MODULE SIX12(DOLLAR,FSAVE,ENTRIES=(SIX12))=
BEGIN


!			DEBUGGING  CONTROL  MODULE
!			--------------------------
!
!
!
!	THIS MODULE  CONTAINS THE DRIVER TO ALLOW INTERACTIVE
!	DEBUGGING OF A BLISS PROGRAM. ESSENTIALLY THE SERVICE
!	PROVIDED BY THIS MODULE IS:
!
!
!		1. MONITOR THE TTY TO ALLOW THE USER TO 'INTERRUPT'
!		   HIS PROGRAM AND ENTER THE DEBUGGING MODE.
!		2. PROVIDE ANALYSIS OF THE SYNTAX OF LINES INPUT
!		   TO THE DEBUGGER, AND SWITCHING TO ANY OF SEVERAL
!		   SPECIFIC DEBUG ROUTINES. A FEW GENERALLY USEFUL
!		   DEBUG ROUTINES ARE INCLUDED IN THIS PACKAGE --
!		   THE INTENTION, HOWEVER, IS THAT THE USER WILL
!		   BUILD HIS OWN ROUTINES TAILORED TO THE PROBLEM
!		   AND USE THIS PACKAGE MERELY TO PROVIDE A STANDARD  
!		   INTERFACE.
!
!
!
!	THE SYNTAX OF INPUT LINES IS:
!
!!	<LINE> == <EMPTY>/<ROUTINE><PARM-LIST>
!	<ROUTINE> == <* ANY PRINT STRING WITHOUT EMBEDDED BLANKS *>
!	<PARM-LIST> == <EMPTY>/<PARM>/<PARM-LIST>,<PARM>
!	<PARM> == <EMPTY>/<ATOM>/<PARM>+<ATOM>/<PARM>-<ATOM>
!	<ATOM> == <NUMBER>/<DDT-NAME>/*/&/.<ATOM>/
!		  <ATOM>[<PARM>]/(<PARM>)
!	<NUMBER> == <INPUT-BASE-NUMBER>/#<OCTAL-NUMBER>/#<DECIMAL-NUMBER-IF-INPUT-BASE-OCTAL>
!	<DDT-NAME> == <IDENTIFIER>/<IDENTIFIER>(<NUMBER>)
!
!
!	FOR EXAMPLE, THE FOLLOWING ARE VALID LINES:
!
!		=  X,.X,.13
!		 :=   X(3),2
!		GLOP^ 3,#14,.X[.Y],*+1
!		THUD  .(Z[.X+1-.P]-.Y),46
!
!
!
!	THE INTENDED INTERPRETATION OF AN INPUT LINE IS THAT THE
!	NAMED DEBUGGING ROUTINE BE CALLED AND THE SPECIFIED
!	PARAMETER VALUES PASSED TO IT. THE INTERPRETATION
!	OF THE VARIOUS ATOMS IS:
!
!		1. DECIMAL AND OCTAL CONSTANTS REPRESENT THEMSELVES
!		2. DDT-NAMES ARE LOOKED UP IN THE DDT SYMBOL TABLE,
!		   THE INTERPRETATION OF SUCH NAMES IS AS IN BLISS -
!		   THAT IS, THEY ARE AN ADDRESS!
!		3. THE SYMBOL "*" IS THE VALUE OF THE POSITIONALLY
!		   CORRESPONDING PARAMETER ON THE IMMED. PREVIOUS
!		   DEBUG LINE.
! %TYM%         4. THE SYMBOL "&" IS THE ADDRESS OF A SPECIAL
!		   "RESULT AREA" -- MAY BE USED BY SOME SPECIFIC
!		   DEBUG ROUTINES. DISPLACEMENTS FROM THE "RESULT AREA" MAY
!		   BE ADDRESSED FOR CONVENIENCE AS $N WHERE N IS A NUMBER.
!		5. THE "." OPERATOR IS INTERPRETED AS THE "@" IN BLISS.
!		6. THE SYMBOLS "[" AND "]" DENOTE INTEGRAL WORD 
!		   DISPLACEMENTS -- IE, E1[E2] = (E1+E2).
!               7. SYMBOLS OF THE FORM <NAME>(<POSITIVE-INTEGER>)
!                  DENOTE THE VALUE OF THE NTH SYMBOL TABEL ENTRY
!                  FOR THE <NAME>.  SEE THE PRS COMMAND FOR LISTING
!                  ALL ENTRIES TO FIND THE ONE YOU WANT.
!
!
!	NOTE:
!	IF, AT ANY TIME DURING EXECUTION (AFTER AN ENABLE COMMAND), ANY CHARACTER IS
!	TYPED ON THE TTY THE DEBUG PACKAGE WILL SHORTLY INTERCEPT
!	CONTROL AND WAIT FOR THE USER TO COMPLETE THE DEBUG LINE.
!
!
!
!	USER-SPECIFIC DEBUGGING ROUTINES MAY BE EASILY ADDED TO
!	THE COLLECTION CURRENTLY PROVIDED AS FOLLOWS:
!		
!		1. WRITE THE ROUTINE TO ACCEPT ITS INPUT PARAMETERS
!		   FROM THE ARRAY "DEBUGPARMS". NOTE THENUMBER OF PARMS
!		   IS IN "NDEBUGPARMS".
!		2. ADD TO THE PLIT, "DEBUGROUTS", A PRINT-NAME AND
!		   THE ACTUAL ROUTINE NAME.
!
!
!	THE SET OF DEBUG ROUTINES PROVIDED IN THIS VERSION ARE:
!
!		= P1,...,PN	PRINT THE VALUES OF P1,...,PN
!		/ P1,P2		PRINT THE VALUES OF P1,...,P1+P2-1
! %TYM%                         P2 DEFAULTS TO 1 IF IT IS OMITTED
!		 :=  P1,P2		ASSIGN P1 := P2
!               " P1,P2         PRINT P2 SUCCESSIVE WORDS IN ASCII STARTING
!                               AT P1 USING BLISS CONVENTION FOR CONTROL CHARS.
!                               P2 DEFAULTS TO 1 IF IT IS MISSING.  IF BIT 35
!                               IS ON IN A WORD ' /1' IS PRINTED AFTER IT.
!		<EMPTY>		NO ACTION
!		DDT		CALL DDT (IN CMU-DDT AN $P IN
!				DDT WILL CAUSE RESUMPTION IN DEBUG MODE)
!		GO		RESUME EXECUTING USER PROGRAM
!		BREAK P1,...,PN SET BREAK POINTS AT THE HEADS OF
!				ROUTINES P1,...,PN. THIS IS A BREAK
!				TO THIS DEBUG SYSTEM (NOT DDT).
!		DBREAK P1,..,PN REMOVE BREAK POINTS SET AS ABOVE.
!		ABREAK P1,,,PN	SET BREAK POINTS AT THE EXIT OF ROUTINES
!				P1,,,PN. THIS IS A BREAK TO THE DEBUG
!				SYSTEM (NOT DDT). THE VREG IS PRINTED.
!		DABREAK P1,,,PN	REMOVE ABREAK POINTS SET AS ABOVE.
!		CALLS		DISPLAY THE STACK OF ROUTINE CALLS
!		CALL+		DISPLAY CALL STACK AND LOCALS --
!				THE LATTER MAY NOT BE VERY USEFUL
!				UNLESS THE USER IS VERY FAMILIAR
!				WITH THE BLISS RUN-TIME ENVIRONMENT.
!		CALL N		PRINT THE LAST N CALLS ON STACK. IF
!				IF N IS OMITTED, PRINT LAST CALL.
!		LCALL N		SAME AS ABOVE BUT ALSO DISPLAYS LOCALS.
!		IBASE N		SETS THE INPUT NUMBER BASE TO N (N IS ALWAYS DECIMAL)
!				(1<N<11). NOTE THAT # IMMEDIATELY
!				PRECEEDING A NUMBER ALWAYS MEANS OCTAL
!				INPUT EXCEPT WHEN THE DEFAULT BASE IS
!				OCTAL, IN WHICH CASE # MEANS DECIMAL.
!				IF N IS OMITTED IT PRINTS THE CURRENT
!				INPUT BASE IN DECIMAL.
!		OBASE N		SETS THE OUTPUT NUMBER BASE TO N (N IS ALWAYS DECIMAL)
!				(1<N<11). IF N IS OMITTED IT PRINTS
!				THE OUTPUT BASE IN DECIMAL.
!		WBASE N		SETS THE MAXIMUM SIZE OF DISPLACEMENT
!				THAT WILL BE PRINTED IN 'BASE+DISPLACEMENT'
!				OUTPUT TO N. (W IS FOR WULF FOR HISTORICAL
!				REASONS.)  INITIALLY SET 1000(OCTAL).
!				IF N IS OMITTED, THE CURRENT WBASE IS
!				PRINTED IN THE CURRENT OUTPUT BASE.
!		SETTRACE	TURNS ON TRACE MODE. WILL DISPLAY
!				CALL STACK FOR ROUTINES AS THEY
!				ARE ENTERED AND LEFT.
!		TRACE		EQUIVALENT TO SETTRACE + GO.  EXECUTION
!				IS RESUMED IN TRACE MODE.  TRACE MODE
!				ENDS WHEN ANYTHING IS TYPED AT THE TERMINAL
!				OR A BREAK POINT IS REACHED.
!		EX P1,...,PN	CALL THE PROCEDURE NAMED P1 WITH
!				PARAMETERS P2,...,PN. (N<6)
!				RETURNS THE VALUE IN "$".
!		EV P1,...,PN	CALL THE PRECEDURE NAMED P2 WITH
!				PARAMETERS P3,...,PN. (N<7)
!				THE VALUE IS PLACED IN THE LOCATION 
!				SPECIFIED BY P1.
!		PRS P1,,,PN	PRINTS A LIST OF ALL DDT SYMBOL TABLE
!				ENTRIES FOR P1,,,PN.
!		DISABLE		TURNS OFF TYPEIN MONITORING, ALLOWS TYPE-AHEAD.
!				THIS IS THE STATE AT STARTUP
!	        ENABLE          TURNS ON TYPEIN MONITORING (RELATIVELY EXPENSIVE)
!		OPAQUE P1,..,PN	MAKES THE NAMED ROUTINES OPAQUE TO TRACING,
!				I.E., IF THE ROUTINE IS ENTERED WITH TRACING TURNED
!				ON, TRACING IS TURNED OFF UNTIL THE MATCHING ROUTINE
!				EXIT IS ENCOUNTERED.  ALL OPAQUE FLAGS ARE RESET IF
!				A BREAK OR TTY INTERUPT OCCURS.
!		DOPAQUE P1,.,PN	UNDOES THE EFFECT OF OPAQUE, I.E. THE
!				NAMED ROUTINES ARE NO LONGER OPAQUE.
!		MONITOR P1,,PN	MONITORS THE LOCATIONS P1,,PN. IF
!				VALUE CHANGES, TELLS WHERE AND HOW.
!		DMONITOR P1,,PN	TURNS OFF MONITORING.
!               PAUSE           CAUSES SIX12 TO BREAK AT OVERLAY TRANSITIONS
!               DPAUSE          TURNS OFF BREAKING AT OVERLAYS
!
!
!
!	NOTE:
!	    IN ORDER TO USE THIS PACKAGE THE MODULES TO BE
!	DEBUGGED MUST BE COMPILED WITH THE PROPER COMPILATION
!	CONTROL, NAMELY:
!
!		1. "TIMER=EXTERNAL(SIX12)" MUST APPEAR IN THE MODULE HEAD.
!		2. EITHER "/F/T" MUST BE USED IN THE COMMAND STRING,
!		   OR "FSAVE,TIMING" MUST APPEAR IN THE MODULE HEAD.
!
!	USE NOTES:
!
!	    1.  DIFFERENT EFFECTS CAN BE CREATED FOR EXECUTION BY USE OF THE
!               TYMEX COMMANDS EXECUTE, TRY AND DEBUG:
!                 EXECUTE - LOADS AND RUNS THE PROGRAM WITH SIX12, BUT NO SYMBOLS
!                 TRY     - LOADS AND TRANSFERS CONTROL TO SIX12 WITH SYMBOLS
!                 DEBUG   - LOADS AND TRANSFERS CONTROL TO DDT.  ;G WILL GO
!                           TO SIX12 COMMAND LEVEL.
!
!           2.  SIXGO;G WILL RETURN TO SIX12 IF DDT HAS BEEN CALLED
!                   FROM SIX12.





!
!
!
!
!
! INPUT-OUTPUT FOR PDP-10 DEBUGGING (ALL TTY I/O)
! -----------------------------------------------

MACHOP TTCALL=#51, CALLI=#47;
%TYM%
MACRO ADDROK(AD)=(IF AD LEQ .JOBREL
                        THEN 1
                        ELSE AD GEQ #400000 AND AD LEQ .JOBHRL<0,18>)&;
%TYM%
BIND NDPARMS=20;


OWN ENTYP,NULLSTE[2];
%  THESE ARE THE ENTRY CODES USED BY THE COMPILER TO TELL SIX12 WHAT
   THE CURRENT CALL IS FOR.  IT IS STORED IN ENTYP.
%
BIND SINIT=1^35, SRENT=0, SREXIT=#777777^18, SSTOP=#377777^18, SCALL=-1;
EXTERNAL JOBSYM,JOBREL,JOBHRL;

OWN	GOFLG,CHAR,TYPE,NC,ACCUM[2],PACCUM,VAL,ERRORFLG,PINDEX,
	BUFF[30],PBUFF,NDEBUGPARMS,VVR,TRACEFLG,RTYPE,ENABFLG,
	DEBUGPARMS:DEBUGRESULTS:OLDPARMS[NDPARMS];
OWN	ROUTS[50],NROUTS;
OWN	OLDVALS[50],NVALS;
OWN	OPQCNT,ENTCNT,INITED,PAUSEF,MAXSTACK;
OWN DBASE,IDBASE,WDBASE;

BIND CRLFSTR=PLIT '?M?J';	! STRING FOR CRLF MACRO

MACRO 	INC=(REGISTER Q; TTCALL(4,Q); .Q)&,
	OUTC(Z)=(REGISTER Q; Q := (Z); TTCALL(1,Q))&,
	OUTSA(Z)=TTCALL(3,Z)&,
	OUTS(Z)=OUTSA(PLIT ASCIZ Z)&,
	OUTM(C,N)=DECR I FROM (N)-1 TO 0 DO OUTC(C)&,
	CR=OUTC(#15)&,
	LF=OUTC(#12)&,
	NULL=OUTC(0)&,
	CRLF=OUTSA(CRLFSTR)&,
	TAB=OUTC(#11)&,
	OUTDEFAULT(Z)=OUTN(Z,.DBASE,1)&,
	OUTRDEF(Z,R)=OUTN(Z,.DBASE,R)&,
	OUTD(Z)=OUTN(Z,10,1)&,
	OUTO(Z)=OUTN(Z,8,1)&,
	OUTDR(Z,N)=OUTN(Z,10,N)&,
	OUTOR(Z,N)=OUTN(Z,8,N)&;

ROUTINE OUTN(NUM,BASE,REQD)=
    BEGIN OWN N,NNP,B,RD,T;
    ROUTINE XN=
	BEGIN LOCAL R;
	IF .N EQL 0 THEN RETURN(OUTM(" ",.RD-.T);IF .NNP THEN OUTC("-"));
	R := .N MOD .B; N := .N/.B; T := .T+1; XN(); OUTC(.R+"0")
	END;
    IF .NUM LSS 0 THEN NNP := T := 1 ELSE NNP := T := 0;
    B := .BASE; RD := .REQD; N := ABS(.NUM); 
    IF .N NEQ 0 THEN XN() ELSE
	(OUTM(" ",.RD-1); OUTC("0"));
    END;

ROUTINE OUTWD(WORD)=
    BEGIN
    LOCAL PTR,CHAR;
    PTR := WORD<36,7>;
    DECR I FROM 4 TO 0
    DO
      IF (CHAR := SCANI(PTR)) EQL "??"
        THEN OUTS('????')
      ELSE IF .CHAR EQL "?0"
        THEN OUTS('??0')
      ELSE IF .CHAR EQL "?1"
        THEN OUTS('??1')
      ELSE IF .CHAR LSS #40
        THEN (OUTC("??"); OUTC(.CHAR+#100))
      ELSE OUTC(.CHAR);
    IF .WORD
      THEN OUTS(' /1')
    END;



!!!!!   INTERACTIVE DEBUGGING INTERFACE AND SUPPORT   !!!!!!
!       -------------------------------------------


FORWARD ERROR;

%  THE FOLLOWING IS THE STRUCTURE FOR THE SYMBOL TABLE ENTRIES AS FAR AS
   SIX12 CARES.
%
STRUCTURE STE[FIELD]=
   CASE .FIELD OF SET
%R50NAME%  (@.STE+0)< 0,32>;
%STYPE  %  (@.STE+0)<32, 2>;
%OUTKILL%  (@.STE+0)<35, 1>;
%SVALUE %  (@.STE+1)< 0,36>;
   TES;

BIND R50NAME=0, STYPE=1, OUTKILL=2, SVALUE=3,
     MODNAME=0, GLOBS=1, LOCS=2;


ROUTINE CLEANST=
   BEGIN

   ROUTINE GOTDOT(SYM)=
      BEGIN
      IF .SYM EQL 0 THEN RETURN 0;
      WHILE .SYM MOD #50 EQL 0
      DO SYM := .SYM/#50;
      IF (SELECT .SYM MOD #50 OF NSET
           RADIX50 "G": 1;
           RADIX50 "0": 1;
           RADIX50 "O": 1;
           OTHERWISE: 0 TESN)
         THEN (.SYM/#50) MOD #50 EQL RADIX50 "."
         ELSE 0
      END;

   REGISTER STE R;
   R := .JOBSYM;
   WHILE (R := .R+#2000002) LSS 0
   DO IF .R[STYPE] EQL GLOBS
         THEN IF GOTDOT(.R[R50NAME])
                 THEN R[OUTKILL] := 1;
   END;


ROUTINE SDDTFA(X)=
    BEGIN REGISTER STE R; EXTERNAL JOBSYM;
    ! GIVEN A SYMBOL, SEARCH DDT SYMBOL-TABLE FOR ITS ADDRESS
    R := .JOBSYM;
    WHILE (R := .R+#2000002) LSS 0 DO
	IF .R[R50NAME] EQL .X THEN RETURN .R[SVALUE];
    0
    END;


ROUTINE NSDDTFA(X,V)=
    BEGIN REGISTER STE R;
    ! GIVEN A SYMBOL SEARCH FOR THE ADDRESS OF ITS NEXT OCCURANCE
    ! STARTING AT .V
    R := .V;
    WHILE (R := .R+#2000002) LSS 0 DO
	IF .R[R50NAME] EQL .X THEN RETURN .R;
    0
    END;

ROUTINE SDDTFS(X)=
    BEGIN EXTERNAL JOBSYM; REGISTER STE R:N;
    ! GIVEN AN ADDRESS, SEARCH DDT SYMBOL-TABLE FOR THE SYMBOL
    N := NULLSTE<0,0>; R := .JOBSYM; % SET UP DUMMY STE FOR FIRST TIME %
    WHILE (R := .R+#2000002) LSS 0 DO
        IF .R[SVALUE] LEQ .X
           THEN IF .R[SVALUE] GEQ .N[SVALUE]
              THEN IF NOT .R[OUTKILL]
                 THEN IF .R[STYPE] NEQ MODNAME
                    THEN IF .R[R50NAME] GTR 0
                       THEN N := .R;
    .N
    END;


ROUTINE MODDDT(X)=
    BEGIN
    REGISTER R;
    ! GIVEN A START ADDRESS X FIND FIRST MODULE NAME
    R := .X;
    WHILE (R := .R+#2000002) LSS 0
	DO IF .R[STYPE] EQL MODNAME THEN RETURN @.R;
    @(.R-2)
    END;


    ! CONVERT BASE 50 CHARACTER TO ASCII CHARACTER
MACRO F50TO7(X)=
  (IF .X EQL 0 THEN 0
  ELSE IF .X EQL RADIX50 "." THEN "."
  ELSE IF .X EQL RADIX50 "$" THEN "$"
  ELSE IF .X EQL RADIX50 "%" THEN "%"
  ELSE IF .X LEQ RADIX50 "9" THEN .X - RADIX50 "0" + ASCII "0"
  ELSE .X - RADIX50 "A" + ASCII "A"  )&;

% CONVERT THE RADIX50 SYMBOL X TO ASCII APPENDING TO THE STRING
  AT LOCATION A.
%
ROUTINE R50TOA(X,A)=
  BEGIN
  REGISTER PTR;

  ROUTINE N50C(S)=
    IF .S NEQ 0
      THEN BEGIN LOCAL C;
        C := .S MOD #50;
        N50C(.S/#50);
        REPLACEI(PTR, F50TO7(C)) END;

  PTR := (.A)<36,7>;
  N50C(.X)
  END;

    ! CONVERT ASCII CHARACTER TO BASE 50 CHARACTER
MACRO F7TO50(X)=
  (IF .X EQL 0 THEN 0
  ELSE IF .X EQL "." THEN RADIX50 "."
  ELSE IF .X EQL "$" THEN RADIX50 "$"
  ELSE IF .X EQL "%" THEN RADIX50 "%"
  ELSE IF .X GEQ "0" AND .X LEQ "9" THEN .X - ASCII "0" + RADIX50 "0"
  ELSE IF .X GEQ "A" AND .X LEQ "Z" THEN .X - ASCII "A" + RADIX50 "A"
  ELSE 0) &;


ROUTINE BASE50(X)=
    BEGIN
    LOCAL PTR,N,Z,Q;
    ! GET BASE 50 REPRESENTATION OF SYMBOL @.X
    Z := N := 0; PTR := (.X)<36,7>;
    WHILE (Q := SCANI(PTR)) NEQ 0 DO 
%1%	IF (N := .N+1) LEQ 6 THEN Z := #50*.Z+F7TO50(Q);
    .Z
    END;

ROUTINE PRSYM50(X)=
    BEGIN LOCAL R[2];
    R[0] := R[1] := 0; R50TOA(.X<0,32>,R<0,0>); OUTSA(R) END;

ROUTINE PRDISP(X)=
%1%    BEGIN EXTERNAL JOBDDT;
    ! PRINT BOTH HALVES OF .X IN "BASE+DISP" FORM
%1%	ROUTINE PRDISPH(Z)=
		    BEGIN
%1%		    REGISTER L,M;
%1%		    IF .Z LSS .JOBDDT<18,18> THEN RETURN OUTDEFAULT(.Z);
		    L := SDDTFS(.Z);  M := .Z<0,18>-@(.L+1);
%1%		    IF .M GEQ .WDBASE THEN OUTDEFAULT(.Z)
			ELSE
			BEGIN
			PRSYM50(@@L);
			IF .M NEQ 0 THEN ( OUTC("+"); OUTDEFAULT(.M))
%1%			END
		    END;
%1%  IF .X<18,18> NEQ 0
%1%	THEN (PRDISPH(.X<18,18>); OUTS(',,'));
%1%  PRDISPH(.X<0,18>);
    END;

ROUTINE PRXDISP(X)=
    ! PRINT ONLY BASE OF .X<0,18>
%1%  PRSYM50(@SDDTFS(.X<0,18>));


ROUTINE PRG(B,T)=
    ! PRINT A CONT. SET OF WORDS FOR STACK DISPLAY
    BEGIN
    INCR I FROM 1 TO .T DO
	BEGIN 
        TAB;
%1%	OUTDEFAULT(.I); OUTS(': '); PRDISP(@(.B+.I-1));
%1%	IF NOT(.I) AND .I LSS .T  THEN CRLF;
	END;
    IF .T NEQ 0 THEN CRLF;
    END;

%  DISPLAY THE CALL STACK.  TOG CONTROLS THE DISPLAY OF LOCAL INFO.
   THE ROUTINE ASUMES THE FREG CHAIN ENDS IN 0.  THE NUMBER
   OF PARAMETERS IS FOUND BY LOOKING AT THE SUBTRACT INSTRUCTION FOLLOWING
   A CALL.  THIS IS SOMETIMES WRONG AS THE COMPILER WILL COMBINE A BLOCK
   EXIT WITH ADJUSTING THE STACK FOR A ROUTINE CALL.
%
ROUTINE PRCALL(CALLER,F,I,TOG)=
  BEGIN
  LOCAL CALLEE,NP,NL;
  NP := 1+(.ENTYP EQL SREXIT);  % THE CALL TO SIX12 LIES ABOVE US %
  UNTIL (NL := @F-@@F-.NP-2; F := @@F) EQL 0 OR (I := .I-1) LSS 0
  DO BEGIN
    CALLEE := .CALLER;
    IF @@F EQL 0
      THEN CALLER := NP := 0
      ELSE BEGIN
        CALLER := .(@F-1)<0,18>;
        NP := IF .(.CALLER)<23,13> NEQ (#274^4 OR SREG<0,0>)   % SUB SREG,[...] %
              THEN 0
              ELSE .(@@CALLER)<0,18>;
        CALLER := .CALLER-1 END;
    PRXDISP(.CALLEE); OUTS('?I(_');
    IF .CALLER EQL 0
      THEN OUTS('****')
      ELSE PRDISP(.CALLER);
    OUTC(")");
    PRG(.F-1-.NP,.NP);
    IF .NP EQL 0
       THEN CRLF;
    IF .TOG
       THEN BEGIN
          OUTS('?IBASE: '); PRDISP(.F); CRLF;
          PRG(@F+1,.NL)  END;
    END;
  END;


ROUTINE PSTK(TOG)=
  BEGIN LOCAL F;
  F := @@@@@FREG;   % THIS SHOULD NOW BE SIX12'S FREG %
  PRCALL(.(@F-1)<0,18>-1,@F,.DEBUGPARMS[1],.TOG);
  CRLF;
  END;





! THE DEBUG PROCESSING ROUTINES
!-------------------------------





ROUTINE XNULL=.VREG;

ROUTINE EDDT=
	BEGIN EXTERNAL JOBOPC,JOBDDT; MACHOP JRST=#254;
	JOBOPC := XNULL<0,0>+1;
        IF .JOBDDT NEQ 0
	   THEN JRST(0,@JOBDDT)
           ELSE OUTS('NO DDT?M?J');
	END;

ROUTINE DISPLAY=
	BEGIN
	INCR I FROM 1 TO .NDEBUGPARMS DO 
	    (OUTRDEF(.DEBUGPARMS[.I],12); TAB; PRDISP(.DEBUGPARMS[.I]); CRLF);
	END;

ROUTINE SLASH=
%1%	BEGIN
%TYM%   LOCAL A,LAST;
%TYM%   A := .DEBUGPARMS[1];
%TYM%   LAST := .A + (IF .NDEBUGPARMS LSS 2
%TYM%                THEN 0
%TYM%                ELSE .DEBUGPARMS[2]-1);
%TYM%   IF ADDROK(.A) AND ADDROK(.LAST)
%TYM%      THEN
%1%             DO BEGIN
%1%	           PRDISP(.A);OUTS('/');TAB;
%1%	           OUTDEFAULT(@(.A)); TAB; PRDISP(@(.A));
%1%	           CRLF;
%1%                END
                UNTIL (A := .A+1) GTR .LAST
%TYM%      ELSE ERROR(7)
%1%
	END;



!!  DEBUG INTEREST ROUTINES  !!
!   -----------------------

!	THE VECTOR ROUTS CONTAINS INFORMATION ABOUT EACH ROUTINE
!	IN WHICH THE DEGUG SYSTEM IS 'INTERESTED'.  THE VARIABLE
!	NROUTS (INITIALIZED TO -1) CONTAINS THE INDEX OF THE LAST
!	VALID ENTRY IN ROUTS.  THE STRUCTURE OF EACH ENTRY IN ROUTS
!	IS
!		!------------------+------------------!
!		! INTEREST BITS    !  ROUTINE ADDRESS !
!		!------------------+------------------!
!
!	TWO VALUES ARE ASSOCIATED WITH EACH BIT IN THE INTEREST BITS
!	FIELD.  IF BIT (35-N) INDICATES AN ABC TYPE INTEREST, THEN
!	ABCF IS A MACRO FOR THE BIT POSITION IN THE WORD,I.E. N,1.
!	ABCV IS A CONSTANT WITH A 1 IN THE CORRESPONDING BIT, I.E. 1^N.
!
!	THE MACRO SETBIT(VAL) PERFORMS THE FOLLOWING ACTIONS
!	FOR EACH ROUTINE IN DEBUGPARMS:
!		1) INSERT THE ROUTINE INTO ROUTS IF IT IS NOT
!		   ALREADY THERE. (CINSERT()).
!		2) TURNS ON THE INTEREST BITS INDICATED BY VAL.
!
!	THE MACRO UNSETBIT(VAL) DOES THE FOLLOWING FOR EACH ROUTINE
!	IN DEBUGPARMS:
!		1) TURN OF THE INTEREST BITS INDICATED BY VAL.
!		2) IF THE INTEREST BIT FIELD OF ANY ENTRY BECOMES
!		   ZERO, REMOVE THAT ENTRY FROM ROUTS.


STRUCTURE XVECTOR[I,J,K]=(.XVECTOR+.I)<.J,.K>;

MACRO BITFLD(N)=N,1&,
      BITVAL(N)=1^(N)&;

! BIT FIELD DEFINITIONS

MACRO
	BREAKF=BITFLD(18)&,
	ABREAKF=BITFLD(19)&,
	OPQF=BITFLD(20)&,
	IDIDITF=BITFLD(21)&,
	VCHGF=BITFLD(22)&;


BIND
	BREAKV=BITVAL(18),
	ABREAKV=BITVAL(19),
	OPQV=BI20),
	IDIDITV=BITVAL(21),
	VCHGV=BITVAL(22);


MACRO SETBIT(VAL)=
	BEGIN
	LOCAL L;
%1%	DECR I FROM .NDEBUGPARMS TO 1 DO
	    (L := CINSERT(.DEBUGPARMS[.I]);
	     ROUTS[.L] := .ROUTS[.L] OR (VAL);
             IF (VAL) EQL VCHGV
                THEN
%TYM%         ( MAP XVECTOR ROUTS; LOCAL AD;
%TYM%           AD := .ROUTS[.L,0,18];
%TYM%           IF ADDROK(.AD)
%TYM%              THEN OLDVALS[.L] := @@AD
%TYM%              ELSE ERROR(7)    ));
	END&;

MACRO UNSETBIT(VAL)=
	BEGIN
%1%	DECR I FROM .NDEBUGPARMS TO 1 DO CREMOVE(.DEBUGPARMS[.I],(VAL));
	END&;

ROUTINE CFINDR(R)=	! CONDITIONAL FIND
	! RETURN THE INDEX OF ROUTINE R IN ROUTS.  -1 IF NOT FOUND
	BEGIN
	MAP XVECTOR ROUTS;
	R := .R<0,18>;
%1%	DECR I FROM .NROUTS TO 0 DO
	    IF .ROUTS[.I,0,18] EQL .R THEN RETURN .I;
	-1
	END;

ROUTINE CINSERT(R)=	! CONDITIONAL INSERT
	! RETURN THE INDEX OF R IN ROUTS. INSERT IF NECESSARY
	BEGIN
	LOCAL L;
	IF (L := CFINDR(.R)) GEQ 0 THEN RETURN .L;
	ROUTS[NROUTS := .NROUTS+1] := .R<0,18>;
	.NROUTS
	END;

ROUTINE CREMOVE(R,VAL)=	! CONDITIONAL REMOVE
	! TURN OF BITS SPECIFIED BY VAL IN THE ENTRY FOR R.
	! DELETE R IF POSSIBLE.
	BEGIN
	LOCAL L;
	MAP XVECTOR ROUTS;
	IF (L := CFINDR(.R)) LSS 0 THEN RETURN;
	ROUTS[.L,0,36] := .ROUTS[.L,0,36] AND NOT .VAL;
	IF .ROUTS[.L,18,18] EQL 0 THEN
	    (ROUTS[.L,0,36] := .ROUTS[.NROUTS,0,36];
	     NROUTS := .NROUTS-1  );
	END;


ROUTINE CKVALS(RTN,TOG)=
	BEGIN
%1%	MAP XVECTOR ROUTS;REGISTER X;
%1%	DECR I FROM .NROUTS TO 0 
	    DO IF .ROUTS[.I,VCHGF]
		THEN BEGIN
%TYM%                   X := .ROUTS[.I,0,18];
%TYM%                   IF ADDROK(.X)
%TYM%                      THEN X := @@X
%TYM%                      ELSE RETURN ERROR(7);
			IF .X NEQ .OLDVALS[.I]
			    THEN BEGIN
				IF .TOG GEQ 0
				    THEN BEGIN
					OUTS('*** ');
					IF .TOG THEN OUTS('DURING ')
						ELSE OUTS('BEFORE ');
					TOG := -1;
					PRXDISP(.RTN);
					CRLF;
					END;
				PRDISP(.ROUTS[.I,0,18]);
				TAB;
				OUTS('OLD: ');
				OUTDEFAULT(.OLDVALS[.I]);
				TAB;
				OUTS('NEW: ');
				OUTDEFAULT(.X);
				CRLF;
				OLDVALS[.I] := .X;
				END;
		END;
	END;



ROUTINE XBREAK=SETBIT(BREAKV);

ROUTINE XABREAK=SETBIT(ABREAKV);

ROUTINE DBREAK=UNSETBIT(BREAKV);

ROUTINE DABREAK=UNSETBIT(ABREAKV);

ROUTINE OPAQUE=SETBIT(OPQV);

ROUTINE DOPAQUE=UNSETBIT(OPQV);

ROUTINE XCHNG=(SETBIT(VCHGV);NVALS := .NVALS+.NDEBUGPARMS);
ROUTINE DCHNG=(UNSETBIT(VCHGV);NVALS := .NVALS-.NDEBUGPARMS);


!-----------------


ROUTINE DOOPQ(TOG,W)=
	BEGIN
	MAP XVECTOR ROUTS;
	IF .TOG EQL 0 THEN
	    BEGIN
	    IF .TRACEFLG THEN
		BEGIN
		ROUTS[.W,IDIDITF] := 1;
		TRACEFLG := 0;
		OPQCNT := 1;
		OUTS('...'); CRLF
		END
	    ELSE
		IF .ROUTS[.W,IDIDITF] THEN OPQCNT := .OPQCNT+1
	    END
	ELSE
	    BEGIN
	    IF .ROUTS[.W,IDIDITF] THEN
		IF (OPQCNT := .OPQCNT-1) LEQ 0 THEN
		    (TRACEFLG := 1; ROUTS[.W,IDIDITF] := 0)
	    END
	END;



ROUTINE UNDOOPQ=
	BEGIN
	MAP XVECTOR ROUTS;
	IF .OPQCNT LEQ 0 THEN RETURN;
	OPQCNT := 0;
%1%	DECR I FROM .NROUTS TO 1 DO
	    IF .ROUTS[.I,IDIDITF] THEN RETURN ROUTS[.I,IDIDITF] := 0;
	END;

ROUTINE GOER= GOFLG := 1;

ROUTINE DISAB=ENABFLG := 0;

ROUTINE ENAB = ENABFLG := 1;
ROUTINE XSTRACE=TRACEFLG := 1;

ROUTINE XTRACE=(XSTRACE(); GOER());

ROUTINE PAUSE = PAUSEF := 1;

ROUTINE DPAUSE = PAUSEF := 0;

ROUTINE SETIT=
	IF .NDEBUGPARMS LSS 2
                THEN ERROR(6)
        ELSE IF .DEBUGPARMS[1] GTR .JOBREL
                THEN ERROR(7)
        ELSE (.DEBUGPARMS[1])<0,36> := .DEBUGPARMS[2];

ROUTINE SETBASE(TOG)=
    BEGIN
    IF .NDEBUGPARMS GTR 0 THEN
	IF (.DEBUGPARMS[1] LSS 2) OR (.DEBUGPARMS[1] GTR 10)
	    THEN RETURN ERROR(8)
	    ELSE IF .TOG THEN IDBASE := .DEBUGPARMS[1]
		ELSE DBASE := .DEBUGPARMS[1];
    OUTD(IF .TOG THEN .IDBASE ELSE .DBASE);
    CRLF;
    END;

ROUTINE M1=SETBASE(1);

ROUTINE M0=SETBASE(0);


ROUTINE XWBASE=
	BEGIN
	IF .NDEBUGPARMS GTR 0 THEN
	    WDBASE := .DEBUGPARMS[1];
	OUTDEFAULT(.WDBASE);
	CRLF;
	END;

ROUTINE C1=(DEBUGPARMS[1] := #377777777777;PSTK(0));

ROUTINE C2=(DEBUGPARMS[1] := #377777777777;PSTK(1));

ROUTINE XCALL=
    BEGIN
    IF .NDEBUGPARMS EQL 0 THEN DEBUGPARMS[1] := 1;
    PSTK(0)
    END;

ROUTINE XLCALL=
    BEGIN
    IF .NDEBUGPARMS EQL 0 THEN DEBUGPARMS[1] := 1;
    PSTK(1)
    END;



ROUTINE EXXX=
    BEGIN 
    MACRO P(X)=(.DEBUGPARMS[X])&;
%1%    REGISTER SAVEGO;
    SAVEGO := .GOFLG;
    GOFLG := 1;
%1%    DEBUGRESULTS := CASE .NDEBUGPARMS OF
	SET
	0;
	P(1)();
	P(1)(P(2));
	P(1)(P(2),P(3));
	P(1)(P(2),P(3),P(4));
	P(1)(P(2),P(3),P(4),P(5));
	P(1)(P(2),P(3),P(4),P(5),P(6));
	TES;
    GOFLG := .SAVEGO;
%1%    .DEBUGRESULTS
    END;

ROUTINE EXV=
    BEGIN
    LOCAL SAVPARM;
    IF .NDEBUGPARMS LSS 1 THEN RETURN ERROR(6);
    SAVPARM := .DEBUGPARMS[1];
    INCR I FROM 1 TO NDEBUGPARMS := .NDEBUGPARMS-1 DO
	DEBUGPARMS[.I] := .DEBUGPARMS[.I+1];
    (.SAVPARM)<0,36> := EXXX()
    END;



ROUTINE PRS=
    BEGIN
    LOCAL X,V;
    INCR I FROM 1 TO .NDEBUGPARMS DO
	IF .DEBUGPARMS[.I] LSS 0
            THEN BEGIN
                PRSYM50(MODDDT(SDDTFS(.DEBUGPARMS[.I]<0,18>)));TAB;
	       OUTRDEF(.DEBUGPARMS[.I]<0,18>,12);TAB;OUTS('MODULE');CRLF
	  END ELSE
	BEGIN
	V := .JOBSYM;X := SDDTFS(.DEBUGPARMS[.I]);
	INCR J FROM 1 DO
	    BEGIN
	    IF (V := NSDDTFA(.(.X)<0,32>,.V)) EQL 0 THEN EXITLOOP;
	    PRSYM50(@.X);OUTC("(");OUTDEFAULT(.J);OUTC(")");TAB;
	    OUTRDEF(.(.V+1)<0,18>,12);TAB;
	    IF .(.V)<32,2> EQL MODNAME
		THEN OUTS('MODULE')
		ELSE BEGIN
		    CASE .(.V)<32,2> OF
			SET
			0;
			OUTS('GLOBAL');
			OUTS('OWN');
			0;
			TES;
		    TAB;PRSYM50(MODDDT(.V));
		    END;
	    CRLF;
	    END;
	END;
    END;



ROUTINE ASCIIP=
  BEGIN
  LOCAL A,LAST;
  IF .NDEBUGPARMS LSS 1
    THEN RETURN ERROR(6);
  A := .DEBUGPARMS[1];
  LAST := .A + (IF .NDEBUGPARMS EQL 1
                THEN 0
                ELSE .DEBUGPARMS[2]-1);
  IF ADDROK(.A) AND ADDROK(.LAST)
    THEN
      DO BEGIN
        PRDISP(.A); OUTC(""""); TAB;
        OUTWD(@.A); CRLF;
        END
      UNTIL (A := .A+1) GTR .LAST
    ELSE ERROR(7)
  END;


ROUTINE QUIT = CALLI(1,#12);    % DO YE OLDE EXIT %

!! NOTE !! THE PLIT BELOW MAPS PRINT NAME TO ROUTINES
!  ----    ------------------------------------------

BIND DEBUGROUTS= PLIT(
	'?M',	XNULL,
	'=',	DISPLAY,
	'_',	SETIT,
	'/',	SLASH,
        '"',    ASCIIP,
	'DDT',	EDDT,
	'CALLS',C1,
	'CALL+',C2,
	'CALL',	XCALL,
	'LCALL',XLCALL,
	'EX',	EXXX,
	'EV',	EXV,
	'BREAK',XBREAK,
	'DBREA',DBREAK,
	'ABREA',XABREAK,
	'DABRE',DABREAK,
	'IBASE',M1,
	'OBASE',M0,
	'GO',	GOER,
	'SETTR',XSTRACE,
	'TRACE',XTRACE,
	'PRS',	PRS,
	'DISAB',DISAB,
        'ENABL',ENAB,
	'OPAQU',OPAQUE,
	'DOPAQ',DOPAQUE,
	'MONIT',XCHNG,
	'DMONI',DCHNG,
	'WBASE',XWBASE,
        'PAUSE',PAUSE,
        'DPAUS',DPAUSE,
        'QUIT',QUIT,
        'Q',QUIT,
	0,	XNULL);



! ANALYSIS OF DEBUG INPUT LINES
! -----------------------------

ROUTINE ADV=
        BEGIN
        NC := .NC+1; CHAR := SCANI(PBUFF);
        TYPE  := 
            IF .CHAR GEQ "0" AND .CHAR LEQ "9" THEN 0
            ELSE IF .CHAR GEQ "A" AND .CHAR LEQ "Z" THEN 1
            ELSE IF .CHAR GEQ "a" AND .CHAR LEQ "z" THEN (CHAR := .CHAR-#40; 1)
            ELSE IF .CHAR EQL "$" OR .CHAR EQL "%" THEN 1
            ELSE IF .CHAR EQL "#" THEN 3
            ELSE 2
	END;

ROUTINE SCAN=
	BEGIN VAL := ACCUM[0] := ACCUM[1] := 0; PACCUM := ACCUM<36,7>;
	WHILE .CHAR EQL " " DO ADV();
	CASE .TYPE OF
	    SET
	    (WHILE .TYPE EQL 0
                DO (VAL := .VAL*(IF .RTYPE THEN 10 ELSE .IDBASE)+(.CHAR-"0");
                    ADV());
             0);
	    (WHILE  (.TYPE LEQ 1) OR (.CHAR EQL ".")
                DO (REPLACEI(PACCUM,.CHAR); ADV());
             1);
	    2;
	    (ADV();
             WHILE .TYPE EQL 0
             DO (VAL := .VAL*(IF .IDBASE EQL 8 THEN 10 ELSE 8)+(.CHAR-"0");
                 ADV());
             0);
	    TES
	END;

ROUTINE ERROR(EN)=
	BEGIN ERRORFLG := 1; OUTM(".",.NC); OUTC("^"); CRLF;
	CASE .EN OF
	SET
	OUTS('DDT-SYMBOL NOT FOUND');
	OUTS('INVALID ATOM');
	OUTS('INVALID PROCESS NAME');
	OUTS('SQ-BRACKETS NOT MATCHED');
	OUTS('PARENS NOT MATCHED');
	OUTS('ROUTINE NAME NOT FOUND');
	OUTS('INSUFFICIENT ARGUMENTS');
	OUTS('INVALID ADDRESS');
	OUTS('MODE MUST BE BETWEEN 2 AND 10');
	OUTS('NUMERIC ARGUEMENT EXPECTED');
	TES;
	CRLF;
	END;


FORWARD PARM;


    ROUTINE STRNG=
	BEGIN
	LOCAL PTR,X[2];PTR := X<36,7>;X := 0;
%1%	DECR I FROM 9 TO 0 DO
%1%	    IF .CHAR EQL "'" THEN RETURN .X
		ELSE (REPLACEI(PTR,.CHAR);ADV());
	.X
	END;



ROUTINE ATOM=
    BEGIN LOCAL X,Y,V,SACCUM[2]; X := 0;
    WHILE 1 DO
	BEGIN
	Y := CASE SCAN() OF
	    SET
	    .VAL;
	    IF .CHAR NEQ "("
		THEN IF (V := SDDTFA(BASE50(ACCUM))) EQL 0 THEN ERROR(0) ELSE .V
		ELSE BEGIN
		    SACCUM[0] := .ACCUM;SACCUM[1] := .ACCUM[1];
		    ADV();
%1%		    IF SCAN() NEQ 0 THEN RETURN ERROR(9);
%1%		    IF .CHAR NEQ ")" THEN RETURN ERROR(4);
		    ADV();
		    IF .VAL LEQ 0 THEN VAL := 1;
		    V := .JOBSYM;
		    Y := BASE50(SACCUM);
%1%		    DECR I FROM .VAL TO 1 
%1%			DO IF (V := NSDDTFA(.Y,.V)) EQL 0 THEN RETURN ERROR(0);
		    @(.V+1)
		    END;
	    SELECT .CHAR OF
		NSET
%TYM%           ".":(LOCAL A;
%TYM%                   ADV(); A := ATOM();
%TYM%                   IF ADDROK(.A) THEN @@A ELSE ERROR(7));
                "+":(ADV(); ATOM());
		"-":(ADV();-(ATOM()));
		"*":(ADV();.OLDPARMS[.PINDEX]);
		"&":(ADV();SCAN(); DEBUGRESULTS<0,0>+.VAL);
		"(":(ADV(); V := PARM(); IF .CHAR EQL ")" THEN ADV() ELSE ERROR(4); .V);
		"[":0;
		#15:0;
		#12:0;
		",":0;
		"'":(ADV();V := STRNG();IF .CHAR EQL "'" THEN ADV() ELSE ERROR(1);.V);
	    OTHERWISE:(ERROR(1);ADV());
		TESN;
	    TES;
	IF .ERRORFLG NEQ 0 THEN RETURN 0;
	X := .X+.Y;
	IF .CHAR NEQ "[" THEN RETURN .X;
	ADV(); X := .X+PARM();
	IF .CHAR EQL "]" THEN ADV() ELSE ERROR(3);
	IF .ERRORFLG NEQ 0 THEN RETURN 0;
	END;
    END;

ROUTINE PARM=
    BEGIN LOCAL V; V := ATOM();
    WHILE 1 DO
	IF .ERRORFLG NEQ 0 THEN RETURN 0 ELSE
	    SELECT .CHAR OF
		NSET
		#15: RETURN .V;
		#12: RETURN .V;
		",": RETURN .V;
		")": RETURN .V;
		"]": RETURN .V;
		"+": (ADV(); V := .V+ATOM());
		"-": (ADV(); V := .V-ATOM());
	    OTHERWISE:ERROR(1);
		TESN;
    END;


ROUTINE INPUT=
    BEGIN LOCAL X;
    PBUFF := BUFF<36,7>; NC := 0;
    DO (X := INC; REPLACEI(PBUFF,.X)) WHILE .X NEQ #12;
    PBUFF := BUFF<36,7>;
    END;

ROUTINE GETDRNAME=
%1%    BEGIN
    ADV(); ACCUM[0] := ACCUM[1] := 0; PACCUM := ACCUM<36,7>;
%1%    UNTIL .CHAR EQL " " OR
%1%	.CHAR EQL #12 OR
%1%	.CHAR EQL #15 DO
%1%	(IF .NC LSS 10 THEN REPLACEI(PACCUM,.CHAR);ADV());
%1%    DECR I FROM .DEBUGROUTS[-1] TO 0 BY 2 DO
%1%	IF .ACCUM EQL .DEBUGROUTS[.I] THEN RETURN .DEBUGROUTS[.I+1];
%1%  ERROR(5)
    END;


ROUTINE XDEBUG=
%1%    BEGIN REGISTER R;
    PINDEX := 0; ERRORFLG := 0;RTYPE := 0;
    DECR I FROM NDPARMS-1 TO 0 DO DEBUGPARMS[.I] := 0;
    R := GETDRNAME();
    IF (.R<0,18> EQL M1<0,0>) OR (.R<0,18> EQL M0<0,0>) THEN RTYPE := 1;
    IF .ERRORFLG NEQ 0 THEN RETURN;
%1%    UNTIL .CHAR EQL #15 OR .CHAR EQL #12 DO
	    (PINDEX := .PINDEX+1;DEBUGPARMS[.PINDEX] := PARM();
	     IF .CHAR EQL "," THEN ADV());
    NDEBUGPARMS := .PINDEX;
    DECR I FROM NDPARMS-1 TO 0 DO OLDPARMS[.I] := .DEBUGPARMS[.I];
    IF .ERRORFLG EQL 0 THEN (.R)();
    END;

ROUTINE STOPIT=
   BEGIN
   TRACEFLG := 0; UNDOOPQ(); GOFLG := 0  END;

ROUTINE PEEK=
   IFSKIP TTCALL(#14,0)   % INPUT LINE PENDING %
      THEN STOPIT();

ROUTINE COMMAND=
   UNTIL .GOFLG
   DO
      BEGIN
      OUTS('&');
      INPUT();
      XDEBUG()
      END;

FORWARD INITSIX12;


GLOBAL ROUTINE SIX12(XP)=
    BEGIN
    MAP XVECTOR ROUTS;
    BIND ENTRY=3;LOCAL X,P,RNAME;
    EXTERNAL JOBDDT;
    VVR := .VREG;
    IF .SREG GEQ 0
       THEN (OUTS('SREG OVERFLOW DETECTED BY SIX12?M?JDDT:'); EDDT());
    ENTCNT := .ENTCNT+1;
    IF .SREG<0,18> - .BREG GTR .MAXSTACK
       THEN MAXSTACK := .SREG<0,18> - .BREG;
    SELECT ENTYP := .XP OF NSET
   SINIT:  IF NOT .INITED
              THEN BEGIN
                 INITSIX12();
                 IF NOT .GOFLG THEN COMMAND() END
              ELSE BEGIN
                 IF .(#400006)<0,18> GTR #400000
                    THEN JOBSYM := .(#400006)<0,36>; % SET HISEG SYMBOL TABLE %
                 IF .PAUSEF
                    THEN BEGIN
                       CRLF; OUTS('<-> PAUSING:'); CRLF;
                       STOPIT(); COMMAND(); MAXSTACK := 0  END
                 END;
   SRENT:  BEGIN
%1%	    XP := .(.FREG)<0,18>;(.FREG)<0,36> := XP<0,0>; %SIMULATE AN FREG SAVE %
	    RNAME := .(@FREG-1)<0,18>-ENTRY;
	    IF .NVALS GTR 0 THEN CKVALS(.RNAME,0);
	    X := IF .NROUTS GTR -1 THEN CFINDR(.RNAME) ELSE -1;
	    IF .X GEQ 0 THEN IF .ROUTS[.X,BREAKF]
		THEN
                   (CRLF; OUTS('<-> AT: '); PRXDISP(@(.FREG-1)); CRLF;
                     STOPIT());
	    IF .TRACEFLG
               THEN BEGIN
                  OUTS('--> ');
                  PRCALL(.RNAME, @FREG, 1,0) END;
	    IF .X GEQ 0 THEN IF .ROUTS[.X,OPQF] THEN DOOPQ(0,.X);
%1%         IF .ENABFLG THEN PEEK();
            IF NOT .GOFLG THEN COMMAND();
%1%	    (.FREG)<0,36> := .XP<0,18>;
           END;
   SCALL:  BEGIN
           STOPIT();
           COMMAND();
           END;
   SREXIT: BEGIN
	    RNAME := .(@FREG-1)<0,18>;
	    IF .NVALS GTR 0 THEN CKVALS(.RNAME,1);
	    X := IF .NROUTS GTR -1
		THEN CFINDR(IF (X := .(@(@@FREG-1)-1)<0,18>) LEQ .JOBDDT<18,18>
                                THEN @(SDDTFS(.RNAME)+1)
                                ELSE .X)
                ELSE -1;
	    IF .X GEQ 0 THEN IF .ROUTS[.X,ABREAKF]
		THEN (CRLF;OUTS('<-> AFTER: ');PRXDISP(.RNAME);
			TAB;OUTS('VALUE: ');OUTDEFAULT(.VVR);TAB;
			PRDISP(.VVR); CRLF; STOPIT());
	    IF .OPQCNT GTR 0 THEN IF .X GEQ 0 THEN DOOPQ(1,.X);
	    IF .TRACEFLG
                THEN
                   (OUTS('<-- '); PRXDISP(.RNAME); TAB; OUTS('VALUE: ');
                    OUTDEFAULT(.VVR); CRLF);
	    IF .ENABFLG THEN PEEK();
            IF NOT .GOFLG THEN COMMAND();
	    END;
   SSTOP:  BEGIN OUTD(.ENTCNT/2); OUTS(' ROUTINE CALLS = ');
                 OUTD(.ENTCNT/8858); OUTS(' PROCESSOR UNITS, ');
                 OUTD(.MAXSTACK); OUTS(' WORDS OF STACK USED');
           END;
   OTHERWISE: OUTS('INVALID SIX12 CALL');
           TESN;
    .VVR
    END;

GLOBAL ROUTINE SIXDDT=       % PUSHJ SIXDDT;X  FROM DDT  MIGHT WORK %
  BEGIN
  LOCAL VV;
  VV := .VREG;
  SIX12(SCALL);
  .VV
  END;

ROUTINE INITSIX12=
    BEGIN
    EXTERNAL JOBDDT;
    NROUTS := -1; NVALS := 0; ENTCNT := 1;
    NULLSTE[0] := NULLSTE[1] := 0;
    (@@@FREG)<0,36> := 0;
    TRACEFLG := ENABFLG := MAXSTACK := 0;
    DBASE := IDBASE := 8;
    WDBASE := #1000;
    IF .JOBSYM<0,18> GEQ #400000
      THEN BEGIN        % SYMBOL TABLE IN HISEG SO UNDO WRITE PROTECT %
        REGISTER R;
        R := 0;
        CALLI(R,#36)  END;
    IF NOT (GOFLG := .JOBDDT EQL 0)
       THEN (.((.(.JOBDDT)<0,18>)+1)<0,18>)<0,36> := 0  % DDT SAVE REGISTER FLAG %
       ELSE BEGIN
         REGISTER R;
         R := (.WDBASE)^18 + SIXDDT<0,0>;
         CALLI(R,2);   % SETDDT %
         END;
    CLEANST();
    INITED := 1;
    END;

GLOBAL ROUTINE SIXGO=
  BEGIN GOFLG := 0; SREG := .SREG-#1000001;
  .VREG END;

END ELUDOM
   @@S