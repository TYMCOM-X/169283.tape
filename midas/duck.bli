MODULE DUCK(DOLLAR,ENTRIES=($DPRTR,$DMSTP,$DPROP),
        FSAVE,TIMING,TIMER=EXTERNAL(SIX12))=
BEGIN

REQUIRE DDEFS.BLI[7,107355];
REQUIRE DVDEFS.BLI[7,107355];
REQUIRE GDEFS.BLI[7,107355];
REQUIRE RDEFS.BLI[7,107355];
REQUIRE UDEFS.BLI[7,107355];


MAP U$DYNARY DBASE$;
MAP G$ DGAM$;
MAP DL$ DLIST$;
MAP DR$ DREGS$;
MAP DF$I DFLAG$;
MAP U$DYNARY DPOOL$;
MAP U$DYNARY DEFER$;
MAP U$DYNARY DRACK$;

UNDECLARE $DPRTR;

GLOBAL ROUTINE $DPRTR(ID)=
   BEGIN
   %THIS ROUTINE PROCESSES ONE EACH
   REQUEST FOR AN ADDRESS FOR A RUN TIME ROUTINE...

        "ID" SHOULD BE SOMETHING LIKE "RTRV$OINK"
        WHICH IDENTIFIES THE RUNTIME ROUTINE $OINK..

        IN RETURN, THE RELATIVE ADDRESS OF THE RUN TIME
        ROUTINE IN THE PDB'S RUN TIME ROUTINE SECTION
        IS RETURNED

    THE FLOW IS AS FOLLOWS:

        (1) WE LOOK IN DRACK$ (THE STOREHOUSE OF ID'S
        FOR ALL CURRENTLY ACTIVE RUN TIME ROUTINES, STORED
        BY ID NUMBER) FOR A PREVIOUS OCCURENCE OF THE
        ID...IF FOUND, IT MEANS THAT WE HAVE AKREADY SEEN
        THIS ROUTINE BEFORE, AND WE RETURN THE ADDRESS;

        (2) IF WE HAVE NOT SEEN IT BEFORE, WE ENTER IT IN DRACK$
        AND UPDATE THE DRACK$ POINTER(INDEX), DXRACKCT$,
        AND RETURN THE RELATIVE ADDRESS


    /JS................................6/14/74(FLAG DAY)
    %

    INCR I FROM 1 TO .DXRACKCT$ DO
        IF .DRACK$[.I] EQL .ID THEN
           RETURN .I*2;
    DXRACKCT$_.DXRACKCT$+1;
    DRACK$[.DXRACKCT$]_.ID;
    
    .DXRACKCT$*2
    
     END;

UNDECLARE $DMSTP;

GLOBAL ROUTINE $DMSTP(ID,QP,LEN,I)=
   BEGIN
   %MAKE A STRING TEMPORARY AND SET ITS PROPERTIES TO DREGS$[I]
   PARAMETERS ARE:

        ID=GAMMA CODE ID
        QP = NUMBER OF CHARACTERS
        LEN = NUMBER OF WORDS DESSIRED
        I = SYMBOLIC REGISTER DESTINATION

   THIS CODE IS BORROWED FROM $DTNS
   AND WILL SOMEDAY REPLACE  THE STRING TEMP CODE 
   FOUND THERE

   /JS........................10/5/74
   %

   DXLSTCT$_.DXLSTCT$+1; 
   %SHOULD CHECK HERE FOR TEMP OVERFLOW AND EMIT HORRENDOUS 
   MESSAGE IF IT HAS OCCURRED%

   %NOW SET UP THE TEMP%
   DLIST$[DL$LOC   ,.DXLSTCT$]_.DXSBASE$; %WHERE%
   DLIST$[DL$QP    ,.DXLSTCT$]_.QP; %HOW MANY CHARS%
   DLIST$[DL$CGFP  ,.DXLSTCT$]_.ID; %WHO%
   DLIST$[DL$UCNT  ,.DXLSTCT$]_DLV$MAX; %A PARAM..AS MANY AS POSSIBLE%
   DLIST$[DL$DDTYPE,.DXLSTCT$]_DDV$STEMP; %WHAT%
   DLIST$[DL$MASK  ,.DXLSTCT$]_0; %NO MASK%

   DXSUSE$_.DXSUSE$+1; %ADD ONE MORE TO THE MANY%

   DREGS$[DR$OFFSET,.I]_.DXSBASE$; %THERE IT IS%

   DXSBASE$_.DXSBASE$+.LEN+1; %STEMPS ARE ALWAYS ONE LARGER%
   IF .DXSBASE$ GTR .DXSTMPSIZE$ THEN
        DXSTMPSIZE$_.DXSBASE$;

   %NOW SET UP THAT DAMN REGISTER%
   DREGS$[DR$BASE  ,.I]_DBV$STEMPBASE; 
   DREGS$[DR$QP    ,.I]_.QP;
   DREGS$[DR$DDTYPE,.I]_DDV$STEMP;
   DREGS$[DR$STP1  ,.I]_0;

   %BOY IS IT MADDENING TO WORK WHEN THEY HAVE THE
   NETWORK TIED UP WITH THE LOCKHEED BENCHMARK!!%
   END;
UNDECLARE $DPROP;

GLOBAL ROUTINE $DPROP(TYPE) =
   BEGIN
   %PRINT/SOURCE CONTROL..

   PARAMETER "TYPE"
        = GV$SKIP .. SKIP N LINES
        = GV$SKIPTO .. SKIP TO LINE N
        = GV$TAB .. TAB N POSITIONS
        = GV$TABTO .. TAB TO POITION N

    /JS.............................10/11/74

    %

    $DGOPD(1,1);
    $DFRCA();

    IF .DREGS$[DR$DDTYPE,1] EQL DDV$SLIT THEN
        $DGSYL(.DREGS$[DR$OFFSET,1],3)
    ELSE
        $DCOPY(1,3);

    SELECT .TYPE OF NSET

GV$SKIP:        $DRNCL(RTRV$TSKIP,1);
GV$SKIPTO:      $DRNCL(RTRV$TSKPT,1);
GV$TABTO:       IF .DXSOURCE$ EQL 0 THEN
                   $DRNCL(RTRV$TCOLO,1)
                ELSE
                   $DRNCL(RTRV$TCOLI,1);
GV$TAB:         IF .DXSOURCE$ EQL 0 THEN
                   $DRNCL(RTRV$TSKPO,1)
                ELSE
                   $DRNCL(RTRV$TSKPI,1);
OTHERWISE:      0;
        TESN;

   END;


%*******************%
END ELUDOM
