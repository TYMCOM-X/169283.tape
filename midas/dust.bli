MODULE DUST(DOLLAR,ENTRIES=($DGSYL,$DGSAD,$DFRCA,$DEXCH,$DMKL2,$DMKL1,
        $DMKST),FSAVE,TIMING,TIMER=EXTERNAL(SIX12))=
BEGIN

REQUIRE DDEFS.BLI[7,107355];
REQUIRE DVDEFS.BLI[7,107355];
REQUIRE GDEFS.BLI[7,107355];
REQUIRE UDEFS.BLI[7,107355];
REQUIRE SDEFS.BLI[7,107355];


MAP U$DYNARY DBASE$;
MAP G$ DGAM$;
MAP DL$ DLIST$;
MAP DR$ DREGS$;
MAP DF$I DFLAG$;
MAP U$DYNARY DPOOL$;
MAP U$DYNARY DEFER$;



UNDECLARE $DGSYL;

GLOBAL ROUTINE $DGSYL(ARG,REG)=
   BEGIN
   %$DGSYL RETURNS SYMBOLIC REGISTER DESIGNATED BY "REG"
   SET TO POINT TO THE SYSTEM LITERAL WHOSE VALUE IS 

   .ARG

   THE PLOT IS AS FOLLOWS:
        (1) A NAME BLOCK(UNDOCUMENTED IN THE SYMBOL TABLE
        ROUTINES) IS BUILT WITH THE DDTYPE "SV$SYSL" AND A VALUE
        OF .ARG;

        (2) A LOOKUP IS PERFORMED WITH THE NAME BLOCK

        (3) IF THERE WAS NO ENTRY, MAKE ONE AND SAVE THE STP;

        (4) IN EITHER CASE, GET THE APPROPRIATE SYMBOL
                TABLE ENTRY, AND SET UP THE VALUES IN
        DREGS$[*,.REG] CORRECTLY;

        (5) LAST, FREE THE SYMBLO TABLE ENTRY.

   /JS..............................5/28/74
  %

  LOCAL SNAM$ T;     %NAME BLOCK%
   LOCAL Q[3];
   LOCAL P,STP;
   MAP S$ P;

   %BUILD NAME BLOCK%
   T_Q;
    Q[0]_0;
   T[S$DDTYPE]_SV$SYSL;
    Q[1]_.ARG;

   IF (STP_$SLKUP(Q,2)) EQL 0 THEN
        BEGIN
        %IT WASN'T THERE, SO MAKE ONE%
        P_$SGVSTS(SV$SYSLIT,2);
        (P[S$NAME])[0]_0;
        (P[S$NAME])[1]_.ARG;
        P[S$DDTYPE]_SV$SYSL;
        P[S$TYPE]_SV$SYSLIT;
        P[S$LB]_DBV$LITBASE;
        P[S$LFO]_.DBASE$[DBV$LITBASE];
        $DEUCE(DBV$LITBASE);
        $DEMIT(DV$CNST,0,0,.P[S$STPX],.ARG);
        $DINCB(DBV$LITBASE);
        STP_$SFNME(.P,2);
        END;

   %NOW GET SYMBOL  TABLE ENTRY%
   P_$SGSTE(.STP);
   DREGS$[DR$BASE,.REG]_.P[S$LB];
   DREGS$[DR$OFFSET,.REG]_.P[S$LFO];
   DREGS$[DR$DDTYPE,.REG]_DDV$1WD;
   DREGS$[DR$QP,.REG]_0;
   DREGS$[DR$STP1,.REG]_.P[S$STPX];
   $SFRNCH(.P);

   END;

UNDECLARE $DGSAD;

GLOBAL ROUTINE $DGSAD(BASE,DISP,REG)=
   BEGIN
   %$DGSAD  RETURNS SYMBOLIC REGISTER ".REG" CONTAINING
   THE ADDRESS CONSTANT INDICATED BY THE (BASE,DISP);
   THE GENERAL FLOW IS AS FOLLOWS:

        (1)A NAME BLOCK (STILL POORLY DOCUMENTED) IS BUILT
        WITH THE BASE,DISP AS THE PRIMARY ARGUMENT;

        (2)$SLKUP TRIES TO FIND A NAME ENTRY WITH THE SSAME
        ADCON VALUE;

        (3)IF NO ENTRY IS FOUND , WE GET AN EMPTY
        SYMBOL TABLE ENTRY OF TYPE "SYS$ADCON", FILL IT WITH ALL
        THE GOOD FLAGS,ETC., ALLOCATE A WORD OF LITERAL SPACE
        TO CONTAIN THE ADCON REPRESENTATION OF (BASE,DISP),
        UPDATE THE SYMBOL TABLE ENTRY SOME MORE, DO A "FREE-NAME"
        ON THE BUFFER,AND SAVE THE SYMBOL TABLE POINTER.

        (4)IN ANY CASE, WE FETCH THE ENTRY FROM THE SYMBOL TABLE,
        AND USE ITS CONTENTS TO FILL THE FIELDS OF DREGS$[*,.REG];

        (5)LASTLY, WE FREE THE SYMBOL TABLE ENTRY AND RETURN....

    IF THIS IS FAMILIAR, LOOK UP THE PAGE A LITTLE WAY AT $DGSYL..

   /JS.......................................5/29/74
   %

   LOCAL Q[2];
   LOCAL T;
   MAP SNAM$ T;
   LOCAL P,STP;
   MAP S$ P;


   T_Q;  %SET T TO BE  A POINTER%
   Q[0]_Q[1]_0;

   T[S$DDTYPE]_SV$SYSA;  %AN ADCON%
   T[S$AVB]_.BASE;
   T[S$AVFO]_.DISP;

   %NOW THE LOOKUP%
   IF (STP_$SLKUP(Q,2)) EQL 0 THEN
        BEGIN
        %WELL, THEN , PROCESS IT%
        P_$SGVSTS(SV$SYSADCON,2);  %GET A BUFFER%
        (P[S$NAME])[0]_0;
        (P[S$NAME])[1]_0;
        P[S$DDTYPE]_SV$SYSA;
        P[S$TYPE]_SV$SYSADCON;
        P[S$LB]_DBV$LITBASE;
        P[S$LFO]_.DBASE$[DBV$LITBASE];
        P[S$AVB]_.BASE;
        P[S$AVFO]_.DISP;
        $DEUCE(DBV$LITBASE);
        $DEMIT(DV$DRELR,0,.BASE,.P[S$STPX],.DISP);
        $DINCB(DBV$LITBASE);
        STP_$SFNME(.P,2);
        END;

    %NOW TO SET UP THE REGISTER%
   P_$SGSTE(.STP);
   DREGS$[DR$BASE,.REG]_.P[S$LB];
   DREGS$[DR$OFFSET,.REG]_.P[S$LFO];
   DREGS$[DR$DDTYPE,.REG]_DDV$1WD;
   DREGS$[DR$QP,.REG]_0;
   DREGS$[DR$STP1,.REG]_.P[S$STPX];
   $SFRNCH(.P);
   END;



UNDECLARE $DFRCA;

GLOBAL ROUTINE $DFRCA =
    BEGIN
    %THIS ROUTINE DOES FOR THE ARITHMETIC ACCUMULATOR
    WHAT THE ROUTINE $DFRCL DOES FOR THE LOGICAL ACCUMULATOR..
    IT FORCES AN ACCUMULATOR IN USE TO BE SAVE IN A TEMPORARY
    AND MARKS THE ACCUMULATOR A S BEING 'FREE'

    /JS..................................5/30/74
    /JS....MOVED FROM DART TO HERE.......8/9/74
    %

    LOCAL T;

    IF .DXACUCNT$ LEQ 0 THEN RETURN; %EARLY EXIT..ACC IS EMPTY%

    %BUSY,SO SAVE IT%

    $DMTMP(.DXACSIZE$); %GET A TEMP OF APPROPRIATE LENGTH%
    T_.DXLSTCT$;


    %SETUP TEMP%
    DLIST$[DL$CGFP,.T]_.DXACID$;
    DLIST$[DL$UCNT,.T]_.DXACUCNT$;
    DLIST$[DL$QP   ,.T]_.DXACQP$;

    %NOW SAVE THE ACC IN THE TEMP%
    DREGS$[DR$BASE   ,0]_DBV$TEMPBASE;
    DREGS$[DR$OFFSET ,0]_.DLIST$[DL$LOC,.T];
    DREGS$[DR$QP     ,0]_.DXACQP$;
    DREGS$[DR$STP1   ,0]_0;
    DREGS$[DR$DDTYPE,0]_.DXACSIZE$;


    SELECT .DXACSIZE$ OF 
        NSET  %DOIT%
DDV$1WD:        $DPCP(DTPV$SAVE1);
DDV$2WD:        $DPCP(DTPV$SAVE2);
DDV$3WD:        $DPCP(DTPV$SAVE3);
        TESN;

     %NOW FREE THE AC%
    DXACID$_DXACUCNT$_DXACQP$_DXACSIZE$_0;

    END;
UNDECLARE $DEXCH;

GLOBAL ROUTINE $DEXCH(I,J)=
   BEGIN
    %EXCHANGE CONTENTS OF DREGS$[*,.I] AND DREGS$[*,.J]
    IN A STRAIGHT-FORWARD FASHION

    /JS...............................8/23/74
    %

    LOCAL T;
    %NOTE..WE ASSUME THAT DR$ HAS FIVE FIELDS..0--4
    REMEMBER THAT WHEN YOU CHANGE DR$!!!%

    INCR K FROM 0 TO 4 DO

        BEGIN
        T_.DREGS$[.K,.I];
        DREGS$[.K,.I]_.DREGS$[.K,.J];
        DREGS$[.K,.J]_.T;
        END;
     IF (.I GTR 2) OR (.J GTR 2) THEN RETURN;

     INCR K FROM 1 TO 11 BY 2 DO
        BEGIN
        T_.DFLAG$[.K,.I];
        DFLAG$[.K,.I]_.DFLAG$[.K,.J];
        DFLAG$[.K,.J]_.T;
        END;


     END;


UNDECLARE $DMKL2;

GLOBAL ROUTINE $DMKL2(NID,NDP,HOW,LOW)=
   BEGIN
   % $DMKL2 LOOKS UP A DOUBLE PRECISION LITERAL IN THE
   SYMBOL TABLE, AND IF NOT THERE, ADDS IT
   IN TYPICAL SYMBOL TABLE EFFICIENCY

   PARAMETERS ARE:
        NID = NUMBER OF INTEGER PLACES IN LITERAL
        NDP = NUMBER OF DECIMAL PLACES IN LITERAL
        HOW = HIGH ORDER WORD OF LITERAL
        LOW = LOW ORDER WORD OF LITERAL

   THE VALUE RETURNED IS THE STP TO THE LITERAL INCARNATION ENTRY

   THE NOTIONS, ETC., FOR THIS CODE WERE MOSTLY STOLEN FROM
   THE SCANNER AND $DGSYL

   /JS..........................8/30/74
   %

   LOCAL Q[4],T,LNE,LIE,STP,X;
   MAP SNAM$ T;
   MAP S$ LNE;
   MAP S$ LIE;

   T_Q;  %T NOW HAS A NAME BLOCK%

   Q[0]_0; %CLEAR FIRST WORD%

   T[S$DDTYPE]_SV$DBLD; %SET UP FIRST WORD OF NAME%
   T[S$NID]_.NID;
   T[S$NDP]_.NDP;
   Q[1]_.HOW;
   Q[2]_.LOW;

   %NAME BLOCK IS SET UP..DOES IT ALREADY EXIST?%

   IF (STP_$SLKUP(Q,3)) EQL 0 THEN
        BEGIN
        %A VIRGIN..JUST FOR ME%
        LNE _ $SGVSTS(SV$DWLIT,3); %GET A NAME BLOCK OF GOOD SIZE%
        STP_LNE[S$STP1]_.LNE[S$STPX]; %MUCKING AROUND WITH STP'S%

        %LNE IS THE NAME ENTRY..NOW FOR THE INCARNATION%
        LIE _ $SGVSTS(SV$LIE,3);
        X_LNE[S$LITINCP]_.LIE[S$STPX]; %REMEMBER WHERE YOU SAW THE INC%
        LIE[S$STP1]_.STP; %REMEMBER WHICH NAME ENTRY%

        %NOW COPY THE NAME FIELD%
        INCR I FROM 0 TO 2 DO
           (LNE[S$NAME])[.I]_(LIE[S$NAME])[.I]_.Q[.I];

        %NOW FREE THE INCARNATION%
        $SFRCH(.LIE);
        %AND THE NAME ENTRY%
        STP_$SFNME(.LNE,3);
        
        END
    ELSE

        BEGIN
        %SEEN THIS ONE BEFORE%
        LNE _ $SGSTE(.STP);
        X _ .LNE[S$LITINCP];
        $SFRNCH(.LNE);
        END;

        %AND NOW .. TO BED%
        .X
    END;

UNDECLARE $DMKL1;

GLOBAL ROUTINE $DMKL1(NID,NDP,VAL)=
   BEGIN
   %LIKE $DMKL2, EXCEPT FOR SINGLE PRECISION

    /JS...................8/30/74
   %

   LOCAL Q[3],T,LNE,LIE,STP,X;
   MAP SNAM$ T;
   MAP S$ LNE;
   MAP S$ LIE;

   T_Q;

   Q[0]_0;

   T[S$DDTYPE]_SV$SINGD;
   T[S$NID]_.NID;
   T[S$NDP]_.NDP;
   Q[1]_.VAL;


   IF (STP_$SLKUP(Q,2)) EQL 0 THEN
        BEGIN
        LNE _ $SGVSTS(SV$SWLIT,2);
        STP_LNE[S$STP1]_.LNE[S$STPX];

        LIE_ $SGVSTS(SV$LIE,2);
        X_LNE[S$LITINCP]_.LIE[S$STPX];
        LIE[S$STP1]_.STP;

        INCR I FROM 0 TO 1 DO
           (LNE[S$NAME])[.I]_(LIE[S$NAME])[.I]_.Q[.I];

        $SFRCH(.LIE);

        STP_$SFNME(.LNE,2);

        END

   ELSE

        BEGIN
        LNE_$SGSTE(.STP);
        X_.LNE[S$LITINCP];
        $SFRNCH(.LNE);
        END;

   .X

   END;

UNDECLARE $DMKST;

GLOBAL ROUTINE $DMKST(LEN,VAL)=
   BEGIN
   % MAKE A ONE WORD SYMBOL TABLE ENTRY FOR THE STRING IN VAL
   HOPEFULLY, LEN <=5
   VAL IS THE VALUE OF THE STRING

   CODE IS SIMILAR TO THE TWO EXAMPLES ABOVE
   
   /JS........................9/23/74
  %

   LOCAL Q[3],T,LNE,LIE,STP,X;
   MAP SNAM$ T;

    MAP S$ LNE;
    MAP S$ LIE;

   T_Q;

   Q[0]_0;
   T[S$DDTYPE]_SV$SLIT;
   T[S$NCHAR]_.LEN;
   Q[1]_.VAL;

   IF (STP_$SLKUP(Q,2)) EQL 0 THEN

        BEGIN
        LNE _ $SGVSTS(SV$STLIT,2);
        STP _ LNE[S$STP1]_.LNE[S$STPX];
        LIE _ $SGVSTS(SV$LIE,2);
        X_LNE[S$LITINCP]_.LIE[S$STPX];
        LIE[S$STP1]_.STP;

        INCR I FROM 0 TO 1 DO
           (LNE[S$NAME])[.I]_(LIE[S$NAME])[.I]_.Q[.I];
        $SFRCH(.LIE);
        STP_$SFNME(.LNE,2);
        END

   ELSE

        BEGIN
        LNE _ $SGSTE(.STP);
        X_.LNE[S$LITINCP];
        $SFRNCH(.LNE);
        END;

   .X

   END;


%*******************%
END ELUDOM
   