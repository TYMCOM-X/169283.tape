MODULE BLISIO(DOLLAR,ENTRIES=($CRESET,$COPEN,$CLOSE,$CSXCP,
                                $CSCP,$CR,$CRB,$CW,$CWB,$CEOFCHR))=

BEGIN

EXTERNAL $CFREEM,$CINITM,$CGETM;  %MEMORY ALLOC. ROUTINES%



%  BASIC MONITOR LEVEL IO CALLS
%

MACHOP
  BLIT=#251,
  CALLI=#047,
  TTCALL=#051,
  NOP=#300,
  XCT=#256;

BIND
  ILLOP=-13,
  BADCUR=-9,
  BADCNT=-10,
  OPENUUO=#050,
  INUUO=#056,
  OUTUUO=#057,
  INBF=#064,
  OUTBF=#065,
  GETSTS=#062,
  STATZ=#063,
  CLOSEUUO=#070,
  RELEAS=#071,
  LOOKUPUUO=#076,
  ENTERUUO=#077,
  USETI=#074,
  USETO=#075;

%       SOME USEFUL MACROS:
%
MACRO
  SKIP(OP)=(VREG_1; OP; VREG_0; .VREG)&,
  MOVE(COUNT,SOURCE,DEST)=
        BEGIN
        REGISTER Q;
        Q<18,18>_SOURCE;
        Q< 0,18>_DEST;
        BLIT(Q,DEST+COUNT-1);
        .VREG
        END&,
  ERRMSG(S)=(TTCALL(3,PLIT ASCIZ S); CALLI(0,#12))&,
  NOFILE=ERRMSG('?M?J????FILE NOT OPENED?M?J  OR BAD FILE POINTER?M?J')&,
  COPYBUF=MOVE(.CF$[BSIZE],.CF$[IPTR]+1,.CF$[OPTR]+1)&,
  ERRCODE=(IF SKIP(XCT(0,CF$[STATZOP])) THEN -7 ELSE -8)&,
  MIN(A,B)=(IF A LSS B THEN A ELSE B)&,
  BETWEEN(C,A,B)=(C GEQ A AND C LEQ B)&,
  INFAILS=SKIP(XCT(0,CF$[INOP]))&,
  OUTFAILS=SKIP(XCT(0,CF$[OUTOP]))&,
  INC(A)=(A_.A+1)&,
  DEC(A)=(A_.A-1)&,
  INPUT=0&,
  OUTPUT=1&,
  UPDATE=2&,
  FDX=3&,
  NORG=2&,
  NTYPE=4&,
  NMODE=2&;

%       STRUCTURE DEFINITIONS FOR VARIOUS THINGS:
%
!  LONG BYTE VECTOR
STRUCTURE LBYTEVEC[I,J]=[I*(J-1)/36+1] (.LBYTEVEC+.I/(36/I))<36-(.I MOD (36/I)+1)*I,I>;

!  COMPRESSED AND MAPPED TABLE WITH 2-BIT VECTOR INDEX
STRUCTURE COMTAB[I]=(.COMTAB+1+.(.COMTAB<34-2*.I,2>))<0,36>;


!   FIELD NAME-VALUES FOR THE FILECB STRUCTURE

BIND
   NB     =0,
   MODE   =1,
   ORG    =2,
   TYPE   =3,
   P      =4,
   CHNL   =5,
   BSIZE  =6,
   DIRTY  =7,
   WLB    =8,
   ITEMPW =9,
   ISIZE  =10,
   IBUFH  =11,
   ICBUF  =12,
   IPTR   =13,
   ICOUNT =14,
   OBUFH  =15,
   OCBUF  =16,
   OPTR   =17,
   OCOUNT =18,
   INOP   =19,
   OUTOP  =20,
   STATZOP=21,
   COML   =22,
   ICP    =23,
   OCP    =24,
   MAXCP  =25,
   RR     =26,
   RBR    =27,
   WR     =28,
   WBR    =29,
   SCPR   =30,
   EXCEPT =31,
   USETIOP=32,
   USETOOP=33,
   BUFL   =34,
   IBUFL  =35,
   OBUFL  =36,
   IBUFR  =37,
   OBUFR  =38,
   TERMCHR=39,
   EOFBIT =40,
   FCBFIDT=41, %8 WORD COPY OF FIDT PASSED TO OPEN%
   EXISTS =42,
   FCBS   =29;  !FILE CONTROL BLOCK SIZE



!   FILE CONTROL BLOCK TABLE FOR EACH FILE
STRUCTURE FILECB[FIELD] = CASE .FIELD OF
        SET
%NB     %   (@.FILECB)<33,3>;
%MODE   %   (@.FILECB)<30,3>;
%ORG    %   (@.FILECB)<27,3>;
%TYPE   %   (@.FILECB)<24,3>;
%P      %   (@.FILECB)<24,9>;
%CHNL   %   (@.FILECB)<20,4>;
%BSIZE  %   (@.FILECB)<12,8>;
%DIRTY  %   (@.FILECB)<10,1>;
%WLB    %   (@.FILECB)<9,1>;
%ITEMPW %   (@.FILECB)<6,3>;
%ISIZE  %   (@.FILECB)<0,6>;
%IBUFH  %   (@.FILECB+1)<0,36>;
%ICBUF  %   (@.FILECB+1)<0,18>;
%IPTR   %   (@.FILECB+2)<0,36>;
%ICOUNT %   (@.FILECB+3)<0,36>;
%OBUFH  %   (@.FILECB+4)<0,36>;
%OCBUF  %   (@.FILECB+4)<0,18>;
%OPTR   %   (@.FILECB+5)<0,36>;
%OCOUNT %   (@.FILECB+6)<0,36>;
%INOP   %   (@.FILECB+7)<0,36>;
%OUTOP  %   (@.FILECB+8)<0,36>;
%STATZOP%   (@.FILECB+9)<0,36>;
%COML   %   (@.FILECB+10)<0,36>;
%ICP    %   (@.FILECB+12)<0,18>;
%OCP    %   (@.FILECB+17)<0,18>;
%MAXCP  %   (@.FILECB+13)<0,18>;
%RR     %   (@.FILECB+14)<0,18>;
%RBR    %   (@.FILECB+14)<18,18>;
%WR     %   (@.FILECB+15)<0,18>;
%WBR    %   (@.FILECB+15)<18,18>;
%SCPR   %   (@.FILECB+16)<0,18>;
%EXCEPT %   (@.FILECB+16)<18,18>;
%USETIOP%   (@.FILECB+12)<0,36>;
%USETOOP%   (@.FILECB+17)<0,36>;
%BUFL   %   (@.FILECB+18)<0,36>;
%IBUFL  %   (@.FILECB+18)<18,18>;
%OBUFL  %   (@.FILECB+18)<0,18>;
%IBUFR  %   (@.FILECB+19)<18,18>;
%OBUFR  %   (@.FILECB+19)<0,18>;
%TERMCHR%   (@.FILECB+13)<18,7>;
%EOFBIT %   (@.FILECB)<11,1>;
%FCBFIDT%   (@.FILECB+20)<0,0>;  %8 WORDS COPY OF FIDT PASSED OPEN%
%EXISTS %   (@.FILECB+28)<0,36>
            TES;


!       NEEDED THINGS FOR BUFFER RINGS:
BIND
   FLINK=0,
   USEBIT=1;

STRUCTURE BUF[FIELD]=CASE .FIELD OF SET
%FLINK%   (@.BUF)<0,18>;
%USEBIT%  (@.BUF)<35,1>
   TES;

!       THINGS DEFINING PARTS OF FID TABLE:
BIND
        DEVICE=0,
        ARGCNT=1,       %EXTENDED FIDT ARGUMENT COUNT%
        PROJ=  2,       %PROJECT NUMBER OF PPN%
        PROG=  3,       %PROGRAMMER NUMBER OF PPN%
        USER=  4,       %POINTER TO ENTIRE PPN%
        NAME=  5,       %FILE NAME IN SIXBIT%
        EXT=   6,       %FILE NAME EXTENSION IN SIXBIT%
        ADATE= 7,       %ACCESS DATE%
        PROT=  8,       %PROTECTION CODE%
        DMODE= 9,       %DATA MODE%
        CTIME=10,       %CREATION TIME%
        CDATE=11,       %CREATION DATE%
        STATUS=12,      %STATUS BITS%
        WRDCNT=13,      %RBSIZE--FILE SIZE IN WORDS%
        VERSION=14;     %FILE VERSION NUMBER IN OCTAL%

STRUCTURE EXFIDT[FIELD]= CASE .FIELD OF
        SET
%DEVICE%   (@.EXFIDT-1)<0,36>;    %WHILE IN BLISIO, ALWAYS POINT%
%ARGCNT%   (@.EXFIDT  )<0,36>;    %TO LOC PASSED -1%
%PROJ  %   (@.EXFIDT+1)<18,18>;
%PROG  %   (@.EXFIDT+1)< 0,18>;
%USER  %   (@.EXFIDT+1)< 0,36>;
%NAME  %   (@.EXFIDT+2)< 0,36>;
%EXT   %   (@.EXFIDT+3)<18,18>;
%ADATE %   (@.EXFIDT+3)< 0,12>;
%PROT  %   (@.EXFIDT+4)<27, 8>;
%DMODE %   (@.EXFIDT+4)<23, 4>;
%CTIME %   (@.EXFIDT+4)<12,11>;
%CDATE %   (@.EXFIDT+4)< 0,12>;
%STATUS%   (@.EXFIDT+4)< 0,36>;
%WRDCNT%   (@.EXFIDT+5)< 0,36>;  %RBSIZE%
%VERSION%  (@.EXFIDT+6)< 0,36>;  %IN OCTAL%
        TES;




!       FOLLOWING MACROS CONSTRUCT INSTRUCTIONS AND EXECUTE THEM

MACRO
  MAKEOP(OP,REG,ADDR)=(OP<0,0>^27+REG^23+ADDR)&,
  EXETEST(X)=(REGISTER Q; Q_X; SKIP(XCT(0,Q)))&,
  EXECUTE(X)=(VREG_X; XCT(0,VREG); .VREG)&,
  IND=0,0,0,1&;


%       EXTERNAL CF$ ALWAYS DENOTES THE FILE CONTROL BLOCK FOR THE CURRENT
        IO OPERATION.
%
EXTERNAL FILECB CF$;

EXTERNAL CINTD$;        !CELL INDICATING THAT $CINITM OCCURRED

EXTERNAL CRSTD$;          ! CELL INDICATING THAT $CRESET OCCURRED



%       "INIT" TAKES FOUR PARAMETERS: THE CHANNEL NUMBER, THE DEVICE
        STATUS (AS SPECIFIED IN THE MONITOR REFERENCE MANUAL, THE
        LOGICAL DEVICE NAME, AND BUFFER POINTERS.  ROUTINE RETURNS
        TRUE IF THE OPEN UUO SUCCEEDS ELSE FALSE.
%

ROUTINE INIT(CHNL,STATUS,LDEV,BUF)=
  EXETEST(MAKEOP(OPENUUO,.CHNL,STATUS<0,0>));


%       DEVSIZ RETURNS THE BUFFER SIZE FOR A GIVEN DEVICE IN A GIVEN MODE
%

ROUTINE DEVSIZ(STATUS,LDEV)=
BEGIN
   VREG_STATUS<0,0>;
   CALLI(VREG,#101);
   NOP();
   .VREG
END;


%       "LOOKUP" AND "ENTER" TAKE THE STANDARD PARAMETER BLOCK EXPECTED
        BY THE MONITOR FOR EITHER THE REGULAR OR EXTENDED OPERATIONS
        SINCE THE MONITOR FIGURES OUT WHICH IS WHICH.  THEY RETURN WITH
        TRUE OR FALSE.
%

ROUTINE LOOKUP(CHNL,BLOCK)=
  EXETEST(MAKEOP(LOOKUPUUO,.CHNL,BLOCK<IND>));

ROUTINE ENTER(CHNL,BLOCK)=
  EXETEST(MAKEOP(ENTERUUO,.CHNL,BLOCK<IND>));


ROUTINE IOABT=ERRMSG('IO ABORT');


ROUTINE PANIC=
BEGIN
   LOCAL FILE,T;
   IF .CF$[EXCEPT] EQL 0 THEN CF$[EXCEPT]_IOABT;
   FILE_.CF$;
   T_(.CF$[EXCEPT])(ERRCODE);
   CF$_.FILE;
   IF .CF$[EXCEPT] EQL 0 THEN CF$[EXCEPT]_IOABT;
   .T
END;


ROUTINE SCPB(CURSOR,CODE)=
BEGIN

   ROUTINE ZONK(CURSOR,S)=
      BEGIN
         BIND
            DISP=(.CURSOR-1) MOD .CF$[ITEMPW],
            WORDS=(((.CURSOR-1)/.CF$[ITEMPW]) MOD .CF$[BSIZE])+1,
            BN=.CURSOR/.CF$[ITEMPW]/.CF$[BSIZE],
            DELBN=BN-(CASE .S OF SET .CF$[ICP]; .CF$[OCP] TES);
         (CASE .S OF SET
            BEGIN
               IF DELBN NEQ 0
                  THEN CASE IF BETWEEN(DELBN,1,.CF$[NB]-1)
                               THEN BEGIN
                                  REGISTER Q;
                                  MAP BUF Q;
                                  Q_.CF$[ICBUF];
                                  DECR R FROM DELBN TO 1 DO Q_.Q[FLINK];
                                  .Q[USEBIT]
                                  END
                               ELSE 0
                        OF SET
                           DECR R FROM DELBN TO 1 DO (XCT(0,CF$[INOP]); NOP());
                           BEGIN
                              CF$[ICP]_BN+1; XCT(0,CF$[USETIOP]);
                              IF INFAILS THEN PANIC() ELSE .VREG
                           END
                        TES;
               CF$[IPTR]
            END;
            BEGIN
               IF DELBN NEQ 0
                  THEN BEGIN
                     IF NOT .CF$[DIRTY] THEN CF$[OPTR]_.CF$[OCBUF]+1;
                     CF$[OCP]_BN+1; XCT(0,CF$[USETOOP]);
                     IF .CF$[OCP] GTR .CF$[MAXCP] THEN (CF$[MAXCP]_.CF$[OCP]; CF$[WLB]_1)
                  END;
               CF$[OPTR]
            END
         TES)_((CASE .S OF SET .CF$[ICBUF]; .CF$[OCBUF] TES)+WORDS+1)
            <36-DISP*.CF$[ISIZE],.CF$[ISIZE]>;
         (CASE .S OF SET CF$[ICOUNT]; CF$[OCOUNT] TES)_.CF$[BSIZE]-WORDS
      END;

   IF .CODE NEQ OUTPUT THEN ZONK(.CURSOR,INPUT);
   IF .CODE NEQ INPUT THEN ZONK(.CURSOR,OUTPUT);

   IF .CF$[TYPE] EQL UPDATE THEN COPYBUF ELSE .VREG
END;


ROUTINE SCPU(CURSOR)=
BEGIN
   IF (.CURSOR AND #177) NEQ 0 THEN (.CF$[EXCEPT])(BADCUR);
   BEGIN
      BIND
         BLN=1+.CURSOR/.CF$[BSIZE];

      IF .CF$[TYPE] NEQ OUTPUT THEN (CF$[ICP]_BLN; XCT(0,CF$[USETIOP]));
      IF .CF$[TYPE] NEQ INPUT
         THEN BEGIN
            CF$[OCP]_BLN; XCT(0,CF$[USETOOP]);
             IF .CF$[OCP] GTR .CF$[MAXCP] THEN (CF$[MAXCP]_.CF$[OCP]; CF$[WLB]_1) ELSE .VREG
            END
   END
END;


ROUTINE CPR(CODE)=
   CASE .CODE*2+(.CF$[NB] GTR 0) OF SET
%UNBUF INPUT%   .CF$[ICP]*.CF$[BSIZE];
%BUF   INPUT%   (.CF$[ICP]+1)*.CF$[BSIZE]*.CF$[ITEMPW]-.CF$[ICOUNT];
%UNBUF OUTPUT%  .CF$[OCP]*.CF$[BSIZE];
%BUF   OUTPUT%  (.CF$[OCP]+1)*.CF$[BSIZE]*.CF$[ITEMPW]-.CF$[OCOUNT]
   TES;


ROUTINE RI=
   IF DEC(CF$[ICOUNT]) LEQ 0
      THEN BEGIN
         REGISTER T;
         T_SCANI(CF$[IPTR]);
         (.CF$[IBUFR])();
         .T
         END
      ELSE SCANI(CF$[IPTR]);

ROUTINE RUB(CNT,ADR)=
BEGIN
   IF (.CNT AND #177) NEQ 0 THEN (.CF$[EXCEPT])(BADCNT);
   CF$[COML]<18,18>_-.CNT;
   CF$[COML]<0,18>_.ADR-1;
   IF INFAILS THEN PANIC() ELSE CF$[ICP]_.CF$[ICP]+.CNT^(-7)
END;


ROUTINE RBB(CNT,ADR)=
   WHILE .CNT GTR 0 DO
      BEGIN
         REGISTER QR;
         QR_MIN(.CNT,.CF$[ICOUNT]);
         MOVE(.QR,.CF$[IPTR]+1,.ADR);
         IF (CF$[IPTR]_.CF$[IPTR]+.QR; CF$[ICOUNT]_.CF$[ICOUNT]-.QR) LEQ 0
            THEN (.CF$[IBUFR])();
         ADR_.ADR+.QR;
         CNT_.CNT-.QR
      END;


ROUTINE RU=
BEGIN
   REGISTER T;
   T_RI();
   IF DEC(CF$[OCOUNT]) LEQ 0
      THEN SCPB(.CF$[ICP]*.CF$[ITEMPW]*.CF$[BSIZE],INPUT);
   .T
END;


ROUTINE RBBU(CNT,ADR)=
BEGIN
   RBB(.CNT,.ADR);
   SCPB((.CF$[ICP]+1)*.CF$[BSIZE]-.CF$[ICOUNT],INPUT)
END;


ROUTINE WI(ELE)=
BEGIN
   REPLACEI(CF$[OPTR],.ELE);
   IF DEC(CF$[OCOUNT]) LEQ 0
      THEN (.CF$[OBUFR])();
   .ELE
END;

ROUTINE WU(ELE)=
BEGIN
   WI(.ELE); CF$[DIRTY]_1;
   IF NOT .CF$[WLB]
      THEN BEGIN
         IF DEC(CF$[OCOUNT]) LSS 0
            THEN IF OUTFAILS
               THEN PANIC()
               ELSE BEGIN
                  COPYBUF; REPLACEI(CF$[OPTR],.ELE);
                  DEC(CF$[OCOUNT]); INC(CF$[OCP])
               END;
         INCP(CF$[OPTR])
      END;
   .ELE
END;


ROUTINE WUB(CNT,ADR)=
BEGIN
   IF (.CNT AND #177) NEQ 0 THEN (.CF$[EXCEPT])(BADCNT);
   CF$[COML]<18,18>_-.CNT;
   CF$[COML]<0,18>_.ADR-1;
   IF OUTFAILS THEN PANIC()
                ELSE IF (CF$[OCP]_.CF$[OCP]+.CNT^(-7)) GEQ .CF$[MAXCP]
                        THEN (CF$[MAXCP]_.CF$[OCP]; CF$[WLB]_1)
END;


ROUTINE WBB(CNT,ADR)=
   WHILE .CNT GTR 0 DO BEGIN
      REGISTER QR;
      QR_MIN(.CF$[OCOUNT],.CNT);
      MOVE(.QR,.ADR,.CF$[OPTR]+1);
      IF (CF$[OPTR]_.CF$[OPTR]+.QR; CF$[OCOUNT]_.CF$[OCOUNT]-.QR) EQL 0
         THEN (.CF$[OBUFR])();
      ADR_.ADR+.QR;
      CNT_.CNT-.QR
   END;


ROUTINE WBBU(CNT,ADR)=
BEGIN
   WBB(.CNT,.ADR);
   SCPB((.CF$[OCP]+1)*.CF$[BSIZE]-.CF$[OCOUNT],OUTPUT)
END;


ROUTINE ER=
   (.CF$[EXCEPT])(ILLOP);


ROUTINE FBUF=$CFREEM(.CF$);


ROUTINE TEOF=
BEGIN
   CF$[IPTR]_(.CF$[ICBUF]+1)<0,7>;
   @CF$[IPTR]_@(@CF$[IPTR]+1)_.CF$[TERMCHR]*(1^29+1^22+1^15+1^8+1^1);
   CF$[ICOUNT]_10;
   CF$[EXCEPT]_0
END;



%       HERE ARE ARE THE ENTRIES FOR ALL THE ROUTINES.
        MOST OF THEM MERELY ELABORATE THE APPROPRIATE ROUTINE SPECIFIED
        IN THE FILE CONTROL BLOCK AT OPEN TIME.
%

GLOBAL ROUTINE $CSXCP(FILE,CURSOR,C)=
BEGIN
   CF$_@@FILE;
   IF .CF$[EXISTS] NEQ SIXBIT 'NADROJ' THEN NOFILE;
   IF .CF$[TYPE] NEQ FDX THEN (.CF$[EXCEPT])(ILLOP);
   (.CF$[SCPR])(.CURSOR,.C)
END;


GLOBAL ROUTINE $CSCP(FILE,CURSOR)=
BEGIN
   CF$_@@FILE;
   IF .CF$[EXISTS] NEQ SIXBIT 'NADROJ' THEN NOFILE;
   (.CF$[SCPR])(.CURSOR,.CF$[TYPE])
END;


GLOBAL ROUTINE $CCP(FILE)=
BEGIN
   CF$_@@FILE;
   IF .CF$[EXISTS] NEQ SIXBIT 'NADROJ' THEN NOFILE;
   CPR(.CF$[TYPE])
END;


GLOBAL ROUTINE $CCPX(FILE,CODE)=
BEGIN
   CF$_@@FILE;
   IF .CF$[EXISTS] NEQ SIXBIT 'NADROJ' THEN NOFILE;
   IF .CF$[TYPE] NEQ FDX THEN (.CF$[EXCEPT])(ILLOP);
   CPR(.CODE)
END;


GLOBAL ROUTINE $CR(FILE)=
BEGIN
   CF$_@@FILE;
   IF .CF$[EXISTS] NEQ SIXBIT 'NADROJ' THEN NOFILE;
   (.CF$[RR])()
END;


GLOBAL ROUTINE $CRB(FILE,CNT,ADR)=
BEGIN
   CF$_@@FILE;
   IF .CF$[EXISTS] NEQ SIXBIT 'NADROJ' THEN NOFILE;
   (.CF$[RBR])(.CNT,.ADR)
END;


ROUTINE CINBUF=
   IF INFAILS
      THEN BEGIN
         IF ERRCODE EQL -7 THEN CF$[EOFBIT]_1;
         CF$[IBUFR]_PANIC
         END
      ELSE INC(CF$[ICP]);


GLOBAL ROUTINE $CIN(FILE)=
BEGIN
   CF$_@@FILE;
   IF .CF$[EXISTS] NEQ SIXBIT 'NADROJ' THEN NOFILE;
   CINBUF()
END;


GLOBAL ROUTINE $CW(FILE,ELE)=
BEGIN
   CF$_@@FILE;
   IF .CF$[EXISTS] NEQ SIXBIT 'NADROJ' THEN NOFILE;
   (.CF$[WR])(.ELE)
END;


GLOBAL ROUTINE $CWB(FILE,CNT,ADR)=
BEGIN
   CF$_@@FILE;
   IF .CF$[EXISTS] NEQ SIXBIT 'NADROJ' THEN NOFILE;
   (.CF$[WBR])(.CNT,.ADR)
END;


ROUTINE COUTBUF=
   IF OUTFAILS THEN PANIC()
               ELSE CASE SIGN(INC(CF$[OCP])-.CF$[MAXCP])+1 OF SET
                  NOP(); CF$[WLB]_1; INC(CF$[MAXCP]) TES;


GLOBAL ROUTINE $COUT(FILE)=
BEGIN
   CF$_.FILE;
   IF .CF$[EXISTS] NEQ SIXBIT 'NADROJ' THEN NOFILE;
   COUTBUF()
END;


GLOBAL ROUTINE $CLOSE(FILE)=
BEGIN
   CF$_@@FILE;
   IF .CF$[EXISTS] NEQ SIXBIT 'NADROJ' 
        THEN NOFILE
        ELSE CF$[EXISTS]_ SIXBIT '123456';
   EXECUTE(MAKEOP(CLOSEUUO,.CF$[CHNL],0));
   IF EXETEST(MAKEOP(STATZ,.CF$[CHNL],#760000))
      THEN EXECUTE(MAKEOP(RELEAS,.CF$[CHNL],0))
      ELSE PANIC();
   IF .CF$[IBUFL] NEQ 0 THEN $CFREEM(.CF$[IBUFL]);
   IF .CF$[OBUFL] NEQ 0 THEN $CFREEM(.CF$[OBUFL]);
   FBUF()
END;




GLOBAL ROUTINE $CRESET=
BEGIN
   CALLI(0);
   IF CINTD$ NEQ SIXBIT 'DANJOR' THEN $CINITM();
   CRSTD$_SIXBIT 'JORDAN'
END;


GLOBAL ROUTINE $CEOFCHR(FILE,CHAR)=
BEGIN
   CF$_@@FILE;
   IF .CF$[EXISTS] NEQ SIXBIT 'NADROJ' THEN NOFILE;
   CF$[TERMCHR]_.CHAR;
   CF$[EXCEPT]_TEOF;
   .CF$
END;

GLOBAL ROUTINE $COPEN(FIDT,PARAM,NBUFS,EXCP)=
BEGIN

%  FIDT IS A POINTER TO THE FILE ID TABLE WHICH BASICALLY IS THE EXTENDED
   LOOKUP OR ENTER BLOCK FOR DISC FILES.
   THE SINGLE EXCEPTION IS THAT THE -1TH ENTRY OF FIDT IS THE DEVICE
   NAME IN SIXBIT FOR THE OPEN UUO.  IF 0 IT DEFAULTS TO DISK.

   PARAM IS THE WORD SPECIFYING THE ACCESS STRUCTURE TO THE FILE AND IS
   PACKED FROM THE BASIC FORMS OF TYPE, ORGANIZATION AND MODE.  OPEN
   ENCODES THESE PARAMETERS INTO A 'FILE STRUCTURE CODE'(FSC) WHICH IS USED
   TO ACCESS THE VARIOUS TABLES WHICH SPECIFY WHAT ROUTINES ARE USED FOR
   WHAT OPERATIONS.  SINCE THE ENCODINGS ARE MESSY THE VARIOUS VALUES ARE:

  FSC    TYPE     ORG   MODE     BUF?   CFSC    RR WR RBR  WBR  SCPR
  ------------------------------------------------------------------
   0:    INPUT    CHAR  SEQUEN   UNBUF (INVALID)
   1:    OUTPUT   CHAR  SEQUEN   UNBUF (INVALID)
   2:    UPDATE   CHAR  SEQUEN   UNBUF (INVALID)
   3:    FDX      CHAR  SEQUEN   UNBUF (INVALID)
   4:    INPUT    WORD  SEQUEN   UNBUF  0       X  X  RUB  X    X
   5:    OUTPUT   WORD  SEQUEN   UNBUF  1       X  X  X    WUB  X
   6:    UPDATE   WORD  SEQUEN   UNBUF (INVALID)
   7:    FDX      WORD  SEQUEN   UNBUF (INVALID)
   8:    INPUT    CHAR  DIRECT   UNBUF (INVALID)
   9:    OUTPUT   CHAR  DIRECT   UNBUF (INVALID)
  10:    UPDATE   CHAR  DIRECT   UNBUF (INVALID)
  11:    FDX      CHAR  DIRECT   UNBUF (INVALID)
  12:    INPUT    WORD  DIRECT   UNBUF  2       X  X  RUB  X    SCPU
  13:    OUTPUT   WORD  DIRECT   UNBUF  3       X  X  X    WUB  SCPU
  14:    UPDATE   WORD  DIRECT   UNBUF  4       X  X  RUB  WUB  SCPU
  15:    FDX      WORD  DIRECT   UNBUF  5       X  X  RUB  WUB  SCPU
  16:    INPUT    CHAR  SEQUEN   BUF    6       RI X  X    X    X
  17:    OUTPUT   CHAR  SEQUEN   BUF    7       X  WI X    X    X
  18:    UPDATE   CHAR  SEQUEN   BUF   (INVALID)
  19:    FDX      CHAR  SEQUEN   BUF   (INVALID)
  20:    INPUT    WORD  SEQUEN   BUF    8       RI X  RBB  X    X
  21:    OUTPUT   WORD  SEQUEN   BUF    9       X  WI X    WBB  X
  22:    UPDATE   WORD  SEQUEN   BUF   (INVALID)
  23:    FDX      WORD  SEQUEN   BUF   (INVALID)
  24:    INPUT    CHAR  DIRECT   BUF    10      RI X  X    X    SCPB
  25:    OUTPUT   CHAR  DIRECT   BUF    11      X  WI X    X    SCPB
  26:    UPDATE   CHAR  DIRECT   BUF    12      RU WU X    X    SCPB
  27:    FDX      CHAR  DIRECT   BUF    13      RI WI X    X    SCPB
  28:    INPUT    WORD  DIRECT   BUF    14      RI X  RBB  X    SCPB
  29:    OUTPUT   WORD  DIRECT   BUF    15      X  WI X    WBB  SCPB
  30:    UPDATE   WORD  DIRECT   BUF    16      RU WU RBBU WBBU SCPB
  31:    FDX      WORD  DIRECT   BUF    17      RI WI RBB  WBB  SCPB

  NBUFS DETERMINES THE NUMBER OF BUFFERS ALLOCATED FOR THE IO
  OPERATIONS.  IF ZERO, THEN THE DATA MODE IS UNBUFFERED.

   "EXCP" IS THE ADDRESS OF A USER SUPPLIED ERROR (EG: E-O-F)
   HANDLING ROUTINE.  IF ZERO A DEFAULT ROUTINE (IOABT) WILL BE
   USED.  AN ERROR-CODE VALUE IS PASSED AS A PARAMETER:
        ILLEGAL OPERATION    =  -13
        END OF FILE          =  -7
        OTHER I/O ERROR      =  -8
        BAD CURSOR VALUE     =  -9
        BAD COUNT VALUE      =  -10


   "CFSC" IS "COMPRESSED FILE STRUCTURE CODE".  THE VALUE OF CFSC
   IS USED TO ACCESS TABLES OF I/O ROUTINE NAMES.


RR   =  READ ELEMENT ROUTINE
WR   =  WRITE ELEMENT ROUTINE
RBR  =  READ BLOCK ROUTINE
WBR  =  WRITE BLOCK ROUTINE
SCPR =  SET CURSOR POSITION ROUTINE
 
"X" UNDER AN I/O ROUTINE COLUMN INDICATES THAT CONTROL WILL
PASS TO INTERNAL ROUTINE ER WHICH INVOKES
THE USERS EXCP ROUTINE WITH AN ERROR CODE OF "ILLOP".


PARAM <== MODE+ORGANIZATION+TYPE
  WHERE MODE IS ONE OF
        SEQUENTIAL ACCESS = #000
        DIRECT ACCESS     = #100
  ORGANIZATION IS ONE OF
        CHARACTER  = #00
        WORD       = #10
  AND TYPE IS ONE OF
        INPUT   = #0
        OUTPUT  = #1
        UPDATE  = #2
        FDX     = #3  FULL-DUPLEX
THESE VALUES ARE DEFINED WITH NAMES IN UNVRSL.BLI,  WHERE
THE ERROR CODES FOR THE OPEN ROUTINE ARE ALSO BOUND TO NAMES.

OPEN RETURNS EITHER A POINTER TO THE FILE-CONTROL-BLOCK CREATED
             OR     AN ERROR CODE  <  ZERO :
                        ILLEGAL MODE    = -1
                        NO CHANNEL AVAIL= -2
                        LOOKUP FAILED   = -3
                        ENTER FAILED    = -4
                        INIT  FAILED    = -5
                        BAD FIDT        = -6.
%

% THE FOLLOWING MACRO DOES THE ENCODING OF PARAM
%
MACRO
   CHAR=0&,
   ENC7X5(A,B,C,D,E,FF,G)=A^31+B^26+C^21+D^16+E^11+FF^6+G^1&,
   ENC18X2(A,B,C,D,E,FF,G,H,I,J,K,L,M,N,O,P,Q,R)=
      A^34+B^32+C^30+D^28+E^26+FF^24+G^22+H^20+I^18+J^16+K^14+L^12+
      M^10+N^8+O^6+P^4+Q^2+R&,
   ENCODE(A,B,C,D)=NMODE*NORG*NTYPE*A +
                         NORG*NTYPE*B +
                              NTYPE*C +
                                    D&;

%  THE FOLLOWING BINDS IMPLEMENT THE TABLES DEFINING THE VARIOUS ROUTINES
   TO BE CALLED TO ELABORATE THE IO OPERATIONS FOR VARIOUS FILE STRUCTURES.
   IN EACH CASE, THE INDEX IS THE COMPRESSEDFILE STRUCTURE CODE (CFSC).
%
BIND
%READ ELEMENT ROUTINE%
   RRS=PLIT(ENC18X2(2,2,2,2,2,2,0,2,0,2,0,2,1,0,0,2,1,0),RI,RU,ER),
%WRITE ELEMENT ROUTINE%
   WRS=PLIT(ENC18X2(2,2,2,2,2,2,2,0,2,0,2,0,1,0,2,0,1,0),WI,WU,ER),
%READ BLOCK ROUTINE%
   RBRS=PLIT(ENC18X2(1,3,1,3,1,1,3,3,0,3,3,3,3,3,0,3,2,0),RBB,RUB,RBBU,ER),
%WRITE BLOCK ROUTINE%
   WBRS=PLIT(ENC18X2(3,1,3,1,1,1,3,3,3,0,3,3,3,3,3,0,2,0),WBB,WUB,WBBU,ER),
%SET CURSOR POSITION ROUTINES%
   SCPRS=PLIT(ENC18X2(2,2,1,1,1,1,2,2,2,2,0,0,0,0,0,0,0,0),SCPB,SCPU,ER),
%MAPPING VECTOR FOR FSC TO CFSC%
   MFSC=PLIT(ENC7X5(0,0,0,0,1,2,0),
             ENC7X5(0,0,0,0,0,3,4),
             ENC7X5(5,6,7,8,0,0,9),
             ENC7X5(10,0,0,11,12,13,14),
             ENC7X5(15,16,17,18,0,0,0)),
%ERROR RETURN CODES%
   ILLMODE=-1,
   NOCHAN=-2,
   LKFAIL=-3,
   ENFAIL=-4,
   NOINIT=-5,
   BADFID=-6;

%       BYTE VECTORS FOR THE TABLES
%
MAP LBYTEVEC MFSC[5,32], EXFIDT FIDT,
    COMTAB RRS:WRS:RBRS:WBRS:SCPRS;

LOCAL CFSC,DATMODE;

EXTERNAL JOBHCU,JOBJDA;

   ROUTINE CLEANUP=
      BEGIN EXECUTE(MAKEOP(RELEAS,.CF$[CHNL],0)); FBUF() END;


   BIND TTY=.FIDT[DEVICE] EQL SIXBIT 'TTY';

   IF .FIDT GEQ #400000 THEN RETURN BADFID;


   IF .CRSTD$ NEQ SIXBIT 'JORDAN' THEN $CRESET();

   CF$_$CGETM(FCBS);      %POINT TO FILE CONTROL BLOCK %

   (@CF$)<0,36> _ 0;  %ZERO FIRST WORD OF FILECB SPACE%
   MOVE(FCBS-1,@CF$,@CF$+1); %ZERO OUT REMAINDER OF FILECB%



   CF$[P]_.PARAM;
   CF$[NB]_.NBUFS;
   IF
      (CFSC_.MFSC[ENCODE((.CF$[NB] GTR 0),.CF$[MODE],.CF$[ORG],.CF$[TYPE])]-1)
         EQL -1
         THEN (FBUF(); RETURN ILLMODE);

   IF TTY THEN (CFSC_12; CF$[TYPE]_UPDATE);

   DATMODE_IF .CF$[ORG] EQL CHAR
              THEN 0
           ELSE IF .CF$[NB] EQL 0
              THEN #15
           ELSE #10;

   IF (CF$[CHNL]_       %AVOID CHANNEL ZERO DUE TO GETSEGS%
                  IF .JOBHCU LSS 15
                          THEN .JOBHCU+1
                  ELSE DECR S FROM 14 TO 1 DO
                     IF @(JOBJDA+.S) EQL 0 THEN EXITLOOP .S)
      LSS 0 THEN (FBUF(); RETURN NOCHAN);

   IF .FIDT[DEVICE] EQL 0 THEN FIDT[DEVICE] _ SIXBIT 'DSK';

   !SAVE USER FIDT INFO
     MOVE(MIN(8,.FIDT[ARGCNT]+2),FIDT<0,0>-1,CF$[FCBFIDT]);

   IF NOT INIT(.CF$[CHNL],.DATMODE,.FIDT[DEVICE],CF$[OBUFH]^18+CF$[IBUFH]<0,0>)
      THEN (FBUF(); RETURN NOINIT);

   IF .CF$[TYPE] NEQ OUTPUT
      THEN IF NOT LOOKUP(.CF$[CHNL],.FIDT) THEN (CLEANUP(); RETURN LKFAIL);
   IF .CF$[TYPE] NEQ INPUT
      THEN IF NOT ENTER(.CF$[CHNL],.FIDT) THEN (CLEANUP(); RETURN ENFAIL);

   IF (CF$[BSIZE]_DEVSIZ(.DATMODE,.FIDT[DEVICE])-3) LSS 0
      THEN (CLEANUP(); RETURN ILLMODE);


   IF .CF$[NB] GTR 0
      THEN BEGIN
         ROUTINE GENBF(SIDE)=
         BEGIN
            LOCAL T,K;
            EXTERNAL JOBFF;
            T_@JOBFF;
            JOBFF_(K_$CGETM((.CF$[BSIZE]+3)*.CF$[NB]+1))+1;
            EXECUTE(MAKEOP((INBF+.SIDE),.CF$[CHNL],.CF$[NB]));
            JOBFF_.T;
            .K
         END;

         CF$[BUFL]_0;
         IF .CF$[TYPE] NEQ OUTPUT THEN CF$[IBUFL]_GENBF(INPUT);
         IF .CF$[TYPE] NEQ INPUT THEN CF$[OBUFL]_GENBF(OUTPUT)
      END;

   IF NOT TTY
      THEN BEGIN
         CF$[RR]_.RRS[.CFSC];
         CF$[WR]_.WRS[.CFSC];
         CF$[RBR]_.RBRS[.CFSC];
         CF$[WBR]_.WBRS[.CFSC];
         CF$[SCPR]_.SCPRS[.CFSC];
         CF$[MAXCP]_.FIDT[WRDCNT]/.CF$[BSIZE]+1
         END
      ELSE BEGIN
         CF$[RR]_RI;
         CF$[WR]_WI;
         CF$[RBR]_ER;
         CF$[WBR]_ER;
         CF$[SCPR]_ER
%        CF$[MAXCP]_0  DONE BY GENERAL ZEROING OF FILECB%
         END;

   CF$[IBUFR]_CINBUF;
   CF$[OBUFR]_COUTBUF;
   CF$[INOP]_MAKEOP(INUUO,.CF$[CHNL],(IF .CF$[NB] EQL 0 THEN CF$[COML]<0,0> ELSE 0));
   CF$[OUTOP]_.CF$[INOP] OR 1^27;
   CF$[STATZOP]_MAKEOP(STATZ,.CF$[CHNL],#740000);
   CF$[USETIOP]_MAKEOP(USETI,.CF$[CHNL],0);
   CF$[USETOOP]_.CF$[USETIOP] OR 1^27;
%  CF$[EOFBIT]_CF$[DIRTY]_0;DONE BY GENERAL ZEROING OF FILECB%
   CF$[WLB]_.CF$[TYPE] EQL OUTPUT;
%  CF$[COML]+1_0;  DONE BY GENERAL ZEROING OF FILECB%
   CF$[ISIZE]_IF .CF$[ORG] EQL 0 THEN 7 ELSE 36;
   CF$[ITEMPW]_36/.CF$[ISIZE];
   CF$[EXCEPT]_IF .EXCP EQL 0 THEN IOABT ELSE .EXCP;

        %
        READ AHEAD IF NOT TTY, AND DO THE INITIALIZATION OF 
        THE OUTBUFFERS (IF REQ'D), NO DATA IS TRANSFERED.
        %
   IF .CF$[NB] GTR 0
      THEN BEGIN
         IF .CF$[TYPE] NEQ OUTPUT
         THEN IF NOT TTY
            THEN CINBUF();
         IF .CF$[TYPE] NEQ INPUT
            THEN OUTFAILS
      END;

   CF$[EXISTS]_SIXBIT 'NADROJ';  %SET FLAG THAT FILE-CONTROL-BLOCK EXISTS%

   .CF$

END;
END ELUDOM
m"