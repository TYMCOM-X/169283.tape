MODULE RIN(DOLLAR,ENTRIES=($TCRI,$TINPT,$TSEQI,$TESQI),
  FSAVE,TIMING,TIMER=EXTERNAL(SIX12))=BEGIN
%VERSION W1%
%LAST UPDATE, APR. 18,1975, BY V.E.VAN VLEAR%
REQUIRE DVDEFS.BLI[7,107355];
REQUIRE RDEFS.BLI[7,107355];
REQUIRE RMDEFS.BLI[7,107355];
REQUIRE FDEFS.BLI[7,107355];
REQUIRE UDEFS.BLI[7,107355];
REQUIRE CDEFS.BLI[7,107355];
REQUIRE KDEFS.BLI[7,107355];
REQUIRE FPDEFS.BLI[7,107355];

MACRO
  ERRQ(S)=
    BEGIN
    ERSW:=1;
    $TILER(.RMSG$[S],0,0);
    LEAVE ERLP
    END&,
  ERRN(S)=$TILER(.RMSG$[S],0,0)&,
  ERR(S)=
    BEGIN
    ERSW:=1;
    $TILER(.RMSG$[S],.FI,0);
    LEAVE ERLP
    END&;

UNDECLARE $TCRI,$TINPT,$TSEQI,$TESQI;

%RUNTIME ROUTINES%



%DOES PROMPT AND INPUTS LINE%
ROUTINE TPRMT(FI)=
BEGIN

LOCAL
  DD$ DD,               %Data Des. location%
  PTR,                  %Temp. string pointer%
  NM,                   %Adr. of field name%
  NCH,                  %No. of chars. in field name%
  CLINE$ LCB,           %Line Control Block address%
  KFCB$ FCB;            %File Control Block address%

MAP SC$ RSRC$;

FCB:=.RSRC$[SC$FCB];

IF .FCB[K$TERMI] THEN
IF .RSRC$[SC$PRMPT] THEN
  BEGIN         %PROMPT IF TERMI AND PROMPT SET%
  DD:=@(.FI-1);
  NM:=.DD[DD$NAME];              %NAME LOCATION%
  PTR:=@(.NM-1);
  NCH:=.(.PTR)<0,18>;             %NO. OF CHARS.%
  $UAPSC((.NM)<36,7>,.NCH);
  $UOCHR(":");
  $UOCHR(" ");
  $UPRPT()
  END
ELSE
  RSRC$[SC$PRMPT]:=SCV$TRUE;     %ALLOW FUTURE PROMPTS%

RSRC$[SC$START]:=SCV$FALSE;

LCB:=.RSRC$[SC$LCB];
IF .LCB[C$WCNT] LEQ 0 THEN
  BEGIN
  $KREAD(FCB);
  RSRC$[SC$EOF]:=.FCB[K$EOFILE] AND NOT .RSRC$[SC$ACCEPT];
  IF .FCB[K$OFLOW] THEN
    $TILER(.RMSG$[RM$ILO],.FI,0) %Input line overflow%
  END;
IF .FCB[K$TERMI] AND .FCB[K$EOFILE] THEN
  BEGIN
  RSRC$[SC$BAD]:=SCV$TRUE;
  RETURN .LCB[C$WPTR]
  END;
.LCB[C$WPTR]

END;


%READ ONE INPUT LINE AND PRESCAN%
ROUTINE ILPS(ROUT,FI)=
BEGIN

%SAVE CURRENT CHAR. IN CH AND GET NEXT CHAR. (NCH)%
MACRO GCH=BEGIN
  CH:=.NCH;
  NCH:=SCANI(BP);
  LCB[C$WCNT]:=.LCB[C$WCNT]-1;           %LINE CHAR. COUNT%
  END&,
  WCI(N)=REPLACEI(BFP,N)&;      %WRITE CHAR.%


LABEL QTLP,DQLP,ERLP;

BIND
  BLANK=#40,    %BLANK CHAR.%
  DITTO=#42,    %FULL-QUOTE%
  ILBSZ=2,      %FIXED PART OF ILB BUFFLETS%
  CR=#15;       %CARR. RET. CHAR.%

LOCAL IL$ ILB1:ILB2,ILI$ ILP,T2,T3,WC,ALP,PER,ERSW,ET,
  CLINE$ LCB,T1,ILI$ PTR:TPTR:IPTR,CH,NCH,BFP,BP,ICT,CN,CT,FCH;

MAP SC$ RSRC$;

LCB:=.RSRC$[SC$LCB];
ICT:=.0;                 %CLEAR ITEM COUNT%

ILB2:=.RSRC$[SC$ILB2];
IF .ILB2[IL$STATUS] EQL ILV$EMPTY THEN
  BEGIN
  %EXCHANGE ILB1 & ILB2%
  T1:=.RSRC$[SC$ILB2];
  ILB2:=RSRC$[SC$ILB2]:=.RSRC$[SC$ILB1];
  ILB1:=RSRC$[SC$ILB1]:=.T1;

  BP:=(.ROUT)(.FI);         %NO INPUT SO DO PROMPT AND GET LINE%
  IF .RSRC$[SC$BAD] THEN RETURN;

  ILB2[IL$SIZE]:=ILBSZ;
  RSRC$[SC$PTR]:=ILB2[IL$ITEM];  %INITIAL ITEM ADDRESS%
  ILB2[IL$STATUS]:=ILV$FULL      %SET STATUS FOR SOMETING IN ILB%
  END
ELSE
  BEGIN
  BP:=(.ROUT)(.FI);      %INPUT FOR ERROR - START WITH CURRENT ILB AREA%
  IF .RSRC$[SC$BAD] THEN RETURN;
  END;

DO
  BEGIN                 %THIS BLK REPEATED UNTIL ERSW EQL 0%
ERLP: BEGIN     %BLK (E), ERRORS CAUSE EXIT%
  ERSW:=0;
  PTR:=.RSRC$[SC$PTR];           %GET ADDRESS OF CURRENT ITEM%
  CH:=IPTR:=0;
  DO
    BEGIN                       %DO UNTIL NCH EQL TERM%
    PTR[IL$TEND]:=ILV$SEP;       %INITIALIZE TO SEP. TYPE ENDING%
    PTR[IL$NEXT]:=WC:=0;
    GCH;                        %SET NEXT CH. (FIRST CHAR WILL BE NO. 1)%
    IF .NCH EQL BLANK THEN
      DO GCH
      UNTIL .NCH NEQ BLANK;

    IF .NCH EQL "??" THEN IF .ICT EQL 0 THEN IF .LCB[C$WCNT] EQL 0 THEN
      BEGIN
      ERSW:=1;           %FORCE PROMPT%
      LEAVE ERLP
      END;

%SET CASE NUMBER ACCORDING TO CHAR.%
    IF .NCH EQL .RSRC$[SC$TERM] OR .LCB[C$WCNT] LSS 0 THEN CN:=0
    ELSE IF .NCH EQL .RSRC$[SC$SEP] THEN CN:=1
    ELSE IF .NCH EQL "'" THEN CN:=2
    ELSE IF .NCH EQL DITTO THEN CN:=3
    ELSE IF .NCH EQL "/" THEN CN:=4
    ELSE CN:=5;

    CASE .CN OF
      SET

%CASE 0, TERMINATOR%
BEGIN
PTR[IL$TEND]:=ILV$TERM;
PTR[IL$TYPE]:=ILV$NULL
END;

%CASE 1, SEPARATOR%
BEGIN
PTR[IL$TEND]:=ILV$SEP;
PTR[IL$TYPE]:=ILV$NULL
END;

%CASE 2, SINGLE QT.%
BEGIN
PTR[IL$TYPE]:=ILV$STR;
BFP:=(.PTR+2)<36,7>;
CT:=0;
GCH;
QTLP: WHILE 1 DO
  BEGIN
  IF .NCH EQL "'" THEN
    BEGIN
    GCH;
    IF .NCH NEQ "'" THEN LEAVE QTLP
    END;
  GCH;
  WCI(.CH);
  CT:=.CT+1;
  IF .CT GTR RV$MSTL THEN
    BEGIN
    ERR(RM$ISTL);       %Input string too long%
    LEAVE QTLP
    END
  END;
WC:=(.CT+4)/5;           %VARIABLE WORD COUNT%
INCR K TO .CT-((.WC-1)*5) DO WCI(BLANK);        %FILL LAST WORD%
PTR[IL$NCHAR]:=.CT       %CHAR. COUNT%
END;

%CASE 3, DITTO%
BEGIN
GCH;
%CHECK IF DITTO ACTION OR QUOTED STRING%
IF .LCB[C$WCNT] LSS 0 OR
   .NCH EQL .RSRC$[SC$TERM] OR .NCH EQL .RSRC$[SC$SEP] THEN
BEGIN
%FIND SAME ITEM IN ILB1 (USE ICT FOR ITEM COUNT)%
IF .ILB1 EQL 0 THEN ERR(RM$DIT1);       %No previous stored line%
TPTR:=ILB1[IL$ITEM];             %LOC. OF FIRST ITEM%
T1:=0;                           %ITEM COUNT%
UNTIL .T1 EQL .ICT DO
  BEGIN
  IF .TPTR[IL$NEXT] EQL 0 THEN ERR(RM$DIT2); %No previous item%
  TPTR:=.TPTR[IL$NEXT];
  T1:=.T1+1
  END;
%COPY ENTRY%
T2:=.TPTR<0,18>;
T3:=.PTR;
T1:=.TPTR[IL$NEXT];
IF .T1 EQL 0 THEN T1:=#777777;
DO
  BEGIN
  (@T3)[0]:=@.T2;             %MOVE WORD%
  WC:=.WC+1;             %COUNT WORD%
  T2:=.T2+1;
  T3:=.T3+1
  END
UNTIL
  @.T2 EQL 0 OR .T2 GTR .T1;
PTR[IL$NEXT]:=0;         %CLEAR PTR. FROM COPY VERSION%
WC:=.WC-ILBSZ    %CORRECT WORD COUNT FOR FIXED PART%
END
ELSE
  %DO QUOTED STRING%
  BEGIN
  PTR[IL$TYPE]:=ILV$STR;
  BFP:=(.PTR+2)<36,7>;
  CT:=0;
  DQLP: WHILE 1 DO
    BEGIN
    IF .NCH EQL DITTO THEN
      BEGIN
      GCH;
      IF .NCH NEQ DITTO THEN LEAVE DQLP
      END;
    GCH;
    WCI(.CH);
    CT:=.CT+1;
    IF .CT GTR RV$MSTL THEN
      BEGIN
      ERR(RM$ISTL);     %Input string too long%
      LEAVE DQLP
      END
    END;
  WC:=(.CT+4)/5;         %VARIABLE WORD COUNT%
  INCR K TO .CT-((.WC-1)*5) DO WCI(BLANK);      %FILL LAST WORD%
  PTR[IL$NCHAR]:=.CT     %CHAR. COUNT%
  END
END;

%CASE 4, "/"%

BEGIN
GCH;
IF .LCB[C$WCNT] GEQ 0 THEN
  IF .NCH NEQ .RSRC$[SC$TERM] THEN
    ERR(RM$SLSH);               %Chars. found after slash%
PTR[IL$TYPE]:=ILV$LNULL;
PTR[IL$TEND]:=ILV$TERM
END;

%CASE 5, ALPH-NUM%
BEGIN
CT:=0;
BFP:=(.PTR+2)<36,7>;
UNTIL .NCH EQL .RSRC$[SC$TERM] OR .NCH EQL .RSRC$[SC$SEP]
  OR .LCB[C$WCNT] LSS 0 DO
  BEGIN
  GCH;
  IF .CH EQL BLANK THEN
    BEGIN
    T1:=1;              %BLANK COUNT%
    UNTIL .NCH NEQ BLANK OR .LCB[C$WCNT] LSS 0 DO
      BEGIN
      GCH;
      T1:=.T1+1         %COUNT THE BLANKS%
      END;
    IF .NCH EQL .RSRC$[SC$TERM] OR .NCH EQL .RSRC$[SC$SEP]
      OR .LCB[C$WCNT] LSS 0 THEN 0
    ELSE
      BEGIN
      CT:=.CT+.T1;              %ADD SPACE COUNT TO CHAR. COUNT%
      INCR K TO .T1-1 DO WCI(" ")       %WRITE THE SPACES%
      END
    END
  ELSE
    BEGIN
    WCI(.CH);
    CT:=.CT+1
    END;
  IF .CT GTR RV$MSTL THEN ERR(RM$ISTL)  %Input string too long%
  END;
WC:=(.CT+4)/5;           %SET VARIABLE WORD COUNT%
INCR K TO .CT-((.WC-1)*5) DO WCI(BLANK);        %FILL LAST WORD%
PTR[IL$TYPE]:=ILV$STR;            %SET TYPE TO STRING%
PTR[IL$NCHAR]:=.CT               %NO. OF CHARS.%
END;

      TES;

    IF .NCH EQL .RSRC$[SC$TERM] OR .LCB[C$WCNT] LSS 0 THEN
      PTR[IL$TEND]:=ILV$TERM;    %SET TERMINATION FLAG%
    IPTR:=.PTR;                  %SAVE FOR TEST OF ENDING%
    IF .PTR[IL$TEND] NEQ ILV$TERM THEN
      BEGIN
      ICT:=.ICT+1;               %GO TO NEXT ITEM POS.%
      PTR[IL$NEXT]:=.PTR+ILBSZ+.WC;
      PTR:=.PTR[IL$NEXT]
      END
    ELSE
      RSRC$[SC$EOL] EQL SCV$TRUE
      END
  UNTIL
    .LCB[C$WCNT] LSS 0 OR
    .NCH EQL .RSRC$[SC$TERM] OR .IPTR[IL$TEND] EQL ILV$TERM;
  END;  %BLK (E), ERRORS CAUSE EXIT FROM THIS BLOCK (ERLP)%
  IF .ERSW NEQ 0 THEN
    BEGIN
    %RETRY ON ERRORS%
    LCB[C$WCNT]:=0;
    BP:=(.ROUT)(.FI);
    IF .RSRC$[SC$BAD] THEN RETURN
    END
  END
  UNTIL .ERSW EQL 0;            %IF ERSW NOT 0, THEN RETRY%

IF .LCB[C$WCNT] GTR 0 THEN LCB[C$WPTR]:=.BP              %SAVE BYTE PTR%
END;

%%
%INPUT AN ITEM FROM A SEQUENTIAL FILE%
GLOBAL ROUTINE $TINPT(FI,LDD)=
BEGIN

MACRO GCH=
        IF .NC GTR 0 THEN (CH:=SCANI(PTR); NC:=.NC-1) ELSE
          (CH:=" "; NC:=-1)&,
      ERX(S)=(ERSW:=S; LEAVE ERLP)&;

LOCAL FCH,SGNT,CMA,T1,T2,ILI$ ILL,IL$ ILB,CH,NEG,CT,
  PTR,ERSW,DOL,ET,NC,CS,SCS,CLINE$ LCB,KFCB$ FCB,
  VAL[2],CHSW,PER,ID,DP,NID,NDP,FP$I DDFP;

MAP SC$ RSRC$, DFI$ FI, DD$ LDD;

LABEL ERLP;

BIND DDV$STR=4,SCV$EMPTY=0;

BIND CHSIZE=7;          %CHAR. SIZE%

BIND BLANK=#40,K10=PLIT(0,10);


IF .RSRC$[SC$BAD] EQL SCV$TRUE THEN RETURN;     %DONT PROCESS IF BAD%
DDFP:=.LDD[DD$FP];               %FORMAT PICTURE FROM DATA DES.%
LCB:=.RSRC$[SC$LCB];
FCB:=.RSRC$[SC$FCB];

IF .RSRC$[SC$FF] EQL SCV$FREE THEN
  BEGIN
  ILB:=.RSRC$[SC$ILB2];
  IF .ILB[IL$STATUS] EQL ILV$EMPTY OR
     .RSRC$[SC$PTR] EQL ILB[IL$ITEM]<0,0> THEN
    BEGIN
    IF NOT .RSRC$[SC$START] THEN IF NOT .RSRC$[SC$EMPTY] THEN
      IF NOT .FCB[K$TERMI] THEN
        %IF NOT AT START OF INPUT LIST AND NOT TERMINAL, ERROR%
        BEGIN
        $TILER(.RMSG$[RM$INSF],.FI,0);  %Insufficient input%
        RSRC$[SC$BAD]:=SCV$TRUE;
        RETURN
        END;
    ILPS(TPRMT,.FI);
    IF .RSRC$[SC$BAD] THEN RETURN;
    RSRC$[SC$EMPTY]:=0;          %SETS NOT EMPTY%
    ILB:=.RSRC$[SC$ILB2]
    END
  END
ELSE
  IF NOT .RSRC$[SC$EMPTY] THEN
    PTR:=.LCB[C$WPTR];          %SET INPUT PTR. FOR FIXED FORM%

DO
BEGIN   %BLK (F),       RETURNS HERE ON ERRORS%
ERLP: BEGIN     %BLK (E), ERROR CAUSES JUMP TO END OF THIS%
ERSW:=0;

IF .RSRC$[SC$FF] EQL SCV$FREE THEN
  BEGIN
  ILL:=.RSRC$[SC$PTR];                %ITEM LOCATION%
  PTR:=(ILL[IL$VAL])<36,7>;        %STRING PTR. FOR GCH%
  NC:=.ILL[IL$NCHAR]             %NO. OF CHARS FOR COPY, ETC.%
  END
ELSE
  BEGIN
  IF .RSRC$[SC$EMPTY] THEN
    BEGIN
    %NO INPUT, DO READ FOR FIXED FORM%
    $KREAD(FCB);
    RSRC$[SC$EOF]:=.FCB[K$EOFILE] AND NOT .RSRC$[SC$ACCEPT];
    RSRC$[SC$START]:=SCV$FALSE;
    IF .FCB[K$OFLOW] THEN
      ERR(RM$ILO)               %Input line overflow%
    ELSE
      BEGIN
      RSRC$[SC$EMPTY]:=0;        %SET NOT EMPTY%
      PTR:=.LCB[C$WPTR]         %SET INPUT PTR.%
      END
    END
  ELSE
      IF .LCB[C$WCNT] LEQ 0 THEN
        IF NOT .RSRC$[SC$START] THEN
          %ERROR, NOT AT START FOR READ%
          ERR(RM$INSF);         %Insufficient input%
  NC:=.LDD[DD$PRSIZE];
  IF .NC GTR .LCB[C$WCNT] THEN
    IF .LCB[C$LCBCNT] NEQ .LCB[C$LCBSIZE] THEN
      BEGIN
      T1:=.NC-.LCB[C$WCNT];             %DETERMINE NO. OF CHARS. NEEDED%
      T2:=.LCB[C$EPTR];
      %BLANK OUT BUFFER FOR BALANCE OF FIELD%
     INCR K TO .T1-1 DO REPLACEI(T2," ");
      LCB[C$EPTR]:=.T2;
      LCB[C$LCBCNT]:=.LCB[C$LCBCNT]+.T1;                %UPDATE COUNT%
      LCB[C$WCNT]:=.LCB[C$WCNT]+.T1
      END;
  IF .NC GTR .LCB[C$WCNT] THEN
    ERR(RM$PRMR);       %Picture requires more chars.%
  LCB[C$WCNT]:=.LCB[C$WCNT]-.NC
  END;
  
IF (IF .RSRC$[SC$FF] EQL SCV$FREE THEN
  IF (.ILL[IL$TYPE] EQL ILV$NULL OR .ILL[IL$TYPE] EQL ILV$LNULL) THEN
    1
  ELSE 0 ELSE 0) THEN
    BEGIN
    %PROCESS NULL VALUE%
    IF .LDD[DD$NULLVAL] EQL 0 THEN
      %USE DEFAULT NULL VALUE (SPACES AND 0)%
      IF .LDD[DD$TYPE] EQL DDV$STR THEN
        BEGIN
        CT:=.LDD[DD$QP];
        T2:=FI[DD$IWO,0]<36,7>;
        INCR K TO .CT-1 DO
          REPLACEI(T2," ")
        END
      ELSE
        BEGIN
        FI[DD$IWO,0]:=0;
        IF .LDD[DD$TYPE] NEQ DDV$1WD THEN
          FI[DD$IWO,1]:=0
        END
    ELSE  %USE POINTER TO NULL VALUE F.I.%
      IF .LDD[DD$TYPE] EQL DDV$STR THEN
        BEGIN
        CT:=.LDD[DD$QP];
        T2:=FI[DD$IWO,0]<36,7>;
        PTR:=(.LDD[DD$NULLVAL])<36,7>;
        INCR K TO .CT-1 DO
          BEGIN
          GCH;
          REPLACEI(T2,.CH)
          END
        END
      ELSE
        BEGIN
        .FI:=@.LDD[DD$NULLVAL];
        IF .LDD[DD$TYPE] NEQ DDV$1WD THEN
          FI[DD$IWO,1]:=(.LDD[DD$NULLVAL])[1]
        END
    END

ELSE IF .LDD[DD$TYPE] EQL DDV$STR THEN
  %MOVE STRING%
  BEGIN
  IF .NC GTR .LDD[DD$PRSIZE] THEN
    ERR(RM$IEPL);       %Input exceeds picture length%
  T2:=(.FI)<36,7>;
  INCR K TO .NC-1 DO
    BEGIN
    GCH;
    REPLACEI(T2,.CH)
    END;
  IF .CH EQL "??" THEN IF .RSRC$[SC$FF] EQL SCV$FREE THEN
    IF .ILL[IL$NCHAR] EQL 1 THEN ERX(1);          %FORCED PROMPT%
  IF .RSRC$[SC$FF] EQL SCV$FREE THEN
  IF .ILL[IL$NCHAR] LSS .LDD[DD$QP] THEN
    INCR K TO .LDD[DD$QP]-.ILL[IL$NCHAR]-1 DO
    REPLACEI(T2," ");
  INCR K TO .T2<30,6>/CHSIZE DO REPLACEI(T2," ")       %FILL LAST WORD WITH BLANKS%
  END

ELSE IF .LDD[DD$CLASS] EQL DDV$CLASS1 THEN
  BEGIN
  %INPUT DATE%
  ERSW:=$TCBSD(PTR,.NC,LDD[DD$DT] %ADR.OF D.T.%,.FI);
  IF .ERSW NEQ 0 THEN 
    BEGIN
    ERSW:=.ERSW+21;             %SET ERROR NO. PAST RIN NOS.%
    LEAVE ERLP
    END
  END

ELSE
  %MOVE INTEGER FIELD%
  BEGIN
  VAL[0]:=VAL[1]:=PER:=ID:=DP:=0;    %INITIALIZE LOCALS%
  CHSW:=DOL:=NEG:=SGNT:=CMA:=CT:=0;
  UNTIL .NC LEQ 0 DO
    BEGIN
    GCH;
    IF .CH EQL "??" THEN IF .RSRC$[SC$FF] EQL SCV$FREE THEN
      IF .NC EQL 0 THEN ERX(1);       %FORCED PROMPT%
    CS:= IF .CH GEQ "0" AND .CH LEQ "9" THEN 0 ELSE
        IF .CH EQL "." THEN 0 ELSE
        IF .CH EQL "-" THEN 1 ELSE
        IF .CH EQL "+" THEN 2 ELSE
        IF .CH EQL "(" THEN 3 ELSE
        IF .CH EQL "$" THEN 4 ELSE
        IF .CH EQL "*" THEN 5 ELSE
        IF .CH EQL " " THEN 6 ELSE 7;
    IF .CS GTR 0 AND .CS LSS 6 THEN CHSW:=1;    %SET CHAR. SW.%
    CASE .CS OF
SET

%0      NUMBER OR PERIOD - START NUMBER PROCESSING%
UNTIL .NC LSS 0 DO
  BEGIN
  SCS:=  IF .CH GEQ "0" AND .CH LEQ "9" THEN 0 ELSE
        IF .CH EQL " " THEN 1 ELSE
        IF .CH EQL "." THEN 2 ELSE
        IF .CH EQL "+" THEN 3 ELSE
        IF .CH EQL ")" THEN 4 ELSE
        IF .CH EQL "-" THEN 5 ELSE
        IF .CH EQL "," THEN 6 ELSE
        IF .CH EQL "D" THEN 7 ELSE
        IF .CH EQL "C" THEN 8 ELSE 9;
  IF .SCS GTR 1 THEN CHSW:=1;           %SET CHAR. SW%
  CASE .SCS OF
  SET

  %0    NUMBER%
  BEGIN
  CT:=.CT+1;
  IF .CT LEQ 20 THEN
    BEGIN
    $UMPY(VAL,10);
    $UDADD(VAL,.CH-#60);
    IF .PER EQL 0 THEN ID:=.ID+1
      ELSE DP:=.DP+1;
    GCH
    END
  ELSE ERX(9)
  END;

  %1    " "%
  UNTIL .NC LSS 0 DO
    BEGIN
    GCH;
    IF .CH NEQ " " THEN ERX(17)
    END;

  %2    "."%
  IF .PER EQL 0 THEN (PER:=1; GCH) ELSE ERX(5);

  %3    "+"%
  IF .SGNT EQL 0 THEN (SGNT:=FPV$RTS; CH:=" ") ELSE ERX(2);

  %4    ")"%
  IF .SGNT EQL FPV$PAREN THEN CH:=" " ELSE ERX(10);

  %5    "-"%
  IF .SGNT EQL 0 THEN
    BEGIN
    SGNT:=FPV$RTS;
    NEG:=-1;
    CH:=" "
    END
  ELSE ERX(2);

  %6    ","%
  IF .PER EQL 0 THEN (CMA:=1; GCH) ELSE ERX(6);

  %7    "D"%
  IF .SGNT EQL 0 THEN
    BEGIN
    GCH;
    IF .CH EQL "B" THEN
      BEGIN
      SGNT:=FPV$DB;
      NEG:=-1;
      CH:=" "
      END
    ELSE ERX(7)
    END
  ELSE ERX(2);

  %8    "C"%
  IF .SGNT EQL 0 THEN
    BEGIN
    GCH;
    IF .CH EQL "R" THEN
      BEGIN
      SGNT:=FPV$CR;
      NEG:=-1;
      CH:=" "
      END
    ELSE ERX(8)
    END
  ELSE ERX(2);

  %9    BAD%
  ERX(4);

  TES
    END;

%1      "-"%
IF .SGNT EQL 0 THEN (SGNT:=FPV$LMP; NEG:=-1) ELSE ERX(2);

%2      "+"%
IF .SGNT EQL 0 THEN SGNT:=FPV$LMPS ELSE ERX(2);

%3      "("%
IF .SGNT EQL 0 THEN (SGNT:=FPV$PAREN; NEG:=-1) ELSE ERX(2);

%4      "$"%
IF .DOL EQL 0 THEN DOL:=1 ELSE ERX(3);

%5      "*"%
IF .DDFP[FP$FS] EQL FPV$STAR THEN 0 ELSE ERX(18);

%6      " "%
0;

%6      BAD%
ERX(4);

TES

    END;

  IF .DDFP[FP$SIGN] EQL FPV$NSC THEN IF .SGNT NEQ 0 THEN ERX(11);
  IF .SGNT EQL FPV$RTS THEN
    IF .DDFP[FP$SIGN] EQL FPV$RTS OR .DDFP[FP$SIGN] EQL FPV$RT THEN 0
    ELSE ERX(12)
  ELSE
    IF .SGNT GEQ FPV$PAREN THEN IF .SGNT NEQ .DDFP[FP$SIGN] THEN ERX(12);
  IF .CMA EQL 1 THEN IF .DDFP[FP$SP4] EQL FPV$FALSE THEN ERX(13);
  IF .DOL EQL 1 THEN IF .DDFP[FP$SP1] EQL FPV$FALSE AND
    .DDFP[FP$FS] NEQ FPV$DOLLAR THEN ERX(14);
  NID:=.(LDD[DD$QP])<9,9>;
  NDP:=.(LDD[DD$QP])<0,9>;
  T1:=.ID+.DP;
  IF .T1 GTR (.NID+.NDP) THEN ERX(15);
  IF .T1 EQL 0 THEN
    IF .CHSW THEN ERX(19)               %MUST HAVE AT LEAST 1 DIGIT%
    %NO DIGITS AND NO CHARACTERS%
    ELSE
      IF NOT .DDFP[FP$SP3] THEN ERX(20);  %MUST BE BLANK FUNC.%
  IF .ID GTR .NID THEN IF .DDFP[FP$SP2] THEN ERX(16);

  %DO SCALING IF NECESSARY%
  IF .PER NEQ 0 OR .DDFP[FP$SP2] THEN
    %DO SCALING%
    BEGIN
    IF .DP LSS .NDP THEN
      INCR K TO .NDP-.DP-1 DO $UMPY(VAL,10)
    ELSE IF .DP GTR .NDP THEN
      INCR K TO .DP-.NDP-1 DO
        IF $UMDDS(VAL,10,VAL) NEQ 0 THEN
          ERX(21)               %CAN ONLY TRUNCATE TRAILING ZEROS%
    END;
  IF .NEG NEQ 0 THEN
    IF .LDD[DD$TYPE] EQL DDV$1WD THEN
      FI[DD$IWO,0]:=-(.VAL[1])
    ELSE
    BEGIN
    FI[DD$IWO,0]:=-(.VAL[0]);
    IF .VAL[1] NEQ 0 THEN
      BEGIN
      FI[DD$IWO,0]:=.FI[DD$IWO,0]-1;
      FI[DD$IWO,1]:=(-.VAL[1]) AND #377777777777
      END
    END
  ELSE
    IF .LDD[DD$TYPE] EQL DDV$1WD THEN
      FI[DD$IWO,0]:=.VAL[1]
    ELSE
    BEGIN
    FI[DD$IWO,0]:=.VAL;
    FI[DD$IWO,1]:=.VAL[1]
    END
  END;
IF .RSRC$[SC$VERIFY] EQL SCV$TRUE THEN
  IF .LDD[DD$VERIFY] NEQ 0 THEN
    IF (.LDD[DD$VERIFY])(.FI) EQL 0 THEN ERR(RM$IN1); %Verify Failure%

END;    %BLK (E), JUMPS TO HERE ON ERROR%
IF .ERSW GTR 1 THEN
  BEGIN
  ET:=   ( CASE .ERSW-2 OF
  SET
  RM$IN2;
  RM$IN3;
  RM$IN4;
  RM$IN5;
  RM$IN6;
  RM$IN7;
  RM$IN8;
  RM$IN9;
  RM$IN10;
  RM$IN11;
  RM$IN12;
  RM$IN13;
  RM$IN14;
  RM$IN15;
  RM$IN16;
  RM$IN17;
  RM$IN18;
  RM$IN19;
  RM$IN20;
  RM$IN21;
%BEGINNING OF ERROR MESSAGES FOR DATE ROUTINES%
  RM$DT1;
  RM$DT2;
  RM$DT3;
  RM$DT4;
  RM$DT5;
  RM$DT6;
  RM$DT7;
  RM$DT8;
  RM$D  RM$DT10;
  RM$DT11;
  RM$DT12;
  RM$DT13;
  RM$DT14;
  RM$DT15;
  TES );
  $TILER(.RMSG$[.ET],.FI,0)                 %TYPE THE ERROR MESSAGE%
  END;

IF .ERSW NEQ 0 THEN
  BEGIN
  LCB[C$WCNT]:=0;                %CLEAR REMAINING CHARS.%
  IF .FCB[K$TERMI] AND .RSRC$[SC$FF] EQL SCV$FREE THEN
    BEGIN
    ILPS(TPRMT,.FI);
    IF .RSRC$[SC$BAD] THEN RETURN
    END
  ELSE
    BEGIN
    RSRC$[SC$BAD]:=SCV$TRUE;     %SET BAD FLAG%
    RETURN
    END
  END

END     %BLK (F), FOR REPEAT ON ERROR%
UNTIL .ERSW EQL 0;

IF .RSRC$[SC$FF] EQL SCV$FREE THEN
BEGIN
IF .ILL[IL$TYPE] NEQ ILV$LNULL THEN
  BEGIN
  RSRC$[SC$PTR]:=.ILL[IL$NEXT];     %SETS PTR TO NEXT ITEM OR 0%
  IF .ILL[IL$TEND] EQL ILV$TERM THEN
    ILB[IL$STATUS]:=ILV$EMPTY      %SET STATUS FOR NEXT ITEM%
  END
END ELSE
  LCB[C$WPTR]:=.PTR             %SAVE BYTE PTR IF NOT FREE FORM%
END;

%%
%SET SEQUENTIAL INPUT%
GLOBAL ROUTINE $TSEQI(SCB)=
BEGIN

MAP SC$ SCB:RSRC$;

LOCAL CLINE$ LCB,IL$ ILB2,KFCB$ FCB;

RSRC$:=.SCB;
FCB:=.RSRC$[SC$FCB];

RSRC$[SC$START]:=SCV$TRUE;
RSRC$[SC$PRMPT]:= IF .RSRC$[SC$BAD] OR NOT .RSRC$[SC$ACCEPT] THEN
  SCV$TRUE ELSE SCV$FALSE;      %SET FLAG TO ALLOW PROMPTS%

IF .RSRC$[SC$BAD] EQL SCV$TRUE THEN
  BEGIN
  ILB2:=.RSRC$[SC$ILB2];
  RSRC$[SC$PTR]:=ILB2[IL$ITEM];  %FORCES NEW ITEM TO START OF BUFFER%
  RSRC$[SC$BAD]:=SCV$FALSE       %CLEAR BAD BIT%
  END;

RSRC$[SC$EMPTY]:=0;     %SET FULL TO STOP READ BY TCRI%
IF .RSRC$[SC$FF] EQL SCV$FREE THEN
  BEGIN
  LCB:=.SCB[SC$LCB];
  LCB[C$WCNT]:=0                   %ZERO CHAR. COUNT%
  END
END;

%FORCE READ OF INPUT LINE%
GLOBAL ROUTINE $TCRI=
BEGIN

MAP SC$ RSRC$;
LOCAL IL$ ILB,KFCB$ FCB,CLINE$ LCB;

LCB:=.RSRC$[SC$LCB];
LCB[C$WCNT]:=0;          %FORCE BUFFER TO LOOK EMPTY FOR TPRMT%
IF .RSRC$[SC$FF] EQL SCV$FREE THEN
  BEGIN
  ILB:=.RSRC$[SC$ILB2];
  ILB[IL$STATUS]:=ILV$EMPTY
  END;
FCB:=.RSRC$[SC$FCB];
IF .RSRC$[SC$EMPTY] THEN
  BEGIN
  $KREAD(FCB);
  RSRC$[SC$EOF]:=.FCB[K$EOFILE] AND NOT .RSRC$[SC$ACCEPT];
  IF .FCB[K$OFLOW] THEN
    BEGIN
    ERRN(RM$ILO);       %Input line overflow%
    RSRC$[SC$BAD]:=SCV$TRUE
    END
  END;
RSRC$[SC$EMPTY]:=1            %FORCE EMPTY%
END;


%ENDS SEQUENTIAL INPUT (FOR FILES)%

GLOBAL ROUTINE $TESQI=
BEGIN

MAP SC$ RSRC$;

LOCAL ILI$ ILL,IL$ ILB;

LABEL ERLP;

IF NOT .RSRC$[SC$BAD] THEN
IF .RSRC$[SC$FF] EQL SCV$FREE THEN
  BEGIN
  ILL:=.RSRC$[SC$PTR];             %CURRENT AREA IN LINE BUFFER%
  ILB:=.RSRC$[SC$ILB2];            %CURRENT LINE BUFFER%
  IF .ILB[IL$STATUS] EQL ILV$FULL THEN
    IF .ILL[IL$TYPE] EQL ILV$LNULL THEN
      ILB[IL$STATUS]:=ILV$EMPTY
    ELSE
  ERLP: BEGIN
      RSRC$[SC$BAD]:=SCV$TRUE;
      ERRN(RM$MVTR)     %more values than required%
      END
  END

END;

RM$$$();                %DUMMY CALL TO FORCE READ OF RMSG$%

END ELUDOM
m@Ó