MODULE DOPE(DOLLAR,ENTRIES=($DOPEN,$DGRCB,$DARSB), 
        FSAVE,TIMING,TIMER=EXTERNAL(SIX12))=
BEGIN

REQUIRE DDEFS.BLI[7,107355];
REQUIRE DVDEFS.BLI[7,107355];
REQUIRE GDEFS.BLI[7,107355];
REQUIRE UDEFS.BLI[7,107355];
REQUIRE SDEFS.BLI[7,107355];
REQUIRE RDEFS.BLI[7,107355];
REQUIRE RCDEFS.BLI[7,107355];
REQUIRE RSDEFS.BLI[7,107355];
REQUIRE IBDEFS.BLI[7,107355];
REQUIRE DBDEFS.BLI[7,107355];

BIND PAGSIZ = 512; %MAGIC PAGE SIZE%

MAP U$DYNARY DBASE$;
MAP G$ DGAM$;
MAP DL$ DLIST$;
MAP DR$ DREGS$;
MAP DF$I DFLAG$;
MAP U$DYNARY DPOOL$;
MAP U$DYNARY DEFER$;
MAP U$DYNARY DRACK$;


UNDECLARE $DOPEN;

GLOBAL ROUTINE $DOPEN(STP,TYPE)=
   BEGIN
   %THIS ROUTINE GENERATES ONE EACH OPEN FOR A SCB,RB, OR AN RCB

    THIS CODE IS REASONABLY STRAIGHT FORWARD

    /JS..............................6/18/74

    %

    LOCAL P;
    MAP S$ P;

    $DFRCA(); %FORCE ARITH AC%
    $DFRCL(); %FORCE LOGICAL AC%

    P_$SGSTE(.STP); %GET IT, WHATEVER IT IS%
    IF .P[S$TYPE] EQL SV$SRCINC THEN
        BEGIN
        %A SOURCE....%
        $DGSCB(.P,1);
        $DGSAD(.DREGS$[DR$BASE,1],.DREGS$[DR$OFFSET,1],3);
        
        IF .TYPE EQL GV$OPEN THEN $DRNCL(RTRV$TOPNI,1)
        ELSE IF .TYPE EQL GV$CLOSE THEN $DRNCL(RTRV$TCLSI,1);
        END
    ELSE IF .P[S$TYPE] EQL SV$REPTINC THEN
        BEGIN
        %GET A REPORT  BLOCK%
        $DGRB(.P,1);
        $DGSAD(.DREGS$[DR$BASE,1],.DREGS$[DR$OFFSET,1],3);
        IF .TYPE EQL GV$OPEN THEN $DRNCL(RTRV$TOPNO,1)
        ELSE IF .TYPE EQL GV$CLOSE THEN $DRNCL(RTRV$TCLSO,1);
        END
   ELSE IF .P[S$TYPE] EQL SV$RELINC THEN
        BEGIN
        %GET A RELATION CONTROL BLOCK%
        $DGRCB(.P,1);
        $DGSAD(.DREGS$[DR$BASE,1],.DREGS$[DR$OFFSET,1],3);
        $DRNCL((SELECT .TYPE OF NSET
GV$OPEN:        RTRV$ROPEN;
GV$CLOSE:       RTRV$RCLSE;
GV$VIA :        RTRV$RSLCT;
GV$READ:        RTRV$READ;
GV$ALTER:       RTRV$RWRTE;
GV$INSERT:      RTRV$RNSRT;
GV$DELETE:      RTRV$RDLET;
GV$SORT:        RTRV$YSORT;
GV$INSORT:      RTRV$RSSRT;
GV$RELEASE:     RTRV$YRLSE;
GV$CHGD:        RTRV$RCHNG;
GV$FETCHALL:    RTRV$RFALL;
GV$STUFFALL:    RTRV$RSALL;
GV$LSBSORT:     RTRV$YLSRT;
GV$DELALL:      RTRV$RDALL; %DELETE ALL%
GV$COUNT:       RTRV$RCNT;  %COUNT THEM INSTANCESS%
                TESN),1);
        END;


   IF .TYPE EQL GV$VIA THEN
        BEGIN
        DXLOGAC$_.DGAM$[G$ID];
        DXLOGCT$_.DGAM$[G$UCNT];
        END;

   $SFRNCH(.P); %FREE IT%
   END;


UNDECLARE $DGRCB;

GLOBAL ROUTINE $DGRCB(RIB,I)= 
   BEGIN
   %GET ONE EACH RCB TO REGISTER I%

   LOCAL LBR,LFO,RBR,RFO,X,P,RDB,NOM;
   MAP S$ RIB;
   MAP S$ RDB;
   MAP S$ NOM;
   LOCAL P1,P2;
   LOCAL STP;
MAP RCBW$I P;
MAP RCBS$I P1;
MAP RCBR$I P2;


   %FIRST, LET US SEE IF WE CAN GET A QUICK TRIP HOME%
   IF .RIB[S$DBT] EQL SV$LC THEN
        BEGIN
        DREGS$[DR$BASE,.I]_.RIB[S$DB];
        DREGS$[DR$OFFSET,.I]_.RIB[S$DFO];
        DREGS$[DR$DDTYPE,.I]_DDV$1WD;
        DREGS$[DR$STP1  ,.I]_.RIB[S$STP1];
        RETURN %GRACEFUL EXIT%
        END;

   %WASN'T ALLOCATED, SO BEGIN BY LOOKING FOR THE RSB%
   RDB_$SGSTE(.RIB[S$RESTP]);

   IF .RDB[S$DBT] NEQ SV$LC THEN
        $DARSB(.RDB);  %NOT ALLOCATED,SO ALLOCATE IT%

%NOW ALLOCATE THE RCB..%
   RIB[S$DBT]_SV$LC;
   RIB[S$DB ]_DBV$RCBBASE;
   RIB[S$DFO]_.DBASE$[DBV$RCBBASE];
   RIB[S$DAL]_1;

   $SFGCH(.RIB);

   P_0;
   P[RC$TYPE]_SELECT .RIB[S$RCBTY] OF NSET

SV$FULLKY:      RCV$FULL;
SV$LEFTSB:      RCV$VIA;
OTHERWISE:      0;
                TESN;

   P[RC$SORT]_0;
   P[RC$DIRTY]_P[RC$TRACE]_P[RC$LOCK]_RCV$FALSE;

   P[RC$WHERE]_.RIB[S$WHEREFLG];   %SET WHERE FLAG%
   P[RC$FOREACH]_.RIB[S$FEFLG];   %SET  FOR EACH  FLAG..3/6/75%

   P[RC$MODE]_SELECT .RIB[S$IOMODE] OF NSET

SV$INPUT:       RCV$READ;
SV$UPDATE:      RCV$UPDATE;
SV$OUTPUT:      RCV$OUTPUT;
SV$SORTED:      RCV$SORTED;
OTHERWISE:      0;
                TESN;

   P[RC$STATE]_RCV$ST0; 
   P[RC$RSB]_.RDB[S$DFO];
   RBR_.RDB[S$DB];

   $DEUCE(DBV$RCBBASE);
   $DEMIT(DV$DRELR,0,.RBR,.RIB[S$STP1],.P);

%THAT WAS WORD 1..WOW!!%

%WORD 2..THE INNER AND OUTER RCB'S%
   P_0;
   $DEMIT(DV$CNST,0,0,0,.P);

%WORD 3..THE INNER AND OUTER RCB'S%
   $DEMIT(DV$CNST,0,0,0,.P);

%WORD 4..LEFT AND RIGHT BUFFERS%
   $DEMIT(DV$CNST,0,0,0,.P);

%WORD 5..FIRST ENTRY IN SORT LIST AND NUMBER OF SORT LIST ENTRIES%
   P_0;
   P[RC$JFCB]_0;
   P[RC$LNUM]_.RIB[S$SORTN];
   $DEMIT(DV$CNST,0,0,0,.P);

%WORD 6..NUMBER OF KEYS USED IN ACCESS AND NUMBER OF FIELDS IN REL%
   P[RC$KEYCT]_0;
   P[RC$FLDS]_.RDB[S$FIELDN];
   $DEMIT(DV$CNST,0,0,0,.P);


%FIRST, THE FIELD INSTANCE CHAIN%
   STP_.RIB[S$FISTP];

   WHILE .STP NEQ SV$NULL DO 
        BEGIN
        $DGFIE(.STP,1); %THIS FORCES THE FI%
        NOM _ $SGSTE(.STP);
%NOM HAS THE FI'S FI%
        P_0;
        P[RC$KEY]_SELECT .NOM[S$KDFLG] OF
           NSET
SV$KEYF:        RCV$TRUE;
SV$DATAF:       RCV$FALSE;
OTHERWISE:      RCV$FALSE;
            TESN;
        P[RC$FLD]_.DREGS$[DR$OFFSET,1];
        RBR_.DREGS$[DR$BASE,1];
        $DEUCE(DBV$RCBBASE);
        $DEMIT(DV$DRELR,0,.RBR,.DREGS$[DR$STP1,1],.P);
        STP_.NOM[S$FISTP];
        $SFRNCH(.NOM);
        END;

%NOW THE SORT CHAIN%
   STP_.RIB[S$SORTC];

   WHILE .STP NEQ SV$NULL DO
        BEGIN
        P1_0;
        $DGFIE(.STP,1);
        NOM_$SGSTE(.STP);
        P1[RC$DIR]_SELECT .NOM[S$SORTORD] OF
           NSET
SV$ASCEND:      RCV$UP;
OTHERWISE:      RCV$DOWN;
           TESN;

        P1[RC$CHAN]_0; %ANOTHER CHANGE 3/20/75 FOR JRO%
        P1[RC$KEYX]_.NOM[S$RSBO];
        P1[RC$LST]_.DREGS$[DR$OFFSET,1];
        RBR_.DREGS$[DR$BASE,1];
        $DEUCE(DBV$RCBBASE);
        $DEMIT(DV$DRELR,0,.RBR,.DREGS$[DR$STP1,1],.P1);
        STP_.NOM[S$SORTC];
        $SFRNCH(.NOM);
        END;

%NOW THE REPORT BLOCK CHAIN%

   IF .RIB[S$RNUM] NEQ 0 THEN
        BEGIN
        %AT LEAST ONE REPORT BLOCK%
        STP_.RIB[S$RICSTP];
        P2_0;
        P2[RC$RNUM]_.RIB[S$RNUM];
        
        WHILE .STP NEQ SV$NULL DO
           BEGIN
           NOM_$SGSTE(.STP);
           $DGRB(.NOM,1);
           P2[RC$RB]_.DREGS$[DR$OFFSET,1];
           RBR_.DREGS$[DR$BASE,1];
           $DEUCE(DBV$RCBBASE);
           $DEMIT(DV$DRELR,0,.RBR,.DREGS$[DR$STP1,1],.P2);
           STP_.NOM[S$RICSTP];
           $SFRNCH(.NOM);
           P2_0;
           END;

        DBASE$[DBV$RCBBASE]_.DBASE$[DBV$RCBBASE]+6+.RIB[S$RNUM]+
                .RIB[S$SORTN]+.RDB[S$FIELDN];
        END

   ELSE

        BEGIN
        $DEMIT(DV$CNST,0,0,0,0);
        DBASE$[DBV$RCBBASE]_.DBASE$[DBV$RCBBASE]+7+.RIB[S$SORTN]+
                .RDB[S$FIELDN];
        END;



    %DUMMY EXIT%
   $SFRNCH(.RDB);
   DREGS$[DR$BASE,.I]_.RIB[S$DB];
   DREGS$[DR$OFFSET,.I]_.RIB[S$DFO];
   DREGS$[DR$DDTYPE,.I]_DDV$1WD;
   DREGS$[DR$STP1  ,.I]_.RIB[S$STP1];

   END;
UNDECLARE $DARSB; 

GLOBAL ROUTINE $DARSB(RDB)=
   BEGIN
   %RIGHT KIDDIES...TIME TO ALLOCATE ONE OF THOSE RSB'S
   RELATION SPECIFICATION BLOCKS TO YOU MOMS AND DADS OUUT
   THERE IN MIDAS LAND

   AGAIN WE WILL DESCRIBE THE ROUTE AS WE GO

   /JS..............................9/25/74
   %

   LOCAL ISIZ,BSIZ,NEWMENT,C5;  %NEW FORMULAE FOR SKIM WORLD%
   LOCAL P,ISTP,RBR,RFO,NOM,C3,C4,IE;
   LOCAL STP,STP2;
   LOCAL XBASE;
   MAP S$ RDB ; %RDB HOLDS THE RELATION DEFINITION ENTRY%
   MAP S$ IE; %IE HOLDS AN ITEM ENTRY%
   MAP S$ NOM; %NOM IS A UTILITY BUFFER%
   MAP RSBW$I P; %P HOLDS RSB ONE WORD ATA TIME%

   XBASE_0; %FOR COMPUTING OFFSET IN ITEM ENTRIES%
   RDB[S$DBT]_SV$LC; %WELL,NOW IT'S ALOOCATED%
   RDB[S$DB]_DBV$RSBBASE;
   RDB[S$DFO]_.DBASE$[DBV$RSBBASE];
   RDB[S$DAL]_1;

   %WELL THE RDB HAS CHANGED..SO MARK IT%
   $SFGCH(.RDB);

   $DEUCE(DBV$RSBBASE);

%WORD 1...CURRENT RCB AND LAST(NEXT) RSB%
   P[RS$RCB]_0;

   IF .DXLASTRSB$ EQL -1 THEN
        BEGIN
        %VERY FIRST ONE!%
        RBR_0;
        P[RS$NXT]_0;
        END
   ELSE
        BEGIN
        %MORE THAN ONE%
        RBR_DBV$RSBBASE;
        P[RS$NXT]_.DXLASTRSB$;
        END;

   DXLASTRSB$_.RDB[S$DFO];

   $DEMIT(DV$DRELR,0,.RBR,.RDB[S$STP1],.P);

%WORD 2...LOCAL/SCHEMA FLAG, REFERENCE COUNT, AND NAME%
   NOM_$SGSTE($DNAME(.RDB[S$STP1]));
   RBR_.NOM[S$DB];
   P[RS$NAME]_.NOM[S$DFO];
   $SFRNCH(.NOM);
   P[RS$LOCAL]_.RDB[S$SCHF];
   P[RS$REF]_0;
   $DEUCE(DBV$RSBBASE);
   $DEMIT(DV$DRELR,0,.RBR,.RDB[S$STP1],.P);

%WORD 3...PHYSICAL RECORD LENGTH%
   P_0;
   P[RS$PRECL]_.RDB[S$PRECL];
!  IF .RDB[S$SCHF] THEN
!       BEGIN
!       %A RELATION VIA THE SCHEMA..GET SIXBIT FILE NAME
!       AND THEN POINT AT IT VIA RSB$FILE
!       3/18/75
!       %
!       $DGSYL(.RDB[S$RFNAM],7);
!       P[RS$FILE]_.DREGS$[DR$OFFSET,7];
!       $DEUCE(DBV$RSBBASE); %SAFETY!!%
!       $DEMIT(DV$DRELL,.DREGS$[DR$BASE,7],0,.RDB[S$STP1],.P);
!       END
!  ELSE
!  %LOCAL RELATION CASE%
   %ABOVE COMMENTING REPRESENT A FEATURE STRAUSS WANTS, BUT NOT JUST YET
   3/20/75..../JS
   %
   $DEMIT(DV$CNST,0,0,0,.P);

%WORD 4...LOGICAL RECORD SIZE AND FCB POINTER%
   P_0;
   P[RS$LBS]_.RDB[S$LRECL];
   $DEMIT(DV$CNST,0,0,0,.P);

%WORD 5..VERSION INFORMATION%
   P[RS$VERS]_-1;
   $DEMIT(DV$CNST,0,0,0,.P);

%WORD 6...MAGIC FIELDS FOR RICH STRAUSS..DBSIZ,IBSIZ,DBMENT,IBMENT%
   C3_ PAGSIZ - DBV$HDSZ;
   C4_ PAGSIZ - IBV$HDSZ;

   P[RS$DBSIZ]_(2*.RDB[S$LRECL])/.C3+SIGN((2*.RDB[S$LRECL]) MOD .C3);
   P[RS$IBSIZ]_(2*(.RDB[S$KEYL]+1))/.C4 +
                SIGN((2*(.RDB[S$KEYL]+1)) MOD .C4);
   %HOORAY A NEW SET OF FORMULAE FOR ALL THESE MAGNIFICENT SIZES
   DISPLACEMENTS, ETC

   TODAY IS 4/10/75..../JS

   FIRST THE OLD , UGLY, OBSOLETE FORMULAE
   %
!  P[RS$IBMENT]_(.P[RS$IBSIZ]*PAGSIZ - IBV$HDSZ) /(.RDB[S$KEYL]+1);
!  P[RS$DBMENT]_(.P[RS$DBSIZ]*PAGSIZ - DBV$HDSZ) /(.RDB[S$LRECL]);


   ISIZ_.RDB[S$LRECL];
   BSIZ _ IF .P[RS$DBSIZ] GTR .P[RS$IBSIZ] THEN .P[RS$DBSIZ] ELSE
        .P[RS$IBSIZ];
   P[RS$DBMENT]_(C5_(.BSIZ*RSV$PAGS-DBV$HDSZ))/.ISIZ;

   IF (C3_(.C5-.P[RS$DBMENT]*.ISIZ)/.BSIZ) GTR 63 AND (.BSIZ LSS 4) THEN
        BEGIN
        INCR I FROM .BSIZ+1 TO 4 DO
           BEGIN
           NEWMENT_(C5_(.I*RSV$PAGS-DBV$HDSZ))/.ISIZ;
           IF (C4_(.C5-NEWMENT*.ISIZ)/.I) LSS .C3 THEN
                BEGIN
                BSIZ_.I;
                C3_.C4;
                END;

           END;
        P[RS$IBSIZ]_P[RS$DBSIZ]_.BSIZ;
        P[RS$DBMENT]_(.BSIZ*RSV$PAGS-DBV$HDSZ)/.ISIZ;
        END;

   P[RS$IBMENT]_(.BSIZ*RSV$PAGS-DBV$HDSZ)/(.RDB[S$KEYL]+1);

   %END OF NEW FORMULAE..MAYBE SOME DAY STRAUSS WILL TELL ME WHAT
   IT MEANS%
   $DEMIT(DV$CNST,0,0,0,.P);

%WORD 7...KEY LENGTH%
   P_0;
   P[RS$KEYL]_.RDB[S$KEYL];
   P[RS$JRCT]_0; %SET JOURNAL FILE COUNT TO ZERO%
   $DEMIT(DV$CNST,0,0,0,.P);

%WORD 8...NUMBER OF KEYS/INST AND NUMBER OF FIELDS/INST%
   P[RS$XCT]_.RDB[S$KEYN];
   P[RS$DCT]_.RDB[S$FIELDN];

   $DEMIT(DV$CNST,0,0,0,.P);
   DBASE$[DBV$RSBBASE]_.DBASE$[DBV$RSBBASE]+8+2*.RDB[S$FIELDN];

   %MORE%
   %NOW EMIT THE FIELD DESCRIPTORS%

   ISTP_.RDB[S$ISTP];

   WHILE .ISTP NEQ SV$NULL DO
        BEGIN
        %SPIN OFF ONE EACH FIELD DESCRIPTION IN RSB%
        IE _ $SGSTE(.ISTP); %GET ITEM ENTRY%
        ISTP _ .IE[S$ISTP]; %NEXT ONE%
        NOM _ $SGSTE(.IE[S$STP1]); %GET NAME ENTRY%
        STP _ .NOM[S$IDSTP]; %READY FOR IDSTP CHAIN%
        $SFRNCH(.NOM); %GOODBYE NAME ENTRY%

        NOM_$SGSTE(.STP); %FIRST ITEM ENTRY%

        WHILE .NOM[S$IESTP] NEQ .IE[S$STPX] DO
           BEGIN
           %KEEP ON TRUCKIN UNTIL AN INCARNATION APPEARS THAT HAS
           THE SAME ITEM ENTRY AS THE ITEM ENTRY WE ARE LOOKING AT%
           STP_.NOM[S$IDSTP];
           $SFRNCH(.NOM);
           NOM_$SGSTE(.STP);
           END;

         %WELL WE FOUND IT%
        STP2_.IE[S$STPX];
        $SFRNCH(.IE); %IE WILL PROBABLY CHANGE%

        $DGFIE(.NOM[S$STPX],1); %FORCE ALLOCATION OD DD%

        IE_$SGSTE(.STP2);

        $SFRNCH(.NOM); %GOODBYE, USEFUL INCARNATION%

        NOM_$SGSTE(.IE[S$FDSTP]); %FIELD DEFINITION%
        $DEUCE(DBV$RSBBASE);
        P_0;
        P[RS$TYPE]_.IE[S$TPKI];
        P[RS$DDTYPE]_ (SELECT .NOM[S$DTYP] OF NSET
SV$SINGD:               DDV$1WD;
SV$DBLD:                DDV$2WD;
SV$SLIT:                DDV$STR;
OTHERWISE:              0;
                        TESN);

        P[RS$SIZE]_.NOM[S$LWORD];
        P[RS$UNPK]_.IE[S$PKI];
        $DEMIT(DV$CNST,0,0,0,.P);

%THAT WORD HAD TYPE,DDTYPE,AND PACKING INFORMATION
NEXT WORD HAS SIZE AND ADDRESS OF DD%

        P[RS$OFFSET]_.XBASE;
        P[RS$FLD]_.IE[S$DDFO];
        RBR_.IE[S$DDB];
        $DEMIT(DV$DRELR,0,.RBR,.IE[S$STP1],.P);

        XBASE_.XBASE+.NOM[S$LWORD]; %INCREMENT OFFSET FOR RICH%

%NOW RELEASE THE BUFFERS%
        $SFRNCH(.IE);
        $SFRNCH(.NOM);

        END;

   END;



%*******************%
END ELUDOM
