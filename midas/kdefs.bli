SWITCHES NOLIST;
UNDECLARE $$$;
%
THIS IS THE MIDAS-1 UNIVERSAL FILE KDEFS.BLI
   FOR SYMBOLS USING THE <LETTER> K.

DEFINITIONS OF STRUCTURES, MACROS, BINDS, ETC
  WHICH ARE USED BY MORE THAN ONE MIDAS MODULE
  ARE DEFINED HERE WITH  NAMES CORRESPONDING 
  TO THE CONVENTIONS OUTLINED IN SECTION
  1.9.4 PART E.

THE MAJORITY OF BLISS MODULES WILL BE COMPILED
  USING ONE OF THESE UNIVERSAL FILES.  THE FIRST EXPRESSION
  IN THE BLOCK HEADING WILL GENERALLY BE A REQUIRE
  STATEMENT:
       REQUIRE (MIDAS)KDEFS.BLI;

THE MACROS IN THIS FILE ARE TERMINATED WITH THE CHARACTER
AMPERSTAND:  &
THE NAMES IN THIS FILE CONTAIN DOLLAR SIGNS:  $
CONSEQUENTLY, THE MODULE HEADER OF ALL MODULES USING THIS
FILE MUST CONTAIN THE "DOLLAR" MODULE-PARAMETER.
%

EXTERNAL
   KFC$,        % GLOBAL VARIABLE USED BY SORT OVERLAY %
   KCOMR$,      % GLOBAL VARIABLE USED BY SORT OVERLAY %
   KPAR$,       % GLOBAL VARIABLE USED BY SORT OVERLAY %
   KST$,        % GLOBAL VARIABLE USED BY SORT OVERLAY %
   KFCB2$,      % GLOBAL VARIABLE USED BY SORT OVERLAY %
   KFCBC$,      % GLOBAL VARIABLE - HEAD OF FCB CHAIN %
   $KFRAFCB,    % CLOSE FILE AND FREE FCBS FOR SPECIFIED AREA NUMBER %
   $KFRNFCB,    % CLOSE FILE AND FREE FCBS NOT IN SPECIFIED AREA %
   $KDFID,      % DELETES A FILE GIVEN ITS FID %
   $KRENM,      % RENAMES A FILE GIVE ITS FCB AND NEW FIDT %
   $KWHY,       % OUTPUTS REASON FOR OPEN FAILURE %
   $KOPFL,      % FATAL ERROR ON FILE OPEN %
   $KPRFN,      % PRINTS THE FILE NAME FOR A FIDT TO UOUT %
   $KSQIB,      % INPUT BUFFER %
   $KSQOB,      % OUTPUT BUFFER %
   $KSQIZ,      % INITIALIZE FCB FOR SEQENTIAL PAGED MODE %
   $KRDLN,      % READ LINE %
   $KWRLN,      % WRITE LINE %
   $KSQLN,      % INITIALIZE SEQUENTIAL LINE MODE %
   $KAFCB,      % ALLOCATE AND OPEN A FCB FROM A FIDT %
   $KOFCB,      % OPEN FCB FROM FIDT %
   $KPNIC,      % PANIC TO EXCEPTION ROUTINE FOR ERROR OR EOF %
   $KILIO,      % ILLEGAL IO OPERATION ABORT %
   $KRDBL,      % READ SEQUENTIAL BLOCK %
   $KWRBL,      % WRITE SEQUENTIAL BLOCK %
   $KSQBL,      % INITIALIZE SEQUENTIAL BLOCK MODE %
   $KSCP,       % SET CURSOR POSITION %
   $KCP,        % READ CURSOR POSITION %
   $KCPX,       % READ FDX CURSOR POSITION %
   $KLKUP,      % LOOK UP A FILE FOR KV$INPUT TO CHECK ITS EXISTANCE %
   $KLOSE,      % CLOSE A FCB %
   $KLOSD,      % CLOSE WITH DELETE %
   $KNOFL,      % BAD FCB DIAGNOSTIC ROUTINE %
   $KIOAB,      % IO ABORT ROUTINE %
   $KGLED,      % GET LINE WITH EDIT FROM TERMINAL %
   $KTYPL,      % TYPE LINE ON TERMINAL %
   $KFCBD,      % DUMP FCB PRINTOUT TO TERMINAL %
   $KINSR,      % SKIM INSERTION %
   $KDLTE,      % SKIM DELETION %
   $KSETK,      % SKIM SET KEY %
   $KRSEQ,      % SKIM READ SEQUENTIAL %
   $KUPDT,      % SKIM REWRITE %
   $KRDKY,      % SKIM READ BY KEY %
   $KSRCH,      % SKIM INDEX SEARCH %
   $KGETP,      % SKIM GET EMPTY FILE PAGE %
   $KRELP,      % SKIM RELEASE FILE PAGE %
   $KFINT,      % SKIM FILE INITIALIZATION %
   $KNULL,      % SKIM GET NULL INSTANCE %
   $KIBUF,      % INITIALIZE BUFFERS %
   $KVIRD,      % VIRTUAL READ ROUTINE %
   $KVIWR,      % VIRTUAL WRITE %
   $KGBUF,      % GET EMPTY BUFFER %
   $KRBUF,      % RELEASE BUFFER %
   $KNFRE,      % RETURNS NUMBER OF FREE BUFFERS %
   $KFLSH,      % FLUSH BUFFERS %
   $KPHYR,      % PHYSICAL READ %
   $KPHYW,      % PHYSICAL WRITE %
   $KPRON,      % LOCK PAGE INTO CORE %
   $KPROF,      % UNLOCK PAGE %
   $KBTIN,      % BUFFER INDEX LOOKUP %

   $KSKIN,      % SKIM MODE INITIALIZATON ROUTINE %
   $KBINT,      % INITIALIZE BUFFERS FOR A NEW FILE %
   $KEYCM,      % KEY COMPARASION ROUTINE %
   $KACWR,      % SKIM ACTUAL WRITE ROUTINE %
   $KALBF,      % SKIM ALLOCATE BUFFERS ROUTINE %
   $KSTAR,      % SKIM START OF FILE ROUTINE  %
   $KRIBW,      % RIB WRITE ROUTINE %
   $KCNT,       % SKIM COUNT THE INSTANCES ROUTINE %
   $KRCVR,      % SKIM RECOVER AFTER ABNORMAL CLOSE ROUTINE %
   $KNFLS,      % SKIM NO FLUSH ROUTINE %
   $KRLSE,      % RELEASE TO SORT ROUTINE %
   $KRSRT,      % READ SORTED ROUTINE %
   $KSORT,      % SORT ROUTINE %
   $KSEXE,      % SORT EXECUTIVE FOR SEPARATE OVERLAY %
   $KWHER,      % WHERE ROUTINE %
   $KINIT,      % SORT MODE INITIALIZATION ROUTINE %
   $KBLDI,      % SKIM INDEX BUILD ROUTINE %
   $KDALL,      % SKIM DELETE ALL ROUTINE %
   $KNXDB,      % NEXT DB ROUTINE %
   $KSFIN,      % SKIM FILE INITIALIZATION ROUTINE FOR SCHEMA COMPILER %
   $KRIBP,      % SKIM RIB BLOCK LIMIT RESOLVER ROUTINE %
   $KLEAR;      % SKIM CLEAR DUPLICATES FROM POST-SORT FILE ROUTINE %

%
DEFINITIONS REQUIRED FOR THE IO ROUTINES
%
%
FILE CONTROL BLOCK STRUCTURE DEFINITION:
%
STRUCTURE KFCB$[FIELD] = CASE .FIELD OF
        SET
%FCB    %   (@.KFCB$   )< 0, 0>;
%LCHAIN %   (@.KFCB$   )<18,18>;
%RCHAIN %   (@.KFCB$   )< 0,18>;
%NLCHAIN%   (.(..KFCB$)< 0,18>)<18,18>;
%PRCHAIN%   (.(..KFCB$)<18,18>)< 0,18>;
%AREA   %   (@.KFCB$+ 1)< 0,36>;
%MODE   %   (@.KFCB$+ 2)<30, 6>;
%DRCT   %   (@.KFCB$+ 2)<27, 3>;
%TERM   %   (@.KFCB$+ 2)<26, 1>;
%SEQF   %   (@.KFCB$+ 2)<25, 1>;
%EOPAGE %   (@.KFCB$+ 2)<24, 1>;
%CHNL   %   (@.KFCB$+ 2)<18, 4>;
%SIMCH  %   (@.KFCB$+ 2)<15, 1>;
%TERMO  %   (@.KFCB$+ 2)<14, 1>;
%TERMI  %   (@.KFCB$+ 2)<13, 1>;
%INITUPD%   (@.KFCB$+ 2)<12, 1>;
%EOFILE %   (@.KFCB$+ 2)<11, 1>;
%DIRTY  %   (@.KFCB$+ 2)<10, 1>;
%WLB    %   (@.KFCB$+ 2)< 9, 1>;
%OFLOW  %   (@.KFCB$+ 2)< 8, 1>;
%PRCHR  %   (@.KFCB$+ 2)< 0, 7>;
%IBUFL  %   (@.KFCB$+ 3)< 0,36>;
%IDEX   %   (@.KFCB$+ 4)< 0,36>;
%ICOUNT %   (@.KFCB$+ 5)< 0,36>;
%OBUFL  %   (@.KFCB$+ 6)< 0,36>;
%ODEX   %   (@.KFCB$+ 7)< 0,36>;
%OCOUNT %   (@.KFCB$+ 8)< 0,36>;
%INOP   %   (@.KFCB$+ 9)< 0,36>;
%OUTOP  %   (@.KFCB$+10)< 0,36>;
%STATZOP%   (@.KFCB$+11)< 0,36>;
%IBP    %   (@.KFCB$+12)< 0,18>;
%USETIOP%   (@.KFCB$+12)< 0,36>;
%IWDCNT %   (@.KFCB$+13)<18,18>;
%ICOML  %   (@.KFCB$+13)< 0,18>;       % NEXT WORD IS %
% ZERO  %   (@.KFCB$+14)<0,0>;  % ALWAYS ZERO FOR INPUT UUO %
%OBP    %   (@.KFCB$+15)< 0,18>;
%USETOOP%   (@.KFCB$+15)< 0,36>;
%OWDCNT %   (@.KFCB$+16)<18,18>;
%OCOML  %   (@.KFCB$+16)< 0,18>;       % NEXT WORD IS %
% ZERO  %   (@.KFCB$+17)<0,0>;  % ALWAYS ZERO FOR OUTPUT UUO %
%LASTBC %   (@.KFCB$+18)< 0,36>;
%SBP    %   (@.KFCB$+19)< 0,36>;
%RR     %   (@.KFCB$+20)<18,18>;
%WR     %   (@.KFCB$+20)< 0,18>;
%SCPR   %   (@.KFCB$+21)<18,18>;
%EXCEPT %   (@.KFCB$+21)< 0,18>;
%CLOSER %   (@.KFCB$+22)< 0,18>;
%MAXCP  %   (@.KFCB$+23)< 0,36>;
%ICP    %   (@.KFCB$+24)< 0,36>;
%OCP    %   (@.KFCB$+25)< 0,36>;
%MODPB  %   (@.KFCB$+26)<18,18>;
%SOBP   %   (@.KFCB$+26)<18,18>;     % SAME AS MODPB %
%FIDPTR %   (@.KFCB$+26)< 0,18>;
%FCBFIDT%   (@(@.KFCB$+26))< 0, 0>;
%EXISTS %   (@.KFCB$+27)< 0,36>;
%IDCNT  %   (@.KFCB$+28)<18,18>;
%BLKSIZ%    (@.KFCB$+28)< 0,18>;
%IDADR  %   (@.KFCB$+28)< 0,18>;
%ODCNT  %   (@.KFCB$+29)<18,18>;
%ODADR  %   (@.KFCB$+29)< 0,18>;
            TES;


BIND    %BINDS FOR ACCESSING FIELDS OF FCB%
   K$FCB    =0,   % ADDRESS OF SELF FOR $KREAD AND $KWRITE %
   K$LCHAIN =1,   % FCB CHAIN - LEFT POINTER %
   K$RCHAIN =2,   % FCB CHAIN - RIGHT POINTER %
   K$NLCHAIN=3,   % FCB CHAIN - NEXT FCB'S LEFT POINTER %
   K$PRCHAIN=4,   % FCB CHAIN - PREV FCB'S RIGHT POINTER %
   K$AREA   =5,   % FCB CHAIN - AREA ASSOCIATION NUMBER %
   K$MODE   =6,   % MODE %
   K$DRCT   =7,   % DRCT = INPUT, OUTPUT, UPDATE OR FULL DUPLEX %
   K$TERM   =8,   % FLAG INDICATING THIS FCB IS FOR THE TERMINAL %
   K$SEQF   =9,   % FLAG INDICATING LINE INPUT FILE IS SEQUENCE NUMBERED %
   K$EOPAGE =10,  % END OF PAGE FLAG FOR LINE MODE IO %
   K$CHNL   =11,  % CHANNEL ASSIGNED TO THE FILE %
   K$SIMCH  =12,  % TRUE IF A SIMULATED CHANNEL (DONT DO CLOSE UUOS, ETC.) %
   K$TERMO  =13,  % TRUE IF THIS IS TERMINAL OUTPUT FCB %
   K$TERMI  =14,  % TRUE IF THIS IS TERMINAL INPUT FCB %
   K$INITUPD=15,  % FLAG INDICATING NEED FOR INIT OF UPDATE FILE %
   K$EOFILE =16,  % FLAG INDICATING END OF FILE ENCOUNTERED %
   K$DIRTY  =17,  % INDICATES OUTPUT BUFFER NEEDS WRITING %
   K$WLB    =18,  % WRITING LAST BLOCK OF FILE %
   K$OFLOW  =19,  % OVERFLOW OF INPUT DATA STRUCTURE OCCURRED %
   K$PRCHR  =20,  % PROMPT CHARACTER FOR TERMINAL OR 0 %
   K$IBUFL  =21,  % INPUT BUFFER PAGE ADDRESS %
   K$IDEX   =22,  % INDEX OF CURRENT WORD IN INPUT PAGE %
   K$ICOUNT =23,  % COUNT OF WORDS IN INPUT PAGE %
   K$OBUFL  =24,  % OUTPUT BUFFER PAGE ADDRESS %
   K$ODEX   =25,  % INDEX OF CURRENT WORD IN OUTPUT PAGE %
   K$OCOUNT =26,  % SIZE OF OUTPUT PAGE %
   K$INOP   =27,  % THE IN UUO FOR THIS CHANNEL %
   K$OUTOP  =28,  % THE OUT UUO FOR THIS CHANNEL %
   K$STATZOP=29,  % THE STATZ UUO FOR THIS CHANNEL %
   K$IBP    =30,  % BLOCK POSITION (128WD) ON INPUT FOR USETI %
   K$USETIOP=31,  % USETI UUO FOR THIS CHANNEL %
   K$IWDCNT =32,  % INPUT WORD COUNT FOR IO OPERATIONS %
   K$ICOML  =33,  % COMMAND LIST FOR CHANNEL OPERATIONS %
   % ZERO   =34,%  % ALWAYS ZERO WORD FOR INPUT UUO %
   K$OBP    =35,  % BLOCK POSITION (128WD) ON OUTPUT SIDE FOR USETO %
   K$USETOOP=36,  % USETO UUO FOR THIS CHANNEL %
   K$OWDCNT =37,  % OUTPUT WORD COUNT %
   K$OCOML  =38,  % OUTPUT OPERATION COMMAND LIST %
   % ZERO   =39,% % ALWAYS ZERO WORD FOR OUTPUT UUO %
   K$LASTBC =40,  % NUMBER OF WORDS IN LAST PAGE OF INPUT FILE %
   K$SBP    =41,  % POINTER TO BUFFER CONTAINING SB FOR FILE %
   K$RR     =42,  % READ ROUTINE %
   K$WR     =43,  % WRITE ROUTINE %
   K$SCPR   =44,  % SET CURSOR POSITION ROUTINE %
   K$EXCEPT =45,  % EXCEPTION HANDLING ROUTINE %
   K$CLOSER =46,  % CLOSE FILE ROUTINE FOR CLEANUP OPERATIONS %
   K$MAXCP  =47,  % MAXIMUM EXCURSION ON OUTPUT SIDE %
   K$ICP    =48,  % INPUT PAGE NUMBER FOR CRSOR ROUTINES %
   K$OCP    =49,  % OUTPUT PAGE NUMBER FOR CURSOR ROUTINES %
   K$MODPB  =50,  % MODE PARAMETER BLOCK POINTER %
   K$SOBP   =51,  % POINTER TO SOB FOR FILE %
   K$FIDPTR =52,  % POINTER TO FILE ID TABLE %
   K$FCBFIDT=53,  % ADDRESS OF FILE ID TABLE %
   K$EXISTS =54,  % VALIDATION WORD FOR CHECK ON FCB POINTER %
   K$IDCNT  =55,  % INPUT DATA ITEM COUNT %
   K$BLKSIZ =56,  % NUMBER OF PAGES IN A SKIM BLOCK %
   K$IDADR  =57,  % INPUT DATA ITEM ADDRESS%
   K$ODCNT  =58,  % OUTPUT DATA ITEM COUNT %
   K$ODADR  =59,  % OUTPUT DATA ITEM ADDRESS %
   KV$FCBS  =30;  % NUMBER OF WORDS IN AN FCB %



%
<FILE/STUFF-STATUS> FROM NOTEBOOK SECTION 3.5-3
THESE VALUES ARE RETURNED ON ERROR CONDITIONS AT
FILE OPEN OR FILE ACCESS TIME.
%

BIND    KV$EOF=#702,    %"HARD" END OF FILE     %
        KV$NOPEN=#701,  %"FILE" NOT OPENED/INIT %
        KV$NCLOSE=#703, %"FILE" NOT CLOSED/TERM %
        KV$ILMOD=#704,  %ILLEGAL MODE ON OPEN   %
        KV$NOCHN=#705,  %NO CHANNEL AVAIL       %
        KV$LKFAL=#706,  %LOOKUP FAILED          %
        KV$ENTFAL=#707, %ENTER FAILED           %
        KV$INTFAL=#710, %INIT FAILED            %
        KV$BDFIDT=#711, %BAD FIDT               %
        KV$ILIOP=#712, %ILLEGAL I/O OPERATION  %
        KV$IOERR=#713,  %IO ERROR               %
        KV$BDCURS=#714, %ILLEGAL CURSOR POSITION%
        KV$BDCNT=#715,  %BAD COUNT VALUE        %
        KV$NDADR=#716,  % NO DADR GIVEN FOR IO OPERATION %
        KV$BADCHK=#746, % INVALID CHECK REQUEST %
        KV$FEXISTS=#747, % FILE EXISTS WHEN NEW CHECK SPECIFIED %
        KV$REFUSED=#750, % USER REFUSED TO CONFIRM OPEN %
        KV$FNEW   =#751, % FILE DID NOT EXIST WHEN REQUIRED %
        KV$RENFL =#752, % RENAME FAILED %
        KV$DELFL =#753; % DELETE FAILED %

%
DEFINITION OF ACCESS STRUCTURE FOR A FILE
%

BIND
                  KV$PAGS  =512,        %SIZE OF PAGE IN WORDS%
  %MODES%         KV$SQLN  =#001,       %SEQUENTIAL LINE %
                  KV$SQBL  =#002,       %SEQUENTIAL BLOCK%
                  KV$SKIM=  #003,       %SKIM FILE %
  %DRCT%          KV$INPUT= #000,       %INPUT           %
                  KV$OUTPUT=#001,       %OUTPUT          %
                  KV$UPDATE=#002,       %UPDATE          %
                  KV$FDX=   #003,       %FULL DUPLEX     %
  % LASTOP %      KV$OPEN  = 0,         % OPEN %
                  KV$READ  = 1,         % SEQUENTIAL READ %
                  KV$SETK  = 2,         % SET KEY %
                  KV$REDK  = 3,         % READ BY KEY %
                  KV$NSRT  = 4,         % INSERT %
                  KV$DLTE  = 5,         % DELETE %
                  KV$UPDT  = 6,         % UPDATE(ALTER) %
 % CONFM MODE %   KV$NEW   = 1,         % NEW REQUIRED %
                  KV$EXISTS= 2,         % EXISTING REQUIRED %
                  KV$ANY   = 0,         % EITHER ONE OK %
                  KV$NONE  = 3;         % CONFIRM FROM USER ON OUTPUT %

!       THINGS DEFINING PARTS OF FID TABLE:
BIND
        K$DEVICE=0,
        K$ARGCNT=1,       %EXTENDED FIDT ARGUMENT COUNT%
        K$PROJ=  2,       %PROJECT NUMBER OF PPN%
        K$PROG=  3,       %PROGRAMMER NUMBER OF PPN%
        K$USER=  4,       %POINTER TO ENTIRE PPN%
        K$NAME=  5,       %FILE NAME IN SIXBIT%
        K$EXT=   6,       %FILE NAME EXTENSION IN SIXBIT%
        K$FWEXT= 7,       %EXTENSION AS FULL WORD%
        K$ADATE= 8,       %ACCESS DATE%
        K$PROT=  9,       %PROTECTION CODE%
        K$DMODE=10,       %DATA MODE%
        K$KTIME=11,       %CREATION TIME%
        K$KDATE=12,       %CREATION DATE%
        K$STATUS=13,      %STATUS BITS%
        K$WRDCNT=14,      %RBSIZE--FILE SIZE IN WORDS%
        K$VERSION=15,     %FILE VERSION NUMBER IN OCTAL%
        K$DEFEXT =16,     % BOOLEAN FOR EXTENSION DEFAULTED %
        K$ERRCODE=17,     % ERRORCODE ASSOCIATED WITH OPEN %
        K$CONFCODE=18,    % CONFIRMATION CODE DESIRED %
        K$USERNBLK=19,    % POINTER TO SPACE FOR USER NAME %
        K$OLDFILE=20,     % BOOLEAN RECORDING PREVIOUS EXISTENCE OF FILE %
        K$MONERR=21,      % LOCATION FOR MONITOR ERROR CODE ON LOOKUP/ENTER %
        K$PRFN=22,        % IF TRUE, PRINT FILE NAME DURING CONFIRM %
        K$ESTSIZE=23,     % ESTIMATED FILE SIZE IN BLOCKS %
        K$ALLOCATE=24,     % NUMBER OF BLOCKS ALLOCATED TO FILE %
        KV$ALLOCNT=10,    % SIZE OF FIDT IF ALLOCATE ENTRY USED %
        KV$ALLOCSIZ=KV$ALLOCNT+5,   % SIZE OF FIDT FOR ALLOCATE USERS %
        KV$DARGCNT=5,     % DEFAULT NO OF ARGS FOR LOOKUP/ENTER BLOCK %
        KV$DFIDTS=KV$DARGCNT+5;  % DEFAULT SIZE OF FIDT %

%DEFINITION OF EXTENDED LOOKUP TABLE%

STRUCTURE KFIDT$[FIELD]= CASE .FIELD OF
        SET
%DEVICE%   (@.KFIDT$+1)< 0,36>;
%ARGCNT%   (@.KFIDT$+4)< 0,36>;
%PROJ  %   (@.KFIDT$+5)<18,18>;
%PROG  %   (@.KFIDT$+5)< 0,18>;
%USER  %   (@.KFIDT$+5)< 0,36>;
%NAME  %   (@.KFIDT$+6)< 0,36>;
%EXT   %   (@.KFIDT$+7)<18,18>;
%FWEXT %   (@.KFIDT$+7)< 0,36>;
%ADATE %   (@.KFIDT$+7)< 0,12>;
%PROT  %   (@.KFIDT$+8)<27, 8>;
%DMODE %   (@.KFIDT$+8)<23, 4>;
%CTIME %   (@.KFIDT$+8)<12,11>;
%CDATE %   (@.KFIDT$+8)< 0,12>;
%STATUS%   (@.KFIDT$+8)< 0,36>;
%WRDCNT%   (@.KFIDT$+9)< 0,36>;  %RBSIZE%
%VERSION%  (@.KFIDT$+10)< 0,36>;  %IN OCTAL%
%DEFEXT %  (@.KFIDT$  )< 9, 1>;
%ERRCODE%  (@.KFIDT$  )< 3, 6>;
%CONFCODE% (@.KFIDT$  )< 0, 3>;
%USERNBLK% (@.KFIDT$+2)< 0, 0>;
%OLDFILE%  (@.KFIDT$+7)<17, 1>;
%MONERR %  (@.KFIDT$+7)< 0,18>;
%PRFN   %  (@.KFIDT$  )<10, 1>;
%ESTSIZE%  (@.KFIDT$+12)<0,36>;
%ALLOCATE% (@.KFIDT$+13)<0,36>;
        TES;


%  DEFINITION OF ENTRIES FOR SKIM SOB %


BIND
   K$SNKEY  =1,   %NUMBER OF KEYS IN EACH INSTANCE %
   K$SNFIELD=2,   % NUMBER OF FIELDS IN EACH INSTANCE %
   K$SDESCR =3,   % ADDRESS OF INSTANCE DESCRIPTOR %
   K$SKSIZ  =4,   % SIZE IN WORDS OF A FULL KEY %
   K$SISIZ  =5,   % SIZE IN WORDS OF AN INSTANCE %
   K$SKEYCT =6,   % NUMBER OF KEYS USED IN CURRENT OPERATION %
   K$SINSBUF=7,   % ADDRESS OF THE CURRENT INSTANCE BUFFER %
   K$SDBSIZ =8,   % SIZE IN PAGES OF EACH DB %
   K$SIBSIZ =9,   % SIZE IN PAGES OF EACH IB %
   K$SIBMENT=10,  % MAX # OF ENTRIES IN AN IB %
   K$SDBMENT=11,  % MAX # OF ENTRIES IN AN DB %
   K$SSPBP  =12,  % ADDRESS OF SEARCH PATH BLOCK %
   K$SEXPAND=13,  % FLAG TO INDICATE THAT FILE HAS EXPANDED %
   K$SCHANGE=14,  % FLAG TO INDICATE AN INSERT OR DELETE HAS OCCURRED %
   K$SDUPLICATES=15,  % DUPLICATE INSERTS DURING CREATION FLAG %
   K$SNEXT  =16,  % NEXT SOB IN CHAIN %
   K$SIBBUF  =17,  % BUFFER ADDRESS OF CURRENT LOWEST LEVEL IB %
   K$SLASTOP =18, % LAST OPERATION ON FILE %
   K$SSIZ   =19,  % # OF WORDS IN LEFT SUBSET KEY %
   K$SLASTINOP=20, % LAST INPUT OPERATION ON FILE %
   K$SNOL   =21,  % NUMBER OF INDEX LEVELS %
   KV$SOBSZ =7;   % SIZE OF AN SOB %


% STRUCTURE DEFINITION FOR SKIM SOB'S (KSOB$)  %


STRUCTURE KSOB$[FIELD]= CASE .FIELD OF
        SET
        0;
%NKEY   %    (@.KSOB$  )<27,9>;
%NFIELD %    (@.KSOB$  )<18,9>;
%DESCR  %    (@.KSOB$  )<0,18>;
%KSIZ   %    (@.KSOB$+1)<18,18>;
%ISIZ   %    (@.KSOB$+1)<0,18>;
%KEYCT  %    (@.KSOB$+2)<18,18>;
%INSBUF %    (@.KSOB$+2)<0,18>;
%DBSIZ  %    (@.KSOB$+3)<27,9>;
%IBSIZ  %    (@.KSOB$+3)<18,9>;
%IBMENT %    (@.KSOB$+3)<9,9>;
%DBMENT %    (@.KSOB$+3)<0,9>;
%SPBP   %    (@.KSOB$+4)<0,18>;
%EXPAND %    (@.KSOB$+4)<35,1>;
%CHANGE %    (@.KSOB$+4)<34,1>;
%DUPLICATES% (@.KSOB$+5)<35, 1>;
%NEXT   %    (@.KSOB$+5)< 0,18>;
%IBBUF  %    (@.KSOB$+6)<0,18>;
%LASTOP %    (@.KSOB$+6)<18,6>;
%SSIZ   %    (@.KSOB$+4)<18,16>;
%LASTINOP%   (@.KSOB$+6)<24,6>;
%NOL   %     (@.KSOB$+6)<30,6>;
        TES;

%  DEFINITION OF ENTRIES FOR SKIM FIELD DESCRIPTOR BLOCK (KDSC$) %

BIND
   K$STYPE   =0,       % UNPACK TYPE %
   K$SDDTYPE =1,       % DATA TYPE %
   K$SUNPK   =2,       % UNPACKING INFO %
   K$SSIZE   =3,       % SIZE IN WORDS %
   K$SFLD    =4,       % POINTER TO DATA DESCRIPTOR %
   K$SOFFSET =5;       % OFFSET FROM START OF INSTANCE %

%  STRUCTURE DEFINITION FOR FIELD DESCRIPTOR BLOCK %

STRUCTURE KDSC$[FIELD,I]= CASE .FIELD OF
       SET
%TYPE   %  (@.KDSC$+.I*2  )<33,3>;
%DDTYPE %  (@.KDSC$+.I*2  )<27,6>;
%UNPK   %  (@.KDSC$+.I*2  )<0,18>;
%SIZE   %  (@.KDSC$+.I*2  )<18, 9>;
%FLD    %  (@.KDSC$+.I*2+1)<0,18>;
%OFFSET %  (@.KDSC$+.I*2+1)<18,18>;
       TES;


%  DEFINITION OF ENTRIES FOR SKIM SEARCH PATH BLOCK (KSPB$) %

BIND
  K$SDBPN      =0,       % PAGE # OF CURRENT DB %
  K$SDBOF      =1,       % OFFSET OF CURRENTANCE IN DB %
  K$SDBBA      =2,       % BUFFER ADDRESS OF CURRENT DB %
  K$SVERN      =3,       % VERSION NUMBER OF CURRENT DB %
  K$SIBPN      =4,       % PAGE # OF IB[I] ON PATH %
  K$SIBOF      =5,       % OFFSET OF ENTRY IN IB[I] ON PATH %
  KV$SPSZ      =20;      % SIZE OF SEARCH PATH BLOCK %

%  STRUCTURE DEFINITION FOR SEARCH PATH BLOCK %

STRUCTURE KSPB$[FIELD,I]= CASE .FIELD OF
       SET
%DBPN  %  (@.KSPB$     )<18,18>;
%DBOF  %  (@.KSPB$     )< 0,18>;
%DBBA  %  (@.KSPB$+1   )<18,18>;
%VERN  %  (@.KSPB$+1   )< 0,18>;
%IBPN  %  (@.KSPB$+.I+1)<18,18>;
%IBOF  %  (@.KSPB$+.I+1)< 0,18>;
       TES;


%  MACROS FOR DOING IO THROUGH THE FCB
%

MACRO
   $KFCBC$LINK(FCB,AREAN)=
           BEGIN % ADD NEW FCB TO CHAIN OF FCBS %
           REGISTER KFCB$ CHAINHEAD; % BECAUSE CHAIN IN FIRST WORD %
           CHAINHEAD _ KFCBC$;       %  OF FCB THIS IS POSSIBLE      %
           FCB[K$LCHAIN] _ KFCBC$;   % INSERT AT BEGINNING %
           FCB[K$RCHAIN] _ .CHAINHEAD[K$RCHAIN];
           FCB[K$NLCHAIN] _ FCB[K$FCB];
           FCB[K$PRCHAIN] _ FCB[K$FCB];
           FCB[K$AREA] _ AREAN
           END&;

MACRO
   $KFCBC$DELINK(FCB)=
   IF NOT (.FCB[K$LCHAIN] EQL 0 ) THEN
     IF NOT (.FCB[K$RCHAIN] EQL 0 ) THEN
       BEGIN
          % REMOVE FCB FROM CHAIN %
          FCB[K$PRCHAIN] _ .FCB[K$RCHAIN];
          FCB[K$NLCHAIN] _ .FCB[K$LCHAIN]
       END&;

MACRO
   $KCRFCB(NAME,FEXT,USER,DIRECTN,MODERTN,MPB)=
      BEGIN
      LOCAL KFCB$ FCB, KFIDT$ FIDT;
      FCB_$CGTZM(KV$FCBS);
      $KFCBC$LINK(FCB,.CAREA$);
      FIDT_$CGTZM(KV$DFIDTS);
      FIDT[K$DEVICE]_ SIXBIT 'DSK';
      FIDT[K$ARGCNT]_KV$DARGCNT;
      FIDT[K$USER]_USER;
      FIDT[K$NAME]_NAME;
      FIDT[K$FWEXT]_FEXT;
      FCB[K$FIDPTR]_.FIDT;
      FCB[K$MODPB]_MPB;
      FCB[K$DRCT]_DIRECTN;
      IF $KOFCB(.FCB,MODERTN<0,0>) NEQ .FCB
         THEN $KOPFL(.FCB)
         ELSE .FCB
      END&,
   $KCRFCBNOC(NAME,FEXT,USER,DIRECTN,MODERTN,MPB)=
      BEGIN
      LOCAL KFCB$ FCB, KFIDT$ FIDT;
      FCB_$CGTZM(KV$FCBS);
      FIDT_$CGTZM(KV$DFIDTS);
      FIDT[K$DEVICE]_ SIXBIT 'DSK';
      FIDT[K$ARGCNT]_KV$DARGCNT;
      FIDT[K$USER]_USER;
      FIDT[K$NAME]_NAME;
      FIDT[K$FWEXT]_FEXT;
      FCB[K$FIDPTR]_.FIDT;
      FCB[K$MODPB]_MPB;
      FCB[K$DRCT]_DIRECTN;
      IF $KOFCB(.FCB,MODERTN<0,0>) NEQ .FCB
         THEN $KOPFL(.FCB)
         ELSE .FCB
      END&,
   $KFREEFCB(FCB)=
      IF .FCB[K$EXISTS] EQL FCB[K$FCB]
         THEN $KLOSE(FCB[K$FCB])
         ELSE $KNOFL()&,
   $KREAD(FCB)=
      IF .FCB[K$EXISTS] EQL FCB[K$FCB]
         THEN (.FCB[K$RR])(FCB[K$FCB])
         ELSE $KNOFL()&,
   $KWRITE(FCB)=
      IF .FCB[K$EXISTS] EQL FCB[K$FCB]
         THEN (.FCB[K$WR])(FCB[K$FCB])
         ELSE $KNOFL()&;


% MACRO $KFATL FOR GENERATING FATAL ERROR MESSAGES  %

MACRO $KFATL(N)= ($UOUTM(FTLMS$<36,7>,0); $FATAL(N))&;


%  MISC BINDS %

BIND
   KV$INSR=0,           %  JOURNAL FILE ENTRY IS AN INSERT %
   KV$DELT=1,           %  JOURNAL FILE ENTRY IS A DELETE %
   KV$ALTR=2,           %  JOURNAL FILE ENTRY IS AN ALTER %
   KV$MASSAGE=0,   % PARAMETER TO $KSRCH %
   KV$NOMASSAGE=1, % SAME %
   KV$SEARCH=1,    % PARAMETER TO $KUPDT %
   KV$NOSEARCH=0,    % SAME %
   KV$MOVECURSOR=1,  % PARAMETER TO $KRSEQ & $KNXDB  %
   KV$NOMOVECURSOR=0,  %  SAME  %
   KV$YCOMP=0,     % PARAMETER TO $KSORT %
   KV$KEYCM=1;     % SAME %

% THIS IS THE END OF KDEFS.BLI
%
SWITCHES LIST;
@j