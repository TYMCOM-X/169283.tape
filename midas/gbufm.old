MODULE GBUFM(DOLLAR,ENTRIES=($GIBUF,$GNBUF,$GRBUF,$GWBUF,$GMBUF,$GDBUF,$GCBUF,$GFBUF,$GFREC,$GLREC),
                        FSAVE,TIMING,TIMER=EXTERNAL(SIX12)) =
  BEGIN

  REQUIRE UDEFS.BLI[7,107355];
  REQUIRE GDEFS.BLI[7,107355];
  REQUIRE CDEFS.BLI[7,107355];
  REQUIRE FDEFS.BLI[7,107355];

  BIND
    BUFNO    = 0,
    BUFLEN   = 1,
    BUFDISP  = 2,
    BUFLINK  = 3;
  STRUCTURE BUFFER[FIELD] = CASE .FIELD OF
      SET
    (@.BUFFER  )<28,8>;         % BUFFER-INCREMENT NUMBER   %
    (@.BUFFER  )<12,16>;        % BUFFER LENGTH             %
    (@.BUFFER  )<0,12>;         % DISPLACEMENT TO THE NEXT AVAILABLE
                                  BUFFER ENTRY
                                %
    (@.BUFFER+1)<0,36>;         % LINK TO THE NEXT BUFFER-INCREMENT    %
      TES;

  UNDECLARE $GIBUF, $GNBUF,$GRBUF,$GWBUF,$GMBUF,$GDBUF,$GCBUF,$GFBUF,$GFREC,$GLREC;


%***
  INITIALIZE BUFFER MAINTENANCE
      INIT. THE FREE INDEX QUEUE WITH ALL VALID INDEX VALUES. THIS ROUTINE IS CALLED BY
        $GEXEC EXCLUSIVELY.
***%
  GLOBAL ROUTINE  $GIBUF =
    BEGIN
    GQUEH$ _ 1;
    GQUET$ _ GV$EBUFX;
    INCR I FROM 0 TO GV$EBUFX
      DO
        GQUE$[.I] _ .I;
    END;

%***
  GET A NEW BUFFER
      DETERMINE IF THERE ARE ANY MORE BUFFER INDEXES AVAILABLE. IF NOT THEN
      RETURN THE VALUE -1. OTHERWISE, GET A BLOCK OF MEMORY AND SAVE ITS 
      ADDRESS AS BOTH THE FIRST AND LAST BUFFER INCREMENT IN GBUFX$.
      INITIALIZE THE STANDARD BUFFER INFORMATION. UPDATE THE QUEUE HEAD
      POINTER AND RETURN THE BUFFER'S INDEX VALUE.
***%

  GLOBAL ROUTINE  $GNBUF(BUFSIZE) =
    BEGIN
    LOCAL CURIX;
    LOCAL BUFFER CBUFPTR;       % CURRENT BUFFER POINTER  %

    BUFSIZE _ .BUFSIZE + 2;
    IF .GQUEH$ EQL .GQUET$
      THEN     % BUFFER ALLOCATION CAPACITY EXCEEDED  %
        $FATAL(#074)
      ELSE
        BEGIN
        CURIX _ .GQUE$[.GQUEH$] * 2;  % TWO POINTERS PER BUFFER %
        CBUFPTR _ GBUFX$[.CURIX] _ GBUFX$[.CURIX +1] _ $CGTZM(.BUFSIZE);
        CBUFPTR[BUFNO] _ 1;
        CBUFPTR[BUFLEN] _ .BUFSIZE;
        CBUFPTR[BUFDISP] _ 2;
        CBUFPTR[BUFLINK] _ 0;
        IF .GQUEH$ EQL GV$EBUFX
          THEN
            GQUEH$ _ 1
          ELSE
            GQUEH$ _ .GQUEH$ +1;
        END;

    .CURIX
    END;

%***
  RELEASE A BUFFER
     INSURE THAT THE INDEX VALUE IS VALID. TRAVERSE THE LIST OF BUFFER
     INCREMENTS WHICH DEFINE THE LOGICAL BUFFER AND FREE THE MEMORY ASSIGNED
     TO EACH. INSURE THAT THE INDEX QUEUE IS NOT FULL. ADD THE INDEX TO THE
     QUEUE OF AVAILABLE INDEXES.
***%

  GLOBAL ROUTINE $GRBUF(CURIX) =
    BEGIN
    LOCAL BUFFER CBUFPTR;       % CURRENT-BUFFER POINTER    %
    LOCAL BUFFER NBUFPTR;       % NEXT-BUFFER POINTER       %

    IF .CURIX LSS 2 OR .CURIX GTR GV$EBUFX * 2
      THEN    %  COMPILER ERROR; INVALID INDEX NO.  %
        $FATAL(#077)
      ELSE
        BEGIN
        CBUFPTR _ .GBUFX$[.CURIX];
        WHILE .CBUFPTR NEQ 0
          DO
            BEGIN
            NBUFPTR _ .CBUFPTR[BUFLINK];
            $CFREEM(.CBUFPTR);
            CBUFPTR _ .NBUFPTR;
            END;
        IF (.GQUET$ + 1 EQL .GQUEH$)        OR
           (.GQUET$ EQL GV$EBUFX  AND  .GQUEH$ EQL 1)
          THEN   %  COMPILER ERROR;  BUFFER-INDEX QUEUE IS FULL AND
                    IT SHOULDN'T BE
                 %
            $FATAL(#076)
          ELSE
            BEGIN
            GQUET$ _ .GQUET$ + 1;
            IF .GQUET$ GTR GV$EBUFX
              THEN
                GQUET$ _ 1;
            GQUE$[.GQUET$] _ .CURIX/2
            END;

         END;
    .CURIX
    END;

%***
  WRITE TO A BUFFER
      INSURE THAT THE INDEX IS VALID. IF IT IS ZERO THEN WRITE THE RECORD
      TO THE GAMMA FILE. OTHERWISE, PUT THE RECORD INTO THE APPROPRIATE
      BUFFER. A POINTER TO THE RECORD IS RETURNED. IF THE RECORD WAS WRITTEN
      TO THE GAMMA FILE THEN THE RECORD POINTER EQUALS ZERO.
***%

  GLOBAL ROUTINE  $GWBUF(SOURCE, CURIX) =
    BEGIN
    LOCAL BUFFER CBUFPTR;       % CURRENT BUFFER POINTER        %
    LOCAL BUFFER LBUFPTR;       % LAST OR PRECEDING BUFFER POINTER  %
    LOCAL G$ CRECPTR;       % POINTER TO THE CURRENT RECORD IN THE BUFFER  %
    LOCAL GRPTR$I RECORDP;
    LOCAL SIZE, CBUFEND;

    MAP G$ SOURCE;

    RECORDP _ 0;
    IF .CURIX LSS 0 OR .CURIX GTR GV$EBUFX * 2
      THEN  %  COMPILER ERROR;  INVALID INDEX NUMBER  %
        $FATAL(#075);
    IF .CURIX EQL 0
      THEN  %  WRITE THE RECORD TO THE GAMMA FILE       %
        $COUTG(.SOURCE)
      ELSE  %  PUT THE RECORD INTO THE SPECIFIED HOLDING BUFFER  %
        BEGIN
        CBUFPTR _ .GBUFX$[.CURIX + 1];
        CBUFEND _ .CBUFPTR + .CBUFPTR[BUFLEN] ;
        CRECPTR _ .CBUFPTR + .CBUFPTR[BUFDISP];
        SIZE _ .SOURCE[G$LENGTH];
        IF .CRECPTR + .SIZE GTR .CBUFEND
          THEN  %  NO MORE SPACE IN THIS BUFFER INCREMENT. GET ANOTHER
                   INCREMENT.
                %
            BEGIN
            IF .CRECPTR LSS .CBUFEND
              THEN
                CRECPTR[G$LENGTH] _ 0;
            IF .CBUFPTR[BUFLINK] NEQ 0
              THEN
                BEGIN
                CBUFPTR _ .CBUFPTR[BUFLINK];
                CRECPTR _ .CBUFPTR + 2;
                END
              ELSE
                BEGIN
                LBUFPTR _ .CBUFPTR;
                CBUFPTR _ $CGTZM(.CBUFPTR[BUFLEN]);
                CBUFPTR[BUFNO]  _ .LBUFPTR[BUFNO] + 1;
                CBUFPTR[BUFLEN] _ .LBUFPTR[BUFLEN];
                CBUFPTR[BUFDISP] _ 2;
                CBUFPTR[BUFLINK] _ 0;
                LBUFPTR[BUFLINK] _ .CBUFPTR;
                CRECPTR _ .CBUFPTR + 2;
                END;
            GBUFX$[.CURIX + 1] _ .CBUFPTR;
            END;
        $UMOVE(.SIZE, .SOURCE, .CRECPTR);
        RECORDP[G$RBNO]  _ .CBUFPTR[BUFNO];
        RECORDP[G$RBADR] _ .CBUFPTR;
        RECORDP[G$RBDISP] _ .CBUFPTR[BUFDISP];
        CBUFPTR[BUFDISP] _ .CBUFPTR[BUFDISP] + .SIZE;
        END;

    .RECORDP
    END;

%***
  MOVE ONE BUFFER TO ANOTHER
      INSURE THAT BOTH BUFFER INDEXES ARE VALID.
      INSURE THAT BOTH BUFFER INDEXES ARE VALID.
***%

  GLOBAL ROUTINE  $GMBUF(SIX, DIX, FSRCREC, LSRCREC) =
    BEGIN
    LOCAL BUFFER CBUFPTR;       % CURRENT-BUFFER POINTER        %
    LOCAL BUFFER DBUFPTR;       % DESTINATION-BUFFER POINTER    %
    LOCAL BUFFER LBUFPTR;       % LAST-BUFFER POINTER           %
    LOCAL G$ LRECPTR;       % POINTER TO THE WORD FOLLOWING THE LAST RECORD
                                  TO BE MOVED.
                                %
    LOCAL G$ DRECPTR;       % DESTINATION RECORD POINTER    %
    LOCAL G$ CRECPTR;       % CURRENT RECORD POINTER        %
    LOCAL CBUFEND, DBUFEND;
    LOCAL RECSIZE;

    MAP GRPTR$I FSRCREC:LSRCREC;

    IF .SIX LSS 2 OR .DIX LSS 0 OR .SIX GTR GV$EBUFX*2 OR .DIX GTR GV$EBUFX*2
      THEN
        $FATAL(#075);
    CBUFPTR _ @GBUFX$[.SIX];
    WHILE .CBUFPTR[BUFNO] LSS .FSRCREC[G$RBNO]
      DO
        BEGIN
        IF .CBUFPTR[BUFLINK] EQL 0
          THEN  %  FIRST SOURCE RECORD IS NOT IN THE BUFFER INDICATED  %
            $FATAL(#073);
        CBUFPTR _ .CBUFPTR[BUFLINK];
        END;
    WHILE .CBUFPTR[BUFNO] LSS .LSRCREC[G$RBNO]
      DO
        BEGIN
        IF .CBUFPTR[BUFLINK] EQL 0
          THEN  %  LAST SOURCE RECORD IS NOT IN THE BUFFER INDICATED  %
            $FATAL(#072);
        CBUFPTR _ .CBUFPTR[BUFLINK];
        END;
    % SET POINTERS FOR THE RECORD TO BE MOVED %
    CBUFPTR _ .FSRCREC[G$RBADR];
    CBUFEND _ .CBUFPTR + .CBUFPTR[BUFLEN];
    CRECPTR _ .CBUFPTR + .FSRCREC[G$RBDISP];
%***
     CALCULATE THE ADDRESS OF THE WORD FOLLOWING THE LAST RECORD TO BE
  MOVED.
***%
    LRECPTR _ .LSRCREC[G$RBADR] + .LSRCREC[G$RBDISP];   
    LRECPTR _ .LRECPTR + .LRECPTR[G$LENGTH];
    IF .DIX EQL 0
      THEN  %  MOVE TO THE GAMMA FILE  %
        BEGIN
        DO
          BEGIN
          IF .CRECPTR GEQ .CBUFEND OR .CRECPTR[G$LENGTH] EQL 0
            THEN
              BEGIN
              CBUFPTR _ .CBUFPTR[BUFLINK];
              CBUFEND _ .CBUFPTR + .CBUFPTR[BUFLEN];
              CRECPTR _ .CBUFPTR + 2
              END;
          $COUTG(.CRECPTR);
          RECSIZE _ .CRECPTR[G$LENGTH];
          CRECPTR _ .CRECPTR + .RECSIZE;
          END
        UNTIL .CRECPTR EQL .LRECPTR OR .CRECPTR  EQL 2
        END
      ELSE  %  MOVE TO ANOTHER HOLDING BUFFER  %
        BEGIN
        DBUFPTR _ @GBUFX$[.DIX + 1];
        DBUFEND _ .DBUFPTR + .DBUFPTR[BUFLEN];
        DRECPTR _ .DBUFPTR + .DBUFPTR[BUFDISP];
        DO
          BEGIN
          IF .CRECPTR GEQ .CBUFEND OR .CRECPTR[G$LENGTH] EQL 0
            THEN
              BEGIN
              CBUFPTR _ .CBUFPTR[BUFLINK];
              CBUFEND _ .CBUFPTR + .CBUFPTR[BUFLEN];
              CRECPTR _ .CBUFPTR + 2;
              END;
          RECSIZE _ .CRECPTR[G$LENGTH];
          $GWBUF(.CRECPTR,.DIX);
          CRECPTR _ .CRECPTR + .RECSIZE;
          END
        UNTIL .CRECPTR EQL .LRECPTR OR .CRECPTR EQL 2
        END
    END;

%***
  DELETE ALL BUFFERS
***%

  GLOBAL ROUTINE $GDBUF =
    BEGIN
    LOCAL CURIX, TEMP;

    IF GQUEH$ NEQ GQUET$
      THEN
        BEGIN
        CURIX _ .GQUEH$ - 1;
        WHILE .CURIX NEQ .GQUET$
          DO
            BEGIN
            CURIX _ .CURIX + 1;
            IF .CURIX GTR GV$EBUFX
              THEN
                CURIX _ 1;
            TEMP _ .GQUE$[.CURIX] * 2;
            GBUFX$[.TEMP]    _ 0;
            GBUFX$[.TEMP+1]  _ 0;
            END;
          END;
    INCR I FROM 1 TO GV$EBUFX
      DO
        IF @GBUFX$[.I * 2] NEQ 0
          THEN
            $GRBUF(.I * 2);
    END;
%****
  CLEAR A BUFFER 
****%

  GLOBAL ROUTINE $GCBUF(BUFIX) =
    BEGIN
    LOCAL BUFFER CBUFPTR;
    LOCAL BUFFER NBUFPTR;
    LOCAL        CRECPTR;

    IF .BUFIX LSS 2 OR .BUFIX GTR GV$EBUFX * 2
      THEN
        $FATAL(#071);
    CBUFPTR _ @GBUFX$[.BUFIX];
    WHILE .CBUFPTR NEQ 0
      DO
        BEGIN
        NBUFPTR _ .CBUFPTR[BUFLINK];
        CBUFPTR[BUFDISP] _ 2;
        CRECPTR _ .CBUFPTR + 2;   % SET THE LENGTH TO ZERO FOR THE FIRST 
                                    RECORD IN EACH BUFFER INCREMENT
                                  %
        .CRECPTR _ 0;
        CBUFPTR _ .NBUFPTR;
        END;
    GBUFX$[.BUFIX + 1] _ @GBUFX$[.BUFIX]
    END;

%*****
  FETCH THE NEXT RECORD FROM A BUFFER
*****%

  GLOBAL ROUTINE $GFBUF(RECP,DEST) =
    BEGIN
    LOCAL BUFFER CBUFPTR;
    LOCAL G$     CRECPTR;
    LOCAL RECSIZE;
    MAP   GRPTR$I RECP;

  % GET THE ADDRESS OF THE BUFFER CONTAINING THE RECORD %
    CBUFPTR _ .RECP[G$RBADR];
    CRECPTR _ .CBUFPTR + .RECP[G$RBDISP];
    RECSIZE _ .CRECPTR[G$LENGTH];
    $UMOVE(.RECSIZE,.CRECPTR,.DEST);
    CRECPTR _ .CRECPTR + .RECSIZE;
    IF .CRECPTR GTR .CBUFPTR + .CBUFPTR[BUFLEN] - 1 OR .CRECPTR[G$LENGTH] EQL 0
      THEN  % NEXT RECORD IS IN THE CONTINUATION BUFFER INCREMENT %
        BEGIN
        CBUFPTR _ .CBUFPTR[BUFLINK];
        IF .CBUFPTR EQL 0
          THEN  % NO MORE RECORDS %
            RECP _ 0
          ELSE  % FIRST RECORD OF THE NEXT BUFFER INCREMENT %
            BEGIN
            RECP[G$RBNO] _ .CBUFPTR[BUFNO];
            RECP[G$RBADR] _ .CBUFPTR;
            RECP[G$RBDISP] _ 2;
            END
        END
      ELSE  % NEXT RECORD IS IN THIS BUFFER INCREMENT %
        IF .CRECPTR GTR .CBUFPTR + .CBUFPTR[BUFDISP] -1
          THEN
            RECP _ 0
          ELSE
            RECP[G$RBDISP] _ .CRECPTR - .CBUFPTR;

    .RECP
    END;


%****
  GET THE RECORD POINTER FOR THE FIRST RECORD IN THE INDICATED BUFFER.
****%
  GLOBAL ROUTINE $GFREC(IX)=
    BEGIN

    LOCAL GRPTR$I RECP;
    LOCAL BUFFER BUFPTR;

    BUFPTR _ .GBUFX$[.IX];
    IF .BUFPTR[BUFDISP] EQL 2
      THEN
        RECP _ 0
      ELSE
        BEGIN
        RECP[G$RBNO]   _ 1;
        RECP[G$RBADR]  _ .BUFPTR;
        RECP[G$RBDISP] _ 2;
        END;

    .RECP

    END;


%****
  GET THE RECORD POINTER FOR THE LAST RECORD IN THE INDICATED BUFFER
****%
  GLOBAL ROUTINE $GLREC(IX)=
    BEGIN

    LOCAL GRPTR$I RECP;
    LOCAL BUFFER BUFPTR;
    LOCAL G$ CRECPTR;
    LOCAL DATAEND;

    BUFPTR _ .GBUFX$[.IX+1];
    DATAEND _ .BUFPTR + .BUFPTR[BUFDISP];
    CRECPTR _ .BUFPTR + 2;
    WHILE .CRECPTR + .CRECPTR[G$LENGTH] LSS .DATAEND
      DO
        CRECPTR _ .CRECPTR + .CRECPTR[G$LENGTH];
    RECP[G$RBNO]    _ .BUFPTR[BUFNO];
    RECP[G$RBADR]   _ .BUFPTR;
    RECP[G$RBDISP]  _ .BUFPTR[BUFDISP] - .CRECPTR[G$LENGTH];

    .RECP

    END;


  END
ELUDOM
  