TITLE	COBDDT VERSION 4		
SUBTTL	COBOL DEBUG PACKAGE	TAH & JRG (APPLIED LOGIC)/ALB/CAM

EDIT==007001            ;DEC-EDT=007,TYM-REL=000
VERSION==004001         ;DEC-VER=004,TYM-VER=001

;COPYRIGHT 1971,1972, DIGITAL EQUIPMENT CORP., MAYNARD, MASS.

	MLON

ENTRY	CBDDT.	;BEGINNING OF COBDDT -- USER PROGRAM DOES JSP 16,CBDDT.
ENTRY TRACE.	;PUT OUT A PARAGRAPH NAME FOR TRACE
ENTRY BTRAC.	;PUT OUT LAST-SEEN PARAGRAPH WHEN JOB DIES
ENTRY TRPOP.	;TAKE ENTRY OFF PUSH-DOWN LIST DURING 'EXIT.'
ENTRY TRPD.	;PUT ENTRY ON PUSH-DOWN LIST DURING 'PERF.'

EXTERNAL .JBREL,.JBSA

;AC DEFINITIONS

SW=0		;SWITCH REGISTER
LIT=1		;PDL FOR LITERAL POOL
COD=2		;PDL FOR CODE ROLL
DT=3		;PNTR TO DATTAB

W1=6		;HOLDS XWD IN CODE GENERATION
W2=7		;EXTRA WORD FOR CODE GENERATORS

NM==10		;NMTAB INDEX
CH==11		;I/O CHARACTER
TE=12		;TEMPORARIES
TD=13
TC=14
TB=15
TA=16
PP=17		;PUSH-DOWN POINTER

TK==1
TJ==2
TI==3
TH==4
TG==5
TF==10
;OPERATORS

DIS==0		;DISPLAY
ACC==1		;ACCEPT

;SWITCH DEFINITIONS FOR 'SW'

FASIGN==1B18	;"A" OPERAND IS SIGNED
FBSIGN==1B19	;"B" OPERAND IS SIGNED
FANUM==1B20	;"A" OPERAND IS NUMERIC
FBNUM==1B21	;"B" OPERAND IS NUMERIC

BPTFLG==1B1	;BREAK!CLEAR COMMAND SEEN
BLNFLG==1B2	;AT LEAST ONE BLANK!TAB SEEN IN SKPBLN
FQFLAG==1B3	;CURRENT UPWARD SEARCH IS FULLY QUALIFIED (NO SKIPS YET)
NUQFLG==1B4	;TWO NON-FULLY QUALIFIED MATCHES HAVE BEEN FOUND
CLRFLG==1B5	;CLEAR COMMAND SEEN
NUIFLG==1B6	;TWO PROPER INITIAL SEGMENTS OF SYMBOLS HAVE BEEN FOUND
ALTFLG==1B7	;LINE TERMINATED W/ALTMODE


;USEFUL TABLES AND DEFINITIONS FOR CODE GENERATORS


CODE9==1		;PICTURE CODE FOR "9"
CODEM==3		;FOR FLOATING "-"
CODES==10		;FOR INSERTED "-"
CODEP==11		;FOR "."

D6MODE==0		;SIXBIT
D7MODE==1		;ASCII
DSMODE==1		;HIGHEST DISPLAY MODE
D1MODE==3		;1-WORD DECIMAL
D2MODE==4		;2-WORD DECIMAL
FPMODE==5		;FLOATING POINT
EDMODE==7		;EDITED

CHAC:	POINT 4,CH,12	;AC-FIELD IN "CH"

BYTE.S:	OCT 6		;SIXBIT BYTE SIZE
	OCT 7		;ASCII BYTE SIZE
	OCT -6		;SIXBIT (NEGATIVE)
	OCT -7		;ASCII (NEGATIVE)

BYTE.W:	OCT 6		;SIXBIT BYTES PER WORD
	OCT 5		;ASCII BYTES PER WORD

;MULTIPLE-PRECISION ARITHMETIC OP-CODES

	OPDEF MUL.21 [32B8]
	OPDEF DIV.21 [36B8]

;OP CODES

DEFINE OPCODE (NAME,VAL,AC) <NAME==VAL'B26+AC'B30>

OPCODE (MOVE%,200,0)
OPCODE (MOVM%,214,0)
OPCODE (MOVEM%,202,0)
OPCODE (MOVMM%,216,0)
OPCODE (MAG%,22,0)
OPCODE (DSPLY%,2,0)
OPCODE (ACEPT%,2,1)
OPCODE (C%DD,4,0)
OPCODE (C%D6D7,4,1)
OPCODE (C%D7D6,4,2)
OPCODE (EDIT%S,5,0)
OPCODE (EDIT%U,5,1)
OPCODE (PD6%,15,0)
OPCODE (PD7%,16,0)
OPCODE (FLOT%2,14,0)

;OP-CODE & AC FIELD FOR CONVERSION UUO CALLS

GMOVET:	XWD C%DD,C%D6D7	;SIXBIT-SIXBIT,SIXBIT-ASCII
	XWD C%D7D6,C%DD	;ASCII-SIXBIT,ASCII-ASCII

;DATAB DEFINITIONS

DTLKP==1		;WORD # OF LINKAGE PTR
DTFLAG==4		;WORD # OF FLAGS
DTSON==2		;WORD # OF FATHER/BROTHER/SON LINKS
DTBP==^D9		;WORD # OF EDIT MASK
DTSUBW==6		;WORD # OF SUBSCRIPT INFO
DTOCCL==000004		;OCCURS AT THIS LEVEL
CL.NUM==2		;CLASS NUMERIC

;BYTE POINTERS

DTCLAS:	POINT 2,DTFLAG(DT),1	;CLASS FIELD
DTDPL:	POINT 6,DTFLAG(DT),35	;DECIMAL PLACES FIELD
DTESIZ:	POINT 18,5(DT),17	;EXTERNAL SIZE
DTISIZ:	POINT 18,5(DT),35	;INTERNAL SIZE
DTNOCC:	POINT 15,DTSUBW(DT),14	;NUMBER OF OCCURANCES
DTRESD:	POINT 6,3(DT),11	;RESIDUE FIELD
DTUSAG:	POINT 3,DTFLAG(DT),17	;USAGE FIELD

;BITS SET IN FIFTH WORD OF DATAB ENTRY

;LEFT HALF
	DTNUM==400000	;NUMERIC
	DTSYNL==100000	;SYNCHRONIZED LEFT
	DTSYNR==040000	;SYNCHRONIZED RIGHT
	DTSIGN==020000	;SIGNED
	DTBWZ==010000	;BLANK WHEN ZERO
	DTSUBS==004000	;MUST BE SUBSCRIPTED
	DTEDIT==002000	;EDITED
	DTLINK==001000	;FATHER (1) OR BROTHER (0) LINK
	DTDEF==000400	;DEFINED
	DTLKS==000100	;LINKAGE SECTION FLAG

;RIGHT HALF
	DTPLOC==1B30	;DECIMAL POINT IS TO RIGHT OF WORD
	DTSYLL==1B25	;SYNCS AT LOWER LEVELS


;CODE ROLL ALLOCATIONS

N.TMP==^D100		;MAX TEMP STORAGE
N.COD==^D20		;MAX CODE ROLL SIZE
N.LIT==^D20		;MAX LIT POOL SIZE

;BITS SET IN THIRD WORD OF PRTAB ENTRY

;RIGHT HALF
	PRLINK==1B25	;PARAGRAPH-NAME (1) OR SECTION-NAME (0)

;BYTE POINTERS

NMLINK:	POINT	15,(TD),17	;LINK UP TO NAMTAB
SECNAM:	POINT	15,1(TD),17	;LINK UP TO SECTION-NAME

;PARAMETERS FOR PRTAB

PRFLGS==2	;WORD # OF FLAGS

;TABLE TYPE PARAMETERS

DTTYPE==100000	;DATAB TYPE
PRTYPE==400000	;PRTAB TYPE
TYPMSK==700000	;MASK FOR TYPE FIELD


;SWITCH DEFINITIONS FOR 'SW'

;GENERAL "SW" TESTER

DEFINE SWTEST (A,B) <
	XLIST
	IFLE A-777777,<TR'B SW,A>
	IFG A-777777,<
	    IFN A&777777,<TD'B SW,[A]>
	    IFE A&777777,<TL'B SW,(A)>
	>
	LIST
>

DEFINE SWON (A) <SWTEST A,O>	;TURN ON FLAGS
DEFINE SWOFF (A) <SWTEST A,Z>	;TURN OFF FLAGS
DEFINE TSWC (A) <SWTEST A,C>	;COMPLEMENT FLAG
DEFINE TSWF (A) <SWTEST A,NE>	;TEST FLAG AND SKIP IF OFF
DEFINE TSWT (A) <SWTEST A,NN>	;TEST FLAG AND SKIP IF ON
DEFINE TSWFZ (A) <SWTEST A,ZE>	;CLEAR FLAG, SKIP IF IT WAS OFF
DEFINE TSWTZ (A) <SWTEST A,ZN>	;CLEAR FLAG, SKIP IF IT WAS ON
DEFINE TSWFS (A) <SWTEST A,OE>	;SET FLAG, SKIP IF IT WAS OFF
DEFINE TSWTS (A) <SWTEST A,ON>	;SET FLAG, SKIP IF IT WAS ON
DEFINE TSWFC (A) <SWTEST A,CE>	;COMP. FLAG, SKIP IF IT WAS OFF
DEFINE TSWTC (A) <SWTEST A,CN>	;COMP. FLAG, SKIP IF IT WAS ON
DEFINE SWONS (A) <SWTEST A,OA>	;SET FLAG AND ALWAYS SKIP
DEFINE SWOFFS (A) <SWTEST A,ZA>	;CLEAR FLAG AND ALWAYS SKIP

;ACCEPT GENERATOR

ACCGEN:	MOVEI	W1,BASEB	;SET UP 'B' OPERAND
	PUSHJ	PP,SETOPN
	MOVE	TE,[XWD BASEB,BASEA]
	BLT	TE,BASAX	;MAKE 'A' = 'B'
	MOVE	TE,DTFLAG(DT)	;GET FLAGS
	MOVEI	TD,EDMODE
	TLNE	TE,DTEDIT	;EDITED?
	HRRM	TD,MODEB	;YES: SET MODE

	HRLZ	W1,SIZEB	;SET UP SIZE IN PARAM
	TLO	W1,(<1B7>)	;SKIP TO CRLF
	LDB	TE,DTCLAS	;CHECK ON CLASS
	CAIN	TE,CL.NUM	;NUMERIC?
	JRST	ACEP15		;YES:

;FIELD IS ALPHANUMERIC

	HRRZ	TE,MODEB
	CAIN	TE,D7MODE	;ASCII?
	CAIN	TE,EDMODE	;YES: EDITED ALSO?
	JRST	ACEP10		;NO: MUST USE TEMP
	JRST	ACEP20		;OK TO USE DIRECTLY

;FIELD IS EITHER ASCII-EDITED OR NON-ASCII ALPHANUMERIC

ACEP10:	MOVE	TE,SIZEA	;GET SIZE FOR TEMP CALC
	ADDI	TE,4
	IDIVI	TE,5		;NUMBER OF WORDS
	PUSHJ	PP,GETEMP	;ALLOCATE AND RETURN ADDR
	MOVEM	TE,INCRA
	MOVE	TE,[XWD ^D36,TEMROL]
	MOVEM	TE,BASEA
	MOVEI	TE,D7MODE	;'A' IS ASCII
	MOVEM	TE,MODEA
	PUSHJ	PP,ACEP20
	SWOFF	FASIGN!FANUM
	JRST	MXX.		;STASH AWAY

;FIELD IS NUMERIC OR NUMERIC EDITED

ACEP15:	PUSHJ	PP,ACEP25
	SETZM	EAC		;AC := 0
	SWON	FASIGN!FANUM
	MOVEI	TE,D2MODE	;USE 2-WORD COMP
	MOVEM	TE,MODEA
	JRST	MACX.		;STASH AWAY

;CREATE LITERAL AND CALL FOR ALPHANUMERIC

ACEP20:	LSH	W1,6
	HLR	W1,RESA		;BYTE RESIDUE
	ROT	W1,-6
	HRR	W1,BASEA	;ADDRESS
	ADD	W1,INCRA	;INCREMENT

ACEP21:	PUSH	LIT,W1		;STORE LITERAL
	MOVSI	CH,ACEPT%	;ACCEPT UUO
	HRR	CH,LIT		;LITERAL ADDR
	PUSH	COD,CH		;STASH CODE
	POPJ	PP,

;CREATE LITERAL AND CALL FOR NUMERIC

ACEP25:	TLO	W1,(<1B6>)	;NUMERIC
	MOVE	TA,DPLA
	JUMPGE	TA,ACEP26	;OK IF POSITIVE
	MOVNS	TA
	TRO	TA,40		;SET SIGN
ACEP26:	HRR	W1,TA		;DECIMAL PLACES
	JRST	ACEP21

;DISPLAY GENERATOR

DISPGN:	LDB	TC,DTUSAG	;GET USAGE
	JRST	@DISPDO(TC)

;DISPLAY DISPATCH TABLE

DISPDO:	EXP	DISERR		;0 - NO SUCH
	EXP	STNDRD		;1 - DISPLAY 6
	EXP	DISPD7		;2 - DISPLAY 7
	EXP	DISERR		;3 - NO SUCH
	EXP	STNDRD		;4 - 1 WORD COMP
	EXP	STNDRD		;5 - 2 WORD COMP
	EXP	DISPFP		;6 - COMP-1
	EXP	STNDRD		;7 - INDEX

;CALL MOVE GENERATOR FOR A LITTLE HELP

STNDRD:	PUSHJ	PP,MXTMP.

STND2:	TLZ	W1,(<1B7>)	;CRLF AT END OF LINE
	PUSH	LIT,W1
	MOVSI	CH,DSPLY%
	HRR	CH,LIT
	PUSH	COD,CH
	POPJ	PP,

;DISPLAY ASCII

DISPD7:	MOVEI	W1,BASEA	;SET UP 'A' OPERAND
	PUSHJ	PP,SETOPN
	TSWF	FANUM		;NUMERIC?
	JRST	STNDRD		;YES: USE STANDARD

	MOVE	TE,DTFLAG(DT)
	HRRZ	W1,SIZEA	;GET CORRECT SIZE
	TLNE	TE,DTEDIT	;IF EDITED
	LDB	W1,DTESIZ	;USE EXTERNAL SIZE
	ROT	W1,-^D12
	HLR	W1,RESA
	ROT	W1,-6
	HRR	W1,BASEA
	ADD	W1,INCRA
	JRST	STND2

;DISPLAY A COMP-1 FIELD

DISPFP:	MOVEI	W1,BASEA	;SET UP 'A' OPERAND
	PUSHJ	PP,SETOPN
	MOVEI	TE,4
	MOVEM	TE,EAC		;USE AC(5)
	MOVSI	CH,MOVE%
	TSWT	FASIGN		;SIGNED?
	MOVSI	CH,MOVM%	;NO: USE MAGNITUDE ONLY
	PUSHJ	PP,GENOPA
	PUSH	COD,[PUSHJ PP,DSP.FP]
	POPJ	PP,

;SET UP OPERAND PARAMETERS
;ENTER WITH EITHER BASEA OR BASEB IN W1 & PNTR TO 'DATAB'
;ENTRY IN DT. SUBSCRIPTING IS DONE IF NECESSARY AND 'INCRX'
;AND 'RESX' ARE UPDATED.

SETOPN:	HRRZ	TA,1(DT)	;GET ADDR OF ELEMENT
	HRRZM	TA,BASEX(W1)
	SETZM	INCRX(W1)	;CLR INCREMENT

	LDB	TE,DTUSAG	;GET USAGE
	SUBI	TE,1
	CAIN	TE,6		;INDEX
	MOVEI	TE,D1MODE	;YES: USE 1-WORD COMP
	MOVEM	TE,MODEX(W1)

	LDB	TE,DTRESD	;GET BYTE RESIDUE
	HRLM	TE,RESX(W1)	;AND STASH
	LDB	TE,DTDPL	;GET DECIMAL PLACES
	TRZE	TE,DTPLOC	;NEGATIVE?
	MOVNS	TE		;YES: NEGATE
	MOVEM	TE,DPLX(W1)	;ANS STASH IT
	LDB	TE,DTISIZ	;USE INTERNAL SIZE
	MOVEM	TE,SIZEX(W1)

	MOVE	TD,DTFLAG(DT)	;FLAGS
	TLNN	TD,DTDEF	;MAKE SURE DEFINED
	JRST	UNDEF

	TRNE	TD,DTLKS	;LINKAGE SECTION?
	JRST	SETOP1		;YES
	TLNN	TD,DTSUBS	;NEED SUBSCRIPTS?
	JRST	[SKIPE NSUBS
		 JRST NOSUB
		 JRST .+2]
SETOP1:	PUSHJ	PP,SUBSCR	;YES: DO CHECK

	MOVE	TD,DTFLAG(DT)	;GET FLAGS BACK
	CAIN	W1,BASEA	;DOING 'A'?
	JRST	SETOP2		;YES:

;'B' OPERAND

	TLNE	TD,DTSIGN	;SIGNED?
	SWONS	FBSIGN
	SWOFF	FBSIGN
	TLNN	TD,DTEDIT	;EDITED
	TLNN	TD,DTNUM	;NO: NUMERIC
	SWOFFS	FBNUM
	SWON	FBNUM
	POPJ	PP,		;RETURN

;'A' OPERAND

SETOP2:	TLNE	TD,DTSIGN	;SIGNED?
	SWONS	FASIGN
	SWOFF	FASIGN
	TLNN	TD,DTEDIT	;EDITED
	TLNN	TD,DTNUM	;NO: NUMERIC
	SWOFFS	FANUM
	SWON	FANUM
	POPJ	PP,		;RETURN

;DO SUBSCRIPTING

SUBSCR:	SKIPE	NSUBS		;DO WE HAVE ANY?
	JRST	SUBSC0		;YES
	TRNN	TD,DTLKS	;IN LINKAGE SECTION?
	JRST	NEDSUB		;NO: TOUGH
SUBSC0:	MOVEM	DT,SAVDT	;SAVE DATAB PNTR
	SETZB	CH,REMAN

	HLRZ	W2,RESX(W1)	;CALC B.P. TO 1ST ELEMENT
	ROT	W2,-6
	HRRZ	TD,MODEX(W1)
	CAIE	TD,D7MODE
	TLOA	W2,600
	TLO	W2,700
	HRR	W2,INCRX(W1)

	MOVE	TD,DTFLAG(DT)	;LINKAGE SECTION?
	TRNN	TD,DTLKS
	JRST	SUBSC2		;NO
	HLRZ	TD,DTLKP(DT)	;YES, GET LINKAGE PTR
	ADD	W2,(TD)
	SKIPE	NSUBS		;0 SUBSCRIPTS?
	JRST	SUBSC2		;NO
	MOVE	TE,W2		;YES, GET TO THE END
	JRST	SUBSC8
SUBSC2:	MOVE	TE,DTSUBW(DT)	;OCCURS AT THIS LEVEL?
	TLNE	TE,DTOCCL
	JRST	SUBSC1
	LDB	DT,[POINT 15,DTSUBW+1(DT),17]
	ADD	DT,@%DT
SUBSC1:	LDB	TA,DTNOCC	;NUMBER OF OCCURRANCES
	MOVE	TC,SUB0.(CH)
	CAMLE	TC,TA		;IN BOUNDS
	JRST	LRGSUB
	SOS	TC
	LDB	TE,DTUSAG	;GET USAGE
	XCT	SUBSIZ(TE)	;GET # OF BYTES
	IMUL	TA,TC
	ADDM	TA,REMAN	;ACCUMULATE SUM

SUBSC3:	AOS	TE,CH		;NEXT SUBSCRIPT
	LDB	TA,[POINT 15,DTSUBW+1(DT),17]
	CAML	TE,NSUBS
	JRST	SUBSC4		;NO MORE TYPED
	JUMPE	TA,TOOFEW	;TOO MANY
	HRRZ	DT,TA		;PNTR TO NEXT LEVEL
	ADD	DT,@%DT
	JRST	SUBSC1		;LOOP

SUBSC4:	JUMPE	TA,SUBSC6	;ALL EVEN?
	JRST	NOTNUF		;NOT ENUF
SUBSC6:	MOVE	TD,REMAN	;GET COMPUTED OFFSET
	LDB	TE,[POINT 6,W2,11]
	MOVEI	TB,^D36
	IDIV	TB,TE		;BYTES/WORD
	IDIV	TD,TB		;NUMBER OF WORDS
	MOVE	TE,W2
	ADD	TE,TD		;CALC NEW OFS
SUBSC7:	SOJL	TC,SUBSC8	;ANY BYTES LEFT OVER?
	IBP	TE		;YES: BUMP BYTE PNTR
	JRST	SUBSC7		;LOOP

SUBSC8:	HRRZM	TE,INCRX(W1)	;STORE OFFSET
	LDB	TE,[POINT 6,TE,5]
	HRLM	TE,RESX(W1)	;AND RESIDUE
	MOVE	DT,SAVDT	;GET BACK DT PTR
	POPJ	PP,		;RETURN
;A TABLE WHICH DETERMINES SIZE OF ITEM (ALWAYS IN BYTES)

SUBSIZ:	JRST	BADBAD		;0
	PUSHJ	PP,SUBSZX	;1 SIXBIT
	PUSHJ	PP,SUBSZX	;2 ASCII
	JRST	BADBAD		;3
	MOVEI	TA,6		;4 1-WORD COMP
	MOVEI	TA,^D12		;5 2-WORD COMP
	MOVEI	TA,6		;6 COMP-1
	MOVEI	TA,6		;7 INDEX

SUBSZX:	LDB	TA,DTESIZ	;EXTERNAL SIZE
	MOVE	TD,DTFLAG(DT)
	TDNN	TD,[XWD DTSYNL!DTSYNR,DTSYLL]
	POPJ	PP,		;NO SYNCS - OK
	EXCH	TE,TA
	IDIV	TE,BYTE.W-1(TA)
	SKIPE	TD
	ADDI	TE,1
	IMUL	TE,BYTE.W-1(TA)
	EXCH	TE,TA
	POPJ	PP,

;MOVE AN ITEM TO TEMPORARY FOR USE BY "DISPLAY"
;ENTER WITH 'DT' POINTING TO AN OPERAND.
;EXIT WITH DISPLAY LITERAL IN 'W1'

MXTMP.:	SETZM	EAC		;START AN AC(0)
	MOVEI	W1,BASEA	;SET UP 'A' OPERAND
	PUSHJ	PP,SETOPN
	MOVE	TE,[XWD BASEA,BASEB]
	BLT	TE,BASBX	;MAKE 'B' = 'A'
	MOVEI	TE,D7MODE
	MOVEM	TE,MODEB	;ASCII

	TSWF	FANUM		;IS 'A' NUMERIC
	JRST	MXTMP4		;YES: TREAT SPECIAL

	MOVE	TE,DTFLAG(DT)
	TLNN	TE,DTEDIT	;EDITED FIELD?
	JRST	MXTMP1		;NO:
	LDB	TE,DTESIZ	;YES: USE EXTERNAL SIZE
	MOVEM	TE,SIZEA
	MOVEM	TE,SIZEB

;INPUT FIELD IS NON-ASCII, NON-NUMERIC

MXTMP1:	HRLZ	W2,SIZEA	;CONSTRUCT LIT IN W2
	MOVE	TE,SIZEB
	ADDI	TE,4		;GET SIZE OF 'B' IN WORDS
	IDIVI	TE,5
	PUSHJ	PP,GETEMP	;GET SOME TEMP LOCS
	MOVEM	TE,INCRB
	MOVE	TE,[XWD ^D36,TEMROL]
	MOVEM	TE,BASEB
	HRR	W2,BASEB
	ADD	W2,INCRB

	PUSHJ	PP,MXX.		;GENERATE MOVE

	TLO	W2,(<^D36B5>)	;BYTE RESIDUE
	MOVE	W1,W2		;RETURN LITERAL
	POPJ	PP,

;ITEM IS NUMERIC, AND THEREFORE MUST BE EDITED.

MXTMP4:	SWON	FBSIGN!FBNUM	;'B' IS ALWAYS SIGNED ETC.
	SKIPL	DPLA		;NEGATIVE DECIMAL PLACES?
	JRST	MXTMP5		;NO:
	MOVM	TE,DPLA		;YES: 'B' IS SIZE - DEC. PL.
	ADD	TE,SIZEA
	MOVEM	TE,SIZEB
	SETZM	DPLB
	JRST	MXTMP9

MXTMP5:	MOVE	TE,SIZEA	;NEGATIVE INTEGRAL PLACES?
	SUB	TE,DPLA
	JUMPGE	TE,MXTMP6	;NO: OK
	MOVE	TE,DPLA		;YES: SIZE IS # DECIMAL PLACES
	MOVEM	TE,SIZEB
	JRST	MXTMP9

MXTMP6:	HRRZ	TE,MODEA	;IS ITEM DISPLAY USAGE?
	CAIG	TE,DSMODE
	JRST	MXTM10		;YES: DON'T MOVE TO TEMP

MXTMP9:	MOVEI	TE,D6MODE	;NO: MOVE TO TEMP
	MOVEM	TE,MODEB
	MOVE	TE,SIZEB	;CALC # OF WORDS
	ADDI	TE,5
	IDIVI	TE,6
	PUSHJ	PP,GETEMP	;GET SOME SPACE
	MOVEM	TE,INCRB
	MOVE	TE,[XWD ^D36,TEMROL]
	MOVEM	TE,BASEB

	MOVE	TE,[XWD BASEB,SAVEA]
	BLT	TE,SAVAX	;SAVE 'B' PARAMETERS
	PUSHJ	PP,MXX.		;MOVE TO TEMP
	MOVE	TE,[XWD SAVEA,BASEA]
	BLT	TE,BASAX
	MOVE	TE,[XWD SAVEA,BASEB]
	BLT	TE,BASBX

;IT IS (OR HAS BEEN CONVERTED TO) DISPLAY USAGE.

MXTM10:	HRRZI	W1,1(LIT)	;ADDR OF LITERAL
	HRLI	W1,(<^D36B5>)
	SETZM	BASEB		;BYTE COUNTER
	MOVEI	TA,0
	MOVE	TB,[POINT 4,TA]	;INITIALIZE
	MOVE	TC,SIZEB
	SUB	TC,DPLB
	JUMPE	TC,MXT11B	;ALL TO RIGHT IF DECIMAL

	MOVEI	CH,CODES	;PRETEND THERE IS ONE INTEGER
	CAIE	TC,1		;IS THAT TRUE?
	AOSA	BASEB		;NO: LEAVE ROOM FOR SIGN
	PUSHJ	PP,MXTM20	;YES: JAM INSERT SIGN
	MOVEI	CH,CODEM	;SET UP FOR "FLOAT SIGN"

MXTM11:	SOJLE	TC,MXT11A	;ONLY ONE LEFT?
	PUSHJ	PP,MXTM20	;NO:
	JRST	MXTM11

MXT11A:	MOVEI	CH,CODE9	;USE "9" FOR LAST INTEGRAL PLACE.
	PUSHJ	PP,MXTM20
	JRST	MXTM12

MXT11B:	MOVEI	CH,CODES	;USE INSERT SIGN
	PUSHJ	PP,MXTM20

MXTM12:	SKIPN	TC,DPLB
	JRST	MXTM13
	MOVEI	CH,CODEP	;INSERT POINT
	PUSHJ	PP,MXTM20
	MOVEI	CH,CODE9	;FINISH OFF WITH "9"'S
	PUSHJ	PP,MXTM20
	SOJG	TC,.-1


;MASK HAS BEEN CREATED FOR NUMERIC ITEM--FINISH UP.

MXTM13:	MOVEI	CH,17
	IDPB	CH,TB
	PUSH	LIT,TA

	HRLZ	W2,BASEB	;FIELD SIZE TO LITERAL
	TLO	W2,(<^D36B5+1B6>)

	MOVE	TE,BASEB
	ADDI	TE,4
	IDIVI	TE,5		;SIZE IN WORDS
	PUSHJ	PP,GETEMP	;GET SOME PLACE TO PUT IT
	MOVEM	TE,INCRB
	MOVE	TE,[XWD ^D36,TEMROL]
	MOVEM	TE,BASEB
	HRR	W2,TE		;ADDR TO LIT ALSO
	ADD	W2,INCRB

	MOVEI	TE,D7MODE	;ASCII
	MOVEM	TE,MODEB
	MOVEI	TE,MDES.	;ASSUME SIGNED
	TSWT	FASIGN		;IS IT?
	MOVEI	TE,MDEU.	;NO: USE UNSIGNED ROUTINE
	PUSHJ	PP,(TE)
	MOVE	W1,W2		;RETURN LIT
	POPJ	PP,

;ROUTINE TO PUT NEXT EDIT CHAR IN WORD AND STASH LIT IF
;NECESSARY. CLEAR 'TA' AND PUT B.P. IN 'TB'.

MXTM20:	IDPB	CH,TB		;STORE AWAY
	AOS	BASEB		;KEEP COUNT
	TLNE	TB,770000	;FULL WORD?
	POPJ	PP,		;NO: JUST EXIT
	PUSH	LIT,TA		;YES: STASH LIT
	MOVEI	TA,0
	MOVE	TB,[POINT 4,TA]
	POPJ	PP,		;RE-INIT AND EXIT

;DISPATCH ROUTINES FOR MOVE GENERATORS

;MOVE THE AC'S TO SOMETHING

MACX.:	HRRZ	TE,MODEA	;CHECK MODES
	CAIE	TE,D2MODE	;ONLY LEGAL
	JRST	BADCOD
	HRRZ	TE,MODEB
	JRST	@MACX.T(TE)	;DO ROUTINE

MACX.T:	EXP	MACD.		; SIXBIT
	EXP	MACD.		; ASCII
	EXP	BADCOD		; ------
	EXP	MAC1C.		; 1-WORD COMP
	EXP	MAC2C.		; 2-WORD COMP
	EXP	MACFP.		; COMP-1
	EXP	BADCOD		; ------
	EXP	MACE.		; EDITED

;MOVE SOMETHING TO SOMETHING

MXX.:	HRRZ	TA,MODEA
	HRRZ	TB,MODEB	;CHECK LEGAL MODES
	CAIG	TA,D2MODE
	CAILE	TB,EDMODE
	JRST	BADCOD
	LSH	TA,2		;MOVT.(4*MODEA+MOBEB/2)
	ROT	TB,-1
	ADDI	TA,(TB)
	TLNE	TB,1B18		;LEFT HALT DISPATCH
	SKIPA	TC,MOVT.(TA)	;NO:
	MOVS	TC,MOVT.(TA)	;YES:
	JRST	(TC)		;GO DO ROUTINE

;TABLE OF ENTRANCE POINTS TO "MOVE" ROUTINES.

MOVT.:	XWD	MDD.,MDD.	;S-S,S-A
	XWD	BADCOD,BADCOD	;-,S-1C
	XWD	BADCOD,BADCOD	;S-2C,S-F
	XWD	BADCOD,MDED.	;-,S-EDIT

	XWD	MDD.,MDD.	;A-S,A-A
	XWD	BADCOD,BADCOD	;-,A-1C
	XWD	BADCOD,BADCOD	;A-2C,A-F
	XWD	BADCOD,MDED.	;-,A-EDIT

	XWD	BADCOD,BADCOD
	XWD	BADCOD,BADCOD
	XWD	BADCOD,BADCOD
	XWD	BADCOD,BADCOD

	XWD	M1CD.,M1CD.	;1C-S,1C-A
	XWD	BADCOD,BADCOD	;-,1C-1C
	XWD	BADCOD,BADCOD	;1C-2C,1C-FP
	XWD	BADCOD,BADCOD	;-,1C-EDIT

	XWD	M2CD.,M2CD.	;2C-S,2C-A
	XWD	BADCOD,BADCOD	;-,2C-1C
	XWD	BADCOD,BADCOD	;2C-2C,2C-FP
	XWD	BADCOD,BADCOD	;-,2C-EDIT

BADCOD:	TTCALL	3,[ASCIZ "? ILLEGAL MOVE ARGS"]
	JRST	MLUP.

;GENERATE CODE TO MOVE FROM ASCII/SIXBIT TO SIXBIT/ASCII
;FOR UNEDITED FIELDS OF SAME SIZE

MDD.:	MOVE	TE,SIZEB	;CHECK ARGS
	CAMN	TE,SIZEA	;FOR SAME SIZE AND
	TSWF	FBNUM		;NON-NUMERIC RECIEVER
	JRST	MDD.E

	PUSHJ	PP,BYTE.A	;GET 'A' PARAMETER
	PUSH	LIT,TA
	PUSH	COD,LIT		;ADDR OF LITERALS
	PUSHJ	PP,BYTE.C	;GET 'B' PARAMETER
	PUSH	LIT,TA
	MOVE	TC,MODEA	;GET CORRECT ROUTINE
	HRRZ	TE,MODEB
	CAIN	TE,D6MODE	;SIXBIT?
	SKIPA	CH,GMOVET(TC)	;YES:
	MOVS	CH,GMOVET(TC)	;NO:
	HLLM	CH,0(COD)	;STASH OP-CODE
	POPJ	PP,

MDD.E:	TTCALL	3,[ASCIZ "? ERROR AT MDD."]
	JRST	MLUP.

;MOVE A 1-WORD COMP TO A DISPLAY FIELD.

M1CD.:	MOVSI	CH,MOVE%	;MOVE TO AN AC
	TSWT	FASIGN!FBSIGN	;SIGNED?
	MOVSI	CH,MOVM%	;NOPE!
	PUSHJ	PP,GENOPA
	JRST	MACD.		;CONVERT AND RETURN

;MOVE A 2-WORD COMP TO A DISPLAY FILED.

M2CD.:	TSWT	FASIGN!FBSIGN	;SIGNED?
	JRST	M2CD.1		;NO: USE SPECIAL ROUTINE
	MOVSI	CH,MOVE%	;MOVE TO AC'S
	PUSHJ	PP,GENOPB
	AOS	INCRA
	MOVSI	CH,MOVE%
	PUSHJ	PP,GENOPA
	JRST	MACD.		;CONVERT AND RETURN

M2CD.1:	MOVSI	CH,MAG%	;DOUBLE-PRECISION MOVE
	PUSHJ	PP,GENOPB	;OF MAGNITUDE
	JRST	MACD.

;GENERATE CODE TO MOVE ACCUMULATORS TO A DISPLAY FIELD.

MACD.:	MOVE	TE,DTFLAG(DT)	;FLAGS
	TLNE	TE,DTBWZ	;BLANK WHEN ZERO?
	JRST	MACE.		;YES: USE EDIT

MACD.1:	HLRZ	TA,RESB		;GENERATE 'B' PARAMETER
	LSH	TA,^D12
	ADD	TA,SIZEB
	TSWF	FBSIGN		;SIGNED
	TRO	TA,(<1B6>)	;YES:
	HRLZS	TA
	HRR	TA,BASEB	;EFFECTIVE ADDR
	ADD	TA,INCRB
	PUSH	LIT,TA
	MOVEI	CH,(LIT)	;ADDR OF LIT
	HRLI	CH,PD6%		;ASSUME SIXBIT
	HRRZ	TE,MODEB
	CAIE	TE,D6MODE	;IS IT?
	HRLI	CH,PD7%		;NOPE - USE ASCII
	MOVE	TE,SIZEB	;1 OR 2 WORD COMP
	MOVE	TD,EAC
	CAIG	TE,^D10		;?
	ADDI	TD,1
	DPB	TD,CHAC		;PC FIELD
	PUSH	COD,CH		;STASH CODE
	POPJ	PP,

;GENERATE CODE TO MOVE AC'S TO A 1-WORD COMP OR INDEX.

MAC1C.:	MOVSI	CH,MOVEM%
	TSWT	FBSIGN		;SIGNED?
	MOVSI	CH,MOVMM%	;NO:
	JRST	GENOPD

;GENERATE CODE TO MOVE AC'S TO A 2-WORD COMP.

MAC2C.:	TSWT	FBSIGN		;SIGNED?
	JRST	MAC2C3		;NO: USE MAGNITUDE
MAC2C2:	MOVSI	CH,MOVEM%
	PUSHJ	PP,GENOPE
	MOVSI	CH,MOVEM%
	AOS	INCRB
	JRST	GENOPD

;HERE FOR POSSIBLE UNSIGNED MOVE

MAC2C3:	TSWT	FASIGN		;'A' SIGNED?
	JRST	MAC2C2		;NO - OK TO USE MOVE(S)
	MOVSI	CH,MAG%
	HRR	CH,EAC
	MOVE	TE,EAC
	DPB	TE,CHAC
	PUSH	COD,CH		;STASH
	SETZM	EAC
	JRST	MAC2C2

;GENERATE CODE TO MOVE AC'S TO COMP-1

MACFP.:	MOVSI	CH,FLOT%2	;CONVERT TO COMP-1
	HRR	CH,EAC
	MOVE	TE,EAC
	DPB	TE,CHAC
	PUSH	COD,CH		;STASH CODE
	SOS	TE		;RESULT IN C(EAC)
	MOVEM	TE,EAC
	MOVEI	TE,FPMODE
	MOVEM	TE,MODEA
	JRST	MAC1C.

;GENERATE CODE TO MOVE AC'S TO EDITED FIELD.

MACE.:	MOVE	TE,[XWD BASEB,SAVMB]
	BLT	TE,SVMBX	;SAVE 'B' PARAMETERS
	MOVEI	TE,D6MODE	;SET MODE TO SIXBIT
	MOVEM	TE,MODEB
	MOVE	TE,SIZEB	;GET A TEMP LOC
	ADDI	TE,5
	IDIVI	TE,6
	PUSHJ	PP,GETEMP
	MOVEM	TE,INCRB
	MOVE	TE,[XWD ^D36,TEMROL]
	MOVEM	TE,BASEB
	MOVE	TE,[XWD BASEB,SAVMA]
	BLT	TE,SVMAX	;SAVE AS 'A' PARAMETER
	PUSHJ	PP,MACD.1	;MOVE TO DISPLAY FIELD
	MOVE	TE,[XWD SAVMA,BASEA]
	BLT	TE,BASBX	;GET BACK 'A' AND 'B'
	JRST	MDED.		;DO EDIT AND RETURN

;GENERATE CODE TO MOVE A DISPLAY FIELD TO AN EDITED FIELD.

MDED.:	PUSHJ	PP,BMASK	;GET EDIT MASK
	TSWF	FASIGN		;ANY SIGNS
	TSWT	FBSIGN
	JRST	MDEU.		;NO: USE UNSIGNED ROUTINE

;BOTH FILEDS ARE SIGNED

MDES.:	MOVE	TE,[XWD BASEA,SAVMA]
	BLT	TE,SVMAX	;SAVE 'A'
	MOVE	TE,SIZEA
	SUBI	TE,1
	PUSHJ	PP,M.IA		;FIND SIGN
	HRRZ	TE,MODEA
	HRLZ	TE,BYTE.S(TE)
	MOVNS	TE
	ADDM	TE,RESA		;MESS PARAM
	PUSHJ	PP,MBYTEA	;GET FIRST LITERAL
	PUSH	COD,LIT

	MOVE	TE,[XWD SAVMA,BASEA]
	BLT	TE,BASAX	;GET 'A' BACK
	MOVSI	CH,EDIT%S
	JRST	MDEU.2		;STASH CODE AND EXIT

;GENERATE CODE FOR AN UNSIGNED EDITED FIELD.

MDEU.:	MOVSI	CH,EDIT%U
	MOVEI	TE,1(LIT)	;ADDR OF LIT
	PUSH	COD,TE

MDEU.2:	HLLM	CH,0(COD)
	PUSHJ	PP,MBYTEA	;GET A BYTE POINTER
	HRRZ	TE,MODEB
	MOVEI	TA,600		;ASSUME SIXBIT
	CAIN	TE,D7MODE
	MOVEI	TA,700		;NO: ASCII
	MOVE	TE,DTFLAG(DT)	;GET FLAGS
	TLNE	TE,DTBWZ	;BLANK WHEN ZERO?
	IORI	TA,40		;YES: SET BIT 12
	ROT	TA,-^D12
	HLR	TA,RESB
	ROT	TA,-6		;FORM B.P.
	HRR	TA,BASEB
	ADD	TA,INCRB
	PUSH	LIT,TA		;SASH AWAY
	PUSH	COD,W1		;ALSO XWD LITERAL
	POPJ	PP,		;AND EXIT

;CREATE THE MASK FOR THE "B" FIELD.

BMASK:	HRRZI	W1,1(LIT)	;LOC OF LITERAL
	HRLI	W1,(<^D36B5>)
	MOVE	TC,DTFLAG(DT)	;GET FLAGS
	TLNN	TC,DTEDIT	;EDITED
	JRST	BMASK4		;NO: BWZ THEN

	HRRZ	TC,DT		;FORM BYTEPNTRS
	ADD	TC,[POINT 4,DTBP,11]
	LDB	TD,[POINT 12,DTBP(DT),11]
	DPB	TD,[POINT 12,W1,17]	;SIGN CHARS

BMASK1:	MOVEI	TA,0
	MOVE	TB,[POINT 4,TA]
BMASK2:	ILDB	TE,TC
	IDPB	TE,TB
	CAIN	TE,17		;END?
	JRST	BMASK3		;YES:
	TLNE	TB,770000	;WORD FULL?
	JRST	BMASK2		;NO: LUP UNTIL IT IS
	PUSH	LIT,TA		;YES: STASH
	JRST	BMASK1

BMASK3:	PUSH	LIT,TA		;STASH LAST OP
	POPJ	PP,		;AND EXIT

;ITEM IS NOT EDITED SO IT MUST BE "BLANK WHEN ZERO".

BMASK4:	MOVE	TB,SIZEB
BMASK5:	CAIGE	TB,^D9
	JRST	BMASK6
	PUSH	LIT,[0]
	SUBI	TB,^D9
	JUMPG	TB,BMASK5	;LUP UNTIL DONE

BMASK6:	MOVEI	TA,0
	MOVE	TC,[POINT 4,TA]
	JUMPE	TB,BMASK7	;NO RESIDUE
	IBP	TC
	SOJG	TB,.-1

BMASK7:	MOVEI	TE,17
	IDPB	TE,TC
	JRST	BMASK3

;RANDOM BYTE POINTER DIDLERS

;GET A BYTE POINTER TO "A"

BYTE.A:	MOVEI	TE,BASEA

BYTE.X:	HRRZ	TC,MODEX(TE)
	HLRZ	TA,RESX(TE)
	LSH	TA,6
	ADD	TA,BYTE.S(TC)
	ROT	TA,-^D12

BYTE.Y:	HRR	TA,BASEX(TE)
	ADD	TA,INCRX(TE)	;ADDR OR WORD
	POPJ	PP,

;SIMILAR TO BYTE.A, EXCEPT FOR "B"

BYTE.B:	MOVEI	TE,BASEB
	JRST	BYTE.X

;SIMILAR TO BYTE.B, EXCEPT SIZE PUT IN BITS 6-17

BYTE.C:	MOVEI	TE,BASEB
	HLRZ	TA,RESB
	LSH	TA,^D12
	ADD	TA,SIZEB
	HRLZS	TA
	JRST	BYTE.Y

;CREATE BYTE POINTER TO 'A' AND PUT IN LITROL

MBYTEA:	HLRZ	TA,RESA
	ROT	TA,-6
	HRRZ	TC,MODEA
	MOVE	TC,BYTE.S(TC)
	DPB	TC,[POINT 6,TA,11]
	HRR	TA,BASEA
	ADD	TA,INCRA
	PUSH	LIT,TA
	POPJ	PP,

;INCREMENT PARAMETERS OF "A" OPERAND BY THE NUMBER
;OF BYTES WHOSE VALUE IS IN "TE".

M.IA:	MOVE	TC,MODEA
	IDIV	TE,BYTE.W(TC)	;ADJUST INCREMENT
	ADDM	TE,INCRA
	HLRZ	TE,RESA
	IMUL	TD,BYTE.S(TC)
	SUB	TE,TD
	CAML	TE,BYTE.S(TC)
	JRST	M.IA1
	CAIN	TC,D7MODE
	SUBI	TE,1
M.IA1:	JUMPG	TE,M.IA2	;TO BIT 35 OR BEYOND
	AOS	INCRA		;YES:
	ADDI	TE,^D36
M.IA2:	HRLM	TE,RESA		;NEW RESIDUE
	POPJ	PP,

;SOME RANDOM GENERATORS

;GEN <OP AC+1,"A">

GENOPA:	MOVE	TE,EAC
	AOSA	TE

;GEN <OP AC,"A">

GENOPB:	MOVE	TE,EAC
	DPB	TE,CHAC

;GEN <OP "A">

GENOPC:	HRR	CH,BASEA
	ADD	CH,INCRA
	PUSH	COD,CH
	POPJ	PP,

;GEN <OP AC+1,"B">

GENOPD:	MOVE	TE,EAC
	AOSA	TE

;GEN <OP AC,"B">

GENOPE:	MOVE	TE,EAC
	DPB	TE,CHAC

;GEN <OP "B">

GENOPF:	HRR	CH,BASEB
	ADD	CH,INCRB
	PUSH	COD,CH
	POPJ	PP,

;ERROR ROUTINES

BADBAD:	TTCALL	3,[ASCIZ "? ILLEGAL SUBCRIPT USAGE"]
	JRST	MLUP.
DISERR:	TTCALL	3,[ASCIZ "? DISPLAY INTERNAL ERROR"]
	JRST	MLUP.
LRGSUB:	TTCALL	3,[ASCIZ "? SUBSCRIPT TOO LARGE"]
	JRST	MLUP.
NEDSUB:	TTCALL	3,[ASCIZ "? ITEM MUST BE SUBSCRIPTED"]
	JRST	MLUP.
NOSUB:	TTCALL	3,[ASCIZ "? NO SUBSCRIPTS ALLOWED"]
	JRST	MLUP.
NOTNUF:	TTCALL	3,[ASCIZ "? NOT ENOUGH SUBSCRIPTS"]
	JRST	MLUP.
TOOFEW:	TTCALL	3,[ASCIZ "? TOO MANY SUBSCRIPTS"]
	JRST	MLUP.
UNDEF:	TTCALL	3,[ASCIZ "? SYMBOL NOT DEFINED"]
	JRST	MLUP.
NONRES:	TTCALL	3,[ASCIZ "? NON-RESIDENT SECTION"]
	JRST	MLUP.
HIPART:	TTCALL	3,[ASCIZ '? NOT ALLOWED FOR HI-SEGMENT PROCEDURES']
	JRST	MLUP.

;ROUTINE TO GET SOME TEMP STORAGE

GETEMP:	ADD	TE,TEMPC	;GET NEW TOP
	CAIL	TE,N.TMP	;OVER?
	JRST	NOTEMP
	EXCH	TE,TEMPC	;RETURN BASE
	POPJ	PP,

NOTEMP:	TTCALL	3,[ASCIZ "? ITEM TOO LARGE FOR TEMP"]
	JRST	MLUP.
NOLAST:	TTCALL	3,[ASCIZ "? NO PREVIOUS DATA-NAME"]
	JRST	MLUP.

;WHERE COMMAND - PRINTS SUMMARY OF BREAK POINTS

WHERE:	TTCALL	3,CRLF
	SKIPN	TD,CUR.BP	;IN ONE?
	JRST	[TTCALL 3,[ASCIZ "PROGRAM NOT STARTED"]
		 JRST WHERE1]
	TTCALL	3,[ASCIZ "PROGRAM STOPPED AT "]
	PUSHJ	PP,PRTBP
WHERE1:	TTCALL	3,CRLF
	TTCALL	3,[ASCIZ "BREAK POINTS:"]
	TTCALL	3,CRLF

	MOVEI	TE,0		;INIT COUNTER OF FREE BPS
	MOVEI	TD,B1ADR	;INIT LOOP
WHERE2:	SKIPN	0(TD)		;IN USE?
	AOJA	TE,WHERE3	;NO: INCREMENT CNTR
	PUSHJ	PP,PRTBP	;YES: PRINT IT
	TTCALL	3,CRLF
WHERE3:	ADDI	TD,LBA
	CAIG	TD,BNADR	;DONE?
	JRST	WHERE2
	CAIL	TE,NBP		;WAS THERE ANY?
	TTCALL	3,[ASCIZ "**NONE**
"]
	TTCALL	3,CRLF
	PUSHJ	PP,PRNUM	;PRINT # OF FREE
	TTCALL	3,[ASCIZ " UNUSED BREAK POINTS"]
	JRST	MLUP.

CRLF:	BYTE (7)15,12

;PRINT BREAK POINT INFOR POINTED AT BY 'TD'

PRTBP:	TTCALL	3,[BYTE (7)74,74]
	HRRZ	TA,0(TD)
	LDB	DT,[POINT 15,0(TA),17]
	ADD	DT,@%NM
	PUSHJ	PP,PRNAM
	HRRZ	TA,1(TD)	;CHECK ON SECTION NAME
	LDB	DT,[POINT 15,0(TA),17]
	ADD	DT,@%NM
	MOVE	TA,1(DT)
	CAME	TA,[SIXBIT /:GENER/]
	PUSHJ	PP,[TTCALL 3,[ASCIZ " IN "]
		    JRST PRNAM]
	TTCALL	3,[BYTE (7)76,76]
	POPJ	PP,

;YE OLDE RECURSIVE NUMBER PRINTER C(TE)

PRNUM:	IDIVI	TE,^D10
	HRLM	TD,0(PP)
	JUMPE	TE,PRNUM1
	PUSHJ	PP,PRNUM
PRNUM1:	HLRZ	TC,0(PP)
	ADDI	TC,"0"
	TTCALL	1,TC
	POPJ	PP,

;BREAK POINT LOGIC

;HERE TO SET BREAK POINTS

SETBRK:	MOVEI	TE,B1ADR	;LOOK FOR FREE BREAK-POINT
STBRK0:	HRRZ	TD,0(TE)
	CAIE	TD,0(DT)	;CHECK IF WE HAVE ONE ALREADY
	SKIPN	0(TE)
	JRST	STBRK1		;USE THIS ONE
	ADDI	TE,LBA
	CAIG	TE,BNADR	;LAST?
	JRST	STBRK0

	TTCALL	3,[ASCIZ "? OUT OF BREAK-POINTS"]
	JRST	MLUP.

STBRK1:	LDB	TA,[POINT 7,2(DT),24]
	JUMPN	TA,NONRES	;MAKE SURE RESIDENT
	LDB	TA,[POINT 15,1(DT),17]
	ADD	TA,@%PR		;SECTION NAME
	LDB	TD,[POINT 18,1(DT),35]
	CAMLE	TD,.JBREL
	JRST	HIPART
	MOVEM	DT,0(TE)
	MOVEM	TA,1(TE)
	SETZM	2(TE)		;CLR PROCEED COUNTER
	JRST	MLUP.

;HERE TO CLEAR A BREAK POINT (OR ALL)

CLRBRK:	JUMPN	DT,CLBRK0	;CLEAR ALL IF ZERO
	MOVE	TE,[XWD B1ADR,B1ADR+1]
	SETZM	B1ADR
	BLT	TE,BNADR+LBA-1
	JRST	MLUP.

CLBRK0:	MOVEI	TE,B1ADR	;FIND ONE MENTIONED
CLBRK1:	HRRZ	TD,0(TE)
	CAIN	TD,0(DT)
	JRST	CLBRK2		;FOUND
	ADDI	TE,LBA
	CAIG	TE,BNADR
	JRST	CLBRK1		;LOOP UNTIL NO MORE
	JRST	MLUP.		;JUST QUIT

CLBRK2:	SETZM	0(TE)
	SETZM	1(TE)		;CLEAR BP AUX STORAGE
	SETZM	2(TE)
	JRST	MLUP.

;HERE TO DO STOP RUN

STOPR:	MOVE	TE,CBLIO.
	PUSHJ	PP,1(TE)

;COMMON ROUTINE TO HANDLE BREAK

BCOM:	Z			;JSA TA,BCOM
	POP	TA,LEAV
	MOVEI	TA,B1SEC-B1INS+1(TA)
	HRRZM	TA,BCOM3
	MOVEI	TA,B1CNT-B1SEC(TA)
	HRRZM	TA,BCOM2
	MOVE	TA,BP1-B1CNT(TA)
	HLLM	TA,LEAV1	;SAVE FLAGS
	EXCH	TA,BCOM
	SOSG	@BCOM2		;TEST PROCEED COUNTER
	JRST	BREAK		;BREAK - ALL AC'S IN PLACE
	MOVEM	TA,SAV.TA	;STASH 'TA'
	LDB	TA,[POINT 9,LEAV,8]
	CAIL	TA,(<JSR>/1000)	;LOOK AT INSTRUCTION
	CAILE	TA,(<JSA>/1000)	;JSA,JSP
	TRNN	TA,700		;UUO
	JRST	PRCED1		;YES: USE PROCEED CODE
	CAIE	TA,(<PUSHJ>/1000)
	CAIN	TA,(<XCT>/1000)	;PUSHJ,XCT
	JRST	PRCED1		;MUST ALSO BE INTERPRETED
	MOVE	TA,SAV.TA	;OK TO JUST EXIT
	JRSTF	@LEAV1		;EXIT

;HERE TO BREAK - SAVE WORLD AND SET UP PDL

BREAK:	JSR	SAVE		;...
	PUSHJ	PP,REMOVB	;REMOVE BREAK-POINTS
	TTCALL	3,[ASCII "BREAK AT  "
		   BYTE (7)74,74]
	MOVE	TA,BCOM2
	SUBI	TA,2		;GET ADDR OF BP
	MOVEM	TA,CUR.BP	;SAVE IT
	HRRZ	TA,0(TA)	;PNTR TO PROTAB
	LDB	DT,[POINT 15,0(TA),17]
	HRRZ	TA,1(TA)	;ADDR IN USER'S PROGRAM
	HRRM	TA,PRCED0
	ADD	DT,@%NM		;NAMTAB ENTRY
	PUSHJ	PP,PRNAM	;PRINT BP NAME
	HRRZ	TA,@BCOM3	;GET SECTION NAME
	LDB	DT,[POINT 15,0(TA),17]
	ADD	DT,@%NM
	MOVE	TA,1(DT)	;SEE IF IT IS THE ONE
	CAME	TA,[SIXBIT /:GENER/]
	PUSHJ	PP,[TTCALL 3,[ASCIZ " IN "]
		    JRST PRNAM]
	TTCALL	3,[BYTE (7)76,76]
	JRST	MLUP.		;INTO MAIN LOOP

;PROCEED COMMAND COMES HERE

PROCED:	SKIPE	DIED.		;ARE WE ALIVE?
	JRST	[TTCALL 3,[ASCIZ "?CANNOT PROCEED!"]
		 JRST MLUP.]	;NO: PRINT MSG AND RETURN TO ML
	SKIPN	TA,CUR.BP	;CURRENT?
	JRST	START		;NO: START USERS PROG
	SKIPN	DT		;NUMBER GIVEN
	MOVEI	DT,1		;NO: ASSUME ONE
	MOVEM	DT,2(TA)	;SAVE COUNT
PRCED0:	HRRZI	TB,0		;ADDR MODIFIED !!!
	PUSHJ	PP,FETCH	;GET INSTRUCTION
	MOVEM	TA,LEAV
	PUSHJ	PP,INSRTB	;INSERT BREAK-POINTS
	JRST	PRCED2

PRCED1:	MOVE	TA,SAV.TA	;GET SAVED AC
	JSR	SAVE		;SAVE WORLD

PRCED2:	MOVEI	TC,100		;SET MAX LOOP COUNT
	MOVEM	TC,TEMP1
	JRST	IXCT5

IXCT4:	CAIL	TA,40		;SYSTEM UUO?
	JRST	IXCT6		;YES: DON'T INTERPRET
	MOVEM	TB,40		;SAVE UUO
	MOVEI	TB,41

IXCT:	SOSG	TEMP1		;LOOPING
	JRST	BPLUP
	PUSHJ	PP,FETCH
	MOVEM	TA,LEAV		;STASH INSTR

IXCT5:	HRLZI	17,AC0		;TEMP FETCH OF ACS
	BLT	17,17
	MOVEI	TA,@LEAV	;GET EFFECTIVE ADDRS
	DPB	TA,[POINT 23,LEAV,35]
	LDB	TC,[POINT 4,LEAV,12]
	LDB	TA,[POINT 9,LEAV,8]
	CAIN	TA,(<PUSHJ>/1000)
	JRST	IPUSHJ		;INTERPRET PUSHJ
	CAIN	TA,(<JSR>/1000)
	JRST	IJSR		;INTERPRET JSR
	CAIN	TA,(<JSP>/1000)
	JRST	IJSP		;INTERPRET JSP
	CAIN	TA,(<JSA>/1000)
	JRST	IJSA		;INTERPRET JSA
	MOVE	TB,LEAV
	TRNN	TA,700
	JRST	IXCT4		;INTERPRET UUO
	CAIN	TA,(<XCT>/1000)
	JRST	IXCT		;INTERPRET XCT
IXCT6:	MOVEI	TA,LEAV
IXCT7:	SETOM	TEMP2
IXCT8:	JRST	RESTOR

;VARIOUS INTERPRETERS

IPUSHJ:	DPB	TC,[POINT 4,CPUSHP,12]
	SETZM	TEMP2		;STORE AC FIELD INTO A PUSH
	MOVE	TA,LEAV
	JRST	IXCT8

IJSA:	MOVE	TA,BCOM
	HRL	TA,LEAV
	EXCH	TA,AC0(TC)
	JRST	IJSR2

IJSR:	MOVE	TA,BCOM
	HLL	TA,FLGS.
IJSR2:	MOVE	TB,LEAV
	PUSHJ	PP,DEP
	AOSA	TA,LEAV
ISR3:	MOVE	TA,LEAV
	JRST	IXCT7

IJSP:	MOVE	TD,BCOM
	HLL	TD,FLGS.
	MOVEM	TD,AC0(TC)
	JRST	ISR3

;COME HERE IF BREAK POINT LOOPING

BPLUP:	PUSHJ	PP,REMOVB
	JSR	SAVE
	TTCALL	3,[ASCIZ "? FATAL BREAK-POINT ERROR!"]
	JRST	MLUP.

;SAVE AND RESTORE WORLD CODE

SAVE:	Z			;JSR ENTRY
	MOVEM	17,PDL.		;CURRENT PDL
	MOVEM	17,AC0+17
	HRRZI	17,AC0
	BLT	17,AC0+16	;SAVE AC'S
	MOVE	TA,SAVE		;SAVE PROCESSOR FLAGS
	HLLM	TA,FLGS.
	JRST	@SAVE

RESTOR:	HRRM	TA,SAVE		;SAVE EXIT ADDR
	MOVE	TA,FLGS.
	HLLM	TA,SAVE
	HRLZI	17,AC0
	BLT	17,17		;RESTORE AC'S
	SKIPL	TEMP2
CPUSHP:	PUSH	0,BCOM		;AC MODIFIED AT IPUSHJ
	JRSTF	@SAVE		;EXIT

;COME HERE TO START USER'S PROGRAM

START:	PUSHJ	PP,INSRTB	;INSERT BREAK-POINTS
	MOVE	PP,PDL.
	JRST	@PROGST

FETCH:	TRNN	TB,-20
	SKIPA	TA,AC0(TB)
	MOVE	TA,0(TB)
	POPJ	PP,

DEP:	TRNN	TB,-20
	JRST	DEP1
	MOVEM	TA,0(TB)
	POPJ	PP,

DEP1:	MOVEM	TA,AC0(TB)
	POPJ	PP,

;CODE TO REMOVE OR INSERT BREAKPOINTS

INSRTB:	MOVE	TE,[JSR BP1]
	MOVEI	TD,B1ADR
INSRT1:	SKIPN	TB,0(TD)	;BP ACTIVE?
	JRST	INSRT2
	HRRZ	TB,1(TB)	;YES: GET ADDR OF BP
	PUSHJ	PP,FETCH	;GET INSTRUCTION
	MOVEM	TA,2(TE)	;SAVE IT
	MOVE	TA,TE
	PUSHJ	PP,DEP		;DEPOSIT "JSR"
INSRT2:	ADDI	TE,LBP
	ADDI	TD,LBA
	CAIG	TD,BNADR	;DONE??
	JRST	INSRT1
	POPJ	PP,		;YES:

REMOVB:	MOVEI	TE,BP1
	MOVEI	TD,B1ADR
REMOV1:	SKIPN	TB,0(TD)	;ACTIVE?
	JRST	REMOV2
	HRRZ	TB,1(TB)
	MOVE	TA,2(TE)
	PUSHJ	PP,DEP
REMOV2:	ADDI	TE,LBP
	ADDI	TD,LBA
	CAIG	TD,BNADR
	JRST	REMOV1
	POPJ	PP,

;PRINT NAME FOUND POINTED AT IN DT

PRNAM:	HLRZ	TA,0(DT)	;GET # OF WORDS
	HRRZI	TB,1(DT)	;GET ADDR OF FIRST
	HRLI	TB,(<POINT 6,,>);MAKE BP
PRNAM1:	ILDB	TC,TB
	JUMPE	TC,PRNAM2	;DONE IF ZERO
	ADDI	TC,40		;CONVER TO ASCII
	CAIN	TC,":"
	MOVEI	TC,"-"
	TTCALL	1,TC
	TLNE	TB,770000	;WORD FINISHED
	JRST	PRNAM1		;NO: LOOP
	SOJG	TA,PRNAM1	;YES: CHECK IF THAT'S ALL
PRNAM2:	POPJ	PP,		;ALL DONE - EXIT

;TRACE ROUTINES...

;HANDLE TRACE COMMAND (ON/OFF)

SETTRC:	MOVEM	W2,PTFLG.	;SAVE VALUE
	JRST	MLUP.		;AND CONTINUE

;HERE TO HANDLE TRACE.

TRACE.:	HRRZ	TA,(PP)		;GET ARG PTR
	HRRZ	TB,(TA)		;GET PROTAB LINK IF ANY
	HLRZ	TA,(TA)		;GET ARG COUNT AND FLAGS
	LDB	TE,[POINT 9,TA,35]	;GET ARG COUNT
	TRNE	TA,10000	;GOBACK?
	JRST	TRACE0		;YES
	TRNE	TA,20000	;EXIT PROGRAM?
	JRST	TRACE1		;YES
	TRNE	TA,3000		;PROGRAM-ENTRY OR OTHER ENTRY?
	JRST	TRACE2		;YES
	ADD	TB,@%PR		;MAKE REAL ADDR
	MOVE	TC,PRFLGS(TB)	;GET PROTAB FLAG WORD
	MOVEI	TD,L.PARA	;ASSUME PARAGRAPH
	TRNN	TC,PRLINK	;IS IT?
	MOVEI	TD,L.SECT	;NO: SECTION
	MOVEM	TB,0(TD)	;SAVE LAST WHATEVER.
	SKIPN	PTFLG.		;ARE WE PRINTING?
	JRST	CNPOPJ		;NO: JUST EXIT

; WE ARE TRACING SO WE MUST PRINT

	LDB	DT,[POINT 15,0(TB),17]
	ADD	DT,@%NM		;GET NAMTAB PNTR
	PUSH	PP,TD		;SAVE PNTR
	TTCALL	3,[BYTE (7)74,74]
	PUSHJ	PP,PRNAM	;PRINT NAME
	POP	PP,TD		;CHECK IF
	CAIN	TD,L.SECT	; SECTION OR NOT
	TTCALL	3,[ASCIZ " SECTION"]
	TTCALL	3,[BYTE (7)76,76,15,12]
	JRST	CNPOPJ		;RETURN...
;TRACE A 'GOBACK' OR 'EXIT PROGRAM'

TRACE0:	SKIPE	PTFLG.
	TTCALL	3,[ASCIZ "<<GOBACK>>
"]
	JRST	CNPOPJ

TRACE1:	SKIPE	PTFLG.
	TTCALL	3,[ASCIZ "<<EXIT PROGRAM>>
"]
	JRST	CNPOPJ

;TRACE ENTRY OR PROGRAM-ENTRY

TRACE2:	SKIPE	PTFLG.		;PRINTING?
	JRST	TRACE3		;YES
CNPOPJ:	ADDM	TE,(PP)		;NO, SKIP RETURN
CPOPJ:	POPJ	PP,

TRACE3:	AOS	(PP)		;AIM AT NAME ARG
	TTCALL	3,[ASCIZ "<<"]
	TRNE	TA,2000		;PROGRAM ENTRY?
	TTCALL	3,[ASCIZ "PROGRAM "]
	TRNE	TA,1000		;OR OTHER ENTRY?
	TTCALL	3,[ASCIZ "ENTRY "]
TRACE5:	SOJLE	TE,TRACE4	;CHK COUNT OF NAME TO PRINT
	AOS	TA,(PP)		;BUMP ARG PTR
	MOVE	TA,-1(TA)	;GET ARG WORD
	PUSHJ	PP,SIXSIX
	JRST	TRACE5
TRACE4:	TTCALL	3,[ASCIZ ">>
"]
	POPJ	PP,
;ENTER HERE FROM KILL.

BTRAC.:	SETOM	DIED.		;WE ARE NOW DEAD
	TTCALL	3,[ASCIZ "ENTERING COBDDT FROM: "]
	MOVE	TA,L.PARA	;PRINT LAST PARAGRAPH
	LDB	DT,[POINT 15,0(TA),17]
	ADD	DT,@%NM
	PUSHJ	PP,PRNAM
	SKIPN	TA,L.SECT	;WAS THERE A SECTION
	JRST	BTRAC1		;NOPE!
	TTCALL	3,[ASCIZ " IN "]
	LDB	DT,[POINT 15,0(TA),17]
	ADD	DT,@%NM
	PUSHJ	PP,PRNAM
BTRAC1:	TTCALL	3,CRLF
	JRST	MLUP.		;GO...

;ROUTINES TO KEEP TRACE CORRECT FOR PERFORMS

TRPD.:	POP	PP,TA		;SAVE RETURN ADDR
	PUSH	PP,L.SECT	;SAVE SECTION
	PUSH	PP,L.PARA	; AND PARAGRAPH
	JRST	(TA)		;RETURN

TRPOP.:	POP	PP,TA		;SAVE RETURN ADDR
	POP	PP,L.PARA	;RESTORE PARAGRAPH
	POP	PP,L.SECT	; AND SECTION
	JRST	(TA)		;RETURN


;PRINT A SIXBIT WORD

SIXSIX:	MOVEI	TB,0
	LSHC	TB,6
	ADDI	TB,40
	TTCALL	1,TB
	JUMPN	TA,SIXSIX
	POPJ	PP,
;....    JRG'S PART OF COBOL DEBUGGER  1-11-71
;TAH:	YOU  JRST TO GOJRG TO TURN ME ON.  I RETURN TO
;	YOU WITH A DISPATCH CODE IF USER TYPES SOMETHING
;	USEFUL IN AC W1,  AND IN THE OBVIOUS CASES A
;	POINTER TO AN ENTRY IN THE DATA-TABLE OR PROCEDURE-
;	TABLE OR A PROCEED COUNT IN AC W2.

	OPDEF	PU	[PUSHJ	PP,]
	DEFINE	ERR0(FOO)	 <[JSP TA,PUTERR
			   ASCIZ FOO]>
	DEFINE	ERR(FOO)	<
				 XLIST
				 JRST	ERR0(FOO)
				 LIST>

GOJRG:	TTCALL	3,CRLF
GOJRG0:	TTCALL	1,[EXP "*"]
	MOVEI	SW,0		;CLEAR SWITCHES.  RH(SW)=CHAR-POSITION
	PU	GETCHR		;CH ALWAYS HOLDS THE NEXT CHAR.
	CAIN	CH,12		;SKIP RANDOM LF'S
	JRST	.-2
	PU	GATOM		;GET COMMAND WORD IN C(TE-TA) IN SIXBIT
	JUMPN	TE,GOJRG1	;ATOM FOUND?
	PU	EOLCHK		;CHECK EOL IF NONE
	JRST	[TSWT ALTFLG
		 JRST GOJRG0
		 JRST GOJRG]
	AOJA	SW,ERR0("LINE TERMINATION ERROR")
GOJRG1:	MOVEI	W1,COMTAB	;USE COMMAND TABLE
	PU	GETCOM		;GET LOC OF ENTRY WHOSE INIT. SEG IS C(TE)
	SUBI	W1,COMTAB
	HRRZ	TA,COMDIS(W1)
	JRST	0(TA)		;DISPATCH

;DISPATCH ENTRIES FROM COMMAND TABLE

CLR.:	SWON	CLRFLG		;CLEAR COMMAND
BRK.:	SWONS	BPTFLG		;BREAK/CLEAR SEEN FLAG

DIS.:
ACC.:	SWOFF	BPTFLG!CLRFLG	;CLEAR BREAKPOINT FLAG
	PU	GATOM		;GET DATA-NAME
	CAMN	TE,[SIXBIT 'TALLY']
	JRST	DOTAL		;TREAT TALLY SPECIALLY
ACC.0:	JUMPE	TE,CKCLR
	PU	GETNAM
	JUMPE	TF,ACCEP2	;SYMBOL NOT IN TABLE
	PUSH	PP,[OCT	-1]	;PUSH ON -1 TO INDICATE BEGINNING OF DATA-NAME PTRS
	PUSH	PP,TF		;PUSH ON PTR TO DATA-NAME SYMBOL HDR
DIS2:	PU	SKPBLN		;SKIP BLANK/TABS
	CAIE	CH,"("		;LOOK FOR SUBSCRIPTS
	JRST	MOREDN		;NO SUBSCRIPTS
	SKIPE	NSUBS		;SKIP IF FIRST OCCURANCE OF SUBSCRIPTS
	AOJA	SW,ERR0("SUBSCRIPT ERROR")
DIS3:	PU	GETCHR		;SKIP PAST "(" OR ","
	PU	GETNUM		;GET A NUMBER
	JUMPLE	W2,ERR0("SUBSCRIPT ERROR")
	AOS	TA,NSUBS
	CAILE	TA,3		;CHECK MAX ALLOWABLE
	ERR	"ONLY 3 SUBSCRIPTS ALLOWED"
	MOVEM	W2,SUB0.-1(TA)	;STASH AWAY
	PU	SKPBLN		;SKIP BLANKS
	CAIN	CH,","		;MORE?
	JRST	DIS3		;YES: CONTINUE
	CAIE	CH,")"		;NO: CHECK PROPER DELIM.
	AOJA	SW,ERR0("IMPROPER SUBSCRIPT DELIMITER")
	PU	GETCHR		;OK: SKIP PAST IT
	MOVE	TB,SUB0.	;MOVE SUB0. TO TB
	EXCH	TB,SUB0.-1(TA)	;EXCHANGE TB WITH SUB0. - 1
				;PLUS THE CONTENTS OF TA
	MOVEM	TB,SUB0.	;STORE TB IN SUB0.
	JRST	MOREDN


CKCLR:	TSWT	CLRFLG		;CLEAR COMMAND?
	TSWT	BPTFLG
	TDZA	W2,W2
	ERR	"MISSING DATA-NAME"
	SWOFF	CLRFLG!BPTFLG
	JRST	WHR.

MOREDN:	PU	GATOM		;LOOK FOR QUALIFIER
	CAME	TE,[SIXBIT /IN/]
	CAMN	TE,[SIXBIT /OF/]
	JRST	INOF
	JUMPN	TE,MORED2	;JUMP IF LINE NOT EMPTY
	PU	EOLCHK
	JRST	QUAL
MORED2:	AOJA	SW,ERR0("IN/OF MISSING")

INOF:	PU	GATOM
	JUMPE	TE,ERR0("MISSING QUALIFIER")
	PU	GETNAM
	JUMPE	TF,ACCEP3	;SYMBOL NOT IN TABLE
	PUSH	PP,TF		;PUSH PTR TO SYMBOL TABLE HDR FOR DATA-NAME
	TSWT	BPTFLG		;ACCEPT/DISPLAY?
	JRST	DIS2		;YES.  CHECK FOR MORE DATA-NAMES
	PU	EOLCHK
	JRST	QUAL
	AOJA	SW,ERR0("LINE TERMINATION ERROR")

ACCEP2:	TSWT	BPTFLG
	ERR	"UNDEFINED DATA-NAME"
	ERR	"UNDEFINED PARAGRAPH-NAME"

ACCEP3:	TSWT	BPTFLG
	ERR	"UNDEFINED DATA-NAME"
	ERR	"UNDEFINED SECTION-NAME"

;SEARCH FOR (QUALIFIED) VARIABLE.
;   PDL HAS -1, THEN  XWD 0,PTR-TO-NAMTAB-ENTRY   FOR EACH
;   VARIABLE.  POINTER TO DATAB OR PRTAB ENTRY RETURNED
;   IN W2.

QUAL:	SWOFF	NUQFLG		;CLEAR NON-UNIQUE FLAG
	SETZI	W2,		;CLEAR W2 INDICATING NO SUCCES YET
	HRRZ	TB,PP		;MAKE RH(TB) POINT AT FIRST NAMPTR
	SKIPL	-1(TB)
	SOJA	TB,.-1
	HRRZ	TA,(TB)		;MAKE LH(TB) POINT AT ENTRY FOR LOWEST SPEC. VAR.

QUAL2:	SWON	FQFLAG		;SET CURRENT SEARCH IS FULLY-QUAL. FLAG
	HRRZ	TA,(TA)		;LOAD LINK TO NEXT ENTRY OF SAME NAME
	TRC	TA,DTTYPE	;WHICH TABLE?
	TRNE	TA,TYPMSK
	JRST	QUAL21		;PRTAB
	ADD	TA,@%DT		;DATAB.  ADD OFFSET
	TSWF	BPTFLG		;LOOKING FOR DATAB ENTRY?
	JRST	QUAL2		;NO.  KEEP GOING
	JRST	QUAL22		;YES.  CARRY ON

QUAL21:	TRC	TA,DTTYPE+PRTYPE
	TRNE	TA,TYPMSK	;CHECK FOR PRTAB
	JRST	QUAL6		;NO MORE ENTRIES
	ADD	TA,@%PR		;ADD OFFSET
	TSWT	BPTFLG		;LOOKING FOR PRTAB ENTRIES
	JRST	QUAL2		;NO.  KEEP GOING
	MOVE	TE,PRFLGS(TA)	;GET FLAG WORD
	TRNN	TE,PRLINK	;PARAGRAPH?
	JRST	QUAL2		;NO.  WAS SECTION NAME. TRY AGAIN

QUAL22:	HRL	TB,TA		;PTR TO NEXT LOW ENTRY
	HRRZ	TA,TB		;TA POINTS AT NAM PTRS IN PDL
	HLRZ	TD,TB		;TD POINTS AT ANCESTOR CHAIN

QUAL3:	CAIGE	TA,(PP)		;THROUGH NAME PTRS IN PDL?
	AOJA	TA,QUAL5	;NO.  TA POINTS AT NEXT NAME PTR
	HRRZ	TE,PRFLGS(TD)	;SUCCESSFUL MATCH.  FULLY QUALIFIED?
	ORI	TE,PRLINK	;(TE)=0 IF SECTION-NAME
	TSWT	BPTFLG
	HLRZ	TE,DTSON(TD)	;DATAB ENTRY.  LOAD FATHER LINK
	TSWF	FQFLAG
	JUMPE	TE,[HLRZ W2,TB	;JUMP IF AT LEVEL 01
		    JRST GOTAH]
	SKIPE	W2		;NOT FULLY QUALIFIED
	SWON	NUQFLG		;NOT UNIQUE.  SET FLAG
	HLRZ	W2,TB		;SAVE PTR TO FIRST MATCH

QUAL4:	HLRZ	TA,TB		;GET READY TO UPDATE LH(TB)
	JRST	QUAL2		;GET LINK TO PROPER TYPE ENTRY

QUAL5:	TSWF	BPTFLG
	JRST	[LDB TD,SECNAM	;LOOK TO SEE IF SECT. NAM. MATCHES ((TA))
		ADD TD,@%PR
		JRST QUAL52 ]
QUAL51:	MOVE	TE,DTFLAG(TD)	;LOAD FLAG WORD
	HLRZ	TD,DTSON(TD)	;GET FATHER/BROTHER LINK
	JUMPE	TD,QUAL4	;JUMP IF NO FATHER
	TRZ	TD,TYPMSK	;CLEAR TYPE BIT
	ADD	TD,@%DT		;ADD OFFSET
	TLNN	TE,DTLINK	;IS THIS ENTRY LINKED TO FATHER
	JRST	QUAL51		;NO.  GO TO BROTHER

QUAL52:	LDB	TE,NMLINK	;DOES ANTECEDENT HAVE SAME NAME AS ((TA))?
	ADD	TE,@%NM		;ADD NAMTAB OFFSET
	HRRZ	TF,(TA)		;GET NAMTAB PTR OUT OF PDL
	CAIN	TF,(TE)
	JRST	QUAL3		;NAME MATCHES.  LOOK FOR FURTHER QUALIFIER
	SWOFF	FQFLAG		;NAME DIFFERS.  CLEAR NOT FULLY QUAL. FLAG
	TSWT	BPTFLG		;NAME DIFFERS
	JRST	QUAL51		;GO UP AGAIN IF LOOKING AT DATAB ENTRIES
	JRST	QUAL4		;SECTION-NAMES HAVE NO FATHERS

QUAL6:	TSWF	NUQFLG		;NO MORE ENTRIES AT LOWEST LEVEL
	ERR	"NOT UNIQUELY QUALIFIED"
	JUMPN	W2,GOTAH	;OK IF EXACTLY ONE FOUND
	ERR	"NOT DEFINED"

PRO.:	MOVEI	W2,1		;RETURN PROCEED COUNT IN W2
	PU	EOLCHK
	JRST	GOTAH
	PU	GETNUM		;GET PROCEED CONT
	JUMPLE	W2,ERR0("PROCEED COUNT ERROR")

STP.:
WHR.:	PU	EOLCHK
	JRST	GOTAH
	AOJA	SW,ERR0("LINE TERMINATION ERROR")

;COMMAND ERROR
COMERR:	ERR	"ILLEGAL COMMAND"

TRC.:	PU	GATOM		;FETCH ATOM
	JUMPE	TE,TRC.E	;ERROR IF NNONE
	MOVEI	W2,1
	CAMN	TE,[SIXBIT /ON/]
	SETOI	W2,
	CAMN	TE,[SIXBIT /OFF/]
	SETZI	W2,
	SKIPLE	W2		;ALL OK?
TRC.E:	ERR	("ON/OFF REQUIRED")
	JRST	WHR.

;MODULE COMMAND SPECIFIES SWITCH TO SYMBOL TABLES OF NAMED MODULE (PROGRAM)

MOD.:	PU	GATOM		;GET PROGRAM NAME
	JUMPE	TE,MOD.E1	;NONE THERE
	MOVEI	NM,NMTAB	;INIT NMTAB LIST PTR
MOD.2:	HLRZ	TG,(NM)		;GET ADDR OF NAME OF LOADED PROGRAM
	JUMPE	TG,MOD.E2	;PROGRAM NAME NOT FOUND
	HRRZI	TH,TE		;INIT PTR TO NAME TYPED
	LDB	TI,[POINT 3,-1(TG),17]	;COUNT OF NAME IN CORE
	SUBI	TI,1
MOD.3:	MOVE	TJ,(TH)		;COMPARE WORD OF NAMES
	JUMPE	TJ,MOD.2	;IF TYPED NAME RUNS OUT, NOT A MATCH
	CAME	TJ,(TG)
	AOJA	NM,MOD.2	;NO MATCH, CONTINUE DOWN LIST
	AOS	TG		;EQUAL, CHECK NEXT WORD OF NAMES
	AOS	TH
	SOJG	TI,MOD.3
	MOVE	TJ,(TH)		;POSSIBLE MATCH, ANY LOOSE ENDS?
	CAIG	TH,TE+4		;IF NOT USED ALL 5 AC'S AND
	JUMPN	TJ,MOD.2	;NEXT AC NOT NULL, ITS NO MATCH
	HRRZI	TA,@%NM		;GET ADDRS OF %NM., %DT., %PT.
	HRRZ	NM,(NM)		;GET ADDRS OF %NM, %DT, %PT IN NEW PROG
	HRRZ	TB,(NM)		;STORE NEW %NM
	MOVEM	TB,(TA)
	HRRZ	TB,1(NM)	;NEW %DT
	MOVEM	TB,1(TA)
	HRRZ	TB,2(NM)	;NEW %PT
	MOVEM	TB,2(TA)
	JRST	GOTAH

MOD.E1:	ERR	("PROGRAM-NAME EXPECTED")
	JRST	WHR.

MOD.E2:	ERR	("PROGRAM NOT LOADED")
	JRST	WHR.

;COMMAND TABLE

COMTAB:	SIXBIT	/DISPLA/
	SIXBIT	/ACCEPT/
	SIXBIT	/PROCEE/
	SIXBIT	/BREAK/
	SIXBIT	/CLEAR/
	SIXBIT	/WHERE/
	SIXBIT	/STOP/
	SIXBIT	/TRACE/
	SIXBIT	/MODULE/
	0

;COMMAND DISPATCH TABLE

COMDIS:	XWD	DISPGN,DIS.
	XWD	ACCGEN,ACC.
	XWD	PROCED,PRO.
	XWD	SETBRK,BRK.
	XWD	CLRBRK,CLR.
	XWD	WHERE,WHR.
	XWD	STOPR,STP.
	XWD	SETTRC,TRC.
	XWD	MLUP.,MOD.
	XWD	0,COMERR

;GETCOM RETURNS THE LOCATION IN W1 OF THE SIXBIT WORD,
;   WHOSE  (UNIQUE)  INITIAL SEGMENT IS IN C(TE), FROM THE 
;   TABLE OF SIXBIT WORDS POINTED AT BY (W1).  THE LAST WORD
;   OF THE TABLE MUST BE BLANKS (=0).  RETURNS PTR TO BLANK
;   ENTRY FOR ERROR RETURN.

GETCOM:	SETOI	TD,		;FIND MASK FOR TRAILING BLANKS
	LSH	TD,-6		;FIND MASK FOR TRAILING BLANKS
	TDNE	TE,TD
	JRST	.-2

GETCM2:	SKIPN	TB,(W1)
	POPJ	PP,		;RETURN.  ERROR - MATCHING WORD NOT FOUND
	ANDCM	TB,TD
	CAME	TB,TE
	AOJA	W1,GETCM2	;DOESN'T MATCH INIT. SEG.

REPEAT 0,<	;PROBABLY DON'T WANT TWO COMMANDS WHICH
		;   START WITH THE SAME LETTER.
	MOVEI	TF,1(W1)
	SKIPN	TB,(TF)
	POPJ	PP,		;UNIQUE
	AND	TB,TD
	CAME	TB,TE
	JRST	.-4		;DOESN'T MATCH INIT. SEG.
	SETOI	TE,		;NON-UNIQUE.  SCREW-UP COMMAND WORD.  GUARANTEES FAIL
	JRST	GETCM2
>
	POPJ	PP,

;SKPBLN SKIPS THE BLANKS AND TABS AND PUTS THE NEXT NON-BLANK/TAB
;   CHARACTER IN C.  SETS BLNFLG SWITCH IF AT LEAST ONE BLANK
;   OR TAB IS FOUND

SKPBL2:	SWONS	BLNFLG		;BLANK/TAB SEEN.  SET FLAG
SKPBLN:	SWOFFS	BLNFLG		;CLEAR BLANK/TAB SEEN FLAG
	PU	GETCHR		;GET NEXT CHAR. FROM BUFFER
	CAIE	CH," "
	CAIN	CH,"	"
	JRST	SKPBL2
	POPJ	PP,		;RETURN N0N-BLANK/TAB CHAR. IN C.


;GETCHR USES GETCH. TO GET NEXT CHAR. IN C.  INCREMENTS CHAR.
;   POSITION COUNTER

GETCHR:	TTCALL	4,CH		;GET NEXT CHARACTER INTO CH
	JUMPE	CH,GETCHR	;SKIP NULLS
	CAIN	CH,15		;SKIP CARR RET'S
	JRST	GETCHR
	CAIE	CH,13		;CONVRT VT & FF TO LF
	CAIN	CH,14
	MOVEI	CH,12
	CAIE	CH,12
	AOSA	SW
	POPJ	PP,		;DON'T INCR. CNTR FOR VERT. MOVE%
	CAIN	CH,"	"	;CHECK FOR TAB
	ORI	SW,7		;TAB SEEN. FIX UP POSITION CTR
	POPJ	PP,


;EOLCHK SKIPS INITIAL BLANKS/TABS AND GIVES SKIP RETURN
;   IF NEXT CHAR. IS NOT A CR OR AN ALTMODE (33,175,176).
;   SETS ALTFLG AND ECHOS 3 BLANKS IF ALTMODE FOUND.

EOLCHK:	PU	SKPBLN		;SKIP BLANKS ETC.
	CAIN	CH,12
	POPJ	PP,
	CAIE	CH,33
	CAIN	CH,175		;ANY FLAVOR OF ESC WILL DO
	JRST	EOLCH2
	CAIN	CH,176
	JRST	EOLCH2
	AOS	0(PP)
	POPJ	PP,

EOLCH2:	SWON	ALTFLG		;SET ALT-MODE SEEN
	TTCALL	3,[ASCIZ "   "]
	POPJ	PP,

;GATOM GETS A STRING OF COBOL CHARACTERS THROUGH
;   THE NEXT NON-ALPHA-NUMERIC-(- AND .) AND RETURNS THEM
;   PACKED INTO SIXBIT IN (TE-TA).   DASHES ARE
;   CONVERTED TO COLONS.  THE
;   BIGFLG SWITCH IS SET IF THE STRING EXCEEDS 30 CHARACTERS.
;   C(TE)  CAN BE TESTED (=0 ?) TO SEE IF STRING IS EMPTY.

GATOM:	PU	SKPBLN
	SETZB	TA,TB
	SETZB	TC,TD
	SETZI	TE,
	MOVE	TF,[POINT 6,TE]

GATOM3:	CAIN	CH,"-"
	MOVEI	CH,":"
	CAIL	CH,"0"		;TEST FOR ALPH-NUMERICS
	CAILE	CH,"Z"
	POPJ	PP,		;OUT OF SIGHT
	CAILE	CH,":"
	CAIL	CH,"A"
	JRST	GATOM4		;LEGAL CHAR.
	POPJ	PP,		;NOT LEGAL CHAR.

GATOM4:	ADDI	CH,40		;CONVERT ASCII TO SIXBIT
	CAME	TF,[POINT 6,TA,35]	;IGNORE CHARS. IN EXCEES OF 30
	IDPB	CH,TF		;DEPOSIT CHAR. IN C(TE-TA)
	PU	GETCHR
	JRST	GATOM3


;GETNUM INTREPRETS THE NEXT CHARS. AS AN INTEGER AND RETURNS
;   THE VALUE IN W2.

GETNUM:	SETZI	W2,
	PU	SKPBLN		;SKIP INITIAL BLANK/TABS IF ANY

GETNU3:	CAIL	CH,"0"
	CAILE	CH,"9"
	POPJ	PP,		;NON-NUMERIC.  RETURN
	IMULI	W2,^D10
	ADDI	W2,-60(CH)	;CONVERT ASCII TO AN INTEGER AND ADD
	PU	GETCHR
	JRST	GETNU3

;GETNAM SEARCHES NAMTAB FOR AN ENTRY THE SAME AS C(TE-TA).
;   RETURNS POINTER TO ENTRY IN TF. OTHERWISE RETURN
;   PTR TO ENTRY IF C(TE-TA) IS INITIAL SEGMENT OF ONLY
;   THAT ENTRY (PRINTS ERROR MESSAGE IF TWO SUCH ENTRIES).
;   FAILING ALL THAT RETURN 0.

GETNAM:	SWOFF	NUIFLG		;CLEAR NOT UNIQUE INITIAL SEGMENT FLAG
	MOVEI	W2,5		;MAKE (TH)=# FULL WORDS IN (TE-TA)
	SETOI	TI,
	SKIPN	TJ,TE-1(W2)
	SOJA	W2,.-1
	LSH	TI,-6		;W2 HAS LENGTH OF SYMBOL TYPED
	TDNE	TJ,TI		;MAKE TI A MASK FOR TRAILING BLANKS OF PARTIAL WORD
	JRST	.-2
	HRRZ	TF,@%NM		;MAKE TF POINT AT HDR OF NAMTAB ENTRIES
	AOSA	TF		;LH(TF) IS PTR TO FIRST MATCHING PROPER INT. SEG
				;(=0, IF NONE YET)

GETNM2:	ADDI	TF,1(TG)	;GET NEXT ENTRY
	HLRZ	TG,(TF)		;TG=LH(HDR)
	JUMPE	TG,GETNM5	;JUMP IF THRU TABLE
	CAMLE	W2,TG		;DON'T BOTHER IFUSER SYMBOL LARGER
	JRST	GETNM2
	HRRZI	TK,(TF)		;INITIALIZE LOOP TO COMPARE (TE-TA) WITH ENTRY
	SETZI	TH,
GETNM3:	ADDI	TK,1
	MOVE	TJ,(TK)		;GET NEXT SIXBIT WORD FROM ENTRY
	CAME	TJ,TE(TH)
	JRST	GETNM4		;SYMBOL DOESN'T MATCH
	CAIGE	TH,-1(TG)
	AOJA	TH,GETNM3
	CAIE	TG,5
	SKIPN	TE+1(TH)
	POPJ	PP,		;SUCCESS
	JRST	GETNM2		;C(TE-TA) LONGER THAN CURRENT ENTRY

GETNM4:	MOVE	TK,TE(TH)	;TRY MASK ONLY IF C(TE(TH)) IS PARTIAL WORD
	JUMPE	TK,GETNM6
	TRNE	TK,77
	JRST	GETNM2		;FAILED ON FULL WORD FROM TE-TA
	ANDCM	TJ,TI		;MASK OUT TRAILING CHARS.
	CAME	TJ,TE(TH)
	JRST	GETNM2		;NOT INITIAL SEGMENT
GETNM6:	TLNE	TF,-1		;YES
	SWONS	NUIFLG		;WE HAVE SEEN AT LEAST 2 INIT. SEG.
	HRLS	TF		;SAVE PTR TO MATCHING INITIAL SEGMENT
	JRST	GETNM2

GETNM5:	TSWF	NUIFLG		;THRU TABLE
	ERR	"MATCHES INITIAL SEGMENTS OF 2 SYMBOLS"
	HLRZS	TF
	POPJ	PP,

;PUTERR OUTPUTS ^ PRECEDED (OR FOLLOWED BY) AN ERROR
;   MESSAGE TO POINT AT A SYNTAX ERROR ON USERS LINE ABOVE
;CALL:	JSP	TA,PUTERR
;	ASCIZ	/ERROR MESSAGE OF YOUR CHOICE/
;RETURNS TO MLUP. TO RESTART REBUGGER

PUTERR:	HRRZ	TB,SW		;LOAD CHAR. POSITION FO LAST USED CHAR.
PUT1A:	PU	EOLCHK
	JRST	PUT1B
	PU	GETCHR
	JRST	PUT1A
PUT1B:	TSWF	ALTFLG
	TTCALL	3,CRLF		;NEED CRLF IF ALTMODE TYPED.
	HRRZ	TC,TA		;TC WILL CONTAIN BPTR TO MESSAGE
	HRLI	TC,(POINT 7,0)	
	MOVEI	TD,2
	ILDB	TE,TC
	SKIPE	TE
	AOJA	TD,.-2
	CAMLE	TD,TB		;COMPARE MESSAGE LENGTH WITH CHAR. POSITION
	SOJA	TB,PUTER2	;JUMP IF MESSAGE TOO LONG TO GO IN FRONT OF ^ .
	SUB	TB,TD		;MESSAGE SHORT ENOUGH TO GO IN FRONT OF ^
	JUMPE	TB,PUT2
PUT1:	TTCALL	1,[EXP "?"]	;PRINT "?" AT FRONT OF LINE
	SOJLE	TB,PUT2
PUT0:	TTCALL	1,[EXP " "]	;PRINT ENOUGH BLANKS IN FRONT OF MESSAGE
	SOJG	TB,PUT0
PUT2:	TTCALL	3,(TA)		;PRINT MESSAGE
	TTCALL	3,[ASCIZ " ^"]
	JRST	MLUP.		;RETURN TO MAIN LOOP

PUTER2:	TTCALL	1,[EXP "?"]	;"?" BEFORE ERROR MESSAGE
	SOJLE	TB,PUTER4
PUTER3:	TTCALL	1,[EXP " "]	;MESSAGE TOO LONG.  HAS TO GO AFTER ^
	SOJG	TB,PUTER3	;PRINT BLANKS BEFORE ^
PUTER4:	TTCALL	3,[ASCIZ "^ "]
	TTCALL	3,(TA)		;PRINT MESSAGE
	JRST	MLUP.

;COBOL DEBUG MAIN LOOP

MLUP.:	SETZI	SW,		;CLEAR FLAGS
	SETZM	NSUBS		;INIT PARSE
	MOVE	PP,PDL.		;RESTORE PUSH-DOWN-LIST

	JRST	GOJRG		;*** PARSE
GOTAH:	MOVE	PP,PDL.
	MOVE	DT,W2
	HLRZ	W1,COMDIS(W1)
	CAIE	W1,ACCGEN	;CHECK FOR CODE GENERATORS
	CAIN	W1,DISPGN
	SKIPA
	JRST	0(W1)		;NO: JUST DISPATCH

;CODE INIT AND EXECUTION

	SETZM	TEMPC
	SETZM	EAC
	SETZM	TEMROL
	MOVE	TE,[XWD CODFST,CODFST+1]
	BLT	TE,CODLST
	MOVE	LIT,[IOWD N.LIT,LITROL]
	MOVE	COD,[IOWD N.COD,CODROL]
	SKIPN	DT		;CHECK FOR LAST DATA ITEM
	JRST	[MOVE DT,LAST.
		 JUMPE DT,NOLAST
		 MOVE TE,[XWD SAVSUB,NSUBS]
		 BLT TE,NSUBS+3
		 JRST .+1]
	MOVEM	DT,LAST.
	MOVE	TE,[XWD NSUBS,SAVSUB]
	BLT	TE,SAVSUB+3

	PUSHJ	PP,0(W1)

	PUSH	COD,[POPJ PP,]
	PUSHJ	PP,CODROL	;CALL CODE
	JRST	MLUP.		;RETURN HERE
;DISPLAY A FLOATING POINT VALUE
;ENTER WITH FLOATING-POINT NUMBER IN "TG".

DSP.FP:	MOVEI	TE,7		;SET TEN'S EXPONENT TO 7

	TDNN	TG,[XWD 777,-1]	;IS IT ZERO?
	JRST	DSP.Z		;YES--SPECIAL PROCESSING

	JUMPGE	TG,DSP.1
	MOVMS	TG
	TTCALL	3,[ASCIZ "-"]
DSP.1:	FAD	TG,[0]		;NORMALIZE

DSP.A:	CAMG	TG,FPP20	;IS NUMBER > 10**20?
	JRST	DSP.B		;NO
	FDVR	TG,FPP20	;YES--BRING IT DOWN
	ADDI	TE,^D20		;ADD TO EXPONENT
	JRST	DSP.A		;LOOP UNTIL IN RANGE

DSP.B:	CAML	TG,FPM12	;IS NUMBER < 10**-12?
	JRST	DSP.C		;NO
	FMPR	TG,FPP12	;YES--BRING IT UP
	SUBI	TE,^D12		;DECREMENT TEN'S EXPONENT
	JRST	DSP.B		;LOOP UNTIL WITHIN RANGE

DSP.C:	MOVE	TJ,TG		;SPLIT THE NUMBER INTO EXPONENT AND MANTISSA
	MULI	TJ,400

	CAMLE	TG,FPP10	;IS NUMBER GREATER THAN 10**10?
	JRST	DSP.H		;YES
	CAILE	TJ,200		;NO--IS IT LESS THAN 1?
	JRST	DSP.L		;NO
;NUMBER IS LESS THAN 1, BUT GREATER THAN 10**-12

	MOVE	A0,TJ+1	;GET DECIMAL POINT TO LEFT OF A0
	MOVEI	A1,0

	SUBI	TJ,200
	ASHC	A0,(TJ)

DSP.E:	CAML	A0,DP9		;AT LEAST 8 PLACES IN A0?
	JRST	DSP.F		;YES
	MUL.21	A0,DP1		;MULTIPLY BY 10
	SOJA	TE,DSP.E	;DECREMENT TEN'S EXPONENT AND LOOP

DSP.F:	ADDI	A0,5		;ROUND
	MOVE	A1,A0		;NOW PUT DECIMAL POINT BETWEEN A0&A1
	MOVEI	A0,0
	JRST	DSP.N

;THE NUMBER IS GREATER THAN 10**10, BUT LESS THAN 10**20

DSP.H:	MOVE	A0,TJ+1
	MOVEI	A1,0
	ASHC	A0,-306(TJ)	;DECIMAL POINT IS NOW TO RIGHT OF A1
	JUMPE	A0,DSP.J	;IS IT < 2**35?

DSP.I:	DIV.21	A0,DP3		;NO: DIVIDE BY 1000
	ADDI	TE,3		;KICK UP TEN'S EXPONENT
	JUMPN	A0,DSP.I	;LOOP

DSP.J:	MOVE	A0,A1
	MOVEI	A1,0
	JRST	DSP.N

;THE NUMBER IS GREATER THAN 1 BUT LESS THAN 10**10

DSP.L:	MOVE	A0,TJ+1
	MOVEI	A1,0
	ASHC	A0,-243(TJ)
;THE NUMBER NOW IS FIXED, AND HAS DECIMAL POINT BETWEEN A0&A1

DSP.N:	CAMGE	A0,DP8		;IS IT GREATER THAN 10**8?
	JRST	DSP.O		;NO
	IDIVI	A0,^D10	;REDUCE IT
	CAIGE	A1,5		;IS REMAINDER < 5?
	TDCA	A1,A1		;YES
	MOVSI	A1,200000	;NO
	AOJA	TE,DSP.N	;BUMP TEN'S EXPONENT AND LOOP

DSP.O:	CAML	A0,DP7		;IS NUMBER LESS THAN 10**7?
	JRST	DSP.P		;NO
	MUL.21	A0,DP1		;YES: INCREASE IT
	SOJA	TE,DSP.O

DSP.P:	TLZE	A1,200000	;ANY NEED TO ROUND?
	AOJA	A0,DSP.N	;YES--BUMP IT AND LOOP

	IDIV	A0,DP7
	ADDI	A0,"0"
	ROT	A0,-7
	TLO	A0,1340
	TTCALL	3,A0

	MOVEI	TJ,DP6

DSP.Q:	MOVE	A0,A1
	IDIV	A0,(TJ)
	ADDI	A0,"0"
	TTCALL	1,A0
	SKIPE	A1
	AOJA	TJ,DSP.Q

	TTCALL	3,[ASCIZ "E"]
	JUMPGE	TE,DSP.R
	TTCALL	3,[ASCIZ "-"]
	MOVMS	TE

DSP.R:	IDIVI	TE,^D10
	HRLM	TE+1,0(PP)
	SKIPE	TE
	PUSHJ	PP,DSP.R

	HLRZ	TJ,(PP)
	ADDI	TJ,"0"
	TTCALL	1,TJ

	POPJ	PP,
;SPECIAL TREATMENT FOR "TALLY"

DOTAL:	CAIN	W1,ACC		;ACCEPT OR DISPLAY?
	JRST	ACCTAL
	CAIE	W1,DIS
	JRST	ACC.0		;NEITHER

DISTAL:	MOVE	TE,@166		;GET CONTENTS OF TALLY
	JUMPGE	TE,.+4		;NOT NEGATIVE
	MOVEI	CH,"-"		;PRINT MINUS SIGN
	TTCALL	1,CH
	MOVM	TE,TE		;MAGNITUDE
	PUSHJ	PP,PRNUM	;PRINT NUMBER
	JRST	GOJRG

ACCTAL:	MOVSI	TE,6005		;PARAMETERS FOR ACCEPT UUO
	ACEPT%,,TE		;GET VALUE FROM USER
	MOVEM	1,@166		;PUT LOW ORDER 5 DIGITS IN TALLY
	JRST	GOJRG0
;THE NUMBER WAS ZERO

DSP.Z:	TTCALL	3,[ASCIZ "0.0E0"]
	POPJ	PP,


A0==0
A1==A0+1

FPP20:	1.0E20
FPP12:	1.0E12
FPM12:	1.0E-12
FPP10:	1.0E10

DP9:	DEC	1000000000
DP8:	DEC	100000000
DP7:	DEC	10000000
DP6:	DEC	1000000
	DEC	100000
	DEC	10000
DP3:	DEC	1000
	DEC	100
DP1:	DEC	10
	DEC	1


;MESSAGE TYPED UPON STARTING COBDDT

STRTUP:	ASCIZ "
STARTING COBOL DDT
"
;IMPURE AREA

INTERNAL PTFLG.

PTFLG.:	BLOCK 1		;NON-ZERO IF WE ARE TRACING
CBLIO.:	BLOCK 1		;ADDRESS OF 'RESET.' ROUTINE
PROGST:	BLOCK 1		;STARTING ADDRESS OF COBOL PROGRAM
NSUBS:	BLOCK 1		;NUMBER OF SUBSCRIPTS TYPED
SUB0.:	BLOCK 3		;PLACE FOR SUBS
SAV.TA:			;PLACE TO SAVE "TA" IN BCOM
SAVDT:	BLOCK 1		;PLACE TO SAVE "DT"
FLGS.:	BLOCK 1		;PLACE TO SAVE PROCESSOR FLAGS
TEMP1:			;TEMP STORAGE FOR BP CODE
EAC:	BLOCK 1		;AC NUMBER FOR ASSEMBLY
TEMP2:			;TEMP STORAGE FOR BP CODE
REMAN:	BLOCK 1		;TEMP STORAGE USED IN SUBSCR CALC

BASEA:	BLOCK 1		;ADDR OF "A" OPERAND (RH)
RESA==BASEA		;BYTE RESIDUE FOR "A" (LH)
INCRA:	BLOCK 1		;OFFSET FOR "A"
SIZEA:	BLOCK 1		;SIZE OF "A"
MODEA:	BLOCK 1		;USAGE OF "A"
DPLA:	BLOCK 1		;DECIMAL PLACES IN "A"

BASEB:	BLOCK 1		;ADDR OF "B" OPERAND (RH)
RESB==BASEB		;BYTE RESIDUE FOR "B" (LH)
INCRB:	BLOCK 1		;OFFSET FOR "B"
SIZEB:	BLOCK 1		;SIZE OF "B"
MODEB:	BLOCK 1		;USAGE OF "B"
DPLB:	BLOCK 1		;DECIMAL PLACES IN "B"

BASEX==0		;OFFSET OF BASE
RESX==0			;OFFSET OF RESIDUE
INCRX==1		;OFFSET OF OFFSET
SIZEX==2		;OFFSET OF SIZE
MODEX==3		;OFFSET OF USAGE
DPLX==4			;OFFSET OF DECIMAL PLACES

SAVEA:	BLOCK DPLX+1	;PLACE TO SAVE "A" PARAMETERS
SAVEB:	BLOCK DPLX+1	;PLACE TO SAVE "B" PARAMETERS
SAVMA:	BLOCK 2*DPLX+2	;PLACE TO SAVE PARAMETERS DURING MOVES
SAVMB=SAVMA+DPLX+1

SAVAX==SAVEA+DPLX
SAVBX==SAVEB+DPLX
BASAX==BASEA+DPLX
BASBX==BASEB+DPLX
SVMAX==SAVMA+DPLX
SVMBX==SAVMB+DPLX

;BREAK POINT IMPURE AREA

BCOM2:	BLOCK 1		;USED INDIRECT FOR PROCEED CNTR
BCOM3:	BLOCK 1		;USED INDIRECT FOR SECTION NAME
LEAV1:	XWD Z,LEAV	;USED JRST @ TO DISMISS
LEAV:	Z		;HOLDS USER OR OTHER DISMISS INSTR
	JRST	@BCOM	;IF INSTR HOPS
	AOS	BCOM	;IF INSTR SKIPS
	JRST	@BCOM

CUR.BP:	BLOCK 1		;HOLDS CURRENT BP (0 IF VIRGIN)
LAST.:	BLOCK 1		;HOLDS LAST DATA ITEM IN ACCEPT ETC.
SAVSUB:	BLOCK 4		;HOLDS SUBSCRIPT INFO AS ABOVE

DEFINE BP (D) <
IRP (D),<
BP'D:	Z		; JSR ENTRY FOR BREAKPOINT D
	JSA TA,BCOM	; INVOKE BP LOGIC
B'D'INS:	Z		; ORIGINAL INSTR AT BP D
>>

DEFINE BA (D) <
IRP (D),<
B'D'ADR:	Z	; PNTR TOP PROTAB FOR BP'D
B'D'SEC:	Z	; SECTION NAME PNTR FOR BP'D
B'D'CNT:	Z	; PROCEED COUNT FOR BP'D
>>

;BREAK POIN CONSTANTS

LBP==3
LBA==3
NBP==^D20

BP (<1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20>)
BPN==.-LBP	;ADDR OF LAST BP ENTRY
PAGE
BA (<1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20>)
BNADR==.-LBA

;CODE GENERATION IMPURE AREAS

TEMPC:	BLOCK 1			;OFFSET IN TEMP
	CODFST==.		;FIRST LOC TO CLEAR
TEMROL:				;TEMP STORAGE

CBDDT.:	;START ADDR OF COBDDT, FOR USER PROGRAM

INIT.:	;;; ONCE-ONLY INITIALIZATION

	SKIPN	@%NM
	JRST	INIT.8

	MOVEM	16,PROGST	;SAVE ADDR OF BEGINNING OF USER PROG
	HRRZ	TB,-4(16)	;SAVE ADDR OF RESET.
	MOVEM	TB,CBLIO.
	HRRZ	TA,-3(16)	;GET ADDR OF MAIN PROGRAM

	MOVEI	NM,NMTAB	;INIT PTR TO NMTAB
	PUSHJ	PP,SETNMS	;SET UP TABLE OF NM'S

	%GETNM	%NM		;GET ADDRESSES OF %NM., %DT., %PR.

	MOVEM	PP,PDL.
	SETZM	LAST.
	SETZM	CUR.BP
	SETZM	DIED.
	SETZM	L.SECT
	SETZM	PTFLG.
	MOVE	TA,INIT.9
	SETZM	B1ADR
	BLT	TA,BNADR+LBA-1
	TTCALL	3,STRTUP
	MOVEI	TA,[	SETOM	DIED.
			TTCALL	3,STRTUP
			JRST	MLUP.]
	HRRM	TA,.JBSA
	JRST	MLUP.

INIT.8:	TTCALL	3,[ASCIZ "?NO SYMBOL TABLE - CANNOT USE COBDDT!"]
	CALLI	12

INIT.9:	XWD	B1ADR,B1ADR+1
;SET UP TABLE OF PTRS TO %NM'S OF ALL LOADED PROGRAMS

SETNMS:	MOVE	TC,TA		;GET ADDR OF NAME OF PROGRAM
	MOVE	TD,[PUSHJ 17,TRACE.]
	CAME	TD,(TC)
	AOJA	TC,.-1
	ADDI	TC,2
	MOVE	TA,1(TA)	;GET ADDR OF [SUBLST,,%FILES]
	HLRZ	TB,TA		;GET ADDR OF CALLED PROGS LIST
	MOVEI	TA,FIXNUM-3(TA)	;AIM AT %NM
	SKIPGE	(TA)		;THIS %NM BEEN SEEN BEFORE?
	POPJ	PP,		;YES
	HRRZM	TA,(NM)		;NO, PUT ITS ADDR IN NMTAB
	HRLM	TC,(NM)		;ALSO STORE ADDR OF PROGRAM NAME
	CAIGE	NM,NMTAB+^D100	;OVERWRITE LAST IF MORE THAN 100
	AOJ	NM,		;BUMP NM PTR
	HRROS	(TA)		;-1 TO LEFT HALF OF THAT %NM
SETNM1:	SKIPN	TA,(TB)		;THIS PROGRAM CALL ANYONE?
	POPJ	PP,		;NO
	PUSH	PP,TB		;YES, SAVE PTR TO CURRENT SUBPRGM LIST
	PUSHJ	PP,SETNMS	;DO CALLED PROGRAM IN THE SAME WAY
	POP	PP,TB		;BACK TO HIGHER PROGRAM
	SKIPE	1(TB)		;ANY MORE SUBPROGRAMS CALLED?
	AOJA	TB,SETNM1	;YES, KEEP GOING
	POPJ	PP,

IFL <N.TMP-.+TEMROL>,<PRINTX DRYROT!!!>
IFGE <N.TMP-.+TEMROL>,<BLOCK <N.TMP-.+TEMROL>>

CODROL:	BLOCK N.COD		;CODE ROLL
LITROL:	BLOCK N.LIT		;LITERAL POOL
	CODLST==.-1		;LAST LOC TO CLEAR

AC0:	BLOCK	20
PDL.:	BLOCK	1		;PUSH DOWN POINTER
DIED.:	BLOCK	1		;FLAG FOR EX DEATH
L.PARA:	BLOCK	1		;PLACE TO SAVE LAST PARA
L.SECT:	BLOCK	1		;PLACE TO SAVE LAST SECTION

NMTAB:	BLOCK	^D100		;ADDR'S OF %NM'S OF ALL LOADED COBOL PROGS

;THE FOLLOWING THREE ITEMS CONTAIN THE ADDRESSES OF %NM., %DT., %PR.
;  IN THAT ORDER

%NM:	BLOCK 1		;ADDR OF %NM.
%DT:	BLOCK 1		;ADDR OF %DT.
%PR:	BLOCK 1		;ADDR OF %PR.

OPDEF	%GETNM [5B8+16B12]

FIXNUM==^D16	;THIS MUST MATCH FIXNUM IN COBOLG & LIBIMP

	END
   ~ }R