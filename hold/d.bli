MODULE NGRID (STACK,MLIST) =
BEGIN
GLOBAL KATRA[300];
EXTERNAL  MHBGEN, MLBGEN, MPBGEN, ENDCODE, SDMBGEN;
EXTERNAL  CLEAR, RELOC, CHECKLAB;
EXTERNAL  REQUESTMEM,INITALLOC,RELEASEMEM;
OWN PTRNO, OLDRJMP;
OWN VCDIR[200];
OWN  SDMB;
STRUCTURE  MHBTYPE [I,J] =
	CASE .I OF SET
		(.MHBTYPE)<0,18>;		!BASEMHB
		(@.MHBTYPE)<0,36>;		!NAMEMHB
		(@.MHBTYPE+1)<18,18>;		!TYPEMHB
		(@.MHBTYPE+1)<0,18>;		!PTRSMHB
		(@.MHBTYPE+2)<0,36>;		!CONTROLMHB
		(@.MHBTYPE+3)<18,18>;		!MPDMHB
		(@.MHBTYPE+3)<0,18>;		!DMBMHB
		IF .J THEN (@.MHBTYPE+4+.J/2)<0,18>  !GET J-TH POINTER
		      ELSE (@.MHBTYPE+4+.J/2)<18,18> !POINTMHB,#
	TES;
MACRO
	BASEMHB		=   0,0	$,
	NAMEMHB		=   1,0	$,
	TYPEMHB		=   2,0	$,
	PTRSMHB		=   3,0	$,
	CONTROLMHB	=   4,0	$,
	MPDMHB		=   5,0	$,
	DMBMHB		=   6,0	$,
	POINTMHB	=   7	$;


STRUCTURE  MLBTYPE [I] =
	CASE .I OF SET
		(.MLBTYPE)<0,18>;		!BASEMLB
		(@.MLBTYPE)<18,18>;		!MPBMLB
		(@.MLBTYPE)<0,18>;		!NEXTMLB
		(@.MLBTYPE+1)<18,18>;		!TYPEMLB
		(@.MLBTYPE+1)<0,18>;		!VALUEMLB
		(@.MLBTYPE+2)<0,36>		!CONTROLMLB
	TES;
MACRO
	BASEMLB		=   0	$,
	MPBMLB		=   1	$,
	NEXTMLB		=   2	$,
	TYPEMLB		=   3	$,
	VALUEMLB	=   4	$,
	CONTROLMLB	=   5	$;


STRUCTURE  MPBTYPE [I,J] =
	CASE .I OF SET
		(.MPBTYPE)<0,18>;		!BASEMPB
		IF .J	THEN (@.MPBTYPE+.J/2)<0,18>   !POINTMPB,#
			ELSE (@.MPBTYPE+.J/2)<18,18>;
		(@.MPBTYPE+(.J+1)/2)<0,36>	!CONTROLMPB
	TES;
MACRO
	BASEMPB		=   0	$,
	POINTMPB	=   1	$,
	CONTROLMPB	= 2,.MHB[PTRSMHB] $;



STRUCTURE  SDMBTYPE [I] =
	CASE .I OF SET
		(.SDMBTYPE)<0,18>;		!BASESDMB
		(@.SDMBTYPE)<18,18>;		!BACKPTRSDMB
		(@.SDMBTYPE)<0,18>;		!FORWDPTRSDMB
		(@.SDMBTYPE+1)<18,18>;		!STARTSDMB
		(@.SDMBTYPE+1)<0,18>;		!LEAVESDMB
		(@.SDMBTYPE+2)<18,18>;		!SIZESDMB
		(@.SDMBTYPE+3)<0,36>		!CODESDMB
	TES;
BIND  HEADERSDMB = 3;
MACRO
	BASESDMB	=   0	$,
	BACKPTRSDMB	=   1	$,
	FORWDPTRSDMB	=   2	$,
	STARTSDMB	=   3	$,
	LEAVESDMB	=   4	$,
	SIZESDMB	=   5	$,
	CODESDMB	=   6	$;


STRUCTURE  DMBTYPE [I] =
	CASE .I OF SET
		(.DMBTYPE)<0,18>;		!BASEDMB
		(@.DMBTYPE)<18,18>;		!BACKPTRDMB
		(@.DMBTYPE)<0,18>;		!FORWDPTRDMB
		(@.DMBTYPE+1)<18,18>;		!STARTDLB
		(@.DMBTYPE+1)<0,18>;		!LEAVEDMB
		(@.DMBTYPE+2)<18,18>;		!SIZEDMB
		(@.DMBTYPE+2)<0,18>;		!DLBDMB
		(@.DMBTYPE+3)<18,18>;		!MHBDMB
		(@.DMBTYPE+4)<0,36>		!CODEDMB
	TES;

BIND  HEADERDMB = 4;
MACRO
	BASEDMB		=   0	$,
	BACKPTRDMB	=   1	$,
	FORWDPTRDMB	=   2	$,
	STARTDMB	=   3	$,
	LEAVEDMB	=   4	$,
	SIZEDMB		=   5	$,
	DLBDMB		=   6	$,
	MHBDMB		=   7	$,
	CODEDMB		=   8	$;



STRUCTURE  DLBTYPE [I] =
	CASE .I OF SET
		(.DLBTYPE)<0,18>;		!BASEDLB
		(@.DLBTYPE)<18,18>;		!BACKPTRDLB
		(@.DLBTYPE)<0,18>;		!FORWDPTRDLB
		(@.DLBTYPE+1)<18,18>;		!STARTDLB
		(@.DLBTYPE+1)<0,18>;		!LEAVEDLB
		(@.DLBTYPE+2)<18,18>;		!SIZEDLB
		(@.DLBTYPE+2)<0,18>		!MLBDLB
	TES;

BIND  HEADERDLB = 3;
MACRO
	BASEDLB		=   0	$,
	BACKPTRDLB	=   1	$,
	FORWDPTRDLB	=   2	$,
	STARTDLB	=   3	$,
	LEAVEDLB	=   4	$,
	SIZEDLB		=   5	$,
	MLBDLB		=   6	$;
BIND	TERMINAL  =  #777777;
MAP SDMBTYPE SDMB;
OWN TABLE[2];
OWN  VIEWPORT[2], WINDOW[2], KMAX, KMIN, KSTEP, LMAX, LMIN, LSTEP;
OWN PASTEND, TEXTBYTE, FIRSTBYTE, LASTCHAR, SCOPE[2], WAITIN, OFF[2], MHB;
OWN INBUF[20], OUTBUF[20],QJOHN[3];
OWN MLBCONTROLWORD;
MACRO	RESETTEXTBYTE = TEXTBYTE_(INBUF-1)<1,7>$;
MACRO
	INITIALIZE(A,LEN,VAL) =
		(MACHOP BLT = #251;
		 REGISTER RQQ987;
		 A[0]_VAL;
		 LEFT(RQQ987)_A[0];
		 RIGHT(RQQ987)_A[1];
		 BLT(RQQ987,A[LEN-1])
		)$;
MACRO
	RIGHT(A)  =  (A)<0,18,0,0>  $,
	LEFT(A)   =  (A)<18,18,0,0> $;
MACRO
	HITMLB(A) = (A)<33,1>$,
	DISPLAYMLB(A) = (A)<35,1>$,
	ENDMLB(A) = (A)<34,1>$,
	MPBCONTMLB(A) = (A)<18,1>$;
BIND	BUFLENGTH  =  100;
OWN  DMB,  BUFFER[BUFLENGTH];
OWN OLDDLB;
GLOBAL ROUTINE OUTMSG (TEXT) =
BEGIN
MACHOP TTCALL = #051;
	TTCALL(3,TEXT,,1)
END;
OWN  LDSSTART;
ROUTINE SETSDMB =
	BEGIN
	MAP SDMBTYPE SDMB;
	REGISTER  SIZE, R;
	MACHOP  BLT = #251;
   !PUT GENERATED CODE IN BUFFER
	SDMB[BASESDMB]_BUFFER<0,0>;
	CLEAR();
	SIZE_HEADERSDMB +
	     SDMBGEN(SDMB[CODESDMB]<0,0>,BUFFER<0,0>+BUFLENGTH-1,SDMB[STARTSDMB]<0,0>);
   !GET SPACE FOR SDMB & COPY
	SDMB[BASESDMB]_REQUESTMEM(.SIZE);
	IF .SDMB[BASESDMB] EQL -1 THEN RETURN -1;
	RELOC(BUFFER<0,0>,.SDMB[BASESDMB]);
	CHECKLAB();
	LEFT(R)_BUFFER<0,0>;
	RIGHT(R)_.SDMB[BASESDMB];
	BLT(R,.SDMB[BASESDMB]-1,SIZE,1);
   !INITIALIZE DISPLAY LIST PTR'S
	SDMB[BACKPTRSDMB]_.SDMB[BASESDMB];
	SDMB[FORWDPTRSDMB]_.SDMB[BASESDMB];
   !RELOCATE THE START AND EXIT ADDRESSES, SET LDS-START..
	SDMB[STARTSDMB]_.SDMB[STARTSDMB]-BUFFER<0,0>+.SDMB[BASESDMB];
	LDSSTART_.SDMB[STARTSDMB];
	SDMB[LEAVESDMB]_.SDMB[LEAVESDMB]-BUFFER<0,0>+.SDMB[BASESDMB];
   !SET SIZE OF SDMB
	SDMB[SIZESDMB]_.SIZE;
	RETURN .SDMB[BASESDMB]
	END;
ROUTINE GEN (KMIN,KMAX,KSTEP,LMIN,LMAX,LSTEP) =
BEGIN
REGISTER I;
LOCAL MHB, MLB,  MPB, MLBK, MLBL, KK, LL, OLDMPB, TEMPMPB;
MAP MHBTYPE  MHB;
MAP MLBTYPE  MLB: MLBK: MLBL;
MAP MPBTYPE  MPB: OLDMPB;
BIND B = REQUESTMEM(5+(((.KMAX-.KMIN)/.KSTEP+1)+((.LMAX-.LMIN)/.LSTEP+1))*3
	+((.KMAX-.KMIN)/.KSTEP+1)*((.LMAX-.LMIN)/.LSTEP+1)*3);
MACRO	DISPMPB(A) = (A)<35,1>$;


MHB[BASEMHB]_B[0]<0,0>;
MHB[NAMEMHB]_'MESH';
MHB[TYPEMHB]_"MH";
MHB[PTRSMHB]_2;
MHB[CONTROLMHB]_#52605;
KK_.KMIN;
LL_.LMIN;
INCR II FROM 5 TO ((.KMAX-.KMIN)/.KSTEP+1)*3+4 BY 3 DO
	(I_.II;
	 IF .II EQL 5 THEN MHB[POINTMHB,0]_B[.II]<0,0>
		      ELSE MLBK[NEXTMLB]_B[.II]<0,0>;
	 MLBK[BASEMLB]_B[.II]<0,0>;
	 MLBK[CONTROLMLB]_0;
	 DISPLAYMLB(MLBK[CONTROLMLB])_1;
	 RIGHT(MLBK[CONTROLMLB])_.KK^9 OR .KK;
	 MPBCONTMLB(MLBK[CONTROLMLB])_1;
	 MLBK[TYPEMLB]_"K";
	 MLBK[VALUEMLB]_.KK;	KK_.KK+1;
	);					!END INCR
MLBK[NEXTMLB]_.MHB[BASEMHB];
(REGISTER ITEMP;
I_.I+3;
ITEMP_.I;
INCR II FROM .I TO ((.LMAX-.LMIN)/.LSTEP+1)*3+.I-1 BY 3 DO
	(I_.II;
	 IF .II EQL .ITEMP THEN MHB[POINTMHB,1]_B[.II]<0,0>
		      ELSE MLBL[NEXTMLB]_B[.II]<0,0>;
	 MLBL[BASEMLB]_B[.II]<0,0>;
	 MLBL[CONTROLMLB]_0;
	 DISPLAYMLB(MLBL[CONTROLMLB])_1;
	 RIGHT(MLBL[CONTROLMLB])_(.KMAX+.LL)^9 OR (.KMAX+.LL);
	 MPBCONTMLB(MLBL[CONTROLMLB])_1;
	 MLBL[TYPEMLB]_"L";
	 MLBL[VALUEMLB]_.LL;	LL_.LL+1
	);					!END INCR
);			!END REGISTER ITEMP
MLBL[NEXTMLB]_.MHB[BASEMHB];
I_.I+3;


MLB[BASEMLB]_.MHB[POINTMHB,0];
OLDMPB[BASEMPB]_TEMPMPB<0,0>;
INCR KK FROM .KMIN TO .KMAX BY .KSTEP DO
	(INCR LL FROM .LMIN TO .LMAX BY .LSTEP DO
		(OLDMPB[POINTMPB,0]_B[.I]<0,0>;
		 B[.I+1]_0;
		 RIGHT(B[.I+1])_.KK^9 OR .KK;
		 DISPMPB(B[.I+1])_1;
		 LEFT(B[.I+2])_.KK;
		 RIGHT(B[.I+2])_.LL;
		 OLDMPB[BASEMPB]_B[.I]<0,0>;
		 I_.I+3
		);
	 OLDMPB[POINTMPB,0]_.MLB[BASEMLB];
	 OLDMPB[BASEMPB]_TEMPMPB<0,0>;
	 MLB[MPBMLB]_.OLDMPB[POINTMPB,0];
	 MLB[BASEMLB]_.MLB[NEXTMLB]
	);
MLBL[BASEMLB]_.MHB[POINTMHB,1];
INCR LL FROM 1 TO (.LMAX-.LMIN)/.LSTEP+1 DO
	(MLBK[BASEMLB]_.MHB[POINTMHB,0];
	 INCR KK FROM .KMIN TO .KMAX BY .KSTEP DO
		(INCR T FROM 1 TO .LL DO
			MPB[BASEMPB]_IF .T EQL 1
					THEN .MLBK[MPBMLB]
					ELSE .MPB[POINTMPB,0];
		 MLBK[BASEMLB]_.MLBK[NEXTMLB];
		 IF .KK EQL .KMIN
			THEN MLBL[MPBMLB]_.MPB[BASEMPB]
			ELSE OLDMPB[POINTMPB,1]_.MPB[BASEMPB];
		 OLDMPB[BASEMPB]_.MPB[BASEMPB]
		);
	 OLDMPB[POINTMPB,1]_.MLBL[BASEMLB];
	 MLBL[BASEMLB]_.MLBL[NEXTMLB]
	);
RETURN  .MHB[BASEMHB]
END;
FORWARD  CREATDLB;
GLOBAL ROUTINE DISPL (MHB,PTRTABLE,OFFSET,VIEWPORT) =
BEGIN
MACRO  NEXTPTR(A)  =  SCANI(A)$;
LOCAL DLBTYPE  TEMP;
LOCAL  TEMPDLB[HEADERDLB];
LOCAL  JMPADDR, BYTE;
OWN  MLB;
MAP	SDMBTYPE  SDMB,
	DMBTYPE  DMB,
	MHBTYPE  MHB,
	DLBTYPE  BUFFER,
	MLBTYPE  MLB;
REGISTER  R, SIZE;
MACHOP BLT = #251;


	DMB[BASEDMB]_BUFFER<0,0>;
	CLEAR();
	SIZE_HEADERDMB+
	     MHBGEN(.MHB[CONTROLMHB],.VIEWPORT,DMB[CODEDMB],BUFFER<0,0>+BUFLENGTH-1,0,VCDIR-1,DMB[STARTDMB]<0,0>);
	DMB[BASEDMB]_REQUESTMEM(.SIZE);
	IF .DMB[BASEDMB] LEQ 0 THEN RETURN -1;
	RELOC(BUFFER<0,0>,.DMB[BASEDMB]);
	CHECKLAB();
	LEFT(R)_BUFFER<0,0>;
	RIGHT(R)_.DMB[BASEDMB];
	BLT(R,.DMB[BASEDMB]-1,SIZE,1);
	DMB[SIZEDMB]_.SIZE;
	DMB[STARTDMB]_.DMB[STARTDMB]-BUFFER<0,0>+.DMB[BASEDMB];
	DMB[LEAVEDMB]_.DMB[LEAVEDMB]-BUFFER<0,0>+.DMB[BASEDMB];
	TEMP[BASEDLB]_TEMPDLB<0,0>;
	JMPADDR_.DMB[LEAVEDMB];
	DMB[MHBDMB]_.MHB[BASEMHB];
	MHB[DMBMHB]_.DMB[BASEDMB];
	OLDRJMP_.DMB[BASEDMB]+.DMB[SIZEDMB]-1;
	BYTE_(@PTRTABLE-1)<0,18,0,0>;
	OLDDLB_TEMPDLB<0,0>;

	WHILE(PTRNO_NEXTPTR(BYTE)) NEQ TERMINAL DO
		(
		 MLB[BASEMLB]_.MHB[POINTMHB,.PTRNO];
		 WHILE .MLB[BASEMLB] NEQ .MHB[BASEMHB] DO
			(
			 IF .ENDMLB(MLB[CONTROLMLB]) THEN EXITLOOP;
			 IF .DISPLAYMLB(MLB[CONTROLMLB]) THEN  CREATDLB(.MLB[BASEMLB],.OFFSET,.MHB);
			 MLB[BASEMLB]_.MLB[NEXTMLB]
			)
		);
	RIGHT(.OLDRJMP)_.JMPADDR;
	DMB[DLBDMB]_.TEMP[FORWDPTRDLB];
	TEMP[BASEDLB]_.TEMP[FORWDPTRDLB];
	TEMP[BACKPTRDLB]_.DMB[BASEDMB];
	(MAP DLBTYPE OLDDLB;
	 OLDDLB[FORWDPTRDLB]_.DMB[BASEDMB]
	);
	RETURN .DMB[BASEDMB]
END;
ROUTINE CREATDLB (MLB,OFFSET,MHB) =
BEGIN
MACRO
	DISPLAY(A) 	=  (A)<35,1>$,
	ENDPOINT(A)	=  (A)<34,1>$,
	MPBCONTROL(A)	=  (A)<18,1>$,
	FOREVER		=  WHILE  1 $,
	POSITION(A)	=  .(A)<30,6>$;
BIND  BUFERROR = PLIT ASCIZ '?M?J?J?J***BUFFER OVERFLOW IN CREATION OF DLB***
?M?J?J?J?W';
BIND RJMPERROR = PLIT ASCIZ '?M?J?J?J***TOO MANY CHANGES IN ONE LINE,
RJMPVECT OVERFLOW***?M?J?J?J?W';
MAP  MHBTYPE  MHB;
MAP  MLBTYPE  MLB;
OWN DLBTYPE DLBTEMP;
REGISTER  MPBTYPE  MPB;
MACHOP  BLT = #251;
REGISTER CONTROLWORD;
OWN  NEWCONTROL, DEFAULTCONTROL, CLEANUP;
OWN DLBTYPE DLB;
OWN  FLAG, SIZE, OLDSIZE, RJMPCOUNT, POLILOC, RJMPLOC;
BIND  RJMPVSIZE  =  5;
OWN  RJMPVECT[RJMPVSIZE];
BIND	DMASK = #777400 ^ 18 OR #777777,
	MLBMASK = #777776 ^ 18 OR #777777;
MACRO	UPDATEPOLIAA =
			IF POSITION(ENTRY) NEQ 0
				THEN RIGHT(.ENTRY) _.LEFT(.ENTRY);
			SIZE _.SIZE + (NOOFPTS _(.NOOFPTS + 1) / 2);
			RIGHT(.POLILOC) _-.NOOFPTS $;
MACRO	ZEROD(A) = (A)<18,1>$,
	ONED(A) = (A)<19,1>$,
	TWOD(A) = (A)<20,1>$,
	THREED(A) = (A)<21,1>$,
	ZEROD1(A) = (A)<22,1>$,
	ONED1(A) = (A)<23,1>$,
	TWOD1(A) = (A)<24,1>$,
	THREED1(A) = (A)<25,1>$,
	UPDATECONTROL(A) =
		(REGISTER BIT;
		BIT_.MPB[CONTROLMPB];
		IF  CASE .PTRNO OF
			SET
				.ZEROD(BIT);
				.ONED(BIT);
				.TWOD(BIT);
				.THREED(BIT);
			TES
		  THEN	(NEWCONTROL_.BIT AND DMASK;  A)
		  ELSE	(IF CASE .PTRNO OF
			   SET
				.ZEROD1(BIT);
				.ONED1(BIT);
				.TWOD1(BIT);
				.THREED1(BIT)
			   TES
			  THEN	NEWCONTROL_.DEFAULTCONTROL
			  ELSE	NEWCONTROL_.CONTROLWORD;
			 1
			)	)	$;
MACRO  CHECKCONTROLWORD  =
	  IF .CONTROLWORD NEQ -1
		THEN  (UNTIL  (UPDATECONTROL(
				       IF .ENDPOINT(NEWCONTROL) THEN (UPDATEPOLIAA; EXITLOOP [2]);
					.DISPLAY(NEWCONTROL))
				)
			  DO
				IF (MPB[BASEMPB]_.MPB[POINTMPB,.PTRNO]) EQL .MLB[BASEMLB]
					THEN  EXITLOOP [2];
			IF  .CONTROLWORD NEQ .NEWCONTROL
			  THEN (FLAG_1;
				CONTROLWORD_.NEWCONTROL;
				NOOFPTS_.NOOFPTS+1;
				REPLACEI(ENTRY,.MPB[BASEMPB]+.OFFSET);
				OLDSIZE_.SIZE+(.NOOFPTS+1)/2;
				IF .CLEANUP THEN
				  SIZE_.SIZE+ENDCODE(BUFFER[.SIZE+(.NOOFPTS+1)/2]<0,0>,
						BUFFER[BUFLENGTH-1]<0,0>);
				SIZE_.SIZE+MPBGEN(.CONTROLWORD,BUFFER[.SIZE+(.NOOFPTS+1)/2]<0,0>,
					BUFFER[BUFLENGTH-1]<0,0>,BUFFER<0,0>+1,CLEANUP,DLBTEMP[STARTDLB]<0,0>);
				EXITLOOP
			       )
		      )   $;

MACRO  CHECKFLAG  =
		IF .FLAG EQL 0
			THEN EXITLOOP
			ELSE (RIGHT(.RJMPLOC+BUFFER<0,0>) _.OLDSIZE;
			      IF (RJMPCOUNT _.RJMPCOUNT+1) LSS RJMPVSIZE
				THEN RJMPVECT[.RJMPCOUNT] _.RJMPLOC+BUFFER<0,0>
				ELSE (OUTMSG(RJMPERROR);
				      RETURN -2
				     )
			     )
		$;
	DLBTEMP[BASEDLB]_BUFFER<0,0>;
	MPB[BASEMPB] _.MLB[MPBMLB];
	SIZE_HEADERDLB;
	CONTROLWORD_.MLB[CONTROLMLB] AND MLBMASK;
	DEFAULTCONTROL_.CONTROLWORD;
	IF .MPBCONTROL(MLB[CONTROLMLB])
	   THEN (UNTIL (UPDATECONTROL(
				IF .ENDPOINT(NEWCONTROL) THEN RETURN 1;
				.DISPLAY(NEWCONTROL)
				)
		       ) DO
			IF (MPB[BASEMPB]_.MPB[POINTMPB,.PTRNO]) EQL .MLB[BASEMLB]
				THEN RETURN 1;
		 CONTROLWORD_.NEWCONTROL;
		)
	   ELSE CONTROLWORD_-1;
	RJMPCOUNT _-1;
	CLEANUP_0;
	CLEAR();
	SIZE_.SIZE+MLBGEN(.MLB[CONTROLMLB] AND MLBMASK,.CONTROLWORD AND DMASK,BUFFER[.SIZE]<0,0>,
		BUFFER[BUFLENGTH-1]<0,0>,DLBTEMP[MLBDLB]<0,0>,CLEANUP,DLBTEMP[STARTDLB]<0,0>);
	FOREVER DO
		(FLAG _0;
		POLILOC_BUFFER[.SIZE]<0,0> - 1;
		RJMPLOC _ .SIZE - 2;
		(REGISTER ENTRY, NOOFPTS;
			ENTRY _(.POLILOC)<0,18>;
			NOOFPTS _0;
			WHILE .MPB[BASEMPB] NEQ .MLB[BASEMLB] DO
				(CHECKCONTROLWORD;
				 NOOFPTS _.NOOFPTS + 1;
				 IF .SIZE + (.NOOFPTS + 1) / 2 GTR BUFLENGTH
					THEN (OUTMSG(BUFERROR);
					       RETURN -2
					      );
				 REPLACEI(ENTRY,.MPB[BASEMPB] + .OFFSET);
				 MPB[BASEMPB] _.MPB[POINTMPB,.PTRNO]
				);
			UPDATEPOLIAA;
		);	!RELEASE REGISTERS ENTRY, NOOFPTS
		CHECKFLAG
	);  !END FOREVER DO
	IF .SIZE EQL HEADERDLB THEN RETURN;
	DLB[BASEDLB] _REQUESTMEM(.SIZE);
	IF .DLB[BASEDLB] EQL -1 THEN RETURN -1;
	INCR I FROM 0 TO .RJMPCOUNT DO
		RIGHT(.RJMPVECT[.I]) _.RIGHT(.RJMPVECT[.I]) + .DLB[BASEDLB];
	RELOC(BUFFER<0,0>,.DLB[BASEDLB]);
	CHECKLAB();
	(REGISTER R;
		LEFT(R) _BUFFER[0]<0,0>;
		RIGHT(R) _.DLB[BASEDLB];
		BLT(R,.DLB[BASEDLB]+.SIZE-1)
	);
	RIGHT(.OLDRJMP) _.DLB[BASEDLB] + HEADERDLB;
	OLDRJMP _.RJMPLOC + .DLB[BASEDLB];
	DLB[BACKPTRDLB] _.OLDDLB;
	(MAP DLBTYPE OLDDLB;
		OLDDLB[FORWDPTRDLB] _.DLB[BASEDLB]
	);
	OLDDLB _.DLB[BASEDLB];
	DLB[SIZEDLB] _.SIZE;
	DLB[MLBDLB] _.MLB[BASEMLB];
	DLB[STARTDLB]_.DLB[STARTDLB]-BUFFER<0,0>+.DLB[BASEDLB];
	DLB[LEAVEDLB]_.DLB[LEAVEDLB]-BUFFER<0,0>+.DLB[BASEDLB];
	RETURN
END;
ROUTINE LINK (SDMB,DMB) =
	BEGIN
	REGISTER  SD, D;
	MAP SDMBTYPE SD;
	MAP DMBTYPE D;
	SD_.SDMB;
	D_.DMB;
   !LINK LIST PTR'S
	D[FORWDPTRDMB]_.SD[FORWDPTRSDMB];
	D[BACKPTRDMB]_.SD[BASESDMB];
	SD[FORWDPTRSDMB]_.D[BASEDMB];
	IF .SD[BACKPTRSDMB] EQL .SD[BASESDMB]
		THEN  SD[BACKPTRSDMB]_.D[BASEDMB];
   !LINK JMP'S
	RIGHT(.D[LEAVEDMB])_.RIGHT(.SD[LEAVESDMB]);
	RIGHT(.SD[LEAVESDMB])_.D[STARTDMB]
	END;
ROUTINE DELINK (DMB) =
	BEGIN
MACRO
	BASEG		=   0	$,
	BACKPTRG	=   1	$,
	FORWDPTRG	=   2	$,
	STARTG		=   3	$,
	LEAVEG		=   4	$,
	SIZEG		=   5	$;
	STRUCTURE GENERAL [I] =
		CASE  .I  OF
		   SET
			(.GENERAL)<0,18>;		!BASEG
			(@.GENERAL)<18,18>;		!BACKPTRG
			(@.GENERAL)<0,18>;		!FORWDPTRG
			(@.GENERAL+1)<18,18>;		!STARTG
			(@.GENERAL+1)<0,18>;		!LEAVEG
			(@.GENERAL+2)<18,18>		!SIZEG
		   TES;


	(REGISTER  GENERAL  RB : R : RF;
	 R[BASEG]_.DMB;
	 RB[BASEG]_.R[BACKPTRG];
	 RF[BASEG]_.R[FORWDPTRG];
   !PATCH BLOCK PTR'S
	 RB[FORWDPTRG]_.R[FORWDPTRG];
	 RF[BACKPTRG]_.R[BACKPTRG];
   !PATCH LDS JMP INSTRUCTION
	 RIGHT(.RB[LEAVEG])_.RIGHT(.R[LEAVEG])
	);
   %DMB IS NOW PATCHED OUT.  RELEASE SPACE FOR DLB'S THEN RELEASE SPACE FOR DMB%
	(REGISTER  TEMP, DMBTYPE RDMB, DLBTYPE RDLB;
	 RDMB[BASEDMB]_.DMB;
	 RDLB[BASEDLB]_.RDMB[DLBDMB];
	 WHILE  .RDLB[BASEDLB] NEQ .RDMB[BASEDMB]  DO
		(TEMP_.RDLB[FORWDPTRDLB];
		 RELEASEMEM(.RDLB[BASEDLB], .RDLB[SIZEDLB]);
		 RDLB[BASEDLB]_.TEMP
		);
	 RELEASEMEM(.RDMB[BASEDMB], .RDMB[SIZEDMB])
	);
	RETURN
	END;
ROUTINE UUO (A,B) =
	BEGIN
	BIND  BACKSPACE = PLIT ASCIZ '@';
	MACRO BPOS(A) = (A)<30,6>$;
	MACRO REFB = (-2)<0,36,FREG,1>$;
	MACHOP TTCALL = #051;
	LOCAL  TMPBUF, INBYTE;
	BIND	SLEEP = PLIT ASCIZ '?J?MSLEEP REQUEST?J?M',
		LDSS = PLIT ASCIZ '?J?MLDS REQUEST?J?M',
		EXITT =PLIT ASCIZ '?J?MEXIT REQUEST?J?M';
	IF .A EQL 0 THEN OUTMSG(SLEEP)
	ELSE IF .A EQL 5 THEN OUTMSG(LDSS)
	ELSE IF .A EQL 4 THEN (MACHOP CALLI = #047; OUTMSG(EXITT); CALLI(0,#12));
	QJOHN[1]_.REFB;
	INBYTE_(INBUF-1)<1,7>;
	DO
		(TTCALL(0,TMPBUF);
		 IF .TMPBUF EQL #177
		   THEN	(OUTMSG(BACKSPACE);
			 IF .BPOS(INBYTE) NEQ 29
				THEN  BPOS(INBYTE)_.BPOS(INBYTE)+7
				ELSE (BPOS(INBYTE)_1;
				      RIGHT(INBYTE)_.RIGHT(INBYTE)-1
				     )
			)
		    ELSE  REPLACEI(INBYTE,.TMPBUF)
		)
	WHILE .TMPBUF NEQ #12;
	QJOHN[0]_1^34
	END;
ROUTINE NUM (BASE) =
	BEGIN
	REGISTER R1,UPPER,FLAG;
	BIND	SPACE = #40,
		ZERO = #60,
		MINUS = #55,
		EOT = #27;
	WHILE (R1_SCANI(TEXTBYTE)) EQL SPACE DO;
	UPPER_ZERO + .BASE - 1;
	FLAG_0;
	IF .R1 EQL MINUS
		THEN (FLAG_1;
		      R1_SCANI(TEXTBYTE)
		     );
	VREG_0;
	UNTIL .R1 LSS ZERO OR .R1 GTR .UPPER OR .R1 EQL EOT OR (.TEXTBYTE)<0,0> EQL .PASTEND DO
		(VREG_.VREG*.BASE+.R1-ZERO;
		 R1_SCANI(TEXTBYTE);
		);
	LASTCHAR_.R1;
	IF .FLAG THEN VREG_-.VREG;
	RETURN .VREG
	END;
ROUTINE DOREAD =
	BEGIN
	REGISTER R1,BASE,VAL;
	LOCAL  L1, L2;
	LOCAL CHAR;
	BIND SPACE = #40;
	MACRO 	NEXT(A) = UNTIL (A_SCANI(TEXTBYTE)) NEQ SPACE DO$,
		GETBASE = IF (BASE_SCANI(TEXTBYTE)) EQL "O" OR .BASE EQL "o"
				 THEN 8 ELSE 10$,
		UPDATE(A) =
			(BASE_GETBASE;
			 NEXT(CHAR);
			 L1_NUM(.BASE);
			 IF .LASTCHAR EQL ","
				THEN L2_NUM(.BASE)
				ELSE L2_.L1;
			 VAL_NUM(8);
			 IF .CHAR EQL "K" OR .CHAR EQL "k"
				THEN (L1_(.L1-.KMIN)/.KSTEP;
				      L2_(.L2-.KMIN)/.KSTEP
				     )
				ELSE (L1_(.L1-.LMIN)/.LSTEP+(.KMAX-.KMIN)/.KSTEP+1;
				       L2_(.L2-.LMIN)/.LSTEP+(.KMAX-.KMIN)/.KSTEP+1
				     );
			 INCR I FROM .L1 TO .L2 DO
				IF A THEN LEFT(VCDIR[.I])_.VAL
					ELSE RIGHT(VCDIR[.I])_.VAL^6
			)$;
	BIND	NOGO = PLIT ASCIZ '?J?MTHAT BLEW MY MIND?J?M?W';
	%I%
	IF (R1_SCANI(TEXTBYTE)) EQL "I" OR .R1 EQL "i"
		THEN UPDATE(0)
	ELSE
	%C%
	IF .R1 EQL "C" OR .R1 EQL "c"
		THEN UPDATE(1)
	ELSE
	%K%
	IF .R1 EQL "K" OR .R1 EQL "k"
		THEN	(BASE_GETBASE;
			 KMIN_NUM(.BASE); KMAX_NUM(.BASE); KSTEP_NUM(.BASE);
			 LMIN_NUM(.BASE); LMAX_NUM(.BASE); LSTEP_NUM(.BASE);
			 RESETTEXTBYTE;
			 RETURN 1
			)
	ELSE
	%W%
	IF .R1 EQL "W" OR .R1 EQL "w"
		THEN	(BASE_GETBASE;
			 LEFT(WINDOW[0])_NUM(.BASE); RIGHT(WINDOW[0])_NUM(.BASE);
			 LEFT(WINDOW[1])_NUM(.BASE); RIGHT(WINDOW[1])_NUM(.BASE)
			)
	ELSE
	%V%
	IF .R1 EQL "V" OR .R1 EQL "v"
		THEN	(BASE_GETBASE;
			 LEFT(VIEWPORT[0])_NUM(.BASE); RIGHT(VIEWPORT[0])_NUM(.BASE);
			 LEFT(VIEWPORT[1])_NUM(.BASE); RIGHT(VIEWPORT[1])_NUM(.BASE)
			)
	ELSE
	%D%
	IF .R1 EQL "D" OR .R1 EQL "d"
		THEN	(MAP SDMBTYPE L1;
			 MAP DMBTYPE L2;
			 L1[BASESDMB]_.SDMB;
			 L2[BASEDMB]_.L1[FORWDPTRSDMB];
			 RIGHT(L2[CODEDMB])_NUM(8)
			)
	ELSE
	%E%
	IF .R1 EQL "E" OR .R1 EQL "e"
		THEN 	(
			 UUO(4,0)
			)
	ELSE
	%G%
	IF .R1 EQL "G" OR .R1 EQL "g"
		THEN	RETURN 3
	ELSE
	%L%
	IF .R1 EQL "L" OR .R1 EQL "l"
		THEN	_GETBASE;
			 NEXT(CHAR);
			 L1_NUM(.BASE);
			 IF .LASTCHAR EQL ","
				THEN  L2_NUM(.BASE)
				ELSE  L2_.L1;
			 LEFT(VAL)_NUM(8);
			 IF .LASTCHAR EQL ","
				THEN  RIGHT(VAL)_NUM(8)
				ELSE  VAL_.LEFT(VAL);
			 (REGISTER  MLB;
			  MAP MHBTYPE MHB;
			  MAP MLBTYPE MLB;
			  MLB[BASEMLB]_IF .CHAR EQL "K" OR .CHAR EQL "k"
					THEN .MHB[POINTMHB,0]
					ELSE .MHB[POINTMHB,1];
			  WHILE  .MLB[BASEMLB] NEQ .MHB[BASEMHB]  DO
				(IF .L1 LEQ .MLB[VALUEMLB] AND .L2 GEQ .MLB[VALUEMLB]
					THEN  MLB[CONTROLMLB]_.VAL;
				 MLB[BASEMLB]_.MLB[NEXTMLB]
				)
			 )
			)
	ELSE
	%P%
	IF .R1 EQL "P" OR .R1 EQL "p"
		THEN	(LOCAL  K1, K2;
			 BASE_GETBASE;
			 K1_NUM(.BASE);
			 IF .LASTCHAR EQL ","
				THEN  K2_NUM(.BASE)
				ELSE  K2_.K1;
			 L1_NUM(.BASE);
			 IF .LASTCHAR EQL ","
				THEN   L2_NUM(.BASE)
				ELSE  L2_.L1;
			 LEFT(VAL)_NUM(8);
			 IF .LASTCHAR EQL ","
				THEN  RIGHT(VAL)_NUM(8)
				ELSE  VAL_.LEFT(VAL);
			 (REGISTER MPB, MLB;
			  MAP MHBTYPE MHB;
			  MAP MLBTYPE MLB;
			  MAP MPBTYPE MPB;
			  MLB[BASEMLB]_.MHB[POINTMHB,0];
			  WHILE .MLB[BASEMLB] NEQ .MHB[BASEMHB] DO
				(IF .MLB[VALUEMLB] GEQ .K1 AND .MLB[VALUEMLB] LEQ .K2
					THEN (MPB[BASEMPB]_.MLB[MPBMLB];
					      WHILE .MPB[BASEMPB] NEQ .MLB[BASEMLB] DO
						(IF .RIGHT(.MPB[BASEMPB]+2) GEQ .L1 AND
							.RIGHT(.MPB[BASEMPB]+2) LEQ .L2
							THEN  MPB[CONTROLMPB]_.VAL;
						 MPB[BASEMPB]_.MPB[POINTMPB,0]
						)
					      );
				 MLB[BASEMLB]_.MLB[NEXTMLB]
				)
			 )
			)
	ELSE OUTMSG(NOGO);
	RESETTEXTBYTE;
	RETURN 0
	END;
ROUTINE HANDLE =
	BEGIN
	BIND	READY = PLIT ASCIZ '?J?MDISPLAY SET UP?J?M?J*?W',
		PROMPT = PLIT ASCIZ '?J?M*?W',
		JOHN = (QJOHN[0])<0,36>,
		FLETCHER = (QJOHN[1])<0,36>,
		JIM = QJOHN[2],
		LF = #12,
		IOMASK = -1 XOR 1^34,
		LDSMASK = -1 XOR 1^29;
	MACRO	IO = JOHN<34,1>$,
		MASTER = JIM<18,6>$,
		CLEARIO = JOHN_@JOHN AND IOMASK$,
		CANCELIO = FLETCHER_@FLETCHER AND IOMASK$,
		CLEARLDS = JOHN_@JOHN AND LDSMASK$,
		CANCELLDS = FLETCHER_@FLETCHER AND LDSMASK$;
	OUTMSG(READY);
	UUO(0,WAITIN);
	IF SCANN(FIRSTBYTE) NEQ LF
		THEN	IF DOREAD()
				THEN	(REGISTER  R;
					 R_.VREG;
					 CLEARIO;
					 RETURN  .R<1,1>
					);
	CLEARIO;
	OUTMSG(PROMPT);
	WHILE 1 DO
		(WHILE .MASTER EQL 13 DO
			(UUO(0,SCOPE);
			 IF .IO THEN
				(IF SCANN(FIRSTBYTE) NEQ LF
					THEN IF DOREAD()
						THEN (REGISTER  R;
						      R_.VREG;
						      CLEARIO;
						      CANCELLDS;
						      RETURN  .R<1,1>
						     );
				 CLEARIO;
				 OUTMSG(PROMPT)
				)
			 ELSE CLEARLDS
			);
		 UUO(5,SCOPE);		!START LDS
		 IF .IO THEN (IF SCANN(FIRSTBYTE) NEQ LF
				THEN IF DOREAD() THEN
					(REGISTER  R;
					 R_.VREG;
					 CLEARIO;
					 CANCELLDS;
					 UUO(5,OFF);
					 RETURN  .R<1,1>
					);
			     CLEARIO;
			     OUTMSG(PROMPT)
			    )
		 ELSE CLEARLDS
		)
	END;
OWN  FREESPACE[2000];
KMAX_4;
KMIN_1;
KSTEP_1;
LMAX_4;
LMIN_1;
LSTEP_1;
TABLE[0]_1;
TABLE[1]_-1;
PASTEND_INBUF+20;
RESETTEXTBYTE;
FIRSTBYTE_INBUF<29,7>;
WAITIN_1^34;
SCOPE[0]_1^34+1^29;
SCOPE[1]_1^34+1^31;
OFF[0]_0;
OFF[1]_1^35;
WHILE 1 DO
     (
	INITALLOC(FREESPACE[0]<0,0>,2000);
	INITIALIZE(VCDIR,200,#302521^18+#077700);
	LEFT(VIEWPORT[0])_-(#3777);
	RIGHT(VIEWPORT[0])_-(#3777);
	VIEWPORT[1]_#3777^18 OR #3777;
	WINDOW[0]_.KMIN^18 OR .LMIN;
	WINDOW[1]_.KMAX^18 OR .LMAX;
	SDMB_SETSDMB();
	MHB_GEN(.KMIN,.KMAX,.KSTEP,.LMIN,.LMAX,.LSTEP);
	RIGHT(SCOPE[1])_.LDSSTART;
	WHILE 1 DO
		(DMB_DISPL(.MHB,TABLE<0,0>,2,VIEWPORT);
		 LINK(.SDMB,.DMB);
		 IF NOT HANDLE() THEN EXITLOOP;
		 DELINK(.DMB)
		)
     )
END
ELUDOM
    9“