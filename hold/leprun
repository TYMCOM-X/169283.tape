SUBTTL Leaping runtime routines.  Dec. 1969.



IFNDEF UPPER,<UPPER__0>
IFNDEF LOWER,<LOWER__0>
IFNDEF ALWAYS,<ALWAYS__0>

IFNDEF SEGS,<SEGS__0>
IFNDEF GLOBSW,<GLOBSW__0>
IFNDEF SAILRUN,<SAILRUN__0>

BEGIN LEAP
INTERNAL LEAP,CVIS,CVSI,NEW.PNAME,DEL.PNAME
IFE ALWAYS,<ENTRY LEAP,CVIS,CVSI
	  TITLE	LEAP
	  EXTERNAL GOGTAB,ARCOP,CORGET,CORREL,ARMAK
	  EXTERNAL DATM,X11,X22,X33,SAVE,RESTR,EQU>

COMMENT 
These are the leap runtime routines.  If you can believe it,there
is only one entry, LEAP.  Imbedded under pushj's to this spot is
a control word.  The right half specifies
a routine name (see table of routines).  The left half has
various bits -- such as:

BOUND
BINDING  **during foreach lists only.
SET	 **these bits are present for all (3) arguments.

FOREA	 -- says that this call is inside a foreach list.
SETOP	 -- this is a set type thing (e.g. x  S)
BRACKET	 -- this is a bracketed search.


Since there is no elegant way of drawing spaghetti with characters,
I will refrain from describing here the mess that these
routines build and destroy (at random).  



;ac definitions.
IFNDEF A,<
	A__1  B__2  C__3  D__4
>
	FLAG __5
	FP_6  FRTAB_7  FPD_10  PNT_11
	TABL __ USER	;MAKE IT THE SAME AS USER.

	ITLEN_=12		;ITEM NUMBERS ARE 12 BITS LONG.



;LENGTHS OF VARIOUS THINGS.....

	FREELEN__3000		;THIS IS HOW MUCH FREE SPACE WE GET
				;AT ONE TIME.
	HASLEN__1777		;MUST BE OF THIS FORM.
				;I.E. 2^N-1 .(THIS IS LENGTH OF HASH TABLE)
	INFOLEN__7777		;MAXIMUM NUMBER OF ITEMS.
	TOPITM __7777		;DITTO...
	FRMAX __ =20		;MAXIMUM NESTING OF FOREACHES.

;FOREACH BLOCK TEMPLATE.
;THIS IS THE "SEARCH CONTROL BLOCK" -- ONE IS MADE FOR EACH KIND
;OF ASSOCIATIVE SEARCHING ROUTINE CALLED.  THE FPD STACK HAS GOOD
;MASKS, TEMPORARY POINTERS, AND A-O-V INFORMATION IN IT.

	SATNO__=10		;MAXIMUM NUMBER OF SATISFIERS.
	FPDLEN__=70		;FOREACH PUSHDOWN LIST LENGTH
;** FOLLOWING ARE INDICES INTO SEACH CONTROL BLOCK (USUALLY "FRTAB")
	FPDP__0			;FOREACH PUSHDOWN POINTER.
	MOVEA__1		;INSTRUCTION TO EXECUTE TO LOAD AC "A"
				;WITH THE CURRENT SATISFIER FOR THE LOCAL NUMBER
				;IN "A"
	MOVEB__2		;SAME FOR AC "B"
	MC__3			;BYTE POINTER FOR DEPOSITING SATISFIERS.
	SCNT__4			;NUMBER OF CORE SATISFIERS FOR THIS SEARCH.
	SATIS__5-1		;START OF SATISFIERS.
				;EACH CELL HAS :
				; RH    USER CORE ADDRESS OF VARB.
				; LH   CURRENT SATISFIER ITEM NUMBER.
				;       (PUT THERE WITH "MC", RETRIEVED
				;	WITH "MOVEA" OR "MOVEB"
	FPDL__5+SATNO		;PUSH DOWN AREA.

	FRCHLEN__SATNO+FPDLEN+6		;TOTAL LENGTH.

;VARIOUS DEFINITIONS OF BITS IN THE CONTROL WORD:
;	THIS IS THE CONTROL WORD IMBEDDED UNDER THE PUSHJ P,LEAP.
;	THESE BITS ARE IN THE LEFT HALF, AND SPECIFY MODIFICATIONS
;	ON THE ROUTINE NUMBER MENTIONED IN THE RIGHT HALF.

DSCR FOREACH INTERPRETATION EXAMPLE
;
COMMENT @
THE THREE FOLLOWING DEFINITIONS PERTAIN TO THE (SAY) THREE ARGUMENTS
IN A FOREACH SEARCH SPECIFICATION: IF I SAID:
	FOREACH X | AXB AND X IN FOOSET DO...
THE CODE WOULD BE:
	PUSHJ	P,LEAP
	11			;START A FOREACH.
	JRST	2232323		;WHERE TO GO WHEN FOREACH ALL DONE.
	1			;NUMBER OF FREE LOCALS
	X			;ADDRESS OF THE ITEMVAR X.
	PUSH	P,[A]		;ITEM A
	PUSH	P,[1]		;FIRST SATISFIER
	PUSH	P,B		;ITEMVAR B.
	PUSHJ	P,LEAP
	XWD 20,2		;SPECIFIES THAT OBJECT IS BEING BOUND
				;IN THIS OPERATION ("BINDING"), AND
				;TO USE SEARCH 2  (OBJECT UNBOUND).
	PUSH	P,[1]		;FIRST SATISFIER
	PUSH	P,FOOSET	;SET
	PUSHJ	P,LEAP
	XWD 20410,7		;SET SEARCH.  SPECIFIES THAT THIS IS
				;A SET OPERATION ("SETOP") AND THAT
				;THE FIRST ARG. IS A BOUND SATISFIER.
	PUSHJ	P,LEAP
	12			;PUT SATISFIERS DOWN IN CORE....



@
	BOUND__4		;THESE NEXT 3 REPEATED FOR A,O AND V.
	BINDING__2
	SET__1

	FOREA__40000		;A FOREACH SEARCH (NOT USED)
	SETOP__20000		;A SET SEARCH IN A FOREACH.
	BRACKET__400000		;MUST BE SIGN BIT.
				;MEANS A BRACKETED TRIPLE SEARCH IN
				;FOREACH CONTEXT.

	ATTPOS__6		;POSITION IN THE WORD.....
	OBJPOS__3
	VALPOS__0

;BITS IN THE DATA STRUCTURES OF LEAP.

	BRABIT__400000		;MUST BE SIGN BIT.
				;ON IF NEXT GUY ON VALUE LIST IS A 
				;BRACKETED TRIPLE.
				;THIS BIT IS USED BOTH IN THE FOREACH SPEC.
				;FOR THE SEARCH, AND IN THE LEAP LIST
				;STRUCTURES CREATED.
	LPARRAY__400000		;MUST BE SIGN BIT.
				;THIS IS STORED IN THE "INFOTAB" ENTRY, RIGHT
				;HALF, FOR AN ITEM IF ITS DATUM IS AN ARRAY.
;DISPLACEMENTS IN FPD STACK FOR VARIOUS THINGS.
;	USED BY THE SEARCH ROUTINES TO FIND ARGUMENTS LEFT BY
;	THE FOREACH SEARCH CALLER.
	T2__2
	TT1__3
	MASK__4
	ATTP__5
	ITMP__5
	OBJP__6
	SETP__6
	VALP__7




;THE MAGIC MACRO TO HASH

	DEFINE HASH (X,Y,Z) <
	IFDIF <X><Y>,<MOVE	X,Y>
	LSH	X,1
	XOR	X,Z
	AND	X,HASMSK(TABL)		;THE MASK
	ADD	X,HASTAB(TABL)		;AND THE BOTTOM OF THE AREA.
	>

;MAGIC MACRO TO TEST FOR BRACKETED TRIPLE.
	DEFINE BRACKP (X) <TRZE X,BRABIT>	;SKIPS IF NO BRACK. TRIPLE.
	DEFINE BRACKN (X) <TRZN X,BRABIT>	;SKIPS IF BRACKETED TRIPLE.



DSCR LEAP ALLOCATION -- START OF PROGRAM.

 Allocation (initially).
The initialization proceeds in several phases:
	1. zero all the set variables.
	2. accumulate counts of declared items and NEW estimates.
	3. allocate hash table, datum table, info table, and frees.
	4. initialize random other things (datum, foreach tables)



;MACRO TO GET LEAP CORE.
DEFINE	LPCOR (SIZE,PLACE) <
	IFDIF <SIZE><>,<MOVEI	C,SIZE>
	PUSHJ	P,CORGZR
	IFDIF <PLACE><>,<MOVEM	B,PLACE(TABL)>
	>

CORGZR:			;THIS GETS AND ZEROES CORE.
	PUSHJ	P,CORGET		;ASK FOR CORE (SIZE IN "C")
	ERR	<CAN'T GET LEAP CORE>
	PUSH	P,B
	HRLS	B
	ADDI	B,1
	SETZM	-1(B)
	ADDI	C,-2(B)
	BLT	B,(C)		;ZERO THE WHOLE AREA.
	POP	P,B
	POPJ	P,



^LPINI:				;LEAP INITIALIZATION ROUTINE.
	PUSH	P,TAC1		;NOT SAVED IN CORGET AND FRIENDS.
	MOVE	B,SETLNK(USER)	;CLEAR OUT ALL SETS LINKED BY COMPILER
	JUMPE	B,LPALLO	;NO SETS!!!!
GOSET:	MOVE	C,-1(B)
	SETZM	(C)		;ZERO THE SET.
	AOBJN	C,.-1
	HRRZ	B,(B)
	JUMPN	B,GOSET		;CDR OF LIST.
LPALLO:				;SEARCH SPACE ALLOCATION INFORMATION.
	SETZB	C,D		;ACCUMULATE MAXIMUM ITEM COUNT.
	SETZM	FP		;COUNT OF PNAMES REQUIRED.
	MOVE	A,SPLNK(USER)	;ALLOCATION LINK POINTER
ITMWQ:	JUMPE	A,ITMDON	;0 WHEN DONE.
	MOVE	TEMP,1(A)	;TOP ITEM NUMBER USED.
	CAILE	TEMP,10		;THERE ARE 7 DUMMIES.
	JRST	[SKIPE C
		 TERPRI	<WARNING: TWO PROGRAMS WITH ITEMS IN THEM>
		 MOVE C,TEMP
		 CAMGE FP,11(A)	;MORE PNAMES NEEDED?
		  MOVE	FP,11(A) ;YES
		 JRST	.+1]
	SKIPGE	TEMP,6(A);IF ITEMS NOT REALLY REQUESTED,
	TLO	USER,-1		;THEN SAY NO LEAP LOCAL MODEL.
	ADD	D,TEMP		;ESTIMATE OF NEW ITEMS REQUIRED.
	HRRZ	A,(A)	;GO DOWN LINK.
	JRST	ITMWQ
ITMDON:			;FINISHED WITH SPACES.
	CAIGE	C,10	;MAKE SURE ITEMS 7 AND BELOW NOT ALLOCATED
	MOVEI	C,7	;NEXT NEW WILL YIELD 10
	MOVEM	C,MAXITM(USER);TOP ITEM ALLOCATED.
	HRROM	FP,HASHP(USER);NUMBER OF PNAMES NEEDED.
	MOVEI	FP,HASLEN&777776;FOR THE HASH TABLE MASK.
	MOVEM	FP,HASMSK(USER)	;AND SAVE
	TLNE	USER,-1		;DOES USER REALLY WANT LOCAL MOD?
	 JRST	 INDONE		;THIS IS TO AVOID HAVING SOME
				;POOR LOSER WHO ONLY WANTS GLOBAL
				;ARRAYS GETTING 15 K CORE FOR LEAP!
	ADDI	C,100(D)	;MAXIMUM EXPECTED NEWS IN ADDITION.
	CAILE	C,TOPITM	;IF OVER THE TOP, THEN...
	MOVEI	C,TOPITM	;MAKE IT RIGHT.
	MOVEM	C,ITMTOP(USER)	;SAVE AS MAX PERMISSIBLE ITEM NUMBER.
	MOVNI	TEMP,-3(C)	;INIT FREITM(USER)
	SUB	TEMP,MAXITM(USER)
	MOVNM	TEMP,FREITM(USER)
SPALLO:	PUSH	P,C
	LPCOR	(,)		;GET CORE FOR VALUE LINKS, ETC.
	MOVEM	B,INFOTAB(TABL)	;RECORD IT.
	LPCOR	(HASLEN+1,HASTAB);HASH TABLE SPACE.
	
	POP	P,C		;RESTORE SIZE
	LPCOR	(,)		;AND FOR DATUMS.
	MOVEM	B,DATAB(TABL)	;RECORD IT.
	HRLI	B,3		;ACCUMULATOR NUMBER FOR DATUM.
	SETZM	OLDITM(TABL)	;RESTART THE OLD ITEM LIST.
	MOVEM	B,DATM		;THIS IS FOR REFERENCING DATUMS.

; **** COMMENT HERE ON BUFACS PROBLEM *****
INDONE:	LPCOR	(FRMAX,LEABOT)	;GET CORE FOR TABLE OF SCB POINTERS
				; (AN SCB IS A SEARCH CONTROL BLOCK --
				;  IT IS 86 WORDS LONG -- ONE IS ALLOCATED
				;  FOR EACH FOREACH -- POINTERS IN THIS 
				;  POINT TO IT)
	SUBI	B,1		;PREPARE FOR AOS
	MOVEM	B,FRLOC(USER)	;1 BEHIND FIRST SCB POINTER
	ADDI	B,FRMAX		;GET POINTER FOR OVERFLOW COMPARE
	MOVEM	B,FRLIM(USER)	; PUT IT HERE

	JSP	FP,FRGO		;SET UP THE FOREACH PARTS.
	TLNN	USER,-1 	;DON'T GET FREES IF NO LOW-SEGMENT ITEMS
	PUSHJ	P,FPEES		;GET FREE STORAGE.
	POP	P,TAC1		;RESTORE AC.
	POPJ	P,		;GO AWAY...



;GET BOTH KINDS OF FREE STORAGE.
FPEES:	PUSHJ	P,FP2DON	;GO GET FREE STORAGE.

DSCR FP1DON FP2DON
THESE ARE THE ROUTINES FOR GETTING MORE FREE STORAGE FROM
THE MAIN CORE ALLOCATORS.  FP1DON GETS 1 WORD FREES, FP2DON
GETS 2 WORD FREES. THEY ARE GENERALLY CALLED UNDER A SKIPN FP,(FP)
AND RETURN FP POINTING TO THE HEAD OF THE NEW FREE STORAGE LIST.

FP1DON DOES A SPECIAL THING -- THE LAST ELEMENT OF THE OLD FREE
STORAGE LIST IS LINKED TO THE FIRST ELEMENT OF THE NEW ONE -- THIS
IS SO THAT SETS (I.E. LINKED LISTS) CAN BE MADE IN ONE PIECE,
WITHOUT WORRYING ABOUT LINKING THE INDIVIDUAL CELLS TOGETHER.

ACS SAVED -- ALL
AC RESULT -- FP HAS NEW POINTER.
;
FP1DON:	PUSHJ	P,FSAV
	LPCOR	(FREELEN,)	;GET THE CORE
	HRRM	B,FP1(TABL)
	HRRZM 	B,SGACS+FP(USER)
	HLRZ	C,FP1(TABL)	;THIS WAS THE LAST WORD BEFORE.
	SKIPE	C		;NONE THERE
	HRRM	B,(C)		;LINK IT DOWN....
	MOVNI	A,FREELEN-1
	ADDI	B,1
	HRRZM	B,-1(B)		;LINK UP THE LIST
	AOJL	A,.-2
	SETZM	(B)
	HRLM	B,FP1(TABL)	;SAVE ADDR OF LAST FREE FOR LINKING
	JRST	FREST		;AND DONE.

FP2DON:	PUSHJ	P,FSAV
	LPCOR	(FREELEN,FP2)
	HRRZM 	B,SGACS+FP(USER)
	MOVNI	A,FREELEN/2-1
	ADDI	B,2
	HRRZM	B,-2(B)
	AOJL	A,.-2		;LINK UP.
	SETZM	(B)
;	JRST	FREST
FREST:	MOVSI	14,SGACS(USER)
	BLT	14,14
	POPJ	P,

FSAV:	MOVEM	14,SGACS+14(USER)
	MOVEI	14,SGACS(USER)
	BLT	14,SGACS+13(USER)
	POPJ	P,





DSCR MAIN DISPATCHER FOR LEAP

THIS IS THE MAIN ENTRY OF THIS CODE (I.E. "LEAP").
THE APPROPRIATE INTERPRETER ROUTINE IS CALLED.

 ****** AC'S SET UP FOR ALL INTERPRETER ROUTINES ******
USER		SET UP TO GOGTAB.
FRTAB		SET UP TO CURRENT FOREACH SEARCH CONTROL TABLE.
UUO1(USER)	CONTAINS THE USER'S RETURN ADDRESS.
FLAG		CONTAINS CONTROL WORD.. UNTOUCHED
P		PUSH-DOWN STACK HAS RETURN ADDRESS WORD POPPED OFF.

;



HERE (LEAP)			;THIS HERE IS LEAP.
	MOVE	USER,GOGTAB
	SKIPN	HASMSK(USER)	;TEST TO SEE IF INITIALIZED ALREADY.
	 PUSHJ	 P,LPINI	;NO -- GO DO IT.
	MOVE	FRTAB,@FRLOC(USER);CURRENT FOREACH TABLE.
	POP	P,UUO1(USER)	;RETURN ADDRESS
	AOS	B,UUO1(USER)	;PAST THE CONTROL WORD.
	MOVE	FLAG,-1(B)	;CONTROL WORD.
	XCT	ROUTABLE(FLAG)	;CALL THE ROUTINE.
LEAV:				;UNIFORM EXIT LOCATION.
	JRST	@UUO1(USER)




;DISPATCH TABLE FOR THE LEAP INTERPRETER.




ROUTABLE:
REPEAT 11,<JRST    	FOREC>	;0-10 -- FOREACH SEARCHES.
	JRST		FORGO	;11 -- START OF FOREACH STAT.
	PUSHJ P,	FRPOP	;12 -- POP FOREACH SATISFIERS INTO CORE.
	JRST		DOAG	;13 -- LOOP AT END OF FOREACH STAT.
	PUSHJ P,	FRTRUE	;14 -- IF A FOREACH BOOLEAN IS TRUE.
	JRST		FRFAL	;15 -- IF A FOREACH BOOLEAN IF FALSE.
	PUSHJ P,    	MAKE	;16 -- MAKE AN ASSOCIATION.
	JRST        	BMAKE	;17 -- MAKE A BRACKETED TRIPLE.
ESTART:	
REPEAT 7,<PUSHJ P,  	ERASE>	;20-26 -- ERASES
	PUSHJ P,    	ISTRIPLE;27 -- ISTRIPLE (FOO)
SELET1:	
REPEAT 3,<PUSHJ P,  	SELECTOR>;30-32 FIRST,SECOND AND THIRD.
	JFCL			;33 -- NO OPERATION.
LD0:	JRST       	LD1	;34 -- DERIVED SETS -- INSIDE FOREACH.
	JRST 	   	LD2	;35
	JRST 	   	LD3	;36
DSTART:	JRST 	   	D1	;37 -- DERIVED SETS -- NORMAL.
	JRST 	   	D2	;40
	JRST 	   	D3	;41
	JRST 	   	DELETE	;42 -- DELETE.
	PUSHJ P,   	NEW	;43 -- REGULAR NEW.
	PUSHJ P,    	NEWART	;44 -- NEW (ARITHMETIC VALUE)
	JRST 	   	NEWARY	;45 -- NEW (ARRAY)
	PUSHJ P,	FDONS	;46 -- RELEASE THIS FOREACH STATEMENT.
	PUSHJ P,	PUTIN	;47 -- PUT X IN SET.
	PUSHJ P,	REMOV	;50 -- REMOVE X FROM SET.
	PUSHJ P,	SIP	;51 -- <A,B,C,D>
	PUSHJ P,	STIN	;52 -- BOOLEAN X SET ?
	PUSHJ P,	COUNT	;53 -- LENGTH OF SET.
	PUSHJ P,	UNIT	;54 -- COP OF SET.
	PUSHJ P,	UNION	;55 -- SET UNION
	PUSHJ P,	INTER	;56 -- SET INTERSECTION.
	PUSHJ P,	SUBTRA	;57 -- SET SUBTRACTION.
	JRST		STORITM	;60 -- STORE A SET OR ITEM FROM STACK.
	JRST	STORBUTDONTREMOVE ;61 -- SAME AS 60, BUT LEAVE ON STACK.
	JRST		POPTOP	;62 -- SAME AS 60 BUT PUT RESULT IN AC1
	JRST		POPSET	;63 -- SAME AS 60 BUT PUT RESULT IN AC1
RELSTART:
REPEAT 6,<PUSHJ P,  	SETEST>	;64-71 -- SET RELATIONALS.
	JRST		IEQ	;72 -- ITEM EQUALITY TEST.
	JRST		INE	;73 -- ITEM NON-EQUALITY TEST.
ISBEG:
REPEAT 7,< JRST     	ISIT >	;74-102 -- ANSWER TO ABC ?
BSTART:
REPEAT 7,<JRST       	BRITM>	;103-111 -- FIND ITEM FOR [ABC]
	JRST    	ITMRY	;112 -- FOR INITIALIZING ARRAY ITEMS.
	JRST     	ITMYR	;113 -- FOR INITIALIZING ARRAY ITEMS.
	JRST		STLOP	;114 -- LOP OF SET.
	JRST		INTNAM	;115 -- INITIALIZE PNAMES.
	JRST		SETCOP	;116 -- COPY A FORMAL SET.
	JRST		SETRCL	;117 -- RECLAIM A FORMAL SET.





DSCR DISPATCH TABLE FOR THE FOREACH SEARCHES

INDEXED BY THE FLAG CONTROL WORD NUMBER -- RESULT
IS ROUTINE NUMBER TO EXECUTE.  IF THE INDEX IS -1,
"FDONE" IS CALLED, WHICH AUTOMATICALLY FLUSHES THE
CURRENT FOREACH STATEMENT GROUP OF SEARCHES (I.E.
THE OUTERMOST SEARCH FAILED, AND IT IS TIME TO GO AWAY).

;

	FDONE
ETAB:
SEROUT:	F1
	F4
	F3
	F5
	F2
	F7
	F6
	S2
	S1


DSCR  ASSOCIATIVE SEARCH ROUTINES
;
comment @
These are the 9 kinds of associative searches:
	f1		AOv
	f2		AOX
	f3		AXV
	f4		XOV
	f5		XYV
	f6		AXY
	f7		XOY
	s1		x  S
	s2		A  S

These all use a "search control block" to describe the details
of the search.  Any bound items have values in the FPD stack,
at -ATTP(FPD),-OBJP(FPD), and -VALP(FPD) depending whether
they are attribute, object or value.  If these items are unbound,
then the stack entries contain the satisfier number (and hence
a description of a place where to put the result we find in the
search).

-TT1(FPD) and -T2(FPD) are used as temporaries by each routine --
they are used to store pointers into the data structure, and
to remember whether the search has been initialized once.
The initial values of these entries are -1 and 0 respectively.

Each search routine skips if it succeeds in finding an association
of the correct variety.  In this case, register A points to the
2 word cell which stores that association.  ERASE code counts
on this pointer, as do some other people (?).

If the search fails, or is exhausted, the normal (non-skipping)
return is taken.


@





;THE SEARCH ROUTINES.....



; AOV

F1:	AOSE	-TT1(FPD)	;FIRST TEMP SAYS WE WRE HERE BEFORE.
	 POPJ	 P,		;RETURN -- HAVE BEEN THROUGH ONCE.
	HASH	(A,<-ATTP(FPD)>,<-OBJP(FPD)>)
COMP:	SKIPN	B,1(A)		;SEE IF A-O-V IS THERE AT ALL.
	 POPJ	 P,		;IT IS NOT.
	XOR	B,-MASK(FPD)	;HAVE WE GOT IT?
	JUMPN	B,NO
YES:	AOS	(P)
	POPJ	P,		;SUCCESSFUL RETURN.

NO:	TDNE	B,[ 777777770000];DO A-O AT LEAST MATCH?
	 JRST	 [HRRZ A,(A)	;CONFLICT POINTER.
		 JUMPN	A,COMP	;AND LOOK IF NONZERO
		 POPJ	P,]	;FAILLLLLLllllll....
	MOVE	B,1(A)
	TRNE	B,7777		;IS VALUE ZERO?
	 POPJ	 P,		;NO -- HENCE CANNOT SUCCEED.
	HLRZ	A,(A)		;VALUE LINK POINTS TO MULTIPLE HITS.
VALE:	MOVE	B,1(A)		;THIS IS IT.
	CAMN	B,-MASK(FPD)	;COMPARE
	 JRST	 YES
	HRRZ	A,(A)		;CONFLICT POINTER.
	JUMPN	A,VALE
	POPJ	P,		;FAILED.



; AOX

F2:	AOSE	-TT1(FPD)	;BEEN HERE BEFORE?
 	 JRST	 NEXT		;YESSIR
	LDB	B,[POINT ITLEN,-MASK(FPD),23]
	LDB	A,[POINT ITLEN,-MASK(FPD),ITLEN-1]
	HASH	(A,A,B)
COMP2:	SKIPN	B,1(A)		;CHECK TO SEE IF A-O-V IS THERE ART LL
	 POPJ	 P,		;FAIL
	TRZ	B,7777		;MASK OUT VALUE.
	CAMN	B,-MASK(FPD)	;SEE IF IT MATCHES...
	 JRST	 YES2
	HRRZ	A,(A)		;CONFLICT.
	JUMPN	A,COMP2		;LOOP
	POPJ	P,		;FAILURE

YES2:	MOVE	B,1(A)		;PICK IT UP AGAIN.
	TRNE	B,7777		;COULD STILL BE A MULTIPLE HIT.
	 JRST	 PUT		;NOPE
	HLRZ	A,(A)		;POINTER TO MULTIPLE HITS.
	HRRZ	C,(A)		;POINTER TO NEXT ONE.
	MOVEM	C,-T2(FPD)	;SAVE FOR NEXT TIME.
PUTA:	MOVE	B,1(A)		;PICK UP A-O-V
PUT:	MOVE	C,-VALP(FPD)	;LOCAL NUMBER FOR VALUE
	DPB	B,MC(FRTAB)	;PUT IN SATISFIER TABLE.
	AOS	(P)
	POPJ	P,		;SUCCESSFUL RETURN


NEXT:	SKIPE	-VALP(FPD)	;ANY ?
	SKIPN	A,-T2(FPD)	;GET NEXT ONE
	 POPJ	 P,		;NONE.
	MOVE	B,1(A)		;GET WORD AGAIN,JUST TO MAKE SURE
	TRZ	B,7777		;SINCE ERASE MUMBLEMUMBLEANY
	CAME	B,-MASK(FPD)	;MAY CHANGE POINTERS ON US.
	 POPJ	 P,		;NO DICE
	HRRZ	C,(A)		;POINTER TO NEXT.
	MOVEM	C,-T2(FPD)	;SAVE IT.
	JRST	PUTA		;GO GET THE VALUE.



; AXV

F3:	AOSE	-TT1(FPD)	;FIRST TIME
	 JRST	 NEXT3		;NO
	MOVE	A,-VALP(FPD)	;VALUE
	ADD	A,INFOTAB(TABL)	;PREPARE TO GET VALUE LINK
	HLRZ	A,(A)		;VALUE LINK!
	JUMPE	A,CPOPJ		;IF ZERO, THERE IS NONE.
NN:	MOVE	B,1(A)		;PICK UP A-O-V
	AND	B,[BYTE (ITLEN) 7777,0,7777]
	CAME	B,-MASK(FPD)	;IS THIS THE ONE?
	 JRST	 NO3
	HLRZ	C,(A)		;VALUE LINK
	BRACKP	C		;IF BRACKETED TRIPLE THEN
	 HLRZ	 C,(C)		;PASS UP BRACKET NUMBER
F3QQ:	MOVEM	C,-T2(FPD)
	MOVE	C,-OBJP(FPD)	;OBJECT NUMBER
	LDB	B,[POINT ITLEN,1(A),23]
	DPB	B,MC(FRTAB)	;STORE IN SATISFIER TABLE.
	AOS	(P)	
	POPJ	P,

NO3:	HLRZ	A,(A)		;VALUE LINK
	BRACKP	A
	 HLRZ	 A,(A)		;PAST BRACKETED ITEM NUMBER.
	JUMPN	A,NN		;LOOP UNTIL EXHAUSTED
	POPJ	P,		;EXHAUSTED.

NEXT3:	MOVE	A,-T2(FPD)	;GET THE LAST POINTER
	SKIPE	-OBJP(FPD)	;ANY OBJECT?
	JUMPN	A,NN		; -- WANT TO DO SEARCH AGAIN.
	POPJ	P,




; XOV


F4:	AOSE	-TT1(FPD)	;BEEN HERE BEFORE
	 JRST	 NEXT4		;YES
	MOVE	A,-VALP(FPD)	;GET VALUE
	ADD	A,INFOTAB(TABL)	;PREPARE TO GET VALUE LINK
	HLRZ	A,(A)		;VALUE LINK!
	JUMPE	A,CPOPJ		;FAIL
NN4:	MOVE	B,1(A)		;A-O-V WORD
	TLZ	B,777700	;MASK OFF ATTRIBUTE
	CAME	B,-MASK(FPD)	;IS THIS THE ONE?
	 JRST	 NO4
	HLRZ	C,(A)		;VALUE LINK
	BRACKP	C		;TEST FOR BRACKETED TRIPLE.
	 HLRZ	 C,(C)		;PASS UP BRACKET ID NUMBER
F4QQ:	MOVEM	C,-T2(FPD)	;SAVE FOR NEXT TIME.
	MOVE	C,-ATTP(FPD)	;ATTRIBUTE ID NUMBER
	LDB	B,[POINT ITLEN,1(A),ITLEN-1];ATTRIBUTE NUMBER
	CAIG	B,7		;THERE ARE 7 DUMMIES.
	 JRST	 NEXT4		;GO FOR MORE.
	DPB	B,MC(FRTAB)	;STORE IN SATISFIER TABLE.
	AOS	(P)	
	POPJ	P,		;RETURN....

NO4:	HLRZ	A,(A)		;VALUE LINK
	BRACKP	A		;TEST FOR BRACKETED TRIPLE.
	 HLRZ	 A,(A)		;PAST BRACKETED ITEM NUMBER.
	JUMPN	A,NN4
	POPJ	P,		;FAILED.

NEXT4:	MOVE	A,-T2(FPD)	;POINTER
	SKIPE	-ATTP(FPD)	; IS THE ATTRIBUTE "ANY" ?
	JUMPN	A,NN4		; NO -- TRY TO CONTINUE SEARCH
	POPJ	P,




; XYV


F5:	MOVE	A,-T2(FPD)	;FOR .....
	AOSE	-TT1(FPD)	;BEEN HERE BEFORE?
	 JRST	 NEXT5		;YUP
	MOVE	A,-VALP(FPD)	;VALUENUMBER
	ADD	A,INFOTAB(TABL)	;GET READY TO GET
	HLRZ	A,(A)		;VALUE LINK
NEXT5:	SKIPN	-ATTP(FPD)	;IF BOTH ARGS ARE "ANY", THEN
	SKIPE	OBJP(FPD)	;RETURN IMMEDIATELY.
	SKIPN	A		;NOT THERE.
	POPJ	P,
	HLRZ	C,(A)		;NEXT VALUE POINTER
	BRACKP	C		;TEST FOR BRACKETED TRIPLE.
	 HLRZ	 C,(C)		;PASS UP BRACKET ID NUMBER
F5QQ:	MOVEM	C,-T2(FPD)
	MOVE	B,1(A)		;A-O-V WORD.
	ROT	B,ITLEN		;ATTRIBUTE IS NOW LOW.
	TRNN	B,7770
	 JRST	 F5		;7 DUMMIES.
	MOVE	C,-ATTP(FPD)	;ATTRIBUTE NUMBER
	DPB	B,MC(FRTAB)	;STORE IN SATISFIER TABLE.
	ROT	B,ITLEN		;OJECT IS NOW LOW
	MOVE	C,-OBJP(FPD)	;OBJECT ID NUMBER
	DPB	B,MC(FRTAB)
	AOS	(P)
	POPJ	P,


; AXY


F6:	AOSE	-TT1(FPD)
	JRST	[SKIPE  -VALP(FPD);IS VALUE "ANY" ?
		 JRST	GRT6	;NO -- CONTINUE SEARCH.
		 SKIPE	-OBJP(FPD);IS OBJECT "ANY"
		 JRST	UPDAT	;NO -- GO TO NEXT OBJECT.
		 POPJ	P,	;YES-- IT WAS ANY AND ANY
	]

UPDAT:	MOVEI	A,1ITLEN	; 10000
	ADDB	A,-MASK(FPD)	; GO UP ONE ITEM NUMBER
	LDB	B,[POINT ITLEN,A,2*ITLEN-1];OBJECT
	CAMLE	B,MAXITM(USER)	;GONE FAR ENOUGH?
	 POPJ	 P,		;YES
	MOVE	C,-OBJP(FPD)	;OBJECT ID NUMBER.
	DPB	B,MC(FRTAB)	;FILL SATISFIER
	SETZM	-T2(FPD)	;RESTART SEARCH
	SETOM	-TT1(FPD)	;RESTART SEARCH
GRT6:	PUSHJ	P,F2		;AOX
	 JRST	 UPDAT		;FAIL
	AOS	(P)
	POPJ	P,



; XOY

F7:	AOSE	-TT1(FPD)
	JRST	[SKIPE	-VALP(FPD);IS VALUE "ANY" 
		 JRST	GRT7	;NO -- GO AHEAD
		 SKIPE	-ATTP(FPD);IS ATTRIBUTE "ANY" ?
		 JRST	UPDAT7	;NO -- GET ANOTHER ATTRIBUTE
		 POPJ	P,]	;NO -- GO AHEAD
	SKIPA	A,[XWD 1000,0]	;START AT ITEM 10 (BECAUSE OF PNMAES)
UPDAT7:	MOVSI	A,(1(2*ITLEN))	; 1000
	ADDB	A,-MASK(FPD)	;UPDATE MASK ATTRIBUTE NUMBER
	LDB	B,[POINT ITLEN,A,ITLEN-1];ATTRIBUTENUMBER
	CAMLE	B,MAXITM(USER)	;GONE FAR ENOUGH?
	 POPJ	 P,
	MOVE	C,-ATTP(FPD)	;ATTRIBUTE ID NUMBER
	DPB	B,MC(FRTAB)	;FILL SATISFIER
	SETZM	-T2(FPD)	;RESTART SEARCH
	SETOM	-TT1(FPD)	;RESTART SEARCH
GRT7:	PUSHJ	P,F2		; AOX
	 JRST	 UPDAT7		;FAIL
	AOS	(P)
	POPJ	P,



; X  S


S1:	MOVE	A,-T2(FPD)	;IN CASE OF NEXT
	AOSE	-TT1(FPD)
	 JRST	 NEXS1		;BEEN HERE BEFORE
	SKIPN	A,-SETP(FPD)
	 POPJ	 P,		;NULL SET
	HRRZ	A,(A)		;GET PAST SET HEADER

NEXS1:	JUMPE	A,CPOPJ		;DONE
	HLRZ	B,(A)		;ITME NUMBER
	MOVE	C,-ITMP(FPD)	;DESTINATION TEMP
	DPB	B,MC(FRTAB)
	HRRZ	B,(A)		;NEXT POINTER.
	MOVEM	B,-T2(FPD)	;FOR NEXT TIME.
	AOS	(P)
	POPJ	P,		;SUCCESS.



; A  S

S2:	AOSE	-TT1(FPD)	;SO THAT YOU DON'T
	 POPJ	 P,		;GO THROUGH TWICE
	SKIPN	A,-SETP(FPD)	;PICK UP SET POINTER
	 POPJ	 P,		;NULL SET
	HRRZ	A,(A)		;PASS UP HEADER
NXT:	JUMPE	A,CPOPJ		;GONE TO END AND NOT FOUND.
	HLRZ	B,(A)
	CAMN	B,-ITMP(FPD)	;RIGHT ONE?
	 JRST	 YESS1
	HRRZ	A,(A)
	JRST	NXT
YESS1:	AOS	(P)
	POPJ	P,






DSCR FORSET AND NOFOR -- MAKE A SEARCH CONTROL BLOCK
THESE ROUTINES TAKE ENTRIES OFF THE STACK (P) AND
MAKE UP SEARCH CONTROL BLOCKS BASED ON THESE ENTRIES AND
THE CONTENTS OF THE FLAG WORD.  THESE ROUTINES ARE
CALLED BY THE FOREACH INTERPRETER, THE ERASE CODE,
AND SOME OF THE "IS THIS ASSOCIATION IN THE STORE"
ROUTINES.

THE DIFFERENCE BETWEEN THE ROUTINES IS THIS:
NOFOR HANDLES "ANY" CONSTRUCTS DIFFERENTLY.  THE SEARCH ROUTINES
ARE CAPABLE OF CUTTING SHORT THEIR SEARCHES, BASED ON THE
EXISTENCE OF AN "ANY".  THIS IS A FINE IDEA FOR THE
FOREACH STATEMENT, SINCE THE USER IS NOT INTERESTED
IN THE ACTUAL ITEMS WHICH WILL MATCH THE "ANY".
HOWEVER, THE ERASE CODE IS VITALLY INTERESTED, SINCE
IT MUST ERASE ALL OF THEM.  SO:

NOFOR -- CALL IF YOU WANT SEARCH CONTROL BLOCK WHICH WILL
	RETURN ON ALL SUCCESSFUL MATCHES TO "ANY"
FORSET -- CALL IF YOU WANT THE ABBREVIATED SEARCHES.

CALLS: BOTH WITH JSP LPSA,xxxx

;



NOFOR:	MOVE	FRTAB,@LEABOT(USER)	;ALWAYS AVAILABLE BLOCK
	MOVEI	A,1		;THIS WILL BE THE SATISFIER NO.
	TLNE	FLAG,BINDINGATTPOS ;IF ATTRIBUTE IS "ANY"
	 MOVEM	 A,-2(P)	;THEN FIX.
	TLNE	FLAG,BINDINGOBJPOS
	 MOVEM	 A,-1(P)
	TLNE	FLAG,BINDINGVALPOS
	 MOVEM	 A,(P)		;THE COMPILER REALLY SHOULD DO THIS.

FORSET:	MOVE	FPD,FPDP(FRTAB)	;PICK UP THE LEAP PUSH-DOWN POINTER.
	TLNE	FLAG,SETOP
	 AOBJN	 FPD,P2		;NO ENTRY IF A SET.

	TLNE	FLAG,BRACKET	;IF BRACKETED TRIPLE SEARCH.
	 POP	 P,D		;THE BRACKETED ITEM NUMBER

P3:	POP	P,B		;THE VALUE
	TLNE	FLAG,BOUNDVALPOS ;IF VALUE IS A BOUND ITEMVAR, THEN
	 XCT	 MOVEB(FRTAB)	;GET THE SATISFIER FROM THE TABLE.
	PUSH	FPD,B
	TLNE	FLAG,BINDINGVALPOS ;ZERO THE ENTRY IF UNBOUND.
	 SETZM	 B
	LSHC	B,-ITLEN	;MAKE UP MASK IN C.

P2:	POP	P,B
	TLNE	FLAG,BOUNDOBJPOS
	 XCT	 MOVEB(FRTAB)
	PUSH	FPD,B
	TLNE	FLAG,BINDINGOBJPOS
	 SETZM	 B
	LSHC	B,-ITLEN

P1:	POP	P,B		;ATTRIBUTE
	TLNE	FLAG,BOUNDATTPOS
	 XCT	 MOVEB(FRTAB)
	PUSH	FPD,B
	TLNE	FLAG,BINDINGATTPOS
	 SETZM	 B
	LSHC	B,-ITLEN


	PUSH	FPD,C		;THE MASK OF A-O-V
				;UNBOUND PORTIONS OF THE MASK ARE 0

	PUSH	FPD,[-1]	;INITIAL -TT1(FPD)
	PUSH	FPD,[0]		;INITIAL -T2(FPD)

	PUSH	FPD,FLAG	;SAVE THE ROUTINE NAME.
	PUSH	FPD,UUO1(USER)	;SAVE RETURN ADDRESS.
	HRLM	D,(FPD)		;SAVE BRACKETED ITEM # IN LH.
	
	JRST	(LPSA)		;ALL DONE.









DSCR  FOREACH STATEMENT INTERPRETER

THERE ARE SEVERAL ROUTINES IN THIS SECTION:

FORGO	-- CALLED TO INITIALIZE A FOREACH STATEMENT.
	   RECORDS FAILURE ADDRESS.
	   RECORDS COUNT AND ADDRESSES OF FREE ITEMVARS.
FRGO	-- TO INITIALIZE A PART OF LEAP CORE (JUST LIKE THE
	   LEABOT(USER) AREA) TO USE AS A SEARCH CONTROL
	   BLOCK.

FDONE	-- WHEN THE OUTERMOST SEARCH IN THE FOREACH STAT.
	   FAILS, THIS IS CALLED.  IT MERELY TAKES THE
	   FAILURE EXIT FROM THE FOREACH STATEMENT.
FDONS	-- USED BY THE "DONE" CONSTRUCT (OR BY A "GO TO")
	   WHEN EXITING FROM INSIDE A FOREACH STATEMENT -- THE
	   IDEA IS TO BACK UP THE NESTING OF FOREACH SEARCHES BY
	   ONE, AND DO SOME BOOKEEPING.

FRPOP 	-- CALLED AT END OF SEARCH SPECIFICATIONS IN FOREACH
	   OR WHEN PREPARING FOR A BOOLEAN EXPRESSION INSIDE
	   A FOREACH SPECIF.  THIS COPIES CURRENT SATISFIER
	   VALUES INTO THEIR REAL USER CORE ADDRESSES (AS RECORDED
	   BY FORGO).

FRTRUE  -- CALLED BY THE "TRUE" RESULT OF A BOOLEAN EXPRESSION
	   INSIDE A FOREACH SPECIFICATION.
	   SKIPS TWO INSTRUCTIONS (I.E. SKIPS OVER CALL ON FRFAL).
FRFAL	-- SIMILAR FOR FALSE. (EXCEPT NO SKIP)

DOAG	-- CALLED AT THE BOTTOM OF THE FOREACH LOOP. CAUSES
	   THE SEARCHES TO BE FIRED UP TO FIND THE NEXT GROUP OF
	   SATISFIERS.

FOREC	-- MAIN CALL TO START A TRIPLE SEARCH, AS SPECIFIED
	   IN THE FOREACH SPECIFICATION. A,O, AND V ARE ON THE
	   STACK.
LD1,LD2,LD3 -- CALLED BY "DERIVED SETS" INSIDE A FOREACH SPEC.
	   SPECIAL ADJUSTMENTS ARE MADE TO THE STACK (TO REORDER
	   OPERANDS).
;





LD2:	MOVE	B,(P)		;IN IS A,V,X
	EXCH	B,-1(P)		;MAKE IT AXV
	MOVEM	B,(P)
				;COMPILER HAS FIXED UP THE BITS
				;CORRECTLY ALREADY.
LD1:
	HRRI	FLAG,(FLAG)ROUTABLE-LD0+DERIV-SEROUT ;FIX UP DISPATCH.

^FOREC:	SETZB	LPSA,D		;MAIN FOREACH SPECIFICATION PROCESSOR.
	JSP	LPSA,FORSET	;SET UP THE SEARCH CONTROL BLOCK.

GO:				;LOOP BACK TO HERE TO DO SEARCHES.
	SKIPG	FLAG,-1(FPD)	;PICK UP ROUTINE NAME.
	 JRST	 BRACK		;BRACKETED SEARCH
	PUSHJ	P,@SEROUT(FLAG)	;CALL THE ROUTINE.
	 JRST	 FAIL		;IT FAILED IF IT CAME HERE.
				;BACK UP THE SEARCH TO NEXT OUTER.

SUCC:	MOVEM	FPD,FPDP(FRTAB)	;SAVE PUSH-DOWN POINTER
	MOVE	FPD,(FPD)	;RETURN ADDRESS (LEFT HALF HAS STUFF)
	JRST	(FPD)		;RETURN
				;THIS DOES NOT RETURN THROUGH
				;"LEAV".


FAIL:	MOVE	FLAG,-1(FPD)	;THE CONTROL WORD.
	SKIPGE	A,-SETP(FPD)	;IF SET NEEDS RECLAIMING
	TLNN	FLAG,SETOP	;WAS THIS A SET?
	 JRST	 FAIGO
	MOVE	B,FP1(USER)	;PREPARE TO RECLAIM TEMP SET.
	HLRZ	C,(A)
	HRRZM	B,(C)		;PUT IN DOWN POINTER.
	HRRM	A,FP1(USER)	;AND UPDATE FREE LIST.
FAIGO:	SUB	FPD,[XWD 10,10]
	JRST	GO		;USE THE NEXT HIGHER ROUTINE.




BRACK:				;IF BRACKETED TRIPLE SEARCH.
	PUSHJ	P,@SEROUT(FLAG)	;CALL THE ROUTINE.
	 JRST	 FAIL		;FAIL....
	HLRZ	B,(A)		;A POINTS TO THING FOUND.
	BRACKN	B		;IS THIS A BRACKETED TRIPLE?
	 JRST	 [HRRZ	FLAG,-1(FPD) ;NO -- GET CONTROL WORD AGAIN.
		JRST	BRACK]	;AND TRY AGAIN.
	HRRZ	B,(B)		;THIS IS THE ITEM ## BRACKET.
	HLRZ	C,(FPD)		;THIS IS THE LOCAL NUMBER
				;FOR THE BRACKETED #
	DPB	B,MC(FRTAB)	;STORE AWAY THE LOCAL.
	JRST	SUCC		;AND WE SUCCEEDED.





;JRST TO DOAG, FRFAL
;PUSHJ TO FRTRUE


^FRTRUE:
	MOVEI	A,2
	ADDM	A,UUO1(USER)	;SKIP OVER THE FALSE CODESSSS.
CPOPJ:	POPJ	P,

^FRFAL:	
^DOAG:
	MOVE	FPD,FPDP(FRTAB)	;RESTORE PUSHDOWN POINTER.
	JRST	GO		;CALL THE RIGHT ROUTINE.


;JRST TO FORGO

^FORGO:
	MOVEI	FP,FREND	;INLINE RETURN FROM FRGO
FRGO:
	AOS	A,FRLOC(USER)	;GET NEXT FOREACH CORE PIECE.
	CAMLE	A,FRLIM(USER)	;MAKE SURE NOT TOO DEEP
	ERR	<FOREACH NESTING TOO DEEP>
	SKIPN	B,(A)		;SEE IF THERE IS CORE THERE.
	JRST	[LPCOR (<FRCHLEN>)
		 MOVEM	B,(A)	;SAVE FOR OTHERS.
		 JRST	.+1]

	MOVEI	A,FPDL-1(B)	;PUSHDOWN LIST.
	HRLI	A,-FPDLEN	;AND LENGTH.
	
	HRRI	C,SATIS(B)	;SATISFIER LIST.
	HRLI	C,(<HLRZ A,(A)>)
	MOVEM	C,MOVEA(B)	;THIS IS THE "UPDATE "A" INSTRUCTION".
	HRLI	C,(<HLRZ B,(B)>)
	MOVEM	C,MOVEB(B)	;AND FOR B.
	HRLI	C,(<POINT 12,(C),17>)
	MOVEM	C,MC(B)		;BYTE POINTER FOR 
				;PUTTING AWAY SATISFIERS.

	PUSH	A,[XWD 0,-1]	;TO CALL FDONE WHEN ALL DONE.
	PUSH	A,@UUO1(USER)	;THIS IS THE JUMP OUT OF THE FOREACH.
	MOVEM	A,FPDP(B)	;AND SAVE THE PUSH-DOWN POINTER.
	JRST	(FP)

FREND:	AOS	C,UUO1(USER)	;INCREMENT OVER JRST WORD.
	MOVEI	D,SATIS+1(B)	;BEGINNING OF SATISFIER TABLE.
	MOVN	A,(C)		; - COUNT OF LOCALS IN THIS LIST.
	MOVEM	A,SCNT(B)	;KEEP TRACK FOR THE POPPING OFF.
LOP:	ADDI	C,1		;THIS COUNTS UP!
	AOJG	A,LDON		;DONE, BY GOOOLLY
	MOVEI	LPSA,@(C)	;GET EFFECTIVE ADDRESS.
				;NOTICE THAT THE PUSH-DOWN POINTER IS IN
				;GOOD SHAPE HERE -- THAT WAY, FORMALS IN
				;THE STACK WORK RIGHT WHEN COMPUTING THE
				;EFFECTIVE ADDRESS.
	HRRZM	LPSA,(D)	;STORE IN RIGHT HALF OF SATISFIER.
	AOJA	D,LOP		;LOOP

LDON:	MOVEM	C,UUO1(USER)	;THE RETURN ADDRESS.
	JRST	LEAV		;AND EXIT.


; FDONE 

FDONE:	PUSH	P,(FPD)		;RETURN ADDRESS.
	SOS	FRLOC(USER)
	POP	P,FP
	POP	P,(P)		;PAST FOREACH RETURN ADDRESS
	JRST	(FP)		;JUMP OUT OF FOREACH STATEMENT.

FDONS:	SOS	FRLOC(USER)
	MOVE	FPD,FPDP(FRTAB)	;WE ARE ABOUT TO LEAVE, SO MAKE
FDX:	MOVE	D,-1(FPD)	;LOOK AT CONTROL WORD.
	SKIPGE	LPSA,-SETP(FPD)	;IF SET NEEDS RECLAIMING
	TLNN	D,SETOP		;THEN DO SO
	JRST	FDY
	MOVE	B,FP1(USER)	;PREPARE TO RECLAIM SET.
	HLRZ	C,(LPSA)
	HRRZM	B,(C)
	HRRM	LPSA,FP1(USER)	;DONE.
FDY:	CAIN	D,-1		;THIS IS THE LAST.
	POPJ	P,		;DONE
	SUB	FPD,[XWD 10,10]
	JRST	FDX		;AND GO FOR MORE.

;PUSHJ TO FRPOP

^FRPOP:
	HRRE	A,SCNT(FRTAB)	;COUNT OF LOCALS.
				;PICKED UP WITH HRRE SINCE THE
				;DEPOSITS OF SATISFIERS FOR "ANY" WILL BE WRONG.
	MOVEI	B,SATIS+1(FRTAB)	;START OF SATISFIERS.
LOPS:	AOJG	A,CPOPJ		;LOOP UNTIL ALL IN CORE.
	MOVE	C,(B)
	HLRZM	C,(C)		;STORE LEFT HALF IN CORE.
	AOJA	B,LOPS



;SOME VARIOUS BOOLEANS


ISIT:				;JRST HERE FOR AOV ?
	JSP	LPSA,NOFOR	;GO GET THINGS SET UP
	PUSHJ	P,@SEROUT-ISBEG+ROUTABLE(FLAG);CALL ROUTINE.
RETNO:	TDZA	A,A		;FAILED
RETYES:	SETOM	A		;SUCCEEDED.
				;RESULT LEFT IN REGISTER 1.
	JRST	LEAV


BRITM:				;JRST HERE FOR BRACKETED ITEM
				;TO BE LEFT ON STACK.
	JSP	LPSA,NOFOR	;GO START THINGS.
BRGO:	MOVE	FLAG,-1(FPD)	;ROUTINE NAME.
	PUSHJ	P,@SEROUT-BSTART+ROUTABLE(FLAG);CALL IT.
	ERR	<NO SUCH BRACKETED ITEM>,1,LEAV
	HLRZ	B,(A)		;VALUE POINTER.
	BRACKN	B		;BRACKETED?
	JRST	BRGO		;NO
	HRRZ	B,(B)		;YES -- THIS IS THE ITEM.
	PUSH	P,B		;ON STACK -- RESULT IS ITEM NUMBER.
	JRST	LEAV		;DONE.....



;JRST TO THESE GUYS.

;ITEM RELATIONS. (EQUAL AND NOTEQUAL)

INE:	SKIPA	D,[CAME B,C]
IEQ:	MOVE	D,[CAMN B,C]	;THE COMPARE INSTRUCTIONS.
	POP	P,C
	POP	P,B
	XCT	D
	JRST	RETYES
	JRST	RETNO




DSCR DERIVED SETS -- NOT IN FOREACH SPECIFICATIONS.

THESE ROUTINES COMPUTE DERIVED SETS.  THEY CALL THE SEARCH
ROUTINES ABOVE, AFTER SETTING UP THE "FIXED" SEARCH CONTROL
BLOCK TO RELECT THE PARTICULAR SEARCH.


;


DERIV:	F2
	F3
AN1TAB:	F6
	F6
AN2TAB:	F7
	F5


INIT2:	
	POP	P,B		;LAST ARG.
	SKIPN	B		;TEST FOR "ANY"
	JRST	[HRRI	FLAG,AN1TAB-DERIV(FLAG); ADJUST ROUTINE NAME.
		 TLO	FLAG,1000 ;COMPLAIN IF ANYANY
		 JRST	.+1]
	PUSH	FPD,B		;ONTO STACK.
	MOVE	C,B
	POP	P,B
	SKIPN	B		;AGAIN IF ANY.
	JRST	[HRRI	FLAG,AN2TAB-DERIV(FLAG);
		 TLNN	FLAG,1000;SEE IF HE LOST.
		 JRST	.+1	;NO...
		 ERR	<ANYANY BITES>]
	PUSH	FPD,B
	MOVE	FRTAB,@LEABOT(USER);FAKE IT UP, GUYS.
	JRST	(FP)



D1:	MOVE	FPD,@LEABOT(USER)
	MOVE	FPD,FPDP(FPD)	;GET PDP FOR CURRENT SEARCH ENTRY ON STACK
	PUSH	FPD,[1]	;FOR VALUE -- RESULT.
	JSP	FP,INIT2	;GO FILL EVERYONE.
	ROT	C,-ITLEN
	LSHC	B,-ITLEN
	JRST 	DOIT		;READY TOGO


D2:	MOVE	FPD,@LEABOT(USER)
	MOVE	FPD,FPDP(FPD)	;SEE ABOVE
	JSP	FP,INIT2
	MOVEI	A,1
	EXCH	A,(FPD)
	PUSH	FPD,A		;CHANGE ORDER OF ARGS.
	LSH	C,ITLEN
	LSHC	B,-ITLEN
;	JRST	DOIT




DOIT:	PUSH	FPD,C
	PUSH	FPD,[-1]	;FOR -TT1(FPD)
	PUSH	FPD,[0]		;WORK ROOM
	PUSH	FPD,[0]		;WOULD HAVE BEEN ROUTINE NAME
	PUSH	FPD,FLAG	;THIS IS ROUTINE NAME.
	PUSH	P,[0]		;THE SET WE WILL ACCUMULATE.
AGS:	PUSHJ	P,@DERIV-DSTART+ROUTABLE(FLAG);CALL THE SEARCH
	 JRST	 [HLRZ A,(P)	;FAILED, AND DONE!
		 MOVNS A	;CHANGE COUNT TO NEGATIVE 
				;TO INDIC. TEMP.
		 HRLM A,(P)
		 JRST LEAV]
	HLRZ	A,SATIS+1(FRTAB)
	MOVEI	TAC1,(P)	;PLACE OFSET
	PUSH	P,A		;ITEM FOR ENTY.
	PUSHJ	P,ENTY		;IN PUTIN
	MOVE	FLAG,(FPD)
	JRST	AGS		;LOOP UNTIL DONE.

LD3:	SUB	P,X11
D3:	SUB	P,X22
	ERR	<P * Q NOT IMPLEMENTED>,1
	JRST	LEAV


DSCR MAKE AND ERASE
THESE ARE THE ROUTINES TO MAKE AND ERASE ASSOCIATIONS IN THE 
ASSOCIATIVE STORE.  THE BIGGEST HAIR IN THESE ROUTINES HAS
TO DO WITH MULTIPLE VALUES.  "MAKE" MAY HAVE TO EXPAND
A SINGLE ASSOCIATION INTO A MULTIPLE VALUE CONFIGURATION,
AND "ERASE" MAY HAVE TO CONTRACT IT.  THE CONTRACTION MAY
INVOLVE MOVING ASSOCIATIONS AROUND, WHICH IN TURN REQUIRES
UPDATING CURRENT FOREACH POINTERS HELD IN VARIOUS PLACES
(I.E.  IN THE FPD STACKS OF THE SEARCH CONTROL BLOCKS).

MAKE AND ERASE ARE BOTH CALLED WITH THE THREE TOP OF STACK
ELEMENTS BEGIN THE ATTRIBUTE, OBJECT, AND VALUE PASSED
AS ARGUMENTS.

MAKE AND ERASE HAVE A "BREAKPOINT" FACILITY, FOR ACTIVATING
A SAIL PROCEDURE EACH TIME AN ASSOCIATION IS MADE OR ERASED.
THE A, O, AND V ARE PASSED BY VALUE IN THE STACK TO THE
BREAKPOINT ROUTINE.

MAKE -- CALLED WITH PUSHJ.
ERASE -- JRST TO IT; IT WILL JRST TO LEAV.
BMAKE -- JRST TO IT; IT WILL JRST TO LEAV. (BRACKETED TRIPLE MAKE).

;


;PUSHJ TO MAKE
; ON EXIT, "PNT" MUST POINT TO THE ASSOCIATION CREATED.

MAKE:
	SKIPE	C,MKBP(USER)	;MAKE BREAK-POINT?
	 PUSHJ	 P,LPBRK1	;GO TO A BREAKPOINT !
	MOVE	FP,FP2(TABL)
	MOVE	PNT,FP		;THIS IS THE ONE WE WILL USE.
	SETZM	C		;FOR MAKING UP THE MAGIC WORD.
	MOVE	B,-2(P)		;OBJECT.
	LSHC	B,-ITLEN
	MOVE	B,-3(P)		;ATTRIBUTE
	LSHC	B,-ITLEN	; A-O-0 IS IN C.
	HASH	(A,<-3(P)>,<-2(P)>)
AG:	SKIPN	B,1(A)		;IS THERE AN EMPTY SPACE IN HASH AREA?
	 JRST	 EASY		;YES
	TRZ	B,7777
	CAMN	B,C		;SAME AS THE ONE WE ARE PUTTING IN?
	 JRST	 DONE		;YES -- MODULO MULTIPLE HITS.
	MOVE	D,A		;REMEMBER WHO POINTS TO US.
	HRRZ	A,(A)		;GO DOWN CONFLICT LIST.
	JUMPN	A,AG		;GO UNTIL END
	SKIPN	FP,(FP)		;NOW TACK ONE WORD ONTHE END.
	 PUSHJ	 P,FP2DON
	SETZB	LPSA,(PNT)	;ZERO FIRST WORD OF ASS. CELL.
	HRRM	PNT,(D)		;LINK CONFLICT.
GOM:	IOR	C,-1(P)		;GET VALUE THERE
	MOVEM	C,1(PNT)	;AND STORE A-O-V
	MOVE	C,-1(P)		;GET VALUE AGAIN.
	ADD	C,INFOTAB(TABL)	;NEED TO UPDATE VALUE LINK
	HLRZ	D,(C)		;OLD ONE
	HRLM	D,(PNT)		;STORE IN VALUE SPOT
	HRLM	PNT,(C)		;AND UPDATE INFO TABLE.
	MOVEM	FP,FP2(TABL)	;SAVE NEW FREE POINTER.
OUT111:	SUB	P,[XWD 4,4]
	JRST	@4(P)		;RETURN, AFTER ADJUSTING STACK.

OUT1AX:	SKIPA	PNT,B
OUT1:	MOVE	PNT,A
	JRST	OUT111		;MUST HAVE PNT POINTING 
				;TO THING WE MADE.

EASY:	MOVE	PNT,A
	JRST	GOM		;PUT IT THERE.


DONE:	MOVE	B,1(A)		;AT LEAST A AND O MATCH TO GET HERE.
	TRNN	B,7777		;MULTIPLE VALUES?
	JRST	MULVAL		;YES
	ANDI	B,7777
	CAMN	B,-1(P)		;COMPARE WITH SPECIFIED VALUE
	JRST	OUT1		;IT IS ALREADY THERE!!!
	SKIPN	FP,(FP)		;MUST NOW MAKE A MULTIPLE VALUE GUY
	 PUSHJ	P,FP2DON
	MOVE	D,(A)		;FIRST WORD OF OLD ASS. CELL
	HLLZM	D,(PNT)		;SAVE IT.(ONLY VALUE POINTER)
	HRL	D,PNT		;NEW POINTER
	MOVEM	D,(A)		;IN OLD CELL.
	MOVE	D,1(A)
	MOVEM	D,1(PNT)
	PUSH	P,D		;SAVE FOR LATER
	TRZ	D,7777
	MOVEM	D,1(A)		;NEW A-O-0 FOR HEADER.
	POP	P,D
	ANDI	D,7777		;JUST VALUE
	ADD	D,INFOTAB(TABL)	;POINTER TO GOOD BITS.
RTNQ:	HLRZ	LPSA,(D)		;VALUE POINTER
	JUMPE	LPSA,[ ERTMAK:ERR <DRYROT -- MAKE>]
	BRACKP	LPSA
	JRST	[MOVE D,LPSA
		 HLRZ LPSA,(LPSA)	;BYPASS BRACKETED TRIPLE.
		 JRST .+1]
	CAIE	LPSA,(A)		;POINTING AT OUR MAN?
	JRST	[MOVE	D,LPSA
		 JRST RTNQ]
	HRLM	PNT,(D)		;CHAIN THINGS RIGHT.
	MOVE	PNT,FP
	JRST	MULINS		;INSERT NEW ONE AS PART OF MULTIPLE HIT.

MULVAL:	HLRZ	B,(A)		;PICK UP POINTER TO MULT. VALS.
IN1:	MOVE	D,1(B)		;PICK UP A-O-V
	ANDI	D,7777		;SAVE ONLY VALUE
	CAMN	D,-1(P)		;THE RIGHT VALUE?
	JRST	OUT1AX		;YES -- IT'S THERE
	HRRZ	B,(B)		;GET NEXT POINTER
	JUMPN	B,IN1		;LOOP

MULINS:	SKIPN	FP,(FP)		;WE NEED A CELL
	 PUSHJ	 P,FP2DON
	HLR	B,(A)		;POINTER TO MULL VALS.
	HRRM	B,(PNT)		;POINTER ON DOWN.
	HRLM	PNT,(A)		;NEW POINTER TO VALS.
	JRST	GOM


;JRST TO BMAKE

BMAKE:				;BRACKETED MAKE.......;;
	PUSHJ	P,MAKE		;GO MAKE IT..
	HLRZ	A,(PNT)		;VALUE POINTER
	BRACKP	A		;IS IT ALREADY A BRACKETED?
	JRST	INALREADY	;YES
	MOVE	FP,FP1(TABL)	;ONE-WORD FREES.
	MOVEI	D,(FP)
	MOVEI	C,(FP)		;LOTS NEED TO KNOW.
	SKIPN	FP,(FP)
	 PUSHJ	P,FP1DON	;OUT OF FREE STORAGE.
	HRRM	FP,FP1(TABL)
	TRC	C,BRABIT	;TURN IT ON.(LOGICALLY)
	HRLM	C,(PNT)
	HRLM	A,(D)		;PUT OLD POINTER IN NEW ONE-WORD FREE
	PUSHJ	P,NEWX		;GET A NEW ITEM.....
	MOVE	B,(P)		;ITEM NUMBER.
	HRRM	B,(D)		;PUT ITEM NUMBER IN FREE.
	ADD	B,INFOTAB(TABL)	;PREPARE TO MAKE VALUE ENTRY.
	MOVE	FP,FP2(TABL)
	DPB	FP,[POINT 17,(B),35];AVOID DISTURBING LPARRAY.
	MOVE	C,1(PNT)	;A-O-V WORD FROM MAKE.
	MOVEI	PNT,(FP)	;POINTER TO FREE.
	MOVEM	C,1(FP)		;INTO RANDOM GOOD WORD.
	SKIPN	FP,(FP)		;GET NEXT ONE
	 PUSHJ	P,FP2DON	;ALL OUT
	MOVEM	FP,FP2(TABL)	;RESTORE IT.
	SETZM	(PNT)		;ZERO FIRST WORD OF NEW FREE.
LEAVS:
	JRST	LEAV


INALREADY:
	HRRZ	B,(A)		;ITEM NUMBER....
	PUSH	P,B
	JRST	LEAVS
;PUSHJ, TO ERASE

ERASE:
	POP	P,PNT		;SAVE RETURN ADDRESS.
	JSP	LPSA,NOFOR	;IN LINE CALL
	PUSH	P,PNT
TRY:	MOVE	FLAG,-1(FPD)	;ROUTINE NAME.
	PUSHJ	P,@ETAB-ESTART+ROUTABLE(FLAG);GET THE RIGHT SEARCH
	 JRST	 LVSEC		;DONE... (IT FAILED)

	SKIPE	C,ERBP(USER)	;ERASE BREAK-POINT?
	 PUSHJ	 P,LPBRK	;A LEAP BREAK POINT !!!
	HRRZ	B,1(A)		;A POINTS TO ASS. CELL
	TRZ	B,770000	;NOW WE HAVE THE VALUE
	ADD	B,INFOTAB(TABL)	;NONO
GOE:	HLRZ	C,(B)		;VALUE LINK.
	BRACKP	C		;TEST FOR BRACKETED TRIPLE
	JFCL			;MACROS FORCE ONE OCCASIONALLY TO PARANOIA
	CAIN	C,(A)		;THE VERY SAME?
	JRST	YESE		;WE HAVE IT
	MOVE	B,C		;REMEMBER WHERE WE CAME FROM
	JUMPN	B,GOE
	ERR	<DRYROT -- ERASE>

YESE:	HLRZ	C,(A)		;AGAIN
	BRACKN	C		;A BRACKETED TRIPLE?
	JRST 	Y1		;NO
	MOVE	FP,OLDITM(TABL)	;PREPARE TO LINK ON LIST.
	MOVE	D,(C)		;THE ONE-WORD CELL
	HRL	FP,D		;ITEM NUMBER
	MOVEM	FP,(C)		;THIS IS THE THE OLD ITEM LIST.
	HRRZM	C,OLDITM(TABL)
	AOS	FREITM(TABL)	;COUNT THE NUMBER FREE
	ADD	D,INFOTAB(TABL)	;GET POINTER TO VALUESSS
	HRRZ	LPSA,(D)	;POINTER TO BRACKET INFO.
	TRZ	LPSA,LPARRAY	;IN CASE DATUM IS ARRAY.
	TRNN	LPSA,377777
	ERR	<DRYROT -- BRACKET CONFUSION>
	MOVE	FP,FP2(TABL)	;PREPARE TO FREE A CELL.
	HRRZM	FP,(LPSA)	;LINK IT IN
	MOVEM	LPSA,FP2(TABL)	;RELEASE BLOCK
	SETZM	(D)
	MOVSS	D
	SKIPA
Y1:	HLRZ	D,(A)		;OLD POINTER ELSEWISE
Y2:	HRLM	D,(B)		;CHAIN NEW VALUE LINK.
	LDB	C,[POINT ITLEN,1(A),ITLEN-1];ATTRIBUTE
	LDB	D,[POINT ITLEN,1(A),2*ITLEN-1];OBJECT
	HASH	(B,C,D)
	MOVE	C,1(A)		;PICK UP THE WORD WE SEARCH FOR
	TRZ	C,7777		;AND TURN OFF VALUE.
	CAMN	B,A		;DO WE POINT THERE ALREADY?
	 JRST	 HASHSPACE	;YES!!

LOOK:	CAIN	B,(A)		;DO WE POINT THERE?
	JRST	THISIT		;YES
	MOVE	D,1(B)		;GET A-O-V
	CAMN	D,C
	JRST	MULVLL		;A-O MATCH AT LEAST
	MOVE	LPSA,B		;REMEMBER WHO POINTED AT US
	HRRZ	B,(B)		;GO DOWN CONFLICT LIST.
	JUMPN	B,LOOK		;AND LOOP
	ERR	<DRYROT -- ERASE>

HASHSPACE:
	HRRZ	D,(A)		;GET CONFLICT POINTER
	JUMPE	D,VALFIX	;NOTHIN TOIT
	MOVE	B,A		;AH SO MANY ACCUMULATORS !
	MOVE	C,(D)		;MOVE THE FIRST WORD
	MOVEM	C,(B)		;INTO THE HASH AREA, AND THEN
	PUSHJ	P,LST1		;GO FINISH THE MOVE AND CHECK VALUE LINKS.
	JRST	TRY		;AND FOR MORE.

VALFIX:	SETZM	(A)		;NOT A CARE IN THE WORLD.
	SETZM	1(A)
	JRST	TRY

THISIT:	HRRZ	B,(A)		;CONFLICT
	HRRM	B,(LPSA)	;BYPASS AROUND US.
	JRST	LINK		;RECLAIM THE WORD OF CORE.

MULVLL:	SETZM	LPSA		; A COUNTER
	HLRZ	C,(B)		;POINTER TO MULTIPLE HITS.
	CAIN	C,(A)		;IS THIS IT?
	JRST	FIST		;-- YESS AND THEFIRST ONE.
M1:	MOVE	D,C		;THIS IS WHO POINTS AT US.
	HRRZ	C,(C)		;GET NEXT MULTIPLE HIT.
	CAIE	C,(A)
	AOJA	LPSA,M1		;LOOP UNTIL FOUND
ITER:	HRRZ	C,(A)		;DOWN POINTER TO MOREHITS.
	JUMPN	LPSA,NOCHK		;IF THERE WAS AT LEAST ONE, FORGET 
	JUMPE	C,LST		;THIS IS THE LAST.
NOCHK:				;BY PASS US ON THE MULVAL LINKS.
	HRRM	C,(D)
	JRST	LINK		;PUT OLD ASSOC CELL ON FREE STORAGE LIST.


FIST:	HRRZ	D,(A)		;NEXT IN LINE...
	HRLM	D,(B)		;INSTALL IN HEADER
	HRRZ	C,(D)		;DOES THE NEXT GUY FINISH OUT?
	JUMPN	C,LINK		;NO -- LINK UP ON FREES AND RETURN.

;COMPACTION OF SOME SORT IS REQUIRED IF WE COME HERE.
;EITHER (1) A MULTIPLE VALUE GUY IS BEING COLLAPSED, OR
;(2) A HASH-SPACE ENTRY HAS BEEN DELETED, AND ITS NEXT
;CONFLICTER MUST BE MOVED INTO THE HASH SPACE.
; D  LAST CELL, FULL OF GOOD THINGS. THIS IS THE ONE
;	WHICH WILL BE RECLAIMED.
; B  PLACE WHERE NEW CELL WILL BE LOCATED.  ANY REFERENCES
;	TO CONTENTS OF D THAT ARE IN THE FOREACH STACKS
;	SHOULD BE CHANGED TO B

LST:	HLRZ	C,(D)		;VALUE LINK
	HRLM	C,(B)		;NOW IN TOP
	PUSHJ	P,LST1		;FINISH MOVE (THIS IS A SUBROUTINE).
LINK:	MOVE	FP,FP2(TABL)
LINKA:	HRRZM	FP,(A)
	MOVEM	A,FP2(TABL)	;BIGGER FREE STORAGE LIST.
	JRST	TRY


LST1:	MOVE	C,1(D)		;A-O-V
	MOVEM	C,1(B)		;NOW IN TOP
	ANDI	C,7777		;VALUE NUMBER
	JUMPE	C,RELK		;THIS IS A MULTIPLE VALUE GUY.
	ADD	C,INFOTAB(TABL)
REL1:	HLRZ	LPSA,(C)	;GO LOOK FOR VALUE POINTER
	BRACKP	LPSA
	HLRZ	LPSA,(LPSA)	;TEST FOR AN BYPASS BRACKETED TRIPLE.
	CAIN	LPSA,(D)	;WHICH POINTS TO THING WE JUST
	JRST	[HRLM B,(C)	;MOVED
		JRST RELK]
	MOVE	C,LPSA
	JUMPN	C,REL1
	ERR	<DRYROT -- ERASE>
RELK:	CAMN	D,-T2(FPD)	;SEE IF A POINTER TO THIS GUY WAS
	MOVEM	B,-T2(FPD)	;STORED DURING SEARCH. IF SO -- UPDATE.
;HERE IS THE SHIT THAT IS NEEDED WHEN YOU HAVE RANDOM POINTERS LYING AROUND
;IN THE FOREACH TABLES.
	MOVE	C,LEABOT(USER)	;ADDRESS OF BASE OF TABLES.
	PUSH	P,FRLOC(USER)	;SAVE CURRENT FRLOC
	PUSH	P,C
FF22:	SOS	C,FRLOC(USER)	;GET ENTRY
	CAMG	C,(P)		;IN RANGE?
	 JRST	 [POP P,(P)	;THROW AWAY.
		  POP	P,FRLOC(USER)
		  JRST RELK1]
	MOVE	C,1(C)		;THIS IS A FRTAB
	MOVE	LPSA,FPDP(C)	;FPDP (FRTAB)
FF11:	HRRE	PNT,-1(LPSA)	;ROUTINE #
	JUMPL	PNT,FF22	;-1,  ALL DONE.
	CAMN	D,-T2(LPSA)
	MOVEM	B,-T2(LPSA)	;ALL FOR THIS ONE FIXUP.
	SUB	LPSA,[XWD 10,10]
	JRST	FF11

;END OF SHIT

RELK1:	MOVE	FP,FP2(TABL)	;PUT "D" BACK ON FS LIST.
	HRRZM	FP,(D)
	HRRZM	D,FP2(TABL)	;RELEASED THIS ONE.
	POPJ	P,		;END OF LST1 SUBROUTINE.


LVSEC:				;ALL DONE.
	POPJ	P,

; LEAP BREAKPOINTS EXIST.  
; ENTRY IS WITH ROUTINE ADDRESS IN C.


LPBRK:	PUSH	P,A		;ENTRY FROM ERASE.
	PUSH	P,FPD		;A  ASSOCIATION TO BE ERASED.
	LDB	B,[POINT 12,1(A),11]
	PUSH	P,B
	LDB	B,[POINT 12,1(A),23];OBJECT
	PUSH	P,B
	LDB	B,[POINT 12,1(A),35];VALUE
	PUSH	P,B
	PUSH	P,B		;STACKS NEED TO BE EQUAL.
	PUSHJ	P,LPBRK1	;GO DO IT.
	SUB	P,[XWD 4,4]	;ALL GONE.
	POP	P,FPD
	POP	P,A
	POPJ	P,

LPBRK1:				;ENTRY FROM MAKE.
	HRL	TEMP,@LEABOT(USER)
	ADD	P,[XWD =86,=86]
	SKIPL	P		;SEE IF WE OVERFLEW THE STACK.
	 PDLOF			;YES, SIGH.
	HRRI	TEMP,-=85(P)
	BLT	TEMP,(P)	;SAVE WORK AREA. SINCE PNAME NEEDS IT.
	PUSH	P,FLAG
	PUSH	P,UUO1(USER)
	PUSH	P,-6-=86(P)	;ATTRIBUTE
	PUSH	P,-6-=86(P)	;OBJECT
	PUSH	P,-6-=86(P)	;VALUE
	PUSHJ	P,(C)		;CALL ROUTINE
	MOVE	USER,GOGTAB	;SET UP AGAIN.
	POP	P,UUO1(USER)
	SUB	P,[XWD =87,=87];REMOVE OLD FLAG AND OLD SCB
	HRLI	TEMP,1(P)
	HRR	TEMP,@LEABOT(USER)
	HRRI	FLAG,=85(TEMP)
	BLT	TEMP,(FLAG)	;RESTORE OLD SCB
	MOVE	FLAG,=87(P)	;RETRIEVE FLAG
	POPJ	P,


INTERNAL BRKERS,BRKMAK	;BREAKPOINT FOR ERASE,BREAKPOINT FOR MAKE.

HERE (BRKERS)	
	SKIPA	TEMP,[ERBP]
HERE (BRKMAK)
	MOVEI	TEMP,MKBP;THE POSITIONS.
	ADD	TEMP,GOGTAB;HO HO.
	POP	P,USER
	POP	P,(TEMP);SUBROUTINE NAME.
	JRST	(USER)



DSCR ISTRIPLE, SELECTOR
;


; INITIALIZATION ROUTINE FOR THE ROUTINES THAT FOLLOW.
;ALL THESE ROUTINES ARE JRSTED TOOOOOOO...

INIT1:	
	MOVE	B,-2(P)		;ARGUMENT
;	TLNE	FLAG,BOUNDATTPOS
;	XCT	MOVEB(FRTAB)
	ADD	B,INFOTAB(TABL)	;READY FOR ALL SORTS OF INFO.
	POPJ	P,

; ISTRIPLE

ISTRIPLE:
	PUSHJ	P,INIT1
	HRRZ	A,(B)		;POINTER TO INFO CELL
	TRZ	A,LPARRAY	;TURN OFF ARRAY BIT.
	JUMPE	A,NOR		;NONE THERE
	SETOM	A		;SAY YES
NOR:	
RET:	SUB	P,X22
	JRST	@2(P)


SELECTOR:			;FOR COMPUTING FIRST,SECOND,THIRD.
	PUSHJ	P,INIT1
	HRRZ	C,(B)
	TRZ	C,LPARRAY	;NOW HAS POINTER IN IT.
	JUMPE	C,ERR1		;SELECT CALLED ON BAD THINGS.
	MOVE	B,1(C)		;GET A-O-V GUY.
	TRNN	B,-1
ERR1:	ERR	<NOT A BRACKETED TRIPLE>,1
	SUBI	FLAG,SELET1-ROUTABLE-2
	TRNE	FLAG,1
	LSH	B,ITLEN
	TRNE	FLAG,2
	LSH	B,-(2*ITLEN)
	ANDI	B,7777		;A FULL-FLEDGED ITEM
	MOVEM	B,-1(P)		;STORE IT AS A RETURNED VALUE
	POPJ	P,


DSCR DELETE, NEW (VARIOUS KINDS), AND ARRAY ITEM CODE.

DELETE -- ITEM PASSED IN STACK. IT IS DELETED. THIS INVOLVES
	COPYING IT ONTO THE "RECENT FREE ITEM" LIST,
	REMOVING ITS PRINTNAME IF ANY, RELEASING THE
	ARRAY WHICH WAS ITS DATUM IF THAT WAS THE CASE,
	AND PERHAPS DOING AN "ERASE" ON THE BRACKETED 
	TRIPLE THAT IT REPRESENTED.

NEW AND NEWX -- RETURN WITH THE STACK BUMPED BY ONE, AND
	THE TOP OF STACK HAS A SHINY NEW ITEM.  THE
	DATUM ENTRY IS ZEROED.  THE INFOTAB ENTRY IS NOT
	ZEROED -- THIS IS IMPORTANT TO THE WORKING OF PNAMES.

NEWART -- CALL IS WITH ARITHMETIC VALUE IN STACK.
	RETURNS A NEW ITEM NUMBER, WITH ARITHMETIC VALUE
	STUFFED IN DATUM ENTRY.

NEWARY -- CALL IS WITH ARRAY DESCRIPTOR IN STACK.
	RETURNS A NEW ITEM NUMBER, WITH DESCRIPTOR OF
	COPIED ARRAY STUFFED IN DATUM ENTRY.

;



DELETE:				;JRST TO DELETE....
	SKIPG	HASHP(USER)	;IF THERE ARE PRINTMAES.
	 JRST	 NOPRN		;NO
	PUSH	P,FLAG		;DEL.PN CLOBBERS THIS
	PUSH	P,UUO1(USER)	;SAVE RETURN ADDRESS.
	PUSH	P,-2(P)		;ITEM NUMBER.
	PUSHJ	P,DEL.PNAME	;DELETE THE PNAMES.
	POP	P,UUO1(USER)	;AND RESTORE IT.
	POP	P,FLAG		;RESTORE FLAG
NOPRN:
	MOVE	A,(P)		;ITEM NUMBER
	SKIPN	B,OLDITM(TABL)	;ANY OTHER ITEMS THERE ?
	JRST	GOHEDL		;NO -- GO AHEAD AND DELETE
LISDEL:	HLRZ	C,(B)		;GET ITEM NUMBER
	HRRZ	B,(B)		;...
	CAMN	C,A		;SAME ITEM?
	JRST	ALDDD		;YES -- DO NOTHING.
	JUMPN	B,LISDEL	;GO DOWN LIST.
GOHEDL:				;NOT FOUND.
	ADD	A,INFOTAB(TABL)
	PUSH	P,A		;SAVE THE ADDRESS.
	HRRZ	B,(A)		;POINTER TO DATUM WORD.
	TRZN	B,LPARRAY	;WAS THIS AN ARRAY?
	JRST	NOARRY
	PUSH	P,B
	MOVEI	LPSA,ARYLS(USER)	;LINKED LIST OF ARRAYS.
	MOVE	C,ARYLS(USER)
	HLRZ	D,(C)		;ITEM NUMBER.
	CAME	D,-2(P)		;IS THIS THE ONE?
	JRST	[MOVE	LPSA,C
		 HRRZ	C,(C)	;GO DOWN LIST.
		 JUMPN	C,.-2	;GO AHEAD
		 ERR	<ARRAY ITEM CONFUSION>]
	MOVE	B,1(C)		;THIS IS THE REAL CORE BLOCK ADDRESS
	HRR	D,(C)		;FOR THE ARRAY. NOW RELEASE THE BLOCK
	HRRM	D,(LPSA)	;FROM THE LINKED LIST.
	MOVE	D,FP2(USER)	;AND PUTIT BACK ON FREE STORAGE.
	HRRZM	D,(C)
	HRRZM	C,FP2(USER)
RELGO:	PUSHJ	P,CORREL	;RELEASE ARRAY CORE STORAGE.
	POP	P,B
NOARRY:
	JUMPE	B,NOBRACK	; NO BRACKETED TRIPLE
	PUSH	P,FLAG
	MOVE	C,1(B)		;A-O-V OF BRACKETED ITEM
	SETZM	B
	LSHC	B,ITLEN
	PUSH	P,B		;ATTRIBUTE
	SETZM	B
	LSHC	B,ITLEN
	PUSH	P,B		;OBJECT
	SETZM	B
	LSHC	B,ITLEN
	PUSH	P,B		;VALUE
	MOVEI	FLAG,ESTART-ROUTABLE;ERASE AOV
	PUSHJ	P,ERASE
	POP	P,FLAG
	SETOM	-1(P)		;SAY THAT ITEM NUMBER HAS
				; BEEN LINKED ALREADY.
NOBRACK:	
	POP	P,C		;ADDRESS OF INFOTAB ENTRY.
	MOVS	B,(P)		;ITEM NUMBER
	SKIPG	B
	JRST	DRET
	MOVE	FP,FP1(TABL)	;NEED TO MAKE A "FREE ITEM" CELL
	MOVE	PNT,FP
	SKIPN	FP,(FP)
	 PUSHJ	P,FP1DON
	HRRM	FP,FP1(TABL)	;SAVE POINTER
	HRR	B,OLDITM(TABL)
	MOVEM	B,(PNT)
	MOVEM	PNT,OLDITM(TABL) ;UPDATE POINTER.
	AOS	FREITM(TABL)	;COUNT NUMBER FREE
NONAM:
DRET:	HLLZS	(C)		;ZERO INFOTAB ENTRY.
				;NOT LEFT HALF SINCE PRINTNAMES MAY BE
				;STILL IN THE WORLD.
ALDDD:	POP	P,A		;PAST ITEM NUMBER
	JRST 	LEAV		;ALL FINISHED.

NEW:				;GET A NEW ITEM NUMBER.
NEWX:
	SKIPN	C,OLDITM(TABL)	;SEE IF ANY DUSTY OLD ITEMS.
	JRST	[
		AOS	C,MAXITM(USER);USE LOCAL ITEM NUMBER.
		CAMGE	C,ITMTOP(USER);IF GONE TOO HIGH. THEN
		 JRST REITM
		ERR	<ITEM SPACE EXHAUSTED>]
	MOVS	C,(C)
	HLRZM	C,OLDITM(TABL)	;UPDATED POINTER.
	ANDI	C,TOPITM	;ITEM NUMBER.
REITM:	
	SOS	FREITM(TABL)	;ONE LESS FREE
	SETZM	@DATM		;ZERO THE DATUM.
	EXCH	C,(P)		;RECORD ANSWER
				;IN STACK.
	JRST	(C)		;EXIT.

NEWART:		;PUSHJ HERE FOR NEW WITH ARITHMETIC TYPE
	POP	P,FRTAB		;RETURN ADDRESS.
	POP	P,FPD		;VALUE
	PUSHJ	P,NEWX		;GET NEW ITEM
	MOVE	PNT,(P)
	ADD	PNT,DATAB(TABL)
	MOVEM	FPD,(PNT)	;DATUM...
	JRST	(FRTAB)		;RETURN.


NEWARY:				;JRST HERE
	PUSHJ	P,ARCOP		;COPIES THE ARRAY IN -1(P)
				;RETURNS POINTER IN A
				;AND CORGET TYPE POINTER IN ARRAY STACK.
	PUSHJ	P,NEW		;GET A NEW ITEM.
				;ITEM IS ON TOP OF STACK.
	MOVE	PNT,(P)		;ITEM NUMBER
	JSP	FPD,ARYL	;MARK AN ARRAY; LINK INTO ARYLS.
	JRST	LEAV



;THIS IS THE "NEW ARRAY" CODE.  
;THIS MAKES ARRAYS FOR ITEMS AND PUTS THE DESCRIPTOR IN THE
;DATUM TABLE

ITMYR:	HLRZ	A,TEMP		;LEFT OVER FROM HRLI FOR
	POP	P,PNT		;ITEM NUMBER.
	MOVEI	FPD,LEAV	;IN LINE CALL.
	JRST	ARYPUT		;COMPILED IN ARRAY.
ITMRY:				;THIS GUY DOES A LOT MORE NOW.
	MOVE	C,UUO1(USER)	;RETURN ADDRESS SINCE ARMAK WILL DESTROY.
	POP	P,B		;ITEM NUMBER.....
	MOVE	D,B		;ITEM NUMBER
	ADD	B,DATAB(TABL)	;NOW INDEX TO DATUM.
	PUSHJ	P,ARMAK		;MAKE AN ARRAY
				;RETURNS DESCRIPTOR IN A.
	MOVEM	A,(B)		;AND RECORD ANSWER SINCE AC B WAS SAVED.
	MOVEM	C,UUO1(USER)	;AND PUT THIS BACK.
	MOVE	PNT,D		;IT WAS AN ARRAY ITEM -- THIS IS THE ITEM
	MOVEI	FPD,LEAV	;IN LINE CALL.

;STUFF BELOW IS CALLED AS  SUBROUTINE.
;  ARYL RECORDS THE ARRAY ON TOP OF ARRPDP IN THE LINKED
;  LIST OF ARRAY DATUMS.
;  IT ALSO SETS UP THE DATUM AND INFOTAB ENTRIES CORRECTLY.

;INPUT --- A     HAS THE ARRAY DESCRIPTOR
;	   -1(P) HAS THE ITEM NUMBER (PASSED AS PARAM).

ARYL:	MOVE	B,ARRPDP(USER)	;ARRAY STACK.
	POP	B,(B)		;THIS IS THE ARRAY.
	MOVEM	B,ARRPDP(USER)
	MOVE	C,FP2(USER)	;FOR ARRAY LISTS
	SKIPN	FP,(C)
	 PUSHJ	 P,FP2DON
	MOVEM	FP,FP2(USER)
	HRRZ	D,PNT		;ITEM NUMBER
	HRL	D,ARYLS(USER)	;CURRENT LINKED LIST OF ARRAYS.
	MOVSM	D,(C)		;IN NEW BLOCK.
	HRRZM	C,ARYLS(USER)	;AND UPDATE LIST
	MOVE	B,1(B)		;PICK UP CORGET POINTER.
	MOVEM	B,1(C)		;AND THE ARRAY LOCATION.
NOGLH:
ARYPUT:	HRRZ	B,PNT		;ITEMNUMBER
	ADD	B,DATAB(TABL)	;POINTER TO DATUM
	MOVEM	A,(B)		;PUT DOWN DESCRIPTOR.
	HRRZ	B,PNT		;ITEM NUMBER AGAIN.
	ADD	B,INFOTAB(TABL)	;POINTER TO GOOD BITS.
	MOVEI	C,LPARRAY
	IORM	C,(B)		;TO TELL THE WORLD.
	JRST	(FPD)		;RETURN.



DSCR SET AND ITEM STORING OPERATIONS.

IF THE TOP OF THE STACK IS AN ITEM, WE OCCASIONALLY CALL
"STORE" TO STORE IT INTO SOME CORE LOCATION.  THE COMPILER
SHOULD BE FIXED TO SIMPLY "POP" THE THING OFF INTO THE RIGHT
SPOT.

HOWEVER, IF THE TOP OF THE STACK IS A SET, WE REALLY DO NEED
TO DO SOME SCREWING AROUND.  HENCE, CALLING "STORE" IS MORE
OR LESS NEEDED.

ALL ENTRIES NEED: TAC1  HAS ADDRESS OF TARGET LOCATION.
	IF LH (TAC1) = -1, THEN THE TARGET IS A SET DESCRIPTOR.

THE VARIOUS ENTRIES ARE:

STORITM	-- MAIN STORE ROUTINE. STORE ITEM OR SET ON TOP OF
		STACK. SUBTRACT STACK WHEN DONE.
POPTOP  -- STORE TOP OF STACK (MUST BE ITEM) INTO AC 1.
POPSET  -- STORE TOP OF STACK (MUST BE SET)  INTO AC 1.

STORBUTDONTREMOVE -- SAME AS STORITM, BUT STACK IS NOT 
		SUBTRACTED.

SETCOP  -- THE SET AT THE ADDRESS SPECIFIED BY TAC1 IS
		COPIED OVER INTO ITSELF.  THIS IS FOR SETS
		PASSED AS VALUE PARAMETERS TO PROCEDURES.  IF 
		THE ACTUAL IS A "TEMP SET", THEN NO ACTUAL
		COPY IS MADE.  THE INVERSE OF SETCOP IS:
SETRCL  -- RECLAIM THE SET POINTED TO BY TAC1.  THE STORAGE
		IS LINKED BACK ON THE FREE STORAGE LIST.

;




SETCOP:	PUSH	P,(TAC1)	;THE SET TO BE COPIED.
	TLZ	TAC1,777
	JRST	SETGO		;ALWAYS RECOPY.


POPSET:	SETZM	RACS+1(USER)	;TO MAKE TARGET SET LOOK NULL.
	HRROI	TAC1,RACS+1(USER)
	JRST	STORITM

POPTOP:				;POP OFF TOP OF STACK.
	MOVEI	TAC1,RACS+1(USER)
	SKIPA
STORBUTDONTREMOVE:
	TLOA	TAC1,777	;THESE BITS WILL TELL US WHETHER
STORITM:			;TO ADJUST THE STACK ON EXIT.
	TLZ	TAC1,777
	JUMPL	TAC1,SETSTOR
	MOVE	B,(P)		;ITEM ARGUMENT.
	TLNE	FLAG,BOUNDATTPOS
	XCT	MOVEB(FRTAB)	;FOR IMBEDDED STORES IN FOREACHES.
	MOVEM	B,(TAC1)	;STORE IT.
	JRST	DECIDE		;ARRANGE STACK ACCORDINGLY.

SETSTOR:			;SET IS TO BE STORED.
	SKIPE	A,(TAC1)	;IS OLD SET THERE?
	CAMN	A,(P)		;IF NULL SET, OR SAME AS ON STACK.
	 JRST	 SETGO		;DO NOT RECLAIM OLD ONE.
	MOVE	FP,FP1(TABL)
	HLRZ	B,(A)		;RECLAIM STORAGE
	HRRM	FP,(B)
	HRRM	A,FP1(TABL)	;VERY FAST !
SETGO:
	SKIPGE	A,(P)		;GET ARGUMENT.
	JRST	TEMPSET		;A TEMPORARY -- NO NEED TO COPY.
COPYQ:	JUMPE	A,NULLSET
	PUSH	P,[0]		;LET UNION DO THE WORK.
	PUSHJ	P,UNION		;MAGIC.
	MOVE	A,(P)		;RESULTS.
TEMPSET:
	HLRE	B,A		;GET COUNT FROM TEMP SET.
	MOVMS	B		;MAKE IT POSITIVE (I.E. PERMANENT SET)
	HRL	A,B		;ABSOLUTE COUNT.
	MOVEM	A,(TAC1)	;STORE IN DESCRIPTOR.
	MOVEM	A,(P)		;IN CASE OF STORBUTDONTREMOVE.
	SKIPA
NULLSET:
	SETZM	(TAC1)		;TARGET SET IS EASY !
DECIDE:	MOVE	A,RACS+1(USER)	;IN CASE OF POPTOP'S
	TLNN	TAC1,777	;LEAVE TOP OF STACK ON?
	 POP	 P,B		;NO --THROW OUT.
	JRST	LEAV		;YES

SETRCL:	SKIPGE	A,(TAC1)	;IF TEMP SET, CRASH
	ERR	<PROC EXIT WITH TEMP SET>,1
	JUMPE	A,LEAV		;NOT IF NULL SET.
	PUSHJ	P,RECQQ		;RECLAIM A SET IN A.
	JRST	LEAV		;AND RETURN.


DSCR SET OPERATIONS
 PUTIN   -- PUT TOP OF STACK IN SET POINTED TO BY TAC1.
	THIS MAKES A PERMANENT SET (I.E. COUNT IN SET
	DESCRIPTOR IS KEPT POSITIVE).

 REMOV   -- REMOVE THE ITEM MENTIONED IN TOP OF STACK FROM
	THE SET POINTED TO BY TAC1.  AN ERROR IS GIVEN IF THE
	ITEM IS NOT A MEMEBER OF THE SET.

 STLOP   -- LOP OFF AN ELEMENT OF THE SET POINTED TO BY
	TAC1, RETURN RESULTANT ITEM IN TOP OF STACK.

;


;SET OPERATIONS.


;INITIALIZER FOR ALL SETS.

INSET:
	SETZB	LPSA		;FOR COUNTING PURPOSES.
				;ALSO RIGHT HALF OF REGISTER 
				;0 MUST BE 0.
	HRRZ	FP,FP1(TABL)	;ONE-WORD FREES IF ANY
	MOVEI	FPD,(FP)	;ANOTHER COPY
	HRROI	PNT,(FP)	;AND ANOTHER COPY.
	JRST	(B)		;RETURN


;PUT AND REMOVE  ----
;	ITEM IS IN -1(P)
;	=> SET IN TAC1

PUTIN:
	MOVE	A,-1(P)		;ITEM.
ENTY:	
	HRRZ	FP,FP1(TABL)
	MOVEI	PNT,(FP)
	SKIPN	B,(TAC1)	;HEADER FOR SET.
	JRST	INS1		;BRAND NEW
LOPSET:	MOVE	C,B		;REMEMBER WHO POINTED AT US.
	HRRZ	B,(B)		;GO DOWN SET.
	JUMPE	B,INSRT		;GOT TO END AND NOT FOUND.
	HLRZ	D,(B)		;GET ITEM NUMBER
	CAIGE	D,(A)		;COMPARE TO ONE BEING INSERTED
	JRST	LOPSET		;NOT FAR ENOUGH
	CAIN	D,(A)
	JRST	RETQ		;ALREADY THERE.
INSRT:	SKIPN	FP,(FP)		;GET FREE STORAGE.
	PUSHJ	 P,FP1DON	;NONE LEFT.
	HRLM	A,(PNT)		;STORE THE NEW ITEM
	HRRM	PNT,(C)		;PUT IN POINTER.
	HRRM	B,(PNT)		;DOWN POINTER
	TRNE	B,-1		;WAS THIS THE LAST?
	JRST	COUTUP		;NO
	MOVE	B,(TAC1)	;GET SET AGAIN.
	HRLM	PNT,(B)		;PUT IN "LAST" POINTER.
COUTUP:	MOVSI	B,1
	ADDM	B,(TAC1)	;BUMP COUNTER
	JRST	RETQ

INS1:	MOVEI	PNT,(FP)	;POINTER TO FIRST FREE.
	SKIPN	FP,(FP)
	 PUSHJ	 P,FP1DON
	MOVEI	B,(FP)		;POINTER TO SECOND FREE.
	SKIPN	FP,(FP)
	 PUSHJ	 P,FP1DON
	HRLZM	A,(B)		;ITEM INSERTED
	HRLM	B,(PNT)
	MOVEM	PNT,(TAC1)
	JRST	COUTUP


;REMOVE

;SAME CALLING SITUATION AS PUT.

REMOV:
	JSP	B,INSET
	HRRZ	A,-1(P)		;THE ITEM
	MOVE	B,(TAC1)	;SET HEADER
LOPSS1:	MOVE	C,B
	HRRZ	B,(B)
	JUMPE	B,ERRS1		;IT WAS NOT THERE
	HLRZ	D,(B)		;ITEM NUMBER
	CAIGE	D,(A)		;COMPARE
	JRST	LOPSS1		;GO FARTHER
	CAIE	D,(A)		;THE VERY SAME?
	JRST	ERRS1		;NO
	CAMN	C,(TAC1)	;THE FIRST ELEMENT?
	JRST	ZEROS		;YES
REG:	HRRZ	D,(B)		;DOWN POINTER.
	HRRM	D,(C)		;BYPASS THE CELL BEING DELETED.
	HRRZ	LPSA,(TAC1)	;POINTER TO SET HEADER.
	HLRZ	D,(LPSA)	;NOW THE POINTER TO LAST OF LIST.
	CAIN	D,(B)		;SAME AS ONE WE FOUND?
	HRLM	C,(LPSA)	;YES -- INSTALL NEW "LAST" ELEMENT.
	HRRM	FP,(B)		;LINK ON FREE STORAGE LIST
	HRLZI	C,-1
	ADDM	C,(TAC1)	;DECREMENT COUNTER.
GOREM:	MOVE	FP,B
RETQ:	HRRM	FP,FP1(TABL)	;
	JRST 	RET0		;ALL DONE.

ZEROS:	TLNE	C,-2		;THE VERY LASTELEMENT OF LIST.
	JRST	REG		;NO -- DO A REGULAR REMOVE.
	HRRM	FP,(B)		;LINK WHOLE THING ON FS LIST.
	HRRZ	B,(TAC1)	;THIS IS NOW THE FS LIST.
	SETZM	(TAC1)		;AND ZERO THE DESCRIPTOR
	JRST	GOREM

ERRS1:	ERR	<REMOVING NON-EXISTENT ITEM FROM SET>,1
	JRST	RETQ


STLOP:	PUSH	P,(TAC1)	;THE SET.
	PUSHJ	P,UNIT		;GO GET THE FIRST ELEMENT IN (P)
	PUSHJ	P,REMOV		;NOW REMOVE IT FROM THE SET.
	AOBJN	P,.+1
	JRST	LEAV		;RETURN AND LEAVE ITEM ON TOP OF STACK.



DSCR  MORE SET OPERATIONS
 SIP -- FOR MAKING UP SETS FROM LISTS OF ITEMS { A,B,C ~.
	CALL IS WITH TOP OF STACK HAVING ITEM IN IT,
	NEXT ELEMENT IN STACK IS THE SET WE ARE BUILDING.

 STIN -- BOOLEAN TO SEE IF ITEM (SECOND ELEMENT DOWN IN
	STACK) IS MEMBER OF SET (TOP OF STACK).

 COUNT -- RETURNS IN AC1 THE LENGTH OF THE SET ON TOP
	OF STACK.

 UNIT -- RETURNS ON TOP OF STACK THE FIRST ELEMENT OF THE
	SET WHICH IS ON THE TOP OF STACK.

 SETEST -- CODE FOR TESTING SET BOOLEANS, I.E. SET CONTAINMENT,
	EQUALITY, INEQUALITY, ETC.

;


; SIP -- FOR MAKING UP SETS OF ITEMS.

;CALL IS WITH ITEM IN -1(P)
;SET STAYS IN -2(P) ..

SIP:
	MOVE	B,-1(P)		;ITEM
	TLNE	FLAG,(BOUND!BINDING)ATTPOS
	XCT	MOVEB(FRTAB)	;GET THE REAL THINGS.
	MOVE	A,B
	MOVEI	TAC1,-2(P)	;THE SET DESCRIPTOR.
	HLRE	B,(TAC1)	;COUNT
	MOVMS	B
	HRLM	B,(TAC1)	;MAKE POSITIVE.

	PUSHJ	P, ENTY		;SEE PUTIN AND FRIENDS.
	HLRE	A,(TAC1)	;COUNT OF SET.
	MOVNS	A
	HRLM	A,(TAC1)	;AND MAKE A TEMP.
	SUB	P,X11
	JRST	@2(P)


RET1:	HRRM	FP,FP1(TABL)
RET0:	SUB	P,X22
	JRST	@2(P)





; STIN  -- A BOOLEAN OF THE FORM  X  SET

;CALL IS WITH X IN -2(P)
; 	SET IN -1(P)

STIN:
	SETZM			;USES R0 FOR JUMPE...
	MOVE	B,-2(P)		;ITEM
	TLNE	FLAG,BOUNDATTPOS
	XCT	MOVEB(FRTAB)	;GET THE SATISFIER
	MOVE	C,-1(P)		;THE SET
LOPT2:	HRRZ	C,(C)		;DOWN THE SET
	JUMPE	C,NOPE
	HLRZ	D,(C)
	CAIE	D,(B)		;THE ITEM?
	JRST	LOPT2

NOPE:	
	PUSHJ	P,RECL1		;RECLAIM IF NECESSARY.
RET3C:	HRREM	C,A		;SAVE IN REG 1 AS RESULT.
RET3:	SUB	P,X33
	JRST	@3(P)



; COUNT ....
	
; CALL IS WITH SET IN -1(P)

COUNT:
	HLRE	C,-1(P)
	PUSHJ	P,RECL1		;RECLAIM -1(P) IF NECESSARY.
	MOVMM	C,A
	JRST	RET0		;THAT'S ALL


; UNIT ...

; CALL IS WITH SET IN -1(P)

UNIT:
	MOVE	A,-1(P)
	TLNN	A,-1
	ERR	<UNIT OF NULL SET UNDEFINED>,1
	HRRZ	A,(A)
	HLRZ	PNT,(A)		;THING TO RETURN
	PUSHJ	P,RECL1		;RECLAIM IF NECESSARY.
	EXCH	PNT,-1(P)
	POPJ	P,

;SET RELATIONS......

;VARIOUS LOCAL BITS.
	TESNEQ__40		;TEST NOT EQUAL
	TESEQL__20		;TEST EQUAL
	TES12 __10		;TEST 12
	TES21 __ 4		;TEST 12
	TESMAY__ 2		;IMPROPER SUBSETS.
	ANSWER__ 1		;THE ANSWER 0 FOR FALSE, 1 FOR TRUE
				;FALSE UNTIL PROVEN TRUE.


RELTAB:
	TES12
	TES21
	TESEQL
	TESNEQ
	TES12!TESMAY
	TES21!TESMAY


SETEST:
	MOVE	RELTAB-RELSTART+ROUTAB(FLAG)	;BITS!!!!
	TRNN	TES21
	JRST	.+4
	MOVE	B,-2(P)		;EXCHANGE THE OPERANDS.
	EXCH	B,-1(P)
	MOVEM	B,-2(P)

	HLRE	A,-2(P)		;EXAMINE COUNTS.
	HLRE	B,-1(P)
	MOVMS	A
	MOVMS	B
	TRNN	TESNEQ!TESEQL	;THESE GUYS WANT THE EQUAL TEST
	JRST	CONTES
	CAIE	A,(B)
	JRST	TESE

EQTST:	JUMPE	A,TESME		;IF NULL SETS, CLEARLY EQUAL
	MOVE	A,-2(P)
	MOVE	B,-1(P)
EQLOP:	HRRZ	A,(A)		;NEXT ELEMENT.
	JUMPE	A,TESME
	HRRZ	B,(B)
	HLRZ	D,(A)
	HLRZ	LPSA,(B)	;ITEMS
	CAIN	LPSA,(D)	;EQUAL?
	JRST	EQLOP
TESE:	TRNE	TESNEQ
SETYES:	TRC	ANSWER
SETNO:
SETANS:	SETOM	C
	TRNN	ANSWER
	SETZM	C
	PUSHJ	P,RECL2		;RECLAIM....
	JRST	RET3C

TESME:	TRNN TESNEQ
	   TRC  ANSWER
	JRST	SETANS
CONTES:	CAIE	A,(B)
	JRST	TESREL		;NOT SAME LENGTH.
	TRZN	TESMAY
	JRST	SETNO		;NOT POSSIBLY CONTAINED.
	JRST	EQTST

TESREL:	CAIL	A,(B)		;POSSIBLY CONTAINED :: COUNT(1) < COUNT(2)?
	JRST	SETNO
	JUMPE	A,SETYES	;NULL SET CONTAINED IN ANY SET.
	MOVE	A,-2(P)
	MOVE	B,-1(P)
COMLP:	HRRZ	A,(A)
COMLP1:	HRRZ	B,(B)
	JUMPE	A,SETYES	;ALL DONE AND NOT KICKED OUT.
	JUMPE	B,SETNO		;TRY TO GO PAST END ? -- NOT FEASIBLE.
	HLRZ	D,(A)
	HLRZ	LPSA,(B)
	CAIGE	D,(LPSA)	;CONTAINED?
	JRST	SETANS		;NO -- RETURN NO.
	CAIE	D,(LPSA)	;THE VERY SAME?
	JRST	COMLP1
	JRST	COMLP



DSCR UNION, INTERSECTION, SUBTRACTION

IN EACH CASE, ARGUMENTS ARE PASSED IN TOP TWO STACK
POSITIONS.  RESULT IS LEFT AS A TEMPORARY SET ON THE
TOP OF THE STACK.

;


; UNION

; CALL IS WITH SETS IN -1 AND -2 (P)

UNION:
	JSP	B,INSET
	MOVE	A,-1(P)
	MOVE	B,-2(P)		;THE SETS
	HRRZ	A,(A)
	HRRZ	B,(B)		;AND PAST THE HEADERS.

LOPA1:	JUMPE	A,AEXH		;A IS EXHAUSTED
LOPA2:	JUMPE	B,BEXH
	HLRZ	C,(A)		;ITEM
	HLRZ	D,(B)		;THE OTHER ITEM
	MOVEI	PNT,(FP)	;THIS IS A FREE STOR. CELL.
	SKIPN	FP,(FP)
	 PUSHJ	 P,FP1DON
	CAILE	C,(D)		;WHICH ONE IS INSERTED?
	SOJA	LPSA,[HRLM D,(PNT)	;PUT IN ITEM
		   HRRZ B,(B)
		   JRST LOPA2]
	HRLM	C,(PNT)
	CAIN	C,(D)		;THE SAME ITEM?
	HRRZ	B,(B)
	HRRZ	A,(A)
	SOJA	LPSA,LOPA1	;LOOP


AEXH:	JUMPE	B,DONN		;IF BOTH EXHAUSTED, DONE
	HLRZ	D,(B)		;NEXT ITEM
	MOVEI	PNT,(FP)	;FREE STORAGE CELL.
	SKIPN	FP,(FP)
	 PUSHJ	 P,FP1DON
	HRLM	D,(PNT)
	HRRZ	B,(B)
	SOJA	LPSA,AEXH

BEXH:	JUMPE	A,DONN
	HLRZ	D,(A)
	MOVEI	PNT,(FP)
	SKIPN	FP,(FP)
	 PUSHJ	 P,FP1DON
	HRLM	D,(PNT)
	HRRZ	A,(A)
	SOJA	LPSA,BEXH



;INTERSECTION.....

; CALL IS WITH SETS IN -1 AND -2 (P)

INTER:
	JSP	B,INSET
	MOVE	A,-1(P)		;FIRST SET
	MOVE	B,-2(P)
LOPS0:	HRRZ	A,(A)
LOPS1:	HRRZ	B,(B)		;GO ON DOWN....
LOPS2:	JUMPE	A,DONN		;IF EITHER A OR B DONE,
LOPS3:	JUMPE	B,DONN		;THEN WE ARE REALLY DONE.
	HLRZ	C,(A)		;ITEM
	HLRZ	D,(B)		;OTER ITEM
	CAIN	C,(D)		;THE SAME?
	JRST	YES4		;YES
	CAIL	C,(D)		;IS THE A LIST LOWER?
	JRST	LOPS1		;NO
	HRRZ	A,(A)		;YES
	JRST	LOPS2

YES4:	MOVEI	PNT,(FP)
	SKIPN	FP,(FP)
	 PUSHJ	 P,FP1DON
	HRLM	C,(PNT)
	SOJA	LPSA,LOPS0	;GO PAST BOTH OF THEM.



; SUBRACTION .

; CALL IS WITH SUBTRAHEND IN -1(P), OTHER IN -2(P)

SUBTRA:
	JSP	B,INSET
	MOVE	A,-1(P)
	MOVE	B,-2(P)		;LARGER SET
LOPR1:	HRRZ	A,(A)		;PAST SET HEADER & DOWN THE LIST.
	JUMPE	A,[ADDI LPSA,1
		   JRST BCOP1]	;COPY THE REST OF B
	HLRZ	C,(A)		;THE ITEM
LOPR2:	HRRZ	B,(B)
	JUMPE	B,DONN
	HLRZ	D,(B)		;THE OTHER ITEM
LOPR3:	CAIN	C,(D)		;THE SAME?
	JRST	LOPR1		;YES -- WALK ON BY.
	CAIL	D,(C)		;IS B LIST LOWER?
	JRST	[HRRZ A,(A)
		 JUMPE A,BCOP	;ALL DONE
		 HLRZ C,(A)
		 JRST LOPR3]
	MOVEI	PNT,(FP)
	SKIPN	FP,(FP)
	 PUSHJ	 P,FP1DON
	HRLM	D,(PNT)
	SOJA	LPSA,LOPR2

BCOP:	JUMPE	B,DONN
	MOVEI	PNT,(FP)
	SKIPN	FP,(FP)
	 PUSHJ	 P,FP1DON
	HRLM	D,(PNT)		;THERE WAS A THING IN D TO BE
				;DISPOSED OF.
BCOP1:	HRRZ	B,(B)		;ON DOWN B.
	HLR	D,(B)		;ITEM NUMBER.
	SOJA	LPSA,BCOP




; THE EXIT CODE.

DONN:	
	JUMPL	PNT,[SETZM PNT	;IF NOTHING DONE,
		 JRST RECLM2]	;RETURN NULL SET.
	HLLZS	(PNT)		;ZERO THE POINTER IN LAST CELL.
	MOVEI	A,(PNT)		;LAST WORD ALLOCATED.
	MOVEI	PNT,(FP)	;AND A NEW ONE -- FOR HEADER.
	SKIPN	FP,(FP)
	 PUSHJ	 P,FP1DON
	HRRM	FPD,(PNT)	;  FIRST OF SET LIST.
	HRLM	A,(PNT)		;PUT IN THE "LAST" LINK
	HRLM	LPSA,PNT	;LPSA IS NEGATIVE, TO INDICATE TEMP.
	HRRM	FP,FP1(TABL)	;....
;	JRST	RECLM2		;NEXT PAGE.

DSCR SET RECLAMATION ROUTINES.

RECLM2 -- RECLAIMS TOP TWO STACK ELEMENTS, SUBTRACTS FROM
	STACK, THEN PUSH'ES "PNT" (A RESULT) ONTO STACK.

RECL2 -- RECLAIMS SETS IN -1(P) AND -2(P)  .. THOSE ARE
	THE STACK POSITIONS BEFORE THE CALL TO RECL2.

RECQQ -- RECLAIMS SET MENTIONED IN REGISTER "A".
	CLOBBERES ACS: FP AND B.

;



RECLM2:	PUSHJ	P,RECL2

ALLD:	
	SUB	P,X33
	PUSH	P,PNT
	JRST	@2(P)		;RETURN.



RECL2:	SKIPGE	A,-3(P)		;...
	PUSHJ	P,RECQQ
RECL1:	SKIPL	A,-2(P)		;RECLAIM IF NECESSARY.
	POPJ	P,
RECQQ:	
	MOVE	FP,FP1(USER)
	HLRZ	B,(A)
	HRRM	FP,(B)		;LINK AT THE END OF LIST.
	HRRM	A,FP1(USER)
	POPJ	P,



; PRINT NAME HANDLING FOR THE WORLD.
; FIRST THE ROUTINE TO HASH THINGS UP, THEN
; THE RETRIEVAL ROUTINES.

INTNAM:	
	PUSH	P,UUO1(USER)	;SINCE ENTR WILL CLOBBER IT.
	SKIPL	C,HASHP(USER)
	JRST	GOMAK		;ALREADY INITED.
	HRRZS	C
	CAILE	C,ITMTOP(USER)	;MAKE SURE WE CAN FIT WITH
	 ERR 	 <TOO MANY PNAMES>,1 ;CURRENT ALLOCATION.
	CAIGE	C,100		;LESS THAN SOME MINIMUM?
	 MOVEI	 C,100		;JUST IN CASE.
	PUSH	P,UUO1(USER)	;SAVE THIS.
	PUSH	P,[0]
	PUSH	P,C		;LOWER BOUND, UPPER BOUND
	PUSH	P,[XWD -1,1]	;STRING ARRAY.
	PUSH	P,[1]		;A RANDOMLY GOOD ITEM NUMBER.
	MOVEI	A,.+3
	MOVEM	A,UUO1(USER)	;SET UP TO RETURN.
	JRST	ITMRY		;MAKE AN ARRAY, WOULD YOU BELIEVE.
	POP	P,UUO1(USER)
	HRRZM	A,HASHP(USER)	;ARRAY BASE.
	MOVN	C,-4(A)		;PICK UP LENGTH OF ARRAY.
	HRLZI	C,(C)		;MAKE AN AOBJN POINTER.
INT2:	HRRZM	C,(A)		;ARRAY.
	ADDI	A,2		;2 WORDS FOR A DSTRING DESCRIPTOR.
	AOBJN	C,INT2		;LINK UP ENTIRE ARRAY.
	HRLM	C,HASHP(USER)	;END OF LIST.
GOMAK:	AOS	A,(P)		;A  START OF ITEMS.
	SKIPE	A,-1(A)		;PICK UP POINTER TO PNAMES
	SKIPN	TEMP,(A)	;ARE THERE ANY?
	 JRST	 INT4		;NO
	PUSH	P,TEMP		;NUMBER OF ITEMS IN LIST
	ADDI	A,1
	PUSH	P,A		;SAVE ADDRESS OF CURRENT ITEM.
INT1:	MOVE	A,@(P)		;XWD ITEM NUMBER,, BYTE POINTER
	PUSH	SP,(A)
	PUSH	SP,1(A)		;STRING IS THERE.
	HLRZS	A
	PUSH	P,A
	PUSHJ	P,ENTR		;PUT IT IN.....
	AOS	(P)		;INDEX THE ADDRESS.
	SOSE	-1(P)		;ITEM COUNT.
	 JRST	 INT1
	SUB	P,X22
INT4:	POP	P,UUO1(USER)	;RESTORE RETURN ADDRESS.
	JRST	LEAV		;ALL DONE.



HERE (CVIS)			;CONVERT ITEM TO STRING.
	PUSHJ	P,SAVE		;SAVE AC'S & GET USER SET UP.
	SKIPG	HASHP(USER)
	ERR	<USING CVIS WITHOUT INITIALIZATION>
	PUSH	P,[1]		;ITEM PNAME
	PUSH	P,-3(P)		;      OUR ITEM
	PUSHJ	P,LEAP
	37			;DERIVED SET.
	SKIPN	A,(P)		;ANYTHING THERE?
	JRST	NOFND		;NO -- ERROR.
	HRRZ	A,(A)
	HLRZ	B,(A)		;B HAS "INDEX" INTO STRING ARRAY.
	HRROM	B,-3(P)		;STORE INTO ITEM (FOR DEL.PNAME)
	LSH	B,1
	ADD	B,HASHP(USER)	;B NOW POINTS TO SECOND WORD OF STRING THING.
	PUSH	SP,-3(B)
	PUSH	SP,-2(B)	;ALL DONE.
	POP	P,A		;SET
	PUSHJ	P,RECQQ		;RECLAIM IT.
	SETZM	@-1(P)		;GOT IT.
	JRST	CV10
NOFND:	POP	P,A		;SET LEFT ON STACK.
	SETOM	@-1(P)
	PUSH	SP,[0]
	PUSH	SP,[0]
CV10:	POP	P,UUO1(USER)
	MOVE	LPSA,X22
	JRST	RESTR		;ALL DONE.


HERE (CVSI)			;CONVERT STRING TO ITEM.
	SETOM	@-1(P)		; THE FLAG.
	MOVE	B,(SP)		;STRING
	ILDB	A,B		;FIRST CHARACTER.
	ILDB	B,B		;GET SECON CHARACTER.
	HRRZ	C,-1(SP)	;COUNT
	CAIE	C,1
	XORI	A,(B)		;A NICE HASH.
	IDIVI	A,113		;A GOOD HASH NUMBER.
	ADDI	B,1		;SINCE ITEM 0 MEANS SOMETHING.
	PUSH	P,[2]		;ITEM HASH
	PUSH	P,B		;   OUR HASH
	PUSHJ	P,LEAP
	37			;DERIVED SET
	SKIPN	D,(P)		;ANTHING THERE
	JRST	NO2		;NO
YE1:	HRRZ	D,(D)
	JUMPE	D,NO3WE
	HLRZ	C,(D)		;ITEM NUMBER -- WE MUST NOW GET ITS PNAME.
	PUSH	SP,-1(SP)
	PUSH	SP,-1(SP)	;COPY STRING
	PUSH	P,C		;ITEM NUMBER
	PUSH	P,-3(P)		;FLAG VARB.
	PUSHJ	P,CVIS		;GET THE STRING.
	AOSG	@-2(P)		;CHECK TO SEE IF IT WAS SUCCESSFUL.
	ERR	<DRYROT -- PNAME>,1
	PUSHJ	P,EQU		;EQUAL?
	MOVE	USER,GOGTAB	;DON'T TRUST NOBODY YOU DON'T KNOW! (DCS)
	JUMPE	1,YE1		;NO -- GO FOR MORE.
	SETZM	@-2(P)		;FOUND IT.
NO3WE:	MOVE	A,(P)
	PUSHJ	P,RECQQ		;RECLAIM SET.
	MOVE	A,C		;ITEM NUMBER
NO2:	SUB	SP,X22
	SUB	P,X33
	JRST	@2(P)



HERE (NEW.PNAME)
ENTR:			;MAKE A NEW PNAME
	MOVE	USER,GOGTAB
	SKIPG	HASHP(USER)
	ERR	<USING NEW.PNAME WITHOUT INITIALIZATION>
	HLRZ	A,HASHP(USER)	;GET LIST OF FREE SPOTS IN ARRAY.
	SKIPE	A
	CAMLE	A,ITMTOP(USER)
	 ERR	 <PNAME SPACE EXHAUSTED>
	PUSH	P,A
	LSH	A,1		;FIND THE CDR OF THE LIST.
	ADD	A,HASHP(USER)
	HRRZ	A,-2(A)		;A _ CDR (A)
	HRLM	A,HASHP(USER)	;AND SAVE IT.
	PUSH	P,[1]		;PNAME
	PUSH	P,-3(P)		;OUR ITEM
	PUSH	P,-2(P)
	PUSHJ	P,LEAP		;MAKE IT
	16
	MOVE	B,(SP)
	ILDB	A,B		;FIRST CHARACTER.
	ILDB	B,B		;GET HASH
	HRRZ	C,-1(SP)
	CAIE	C,1
	XORI	A,(B)		;NICE HASH.
	IDIVI	A,113
	ADDI	B,1
	PUSH	P,[2]		;HASH
	PUSH	P,B		;OUR HASH
	PUSH	P,-4(P)		;OUR ITEM
	PUSHJ	P,LEAP		;MAKE
	16

	POP	P,A		;ARRAY INDEX.
	LSH	A,1
	ADD	A,HASHP(USER)
	POP	SP,-2(A)
	POP	SP,-3(A)	;STORE IN STRING ARRAY.
	SUB	P,X22
	JRST	@2(P)		;ALL DONE.


HERE (DEL.PNAME)		;REMOVE A PNAME FROM THINGS.
	PUSH	P,-1(P)		;ITEM NUMBER.
	PUSH	P,[0]		;FLAG FOR INDIRECTION.
	PUSHJ	P,CVIS		;GET THE PRINTNAME FIRST.
	SUB	SP,X22		;ADJUST FOR OUR CROCKS.
	SKIPL	A,1(P)		;IF NEGATIVE, THEN IT WAS FOUND
	 JRST	 DEL3		;NOT FOUND -- GO AWAY.
;	MOVE	A,1(P)		;THIS IS THE INDEX INTO THE ARRAY.
	MOVEI	B,(A)
	LSH	B,1
	ADD	B,HASHP(USER)
	SETZM	-3(B)		;NULL STRING.
	HLRM	B,-2(B)		;CHAIN THE LIST FROM HASHP.
	HRLM	A,HASHP(USER)	;ALL DONE.
	PUSH	P,[1]		;PNAME
	PUSH	P,-2(P)
	PUSH	P,[0]		;ANY
	PUSHJ	P,LEAP
	XWD BINDING,24		;ERASE PNAMEITEMANY
;	XWD BINDING,21		;ERASE PNAMEITEMANY
	PUSH	P,[2]
	PUSH	P,[0]
	PUSH	P,-3(P)		;ERASE HASHANYITEM
	PUSHJ	P,LEAP
	XWD BINDINGOBJPOS,22	;...
DEL3:	SUB	P,X22
	JRST	@2(P)		;ALL DONE.  MY THAT WAS SIMPLE.

BEND	LEAP
	XLIST		;EXPURGATE SYMBOLS


IFN SEGS,<LIT
	VAR
	DEPHASE 
	END	UPWRT>
	END
                                                                                                                                                                  ^@!