DBGRC - SIMPL VERS 2.00 20-JUN 1974 15:48



     1	DEF ALT.NAME(A,B) AS A=B
     2	DEF ALT.ENTRY(A,B) AS \ENTRYNAME A
     3	!  IOCS DEFS OF INTEREST TO USER
     4	
     5	!  FILE DESCRIPTORS PASSED TO %OPEN
     6	
     7	!MAINTAIN ORDER OF FILE TYPES (SEE %OPEN1)
     8	
     9	DEF INPUT AS 0
    10	DEF UPDATE AS 1
    11	DEF OUTPUT AS 2
    12	DEF OUTMSG AS 3
    13	
    14	!FILE TYPE MODIFIERS
    15	
    16	DEF NEW AS OCT 100
    17	DEF OLD AS OCT 200
    18	
    19	!FILE MODES
    20	
    21	DEF SEQUEN AS 0
    22	DEF DIRECT AS OCT 10
    23	
    24	!FILE ORGANIZATIONS
    25	
    26	DEF WORD AS 0
    27	DEF CHARACTER AS OCT 20
    28	DEF PACK AS OCT 40
    29	
    30	!  FILE NUMBERS  (FNMIN IS MIN CHANNEL WHICH WILL BE USED)
    31	
    32	DEF FNMIN AS 1            !MIN AND MAX FILE NUMBERS
    33	DEF FNMAX AS 15           !AVAILABLE, EXCLUDING TEL
    34	DEF TEL AS (FNMIN-1)        !FILE NO. INDICATING TERMINAL 
    35	
    36	!  ERROR NUMBERS (ERRNUM VALUES)
    37	
    38	DEF TMFERR AS 1     !TOO MANY FILES OPEN (OPEN)
    39	DEF FMDERR AS 2     !BAD FILE MODE OR TYPE FOR ATTEMPTED OPERATION
    40	                    !(OPEN SEQUEN UPDATE, SETCP OR ERASE SEQUEN,
    41	                    !WRITE OR ERASE INPUT, READ SEQUEN OUTPUT)
    42	DEF IFDERR AS 3     !ILLEGAL FILE IDENTIFIER (SETFID, OPEN, DELETE, RENAME)
    43	DEF CNFERR AS 4     !NEW/OLD FILE MESSAGE NOT CONFIRMED (OPEN OUTMSG)
    44	                    !OR TYPE MODIFIER CONFLICT - FILE NOT NEW/OLD (OPEN OUTPUT OR UPDATE)
    45	
    46	!ORDER OF FOLLOWING 5 NOS. SHALL BE MAINTAINED. (ALL BUT LAST MAY
    47	!OCCUR DURING OPEN, DELETE, OR RENAME)
    48	
    49	DEF FNFERR AS 5     !FILE NOT FOUND
    50	DEF IUSERR AS 6     !INVALID USER NAME (BAD PPN)
    51	DEF PRTERR AS 7     !PROTECTION VIOLATION ATTEMPT
    52	DEF FBSERR AS 8     !FILE BUSY
    53	DEF AEFERR AS 9     !NEW NAME BELONGS TO ALREADY EXISTING FILE  (RENAME)
    54	
    55	DEF EOFERR AS 10    !END OF FILE (R, RB, GETLINE)
    56	DEF LNGERR AS 11    !LINE TOO LONG (GETLINE FROM FILE)
    57	DEF TELERR AS 12    !ILLEGAL OPERATION ON TEL (OPEN, DELETE, RENAME,
    58	                    !CP, SIZE)
    59	DEF ARGERR AS 13    !BAD ARGUMENT VALUE - SUCH AS:
    60	                    !NEGATIVE CURSOR POSITION (SETCP, ERASE),
    61	                    !NEG. COUNT (RB, WB)
    62	DEF CORERR AS 14    !OUT OF CORE (OPEN, BLOCK, RELEASE)
    63	
    64	FIND ALT.NAME("$STS",STS)
    65	FIND ALT.NAME("$CFN",CFN)
    66	FIND ALT.NAME("$SETCF",%SETCFN)
    67	FIND ALT.NAME("$EXU",%EXU)
    68	FIND ALT.NAME("$EXUF",%EXUF)
    69	FIND ALT.NAME("$IOCS",%IOCS)
    70	FIND ALT.NAME("$OPEN",%OPEN)
    71	FIND ALT.NAME("$SETFI",%SETFID)
    72	FIND ALT.NAME("$TELCH",%TELCHK)
    73	FIND ALT.NAME("$WFID",%WFID)
    74	FIND ALT.NAME("$CLOSE",%CLOSE)
    75	FIND ALT.NAME("$CANCE",%CANCEL)
    76	FIND ALT.NAME("$BUFDU",%BUF.DUMP)
    77	FIND ALT.NAME("$OPENP",%OPENP)
    78	FIND ALT.NAME("$SETFP",%SETFIP)
    79	FIND ALT.NAME("$SETMO",%SETMODE)
    80	FIND ALT.NAME("$CLALL",%CLOSE.ALL)
    81	FIND ALT.NAME("$CAALL",%CANC.ALL)
    82	FIND ALT.NAME("$PLNCH",%PLNCHK)
    83	FIND ALT.NAME("$PLNW",%PLNW)
    84	FIND ALT.NAME("$SETTA",%SET.TAB)
    85	FIND ALT.NAME("$SETTE",%SET.TERM)
    86	FIND ALT.NAME("$SETPR",%SET.PRMPT)
    87	FIND ALT.NAME("$TABOF",%TAB.OFF)
    88	FIND ALT.NAME("$R",%R)
    89	FIND ALT.NAME("$GETLI",%GETLINE)
    90	FIND ALT.NAME("$W",%W)
    91	FIND ALT.NAME("$WX",%WX)
    92	FIND ALT.NAME("$ERASE",%ERASE)
    93	FIND ALT.NAME("$SETCP",%SETCP)
    94	FIND ALT.NAME("$CP",%CP)
    95	FIND ALT.NAME("$SIZE",%SIZE)
    96	FIND ALT.NAME("$WB",%WB)
    97	FIND ALT.NAME("$RB",%RB)
    98	FIND ALT.NAME("$BLOCK",%BLOCK)
    99	FIND ALT.NAME("$RELEA",%RELEASE)
   100	FIND ALT.NAME("$DELET",%DELETE)
   101	FIND ALT.NAME("$RENAM",%RENAME)
   102	FIND ALT.NAME("$CLIBU",%CLIBUF)
   103	FIND ALT.NAME("$CLOBU",%CLOBUF)
   104	FIND ALT.NAME("$TTYLE",%TTYLEN)
   105	FIND ALT.NAME("$GET",%GET)
   106	FIND ALT.NAME("$PUT",%PUT)
   107	FIND ALT.NAME("$PUTX",%PUTX)
   108	FIND ALT.NAME("$PUTC",%PUTC)
   109	FIND ALT.NAME("$PRINT",%PRINT)
   110	FIND ALT.NAME("$PRINC",%PRINTC)
   111	FIND ALT.NAME("$MSG",%MSG)
   112	FIND ALT.NAME("$SETRW",%SETRWE)
   113	FIND ALT.NAME("$FPMSG",%F.P.MSG)
   114	FIND ALT.NAME("$FPRNT",%F.P.PRINT)
   115	FIND ALT.NAME("$OFFAL",%OFFALT)
   116	FIND ALT.NAME("$ONALT",%ONALT)
   117	FIND ALT.NAME("$ONALC",%ONALT.C)
   118	FIND ALT.NAME("$ALTLO",ALTLOC)
   119	FIND ALT.NAME("$ERRNU",ERRNUM)
   120	
   121	DEF TO.TERM   AS 1
   122	DEF TO.TOUT   AS 2
   123	DEF TO.BOTH   AS 3
   124	DEF TO.NEITHER AS 4
   125	
   126	FIND ALT.NAME("$XTOUT",%EX.TOUT)
   127	FIND ALT.NAME("$EXCFN",%EX.CFN)
   128	FIND ALT.NAME("$TDEST",%TT.DEST)
   129	FIND ALT.NAME("$CECHO",%CF.ECHO)
   130	FIND ALT.NAME("$TECHO",%TT.ECHO)
   131	FIND ALT.NAME("$RSBRK",%RS.BRK)
   132	FIND ALT.NAME("$RSALT",%RS.ALT)
   133	FIND ALT.NAME("$DDOVR",%DDT.OVR)
   134	
   135	FIND ALT.NAME("$FIDP",FIDP())
   136	DEF LOCWPF AS 5
   137	DEF MAXARG AS 27
   138	DEF MINARG AS 5
   139	DEF WPF AS (LOCWPF+1+MINARG)
   140	DEF MAXWPF AS (LOCWPF+1+MAXARG)
   141	! EXTENDED ARGUMENT BLOCK:
   142	DEF ARGCNT(TBL) AS TBL(LOCWPF)
   143	DEF PPNARG(TBL) AS TBL(LOCWPF+1)
   144	DEF NAMARG(TBL) AS TBL(LOCWPF+2)
   145	DEF EXTARG(TBL) AS TBL(LOCWPF+3)
   146	DEF PRVARG(TBL) AS TBL(LOCWPF+4)
   147	DEF FILSIZ(TBL) AS TBL(LOCWPF+5)
   148	DEF EXTQ(TBL) AS TBL(0)
   149	DEF USRNAM(TBL) AS TBL(1)
   150	DEF DEVNAM(TBL) AS TBL(3)
   151	
   152	!  GETLINE 
   153	
   154	DEF LLEN AS 256                !MAX. LINE LENGTH
   155	DEF GLBCMX AS (LLEN+1)         !MAX. CHAR CAPACITY
   156	DEF CPW AS CHARS.PER.WORD
   157	DEF GLBSZ AS ((GLBCMX+CPW-1)/CPW)  !SIZE IN WORDS
   158	FIND ALT.NAME("$FREE",FREE(0:GLBSZ-1))   !GETLINE INTERNAL BUFFER (AVAILABLE
   159	                                         !BETWEEN GETLINE CALLS)
   160	FIND ALT.NAME("$IMAGE",IMAGE(0:GLBSZ-1)) !GETLINE IMAGE LINE BUFFER
   161	FIND ALT.NAME("$GLCNT",GLCNT)            !GETLINE CHAR COUNT
   162	
   163	! VTYP VALUES
   164	
   165	DEF INT  AS 1
   166	DEF REAL AS 2
   167	DEF DOUB AS 3
   168	DEF CPLX AS 4
   169	DEF NUMTMAX AS CPLX   !MAX NUMERIC TYPE
   170	DEF LGC  AS 5
   171	DEF STR  AS 6
   172	DEF VTYPMAX AS STR
   173	DEF VTYPRNG AS VTYPMAX     !USED IN CASES ON VTYP
   174	FIND ALT.NAME("$FLDMA",FLDMAX(REAL:CPLX))
   175	
   176	! FTYP VALUES
   177	
   178	DEF SYM AS 1
   179	DEF BIN AS 2
   180	
   181	! FMODE VALUES
   182	
   183	DEF SEQ AS 1
   184	DEF VRL AS 2
   185	DEF FRL AS 3
   186	
   187	DEF FREEFORM AS FORM<0
   188	
   189	FIND ALT.NAME("$VTYP",VTYP)
   190	FIND ALT.NAME("$VCNT",VCNT)
   191	FIND ALT.NAME("$VADR",VADR)
   192	FIND ALT.NAME("$FN",FN)
   193	FIND ALT.NAME("$FTYP",FTYP)
   194	FIND ALT.NAME("$FMODE",FMODE)
   195	FIND ALT.NAME("$RECSZ",RECSZ)
   196	FIND ALT.NAME("$FORM",FORM)
   197	FIND ALT.NAME("$CADR",CADR)
   198	FIND ALT.NAME("$CRFG",CRFG(TEL:FNMAX))
   199	FIND ALT.NAME("$ELCNT",ELCNT(TEL:FNMAX))
   200	DEF INITREC(FN) AS [ELCNT(FN) _ CRFG(FN) _ 0]
   201	
   202	FIND ALT.NAME("$SFORW",%SFORW)
   203	FIND ALT.NAME("$RWINI",%RWINIT)
   204	FIND ALT.NAME("$READ",%READ)
   205	FIND ALT.NAME("$WRITE",%WRITE)
   206	FIND ALT.NAME("$NUMUI",%NUMUN.INIT)
   207	FIND ALT.NAME("$NUMUN",%NUMUNPK)
   208	FIND ALT.NAME("$NUMSI",%NUMSC.INIT)
   209	FIND ALT.NAME("$NUMSC",%NUMSCAN)
   210	FIND ALT.NAME("$LGCPK",%LGCPK)
   211	FIND ALT.NAME("$LGCUN",%LGCUNPK)
   212	FIND ALT.NAME("$LSCAN",%LSCAN.INIT)
   213	FIND ALT.NAME("$SCANI",%SCAN.INIT)
   214	FIND ALT.NAME("$SCAN",%SCAN)
   215	FIND ALT.NAME("$STRPI",%STRP.INIT)
   216	FIND ALT.NAME("$STRUP",%STRUP.INIT)
   217	FIND ALT.NAME("$TSTRP",%TSTRP.INIT)
   218	FIND ALT.NAME("$STRPK",%STRPK)
   219	FIND ALT.NAME("$STRUN",%STRUNPK)
   220	FIND ALT.NAME("$FLOUT",%FLOUT)
   221	FIND ALT.NAME("$POUT",%POUT)
   222	FIND ALT.NAME("$SETRP",%SETRWP)
   223	
   224	!  NUMUN.INIT ARGUMENT VALUES
   225	
   226	DEF INTFLD AS 1
   227	DEF DECFLD AS 2
   228	DEF EXPFLD AS 3
   229	
   230	!  LABELS NXVAR BRANCHES TO AT END OF I/O LIST
   231	FIND ALT.NAME("$FRIEO",FRI.EOV:)
   232	FIND ALT.NAME("$FMIEO",FMI.EOV:)
   233	FIND ALT.NAME("$FROEO",FRO.EOV:)
   234	FIND ALT.NAME("$FMOEO",FMO.EOV:)
   235	! FOR MPK
   236	FIND ALT.NAME("$OVFLE",OVFLERR:)
   237	FIND ALT.NAME("$NUMPH",NUMPHI)
   238	FIND ALT.NAME("$NUMPL",NUMPLO)
   239	FIND ALT.NAME("$NUMPS",NUMPSGN)
   240	!  IOCSU AND SFORWU MUST PRECEDE.
   241	
   242	ALT.ENTRY("$RUNCT",RUNCTL)
   243	
   244	!  MACHINE DEPENDENT MACROS
   245	
   246	! IF INCREASE TOTAL DGMAX, MUST EXPAND PWR10 TABLE!
   247	DEF I.DGMAX AS 5     !MAX NO. INTEGER & DECIMAL LINE KEY DIGITS (4 BITS
   248	DEF D.DGMAX AS 3     !PER - MUST FIT IN WORD ALONG WITH SIGN BIT)
   249	
   250	DEF LWUPDIF AS OCT 40
   251	DEF LESSTR(X,Y) AS (X) SHR 1 < (Y) SHR 1  !STRING COMPARISON
   252	DEF ND.STR AS '[[[[['    !STRING LIT > WD OF ALPHA CHARS
   253	DEF EOLITWD AS 0         !WORD OF EOLITS
   254	DEF TABCH AS OCT 11      !HANDLED IN MACHINE DEPENDENT MANNER
   255	DEF NSPCH(CHAR) AS ($ #CHAR#TABCH)
   256	DEF SPCH(CHAR) AS NOT NSPCH(CHAR)
   257	
   258	GLOBAL ALT.NAME("$RUNCT",%RUNCTL)
   259	GLOBAL ALT.NAME("$STM",%STM)
   260	GLOBAL ALT.NAME("$QUIT",%QUIT)
   261	GLOBAL ALT.NAME("$XIT",%XIT)
   262	GLOBAL ALT.NAME("$PAWS",%PAWS)
   263	GLOBAL ALT.NAME("$CONER",%CONERR)
   264	GLOBAL ALT.NAME("$NCNER",%NCNERR)
   265	GLOBAL ALT.NAME("$DBFNM",DBFNM(0:3))
   266	GLOBAL ALT.NAME("$DBFDT",DBFDT)
   267	
   268	LOCAL DB.CNUM, DB.INTNO, DB.NLINES, LNUM, DB.DOT
   269	
   270	FIND ALT.NAME("$SFOIN",SFOIN)
   271	FIND ALT.NAME("$SFOED",SFOED)
   272	FIND ALT.NAME("$CURLI",CURLINE)
   273	FIND ALT.NAME("$SFRUN",%SFRUN)
   274	FIND ALT.NAME("$IORES",%IORESTORE)
   275	FIND ALT.NAME("$SFCLA",%SFCLS.ALL)
   276	FIND ALT.NAME("$OFINT",%OFINT)
   277	FIND ALT.NAME("$RESIN",%RESINT)
   278	FIND ALT.NAME("$UNCOR",%UNCORE)
   279	
   280	
   281	LOCAL CFNEOF:, ERROR.EXIT
   282	
   283	LOCAL %DEXU
   284	LOCAL %PRMPT, %NXNSP, %BACKSP, LASTCH
   285	DEF NXCHAR AS LASTCH _ NCHV LPTR
   286	LOCAL %GETCOM
   287	LOCAL %OUTNUM, %WKEY
   288	LOCAL %WDSTOR, %CMDREC, %WDREC
   289	LOCAL %CERR, %CPERR, %LNGCHK, %CFNCLS, %PCMDL
   290	
   291	LOCAL %CSCAN.INIT, %FCR, %FFID, %FADR, %FLST, %FNAME, %FINT
   292	
   293	LOCAL %PRGCHK, %INLIST
   294	LOCAL %I.NXLNUM, %NXLNUM
   295	LOCAL %XLKLN
   296	LOCAL %ALPH
   297	
   298	DEF MAIN.NAME AS 0   ! NAME OF MAIN PROGRAM. BLANKS IN SIXBIT
   299	
   300	LOCAL %DERR, %DPERR, %RWERR, %SYMERR, %SYMNERR
   301	LOCAL %PUTSYM, %PUTQSYM, %OUTSET
   302	LOCAL %INIT.DB, %SET.CURRENT.ROUTINE, %SET.DOT.TO.CURLINE, %STM.REPORT
   303	
   304	! ALL GET PROCS LEAVE WITH LASTCH AS (NON-BLANK) TERMINATOR TO WHAT WAS GOT,
   305	! AND LPTR PAST LASTCH
   306	LOCAL %GET.SYM, %GET.VAR, %GET.NAME, %GET.PINT
   307	
   308	!
   309	! ROUTINE TABLE DEFINITIONS
   310	!
   311	DEF DB.HDR.SIZE AS 4
   312	DEF DB.HDR.VERS(X) AS X(0)
   313	DEF DB.FILE.SIZE(X) AS X(1)
   314	DEF DB.RT.FILE.LOC(X) AS HW(@X(2),1)
   315	DEF DB.RT.NO.WORDS(X) AS HW(@X(2))
   316	DEF DB.HDR.DATE(X) AS X(3)
   317	
   318	DEF DB.VERSION AS 1
   319	DEF RT.FESIZE AS 4
   320	
   321	DEF RT.NAME(X) AS X(0)
   322	DEF RT.DICT.FILE.DESC(X) AS BYT(X(1),35,0)
   323	DEF RT.DICT.IN(X) AS BYT(X(1),1,35)
   324	DEF RT.DICT.FILE.LOC(X) AS HW(@X(1),1)
   325	DEF RT.DICT.NO.WORDS(X) AS BYT(X(1),17,18)
   326	DEF RT.DICT.SIZE(X) AS RT.DICT.NO.WORDS(X)/RT.CESIZE
   327	DEF RT.DICT.CORE.LOC(X) AS HW(@X(2))
   328	DEF RT.ORDINAL(X) AS BYT(X(3),9,27)
   329	DEF RT.HIGH.LINE.KEY(X) AS BYT(X(3),27,0)
   330	DEF RT.SYMT.FILE.DESC(X) AS BYT(X(4),35,0)
   331	DEF RT.SYMT.IN(X) AS BYT(X(4),1,35)
   332	DEF RT.SYMT.FILE.LOC(X) AS HW(@X(4),1)
   333	DEF RT.SYMT.NO.WORDS(X) AS BYT(X(4),17,18)
   334	DEF RT.SYMT.CORE.LOC(X) AS HW(@X(2),1)
   335	
   336	LOCAL FIRST.ROUTINE() ! INDEX OF FIRST ROUTINE IN TABLE
   337	DEF NEXT.ROUTINE(X) AS X+_RT.CESIZE ! POINTS X TO NEXT ROUTINE IN TABLE
   338	LOCAL NUM.OF.ROUTINES ! NUMBER OF ROUTINES IN TABLE
   339	DEF LINE.START.ROUTINE(X) AS X-RT.CESIZE*RT.ORDINAL(X)
   340	DEF ORDINAL.START AS 0 ! FIRSTS ORDINAL VALUE
   341	LOCAL CURRENT.ROUTINE(), CURRENT.DICT(), CURRENT.SYMT
   342	DEF NO.ROUTINE AS -1
   343	DEF RT.CESIZE AS 5
   344	LOCAL DB.FNO ! Debug information file number
   345	LOCAL LAST.ROUTINE.REPORTED() ! Routine containing last executed STM
   346	LOCAL MAIN.ROUTINE() ! INDEX OF MAIN PROGRAM
   347	
   348	! DICTIONARY DEFINITIONS
   349	
   350	DEF DICT.ESIZE AS 2
   351	DEF LINE.KEY(K) AS CURRENT.DICT((K-1)*DICT.ESIZE-1)
   352	DEF CORE.ADDR(K) AS HW(@CURRENT.DICT((K-1)*DICT.ESIZE-1),1)
   353	DEF DICT.HDR.SIZE AS 1
   354	DEF DICT.OWNER.COUNT(D) AS ^((D)-DICT.HDR.SIZE)
   355	
   356	!  DEFS FOR SYMBOL TABLE
   357	
   358	! FOLLOWING APPLY TO ENTRY AT ADDRESS PTR
   359	
   360	!  FLAGS IN LH(WD 0)
   361	DEF S.VAR(PTR) AS (^(PTR) BAND 1 SHL 35)
   362	DEF S.COM(PTR) AS (^(PTR) BAND 1 SHL 34)
   363	DEF S.FUN(PTR) AS (^(PTR) BAND 1 SHL 30)
   364	DEF S.SUBR(PTR) AS (^(PTR) BAND 1 SHL 29)
   365	DEF S.SUBD(PTR) AS (^(PTR) BAND 1 SHL 28)
   366	DEF S.PRG(PTR) AS (^(PTR) BAND 1 SHL 23)
   367	DEF S.DUM(PTR) AS (^(PTR) BAND 1 SHL 22)
   368	DEF S.ADJ(PTR) AS (^(PTR) BAND 1 SHL 21)
   369	DEF S.LIB(PTR) AS (^(PTR) BAND 1 SHL 20)
   370	DEF S.ARYB(PTR) AS (^(PTR) BAND 1 SHL 19)
   371	DEF S.LONG(PTR) AS (^(PTR) BAND 1 SHL 18)
   372	
   373	DEF S.TYP(PTR) AS (^(PTR) BAND OCT 77.00)
   374	  DEF S.INT  AS 0
   375	  DEF S.REAL AS OCT 4.00
   376	  DEF S.DOUB AS OCT 10.00
   377	  DEF S.CPLX AS OCT 14.00
   378	  DEF S.LGC  AS OCT 1.00
   379	  DEF S.STR  AS OCT 15.00
   380	LOCAL %VTYPA  !TO TRANSFORM S.TYP TO VTYP
   381	
   382	DEF S.LEN(PTR) AS (^(PTR) BAND OCT 77)
   383	DEF S.VBT(PTR) AS ^((PTR)+1)
   384	DEF S.LOC(PTR) AS HW((PTR)+2,1)
   385	  DEF S.SCAP(PTR) AS HW(S.LOC(PTR))
   386	  DEF S.SLOC(PTR) AS HW(S.LOC(PTR),1)
   387	  DEF S.DLOC(PTR) AS HW(S.LOC(PTR),1)   !DUMMY ARRAY BASE
   388	DEF S.NAM(PTR) AS ^((PTR)+3)
   389	DEF S.SNUM(PTR) AS HW((PTR)+1)
   390	DEF INIT.S.MUL(PTR) AS S.MULP _ HWPT((PTR)+4,-1)
   391	DEF NX.S.MUL AS NHWV S.MULP   !FOR I=1 TO S.SNUM(PTR)
   392	DEF S.SIZ(PTR) AS HW((PTR)+3)
   393	LOCAL %S.OFF, S.MULP
   394	
   395	! Memory management routines. Currently the ones in IOCS are used.
   396	
   397	DEF BLK(N) AS (((N)+130)/131)
   398	DEF GET.BLOCK(N) AS BLOCK(BLK(N),0,NOCORE)
   399	DEF REL.BLOCK(A,N) AS RELEASE(BLK(N),A,NOCORE)
   400	
   401	!  ERROR MESSAGES
   402	
   403	TABLE NOCONT   ['NOT CONTINUABLE']
   404	TABLE BDCONS   ['ILLEGAL CONSTANT']
   405	TABLE BDCPLX   ['COMPLEX MUST BE ENTERED AS (REAL, IMAG)']
   406	
   407	! SYMBOL ERRORS:
   408	TABLE UNDEFS   ['UNDEFINED']
   409	TABLE NOTARY   ['NOT AN ARRAY']
   410	TABLE ISARY    ['IS AN ARRAY']
   411	TABLE BADINT   ['NOT INTEGER']
   412	TABLE SUBCNT   ['WRONG NUMBER OF SUBSCRIPTS']
   413	TABLE BOUNDS   ['SUBSCRIPT OUT OF BOUNDS']
   414	TABLE DIMLIT   ['DIMENSIONS EXCEED LIMIT OF 10']
   415	TABLE BDMTCH   ['TYPE DOES NOT MATCH']
   416	
   417	TABLE ASSIGN   ['ASSIGNMENTS DONE']
   418	TABLE NOXRNG   ['NO EXECUTABLE OR FORMAT STATEMENT IN ']
   419	
   420	DEF SXPT(ADR) AS [6,6,24]*[36,6,ADR]
   421	
   422	DEF AC.TRCBIT AS 1
   423	DEF AC.BRKBIT AS 2
   424	DEF TRCBIT AS (AC.TRCBIT SHL 23)
   425	DEF BRKBIT AS (AC.BRKBIT SHL 23)
   426	DEF BRKSTR AS 'BREAK '
   427	DEF TRCSTR AS 'TRACE '
   428	
   429	DEF SUBSMAX AS 10   !??
   430	LOCAL SUBS(SUBSMAX)
   431	LOCAL  LTTYLEN
   432	LOCAL CONT.OK		! CONTINUE ALLOWED FLAG
   433	LOCAL INITFG
   434	LOCAL SETFG   !SPECIAL PRINTOUT FOR SET COMMAND ERRORS
   435	
   436	!  MACHINE/IMPLEMENTATION DEPENDENT I/O DATA
   437	
   438	LOCAL FREEPTR                !PTR TO BEGINNING OF FREE BUFFER
   439	LOCAL IMGPTR
   440	
   441	! USED IN COMMAND PROCESSING (NOT SAVED BETWEEN COMMANDS):
   442	
   443	LOCAL LPTR                   !INPUT LINE STRING POINTER
   444	LOCAL BEG.LPTR               !INITIAL VALUE OF 'LPTR'
   445	LOCAL EL(4), ELID(4), ELP    !COMMAND LINE ELEMENTS, ELEMENT IDS
   446	DEF SELLIM AS GLBSZ
   447	LOCAL SEL(-1:SELLIM)         !SUBELEMENTS (LINE LIST & RANGE)
   448	DEF LTBL(X) AS SEL((X)-2)    !LINE LIST NOS. & COUNTS
   449	LOCAL SELP                   !SEL PTR
   450	LOCAL LSTCNT	!NO. LINES SPECIFIED IN LINE LIST
   451	DEF ELW(X,Y) AS [EL(INC ELP)_(Y); EL.ID(ELP)_(X)]
   452	
   453	!  COMMAND WORDS
   454	
   455	DEF K.ABT  AS 1
   456	DEF K.BRK  AS 2
   457	DEF K.CAN  AS 3
   458	DEF K.CHNG AS 4
   459	DEF K.CLS  AS 5
   460	DEF K.COMP AS 6
   461	DEF K.CONT AS 7
   462	DEF K.CRE  AS 8
   463	DEF K.DEB  AS 9
   464	DEF K.DISP AS 10
   465	DEF K.DO   AS 11
   466	DEF K.GO   AS 12
   467	DEF K.HUSH AS 13
   468	DEF K.INIT AS 14
   469	DEF K.LIST AS 15
   470	DEF K.MODE AS 16
   471	DEF K.NEXT AS 17
   472	DEF K.NO   AS 18
   473	DEF K.PROD AS 19
   474	DEF K.QUIT AS 20
   475	DEF K.RUN  AS 21
   476	DEF K.SET  AS 22
   477	DEF K.STEP AS 23
   478	DEF K.TOUT AS 24
   479	DEF K.TRC  AS 25
   480	DEF K.VAL  AS 26
   481	DEF CWDCNT AS K.VAL
   482	DEF K.NOPT(N) AS (K.VAL+N)
   483	DEF K.NBRK AS K.NOPT(1)
   484	DEF K.NHSH AS K.NOPT(2)
   485	DEF K.NTRC AS K.NOPT(3)
   486	DEF K.NVAL AS K.NOPT(4)
   487	DEF NWDCNT AS 4
   488	DEF K.LOPT(N) AS (K.NVAL+N)
   489	DEF K.LBRK AS K.LOPT(1)
   490	DEF K.LDEB AS K.LOPT(2)
   491	DEF K.LTRC AS K.LOPT(3)
   492	DEF K.LVAL AS K.LOPT(4)
   493	DEF K.LVER AS K.LOPT(5)
   494	DEF LWDCNT AS 5
   495	DEF K.VOPT(N) AS (K.LVER+N)
   496	DEF K.VBRK AS K.VOPT(1)
   497	DEF K.VTRC AS K.VOPT(2)
   498	DEF VWDCNT AS 2
   499	DEF K.NVOPT(N) AS (K.VTRC+N)
   500	DEF K.NVBK AS K.NVOPT(1)
   501	DEF K.NVTC AS K.NVOPT(2)
   502	DEF K.LVOPT(N) AS (K.NVTC+N)
   503	DEF K.LVBK AS K.LVOPT(1)
   504	DEF K.LVTC AS K.LVOPT(2)
   505	DEF K.POPT(N) AS (K.LVTC+N)
   506	DEF K.PCMP AS K.POPT(1)
   507	DEF K.AS K.POPT(2)
   508	DEF K.PRUN AS K.POPT(3)
   509	DEF PWDCNT AS 3
   510	DEF CMDCNT AS K.PRUN   !FOR CASE STATEMENT
   511	
   512	TABLE CWD(CWDCNT+1)[ &
   513	 "ABORT", &
   514	 "BREAK", &
   515	 "CANCEL", &
   516	 "CHANGE", &
   517	 "CLOSE", &
   518	 "COMPILE", &
   519	 "CONTINUE", &
   520	 "CREATE", &
   521	 "DEBUG", &
   522	 "DISPLAY", &
   523	 "DO", &
   524	 "GO", &
   525	 "HUSH", &
   526	 "INITIALIZE", &
   527	 "LIST", &
   528	 "MODE", &
   529	 "NEXT", &
   530	 "NO", &
   531	 "PRODUCTION", &
   532	 "QUIT", &
   533	 "RUN", &
   534	 "SET", &
   535	 "STEP", &
   536	 "TOUT", &
   537	 "TRACE", &
   538	 "VALUE", &
   539	 ND.STR]
   540	DEF CLMAX AS 10     !COMMAND WORD LENGTH MAX
   541	
   542	! CMD ARRAY USED ONLY IN GENERATION OF COMMAND MODELS
   543	! NULL ENTRIES: AFTER GETCOM, DB.CNUM WILL NEVER HAVE CORRESPONDING VALUE
   544	TABLE CMD(CWDCNT+1:CMDCNT)[ &
   545	 "NO BREAK", &
   546	 "NO HUSH", &
   547	 "NO TRACE", &
   548	 "NO VALUE", &
   549	 "LIST BREAK", &
   550	 "LIST TRACE", &
   551	 "LIST VALUE", &
   552	 "LIST VERSION", &
   553	 "VALUE BREAK", &
   554	 "VALUE TRACE", &
   555	 "NO VALUE BREAK", &
   556	 "NO VALUE TRACE", &
   557	 "LIST VALUE BREAK", &
   558	 "LIST VALUE TRACE", &
   559	 "PRODUCTION INITIALIZE", &
   560	 "PRODUCTION RUN"]
   561	
   562	TABLE LWD(LWDCNT+1)[ &
   563	 "BREAK", &
   564	 "DEBUG", &
   565	 "TRACE", &
   566	 "VALUE", &
   567	 "VERSION", &
   568	 ND.STR]
   569	DEF LLMAX AS 7  !LIST COMMAND WORD LENGTH MAX
   570	
   571	TABLE NWD(NWDCNT+1)[ &
   572	 "BREAK", &
   573	 "TRACE", &
   574	 "VALUE", &
   575	 ND.STR]
   576	DEF NLMAX AS 5  !NO COMMAND WORD LENGTH MAX
   577	
   578	TABLE VWD(VWDCNT+1)[ &
   579	 "BREAK", &
   580	 "TRACE", &
   581	 ND.STR]
   582	DEF VLMAX AS 5  !VALUE COMMAND WORD LENGTH MAX
   583	
   584	TABLE PWD(PWDCNT+1)[ &
   585	 "COMPILE", &
   586	 "INITIALIZE", &
   587	 "RUN", &
   588	 ND.STR]
   589	DEF PLMAX AS 10 !PRODUCTION COMMAND WORD LENGTH MAX
   590	
   591	!  COMMAND LINE ELEMENT IDENTIFIERS
   592	
   593	DEF FID.ID AS 1              !FILE IDENTIFIER INDEX
   594	DEF LST.ID AS 2              !LINE LIST
   595	DEF ADR.ID AS 3              !LINE ADDRESS
   596	DEF NAM.ID AS 4              !IDENTIFIER
   597	DEF INT.ID AS 5              !POSITIVE INTEGER
   598	
   599	!  ERROR MESSAGES TO USER OF CCS
   600	
   601	TABLE LNLONG       ['LINE TOO LONG']
   602	TABLE BDLRNG       ['ILLEGAL LINE RANGE']
   603	TABLE NOCORE       ['NOT ENOUGH CORE']
   604	TABLE NOTIMP       ['NOT IMPLEMENTED']
   605	TABLE BDCMND       ['NO SUCH COMMAND']
   606	TABLE AMBGCM       ['AMBIGUOUS ABBREVIATION, TYPE MORE CHARACTERS']
   607	TABLE LSTLNG       ['LINE LIST TOO LONG']
   608	TABLE NOPROG       ['NO PROGRAM']
   609	TABLE NOTYMEX      ['NOT ALLOWED FROM TYMEX']
   610	
   611	!FILE OPEN ERRORS
   612	TABLE FILERR(IFDERR:FBSERR)[ &
   613	 'ILLEGAL FILE IDENTIFIER', &
   614	 '$NEW/OLD FILE MESSAGE NOT CONFIRMED', &
   615	 'FILE NOT FOUND', 'INVALID USER NAME', &
   616	 'PROTECTION VIOLATION ATTEMPT', 'FILE BUSY']
   617	
   618	
   619	!  OF GENERAL INTEREST:
   620	
   621	DEF UPALPH(X) AS ($A<=X<=$Z)
   622	DEF LWALPH(X) AS ($A+LWUPDIF <= X <= $Z+LWUPDIF)
   623	DEF XLWUP(X) AS X _ X-LWUPDIF   !TRANSFORM X FROM LWR TO UPR CASE
   624	DEF NUM(X) AS ($0<=X<=$9)
   625	
   626	DEF DGMAX AS (I.DGMAX+D.DGMAX) !MAX. TOTAL LINE KEY DIGITS
   627	TABLE PWR10(0:DGMAX) [1,10,100,1000,10000,100000,1000000,10000000, &
   628	   100000000]
   629	
   630	DEF SGNBIT AS (1 ROTR 1)
   631	DEF BPW AS BITS.PER.WORD
   632	DEF BPC AS (BPW/CPW)
   633	
   634	DEF YES AS 1
   635	DEF NO  AS 0
   636	
   637	
   638	FIND ALT.NAME(".JBVER",JOBVER)
   639	
   640	%RUNCTL
   641	
   642	!  COMMAND MODELS
   643	
   644	LOCAL CMDL(CMDCNT)
   645	CMDL(K.ABT) _ CMDL(K.QUIT) _ CMDL(K.HUSH) _ CMDL(K.NHSH) _ &
   646	  CMDL(K.CONT) _ CMDL(K.LDEB) _ CMDL(K.LVER) _ ''
   647	CMDL(K.GO) _ '[ <LINE> ]'
   648	CMDL(K.CRE) _ CMDL(K.DO) _ CMDL(K.TOUT) _ '<FILE>'
   649	CMDL(K.BRK) _ CMDL(K.TRC) _ '<LINES> [ <VARIABLES> ] [ @ <INTEGER> ]'
   650	CMDL(K.NBRK) _ CMDL(K.NTRC) _ CMDL(K.LBRK) _ CMDL(K.LTRC) _ '[ <LINES> ]'
   651	CMDL(K.DISP) _ '<VARIABLES>'
   652	CMDL(K.SET) _ '<VARIABLE> = <VARIABLE OR CONSTANT> [ ,<ETC> ]'
   653	CMDL(K.CHNG) _ '[ <FILES> ]'
   654	CMDL(K.CAN) _ CMDL(K.CLS) _ '[ <UNITS> ]'
   655	CMDL(K.COMP) _ CMDL(K.INIT) _ CMDL(K.RUN) _ CMDL(K.PINI) _ &
   656	 CMDL(K.PRUN) _ '[ <LOAD STRING> ]'
   657	CMDL(K.DEB) _ '[ <LINE> OR: <SUBROUTINE OR FUNCTION NAME> ]'
   658	CMDL(K.MODE) _ '<ASCII, OCTAL OR DECLARED> <VARIABLES>'
   659	CMDL(K.NEXT) _ CMDL(K.STEP) _ '[ <INTEGER> ]'
   660	CMDL(K.NVBK) _ CMDL(K.NVTC) _ CMDL(K.LVBK) _ CMDL(K.LVTC) _ '[ <VARIABLES> ]'
   661	CMDL(K.VBRK) _ CMDL(K.VTRC) _ '<VARIABLES> [ <LINES> ]'
   662	
   663	LOCAL ALT:, INIT.ERROR:
   664	
   665	ERROR.EXIT _ INIT.ERROR
   666	INIT.DB ! INITIALIZE DEBUG TABLES
   667	FREEPTR _ CHPT(FREE,-1); IMGPTR _ CHPT(IMAGE,-1)
   668	CFN _ TEL
   669	ALTLOC _ ALT
   670	IF SFOIN THEN GETCOM
   671	RETURN
   672	
   673	INIT.ERROR: EXIT
   674	
   675	%PCMDL
   676	
   677	MSG("$SHOULD BE:$"); PRINT(IF DB.CNUM<=CWDCNT THEN CWD(DB.CNUM) ELSE CMD(DB.CNUM))
   678	PUT($ ); MSG(CMDL(DB.CNUM)); RETURN
   679	
   680	END PCMDL
   681	
   682	
   683	%GETCOM
   684	! GET COMMAND LINE.  EXECUTE COMMANDS.
   685	
   686	LOCAL %CSCAN, %COMMAND
   687	LOCAL ERRA:, INLA:, NCOM:
   688	
   689	OFINT
   690	NCOM:   SETRWP(0,%RWERR) ; LTTYLEN _ TTYLEN; SETPRMPT(%PRMPT)
   691	        ERROR.EXIT _ INLA
   692	
   693	LOOP DO
   694	
   695	INLA:   BEG.LPTR _ LPTR _ GETLINE(CFN)
   696	        WHILE NOT FCR THEN DO
   697	           DB.CNUM _ COMMAND(CWD,ERRA)
   698	           CSCAN; WHILE DEXU; INC DB.INTNO
   699	        END
   700	
   701	END
   702	RETURN
   703	
   704	ALT:    OFFALT; CLOBUF; CLIBUF; PUT(CARRET)
   705	        IF CFN#TEL THEN [MSG('ABORTED$'); CFNCLS]
   706	        GO NCOM
   707	
   708	ERRA:  CERR(BDCMND)
   709	
   710	CFNEOF:  OFFALT; LNGCHK; CFNCLS; FN _ TEL; ONALT.C; GO INLA
   711	
   712	
   713	%CSCAN
   714	
   715	        CSCAN.INIT
   716		DO DB.CNUM OF CWDCNT
   717	
   718	K.DO:	FFID(OCT 435544.000000)   !.CMD
   719	
   720	K.NEXT: K.STEP:	IF NOT FINT THEN ELW(INT.ID,1)
   721	
   722	K.GO:   IF NOT F.ADR THEN ELW(NAM.ID,MAIN.NAME)
   723	
   724	K.BRK: K.TRC:   IF NOT FLST THEN GO EROUT
   725	
   726	K.CAN: K.CLS:	DERR(NOTIMP)
   727	
   728	K.DEB:	IF NOT(FADR OR FNAME) THEN ELW(NAM.ID,MAIN.NAME)
   729	
   730	K.LIST: DO DB.CNUM _ K.LOPT(COMMAND(LWD,ERRA)) OF K.LOPT(1):K.LOPT(LWDCNT)
   731	
   732		K.LBRK: K.LTRC:	FLST
   733	
   734	        K.LVAL: DB.CNUM _ K.LVOPT(COMMAND(VWD,ERRA))
   735	                DERR(NOTIMP)
   736	
   737	        END ! LIST OPTIONS
   738	
   739	K.MODE: DERR(NOTIMP)
   740	
   741	K.NO:   DO DB.CNUM _ K.NOPT(COMMAND(NWD,ERRA)) OF K.NOPT(1):K.NOPT(NWDCNT)
   742	        K.NBRK: K.NTRC: F.LST
   743	
   744	        K.NVAL: DB.CNUM _ K.NVOPT(COMMAND(VWD,ERRA))
   745	                DERR(NOTIMP)
   746	
   747	        END ! NO OPTIONS
   748	
   749	K.TOUT: DERR(NOTIMP)
   750	
   751	K.VAL:  DB.CNUM _ K.VOPT(COMMAND(VWD,ERRA))
   752	        DERR(NOTIMP)
   753	
   754	K.PROD: DB.CNUM _ K.POPT(COMMAND(PWD,ERRA))
   755	        IF NOT SFOED AND FCR THEN DERR(NOTYMEX)
   756	        RETURN
   757	
   758	K.RUN: K.INIT: K.COMP: &
   759	        IF NOT SFOED AND FCR THEN DERR(NOTYMEX)
   760	        RETURN
   761	
   762	K.CHNG: K.CRE: &
   763	        IF NOT SFOED THEN DERR(NOTYMEX)
   764	        RETURN
   765	
   766	K.DISP: K.SET:	RETURN
   767	   
   768	
   769		END
   770	
   771	        IF NOT FCR THEN DPERR(%PCMDL); RETURN
   772	
   773	EROUT:  IF FCR THEN DPERR(%PCMDL) ELSE DERR(BDLRNG)
   774	
   775	END CSCAN
   776	
   777	%COMMAND(LIST(),ERR:)
   778	LOCAL CMD
   779	IF NOT ALPH(LASTCH) THEN GO ERR
   780	WDSTOR(CLMAX,ERR)
   781	CMD _ CMDREC(LIST,ERR)
   782	NXNSP ; BACKSP
   783	RETURN CMD
   784	END COMMAND
   785	
   786	%CPERR (%MSGPROC)
   787	
   788	ONALT.C
   789	CLIBUF; MSGPROC
   790	GO BELOW
   791	
   792	%%CERR (N)
   793	
   794	!  HANDLES INPUT ERRORS WHICH IF CFN WAS NOT TEL, ABORTS CFN INPUT
   795	
   796	         ONALT.C
   797	         CLIBUF; MSG(N)
   798	BELOW:   PUT(CARRET); IF CFN#TEL THEN PRINT(FREE)
   799	         OFFALT; CFNCLS; GO ^ERROR.EXIT
   800	
   801	END CPERR
   802	
   803	
   804	END GETCOM
   805	
   806	
   807	%LNGCHK
   808	IF ERRNUM=LNGERR THEN CERR(LNLONG); RETURN
   809	END LNGCHK
   810	
   811	
   812	%CFNCLS
   813	CLOSE(CFN <== TEL); RETURN
   814	END CFNCLS
   815	
   816	
   817	%PRMPT
   818	
   819	PUT($:); PUT($ ); RETURN
   820	
   821	END PRMPT
   822	
   823	
   824	%NXNSP
   825	
   826	! STORES IN LASTCH & RETURNS NEXT NON-BLANK
   827	
   828	WHILE SPCH(NXCHAR) THEN NULL; RETURN LASTCH
   829	
   830	END NXNSP
   831	
   832	
   833	%BACKSP
   834	
   835	PCHV LPTR; RETURN
   836	
   837	END BACKSP
   838	
   839	
   840	%WDSTOR (LMAX, LAB:)
   841	
   842	!  NEXT CHAR IS ALPHABETIC.  STORES CHARS UP TO NEXT NON-ALPHA
   843	!  IN INWD ARRAY; LPTR UPON RETURN IS BEFORE WD TERMINATOR.
   844	!  GOES TO LAB IF NO. OF ALPHA CHARS EXCEEDS LMAX.
   845	!  CONVERTS LOWER CASE ALPHA TO UPPER CASE.
   846	
   847	DEF INWDSZ AS (CLMAX+CPW-1)/CPW
   848	LOCAL INWD(0:INWDSZ-1)       !MUST HOLD CLMAX CHARS
   849	LOCAL PTR,CNT
   850	
   851	       MOVE INWDSZ FROM ALL EOLITWD TO INWD
   852	       PTR _ CHPT(INWD,CNT _ -1)
   853	       WHILE INC CNT<=LMAX THEN DO
   854	         IF NOT UPALPH(NXCHAR) THEN DO
   855	           IF LWALPH(LASTCH) THEN XLWUP(LASTCH) ELSE [BACKSP; RETURN]
   856	         END
   857	         NCHV PTR _ LASTCH
   858	       END
   859	       GO LAB
   860	
   861	
   862	%CMDREC (WD(), LAB:)
   863	
   864	! WORD RECOGNITION
   865	
   866	!  WORD IS AT ADDR INWD, NO. OF CHARS IS IN CNT.
   867	!  IF RECOGNIZES WORD AS WD(I), RETURNS I.
   868	!  ALLOWS SHORTEST UNIQUE ABBREVIATION.
   869	!  GOES TO LAB IF NO MATCH.
   870	!  IF COMMAND LOOKUP (CWD ARRAY), MAY BE AMBIGUITY, IN WHICH CASE
   871	!  ERR EXIT IS TAKEN.
   872	
   873	LOCAL %COMPARE
   874	LOCAL W, SAVE, TEMP, PTR
   875	
   876	       [W;CNT] _ CNT DIVMOD CPW
   877	       PTR _ 0
   878	       WHILE INWD(0) # ^WD(INC PTR) THEN DO
   879	         IF LESSTR(INWD(0),^WD(PTR)) THEN GO NXT
   880	       END
   881	! INWD(0) <= ^WD(PTR)
   882	NXT:   DO COMPARE OF -1:1
   883	-1:      GO LAB                !<, NO MATCH
   884	1:       INC PTR; GO NXT       !>, ONLY 1ST WD MATCH, CONTINUE
   885	0:       SAVE _ PTR; INC PTR   !=, MATCH
   886	         DO COMPARE OF -1:1    !AMBIGUITY CHECK
   887	 -1: 1:    RETURN SAVE         !<, NO AMBIGUITY
   888	  0:       CERR(AMBGCM)
   889	         END
   890	       END
   891	
   892	%COMPARE
   893	
   894	! COMPARES INWD TO COMMAND AT WD(PTR), UP TO END OF INWD.
   895	! RETURNS -1, 0 OR 1, IF <, = OR >, RESPECTIVELY.
   896	
   897	LOCAL J, I
   898	
   899	       I _ TEMP _ -1
   900	       WHILE INC I<W THEN DO
   901	CA:      J _ ^(WD(PTR)+I) BAND TEMP
   902	         IF INWD(I)#J THEN DO
   903	           RETURN IF LESSTR(INWD(I),J) THEN -1 ELSE 1
   904	         END
   905	       END
   906	       IF TEMP=-1 THEN [TEMP _ TEMP SHL (BPW-BPC*CNT); GO CA]
   907	       RETURN 0
   908	
   909	END COMPARE
   910	
   911	END CMDREC
   912	
   913	
   914	%WDREC (WD(), LAB:)
   915	
   916	!  SIMILAR TO CMDREC BUT ALLOWS NO ABBREVIATION.
   917	
   918	LOCAL PTR, I
   919	
   920	PTR _ 0
   921	LOOP DO
   922	  IF I _ ^WD(INC PTR) =^ND.STR THEN GO LAB
   923	  WHILE INWD(0)#I
   924	END
   925	I _ 0
   926	WHILE INC I <= (CNT-1)/CPW THEN DO  !REMAINING WDS OF STRING
   927	  IF INWD(I)#^(WD(PTR)+I) THEN GO LAB
   928	END
   929	RETURN PTR
   930	
   931	END WDREC
   932	
   933	END WDSTOR
   934	
   935	
   936	%CSCAN.INIT
   937	
   938	LOCAL FIDPTR
   939	LOCAL FIDTBL(0:2*WPF-1)
   940	
   941	MOVE 4 FROM ALL 0 TO ELID+1; SELP _ ELP _ 0
   942	FIDPTR _ FIDTBL-WPF; RETURN
   943	
   944	
   945	%FCR
   946	
   947	LOCAL TEMP
   948	
   949	TEMP _ [NXNSP=CARRET]; BACKSP; RETURN TEMP
   950	
   951	END FCR
   952	
   953	
   954	%FFID (EXTDEF)
   955	
   956	!  SCANS FOR FILE IDENTIFIER (FID) TERMINATED BY BLANK OR CR.
   957	!  CALLED WHEN NO ALTERNATIVE TO FID, SO TAKES ERROR EXIT IF FAILS.
   958	!  STORES FID INFO WITH SETFID; IF OK, STORES FID.ID & ARG TO BE 
   959	!  USED IN OPEN CALL.
   960	
   961	LOCAL EROUT:
   962	
   963	         IF FCR THEN CPERR(%PCMDL)
   964	         SETFID(FIDPTR +_ WPF, @LPTR, EXTDEF, EROUT)
   965	         ELW(FID.ID,-FIDPTR); RETURN
   966	
   967	EROUT:   CERR(FILERR(IFDERR))
   968	
   969	END FFID
   970	
   971	
   972	%FADR
   973	
   974	!  SCANS FOR CONSTRUCTION SPECIFIED AT ENTRY POINT.
   975	!
   976	!  ADR      LKEY  OR  $  OR  .  OR  #INT  OR  ADR+INT  OR  ADR-INT
   977	!           (LKEY FORM IS 0 TO I.DGMAX DIGITS, OPTIONAL 0 TO D.DGMAX
   978	!           DECIMAL DIGITS WITH >0 DIGITS IN ALL)
   979	!  LST      ADR[:ADR],...,ADR[:ADR]  OR  ALL
   980	!
   981	!  IF SUCCESSFUL, STORES APPROPRIATE EL.ID AND, IN EL ARRAY,
   982	!     ADR OF WD BEFORE 1ST WD OF SUBELEMENT LIST
   983	!                    (SEE %FRNGL)
   984	!
   985	!  RETURNS 1, WITH LPTR BEFORE CONSTRUCTION TERMINATOR.
   986	!  IF NOT SUCCESSFUL, RESETS LPTR AND RETURNS 0.
   987	!
   988	!  LOW-ORDER BITS OF LFGS REPRESENT STATES AS FOLLOWS:
   989	!
   990	!            ADR     LST
   991	!     :    + OR -     $
   992	!     #     DIGIT     .
   993	!
   994	!  THUS:
   995	
   996	DEF DOTB  AS 1
   997	DEF DGTB  AS (1 SHL 1)
   998	DEF NUMB  AS (1 SHL 2)
   999	DEF DLRB  AS (1 SHL 3)
  1000	DEF SGNB  AS (1 SHL 4)
  1001	DEF CLNB  AS (1 SHL 5)
  1002	DEF LSTB  AS (1 SHL 6)
  1003	DEF ADRB  AS (1 SHL 7)
  1004	
  1005	LOCAL %FRNGL
  1006	LOCAL LFGS
  1007	
  1008	         LFGS _ ADRB; ELW(ADR.ID,FRNGL); RETURN YES
  1009	
  1010	
  1011	%%FLST
  1012	
  1013	         LFGS _ LSTB
  1014	         ELW(LST.ID,FRNGL); RETURN YES
  1015	
  1016	
  1017	LAB:    RETURN NO
  1018	
  1019	
  1020	%FRNGL
  1021	
  1022	!    TERMINATES ON ANY SYMBOL NOT : + - $ # DIGIT .
  1023	!    STORES SUBELEMENTS IN SEL ARRAY (1 PER WD) & RETURNS ADR OF
  1024	!    WD BEFORE 1ST WD OF LIST.  SUBELEMENTS INCLUDE ANY SPECIAL
  1025	!    SYMBOL & (NEGATIVE OF) ANY NUMBER READ (LKEY STORED AS INTEGER).
  1026	!    LIST TERMINATED BY 0.
  1027	!    SPECIAL CASE FOR LSTB: 'ALL' INDICATES ALL LINES, RETURNS 0
  1028	
  1029	LOCAL %SVNUM, %SELW
  1030	LOCAL LVAL, TEMP, PTR, CNT
  1031	TABLE ALLWD(2)['ALL', ND.STR]
  1032	
  1033	! EXTRACTION OF TYPE BIT:
  1034	DEF TYPB AS (LFGS BAND (ADRB+LSTB))
  1035	
  1036	! CHECK FOR ILLEGAL STATES:
  1037	DEF NG(X) AS IF LFGS BAND (X) THEN GO OUT
  1038	
  1039	         TEMP _ LPTR
  1040	         IF NXNSP=CARRET THEN GO OUT
  1041	         PTR _ SELP
  1042	         CNT _ I.DGMAX; LVAL _ 0    !LVAL RESET IN SVNUM
  1043	
  1044	       LOOP DO
  1045	         EIF NUM(LASTCH) THEN DO
  1046	           NG(DLRB)
  1047	           LVAL _ LVAL*10+LASTCH-$0
  1048	! DON'T DEC CNT IF LEADING INTEGER ZERO
  1049	           IF NOT(LVAL=0=LFGS BAND DOTB) THEN IF DEC CNT<0 THEN GO OUT
  1050	           LFGS BOR_ DGTB
  1051	         END
  1052	
  1053	         ORIF LASTCH=$. THEN DO
  1054	           NG(SGNB+DLRB+NUMB+DOTB)
  1055	           LFGS BOR_ DOTB
  1056	           CNT _ D.DGMAX
  1057	         END
  1058	
  1059	         ELSE DO
  1060	           EIF LASTCH=$: THEN DO
  1061	             NG(ADRB+CLNB)
  1062	             SVNUM; LFGS _ TYPB BOR CLNB
  1063	           END
  1064	
  1065	           ORIF LASTCH=$+ OR LASTCH=$- THEN DO
  1066	             NG(SGNB)
  1067	             SVNUM; LFGS _ TYPB BOR (LFGS BAND CLNB) BOR SGNB
  1068	           END
  1069	
  1070	           ORIF LASTCH=$$ OR LASTCH=$# THEN DO
  1071	             NG(BNOT(ADRB+LSTB+CLNB))
  1072	             LFGS BOR_ IF LASTCH=$$ THEN DLRB ELSE NUMB
  1073	           END
  1074	
  1075	           ORIF LASTCH=$, THEN DO
  1076	             NG(ADRB) 
  1077	             SVNUM; LFGS _ TYPB
  1078	           END
  1079	
  1080	           ELSE GO ENDCH
  1081	
  1082	           SELW(LASTCH); CNT _ I.DGMAX
  1083	
  1084	         END
  1085	
  1086	         NXCHAR
  1087	       END
  1088	
  1089	ENDCH:   SVNUM; SELW(0); BACKSP; RETURN @SEL(PTR)
  1090	
  1091	OUT:     LPTR _ TEMP
  1092	        IF (LFGS<==0) BAND LSTB=0 THEN GO LAB
  1093	        NXNSP; BACKSP; WDSTOR(3,OUT)  !LEAVES LPTR BEFORE TERM
  1094	        WDREC(ALLWD,OUT) ; RETURN
  1095	
  1096	
  1097	%SELW (X)
  1098	
  1099	!  SUBELEMENT WRITE WITH OVERFLOW CHECK
  1100	
  1101	IF INC SELP>SELLIM THEN CERR(LSTLNG)
  1102	SEL(SELP) _ X; RETURN
  1103	
  1104	END SELW
  1105	
  1106	
  1107	%SVNUM
  1108	
  1109	!  CALLED AT : + - , (BEFORE SETTING STATE BIT) AND AT
  1110	!  TERMINATOR, TO STORE NEGATIVE OF LKEY/INTEGER PRECEDING, IF ANY.  
  1111	!  %FRNGL ACCUMULATED NUMBER IN LVAL, WITH LKEY DOT IGNORED
  1112	!  AND NO. OF DIGITS PAST DOT = 3-CNT.
  1113	!  MAY BE $ OR CURRENT LINE DOT;  IN ANY OTHER
  1114	!  CASE, ABSENCE OF DIGIT IS ILLEGAL.
  1115	!  0 ILLEGAL EXCEPT AFTER SIGN.
  1116	
  1117	         IF LFGS BAND DLRB THEN RETURN  !PREVIOUSLY DISALLOWED $DIGIT
  1118	         IF LFGS BAND DGTB=0 THEN DO
  1119	           IF LFGS BAND DOTB THEN [SELW($.); RETURN]
  1120	           GO OUT
  1121	         END
  1122	         IF LVAL=0 AND LFGS BAND SGNB=0 THEN GO OUT
  1123	         SELW ((LVAL<==0) * (IF LFGS BAND (SGNB+NUMB) THEN 1 ELSE &
  1124	           IF LFGS BAND DOTB THEN PWR10(CNT) ELSE PWR10(DDGMAX))*-1)
  1125	         RETURN
  1126	
  1127	END SVNUM
  1128	
  1129	END FRNGL
  1130	
  1131	END FADR
  1132	
  1133	%FINT
  1134	LOCAL VAL
  1135	IF GET.PINT(VAL) THEN [ELW(INT.ID,VAL) ; RETURN YES]
  1136	RETURN NO
  1137	END FINT
  1138	
  1139	%FNAME
  1140	LOCAL NAME
  1141	IF GET.NAME(NAME) THEN [ELW(NAM.ID,NAME) ; RETURN YES]
  1142	RETURN NO
  1143	END FNAME
  1144	
  1145	END CSCAN.INIT
  1146	
  1147	
  1148	
  1149	%PRGCHK
  1150	IF DB.NLINES=0 THEN CERR(NOPROG); RETURN
  1151	END PRGCHK
  1152	
  1153	
  1154	
  1155	%INLIST (I)
  1156	
  1157	!  IF NO PROGRAM, ERROR.
  1158	!  I IS INDEX INTO EL.ID & EL ARRAYS FOR LINE LIST INFO.
  1159	! EL.ID(I) IS LST.ID OR 0: IF LST.ID, EL(I) IS
  1160	!  ADDRESS OF WD BEFORE 1ST WD OF SUBELEMENT LIST; IF 0, OR
  1161	!  IF EL.ID(I) IS 0, INDICATES DEFAULT LIST OF #1:$.
  1162	!  CALCULATES AND STORES LIST PARAMETERS AS FOLLOWS:
  1163	!    LSTCNT    TOTAL NO. OF LINES SPECIFIED
  1164	!    LTBL(1)   LINE NO. OF 1ST LINE OF 1ST SUBRANGE (LIST CONSTRUCTION
  1165	!              IS SUBRANGES SEPARATED BY COMMAS)
  1166	!    LTBL(2)   NO. OF LINES IN THIS SUBRANGE (>=0)
  1167	!    LTBL(3)   LINE NO. OF 2ND SUBRANGE (IF ANY)
  1168	!    ETC.
  1169	!  RETURNS NO. OF SUBRANGES READ.
  1170	
  1171	DEF RNGMX AS 10  !MAX NO. OF SUBRANGES IN LINE LIST
  1172	LOCAL %NXADR
  1173	LOCAL MTCHFG, SAVE, CNT, PTR, WD()
  1174	LOCAL TERM
  1175	
  1176	         PRGCHK
  1177	         IF EL.ID(I)=0 OR EL(I)=0 THEN DO     !ALL LINES
  1178	           LSTCNT _ LTBL(2) _ DB.NLINES; LTBL(1) _ CNT _ 1
  1179	         END ELSE DO
  1180	           WD _ EL(I)
  1181	           CNT _ LSTCNT _ PTR _ I _ 0
  1182	           LOOP DO
  1183	             IF INC CNT>RNGMX THEN CERR(LSTLNG)
  1184	             SAVE _ 0; LTBL(INC I) _ NXADR
  1185	             IF TERM=$: THEN DO
  1186	               IF LTBL(INC I) _ NXADR-LTBL(I)+1 <0 THEN CERR(BDLRNG)
  1187	             END ELSE LTBL(INC I) _ MTCHFG
  1188	             LSTCNT +_ LTBL(I)
  1189	             WHILE TERM=$,
  1190	           END
  1191	         END
  1192	
  1193	         I.NXLNUM; RETURN CNT
  1194	
  1195	%NXADR
  1196	
  1197	!  RETURNS LINE NO. CORRESPONDING TO NEXT LINE ADDRESS (BEGINNING
  1198	!  AT INC PTR). LEAVES PTR AT : , OR 0, WITH WD(PTR) IN TERM.
  1199	!  NOTE: IF NEGATIVE SUBELEMENT, IS INTEGER REPRESENTING LINE KEY OR 
  1200	!  DISPLACEMENT.
  1201	
  1202	LOCAL NX1:, LKEY, TEMP
  1203	
  1204	         MTCHFG _ YES; LKEY _ 0
  1205	         EIF WD(INC PTR)<0 THEN DO
  1206	           XLKLN(LKEY_-WD(PTR),NX1)    !STORES RESULT IN LNUM
  1207	           GO NX2
  1208	NX1:       MTCHFG _ NO   !IS 1+GREATEST LINE NO. WITH SMALLER KEY
  1209	         END
  1210	         ORIF WD(PTR)=$. THEN LNUM_DB.DOT
  1211	         ORIF WD(PTR)=$$ THEN LNUM _ DB.NLINES
  1212	         ELSE !IS $#! IF LNUM_-WD(INC PTR)>DB.NLINES THEN CERR(BDLRNG)
  1213	
  1214	NX2:     IF TEMP_[WD(INC PTR)=$-] OR WD(PTR)=$+ THEN DO
  1215	           IF MTCHFG=NO THEN CERR(BDLRNG)
  1216	           INC PTR; LNUM +_ IF TEMP THEN WD(PTR) ELSE -WD(PTR)
  1217	           IF NOT(1<=LNUM<=DB.NLINES) THEN CERR(BDLRNG)
  1218	           INC PTR
  1219	         END ELSE DO     !NO DISPLACEMENT
  1220	           IF SAVE#0 AND MTCHFG=NO THEN DEC LNUM
  1221	         END
  1222	
  1223	         IF LKEY=0 THEN LKEY _ LINE.KEY(LNUM)
  1224	         IF SAVE=0 THEN SAVE _ LKEY ELSE IF SAVE>LKEY THEN CERR(BDLRNG)
  1225	         TERM _ WD(PTR); RETURN LNUM
  1226	
  1227	END NXADR
  1228	
  1229	END INLIST
  1230	
  1231	
  1232	%I.NXLNUM
  1233	
  1234	!  INITIALIZES %NXLNUM TO RETURN 1ST LINE NO. IN LTBL
  1235	!  CALLED BEFORE %INLIST RETURN.
  1236	
  1237	LOCAL CNT, PTR
  1238	
  1239	CNT _ -1; PTR _ 1; RETURN
  1240	
  1241	%%NXLNUM
  1242	
  1243	!  RETURNS (AND STORES IN LNUM) NEXT LINE NO. SPECIFIED IN LTBL.
  1244	!  BEWARE OF OVERCALLING (MAX. OF LSTCNT CALLS AFTER I.NXNLUM)!!
  1245	
  1246	IF INC CNT = LTBL(PTR+1) THEN DO
  1247	  WHILE LTBL(1+PTR+_2)=0 THEN NULL; CNT _ 0
  1248	END
  1249	RETURN LNUM _ LTBL(PTR)+CNT
  1250	
  1251	END I.NXLNUM
  1252	
  1253	
  1254	%XLKLN (ILKEY,LAB:)
  1255	
  1256	!  TRANSFORMS ILKEY (LINE KEY IN INTEGER FORM) TO ORDINAL LINE
  1257	!  NO., STORING RESULT IN LNUM.  IF EXACT MATCH, RETURNS; IF NOT,
  1258	!  RESULT IS 1+GREATEST LINE NO. WITH SMALLER LKEY & GOES TO LAB
  1259	!  RATHER THAN RETURN.
  1260	
  1261	         LNUM _ 0
  1262	         WHILE INC LNUM<=DB.NLINES THEN DO
  1263	           IF ILKEY <= LINE.KEY(LNUM) THEN DO
  1264	             IF ILKEY=LINE.KEY(LNUM) THEN RETURN; GO LAB
  1265	           END
  1266	         END
  1267	         GO LAB
  1268	
  1269	END XLKLN
  1270	
  1271	
  1272	%WKEY (I)
  1273	
  1274	! WRITES LINE.KEY(I) (LINE KEY IN DICTIONARY FORM) PLUS A BLANK, ON TEL.
  1275	
  1276	LOCAL FLG, KEY, TEMP, CNT
  1277	
  1278	FLG _ NO; KEY _ LINE.KEY(I); CNT _ DGMAX
  1279	WHILE DEC CNT>=D.DGMAX THEN DO      !PRINT INTEGER DIGITS
  1280	  [TEMP;KEY] _ KEY DIVMOD PWR10(CNT)
  1281	  IF TEMP THEN FLG _ YES  !SUPPRESS LEADING ZEROES
  1282	  IF FLG THEN PUT(TEMP+$0)
  1283	END
  1284	IF KEY THEN DO  !PRINT DEC. DIGITS
  1285	  PUT($.)
  1286	  WHILE KEY THEN [ [TEMP;KEY] _ KEY DIVMOD PWR10(CNT); DEC CNT; PUT(TEMP+$0) ]
  1287	END
  1288	RETURN
  1289	
  1290	END WKEY
  1291	
  1292	%OUTNUM (N, RAD)
  1293	
  1294	! CONVERTS N TO BASE RAD AND WRITES IT ON TEL
  1295	
  1296	LOCAL BUF(12), I
  1297	
  1298	IF N < 0 THEN [W(TEL,$-); N - _]
  1299	LOOP [FOR I _ 1 TO 12; [N; BUF(I)] _ N DIVMOD RAD; WHILE N # 0]
  1300	LOOP [W(TEL,BUF(I)+$0); WHILE DEC I > 0]
  1301	RETURN
  1302	
  1303	END OUTNUM
  1304	
  1305	
  1306	%ALPH (X)
  1307	! NOT MACRO SO X CAN HAVE SIDE EFFECT (I.E., NCHV)
  1308	RETURN [UPALPH(X) OR LWALPH(X)]
  1309	END ALPH
  1310	
  1311	
  1312	
  1313	%S.OFF(PTR)
  1314	!MAY BE NEGATIVE
  1315	LOCAL TEMP
  1316	IF (TEMP _ HW((PTR)+3,1)) BAND OCT 400000 THEN TEMP BOR_ OCT 777777000000
  1317	RETURN TEMP
  1318	END S.OFF
  1319	
  1320	
  1321	!  ERROR HANDLING
  1322	
  1323	%DERR (MSGADR)
  1324	
  1325	IF SETFG THEN [PRINT(MSGADR); CPERR(%OUTSET)]
  1326	PUT(CARRET); CERR(MSGADR)
  1327	
  1328	END DERR
  1329	
  1330	
  1331	%RWERR (N, %MSGPROC)
  1332	%%DPERR (%MSGPROC)
  1333	
  1334	IF SETFG THEN [MSGPROC; CPERR(%OUTSET)]
  1335	PUT(CARRET); CPERR(%MSGPROC)
  1336	
  1337	END RWERR
  1338	
  1339	
  1340	%SYMNERR (MSGADR, SYMNAM)
  1341	
  1342	LOCAL %X
  1343	
  1344	CPERR(%X)
  1345	
  1346	%%SYMERR (MSGADR, SYMPTR)
  1347	
  1348	SYMNAM _ S.NAM(SYMPTR); CPERR(%X)
  1349	
  1350	%X
  1351	
  1352	PUT(CARRET); PUTQSYM(SYMNAM,%PUT); PRINT(MSGADR)
  1353	IF SETFG THEN OUTSET
  1354	RETURN
  1355	
  1356	END X
  1357	
  1358	END SYMNERR
  1359	
  1360	
  1361	%VTYPA (S.TYPE)
  1362	
  1363	LOCAL I
  1364	TABLE S.TYPA(VTYPRNG) [S.INT,S.REAL,S.DOUB,S.CPLX,S.LGC,S.STR]
  1365	
  1366	FOR I _ INT TO STR IF S.TYPE=S.TYPA(I) THEN RETURN I
  1367	HALT
  1368	
  1369	END VTYPA
  1370	
  1371	
  1372	%PUTQSYM (SYMNAM, %PUT)
  1373	
  1374	!  PRINTS SYMBOL NAME SYMNAM IN QUOTES FOLLOWED BY BLANK, USING %PUT.
  1375	
  1376	PUT($"); PUTSYM(SYMNAM,%PUT); PUT($"); PUT($ ); RETURN
  1377	
  1378	END PUTQSYM
  1379	
  1380	
  1381	%PUTSYM (SYMNAM, %PUT)
  1382	
  1383	!  PRINTS SYMBOL NAME SYMNAM, USING %PUT.
  1384	
  1385	LOCAL CHAR,SXPTR
  1386	
  1387	SXPTR _ SXPT(@SYMNAM)
  1388	LOOP [REPEAT 6; WHILE CHAR _ NCHV SXPTR#0; PUT(CHAR+OCT 40)]
  1389	RETURN
  1390	
  1391	END PUTSYM
  1392	
  1393	
  1394	%GET.SYM
  1395	
  1396	!  GET SYMBOL.  IF SUCCESSFUL, RETURN SYMBOL PTR.
  1397	!  IF FAIL, TAKE APPROPRIATE ERROR EXIT.
  1398	
  1399	LOCAL %FSYM
  1400	LOCAL SYMPTR, SYMNAM
  1401	
  1402	IF NOT GET.NAME(SYMNAM) THEN DPERR(%PCMDL)
  1403	IF NOT FSYM THEN SYMNERR(UNDEFS,SYMNAM)
  1404	RETURN SYMPTR
  1405	
  1406	%FSYM
  1407	
  1408	!  LOOKS UP SYMNAM IN SYMBOL TABLE.  IF FINDS ARRAY ELEMENT
  1409	!  OR VARIABLE CORRESPONDING TO SYMNAM, SET SYMPTR ACCORDINGLY
  1410	!  AND RETURN YES ELSE RETURN NO.
  1411	
  1412	SYMPTR _ CURRENT.SYMT
  1413	LOOP DO
  1414	  WHILE S.VAR(SYMPTR) AND NOT S.ADJ(SYMPTR)
  1415	  IF SYMNAM=S.NAM(SYMPTR) THEN RETURN YES
  1416	  WHILE ^(SYMPTR +_ S.LEN(SYMPTR))#0
  1417	END
  1418	RETURN NO
  1419	
  1420	END FSYM
  1421	
  1422	END GET.SYM
  1423	
  1424	%GET.NAME(SYMNAM)
  1425	
  1426	LOCAL I, SXPTR
  1427	
  1428	SXPTR _ SXPT(@SYMNAM); SYMNAM _ 0
  1429	IF NOT ALPH(NXNSP) THEN [BACKSP ; RETURN NO]
  1430	I _ 6
  1431	LOOP [IF DEC I>=0 THEN NCHV SXPTR _ (LASTCH-OCT 40); WHILE ALPH(NXCHAR) OR $0<=LASTCH<=$9]
  1432	IF SPCH(LASTCH) THEN NXNSP
  1433	RETURN YES
  1434	END GET.NAME
  1435	
  1436	
  1437	%GET.VAR
  1438	
  1439	!  GET VARIABLE/ARRAY ELEMENT WITH CONSTANT OR INTEGER VARIABLE
  1440	!  SUBSCRIPTS.  IF SUCCESSFUL, RETURN SYMBOL PTR AND LOCATION.
  1441	!  IF FAIL, TAKE APPROPRIATE ERROR EXIT.
  1442	!  DISALLOW ARRAY NAME WITHOUT SUBSCRIPTS.
  1443	
  1444	LOCAL SYMPTR, SUBPTR, LOC, I, %GET.INT, VAL
  1445	
  1446	SYMPTR _ GET.SYM; LOC _ 0
  1447	EIF LASTCH=$( THEN DO
  1448	  IF NOT S.ARYB(SYMPTR) THEN SYMERR(NOTARY,SYMPTR)
  1449	  I _ 0; INIT.S.MUL(SYMPTR)
  1450	  LOOP DO
  1451	    IF NOT GET.INT THEN DO
  1452	      IF S.ARYB(SUBPTR _ GET.SYM) THEN SYMERR(ISARY,SUBPTR)
  1453	      IF S.TYP(SUBPTR)#S.INT THEN SYMERR(BADINT,SUBPTR)
  1454	      VAL _ ^(S.LOC(SUBPTR))
  1455	    END
  1456	    IF INC I>SUBSMAX THEN SYMERR(DIMLIT,SYMPTR)
  1457	    SUBS(I) _ VAL
  1458	    WHILE LASTCH=$,
  1459	    IF I=S.SNUM(SYMPTR) THEN SYMERR(SUBCNT,SYMPTR)
  1460	    LOC +_ VAL*NX.S.MUL
  1461	  END
  1462	  IF LASTCH#$) THEN DPERR(%PCMDL); NXNSP
  1463	  IF I#S.SNUM(SYMPTR) THEN SYMERR(SUBCNT,SYMPTR)
  1464	  IF NOT(0<=LOC +_ VAL*NX.S.MUL+S.OFF(SYMPTR)<S.SIZ(SYMPTR)) THEN SYMERR(BOUNDS,SYMPTR)
  1465	END
  1466	FIF S.ARYB(SYMPTR) THEN SYMERR(ISARY,SYMPTR)
  1467	RETURN [SYMPTR; LOC+IF S.TYP(SYMPTR)=S.STR THEN S.SLOC(SYMPTR) &
  1468	  ELSE IF S.ARYB(SYMPTR) AND S.DUM(SYMPTR) THEN S.DLOC(SYMPTR) &
  1469	    ELSE S.LOC(SYMPTR)]
  1470	
  1471	
  1472	%GET.INT
  1473	
  1474	!  GET INTEGER.  IF SUCCESSFUL, RETURN YES AND SET VAL TO INTEGER.
  1475	!  IF FAIL, RETURN NO AND RESET LPTR BEFORE NEXT NON-BLANK CHAR.
  1476	
  1477	LOCAL SGN
  1478	
  1479	SGN _ 1
  1480	IF NXNSP=$- THEN [SGN _ -1; NXCHAR]
  1481	VAL *_ SGN; RETURN YES
  1482	
  1483	END GET.INT
  1484	
  1485	END GET.VAR
  1486	
  1487	%GET.PINT(VAL)
  1488	
  1489	VAL _ 0
  1490	IF NOT($0<=LASTCH<=$9) THEN [BACKSP; RETURN NO]
  1491	LOOP DO
  1492	  VAL _ VAL*10+LASTCH-$0; WHILE $0<=NXCHAR<=$9
  1493	END
  1494	IF SPCH(LASTCH) THEN NXNSP; RETURN YES
  1495	
  1496	END GET.PINT
  1497	
  1498	%DEXU
  1499	
  1500	LOCAL INFN, ERR:
  1501	LOCAL %SET, %DISPLAY, %DEBUG.COMMAND, %EIEXIT
  1502	LOCAL X, I, CNT
  1503	
  1504	DEF WKEYRNG(FIRST,LAST) BY WKEY(FIRST)
  1505	  IF LAST#FIRST THEN [PUT($:); WKEY(LAST)]
  1506	  ENDM WKEYRNG
  1507	
  1508		SETFG _ 0
  1509		DO DB.CNUM OF CMDCNT
  1510	
  1511	K.DO:   OFFALT
  1512		IF TELCHK THEN INFN _ TEL ELSE DO
  1513		  LOOP DO
  1514		    INFN _ OPEN(EL(1),INPUT+DIRECT+CHARACTER,ERR); WHILE 0
  1515	ERR:        IF ERRNUM#FNFERR OR EXTQ(FIDP)=YES THEN DO
  1516	                IF ERRNUM=CORERR THEN CERR(NOCORE)
  1517	                IF ERRNUM>FNFERR THEN &
  1518	                        [PRINT('CANNOT OPEN '); WFID(FIDP); PUT(CARRET)]
  1519	                CERR(FILERR(ERRNUM))
  1520	            END
  1521		    EXTQ(FIDP) _ YES; EXTARG(FIDP) _ 0
  1522		  END
  1523		END
  1524	        CLOSE(CFN<==INFN); SETRWE(CFN,CFNEOF)
  1525	
  1526	K.LVER:	OUTNUM(HW(@JOBVER),8); PUT($.); OUTNUM(HW(@JOBVER,1),8); PUT(CARRET)
  1527	
  1528	K.GO:  DERR(NOTIMP)
  1529	
  1530	K.DEB:  DEBUG.COMMAND
  1531	
  1532	K.LDEB: PRINT('DEBUG AT '); PUTSYM(RT.NAME(CURRENT.ROUTINE),%PUT)
  1533		PUT(CARRET)
  1534	        EIF CONT.OK THEN [PRINT('CONTINUABLE AT '); WKEY(DB.DOT)]
  1535	        ELSE PRINT(NOCONT)
  1536		PUT(CARRET)
  1537	
  1538	K.BRK: K.TRC:  &
  1539		X _ IF DB.CNUM=K.BRK THEN BRKBIT ELSE TRCBIT
  1540		INLIST(1)
  1541		I _ 0
  1542		LOOP DO
  1543		  CNT _ 0; REPEAT LTBL(I+_2) [^CORE.ADDR(LNUM) BOR _ X; INC CNT]
  1544		  IF CNT=0 THEN DO
  1545		    PRINT(NOXRNG); CNT _ LNUM <== LTBL(I-1)  !1ST IN SUBRANGE
  1546		    WKEYRNG(LNUM,CNT)
  1547		    PUT(CARRET)
  1548		  END
  1549		  WHILE LSTCNT -_ LTBL(I)
  1550		END
  1551	
  1552	K.LBRK:  K.LTRC:  &
  1553		X _ IF DB.CNUM=K.LBRK THEN BRKBIT ELSE TRCBIT
  1554		LNUM _ CNT _ 0
  1555		LOOP DO
  1556		  LOOP DO
  1557		    IF INC LNUM>DB.NLINES THEN GO AWAY
  1558		    WHILE ^CORE.ADDR(LNUM) BAND X=0
  1559		  END
  1560		  IF CNT THEN [PUT($,); PUT($ )]; I _ LNUM
  1561		  LOOP DO
  1562		    WHILE INC LNUM<=DB.NLINES 
  1563		    WHILE ^CORE.ADDR(LNUM) BAND X
  1564		  END
  1565		  IF INC CNT=1 THEN PRINT(IF X=BRKBIT THEN BRKSTR ELSE TRCSTR)
  1566		  WKEYRNG(I,LNUM-1)
  1567		END
  1568	AWAY:	PUT(CARRET)
  1569	
  1570	K.CONT: IF NOT CONT.OK THEN CERR(NOCONT)
  1571	        IORESTORE; RESINT; INC DB.INTNO; RETURN NO
  1572	
  1573	K.DISP: DISPLAY
  1574	
  1575	K.SET:  SET
  1576	
  1577	K.NBRK:	K.NTRC:	NULL
  1578	    X _ BNOT(IF DB.CNUM=K.NBRK THEN BRKBIT ELSE TRCBIT)
  1579	    INLIST(1)
  1580	    REPEAT LSTCNT  ^(CORE.ADDR(NXLNUM)) BAND_X
  1581	
  1582	K.QUIT: K.ABT: OFFALT; SFCLSALL; QUIT
  1583	
  1584	K.RUN:  EIEXIT('EXECUTE /SDEBUG ')
  1585	
  1586	K.PRUN: EIEXIT('EXECUTE ')
  1587	
  1588	K.COMP: EIEXIT('COMPILE /SDEBUG ')
  1589	
  1590	K.PCMP: EIEXIT('COMPILE ')
  1591	
  1592	K.INIT: EIEXIT('EXECUTE %13Y /SDEBUG ')
  1593	
  1594	K.PINI: EIEXIT('EXECUTE %13Y ')
  1595	
  1596	K.CHNG: K.CRE: EIEXIT('')
  1597	
  1598		END
  1599	    RETURN YES
  1600	
  1601	
  1602	%DEBUG.COMMAND
  1603	
  1604	LOCAL X, NEW.ROUTINE(), ORD
  1605	
  1606	EIF ELID(1)=ADR.ID THEN DO
  1607	   INLIST(1)
  1608	   X _ LINE.KEY(NXLNUM)
  1609	   NEW.ROUTINE _ LINE.START.ROUTINE(CURRENT.ROUTINE)
  1610	   ORD _ ORDINAL.START-1
  1611	   WHILE X>RT.HIGH.LINE.KEY(NEW.ROUTINE) AND &
  1612	        INC ORD=RT.ORDINAL(NEW.ROUTINE) THEN NEXT.ROUTINE(NEW.ROUTINE)
  1613	END
  1614	ELSE DO
  1615	   NEW.ROUTINE _ FIRST.ROUTINE
  1616	   LOOP DO
  1617	      REPEAT NUM.OF.ROUTINES
  1618	      WHILE EL(1)#RT.NAME(NEW.ROUTINE)
  1619	      NEXT.ROUTINE(NEW.ROUTINE)
  1620	   END
  1621	   IF EL(1)#RT.NAME(NEW.ROUTINE) THEN DERR('NO SUCH ROUTINE')
  1622	END
  1623	SET.CURRENT.ROUTINE(NEW.ROUTINE)
  1624	RETURN
  1625	
  1626	END DEBUG.COMMAND
  1627	
  1628	%EIEXIT (S) ! EXIT TO EXTERNAL INTERFACE. EITHER SFORTRAN EDITOR OR TYMEX
  1629	
  1630	LOCAL BUFF(0:GLBSZ-1), PB, P, N, %WRITE.TMP, %RUN
  1631	
  1632	IF SFOED THEN DO
  1633	 WRITE.TMP('SFC',FREE,(GLCNT+CPW)/CPW)
  1634	 SFRUN
  1635	END ELSE DO
  1636	 PB _ CHPT(BUFF,-1) ; P _ CHPT(S,-1) ; N _ 3+CPW-1
  1637	 WHILE NCHV PB_NCHV P#EOLIT THEN INC N
  1638	 WHILE NCHV PB_NCHV LPTR#EOLIT THEN INC N
  1639	 CHV PB_CARRET ; NCHV PB_LNFEED ; NCHV PB_EOLIT
  1640	 WRITE.TMP('SVC',BUFF,N/CPW)
  1641	 RUN('RPG',1)
  1642	END
  1643	
  1644	%WRITE.TMP(CODE,BUFF,N)
  1645	LOCAL T.BLK(0:1),FILE(0:1),FID.TBL(0:WPF),F,%GET.NAME,TMPERR:
  1646	DEF IOWD(B,N) AS [18,18]*[-N,B-1]
  1647	LOCAL W.TMP.EXIT:
  1648	
  1649	GET.NAME
  1650	
  1651	^OCT 16_[18,18]*[3,T.BLK]
  1652	EXU(OCT 47,OCT 16,OCT 44,W.TMP.EXIT)
  1653	
  1654	F_OPEN(-FID.TBL,SEQUEN+OUTPUT+WORD,TMPERR,2)
  1655	WB(F,N,BUFF)
  1656	CLOSE(F)
  1657	
  1658	W.TMP.EXIT: RETURN
  1659	
  1660	TMPERR: DERR('CANNOT WRITE TEMPORARY FILE$')
  1661	
  1662	%GETNAME
  1663	LOCAL JOB,I,J,P
  1664	TABLE TMP.EXT[OCT 64.55.60.00.00.00]
  1665	
  1666	EXU(OCT 47,OCT 16,OCT 30)
  1667	JOB_^OCT 16 ; P_CHPT(FILE,-1) ; I_100
  1668	WHILE I>0 THEN DO
  1669	   [J;JOB]_JOB DIVMOD I
  1670	   I/_10
  1671	   NCHV P_J+$0
  1672	END
  1673	I_CHPT(CODE,-1)
  1674	WHILE NCHV P_NCHV I#EOLIT THEN NULL
  1675	P_CHPT(FILE,-1)
  1676	SETFID(FID.TBL,@P,TMP.EXT,TMPERR)
  1677	T.BLK(0)_NAMARG(FID.TBL) SHL 18
  1678	T.BLK(1)_IOWD(BUFF,N)
  1679	RETURN
  1680	END GET.NAME
  1681	END WRITE.TMP
  1682	
  1683	!EXECUTE RUN UUO ON FILE 'NAME'
  1684	!
  1685	%RUN(NAME,START)
  1686	LOCAL RUN.BLK(0:5),FID.TBL(0:WPF),P,RUNERR:
  1687	RUN.BLK(0)_OCT 63.71.63.00.00.00  ! 'SYS' IN SIXBIT
  1688	P_CHPT(NAME,-1)
  1689	SETFID(FID.TBL,@P,0,RUNERR)
  1690	RUN.BLK(1)_NAMARG(FID.TBL)
  1691	MOVE 4 FROM ALL 0 TO @RUN.BLK(2)
  1692	^OCT 16_[18,18]*[START,RUN.BLK]
  1693	EXU(OCT 47,OCT 16,OCT 35)
  1694	RUNERR: DERR('CANNOT RUN TYMEX')
  1695	END RUN
  1696	
  1697	END EIEXIT
  1698	
  1699	%SET
  1700	
  1701	LOCAL %GETVAL
  1702	LOCAL RLOC, LLOC, ILPTR, SVLPTR, VPTR, CHAR, TEMP, SYMPTR
  1703	
  1704	SETFG _ 1
  1705	ILPTR _ SVLPTR _ LPTR
  1706	LOOP DO
  1707	  [SYMPTR; LLOC] _ DOUBLE GET.VAR
  1708	  IF LASTCH#$= OR NOT($,#NXNSP#CARRET) THEN DPERR(%PCMDL)
  1709	  IF ALPH(LASTCH) THEN DO
  1710	    BACKSP; [VPTR; RLOC] _ DOUBLE GET.VAR
  1711	    IF S.TYP(VPTR)#S.TYP(SYMPTR) THEN SYMERR(BDMTCH,VPTR)
  1712	    ^LLOC _ ^RLOC
  1713	  END ELSE GETVAL(LLOC,S.TYP(SYMPTR))
  1714	  SVLPTR _ LPTR
  1715	  WHILE LASTCH=$,
  1716	END
  1717	IF LASTCH#CARRET THEN DPERR(%PCMDL)
  1718	RETURN
  1719	
  1720	%GETVAL (LOC, S.TYPE)
  1721	
  1722	!  USE SFORW TO SCAN & ACCUMULATE VALUE AT LOC FOR VARIABLE
  1723	!  OF TYPE S.TYPE.
  1724	!  LASTCH IS NON(BLANK OR ALPH). RETURNS WITH LASTCH AS NON-BLANK TERMINATOR.
  1725	!  IF PTR INVOLVED, IS SYMPTR.
  1726	
  1727		FORM _ -1    !REF'D BY NUMSCAN ERROR
  1728		VADR _ LOC; VCNT _ 1
  1729		IF VTYP _ VTYPA(S.TYPE)=CPLX THEN DO
  1730		  IF LASTCH#$( THEN DERR(BDCPLX); NXNSP
  1731		  VTYP _ REAL; INC VCNT
  1732		END
  1733		LOOP DO
  1734	
  1735		DO VTYP OF VTYPRNG
  1736	
  1737	LGC:	CHAR _ EOLITWD; TEMP _ CHPT(@CHAR,-1)
  1738		IF LASTCH#$. THEN DERR(BDCONS)
  1739		LOOP DO
  1740		  REPEAT 5; WHILE ALPH(NXCHAR); NCHV TEMP _ LASTCH
  1741		END
  1742		I _ NO
  1743		EIF CHAR=^'FALSE' THEN NXCHAR
  1744		ORIF CHAR=^'TRUE' THEN I _ YES
  1745		ELSE DERR(BDCONS)
  1746		IF LASTCH#$. THEN DERR(BDCONS)
  1747		LGCPK(I); NXNSP
  1748	
  1749	STR:	IF $'#LASTCH#$" THEN DERR(BDCONS)
  1750		CHAR _ LASTCH; TEMP _ CHPT(VADR,-1); CNT _ S.SCAP(SYMPTR)
  1751		LOOP DO
  1752		  WHILE DEC CNT>=0; WHILE CARRET#NXCHAR#CHAR; NCHV TEMP _ LASTCH
  1753		END
  1754		EIF CNT>=0 THEN NCHV TEMP _ EOLIT
  1755		! NOTE THAT CARRET SUPPLIES STRING TERMINATOR.
  1756		ELSE WHILE CARRET#NXCHAR#CHAR THEN NULL !INPUT BEYOND CAPACITY
  1757		IF LASTCH#CARRET THEN NXNSP
  1758	
  1759	INT: REAL: DOUB: &
  1760		NUMSCINIT
  1761		LOOP [NUMSCAN(LASTCH); WHILE $,#NXCHAR#CARRET AND $ #LASTCH#$)]
  1762		NUMSCAN(-2)
  1763		IF LASTCH=$  THEN NXNSP
  1764	
  1765		END
  1766		WHILE DEC VCNT>0
  1767		IF LASTCH#$, THEN DERR(BDCPLX); NXNSP
  1768		INC VADR
  1769	
  1770		END
  1771		IF VADR>LOC THEN DO   !COMPLEX
  1772		  IF LASTCH#$) THEN DERR(BDCPLX); NXNSP
  1773		END
  1774		RETURN
  1775	
  1776	END GETVAL
  1777	
  1778	
  1779	%OUTSET
  1780	
  1781	PUT(CARRET)
  1782	EIF ILPTR=SVLPTR THEN [PRINT('NO '); PRINT(ASSIGN)]
  1783	ELSE DO
  1784	  PRINT(ASSIGN); PUT($:); PUT(CARRET)
  1785	  PCHV SVLPTR  !TO BEFORE TERMINATOR
  1786	  WHILE ILPTR#SVLPTR THEN PUT(NCHV ILPTR)
  1787	END
  1788	RETURN
  1789	
  1790	END OUTSET
  1791	
  1792	END SET
  1793	
  1794	
  1795	%DISPLAY
  1796	
  1797	LOCAL %DPUT.INIT, %DPUT, %PUTDBUF
  1798	LOCAL %PUTVAL
  1799	DEF DBUFLEN AS 133   !MAX TTYLEN+1 FOR EOLIT
  1800	DEF DBUFSZ AS ((DBUFLEN+CPW-1)/CPW)
  1801	LOCAL DBUF(0:DBUFSZ-1)
  1802	LOCAL DPOS   !POSITION FOR LINE SINCE DBUF.INIT
  1803	LOCAL DCNT   !TO CHECK FOR DBUF OVERFLOW (PAST TTYLEN)
  1804	LOCAL DPTR
  1805	LOCAL LOC, SYMPTR
  1806	
  1807	DPUT.INIT
  1808	LOOP DO
  1809	  [SYMPTR; LOC] _ DOUBLE GET.VAR
  1810	  PUTSYM(S.NAM(SYMPTR),%DPUT)
  1811	  IF S.ARYB(SYMPTR) THEN DO
  1812	    DPUT($(); I _ 0
  1813	    WHILE INC I<S.SNUM(SYMPTR) THEN DO
  1814	      PUTVAL(@SUBS(I),S.INT); DPUT($,)
  1815	    END
  1816	    PUTVAL(@SUBS(I),S.INT); DPUT($))
  1817	  END
  1818	  DPUT($ ); DPUT($=); PUTVAL(LOC,S.TYP(SYMPTR)); PUTDBUF
  1819	  WHILE LASTCH=$,
  1820	END
  1821	IF LASTCH#CARRET THEN DPERR(%PCMDL)
  1822	PUT(CARRET)
  1823	RETURN
  1824	
  1825	
  1826	%PUTVAL (LOC, S.TYPE)
  1827	
  1828	!  USE SFORW FOR OUTPUT OF VALUE OF SPECIFIED TYPE
  1829	!  AT LOC.
  1830	!  IF PTR INVOLVED, IS SYMPTR.
  1831	
  1832	LOCAL CHAR, TEMP
  1833	
  1834		VADR _ LOC; VCNT _ 1
  1835		IF VTYP _ VTYPA(S.TYPE) =CPLX THEN [VTYP _ REAL; INC VCNT]
  1836		LOOP DO
  1837	
  1838		DO VTYP OF VTYPRNG
  1839	
  1840	LGC:	DPUT($ ); DPUT(IF LGCUNPK THEN $T ELSE $F)
  1841	
  1842	STR:	TEMP _ CHPT(VADR,-1); DPUT($ ); DPUT($")
  1843		LOOP DO
  1844		  REPEAT S.SCAP(SYMPTR); WHILE CHAR _ NCHV TEMP#EOLIT; DPUT(CHAR)
  1845		END
  1846		DPUT($")
  1847	
  1848	INT:	DPUT(IF NUMUN.INIT(INTFLD) THEN $-  ELSE $ )
  1849		REPEAT NUMUNPK DPUT(NUMUNPK)
  1850	
  1851	REAL: DOUB: &
  1852		TEMP _ POUT(%DPUT); FLOUT; POUT(TEMP)
  1853	
  1854		END
  1855		WHILE DEC VCNT>0
  1856		DPUT($,)
  1857		INC VADR
  1858	
  1859		END
  1860		RETURN
  1861	
  1862	END PUTVAL
  1863	
  1864	
  1865	%DPUT.INIT
  1866	
  1867	!  INITIALIZATION (CALLED ONCE PER DISPLAY COMMAND).
  1868	
  1869	LOCAL %DBUF.INIT
  1870	
  1871	DPOS _ 0; DBUF.INIT; RETURN
  1872	
  1873	%%DPUT (CHAR)
  1874	
  1875	!  STORE CHAR IN DBUF OR, IF OVERFLOW, PUT TO TERMINAL.
  1876	
  1877	EIF DEC DCNT>0 THEN NCHV DPTR _ CHAR
  1878	ELSE PUTDBUF
  1879	RETURN
  1880	
  1881	%PUTDBUF
  1882	
  1883	!  PUTS DBUF TO TERMINAL AND INITS FOR NEXT DISPLAY ITEM.
  1884	
  1885	IF DPOS>0 THEN DO
  1886	  EIF DPOS+3+(LTTYLEN+1-DCNT)>=LTTYLEN THEN [PUT(CARRET); DPOS _ 0]
  1887	  ELSE [REPEAT 3 PUT($ ); DPOS +_ 3]
  1888	END
  1889	PRINT(DBUF); DPOS +_ LTTYLEN+1-DCNT; DBUF.INIT; RETURN
  1890	
  1891	END PUTDBUF
  1892	
  1893	
  1894	%DBUF.INIT
  1895	
  1896	!  INITIALIZE FOR (DPUT OF) NEW ITEM OF DISPLAY OUTPUT.
  1897	
  1898	MOVE DBUFSZ FROM ALL EOLITWD TO DBUF
  1899	DPTR _ CHPT(DBUF,-1); DCNT _ LTTYLEN+1; RETURN
  1900	
  1901	END DBUF.INIT
  1902	
  1903	END DPUT.INIT
  1904	
  1905	END DISPLAY
  1906	
  1907	END DEXU
  1908	
  1909	
  1910	%STM (AC)
  1911	!
  1912	! AC IS THE AC FIELD OF THE STM UUO.
  1913	!
  1914	
  1915	IF AC=0 THEN RETURN    !FOR SPEED
  1916	PRINT(IF AC BAND AC.BRKBIT THEN BRKSTR ELSE TRCSTR)
  1917	STM.REPORT
  1918	IF AC BAND AC.BRKBIT=0 THEN RETURN
  1919	CONT.OK _ YES ; GETCOM ; RETURN
  1920	
  1921	END STM
  1922	
  1923	%PAWS
  1924	! CALLED BY PAUSE ROUTINE
  1925	
  1926	%%CONERR
  1927	! Called by continuable errors
  1928	
  1929	STM.REPORT
  1930	CONT.OK _ YES
  1931	GETCOM
  1932	RETURN
  1933	
  1934	END PAWS
  1935	
  1936	
  1937	%XIT
  1938	
  1939	! CALLED BY STOP AND END STATEMENTS
  1940	
  1941	%%NCNERR
  1942	
  1943	! Called by noncontinuable errors
  1944	
  1945	STM.REPORT
  1946	CONT.OK _ NO
  1947	UNCORE
  1948	GETCOM
  1949	RETURN
  1950	
  1951	END XIT
  1952	
  1953	%QUIT
  1954	
  1955	! Called by QUIT command and statement
  1956	
  1957	CONT.OK _ NO
  1958	UNCORE
  1959	SFCLS.ALL
  1960	EXU(OCT 47,1,OCT 12,0)
  1961	END QUIT
  1962	
  1963	%STM.REPORT
  1964	
  1965	! Report statement at which stop occurred
  1966	
  1967	SET.DOT.TO.CURLINE ! Set '.' to current statement
  1968	PRINT('AT ')
  1969	IF CURRENT.ROUTINE#LAST.ROUTINE.REPORTED THEN &
  1970	        [ PUTSYM(CURRENT.ROUTINE,%PUT) ; PUT($ ) ]
  1971	LAST.ROUTINE.REPORTED _ CURRENT.ROUTINE
  1972	WKEY(DB.DOT) ; PUT(CARRET)
  1973	RETURN
  1974	END STM.REPORT
  1975	
  1976	%INIT.DB
  1977	
  1978	LOCAL HDR(0:DB.HDR.SIZE-1), RT(), T, DBFOPE:, DBFRWE:
  1979	LOCAL DB.FIDTBL(0:WPF-1)
  1980	
  1981	! Open debug information file, read and check header and create routine
  1982	! table. Also, set the current debug context to the main program.
  1983	
  1984	! The debug informatin file name is stored by the loader in
  1985	! a LOOKUP block at $DBFNM. Put the file information in a
  1986	! SETFID block for file opening by IOCS. Save file number in DB.FNO
  1987	
  1988	MOVE WPF FROM ALL 0 TO DB.FIDTBL
  1989	ARGCNT(DB.FIDTBL) _ MINARG
  1990	NAMARG(DB.FIDTBL) _ DBFNM(0)
  1991	EXTARG(DB.FIDTBL) _ DBFNM(1)
  1992	EXTQ(DB.FIDTBL) _ 1
  1993	
  1994	DB.FNO _ OPEN(-DB.FIDTBL,DIRECT+UPDATE+WORD,DBFOPE)
  1995	SETRWE(DB.FNO,DBFRWE) 
  1996	
  1997	RB(DB.FNO,DB.HDR.SIZE,@HDR(0)) ! Read debug file header
  1998	
  1999	IF DB.HDR.VERS(HDR)#DB.VERSION THEN &
  2000	        CERR('WRONG VERSION IN DEBUG INFORMATION FILE.')
  2001	IF DB.HDR.DATE(HDR)#DBFDT THEN &
  2002	        CERR('OUT OF DATE DEBUG INFORMATION FILE.')
  2003	
  2004	SETCP(DB.FNO,DB.RT.FILE.LOC(HDR)) ! Position to routine table info
  2005	NUM.OF.ROUTINES _ DB.RT.NO.WORDS(HDR)/RT.FESIZE ! Number of routines
  2006	FIRST.ROUTINE _ GET.BLOCK(NUM.OF.ROUTINES*RT.CESIZE)
  2007	
  2008	RT _ FIRST.ROUTINE ! Point to first routine table entry
  2009	REPEAT NUM.OF.ROUTINES DO
  2010	 RT.NAME(RT) _ R(DB.FNO) ! Read routine name
  2011	 RT.SYMT.FILE.DESC(RT) _ R(DB.FNO) ! Read symbol table location
  2012	 RT.SYMT.IN(RT) _ NO ! Set symbol table not in core
  2013	 RT.DICT.FILE.DESC(RT) _ R(DB.FNO) ! Read dictionary location
  2014	 RT.DICT.IN(RT) _ NO ! Set dictionary not in core
  2015	 T _ R(DB.FNO) ! Read high line key and routine ordinal
  2016	 RT.ORDINAL(RT) _ BYT(T,9,27)
  2017	 RT.HIGH.LINE.KEY(RT) _ BYT(T,27,0)
  2018	 IF RT.NAME(RT)=MAIN.NAME THEN MAIN.ROUTINE _ RT ! Save index of main program
  2019	END
  2020	LAST.ROUTINE.REPORTED _ NO.ROUTINE ! No previous STM executed
  2021	CURRENT.ROUTINE _ NO.ROUTINE ! No current routine as yet
  2022	SET.CURRENT.ROUTINE(MAIN.ROUTINE) ! Make main program current routine
  2023	RETURN
  2024	
  2025	DBFOPE: CERR('CANNOT OPEN DEBUG INFORMATION FILE.')
  2026	DBFRWE: CERR('ERROR READING DEBUG INFORMATION FILE.')
  2027	END INIT.DB
  2028	
  2029	%SET.CURRENT.ROUTINE (R())
  2030	
  2031	! Make "R" the current routine. Read in its dictionary and
  2032	! symbol table.
  2033	
  2034	IF CURRENT.ROUTINE=R THEN RETURN
  2035	
  2036	OFFALT
  2037	
  2038	IF NOT RT.DICT.IN(R) THEN DO
  2039	 EIF CURRENT.ROUTINE#NO.ROUTINE AND &
  2040	        RT.DICT.FILE.DESC(CURRENT.ROUTINE)=RT.DICT.FILE.DESC(R) THEN DO
  2041	  RT.DICT.CORE.LOC(R) _ RT.DICT.CORE.LOC(CURRENT.ROUTINE)
  2042	  RT.DICT.IN(R) _ YES
  2043	  INC DICT.OWNER.COUNT(RT.DICT.CORE.LOC(R))
  2044	 END
  2045	 ELSE DO
  2046	  IF CURRENT.ROUTINE#NO.ROUTINE AND &
  2047	        DEC DICT.OWNER.COUNT(RT.DICT.CORE.LOC(CURRENT.ROUTINE))<1 THEN DO
  2048	   REL.BLOCK(RT.DICT.CORE.LOC(CURRENT.ROUTINE)-DICT.HDR.SIZE,RT.DICT.NO.WORDS(CURRENT.ROUTINE)+DICT.HDR.SIZE)
  2049	   RT.DICT.IN(CURRENT.ROUTINE) _ NO
  2050	  END
  2051	  RT.DICT.CORE.LOC(R) _ GET.BLOCK(RT.DICT.NO.WORDS(R)+DICT.HDR.SIZE)+DICT.HDR.SIZE
  2052	  DICT.OWNER.COUNT(RT.DICT.CORE.LOC(R)) _ 1
  2053	  SETCP(DB.FNO,RT.DICT.FILE.LOC(R))
  2054	  RB(DB.FNO,RT.DICT.NO.WORDS(R),RT.DICT.CORE.LOC(R))
  2055	  RT.DICT.IN(R) _ YES
  2056	 END
  2057	END
  2058	
  2059	IF NOT RT.SYMT.IN(R) THEN DO
  2060	 IF CURRENT.ROUTINE#NO.ROUTINE THEN DO
  2061	  REL.BLOCK(RT.SYMT.CORE.LOC(CURRENT.ROUTINE),RT.SYMT.NO.WORDS(CURRENT.ROUTINE))
  2062	  RT.SYMT.IN(CURRENT.ROUTINE) _ NO
  2063	 END
  2064	 RT.SYMT.CORE.LOC(R) _ GET.BLOCK(RT.SYMT.NO.WORDS(R))
  2065	 SETCP(DB.FNO,RT.SYMT.FILE.LOC(R))
  2066	 RB(DB.FNO,RT.SYMT.NO.WORDS(R),RT.SYMT.CORE.LOC(R))
  2067	 RT.SYMT.IN(R) _ YES
  2068	END
  2069	CURRENT.ROUTINE _ R
  2070	CURRENT.DICT _ RT.DICT.CORE.LOC(R)
  2071	DB.DOT _ 1
  2072	DB.NLINES _ RT.DICT.SIZE(R)
  2073	CURRENT.SYMT _ RT.SYMT.CORE.LOC(R)
  2074	
  2075	ONALT
  2076	RETURN
  2077	END SET.CURRENT.ROUTINE
  2078	
  2079	%SET.DOT.TO.CURLINE
  2080	
  2081	LOCAL R()
  2082	
  2083	DEF IN.ROUTINE(R) AS RT.DICT.FILE.LOC(R)<=CURLINE<RT.DICT.FILE.LOC(R)+RT.DICT.NO.WORDS(R)
  2084	
  2085	IF NOT IN.ROUTINE(CURRENT.ROUTINE) THEN DO
  2086	 R _ FIRST.ROUTINE
  2087	 LOOP DO
  2088	  REPEAT NUM.OF.ROUTINES
  2089	  WHILE NOT IN.ROUTINE(R)
  2090	  NEXT.ROUTINE(R)
  2091	 END
  2092	 IF NOT IN.ROUTINE(R) THEN CERR('DEBUG INFORMATION FILE INVALID.')
  2093	 SET.CURRENT.ROUTINE(R)
  2094	END
  2095	DB.DOT _ (CURLINE-RT.DICT.FILE.LOC(CURRENT.ROUTINE))/DICT.ESIZE+1
  2096	RETURN
  2097	END SET.DOT.TO.CURLINE
  2098	
  2099	END RUNCTL

DBGRC
SYMBOL CROSS REFERENCE

AC	  1910#	  1910	  1915	  1916	  1918
ACBRKB	   423#	   425	  1916	  1918
ACTRCB	   422#	   424
ADRB	  1003#	  1008	  1034	  1061	  1071	  1076
ADRID	   595#	  1008	  1606
AEFERR	    53#
ALLWD	  1031#	  1094
ALPH	   296	   779	  1306#	  1429	  1431	  1709	  1740
ALT	   663#	   669	   704#
ALTENT	     2#	   242
ALTLOC	   118#	   669
ALTNAM	     1#	    64	    65	    66	    67	    68	    69	    70	    71	    72	    73	    74	    75	    76
	    77	    78	    79	    80	    81	    82	    83	    84	    85	    86	    87	    88	    89	    90
	    91	    92	    93	    94	    95	    96	    97	    98	    99	   100	   101	   102	   103	   104
	   105	   106	   107	   108	   109	   110	   111	   112	   113	   114	   115	   116	   117	   118
	   119	   126	   127	   128	   129	   130	   131	   132	   133	   135	   158	   160	   161	   174
	   189	   190	   191	   192	   193	   194	   195	   196	   197	   198	   199	   202	   203	   204
	   205	   206	   207	   208	   209	   210	   211	   212	   213	   214	   215	   216	   217	   218
	   219	   220	   221	   222	   231	   232	   233	   234	   236	   237	   238	   239	   258	   259
	   260	   261	   262	   263	   264	   265	   266	   270	   271	   272	   273	   274	   275	   276
	   277	   278	   638
AMBGCM	   606#	   888
ARGCNT	   142#	  1989
ARGERR	    59#
ASSIGN	   417#	  1782	  1784
AWAY	  1557	  1568#
BACKSP	   284	   782	   833#	   855	   949	  1089	  1093	  1429	  1490	  1710
BADINT	   411#	  1453
BDCMND	   605#	   708
BDCONS	   404#	  1738	  1745	  1746	  1749
BDCPLX	   405#	  1730	  1767	  1772
BDLRNG	   602#	   773	  1186	  1212	  1215	  1217	  1224
BDMTCH	   415#	  1711
BEGLPT	   444#	   695
BELOW	   790	   798#
BIN	   179#
BLK	   397#	   398	   399
BLOCK	    98	  2006	  2051	  2064
BOUNDS	   413#	  1464
BPC	   632#	   906
BPW	   631#	   632	   906
BRKBIT	   425#	  1538	  1552	  1565	  1578
BRKSTR	   426#	  1565	  1916
BUF	  1296#	  1299	  1300
BUFDUM	    76
BUFF	  1630#	  1636	  1640	  1644#	  1644	  1655	  1678
CA	   901	   901#	   906
CADR	   197#
CANCAL	    81
CANCEL	    75
CERR	   289	   708	   792#	   808	   888	   967	  1101	  1150	  1183	  1186	  1212	  1215	  1217	  1224
	  1326	  1516	  1519	  1570	  1999	  2001	  2025	  2026	  2092
CFECHO	   129
DBGRC
SYMBOL CROSS REFERENCE

CFN	    65#	   668	   695	   705	   798	   813	  1524
CFNCLS	   289	   705	   710	   799	   812#
CFNEOF	   281#	   710#	  1524
CHAR	  1385#	  1388	  1702#	  1737	  1743	  1744	  1750	  1752	  1756	  1832#	  1844	  1873#	  1873	  1877
CHARAC	    27#	  1514
CLIBUF	   102	   704	   789	   797
CLMAX	   540#	   780	   847
CLNB	  1001#	  1061	  1062	  1067	  1071
CLOBUF	   103	   704
CLOSE	    74	   813	  1524	  1656
CLOSEA	    80
CMD	   544#	   677	   778#	   781	   783
CMDCNT	   510#	   544	   644	  1509
CMDL	   644#	   645	   647	   648	   649	   650	   651	   652	   653	   654	   655	   657	   658	   659
	   660	   661	   678
CMDREC	   288	   781	   862#
CNFERR	    43#
CNT	   849#	   852	   853	   876	   906	   926	  1030#	  1042	  1049	  1056	  1082	  1123	  1173#	  1178
	  1181	  1183	  1193	  1237#	  1239	  1246	  1247	  1249	  1276#	  1278	  1279	  1280	  1286	  1502#
	  1543	  1544	  1545	  1546	  1554	  1560	  1565	  1750	  1752	  1754
CODE	  1644#	  1644	  1673
COMMAN	   686	   697	   730	   734	   741	   744	   751	   754	   777#
COMPAR	   873	   882	   886	   892#
CONERR	   263	  1926#
CONTOK	   432#	  1534	  1570	  1919	  1930	  1946	  1957
COREAD	   352#	  1543	  1558	  1563	  1580
CORERR	    62#	  1516
CP	    94
CPERR	   289	   786#	   963	  1325	  1334	  1335	  1344	  1348
CPLX	   168#	   169	   174	  1729	  1835
CPW	   156#	   157	   632	   847	   876	   926	  1633	  1636	  1640	  1800
CRFG	   198#
CSCAN	   686	   698	   713#
CSCANI	   291	   715	   936#
CURLIN	   272#	  2085	  2089	  2092	  2095
CURREN	   341#	  1223	  1263	  1264	  1278	  1412	  1532	  1543	  1558	  1563	  1580	  1608	  1609	  1969
	  1971	  2021	  2034	  2039	  2041	  2046	  2048	  2049	  2060	  2061	  2062	  2069	  2070	  2073
	  2085	  2095
CWD	   512#	   677	   697
CWDCNT	   481#	   512	   544	   677	   716
DBCNUM	   268#	   677	   678	   697	   716	   730	   734	   741	   744	   751	   754	  1509	  1538	  1552
	  1578
DBDOT	   268#	  1210	  1534	  1972	  2071	  2095
DBFDT	   266#	  2001
DBFIDT	  1979#	  1988	  1989	  1990	  1991	  1992	  1994
DBFILE	   313#
DBFNM	   265#	  1990	  1991
DBFNO	   344#	  1994	  1995	  1997	  2004	  2010	  2011	  2013	  2015	  2053	  2054	  2065	  2066
DBFOPE	  1978#	  1994	  2025#
DBFRWE	  1978#	  1995	  2026#
DBHDRD	   316#	  2001
DBHDRS	   311#	  1978	  1997
DBHDRV	   312#	  1999
DBGRC
SYMBOL CROSS REFERENCE

DBINTN	   268#	   698	  1571
DBNLIN	   268#	  1150	  1178	  1211	  1212	  1217	  1262	  1557	  1562	  2072
DBRTFI	   314#	  2004
DBRTNO	   315#	  2005
DBUF	  1801#	  1889	  1898	  1899
DBUFIN	  1869	  1871	  1889	  1894#
DBUFLE	  1799#	  1800
DBUFSZ	  1800#	  1801	  1898
DBVERS	   318#	  1999
DCNT	  1803#	  1877	  1886	  1889	  1899
DDGMAX	   248#	   626	  1056	  1123	  1279
DDTOVR	   133
DEBUGC	  1501	  1530	  1602#
DECFLD	   227#
DELETE	   100
DERR	   300	   726	   735	   739	   745	   749	   752	   755	   758	   762	   773	  1323#	  1528	  1621
	  1660	  1694	  1730	  1738	  1745	  1746	  1749	  1767	  1772
DEVNAM	   150#
DEXU	   283	   698	  1498#
DGMAX	   626#	   627	  1278
DGTB	   997#	  1050	  1118
DICTES	   350#	   351	   352	  2095
DICTHD	   353#	   354	  2048	  2051
DICTOW	   354#	  2043	  2046	  2052
DIMLIT	   414#	  1456
DIRECT	    22#	  1514	  1994
DISPLA	  1501	  1573	  1795#
DLRB	   999#	  1046	  1054	  1072	  1117
DOTB	   996#	  1049	  1054	  1055	  1119	  1123
DOUB	   167#	  1759	  1851
DPERR	   300	   771	   773	  1332#	  1402	  1462	  1708	  1717	  1821
DPOS	  1802#	  1871	  1885	  1886	  1887	  1889
DPTR	  1804#	  1877	  1899
DPUT	  1797	  1810	  1812	  1814	  1816	  1818	  1840	  1842	  1844	  1846	  1848	  1849	  1851	  1856
	  1873#
DPUTIN	  1797	  1807	  1865#
EIEXIT	  1501	  1584	  1586	  1588	  1590	  1592	  1594	  1596	  1628#
EL	   445#	   720	   722	   728	   965	  1008	  1014	  1135	  1141	  1177	  1180	  1514	  1618	  1621
ELCNT	   199#
ELID	   445#	   720	   722	   728	   941	   965	  1008	  1014	  1135	  1141	  1177	  1606
ELP	   445#	   720	   722	   728	   941	   965	  1008	  1014	  1135	  1141
ELW	   451#	   720	   722	   728	   965	  1008	  1014	  1135	  1141
ENDCH	  1080	  1089#
EOFERR	    55#
EOLITW	   253#	   851	  1737	  1898
ERASE	    92
EROUT	   724	   773#	   961#	   964	   967#
ERR	   777	   779	   780	   781	  1500#	  1514	  1515#
ERRA	   687#	   697	   708#	   730	   734	   741	   744	   751	   754
ERRNUM	   119#	   808	  1515	  1516	  1517	  1519
ERRORE	   281#	   665	   691	   799
EXCFN	   127
EXPFLD	   228#
DBGRC
SYMBOL CROSS REFERENCE

EXTARG	   145#	  1521	  1991
EXTDEF	   954#	   954	   964
EXTOUT	   126
EXTQ	   148#	  1515	  1521	  1992
EXU	    67	  1652	  1666	  1693	  1960
EXUF	    68
F	  1645#	  1654	  1655	  1656
FADR	   291	   722	   728	   972#
FBSERR	    52#	   612
FCR	   291	   696	   755	   758	   771	   773	   945#	   963
FFID	   291	   718	   954#
FIDID	   593#	   965
FIDP	   135#	  1515	  1517	  1521
FIDPTR	   938#	   942	   964	   965
FIDTBL	   939#	   942	  1645#	  1654	  1676	  1677	  1686#	  1689	  1690
FILE	  1645#	  1667	  1675
FILERR	   612#	   967	  1519
FILSIZ	   147#
FINT	   291	   720	  1133#
FIRSTR	   336#	  1615	  2006	  2008	  2086
FLDMAX	   174#
FLG	  1276#	  1278	  1281	  1282
FLOUT	   220	  1851
FLST	   291	   724	   732	   742	  1011#
FMDERR	    39#
FMIEOV	   232
FMODE	   194#
FMOEOV	   234
FN	   192#	   710
FNAME	   291	   728	  1139#
FNFERR	    49#	  1515	  1517
FNMAX	    33#	   198	   199
FNMIN	    32#	    34
FORM	   196#	  1727
FPMSG	   113
FPPRIN	   114
FREE	   158#	   667	   798	  1633
FREEFO	   187#
FREEPT	   438#	   667
FRIEOV	   231
FRL	   185#
FRNGL	  1005	  1008	  1014	  1020#
FROEOV	   233
FSYM	  1399	  1403	  1406#
FTYP	   193#
GET	   105
GETBLO	   398#	  2006	  2051	  2064
GETCOM	   286	   670	   683#	  1919	  1931	  1948
GETINT	  1444	  1451	  1472#
GETLIN	    89	   695
GETNAM	   306	  1141	  1402	  1424#	  1645	  1649	  1662#
GETPIN	   306	  1135	  1487#
GETSYM	   306	  1394#	  1446	  1452
DBGRC
SYMBOL CROSS REFERENCE

GETVAL	  1701	  1713	  1720#
GETVAR	   306	  1437#	  1707	  1710	  1809
GLBCMX	   155#	   157
GLBSZ	   157#	   158	   160	   446	  1630
GLCNT	   161#	  1633
HDR	  1978#	  1997	  1999	  2001	  2004	  2005
I	   897#	   899	   900	   901	   902	   903	   918#	   922	   923	   925	   926	   927	  1155#	  1155
	  1177	  1180	  1181	  1184	  1186	  1187	  1188	  1272#	  1272	  1278	  1296#	  1299	  1300	  1363#
	  1366	  1426#	  1430	  1431	  1444#	  1449	  1456	  1457	  1459	  1463	  1502#	  1541	  1543	  1545
	  1549	  1560	  1566	  1663#	  1667	  1668	  1669	  1670	  1673	  1674	  1742	  1744	  1747	  1812
	  1813	  1814	  1816
IDGMAX	   247#	   626	  1042	  1082
IFDERR	    42#	   612	   967
ILKEY	  1254#	  1254	  1263	  1264
ILPTR	  1702#	  1705	  1782	  1786
IMAGE	   160#	   667
IMGPTR	   439#	   667
INFN	  1500#	  1512	  1514	  1524
INITDB	   302	   666	  1976#
INITER	   663#	   665	   673#
INITFG	   433#
INITRE	   200#
INITSM	   390#	  1449
INLA	   687#	   691	   695#	   710
INLIST	   293	  1155#	  1540	  1579	  1607
INPUT	     9#	  1514
INROUT	  2083#	  2085	  2089	  2092
INT	   165#	  1366	  1759	  1848
INTFLD	   226#	  1848
INTID	   597#	   720	  1135
INWD	   848#	   851	   852	   878	   879	   902	   903	   923	   927
INWDSZ	   847#	   848	   851
INXLNU	   294	  1193	  1232#
IOCS	    69
IOREST	   274	  1571
IOWD	  1646#	  1678
ISARY	   410#	  1452	  1466
IUSERR	    50#
J	   897#	   901	   902	   903	  1663#	  1669	  1671
JOB	  1663#	  1667	  1669
JOBVER	   638#	  1526
KABT	   455#	   645	  1582
KBRK	   456#	   649	   724	  1538
KCAN	   457#	   654	   726
KCHNG	   458#	   653	   762	  1596
KCLS	   459#	   654	   726
KCOMP	   460#	   655	   758	  1588
KCONT	   461#	   645	  1570
KCRE	   462#	   648	   762	  1596
KDEB	   463#	   657	   728	  1530
KDISP	   464#	   651	   766	  1573
KDO	   465#	   648	   718	  1511
KEY	  1276#	  1278	  1280	  1284	  1286
DBGRC
SYMBOL CROSS REFERENCE

KGO	   466#	   647	   722	  1528
KHUSH	   467#	   645
KINIT	   468#	   655	   758	  1592
KLBRK	   489#	   650	   732	  1552
KLDEB	   490#	   645	  1532
KLIST	   469#	   730
KLOPT	   488#	   489	   490	   491	   492	   493	   730
KLTRC	   491#	   650	   732	  1552
KLVAL	   492#	   734
KLVBK	   503#	   660
KLVER	   493#	   495	   645	  1526
KLVOPT	   502#	   503	   504	   734
KLVTC	   504#	   505	   660
KMODE	   470#	   658	   739
KNBRK	   483#	   650	   742	  1577	  1578
KNEXT	   471#	   659	   720
KNHSH	   484#	   645
KNO	   472#	   741
KNOPT	   482#	   483	   484	   485	   486	   741
KNTRC	   485#	   650	   742	  1577
KNVAL	   486#	   488	   744
KNVBK	   500#	   660
KNVOPT	   499#	   500	   501	   744
KNVTC	   501#	   502	   660
KPCMP	   506#	  1590
KPINI	   507#	   655	  1594
KPOPT	   505#	   506	   507	   508	   754
KPROD	   473#	   754
KPRUN	   508#	   510	   655	  1586
KQUIT	   474#	   645	  1582
KRUN	   475#	   655	   758	  1584
KSET	   476#	   652	   766	  1575
KSTEP	   477#	   659	   720
KTOUT	   478#	   648	   749
KTRC	   479#	   649	   724	  1538
KVAL	   480#	   481	   482	   751
KVBRK	   496#	   661
KVOPT	   495#	   496	   497	   751
KVTRC	   497#	   499	   661
LAB	   840	   859	   862	   883	   914	   922	   927	  1017	  1017#	  1092#	  1092	  1254	  1264	  1267
LASTCH	   284#	   779	   828	   854	   855	   857	  1045	  1047	  1053	  1060	  1065	  1070	  1072	  1075
	  1082	  1086	  1431	  1432	  1447	  1458	  1462	  1480	  1490	  1492	  1494	  1708	  1709	  1715
	  1717	  1730	  1738	  1740	  1743	  1746	  1749	  1750	  1752	  1756	  1757	  1761	  1763	  1767
	  1772	  1819	  1821
LASTRO	   345#	  1969	  1971	  2020
LESSTR	   251#	   879	   903
LFGS	  1006#	  1008	  1013	  1046	  1049	  1050	  1054	  1055	  1061	  1062	  1066	  1067	  1071	  1072
	  1076	  1077	  1092	  1117	  1118	  1119	  1122	  1123
LGC	   170#	  1737	  1840
LGCPK	   210	  1747
LGCUNP	   211	  1840
LINEKE	   351#	  1223	  1263	  1264	  1278	  1608
LINEST	   339#	  1609
DBGRC
SYMBOL CROSS REFERENCE

LIST	   777#	   777	   781
LKEY	  1202#	  1204	  1206	  1223	  1224
LLEN	   154#	   155
LLMAX	   569#
LLOC	  1702#	  1707	  1712	  1713
LMAX	   840#	   840	   853
LNGCHK	   289	   710	   807#
LNGERR	    56#	   808
LNLONG	   601#	   808
LNUM	   268#	  1210	  1211	  1212	  1216	  1217	  1220	  1223	  1225	  1249	  1261	  1262	  1263	  1264
	  1543	  1545	  1546	  1554	  1557	  1558	  1560	  1562	  1563	  1566
LOC	  1444#	  1446	  1460	  1464	  1467	  1720#	  1720	  1728	  1771	  1805#	  1809	  1818	  1826#	  1826
	  1834
LOCWPF	   136#	   139	   140	   142	   143	   144	   145	   146	   147
LPTR	   443#	   695	   828	   835	   854	   964	  1039	  1086	  1091	  1431	  1480	  1492	  1638	  1705
	  1714	  1740	  1743	  1752	  1756	  1761
LSCANI	   212
LSTB	  1002#	  1013	  1034	  1071	  1092
LSTCNT	   450#	  1178	  1181	  1188	  1549	  1580
LSTID	   594#	  1014
LSTLNG	   607#	  1101	  1183
LTBL	   448#	  1178	  1184	  1186	  1187	  1188	  1246	  1247	  1249	  1543	  1545	  1549
LTTYLE	   431#	   690	  1886	  1889	  1899
LVAL	  1030#	  1042	  1047	  1049	  1122	  1123
LWALPH	   622#	   855	  1308
LWD	   562#	   730
LWDCNT	   494#	   562	   730
LWUPDI	   250#	   622	   623
MAINNA	   298#	   722	   728	  2018
MAINRO	   346#	  2018	  2022
MAXARG	   137#	   140
MAXWPF	   140#
MINARG	   138#	   139	  1989
MSG	   111	   677	   678	   705	   797
MSGADR	  1323#	  1323	  1325	  1326	  1340#	  1340	  1346	  1352
MSGPRO	   786	   789	  1331	  1332	  1334	  1335
MTCHFG	  1173#	  1187	  1204	  1208	  1215	  1220
N	   792#	   792	   797	  1292#	  1292	  1298	  1299	  1331#	  1331	  1630#	  1636	  1637	  1638	  1640
	  1644#	  1644	  1655	  1678
NAMARG	   144#	  1677	  1690	  1990
NAME	  1140#	  1141	  1685#	  1685	  1688
NAMID	   596#	   722	   728	  1141
NCNERR	   264	  1941#
NCOM	   687#	   690#	   706
NDSTR	   252#	   512	   562	   571	   578	   584	   922	  1031
NEW	    16#
NEWROU	  1604#	  1609	  1611	  1615	  1618	  1619	  1621	  1623
NEXTRO	   337#	  1611	  1619	  2090
NG	  1037#	  1046	  1054	  1061	  1066	  1071	  1076
NLMAX	   576#
NO	   635#	  1017	  1136	  1142	  1208	  1215	  1220	  1278	  1418	  1429	  1490	  1571	  1742	  1946
	  1957	  2012	  2014	  2049	  2062
NOCONT	   403#	  1535	  1570
DBGRC
SYMBOL CROSS REFERENCE

NOCORE	   603#	  1516	  2006	  2048	  2051	  2061	  2064
NOPROG	   608#	  1150
NOROUT	   342#	  2020	  2021	  2039	  2046	  2060
NOTARY	   409#	  1448
NOTIMP	   604#	   726	   735	   739	   745	   749	   752	  1528
NOTYME	   609#	   755	   758	   762
NOXRNG	   418#	  1545
NSPCH	   255#	   256
NUM	   624#	  1045
NUMB	   998#	  1054	  1072	  1123
NUMOFR	   338#	  1617	  2005	  2006	  2009	  2088
NUMPHI	   237#
NUMPLO	   238#
NUMPSG	   239#
NUMSCA	   209	  1761	  1762
NUMSCI	   208	  1759
NUMTMA	   169#
NUMUNI	   206	  1848
NUMUNP	   207	  1849
NWD	   571#	   741
NWDCNT	   487#	   571	   741
NX1	  1202#	  1206	  1208#
NX2	  1207	  1214#
NXADR	  1172	  1184	  1186	  1195#
NXCHAR	   285#	   828	   854	  1086	  1431	  1480	  1492	  1740	  1743	  1752	  1756	  1761
NXLNUM	   294	  1241#	  1580	  1608
NXNSP	   284	   782	   824#	   949	  1040	  1093	  1429	  1432	  1462	  1480	  1494	  1708	  1730	  1747
	  1757	  1763	  1767	  1772
NXSMUL	   391#	  1460	  1464
NXT	   879	   882#	   884
OFFALT	   115	   704	   710	   799	  1511	  1582	  2036
OFINT	   276	   689
OLD	    17#
ONALT	   116	  2075
ONALTC	   117	   710	   788	   796
OPEN	    70	  1514	  1654	  1994
OPENP	    77
ORD	  1604#	  1610	  1611
ORDINA	   340#	  1610
OUT	  1040	  1046	  1049	  1054	  1061	  1066	  1071	  1076	  1091#	  1093	  1094	  1120#	  1120	  1122
OUTMSG	    12#
OUTNUM	   287	  1292#	  1526
OUTPUT	    11#	  1654
OUTSET	   301	  1325	  1334	  1353	  1779#
OVFLER	   236
P	  1630#	  1636	  1637	  1663#	  1667	  1671	  1674	  1675	  1676	  1686#	  1688	  1689
PACK	    28#
PAWS	   262	  1923#
PB	  1630#	  1636	  1637	  1638	  1639
PCMDL	   289	   675#	   771	   773	   963	  1402	  1462	  1708	  1717	  1821
PLMAX	   589#
PLNCHK	    82
PLNW	    83
DBGRC
SYMBOL CROSS REFERENCE

POUT	   221	  1851
PPNARG	   143#
PRGCHK	   293	  1149#	  1176
PRINT	   109	   677	   798	  1325	  1352	  1517	  1532	  1534	  1535	  1545	  1565	  1782	  1784	  1889
	  1916	  1968
PRINTC	   110
PRMPT	   284	   690	   817#
PRTERR	    51#
PRVARG	   146#
PTR	   849#	   852	   857	   874#	   877	   878	   879	   884	   885	   901	   918#	   920	   922	   927
	   929	  1030#	  1041	  1089	  1173#	  1181	  1205	  1206	  1210	  1211	  1212	  1214	  1216	  1218
	  1225	  1237#	  1239	  1246	  1247	  1249	  1313#	  1313	  1316
PUT	   106	   678	   704	   798	   819	  1282	  1285	  1286	  1326	  1335	  1352	  1372	  1376	  1381
	  1388	  1517	  1526	  1532	  1533	  1536	  1546	  1547	  1560	  1566	  1568	  1781	  1784	  1786
	  1822	  1886	  1887	  1969	  1972
PUTC	   108
PUTDBU	  1797	  1818	  1878	  1881#
PUTQSY	   301	  1352	  1372#
PUTSYM	   301	  1376	  1381#	  1532	  1810	  1969
PUTVAL	  1798	  1814	  1816	  1818	  1826#
PUTX	   107
PWD	   584#	   754
PWDCNT	   509#	   584
PWR10	   627#	  1123	  1280	  1286
QUIT	   260	  1582	  1953#
R	    88	  2010	  2011	  2013	  2015	  2029#	  2029	  2034	  2038	  2039	  2041	  2042	  2043	  2051
	  2052	  2053	  2054	  2055	  2059	  2064	  2065	  2066	  2067	  2069	  2070	  2072	  2073	  2081#
	  2086	  2089	  2090	  2092	  2093
RAD	  1292#	  1292	  1299
RB	    97	  1997	  2054	  2066
READ	   204
REAL	   166#	   174	  1731	  1759	  1835	  1851
RECSZ	   195#
RELBLO	   399#	  2048	  2061
RELEAS	    99	  2048	  2061
RENAME	   101
RESINT	   277	  1571
RLOC	  1702#	  1710	  1712
RNGMX	  1171#	  1183
RSALT	   132
RSBRK	   131
RT	  1978#	  2008	  2010	  2011	  2012	  2013	  2014	  2016	  2017	  2018
RTCESI	   343#	  1609	  1611	  1619	  2006	  2072	  2090
RTDICT	   322#	   323#	   324#	   325#	   326	   326#	   327#	  2013	  2014	  2038	  2039	  2041	  2042	  2043
	  2046	  2048	  2049	  2051	  2052	  2053	  2054	  2055	  2070	  2072	  2083	  2095
RTFESI	   319#	  2005
RTHIGH	   329#	  1611	  2017
RTNAME	   321#	  1532	  1618	  1621	  2010	  2018
RTORDI	   328#	   339	  1611	  2016
RTSYMT	   330#	   331#	   332#	   333#	   334#	  2011	  2012	  2059	  2061	  2062	  2064	  2065	  2066	  2067
	  2073
RUN	  1630	  1641	  1685#
RUNBLK	  1686#	  1687	  1690	  1691	  1692
DBGRC
SYMBOL CROSS REFERENCE

RUNCTL	   258	   640#
RUNERR	  1686#	  1689	  1694#
RWERR	   300	   690	  1331#
RWINIT	   203
S	  1628#	  1628	  1636
SADJ	   368#	  1414
SARYB	   370#	  1448	  1452	  1466	  1467	  1811
SAVE	   874#	   885	   887	  1173#	  1184	  1220	  1224
SCAN	   214
SCANIN	   213
SCOM	   362#
SCPLX	   377#	  1364
SDLOC	   387#	  1467
SDOUB	   376#	  1364
SDUM	   367#	  1467
SEL	   447#	  1089	  1102	  1178	  1184	  1186	  1187	  1188	  1246	  1247	  1249	  1543	  1545	  1549
SELLIM	   446#	   447	  1101
SELP	   449#	   941	  1041	  1101	  1102
SELW	  1029	  1082	  1089	  1097#	  1119	  1123
SEQ	   183#
SEQUEN	    21#	  1654
SET	  1501	  1575	  1699#
SETCFN	    66
SETCP	    93	  2004	  2053	  2065
SETCUR	   302	  1623	  2022	  2029#	  2093
SETDOT	   302	  1967	  2079#
SETFG	   434#	  1325	  1334	  1353	  1508	  1704
SETFID	    71	   964	  1676	  1689
SETFIP	    78
SETMOD	    79
SETPRM	    86	   690
SETRWE	   112	  1524	  1995
SETRWP	   222	   690
SETTAB	    84
SETTER	    85
SFCLSA	   275	  1582	  1959
SFOED	   271#	   755	   758	   762	  1632
SFOIN	   270#	   670
SFORW	   202
SFRUN	   273	  1634
SFUN	   363#
SGN	  1477#	  1479	  1480	  1481
SGNB	  1000#	  1054	  1066	  1067	  1122	  1123
SGNBIT	   630#
SINT	   374#	  1364	  1453	  1814	  1816
SIZE	    95
SLEN	   382#	  1416
SLGC	   378#	  1364
SLIB	   369#
SLOC	   384#	   385	   386	   387	  1454	  1467
SLONG	   371#
SMULP	   393#	  1449	  1460	  1464
SNAM	   388#	  1348	  1415	  1810
DBGRC
SYMBOL CROSS REFERENCE

SOFF	   393	  1313#	  1464
SPCH	   256#	   828	  1432	  1494
SPRG	   366#
SREAL	   375#	  1364
SSCAP	   385#	  1750	  1844
SSIZ	   392#	  1464
SSLOC	   386#	  1467
SSNUM	   389#	  1459	  1463	  1813
SSTR	   379#	  1364	  1467
SSUBD	   365#
SSUBR	   364#
START	  1685#	  1685	  1692
STM	   259	  1910#
STMREP	   302	  1917	  1929	  1945	  1963#
STR	   171#	   172	  1366	  1749	  1842
STRPIN	   215
STRPK	   218
STRUNP	   219
STRUPI	   216
STS	    64#
STYP	   373#	  1453	  1467	  1711	  1713	  1818
STYPA	  1364#	  1366
STYPE	  1361#	  1361	  1366	  1720#	  1720	  1729	  1826#	  1826	  1835
SUBCNT	   412#	  1459	  1463
SUBPTR	  1444#	  1452	  1453	  1454
SUBS	   430#	  1457	  1814	  1816
SUBSMA	   429#	   430	  1456
SVAR	   361#	  1414
SVBT	   383#
SVLPTR	  1702#	  1705	  1714	  1782	  1785	  1786
SVNUM	  1029	  1062	  1067	  1077	  1089	  1107#
SXPT	   420#	  1387	  1428
SXPTR	  1385#	  1387	  1388	  1426#	  1428	  1431
SYM	   178#
SYMERR	   300	  1346#	  1448	  1452	  1453	  1456	  1459	  1463	  1464	  1466	  1711
SYMNAM	  1340#	  1340	  1348	  1352	  1372#	  1372	  1376	  1381#	  1381	  1387	  1400#	  1402	  1403	  1415
	  1424#	  1424	  1428
SYMNER	   300	  1340#	  1403
SYMPTR	  1346#	  1346	  1348	  1400#	  1404	  1412	  1414	  1415	  1416	  1444#	  1446	  1448	  1449	  1456
	  1459	  1463	  1464	  1466	  1467	  1702#	  1707	  1711	  1713	  1750	  1805#	  1809	  1810	  1811
	  1813	  1818	  1844
T	  1978#	  2015	  2016	  2017
TABCH	   254#	   255
TABOFF	    87
TBLK	  1645#	  1651	  1677	  1678
TEL	    34#	   198	   199	   668	   705	   710	   798	   813	  1298	  1300	  1512
TELCHK	    72	  1512
TELERR	    57#
TEMP	   874#	   899	   901	   906	   947#	   949	  1030#	  1039	  1091	  1202#	  1214	  1216	  1276#	  1280
	  1281	  1282	  1286	  1315#	  1316	  1317	  1702#	  1737	  1740	  1750	  1752	  1754	  1832#	  1842
	  1844	  1851
TERM	  1174#	  1185	  1189	  1225
TMFERR	    38#
DBGRC
SYMBOL CROSS REFERENCE

TMPERR	  1645#	  1654	  1660#	  1676
TMPEXT	  1664#	  1676
TOBOTH	   123#
TONEIT	   124#
TOTERM	   121#
TOTOUT	   122#
TRCBIT	   424#	  1538	  1552	  1578
TRCSTR	   427#	  1565	  1916
TSTRPI	   217
TTDEST	   128
TTECHO	   130
TTYLEN	   104	   690
TYPB	  1034#	  1062	  1067	  1077
UNCORE	   278	  1947	  1958
UNDEFS	   408#	  1403
UPALPH	   621#	   854	  1308
UPDATE	    10#	  1994
USRNAM	   149#
VADR	   191#	  1728	  1750	  1768	  1771	  1834	  1842	  1857
VAL	  1134#	  1135	  1444#	  1454	  1457	  1460	  1464	  1481	  1487#	  1487	  1489	  1492
VCNT	   190#	  1728	  1731	  1766	  1834	  1835	  1855
VLMAX	   582#
VPTR	  1702#	  1710	  1711
VRL	   184#
VTYP	   189#	  1729	  1731	  1735	  1835	  1838
VTYPA	   380	  1361#	  1729	  1835
VTYPMA	   172#	   173
VTYPRN	   173#	  1364	  1735	  1838
VWD	   578#	   734	   744	   751
VWDCNT	   498#	   578
W	    90	   874#	   876	   900	  1298	  1300
WB	    96	  1655
WD	   862#	   862	   878	   879	   901	   914#	   914	   922	   927	  1173#	  1180	  1205	  1206	  1210
	  1211	  1212	  1214	  1216	  1225
WDREC	   288	   914#	  1094
WDSTOR	   288	   780	   840#	  1093
WFID	    73	  1517
WKEY	   287	  1272#	  1534	  1546	  1566	  1972
WKEYRN	  1504#	  1546	  1566
WORD	    26#	  1654	  1994
WPF	   139#	   939	   942	   964	  1645	  1686	  1979	  1988
WRITE	   205
WRITET	  1630	  1633	  1640	  1644#
WTMPEX	  1647#	  1652	  1658#
WX	    91
X	  1097#	  1097	  1102	  1306#	  1306	  1308	  1342	  1344	  1348	  1350#	  1502#	  1538	  1543	  1552
	  1558	  1563	  1565	  1578	  1580	  1604#	  1608	  1611
XIT	   261	  1937#
XLKLN	   295	  1206	  1254#
XLWUP	   623#	   855
YES	   634#	  1008	  1014	  1135	  1141	  1204	  1281	  1415	  1433	  1481	  1494	  1515	  1521	  1599
	  1744	  1919	  1930	  2042	  2055	  2067    i<?eI