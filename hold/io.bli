MODULE IO(RESERVE(4))=

BEGIN


%  BASIC MONITOR LEVEL IO CALLS
%

MACHOP
  CALLI=#047,
  TTCALL=#051,
  NOP=#300,
  XCT=#256;

BIND
  ILLOP=0,
  BADCUR=3,
  BADCNT=4,
  BLIT=#251,
  OPENUUO=#050,
  INUUO=#056,
  OUTUUO=#057,
  INBF=#064,
  OUTBF=#065,
  GETSTS=#062,
  STATZ=#063,
  CLOSEUUO=#070,
  RELEAS=#071,
  LOOKUPUUO=#076,
  ENTERUUO=#077,
  USETI=#074,
  USETO=#075;

%       SOME USEFUL MACROS:
%
MACRO
  SKIP(OP)=(VREG_1; OP; VREG_0; .VREG)$,
  MOVE(C,S,D)=(REGISTER Q,R; Q<18,18>_S; Q<0,18>_D; R_C;
               VREG_BLIT^27+Q^23+R^18+D-1; XCT(0,VREG); .VREG)$,
  COPYBUF=MOVE(.F[BSIZE],.F[IPTR]+1,.F[OPTR]+1)$,
  ERRCODE=(IF SKIP(XCT(0,F[STATZOP])) THEN 1 ELSE 2)$,
  MIN(A,B)=(IF A LSS B THEN A ELSE B)$,
  BETWEEN(C,A,B)=(C GEQ A AND C LEQ B)$,
  INFAILS=SKIP(XCT(0,F[INOP]))$,
  OUTFAILS=SKIP(XCT(0,F[OUTOP]))$,
  INC(A)=(A_.A+1)$,
  DEC(A)=(A_.A-1)$,
  INPUT=0$,
  OUTPUT=1$,
  UPDATE=2$,
  FDX=3$,
  NORG=2$,
  NTYPE=4$,
  NMODE=2$;

%       STRUCTURE DEFINITIONS FOR VARIOUS THINGS:
%
!  LONG BYTE VECTOR
STRUCTURE LBYTEVEC[I,J]=[I*(J-1)/36+1] (.LBYTEVEC+.I/(36/I))<36-(.I MOD (36/I)+1)*I,I>;

!  COMPRESSED AND MAPPED TABLE WITH 2-BIT VECTOR INDEX
STRUCTURE COMTAB[I]=(.COMTAB+1+.(.COMTAB<34-2*.I,2>))<0,36>;


!   FIELD NAME-VALUES FOR THE FILECB STRUCTURE

BIND
   NB     =0,
   MODE   =1,
   ORG    =2,
   TYPE   =3,
   P      =4,
   CHNL   =5,
   BSIZE  =6,
   DIRTY  =7,
   WLB    =8,
   ITEMPW =9,
   ISIZE  =10,
   IBUFH  =11,
   ICBUF  =12,
   IPTR   =13,
   ICOUNT =14,
   OBUFH  =15,
   OCBUF  =16,
   OPTR   =17,
   OCOUNT =18,
   INOP   =19,
   OUTOP  =20,
   STATZOP=21,
   COML   =22,
   ICP    =23,
   OCP    =24,
   MAXCP  =25,
   RR     =26,
   RBR    =27,
   WR     =28,
   WBR    =29,
   SCPR   =30,
   EXCEPT =31,
   USETIOP=32,
   USETOOP=33,
   BUFL   =34,
   IBUFL  =35,
   OBUFL  =36,
   IBUFR  =37,
   OBUFR  =38,
   FCBS   =20;



!   FILE CONTROL BLOCK TABLE FOR EACH FILE
STRUCTURE FILECB[FIELD] = CASE .FIELD OF SET
%NB     %   (@.FILECB)<33,3>;
%MODE   %   (@.FILECB)<30,3>;
%ORG    %   (@.FILECB)<27,3>;
%TYPE   %   (@.FILECB)<24,3>;
%P      %   (@.FILECB)<24,9>;
%CHNL   %   (@.FILECB)<20,4>;
%BSIZE  %   (@.FILECB)<12,8>;
%DIRTY  %   (@.FILECB)<10,1>;
%WLB    %   (@.FILECB)<9,1>;
%ITEMPW %   (@.FILECB)<6,3>;
%ISIZE  %   (@.FILECB)<0,6>;
%IBUFH  %   (@.FILECB+1)<0,36>;
%ICBUF  %   (@.FILECB+1)<0,18>;
%IPTR   %   (@.FILECB+2)<0,36>;
%ICOUNT %   (@.FILECB+3)<0,36>;
%OBUFH  %   (@.FILECB+4)<0,36>;
%OCBUF  %   (@.FILECB+4)<0,18>;
%OPTR   %   (@.FILECB+5)<0,36>;
%OCOUNT %   (@.FILECB+6)<0,36>;
%INOP   %   (@.FILECB+7)<0,36>;
%OUTOP  %   (@.FILECB+8)<0,36>;
%STATZOP%   (@.FILECB+9)<0,36>;
%COML   %   (@.FILECB+10)<0,36>;
%ICP    %   (@.FILECB+12)<0,18>;
%OCP    %   (@.FILECB+17)<0,18>;
%MAXCP  %   (@.FILECB+13)<0,36>;
%RR     %   (@.FILECB+14)<0,18>;
%RBR    %   (@.FILECB+14)<18,18>;
%WR     %   (@.FILECB+15)<0,18>;
%WBR    %   (@.FILECB+15)<18,18>;
%SCPR   %   (@.FILECB+16)<0,18>;
%EXCEPT %   (@.FILECB+16)<18,18>;
%USETIOP%   (@.FILECB+12)<0,36>;
%USETOOP%   (@.FILECB+17)<0,36>;
%BUFL   %   (@.FILECB+18)<0,36>;
%IBUFL  %   (@.FILECB+18)<18,18>;
%OBUFL  %   (@.FILECB+18)<0,18>;
%IBUFR  %   (@.FILECB+19)<18,18>;
%OBUFR  %   (@.FILECB+19)<0,18>
            TES;


!       NEEDED THINGS FOR BUFFER RINGS:
BIND
   FLINK=0,
   USEBIT=1;

STRUCTURE BUF[FIELD]=CASE .FIELD OF SET
%FLINK%   (@.BUF)<0,18>;
%USEBIT%  (@.BUF)<35,1>
   TES;

!       THINGS DEFINING PARTS OF FID TABLE:
BIND
   DEV=0,
   RBSIZ=1;

STRUCTURE FID[FIELD]=CASE .FIELD OF SET
%DEVICE%  (@.FID-1)<0,36>;
%RBSIZ%   (@.FID+5)<0,36>
   TES;



!       FOLLOWING MACROS CONSTRUCT INSTRUCTIONS AND EXECUTE THEM

MACRO
  MAKEOP(OP,REG,ADDR)=(OP<0,0>^27+REG^23+ADDR)$,
  EXETEST(X)=(REGISTER Q; Q_X; SKIP(XCT(0,Q)))$,
  EXECUTE(X)=(VREG_X; XCT(0,VREG); .VREG)$,
  IND=0,0,0,1$;


%       REGISTER F ALWAYS DENOTES THE FILE CONTROL BLOCK FOR THE CURRENT
        IO OPERATION.
%
REGISTER FILECB F=4;

GLOBAL TTYF;            ! POINTER TO FILECB FOR TTY(ALWAYS OPEN AFTER INIT)

!
!       DYNAMIC MEMORY ALLOCATION ROUTINES
!
!  THIS MODULE IMPLEMENTS THE BUDDY SYSTEM OF DYNAMIC MEMORY
!  MANAGEMENT WITH CALLS OF FREEM AND GETM.  THE INITIAL SIZE OF MEMORY
!  IS REST OF PAGE AT JOBFF OR 1K IF NOT AT LEAST 2 WORDS.  WHEN SPACE IS
!  EXHAUSTED, THE PACKAGE WILL ATTEMPT TO DOUBLE ITS SIZE BY EXPANDING
!  CORE.  IF NOT POSSIBLE, THEN AN ABORT WILL OCCUR.  MEMORY WILL NOT
!  BE RELEASED UNTIL ANOTHER INITIALIZATION OCCURS, AT WHICH TIME
!   ALL EXTANT BLOCKS ARE RECLAIMED, REGARDELESS.
!

EXTERNAL JOBFF;

BIND
   MEMSIZE=1^17,
   LOG2MEMSIZE=35-FIRSTONE(MEMSIZE);

STRUCTURE ITEM[I,J,P,S]=
   CASE .I OF SET
%BASE%     (.ITEM)<.P,.S>;
           (@.ITEM+.J)<.P,.S>;
           (@@.ITEM+.J)<.P,.S>;
           (@(@.ITEM+1)+.J)<.P,.S>
   TES;

STRUCTURE VECTOR2[I]=[2*I](.VECTOR2+2*.I)<0,36>;

MACRO
   BASE=0,0,0,36$,
   RLINK=1,0,0,18$,
   ITEMSIZE=1,0,18,18$,
   LLINK=1,1,0,18$,
   NXTRLINK=2,0,0,18$,
   NXTLLINK=2,1,0,18$,
   PRVRLINK=3,0,0,18$,
   PRVLLINK=3,1,0,18$;

OWN VECTOR2 SPACE[LOG2MEMSIZE+1],CSIZE,MEM;

BIND SIZE=PLIT(1^0,1^1,1^2,1^3,1^4,1^5,1^6,1^7,1^8,1^9,1^10,
               1^11,1^12,1^13,1^14,1^15,1^16,1^17);

MACRO
   PARTNER(B1,B2,S)=((((B1)-.MEM) XOR ((B2)-.MEM)) EQL .SIZE[S])$,
   REPEAT=WHILE 1 DO$,
   BASEADDR(B,S)=.MEM+(((B)-.MEM) AND NOT .SIZE[S])$,
   ERRMSG(S)=(TTCALL(3,PLIT ASCIZ S); CALLI(0,#12))$;


ROUTINE EMPTY(L)=
BEGIN           !PREDICATE INDICATING EMPTY LIST
   MAP ITEM L;
   .L[BASE] EQL .L[RLINK]
END;


ROUTINE DELINK(A)=
BEGIN           !REMOVES ITEM A FROM LIST TO WHICH IT IS APPENDED.
   MAP ITEM A;
   A[PRVRLINK]_.A[RLINK];
   A[NXTLLINK]_.A[LLINK];
   A[RLINK]_A[LLINK]_.A[BASE]
END;


ROUTINE LINK(A,TOO)=
BEGIN           !INSERTS ITEM A INTO LIST AFTER ITEM TOO
   MAP ITEM A:TOO;
   A[LLINK]_.TOO[BASE];
   A[RLINK]_.TOO[RLINK];
   TOO[NXTLLINK]_TOO[RLINK]_.A[BASE]
END;


ROUTINE COLLAPSE(A,N)=

%   CALLED BY GETM AND FREEM TO ATTEMPT TO COMPACTIFY STORAGE IF
    ADJACENT ITEMS ARE FREE.
%
BEGIN
   MAP ITEM A; REGISTER ITEM L;
   LABEL FOO;
   REPEAT
FOO:  BEGIN
         L[BASE]_SPACE[.N]<0,0>;
         WHILE .L[RLINK] NEQ SPACE[.N]<0,0> DO
            IF PARTNER(.L[RLINK],.A[BASE],.N)
               THEN BEGIN
                  A[BASE]_BASEADDR(DELINK(.L[RLINK]),.N);
                  N_.N+1; LEAVE FOO
                  END
               ELSE L[BASE]_.L[RLINK];
         RETURN (A[ITEMSIZE]_.N; LINK(.A[BASE],.L[BASE]))
      END
END;


ROUTINE EXPANDM(S)=
BEGIN
   REGISTER X;
   BIND NCSIZE=.CSIZE+.S;
   X_1^NCSIZE+.MEM;
   IF (VREG_1; CALLI(X,#11); VREG_0; .VREG)
      THEN BEGIN
         MAP ITEM X;
         IF .CSIZE EQL 0
            THEN COLLAPSE(.MEM,.S)
         ELSE IF .S EQL 0
            THEN COLLAPSE(.MEM,.CSIZE)
         ELSE BEGIN
            DECR K FROM .S-1 TO 1 DO BEGIN
               X[BASE]_.MEM+.SIZE[X[ITEMSIZE]_.CSIZE+.K];
               LINK(.X[BASE],.SPACE[.CSIZE+.K])
               END;
            COLLAPSE(.MEM+.SIZE[.CSIZE],.CSIZE)
            END;
         JOBFF_.JOBFF+1^NCSIZE-(IF .CSIZE NEQ 0 THEN 1^(.CSIZE) ELSE 0);
         CSIZE_NCSIZE
         END
      ELSE ERRMSG('CANNOT EXPAND CORE FURTHER')
END;


GLOBAL ROUTINE INITM=
BEGIN
   DECR I FROM LOG2MEMSIZE-1 TO 1 DO
      SPACE[.I]_(SPACE[.I]+1)<0,36>_SPACE[.I]<0,0>;
   IF .MEM EQL 0 THEN MEM_.JOBFF;
   CSIZE_0;
   IF .MEM MOD 1024 EQL 0 OR .MEM MOD 1024 EQL 1023
      THEN EXPANDM(9)
      ELSE BEGIN
         CSIZE_35-FIRSTONE((.MEM/1024+1)*1024-.MEM);
         EXPANDM(0);
         JOBFF_.MEM+1^(.CSIZE)
         END
END;


ROUTINE GET(N)=
BEGIN
%       GETS A BLOCK OF MEMORY OF SIZE 2**N
%
   REGISTER ITEM R;
   IF .N GTR .CSIZE THEN EXPANDM(.N-.CSIZE+EMPTY(SPACE[.CSIZE]<0,0>));
   IF NOT EMPTY(SPACE[.N]<0,0>)
      THEN R[BASE]_DELINK(.SPACE[.N])
      ELSE BEGIN
         R[BASE]_GET(.N+1);
         COLLAPSE(.R[BASE]+.SIZE[.N],.N)
         END;
   R[ITEMSIZE]_.N;
   .R[BASE]
END;


GLOBAL ROUTINE GETM(W)=

%   RETURNS A POINTER TO A BLOCK OF MEMORY OF SIZE 2**CEILING(LOG2(W))
%
BEGIN
   BIND K=35-FIRSTONE(.W);
   BIND N=IF 1^K EQL .W THEN K ELSE K+1;

   IF N LEQ 0 OR N GTR LOG2MEMSIZE 
      THEN ERRMSG('INVALID MEMORY REQUEST');
   GET(N)
END;


GLOBAL ROUTINE FREEM(A)=
BEGIN           !CALLED TO FREE ITEM POINTED TO BY A
   MAP ITEM A;
   COLLAPSE(.A[BASE],.A[ITEMSIZE])
END;

%       "INIT" TAKES FOUR PARAMETERS: THE CHANNEL NUMBER, THE DEVICE
        STATUS (AS SPECIFIED IN THE MONITOR REFERENCE MANUAL, THE
        LOGICAL DEVICE NAME, AND BUFFER POINTERS.  ROUTINE RETURNS
        TRUE IF THE OPEN UUO SUCCEEDS ELSE FALSE.
%

ROUTINE INIT(CHNL,STATUS,LDEV,BUF)=
  EXETEST(MAKEOP(OPENUUO,.CHNL,STATUS<0,0>));


%       DEVSIZ RETURNS THE BUFFER SIZE FOR A GIVEN DEVICE IN A GIVEN MODE
%

ROUTINE DEVSIZ(STATUS,LDEV)=
BEGIN
   VREG_STATUS<0,0>;
   CALLI(VREG,#101);
   NOP();
   .VREG
END;


%       "LOOKUP" AND "ENTER" TAKE THE STANDARD PARAMETER BLOCK EXPECTED
        BY THE MONITOR FOR EITHER THE REGULAR OR EXTENDED OPERATIONS
        SINCE THE MONITOR FIGURES OUT WHICH IS WHICH.  THEY RETURN WITH
        TRUE OR FALSE.
%

ROUTINE LOOKUP(CHNL,BLOCK)=
  EXETEST(MAKEOP(LOOKUPUUO,.CHNL,BLOCK<IND>));

ROUTINE ENTER(CHNL,BLOCK)=
  EXETEST(MAKEOP(ENTERUUO,.CHNL,BLOCK<IND>));


ROUTINE IOABT=ERRMSG('IO ABORT');


ROUTINE PANIC=
   (.F[EXCEPT])(ERRCODE);


ROUTINE SCPB(CURSOR,CODE)=
BEGIN

   ROUTINE ZONK(CURSOR,S)=
      BEGIN
         BIND
            DISP=(.CURSOR-1) MOD .F[ITEMPW],
            WORDS=(((.CURSOR-1)/.F[ITEMPW]) MOD .F[BSIZE])+1,
            BN=.CURSOR/.F[ITEMPW]/.F[BSIZE],
            DELBN=BN-(CASE .S OF SET .F[ICP]; .F[OCP] TES);
         (CASE .S OF SET
            BEGIN
               IF DELBN NEQ 0
                  THEN CASE IF BETWEEN(DELBN,1,.F[NB]-1)
                               THEN BEGIN
                                  REGISTER Q;
                                  MAP BUF Q;
                                  Q_.F[ICBUF];
                                  DECR R FROM DELBN TO 1 DO Q_.Q[FLINK];
                                  .Q[USEBIT]
                                  END
                               ELSE 0
                        OF SET
                           DECR R FROM DELBN TO 1 DO (XCT(0,F[INOP]); NOP());
                           BEGIN
                              F[ICP]_BN+1; XCT(0,F[USETIOP]);
                              IF INFAILS THEN PANIC() ELSE .VREG
                           END
                        TES;
               F[IPTR]
            END;
            BEGIN
               IF DELBN NEQ 0
                  THEN BEGIN
                     IF NOT .F[DIRTY] THEN F[OPTR]_.F[OCBUF]+1;
                     F[OCP]_BN+1; XCT(0,F[USETOOP]);
                     IF .F[OCP] GTR .F[MAXCP] THEN (F[MAXCP]_.F[OCP]; F[WLB]_1)
                  END;
               F[OPTR]
            END
         TES)_((CASE .S OF SET .F[ICBUF]; .F[OCBUF] TES)+WORDS+1)
            <36-DISP*.F[ISIZE],.F[ISIZE]>;
         (CASE .S OF SET F[ICOUNT]; F[OCOUNT] TES)_.F[BSIZE]-WORDS
      END;

   IF .CODE NEQ OUTPUT THEN ZONK(.CURSOR,INPUT);
   IF .CODE NEQ INPUT THEN ZONK(.CURSOR,OUTPUT);

   IF .F[TYPE] EQL UPDATE THEN COPYBUF ELSE .VREG
END;


ROUTINE SCPU(CURSOR)=
BEGIN
   IF (.CURSOR AND #177) NEQ 0 THEN (.F[EXCEPT])(BADCUR);
   BEGIN
      BIND
         BLN=1+.CURSOR/.F[BSIZE];

      IF .F[TYPE] NEQ OUTPUT THEN (F[ICP]_BLN; XCT(0,F[USETIOP]));
      IF .F[TYPE] NEQ INPUT
         THEN BEGIN
            F[OCP]_BLN; XCT(0,F[USETOOP]);
             IF .F[OCP] GTR .F[MAXCP] THEN (F[MAXCP]_.F[OCP]; F[WLB]_1) ELSE .VREG
            END
   END
END;


ROUTINE CPR(CODE)=
   CASE .CODE*2+(.F[NB] GTR 0) OF SET
%UNBUF INPUT%   .F[ICP]*.F[BSIZE];
%BUF   INPUT%   (.F[ICP]+1)*.F[BSIZE]*.F[ITEMPW]-.F[ICOUNT];
%UNBUF OUTPUT%  .F[OCP]*.F[BSIZE];
%BUF   OUTPUT%  (.F[OCP]+1)*.F[BSIZE]*.F[ITEMPW]-.F[OCOUNT]
   TES;


ROUTINE RI=
   IF DEC(F[ICOUNT]) LEQ 0
      THEN BEGIN
         REGISTER T;
         T_SCANI(F[IPTR]);
         (.F[IBUFR])();
         .T
         END
      ELSE SCANI(F[IPTR]);

ROUTINE RUB(CNT,ADR)=
BEGIN
   IF (.CNT AND #177) NEQ 0 THEN (.F[EXCEPT])(BADCNT);
   F[COML]<18,18>_-.CNT;
   F[COML]<0,18>_.ADR-1;
   IF INFAILS THEN PANIC() ELSE F[ICP]_.F[ICP]+.CNT^(-7)
END;


ROUTINE RBB(CNT,ADR)=
   WHILE .CNT GTR 0 DO
      BEGIN
         REGISTER Q;
         MOVE(Q_MIN(.CNT,.F[ICOUNT]),.F[IPTR]+1,.ADR);
         IF (F[IPTR]_.F[IPTR]+.Q; F[ICOUNT]_.F[ICOUNT]-.Q) EQL 0
            THEN (.F[IBUFR])();
         CNT_.CNT-.Q
      END;


ROUTINE RU=
BEGIN
   REGISTER T;
   T_RI();
   IF DEC(F[OCOUNT]) LEQ 0
      THEN SCPB(.F[ICP]*.F[ITEMPW]*.F[BSIZE],OUTPUT);
   .T
END;


ROUTINE RBBU(CNT,ADR)=
BEGIN
   RBB(.CNT,.ADR);
   SCPB((.F[ICP]+1)*.F[BSIZE]-.F[ICOUNT],OUTPUT)
END;


ROUTINE WI(ELE)=
BEGIN
   REPLACEI(F[OPTR],.ELE);
   IF DEC(F[OCOUNT]) LEQ 0
      THEN (.F[OBUFR])();
   .ELE
END;

ROUTINE WU(ELE)=
BEGIN
   WI(.ELE); F[DIRTY]_1;
   IF NOT .F[WLB]
      THEN BEGIN
         IF DEC(F[ICOUNT]) LSS 0
            THEN IF INFAILS
               THEN PANIC()
               ELSE BEGIN
                  COPYBUF; REPLACEI(F[OPTR],.ELE);
                  DEC(F[ICOUNT]); INC(F[ICP])
               END;
         INCP(F[IPTR])
      END;
   .ELE
END;


ROUTINE WUB(CNT,ADR)=
BEGIN
   IF (.CNT AND #177) NEQ 0 THEN (.F[EXCEPT])(BADCNT);
   F[COML]<18,18>_-.CNT;
   F[COML]<0,18>_.ADR-1;
   IF OUTFAILS THEN PANIC()
                ELSE IF (F[OCP]_.F[OCP]+.CNT^(-7)) GEQ .F[MAXCP]
                        THEN (F[MAXCP]_.F[OCP]; F[WLB]_1)
END;


ROUTINE WBB(CNT,ADR)=
   WHILE .CNT GTR 0 DO BEGIN
      REGISTER Q;
      MOVE(Q_MIN(.F[OCOUNT],.CNT),.ADR,.F[OPTR]+1);
      IF (F[OPTR]_.F[OPTR]+.Q; F[OCOUNT]_.F[OCOUNT]-.Q) EQL 0
         THEN (.F[OBUFR])();
      CNT_.CNT-.Q
   END;


ROUTINE WBBU(CNT,ADR)=
BEGIN
   WBB(.CNT,.ADR);
   SCPB((.F[OCP]+1)*.F[BSIZE]-.F[OCOUNT],INPUT)
END;


ROUTINE ER=
   (.F[EXCEPT])(ILLOP);


ROUTINE FBUF=FREEM(.F-1);

%       HERE ARE ARE THE ENTRIES FOR ALL THE ROUTINES.
        MOST OF THEM MERELY ELABORATE THE APPROPRIATE ROUTINE SPECIFIED
        IN THE FILE CONTROL BLOCK AT OPEN TIME.
%

GLOBAL ROUTINE SXCP(FILE,CURSOR,C)=
BEGIN
   F_.FILE;
   IF .F[TYPE] NEQ FDX THEN (.F[EXCEPT])(ILLOP);
   (.F[SCPR])(.CURSOR,.C)
END;


GLOBAL ROUTINE SCP(FILE,CURSOR)=
BEGIN
   F_.FILE;
   (.F[SCPR])(.CURSOR,.F[TYPE])
END;


GLOBAL ROUTINE CP(FILE)=
BEGIN
   F_.FILE;
   CPR(.F[TYPE])
END;


GLOBAL ROUTINE CPX(FILE,CODE)=
BEGIN
   F_.FILE;
   CPR(.CODE)
END;


GLOBAL ROUTINE R(FILE)=
BEGIN
   F_.FILE;
   (.F[RR])()
END;


GLOBAL ROUTINE RB(FILE,CNT,ADR)=
BEGIN
   F_.FILE;
   (.F[RBR])(.CNT,.ADR)
END;


GLOBAL ROUTINE INBUF=
   IF INFAILS THEN PANIC()
              ELSE INC(F[ICP]);


GLOBAL ROUTINE IN(FILE)=
BEGIN
   F_.FILE;
   (.F[IBUFR])()
END;


GLOBAL ROUTINE W(FILE,ELE)=
BEGIN
   F_.FILE;
   (.F[WR])(.ELE)
END;


GLOBAL ROUTINE WB(FILE,CNT,ADR)=
BEGIN
   F_.FILE;
   (.F[WBR])(.CNT,.ADR)
END;


GLOBAL ROUTINE OUTBUF=
   IF OUTFAILS THEN PANIC()
               ELSE CASE SIGN(INC(F[OCP])-.F[MAXCP])+1 OF SET
                  NOP(); F[WLB]_1; INC(F[MAXCP]) TES;


GLOBAL ROUTINE OUT(FILE)=
BEGIN
   F_.FILE;
   (.F[OBUFR])()
END;


GLOBAL ROUTINE CLOSE(FILE)=
BEGIN
   F_.FILE;
   EXECUTE(MAKEOP(CLOSEUUO,.F[CHNL],0));
   IF EXETEST(MAKEOP(STATZ,.F[CHNL],#760000))
      THEN EXECUTE(MAKEOP(RELEAS,.F[CHNL],0))
      ELSE PANIC();
   IF .F[IBUFL] NEQ 0 THEN FREEM(.F[IBUFL]);
   IF .F[OBUFL] NEQ 0 THEN FREEM(.F[OBUFL]);
   FBUF()
END;



GLOBAL ROUTINE OPEN(FIDT,PARAM,NBUFS,EXCP)=
BEGIN

%  FIDT IS A POINTER TO THE FILE ID TABLE WHICH BASICALLY IS THE EXTENDED
   LOOKUP OR ENTER BLOCK FOR DISC FILES.  THE STANDARD BLOCK WILL WORK TOO.
   THE SINGLE EXCEPTION IS THAT THE -1TH ENTRY OF FIDT IS THE DEVICE
   NAME IN SIXBIT FOR THE OPEN UUO.  IF 0 IT DEFAULTS TO DISK.

   PARAM IS THE WORD SPECIFYING THE ACCESS STRUCTURE TO THE FILE AND IS
   PACKED FROM THE BASIC FORMS OF TYPE, ORGANIZATION AND MODE.  OPEN
   ENCODES THESE PARAMETERS INTO A 'FILE STRUCTURE CODE'(FSC) WHICH IS USED
   TO ACCESS THE VARIOUS TABLES WHICH SPECIFY WHAT ROUTINES ARE USED FOR
   WHAT OPERATIONS.  SINCE THE ENCODINGS ARE MESSY THE VARIOUS VALUES ARE:

  FSC    TYPE     ORG   MODE     BUF?   CFSC
  ----------------------------------------------
   0:    INPUT    CHAR  SEQUEN   UNBUF (INVALID)
   1:    OUTPUT   CHAR  SEQUEN   UNBUF (INVALID)
   2:    UPDATE   CHAR  SEQUEN   UNBUF (INVALID)
   3:    FDX      CHAR  SEQUEN   UNBUF (INVALID)
   4:    INPUT    WORD  SEQUEN   UNBUF  0
   5:    OUTPUT   WORD  SEQUEN   UNBUF  1
   6:    UPDATE   WORD  SEQUEN   UNBUF (INVALID)
   7:    FDX      WORD  SEQUEN   UNBUF (INVALID)
   8:    INPUT    CHAR  DIRECT   UNBUF (INVALID)
   9:    OUTPUT   CHAR  DIRECT   UNBUF (INVALID)
  10:    UPDATE   CHAR  DIRECT   UNBUF (INVALID)
  11:    FDX      CHAR  DIRECT   UNBUF (INVALID)
  12:    INPUT    WORD  DIRECT   UNBUF  2
  13:    OUTPUT   WORD  DIRECT   UNBUF  3
  14:    UPDATE   WORD  DIRECT   UNBUF  4
  15:    FDX      WORD  DIRECT   UNBUF  5
  16:    INPUT    CHAR  SEQUEN   BUF    6
  17:    OUTPUT   CHAR  SEQUEN   BUF    7
  18:    UPDATE   CHAR  SEQUEN   BUF   (INVALID)
  19:    FDX      CHAR  SEQUEN   BUF   (INVALID)
  20:    INPUT    WORD  SEQUEN   BUF    8
  21:    OUTPUT   WORD  SEQUEN   BUF    9
  22:    UPDATE   WORD  SEQUEN   BUF   (INVALID)
  23:    FDX      WORD  SEQUEN   BUF   (INVALID)
  24:    INPUT    CHAR  DIRECT   BUF    10
  25:    OUTPUT   CHAR  DIRECT   BUF    11
  26:    UPDATE   CHAR  DIRECT   BUF    12
  27:    FDX      CHAR  DIRECT   BUF    13
  28:    INPUT    WORD  DIRECT   BUF    14
  29:    OUTPUT   WORD  DIRECT   BUF    15
  30:    UPDATE   WORD  DIRECT   BUF    16
  31:    F   WORD  DIRECT   BUF    17

  NBUFS DETERMINES THE NUMBER OF BUFFERS ALLOCATED FOR THE IO
  OPERATIONS.  IF ZERO, THEN THE DATA MODE IS UNBUFFERED.
%

% THE FOLLOWING MACRO DOES THE ENCODING OF PARAM
%
MACRO
   CHAR=0$,
   ENC7X5(A,B,C,D,E,F,G)=A^31+B^26+C^21+D^16+E^11+F^6+G^1$,
   ENC18X2(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R)=
      A^34+B^32+C^30+D^28+E^26+F^24+G^22+H^20+I^18+J^16+K^14+L^12+
      M^10+N^8+O^6+P^4+Q^2+R$,
   ENCODE(A,B,C,D)=NTYPE*NORG*NMODE*A+NORG*NMODE*B+NMODE*C+D$;

%  THE FOLLOWING BINDS IMPLEMENT THE TABLES DEFINING THE VARIOUS ROUTINES
   TO BE CALLED TO ELABORATE THE IO OPERATIONS FOR VARIOUS FILE STRUCTURES.
   IN EACH CASE, THE INDEX IS THE COMPRESSEDFILE STRUCTURE CODE (CFSC).
%
BIND
%READ ELEMENT ROUTINE%
   RRS=PLIT(ENC18X2(2,2,2,2,2,2,0,2,0,2,0,2,1,0,0,2,1,0),RI,RU,ER),
%WRITE ELEMENT ROUTINE%
   WRS=PLIT(ENC18X2(2,2,2,2,2,2,2,0,2,0,2,0,1,0,2,0,1,0),WI,WU,ER),
%READ BLOCK ROUTINE%
   RBRS=PLIT(ENC18X2(1,3,1,3,1,1,3,3,0,3,3,3,3,3,0,3,2,0),RBB,RUB,RBBU,ER),
%WRITE BLOCK ROUTINE%
   WBRS=PLIT(ENC18X2(3,1,3,1,1,1,3,3,3,0,3,3,3,3,3,0,2,0),WBB,WUB,WBBU,ER),
%SET CURSOR POSITION ROUTINES%
   SCPRS=PLIT(ENC18X2(2,2,1,1,1,1,2,2,2,2,0,0,0,0,0,0,0,0),SCPB,SCPU,ER),
%MAPPING VECTOR FOR FSC TO CFSC%
   MFSC=PLIT(ENC7X5(0,0,0,0,1,2,0),
             ENC7X5(0,0,0,0,0,0,3),
             ENC7X5(4,5,6,7,8,0,0),
             ENC7X5(9,10,0,0,11,12,13),
             ENC7X5(14,15,16,17,18,0,0)),
%ERROR RETURN CODES%
   ILLMODE=-1,
   NOCHAN=-2,
   LKFAIL=-3,
   ENFAIL=-4,
   NOINIT=-5;

%       BYTE VECTORS FOR THE TABLES
%
MAP LBYTEVEC MFSC[5,32], FID FIDT,
    COMTAB RRS:WRS:RBRS:WBRS:SCPRS;

LOCAL CFSC,DATMODE;

EXTERNAL JOBHCU,JOBJDA;

   BIND TTY=.FIDT[DEV] EQL SIXBIT 'TTY';


   F_GETM(FCBS+1)+1;
   F[P]_.PARAM;
   F[NB]_.NBUFS;
   IF
      (CFSC_.MFSC[ENCODE((.F[NB] GTR 0),.F[MODE],.F[ORG],.F[TYPE])])-1
      EQL -1 THEN (FBUF(); RETURN ILLMODE);

   IF TTY THEN (CFSC_12; F[TYPE]_UPDATE);

   DATMODE_IF .F[ORG] EQL CHAR
              THEN 0
           ELSE IF .F[NB] EQL 0
              THEN #15
           ELSE #10;

   IF (F[CHNL]_IF .JOBHCU EQL 0 AND .JOBJDA EQL 0
                  THEN 0
               ELSE IF .JOBHCU LSS 15
                          THEN .JOBHCU+1
                  ELSE DECR S FROM 14 TO 0 DO
                     IF @(JOBJDA+.S) EQL 0 THEN EXITLOOP .S)
      LSS 0 THEN (FBUF(); RETURN NOCHAN);

   IF .FIDT[DEV] EQL 0 THEN FIDT[DEV] _ SIXBIT 'DSK';

   IF NOT INIT(.F[CHNL],.DATMODE,.FIDT[DEV],F[OBUFH]^18+F[IBUFH]<0,0>)
      THEN (FBUF(); RETURN NOINIT);

   IF .F[TYPE] NEQ OUTPUT
      THEN IF NOT LOOKUP(.F[CHNL],.FIDT) THEN (FBUF(); RETURN LKFAIL);
   IF .F[TYPE] NEQ INPUT
      THEN IF NOT ENTER(.F[CHNL],.FIDT) THEN (FBUF(); RETURN ENFAIL);

   IF (F[BSIZE]_DEVSIZ(.DATMODE,.FIDT[DEV])-3) LSS 0
      THEN (FBUF(); RETURN ILLMODE);

   IF .F[NB] GTR 0
      THEN BEGIN
         ROUTINE GENBF(SIDE)=
         BEGIN
            LOCAL T,K;
            EXTERNAL JOBFF;
            T_@JOBFF;
            JOBFF_(K_GETM((.F[BSIZE]+3)*.F[NB]+1))+1;
            EXECUTE(MAKEOP((INBF+.SIDE),.F[CHNL],.F[NB]));
            JOBFF_.T;
            .K
         END;

         F[BUFL]_0;
         IF .F[TYPE] NEQ OUTPUT THEN F[IBUFL]_GENBF(INPUT);
         IF .F[TYPE] NEQ INPUT THEN F[OBUFL]_GENBF(OUTPUT)
      END;

   IF NOT TTY
      THEN BEGIN
         F[RR]_.RRS[.CFSC];
         F[WR]_.WRS[.CFSC];
         F[RBR]_.RBRS[.CFSC];
         F[WBR]_.WBRS[.CFSC];
         F[SCPR]_.SCPRS[.CFSC];
         F[MAXCP]_.FIDT[RBSIZ]/.F[BSIZE]+1
         END
      ELSE BEGIN
         F[RR]_RI;
         F[WR]_WI;
         F[RBR]_ER;
         F[WBR]_ER;
         F[SCPR]_ER;
         F[MAXCP]_0
         END;

   F[IBUFR]_INBUF;
   F[OBUFR]_OUTBUF;
   F[INOP]_MAKEOP(INUUO,.F[CHNL],(IF .F[NB] EQL 0 THEN F[COML]<0,0> ELSE 0));
   F[OUTOP]_.F[INOP] OR 1^27;
   F[STATZOP]_MAKEOP(STATZ,.F[CHNL],#740000);
   F[USETIOP]_MAKEOP(USETI,.F[CHNL],0);
   F[USETOOP]_.F[USETIOP] OR 1^27;
   F[DIRTY]_0;
   F[WLB]_.F[TYPE] EQL OUTPUT;
   F[COML]+1_0;
   F[ISIZE]_IF .F[ORG] EQL 0 THEN 7 ELSE 36;
   F[ITEMPW]_36/.F[ISIZE];
   F[EXCEPT]_IOABT;

   IF .F[NB] GTR 0
      THEN BEGIN
         IF .F[TYPE] NEQ OUTPUT
         THEN IF NOT TTY
            THEN INFAILS;
         IF .F[TYPE] NEQ INPUT
            THEN OUTFAILS
      END;

   .F

END;


GLOBAL ROUTINE RESET=
BEGIN
   CALLI(0);
   INITM();
   TTYF_OPEN(PLIT(SIXBIT 'TTY')+1,0,1,-1)
END;
END ELUDOM
  v ]Þ