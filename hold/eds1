  10  INTEGER OBJ,HISTRY(100),SPCALC,FLUSH,BRIEF,FRSTSG,EDITL,CURRGO,
             EXIST,CMND,CURCMP,ERRCNT,COMPL,ACTVL,PRNTL,FSTITM,CLRITM,HASH,
              SONPTR,SONS,TREE,BUFITM,ITMLOC,ITMDIM,TYPE,OVLNO,FMTPTR
  20  COMMON FV(3000)
  30  COMMON ITEM,OBJ,SBSNAM,LSBNAM,HISTRY,
             SPCALC,NOPRNT,FLUSH,ITMCHK,BRIEF,
             INPUT(21),LINPUT,FRSTSG,LASTSG,NXSTRT,
             EDITL(100),LEDITL,OVL,INDOVL,INDIR,
  40 COMMON  CURRGO,LASTGO,CMND,CURCMP,ERRCNT,
             COMPL(100),LCOMPL,ACTVL(100),LACTVL,PRNTL(100),LPRNTL,
             NITEMS,MULTRE,EXIST(3),FSTITM,LSTITM,CLRITM,
  50 COMMON  HASH(199),SONPTR(25),SONS(65),TREE(100),
             DICFIL,FMTFIL,ATRFIL,
             BUFITM,ITMLOC,ITMMOD,ITMDIM,ITMTYP,ITMIO,ITMOVL,
             ITMFMT,ITMMIN,ITMMAX,ITMNAM(7),LITNAM
  60  REAL ITMMIN,ITMMAX
  70  STRING INPUT(4),ITMNAM(4)
  80  STRING SBSNAM(8),OVL(8),INDOVL(8),DICFIL(8),FMTFIL(8),ATRFIL(8)
  90 * 
 100 *FROM RUNCOMDS
 110  INTEGER ALL,EXITEM,CLEAR,CEXEC,CURITM,CSONNO,CURSON
 120  STRING DICTF(4),FMTF(4),ATRF(4),MSGF(4)
 130  STRING DBLANK(8),MSGFIL(8),DSPHSH(8),DSDATA(8)
 140  DATA MXLSBN,ALL,CLEAR,CURSON,CEXEC/6,0,7,0,102/
 150  DATA DICTF,FMTF,ATRF,MSGF/DF,FF,AF,MF/
 160  DATA DBLANK,DSPHSH,DSDATA/ ,DSPHSH,DSDATA/
 170  DATA N0,N1,N2,N1000,N10T6/0,1,2,1000,1000000/
 180  DATA M10/-10/
 190  EXITEM=N0
 200  IF(CMND.NE.N0)GOTO 10
 210 * 
 220 *  USER JUST STARTED -- THIS IS THE FIRST OVERLAY CALLED
 230 * 
 240 *  NULL OUT INPUT STRING TO FORCE SCOPE FAILURE IN DATADS
 250 * 
 260  LINPUT=N0
 270  NXSTRT=N0
 280 * 
 290 *  IS THERE A MODULE NAME IN COMMON
 300 * 
 310  IF(LSBNAM.NE.N0)GOTO 20
 320 * 
 330 *  NO MODULE NAME IN COMMON -- ZERO OUT PARAMETERS NORMALLY READ
 340 *  FROM MODULE'S BINARY DICTIONARY FILE AND READ IN PROTOTYPE
 350 *  HASH TABLE CONTAINING ENTRIES FOR SYSTEM COMMANDS ONLY
 360 * 
 370  NITEMS=100
 380  FSTITM=N0
 390  LSTITM=N0
 400  CLRITM=N0
 410  MULTRE=N0
 420  DICFIL=DSPHSH
 430  OPEN(3,DICFIL,INPUT,BINARY)
 440  READ(3)HASH
 450  GOTO 40
 460 * 
 470 *  CHECK FOR CLEAR COMMAND
 480 * 
 490  10   IF(CMND.EQ.CLEAR)GOTO 100
 500 * 
 510 *  INITIAL MODULE NAME GIVEN OR SWITCHING MODULES
 520 * 
 530 *  CONSTRUCT NAMES OF BINARY DICTIONARY FILE (DICFIL),
 540 *  ATTRIBUTE FILE (ATRFIL), AND FORMAT FILE (FMTFIL) FROM
 550 *  MODULE NAME AND SUFFIXES
 560 * 
 570  20   LSBNAM=MIN0(LSBNAM,MXLSBN)
 580  L=LSBNAM+N1
 590  DICFIL=DBLANK
 600  CALL MOVE(SBSNAM,N1,DICFIL,N1,LSBNAM)
 610  CALL MOVE(DICTF,N1,DICFIL,L,N2)
 620  ATRFIL=DBLANK
 630  CALL MOVE(SBSNAM,N1,ATRFIL,N1,LSBNAM)
 640  CALL MOVE(ATRF,N1,ATRFIL,L,N2)
 650  FMTFIL=DBLANK
 660  CALL MOVE(SBSNAM,N1,FMTFIL,N1,LSBNAM)
 670  CALL MOVE(FMTF,N1,FMTFIL,L,N2)
 680 * 
 690 *  CONSTRUCT NAME OF BANNER MESSAGE FILE AND CALL ROUTINE TO
 700 *  DUMP IT IF IT EXISTS
 710 * 
 720  MSGFIL=DBLANK
 730  CALL MOVE(SBSNAM,N1,MSGFIL,N1,LSBNAM)
 740  CALL MOVE(MSGF,N1,MSGFIL,L,N2)
 750  CALL FDUMP(MSGFIL,$30)
 760 * 
 770 *  READ IN ALL ASSUMED VALUES
 780 * 
 790  30   CALL ASMVAL(ALL)
 800 * 
 810 *  READ MODULE'S PARAMETERS FROM BINARY DICTIONARY FILE
 820 * 
 830  OPEN(3,DICFIL,INPUT,BINARY)
 840  READ(3)NITEMS,MULTRE,FSTITM,LSTITM,CLRITM,HASH,
             SONPTR,SONS,TREE,EXIST
 850 * 
 860 *  SET ITEM TO BE EXECUTED TO FIRST ITEM
 870 * 
 880  EXITEM=FSTITM
 890 * 
 900 *  INITIALIZE COMMON
 910 * 
 920  40   ITEM=N0
 930  OBJ=N0
 940  DO 50 I=N1,NITEMS
 950  50   HISTRY(I)=N0
 960  SPCALC=N0
 970  NOPRNT=N0
 980  FLUSH=N0
 990  ITMCHK=N0
1000  BRIEF=N0
1010  LEDITL=N0
1020  CURRGO=N0
1030  LASTGO=N0
1040  CURCMP=N0
1050  LCOMPL=N0
1060  LACTVL=N0
1070  LPRNTL=N0
1080  ERRCNT=N0
1090  BUFITM=N0
1100 * 
1110 *  SEE IF AN ITEM'S RELATION CODE SHOULD BE EXECUTED
1120 * 
1130  IF(EXITEM.EQ.N0)GOTO 70
1140 * 
1150 *  BUILD A COMPUTATION LIST OF ONE ITEM TO EXECUTE THE ITEM AS
1160 *  A COMMAND WITH PRINTING SUPPRESSED
1170 * 
1180  CALL FILE(EXITEM)
1190  LCOMPL=N1
1200  COMPL(LCOMPL)=N10T6+N1000*ITMOVL+EXITEM
1210  CMND=CEXEC
1220  60   CLOSE(4)
1230  70   IF(INDIR.EQ.N0)OVL=DSDATA
1240  INDIR=-INDIR
1250  CLOSE(3)
1260  RETURN
1270 * 
1280 * 
1290 * 
1300 *  CLEAR COMMAND
1310 * 
1320 *  SEE IF AN OBJECT WAS GIVEN
1330 * 
1340  100  IF(OBJ.NE.N0)GOTO 110
1350 * 
1360 *  NO OBJECT -- CLEAR ALL ITEMS
1370 * 
1380 *  READ IN ALL ASSUMED VALUES, SET ITEM TO BE EXECUTED TO
1390 *  THE CLEAR ITEM, AND GOTO RE-INITIALIZE COMMON
1400 * 
1410  CALL ASMVAL(ALL)
1420  EXITEM=CLRITM
1430  GOTO 40
1440 * 
1450 *  OBJECT GIVEN
1460 * 
1470 *  READ IN ASSUMED VALUE OF OBJECT (IF ANY)
1480 * 
1490  110  CALL ASMVAL(OBJ)
1500 * 
1510 *  IF OBJ IS CURRENTLY IN ERROR , BUMP ERROR COUNT DOWN
1520 * 
1530  IF(IABS(HISTRY(OBJ)).GE.N1000)ERRCNT=ERRCNT-N1
1540 * 
1550 *  IS THERE AN ACTIVE LIST
1560 * 
1570  IF(LACTVL.GT.N0)GOTO 120
1580 * 
1590 *  NO ACTIVE LIST
1600 * 
1610 *  JUST SET HISTORY OF OBJ TO ZERO AND GET OUT
1620 * 
1630  HISTRY(OBJ)=N0
1640  GOTO 60
1650 * 
1660 *  THERE IS AN ACTIVE LIST
1670 * 
1680 *  REVOVE FROM ACTIVE LIST OBJ (IF ON ) AND ALL OTHER ITEMS
1690 *  WHOSE VALUES DEPEND ON OBJ DIRECTLY OR INDIRECTLY
1700 * 
1710  120  HISTRY(OBJ)=M10
1720  DO 150 I=N1,LACTVL
1730  CURITM=ACTVL(I)
1740  IF(CURITM.EQ.OBJ)GOTO 140
1750  CSONNO=N0
1760  130  CSONNO=CSONNO+N1
1770  CALL GETSON(CURITM,CSONNO,CURSON,N0,$150,$150)
1780  IF(HISTRY(CURSON).NE.M10)GOTO 130
1790  IF(IABS(HISTRY(CURITM)).GE.N1000)ERRCNT=ERRCNT-N1
1800  HISTRY(CURITM)=M10
1810  140  ACTVL(I)=N0
1820  150  CONTINUE
1830  DO 160 CURITM=N1,NITEMS
1840  IF(HISTRY(CURITM).EQ.M10)HISTRY(CURITM)=N0
1850  160  CONTINUE
1860  J=N0
1870  DO 180 I=N1,LACTVL
1880  IF(ACTVL(I))170,180,170
1890  170  J=J+N1
1900  ACTVL(J)=ACTVL(I)
1910  180  CONTINUE
1920  LACTVL=J
1930  GOTO 60
1940  END
1950  SUBROUTINE FILE(ITEMNO)
1960  INTEGER OBJ,HISTRY(100),SPCALC,FLUSH,BRIEF,FRSTSG,EDITL,CURRGO,
             EXIST,CMND,CURCMP,ERRCNT,COMPL,ACTVL,PRNTL,FSTITM,CLRITM,HASH,
              SONPTR,SONS,TREE,BUFITM,ITMLOC,ITMDIM,TYPE,OVLNO,FMTPTR
1970  COMMON FV(3000)
1980  COMMON ITEM,OBJ,SBSNAM,LSBNAM,HISTRY,
             SPCALC,NOPRNT,FLUSH,ITMCHK,BRIEF,
             INPUT(21),LINPUT,FRSTSG,LASTSG,NXSTRT,
             EDITL(100),LEDITL,OVL,INDOVL,INDIR,
1990 COMMON  CURRGO,LASTGO,CMND,CURCMP,ERRCNT,
             COMPL(100),LCOMPL,ACTVL(100),LACTVL,PRNTL(100),LPRNTL,
             NITEMS,MULTRE,EXIST(3),FSTITM,LSTITM,CLRITM,
2000 COMMON  HASH(199),SONPTR(25),SONS(65),TREE(100),
             DICFIL,FMTFIL,ATRFIL,
             BUFITM,ITMLOC,ITMMOD,ITMDIM,ITMTYP,ITMIO,ITMOVL,
2010 COMMON  ITMFMT,ITMMIN,ITMMAX,ITMNAM(7),LITNAM
2020  REAL ITMMIN,ITMMAX
2030  STRING INPUT(4),ITMNAM(4)
2040  STRING SBSNAM(8),OVL(8),INDOVL(8),DICFIL(8),FMTFIL(8),ATRFIL(8)
2050 * 
2060 *FROM RUNCOMDS
2070 * 
2080 *  SUBROUTINE TO READ THE ATTRIBUTES OF AN ITEM FROM THE
2090 *  MODULE'S ATTRIBUTE FILE INTO COMMON, WHERE ITEMNO IS THE
2100 *  NUMBER OF THE ITEM WHOSE ATTRIBUTES ARE TO BE READ
2110 * 
2120  STRING COLON(4)
2130  DATA COLON/:/
2140  DATA N0,N1,N28/0,1,28/
2150 * 
2160 *  IF ITEM'S ATTRIBUTES ARE ALREADY IN CORE, RETURN
2170 * 
2180  IF(ITEMNO.EQ.BUFITM)GOTO 1
2190  BUFITM=ITEMNO
2200 * 
2210 *  READ THE ITEM'S ATTRIBUTES USING THE ITEM'S NUMBER AS
2220 *  A RECORD INDEX
2230 * 
2240  OPEN(4,ATRFIL,RANDIO,BINARY)
2250  READ(4)(BUFITM)ITMLOC,ITMMOD,ITMDIM,ITMTYP,ITMIO,
            ITMOVL,ITMFMT,ITMMIN,ITMMAX,ITMNAM
2260 * 
2270 *  COMPUTE LENGTH OF ITEM'S FIRST NAME (NAMES ARE IN ITMNAM
2280 *  ENDED BY COLONS)
2290 * 
2300  M=N1
2310  CALL SCOPE(ITMNAM,M-N28,K,LITNAM,N0,N0,N0,N0,COLON,N1,$2)
2320  1    RETURN
2330 * 
2340 *  ITEM HAS NO NAME
2350 * 
2360  2    LITNAM=N0
2370  GOTO 1
2380  END
2390  SUBROUTINE ASMVAL(ITEMNO)
2400  INTEGER OBJ,HISTRY(100),SPCALC,FLUSH,BRIEF,FRSTSG,EDITL,CURRGO,
             EXIST,CMND,CURCMP,ERRCNT,COMPL,ACTVL,PRNTL,FSTITM,CLRITM,HASH,
              SONPTR,SONS,TREE,BUFITM,ITMLOC,ITMDIM,TYPE,OVLNO,FMTPTR
2410  COMMON FV(3000)
2420  COMMON ITEM,OBJ,SBSNAM,LSBNAM,HISTRY,
             SPCALC,NOPRNT,FLUSH,ITMCHK,BRIEF,
             INPUT(21),LINPUT,FRSTSG,LASTSG,NXSTRT,
             EDITL(100),LEDITL,OVL,INDOVL,INDIR,
2430 COMMON  CURRGO,LASTGO,CMND,CURCMP,ERRCNT,
             COMPL(100),LCOMPL,ACTVL(100),LACTVL,PRNTL(100),LPRNTL,
             NITEMS,MULTRE,EXIST(3),FSTITM,LSTITM,CLRITM,
2440 COMMON  HASH(199),SONPTR(25),SONS(65),TREE(100),
             DICFIL,FMTFIL,ATRFIL,
             BUFITM,ITMLOC,ITMMOD,ITMDIM,ITMTYP,ITMIO,ITMOVL,
             ITMFMT,ITMMIN,ITMMAX,ITMNAM(7),LITNAM
2450  REAL ITMMIN,ITMMAX
2460  STRING INPUT(4),ITMNAM(4)
2470  STRING SBSNAM(8),OVL(8),INDOVL(8),DICFIL(8),FMTFIL(8),ATRFIL(8)
2480 * 
2490 *FROM RUNCOMDS
2500 * 
2510 *  SUBROUTINE TO READ ASSUMED VALUES FOR AN ITEM INTO ITS 
2520 *  ALLOCATED STORAGE IN FV, WHERE ITEMNO IS THE NUMBER OF THE
2530 *  ITEM WHOSE ASSUMED VALUES (IF ANY) ARE TO BE READ
2540 * 
2550 *  IF ITEMNO=0 ASSUMED VALUES FOR ALL ASSUMABLE ITEMS ARE READ
2560 * 
2570  INTEGER ALL,ASSUME
2580  DATA ALL,ASSUME/0,2/
2590  DATA N0,N10000/0,10000/
2600  IF(ITEMNO.NE.N0)GOTO 10
2610  LOCN=N10000
2620  GOTO 20
2630  10   CALL FILE(ITEMNO)
2640  IF(ITMTYP.NE.ASSUME)GOTO 100
2650  LOCN=ITMLOC
2660  20   READ(3)I1,I2
2670  30   IF(I1.EQ.N0.OR.I1.GT.LOCN)GOTO 100
2680  IF(ITEMNO.NE.N0)IF(I1-LOCN)50,40,50
2690  40   READ(3)(FV(I),I=I1,I2),I1,I2
2700  GOTO 30
2710  50   READ(3)(TEMP,I=I1,I2),I1,I2
2720  GOTO 30
2730  100  RETURN
2740  END
2750  SUBROUTINE FDUMP(FILE,*)
2760 * 
2770 *  SUBROUTINE TO PRINT A BCD FILE WITH OR WITHOUT LINE
2780 *  NUMBERS, WHERE FILE IS THE NAME OF THE FILE TO BE DUMPED
2790 * 
2800 *  NON-STANDARD RETURNS
2810 *    1 -- FILE DOES NOT EXIST OR IS NOT BCD
2820 * 
2830  INTEGER INFO(4),FSTCHR
2840  STRING TEXT(80),BUFF(2048),BLANK(4),CZERO(4)
2850  STRING FILE(8)
2860  LOGICAL EQ
2870  DATA BLANK,CZERO/ ,0/
2880  DATA N0,N1,N3,N7,N72,N510,N512/0,1,3,7,72,510,512/
2890 * 
2900 *  CHECK FOR EXISTANCE OF FILE
2910 * 
2920  CALL FILE#CHK(FILE,INFO,N1,$99)
2930 * 
2940 *  IS FILE BCD?
2950 * 
2960  IF(INFO(N1).NE.N0)GOTO 99
2970 * 
2980 *  FILE EXISTS AND IS BCD -- INITIALIZE FOR DUMP
2990 * 
3000  FSTCHR=N0
3010  NWDS=N512
3020 * 
3030 *  READ 1ST RECORD OF FILE AND DECIDE WHETHER OR NOT FILE HAS
3040 *  LINE NUMBERS
3050 * 
3060  10   CALL #READ#(FILE,TEXT,LTEXT,$50)
3070  IF(FSTCHR.NE.N0)GOTO 20
3080 * 
3090 *  FIRST TIME THROUGH -- CHECK IF FILE HAS LINE NUMBERS AND
3100 *  SET FSTCHR APPROPRIATELY
3110 * 
3120  FSTCHR=N1
3130  IF(EQ(TEXT,N1,CZERO,N1,N1))FSTCHR=N7
3140 * 
3150 *  IF NO LINE NUMBERS GET OUT AND READ A LINK AT A TIME
3160 * 
3170  IF(FSTCHR.EQ.N1)GOTO 30
3180 * 
3190 *  PRINT CURRENT LINE OF FILE WITH LINE NUMBERS AND GO BACK FOR
3200 *  NEXT LINE
3210 * 
3220  20   CALL STRPRINT(BLANK,TEXT,FSTCHR,LTEXT,N72)
3230  GOTO 10
3240 * 
3250 *  FILE HAS NO LINE NUMBERS -- READ IT UNBUFFERED A LINK AT A
3260 *  TIME -- INFO(3) HAS NUMBER OF LINKS
3270 * 
3280  30   CLOSE(6)
3290  NLINKS=INFO(N3)
3300  DO 40 LINK=N1,NLINKS
3310 * 
3320 *  GET NEXT LINK
3330 * 
3340  CALL #UREAD#(FILE,LINK,BUFF,NWDS)
3350  NWDSP=NWDS
3360 * 
3370 *  IF WE READ A FULL LINK (IE. NWDS STILL = 512) SET NUMBER OF
3380 *  WORDS TO PRINT TO 510 SINCE G.E. USES LAST TWO WORDS OF LINK
3390 *  TO POINT TO NEXT LINK
3400 * 
3410  IF(NWDSP.EQ.N512)NWDSP=N510
3420 * 
3430 *  PRINT OUT THIS LINK OF FILE (WE CAN GET AWAY WITH THIS SINCE
3440 *  END OF RECORD MARK FOR BCD FILES IS A WORD CONTAINING 
3450 *  CR LF RO RO)
3460 * 
3470  PRINT 34,(BUFF(J),J=N1,NWDSP)
3480  34   FORMAT('0',S)
3490  40   CONTINUE
3500  50   CLOSE(6)
3510  RETURN
3520  99   RETURN N1
3530  END
3540  SUBROUTINE GETSON(ITEMNO,SONNO,SON,IGNORE,*,*)
3550  INTEGER OBJ,HISTRY(100),SPCALC,FLUSH,BRIEF,FRSTSG,EDITL,CURRGO,
             EXIST,CMND,CURCMP,ERRCNT,COMPL,ACTVL,PRNTL,FSTITM,CLRITM,HASH,
              SONPTR,SONS,TREE,BUFITM,ITMLOC,ITMDIM,TYPE,OVLNO,FMTPTR
3560  COMMON FV(3000)
3570  COMMON ITEM,OBJ,SBSNAM,LSBNAM,HISTRY,
             SPCALC,NOPRNT,FLUSH,ITMCHK,BRIEF,
             INPUT(21),LINPUT,FRSTSG,LASTSG,NXSTRT,
             EDITL(100),LEDITL,OVL,INDOVL,INDIR,
3580 COMMON  CURRGO,LASTGO,CMND,CURCMP,ERRCNT,
             COMPL(100),LCOMPL,ACTVL(100),LACTVL,PRNTL(100),LPRNTL,
             NITEMS,MULTRE,EXIST(3),FSTITM,LSTITM,CLRITM,
3590 COMMON  HASH(199),SONPTR(25),SONS(65),TREE(100),
             DICFIL,FMTFIL,ATRFIL,
             BUFITM,ITMLOC,ITMMOD,ITMDIM,ITMTYP,ITMIO,ITMOVL,
             ITMFMT,ITMMIN,ITMMAX,ITMNAM(7),LITNAM
3600  REAL ITMMIN,ITMMAX
3610  STRING INPUT(4),ITMNAM(4)
3620  STRING SBSNAM(8),OVL(8),INDOVL(8),DICFIL(8),FMTFIL(8),ATRFIL(8)
3630 * 
3640 *FROM RUNCOMDS
3650 * 
3660 *  GETS ONE OF AN ITEM'S SONS, WHERE -
3670 *ITMNO = ITEM NO. OF ITEM WHOSE SON IS TO BE RETURNED
3680 *SONNO = NUMBER OF SON TO BE RETURNEE
3690 *  SON = ITEM NO. OF RETURNED SON
3700 *    IGNORE = ITEM NO. OF SON TO BE IGNORED BY THIS CALL
3710 * 
3720 *  NON-STANDARD RETURNS --
3730 *    1 -- ITEM DOES NOT HAVE SONNO SONS
3740 *    2 -- ITEM HAS NO SONS AT ALL
3750 * 
3760  INTEGER SONNO,SON,FSPTR,SPTR
3770  DATA FSPTR,LSPTR/0,0/
3780  DATA N1,N2,N4/1,2,4/
3790 * 
3800 *  GET POINTERS TO FIRST AND LAST SONS OF ITEM
3810 * 
3820  CALL MOVE(SONPTR,ITEMNO,FSPTR,N4,N1)
3830  CALL MOVE(SONPTR,ITEMNO+N1,LSPTR,N4,N1)
3840  LSPTR=LSPTR-N1
3850 * 
3860 *  IF NO SONS RETURN 2
3870 * 
3880  IF(FSPTR.GT.LSPTR)RETURN N2
3890 * 
3900 *  GET POINTER TO SONNO-TH SON OF ITEM
3910 * 
3920  10   SPTR=FSPTR+SONNO-N1
3930 * 
3940 *  IF NO SONNO--TH SON RETURN 1
3950 * 
3960  IF(SPTR.GT.LSPTR)RETURN N1
3970 * 
3980 *  GET SONNO-TH SON OF ITEM
3990 * 
4000  CALL MOVE(SONS,SPTR,SON,N4,N1)
4010 * 
4020 *  SEE IF WE SHOULD IGNORE IT -- IF SO, BUMP SONNO AND START OVER
4030 * 
4040  IF(SON.NE.IGNORE)RETURN
4050  SONNO=SONNO+N1
4060  GOTO 10
4070  END
 