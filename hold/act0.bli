!ACTIO0 MUST BE COMPILED IN THE ORDER: AC0HD,FIRST,TABLES,META72,ACTIO0
!***COPYRIGHT 1973, DIGITAL EQUIPEMENT CORP., MAYNARD, MASS.***
!AUTHOR: F.J. INFANTE
GLOBAL BIND ACT0V=41;	!21-MAY-73
SWITCHES LIST;
	FORWARD
		FUNCTIONSCAN,	!P.26
		FIRSTSTATEMENT,	!P.27
		TYPEID,		!P.28
		LETTER,		!P.29
		TOQUOTE,	!P.30
		RECORDMARK,	!P.31
		INTORL,		!P.32
		EXPRLIST,	!P.39
		MULTIASGN;	!P.40

GLOBAL ROUTINE DOLABEL=
BEGIN
EXTERNAL QUEUE,CHAR,STK,SP,ENTRY,TBLSEARCH,NAME,ERROUT;
REGISTER VALUE;
	VALUE _ 0;
	SIGCHAR;	!GET FIRST DIGIT
	WHILE DIGIT(C) DO
	BEGIN
		VALUE _ .VALUE*10;
		VALUE _ .VALUE +(-#60)[.C]<0,0>;
		SIGCHAR;
	END;
	QUEUE();	!QUEUE THE NON DIGIT
	IF .VALUE GTR 99999 THEN RETURN ERROUT(19);	!LABEL VALUE TOO LARGE
	NAME _ LABTAB; ENTRY[0] _ .VALUE;
	STK[SP _ .SP+1] _ TBLSEARCH();	!CREATE THE LABEL TABLE NODE
	.VREG;
END;
GLOBAL ROUTINE FUNCTIONSCAN =
BEGIN
	EXTERNAL Q,QON,QOFF,STK,SP;
	IF FIRSTSTATEMENT()  THEN
	BEGIN
		REGISTER R1,R2;
		ROUTINE SAVECHAR =
		BEGIN
			SIGCHAR;
			Q[R2_.R2+1]_.C;
			.VREG
		END;
		R1_(FNPLIT)<36,7>;R2_IF .QON EQL .QOFF THEN QON_QOFF_-1 ELSE .QON;
		DECR I FROM 7 TO 0 DO
			IF SAVECHAR() NEQ SCANI(R1) THEN(QON_.R2;RETURN -1);
		RETURN 0
	END
	ELSE RETURN -1
END;
GLOBAL ROUTINE FIRSTSTATEMENT =
BEGIN
	MACHOP SETZ=#400,TRZN=#626,SETO=#474;
	SETO(VREG,0);
	TRZN(FLGREG,#400000);
	SETZ(VREG,0);
	.VREG
END;
GLOBAL ROUTINE TYPEID =
BEGIN
	MAP BASE T1;
	EXTERNAL SCAN,GETCONST,TYPE;
	REGISTER R1,R2;
	SIGCHAR;	!NEXT SIGNIFICANT CHAR TO C
	SELECT .C OF NSET
	"I": EXITSELECT (R1_INTEGER;R2_PLIT'NTEGER');
	"R": EXITSELECT (R1_REAL;R2_PLIT'EAL');
	"D": EXITSELECT IF SCAN(PLIT'OUBLEPRECISION') LSS 0 THEN RETURN -1
		ELSE (TYPE_DOUBLPREC;RETURN);
	"C": EXITSELECT (R1_COMPLEX;R2_PLIT'OMPLEX');
	"L": EXITSELECT (R1_LOGICAL;R2_PLIT'OGICAL');
	"B": EXITSELECT (R1_7^5+BYTE;R2_PLIT'IT');
	"S": EXITSELECT IF SCAN(PLIT'UBSCRIPTINTEGER') LSS 0 THEN RETURN -1
		ELSE (IDTYPE_INDEX;RETURN);
	OTHERWISE: (QUEUE(); RETURN -1)
	TESN;
	IF SCAN(.R2) LSS 0 THEN RETURN -1;
	TYPE _ .R1;	!SET GLOBAL TYPE FOR USE IN ROUTINE LETTER
	SIGCHAR;	!GET NEXT SIGNIFICANT CHARACTER
	IF .C EQL "*" THEN
	BEGIN
		MACHOP MOVEI=#201;
		SIGCHAR;MOVEI(VREG,-"0",C);
		IF .VREG GTR 8 THEN RETURN -1;
		IF .VREG LEQ 0 THEN RETURN -1; !OUT OF RANGE
		R2 _ .VREG;
		TYPE _	SELECT .R1 OF NSET
			INTEGER:IF .R2 EQL 2 THEN RETURN -1
				ELSE IF .R2 EQL 4 THEN INTEGER
					ELSE RETURN -1;
			REAL:IF .R2 EQL 4 THEN REAL
				ELSE IF .R2 EQL 8 THEN DOUBLPREC
					ELSE RETURN -1;
			COMPLEX:IF .R2 EQL 8 THEN COMPLEX
				ELSE RETURN -1;
			LOGICAL:IF .R2 EQL 1 THEN RETURN -1
				ELSE IF .R2 EQL 4 THEN LOGICAL
					ELSE RETURN -1;
			BYTE:IF .R2 LEQ 36 THEN .R2^5+BYTE
				ELSE RETURN -1
			TESN
	END ELSE QUEUE(); !QUEUE IF NO "*"
	RETURN 0
END;
GLOBAL ROUTINE LETTER =
BEGIN
	LOCAL L1,L2;
	EXTERNAL TYPE,TYPTAB,WARNOUT;
	MACHOP MOVEI=#201;
	SIGCHAR;
	IF ALPHA(C) THEN L1 _ (-#101)[.C]<0,0>
		ELSE IF LCALPHA(C) THEN L1 _ (-#141)[.C]<0,0>
			ELSE RETURN -1;
	SIGCHAR; !LOOKING FOR X-Y CONSTRUCT
	IF .C EQL "-"
		THEN (SIGCHAR; !GET THE NEXT LETTER
			IF ALPHA(C) THEN L2 _ (-#101)[.C]<0,0>
			 ELSE IF LCALPHA(C) THEN L2 _ (-#141)[.C]<0,0>
			   ELSE RETURN -1;  !ERROR
		     )
		ELSE ( QUEUE();
			IF .TYPTAB[.L1]<LEFT> EQL #777777 THEN WARNOUT(88) ELSE TYPTAB[.L1]<LEFT> _ #777777;
			TYPTAB[.L1]<RIGHT> _ .TYPE; !SET IMPLICIT TYPE FOR IDENTIFIERS
			RETURN 0
		     );
	DO (TYPTAB[.L1]<RIGHT> _ .TYPE;  !SET IMPLICIT TYPE FOR RANGE OF LETTERS
		IF .TYPTAB[.L1]<LEFT> EQL #777777 THEN WARNOUT(88) ELSE TYPTAB[.L1]<LEFT> _ #777777;
	    L1 _ .L1+1;
	   ) WHILE .L1 LEQ .L2;
	VREG_0
END;
GLOBAL ROUTINE TOQUOTE =
BEGIN
	EXTERNAL SCAN;
	VREG_SCAN(PLIT'TO');
	.VREG
END;
GLOBAL ROUTINE ASTERSK =
BEGIN	!ACTION ROUTINE TO CHECK FOR IBM TYPE SPEC (*N)
	IF SIGCHAR NEQ "*" THEN (QUEUE(); VREG _ -1)
		ELSE VREG _ 0;
	.VREG
END;!OF ASTERSK
GLOBAL ROUTINE RECORDMARK =
BEGIN
	EXTERNAL LEXEMEGEN,ERROUT,STK,SP,QUEUE,EXPRESSION,LEXL,COPYLIST;
	EXTERNAL ENTRY;
	MACRO ERR0(X) = (ENTRY[1] _ X; RETURN ERROUT(0))$;
	IF .LEXL<LEFT> EQL IDENT
	THEN
	  BEGIN
		LOCAL LSP1;
		LSP1 _ .SP-1;	!SAVING SP
		IF SIGCHAR EQL "("
		THEN
		  BEGIN
			LOCAL LSP;
			STK[SP _ .SP+1] _ 1;	!ARRAY REF OPTION
			LSP _ .SP;	!SAVING
			WHILE 1 DO
			BEGIN
				LSAVE _ 0;	!SO EXPRESSION WILL GENERATE ITS OWN LEXEME
				IF  EXPRESSION() LSS 0
				THEN RETURN -1;
				!EXPRESSION WILL ALWAYS CREATE NEXT LEXEME
				IF .LEXL<LEFT> NEQ COMMA THEN EXITLOOP;
			END;
			IF .LEXL<LEFT> NEQ RPAREN THEN ERR0(PLIT'RPAREN');
			COPYLIST(.LSP); !PUT LIST IN FREE STORAGE
		  END
		ELSE (STK[SP _ .SP+1] _ 0; QUEUE());
		STK[SP _ .SP+1] _ 0;	!NO OPTIONAL BYTE SPEC
		COPYLIST(.LSP1);
	  END;
	IF SIGCHAR NEQ "'" THEN
		IF .C NEQ "#" THEN (QUEUE();RETURN VREG_-1);
	.VREG _ 0
END;
ROUTINE INTORL (VALUE) =
BEGIN
	EXTERNAL C1H,C1L,C2H,C2L,COPRIX,CNSTCM;
	C1L_@VALUE;C1H_C2H_C2L_0;
	COPRIX_INTEGER OR REAL^(-1);
	CNSTCM();RETURN .C2H
END;
GLOBAL ROUTINE LOCALARG=
BEGIN
%
	THIS ROUTINE PROCESSES THE LIST OF LOCAL ARGUMENTS FOR
	A STATEMENT FUNCTION. BOTH SYNTAX AND SEMANTICS PROCESSING
	IS PERFORMED ON THE THIS ARGUMENT  LIST.

	THE ROUTINE IS CALLED BY SYNTAX DURING PROCESSING OF A STATEMENT
	FUNCTION SPECIFICATION THRU THE USE OF THE ACTION CONSTRUCT
	IN THE SYNTAX DEFINITION OF STATEMENT FUNCTION

	THE ROUTINE PUTS A POINTER TO A LIST OF ARGUMENTS ON STK[.SP+1]
	AND RETRUNS A VALUE 0 IF SYNTAX AND SEMANTICS WERE CORRECT.
	IF ANY ERROR WAS DETECTED THEN A VALUE OF -1 IS RETURNED AND
	NO LIST POINTER IS PLACED ON STK.
%
	EXTERNAL SYNTAX,CHAR,QUEUE,COPYLIST,LEXL,LSAVE,SAVSPACE;
	EXTERNAL LEXNAME,CORMAN,STK,SP,ENTRY,ERROUT,LEXEMEGEN;
	MAP BASE T1:T2;
	MACRO ERR0(X)=( ENTRY[1]_.LEXNAME[.LEXL<LEFT>];
				ENTRY[2]_X;RETURN ERROUT(0))$;
	LOCAL LSP;
	LSP_.SP;	!SAVE STACK PTR
	DO
	BEGIN
		IF .LSAVE NEQ 0 THEN LSAVE _ 0 ELSE LEXL _ LEXEMEGEN();
		IF .LEXL<LEFT> NEQ IDENT
		  THEN ERR0(PLIT'IDENTIFIER?0');
		T2 _ .LEXL<RIGHT>;
		T2[IDATTRIBUT(SFDUMMY)] _ 1; !SET TO STATEMENT FUNCTION DUMMY
		STK[SP_.SP+1] _ .T2;
	END
	  WHILE (SIGCHAR; .C EQL ",");
	IF .C NEQ ")" THEN ERR0(LPAREN) ELSE QUEUE();
	COPYLIST(.LSP);
	.VREG
END;
GLOBAL ROUTINE EXPRLIST =
BEGIN
!------------------------------------------------------------------------------------------------------------------
!THE TOP TWO ELEMENTS OF THE LEXEME STACK ON ENTRY ARE THE OPTION
!(STK[.SP]= OPTION 1) AND THE LEXEME IDENTIFIER^18+LOC (STK[.SP-1]).
!A LIST OF EXPRESSIONS FOLLOWED BY A RIGHT PAREN IS  EXPECTED
!TO FOLLOW. THIS ROUTINE DETERMINES WHETHER OR NOT THE IDENTIFIER
!SHOULD BE FOLLOWED BY A SUBSCRIPT OR ARGUMENT LIST THEN SCANS THE
!SUBSCRIPT OR ARGUMENT LIST WITH THE APPROPRIATE FLAGS SET.
!IF THE IDENTIFIER IS A FUNCTION NAME THEN THE FELFLG IS SET TO INDICATE
!THAT A FUNCTION NAME WITHOUT AN ARGUMENT LIST OR AN ARRAY NAME WITHOUT
!A SUBSCRIPT LIST IS A LEGAL ARGUMENT .
!------------------------------------------------------------------------------------------------------------------
	LOCAL META,LSP;
	EXTERNAL EXPRES,STK,SP,SYNTAX %(NODE)%,LSAVE,LEXEMEGEN %()%,LEXL,COPYLIST %(START)%;
	MAP BASE T1;MACRO COMMA=8$;
	T1_.STK[.SP-1];	!T1_LOC(IDENTIFIER)
	ENTRY[1]_T1[IDSYMBOL];
	IF .T1[IDATTRIBUT(NAMNAM)] NEQ 0 THEN RETURN ERROUT(E6);	!NAMELIST NAME
	IF NOT .T1[PARENLSTFLG] THEN	!NOT AN ARRAY OR FUNCTION
		IF ISDEFIND(T1) THEN RETURN (ENTRY[2] _ PLIT'SCALAR';ERROUT(34))	!BUT DEFINED, ERROR
			ELSE IF .T1[FORMLFLG] THEN T1[OPERSP] _ FORMLFN
				ELSE T1[OPERSP] _ FNNAME;
	IF .T1[OPERSP] GEQ FNNAME THEN (META_ACTUALARG;)
		ELSE (META_0);
!------------------------------------------------------------------------------------------------------------------
!	NOW SCAN THE LIST OF EXPRESSIONS (ONE OR MORE SEPERATED BY COMMAS)
!	WHICH MUST FOLLOW.
!------------------------------------------------------------------------------------------------------------------
	LSP_.SP;
	LSAVE_-1;
	WHILE 1 DO
	BEGIN
		LEXL_LEXEMEGEN();
		IF .META NEQ 0  THEN FLGREG<FELFLG>_1;
		IF (.LEXL<LEFT> NEQ DOLLAR) AND (.LEXL<LEFT> NEQ ASTERISK)
		THEN (STK[SP_.SP+1]_1; !EXPRESSION
			IF EXPRES() LSS 0 THEN RETURN;
			!EXPRES PUTS ITS RESULT  ON STK[SP_.SP+1] AND RETURNS NEXT LEX IN LEXL
		     )
		ELSE (STK[SP_.SP+1] _ 2; !LABEL ARG
			STK[SP_.SP+1]_LEXEMEGEN();
			LEXL _ LEXEMEGEN();
		     );
		IF .LEXL<LEFT> NEQ COMMA THEN  EXITLOOP;
	END;
	LSAVE _ -1;
	COPYLIST(.LSP);
	RETURN 0
END;
GLOBAL ROUTINE MULTIASGN =
BEGIN
	MAP BASE T1:T2;REGISTER BASE R1:R2;
	EXTERNAL NEWENTRY %()%,SAVSPACE %(SIZE,LOC)%,STK,ASGNTYPER,LABLOFSTATEMENT;
	EXTERNAL DOINDEX,WARNOUT;	!PTR TO CURRENT DO INDEX ACTIVE
	MACRO
	ELMNT=0,0,FULL$,ELMNT1=0,1,FULL$,ELMNT2=0,2,FULL$,EXPRBASE=1,0,FULL$;
	BIND SRCEXPR=STK[1],LSTBASE=STK[2],SRCVAL=STK[3],LASTLH=STK[4];
	T1 _ .STK[0];
	!RESULT OF PARSE IN T1
	IF .T1[ELMNT1] NEQ 0 THEN
	BEGIN
		R1_.T1[ELMNT2];SAVSPACE(.R1<LEFT>,.R1);
		ENTRY[0]_.ISN;ERROUT(E39);T1_.T1+1
	END;
	LASTLH_@T2;T1_LSTBASE_.T1[ELMNT2];	!T1_LOC(LOGICAL EXPRESSION LIST)
	!IF LEFT HALF OF T1 IS NON ZERO THEN MULTIPLE ASSIGNMENT
	IF .T1<LEFT> NEQ 0 THEN RETURN ERROUT(86); !MULTIPLE ASSIGNMENT NOT SUPPORTED
	R1_@T1+.T1<LEFT>;
	NAME_IDOFSTATEMENT_ASGNDATA;NAME<RIGHT>_SORTAB;
	R2_.R1[ELMNT];SRCEXPR_T2_.R2[ELMNT];SAVSPACE(.R2<LEFT>,.R2);
	INCR LST FROM @T1 TO @R1-1 DO
	BEGIN
		MAP BASE LST;
		R1_.LST[ELMNT];R2_.R1[ELMNT];	!R1_LIST POINTER,R2_VARIABLESPEC
		SAVSPACE(0,.R1);
		IF .R2<RIGHT> EQL .DOINDEX<RIGHT> THEN WARNOUT(77); !DO INDEX REASSIGNED INSIDE DO
		IF .R2[OPRCLS] NEQ ARRAYREF THEN
			IF .R2[OPRCLS] NEQ DATAOPR THEN
				(ENTRY[0]_@ISN;RETURN ERROUT(E16))
				ELSE
					IF .R2[OPERSP] GTR FORMLVAR THEN
						(ENTRY[0]_@ISN;RETURN ERROUT(E16));
		NAME_IDOFSTATEMENT_ASGNDATA;NAME<RIGHT>_SORTAB;
		R1_NEWENTRY();R1[LHEXP]_@R2;
		LABLOFSTATEMENT _ 0;	!ZERO ANY STATEMENT LABEL FOR MULTIPLE ASSIGNMENTS
		R1[RHEXP]_@SRCEXPR;
		ASGNTYPER(.R1); !CHECK FOR ASSIGNMENT CONVERSION
		NAME_IDOFSTATEMENT_ASGNDATA;NAME<RIGHT>_SORTAB; !RESETING NAME INCASE OF CHANGE BY ASGNTYPER
		R2 _ .R1[LHEXP]; !RESTORING THE RH EXPR PTR IN CASE OF TYPE CONVERSION INSERTED
		IF .R2[OPRCLS] EQL DATAOPR THEN R1[A1VALFLG]_1
			 ELSE (R2[PARENT] _ .R1; IF .R2[FNCALLSFLG] THEN R1[FNCALLSFLG] _ 1;);

		R2 _ .R1[RHEXP]; !RESTORE RH EXP PTR
		IF .R2[OPRCLS] EQL DATAOPR  THEN R1[A2VALFLG]_1
			 ELSE ( R2[PARENT] _ .R1; IF .R2[FNCALLSFLG] THEN R1[FNCALLSFLG] _1);
	END;
	R1_NEWENTRY();R1[LHEXP]_R2_.LASTLH;R1[RHEXP]_.SRCEXPR;
	IF .R2<RIGHT> EQL .DOINDEX<RIGHT> THEN WARNOUT(77);	!DO INDEX USED IN ASSIGNMENT
	ASGNTYPER(.R1);	!CHECKING FOR ASSIGNMENT CONVERSION
	R2 _ .R1[LHEXP]; !RESTORING EXP PTR INCASE OF TYPE CONVERSION NODE INSERTED
	IF .R2[OPRCLS] EQL DATAOPR THEN R1[A1VALFLG]_1 ELSE R2[PARENT] _ .R1;
	R2 _ .R1[RHEXP]; !RESTORE RH EXP PTR
	IF .R2[OPRCLS] EQL DATAOPR  THEN R1[A2VALFLG]_1
		 ELSE ( R2[PARENT] _ .R1; IF .R2[FNCALLSFLG] THEN R1[FNCALLSFLG] _1);
	SAVSPACE(.LSTBASE<LEFT>,@LSTBASE);SAVSPACE(.STK[0]<LEFT>,@STK[0])
END;
END ELUDOM
    