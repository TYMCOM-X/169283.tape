DEF S.LEN(PTR) AS (^(PTR) BAND OCT 77)
DEF S.VBT(PTR) AS ^((PTR)+1)
DEF S.LOC(PTR) AS HW((PTR)+2,1)
  DEF S.SCAP(PTR) AS HW(S.LOC(PTR))
  DEF S.SLOC(PTR) AS HW(S.LOC(PTR),1)
  DEF S.DLOC(PTR) AS HW(S.LOC(PTR),1)   !DUMMY ARRAY BASE
DEF S.NAM(PTR) AS ^((PTR)+3)
DEF S.SNUM(PTR) AS HW((PTR)+1)
DEF INIT.S.MUL(PTR) AS S.MULP _ HWPT((PTR)+4,-1)
DEF NX.S.MUL AS NHWV S.MULP   !FOR I=1 TO S.SNUM(PTR)
DEF S.SIZ(PTR) AS HW((PTR)+3)
LOCAL %S.OFF, S.MULP

!  ERROR MESSAGES

TABLE NOCONT   ['NOT CONTINUABLE']
TABLE BDCONS   ['ILLEGAL CONSTANT']
TABLE BDCPLX   ['COMPLEX MUST BE ENTERED AS (REAL, IMAG)']

! SYMBOL ERRORS:
TABLE UNDEFS   ['UNDEFINED']
TABLE NOTARY   ['NOT AN ARRAY']
TABLE ISARY    ['IS AN ARRAY']
TABLE BADINT   ['NOT INTEGER']
TABLE SUBCNT   ['WRONG NUMBER OF SUBSCRIPTS']
TABLE BOUNDS   ['SUBSCRIPT OUT OF BOUNDS']
TABLE DIMLIT   ['DIMENSIONS EXCEED LIMIT OF 10']
TABLE BDMTCH   ['TYPE DOES NOT MATCH']

TABLE ASSIGN   ['ASSIGNMENTS DONE']
TABLE NOXRNG   ['NO EXECUTABLE OR FORMAT STATEMENT IN ']

DEF SXPT(ADR) AS [6,6,24]*[36,6,ADR]

DEF AC.TRCBIT AS 1
DEF AC.BRKBIT AS 2
DEF TRCBIT AS (AC.TRCBIT SHL 23)
DEF BRKBIT AS (AC.BRKBIT SHL 23)
DEF BRKSTR AS 'BREAK '
DEF TRCSTR AS 'TRACE '

DEF SUBSMAX AS 10   !?
LOCAL SUBS(SUBSMAX)
LOCAL  LTTYLEN
LOCAL CONT.OK		! CONTINUE ALLOWED FLAG
LOCAL INITFG
LOCAL SETFG   !SPECIAL PRINTOUT FOR SET COMMAND ERRORS

!  MACHINE/IMPLEMENTATION DEPENDENT I/O DATA

LOCAL FREEPTR                !PTR TO BEGINNING OF FREE BUFFER
LOCAL IMGPTR

! USED IN COMMAND PROCESSING (NOT SAVED BETWEEN COMMANDS):

LOCAL LPTR                   !INPUT LINE STRING POINTER
LOCAL EL(4), ELID(4), ELP    !COMMAND LINE ELEMENTS, ELEMENT IDS
DEF SELLIM AS GLBSZ
LOCAL SEL(-1:SELLIM)         !SUBELEMENTS (LINE LIST & RANGE)
DEF LTBL(X) AS SEL((X)-2)    !LINE LIST NOS. & COUNTS
LOCAL SELP                   !SEL PTR
LOCAL LSTCNT	!NO. LINES SPECIFIED IN LINE LIST
DEF ELW(X,Y) AS [EL(INC ELP)_(Y); EL.ID(ELP)_(X)]

!  COMMAND WORDS

DEF K.ABT  AS 1
DEF K.BRK  AS 2
DEF K.CAN  AS 3
DEF K.CHNG AS 4
DEF K.CLS  AS 5
DEF K.COMP AS 6
DEF K.CONT AS 7
DEF K.CRE  AS 8
DEF K.DEB  AS 9
DEF K.DISP AS 10
DEF K.DO   AS 11
DEF K.GO   AS 12
DEF K.HUSH AS 13
DEF K.INIT AS 14
DEF K.LIST AS 15
DEF K.MODE AS 16
DEF K.NEXT AS 17
DEF K.NO   AS 18
DEF K.PROD AS 19
DEF K.QUIT AS 20
DEF K.RUN  AS 21
DEF K.SET  AS 22
DEF K.STEP AS 23
DEF K.TOUT AS 24
DEF K.TRC  AS 25
DEF K.VAL  AS 26
DEF CWDCNT AS K.VAL
DEF K.NOPT(N) AS (K.VAL+N)
DEF K.NBRK AS K.NOPT(1)
DEF K.NHSH AS K.NOPT(2)
DEF K.NTRC AS K.NOPT(3)
DEF K.NVAL AS K.NOPT(4)
DEF NWDCNT AS 4
DEF K.LOPT(N) AS (K.NVAL+N)
DEF K.LBRK AS K.LOPT(1)
DEF K.LDEB AS K.LOPT(2)
DEF K.LTRC AS K.LOPT(3)
DEF K.LVAL AS K.LOPT(4)
DEF K.LVER AS K.LOPT(5)
DEF LWDCNT AS 5
DEF K.VOPT(N) AS (K.LVER+N)
DEF K.VBRK AS K.VOPT(1)
DEF K.VTRC AS K.VOPT(2)
DEF VWDCNT AS 2
DEF K.NVOPT(N) AS (K.VTRC+N)
DEF K.NVBK AS K.NVOPT(1)
DEF K.NVTC AS K.NVOPT(2)
DEF K.LVOPT(N) AS (K.NVTC+N)
DEF K.LVBK AS K.LVOPT(1)
DEF K.LVTC AS K.LVOPT(2)
DEF K.POPT(N) AS (K.LVTC+N)
DEF K.PINI AS K.POPT(1)
DEF K.PRUN AS K.POPT(2)
DEF PWDCNT AS 2
DEF CMDCNT AS K.PRUN   !FOR CASE STATEMENT

TABLE CWD(CWDCNT+1)[ &
 "ABORT", &
 "BREAK", &
 "CANCEL", &
 "CHANGE", &
 "CLOSE", &
 "COMPILE", &
 "CONTINUE", &
 "CREATE", &
 "DEBUG", &
 "DISPLAY", &
 "DO", &
 "GO", &
 "HUSH", &
 "INITIALIZE", &
 "LIST", &
 "MODE", &
 "NEXT", &
 "NO", &
 "PRODUCTION", &
 "QUIT", &
 "RUN", &
 "SET", &
 "STEP", &
 "TOUT", &
 "TRACE", &
 "VALUE", &
 ND.STR]
DEF CLMAX AS 10     !COMMAND WORD LENGTH MAX

! CMD ARRAY USED ONLY IN GENERATION OF COMMAND MODELS
! NULL ENTRIES: AFTER GETCOM, DB.CNUM WILL NEVER HAVE CORRESPONDING VALUE
TABLE CMD(CWDCNT+1:CMDCNT)[ &
 "NO BREAK", &
 "NO HUSH", &
 "NO TRACE", &
 "NO VALUE", &
 "LIST BREAK", &
 "LIST TRACE", &
 "LIST VALUE", &
 "LIST VERSION", &
 "VALUE BREAK", &
 "VALUE TRACE", &
 "NO VALUE BREAK", &
 "NO VALUE TRACE", &
 "LIST VALUE BREAK", &
 "LIST VALUE TRACE", &
 "PRODUCTION INITIALIZE", &
 "PRODUCTION RUN"]

TABLE LWD(LWDCNT+1)[ &
 "BREAK", &
 "DEBUG", &
 "TRACE", &
 "VALUE", &
 "VERSION", &
 ND.STR]
DEF LLMAX AS 7  !LIST COMMAND WORD LENGTH MAX

TABLE NWD(NWDCNT+1)[ &
 "BREAK", &
 "TRACE", &
 "VALUE", &
 ND.STR]
DEF NLMAX AS 5  !NO COMMAND WORD LENGTH MAX

TABLE VWD(VWDCNT+1)[ &
 "BREAK", &
 "TRACE", &
 ND.STR]
DEF VLMAX AS 5  !VALUE COMMAND WORD LENGTH MAX

TABLE PWD(PWDCNT+1)[ &
 "INITIALIZE", &
 "RUN", &
 ND.STR]
DEF PLMAX AS 10 !PRODUCTION COMMAND WORD LENGTH MAX

!  COMMAND LINE ELEMENT IDENTIFIERS

DEF FID.ID AS 1              !FILE IDENTIFIER INDEX
DEF LST.ID AS 2              !LINE LIST
DEF ADR.ID AS 3              !LINE ADDRESS
DEF NAM.ID AS 4              !IDENTIFIER
DEF INT.ID AS 5              !POSITIVE INTEGER

!  ERROR MESSAGES TO USER OF CCS

TABLE LNLONG       ['LINE TOO LONG']
TABLE BDLRNG       ['ILLEGAL LINE RANGE']
TABLE NOCORE       ['NOT ENOUGH CORE']
TABLE NOTIMP       ['NOT IMPLEMENTED']
TABLE BDCMND       ['NO SUCH COMMAND']
TABLE AMBGCM       ['AMBIGUOUS ABBREVIATION, TYPE MORE CHARACTERS']
TABLE LSTLNG       ['LINE LIST TOO LONG']
TABLE NOPROG       ['NO PROGRAM']

!FILE OPEN ERRORS
TABLE FILERR(IFDERR:FBSERR)[ &
 'ILLEGAL FILE IDENTIFIER', &
 '$NEW/OLD FILE MESSAGE NOT CONFIRMED', &
 'FILE NOT FOUND', 'INVALID USER NAME', &
 'PROTECTION VIOLATION ATTEMPT', 'FILE BUSY']


!  OF GENERAL INTEREST:

DEF UPALPH(X) AS ($A<=X<=$Z)
DEF LWALPH(X) AS ($A+LWUPDIF <= X <= $Z+LWUPDIF)
DEF XLWUP(X) AS X _ X-LWUPDIF   !TRANSFORM X FROM LWR TO UPR CASE
DEF NUM(X) AS ($0<=X<=$9)

DEF DGMAX AS (I.DGMAX+D.DGMAX) !MAX. TOTAL LINE KEY DIGITS
TABLE PWR10(0:DGMAX) [1,10,100,1000,10000,100000,1000000,10000000, &
   100000000]

DEF SGNBIT AS (1 ROTR 1)
DEF BPW AS BITS.PER.WORD
DEF BPC AS (BPW/CPW)

DEF YES AS 1
DEF NO  AS 0


FIND ALT.NAME(".JBVER",JOBVER)

%RUNCTL

!  COMMAND MODELS

LOCAL CMDL(CMDCNT)
CMDL(K.ABT) _ CMDL(K.QUIT) _ CMDL(K.HUSH) _ CMDL(K.NHSH) _ &
  CMDL(K.CONT) _ CMDL(K.LDEB) _ CMDL(K.LVER) _ ''
CMDL(K.GO) _ '[ <LINE> ]'
CMDL(K.CRE) _ CMDL(K.DO) _ CMDL(K.TOUT) _ '<FILE>'
CMDL(K.BRK) _ CMDL(K.TRC) _ '<LINES> [ <VARIABLES> ] [ @ <INTEGER> ]'
CMDL(K.NBRK) _ CMDL(K.NTRC) _ CMDL(K.LBRK) _ CMDL(K.LTRC) _ '[ <LINES> ]'
CMDL(K.DISP) _ '<VARIABLES>'
CMDL(K.SET) _ '<VARIABLE> = <VARIABLE OR CONSTANT> [ ,<ETC> ]'
CMDL(K.CHNG) _ '[ <FILES> ]'
CMDL(K.CAN) _ CMDL(K.CLS) _ '[ <UNITS> ]'
CMDL(K.COMP) _ CMDL(K.INIT) _ CMDL(K.RUN) _ CMDL(K.PINI) _ &
 CMDL(K.PRUN) _ '[ <LOAD STRING> ]'
CMDL(K.DEB) _ '[ <LINE> OR: <SUBROUTINE OR FUNCTION NAME> ]'
CMDL(K.MODE) _ '<ASCII, OCTAL OR DECLARED> <VARIABLES>'
CMDL(K.NEXT) _ CMDL(K.STEP) _ '[ <INTEGER> ]'
CMDL(K.NVBK) _ CMDL(K.NVTC) _ CMDL(K.LVBK) _ CMDL(K.LVTC) _ '[ <VARIABLES> ]'
CMDL(K.VBRK) _ CMDL(K.VTRC) _ '<VARIABLES> [ <LINES> ]'

LOCAL ALT:

INIT.DB ! INITIALIZE DEBUG TABLES
FREEPTR _ CHPT(FREE,-1); IMGPTR _ CHPT(IMAGE,-1)
CFN _ TEL
ALTLOC _ ALT
IF SFOIN THEN GETCOM
RETURN

%PCMDL

MSG("$SHOULD BE:$"); PRINT(IF DB.CNUM<=CWDCNT THEN CWD(DB.CNUM) ELSE CMD(DB.CNUM))
PUT($ ); MSG(CMDL(DB.CNUM)); RETURN

END PCMDL


%GETCOM
! GET COMMAND LINE.  EXECUTE COMMANDS.

LOCAL %CSCAN, %COMMAND
LOCAL ERRA:, INLA:, NCOM:

OFINT
NCOM:   SETRWP(0,%RWERR) ; LTTYLEN _ TTYLEN; SETPRMPT(%PRMPT)

LOOP DO

INLA:   LPTR _ GETLINE(CFN)
        WHILE NOT FCR THEN DO
           DB.CNUM _ COMMAND(CWD,ERRA)
           CSCAN; WHILE DEXU; INC DB.INTNO
        END

END
RETURN

ALT:    OFFALT; CLOBUF; CLIBUF; PUT(CARRET)
        IF CFN#TEL THEN [MSG('ABORTED$'); CFNCLS]
        GO NCOM

ERRA:  CERR(BDCMND)

CFNEOF:  OFFALT; LNGCHK; CFNCLS; FN _ TEL; ONALT.C; GO INLA


%CSCAN

        CSCAN.INIT
	DO DB.CNUM OF CWDCNT

K.DO:	FFID(OCT 435544.000000)   !.CMD

K.NEXT: K.STEP:	IF NOT FINT THEN ELW(INT.ID,1)

K.GO:  F.ADR

K.BRK: K.TRC:	IF NOT FLST THEN GO EROUT

K.CAN: K.CLS:	DERR(NOTIMP)

K.CHNG: K.CRE:	RETURN

K.COMP: K.INIT: K.RUN:	RETURN

K.DEB:	IF NOT(FADR OR FNAME) THEN ELW(NAM.ID,MAIN)

K.LIST: DO DB.CNUM _ K.LOPT(COMMAND(LWD,ERRA)) OF K.LOPT(1):K.LOPT(LWDCNT)

	K.LBRK: K.LTRC:	FLST

        K.LVAL: DB.CNUM _ K.LVOPT(COMMAND(VWD,ERRA))
                DERR(NOTIMP)

        END ! LIST OPTIONS

K.MODE: DERR(NOTIMP)

K.NO:   DO DB.CNUM _ K.NOPT(COMMAND(NWD,ERRA)) OF K.NOPT(1):K.NOPT(NWDCNT)
        K.NBRK: K.NTRC: F.LST

        K.NVAL: DB.CNUM _ K.NVOPT(COMMAND(VWD,ERRA))
                DERR(NOTIMP)

        END ! NO OPTIONS

K.TOUT: DERR(NOTIMP)

K.VAL:  DB.CNUM _ K.VOPT(COMMAND(VWD,ERRA))
        DERR(NOTIMP)

K.PROD: DB.CNUM _ K.POPT(COMMAND(PWD,ERRA))
        RETURN

K.DISP: K.SET:	RETURN
   

	END

        IF NOT FCR THEN DPERR(%PCMDL); RETURN

EROUT:  IF FCR THEN DPERR(%PCMDL) ELSE DERR(BDLRNG)

END CSCAN

%COMMAND(LIST(),ERR:)
LOCAL CMD
IF NOT ALPH(LASTCH) THEN GO ERR
WDSTOR(CLMAX,ERR)
CMD _ CMDREC(LIST,ERR)
NXNSP ; BACKSP
RETURN CMD
END COMMAND

%CPERR (%MSGPROC)

ONALT.C
CLIBUF; MSGPROC
GO BELOW

%%CERR (N)

!  HANDLES INPUT ERRORS WHICH IF CFN WAS NOT TEL, ABORTS CFN INPUT

         ONALT.C
         CLIBUF; MSG(N)
BELOW:   PUT(CARRET); IF CFN#TEL THEN PRINT(FREE)
         OFFALT; CFNCLS; GO INLA

END CPERR


END GETCOM


%LNGCHK
IF ERRNUM=LNGERR THEN CERR(LNLONG); RETURN
END LNGCHK


%CFNCLS
CLOSE(CFN <== TEL); RETURN
END CFNCLS


%PRMPT

PUT($:); PUT($ ); RETURN

END PRMPT


%NXNSP

! STORES IN LASTCH & RETURNS NEXT NON-BLANK

WHILE SPCH(NXCHAR) THEN NULL; RETURN LASTCH

END NXNSP


%BACKSP

PCHV LPTR; RETURN

END BACKSP


%WDSTOR (LMAX, LAB:)

!  NEXT CHAR IS ALPHABETIC.  STORES CHARS UP TO NEXT NON-ALPHA
!  IN INWD ARRAY; LPTR UPON RETURN IS BEFORE WD TERMINATOR.
!  GOES TO LAB IF NO. OF ALPHA CHARS EXCEEDS LMAX.
!  CONVERTS LOWER CASE ALPHA TO UPPER CASE.

DEF INWDSZ AS (CLMAX+CPW-1)/CPW
LOCAL INWD(0:INWDSZ-1)       !MUST HOLD CLMAX CHARS
LOCAL PTR,CNT

       MOVE INWDSZ FROM ALL EOLITWD TO INWD
       PTR _ CHPT(INWD,CNT _ -1)
       WHILE INC CNT<=LMAX THEN DO
         IF NOT UPALPH(NXCHAR) THEN DO
           IF LWALPH(LASTCH) THEN XLWUP(LASTCH) ELSE [BACKSP; RETURN]
         END
         NCHV PTR _ LASTCH
       END
       GO LAB


%CMDREC (WD(), LAB:)

! WORD RECOGNITION

!  WORD IS AT ADDR INWD, NO. OF CHARS IS IN CNT.
!  IF RECOGNIZES WORD AS WD(I), RETURNS I.
!  ALLOWS SHORTEST UNIQUE ABBREVIATION.
!  GOES TO LAB IF NO MATCH.
!  IF COMMAND LOOKUP (CWD ARRAY), MAY BE AMBIGUITY, IN WHICH CASE
!  ERR EXIT IS TAKEN.

LOCAL %COMPARE
LOCAL W, SAVE, TEMP, PTR

       [W;CNT] _ CNT DIVMOD CPW
       PTR _ 0
       WHILE INWD(0) # ^WD(INC PTR) THEN DO
         IF LESSTR(INWD(0),^WD(PTR)) THEN GO NXT
       END
! INWD(0) <= ^WD(PTR)
NXT:   DO COMPARE OF -1:1
-1:      GO LAB                !<, NO MATCH
1:       INC PTR; GO NXT       !>, ONLY 1ST WD MATCH, CONTINUE
0:       SAVE _ PTR; INC PTR   !=, MATCH
         DO COMPARE OF -1:1    !AMBIGUITY CHECK
 -1: 1:    RETURN SAVE         !<, NO AMBIGUITY
  0:       CERR(AMBGCM)
         END
       END

%COMPARE

! COMPARES INWD TO COMMAND AT WD(PTR), UP TO END OF INWD.
! RETURNS -1, 0 OR 1, IF <, = OR >, RESPECTIVELY.

LOCAL J, I

       I _ TEMP _ -1
       WHILE INC I<W THEN DO
CA:      J _ ^(WD(PTR)+I) BAND TEMP
         IF INWD(I)#J THEN DO
           RETURN IF LESSTR(INWD(I),J) THEN -1 ELSE 1
         END
       END
       IF TEMP=-1 THEN [TEMP _ TEMP SHL (BPW-BPC*CNT); GO CA]
       RETURN 0

END COMPARE

END CMDREC


%WDREC (WD(), LAB:)

!  SIMILAR TO CMDREC BUT ALLOWS NO ABBREVIATION.

LOCAL PTR, I

PTR _ 0
LOOP DO
  IF I _ ^WD(INC PTR) =^ND.STR THEN GO LAB
  WHILE INWD(0)#I
END
I _ 0
WHILE INC I <= (CNT-1)/CPW THEN DO  !REMAINING WDS OF STRING
  IF INWD(I)#^(WD(PTR)+I) THEN GO LAB
END
RETURN PTR

END WDREC

END WDSTOR


%CSCAN.INIT

LOCAL FIDPTR
LOCAL FIDTBL(0:2*WPF-1)

MOVE 4 FROM ALL 0 TO ELID+1; SELP _ ELP _ 0
FIDPTR _ FIDTBL-WPF; RETURN


%FCR

LOCAL TEMP

TEMP _ [NXNSP=CARRET]; BACKSP; RETURN TEMP

END FCR


%FFID (EXTDEF)

!  SCANS FOR FILE IDENTIFIER (FID) TERMINATED BY BLANK OR CR.
!  CALLED WHEN NO ALTERNATIVE TO FID, SO TAKES ERROR EXIT IF FAILS.
!  STORES FID INFO WITH SETFID; IF OK, STORES FID.ID & ARG TO BE 
!  USED IN OPEN CALL.

LOCAL EROUT:

         IF FCR THEN CPERR(%PCMDL)
         SETFID(FIDPTR +_ WPF, @LPTR, EXTDEF, EROUT)
         ELW(FID.ID,-FIDPTR); RETURN

EROUT:   CERR(FILERR(IFDERR))

END FFID


%FADR

!  SCANS FOR CONSTRUCTION SPECIFIED AT ENTRY POINT.
!
!  ADR      LKEY  OR  $  OR  .  OR  #INT  OR  ADR+INT  OR  ADR-INT
!           (LKEY FORM IS 0 TO I.DGMAX DIGITS, OPTIONAL 0 TO D.DGMAX
!           DECIMAL DIGITS WITH >0 DIGITS IN ALL)
!  LST      ADR[:ADR],...,ADR[:ADR]  OR  ALL
!
!  IF SUCCESSFUL, STORES APPROPRIATE EL.ID AND, IN EL ARRAY,
!     ADR OF WD BEFORE 1ST WD OF SUBELEMENT LIST
!                    (SEE %FRNGL)
!
!  RETURNS 1, WITH LPTR BEFORE CONSTRUCTION TERMINATOR.
!  IF NOT SUCCESSFUL, RESETS LPTR AND RETURNS 0.
!
!  LOW-ORDER BITS OF LFGS REPRESENT STATES AS FOLLOWS:
!
!            ADR     LST
!     :    + OR -     $
!     #     DIGIT     .
!
!  THUS:

DEF DOTB  AS 1
DEF DGTB  AS (1 SHL 1)
DEF NUMB  AS (1 SHL 2)
DEF DLRB  AS (1 SHL 3)
DEF SGNB  AS (1 SHL 4)
DEF CLNB  AS (1 SHL 5)
DEF LSTB  AS (1 SHL 6)
DEF ADRB  AS (1 SHL 7)

LOCAL %FRNGL
LOCAL LFGS

         LFGS _ ADRB; ELW(ADR.ID,FRNGL); RETURN YES


%%FLST

         LFGS _ LSTB
         ELW(LST.ID,FRNGL); RETURN YES


LAB:    RETURN NO


%FRNGL

!    TERMINATES ON ANY SYMBOL NOT : + - $ # DIGIT .
!    STORES SUBELEMENTS IN SEL ARRAY (1 PER WD) & RETURNS ADR OF
!    WD BEFORE 1ST WD OF LIST.  SUBELEMENTS INCLUDE ANY SPECIAL
!    SYMBOL & (NEGATIVE OF) ANY NUMBER READ (LKEY STORED AS INTEGER).
!    LIST TERMINATED BY 0.
!    SPECIAL CASE FOR LSTB: 'ALL' INDICATES ALL LINES, RETURNS 0

LOCAL %SVNUM, %SELW
LOCAL LVAL, TEMP, PTR, CNT
TABLE ALLWD(2)['ALL', ND.STR]

! EXTRACTION OF TYPE BIT:
DEF TYPB AS (LFGS BAND (ADRB+LSTB))

! CHECK FOR ILLEGAL STATES:
DEF NG(X) AS IF LFGS BAND (X) THEN GO OUT

         TEMP _ LPTR
         IF NXNSP=CARRET THEN GO OUT
         PTR _ SELP
         CNT _ I.DGMAX; LVAL _ 0    !LVAL RESET IN SVNUM

       LOOP DO
         EIF NUM(LASTCH) THEN DO
           NG(DLRB)
           LVAL _ LVAL*10+LASTCH-$0
! DON'T DEC CNT IF LEADING INTEGER ZERO
           IF NOT(LVAL=0=LFGS BAND DOTB) THEN IF DEC CNT<0 THEN GO OUT
           LFGS BOR_ DGTB
         END

         ORIF LASTCH=$. THEN DO
           NG(SGNB+DLRB+NUMB+DOTB)
           LFGS BOR_ DOTB
           CNT _ D.DGMAX
         END

         ELSE DO
           EIF LASTCH=$: THEN DO
             NG(ADRB+CLNB)
             SVNUM; LFGS _ TYPB BOR CLNB
           END

           ORIF LASTCH=$+ OR LASTCH=$- THEN DO
             NG(SGNB)
             SVNUM; LFGS _ TYPB BOR (LFGS BAND CLNB) BOR SGNB
           END

           ORIF LASTCH=$$ OR LASTCH=$# THEN DO
             NG(BNOT(ADRB+LSTB+CLNB))
             LFGS BOR_ IF LASTCH=$$ THEN DLRB ELSE NUMB
           END

           ORIF LASTCH=$, THEN DO
             NG(ADRB) 
             SVNUM; LFGS _ TYPB
           END

           ELSE GO ENDCH

           SELW(LASTCH); CNT _ I.DGMAX

         END

         NXCHAR
       END

ENDCH:   SVNUM; SELW(0); BACKSP; RETURN @SEL(PTR)

OUT:     LPTR _ TEMP
        IF (LFGS<==0) BAND LSTB=0 THEN GO LAB
        NXNSP; BACKSP; WDSTOR(3,OUT)  !LEAVES LPTR BEFORE TERM
        WDREC(ALLWD,OUT) ; RETURN


%SELW (X)

!  SUBELEMENT WRITE WITH OVERFLOW CHECK

IF INC SELP>SELLIM THEN CERR(LSTLNG)
SEL(SELP) _ X; RETURN

END SELW


%SVNUM

!  CALLED AT : + - , (BEFORE SETTING STATE BIT) AND AT
!  TERMINATOR, TO STORE NEGATIVE OF LKEY/INTEGER PRECEDING, IF ANY.  
!  %FRNGL ACCUMULATED NUMBER IN LVAL, WITH LKEY DOT IGNORED
!  AND NO. OF DIGITS PAST DOT = 3-CNT.
!  MAY BE $ OR CURRENT LINE DOT;  IN ANY OTHER
!  CASE, ABSENCE OF DIGIT IS ILLEGAL.
!  0 ILLEGAL EXCEPT AFTER SIGN.

         IF LFGS BAND DLRB THEN RETURN  !PREVIOUSLY DISALLOWED $DIGIT
         IF LFGS BAND DGTB=0 THEN DO
           IF LFGS BAND DOTB THEN [SELW($.); RETURN]
           GO OUT
         END
         IF LVAL=0 AND LFGS BAND SGNB=0 THEN GO OUT
         SELW ((LVAL<==0) * (IF LFGS BAND (SGNB+NUMB) THEN 1 ELSE &
           IF LFGS BAND DOTB THEN PWR10(CNT) ELSE PWR10(DDGMAX))*-1)
         RETURN

END SVNUM

END FRNGL

END FADR

%FINT
LOCAL VAL
IF GET.PINT(VAL) THEN [ELW(INT.ID,VAL) ; RETURN YES]
RETURN NO
END FINT

%FNAME
LOCAL NAME
IF GET.NAME(NAME) THEN [ELW(NAM.ID,NAME) ; RETURN YES]
RETURN NO
END FNAME

END CSCAN.INIT



%PRGCHK
IF DB.NLINES=0 THEN CERR(NOPROG); RETURN
END PRGCHK



%INLIST (I)

!  IF NO PROGRAM, ERROR.
!  I IS INDEX INTO EL.ID & EL ARRAYS FOR LINE LIST INFO.
! EL.ID(I) IS LST.ID OR 0: IF LST.ID, EL(I) IS
!  ADDRESS OF WD BEFORE 1ST WD OF SUBELEMENT LIST; IF 0, OR
!  IF EL.ID(I) IS 0, INDICATES DEFAULT LIST OF #1:$.
!  CALCULATES AND STORES LIST PARAMETERS AS FOLLOWS:
!    LSTCNT    TOTAL NO. OF LINES SPECIFIED
!    LTBL(1)   LINE NO. OF 1ST LINE OF 1ST SUBRANGE (LIST CONSTRUCTION
!              IS SUBRANGES SEPARATED BY COMMAS)
!    LTBL(2)   NO. OF LINES IN THIS SUBRANGE (>=0)
!    LTBL(3)   LINE NO. OF 2ND SUBRANGE (IF ANY)
!    ETC.
!  RETURNS NO. OF SUBRANGES READ.

DEF RNGMX AS 10  !MAX NO. OF SUBRANGES IN LINE LIST
LOCAL %NXADR
LOCAL MTCHFG, SAVE, CNT, PTR, WD()
LOCAL TERM

         PRGCHK
         IF EL.ID(I)=0 OR EL(I)=0 THEN DO     !ALL LINES
           LSTCNT _ LTBL(2) _ DB.NLINES; LTBL(1) _ CNT _ 1
         END ELSE DO
           WD _ EL(I)
           CNT _ LSTCNT _ PTR _ I _ 0
           LOOP DO
             IF INC CNT>RNGMX THEN CERR(LSTLNG)
             SAVE _ 0; LTBL(INC I) _ NXADR
             IF TERM=$: THEN DO
               IF LTBL(INC I) _ NXADR-LTBL(I)+1 <0 THEN CERR(BDLRNG)
             END ELSE LTBL(INC I) _ MTCHFG
             LSTCNT +_ LTBL(I)
             WHILE TERM=$,
           END
         END

         I.NXLNUM; RETURN CNT

%NX
!  RETURNS LINE NO. CORRESPONDING TO NEXT LINE ADDRESS (BEGINNING
!  AT INC PTR). LEAVES PTR AT : , OR 0, WITH WD(PTR) IN TERM.
!  NOTE: IF NEGATIVE SUBELEMENT, IS INTEGER REPRESENTING LINE KEY OR 
!  DISPLACEMENT.

LOCAL NX1:, LKEY, TEMP

         MTCHFG _ YES; LKEY _ 0
         EIF WD(INC PTR)<0 THEN DO
           XLKLN(LKEY_-WD(PTR),NX1)    !STORES RESULT IN LNUM
           GO NX2
NX1:       MTCHFG _ NO   !IS 1+GREATEST LINE NO. WITH SMALLER KEY
         END
         ORIF WD(PTR)=$. THEN LNUM_DB.DOT
         ORIF WD(PTR)=$$ THEN LNUM _ DB.NLINES
         ELSE !IS $#! IF LNUM_-WD(INC PTR)>DB.NLINES THEN CERR(BDLRNG)

NX2:     IF TEMP_[WD(INC PTR)=$-] OR WD(PTR)=$+ THEN DO
           IF MTCHFG=NO THEN CERR(BDLRNG)
           INC PTR; LNUM +_ IF TEMP THEN WD(PTR) ELSE -WD(PTR)
           IF NOT(1<=LNUM<=DB.NLINES) THEN CERR(BDLRNG)
           INC PTR
         END ELSE DO     !NO DISPLACEMENT
           IF SAVE#0 AND MTCHFG=NO THEN DEC LNUM
         END

         IF LKEY=0 THEN LKEY _ INTKEY(LNUM)
         IF SAVE=0 THEN SAVE _ LKEY ELSE IF SAVE>LKEY THEN CERR(BDLRNG)
         TERM _ WD(PTR); RETURN LNUM

END NXADR

END INLIST


%I.NXLNUM

!  INITIALIZES %NXLNUM TO RETURN 1ST LINE NO. IN LTBL
!  CALLED BEFORE %INLIST RETURN.

LOCAL CNT, PTR

CNT _ -1; PTR _ 1; RETURN

%%NXLNUM

!  RETURNS (AND STORES IN LNUM) NEXT LINE NO. SPECIFIED IN LTBL.
!  BEWARE OF OVERCALLING (MAX. OF LSTCNT CALLS AFTER I.NXNLUM)!!

IF INC CNT = LTBL(PTR+1) THEN DO
  WHILE LTBL(1+PTR+_2)=0 THEN NULL; CNT _ 0
END
RETURN LNUM _ LTBL(PTR)+CNT

END I.NXLNUM


%XLKLN (ILKEY,LAB:)

!  TRANSFORMS ILKEY (LINE KEY IN INTEGER FORM) TO ORDINAL LINE
!  NO., STORING RESULT IN LNUM.  IF EXACT MATCH, RETURNS; IF NOT,
!  RESULT IS 1+GREATEST LINE NO. WITH SMALLER LKEY & GOES TO LAB
!  RATHER THAN RETURN.

LOCAL TEMP

         LNUM _ 0; TEMP _ BCD(ILKEY)
         WHILE INC LNUM<=DB.NLINES THEN DO
           IF TEMP <= LINE.KEY(LNUM) THEN DO
             IF TEMP=LINE.KEY(LNUM) THEN RETURN; GO LAB
           END
         END
         GO LAB

END XLKLN


%BCD (ILKEY)

!  TRANSFORMS ILKEY (LINE KEY IN INTEGER FORM) TO BCD (DICTIONARY)
!  FORM
!  AND RETURNS RESULT.

LOCAL TEMP, I, CNT

         TEMP _ 0; CNT _ -4
         WHILE ILKEY THEN DO
           [ILKEY;I] _ ILKEY DIVMOD 10
           TEMP BOR_ (I SHL CNT +_ 4)
         END
         RETURN TEMP

END BCD


%INTKEY (LNUM)

LOCAL TEMP, I, CNT

!  TRANSFORMS LINE KEY CORRESPONDING TO LNUM FROM BCD (DICTIONARY
!  FORM) TO INTEGER FORM AND RETURNS RESULT.

         TEMP _ (I_LINE.KEY(LNUM)) BAND HEX F; CNT _ 0
         WHILE I _ I SHR 4 > 0 THEN DO
           TEMP _ TEMP + (I BAND HEX F) * PWR10(INC CNT)
         END
         RETURN TEMP

END INTKEY



%WKEY (I)

! WRITES LINE.KEY(I) (LINE KEY IN DICTIONARY FORM) PLUS A BLANK, ON TEL.

LOCAL FLG, KEY, TEMP, CNT

FLG _ NO; KEY _ LINE.KEY(I) SHL (BPW-(CNT_DGMAX)*4)
WHILE DEC CNT>=D.DGMAX THEN DO      !PRINT INTEGER DIGITS
  [TEMP;KEY] _ [0;KEY] DSHL 4
  IF TEMP THEN FLG _ YES  !SUPPRESS LEADING ZEROES
  IF FLG THEN PUT(TEMP+$0)
END
IF KEY THEN DO  !PRINT DEC. DIGITS
  PUT($.)
  WHILE KEY THEN [ [TEMP;KEY] _ [0;KEY] DSHL 4; PUT(TEMP+$0) ]
END
RETURN

END WKEY

%OUTNUM (N, RAD)

! CONVERTS N TO BASE RAD AND WRITES IT ON TEL

LOCAL BUF(12), I

IF N < 0 THEN [W(TEL,$-); N - _]
LOOP [FOR I _ 1 TO 12; [N; BUF(I)] _ N DIVMOD RAD; WHILE N # 0]
LOOP [W(TEL,BUF(I)+$0); WHILE DEC I > 0]
RETURN

END OUTNUM


%ALPH (X)
! NOT MACRO SO X CAN HAVE SIDE EFFECT (I.E., NCHV)
RETURN [UPALPH(X) OR LWALPH(X)]
END ALPH


%LIST.EXU


OPNERR:  IF ERRNUM=CORERR THEN CERR(NOCORE)
         IF ERRNUM>FNFERR THEN [PRINT('CANNOT OPEN '); WFID(FIDP); PUT(CARRET)]
         CERR(FILERR(ERRNUM))

END LIST.EXU


%S.OFF(PTR)
!MAY BE NEGATIVE
LOCAL TEMP
IF (TEMP _ HW((PTR)+3,1)) BAND OCT 400000 THEN TEMP BOR_ OCT 777777000000
RETURN TEMP
END S.OFF


!  ERROR HANDLING

%DERR (MSGADR)

IF SETFG THEN [PRINT(MSGADR); CPERR(%OUTSET)]
PUT(CARRET); CERR(MSGADR)

END DERR


%RWERR (N, %MSGPROC)
%%DPERR (%MSGPROC)

IF SETFG THEN [MSGPROC; CPERR(%OUTSET)]
PUT(CARRET); CPERR(%MSGPROC)

END RWERR


%SYMNERR (MSGADR, SYMNAM)

LOCAL %X

CPERR(%X)

%%SYMERR (MSGADR, SYMPTR)

SYMNAM _ S.NAM(SYMPTR); CPERR(%X)

%X

PUT(CARRET); PUTQSYM(SYMNAM,%PUT); PRINT(MSGADR)
IF SETFG THEN OUTSET
RETURN

END X

END SYMNERR


%VTYPA (S.TYPE)

LOCAL I
TABLE S.TYPA(VTYPRNG) [S.INT,S.REAL,S.DOUB,S.CPLX,S.LGC,S.STR]

FOR I _ INT TO STR IF S.TYPE=S.TYPA(I) THEN RETURN I
HALT

END VTYPA


%PUTQSYM (SYMNAM, %PUT)

!  PRINTS SYMBOL NAME SYMNAM IN QUOTES FOLLOWED BY BLANK, USING %PUT.

PUT($"); PUTSYM(SYMNAM,%PUT); PUT($"); PUT($ ); RETURN

END PUTQSYM


%PUTSYM (SYMNAM, %PUT)

!  PRINTS SYMBOL NAME SYMNAM, USING %PUT.

LOCAL CHAR,SXPTR

SXPTR _ SXPT(@SYMNAM)
LOOP [REPEAT 6; WHILE CHAR _ NCHV SXPTR#0; PUT(CHAR+OCT 40)]
RETURN

END PUTSYM


%GET.SYM

!  GET SYMBOL.  IF SUCCESSFUL, RETURN SYMBOL PTR.
!  IF FAIL, TAKE APPROPRIATE ERROR EXIT.

LOCAL %FSYM
LOCAL SYMPTR, SYMNAM

IF NOT GET.NAME(SYMNAM) THEN DPERR(%PCMDL)
IF NOT FSYM THEN SYMNERR(UNDEFS,SYMNAM)
RETURN SYMPTR

%FSYM

!  LOOKS UP SYMNAM IN SYMBOL TABLE.  IF FINDS ARRAY ELEMENT
!  OR VARIABLE CORRESPONDING TO SYMNAM, SET SYMPTR ACCORDINGLY
!  AND RETURN YES ELSE RETURN NO.

SYMPTR _ CURRENT.SYMT
LOOP DO
  WHILE S.VAR(SYMPTR) AND NOT S.ADJ(SYMPTR)
  IF SYMNAM=S.NAM(SYMPTR) THEN RETURN YES
  WHILE ^(SYMPTR +_ S.LEN(SYMPTR))#0
END
RETURN NO

END FSYM

END GET.SYM

%GET.NAME(SYMNAM)

LOCAL I, SXPTR

SXPTR _ SXPT(@SYMNAM); SYMNAM _ 0
IF NOT ALPH(NXNSP) THEN [BACKSP ; RETURN NO]
I _ 6
LOOP [IF DEC I>=0 THEN NCHV SXPTR _ (LASTCH-OCT 40); WHILE ALPH(NXCHAR) OR $0<=LASTCH<=$9]
IF SPCH(LASTCH) THEN NXNSP
RETURN YES
END GET.NAME


%GET.VAR

!  GET VARIABLE/ARRAY ELEMENT WITH CONSTANT OR INTEGER VARIABLE
!  SUBSCRIPTS.  IF SUCCESSFUL, RETURN SYMBOL PTR AND LOCATION.
!  IF FAIL, TAKE APPROPRIATE ERROR EXIT.
!  DISALLOW ARRAY NAME WITHOUT SUBSCRIPTS.

LOCAL SYMPTR, SUBPTR, LOC, I, %GET.INT, VAL

SYMPTR _ GET.SYM; LOC _ 0
EIF LASTCH=$( THEN DO
  IF NOT S.ARYB(SYMPTR) THEN SYMERR(NOTARY,SYMPTR)
  I _ 0; INIT.S.MUL(SYMPTR)
  LOOP DO
    IF NOT GET.INT THEN DO
      IF S.ARYB(SUBPTR _ GET.SYM) THEN SYMERR(ISARY,SUBPTR)
      IF S.TYP(SUBPTR)#S.INT THEN SYMERR(BADINT,SUBPTR)
      VAL _ ^(S.LOC(SUBPTR))
    END
    IF INC I>SUBSMAX THEN SYMERR(DIMLIT,SYMPTR)
    SUBS(I) _ VAL
    WHILE LASTCH=$,
    IF I=S.SNUM(SYMPTR) THEN SYMERR(SUBCNT,SYMPTR)
    LOC +_ VAL*NX.S.MUL
  END
  IF LASTCH#$) THEN DPERR(%PCMDL); NXNSP
  IF I#S.SNUM(SYMPTR) THEN SYMERR(SUBCNT,SYMPTR)
  IF NOT(0<=LOC +_ VAL*NX.S.MUL+S.OFF(SYMPTR)<S.SIZ(SYMPTR)) THEN SYMERR(BOUNDS,SYMPTR)
END
FIF S.ARYB(SYMPTR) THEN SYMERR(ISARY,SYMPTR)
RETURN [SYMPTR; LOC+IF S.TYP(SYMPTR)=S.STR THEN S.SLOC(SYMPTR) &
  ELSE IF S.ARYB(SYMPTR) AND S.DUM(SYMPTR) THEN S.DLOC(SYMPTR) &
    ELSE S.LOC(SYMPTR)]


%GET.INT

!  GET INTEGER.  IF SUCCESSFUL, RETURN YES AND SET VAL TO INTEGER.
!  IF FAIL, RETURN NO AND RESET LPTR BEFORE NEXT NON-BLANK CHAR.

LOCAL SGN

SGN _ 1
IF NXNSP=$- THEN [SGN _ -1; NXCHAR]
VAL *_ SGN; RETURN YES

END GET.INT

END GET.VAR

%GET.PINT(VAL)

VAL _ 0
IF NOT($0<=LASTCH<=$9) THEN [BACKSP; RETURN NO]
LOOP DO
  VAL _ VAL*10+LASTCH-$0; WHILE $0<=NXCHAR<=$9
END
IF SPCH(LASTCH) THEN NXNSP; RETURN YES

END GET.PINT

%DEXU

LOCAL INFN, ERR:
LOCAL %SET, %DISPLAY
LOCAL X, I, CNT

DEF WKEYRNG(FIRST,LAST) BY WKEY(FIRST)
  IF LAST#FIRST THEN [PUT($:); WKEY(LAST)]
  ENDM WKEYRNG

	SETFG _ 0
	DO DB.CNUM OF CMDCNT

K.DO:   OFFALT
	IF TELCHK THEN INFN _ TEL ELSE DO
	  LOOP DO
	    INFN _ OPEN(EL(1),INPUT+DIRECT+CHARACTER,ERR); WHILE 0
ERR:	    IF ERRNUM#FNFERR OR EXTQ(FIDP)=YES THEN GO OPNERR
	    EXTQ(FIDP) _ YES; EXTARG(FIDP) _ 0
	  END
	END
        CLOSE(CFN<==INFN); SETRWE(CFN,CFNEOF)

K.LIST:	LIST.EXU

K.LVER:	OUTNUM(HW(@JOBVER),8); PUT($.); OUTNUM(HW(@JOBVER,1),8); PUT(CARRET)

K.GO:  DERR(NOTIMP)

K.DEB:  EIF ELID(1)=ADR.ID THEN DO
           INLIST(1)
           X _ LINE.KEY(NXLNUM)
           NEW.ROUTINE _ LINE.START.ROUTINE(CURRENT.ROUTINE)
           ORD _ ORDINAL.START-1
           WHILE X>RT.HIGH.LINE.KEY(NEW.ROUTINE) AND INC ORD=ORDINAL(X) &
                THEN NEXT.ROUTINE(NEW.ROUTINE)
        END
        ELSE DO
           NEW.ROUTINE _ FIRST.ROUTINE
           LOOP DO
              REPEAT NO.ROUTINES
              WHILE EL(1)#RT.NAME(NEW.ROUTINE)
              NEXT.ROUTINE(NEW.ROUTINE)
           END
           IF EL(1)#RT.NAME(NEW.ROUTINE) THEN DERR('NO SUCH ROUTINE')
        END
        SET.CURRENT.ROUTINE(NEW.ROUTINE)

K.LDEB: PRINT('DEBUG AT '); WKEYRNG(LINE.KEY(1),RT.HIGH.LINE.KEY(CURRENT.ROUTINE))
	PUT(CARRET)
        EIF CONT.OK THEN [PRINT('CONTINUABLE AT '); WKEY(DB.DOT)]
        ELSE PRINT(NOCONT)
	PUT(CARRET)

K.BRK: K.TRC:  &
	X _ IF DB.CNUM=K.BRK THEN BRKBIT ELSE TRCBIT
	INLIST(1)
	I _ 0
	LOOP DO
	  CNT _ 0; REPEAT LTBL(I+_2) [^CORE.ADDR(LNUM) BOR _ X; INC CNT]
	  IF CNT=0 THEN DO
	    PRINT(NOXRNG); CNT _ LNUM <== LTBL(I-1)  !1ST IN SUBRANGE
	    WKEYRNG(LNUM,CNT)
	    PUT(CARRET)
	  END
	  WHILE LSTCNT -_ LTBL(I)
	END

K.LBRK:  K.LTRC:  &
	X _ IF DB.CNUM=K.LBRK THEN BRKBIT ELSE TRCBIT
	LNUM _ CNT _ 0
	LOOP DO
	  LOOP DO
	    IF INC LNUM>DB.NLINES THEN GO AWAY
	    WHILE ^CORE.ADDR(LNUM) BAND X=0
	  END
	  IF CNT THEN [PUT($,); PUT($ )]; I _ LNUM
	  LOOP DO
	    WHILE INC LNUM<=DB.NLINES 
	    WHILE ^CORE.ADDR(LNUM) BAND X
	  END
	  IF INC CNT=1 THEN PRINT(IF X=BRKBIT THEN BRKSTR ELSE TRCSTR)
	  WKEYRNG(I,LNUM-1)
	END
AWAY:	PUT(CARRET)

K.CONT: IF NOT CONT.OK THEN CERR(NOCONT)
        IORESTORE; RESINT; INC DB.INTNO; RETURN NO

K.DISP: DISPLAY

K.SET:  SET

K.NBRK:	K.NTRC:	NULL
    X _ BNOT(IF DB.CNUM=K.NBRK THEN BRKBIT ELSE TRCBIT)
    INLIST(1)
    REPEAT LSTCNT  ^(CORE.ADDR(NXLNUM)) BAND_X

K.QUIT: K.ABT: OFFALT; SFCLSALL; QUIT

	END
    RETURN YES


%SET

LOCAL %GETVAL
LOCAL RLOC, LLOC, ILPTR, SVLPTR, VPTR, CHAR, TEMP, SYMPTR

SETFG _ 1
ILPTR _ SVLPTR _ LPTR
LOOP DO
  [SYMPTR; LLOC] _ DOUBLE GET.VAR
  IF LASTCH#$= OR NOT($,#NXNSP#CARRET) THEN DPERR(%PCMDL)
  IF ALPH(LASTCH) THEN DO
    BACKSP; [VPTR; RLOC] _ DOUBLE GET.VAR
    IF S.TYP(VPTR)#S.TYP(SYMPTR) THEN SYMERR(BDMTCH,VPTR)
    ^LLOC _ ^RLOC
  END ELSE GETVAL(LLOC,S.TYP(SYMPTR))
  SVLPTR _ LPTR
  WHILE LASTCH=$,
END
IF LASTCH#CARRET THEN DPERR(%PCMDL)
RETURN

%GETVAL (LOC, S.TYPE)

!  USE SFORW TO SCAN & ACCUMULATE VALUE AT LOC FOR VARIABLE
!  OF TYPE S.TYPE.
!  LASTCH IS NON(BLANK OR ALPH). RETURNS WITH LASTCH AS NON-BLANK TERMINATOR.
!  IF PTR INVOLVED, IS SYMPTR.

	FORM _ -1    !REF'D BY NUMSCAN ERROR
	VADR _ LOC; VCNT _ 1
	IF VTYP _ VTYPA(S.TYPE)=CPLX THEN DO
	  IF LASTCH#$( THEN DERR(BDCPLX); NXNSP
	  VTYP _ REAL; INC VCNT
	END
	LOOP DO

	DO VTYP OF VTYPRNG

LGC:	CHAR _ EOLITWD; TEMP _ CHPT(@CHAR,-1)
	IF LASTCH#$. THEN DERR(BDCONS)
	LOOP DO
	  REPEAT 5; WHILE ALPH(NXCHAR); NCHV TEMP _ LASTCH
	END
	I _ NO
	EIF CHAR=^'FALSE' THEN NXCHAR
	ORIF CHAR=^'TRUE' THEN I _ YES
	ELSE DERR(BDCONS)
	IF LASTCH#$. THEN DERR(BDCONS)
	LGCPK(I); NXNSP

STR:	IF $'#LASTCH#$" THEN DERR(BDCONS)
	CHAR _ LASTCH; TEMP _ CHPT(VADR,-1); CNT _ S.SCAP(SYMPTR)
	LOOP DO
	  WHILE DEC CNT>=0; WHILE CARRET#NXCHAR#CHAR; NCHV TEMP _ LASTCH
	END
	EIF CNT>=0 THEN NCHV TEMP _ EOLIT
	! NOTE THAT CARRET SUPPLIES STRING TERMINATOR.
	ELSE WHILE CARRET#NXCHAR#CHAR THEN NULL !INPUT BEYOND CAPACITY
	IF LASTCH#CARRET THEN NXNSP

INT: REAL: DOUB: &
	NUMSCINIT
	LOOP [NUMSCAN(LASTCH); WHILE $,#NXCHAR#CARRET AND $ #LASTCH#$)]
	NUMSCAN(-2)
	IF LASTCH=$  THEN NXNSP

	END
	WHILE DEC VCNT>0
	IF LASTCH#$, THEN DERR(BDCPLX); NXNSP
	INC VADR

	END
	IF VADR>LOC THEN DO   !COMPLEX
	  IF LASTCH#$) THEN DERR(BDCPLX); NXNSP
	END
	RETURN

END GETVAL


%OUTSET

PUT(CARRET)
EIF ILPTR=SVLPTR THEN [PRINT('NO '); PRINT(ASSIGN)]
ELSE DO
  PRINT(ASSIGN); PUT($:); PUT(CARRET)
  PCHV SVLPTR  !TO BEFORE TERMINATOR
  WHILE ILPTR#SVLPTR THEN PUT(NCHV ILPTR)
END
RETURN

END OUTSET

END SET


%DISPLAY

LOCAL %DPUT.INIT, %DPUT, %PUTDBUF
LOCAL %PUTVAL
DEF DBUFLEN AS 133   !MAX TTYLEN+1 FOR EOLIT
DEF DBUFSZ AS ((DBUFLEN+CPW-1)/CPW)
LOCAL DBUF(0:DBUFSZ-1)
LOCAL DPOS   !POSITION FOR LINE SINCE DBUF.INIT
LOCAL DCNT   !TO CHECK FOR DBUF OVERFLOW (PAST TTYLEN)
LOCAL DPTR
LOCAL LOC, SYMPTR

DPUT.INIT
LOOP DO
  [SYMPTR; LOC] _ DOUBLE GET.VAR
  PUTSYM(S.NAM(SYMPTR),%DPUT)
  IF S.ARYB(SYMPTR) THEN DO
    DPUT($(); I _ 0
    WHILE INC I<S.SNUM(SYMPTR) THEN DO
      PUTVAL(@SUBS(I),S.INT); DPUT($,)
    END
    PUTVAL(@SUBS(I),S.INT); DPUT($))
  END
  DPUT($ ); DPUT($=); PUTVAL(LOC,S.TYP(SYMPTR)); PUTDBUF
  WHILE LASTCH=$,
END
IF LASTCH#CARRET THEN DPERR(%PCMDL)
PUT(CARRET)
RETURN


%PUTVAL (LOC, S.TYPE)

!  USE SFORW FOR OUTPUT OF VALUE OF SPECIFIED TYPE
!  AT LOC.
!  IF PTR INVOLVED, IS SYMPTR.

LOCAL CHAR, TEMP

	VADR _ LOC; VCNT _ 1
	IF VTYP _ VTYPA(S.TYPE) =CPLX THEN [VTYP _ REAL; INC VCNT]
	LOOP DO

	DO VTYP OF VTYPRNG

LGC:	DPUT($ ); DPUT(IF LGCUNPK THEN $T ELSE $F)

STR:	TEMP _ CHPT(VADR,-1); DPUT($ ); DPUT($")
	LOOP DO
	  REPEAT S.SCAP(SYMPTR); WHILE CHAR _ NCHV TEMP#EOLIT; DPUT(CHAR)
	END
	DPUT($")

INT:	DPUT(IF NUMUN.INIT(INTFLD) THEN $-  ELSE $ )
	REPEAT NUMUNPK DPUT(NUMUNPK)

REAL: DOUB: &
	TEMP _ POUT(%DPUT); FLOUT; POUT(TEMP)

	END
	WHILE DEC VCNT>0
	DPUT($,)
	INC VADR

	END
	RETURN

END PUTVAL


%DPUT.INIT

!  INITIALIZATION (CALLED ONCE PER DISPLAY COMMAND).

LOCAL %DBUF.INIT

DPOS _ 0; DBUF.INIT; RETURN

%%DPUT (CHAR)

!  STORE CHAR IN DBUF OR, IF OVERFLOW, PUT TO TERMINAL.

EIF DEC DCNT>0 THEN NCHV DPTR _ CHAR
ELSE PUTDBUF
RETURN

%PUTDBUF

!  PUTS DBUF TO TERMINAL AND INITS FOR NEXT DISPLAY ITEM.

IF DPOS>0 THEN DO
  EIF DPOS+3+(LTTYLEN+1-DCNT)>=LTTYLEN THEN [PUT(CARRET); DPOS _ 0]
  ELSE [REPEAT 3 PUT($ ); DPOS +_ 3]
END
PRINT(DBUF); DPOS +_ LTTYLEN+1-DCNT; DBUF.INIT; RETURN

END PUTDBUF


%DBUF.INIT

!  INITIALIZE FOR (DPUT OF) NEW ITEM OF DISPLAY OUTPUT.

MOVE DBUFSZ FROM ALL EOLITWD TO DBUF
DPTR _ CHPT(DBUF,-1); DCNT _ LTTYLEN+1; RETURN

END DBUF.INIT

END DPUT.INIT

END DISPLAY

END DEXU


%STM (AC)
!
! AC IS THE AC FIELD OF THE STM UUO.
!

IF AC=0 THEN RETURN    !FOR SPEED
SET.DOT
PRINT(IF AC BAND AC.BRKBIT THEN BRKSTR ELSE TRCSTR)
WKEY(DB.DOT); PUT(CARRET)
IF AC BAND AC.BRKBIT=0 THEN RETURN
CONT.OK _ YES ; GETCOM ; RETURN

END STM

%PAWS
! CALLED BY PAUSE ROUTINE

CONT.OK _ YES
SET.DOT
GETCOM
RETURN

END PAWS


%XIT

! CALLED BY STOP AND END STATEMENTS

CONT.OK _ NO
UNCORE
SET.DOT
GETCOM
RETURN

END XIT

%QUIT
END QUIT

%CONERR
END CONERR

%NCNERR
END NCNERR
D 1›