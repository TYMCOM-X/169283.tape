!  CCS FOR THE PDP-10                       CAROLINE DIEHL AND FRIENDS


!  MACHINE DEPENDENT MACROS

! IF INCREASE TOTAL DGMAX, MUST EXPAND PWR10 TABLE!
DEF I.DGMAX AS 5     !MAX NO. INTEGER & DECIMAL LINE KEY DIGITS (4 BITS
DEF D.DGMAX AS 3     !PER - MUST FIT IN WORD ALONG WITH SIGN BIT)
DEF LBL.DGMAX AS 5   !MAX NO. DIGITS IN FORTRAN LABEL

DEF LWUPDIF AS OCT 40     !LWR CASE CHAR MINUS UPR CASE OF SAME
DEF LESSTR(X,Y) AS (X) SHR 1 < (Y) SHR 1  !STRING COMPARISON
DEF ND.STR AS '[[[[['    !STRING LIT > WD OF ALPHA CHARS
DEF EOLITWD AS 0         !WORD OF EOLITS
DEF TABCH AS OCT 11      !HANDLED IN MACHINE DEPENDENT MANNER
DEF NSPCH(CHAR) AS ($ #CHAR#TABCH)
DEF SPCH(CHAR) AS NOT NSPCH(CHAR)


GLOBAL %CCS

S:      GO S1           !INITIAL ENTRY
S2:     CCS(0)          !RECOVERY FROM EXECUTION
S1:     CCS(1)

\\->S


%CCS (INITIAL)

! REQUIRES IOCSU FILE

LOCAL %PRMPT, %NXNSP, %BACKSP, %OFFSET, %GETSTR
DEF NXCHAR AS NCHV LPTR
LOCAL %OUTKEY, %PRMPTKEY, %PLNKEY, %OUTDEC
LOCAL %WDSTOR, %WDREC, %CSCAN, %CEXU
LOCAL %ERR, %ABERR, %EXERR, %LNGCHK, %CFNCLS

!  PROGRAM FILE AND CONTROL ROUTINES

FIND %PF.OPEN, %PF.CLOSE, %PF.RDLIN, %PF.WTLIN, %PF.UPDATE, %PF.CLEAR
FIND %GOSEG, %CMPDON

!  MACHINE/IMPLEMENTATION DEPENDENT I/O DATA

LOCAL FREEPTR                !PTR TO BEGINNING OF FREE BUFFER
LOCAL IMGPTR
DEF NBUFS AS 10                !IOCS ARGUMENT
LOCAL FIDTBL(0:2*WPF-1)

!  CCS DATA FROM PROGRAM FILE

FIND PF.FN              !FILE NUMBER OF PF
FIND PF.NOPF            !ERROR LABEL FOR PF NOT OPEN

FIND PF.VER             !PF FORMAT VERSION #
FIND PF.INTNO           !CURRENT INTERACTION NUMBER
FIND PF.RELOK           !1 SAYS CURRENT REL IS OK TO USE
FIND PF.DOT             !INDEX OF CURRENT LINE
FIND PF.NLINES          !# OF PROGRAM LINES IN USE
FIND PF.CNUM            !CURRENT COMMAND #

DEF NLMAX AS 1024

FIND PF.CPD(NLMAX)      !CURSOR POSITION IN PF OF LINE N
FIND PF.KEYD(NLMAX)     !LINE KEY FOR LINE N (4BIT DECIMAL - BCD)

! USED IN COMMAND PROCESSING (NOT SAVED BETWEEN COMMANDS):

LOCAL SCR(NLMAX)             !SCRATCH ARRAY
LOCAL INFN, OUTFN            !INPUT & OUTPUT FILE NUMBERS
LOCAL LPTR                   !INPUT LINE STRING POINTER
LOCAL EL(4), ELID(4), ELP    !COMMAND LINE ELEMENTS, ELEMENT IDS
DEF SELLIM AS GLBSZ
LOCAL SEL(-1:SELLIM)         !SUBELEMENTS (LINE LIST & RANGE)
DEF LTBL(X) AS SEL((X)-2)    !LINE LIST NOS. & COUNTS
LOCAL SELP                   !SEL PTR
LOCAL LNUM

!  PROMPT PARAMETERS

LOCAL PRMNUM                 !PROMPT IDENTIFYING NO.
DEF K.PFE AS 1
DEF K.PAT AS (K.PFE+1)
DEF K.PLK AS (K.PAT+1)
DEF K.PQM AS (K.PLK+1)
DEF PRMCNT AS K.PQM
LOCAL PRMKEY                 !LINE KEY TO PRINT IF PRMNUM=K.PLK

!  COMMAND WORDS

DEF K.CLR  AS 1
DEF K.COMP AS 2
DEF K.COPY AS 3
DEF K.DEL  AS 4
DEF K.DO   AS 5
DEF K.EDIT AS 6
DEF K.ENT  AS 7
DEF K.FAST AS 8
DEF K.LIST AS 9
DEF K.MERG AS 10
DEF K.MOD  AS 11
DEF K.MOVE AS 12
DEF K.OPEN AS 13
DEF K.QUIT AS 14
DEF K.REN  AS 15
DEF K.RUN  AS 16
DEF K.SAVE AS 17
DEF K.SWIT AS 18
DEF K.VER  AS 19

DEF CWDCNT AS K.VER
TABLE CWD(CWDCNT+1)["CLEAR","COMPILE",&
  "COPY","DELETE","DO","EDIT","ENTER","FAST",&
  "LIST","MERGE","MODIFY",&
  "MOVE","OPEN","QUIT","RENUMBER",&
  "RUN","SAVE","SWITCH","VERSION",ND.STR]

DEF CLMAX AS 8     !COMMAND LENGTH MAX
DEF INWDSZ AS (CLMAX+CPW-1)/CPW
LOCAL INWD(0:INWDSZ-1)       !MUST HOLD CLMAX CHARS

!  COMMAND LINE ELEMENT IDENTIFIERS

DEF FID.ID AS 1              !FILE IDENTIFIER INDEX
DEF LST.ID AS 2              !LINE LIST
DEF ADR.ID AS 3              !LINE ADDRESS
DEF RNG.ID AS 4              !LINE RANGE
DEF LKY.ID AS 5              !LINE KEY
DEF FOR.ID AS 6              !FORTRAN ELEMENT (STMT, LABEL, VAR)
DEF INT.ID AS 7              !POSITIVE INTEGER

!  USED IN LINE KEY AND/OR LINE TEXT OUTPUT:

LOCAL OUTCNT    !ORIGINALLY MAX NO. OF OUTPUT CHARS; DEC'D. SET TO
                !VERY LARGE NO. IF NO LIMIT
LOCAL TABSP     !LIST COMMAND: LINE INDENTATION

!  ERROR MESSAGES TO USER OF CCS

TABLE BDCMND       ['NO SUCH COMMAND']
TABLE LNLONG       ['LINE TOO LONG']
TABLE EDILNG       ['TRUNCATED LINE AVAILABLE FOR EDIT']
TABLE AMBGCM       ['AMBIGUOUS COMMAND, TYPE MORE CHARACTERS']
TABLE BDLRNG       ['ILLEGAL LINE RANGE']
TABLE LSTLNG       ['LINE LIST TOO LONG']
TABLE NODFLT       ['NO DEFAULT NAME']
TABLE NOTIMP       ['BAD I/O SOURCE OR DESTINATION']
TABLE CNTREN       ['CANNOT RENUMBER, CHECK LINE RANGE']
TABLE NOPROG       ['NO PROGRAM']
TABLE BDANS        ['ILLEGAL RESPONSE IN COMMAND FILE']
TABLE DISORD       ['DISORDERLY LINE NUMBER']
TABLE PTROOM       ['NOT ENOUGH ROOM, CANNOT ENTER LINE']
TABLE NOROOM       ['NOT ENOUGH ROOM, COMMAND NOT EXECUTED']
TABLE BDLNFL       ['EDIT REQUIRES LINE NUMBERS, COPY REQUIRES NONE']
TABLE ENDSCR       ['OUT OF SCRATCH AREA, TRY SAVE AND RELOAD']
TABLE NDOPEN       ['PLEASE GIVE OPEN COMMAND FIRST']

!FILE OPEN ERRORS
TABLE FILERR(IFDERR:FBSERR) ['ILLEGAL FILE IDENTIFIER', &
 '$NEW/OLD FILE MESSAGE NOT CONFIRMED', &
 'FILE NOT FOUND', 'INVALID USER NAME', &
 'PROTECTION VIOLATION ATTEMPT', 'FILE BUSY']

!  ERROR MESSAGES TO PROGRAMMER OF CCS (HOPEFULLY NOT TO USER)

TABLE NOCORE       ['NOT ENOUGH CORE FOR BUFFER RING']

!  COMMAND MODELS

LOCAL CMDL(CWDCNT)
CMDL(K.ENT) _ '<LINE NUMBER> <STATEMENT>$  OR: <LINE RANGE> <CR> &
<STATEMENTS> <CR>'
CMDL(K.CLR) _ CMDL(K.QUIT) _ CMDL(K.VER) _ ''
CMDL(K.SAVE) _ '[ <FILE> ]'
CMDL(K.MERG) _ CMDL(K.DO) _ '<FILE>'
CMDL(K.EDIT) _ '<LINES OR FILE>'
CMDL(K.MOD) _ '<LINES>'
CMDL(K.DEL) _ '[ <LINES> ]'
CMDL(K.FAST) _ CMDL(K.LIST) _ '[ <LINES> ] [ TO <FILE> ]'
CMDL(K.COPY) _ '<LINES OR FILE> TO <LINE RANGE OR FILE>'
CMDL(K.MOVE) _ '<LINES> TO <LINE RANGE OR FILE>'
CMDL(K.REN) _ '[ <LINE> [ :<LINE> ] ] [ AS <LINE RANGE> ]'
CMDL(K.RUN) _ CMDL(K.COMP) _ '[ <ARGUMENTS> ]'
CMDL(K.SWIT) _ '[ <SWITCHES> ]'

LOCAL PCMDL:                 !PRINTS CMND MDL (IN CSCAN, REF'D BY CEXU)
LOCAL FIXUP                  !LABEL USED IN FIXUP AFTER ALT MODE OR
                             !UNRECOVERABLE ERROR

!  OF GENERAL INTEREST:

DEF UPALPH(X) AS ($A<=X<=$Z)
DEF LWALPH(X) AS ($A+LWUPDIF <= X <= $Z+LWUPDIF)
DEF XLWUP(X) AS X _ X-LWUPDIF   !TRANSFORM X FROM LWR TO UPR CASE
DEF NUM(X) AS ($0<=X<=$9)
LOCAL %ALPH

DEF DGMAX AS (I.DGMAX+D.DGMAX) !MAX. TOTAL LINE KEY DIGITS
TABLE PWR10(0:DGMAX) [1,10,100,1000,10000,100000,1000000,10000000, &
   100000000]
DEF LKY.MAX AS (PWR10(DGMAX)-1)        !MAX. LINE KEY VALUE

DEF SGNBIT AS (1 ROTR 1)
DEF BIGNUM AS BNOT SGNBIT
DEF BPW AS BITS.PER.WORD
DEF BPC AS (BPW/CPW)

DEF YES AS 1
DEF NO  AS 0

LOCAL CHAR, PTR, CNT, TEMP, I


!  CCS INITIALIZATION

LOCAL CFNEOF:, ERRA:, ALT:, NEWCOM:, QUIT:, NOPF:
FIND JOBDDT

       IF INITIAL THEN DO
         IOCS(NBUFS)
         SETRWE(CFN,CFNEOF)
         SETPRMPT(%PRMPT); TAB.OFF(%OFFSET)
         FREEPTR _ CHPT(FREE,-1); IMGPTR _ CHPT(IMAGE,-1)
         PUT(CARRET)
         OFFALT
         ALTLOC _ ALT
         PF.FN _ TEL; PF.NOPF _ NOPF; PF.CLEAR
       END

!  ACCEPT A COMMAND LINE
!  NOTE: DO OFFALT BEFORE BRANCH HERE OR TO ANY LABELS FOLLOWING
!  ABOVE OFFALT

NEWCOM:  FIXUP _ NEWCOM
         ONALT.C
         PRMNUM _ K.PFE
         LOOP [GETSTR(CFN); WHILE CHAR _ NXNSP =CARRET]
         BACKSP; IF ALPH(CHAR) THEN [WDSTOR(CLMAX,ERRA); &
           PF.CNUM _ WDREC(CWD,ERRA)] ELSE PF.CNUM _ K.ENT
         CSCAN; CEXU; IF PF.FN > TEL THEN INC PF.INTNO; GO NEWCOM

ERRA:    ERR(BDCMND)

NOPF:   ERR(NDOPEN)

ALT:     OFFALT; CLOBUF; CLIBUF; PUT(CARRET)
         IF JOBDDT THEN [ONALT.C; PUT(7); GO ^HW(@JOBDDT,1)]
BACK:    OFFALT; IF CFN#TEL THEN [MSG('$ABORTED$'); CFNCLS]
         GO ^FIXUP


%GETSTR (FN)

INLA:    RETURN LPTR _ GETLINE(FN)

CFNEOF:  OFFALT; LNGCHK; CFNCLS; FN _ TEL; ONALT.C; GO INLA

%ERR (N)

!  FN IS LAST FILE GETSTR READ FROM.
!  HANDLES RECOVERABLE TEL INPUT ERRORS AND CFN INPUT ERRORS WHICH
!  DO NOT ABORT CFN INPUT IF FN  WAS INFN (EG, LOAD OR COPY).
!  IF FN WAS COMMAND FILE NOT TEL (EG, ENTER) ABORTS CFN INPUT AND
!  OMITS FIXUP.

         ONALT.C
         CLIBUF; MSG(N); PUT(CARRET)
         IF FN=TEL THEN GO INLA
         PRINT(FREE)
         IF FN#CFN THEN GO INLA
         OFFALT; CFNCLS; GO NEW.COM

END ERR


%EXERR (N)

!  HANDLES FATAL ERRORS THAT RESULT IN EXIT.

  OFFALT; FIXUP _ QUIT

%%ABERR (N)

!  HANDLES UNRECOVERABLE ERRORS.  CFN INPUT ABORTED.
!  DOES SAME FIXUP AS ALT MODE.

       ONALT.C
       CLIBUF; MSG(N); PUT(CARRET); IF FN#TEL THEN PRINT(FREE)
       OFFALT; CFNCLS; GO ^FIXUP

END EXERR

END GETSTR


%LNGCHK
IF ERRNUM=LNGERR THEN ERR(LNLONG); RETURN
END LNGCHK


%CFNCLS
CLOSE(CFN <== TEL); RETURN
END CFNCLS


%PRMPT

! PROMPTS AS SPECIFIED BY PRMNUM

         DO PRMNUM OF PRMCNT
K.PFE:     OUTFN _ TEL; OUTDEC(PF.INTNO); MSG(': ')
K.PAT:     PUT($@)
K.PLK:     OUTFN _ TEL; PRMPTKEY(0,0,0)
K.PQM:     PUT($?); PUT($ )
         END
         RETURN

END PRMPT


%OFFSET
!  STATEMENT TAB ORIGIN MUST BE PAST LINE NO. ( & ENTER, IF ANY)

LOCAL PTR, OFF, CHAR

OFF _ 0
IF PRMNUM=K.PFE THEN DO
  PTR _ IMGPTR; WHILE SPCH(CHAR_NCHV PTR) OR ALPH(CHAR) THEN INC OFF
  IF CHAR=EOLIT OR (CHAR#$. AND NOT($0<=CHAR<=$9)) THEN RETURN 0; INC OFF
  WHILE $0<=CHAR _ NCHV PTR<=$9 OR CHAR=$. THEN INC OFF
  IF CHAR=EOLIT OR SPCH(CHAR) THEN INC OFF
END
RETURN OFF

END OFFSET


%NXNSP

! RETURNS NEXT NON-BLANK

WHILE SPCH(I_NCHV LPTR) THEN NULL; RETURN I

END NXNSP


%BACKSP

PCHV LPTR; RETURN

END BACKSP


%WDSTOR (LMAX, LAB:)

!  NEXT CHAR IS ALPHABETIC.  STORES CHARS UP TO NEXT NON-ALPHA
!  IN INWD ARRAY; LPTR UPON RETURN IS BEFORE WD TERMINATOR.
!  GOES TO LAB IF NO. OF ALPHA CHARS EXCEEDS LMAX.
!  CONVERTS LOWER CASE ALPHA TO UPPER CASE.

       MOVE INWDSZ FROM ALL EOLITWD TO INWD
       PTR _ CHPT(INWD,CNT _ -1)
       WHILE INC CNT<=LMAX THEN DO
         IF NOT UPALPH(CHAR _ NXCHAR) THEN DO
           IF LWALPH(CHAR) THEN XLWUP(CHAR) ELSE [BACKSP; RETURN]
         END
         NCHV PTR _ CHAR
       END
       GO LAB

END WDSTOR


%WDREC (WD(), LAB:)

! WORD RECOGNITION

!  WORD IS AT ADDR INWD, NO. OF CHARS IS IN CNT.
!  IF RECOGNIZES WORD AS WD(I), RETURNS I.
!  ALLOWS SHORTEST UNIQUE ABBREVIATION.
!  GOES TO LAB IF NO MATCH.
!  IF COMMAND LOOKUP (CWD ARRAY), MAY BE AMBIGUITY, IN WHICH CASE
!  ERR EXIT IS TAKEN.

LOCAL %COMPARE
LOCAL W, SAVE

       [W;CNT] _ CNT DIVMOD CPW
       PTR _ 0
       WHILE INWD(0) # ^WD(INC PTR) THEN DO
         IF LESSTR(INWD(0),^WD(PTR)) THEN GO NXT
       END
! INWD(0) <= ^WD(PTR)
NXT:   DO COMPARE OF -1:1
-1:      GO LAB                !<, NO MATCH
1:       INC PTR; GO NXT       !>, ONLY 1ST WD MATCH, CONTINUE
0:       SAVE _ PTR; INC PTR   !=, MATCH
         DO COMPARE OF -1:1    !AMBIGUITY CHECK
 -1: 1:    RETURN SAVE         !<, NO AMBIGUITY
  0:       ERR(AMBGCM)
         END
       END

%COMPARE

! COMPARES INWD TO COMMAND AT WD(PTR), UP TO END OF INWD.
! RETURNS -1, 0 OR 1, IF <, = OR >, RESPECTIVELY.

LOCAL J

       I _ TEMP _ -1
       WHILE INC I<W THEN DO
CA:      J _ ^(WD(PTR)+I) BAND TEMP
         IF INWD(I)#J THEN DO
           RETURN IF LESSTR(INWD(I),J) THEN -1 ELSE 1
         END
       END
       IF TEMP=-1 THEN [TEMP _ TEMP SHL (BPW-BPC*CNT); GO CA]
       RETURN 0

END COMPARE

END WDREC


%CSCAN

!  CCS COMMAND LINE SCANNER

!  STORES COMMAND LINE ELEMENT IDENTIFIERS (IN EL.ID ARRAY) & INFO
!  NEEDED TO ACCESS ELEMENTS (IN EL ARRAY).
!  PF.CNUM (COMMAND NO.) RETURNED IF SCAN SUCCESSFUL, WITH 0'S IN
!  UNUSED EL.ID POSITIONS.

! PREPOSITIONAL WORDS - NO EL.ID/EL ENTRY FOR THESE

DEF K.AS   AS 1
DEF K.TO   AS 2
DEF PWDCNT AS K.TO
TABLE PWD(PWDCNT+1)["AS","TO",ND.STR]
DEF PLMAX AS 2               !MAX LENGTH OF PREP WD

DEF ELW(X,Y) AS [EL(INC ELP)_(Y); EL.ID(ELP)_(X)]

LOCAL %FCR, %FFID, %FPWD
LOCAL %FRNG, %FADR, %FLST
LOCAL EROUT:, CRCHK:
LOCAL FIDP

         MOVE 4 FROM ALL 0 TO ELID+1
         SELP _ ELP _ 0; FIDP _ FIDTBL-WPF

         DO PF.CNUM OF CWDCNT

K.ENT:   IF NOT FRNG THEN GO EROUT
         IF EL.ID(1)=LKY.ID THEN DO
           IF NSPCH(NXCHAR)  THEN BACKSP     !ABSORB BLANK AFTER LINE KEY
           ELW(FOR.ID,LPTR); RETURN PF.CNUM
         END

K.CLR:   K.QUIT:  K.VER:  K.RUN:  NULL

K.EDIT:  IF NOT FLST THEN GO INP
         IF NXNSP#CARRET THEN [LPTR _ TEMP; DEC ELP; GO INP]    !TO ALLOW 1.F4
         BACKSP

INP: &
K.MERG:  FFID(0)

K.DO:   FFID(0)

K.MOD:   IF NOT FLST THEN GO EROUT

K.DEL:   FLST

K.FAST:  K.LIST: &
         FLST; FPWD(K.TO,CRCHK); FFID(0)

K.COPY:  IF NOT FLST THEN FFID(0)
COP.B:   FPWD(K.TO,PCMDL); IF NOT FRNG THEN FFID(0)

K.MOVE:  IF NOT FLST THEN GO EROUT; GO COP.B

K.REN:   FLST; FPWD(K.AS,CRCHK); IF NOT FRNG THEN GO EROUT

K.OPEN:  FFID(OCT 604755.000000)  !.PGM

         END

! CR MUST FOLLOW
CRCHK:   IF NOT FCR THEN GO PCMDL; RETURN PF.CNUM

EROUT:   IF NXNSP#CARRET THEN ERR(BDLRNG)
PCMDL:   MSG("$SHOULD BE:$"); PRINT(CWD(PF.CNUM)); PUT($ )
         ERR(CMDL(PF.CNUM))



%FCR

TEMP _ [NXNSP=CARRET]; BACKSP; RETURN TEMP

END FCR


%FFID (EXTDEF)

!  SCANS FOR FILE IDENTIFIER (FID) TERMINATED BY BLANK OR CR.
!  CALLED WHEN NO ALTERNATIVE TO FID, SO TAKES ERROR EXIT IF FAILS.
!  STORES FID INFO WITH SETFID; IF OK, STORES FID.ID & ARG TO BE 
!  USED IN OPEN CALL.

LOCAL EROUT:

         IF NXNSP=CARRET THEN GO PCMDL
         BACKSP; SETFID(FIDP +_ WPF, @LPTR, EXTDEF, EROUT)
         ELW(FID.ID,-FIDP); RETURN

EROUT:   ABERR(FILERR(IFDERR))

END FFID


%FPWD (K.PWD,LAB:)

!  SCANS FOR PREP. WD SPECIFIED BY K.PWD (INCL. ABBREVIATIONS).
!  IF SUCCESSFUL, RETURNS K.PWD ELSE RESETS LPTR & GOES TO LAB.
!  SPECIAL CASE: IF K.PWD IS EOLIT, RETURNS INDEX TO PREP. WD FOUND;
!  IF WD IS NONE OF THE PREP. WDS, GOES TO LAB.

LOCAL OUT:

         TEMP _ LPTR
         IF NOT ALPH(NXNSP) THEN GO OUT
         BACKSP; WDSTOR(PLMAX,OUT)
         IF I _ WDREC(PWD,OUT)=KPWD OR KPWD=0 THEN RETURN I
OUT:     LPTR _ TEMP; GO LAB

END FPWD


%FRNG

!  SCANS FOR CONSTRUCTION SPECIFIED AT ENTRY POINT.
!
!  RNG      LKEY:LKEY  OR  LKEY(LKEY)LKEY  OR  LKEY(LKEY)  OR  LKEY
!           (LKEY FORM IS 0 TO I.DGMAX DIGITS, OPTIONAL 0 TO D.DGMAX
!           DECIMAL DIGITS WITH >0 DIGITS IN ALL)
!  ADR      LKEY  OR  $  OR  .  OR  *INT  OR  ADR+INT  OR  ADR-INT
!  LST      ADR[:ADR],...,ADR[:ADR]  OR  ALL
!
!  IF SUCCESSFUL, STORES APPROPRIATE EL.ID AND, IN EL ARRAY,
!     ADR OF WD BEFORE 1ST WD OF SUBELEMENT LIST
!                    (SEE %FRL)
!
!  RETURNS 1, WITH LPTR BEFORE CONSTRUCTION TERMINATOR.
!  IF NOT SUCCESSFUL, RESETS LPTR AND RETURNS 0.
!
!  LOW-ORDER BITS OF LFGS REPRESENT STATES AS FOLLOWS:
!
!            RNG     ADR
!    LST      :       (
!  + OR -     $       )
!     *     DIGIT     .
!
!  THUS:

DEF DOTB  AS 1
DEF DGTB  AS (1 SHL 1)
DEF ASTB  AS (1 SHL 2)
DEF RGTB  AS (1 SHL 3)
DEF DLRB  AS (1 SHL 4)
DEF SGNB  AS (1 SHL 5)
DEF LFTB  AS (1 SHL 6)
DEF CLNB  AS (1 SHL 7)
DEF LSTB  AS (1 SHL 8)
DEF ADRB  AS (1 SHL 9)
DEF RNGB  AS (1 SHL 10)

LOCAL %FRL
LOCAL LFGS

         LFGS _ RNGB; I _ FRL
         ELW(IF PF.CNUM=K.ENT AND LFGS BAND (CLNB+RGTB)=0 THEN LKY.ID &
           ELSE RNG.ID, I)
         RETURN YES


%%FADR

         LFGS _ ADRB; ELW(ADR.ID,FRL); RETURN YES


%%FLST

         LFGS _ LSTB
         ELW(LST.ID,FRL); RETURN YES


LAB:    RETURN NO


%FRL

!    TERMINATES ON ANY SYMBOL NOT : ( + - $ ) * DIGIT .
!    STORES SUBELEMENTS IN SEL ARRAY (1 PER WD) & RETURNS ADR OF
!    WD BEFORE 1ST WD OF LIST.  SUBELEMENTS INCLUDE ANY SPECIAL
!    SYMBOL & (NEGATIVE OF) ANY NUMBER READ (LKEY STORED AS INTEGER).
!    LIST TERMINATED BY 0.
!    SPECIAL CASE FOR LSTB: 'ALL' INDICATES ALL LINES, RETURNS 0

LOCAL %SVNUM, %SELW
LOCAL LVAL, TEMP

! EXTRACTION OF TYPE BIT:
DEF TYPB AS (LFGS BAND (RNGB+ADRB+LSTB))

! CHECK FOR ILLEGAL STATES:
DEF NG(X) AS IF LFGS BAND (X) THEN GO OUT

DEF PARENS AS (LFTB+RGTB)

         TEMP _ LPTR
         IF CHAR_NXNSP=CARRET THEN GO OUT
         PTR _ SELP
         CNT _ I.DGMAX; LVAL _ 0    !LVAL RESET IN SVNUM

       LOOP DO
         EIF NUM(CHAR) THEN DO
           NG(DLRB)
           LVAL _ LVAL*10+CHAR-$0
! DON'T DEC CNT IF LEADING INTEGER ZERO
           IF NOT(LVAL=0=LFGS BAND DOTB) THEN IF DEC CNT<0 THEN GO OUT
           LFGS BOR_ DGTB
         END

         ORIF CHAR=$. THEN DO
           NG(SGNB+DLRB+ASTB+DOTB)
           LFGS BOR_ DOTB
           CNT _ D.DGMAX
         END

         ELSE DO
           EIF CHAR=$: THEN DO
             NG(ADRB+CLNB+PARENS)
             SVNUM; LFGS _ TYPB BOR CLNB
           END

           ORIF CHAR=$( THEN DO
             NG(ADRB+LSTB+CLNB+PARENS)
             SVNUM; LFGS _ TYPB BOR LFTB
           END

           ORIF CHAR=$) THEN DO
             IF LFGS BAND PARENS#LFTB THEN GO OUT
             SVNUM; LFGS _ TYPB BOR RGTB
           END

           ORIF CHAR=$+ OR CHAR=$- THEN DO
             NG(RNGB+SGNB)
             SVNUM; LFGS _ TYPB BOR (LFGS BAND CLNB) BOR SGNB
           END

           ORIF CHAR=$$ OR CHAR=$* THEN DO
             NG(BNOT(ADRB+LSTB+CLNB))
             LFGS BOR_ IF CHAR=$$ THEN DLRB ELSE ASTB
           END

           ORIF CHAR=$, THEN DO
             NG(RNGB+ADRB) 
             SVNUM; LFGS _ TYPB
           END

           ELSE GO ENDCH

           SELW(CHAR); CNT _ I.DGMAX

         END

         CHAR _ NXCHAR
       END

ENDCH:   IF LFGS BAND PARENS=LFTB THEN GO OUT
         SVNUM; SELW(0); BACKSP; RETURN @SEL(PTR)

OUT:     LPTR _ TEMP
        IF (LFGS<==0) BAND LSTB=0 THEN GO LAB
        NXNSP; BACKSP; WDSTOR(3,OUT)  !LEAVES LPTR BEFORE TERM
        IF INWD(0)=^'ALL' THEN RETURN 0; GO OUT


%SELW (X)

!  SUBELEMENT WRITE WITH OVERFLOW CHECK

IF INC SELP>SELLIM THEN ERR(LSTLNG)
SEL(SELP) _ X; RETURN

END SELW


%SVNUM

!  CALLED AT : ( ) + - , (BEFORE SETTING STATE BIT) AND AT
!  TERMINATOR, TO STORE NEGATIVE OF LKEY/INTEGER PRECEDING, IF ANY.  
!  %FRL ACCUMULATED NUMBER IN LVAL, WITH LKEY DOT IGNORED
D NO. OF DIGITS PAST DOT = 3-CNT.
!  MAY BE $ OR CURRENT LINE DOT OR NO LKEY AFTER );  IN ANY OTHER
!  CASE, ABSENCE OF DIGIT IS ILLEGAL.
!  0 ILLEGAL EXCEPT AFTER SIGN.

         IF LFGS BAND DLRB THEN RETURN  !PREVIOUSLY DISALLOWED $DIGIT
         IF LFGS BAND DGTB=0 THEN DO
           IF LFGS BAND RGTB THEN RETURN
           IF LFGS BAND DOTB AND TYPB#RNGB THEN [SELW($.); RETURN]
           GO OUT
         END
         IF LVAL=0 AND LFGS BAND SGNB=0 THEN GO OUT
         SELW ((LVAL<==0) * (IF LFGS BAND (SGNB+ASTB) THEN 1 ELSE &
           IF LFGS BAND DOTB THEN PWR10(CNT) ELSE PWR10(DDGMAX))*-1)
         RETURN

END SVNUM

END FRL

END FRNG

END CSCAN


%CEXU

!  EXECUTES COMMAND PF.CNUM.
!  WHEN FALL THRU TO END OF CASE STATEMENT, ALT MODE MUST BE OFF
!  (BECAUSE OF SUBSEQUENT BRANCH TO NEWCOM:).
!  FIXUP LOCATION SHOULD NOT INCLUDE OFFALT (WILL BE OFF WHEN 
!  GO ^FIXUP).

LOCAL %PRGCHK, %OKAY, %UNPKTK
LOCAL %INRANG, %INLIST, %INTXL
LOCAL %MRGINP, %SET.INCR, %I.NXLNUM, %NXLNUM
LOCAL %MKDL, %DELMKD, %UNMKDL
LOCAL %LIST.PAR, %XLKLN, %BCD, %INTKEY
LOCAL %ANS

LOCAL LOKEY      !1ST KEY OF RANGE
LOCAL HIKEY      !LAST ALLOWABLE KEY
LOCAL INCR       !RANGE INCREMENT 
LOCAL LONUM      !1ST DICT. POSITION TO BE AFFECTED BY NEW RANGE
LOCAL HINUM      !POSITION OF 1ST LINE BEYOND AFFECTED RANGE IN PROG.
LOCAL TXINCT     !TEXT INPUT COUNT (NO. LINES ENTERED)
LOCAL MXINCT     !MAXIMUM TEXT INPUT COUNT

LOCAL LSTCNT     !NO. LINES SPECIFIED IN LINE LIST
DEF RNGMX AS 10  !MAX NO. OF SUBRANGES IN LINE LIST

LOCAL I, J, WD(), TEMP
LOCAL OPNERR:, LNERRA:, LNERRB:, HERE:, LOAD.B:, COP.B:
LOCAL COP.C:, LOADFX:, COPFX:, ENTFX:, MERGN:
LOCAL %SET.INFN


         DO PF.CNUM OF CWDCNT


K.ENT:   INRANG(1)
         FIXUP _ ENTFX     !== FIXUP TO NEWCOM UNTIL LINE HAS BEEN ENTERED
         EIF EL.ID(1)=LKY.ID THEN INTXL    !LPTR IS OK

         ORIF INCR<0 THEN DO   !NO INCREMENT - AT SIGN PROMPT
           PRMNUM _ K.PAT
           LOOP DO
             GETSTR(CFN); WHILE NXCHAR#CARRET; BACKSP; INTXL
           END
         END
  
         ELSE DO    !INCREMENT - LINE KEY PROMPT
           PRMNUM _ K.PLK; TEMP _ LOKEY
ENT.B:     PRMKEY _ BCD(TEMP); GETSTR(CFN)
           IF NXCHAR#CARRET THEN DO
             BACKSP; INTXL
             IF TEMP +_ INCR <= HIKEY THEN GO ENT.B
           END
         END

         OFFALT
ENTFX:   PF.DOT _ MRGINP


LOCAL LOAD.C:

K.MERG: OFFALT     !SINGLE LINE ENTER FROM FILE
        SETRWE(SET.INFN,MERGN); FIXUP _ LOAD.C; ONALT
        LOOP DO
          GETSTR(INFN)
          IF NXNSP#CARRET THEN DO
            BACKSP; PF.CNUM _ K.ENT; CSCAN
            INRANG(1); IF EL.ID(1)#LKY.ID THEN ERR(BDLRNG)
            INTXL; OFFALT; PF.DOT _ MRGINP; ONALT
          END
        END

MERGN:  LNGCHK; OFFALT; GO LOAD.C

LOAD.C: CLOSE(INFN)


K.DO:   OFFALT; INFN _ OPEN(EL(1),INPUT+SEQUEN+CHARACTER,OPNERR,2)
        CLOSE(CFN<==INFN); SETRWE(CFN,CFNEOF)


K.FAST: K.LIST: &
         IF EL.ID(1)=FID.ID THEN DO
           ELID(1) <=> ELID(2)      !MOVE FID INFO; ZERO LIST ID
           EL(2) _ EL(1)            !FOR %INLIST
         END
         GO FAST


K.COPY: K.MOVE: &
         EIF EL.ID(1)=LST.ID THEN DO
FAST:      INLIST(1)
           EIF EL.ID(2)#RNG.ID THEN DO    !LINE LIST TO FILE OR TEL
             OFFALT
             IF OUTFN _ IF ELID(2)=0 THEN TEL ELSE &
              OPEN(EL(2),OUTMSG+SEQUEN+CHARACTER,OPNERR,2)#TEL THEN OKAY
             FIXUP _ COPFX
             ONALT
             [I;J] _ DOUBLE LIST.PAR
             REPEAT LSTCNT DO
               NXLNUM
               OUTCNT _ IF PF.CNUM=K.LIST THEN BIGNUM ELSE LLEN
               DO PF.CNUM OF K.COPY:K.MOVE
  K.MOVE:        MKDL(LNUM)
  K.COPY:        NULL
  K.LIST:        OUTKEY(0,I,J)
  K.FAST:        IF OUTFN#TEL THEN PLNKEY ELSE OUTKEY(0,0,0)
               END
               UNPKTK(0,LNERRA)
             END
             OFFALT
             CLOSE(OUTFN); IF PF.CNUM=K.MOVE THEN GO DELA
             IF OUTFN=TEL THEN [PF.DOT _ LNUM; IF PF.CNUM=K.LIST THEN PUT(CARRET)]
           END


           ELSE DO           !LINE LIST TO RANGE
             INRANG(2)
             OFFALT
             REPEAT LSTCNT DO
               NXLNUM
               IF PF.CNUM=K.MOVE THEN DO
                 IF NOT(LONUM<=LNUM<HINUM) AND PF.KEYD(LNUM)>0 THEN DO
                 !IF OUTSIDE RANGE AND NOT ALREADY MARKED FOR DELETION:
                   INC MXINCT; MKDL(LNUM)
                 END
               END
               IF TXINCT=MXINCT THEN ABERR(NOROOM)
               SCR(INC TXINCT) _ PF.CPD(LNUM)
             END
             IF PF.CNUM=K.MOVE THEN DO     !SET UP FOR MRGINP
               LONUM _ DELMKD(1,LONUM-1)+1
               PF.NLINES _ DELMKD(HINUM,PF.NLINES)
             END
             PF.DOT _ MRGINP
           END
         END


         ELSE DO
           OFFALT
           SETRWE(SET.INFN,COP.B); IF PLNCHK(INFN) THEN ABERR(BDLNFL)
!* NOTE: IF ADD FILE-TO-FILE, MUST MOVE FOLLOWING ASSIGNMENT
           FIXUP _ COP.C
           ONALT
           EIF EL.ID(2)=RNG.ID THEN DO       !FILE TO RANGE
             INRANG(2)
!* NOTE: NOROOM ERR IF INCR>=0 AND LINE KEY>HIKEY (MXINCT EXCEEDED)
             LOOP [GETSTR(INFN); INTXL]
COP.B:       LNGCHK; OFFALT
             PF.DOT _ MRGINP
COP.C:       CLOSE(INFN)
           END


           ELSE DO       !FILE TO FILE
             ERR(NOTIMP)
           END
         END


K.MOD: &
K.EDIT:  INLIST(1); OUTFN _ TEL; PRMNUM _ K.PLK
         REPEAT LSTCNT DO
           PRMKEY _ PF.KEYD(NXLNUM)
           OUTCNT _ LLEN; UNPKTK(CHPT(IMAGE,-1),LNERRB)
EDIT.A:    IF PF.CNUM=K.EDIT THEN [OUTKEY(0,0,0); PRINTC(IMAGE)]
           GETSTR(TEL)
           IF NXCHAR#CARRET THEN DO
             BACKSP
             OFFALT
             PF.CPD(PF.DOT _ LNUM) _ PF.WTLIN(LPTR)
             ONALT
           END
         END
         OFFALT


K.DEL: K.CLR: &
         IF EL.ID(1)=0 THEN DO     !CLEAR
           IF ANS('ALL')=YES THEN DO
             OFFALT;  PF.CLEAR;  GO NEWCOM
           END ELSE OFFALT

         END ELSE DO     !DELETE SPECIFIED LINES
           INLIST(1)
           OFFALT
           REPEAT LSTCNT MKDL(NXLNUM)
DELA:      PF.NLINES _ DELMKD(1,PF.NLINES)
         END


K.REN: &
! WILL NOT MOVE OR DELETE LINES! &
         IF ELID(1)=RNG.ID THEN DO
           ELID(1) <=> ELID(2)     !MOVE RANGE INFO, ZERO LIST ID
           EL(2) _ EL(1)           !FOR %INLIST
         END
         IF INLIST(1)>1 THEN GO PCMDL  !PCMDL IS IN %CSCAN
         IF ELID(1)#0=ELID(2) THEN DO
           !REN ADR1:ADR2 - ASSUME AS KEY(ADR1):KEY(ADR2)
           !MXINCT CHECK NOT NEEDED
           INCR _ -1
           LOKEY _ INTKEY(LONUM _ LTBL(1))
           HIKEY _ INTKEY((HINUM _ LTBL(1)+LSTCNT)-1)
         END ELSE [INRANG(2); IF LSTCNT>MXINCT THEN ERR(CNTREN)]
         IF NOT(LONUM>= LNUM _ LTBL(1) >=HINUM-LSTCNT) THEN ERR(CNTREN) 
         TXINCT _ LSTCNT; SET.INCR; DEC LNUM
         OFFALT
         REPEAT LSTCNT PF.KEYD(INC LNUM) _ BCD(LOKEY <== LOKEY+INCR)


K.RUN:   IF PF.RELOK THEN CMPDON ELSE GOSEG(OCT 634657.000000,0)  !SFO


K.OPEN:  OFFALT
         DO PF.OPEN(EL(1)) OF -1:1
-1:      ERR(NOTIMP)  !TEL
0:       GO OPNERR  !DIDN'T OPEN IT
         END
         OKAY


K.QUIT:  OFFALT; GO QUIT
QUIT:    PF.CLOSE; CLOSE.ALL; ONALT; EXIT


         END
         RETURN


OPNERR:  IF ERRNUM=CORERR THEN EXERR(NOCORE)
         IF ERRNUM>FNFERR THEN DO
           PRINT('CANNOT OPEN '); WFID(FIDP); PUT(CARRET)
         END
         ABERR(FILERR(ERRNUM))

LNERRA:  OFFALT; PF.DOT _ LNUM; ONALT   !ERROR LINE = DOT
         IF OUTFN#TEL THEN UNPKTK(IF K.COPY#PF.CNUM#K.MOVE THEN &
           OUTKEY(FREEPTR,I,J) ELSE FREEPTR, HERE)
HERE:    ABERR(LNLONG)

COPFX:  IF OUTFN#TEL THEN [CLOSE(OUTFN); DELETE(-FIDP)]
         IF PF.CNUM=K.MOVE THEN UNMKDL
         GO NEWCOM

LNERRB:  MSG(LNLONG); MSG(EDILNG); GO EDIT.A

%SET.INFN
LOCAL INERR:

        LOOP DO
         IF INFN _ OPEN(EL(1),INPUT+SEQUEN+CHARACTER,INERR,2) &
          =TEL THEN ERR(NOTIMP); OKAY; RETURN INFN
INERR:   IF ERRNUM#FNFERR OR EXTQ(FIDP)=YES THEN GO OPNERR
         EXTQ(FIDP) _ YES; EXTARG(FIDP) _ 0
        END

END SET.INFN


%PRGCHK
IF PF.NLINES=0 THEN ERR(NOPROG); RETURN
END PRGCHK

%OKAY
IF CFN=TEL THEN MSG("OK$"); RETURN
END OKAY


%INRANG (I)

!  I IS INDEX INTO EL.ID & EL ARRAYS FOR LINE RANGE INFO. EL(I) IS
!  ADDRESS OF WD BEFORE 1ST WD OF SUBELEMENT LIST,
!  UNLESS EL.ID(I) IS 0, TO INDICATE DEFAULT RANGE OF 1(1) (RENUMBER).
!  ALSO SPECIAL RENUMBER CASE: IF UPPER LIMIT OMITTED, IS LAST LINE
!  IN LIST TO BE RENUMBERED.
!  CALCULATES AND STORES RANGE PARAMETERS: LOKEY, HIKEY, INCR (-1
!  IF NONE), LONUM, HINUM, MXINCT.
!  INITS TXINCT & CURSOR FOR %INTXL
!  NOTE: NEGATIVE INTEGER REPRESENTS LINE KEY.

LOCAL CONT:, NXT:, NXT1:

         IF EL.ID(I)=0 THEN [LOKEY _ INCR _ PWR10(D.DGMAX); GO INRA]
         WD _ EL(I)
         LOKEY _ -WD(1); INCR _ -1
         IF WD(2)=0 THEN HIKEY_LOKEY ELSE DO
           IF WD(2)=$: THEN HIKEY_-WD(3) ELSE DO
             INCR _ -WD(3)    !WD(2) IS (, WD(4) IS )
             IF HIKEY _ -WD(5)=0 THEN DO    !CREATE UPPER LIMIT KEY
INRA:          IF PF.CNUM=K.REN THEN LNUM _ LTBL(1)+LSTCNT ELSE DO
                 XLKLN(LOKEY,CONT); INC LNUM
                 ! LNUM IS 1ST PROG. LINE ABOVE LOWER LIMIT
               END
CONT:          HIKEY _ IF LNUM >PF.NLINES THEN LKY.MAX ELSE &
                 INTKEY(LNUM)-1
             END
           END
           IF HIKEY < LOKEY THEN ERR(BDLRNG)   !OLD CCS DISALLOWED =
         END

         XLKLN(LOKEY,NXT)
NXT:     LONUM _ LNUM
         XLKLN(HIKEY,NXT1); INC LNUM
NXT1:    HINUM _ LNUM
         ! HINUM-LONUM IS NO. OF LINES CURRENTLY IN RANGE
         MXINCT _ NLMAX MIN 1+(HIKEY-LOKEY)/(IF INCR<0 THEN 1 &
           ELSE INCR) MIN HINUM-LONUM+NLMAX-PF.NLINES

         TXINCT _ 0; RETURN

END INRANG


%INLIST (I)

!  IF NO PROGRAM, ERROR.
!  I IS INDEX INTO EL.ID & EL ARRAYS FOR LINE LIST INFO.
! EL.ID(I) IS LST.ID OR 0: IF LST.ID, EL(I) IS
!  ADDRESS OF WD BEFORE 1ST WD OF SUBELEMENT LIST; IF 0, OR
!  IF EL.ID(I) IS 0, INDICATES DEFAULT LIST OF *1:$.
!  CALCULATES AND STORES LIST PARAMETERS AS FOLLOWS:
!    LSTCNT    TOTAL NO. OF LINES SPECIFIED
!    LTBL(1)   LINE NO. OF 1ST LINE OF 1ST SUBRANGE (LIST CONSTRUCTION
!              IS SUBRANGES SEPARATED BY COMMAS)
!    LTBL(2)   NO. OF LINES IN THIS SUBRANGE (>=0)
!    LTBL(3)   LINE NO. OF 2ND SUBRANGE (IF ANY)
!    ETC.
!  RETURNS NO. OF SUBRANGES READ.

LOCAL %NXADR
LOCAL MTCHFG, SAVE, CNT
LOCAL TERM

         PRGCHK
         IF EL.ID(I)=0 OR EL(I)=0 THEN DO     !ALL LINES
           LSTCNT _ LTBL(2) _ PF.NLINES; LTBL(1) _ CNT _ 1
         END ELSE DO
           WD _ EL(I)
           CNT _ LSTCNT _ PTR _ I _ 0
           LOOP DO
             IF INC CNT>RNGMX THEN ERR(LSTLNG)
             SAVE _ 0; LTBL(INC I) _ NXADR
             IF TERM=$: THEN DO
               IF LTBL(INC I) _ NXADR-LTBL(I)+1 <0 THEN ERR(BDLRNG)
             END ELSE LTBL(INC I) _ MTCHFG
             LSTCNT +_ LTBL(I)
             WHILE TERM=$,
           END
         END

         I.NXLNUM; RETURN CNT

%NXADR

!  RETURNS LINE NO. CORRESPONDING TO NEXT LINE ADDRESS (BEGINNING
!  AT INC PTR). LEAVES PTR AT : , OR 0, WITH WD(PTR) IN TERM.
!  NOTE: IF NEGATIVE SUBELEMENT, IS INTEGER REPRESENTING LINE KEY OR 
!  DISPLACEMENT.

LOCAL NX1:, LKEY

         MTCHFG _ YES; LKEY _ 0
         EIF WD(INC PTR)<0 THEN DO
           XLKLN(LKEY_-WD(PTR),NX1)    !STORES RESULT IN LNUM
           GO NX2
NX1:       MTCHFG _ NO   !IS 1+GREATEST LINE NO. WITH SMALLER KEY
         END
         ORIF WD(PTR)=$. THEN LNUM_PF.DOT
         ORIF WD(PTR)=$$ THEN LNUM _ PF.NLINES
         ELSE !IS $*! IF LNUM_-WD(INC PTR)>PF.NLINES THEN ERR(BDLRNG)

NX2:     IF TEMP_[WD(INC PTR)=$-] OR WD(PTR)=$+ THEN DO
           IF MTCHFG=NO THEN ERR(BDLRNG)
           INC PTR; LNUM +_ IF TEMP THEN WD(PTR) ELSE -WD(PTR)
           IF NOT(1<=LNUM<=PF.NLINES) THEN ERR(BDLRNG)
           INC PTR
         END ELSE DO     !NO DISPLACEMENT
           IF SAVE#0 AND MTCHFG=NO THEN DEC LNUM
         END

         IF LKEY=0 THEN LKEY _ INTKEY(LNUM)
         IF SAVE=0 THEN SAVE _ LKEY ELSE IF SAVE>LKEY THEN ERR(BDLRNG)
         TERM _ WD(PTR); RETURN LNUM

END NXADR

END INLIST


%I.NXLNUM

!  INITIALIZES %NXLNUM TO RETURN 1ST LINE NO. IN LTBL
!  CALLED BEFORE %INLIST RETURN.

LOCAL CNT, PTR

CNT _ -1; PTR _ 1; RETURN

%%NXLNUM

!  RETURNS (AND STORES IN LNUM) NEXT LINE NO. SPECIFIED IN LTBL.
!  BEWARE OF OVERCALLING (MAX. OF LSTCNT CALLS AFTER I.NXNLUM)!!

IF INC CNT = LTBL(PTR+1) THEN DO
  WHILE LTBL(1+PTR+_2)=0 THEN NULL; CNT _ 0
END
RETURN LNUM _ LTBL(PTR)+CNT

END I.NXLNUM


%INTXL

!  WRITE LINE AT LPTR ON PF AND STORE CORRESPONDING PF.CPD ENTRY
!  IN SCR ARRAY.
!  OFFALT PROTECTS AGAINST TXINCT BEING 1>NO. OF SCR ENTRIES.

         IF TXINCT = MXINCT THEN &
         ABERR(IF PF.CNUM=K.ENT THEN PTROOM ELSE NOROOM)
         OFFALT; SCR(INC TXINCT) _ PF.WTLIN(LPTR); ONALT
         RETURN

END INTXL


%MRGINP

!  MERGE THOSE LINES WHICH HAVE PF.CPD ENTRIES IN SCR ARRAY.
!  (TXINCT LINES IN ALL).  1ST KEY IS LOKEY; INCR IS CALCULATED IF
!  NEVER SPECIFIED.  1ST LNUM IS LONUM; LOKEY AND LONUM ARE UPDATED.
!  RETURNS NO. OF LAST LINE MERGED, POSSIBLY USED TO SET PF.DOT
!  (THUS DOES NOTHING BUT RETURN PF.DOT IF TXINCT IS 0.)

LOCAL MVCNT, MVDIS

         IF TXINCT=0 THEN RETURN PF.DOT
         SET.INCR
         MVCNT _ PF.NLINES-HINUM+1
         IF MVDIS _ LONUM+TXINCT-HINUM >0 THEN DO
!  MOVE DOWN LOWER PART OF EACH DICTIONARY,STARTING WITH LAST ENTRY
!  (PF.NLINES), ENDING WITH BEGINNING OF LOWER PART (HINUM).
           PTR _ PF.NLINES+1
           REPEAT MVCNT DO
             PF.CPD(PTR+MVDIS) _ PF.CPD(DEC PTR)
             PF.KEYD(PTR+MVDIS) _ PF.KEYD(PTR)
           END
         END ELSE IF MVDIS<0 THEN DO     !MOVE UP LOWER PART
           MOVE MVCNT FROM @PF.CPD(HINUM) TO @PF.CPD(LONUM+TXINCT)
           MOVE MVCNT FROM @PF.KEYD(HINUM) TO @PF.KEYD(LONUM+TXINCT)
         END
         DEC LONUM; I _ 0
         WHILE INC I <= TXINCT THEN DO
           PF.CPD(INC LONUM) _ SCR(I)
           PF.KEYD(LONUM) _ BCD(LOKEY<==LOKEY+INCR)
         END
         PF.NLINES +_ MVDIS
         RETURN LONUM
END MRGINP


%SET.INCR

! COMPUTE INCREMENT IF NECESSARY.

IF TXINCT>1 AND INCR<0 THEN DO
  TEMP _ (HIKEY-LOKEY)/(TXINCT-1) +1
  I _ D.DGMAX+1
  WHILE TEMP <= PWR10(DEC I) THEN NULL; INCR _ PWR10(I)
END
RETURN

END SET.INCR


%UNPKTK (DEST, LAB:)

!  WRITES TEXT OF LINE LNUM ON OUTFN IF DEST IS 0 ELSE AT
!  CHAR PTR DEST.  DECS OUTCNT WITH EACH WRITE;
!  GOES TO LAB IF <0 (LINE TOO LONG).
!  RETURNS DEST (IS ADVANCED CHAR PTR IF NOT 0)
!  IMPLEMENTATION DEPENDENCY: PHASE 2 INPUT MUST BE FORMATTED,
!  SO LABEL SEPARATION IS UNNECESSARY.

LOCAL LAST, PP

         PP _ PF.RDLIN(LNUM)
         LAST _ 0
         WHILE (TEMP _ NCHV PP) # EOLIT THEN DO
           IF DEST THEN NCHV DEST _ TEMP ELSE DO
             IF LAST=LNFEED THEN DO
               REPEAT TABSP+LBL.DGMAX+1 [W(OUTFN,$ ); DEC OUTCNT]
             END
             LAST _ W(OUTFN,TEMP)
           END
           IF DEC OUTCNT<0 THEN DO
             IF DEST THEN [CHV DEST_EOLIT; PCHV DEST_CARRET]
             GO LAB
            END
         END
         IF DEST THEN REPEAT 3 NCHV DEST _ EOLIT   !FILL LAST WORD
         RETURN DEST

END UNPKTK


%OUTKEY (DEST, IFS, DFS)

! WRITES PRMKEY (LINE KEY IN DICTIONARY FORM) PLUS A BLANK, ON OUTFN IF
! DEST IS 0 ELSE AT CHAR PTR DEST.  DECS OUTCNT WITH EACH WRITE.  
!  PRMPTKEY CALLED FROM %PRMPT; PRMKEY SET BEFORE %GETSTR CALL.
! IFS IS INTEGER FIELD SIZE (BLANKS IN PLACE OF LEADING ZEROES); DFS
! IS DECIMAL FIELD SIZE (BLANKS IN PLACE OF TRAILING ZEROES).
! IFS=DFS=0 SUPPRESSES THESE ZEROES.
! RETURNS DEST (IS ADVANCED CHAR PTR IF NOT 0).

LOCAL %OUT
LOCAL FLG, KEY, TEMP

         PRMKEY _ PF.KEYD(LNUM)

%%PRMPTKEY (DEST, IFS, DFS)

         FLG _ NO; KEY _ PRMKEY SHL (BPW-(CNT_DGMAX)*4)
         WHILE DEC CNT>=D.DGMAX THEN DO      !PRINT INTEGER DIGITS
           [TEMP;KEY] _ [0;KEY] DSHL 4
           IF TEMP THEN FLG _ YES  !SUPPRESS LEADING ZEROES
           IF FLG THEN OUT(TEMP+$0) ELSE IF CNT-D.DGMAX<IFS THEN OUT($ )
         END
         IF KEY THEN DO  !PRINT DEC. DIGITS
           OUT($.)
           WHILE KEY THEN DO
             [TEMP;KEY] _ [0;KEY] DSHL 4; OUT(TEMP+$0); DEC DFS
           END
         END ELSE IF DFS THEN INC DFS !NO DEC. PART - BLANK DOT POSITION
         REPEAT DFS OUT($ )
         OUT($ ); RETURN DEST

%OUT (X)
  IF DEST THEN NCHV DEST _ X ELSE W(OUTFN,X); DEC OUTCNT; RETURN
END OUT


%PLNKEY

! MACHINE DEPENDENT.  SPECIAL FILE OUTPUT FOR SAVE AND FAST.
! CONVERTS PF.KEYD(LNUM) TO CHARS RIGHT-JUSTIFIED WITH LEADING $0'S,
! WITH TRAILING 0'S SUPPRESSED.
! STORES RESULT AT PLN & CALLS PLNW TO WRITE KEY.

LOCAL I, PLN(0:1)
DEF NXRDG AS ((KEY<==KEY SHR 4) BAND OCT 17)

         PLN(0) _ PLN(1) _ ^'00000'; TEMP _ CHPT(PLN+2)
         KEY _ PF.KEYD(LNUM); I _ 0
         WHILE KEY BAND OCT 17=0 THEN DO
           KEY _ KEY SHR 4
           IF INC I=DDGMAX THEN GO INT
         END
         REPEAT DDGMAX-I PCHV TEMP _ NXRDG+$0   !OUT DEC. PART
         PCHV TEMP _ $.
INT:     REPEAT IDGMAX PCHV TEMP _ NXRDG+$0
         I _ 1
         IF PLN(0)=^'00000' THEN PLN(0) _ PLN(1) ELSE INC I
         PLNW(OUTFN,PLN,I); RETURN

END PLNKEY


END OUTKEY


%MKDL (LNUM)

!  MARK LINE WITH NUMBER LNUM FOR DELETION (TURN ON SIGN BIT)

PF.KEYD(LNUM) BOR_ SGNBIT; RETURN

END MKDL


%DELMKD (LO, HI)

!  DELETE LINES MARKED FOR DELETION (SIGN BIT ON) IN RANGE OF LINE
!  NUMBERS LO TO HI; I.E., CRUNCH UNMARKED LINES.
!  RETURNS INDEX TO LAST OF CRUNCHED LINES (LO-1 IF ALL MARKED).
!  IF HI EXCEEDS LO, RETURNS LO-1; WHEN CALLED IN MOVING
!  LIST TO RANGE, WILL WORK OK IF LONUM IS 0 OR HINUM IS PF.NLINES+1.
!  ADJUST PF.DOT IF IN AFFECTED RANGE.

LNUM _ I _ LO-1
WHILE INC LNUM<=HI THEN DO
  IF PF.KEYD(LNUM)>0 THEN DO
    PF.KEYD(INC I) _ PF.KEYD(LNUM)
    PF.CPD(I) _ PF.CPD(LNUM)
  END
  IF LNUM=PF.DOT AND PF.DOT _ I =0 THEN INC PF.DOT
END
RETURN I

END DELMKD


%UNMKDL

!  UNMARK ALL LINES MARKED FOR DELETION (TURN OFF SIGN BIT).

LNUM _ 0
REPEAT PF.NLINES &
  PF.KEYD(INC LNUM) BAND_ BNOT SGNBIT
RETURN

END UNMKDL


%LIST.PAR

!  DETERMINES LINE KEY FIELD SIZE BY
!  EXAMINING KEYS OF ALL LINES SPECIFIED IN LTBL AND RETURNS DOUBLE
!  ARITHMETIC EXPRESSION SPECIFYING MAX. NO. OF INTEGER DIGITS
!  AND MAX. NO. OF DECIMAL DIGITS IN EXAMINED KEYS.
!  ALSO SETS TABSP (LIST INDENTATION FOR UNPKTK).
!  RETURNS ZEROES IF COMMAND IS NOT LIST.
!  ASSUMES I.NXLNUM PREV. CALLED, AND CALLS AGAIN BEFORE RETURN.

         I _ J _ TABSP _ 0
         IF PF.CNUM=K.LIST AND LSTCNT#0 THEN DO
           TEMP _ 0; REPEAT LSTCNT TEMP BOR_ PF.KEYD(NXLNUM)
           I.NXLNUM
           WHILE J<D.DGMAX AND TEMP BAND HEX F=0 THEN DO
             TEMP _ TEMP SHR 4; INC J   !J=NO. OF TRAILING DECIMAL 0'S
           END
           WHILE TEMP THEN DO
             TEMP _ TEMP SHR 4; INC I    !I=TOTAL NO. DIGITS
           END
           I _ 0 MAX I-J_(D.DGMAX-J)   !ALLOWS FOR LEADING DECIMAL 0'S
           TABSP _ I+J+1      !ADD 1 FOR BLANK
           IF J>0 THEN INC TABSP      !ADD 1 FOR ., IF ANY
           IF OUTFN=TEL THEN PUT(CARRET)   !FOR BOB RASMUSSEN
         END
         RETURN [I;J]

END LIST.PAR


%XLKLN (ILKEY,LAB:)

!  TRANSFORMS ILKEY (LINE KEY IN INTEGER FORM) TO ORDINAL LINE
!  NO., STORING RESULT IN LNUM.  IF EXACT MATCH, RETURNS; IF NOT,
!  RESULT IS 1+GREATEST LINE NO. WITH SMALLER LKEY & GOES TO LAB
!  RATHER THAN RETURN.

         LNUM _ 0; TEMP _ BCD(ILKEY)
         WHILE INC LNUM<=PF.NLINES THEN DO
           IF TEMP <= PF.KEYD(LNUM) THEN DO
             IF TEMP=PF.KEYD(LNUM) THEN RETURN; GO LAB
           END
         END
         GO LAB

END XLKLN


%BCD (ILKEY)

!  TRANSFORMS ILKEY (LINE KEY IN INTEGER FORM) TO BCD (DICTIONARY)
!  FORM
!  AND RETURNS RESULT.

LOCAL TEMP, I

         TEMP _ 0; CNT _ -4
         WHILE ILKEY THEN DO
           [ILKEY;I] _ ILKEY DIVMOD 10
           TEMP BOR_ (I SHL CNT +_ 4)
         END
         RETURN TEMP

END BCD


%INTKEY (LNUM)

LOCAL TEMP, I

!  TRANSFORMS LINE KEY CORRESPONDING TO LNUM FROM BCD (DICTIONARY
!  FORM) TO INTEGER FORM AND RETURNS RESULT.

         TEMP _ (I_PF.KEYD(LNUM)) BAND HEX F; CNT _ 0
         WHILE I _ I SHR 4 > 0 THEN DO
           TEMP _ TEMP + (I BAND HEX F) * PWR10(INC CNT)
         END
         RETURN TEMP

END INTKEY


%ANS (QUES)

!  PRINTS QUES (IF COMMAND FILE TEL), READS ANSWER AND RETURNS 1 IF YES,
!  0 IF NO.

         IF CFN=TEL THEN [MSG(QUES); PRMNUM _ K.PQM]
         LOOP DO
           GETSTR(CFN)
           IF LWALPH(CHAR _ NXNSP) THEN XLWUP(CHAR)
           IF NOT($Y#CHAR#$N) THEN RETURN [CHAR=$Y]
           IF CFN#TEL THEN ERR(BDANS)
           MSG('WHAT')
         END

END ANS

END CEXU


%OUTDEC (N)

! CONVERTS N TO DECIMAL AND WRITES IT ON OUTFN

LOCAL BUF(12)

IF N < 0 THEN [W(OUTFN,$-); N - _]
LOOP [FOR I _ 1 BY 1 TO 12; [N; BUF(I)] _ N DIVMOD 10; WHILE N # 0]
LOOP [W(OUTFN,BUF(I)+$0); WHILE DEC I > 0]
RETURN

END OUTDEC


%ALPH (X)
! NOT MACRO SO X CAN HAVE SIDE EFFECT (I.E., NCHV)
RETURN [UPALPH(X) OR LWALPH(X)]
END ALPH

END CCS
   	@pW