^^
.number 0
.justify
.fill
.left margin 0
.right margin 70
.spacing 1
.paper size 58,72
.title SFORTRAN DEBUGGER
.figure 1

.blank
.break
.skip 10
.center
SFORTRAN DEBUGGER
.center
SPECIFICATION
.skip 10
.spacing 2
I###-#Command Specification
.break
II##-#Command Syntax
.break
III#-#Debugger Structure Abstraction
.break
IV##-#Algorithms
.spacing 1
.subtitle COMMAND SPECIFICATION
.page
I. COMMAND SPECIFICATION
.skip 2
^&The Debugger Context\&
.paragraph
There are two contexts which exist in the debugger which allow
proper interpretation of most debug commands.
One context is the subroutine to which a variable name
refers.
The other context is the section of the
program to which a line number refers.
Initially, the variable name context is the main program and
the line number context is the section of the program with increasing
line numbers containing the main program.
Two commands exist which refer directly to these contexts.
One for setting them and the other for listing them.
Whenever program execution stops by breakpoints, escapes, errors, PAUSE or
STOP statements, both contexts are set to the contexts contain the
statement where the stop occurred.
.skip 1
.center
DEBUG [ line-address | subroutine name ]
.paragraph
If a line address is given as the parameter of the DEBUG command, only
the variable name context can be changed since line addresses are
interpreted as refering to the current line number context.
If a subroutine name (or function name) is used, both the
variable name and the line number contexts can be changed since
the subroutine can be in a section of the
program which differs from the section defining the line
number context.
If no parameter is given, both contexts are reset to their initial
setting.
Note that the subroutine which defines the variable name context will
always be in the section of program defining the line number context.
.skip 1
.center
LIST DEBUG
.paragraph
Lists the current debug contexts.
The subroutine name which defines the variable name context will be listed.
.skip 2
.test page 6
^&DISPLAY Command\&
.paragraph
THe format of the DISPLAY command is
.skip 1
.center
DISPLAY display-list
.skip 1
where display-list is a list of scalar variable references, array variable
references with integer constant or integer scalar subscripts or
array variable names.
Elements in the display-list are
separated by commas.
Execution of the command causes the values of the elements to be
displayed in their declared mode (integer, real, logical etc.)
or in the mode specified by the mode command whose format is
.skip 1
.center
MODE { ASCII | OCTAL | DECLARED } variable-name-list
.paragraph
This command sets the display mode for all the variables in
variable-name-list.
Variable-name-list is a list of variable names (either scalar or array
without subscripts).
If the mode is set to ASCII, the variable  is interpreted as
containing five seven-bit characters per word.
If the mode is set to OCTAL, the variable is interpreted as an
unsigned octal number.
If the mode is DECLARED, the variable is returned to its declared
display mode.
.skip 2
.test page 6
^&SET Command\&
.paragraph
The SET command has the format
.skip 1
.center
SET set-list
.skip 1
where set-list is a list of FORTRAN assignments separated by commas.
The assignments have the following restrictions.
.break
.left margin 4
.skip 1
1. The left part must be either a scalar variable reference or
an array reference with integer scalar or constant subscripts.
.skip 1
2. The right part must be either a scalar variable reference, an array
reference with integer scalar or constant subscripts or a constant.
.skip 1
3. If the right part is not a constant, it must agree in type with the
left part.
.skip 1
4. If the right part is a string or logical constant, the left part
must be of type string or logical respectively.
.skip 1
5. For complex left parts, a constant right part must be two numeric
constants (defined in 6.), separated by commas and enclosed in parentheses.
.skip 1
6. For integer, real or double precision left parts, a constant
right part must be a numberic constant.
A numberic constant is either an integer, real or double precision constant.
.left margin 0
.skip 2
.test page 6
^&Execution Commands\&
.paragraph
The following four commands, along with the RUN command, initiate program
execution.
.skip 1
.center
GO [ line-address ]
.paragraph
This command causes program execution to begin at line-address.
If no line-address is given, execution begins at the first executable
statement in the main program.
.skip 1
.center
CONTINUE
.paragraph
This command causes program execution to begin where it last stopped
due to a breakpoint, a completed NEXT or STEP command, a recoverable
error or a PAUSE statement.
The continue command is used to resume program execution.
.skip 1
.center
NEXT [ integer ]
.paragraph
This command causes program execution to resume as in the CONTINUE command.
But it further limits execution of the program to the next n executed
statements at which point control returns to the debugger.
The parameter of the command specifies the value of n and if missing,
n defaults to the value of one.
.skip 1
.center
STEP [ integer ]
.paragraph
This command is similiar to the NEXT command with the additional feature
of typing the line address of each statement executed.
.skip 2
.test page 6
^&Program Flow Control\&
.paragraph
Two commands are available to control and examine the program flow.
They are the BREAK and TRACE commands.
They both specify sets of FORTRAN statements whose
execution should be identified.
They differ in what is done after identifying the statement to be executed.
BREAK returns control to the debugger command level and TRACE continues
with execution.
The statement identified will be the next statement to be executed.
The format of the commands are
.skip 1
.center
BREAK line-address-list [ variable-list ] [ @-integer ]
.center
TRACE line-address-list [ variable-list ] [ @-integer ]
.skip 1
where line-address-list are the statements whose execution should be
identified.
If ALL is used for the line-address-list, all the statements
in all the files which have been compiled and loaded in debug
mode will have their execution identified.
A statement whose line-address appears in a BREAK or TRACE command is
said to have a breakpoint or tracepoint at it.
.paragraph
The variable-list is a list of scalar variable references or ^&nondummy\&
array variable references with integer constant subscripts.
The values of these variables are displayed whenever the statement
having the breakpoint or tracepoint is identified as about to be
executed.
The variables in variable-list refer to variables in the current variable
context.
.paragraph
The integer after the @ specifies how often the reaching of a
breakpoint or tracepoint should be reported.
If not specified, the reaching of a breakpoint
or tracepoint is always reported.
Otherwise, reporting is done on every integer number of execution of
any statement specified in the command.
.break
Example:
.center
BREAK 10.1,100.2 @5
.skip 1
will break if 10.1 has been executed twice and 100.2 is about to be
executed for the third time.
.paragraph
If the statement has a breakpoint or tracepoint at it and
another is set, the new variable-list and @-integer ^&replace\&
those set by the previos BREAK or TRACE commands.
BREAK commands only replace breakpoints and TRACE commands only replace
tracepoints.
The breakpoints and tracepoints set with line address ALL can only be
changed by another BREAK or TRACE command with line address ALL.
The commands BREAK#ALL#@10 and BREAK#100.3 will cause a break
always to occur at 100.3 but breaks to occur after every tenth
execution of all other statements.
.paragraph
To remove a breakpoint or tracepoint, the commands used are
.skip 1
.center
NO BREAK [ line-address-list ]
.center
NO TRACE [ line-address-list ]
.skip 1
These commands removes the breakpoints or tracepoints at the
sttaements specified by line-address-list.
If ALL is used for the line-address-list, only the breakpoints
or tracepoints set with BREAK#ALL or TRACE#ALL are removed.
If no line-address-list is given, all breakpoints or tracepoints
are removed (including one set by ALL).
If there is no breakpoint or tracepoint at a specified statement,
no error message is given.
.paragraph
To determine what breakpoints or tracepoints are set, the commands
used are
.skip 1
.center
LIST BREAK [ line-address-list ]
.center
LIST TRACE [ line-address-list ]
.skip 1
The line-address-list is interpretted as in NO#BREAK with
ALL refering to only breakpoints set with BREAK#ALL and no line-address-list
refering to all breakpoints.
.skip 2
.test page 6
^&Reporting Variable Value Change\&
.paragraph
Two commands are avaiable to set breakpoints and tracepoints on variable
value change.
This allows reporting where and to what a variable value is changed.
The two commands are
.skip 1
.center
VALUE BREAK variable-list [ line-address-list ]
.center
VALUE TRACE variable-list [ line-address-list ]
.skip 1
The line-address-list and the variable-list have the same syntax as in
the BREAK and TRACE commands.
The variables in the variable-list are only displayed when their
value is changed.
The check to determine whether the value has changed is only made
at the statements specified by line-address-list.
If ALL is used as the line-address-list, the check is made at all
statements in routines compiled and loaded in debug mode.
If no line-address-list is given, the check is made at all
statements in the current subroutine defining the variable name context.
.paragraph
To remove value breakpoints and tracepoints, the commands used are
.skip 1
.center
NO VALUE BREAK [ variable-list ]
.center
NO VALUE TRACE [ variable-list ]
.skip 1
This command removes the breakpoints or tracepoints for the variables in
variable-list.
If variable-list is not given, all value breakpoints or tracepoints are
removed.
.paragraph
To determine which variables have value breakpoints or tracepoints,
the commands used are
.skip 1
.center
LIST VALUE BREAK [ variable-list ]
.center
LIST VALUE TRACE [ variable-list ]
.skip 2
.test page 6
^&CLOSE Command\&
.paragraph
The format of the CLOSE command is
.skip 1
.center
CLOSE [ (unit-list) | unit-list ]
.skip 1
where unit-list is a list of integer constants separated by commas
which represent FORTRAN I/O units.
The command causes the specified units to be closed in the sense of
the FORTRAN CLOSE statement.
If no unit-list is given, all open units
except 0, 1 and the command file are closed.
.page
^&Debugger Command Summary\&
.nojustify
.nofill
.skip 1
.spacing 2
DEBUG [ line-address | subroutine-name ]
LIST DEBUG
DISPLAY display-list
SET set-list
MODE { ASCII | OCTAL | DECLARED } variable-name-list
{ BREAK | TRACE } line-address-list [ variable-list ] [ @-integer ]
NO { BREAK | TRACE } [ line-address-list ]
LIST { BREAK | TRACE } [ line-address-list ]
VALUE { BREAK | TRACE } variable-list [ line-address-list ]
NO VALUE { BREAK | TRACE } [ variable-list ]
LIST VALUE { BREAK | TRACE } [ variable-list ]
GO [ line-address ]
NEXT [ integer ]
STEP [ integer ]
CONTINUE
CLOSE [ (unit-list) | unit-list ]
.spacing 1
.justify
.fill
.subtitle COMMAND SYNTAX
.page
II. COMMAND SYNTAX
.skip 2
This section gives complete, detailed syntax for all debugger commands.
The commands are defined by the nonterminal <commands>.
All nonterminals are defined except <line-number>, <variable-name>,
<integer>, <routine-name>, <number>, <single-quote-constant> and
<double-quote-constant>.
They are define as follows:
.skip 1
<line-number>#-#a decimal between .001 and 99999.999 with only three
decimal places.
.skip 1
<variable-name>#-#a FORTRAN variable name. May be greater than
six characters in length, but only the first six
characters are used.
.skip 1
<integer>#-#a positive or negative FORTRAN integer
constant.
.skip 1
<routine-name>#-#the name of a FORTRAN subroutine, function
or .MAIN. to signify the main program.
.skip 1
<number>#-#a FORTRAN integer, real or double precision
constant.
.skip 1
<single-quote-constant>#-#any sequence of characters
except single quote passed to the debugger by IOCS's GETLINE enclosed
in single quotes.
.skip 1
<double-quote-constant>#-#any sequence of characters
except double quote passed to the debugger by IOCS's GETLINE enclosed
in double quotes.
.skip 2
The following are the debugger syntax rules.
.nofill
.nojustify
.skip 2
.test page 9
<commands> ::= <break-command> | <trace-command> |
        <value-break-command> | <value-trace-command> |
        <no-break-command> | <no-trace-command> |
        <no-value-break-command> | <no-value-trace-command> |
        <list-break-command> | <list-trace-command> |
        <list-value-break-command> | <list-value-trace-command> |
        <debug-command> | <list-debug-command> |
        <display-command> | <set-command> | <mode-command> |
        <go-command> | <next-command> | <step-command> |
        <continue-command> | <close-command>
.skip 1
.test page 14
<break-command> ::= BREAK <flow-arguments>
<trace-command> ::= TRACE <flow-arguments>
<flow-arguments> ::= <line-address-list> <op-variable-list>
        <op-@-counter>
<line-address-list> ::= ALL | <line-list>
<line-list> ::= <line> | <line> <list-sep> <line-list>
<line> ::= <single> | <single>:<single>
<single> ::= . | $ | <line-number> | #<integer>
<list-sep> ::= ,
<op-variable-list> ::= <variable-list> | <null>
<variable-list> ::= <variable> | <variable> <list-sep> <variable-list>
<variable> ::= <variable-name> | <variable-name>(<integer-list>)
<integer-list> ::= <integer> | <integer>,<integer-list>
<null> ::=
<op-@-counter> ::= @ <integer> | <null>
.skip 1
.test page 4
<value-break-command> ::= VALUE BREAK <value-argument>
<value-trace-command> ::= VALUE TRACE <value-argument>
<value-argument> ::= <variable-list> <op-line-address-list>
<op-line-address-list> ::= <line-address-list> | <null>
.skip 1
.test page 2
<no-break-command> ::= NO BREAK <op-line-address-list>
<no-trace-command> ::= NO TRACE <op-line-address-list>
.skip 1
.test page 2
<no-value-break-command> ::= NO VALUE BREAK <op-variable-list>
<no-trace-break-command> ::= NO TRACE BREAK <op-variable-list>
.skip 1
.test page 2
<list-break-command> ::= LIST BREAK <op-line-address-list>
<list-trace-command> ::= LIST TRACE <op-line-address-list>
.skip 1
.test page 2
<list-value-break-command> ::= LIST VALUE BREAK <op-variable-list>
<list-value-trace-command> ::= LIST VALUE TRACE <op-variable-list>
.skip 1
.test page 2
<debug-command> ::= DEBUG <debug-argument>
<debug-argument ::= <single> | <routine-name> | <null>
.skip 1
.test page 1
<list-debug-command> ::= LIST DEBUG
.skip 1
.test page 5
<display-command> ::= DISPLAY <display-list>
<display-list> ::= <display-item> | <display-item>,<display-list>
<display-item> ::= <variable-name> | <variable-name>(<subscript-list>)
<subscript-list> ::= <subscript> | <subscript>,<subscript-list>
<subscript> ::= <variable-name> | <integer>
.skip 1
.test page 6
<set-command> ::= SET <set-list>
<set-list> ::= <assignment> | <assignment>,<set-list>
<assignment> ::= <display-item>=<value>
<value> ::= <display-item> | <number> | (<number>,<number>) |
        <single-quote-constant> | <double-quote-constant> |
        .TRUE. | .FALSE.
.skip 1
.test page 4
<mode-command> ::= MODE <mode-type> <variable-name-list>
<mode-type> ::= ASCII | OCTAL | DECLARED
<variable-name-list> ::= <variable-name> |
        <variable-name> <list-sep> <variable-name-list>
.skip 1
.test page 2
<go-command> ::= GO <go-argument>
<go-argument> ::= <single> | <null>
.skip 1
.test page 3
<next-command> ::= NEXT <op-integer>
<step-command> ::= STEP <op-integer>
<op-integer> ::= <integer> | <null>
.skip 1
.test page 1
<continue-command> ::= CONTINUE
.skip 1
.test page 4
<close-command> ::= CLOSE <close-argument>
<close-argument> ::= <unit-list> | (<unit-list>) | <null>
<unit-list> ::= <unit> | <unit> <list-sep> <unit-list>
<unit> ::= <integer> | *
.justify
.fill
.subtitle DEBUGGER STRUCTURE ABSTRACTION
.page
III. DEBUGGER STRUCTURE ABSTRACTION
.skip 1
.paragraph
The next two sections describe how the debugger views the program
and how it operates on the program so viewed.
In this section, a description of the structure of the program
is given followed by a list of properties of the structure.
The notation used in this and the following section is taken from
Hoare, C.A.R (1972) Notes on Structured Programming, "Notes on Data
Structuring", pp 83-174, Academic Press, London.
A general discussion of the notation will be given before the
structure definition.
An explanation will be given of how each part of the structure relates
to the program to be debugged.
.skip 2
.test page 6
^&Notation\&
.paragraph
All items (variables, constants, functions etc.) have a type which
is either structured or unstructured.
An example of a structured type is array and of
an unstructured type is integer.
(Type integer could be considered structured if one was concerned
with the structure of integers such as their digits.)
Real array is a structured type (array) composed of
unstructured subscripts (integer)  and values (real).
.paragraph
The type of a variable is specified by following it with a colon and
a type name.
For example,
.skip 1
.center
x:real
.skip 1
specifies that x is a variable of type real and
.skip 1
.center
seasons:ARRAY#(1,2,3,4)#OF#(spring,summer,fall,winter)
.skip 1
specifies that seasons in an array such that seasons[1]=spring,
seasons[2]=summer,
seasons[3]=fall and
seasons[4]=winter.
In the last example, spring, summer, fall and winter are constants of
an unnamed, unstructured type.
.paragraph
The atomic unstructured types which are used to define all other types are
the following.
.skip 1
.left margin 5
identifier#-#a six character alphanumeric nce the first character of
which must be a letter.
.skip 1
line__key#-#an unsigned decimal number from .001 to 99999.999 with at
most three decimal places.
.skip 1
address#-#an octal integer from 0 to 777777
.skip 1
string#-#a sequence of printing characters and spaces
.skip 1
logical#-#has values 'true' or 'false'.
.skip 1
symbol__value#-#any value a fortran variable can assume.
.left margin 0
.skip 1
The types function and integer will not be defined.
.skip 1
The atomic structured types are
.left margin 5
.skip 1
array#-#the notation for type array is
.skip 1
.center
ARRAY &d OF &r
.skip 1
where &d is the type of the domain of the array or its subscripts
and &r is the type of the range of the array or its values.
An array is considered a mapping from &d to &r.
The element of an array is specified by array__name[domain__value].
If the array is sparse (see below for definition of sparse),
the values of the domain and range which are in the array are defined
by the functions domain(array__name) and range(array__name).
.skip 1
powerset#-#the notation for type powerset is
.skip 1
.center
POWERSET &z
.skip 1
which defines a set of items of type &t.
It is called a powerset since the set of possible values of the type
is the set of all subsets of the set of values of type &t.
.skip 1
cartesian#product#-# the notation for type cartesian product is
.skip 1
.center
(a1:t1 ; a2:t2 ; ... ; an:tn)
.skip 1
where the ai are the names of the parts of an element of
type cartesian product and the ti are the types of the parts.
If v is a variable of type cartesian product, then v.ai is the
value of part ai of v.
If T is a cartesian product type, then T(v1,v2,...,vn)
is an element of typee T where the vi's are the parts of
the cartesian product.
.left margin 0
.skip 1
Both ARRAY and POWERSET can be preceded by
the word SPARSE to signify that only a few of the possible values of the type
will be used by the type.
A type can also be defined by enumeration of its values by
.skip 1
.center
(v1 , v2 , ... , vn)
.skip 1
where the vi's are the possible values of the type.
Two variables are defined as the same type by
.skip 1
.center
x1,x2:type
.skip 2
.test page 17
^&Debugger Structure Definition\&
.skip 2
.nofill
.nojustify
routine__table : SPARSE ARRAY identifier OF
    (line__context:context ; symbol__context:context ;
    symbol__table : SPARSE ARRAY identifier OF
        (symbol__type:(integer,real,double,complex,logical,string) ;
        symbol__size:integer ;
        display__mode:(declared,ascii,octal) ;
        element__address:SPARSE POWERSET address ;
        address__function:function ;
        symbol__value__check:value__check)   )
.skip 1
.fill
.justify
.left margin 4
This defines a mapping from a routine name which is of type
identifier (either a subprogram name or a main program name) to
all the information associated with a routine which is of concern
to the debugger.
The elements of the array are cartesian products whose
parts are
.break
.left margin 6
.skip 1
i) the line number context which contains the routine,
.skip 1
ii) the variable name context for the routine and
.skip 1
iii) the routines's symbol table.
.skip 1
.left margin 4
The symbol table maps the variable name, an identifier, onto the
information about each variable needed by the debugger.
Each element of the array is a cartesian product
whose parts are
.skip 1
.left margin 6
i) the FORTRAN type of the variable,
.skip 1
ii) the number of words for nonstring variables and
the number of characters for string variables,
.skip 1
iii) the variable's display mode,
.skip 1
iv) the possible memory addresses for the elements of the
variable, for scalars, this set contains only one element which is
the memory address of the value of the variable and for arrays, this
set contains the memory addresses of the values of all the elements
of the array,
.skip 1
v) the function which converts array subscripts to
elements of element__address or for scalars, the null string to
the element of element__address and
.skip 1
vi) the value checks associated with the variable.
.left margin 0
.skip 2
.nofill
.nojustify
.test page 5
ORDERED TYPE context = SPARSE ARRAY line__key OF statement
.skip 1
TYPE statement = (
    statement__flow__check:ARRAY check OF SPARSE POWERSET flow__index ;
    statement__value__check:value__check)
.skip 1
.fill
.justify
.left margin 4
The above two type definitions specify the mappings from line__key
to statement and the elements of the statement which concern the debugger.
These are the flow and value checks to be made at the statement.
.left margin 0
.skip 2
.nofill
.nojustify
.test page 11
TYPE value__entry = (value__ident:symbol__ident ; old__value:symbol__value)
.skip 1
TYPE value__check = ARRAY check OF SPARSE POWERSET value__entry
.skip 1
value__check__set:ARRAY check OF SPARSE POWERSET (
    value__entry__set:SPARSE POWERSET value__entry ;
    value__statement:SPARSE POWERSET statement)
.skip 1
all__value__check:value__check
.skip 1
all__value__routine:ARRAY check OF identifier
.skip 1
.fill
.justify
.left margin 4
The above type and variable definitions is the structure
concerned with value checks.
The type check is used to distinguish between
breakpoints and tracepoints.
The value__check__set contains all value checks other than
those specified by ALL.
They are contained in all__value__check.
All__value__routine contains the routine
name where the variables for all__value__check
are defined.
A value__entry contains information to identify the variable
to be checked and the old value against which to check.
.skip 2
.nofill
.nojustify
.test page 9
.left margin 0
TYPE flow__entry = (icount,count:integer ; owner:integer ;
    flow__variable:SPARSE POWERSET symbol__ident)
.skip 1
flow__check__set:ARRAY check OF
    SPARSE ARRAY flow__index OF SPARSE POWERSET flow__entry
.skip 1
all__flow__check:ARRAY check OF SPARSE POWERSET flow__entry
.skip 1
all__flow__routine:ARRAY check OF identifier
.skip 1
.fill
.justify
.left margin 4
The above type and variable definitions is the structure concerned
with flow checks, both flow breakpoints and flow tracepoints.
The flow__check__set contains all flow checks other than those
specified by ALL.
They are contained in all__flow__check.
All__flow__routine contains the routine names where the variables
to be typed at all__flow__check are defined.
A flow__entry contains the initial @-counter, the
current @-counter, the number of statements with this flow check
and the variables to be typed at this flow check.
.skip 2
.nofill
.nojustify
.left margin 0
.test page 5
current__routine:identifier
.skip 1
next__active,step__active:logical
.skip 1
next__counter,step__counter:integer
.fill
.justify
.left margin 4
.skip 1
The variable current__routine defines the current contexts.
It is in domain(routine__table).
The other four variables are for the NEXT and STEP commands.
.skip 2
.nofill
.nojustify
.left margin 0
.test page 5
TYPE check = (break,trace)
.skip 1
TYPE symbol__ident = (ident__name:identifier ; ident__address:address ;
    identification:string)
.skip 1
.fill
.justify
.left margin 4
The above two types are used by the other type definitions.
Check is used to disyinguish between break and trace.
Symbol__ident is the information needed to
identify a variable for flow and value checks.
.test page 5
.left margin 0
.skip 2
.test page 6
^&Properties\&
.paragraph
The following is a list of properties of the
above structure.
Each property is stated twice, informally and formally.
The formal statement uses the same number as the
informal statement followed by an asterick.
.skip 2
.nojustify
0)#All the statements about flow breaks or value breaks are also true for
flow traces and value traces.
.skip 1
0*)#In all of the following, let i:check.
.skip 2
1)#These are assertions about all statements in all routines.
.skip 1
1*)# For all d:identifier in domain(routine__table), for all l:line__key
in domain(routine__table[d].symbol__context), let s = symbol__context[l].
.skip 1
.left margin 2
a)#There is at most one flow break at each statement.
.skip 1
a*)#size(s.statement__flow__check[i]) = 0 or 1
.skip 1
b)#Every flow break at a statement is in the flow break set.
.skip 1
b*)#If a in s.statement__flow__check[i] then a in domain(flow__check__set[i]).
.skip 1
c)#All the variables to be displayed at a flow break come from the symbol
table of only one routine which is in the same line number context as the
statement with the flow break.
.skip 1
c*)#There exists one and only one r:identifier in domain(routine__table)
such that routine__table[d].line__context = routine__table[r].line__context
and if a in s.statement__flow__check[i] and b in flow__check__set[i,a] then
for all c in b.flow__variable,
c.ident__name in domain(routine__table[r].symbol__table) and
c.ident__address in symbol__table[c.ident__name].element__address.
.skip 1
d)#Every value break at a statement is in the value break set and that
element refers to the statement.
.skip 1
d*)#If a in s.statement__value__check[i] then there exists one and only one
b in value__check__set[i] such that a in b.value__entry__set and
s in b.value__statement.
.skip 1
e)#All the variables to be checked at a value break are in the symbol table
of only one routine with the same line number context as the statement
with the value break and the value break is in the set of value
breaks for the variable in the symbol table.
.skip 1
e*)#There exists one and only one r:identifier in domain(routine__table)
such that routine__table[d].line__context = routine__table[r].line__context
and for all a in s.statement__value__check[i],
a.value__ident.ident__name in domain(routine__table[r].symbol__table),
a.value__ident.ident__address in
symbol__table[a.value__ident.ident__name].element__address and
a in symbol__table[a.value__ident.ident__name].symbol__value__check[i].
.left margin 0
.skip 2
2)#Every flow break in the flow break set is on at least one statement.
.skip 1
2*)#For all a:flow__index in domain(flow__check__set[i]), there exists
r:identifier in domain(routine__table) such that there exists
l:line__key in domain(routine__table[r].line__context) such that
a in line__context[l].statement__flow__check[i].
.skip 2
3)#A flow break is only on statements in only one line number context.
.skip 1
3*)#For all a:flow__index in domain(flow__check__set[i]),
for all r1,r2:identifier in domain(routine__table),
for all l1,l2:line__key such that l1 in domain(routine__table[r1].line__context)
and l2 in domain(routine__table[r2].line__context),
if a in line__context[l1].statement__flow__check[i] and
a in line__context[l2].statement__flow__check[i] then
routine__table[r1].line__context = routine__table[r2].line__context.
.skip 2
4)#All statements in a routine's symbol context are in its line number
context.
.skip 1
4*)#For all r:identifier in domain(routine__table),
if l:line__key in domain(routine__table[r].symbol__context) then
l in domain(routine__table[r].line__context) and
symbol__context[l] = line__context[l].
.skip 2
5)#Each statement in a routine's line number context is in only one
routine's symbol context. These routines have the same line number context.
.skip 1
5*)#For all r1:identifier in domain(routine__table),
if l:line__key in domain(routine__table[r1].line__context) then there exists
one and only one r2:identifier in domain(routine__table) such that
l in domain(routine__table[r2].symbol__context),
routine__table[r1].line__context[l] = routine__table[r2].symbol__context[l] and
routine__table[r1].line__context = routine__table[r2].line__context.
.skip 2
6)#These are assertions about all value breaks.
.skip 1
6*)#For all b in value__check__set[i].
.skip 1
.left margin 2
a)#All the variables to be checked at a value break are in only one routine.
.skip 1
a*)#there exists one and only one r:identifier in domain(routine__table)
such that for all a:value__entry in b.value__entry__set,
a.value__ident.ident__name in domain(routine__table[r].symbol__table) and
a.value__ident.ident__address in
symbol__table[a.value__ident.ident__name].element__address.
.skip 1
b)#All the variables to be checked at a value break are referenced by all
the statements associated with the value break.
.skip 1
b*)#If s in b.value__statement then there exists r:identifier
in domain(routine__table) and a l:line__key in
in domain(routine__table[r].line__context) such that s = line__context[l] and
b.value__entry__set is a subset of s.statement__value__check[i].
.skip 1
c)#A value break has only one reference to each variable instance.
.skip 1
c*)#There does not exist a1,a2:value__entry in b.value__entry__set such that
a1.value__ident.ident__name = a2.value__ident.ident__name,
a1.value__ident.ident__address = a2.value__ident.ident__address and
not a1 = a2.
.skip 2
.left margin 0
7)#All the variables to be checked at the all value break are in only
one routine.
.skip 1
7*)#There exists one and only one r:identifier in domain(routine__table)
such that for all a:value__entry in all__value__check[i]
a.value__ident.ident__name in domain(routine__table[r].symbol__table) and
a.value__ident.ident__address in
symbol__table[a.value__ident.ident__name].element__address.
.skip 2
8)#The all value break has only one reference to each variable instance.
.skip 1
8*)#There does not exist a1,a2:value__entry in all__value__check[i] such that
a1.value__ident.ident__name = a2.value__ident.ident__name,
a1.value__ident.ident__address = a2.value__ident.ident__address and
not a1 = a2.
.skip 2
9)#Two value breaks do not refer to the same variable instance.
.skip 1
9*)#There does not exist b1,b2 in value__check__set[i] such that not b1 = b2 and
there exists a1:value__entry in b1.value__entry__set and
a2:value__entry in b2.value__entry__set such that a1 = a2.
.skip 2
10)#There is at most one all flow break.
.skip 1
10*)#size(all__flow__check[i]) = 0 or 1.
.skip 2
11)#A statement is in only one routine and in that routine its line key is
unique.
.skip 1
11*)#If s:statement then there exists one and only one
r:identifier in domain(routine__table) and one and only one
l:line__key in domain(routine__table[r].symbol__context) such that
s = routine__table[r].symbol__context[l]. define two functions
routine(statement) = identifier and line(statement) = line__key
such that routine(s) = l and line(s) = l.
.fill
.justify
.subtitle ALGORITHMS
.page
IV. ALGORITHMS
.skip 1
.paragraph
The following are the algorithms which realize the debugger
described in section I.
The algorithms for the STM#UUO, the flow break and trace commands,
the value break and trace commands, the debug commands and the
execution commands are given in an ALGOL-like language which uses the
notation of section III.
.skip 2
.test page 6
^&STM UUO\&
.paragraph
The STM procedure is called whenever a statement, which was
compiled and loaded in debug mode, is about to be executed.
The agrument of the procedure is the statement to be executed.
.skip 2
.nofill
.nojustify
comment old__routine contains the name of the routine that the last
        statement was executed in. It is used to determine if
        if the name of the current routine should be typed
        at break or tracepoints ;
.skip 1
old__routine:identifier,initially '.MAIN.';
.skip 1
procedure stm(s:statement) ;
 begin
.skip 1
  comment the variable heading is used to insure that the line key
          for the statement is only typed once no matter how many break
          or trace points are at the statement.
          The array test is used to remember if a break has occured
          at the statement. ;
.skip 1
  heading:logical; test:ARRAY check OF logical ;
  heading='false' ; for i:check do test[i]='false' ;
.skip 1
  comment the following two tests handle the NEXT and STEP commands. ;
.skip 1
  if next__active
   then
    begin
    decr(next__counter) ;
    if next__counter<= 0
     then
      begin
      display__heading ;
      test['break']='true'
      end
    end ;
.skip 1
  if step__active
   then
    begin
    display__heading ;
    decr(step__counter) ;
    if step__counter<=0 then test['break']='true'
    end ;
.skip 1
  comment the order in which the possible breaks and traces are checked
          is all flow break, statement flow break, all value break,
          statement value break, all flow trace, statement value trace,
          all value trace and statement value trace. The
          order is not important and any order could be choosen. ;
.skip 1
  for i:check do
   begin
   for x in all__flow__check[i] do test[i] or=check__flow(x)
   for x in s.statement__flow__check[i] do
    test[i] or=check__flow(flow__check__set[i,x]) ;
   for x in all__value__check[i] do test[i] or=check__value(x) ;
   for x in s.statement__value__check[i] do test[i] or=check__value(x)
  end ;
.skip 1
  comment if a break has occured, go to the debugger else return to
          the program. ;
.skip 1
  if test['break'] then execute__debugger(s) ;
  return ;
.skip 2
 comment test if a break or trace should occur due to flow__entry x. ;
.skip 1
  function check__flow(x:flow__entry):logical ;
   begin
.skip 1
   comment decrement the @ counter. if zero, break or trace should
           occur. ;
.skip 1
   decr(x.count) ;
   if x.count>0 then return 'false' ;
   x.count=x.icount ;
.skip 1
   comment display heading (routine name and line key) and flow check
           variables. ;
.skip 1
   display__heading ;
   for y in x.flow__variables do display__variable(y) ;
   return 'true'
   end check__flow ;
.skip 2
  comment test if a break or trace should occur due to value entry x. ;
.skip 1
  function check__value(x:value__entry):logical ;
   begin
.skip 1
   comment break or trace if value has changed. if so, save new value. ;
.skip 1
   if value(x.value__ident)#x.old__value then return 'false' ;
   x.old__value=value(x.value__ident) ;
.skip 1
   comment display heading and new value of variable. ;
.skip 1
   display__heading ;
   display__variable(x.value__ident) ;
   return 'true'
   end check__value ;
.skip 2
  comment display heading (outine name if different from last displayed
          name and line key) and insure that it is only displayed 
          once. ;
.skip 1
  procedure display__heading ;
   begin
   if not heading
    then
     begin
     if old__routine#routine(s)
      then
       begin
       display__name(routine(s)) ; old__routine=routine(s)
       end ;
     display__line__key(line(s)) ;
     heading='true'
     end ;
   return
   end display__heading
 end stm
.fill
.justify
.skip 2
^&Flow Break and Trace Commands\&
.paragraph
Three procedures are defined here, flow__set__command for the
BREAK and TRACE commands, no__flow__command for the
NO#BREAK and NO#TRACE commands and list__flow__command
for the LIST#BREAK and LIST#TRACE commands.
.skip 2
.nofill
.nojustify
comment first define the scanning routines to get elements of the
        command line. Only the call and value of the scanners will
        be given. The use of the scanners will not include
        all error checking. The scanning routines will check that the
        line keys and variables are in the current context. ;
.skip 1
scan__line__addresses(x:SPARSE POWERSET statement):logical
scan__line__address(x:statement):logical
scan__variables(x:SPARSE POWERSET symbol__ident):logical
scan__variable(x:symbol__ident):logical
scan__variable__names(x:identifier):logical
scan__routine(x:identifier):logical
scan__string(x:string):logical
scan__integer(x:integer):logical
.skip 1
comment flow__set__command is called with a check type argument
        specifying whether BREAK or TRACE was typed for the command. ;
.skip 1
procedure flow__set__command(i:check) ;
 begin
 all:logical ; fe:flow__entry ; fi:flow__index ; cnt:integer ;
 stmt:SPARSE POWERSET statements ; vars:SPARSE POWERSET symbol__ident ;
.skip 1
 comment collect the command arguments. The variable all will be
         'true' if BREAK#ALL or TRACE#ALL. Otherwise, stmt will
         contain the statements where checks should be put. The
         variable vars will contain the symbol__ident's of
         variables to be displayed at the check. Cnt will contain
         the value of the @-counter. ;
.skip 1
 all=scan__string('ALL') ;
 if not all then scan__line__addresses(stmt) ;
 if not scan__variables(vars) then vars=empty__set ;
 if scan__string('@') then scan__integer(cnt) else cnt=1 ;
.skip 1
 if all
  then
.skip 1
   comment replace the ALL break or trace point. ;
.skip 1
   begin
   if not empty(all__flow__check[i]) then clear(all__flow__check[i]) ;
   append(all__flow__check[i],flow__entry(cnt,cnt,1,vars) ;
   end
.skip 1
  else
.skip 1
   comment construct a new flow__entry, get a new flow__index,
           put flow__index on each statement to be checked and
           add flow__entry to flow__check__set. increment owner
           of flow__entry for each statement at stmt. ;
.skip 1
   begin
   fe=flow__entry(cnt,cnt,0,vars) ;
   fi=new__flow__index ;
   for s:statement in stmt do
    begin
    incr(fe.owner) ;
    clear__flow(s,i) ;
    append(s.statement__flow__check[i],fi)
    end
   flow__check__set[i,fi]=fe
   end
.skip 1
 return
 end flow__set__command ;
.skip 2
comment no__flow__command is also called with check type argument. ;
.skip 1
procedure no__flow__command(i:check) ;
 begin
 stmt:SPARSE POWERSET statement ;
.skip 1
 if scan__string('ALL')
  then
.skip 1
   comment clear all__flow__check if there is one. ;
.skip 1
   begin
   if not empty(all__flow__check[i]) then from all__flow__check[i]
   end
.skip 1
  else
.skip 1
   comment clear flow check for each line address in command. ;
.skip 1
   if scan__line__address(stmt)
    then for s:statement in stmt do clear__flow(s,i)
.skip 1
   comment clear flow checks on all statements. ;
.skip 1
   else for r:identifier in domain(routine__table) do
    for l:line__key in domain(routine__table[r].symbol__context) do
     clear__flow(routine__table[r].symbol__context[l],i) ;
.skip 1
 return
 end no__flow__command ;
.skip 2
comment clear a flow check at the specified statement. used by
        no__flow__command to delete flow checks. ;
.skip 1
procedure clear__flow(s:statement,i:check) ;
 begin
 fi:flow__index ;
 if not empty(s.statement__flow__check[i])
  then
   begin
   fi from s.statement__flow__check[i] ;
.skip 1
   comment only clear if no other statement uses this flow check. ;
.skip 1
   decr(flow__check__set[i,fi].owner) ;
   if flow__check__set[i,fi].owner=0 then flow__check__set[i]=empty__set ;
   end ;
.skip 1
 return
 end clear__flow ;
.skip 2
comment the following procedures realize the LIST BREAK and
        LIST TRACE commands. ;
.skip 1
procedure list__flow__command(i:check) ;
 begin
 stmt:SPARSE POWERSET statement ;
.skip 1
 if scan__string('ALL')
  then
.skip 1
   comment list all__flow__check if argument is ALL. Display routine
           name and variables. ;
.skip 1
   begin
   if not empty(all__flow__check[i])
    then
     begin
     display__name(all__flow__routine[i]) ;
     display__flow__variable__names(flow__check__set[i,fi].flow__variable)
     end
   end
.skip 1
  else
.skip 1
   comment list flow checks at specified statements. ;
.skip 1
   if scan__line__address(stmt)
    then for s:statement in stmt do
     for fi:flow__index in s.statement__flow__check[i] do
      begin
      display__line__key(line(s)) ;
      display__flow__variable__names(flow__check__set[i,fi].flow__variable)
      end
.skip 1
    comment list all flow checks. use routines defined in block
            defined below to condense reporting. ;
.skip 1
    else for r:identifier in domain(routine__table) do
     with routine__table[r] do
      begin
      begin__routine ;
      for l:line__key in domain(symbol__context) do
       with symbol__context[l] do
        if not empty(statement__flow__check[i])
         then for nfi:flow__index in statement__flow__check[i] do next__line(nfi)
         else no__line ;
      end__routine 
      end ;
 return ;
.skip 1
procedure display__flow__variable__names(x:SPARSE POWERSET symbol__ident) ;
 begin
 for y:symbol__ident in x do display__string(y.identification)
 return
 end display__flow__variable__names ;
.skip 2
 comment this block is for listing all the flow checks. The procedures
         defined here are called whenever a new routine is scanned
         (begin__routine), whenever a statement with flow checks is
         scanned (next__line), whenever a statement without flow
         checks is scanned (no__line) and whenever the end of a
         routine is scanned (end__routine).
.skip 1
         If a flow check is defined for a range, only the beginning
         and ending line keys for the range are displayed. If a flow
         check is defined for a sequence of line keys without
         intervening flow checks, the variables and @-counter are
         only displayed once for the sequence. The routine name
         heads any flow checks defined in the routine. ;
.skip 1
 begin
  bs,es:statement ; heading,check,range:logical ; fi:flow__index ;
  name:identifier ;
.skip 1
  procedure begin __routine(r:identifier) ;
   begin
   heading=check=range='false' ; name=r ;
   return
   end begin__routine ;
.skip 1
  procedure next__line(nfi:flow__index) ;
   begin
   if not check
    then begin__check
    else
     if nfi=fi
      then if range then extend__range else begin__range
      else
       begin
       end__check ; begin__check
       end ;
   return
   end next__line ;
.skip 1
  procedure no__line ;
   begin
   if check and range then end__range ;
   return
   end no__line ;
.skip 1
  procedure end__routine ;
   begin
   if check then end__check ;
   return
   end end__routine ;
.skip 1
  procedure begin__check
   begin
   if not heading
    then
     begin
     display__name(name) ;
     heading='true'
     end ;
   fi=nfi ; check='true' ;
   begin__range ;
   return
   end begin__check ;
.skip 1
  procedure begin__range ;
   begin
   bs=es=s ; range='true' ;
   return
   end begin__range ;
.skip 1
  procedure extend__range ;
   begin
   es=s ;
   return
   end extend__range ;
.skip 1
  procedure end__range ;
   begin
   display__line__address(bs) ;
   if bs#es
    then
     begin
     display__character(':') ;
     display__line__address(es)
     end ;
   range='false' ;
   return
   end end__range ;
.skip 1
  procedure end__check ;
   begin
   if range then end__range ;
   display__flow__variable__names(flow__check__set[i,f].flow__variables) ;
   if flow__check__set[i,f].icount>1
    then
     begin
     display__string('@ ') ;
     display__integer(flow__check__set[i,f].icount)
     end ;
   check='false' ;
   return
   end end__check ;
.skip 1
  end
.skip 1
end list__flow__command ;
.skip 2
.test page 6
^&Value Break and Trace\&
.skip 1
comment the following procedures are concerned with value checks. ;
.skip 1
procedure value__set__command(i:check) ;
 begin
 stmt:SPARSE POWERSET statement ;
 vars:SPARSE POWERSET symbol__ident ;
 valset:SPARSE POWERSET value__entry ;
 valent:value__entry ; all:logical ;
.skip 1
 with routine__table[current__routine] do
  begin
  if not scan__variables(vars) then error ;
  all=scan__string('ALL') ;
  if not all then if not scan__line__addresses(stmt)
    then stmt=range(symbol__context) ;
.skip 1
  for x:symbol__ident in vars do
   begin
   valent=value__entry(x,value(x)) ;
   append(valset,valset) ;
   append(symbol__table[x.ident__name].symbol__value__check[i],valent) ;
.skip 1
   for y in value__check__set[i] do
    begin
    remove(valent,y.value__entry__set) ;
    if empty(y.value__entry__set) then remove(y,value__check__set)
    end
   remove(valent,all__value__check[i]) ;
.skip 1
   if all then append(all__value__check[i],valent)
   end
.skip 1
  if not all
   then
    begin
    for x:statement in stmt do
     append(x.statement__value__check[i],valent) ;
    append(value__check__set[i],(valent;stmt))
    end
.skip 1
  end ;
  return
 end value__set__command ;
.skip 2
procedure list__value__command(i:check) ;
 begin
 vars:SPARSE POWERSET symbol__ident ;
.skip 1
 if scan__variables(vars)
  then for x:symbol__ident in vars do
        for y in value__check__set[i] do
         for z:value__entry in y.value__entry__set do
          if x=z.value__ident
           then
            begin
            display__string(z.value__ident.identification) ;
            for s:statement in y.value__statement do
             display__line__address(line(s))
            end
  else
   for y in value__check__set[i] do
    begin
    for z:value__entry in y.value__entry__set do
     display__string(z.value__ident.identification) ;
    for z:statement in y.value__statement do
     display__line__address(line(s))
    end ;
.skip 1
 return
 end list__value__command ;
.skip 2
.test page 6
^&Debug Context Commands\&
.skip 1
comment the following procedures set and display the debug contexts. ;
.skip 1
procedure debug__command ;
 begin
 r:identifier ; s:statement ;
 if scan__identifier(r)
  then current__routine=r
  else
   if scan__line__address(s)
    then current__routine=routine(s)
    else current__routine='.main.' ;
 return
 end debug__command ;
.skip 1
procedure list__debug__command ;
 begin
 display__identifier(current__routine) ;
 return
 end list__debug__command ;
.skip 2
.test page 6
^&Execution Commands\&
.skip 1
comment the following procedures start program execution. ;
.skip 1
procedure go__command ;
 begin
 s:statement ;
 if not scan__line__address(s)
  then
   begin
   current__routine='.MAIN.' ;
   s=first(routine__table[current__routine].symbol__context)
   end ;
 start__at(s) ;
 return
 end go command ;
.skip 1
procedure continue__command ;
 begin
 return__to__STM ;
 return
 end continue__command ;
.skip 1
procedure next__command ;
 begin
 if not scan__integer(next__counter) then next__counter=1 ;
 next__active='true' ;
 continue__command ;
 return
 end next__command ;
.skip 1
procedure step__command ;
 begin
 if not scan__integer(step__counter) then step__counter=1 ;
 step__active='true' ;
 continue__command ;
 return
 end step__command ;
    p@F¤