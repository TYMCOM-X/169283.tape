TITLE TRAPS	OVER/UNDERFLOW TRAP ROUTINE
SUBTTL	V32/01	14-SEP-72	/DLH

;FROM V.32(305)	6-OCT-1971	T. EGGERS/DMN/TWE
;***COPYRIGHT 1969,1970,1971,1972 DIGITAL EQUIPMENT CORP., MAYNARD, MASS.***

REENT==0	;TRAPS WILL NOT LOAD INTO HIGH SEGMENT

T=14	;WORKING ACCUMULATOR
TT=1
IFE REENT,<LOW=0>
IFN REENT,<LOW=16>
P=17	;PUSH DOWN POINTER

FXU=1B11	;FLOATING EXPONENT UNDERFLOW FLAG
FOV=1B3		;FLOATING OVERFLOW BIT
NDV=1B12	;NO DIVIDE BIT

OPDEF APRENB [CALLI 16]	;TO SET UP APR TRAPPING
OVE=10		;ENABLE INTEGER OVERFLOW TRAPS

;RESTRICTIONS ON OVTRAP ROUTINE:
;	1- NO ANSWER FOR A TRAPPING INSTRUCTION MUST BE STORED,
;	   INDEXED BY 17, OFF THE END OF THE PUSH DOWN LIST WHOSE
;	   POINTER IS IN 17.
;	2- OVTRAP DOES NOT TRACE XCT OR UUO CHAINS
;	3- THERE ARE NO FIXUPS FOR INTEGER TRAPS
;	4- MOVNX AND MOVMX ARE CONSIDERED INTEGER INSTRUCTIONS
;	5- TRAPPING INSTRUCTION MUST NOT BE IN ACCUMULATOR T=14
;	6- CRY0 AND CRY1 WILL BE PRESERVED
;	7- THE UN-NORMALIZING OF UNDERFLOWS WILL NOT WORK FOR THE
;	   FLOATING "LONG" MODE OR KI10 D.P. INSTRUCTIONS.

IF1,<OPDEF KADFN [DFN]>	;THIS PRESERVES THE KA10 "DFN"
			;   SINCE SEARCH DEF40 REDIFINES IT FOR THE KI10

SEARCH	DEF40
ENTRY	TRPIN.,TIMER		;**V32/01**
EXTERN	.JBCNI		;**V32/01**
EXTERN	OVPC.,OVCNT.
EXTERN	.JBTPC,.JBAPR,.JBREL,ITYPM.,UUOL.

MLON	;ENABLE MULTI LINE LITERALS

			;PUSHJ P,TRPINI	TO INITIALIZE ALL TRAPPING
TRPIN.:	MOVEI TT,OVTRAP
	HRRZM TT,.JBAPR		;INIT OVERFLOW TRAP ADDRESS
	MOVEI TT,OVE+400000
	JRSTF @[XWD 004000,.+1]		;CLEAR APR FLAGS
	APRENB TT,		;INIT OVERFLOW TRAPPING
	SETZM OVCNT.(LOW)	;INIT # OVERFLOWS TO 0
	POPJ	P,		;RETURN

;*******TIMER PATCH****14-SEP-72****V32/01**************************
;ROUTINE TO ALLOW USER TO SPECIFY A MAXIMUM CPU TIME IN SECONDS.
;CALLING SEQUENCE IS 
;	CALL TIMER (TIME)
;WHERE TIME IS THE MAX RUN TIME IN INTEGER SECONDS.

TIMER:	0
	MOVE	0,@0(16)	;GET TIME ARGUMENT
	IMULI	0,^D60		;CONVERT TIME TO TICKS
	MOVEM	0,MAXTIM	;STORE
	SETZM	NOWTIM		;CLEAR TO DATE TIME
	JRSTF	@[XWD 004000,.+1];CLEAR APR FLAGS
	MOVEI	0,401010	;SET CLOCK AND OVERFLOW TRAPS
	APRENB	0,		;ENABLE
	JRA	16,0(16)	;RETURN
NOTIME:	TTCALL	3,[ASCIZ/
MAXIMUM RUN TIME EXCEEDED
/]
	CALLI	1,12		;EXIT WITH CHANNELS OPEN
MAXTIM:	0			;MAXIMUM RUN TIME IN TICKS
NOWTIM:	0			;RUN TIME TO DATE IN TICKS
;********************END OF TIMER PATCH**************************************
OVTRAP:	JRSTF	@[XWD 004000,.+1];**V32/02** PREVENT CLOCK TRAP
	MOVEM T,TSAVE		;SAVE AC T
;************TIMER PATCH****14-SEP-72****V32/01****************************
	SKIPN	MAXTIM		;TEST IF CLOCK TRAPPING
	JRST	CONT		;NO - NORMAL PATH
	MOVE	T,.JBCNI	;GET APR STATUS
	TRNE	T,200110	;OVERFLOW?
	JRST	CONT		;YES - NORMAL PATH
	AOS	T,NOWTIM	;INCREMENT TICK COUNTR
	CAML	T,MAXTIM	;TIME ELAPSED?
	JRST	NOTIME		;YES - ERROR MSG
	JRST	RETURN		;NO - RETURN TO PROG
CONT:	SOS T,.JBTPC		;MAKE JOBTPC POINT TO INSTRUCTION
;*****************END OF TIMER PATCH************************************

	MOVEM T,OVPC.(LOW)	;SAVE PC WORD
	TLNN T,(FXU)		;FLOATING POINT UNDERFLOW?
	JRST OVTRP1		;NO

	HLL T,1(T)		;YES
	TLC T,(JFCL (2))	; IS NEXT INSTRUCTION
	TLNN T,777002		;   A JFCL (2) ?
	JRST OVTRP2		;YES

	LDB T,[POINT 9,(T),8]	;GET INSTRUCTION
	CAILE T,177		;POSSIBLE FLOATING POINT?
	JRST TJFCL1		;NO
	CAIGE T,140		;BETWEEN 140 AND 177?
	JRST	[CAIN T,(<FSC>_-9)	;NO, FSC?
		JRST UAC		;YES
					;(UFA AND DFN CAN'T CAUSE UNDERFLOW)
	IFN KI10,<TRZ T,003		;CHANGE ALL KI10 D.P. ARITH TO DFAD
		CAIN T,(<DFAD>_-9)
		JRST UACLNG >		;DFAD, DFSB, DFMP, DFDV
		JRST TJFCL1]		;NO, PRINT ERROR MESSAGE
	ANDI T,7		;MASK TO MODE BITS
	JRST UTBL(T)		;DISPATCH ON INSTRUCTION TYPE


OVTRP1:	TLNN T,(FOV)		;FLOATING OVERFLOW OR FLOATING DIVIDE CHECK?
	JRST TJFCL1		;NO, INTEGER OVERFLOW OR DIVIDE CHECK
OVTRP2:	LDB T,[POINT 4,@.JBTPC,12]	;GET AC FIELD
	MOVEM T,ACFLD		;SAVE AC FIELD
	MOVE T,@.JBTPC		;GET INSTRUCTION
	MOVEM T,INST
	MOVE T,TSAVE
	MOVEI T,@INST		;GET EFFECTIVE ADDRESS
	EXCH T,INST		; AND SAVE. PICK UP INSTRUCTION
	TLC T,(042B8)		;CHANGE "MODE 2" TO "MODE 0"
				; AND CHANGE 140-177
				;   TO 100-137
	HLR T,.JBTPC		;GET FLAGS IN RIGHT HALF
	TDNE T,[643B8+<NDV_-^D18>]	;SKIP FOR "TO MEMORY" AND NO NDV
				; NO SKIP FOR INSTRUCTIONS OUTSIDE 140-177
				;  (E.G. FSC,XCT,UFA,DFAD,DFSB,DFMP,DFDV)
	SKIPA T,ACFLD		;GET CORRECT SIGN FROM AC
	MOVE T,INST		;GET CORRECT SIGN FROM MEMORY
	MOVEM T,ACDATA		;SAVE ADDRESS FOR SIGN OF CORRECT RESULT
	MOVE T,.JBTPC		;IS THIS AN UNDERFLOW THAT
	TLNE T,(FXU)		;  NEEDS TO BE UNNORMALIZED?
	JRST	[MOVE T,TSAVE	;YES, RESTORE T AND
		MOVE T,@ACDATA	;  GET ANSWER THAT NEEDS UN-NORMALIZING
		PUSH P,TT	;SAVE ANOTHER AC
		HLRE TT,T	;GET EXPONENT WITH EXTENDED SIGN INTO
		ASH TT,-9	;  RIGHT 8 BITS
		TSCE TT,TT	;FOR NEGATIVE ARG, GET 1'S COMPLEMENT
				;OF EXPONENT AND DON'T SKIP
		TLOA T,777000	;FOR NEG. ARG, SET EXP TO ALL ONES
		TLZ T,777000	;FOR POS. ARG, SET EXP TO ALL 0'S
		CAMGE TT,[346,,346]	;WILL ALL FRACTION BITS GO AWAY?
		TDZA T,T		;YES, FRACTION SHOULD BE ZERO
		ASH T,400000(TT)	;UN-NORMALIZE FRACTION TO BRING EXP
				;BACK INTO RANGE
		POP P,TT	;RESTORE THE AC
		JRST OVTRP3]	;GO STORE RESULT
	MOVE T,TSAVE
	SKIPGE @ACDATA		;SKIP IF CORRECT RESULT IS POSITIVE
	SKIPA T,[XWD 400000,1]	;NO, NEGATIVE
	HRLOI T,377777		;YES
OVTRP3:	PUSH P,T		;SAVE FIX UP
	LDB T,[POINT 9,@.JBTPC,8]	;GET INSTRUCTION
	CAIG T,177
	CAIGE T,140		;NORMAL FLOATING POINT INSTRUCTION
	JRST	[CAIN T,(<FSC>_-9)	;NO, FSC?
		JRST AC		;YES
		CAIN T,(<UFA>_-9)	;UFA?
		JRST AC1
		POP P,ACDATA	;GET SIGN OF RESULT OFF PDL
	IFN KI10,<TRZ T,003	;CHANGE ALL KI10 D.P. ARITHMETIC TO DFAD
		CAIN T,(<DFAD>_-9)
		JRST ACDOUB >	;KI10 DFAD, DFSB, DFMP, OR DFDV
		JRST TJFCL1]	;PROBABLY AN XCT
	ANDI T,7
	JRST TBL(T)
;THIS PAGE FOR OVERFLOWS, DIVIDE CHECKS, AND UN-NORMALIZING UNDERFLOWS

TBL:	JRST AC
	JRST ACLONG
	JRST MEMORY
	JRST BOTH
	JRST AC
	JRST AC
	JRST MEMORY
	;JRST BOTH

BOTH:	PUSH P,(P)		;SAVE ANOTHER COPY
BOTH1:	MOVE T,TSAVE
	POP P,@ACFLD		;LOAD AC
	POP P,@INST		;LOAD MEMORY
	JRST TJFCL

AC1:	AOS T,ACFLD
	ANDI T,17		;MASK AC+1 TO 4 BITS
	MOVEM T,ACFLD
AC:	MOVE T,TSAVE
	POP P,@ACFLD		;LOAD AC
	JRST TJFCL

ACLONG:	MOVE T,ACFLD		;GET AC
	ADDI T,1
	ANDI T,17
	MOVEM T,INST		;PUT AC+1 INTO MEMORY ADDRESS
	POP P,ACDATA		;GET SIGN OF ANSWER INTO BETTER PLACE
	PUSH P,[XWD 344777,-1]	;SAVE A POS LOW WORD
	HRLOI T,377777		;ASSUME A POSITIVE HIGH WORD
	SKIPGE ACDATA		;SHOULD RESULT BE POSITIVE?
	KADFN T,(P)		;NO, NEGATE IT WITH KA10 DFN
	PUSH P,T		;PUT OTHER ARG ON PDL
	JRST BOTH1

MEMORY:	MOVE T,TSAVE
	POP P,@INST
	JRST TJFCL

IFN KI10,<
ACDOUB:	MOVSI T,(Z 17,)		;GET ONES IN AC FIELD
	AND T,@.JBTPC		;EXTRACT AC FIELD FROM FAULTING D.P. INST
	IOR T,[DMOVE 0,[EXP <377777,,777777>,<377777,,777777>]]
	SKIPGE ACDATA		;WAS OVERFLOW RESULT POSITIVE?
	TLC T,1000		;NO, CHANGE THE DMOVE TO DMOVN
	JRST UAC2 >		;GO FIXUP THE TWO AC'S
;THIS PAGE ONLY FOR ZEROING UNDERFLOWS

UTBL:	JRST UAC		;ZERO AC
	JRST UACLNG		;ZERO AC, AC+1
	JRST UMEMRY		;ZERO E
	JRST UBOTH		;ZERO AC,E
	JRST UAC
	JRST UAC
	JRST UMEMRY
	;JRST UBOTH

UBOTH:	MOVE T,@.JBTPC		;GET OFFENDING INSTRUCTION
	TLZ T,777000		;ZERO OP CODE
	TLO T,(SETZB)		;CHANGE TO "SETZB AC,E"
	JRST UAC2

UMEMRY:	MOVE T,@.JBTPC
	TLZ T,777740		;ZERO OP CODE, AC FIELD
	TLO T,(SETZM)		;CHANGE TO "SETZM E"
	JRST UAC2

UACLNG:
IFE KI10,<LDB T,[POINT 4,@.JBTPC,12]	;GET AC FIELD
	DPB T,[POINT 4,T,12]	;COPY INTO AC FIELD
	ADDI T,1		;CHANGE AC TO AC+1
	TRZ T,20		;MASK TO 4 BITS
	TLO T,(SETZB) >		;CHANGE TO "SETZB AC,AC+1"
IFN KI10,<MOVSI T,(Z 17,)	;GET ONES IN AC FIELD
	AND T,@.JBTPC		;EXTRACT AC FIELD FROM FAULTING INST
	IOR T,[DMOVE 0,[EXP 0,0]] >	;SET UP A DMOVE TO CLEAR 2 AC'S
	JRST UAC2

UAC:	HLLZ T,@.JBTPC		;GET OFFENDING INSTRUCTION
	TLZ T,777037		;ZERO OP CODE, XR,@, LEAVE AC
	TLO T,(SETZ)		;CHANGE TO "SETZ AC,"
UAC2:	EXCH T,TSAVE		;SAVE INSTRUCTION, RESTORE T
	XCT TSAVE		;CLEAR THE REQUIRED REGISTERS

TJFCL:	MOVEM T,TSAVE		;SAVE T AGAIN
TJFCL1:	AOS .JBTPC		;JOBTPC POINTS TO NEXT INSTRUCTION
	MOVE T,@.JBTPC		;GET NEXT INSTRUCTION
	TLC T,(<JFCL>)		;COMPLEMENT "JFCL" BITS
	TLNE T,777000		;JFCL INSTRUCTION?
	JRST ERRPNT		;NO, PRINT ERROR MESSAGE
	TRNE T,-1		;ADDRESS SPECIFIED ON JFCL?
	HRRM T,.JBTPC		;YES, GO THERE
	TLNE T,(<Z 10,(1)>)	;IS OVERFLOW BIT (OR XR1) SET IN JFCL?
	JRST ERRPNT		;YES, TYPE ERROR MESSAGE
RETURN:	JRSTF	@[XWD 004000,.+1] ;CLEAR APR FLAGS
	SKIPN	MAXTIM		;CLOCK TRAPPING?
	JRST	GO		;NO - BYPASS RE-ENABLING
	HRRI	T,401010	;SET CLOCK AND OVERFLOW TRAPS
	APRENB	T,		;ENABLE
GO:	HRLOI T,337600		;MASK OUT SOME FLAGS
;***************END OF TIMER PATCH***************************************


	ANDM T,.JBTPC		;BUT LEAVE CRY0, CRY1, AND USER IOT SET
	MOVE T,TSAVE		;RESTORE T
	JRSTF @.JBTPC
%OP==(7B2)
IFE REENT,<%L==0>
IFN REENT,<%L==(1B5)>
%O==5
%E==10
%%CR==3

ERRPNT:	MOVE T,OVPC.(LOW)	;GET FLAGS
	TLNN T,(FXU)
	AOS OVCNT.(LOW)		;COUNT OVERFLOWS AND DIVIDE CHECKS
	TLNN T,(FOV)		;FLOATING POINT TRAP?
	JRST	[HRRI T,1	;NO, ASSUME INTEGER OVERFLOW
		TLNE T,(NDV)	;INTEGER DIVIDE CHECK?
		MOVEI T,2	;YES
		JRST MSG2]
	HRRI T,3		;ASSUME FLOATING POINT OVERFLOW
	TLNE T,(NDV)		;FLOATING DIVIDE CHECK?
	MOVEI T,5		;YES
	TLNE T,(FXU)		;FLOATING UNDERFLOW?
	MOVEI T,4		;YES
MSG2:	HRRZS	T		;MAKE SURE LEFT HALF IS CLEAR
	PUSH	P,1
	PUSH	P,2
	PUSH	P,3
	HRRZ	1,OVPC.(LOW)	;GET ADDRESS
	CAMG	1,.JBREL	;SKIP IF FROM HIGH SEGMENT
	XCT	UUOL.(LOW)	;SET UP AC16 IF REENT OP SYSTEM
	PUSHJ	P,ITYPM.
	%E,	T	(%OP)
	%O,	@OVPC.	(%OP+%L+%%CR)
	HRRZ	1,OVPC.(LOW)	;GET ADDRESS
	CAMG	1,.JBREL	;SKIP IF FROM HIGH SEGMENT
	XCT	UUOL.(LOW)	;RESTORE AC16 AGAIN
	POP	P,3
	POP	P,2
	POP	P,1
	JRST	RETURN

TSAVE:	BLOCK 1		;TEMP FOR AC T
ACFLD:	BLOCK 1		;ADDRESS OF ACCUMULATOR
ACDATA:	BLOCK 1		;HOLDS SIGN OF CORRECT ANSWER
INST:	BLOCK 1		;HOLDS INSTRUCTION OR "E"

IF1,<	END	>	;SAVE TIME ON ASSEMBLY

REPEAT 0,<

DESCRIPTION OF "TRAPS" PROGRAM FOR LIB40-

I. THE PURPOSE OF THE TRAPS PROGRAM IS DO ERROR DETECTION
   AND CORRECTION WHEN ARITHMETIC FAULTS OCCUR DURING THE
   EXECUTION OF FORTRAN PROGRAMS.

II. THE TRAPS PROGRAM CONSISTS OF THREE DISTINCT PARTS:

	A. TRPINI
		1. CALLING SEQUENCE- PUSHJ P,TRPINI
						;RETURN
		2. THE OVERFLOW COUNTER, OVCNT, (USED BY THE OVERFL
		      FUNCTION) AND THE PC WORD FLAGS ARE CLEARED
		3. PROCESSOR AND MONITOR TRAPPING ON OVERFLOW (PC WORD
		      BIT 0) IS ENNABLED

	B. OVERFL IS THE STANDARD FORTRAN OVERFLOW FUNCTION
		AND EXISTS IN LIB40 AS OVERFL.
		1. CALLING SEQUENCE-	JSA 16,OVERFL
					ARG	J
						;RETURN
		2. IF OVCNT=0, THEN J_1
		3. IF OVCNT=/0, THEN J_2
		4. THE OVERFLOW COUNTER, OVCNT, IS CLEARED TO 0

	C. OVTRAP IS A USER-MODE INTERRUPT ROUTINE WHICH IS STARTED
	  BY THE MONITOR WHEN AN ARITHMETIC FAULT OCCURS
		1. THE PC WORD (WITH THE ADDRESS OF THE INSTRUCTION
		      CAUSING THE TRAP) IS STORED IN OVPC.
		2. FOR FLOATING POINT INSTRUCTIONS
			A. FOR OVERFLOWS AND DIVIDE CHECKS,
			    THE FAULTY ANSWER IS PATCHED
			   TO BE PLUS OR MINUS (THE SIGN WILL BE THAT
			   OF THE CORRECT ANSWER)THE LARGEST POSSIBLE
			   NUMBER.
			B. FOR UNDERFLOWS, THE FAULTY ANSWER IS NORMALLY
			   PATCHED TO BE 0. HOWEVER, IF THE INSTRUCTION
			   FOLLOWING THE TRAPPING INSTRUCTION IS A JFCL
			   WITH BIT 16 (XR2) SET, THE ANSWER WILL BE
			   UN-NORMALIZED ENOUGH TO BRING THE EXPONENT
			   BACK INTO RANGE.
		3. (FOR INTEGER INSTRUCTIONS, NO PATCHING OF ANSWERS
		      IS DONE.)
		4. IF THE INSTRUCTION AFTER THE TRAPPING INSTRUCTION
		      IS JFCL
		      A. DO NOT TYPE AN ERROR MESSAGE
			 UNLESS BIT 9 (AR OV TEST BIT) OR 17 (XR1) IS 1
		      B. DO NOT INDEX THE OVERFLOW COUNTER OVCNT
		      C. IF THE ADDRESS (BITS 18-35) OF THE JFCL
			 ARE NON-ZERO, THE INTERRUPTED PROGRAM WILL
			 BE RESTARTED AT THE ADDRESS OF THE JFCL
			  (THE @ AND INDEX FIELDS ARE IGNORED).
		      D. IF THE ADDRESS OF THE JFCL IS ZERO, THE
			 INTERRUPTED PROGRAM WILL BE RESTARTED AT
			 THE JFCL
			E. IF BIT 16 (XR2) IS A 1, UN-NORMALIZE THE
			   FRACTION BITS FOR UNDERFLOWS IN ORDER TO
			   BRING THE EXPONENT BACK INTO RANGE.
		5. IF THE INSTRUCTION AFTER THE TRAPPING INSTRUCTION
		      IS NOT JFCL
		      A. INDEX THE OVERFLOW COUNTER, OVCNT
		      B. TYPE AN ERROR MESSAGE, USING SUBROUTINE "ERRMSG",
			 OF THE FOLLOWING FORM:

			INTEGER     OVERFLOW
			FLOATING    UNDERFLOW	PC=NNNNNN
			FLOATING    DIVIDE CHECK

		      C. THE INTERRUPTED PROGRAM WILL BE RESTARTED AT
			 THE INSTRUCTION AFTER THE TRAPPING INSTRUCTION
		6. THE PROCESSOR FLAGS (PC WORD FLAGS) ARE CLEARED
			EXCEPT FOR CRY0 AND CRY1.
		7. THE INTERRUPTED PROGRAM IS RESTARTED

III. LIMITATIONS

	A. OVTRAP FIXUPS WILL NOT WORK ON THE PDP-6 FOR-
		1. THE LOW ORDER WORD OF FXXRL OR FXXL INSTRUCTIONS
		2. EXPONENT UNDERFLOW OR DIVIDE CHECK TRAPS

	B. FLOATING POINT FIX UPS WILL NOT OCCUR FOR INSTRUCTIONS
	   THAT ARE EXECUTED BY AN XCT OR A UUO, OR FOR INSTRUCTIONS
	   THAT ARE IN ACCUMULATOR T=14


	C. THE MEMORY FIX UPS FOR THE FLOATING POINT INSTRUCTIONS
	   WILL NOT WORK PROPERLY IF THE ANSWER IS STORED INDEXED
	   BY 17 (THE PUSH DOWN POINTER). EXAMPLES:

			FADRM AC,(17)
			FMPRB AC,-2(17)
			FDVM  AC,+1(17)

	D. MOVNX AND MOVMX ARE INTEGER INSTRUCTIONS AND WILL HAVE
	   NO FLOATING POINT FIX UPS IF THEY CAUSE OVERFLOW
	E. TRAPPING INSTRUCTION MUST NOT BE IN ACCUMULATOR T=14
	F. THE SIGN OF F.P. DIVIDE CHECK FIX UPS WILL BE CORRECT
	    ONLY WHEN DIVIDING BY ZERO. (THIS IMPLIES THAT THE
	    ARGUMENTS FOR DIVIDE CHECKS SHOULD BE NORMALIZED.)

>	;END REPEAT 0

END
