BIT2DATA (PARSE TOKEN CLASS/OPERATOR BITS)
	CLSIDX__11

	OPER__0=18		;HIGH ORDER BIT FOR RESERVED WORD SYMBOL TABLE
	CLASOP__OPER+CLSIDX=18	;SAME, BUT FOR CLASS MEMBERS
ENDDATA

BEGIN	PARSE
DSCR PARSE --- Sail's production interpreter.
DES
	This is the production interpreter for the SAIL
	language.  It is table driven, by tables organized
	as follows.  Each production is represented by an entry:

1.	(optional name in ascii -- if bit 35 is on,
		signal the debugging package)
2.	xwd [where to go if compare FAILS],[where if SUCCEEDS]
3.	--ID numbers, etc. stored in 12 bit bytes.
4.	address of production to "pushj" to (optional).


	The interpreter has 5 parts.  The five operations are
	performed in series.  The last four are executed
	only if the first one (the compares on the parse stack)
	succeeds.  The parts are:

	1. Compare the parse stack with the ID numbers stored
		in the 12 bit bytes.  The types of compares and
		depth are determined by bits in the byte--
		The operations performed are:

	<no bits>	compare ID number against stack
	bclass		Compare class of stack element to ID class
	bcare		Careful compare -- ignore class information.
	bdone		Done -- go on to part 2.

		If the compares fail before reaching the "done"
		indication, the interpreter transfers its attention
		to the production named in the "FAIL" location.

	2. Pop the parse stack elements which are involved in
		the current production.  
		The top element is put in PARLEF, the
		next in PARLEF+1, etc.  The generator stack
		entries are popped (in synchronism) into temporaries
		GENLEF, GENLEF+1, etc.
	3. Restore the stacks.  The bytes are examined
		as above, starting where step 3 left off.
		The stacks are not actually restored at this time.
		Instead, the right half temporaries PARRIG and GENRIG
		are composed from information in the bytes:

	btemp		Restore the temporary pointed to by the
			12 bit byte.
	<no bits>	Use the byte as immediate information for
			the parse stack. 
	bdone		Done -- go to step 4.

	4. Call the necessary executive routine.  The bytes
		are examined

	<no bits>	Executive routine.  Use 12 bit byte as index
			into EXCTAB.
	bclass		Executive routine appropriate to class.
			Pick up the parse stack temporary
			pointed to by the current 12 bit byte.  Pick up next
			byte and subtract from first (this gives us
			a RELATIVE base). Then get the next 12 bit byte, and
			use it as index into EXCTAB for the routine
			to call.
	bdone		Done -- go to step 5.


	5. Scan.  The byte is the number of times to call the 
			scanner.
	6. This last byte (the one which specified the number of scans)
		may also indicate a production pushj or popj.
		
	bclass		pushj to the location specified in the next
			full word in the production tables.
	bcare		popj.




	The interpreter is called by:

		PUSH P,[PRODGO]
		JRST PARSE




;

DEFINE SUBR (X) <PUSHJ P,X>
;DECLARATIONS FOR ACCUMULATORS

ACDATA (PARSER)
	PP__SP
	GP__7
	PROD__10
	PTR__12


ZERODATA (PARSER VARIABLES)

FTCOUNT__0
IFN FTCOUNT <
CARCNT: 0	;COUNT OF NUMBER OF CAREFUL COMPARES
CLSCNT: 0	;COUNT OF NUMBER OF CLASS COMPARES
REGCNT: 0	;COUNT OF NUMBER OF REGULAR COMPARES
>;IFN FTCOUNT

;SAVPAR, SAVPOP, SAVSEM, TEMCNT -- temporaries for the PARSER
^SAVPAR: 0
^SAVPOP: 0
^SAVSEM: 0
TEMCNT: 0

SCNNO:	0	;ANOTHER TEMP

TABCONDATA (PARSER BIT TABLE)

; BIT TABLE FOR CLASS OPERATIONS -- GAIN SPEED OVER CALCULATING THEM
BITAB:
	FOR I_0,=35 <
	1  I >

DATA (PARSER PARSE TOKENS)

COMMENT 
 These variables allow access to PARSE token numbers, for use by
EXECS when they have to examine or change the PARSE stack -- for
example, TRAGO must search the PARSE stack to generate code
for leaving blocks, loops, etc.

^%ASSDO:	NASSDO & 777
^%DOL:		NDOL & 777
^%NBEG:		RBEGIN & 777
^%PDNO:		NPDNO & 777
^%NFORC:	NFORC & 777
^%NPDEC:	NPDEC & 777
^%OPC:		NOPC & 777		;OPCODE, SET BY SETSIZ (GENERATOR)
^%WHILC:	NWHILC & 777

ENDDATA
;DECLARATIONS OF CONTROL BITS IN PRODUCTION BYTES.

BITDATA (PARSER CONTROL)
BCLASS__	4000		;CONTROL BITS IN 12 BIT BYTE.
BTEMP __	2000
BCARE __	2000		;MUST BE SAME AS BTEMP
BDONE __	1000		;DONE WITH THIS "PHASE"

ENDDATA

^PRODGO:	BB0		;PRODUCTION WITH WHICH TO START


^PARSE:				;THIS IS THE PARSER !
	POP	P,PROD		;REMEMBER?
	HRRZ	PROD,(PROD)	;PICK UP SUCCESS POINTER
	IFN FTDEBUG <SETZM DEBTEM>
	SKIPA	C,[XWD 0,-1]	;REGISTER FOR CLASS COMPARE TEST AND START

FAIL:	HLRZ	PROD,(PROD)	;GET FAILURE POINTER

PROGO:	IFN FTDEBUG <
^PRODBK: JFCL	DUMPRO		;GO TO DEBUGGING PACKAGE.	>

POOG:	HRLZI	PTR,(<POINT 12,0>) ;INITIALIZE BYTE POINTER
	HRRI	PTR,1(PROD)	;MORE BYTE POINTER
	HRRZ	PP,PPSAV	;MOVE PARSE STACK POINTER INTO PP FOR USE
;MAIN COMPARE LOOP OF THE PRODUCTION INTERPRETER.

COMP:	ILDB	A,PTR		;PICK UP FIRST BYTE
	TRNE	A,BCLASS!BCARE!BDONE	;REGULAR COMPARE?
	JRST	NOREG		;NO
IFN FTCOUNT, <AOS REGCNT>
	CAME	A,(PP)		;COMPARE BYTE TO STACK
	JUMPN	A,FAIL		;GO TO FAILURE PRODUCTION UNLESS "SIGMA"
	SOJA	PP,COMP		;LOOP

NOREG:	TRZE	A,BCLASS	;CLASS COMPARE?
	JRST	CLASSCOM	;YES
	TRZN	A,BCARE		;CAREFUL COMPARE?
	JRST	POPTEM		;DONE WITH COMPARES

CARE:	HRRZ	B,(PP)		;GET ONLY ID NUMBERS FROM STACK
IFN FTCOUNT,<AOS CARCNT>
	CAIE	B,(A)		;COMPARE TOKEN AGAINST BYTE
	JRST	FAIL		;BAD COMPARE
	SOJA	PP,COMP


CLASSCOM:	
	CAML	C,(PP)		;LOOK TO SEE IF CLASS INDEX IS ON
	JRST	FAIL		;NO -- STACK ENTRY WAS NOT CLASS MEMBER
	MOVEI	CLSIDX,CLSTAB	;PREPARE THE INDEX REGISTER FOR TDNE@
	TRZE	A,400		;ON IF CLASS NUMBER GREATER THAN 36.
	MOVEI	CLSIDX,CLSTAB+CLASSNO	;OTHER CLASS TABLE.
	MOVE	B,BITAB-1(A)	;MAGIC BIT FOR THIS CLASS NUMBER.
IFN FTCOUNT, < AOS CLSCNT >
	TDNE	B,@(PP)		;SEE IF CLSTAB HAS THE BIT ON
	SOJA	PP,COMP		;YES -- GO ON
	JRST	FAIL		;NO

;POP OFF TOP OF STACK INTO TEMPORARIES.  THIS IS TO KEEP STACKS
;(GENERATOR AND PARSE) IN SYNC, AND KEEP EXEC ROUTINES FROM
;CLOBBERING THEM.

POPTEM:	HRRZ	C,PPSAV		;COMPUTE NUMBER OF THINGS TO POP.
	SUBI	C,(PP)		;OK, READY TO GO.
IFN FTDEBUG,<MOVEM C,DEBTEM>
	MOVE	GP,GPSAV	;PICK UP STACK POINTERS
	MOVE	PP,PPSAV
	SETZM	B		;ZERO THE INITIAL COUNTER
POPA:	SOJL	C,RESTA		;DONE POPPING ?
	POP	GP,GENLEF(B)	;POP GENERATOR ENTRY
	POP	PP,PARLEF(B)
	AOJA	B,POPA		;NOT DONE YET
RESTA:	MOVEI	B,-BDONE(A)	;TAKE ACCOUNT OF BIT.
	MOVEM	B,TEMCNT	;COUNT OF RIGHT HALF TEMPORARIES.
RESTB:	ILDB	A,PTR		;GET NEXT BYTE FROM TABLE
	JUMPE	B,EXECA
	TRZE	A,BTEMP		;RESTORE FROM TEMPORARY ?
	JRST	RESTMP		;YES
	CAIGE	A,CLASSNO	;RESTORE WITH CLASS INDEX?
	TLO	A,CLSIDX	;YES
	MOVEM	A,PARRIG-1(B)	;STORE IN RIGHT HALF TEMPORARY
	MOVE	C,GENLEF-1(B)	;SEMANTICS ARE COPIED FOR SAKE OF
	MOVEM	C,GENRIG-1(B)	;CONVENIENCE FOR  T SG  E SG
	SOJA	B,RESTB		;GO FOR MORE

RESTMP:	MOVE	C,PARLEF-1(A)	;GET THE TEMP. FROM THE LEFT STORAGE
	MOVEM	C,PARRIG-1(B)	;AREA AND PUT IT IN THE RIGHT ONE.
	MOVE	C,GENLEF-1(A)
	MOVEM	C,GENRIG-1(B)	;
	SOJA	B,RESTB		;LOOP UNTIL DONE.

;CALL ANY EXECUTIVE ROUTINES THAT ARE NEEDED.  THE TABLE
;EXCTAB, LISTING ALL ROUTINES, IS PUT TOGETHER BY THE
;PRODUCTION TABLE ASSEMBLER.

EXECA:	PUSH	P,PROD		;SAVE PRODUCTION POINTER
	MOVEM	PP,PPSAV	;SAVE PARSE STACK POINTER
	MOVEM	GP,GPSAV	;AND GENERATOR STACK POINTER

EXECB:	TRZE	A,BDONE		;DONE ?
	JRST	REST		; YES -- RESTORE STACKS.
	TRZE	A,BCLASS	;CLASS TYPE ROUTINE?
	JRST	EXCLS
EXGO:	PUSH	P,PTR
IFN FTDEBUG <
^EXCBK: JFCL	DMYEXC		;CALL THE DEBUG PACKAGE	>
	XCT	EXCTAB-1(A)	;CALL THE ROUTINE WITH GENCLS IN B	
EXDON:	POP	P,PTR		;RESTORE THE WORLD
	ILDB	A,PTR		;GET NEXT BYTE
	JRST	EXECB		;TRY AGAIN

EXCLS:	HRRZ	B,PARLEF-1(A)
	ILDB	A,PTR		;A NOW HAS AN INDEX UNTO THE CLASS
	SUB	B,A		;B HAS THE RELATIVE INDEX
	ILDB	A,PTR		;NOW INDEX TO ROUTINE
	JRST	EXGO		;GO DO THE ROUTINE
;RESTORE THE STACKS FROM THE TEMPORARIES.
;CALL THE SCANNER THE RIGHT NUMBER OF TIMES, AND
;GO START ALL OVER AGAIN.

REST:	MOVE	GP,GPSAV
	MOVE	PP,PPSAV
	SKIPN	B,TEMCNT
	JRST	SCANA

RES1:	PUSH	PP,PARRIG-1(B)	;RESTORE PARSE ITEM.
	PUSH	GP,GENRIG-1(B)	;AND SEMANTIC ITEM.
	SOJN	B,RES1		;GO BACK FOR MORE.



SCAN1:	MOVEM	PP,PPSAV	;SAVE STACK POINTERS
	MOVEM	GP,GPSAV	;SAVE STACK POINTERS
SCANA:	MOVEM	A,SCNNO	;NUMBER OF SCANS TO DO.
	TRNE	A,BCLASS!BCARE	;ANY POPJ'S OR PUSHJ'S TO DO?
	JRST	DPUSH		;YES.
	SOSGE	SCNNO		;GO SCAN.
	JRST	PARSE		;ALL DONE.
	PUSHJ	P,SCANNER	;;;;
	JRST	.-3		;AND LOOP UNTIL DONE.

DPUSH:	PUSH	P,PTR		;SAVE THIS -- WE WILL NEED IT.
	TRNN	A,777		;ANY SCANS TO DO?
	JRST	DOIT		;NO -- GO PUSH OR POP
	PUSHJ	P,SCANNER
	SOS	A,SCNNO		;DECREMENT SCAN COUNT.
	JRST	.-4		;AND LOOP

DOIT:	AOS	(P)		;RETRIEVED POINTER INTO PRODUCTION TABLE.
	TRNE	A,BCLASS	;IF PUSHJ, THEN
	JRST	PARSE		;DONE ---- .
	SUB	P,X22		;UNDO THE PUSH ABOVE, AND SOME MORE.
	MOVE	A,(P)		;PLACE WE ARE GOING BACK TO.
	MOVEM	A,SAVPOP	;SAVE IT FOR ERROR HANDLERS.
	JRST	PARSE		;AND CONTINUE.

	SUBTTL	Debug package.

^STPLIN: 
IFN FTDEBUG <
	PUSH	P,A
	SETOM	LSTPSW	;DO NOT PRINT HEADER FOR STACK
	MOVE	A,STPAGE	;WANTS TO STOP ON THIS PAGE NUM
	JUMPE	A,STPTHS	;EACH PAGE?
	CAME	A,FPAGNO	;HAS IT COME BY YET?
	 JRST	 LSTPJ		; (THERE WILL BE FILE REDUNDANCY)
	MOVE	A,STLINE	;RIGHT PAGE, IS IT THE
	CAMN	A,ASCLIN	; DESIRED LINE?
STPTHS:	JRST	[SETZM EXC	;CLEAR USELESS PARAMS
		 SETZM DEBTEM
		PUSHJ P,DMY
		JRST .+1]    ;YES, PRINT AND WAIT
LSTPJ:	SETZM	LSTPSW		;RESET
	POP	P,A
>
	POPJ	P,
IFN FTDEBUG	<
IFN TIMER, <
BEGIN TIMER
COMMENT 
	THIS IS A LITTLE TIMER THAT WORKS FOR SAIL.
	IF YOU START THE THING AT "TIMIT", THE COMPILER WILL
	BE INTERPRETED.  COUNTS OF THE GENERAL TYPE OF INSTRUCTION
	(IN INTAB) AND WHERE (IN THE BUCKETS DEFINED BY THE MACRO
	RR AT THE END) ARE KEPT.  USING THIS ROUTINE SLOWS COMPILATION
	DOWN BY A FACTOR OF ROUGHLY 25.


EXTERNAL JOBSA



;AC'S

ZZ _ 0 ;CRUCIAL IN NUMBERS.
AA _ 1 ;  DITTO.

^TIMIT:			;START HERE
	SETZM	INTAB
	MOVE	ZZ,[XWD INTAB,INTAB+1]
	BLT	ZZ,INTAB+7
	MOVEI	ZZ,BKLEN		;NUMBER OF BUCKETS IN TABLE.
	MOVEI	AA,BKBEG		;FIRST BUCKET.
BKLOP:	SETZM	1(AA)			;COUNT OF INSTRUCTIONS IN BUCKET.
	ADDI	AA,2
	SOJG	ZZ,BKLOP		;LOOP......

	HRRZ	AA,JOBSA		;WHERE TO START !!
	MOVEM	AA,PPCNT
	MOVEM	AA,PEECEE		;MY PROGRAM COUNTER

SEARCH:	MOVEM	3,SAV3
	MOVEM	ZZ,ZZSAV		;GET SOME AC'S
	MOVEM	4,SAV4

	MOVEI	ZZ,BKLEN
	MOVEI	3,BKBEG			;PREPARE TO SEARCH BLOCK.
COMLUP:	HLRZ	4,(3)			;LOWER BOUND
	CAIGE	AA,(4)			;ABOVE IT
	JRST	NOFAIL
	HRRZ	4,(3)
	CAILE	AA,(4)			;AND UNDER IT.
	JRST	NOFAIL
	HRRZM	4,CURTOP
	HLRZ	4,(3)
	HRRZM	4,CURBOT
	MOVEI	3,1(3)			;PLACE WHERE COUNT IS
	MOVEM	3,CURPNT

ALLON:	MOVE	3,SAV3
	MOVE	4,SAV4
	MOVE	ZZ,ZZSAV
	JRST	STARUP			;GO GO GO

NOFAIL:	ADDI	3,2
	SOJG	ZZ,COMLUP		;LOOK SOME MORE
	JRST	ALLON			;IF YOU CAN'T FIND A NEW BUCKET, USE
					;OLD ONE.

DOIT:	MOVE	AA,AASAV
INST:	XCT	@PPCNT			;MOST INSTR'S EXECUTED HERE.
	JRST	NEXT			;DID NOT SKIP
	AOS	PEECEE
NEXT:	MOVEM	AA,AASAV
RECORD:	SETZM	XCTF			;EXECUTE GOING ?
	MOVE	AA,PEECEE		;PC _ MA
	MOVEM	AA,PPCNT
RECGO:	CAML	AA,CURBOT		;SEE IF EFFECTIVE ADDRESS IN THIS
	CAMLE	AA,CURTOP		;BUCKET ...
	JRST	SEARCH			;NOT IN THIS BUNCH.
STARUP:	CAMN	AA,PROGS		;BREAK POINT
TIMBRK:	JFCL				;PLACE TO PLANT A REAL DDT BREAKPOINT
	AOS	@CURPNT			;INDEX THE BUCKET COUNTER
	LDB	AA,[POINT 3,@PPCNT,2]	;INSTRUCTION
	SKIPN	XCTF
	AOS	PEECEE			;PC _ PC +1
	AOS	INTAB(AA)		;RECORD INSTRUCTION FREQUENCY
	JRST	@DISTAB(AA)

INTAB:	BLOCK 10
DISTAB:	UUOINST				;DISPATCH TABLE
	DOIT
	SPECL
	JUMPS
	DOIT
	DOIT
	DOIT
	DOIT


UUOINST:
	LDB	AA,[POINT 9,@PPCNT,8]
	CAIE	AA,41			;INIT ?
	JRST	DOIT
	ERR	<INIT'S ARE NOT USED IN SAIL>

JUMPS:	LDB	AA,[POINT 6,@PPCNT,5]	;INTERPRET JUMPS
	CAIN	AA,32
	JRST	JUMPXX
	CAIE	AA,34
	CAIN	AA,36
	SKIPA
	JRST	DOIT
JUMPXX:	MOVE	AA,@PPCNT
	TLZ	AA,37
	HLLM	AA,JMPINS		;SAVE IT.
	MOVE	AA,AASAV
JMPINS:	JRST	TRA			;GO TO TRA IF IT TAKES.
	JRST	NEXT			;DID NOT TAKE.
TRA:	MOVEM	AA,AASAV
	MOVEM	ZZ,ZZSAV
TRAIT:	
	MOVE	ZZ,@PPCNT
	MOVEI	ZZ,@ZZ			;DEPENDS ON ZZ BEINO ZERO.
	MOVEM	ZZ,PEECEE		;NEW VALUE
	MOVE	AA,ZZ
	MOVE	ZZ,ZZSAV
	JRST	RECORDIT

SPECL:	LDB	AA,[POINT 9,@PPCNT,8]
	TRCE	AA,30
	TRNN	AA,40
	JRST	DOIT
	TRCN	AA,30
	JRST	DOIT
	TRNN	AA,10
	JRST	DPUSHJ			;OP CODES 260 - 267
	CAIE	AA,256			;XCT
	JRST	[CAILE	AA,251
		 JRST	JUMPXX
		 JRST	DOIT]
	SETOM	XCTF			;START EXECUTE CYCLE
	MOVEM	ZZ,ZZSAV
	MOVE	ZZ,@PPCNT
	MOVE	AA,AASAV
	MOVEI	ZZ,@ZZ			;EFFECTIVE ADDRESS....
	MOVEM	ZZ,PPCNT
	MOVE	AA,ZZ
	MOVE	ZZ,ZZSAV
	JRST	RECGO


DPUSHJ:	MOVEM	ZZ,ZZSAV
	ANDI	AA,7
	JRST    @.+1(AA)

	PUSHJ1
	DOIT
	DOIT
	POPJ1
	JSR1
	JSP1
	JSA1
	JRA1

PUSHJ1:	MOVE	ZZ,PEECEE
	LDB	AA,[POINT 4,@PPCNT,12]
	DPB	AA,[POINT 4,.+3,12]
	EXCH	ZZ,ZZSAV
	MOVE	AA,AASAV
	PUSH	ZZSAV
	JRST	TRA

POPJ1:	LDB	AA,[POINT 4,@PPCNT,12]
	DPB	AA,[POINT 4,.+2,12]
	MOVE	AA,AASAV
	POP	PEECEE
	MOVEM	AA,AASAV
	HRRZS	AA,PEECEE
	JRST	RECORDIT

JSR1:	MOVE	ZZ,@PPCNT
	MOVE	AA,AASAV
	MOVEI	ZZ,@ZZ
	MOVE	AA,PEECEE
	MOVEM	AA,@ZZ
	AOS	AA,ZZ
	MOVEM	AA,PEECEE
	MOVE	ZZ,ZZSAV
	JRST	RECORDIT

JSP1:	LDB	AA,[POINT 4,@PPCNT,12]
	MOVE	ZZ,PEECEE
	MOVEM	ZZ,ZZSAV(AA)	;RECORD IN BOTH PLACES.
	MOVEM	ZZ,(AA)
	JRST	TRAIT

JSA1:	JRA1:
	ERR	<NOT IMPLEMENTED>

PPCNT:	0
CURTOP:	0
CURBOT:	0
ZZSAV:	0
AASAV:	0
BLOCK 20
SAV3:	0
SAV4:	0
XCTF:	0
PEECEE:	0
CURPNT:	0
PROGS:	0




BKLEN	_=12
BKBEG:	
DEFINE RR (BEGINNING,ENDD) < XWD BEGINNING,ENDD
			0
>

	RR	LARGER,PRODGO	;COMMAND SCANNER & INITIALIZATION
	RR	PARSE,<POPTEM-1>;PRODUCTION SEARCHER
	RR	POPTEM,TIMIT-1	;STACK POPPER & EXEC ROUTINE CALLER
	RR	BKBEG,<SCAN-1>	;DEBUGGING ROUTINES
	RR	SCAN,<ENTER-1>	;SCANNER ...
	RR	ENTER,<GENINI-1>;SYMBOL TABLE LOOKUP & ENTER
	RR	GENINI,<LEPINI-1>;HIGH LEVEL ARITHMETIC GENERATORS
	RR	LEPINI,<CONV-1>;HIGH LEVEL LEAP GENERATORS
	RR	CONV,RINGSORT-1	;LOW LEVEL GENERATORS
	RR	RINGSORT,PATCH	;CORE MANAGEMENT, STRING GARBAGE COLLECTOR
	RR	400000,777777	;CORE MANAGEMENT, STRING GARBAGE COLLECTOR
	BLOCK =2






BEND
>

>;TEMPORARY END OF IFN FTDEBUG
Comment	
	Here begins the debugging package.
	The aim is to print out information about any productions
	flagged by having the low order bit of the name word on.
	If the executive routines are merely dummies, this will
	also dump out information about the stacks when execs are
	called.  
	After printing out the name of the caller
	and several stack entries, the tty will
	be required to respond:

	"b"	--breakpoint operation.  Must be followed by
		  "s" (set) or "r" (remove) and the production
	 	  name, followed by a space.
	xxM	--set mode.  Must be preceded by a number  xx :
			1 print out just execs.
			2 print out nothing.
			3 everything
			4 multiple proceed until breakpoint.
			5 display the line being scanned.
			6 disable debugging mode, full speed ahead
	"c"	--count the free storage cells.
	"p"	--proceed
	"d"	--go to ddt or raid -- operates by setting a breakpoint
		if using RAID -- return with <ctrl>P.  In DDT, return
		by REGO$G
	"l"	-- stop on line -- followed by line/page#, compiler
		 will stop just after reading specified line, but 
		 before scanning it. If /page is omitted, current one
		 implied -- other commands may appear after L, but
		 nothing happens until CRLF typed (for editing line#)

	xxS	--a number of a stack entry
		(relative to current top) to print

	"t"	--terminate and return to error handler.

This whole section of code is merely a convenience, and not really
part of the guts of the compiler.  Most of the routines were written
to satisfy real debugging needs as the compiler was being developed.


ZERODATA (PARSE DEBUGGER VARIABLES)

COMMENT 
PRODUCTION/EXEC BREAK CONTROL VARIABLES

.DBG. -- This value is set by the /M switch in the command line,
    or by the M parameter in the Debugging Scanner.  Its values,
    corresponding "M" codes, and functions are ---
  0 --  /2M --  Do not break on anything but "asynchronous break"
		(user types CR to break in)
  >0 -- /3M --  Break when EXEC routine to be executed
  <0 -- /1M --  Break when any production matches, or on EXEC
	/5M and /6M cut .DBG. out of the loop.

^^.DBG.: 0

ASYNSW: 0	;TEMP USED IN DMY TO INDICATE ASYNCH. BREAK

;BREAKP -- set if DMY is being executed because of a production
;    breakpoint -- see DSCR for debug routines for more details
BREAKP: 0

;EXC -- set before DMY is called -- 0 if PRODUCTION Break,
;    -1 if EXEC break (unless ASYNSW set, then irrelevant)
EXC:	 0

;MULTP -- set if user is not to be given control after input
;    line, stack, etc. are displayed (subject to ASYNSW, of
;    course (/4M mode)
^^MULTP: 0

;PLINSW -- set if input line is to be displayed at every possible
;   moment  (/5M mode)
^^PLINSW: 0

COMMENT 
OTHER DEBUGGER VARIABLES, RICH AND POOR

IFN FTDEBUG < ;JUST CONDIT THE BIG ONES
ACSAV -- block for saving ACs when doing DMY

ACSAV:	BLOCK	20
>

ASAV:	0	;SAVE AC A SOMETIMES

ASYNTMP: 0	;TEMP FOR ASYNCHRONOUS STUFF

COMMENT 
BKR -- specifies break character for ASCFIL routine -- see for
    details (used to allow ASCII strings to be considered as
    single entities at one time, for shipping around,  later
    as groups of characters, to be interspersed with other data
    e.g., setting up title lines, printing display line, etc.

^^BKR:	0


CHAR:	 0	;TEMP FOR DEBUGGER SCANNER

IFN FTDEBUG <
COMMENT 
DDFBUF, DDFPDL, DDRES
  Variables for implementing the DDFIND routine -- called from
  RAID or DDT to find the Semantics currently corresponding
  to a name.

DDFBUF: BLOCK	6	;FOR INPUT OF ID
DDFPDL: BLOCK	11	;SPECIAL PDP
^^DDRES: 0		;RESULT IF FOUND
;DDFPDP -- SEE ALSO, BELOW
>

DEBTEM: 0		;A TEMP

COMMENT 
EXROUTIN -- A call to the desired EXEC is placed here before
   going into the debugging business -- at an appropriate 
   point, after the stack has been displayed, and the user
   has had a chance to respond (he can look at EXROUTIN, among
   other things), this is XCTed -- not used if not debugging

^^EXROUTIN: 0

;FILBP -- PNEXTC transferred here when macro expansion is entered.
;   Used to print arrow on input line display (see ASCFIL)
^^FILBP: 0	;CONSIDER PUTTING THIS ELSEWHEREIRAN:  0	;RANDOM TEMP

LSTPSW: 0	;FLAG INDICATING LINE # BREAK TO DMY

NEG:	 0	;RANDOM FLAG FOR NUMBER INPUTTER IN DEBUG SCANNER

SENC:	 0	;RANDOM TEMP

SETB:	 0	;RANDOM TEMP

STLINE: 0	;LINE # (ASCII) ON WHICH TO CAUSE LINE BREAK
^^STPAGE: 0	;PAGE # (BINARY) ON WHICH TO CAUSE LINE BREAK

DATA (PARSE DEBUGGER VARIABLES)

IFN FTDEBUG <
COMMENT 
HEADINGS FOR DEBUG OUTPUT (DESCRIBES REASON FOR BREAK, ETC.)


^^ASYBUF: ASCIZ	"ASYNCHRONOUS BREAK
"

^^HBUF:	ASCIZ	"PRODUCTION IS                    "

^^HDBUF: ASCIZ	"LINE BREAK
"

^^XBUF:	ASCIZ	"EXEC ROUTINE                     "


DDFPDP: IOWD	10,DDFPDL	;PDP FOR DDFPDL (SEE DDRES)

;OBUF -- Output buffer for TTYUUO'S to type stack info
OBUF:	ASCII/                                                           /
	BLOCK	10

>
ENDDATA
IFN FTDEBUG <	;RESUME CONDITIONAL ASSEMBLY
EXTERNAL	JOBDDT

DMYEXC:	PUSH	P,EXCTAB-1(A)	;THE EXEC ROUTINE
	POP	P,EXROUTIN
	SETOM	EXC
	MOVEM	A,ASAV
	SKIPE	.DBG.	;DON'T DEBUG IF THIS SWITCH UNSET
	PUSHJ	P,DMY
	XCT	EXROUTIN		;DO IT IF NECESSARY.
	PUSHJ	P,ASYNCHK
	JRST	EXDON



DUMPRO:	MOVE	A,-1(PROD)	;PICK UP PRODUCTION NAME
	SETZM	BREAKP
	SETZM	EXC
	MOVEM	A,ASAV
	TRNE	A,1		;A BREAKPOINT ?
	JRST	[SETOM BREAKP
		JRST YESPRO]
	SKIPGE	.DBG.		;DO NOT DEBUG IF NOT NEGATIVE
YESPRO:	PUSHJ	P,DMY
	JRST	POOG

ASYNCHK:
	SKIPE	.DBG.		;IF NOT DEBUGGING OR
	SKIPE	MULTP		; DEBUGGING UNCONTROLLABLY,
	JRST	ASCH1		; GO SEE IF USER HAS INTERRUPTED.
	POPJ	P,		;ELSE A LONG NOOP
ASCH1:	SKIPN	PLINSW
	 JRST	 ASCH2
ASCH2:	TTCALL	5,ASYNTMP
	POPJ	P,
	SETOM	ASYNSW
	TTCALL	11,
	PUSHJ	P,DMY
	SETZM	ASYNSW
	POPJ	P,

DMY:	MOVEM	0,ACSAV
	MOVE	0,[XWD 1,ACSAV+1]
	BLT	0,ACSAV+16	;SAVE ALL ACCUMULATORS


; DISPLAY A PRINT LINE IF RUNNING A DISPLAY

	PUSHJ	P,DSPLIN	;DISPLAY IF POSSIBLE
	JFCL			;IT DOESN'T MUCH MATTER ANYWAY

	SETZM	CHAR		;CHARACTER COUNTER
	MOVEI	A,HDBUF
	SKIPE	LSTPSW		;LINE NUMBER BREAK?
	 JRST	 PRTHED		;YES, PRINT SIMPLE HEADING
	MOVEI	A,ASYBUF
	SKIPE	ASYNSW
	 JRST	 PRTHED
	MOVE	PTR,[POINT 7,HBUF+3]
	SKIPE	EXC		;CALLED FROM EXECUTIVE HANDLER?
	HRRI	PTR,XBUF+3	;YES
	MOVE	A,ASAV		;GET SIXBIT OR  TO IT BACK
	SKIPE	EXC
	MOVE	A,EXCNAM(A)	;GET EX NAME

	PUSHJ	P,PRINSYM	;PRINT THE SYMBOL
	PUSHJ	P,CRLF
	MOVEI	A,HBUF
	SKIPE	EXC
	MOVEI	A,XBUF
PRTHED:	CALL	A,[SIXBIT/DDTOUT/]
	MOVEI	A,0
	MOVE	B,DEBTEM
	ADDM	B,GPSAV
	ADDB	B,PPSAV
P6:	PUSH	P,A
	PUSH	P,B
	SETZM	CHAR
	PUSHJ	P,PRINLIN
	POP	P,B
	POP	P,A
	SOS	A
	SOJE	B,P6A
	SKIPE	EXC
	JRST	.+4
	CAME	A,[-3]
	JRST	P6
	JRST	P6A
	MOVN	C,A
	CAME	C,DEBTEM
	JRST	P6


P6A:	MOVN	B,DEBTEM
	ADDM	B,PPSAV
	ADDM	B,GPSAV
	SKIPE	ASYNSW		;STOP IF USER TYPED
	JRST	IN1		;INTERRUPTION CHAR
	SKIPN	LSTPSW		;STOP ON LINE BREAK ALWAYS
	SKIPN	MULTP		;IN MULTIPLE PROCEED?
	JRST	IN1		;NO
	SKIPN	BREAKP
	JRST	PRO		;PROCEED IF NO BREAKPOINT.
IN1:	MOVE	A,(P)		;ADDRESS OF WHERE TO RETURN.
	HRRM	A,REGO		;FIX UP THE INSTRUCTION FOR DDT.
^INNA:	SETZB C,NEG
INN:	TTCALL	A		;GET A CHAR FROM USER
	CAIN	A,"P"
	JRST	PROXX		;PROCEED
	CAIN	A,"D"		;GO TO DDT
	JRST	DDTG
	CAIN	A,"B"	;BREAKPOINT
	JRST	BP1
	CAIN	A,"T"
	ERR	<YOU ARE INSIDE THE ERROR HANDLER>
	CAIN	A,"S"	;STACK EXAMINE.
	JRST	STA
	CAIN 	A,"M"		;MODE
	JRST	MOD1
	CAIN	A,"C"		;COUNT
	JRST	SCNT
	CAIN	A,"L"		;PAGE AND LINE BREAK SPECS?
	 JRST	 LINSTOP	; YES
	CAIE	A,"-"
	JRST	[CAIG A,"9"
		CAIGE A,"0"
		JRST INN
		IMULI C,=10
		ADDI C,-"0"(A)
		JRST INN]
	SETOM	NEG
	JRST	INN

STA:	
	SKIPL	NEG
	MOVNS	C		;WE WERE TOLD TO COMPLEMENT IT
	MOVE	A,C
	ADD	A,DEBTEM	;TO GET INREASONABLE RANGE.
	PUSHJ	P,PRINLIN
	JRST	INNA

BP1:	TTCALL	A
	CAIN	A,"S"		;SET?
	SETOM	SETB
	CAIN	A,"R"
	SETZM	SETB
	SETZB	B,SENC
	MOVE	C,[POINT 6,B]
BPX:	TTCALL	A
	SUBI	A,40		;CONVERT TO SIXBIT
	SKIPN	SENC
	JUMPE	A,BPX
	IDPB	A,C
	SETOM	SENC
	JUMPN	A,BPX
	MOVEM	B,HIRAN

	MOVEI	A,BB0-1		;START HERE
FLOP:	CAIN	A,IPROC		;END HERE
	JRST	NOFND
	MOVE	C,(A)
	TRZ	C,1		;TRUN OFF DEBUG BIT.
	CAMN	C,B
	JRST	YESFND
	AOJA	A,FLOP

LINSTOP: ;GET LINE/PAGE NUMBERS
	TTCALL	14,0		;WAIT FOR ACTIVATOR
	SETZM	STLINE
	MOVE	TEMP,[POINT 7,STLINE]
	MOVEI	B,5		;MAX USABLE COUNT
LSLP10:	TTCALL	A		;GET A CHAR
	CAIL	A,"0"
	CAILE	A,"9"		;IS IT A DIGIT?
	JRST	LSLP10		;NO
	SKIPA			;YES
LSLP1:	TTCALL	A		;GET A CHAR
	CAIL	A,"0"
	CAILE	A,"9"		;DIGIT?
	 JRST	 LSLP2		;NO, DONE
	SOJL	B,LSLP1		;FORGET AFTER 5
	IDPB	A,TEMP		;PUT IT AWAY
	JRST	LSLP1		;LOOP
LSLP2:	MOVE	B,STLINE	;GET RESULT
LSLP3:	TRNE	B,376		;LOW ORDER 0?
	 AOJA	 B,LSLP4	;NO, ALL OK
	LSH	B,-7
	TLO	B,"0"(=18-7)	;YES, PUT IN ZEROES
	JRST	LSLP3		;LOOP UNTIL ALL ASCII CHARS
LSLP4:	MOVEM	B,STLINE	;RESTORE IT
	CAIE	A,"/"		;PAGE # SPECIFIED?
	 JRST	 INNA		;NO
	MOVEI	B,0		;YES, GET PAGE #
LSLP6:	TTCALL	A		;GET A CHAR
	CAIL	A,"0"
	CAILE	A,"9"		;DIGIT?
	 JRST	 LSLP5		; YES, DONE
	IMULI	B,=10
	ADDI	B,-"0"(A)	;COLLECT NUMBER
	JRST	LSLP6		;LOOP
LSLP5:	MOVEM	B,STPAGE
	JRST	INNA		;DONE


NOFND:	TERPRI	<NOT FOUND>
	JRST	INNA

YESFND:	SKIPE	SETB
	TRO	C,1
	MOVEM	C,(A)		;PUT IT BACK.
	JRST	INNA

MOD1:	
	JUMPL	C,INNA
	CAIG	C,6
	PUSHJ	P,@SWDSP		;(SEE COMMAND SCANNER)
	JRST	INNA





SCNT:	SETZM	C
	SKIPA	LPSA,BLFREE
SLOPP:	RIGHT	,%TBUCK,ALDD
	AOJA	C,SLOPP
ALDD:	OCTPNT	C
	JRST	INNA


PROXX:	TTCALL	11,		;CLEAR INPUT BUFFER BEFORE PROCEEDING
	JRST	PRO

DDTG:	MOVE	A,JOBDDT
	HLRZ	B,1(A)		;INSTR AT DDT+1
	CAIN	B,(<JSR>)	; A JSR IN RAID, NOT IN DDT
	 JRST	 [MOVEI B,BRKHER;SET BREAK POINT
		  JSR	B,@-1(A);VIA ADDR IN VECTOR
		  JRST  PRO]
	MOVEM	A,(P)		;NEW ADDRESS.
PRO:
	MOVE	0,[XWD ACSAV+1,1]
	BLT	0,16
	MOVE	0,ACSAV
BRKHER:	TRN			;<0 IF NO BREAKPOINT SET HERE
	SKIPL	BRKHER		;TEST IF BREAKPOINT SET
	 JRST	 [MOVEM A,ACSAV+1 ;YES (JSR>0)
		  MOVEM B,ACSAV+2
		  MOVE	A,JOBDDT
		  MOVEI B,BRKHER
		  JSR   B,@-2(A);JSR $RBP TO REMOVE BREAKPOINT
		  MOVE  A,ACSAV+1
		  MOVE  B,ACSAV+2
		  POPJ	P,]	;DONE
	POPJ	P,		;AWAY WE GO


^REGO:	JRST	.
;ROUTINE TO PUT TOGETHER A LINE ABOUT THE STACK ENTRY
;WHOSE INDEX IS IN REGISTER "A"

PRINLIN:	MOVEM	A,ASAV
	MOVE	B,PPSAV
	ADDI	B,(A)
	MOVE	B,(B)		;STACK ENTRY
	MOVEI	C,"@"
	CAIG	B,400000
	MOVEI	C," "
	DPB	C,[POINT 7,OBUF,27]	;CLASS TYPE?
	MOVE	A,SYMNAM (B)	;PRINT NAME
	MOVE	PTR,[POINT 7,OBUF+1]
	PUSHJ	P,PRINSYM
	MOVE	PTR,[POINT 7,OBUF+2,27]
	MOVE	B,GPSAV
	ADD	B,ASAV
	MOVE	A,(B)
	PUSH	P,A	;GENERATOR ENTRY
	PUSHJ	P,NUM
	PUSHJ	P,SPOUT
	MOVE	D,(P)	;IS THERE AN ENTRY?
	MOVE	B,GOGTAB	;POINTER TO TH WORLD
	CAMGE	D,LPSTOP(B)
	CAMGE	D,LPSBOT(B)

PING:	JRST	CRLF0	
	HLRZ	A,$TBITS(D)
	PUSHJ	P,NUM
	PUSHJ	P,SPOUT
	HRRZ	A,$TBITS(D)	;TBITS
	PUSHJ	P,NUM
	PUSHJ	P,SPOUT
	HLRZ	A,$SBITS(D)
	PUSHJ	P,NUM
	PUSHJ	P,SPOUT
	HRRZ	A,$ACNO(D)
	PUSHJ	P,NUM
	PUSHJ	P,SPOUT
	HRRZ	A,$PNAME(D)	;COUNT
	JUMPE	A,CRLF0		;NO PRINT NAME
	CAILE	A,15
	MOVEI	A,15
	MOVE	D,$PNAME+1(D)
SRFF:	ILDB	TEMP,D
	IDPB	TEMP,PTR
	SOJG	A,SRFF


	
CRLF0:	POP	P,A
	TRZ	C,177
	IDPB	C,PTR
	TTCALL	3,OBUF		;PRINT THE LINE
	TERPRI			;TERMINATE IT
	POPJ	P,

CRLF:	MOVEI	C,15
	IDPB	C,PTR
	MOVEI	C,12
	IDPB	C,PTR
	TRZ	C,177
	IDPB	C,PTR
	POPJ	P,

SPOUT:	MOVEI	TEMP," "
	IDPB	TEMP,PTR
	POPJ	P,
Comment  DDFIND -- find symbol for USER.
	Called from DDT or RAID by typing DDFIND$G  

^DDFIND: EXCH	P,DDFPDP		;IN CASE RAID IS DISHONEST
	PUSHJ	P,SAVE		;IN GOGOL.IOSER
	SETZM	DDFBUF
	MOVE	TEMP,[XWD DDFBUF,DDFBUF+1] ;CLEAR BUFFER
	BLT	TEMP,DDFBUF+5
	MOVEI	A,0		;COLLECT COUNT
	PUSH	P,PNAME
	PUSH	P,PNAME+1
	MOVE	B,[POINT 7,DDFBUF]
	MOVEM	B,PNAME+1	;FIRST BYTE OF PNAME
	
DDF1:	TTCALL	TEMP		;GET A CHARACTER
	CAIN	TEMP,15		;TERMINATES
	 JRST	 DDFDUN
	IDPB	TEMP,B		;YES
	AOJA	A,DDF1		;GET IT ALL
DDFDUN:	HRRZM	A,PNAME		;COUNT
	PUSH	P,HPNT
	PUSH	P,NEWSYM
	MOVE	LPSA,SYMTAB
	PUSHJ	P,SHASH
	SKIPE	A,NEWSYM
	TERPRI	<FOUND IT -- RESULTS IN DDRES>
	SKIPN	A
	TERPRI	<NOT FOUND>
	MOVEM	A,DDRES
	POP	P,NEWSYM
	POP	P,HPNT
	POP	P,PNAME+1
	POP	P,PNAME
	MOVEI	LPSA,0
	MOVEI	TEMP,.+3
	MOVEM	TEMP,UUO1(USER)
	JRST	RESTR
	EXCH	P,DDFPDP
	POPJ	P,		;SINCE HE CALLED IT WITH PUSHJ P,

PRINSYM:	
	MOVNI	C,6	;COUNT
P1:	SETZM	B
	ROTC	A,6
	ADDI	B,40		;CONVERT TO ASCII
	IDPB	B,PTR
	AOS	CHAR
	AOJN	C,P1
	POPJ	P,


NUM:	MOVNI	C,6
	ROT	A,=18
PEP2:	SETZM	B
	ROTC	A,3
	ADDI	B,"0"
	IDPB	B,PTR
	AOS	CHAR
	AOJN	C,PEP2
	POPJ	P,


SIXBT:	MOVNI	C,3
P3:	SETZM	B
	ROTC	A,6
	ADDI	B,40
	IDPB	B,PTR
	AOS	CHAR
	AOJN	C,P3
	POPJ	P,

>			;end of IFN FTDEBUG conditional assmby.
DSCR DECFIL
CAL PUSHJ from text-line creators
PAR D is number to be converted to ASCII
 TEMP is ASCII bp to output
RES ASCII for D (with sign, if neg) is deposited via TEMP
SID D, D+1 destroyed, TEMP updated

^DECFIL:	; PUT A POSITIVE NUMBER IN ASCII IN BUFFER
		; POINTED TO BY TEMP

	JUMPGE	D,POSFIL	;MIGHT BE NEGATIVE
	MOVEI	D+1,"-"
	IDPB	D+1,TEMP
	MOVMS	D		;ISN'T NOW

POSFIL:	IDIVI	D,=10
	HRLM	D+1,(P)	;IT'S RECURSIVE PRINTER TIME AGAIN
	SKIPE	D
	PUSHJ	P,POSFIL
	HLRZ	D,(P)
	IORI	D,"0"
	IDPB	D,TEMP
	POPJ	P,

DSCR ASCFIL
CAL PUSHJ from routines which create text lines
PAR A is input BP
 BKR is break char
 TEMP is output BP
 FILBP (in compiler) is bp to a char which is to be indicated
  by an arrow. (via DPY instrs if NOEXPO, LF otherwise).
RES Text is moved from A's area to TEMP's, stopping when
  an input char = BKR (or if BKR<0, when char terminates line).
 If A ever = FILBP, stuff is done to produce the arrow or line
  feed (assumes that when this happens, output is going to DPY).
SID B is destroyed, A and TEMP are updated.

^ASCFIL:CAME	A,FILBP
	 JRST	 NOARROW		;NOT YET (OR NOT AGAIN)
		 MOVEI	B,12
		 IDPB	B,TEMP		;NO, USE LINE FEED TO
NOARROW:
	ILDB	B,A
	SKIPGE	BKR
	JRST	[JUMPE	B,YPOPJ   ;IN THIS MODE, WANT TO
		 CAIE	B,177	  ;STOP ON 0, 12, OR 177
		 CAIN	B,12
		 POPJ	P,
		 JRST	FDIPB]
	CAMN	B,BKR		;DONE?
YPOPJ:	 POPJ	P,
FDIPB:	IDPB	B,TEMP		;NO -- STORE THIS ONE
	JRST	ASCFIL

	XALL
SUBTTL Production Tables.
                                                                                                                                                                                                                                                                                                                                                                                                                                 	}(