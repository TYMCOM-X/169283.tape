TITLE	LIBINT	SFO LIBRARY INTERFACE ROUTINES-RDO/RDO


        LOC     <.JB41=:41>
        PUSHJ   17,UUO
        RELOC

ENTRY   RESET.,EXIT.,CONER.,NCNER.,$MSGIN,ONINT.,OFINT.,$RESTA,GETP.,SETP.
ENTRY	SFSZ.,STRG.,STRGA.,SSTR.,SSTRA.,SEST.,SBST.,SMAX.,SMIN.,LNGTH.
ENTRY	INDX.,SKSE.,SKSN.,SKSL.,SKSLE.,SKSG.,SKSGE.,SCHAR.,SDATE.,SASC.
ENTRY	SRMOV.,IVAL.,VAL.,DVAL.,CVAL.,STR.,SLFT.,SRGHT.,SPNT.,STM.
ENTRY	OPEN.,CLSAL.,CLOSE.,ENC.,DEC.,RTB.,WTB.,IN.,OUT.
ENTRY	FIN.,IOLST.,BOOL.,TIME.,$CURLI

DEFINE E(A,B)<
EXTERN $'A
IFB<B>,<A==$'A>
IFNB<B>,<B==$'A>
>

E ASC
E BUFCNT
SEXTERN CHAIN.
E CHAR
E CMPEL
E CMPEA,CMPELA
E CONERR
E DATE
E DBEL
E DBELA
E EOFLAB
E ERRLAB
E ERRVAR
E XIT,EXIT
E FPROT
E INDEX
E INTEL
E INTEA,INTELA
E IOCS
E IOINIT
E IOREST
E IOSAVE
E LEFT
E LENGTH
E LGCEL
E LGCEA,LGCELA
E NCNERR
E NMLIN
E NMLOUT
E OFINT
E ONINT
E RIGHT
E RLEL
E RLELA
E RUNCTL
E SESTRT
E SFCLS
E SFCLA,SFCLSA
E SFCVAL
E SFDEF
E SFDEA,SFDEFA
E SFDVAL
E SFENF
E SFENA,SFENFA
E SFEOL
E SFIVAL
E SFOIO
E SFOPN
E SFOPA,SFOPNA
E SFP
E SFPRIN
E SFR
E SFRF
E SFRFA
E SFSETP
E SFSTR
E SFSZ
E SFVAL
E SFW
E SFWF
E SFWFA
E SKPSE
E SKPSG
E SKPGE,SKPSGE
E SKPSL
E SKPLE,SKPSLE
E SKPSN
E SMAX
E SMIN
E SREMOV
E SSTOR
E SSTOA,SSTORA
E STM
E STREL
E STREA,STRELA
E STRINT
E STRNG
E STRNA,STRNGA
E SUBSTR
E XLINK


TYP.ST=	15		;; STRING TYPE.
L=	16			; ARG BLK POINTER REGISTER.
NUUOS=	6			; NR OF STRING UUO'S.
STMUUO=	5			; STM UUO OP CODE.
STKSZ=	240
R=	17


	DEFINE	SAVEM	<
	MOVEM	17,B+17		;; SAVE
	MOVEI	17,B		;;   THE
	BLT	17,B+16		;;     REGISTERS.
				>

	DEFINE	SSAVEM
<	SAVEM
	MOVE	R,[OPNPRM,,DIALOG] ;; CLEAR OPEN PARAMS AREA.
	CLEARM	OPNPRM
	BLT	R,ASSOC
				>




DEFINE RSTOREM
<	HRLZI	17,B
	BLT	17,17
	POPJ	17,
					>

	DEFINE CLLN(PROC)
<	SAVEM
	JSP	17,PROC		;; CALL PROC W/OUT ARGUMENTS.
	MOVEM	1,B		;; FCN VALUE MAYBE?
	RSTOREM			;; ALL DONE.
					>



        DEFINE  CLL(PROC)
<       SAVEM                   ;; SAVE ALL AC'S.
        JSP     17,ARGS         ;; GET THE ARGUMENTS.
        JSP     17,PROC         ;; CALL THE ROUTINE.
	MOVEM	1,B		;;FOR FUNCTION VALUE,IF ANY.
	RSTOREM
                        >



        DEFINE  CLLSK(PROC)
<       SAVEM           	;;SAVE AC'S.
        JSP     17,PROC 	;;CALL THE PROCEDURE.
	HRRZ	2,B+17		;; ADD 0 OR 1 TO USER'S PC.
	ADDM	1,(2)
	RSTOREM			;; DONE.
                                >


RESET.::
	MOVEM	16,START	; SAVE STARTING LOCATION
	JSP	17,IOCS		; INITIALIZE IOCS
	JSP	17,SFOIO  	; MORE INITIALIZATION.
	JSP	17,IOINIT  	; SAME HERE.
	JSP	17,RUNCTL	; INITIALIZE RUNTIME CONTROL
	MOVE	17,[IOWD STKSZ,STAK]	; INITIALIZE STACK POINTER.
;	PUSHJ	17,TRPIN.##	; INITIALIZE OVERFLOW TRAPPING
	MOVE	16,START
	JRST	1(16)		; START PROGRAM

EXIT.:: CLLN    (EXIT)          ; EXIT FROM PROGRAM. END AND STOP STATEMENTS

CONER.:: CLLN   (CONERR)        ; CONTINUABLE ERROR EXIT

NCNER.:: CLLN   (NCNERR)        ; NONCONTINUABLE ERROR EXIT

$MSGIN:: TTCALL 13,0            ; RESTORE OUTPUT DISABLED BY ^O
        JFCL
        JRST    @17             ; CALLED BY SIMPL ROUTINES

IOPARM:	MOVEM	17,IOPSV		; SA AC17.
	HLRE	-1(L)			; STOR NUM OF ARGS-3
	ADDI	3			; IN 'ARGN'.
	MOVMM	ARGN
	CLEARM	POSIT			; CLEAR POSITION INCICATOR.
	CLEARM	XEXPR		; CLEAR 'EXPR. DEPTH ' WORD.
	HRRE	(L)			; GET THE UNIT. WE CAN'T DO THE
	LDB	17,[POINT 4,(L),17]	; TRICK OF 'MOVEI 0,@(L)'
	SKIPE	17			; SINCE THE UNIT IS ALLOWED TO
	MOVE	17,B(17)		; BE NEGATIVE. AND YOU KNOW
	ADD	17			; WHAT INDIRECTION CAN DO
	LDB	17,[POINT 1,(L),13]	; WITH NEGATIVE NUMBERS .
	JUMPE	17,.+4			; (THINK ABOUT IT)
	CAIG	17
	ADDI	B
	MOVE	@
	MOVEM	UNIT
	MOVEI	0,@1(L)		; GET END= ADDRESS.
	SKIPE			; SET GLOBAL VARIABLE, IF
	MOVEM	0,EOFLAB	; END ADDRESS EXISTS.
	MOVEI	0,@2(L)		; GET ERR= ADDRESS, IF ANY.
	SKIPE	
	MOVEM	0,ERRLAB	; SET IF NOT ZERO.
	HLRZ	0,-1(L)		; IF THERE ARE 6 ARGUMENTS,
	CAIE	0,-6		; PICK UP THE 6TH ARG AND STORE
	JRST	.+3		; AS A RANDOM I/O POSITION.
	MOVE	0,@5(L)
	MOVEM	0,POSIT
	ADDI	L,3		; ADJUST L.
	JRST	@IOPSV		; RETURN.

PSET:	SKIPN	POSIT		; GO THRU ALL THIS ONLY IF WE NEED
	JRST	(11)		; TO POSITION THE FILE
	MOVEI	17,PSSV		; SAVE 0-16
	BLT	17,PSSV+15
	MOVE	1,UNIT
	MOVE	2,POSIT
	JSP	17,SFSETP  	; DO IT!
	HRLZI	17,PSSV		; RESTORE 0-16
	BLT	17,16
	JRST	(11)		; RETURN.

ONINT.::	SAVEM		;
	MOVEI	1,@(L)		; FIRST ARGUMENT - LABEL ADDR.
	MOVE	2,B+17		; GET AC 17 BEFORE PUSHJ TO US
	SUB	2,[1000001]	; AS 2'ND ARG.
	JSP	17,ONINT
	RSTOREM

OFINT.::	CLLN	OFINT  	;

$RESTA::	HRRZ	2,B+17 ;STORE BRANCH ADDRESS IN
	HRRM	1,(2)		; PC FIELD OF STCK WORD.
	RSTOREM			; WORD IN STACK.
	
GETP.::	CLL	SFP

SETP.::	SAVEM
	MOVEI	0,@(L)		; UNIT.
	MOVE	2,@5(L)		; POSITION -- 2'ND ARG.
	MOVE	1,0		; UNIT IS 1'ST ARG.
	JSP	17,SFSETP
	RSTOREM



SFSZ.::	CLL	SFSZ


STRG.::	JSP	17,STRNG
	RSTOREM

STRGA.::	JSP	17,STRNGA
	RSTOREM

SSTR.::	JSP	17,SSTOR
	RSTOREM

SSTRA.::	JSP	17,SSTORA
	RSTOREM


SEST.::	SAVEM
	JSP	17,SESTRT
	RSTOREM

SBST.::	SAVEM			; DIFFERENT CALLING SEQUENCE.
	JSP	17,ARGS
	CAIE	7,2
	MOVEI	2,0	; SET UP SPECIAL 2'ND ARG FOR SUBSTR.
	JSP	17,SUBSTR
	RSTOREM


SMAX.::	SAVEM
	HLRE	1,-1(16)
	MOVM	1,1
	JSP	17,SMAX
	RSTOREM


SMIN.::	SAVEM
	HLRE	1,-1(16)
	MOVM	1,1
	JSP	17,SMIN
	RSTOREM

LNGTH.::	CLLN	LENGTH

INDX.::	SAVEM
	JSP	17,ARGS
	SKIPN	7
	MOVEI	1,1
	JSP	17,INDEX
	MOVEM	1,B
	RSTOREM

SKSE.::	CLLSK	SKPSE

SKSN.::	CLLSK	SKPSN

SKSL.::	CLLSK	SKPSL

SKSLE.::	CLLSK	SKPSLE

SKSG.::	CLLSK	SKPSG

SKSGE.::	CLLSK	SKPSGE

SCHAR.::	CLL	CHAR

SDATE.::	CLLN	DATE

SASC.::	CLLN	ASC

SRMOV.::	CLLN	SREMOVE

IVAL.::	SAVEM
	JSP	17,SFIVAL
ISET:	MOVE	0,(1)
	MOVEM	0,B
	RSTOREM

VAL.::	SAVEM
	JSP	17,SFVAL
	JRST	ISET

DVAL.::	SAVEM
	JSP	17,SFDVAL
DSET:	MOVE	0,(1)
	MOVE	1,1(1)
	MOVEM	0,B
	MOVEM	1,B+1
	RSTOREM

CVAL.::	SAVEM
	JSP	17,SFCVAL
	JRST	DSET


STR.::	SAVEM
	LDB	1,[POINT 4,(L),12] ; TYPE IS 1'ST ARG.
	HRRZ	2,(16)		; ADDRESS IS SECOND ARG.
	JSP	17,SFSTR		; CALL STR.
	RSTOREM			; ALL DONE.

SLFT.::	CLL	LEFT

SRGHT.::	CLL	RIGHT


ARGS:				; ROUTINE TO GATHER NON-STRING
				; ARGUMENTS AND STORE THEM AWAY.
				; THEN, PICK THEM UP IN AC'S,
				; STARTING FROM 1TO 6.
	MOVEM	R,RSAVE		; SAVE AWAY.
	HLRE	0,-1(L)		; NR OF ARGS.
	MOVMM	0,ARGN		; SAVE AWAY.
	MOVEI	R,0		; COUNT OF NON-STRING ARGS.

	JUMPE	0,ARX		; IF NO ARGS,DONT BOTHER W/ THIS NONSENSE.

AR1:	LDB	0,[POINT 4,(L),12]  ; GET TYPE.
	CAIN	0,TYP.STR	; IF STRING,LOOK AT NXT ONE BUT DONT INC COUNT OF NON-STR ARGS.
	JRST	AR2
	MOVE	0,@(L)		; GET ARG.
	MOVEM	0,ARGMNTS(R)	; STORE AWAY.
	AOS	R		; BUMP COUNT OF NON-STRING ARGS.
AR2:	AOS	L		; FOR NEXT ARGUMENT.
	SOSE	ARGN		; DON'T GO TOO FAR, THOUGH.
	JRST	AR1

	MOVE	1,[ARGMNTS,,1]	; PICK UP THE ARGS NOW.
	BLT	1,6		; SIX OF 'EM.

ARX:	MOVE	7,R		; RETURN NR OF 'EM IN R7.
	MOVE	R,RSAVE		; SO WE CAN ...
	JRST	(17)		; RETURN.

	
SPNT.::	CLLN	SFPRINT


STM.::				;
	JSP	17,STM		; ELSE DO WHAT MUST BE DONE.
	RSTOREM



UUO:	MOVEM	B		; SAVE AWAY AC0.
	LDB	[POINT 13,40,12] ; PICK UP OPCODE AND AC FIELD.
	CAIE	120		; UNLESS IT'S STM UUO W/ NO BRK OR TRACE,
	JRST	UUO2		; CONTINUE PROCESSING.
	HRRZ	40		; GET LINE # & STORE IN GLOBAL.
	MOVEM	$CURLI
	MOVE	B		; OTHERWISE TAKE QUICK TRIP BACK.
	POPJ	17,

UUO2:	MOVEM	17,B+17		; NOT NULL STM UUO,COMPLETE THE
	MOVE	17,[1,,B+1]	; THE REGISTER ZAVE.
	BLT	17,B+16

	LDB	3,[POINT 9,40,8]
	CAILE	3,NUUOS		; OP CODES GO FROM 1-NUUOS.
	HALT			; IF OUTSIDE RANGE.
	CAIN	3,6
	JRST	CHAIN.
	LDB	2,[POINT 4,40,12]  ; PICK UP AC FIELD.
	CAIE	3,STMUUO	; STAY WITH AC FIELD IF STM.
	MOVE	2,B(2)		; PICK UP REGISTER.
UUO1=	.
	HRRZ	1,40		; GET EA.
	CAIE	3,STMUUO	; STAY WITH 'Y' FIELD IF STM.
	MOVE	1,(1)		; GET STRING POINTER WORD.
	
	JRST	UUOTAB-1(3)	; DO CORRECT ONE.
UUOTAB:	JRST	STRG.
	JRST	STRGA.
	JRST	SSTR.
	JRST	SSTRA.
	JRST	STM.


	
OPEN.::	SSAVEM			;
	JSP	17,IOPARM

OPEN1:	LDB	R,[POINT 5,(L),8] ; MOVE ALL ARGS BASED ON TYPE OF
	MOVE	0,(L)		; ARG, TO OPEN PARAMS AREA.
	MOVEM	0,OPNPRM(R)
	AOS	L		; FOR NEXT ONE.
	SOSLE	ARGN
	JRST	OPEN1	

	MOVEI			; CLEAR R0, CUZ WE ARE GOING TO
	MOVE	R,@BFCNT	; SET THE PARAMETERS, AND THE
	MOVEM	R,BUFCNT  	; OMITTED ONES WE WANT TO BE
	MOVE	R,@MODE		; ACTUAL ZEROES.
	MOVEM	R,MODE
	MOVE	R,@RECSIZ
	MOVEM	R,RECSIZ
	MOVEI	R,@ERR
	MOVEM	R,ERRVAR
	MOVE	R,@PROT		; SET
	MOVEM	R,FPROT  	; PROTECTION CODE.

	MOVE	R,@AXS		; BUILD ACCESS MODE WORD.
	SKIPE	MODE		; IF IT'S A BINARY FILE,
	IORI	R,20		; SET BIT 31.
	SKIPE	RECSIZ		; IF RECORD SIZE SPECIFIED,
	IORI	R,10		; SET BIT 32.
	MOVEM	R,AXS		; STASH AWAY FOR LATER YOOSE.

	LDB	0,[POINT 4,FNAME,12]  ; IF FILENAME IS A STRING,
	CAIE	0,TYP.STR	; CALL SEQUENCE IS DIFFERENT FROM
	JRST	CALL2		; FILENAME IN ARRAY.

CALL1:	MOVEI			; CLEAR R0 FOR NEAT TRICK.
	MOVE	0,@FNAME	; GET STRING POINTER  AND
	MOVEM	0,FNAME		; SAVE IT.
	JUMPE	0,CALL1A	; IF POINTER ADDR =0,STRING WAS
				; ALREADY ON STACK, SO JUMP.
	JSP	17,SESTRT	; START NEW STRING EXPRESSION.
	MOVE	1,FNAME		; STACK FILE NAME.
	JSP	17,STRNG
CALL1A:	MOVE	1,UNIT		; SET UP FOR CALL.
	MOVE	2,AXS
	MOVE	3,RECSIZ
	HRRZ	4,REELS		; PICK UP CARRIAGE CTRL FLAG.
	JSP	17,SFOPN
	RSTOREM			; RESTORE AC'S AND RETURN.
	
CALL2:				; SET UP AND CALL SFOPNA.
	SKIPN	FNAME		; IF FNAME IS = 0,THEN THE FILE
	JRST	CALL2C		; NAME IS AN ARRAY NAME RATHER
	CAIE	17		; CHECK FOR HOLLERITH LITERAL.
	JRST	CALL2A
	MOVEI	2,@FNAME	; YES - PICK UP & TREAT AS ARRAY.
	SKIPA
CALL2C:	MOVEI	2,@FNARY	; THAN ARRAY ELEMENT OR SCALAR.
	MOVE	5,2		; THEREFORE, SCAN FOR EOLIT TO
	IOR	5,[POINT 7,0, ]	; GET LENGTH.
	MOVEI	3,0
	ILDB	4,5
	SKIPE	4
	AOJA	3,.-2		; GOT CHARACTER CNT IN 3 WHEN FALLTHRU
	ADDI	3,4		; GET WORD CNT BY ADDING 4,THEN
	IDIVI	3,5		; DIVIDE BY 5.
	JRST	CALL2B		; GOT IT!
CALL2A:	MOVEI	3,1		; STILL HAVE TYPE IN R0. IF
	CAIGE	10		; COMPLEX OR DOUBLE,WORD CNT=2,
	JRST	CALL2B		; ELSE 1.
	CAIG	14
	MOVEI	3,2
	MOVEI	2,@FNAME
CALL2B:	MOVE	1,UNIT		; UNIT.
	MOVE	5,RECSIZ	; RECORD SIZE.
	HRRZ	6,REELS		; CARRIAGE CONTROL FLAG.
	MOVE	4,AXS		; PICK UP ACCES MODE.
	JSP	17,SFOPNA
	RSTOREM


CLSAL.::	CLLN SFCLSALL


	
CLOSE.::	SAVEM	;
	JSP	17,IOPARM
	MOVE	1,UNIT		; GET UNIT.
	JSP	17,SFCLS
	RSTOREM



ENC.::	CLEARM	ECDFLG		; SET CODE FOR ENCODE (0).
	JRST	ECDCOM		; GO TO COMMON CODING.

DEC.::	SETOM	ECDFLG		; SET CODE FOR DECODE (-1)

ECDCOM:	SAVEM			;
	JSP	17,IOPARM	; COLLECT THE BIG THREE.
	CLEARM	Z1		; ZERO ANOTHER FLAG.

	MOVEI	R,@2(L)		; ADDRESS OF CORE BUFFER.
	MOVEM	R,OPNPRM	; SAVE IT AWAY.
	LDB	R,[POINT 4,(L),12]  ; TYPE OF FORMAT.
	CAIE	R,TYP.STR	; IF STRING, STACK IT,
	JRST	ECD1		; ELSE DO THINGS DIFFERENTLY.
	MOVEI			; CLEAR AC0 TO GET 0 IF NO STRING ADDDR.
	MOVE	1,@(L)		; GET STRING POINTER.
	JUMPE	1,ECD2		; ZERO ADDR MEANS CALLER STACKED IT.
	MOVEM	1,FMTSTR	; SAVE IT.
	JSP	17,SESTRT	; START NEW STRING EXPR.
	MOVE	1,FMTSTR	; STRING POINTER.
	JSP	17,STRNG	; ALL RIGHT!
	JRST	ECD2		; GO AROUNG ARRAY FORMAT STUFF.
ECD1:	MOVEI	3,@(L)		; ADDR OF FORMAT ARRAY.
	MOVEI	4,@1(L)		; SIZE OF FORMAT ARRAY.
	AOS	Z1		; SET FLAG.
ECD2:	MOVE	1,OPNPRM	; ADDR OF CORE BUFFER.
	MOVE	2,UNIT		; ACTUALLY, THE NUMBER OF CHARACTERS.
	MOVM	5,ECDFLG	; SET UP TO CALL CORRECT ROUTINE.
	ADD	5,5
	ADD	5,Z1
	JSP	17,@EDCALL(5)
	RSTOREM


RTB.::	SETZM	V2		; SET CODE FOR READ UNFORMATTED.
	JRST	BCOM		; GO TO COMMON CODING.

WTB.::	SETOM	V2		; SET CODE FOR WRITE UNFORMATTED.

BCOM:	SAVEM		;
	JSP	17,IOPARM	; UNIT,END=,ERR=.
	JSP	11,PSET
	MOVE	1,UNIT		; ARG.
	MOVM	4,V2		; GET READ/WRITE CODE.
	JSP	17,@BRW(4)	; CALL THE ROUTINE.
	RSTOREM			; DONE.

	
IN.::	SETZM	V2		; SET CODE FOR 'IN' (0).
	JRST	IOC		; GO TO COMMON CODINE.

OUT.::	SETOM	V2		; SET CODE FOR 'OUT' (-1).

IOC:	SAVEM		;
	JSP	17,IOPARM	; GET UNIT, END/ERR ADDRS.
	MOVEI	1		; IF # OF ARGS IS 4,THIS IS A
	CAME	ARGN		; NAMELIST CALL.
	JRST	IOC1A		; (ELSE CONTINUE)
	MOVE	1,UNIT		; GET UNIT & ADDR OF ITEM LIST
	MOVEI	2,@(L)		; AND CALL NMLIN OR NMLOUT,
	MOVM	17,V2		; DEPENDING.
	JSP	17,@NML(17)
	JRST	DONE		; DONE.
NML:	EXP	NMLIN,NMLOUT

IOC1A:	;
	CLEARM	Z1		; USE AS A FLAG.
	LDB	R,[POINT 4,(L),12] ; TYPE OF FORMAT.
	CAIE	R,TYP.STR	; IF STRING,STACK IT.
	JRST	IOC1
	MOVEI			; CLEAR TO GET 0 IF NO STR ADDR.
	MOVE	1,@(L)		; GET STRING POINTER .
	JUMPE	1,IOC2		; ALREADY STACKED IF ADDR=0.
	MOVEM	1,FMTSTR	; AND SAVE AWAY.
	JSP	17,SESTRT	; START NEW EXPR.
	MOVE	1,FMTSTR	; GET POINTER.
	JSP	17,STRNG	; STACK THE STRING.
	JRST	IOC2		; SKIP AROUND OTHER CODE.
IOC1:	MOVEI	2,@(L)		; ADDR OF FORMAT ARRAY.
	MOVEI	3,@1(L)		; SIZE OF FORMAT ARRAY.
	AOS	Z1		; SET FLAG.
IOC2:			;
	MOVE	1,UNIT		; FIRST ARG.
	MOVE	4,Z1		; FLAG.
	MOVM	5,V2		; 0 OR 1,DEPENDING.
	ADD	5,5		; DOUBLE IT.
	ADD	4,5		; + STRING/FORMAT CODE.
	JSP	17,@RWCALL(4)	; CALL THE APPROPRIATE ROUTINE.
	JSP	11,PSET		; TAKE CARE OF POSITIONING.
	RSTOREM

	
FIN.::	SSAVEM			; I/O REQUEST TERMINATION.
OTSFIN:	JSP	17,SFEOL
	SKIPLE	1,XEXPR		; SEE IF SHOULD DELETE STRNG XPR'S.
	JSP	17,SREMOV	; YES -- DO IT.
	RSTOREM
	
	
IOLST.::	SAVEM		;
	MOVEM	L,LSAVE		; SAVE THE ARG BLK POINTER.
CKAGIN:	HRLZI	17,B		; GET USER'S REGISTERS.
	BLT	17,17
	MOVE	L,LSAVE		; EXCEPT L -- GET PREVIOUS.
	LDB	0,[POINT 4,(L),12]  ; TYPE
	LDB	R,[POINT 5,(L),8]   ; CLASS
	JRST	.+1(R)		; SELECT APPROPRIATE THING.
	JRST	OTSZERO		; NOT IN.
	JRST	OTSDATA		; SINGLE DATA ITEM.
	JRST	OTSSLIST	; MULTIPLE.
	JRST	OTSELIST	; NOT IN.
	JRST	OTSFIN		; END OF I/O LIST.
	JRST	OTSKLG		; OUTPUT A STRING CONSTANT AS IN THE ACCEPT STMT.
	JRST	OTSSXP		; STRNG EXPR'S STACKED.
	
OTSDATA:			; DATA ITEM.
	MOVEM	0,S0		; SAVE AWAY THE TYPE.
	MOVEI	1,@(L)		; ADDR OF DATA ITEM.
	CAIE	0,TYP.STR	; IF STRING, STACK IT B4 IOCALL.
	JRST	OTSD2
	MOVEM	1,S1		; ALSO SAVE R1.
	JSP	17,SESTRT	; CREATE NEW EXPR.
	MOVE	1,@S1		; GET STRING POINTER.
	JSP	17,STRNG	; STACK IT.
OTSD2:	MOVE	R,S0		; GET TYPE.
	JSP	17,@DTAT(R)	; CALL SOMEBODY.
	AOS	L,LSAVE
	JRST	CKAGIN		; INC FOR NXT ELEMENT, CHECK AGAIN.
	
OTSSLIST:			; 
	LDB	0,[POINT 4,2(L),12]  ; FOR ARRAY,TYPE IS IN DIFFERENT WORD.
	MOVEI	R,@2(L)		; ADDRESS OF ARRAY.
	MOVEI	2,@(L)		; COUNT.
	CAIN	0,TYP.STR	; IF OF TYPE STRING, GET POINTER.
	MOVE	R,(R)
	MOVE	1,R		; GET AS FIRST ARGUMENT.
	MOVE	R,0		; TYPE IN R FOR INDEXING.
	CAIE	0,TYP.STR	; IF STRING ARRAY,COUNT IS IN
	JRST	OTSSL1		; WORDS INSTEAD OF ELEMENTS, SO
	HLRZ	3,1		; CHARS/STRING
	ADDI	3,4		; +4
	IDIVI	3,5		; /5 GIVES WDS/STRING.
	IDIV	2,3		; GIVES ELEMENTS IN ARRAY
OTSSL1:	JSP	17,@DTATA(R)	; SELECT SOMEONE.
	MOVEI	0,3		; INCREMENT LSAVE BY 3 FOR
	ADDM	0,LSAVE		; THE NEXT ENTRY.
	JRST	CKAGIN
	
OTSZERO:	RSTOREM
OTSELIST:	HALT

OTSKLG:	MOVE	1,@(L)		; GET STRING POINTER FOR SFPRINT.
	JSP	17,SFPRINT	; OUTPUT THE STRING.
	AOS	L,LSAVE		; RESTORE & ADJUST
	JRST	CKAGIN		; DONE.


OTSSXP:	MOVEM	L,LSAVE		; SAVE R16.
	HRRZ	1,(L)		; GET STRING EXPRESSION #.
	CAMLE	1,XEXPR		; SET GREATEST DEPTH.
	MOVEM	1,XEXPR
	JSP	17,XLINK  	; PUT N'TH STRNG EXPR ON TOP.
	JSP	17,STREL	; GO,GO,GO.
	AOS	L,LSAVE		; BUMP R16.
	JRST	CKAGIN		; FOR MORE.

HPRINT:	; SCAN A HOLLERITH LITERAL UNTIL EOLIT FOUND, 
	; PUT CHARACTER COUNT IN LEFT HALF OF AC1, GO TO SFPRINT.
	MOVE	2,1		; TO BUILD BYTE POINTER.
	IOR	2,[POINT 7,0, ]
	ILDB	2		; COLLECT BYTE.
	JUMPE	SFPRINT  	; EOLIT -- GO TO SFPRINT.
	ADD	1,[1,,0]	; NOT EOLIT -- BUMP LH OF AC1.
	JRST	.-3		; FOR ANOTHER.


BOOL.::	SAVEM

	SETZM	OCTVAL		; ZAP OUT STRING AREA.
	SETZM	OCTVAL+1
	SETZM	OCTVAL+2
	MOVEI	1,OCTVAL	; TO CONSTRUCT STRING POINTER.
	MOVEI	2,^D12		; NR. OF ITERATIONS-1.
	MOVE	3,[POINT 3,@(16), ] ; GET 1 OCT DIGIT AT A TIME
	MOVE	4,[POINT 7,OCTVAL,] ; PUT 1 CHARACTER AT A TIME
	MOVE	5,[JUMPE BL1]	; FOR LEADING 0 DIGIT TEST.
	MOVEI	" "		; FIRST CHARACTER IS BLANK --
	JRST	BL5		; ENTER LOOP & GO FROM THERE.

BL2:	ILDB	3		; PICK UP INTERNAL DIGIT.
	XCT	5		; IGNORE LEADING 0 BYTES,
	MOVE	5,[SKIPA 0]	; ON 1'ST NONZERO ONE SET TO GET ALL THE REST.
BL3:	ADDI	60		; ZONE THE DIGIT.
BL5:	IDPB	4		; PLACE IT IN STRING.
	ADD	1,[1,,0]	; BUMP STRING CAPACITY.
BL1:	SOJG	2,BL2		; REPEAT EXCEPT FOR LAST DIGIT.
	MOVE	5,[SKIPA 0]	; ENSURE GETTING LAST DIGIT IN CASE ALL 0.
	JUMPE	2,BL2		; ALWAYS GET AT LEAST ONE,FALL THRU
				; AFTERWARDS.
	JSP	17,STRNG	; STACK THE STRING.
DONE:	RSTOREM			; DONE.

TIME.::	TIMER	0,	; GET JIFFIES IN AC0.
	POPJ	17,	; RETURN


	
RWCALL:	EXP	SFRF,SFRFA,SFWF,SFWFA
BRW:	EXP	SFR,SFW		; UNFORMATTED READ,WRITE.
EDCALL:	EXP	SFENF,SFENFA,SFDEF,SFDEFA
DTAT:	EXP	INTEL,LGCEL,H,H,RLEL,H,H,H,DBEL,H,H,H,CMPEL,STREL,H,HPRINT
DTATA:	EXP	INTELA,LGCELA,H,H,RLELA,H,H,H,DBELA,H,H,H,CMPELA,STRELA
H:	HALT

	
XEXPR:	0			; DEPTH TO DELETE STRNG EXPR'S.
POSIT:	Z
IOPSV:	Z
FMTSTR:	Z
S0:	Z
S1:	Z
V2:	Z
Z1:     Z               ; SKIP FLAG FOR STRING RELATIONALS.
STAK:	BLOCK	STKSZ
B:      BLOCK   20              ; REGISTER SAVE AREA.
$SAVEA=:	B
PSSV:	BLOCK	17		; SAVE AREA FOR PSET.
LSAVE:	Z
RSAVE:	Z
UNIT:	Z
ARGN:	Z
START:	Z
$CURLI:: Z
OPNPRM:	Z		; DEFNS FROM HERE THRU 'FNARY' MUST STAY IN ORDER.
DIALOG:	Z
AXS:	Z
DVC:	Z
BFCNT:	Z
BKSIZ:	Z
FNAME:	Z
PROT:	Z
DIREC:	Z
LIMIT:	Z
MODE:	Z
FSIZE:	Z
RECSIZ:	Z
DISPOS:	Z
VER:	Z
REELS:	Z
MNT:	Z
ERR:	Z
ASSOC:	Z
FNARY:	Z		; FILE NAME IS ARRAY.

WDSTCLR=	FNARY-OPNPRM
ARGMNTS=	OPNPRM		; ************************
OCTVAL:	BLOCK	3		; FOR 'BOOL' FCN.
ECDFLG=	V2			; *************************

	END
    