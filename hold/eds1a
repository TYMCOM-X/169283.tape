 INTEGER OBJ,HISTRY(100),SPCALC,FLUSH,BRIEF,FRSTSG,EDITL,CURRGO,
  EXIST,CMND,CURCMP,ERRCNT,COMPL,ACTVL,PRNTL,FSTITM,CLRITM,HASH,
   SONPTR,SONS,TREE,BUFITM,ITMLOC,ITMDIM,TYPE,OVLNO,FMTPTR
 COMMON FV(3000)
 COMMON ITEM,OBJ,SBSNAM,LSBNAM,HISTRY,
  SPCALC,NOPRNT,FLUSH,ITMCHK,BRIEF,
  INPUT(21),LINPUT,FRSTSG,LASTSG,NXSTRT,
  EDITL(100),LEDITL,OVL,INDOVL,INDIR,
COMMON  CURRGO,LASTGO,CMND,CURCMP,ERRCNT,
  COMPL(100),LCOMPL,ACTVL(100),LACTVL,PRNTL(100),LPRNTL,
  NITEMS,MULTRE,EXIST(3),FSTITM,LSTITM,CLRITM,
COMMON  HASH(199),SONPTR(25),SONS(65),TREE(100),
  DICFIL,FMTFIL,ATRFIL,
  BUFITM,ITMLOC,ITMMOD,ITMDIM,ITMTYP,ITMIO,ITMOVL,
  ITMFMT,ITMMIN,ITMMAX,ITMNAM(7),LITNAM
 REAL ITMMIN,ITMMAX
 STRING INPUT(4),ITMNAM(4)
 STRING SBSNAM(8),OVL(8),INDOVL(8),DICFIL(8),FMTFIL(8),ATRFIL(8)
* 
*FROM RUNCOMDS
 INTEGER ALL,EXITEM,CLEAR,CEXEC,CURITM,CSONNO,CURSON
 STRING DICTF(4),FMTF(4),ATRF(4),MSGF(4)
 STRING DBLANK(8),MSGFIL(8),DSPHSH(8),DSDATA(8)
 DATA MXLSBN,ALL,CLEAR,CURSON,CEXEC/6,0,7,0,102/
 DATA DICTF,FMTF,ATRF,MSGF/DF,FF,AF,MF/
 DATA DBLANK,DSPHSH,DSDATA/ ,DSPHSH,DSDATA/
 DATA N0,N1,N2,N1000,N10T6/0,1,2,1000,1000000/
 DATA M10/-10/
 EXITEM=N0
 IF(CMND.NE.N0)GOTO 10
* 
*  USER JUST STARTED -- THIS IS THE FIRST OVERLAY CALLED
* 
*  NULL OUT INPUT STRING TO FORCE SCOPE FAILURE IN DATADS
* 
 LINPUT=N0
 NXSTRT=N0
* 
*  IS THERE A MODULE NAME IN COMMON
* 
 IF(LSBNAM.NE.N0)GOTO 20
* 
*  NO MODULE NAME IN COMMON -- ZERO OUT PARAMETERS NORMALLY READ
*  FROM MODULE'S BINARY DICTIONARY FILE AND READ IN PROTOTYPE
*  HASH TABLE CONTAINING ENTRIES FOR SYSTEM COMMANDS ONLY
* 
 NITEMS=100
 FSTITM=N0
 LSTITM=N0
 CLRITM=N0
 MULTRE=N0
 DICFIL=DSPHSH
 OPEN(3,DICFIL,INPUT,BINARY)
 READ(3)HASH
 GOTO 40
* 
*  CHECK FOR CLEAR COMMAND
* 
 10   IF(CMND.EQ.CLEAR)GOTO 100
* 
*  INITIAL MODULE NAME GIVEN OR SWITCHING MODULES
* 
*  CONSTRUCT NAMES OF BINARY DICTIONARY FILE (DICFIL),
*  ATTRIBUTE FILE (ATRFIL), AND FORMAT FILE (FMTFIL) FROM
*  MODULE NAME AND SUFFIXES
* 
 20   LSBNAM=MIN0(LSBNAM,MXLSBN)
 L=LSBNAM+N1
 DICFIL=DBLANK
 CALL MOVE(SBSNAM,N1,DICFIL,N1,LSBNAM)
 CALL MOVE(DICTF,N1,DICFIL,L,N2)
 ATRFIL=DBLANK
 CALL MOVE(SBSNAM,N1,ATRFIL,N1,LSBNAM)
 CALL MOVE(ATRF,N1,ATRFIL,L,N2)
 FMTFIL=DBLANK
 CALL MOVE(SBSNAM,N1,FMTFIL,N1,LSBNAM)
 CALL MOVE(FMTF,N1,FMTFIL,L,N2)
* 
*  CONSTRUCT NAME OF BANNER MESSAGE FILE AND CALL ROUTINE TO
*  DUMP IT IF IT EXISTS
* 
 MSGFIL=DBLANK
 CALL MOVE(SBSNAM,N1,MSGFIL,N1,LSBNAM)
 CALL MOVE(MSGF,N1,MSGFIL,L,N2)
 CALL FDUMP(MSGFIL,$30)
* 
*  READ IN ALL ASSUMED VALUES
* 
 30   CALL ASMVAL(ALL)
* 
*  READ MODULE'S PARAMETERS FROM BINARY DICTIONARY FILE
* 
 OPEN(3,DICFIL,INPUT,BINARY)
 READ(3)NITEMS,MULTRE,FSTITM,LSTITM,CLRITM,HASH,
  SONPTR,SONS,TREE,EXIST
* 
*  SET ITEM TO BE EXECUTED TO FIRST ITEM
* 
 EXITEM=FSTITM
* 
*  INITIALIZE COMMON
* 
 40   ITEM=N0
 OBJ=N0
 DO 50 I=N1,NITEMS
 50   HISTRY(I)=N0
 SPCALC=N0
 NOPRNT=N0
 FLUSH=N0
 ITMCHK=N0
 BRIEF=N0
 LEDITL=N0
 CURRGO=N0
 LASTGO=N0
 CURCMP=N0
 LCOMPL=N0
 LACTVL=N0
 LPRNTL=N0
 ERRCNT=N0
 BUFITM=N0
* 
*  SEE IF AN ITEM'S RELATION CODE SHOULD BE EXECUTED
* 
 IF(EXITEM.EQ.N0)GOTO 70
* 
*  BUILD A COMPUTATION LIST OF ONE ITEM TO EXECUTE THE ITEM AS
*  A COMMAND WITH PRINTING SUPPRESSED
* 
 CALL FILE(EXITEM)
 LCOMPL=N1
 COMPL(LCOMPL)=N10T6+N1000*ITMOVL+EXITEM
 CMND=CEXEC
 60   CLOSE(4)
 70   IF(INDIR.EQ.N0)OVL=DSDATA
 INDIR=-INDIR
 CLOSE(3)
 RETURN
* 
* 
* 
*  CLEAR COMMAND
* 
*  SEE IF AN OBJECT WAS GIVEN
* 
 100  IF(OBJ.NE.N0)GOTO 110
* 
*  NO OBJECT -- CLEAR ALL ITEMS
* 
*  READ IN ALL ASSUMED VALUES, SET ITEM TO BE EXECUTED TO
*  THE CLEAR ITEM, AND GOTO RE-INITIALIZE COMMON
* 
 CALL ASMVAL(ALL)
 EXITEM=CLRITM
 GOTO 40
* 
*  OBJECT GIVEN
* 
*  READ IN ASSUMED VALUE OF OBJECT (IF ANY)
* 
 110  CALL ASMVAL(OBJ)
* 
*  IF OBJ IS CURRENTLY IN ERROR , BUMP ERROR COUNT DOWN
* 
 IF(IABS(HISTRY(OBJ)).GE.N1000)ERRCNT=ERRCNT-N1
* 
*  IS THERE AN ACTIVE LIST
* 
 IF(LACTVL.GT.N0)GOTO 120
* 
*  NO ACTIVE LIST
* 
*  JUST SET HISTORY OF OBJ TO ZERO AND GET OUT
* 
 HISTRY(OBJ)=N0
 GOTO 60
* 
*  THERE IS AN ACTIVE LIST
* 
*  REVOVE FROM ACTIVE LIST OBJ (IF ON ) AND ALL OTHER ITEMS
*  WHOSE VALUES DEPEND ON OBJ DIRECTLY OR INDIRECTLY
* 
 120  HISTRY(OBJ)=M10
 DO 150 I=N1,LACTVL
 CURITM=ACTVL(I)
 IF(CURITM.EQ.OBJ)GOTO 140
 CSONNO=N0
 130  CSONNO=CSONNO+N1
 CALL GETSON(CURITM,CSONNO,CURSON,N0,$150,$150)
 IF(HISTRY(CURSON).NE.M10)GOTO 130
 IF(IABS(HISTRY(CURITM)).GE.N1000)ERRCNT=ERRCNT-N1
 HISTRY(CURITM)=M10
 140  ACTVL(I)=N0
 150  CONTINUE
 DO 160 CURITM=N1,NITEMS
 IF(HISTRY(CURITM).EQ.M10)HISTRY(CURITM)=N0
 160  CONTINUE
 J=N0
 DO 180 I=N1,LACTVL
 IF(ACTVL(I))170,180,170
 170  J=J+N1
 ACTVL(J)=ACTVL(I)
 180  CONTINUE
 LACTVL=J
 GOTO 60
 END
 SUBROUTINE FILE(ITEMNO)
 INTEGER OBJ,HISTRY(100),SPCALC,FLUSH,BRIEF,FRSTSG,EDITL,CURRGO,
  EXIST,CMND,CURCMP,ERRCNT,COMPL,ACTVL,PRNTL,FSTITM,CLRITM,HASH,
   SONPTR,SONS,TREE,BUFITM,ITMLOC,ITMDIM,TYPE,OVLNO,FMTPTR
 
 COMMON ITEM,OBJ,SBSNAM,LSBNAM,HISTRY,
  SPCALC,NOPRNT,FLUSH,ITMCHK,BRIEF,
  INPUT(21),LINPUT,FRSTSG,LASTSG,NXSTRT,
  EDITL(100),LEDITL,OVL,INDOVL,INDIR,
COMMON  CURRGO,LASTGO,CMND,CURCMP,ERRCNT,
  COMPL(100),LCOMPL,ACTVL(100),LACTVL,PRNTL(100),LPRNTL,
  NITEMS,MULTRE,EXIST(3),FSTITM,LSTITM,CLRITM,
COMMON  HASH(199),SONPTR(25),SONS(65),TREE(100),
  DICFIL,FMTFIL,ATRFIL,
  BUFITM,ITMLOC,ITMMOD,ITMDIM,ITMTYP,ITMIO,ITMOVL,
COMMON  ITMFMT,ITMMIN,ITMMAX,ITMNAM(7),LITNAM
 REAL ITMMIN,ITMMAX
 STRING INPUT(4),ITMNAM(4)
 STRING SBSNAM(8),OVL(8),INDOVL(8),DICFIL(8),FMTFIL(8),ATRFIL(8)
* 
*FROM RUNCOMDS
* 
*  SUBROUTINE TO READ THE ATTRIBUTES OF AN ITEM FROM THE
*  MODULE'S ATTRIBUTE FILE INTO COMMON, WHERE ITEMNO IS THE
*  NUMBER OF THE ITEM WHOSE ATTRIBUTES ARE TO BE READ
* 
 STRING COLON(4)
 DATA COLON/:/
 DATA N0,N1,N28/0,1,28/
* 
*  IF ITEM'S ATTRIBUTES ARE ALREADY IN CORE, RETURN
* 
 IF(ITEMNO.EQ.BUFITM)GOTO 1
 BUFITM=ITEMNO
* 
*  READ THE ITEM'S ATTRIBUTES USING THE ITEM'S NUMBER AS
*  A RECORD INDEX
* 
 OPEN(4,ATRFIL,RANDIO,BINARY)
 READ(4)(BUFITM)ITMLOC,ITMMOD,ITMDIM,ITMTYP,ITMIO,
 ITMOVL,ITMFMT,ITMMIN,ITMMAX,ITMNAM
* 
*  COMPUTE LENGTH OF ITEM'S FIRST NAME (NAMES ARE IN ITMNAM
*  ENDED BY COLONS)
* 
 M=N1
 CALL SCOPE(ITMNAM,M-N28,K,LITNAM,N0,N0,N0,N0,COLON,N1,$2)
 1    RETURN
* 
*  ITEM HAS NO NAME
* 
 2    LITNAM=N0
 GOTO 1
 END
 SUBROUTINE ASMVAL(ITEMNO)
 INTEGER OBJ,HISTRY(100),SPCALC,FLUSH,BRIEF,FRSTSG,EDITL,CURRGO,
  EXIST,CMND,CURCMP,ERRCNT,COMPL,ACTVL,PRNTL,FSTITM,CLRITM,HASH,
   SONPTR,SONS,TREE,BUFITM,ITMLOC,ITMDIM,TYPE,OVLNO,FMTPTR
 COMMON FV(3000)
 COMMON ITEM,OBJ,SBSNAM,LSBNAM,HISTRY,
  SPCALC,NOPRNT,FLUSH,ITMCHK,BRIEF,
  INPUT(21),LINPUT,FRSTSG,LASTSG,NXSTRT,
  EDITL(100),LEDITL,OVL,INDOVL,INDIR,
COMMON  CURRGO,LASTGO,CMND,CURCMP,ERRCNT,
  COMPL(100),LCOMPL,ACTVL(100),LACTVL,PRNTL(100),LPRNTL,
  NITEMS,MULTRE,EXIST(3),FSTITM,LSTITM,CLRITM,
COMMON  HASH(199),SONPTR(25),SONS(65),TREE(100),
  DICFIL,FMTFIL,ATRFIL,
  BUFITM,ITMLOC,ITMMOD,ITMDIM,ITMTYP,ITMIO,ITMOVL,
  ITMFMT,ITMMIN,ITMMAX,ITMNAM(7),LITNAM
 REAL ITMMIN,ITMMAX
 STRING INPUT(4),ITMNAM(4)
 STRING SBSNAM(8),OVL(8),INDOVL(8),DICFIL(8),FMTFIL(8),ATRFIL(8)
* 
*FROM RUNCOMDS
* 
*  SUBROUTINE TO READ ASSUMED VALUES FOR AN ITEM INTO ITS 
*  ALLOCATED STORAGE IN FV, WHERE ITEMNO IS THE NUMBER OF THE
*  ITEM WHOSE ASSUMED VALUES (IF ANY) ARE TO BE READ
* 
*  IF ITEMNO=0 ASSUMED VALUES FOR ALL ASSUMABLE ITEMS ARE READ
* 
 INTEGER ALL,ASSUME
 DATA ALL,ASSUME/0,2/
 DATA N0,N10000/0,10000/
 IF(ITEMNO.NE.N0)GOTO 10
 LOCN=N10000
 GOTO 20
 10   CALL FILE(ITEMNO)
 IF(ITMTYP.NE.ASSUME)GOTO 100
 LOCN=ITMLOC
 20   READ(3)I1,I2
 30   IF(I1.EQ.N0.OR.I1.GT.LOCN)GOTO 100
 IF(ITEMNO.NE.N0)IF(I1-LOCN)50,40,50
 40   READ(3)(FV(I),I=I1,I2),I1,I2
 GOTO 30
 50   READ(3)(TEMP,I=I1,I2),I1,I2
 GOTO 30
 100  RETURN
 END
 SUBROUTINE FDUMP(FILE,*)
* 
*  SUBROUTINE TO PRINT A BCD FILE WITH OR WITHOUT LINE
*  NUMBERS, WHERE FILE IS THE NAME OF THE FILE TO BE DUMPED
* 
*  NON-STANDARD RETURNS
*    1 -- FILE DOES NOT EXIST OR IS NOT BCD
* 
 INTEGER INFO(4),FSTCHR
 STRING TEXT(80),BUFF(2048),BLANK(4),CZERO(4)
 STRING FILE(8)
 LOGICAL EQ
 DATA BLANK,CZERO/ ,0/
 DATA N0,N1,N3,N7,N72,N510,N512/0,1,3,7,72,510,512/
* 
*  CHECK FOR EXISTANCE OF FILE
* 
 CALL FILE#CHK(FILE,INFO,N1,$99)
* 
*  IS FILE BCD?
* 
 IF(INFO(N1).NE.N0)GOTO 99
* 
*  FILE EXISTS AND IS BCD -- INITIALIZE FOR DUMP
* 
 FSTCHR=N0
 NWDS=N512
* 
*  READ 1ST RECORD OF FILE AND DECIDE WHETHER OR NOT FILE HAS
*  LINE NUMBERS
* 
 10   CALL #READ#(FILE,TEXT,LTEXT,$50)
 IF(FSTCHR.NE.N0)GOTO 20
* 
*  FIRST TIME THROUGH -- CHECK IF FILE HAS LINE NUMBERS AND
*  SET FSTCHR APPROPRIATELY
* 
 FSTCHR=N1
 IF(EQ(TEXT,N1,CZERO,N1,N1))FSTCHR=N7
* 
*  IF NO LINE NUMBERS GET OUT AND READ A LINK AT A TIME
* 
 IF(FSTCHR.EQ.N1)GOTO 30
* 
*  PRINT CURRENT LINE OF FILE WITH LINE NUMBERS AND GO BACK FOR
*  NEXT LINE
* 
 20   CALL STRPRINT(BLANK,TEXT,FSTCHR,LTEXT,N72)
 GOTO 10
* 
*  FILE HAS NO LINE NUMBERS -- READ IT UNBUFFERED A LINK AT A
*  TIME -- INFO(3) HAS NUMBER OF LINKS
* 
 30   CLOSE(6)
 NLINKS=INFO(N3)
 DO 40 LINK=N1,NLINKS
* 
*  GET NEXT LINK
* 
 CALL #UREAD#(FILE,LINK,BUFF,NWDS)
 NWDSP=NWDS
* 
*  IF WE READ A FULL LINK (IE. NWDS STILL = 512) SET NUMBER OF
*  WORDS TO PRINT TO 510 SINCE G.E. USES LAST TWO WORDS OF LINK
*  TO POINT TO NEXT LINK
* 
 IF(NWDSP.EQ.N512)NWDSP=N510
* 
*  PRINT OUT THIS LINK OF FILE (WE CAN GET AWAY WITH THIS SINCE
*  END OF RECORD MARK FOR BCD FILES IS A WORD CONTAINING 
*  CR LF RO RO)
* 
 PRINT 34,(BUFF(J),J=N1,NWDSP)
 34   FORMAT('0',S)
 40   CONTINUE
 50   CLOSE(6)
 RETURN
 99   RETURN N1
 END
 SUBROUTINE GETSON(ITEMNO,SONNO,SON,IGNORE,*,*)
 INTEGER OBJ,HISTRY(100),SPCALC,FLUSH,BRIEF,FRSTSG,EDITL,CURRGO,
  EXIST,CMND,CURCMP,ERRCNT,COMPL,ACTVL,PRNTL,FSTITM,CLRITM,HASH,
   SONPTR,SONS,TREE,BUFITM,ITMLOC,ITMDIM,TYPE,OVLNO,FMTPTR
 COMMON FV(3000)
 COMMON ITEM,OBJ,SBSNAM,LSBNAM,HISTRY,
  SPCALC,NOPRNT,FLUSH,ITMCHK,BRIEF,
  INPUT(21),LINPUT,FRSTSG,LASTSG,NXSTRT,
  EDITL(100),LEDITL,OVL,INDOVL,INDIR,
COMMON  CURRGO,LASTGO,CMND,CURCMP,ERRCNT,
  COMPL(100),LCOMPL,ACTVL(100),LACTVL,PRNTL(100),LPRNTL,
  NITEMS,MULTRE,EXIST(3),FSTITM,LSTITM,CLRITM,
COMMON  HASH(199),SONPTR(25),SONS(65),TREE(100),
  DICFIL,FMTFIL,ATRFIL,
  BUFITM,ITMLOC,ITMMOD,ITMDIM,ITMTYP,ITMIO,ITMOVL,
  ITMFMT,ITMMIN,ITMMAX,ITMNAM(7),LITNAM
 REAL ITMMIN,ITMMAX
 STRING INPUT(4),ITMNAM(4)
 STRING SBSNAM(8),OVL(8),INDOVL(8),DICFIL(8),FMTFIL(8),ATRFIL(8)
* 
*FROM RUNCOMDS
* 
*  GETS ONE OF AN ITEM'S SONS, WHERE -
*ITMNO = ITEM NO. OF ITEM WHOSE SON IS TO BE RETURNED
*SONNO = NUMBER OF SON TO BE RETURNEE
*  SON = ITEM NO. OF RETURNED SON
*    IGNORE = ITEM NO. OF SON TO BE IGNORED BY THIS CALL
* 
*  NON-STANDARD RETURNS --
*    1 -- ITEM DOES NOT HAVE SONNO SONS
*    2 -- ITEM HAS NO SONS AT ALL
* 
 INTEGER SONNO,SON,FSPTR,SPTR
 DATA FSPTR,LSPTR/0,0/
 DATA N1,N2,N4/1,2,4/
* 
*  GET POINTERS TO FIRST AND LAST SONS OF ITEM
* 
 CALL MOVE(SONPTR,ITEMNO,FSPTR,N4,N1)
 CALL MOVE(SONPTR,ITEMNO+N1,LSPTR,N4,N1)
 LSPTR=LSPTR-N1
* 
*  IF NO SONS RETURN 2
* 
 IF(FSPTR.GT.LSPTR)RETURN N2
* 
*  GET POINTER TO SONNO-TH SON OF ITEM
* 
 10   SPTR=FSPTR+SONNO-N1
* 
*  IF NO SONNO--TH SON RETURN 1
* 
 IF(SPTR.GT.LSPTR)RETURN N1
* 
*  GET SONNO-TH SON OF ITEM
* 
 CALL MOVE(SONS,SPTR,SON,N4,N1)
* 
*  SEE IF WE SHOULD IGNORE IT -- IF SO, BUMP SONNO AND START OVER
* 
 IF(SON.NE.IGNORE)RETURN
 SONNO=SONNO+N1
 GOTO 10
 END
   