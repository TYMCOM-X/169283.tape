BASE 0
GLOBAL %TENUPDATE

%TENUPDATE


FIND %BYPT, %CHOOSE, %LISTABLE, %DATOUT
FIND %INITTTY, %GETNUM, %GETTOKEN, %NUMOUT, %OCTOUT, %GETOCT, %QUERY
FIND %IMGIO, %HASH, %MAKE.SIXBIT, %CHR.OUT
FIND TOKEN(0)

GLOBAL CHK.ERR:, IO.ADR, IOTAB(WPF)

GLOBAL INDEX, THIS.SYS, THIS.LIC, CMD,CHG
GLOBAL OP, CHR	!VARIABLES FOR IMAGE I/O
GLOBAL D.BLK(128), D.INDEX, D.LOC, CH.DUL,  DUL.NAME, D.OV.BLK.N
GLOBAL SIZE.DUL, PASSW(2), ANS, H.SYS, DATE, DAY, TTFNAME, TTEXT
GLOBAL L.BLK(128), L.INDEX, LOC.HASH, CH.LUD, LUD.NAME, L.OV.BLK.N
GLOBAL L.SAVE(128), SIZE.LUD
GLOBAL SITE.31.NAME, SITE, CODE
GLOBAL CH.OUT, P, NUMBER, P1, TMP, USER(3), FOUND
GLOBAL STRINF(3), NAME.HASH, OLD.NAME(2), PRIV, DIST, RUB
GLOBAL GAN, UUN, M.BLK(256), M.INDEX, P.M.INDEX
GLOBAL L.OLD.INDEX, LOC.OLD.HASH, O.ENT.SIZE, OLD.HASH
GLOBAL UFD, BAD.CHR:, FROMTTY:

GLOBAL %ERROR, %INITUPD, %LOKUP.LUD, %LUD.SEQ, %LOKUP.DUL
GLOBAL %LUD.LOOK, %DUL.LOOK, %DEL.FILES, %CALL.GETTAB
GLOBAL %FIND.STR, %FIND.L.ROOM, %MAKE.L.OVER
GLOBAL %MAKE.D.OVER, %CHK.IO.ERR, %GET.STR.INF, %SEND.O.WD
GLOBAL %GET.P.BITS, %O.LUDUPD, %MUDUP, %GET.M.CIR, %GET.A.CIR
GLOBAL  %GET.MODE, %SEND.ACT
GLOBAL %CHECK.OK, %LIST.INF, %CHANGE.ENT, %GET.PASSW, %BILL.USER




!INTERNAL MUD,LUD,DUL COMMANDS
DEF DEL.USR AS 1
DEF ADD.USR AS 2
DEF CH.NAME AS 3
DEF CH.PRIV AS 4
DEF CH.STR AS 5
DEF CH.DIST AS 6
DEF CH.RUB AS 7
DEF CH.HOME AS 8
DEF REVERSE AS 9
DEF CH.PASSW AS 10
DEF GET.M AS 11
DEF OTHER.L.D AS 12

!USER COMMANDS
DEF HELP AS 1
DEF GET AS 2
DEF VALIDATE AS 3
DEF ADD AS 4
DEF CHANGE AS 5
DEF INVALIDATE AS 6
DEF REMOVE AS 7
DEF CHECK AS 8
DEF LIST AS 9
DEF QUIT AS 11

ANGE COMMANDS
DEF CH.HOME AS 1
DEF CH.PASSWORD AS 2
!LIST COMMANDS
DEF L.PROJECT AS 1
DEF L.USER AS 2

!SIZE OF TABLES
DEF N.I.CMDS AS 10
DEF N.U.CMDS AS 16
DEF N.MODES AS 4
DEF N.LISTS AS 2
DEF N.CHANGES AS 9


GLOBAL TABLE INT.CMDS(1:N.I.CMDS)['HELP','GET','NEW','ADD','CHANGE',&
	'CANCEL','REMOVE','CHECK','LIST','QUIT']

GLOBAL TABLE U.CMDS(1:N.U.CMDS)['HELP','NEW USER',&
	'ADD PDP10','CHANGE NAME','CHANGE HOME','CHANGE PASSWORD',&
        'CHANGE PRIVILEGES','CANCEL USER','REMOVE PDP10',&
	'CHANGE STRUCTURE','CHANGE DISTRICT','CHECK NAME',&
	'GET MUD','LIST PROJECT','LIST USER','QUIT']


GLOBAL TABLE CH.CMDS(1:N.CHANGES)['NAME','HOME','PASSWORD',&
	'PRIVILEGES','STRUCTURE','DISTRICT']

GLOBAL TABLE L.CMDS(1:N.LISTS)['PRIJECT','USER']

GLOBAL TABLE MODES(1:N.MODES)['PDP10','TYMEX','GE','SUDS']

!FLAGS
GLOBAL BAD.C.FLG	!=1 IF BAD CHARACTER WAS TYPED
GLOBAL N.OFFICIAL	!=1 IF CHANGING NON-OFFICIAL LUD/DUL
GLOBAL TTYF	!=1 IF RUN FROM TTY; =0 IF FROM CIRCUITS
   DEF CIR AS 0
GLOBAL MUDCIR ! = THERE IF CIR BUILT TO MUD SYSTEM
GLOBAL ACCT.CIR	!=THERE IF CIR BUILT TO ACCTG. SYS
GLOBAL IN.VAL.U
   DEF CANCEL AS 0
   DEF REMOVE AS 1
GLOBAL NEW.USER
   DEF NEW.U AS 0
   DEF ADD.U AS 1

!IMAGE MODE OPERATIONS
DEF SET.UP.TTY AS 1
DEF SEND AS 2
DEF RECEIVE AS 3
DEF CIR.EOF AS OCT 377

!WORDS IN LUD/DUL ENTRIES
DEF WD.PPN AS 0
DEF WD.S.NAME AS 0
DEF WD.DIST AS 1
DEF WD.NAME AS 1	!DUL ENTRY ONLY
DEF WD.INIT AS 2
DEF WD.SIZE AS 2
DEF WD.RUB AS 2
DEF WD.PRIV AS 3
DEF WD.HASH AS 4
DEF WD.STRN AS 5
DEF WD.QIN AS 6
DEF WD.QOUT AS 7

!MUD WORD VALUES
DEF M.NAME AS 0
DEF M.PASSW AS P.M.INDEX+0
DEF M.GAN AS P.M.INDEX + 2
DEF M.UUN AS P.M.INDEX + 3
DEF M.DIST AS P.M.INDEX + 4
DEF M.CPARW AS P.M.INDEX + 4

!MUD COMMANDS
DEF GET.M AS 1
DEF CH.HOME AS 2
DEF CH.PASSW AS 3
DEF CH.PRIV AS 4
DEF DELETE.M AS 5
DEF CH.DIST AS 6
DEF ADD.M AS 7
DEF REVERSE.M AS 8
DEF CHECK.M AS 9


GLOBAL TABLE ERRTAB(1:16)['$ENTRY COMPLETED','NAME ALLREADY IN LUD',&
   'NAME NOT IN LUD','NAME ALLREADY IN DUL','NAME NOT IN DUL',&
   'NAME ALLREADY IN MUD','NAME NOT IN MUD','STR ALLREADY THERE','STR NOT FOUND',&
   'BAD SITE','ERROR IN BILLING FILE','FILE BUSY - TRY AGAIN',&
   'ERROR IN DELETING FILE OR UFD','BAD CODE','SIMPL ERROR',&
   'ILLEGAL NAME']



DEF ACCT.SYS AS 31
DEF ACCT.SYS AS 31
DEF ACCT.SUP.BIT(A) AS BYT(A,1,13)
DEF ALPHA AS 0	!ARGUMENT FOR GETTOKEN - RETURN ALPHA VALUE
DEF CHG.ENT(A) AS [L.BLK.UP; A; LUD.CL]
DEF C.IMGIO(A,B) AS [OP _ A; CHR _ B; IMGIO]
DEF CHECK.OK AS IF QUERY('ALL ENTRIES CORRECT')= NO THEN GO GETCMD
DEF CK.A.CIR AS [IF ACT.CIR # THERE THEN [IF GET.A.CIR # THERE THEN &
	GO GETCMD]]
DEF CK.M.CIR AS [IF MUD.CIR # THERE THEN [IF GET.M.CIR # THERE THEN &
	GO GETCMD]]
DEF CR AS CHR.OUT(CARRET)
DEF D.BLK.UP AS [LOKUP.DUL(IN.UPDATE); SETCP(CH.DUL,FIXCP(D.LOC));&
	RB(CH.DUL,SIZE.BLK,D.BLK); SETCP(CH.DUL,FIXCP(D.LOC))]
DEF DIST.BITS AS BYT(LUD(WD.DIST),8,0)
DEF DUL(A) AS D.BLK(D.INDEX+A)
DEF DUL.OVER AS [D.OV.BLK.N_GET.D.OV.BLK; LOKUP.DUL(IN.READ);SETCP(CH.DUL,FIXCP(D.OV.BLK.N));&
	DUL.READ; CLOSE(CH.DUL)]
DEF DUL.READ AS [RB(CH.DUL,SIZE.BLK,D.BLK); D.INDEX _ 0]
DEF DUL.WRIT AS [WB(CH.DUL,SIZE.BLK,D.BLK); CLOSE(CH.DUL)]
DEF ERR.OUT(A) AS [IF TTYF = CIR THEN C.IMGIO(SEND,A) ELSE &
	[MSG(ERRTAB(A)); CR]]
DEF FIND.NAME AS [GET.NAME;&
   IF FOUND _ LUD.LOOK = THERE THEN MOVE SIZE.LUD.ENT FROM @LUD(WD.PPN) TO L.SAVE]
DEF FIXCP(A) AS (A-1)*SIZE.BLK
DEF G.CIR.NUM AS [P1 _ BYPT(NUMBER,24,8); NUMBER _ 0;&
   REPEAT 3 C.IMGIO(RECEIVE,NCHV P1)]
DEF G.CIR.WD(A,B) AS [P1 _ CHPT(A,-1); REPEAT B IMGIO(RECEIVE,P1)]
DEF GET.ACCT AS [C.IMGIO(RECEIVE,0); ANS _ CHR]
DEF GET.C.NAME AS [IF TTYF = CIR THEN G.CIR.WD(USER,12);&
	MAKE.SIXBIT(TOKEN,USER,12)]
DEF GET.DIST AS [GET.NUM.INF('DISTRICT: '); DIST _ NUMBER]
DEF GET.D.OV.BLK AS HW(@DUL(WD.PPN),1)
DEF GET.GAN AS [MSG('GAN: '); GAN _ HW(@L.SAVE(WD.PPN),0)_GETOCT]
DEF GET.L.OV.BLK AS HW(@LUD(WD.PPN),1)
DEF GET.NEW AS IF TTYF # CIR THEN MSG('NEW ')
DEF GET.NUM.INF(A) AS [IF TTYF # CIR THEN [MSG(A); GETNUM] &
   ELSE G.CIR.NUM]
DEF GET.T.NAME AS [MSG('USER NAME: '); GETTOKEN(ALPHA);&
	MAKE.SIXBIT(TOKEN,USER,12)]
DEF HIGH.UFD.INDEX AS 125
DEF INIT.BIT AS BYT(LUD(WD.INIT),1,8)
DEF IN.VAL.DUL AS MAKE.DUL.CHG(MOVE 3 FROM ALL 0 TO @DUL(WD.PPN))
DEF IN.VAL.LUD AS CHG.ENT(LUD(WD.HASH) _ 0)
DEF L.BLK.UP AS [LOKUP.LUD(IN.UPDATE); SETCP(CH.LUD,FIXCP(LOC.HASH));&
   RB(CH.LUD,SIZE.BLK,L.BLK); SETCP(CH.LUD,FIXCP(LOC.HASH))]
DEF L.OV.BLK AS HW(@LUD(WD.PPN),1)
DEF LUD(A) AS L.BLK(L.INDEX+A)
DEF LUD.CL AS [LUD.WRIT; CLOSE(CH.LUD)]
DEF LUD.OVER AS [L.OV.BLK.N _ GET.L.OV.BLK; LOKUP.LUD(IN.READ);&
   SETCP(CH.LUD,FIXCP(L.OV.BLK.N)); LUD.READ; CLOSE(CH.LUD)]
DEF LUD.READ AS [RB(CH.LUD,SIZE.BLK,L.BLK); L.INDEX _ 0]
DEF LUD.WRIT AS WB(CH.LUD,SIZE.BLK,L.BLK)
DEF MAKE.CHG(A) AS [CHECK.OK; CHG.ENT(A)]
DEF MAKE.DUL.CHG(A) AS [D.BLK.UP; A; DUL.WRIT]
DEF MAKE.VALID AS CHG.ENT(LUD(WD.HASH) _ NAME.HASH)
DEF MIN.CMD AS 1
DEF MAX.CMD AS 26
DEF MODE.BITS(A) AS BYT(A,2,7)
DEF MODE.BIT(A) AS BYT(A,2,7)
DEF N.DUL.BLKS AS SIZE(CH.DUL)/SIZE.BLK
DEF NEW.ENT.SIZE AS 8
DEF N.LUD.BLKS AS SIZE(CH.LUD)/SIZE.BLK
DEF NO AS 0
DEF NOT.THERE AS 0
DEF OCT.WD.OUT(A) AS [OCTOUT(HW(A),0); CHR.OUT($,); OCTOUT(HW(A),1)]
DEF OV.BIT AS OCT 400000
DEF OV.L.BIT AS HW(@LUD(WD.PPN),0)
DEF OV.D.BIT AS HW(@DUL(WD.PPN),0)
DEF IN.READ AS 0
DEF RESTORE AS [NAME.HASH_OLD.HASH; LOC.HASH_LOC.OLD.HASH;&
	L.INDEX_L.OLD.INDEX]
DEF RUB.BIT AS BYT(LUD(WD.RUB),1,33)
DEF SAVE.OLD AS [O.ENT.SIZE_SIZE.LUD.ENT; L.OLD.INDEX_L.INDEX+&
	LOC.OLD.HASH_LOC.HASH; OLD.HASH_NAME.HASH]
DEF SEND.SYS.AND.NAME AS [SEND.ACT(NUM.THIS.SYS,1); SEND.ACT(ALPHA,USER,12)]
DEF SET.SITE AS [HW(@EXTARG(IOTAB),0) _ SITE.31.NAME;&
   SITBYT _ SITBYT + SITE - 31]
DEF SITBYT AS BYT(EXTARG(IOTAB),6,24)
DEF SIZE.BLK AS 128
DEF SIZE.DUL.ENT AS 3
DEF SIZE.INIT.INF AS 3
DEF SIZE.LUD.ENT AS BYT(LUD(WD.SIZE),7,0)
DEF SIZE.STR.INF AS 3
DEF SIZE.UFD.ENT AS 5
DEF THERE AS 1
DEF TYMSH.BIT(A) AS BYT(A,1,14)
DEF UFD.READ AS [RB(CH.UFD,SIZE.BLK,UFD.BLK); INDEX _ 0]
DEF IN.UPDATE AS 1
DEF VERSION AS 23
DEF WHAT AS [MSG('$?$'); GO GETCMD]
DEF YES AS 1

!ERRORS
DEF OK AS 1
DEF NAME.IN.LUD AS 2
DEF NAME.NT.LUD AS 3
DEF NAME.IN.DUL AS 4
DEF NAME.NT.DUL AS 5
DEF NAME.IN.MUD AS 6
DEF NAME.NT.MUD AS 7
DEF STR.THERE AS 8
DEF STR.NT.THERE AS 9
DEF BAD.SITE AS 10
DEF BILL.FILE.ERR AS 11
DEF FILE.BUSY AS 12
DEF DEL.ERR AS 13
DEF BAD.CODE AS 14
DEF SIMPL.ERR AS 15
DEF BAD.NAME AS 16

START: GO FROMCIR	!START HERE IF FROM A CIRCUIT
FROMTTY: TTYF _ 1; INITUPD; GO GETCMD	!HERE IF FROM TTY - SET TTYF
\\->FROMTTY
FROMCIR: TTYF _ CIR; INITUPD; O.LUDUPD


GETCMD: N.OFFICIAL _ IN.VAL.U _ NEW.USER _ 0
MSG('$*'); P _ GETLINE(TEL); GETTOKEN(ALPHA)
   IF CMD _ CHOOSE(N.I.CMDS,INT.CMDS) = 0 THEN WHAT
DISP: DO CMD OF 1:N.I.CMDS

HELP: LISTABLE(N.U.CMDS,U.CMDS)

GET: CK.M.CIR; GET.T.NAME; MUDUP(GET.M)

CHECK: CK.M.CIR; GET.T.NAME; MUDUP(CHECK.M)

ADD: NEW.USER _ ADD.U; CMD _ VALIDATE; GO DISP

LIST: GETTOKEN(ALPHA)
   IF TMP _ CHOOSE(N.LISTS,L.CMDS) = 0 THEN WHAT
   IF TMP = L.USER THEN DO
	FIND.NAME
	IF FOUND # THERE THEN ERROR(NAME.NT.LUD)
	MSG('PPN: '); OCT.WD.OUT(@LUD(WD.PPN))
	MSG('$DISTRICT: '); NUMOUT(LUD(WD.DIST))
	MSG('$PRIV: ')
	   IF ACCT.SUP.BIT(LUD(WD.PRIV)) = 1 THEN MSG('ACCT. SUP ')
	   IF TYMSH.BIT(LUD(WD.PRIV)) = 1 THEN MSG('TYM')
	   MSG('$MODE: '); MSG(@MODES(MODE.BIT(WD.PRIV)))
	   INDEX _ WD.STRN; TMP _ 0
	   IF INIT.BIT = 1 THEN [INDEX+_SIZE.INIT.INF; TMP_SIZE.INIT.INF]
	   TMP _ ((SIZE.LUD.ENT-TMP)-WD.STRN)/SIZE.STR.INF
	   REPEAT TMP DO
		MSG('STRUCTURE: ')
		P1 _ BYPT(L.BLK+L.INDEX+INDEX,1,6)
		REPEAT 4 CHR.OUT(NCHV P1 + OCT 40)
		MSG('$QUOTA IN: '); NUMOUT(LUD(INDEX+1))
		MSG('$QUOTA OUT: '); NUMOUT(LUD(INDEX+2))
	   END
   END ELSE DO
	GET.GAN
	IO.ADR _ GETCMD
	LOKUP.LUD(IN.READ); LUD.READ
	LOOP DO
	   LUD.SEQ
	   IF HW(@LUD(WD.PPN),0) = GAN THEN DO
		IF DUL.LOOK = THERE THEN DO
		   P1 _ BYPT(D.BLK+D.INDEX+WD.NAME,1,6)
		   REPEAT 12 CHR.OUT(NCHV P1 + OCT 40)
		   CR
		END
	   END
	END
   END

QUIT: EXIT

REMOVE: IN.VAL.USER _ REMOVE; CMD _ INVALIDATE; GO GETCMD

INVALIDATE: CK.A.CIR; CK.M.CIR
   FIND.NAME
   IF FOUND # THERE THEN ERROR(NAME.NT.LUD)
   IF MUDUP(GET.M) # THERE THEN ERROR(NAME.NT.MUD)
   IF LUD(WD.PPN) = OCT 1000001 OR LUD(WD.PPN) = OCT 1000004 THEN ERROR(BAD.NAME)
   CHECK.OK
   IF IN.VAL.USER = CANCEL THEN MUDUP(DELETE.M)
   DEL.FILES
   CHG.ENT(LUD(WD.HASH) _ 0)
   IF THIS.SYS = ACT.SYS THEN ANS _ O.LUDUPD(DEL.USR) ELSE DO
	SEND.ACT(NUM,DEL.USR,1)
	SEND.SYS.AND.NAME
	GET.ACCT
   END
   IF ANS # OK THEN DO
	IF IN.VAL.USER = CANCEL THEN MUDUP(REVERSE.M)
	MAKE.VALID
   END
   ERROR(ANS)

ADD: NEW.USER _ ADD.U; CMD _ VALIDATE; GO DISP

VALIDATE: CK.A.CIR; CK.M.CIR
   FIND.NAME
   IF FOUND # THERE THEN ERROR(NAME.IN.LUD)
   IF TMP _ MUDUP(GET.M) # THERE THEN DO
	IF NEW.USER = ADD.U THEN ERROR(NAME.NT.MUD)
   END ELSE IF NEW.USER = NEW.U THEN ERROR(NAME.IN.MUD)
   L.SAVE(WD.HASH) _ NAME.HASH
   IF TMP = 0 THEN DO
	GET.GAN
	MSG('UUN: '); UUN _ HW(@L.SAVE(WD.PPN),1) _ GETOCT
	GET.DIST; BYT(L.SAVE(WD.DIST),8,0) _ DIST
	GET.P.BITS; L.SAVE(WD.PRIV) _ PRIV
   END ELSE DO
	GAN _ HW(@L.SAVE(WD.PPN),0) _ BYT(MUD(M.GAN),20,0)
	UUN _ HW(@L.SAVE(WD.PPN),1) _ BYT(MUD(M.UUN),17,0)
	DIST _ BYT(L.SAVE(WD.DIST),8,0) _ BYT(MUD(M.DIST),9,0)
	ACCT.SUP.BIT(PRIV) _ BYT(MUD(M.CPARW),1,19)
	TYM.SH.BIT(PRIV) _ BYT(MUD(M.CPARW),1,23)
	GET.MODE
	L.SAVE(WD.PRIV) _ PRIV)
   END
   BYT(L.SAVE(WD.SIZE),7,0) _ NEW.ENT.SIZE
   GET.STR.INF
   CHECK.OK
   MUDUP(ADD.M)
   FIND.L.ROOM
   CHG.ENT(MOVE NEW.ENT.SIZE FROM L.SAVE TO @LUD(WD.PPN); &
	   MOVE SIZE.STR.INF FROM STRINF TO @LUD(WD.STRN))
   IF DUL.LOOK = THERE THEN DO
	IF NEW.USER # ADD.U THEN MUDUP(REVERSE.M)
	IN.VAL.LUD
	ERROR(NAME.IN.DUL)
   END
   FIND.D.ROOM	!IN THIS NECESSARY?
   MAKE.DUL.CHG(DUL(WD.PPN) _ LUD(WD.PPN); MOVE 2 FROM USER TO @DUL(WD.NAME))
   IF THIS.SYS = ACCT.SYS THEN ANS _ O.LUDUPD(ADD.USR) ELSE DO
	SEND.ACT(NUM,ADD.USR,1)
	SEND.SYS.AND.NAME
	SEND.ACT(NUM,GAN,3)
	SEND,ACT(NUM.UUN,3)
	SEND.ACT(NUM,DIST,1)
	SEND.ACT(NUM,PRIV,3)
	SEND.ACT(ALPHA,STRINF,4)
	SEND.ACT(NUM,STRINF+1,3)
	SEND.ACT(NUM,STRINF+2,3)
	GET.ACCT
   END
   IF ANS # OK THEN DO
	IF N.USER # ADD.U THEN MUDUP(REVERSE.M)
	IN.VAL.DUL
	IN.VAL.LUD
   END
   ERROR(ANS)

CHANGE: GETTOKEN(ALPHA)
   IF CHG _ CHOOSE(N.CHANGES,CH.CMDS) = 0 THEN WHAT
   DO CHG OF 1:N.CHANGES

CH.HOME: CK.M.CIR; GET.T.NAME; CHECK.OK; MUDUP(CH.HOME)

CH.PASS: CK.M.CIR; GET.NAME; CHECK.OK; MUDUP(CH.PASSW)

CH.PRIV: CK.M.CIR; CK.A.CIR
   FIND.NAME
   IF FOUND # THERE THEN ERROR(NAME.NT.LUD)
   IF MUDUP(GET.M) # THERE THEN ERROR(NAME.NT.MUD)
   GET.P.BITS
   MAKE.CHG(LUD(WD.PRIV) _ PRIV)
   MUDUP(CH.PRIV)
   IF THIS.SYS = ACCT.SYS THEN ANS _ O.LUDUPD(CH.PRIV) ELSE DO
	SEND.ACT(NUM,CH.PRIV,1)
	SEND.SYS.AND.NAME
	SNED.ACT(NUM,PRIV,3)
	GET.ACCT
   END
   ERROR(ANS)

CH.STR: CK.A.CIR; FIND.NAME
   IF FOUND ## THERE THEN ERROR(NAME.NT.LUD)
   STR.INF(WD.STRN) _ 'DSKB'
   IF FIND.STR # THERE THEN ERROR(STR.NT.THERE)
	OLD.STRN _ STRINF(WD.STRN)
	GET.STR.INF
	MAKE.CHG(MOVE SIZE.STR.INF FROM STRINF TO @LUD(INDEX))
   IF THIS.SYS = ACCT.SYS THEN ANS _ O.LUDUPD(CH.STR) ELSE DO
	SEND.ACT(NUM.CH.STR,1)
	SEND.SYS.AND.NAME
	SEND.ACT(ALPHA,OLD.STRN,4)
	SEND.ACT(ALPHA,STRINF,4)


	SEND.ACT(NUM,STRINF+1,3)
	SEND.ACT(NUM,STRINF+2,3)
	GET.ACCT
   END
   ERROR(ANS)

CH.DIST: CK.M.CIR; CK.A.CIR;  FIND.NAME
   IF FOUND # THERE THEN ERROR(NAME.NT.LUD)
   GET.NEW
   GET.DIST
   MUDUP(CH.DIST)
   MAKE.CHG(DIST.BITS _ DIST)
   IF THIS.ACCCT = ACCT.SYS THEN ANS _ O.LUDUPD(CH.DIST) ELSE DO
	SEND.ACT(NUM,CH.DIST,1)
	SEND.SYS.AND.NAME
	SEND.ACT(NUM,DIST,1)
	GET.ACCT
   END
   IF ANS # OK THEN DO
	MUDUP(REVERSE.M)
	CHG.ENT(DIST.BITS _ BYT(L.SAVE(WD.DIST),8,0))
   END
   ERROR(ANS)

CH.RUB: CK.A.CIR; FIND.NAME
   IF FOUND # THERE THEN  ERROR(NAME.NT.LUD)
   RUB _ QUERY('$SET RESTRICTED USE BIT')
   MAKE.CHG(RUB.BIT _ RUB)
   IF THIS.ACCT = ACCT.SYS THEN ANS _ O.LUDUPD(CH.RUB) ELSE DO
	SEND.ACT(NUM,CH.RUB,1)
	SEND.SYS.AND.NAME
	SEND.ACT(NUM,RUB,1)
	GET.ACCT
   END
   IF ANS # OK THEN CHG.ENT(RUB.BIT(L.SAVE(WD.RUB),1,33))
   ERROR(ANS)

CH.NAME: FIND.NAME
   IF FOUND # THERE THEN ERROR(NAME.NT.LUD)
   IF MUDUP(GET.M) # THERE THEN ERROR(NAME.NT.MUD)
   MOVE 2 FROM USER TO OLDNAME
   GET.NAME; MUDUP(CH.NAME)
   MAKE.CHG(LUD(WD.HASH) _ 0)
   SAVE.OLD
   IF LUD.LOOK = THERE THEN DO
	RESTORE
	MAKE.VALID
	MUDUP(REVERSE.M)
	ERROR(NAME.IN.LUD)
   END
   FIND.L.ROOM
   LUD(WD.PPN) _ L.SAVE(WD.PPN)
   OLDNAME(0) <=> USER(0)
   OLDNAME(1) <=> USER(1)
   IF DUL.LOOK = NOT.THERE THEN DO
	LOC.HASH _ LOC.OLD.HASH
	RESTORE
	MAKE.VALID
	MUDUP(REVERSE.M)
	ERROR(NAME.NT.DUL)
   END
   OLDNAME(0) <=> USER(0)
   OLDNAME(1) <=> USER(1)
   MAKE.DUL.CHG(MOVE 2 FROM USER TO @DUL(WD.NAME))
   CHG.ENT(MOVE O.ENT.SIZE FROM L.SAVE TO @LUD(WD.PPN))
   IF THIS.SYS = ACCT.SYS THEN ANS _ O.LUDUPD(CH.NAME) ELSE DO
	SEND.ACT(NUM,OLDNAME,12)
	SEND(NUM,THISSYS,1)
	SEND.ACT(ALPHA,USER,12)
	GET.ACCT
   END
   IF ANS # OK THEN DO
	MUDUP(REVERSE.M)
	IN.VAL.LUD
	RESTORE
	MAKE.VALID
	MAKE.DUL.CHG(MOVE 2 FROM OLD.NAME TO @(WD.NAME))
   END
   ERROR(ANS)

END
END




%INITUPD
LOCAL L.TMP
IOCS(2)
!SSET THIS.LIC
!SET THIS.SYS
IF TTYF # CIR THEN DO
   INITTTY(BAD.CHR)
   CH.OUT _ OPEN('TEL', SEQUEN+OUTPUT+CHARACTER,0,2)
   MOVE 72/CHARS.PER.WORD FROM ALL 0 TO TOKEN
   MSG('$LUD UPDATER - VERSION '); NUMOUT(VERSION)
END ELSE DO
   C.IMGIO(SET.UP.TTY,0)
   REPEAT 2 C.IMGIO(SEND,1)
   C.IMGIO(SEND,OCT 40)
   L.TMP _ 0
   WHILE L.TMP = 0 THEN DO
	C.IMGIO(RECEIVE,0); IF CHR = 1 THEN DO
	   C.IMGIO(RECEIVE,0); IF CHR = 1 THEN DO
	      C.IMGIO(RECEIVE,0); IF CHR = OCT 40 THEN INC L.TMP
	   END
	END
   END
END
P1 _ CHPT('(CUD10)LUD.31',-1)
   SETFID(IOTAB,@P1,0,CHK.ERR)
   LUD.NAME _ NAMARG(IOTAB)
   SITE.31.NAME _ HW(@EXTARG(IOTAB),0)
P1 _ CHPT('(CUD10)DUL.UFD',-1)
   SETFID(IOTAB,@P1,0,CHKERR)
   DUL.NAME _ NAMARG(IOTAB)
   UFD _ HW(@EXTARG(IOTAB),0)
INDEX _ D.LOC _ D.OV.BLK.N _ TMP _ CODE _ OLD.NAME(0) _ 0
OLD.NAME(1) _ L.OLD.INDEX _ LOC.OLD.HASH _ O.ENT.SIZE _ OLD.HASH _ 0
FOUND _ N.OFFICIAL _ SITE _ OLD.CODE _ BAD.C.FLG _ 0
GET.M.CIR; GET.A.CIR
RETURN
END INIT.UPD



%O.LUDUPD(CODE)	!UPDATE NON STANDARD LUD/DUL
LOCAL SITE
N.OFFICIAL _ 1
IF TTYF = CIR THEN 
   G.CIR.NUM; CODE _ NUMBER
   G.CIR.NUM; SITE _ NUMBER
END ELSE SITE _ ACCT.SYS
IF TTYF = CIR THEN [G.CIR.NUM; SITE _ NUMBER] ELSE SITE _ ACCT.SYS
DO CODE OF MIN.CMD: MAX.CMD

DEL.USR: GET.C.NAME
   IF FOUND # THERE THEN RETURN NAME.NT.LUD
   CHG.ENT(LUD(WD.HASH) _ 0)

CH.PRIV: GET.C.NAME
   IF FOUND # THERE THEN RETURN NAME.NT.LUD
   IF TTYF = CIR THEN [G.CIR.NUM; PRIV _ NUMBER]
   CHG.ENT(LUD(WD.PRIV) _ PRIV)

CH.STR: GET.C.NAME
    IF FOUND # THERE THEN RETURN NAME.NT.LUD
   IF TTYF = CIR THEN G.CIR.WD(STRINF,4)
   IF FIND.STR # THERE THEN RETURN STR.NT.THERE
   OLD.STRN _ STRINF(WD.STRN)
   IF TTYF = CIR THEN GET.STR.INF
   CHG.ENT(MOVE SIZE.STR.INF FROM STRINF TO @LUD(INDEX))

CH.DIST: GET.C.NAME
   IF FOUND # THERE THEN RETURN NAME.NT.LUD
   IF TTY = CIR THEN [C.IMGIO(RECEIVE,0); DIST _ NUMBER]
   CHG.ENT(DIST.BITS _ DIST)

CH.RUB: GET.C.NAME
   IF FOUND # THERE THEN RETURN NAME.NT.LUD
   IF TTY = CIR THEN [C.IMGIO(RECEIVE,0); RUB _ NUMBER]
   CHG.ENT(RUB.BIT _ RUB)

ADD.USR: GET.C.NAME
   IF FOUND = THERE THEN RETURN NAME.IN.LUD
   FIND.L.ROOM
   IF TTYF = CIR THEN DO
	L.SAVE(WD.HASH) _ NAME.HASH
	G.CIR.NUM; HW(@L.SAVE(WD.PPN),0) _ NUMBER
	G.CIR.NUM; HW(@L.SAVE(WD.PPN),1) _ NUMBER
	BYT(L.SAVE(WD.SIZE,7,0) _ NEW.ENT.SIZE
	GET.DIST; BYT(L.SAVE(WD.DIST),8,0) _ DIST
	GET.P.BITS; L.SAVE(WD.PRIV) _ PRIV
	GET.STR.INF
    END
   CHG.ENT(MOVE NEW.ENT.SIZE FROM L.SAVE TO @LUD(WD.PPN);&
	MOVE SIZE.STR.INF FROM STRINF TO @LUD(WD.STRN))
   IF DUL.LOOK = THERE THEN [IN.VAL.LUD; RETURN NAME.IN.DUL]
   FIND.D.ROOM
   MAKE.DUL.CHG(MOVE 2 FROM USER TO @DUL(WD.NAME); DUL(WD.PPN) _ LUD(WD.PPN))

CH.NAME: IF TTYF = CIR THEN [G.CIR.WD(USER,12); OLDNAME(0) _ USER(0); &
	OLDNAME(1) _ USER(1)]
   IF FOUND _ LUD.LOOK = THERE THEN RETURN NAME.IN.LUD
   IF TTYF = CIR THEN DO
	G.CIR.WD(USER,12)
	SAVE.OLD
   END
   CHG.ENT(LUD(WD.HASH) _ 0)
   IF LUD.LOOK = THERE THEN DO
	RESTORE
	MAKE.VVLID
	RETURN NAME.IN.LUD
   END
   FIND.L.ROOM
   LUD(WD.PPN) _ L.SAVE(WD.PPN)
   OLDNAME(0) <=> USER(0)
   OE(1) <=> USER(1)
   IF DUL.LOOK # THERE THEN DO
	RESTORE
	MAKE.VALID
	RETURN NAME.NT.DUL
   END
   OLDNAME(0) <=> USER(0)
   OLDNAME(1) <=> USER(1)
   MAKE.DUL.CHG(MOVE 2 FROM USER TO @DUL(WD.NAME))
   CHG.ENT(MOVE O.ENT.SIZE FROM L.SAVE TO @LUD(WD.PPN))
END
RETURN OK
END  O.LUDUPD


%LOKUP.LUD(MODE)
	!MODE = READ OR UPDATE
IF N.OFFICIAL = 0 THEN DO
   IF MODE = IN.READ THEN CH.LUD _ OPEN('(NICRAM)LUD.SYS',DIRECT+INPUT+WORD,CHK.ERR)&
	ELSE CH.LUD _ OPEN('(NICRAM)LUD.SYS',DIRECT+UPDATE+WORD,CHK.ERR)
END ELSE DO
   NAMARG(IOTAB) _ LUD.NAME
   SET.SITE
   IF MODE = IN.READ THEN CH.LUD _ OPEN(-IOTAB,DIRECT+INPUT+WORD,CHK.ERR)&
	ELSE CH.LUD _ OPEN(-IOTAB,DIRECT+UPDATE+WORD,CHK.ERR)
END
SIZE.LUD _ N.LUD.BLKS
RETURN
END LOKUP.LUD


%LOKUP.DUL(MODE)
IF N.OFFICIAL = 0 THEN DO
IF MODE = IN.READ THEN CH.DUL _ OPEN('(NICRAM)DUL.SYS',DIRECT+INPUT+WORD,CHK.ERR)&
	ELSE CH.DUL _ OPEN('(NICRAM)DUL.SYS',DIRECT+UPDATE+WORD,CHK.ERR)
END ELSE DO
   NAMARG(IOTAB) _ DUL.NAME
   SET.SITE
   IF MODE = IN.READ THEN CH.DUL _ OPEN(-IOTAB,DIRECT+INPUT+WORD,CHK.ERR)&
	ELSE CH.DUL _ OPEN(-IOTAB,DIRECT+UPDATE+WORD,CHK.ERR)
END
SIZE.DUL _ N.DUL.BLKS
RETURN
END LOKUP.DUL


%LUD.LOOK
	!LOOKUP USER,USER+1 IN LUD
HASH(USER(0),USER(1)); L.OV.BLK.N _ 0
LOKUP.LUD(IN.READ)
SETCP(CH.LUD,FIXCP(LOC.HASH)); LUD.READ; CLOSE(CH.LUD)
WHILE LUD(WD.HASH) # NAME.HASH THEN DO
   EIF LUD(WD.PPN) = 0 THEN RETURN NOT.THERE
   ORIF LUD(WD.PPN) < 0 THEN LUD.OVER
   ELSE L.INDEX + _ SIZE.LUD.ENT
END
RETURN THERE
END LUD.LOOK



%DUL.LOOK
D.LOC _ LUD(WD.PPN) MOD 101 + 1
D.OV.BLK.N _ 0
LOKUP.DUL(IN.READ)
SETCP(CH.DUL,FIXCP(D.LOC))
DUL.READ; CLOSE(CH.DUL)
WHILE DUL(WD.PPN) # LUD(WD.PPN) THEN DO
   IF DUL(WD.PPN) = 0 THEN RETURN NOT.THERE
   IF DUL(WD.PPN) < 0 THEN DUL.OVER
   D.INDEX + _ SIZE.DUL.ENT
END
RETURN THERE
END DUL.LOOK


%CHK.IO.ERR
CHK.ERR: IF ERRNUM = EOFERR AND IO.ADR # 0 THEN GO ^IO.ADR
   IF TTYF = CIR THEN ERROR(SIMPL.ERR)
   MSG('$ERROR ON '); WFID(FIDP); CR
   DO ERRNUM OF TMFERR:CORERR
TMFERR: MSG('TOO MANY FILES OPEN')
FMDERR: MSG('BAD FILE MODE OR TYPE')
IFDERR: MSG('ILLEGAL FILE ID')
FNFERR: MSG('FILE NOT FOUND')
IUSERR: MSG('INVALID USER NAME')
PRTERR: MSG('PROTECTION FAILURE')
EOFERR: MSG('END OF FILE')
   END
   MSG('.$ ERROR '); NUMOUT(ERRNUM); EXIT
END CHK.IO.ERR


%ERROR(NUM)
ERR.OUT(NUM)
IF NUM = BAD.CODE THEN SEND.CIR(CODE)
IF NUM = SIMPL.ERR THEN SEND.CIR(ERRNUM)
IF TTYF = CIR THEN EXIT ELSE GO GETCMD

END ERROR


%LUD.SEQ
LOOP DO
   L.INDEX + _ SIZE.LUD.ENT
   IF LUD(WD.PPN) < 0 THEN LUD.OVER
   WHILE LUD(WD.PPN) <= 0 THEN LUD.READ
   IF LUD(WD.HASH) # 0 THEN RETURN
END
END LUD.SEQ


%FIND.STR
!FIND STR IN STRINF IN LUD,
!IF FOUND, LOC IN INDEX UPDON RETURN
INDEX _ WD.STRN
WHILE LUD(INDEX) # STRINF(WD.S.NAME) THEN DO
   INDEX + _ SIZE.STR.INF
   IF INDEX >=SIZE.LUD.ENT THEN RETURN NOT.THERE
END
RETURN THERE
END FIND.STR


%FIND.L.ROOM
!MAKE ROOM FOR NEW ENTRY (NEW.ENT.SIZE WDS)
!CREATE OVERFLOW IF NECESSARY
L.INDEX _ 0
LOOP DO
   EIF LUD(WD.PPN) = 0 THEN DO
	IF L.INDEX + NEW.ENT.SIZE <= SIZE.BLK-1 THEN RETURN
	MAKE.L.OVER; RETURN
     END
   ORIF LUD(WD.PPN) < 0 THEN LUD.OVER
   ORIF LUD(WD.HASH) = 0 THEN DO
	IF SIZE.LUD.ENT = NEW.ENT.SIZE THEN RETURN
	MOVE SIZE.BLK-(L.INDEX+SIZE.LUD.ENT) FROM @LUD(SIZE.LUD.ENT)&
	TO @LUD(SIZE.LUD.ENT-NEW.ENT.SIZE)
	RETURN
     END
   ELSE L.INDEX+_SIZE.LUD.ENT
END
END FIND.L.ROOM


%FIND.D.ROOM
D.INDEX _ 0
LOOP DO
   EIF DUL(WD.PPN) = 0 THEN DO
	IF D.INDEX + SIZE.DUL.ENT < SIZE.BLK THEN RETURN
	MAKE.D.OVER; RETURN
   END
   ORIF DUL(WD.PPN) < 0 THEN DUL.OVER
   ELSE D.INDEX + _ SIZE.DUL.ENT
END
END FIND.D.ROOM


%MAKE.L.OVER
L.BLK.UP
SIZE.LUD _ GET.L.OV.BLK _ L.OV.BLK.N _ SIZE.LUD + 1
OV.L.BIT _ OV.BIT; LUD.CL
MOVE SIZE.BLK FROM ALL 0 TO @LUD(WD.PPN)
LOKUP.LUD(IN.UPDATE)
SETCP(CH.LUD,FIXCP(SIZE.LUD))
LUD.CL
L.INDEX _ 0
RETURN
END MAKE.L.OVER


%MAKE.D.OVER
D.BLK.UP; SIZE.DUL _ GET.D.OV.BLK _ D.OV.BLK.N _ SIZE.DUL + 1
OV.D.BIT _ OV.BIT; DUL.WRIT
MOVE SIZE.BLK FROM ALL 0 TO @DUL(WD.PPN)
LOKUP.DUL(IN.UPDATE); SETCP(CH.DUL,FIXCP(SIZE.DUL))
DUL.WRIT
D.INDEX _ 0
RETURN
END MAKE.D.OVER



%DELFILES
LOCAL CH.UFD, UFDBLK(SIZE.BLK)
LOCAL  HIGHJOB, ACC, USR.TAB(WPF)
ERRNUM _ 0
ACC _ OCT 20000012
HIGHJOB _ CALL.GETTAB(ACC)
WHILE DEC HIGH.JOB >= 0 THEN DO
   HW(ACC,0) _ HIGHJOB + 1; HW(ACC,1) _ 2
   IF CALL.GETTAB(ACC) = LUD(WD.PPN) THEN ERR.OUT(DEL.ERR)
END
PPNARG(IOTAB) _ OCT 1000001; NAMARG(IOTAB) _ LUD(WD.PPN)
EXTARG(IOTAB) _ UFD
CH.UFD _ OPEN(-IOTAB,DIRECT+INPUT+WORD,CHK.ERR)
PPNARG(IOTAB) _ LUD(WD.PPN)
UFD.READ
WHILE NAMARG(USR.TAB) _ UFD.BLK(INDEX) # 0 THEN DO
   IF INDEX >= HIGH.UFD.INDEX THEN UFD.READ ELSE DO
	HW(@EXTARG(USR.TAB),0) _ HW(@UFD.BLK(INDEX+1),0)
	DELETE(-USR.TAB,CHK.ERR)
	INDEX + _ SIZE.UFD.ENT
    END
END
END.UFD: DELETE(-IOTAB,CHK.ERR)
IF TTYF = CIR THEN DO
   C.IMGIO(SEND,1)
   SEND.O.WD('$PPN: ',^L.BLK+L.INDEX+WD.PPN)
END
RETURN
END DELFILES


%CALL.GETTAB(AC)
LOCAL DIDIT:
TMP _ EXU(OCT 47,AC,OCT 41,DIDIT)
ERROR(MISC)
DIDIT: RETURN TMP
END CALL.GETTAB

%GET.STR.INF
IF TTYF = CIR THEN G.CIR.WD(STRINF,4) ELSE STRINF(WD.STRN)_'DSKB'
GET.NUM.INF('QUOTA IN: '); STRINF(1) _ NUMBER
GET.NUM.INF('QUOTA OUT: '); STRINF(2) _ NUMBER
RETURN
END GET.STR.INF


%SEND.O.WD(A,B)
IF TTYF # CIR THEN DO
   TMP _ HW(B,0)
   SEND.O.NUM(A,TMP)
   TMP _ HW(B,1)
   SEND.O.NUM(',',TMP)
END ELSE DO
   TMP _ HW(B,0)
   S.CIR.NUM(TMP)
   TMP _ HW(B,1)
   S.CIR.NUM(TMP)
END
RETURN
END SEND.O.WD



%GET.P.BITS
IF TTYF = CIR THEN DO
   G.CIR.NUM
   PRIV _ NUMBER
   RETURN
END
PRIV _ 0
ACCT.SUP.BIT(PRIV) _ QUERY('ACCOUNT SUPERVISOR')
TYMSH.BIT(PRIV) _ QUERY('TYMSHARE')
GET.MODE
RETURN
END GET.P.BITS



%GET.MODE
LOOP DO
	MSG('MODE: '); GETTOKEN(ALPHA)
	IF MODE _ CHOOSE(N.MODES,MODES) # 0 THEN DO
	  MODE.BITS(PRIV) _ MODE -1
	RETURN
END
MSG('$VALID MODES ARE: '); LISTABLE(N.MODES,MODES)
CR
END
END GET.MODES



%SEND.ACT(TYPE,WD,N)
IF TYPE = NUM THEN DO
   P1 _ BYPT(WD,24,8)
   IF N = 1 THEN [NCHV P1; NCHV P1]
P1 _ BYPT(WD,6,0)
END
REPEAT N C.IMGIO(SEND,NCHV P1)
RETURN
END SEND.ACT



%GET.M.CIR
IF NUM.CIR = THERE THEN RETURN
MSG('$CANNOT BUILD CIRCUITS TO MUD SYTEM NOW.$')
RETURN
END GET.M.CIR



%GET.A.CIR
IF ACT.CIR = THERE THEN RETURN
MSG('$CANNOT BUILLD CICUITS TO ACCTG. SYSTEM NOW.$')
RETURN 
END GET.A.CIR


%MUDUP(KIND)
DO KIND OF GET.M:CHECK.M

GET.M: IF FIND.MUD # THERE THEN ERROR(NAME.NT.MUD)
   MSG('$GAN: '); OCTOUT(@MUD(M.GAN))

CHECK.M: IF FIND.MUD # THERE THEN ERROR(NAME.NT.MUD) ELSE ERROR(NAME.IN.MUD)

END
RETURN
END MUDUP



END TENUPDATE
                                                                                                                                                                                                                                                                                                                                                                                                                                                                &i