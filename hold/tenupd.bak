BASE 0
GLOBAL %TENUPDATE

%TENUPDATE


FIND %OUT, %BYPT, %CHOOSE, %LISTABLE, %DATOUT, %BUILD
FIND %INITTTY, %GETNUM, %GETTOKEN, %NUMOUT, %OCTOUT, %GETOCT, %QUERY
FIND %IMGIO, %HASH, %MAKE.SIXBIT, %CHR.OUT, %PASS.IN
FIND TOKEN(0)

GLOBAL CHK.ERR:, IO.ADR, IOTAB(WPF)

GLOBAL INDEX, THIS.SYS, THIS.LIC, CMD,CHG
GLOBAL OP, CHR	!VARIABLES FOR IMAGE I/O
GLOBAL D.BLK(128), D.INDEX, D.LOC, CH.DUL,  DUL.NAME, D.OV.BLK.N
GLOBAL SIZE.DUL, PASSW(2), ANS(4), H.SYS, DATE, DAY, TTFNAME, TTEXT
GLOBAL L.BLK(128), L.INDEX, LOC.HASH, CH.LUD, LUD.NAME, L.OV.BLK.N
GLOBAL L.SAVE(128), SIZE.LUD, CPARW, CT
GLOBAL SITE.31.NAME, SITE, CODE, C.USER(2), M.KIND
GLOBAL CH.OUT, P, NUMBER, P1, TMP, USER(2), FOUND
GLOBAL STRINF(2), NAME.HASH, OLD.NAME(2), PRIV, DIST, RUB
GLOBAL GAN, UUN, MUD(3), A.CHAN, STRING
GLOBAL L.OLD.INDEX, LOC.OLD.HASH, O.ENT.SIZE, OLD.HASH
GLOBAL UFD, BAD.CHR:, FROMTTY:

GLOBAL %ERROR, %INITUPD, %LOKUP.LUD, %LUD.SEQ, %LOKUP.DUL
GLOBAL %LUD.LOOK, %DUL.LOOK, %DEL.FILES, %CALL.UUO
GLOBAL %FIND.STR, %FIND.L.ROOM, %MAKE.L.OVER
GLOBAL %MAKE.D.OVER, %CHK.IO.ERR, %GET.STR.INF, %SEND.O.WD
GLOBAL %GET.P.BITS, %O.LUDUPD, %MUDUP, %BLD.M.CIR, %BLD.A.CIR
GLOBAL  %GET.MODE, %GET.CIR, %T.ERROR
GLOBAL %CHECK.OK, %LIST.INF, %CHANGE.ENT, %BILL.USER
GLOBAL %SEND.CIR, %GET.MUD.DATA, %COMPRESS, %MAKE.CPARW




!INTERNAL MUD,LUD,DUL COMMANDS
DEF DEL.USR AS 3
DEF ADD.USR AS 1
DEF CH.NAME AS 6
DEF CH.PRIV AS 4
DEF CH.STR AS 5
DEF CH.DIST AS 11
DEF CH.RUB AS 7
DEF CH.HOME AS 8
DEF REVERSE AS 9
DEF CH.PASSW AS 2
DEF GET.M AS 10
DEF OTHER.L.D AS 12
DEF CH.COMMON AS 13
DEF CK.UNQE AS 14

!USER COMMANDS
DEF HELP AS 1
DEF GET AS 2
DEF VALIDATE AS 3
DEF ADD AS 4
DEF CHANGE AS 5
DEF INVALIDATE AS 6
DEF REMOVE AS 7
DEF CHECK AS 8
DEF LIST AS 9
DEF QUIT AS 10

!LIST COMMANDS
DEF L.PROJECT AS 1
DEF L.USER AS 2


!MUD ERRORS
DEF NIM AS 1	!NOT IN MUD
DEF AIM AS 2	!ALLREADY IN MUD
DEF MFB AS 3	!MUD FILE BUSY

!SIZE OF TABLES
DEF N.I.CMDS AS 14
DEF N.U.CMDS AS 16
DEF N.MODES AS 4
DEF N.LISTS AS 2
DEF MAX.N.CHANGES AS 11


GLOBAL TABLE INT.CMDS(1:N.I.CMDS)['HELP','GET','NEW','ADD','CHANGE',&
	'CANCEL','REMOVE','CHECK','LIST','QUIT']

GLOBAL TABLE U.CMDS(1:N.U.CMDS)['HELP','NEW USER',&
	'ADD PDP10','CHANGE NAME','CHANGE HOME','CHANGE PASSWORD',&
        'CHANGE PRIVILEGES','CANCEL USER','REMOVE PDP10',&
	'CHANGE STRUCTURE','CHANGE DISTRICT','CHECK NAME',&
	'GET MUD','LIST PROJECT','LIST USER','QUIT']


GLOBAL TABLE CH.CMDS(1:MAX.N.CHANGES)[-1,'PASSWORD',-1,'PRIVILEGES',&
   'STRUCTURE','NAME',-1,'HOME',2(-1),'DISTRICT']

GLOBAL TABLE L.CMDS(1:N.LISTS)['PROJECT','USER']

GLOBAL TABLE MODES(1:N.MODES)['PDP10','TYMEX','GE','SUDS']

!FLAGS
GLOBAL N.OFFICIAL	!=1 IF CHANGING NON-OFFICIAL LUD/DUL
GLOBAL TTYF		!=1 IF RUN FROM TTY; =0 IF FROM CIRCUITS
   DEF CIR AS 0
GLOBAL MUD.CIR		 ! = CHAN. #  IF CIR BUILT TO MUD SYSTEM, ELSE ZERO
GLOBAL ACCT.CIR		! = CHAN. #  IF CIR BUILT TO ACCTG. SYS, ELSE ZERO
GLOBAL IN.VAL.UF	! = EITHER REMOVE OR CANCEL
   DEF U.CANCEL AS 0
   DEF U.REMOVE AS 1
GLOBAL NEW.USERF	! = EITHER NEW OR ADD
   DEF NEW.U AS 0
   DEF ADD.U AS 1

!IMAGE MODE OPERATIONS - USED WHEN TENUPD IS RUN FROM AN AUX CIR.
DEF SET.UP.TTY AS 1
DEF SEND AS 2
DEF RECEIVE AS 3

!WORDS IN LUD/DUL ENTRIES
DEF WD.PPN AS 0
DEF WD.S.NAME AS 0
DEF WD.DIST AS 1
DEF WD.NAME AS 1	!DUL ENTRY ONLY
DEF WD.INIT AS 2
DEF WD.SIZE AS 2
DEF WD.RUB AS 2
DEF WD.PRIV AS 3
DEF WD.HASH AS 4
DEF WD.STRN AS 5
DEF WD.QIN AS 6
DEF WD.QOUT AS 7

!MUD WORD VALUES
DEF M.GAN AS 0
DEF M.UUN AS 1
DEF M.HOME AS 1
DEF M.CPARW AS 2



GLOBAL TABLE ERRTAB(1:20)['$ENTRY COMPLETED','NAME ALLREADY IN LUD',&
   'NAME NOT IN LUD','NAME ALLREADY IN DUL','NAME NOT IN DUL',&
   'NAME ALLREADY IN MUD','NAME NOT IN MUD','STR ALLREADY THERE',&
   'STR NOT FOUND','ILLEGAL SYSTEM NO.',&
   'ERROR IN BILLING FILE','FILE BUSY - TRY AGAIN',&
   'ERROR IN DELETING FILE OR UFD','BAD CODE','SIMPL ERROR',&
   'ILLEGAL NAME','BAD UUO','AUX. CIR. ERROR','MISC. MUD ERROR',&
   'MUD BUSY - TRY LATER']



DEF ACCT.SYS AS 31
DEF ACCT.SUP.BIT(A) AS BYT(A,1,13)
DEF ALPHA AS 0	!ARGUMENT FOR GETTOKEN - RETURN ALPHA VALUE
DEF C.IMGIO(A,B) AS [OP _ A; CHR _ B; IMGIO]
DEF CK.A.CIR AS [IF ACCT.CIR = NOT.THERE THEN [IF BLD.A.CIR = NOT.THERE THEN &
	GO GETCMD]]
DEF CK.M.CIR AS [IF MUD.CIR = NOT.THERE THEN [IF BLD.M.CIR = NOT.THERE THEN &
	GO GETCMD]]
DEF CK.NAME AS [IF FOUND # THERE THEN ERROR(NAME.NT.LUD);&
   IF MUDUP(GET.M) # THERE THEN ERROR(NAME.NT.MUD)]
DEF CPARW.CHG AS [M.KIND _ CH.PRIV; CT+_3; SEND.CT.AND.NAME;&
   SEND.M.EOF; MUD.GOOD]
DEF CR AS CHR.OUT(CARRET)
DEF CUD10.PPN AS OCT 1042313
DEF D.BLK.UP AS [LOKUP.DUL(IN.UPDATE); SETCP(CH.DUL,FIXCP(D.LOC));&
	RB(CH.DUL,SIZE.BLK,D.BLK); SETCP(CH.DUL,FIXCP(D.LOC))]
DEF DIST.BITS AS BYT(LUD(WD.DIST),8,0)
DEF DSKB AS 'DSKB'
DEF DUL(A) AS D.BLK(D.INDEX+A)
DEF DUL.OVER AS [D.OV.BLK.N_GET.D.OV.BLK; LOKUP.DUL(IN.READ);&
	SETCP(CH.DUL,FIXCP(D.OV.BLK.N)); DUL.READ; CLOSE(CH.DUL)]
DEF DUL.READ AS [RB(CH.DUL,SIZE.BLK,D.BLK); D.INDEX _ 0]
DEF DUL.WRIT AS [WB(CH.DUL,SIZE.BLK,D.BLK); CLOSE(CH.DUL)]
DEF EXCH.OLD.NEW.N AS [USER(0)<=>OLDNAME(0);USER(1)<=>OLDNAME(1)]
DEF FILL.IN.LUD.INF AS [MOVE SIZE.NEW.ENT FROM L.SAVE TO @LUD(WD.PPN);&
   MOVE SIZE.STR.INF FROM STRINF TO @LUD(WD.STRN)]
DEF FIND.NAME AS [GET.T.NAME; IF FOUND _ LUD.LOOK = THERE &
   THEN MOVE SIZE.LUD.ENT FROM @LUD(WD.PPN) TO L.SAVE]
DEF FIND.D.ROOM AS IF D.INDEX+SIZE.DUL.ENT>=SIZE.BLK THEN MAKE.D.OVER
DEF FIRSTOF24(A) AS BYT(A,1,23)
DEF FIXCP(A) AS (A-1)*SIZE.BLK
DEF G.CIR.NUM AS [P1 _ BYPT(NUMBER,24,8); NUMBER _ 0;&
   REPEAT 3 C.IMGIO(RECEIVE,NCHV P1)]
DEF G.CIR.WD(A,B) AS [P1 _ CHPT(A,-1); REPEAT B IMGIO(RECEIVE,P1)]
DEF GET.C.NAME AS [IF TTYF = CIR THEN G.CIR.WD(USER,12); FOUND_LUD.LOOK]
DEF GET.DIST AS [MSG('DISTRICT: '); DIST _ GETNUM]
DEF GET.D.OV.BLK AS HW(@DUL(WD.PPN),1)
DEF GET.GAN AS [MSG('GAN: '); GAN _ HW(@L.SAVE(WD.PPN),0)_GETOCT]
DEF GET.L.OV.BLK AS HW(@LUD(WD.PPN),1)
DEF GET.NEW AS MSG('NEW ')
DEF GET.NUM.INF(A) AS [IF TTYF # CIR THEN [MSG(A); GETNUM] &
   ELSE G.CIR.NUM]
DEF GET.H.SITE AS [MSG('$HOME SYSTEM: '); IF MAX.SITE<H.SYS_GETNUM&
   <1 OR 19<H.SYS<24 OR 24<H.SYS<30 THEN ERROR(BAD.SITE)]
DEF GET.PASS AS [CLOSE.ALL; PASS.IN; CH.OUT_OPEN('TEL',SEQUEN+&
   OUTPUT+CHARACTER,0,2)]
DEF GET.T.NAME AS [MSG('USER NAME: '); GETTOKEN(ALPHA);&
	MAKE.SIXBIT(TOKEN,USER,12)]
DEF HIGH.UFD.INDEX AS 125
DEF INIT.BIT AS BYT(LUD(WD.INIT),1,8)
DEF IN.STR.PDP AS 'CUD10:31'
DEF IN.STR.940 AS 'CUD:*;'
DEF IN.VAL.DUL AS MAKE.DUL.CHG(MOVE 3 FROM ALL 0 TO @DUL(WD.PPN))
DEF MAKE.LUD.CHG(A) AS [L.BLK.UP; A; LUD.CL]
DEF IN.VAL.LUD AS [MAKE.LUD.CHG(LUD(WD.HASH) _ 0); MSG(TT.MSGS(LUD.REV))]
DEF L.BLK.UP AS [LOKUP.LUD(IN.UPDATE); SETCP(CH.LUD,FIXCP(LOC.HASH));&
   RB(CH.LUD,SIZE.BLK,L.BLK); SETCP(CH.LUD,FIXCP(LOC.HASH))]
DEF L.OV.BLK AS HW(@LUD(WD.PPN),1)
DEF LUD(A) AS L.BLK(L.INDEX+A)
DEF LUD.CL AS [LUD.WRIT; CLOSE(CH.LUD)]
DEF LUD.OVER AS [L.OV.BLK.N _ GET.L.OV.BLK; LOKUP.LUD(IN.READ);&
   SETCP(CH.LUD,FIXCP(L.OV.BLK.N)); LUD.READ; CLOSE(CH.LUD)]
DEF LUD.READ AS [RB(CH.LUD,SIZE.BLK,L.BLK); L.INDEX _ 0]
DEF LUD.WRIT AS WB(CH.LUD,SIZE.BLK,L.BLK)
DEF MAKE.CHG(A) AS [CHECK.OK; MAKE.LUD.CHG(A)]
DEF MAKE.DUL.CHG(A) AS [D.BLK.UP; A; DUL.WRIT]
DEF MAKE.VALID AS [MAKE.LUD.CHG(LUD(WD.HASH) _ NAME.HASH); MSG(TT.MSGS(LUD.REV))]
DEF MIN.CMD AS 1
DEF MAX.CMD AS 12
DEF MAX.SITE AS 33
DEF MODE.BITS(A) AS BYT(A,2,7)
DEF M.EOF AS OCT 40
DEF MUD.GOOD AS [GET.CIR(MUD.CIR,1); IF ANS = 0 THEN &
   [MSG(TT.MSGS(MUD.OK)); RETURN]]
DEF NAME.OUT(A) AS [P1 _ BYPT(A,1,6); REPEAT 12 CHR.OUT(NCHV P1 + &
   OCT 40); CR]
DEF N.DUL.BLKS AS SIZE(CH.DUL)/SIZE.BLK
DEF NINE40WD AS 2
DEF N.LUD.BLKS AS SIZE(CH.LUD)/SIZE.BLK
DEF NO AS 0
DEF NOT.THERE AS 0
DEF NUM AS 1
DEF PPN.OUT AS [OUT('$PPN: '); OCT.WD.OUT(@LUD(WD.PPN))]
DEF OCT.WD.OUT(A) AS [OCTOUT(HW(A),0); CHR.OUT($,); OCTOUT(HW(A),1)]
DEF OV.BIT AS OCT 400000
DEF OV.L.BIT AS HW(@LUD(WD.PPN),0)
DEF OV.D.BIT AS HW(@DUL(WD.PPN),0)
DEF IN.READ AS 0
DEF RESTORE AS [NAME.HASH_OLD.HASH; LOC.HASH_LOC.OLD.HASH;&
	L.INDEX_L.OLD.INDEX]
DEF RUB.BIT AS BYT(LUD(WD.RUB),1,33)
DEF SAVE.OLD AS [O.ENT.SIZE_SIZE.LUD.ENT; L.OLD.INDEX_L.INDEX+&
	LOC.OLD.HASH_LOC.HASH; OLD.HASH_NAME.HASH]
DEF SEND.ACT(A,B,C) AS SEND.CIR(A,B,C,ACCT.CIR)
DEF SEND.CT.AND.NAME AS [SEND.MUD(@CT,1); SEND.MUD(@M.KIND,1);&
   SEND.MUD(C.USER,9)]
DEF SEND.M.EOF AS SEND.MUD(M.EOF,1)
DEF SEND.MUD(A,B) AS SEND.CIR(NINE40WD,A,B,MUD.CIR)
DEF SEND.SYS.AND.NAME AS [TMP_THIS.SYS; SEND.ACT(NUM,TMP,1);&
   SEND.ACT(ALPHA,USER,12)]
DEF SET.RUB AS RUB _ QUERY('$SET RESTRICTED USE BIT')
DEF SET.SITE AS [HW(@EXTARG(IOTAB),0) _ SITE.31.NAME;&
   SITBYT _ SITBYT + SITE - 31]
DEF SITBYT AS BYT(EXTARG(IOTAB),6,24)
DEF SIX.B(A) AS A-OCT 40
DEF SIZE.BLK AS 128
DEF SIZE.DUL.ENT AS 3
DEF SIZE.NEW.ENT AS 8
DEF SIZE.INIT.INF AS 3
DEF SIZE.LUD.ENT AS BYT(LUD(WD.SIZE),7,0)
DEF SIZE.STR.INF AS 3
DEF SIZE.UFD.ENT AS 5
DEF TT.DIST.OUT AS [OUT('$2. DISTRICT: '); NUMOUT(L.SAVE(WD.DIST))]
DEF TT.HOME.OUT AS [OUT('$5. HOME SYSTEM: '); NUMOUT(H.SYS)]
DEF TT.PRIV.OUT AS [OUT('$3. PRIV: ');&
   IF ACCT.SUP.BIT(L.SAVE(WD.PRIV)) = THERE THEN OUT('ACCT. SUP');&
   IF TYMSH.BIT(L.SAVE(WD.PRIV)) = THERE THEN OUT('TYM');&
   OUT('$   MODE: '); OUT(@MODES(MODE.BITS(WD.PRIV)))]
DEF TT.RUB.OUT AS IF RUB.BIT = THERE THEN OUT('$6. RUB BIT SET') &
   ELSE OUT('$6. RUB BIT NOT SET')
DEF TT.STR.OUT AS [OUT('$4. STRUCTURE: ');P1 _ BYPT(L.SAVE(WD.STRN),1,6);&
   REPEAT 4 CHR.OUT(NCHV P1 + OCT 40);&
   OUT('$   QUOTA IN: '); NUMOUT(L.SAVE(WD.QIN));&
   OUT('$   QUOTA OUT: '); NUMOUT(L.SAVE(WD.QOUT))]
DEF TT.USER.OUT AS [OUT('$1. USER NAME: '); NAME.OUT(USER)]
DEF THERE AS 1
DEF TYMSH.BIT(A) AS BYT(A,1,14)
DEF UFD.READ AS [RB(CH.UFD,SIZE.BLK,UFD.BLK); INDEX _ 0]
DEF IN.UPDATE AS 1
DEF VERSION AS 1
DEF WHAT AS [MSG('$?$'); GO GETCMD]
DEF YES AS 1

!ERRORS
DEF OK AS 1
DEF NAME.IN.LUD AS 2
DEF NAME.NT.LUD AS 3
DEF NAME.IN.DUL AS 4
DEF NAME.NT.DUL AS 5
DEF NAME.IN.MUD AS 6
DEF NAME.NT.MUD AS 7
DEF STR.THERE AS 8
DEF STR.NT.THERE AS 9
DEF BAD.SITE AS 10
DEF BILL.FILE.ERR AS 11
DEF FILE.BUSY AS 12
DEF DEL.ERR AS 13
DEF BAD.CODE AS 14
DEF SIMPL.ERR AS 15
DEF BAD.NAME AS 16
DEF BAD.UUO AS 17
DEF AUX.ERR AS 18
DEF MUD.ERR AS 19
DEF MUD.BUSY AS 20

!TATTLE TALE FILES MESSAGES
DEF MUD.OK AS 1
DEF MUD.REV AS 2
DEF LUD.OK AS 3
DEF LUD.REV AS 4

TABLE TT.MSGS(1:4)['MUD ENTRY MADE','MUD ENTRY REVERESED',&
   'LUD ENTRY MADE','LUD ENTRY REVERESED']



START: GO FROMCIR	!START HERE IF FROM A CIRCUIT

FROMTTY: TTYF _ 1; INITUPD; GO GETCMD	!HERE IF FROM TTY - SET TTYF
\\->FROMTTY

FROMCIR: TTYF _ CIR; INITUPD; LOOP RETURN O.LUDUPD(OTHER.L.D)

GETCMD: N.OFFICIAL _ IN.VAL.UF _ NEW.USERF _ 0
MSG('$*'); P _ GETLINE(TEL); GETTOKEN(ALPHA)
   IF CMD _ CHOOSE(N.I.CMDS,INT.CMDS) = NOT.THERE THEN WHAT
DISP: DO CMD OF 1:N.I.CMDS

HELP: LISTABLE(N.U.CMDS,U.CMDS)

GET: CK.M.CIR; GET.T.NAME
   IF MUDUP(GET.M) # THERE THEN ERROR(NAME.NT.MUD)
   MSG('$GAN: '); OCTOUT(BYT(MUD(M.GAN),20,0))
   MSG('$UUN: '); OCTOUT(BYT(MUD(M.UUN),17,0))
   MSG('$DISTRICT: '); NUMOUT(BYT(MUD(M.CPARW),9,0))
   MSG('$HOME SYS: '); NUMOUT(BYT(MUD(M.HOME),7,23))

CHECK: CK.M.CIR; GET.T.NAME
   IF MUDUP(CHECK) = THERE THEN ERROR(NAME.IN.MUD) ELSE &
	ERROR(NAME.NT.MUD)


LIST: GETTOKEN(ALPHA)
   IF TMP _ CHOOSE(N.LISTS,L.CMDS) = NOT.THERE THEN WHAT
   EIF TMP = L.USER THEN DO
	FIND.NAME
	CK.NAME
	PPN.OUT
	MSG('$DISTRICT: '); NUMOUT(LUD(WD.DIST))
	MSG('$PRIV: ')
	   IF ACCT.SUP.BIT(LUD(WD.PRIV)) = THERE THEN MSG('ACCT. SUP ')
	   IF TYMSH.BIT(LUD(WD.PRIV)) = THERE THEN MSG('TYM')
	MSG('$MODE: '); MSG(@MODES(MODE.BITS(WD.PRIV)))
	INDEX _ WD.STRN; TMP _ 0
	   IF INIT.BIT = 1 THEN [INDEX+_SIZE.INIT.INF; TMP_SIZE.INIT.INF]
	   TMP _ ((SIZE.LUD.ENT-TMP)-WD.STRN)/SIZE.STR.INF
	   REPEAT TMP DO
		MSG('STRUCTURE: ')
		P1 _ BYPT(L.BLK+L.INDEX+INDEX,1,6)
		REPEAT 4 CHR.OUT(NCHV P1 + OCT 40)
		MSG('$QUOTA IN: '); NUMOUT(LUD(INDEX+1))
		MSG('$QUOTA OUT: '); NUMOUT(LUD(INDEX+2))
	   END
   END
   ORIF TMP = L.PROJECT THEN DO
	GET.GAN
	IO.ADR _ GETCMD
	LOKUP.LUD(IN.READ); LUD.READ
	LOOP DO
	   LUD.SEQ
	   IF HW(@LUD(WD.PPN),0) = GAN THEN DO
		IF DUL.LOOK = THERE THEN NAME.OUT(D.BLK+D.INDEX+WD.NAME)
	   END
	END
   END
ELSE WHAT

QUIT: EXIT

REMOVE: IN.VAL.UF _ U.REMOVE; GO DELETE.U

DELETE.U: INVALIDATE:  CK.A.CIR; CK.M.CIR
   FIND.NAME
   CK.NAME
   IF LUD(WD.PPN) = OCT 1000001 OR LUD(WD.PPN) = OCT 1000004 THEN ERROR(BAD.NAME)
   CHECK.OK
   MAKE.LUD.CHG(LUD(WD.HASH) _ 0)
   DEL.FILES
   IF THIS.SYS # ACCT.SYS THEN DO
	SEND.ACT(NUM,DEL.USR,1)
	SEND.SYS.AND.NAME
	GET.CIR(ACCT.CIR,1)
   END ELSE ANS(0) _ O.LUDUPD(DEL.USR)
   IF ANS(0) = OK THEN DO
	BILL.USER(DEL.USR)
	IF INVAL.UF = U.CANCEL THEN DO
	   IF MUD(DEL.USR) # OK THEN DO
		MAKE.VALID
		IF THIS.SYS # ACCT.SYS THEN SEND.ACT(NUM,REVERSE,1) &
		   ELSE O.LUDUPD(REVERSE)
	   END
	END
   END ELSE MAKE.VALID
    ERROR(ANS)

ADD: NEW.USERF _ ADD.U;GO VALUSER

VALIDATE: VALUSER: CK.A.CIR; CK.M.CIR
   FIND.NAME
   IF FOUND # THERE THEN ERROR(NAME.IN.LUD)
   IF TMP _ MUDUP(GET.M) = NOT.THERE THEN DO
	IF NEW.USERF = ADD.U THEN ERROR(NAME.NT.MUD)
   END ELSE IF NEW.USERF = NEW.U THEN ERROR(NAME.IN.MUD)
   L.SAVE(WD.HASH) _ NAME.HASH
   IF TMP = NOT.THERE THEN DO
	GET.GAN
	MSG('UUN: '); UUN _ HW(@L.SAVE(WD.PPN),1) _ GETOCT
	GET.DIST; BYT(L.SAVE(WD.DIST),8,0) _ DIST
	GET.P.BITS; L.SAVE(WD.PRIV) _ PRIV
   END ELSE DO
	GAN _ HW(@L.SAVE(WD.PPN),0) _ BYT(MUD(M.GAN),20,0)
	UUN _ HW(@L.SAVE(WD.PPN),1) _ BYT(MUD(M.UUN),17,0)
	DIST _ BYT(L.SAVE(WD.DIST),8,0) _ BYT(MUD(M.CPARW),9,0) SHR 2
	ACCT.SUP.BIT(PRIV) _ BYT(MUD(M.CPARW),1,19)
	TYM.SH.BIT(PRIV) _ BYT(MUD(M.CPARW),1,23)
	GET.MODE
	L.SAVE(WD.PRIV) _ PRIV
   END
   BYT(L.SAVE(WD.SIZE),7,0) _ SIZE.NEW.ENT
   GET.STR.INF
   FILL.IN.LUD.INF
   CHECK.OK
   IF NEW.USERF = NEW.U THEN DO
	GET.PASS
	MUDUP(ADD.USR)
   END ELSE MUDUP(CH.COMMON)
   FIND.L.ROOM
   IF DUL.LOOK = THERE THEN DO
	IF NEW.USERF = NEW.U THEN MUDUP(DEL.USR)
	ERROR(NAME.IN.DUL)
   END
   MAKE.LUD.CHG(FILL.IN.LUD.INF)
   FIND.D.ROOM	
   MAKE.DUL.CHG(DUL(WD.PPN) _ LUD(WD.PPN); MOVE 2 FROM USER TO @DUL(WD.NAME))
   IF THIS.SYS # ACCT.SYS THEN DO
	SEND.ACT(NUM,ADD.USR,1)
	SEND.SYS.AND.NAME
	SEND.ACT(NUM,GAN,3)
	SEND.ACT(NUM,UUN,3)
	SEND.ACT(NUM,DIST,1)
	SEND.ACT(NUM,PRIV,3)
	SEND.ACT(NUM,STRINF+1,3)
	SEND.ACT(NUM,STRINF+2,3)
	GET.CIR(ACCT.CIR,1)
   END ELSE ANS(0) _ O.LUDUPD(ADD.USR)
   IF ANS # OK THEN DO
	IF NEW.USERF = NEW.U THEN MUDUP(DEL.USR)
	IN.VAL.DUL
	IN.VAL.LUD
   END ELSE BILL.USER(ADD.USR)
   ERROR(ANS)

CHANGE: GETTOKEN(ALPHA)
   IF CHG _ CHOOSE(MAX.N.CHANGES,CH.CMDS) = 0 THEN WHAT
   DO CHG OF 1:MAX.N.CHANGES

CH.HOME: CK.M.CIR; GET.T.NAME
   IF MUDUP(GET.M) # THERE THEN ERROR(NAME.NT.MUD)
   GET.NEW; GET.H.SITE
   CHECK.OK; MUDUP(CH.HOME)

CH.PASS: CK.M.CIR; GET.T.NAME
   IF MUDUP(GET.M) # THERE THEN ERROR(NAME.NT.MUD)
   GET.NEW; GET.PASS
    MUDUP(CH.PASSW)

CH.PRIV: CK.M.CIR; CK.A.CIR
   FIND.NAME
   CK.NAME
   GET.P.BITS
   MAKE.CHG(LUD(WD.PRIV) _ PRIV)
   MUDUP(CH.PRIV)
   IF THIS.SYS = ACCT.SYS THEN DO
	SEND.ACT(NUM,CH.PRIV,1)
	SEND.SYS.AND.NAME
	SEND.ACT(NUM,PRIV,3)
	GET.CIR(ACCT.CIR,1)
   END ELSE ANS(0) _ O.LUDUPD(CH.PRIV)
   ERROR(ANS)

CH.STR: CK.A.CIR; FIND.NAME
   IF FOUND # THERE THEN ERROR(NAME.NT.LUD)
   STR.INF(WD.STRN) _ DSKB
   IF FIND.STR # THERE THEN ERROR(STR.NT.THERE)
	GET.STR.INF
	MAKE.CHG(MOVE SIZE.STR.INF FROM STRINF TO @LUD(INDEX))
   IF THIS.SYS = ACCT.SYS THEN DO
	SEND.ACT(NUM,CH.STR,1)
	SEND.SYS.AND.NAME
	SEND.ACT(NUM,STRINF+1,3)
	SEND.ACT(NUM,STRINF+2,3)
	GET.CIR(ACCT.CIR,1)
   END ELSE ANS(0) _ O.LUDUPD(CH.STR)
   ERROR(ANS)

CH.DIST: CK.M.CIR; CK.A.CIR;  FIND.NAME
   CK.NAME
   GET.NEW
   GET.DIST
   MAKE.CHG(DIST.BITS _ DIST)
   MUDUP(CH.DIST)
   IF THIS.SYS = ACCT.SYS THEN DO
	SEND.ACT(NUM,CH.DIST,1)
	SEND.SYS.AND.NAME
	SEND.ACT(NUM,DIST,1)
	GET.CIR(ACCT.CIR,1)
   END ELSE ANS(0) _ O.LUDUPD(CH.DIST)
   IF ANS # OK THEN DO
	MUDUP(REVERSE)
	MAKE.LUD.CHG(DIST.BITS _ BYT(L.SAVE(WD.DIST),8,0))
   END
   ERROR(ANS)

CH.RUB: CK.A.CIR; FIND.NAME
   IF FOUND # THERE THEN  ERROR(NAME.NT.LUD)
   SET.RUB
   MAKE.CHG(RUB.BIT _ RUB)
   IF THIS.SYS = ACCT.SYS THEN DO
	SEND.ACT(NUM,CH.RUB,1)
	SEND.SYS.AND.NAME
	SEND.ACT(NUM,RUB,1)
	GET.CIR(ACCT.CIR,1)
   END ELSE ANS(0) _ O.LUDUPD(CH.RUB)
   IF ANS # OK THEN MAKE.LUD.CHG(RUB.BIT_BYT(L.SAVE(WD.RUB),1,33))
   ERROR(ANS)

CH.NAME: FIND.NAME
   CK.NAME
   MOVE 2 FROM USER TO OLDNAME
   GET.NEW; GET.T.NAME; GET.PASS
   MAKE.CHG(LUD(WD.HASH) _ 0)
   SAVE.OLD
   IF LUD.LOOK = THERE THEN DO
	RESTORE
	MAKE.VALID
	ERROR(NAME.IN.LUD)
   END
   FIND.L.ROOM
   LUD(WD.PPN) _ L.SAVE(WD.PPN)
   EXCH.OLD.NEW.N
   IF DUL.LOOK = NOT.THERE THEN DO
	RESTORE
	MAKE.VALID
	ERROR(NAME.NT.DUL)
   END
   EXCH.OLD.NEW.N
   MAKE.DUL.CHG(MOVE 2 FROM USER TO @DUL(WD.NAME))
   MAKE.LUD.CHG(MOVE O.ENT.SIZE FROM L.SAVE TO @LUD(WD.PPN))
   IF THIS.SYS = ACCT.SYS THEN DO
	SEND.ACT(NUM,CH.NAME,1)
	SEND.ACT(ALPHA,OLDNAME,12)
	SEND.ACT(NUM,THISSYS,1)
	SEND.ACT(ALPHA,USER,12)
	GET.CIR(ACCT.CIR,1)
   END ELSE ANS(0) _ O.LUDUPD(CH.NAME)
   IF ANS # OK THEN DO
	IN.VAL.LUD
	RESTORE
	MAKE.VALID
	MAKE.DUL.CHG(MOVE 2 FROM OLD.NAME TO @DUL(WD.NAME))
   END ELSE [BILL.USER(CH.NAME); MUDUP(CH.NAME)]
   ERROR(ANS)

END
END
GO GETCMD

BAD.CHR: WHAT




%INITUPD
LOCAL TENS,ONES
IOCS(2)
!IF EXU(OCT 47,0,OCT 24,0) # CUD10.PPN THEN EXIT
!SET THIS.LIC
THIS.SYS _ 31	!LATER, SET SITE HERE
IF TTYF # CIR THEN DO
   INITTTY(BAD.CHR)
   CH.OUT _ OPEN('TEL', SEQUEN+OUTPUT+CHARACTER,0,2)
   MOVE 72/CHARS.PER.WORD FROM ALL 0 TO TOKEN
   MSG('$LUD UPDATER - VERSION ; DATOUT'); NUMOUT(VERSION)
   DATE _ EXU(OCT 47,OCT 1,OCT 14)
   [TMP;DAY] _ DATE DIVMOD 31
   [TENS;ONES] _ DATE DIVMOD 10
   TT.EXT _ (TENS + $0 SHL 6) BAND ONES + $0
   P1 _ CHPT('(NICRAM)TTFILE',-1)
	SETFID(IOTAB,@P1,0,CHKERR)
	TTFNAME _ NAMARG(IOTAB)
   BLD.M.CIR
   BLD.A.CIR
END ELSE DO
   C.IMGIO(SET.UP.TTY,0)
   FOR TMP _ 1 TO 4 C.IMGIO(SEND,TMP)
   TMP _ 0
   WHILE INC TMPTHEN DO
	C.IMGIO(RECEIVE,0)
	IF CHR # TMP THEN TMP _ 0
   END
END
P1 _ CHPT('(CUD10)LUD.31',-1)
   SETFID(IOTAB,@P1,0,CHK.ERR)
   LUD.NAME _ NAMARG(IOTAB)
   SITE.31.NAME _ HW(@EXTARG(IOTAB),0)
P1 _ CHPT('(CUD10)DUL.UFD',-1)
   SETFID(IOTAB,@P1,0,CHKERR)
   DUL.NAME _ NAMARG(IOTAB)
   UFD _ HW(@EXTARG(IOTAB),0)
INDEX _ D.LOC _ D.OV.BLK.N _ TMP _ CODE _ OLD.NAME(0) _ 0
OLD.NAME(1) _ L.OLD.INDEX _ LOC.OLD.HASH _ O.ENT.SIZE _ OLD.HASH _ 0
FOUND _ N.OFFICIAL _ SITE _ 0
RETURN
END INIT.UPD



%O.LUDUPD(CODE)	!UPDATE NON STANDARD LUD/DUL
LOCAL SITE
N.OFFICIAL _ 1
IF TTYF = CIR THEN DO 
   G.CIR.NUM; CODE _ NUMBER
   G.CIR.NUM; SITE _ NUMBER
   GET.C.NAME
END ELSE SITE _ ACCT.SYS
DO CODE OF MIN.CMD: MAX.CMD

DEL.USR: IF FOUND # THERE THEN RETURN NAME.NT.LUD
   MAKE.LUD.CHG(LUD(WD.HASH) _ 0)

CH.PRIV: IF FOUND # THERE THEN RETURN NAME.NT.LUD
   IF TTYF = CIR THEN [G.CIR.NUM; PRIV _ NUMBER]
   MAKE.LUD.CHG(LUD(WD.PRIV) _ PRIV)

CH.STR:  IF FOUND # THERE THEN RETURN NAME.NT.LUD
   STRINF(WD.STRN) _ DSKB
   IF FIND.STR # THERE THEN RETURN STR.NT.THERE
   IF TTYF = CIR THEN GET.STR.INF
   MAKE.LUD.CHG(MOVE SIZE.STR.INF FROM STRINF TO @LUD(INDEX))

CH.DIST: IF FOUND # THERE THEN RETURN NAME.NT.LUD
   IF TTY = CIR THEN [C.IMGIO(RECEIVE,0); DIST _ NUMBER]
   MAKE.LUD.CHG(DIST.BITS _ DIST)

CH.RUB: IF FOUND # THERE THEN RETURN NAME.NT.LUD
   IF TTY = CIR THEN [C.IMGIO(RECEIVE,0); RUB _ NUMBER]
   MAKE.LUD.CHG(RUB.BIT _ RUB)

ADD.USR: IF FOUND = THERE THEN RETURN NAME.IN.LUD
   FIND.L.ROOM
   IF TTYF = CIR THEN DO
	L.SAVE(WD.HASH) _ NAME.HASH
	G.CIR.NUM; HW(@L.SAVE(WD.PPN),0) _ NUMBER
	G.CIR.NUM; HW(@L.SAVE(WD.PPN),1) _ NUMBER
	BYT(L.SAVE(WD.SIZE),7,0) _ SIZE.NEW.ENT
	GET.DIST; BYT(L.SAVE(WD.DIST),8,0) _ DIST
	GET.P.BITS; L.SAVE(WD.PRIV) _ PRIV
	GET.STR.INF
    END
   MAKE.LUD.CHG(MOVE SIZE.NEW.ENT FROM L.SAVE TO @LUD(WD.PPN);&
	MOVE SIZE.STR.INF FROM STRINF TO @LUD(WD.STRN))
   IF DUL.LOOK = THERE THEN [IN.VAL.LUD; RETURN NAME.IN.DUL]
   FIND.D.ROOM
   MAKE.DUL.CHG(MOVE 2 FROM USER TO @DUL(WD.NAME); DUL(WD.PPN) _ LUD(WD.PPN))

CH.NAME: IF TTYF = CIR THEN [OLDNAME(0) _ USER(0); &
	OLDNAME(1) _ USER(1)]
   IF FOUND _ LUD.LOOK = THERE THEN RETURN NAME.IN.LUD
   IF TTYF = CIR THEN DO
	G.CIR.WD(USER,12)
	SAVE.OLD
   END
   MAKE.LUD.CHG(LUD(WD.HASH) _ 0)
   IF LUD.LOOK = THERE THEN DO
	RESTORE
	MAKE.VALID
	RETURN NAME.IN.LUD
   END
   FIND.L.ROOM
   LUD(WD.PPN) _ L.SAVE(WD.PPN)
   EXCH.OLD.NEW.N
   IF DUL.LOOK # THERE THEN DO
	RESTORE
	MAKE.VALID
	RETURN NAME.NT.DUL
   END
   EXCH.OLD.NEW.N
   MAKE.DUL.CHG(MOVE 2 FROM USER TO @DUL(WD.NAME))
   MAKE.LUD.CHG(MOVE O.ENT.SIZE FROM L.SAVE TO @LUD(WD.PPN))
END
RETURN OK
END  O.LUDUPD


%LOKUP.LUD(MODE)
	!MODE = READ OR UPDATE
IF N.OFFICIAL = 0 THEN DO
   IF MODE = IN.READ THEN CH.LUD _ OPEN('(NICRAM)LUD.SYS',DIRECT+INPUT+WORD,CHK.ERR)&
	ELSE CH.LUD _ OPEN('(NICRAM)LUD.SYS',DIRECT+UPDATE+WORD,CHK.ERR)
END ELSE DO
   NAMARG(IOTAB) _ LUD.NAME
   SET.SITE
   IF MODE = IN.READ THEN CH.LUD _ OPEN(-IOTAB,DIRECT+INPUT+WORD,CHK.ERR)&
	ELSE CH.LUD _ OPEN(-IOTAB,DIRECT+UPDATE+WORD,CHK.ERR)
END
SIZE.LUD _ N.LUD.BLKS
RETURN
END LOKUP.LUD


%LOKUP.DUL(MODE)
IF N.OFFICIAL = 0 THEN DO
IF MODE = IN.READ THEN CH.DUL _ OPEN('(NICRAM)DUL.SYS',DIRECT+INPUT+WORD,CHK.ERR)&
	ELSE CH.DUL _ OPEN('(NICRAM)DUL.SYS',DIRECT+UPDATE+WORD,CHK.ERR)
END ELSE DO
   NAMARG(IOTAB) _ DUL.NAME
   SET.SITE
   IF MODE = IN.READ THEN CH.DUL _ OPEN(-IOTAB,DIRECT+INPUT+WORD,CHK.ERR)&
	ELSE CH.DUL _ OPEN(-IOTAB,DIRECT+UPDATE+WORD,CHK.ERR)
END
SIZE.DUL _ N.DUL.BLKS
RETURN
END LOKUP.DUL


%LUD.LOOK
	!LOOKUP USER,USER+1 IN LUD
HASH(USER(0),USER(1)); L.OV.BLK.N _ 0
LOKUP.LUD(IN.READ)
SETCP(CH.LUD,FIXCP(LOC.HASH)); LUD.READ; CLOSE(CH.LUD)
WHILE LUD(WD.HASH) # NAME.HASH THEN DO
   EIF LUD(WD.PPN) = 0 THEN RETURN NOT.THERE
   ORIF LUD(WD.PPN) < 0 THEN LUD.OVER
   ELSE L.INDEX + _ SIZE.LUD.ENT
END
RETURN THERE
END LUD.LOOK



%DUL.LOOK
D.LOC _ LUD(WD.PPN) MOD 101 + 1
D.OV.BLK.N _ 0
LOKUP.DUL(IN.READ)
SETCP(CH.DUL,FIXCP(D.LOC))
DUL.READ; CLOSE(CH.DUL)
WHILE DUL(WD.PPN) # LUD(WD.PPN) THEN DO
   IF DUL(WD.PPN) = 0 THEN RETURN NOT.THERE
   IF DUL(WD.PPN) < 0 THEN DUL.OVER
   D.INDEX + _ SIZE.DUL.ENT
END
RETURN THERE
END DUL.LOOK


%CHK.IO.ERR
CHK.ERR: IF ERRNUM = EOFERR AND IO.ADR # 0 THEN GO ^IO.ADR
   IF TTYF = CIR THEN ERROR(SIMPL.ERR)
   MSG('$ERROR ON '); WFID(FIDP); CR
   DO ERRNUM OF TMFERR:CORERR
TMFERR: MSG('TOO MANY FILES OPEN')
FMDERR: MSG('BAD FILE MODE OR TYPE')
IFDERR: MSG('ILLEGAL FILE ID')
FNFERR: MSG('FILE NOT FOUND')
IUSERR: MSG('INVALID USER NAME')
PRTERR: MSG('PROTECTION FAILURE')
EOFERR: MSG('END OF FILE')
   END
   MSG('.$ ERROR '); NUMOUT(ERRNUM); ERROR(SIMPL.ERR); EXIT
END CHK.IO.ERR


%T.ERROR(A)
OUT(ERRTAB(A)); CR
CLOSE(CH.OUT)
CH.OUT _ OPEN('TEL',SEQUEN+OUTPUT+CHARACTER,0,2)
ERROR(A)
RETURN
END T.ERROR


%ERROR(NUMB)
IF TTYF = CIR THEN DO
   C.IMGIO(SEND,NUMB)
   IF NUMB = BAD.CODE THEN C.IMGIO(SEND,CODE)
   IF NUMB = SIMPL.ERR THEN C.IMGIO(SEND,ERRNUM)
   EXIT
END ELSE DO
   OUT(ERRTAB(NUMB)); CR
   GO GETCMD
END
END ERROR


%LUD.SEQ
LOOP DO
   L.INDEX + _ SIZE.LUD.ENT
   IF LUD(WD.PPN) < 0 THEN LUD.OVER
   WHILE LUD(WD.PPN) <= 0 THEN LUD.READ
   IF LUD(WD.HASH) # 0 THEN RETURN
END
END LUD.SEQ


%FIND.STR
!FIND STR IN STRINF IN LUD,
!IF FOUND, LOC IN INDEX UPDON RETURN
INDEX _ WD.STRN
WHILE LUD(INDEX) # STRINF(WD.S.NAME) THEN DO
   INDEX + _ SIZE.STR.INF
   IF INDEX >=SIZE.LUD.ENT THEN RETURN NOT.THERE
END
RETURN THERE
END FIND.STR


%FIND.L.ROOM
!MAKE ROOM FOR NEW ENTRY (SIZE.NEW.ENT WDS)
!CREATE OVERFLOW IF NECESSARY
L.INDEX _ 0
LOOP DO
   EIF LUD(WD.PPN) = 0 THEN DO
	IF L.INDEX + SIZE.NEW.ENT <= SIZE.BLK-1 THEN RETURN
	MAKE.L.OVER; RETURN
     END
   ORIF LUD(WD.PPN) < 0 THEN LUD.OVER
   ORIF LUD(WD.HASH) = 0 THEN DO
	IF SIZE.LUD.ENT = SIZE.NEW.ENT THEN RETURN
	MOVE SIZE.BLK-(L.INDEX+SIZE.LUD.ENT) FROM @LUD(SIZE.LUD.ENT)&
	TO @LUD(SIZE.LUD.ENT-SIZE.NEW.ENT)
	RETURN
     END
   ELSE L.INDEX+_SIZE.LUD.ENT
END
END FIND.L.ROOM


%MAKE.L.OVER
L.BLK.UP
SIZE.LUD _ GET.L.OV.BLK _ L.OV.BLK.N _ SIZE.LUD + 1
OV.L.BIT _ OV.BIT; LUD.CL
MOVE SIZE.BLK FROM ALL 0 TO @LUD(WD.PPN)
LOKUP.LUD(IN.UPDATE)
SETCP(CH.LUD,FIXCP(SIZE.LUD))
LUD.CL
L.INDEX _ 0
RETURN
END MAKE.L.OVER


%MAKE.D.OVER
D.BLK.UP; SIZE.DUL _ GET.D.OV.BLK _ D.OV.BLK.N _ SIZE.DUL + 1
OV.D.BIT _ OV.BIT; DUL.WRIT
MOVE SIZE.BLK FROM ALL 0 TO @DUL(WD.PPN)
LOKUP.DUL(IN.UPDATE); SETCP(CH.DUL,FIXCP(SIZE.DUL))
DUL.WRIT
D.INDEX _ 0
RETURN
END MAKE.D.OVER



%DELFILES
LOCAL CH.UFD, UFDBLK(SIZE.BLK)
LOCAL  HIGHJOB, ACC, USR.TAB(WPF)
ERRNUM _ 0
ACC _ OCT 20000012
HIGHJOB _ CALL.UUO(ACC)
WHILE DEC HIGH.JOB >= 0 THEN DO
   HW(ACC,0) _ HIGHJOB + 1; HW(ACC,1) _ 2
   IF CALL.UUO(ACC) = LUD(WD.PPN) THEN T.ERROR(DEL.ERR)
END
PPNARG(IOTAB) _ OCT 1000001; NAMARG(IOTAB) _ LUD(WD.PPN)
EXTARG(IOTAB) _ UFD
CH.UFD _ OPEN(-IOTAB,DIRECT+INPUT+WORD,CHK.ERR)
PPNARG(IOTAB) _ LUD(WD.PPN)
UFD.READ
WHILE NAMARG(USR.TAB) _ UFD.BLK(INDEX) # 0 THEN DO
   IF INDEX >= HIGH.UFD.INDEX THEN UFD.READ ELSE DO
	HW(@EXTARG(USR.TAB),0) _ HW(@UFD.BLK(INDEX+1),0)
	DELETE(-USR.TAB,CHK.ERR)
	INDEX + _ SIZE.UFD.ENT
    END
END
END.UFD: DELETE(-IOTAB,CHK.ERR)
IF TTYF = CIR THEN DO
   C.IMGIO(SEND,1)
   SEND.O.WD('$PPN: ',^L.BLK+L.INDEX+WD.PPN)
END
RETURN
END DELFILES


%CALL.UUO(AC)
LOCAL DIDIT:
TMP _ EXU(OCT 47,AC,OCT 41,DIDIT)
ERROR(BAD.UUO)
DIDIT: RETURN TMP
END CALL.UUO



%GET.STR.INF
 STRINF(WD.STRN)_'DSKB'
GET.NUM.INF('QUOTA IN: '); STRINF(WD.QOUT) _ NUMBER
GET.NUM.INF('QUOTA OUT: '); STRINF(2) _ NUMBER
RETURN
END GET.STR.INF


%SEND.O.WD(A,B)
IF TTYF # CIR THEN DO
   MSG(A)
   OCTOUT(HW(B,0))
   CHR.OUT($,)
   OCTOUT(HW(B,1))
END ELSE DO
   TMP _ HW(B,0)
   C.IMGIO(SEND,TMP)
   TMP _ HW(B,1)
   C.IMGIO(SEND,TMP)
END
RETURN
END SEND.O.WD



%GET.P.BITS
IF TTYF = CIR THEN DO
   G.CIR.NUM
   PRIV _ NUMBER
   RETURN
END
PRIV _ 0
ACCT.SUP.BIT(PRIV) _ QUERY('ACCOUNT SUPERVISOR')
TYMSH.BIT(PRIV) _ QUERY('TYMSHARE')
GET.MODE
RETURN
END GET.P.BITS



%GET.MODE
LOCAL MODE
LOOP DO
	MSG('MODE: '); GETTOKEN(ALPHA)
	IF MODE _ CHOOSE(N.MODES,MODES) # 0 THEN DO
	  MODE.BITS(PRIV) _ MODE -1
	RETURN
END
MSG('$VALID MODES ARE: '); LISTABLE(N.MODES,MODES)
CR
END
END GET.MODE




%GET.CIR(CIRNUM,N)
LOCAL GOOD:
HW(TMP,0) _ CIRNUM; HW(TMP,1) _ 0
P1 _ BYPT(ANS,24,8)
REPEAT N MOD 3 NCHV P1
NCHV P1 _ EXU(OCT 42,TMP,ANS,GOOD)
   ERROR(AUX.ERR)
GOOD: RETURN
END GET.CIR



%BLD.M.CIR
IF MUD.CIR = THERE THEN RETURN THERE
STRING _ IN.STR.940
BUILD
IF MUD.CIR _ A.CHAN < 0 THEN ERROR(AUX.ERR)
TMP _ 1
REPEAT 2 SEND.MUD(TMP,1)
TMP _ OCT 40
SEND.MUD(TMP,1)
LOOP DO
   GET.CIR(MUD.CIR,1)
   IF ANS(0) = 1 THEN DO
	GET.CIR(MUD.CIR,1)
	IF ANS(0) = 1 THEN DO
	   GET.CIR(MUD.CIR,1)
	   IF ANS(0) = OCT 40 THEN RETURN
	END
   END
END
RETURN THERE
END BLD.M.CIR



%BLD.A.CIR
LOCAL CNT
IF ACCT.CIR = THERE THEN RETURN THERE
STRING _ IN.STR.PDP
BUILD
IF ACCT.CIR _ A.CHAN < 0 THEN ERROR(AUX.ERR)
SEND.ACT(ALPHA,'$GET TENUPD$ST$',16)
CNT _ 0
WHILE INC CNT < 5 THEN DO
   GET.CIR(ACCT.CIR,1)
   IF ANS # CNT THEN CNT _ 0
END
FOR CNT _ 1 TO 4 SEND.ACT(NUM,CNT,1)
RETURN THERE 
END BLD.A.CIR


%CHECK.OK
LOCAL TT.ERR:
LIST.INF(0)
IF QUERY('$ALL ENTRIES CORRECT') = NO THEN CHANGE.ENT
NAMARG(IOTAB) _ TT.F.NAME
EXTARG(IOTAB) _ TT.EXT
CH.OUT _ OPEN(-IOTAB,DIRECT+UPDATE+CHARACTER,TT.ERR)
WRIT.IT: DAT.OUT
	!OUTPUT NAME AND OPER NAME OF USER
LIST.INF(1)
RETURN
TT.ERR: IF ERRNUM # FNFERR THEN CHK.IO.ERR
CH.OUT _ OPEN(-IOTAB,DIRECT+OUTPUT+CHARACTER,CHK.ERR)
GO WRIT.IT
END CHECK.OK



%LIST.INF(TTF)	!TTF = 1 IF TO TATTLE TALE FILE, 0 IF TO TTY

DO CMD OF 1:N.I.CMDS

INVALIDATE: DDTREMOVE:  IF TTF # 0 THEN DO
 	IF CMD = REMOVE THEN OUT('$REMOVE PDP10') ELSE OUT('$CANCEL USER')
   END
   TT.USER.OUT

ADD: VALIDATE: IF TTF # 0 THEN DO
	IF CMD = ADD THEN OUT('$ADD PDP10') ELSE OUT('$NEW USER')
   END
   TT.USER.OUT
   TT.DIST.OUT
   TT.PRIV.OUT
   TT.STR.OUT
   IF TTF # 0 THEN PPN.OUT

CHANGE: DO CHG OF 1:MAX.N.CHANGES

CH.HOME: IF TTF # 0 THEN OUT('$CHANGE HOME')
   TT.USER.OUT
   TT.HOME.OUT

CH.PRIV: IF TTF # 0 THEN OUT('$CHANGE PRIVILIGES')
   TT.USER.OUT
   TT.PRIV.OUT

CH.STR: IF TTF = 0 THEN OUT('$CHANGE STRUCTURE')
   TT.USER.OUT
   TT.STR.OUT

CH.DIST: IF TTF = 0 THEN OUT('$CHANGE DISTRICT')
   TT.USER.OUT
   TT.DIST.OUT

CH.RUB: IF TTF = 0 THEN OUT('$CHANGE RUB BIT')
   TT.USER.OUT
   TT.RUB.OUT

CH.NAME: IF TTF = 0 THEN OUT('$CHANGE NAME')
   OUT('$1. OLD USER NAME: '); NAME.OUT(OLD.NAME)
   OUT('$7. NEW USER NAME: '); NAME.OUT(USER)

END
END
RETURN
END LIST.INF


%CHANGE.ENT
LOCAL T.CHG, ER.FLG
ER.FLG _ 0	!STAYS ZERO IF USER TYPED LEGAL #
LOOP DO
   MSG('$WHICH ENTRY DO YOU WANT TO CHANGE?')
   T.CHG _ GETNUM
   DO CMD OF 1:N.I.CMDS

REMOVE: INVALIDATE: GO GETCMD

ADD: VALIDATE: IF T.CHG < 6 THEN DO T.CHG OF 1:5
1: GO GETCMD
2: GET.DIST; BYT(L.SAVE(WD.DIST),8,0) _ DIST; TT.DIST.OUT
3: GET.P.BITS; L.SAVE(WD.PRIV) _ PRIV; TT.PRIV.OUT
4: GET.STR.INF; TT.STR.OUT
END ELSE INC ERFLG

CHANGE: DO CHG OF 1:MAX.N.CHANGES
CH.HOME: EIF T.CHG = 1 THEN GO GETCMD
   ORIF T.CHG = 5 THEN [GET.H.SITE; TT.HOME.OUT]
   ELSE INC ERFLG

CH.PRIV: EIF T.CHG = 1 THEN GO GETCMD
   ORIF T.CHG = 3 THEN [GET.P.BITS; L.SAVE(WD.PPN) _ PRIV; TT.PRIV.OUT]
   ELSE INC ERFLG

CH.STR: EIF T.CHG = 1 THEN GO GETCMD
   ORIF T.CHG = 4 THEN [GET.STR.INF; TT.STR.OUT]
   ELSE INC ERFLG

CH.DIST: EIF T.CHG = 1 THEN GO GETCMD
   ORIF T.CHG = 2 THEN [GET.DIST; BYT(L.SAVE(WD.DIST),8,0)_DIST;TT.DIST.OUT]
   ELSE INC ERFLG

CH.RUB: EIF T.CHG = 1 THEN GO GETCMD
   ORIF T.CHG = 6 THEN [SET.RUB; TT.RUB.OUT]
   ELSE INC ERFLG

CH.NAME: GO GETCMD
END
END
IF ERFLG = 0 THEN DO
	IF QUERY('$OKAY') = YES THEN DO
	   IF QUERY('$ANOTHER') = NO THEN RETURN
	END
   END
END
END CHANGE.ENT


%BILL.USER(KIND)
LOCAL CH.BILL,BILL.ERR:
TMP _ (KIND SHL 33) BAND DATE
CH.BILL _ OPEN('(NICRAM)LUDCHG.SYS',DIRECT+UPDATE+WORD,BILL.ERR)
SETCP(CH.BILL,SIZE(CH.BILL))
WRITE.BILL: W(CH.BILL,LUD(WD.PPN))
	W(CH.BILL,TMP)
	CLOSE(CH.BILL)
	RETURN
BILL.ERR: IF ERRNUM # FNFERR THEN CHK.IO.ERR
	CH.BILL _ OPEN('(NICRAM)LUDCHG.SYS',DIRECT+OUTPUT+WORD,CHK.ERR)
	GO WRITE.BILL
END BILL.USER



%MUDUP(KIND)
COMPRESS	!CONVERST NAME IN USER TO C.USER
CT _ 9
DO KIND OF DEL.USR:GET.M

DELETE.M:NULL
DEL.USR: M.KIND _ DEL.USR
   SEND.CT.AND.NAME
   MUD.GOOD

CH.PASSW: M.KIND _ CH.PASSW; CT+_6
   SEND.CT.AND.NAME
   SEND.MUD(PASSW,6)
   MUD.GOOD

ADD.USR: M.KIND _ ADD.USR; CT+_15
   SEND.MUD(@CT,1)
   SEND.MUD(@M.KIND,1)
   SEND.MUD(PASSW,6)
   SEND.MUD(L.SAVE(WD.PPN),6)
   MAKE.CPARW; SEND.MUD(CPARW,3)
   SEND.MUD(C.USER,9)
   MUD.GOOD

CH.NAME: M.KIND _ CH.NAME; CT+_9
   SEND.CT.AND.NAME
   EXCH.OLD.NEW.N
   COMPRESS
   SEND.MUD(C.USER,9)
   EXCH.OLD.NEW.N
   MUD.GOOD

GET.M: GET.MUD.DATA

CHECK: M.KIND _ CK.UNQE; SEND.CT.AND.NAME
   SEND.M.EOF
   GET.CIR(MUD.CIR,1)
   RETURN ANS

CH.COM: GET.MUD.DATA
   IF BYT(MUD(M.CPARW),1,6) = 1 THEN RETURN
   BYT(MUD(M.CPARW),1,6) _ 1
   CPARW.CHG

CH.PRIV: GET.MUD.DATA
   BYT(MUD(M.CPARW),1,19) _ ACCT.SUP.BIT(PRIV)
   BYT(MUD(M.CPARW),1,23) _ TYM.SH.BIT(PRIV)
   CPARW.CHG

END
IF ANS # 1 THEN ERROR(MUD.ERR)
GET.CIR(MUD.CIR,1)
EIF ANS = NIM THEN ERROR(NAME.NT.MUD)
   ORIF ANS = AIM THEN ERROR(NAME.IN.MUD)
ORIF ANS = MFB THEN ERROR(MUD.BUSY)
ELSE ERROR(MUD.ERR)
END MUDUP



%GET.MUD.DATA
M.KIND _ GET.M
SEND.CT.AND.NAME
SEND.M.EOF
GET.CIR(MUD.CIR,1)
IF ANS = 0 THEN DO
   GET.CIR(MUD.CIR,3); MUD(M.GAN) _ ANS
   GET.CIR(MUD.CIR,3) ; MUD(M.UUN) _ ANS
   GET.CIR(MUD.CIR,3); MUD(M.CPARW) _ ANS
RETURN
END
END GET.MUD.DATA



%COMPRESS
LOCAL N.CH,N.WD
P1 _ BYPT(USER,1,6)
N.CH _ N.WD _ 0
REPEAT 12 DO
   EIF CHR _ NCHV P1 = SIX.B($ ) THEN NULL
   ORIF SIX.B($A) <= CHR <= SIX.B($Z) THEN CHR-_32
   ORIF SIX.B($0) <= CHR <= SIX.B($9) THEN CHR+_15
ORIF CHR = SIX.B($-) THEN CHR _ 28
   ORIF CHR = SIX.B($.) THEN CHR _ 29
   ORIF CHR = SIX.B($/) THEN CHR _ 30
   ORIF CHR = SIX.B($:) THEN CHR _ 41
   ORIF CHR = SIX.B($@) OR CHR = SIX.B($*) THEN CHR _ 42
   ORIF CHR = SIX.B($') THEN CHR _ 43
   ELSE CHR _ 44
   EIF INC N.CH = 1 THEN C.USER(N.WD) _ CHR * 45
   ORIF N.CH = 2 OR N.CH = 3 THEN C.USER(N.WD) _ (C.USER(N.WD)+CHR)*45
   ELSE DO
	C.USER(N.WD) + _ CHR
	N.CH _ 0
	INC N.WD
	END
END
EIF C.USER(1) = 0 THEN FIRSTOF24(C.USER(0)) _ 1
ORIF C.USER(2) = 0 THEN FIRSTOF24(C.USER(1)) _ 1
ELSE NULL
RETURN
END COMPRESS



%MAKE.CPARW
RETURN
END MAKE.CPARW



%SEND.CIR(TYPE,WD,TIMES,CIR.NO)
LOCAL GOOD:
IF TYPE # ALPHA THEN DO
   P1 _ BYPT(WD,24,8)
   REPEAT TIMES MOD 3 NCHV P1
END ELSE P1 _ BYPT(WD,6,0)
HW(TMP,0) _ CIR.NO; HW(TMP,1) _ 4
REPEAT TIMES DO
   EXU(OCT 42, TMP, NCHV P1, GOOD)
	ERROR(AUX.ERR)
GOOD: NULL
END
RETURN
END SEND.CIR


END TENUPDATE
    ]@*