! 6 APR 73    PORT ACCOUNTING PACKAGE

DEF MAXI AS 10000
DEF CR AS MSG('$')
DEF DEBUG(X) AS 
DEF D(X) AS 
DEF PNUM(X) AS PN(TEL,X,10,0)

DEF LT AS 0
DEF EQ AS 1
DEF GT AS 2

DEF ON AS 1
DEF ST AS 2
DEF HK AS 3
DEF LS AS 4

DEF FALSE AS 0
DEF TRUE AS 1

GLOBAL %FMSG
GLOBAL %PN
GLOBAL %PR.FILE
GLOBAL %DRIVE
GLOBAL %PORT.AC
GLOBAL GAN

!
%PORT.AC(PORTS,TRU.LIM1,TRU.LIM2,PRIME.ST,PRIME.END,ST.LIM1,ST.LIM2, &
            P.BASIC,P.TRU1,P.TRU2,P.N.TRU,P.ST1,P.ST2,P.CNCT)
!GAN-GAN # (LEFT HALF OF PPN)
!PORTS-CONTRACTUAL NUMBER OF PORTS
!TRU.LIM1-LIMIT OF FIRST BLOCK OF TRUS
!TRU.LIM2-LIMIT OF 2ND BLOCK OF PRIME-TIME TRUS
!PRIME.ST-START OF PRIME TIME (E.G.,0500)
!PRIME.END-END  OF PRIME TIME (E.G.,1700)
!ST.LIM1-LIMIT OF FIRST BLOCK OF STORAGE
!ST.LIM2-LIMIT OF SECOND BLOCK OF STORAGE


LOCAL %CNTSC, %CSTN, %BYPT, %CNVT.TIME, %GET.MONTH
LOCAL %DO.PORTS, %GET.REC, %GET.TYPE, %GET.FIELDS, %FPRINT
LOCAL  %PS, %REPORT, %SORT, %REPLACE, %MV.FLD
LOCAL %SPC, %SEP.PRIME, %UNSQZ, %WRITE


LOCAL TIME.ON, TIME.OFF, CNCT, AVG.D.ST, DAY, MONTH, YEAR
LOCAL CNCT.TOT, PRIME.TOT, N.PRIME.TOT, TRU.TOT, ST.TOT
LOCAL OP.ERR.IN:, OP.ERR.OUT:, OP.ERR.PORT:, OP.ERR.ON:
LOCAL FN, BUF, READS, LS.P, N, I, PORTON.FN, REC.NUM, LINE, TRU
LOCAL MAX.N, MAX.DAY, MAX.ON, ON.FN, AUD.FN
LOCAL KNCT.TIME(1:20)
LOCAL KNCT.ON  (1:20)
LOCAL KNCT.OFF (1:20)


!OPEN MONTHLY MASTER FILE AND LOGON/LOGOFF FILE TO BE BUILT
FN _ OPEN('OLDMS.DAT',CHARACTER+DIRECT+INPUT,OP.ERR.IN)
PORTON.FN _ OPEN('PORTON',WORD+DIRECT+UPDATE,OP.ERR.PORT)

MSG('FILES OPEN$')
CNCT.TOT _ PRIME.TOT _ N.PRIME.TOT _ TRU.TOT _ ST.TOT _ 0
MAX.N _ N _ REC.NUM _ READS _ 0

PRIME.ST  _ CNVT.TIME(PRIME.ST)
PRIME.END _ CNVT.TIME(PRIME.END)                !CNVT TO MINUTES

TRU.LIM1 *_ 100                 !INTERNAL TRUS ARE SCALED 100
TRU.LIM2 *_ 100

[MONTH;YEAR] _ DOUBLE GET.MONTH(FN)     !GET MONTH,YEAR FROM HEADR RCD
WHILE LINE_GET.REC(FN,GAN) &
 THEN &
 DO
  NULL
  DO GET.TYPE(LINE) OF 0:LS
  
  0: MSG('GET.TYPE FAILED TO FIND GOOD TYPE$')

  ST: NULL              !IGNORE DAILY STORAGE RECORDS

HK:ON:  GET.FIELDS(LINE) !SETS TIME.ON, TIME.OFF, TIME.CNCT, TRU
       EIF TRU.TOT+TRU <= TRU.LIM1 THEN NULL
       ORIF TRU.TOT >= TRU.LIM1 THEN SEP.PRIME
       ELSE PRIME.TOT_TRU.TOT+TRU-TRU.LIM1
       TRU.TOT+_TRU

       IF CNCT > TIME.OFF !SOMEONE WAS ON AT MIDNIGHT! &
        THEN &
        DO
         WRITE(DAY-1, 1440-(CNCT-TIME.OFF), 1440)       !SEPARATE PREV DAY
         WRITE(DAY, 0, TIME.OFF)
        END &
       ELSE WRITE(DAY, TIME.ON, TIME.OFF)

  LS:  LS.P _ TRUE
       GET.FIELDS(LINE)
       ST.TOT +_ AVG.D.ST

  END           !OF DO CASE
 END            !OF WHILE

IF NOT LS.P THEN MSG('LS REC NOT FND$')
CLOSE(FN)               !CLOSE OLDMS.DAT

D(CLOSE(PORTON.FN))
D(ON.FN _ OPEN('ONFILE',CHARACTER+UPDATE+DIRECT,OP.ERR.ON))
D(PR.FILE(ON.FN,MAXI))             !PRINT PORTON FILE
D(PORTON.FN _ OPEN('PORTON',WORD+DIRECT+UPDATE,OP.ERR.PORT))
D(MSG('CALLING SORT$'))
D(MSG('1ST PORTON REC IS');PNUM(R(PORTON.FN));CR)

SETCP(PORTON.FN,0)
SORT(PORTON.FN,0,REC.NUM-1)   !SORT PORTON FILE BYDAY, THEN LOGON
MSG('END SORT.$')

D(CLOSE(PORTON.FN))
D(MSG('SORTED PORTON FILE:$'))
D(PR.FILE(ON.FN,MAXI))
D(CLOSE(ON.FN))
D(PORTON.FN _ OPEN('PORTON',WORD+DIRECT+UPDATE,OP.ERR.PORT))
D(MSG('CALLING DO.PORTS$'))
D(AUD.FN _ OPEN('AUD',CHARACTER+DIRECT+UPDATE,OP.ERR.PORT))

DO.PORTS(PORTON.FN)     !PROCESS PORTON FILE, COMPUTING ANY CONNECT TIME
CLOSE(PORTON.FN)

!OPEN REPORT FILE AND CALL REPORT GENERATING ROUTINE
FN _ OPEN('PORTAC',CHARACTER+DIRECT+UPDATE,OP.ERR.OUT)
D(MSG('CALLING REPORT$'))
REPORT(FN)
CLOSE(FN)

RETURN
OP.ERR.IN:  MSG('OLDMS.DAT OPEN ERR$');RETURN
OP.ERR.PORT:MSG('PORTON OPEN ERR$');RETURN
OP.ERR.OUT: MSG('PORTAC OPEN ERR$');RETURN
OP.ERR.ON:  MSG('ONFILE OPEN ERR$');RETURN


%WRITE(DAY,ONN,OFF)             !WRITE RECORD TO PORTON FILE
W(PORTON.FN,TIME.OFF)
W(PORTON.FN,DAY)
W(PORTON.FN,TIME.ON)
INC REC.NUM
RETURN
END WRITE

!
%GET.REC(FN,CUST)
!FN-FILE NUMBER FOR MASTER FILE
!CUST-CUSTOMER NUMBER 

LOCAL EOF:
LOCAL BUF, OLDUSR, P, P1

SETRWE(FN,EOF)

WHILE P _ BUF _ GETLINE(FN) &
 THEN &
 DO
  INC READS             !KEEP TRACK OF  OLDMS.DAT RECORDS
IF (READS MOD 1000)=0 &
 THEN &
 DO
  MSG('$RDS=');PNUM(READS)
  MSG('   RECS=');PNUM(REC.NUM) 
 END
  P1 _ BYPT(@OLDUSR,1,6)
  REPEAT 6 NCHV P1 _ ((NCHV P) - $  ) BAND OCT 77
  IF CUST = UNSQZ(OLDUSR) THEN RETURN (FREE)
 END
RETURN (0)
EOF:  MSG('$OLDMS.DAT EOF HIT$')
      RETURN (0)

END GET.REC
!
%UNSQZ(OLDUSR)          !UNSQUEEZE PPN INTO GLOBAL ACCT NUMBER
LOCAL TMP1, TMP2, NO

TMP1 _ OLDUSR; TMP2 _ NO _ 0
REPEAT 2 DO
  REPEAT 3 DO
    [TMP2;TMP1] _ [TMP2;TMP1] DROTL 6
    IF TMP2 _ TMP2 BAND OCT 77 = 0 THEN TMP2 _ 26
    IF TMP2 - _ 16 >= 17 THEN TMP2 - _ 6
    NO _ NO*OCT 50+TMP2
  END
HW(@TMP1,1) _ NO; NO _ 0
END
RETURN (HW(@TMP1))
END UNSQZ






!THE FOLLOWING ROUTINE COMPUTES A GENERAL BYT POINTER SO THAT
!NCHV ON THE PDP-10 WILL DO ILDB'S FOR ANY BYTE SIZE
%BYPT(Y,P1,S)
RETURN [6,6,6,18]*[IF P1>=0 THEN 36-S*(P1 MOD(36/S)-1)&
        ELSE 36-S*(36/S-(-P1)MOD(36/S)+1),S,0,&
        IF P1>=0 THEN Y+P1/(36/S) ELSE Y+(P1+1)/(36/S)-1]
END BYPT





%GET.TYPE(LINE)
!INPUT: RECORD BUFFER ADDRESS
!VALUE: RECORD TYPE

LOCAL CHAR

CHAR _ CH(LINE,9)
EIF  CHAR = $O THEN RETURN (ON)
ORIF CHAR = $S THEN RETURN (ST)
ORIF CHAR = $L THEN RETURN (LS)
ORIF CHAR = $H THEN RETURN (HK)
ELSE RETURN (0)

END GET.TYPE
!
%SEP.PRIME              !SEPARATE PRIME-TIME TRUS

LOCAL %SEPARATE
LOCAL T
!D(MSG('SEP.PRIME$'))
IF CNCT > TIME.OFF !SOMEONE WAS ON AT MIDNIGHT! &
 THEN &
 DO
  T _ ((1440-TIME.ON)/CNCT)*TRU         !TRUS BEFORE MIDNITE
  SEPARATE(T, 1440-TIME.ON, TIME.ON, 1440)
  SEPARATE(TRU-T, TIME.OFF, 0, TIME.OFF)
 END &
ELSE SEPARATE (TRU,CNCT,TIME.ON,TIME.OFF)       !NORMAL CASE

!D(MSG('PRIME.TOT= '))
!D(PNUM(PRIME.TOT))
!D(MSG('N.PRIME.TOT= '))
!D(PNUM(N.PRIME.TOT))
RETURN [PRIME.TOT;N.PRIME.TOT]

%SEPARATE(TRUS, CNCT.T, ONN, OFF)
LOCAL T

EIF ONN < PRIME.ST &
 THEN &
 DO
  EIF OFF <= PRIME.ST THEN N.PRIME.TOT+_TRUS
  ORIF OFF <= PRIME.END &
   THEN &
   DO
    N.PRIME.TOT +_ (T _ ((PRIME.ST-ONN)/CNCT.T)*TRUS)
    PRIME.TOT +_ TRUS-T
   END
  ELSE  !OFF >= PRIME.END ! &
  DO
   PRIME.TOT +_ (T _ ((PRIME.END-PRIME.ST)/CNCT.T)*TRUS)
   N.PRIME.TOT +_ TRUS-T
  END
 END
ORIF ONN < PRIME.END &
 THEN &
 DO
  IF OFF <= PRIME.END THEN PRIME.TOT +_ TRUS &
  ELSE &
  DO
   PRIME.TOT +_ (T _ ((PRIME.END-ONN)/CNCT.T)*TRUS)
   N.PRIME.TOT +_ TRUS-T
  END
 END
ELSE N.PRIME.TOT +_ TRUS
RETURN
END SEPARATE


END SEP.PRIME
!
%DO.PORTS(FN)           !PROCESS PORTON FILE TO COMPUTE EXCESS CNCT TIME
!PORTON FILE HAS BEEN SORTED ACCORDING TO LOGON TIME. EACH 'RECORD'
!IS 3 WORDS LONG: LOGON TIME IN MINUTES, LOGOFF TIME, RECORD NUMBER

LOCAL %EARLIEST

LOCAL REC, ENTRY.P, E, EOF:, DAY, CUR.DAY

D(MSG('DO.PORTS$'))
SETRWE(FN,EOF)
SETCP(FN,0)
REC _ 0
CUR.DAY _ 1
WHILE (INC REC)<=REC.NUM &
 THEN &
 DO
  TIME.OFF_ R(FN)
  DAY     _ R(FN)               !READS MUST REMAIN IN ORDER
  TIME.ON _ R(FN)
  CNCT _ TIME.OFF-TIME.ON
  IF DAY > CUR.DAY !LET'S START A NEW DAY! &
   THEN &
   DO
    N _ 0                       !CLEAR NUMBER OF PORTS ACTIVE
    FOR I_1 TO PORTS  KNCT.TIME(I)_KNCT.ON(I)_KNCT.OFF(I) _ 0
    CUR.DAY _ DAY
   END
  ENTRY.P _ FALSE
  I _ 0
  WHILE (INC I) <= N &
   THEN &
    IF TIME.ON >= KNCT.OFF(I) &
     THEN &
     DO
      REPLACE(I)                !REPLACE THE I-TH PORT TABLE ENTRY
      I +_ N            !GET OUT OF THIS WHILE LOOP
      ENTRY.P _ TRUE    !YES, WE FOUND A REPLACEMENT PORT
     END
  IF NOT ENTRY.P THEN IF N < PORTS &
   THEN &
   DO
    INC N               !ADD NEW ENTRY TO 
    REPLACE(N)          !THE PORT TABLE
!
!   W(AUD.FN, CARRET);PN1(N)
!   FMSG(AUD.FN, '  PORT TABLE ENTRIES FOLLOW:$')
!   FOR I_1 TO N DO
!    PN1(KNCT.TIME(I)); PN1(KNCT.ON(I)); PN1(KNCT.OFF(I)); W(AUD.FN,CARRET)
!   END
!   FMSG(AUD.FN, '$CNCT, TIME.ON, TIME.OFF, DAY, REC FOLLOW:$')
!   PN1(CNCT); PN1(TIME.ON); PN1(TIME.OFF); PN1(DAY); PN1(REC)
!   W(AUD.FN,CARRET)
   END &
  ELSE !PORT TABLE IF FULL,SO RECORD ALL OR PART OF CNCT TIME!&
  DO
   E _ EARLIEST         !INDEX OF EARLIEST LOGOFF IN TABLE
   IF KNCT.OFF(E) < TIME.OFF &
    THEN &
    DO
     CNCT.TOT +_ (KNCT.OFF(E)-TIME.ON)  !ADD OVERLAP TIME AND
     REPLACE(E)                         !REPLACE ENTRY
    END &
   ELSE CNCT.TOT +_ CNCT                !NEW ENTRY ENTIRELY OVERLAPPED
  END
 END            !OF WHILE
!CNCT.TOT NOW COMPLETE
D(MSG('CNCT.TOT=');PNUM(CNCT.TOT))
RETURN (CNCT.TOT)
EOF:  MSG('PORTON EOF IN DO.PORTS$');RETURN

%EARLIEST               !COMPUTE INDEX TO EARLIEST LOGOFF IN TABLE
LOCAL T, I, E

T _ KNCT.OFF(1)
FOR I _ 1 TO N IF KNCT.OFF(I) <= T THEN [T _ KNCT.OFF(I); E _ I]
RETURN (E)

END EARLIEST


END DO.PORTS
!
%REPLACE(I)
KNCT.TIME(I)_CNCT
KNCT.ON  (I)_TIME.ON
KNCT.OFF (I)_TIME.OFF
IF I>MAX.N THEN DO
 MAX.N _ I
 MAX.DAY _ DAY
 MAX.ON _ TIME.ON
END
RETURN
END REPLACE





%CNTSC(N,PTR,@I,S)
   LOCAL A(0:9),APTR,Q1,Q2
   I_0; APTR_CHPT(A,-1); NCHV APTR_EOLIT

   IF N<0 THEN [N_-N; INC I; NCHV PTR_$-]

   IF S#0 THEN [N;Q2]_N DIVMOD S

   LOOP DO
      [N;Q1]_N DIVMOD 10
      NCHV APTR_Q1+$0
      WHILE N#0
   END

   NCHV APTR

   WHILE Q1_PCHV APTR#EOLIT THEN [INC I; NCHV PTR_Q1]

   IF S#0 THEN DO
      NCHV PTR_$.
      INC I
      LOOP DO
         WHILE S>1
         S_S/10
         [Q1;Q2]_Q2 DIVMOD S
         INC I
         NCHV PTR_Q1+$0
      END
   END

   NCHV PTR_EOLIT
   RETURN
END CNTSC


%FMSG(FN,STR)
   LOCAL PTR
   PTR_CHPT(STR,-1)
   WHILE NCHV PTR#EOLIT THEN W(FN,IF CHV PTR=$$ THEN CARRET ELSE CHV PTR)
   RETURN

   %%FPRINT(FN,STR)
      PTR_CHPT(STR,-1)
      WHILE NCHV PTR#EOLIT THEN W(FN,CHV PTR)
      RETURN
END FMSG

%SPC(FN,N)
 REPEAT N W(FN,$ )
 RETURN
END SPC

%PN(FN,N,F,S)
 LOCAL STR(0:9),PTR,L
 PTR_CHPT(STR,-1)
 CNTSC(N,PTR,@L,S)
 SPC(FN,F-L)
 FPRINT(FN,STR)
 RETURN
END PN

%PS(FN,PTR,N)
 W(FN,$ )
 PTR_CHPT(PTR,-1)
 REPEAT N W(FN,IF NCHV PTR=EOLIT THEN $  ELSE CHV PTR)
 RETURN
END PS

%CSTN(PTR,@TCH,B)
 LOCAL N,MFLG,CNT,%PST
 N_MFLG_CNT_0
 LOOP WHILE NCHV PTR=$ 
 IF CHV PTR=$- THEN INC MFLG ELSE PCHV PTR
 PST; CNT_0
 IF CHV PTR=$. THEN PST
 TCH_CHV PTR
 IF MFLG#0 THEN N_-N
 RETURN [N;CNT]
 %PST
  WHILE $0<=NCHV PTR<=B+$0 THEN [INC CNT; N_N*B+(CHV PTR)-$0]
  RETURN
 END PST
END CSTN
!
%SORT(FN,LB,UB)
  DEF GTR(X,Y) AS FNCOMP(X,Y)=1
  DEF LSS(X,Y) AS FNCOMP(X,Y)=-1
  DEF UNTIL(X) AS WHILE NOT (X)
  LOCAL %FNSORT, %FNCOMP, %XCH, %KEY
  LOCAL USTK(50),LSTK(50),STKP
  LOCAL EOF:, CNT
  DEF NKB AS 10
  LOCAL KB(0:3*NKB), I, LMED, UMED, KP()

  KP_KB-3
  LMED_UMED_-2
  SETRWE(FN, EOF)

  FNSORT(%KEY,LB,UB)
  RETURN
EOF: MSG('PORTON EOF DURING SORT$');RETURN

  %FNSORT(%KEY,LB,UB)

    LOCAL I,N,L,U
    CNT_0
    STKP_1
    MSG('SORTING'); PNUM(UB-LB); MSG('  RECORDS.$')
    SORT: WHILE UB-LB<11 THEN !BUBBLE AWAY! DO
      N_UB
      WHILE LB<UB_N<==I_LB THEN  DO
        WHILE INC I<=UB THEN IF GTR(KEY(I-1),KEY(I)) THEN DO
          XCH(I-1,I); N_I
        END
      END

      IF DEC STKP <= 0 THEN RETURN
      UB_USTK(STKP); LB_LSTK(STKP)
    END

    IF LSS(UMED_KEY(U_UB),LMED_KEY(L_LB)) THEN UMED <=> LMED

    WHILE L<U THEN DO
      IF GTR(KEY(L),KEY(U)) THEN XCH(L,U)
      IF LSS(LMED,KEY(L)) THEN LMED_KEY(L)
      IF LSS(KEY(U),UMED) THEN UMED_KEY(U)
      LOOP UNTIL(L>=U OR GTR(KEY(INC L),LMED))
      LOOP UNTIL(U<=L OR LSS(KEY(DEC U),UMED))
    END
    IF GTR(KEY(L),UMED) THEN DEC L
    IF L<LB THEN INC L ELSE IF L=UB THEN DEC L
    EIF L-LB<UB-L THEN [USTK(STKP)_UB<==L; LSTK(STKP)_L+1]
    ELSE [LSTK(STKP)_LB<==L+1; USTK(STKP)_L]
    INC STKP; GO SORT
  END FNSORT

  %FNCOMP(X,Y)
    LOCAL KEY1(),KEY2(),I

    KEY1_X
    KEY2_Y

    I_1
    LOOP DO
      WHILE KEY1(I)=KEY2(I)
      IF INC I > 2  THEN RETURN 0
    END
    RETURN IF KEY1(I)>KEY2(I) THEN 1 ELSE -1
  END FNCOMP

  %KEY(X)
    LOCAL I
    LOOP UNTIL(LMED#KP_IF KP+_3>=KB+NKB*3 THEN KB ELSE KP#UMED)
    SETCP(FN,X*3)
    FOR I_0 TO 2 KP(I)_R(FN)
    RETURN KP
  END KEY

  %XCH(X,Y)
    LOCAL I,KEY1(0:2),KEY2(0:2)
    SETCP(FN,Y*3)
    FOR I_0 TO 2 KEY1(I)_R(FN)
    SETCP(FN,X*3)
    FOR I_0 TO 2 KEY2(I)_R(FN)
    SETCP(FN,X*3)
    FOR I_0 TO 2  W(FN,KEY1(I))
    SETCP(FN,Y*3)
    FOR I_0 TO 2  W(FN,KEY2(I))
    RETURN
  END XCH


END SORT


!
%GET.FIELDS(LINE)
!LINE-BUFFER ADDRESS OF INPUT RECORD
!GET.FIELDS GETS VALUES FOR 
!   FIELD               START COLUMN (1 ORIGIN)         LENGTH
!
!LOGOFF HOUR                    11                      8
!LOGOFF MINUTE                  19                      2
!CONNECT TIME                   23                      6
!DAY                            35                      2
!TRUS                           54                      11.2
!AVERAGE DAILY STORAGE          65                      11.2

DEF D(X) AS NULL
LOCAL TRM

TIME.OFF _ 60*(CSTN(MV.FLD(LINE,11,8),@TRM,10)) + CSTN(MV.FLD(LINE,19,2),@TRM,10)
CNCT     _ CSTN(MV.FLD(LINE,23,6),@TRM,10)
TIME.ON  _ TIME.OFF-CNCT
DAY      _ CSTN(MV.FLD(LINE,35,2),@TRM,10)
TRU      _ (CSTN(MV.FLD(LINE,54,8),@TRM,10))*100 + CSTN(MV.FLD(LINE,63,2),@TRM,10)
AVG.D.ST _ (CSTN(MV.FLD(LINE,65,8),@TRM,10))*100 + CSTN(MV.FLD(LINE,74,2),@TRM,10)

D(PNUM(TIME.ON))
D(PNUM(TIME.OFF))
D(PNUM(CNCT))
D(PNUM(DAY))
D(PNUM(TRU))
D(PNUM(AVG.D.ST))

RETURN

END GET.FIELDS




%MV.FLD(LINE,START,LEN)
!GIVEN BUFFER ADDRESS, START COLUMN, LENGTH
!RETURNS CHPT PTR TO 1 CHAR BEFORE STRING. EOLIT TERMINATES STRING.

LOCAL P1, P2, P3, I, TEMP(1:10)

P1 _ CHPT(LINE, START-1)
P2 _ P3 _ CHPT(@TEMP(1), -1)
FOR I_0 TO LEN-1  NCHV P2 _ NCHV P1
NCHV P2 _ E.O.LIT

RETURN (P3)

END MV.FLD

!
%CNVT.TIME(N)
LOCAL Q, R

[Q;R] _ N DIVMOD 100
RETURN (Q*60+R)
END CNVT.TIME



%GET.MONTH(FN)
!READ FIRST OLDMS.DAT RECORD AND EXTRACT MONTH,YEAR
LOCAL EOF:
LOCAL BUF, LINE, YEAR, MONTH

SETRWE(FN,EOF)
YEAR _ MONTH _ 0
BUF _ GETLINE(FN)               !FIRST READ OF OLDMS.DAT FILE
LINE _ FREE

IF CH(LINE,3) # $D &
 THEN &
 DO 
  MSG('FIRST RECORD NOT HEADER$')
  RETURN [1;1]
 END

MONTH _ CSTN(MV.FLD(LINE,7,2),@BUF,10)
YEAR  _ CSTN(MV.FLD(LINE,19,2),@BUF,10)

IF NOT(1<=MONTH<=12) THEN [MSG('INVALID MONTH IN HDR:');PNUM(MONTH)]
IF NOT(73<=YEAR<=80) THEN [MSG('INVALID YEAR IN HDR:');PNUM(YEAR)]

MSG('MONTH, YEAR:');PNUM(MONTH);MSG(',');PNUM(YEAR);CR

RETURN [MONTH;YEAR]
EOF: MSG('OLDMS.DAT ERR ON FIRST READ$'); RETURN

END GET.MONTH
!
%REPORT(FN)
LOCAL T, TMP, TOT, ERR:
D(MSG('REPORT$'))

TABLE MONTHS(1:12) ['JANUARY','FEBRUARY','MARCH','APRIL','MAY',&
                    'JUNE','JULY','AUGUST','SEPTEMBER','OCTOBER',&
                    'NOVEMBER','DECEMBER']

DEF DOL AS W(FN,$$)
DEF MS(X) AS FMSG(FN,X)
DEF CR AS W(FN, CARRET)
DEF MARGIN AS NULL
DEF INDENT AS SPC(FN, 5)
DEF INDENT2 AS SPC(FN,10)
DEF TOTALS AS SPC(FN,48)
DEF COST AS SPC(FN,59);DOL
DEF PNUM(X,SCALE) AS PN(FN,X,10,SCALE)
DEF SECTION AS CR;CR;CR


SETRWE(FN, ERR)

!TITLE
SECTION;SECTION
INDENT2;INDENT2; MS('PORT ACCOUNTING FOR$')
INDENT2;INDENT2; MS(" CONSUMER'S POWER$")
INDENT2;INDENT2;INDENT; MS(MONTHS(MONTH)); MS(', 19'); PN(FN,YEAR,2,0)

SECTION
MARGIN; MS('I. BASIC MONTHLY RATE$')
COST; PNUM(TOT_(P.BASIC*100),100);CR

SECTION
MARGIN; MS('II. PORT ACCOUNTING$'); CR
INDENT; MS('TOTAL MINUTES OVER CONTRACTUAL LIMIT @ ');DOL
        PN(FN,P.CNCT,5,1000);CR
TOTALS; PNUM(CNCT.TOT,0); CR
COST; PNUM(TMP_((CNCT.TOT*P.CNCT)/600),100); CR
TOT +_ TMP

SECTION
MARGIN; MS('III. TRU ACCOUNTING$');CR
INDENT; MS('TOTAL TRUS$')
TOTALS; PNUM(TRU.TOT,100); CR

INDENT; MS('TRUS INCLUDED IN BASIC RATE$')
TOTALS; PNUM(TRU.LIM1, 100); CR
COST; PNUM(0,100); CR

INDENT; MS('TRUS IN EXCESS OF BASIC RATE$'); CR
INDENT2; MS('NON-PRIME TIME TRUS @ '); DOL; PN(FN,P.N.TRU,5,1000); CR
TOTALS; PNUM(N.PRIME.TOT,100); CR
COST; PNUM(TMP_((N.PRIME.TOT*P.N.TRU)/1000),100); CR
TOT +_ TMP

INDENT2; PNUM(TRU.LIM2,100); MS(' NEXT PRIME TIME TRUS @ ');DOL
         PN(FN,P.TRU1,5,1000); CR
IF T_(PRIME.TOT-TRU.LIM2)<0 THEN T_0
TOTALS; PNUM((PRIME.TOT-T),100); CR
COST; PNUM(TMP_(((PRIME.TOT-T)*P.TRU1)/1000),100); CR
TOT +_ TMP

INDENT2; MS('REMAINING TRUS @ '); DOL; PN(FN,P.TRU2,5,1000); CR
TOTALS; PNUM(T, 100); CR
COST; PNUM(TMP_((T*P.TRU2)/1000),100); CR
TOT +_ TMP

SECTION
ST.TOT _ (ST.TOT*128*5)/100        !COMPUTE AVG. CHARS FROM AVG BLKS
MARGIN; MS('IV. DISK STORAGE $'); CR

INDENT; MS('TOTAL AVERAGE STORAGE WORDS$')
TOTALS; PNUM(ST.TOT,0); CR

INDENT; MS('TOTAL AVERAGE WORDS INCLUDED IN BASIC RATE$')
TOTALS; PNUM(ST.LIM1,0); CR

INDENT; MS('AVERAGE STORAGE IN EXCESS OF BASIC RATE$'); CR

INDENT2; PNUM(ST.LIM2,0); MS(' NEXT CHARACTERS @ ');DOL
         PN(FN,P.ST1,5,1000); MS('/1000$')
IF T_(ST.TOT-ST.LIM1)<0 THEN T_0
TOTALS; PNUM(T,0); CR
COST; PNUM(TMP_((T*P.ST1)/10000),100); CR
TOT +_ TMP

INDENT2; MS('REMAINING AVG CHARACTERS @ '); DOL; PN(FN,P.ST2,5,1000)
        MS('/1000$')
IF T_(T-ST.LIM2)<0 THEN T_0
TOTALS; PNUM(T,0); CR
COST; PNUM(TMP_((T*P.ST2)/10000),100); CR
TOT +_ TMP

SECTION
TOTALS; MS('TOTAL$')
COST; PNUM(TOT,100); CR

SECTION;SECTION

RETURN
ERR:  MSG('WRITE ERR DURING REPORT GENERATION$'); RETURN
END REPORT
!
END PORT.AC
%DRIVE
START: NULL
\\->START
IOCS(3)
GAN _ OCT 5411          !GLOBAL ACCOUNT NUMBER
PORT.AC(6,90000,30000,500,1700,5000000,5000000,15000,100,90,65,&
            500,300,8000)
!PORT.AC(2,900  ,300  ,500,1700,500    ,500    ,15000,100,90,65,&
           500,300,8000)
MSG('FINISHED.$')
EXIT
END DRIVE




%PR.FILE(OUT.FN,MX)                     !PRINT PORTON FILE ON OUT.FN
DEF PNUM1(X) AS PN(OUT.FN,X,10,0)
LOCAL IN.FN, I, N, ONN, OFF, OP.ERR:, EOF:

MSG('PR.FILE$')
IN.FN _ OPEN('PORTON',WORD+DIRECT+UPDATE,OP.ERR)
SETRWE(IN.FN,EOF)
FMSG(OUT.FN,'       DAY     LOGON    LOGOFF $')
I _ 0
WHILE (INC I) <= MX &
 THEN &
 DO
  OFF _ R(IN N _ R(IN.FN);ONN _ R(IN.FN)
  PNUM1(N); PNUM1(ONN); PNUM1(OFF); W(OUT.FN,CARRET)
 END
EOF: NULL
D(MSG('LAST READ RECORD ATTEMPTED IS NUMBER '); PNUM(I); CR)
D(PNUM(N); PNUM(ONN); PNUM(OFF); CR)
CLOSE(IN.FN)

RETURN
OP.ERR:  MSG('PORTON OPEN ERR$');RETURN (IN.FN)
END PR.FILE
   
Khs