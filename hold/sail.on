SAILON NO. 57.2					SAIL   1

                          TABLE OF CONTENTS
                                    
                                    
                                    
                                    
CONTENT                                                    PARAGRAPH
   
   
   
SECTION 1--INTRODUCTION
   
SECTION 2--PROGRAMS, BLOCKS, STATEMENTS
   SYNTAX                                                  2- 1
   EXAMPLES                                                2- 2
   SEMANTICS                                               2- 3
      Declarations                                         2- 3
      Statements                                           2- 6
      Block Names                                          2- 9
      Entry Specifications                                 2-11
   
SECTION 3--DECLARATIONS
   SYNTAX                                                  3- 1
   RESTRICTIONS                                            3- 2
   EXAMPLES                                                3- 6
   SEMANTICS                                               3- 8
      Scope of declarations                                3- 8
      Type Declarations                                    3-11
       Numeric Declarations                                3-13
       String Declarations                                 3-15
       Item Declarations                                   3-18
        Items                                              3-19
        Item Genesis                                       3-20
        Datums                                             3-21
       Itemvar Declarations                                3-22
       Set Declarations                                    3-24
      Array Declarations                                   3-25
      Preload Specifications                               3-33
      Procedure Declarations                               3-38
       Formal Parameters                                   3-39
       Forward Procedure Declarations                      3-42
       Recursive Procedures                                3-44
       External Procedures                                 3-47
       Parametric Procedures                               3-51
       Defaults in Procedure Declarations                  3-53
       Restrictions on Procedure Declarations              3-54
      Synonyms                                             3-55
      Define Specification                                 3-56
      Requirements                                         3-57
   
SAILON NO. 57.2					SAIL   2

SECTION 4--ASSIGNMENT STATEMENTS
   SYNTAX                                                  4- 1
   RESTRICTION                                             4- 2
   SEMANTICS                                               4- 3
      Datum Assignments                                    4- 7
      Swap Assignment                                      4- 8
      Byte statements                                      4-10
   
SECTION 5--EXECUTION CONTROL STATEMENTS
   SYNTAX                                                  5- 1
   SEMANTICS                                               5- 2
      Conditional Statements                               5- 2
       If Statement                                        5- 4
       If ... Else Statement                               5- 5
       Ambiguity in Conditional Statements                 5- 6
      Go To Statements                                     5- 8
      For Statements                                       5-11
      While Statement                                      5-16
      Do Statement                                         5-17
      Case Statements                                      5-18
      Return Statement                                     5-20
      Done Statement                                       5-24
      Next Statement                                       5-26
      Continue Statement                                   5-30
   
SECTION 6--PROCEDURE STATEMENTS
   SYNTAX                                                  6- 1
   SEMANTICS                                               6- 2
      Actual Parameters                                    6- 4
      Call by Value                                        6- 5
      Call by Reference                                    6- 6
      Procedures as Actual Parameters                      6-10
      Fortran Procedures                                   6-12
      Implementation Details                               6-15
      Examples:                                            6-16
   
SECTION 7--LEAP STATEMENTS
   SYNTAX                                                  7- 1
   SEMANTICS                                               7- 2
      LEAP Introduction                                    7- 2
      General Restrictions                                 7- 7
      Construction - Retrieval Distinction                 7- 8
      PUT and REMOVE                                       7- 9
      DELETE                                               7-10
      MAKE                                                 7-11
      ERASE                                                7-13
      FOREACH Statement                                    7-15
       Restrictions and Caveats                            7-22
   
SAILON NO. 57.2					SAIL   3

SECTION 8--ASSEMBLY LANGUAGE STATEMENTS
   SYNTAX                                                  8- 1
   SEMANTICS                                               8- 2
      Declarations in Code Blocks                          8- 3
      Meaning of Instruction Operands                      8- 4
      Distinctions Between STARTCODE and QUICKCODE       8- 7
      Warning Concerning Default Radix                     8- 8
   
SECTION 9--ALGEBRAIC EXPRESSIONS
   SYNTAX                                                  9- 1
   SEMANTICS                                               9- 2
      Conditional Expressions                              9- 2
      Example                                              9- 3
      Assignment Expressions                               9- 4
      Example                                              9- 5
      Case Expressions                                     9- 6
      Example                                              9- 8
      Simple Expressions                                   9- 9
       The Boolean Expression Anomaly                      9-10
       Precedence of Algebraic Operators                   9-13
       Expression Evaluation Rules                         9-14
       Algebraic Expressions                               9-15
       Disjunctive Expressions                             9-18
       Relational Expressions                              9-19
       Arithmetic Type Conversions                         9-21
       String-Arithmetic Conversions                       9-27
       Bounded Expressions                                 9-29
       Adding Expressions                                  9-30
       Terms                                               9-33
       Concatenation Operator                              9-38
       Factors                                             9-39
       Primaries                                           9-40
        Variables and Constants                            9-41
        Substrings                                         9-42
      Special Length Operator ()                          9-45
        Function Designators                               9-47
        Length                                             9-50
        Lop                                                9-51
        Cvn                                                9-52
        Lnot                                               9-53
        Abs                                                9-54
        Unary Minus                                        9-55
        Boolean Primaries                                  9-56
   ISTRIPLE                                                9-57
   LDB and ILDB                                            9-58
   
SECTION 10--SET AND ASSOCIATIVE EXPRESSIONS
   SYNTAX                                                  10- 1
   SEMANTICS                                               10- 2
SAILON NO. 57.2					SAIL   4

      Set Expressions                                      10- 2
      Set Primaries                                        10- 3
	      Item Constructs                                      10- 4
      Item Selectors                                       10- 5
      NEW Items                                            10- 6
   NEWITEM Declaration                                    10- 6
      ANY Construct                                        10- 7
      CVI                                                  10- 8
      LEAP Booleans                                        10- 9
   
SECTION 11--BASIC CONSTRUCTS
   SYNTAX                                                  11- 1
   SEMANTICS                                               11- 2
      Variables                                            11- 2
      Datums                                               11- 6
      Identifiers                                          11- 7
      Sail Reserved Words                                  11-10
      Sail Predeclared Identifiers                         11-12
      Arithmetic Constants                                 11-15
      String Constants                                     11-19
      Examples                                             11-22
      Comments                                             11-24
   
SECTION 12--EXECUTION TIME ROUTINES
   GENERAL                                                 12- 1
      Scope                                                12- 1
      Notational Conventions                               12- 3
      Example                                              12- 5
   I/O ROUTINES                                            12- 6
      Open                                                 12- 6
      Close, Closin, Closo                                 12-10
      Getchan                                              12-12
      Release                                              12-14
      Lookup, Enter                                        12-17
      Rename                                               12-21
      Breakset                                             12-22
      Setbreak                                             12-35
      Stdbrk                                               12-37
      Input                                                12-40
      Scan                                                 12-43
      Out                                                  12-45
      Linout                                               12-46
      Wordin                                               12-48
      Arryin                                               12-50
      Wordout                                              12-53
      Arryout                                              12-55
      Mtape                                                12-57
      Useti, Useto                                         12-59
      Realin, Intin                                        12-61
SAILON NO. 57.2					SAIL   5

      Realscan, Intscan                                    12-66
      Teletype I/O Functions                               12-68
      Pseudo-teletype functions (Stanford only)            12-70
   STRING MANIPULATION ROUTINES                            12-72
      Equ                                                  12-73
   TYPE CONVERSION ROUTINES                                12-75
      Setformat                                            12-75
      Getformat                                            12-78
      Cvs                                                  12-80
      Cvos                                                 12-82
      Cvis                                                 12-84
      Cvsi                                                 12-86
      NewPname                                            12-88
      DelPname                                            12-90
      Cve, Cvf, Cvg                                        12-92
      Cvstr                                                12-97
      Cvxstr                                               12-99
      Cvd                                                  12-101
      Cvo                                                  12-103
      Cvasc                                                12-105
      Cvsix                                                12-107
      Cvfil                                                12-109
      Arrinfo                                              12-110
      Arrblt                                               12-112
      Arrtran                                              12-114
   LIBERATION-FROM-SAIL ROUTINES                           12-116
      Code                                                 12-116
      Call                                                 12-118
      Usercon                                              12-120
      Usererr                                              12-124
      Point                                                12-126
   
SECTION 13--USE OF DEFINE
      Defining Macros                                      13- 1
      String Constants in Macro Bodies                     13- 4
      Using Macros                                         13- 5
      Macro Parameters                                     13- 6
       Example                                             13- 8
      Actual Parameter Expansion                           13- 9
       Examples                                            13-11
   
SECTION 14--COMPILER OPERATION
   COMMAND FORMAT                                          14- 1
      Semantics                                            14- 2
       Rpg Mode                                            14-12
       Switches                                            14-13
      Debugging modes                                      14-14
   ERROR MESSAGES                                          14-19
   STORAGE ALLOCATION                                      14-22
SAILON NO. 57.2					SAIL   6

   
SECTION 15--PROGRAM OPERATION
   LOADING AND STARTING SAIL PROGRAMS                      15- 1
      Loading                                              15- 1
      Starting the Program -- Normal Operation             15- 2
      Starting the Program in "RPG" Mode                   15- 3
      Starting the Program with Allocation Modifications   15- 4
   ERROR MESSAGES                                          15- 5
   DEBUGGING                                               15- 9
      Symbols                                              15-10
      Blocks                                               15-13
      Sail-Generated Symbols                               15-14
      Warnings                                             15-15
       Long Names                                          15-16
   
SECTION 16--PROGRAM STRUCTURE
   THE SAIL CORE IMAGE (REQUIRED)                          16- 1
      Main Program                                         16- 2
      Storage Allocation, Basic Utilities                  16- 4
      Other Execution-Time Routines                        16- 6
   OPTIONAL ADDITIONS                                      16- 7
      Separately Compiled Procedures                       16- 7
      Fortran Procedures                                   16-11
      Assembly Language Procedures                         16-12
      Others                                               16-13
   
SECTION 17--IMPLEMENTATION INFORMATION
   STORAGE LAYOUT                                          17- 1
      User Table                                           17- 1
      Storage Allocation Routines                          17- 5
       Corget                                              17- 6
       Correl                                              17-10
       Corinc                                              17-11
       Caninc                                              17-12
       Corbig                                              17-13
   STRINGS                                                 17-15
      String Descriptors                                   17-15
      String Operations                                    17-20
       Cat                                                 17-21
       Substr                                              17-22
       String to Integer                                   17-26
       Putch                                               17-27
       Lop Details                                         17-28
      String Space                                         17-29
      Parameters Used by String Operations                 17-31
      String Garbage Collection                            17-32
      String-Oriented Machine Language Routines            17-33
   ARRAY IMPLEMENTATION                                    17-35
      Form                                                 17-35
SAILON NO. 57.2					SAIL   7

      Explanation                                          17-36
      Array Allocation                                     17-37
       Dynamic Arrays                                      17-37
       Built-In Arrays                                     17-40
      Array Access Code                                    17-44
   PROCEDURE IMPLEMENTATION                                17-48
      Procedure Body                                       17-49
       Discussion                                          17-50
      Procedure Calling Sequences                          17-51
       Discussion                                          17-52
   
SECTION PPENDIX -- USEFUL SUMMARIES
   ARITHMETIC TYPE-CONVERSION TABLE                        18- 1
   SAIL RESERVED WORDS                                     18- 2
   SAIL PRE-DECLARED IDENTIFIERS                            18- 3
   CHARACTER-IDENTIFIER EQUIVALENCES                       18- 4
	   PARAMETERS TO THE OPEN FUNCTION                         18- 5
   BREAKSET MODES                                          18- 6
   MTAPE COMMANDS                                          18- 7
   COMMAND SWITCHES                                        18- 8
   DEBUGGING MODES                                         18- 9
   VALID RESPONSES TO ERROR MESSAGES                       18-10
   NON-FATAL ERROR, EXCEPTIONAL CONDITION RETURN CODES     18-11
   
SECTION 19--BIBLIOGRAPHY
   
SAILON NO. 57.2					SAIL   1-1
	
                              SECTION 1
                                    
                             INTRODUCTION
                                    
   
   
1-1.    SAIL is  a  high-level  programming  system  for  the  PDP-10
computer.  It includes an extended ALGOL compiler and a companion set
of execution-time routines.  A  non-standard  ALGOL  60  compiler  is
extended  to  provide  facilities  for describing manipulations of an
associative data  structure.   This  structure  contains  information
about  ITEMS,  stored  as unordered collections of items (sets) or as
ordered triples of items (associations).  The algebraic  capabilities
of  the  language are linked to the associative capabilities by means
of the DATUM operator, which can associate with any ITEM an algebraic
datum.
   
   
1-2.    Several  forerunners (namely the GOGOL compilers developed at
the Stanford Artificial Intelligence Project) have contributed to the
general  appearance  of  the  non-associative  portions  of  the SAIL
language.  The associative data  structure  is  a  slightly  reworked
version  of  the LEAP language, which was designed by J.  Feldman and
P.  Rovner, and  implemented  on  Lincoln  Laboratory's  TX-2.   This
language  is  described  in  some  detail  in an article entitled "An
Algol-Based Associative Language" in the August, 1969  issue  of  the
ACM Communications [Feldman&Rovner].  The implementation was modified
to tolerate the non-paging environment of the PDP-10.
   
   
1-3.    SAIL in a sense has something for everyone.   For  those  who
think in ALGOL, SAIL has ALGOL.  For those who want the most from the
PDP-10 and the time-sharing system, SAIL allows flexible  linking  to
hand-coded  machine  language  programs.   For those who have complex
input/output requirements, the language provides complete  access  to
the  I/O  facilities  of  the PDP-10 system.  For those who aspire to
speed, SAIL generates fairly good code.  The user should, however, be
warned  that  SAIL  falls  several man-decades short of the extensive
testing and optimization efforts contained in the histories  of  most
commercial compilers.
	   
   
   
                                             D.  Swinehart
                                             R.  Sproull
                                             November, 1969
                                             Revised January, 1971
                                                
   
SAILON NO. 57.2					SAIL   2-1

                              SECTION 2
                                    
                     PROGRAMS, BLOCKS, STATEMENTS
                                    
   
   
SYNTAX
   
   
2-1.    
   

<program>                ::= <block>
                         ::= <entryspecification> <block> 

<block>                  ::= <blockhead> ; <compoundtail> 

<blockhead>             ::= BEGIN <declaration>
                         ::= BEGIN <blockname> <declaration>
                         ::= <blockhead> ; <declaration> 

<compoundtail>          ::= <statement> END
                         ::= <statement> END <blockname>
                         ::= <statement> ; <compoundtail> 
   
   

<statement>              ::= <block>
                         ::= <compoundstatement>
                         ::= <assignment>
                         ::= <bytestatement>
                         ::= <conditionalstatement>
                         ::= <ifstatement>
                         ::= <gotostatement>
                         ::= <forstatement>
                         ::= <whilestatement>
                         ::= <dostatement>
                         ::= <casestatement>
                         ::= <returnstatement>
                         ::= <donestatement>
                         ::= <nextstatement>
                         ::= <continuestatement>
                         ::= <leapstatement>
                         ::= <procedurestatement>
                         ::= <codeblock>
                         ::= <definespecification>
                         ::= <stringconstant> <statement>
                         ::= <labelidentifier> : <statement>
                         ::= <empty> 
SAILON NO. 57.2					SAIL   2-1


<compoundstatement>     ::= BEGIN <compoundtail>
                         ::= BEGIN <blockname> <compoundtail> 

<blockname>             ::= <stringconstant> 

<entryspecification>    ::= ENTRY <idlist> 
   
   
   
EXAMPLES
   
   
2-2.    
Given:
    S is a statement,
    Sc is a Compound Statement,
    D is a Declaration,
    B is a Block.

Then:
    (Sc)    BEGIN S; S; S; ... ; S END
    (Sc)    BEGIN "SORT" S; S; ... ;S END
    (B)     BEGIN D; D; D; ... ; S; S; S; ... ; S END
    (B)     BEGIN "ENTER NEW INFO" D;  D; ... ; S; ... ;S END

			are syntactically valid SAIL constructs.

   
   
SEMANTICS
   
Declarations
   
   
2-3.    SAIL   programs   are  organized  in  the  traditional  block
structure of ALGOL-60.
   
   
2-4.    Declarations serve to define the data types and dimensions of
simple  and  subscripted  (array)  variables  (arithmetic  variables,
strings, sets, and items).  They are also used to describe procedures
(subroutines)  and  name  program  labels.  The DEFINE construct (see
DECLARATIONS,  3-1,  USE  OF  DEFINE,  13-0)  may  also   appear   in
declarations.
SAILON NO. 57.2					SAIL   2-5

   
   
2-5.    Any  identifier referred to in a program must be described in
some declaration.  An identifier may only be referenced by statements
within the scope (see Scope of declarations, 3-8) of its declaration.
   
   
Statements
   
   
2-6.    As  in  ALGOL,  the  statement  is  the  fundamental  unit of
operation in the SAIL language.  Since a statement within a block  or
compound  statement  may itself be a block or compound statement, the
concept of statement must be understood recursively.
   
   
2-7.    This definition of a block as a statement has  virtues  other
than  its  syntactic  niceness.   In  many  ways a block behaves as a
single complex statement; most importantly, no transfers (jumps)  may
be  made  to  any statement within it except the first (There are now
(unfortunately?)  exceptions,  see  Go  To  Statements,  5-8).   This
assures  proper  allocation  and initialization of the data space for
the block.
   
   
2-8.    The  block  representing  the  program  is   known   as   the
"outer block".   All  blocks internal to this one will be referred to
as "inner blocks".
   
   
	Block Names
   
   
2-9.    The block name  construct  is  used  to  describe  the  block
structure  of  a  SAIL  program  to a symbolic debugging routine (see
DEBUGGING, 15-9).  The name of the outer block becomes the  title  of
the  binary output file (not necessarily the file name).  In addition,
if a block name is used following an END, the  compiler  compares  it
with  the  block  name  which  followed  the  corresponding BEGIN.  A
mismatch is reported to the user as evidence  of  a  missing  (extra)
BEGIN  or  END somewhere.  The block name is also used in conjunction
with the DONE, NEXT, and CONTINUE  statements  (see  Done  Statement,
5-24 and following).
   
   
2-10.    The <stringconstant> <statement> construct is equivalent in
action to the <statement> alone; that is, the string constant  serves
only as a comment.
SAILON NO. 57.2					SAIL   2-10

   
   
Entry Specifications
   
   
2-11.    See Separately Compiled Procedures, 16-7.
SAILON NO. 57.2					SAIL   3-1
	
                              SECTION 3
                                    
                             DECLARATIONS
                                    
   
   
SYNTAX
   
   
3-1.    

<idlist>                ::= <identifier>
                         ::= <identifier> , <idlist> 
   
   

<declaration>            ::= <typedeclaration>
                         ::= <arraydeclaration>
                         ::= <preloadspecification>
                         ::= <labeldeclaration>
                         ::= <proceduredeclaration>
                         ::= <definespecification>
                         ::= <synonymdeclaration>
                         ::= <requirement> 
   
   

<type>                   ::= <algebraictype>
                         ::= <leaptype>
                         ::= <algebraictype> <leaptype>
                         ::= <algebraictype> ARRAY <leaptype>
                         ::= SET
                         ::= SET <leaptype>
                         ::= SET ARRAY <leaptype>
                         ::= <typequalifier> <type> 

<algebraictype>         ::= REAL
                         ::= INTEGER
                         ::= BOOLEAN
                         ::= STRING 

<leaptype>              ::= ITEM
                         ::= ITEMVAR 
SAILON NO. 57.2					SAIL   3-1


<typequalifier>         ::= EXTERNAL
                         ::= INTERNAL
                         ::= SAFE
                         ::= FORWARD
                         ::= RECURSIVE
                         ::= FORTRAN
                         ::= OWN
                         ::= SHORT 
   
   

<typedeclaration>       ::= <type> <idlist> 
   
   

<arraydeclaration>      ::= <type> ARRAY <arraylist> 

<arraylist>             ::= <arraysegment>
                         ::= <arraylist> , <arraysegment> 

<arraysegment>          ::= <idlist> [ <boundpairlist> ] 

<boundpairlist>        ::= <boundpair>
                         ::= <boundpairlist> , <boundpair> 

<boundpair>             ::= <lowerbound> : <upperbound> 

<lowerbound>            ::= <algebraicexpression> 

<upperbound>            ::= <algebraicexpression> 

<preloadspecification>  ::= PRELOADWITH <preloadlist> 

<preloadlist>           ::= <preloadelement>
                         ::= <preloadlist> , <preloadelement> 

<preloadelement>        ::= <expression>
                         ::= [expression] <expression> 
   
   

<labeldeclaration>      ::= LABEL <idlist> 
   
   
SAILON NO. 57.2					SAIL   3-1


<proceduredeclaration>  ::= PROCEDURE <identifier> <procedurehead> 
                                <procedurebody>
                         ::= <type> PROCEDURE <identifier> 
                                <procedurehead> <procedurebody> 

<procedurehead>         ::= <empty>
                         ::= ( <formalparamdecl> ) 

<procedurebody>         ::= <empty>
                         ::= ; <statement> 

<formalparamdecl>      ::= <formalparameterlist>
                         ::= <formalparameterlist> ; 
                                <formalparamdecl> 

<formalparameterlist>  ::= <formaltype> <idlist> 

<formaltype>            ::= <simplerformaltype>
                         ::= REFERENCE <simplerformaltype>
                         ::= VALUE <simplerformaltype> 

<simplerformaltype>    ::= <type>
                         ::= <type> ARRAY
                         ::= <type> PROCEDURE 
   
   

<definespecification>   ::= DEFINE <definitionlist> 

<definitionlist>        ::= <definition>
                         ::= <definition> , <definitionlist> 

<definition>             ::= <defineidentifier> = <definebody> 

<defineidentifier>      ::= <identifier>
                         ::= <identifier> ( <idlist> ) 

<definebody>            ::= <stringconstant> 

<synonymdeclaration>    ::= LET <synonymlist> 

<synonymlist>           ::= <synonym>
                         ::= <synonymlist> , <synonym> 

<synonym>                ::= <identifier> = <reservedword> 

<requirement>            ::= REQUIRE <requirelist> 
SAILON NO. 57.2					SAIL   3-1


<requirelist>           ::= <requireelement>
                         ::= <requirelist> , <requireelement> 

<requireelement>        ::= <arithmeticconstant> <spacespec>
                         ::= <stringconstant> <filespec> 

<spacespec>             ::= STRINGSPACE
                         ::= SYSTEMPDL
                         ::= STRINGPDL
                         ::= ARRAYPDL
                         ::= NEWITEMS
                         ::= PNAMES 

<filespec>              ::= LOADMODULE
                         ::= LIBRARY
                         ::= SOURCEFILE
                         ::= SEGMENTFILE
                         ::= SEGMENTNAME 
   
   
   
RESTRICTIONS
   
   
3-2.    For  simplicity,  the  typequalifiers are listed in only one
syntactic class.  Although their uses are always  valid  when  placed
according  to  the  above syntax, most of them only have meaning when
applied to particular subsets of these productions:
   
   SAFE is only meaningful in array declarations
   INTERNAL/EXTERNAL  have  no   meaning   in   formal   parameter
   declarations
   FORWARD,  RECURSIVE, and FORTRAN have meaning only in procedure
   type specifications.
   ITEM ARRAYS and PROCEDURES do not exist (use ITEMVAR).
   SHORT  has  meaning  only  when  applied  to  INTEGER  or  REAL
   entities.
   
   
3-3.    For   array   declarations  in  the  outer  block  substitute
<constantexpression> for <algebraicexpression> in  the  productions
for <lowerbound> and <upperbound>.
   
   
3-4.    A  label must be declared in the innermost block in which the
statement being labeled appears.
SAILON NO. 57.2					SAIL   3-5

   
	   
3-5.    The  syntax  for  procedure  declarations  requires  semantic
embellishment  (see  Procedure  Declarations,  3-38) in order to make
total sense.  In particular, a procedure body may be empty only in  a
restricted class of declarations.
   
   
EXAMPLES
   
   
3-6.    Let I,J,K,L,X,Y, and P be identifiers, S a statement:
   
(<typedeclaration>)       INTEGER I,J,K
                           EXTERNAL REAL X,Y
                           ITEM I
                           SET P
                           ITEMVAR X
                           REAL ITEM Y
                           INTEGER ARRAY ITEM J[X:Y]
                           INTERNAL STRING K
   
   
(<arraydeclaration>)      INTEGER ARRAY X[0:10,0:10]
                           REAL ARRAY Y[X:P(L)]; Comment illegal
                               in outer block
                           STRING ARRAY I[0:IF BIG THEN 30 ELSE 3]
                           ITEMVAR ARRAY K[0:5,1:L]
                           REAL ARRAY ITEMVAR ARRAY P[0:15]
   
   
(<labeldeclaration>)      LABEL L,X,Y
   
   
(<procedure declaration>)  PROCEDURE P; S
                           PROCEDURE P(INTEGER I,J;
                               REFERENCE REAL X; REAL Y) ; S
                           INTEGER PROCEDURE P (REAL PROCEDURE L;
                               STRING I,J; INTEGER ARRAY K); S
                           EXTERNAL PROCEDURE P(REAL X)
                           FORWARD INTEGER PROCEDURE X(INTEGER I)
                           FORTRAN REAL PROCEDURE SIN
   
   
(<definespecification>)   DEFINE CR="'15", LF="'12",
                               CRLF = "(CR&LF)",
                               TTY="1",
                               TYPE(MSG)="OUT(TTY,MSG&CRLF)"
SAILON NO. 57.2					SAIL   3-7

   
   
3-7.    Note that these sample declarations are all given without the
semicolons  which  would  normally separate them from the surrounding
declarations and statements.  Here is a sample block to bring it  all
together (again, let S be any statement, D any declaration, and other
identifiers as above:
   

BEGIN "SAMPLE BLOCK"
 INTEGER I,J,K; 
 REAL X,Y;
 STRING A;
 INTEGER PROCEDURE P(REFERENCE REAL X; REAL Y);
  BEGIN
   D; D; D; ... ;S; ... ; S
  END "P";

 REAL ARRAY DIPHTHONGS[0:10,1:100];

 S;  S;  S;  S
END "SAMPLE BLOCK"

   
   
SEMANTICS
   
Scope of declarations
   
   
3-8.    Every  block  automatically  introduces  a   new   level   of
nomenclature.   Any  identifier declared in a block's head is said to
be LOCAL to that block.  This means that:
   
  a.  The entity represented by this identifier inside  the  block
      has no existence outside the block.
         
  b.   Any  entity  represented by the same identifier outside the
      block is completely inaccessible (unless it has been  passed
      as a parameter) inside the block.
   
   
3-9.    An  identifier  occurring  within  an  inner  block  and  not
declared within that block will be nonlocal (global) to it; that  is,
the identifier will represent the same entity inside the block and in
the block or blocks within which it is nested, up  to  and  including
the level in which the identifier is declared.
SAILON NO. 57.2					SAIL   3-10

   
   
3-10.    The  Scope  of  an  entity is the set of blocks in which the
entity is represented, using the above rules, by its identifier.   An
entity may not be referenced by any statement outside its scope.
   
   
Type Declarations
   
   
3-11.    SAIL  reserves  either  one  or  two  36-bit  words for each
identifier appearing in a type declaration (exception -- no space  is
reserved for items -- see Item Declarations, 3-18).  The use of these
cells falls into two classes -- values and descriptors  --  depending
on  the type preceding the identifier.  If an identifier represents a
REAL or INTEGER (BOOLEAN) variable or an ITEMVAR, its value is stored
directly  in  the  reserved  cell.   For strings (2 words, see String
Declarations, 3-15) and sets (1 word,  see  Set  Declarations,  3-24)
internal descriptors are placed in the reserved cells which allow the
running program to access these entities.  These differences are  not
reflected  in  the  SAIL syntax.  The user may treat entities of both
kinds as if their values were directly  accessible  in  the  reserved
locations.   For this reason we will henceforth refer synonymously to
a simple identifier (one declared in  a  type  declaration)  and  the
simple variable it represents, as a "variable".
   
   
3-12.    Items  do  not  entirely  conform to the structure described
above.  Please suppress any  enpuzzlement  concerning  the  roles  of
items  and  itemvars  until after you have read the paragraph on Item
Declarations, 3-18.
   
   
Numeric Declarations
   
   
3-13.    Identifiers which appear in  type  declarations  with  types
REAL  or  INTEGER  can  subsequently  be  used  to  refer  to numeric
variables.  An Integer variable may take  on  values  from  -2^35  to
2^35-1  (-2^26  to  2^26-1  for SHORT INTEGERS).  A Real variable may
take on positive and negative values from about 10^-38 to 10^38  with
a  precision  of  27  bits  (same  range for SHORT REALs as for SHORT
INTEGERs.  REAL and INTEGER variables (and constants) may be used  in
the  same  arithmetic  expressions;  type conversions are carried out
automatically (see Arithmetic  Type  Conversions,  9-21  below)  when
necessary.
SAILON NO. 57.2					SAIL   3-14

   
   
3-14.    The  BOOLEAN type is currently identical to INTEGER.  As you
will see, BOOLEAN and algebraic  expressions  are  really  equivalent
syntactically.  The syntactic context in which they appear determines
their meaning.  Algorithms for determining the Boolean and  algebraic
interpretations  of  these  expressions  will  be given below.  The
declarator BOOLEAN is included for program clarity.
   
   
String Declarations
   
   
3-15.    A variable defined in a String  declaration  is  a  two-word
descriptor  containing  the information necessary to represent a SAIL
character string.
   
   
3-16.    A  String  may  be  thought   of   as   a   variable-length,
one-dimensional  array  of  7-bit  ASCII  characters.  Its descriptor
contains a character count and a byte pointer to the first  character
(see STRINGS, 17-15).  Strings originate as constants at compile time
(String Constants, 11-19), as the result of a String INPUT  operation
from  some  device  (see  Input, 12-40), or from the concatenation or
decomposition  of  already  existing   strings   (see   Concatenation
Operator, 9-38 and Substrings, 9-42).
   
   
3-17.    When  strings appear in arithmetic operations or vice-versa,
a somewhat arbitrary conversion is performed  to  obtain  the  proper
type   (by   arbitrary  we  do  not  mean  to  imply  random  --  see
String-Arithmetic Conversions, 9-27).  For this reason arithmetic and
String  variables  are referred to as "algebraic variables" and their
corresponding  expressions  are   called   "algebraic   expressions".
(Suggestions  for  a  better term will be given a high priority).  No
other direct,  or  "forced",  conversions  (except  for  Integer/Real
conversions) are present in the language.
SAILON NO. 57.2					SAIL   3-18

   
   
Item Declarations
   
Prerequisite
   
   
3-18.    Please  make  no  attempt to understand the sections of this
manual describing the associative capabilities of the  SAIL  language
until  you  have  read  the  article  describing  its basic flavor in
[Feldman&Rovner].  If you do not have access to a copy of  the  CACM,
reprints   are   available  from  the  authors.   The  structure  and
operations of the associative portions of LEAP and SAIL are so nearly
identical  that  it  seemed  foolish  to repeat them completely here.
However, a full description of the syntax and a brief  discussion  of
each construct is given here.
   
   
Items
   
   
3-19.    The  "Associative  memory" of the SAIL system is constructed
from a universe of items and a universe of associations  among  these
items.   An Item is an entity which is represented inside the machine
by its internal name and is otherwise uninterpreted.   Items  may  be
combined  to  form  "associations"  which express facts (see Triples,
7-6).   They  may  also  be  collected  into  unordered   sets   (Set
Declarations, 3-24).
   
   
Item Genesis
   
   
3-20.    The   universe  of  items  is  divided  into  three  classes
differing in the way an Item enters it:

  1)   A  declared  Item  results  from  each  declaration  of  an
      identifier  to  be  of  type ITEM.  The declaration causes a
      single internal name to be created for the  item.   Declared
      items  do  not  obey the usual rules in recursive functions.
      In particular, items behave as if they were declared in  the
      outer  block.   Although  they  may referred to by name only
      within  the  scope  of  their  declarations  (see  Scope  of
      declarations,  3-8),  they  may be accessed from outside the
      scope if they have been included in (and not  removed  from)
      any  associations or sets, or assigned to itemvars which are
      still accessible.  They are not deleted at  block-exit.   It
	      might   be  helpful  to  think  of  declared  items  as  the
      associative analogue of algebraic constants.
SAILON NO. 57.2					SAIL   3-20


  2)   A  created  Item  results  from  the  execution  of  a  NEW
      expression  (see  NEW Items, 10-6).  Any created Item may be
      deleted from the  universe  of  items  (see  DELETE,  7-10).
      Again,  usual  block  structure  rules  do  not apply to any
      items.

  3)   An  association  Item  results  from  the  execution  of  a
      bracketed  construction triple (see Construction - Retrieval
      Distinction, 7-8).  These may also be explicitly, but  never
      automatically, deleted.
   
   
Datums
   
   
3-21.    An  Item  of  type  1)  or  2)  may have an associated value
(Datum) of algebraic or SET type which can be used  or  altered  like
any  other  variable.   This  Datum  may  represent a simple or array
variable of any type except ITEM or ITEMVAR.  Datums may be  referred
to by use of the DATUM operator (see Datums, 11-6, Datum Assignments,
4-7).
   
   
Itemvar Declarations
   
   
3-22.    An Itemvar is a variable whose value is an  Item  (it  is  a
reference  to  an Item).  Just as the statements "X_3; A_X" and "A_3"
are equivalent with respect to A, the  statements  "X_EDGE; A_X"  and
"A_EDGE"  are  equivalent with respect to A, if X and A are itemvars,
EDGE an item.  The use of an Itemvar is equivalent to the use of  the
Item  to  which  it  refers.   The  difference is, of course that the
Itemvars may represent different Items at different times.
   
   
3-23.    Just as algebraic variables may be bound as  loop  variables
in  FOR statements, Itemvars observe a special binding in the FOREACH
statement.  This very important construct  is  described  in  FOREACH
Statement, 7-15 below.
SAILON NO. 57.2					SAIL   3-24

   
   
Set Declarations
   
   
3-24.    Because  the  answers  to  many  associative  questions  are
many-valued (all the sons of Harry, for example), sets of  Items  are
provided.   A SAIL Set is an unordered collection of Items containing
at most one occurrence of any  single  Item.   The  more  common  Set
operations are available for convenient manipulation of Sets.
   
   
Array Declarations
   
   
3-25.    In  general,  any  data type which is applicable to a simple
variable may be applied in  an  Array  declaration  to  an  array  of
variables.   Note,  however,  the restriction (see RESTRICTIONS, 3-2)
prohibiting  ITEM  ARRAY  X  as  a  legal  declaration   (Items   are
"constants"),  although  ITEMVAR  Arrays  are  allowed.   The  entity
represented by  the  name  of  an  Array,  qualified  with  subscript
expressions  to locate a particular element (e.g.  A[I,J]) behaves in
every way like a simple variable.  Therefore, in the future we  shall
refer  to  both  simple  variables  and  single  elements  of  Arrays
(subscripted  variables)  as  "variables".   The  formal  syntax  for
<variable> can be found in Variables, 11-2.
   
   
3-26.    Each  subscript  for  an Array which is not qualified by the
SAFE attribute will be checked to ensure that  it  falls  within  the
lower  and  upper  bounds  given  for the dimension it specifies.  An
overflow triggers an  error  message  and  job  abortion.   The  SAFE
declaration inhibits this checking, resulting in faster, smaller, and
bolder code.
   
   
3-27.    Arrays are stored by rows.  That is, if A[I,J] is stored  in
location 10000, then A[I,J+1] is stored in location 10001.
   
   
3-28.    There is no limit to the number of dimensions allowed for an
Array.  However, the efficiency of Array references tends to decrease
for  large  dimensions.   Avoid  large  dimensionality  if  it is not
necessary.
SAILON NO. 57.2					SAIL   3-29

   
   
3-29.    The Item instances stored  in  an  Itemvar  Array  may  have
datums which are themselves algebraic or Set Arrays.  This provides a
good deal of power,  since  an  Array  of  algebraic  values  can  be
dynamically associated with any Item.
   
   
3-30.    OWN  Arrays  are  available  in part.  They must be declared
	with constant bounds, since fixed  storage  is  allocated  for  these
Arrays.   They  are  initialized to zero when the block in which they
are declared is entered (except  in  preloaded  Arrays,  see  Preload
Specifications,  3-33).   A  certain  degree  of  extra efficiency is
possible in accessing  these  Arrays,  since  they  may  be  assigned
absolute  core  locations  by  the  compiler, eliminating some of the
address arithmetic.  Constant bounds always add a little  efficiency,
even in inner blocks.
   
   
3-31.    Arrays  declared  in  the  outer  block  must  have constant
bounds, since no variable may yet have been assigned a  value.   They
are thus automatically made OWN.
   
   
3-32.    For more details concerning the internal structure of Arrays
see DEBUGGING, 15-9, Separately Compiled Procedures, 16-7  and  ARRAY
IMPLEMENTATION, 17-35.
   
   
Preload Specifications
   
   
3-33.    Any  OWN arithmetic or String Array may be "pre-loaded" with
constant  information   by   preceding   its   declaration   with   a
<preloadspecification>.   This  specification gives the values which
are to be placed in consecutive  core  locations  within  all  Arrays
declared    immediately    following   the   <preloadspecification>.
"Immediately",  in  this  case,  means  all  identifiers  up  to  and
including one which is followed by boundpairlist brackets (e.g.  in
REAL ARRAY X,Y,Z[0:10],W[1:5]; -- preloads X,Y, and Z; not W).  It is
the user's responsibility to guarantee that the proper values will be
obtained under the subscript mapping.
   
	   
3-34.    The original values of pre-loaded Arrays will not be lost by
restarting   the   program   (most  Arrays  are  cleared  when  their
declarations are processed), but  they  will  not  be  re-initialized
either.  The values can be changed by assignment statements.
SAILON NO. 57.2					SAIL   3-35

   
   
3-35.    For  String Arrays, the original pre-loaded values remain if
not changed by assignment statements.  In  general,  however,  String
Array   elements  whose  values  have  been  changed  during  program
executions will be set to null strings when the program is restarted.
   
   
3-36.    Algebraic type conversions will be performed at compile-time
to  provide  values  of  the  proper types to pre-loaded Arrays.  All
expressions in these specifications must be constant  expressions  --
that  is,  they  must contain only constants and algebraic operators.
The compiler will not allow you to fill an Array beyond its capacity.
You  may,  however,  provide a number of elements less than the total
size of the Array; remaining elements will be set to zero or  to  the
null string.
   
   
Example
   
   
3-37.    


  PRELOADWITH [5] 0, 3, 4, [4] 6, 2;
  INTEGER ARRAY TABL[1:4,1:3];

The  first  five elements of TABL will be initialized to 0 (bracketed
number is used as a repeat argument).  The next two elements will  be
3  and  4,  followed  by  four 6's and a 2.  The array will look like
this:


        1  2  3

    1   0  0  0
    2   0  0  3
    3   4  6  6
    4   6  6  2

SAILON NO. 57.2					SAIL   3-38

   
   
Procedure Declarations
   
   
3-38.    If a Procedure is typed, it may return a value  (see  Return
Statement,  5-20)  of  the  specified type.  If formal parameters are
specified, they must be supplied with actual parameters in a  one  to
one  correspondence  when  they are called (see Function Designators,
9-47 and Procedure Statements, 6-2).
   
   
Formal Parameters
   
	   
3-39.    Formal parameters, when specified,  provide  information  to
the  body  (executable  portion)  of the Procedure about the kinds of
values which will be provided as actual parameters in the call.   The
type  and  complexity  (simple  or  Array)  are  specified  here.  In
addition, the formal parameter indicates whether the value (VALUE) or
address (REFERENCE) of the actual parameter will be supplied.  If the
address is supplied, the variable whose  identifier  is  given  as  an
actual  parameter  may  be changed by the Procedure.  This is not the
case if the value is given.
   
   
3-40.    To pass a PROCEDURE by value or an ITEM by reference has  no
readily  determined  meaning.   ARRAYs  passed  by value (requiring a
complete copy operation) have not yet  been  implemented.   Therefore
these cases are noted as errors by the compiler.
   
   
3-41.    The  proper use of actual parameters is further discussed in
the paragraphs on Procedure Statements, 6-2 and Function Designators,
9-47.
SAILON NO. 57.2					SAIL   3-42

   
   
Forward Procedure Declarations
   
   
3-42.    A  Procedure's  type and parameters must be described before
the Procedure may  be  called.   Normally  this  is  accomplished  by
specifying  the  procedure  declaration  in  the  head  of some block
containing the call.  If,  however,  it  is  necessary  to  have  two
Procedures, declared in some block head, which are both accessible to
statements in the compound tail of that block and to each other,  the
FORWARD construct permits the definition of the parameter information
for one of these Procedures  in  advance  of  its  declaration.   The
Procedure  body  must  be  empty  in a forward procedure declaration.
When the body of the Procedure described in the  forward  declaration
is  actually  declared,  the  types  of  the  Procedure  and  of  its
parameters must be identical in both declarations.  The  declarations
must appear at the same level (within the same block head).
SAILON NO. 57.2					SAIL   3-43

   
   
Example
   
   
3-43.    
   
BEGIN "NEED FORWARD"
   FORWARD INTEGER PROCEDURE T1(INTEGER I); COMMENT PARAMS DESCRIBED;
   
   INTEGER PROCEDURE T2(INTEGER J);
       RETURN (T1(J)+3); COMMENT CALL T1 ;
   
   INTEGER PROCEDURE T1 (INTEGER I); COMMENT ACTUALLY DEFINE T1;
       RETURN (IF I=15 THEN I ELSE T2(I-1)); COMMENT CALLS T2;
   
...
   
K_T1(L); ...  ; L_T2(K); ...
   
END "NEED FORWARD";
   
Notice that the forward declaration is  required  only  because  BOTH
Procedures  are  called  in  the body of the block.  These procedures
should also be declared RECURSIVE if recursive  entrance  is  likely.
If only T1 were called from statements within the block, this example
could be implemented as:
   
BEGIN "NO FORWARD"
   RECURSIVE INTEGER PROCEDURE T1(INTEGER I);
   BEGIN
       INTEGER PROCEDURE T2(J);
           RETURN (T1(J)+3);
   
       RETURN( IF I=15 THEN I ELSE T2(I-1));
   END "T1";
   
...
   K_T1(L);
...
END "NO FORWARD";
   
SAILON NO. 57.2					SAIL   3-44

   
   
Recursive Procedures
   
   
3-44.    If a Procedure is to be entered  recursively,  the  compiler
must  be  instructed  to  provide code for saving its local variables
when the Procedure is called and restoring them when it returns.  Use
the  type-qualifier  RECURSIVE  in  the  declaration of any recursive
Procedure.
   
   
3-45.    The compiler  can  produce  much  more  efficient  code  for
non-recursive  Procedures than for recursive ones.  We feel that this
gain in efficiency merits the necessity for declaring  Procedures  to
be recursive.
   
   
3-46.    If  a  Procedure  which  has  not been declared recursive is
called recursively, all its local variables  (and  temporary  storage
locations  assigned  by  the  compiler)  will  behave as if they were
global to the Procedure -- no values will be saved.  Otherwise no ill
effects should be observed.
   
   
External Procedures
   
   
3-47.    A  file  compiled by SAIL represents either a "main" program
or a collection of independent procedures to be called  by  the  main
program.  The method for preparing such a collection of Procedures is
described in Separately Compiled Procedures, 16-7.  The EXTERNAL  and
FORTRAN  type-qualifiers  allow  description  of  the  types of these
Procedures and their parameters.  An EXTERNAL  or  FORTRAN  procedure
declaration,  like  the  FORWARD  declaration,  does  not  include  a
procedure body.  Both declarations instead result in requests to  the
loader to provide the addresses of these Procedures to all statements
which call them.  This means that an EXTERNAL  Procedure  declaration
(or  the declaration of any External identifier) may be placed within
any block head,  thereby  controlling  the  scope  of  this  External
identifier within this program.
   
   
3-48.    Any  SAIL  Procedure  which is referenced via these external
declarations  must  be  an  INTERNAL   Procedure.    That   is,   the
type-qualifier  INTERNAL must appear in the actual declaration of the
Procedure.  Again, see Separately Compiled Procedures, 16-7.
SAILON NO. 57.2					SAIL   3-49

   
   
3-49.    The type-qualifier FORTRAN is used to describe the type  and
name  of  an  external  Procedure  which  is to be called using a DEC
Fortran calling sequence.  All parameters to Fortran  Procedures  are
by  reference.   In  fact, the procedure head part of the declaration
need not be included unless  the  types  expected  by  the  Procedure
differ  from  those  provided by the actual parameters--the number of
parameters supplied, and their types, are presumed correct.   Fortran
Procedures  are  automatically External Procedures.  See Restrictions
on Procedure Declarations, 3-54, Procedure Statements, 6-2,  Function
Designators, 9-47 for more information about Fortran Procedures.
   
   
Example:
   
   
3-50.    
FORTRAN PROCEDURE MAX;
Y_MAX(X,Z);
   
   
Parametric Procedures
   
   
3-51.    The  calling  conventions  for Procedures with Procedures as
arguments, and for the execution of these parametric Procedures,  are
described  in  Procedure  Statements,  6-2  and Function Designators,
9-47.  Any Procedure PP which is to be used as a parameter to another
Procedure  CP must not have any Procedure or array parameters, or any
parameters called by value.  In other words, PP may only have  simple
reference parameters.  The number of parameters supplied in a call on
PP within CP, and their types, will be presumed correct.
SAILON NO. 57.2					SAIL   3-52

   
   
Example
	   
   
3-52.    

PROCEDURE CP (INTEGER PROCEDURE FP);
BEGIN INTEGER A,I; REAL X;
 ...
 A_FP(I,X); COMMENT I AND X PASSED BY REFERENCE,
	    NO TYPE CONVERSION;
END "CP";

INTEGER PROCEDURE PP (REFERENCE INTEGER J; REFERENCE REAL Y);
BEGIN
 ...
END "PP";

...

CP(PP);

   
   
Defaults in Procedure Declarations
   
   
3-53.    If no  VALUE  or  REFERENCE  qualification  appears  in  the
description, the following qualifications are assumed:
                  

VALUE          Variables -- simple  INTEGER,  STRING,  ITEM,  ITEMVAR
               declarations.

REFERENCE      Arrays and Procedures.
   
   
Restrictions on Procedure Declarations
   
   
3-54.    

1)  The scope of a formal  parameter  for  a  Procedure  P  does  not
    include  statements within any Procedure Q declared within P.  In
    other words, Q may refer only to its own formal  parameters.   It
    may,  however,  refer to variables which are local to some global
    Procedure.  Here is an example:
SAILON NO. 57.2					SAIL   3-54



PROCEDURE P1(INTEGER I);
BEGIN INTEGER J;
 PROCEDURE P2(INTEGER K);
 BEGIN
  INTEGER L;
  L_I; COMMENT THIS IS WRONG -- WON'T WORK;
  L_J; COMMENT THIS IS ALL RIGHT;
  L_K; COMMENT CLEARLY ALL RIGHT;
  ...


2)  There is no such thing as an ITEM Procedure (use ITEMVAR).

3)   Fortran  Procedures  can  not  handle  String,  Set,   or   Item
    parameters.   Nor  can  a  Fortran  Procedure return any of these
    types as a result.

4)  Go To Statements appearing in  a  Procedure  body  may  not  name
    statements outside that Procedure body as targets.

5)  Labels may never be passed as arguments to Procedures.
   
   
Synonyms
   
   
3-55.    The declaration `LET BEG=BEGIN' would tell the compiler that
BEG is now a reserved word with the same meaning as BEGIN.  BEGIN can
subsequently  be  DEFINEd  or  declared  as  something  else  without
eliminating  the  opening  of  new  blocks (use BEG for BEGIN).  This
synonymity applies only over the scope of the declaration, as usual.
   
   
Define Specification
   
   
3-56.    See the section on  USE  OF  DEFINE,  13-0  for  a  complete
discussion.
   
   
Requirements
   
   
3-57.    The  user  may,  using the REQUIRE construct, specify to the
compiler  conditions  which  are  required  to   be   true   of   the
execution-time  environment  of  his programs.  The requirements fall
into two classifications, described as follows:
SAILON NO. 57.2					SAIL   3-57

   
   
Group 1 -- Space requirements -- STRINGSPACE, SYSTEMPDL, etc.
   
   
3-58.    The   inclusion   of   the   specification   "REQUIRE   1000
STRINGSPACE" will ensure that at least 1000 words of storage will be
available for storing Strings  when  the  program  is  run.   Similar
provisions  are  made  for  various  push-down  stacks  used  by  the
execution-time routines and the compiled code.   If  a  parameter  is
specified twice, or if separately compiled procedures are loaded (see
Separately  Compiled  Procedures,  16-7),  the  sum   of   all   such
specifications will be used.  These parameters could also be typed to
the loaded program just before  execution  (see  STORAGE  ALLOCATION,
14-22),  but  it is often more convenient to specify differences from
the standard sizes in the source program.  Use  these  specifications
only  if messages from the running program indicate that the standard
allocations are not sufficient.  "REQUIRE  300  NEWITEMS"  specifies
that  300  is a reasonable estimate of the number of items which will
be created dynamically using the NEW construct.  "REQUIRE 100 PNAMES"
will  allow up to 100 print names to be dynamically assigned to items
(see NewPname, 12-88, Cvis, 12-84 and following).   PNAMES  are  not
available at all unless some number are "REQUIREd".
   
   
Group 2 -- Other files -- LOADMODULE, LIBRARY, SOURCEFILE, etc.
   
   
3-59.        The    inclusion    of    the    specification
REQUIRE "PROCS1" LOADMODULE, "HELIB[1,3]" LIBRARY; would inform  the
Loader  that  the  file  PROCS1.REL  must  be  loaded and the library
HELIB.REL[1,3]  searched  whenever   the   program   containing   the
specification is loaded.  The parameter for both features should be a
string constant of one of the above forms.  The device DSK, and  file
extension  .REL  are the only values permitted for these entries, and
are therefore assumed.
   
   
3-60.    LOADMODULES  (.REL  files  to  be  loaded)  may  themselves
contain  requests  for other LOADMODULES and LIBRARYs.  LIBRARYs may
only contain requests for other LIBRARYs.   Duplicate  specifications
are  in  general  merged into single requests (if a file is requested
twice, it will be loaded only once).
   
   
3-61.    SAIL  automatically  places  a  request  for   the   library
"LIBSAI[1,3]"  in  each  main  program.   This  library  contains the
execution-time routines.
SAILON NO. 57.2					SAIL   3-62

   
	   
3-62.    The inclusion of  REQUIRE "SYS:PREAMB.SAI" SOURCEFILE  (or,
perhaps,  ... "PREAMB.SAI[1,3]" ...)  will cause the compiler to save
the state of the current input file, then begin scanning from PREAMB.
When PREAMB is exhausted, SAIL will resume scanning the original file
on the line directly following  the  REQUIRE.   SOURCEFILEs  may  be
nested to a depth of about 10 levels.
   
   
3-63.    Restrictions:  A  SOURCEFILE  request must be followed by a
semicolon (only one per REQUIREment), and must be the  last  text  on
the  line  in  which  it  appears.  SOURCEFILE switching must not be
specified from within a DEFINE body.
   
   
3-64.    The SEGMENTNAME, SEGMENTFILE specifications are  currently
applicable  only  to the Stanford "global model" users of SAIL.  They
allow specification of the name of a  special  non-sharable  "HISEG",
and  the  name  of  the  file  used  to  create  this  HISEG.   These
specifications may, like the space  REQUIREments,  be  overridden  by
using the system REENTER command (see STORAGE ALLOCATION, 14-22).
	   
   
Comment
   
   
3-65.    You  have  probably  noticed  that  a  great  deal  of prior
knowledge is required for proper understanding of this section.   For
more information about PNAMES see Cvis, 12-84 and following.  Storage
allocation is discussed in STORAGE ALLOCATION, 14-22 below.  The form
and  use  of  .REL files and libraries are described in "The Stanford
A-I Project Monitor Manual" [Moorer] and [Weiher].
SAILON NO. 57.2					SAIL   4-1

                              SECTION 4
                                    
                        ASSIGNMENT STATEMENTS
                                    
   
   
SYNTAX
   
   
4-1.    

<assignment>             ::= <assignmentstatement>
                         ::= <swapstatement> 

<assignmentstatement>   ::= <algebraicassignment>
                         ::= <itemassignment>
                         ::= <setassignment> 

<algebraicassignment>   ::= <algebraicvariable> _ 
                                <algebraicexpression> 

<itemassignment>        ::= <itemvarvariable> _ 
                                <constructionitemexpression> 

<setassignment>         ::= <setvariable> _ 
                                <constructionsetexpression> 
   
   

<swapstatement>         ::= <variable>  <variable> 
   
   

<bytestatement>         ::= DPB (algebraicexpression , 
                                <algebraicexpression> )
                         ::= IDPB (algebraicexpression , 
                                <algebraicvariable> )
                         ::= IBP (algebraicvariable) 
   
   
   
RESTRICTION
   
   
4-2.    If the operator is , the expression (of  whatever  kind)  on
the  right  hand  side  must  be a simple or subscripted variable, or
DATUM(<itemprimary>).   The    operator  may  not  be  used  in  an
assignment expression (see Assignment Expressions, 9-4).  It is valid
only at statement level.
SAILON NO. 57.2					SAIL   4-2

   
   
SEMANTICS
   
   
4-3.    The assignment statement causes the value represented  by  an
expression  to  be  assigned to the variable appearing to the left of
the  assignment  symbol.   You  will  see   later   (see   Assignment
Expressions,  9-4)  that  one  value  may  be assigned to two or more
variables through the use of two or  more  assignment  symbols.   The
operation  of  the  assignment  statement  proceeds  in the following
order:

a)     The subscript expressions of the  left  part  variable  (if
       any)  are  evaluated  from  left  to  right (see Expression
       Evaluation Rules, 9-14).

b)     The expression is evaluated.

c)     The value of the expression is assigned to  the  left  part
       variable, with subscript expressions, if any, having values
       as determined in step a.
   
   
4-4.    This ordering  of  operations  may  usually  be  disregarded.
However  it becomes important when expression assignments (Assignment
Expressions, 9-4) or function calls with reference parameters  appear
anywhere in the statement.  For example, in the statements
   
    I_3;
    A[I]_3+(I_1);
   
A[3]  will  receive  the  value  4  using the above algorithm.  If no
subscript calculations were  performed  until  after  the  expression
evaluation, A[1] would become 4.  Be careful.
   
   
4-5.    As  the  syntax implies, if the left part variable is of type
Itemvar the  value  to  be  assigned  must  be  a  construction  Item
expression.  Similarly for Sets.
   
   
4-6.    However,  any  algebraic expression (REAL, INTEGER (BOOLEAN),
or STRING) may be assigned to any variable of  algebraic  type.   The
resultant  type  will  be  that  of  the  left  part  variable.   The
conversion rules for assignments involving  mixed  types  are  mildly
amusing.   They  are  identical to the conversion rules for combining
mixed types in algebraic expressions (see Arithmetic Type Conversions,
9-21, String-Arithmetic Conversions, 9-27 below).
SAILON NO. 57.2					SAIL   4-6

   
   
Datum Assignments
   
   
4-7.    The algebraic or Set value associated with an Item is changed
using an assignment statement in which the left part is  a  the  word
DATUM  operating  on  an  Item  Primary.  This is valid syntactically
because the syntax for <variable> (see Variables, 11-2) includes this
DATUM  construct.   The expression is checked for validity and proper
type conversions are made before this  kind  of  store  occurs.   One
hazard  is  that there are times when the compiler cannot verify that
an Item assigned to an Itemvar has a datum whose  type  matches  that
expected by the Itemvar.  Incorrect conversions might well be made in
this case.
   
   
Swap Assignment
   
   
4-8.    The  operator causes the value of the variable on  the  left
hand side to be exchanged with the value of the variable on the right
hand side.  Arithmetic (REALINTEGER) type conversions are  made,  if
necessary;  any  other type conversions are invalid.  Remember, the 
operator may not be used in assignment expressions.
   
   
Examples
   
   
4-9.    

  X_I_A+B; Comment if A, B and X are Real, I Integer,
                the Real value of the  sum is truncated,
                converted to an Integer, and stored in I. 
		The truncated value is then converted to 
		a Real number and stored in X.

  BEGIN REAL ITEMVAR X;
    X_LOP(SET3);
    DATUM(X) _ 5; Comment a  conversion  to 5.0  will be made
	before the store  is done,  but there is no guarantee
	that the Item obtained by LOP(SET3) was not declared,
	for example, as INTEGER ITEM A;
  END;

SAILON NO. 57.2					SAIL   4-10

   
   
Byte statements
   
   
4-10.    
   
   
4-10.    The  statements  DPB,  IDPB  and  IBP   are   provided   for
manipulating  bytes  of  information.   These  operations  correspond
exactly to the PDP-10 machine instructions  for  manipulating  bytes.
The formats are as follows:

   1)  DPB ( byte, bytepointer )
	       The "byte" is deposited according to the bytepointer.  The
       POINT  procedure  may  be used for generating byte pointers
       (see Point, 12-126).

   2)  IDPB ( byte, bytepointer )
       The "byte" is deposited, and the bytepointer  incremented.
       For this reason, the bytepointer may not be an expression,
       but must be a variable.

   3)  IBP ( bytepointer )
       The bytepointer is incremented.  The rules for IDPB apply.
   
SAILON NO. 57.2					SAIL   5-1

                              SECTION 5
                                    
                     EXECUTION CONTROL STATEMENTS
                                    
   
   
SYNTAX
   
   
5-1.    

<conditionalstatement>  ::= <ifstatement>
                         ::= <ifstatement> ELSE <statement> 

<ifstatement>           ::= IF <booleanexpression> THEN <statement> 
   
   

<gotostatement>        ::= GO TO <labelidentifier>
                         ::= GOTO <labelidentifier>
                         ::= GO <labelidentifier> 

<labelidentifier>       ::= <identifier> 
   
   

<forstatement>          ::= FOR <algebraicvariable> _ <forlist> DO 
                                <statement>
                         ::= NEEDNEXT <forstatement> 

<forlist>               ::= <forlistelement>
                         ::= <forlist> , <forlistelement> 

<forlistelement>       ::= <algebraicexpression>
                         ::= <algebraicexpression> STEP 
                                <algebraicexpression> UNTIL 
                                <algebraicexpression>
                         ::= <algebraicexpression> STEP 
                                <algebraicexpression> WHILE 
                                <booleanexpression> 
   
   

<whilestatement>        ::= WHILE <booleanexpression> DO <statement>
                         ::= NEEDNEXT <whilestatement> 
   
   
SAILON NO. 57.2					SAIL   5-1


<dostatement>           ::= DO <statement> UNTIL <booleanexpression>
                         ::= NEEDNEXT <dostatement> 
   
   

<casestatement>         ::= <casestatementhead> <compoundtail> 

<casestatementhead>    ::= CASE <algebraicexpression> OF BEGIN 
   
   

<returnstatement>       ::= RETURN
                         ::= RETURN ( <expression> ) 

<donestatement>         ::= DONE
                         ::= DONE <blockname> 

<nextstatement>         ::= NEXT
                         ::= NEXT <blockname> 

<continuestatement>     ::= CONTINUE
                         ::= CONTINUE <blockname> 
   
   
   
SEMANTICS
   
Conditional Statements
   
   
5-2.    These statements provide a means whereby the execution  of  a
statement,  or  a  series  of statements, is dependent on the logical
value produced by a Boolean expression.
   
   
5-3.    A Boolean expression is an  algebraic  expression  whose  use
implies  that  it  is  to  be tested as a logical (truth) value.  The
rules for determining this value are given in Simple Expressions, 9-9
and following.
   
   
If Statement
   
   
5-4.    The statement following the operator THEN (the "THEN part") is
executed if the logical value of  the  Boolean  expression  is  TRUE;
otherwise, that statement is ignored.
SAILON NO. 57.2					SAIL   5-4

   
   
If ...  Else Statement
   
   
	5-5.    If the Boolean expression is true, the "THEN part" is executed
and the statement following the operator ELSE (the  "ELSE  part")  is
ignored.   If  the  Boolean  expression  is  FALSE, the "ELSE part" is
executed and the "THEN part" is ignored.
   
   
Ambiguity in Conditional Statements
   
   
5-6.    The syntax given here for  conditional  statements  does  not
fully  explain  the  correspondences  between  THEN-ELSE  pairs  when
conditional statements are nested.  An ELSE  will  be  understood  to
match the immediately preceding unmatched THEN.
   
   
Example
   
   
5-7.    

COMMENT DECIDE WHETHER TO GO TO WORK;

IF WEEKEND THEN
    IF GIANTSONTV THEN BEGIN
	PHONEEXCUSE("GRANDMOTHER DIED");
	ENJOY(GAME);
	SUFFER(CONSCIENCEPANGS)
    END
    ELSE IF REALLYSICK THEN BEGIN
	PHONEEXCUSE("REALLY SICK");
	ENJOY(0);
	SUFFER(AGONY)
    END
    ELSE GO TO WORK;

SAILON NO. 57.2					SAIL   5-8

	   
   
Go To Statements
   
   
5-8.    Each of the three forms of the Go To statement means the same
thing -- an unconditional transfer is to  be  made  to  the  "target"
statement  labeled  by  the  label  identifier.   The following rules
pertain to labels:

1)  All label identifiers used in a program must be declared.  The
    declaration  of a label must be local to the block immediately
    surrounding the statement it identifies (see exception below).
    Note  that  compound statements (BEGIN-END pairs containing no
    declarations) are not blocks.  Therefore the block


	BEGIN "B1"
	 INTEGER I,J; LABEL L1;
	 ...
	 IF BE3 THEN BEGIN "C1"
	  ...
	  L1:  ...
	  ...
	 END "C1";
	 ...
	 GO TO L1
	END "B1"

	   is legal.

2)  No Go To Statement may specify a transfer from a statement  S1
    outside  a  given  block  to a target statement S2 inside that
    block, if the block contains any Array declarations.  This  is
    automatic  from  rule 1, since the label identifying S2 is not
    available to S1.  When  no  Array  declarations  are  present,
    access  may  be  provided by moving the label declaration into
    blocks global to the block containing the labelled  statement,
    as  long as the declaration is not made global to a block with
    Array declarations, and rule 4 below is followed.   Again  the
    rule  does  not  apply  to  compound  statements, as the above
    example demonstrates.

3)  No Go To statement may specify a  transfer  from  a  statement
    within  a Procedure to a statement outside that Procedure (you
    can't jump out of Procedures).

4)  No Go To statement may  specify  a  transfer  into  a  FOREACH
    statement, or into complicated For loops (those with For Lists
SAILON NO. 57.2					SAIL   5-8

    or which contain a NEXT statement).
   
   
5-9.    Labels will seldom be needed  for  debugging  purposes.   The
block  name  feature  (see  DEBUGGING,  15-9) and the listing feature
which associates with each source  line  the  octal  address  of  its
corresponding  object  code  (see  Listing  Features,  14-13)  should
provide enough information to find things easily.
   
   
5-10.    Many program loops coded with labels  can  be  alternatively
expressed  as  For  or  While  loops,  augmented  by  DONE, NEXT, and
CONTINUE statements.  This often results in a  source  program  whose
organization  is  somewhat  more  transparent,  and an object program
which is more efficient.
   
   
For Statements
   
   
5-11.    For and While statements (see also FOREACH Statement,  7-15)
provide  methods  for  forming  loops  in  a program.  They allow the
repetitive execution of  a  statement  zero  or  more  times.   These
statements  will  be  described  by  means of SAIL programs which are
functionally equivalent but which demonstrate better the actual order
of  processing.  Refer to these equations for any questions you might
have about what gets evaluated when, and how many times each part  is
evaluated.
   
   
5-12.    Let  VBL  be  any  algebraic  variable,  AE1, ...  , AE8 any
algebraic expressions, BE  a  Boolean  expression,  TEMP  a  temporary
location,  S  a  statement.   Then  the following SAIL statements are
equivalent:


Using For Statements -- 

    FOR VBL _ AE1, AE2, AE3 STEP AE4 UNTIL AE5,
	AE6 STEP AE7 WHILE BE, AE8 DO S;


Equivalent formulation without For Statements --

    VBL_AE1;
    S;
    VBL_AE2;
    S;

SAILON NO. 57.2					SAIL   5-12


  Comment STEP-UNTIL loop;
    VBL_AE3;
LOOP1: 
    IF (VBL-AE5) * SIGN(AE4)  0 THEN
    BEGIN
	S;
	VBL_VBL+AE4;
	GO TO LOOP1
    END;


  Comment STEP-WHILE loop;
    VBL_AE6;
LOOP2:
    IF BE THEN BEGIN
	S;
	VBL_VBL+AE7;
	GO TO LOOP2
    END;

    VBL_AE8;
    S;

If AE4 (AE7) is an unsubscripted variable, changing its value  within
the  loop will cause the new value to be used for the next iteration.
If AE4 (AE7) is a constant or an expression requiring  evaluation  of
some  operator,  the  value  used  for  the  step element will remain
constant throughout the execution of the For Statement.  If AE5 is an
expression, it will be re-evaluated before each iteration.
   
   
5-13.    Now consider the For Statement:

    FOR VBL_AE1 STEP CONST UNTIL AE2 DO S;

where  const is a positive constant.  The compiler will simplify this
case to:


    VBL_AE1;
LOOP3: 
    IF VBL  AE2 THEN BEGIN
	S;
	VBL_VBL+CONST;
		GO TO LOOP3
    END;

SAILON NO. 57.2					SAIL   5-13

If CONST is negative, the line at LOOP3 would be:


LOOP3:
    IF VBL  AE2 THEN BEGIN

   
   
5-14.    The value of VBL when execution of the loop  is  terminated,
whether  it  be  by  exhaustion  of the for list or by execution of a
DONE,NEXT  or  GO  TO  statement  (see  Done   Statement,   5-24,Next
Statement, 5-26,Go To Statements, 5-8), is the value last assigned to
it using  the  algorithm  above.   This  value  is  therefore  always
well-defined.
   
   
5-15.    The   statement  S  may  contain  assignment  statements  or
procedure calls which change the value  of  VBL.   Such  a  statement
behaves  the same way it would if inserted at the corresponding point
in the equivalent loop described above.
   
   
While Statement
   
   
5-16.    The statement
   
    WHILE BE DO S;
   
is equivalent to the statements:

LOOP:
    IF BE THEN BEGIN
	S;
	GO TO LOOP
    END;
SAILON NO. 57.2					SAIL   5-17

   
   
Do Statement
   
   
5-17.    The statement
   
    DO S UNTIL BE;
   
is equivalent to the sequence:


LOOP:
    S;
    IF BE THEN GO TO LOOP;

   
   
Case Statements
   
   
5-18.    The statement

CASE AE OF BEGIN
    S0; S1; S2;... Sn 
END

	is functionally equivalent to the statements:

    TEMP_AE;
    IF 		TEMP = 0 THEN S0
	ELSE IF TEMP = 1 THEN S1
	ELSE IF TEMP = 2 THEN S2
	...
	ELSE IF TEMP = n THEN Sn
    ELSE ERROR;

For applications of this type  the  CASE  statement  form  will  give
significantly  more efficient code than the equivalent If statements.
Notice that dummy statements may be inserted for  those  cases  which
will not occur or for which no entries are necessary.  For example,


CASE AE OF BEGIN
    S0; ; ; S3; ; ; S6; END 

provides  for  no actions when AE is 1,2,4,5, or 7.  When AE is 0, 3,
or 6 the corresponding statement will be executed.
SAILON NO. 57.2					SAIL   5-19

   
   
5-19.    The CASE statement gives rise to one of the  few  legitimate
uses  of SAIL Labels.  If two of the S[i] within a CASE are to do the
same thing except for some initial statements, it is useful  to  jump
from  one  into the other (or from both to an unused third) after the
individual code has been executed.  If two of the S[i] are to provide
exactly  the  same  functions,  it  is  better  to combine them via a
mapping function on the CASE  index  (e.g.,  use  a  character  table
containing  the  same CASE index for all characters which do the same
thing).
   
   
Return Statement
   
   
5-20.    This statement is invalid if it appears outside a  procedure
declaration.   It  provides  for  an  early  return  from a Procedure
execution to the statement  calling  the  Procedure.   If  no  return
statement  is  executed,  the  Procedure  will  return after the last
statement representing the procedure body is executed (see  Procedure
Declarations, 3-38).
   
   
5-21.    An untyped Procedure (see Procedure Statements, 6-2) may not
return a value.  The return statement  for  this  kind  of  Procedure
consists merely of the word RETURN.  If an argument is given, it will
cause the compiler to issue an error message.
   
   
5-22.    A typed Procedure  (see  Function  Designators,  9-47)  must
return  a value as it executes a return statement.  If no argument is
present an error message will be given.   If  the  Procedure  has  an
algebraic  type,  any  algebraic  expression  may  be returned as its
value; type conversion will be performed in  a  manner  described  by
Arithmetic  Type Conversions, 9-21 and String-Arithmetic Conversions,
9-27 below.  If the Procedure is of type SET or  ITEM,  the  argument
must be an expression of type SET or ITEM.
   
   
5-23.    If no RETURN statement is executed in a typed Procedure, the
value returned is undefined (it could be anything  --  try  it,  it's
fun).
SAILON NO. 57.2					SAIL   5-24

   
   
Done Statement
   
   
5-24.    The  statement  containing only the word DONE may be used to
terminate the execution of a FOR, WHILE, or FOREACH loop  explicitly.
Its  operation  can  most easily be seen by means of an example.  The
statement


    FOR I_1 STEP 1 UNTIL n DO BEGIN
	S;
	...
	IF BE THEN DONE;
	...
    END

    is equivalent to the statement

    FOR I_1 STEP 1 UNTIL n DO BEGIN
	S;
	...
	IF BE THEN GO TO EXIT;
	...
    END;
EXIT:

In either case the value of I is well-defined after the statement has
been executed (see For Statements, 5-14).
   
   
5-25.    The  DONE  statement  will  only  cause  an  escape from the
innermost loop in which it  appears,  unless  a  block  name  follows
"DONE".   The  block  name  must  be  the name of a block or compound
statement (a "Loop Block") which is the object statement of some FOR,
FOREACH,  WHILE,  or DO statement in which the current one is nested.
The effect is to terminate all loops out to (and including) the  Loop
Block, continuing with the statement following this outermost loop.
SAILON NO. 57.2					SAIL   5-26

   
   
Next Statement
   
   
5-26.    A  Next  statement  is  valid only in a For Statement, While
Statement, Do Statement, or Foreach Statement  (see  For  Statements,
5-11,  etc.,  FOREACH  Statement,  7-15).   Processing  of  the  loop
statement is temporarily suspended.  When the NEXT statement  appears
in  a  For or Foreach loop, the next value (set of items) is obtained
from  the  For  List  (Associative  Context)  and  assigned  to   the
controlled  variable (bound variables).  The termination test is then
made.  If the termination condition is satisfied, control  is  passed
to  the  statement  following the For Statement or Foreach statement.
If not, control is returned to the inner statement following the NEXT
statement.   In  While  and  Do  loops,  the termination condition is
tested.  If it  is  satisfied,  execution  of  the  loop  terminates.
Otherwise  it  resumes at the statement within the loop following the
NEXT statement.
   
   
5-27.    Unless  a  block  name  follows  NEXT,  the  innermost  loop
containing  the  NEXT  statement  is  used,  and  must be preceded by
NEEDNEXT.  If a block name is present, the terminating condition  for
the  loop  containing  the  "Loop  Block"  (see Done Statement, 5-24,
above) is checked.  If the condition is  met,  all  inner  loops  are
terminated  (in DONE fashion) as well.  If continuation is indicated,
no inner-loop FOR-variable or WHILE-condition will have been affected
by the NEXT code.  In complicated cases, many strange effects will be
noticed.
   
   
5-28.    The reserved word NEEDNEXT must precede FOREACH, FOR, WHILE,
or DO in the "Loop Block", and must not appear between this block and
the NEXT statement.
   
   
Example
   
   
5-29.    

   NEEDNEXT WHILE EOF DO BEGIN
	S_INPUT(1,1);
	NEXT;	Comment check EOF and terminate if TRUE;
	T_INPUT(1,3);
        PROCESSINPUT(S,T);
   END;

SAILON NO. 57.2					SAIL   5-29

   
   
Continue Statement
   
   
5-30.    The Continue statement is valid in only those contexts valid
for  the  DONE statement (see Done Statement, 5-24); the "Loop Block"
is determined in the same way.  All loops out to the Loop  Block  are
terminated  as if DONE had been requested.  Control is transferred to
a point inside the loop containing the  Loop  Block,  but  after  all
statements in the loop.
   
   
Example:
   
   
5-31.    

	FOR I_1 STEP 1 UNTIL N DO BEGIN
		...
		CONTINUE;
		...
	END

   is semantically equivalent to:

	FOR I_1 STEP 1 UNTIL N DO BEGIN
		LABEL CONT;
		...
		GO TO CONT;
		...
	 CONT:
	END

   
SAILON NO. 57.2					SAIL   6-1

                              SECTION 6
                                    
                         PROCEDURE STATEMENTS
                                    
   
   
SYNTAX
   
   
6-1.    

<procedurestatement>    ::= <procedureidentifier>
                         ::= <procedureidentifier> ( 
                                <actualparameterlist> ) 

<actualparameterlist>  ::= <actualparameter>
                         ::= <actualparameterlist> , 
                                <actualparameter> 

<actualparameter>       ::= <expression>
                         ::= <arrayidentifier>
                         ::= <procedureidentifier> 
   
   
   
SEMANTICS
   
   
6-2.    A  Procedure  statement is used to invoke the execution of an
untyped Procedure (see Procedure Declarations, 3-38).  It may also be
used to supply parameters to the Procedure.
   
   
6-3.    No  value  may  be  returned  from  a  Procedure  called by a
Procedure statement, since there is no specification in the statement
telling  how  to  use  the  value.   The  compiler  determines  how a
Procedure may be used by noticing if a  type  was  specified  in  the
procedure  declaration.   After  execution  of the Procedure, control
returns  to  the  statement  immediately  following   the   Procedure
statement.   However,  SAIL does allow you to use typed Procedures as
procedure statements.  The  value  returned  from  the  Procedure  is
simply discarded.
SAILON NO. 57.2					SAIL   6-4

   
	   
Actual Parameters
   
   
6-4.    The actual parameters supplied to a Procedure must in general
match the formal parameters described in the  procedure  declaration.
As  usual,  the  exception  is  algebraic  expressions;  the transfer
functions  described  in  Arithmetic  Type  Conversions,   9-21   and
String-Arithmetic  Conversions,  9-27  will be applied to convert the
type of any algebraic expression passed by  VALUE  to  the  algebraic
type required by the Procedure.
   
   
Call by Value
   
   
6-5.    If  an actual parameter is passed by VALUE, only the value of
the expression is given to the Procedure.  This value may be  changed
or  examined  by the Procedure, but this will in no way affect any of
the variables used to evaluate the actual parameters.  Any  algebraic
expression,  any  Item  or  Set  expression  may  be passed by value.
Neither Arrays nor Procedures  may  be  passed  by  value.   See  the
default   declarations   for  parameters  in  Defaults  in  Procedure
Declarations, 3-53.
   
   
Call by Reference
   
   
6-6.    If an actual parameter is passed by REFERENCE, its address is
passed  to the Procedure.  All accesses to the value of the parameter
made by the Procedure  are  made  indirectly  through  this  address.
Therefore  any  change  the  Procedure makes in a reference parameter
will change the value of the variable which was  used  as  an  actual
parameter.  This is sometimes useful.  However if it is not intended,
use of this feature  can  also  be  somewhat  confusing  as  well  as
moderately  inefficient.   Reference  parameters  should be used only
where needed.
   
   
6-7.    Variables,   constants,   Procedures,   Arrays,   and    most
expressions  may  be  passed  by reference.  Neither Items nor String
expressions (or String constants) may be reference parameters.
SAILON NO. 57.2					SAIL   6-8

   
   
6-8.    If an expression is passed by reference, its value  is  first
placed  in  a  temporary  location; a constant passed by reference is
stored in a unique location.  The address of this location is  passed
to the Procedure.  Therefore, any values changed by the Procedure via
reference parameters of this form will be  inaccessible  to  the  user
after  the  Procedure  call.   If  the  called program is an assembly
language routine which saves the parameter address, it  is  dangerous
to  pass  expressions  to  it, since this address will be used by the
compiler for other temporary purposes.  A  warning  message  will  be
printed when expressions are called by reference.
   
   
6-9.    The type of each actual parameter passed by reference must be
identical  to  that  of  its  corresponding  formal  parameter.    An
exception  is  made for Fortran calls (see Fortran Procedures, 6-12).
If an algebraic type mismatch  occurs  the  compiler  will  create  a
temporary  variable  containing  the  converted  value  and  pass the
address of this temporary as the parameter.  A warning  message  will
be printed.
   
   
Procedures as Actual Parameters
   
   
6-10.    If  an  actual  parameter to a Procedure PC is the name of a
Procedure PR with no arguments, one of three things might happen:

   1)  If the corresponding formal parameter requires a value of a
       type matching that of PR (in the loose sense given above in
       Actual Parameters, 6-4), the Procedure is evaluated and its
       value is sent to the Procedure PC.

   2)   If  the  formal  parameter  of  PC  requires  a  reference
       Procedure of identical type, the address of PR is passed to
       PC as the actual parameter.

   3)  If the formal parameter requires a reference variable,  the
       Procedure  is evaluated, its result stored, and its address
       passed (as with expressions in the previous  paragraph)  as
       the parameter.
SAILON NO. 57.2					SAIL   6-11

   
   
6-11.    If a Procedure name followed by actual parameters appears as
an actual parameter it is evaluated (see Function Designators, 9-47).
Then  if  the  corresponding  formal  parameter requires a value, the
result of this evaluation is passed as the actual parameter.  If  the
formal  parameter  requires a reference to a value, it is called as a
reference expression.
   
   
Fortran Procedures
   
   
6-12.    If the Procedure being called is a  Fortran  Procedure,  all
actual  parameters  must  be  of type INTEGER (BOOLEAN) or REAL.  All
such parameters are passed by  reference,  since  Fortran  will  only
accept   that  kind  of  call.   For  convenience,  any  constant  or
expression used as an actual parameter  to  a  Fortran  Procedure  is
stored  in  a  temporary cell whose address is given as the reference
actual parameter.
   
   
6-13.    It was explained in Procedure Declarations, 3-38 that formal
parameters need not be described for Fortran Procedures.  This allows
a program to  call  a  Fortran  Procedure  with  varying  numbers  of
arguments, a feature which exists in DEC Fortran.  No type conversion
will be performed for such parameters, of course.  If type conversion
is  desired,  the formal parameter declarations should be included in
the Fortran procedure declaration; SAIL will use  them  if  they  are
	present.
   
   
6-14.    To  pass  an  Array  to  Fortran, mention the address of its
first element (e.g.  A[0], or B[1,1]).
   
   
Implementation Details
   
   
6-15.    See the paragraphs concerning procedures in the  section  on
implementation  (PROCEDURE IMPLEMENTATION, 17-48) for descriptions of
the calling sequences and basic layout of SAIL procedures.  See  also
Separately Compiled Procedures, 16-7 for more information about these
useful constructs.
SAILON NO. 57.2					SAIL   6-16

   
   
Examples:
   
   
6-16.    To call an untyped Procedure:

BEGIN ...; PROC(I+J,A[Q],L); ...END;
To call a Procedure of type Integer with one Integer argument:

I_PROC(PROC(I));
   
SAILON NO. 57.2					SAIL   7-1

                              SECTION 7
                                    
                           LEAP STATEMENTS
                                    
   
   
SYNTAX
   
   
7-1.    

<leapstatement>         ::= <setstatement>
                         ::= <associativestatement>
                         ::= <loopstatement> 

<setstatement>          ::= <setassignment>
                         ::= PUT <constructionitemexpression> IN 
                                <setvariable>
                         ::= REMOVE <retrievalitemexpression> FROM 
                                <setvariable> 

<associativestatement>  ::= <itemassignment>
                         ::= DELETE ( <retrievalitemexpression> )
                         ::= MAKE <constructiontriple>
                         ::= ERASE <retrievaltriple> 
   
   

<loopstatement>         ::= FOREACH <bindinglist> 
                                <associativecontext> DO <statement>
                         ::= NEEDNEXT <loopstatement> 

<bindinglist>           ::= <idlist> |

                         ::= <idlist> SUCH THAT 

<associativecontext>    ::= <element>
                         ::= <associativecontext> AND <element>
                         ::= <associativecontext>  <element> 

<element>                ::= <retrievalassociativeexpression> IN 
                                <retrievalsetexpression>
                         ::= <retrievaltriple>
                         ::= ( <booleanexpression> ) 

<triple>               ::= <derivedset>  
                                <associativeexpression> 
   
SAILON NO. 57.2					SAIL   7-1

   
	   
SEMANTICS
   
LEAP Introduction
   
   
7-2.    The basic ALGOL facility  in  SAIL  has  been  extended  with
syntactic  constructs  and  semantic  interpretations to reference an
associative data store.  This extension was developed by J.   Feldman
and P.  Rovner and is described in [Feldman].  The LEAP facilities in
SAIL differ slightly from those published in the  CACM  article.   In
the  discussion  of the use of the associative facilities, reasonably
simple examples are given for each  construct.   These  examples  and
associated  discussions  should emphasize the differences between the
SAIL implementation and the constructs published in the CACM article.
   
   
7-3.    The LEAP constructs all involve manipulations  of  one  basic
entity,   the  item.   An  item  is  a  conceptual  entity  which  is
represented at execution time by a unique  number.   Associated  with
each item in the universe is a DATUM.  The DATUM of an item may be an
algebraic quantity, an array of such quantities, or a SET.  The DATUM
assignment  statement  (see  Datum Assignments, 4-7) is used to store
the value of an expression into the DATUM of an item.  The DATUM of a
declared  ARRAY  ITEM is loaded automatically when the block in which
the ARRAY ITEM is declared is entered.  The DATUM of an item may also
be referenced during evaluation of expressions (see Datums, 11-6).
Examples:
	INTEGER ITEM father,joe;
	INTEGER ARRAY ITEM ages [1:20];
	INTEGER a,b,c;

	DATUM (father) _ 21 ;
	DATUM (ages) [b] _ b / 33 ;
	c _ DATUM (joe) - 12 ;
   
The  DATUM  operator  is  intended  to  link the powerful associative
processing routines developed for  manipulation  of  items  with  the
algebraic  facilities  of  ALGOL.   This link is made as efficient as
possible -- only two machine instructions are required to access  the
DATUM of an item.
SAILON NO. 57.2					SAIL   7-4

   
   
7-4.    Items  or  information about items may be stored in a variety
of ways.  The simple entity ITEM  does  not  itself  occupy  storage.
Instead,  instances  of  ITEMS  are  stored  in  ITEMVARS,  SETS,  or
associations.  The simplest of these forms is the  ITEMVAR:  an  item
may  be "stored" in an ITEMVAR.  Evaluation of that ITEMVAR will then
yield the item stored into it.  ITEMVARS are thus  roughly  analogous
to simple arithmetic variables.  SAIL also allows arrays of ITEMVARs,
with the obvious interpretation.   A  typical  declaration  would  be
"ITEMVAR ARRAY x[1:22,0:1]", or "INTEGER ITEMVAR ARRAY y[1:20]".
   
   
7-5.    Instances   of   items   may  also  be  stored  as  unordered
collections,  or  SETS.   Facilities  are  provided  for  common  set
operations  (see  Set  Expressions,  10-2).  The SAIL system uses one
word of storage for each item in a set.  A set will contain  at  most
one  instance of a specific item: if an instance of item X is already
in set S, then any subsequent attempts to put an instance of X  in  S
will   have  no  effect.   This  is  in  keeping  with  the  standard
mathematical notion of set.
   
   
7-6.    The third, and perhaps most important,  form  of  storage  of
item  instances  is  the  association, or triple.  Ordered triples of
item instances may be written into or retrieved from a special store,
the  associative  store.   The  method of storage of these triples is
designed to  facilitate  fast  and  flexible  retrieval.   SAIL  uses
approximately two words of storage for each triple in the associative
store.  There is at most one copy of a triple in  the  store  at  any
time.   Once  a triple has been stored in the associative memory, its
component item instances may not be changed.  In the  examples  which
follow, a triple is represented by:
   
	A  O  V
   
where  A,  O, and V are items or itemvars.  A, O, and V are mnemonics
for the three components of a triple: attribute, object,  and  value.
The  exact  syntactic  rules  for describing triples are discussed in
SEMANTICS, 10-2.
SAILON NO. 57.2					SAIL   7-7

   
   
General Restrictions
   
   
7-7.    The implementation of the associative store and  other  forms
of  item  storage imposes several limitations on the LEAP capability.
The maximum number of items (as represented by their unique  numbers)
is  4090.   This arises from an overwhelming desire to store a triple
in one word of storage, and hence the requirement that an item number
be describable in 12 bits.
   
   
Construction - Retrieval Distinction
   
   
7-8.    There  are  two  basic  operations which are performed on the
three types of item stores -- construction of a new element  in  that
store, and retrieval of some existing element in the store.  For some
purposes,  it  is  necessary  to  distinguish  the  operations  being
performed.   This  distinction manages to find its way to the syntax.
In the discussion of associative expressions (Item Constructs, 10-4),
the    syntactic    forms    <constructionitemprimary>    and
<retrievalitemprimary> are  discussed.   The  ascent  from  primary
level to associative expressions preserves these distinctions.  Thus,
one   speaks   of   a   <constructionitemexpression>,   or   of   a
<retrievalitemexpression>.   Often  the  BNF  productions  speak of
<itemexpressions>.  This is merely a shorthand to denote that  two
separate   sets   of   productions   exist,  one  in  which    means
"construction", and one in which  means "retrieval".
   
   
PUT and REMOVE
   
   
7-9.    The verbs PUT and REMOVE are  provided  for  easily  altering
sets.  After initialization, all sets are empty.  They may be altered
either by PUTting  item  instances  into  them  or  by  explicit  set
assignment statements.  The PUT statement is executed as follows: the
construction item expression is evaluated, and must  yield  a  single
item.  An instance of this item is then recorded in the set specified
by the set variable.  REMOVE operates in an analogous fashion.  If an
instance  of  the  item  to  be REMOVEd does not occur in the set, an
error message issues forth.
SAILON NO. 57.2					SAIL   7-10

   
   
DELETE
   
   
7-10.    DELETE releases an item from the universe of current  items.
Some small amount of storage is reclaimed in this process, as well as
the unique number associated with the item DELETEd.  Since  there  is
an  upper  limit  on the number of items, the DELETE statement can be
used to free item numbers for other uses.  The DELETE statement in no
way  alters  the  instances  of the DELETEd item which are present in
sets or associations.  The user should be  sure  that  there  are  no
instances  of  the  DELETEd  item  occurring  in  sets,  itemvars  or
associations.  Attempts to reference a DELETEd item in any  way  will
result in confusion.
   
   
MAKE
   
   
7-11.    Associations may be added to the associative memory with the
MAKE statement.  If the association already exists in the  store,  no
alterations  are  made.   The  argument  to  the  MAKE statement is a
construction triple; that  is,  a  triple  composed  of  construction
associative  expressions.   Every  construct  in these expressions is
interpreted in  a  construction  sense.   The  component  associative
expressions  in  this  triple  are  evaluated  left  to  right.  Some
constructs in these expressions (e.g.  see NEW Items, 10-6 or in  the
case  of  bracketed  triples) require that new unique item numbers be
created.  Examples:
   
	MAKE item1  item2  item3
	MAKE item1  itemvar1  NEW
	MAKE item1[item2itemvar1item3]itemvararray[23]
   
   
7-12.     The last example involves the use of  a  BRACKETED  TRIPLE.
The  bracketed triple "[item2  itemvar1  item]" which is used as an
associative expression is inserted in the associative store.   A  new
unique  item  number  is generated, which refers to that association.
Various functions (  ISTRIPLE,  FIRST,  SECOND,  THIRD  --  see  Item
Selectors,  10-5)  may  use  an  instance  of  this new item as their
argument.  Consider the following statements:

	MAKE number  [part  hand  finger]  new (5);
	FOREACH x,y SUCH THAT number  x  y AND 
	  (ISTRIPLE (x) AND FIRST (x) = part) DO
		count _ count + DATUM (y) ;

SAILON NO. 57.2					SAIL   7-12

   
   
ERASE
   
   
7-13.    The ERASE statement is provided to undo the damage  done  by
the  MAKE  statement.   The  same  general class of arguments must be
provided.  ERASE requires a retrieval triple as  its  argument,  thus
eliminating  such  questionable  constructs as NEW from said triples.
However, the construct ANY may appear in a  triple  specification  to
ERASE.   This  allows  a whole slew of appropriate associations to be
erased in one statement.  (Restriction: ERASE ANY    ANY    ANY  is
considered  bad  form, and is as a direct result, forbidden).  Sample
ERASE statements are:

	ERASE item1  item2  item3
	ERASE item1  itemvar1  item2
	ERASE itemvar1  ANY  item1
RESTRICTION -- MAKE and ERASE will  take  only  item  expressions  as
arguments, and will not take set expressions.
   
   
7-14.    In  order  to give the programmer some idea of what is going
on in the associative store, there is a provision to  interrupt  each
MAKE  and  ERASE  operation,  and enter a breakpoint procedure.  This
allows you to  get  at  the  attribute,  object,  and  value  of  the
association  being  written  or  erased.   ERASE foo  ANY  ANY will
cause  the  breakpoint  procedure  to  be  activated  once  for  each
association that matches the pattern.

    A breakpoint procedure has a declaration of the form:
PROCEDURE breakp ( ITEM a,o,v).
The  attribute,  object  and  value  of the interrupted operation are
passed in the formal parameters.  The breakpoints are set with  calls
on   two  routines  in  the  LEAP  runtime  routines  (they  are  not
pre-declared, so the appropriate declarations are given below):
   

	EXTERNAL PROCEDURE BRKERS ( PROCEDURE BP );
	EXTERNAL PROCEDURE BRKMAK ( PROCEDURE BP );

	BRKMAK ( breakp );  Comment this sets the breakpoint for MAKE;
	BRKERS ( breakp ); Comment this sets the breakpoint for ERASE;
SAILON NO. 57.2					SAIL   7-15

   
   
FOREACH Statement
   
   
7-15.    Flexible searching and retrieval are  the  main  motivations
for  using  the  set  and  associative stores.  The FOREACH statement
provides  this  retrieval  facility.   The   FOREACH   statement   is
essentially  a  looping  statement:  the  <statement> after the DO is
executed for  each  group  of  item  instances  in  the  store  which
satisfies  the  FOREACH  specification.   If there are no such groups
present in the store, the body of the statement  is  never  executed.
The  <bindinglist> specifies the itemvars which will contain results
of   the   search.     For    instance,    the    simple    construct
FOREACH x SUCH THAT x IN set1 DO procedure(x)  causes the body of the
statement to be executed once for each item instance in the set set1.
During  execution  of  the  body  of  the  statement,  the  itemvar x
evaluates to  the  item  retrieved  from  the  set  set1.   Consider,
however, the FOREACH Statement
   
	FOREACH x SUCH THAT x IN set1 AND x IN set2 DO statement
   
This  specification may appear ambiguous, and indeed it is, unless we
define  the  concept  of  BINDING   the   itemvars   in   a   FOREACH
specification.   In  an associative context, an itemvar which appears
in the <bindinglist> is said to be FREE until a search specification
has  determined the first requirement on the value of the itemvar (in
a left-to-right scan of the <associativecontext>).  After the  first
requirement, it is said to be BOUND.  Thus the <element> in the above
example which reads "x IN set1" specifies a  search  in  which  x  is
free.   The  fact that x is free implies the searching operation.  In
the second element, "x IN set2", x  is  bound.   Thus  no  search  is
conducted  here.  Instead, the question "Does an instance of the item
I am considering for x appear in the set set2?"  is  evaluated.   The
answer  must  be  TRUE in order that the statement be executed with x
evaluating to that item.  In summary,  then,  the  FOREACH  statement
above  specifies  one  search  (  x  IN  set1  )  and  one additional
requirement ( x IN set2 ).
SAILON NO. 57.2					SAIL   7-16

   
   
7-16.    An  element  of  a  FOREACH  specification  may  also  be  a
parenthesized boolean expression.  It is of course requisite that all
itemvars appearing in the boolean expression must be bound, i.e.   no
searching  of  the  associative store will be accomplished during the
evaluation of the boolean expression.  Example:
   
	FOREACH x SUCH THAT x IN set1 AND ( DATUM (x) < 21 ) DO ...
   
Only members of set1 with DATUMs less than 21  will  be  selected  by
this  specification.  In the example above (FOREACH Statement, 7-15),
the second <element> could also have  been  written  in  its  boolean
form: ( x IN set2 ).
   
   
7-17.    The most powerful <element> construct is a retrieval triple.
Such  specifications  make  searches  (for  any  FREE  itemvars)   or
verifications (in the case of completely BOUND elements) in the store
of associations.  For example:
   
1.	FOREACH x SUCH THAT a  o  x DO PUT x IN peopleset;
2.	FOREACH x SUCH THAT a  o  x AND b  g  x DO ...
   
The aim of statement 1 is clear -- a search is conducted through  the
associative  store for all associations with attribute "a" and object
"o".  If k such associations are discovered, then  the  body  of  the
statement  is  executed  k  times, with x taking on successive values
each time.  The second example is similar, but places  an  additional
constraint  on  the  values of x which should be returned.  Since the
second element (b   g    x)  is  completely  BOUND,  no  search  is
conducted,  but a test is made to verify that the association b  g 
x' is in the store, where x' is some item retrieved during the search
for a  o  x.
   
   
7-18.    In  general,  an  <associative context> is satisfied by some
assignment of item instances to the itemvars in the <binding list> if
all  of  the  <element>s  are  satisfied  under  that  assignment.  A
<boolean expression>  is  satisfied  if  it  evaluates  to  TRUE.   A
<retrieval  triple> containing no <set expression> is satisfied by an
assignment if the association it specifies  is  in  the  universe  of
associations.  A <retrieval triple> containing a <set expression> (or
ANY) is satisfied if there are, in the universe of associations,  any
of  the  associations  formed by substituting elements of the set (or
arbitrary items) in the position occupied by the <set expression>.
SAILON NO. 57.2					SAIL   7-19

   
   
7-19.    With this concept of SATISFIERS,  we  proceed  to  the  more
general  case  with  more than one itemvar cited in the binding list.
Suppose there are  such itemvars.  Then the <statement> is  executed
once  for  each  permutation  of  the  universe  of items among the 
itemvars which SATISFY the associative context.  During the execution
of  the  <statement>,  the  itemvars will evaluate to the particular
permutation which SATISFIED the associative context.
   
   
7-20.    The above description for  several  itemvars  is  sound  but
slightly  misleading.   The  SAIL  implementation  makes no effort to
avoid duplicating a particular permutation of values which  satisfies
the  associative  context.  Thus the <statement> will be executed one
OR MORE times for every permutation which satisfies  the  associative
context.  (See Restrictions and Caveats, 7-22).
SAILON NO. 57.2					SAIL   7-21

   
   
7-21.      Examples  of FOREACH statements with several free itemvars
specified are:
   
1.	FOREACH x,y,z SUCH THAT fatherxy AND fatheryz DO ...
2.	FOREACH x,z SUCH THAT father (father  x)  z DO ...
3.	FOREACH x,y SUCH THAT x IN set AND father  x  y DO ...
4.	FOREACH x,y SUCH THAT father  x  y AND x IN set DO ...
   
As it happens, 1 and 2 are equivalent.  The compiler actually reduces
2 to 1 by including a dummy itemvar to be analogous to the use of "y"
in the first example.  Examples 3 and  4  are  precisely  equivalent,
that  is,  the  statement will be executed with x and y evaluating to
all the ordered pairs of items which satisfy the (clearly equivalent)
requirements.   There  is,  however, a considerable difference in the
execution efficiency of  these  two  examples.   Example  3  is  more
efficient  since  the  "set"  is  probably quite small, and since the
search of the associative memory with only one free  itemvar  in  the
search  specification  is  rather fast.  The second example, however,
makes a search through the associative memory for all the (x,y) pairs
and  then  discards  those  pairs for which an instance of x does not
occur in the "set".  Listed below in order of  decreasing  efficiency
are the various basic forms of <element>s that are legal.  The effect
of a statement such as 2 above should be calculated by reducing it to
the  form  of  1.   In  the  list  below,  x, y, and z represent free
itemvars, whereas A, O, and V  represent  either  bound  itemvars  or
fixed items.

	A  O  V	Verification that the triple 
				is in the store.
	A  O  x	Only the value is free.
	A IN S		Verification that item A is in set S.
	x IN S		All items x in the set S.
	x  y  V	Attribute and object are free.
	A  x  V	Only the object is free.
	x  O  V	Only the attribute is free.
	A  x  y	Object and value are free.
	x  O  y	Attribute and value are free.
	x  y  z	PROHIBITED

SAILON NO. 57.2					SAIL   7-22

   
   
Restrictions and Caveats
   
   
7-22.    i.  The SAIL implementation differs in fundamental ways from
the implementation described  by  Feldman  and  Rovner  in  the  CACM
article.   Their  FOREACH  statement  builds  a  record  of  all  the
permutations which satisfy the associative context, being careful  to
include only one copy of each such permutation.  Then the <statement>
is executed once for each permutation  that  was  stored  during  the
retrieval  operation.   The  SAIL implementation uses the associative
context as a generator of satisfiers.  Thus one group  of  satisfiers
is  found, <statement> is executed for those satisfiers, then another
found, etc.  until all groups of satisfiers  have  been  found.   The
implications of this method are startling:
   
1.   There  is absolutely no way to guarantee that a particular group
of satisfiers is not repeated.  There are methods  of  coding  around
this  problem.   The  user can stuff itemvar arrays with results of a
FOREACH and avoid duplications.  In many  search  specifications  the
nature  of  the  searches (e.g.  sets, where only one copy of an item
instance can occur in the set) avoids duplicate satisfiers.
2.  Operations within <statement> which change the  associative  data
store may affect the subsequent satisfier groups retrieved.  Note the
difficulty in the following:

	FOREACH x,y |
 link  x  y DO MAKE link  x  newlink
   
There is another difficulty with ERASE or REMOVE operations inside  a
FOREACH  statement.   The SAIL implementation saves pointers into the
data  structure  during  the  execution  of  the   <statement>.    If
operations  within  that  statement  cause  these  pointers to become
invalid, wild effects will occur.  Care has been taken,  however,  to
make sure that some simple things work correctly:

	FOREACH x |
 link  x  node DO ERASE link  x  NODE ;
	FOREACH x |
 x  set1  x  set2 DO REMOVE x FROM set1 ;
		..... and many more.
SAILON NO. 57.2					SAIL   7-23

   
   
7-23.      During and after the execution of a FOREACH statement, the
values of the bound  itemvars  are  in  general  well-defined.   They
evaluate to the permutation which last satisfied the FOREACH context.
If a GO TO is executed within the <statement>, the values are correct
in  that  they  correspond  to  the group of satisfiers for which the
<statement> was being executed.  The only case in which the  itemvars
are undefined is when the search specified has been exhausted and the
associative context contains a boolean expression.   The  explanation
of  this  restriction is quite simple -- prior to the evaluation of a
boolean expression, the core locations reserved for the  itemvars  in
the  <bindinglist>  are  stuffed with the current satisfiers so that
the evaluation of the boolean expression may reference them.
   
   
7-24.    Expression case  statements,  conditional  expressions,  and
procedure   calls   are  all  valid  within  an  associative  context
specification, provided that all itemvars used  in  these  constructs
are BOUND.
SAILON NO. 57.2					SAIL   8-1

                              SECTION 8
                                    
                     ASSEMBLY LANGUAGE STATEMENTS
                                    
   
   
SYNTAX
   
   
8-1.    

<codeblock>             ::= <codehead> <codetail> 

<codehead>              ::= <codebegin>
                         ::= <codebegin> <blockname>
                         ::= <codehead> <declaration> ; 

<codebegin>             ::= STARTCODE
                         ::= QUICKCODE 

<codetail>              ::= <instruction> END
                         ::= <instruction> END <blockname>
                         ::= <instruction> ; <codetail> 

<instruction>            ::= <addresses>
                         ::= <opcode>
                         ::= <opcode> <addresses> 

<addresses>              ::= <address>
                         ::= <acfield> ,
                         ::= <acfield> , <address> 

<acfield>               ::= <constantexpression> 

<address>                ::= <indexedaddress>
                         ::= @ <indexedaddress> 

<indexedaddress>        ::= <simpleaddress>
                         ::= <simpleaddress> ( <indexfield> ) 

<simpleaddress>         ::= <identifier>
                         ::= <constantexpression>
                         ::= <literal> 

<literal>                ::= [ <constantexpression> ] 

<indexfield>            ::= <constantexpression> 
SAILON NO. 57.2					SAIL   8-1


<opcode>                 ::= <constantexpression>
                         ::= PDP-10opcode 
   
   
   
SEMANTICS
   
   
8-2.    Within   a  STARTCODE  (QUICKCODE)  block,  statements  are
processed by a small  and  weak,  but  hopefully  adequate,  assembly
language  translator.  Each "instruction" places one instruction word
into the output file.
   
   
Declarations in Code Blocks
   
   
8-3.    A codeblock behaves like any other  block  with  respect  to
block  structure.   Therefore,  all  declarations  are valid, and the
names given in these declarations  will  be  available  only  to  the
instructions  in  the  codeblock.   There  will, in general, be more
Labels than usual declared in these blocks, since a Label may  appear
in  an  address  field, and since jump instructions referring to such
Labels  are  the  only  means  for  transferring  control  within   a
codeblock.   Labels  in  codeblocks may refer to instructions which
will be executed, or to those which are not really instructions,  but
data to be manipulated by these instructions (these latter words must
be bypassed in the code by jump instructions).
   
   
Meaning of Instruction Operands
   
   
8-4.    If the <address> in an instruction is  a  constant  (constant
expression), it is assumed to be an immediate or data operand, and is
not relocated.  If  the  <address>  is  an  identifier,  the  machine
address  (relative to the start of the compilation) is used, and will
be relocated to the proper value by the Loader.  If the <address>  is
an  identifier  which  has  been  declared as a formal parameter to a
procedure, addressing arithmetic will be done automatically to get at
the  VALUE  of  the  paramter.   Hence  if  the <address> is a formal
reference parameter, the instruction will be of the form
OP AC,@ -x('17)
where x depends on exactly where the parameter is in the stack.  If a
literal  is used, the address of the compiled constant will be placed
in the instruction.  Any reference to  Strings  will  result  in  the
address  of the second descriptor word (byte pointer) to be placed in
the instruction.
SAILON NO. 57.2					SAIL   8-5

   
   
8-5.    The indirect, index, and AC fields have the same  syntax  and
perform the same functions as they do in the FAIL or MACRO languages.
   
   
8-6.    The  Opcode may be a constant provided by the user, or one of
the  standard   (non   I/O)   PDP-10   operation   codes,   expressed
symbolically.   If  a constant, it should take the form of a complete
PDP-10 instruction, expressed in octal radix (e.g.  DEFINE  TTYUUO  =
"'510000000000";).   Any  bits  appearing  in  fields  other than the
opcode field (first 9 bits) will be OR'ed with the bits  supplied  by
other fields of instructions in which this opcode appears.
   
   
Distinctions Between STARTCODE and QUICKCODE
   
   
8-7.    Before  your instructions are parsed in a block starting with
STARTCODE, instructions are executed to leave all accumulators  from
0  through  '15  available for your use.  In this case, you may use a
JRST to transfer control out of the codeblock, as long as you do not
leave a procedure, a block with array declarations, a Foreach loop, a
loop with a For list, or a loop which uses the NEXT construct.  In  a
QUICKCODE  block,  no  accumulator-saving  instructions  are issued.
Ac's '13 through '15 only are free.  In addition, some recently  used
variables   may  be  given  the  wrong  values  if  used  as  address
identifiers (their current values may be contained  in  Ac's  0-'12);
and  control  should  not  leave  the  codeblock  except by "falling
through".
   
   
Warning Concerning Default Radix
   
   
8-8.    All integer constants will  be  expressed  in  decimal  radix
unless the octal representation is explicitly used.
SAILON NO. 57.2					SAIL   9-1

                              SECTION 9
                                    
                        ALGEBRAIC EXPRESSIONS
                                    
	   
   
SYNTAX
   
   
9-1.    

<expression>             ::= <simpleexpression>
                         ::= <conditionalexpression>
                         ::= <assignmentexpression>
                         ::= <caseexpression> 
   
   

<conditionalexpression> ::= IF <booleanexpression> THEN <expression> 
                                ELSE <expression> 

<assignmentexpression>  ::= <assignmentstatement> 

<caseexpression>        ::= CASE <algebraicexpression> OF ( 
                                <expressionlist> ) 

<expressionlist>        ::= <expression>
                         ::= <expressionlist> , <expression> 

<simpleexpression>      ::= <algebraicexpression>
                         ::= <stringexpression>
                         ::= <setexpression>
                         ::= <associativeexpression> 

<booleanexpression>     ::= <expression> 

<stringexpression>      ::= <algebraicexpression> 
   
   
	
<algebraicexpression>   ::= <disjunctiveexpression>
                         ::= <algebraicexpression>  
                                <disjunctiveexpression> 

<disjunctiveexpression> ::= <negatedexpression>
                         ::= <disjunctiveexpression>  
                                <negatedexpression> 
SAILON NO. 57.2					SAIL   9-1


<negatedexpression>     ::=  <relationalexpression>
                         ::= <relationalexpression> 

<relationalexpression>  ::= <algebraicrelational>
                         ::= <leaprelational> 

<algebraicrelational>   ::= <boundedexpression>
                         ::= <relationalexpression> 
                                <relationaloperator> 
                                <boundedexpression> 

<leaprelational>        ::= <retrievalitemexpression>  
                                <retrievalsetexpression>
                         ::= <retrievalitemexpression> 
                                <relationaloperator> 
                                <retrievalitemexpression>
                         ::= <retrievalsetexpression> 
                                <relationaloperator> 
                                <retrievalsetexpression>
                         ::= <retrievaltriple> 

<relationaloperator>    ::= <
                         ::= >
                         ::= =
                         ::= 
                         ::= 
                         ::=  

<boundedexpression>     ::= <addingexpression>
                         ::= <boundedexpression> MAX 
                                <addingexpression>
                         ::= <boundedexpression> MIN 
                                <addingexpression> 

<addingexpression>      ::= <term>
                         ::= <addingexpression> <addoperator> <term> 

<addingoperator>        ::= +
                         ::= -
                         ::= LAND
                         ::= LOR
                         ::= EQV
                         ::= XOR 

<term>                   ::= <factor>
                         ::= <term> <multoperator> <factor> 
SAILON NO. 57.2					SAIL   9-1


<multoperator>          ::= *
                         ::= /
                         ::= %
                         ::= LSH
                         ::= ROT
                         ::= MOD
                         ::= DIV
                         ::= & 

<factor>                 ::= <primary>
                         ::= <primary> ^ <primary> 

<primary>                ::= <algebraicvariable>
                         ::= - <primary>
                         ::= LNOT <primary>
                         ::= ABS <primary>
                         ::= <algebraicexpression> [ <substringspec> 
                                ]
                         ::= 
                         ::= <constant>
                         ::= <functiondesignator>
                         ::= ( <algebraicexpression> )
                         ::= LENGTH ( <retrievalsetexpression> )
                         ::= LENGTH ( <stringexpression> )
                         ::= CVN ( <itemprimary> )
                         ::= LOP ( <stringvariable> )
                         ::= LDB ( <arithmeticexpression> )
                         ::= ILDB ( <arithmeticvariable> )
                         ::= ISTRIPLE ( <itemexpression> ) 

<substringspec>         ::= <algebraicexpression> TO 
                                <algebraicexpression>
                         ::= <algebraicexpression> FOR 
                                <algebraicexpression> 

<functiondesignator>    ::= <procedureidentifier>
                         ::= <procedureidentifier> ( 
                                <actualparameterlist> ) 

<actualparameterlist>  ::= <actualparameter>
                         ::= <actualparameterlist> , 
                                <actualparameter> 

<actualparameter>       ::= <expression>
                         ::= <arrayidentifier>
                         ::= <procedureidentifier> 

<algebraicvariable>     ::= <variable> 
SAILON NO. 57.2					SAIL   9-1


<stringvariable>        ::= <variable> 
   
   
   
SEMANTICS
   
Conditional Expressions
   
   
9-2.    A  conditional  expression returns one of two possible values
depending on the logical truth value of the Boolean expression.   For
the  rules  on evaluation of this truth value see Simple Expressions,
9-9 and following.  If the Boolean expression (BE) is true, the value
of  the  conditional  expression  is  the  value  of  the  expression
following the delimiter THEN.  If BE is false,  the  other  value  is
used.  If both expressions are of an algebraic type, the precise type
of the entire conditional expression is  that  of  the  "THEN  part".
Otherwise,  both expressions must be of precisely the same type (Set,
Item, etc.).  Unlike the nested If statement problem, there can be no
ambiguity for conditional expressions, since there is an ELSE part in
every such expression.
   
   
Example
   
	   
9-3.    

  FOURTHDOWN(YARDSTOGO,YARDLINE,IF YARDLINE < 70 THEN PUNT
	ELSE IF YARDLINE < 90 THEN FIELDGOAL
	ELSE RUNFORIT)

SAILON NO. 57.2					SAIL   9-4

   
   
Assignment Expressions
   
   
9-4.    The somewhat weird syntax for an assignment expression (it is
equivalent  to  that  for  an  assignment  statement)  is nonetheless
accurate: the two function identically as far as the new value of the
left part variable is concerned.  The difference is that the value of
this left part variable is also retained as the value of  the  entire
expression.   Assuming that the assignment itself is legal (following
the rules given in Assignment Statements, 4-3 above), the type of the
expression  is that of the left part variable.  This variable may now
participate in any surrounding expressions as if it  had  been  given
its new value in a separate statement on the previous line.  Only the
_ operator is valid in assignment expressions.   The    operator  is
valid only at statement level.
   
	   
Example
   
   
9-5.    

  IF (I_I+1) < 30 THEN I_0 ELSE I_I+1;

   
   
Case Expressions
   
   
9-6.    The expression


    CASE AE OF (E0, E1, E2, ... , En) is equivalent to

    IF          AE=0 THEN E0 
	ELSE IF AE=1 THEN E1
	ELSE IF AE=2 THEN E2
	...
	ELSE IF AE=n THEN En
    ELSE ERROR

   
   
9-7.    The  type  of  the entire expression is therefore that of E0.
If any of the expressions E1 ...  En cannot be fit into this mold  an
error message is issued by the compiler.
SAILON NO. 57.2					SAIL   9-7

   
   
Example
   
   
9-8.    


  OUT(TTY,CASE ERRNO OF("BAD DIRECTORY",
		"IMPROPER DATA MODE",
		"UNKNOWN I/O ERROR",
		...
		"COMPUTER IN BAD MOOD"));

   
   
Simple Expressions
   
   
9-9.    Simple  expressions  are  simple  only  in  that they are not
conditional, case, or assignment expressions.  There are in fact some
exciting   complexities  to  be  discussed  with  respect  to  simple
expressions.  Set, Item, and Associative expressions are discussed in
the  next section.  Before continuing with a description of algebraic
expressions in the following paragraphs, an explanation  of  what  is
meant by a Boolean expression is in order.
   
   
The Boolean Expression Anomaly
   
   
9-10.    You  will  notice that in the syntax a Boolean expression is
said to be equivalent to an expression.  In actuality, the  expression
may  NOT  be  an associative one.  This is simply a way of expressing
syntactically that there are  automatically  invoked  rules,  1)  for
obtaining  a  logical  truth  value from an expression which does not
contain any logical operators or  logical  connectives,  and  2)  for
obtaining  an  algebraic  (Integer)  value  from one which does.  The
rules are very simple:
SAILON NO. 57.2					SAIL   9-11

   
   
Integer, Real, or String to "Boolean"
   
   
9-11.    The logical truth value of an expression  `X'  which  is  of
type  Integer,  Real, or String is the same as the truth value of the
expression `X0'.  A  String  expression  will  be  converted  to  an
Integer  one  (see  String-Arithmetic  Conversions,  9-27) before the
comparison is made.  This need not be done for a Real expression,  of
course,  since  the  Integer  and  Real representations for 0 are the
same.  This means you can write expressions of the form

    IF I+3 THEN E1 ELSE E2      when you really mean
    IF I+30 THEN E1 ELSE E2

One application of this rule can be found in several of the execution
time  routines  (ENTER, LOOKUP, etc.) where an error flag is returned
which is zero (FALSE) if the operation was  successful  and  non-zero
(TRUE)  if  an  error occurred.  This flag may be tested as a Boolean
variable (IF FLAG THEN  ERROR("LOOKUP  FAILED")  )  or  to  determine
exactly what went wrong by examining its actual value.
   
   
"Boolean" to Integer
   
   
9-12.    The   truth   value  of  an  expression  containing  logical
operators and/or connectives may be determined by rules  given  below
(see  Algebraic  Expressions,  9-15,  Disjunctive  Expressions, 9-18,
Logical Expressions, 9-31).  If this value  is  needed  to  determine
which part to execute in a conditional statement, while statement, or
conditional expression no actual numerical value need be created  for
the  expression  --  the  tests  which determine the truth value lead
directly to the correct program branch.  However, if this  expression
is  combined  with  other  algebraic  expressions  using  some numeric
operator, or if it is assigned to an algebraic variable, some  actual
value  must  be  returned  for  the expression.  If the expression is
false, a zero is returned.   A  non-zero  value  indicates  that  the
expression  is  true.  The actual value returned for true expressions
may differ from time to time, but it is guaranteed non-zero.
SAILON NO. 57.2					SAIL   9-13

   
   
Precedence of Algebraic Operators
   
   
9-13.    The binary  operators  in  SAIL  generally  follow  "normal"
precedence  rules.   That  is,  exponentiations  are performed before
multiplications or divisions, which  in  turn  are  performed  before
additions  and subtractions, etc.  The bounding operators MAX and MIN
are performed after these operations.  The logical connectives   and
,  when  they  occur,  are  performed last (  before ).  The exact
precedence of operators is described in the syntax above.  The  order
of  operation  can be changed by including parentheses at appropriate
points (see Primaries, 9-40).
SAILON NO. 57.2					SAIL   9-14

   
   
9-14.    In  an  expression  where  several  operators  of  the  same
precedence occur at the same level, the operations are performed from
left  to  right.   See  Algebraic  Expressions,   9-15,   Disjunctive
Expressions,   9-18   for   special   evaluation  rules  for  logical
connectives.
   
Expression Evaluation Rules
   
   
9-14.    SAIL  does  not   evaluate   expressions   in   a   strictly
left-to-right  fashion.  If we are not constrained to a left-to-right
evaluation,  (as  is  ALGOL  60),  we  can  in  some  cases   produce
considerably  better  code  than  a strict left-to-right scheme could
achieve.  Intuitively, The essential features (and pitfalls) of  this
evaluation rule can be illustrated by a simple example:

	REAL PROCEDURE halve ( REFERENCE REAL whole );
		RETURN ( whole_whole/2 );

	b _ 2.6 ;
	c _ b + halve (b) ;

The  last  assignment  statement  is evaluated as follows: first call
halve, with a reference to b as its argument; upon return, add  b  to
the procedure call result; then store the result (which is 2.6) in c.
If we were doing a strict left-to-right evaluation, the  value  of  b
would  have  to  be saved before the procedure halve was called.  The
evaluation scheme can be stated quite simply: no  code  is  generated
for the operation represented by a BNF production until the reduction
of that BNF production takes place.  The evaluation rules can also be
stated  a  little  more  elegantly, by defining a function EVAL whose
value is a REFERENCE to some computed value.  EVAL  (variable)  is  a
reference  to  that  variable.   EVAL  ( thing1 operation thing2 ) is
DO-OPERATION (operation, EVAL(thing1),EVAL(thing2))),    where
DO-OPERATION  returns  a  reference  to  the  resulting  value.  Here
thing1, operation, and thing2 are abstract entities, merely  intended
to suggest the various concrete syntactic constructs.
   
   
Algebraic Expressions
   
   
9-15.    If  an  algebraic expression has as its major connective the
logical connective "", the expression has  the  logical  value  TRUE
(arithmetic  value  some non-zero integer) if either of its conjuncts
(the expressions surrounding the "") is true; FALSE otherwise.
SAILON NO. 57.2					SAIL   9-16

   
   
9-16.     AB does NOT produce the bit-wise Or of A and B if they are
algebraic  expressions.   Truth  values combined by numeric operators
will in general be meaningless (use the operators LOR  and  LAND  for
bit operations).
   
   
9-17.    The  user  should be warned that in an expression containing
logical connectives, only enough of the expression is evaluated (from
left  to  right)  to uniquely determine its truth value.  Thus in the
expression

    (J<3  (K_K+1) > 0),

K will not be incremented if J  is  less  than  3  since  the  entire
expression is already known to be true.  Conversely in the expression

    (X 0  SQRT(X)>2) (see Disjunctive Expressions, 9-18),

there is never any danger of attempting to extract the square root of
a negative X, since the failure of the first test  testifies  to  the
falsity  of  the  entire  expression  -- the SQRT routine is not even
called in this case.
   
   
Disjunctive Expressions
   
   
9-18.    If a disjunctive expression has as its major connective  the
logical  connective "", the expression has the logical value TRUE if
both of its disjuncts are TRUE; FALSE otherwise.  Again, if the first
disjunct is FALSE a logical value of FALSE is obtained for the entire
expression without further evaluation.
   
   
Relational Expressions
   
   
9-19.    If any of the binary relational  operators  is  encountered,
code  is produced to convert any String arguments to Integer numbers.
Then type  conversion  is  done  as  it  is  for  +  operations  (see
Arithmetic  Type  Conversions,  9-21).   The values thus obtained are
compared for the indicated condition.  A Boolean value TRUE or  FALSE
is  returned  as  the  value  of  the expression.  Of course, if this
expression is used in subsequent arithmetic operations, a  conversion
to  integer  (see  "Boolean"  to Integer, 9-12 above) is performed to
obtain an Integer value.
SAILON NO. 57.2					SAIL   9-20

   
   
9-20.    Leap relational operators are discussed in depth in a  later
section.
   
   
Arithmetic Type Conversions
   
   
9-21.    The  binary arithmetic, logical, and String operations which
follow will accept combinations of arguments of any algebraic  types.
The type of the result of such an operation is sometimes dependent on
the type of its arguments and sometimes fixed.  An  argument  may  be
converted  to  a  different  algebraic  type  before the operation is
performed.   The  following  table  describes  the  results  of   the
arithmetic  and logical operations given various combinations of Real
and Integer inputs.  ARG1 and ARG2 represent the types of the  actual
arguments.   ARG1'  and  ARG2'  represent  the types of the arguments
after any necessary conversions have been made.
SAILON NO. 57.2					SAIL   9-22

   
   
9-22.    
   
OPERATION     ARG1   ARG2   ARG1'  ARG2'  RESULT
   
+ -           INT    INT    INT    INT    INT*
* ^ %         REAL   INT    REAL   REAL   REAL
MAX MIN       INT    REAL   REAL   REAL   REAL
              REAL   REAL   REAL   REAL   REAL
   
LAND LOR      INT    INT    INT    INT    INT
EQV XOR       REAL   INT    REAL   INT    REAL
              INT    REAL   INT    REAL   INT
              REAL   REAL   REAL   REAL   REAL
   
LSH ROT       INT    INT    INT    INT    INT
              REAL   INT    REAL   INT    REAL
	              INT    REAL   INT    INT    INT
              REAL   REAL   REAL   INT    REAL
   
/             INT    INT    REAL   REAL   REAL
              REAL   INT    REAL   REAL   REAL
              INT    REAL   REAL   REAL   REAL
              REAL   REAL   REAL   REAL   REAL
   
MOD DIV       INT    INT    INT    INT    INT
              REAL   INT    INT    INT    INT
              INT    REAL   INT    INT    INT
              REAL   REAL   INT    INT    INT
   
* Unless ARG2 is <0 for the operator ^
   
   
9-23.    An Integer is converted to a Real number in such a way  that
if this Real number is converted back to an Integer, the same Integer
value will result, unless the absolute value of the number is greater
than  134217728.   Some  low-order  significance  will  be  lost  for
integers greater than this magnitude.
   
   
9-24.    If the Integer is a SHORT INTEGER variable, or the  Real  is
SHORT  REAL, the conversion is done with a FSC instruction, much more
efficiently (a factor of about 8) than the normal UUO.
SAILON NO. 57.2					SAIL   9-25

   
   
9-25.    A Real number is converted to an Integer using the following
formula:

   Integer _ SIGN(Real)*{largest integer I such that IABS(Real)~.

This  function  will  produce invalid results for Real numbers with a
magnitude greater than 134217728.   If  either  operand  is  declared
SHORT,  conversion  is  done  (Stanford  only)  with the built-in FIX
instruction, at a correspondingly faster  rate.   As  usual,  caution
must be taken that the range of the number is that of a SHORT Integer
(27 bits).
   
   
9-26.    If a String is presented as an  argument  to  any  of  these
operations,  it  is  converted  to an Integer.  If an Integer or Real
argument is presented  to  the  concatenation  operator  (&),  it  is
converted to a one-character string.  Here are the rules:
   
   
String-Arithmetic Conversions
   
   
9-27.    If  a  String  is  presented as an argument to an arithmetic
operator, as a (value) parameter to a procedure which expects a  Real
or  Integer  value, or as an expression to be stored by an assignment
statement into a Real  or  Integer  variable,  an  Integer  value  is
created for it as follows:

    If  the  string is the null string (length=0), a 0 is returned as
its `Integer value'.  Otherwise a word which has its lefthand 29 bits
0, the rightmost 7 bits containing the first character of the String,
is returned as its `Integer value'.  For instance, the String "ABCDE"
has  as  its  `Integer  value'  '101, the octal representation of the
letter `A'.  This Integer will then be converted to a Real number, if
necessary.
SAILON NO. 57.2					SAIL   9-28

   
   
9-28.    If  an Integer or Real number is presented where a String is
expected, a one character String  will  be  created  whose  character
consists  of  bits  29-35  (the  rightmost seven bits) of the numeric
value.  A Real number is not  converted  to  an  Integer  before  the
conversion.  For instance, the expression
   
    "STRING"& '15 & '12
   
will  result  in  a  String which is 8 characters long.  The last two
characters are the ASCII codes for carriage  return  and  line  feed,
respectively.
   
   
Bounded Expressions
   
   
9-29.    A  MAX  B  (where A and B are appropriate expressions -- see
the Syntax) has the value of the larger of A and B (in the  algebraic
sense).   Type conversions are performed as if the operator were `+'.
0 MAX X MIN 10 is X if 0X10, 0 if X<0, 10 if X>10.
   
   
Adding Expressions
   
	   
9-30.    All  the   operators   grouped   in   the   semantic   class
<addoperator>  operate  at the same precedence level.  The user must
sometimes provide parentheses in order to make the  meaning  of  such
expressions  absolutely  unambiguous.   The + and - operators will do
integer addition (subtraction) if both  arguments  are  integers  (or
converted to integers from strings); otherwise, rounded Real addition
or subtraction, after necessary conversions, is done.
   
   
9-31.    LAND,  LOR,  XOR,  and  EQV  carry  out  bit-wise  And,  Or,
Exclusive Or, and Equivalence operations on their arguments.  No type
conversions are done for these functions.  The logical connectives  
and  do not have this effect -- they simply cause tests and jumps to
be compiled.  The type of the result is that of  the  first  operand.
This  allows  expressions  of  the form X LAND '777777777, where X is
Real, if they are really desired.
   
   
9-32.    Currently the values of the various overflow flags  produced
by  these operators (and those which follow) are not available to the
user.
SAILON NO. 57.2					SAIL   9-32

   
   
Terms
   
Arithmetic Multiplicative Operators
   
   
9-33.    The operation * (multiplication), like + and  -,  represents
Integer  multiplication  only  if  both  arguments are integers; Real
otherwise.  Integer multiplication uses the IMUL machine  instruction
-- no double-length result is available.
   
   
9-34.    The / operator (division) always does rounded Real division,
after converting any Integer arguments to Real.
   
   
9-35.    The % operator has the same type table as +, -, and  *.   It
performs whatever division is appropriate.
   
   
9-36.    LSH  and ROT provide logical shift operations on their first
arguments.  If the value of the second argument is positive, a  shift
or  rotation  of  that  many bits to the left is performed.  If it is
negative, a right-shift or rotate is done.  To obtain  an  arithmetic
shift (ASH) operation, multiply or divide by the appropriate power of
	2; the compiler will change this operation to a shift operation.
   
   
9-37.    DIV and MOD force  both  arguments  to  be  integers  before
dividing.   X MOD Y  is  the  remainder  after  X  DIV Y is performed
(X MOD Y = X - (X DIV Y)*Y);
   
   
Concatenation Operator
   
   
9-38.    This operator produces a result of type String.  It  is  the
String  with  length  the  sum  of  the  lengths  of  its  arguments,
containing all the characters of the second  string  concatenated  to
the  end of all the characters of the first.  The operands will first
be   converted   to   strings   if   necessary   as   described    in
String-Arithmetic  Conversions,  9-27 above.  The normal use of the &
operator is to collect lines  of  text,  from  several  other  string
sources,  which  will  subsequently  be  sent  to  an  output device.
Numbers can be converted to strings representing their external forms
(and  vice-versa)  through  explicit calls on execution time routines
like CVS and CVD (see Execution Routines, 12-1 below).
SAILON NO. 57.2					SAIL   9-38

   
   
Factors
   
   
9-39.    A factor is either a primary or a primary raised to a  power
represented by another primary.  As usual, evaluation is from left to
right, so that A^B^C is evaluated as (A^B)^C.  In the factor  X^Y,  a
suitable  number  of  multiplications  and  additions is performed to
produce an "exact" answer if Y is a positive  integer.   Otherwise  a
routine  is  called  to approximate ANTILOG(Y LOG X).  The result has
the type of X in the former case.  It is always of type Real  in  the
latter.
   
   
Primaries
   
   
9-40.    A  primary  represents  an  arithmetic or String value which
always acts as a unit in any  binary  operation.   It  is  either  an
expression   surrounded  by  parentheses  which  indicates  that  all
internal operations should be  performed  before  combining  it  with
other  things,  or  one  of  myriad  other  constructs  which will be
considered separately.
   
   
Variables and Constants
   
   
9-41.    These  are  clearly  primary  objects.   They   are   values
contained  in  specific core locations, or in parameter stacks, or in
the case of some numeric constants, they are immediate operands.
   
   
Substrings
   
   
9-42.    A  String  primary  which  is  qualified  by   a   substring
specification represents a part of the specified string.  ST[X FOR Y]
represents the Xth through the (X + Y - 1)th characters of the String
ST.  ST[X TO Y] represents the Xth through Yth characters of ST.
SAILON NO. 57.2					SAIL   9-43

   
   
9-43.    Consider the ST[X TO Y] case.  If Y>LENGTH(ST), Y_LENGTH(ST).
if  Y<0,  Y_0;  in either case  the  right half of the global Integer
SKIP  is  set  to  TRUE.   If  X    1 it is set to 1.  If X > (the
modified) Y, it is set to Y+1 (null string  guaranteed).   In  either
case the left half of SKIP is made TRUE.  The ST[X FOR Y] operation
is converted to the ST[X TO Y] case before the substring operation is
performed.
   
   
9-44.    To  examine  the  above conditions, declare EXTERNAL INTEGER
SKIP, and look at it after any interesting substring operation.
   
   
Special Length Operator ()
   
   
9-45.    This  special  primary  construct  is  valid   only   within
substring brackets.  It is an algebraic value representing the length
of the most immediate string under consideration.
   
   
Example:
   
   
9-46.    

	A[4 to ] throws out the first 3 characters of A.
	A[3 for B[-1 for 1]] uses the next to the last character
			      of string B as the number of characters
			      for the A substring operation.
   
   
Function Designators
   
   
9-47.    A function designator defines a single value.  This value is
produced  by  the  execution  of a typed user Procedure or of a typed
execution-time routine (Execution Routines, 12-1).   For  a  function
designator to be an algebraic primary, its Procedure must be declared
to have an algebraic type.  Untyped Procedures  may  only  be  called
from Procedure statements (see Procedure Statements, 6-2).  The value
obtained from a user-defined Procedure is that provided by  a  Return
Statement within that Procedure.  If the Procedure does not execute a
Return Statement, the value might  be  anything  at  all.   A  Return
Statement  in  a  typed  Procedure  must  mention a value (see Return
Statement, 5-20).
SAILON NO. 57.2					SAIL   9-48

   
   
9-48.    The rules for supplying  actual  parameters  in  a  function
designator  are  identical  to  those  for  supplying parameters in a
procedure statement (see Procedure Statements, 6-2).
   
   
9-49.    Several of the constructs given here as primaries  have  the
form  of  function designators.  However, the operations necessary to
obtain the values of these constructs are generally compiled directly
into the program.  Descriptions of these functions follow:
   
   
Length
   
   
9-50.    LENGTH   is  always  an  integer-valued  function.   If  its
argument is a set expression, the result is the number  of  Items  in
the  set.   If  the argument is a String, its length is the number of
characters in the string.  The length of an algebraic  expression  is
always 1 (see String-Arithmetic Conversions, 9-27).
   
   
Lop
   
   
9-51.    The  LOP  operator  applied to a String variable removes the
first character from the String and returns it in the form  given  in
String-Arithmetic  Conversions,  9-27  above.   The  String no longer
contains this character.  LOP applied to a null  String  has  a  zero
value.   If  the  argument is a Set expression the result is an Item.
This case is described below (Item Constructs, 10-4).
   
   
Cvn
   
   
9-52.    CVN has as its value  the  Integer  which  is  the  internal
representation  of  its  Item  argument.   This  function  is  highly
implementation-dependent, and should only be used by people  who  are
willing  to  follow  the  compiler writers around a lot.  Its inverse
function is CVI, described in Item Constructs, 10-4 below.
SAILON NO. 57.2					SAIL   9-53

   
   
Lnot
   
   
9-53.    The unary operator Lnot produces the bitwise  complement  of
its  (algebraic)  argument.   No  type conversions (except strings to
integers) are performed on the argument.   The  type  of  the  result
(meaningful or not) is the type of the argument.
   
   
Abs
   
   
9-54.    The   unary   operator  ABS  is  valid  only  for  algebraic
quantities.  It returns the absolute value of its argument.
   
   
Unary Minus
   
   
9-55.    -X  is  equivalent  to  (0-X).   No  type  conversions   are
performed.
   
   
Boolean Primaries
   
   
9-56.    The  unary  Boolean  operator   applied to an argument BE(a
relational expression, see Syntax) has the value TRUE if BE is false,
and  FALSE  if  BE  is  true.   Notice  that  A  is  not the bitwise
complement of A, if A is an algebraic value.  If used as an algebraic
value,  A  is simply 0 if A0 (see "Boolean" to Integer, 9-12), some
non-zero Integer otherwise.
SAILON NO. 57.2					SAIL   9-57

   
   
ISTRIPLE
   
   
9-57.    
   
   
9-57.    Istriple (IE) is TRUE if IE is an  Item  which  describes  a
bracketed  triple.   It  is  FALSE  otherwise.   If IE is not an Item
expression, the compiler will complain bitterly.

   ISTRIPLE ( [ABV] ) is true.

   ISTRIPLE ( <declared item> ) is false.

   
   
	LDB and ILDB
   
   
9-58.    LDB and ILDB are SAIL constructs used to invoke  the  PDP-10
byte  loading  instructions.   The  arguments  to these functions are
expressions which are interpreted as byte pointers.  In the  case  of
ILDB,  you  are required to use an algebraic variable as argument, so
that  the  byte  pointer  (i.e.   that  algebraic  variable)  may  be
incremented.
SAILON NO. 57.2					SAIL   10-1

                              SECTION 10
                                    
                   SET AND ASSOCIATIVE EXPRESSIONS
                                    
   
   
SYNTAX
   
   
10-1.    

<setexpression>         ::= <setexpression> 

<setexpression>       ::= <setterm>
                         ::= <setexpression>  <setterm> 

<setterm>             ::= <setfactor>
                         ::= <setterm>  <setfactor> 

<setfactor>           ::= <setprimary>
                         ::= <setfactor> - <setprimary> 

<setprimary>          ::= PHI
                         ::= <setvariable>
                         ::= {itemexprlist~
                         ::= ( <setexpression> )
                         ::= <derivedset> 

<itemexprlist>       ::= <itemexpression>
                         ::= <itemexprlist> , <itemexpression> 

<derivedset>          ::= <associativeexpr> 
                                <associativeoperator> 
                                <associativeexpr> 

<associativeoperator>   ::= 
                         ::= `
                         ::= * 
   
   

<associativeexpression> ::= <associativeexpr> 

<associativeexpr>     ::= <itemexpression>
                         ::= <setexpression> 
SAILON NO. 57.2					SAIL   10-1


<itemexpression>      ::= <itemprimary>
                         ::= <selector> ( <itemprimary> )
                         ::= [ <itemprimary>  <itemprimary>  
	                                <itemprimary> ] 

<constructionitemprim> ::= <itemprimary>
                         ::= NEW
                         ::= NEW ( <algebraicexpression> )
                         ::= NEW ( <arrayname> ) 

<retrievalitemprim>    ::= <itemprimary>
                         ::= ANY 

<itemprimary>           ::= <itemidentifier>
                         ::= <itemvarvariable>
                         ::= CVI ( <algebraicexpression> )
                         ::= COP ( <setvariable> )
                         ::= LOP ( <setvariable> ) 

<triple>               ::= <derivedset>  
                                <associativeexpression> 

<selector>               ::= FIRST
                         ::= SECOND
                         ::= THIRD 

<itemvarvariable>       ::= <variable> 

<setvariable>           ::= <variable> 

<leaprelational>        ::= <retrievalassociativeexpression> IN 
                                <retrievalsetexpression>
                         ::= <retrievalassociativeexpression> 
                                <relationaloperator> 
                                <retrievalassociativeexpression>
                         ::= <retrievaltriple> 
   
SAILON NO. 57.2					SAIL   10-2

   
   
SEMANTICS
   
Set Expressions
   
   
10-2.      Three  rather  standard  operators are implemented for use
with sets.  These are union (), intersection  (),  and  subtraction
(-).  These operators have the standard mathematical interpretations.
The only possible confusion pertains to subtraction:  if  we  perform
the set operation set1 - set2, and if there is an instance of an item
x in set2 but not in set1, the  subtraction  proceeds  and  no  error
message is given.
   
   
Set Primaries
   
   
10-3.    In  addition  to  the  <setvariable>,  there  are three set
primaries: the empty set PHI, a  set  composed  of  a  list  of  item
expressions,  and  derived  sets.   The  empty  set is the set with a
LENGTH of 0.  Its use is unrestricted.  A set primary  which  results
from  a  list  of  item  expressions  is  put  together  as each item
expression is evaluated.  Derived sets are really sets of answers  to
questions which search the associative memory.  The conventions are:
   
	a  b		-- all x such that a  b  x
	a ` b		-- all x such that a  x  b
	a * b		-- (a  b)  (a ` b)
   
Examples of set primaries:
   
	PHI
	{ item1 , item2 , itemprocedure1 ~
	(item1  itemvar1)

SAILON NO. 57.2					SAIL   10-4

   
   
Item Constructs
   
   
10-4.      There  are  several  SAIL functions which yield items when
evaluated.  This is actually  a  rather  ambiguous  statement,  since
items  as  such  have no real existence as entities to pass around in
the breeze.  But, of course, their unique identifier numbers  may  be
passed  about  freely  and indeed are, since the identifier number is
sufficient to specify an item.   As  explained  earlier,  an  itemvar
evaluates  to  the item last "stored" in that itemvar.  There are two
functions provided for removing item instances from sets.  The  first
of  these  is  COP, which evaluates the <setexpression> argument and
returns an instance of the first item in the set.  The  "first"  item
in  a  set  is  not  well defined, since the sets are unordered.  The
value of the <setexpression> is  unchanged.   The  function  LOP  is
similar  to COP in that its value is an instance of the first item in
the set argument, but the item returned will be removed from the  set
if LOP is used.  The set argument to LOP must be a <variable> for the
simple reason that the set descriptor must be changed to reflect  the
removed item.
   
   
Item Selectors
   
   
10-5.    The  operators  FIRST,  SECOND,  and  THIRD are provided for
decomposing bracketed triples  (see  Bracketed  Triples,  7-12.   The
<itemprimary> argument is assumed to be an instance of an item which
was created for the bracketed association when the MAKE was executed.
Examples:
	FIRST ( [aov] ) evaluates to a.
	SECOND ( [aov] ) evaluates to o.
	THIRD ( [aov] ) evaluates to v.
SAILON NO. 57.2					SAIL   10-6

   
   
NEW Items
   
   
10-6.    The  function  NEW  calls  upon  the  associative  store  to
refurbish  a  dusty old DELETEd item or to generate a new one.  These
new items become a part of the universe of existing items, and may be
accessed and handled in precisely the same fashion as declared items.
If NEW is used  in  an  item  expression,  that  expression  is  then
constrained  to be a construction item expression.  NEW may also take
an argument.  In  this  case,  the  datum  of  the  created  item  is
preloaded  with  the  value  passed as argument.  If this argument is
algebraic (real or integer), then the datum will be of the same type.
No  type  conversions  are  done when passing the algebraic argument.
NEW will also accept an array name as argument.  In  this  case,  the
created  item will be of the type array.  In fact, the array cited as
argument will be copied into the newly created array.  The new  array
will have the same bounds and number of dimensions as the array cited
as argument.  This array will not disappear even if the  outer  block
is exited.
   
NEWITEM Declaration
   
   
10-6.    The  SAIL  runtime routines allocate several tables based on
the number of items in the world.  The maximum size of  these  tables
is  4096.  In order to conserve storage, the size of these tables may
be specified by the user.  The compiler accounts for all the declared
items  --  it  remains the user's responsibility to estimate how many
generated (NEW) items he will require.  This  specification  is  made
with the REQUIRE verb:

	REQUIRE 2000 NEWITEMS;
   
   
ANY Construct
   
   
10-7.    Some    associative   searches   may   need   only   partial
specification -- particular portions of a foreach  specification  may
be  unimportant.   The ANY construct is used to specify exactly which
parts of the specification are "don't care"'s.  Examples are:
   
	FOREACH x SUCH THAT father  x  ANY DO PUT x IN sons;
		fathers _ (father  ANY ) ;
ANY is NOT an item.  It is merely a syntactic arrangement to  specify
the "don't care" condition.  Thus foo _ ANY is illegal
SAILON NO. 57.2					SAIL   10-7

   
   
CVI
   
   
10-8.    The  function CVI is provided for those people who insist on
having the world at their disposal.  The argument is an  integer  and
the  result is an instance of the item which uses that integer as its
unique identifier.  Absolutely no error checking is done.  CVI is for
	daring men.
   
   
LEAP Booleans
   
   
10-9.    Several boolean primaries are implemented for comparing sets
and items.  In the following discussion, "ix" means item  expression,
and "se" means set expression.  These are:
1.   Set  Membership.   The  boolean  "ix  IN  se"  evaluates the set
expression, and returns TRUE if the item value specified by the  item
expression is a member of the set.
2.  Association Existence.  The boolean " ix  ix  ix " returns TRUE
if the association exists in the associative store.  Examples:
   
	IF father  x  joe THEN ...
	IF father  joe  ANY THEN MAKE type  joe  legitimate
   
3.  Relations.  The  use  of  the  third  kind  of  boolean  is  more
restricted than the syntax implies.  Only the following relations are
valid:

	ix = ix		-- obvious interpretation
	ix  ix		-- obvious interpretation
	se1 < se2	-- true if se1 is a proper subset of se2
	se1  se2	-- true if se1 is identical to se2 or
			    if se1 is a proper subset of se2
	se1 = se2	-- obvious interpretation
	se1  se2	-- obvious interpretation
	se1 > se2	-- equivalent to se2 < se1
	se1  se2	-- equivalent to se2  se1

   
SAILON NO. 57.2					SAIL   11-1

                              SECTION 11
                                    
                           BASIC CONSTRUCTS
                                    
   
   
SYNTAX
   
   
11-1.    

<variable>               ::= <identifier>
                         ::= <identifier> [ <subscriptlist> ]
                         ::= DATUM ( <itemidentifier> )
                         ::= DATUM ( <itemidentifier> ) [ 
                                <subscriptlist> ] 

<subscriptlist>         ::= <algebraicexpression>
                         ::= <subscriptlist> , <algebraicexpression> 
   
   
   
SEMANTICS
   
Variables
   
   
11-2.    If  a  variable  is  simply  an  identifier, it represents a
single value of the type given in its declaration.
   
   
11-3.     If it is an identifier qualified by  a  subscript  list  it
represents  an  element  from  the  array  bearing  the  name  of the
identifier.
SAILON NO. 57.2					SAIL   11-4

   
   
11-4.     The array should contain as many dimensions  as  there  are
elements in the subscript list.  A[I] represents the I+1th element of
the vector A (if the vector has a lower bound of 0).  B[I,J]  is  the
element  from  the  I+1th row and J+1th column of the two-dimensional
array B.  To explain the indexing scheme precisely, all arrays behave
as  if  each  dimension  had its origin at 0, with (integral) indices
extending infinitely far in either direction.  However, only the part
of  an array between (and including) the lower and upper bounds given
in the declaration are available for use (and in fact, these are  the
only  parts  allocated).   If  the  array  is not declared SAFE, each
subscript is tested against the bounds for its dimension.  If  it  is
outside  its  range, a fatal message is printed identifying the array
and subscript position at fault.  SAFE arrays are not bounds-checked.
Users must take the consequences of the journeys of errant subscripts
for SAFE arrays.  The bounds checking causes  at  least  three  extra
machine  instructions  (two  of  which  are always executed for valid
subscripts) to be added for each subscript in each  array  reference.
The  algebraic  expressions  for  lower  and  upper  bounds  in array
declarations, and for subscripts in subscripted variables, are always
converted  to  Integer values (see Arithmetic Type Conversions, 9-21)
before use.
   
   
11-5.    For  more  information  about  the  implementation  of  SAIL
arrays, see ARRAY IMPLEMENTATION, 17-35.
   
   
Datums
   
   
11-6.    If  the  Item argument of DATUM has an algebraic datum, this
value is returned.  Otherwise the result is  representative  of  some
other  data type and the value returned will have very little meaning
as an algebraic value; it will probably be some internal  pointer  or
something.   This  is mentioned here because there are times when the
compiler will not be able to tell  that  such  a  type  mismatch  has
occurred.   Then  it  will be up to the user to interpret the strange
results.  If a Set is desired here, of course, the result  is  a  Set
primary and may be used as such.
   
   
Identifiers
   
   
11-7.    You  will  notice  that  no  syntax  was  included  for  the
non-terminal symbols <identifier> or <constant>.  It is far easier to
explain these constructs in an informal manner.
SAILON NO. 57.2					SAIL   11-8

   
	   
11-8.    A  SAIL  letter  is any of the upper or lower case letters A
through Z, or the underline character  (  or  !,  they  are  treated
equivalently).   Lower case letters are mapped into the corresponding
upper case letters for purposes of symbol table comparisons  (SCHLUFF
is  the  same symbol as Schluff).  A digit is any of the characters 0
through 9.  An identifier is a string of characters consisting  of  a
letter  followed  by virtually any number of letters and digits There
must be a character which is neither a letter nor a digit (nor either
of the characters "." or "$") both before and after every identifier.
In other words, if YOU can't determine where one identifier ends  and
another begins in a program you have never seen before, well, neither
can SAIL.
   
   
11-9.    There is a  set  of  identifiers  which  are  used  as  SAIL
delimiters  (in the Algol sense -- that is, BEGIN is treated by Algol
as if it were a single character.  Such an approach is not practical,
so  a  reserved  identifier  is  used).  These identifiers are called
Reserved Words and may not be used for any purpose other  than  those
given  explicitly  in  the syntax, or in declarations (DEFINES) which
mask their reserved-word status over the scope of  the  declarations.
E.g.,  "INTEGER BEGIN" is allowed, but a Synonym (see Synonyms, 3-55)
should have been provided for BEGIN if any  new  blocks  are  desired
within  this  one,  because  BEGIN  is ONLY an Integer in this block.
Another set of identifiers have preset declarations -- these are  the
execution  time  functions.   These  latter  identifiers  may also be
redefined by the user; they behave as if  they  were  declared  in  a
block   surrounding   the  outer  block.   A  list  of  reserved  and
predeclared identifiers follows:
   
   
Sail Reserved Words
   
   
11-10.    
   
ABS AND ANY ARRAY ARRAYPDL ASSOC BBPP  BEGIN  BOOLEAN  CASE  COMMENT
CONTINUE  COP  CVI  CVN  DATUM DEFINE DELETE DIV DO DONE DPB ELSE END
ENTRY EQV ERASE EXTERNAL FALSE FIRST FOR FOREACH FORTRAN FORWARD FROM
GEQ  GO  GOTO IBP IDPB IF ILDB IN INF INTEGER INTER INTERNAL ISTRIPLE
ITEM ITEMVAR LABEL LAND LDB LENGTH LEQ LET LIBRARY  LOADMODULE  LNOT
LOP LOR LSH MAKE MAX MIN MOD NEEDNEXT NEQ NEXT NEW NEWITEMS NOT NULL
OF OR OWN PHI  PNAMES  PRELOADWITH  PROCEDURE  PUT  QUICKCODE  REAL
RECURSIVE  REFERENCE  REMOVE  REQUIRE RETURN ROT SAFE SECOND SET SETC
SETO SHORT SOURCEFILE STARTCODE STEP STRING STRINGPDL STRINGSPACE
SUCH SYSTEMPDL THAT THEN THIRD TO TRUE UNTIL VALUE WHILE XOR
SAILON NO. 57.2					SAIL   11-11

   
   
11-11.    Those  who use Stanford's "Global Model" compiler will also
recognize:
GLOBAL MESSAGE SEGMENTFILE SEGMENTNAME
   
   
Sail Predeclared Identifiers
   
   
11-12.    
   
ARRBLT ARRINFO ARRTRAN ARRYIN  ARRYOUT  BREAKSET  CALL  CLOSE  CLOSIN
CLOSO  CLRBUF CODE CVASC CVD CVE CVF CVFIL CVG CVIS CVO CVOS CVS CVSI
CVSIX CVSTR CVXSTR ENTER EQU FILEINFO GETCHAN GETFORMAT INCHRW INCHRS
INCHSL  INCHWL  INSTR INSTRL INSTRS INPUT INTIN INTSCAN LINOUT LOOKUP
MTAPE OPEN OUT OUTCHR OUTSTR  REALIN  REALSCAN  RELEASE  RENAME  SCAN
SETBREAK  SETFORMAT STRBRK TTYIN TTYINL TTYINS WORDIN WORDOUT USERCON
USERERR USETI USETO
   
   
11-13.    These apply only  to  Stanford  users  (especially  "Global
Model" users): BACKUP GETBIT GETDATA GETENTRY IFGLOBAL ISSUE LODED
PTCHRS PTCHRW PTIFRE PTOCNT PTOCHS PTOCHW PTOSTR PTYALL PTYGET  PTYIN
PTYREL PTYSTR PUTDATA QUEUE
SAILON NO. 57.2					SAIL   11-14

   
   
11-14.    Some  of  the  reserved  words  are  equivalent  to certain
special characters.  These equivalences are:


	CHARACTER		RESERVED WORD (s)

	    			   AND
	    			   EQV	
	    			   NOT
	    			   OR
	    			   XOR	
	    			   INF
	    			   IN
	    |		           SUCH THAT
	    			   NEQ
	    			   LEQ
	    			   GEQ
	    {			   SETO	   "set open"
	    ~			   SETC	   "set close"
	    			   UNION
	    			   INTER
	    `			   ASSOC   for derived sets
	    			   SWAP
	    			   !	   alternate underline
   
   
Arithmetic Constants
   
   
11-15.    
     12369 is an Integer with decimal value 12369
     '12357 is an Integer constant with octal value 12357
     123.  is a Real constant with floating point value 123.0
     0123.0 is a Real constant with floating point value 123.0
     .524 is a Real constant with floating point value 0.524
     5.3@4 is a Real constant with floating point value 53000.0
     5.342@-3 is a Real constant with value 0.005342
   
   
11-16.    The character ' (right quote) precedes a string  of  digits
to be converted into an OCTAL number.
SAILON NO. 57.2					SAIL   11-17

   
   
11-17.    If  a  .  or a @ appears in a numeric constant, the type of
the constant is returned as Real (even if it has an integral  value).
Otherwise  it  is  an  integer.  Type conversions are made at compile
time to make the type of a constant commensurate with  that  required
by  a  given  operation.   Expressions  involving  only constants are
evaluated by the compiler and the resultant  values  are  substituted
for the expressions.
   
   
11-18.    The  reserved  word  TRUE  is  equivalent  to  the  Integer
(Boolean) constant -1; FALSE is equivalent to the constant 0.
   
   
String Constants
   
   
11-19.    A String constant is a  string  of  ASCII  characters  (any
which  you  can  get  into  a text file) delimited at each end by the
character ".  If the " character is desired in the string, insert two
" characters (after the initial delimiting " character, of course).
   
   
11-20.    A  String  constant  behaves  like  any  other  (algebraic)
primary.  It is originally of type String, but may  be  converted  to
Integer   by   extracting  the  first  character  if  necessary  (see
String-Arithmetic Conversions, 9-27).
   
   
11-21.    The  reserved  word  NULL  represents  a  String   constant
containing no characters (length=0).
SAILON NO. 57.2					SAIL   11-22

   
   
Examples
   
   
11-22.    The  left  hand  column in the table that follows gives the
required input format to obtain the strings given in  the  right-hand
column:
   
      INPUT                          RESULT                 LENGTH
   
"THIS IS A STRING"             THIS IS A STRING             16
"WHAT DOES ""FERNDOK"" MEAN?"  WHAT DOES "FERNDOK" MEAN?    25
"THIS IS HOW YOU TYPE A """    THIS IS HOW YOU TYPE A "     24
"""THIS IS A QUOTED STRING"""  "THIS IS A QUOTED STRING"    25
""                                                          0
NULL                                                        0
   
   
	   
11-23.    The scanning algorithm is altered somewhat if the String is
being used as a macro body definition (see USE OF DEFINE, 13-0).
   
   
Comments
   
   
11-24.    If   the   scanner  detects  the  identifier  COMMENT,  all
characters up to  and  including  the  next  semicolon  (;)  will  be
ignored.   A  comment may appear anywhere as long as the word COMMENT
is properly delimited (not in a String constant, of course);
   
   
11-25.    A string constant appearing just before  a  statement  also
has the effect of a comment.
SAILON NO. 57.2					SAIL   12-1

                              SECTION 12
                                    
                       EXECUTION TIME ROUTINES
                                    
   
   
GENERAL
   
Scope
   
   
12-1.    A   large  set  of  pre-declared,  built-in  procedures  and
functions have been compiled into a library permanently  resident  on
the  system disk area (SYS:LIBSAI.REL), and optionally into a special
sharable write-protected high segment.   The  library  also  contains
programs  for managing storage allocation and initialization, and for
certain String functions.  If a user calls one of these procedures  a
request is automatically made to the loader to include the procedure,
and any other routines it might need, in the core image (or  to  link
to  the  high  segment).   These  routines provide input/output (I/O)
facilities, Arithmetic-String conversion  facilities,  array-handling
procedures and miscellaneous other interesting functions.
   
   
12-2.    The   remainder   of  this  section  describes  the  calling
sequences and functions of these routines.
   
   
Notational Conventions
   
   
12-3.    A short-hand is used in these  descriptions  for  specifying
the  types  (if  any)  of  the  execution-time  routines and of their
parameters.  Before the description of each routine there is a sample
call of the form


   VALUE _ FUNCTION ( ARG1, ARG2, ... ARGn )

If VALUE is omitted, the procedure is an untyped one, and may only be
called at statement level (Procedure Statements, 6-2).
SAILON NO. 57.2					SAIL   12-4

   
   
12-4.    The types of VALUE and the arguments may be determined using
the following scheme:

  1)  If " characters surround the  sample  identifier  (which  is
      usually  mnemonic  in nature) a String argument is expected.
      Otherwise the  argument  is  Integer  or  Real.   If  it  is
      important  which  of  the  types  Integer  or  Real  must be
      presented, it will be made clear in the description  of  the
      function.   Otherwise the compiler assumes Integer arguments
      (for those functions which are predeclared).  The  user  may
      pass Real arguments to these routines (WORDOUT, for example)
      by re-declaring  them  in  the  blocks  in  which  the  Real
      arguments are desired.

  2)  If the @  character  precedes  the  sample  identifier,  the
      argument  will  be  called  by reference.  Otherwise it is a
      value parameter.
   
   
Example
	   
   
12-5.    


  "RESULT" _ SCAN ( @"SOURCE", BREAKTABLE, @BRCHAR)

is a predeclared procedure with the implicit declaration:

  EXTERNAL STRING PROCEDURE SCAN (REFERENCE STRING SOURCE;
				  INTEGER BREAKTABLE;
				  REFERENCE INTEGER BRCHAR);

   
   
I/O ROUTINES
                                    
                                    
                                 Open                                                                      
   
   
Form:
   
   
12-6.    OPEN(CHANNEL,"DEVICE",MODE,NUMBEROFINPUTBUFFERS,
    NUMBEROFOUTPUTBUFFERS,@COUNT,@BRCHAR,@EOF);
SAILON NO. 57.2					SAIL   12-6

   
   
Function:
   
   
12-7.    SAIL input/output operates  at  a  very  low  level  in  the
following sense: the operations necessary to obtain devices, open and
close files, etc., are almost directly analogous to the system  calls
used  in  assembly  language.   OPEN  is  used to associate a channel
number (0 to '17) with a device, to determine the data  mode  of  the
I/O to occur on this channel (character mode, binary mode, dump mode,
etc.), to specify storage requirements for the data buffers  used  in
the operations, and to provide the system with information to be used
for input operations.
          


CHANNEL is a user-provided channel  number  which  will  be  used  in
       subsequent I/O operations to identify the device.  CHANNEL may
       range from 0 to 15 ('17).  If some file  is  already  open  on
       this  channel,  a  RELEASE  will be performed for that channel
       before the OPEN is executed.


DEVICE must be a String (i.e.  "TTY", "DATA") which  is  recognizable
       by the system as a physical or logical device name.


MODE  is the data mode for the I/O operation.   MODE  0  will  always
       work for characters ( see Input, 12-40 and Out, 12-45).  Modes
       8 ('10) and 15 ('17) are applicable for binary  and  dump-mode
       operations  using  the  functions  WORDIN, WORDOUT, ARRYIN, or
	       ARRYOUT (see Wordin, 12-48 and  following).   For  other  data
       modes, see [Moorer].
       If any of bits 18-21 are on in the MODE word, the I-O routines
       will not print error messages when  data  errors  occur  which
       present  the  corresponding  bits  as a response to the GETSTS
       UUO.  Instead, the GETSTS bits will be reported to the user as
       described  under EOF below.  If bit 23 is on, no error message
       will be printed if  an  invalid  file  name  specification  is
       presented  to LOOKUP, ENTER, or RENAME, a code identifying the
       problem  will  be  returned  (see  Lookup,  Enter,  12-17  and
       following,   Rename,   12-21   for  details).   If  you  don't
       understand any of this, leave all non-mode  bits  off  in  the
       MODE word.
SAILON NO. 57.2					SAIL   12-7



NUMBEROF{INPUT/OUTPUT~BUFFERS specifies the number of buffers to be
       reserved for the I/O operations (see  [Moorer]  for  details).
       At  least  one buffer must be specified for input if any input
       is to be done in modes other than '17; similarly  for  output.
       If  data  is  only  going  one  direction,  the  other  buffer
       specification  should  be  0.   Two  buffers  give  reasonable
       performance  for most devices (1 is sufficient for a TTY, more
       are required for DSK if rapid operation is desired).
       The left half of the BUFFER parameter, if non-zero,  specifies
       the  buffer  size  for  the I/O buffers.  Use this only if you
       desire non-standard sizes.
   
   
12-8.    The  remaining  arguments  are  applicable  only  for  INPUT
(String  input).   They  will  be  ignored  for  any other operations
(although their values may be changed by the Open function).


COUNT     designates a variable which will contain the maximum number
          of  characters  to  be  read from "DEVICE" in a given INPUT
          call (see Input, 12-40, Breakset, 12-22).  Fewer characters
          may  be  read  if a break character is encountered or if an
          end of file is detected.  The count should be a variable or
          constant  (not an expression), since its address is stored,
          and the temporary storage for an expression may be re-used.


BRCHAR    designates a variable into which the break  character  (see
          INPUT  and  BREAKSET  again) will be stored.  This variable
          can  be  tested  to  determine  which  of   many   possible
          characters terminated the read operation.
SAILON NO. 57.2					SAIL   12-8



EOF       designates a variable to be used for two purposes:

   1)  If EOF is 0 when OPEN is called, a SAIL error message  will
       be  invoked  if the device is not available.  The user will
       be  given  the  options  of  retrying  or  terminating  the
       operation.  If EOF is non-zero when OPEN is called, it will
       be set to 0 if the OPEN is successful.  Otherwise  it  will
       not  be  changed.   In  this  case  (EOF non-zero on entry)
       control will be returned to the user.  This flag  may  then
       be tested.

   2)  EOF will  be  made  non-zero  (TRUE)  if  an  end  of  file
       condition,  or any error condition among those enabled (see
       MODE, above)  is  detected  during  any  SAIL  input/output
       operation.   It  will  be  0  (FALSE) on return to the user
       otherwise.  Subsequent inputs  after  an  EOF  return  will
       return  non-zero values in EOF and a null String result for
       INPUT.  For ARRYIN , a 0 is returned as the  value  of  the
       call  after  end of file is detected.  If EOF is TRUE after
       such an operation, it will contain the entire set (18 bits)
       of  GETSTS  information  in  the left half.  The EOF bit is
       '20000, and is the only one you'll ever see if you  haven't
       specially  enabled  for  others.   A  summary of the enable
       bits, the  EOF  and  error  bits,  and  their  meanings  is
       contained  in  the  Appendix  NON-FATAL  ERROR, EXCEPTIONAL
       CONDITION RETURN CODES, 18-11.
   
   
Assembly Language Approximation to OPEN
   
   
12-9.    
        INIT    CHANNEL,MODE
        SIXBIT  /DEVICE/
        XWD     OHED,IHED
        JRST    <handle error condition>
        JUMPE   <NUMBEROFOUTPUTBUFFERS>,GETIN
        <allocate buffer space>
        OUTBUF  CHANNEL,NUMBEROFOUTPUTBUFFERS
GETIN:  JUMPE   <NUMBEROFINPUTBUFFERS>,DONE
        <allocate buffer space>
        INBUF   CHANNEL,NUMBEROFINPUTBUFFERS
DONE:   <mark channel open -- internal bookkeeping>
        <return>
   
OHED:   BLOCK   3
IHED:   BLOCK   3
SAILON NO. 57.2					SAIL   12-9

                                    
                                    
                         Close, Closin, Closo                                                      
   
   
Form:
   
   
12-10.    
CLOSE ( CHANNEL )
CLOSIN ( CHANNEL )
CLOSO ( CHANNEL )
   
Function:
   
   
12-10.    The input (CLOSIN) or output (CLOSO) side of the  specified
channel is closed: all output is forced out (CLOSO); the current file
name is forgotten.  However the device is still active; no OPEN  need
be done again before the next input/output operation.  No INPUT, OUT,
etc.  may be given to a directory device until an ENTER,  LOOKUP,  or
RENAME has been issued for the channel.
   
   
12-11.    CLOSE  is  equivalent  to  the execution of both CLOSIN and
CLOSO for the channel.
                                    
                                    
                               Getchan                                                                   
   
   
Form:
   
   
12-12.    VALUE _ GETCHAN;
   
	   
Function:
   
   
12-13.    The number of some channel not currently open is  returned.
-1 is returned if all channels are busy.
SAILON NO. 57.2					SAIL   12-14

                                    
                                    
                               Release                                                                   
   
   
Form:
   
   
12-14.    RELEASE ( CHANNEL );
   
   
Function:
   
   
12-15.    If  an  OPEN has been executed for this channel, a CLOSE is
now executed for it.  The device is dissociated from the channel  and
returned  to  the  resource  pool (unless it has been assigned by the
monitor ASSIGN command).  No I/O operation may refer to this  channel
until another OPEN denoting it has been executed.
   
   
12-16.    Release  is  always valid.  If the channel mentioned is not
currently open, the command is simply ignored.
                                    
                                    
                            Lookup, Enter                                                             
   
   
Form:
   
   
12-17.    
LOOKUP ( CHANNEL , "FILE" , @FLAG );
ENTER ( CHANNEL , "FILE" , @FLAG );
   
   
Function:
   
   
12-18.    Before input or output operations may be  performed  for  a
directory device (DECtape or DSK) a file name must be associated with
the channel on which the device has been  opened  (see  Open,  12-6).
LOOKUP names a file which is to be read.  ENTER names a file which is
to be created or extended (see [Moorer]).  Both operations are  valid
even  if  no filename is really necessary.  It is recommended that an
ENTER be performed after every OPEN  of  an  output  device  so  that
output  not  normally  directed  to the DSK can be directed there for
later processing if desired.  The format for a file name string is
SAILON NO. 57.2					SAIL   12-18


	NAME ,
	NAME.EXT ,
	NAME[P,PN] ,
   or   NAME.EXT[P,PN] (see [Moorer] for the meaning of these things
			if you do not immediately understand).

All characters are converted to SIXBIT by moving the '100 bit to  the
'40 bit.  SAIL is not as choosy about the characters it allows as PIP
and other processors are.  Any character which is not ".", ",",  "[",
or  "]"  will  be  converted  and passed on.  Up to 6 characters from
NAME, 3 from EXT, P, or PN will be converted -- the rest are ignored.
   
   
12-19.    If the LOOKUP or ENTER operation fails (see [Moorer])  then
variable  FLAG may be examined to determine the cause.  The left half
of FLAG will be set to '777777 (Flag has  the  logical  value  TRUE).
The  right  half  will contain the code returned by the system giving
the cause of the failure.  An invalid file specification will  return
a  code  of  '10.   In this case, if the appropriate bit (bit 23, see
OPEN) was OFF in the MODE parameter of the  OPEN,  an  error  message
will   be  printed;  otherwise,  the  routine  just  returns  without
performing the UUO.
   
   
12-20.    If the LOOKUP or ENTER succeeds, FLAG will be set  to  zero
(FALSE).
                                    
                                    
                                Rename                                                                    
   
   
Form:
   
   
12-21.    RENAME ( CHANNEL , "FILE-SPEC" , PROTECTION , @FLAG );
SAILON NO. 57.2					SAIL   12-22

   
   
Function:
   
   
12-22.    The  file  open  on CHANNEL is renamed to FILESPEC (a NULL
file-name  will  delete  the  file)  with  read/write  protection  as
specified  in  PROTECTION  (nine  bits, described in the time-sharing
manual).  FLAG is set as in LOOKUP and ENTER.
                                    
                                    
                               Breakset                                                                  
   
   
Form:
   
   
12-22.    BREAKSET( TABLE, "BREAKCHARS" , MODE);
   
   
Function:
   
	   
12-23.    Character input/output is done using the String features of
SAIL.   In  fact, I/O is the chief justification for the existence of
strings in the language.
    String input presents a problem not  present  in  String  output.
The length of an output String can be used to determine the number of
characters written.  However  it  is  often  awkward  to  require  an
absolute  count  for  input.  Quite often one would like to terminate
input, or "break", when one of  a  specified  set  of  characters  is
encountered  in  the  input  stream.   In  SAIL,  this  capability is
implemented  by  means  of  the  BREAKSET,  INPUT,  TTYIN,  and  SCAN
functions.
   
   
12-24.    The  value  of TABLE may range from 1 to 18.  Thus up to 18
different sets of break specifications may exist at once.  Which  set
will be used is determined by the TABLE parameter in an INPUT or SCAN
function call.
   
   
12-25.    The function of a given BREAKSET  command  depends  on  the
MODE,  an  integer  which  is  interpreted as a right-justified ASCII
character whose value is intended to be vaguely  mnemonic.   BREAKSET
commands can be partitioned into 3 groups according to mode:
SAILON NO. 57.2					SAIL   12-26

   
   
GROUP 1 -- Break character specifications
   
   
12-26.    


MODE     FUNCTION


"I"      (by Inclusion) The characters in the  BREAKCHARS  String
          comprise  the  set of characters which will terminate an
          INPUT (or SCAN).


"X"      (by eXclusion) Only those characters (of the possible 128
          ASCII  characters) which are NOT contained in the String
          BREAKCHARS will terminate  an  input  when  using  this
          table.


"O"      (Omit) The characters in "BREAKCHARS"  will  be  omitted
          (deleted) from the input string.
   
   
12-27.    Any  "I"  or  "X"  command  completely  specifies the break
character set for its table (i.e., the table is  reset  before  these
characters  are  stored  in  it).   Neither  will destroy the omitted
character set currently specified for this table.   Any  "O"  command
completely  specifies the set of omitted characters, without altering
the break characters for the table in question.  If a character is  a
break-character,  any  role  it might play as an omitted character is
sacrificed.
   
   
12-28.    The second group of MODEs  determines  the  disposition  of
break  characters in the input stream.  The "BREAKCHARS" argument is
ignored in these commands, and may in fact be NULL:
   
   
SAILON NO. 57.2					SAIL   12-29

   
   
GROUP 2 -- Break character disposition
   
   
12-29.    


MODE     FUNCTION


"S"      (Skip -- default mode) After execution of an "S"  command
          the  break  character  will  not  appear  either  in the
          resultant String or in subsequent INPUTs or SCANs--  the
          character  is  "skipped".   Its  value may be determined
          after the INPUT by examination of  the  break  character
          variable (see Open, 12-6).


"A"      (Append) The break character (if  there  is  one  --  see
          Open,   12-6   and   Input,   12-40)   is  appended,  or
          concatenated to the end of the input  string.   It  will
          not appear again in subsequent inputs.


"R"      (Retain) The break  character  does  not  appear  in  the
          resultant  INPUT  or  SCAN String, but will be the first
          character processed in the next operation  referring  to
          this input source (file or SCAN String).
   
	   
12-30.    For  disk  and tape files using the standard editor format,
line numbers present a special problem.  A  line  number  is  a  word
containing  5  ASCII characters representing the number in bits 0-34,
with a "1" in bit 35.  No other words in the file contain 1's in  bit
35.   Since  String  manipulations  provide no way for distinguishing
line numbers from other characters, there must be a way to  warn  the
user  that  line  numbers are present, or to allow him to ignore them
entirely.
   
   
12-31.    The third group of  MODEs  determines  the  disposition  of
these line numbers.  Again, the "BREAKCHARS" argument is ignored:
   
   
SAILON NO. 57.2					SAIL   12-32

   
   
Group 3 -- Line number disposition
   
   
12-32.    


MODE     FUNCTION


"P"      (Pass -- default) Line numbers are treated as  any  other
          characters.   Their identity is lost; they simply appear
          in the result string.


"N"      (No numbers) No line number  (or  the  TAB  which  always
          follows  it in standard files) will appear in the result
          string.  They are simply discarded.


"L"      (Line no.  break) The result String  will  be  terminated
          early  if  a line number is encountered.  The characters
          comprising the line number and the associated  TAB  will
          appear  as  the  next  6 characters read or scanned from
          this  character  source.   The  user's  break  character
          variable  (see  Open, 12-6 and Input, 12-40) will be set
          to -1 to indicate a line number break.


"E"       (lee  Erman's  very  own  mode)  The  result  String  is
          terminated on a line number as with "L", but neither the
          line number nor the TAB  following  it  will  appear  in
          subsequent  inputs.   The  line number word, negated, is
          returned in the user's (integer) BRCHAR variable.


"D"      (Display) If the TTY is a DPY, each line number from  any
          input  file will be displayed (along with a page number)
          on the right-hand side of the screen.  This mode  really
          applies  to  all  input operations after the "D" operand
          appears in any Breakset call.  There is no way  to  turn
          it off.
   
   
12-33.    Once  a  break  table is set up, it may be referenced in an
INPUT, TTYIN or SCAN call to control the scanning operation.
SAILON NO. 57.2					SAIL   12-33

   
   
Example:
   
   
12-34.    To  delimit  a  "word"  a  program  might  wish  to   input
characters until a blank, a TAB, a line feed, a comma, or a semicolon
is encountered, ignoring line numbers.   Assume  also  that  carriage
returns  are  to  be  ignored,  and that the break character is to be
retained in the character source for the next scanning operation:


    BREAKSET(DELIMS," ,;"&TAB&LF,"I"); Comment break on any of these; 
    BREAKSET(DELIMS,'15,"O"); Comment ignore carriage return;
    BREAKSET(DELIMS,NULL,"N"); Comment ignore line numbers;
    BREAKSET(DELIMS,NULL,"R"); Comment save break char for next time;

                                    
                                    
                               Setbreak                                                                  
   
   
Form:
   
   
12-35.    
   
SETBREAK ( TABLE , "BREAKCHARS" , "OMITCHARS" , "MODES" )
   
   
Function:
   
   
12-36.    SETBREAK is logically equivalent to the SAIL statement:


BEGIN "SETBREAK"
 INTEGER I;
 
 IF LENGTH(OMITCHARS) > 0 THEN
	BREAKSET(TABLE,OMITCHARS,"O");

 FOR I_1 STEP 1 UNTIL LENGTH(MODES) DO
	BREAKSET(TABLE,BREAKCHARS,MODES[I FOR 1])

END "SETBREAK"

SAILON NO. 57.2					SAIL   12-36

                                    
                                    
                                Stdbrk                                                                    
   
   
Form:
   
   
12-37.     STDBRK ( CHANNEL );
	   
   
Function:
   
   
12-38.    Eighteen   breakset   tables   have   been   selected    as
representative  of  the  more  common input scanning operations.  The
function STDBRK initializes the breakset tables by opening  the  file
SYS:BKTBL.BKT  on  CHANNEL and reading in these tables.  The user may
then reset those tables which he does not like to something  he  does
like.
   
   
12-39.    The  eighteen  tables  are  described  here  by  giving the
SETBREAKs which would be required for the user to initialize them:


DELIMS _ '15 & '12 & '40 & '11 & '14;
 Comment carriage return, line feed, space, tab, form feed;
LETTS _ "ABC ... Zabc ... z";
DIGS _ "0123456789";
SAILID _ LETTS&DIGS;

SETBREAK ( 1, '12, '15, "INS" );
SETBREAK ( 2, '12, NULL, "INA" );
SETBREAK ( 3, DELIMS, NULL, "XNR" );
SETBREAK ( 4, SAILID, NULL, "INS" );
SETBREAK ( 5, SAILID, NULL, "INR" );
SETBREAK ( 6, LETTS, NULL, "XNR" );
SETBREAK ( 7, DIGS, NULL, "XNR" );
SETBREAK ( 8, DIGS, NULL, "INS" );
	SETBREAK ( 9, DIGS, NULL, "INR" );
SETBREAK (10, DIGS&"+-@.", NULL, "XNR" );
SETBREAK (11, DIGS&"+-@.", NULL, "INS" );
SETBREAK (12, DIGS&"+-@.", NULL, "INR" );
SETBREAK (13-18, NULL, NULL, NULL );

SAILON NO. 57.2					SAIL   12-39

                                    
                                    
                                Input                                                                     
   
   
Form:
   
   
12-40.    "RESULT" _ INPUT(CHANNEL, BREAKTABLE);
   
   
Function:
   
   
12-41.    A string of characters is obtained for  the  file  open  on
CHANNEL,  and  is  returned  as  the  result.  The INPUT operation is
controlled by BREAKTABLE (see Breakset,  12-22)  and  the  reference
variables  BRCHAR,  EOF,  and COUNT which are provided by the user in
the OPEN function for this channel (see Open, 12-6).   Input  may  be
terminated  in several ways.  The exact reason for termination can be
obtained by examining BRCHAR and EOF:
SAILON NO. 57.2					SAIL   12-41

                  


EOF    BRCHAR    


0     0       End of file or an error (if enabled, see Open, 12-6
               occurred  while  reading.   The  result is a String
               containing   all   non-omitted   characters   which
               remained in the file when INPUT was called.


0      0       No break characters were encountered.   The  result
               is  a  String  of length equal to the current COUNT
               specifications for the CHANNEL (see Open, 12-6).


0      <0      A line number was encountered and the  break  table
               specified  that someone wanted to know.  The result
               String contains  all  characters  up  to  the  line
               number.   If mode "L" was specified in the Breakset
               setting up this table, bit 35 is turned off in  the
               line  number  word  so  that  it will be input next
               time.  -1 is placed in BRCHAR.   If  mode  "E"  was
               specified,  the  line number will not appear in the
               next input String, but  its  negated  ASCII  value,
               complete  with  low-order  line number bit, will be
               found in BRCHAR.


0      >0      A  break  character  was  encountered.   The  break
               character is stored in BRCHAR (an INTEGER reference
               variable, see  Open,  12-6)  as  a  right-justified
               7-bit ASCII value.  It may also be tacked on to the
               end of the result String or saved  for  next  time,
               depending  on  the  BREAKSET  mode  (see  Breakset,
               12-22).
   
   
12-42.    If break table  0  is  specified,  the  only  criteria  for
termination  are  end  of  file  or COUNT exhaustion.  The routine is
somewhat faster operating in this mode.
SAILON NO. 57.2					SAIL   12-43

                                    
                                    
                                 Scan                                                                      
   
   
Form:
   
	   
12-43.    "RESULT" _ SCAN ( @"SOURCE" , BREAKTABLE , @BRCHAR )
   
   
Function:
   
   
12-44.    SCAN functions identically  to  INPUT  with  the  following
exceptions:


1.   The source is not a data file but the String  SOURCE,  called
     by  reference.   The String SOURCE is truncated from the left
     to produce the same effect as one would obtain if SOURCE were
     a  data  file.  The disposition of the break character is the
     same as it is for INPUT.

	
2.   BRCHAR is directly specified as a parameter.  INPUT gets  its
     break character variable from a table set up by Open, 12-6.


3.   Line number considerations are irrelevant.
                                    
                                    
                                 Out                                                                       
   
   
Form:
   
   
12-45.    OUT(CHANNEL,"STRING")
   
Function:
   
   
12-45.    STRING is output to the  file  open  on  CHANNEL.   If  the
device is a TTY, the String will be typed immediately.  Buffered mode
text output is employed for this operation.  The data mode  specified
in  the  OPEN for this channel must be 0 or 1.  The EOF variable will
be set non-zero as described in Open, 12-6 if an  error  is  detected
and the program is enabled for it; 0 otherwise.
SAILON NO. 57.2					SAIL   12-45

                                    
                                    
                                Linout                                                                    
   
   
Form:
   
   
12-46.    LINOUT ( CHANNEL , NUMBER );
   
   
Function:
   
   
12-47.    ABS(NUMBER) mod 100,000 is converted to a 5 character ASCII
string.  These characters are placed in a single word in  the  output
file  designated  by CHANNEL with the low-order bit (line-number bit)
turned on.  A tab is inserted after the line number.   Mode  0  or  1
must  have been specified in the OPEN (Open, 12-6) for the results to
be anywhere near satisfactory.  EOF is set as in OUT.
                                    
                                    
                                Wordin                                                                    
   
   
Form:
   
   
12-48.    VALUE _ WORDIN ( CHANNEL )
   
   
Function:
   
   
12-49.    The next word from the file open on CHANNEL is returned.  A
0 is returned, and EOF (see Open, 12-6,Input, 12-40) set, when end of
file or  error  is  encountered.   This  operation  is  performed  in
buffered  mode  or  dump mode, depending on the mode specification in
the OPEN.
                                    
                                    
                                Arryin                                                                    
   
   
Form:
   
   
12-50.     ARRYIN ( CHANNEL , @LOC , HOWMANY );
SAILON NO. 57.2					SAIL   12-50

   
   
Function:
   
   
12-51.    HOWMANY words are read from the device and  file  open  on
CHANNEL,   and   deposited   in  memory  starting  at  location  LOC.
Buffered-mode input is done if MODE (see Open, 12-6) is '10  or  '14.
Dump-mode  input  is  done  if  MODE  is '16 or '17.  Other modes are
illegal.
   
   
12-52.    If an end of file or enabled error condition occurs  before
HOWMANY  words are read, the EOF variable (see Open, 12-6) is set to
the enabled bits in its left half, as usual.  Its right half contains
the number of words actually read.  EOF will be 0 if the full request
is satisfied.
                                    
                                    
                               Wordout                                                                   
   
   
Form:
   
   
12-53.    WORDOUT ( CHANNEL , VALUE );
   
   
Function:
   
   
12-54.    VALUE is placed in  the  output  buffer  for  CHANNEL.   An
OUTPUT  is done when the buffer is full or when a CLOSE or RELEASE is
executed for this channel.  Dump mode output will  be  done  if  dump
mode  is  specified  in  the OPEN (see Open, 12-6).  EOF is set as in
OUT.
                                    
                                    
                               Arryout                                                                   
   
   
Form:
   
   
12-55.     ARRYOUT ( CHANNEL , @LOC , HOWMANY );
SAILON NO. 57.2					SAIL   12-56

   
   
Function:
   
   
12-56.    HOWMANY  words  are  written  from  memory,  starting   at
location  LOC, onto the device and file open on channel CHANNEL.  The
valid modes are again '10, '14, '16, and '17.  The  EOF  variable  is
set as in ARRYIN, except that the EOF bit itself will never occur.
                                    
                                    
                                Mtape                                                                     
   
   
	Form:
   
   
12-57.    MTAPE ( CHANNEL , MODE );
   
   
Function:
   
   
12-58.    MTAPE  is ignored unless the device associated with CHANNEL
is a magnetic tape drive.  It performs tape actions as follows:
             
             
          MODE               FUNCTION
             
          "A"                Advance past one tape mark (or file)
          "B"                Backspace past one tape mark
          "E"                Write tape mark
	          "F"                Advance one record
          "R"                Backspace one record
          "S"                Write 3 inches of blank tape
          "T"                Advance to logical end of tape
          "U"                Rewind and unload
          "W"                Rewind tape
             
SAILON NO. 57.2					SAIL   12-59

                                    
                                    
                             Useti, Useto                                                              
   
   
Form:
   
   
12-59.    
USETI ( CHANNEL , VALUE );
USETO (CHANNEL , VALUE );
   
   
Function:
   
   
12-60.    The corresponding  system  function  is  carried  out  (see
[Moorer] ).
                                    
                                    
                            Realin, Intin                                                             
   
   
Form:
   
	   
12-61.    
VALUE _ REALIN ( CHANNEL );
VALUE _ INTIN ( CHANNEL );
   
   
Function:
   
   
12-62.     Number input may be obtained using the functions REALIN or
INTIN, depending on whether a Real number or an Integer is  required.
Both  functions use the same free field scanner, and take as argument
a channel number.
   
   
12-63.    Free  field  scanning  works  as  follows:  characters  are
scanned   one  at  a  time  from  the  input  channel.   Nulls,  line
	numbers,and carriage returns are ignored.  When a digit is scanned it
is assumed that this is a number and the following syntax is used:

<number>         ::=	<sign><real number>

<real number>	 ::=	<decimal number>|<decimal number><exponent>|
			<exponent>
SAILON NO. 57.2					SAIL   12-63



<decimal number> ::=	<integer>|<integer>.|<integer>.<integer>|
			.<integer>

<integer>	 ::=	<digit>|<integer><digit>


<exponent>	 ::=	@<sign><integer>

<digit>		 ::=	0|1|2|3|4|5|6|7|8|9

<sign>		 ::=	+|-|<empty>


   
   
12-64.    If  the digit is not part of a number an error message will
be printed and the program will halt.  Typing a carriage return  will
cause the input function to return zero.  On input, leading zeros are
ignored.  The ten most  significant  digits  are  used  to  form  the
number.   A  check  for  overflow  and underflow is made and an error
message printed if this occurs.  When using  INTIN  any  exponent  is
removed  by  scaling  the  Integer  number.  Rounding is used in this
process.   All  numbers  are  accurate  to  one  half  of  the  least
significant bit.
   
   
12-65.    After scanning the number the last delimiter is replaced on
the input string and is returned  as  the  break  character  for  the
channel.   If  no  number is found, a zero is returned, and the break
variable is set to -1; If an end of file or enabled error  is  sensed
this  is  also  returned  in  the  appropriate  channel variable.  The
maximum character count appearing in the OPEN call is ignored.
                                    
                                    
                          Realscan, Intscan                                                         
   
   
Form:
   
   
12-66.    
VALUE _ REALSCAN ( @"NUMBERSTRING" , @BRCHAR ) ; VALUE _  INTSCAN  (
@"NUMBERSTRING" , @BRCHAR );
SAILON NO. 57.2					SAIL   12-67

   
   
Function:
   
   
12-67.    These  functions  are  identical  in function to REALIN and
INTIN.  Their inputs, however, are obtained from their  NUMBERSTRING
arguments.    These   routines  replace  NUMBERSTRING  by  a  string
containing all characters left over after the number has been removed
from the front.
                                    
                                    
                        Teletype I/O Functions                                                    
   
   
Form:
   
   
12-68.    
CHAR _ INCHRW;
CHAR _ INCHRS;
"STR" _ INCHWL;
"STR" _ INCHSL ( @FLAG );
"STR" _ INSTR ( BRCHAR );
"STR" _ INSTRL ( BRCHAR );
"STR" _ INSTRS ( @FLAG , BRCHAR );
"STR" _ TTYIN ( TABLE , @BRCHAR );
   
"STR" _ TTYINL ( TABLE , @BRCHAR );
"STR" _ TTYINS ( TABLE , @BRCHAR );
OUTCHR ( CHAR );
OUTSTR ( "STR" );
CLRBUF;
BACKUP;
LODED ( "STR" );
SAILON NO. 57.2					SAIL   12-69

   
   
Function:
   
   
12-69.    Each  of  the  I/O  functions  uses  the TTYUUO UUO's to do
direct TTY I/O.

INCHRW   waits for a  character  to  be  typed  and  returns  that
         character.

INCHRS   returns a negative  value  if  no  characters  have  been
         typed; otherwise it is INCHRW.

INCHWL   waits for a line, terminated  by  a  carriage-return  and
         line  feed  (CR-LF)  to be typed.  It returns as a string
         all characters up to (not including) the CR.  The  LF  is
         lost.

INCHSL   returns NULL with FLAG  0 if no lines have  been  typed.
         Otherwise it sets FLAG to 0 and performs INCHWL.

INSTR    returns as  a  string  all  characters  up  to,  but  not
         including,  the  first  instance  of  BRCHAR.  The BRCHAR
         instance is lost.

INSTRL   waits for a line to be typed, then performs INSTR.

INSTRS   is INCHSL if no lines are waiting; INSTRL otherwise.

TTYIN    uses the break  table  features  described  in  Breakset,
         12-22  and  Input,  12-40  to  return  a string and break
         character.  Mode "R" is illegal; line  number  modes  are
         irrelevant.   The  input count (see Open, 12-6) is set at
         100.

TTYINL   waits for a line to be typed, then does TTYIN.

TTYINS   sets BRCHAR to 0  and  returns  NULL  if  no  lines  are
         waiting.  Otherwise it is TTYINL.
SAILON NO. 57.2					SAIL   12-69


OUTCHR   types  its  character  argument  (right-justified  in  an
         integer variable).

OUTSTR   types its string argument.

CLRBUF   flushes the input buffer.

BACKUP   backs up the scan (when started by a system command).

LODED    loads the line editor with the string argument.
                                    
                                    
              Pseudo-teletype functions (Stanford only)                                 
   
   
Form:
   
   
12-70.    
line _ PTYGET ;
PTYREL ( line );
characteristics _ PTGETL ( line );
PTSETL ( line , characteristics );
number _ PTIFRE ( line );
	number _ PTOCNT ( line );
char _ PTCHRW ( line );
char _ PTCHRS ( line );
PTOCHS ( line , char );
PTOCHW ( line , char );
PTOSTR ( line , "str" );
string _ PTYALL ( line );
string _ PTYSTR ( line , brchar );
string _ PTYIN ( line, bktbl , @brchar );
SAILON NO. 57.2					SAIL   12-71

   
   
Function:
   
   
12-71.    

PTYGET   gets a new pseudo-teletype line number  and  returns  it.
         The global variable .SKIP.  is -1 if the attempt to get a
         PTY was successful, and 0 otherwise.

PTYREL   releases PTY identified by "line".

PTGETL   returns line characteristics for the PTY.

PTSETL   sets  line  characteristics  for  thm  PTY  specified  by
         "line".

PTIFRE   returns the number of free characters in  the  PTY  input
         buffer.

PTOCNT   returns the number of free characters in the  PTY  output
         buffer.

PTCHRW   waits for a character from the PTY and returns it.

PTCHRS   reads a character from the PTY if there is  one,  returns
         -1 if none.

PTOCHS   tries to send a character to a PTY.  If the  attempt  was
         successful,  the global variable .SKIP.  is -1, otherwise
         0.

PTOCHW   sends a character to a PTY, waiting if necessary.

PTOSTR   sends the string to the PTY, waiting if necessary.
SAILON NO. 57.2					SAIL   12-71


PTYALL   returns whatever is  in  the  PTY's  output  buffer.   No
         waiting is done.

PTYSTR   reads characters from  the  PTY,  waiting  if  necessary,
         until  a  character equal to "char" is seen.  All but the
         break character is returned as the string.  If the  break
         character   was  '15  (carriage  return),  the  following
         line-feed is snarfed.

PTYIN    reads from the PTY (waiting if  necessary)  according  to
         break  table  conventions.  The break character is stored
         in "brchar".
            
   
   
STRING MANIPULATION ROUTINES
                                    
                                    
                                 Equ                                                                       
   
   
Form:
   
   
12-73.    VALUE _ EQU ( "STR1", "STR2" );
   
   
Function:
   
   
12-74.    The value of this function is TRUE if  STR1  and  STR2  are
equal  in length and have identically the same characters in them (in
the same order).  The value of EQU is FALSE otherwise.
   
   
TYPE CONVERSION ROUTINES
                                    
                                    
                              Setformat                                                                 
   
   
Form:
   
   
12-75.     SETFORMAT ( WIDTH , DIGITS ) ;
SAILON NO. 57.2					SAIL   12-76

   
   
Function:
   
   
12-76.    This function allows specification of a minimum  width  for
strings  created  by  the functions CVS, CVOS, CVE, CVF, and CVG (see
Cvs, 12-80 and following).   If  this  number  (WIDTH)  is  positive,
enough  blanks  will  be inserted in front of the resultant string to
make the entire results at least WIDTH characters long.  The sign, if
any,  will  appear  after  the blanks.  If WIDTH is negative, leading
zeroes will be used in place of blanks, The  sign,  of  course,  will
appear  before  the  zeroes.   This  parameter  is initialized by the
system to 0.
   
   
12-77.    In addition, the DIGITS parameter allows one to specify the
number  of  digits  to  appear following the decimal point in strings
created by CVE, CVF, and CVG.  This number is initially 7.   See  the
writeups  on  the  functions  Cve,  Cvf, Cvg, 12-92 and following for
details.
                                    
                                    
                              Getformat                                                                 
   
   
Form:
   
   
12-78.    GETFORMAT ( @WIDTH , @DIGITS ) ;
   
   
	Function:
   
   
12-79.    The  WIDTH  and  DIGIT  settings  specified  in  the   last
SETFORMAT call are returned in the appropriate reference parameters.
                                    
                                    
                                 Cvs                                                                       
   
   
Form:
   
   
12-80.    "ASCIISTRING" _ CVS ( VALUE );
SAILON NO. 57.2					SAIL   12-81

   
   
	Function:
   
   
12-81.    The  decimal Integer representation of VALUE is produced as
an ASCII String with leading zeroes omitted (unless  WIDTH  has  been
set  by  Setformat,  12-75  to  some  negative  value).   "-" will be
concatenated to the String representing the decimal absolute value of
VALUE if VALUE is negative.
                                    
                                    
                                 Cvos                                                                      
   
   
Form:
   
   
12-82.    "ASCIISTRING" _ CVOS ( VALUE );
   
   
Function:
   
   
12-83.    The octal Integer representation of VALUE is produced as an
ASCII String with leading zeroes omitted (unless WIDTH has  been  set
to  some negative value by Setformat, 12-75).  No "-" will be used to
indicate negative numbers.  For instance, -5 will be  represented  as
"777777777773".
                                    
                                    
                                 Cvis                                                                      
   
   
Form:
   
   
12-84.    "STRING" _ CVIS ( ITEM , @FLAG ) ;
   
   
Function:
   
   
12-85.    The  print name of ITEM is returned as a string.  An Item's
print name is the identifier used to declare it, or that provided  by
the  NEWPNAME function (see NewPname, 12-88).  FLAG is set to FALSE
(0) if the appropriate string is found.  Otherwise it is set to  TRUE
(-1), and you should not place great faith in the string result.
SAILON NO. 57.2					SAIL   12-85

                                    
                                    
                                 Cvsi                                                                      
   
   
Form:
   
   
12-86.    ITEM _ CVSI ( "PNAME" , @FLAG ) ;
   
   
Function:
   
   
12-87.    The  Item  whose identifier (or name provided by NewPname,
12-88) is the same as the string argument PNAME is returned and  FLAG
set  to  FALSE  if  such  an  Item exists.  Otherwise, something very
random is returned, and FLAG is set to TRUE.
                                    
                                    
                              NewPname                                                                 
   
   
Form:
   
   
12-88.    
NEWPNAME (ITEM , "STRING" )
   
   
Function:
   
   
12-89.    This function assigns to the Item the name "STRING".  Don't
perform  this  twice  for  the  same  Item without first deleting the
previous one.  The corresponding name or Item may be retrieved  using
CVIS or CVSI (above).  You must use the REQUIRE n PNAMES construct in
one of the files comprising your program for all this to work.
                                    
                                    
                              DelPname                                                                 
   
   
Form:
	   
   
12-90.    
DELPNAME ( ITEM )
SAILON NO. 57.2					SAIL   12-90

   
   
Function:
   
   
12-91.    This function deletes any string PNAME associated with this
Item.
                                    
                                    
                            Cve, Cvf, Cvg                                                             
   
   
Form:
   
   
12-92.    
"STRING"  _ CVE ( VALUE ); "STRING" _ CVF ( VALUE ); "STRING" _ CVG (
VALUE );
   
   
Function:
   
   
12-93.     Real number output is facilitated by means of one of three
functions CVE,CVG, or CVF, corresponding to the E,G, and F formats of
FORTRAN IV.  Each of these functions takes as argument a real  number
and  returns  a  string.   The  format of the string is controlled by
another function SETFORMAT (  WIDTH,DIGITS)  (see  Setformat,  12-75)
which  is  used  to  change  WIDTH from zero and DIGITS from 7, their
initial values.  WIDTH specifies the minimum string length.  If WIDTH
is  positive  leading blanks will be inserted and if negative leading
zeros will be inserted.
   
   
12-94.    The following table indicates the strings returned for some
typical numbers.   indicates a space and it is assumed that WIDTH_10
and DIGITS_3.

	   CVF    	   CVE    	   CVG
	.000	.100@-3	.100@-3
	.001	.100@-2	.100@-2
	.010	.100@-1	.100@-1
	.100	.100	.100
	1.000	.100@1	1.00
	10.000	.100@2	10.0
	100.000	.100@3	100.
	1000.000	.100@4	.100@4
SAILON NO. 57.2					SAIL   12-94


	10000.000	.100@5	.100@5
       100000.000	.100@6	.100@6
      1000000.000	.100@7	.100@7
      -1000000.000	-.100@7	-.100@7

   
   
12-95.    The first character ahead of the number is either  a  blank
or a minus sign.  With WIDTH_-10 plus and minus 1 would print as:

	   CVF    	   CVE    	   CVG
	00001.000	0.100@1	01.00
	-00001.000	-0.100@1	-01.00

   
   
12-96.    All  numbers  are accurate to one unit in the eighth digit.
If DIGITS is greater than 8, trailing zeros  are  included;  if  less
than eight, the number is rounded.
                                    
                                    
                                Cvstr                                                                     
   
   
Form:
   
   
12-97.    "STRING" _ CVSTR ( VALUE ) ;
   
   
Function:
   
   
12-98.    VALUE  is treated as a 5-character left-justified word full
of ASCII.  the result is a 5-character long String  containing  these
characters.  The low order bit of VALUE is ignored.
                                    
                                    
                                Cvxstr                                                                    
   
   
Form:
	   
   
12-99.     "STRING" _ CVXSTR ( VALUE ) ;
SAILON NO. 57.2					SAIL   12-100

   
   
Function:
   
   
12-100.    VALUE is treated as a 6-character left-justified word full
of SIXBIT.  The result is a 6-character long String containing  these
characters, converted to ASCII.
                                    
                                    
                                 Cvd                                                                       
   
   
Form:
   
   
12-101.    VALUE _ CVD ( "ASCIISTRING" );
   
   
Function:
   
   
12-102.    ASCIISTRING   should   be   a  String  of  decimal  ASCII
characters perhaps preceded by plus and/or minus  signs.   Characters
with  ASCII  values    SPACE ('40) are ignored preceding the number.
Any character not a digit will  terminate  the  conversion  (with  no
error indication).  The result is the internal (signed) 36-bit binary
representation of the number.
	                                    
                                    
                                 Cvo                                                                       
   
   
Form:
   
   
12-103.    VALUE _ CVO ( "ASCIISTRING" );
   
   
Function:
   
   
12-104.    This function is the same as CVD  except  that  the  input
characters are deemed to represent Octal values.
SAILON NO. 57.2					SAIL   12-104

                                    
                                    
                                Cvasc                                                                     
   
   
Form:
   
   
12-105.     VALUE _ CVASC ( "STRING" );
   
   
Function:
   
   
12-106.    This  is the inverse function for CVSTR.  Up to five ASCII
characters will be fetched from the beginning of  STRING  and  placed
left-justified  in VALUE.  If the String is less than five characters
	long, the right characters will be padded with null (0) characters.
                                    
                                    
                                Cvsix                                                                     
   
   
Form:
   
   
12-107.     VALUE _ CVSIX ( "STRING" );
   
   
Function:
   
   
12-108.    The inverse for CVXSTR, this function works  the  same  as
CVASC  except  that  up to six SIXBIT characters are placed in VALUE.
The characters from STRING are converted from ASCII to SIXBIT  before
depositing them in VALUE.
                                    
                                    
                                Cvfil                                                                     
   
   
Form:
   
   
12-109.     VALUE _ CVFIL ( "FILESPEC" , @EXTEN , @PPN ) ;
SAILON NO. 57.2					SAIL   12-110

   
   
Function:
   
   
12-110.    FILESPEC  has  the same form as a file name specification
for LOOKUP or ENTER.  The SIXBIT for the file  name  is  returned  in
VALUE.   SIXBIT  values  for  the  extension  and  project-programmer
numbers are returned in the  respective  reference  parameters.   Any
unspecified  portions  of  the  FILESPEC will result in zero values.
The global variable SKIP (accessed  by  declaring  it  as  EXTERNAL
INTEGER  SKIP)  will  be  0 if no errors occurred, 0 if an invalid
file name specification is presented.
   
Arrinfo
   
	   
Form:
   
   
12-110.     VALUE _ ARRINFO ( ARRAY , PARAMETER );
   
   
Function:
   
   
12-111.    

ARRINFO(ARRAY,-1)  returns the number of dimensions for the array.
                   This number is negative for String arrays.

ARRINFO(ARRAY,0)   returns the total size of the array in words.

ARRINFO(ARRAY,1)    returns  the  lower  bound   for   the   first
                   dimension.

ARRINFO(ARRAY,2)    returns  the  upper  bound   for   the   first
                   dimension.

ARRINFO(ARRAY,3)    returns  the  lower  bound  for   the   second
                   dimension.

ARRINFO( ...)      etc.
SAILON NO. 57.2					SAIL   12-112

                                    
                                    
                                Arrblt                                                                    
   
   
Form:
   
   
12-112.     ARRBLT ( @LOC1 , @LOC2 , NUM );
   
   
Function:
   
   
12-113.    NUM  words  are  transferred  from  consecutive  locations
starting  at  LOC2  to  consecutive  locations  starting at LOC1.  No
bounds checking is performed.  This function does not work  well  for
String Arrays.
                                    
                                    
                               Arrtran                                                                   
   
   
Form:
   
   
	12-114.     ARRTRAN ( ARRAY1, ARRAY2 );
   
   
Function:
   
   
12-115.    This  function  copies  information from ARRAY2 to ARRAY1.
The transfer starts at the  first  data  word  of  each  array.   The
minimum  of  the  sizes  of  ARRAY1 and ARRAY2 is the number of words
transferred.
   
   
LIBERATION-FROM-SAIL ROUTINES
                                    
                                    
                                 Code                                                                      
   
   
Form:
   
   
12-116.     RESULT _ CODE ( INSTR , @ADDR )
SAILON NO. 57.2					SAIL   12-116

   
   
Function:
   
   
12-117.    This function is equivalent to the FAIL statements:


	EXTERNAL .SKIP.		;DECLARE AS SKIP IN SAIL
	SETOM	.SKIP.		;ASSUME SKIP
	MOVE	0,INSTR
	ADDI	0,@ADDR
	XCT	0
	SETZM	.SKIP.		;DIDN'T SKIP
	RETURN	(1)

   
In other words, it executes the  instruction  formed  by  adding  the
address  of  the  ADDR  variable  (passed by reference) to the number
INSTR.  Before the operation is carried out, AC1  is  loaded  from  a
special  cell (initially 0).  AC1 is returned as the result, and also
stored back into the special cell after the instruction is  executed.
The  global  variable  SKIP  (.SKIP.   in DDT or FAIL) is FALSE (0)
after the call  if  the  executed  instruction  did  not  skip;  TRUE
(currently    -1)    if   it   did.    Declare   this   variable   as
EXTERNAL INTEGER SKIP if you want to use it.
                                    
                                    
                                 Call                                                                      
   
   
Form:
   
   
12-118.    RESULT _ CALL ( VALUE , "FUNCTION" );
SAILON NO. 57.2					SAIL   12-119

   
   
Function:
   
   
12-119.    This function is equivalent to the FAIL statements:


	EXTERNAL .SKIP.
	SETOM	.SKIP.
	MOVE	1,VALUE
	CALL	1,[SIXBIT /FUNCTION/]
	SETZM	.SKIP.		;DID NOT SKIP
	RETURN	(REGISTER 1)

The .SKIP.  variable (SKIP in SAIL) is  set  as  described  in  the
previous paragraph (CODE).
                                    
                                    
                               Usercon                                                                   
   
   
Form:
   
   
12-120.    
USERCON ( @INDEX , @VALUE , FLAG )
	   
   
Function:
   
   
12-121.    This  function  allows  inspection  and  alteration of the
"User Table" (see User  Table,  17-1).   Declare  an  index  you  are
interested in as an External Integer (e.g., EXTERNAL INTEGER REMCHR).
This will, when loaded, give an address which  is  secretly  a  small
Integer  index  into  the User Table.  When passed by reference, this
index is available to USERCON.  The names and meanings of the various
User  Table  indices  can  be  found  in the file HEAD, wherever SAIL
	compiler program text files are sold.
   
   
12-122.    USERCON  always  returns  the   current   value   of   the
appropriate  User Table entry (the Global Upper Segment Table is used
if FLAG is negative and your system knows  about  such  things).   If
FLAG  is  odd, the contents of VALUE before the call replaces the old
value in the selected entry of the selected table.
SAILON NO. 57.2					SAIL   12-123

   
   
12-123.    By now the incredible  danger  of  this  feature  must  be
apparent  to  you.   Be  sure you understand the ramifications of any
changes you make to any User Table value.
                                    
                                    
                               Usererr                                                                   
   
   
Form:
   
   
12-124.    USERERR ( VALUE , CODE , "MSG" );
   
   
Function
   
   
12-125.    MSG is printed on the teletype.  If CODE  =  2,  VALUE  is
printed  in  decimal  on  the  same  line.  Then on the next line the
"LAST SAIL CALL" message is typed which indicates where in  the  user
program  the error occurred.  A "?" or "" character is typed and the
user may type a standard reply (see ERROR MESSAGES, 14-19).  If  CODE
is  1  or  2,  a  ""  will be typed and execution will be allowed to
continue.  If it is 0, a "?" is typed, and no  continuation  will  be
permitted.
                                    
                                    
                                Point                                                                     
   
   
Form:
   
   
12-126.    VALUE  _ POINT ( BYTE SIZE , @EFFECTIVE ADDRESS , LAST BIT
NUMBER )
   
   
Function:
   
   
12-127.    POINT  returns  a  byte  pointer  (hence  it  is  of  type
integer).  The three arguments are enough to specify the three fields
of a PDP-10 If the LAST BIT  NUMBER  is  -1,  POINT  creates  a  byte
pointer  which,  when  used with an ILDB, will pick up the first byte
from the word at EFFECTIVE ADDRESS.  Otherwise, the  three  arguments
to  POINT  are  exactly  analogous to the three arguments to POINT in
FAIL.
SAILON NO. 57.2					SAIL   13-1

                              SECTION 13
                                    
                            USE OF DEFINE
                                    
The SAIL DEFINE feature provides  a  limited  macro  capability  with
parameter substitution.  The formal syntax for DEFINE declarations is
given in DECLARATIONS, 3-1.  Use of these macros is described below.
   
   
Defining Macros
   
   
13-1.    When a macro of the form

	DEFINE MAC(X,Y) = "FOR Y_1 STEP 1 UNTIL X DO"

is seen by the compiler (either at  declaration  level  or  statement
level),  it  first associates with the "formal parameters" sequential
indices (X=1, Y=2).  Then it reads the String  constant  representing
the macro body into String space, substituting for each occurrence of
a formal parameter the  character  '177  followed  by  the  character
representing  the  index  of  this  formal  parameter.  These special
characters will be used to locate  the  actual  parameters  when  the
macro  is expanded.  The modified macro body is stored under the name
of the macro, where it lies dormant until someone mentions it again.
   
   
13-2.    In  what  follows,  the  character    will  represent   the
character  ('177)  used  to identify parameter locations.  The number
following it will always be the parameter index.  The above macro  is
stored as:

     FOR 2_1 STEP 1 UNTIL 1 DO

   
   
13-3.    A macro may be re-defined (at statement level) as many times
as desired.  The new macro body replaces the old  one.   Macro  names
follow  block  structure,  so  for a macro with the same name as some
other macro to be a redefinition, it must appear at  the  same  block
level as that other definition.
SAILON NO. 57.2					SAIL   13-4

   
   
String Constants in Macro Bodies
   
   
13-4.    String constants may be represented in macro bodies, but two
quote characters (") must be inserted for each  one  which  would  be
necessary  if  the  String  constant  appeared outside the macro body
(which after all is itself a String constant, hence the problem).
   
   
Using Macros
   
   
13-5.    When a macro name (ignore for the moment the possibility  of
parameters)  is  detected  in  a  file,  the  body  of  that macro is
retrieved and becomes the input to the SAIL scanner until the  String
is  exhausted;  the  scanner  then returns to the source file for its
	input.  The macro name itself never makes it out of the scanner.  If,
while  a  macro  body  is  providing  input,  another  macro  name is
encountered, the original macro body is  put  aside  until  this  new
macro is exhausted.  Nesting may occur to any level; however, it will
be necessary to increase the size of the compiler's DEFINE push  down
stack  if nesting gets extremely deep ( see the D switch in Switches,
14-13).
   
   
Macro Parameters
   
   
13-6.    If a macro body has been defined with formal parameters, the
compiler will look for actual parameters to satisfy them when a macro
is expanded.  Actual parameters follow the macro name, are surrounded
by parentheses and separated by commas.
SAILON NO. 57.2					SAIL   13-7

   
   
13-7.    A macro parameter is scanned as a String constant.  However,
for convenience, the following special rules apply to the scanning of
a macro actual parameter:
   

  1)  All blank characters after the left parenthesis are ignored.

  2)  If the first non-blank character is not the " character, the
      parameter  String  will  be terminated by a comma or a right
      parenthesis, which will not appear in the parameter.  If the
      "  character  is  subsequently  found,  it is treated as any
      other text character.

  3)  If the first non-blank character is  the  "  character,  the
      parameter  is  scanned  using  the  normal  rules for String
      constants.
   
   
Example
   
   
13-8.    

	MAC("I","J") is equivalent to MAC(I,J);
	MAC("J+3" , "X&""A STRING""")
	  is equivalent to MAC(J+3,X&"A STRING");

 but	MAC("""A STRING""","PROC(I,J)") 

may not be abbreviated, because the meaning of the " character  would
otherwise  be  ambiguous  in  the  first argument, and the commas and
parentheses need protection in the second.
   
   
Actual Parameter Expansion
   
   
13-9.    The actual parameter strings are stored in an  ordered  list
just before the input stream is switched to the macro body.  When one
	of the number pairs appears, the input stream  is  switched  to  the
(number)th   actual   parameter.    Other  macros  (with  or  without
parameters) may appear in these actual parameters  without  confusing
the scanner (sic).
SAILON NO. 57.2					SAIL   13-10

   
   
13-10.    For  an  actual  parameter to be recognized eventually as a
String constant, enough " characters must surround it to allow one to
survive  on  each end when it passes through the scanner for the last
time.  To be sure, the implementation of this feature is so  wondrous
that  even  the  authors  must resort to trial and error methods when
complicated things are done\enod\attempted.
   
   
Examples
   
   
13-11.    


DEFINE TTY="1", SRC="2", BRKONLFD="2";
	Comment for constant parameters for which
	  it is desirable to include symbolic names,
	  this is more efficient than assigning the
	  parameter values to variables;

DEFINE TYPE(MSG)= "OUT(TTY,MSG)";
	Comment note inclusion of TTY macro in the
	  body of the TYPE macro;

DEFINE TYPEC(MSG)="OUT(TTY,""MSG"")";
	Comment argument always to be made into
	  a String constant;

DEFINE DEBUGGING = "TRUE", INP1(VBL,WHERE)=
 "BEGIN
   VBL_INPUT(SRC,BREAKONLFD);
   IF DEBUGGING THEN
	TYPE(""""""INPUT TO VBL AT WHERE IS""""&VBL"");
  END"; Comment (probably);


Using these definitions,
	
	INP1(STR,INITIAL READ) expands to:

	BEGIN
	 STR_INPUT(2,2);
	 IF TRUE THEN
		OUT(1,"INPUT TO STR AT INITIAL READ IS "&STR);
	END;

   
SAILON NO. 57.2					SAIL   14-1

                              SECTION 14
                                    
                          COMPILER OPERATION
                                    
   
   
COMMAND FORMAT
   
Syntax
   
   
14-1.    

<commandline>           ::= <binaryname> <listingname> _ 
                                <sourcelist>
                         ::= <filespec> @
                         ::= <filespec> EXC 

<binaryname>            ::= <filespec>
                         ::= <empty> 

<listingname>           ::= , <filespec>
                         ::= <empty> 

<sourcelist>            ::= <filespec>
                         ::= <sourcelist> , <filespec> 

<filespec>              ::= <filename> <fileext> <projprog>
                         ::= <devicename> <filespec> <switches>
                         ::= <devicename> <switches> 

<filename>              ::= <legalsixbitid> 

<fileext>               ::= . <legalsixbitid>
                         ::= <empty> 

<projprog>              ::= [ <legalsixbitid> , <legalsixbitid> ]
                         ::= <empty> 

<devicename>            ::= <legalsixbitid> 

<switches>               ::= ( <unslashedswitchlist> )
                         ::= <slashedswitchlist>
                         ::= <empty> 

<unslashedswitchlist>  ::= <switchspec>
                         ::= <unslashedswitchlist> <switchspec> 
SAILON NO. 57.2					SAIL   14-1


<slashedswitchlist>    ::= / <switchspec>
                         ::= <slashedswitchlist> / <switchspec> 

<switchspec>            ::= <validswitchname>
                         ::= <signedinteger> <validswitchname> 

<validswitchname>      ::= D
                         ::= L
                         ::= M
                         ::= P
                         ::= Q
                         ::= R
                         ::= S
                         ::= C
                         ::= F 
   
   
   
Semantics
   
   
14-2.    All this is by way of saying that SAIL accepts  commands  in
essentially  the same format accepted by DEC processors such as MACRO
and FORTRAN.  The binary file name is the name of the  output  device
and  file  on which the ready to load object program will be written.
The listing file, if included, will contain  a  copy  of  the  source
files  with  a  header  at  the top of each page and an octal program
counter entry at the head of each line (see Listing Features, 14-13).
The  listing  file  name  is often omitted (no listing created).  The
source file list specifies a set of user-prepared files  which,  when
concatenated, form a valid SAIL program (one outer block).
   
   
14-3.    legalsixbitidentifier is a name which is acceptable to the
time sharing system as a valid file  name,  device  name,  extension,
etc.   when  its  first  six  (device,  file)  or  three  (extension,
project-programmer number) are converted from ASCII to  SIXBIT.   For
more information about file and device names, see [Moorer].
   
   
14-4.    If  fileext  is omitted from the binaryname, the extension
for the output file will be .REL.   The  default  extension  for  the
listing file is .LST.  SAIL will first try to find source files under
the names given.  If this fails, and the extension  is  omitted,  the
same file with a .SAI extension will be tried.
SAILON NO. 57.2					SAIL   14-5

   
	   
14-5.    If devicename is omitted, DSK: is assumed.  If projprog is
omitted, the project-programmer number for the job is assumed.
   
   
14-6.    Switches are parameters which affect the  operation  of  the
compiler.   A  list  of switches may appear after any file name.  The
parameters specified are changed  immediately  after  the  file  name
associated  with them is processed.  The meanings of the switches are
given below.
   
   
14-7.    The binary,  listing  and  (first)  source  file  names  are
processed  before  compilation  -- subsequent source names (and their
switches) are processed whenever an end-of-file condition is detected
in  the current source file.  Source files which appear after the one
containing the outer block's END delimiter are ignored.
   
   
14-8.    Each new line in the  command  file  (or  entered  from  the
teletype)  specifies  a  separate program compilation.  Any number of
programs can be compiled by the same SAIL core image.
   
   
14-9.    The filespec@ command  causes  the  compiler  to  open  the
specified  file  as  the command file.  Subsequent commands will come
from this file.  If any of  these  commands  is  filespec@,  another
switch will occur.
   
   
14-10.    The  filespec! command will cause the specified file to be
run as the next processor.  This program  will  be  started  in  "RPG
mode".   That  is,  it will look on the disk for its commands if its
standard command file is there --  otherwise,  command  control  will
revert  to  the  TTY.  The default option for this file name is .DMP.
The default device is SYS.
   
   
14-11.    For information about logging in, running jobs, and so  on,
see [Moorer].
SAILON NO. 57.2					SAIL   14-12

   
   
Rpg Mode
   
   
14-12.    The  COMPILE,  DEBUG,  LOAD,  and  EXECUTE  set  of  system
commands may be used to compile and run SAIL programs.  See  [Moorer]
for  details.   A  typical  command  String to the system (which will
prepare commands of the form described above and pass  them  to  SAIL
(after starting it) might be:

   DEBUG /SAIL RECOG(-2L5MRR)=BEG+PROCS+RECOG/LIST,CMDSCN[1,DCS]

This command will cause the following commands to be placed in a file
on your area by the name of QQSAIL.RPG:

   RECOG.REL,RECOG.LST(-2L5MRR)_BEG,PROCS,RECOG
   CMDSCN.REL_CMDSCN[1,DCS]
   LOADER!

The /SAIL entry may be omitted if all files have  a  .SAI  extension.
The  loader  will  load the files with DDT or RAID and then start the
specified debugging program.
SAILON NO. 57.2					SAIL   14-13

   
   
Switches
   
   
14-13.    The following table describes the SAIL parameter  switches.
If  the  switch letter is preceded in the table by the D character, a
decimal number is expected as an argument.  0 is the  default  value.
The  character  O indicates that an octal number is expected for this
switch.  Otherwise the argument is ignored.

ARG   SWITCH  FUNCTION

      C       This switch turns on CREFfing.  The listing file (which
              must exist) will be in a format suitable for processing
              by  CREF,   the   program   which   will   generate   a
              cross-reference listing of your SAIL program.

      D       For every occurrence of  this  switch  in  the  command
              line,  the amount of space for the push down stack used
              in expanding  macros  (see  USE  OF  DEFINE,  13-0)  is
              doubled.   Use this switch if the compiler indicates to
              you that this stack  has  overflowed.   This  shouldn't
              happen  unless  you nest DEFINE calls extremely deeply.
              The compiler is initialized with /6f (i.e.   list  line
              numbers and macro names).

O     F       O is an octal number which specifies exactly what  kind
              of listing format is generated.  O contains information
              about 5 separate listing features,  each  of  which  is
              assigned a bit in O.

		1	List the program counter (see / L switch below).
		2	List with line numbers from the source text.
		4	List the macro names before expansion.
	       10	Expand macro texts in the listing file.
	       20	Surround each listed macro expansion with  and  .

O     L       In compiling  a  SAIL  program,  an  internal  variable
              called  PCNT  (for  program counter) is incremented (by
              one) for each word  of  code  generated.   This  value,
              initially  0,  represents the address of a word of code
              in the running program, relative to the load point  for
              this program.  The current octal value of PCNT plus the
              value of another internal variable called LSTOFFSET, is
              printed  at  the  beginning  of  each  output line in a
              listing file.  For the  first  program  compiled  by  a
              given  SAIL  core  image, LSTOFFSET is initially 0.  If
              the L switch occurs in the command and the value  O  is
SAILON NO. 57.2					SAIL   14-13

              non-negative,   O   replaces   the   current  value  of
              LSTOFFSET.  If O is -1, the current size of DDT is  put
              into  LSTOFFSET.   If O is -2, the current size of RAID
              is used.  In "RPG mode" the  final  value  of  PCNT  is
              added  to  LSTOFFSET  after  each compilation.  Thus by
              deleting all  .REL  files  produced  by  SAIL,  and  by
              compiling  all  SAIL  programs  which  are to be loaded
              together with one RPG  command  which  includes  the  L
              switch,  you can obtain listing files such that each of
              these octal numbers represents the actual starting core
              address  of  the code produced by the line it precedes.
              At the time of this writing, RPG would not accept minus
              signs  in  switches  to  be  sent  to processors.  Keep
              trying.

D     M       D is a number from 1 to 6.   This  parameter  puts  the
              compiler  in  one  of  several  debugging  modes.  This
              switch is most useful to compiler fixers, but  some  of
              the  modes  are  of  general  interest.   The functions
              represented by each of these  modes  are  described  in
              Debugging modes, 14-14 below.

      P       Each occurrence of this switch doubles the size of  the
              system  push  down  list.   It  has never been known to
              overflow.

      Q       Each occurrence doubles the size  of  the  String  push
              down  list.   No  trouble  has  been  encountered here,
              either.

      R       Each occurrence doubles  the  size  of  the  compiler's
              parsing   and  semantic  stacks.   A  long  conditional
	              statement of the form (IF ...  THEN ...   ELSE  IF  ...
              THEN  ...  ELSE IF ...  ) has been known to cause these
              stacks to overflow their normally allocated sizes.

D     S       The size of String space is Set  to  D  words.   String
              space usage is a function of the number of identifiers,
              especially macros, declared by the user.  In  the  rare
              case  of  String space exhaustion, 5000 is a good first
              number to try.
SAILON NO. 57.2					SAIL   14-14

   
   
Debugging modes
   
   
14-14.    Certain versions of the  SAIL  compiler  have  a  debugging
facility  built  into the inner loop of the parser.  It is willing to
display information about the current state  of  the  compilation  at
strategic  times.   This  routine  can be in one of several modes.  A
debugging mode is initially specified using the  M  switch  described
above.   It can be changed by the user as the compilation progresses.
The modes and their functions are as follows:

  1)   Just  before  each  code-generator  is  called,  its  name  is
      displayed  on  the  TTY  along with the top few elements of the
      parse and semantic stacks.  If the TTY is a DPY, one also  gets
      the  current input line with an arrow underneath indicating the
      next element to be scanned.  If you do not know  what  to  look
      for  in  the  stack,  don't  use this mode.  Compilation may be
      continued by typing the character "P".

  2)  No information is displayed in this mode.  However line  breaks
	      and asynchronous breaks (see below) can still occur.

  3)  Just before each parse production  is  compared  to  the  parse
      stack,  the  name  of  the production and the other information
      mentioned  above  is  presented.   Proceed   by   typing   "P".
      Compilation takes forever in this mode.

  4)  This mode does not cancel any of modes 1, 2,or 3.  However,  it
      puts  the  debugging  routines  in a mode wherein they will not
      wait for a user go-ahead before proceeding  from  the  displays
      described  for  these  modes.  Line and asynchronous breaks are
      still enabled in this mode, and may be used to  regain  control
      of things.

  5)  This mode has no very useful application if the TTY is really a
      TTY.   However  if it is secretly a DPY, the current input line
      is continuously presented  along  with  an  arrow  showing  the
      compiler's  progress through it.  No user go-ahead is necessary
      after each presentation.  All other modes are cancelled.   Line
      and asynchronous breaks are enabled.

	  6)  This is the default mode.  No information  is  displayed.   The
      debugging routines are completely detached from the compilation
      loop.  Line and asynchronous breaks are disabled.  The only way
      to get any of the information described above is to start over.
SAILON NO. 57.2					SAIL   14-15

   
   
14-15.    If  you have the compiler in a position where it is willing
to listen to a "P" to continue, you may also type some other  things.
The  most interesting one is the "L" command.  Typing "L" followed by
a 5 character  line  number,  a  "/",  and  a  decimal  page  number,
terminated  with  a  carriage return, causes the compiler to remember
this page and line number, and to stop with a Line Break message  and
the  information  described  above  just after the specified line has
been read.  At this point you may change modes (see below) or not, as
you prefer, and type "P" to continue.  This command is really not too
useful unless you are a compiler fixer.
   
   
14-16.     To change  modes  while  compiling,  type  any  number  of
parameter-M  pairs  to the debugging interpreter before typing "P" to
go on.
   
   
14-17.     To get the compiler's attention when it  is  operating  in
one  of  the  modes  2, 4, or 5, simply type a carriage return.  Very
shortly the compiler will display an Asynchronous Break message,  the
print  line, and some stack elements.  Then you may change modes, set
a line break, or simply proceed.  This  is  often  useful  simply  to
convince  yourself  that  your program is still being compiled if you
are running in mode 2.  If you are operating in mode 6, the  compiler
will  not  listen  to your plea.  Start the compiler in mode 2 if you
want  this  feature,  but  be  warned  that  things  will  slow  down
considerably (10%?).
   
   
14-18.    Here  is  an  example  of a compile string which a user who
just has to try every bell and whistle available to him might type to
compile a file named NULL:


COMPILE /LIST /SAIL NULL(RR-2L1M4M5000S) 

The   switch  information  contained  in  parentheses  will  be  sent
unchanged to SAIL.  Note the  convention  which  allows  one  set  of
parentheses enclosing a myriad of switches to replace a "/" character
inserted before each one.  This string tells the compiler to  compile
NULL  using  parse  and  semantic stacks four times larger than usual
(RR).  A listing file is to be made which assumes that RAID  will  be
loaded  and  NULL  will  be  loaded right after RAID (-2L).  The user
wants to see  the  stack  and  input  line  just  before  every  code
generating  routine is called (1M), but he does not want the compiler
to stop after each display (4M).  His program is big enough  to  need
5000 words of String space (5000S).
SAILON NO. 57.2					SAIL   14-18

   
   
ERROR MESSAGES
   
   
14-19.    If  the  compiler  detects a syntax or semantic error while
compiling a program it will  provide  the  user  with  the  following
information:

  1)  The error message.  These are English phrases  or  sentences
      which  attempt  to  diagnose  the  problem.  If a message is
      vague it is because no specific test for the error has  been
      made  and  a  catchall  routine detected it.  If the message
      begins with the word "DRYROT" it means that there is  a  bug
      in  the  compiler which some strangeness in your program was
      able to tickle.  See a system programmer about this.

  2)  The current input line.  Page and line  number,  along  with
      the  text  of  the  line  being  scanned, are typed.  If the
      console device is a TTY, a line feed will occur at the point
      in the line just following the last program element scanned.
	      If the device is a DPY, the line will be  displayed  with  a
      vertical  arrow  below  the scan position.  The absence of a
      position indicator means that a macro (DEFINE) body is being
      expanded.

  3)  "CALLED FROM xxxxx".  This is a message of value to compiler
      debuggers only.

  4)  A question mark or arrow ( or ^).
SAILON NO. 57.2					SAIL   14-20

   
   
14-20.    Respond to the prompt in any of the following ways:

  CR  Try to continue compilation.  A message will be printed  and
      the  sequence  reentered if recovery is impossible (if a "?"
      was typed instead of an arrow).

  LF  Continue and don't stop from now on.  The program  will  not
      stop  if  it  can  help  it.   Messages  will  fly by (at an
      unreadable rate on DPYs) until the compilation  is  complete
      or  an  error occurs from which no recovery is possible.  In
      the latter case the question sequence is reentered.

  S   Restart.  Sometimes useful if you are debugging the compiler
      (or  if  you were compiling the wrong file).  The program is
      restarted, accepting compilation commands from the TTY.

  X   Exit.  All files are closed in  their  current  state.   The
      program exits to the system.

  L   Look at stack.  This enters a part of the debugging  routine
      (see  Debugging  modes, 14-14 above) to allow examination of
      the parse and semantic stacks.  The compiler will  lead  you
      by the hand through these procedures.

  E   Edit.  This command must be followed by a  carriage  return,
      or a space, a filename (in standard format, assumes DSK) and
      a carriage return.  If the  filename  is  missing,  the  SOS
      editor  (see  [Savitzky])  is started, given instructions to
      edit the current source file and to move the editing pointer
      to  the  current  page  and  line number.  If a file name is
      present, that file is  edited  starting  at  the  beginning.
      This  feature  is available outside Stanford only if the SOS
      editor is available, and is modified to read a standard  CCL
      file for its input.

  D   Enter DDT or RAID if one is  loaded.   Otherwise,  type  "NO
      DDT" and re-question.
   
   
14-21.    Any  other  character will cause the error routines to spew
forth a summary of this table and re-enter the question sequence.
SAILON NO. 57.2					SAIL   14-22

   
   
STORAGE ALLOCATION
   
   
14-22.    The compiler dynamically allocates working storage for  its
push down lists, symbol tables, string spaces, etc.  It normally runs
with a  standard  allocation  adequate  for  most  programs.   Switch
settings  given  above  may  be used to change these allocations.  If
desired, these allocations may also be changed by typing ^C, followed
by REE (reenter).  The compiler will ask you if you want to allocate.
Type Y to allocate, N to use the standard allocation, and  any  other
character  to  use  the  standard allocations and print out what they
are.  All entries will  be  prompted.   Numbers  should  be  decimal.
Typing  alt-mode  instead  of CR will cause standard allocation to be
used for  the  remaining  values.   The  compiler  will  then  start,
awaiting command input from the teletype.
   
   
14-23.    For  Stanford  "Global  Model"  users, the REE command will
also  delete  any  REQUIREd  or   previously   typed   segment   name
information.   The  initialization  sequence  will  then  ask for new
names.
SAILON NO. 57.2					SAIL   15-1

                              SECTION 15
                                    
                          PROGRAM OPERATION
                                    
   
   
LOADING AND STARTING SAIL PROGRAMS
   
Loading
   
   
15-1.    Load the main program,  any  separately  compiled  procedure
files  (see  Separately  Compiled  Procedures,  16-7),  any  assembly
language (see PROCEDURE IMPLEMENTATION, 17-48) or Fortran procedures,
and  DDT  or  RAID  if desired.  This is all automatic if you use the
LOAD or DEBUG or EXECUTE system commands (see [Moorer]).  Any of  the
SAIL  execution  time  routines  requested  by  your  program will be
searched out and loaded automatically from  SYS:LIBSAI.REL.   If  the
shared  segment  (SYS:SAISEG, etc.) is available and desired, type /Y
as as your very first LOADER command (before /D even).  This is  done
automatically by RPG at Stanford.
   
   
Starting the Program -- Normal Operation
   
   
15-2.    For  most  applications,  SAIL programs can by started using
the START, RUN, EXECUTE, or TRY system commands, or by using  the  $G
command  of  DDT (RAID).  The SAIL storage areas will be initialized.
This means that all  knowledge  of  I/O  activity,  associative  data
structures,  strings,  etc.   from  any  previous  activation  of the
program will be lost.  All strings (except constants) will be cleared
to  NULL.   All  compiled-in  arrays which were not PRELOADed will be
cleared to 0, NULL, or PHI, whichever is appropriate.  Then execution
will  begin  with the first statement in the outer block of your main
program.  As each block is entered, its arrays  will  be  cleared  as
they  are  allocated.   Variables  are not cleared.  The program will
exit when it leaves this outer block.
   
   
Starting the Program in "RPG" Mode
   
   
15-3.    SAIL programs may be  started  at  one  of  two  consecutive
locations: at the address contained in the cell JOBSA in the job data
area, or at the address just following that one.  The global variable
RPGSW  is  set to 0 in the former case, -1 in the latter.  Aside from
this, there is no difference between the two methods.  This cell  may
be examined by declaring RPGSW as an EXTERNAL INTEGER.
SAILON NO. 57.2					SAIL   15-3

   
   
Starting the Program with Allocation Modifications
   
   
15-4.    If  the  default  (or REQUIREd) storage allocations for such
things as the push down stacks or string space are insufficient,  the
program  may  be  started  using the REENTER system command.  You may
then answer questions as described in STORAGE ALLOCATION, 14-22.  You
can  find  out  what  the  standard allocations are by typing a space
after the system types ALLOC? at you.  Arrays, Leap  spaces  and  I/O
buffers  are  allocated dynamically, obtaining more storage from the
operating system if necessary.  See Storage Allocation Routines, 17-5
and  following  for  ways  of  cooperating  with SAIL with respect to
storage allocation if you write machine language subroutines.
   
   
ERROR MESSAGES
   
   
15-5.    Error messages have nearly the same format as those from the
compiler (ERROR MESSAGES, 14-19).  They indicate that

  1)  an array subscript has overflowed;

  2)  a case index is out of range;

  3)   a  stack  has  overflowed  while  allocating  space  for  a
      recursive procedure; or

  4)  one of the execution time routines has detected an error.
   
   
15-6.    The "CALLED FROM" address identifies, in the first 3  cases,
the location in the user program where the error occurred ; the "LAST
SAIL CALL AT" address gives the location of the faulty  call  on  the
SAIL routine for type 4 messages.
   
   
15-7.    All  the  replies  to  error  messages  described  in  ERROR
MESSAGES, 14-19 are valid except the "L" option.  If no file name  is
typed  with  the  "E"  option,  the  editor  re-opens  the  last file
mentioned in the EDIT system command (if the appropriate version  SOS
is available.
   
   
15-8.    The  function USERERR may be used to activate the SAIL error
message mechanism.  See Usererr, 12-124 for details.
SAILON NO. 57.2					SAIL   15-8

   
   
DEBUGGING
   
   
15-9.    The code output for SAIL programs is designed to  be  fairly
easy  to understand when examined using the DDT debugging language or
Stanford's  display  oriented  RAID  program.   A  knowledge  of  the
debugger  you  have  chosen  is  required before this section will be
comprehensible.
   
   
Symbols
   
   
15-10.    Only those symbols which have been declared  INTERNAL  (see
Separately  Compiled  Procedures,  16-7)  and  those  declared in the
currently open "program" are available at a given time.  The name  of
a SAIL program as far as DDT or RAID (henceforth DDRAID) is concerned
is the name of the outer block of that program.  If no name is  given
for this block, the name M.  will be the default.
   
   
15-11.    Only  the first six non-blank characters of a block name or
identifier  will  be  used  in  forming  a  DDRAID  symbol.   If  two
identifiers  in the same block have the same first six characters the
program using them will not get confused, but  the  user  might  when
trying to locate these identifiers.
   
   
15-12.    To  obtain  symbols  for  the execution time routines, load
RUNTIM.REL (available from your friendly local SAIL maintainer)  with
your  other files.  The routines will be loaded from this file, which
includes symbols, instead  of  from  the  LIBSAI  library  or  shared
segment,  which  do not.  Your program will be several thousand words
longer when this file is used.
   
   
Blocks
   
   
15-13.    All  block  names  and  identifiers  used   as   variables,
procedures  or labels in a given (main or separate procedure) program
are available for typeout when that program is "open" (NAME$: has been
typed).   To refer to a symbol, type BLOCKNAME&SYMBOL/ (; for RAID).
The block name may be omitted if you have  "opened"  the  block  with
BLOCKNAME$&.   The  symbol  table  is  block-structured  only to the
extent that block names have appeared in  the  source  program.   For
instance, in the program
SAILON NO. 57.2					SAIL   15-13



BEGIN "NAME1"
  INTEGER I,J;
  ...
  BEGIN
    INTEGER I,K;
    ...
  END;
  ...
END "NAME1"

the  symbols  J,  K,  and  both symbols I are considered by DDRAID to
belong in the  same  block.   Therefore  confusion  can  result  with
respect  to  I.   This  approach  was taken to avoid the necessity of
generating meaningless block names for DDRAID when none were given in
the  source  program.   A  compound  statement  will be considered by
DDRAID to be a block if it has a name.
   
   
Sail-Generated Symbols
   
   
15-14.    Some extra symbols are generated by SAIL and will  show  up
	when you are using DDRAID.  They are:

ACS     The accumulators P (system push  down  list  pointer),  SP
        (string  push  down  pointer),  and  TEMP  (commonly  used
        temporary) are given  symbolic  names.   Currently  P='17,
        SP='16, TEMP='14.

OPS     The op codes for the UUOs ERR., ERROR., FIX, FLOAT, PDLOV,
        and  ARERR  (subscript  overflow UUO) are included to make
        these easy to detect in the code.

ARRAYS  For each array  declared  in  the  outer  block  (built-in
        arrays), the fixed address of its first element is given a
        symbolic  name.   This  name  is  constructed   from   the
        characters  of the array name (up to the first 5) followed
        by a period.  For instance, the first element of array CHT
        is  CHT.;  the first element of PDQARR is PDQAR.; The last
        semicolon was really a period.  This dotted symbol  points
        to  the  second  word  of  the first descriptor for String
        Arrays (see STRINGS, 17-15, ARRAY IMPLEMENTATION, 17-35).
SAILON NO. 57.2					SAIL   15-14


BLOCKS  The first word of the first executable statement of  every
        block or compound statement which has been given a name is
        given a label created in the same way as those for  arrays
        above.   This  label  cannot  be  gone  to  in  the source
        program.  It causes no program inefficiency.   This  label
        points  at  the first word of the compound tail -- not the
        first word of code generated  for  the  block  (skips  any
        procedure or array declaration code).

START   The first word of code generated for any given program  is
        given the name "S.".
   
   
Warnings
   
   
Long Names
   
   
15-16.    Since  only  the  first  6  characters of an identifier are
available, it is wise to declare symbols which will  be  examined  by
DDRAID in such a way that these six characters will uniquely identify
them.
SAILON NO. 57.2					SAIL   16-1

                              SECTION 16
                                    
                          PROGRAM STRUCTURE
                                    
   
   
THE SAIL CORE IMAGE (REQUIRED)
   
   
16-1.    The following  things  must  be  present  in  a  core  image
containing SAIL-compiled files:
   
   
Main Program
   
   
16-2.    A SAIL "main program", or an assembly language program which
looks an awful lot like a SAIL main program, must be present  if  any
SAIL-compiled  files  are.   A  SAIL  source  program  which  has  no
entry-specification as its first element satisfies this  requirement.
The  first  statement  executed  after storage allocation is complete
will be its first statement.  There should be no more than  one  main
program per core image.
   
   
16-3.    The salient characteristics of a main program are:

  1)  Its .REL file has a starting address block (the loader  will
      tell  the  time  sharing system to start the program at this
      address).

  2)  Its first task is  to  determine  whether  the  program  was
      started  in  RPG  mode.  If so, the global variable RPGSW is
      set to TRUE; otherwise FALSE.

  3)  Its  next  task  is  to  call  the  storage  allocator  with
      JSR SAILOR.

  4)  It should then proceed with the main control of the program.

  4)  It should execute a POPJ 17,0 when it is all done.

  5)  It may not execute any UUOs  except  SAIL  UUOs  (nor  alter
      permanently  the  UUO  locations  40  and  41) without great
      caution.
SAILON NO. 57.2					SAIL   16-4

   
   
	Storage Allocation, Basic Utilities
   
   
16-4.    There is a set of routines which must always  be  loaded  to
establish   the  operating  environment  for  SAIL  programs.   These
routines allocate storage, set up push down pointers, and  initialize
some  of  SAIL's  internal  tables.   Other routines included in this
package are a String  garbage  collector  (see  STRINGS,  17-15)  and
several basic routines which many others call upon.
   
   
16-5.    These  programs will be loaded automatically from LIBSAI.REL
if the JSR SAILOR instruction, where SAILOR is an  external  request,
is  present  in the main program (this is automatic for SAIL-compiled
main programs).  If the shared segment option is available, they  may
also  be  included by mentioning SYS:SAILOW (or /Y) as the very first
thing in your LOADER input string (done automatically at Stanford.
   
   
Other Execution-Time Routines
   
   
16-6.    All I/O, String-handling, etc.  is done  by  routines  which
understand  about  SAIL.   Programs  requiring  these services should
probably  use  these  routines.   SAIL-compiled  files  automatically
request these blessed routines from LIBSAI.REL, or link to the second
segment versions via RPG at Stanford.
   
   
OPTIONAL ADDITIONS
   
Separately Compiled Procedures
   
   
16-7.    When a program becomes extremely large it becomes useful  to
break  the  program  up  into  several  files  which  can be compiled
separately.  This can be done in SAIL by preparing one file as a main
program,  and  one  or  more  other  files  as programs each of which
contains one or more procedures to be called  by  the  main  program.
Such a file must have the following characteristics:
SAILON NO. 57.2					SAIL   16-7


  1)  An entry specification (see Entry Specifications, 2-1)  must
      be  the  first item in the program (preceding even the BEGIN
      for its outer block).  The list of identifiers will be  used
      to  form  an Entry Block for the loader.  Therefore the file
      may be placed in a user library if desired.  The  format  of
      libraries  is  described  in  [Weiher].   The  identifier(s)
      appearing in the entry list may be  any  valid  identifiers,
      but  usually  they  will  be  the  names  of  the procedures
      contained in the file.  No starting address will  be  issued
      for   a  program  containing  an  Entry  Specification.   No
      checking is done to see if entry identifiers are ever really
      declared in the body of the program.

  2)  Since no starting address is present for this file, entry to
      code within it may only be to the  procedures  it  contains;
      the  statements  in  the  outer  block, if any, can never be
      executed.  All procedures to be called from the main program
      (or  procedures  in  other files) must be qualified with the
      INTERNAL  attribute  when  they  are   declared.    External
      procedure  declarations  with headings identical to those of
      the actual declarations must appear in  all  those  programs
      which call these procedures.

  3)  These internal procedures must be uniquely  identifiable  by
      the  first six characters of their identifiers.  In general,
      any two internal procedure  names  (or  any  other  Internal
      variables  in  the  same core image) with the same first six
      characters will cause incorrect linkages when  the  programs
      are loaded.

  4)  Any variables (simple or array) which appear  in  the  outer
      block  of  a  Separately  Compiled Procedure program will be
      global to the procedures in this program, but not  available
      to   the   main   program  (unless  they  are  connected  by
      Internal/External declarations --  see  below).   Arithmetic
      arrays  in  these  outer blocks will always be zero when the
      program is first loaded, but will never be cleared as others
      are  (see Starting the Program -- Normal Operation, 15-2) --
      String arrays are always cleared.

  5)  Any variable, procedure or label may contain  the  attribute
      INTERNAL or EXTERNAL in its declaration (ITEMS may not).
SAILON NO. 57.2					SAIL   16-8

   
   
16-8.    The   INTERNAL   attribute   does  not  affect  the  storage
assignment of the entity it represents, nor does it have  any  effect
on the behavior of the entity (or the scope of its identifier) in the
file wherein it appears.  However, its address  and  (the  first  six
characters  of)  its  name  are  made  available  to  the  loader for
satisfying External requests.
   
   
16-9.    No space is ever  allocated  for  an  External  declaration.
Instead,  a list of references to each External identifier is made by
the compiler.  This list is passed to the loader along with the first
six  characters  of  the  identifier  name.   When  an  Internal name
matching it is found during loading, its associated address is placed
in  each  of  the  instructions  mentioned  on  the list.  No program
inefficiency at all results from  External/Internal  linkages  (belay
that   --   references   to   External   arrays  are  sometimes  more
inefficient).
   
   
16-10.    The entity finally represented by an External identifier is
only  accessible  within  the  scope  of  the  External  declaration.
Transfers to external labels are always allowed, but if  things  work
correctly when this is done it is only by sheer luck that they do.
   
   
Fortran Procedures
   
   
16-11.    For  a program written in DEC FORTRAN IV to run in the SAIL
environment, the following restrictions must be observed:

  1)  It must be a SUBROUTINE or FUNCTION, not a main program.

  2)  It  must  not  execute  any  FORTRAN  I/O  calls.   The  UUO
      structures of the two languages are not compatible.

  3)  It must be declared as  a  Fortran  Procedure  (see  Fortran
      Procedures, 6-12) in the SAIL program which calls it.
   
The  type  bits  required  in  the  argument  addresses  for  Fortran
arguments are passed correctly to these routines.
   
The SAIL compiler will not produce a  procedure  to  be  called  from
FORTRAN.
SAILON NO. 57.2					SAIL   16-12

   
   
Assembly Language Procedures
   
   
16-12.    The   implementation   section   contains   the   following
paragraphs to aid  in  writing  assembly  language  procedures:  User
Table,  17-1,  STRINGS,  17-15,  ARRAY IMPLEMENTATION, 17-35, Storage
Allocation Routines, 17-5, and PROCEDURE IMPLEMENTATION,  17-48.   In
addition, the following rules should be observed:

  1)  The ENTRY, INTERNAL, and EXTERNAL pseudo-ops should be  used
      to   obtain   linkages  for  procedure  names  and  "global"
      identifiers (remember that only six characters are used  for
      these linkage names.

  2)  Accumulators P  (currently  '17)  and  SP  ('16)  should  be
      preserved over function calls.  P may be used as a push-down
      pointer for arithmetic values and return addresses.   SP  is
      the  string  stack  pointer.  String results are returned on
      this stack.  Arithmetic results are returned in  AC  1  (see
      PROCEDURE IMPLEMENTATION, 17-48).

  3)  The UUO locations 40 and 41 should be preserved.

  4)  JOBFF must be set by the  user  to  some  free  buffer  area
      before   OUTBUF  or  INBUF  UUOs  are  executed.   JOBFF  is
      periodically set by SAIL routines to an invalid address.

  5)  The CORE UUO may be used to increase memory size, but  never
      to  decrease  it.   Never attempt to use directly any of the
      memory space currently assigned  to  the  job  (except  that
      explicitly  provided  in  the  routine).  Release all memory
      obtained in this way before returning to SAIL routines.  See
      Storage   Allocation  Routines,  17-5  for  instructions  on
      obtaining core from  the  SAIL  memory  allocators  (a  much
      safer, and sometimes faster way).
   
   
Others
   
   
16-13.    There  are  no  other  known  processors which will produce
SAIL-compatible programs.  In particular, the LISP 1.6 system, by its
very   nature,   contains  storage  allocation  conflicts  which  are
difficult to resolve.  If a great need for this kind of compatibility
develops it can be provided.
SAILON NO. 57.2					SAIL   17-1

                              SECTION 17
                                    
                      IMPLEMENTATION INFORMATION
                                    
   
	   
STORAGE LAYOUT
   
User Table
   
   
17-1.    All  working  storage areas for a SAIL-generated program and
its execution-time routines are dynamically allocated  --  some  just
once when the program is first started, some as more space is needed.
   
   
17-2.    The  first  area  allocated  is a several hundred word table
which contains information about  the  remaining  storage  areas  and
global  variables for the execution-time routines.  A single internal
variable, GOGTAB, will always contain a pointer to this  table.   The
execution-time  routines  make  all  accesses to storage through this
table or through user-supplied addresses.  They  would  therefore  be
totally  re-entrant  if the GOGTAB variable were allowed to vary over
several users.
   
   
17-3.    A FAIL source file containing symbolic indices for the  user
table,  as  well  as  some  useful  MACROs,  OPDEFs,  and accumulator
definitions is available to provide accessability to this  table  for
assembly  language routines.  This file may be concatenated to a FAIL
program before assembly.  Users can read and modify these entries  in
SAIL via the procedure Usercon, 12-120.
   
   
17-4.    Most  execution-time  routines load the address contained in
GOGTAB into the accumulator USER (currently '15) in  order  to  index
the  user  table.   Thus in what follows, symbolic index XX into this
table will be listed as XX(USER).
   
   
Storage Allocation Routines
   
   
17-5.    SAIL makes all requests for  storage  through  the  routines
CORGET,  CORREL,  CORINC,  CORBIG,  and  CANINC.   These routines are
described in the following paragraphs.  The AC's  THIS  and  SIZ  are
currently set to 2 and 3, respectively.  All core routines are called
with PUSHJ 17,routine.
SAILON NO. 57.2					SAIL   17-5

   
   
Corget
   
   
17-6.    Corget is called with the desired size of a block of storage
in  register  SIZ.   It returns the address of the new block in THIS.
No other accumulators are altered.  Normally the  function  skips  on
return.   It does not skip if insufficient core is available to grant
the request.  The address returned is that of  the  first  free  data
word (DATA below).
   
   
17-7.    A SAIL core block has the following form:


HEAD:	LAST,,NEXT	;when not in use (free list links)
	SIZE		;END-HEAD+1, negated when block is in use
DATA:	BLOCK	SIZE-3	;available to user -- sometimes a few more
			;   words than requested will be contained
			;   in the block
END:	USEBIT,,HEAD	;USEBIT is 400000 if block is in use; else 0

The  first  time  CORGET is called, GOGTAB is 0.  CORGET notices this
and performs the following special actions:

  1)  Prepares to allocate  storage  just  past  the  program  and
      symbols (left half of JOBSA contains the relevant address).

  2)  Allocates the user table; puts pointer in GOGTAB.

  3)  Forms remaining free storage from the end of the user  table
      to  contents  (JOBREL)  [C(JOBREL)]  into a single free SAIL
      block.  Puts HEAD in LO(USER), FRE(USER).  Puts C(JOBREL)+1
      in TOP(USER).

  4)  Performs the requested CORGET operation.
   
   
17-8.    FRE(USER) is the header  of  a  linked  free  storage  list,
Blocks  are  obtained from this list and the list is updated.  CORREL
releases blocks onto this list.  If  no  currently  free  block  will
satisfy  a  CORGET request, the CORE UUO is executed to get more from
the time sharing system.
SAILON NO. 57.2					SAIL   17-9

   
   
17-9.    Users are free to use the CORGET function if  they  will  be
careful  of  the  two  header  words  and  the  single  trailer  word
associated with each block.  Release these blocks as soon as possible
to prevent undue checker-boarding of free storage.
   
   
Correl
   
   
17-10.    Correl   is   called  with  the  address  obtained  in  the
corresponding Corget call (the DATA address) in register  THIS.   The
block  is  returned  to  the free storage list.  If either of the two
neighboring blocks is already free,  the  adjacent  free  blocks  are
merged  with  the  one  being  released to form a bigger one.  If the
block being released is uppermost in core, and if  it  occupies  more
than  about  2K, the core size of the program is contracted using the
CORE UUO.  About 2K of free storage is left in this case.  No ACs are
altered by CORREL.
   
   
Corinc
   
   
17-11.    Corinc  is  called with the DATA address of a SAIL block in
THIS and a desired increment in  SIZ.   If  there  is  a  free  block
directly above the THIS block with at least SIZ free words, or if the
THIS block occupies the highest addresses of any block  in  use,  the
request  is  granted,  the  block  is  extended  by SIZ words and the
function executes a skip-return.  Otherwise no  skip  occurs  and  no
action is taken.  No ACs will be altered.
   
   
Caninc
   
   
17-12.    Caninc  performs  the  same tests as Corinc and skips under
the same conditions.  It also uses the same calling sequence.  If  it
does  not  skip,  it  returns  with SIZ altered to show the number of
words by which the DATA block can  be  increased.   It  is  0  if  no
increase  is  possible.   This  function  never  affects current core
allocation.
SAILON NO. 57.2					SAIL   17-13

   
   
Corbig
   
   
17-13.    Corbig returns the size of the largest available free block
in SIZ.
   
   
17-14.    These  functions  are  not available to SAIL programs since
core can be obtained by array declarations (which in turn  use  these
functions).
   
   
	STRINGS
   
String Descriptors
   
   
17-15.    A  SAIL  String  has two distinct parts: the descriptor and
the text.  The descriptor is unique and has the following format:


WORD1:	STRINGNO,,LENGTH
WORD2:	BYTP


  1)  STRINGNO.  This entry is 0 if the String is a constant  (the
      descriptor  will  not be altered, and the String text is not
      in  String  space,  is  therefore  not  subject  to  garbage
      collection).   Every  time  a  String  is  created  via  the
	      concatenation   operator,   or   Input   function,   or   an
      Integer-String  type conversion, it receives a new STRINGNO.
      Each new String receives a number one greater than the last,
      starting  at 1 when the program is initialized.  All strings
      formed as substrings of  a  given  String  have  the  String
      number of the original (major) string.  These numbers aid in
      increasing String garbage collection efficiency.

  2)  LENGTH.  This number is zero for any null String;  otherwise
      it is the number of text characters.

  3)  BYTP.  If count is 0, this byte pointer is never checked (it
      need  not  even be a valid byte pointer.  Otherwise, an ILDB
      machine instruction pointed at the BYTP word  will  retrieve
      the  first  text  character  of  the String.  The text for a
      String may begin at any point in a word.  The characters are
      stored as LENGTH contiguous characters.
SAILON NO. 57.2					SAIL   17-16

   
   
17-16.    A SAIL String variable contains the two word descriptor for
that variable.  The identifier naming it  points  to  WORD1  of  that
descriptor.   If a String is declared INTERNAL, a symbol is formed to
reference WORD2 by taking all characters from the original  name  (up
to  5)  and  concatenating  a  "."  (OUTSTRING's second word would be
labeled OUTST.).
   
   
17-17.    When a String is passed by reference to  a  procedure,  the
address   of   WORD2   is   placed  in  the  P-stack  (see  PROCEDURE
IMPLEMENTATION, 17-48).  For VALUE Strings both descriptor words  are
pushed onto the SP stack.
   
   
17-18.    A  String  array  is  a block of 2-word String descriptors.
The array descriptor (see ARRAY IMPLEMENTATION, 17-35) points at  the
second word of the first descriptor in the array.
   
   
17-19.    Information  is  generated  by  the  compiler  to allow the
locations of all non-constant strings to be  found  for  purposes  of
garbage-collection  and initialization (see PROCEDURE IMPLEMENTATION,
17-48).  All String variables and arrays are cleared to NULL whenever
a SAIL program is started.
   
   
String Operations
   
   
17-20.    The  five  basic String operations are concatenation (CAT),
substrings (SUBSTR),  String-integer  (done  inline),  Integer-string
(PUTCH),  and one-character truncation (LOP, compiled inline).  Other
functions producing  or  operating  upon  strings  are  described  in
Execution Routines, 12-1.
SAILON NO. 57.2					SAIL   17-21

   
   
Cat
   
   
17-21.    CAT forms a new String from two other strings (constants or
otherwise).  The calling sequence is:


	PUSH	SP,WORD11	;WORD1, FIRST ARGUMENT
	PUSH	SP,WORD12	;WORD2, FIRST ARGUMENT
	PUSH	SP,WORD21	;ETC.
	PUSH	SP,WORD22
	PUSHJ	P,CAT

The result is found as a new two-word descriptor on  top  of  the  SP
(currently AC '16) stack.  If either argument is the null String, the
result is the other argument.  If the  first  argument  occupies  the
space  directly  preceding  the first free character in String space,
only the second argument is copied.  Otherwise,  both  arguments  are
copied  (in  order) into free space to form the result.  A new String
number is created for this result.  The LENGTH field is  the  sum  of
the LENGTHs of the two arguments.
   
   
Substr
   
   
17-22.    SUBSTR  returns  a  descriptor  representing  a part of its
input argument.  SUBSTR is really two routines, called as follows:


		 PUSH  SP,WORD1
		 PUSH  SP,WORD2

	   SUBST	    SUBSR
	PUSH P,LASDX	 PUSH   P,NUMCHR
	PUSH P,FIRSDX    PUSH   P,FIRSDX

		 PUSHJ P,SUBS{T/R~

LASDX is the number of the last character to  be  included  (starting
with 1).  FIRSDX is the number of the first character to be included.
NUMCHR is the number of characters to be included.
SAILON NO. 57.2					SAIL   17-23

   
   
17-23.    The result is always a two-word descriptor in the SP  stack
describing the substring.
   
SUBST is used for the construct ST[X for Y].
SUBSR is used for ST[X to Y].
   
   
17-24.    An error code is returned if the request can not be totally
satisfied (see Substrings, 9-42).
   
   
17-25.    The String number of the output is the same as  the  String
number of the input.
   
   
String to Integer
   
   
17-26.    This   returns   the   first   string   character  (or  0),
right-justified, in an accumulator.  It  is  invoked  when  something
like I_STR is executed (see String-Arithmetic Conversions, 9-27).  It
is compiled as


	HRRZ 	AC,WORD1
	JUMPE	AC,.+3
	MOVE	AC,WORD2
	ILDB	AC,AC

   
   
Putch
   
   
17-27.    Call with


	PUSH	P,VALUE
	PUSHJ	P,PUTCH

The result is a String descriptor with count of 1 on top  of  the  SP
stack.   The  P  stack is adjusted to remove the parameter and return
address.  The String number is new.  The low order 7  bits  of  VALUE
form the single character in the string.
SAILON NO. 57.2					SAIL   17-28

   
	   
Lop Details
   
   
17-28.    LOP(ST) is compiled inline as:


	HRRZ	AC,WORD1
	JUMPE	AC,.+3
	ILDB	AC,WORD2	;return 1st char, update bp
	SOS	WORD1		;decrement character count

   
   
String Space
   
   
17-29.    The  normal  or  user-specified  (see  STORAGE  ALLOCATION,
14-22) number of words required for  strings  is  used  to  obtain  a
single  SAIL  block  (see Storage Allocation Routines, 17-5) when the
program is started.  The limits of this area are placed  in  ST(USER)
and STTOP(USER).  Other parameters are set up as described below.
   
   
17-30.    String text characters are placed contiguously in thes area
as strings are created.   When  not  enough  storage  remains  for  a
contemplated  String,  the  garbage  collector  (see  String  Garbage
Collection, 17-32) is  called  to  obtain  more  (by  compacting  the
current space, if possible).  If this fails, the program will restart
and request more reasonable allocation.
SAILON NO. 57.2					SAIL   17-31

   
   
Parameters Used by String Operations
   
   
17-31.    

ST(USER)         Bottom (low address) of String space

STTOP(USER)      (Top+1) of String space

TOPBYTE(USER)    Byte pointer such that  IDPB  TOPBYTE(USER)  will
                 store into next character

REMCHR(USER)     Negated number of free characters remaining

TOPSTR(USER)     WORD1 for last created  String  (doesn't  include
                 substring  operations).   CAT  uses  this word to
                 decide whether its first  argument  needs  to  be
                 moved (see Cat, 17-21).
   
   
String Garbage Collection
   
   
17-32.    The  String  garbage  collector (STRNGC) is called whenever
the (estimated or actual) size  of  a  soon-to-be-created  String  is
larger  than  -REMCHR(USER).   By  various devious means it finds all
active (non-constant) String descriptors, sorting them  in  ascending
address   sequence  by  using  the  byte  pointers,  associating  all
substrings of a given active String (major String) ...ouch.  Then  it
compacts  String  space  by  moving the text for all major strings to
lower memory locations occupied by text no longer reachable from  any
descriptor.   Finally  it  updates  all  String  descriptors  and the
parameters described above.  If there is still not  enough  room,  it
prints  a  frustrated  message  and  restarts  the  program  with the
allocation sequence normally obtained by typing  the  REEnter  system
command (see STORAGE ALLOCATION, 14-22).
SAILON NO. 57.2					SAIL   17-33

   
   
String-Oriented Machine Language Routines
   
   
17-33.    If  you  must  write  a  routine which operates on strings,
please observe the following conventions:

  1)    See  PROCEDURE  IMPLEMENTATION,  17-48   for   conventions
       concerning input parameters and value returning.

  2)   If you merely need to read a String, no particular care  is
       required (don't change the descriptor of a reference String
       parameter by performing careless ILDBs).
SAILON NO. 57.2					SAIL   17-34

   
   
17-34.    If you  need  to  create  a  new  String,  these  are  also
applicable:

  4)   Estimate the number  of  characters  if  it  is  not  known
       exactly.    This  estimate  must  be  an  upper  bound;  an
       unrealistically  large  estimate  will  cause  the  garbage
       collector  to  work  more  often than necessary.  Place the
       estimate in register A (1).

  4)     Execute   the   following   code   before    doing    any
	       String-munching:


		MOVE	USER,GOGTAB	;ESTABLISH ADDRESSABILITY
		ADDM	A,REMCHR(USER)	;UPDATE REMAINING COUNT
		SKIPLE	REMCHR(USER)	;TEST IMPENDING OVERFLOW
		PUSHJ	P,STRNGC	;COLLECT, WILL NOT RETURN IF
					; NEW REMCHR+C(A)>0.


  5)   TOPBYTE(USER) should be your WORD2 result.  Save it now.

  6)   Do repeated IDPBs to TOPBYTE(USER) to  store  your  string.
       This  keeps  TOPBYTE  accurate.   Count  characters if your
       estimate was only an estimate.

  7)   Create WORD1 of your result.  The left  half  is  the  left
       half of TOPSTR(USER) incremented by one.  The right half is
       the length of your new string.  This word is not only WORD1
       of your result, but also should be placed in TOPSTR(USER).

  8)   Subtract (estimate - actual length)  from  REMCHR(USER)  to
       keep  it  honest.  This should make REMCHR if anything more
       negative.

  9)   Return String results on the top of the  SP  stack.   If  a
       result  is  to  go  in a reference parameter (see PROCEDURE
       IMPLEMENTATION, 17-48) remember that the address  you  have
       is that of the WORD2 (byte pointer) word of the descriptor.
SAILON NO. 57.2					SAIL   17-35

   
   
ARRAY IMPLEMENTATION
   
Form
   
   
17-35.    Let  STRINGAR  be  1  (TRUE)  if the array in question is a
String array, 0 (FALSE) otherwise.  Then a SAIL array of n dimensions
has the following format:


HEAD:	DATAWD		; MEANS "POINTS AT"
	HEAD-END-1
ARRHED:	BASEWORD	;SEE BELOW
		LOWERBD(n)
	UPPERBD(n)
	MULT(n)
	...
	LOWERBD(1)
	UPPERBD(1)
	MULT(1)
	NUMDIMS,,TOTALSIZE
DATAWD:	BLOCK	TOTALSIZE
	<sometimes a few extra words>
END:	400000,,HEAD

   
   
Explanation
   
   
17-36.    

HEAD         The first two words of each array, and the  last,  are
             control  words  for  the  Storage Allocation Routines,
             17-5.  These words are always present  for  an  array.
             The array access code does not refer to them.

ARRHED       Each array is preceded by a  block  of  3*n+2  control
             words.  The BASEWORD entry is explained later.

NUMDIMS     This is the dimensionality of the array.  If STRINGAR,
             this value is negated before storage in the left half.

TOTALSIZE   The total number of  accessible  elements  (double  if
             STRINGAR) in the array.
SAILON NO. 57.2					SAIL   17-36


BOUNDS       The lower bound and upper bound for each dimension are
             stored  in  this  table,  the  left-hand  index values
             occupying the higher addresses (closest to  the  array
             data).   If  they  are  constants,  the  compiler will
             remember them  too  and  try  for  better  code  (i.e.
             immediate operands).

MULT         This number, for dimension m, is the  product  of  the
             total  number of elements of dimensions m+1 through n.
             MULT for the last dimension is always 1.

BASEWORD    This is
                
             DATAWD - the sum of (STRINGAR+1)*LOWERBD(m)*MULT(m)
                
             for all m from 1 to n.  The  formula  for  calculating
             the address of A[I,J,K] is:


	address(A[I,J,K]) = 
	    address(DATAWD) + 
	      (I-LOWERBD(1))*MULT(1) + 
	      (J-LOWERBD(2))*MULT(2) + 
	      (K-LOWERBD(3))

             This expands to


	address(A[I,J,K]) =
	    address(DATAWD) +
	     I*MULT(1) + J*MULT(2) + K
	       -(LOWERBD(1)*MULT(1) + LOWERBD(2)*MULT(2) + LOWERBD(3)

             which is


	    BASEWORD + I*MULT(1) + J*MULT(2) + K.

             By  pre-calculating  the  effects of the lower bounds,
             several  instructions  are  saved   for   each   array
             reference.
SAILON NO. 57.2					SAIL   17-37

   
   
Array Allocation
   
Dynamic Arrays
   
   
17-37.    When an array is declared in any block other than the outer
one, the compiler generates code to  call  the  function  ARMAK  with
parameters  describing  the  array.   This  routine calls CORGET (see
Storage Allocation Routines, 17-5) to  obtain  enough  storage,  then
sets  up  the  control table and clears the data area to zeroes.  The
ARRHED address is saved in an array push-down list whose  pointer  is
ARRPDP(USER).  The address of DATAWD+1 is returned for String arrays;
the address of DATAWD is  returned  for  all  others.   The  compiler
generates  code  to  store  this address in the core cell bearing the
name of the array variable.
   
   
17-38.    When  all  declarations  for  a  block   containing   array
declarations have been processed, the compiler issues a call to ARMRK
which marks the array push-down stack (with a  -1,  as  a  matter  of
fact).   On  block exit (or when a GO TO transfers out of the block),
the routine ARREL is called to remove this mark and return all arrays
back to the previous mark to the SAIL free storage list.
   
   
17-39.    The String garbage collector uses the array push-down stack
to find dynamic String arrays which need attention.
   
   
Built-In Arrays
   
   
17-40.    Outer-block arrays  have  constant  bounds.   The  compiler
simply emits a Jrst instruction, then compiles the control table into
the block head of the object program.  It leaves room for the  array,
then  issues  the END word.  The Jrst instruction then finds its home
in some code to clear the array to zeroes.
   
   
17-41.    The core location bearing the name of  the  array  has  the
address  of  DATAWD  (DATAWD+1  if  STRINGAR) compiled into it.  This
address is given the dotted name described in DEBUGGING, 15-9.
SAILON NO. 57.2					SAIL   17-42

   
   
17-42.    For built-in  String  arrays,  a  String  link  block  (see
PROCEDURE  IMPLEMENTATION,  17-48)  is  issued  following  the  space
allocated for the array.  The String garbage  collector  (see  String
Garbage  Collection,  17-32)  gains access to this array through this
static link.
   
   
17-43.    It can be seen from all this that all dynamic and  built-in
arrays  are  cleared  when  the blocks in which they are declared are
entered.  Since the outer block of a  separately  compiled  procedure
file (see Separately Compiled Procedures, 16-7) is never entered, its
built-in arrays, although available for use, are never cleared.   The
loader clears them once as it loads.
   
   
Array Access Code
   
   
17-44.    In  the  worst  case (no fixed bounds, bounds checking, not
built-in) the statement K_A[I,J] will be compiled as:


	MOVE	1,A		;FIRST DATA WORD
	MOVE	2,I		;FIRST SUBSCRIPT
	CAML	2,-4(1)		;IF <LOWER BOUND OR
	CAMLE	2,-3(1)		; >UPPER BOUND THEN
	ARERR	1,[ASCIZ /A/]	;  ERROR IN INDEX 1
	IMUL	2,-2(1)		;I*MULT(1)
	MOVE	3,J		;CHECK DIMENSION 2
	CAML	3,-7(1)
	CAMLE	3,-6(1)
	ARERR	2,[ASCIZ /A/]
	ADD	3,2		;NO MULT FOR LAST, COLLECT OFFSET
	ADD	3,-10(1)	;  + BASEWORD
	MOVE	4,(3)		;DATA FROM A[I,J]
	MOVEM	4,K

SAILON NO. 57.2					SAIL   17-45

   
   
17-45.    If A is, however, declared  in  the  outer  block  as  SAFE
INTEGER ARRAY A[1:10,1:5], the code for A[I,J] is


	MOVE	1,I
	IMULI	1,5		;I*MULT(1)
	ADD	1,J		;COLLECT OFFSET
	MOVE	2,A.-5(1)	;CONSTANT PART OF ADDRESS COMPILED IN
	MOVEM	2,K

   
   
17-46.    A[I,3] would be compiled as


	MOVE	1,I
	IMULI	1,5
	MOVE	2,A.-2(1)
	MOVEM	2,K

and J_A[2,3] would be

	MOVE	3,A.+7
	...
	MOVEM	3,J
   
   
17-47.    Various  configurations  of array declarations and accesses
result in code which ranges between these degrees of efficiency.
   
   
PROCEDURE IMPLEMENTATION
   
   
17-48.    
   
   
Procedure Body
   
   
17-49.    To describe the main characteristics of SAIL procedures,  a
set  of sample procedures are displayed here along with the code they
produce.  Some of the entries are discussed  in  more  detail  below.
The  notation  [n]  is  placed  in  the comment field of the assembly
instruction to refer to these discussions:
SAILON NO. 57.2					SAIL   17-49



INTEGER PROCEDURE P1(INTEGER I,J; STRING A);
	P1:	AOS	P1PAC	;[1] INCREMENT PROC ACTIVE COUNTER

BEGIN
 INTEGER Q; STRING A,B;
 INTEGER ARRAY X[0:5];
		PUSH	P,[0]
		PUSH	P,[5]
		PUSH	P,[1]
		PUSHJ	P,ARMAK	;ALLOCATE AND CLEAR
		MOVEM	1,X	;STORE POINTER
		PUSHJ	P,ARMRK	;END OF ARRAYS FOR BLOCK


 <code for procedure>

 RETURN(Q);
		MOVE	1,Q	;[2] RESULT IN 1
		PUSHJ	P,ARREL	;[3] RELEASE ARRAYS FOR BLOCK
		JRST	P1EXIT	;EXIT PROCEDURE

 <more code for procedure>


END "P1"
		PUSHJ	P,ARREL	;IF FALLS THROUGH, RELEASE ARRAYS
	P1EXIT:	SOS	P1PAC	;ONE TIME LESS ACTIVE
		SUB	SP,[XWD 2,2]	;REMOVE STRING PARAMETER
		SUB	P,[XWD 3,3]	;[4] NON-STRINGS, RETURN ADDR
		JRST	@3(P)		;RETURN
	Q:	0		;ROOM FOR VARIABLE
	X:	0		;ARRAY POINTER
	TEMP07:	0		;[5] TEMPORARY STORAGE
	A:	BLOCK	2	;TWO WORDS FOR EACH STRING
	B:	BLOCK	2
	P1PAC:	0		;[6] PROCEDURE-ACTIVE COUNT
		XWD	2,A	;STRING COUNT,FIRST
	LNKWD:	0		;[7] LINK PASSES THROUGH HERE
		LINK	1,LNKWD	;[7] CAUSES LOADER LINKAGE




PROCEDURE P2(INTEGER I,J; STRING A);
BEGIN
 INTEGER ARRAY X[0:10];
 ...
SAILON NO. 57.2					SAIL   17-49

 BEGIN
  INTEGER ARRAY Y[0:10];
  ...
   RETURN;
		PUSHJ	P,ARREL		;RELEASE ARRAYS FOR ALL
		PUSHJ	P,ARREL		; BLOCKS IN PROCEDURE
		JRST	P2EXIT

  ...
 END;
END"P2";



STRING PROCEDURE P3(STRING A,B);
BEGIN STRING C;
 ...
 RETURN(C);
		SUB	SP,[XWD 4,4]	;REMOVE PARAMS
		PUSH	SP,C
		PUSH	SP,C+1		;RETURN STRING RESULT
		JRST	P3EXIT

 RETURN(B);
		SUB	SP,[XWD 4,4]
		PUSH	SP,3(SP)	;FIRST WORD OF B
		PUSH	SP,3(SP)	;SECOND WORD OF B
		JRST	P3EXIT		;GO RETURN

 RETURN(C&"STR"); COMMENT ASSUME CAT ALREADY DONE;
		SUB	SP,[XWD 6,6]	;REMOVE PARAMS, TEMP RESLT
		PUSH	SP,5(SP)	;TEMP RESLT
		PUSH	SP,5(SP)	;2D WORD
		JRST	P3EXIT

 ...
END "P3";
	P3EXIT:	SOS	P3PAC
		SUB	SP,[XWD 4,4] ;NOT THIS TIME, BUT WOULD
		PUSH	SP,[0]	     ;BE INCLUDED IF NO RETURNS 
		PUSH	SP,[0]	     ;DONE ABOVE (RETURN NULL STRING)


RECURSIVE INTEGER PROCEDURE P4(STRING A,B; INTEGER I,J);
	P4TEXT:	AOS	P4PAC

BEGIN
 STRING C,D; INTEGER K,L;
 ...
SAILON NO. 57.2					SAIL   17-49

END "P4";
	P4EXIT:	SOS	P4PAC
		SUB	SP,[XWD =8,=8] ;[8]TAKE OFF LOCALS,PARAMS
		HRRI	TEMP,C		;[8]
		HRLI	TEMP,5(SP)	;[8]
		BLT	TEMP,D+1	;[8] RESTORE LOCAL STRINGS

		SUB	P,[XWD 6,6]	;[8] SAME FOR P-SIDE
		HRRI	TEMP,K		; (ALSO RETURN ADDR REMOVED)
		HRLI	TEMP,4(P)
		BLT	TEMP,TEMP03	;MUST EVEN SAVE TEMPS
		JRST	@3(P)		;RETURN

	P4:	ADD	P,[XWD 3,3]	;LEAVE ROOM FOR LOCALS 
		SKIPL	P		;CHECK PUSH-DOWN OVERFLOW
		PDLOV	P,		;[9]UUO TO SIMULATE PDL OV
		HRRI	TEMP,-2(P)	;[9]SAVE LOCALS
		HRLI	TEMP,TEMP03	; AND TEMPS
		BLT	TEMP,(P)
		<similarly for SP (string stack)>
		JRST	P4TEXT		;GO DO PROCEDURE
		<variables and such>



RECURSIVE STRING PROCEDURE P5(STRING A,B);
BEGIN
 STRING C,D;
 ...
 RETURN(C);
		PUSHJ	P,P5POP	;[10]REMOVE STRING LOCALS,PARAMS
		PUSH	SP,C	;STRING RESULT
		PUSH	SP,C+1
		PUSHJ	P,ARREL	;ENOUGH TIMES IF ANY ARRAYS
		JRST	P5EXIT

 RETURN(B);
		PUSHJ	P,P5POP
		PUSH	SP,3(SP)
		PUSH	SP,3(SP)	;RETURN PARAMETER
		JRST	P5EXIT

 RETURN(A&"STR");
		POP	SP,1	;[11]ASSUME CAT ALREADY DONE
		POP	SP,0
		PUSHJ	P,P5POP
		PUSH	SP,0	;[11]RETURN VALUE
		PUSH	SP,1
		JRST	P5EXIT
SAILON NO. 57.2					SAIL   17-49

 
 ...
END "P5";
	P5EXIT:	SUB	P,[XWD 2,2] ;OR WHATEVER, SEE ABOVE
		...		     ;RESTORE LOCALS, ADJUST
		JRST	@3(P)	    ;RETURN

	P5:	<as above>
		...

	P5POP:	SUB	SP,[XWD =8,=8]	;[10] REMOVE STRING LOCALS,PARAMS
		HRRI	TEMP,C
		HRLI	TEMP,5(SP)
		BLT	TEMP,D+1
		POPJ	P,		;RETURN

The main program has the following format:


S.:	SKIPA		;NOT STARTED IN RPG MODE
	SETOM	RPGSW	;STARTED IN RPG MODE -- RPGSW A GLOBAL
	JSR	SAILOR	;INIT -- RETURNS BY PUSHJ P,@SAILOR

  Comment  The main program looks like a non-recursive procedure
    from here on, except for built-in arrays  

	POPJ	P,	;RETURN TO INIT, WHO EXITS
	<global variables, linkages>
	<non-String constants>
	XWD	0,,=8	;TYPICAL STRING CONSTANT
	POINT	7,.+1
	ASCII	/CONSTANT/
	<more String constants>

	END	S.	;STARTING ADDRESS FOR MAIN PROGRAM

SAILON NO. 57.2					SAIL   17-50

   
   
Discussion
   
   
17-50.    

[1]   There is for each procedure a word (PAC  for  Procedure  Active
      Count)  which is incremented on procedure entry and decremented
      on exit.  At one time, the String garbage collector  used  this
      word.   It  may  again some time in the future.  At present the
      counter is useful for determining the depth of recursion  (from
      DDT).

[2]   Non-String  procedures  return  their  results  in  1;  Fortran
      returns  things  in  0;  String  results are returned on the SP
      stack.

[3]   An ARREL call is issued  for  each  block  (containing  arrays)
      which  must  be  left  in  order to exit.  All arrays for these
      blocks are released at this  time.   The  same  sort  of  thing
      happens when a Go To statement leaves one or more blocks.

[4]   Since the return address is on the top  of  the  P-stack,  with
      parameters  buried  beneath,  a  subtract  and an indirect jump
      replace the POPJ.  Procedures always adjust  the  stack  before
      returning.

[5]    String  temporaries  are  kept  in  the  SP   stack.    Others
      occasionally  occupy  core  locations.  These are grouped with
      the non-String variables to make saving and restoring  easy  in
      recursive procedures.

[6]   This is the Procedure Active  Count  word  (see  [1]).   It  is
      placed  in  a  fixed  location  with respect to the String-link
      block (below).  The  String  garbage  collector  could,  if  it
      wished, see this count.

[7]   A linked list, with its head in a reserved  cell  in  the  user
      table (see User Table, 17-1) gives the String garbage collector
      access to all String variables declared for each procedure; and
      to all built-in String arrays.  Each entry on the list contains
      three words: a PAC counter (currently ignored), a  word  giving
      the  location  and  extent  of  the  String  descriptors  being
      described, and the pointer (LNKWD) to  the  next  entry.   A  0
      entry  ends  the  list.   The LINK pseudo-op (or the equivalent
      code issued by SAIL) instructs the loader to create this  list.
      The  LINKEND  pseudo-op  is  issued  in  the  SAILOR routine to
      collect the address of the first list element.   This  is  then
SAILON NO. 57.2					SAIL   17-50

      transferred  to  the  user  table.   See  [Weiher]  for details
      concerning the LINK block type.

[8]   When a recursive procedure is called, all values for  variables
      declared  in blocks internal to this procedure are saved in the
      appropriate stack.  These are added "on top of" the  parameters
      and  return  address  for the procedure.  At procedure exit the
      stack pointer is adjusted to point below the  first  parameter.
      Then  the proper BLT word is set up to restore all these locals
      from the stack.  After the BLT is executed, that stack is ready
      for procedure exit.

[9]   Since SAIL is a one-pass compiler, it does not  know  how  many
      locals a procedure has until all blocks for that procedure have
      been  processed.   Therefore  the  entry  code  for   recursive
      procedures  is  added last, followed by a jump to the procedure
      text.

[10]  When a String procedure returns a value, the String  parameters
      and  locals  must  be  removed  from the stack before the value
      (result) can be pushed on.  Since the total  number  of  String
      locals  is  not  yet  known,  a routine like P5POP is called to
      remove the unwanted values first.  Recursive String  procedures
      must  contain  Return  Statements (see Return Statement, 5-20);
      otherwise improper code will result.

[11]  Once P5POP or its equivalent has been  executed,  the  previous
      top of stack location is not known; the temp value is therefore
      removed first and restored after the call.
   
   
Procedure Calling Sequences
   
   
17-51.    Again a case study is presented.  A procedure with  several
internal procedures is presented to demonstrate the ridiculous number
of possibilities.  Only the relevant code is  described.   Accumulator
numbers  in  the  code  below  are  only examples -- other values are
possible.  This list is not complete;  to  describe  all  cases  here
would  take  more space than a copy of the code in SAIL which handles
them.   Item  and  Set  parameters  behave  like  Integer  and   Real
parameters as far as argument passing is concerned:
SAILON NO. 57.2					SAIL   17-51



PROCEDURE SUPER(REFERENCE STRING RPSTR;
		INTEGER PINT; REFERENCE INTEGER RPINT;
		REAL PROCEDURE PPAR;
		STRING PSTR1,PSTR2);
BEGIN
 INTEGER INT1,INT2; STRING STR1,STR2; REAL REL;
 SAFE INTEGER  ARRAY ARR[2:10]; SAFE STRING ARRAY SARR[2:10];
 INTEGER PROCEDURE INTP(INTEGER I,J);...;
 PROCEDURE RINTP(REFERENCE INTEGER I);...;
 PROCEDURE STRP(STRING A,B);...;
 PROCEDURE RSTRP(REFERENCE STRING A);...;
 PROCEDURE PROCP(PROCEDURE PARAM);...;
 PROCEDURE ARRP(STRING ARRAY X);...;


 INT1_PINT^2 + RPINT^2 - 3;
		MOVE	1,-3(P)		;RELATIVE LOC OF PINT
		IMUL	1,1
		MOVE	2,@-2(P)	;RPINT's ADDRESS IS IN STACK
		IMUL	2,2
		ADD	2,1		;SUM
		SUBI	2,3		;RESULT LEFT IN 2

REL_INTP(INT1,PINT);
		PUSH	P,2		;INT1 STILL IN 2
		PUSH	P,-4(P)		;[1]ADJUST FOR PREV PUSH
		MOVEM	2,INT2		;[2]STORE CURRENT ACS BEFORE CALL
		PUSHJ	P,INTP		;CALL PROCEDURE
		FLOAT	1,1		;CONVERT TO REAL -- REL IS IN 1

RINTP(INT1);
		PUSH	P,[INT1]	;ADDRESS OF INT1
		MOVEM	1,REL		;PREVIOUS RESULT
		PUSHJ	P,RINTP

RINTP(PINT);
		MOVEI	3,-3(P)		;ADDRESS OF PINT
		PUSH	P,3
		PUSHJ	P,RINTP

RINTP(RPINT);
		PUSH	P,-2(P) 	;PASS ON ADDR OF RPINT
		PUSHJ	P,RINTP

INT2_INTP(INT1,ARR[PINT]);
		PUSH	P,INT1
		MOVE	4,-4(P)		;PINT
SAILON NO. 57.2					SAIL   17-51

		MOVE	5,ARR
		ADD	4,-4(5)		;BASE ADDR OF ARR
		PUSH	P,(4)
		PUSHJ	P,INTP		;RESULT IN 1

RINTP(ARR[PINT]);
		MOVE	6,PINT
		MOVE	7,ARR
		ADD	6,-4(7)
		PUSH	P,6		;ADDRESS
		MOVEM	1,INT2
		PUSHJ	P,RINTP

STRP(STR1&"CON",PSTR1);
		PUSH	SP,STR1
		PUSH	SP,STR1+1
		PUSH	SP,CONAD	;ADDRESS OF DSCRPTR FOR "CON"
		PUSH	SP,CONAD+1
		PUSHJ	P,CAT		;LEAVE CONCATENATE IN STACK
		PUSH	SP,-4(SP)	;PUT STR1 ON TOP
		PUSH	SP,-4(SP)
		PUSHJ	P,STRP

RSTRP(STR1);
		PUSH	P,[STR1+1]	;ALL REF PARAMS TO P-STACK
		PUSHJ	P,RSTRP

RSTRP(RPSTR);
		PUSH	P,-4(P)		;PASS REFERENCE ALONG;
		PUSHJ	P,RSTRP

RSTRP(PSTR2);
		HRROI	10,(SP)		;[3]RH2D WORD OF PSTR2
		PUSH	P,10
		PUSHJ	P,RSTRP

PROCP(RINTP);
		PUSH	P,[RINTP]	;PARAMETRIC PROCEDURE
		PUSHJ	P,PROCP

ARRP(SARR);
		PUSH	P,SARR		;THIS IS EFFECTIVELY A REFERENCE CALL
		PUSHJ	P,ARRP

SAILON NO. 57.2					SAIL   17-52

   
   
Discussion
   
   
17-52.    

[1]   Counts are  maintained  of  the  current  number  of  actual
      parameters  (during  a procedure call) on each stack.  These
      counts must be added to  the  parameter  indices  to  access
      parameters of the procedure doing the calling.

[2]   Whenever a SAIL procedure is called, all accumulators except
      SP ('16) and P ('17) are available for its use.

[3]   Some  String  operations  require  that  the  left  half  of
      pointers   to   descriptors   be  negative.   Therefore  any
      operation which obtains a String descriptor address  does  a
      HRRO  or  HRROI  to accomplish this.  In this case it is not
      necessary, but it won't  hurt  anything.   String  reference
      parameters  always point to the second word of the String in
      question.
   
SAILON NO. 57.2					SAIL   18-1

                              SECTION 18
                                    
                     APPENDIX -- USEFUL SUMMARIES
                                    
   
   
ARITHMETIC TYPE-CONVERSION TABLE
   
   
18-1.    
   
   
   
OPERATION     ARG1   ARG2   ARG1'  ARG2'  RESULT
   
+ -           INT    INT    INT    INT    INT*
* ^ %         REAL   INT    REAL   REAL   REAL
              INT    REAL   REAL   REAL   REAL
              REAL   REAL   REAL   REAL   REAL
   
LAND LOR      INT    INT    INT    INT    INT
EQV XOR       REAL   INT    REAL   INT    REAL
              INT    REAL   INT    REAL   INT
              REAL   REAL   REAL   REAL   REAL
   
LSH ROT       INT    INT    INT    INT    INT
              REAL   INT    REAL   INT    REAL
              INT    REAL   INT    INT    INT
              REAL   REAL   REAL   INT    REAL
   
/             INT    INT    REAL   REAL   REAL
              REAL   INT    REAL   REAL   REAL
              INT    REAL   REAL   REAL   REAL
              REAL   REAL   REAL   REAL   REAL
   
MOD DIV       INT    INT    INT    INT    INT
              REAL   INT    INT    INT    INT
              INT    REAL   INT    INT    INT
              REAL   REAL   INT    INT    INT
   
* Unless ARG2 is <0 for the operator ^
SAILON NO. 57.2					SAIL   18-2

   
   
SAIL RESERVED WORDS
   
   
18-2.    
   
ABS AND ANY ARRAY ARRAYPDL ASSOC BBPP  BEGIN  BOOLEAN  CASE  COMMENT
CONTINUE  COP  CVI  CVN  DATUM DEFINE DELETE DIV DO DONE DPB ELSE END
ENTRY EQV ERASE EXTERNAL FALSE FIRST FOR FOREACH FORTRAN FORWARD FROM
GEQ  GLOBAL  GO  GOTO  IBP IDPB IF ILDB IN INF INTEGER INTER INTERNAL
ISTRIPLE  ITEM  ITEMVAR  LABEL  LAND  LDB  LENGTH  LEQ  LET   LIBRARY
LOADMODULE  LNOT  LOP  LOR LSH MAKE MAX MESSAGE MIN MOD NEEDNEXT NEQ
NEXT NEW NEWITEMS  NOT  NULL  OF  OR  OWN  PHI  PNAMES  PRELOADWITH
PROCEDURE  PUT  QUICKCODE  REAL  RECURSIVE  REFERENCE REMOVE REQUIRE
RETURN ROT SAFE SECOND SEGMENTNAME SEGMENTFILE SET SETC SETO  SHORT
STARTCODE  STEP STRING STRINGPDL STRINGSPACE SOURCEFILE SUCH SWAP
SYSTEMPDL THAT THEN THIRD TO TRUE UNTIL VALUE WHILE XOR
   
   
SAIL PRE-DECLARED IDENTIFIERS
   
   
18-3.    
   
ARRBLT ARRINFO ARRTRAN ARRYIN  ARRYOUT  BACKUP  BREAKSET  CALL  CLOSE
CLOSIN  CLOSO  CLRBUF  CODE CVASC CVD CVE CVF CVFIL CVG CVIS CVO CVOS
CVS CVSI CVSIX CVSTR CVXSTR  ENTER  EQU  FILEINFO  GETCHAN  GETFORMAT
INCHRW  INCHRS  INCHSL INCHWL INSTR INSTRL INSTRS INPUT INTIN INTSCAN
LINOUT LODED LOOKUP MTAPE OPEN OUT OUTCHR OUTSTR PTCHRS PTCHRW PTIFRE
PTOCNT  PTOCHS PTOCHW PTOSTR PTYALL PTYGET PTYIN PTYREL PTYSTR REALIN
REALSCAN RELEASE RENAME SCAN SETBREAK SETFORMAT STRBRK  TTYIN  TTYINL
TTYINS WORDIN WORDOUT USERCON USERERR USETI USETO
SAILON NO. 57.2					SAIL   18-4

   
   
CHARACTER-IDENTIFIER EQUIVALENCES
   
   
18-4.    


	CHARACTER		RESERVED WORD

	    			   AND
	    			   EQV	
	    			   NOT
		    			   OR
	    			   XOR	
	    			   INF
	    			   IN
	    |			   SUCH THAT
	    			   NEQ
	    			   LEQ
	    			   GEQ
	    {			   SETO
	    ~			   SETC
	    			   UNION
	    			   INTER
	    `			   ASSOC
	    			   SWAP
	    			   !

SAILON NO. 57.2					SAIL   18-5

   
   
PARAMETERS TO THE OPEN FUNCTION
   
   
18-5.    
   

CHANNEL   System Data Channel, 0-'17
	
DEVICE    string giving device name

MODE      data mode, bits 18-21, 23 enable error returns

INBUFS    number of input buffers, lh buffer size if 0

OUTBUFS   number of output buffers

COUNT     text input count (reference)

BRCHAR    break char variable (reference)

EOF       end-of-file and IO error flag (reference)
SAILON NO. 57.2					SAIL   18-6

   
   
BREAKSET MODES
   
   
18-6.    

I         (Inclusion) string is set of break chars

X         (eXclusion) string of all non-break chars

O         (Omit) string of characters to be omitted from result
             

S         (skip) break char appears only in BRCHAR variable

A         (Append) break char is last char of result string

R         (Retain) break char is first char of next string
             

P         (Pass) line numbers appear in input without warning

N         (No numbers) line numbers and the tabs that follow  them
          are removed.

L         (Line no break) line numbers cause input break.   BRCHAR
          is negative.  Next input gets line no characters.

E         (Erman) line numbers cause input break.  Negated line no
          returned in BRCHAR.  Line no removed from input.

D         (Display) after this appears, each line no is listed  on
          the display (if TTY is a DPY) as it is dealt with.
SAILON NO. 57.2					SAIL   18-7

   
   
MTAPE COMMANDS
   
	   
18-7.    
             
             

MODE      FUNCTION
             

"A"       Advance past one tape mark (or file)

"B"       Backspace past one tape mark

"F"       Advance one record

"R"       Backspace one record

"W"       Rewind tape

"E"       Write tape mark

"U"       Rewind and unload
             
SAILON NO. 57.2					SAIL   18-8

   
   
COMMAND SWITCHES
   
   
18-8.    

D         double size of define pushdown stack

numL      listing control -- num>0 becomes listing starting  addr.
          num=-1  starts  listing  after current DDT size.  num=-2
          starts listing after current RAID size.

numM      initial debugging mode set to num

P         double size of system pushdown list

Q         double size of string pushdown list

R         double size of parse pushdown list

numS      set size of string space to num

C         create CREF (cross-reference) input file.

numF      enable various listing formats.
   
   
DEBUGGING MODES
   
   
18-9.    

1         display before executing each code generation routine

2         don't display, but remain enabled for  asynchronous  and
          line breaks

3         display before each production is compared

4         continue from type 1 and 3 modes automatically

5         just display input file as it goes past

6         disable debugging mechanism (started in this mode unless
          an M switch appears).
SAILON NO. 57.2					SAIL   18-10

   
   
VALID RESPONSES TO ERROR MESSAGES
   
   
18-10.    

CR        (carriage return) try to continue

LF        (line feed) continue automatically  --  don't  stop  for
          user go-ahead after each message

S         restart

X         exit -- close all files, return to monitor

L         look at stacks -- of interest only to compiler fixers

E         edit.  Follow by CR to get file the compiler is  working
          on (or last thing edited, for runtime routines).  Follow
          with <name> CR to edit <name>.

D         go to DDT or RAID
SAILON NO. 57.2					SAIL   18-11

   
   
NON-FATAL ERROR, EXCEPTIONAL CONDITION RETURN CODES
   
18-11.    


ROUTINE    CODE LOCATION        CONDITIONS, CODE VALUES 

CALL      SKIP         set TRUE if the UUO skips, FALSE otherwise

CODE      SKIP         set TRUE if the constructed instruction
                         skips, FALSE otherwise

CVFIL     SKIP         set TRUE if the file input is invalidly
                         specified (wrong punctuation, order, etc.),
                         FALSE otherwise.

CVIS      FLAG param     set TRUE if no PNAME exists for  this  Item,
                         FALSE if CVIS succeeds.

CVSI      FLAG param     set TRUE if no Item exists with this  String
                         as PNAME, FALSE if CVSI succeeds.

ENTER     FLAG param     set FALSE if the ENTER succeeds.  Otherwise,
                         the  left half is made -1.  Then if the file
                         name was invalid, the  right  half  is  made
                         '10.   Otherwise it is set to some code from
                         0 to 7,  depending  on  the  type  of  ENTER
                         failure.   These  codes  are the same as the
                         ENTER UUO codes in [Moorer].  If  error  '10
                         (invalid   spec.)   is  returned,  an  error
                         message (non-fatal) will  also  be  printed,
                         unless  you are enabled for user handling of
                         this error (see I/O below).

GETCHAN   result         <0 if no channel is available.

INCHRS    result         <0 if no characters are waiting.

INCHSL    FLAG param     0 if no characters are waiting.

INSTRS    FLAG param     0 if no characters are waiting.
SAILON NO. 57.2					SAIL   18-11


I/O       EOF vbl.       0 if no exceptional conditions  occurred  in
                         an  I/O operation.  Otherwise, the left half
                         has certain bits turned on, indicating the
                         error: 400000  is  a  catchall  --  improper
                         mode.
                         200000 means parity error occurred.
                         100000 means a data error occurred.
                         40000 means "Record number out of bounds".
                         20000 means End of File (input only).
                         You  are always enabled for bit 20000 (EOF).
                         However, to be allowed to handle any of  the
                         others,  you  must turn on the corresponding
                         bit in the right half of the  MODE  word  in
                         the OPEN for this channel.  In addition, the
                         10000 bit is used to enable user handling of
                         invalid   file   specifications   to  ENTER,
                         LOOKUP, and RENAME (see above).  '7500017 in
                         the  MODE parameter would enable a dump mode
                         file for user handling of ALL I/O errors  on
                         this  channel.  If you are not enabled for a
                         given error, an error message (which may  or
                         may  not  be fatal) will be printed, and the
                         error  code  word  set  as  indicated.    In
                         addition,   the  number  of  words  actually
                         transferred is stored in the right  half  of
                         this variable for ARRYIN, ARRYOUT.

LOOKUP    FLAG param     same as ENTER.

OPEN      EOF vbl        if 0 on entry, prints fatal error message if
                         OPEN  fails.  If 0 on entry, always returns
                         to user -- still 0 if OPEN failed, 0 if  it
                         succeeded.

RENAME    FLAG param     same as ENTER.

TTYINS    FLAG param     same as INSTRS.
SAILON NO. 57.2					SAIL   18-11


substrings SKIP        consider ST[X TO Y]. If Y>LENGTH(ST), Y_
			 LENGTH(ST).  If Y<0, Y_0; rh(SKIP)_-1 with
                         both. If X<1, X_1.   If  X>Y it  is  set  to
                         Y+1 (guaranteeing a null String result).  In
                         either case, lh(SKIP) is set to  -1.   The
                         ST[X  FOR  Y] case is first converted to the
                         other case, then executed.

You should also refer to the table for Input, 12-40,  describing  the
                         various  combinations  of the BRCHAR and EOF
                         variables and their meanings.
SAILON NO. 57.2					SAIL   19-1

                                          SECTION 19
                                                 
                                         BIBLIOGRAPHY
                                                 
                            
                            
                         19-1.    


REFERENCE           DESCRIPTION

	
Feldman             Feldman, J.A.  and Rovner, P.D.   An  Algol-Based
                    Associative  Language,  Comm.   ACM  12,  8 (Aug.
                    1969), 439-449.


Moorer               Moorer,  J.A.   Stanford  A-I  Project   Monitor
                    Manual, Sailons 54 and 55 (Sep.  1969).


Weiher              Weiher, W.F.   Loader  Input  Format,  Sailon  46
                    (Oct.  1968).


Savitzky            Savitzky, S.R.   Son  of  Stopgap,  Sailon  50.1,
                    (Sep.   1969),  a revision of Stopgap, Sailon 50,
                    by W.F.  Weiher.
SAILON NO. 57.2					SAIL   19-1

INDEX

10- 1	<associativeexpr>
10- 1	<derivedset>
10- 1	<itemexprlist>
10- 1	<itemexpression>
10- 1	<setexpression>
10- 1	<setfactor>
10- 1	<setprimary>
10- 1	<setterm>
 7- 1	<triple>
10- 1	<triple>
 9-54	Abs
 8- 1	<acfield>
 6- 1	<actualparameter>
 6- 1	<actualparameterlist>
 9- 1	<actualparameterlist>
 9- 1	<actualparameter>
13- 9	Actual Parameter Expansion
 6- 4	Actual Parameters
 9- 1	<addingexpression>
 9- 1	<addingoperator>
 9-30	Adding Expressions
 8- 1	<address>
 8- 1	<addresses>
 4- 1	<algebraicassignment>
 9- 1	<algebraicexpression>
 9- 1	<algebraicrelational>
 3- 1	<algebraictype>
 9- 1	<algebraicvariable>
 9	ALGEBRAIC EXPRESSIONS
 9-15	Algebraic Expressions
10- 7	ANY Construct
18	APPENDIX -- USEFUL SUMMARIES
11-15	Arithmetic Constants
 9-21	Arithmetic Type Conversions
 3- 1	<arraydeclaration>
 3- 1	<arraylist>
 3- 1	<arraysegment>
17-37	Array Allocation
 3-25	Array Declarations
17-35	ARRAY IMPLEMENTATION
 3-31	Arrays, outer block
 3-30	Arrays, OWN
 3-26	Arrays, SAFE declaration
 3-27	Arrays, storage convention
12-112	Arrblt
12-110	Arrinfo
12-114	Arrtran
SAILON NO. 57.2					SAIL   19-1

12-50	Arryin
12-55	Arryout
16-12	Assembly Language Procedures
 8	ASSEMBLY LANGUAGE STATEMENTS
 4- 1	<assignment>
 9- 1	<assignmentexpression>
 4- 1	<assignmentstatement>
 9- 4	Assignment Expressions
 4- 7	Assignment statement, DATUM
 4- 3	Assignment statement, semantics
 4- 8	Assignment statement, Swap
 4	ASSIGNMENT STATEMENTS
 7- 1	<associativecontext>
10- 1	<associativeexpression>
10- 1	<associativeoperator>
 7- 1	<associativestatement>
 7-18	Associative context, satisfaction
11	BASIC CONSTRUCTS
19	BIBLIOGRAPHY
14- 1	<binaryname>
 7- 1	<bindinglist>
 2- 1	<block>
 2- 1	<blockhead>
 2- 1	<blockname>
 2- 9	Block Names
 3-20	Block structure, for items
 3-14	Boolean, declaration
 9- 1	<booleanexpression>
10- 9	Boolean constructs, for LEAP
 9-10	Boolean Expression, anomaly
 7-16	Boolean expressions, if FOREACH specifications
 9-56	Boolean Primaries
 3- 1	<boundpair>
 3- 1	<boundpairlist>
 9- 1	<boundedexpression>
 9-29	Bounded Expressions
 7-11	Bracketed Triples
 9-57	Bracketed triples, ISTRIPLE
	10- 5	Bracketed triples, selectors
 7-14	Breakpoints, MAKE and ERASE
12-22	Breakset
 4- 1	<bytestatement>
12-127	Byte pointers, creation
 4-10	Byte statements
12-118	Call
17-12	Caninc
 9- 1	<caseexpression>
 5- 1	<casestatement>
 5- 1	<casestatementhead>
SAILON NO. 57.2					SAIL   19-1

 9- 6	Case Expressions
 5-18	Case Statements
12-10	Close, Closin, Closo
12-116	Code
 8- 1	<codebegin>
 8- 1	<codeblock>
 8- 1	<codehead>
 8- 1	<codetail>
	14- 1	<commandline>
14- 1	COMMAND FORMAT
 2-10	Comment
11-24	Comments
14	COMPILER OPERATION
 2- 1	<compoundstatement>
 2- 1	<compoundtail>
 9-38	Concatenation Operator
 9- 1	<conditionalexpression>
 5- 1	<conditionalstatement>
 9- 2	Conditional Expressions
 5- 2	Conditional Statements
 5- 6	Conditional Statements, ambiguity
11-15	Constants, arithmetic
11-16	Constants, octal
11-17	Constants, real
11-19	Constants, string
 7- 8	Construction, definition
10- 1	<constructionitemprim>
 5- 1	<continuestatement>
 5-30	Continue Statement
 4- 6	Conversions, algebraic
 9-21	Conversions, algebraic
 9-12	Conversions, Boolean to Integer
 3-36	Conversions, for preloaded arrays
 3-17	Conversions, string
 9-27	Conversions, strings
 9-11	Conversions, to BOOLEAN
10- 4	COP, of set
17-13	Corbig
17- 6	Corget
17-11	Corinc
17-10	Correl
12-105	Cvasc
12-101	Cvd
12-92	Cve, Cvf, Cvg
12-109	Cvfil
10- 8	CVI
12-84	Cvis
 9-52	Cvn
12-103	Cvo
SAILON NO. 57.2					SAIL   19-1

12-82	Cvos
12-80	Cvs
12-86	Cvsi
12-107	Cvsix
12-97	Cvstr
12-99	Cvxstr
 7- 3	DATUM, use of
 4- 7	Datum Assignments
11- 6	Datums
15- 9	DEBUGGING
14-14	Debugging modes
 3- 1	<declaration>
 2- 3	Declarations
 3	DECLARATIONS
 8- 3	Declarations in Code Blocks
 3- 1	<definebody>
 3- 1	<defineidentifier>
 3- 1	<definespecification>
 3-56	Define Specification
13- 1	Defining Macros
 3- 1	<definition>
 3- 1	<definitionlist>
12-90	DelPname
 7-10	DELETE
14- 1	<devicename>
 9- 1	<disjunctiveexpression>
 9-18	Disjunctive Expressions
 8- 7	Distinctions Between STARTCODE and QUICKCODE
 5- 1	<dostatement>
 5-17	Do Statement
 5- 1	<donestatement>
 5-24	Done Statement
 4-10	DPB
 7- 1	<element>
 2- 1	<entryspecification>
 2-11	Entry Specifications
12-73	Equ
 7-13	ERASE
 7-13	ERASE, restriction
14-19	ERROR MESSAGES
 5	EXECUTION CONTROL STATEMENTS
12	EXECUTION TIME ROUTINES
 9- 1	<expression>
 9- 1	<expressionlist>
 9-14	Expression Evaluation Rules
 3- 2	EXTERNAL declaration
 3-47	External Procedures
 9- 1	<factor>
 9-39	Factors
SAILON NO. 57.2					SAIL   19-1

11-18	FALSE, definition
14- 1	<fileext>
14- 1	<filename>
 3- 1	<filespec>
14- 1	<filespec>
10- 5	FIRST, of bracketed triple
 5- 1	<forlist>
 5- 1	<forlistelement>
 5- 1	<forstatement>
 5-11	For Statements
 7-19	FOREACH specification, evaluation
 7-15	FOREACH Statement
 7-21	FOREACH statement, efficiency considerations
 7-20	FOREACH statement, harsh warning
 7-22	FOREACH statement, restrictions and warnings
 3- 1	<formalparamdecl>
 3- 1	<formalparameterlist>
 3- 1	<formaltype>
 3-39	Formal Parameters
 3-54	FORTRAN, actual parameters
 3-49	FORTRAN, declaration
 6-12	Fortran Procedures
16-11	Fortran Procedures
 3- 2	FORWARD declaration
 3-42	Forward Procedure Declarations
 9- 1	<functiondesignator>
 9-47	Function Designators
11-12	Functions, predeclared
12-12	Getchan
12-78	Getformat
 5- 1	<gotostatement>
 3-54	Go To, restriction
 5- 8	Go To Statements
 5- 8	Go To Statements, restrictions
12- 6	I/O ROUTINES
 4-10	IBP
 3- 1	<idlist>
11- 7	Identifiers
 4-10	IDPB
 5- 1	<ifstatement>
 5- 4	If Statement
 5- 5	If ... Else Statement
 9-58	ILDB
17	IMPLEMENTATION INFORMATION
 8- 1	<indexfield>
 8- 1	<indexedaddress>
 2- 8	Inner block
12-40	Input
 8- 1	<instruction>
SAILON NO. 57.2					SAIL   19-1

 3-13	Integers, range
 3- 2	INTERNAL declaration
 3-48	Internal procedures
10- 2	Intersection, sets
 1	INTRODUCTION
 9-57	ISTRIPLE
 3-54	ITEM, procedure
 4- 1	<itemassignment>
10- 1	<itemprimary>
 3- 2	ITEM ARRAYS, nonexistence
10- 4	Item Constructs
 3-18	Item Declarations
 3-20	Item Genesis
10- 5	Item Selectors
 3-19	Items
10- 6	Items, dynamic NEW
 7- 4	ITEMS, storage of instances
10- 1	<itemvarvariable>
 3-22	Itemvar Declarations
 3-23	Itemvars, binding in FOREACH
 7-17	ITEMVARS, binding in FOREACH specifications
 7-15	ITEMVARS, binding in FOREACH statements
 7-23	ITEMVARS, in FOREACH statement
 7- 4	ITEMVARS, use
 3- 1	<labeldeclaration>
 5- 1	<labelidentifier>
 3- 4	Label use
 3-54	Labels, as actual parameters
 9-58	LDB and ILDB
 7- 2	LEAP, introduction
 7- 7	LEAP, restrictions
 9- 1	<leaprelational>
10- 1	<leaprelational>
 7- 1	<leapstatement>
 3- 1	<leaptype>
10- 9	LEAP Booleans
 7	LEAP STATEMENTS 
 9-50	Length
12-116	LIBERATION-FROM-SAIL ROUTINES
12- 1	Library, runtime
12-46	Linout
14- 1	<listingname>
 8- 1	<literal>
 9-53	Lnot
15- 1	LOADING AND STARTING SAIL PROGRAMS
 9-30	Logical Expressions
12-17	Lookup, Enter
 7- 1	<loopstatement>
 9-51	Lop
SAILON NO. 57.2					SAIL   19-1

10- 4	LOP, of set
17-28	Lop Details
 3- 1	<lowerbound>
13- 6	Macro Parameters
16- 2	Main Program
 7-11	MAKE
 7-13	MAKE, restriction
 8- 4	Meaning of Instruction Operands
12-57	Mtape
 9- 1	<multoperator>
 9- 1	<negatedexpression>
10- 6	NEWITEM Declaration
12-88	NewPname
10- 6	NEW Items
 5- 1	<nextstatement>
 5-26	Next Statement
18-11	NON-FATAL ERROR, EXCEPTIONAL CONDITION RETURN CODES
11-21	NULL, definition
 3-13	Numeric Declarations
 8- 1	<opcode>
12- 6	Open
12-45	Out
 2- 8	Outer block
10- 3	PHI, the empty set
12-126	Point
 9-13	Precedence of Algebraic Operators
 3- 1	<preloadelement>
 3- 1	<preloadlist>
 3- 1	<preloadspecification>
 3-33	Preload Specifications
 9-40	Primaries
 9- 1	<primary>
 3- 1	<procedurebody>
 3- 1	<proceduredeclaration>
 3- 1	<procedurehead>
 6- 1	<procedurestatement>
 3- 5	Procedure body, emptiness
17-51	Procedure Calling Sequences
 6- 4	Procedure Calls, actual parameters
 6- 2	Procedure Calls, semantics
 3-38	Procedure Declarations
17-48	PROCEDURE IMPLEMENTATION
	 6	PROCEDURE STATEMENTS
 6-10	Procedures, as actual parameters
 3-53	Procedures, defaults in declarations
 3-51	Procedures, parametric
 3-54	Procedures, restrictions
 2- 1	<program>
 2- 9	Program name, for DDT
SAILON NO. 57.2					SAIL   19-1

15	PROGRAM OPERATION
16	PROGRAM STRUCTURE
 2	PROGRAMS, BLOCKS, STATEMENTS
14- 1	<projprog>
12-70	Pseudo-teletype functions (Stanford only)
 7- 9	PUT, use
12-61	Realin, Intin
 3-13	Reals, range
12-66	Realscan, Intscan
 3- 2	RECURSIVE declaration
 3-44	Recursive Procedures
 3-39	REFERENCE
 3-53	REFERENCE
 6- 6	REFERENCE, actual parameters
 9- 1	<relationalexpression>
 9- 1	<relationaloperator>
 9-19	Relational Expressions
12-14	Release
 7- 9	REMOVE, use
12-21	Rename
10- 6	REQUIRE, newitems
 3- 1	<requireelement>
 3- 1	<requirelist>
 3-57	REQUIRE declaration
 3- 1	<requirement>
 3-57	Requirements
11-10	Reserved words, list of
11-11	Reserved words, "Global Model"
 7- 8	Retrieval, definition
10- 1	<retrievalitemprim>
 9-47	RETURN, value of function
 5- 1	<returnstatement>
 5-20	Return Statement
14-12	Rpg Mode
11-12	Runtime routines, list of
11-13	Runtime routines, Stanford Only
 3- 2	SAFE declaration
 7-18	Satisfiers, of associative context
 7-19	Satisfiers, of associative context
12-43	Scan
 3- 8	Scope of declarations
10- 5	SECOND, of bracketed triple
10- 1	<selector>
16- 7	Separately Compiled Procedures
 4- 1	<setassignment>
10- 1	<setexpression>
 7- 1	<setstatement>
10- 1	<setvariable>
10	SET AND ASSOCIATIVE EXPRESSIONS
SAILON NO. 57.2					SAIL   19-1

 3-24	Set Declarations
10- 2	Set Expressions
10- 3	Set Primaries
12-35	Setbreak
12-75	Setformat
10- 3	Sets, derived from associations
 7-15	SETS, in FOREACH specifications
 7- 5	SETS, use
 9-24	Short IntegerReal Conversions
 8- 1	<simpleaddress>
 9- 1	<simpleexpression>
 9- 9	Simple Expressions
 3- 1	<simplerformaltype>
14- 1	<slashedswitchlist>
14- 1	<sourcelist>
 3- 1	<spacespec>
 9-45	Special Length Operator ()
15- 2	Starting the Program -- Normal Operation
15- 3	Starting the Program in "RPG" Mode
15- 4	Starting the Program with Allocation Modifications
 2- 1	<statement>
 2- 6	Statements
12-37	Stdbrk
14-22	STORAGE ALLOCATION
17- 5	Storage Allocation Routines
17- 1	STORAGE LAYOUT
 9-27	String-Arithmetic Conversions
 9- 1	<stringexpression>
17-33	String-Oriented Machine Language Routines
 9- 1	<stringvariable>
 2-10	String constant, as comment.
11-19	String Constants
 3-15	String Declarations
17-15	String Descriptors
17-32	String Garbage Collection
12-72	STRING MANIPULATION ROUTINES
17-20	String Operations
17-29	String Space
17-15	STRINGS
11- 1	<subscriptlist>
 9- 1	<substringspec>
 9-42	Substrings
10- 2	Subtraction, sets
 4- 1	<swapstatement>
 4- 8	Swap Assignment
 4- 2	Swap operator, restriction
14- 1	<switchspec>
14- 1	<switches>
14-13	Switches
SAILON NO. 57.2					SAIL   19-1
	
15-10	Symbols
 3- 1	<synonym>
 3- 1	<synonymdeclaration>
 3- 1	<synonymlist>
 3-55	Synonyms
12-68	Teletype I/O Functions
 9- 1	<term>
 9-33	Terms
16- 1	THE SAIL CORE IMAGE (REQUIRED)
10- 5	THIRD, of bracketed triple
 7-12	Triples, bracketed
 7-17	Triples, in FOREACH specifications
11-18	TRUE, definition
 3- 1	<type>
 3- 1	<typedeclaration>
 3- 1	<typequalifier>
12-75	TYPE CONVERSION ROUTINES
 3-11	Type Declarations
 9-55	Unary Minus
10- 2	Union, sets
	14- 1	<unslashedswitchlist>
 3- 1	<upperbound>
13	USE OF DEFINE
17- 1	User Table
12-120	Usercon
12-124	Usererr
12-59	Useti, Useto
13- 5	Using Macros
14- 1	<validswitchname>
 3-39	VALUE
 3-53	VALUE
 6- 5	VALUE, actual parameters
11- 1	<variable>
 3-11	Variables
11- 2	Variables
 8- 8	Warning Concerning Default Radix
 5- 1	<whilestatement>
 5-16	While Statement
12-48	Wordin
12-53	Wordout
 7-15	<bindinglist>
                    


  $ y