TITLE	RPWGEN FOR COBOL 5(100)	
SUBTTL	GENERATE CODE FOR REPORT-WRITER		AL BLACKINGTON/CAM

;COPYRIGHT 1971,1972, DIGITAL EQUIPMENT CORP, MAYNARD, MA.

TWOSEG
RELOC	400000

ENTRY INITRW	;INITIATE
ENTRY TERMRW	;TERMINATE
ENTRY GENRW	;GENERATE
ENTRY SETRPW	;SET UP CONTROL BREAK TESTS, ETC.

RPWGEN:	INTERNAL RPWGEN

	EXTERNAL MOVGEN,RESGEN,ADDTGN
	EXTERNAL FATAL,MSX.,MZC1.,MZC2.,MXX.
	EXTERNAL SETOPN,SETOPA,GETTAG,PUTTAG,LARGE,LNKSET
	EXTERNAL PUTASY,PUTASN,PUTAS1,SETUUO,STASHL
	EXTERNAL M.IB,IFGNZC


;DEFINE A MACRO TO PICK UP 'RD' ADDRESS

	DEFINE GETRD,<
	HLRZ	TA,CURRPW
	ADD	TA,RPWLOC
	>
SUBTTL GENERATE 'INITIATE'

INITRW:	MOVEI	EACB,INITT##	;PICK UP 'INIT.' OP-CODE
	MOVEM	W1,OPLINE	;SAVE OPERATOR
	MOVE	EACA,EOPLOC	;START AT TOP OF EOPTAB

INIT1:	CAMN	EACA,EOPNXT	;ARE WE DONE?
	POPJ	PP,		;YES

	PUSHJ	PP,INIT2	;NO--GENERATE <INIT. RPWTAB>

	MOVE	CH,[XWD MOVEI.,1];GENERATE
	PUSHJ	PP,PUTASY	;  <MOVEI. 0,1>
	LDB	CH,RW.PC	;GENERATE
	ANDI	CH,LMASKB	;  <MOVEM 0,PAGE-COUNTER>
	IORI	CH,AS.DAT
	HRLI	CH,MOVEM.
	PUSHJ	PP,PUTASY

	JRST	INIT1

INIT2:	ADD	EACA,[XWD 2,2]	;GET TO 2ND WORD OF NEXT OPERAND
	MOVE	TA,(EACA)	;GET RPWTAB LINK
	ANDI	TA,LMASKB	;CONVERT TO
	ADD	TA,RPWLOC	;  ADDRESS

	LDB	CH,RW.RWT	;GET TAG OF RUN-TIME RPWTAB
	JUMPN	CH,INIT3	;IF ZERO,
	POPJ	PP,		;  FORGET IT

INIT3:	HRLI	CH,(EACB)	;GET OP-CODE
	PUSHJ	PP,SETUUO	;SET UUOTAB BITS
	JRST	PUTASY		;WRITE IT OUT
SUBTTL GENERATE 'TERMINATE'

TERMRW:	MOVEI	EACB,TERM##	;GET 'TERM.' OP-CODE
	MOVEM	W1,OPLINE	;SAVE OPERATOR
	MOVE	EACA,EOPLOC	;START AT TOP OF TABLE

TERM1:	CAMN	EACA,EOPNXT	;ARE WE DONE?
	POPJ	PP,		;YES

	PUSHJ	PP,INIT2	;NO--GENERATE <TERM. RPWTAB>

	LDB	CH,RW.FBT	;GENERATE
	HRLI	CH,EPJPP	;  PUSHJ TO
	TRNE	CH,-1		;  FINAL BREAK ROUTINE UNLESS
	PUSHJ	PP,PUTASY	;  THERE IS NONE

	LDB	CH,RW.PFR	;GENERATE CALL TO
	HRLI	CH,EPJPP	;  PAGE-FOOTING ROUTINE
	TRNE	CH,-1		;  IF THERE IS ONE
	PUSHJ	PP,PUTASY

	LDB	CH,RW.RFR	;GENERATE CALL TO
	HRLI	CH,EPJPP	;  REPORT-FOOTING ROUTINE
	TRNE	CH,-1		;  IF THERE IS ONE
	PUSHJ	PP,PUTASY

	LDB	CH,RW.LC	;GENERATE
	ANDI	CH,LMASKB	;  <SETOM LINE-COUNTER>
	JUMPE	CH,TERM1	;*
	IORI	CH,AS.DAT	;*
	HRLI	CH,SETOM.	;*
	PUSHJ	PP,PUTASY	;*

	JRST	TERM1
SUBTTL GENERATE 'GENERATE'

GENRW:	MOVEM	W1,OPLINE	;SAVE OPERATOR
	MOVE	EACA,EOPLOC	;IF THERE
	CAMN	EACA,EOPNXT	;  IS NOTHING IN EOPTAB,
GENRW0:	POPJ	PP,		;  FORGET THE WHOLE THING

	MOVE	TA,2(EACA)	;GET OPERAND LINK
	ANDI	TA,LMASKB
	MOVSM	TA,CURRPW	;SAVE IT
	ADD	TA,RPWLOC	;CONVERT TO ADDRESS
	HRRM	TA,CURRPW	;  AND SAVE THAT

	SKIPL	0(TA)		;IS OPERAND AN 'RD'?
	JRST	GENRW2		;YES
	LDB	TA,RW.RDL	;NO--GET LINK TO 'RD'
	ANDI	TA,LMASKB
	HRLM	TA,CURRPW
	ADD	TA,RPWLOC

GENRW2:	LDB	TA,RW.COD	;GET LINK TO 'CODE'
	SKIPE	TA		;IF NON-ZERO,
	PUSHJ	PP,LNKSET	;  CONVERT IT TO ADDRESS
	HRRZM	TA,CURMNE	;SAVE ZERO OR MNETAB ADDRESS
	GETRD
	LDB	CH,RW.BKT	;GENERATE
	HRLI	CH,EPJPP	;  PUSHJ TO
	PUSHJ	PP,PUTASY	;  'BREAK-TEST' ROUTINE

	MOVE	TA,CURRPW	;GET BACK TO ITEM
	SKIPL	0(TA)		;IS IT 'RD'?
	JRST	GENRW3		;YES

;GENERATE CODE FOR DETAIL LINE

	MOVEI	TE,LINE.D
	MOVEM	TE,RWSAV7
	JRST	WRIGRP		;GENERATE CODE FOR LINE AND RETURN
;GENERATE LINES FOR 'RD'

GENRW3:	MOVE	TE,[XWD 1B18,LINE.D]; SET 'I AM RD'
	MOVEM	TE,RWSAV7

	LDB	TA,RW.FGP	;GET LINK TO FIRST GROUP ITEM
	JUMPE	TA,GENRW0	;IF ZERO LINK (ERROR IN RD), FORGET IT
GENRW4:	PUSH	PP,TA		;SAVE LINK TO 01-ITEM
	PUSHJ	PP,LNKSET	;CONVERT TO ADDRESS
	LDB	TA,DA.RPW	;GET ASSOCIATED RPWTAB LINK
	ANDI	TA,LMASKB
	ADD	TA,RPWLOC
	HRRM	TA,CURRPW	;SAVE RPWTAB ADDRESS

	LDB	TE,RW.TYP	;IF IT IS
	CAIN	TE,RWDE		;  A 'TYPE DETAIL' ITEM,
	PUSHJ	PP,WRIGRP	;  GENERATE SET-UP

	POP	PP,TA		;GET LINK TO 01-ITEM AGAIN
	PUSHJ	PP,LNKSET	;RE-COMPUTE ADDRESS
	LDB	TE,DA.FAL	;IF IT DOESN'T HAVE A BROTHER,
	JUMPN	TE,GENRW0	;  WE ARE DONE
	LDB	TA,DA.BRO	;GET BROTHER LINK
	JRST	GENRW4		;LOOP TO PROCESS THAT ONE
	SUBTTL GENERATE RPWTAB

SETRPW:	MOVE	TA,RPWLOC	;IF
	CAMN	TA,RPWNXT	;  NO RPWTAB ENTRIES,
	POPJ	PP,		;  QUIT

	MOVEI	TA,1(TA)	;SET TA TO FIRST ENTRY
	SUB	TA,RPWLOC

SETR00:	HRLM	TA,CURRPW	;SAVE ADDRESS OF 'RD'
	ADD	TA,RPWLOC

	PUSHJ	PP,GETTAG	;GET TAG FOR
	DPB	CH,RW.RWT	;  RUN-TIME RPWTAB

	PUSHJ	PP,SETCOD	;SET UP 'CODE'
	PUSHJ	PP,ROUTS	;GENERATE CODE FOR RH,RF,PH,PF

	GETRD
	LDB	CH,RW.RWT	;DEFINE TAG FOR RPWTAB
	PUSHJ	PP,PUTTAG

	MOVE	CH,[XWD AS.XWD,6]
	PUSHJ	PP,PUTASN

	LDB	CH,RW.PAG	;PAGE-LIMIT
	PUSHJ	PP,PUTASN
	LDB	CH,RW.LC	;ADDRESS OF LINE-COUNTER
	ANDI	CH,LMASKB
	IORI	CH,AS.DAT
	PUSHJ	PP,PUTASY

	LDB	CH,RW.FDE	;FIRST DETAIL LINE
	PUSHJ	PP,PUTASN
	LDB	CH,RW.LDE	;LAST DETAIL LINE
	PUSHJ	PP,PUTASY

	LDB	CH,RW.CFL	;LAST CONTROL FOOTING LINE
	PUSHJ	PP,PUTASN
	LDB	CH,RW.RHR	;ADDRESS OF RH ROUTINE
	PUSHJ	PP,PUTASY

	LDB	CH,RW.PHR	;ADDRESS OF PH ROUTINE
	PUSHJ	PP,PUTASN
	LDB	CH,RW.PFR	;ADDRESS OF PF ROUTINE
	PUSHJ	PP,PUTASY
	LDB	CH,RW.FIL	;FILE-TABLE ADDRESS
	ANDI	CH,LMASKS
	IORI	CH,AS.FIL
	PUSHJ	PP,PUTASN
	MOVEI	CH,0		;EMPTY RIGHT-HALF
	PUSHJ	PP,PUTASY

	HRRZ	TA,CURMNE	;GET ADDRESS OF 'CODE' MNETAB ENTRY
	JUMPN	TA,SETR0B	;IF NON-ZERO, THERE IS A CODE

	MOVEI	CH,0		;THERE IS NO CODE
	PUSHJ	PP,PUTASN	;PUT OUT
	PUSHJ	PP,PUTASY	;  <XWD 0,0>
	JRST	SETR01		;WE ARE DONE WITH OBJECT RPWTAB

SETR0B:	HRRZ	CH,1(TA)	;GET CODE SIZE
	PUSHJ	PP,PUTASN	;LH OF WORD 6 = CODE SIZE
	MOVS	CH,2(TA)	;RH OF WORD 6 = LITERAL ADDRESS
	HRRI	CH,AS.MSC	;*
	PUSHJ	PP,PUTASY	;*

SUBTTL GENERATE BREAK COMPARISONS

SETR01:	PUSHJ	PP,GETTAG	;GET TAG FOR BREAK-TEST START
	GETRD
	DPB	CH,RW.BKT	;SAVE IT
	PUSHJ	PP,PUTTAG	;GIVE IT TO ASSEMBLER

	GETRD
	LDB	CH,RW.RWT	;GENERATE <MOVEI 16,RPWTAB>
	HRLI	CH,MOVEI.+AC16
	PUSHJ	PP,PUTASY

	MOVE	CH,[XWD EPJPP,LIN.RH]	;GENERATE <PUSHJ 17,LIN.RH>
	PUSHJ	PP,PUTASY

	LDB	TE,RW.NCI	;SAVE
	MOVEM	TE,RWSAV1	;  NUMBER OF CONTROL IDENTIFIERS
	JUMPE	TE,SETR09	;IF NONE, NOT MUCH CODE NEEDED

	LDB	TB,RW.CID	;GET RELATIVE ADDRESS OF
	ANDI	TB,LMASKB	;  CONTROL IDENTIFIER PARAMETERS
	ADD	TB,RPWLOC	;CONVERT TO ADDRESS
	HRRZM	TB,RWSAV2	;SAVE

	PUSHJ	PP,GETTAG	;GET TAG FOR FIRST RESET
	HRLM	CH,2(TB)
	HRLI	CH,JRST.	;GENERATE
	PUSHJ	PP,PUTASY	;  <JRST %TAG>

	PUSHJ	PP,GETTAG	;GET TAG FOR
	MOVEM	CH,RWMBRK	;  BREAK PRINTING ROUTINE
	SETZM	RWBRKC		;CLEAR 'PARAM' ADDRESS
	MOVE	CH,RWSAV1	;GET CONTROL COUNT
	SOS	CH		;BREAK EVEN IF NO FINAL & ONLY 1 CONTROL

	SKIPN	@RWSAV2		;IS THERE A FINAL?
	SOS	CH		;YES--DEDUCT ONE FROM COUNTER
	HRLI	CH,MOVEI.	;GENERATE
	PUSHJ	PP,PUTASY	;  <MOVEI 0,CID-COUNT>
	MOVE	CH,[XWD MOVEM.,AS.MSC]; GENERATE <MOVEM 0,%PARAM>
	PUSHJ	PP,PUTASN
	MOVE	CH,EAS1PC
	IORI	CH,AS.PAR
	MOVEM	CH,RWBRKC	;SAVE BREAK COUNT ADDRESS
	PUSHJ	PP,PUTASY

	MOVE	CH,[XWD AS.OCT,1]
	PUSHJ	PP,PUTAS1
	MOVEI	CH,0
	PUSHJ	PP,PUTAS1
	AOS	EAS1PC
	JRST	SETR03
;PUT OUT BREAK TESTS

SETR03:	PUSHJ	PP,BLDPAR	;BUILD 'A' AND 'B' FOR CONDITIONAL TEST
	JRST	SETR07		;TROUBLE--FORGET THIS ONE

	MOVE	TB,RWSAV2
	PUSH	PP,TE		;SAVE SIZE OF ITEM COMPUTED BY 'BLDPAR'
	EXCH	TE,EAS1PC
	ADDM	TE,EAS1PC	;BUMP EAS1PC
	IORI	TE,AS.PAR	;CONVERT TO %PARAM TYPE
	HRRM	TE,0(TB)	;SAVE ADDRESS IN CONTROL INFO
	MOVEM	TE,EINCRB	;SET PARAMETER INCREMENT

	POP	PP,CH		;GET SIZE OF ITEM BACK
	HRRZ	TA,CH		;WRITE
	HRLI	CH,AS.OCT	;  OUT
	PUSHJ	PP,PUTAS1	;  'OCT 0'
SETR04:	MOVEI	CH,0		;  ONTO
	PUSHJ	PP,PUTAS1	;  AS1FIL FOR
	SOJG	TA,SETR04	;  EACH %PARAM WORD

	HRLZ	W2,RWMBRK
	MOVE	W1,OPLINE
	TLZ	W1,777770
	TLO	W1,EQTEST
	PUSHJ	PP,IFGNZC

;THAT BREAK IS SET -- TRY NEXT

SETR07:	SOSG	RWSAV1		;ANY MORE?
	JRST	SETR08		;NO

	MOVEI	TB,EXTRAS	;INCREMENT ADDRESS TO CONTROL DATA
	ADDB	TB,RWSAV2
	SKIPE	-EXTRAS(TB)	;IF THAT PREVIOUS ONE WAS 'FINAL',
	SKIPN	RWBRKC		;  OR THERE IS NO BREAK COUNT,
	JRST	SETR03		;  THEN NO 'SOS' NEEDED

	MOVE	CH,[XWD SOS.,AS.MSC]; GENERATE <SOS %PARAM>
	PUSHJ	PP,PUTASN
	HRRZ	CH,RWBRKC
	PUSHJ	PP,PUTASY
	JRST	SETR03		;GO BACK FOR MORE

;ALL BREAK TESTED -- PUT OUT 'POPJ'

SETR08:	MOVSI	CH,POPJ.+AC17
	PUSHJ	PP,PUTASY
	JRST	SETR10
;THERE ARE NO CONTROL FIELDS

SETR09:	GETRD
	LDB	CH,RW.GIR	;GET TAG
	SKIPN	CH		;  FOR
	PUSHJ	PP,GETTAG	;  'GROUP INDICATE'
	DPB	CH,RW.GIR	;  ROUTINE

	HRLI	CH,JRST.	;GENERATE <JRST GI-CODE>
	PUSHJ	PP,PUTASY

	MOVSI	CH,POPJ.+AC17	;GENERATE <POPJ 17,>
	PUSHJ	PP,PUTASY
	JRST	SETR70
SUBTTL GENERATE BREAK PRINTING ROUTINES

SETR10:	GETRD
	SKIPN	RWBRKC		;ANY BREAK COUNT?
	JRST	SETR15		;NO
	PUSHJ	PP,GETTAG	;YES--GET 'FINAL BREAK' TAG
	DPB	CH,RW.FBT	;SAVE FOR 'TERMINATE'
	PUSHJ	PP,PUTTAG	;DEFINE IT HERE

	MOVE	CH,[XWD HRLOI.,AS.CNB]; GENERATE
	PUSHJ	PP,PUTASN	;  <HRLOI 0,377777>
	MOVEI	CH,377777	;*
	PUSHJ	PP,PUTASY	;*

	MOVE	CH,[XWD MOVEM.,AS.MSC]; GENERATE
	PUSHJ	PP,PUTASN	;  <MOVEM 0,%PARAM>
	MOVE	CH,RWBRKC	;*
	PUSHJ	PP,PUTASY	;*

	MOVE	CH,RWMBRK	;GET TAG OF FIRST BREAK PRINTER
	JRST	SETR16

SETR15:	MOVE	CH,RWMBRK	;TAG OF FIRST BREAK PRINTER IS
	DPB	CH,RW.FBT	;  TAG OF FINAL BREAK
SETR16:	PUSHJ	PP,PUTTAG

	LDB	TE,RW.NCI	;GET NUMBER OF CONTROL IDENTIFIERS
	MOVEM	TE,RWSAV1	;SAVE IT
	IMULI	TE,EXTRAS

	LDB	TD,RW.CID	;GET ADDRESS OF FIRST CONTROL IDENTIFIER
	ANDI	TD,LMASKB
	ADDI	TD,-EXTRAS(TE)	;GET ADDRESS OF LAST CONTROL IDENTIFIER
	ADD	TD,RPWLOC
	HRRZM	TD,RWSAV2	;SAVE IT

SETR20:	GETRD
	HRRZ	TC,1(TD)	;GET ADDRESS OF CF GROUP
	ANDI	TC,LMASKB
	JUMPE	TC,SETR22
	ADD	TC,RPWLOC
	HRRM	TC,CURRPW
	MOVEI	TE,LINE.C
	MOVEM	TE,RWSAV7

	PUSHJ	PP,WRIGRP	;GENERATE CODE TO WRITE GROUP
;ALL LINES HAVE BEEN GENERATED FOR CURRENT CF GROUP

SETR22:	SKIPE	@RWSAV2		;WAS THAT 'FINAL'?
	SKIPN	RWBRKC		;NO--ANY CONTROL COUNT?
	JRST	SETR23		;NO

	MOVE	CH,[XWD SOSGE.,AS.MSC]; YES--
	PUSHJ	PP,PUTASN	;  GENERATE <SOSGE %PARAM.>
	HRRZ	CH,RWBRKC
	PUSHJ	PP,PUTASY

	MOVE	TD,RWSAV2	;ANY TAG THERE ALREADY?
	HLRZ	CH,2(TD)
	JUMPN	CH,SETR26	;IF SO, USE IT
	PUSHJ	PP,GETTAG	;GENERATE <JRST %RESET>
	MOVE	TD,RWSAV2
	HRLM	CH,2(TD)
SETR26:	HRLI	CH,JRST.
	PUSHJ	PP,PUTASY

SETR23:	SOSG	RWSAV1		;ANY LEFT?
	JRST	SETR25		;NO
	MOVNI	TD,EXTRAS	;YES--DECREMENT
	ADDB	TD,RWSAV2	;  ADDRESS
	JRST	SETR20		;  AND LOOP


;ALL GROUPS HAVE BEEN PUT OUT

SETR25:	MOVSI	CH,POPJ.+AC17	;GENERATE
	PUSHJ	PP,PUTASY	;  <POPJ 17,>
SUBTTL GENERATE 'RESET' CODE

SETR50:	GETRD
	LDB	TD,RW.CID	;GET ADDRESS OF
	ANDI	TD,LMASKB
	ADD	TD,RPWLOC	;  CONTROL IDENTIFIER PARAMETERS
	HRRZM	TD,RWSAV2	;SAVE IT
	LDB	TE,RW.NCI	;GET NUMBER OF CONTROL IDENTIFIERS
	MOVEM	TE,RWSAV1	;SAVE THAT

SETR51:	HLRZ	CH,2(TD)	;PUT OUT
	SKIPE	CH		;  ANY %TAG FOR
	PUSHJ	PP,PUTTAG	;  ROUTINE

	PUSHJ	PP,BLDPAR	;SET UP 'A' AND 'B' FOR SAVING CONTROL
	JRST	SETR52		;TROUBLE--FORGET IT

	MOVE	TE,RWSAV2	;GET %PARAM LOCATION FOR
	HRRZ	TE,0(TE)	;  SAVING THE VALUE
	JUMPE	TE,SETR52	;IF ZERO, FORGET IT
	HRRZM	TE,EINCRB	;GENERATE MOVE TO
	PUSHJ	PP,MXX.		;  SAVE THE VALUE OF THE CONTROL

SETR52:	MOVE	TE,RWSAV2	;PICK UP
	HLRZ	TA,1(TE)	;  'CH' GROUP LINK
	ANDI	TA,LMASKB
	JUMPE	TA,SETR53
	ADD	TA,RPWLOC
	HRRM	TA,CURRPW	;GENERATE
	PUSHJ	PP,WRIGRP	;  'CH' LINE
;CLEAR ALL SUMMATION COUNTERS

SETR53:	MOVE	TE,RWSAV2
	HRRZ	TA,1(TE)	;GET 'CF' LINK

SETR54:	ANDI	TA,LMASKB
	JUMPE	TA,SETR60
	ADD	TA,RPWLOC
	HRRM	TA,CURRPW

	LDB	TE,RW.SCD	;PICK UP 'SOURCE-SUM' CODE
	CAIE	TE,RWSUM	;IS IT A 'SUM'?
	JRST	SETR56		;NO

	LDB	TE,RW.RSF	;IS THE ITEM
	JUMPN	TE,SETR56	;  RESET ON 'FINAL'?
	LDB	TE,RW.RES	;NO--IS THERE A 'RESET ON' CLAUSE?
	SKIPN	TE		;IF NOT,
	PUSHJ	PP,SETZER	;  GENERATE CODE TO ZERO THE FIELD

SETR56:	PUSHJ	PP,NXTDAT	;GET NEXT DATA ITEM
	JRST	SETR60		;NO MORE--QUIT
	LDB	TE,DA.LVL	;IF THIS IS
	CAIN	TE,01		;  01-LEVEL,
	JRST	SETR60		;  QUIT,
	LDB	TA,DA.RPW	;  ELSE GET RPWTAB LINK AND
	JRST	SETR54		;  LOOP
;ALL SUMMATION COUNTERS ARE CLEARED FOR THIS GROUP.
;FIND ALL 'RESET ON' CLAUSES WHICH REFERENCE THIS CONTROL.

SETR60:	HLRZ	TE,@RWSAV2	;SAVE
	MOVEM	TE,RWSAV3	;  LINK TO CONTROL IDENTIFIER
	PUSH	PP,RWSAV1	;SAVE COUNT
	PUSH	PP,RWSAV2	;SAVE POINTER

SETR61:	SOSG	RWSAV1		;ANY MORE CONTROLS?
	JRST	SETR66		;NO--DONE WITH THIS CONTROL GROUP

	MOVEI	TD,EXTRAS	;YES--STEP DOWN TO
	ADDB	TD,RWSAV2	;  NEXT CONTROL

	HRRZ	TA,1(TD)	;IF NO CONTROL-FOOTING GROUP,
	JUMPE	TA,SETR61	;  TRY NEXT ONE

SETR62:	ANDI	TA,LMASKB	;GET ADDRESS OF
	ADD	TA,RPWLOC	;  RPWTAB ENTRY
	HRRM	TA,CURRPW	;SAVE IT

	LDB	TE,RW.SCD	;IF THIS ITEM
	CAIE	TE,RWSUM	;  IS NOT SUM,
	JRST	SETR65		;  GO TO NEXT

	SKIPE	RWSAV3		;IF WE ARE NOT RESETTING FINAL,
	JRST	SETR63		;  SEE IF THERE IS 'RESET ON ID'
	LDB	TE,RW.RSF	;IS ITEM TO BE RESET ON FINAL?
	JUMPE	TE,SETR65
	JRST	SETR64		;YES

SETR63:	LDB	TE,RW.RES	;GET RESET CONTROL IDENTIFIER
	CAMN	TE,RWSAV3	;IF IT IS THIS GROUP
SETR64:	PUSHJ	PP,SETZER	;  GENERATE 'MOVE ZERO'

SETR65:	PUSHJ	PP,NXTDAT	;GO TO NEXT DATA ITEM
	JRST	SETR61		;NO MORE--GO TO NEXT CONTROL
	LDB	TE,DA.LVL	;IF THIS IS
	CAIN	TE,01		;  01-LEVEL
	JRST	SETR61		;  GO TO NEXT CONTROL
	LDB	TA,DA.RPW	;GET ASSOCIATED RPWTAB LINK
	JRST	SETR62		;LOOP

SETR66:	POP	PP,RWSAV2	;RESTORE TO
	POP	PP,RWSAV1	;  WHERE WE WERE

SETR67:	SOSG	RWSAV1		;ANY MORE CONTROLS?
	JRST	SETR70		;NO
	MOVEI	TD,EXTRAS	;YES--INCREMENT TO NEXT CONTROL
	ADDB	TD,RWSAV2
	JRST	SETR51
SUBTTL PUT OUT 'GROUP INDICATE' CODE

SETR70:	GETRD
	LDB	CH,RW.GIR	;IS THERE A TAG FOR
	SKIPN	CH		;  'GROUP INDICATE' ROUTINE?
	PUSHJ	PP,GETTAG	;NO--GET ONE
	DPB	CH,RW.GIR	;SAVE IT
	PUSHJ	PP,PUTTAG	;DEFINE IT

	LDB	TA,RW.FGP	;GET LINK TO FIRST GROUP
	JUMPE	TA,SETR80	;IF NULL--FORGET IT

SETR71:	PUSHJ	PP,LNKSET	;GET DATAB ADDRESS
SETR72:	LDB	TA,DA.RPW	;GET RPWTAB LINK
	ANDI	TA,LMASKB
	JUMPE	TA,SETR80
	ADD	TA,RPWLOC
	HRRM	TA,CURRPW	;SAVE LINK TO GROUP
	LDB	TE,RW.TYP	;IS THE GROUP
	CAIN	TE,RWDE		;  TYPE DETAIL?
	JRST	SETR73		;YES

	LDB	TA,RW.DAT	;DOES THIS
	PUSHJ	PP,LNKSET	;  01 DATA-NAME
	LDB	TE,DA.FAL	;  HAVE
	JUMPN	TE,SETR80	;  A BROTHER?

	LDB	TA,DA.BRO	;YES--GET LINK
	JUMPN	TA,SETR71	;IF NON-ZERO--LOOP
	JRST	SETR80		;IF ZERO--QUIT
;GROUP IS TYPE DETAIL

SETR73:	LDB	TA,RW.DAT	;GET DATAB LINK
SETR74:	PUSHJ	PP,LNKSET	;CONVERT TO ADDRESS
SETR75:	HRRZM	TA,CURDAT	;SAVE IT

	LDB	TA,DA.RPW	;GET ASSOCIATED
	ANDI	TA,LMASKB
	ADD	TA,RPWLOC	;  RPWTAB ENTRY
	HRRM	TA,CURRPW

	LDB	TE,RW.GPI	;IF NOT 'GROUP INDICATE',
	JUMPE	TE,SETR76	;  NO CODE
	LDB	TE,RW.SLK	;IF NO SOURCE LINK,
	JUMPE	TE,SETR76	;  NO CODE

	MOVE	EACA,EOPLOC	;SET UP
	SETZM	1(EACA)		;  AND CALL
	SETZM	3(EACA)		;  'MOVE'
	MOVEM	TE,2(EACA)	;*
	LDB	TE,RW.DAT	;*
	MOVEM	TE,4(EACA)	;*
	ADD	EACA,[XWD 4,4]	;*
	PUSHJ	PP,MOVGEN	;*

SETR76:	PUSHJ	PP,NXTDAT	;GET NEXT DATA ITEM
	JRST	SETR80		;NO MORE--QUIT

	LDB	TE,DA.LVL	;IF NOT
	CAIE	TE,01		;  01-LEVEL,
	JRST	SETR75		;  LOOP
	JRST	SETR72		;START AGAIN WITH NEW GROUP

;DONE WITH 'GROUP INDICATE' CODE

SETR80:	MOVSI	CH,POPJ.+AC17	;GENERATE <POPJ 17,>
	PUSHJ	PP,PUTASY

	GETRD
	LDB	TA,RW.BRO	;DOES IT HAVE A BROTHER?
	ANDI	TA,LMASKB
	JUMPN	TA,SETR00	;IF TRUE, LOOP BACK FOR IT
	POPJ	PP,		;NOT TRUE--QUIT
SUBTTL SET A SUM-COUNTER TO ZERO

SETZER:	LDB	TA,RW.SLK	;GET LINK TO ITEM
	JUMPE	TA,SETZ2	;IGNORE ZEROES
	MOVE	TC,EOPLOC	;SET UP
	MOVEI	TC,1(TC)	;  EOPTAB TO
	MOVEM	TC,CUREOP	;  LOOK AS IF
	MOVEM	TC,OPERND	;  ITEM CAME FROM GENFIL
	SETZM	0(TC)
	HRRZM	TA,1(TC)
	MOVEI	LN,EBASEB	;NOW SET UP 'B' PARAMETERS
	PUSHJ	PP,SETOPN
	TSWF	FERROR		;IF TROUBLE,
SETZ2:	POPJ	PP,		;  QUIT

	MOVEI	TD,MZC1.	;PRETEND IT IS 1-WORD ACCUMULATOR
	HRRZ	TE,EMODEB	;IF IT IS ACTUALLY
	CAIN	TE,D2MODE	;  2-WORDS,
	MOVEI	TD,MZC2.	;  USE THAT ROUTINE
	JRST	(TD)		;CALL ONE OF THE ZERO ROUTINES & RETURN
SUBTTL PUT OUT RH, RF, PH & PF ROUTINES

ROUTS:	GETRD
	PUSHJ	PP,GETTAG	;GET TAG FOR
	DPB	CH,RW.GIR	;  'GROUP INDICATE' ROUTINE
	LDB	TA,RW.FGP	;GET LINK TO FIRST GROUP
	JUMPE	TA,ROUT2A	;IF NONE--FORGET THE WHOLE THING

ROUTS1:	PUSHJ	PP,LNKSET	;CONVERT DATAB LINK TO ADDRESS
	LDB	TA,DA.RPW	;GET LINK TO ASSOCIATED RPWTAB ENTRY
	ANDI	TA,LMASKB	;CLEAR CODE BITS
	JUMPE	TA,ROUT2A
	ADD	TA,RPWLOC
	HRRM	TA,CURRPW	;SAVE IT
	PUSH	PP,TA		;SAVE IT

	LDB	TB,RW.TYP	;GET TYPE
	CAIN	TB,RWRH		;IS IT AN 'RH'?
	JRST	ROUTRH
	CAIN	TB,RWRF		;NO--'RF'?
	JRST	ROUTRF
	CAIN	TB,RWPH		;NO--'PH'?
	JRST	ROUTPH
	CAIN	TB,RWPF		;NO--'PF'?
	JRST	ROUTPF

ROUTS2:	POP	PP,TA		;GET ADDRESS OF 01-ITEM AGAIN
	LDB	TA,RW.DAT	;GET DATAB LINK
	PUSHJ	PP,LNKSET
	LDB	TC,DA.FAL	;DOES THIS
	JUMPN	TC,ROUT2A	;  ITEM
	LDB	TA,DA.POP	;  HAVE A
	JUMPN	TA,ROUTS1	;  BROTHER?
ROUT2A:	GETRD
	LDB	TE,RW.PHR	;IF THERE IS ALREADY A PH ROUTINE,
	JUMPN	TE,ROUT2C	;  WE ARE DONE
	PUSHJ	PP,GETTAG	;THERE ISN'T--GET TAG FOR DUMMY ROUTINE
	DPB	CH,RW.PHR
	PUSHJ	PP,PUTTAG	;PASS IT TO ASSEMBLER

ROUT2B:	LDB	CH,RW.PC	;GENERATE
	ANDI	CH,LMASKB	;  <AOS PAGE-COUNTER>
	IORI	CH,AS.DAT	;*
	HRLI	CH,AOS.		;*
	PUSHJ	PP,PUTASY	;*

	LDB	CH,RW.GIR	;GENERATE
	HRLI	CH,JRST.	;  <JRST GI-ROUTINE>
	JRST	PUTASY

ROUT2C:	POPJ	PP,		;WE ARE DONE
ROUTRH:	SKIPA	TB,RW.RHR
ROUTRF:	MOVE	TB,RW.RFR
	JRST	ROUTS3

ROUTPF:	MOVE	TB,RW.PFR

ROUTS3:	PUSHJ	PP,ROUTSX
	MOVSI	CH,POPJ.+AC17	;GENERATE
	PUSHJ	PP,PUTASY	;  <POPJ 17,>
	JRST	ROUTS2

ROUTPH:	MOVE	TB,RW.PHR
	PUSHJ	PP,ROUTSX
	GETRD
	PUSHJ	PP,ROUT2B
	JRST	ROUTS2

ROUTSX:	GETRD
	LDB	TC,TB		;IF THERE IS A ROUTINE OF THIS TYPE,
	JUMPN	TC,ROUTSE	;  IT IS AN ERROR
	PUSHJ	PP,GETTAG	;THERE ISN'T--GET A TAG FOR THIS ONE
	DPB	CH,TB		;SAVE IT
	PUSHJ	PP,PUTTAG
	MOVEI	TE,LINE.H	;SET UP
	MOVEM	TE,RWSAV7	;  FOR 'LINE.X' CALL
	JRST	WRIGRP

ROUTSE:	MOVEI	DW,^D354
	JRST	RWERA
SUBTTL BUILD 'A' AND 'B' PARAMETERS FOR A CONTROL IDENTIFIER

;'A' IS CONTROL ID ITSELF, 'B' IS THAT %PARAM INTO WHICH
;CONTROL ID IS SAVED AT RUN-TIME.

BLDPAR:	SWOFF	FEOFF1		;TURN OFF MOST FLAGS
	HLRZ	TA,@RWSAV2	;GET LINK TO DATAB
	JUMPE	TA,BLDP4	;IF ZERO--FORGET IT

	MOVE	TB,EOPLOC	;CREATE OPERAND
	MOVEM	TA,2(TB)
	PUSHJ	PP,LNKSET	;GET DATAB ADDRESS
	MOVEM	TA,CURDAT	;SAVE
	LDB	TE,DA.LNC	;GET LN&CP
	MOVEM	TE,1(TB)

	MOVEI	TC,1(TB)
	MOVEM	TC,CUREOP
	MOVSM	TC,OPERND
	HRRM	TC,OPERND
	PUSHJ	PP,SETOPA

	MOVE	TE,[XWD EBASEA,EBASEB];COPY PARAMETERS TO 'B'
	BLT	TE,EBASBX

	TSWT	FANUM		;SET NUMERIC
	JRST	BLDP2		;  FLAG IF
	SWON	FBNUM		;  NECESSARY

	HRRZ	TD,EMODEA	;IS IT
	CAILE	TD,DSMODE	;  DISPLAY?
	JRST	BLDP1		;NO
	MOVEI	TD,D1MODE	;YES--ASSUME ONE WORD
	MOVE	TE,ESIZEA	;IF IT IS
	CAILE	TE,^D  ACTUALLY TWO WORDS,
	MOVEI	TD,D2MODE	;  RESET MODE
	MOVEM	TD,EMODEB

BLDP1:	MOVEI	TE,1		;AGAIN, ASSUME 1 WORD
	CAIN	TD,D2MODE	;  BUT IF TWO,
	MOVEI	TE,2		;  RESERVE 2 WORDS
	JRST	BLDP3
;BREAK ITEM IS NON-NUMERIC

BLDP2:	SWOFF	FBNUM		;TURN OFF 'NUMERIC' FLAG
	MOVE	TA,CURDAT
	MOVE	TE,ESIZEA

	LDB	TD,DA.EDT	;IF ITEM IS
	SKIPE	TD		;  EDITED,
	LDB	TE,DA.EXS	;  USE EXTERNAL SIZE
	MOVEM	TE,ESIZEA
	MOVEM	TE,ESIZEB

	HRRZ	TC,EMODEA	;GET MODE
	IDIV	TE,BYTE.W(TC)	;COMPUTE NUMBER OF
	SKIPE	TD		;  WORDS NECESSARY TO
	ADDI	TE,1		;  HOLD ITEM

BLDP3:	MOVE	TD,[XWD ^D36,AS.MSC]
	MOVEM	TD,EBASEB
	AOS	(PP)

BLDP4:	POPJ	PP,
SUBTTL GENERATE CODE TO WRITE OUT ALL LINES FOR A GROUP

WRIGRP:	PUSHJ	PP,FINDLG	;FIND LARGEST PRINT RECORD
	POPJ	PP,		;TROUBLE--QUIT

	SETOM	RPWLIN		;NO 'LINE INTEGER' YET

	SETZM	RWSAV4		;CLEAR COLUMN NUMBER
	MOVE	TA,CURRPW	;GET ADDRESS OF THIS ITEM
	LDB	CH,RW.USE	;IF
	JUMPE	CH,WRG00B	;  THERE
	ANDI	CH,LMASKB	;  IS
	IORI	CH,AS.TAG	;  A
	HRLI	CH,EPJPP	;  'USE' PROCEDURE,
	PUSHJ	PP,PUTASY	;  GENERATE <PUSHJ PP,%TAG-FOR-USE>

WRG00B:	LDB	TE,RW.DAT	;SAVE DATAB LINK TO
	HRLZM	TE,RWSAV8	;  01-LEVEL ITEM

	LDB	TE,RW.NLC	;GET 'NEXT GROUP' CODE
	MOVSM	TE,RWSAV3
	LDB	TE,RW.NXT	;AND 'NEXT GROUP' INTEGER
	HRRM	TE,RWSAV3

	LDB	TE,RW.LCD	;IF THERE IS
	JUMPN	TE,WRG00A	;  NO LINE CODE,
	SKIPL	RWSAV7		;  AND THIS IS NOT REPORT-NAME GENERATION,
	PUSHJ	PP,WRIG45	;  SET PRINT LINE TO SPACES
	MOVE	TA,CURRPW

WRG00A:	LDB	TA,RW.DAT	;GET DATAB LINK FOR THIS ITEM
WRIG00:	PUSHJ	PP,LNKSET	;CONVERT TO ABSOLUTE

WRIG01:	MOVEM	TA,CURDAT	;SAVE ADDRESS OF DATAB ENTRY
	LDB	TA,DA.RPW
	ANDI	TA,LMASKB
	ADD	TA,RPWLOC
	HRRM	TA,CURRPW

	LDB	TB,RW.LCD	;GET LINE CODE
	JUMPE	TB,WRIG06	;IF NONE--NO WRITING NOW
	CAIE	TB,RWLINT	;IS IT 'LINE IS INTEGER'?
	JRST	WRIG1B		;NO
	LDB	TE,RW.LIN	;YES--IS THAT
	CAMN	TE,RPWLIN	;  INTEGER SAME AS LAST ONE?
	JRST	WRIG06		;YES--PRETEND THERE IS NO 'LINE' CLAUSE
	MOVEM	TE,RPWLIN	;SAVE THIS INTEGER

WRIG1B:	SKIPL	RWSAV7		;IF GENERATING 'RD'
	SKIPN	RWSAV4		;  OR LINE IS EMPTY
	JRST	WRIG02		;  DON'T WRITE LINE

	PUSHJ	PP,WRIG40	;YES--WRITE OUT CURRENT LINE
	MOVEI	CH,0		;WRITE OUT 'LINES TO SKIP'
	PUSHJ	PP,PUTASY
WRIG02:	SETZM	RWSAV4		;RESET COLUMN NUMBER
	MOVE	TA,CURRPW	;*
	LDB	CH,RW.LIN	;*
	LDB	TB,RW.LCD	;*
	PUSHJ	PP,WRIG50	;PUT OUT 'LINE.X' CODE

	PUSHJ	PP,WRIG45	;SET PRINT LINE TO SPACES

;NEW LINE IS NOW SET UP

WRIG06:	MOVE	TA,CURDAT	;IF THIS
	LDB	TB,DA.SON	;  ITEM IS ELEMENTARY,
	JUMPE	TB,WRIG07	;  PROCESS IT
	MOVE	TA,TB		;IT ISN'T, GO TO SON
	JRST	WRIG00

;WE HAVE AN ELEMENTARY ITEM

WRIG07:	PUSHJ	PP,WRIG20	;GENERATE MOVE TO THIS ITEM
	SKIPGE	RWSAV7		;IF WE ARE GENERATING 'RD'
	JRST	WRIG09		;  DON'T WRITE
	MOVE	TA,CURRPW	;GET BACK TO ITEM
	MOVE	TE,[XWD ESAVRW,EBASEB] ;GET PRINTER PARAMETERS
	BLT	TE,EBASBX
	LDB	TB,RW.COL	;ANY COLUMN NUMBER?
	SOJL	TB,WRIG09
;MOVE ITEM TO PRINT LINE

	HRRZ	TE,CURMNE	;GET ADDRESS OF 'CODE' ENTRY
	JUMPE	TE,WRIG08	;IF ZERO, NO CODE
	HRRZ	TE,1(TE)	;ADD SIZE OF CODE TO
	ADD	TB,TE		;  'B' INCREMENT
WRIG08:	MOVEM	TB,EINCRB

	MOVE	TA,CURDAT
	LDB	TE,DA.SGN	;IF
	SKIPE	TE		;  ITEM IS SIGNED,
	SWONS	FASIGN		;  SET FLAG,
	SWOFF	FASIGN		;  ELSE CLEAR FLAG

	LDB	TE,DA.EXS
	MOVEM	TE,ESIZEA
	ADD	TE,EINCRB	;WILL ITEM FIT IN
	CAMLE	TE,ESIZEB	;  PRINT-LINE?
	JRST	WRIG10		;NO--ERROR
	MOVEM	TE,RWSAV4	;YES--THAT IS LAST COLUMN SO FAR

	MOVE	TE,ESIZEA	;SIZE OF 'B' IS
	MOVEM	TE,ESIZEB	;  SIZE OF 'A'
	SETZM	EDPLA		;NO
	SETZM	EDPLB		;  DECIMAL PLACES
	LDB	TE,DA.RES	;SET RESIDUE
	HRLM	TE,ERESA
	LDB	TE,DA.USG	;SET
	SUBI	TE,1		;  MODE
	MOVEM	TE,EMODEA
	SETZM	EINCRA

	SUB	TA,DATLOC
	ANDI	TA,LMASKB
	IORI	TA,AS.DAT
	HRRM	TA,EBASEA

	MOVE	TD,EINCRB
	MOVE	TE,EMODEB	;GET CORRECT OUTPUT MODE
	IDIV	TD,BYTE.W(TE)
	MOVEM	TD,EINCRB
	IMUL	TC,BYTE.S(TE)
	MOVNS	TC
	ADDI	TC,^D36
	HRLM	TC,ERESB

	MOVE	TE,[XWD EBASEA,ESAVEB]; SAVE 'A' PARAMETERS
	BLT	TE,ESAVBX
	SWOFF	FANUM!FBNUM!FASUB!FBSUB; TURN OFF A FEW FLAGS
	PUSHJ	PP,MXX.	;GENERATE MOVE

	MOVE	TA,CURRPW	;IF THIS IS
	LDB	TE,RW.GPI	;  NOT GROUP-INDICATE
	JUMPE	TE,WRIG09	;  WE ARE DONE

	MOVE	TE,[XWD ESAVEB,EBASEB]; RESTORE 'A' TO BE 'B'
	BLT	TE,EBASBX
	MOVE	TE,EMODEB	;CALL APPROPRIATE
	PUSHJ	PP,@MSX.(TE)	;  SPACE-FILL ROUTINE
;ITEM HAS BEEN MOVED--GO TO NEXT ITEM

WRIG09:	PUSHJ	PP,NXTDAT	;GET NEXT DATA ITEM
	JRST	WRIG9A		;NO MORE--DONE

	LDB	TE,DA.LVL	;IS IT
	CAIE	TE,01		;  01-LEVEL?
	JRST	WRIG01		;NO--LOOP

WRIG9A:	SKIPGE	RWSAV7		;IF WE ARE GENERATING 'RD'
	POPJ	PP,		;  NO WRITING
	SKIPN	RWSAV4		;ANYTHING IN LINE?
	JRST	WRIG9B		;NO--JUST ADVANCE

	PUSHJ	PP,WRIG40	;YES--WRITE THAT FINAL LINE
	HLRZ	TB,RWSAV3	;GET 'NEXT GROUP' CODE
	CAIN	TB,RWLPLS	;IS IT 'PLUS INTEGER'?
	JRST	WRIG9C		;YES
	MOVEI	CH,0		;NO--SET 'ADVANCE 0 LINES'
	PUSHJ	PP,PUTASY

WRIG9B:	SKIPN	CH,RWSAV3
	POPJ	PP,
	HLRZ	TB,CH
	CAIE	TB,RWLNXT
	JRST	WRIG50
	JRST	WRIG9E

WRIG9C:	HRRZ	CH,RWSAV3	;SET 'ADVANCE N LINES'
	PUSHJ	PP,PUTASY
	HRLI	CH,MOVEI.	;GENERATE
	PUSHJ	PP,PUTASY	;  <MOVEI. 0,<LINES TO ADVANCE>>

	GETRD
	LDB	CH,RW.LC	;GENERATE
	ANDI	CH,TM.DAT	;  <ADDM 0,LINE-COUNTER>
	IORI	CH,AS.DAT	;*
	HRLI	CH,ADDM.	;*
	JRST	PUTASY
;'NEXT GROUP IS NEXT PAGE'

;IF PH,PF,RH OR RF SIMPLY SKIP TO TOP-OF-FORM

WRIG9E:	MOVE	TA,CURRPW
	LDB	TE,RW.TYP
	CAIE	TE,RWPH
	CAIN	TE,RWPF
	JRST	WRIG9G
	CAIE	TE,RWRH
	CAIN	TE,RWRF
	JRST	WRIG9G

;CALL PAGE-FOOTING ROUTINE

	GETRD
	LDB	CH,RW.PFR
	JUMPE	CH,WRIG9F
	HRLI	CH,EPJPP
	PUSHJ	PP,PUTASY

;CALL PAGE-HEADING ROUTINE

WRIG9F:	LDB	CH,RW.PHR
	JUMPE	CH,WRIG9G
	HRLI	CH,EPJPP
	JRST	PUTASY

WRIG9G:	GETRD
	LDB	CH,RW.LC	;GENERATE
	ANDI	CH,TM.DAT	;  <AOS LINE-COUNTER>
	IORI	CH,AS.DAT	;  TO INSURE THAT
	HRLI	CH,AOS.		;  LINE-COUNTER IS
	PUSHJ	PP,PUTASY	;  ALREADY '1'

	MOVE	CH,[XWD MOVEI.+AC15,1]
	PUSHJ	PP,PUTASY

	LDB	CH,RW.RWT
	HRLI	CH,MOVEI.+AC16
	PUSHJ	PP,PUTASY
	MOVEI	CH,LINE.H
	JRST	WRIG56

;ERROR--ITEM WILL NOT FIT IN PRINT-LINE

WRIG10:	MOVE	TA,CURDAT
	LDB	LN,DA.LN
	LDB	CP,DA.CP
	MOVEI	DW,^D360
	PUSHJ	PP,FATAL
	JRST	WRIG09
;GENERATE CODE TO MOVE SOMETHING INTO AN ITEM

WRIG20:	MOVE	TA,CURRPW
	LDB	TB,RW.SCD	;IS IT
	CAIN	TB,RWSUM	;  SUM?
	JRST	WRIG37		;YES
	CAIE	TB,RWSORC	;NO--IS IT SOURCE?
	POPJ	PP,		;NO

;GENERATE CODE FOR 'SOURCE'

WRIG30:	LDB	TE,RW.GPI	;IS IT
	JUMPE	TE,WRIG31	;  'GROUP INDICATE'?
	POPJ	PP,		;YES--FORGET IT

WRIG31:	LDB	TE,RW.SLK	;NO--GET LINK
	MOVE	EACA,EOPLOC
	MOVEM	TE,2(EACA)
	MOVE	TA,CURRPW
	LDB	TE,RW.DAT
	MOVEM	TE,4(EACA)

WRIG33:	LDB	TA,RW.DAT	;GET DATAB LINK
	PUSHJ	PP,LNKSET
	LDB	TE,DA.LNC	;GET LN&CP OF DATAB ITEM
	MOVEM	TE,1(EACA)
	MOVEM	TE,3(EACA)

	HRRZ	TA,2(EACA)	;GET PTR TO SOURCE
	PUSHJ	PP,LNKSET
	LDB	TB,DA.LKS##	;IN LINKAGE SECT?
	JUMPE	TB,WRIG32	;NO
	MOVSI	TB,400		;SET GENFIL-TYPE LKS FLAG
	IORM	TB,1(EACA)

WRIG32:	ADD	EACA,[XWD 4,4]
	MOVEM	EACA,EOPNXT
	PUSHJ	PP,MOVGEN	;GENERATE A MOVE

	MOVE	TA,CURRPW	;IS THIS ITEM
	LDB	TE,RW.TYP	;  IN A
	CAIE	TE,RWCF		;  CONTROL-FOOTING GROUP?
	CAIN	TE,RWDE		;NO--DETAIL?
	JRST	WRIG34		;YES--MAYBE SUMMING NEEDED
	POPJ	PP,		;NO

WRIG34:	LDB	TA,RW.SLK	;GET SOURCE OR SUM LINK
	HRRM	TA,RWSAV8	;SAVE IT
	PUSHJ	PP,LNKSET	;CONVERT TO ADDRESS

	LDB	TE,DA.RBS	;IS IT REFERENCED BY SUM?
	SKIPN	TE
	POPJ	PP,		;NO
	JRST	SUMIT		;YES--GO DO SUMMING
;ITEM TO BE PRESENTED IS A 'SUM'

WRIG37:	LDB	TE,RW.TYP	;IS IT IN
	CAIN	TE,RWCF		;  A CONTROL-FOOTING GROUP?
	JRST	WRIG30		;YES--OK
	MOVEI	DW,^D363	;NO--ERROR
	JRST	RWERA1		;PUT OUT DIAG AND RETURN
;WRITE OUT THE CURRENT LINE

WRIG40:	HLRZ	CH,CURFIL	;GENERATE <WADV. FILTAB>
	ANDI	CH,LMASKS
	IORI	CH,AS.FIL
	HRLI	CH,WADV.
	PUSHJ	PP,SETUUO
	PUSHJ	PP,PUTASY

	MOVE	CH,[XWD AS.XWD,1];PUT OUT FIRST HALF OF THE 'WADV.' PARAMETER
	PUSHJ	PP,PUTASN
	MOVS	CH,RWSAV4
	LSH	CH,6
	TLO	CH,20
	HRRI	CH,AS.CNB
	JRST	PUTASN

;SET PRINT-LINE TO SPACES

WRIG45:	SKIPGE	RWSAV7		;IF WE ARE GENERATING 'RD',
	POPJ	PP,		;  NO NEED FOR CODE
	MOVE	TE,[XWD ESAVRW,EBASEB];SET 'B' TO BE PRINT-LINE
	BLT	TE,EBASBX

	HRRZ	TA,CURMNE	;GET ADDRESS OF 'CODE' ENTRY
	JUMPE	TA,WRIG46	;IF ZERO, NO CODE

	MOVE	TD,[XWD ^D36,AS.MSC]	;SET UP 'A'
	MOVEM	TD,EBASEA	;  TO BE
	MOVE	TD,2(TA)	;  'CODE' LITERAL
	HRRZM	TD,EINCRA
	HRRZ	TD,1(TA)
	MOVEM	TD,ESIZEA
	SETZM	EDPLA
	MOVEI	TD,D6MODE
	MOVEM	TD,EMODEA
	SWOFF	FASUB!FANUM!FASIGN
	JRST	MXX.		;MOVE 'CODE' TO PRINT LINE

WRIG46:	MOVE	TE,ESIZEB	;SET SIZE
	MOVEM	TE,ESIZEZ	;  TO SIZE OF PRINT-LINE
	MOVE	TE,EMODEB	;CALL APPROPRIATE
	JRST	@MSX.(TE)	;  SPACING ROUTINE
;GENERATE 'LINE.X' CODE

WRIG50:	SKIPGE	RWSAV7		;IF WE ARE GENERATING 'RD',
	POPJ	PP,		;  NO NEED FOR CODE
	CAIN	TB,RWLNXT	;IF NEXT-PAGE,
	MOVEI	CH,1		;  PRETEND IT IS '1'
	HRLI	CH,MOVEI.+AC15
	PUSHJ	PP,PUTASY

	CAIE	TB,RWLPLS	;IS IT 'PLUS INTEGER'?
	JRST	WRIG55		;NO
	GETRD
	LDB	CH,RW.LC	;GET ADDRESS OF LINE-COUNTER
	ANDI	CH,LMASKB	;CONVERT TO
	IORI	CH,AS.DAT	;  DATAB ASYFIL LINK
	HRLI	CH,AC15+AD##	;GENERATE
	PUSHJ	PP,PUTASY	;  <ADD 15,LINE-COUNTER>

WRIG55:	GETRD
	LDB	CH,RW.RWT	;GET ADDRESS OF RUN-TIME RPWTAB
	HRLI	CH,MOVEI.+AC16	;GENERATE
	PUSHJ	PP,PUTASY	;  <MOVEI 16,RPWTAB>

	MOVE	CH,RWSAV7	;GET 'LINE.X'

WRIG56:	TSWT	FAS3		;ARE WE IN NON-RESIDENT SEGMENT?
	JRST	WRIG57		;NO
	MOVE	TE,CH		;YES--
	ANDI	TE,LMASKS	;  SET
	ADD	TE,EXTLOC	;  FLAG
	MOVSI	TD,1B18		;  IN
	IORM	TD,1(TE)	;  EXTAB

WRIG57:	HRLI	CH,EPJPP	;GENERATE <PUSHJ 17,LINE.X>
	JRST	PUTASY		;  AND RETURN
SUBTTL GENERATE SUMS WHICH REFERENCE CURRENT ITEM

;ENTER WITH LINK TO SUM IDENTIFIER IN RH OF RWSAV8,
;	AND DATAB LINK TO REPORT-GROUP IN LH OF RWSAV8

SUMIT:	MOVE	TA,CURRPW	;GET TO
	LDB	TA,RW.DAT	;  CF OR DE
	PUSHJ	PP,LNKSET	;  DATAB ENTRY
	LDB	TB,DA.LNC	;SAVE LN&CP FOR LATER USE
	MOVE	EACA,EOPLOC	;*
	MOVEM	TB,1(EACA)	;*
	MOVEM	EACA,EOPNXT	;SET 'EOPTAB IS EMPTY'

	GETRD
	LDB	TE,RW.NCI	;ANY CONTROL IDENTIFIERS?
	JUMPE	TE,SUMIT9	;IF NOT--QUIT
	PUSH	PP,CURRPW	;SAVE
	PUSH	PP,RWSAV1	;  SOME
	PUSH	PP,RWSAV2	;  STUFF

	MOVEM	TE,RWSAV1	;SAVE NUMBER OF CONTROL-ID'S
	LDB	TD,RW.CID	;COMPUTE
	ANDI	TD,LMASKB	;  ADDRESS OF
	ADD	TD,RPWLOC	;  FIRST CONTROL-ID PARAMETER
	HRRZM	TD,RWSAV2	;  AND SAVE IT

SUMIT1:	HRRZ	TA,1(TD)	;GET LINK TO CF GROUP
SUMIT3:	ANDI	TA,LMASKB
	JUMPE	TA,SUMIT7	;IF NONE, NO CF

	ADD	TA,RPWLOC	;  ASSOCIATED RPWTAB ENTRY
	HRRM	TA,CURRPW	;SAVE IT

	LDB	TE,RW.SCD	;DOES THAT ITEM
	CAIE	TE,RWSUM	;  HAVE A SUM CLAUSE?
	JRST	SUMIT6		;NO
	LDB	TE,RW.NSI	;YES--GET NUMBER OF SUM IDENTIFIERS
	JUMPE	TE,SUMIT6	;IF NONE--FORGET IT
	MOVEM	TE,RWSAV6	;SAVE IT
	HRRZ	TA,CURRPW	;COMPUTE BYTE-POINTER TO
	ADD	TA,[POINT 18,5]	;  SUM-IDENTIFIER LINKS
	MOVEM	TA,RWSAV5	;SAVE IT
SUMIT4:	ILDB	TE,RWSAV5	;GET LINK TO SUM-IDENTIFIER
	JUMPE	TE,SUMIT5	;IF ZERO, FORGET IT
	HRRZ	TD,RWSAV8	;IF NOT THE
	CAIE	TE,(TD)		;  ONE WE ARE AFTER,
	JRST	SUMIT5		;  GO TO NEXT IDENTIFIER

	MOVE	TA,CURRPW	;IF CLAUSE IS
	LDB	TE,RW.UPN	;  'SUM UPON',
	JUMPE	TE,SMIT4A	;  CODE IS GENERATED ONLY IF
	HLRZ	TD,RWSAV8	;  WE ARE WORKING
	CAIE	TE,(TD)		;  ON CORRECT DETAIL GROUP
	JRST	SUMIT5		;NO CODE GENERATED

SMIT4A:	MOVE	EACA,EOPLOC	;IS EOPTAB
	CAME	EACA,EOPNXT	;  EMPTY?
	JRST	SMIT4B		;NO--THERE MUST BE SUM RESULT OPS ALREADY

	HRRZ	TA,RWSAV8	;YES--SET UP
	MOVEM	TA,2(EACA)	;  EOPTAB FOR 'ADDTGN'
	PUSHJ	PP,LNKSET	;IF ITEM IS
	LDB	TE,DA.CLA	;  NOT
	CAIE	TE,2		;  NUMERIC
	JRST	SMIT10		;  OR
	LDB	TE,DA.EDT	;  IT IS
	JUMPN	TE,SMIT10	;  EDITED, ERROR

	ADD	EACA,[XWD 2,2]	;GENERATE
	MOVEM	EACA,EOPNXT	;  THE
	PUSHJ	PP,ADDTGN	;  FIRST HALF OF 'ADD TO'

	MOVE	EACA,EOPLOC
	JRST	SMIT4C

SMIT4B:	MOVE	EACA,EOPNXT
	MOVE	TE,-1(EACA)	;GET LN,CP FROM PREVIOUS OPERAND
	MOVEM	TE,1(EACA)	;PUT IT IN THIS OPERAND

SMIT4C:	MOVE	TA,CURRPW
	LDB	TA,RW.SLK
	MOVEM	TA,2(EACA)

	ADD	EACA,[XWD 2,2]
	MOVEM	EACA,EOPNXT
;STEP TO NEXT IDENTIFIER FOR THIS SUM

SUMIT5:	SOSLE	RWSAV6		;IF MORE SUM ID'S,
	JRST	SUMIT4		;  LOOP

SUMIT6:	PUSHJ	PP,NXTDAT	;GO TO NEXT DATAB ITEM
	JRST	SUMIT7			;NO MORE--WE ARE DONE WITH GROUP
	LDB	TE,DA.LVL	;IF THE NEXT IS
	CAIN	TE,01		;  01-LEVEL,
	JRST	SUMIT7		;  WE ARE DONE WITH GROUP

	LDB	TA,DA.RPW	;NOT DONE--GET ASSOCIATED RPWTAB ENTRY
	JRST	SUMIT3		;  AND LOOP

;STEP TO NEXT CONTROL PARAMETER

SUMIT7:	SOSG	RWSAV1		;ANY MORE CONTROL-ID PARAMETERS?
	JRST	SUMIT8		;NO--QUIT
	MOVEI	TD,EXTRAS	;YES--BUMP DOWN TO
	ADDB	TD,RWSAV2	;  NEXT AND
	JRST	SUMIT1		;  DO THAT CF GROUP

SUMIT8:	MOVE	EACA,EOPNXT	;IS THERE
	CAME	EACA,EOPLOC	;  ANYTHING IN EOPTAB?
	PUSHJ	PP,RESGEN	;YES--GENERATE 'RESULT'

	POP	PP,RWSAV2	;RESTORE
	POP	PP,RWSAV1	;  SOME
	POP	PP,CURRPW	;  LOCATIONS
SUMIT9:	POPJ	PP,		;GO AWAY

;ERROR--ITEM TO BE SUMMED IS NOT NUMERIC

SMIT10:	MOVEI	DW,^D362
	PUSHJ	PP,RWERA
	JRST	SUMIT5
SUBTTL FIND LARGEST PRINTING RECORD FOR REPORT

;SET UP 'ESAVRW' WITH PARAMETERS SPECIFYING LARGEST RECORD OF
;	PRINTING FILE

FINDLG:	GETRD
	LDB	TA,RW.FIL	;GET LARGEST RECORD FOR FILE, IN
	JUMPE	TA,FNDLGE	;  OPERAND FORMAT, INTO
	MOVSM	TA,CURFIL
	PUSHJ	PP,LNKSET
	HRRM	TA,CURFIL
	PUSHJ	PP,LARGE	;  'EINTO'

	MOVEI	LN,ESAVRW
	MOVEI	TC,EINTO
	SETZM	EINTO		;CLEAN UP, SO ENDIFGEN WON'T BE CONFUSED
	PUSHJ	PP,SETOPN

	TSWT	FERROR		;IF ERROR,
	AOS	(PP)		;  DON'T BUMP RETURN

FNDLGE:	POPJ	PP,
SUBTTL SKIP DOWN TO NEXT DATAB ITEM

;EXIT TO CALL+1 IF NO MORE DATAB ITEMS
;EXIT TO CALL+2 IF ANOTHER FOUND, WITH DATAB ADDRESS IN 'TA'

NXTDAT:	HRRZ	TA,CURRPW	;GET TO RPW ENTRY
	LDB	TA,RW.DAT	;GET TO
	PUSHJ	PP,LNKSET	;  CURRENT DATAB ENTRY

NXDAT1:	LDB	TE,DA.SON	;IF HE HAS A SON,
	JUMPN	TE,NXDAT3	;  HE IS WHAT WE WANT

NXDAT2:	LDB	TE,DA.FAL	;IF THERE IS A BROTHER,
	JUMPE	TE,NXDAT4	;  GO TO HIM

	LDB	TA,DA.POP	;GET FATHER LINK
	LDB	TE,LNKCOD	;GET TABLE TYPE
	CAIE	TE,TB.DAT	;IF NOT DATAB,
	POPJ	PP,		;  QUIT
	PUSHJ	PP,LNKSET	;GET ADDRESS AND
	JRST	NXDAT2		;  TRY HIM

NXDAT3:	SKIPA	TA,TE		;TA_SON LINK
NXDAT4:	LDB	TA,DA.BRO	;TA_BROTHER LINK
	JUMPE	TA,NXDAT5	;IF ZERO--EXIT TO CALL+1

	AOS	(PP)		;WE HAVE NEXT ITEM
	JRST	LNKSET		;CONVERT TO ADDRESS AND EXIT TO CALL+2
NXDAT5:	POPJ	PP,
SUBTTL SET UP 'CURMNE' TO POINT TO 'CODE'

SETCOD:	GETRD
	LDB	TA,RW.COD	;GET LINK TO MNETAB ENTRY FOR 'CODE'
	SETZM	CURMNE		;CLEAR 'CURMNE'
	JUMPE	TA,SETCD5	;IF ZERO, NO CODE

	PUSHJ	PP,LNKSET	;GET ADDRESS OF MNETAB ENTRY
	HRRZM	TA,CURMNE

	HLRZ	TE,2(TA)	;IF ALREADY SET UP,
	JUMPE	TE,SETCD5	;  NO ACTION NEEDED

	HRRZ	TC,1(TA)	;GET SIZE OF CODE VALUE
	JUMPN	TC,SETCD1	;IF ZERO,
	SETZM	CURMNE		;  CLEAR OUT
	GETRD
	DPB	TC,RW.COD	;  LINK
	POPJ	PP,		;  AND FORGET THE WHOLE THING

;GENERATE LITERAL FOR CODE VALUE

SETCD1:	PUSH	PP,TC		;SAVE BYTE SIZE OF LITERAL
	ADDI	TC,5		;CONVERT
	IDIVI	TC,6		;  TO WORDS
	EXCH	TC,0(PP)	;  AND SAVE THAT

	MOVE	TA,0(PP)	;PUT OUT
	HRLI	TA,SIXLIT	;  SIXBIT LITERAL
	PUSHJ	PP,STASHL	;  HEADER

	HRRZ	TB,CURMNE	;BUILD BYTE-POINTER TO
	ADD	TB,[POINT 7,2]	;  LITERAL VALUE

SETCD2:	MOVEI	TA,0		;CLEAR TA
	MOVE	TE,[POINT 6,TA]

SETCD3:	ILDB	CH,TB		;GET LITERAL BYTE
	CAIG	CH,137		;IF IT IS
	CAIGE	CH,40		;  OUTSIDE SIXBIT RANGE,
	JRST	SETCD6		;  WE NEED SPECIAL PROCESSING
	SUBI	CH,40		;CONVERT TO SIXBIT
SETC3A:	IDPB	CH,TE		;STASH IN TA
	TLNE	TE,770000	;IS TA FULL?
	SOJG	TC,SETCD3	;NO--LOOP
	PUSHJ	PP,STASHL	;YES--PUT TA IN LITAB
	SOJG	TC,SETCD2	;LOOP
;PUT OUT CODE VALUE (CONT'D)

SETCD4:	MOVE	TB,CURMNE	;PUT
	MOVE	TE,ELITPC	;  ADDRESS
	IORI	TE,AS.LIT	;  OF LITERAL
	HRRZM	TE,2(TB)	;  INTO MNETAB

	POP	PP,TC		;GET WORD SIZE BACK
	ADDM	TC,ELITPC	;BUMP LITERAL PC

SETCD5:	POPJ	PP,

;BYTE IS OUTSIDE SIXBIT RANGE

SETCD6:	CAIG	CH,"Z"+40	;IS IT
	CAIGE	CH,"A"+40	;  LOWER-CASE?
	JRST	SETCD7		;NO--TROUBLE
	SUBI	CH,100		;YES--CONVERT TO SIXBIT UPPER-CASE
	JRST	SETC3A		;  AND USE THAT

SETCD7:	PUSH	PP,TA
	PUSH	PP,TE
	GETRD
	MOVEI	DW,^D387
	LDB	LN,RW.LN
	LDB	CP,RW.CP
	PUSHJ	PP,FATAL
	POP	PP,TE
	POP	PP,TA
	MOVEI	CH,"\"-40
	JRST	SETC3A
SUBTTL PUT OUT AN ERROR DIAGNOSTIC

;ENTER WITH DIAG NUMBER IN 'DW'

RWERA:	MOVE	TA,CURRPW
RWERA1:	LDB	TA,RW.DAT
	PUSHJ	PP,LNKSET
	LDB	CP,DA.CP
	LDB	LN,DA.LN
	JRST	FATAL
	EXTRAS==3	;NUMBER OF WORDS PER CONTROL ID PARAMETER
	EQTEST==1B29	;'EQUAL' FLAG IN 'IF' OPERAND
	AC15==15B30
	AC16==16B30
	AC17==17B30

EXTERNAL RWSAV1,RWSAV2,RWSAV3,RWSAV4,RWSAV5,RWSAV6,RWSAV7,RWSAV8
EXTERNAL RWBRKC,RWMBRK,RPWLIN,LMASKB,LMASKS

EXTERNAL EBASEA,EBASBX,ESIZEA,ESIZEB,EMODEA,EMODEB
EXTERNAL EBASEB,ESAVRW,EINCRA,EINCRB,EINCRX,EMODEX,EDPLX,ESIZEZ
EXTERNAL EDPLA,EDPLB,ERESA,ERESB,ESAVEB,ESAVBX,EBASBX

EXTERNAL EXTLOC,RPWLOC,RPWNXT,CURRPW,FILLOC,CURFIL,DATLOC,DATNXT,CURDAT
EXTERNAL EOPLOC,EOPNXT,CUREOP,LITNXT,CURLIT,CURMNE,EAS1PC,ELITPC
EXTERNAL OPERND,BYTE.W,BYTE.S,OPLINE,EINTO,LNKCOD
EXTERNAL D1MODE,D2MODE,D6MODE,D7MODE,DSMODE

EXTERNAL JRST.,EPJPP,MOVEI.,MOVEM.,SETOM.,POPJ.,AOS.,SOS.,SOSGE.,WADV.,ADDM.
EXTERNAL HRLOI.,LINE.C,LINE.D,LINE.H,LIN.RH

EXTERNAL ASCLIT,SIXLIT

EXTERNAL DA.POP,DA.BRO,DA.LNC,DA.LVL,DA.RES,DA.RPW,DA.SON,DA.USG,DA.EXS
EXTERNAL DA.LN,DA.CP,DA.FAL,DA.CLA,DA.SGN,DA.EDT,DA.RBS

EXTERNAL TB.DAT,TM.DAT

EXTERNAL AS.CNB,AS.DAT,AS.FIL,AS.MSC,AS.PAR,AS.XWD,AS.OCT,AS.TAG
EXTERNAL AS.ASC,AS.LIT

EXTERNAL RW.NAM,RW.SAM,RW.BRO,RW.LN,RW.CP,RW.FIL,RW.FGP,RW.LC,RW.PC
EXTERNAL RW.PHL,RW.CFL,RW.FDE,RW.LDE,RW.PAG,RW.RWT,RW.RHR,RW.RFR
EXTERNAL RW.PHR,RW.PFR,RW.GIR,RW.COD,RW.CID,RW.NCI,RW.BKT,RW.FBT
EXTERNAL RW.RDL,RW.DAT,RW.LCD,RW.NLC,RW.SCD,RW.TYP,RW.NSI,RW.LIN
EXTERNAL RW.COL,RW.NXT,RW.RES,RW.SLK,RW.UPN,RW.GPI,RW.RSF,RW.RSU
EXTERNAL RW.USE

EXTERNAL RWSORC,RWSUM,RWVALU,RWLNXT,RWLINT,RWLPLS
EXTERNAL RWRH,RWPH,RWCH,RWDE,RWCF,RWPF,RWRF

	END
   =n;Iš