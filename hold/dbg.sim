!  IOCSU, SFORWU & CCOMU MUST PRECEDE


GLOBAL %DBG, %STM, %XIT, %PAWS


%DBG


LOCAL %DERR, %DPERR, %RWERR, %SYMERR, %SYMNERR
LOCAL %PUTSYM, %PUTQSYM, %OUTSET, %CURSYM
LOCAL %DEXU,%DSCAN

! ALL GET PROCS LEAVE WITH LASTCH AS (NON-BLANK) TERMINATOR TO WHAT WAS GOT,
! AND LPTR PAST LASTCH
LOCAL %GET.INT, %GET.SYM, %GET.VAR

!  DEFS FOR SYMBOL TABLE

! FOLLOWING APPLY TO ENTRY AT ADDRESS PTR

!  FLAGS IN LH(WD 0)
DEF S.VAR(PTR) AS (^(PTR) BAND 1 SHL 35)
DEF S.COM(PTR) AS (^(PTR) BAND 1 SHL 34)
DEF S.FUN(PTR) AS (^(PTR) BAND 1 SHL 30)
DEF S.SUBR(PTR) AS (^(PTR) BAND 1 SHL 29)
DEF S.SUBD(PTR) AS (^(PTR) BAND 1 SHL 28)
DEF S.PRG(PTR) AS (^(PTR) BAND 1 SHL 23)
DEF S.DUM(PTR) AS (^(PTR) BAND 1 SHL 22)
DEF S.ADJ(PTR) AS (^(PTR) BAND 1 SHL 21)
DEF S.LIB(PTR) AS (^(PTR) BAND 1 SHL 20)
DEF S.ARYB(PTR) AS (^(PTR) BAND 1 SHL 19)
DEF S.LONG(PTR) AS (^(PTR) BAND 1 SHL 18)

DEF S.TYP(PTR) AS (^(PTR) BAND OCT 77.00)
  DEF S.INT  AS 0
  DEF S.REAL AS OCT 4.00
  DEF S.DOUB AS OCT 10.00
  DEF S.CPLX AS OCT 14.00
  DEF S.LGC  AS OCT 1.00
  DEF S.STR  AS OCT 15.00
LOCAL %VTYPA  !TO TRANSFORM S.TYP TO VTYP

DEF S.LEN(PTR) AS (^(PTR) BAND OCT 77)
DEF S.LOC(PTR) AS HW((PTR)+1,1)
  DEF S.SCAP(PTR) AS HW(S.LOC(PTR))
  DEF S.SLOC(PTR) AS HW(S.LOC(PTR),1)
  DEF S.DLOC(PTR) AS HW(S.LOC(PTR),1)   !DUMMY ARRAY BASE
DEF S.NAM(PTR) AS ^((PTR)+2)
DEF S.SNUM(PTR) AS HW((PTR)+1)
DEF INIT.S.MUL(PTR) AS S.MULP _ HWPT((PTR)+4,-1)
DEF NX.S.MUL AS NHWV S.MULP   !FOR I=1 TO S.SNUM(PTR)
DEF S.SIZ(PTR) AS HW((PTR)+3)
DEF S.OFF(PTR) AS HW((PTR)+3,1)

!  ERROR MESSAGES

TABLE NOCONT   ['NOT CONTINUABLE']
TABLE BDCONS   ['ILLEGAL CONSTANT']
TABLE MISCOM   ['MISSING COMMA IN COMPLEX']

! SYMBOL ERRORS:
TABLE UNDEFS   ['UNDEFINED']
TABLE NOTARY   ['NOT AN ARRAY']
TABLE ISARY    ['IS AN ARRAY']
TABLE BADINT   ['NOT INTEGER']
TABLE SUBCNT   ['WRONG NUMBER OF SUBSCRIPTS']
TABLE BOUNDS   ['SUBSCRIPT OUT OF BOUNDS']
TABLE DIMLIT   ['DIMENSIONS EXCEED LIMIT OF 10']
TABLE BDMTCH   ['TYPE DOES NOT MATCH']

TABLE ASSIGN   ['ASSIGNMENTS DONE']

DEF SXPT(ADR) AS [6,6,24]*[36,6,ADR]

FIND PF.DBGD(NLMAX)
DEF PF.CADR(LNUM) AS HW(@PF.DBGD(LNUM),1)

DEF TRCBIT AS 1
DEF BRKBIT AS 2

DEF SUBSMAX AS 10   !?
LOCAL SUBS(SUBSMAX)
LOCAL SYMPTR, SXPTR, VAL, LTTYLEN, S.MULP
LOCAL CRETURN		! RETURN ADDRESS FOR 'CONTINUE'.
LOCAL SYM.TABLE         !CURRENT SYMBOL TABLE PTR
GLOBAL CURLOC    !CURRENT DEBUG LOCATION

LOCAL CHAR, CNT, TEMP, I

LOCAL NCOM:


!  DEBUGGER INITIALIZATION

        SFORW    !EVENTUALLY?
        SYM.TABLE _ 0
        IF PF.CNUM=K.RUN THEN RETURN
        CRETURN _ RETURN
DBCOM:  SETRWP(0,%RWERR); LTTYLEN _ TTYLEN
        CCOM(NCOM)

!  ACCEPT A COMMAND LINE

FIND SG.ED:, JOBSYM, %SFCLSALL

NCOM:	FIXUP _ NCOM; ONALTC
	GETCOM
        IF CMN(PF.CNUM)=0 THEN [SFCLSALL; JOBSYM _ 0; GOSEG(SG.ED,2)]
	DSCAN;  DEXU; INC PF.INTNO
	GO NCOM


!  ERROR HANDLING

LOCAL SETFG   !SPECIAL PRINTOUT FOR SET COMMAND ERRORS
DEF NEWLIN AS PUT(CARRET)

%DERR (MSGADR)

IF SETFG THEN [PRINT(MSGADR); CPERR(%OUTSET)]
NEWLIN; CERR(MSGADR)

END DERR


%RWERR (N, %MSGPROC)
%%DPERR (%MSGPROC)

IF SETFG THEN [MSGPROC; CPERR(%OUTSET)]
NEWLIN; CPERR(%MSGPROC)

END RWERR


%SYMNERR (MSGADR, SYMNAM)

LOCAL %X

CPERR(%X)

%%SYMERR (MSGADR, SYMPTR)

SYMNAM _ S.NAM(SYMPTR); CPERR(%X)

%X

NEWLIN; PUTQSYM(SYMNAM,%PUT); PRINT(MSGADR)
IF SETFG THEN OUTSET
RETURN

END X

END SYMNERR


%VTYPA (S.TYPE)

TABLE S.TYPA(VTYPRNG) [S.INT,S.REAL,S.DOUB,S.CPLX,S.LGC,S.STR]

FOR I _ INT TO STR IF S.TYPE=S.TYPA(I) THEN RETURN I
HALT

END VTYPA


%PUTQSYM (SYMNAM, %PUT)

!  PRINTS SYMBOL NAME SYMNAM IN QUOTES FOLLOWED BY BLANK, USING %PUT.

PUT($"); PUTSYM(SYMNAM,%PUT); PUT($"); PUT($ ); RETURN

END PUTQSYM


%PUTSYM (SYMNAM, %PUT)

!  PRINTS SYMBOL NAME SYMNAM, USING %PUT.

SXPTR _ SXPT(@SYMNAM)
LOOP [REPEAT 6; WHILE CHAR _ NCHV SXPTR#0; PUT(CHAR+OCT 40)]
RETURN

END PUTSYM


%CURSYM

!  RETURNS PTR TO SYMBOL TABLE CORRESPONDING TO CURLOC.
!  WATCH OUT IF CURLOC IS BAD!

DEF HDR.SIZE AS 3
DEF HDR.NAME(X) AS X(0)
DEF HDR.SYM.SIZE(X) AS HW(X+1)
DEF HDR.SYM.CP(X) AS HW(X+1,1)
DEF HDR.CORE.LOC(X) AS HW(X+2,1)

LOCAL SYM.HDR(0:HDR.SIZE-1), T.SYM.HDR(0:HDR.SIZE-1)

LOCAL SYM.SIZE
LOCAL CORE.LOW, CORE.HIGH

LOCAL BLK.ERR:

DEF KL.RB(ELCT,ADR) AS [I _ ADR; REPEAT ELCT [^I _ PF.R; INC I]]

IF SYM.TABLE#0 THEN DO
  IF CORE.LOW<=CURLOC<CORE.HIGH THEN RETURN SYM.TABLE
  RELEASE((SYM.SIZE+130)/131, SYM.TABLE, BLK.ERR)
END

PF.STCP(HW(@PF.BLKD,1))

KL.RB(HDR.SIZE, SYM.HDR)
LOOP DO
  KL.RB(HDR.SIZE, T.SYM.HDR)
  WHILE HDR.CORE.LOC(T.SYM.HDR)<=CURLOC
  MOVE HDR.SIZE FROM T.SYM.HDR TO SYM.HDR
END

SYM.SIZE _ HDR.SYM.SIZE(SYM.HDR)
SYM.TABLE _ BLOCK((SYM.SIZE+130)/131, 0, BLK.ERR)
PF.STCP(HDR.SYM.CP(SYM.HDR))
PF.RB(SYM.SIZE, SYM.TABLE)

RETURN SYM.TABLE

BLK.ERR: EXERR(NOCORE)

END CURSYM


%GET.INT

!  GET INTEGER.  IF SUCCESSFUL, RETURN YES AND SET VAL TO INTEGER.
!  IF FAIL, RETURN NO AND RESET LPTR BEFORE NEXT NON-BLANK CHAR.

LOCAL SGN

VAL _ 0; SGN _ 1
IF NXNSP=$- THEN [SGN _ -1; NXCHAR]
IF NOT($0<=LASTCH<=$9) THEN [BACKSP; RETURN NO]
LOOP DO
  VAL _ VAL*10+LASTCH-$0; WHILE $0<=NXCHAR<=$9
END
VAL *_ SGN; IF SPCH(LASTCH) THEN NXNSP; RETURN YES

END GET.INT


%GET.SYM

!  GET SYMBOL.  IF SUCCESSFUL, RETURN SYMBOL PTR.
!  IF FAIL, TAKE APPROPRIATE ERROR EXIT.

LOCAL %FSYM
LOCAL SYMPTR, SYMNAM

SXPTR _ SXPT(@SYMNAM); SYMNAM _ 0
IF NOT ALPH(NXNSP) THEN DPERR(%PCMDL); I _ 6
LOOP [WHILE DEC I<=0; NCHV SXPTR _ (LASTCH-OCT 40); WHILE ALPH(NXCHAR) OR $0<=LASTCH<=$9]
IF I>=0 THEN WHILE ALPH(NXCHAR) OR $0<=LASTCH<=$9 THEN NULL !CLEAR PAST 6TH
IF NOT FSYM THEN SYMNERR(UNDEFS,SYMNAM)
IF SPCH(LASTCH) THEN NXNSP
RETURN SYMPTR

%FSYM

!  LOOKS UP SYMNAM IN SYMBOL TABLE.  IF FINDS ARRAY ELEMENT
!  OR VARIABLE CORRESPONDING TO SYMNAM, SET SYMPTR ACCORDINGLY
!  AND RETURN YES ELSE RETURN NO.

SYMPTR _ CURSYM
LOOP DO
  WHILE S.VAR(SYMPTR) AND NOT S.ADJ(SYMPTR)
  IF SYMNAM=S.NAM(SYMPTR) THEN RETURN YES
  WHILE ^(SYMPTR +_ S.LEN(SYMPTR))#0
END
RETURN NO

END FSYM

END GET.SYM


%GET.VAR

!  GET VARIABLE/ARRAY ELEMENT WITH CONSTANT OR INTEGER VARIABLE
!  SUBSCRIPTS.  IF SUCCESSFUL, RETURN SYMBOL PTR AND LOCATION.
!  IF FAIL, TAKE APPROPRIATE ERROR EXIT.
!  DISALLOW ARRAY NAME WITHOUT SUBSCRIPTS.

LOCAL SYMPTR, SUBPTR, LOC

SYMPTR _ GET.SYM; LOC _ 0
EIF LASTCH=$( THEN DO
  IF NOT S.ARYB(SYMPTR) THEN SYMERR(NOTARY,SYMPTR)
  I _ 0; INIT.S.MUL(SYMPTR)
  LOOP DO
    IF NOT GET.INT THEN DO
      IF S.ARYB(SUBPTR _ GET.SYM) THEN SYMERR(ISARY,SUBPTR)
      IF S.TYP(SUBPTR)#S.INT THEN SYMERR(BADINT,SUBPTR)
      VAL _ ^(S.LOC(SUBPTR))
    END
    IF INC I>SUBSMAX THEN SYMERR(DIMLIT,SYMPTR)
    SUBS(I) _ VAL
    WHILE LASTCH=$,
    IF I=S.SNUM(SYMPTR) THEN SYMERR(SUBCNT,SYMPTR)
    LOC +_ VAL*NX.S.MUL
  END
  IF LASTCH#$) THEN DPERR(%PCMDL); NXNSP
  IF I#S.SNUM(SYMPTR) THEN SYMERR(SUBCNT,SYMPTR)
  IF NOT(0<=LOC +_ VAL*NX.S.MUL+S.OFF(SYMPTR)<S.SIZ(SYMPTR)) THEN SYMERR(BOUNDS,SYMPTR)
END
FIF S.ARYB(SYMPTR) THEN SYMERR(ISARY,SYMPTR)
RETURN [SYMPTR; LOC+IF S.TYP(SYMPTR)=S.STR THEN S.SLOC(SYMPTR) &
  ELSE IF S.ARYB(SYMPTR) AND S.DUM(SYMPTR) THEN S.DLOC(SYMPTR) &
    ELSE S.LOC(SYMPTR)]

END GET.VAR

%DSCAN

    CSCAN.INIT
    DO PF.CNUM OF CMDCNT

K.NEXT:	DERR(NOTIMP)

K.GO:  K.DEB:  F.ADR

K.BRK: K.TRC: K.NBRK: K.NTRC: K.LBRK: K.LTRC:&
    IF NOT FLST THEN GO EROUT

K.CONT:  K.QUIT:  K.LDEB:  NULL


K.PRNT: K.SET:	RETURN
   
   END
 
    IF NOT FCR THEN PCMDL; RETURN

EROUT:	IF NXNSP#CARRET THEN DERR(BDLRNG) ELSE PCMDL

END DSCAN

%DEXU

LOCAL %SET, %DISPLAY
LOCAL X, J

SETFG _ 0
   DO PF.CNUM OF CMDCNT

K.GO:  K.LDEB:  K.LBRK:  K.LTRC:  DERR(NOTIMP)

K.DEB:	INLIST(1); I.NXLNUM; CURLOC _ PF.CADR(NXLNUM)

K.BRK: K.TRC:		NULL
    X_(IF PF.CNUM=K.BRK THEN BRKBIT ELSE TRCBIT) SHL 24
    INLIST(1)
    REPEAT LSTCNT  ^(PF.CADR(NXLNUM)) BOR_X

FIND %IORESTORE

K.CONT: IF CRETURN=0 THEN CERR(NOCONT)
        IORESTORE; INC PF.INTNO; GO ^CRETURN

K.PRNT: DISPLAY

K.SET:  SET

K.NBRK:	K.NTRC:	NULL
    X_BNOT((IF PF.CNUM=K.NBRK THEN BRKBIT ELSE TRCBIT) SHL 24)
    INLIST(1)
    REPEAT LSTCNT  ^(PF.CADR(NXLNUM)) BAND_X

K.LBRK:	K.LTRC:	NULL			! FOR NOW

K.QUIT: OFFALT; SFCLSALL; QUIT

   END

    RETURN

%SET

LOCAL %GETVAL
LOCAL RLOC, LLOC, ILPTR, SVLPTR, VPTR

SETFG _ 1
ILPTR _ SVLPTR _ LPTR
LOOP DO
  [SYMPTR; LLOC] _ DOUBLE GET.VAR
  IF LASTCH#$= OR NOT($;#NXNSP#CARRET) THEN DPERR(%PCMDL)
  IF ALPH(LASTCH) THEN DO
    BACKSP; [VPTR; RLOC] _ DOUBLE GET.VAR
    IF S.TYP(VPTR)#S.TYP(SYMPTR) THEN SYMERR(BDMTCH,VPTR)
    ^LLOC _ ^RLOC
  END ELSE GETVAL(LLOC,S.TYP(SYMPTR))
  SVLPTR _ LPTR
  WHILE LASTCH=$;
END
IF LASTCH#CARRET THEN DPERR(%PCMDL)
RETURN

%GETVAL (LOC, S.TYPE)

!  USE SFORW TO SCAN & ACCUMULATE VALUE AT LOC FOR VARIABLE
!  OF TYPE S.TYPE.
!  LASTCH IS NON-(BLANK OR ALPH).
!  IF PTR INVOLVED, IS SYMPTR.

	FORM _ -1    !REF'D BY NUMSCAN ERROR
	VADR _ LOC; VCNT _ 1
	IF VTYP _ VTYPA(S.TYPE)=CPLX THEN [VTYP _ REAL; INC VCNT]
	LOOP DO

	DO VTYP OF VTYPRNG

LGC:	CHAR _ EOLITWD; TEMP _ CHPT(@CHAR,-1)
	IF LASTCH#$. THEN DERR(BDCONS)
	LOOP DO
	  REPEAT 5; WHILE ALPH(NXCHAR); NCHV TEMP _ LASTCH
	END
	I _ NO
	EIF CHAR=^'FALSE' THEN NXCHAR
	ORIF CHAR=^'TRUE' THEN I _ YES
	ELSE DERR(BDCONS)
	IF LASTCH#$. THEN DERR(BDCONS)
	LGCPK(I); NXNSP

STR:	IF $'#LASTCH#$" THEN DERR(BDCONS)
	CHAR _ LASTCH; TEMP _ CHPT(VADR,-1); CNT _ S.SCAP(SYMPTR)
	LOOP DO
	  WHILE DEC CNT>=0; WHILE CARRET#NXCHAR#CHAR; NCHV TEMP _ LASTCH
	END
	EIF CNT>=0 THEN NCHV TEMP _ EOLIT
	! NOTE THAT CARRET SUPPLIES STRING TERMINATOR.
	ELSE WHILE CARRET#NXCHAR#CHAR THEN NULL !INPUT BEYOND CAPACITY
	IF LASTCH#CARRET THEN NXNSP

INT: REAL: DOUB: &
	NUMSCINIT
	LOOP [NUMSCAN(LASTCH); WHILE $;#NXCHAR#CARRET AND $ #LASTCH#$,]
	NUMSCAN(-2)
	IF LASTCH=$  THEN NXNSP

	END
	WHILE DEC VCNT>0
	IF LASTCH#$, THEN DERR(MISCOM); NXNSP
	INC VADR

	END
	RETURN

END GETVAL


%OUTSET

PUT(CARRET)
EIF ILPTR=SVLPTR THEN [PRINT('NO '); PRINT(ASSIGN)]
ELSE DO
  PRINT(ASSIGN); PUT($:); PUT(CARRET)
  PCHV SVLPTR  !TO BEFORE TERMINATOR
  WHILE ILPTR#SVLPTR THEN PUT(NCHV ILPTR)
END
RETURN

END OUTSET

END SET


%DISPLAY

LOCAL %DPUT.INIT, %DPUT, %PUTDBUF
LOCAL %PUTVAL
DEF DBUFLEN AS 133   !MAX TTYLEN+1 FOR EOLIT
DEF DBUFSZ AS ((DBUFLEN+CPW-1)/CPW)
LOCAL DBUF(0:DBUFSZ-1)
LOCAL DPOS   !POSITION FOR LINE SINCE DBUF.INIT
LOCAL DCNT   !TO CHECK FOR DBUF OVERFLOW (PAST TTYLEN)
LOCAL DPTR
LOCAL LOC

DPUT.INIT
LOOP DO
  [SYMPTR; LOC] _ DOUBLE GET.VAR
  PUTSYM(S.NAM(SYMPTR),%DPUT)
  IF S.ARYB(SYMPTR) THEN DO
    DPUT($(); I _ 0
    WHILE INC I<S.SNUM(SYMPTR) THEN DO
      PUTVAL(@SUBS(I),S.INT); DPUT($,)
    END
    PUTVAL(@SUBS(I),S.INT); DPUT($))
  END
  DPUT($ ); DPUT($=); PUTVAL(LOC,S.TYP(SYMPTR)); PUTDBUF
  WHILE LASTCH=$,
END
IF LASTCH#CARRET THEN DPERR(%PCMDL)
PUT(CARRET)
RETURN


%PUTVAL (LOC, S.TYPE)

!  USE SFORW FOR OUTPUT OF VALUE OF SPECIFIED TYPE
!  AT LOC.
!  IF PTR INVOLVED, IS SYMPTR.

	VADR _ LOC; VCNT _ 1
	IF VTYP _ VTYPA(S.TYPE) =CPLX THEN [VTYP _ REAL; INC VCNT]
	LOOP DO

	DO VTYP OF VTYPRNG

LGC:	DPUT($ ); DPUT(IF LGCUNPK THEN $T ELSE $F)

STR:	TEMP _ CHPT(VADR,-1); DPUT($ ); DPUT($")
	LOOP DO
	  REPEAT S.SCAP(SYMPTR); WHILE CHAR _ NCHV TEMP#EOLIT; DPUT(CHAR)
	END
	DPUT($")

INT:	DPUT(IF NUMUN.INIT(INTFLD) THEN $-  ELSE $ )
	REPEAT NUMUNPK DPUT(NUMUNPK)

REAL: DOUB: &
	TEMP _ POUT(%DPUT); FLOUT; POUT(TEMP)

	END
	WHILE DEC VCNT>0
	DPUT($,); DPUT($ )
	INC VADR

	END
	RETURN

END PUTVAL


%DPUT.INIT

!  INITIALIZATION (CALLED ONCE PER DISPLAY COMMAND).

LOCAL %DBUF.INIT

DPOS _ 0; DBUF.INIT; RETURN

%%DPUT (CHAR)

!  STORE CHAR IN DBUF OR, IF OVERFLOW, PUT TO TERMINAL.

EIF DEC DCNT>0 THEN NCHV DPTR _ CHAR
ELSE PUTDBUF
RETURN

%PUTDBUF

!  PUTS DBUF TO TERMINAL AND INITS FOR NEXT DISPLAY ITEM.

IF DPOS>0 THEN DO
  EIF DPOS+3+(LTTYLEN+1-DCNT)>=LTTYLEN THEN [PUT(CARRET); DPOS _ 0]
  ELSE [REPEAT 3 PUT($ ); DPOS +_ 3]
END
PRINT(DBUF); DPOS +_ LTTYLEN+1-DCNT; DBUF.INIT; RETURN

END PUTDBUF


%DBUF.INIT

!  INITIALIZE FOR (DPUT OF) NEW ITEM OF DISPLAY OUTPUT.

MOVE DBUFSZ FROM ALL EOLITWD TO DBUF
DPTR _ CHPT(DBUF,-1); DCNT _ LTTYLEN+1; RETURN

END DBUF.INIT

END DPUT.INIT

END DISPLAY

END DEXU

%STM(LINEN,AC)
!
! LINEN IS THE LINE NUMBER, AND AC IS THE AC FIELD OF THE STM UUO.
!
    CURLOC_PF.CADR(LINEN)
    PRMKEY_PFKEYD(LINEN)
    IF AC = 0 THEN RETURN
    IF AC BAND BRKBIT THEN 	&
        MSG('$BREAK AT ') 	&
    ELSE IF AC BAND TRCBIT THEN MSG('$')
    OUTKEY(0,0,0)

    IF AC BAND BRKBIT THEN DO
	CRETURN_RETURN
	GO DBCOM
    END

    RETURN
END STM


%XIT

! CALLED BY USER OR ERROR ROUTINES TO QUIT.

CRETURN _ 0     !DISALLOW CONTINUE
GO DBCOM

END XIT


%PAWS

! CALLED BY PAUSE ROUTINE TO MAKE DEBUGGER RUN

CRETURN _ RETURN
GO DBCOM

END PAWS


END DBG
    