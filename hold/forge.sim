! 11 JUL        FORMAT GENERATOR     MH

GLOBAL START:
GLOBAL %FORGE

DEF TRUE AS 1
DEF FALSE AS 0

DEF P AS 1
DEF M AS 2
DEF A AS 3
DEF N AS 4 
DEF D AS 5
DEF F AS 6
DEF FREEE AS 7
DEF TEMP AS 8
DEF L AS 9
DEF Z AS 10

DEF OUTT(X) AS FMSG(TEL,X)
DEF OUTNT(X) AS PN(TEL,X,10,0)
DEF SP(X) AS SPC(OUT.FN,X)
DEF OUT(X) AS FMSG(OUT.FN,X)
DEF CR AS W(OUT.FN,CARRET)
DEF CRT AS W(TEL,CARRET)
DEF DEBUG(X) AS 
DEF TEST.BUF(X) AS DEBUG(IF(BUF.USED(X)+BUF.LEFT(X))#BUF.LEN(X) THEN [MSG('BUF CTL FCKD$');HALT])
DEF UPDAT.FREE(X) AS BUF.USED(FREEE)+_X;BUF.LEFT(FREEE)-_X
DEF UPDAT.INDEX(X) AS BUF.LEFT(INDEX)_BUF.LEN(INDEX)+_X

DEF P.END AS 18
DEF M.END AS 56
DEF A.END AS 94
DEF N.END AS 130
DEF D.END AS 130
DEF F.END AS 130
DEF L.END AS 130

DEF BLANK AS $   
DEF COMMA AS $,
DEF SEMICOLON AS $; 

LOCAL %GET.CONTROL, %GET.FIELD, %GET.STRING, %GET.REC, %GET.NUM
LOCAL %PROCESS.LINE, %TOKENS.OUT
LOCAL %INIT
LOCAL %FMSG, %SPC, %FPRINT
LOCAL %CNTSC, %PN, %PS, %CSTN

LOCAL BUF.LEN(P:Z), BUF.USED(P:Z), BUF.LEFT(P:Z), BUF(P:Z)
LOCAL FIELD.END(P:Z), MODE(P:Z), WIDTH(P:Z)
LOCAL P.BUF(0:50), M.BUF(0:200), A.BUF(0:200), N.BUF(0:200)
LOCAL F.BUF(0:200), D.BUF(0:200), L.BUF(0:30)

LOCAL IN.FN, OUT.FN, DELIM
LOCAL TERM:

!
%FORGE
LOCAL PRED, CTL, OLD.CTL
START: NULL
\\->START

INIT
IF NOT GET.REC THEN [MSG('INPUT FILE EMPTY.$');GO TERM]  !PERFORM
                        !THE FIRST GET.REC TO FILL BUFFER FREE

LOOP DO
 [PRED;CTL] _ DOUBLE GET.CONTROL
 IF NOT PRED THEN MSG('CONTROL LETTERS NOT FOUND BY GET.CONTROL$')

 DO CTL OF P:Z

P: PROCESS.LINE
   MODE(P) _ TRUE
   GET.FIELD(P)         !MOVES TEXT FIELD INTO P.BUF

M: IF NOT MODE(P) THEN MSG('";M" DOES NOT FOLLOW ";P"$')
   GET.FIELD(M)         !MOVES TEXT FIELD INTO M.BUF
   !IF OLD.CTL#P THEN [PROCESS.LINE;MODE(P)_TRUE;CLEAR BUF(P);M:]

A: IF OLD.CTL#M THEN MSG('";A" DOES NOT FOLLOW ";M"$')
   GET.FIELD(A)

N: IF OLD.CTL#A THEN MSG('";N" DOES NOT FOLLOW ";A"$')
   GET.FIELD(N)

F: PROCESS.LINE
   MODE(F) _ TRUE
   GET.FIELD(F)

D: PROCESS.LINE
   MODE(D) _ TRUE
   GET.FIELD(D)

L: PROCESS.LINE
   MODE(L) _ TRUE

Z: PROCESS.LINE
   MSG('END OF INPUT FILE$')
   CLOSE(IN.FN)
   CLOSE(OUT.FN)
   EXIT

 END    !END DO CASE

 OLD.CTL _ CTL

END     !END OF LOOP DO

END FORGE
!
%PROCESS.LINE
!PROCESS.LINE IS CALLED WHEN THE START OF A NEW LINE IS SIGNALLED
!BY ONE OF ;P, ;F, ;D, OR ;L.  PROCESS.LINE CALLS THE ROUTINE
!WHICH HANDLES THE JUST COMPLETED LINE.

LOCAL %P.LINE, %D.LINE, %F.LINE, %L.LINE

EIF MODE(P) THEN P.LINE
ORIF MODE(D) THEN D.LINE
ORIF MODE(F) THEN F.LINE
 FIF MODE(L) THEN L.LINE

RETURN



%P.LINE
LOCAL NN, I

WHILE BUF.LEFT(P)+BUF.LEFT(M)+BUF.LEFT(A)+BUF.LEFT(N)>0 &
 THEN &
 DO
  FOR I_P TO N &
  DO
   NN _ 0                        !TOKENS.OUT REDUCES BUF.LEFT(I)
   IF BUF.LEFT(I) THEN NN _ TOKENS.OUT(WIDTH(I),I)  !TOKENS.OUT MUST
                                                 !RETURN PROPER LENGTH
   DEBUG(OUTT('RETURN FROM TOKENS.OUT...NN = ');OUTNT(NN);CRT)
   SP(WIDTH(I)-NN)         !SPACE TO END OF FIELD
   OUT(@DELIM)                   !MARK END OF FIELD WITH DELIMITER
  END
  CR                            !END OF PRINT LINE
 END            !END OF WHILE LOOP

FOR I_P TO N &
 DO
  SP(WIDTH(I))
  OUT(@DELIM)           !PUT DELIMS WITH NO TEXT AS LINE SPACER
 END
CR

MODE(P) _ FALSE
RETURN
END P.LINE


%L.LINE
OUT(BUF(L))
CR
MODE(L) _ FALSE
RETURN
END L.LINE
!
%F.LINE
WHILE BUF.LEFT(F)>0 THEN [TOKENS.OUT(FIELD.END(F),F);CR]
MODE(F) _ FALSE
RETURN
END F.LINE




%D.LINE
LOCAL NN

WHILE BUF.LEFT(D)>0 &
 THEN &
 DO
  NN _ TOKENS.OUT(FIELD.END(D),D)
  SP(FIELD.END(D) - NN)
  OUT(@DELIM) 
  CR
 END

MODE(D) _ FALSE
RETURN
END D.LINE


END PROCESS.LINE
!
%TOKENS.OUT(NN,INDEX)
!TOKENS.OUT PUTS OUT NN OR FEWER CHARACTERS, A TOKEN AT A TIME, (SINCE
!WE DON'T WANT TO BUILD A HYPHENATOR) FROM THE BUFFER BUF(INDEX),
!  THE BUFFERS HAVE CLEAR TEXT (NO CONTROL SEMICOLONS) SO THAT
!WE ONLY HAVE TO LOOK FOR TOKEN DELIMITERS (BLANK, COMMA, SEMICOLON)
!OR THE END OF BUFFER (E.O.LIT)

LOCAL PTR.BL, PTR.COM, PTR.EOLIT, PTR.SEMI, PTR
LOCAL CHARS, I
LOCAL %OUT.CH, %TEST.FOR

DEBUG(MSG('TOKENS.OUT CALLED WITH NN = ');OUTNT(NN);CRT)
CHARS _ 0
PTR.BL_PTR.COM_PTR.EOLIT_PTR.SEMI_PTR_CHPT(BUF(INDEX),BUF.USED(INDEX)-1)

DEBUG(MSG('INDEX, BUF.USED(INDEX), BUF.LEFT(INDEX) ARE:$'))
DEBUG(OUTNT(INDEX);CRT;OUTNT(BUF.USED(INDEX));CRT;OUTNT(BUF.LEFT(INDEX));CRT)
IF BUF.LEFT(INDEX)<NN THEN NN_BUF.LEFT(INDEX) !LET'S NOT LOOK FOR NOUGHT

DEBUG(MSG('LINE IS:$'))
DEBUG(FOR I_1 TO BUF.LEFT(INDEX) W(TEL,NCHV(PTR.BL)))
DEBUG(W(TEL,CARRET))

IF TEST.FOR(BLANK) THEN RETURN CHARS
IF TEST.FOR(COMMA) THEN RETURN CHARS
IF TEST.FOR(SEMICOLON) THEN RETURN CHARS
IF TEST.FOR(EOLIT) THEN RETURN CHARS    !EOLIT INCLUDED IN BUF.LEN

IF CHARS=0 THEN MSG('BIG TOKE$')
RETURN CHARS


%TEST.FOR(DEL)
LOCAL WORK.PTR
WORK.PTR _ PTR           !SAVE PTR IN CASE NO MATCH

DEBUG(MSG('TEST.FOR$'))
I _ 0
WHILE (INC I)<=(NN-CHARS)  &
 THEN &
 DO
  IF NCHV(WORK.PTR)=DEL &
   THEN &
   DO
    IF DEL=EOLIT &
     THEN &
     DO
      OUT.CH(I-1)               !DON'T PUT OUT EOLIT
      INC BUF.USED(INDEX)       !BUT WE USED UP THE EOLIT
      DEC BUF.LEFT(INDEX)       !THIS SHOULD NOW EQUAL ZERO
      RETURN (TRUE)
     END
    OUT.CH(I)                   !PUT OUT TOKEN AND UPDATE "CHARS"
    PTR _ WORK.PTR               !UPDATE PTR PAST TOKEN
    I _ 0                       !START COUNTING NEXT TOKEN
   END
 END
IF CHV(WORK.PTR)=DEL THEN RETURN TRUE
RETURN FALSE
END TEST.FOR


%OUT.CH(NUM)
LOCAL TEMP1
!USES PTR, CHARS DEFINED ABOVE
DEBUG(MSG('OUT.CH CALLED WITH NUM = ');OUTNT(NUM);CRT)

IF NUM <= 0  THEN RETURN                !NO WORK TO DO
FOR I_1 TO NUM &
 DO
  IF TEMP1_NCHV(PTR)#EOLIT &
   THEN &
   DO
    W(OUT.FN,TEMP1)
    DEBUG(W(TEL,TEMP1))
   END
 END

DEBUG(CRT)
CHARS+_NUM; BUF.USED(INDEX)+_NUM; BUF.LEFT(INDEX)-_NUM
TEST.BUF(INDEX)
IF BUF.USED(INDEX)>BUF.LEN(INDEX)  &
 THEN &
 DO
  MSG('BUF.USED>BUF.LEN FOR INDEX=')
  OUTNT(BUF.USED(INDEX));OUTT(' > ');OUTNT(BUF.LEN(INDEX))
  OUTT(' FOR INDEX = ');OUTNT(INDEX);OUTT(', NUM IS ');OUTNT(NUM);CRT
  OUTT('WE CHEATED...BUF.LEFT(INDEX)_0...WAS = ')
  OUTNT(BUF.LEFT(INDEX));CRT
 END
RETURN
END OUT.CH

END TOKENS.OUT
!
%GET.CONTROL
!RETURNS TRUE IF ONE OF ;P, ;M, ;A, ;N, ;F, ;D, OR ;L IS FOUND
!OTHERWISE RETURNS FALSE
!ALSO RETURNS THE CONTROL CHARACTER P, M, A, N, ETC.
!BUF(FREEE) SHOULD HAVE <SEMICOLON><CONTROL CHARACTER> WAITING TO
!BE PARSED

DEBUG(MSG('GET.CONTROL$'))

LOCAL PTR.FREE, CHAR

IF BUF.LEFT(FREEE)=0 THEN IF NOT GET.REC THEN RETURN [TRUE;Z]
PTR.FREE _ CHPT(FREE, BUF.USED(FREEE)-1)  !START GOBBLING CHARS
                        !FROM INPUT BUF, WHERE WE LEFT OFF LAST TIME
IF NCHV(PTR.FREE)#SEMICOLON THEN [MSG('";" NOT FND..GET.CTL');&
       W(TEL,CHV(PTR.FREE));W(TEL,CHV(PTR.FREE));W(TEL,CHV(PTR.FREE));HALT]

UPDAT.FREE(2)
EIF CHAR _ NCHV(PTR.FREE)=$P THEN RETURN [TRUE;P]
ORIF CHAR=$M THEN RETURN[TRUE;M]
ORIF CHAR=$A THEN RETURN[TRUE;A]
ORIF CHAR=$N THEN RETURN[TRUE;N]
ORIF CHAR=$F THEN RETURN[TRUE;F]
ORIF CHAR=$D THEN RETURN[TRUE;D]
ORIF CHAR=$L THEN RETURN[TRUE;L]
ELSE RETURN [FALSE;FALSE]

END GET.CONTROL
!
%GET.FIELD(INDEX)
!GET FIELD OF TEXT INTO BUF(INDEX)
!THIS ROUTINE HANDLES  ;<CR>    CONTINUED LINE
!                       ;;      SINGLE SEMICOLON
!                       ;INNN   INDENT TO COLUMN NNN
!                       ;SNNN   INDENT NNN SPACES FROM CURRENT COLUMN
!
!THE FIELD TERMINATES ON ONE OF ;P, ;M, ;A, ;N, ;F, ;D, OR ;L

DEBUG(MSG('GET.FIELD$'))

LOCAL PTR.FREE, PTR.INDEX, CHAR, NEXT.CHAR, I, X, NUM

PTR.FREE _ CHPT(FREE, BUF.USED(FREEE)-1)  !START GOBBLING CHARS
                        !FROM INPUT BUF, WHERE WE LEFT OFF LAST TIME
PTR.INDEX _ CHPT(BUF(INDEX), -1)   !START AT FRONT END OF OUTPUT BUF
BUF.LEN(INDEX) _ BUF.USED(INDEX) _ BUF.LEFT(INDEX) _ 0

!TOP:NULL
WHILE BUF.LEFT(FREEE)>0 &
 THEN &
 DO
  TEST.BUF(INDEX)
  CHAR _ NCHV(PTR.FREE)
  IF SEMICOLON#CHAR &
   THEN &
   DO
    NCHV(PTR.INDEX) _ CHAR      !MOVE CHAR INTO OUTPUT BUF(INDEX)
    UPDAT.FREE(1)
    UPDAT.INDEX(1)
   END &
   ELSE  !WE HAVE SEMICOLON! &
   DO
    EIF CARRET=NEXT.CHAR_NCHV(PTR.FREE) &
     THEN &
     DO
      IF NOT GET.REC THEN [MSG('NO CONTINUED LINE$');OUT(FREE)]
      PTR.FREE _ CHPT(FREE,-1)
     END
    ORIF NEXT.CHAR=SEMICOLON &
     THEN &
     DO
      NCHV(PTR.INDEX)_NEXT.CHAR         !MOVE ONE OF THE SEMI'S
      UPDAT.INDEX(1)
      UPDAT.FREE(2)
     END
    ORIF NEXT.CHAR=$I &
     THEN &
     DO
      [X;NUM] _ DOUBLE GET.NUM          !X DIGITS WITH NUM VALUE
      IF NUM<=BUF.USED(INDEX)THEN[MSG('";I"IGNORED$');UPDAT.FREE(X+2)]&
      ELSE &
      DO
       FOR I_1 TO NUM NCHV(PTR.INDEX)_BLANK
       UPDAT.INDEX(NUM)
       UPDAT.FREE(X+2)
      END
     END
    ORIF NEXT.CHAR=$S &
     THEN &
    DO
      [X;NUM] _ DOUBLE GET.NUM
      FOR I_1 TO NUM NCHV(PTR.INDEX)_BLANK
      UPDAT.INDEX(NUM)
      UPDAT.FREE(X+2)
     END
    ORIF NEXT.CHAR=$P &
      OR NEXT.CHAR=$M &
      OR NEXT.CHAR=$A &
      OR NEXT.CHAR=$N &
      OR NEXT.CHAR=$F &
      OR NEXT.CHAR=$D &
      OR NEXT.CHAR=$L &
        THEN &
        DO
         NCHV(PTR.INDEX) _ EOLIT    !PROPER END FOR OUTPUT BUFFER
         UPDAT.INDEX(1)             !COUNT EOLIT IN BUF.LEN
         RETURN
        END
    ELSE  !WE HAVE SEMICOLON FOLLOWED BY SOME NON-CONTROL LETTER!&
    DO
     NCHV(PTR.INDEX)_CHAR
     NCHV(PTR.INDEX)_NEXT.CHAR
     UPDAT.INDEX(2)
     UPDAT.FREE(2)
    END
  END    !END "IF SEMICOLON#CHAR..."
 END     !END OF WHILE LOOP

NCHV(PTR.INDEX) _ EOLIT
UPDAT.INDEX(1)          !COUNT EOLIT IN BUF.LEN
RETURN
!IF NOT GET.REC THEN RETURN Z*************?????????
!PTR.FREE _ CHPT(FREE,-1)

!GO TOP

%GET.NUM
RETURN          !NEED WORK HERE*********************
END GET.NUM

END GET.FIELD
!
%GET.REC
LOCAL EOF:

SETRWE(IN.FN,EOF)
GETLINE(IN.FN)
BUF.LEN(FREEE)_BUF.LEFT(FREEE)_GLCNT-1          !MINUS 1 FOR EOLIT
BUF.USED(FREEE)_0

DEBUG(MSG('GET.REC...RECORD IN FREE IS:$');OUTT(FREE))

RETURN TRUE

EOF: RETURN FALSE
END GET.REC
!
%INIT
LOCAL IN.ERR:, OUT.ERR:
LOCAL I, PTR

IOCS(3)
MSG('WE ARE STARTING UP THE FORGE...$')
MSG('ENTER DELIMITER CHARACTER: ')
DELIM _ 0
IF GET.STRING THEN [PTR_CHPT(IMAGE,-1);CH(@DELIM)_NCHV(PTR)] &
 ELSE CH(@DELIM)_CH('>')

IN:NULL
MSG('INPUT FILE: ')
IF NOT GET.STRING THEN GO IN
IN.FN _ OPEN(IMAGE,CHARACTER+UPDATE+DIRECT,IN.ERR)

OUTN:NULL
MSG('OUTPUT FILE: ')
IF NOT GET.STRING THEN GO OUTN
OUT.FN _ OPEN(IMAGE,CHARACTER+UPDATE+DIRECT,OUT.ERR)
BUF(A) _ A.BUF
BUF(P) _ P.BUF
BUF(M) _ M.BUF
BUF(N) _ N.BUF
BUF(F) _ F.BUF
BUF(D) _ D.BUF
BUF(L) _ L.BUF
BUF(FREEE) _ FREE

FOR I_P TO Z &
 DO
  BUF.LEFT(I)_BUF.LEN(I)_BUF.USED(I)_0
  MODE(I)_FALSE
 END

FIELD.END(P) _ P.END
FIELD.END(M) _ M.END
FIELD.END(A) _ A.END
FIELD.END(N) _ N.END
FIELD.END(D) _ D.END
FIELD.END(F) _ F.END
FIELD.END(L) _ L.END

WIDTH(P)_FIELD.END(P)-1
WIDTH(M)_FIELD.END(M)-FIELD.END(P)-1
WIDTH(A)_FIELD.END(A)-FIELD.END(M)-1
WIDTH(N)_FIELD.END(N)-FIELD.END(A)-1

PTR _ CHPT(BUF(L), -1)          !LOAD L.BUF WITH DELIM CHARS
FOR I_1 TO FIELD.END(L) NCHV(PTR)_CH(@DELIM)
NCHV(PTR) _ E.O.LIT

RETURN

 IN.ERR: MSG(' INPUT FILE OPEN ERROR.$'); MSG('IN.FN IS '); OUTNT(IN.FN);GO IN
OUT.ERR: MSG('OUTPUT FILE OPEN ERROR.$');MSG('OUT.FN IS ');OUTNT(OUT.FN); GO OUTN
END INIT
!
%FMSG(FN,STR)
   LOCAL PTR
   PTR_CHPT(STR,-1)
   WHILE NCHV PTR#EOLIT THEN W(FN,IF CHV PTR=$$ THEN CARRET ELSE CHV PTR)
   RETURN

   %%FPRINT(FN,STR)
      PTR_CHPT(STR,-1)
      WHILE NCHV PTR#EOLIT THEN W(FN,CHV PTR)
      RETURN
END FMSG

%SPC(FN,NN)
 REPEAT NN W(FN,$ )
 RETURN
END SPC



%GET.STRING
LOCAL PTR1, PTR2

PTR1 _ PTR2 _ CHPT(FREE,-1)
GETLINE(TEL)
IF GLCNT=1 THEN RETURN FALSE            !CARRET ONLY TYPED AT TTY
WHILE NCHV(PTR1)#CARRET THEN NULL
NCHV(PTR1)_E.O.LIT                      !REPLACE CARRET WITH EOLIT
RETURN TRUE
END GET.STRING


%CNTSC(NN,PTR,@I,S)
   LOCAL AA(0:9),APTR,Q1,Q2
   I_0; APTR_CHPT(AA,-1); NCHV APTR_EOLIT

   IF NN<0 THEN [NN_-NN; INC I; NCHV PTR_$-]

   IF S#0 THEN [NN;Q2]_NN DIVMOD S

   LOOP DO
      [NN;Q1]_NN DIVMOD 10
      NCHV APTR_Q1+$0
      WHILE NN#0
   END

   NCHV APTR

   WHILE Q1_PCHV APTR#EOLIT THEN [INC I; NCHV PTR_Q1]

   IF S#0 THEN DO
      NCHV PTR_$.
      INC I
      LOOP DO
         WHILE S>1
         S_S/10
         [Q1;Q2]_Q2 DIVMOD S
         INC I
         NCHV PTR_Q1+$0
      END
   END

   NCHV PTR_EOLIT
   RETURN
END CNTSC



%PN(FN,NN,FF,S)
 LOCAL STR(0:9),PTR,LL
 PTR_CHPT(STR,-1)
 CNTSC(NN,PTR,@LL,S)
!SPC(FN,FF-LL)
 FPRINT(FN,STR)
 RETURN
END PN

%PS(FN,PTR,NN)
 W(FN,$ )
 PTR_CHPT(PTR,-1)
 REPEAT NN W(FN,IF NCHV PTR=EOLIT THEN $  ELSE CHV PTR)
 RETURN
END PS

%CSTN(PTR,@TCH,B)
 LOCAL NN,MFLG,CNT,%PST
 NN_MFLG_CNT_0
 LOOP WHILE NCHV PTR=$ 
 IF CHV PTR=$- THEN INC MFLG ELSE PCHV PTR
 PST; CNT_0
 IF CHV PTR=$. THEN PST
 TCH_CHV PTR
 IF MFLG#0 THEN NN_-NN
 RETURN [NN;CNT]
 %PST
  WHILE $0<=NCHV PTR<=B+$0 THEN [INC CNT; NN_NN*B+(CHV PTR)-$0]
  RETURN
 END PST
END CSTN


   