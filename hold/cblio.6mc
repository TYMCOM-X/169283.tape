TITLE CBLIO FOR LIBOL VERSION 6		 21-MAR-73
;***COPYRIGHT 1973 DIGITAL EQUIPMENT CORP., MAYNARD, MASS.***
SUBTTL IMPURE LOCATIONS USED BY LIBOL ROUTINES

ENTRY RESET.

EXTERNAL LIBIMP	;BE SURE LIBIMP IS LOADED

	LOC	124	;.JBREN
	EXP	RENDP	;TO FORCE A DUMP
	VERSION==006001        ;DEC-VER=006,TYM-VER=001
	EDIT==262001           ;DEC-EDT=262,TYM-REL=001
	LOC	137	;.JBVER
	XWD	VERSION,EDIT

	IFNDEF ISAM,<ISAM==01>

	IFNDEF EBCDIC,<EBCDIC==0>

	IFNDEF ALTMOD,<ALTMOD==1>	;IF NON ZERO ALT-MODE IS A END-OF-LINE CHAR

	HISEG

EXTERNAL DTSIZ.,DTABL.,DTVAL.

EXTERNAL IIN,IOUT,ISETI,ISETO,ICLOS,IRELE,IGETS,IWAIT,IRNAM
EXTERNAL MWAIT.,MREW.,MREWU.,MBSPR.,MBSPF.,MADVR.,MADVF.,MWEOF.,MTIND.
EXTERNAL SOBOT.,SZBOT.,SZEOF.,SZEOT.,DPLOC.

EXTERNAL UOPEN.,UENTR.,ULKUP.,UOBUF.,UIBUF.,UCLOS.,URELE.,USETI.
EXTERNAL USETO.,UOUT.,UIN.,USETS.,UGETS.,UWAIT.,USEEK.,URNAM.

EXTERNAL UOCAL.,OPNCH.,UOBLK.

EXTERNAL UEBLK.,ULBLK.,TTOBP.,TTOBC.,TTOBF.,STDLB.
EXTERNAL REDMP.,TEMP.,TEMP.1,JSARR.,TEMP.2,SEGNO.,AINFO.,OVRBF.,FLDCT.,OVRIX.
EXTERNAL NOCR.,PRGFLG,TTYOPN,ACSAV0,MXIE,IESAVE,MXBUF,AUXBUF,AUXIOW,AUXBNO,CMDLST,NEWBK1
EXTERNAL NEWBK2,OLDBK,MXBF,DRTAB,LRWA

EXTERNAL FRSTIC,LASTIC,PFRST.,UFRST.,ULAST.,IFRST.,ILAST.

SUBTTL CONSTANTS

AC0==0		;AC ASSIGNMENTS
AC1==1
AC2==2
AC3==3
AC4==4
AC5==5
AC6==6
FLG==7
AC10==10
AC11==11
C==11
AC12==12
I12==12
AC13==13
LVL==13
AC14==14
FLG1==14
AC15==15
AC16==16
I16==16
PP==17

REPEAT 0,<		;FLAGS IN LEFT SIDE OF "10(I16)" BEFORE RESET
DDMASC==400000	;DEVICE DATA MODE IS ASCII
DDMBIN==200000	;DEVICE DATA MODE IS BINARY (SIXBIT)
NONSTD==100000	;NON STANDARD LABELS
STNDRD==40000	;STANDARD LABELS
OPNIN==20000	;FILE IS OPEN FOR INPUT
OPNOUT==10000	;FILE IS OPEN FOR OUTPUT
OPNIO==4000	;FILE IS OPEN FOR INPUT/OUTPUT
ATEND==2000	;AN "EOF" WAS SEEN
CONNEC==400	;DEVICE & CORE DATA MODES DIFFER
RRUNER==200	;RERUN DUMP AT END-OF-REEL
RRUNRC==100	;RERUN DUMP VIA RECORD-COUNT
NOTPRS==40	;OPTIONAL FILE NOT PRESENT
FILOPT==20	;OPTIONAL FILE
CDMASC==10	;CORE DATA MODE IS ASCII
CDMBIN==4	;CORE DATA MODE IS BINARY (SIXBIT)
RANFIL==1	;IS A RANDOM FILE
>

HUF==1
LOCK==2
		;FLAGS IN LEFT SIDE OF "FLG" & 10(I16) AFTER RESET.
DDMASC==400000	;DEVICE DATA MODE IS ASCII
DDMSIX==200000	;DEVICE DATA MODE IS SIXBIT
DDMBIN==100000	;DEVICE DATA MODE IS BINARY
DDMEBC==40000	;DEVICE DATA MODE IS IBCDIC
OPNIN==20000	;FILE IS OPEN FOR INPUT
OPNOUT==10000	;FILE IS OPEN FOR OUTPUT
OPNIO==4000	;FILE IS OPEN FOR INPUT/OUTPUT
ATEND==2000	;AN "EOF" WAS SEEN
CONNEC==1000	;DEVICE & CORE DATA MODES DIFFER
NOTPRS==400	;OPTIONAL FILE NOT PRESENT
RRUNER==200	;RERUN DUMP AT END-OF-REEL
RRUNRC==100	;RERUN DUMP VIA RECORD-COUNT
CDMASC==40	;CORE DATA MODE IS ASCII
CDMSIX==20	;CORE DATA MODE IS SIXBIT
CDMBIN==10	;CORE DATA MODE IS BINARY
IDXFIL==4	;ACCESS MODE IS INDEX-SEQUENTIAL
SEQFIL==2	;ACCESS MODE IS SEQUENTIAL
RANFIL==1	;ACCESS MODE IS RANDOM

		;FLAGS IN LEFT SIDE OF FLG1 & -23(I16) AFTER RESET.
FILOPT==200000	;FILE IS OPTIONAL
NONSTD==100000	;LABELS ARE NON-STANDARD
STNDRD==40000	;LABELS ARE STANDARD
APPEND==1	;NOT USED

IFN ISAM,<
WSTB==1000	;WRITE THE STATISTICS BLOCK
IIAB==400	;INSERTION IS IN AUX BUFFER
TRYAGN==200	;MAKE A SECOND PASS AT ALC01
BVN==100	;BUMP-VERSION-NUMBER SPLITTING A BLOCK
WSB==40		;WRITE THE SAT BLOCK
BLK2==20	;REQ FOR 2ND DATA BLOCK
SEQ==10		;SEQUENTIAL READ
VERR==4		;VERSION NUMBER DISCREPANCY BTWEEN INDEX LEVELS
WIVK==2		;WRITE INVALID-KEY
RIVK==1		;READ, RERIT OR DELET INVALID-KEY
EIX==1		;ENTER OF NAME.IDX IN PROGRESS
>

		;FLAGS IN LEFT SIDE OF AC16 FOR DURATION OF CURRENT COBOL UUO
WADV==400000
WRITE==200000
READ==100000
OPEN==40000
CLOSEF==20000	;EOF
CLOSER==10000	;EOV
CLOSEB==4000	;HDR
RERIT==10	;ISAM REWRITE
DELET==4	;ISAM DELETE
SLURP==2	;WRITE REEL CHANGE, RESTORE THE RECORD AREA
MTAEOT==1	;END-OF-TAPE

BUFLOC==4000	;BUFFER LOCATION HAS BEEN ASSIGNED, LEFT-HALF OF 5(I16)
IOFILE==2000	;FILE IS AN INPUT/OUTPUT FILE, LEFT HALF OF 5(I16)
OEUP==4000	;OPEN ERROR USE PROCEDURE - ENTER ERROR FILE BEING MODIFIED, BIT 6 OF 22(I16)
EXTERN	.JBSA,.JBFF,.JBREL,.JB41,.JBAPR,.JBTPC,.JBCNI,.JBVER,.JBDA,.JBOPC,.JBREN

EXTERN	.JBOPS
INTERN	CLOSE.,DOPFS.,END.,GETCH.,DSPLY.,DSPL1.,OPEN.,OUTCH.
INTERN	OUT6B.,OUTBF.,READ.,RSTAB.,SEEK.,STOPR.,STOP.,TODAY.,TRAP.,WRITE.,WADV.,WRPW.
INTERN	GOTO.,KILL.,PPOUT.,ULOSE.

EXTERNAL RET.1,RET.2,RET.3,PPSIZ.,UUO.

INTERN	DELET.,RERIT.,PURGE.

IFN ISAM,<EXTERNAL GD6.,GD7.,KEYCNV>

EXTERNAL FILES.,USES.,OVRFN.,TRAC1.

;DEVICE TABLE CONSTANTS

D.BPW=-25	;BYTES PER WORD
D.RD=-24	;RERUN DEVICE NAME IN SIXBIT
D.F1=-23	;0-17 FLG1 
D.IE=-22	;# OF INPUTS EXECUTED
D.OE=-21	;# OF OUTPUTS EXECUTED
D.LRS=-20	;18-35 LABEL RECORD SIZE
D.BL=-20	;0-17 BUFFER LOCATION
D.FBB=-17	;18-35 EBCDIC, # OF FREE BUFFER BYTES
D.HF=-17	;BIT-17 HUF FLAG
D.LF=-17	;BIT-16 LOCK FLAG
D.CN=-17	;12-15 IO CHANNEL NUMBER
D.RN=-17	;0-11 MAGTAPE REEL NUMBER
D.CBN=-16	;CURRENT PHYSCIAL BLOCK NUMBER
D.BPL=-15	;# OF BUFFERS PER LOGICAL BLOCK
D.BCL=-14	;# OF BUFFERS TO FILL CURRENT LOGICAL BLOCK
D.RCL=-13	;# OF RECORDS TO FILL CURRENT LOGICAL BLOCK
D.ICD=-12	;IOWD FOR CURRENT DEVICE
D.OBH=-11	;OUTPUT BUFFER HEADER
D.OBB=-10	;OUTPUT BUFFER BYTE POINTER
D.OBC=-7	;OUTPUT BUFFER BYTE COUNT
D.IBH=-6	;INPUT BUFFER HEADER
D.IBB=-5	;INPUT BUFFER BYTE POINTER
D.IBC=-4	;INPUT BUFFER BYTE COUNT
D.RRD=-3	;# OF RECORDS TO A RERUN DUMP
D.RP=-2		;# OF RECORDS PROCESSED
D.DC=-1		;DEVICE CHARACTERISTICS
D.OPT=-1	;-1 IF A "NOT-PRESENT" OPTIONAL ISAM FILE
IFN ISAM,<
ADR==0
DEFINE	TABADR(N,L) <
N==ADR
ADR==ADR+L
>

TABADR	STAHDR,1	;SIZE OF STATISTICS BLOCK IN SIXBIT BYTES
TABADR	DDEVNM,1	;DATA FILE'S DEVICE NAME
TABADR	DFILNM,1	;DATA FILE'S FILE NAME
TABADR	DEXT,1		;DATA FILE'S EXTENSION
TABADR	DCDATE,1	;DATA FILE'S CREATION DATE
TABADR	DADATE,1	;DATA FILE'S ACCESS DATE
TABADR	MXLVL,1		;NUMBER OF LEVELS IN INDEX FILE
TABADR	DBF,1		;DATA FILE BLOCKING FACTOR
TABADR	DMTREC,1	;NUMBER OF EMPTY RECORDS PER DATA BLOCK
TABADR	EPIB,^D20	;TWO WORDS PER INDEX LEVEL
			;FIRST WORD:  NUMBER OF ENTRIES PER INDEX BLOCK
			;SECOND WORD:  NUMBER OF EMPTY ENTRIES
TABADR	DMXBLK,1	;TOTAL BLOCKS IN DATA FILE
TABADR	DMTBLK,1	;EMPTY BLOCKS IN DATA FILE
TABADR	IMXSCT,1	;TOTAL SECTORS IN INDEX FILE
TABADR	IMTSCT,1	;EMPTY SECTORS IN INDEX FILE
TABADR	FMTSCT,1	;FIRST EMPTY SECTOR IN INDEX FILE
TABADR	DMXREC,1	;MAXIMUM DATA RECORD SIZE IN WORDS
TABADR	DBPRK,1		;BYTE POINTER TO RECORD KEY RELATIVE TO DATA RECORD
TABADR	RWRSTA,1	;NUMBER OF READ, WRITE, REWRITE STATEMENTS SINCE INITIALIZATION
TABADR	IOUUOS,1	;NUMBER OF IN'S AND OUT'S SINCE INITIALIZATION
TABADR	SBLOC,1		;RELATIVE ADR OF FIRST SAT BLOCK
TABADR	SBTOT,1		;TOTAL SAT BLOCKS
TABADR	ISPB,1		;INDEX FILE, SECTORS PER LOGICAL BLOCK
TABADR	FILSIZ,1	;MAXIMUM POSSIBLE NUMBER OF DATA BLOCKS IN FILE
TABADR	KEYTYP,0	;KEY-TYPE IN LEFT HALF
TABADR	KEYDES,1	;DESCRIPTION OF RECORD KEY
TABADR	IESIZ,1		;INDEX ENTRY SIZE IN WORDS
TABADR	TOPIBN,1	;TOP INDEX BLOCK NUMBER
TABADR	%DAT,1		;% OF DATA FILE EMPTY
TABADR	%IDX,1		;% OF INDEX FILE EMPTY
TABADR	RECBYT,1	;SIZE OF LARGEST DATA BLOCK IN BYTES
TABADR	MAXSAT,1	;MAX # OF RECORDS FILE CAN BECOME
TABADR	ISAVER,1	;"ISAM" VERSION NUMBER

STABL==ADR	;EQUALS SIZE OF STATISTICS BLOCK

TABADR	IOWRD,14+1	;TABLE OF DUMP MODE IOWD'S FOR EACH INDEX LEVEL
			;0 DATA BLOCK
			;1-12 INDEX BLOCKS
			;13 SAT BLOCK
			;14 STATISTICS BLOCK
TABADR	OMXLVL,1	;ORIGINAL MAX NUMBER OF LEVELS IN INDEX FILE
TABADR	ICHAN,1		;CHANNEL NUMBER FOR INDEX DEVICE
TABADR	USOBJ,14+1	;USETI/O OBJECT: DATA, 10 INDEX, SAT & STA
TABADR	CNTRY,14+1	;CURRENT INDEX ENTRY
TABADR	NNTRY,14+1	;FLAG, CNTRY POINTS TO NEXT ENTRY NOT CURRENT
TABADR	LIVE,1	;(-1) IF DATA NOT YET OUTPUT
TABADR	BRISK,1		;IF -1 OUTPUT ONLY WHEN INPUT IS EMINENT
TABADR	CLVL,1		;CURRENT LEVEL
TABADR	IAKBP,1		;INDEX ADJUSTED SYMBOLIC KEY BYTE-POINTER
TABADR	IAKBP1,1	;POINTER TO SECOND KEY WORD
TABADR	DAKBP,1		;DATA ADJUSTED SYMBOLIC KEY BP
TABADR	DAKBP1,1	;POINTER TO THE SECOND KEY WORD
TABADR	SINC,1		;BINARY SEARCH INCREMENT
TABADR	IBLEN,1		;INDEX BLOCK LENGTH NOT COUNTING HEADERS
TABADR	IKWCNT,1		;INDEX, NUMBER OF WORDS IN THE KEY
TABADR	DKWCNT,1		;DATA, NUMBER OF WORDS IN KEY
TABADR	FWMASK,1		;MASK FOR FIRST WORD OF DATA KEY
TABADR	LWMASK,1	;MASK FOR LAST WORD OF DATA KEY
TABADR	ICMP,1		;HOLDS ADR OF THE INDEX COMPARE ROUTINE
TABADR	DCMP,1		;HOLDS ADR OF DATA COMPARE OR CONVERT ROUTINE
TABADR	DCMP1,1		;HOLDS ADR OF DATA COMPARE ROUTINE IF KEY IS NUMERIC DISPLAY
TABADR	GDX.,1		;HOLDS ADR OF CONVERT ROUTINE
TABADR	GDPSK,1		;PARAMETER FOR SYM-KEY CONVERSION
TABADR	GDPRK,1		;PARAMETER FOR REC-KEY CONVERSION
TABADR	GDPRK1,1	;
TABADR	GETSET,1	;DISPATCH LOC: ADJKEY OR GD67 OR FPORFP
TABADR	RECBP,1		;RECORD AREA BYTE-POINTER
TABADR	RSBP,1		;BYTE POINTER TO RECORD SIZE IN BUFFER
TABADR	RSBP1,1		;ANOTHER BP TO RECORD SIZE
TABADR	LRW,1		;FIRST FREE RECORD WORD, USED BY SETLRW
TABADR	IOWRD0,1	;POINTS TO CURRENT IOWRD
TABADR	USOBJ0,1	;POINTS TO CURRENT USOBJ
TABADR	CNTRY0,1	;POINTS TO CURRENT CNTRY
TABADR	NNTRY0,1	;FLAG, CNTRY POINTS TO NEXT ENTRY
TABADR	BPSB,1		;NUMBER OF BITS PER SAT BLOCK
TABADR	CORE0,1		;LAST,,FIRST -  CORE AREA CLEARED AT CLOSE
ITABL==ADR-STABL	;INDEX TABLE LEN 
TABADR	BA,0		;START OF BUFFER AREA
> ;END OF 'IFN ISAM'
SUBTTL	RESET
	;RESET IS CALLED WITH A JSP 14,RESET.
	MLON

RESET.:	JRST	.+2		;ENTRY FOR 'RESET.'
	JRST	STOPR.		;ENTRY FOR 'STOP RUN'
	CALLI			;RESET
	HRRZ	AC1,.JBSA	;[START.]
	MOVEM	AC1,JSARR.	;SAVE FOR RRDMP
	HRRZ	AC1,.JBFF	;TO-1
	CAMG	AC1,.JBREL	;SKIP ILL-MEM-REF
	SETZM	(AC1)		;ZERO WORD
	HRL	AC1,AC1		;FROM,,TO-1
	ADDI	AC1,1		;FROM,,TO
	HRRZ	AC2,.JBREL	;UNTIL
	CAIL	AC2,(AC1)	;SKIP ILL-MEM-REF IF .JBFF = .JBREL
	BLT	AC1,(AC2)	;ZERO FREE COR
RESET1:	MOVEI	AC0,[TTCALL 3,[ASCIZ/COBOL PROGRAMS MAY ONLY BE STARTED THROUGH USE OF "GET AND ST" OR "RUN" MONITOR COMMANDS/]
			CALLI 12]	;EXIT
	HRRM	AC0,.JBSA
	MOVE	PP,[PUSHJ PP,UUO.]
	MOVEM	PP,41
	HLRZ	PP,.JBOPS	;START OF IMPURE AREA
	MOVEM	PP,DPLOC.	;SAVE IT FOR PERF., EXIT., AND KILL.
	MOVEI	AC10,DTSIZ.	;IF NO DISPATCH TABLE,
	JUMPE	AC10,RSET1A	;  DON'T MOVE DOWN ADDRESSES
	HRRZ	PP,.JBOPS	;GET ADDRESS OF DISPATCH TABLE
	SKIPN	PP		;IF ZERO IT MUST BE OLD COMPILER,
	MOVEI	PP,152		;  SO USE 152
	HRLI	PP,DTVAL.	;BUILD XWD FOR BLT
	ADDI	AC10,(PP)	;FINAL DESTINATION ADDRESS
	BLT	PP,-1(AC10)	;MOVE THE ADDRESSES (NON-UUO DISPATCH TABLE
RSET1A:	MOVE	PP,[XWD PFRST.,IFRST.]
	BLT	PP,ILAST.	;THE IO UUO'S
	MOVNI	PP,PPSIZ.	;SET
	MOVSS	PP		;  UP
	HRR	PP,.JBFF	;  PUSH-DOWN POINTER
	MOVEI	AC10,PPSIZ.+1	;SET ASIDE
	ADDB	AC10,.JBFF	;  ENOUGH
	IORI	AC10,1777	;  ROOM
	CAMG	AC10,.JBREL	;  FOR PUSH-DOWN LIST
	JRST	RESET2		;
	CALLI	AC10,11		;MORE CORE IF NECESSARY
	JRST	GETCO1		;ERROR RET

RESET2:	PUSHJ	PP,RSAREN	;INIT .JBSA AND .JBREN
	PUSHJ	PP,OUTBF1	;SETUP TTY BYTE-POINTER AND BYTE-COUNT
	PUSHJ	PP,RSTLNK	;LINK ALL SUB-PROGRAM'S FILE-TABLES
	PUSHJ	PP,SETOVR	;SET UP OVERLAY FILE
	PUSHJ	PP,RSTAB.	;ASSIGN THE  BUFFER AREA

	;SET FLAGS TO TRAP ON
	MOVEI AC0,TRAP.		;INTERUPT ROUTINE ADR
	MOVEM	AC0,.JBAPR	;
	MOVEI	AC0,230000	;PDLOV - MPVIO - NXM
	CALLI	AC0,16		;APRENB UUO
	JRST	1(AC14)		;RETURN

	;HERE TO CHAIN FILE-TABLES OF ALL SUBPROGRAMS TOGETHER
	;POINTERS ARE AS FOLLOWS
	;AC14/	ADR OF SP1	;ADR OF ADR OF "MAIN" PROGRAM 
	;THE FOLLOWING ARE THE SAME FOR ALL SUBPROGRAMS
	;SP1+1/	LST,,FILES.	;FILES. HAS ADR OF FIRST FILE-TABLE
	;LST/	SP2		;ADR OF SUBPROGRAMS CALLED BY SP1
	;LST+1/	SP4		;  .
	;LST+N/	0		;TERMINATES WITH A ZERO

RSTLNK:	MOVEI	AC3,AC3		;THWART THE FIRST LINK
	HRR	AC1,(AC14)	;ADDRESS OF "MAIN" PRG + 1
	HRL	AC2,1(AC1)	;SETUP THE
	HRRI	AC2,FILES.	;    FIXED
	HRRZI	AC4,FILES.	;    PARAMETERS
	BLT	AC2,FIXNUM##-1(AC4); %FILES THRU %PR
RSTL10:	MOVE	AC1,1(AC1)	;ADDRES OF [LIST ,, FILES.]
	HLRZ	AC2,AC1		;ADR OF LIST OF CALLED SUBPROGRAMS
	SKIPGE	AC4,(AC1)	;HAVE WE BEEN HERE BEFORE?
	POPJ	PP,		;YES,  -1 IN LEFT HALF
	JUMPE	AC4,RSTL12	;JUMP IF SUBPRG HAS NO FILE-TABLES 
	SKIPN	FILES.		;HAS FILES. BEEN SETUP YET?
	HRRM	AC4,FILES.	;NO - SO DOIT
	HRRM	AC4,(AC3)	;LINK THIS FILE-TABLE GROUP TO LAST GROUP
RSTL11:	HRRZI	AC3,6(AC4)	;GET ADR OF LINK TO NEXT TABLE
	HRRZ	AC4,(AC3)	;GET THE LINK TO NEXT TABLE
	JUMPN	AC4,RSTL11	;LOOP IF NOT THE LAST TABLE
RSTL12:	HRROS	(AC1)		;MARK THIS FILE-TABLE GROUP DONE

RSTL20:	SKIPN	AC1,(AC2)	;ANY SUBPRGMS?
	POPJ	PP,		;NO -- BACK TO THE LAST SUBPRG OR EXIT
	PUSH	PP,AC2		;SAVE POINTER TO SUBPROGRAM LIST
	PUSHJ	PP,RSTL10	;GO LINK THE FILE-TABLES
	POP	PP,AC2		;RETREIVE LIST POINTER
	SKIPE	1(AC2)		;ANY MORE SUBPRGMS?
	AOJA	AC2,RSTL20	;INCREMENT POINTER AND TRY AGAIN
	POPJ	PP,		;NO--DONE.
	;ASSIGN THE BUFFER AREA.   ***POPJ***

RSTAB.:	PUSHJ	PP,GCHAN	;FIND A FREE CHANNEL
	PUSHJ	PP,SETC1.	;  ASSIGN TO IO UUOS
	SETZM	TEMP.1		;ZERO THE ERROR COUNT
	HRRZ	AC16,FILES.	;FIRST FILE TABLE
	JUMPE	AC16,RET.1	;THERE ARE NO FILES
RSTIFI:	SETZM	TEMP.		;MAX SIZE OF BUF AREA
RSTIF1:	MOVE	AC15,5(I16)	;IF THIS IS FIRST
	TLNN	AC15,BUFLOC	;  TIME THROUGH TABLE,
	PUSHJ	PP,RSTFLG	;REORGANIZE THE FLAGS
	MOVE	FLG,10(I16)	;GET THE FLAGS
	HRLOI	AC15,4077	;#OF DEVICES,,LOC OF FIRST ONE
	AND	AC15,5(I16)	;
	TLZE	AC15,BUFLOC	;IS BUFLOC SET?
	JRST	RSTNFL		;YES-NEXT FILE
	MOVEM	AC15,AC13	;
	TLC	AC13,777777	;MAKE
	AOBJP	AC13, .+1	;KIND OF
	HRR	AC13,AC15	;AN IOWD
	MOVEM	AC13,D.ICD(I16)	;%-<#OF DEVS>,,LOC OF FIRST DEVNAM
RSTDEV:	MOVE	AC3,(AC13)	;SIXBIT /DEVICE NAME/
	CALLI	AC3,4		;DEVCHR UUO
	TLNN	AC3,140610	;SKIP IF A LPT,TTY,PTP,PTR,CDP, OR CDR
	JRST	RSTDE0		;
	TLO	FLG,DDMASC	;FORCE ASCII MODE
	TLZ	FLG,DDMBIN!DDMSIX!DDMEBC	;  FOR THE ABOVE DEVICES
	MOVEM	FLG,10(I16)	;
RSTDE0:	JUMPN	AC3,RSTDE2	;
RSTDE1:	MOVE	AC2,[BYTE(5)25,4,20,13,23,15,14];"NOT A DEVICE OR
	PUSHJ	PP,MSOUT.	;NOT AVAILABLE TO THIS JOB
	AOS	TEMP.1		;COUNT THE ERRORS
	JRST	RSTLOO		;
RSTDE2:	MOVE	AC15,5(I16)	;GET THE IO FLAG
	MOVE	AC12,.JBFF
	HRLM	AC12,D.BL(I16)	;SET BUFFER LOCATION
	MOVE	AC12,(AC13)	;SIXBIT /DEVNAM/
	MOVEM	AC12,UOBLK.+1	;FOR THE INIT BLOCK
	HRLZI	AC12,D.OBH(I16)	;LOC OF OBUF HDR
	TLNE	AC15,IOFILE	;SKIP IF NOT IO
	HRRI	AC12,D.IBH(I16)	;LOC OF IBUF HDR
	MOVEM	AC12,UOBLK.+2	;INIT BLOCK
IFN ISAM,<
	MOVEI	AC1,17		;DUMP MODE
	TLNE	FLG,IDXFIL	;INDEX-FILE?
	HRRZM	AC1,UOBLK.	;YES
>
	XCT	UOPEN.		;********************
	JRST	RSTDE1		;INIT FAILED, ERROR RETURN
	PUSH	PP,.JBFF	;
	TLNE	FLG,IDXFIL	;
	JRST	RSTIDX		;SETUP FOR AN INDEX FILE
	TLNN	AC3,20		;SKIP IF A MTA
	TLNE	FLG,RANFIL+OPNIO ;SKIP IF  NOT RANDOM OR IO
	JRST	RSTDE4		;SETUP FOR NON-STD OR DUMP MODE BUFFERS

RSTDE7:	LDB	AC6,FTBN.	;NUMBER OF BUFFERS
	XCT	UOBUF.		;ALLOCATE **************
	TLNE	AC15,IOFILE	;THE
	XCT	UIBUF.		;BUFFERS **************
RSTDE5:	HLRZ	AC12,D.BL(I16)	;CALCULATE
	SUB	AC12,.JBFF	;THE SIZE
	POP	PP,.JBFF	;
	MOVNS	AC12		;OF THE
RSTDE3:	CAML	AC12,TEMP.	;BUFFER AREA
	MOVEM	AC12,TEMP.	;SAVE SIZE OF LARGER
			;LOOP AGAIN
RSTLOO:
IFN ISAM,<TLNN	FLG,IDXFIL	>
	AOBJN	AC13,RSTDEV	;JUMP IF MORE DEV/FILTAB
	MOVSI	AC15,BUFLOC	;NOTE WE ARE DONE
	IORM	AC15,5(I16)	;% WITH THIS FILE TABLE
	HLRZ	AC1,15(I16)	;
	JUMPE	AC1,RSTNFL	;GET THE NEXT FILE TABLE
	MOVEM	AC1,AC16	;
	JRST	RSTIF1		;SHARES THE SAME BUFFER AREA
RSTNFL:	MOVE	AC12,TEMP.	;INCREASE .JBFF BY
	ADDM	AC12,.JBFF	;THE BUFFER AREA SIZE
	HRRZ	AC16,6(I16)	;LOCATE THE NEXT FILE TABLE
	JUMPN	AC16,RSTIFI	;AND JUMP IF THERE IS ONE.
	SKIPE	TEMP.1		;ANY ERRORS ?
	JRST	KILL.		;YES
	XCT	URELE.		;RELEASE THE CHANNEL

IFN ISAM,<
	;GRAB SPACE FOR THE AUX BLOCK
	SKIPE	MXBUF		;EXIT IF NO INDEXED FILES
	SKIPE	KEYCNV		;SKIP IF RESET UUO
	JRST	RSTXIT		;EXIT - ITS A SORT CALL
	MOVE	AC0,MXBUF	;SIZE OF AUX BLOCK
	MOVE	AC1,.JBFF	;
	HRRZM	AC1,AUXBUF	;LOCATION OF AUX BLK
	PUSHJ	PP,GETSPC	;
	 JRST	GETCO1		;ERROR RETURN

	;SPACE FOR DATA-RECORD-TABLE FOR SPLITTING BLOCKS
	MOVE	AC0,MXBF	;MAX-BLOCKING FACTOR OF ALL IDXFIL'S
	ADDI	AC0,1		;TERMINATOR
	MOVE	AC1,.JBFF	;
	HRRZM	AC1,DRTAB	;
	PUSHJ	PP,GETSPC	;
	 JRST	GETCO1		;ERROR RETURN

	;SPACE FOR INDEX ENTRY WHEN SPLITTING TOP INDEX BLOCK
	MOVE	AC0,MXIE	;SIZE OF LARGEST INDEX ENTRY
	MOVE	AC1,.JBFF	;
	HRRZM	AC1,IESAVE	;LOC OF SAVE AREA
	PUSHJ	PP,GETSPC	;
	 JRST	GETCO1
>
RSTXIT:	LDB	AC2,[POINT 4,UOPEN.,12]	;FREE THE CHANNEL
	PUSHJ	PP,FRECH2	;  AND POPJ
	HRLZI	AC0,377774	;TURN OFF CHAN 0
	SKIPE	TEMP.2		;ANY RERUNS?
	ANDM	AC0,OPNCH.	;YES, DOIT
	POPJ	PP,
	;SETUP FOR NONSTD BUFFERS OR DUMP MODE
RSTDE4:	PUSHJ	PP,OPNWPB	;AC10= WODRS PER LOGICAL BLOCK
	JUMPE	AC5,RSTDE7	;JUMP IF BLOCKING FACTOR IS 0
	ADDI	AC10,3		;   PLUS 3 FOR BOOKEEPING WORDS
	TLNN	AC3,20		;SKIP IF A MTA
	JRST	RSTDE6		;JUMP ITS NOT A MTA
	HLLZ	AC6,D.F1(I16)	;SECOND FLAG REG
	TLNN	AC6,STNDRD	;SKIP IF STANDARD LABELS
	JRST	RSTDE8		;MTA W/NONSTD OR OMITTED LABELS
	CAIGE	AC10,^D16+4	;SBIP"iF RECORD IS GE THE LABEL RECORD
	MOVEI	AC10,^D16+4	;ENSURE LABEL REC WILL FIT IN REC AREA
IFN EBCDIC,<
	TLNN	FLG,DDMEBC	;SKIP IF EBCDIC
	JRST	RSTD80		;ITS NOT
	ADDI	AC10,1		;ADD IN ONE FOR BLOCK HRD-WRD
	CAIGE	AC10,^D20+4	;
	MOVEI	AC10,^D20+4	;LABEL RECORD IS THE LARGEST RECORD
>
RSTDE8:
IFE EBCDIC,<
	TLNN	FLG,DDMEBC	;EBCDIC?
	JRST	RSTD80		;NO
	TTCALL	3,[ASCIZ /EBCDIC NOT IMPLEMENTED,/]
	JRST	RSTERR
RSTD80:
>
IFN EBCDIC,<
	TLNN	FLG,DDMEBC	;EBCDIC?
	JRST	RSTD80		;NO
	TLNN	AC6,STNDRD	;YES - LABELS STANDARD?
	JRST	RSTER1		;NO - ERROR, MUST BE STANDARD
	HRRZ	AC1,5(I16)	;..MAKE SURE TAPE-DRIVE IS 9 CHANNEL..
	MOVE	AC1,(AC1)	;SIXBIT DEVICE NAME FOR
	CALLI	AC1,54		;  DEVSTS
	JRST	RSTD80		;ERROR RET - ASSUME ITS OK
	TRNE	AC1,4		;9 CHANNEL?
	JRST	RSTER2		;NO, 7CH SO ERROR
RSTD80:
>
	TLNN	AC6,NONSTD	;SKIP IF NON-STANDARD LABELS
	JRST	RSTDE9		;
	HLRZ	AC1,11(I16)	;NONSTD LABEL SIZE
	JUMPGE	FLG,RSTD10	;JUMP IF NOT ASCII
	ADDI	AC1,2		;ADD IN "CR-LF" CHARS
	IDIVI	AC1,5		;
RSTD10:	TLNN	FLG,DDMASC	;SKIP IF ASCII
	IDIVI	AC1,6		;
	SKIPE	AC2		;
	ADDI	AC1,1		;CONVERT CHARS TO WORDS
	CAIGE	AC10,3(AC1)	;
	MOVEI	AC10,3(AC1)	;ENSURE LABEL REC WILL FIT IN REC AREA
RSTDE9:	MOVEI	AC1,-3(AC10)	;
	HRRM	AC1,D.LRS(I16)	;SAVE IT FOR OPNNSB
	LDB	AC12,FTBN.	;NUMBER OF ALTERNATES
	IMULI	AC10,2(I12)	;REC TIMES NUMBER OF ALTERNATE BUFFERS
	JRST	RSTD11		;
RSTDE6:	TLNN	AC3,200000	;SKIP IF DEV IS A DSK
	JRSER0		;COMPLAIN
	ADDI	AC10,7		;3+7=12 FLAG WORDS REQD FOR RANDOM OR IO
RSTD11:	ADDB	AC10,.JBFF	;CLAIM THE BUFFER AREA
	CAMLE	AC10,.JBREL	;DO WE NEED MOR COR?
	PUSHJ	PP,GETCOR	;GET MOR COR
	JRST	RSTDE5		;RETURN
IFN EBCDIC ,<
RSTER2:	TTCALL	3,[ASCII /EBCDIC REQUIRES A 9 CHANNEL TAPE DRIVE/]
	JRST	RSTERR
RSTER1:	TTCALL	3,[ASCII /EBCDIC FILES REQUIRE STANDARD LABELS/]
	JRST	RSTERR
>

RSTER0:	TTCALL	3,[ASCIZ /ONLY DSK MAY BE USED FOR RANDOM, IO OR INDEX-SEQ PROCESSING/]
RSTERR:	MOVE	AC2,[BYTE (5)10,31,20]
	PUSHJ	PP,MSOUT.
IFE ISAM,<
RERIT.:	TTCALL	3,[ASCIZ /REWRITE ?/]
	SKIPA
DELET.:	TTCALL	3,[ASCIZ /DELETE ?/]
RSTIDX:	TTCALL	3,[ASCIZ /
TO PROCESS ISAM FILES CBLIO MUST BE REASSEMBLED WITH THE CONDITIONAL
ASSEMBLY SWITCH,ISAM, EQUAL TO A NON-ZERO VALUE./]
	JRST	KILL.
>
IFN ISAM,<
;SETUP FOR AN INDEX FILE

RSTIDX:	PUSHJ	PP,OPNLIX	;IDXFIL FILENAME
	XCT	ULKUP.		;***************
	JRST	RSTID1		;
	MOVEI	AC0,STABL	;
	HRR	AC1,.JBFF	;
	PUSHJ	PP,GETSPC	;
	 JRST	GETCO1		;ERROR RETURN
	HRLI	AC1,-STABL	;
	SUBI	AC1,1		;DUMP MODE IOWD
	SETZ	AC2,		;TERMINATOR
	MOVEI	AC6,1		;LOCATION OF
	HRRM	AC6,UIN.	;  IOWD
	XCT	UIN.		;READ IN STATISTICS BLOCK
	SKIPA	AC12,1+ISPB(AC1)	;INDEX SECTORS / BLK
	JRST	RSTIER		;

	HLRZ	AC2,1(AC1)	;GET FILE FORMAT CODE
	CAIN	AC2,401		;COMPLAIN IF NOT 401
	JRST	RSTID7		;OK
	PUSHJ	PP,MSVID	;OUTPUT VALUE-OF-ID
	TTCALL	3,[ASCIZ/ IS NOT THE INDEX FOR ISAM/]
	PUSHJ	PP,MSFIL.	;OUTPUT FILE NAME AND VID
	PUSHJ	PP,KILL.	;KILL NEVER RETURNS

	;HERE IF LOOKUP FAILURE
RSTID1:	TLNN	FLG,FILOPT	;OPTIONAL FILE?
	JRST	LUPERR		;NO
	HRRZ	AC1,ULBLK.+1	;GET THE ERROR CODE
	TRZ	AC1,777740	;WAS IT FILE NOT FOUND?
	JUMPN	AC1,LUPERR	;EXIT HERE IF OTHER
	POP	PP,.JBFF	;RESTORE THE STACK
	SETOM	D.OPT(I16)	;FILE NOT FOUND - REMEMBER THAT
	JRST	RSTLOO		;  AND SHOOT HIM DOWN AT OPEN TIME

RSTID7:	HLLZS	UIN.		;CLEAR IOWD POINTER
	IMULI	AC12,200	;WRDS / SECTOR
	CAMLE	AC12,MXBUF	;LARGER THAN LARGEST?
	MOVEM	AC12,MXBUF	;YES, SAVE AS NEW LARGEST
	MOVE	AC6,1+MXLVL(AC1)		;NUMBER OF INDEX LEVELS
	ADDI	AC6,2		;PLUS ONE FOR SAT BLK & ONE FOR SPLITING TOP-LEVEL
	IMUL	AC12,AC6	;

	;FIND THE LARGEST INDEX ENTRY SIZE
	MOVE	AC2,1+IESIZ(AC1)
	CAMLE	AC2,MXIE	;
	MOVEM	AC2,MXIE	;

	;FIND THE MAX BLOCKING-FACTOR
	MOVE	AC2,DBF+1(AC1)	;
	CAMLE	AC2,MXBF	;
	MOVEM	AC2,MXBF	;

	MOVE	AC0,1+KEYDES(AC1)	;KEY DESCRIPTION
	LDB	AC6,[POINT 3,AC0,23]	;TYPE OF KEY
	JUMPN	AC6,RSTID2	;BRANCH IF NON-NUMERIC-DISPLAY
	MOVE	AC4,1+IESIZ(AC1)	;INDEX ENTRY BLOCK SIZE
	SUBI	AC4,1		;-2 HDR WRDS, +1 WRD FOR WRAP-AROUND
	IMULI	AC4,3		;RESERVE 3 KEY AREAS
	JRST	RSTID3		;

RSTID2:	MOVEI	AC4,6		;1+1*3
	TRNN	AC6,1		;ODD = 1 WRD,  EVEN = 2 WRDS
	MOVEI	AC4,9		;2+1*3

RSTID3:	ADDI	AC12,2(AC4)	;NUMBER OF WORDS ALLOCATED
	MOVE	AC2,5(I16)
	MOVE	AC2,1(AC2)	;DATA FILE DEVICE NAME
	MOVEM	AC2,UOBLK.+1	;
	XCT	UOPEN.		;**************
	JRST	RSTDE1		;ERROR
	CALLI	AC2,4		;DEVCHR
	TLNE	AC2,200000	;DATA FILE
	TLNN	AC3,200000	;IDX FILE
	JRST	RSTER0		;MUST BE A DSK 

	TRNE	AC0,400000	;
	JRST	RSTID5		;ASCII TEST
	TLNE	FLG,DDMSIX	;BOTH SIXBIT ?
	JRST	RSTID6		;YES
RSTID4:	TTCALL	3,[ASCIZ /DATA-MODE DISCREPANCY/]
	MOVE	AC2,[BYTE (5)10,31,20,4]
	JRST	MSOUT.		;

RSTID5:	TLNN	FLG,DDMASC	;BOTH ASCII ?
	JRST	RSTID4		;NO, ERROR
RSTID6:	PUSHJ	PP,OPNWPB	;RETURNS WRDS/LOGICAL BLOCK IN AC10
	CAMLE	AC10,MXBUF	;
	MOVEM	AC10,MXBUF	;SAVE AS LARGEST AUX BUF
	ADD	AC12,AC10	;
	ADDI	AC12,ITABL	;INDEX TABLE LEN
	MOVE	AC0,AC12	;
	MOVEM	AC0,D.OBH(I16)	;SAVE AMOUNT OF CORE REQUIRED
	PUSHJ	PP,GETSPC	;GRAB SOME CORE AREA
	 JRST	GETCO1		;ERROR RETURN
	SETZM	UOBLK.		;
	JRST	RSTDE5		;RETURN


GETSPC:	ADDB	AC0,.JBFF	;
	CAMG	AC0,.JBREL	;
	JRST	RET.2
	CALLI	AC0,11		;CORE UUO
	POPJ	PP,		;ERROR EXIT
	JRST	RET.2		;NORMAL EXIT

RSTIER:	XCT	UGETS.		;INPUT ERROR DURING RESET UUO
	PUSHJ	PP,IOERM1	;
	MOVE	AC2,[BYTE (5)35,4,10,31,20,2]
	JRST	KILL.		;&KILL.
>
		;SUBROUTINE TO SET UP OVERLAY FILE

SETOVR:	SKIPN	AC1,OVRFN.	;ANY FILE TO BE OPENED
	POPJ	PP,		;NO--RETURN

	HRLZI	AC0,377774	;TURN OFF CHAN 0
	ANDM	AC0,OPNCH.	;DOIT
	HRROI	AC0,-1		;DSK = -1
	HRLZI	AC3,(SIXBIT /DSK/) ;
SETOV1:	MOVEI	AC2,14+1B30	;SET UP DEVICE
	HRRZI	AC4,OVRBF.	;
	OPEN	AC2		;INIT 
	JRST	SETOV4		;
	MOVSI	AC2,(SIXBIT "OVR")
	SETZB	AC3,AC4		;
	LOOKUP	AC1		;
	JRST	SETOV5		;LOOKUP FAILED
	INBUF	2		;GET 2 BUFFERS
	MOVEI	AC1,OVRIX.	;
	PUSHJ	PP,SETOV2	;
	MOVEI	AC1,OVRIX.+200	;

SETOV2:	IN
	SKIPA	AC2,OVRBF.	;
	JRST	SETOV6		;
	MOVSI	AC2,2(AC2)	;
	HRR	AC2,AC1		;
	BLT	AC2,177(AC1)	;
	POPJ	PP,

SETOV4:	TTCALL	3,[ASCIZ "CANNOT INITIALIZE OVERLAY DEVICE"]
	JRST	KILL.

SETOV5:	HRLZI	AC3,(SIXBIT /SYS/) ;TRY SYS IF DSK FAILS
	AOJE	SETOV1		;
	TTCALL	3,[ASCIZ "CANNOT FIND OVERLAY FILE"]
	JRST	KILL.

SETOV6:	TTCALL	3,[ASCIZ "INPUT ERROR ON OVERLAY DEVICE"]
	JRST	KILL.

GETCOR:	CALLI	AC10,11		;CALLI CORE
	SKIPA			;ERROR RETURN
	POPJ	PP,		;NORMAL SO RETURN
GETCO1:	PUSHJ	PP,GETCO9
	JRST	KILL.

GETCO9:	TTCALL	3,[ASCIZ/INSUFICIENT CORE FOR BUFFER REQUIREMENTS/]
	POPJ	PP,
			;ROUTINE TO REORGANIZE THE FLAGS
RSTFLG:	MOVE	FLG,10(I16)	;GET FLAGS
	HRLZI	AC15,4300		;
	AND	AC15,FLG		;RRUNER & RRUNRC
	LDB	AC1,[POINT 2,FLG,1]
	HLLZ	AC2,FLGTAB(AC1)	;DEVICE DATA MODE
	TLZ	AC2,037777	;
	IOR	AC15,AC2		;
	LDB	AC1,[POINT 2,FLG,15]
	HLLZ	AC2,FLGTAB(AC1)	;CORE DATA MODE
	TLZ	AC2,777707	;
	IOR	AC15,AC2		;
	LDB	AC1,[POINT 2,FLG,17]
	HLLZ	AC2,FLGTAB(AC1)	;ACCESS MODE
	TLZ	AC2,777770	;
	IOR	AC15,AC2		;

	TLNE	FLG,20		;FILOPT?
	TRO	AC15,FILOPT	;
	TLNE	FLG,100000	;NONSTD?
	TRO	AC15,NONSTD	;
	TLNE	FLG,40000	;STNDRD?
	TRO	AC15,STNDRD	;
	HLLM	AC15,10(I16)	;SAVE IT
	HRLM	AC15,D.F1(I16)	;FLG1
	TLNE	FLG,RRUNER!RRUNRC	;RERUNING?
	SETOM	TEMP.2		;YES, REMEMBER TO TURN OFF CHAN 17
	POPJ	PP,		;

FLGTAB:	200022,,0
	100011,,0
	400044,,0
	040000,,0

			;TRAP INTERUPT ROUTINE
TRAP.:	MOVE	AC0,.JBCNI	;APR STATUS
	TRNE	AC0,20000
	TTCALL	3,[ASCIZ/MEMORY PROTECTION VIOLATION AT USER LOC /]
	TRNE	AC0,10000
	TTCALL	3,[ASCIZ/NON-EX-MEM REQUEST AT USER LOC /]
	TRNE	AC0,200000
	JRST	TRAP1		;PDLOV
TRAP0:	HRLO	AC12,.JBTPC	;THE GUILTY LOCATION
	PUSHJ	PP,PPOUT2.	;OUTPUT THE LOC
	JRST	KILL.		;AND KILL

TRAP1:	TTCALL	3,[ASCIZ/PUSH-DOWN-LIST OVERFLOW AT /]
	JRST	TRAP0

	;ULOSE. IS THE ERROR EXIT FOR A UUO CALL TO A ROUTINE
	;THAT WAS NOT LOADED. THE RUN IS TERMINATED VIA KILL.
ULOSE.:	TTCALL	3,[ASCIZ /ENCOUNTERED A UUOCALL FOR A ROUTINE THAT WAS NOT LOADED
/]
	SKIPA		;TO KILL.

	;GOTO IS THE ERROR EXIT FOR UNALTERED "GOTO"
	;STATEMENTS WHICH DID NOT PROVIDE AN OBJECT PARAGRAPH NAME.
GOTO.:	TTCALL 3,[ASCIZ /ENCOUNTERED AN UNALTERED GOTO WITH NO DESTINATION
/]
	;KILL TYPES OUT THE LOCATION OF THE LAST COBOL UUO,
	;STOPS ALL IO AND EXITS TO THE MONITOR.

KILL.:	PUSHJ	PP,VEROUT	;TYPE THE VERSION NUMBER
	TTCALL	3,[ASCIZ /?/]
	SKIPE	DPLOC.		;IF COBOL V3 OR LATER,
	PUSHJ	PP,@TRAC1.	;  CALL BTRAC. IN TRACE ROUTINE
	PUSHJ	PP,PPOUT1	;TYPE THE LOCATION OF THE LAST UUOCALL
	CALLI	12		;CLOSE ALL FILES AND EXIT HERE

	;STOPR. IS CALLED WITH A "PUSHJ PP,STOPR."  ALL FILES ARE
	;CLOSED VIA COBOL CLOSE UUOS AND A CALLI EXIT IS EXECUTED.

STOPR.:	HRRZ	AC16,FILES.	;LOOP THROUGH THE FILE TABLES
	JUMPE	AC16,STOPR2	;DONE
STOPR1:	HRLI	AC16,001040	;STANDARD CLOSE UUO
	MOVE	FLG,10(AC16)	;GET THE FLAGS
	TLNE	FLG,OPNIN+OPNOUT;  IF THE FILE IS OPEN
	PUSHJ	PP,CLOSE.	;  CLOSE IT
	HRRZ	AC16,6(AC16)	;NEXT FILE
	JUMPN	AC16,STOPR1	;LOOP
STOPR2:	CALLI	12		;CALLI EXIT
	;TYPE THE VERSION NUMBER "LIBOL N(M)"
VEROUT:	SKIPN	AC12,.JBVER	;GET VERSION NUMBER
	JRST	VEROU1		;EXIT IF NOT THERE
	TTCALL	3,[ASCIZ /
LIBOL /]
	MOVEI	AC0,4		;
	PUSHJ	PP,NUMOUT	;THE VERSION NUMBER
	MOVEI	AC0,6		;
	HRLZ	AC12,.JBVER	;
	JUMPE	AC12,VEROU1	;DONE IF NO EDIT NUMBER
	MOVEI	C,"("		;
	PUSHJ	PP,OUTCH.	;
	PUSHJ	PP,NUMOUT	;THE EDIT NUMBER
	MOVEI	C,")"		;
	PUSHJ	PP,OUTCH.	;
VEROU1:	JRST	DSPL1.		;"CRLF" AND EXIT

NUMOUT:	MOVEI	C,6		;HALF AN ASCII ZERO
	LSHC	C,3
	TRNN	C,7		;SKIP LEADING ZEROES
	SOJG	AC0,NUMOUT
	JUMPL	AC0,RET.1
	PUSHJ	PP,OUTCH.
	MOVEI	C,6
	LSHC	C,3
	SOJG	AC0,.-3
	POPJ	PP,

	;STOP. IS CALLED WITH A "PUSHJ PP,STOP."  AFTER THE OPERATOR
	;TYPES "CONTINUE" IT RETURNS TO THE CALLING ROUTINE

STOP.:	TTCALL	3,[ASCIZ / TYPE CONTINUE TO PROCEED .../]
	CALLI	1,12		;WAIT FOR CONT
	POPJ	PP,		;

	;PPOUT.:  TYPES OUT VALUE MINUS ONE OF THE RIGHT
	;HALF OF THE LAST ENTRY ON THE PUSH DOWN STACK

PPOUT1:	TTCALL	3,[ASCIZ /LAST COBOL UUO CALLED FROM USER LOCATION /]
	SKIPA	AC12,UOCAL.	;RETURN FOR THE LAST UUO CALL,
PPOUT.:	MOVE	AC12,-1(PP)	;PREVIOUS PUSHJ'S RETURN
	HRLOI	AC12,-1(AC12)	;THE CALL IS ONE LESS THAN THE RETURN
PPOUT2:	MOVEI	C,6		;HALF OF AN ASCII ZERO-60
	LSHC	C,3		;APPEND THE OCTAL NUMBER
	PUSHJ	PP,OUTCH.	;DEPOSIT IT IN THE TTY BUFFER
	TRNE	AC12,-1		;HAVE WE SEEN SIX NUMBERS?
	JRST	PPOUT2		;NO, LOOP
	JRST	DSPL1.		;YES, APPEND "CRLF", THEN EXIT
SUBTTL	SEEK-UUO

;A SEEK UUO LOOKS LIKE:
;002240,,ADR	ADR = FILE TABLE ADDRESS
;CALL+1:	;POPJ RETURN

SEEK.:	MOVE	FLG,10(I16)	;FLAG REGISTER
	TLNE	FLG,RANFIL	;SKIP IF NOT A RANDOM FILE
	TLNN	FLG,OPNIN!OPNOUT ;SKIP IF RANDOM FILE IS OPEN
	POPJ	PP,		;EXIT TO ***ACP***
	HLRZ	I12,D.BL(I16)	;SET UP FOR FLIMIT
	PUSHJ	PP,FLIMIT	;CHECK THE FILE LIMITS
				;INVALID KEY RETURNS TO ***ACP***
	MOVE	AC1,AC4		;ACTUAL KEY
	PUSHJ	PP,SETCN.	;SET UP CHANNEL NUMBER
	XCT	USETI.		;
	XCT	USEEK.		;SEEK UUO
	POPJ	PP,		;EXIT TO  ***ACP***


	;FORCE A CALL TO RRDMP
RENDP:	SETOM	REDMP.		;
	JRSTF	@.JBOPC		;CONTINUE

	;RESTORE .JBSA, .JBREN - DESTROYED BY RERUN'S GETSEG

RSAREN:	HRR	AC2,RESET1
	HRRM	AC2,.JBSA
	MOVEI	AC2,RENDP
	MOVEM	AC2,.JBREN
	MOVEI	AC2,EDIT
	HRLI	AC2,VERSION
	HRRM	AC2,.JBVER
	POPJ	PP,
SUBTTL	DISPLAY-UUO

;CALLING SEQUENCE IS PUSHJ PP,DSPLY. WITH THE CALLING UUO IN AC 16.
;THE UUO'S EFFECTIVE ADDRESS CONTAINS A MODIFIED BYTE POINTER TO THE
;ASCII CHARACTER STRING.  MODIFICATIONS FOLLOW:
;	IF BIT 6 IS SET LEADING SPACES AND HOR-TABS ARE SUPPRESSED.
;	IF BIT 7 IS SET A "CRLF" IS APPENDED TO THE CHARACTER STRING.
;	BITS 8-17 CONTAIN THE NUMBER OF CHARACTERS TO BE DISPLAYED.
;THE ONLY ERROR EXIT IS A CALL TO STOP. CAUSED BY "TELETYPE OUTPUT
;ERROR".  A NORMAL RETURN IS A POPJ PP,.
;MODIFIED ACS ARE: 17,15,11,7,6,AND 4.

;AC16=		;THE CALLING UUO
;AC15=		;UUO'S OPERAND
;AC6=		;CHARACTER COUNT
;AC4=		;BLANK COUNT
;AC12		;MUST NOT BE USED

;FOLLOWING BITS ARE IN LEFT HALF OF FLG
BIT6=	  4000	;NUMERIC, SUPPRESS LEADING SPACES AND TABS
BIT7=	  2000	;LAST FIELD, APPEND "CRLF"

DSPLY.:	SKIPE	TTYOPN		;IS THERE A TTY FILE OPEN?
	PUSHJ	PP,DSPTO	;YES, DUMP THE BUFFER BEFORE DISPLAYING
	MOVE	AC15,(I16)	;GET DISPLAY OPERAND
	MOVE	FLG,AC15	;SAVE IT FOR THE FLAGS
	LDB	AC6,DOPFS.	;NUMBER OF CHARS. TO BE DISPLAYED
	TLZ	AC15,7777	;
	TLO	AC15,700	;(AC15) IS BYTE POINTER TO CHARS.
	TLNE	FLG,BIT7	;APPEND CR-LF AT END?
	JRST	DSPL2		;  YES
	ILDB	C,AC15		;GET A CHARACTER.
	SKIPE	C		;DONT PASS NULLS BUT COUNT THEM
	PUSHJ	PP,OUTEST	;OUTPUT A CHAR.
	SOJG	AC6,.-3		;LOOP IF NOT DONE.
	JRST	OUTBF.		;DUMP THE BUFFER AND EXIT.
DSPL2:	SETZ	AC4,		;CLEAR THE BLANK COUNT
DSPL23:	ILDB	C,AC15		;GET A CHARACTER
	CAIN	C,040		;A BLANK?
	AOJA	AC4,DSPL21	;  YES
	JUMPE	AC4,DSPL22	;JUMP IF NO ACCUMULATED BLANKS
	MOVEI	C,040		;OUTPUT BLANKS
	PUSHJ	PP,OUTEST	;
	SOJG	AC4,.-2		;LOOP
	LDB	C,AC15		;RESTORE ORIGINAL CHARACTER
DSPL22:	SKIPE	C		;COUNT NULLS BUT DONT OUTPUT THEM
	PUSHJ	PP,OUTEST	;OUTPUT THE CHARACTER
DSPL21:	SOJG	AC6,DSPL23	;LOOP
DSPL1.:	MOVEI	C,15		;APPEND CR-LF
	PUSHJ	PP,OUTCH.	;	.
	MOVEI	C,12		;	.
	PUSHJ	PP,OUTCH.	;	.
	JRST	OUTBF.		;DUMP BUFFER AND EXIT.

DSPTO:	PUSH	PP,AC16		;SAVE AC16
	MOVE	AC16,TTYOPN	;GET FILE-TABLE ADR FOR ERROR ROUTINES
	PUSHJ	PP,SETCN.	;SETUP IO CHANNEL
	PUSHJ	PP,WRTOUT	;DUMP THE BUFFER
	POP	PP,AC16		;RESTORE
	POPJ	PP,		;EXIT

OUTEST:	TLNN	FLG,BIT6	;SUPPRESS LEADING SPACES?
	JRST	OUTCH.		; NO.
	CAIE	C,40		; YES, ARE THERE ANY?
	CAIN	C,11		;
	POPJ	PP,		;	YES.
	TLZA	FLG,BIT6	;	NO, AND NONE FOLLOWING.
OUT6B.:	ADDI	C,40		;CONVERT A 6IXBIT CHAR
OUTCH.:	IDPB	C,TTOBP.	;DEPOSIT CHAR. IN BUFFER.
	SOSLE	TTOBC.		;DUMP THE BUFFER?
	POPJ	PP,		; NO.
	;OUTPUT A TTY BUFFER.  ***POPJ***
OUTBF.:	SETZ	C,		;ASCIZ TERMINATOR
	IDPB	C,TTOBP.	;
	TTCALL	3,TTOBF.	;DUMP THE BUFFER
OUTBF1:	MOVE	C,[POINT 7,TTOBF.]
	MOVEM	C,TTOBP.	;INITIALIZE THE BYTE-POINTER
	MOVEI	C,^D132		;A 132 CHAR BUFFER
	MOVEM	C,TTOBC.	;INITIALIZE THE BYTE-COUNT
	POPJ	PP,		;

	;RETURN A CHARACTER IN C
	;IGNORE "CARRIAGE-RETURN"
	;SKIP EXIT IF NOT AN END-OF-LINE CHAR
	;POPJ IF EOL, EOL = LF, VT, FF OR ALT-MODE
GETCH.:	TTCALL	2,C		;SKIP IF A CHAR IS RETURNED IN C
	TTCALL	4,C		;INPUT A LINE, FIRST CHAR TO C
	CAIN	C,15
	JRST	GETCH.
IFN ALTMOD,<
	CAIN	C,33
	JRST	GETCH1
>
	CAIG	C,14
	CAIGE	C,12
	JRST	RET.2
GETCH1:	MOVEI	C,12
	POPJ	PP,
SUBTTL	OPEN-UUO

	;AN OPEN UUO LOOKS LIKE:
	;001000,,ADR	WHERE ADR = FILE TABLE ADDRESS
	;BIT9  =1	OPEN FOR OUTPUT
	;BIT10 =1	OPEN FOR INPUT
	;BIT11 =1	DON'T REWIND
	;BIT12 =0	ALWAYS 0 (VS. 1 = CLOSE)
	;CALL+1:	POPJ RETURN


	;MAKE PRELIMINARY CHECKS:  ALREADY OPEN, OPTIONAL FILE PRESENT,
	;ANOTHER FILE USING SHARED BUFFER AREA  ***OPNDEV***

OPEN.:	TLO	AC16,OPEN	;OPEN-UUO
	MOVE	FLG,10(I16)
	HLLZ	FLG1,D.F1(I16)	;MORE FLAGS
	TLNN	FLG,OPNIN+OPNOUT ;IS THE FILE OPEN?
	JRST	OPNLOC		;NO
	HRLZI	AC2,(BYTE (5)10,2,3) ;FCBO,AO.
	JRST	MSOUT.		;ONLY CLOSED FILES MAY BE OPENED
OPNLOC:	SETZM	D.RP(I16)	;INITIALIZE THE RECORD SEQUENCE NUMBER
	MOVE	AC5,D.LF(I16)	;
	TLNN	AC5,LOCK	;SKIP IF THE FILE IS LOCKED
	JRST	OPNOPT		;
	TTCALL	3,[ASCIZ /LOCKED /]
	HRLZI	AC2,(BYTE(5)10,2,4)
	JRST	MSOUT.		;EXIT, THE FILE IS LOCKED
OPNOPT:	TLNE	AC16,400	;SKIP IF NOT OUTPUT
	TLO	FLG,OPNOUT	;
	TLNE	AC16,200	;SKIP IF NOT INPUT
	TLO	FLG,OPNIN	;
	TLNE	FLG1,FILOPT	;IS FILE OPTIONAL?
	JRST	OPNOP		;YES. RETURNS ONLY IF PRESENT
OPNSBA:	PUSHJ	PP,DEVIOW	;RESET THE DEVICE IOWD
	TLNE	FLG,RANFIL	;SKMFILE
	PUSHJ	PP,OPNSFL	;STORE THE FILE LIMITS SO HE CAN'T DIDDLE
	HLRZ	AC4,15(I16)	;FILTAB THAT SHARES THE SAME BUFFER
OPNSB1:	JUMPE	AC4,OPNDEV	;JUMP IF NO ONE SHARES
	CAIN	AC4,(I16)	;HAVE WE CHECKED ALL "SBA" FILTAB'S
	JRST	OPNDEV		;YES
	HLL	AC4,10(AC4)	;GET THE FLAGS
	TLNE	AC4,030000	;SKIP IF ANY FILES ARE NOT OPEN
	JRST	OPNSB2		;GIVE AN ERROR MESSAGE
	HLRZ	AC4,15(AC4)	;GET NEXT "SBA FILTAB"
	JRST	OPNSB1		;+LOOP
OPNSB2:	MOVE	AC5,AC4		;MSOUT. USES AC4
	MOVE	AC2,[BYTE (5)10,31,20,2,1,14]
	PUSHJ	PP,MSOUT.
	HRLZI	AC2,(BYTE (5)10,31,20)
	HRR	AC16,AC5
	JRST	MSOUT.		;SOME OTHER FILE IS USING OUR BUFFER AREA

OPNOP:	TLNE	FLG,OPNOUT	;SKIP IF NOT OUTPUT
	JRST	OPNSBA		;OUTPUT FILES ARE NOT OPTIONAL
	TTCALL	3,[ASCIZ /IS /]	;OPTIONAL FILE PRESENT?
	PUSHJ	PP,MSFIL.
	TTCALL	3,[ASCIZ / PRESENT? .../]
	PUSHJ	PP,YES.NO	;SKIP RETURN IF "NO" ANSWER
	JRST	OPNOP1		;YES
	TLO	FLG,NOTPRS	;NO, "NOT PRESENT"
	TLZ	FLG,OPNIN	;NOTE THAT IT'S NOT OPEN
	MOVEM	FLG,10(I16)	;%SAVE THE FLAG WORD
	POPJ	PP,		;RETURN TO MAIN LINE *EXIT************

OPNOP1:	TLNN	FLG,IDXFIL	;ISAM FILE?
	JRST	OPNSBA		;NO
	MOVE	AC1,D.OPT(I16)	;WERE THE BUFFERS SETUP AT RESET TIME?
	AOJN	AC1,OPNSBA	;EXIT HERE IF THEY WERE
	TTCALL	3,[ASCIZ /BUT FILE WAS NOT PRESENT AT RESET TIME SO NO BUFFERS WERE ALLOCCATED/]
	PUSHJ	PP,KILL.	;AND DONT RETURN

YESNO:	TTCALL	11,0		;CLEAR THE BUFFER
	TTCALL	3,[ASCIZ /TYPE YES OR NO
/]
YES.NO:	MOVE	AC5,[POINT 7,[ASCIZ /ES/],]
	PUSHJ	PP,GETCH.
	  JRST	.-1

	CAIE	C,"Y"
	JRST	YESNO2
YESNO1:	PUSHJ	PP,GETCH.
	  POPJ	PP,		;IS THE "YES" RETURN
	ILDB	AC4,AC5
	CAMN	AC4,C
	JRST	YESNO1
	JRST	YESNO
YESNO2:	MOVE	AC5,[POINT 7,[ASCIZ /NO/],]
YESNO3:	ILDB	AC4,AC5
	CAME	AC4,C
	JRST	YESNO
	PUSHJ	PP,GETCH.
	  JRST	RET.2		;THE NO RETURN
	JRST	YESNO3
	;SETUP DEVICE IOWD
DEVIOW:	HRLOI	AC0,77		;
	AND	AC0,5(I16)	;
	TLC	AC0,-1		;
	AOBJP	AC0,.+1		;
	HRR	AC0,5(I16)	;
IFN ISAM,<
	TLNE	FLG,IDXFIL	;IF INDEX FILE
	AOBJP	AC0,.+1		;  POINT AT DATA DEVICE
>
	MOVEM	AC0,D.ICD(I16)	;
	POPJ	PP,		;
	;SET THE FILE LIMIT CLAUSES IN THE FILE-TABLE.  ***POPJ***

OPNSFL:	LDB	AC5,FTFLC	;NUMBER OF FILE LIMIT CLAUSES
	JUMPE	AC5,RET.1	;RETURN IF NONE
	MOVNS	AC5		;
	HRL	AC1,AC5		;
	LDB	AC5,VERNO	;COMPILER'S VERSION NUMBER
	HRRI	AC1,22(I16)	;IOWD NUMBER OF,, FILE LIMIT
	CAIL	AC5,3		;VERSION 0 - 2 = 22(I16)
	HRRI	AC1,31(I16)	;VERSION 3= 31(I16)
	HLR	I12,D.BL(I16)	;PICK UP THE BUFFER LOCATION
	MOVEM	AC1,10(I12)	;

OPNSF1:	MOVE	AC5,(AC1)	;LIMIT,,LIMIT
	MOVE	AC6,(AC5)	;
	MOVSS	AC5		;
	MOVE	AC4,(AC5)	;
	CAMLE	AC4,AC6		;SKIP IF AC4 IS THE LOW LIMIT
	EXCH	AC4,AC6	;
	MOVEM	AC4,1(AC1)	;LOW LIMIT
	MOVEM	AC6,2(AC1)	;HIGH LIMIT
	ADDI	AC1,2		;ACCOUNT FOR TWO WORDS
	AOBJN	AC1,OPNSF1	;GO AGAIN IF YOU CAN
	POPJ	PP,		;
	;GET DEVICE CHARACTERISTICS AND CHECK IF DEVICE CAN DO
	;REQUESTED IO FUNCTIONS  ***OPNCHN***
	;ENTRY POINT FOR READ GENERATED CLOSE GENERATED OPEN.  ***READEF+N***

OPNDEV:	SETZM	D.OE(I16)	;CLEAR NUMBER OF OUTPUTS
	SETZM	D.IE(I16)	;  NUMBER OF INPUTS
	PUSHJ	PP,DEVCHR	;GET THE DEVICE CHAR.
	TLNE	AC13,40		;SKIP IF NOT AVAILABLE TO JOB
	JRST	OPNDE2
	MOVE	AC2,[BYTE (5)10,2,4,20,15]	;FCBO,DINATTJ.
	JRST	MSOUT.

OPNDE2:	TLNN	AC13,200000	;SKIP IF A DSK
	TRNN	AC13,200000	;SKIP IF DEV IS INITED
	JRST	OPNDE6
	MOVE	AC2,[BYTE (5)10,2,4,20,16]	;FCBO,DIATAF.
	JRST	MSOUT.

OPNDE6:	TLNN	FLG,OPNIO	;SKIP IF IO IS REQUESTED
	JRST	OPNDE7		;NEXT TEST
	TLNN	AC13,200000	;SKIP IF DEVICE IS A DSK
	SKIPA	AC2,[BYTE (5)10,2,4,20,17]
	JRST	OPNCHN		;FIND A FREE CHANNEL
	JRST	MSOUT.
OPNDE7:	TLNE	FLG,OPNIN	;SKIP IF NOT AN INPUT REQUEST
	TLNE	AC13,2		;SKIP IF DEVICE CANNOT DO INPUT
	JRST	OPNDE8		;NEXTEST
	MOVE	AC2,[BYTE (5)10,2,4,20,21]
	JRST	MSOUT.		;TYPE AN ERROR MESSAGE + KILL
OPNDE8:	TLNE	FLG,OPNOUT	;SKIP IF NOT AN OUTPUT REQUEST
	TLNE	AC13,1		;SKIP IF DEVICE CANNOT DO OUTPUT
	JRST	OPNCHN		;FIND A FREE CHAN
	MOVE	AC2,[BYTE (5)10,2,4,20,22]
	JRST	MSOUT.

DEVCHR:	MOVE	AC13,D.ICD(I16)	;ADR OF DEV. NAME
	MOVE	AC13,(AC13)	;SIXBIT/DEVICE NAME/
	MOVEM	AC13,UOBLK.+1	;FOR OPEN
	CALLI	AC13,4		;DEVCHR UUO
	MOVEM	AC13,D.DC(I16)	;SAVE THE CHARACTERISTICS
	SKIPE	AC13
	POPJ	PP,
	MOVE	AC2,[BYTE (5)10,2,4,20,13]	;FCBO,DINAD.
	JRST	MSOUT.
	;FIND A FREE DEVICE CHANNEL AND SETUP THE BUFFERS
	;XCT OPEN, INBUF AND/OR OUTBUF  ***OPNBSI***

OPNCHN:	PUSHJ	PP,GCHAN	;LOAD AC5 WITH A CHANNEL NUMBER
	DPB	AC5,FTCN.	;SAVE IT
IFN ISAM,<
	TLNN	FLG,IDXFIL	;INDEX FILE ?
	JRST	OPNCH1		;NO
	PUSHJ	PP,GCHAN	;
	HLRZ	I12,D.BL(I16)	;
	HRRZM	AC5,ICHAN(I12)	;SAVE INDEX FILE CHAN NO.
>
OPNCH1:	PUSHJ	PP,SETC1.	;DISTRIBUTE THE CHANNEL NUMBER
	TLNE	FLG,DDMASC	;SKIP IF NOT ASCII
	TDZA	AC6,AC6		;ASCII MODE AND SKIP
	MOVEI	AC6,14		;PERHAPS BINARY
	TLNE	FLG,RANFIL!OPNIO!IDXFIL ;SKIP IF BUFFERED IO
	MOVEI	AC6,17		;DUMP MODE
	HRRM	AC6,UOBLK.	;UOBLK.+1 SET AT DEVCHR
	HRLI	AC6,D.OBH(I16)	;OUTPUT BUFFER HEADER
	HRRI	AC6,D.IBH(I16)	;INPUT BUF HDR
	MOVEM	AC6,UOBLK.+2
IFN ISAM,<
	TLNN	FLG,IDXFIL	;ISAM ?
	JRST	OPNCH3		;NO
	MOVE	AC1,5(I16)	;ADR
	MOVE	AC1,(AC1)	;IDX DEVICE NAME
	MOVEM	AC1,UOBLK.+1	;
OPNCH3:	>
	XCT	UOPEN.		;OPEN THE DEVICE ***************
OPNCH4:	SKIPA	AC2,[BYTE (5)25,4,20,13,23,15]
	SKIPA			;NORMAL RETURN
	JRST	MSOUT.		;DINAD OINATTJ.
	PUSHJ	PP,OPNWPB	;RETS LOGICAL BLOCK SIZE IN AC10, BLKFTR IN AC5
	LDB	AC6,FTBN.	;NUMBER OF ALTERNATE BUFFERS (FOR INBUF X,2(AC6))
	TLNE	AC13,20		;SKIP IF NOT A MTA
	JUMPN	AC5,OPNNSB	;NON STANDARD BUFFER SIZE
IFN ISAM,<
	TLNE	FLG,IDXFIL	;ISAM ?
	JRST	OPNIDX		;YES
>
	TLNE	FLG,OPNIO+RANFIL ;OPNIO=IOFILE
	JRST	OPNRIO		;RANDOM OR IO DUMP MODE BUFFERS
	PUSH	PP,.JBFF
	HLRZ	AC11,D.BL(I16)	;BUFFER LOCATION
	MOVEM	AC11,.JBFF
	TLNE	FLG,OPNIN	;INPUT?
	XCT	UIBUF.		;**********
	TLNE	FLG,OPNOUT	;OUTPUT?
	XCT	UOBUF.		;**********
	POP	PP,.JBFF	;RESTORE .JBFF
OPNCH2:	TLNE	AC13,4		;SKIP IF NON-DIRECTORY DEVICE
	TLNE	FLG1,STNDRD	;SKIP IF NOT STANDARD LABELS
	JRST	OPNBSI		;SET THE BYTE SIZE
	MOVE	AC2,[BYTE (5)10,2,4,26]	;FCBO,DDMHSL
	JRST	MSOUT.
	;SET UP NON-STD MTA BUFFERS (SIZE OF LOGICAL BLOCK).  ***OPNCH2***

OPNNSB:	ADDI	AC6,2		;ALTERNATE PLUS 2 DEFAULT BUFFERS
	TLNE	FLG1,STNDRD+NONSTD ;SKIP IF OMITTED LABELS
	HRRZ	AC10,D.LRS(I16)	;IN CASE LABEL IS GE TO REC AREA
	HLRZ	AC4,D.BL(I16)	;BUFFER LOCATION
	ADDI	AC4,1		;BUF1+1
	HRLI	AC4,400000	;   AND NEVER WAS REFERENCED
	MOVEM	AC4,D.IBH(I16)	;INPUT HEADER
	MOVEM	AC4,D.OBH(I16)	;OUTPUT HEADER
	HRR	AC2,AC4		;BUF1+1
	HRLI	AC2,1(AC10)	;SIZE+1,,BUF1+1
	SKIPA	AC3,AC4		;BUF1+1
OPNNS1:	ADDI	AC3,3(AC10)	;LOCATION OF NEXT LINK
	ADDI	AC2,3(AC10)	;SIZE+2,,<BUF1+1+SIZE+3>
	MOVEM	AC2,(AC3)	;SIZE+2,,BUF2+1
	SOJG	AC6,OPNNS1	;LOOP IF ANY MORE BUFFERS
	HRRM	AC4,(AC3)	;LAST BUFFER CLOSES THE RING (BUF1+1)
	ADDI	AC4,1		;BUF1+2
	HRRM	AC4,D.IBB(I16)	;INPUT HEADER BYTE POINTER
	HRRM	AC4,D.OBB(I16)	;OUTPUT H...
	JRST	OPNCH2		;RETURN TO MAIN LINE

	;AC10 = WORDS PER LOGICAL BLOCK
	;INITIALIZE DUMP MODE BUFFERS FOR RANDOM AND IO.  ***OPNCON***

OPNRIO:	HLRZ	I12,D.BL(I16)	;BUFFER LOCATION
	MOVNM	AC10,AC6	;0,,-N
	HRLI	AC6,10(I12)	;LOC-1,,-N
	MOVSM	AC6,(I12)	;-N,,LOC-1
	SETZM	1(I12)		;IOWD TERMINATOR
	SETZM	6(I12)		;NO ACTIVE DATA IN BUFFER
	SETZM	3(I12)		;NO INPUTS DONE FOR THIS FILE
	SETOM	7(I12)		;LAST UUO WAS A WRITE
	MOVEI	AC6,11(I12)	;FIRST DATA WORD
	HRLI	AC6,440700	;  AN ASCII BYTE POINTER
	TLNN	FLG,DDMASC	;SKIP IF DEVICE DATA MODE IS ASCII
	TLZ	AC6,100		;MAKE SIZE 646BIT
	MOVEM	AC6,2(I12)	;
	MOVEM	AC6,4(I12)	;BYTE POINTER TO THE FIRST RECORD
	JRST	OPNCON		;RET

IFN ISAM,<
	;SETUP INDEX FILE BUFFER AND TABLE AREAS

OPNIDX:	SETZM	IOWRD(I12)	;CLEAR THE FIRST WORD OF INDEX TABLE
	HRRI	AC0,USOBJ+1(I12)  ;TO
	HRLI	AC0,USOBJ(I12)	;FROM,,TO
	HRRZI	AC1,ITABL-15+ICHAN(I12)  ;UNTIL
	BLT	AC0,(AC1)	;CLEAR REST OF INDEX TABLE
	PUSHJ	PP,OPNLIX	;INDEX FILE-NAME TO LOOKUP BLOCK
	XCT	ULKUP.		;LOOKUP
	JRST	LUPERR		;ERROR
	TLNN	FLG,OPNOUT!OPNIO  ;OPEN FOR UPDATING?
	JRST	OPNI01		;NO
OPNI00:	TLO	FLG1,EIX	;ENTER OF .IDX FILE IN PROGRESS
	PUSHJ	PP,OPNEIX	;INDEX FILE-NAME TO ENTER BLOCK
	XCT	UENTR.		;ENTER, FOR UPDATING
	JRST	ENRERR		;ERROR
	TLZ	FLG1,EIX	;FREE THIS BIT FOR "RIVK" FLAG
OPNI01:	HRLZI	AC1,STABL	;STATISTICS BLOCK LEN
	MOVNS	AC1		;
	HRR	AC1,I12		;
	SUBI	AC1,1		;DUMP MODE IOWD
	MOVEM	AC1,IOWRD+14(I12)	;SAVE IN IOWRD TABLE
	SETZ	AC2,		;TERMINATOR
	MOVEI	AC0,1		;
	HRRM	AC0,UIN.	;
	XCT	UIN.		;READ THE STATISTICS BLOCK
	JRST	OPNI02		;
	TTCALL	3,[ASCIZ /CANNOT OPEN INDEX FILE/]
	JRST	IINER

	;OPEN THE DATA FILE
OPNI02:	HLLZS	UIN.		;CLEAR THE IOWR POINTER
	MOVEI	AC0,17		;DUMP MODE
	HRRM	AC0,UOBLK.	;SETUP OPEN BLOCK
	MOVE	AC1,5(I16)	;
	MOVE	AC1,(AC1)	;
	MOVEM	AC1,UOBLK.+1	;
	SETZM	UOBLK.+2	;
	PUSHJ	PP,SETCN.	;SET DATA FILE CHANNEL
	XCT	UOPEN.		;OPEN THE DATA FILE
	JRST	OPNCH4		;ERROR RETURN

	;SETUP IOWRD TABLE
	MOVEI	AC3,BA(I12)	;
	MOVE	AC1,ISPB(I12)	;SECTORS PER BLOCK
	IMULI	AC1,200		;WORDS PER SECTOR
	MOVN	AC2,AC1	;-LEN
	HRLZS	AC2		;-LEN,,0
	HRRI	AC2,-1(AC3)	;IOWD, -LEN,,LOC-1
	SKIPN	AC4,OMXLVL(I12)	;USE ORIGINAL # OF LEVELS
	MOVN	AC4,MXLVL(I12)	;MAXIMUM NUMBER OF INDEX LEVELS
	MOVEM	AC4,OMXLVL(I12)	;SAVE INCASE THIS FILE IS OPENED AGAIN
	SUBI	AC4,1		;PLUS ONE FOR SPLITTING THE TOP LEVEL
	HRLZS	AC4		;
	HRRI	AC4,IOWRD+1(I12)	;
	SKIPN	(AC4)		;IF IOWRD'S ALREADY SETUP
	MOVEM	AC2,(AC4)	;
	ADD	AC2,AC1		;
	AOBJN	AC4,.-3		;LOOP

	MOVN	AC5,MXLVL(12)	;SEE IF ANY NEW INDEX LEVELS WERE
	SUB	AC5,OMXLVL(12)	;  CREATED SINCE LAST TIME FILE WAS OPEN
	JUMPE	AC5,OPNI06	;SKIP THE FOLLOWING IF NOT
	HRL	AC4,AC5		;NEW LEVEL(S)
	HRR	AC6,.JBFF	;  SO MAKE
	SUBI	AC6,1		;  ANOTHER
	HRLI	AC6,-200	;  IOWD
OPNI03:	SKIPE	(AC4)		;USE ONLY IF
	JRST	OPNI04		;  ANOTHER JOB MADE THE NEW LEVEL
	SKIPE	KEYCNV		;ARE WE SORTING?
	JRST	OPNIR0		;YES - CANT HANDLE THAT
	MOVEI	AC0,200		;GET 200 WORDS
	PUSHJ	PP,GETSPC	;  OF CORE
	  JRST	OPNIR1		;TOO BAD
	MOVEM	AC6,(AC4)	;USE IT
	ADD	AC6,AC1		;SET UP FOR NEXT IOWD
OPNI04:	AOBJN	AC4,OPNI03	;LOOP IF YOU MUST
OPNI06:	MOVEM	AC2,IOWRD+13(I12)	;SAT BLOCK
	ADD	AC2,AC1		;

	;IOWRD0, USOBJ0, CNTRY0, NNTRY0  - SET TO INDEX ON LVL
	HRLZI	AC0,LVL		;HOLDS CURRENT LEVEL OF INDEX
	HRRI	AC0,IOWRD(I12)	;
	MOVEM	AC0,IOWRD0(I12)	;
	HRRI	AC0,USOBJ(I12)	;
	MOVEM	AC0,USOBJ0(I12)	;
	HRRI	AC0,CNTRY(I12)	;
	MOVEM	AC0,CNTRY0(I12)	;
	HRRI	AC0,NNTRY(I12)	;
	MOVEM	AC0,NNTRY0(I12)	;
	;SET BRISK FLAG   OUTPUT ONLY WHEN YOU MUST
	LDB	AC5,BBRISK
	SKIPE	AC5
	SETOM	BRISK(I12)

	;CHECK FILTAB BLKFTR VS STAT-BLK BLKFTR
	PUSHJ	PP,OPNWPB	;AC5 = BLKFTR, AC10 = WPB
	MOVE	AC6,DBF(I12)	;DATA FILE BLOCKING FACTOR VIA STA BLOCK
	CAMN	AC5,AC6		;AC5 = BLKFTR VIA FILE TABLE
	JRST	OPNI05		;OK
	TTCALL	3,[ASCIZ /BLOCKING-FACTOR DIFFERS BETWEEN INDEX FILE AND FILE-TABLE/]
	MOVE	AC2,[BYTE (5) 10,31,20,2]
	PUSHJ	PP,MSOUT.

	;IOWRD(I12) - SET DATA BLOCK IOWD POINTER
OPNI05:	MOVN	AC5,AC10	;
	HRL	AC2,AC5		;
	SKIPN	IOWRD(I12)	;SKIP IF ALREADY SETUP BY PREVIOUS OPEN
	MOVEM	AC2,IOWRD(I12)	;DATA BLOCK
	ADDI	AC2,1(AC10)	;AC2 POINT AT NEXT FREE AREA 

	;IBLEN - LEN OF INDEX BLOCK FOR BINARY SEARCH
	MOVE	AC0,EPIB(I12)	;
	IMUL	AC0,IESIZ(I12)	;NO. OF WRDS IN IDX BLK
	MOVEM	AC0,IBLEN(I12)	;IDX BLK LEN

	;SINC - SEARCH INCREMENT FOR BINARY SEARCH
	MOVE	AC1,IESIZ(I12)	;THE INCREMENT TO BE
	IMULI	AC1,2		;
	CAMG	AC1,AC0		;INC GT INDEX LENGTH?
	JRST	.-2		;NO
	MOVEM	AC1,SINC(I12)	;SAVE THE SEARCH INCREMENT

	;DAKBP - BYTE POINTER TO DATA ADJUSTED KEY
	MOVE	AC1,DBPRK(I12)	;START WITH RELATIVE DATA KEY BP
	HRRI	AC1,(AC2)	;
	MOVEM	AC1,DAKBP(I12)	;DATA ADJUSTED KEY BYTE POINTER
	SETZM	(AC1)		;ZERO THE FIRST DATA REC-KEY WRD
	ADDI	AC1,1		;
	MOVEM	AC1,DAKBP1(I12)	;POINTER TO SECOND REC-KEY WRD
	ADD	AC1,IESIZ(I12)	;KEY SIZE PLUS 2 WRD HDR
	SUBI	AC1,2		;PERMIT 1 EXTRA WRD FOR WRAP-AROUND
	SETZM	-1(AC1)		;ZERO LAST DATA REC-KEY WRD

	;RESERVE AREA FOR INDEX ENTRY
	ADDI	AC1,2		;LOC FOR BLOCK # AND VERSION #
	;IAKBP - BYTE POINTER TO INDEX ADJUSTED KEY
	TLZ	AC1,770000	;
	TLO	AC1,440000	;
	MOVEM	AC1,IAKBP(I12)	;INDEX ADJUSTED KEY BP
	ADDI	AC1,1		;
	MOVEM	AC1,IAKBP1(I12)	;POINTER TO SECOND IDX-KEY WRD
	ADD	AC1,IESIZ(I12)	;
	SUBI	AC1,2		;
	SETZM	-1(AC1)		;ZERO LAST IDX-KEY WRD

			;AC1 POINTS TO NEXT FREE AREA
	HRLI	AC1,-1(AC1)	;UNTIL
	HRRI	AC1,ICHAN(I12)	;UNTIL,,FROM
	MOVEM	AC1,CORE0(I12)	;CLOSE CLEARS THIS CORE AREA

	;AUXIOW - SETUP THE IOWD
	MOVN	AC0,MXBUF	;MAX BUFFER SIZE
	HRL	AC0,AC0		;
	HRR	AC0,AUXBUF	;
	SUBI	AC0,1		;LOC-1
	MOVEM	AC0,AUXIOW	;SAVE IT

	;KWCNT - NUMBER OF WORDS IN THE KEY
	MOVE	AC1,IESIZ(I12)	;SETUP KWCNT
	SUBI	AC1,2		;
	;HRRM	AC1,IKWCNT(I12)	;
	;HRRM	AC1,DKWCNT(I12)	;
	MOVNS	AC1		;
	HRLM	AC1,IKWCNT(I12)	;-CNT,,CNT

	;FWMASK, LWMASK - CREATE 2 MASK WORDS FOR FIRST AND LAST DATA-KEY WORDS
	LDB	AC0,[POINT 3,KEYDES(I12),17]
	JUMPN	AC0,OPNBPS	;SKIP THIS MESS
	MOVE	AC0,KEYDES(I12)	;NON-NUMERIC-DISPLAY
	LDB	AC1,[POINT 12,KEYDES(I12),35]  ;KEY SIZE
	MOVN	AC2,AC1		;
	HRLZS	AC2		;
	MOVE	AC3,DBPRK(I12)	;RELATIVE DATA-RECORD-KEY POINTER
OPNMSK:	IBP	AC3
	AOBJN	AC2,.+1
	TLNE	AC3,760000	;STAY WITH IN THE FIRST WORD
	JUMPL	AC2,OPNMSK	;UNLESS WE RUN OUT OF BYTES

	LDB	AC4,[POINT 6,DBPRK(I12),5]
	SETZ	AC5,		;
	SETO	AC6,		;
	LSHC	AC5,(AC4)	;
	MOVEM	AC5,FWMASK(I12)	;007777 FIRST WORD MASK

	TLNN	AC3,760000	;
	JRST	OPNMS1		;
	LDB	AC4,[POINT 6,AC3,5]  ;THE KEY IS LESS THAN ONE WORD
	MOVNS	AC4		;
	LSH	AC5,(AC4)	;
	MOVNS	AC4		;
	LSH	AC5,(AC4)	;
	JRST	.+2		;007700 AC5 HAS MASK

OPNMS1:	JUMPL	AC2,OPNMS2	;IS KEY GREATER THAN ONE WRD?
	SETZM	FWMASK(I12)	;NO, ONE WRD OR LESS
	MOVEM	AC5,LWMASK(I12)	;
	JRST	OPNBPS		;DONE

OPNMS2:	MOVEI	AC4,5		;ASCII
	TRNN	AC0,400000	;
	MOVEI	AC4,6		;SIXBIT
	HLRES	AC2		;
	MOVMS	AC2		;MAKE IT POSITIVE
	IDIV	AC2,AC4		;
	SKIPN	AC3		;REMAINDER?
	SKIPA	AC3,AC4		;NO--BYTES PER WORD
	ADDI	AC2,1		;YES
	TRNE	AC0,400000	;ASCII KEY?
	MOVEI	AC4,7		;YES--BITS PER BYTE
	MOVNS	AC2		;
	HRLM	AC2,DKWCNT(I12)	;NUMBER OF REC-WRDS -1 THAT CONTAIN THE KEY
	IMUL	AC3,AC4		;
	SETO	AC6,		;
	SETZ	AC5,		;
	MOVNS	AC3
	ROTC	AC5,(AC3)	;
	MOVEM	AC5,LWMASK(I12)	;MASK FOR THE LAST REC-DATA-KEY WRD

	;BPSB - NUMBER OF BITS PER SAT BLOCK
OPNBPS:	MOVE	AC0,FILSIZ(I12)	;TOTAL NUMBER OF DATA BLOCKS IN FILE
	IDIV	AC0,SBTOT(I12)	;  WILL GIVE NUMBER PER SAT BLOCK
	MOVEM	AC0,BPSB(I12)	;SAVIT

	;ICMP, DCMP - SETUP DISPATCH ADR FOR COMPARE ROUTINES
OPNDSP:	LDB	AC2,[POINT 3,KEYDES(I12),23]
	CAIE	AC2,3		;MAKE TYPE 3
	CAIN	AC2,4		;  AND 4
	LSH	AC2,-1		;  BE 1 AND 2
	TRZ	AC2,4		;0 = DCDNN, 1 = DC1S/U, 2 = DC2S/U
	MOVE	AC0,KEYDES(I12)	;
	TRNE	AC0,100000	;
	SKIPA	AC3,ICTAB(AC2)	;SIGNED
	MOVS	AC3,ICTAB(AC2)	;UNSIGNED
	HRRZM	AC3,ICMP(I12)	;INDEX COMPARE ROUTINE

	TRNE	AC0,100000	;
	SKIPA	AC3,DCTAB(AC2)	;
	MOVS	AC3,DCTAB(AC2)	;
	HRRZM	AC3,DCMP(I12)	;DATA COMPARE ROUTINE

	;GDPRK, GDPSK - SETUP GET DISPLAY PARAMETER
	LDB	AC2,[POINT 3,KEYDES(I12),23]
	CAILE	AC2,2		;
	JRST	OPNRSB		;
	JUMPE	AC2,OPNRSB	;
	HLLZ	AC1,24(I16)	;POSITION IN DATA-REC
	TRNE	AC0,100000	;
	TLOA	AC1,4000	;SIGNED
	TLZ	AC1,4000	;UNSIGNED
	LDB	AC2,[POINT 12,KEYDES(I12),35]  ;KEYSIZE
	DPB	AC2,[POINT 11,AC1,17]  ;
	MOVEM	AC1,GDPRK(I12)	;GD PARAMETER FOR REC-KEY
	HRR	AC1,23(I16)	;ADR OF SYMKEY
	TLZ	AC1,770000	;MASK
	HLLZ	AC2,23(I16)	;
	TLZ	AC2,7777	;
	IOR	AC1,AC2		;SYM-KEY BYTE RESIDUE
	MOVEM	AC1,GDPSK(I12)	;GD PARAMETER FOR SYM-KEY
	HRRZI	AC1,GD6.	;
	TRNE	AC0,400000	;
	HRRZI	AC1,GD7.	;
	MOVEM	AC1,GDX.(I12)	;

	;DCMP,DCMP1 - SETUP TO CONVERT THEN COMPARE
	HRRZM	AC3,DCMP1(I12)	;COMPARE ROUTINE
	HRRZI	AC3,DGD67	;CONVERSION ROUTINE
	MOVEM	AC3,DCMP(I12)	;CONVERT THEN COMPARE

	;RSBP - BR TO SIXBIT/ASCII RECORD SIZE
OPNRSB:	MOVE	AC1,[POINT 12,-1(AC4),35]
	TLNN	FLG,DDMSIX
	MOVE	AC1,[POINT 12,-1(AC4),34]
	MOVEM	AC1,RSBP(I12)
	SUBI	AC1,-1
	MOVEM	AC1,RSBP1(I12)
	;GETSET - SETUP KEY FOR SEARCH ROUTINES
OPNGST:	HLRZ	AC1,KEYTYP(I12)	;KEY-TYPE
	JUMPN	AC1,.+2		;
	MOVEI	AC2,ADJKEY	;DNN
	CAIE	AC1,1		;
	CAIN	AC1,2		;
	MOVEI	AC2,GD67	;DN
	CAIL	AC1,3		;
	MOVEI	AC2,FPORFP	;FP
	MOVEM	AC2,GETSET(I12)	;DISPATCH FOR SEARCH INITIALIZING

	;RECBP - SETUP REC AREA BYTE-POINTER
	HRRZ	AC2,FLG		;ADR OF REC
	TLNE	FLG,CDMASC	;
	TLOA	AC2,(POINT 7,)	;ASCII
	HRLI	AC2,(POINT 6,)	;SIXBIT
	MOVEM	AC2,RECBP(I12)	;

	JRST	OPNCH2		;

OPNIR0:	TTCALL	3,[ASCIZ /CANNOT EXPAND CORE WHILE SORT IS IN PROGRESS/]
	SKIPA
OPNIR1:	PUSHJ	PP,GETCO9	;CORE UUO FAILED
	MOVE	AC2,[BYTE (5) 10,31,20,2]
	PUSHJ	PP,MSOUT.	;DOESN'T RETURN


	;DISPATCH FOR INDEX COMPARE ROUTINES
ICTAB:	XWD	ICDNN,	ICDNN	;DISPLAY NON-NUMERIC
	XWD	IC1S,	IC1U	;ONE WRD SIGNED / UNSIGNED
	XWD	IC2S,	IC2U	;TWO WRD SIGNED / UNSIGNED

	;DISPATCH FOR DATA COMPARE ROUTINES
DCTAB:	XWD	DCDNN,	DCDNN	;DISPLAY NON-NUMERIC
	XWD	DC1S,	DC1U	;ONE WRD SIGNED / UNSIGNED
	XWD	DC2S,	DC2U	;TWO WRD SIGNED / UNSIGNED
>
	;RETURNS IN AC10 NUMBER OF WORDS PER LOGICAL BLOCK
	;AND BLOCKING FACTOR IN AC5.  ***POPJ***

OPNWPB:	LDB	AC5,FTBF.	;BLOCKING FACTOR
	MOVEM	AC5,D.RCL(I16)	;
IFN EBCDIC,<
	TLNN	FLG,DDMEBC	;EBCDIC?
	JRST	OPNWP4		;NO
	HLRZ	AC10,12(I16)	;BLOCK SIZE
	HRRM	AC10,D.FBB(I16)	;SETUP # OF FREE BUFFER BYTES
	ADDI	AC10,3		;ROUND UP
	IDIVI	AC10,4		;4 CHAR PER WORD
	POPJ	PP,
OPNWP4:
>
	LDB	AC10,FTMRS.	;MAX RECORD SIZE
	TLNE	FLG,DDMBIN	;IF MODE IS BINARY,
	JRST	OPNWP3		;  CONVERT SIZE TO WORDS

	MOVEI	AC6,5		;5 CPW IF ASCII
	TLNN	FLG,DDMASC	;SKIP IF ASCII
	MOVEI	AC6,6		;6 IF SIXBIT
	HRRZM	AC6,D.BPW(I16)	;CHARS PER WORD
	JUMPL	FLG,OPNWP1	;JUMP IF ASCII
	ADDI	AC10,6		;ADD IN 6 CHARS FOR VARLEN CHAR-COUNT
OPNWP2:	ADDI	AC10,-1(AC6)	;ROUND UP
	IDIV	AC10,AC6	;RECSIZ/CPW
	IMUL	AC10,AC5	;WORDS PER LOGBLK
	POPJ	PP,		;

OPNWP1:	ADDI	AC10,2		;FOR CRLF
IFN ISAM,<
	TLNE	FLG,IDXFIL	;INDEX FILE?
	ADDI	AC10,5		;FOR THE HEADER WORD
>
	ADDI	AC10,4		;ROUND UP
	IDIVI	AC10,5		;WORDS-PER-RECORD
	IMUL	AC10,AC5	;WORDS-PER-BLOCK
	POPJ	PP,

;RECORDING MODE IS BINARY--CONVERT SIZE TO WORDS

OPNWP3:	MOVEI	AC6,6		;ASSUME SIXBIT RECORD IN CORE
	TLNE	FLG,CDMASC	;IS IT ACTUALLY ASCII?
	MOVEI	AC6,5		;YES--5 BYTES PER WORD
	JRST	OPNWP2

	;SET DEVICE TABLE BUFFER HEADER BYTE SIZE
	;SETUP CONVERSION FLG  ***OPNLO***

OPNBSI:	JUMPL	FLG,OPNCON	;JUMP IF DEVICE IS ASCII
	TLNE	FLG,DDMBIN	;IF MODE IS BINARY,
	JRST	OPNBPB		;  DON'T TOUCH BYTE POINTER
	MOVEI	AC6,6		;SIXBIT BYTE SIZE
IFN EBCDIC,<
	TLNE	FLG,DDMEBC	;SKIP IF NOT EBCDIC
	MOVEI	AC6,10		;EBCDIC IS 8 BITS WIDE
>
	DPB	AC6,FTIBS.	;INPUT HEADER BYTE-POINTER
	DPB	AC6,FTOBS.	;OUTPUT H...

OPNCON:	TLNE	FLG,CDMASC	;SKIP IF CORE RECORD IS NOT ASCII
	JUMPL	FLG,OPNBPB	;JUMP IF BOTH ARE ASCII
	TLNE	FLG,DDMASC+CDMASC ;SKIP IF BOTH ARE NOT ASCII
	TLO	FLG,CONNEC	;%SET THE CONVERSION FLAG

	;PRESUMES AC10 HAS WRDS/LOGICAL BLOCK
	;SETUP BUFFERS PER LOGICAL BLOCK AND
	;NUMBER OF RECORDS TO A RERUN DUMP..  ***OPNLO***

OPNBPB:	MOVEI	AC0,200		;DSK BUFFER SIZE
	TLNE	FLG,OPNIO!RANFIL!IDXFIL ;SKIP IF NOT RANDOM OR IO
	JRST	OPNBP3		;
	TLNN	AC13,20		;SKIP IF A MTA
	JRST	OPNBP1		;JUMP, NOT A MTA
	JUMPE	AC5,OPNBP1	;JUMP IF BLK-FTR IS ZERO (AC5)
	MOVEI	AC10,1		;ONE BUFFER PER LOGICAL BLOCK
	JRST	OPNBP2		;
OPNBP1:	HRRZ	AC11,D.IBH(I16)	;ASSUME INPUT
	TLNN	FLG,OPNIN	;SKIP IF INPUT
	HRRZ	AC11,D.OBH(I16)	;MUST BE OUTPUT
	HLRZ	AC0,(AC11)	;BUFFER SIZE + 1 IN WORDS
	SUBI	AC0,1		;SIZE
OPNBP3:	IDIV	AC10,AC0	;/BUF-SIZE
	SKIPE	AC10+1		;ROUND UP
	ADDI	AC10,1		;AC10=BUFFERS PER LOGICAL BLOCK
OPNBP2:	MOVEM	AC10,D.BCL(I16)	;CURRENT BUFBLK
	MOVEM	AC10,D.BPL(I16)	;BUFBLK
	HRR	AC10,7(I16)	;
	HRRZM	AC10,D.RRD(I16)	;NUMBER OF RECORDS TO A RERUN DUMP

OPNBP4:	TLNE	AC13,20		;SKIP IF NOT A MAGTAPE
	JRST	OPNMTA		;SET DENSITY, PARITY & POSITION THE MAGTAPE
	;DO A LOOKUP OR READ A LABEL.  SETUP DEVICE TABLE REEL
	;NUMBER AND NUMBER OF FIRST BLOCK OF FILE.  ***OPNBBF***

OPNLO:	TLNN	AC16,OPEN	;OPEN UUO SKIPS
	JRST	OPNLO1		;
	MOVEI	AC0,2020	;SIXBIT REEL NUMBER '00'
	LDB	AC1,FTFP.	;FILE POSITION (ON MTA)
	SKIPN	AC1		;SKIP IF MULTI-FILE-REEL
	ADDI	AC0,1		;MULTI-REEL-FILE  REEL '01'
	TLNE	AC16,1000	;SKIP IF A CLOSE REEL GENERATED OPEN
	DPB	AC0,DTRN.	;INITIALIZE THE REEL NUMBER
OPNLO1:	TLNN	FLG,OPNIN!RANFIL!IDXFIL ;SKIP IF INPUT/IO
	JRST	OPNBBF		;OUTPUT. BBF USE PRO.
OPNLUP:	PUSHJ	PP,OPNLID	;SETUP LOOKUP BLOCK WITH ID
	TLNN	AC13,4		;SKIP IF DIRECTORY DEVICE
	JRST	OPNRLB		;READ LABEL INTO RECORD AREA
	XCT	ULKUP.		;*** LOOKUP ***************
	 JRST	OPNLER		;ERROR RETURN
	SETZM	D.CBN(I16)	;THE FIRST BLOCK OF ALL
	TLNN	FLG,RANFIL	;  BUT RANDOM FILES
	AOS	D.CBN(I16)	;  IS ONE.

	PUSHJ	PP,ZROSLA	;ZERO THE STD LABEL AREA
	MOVE	AC0,ULBLK.	;FILE NAME
	MOVE	AC1,ULBLK.+1	;EXTENSION
	TLNE	AC13,100	;SKIP IF NOT A DTA
	HRRM	AC1,D.CBN(I16)	;SAVE AS THE FIRST BLOCK NUMBER
	TRZ	AC1,-1		;THEN ZERO IT
	ROTC	AC0,14		;
	MOVEM	AC0,STDLB.+1	;
	HLLM	AC1,STDLB.+2	;
	HRLI	AC1,(SIXBIT /HDR/) ;LABEL TYPE
	IORI	AC1,(SIXBIT /1/)
	MOVEM	AC1,STDLB.	;
	LDB	AC4,[POINT 12,ULBLK.+2,35]
	PUSHJ	PP,TODA1.	;CREATION DATE
	SETZ	AC1,		;
	ROTC	AC0,6		;
	MOVEM	AC0,STDLB.+7	;DATE
	MOVEM	AC1,STDLB.+6	;DATE
	PUSHJ	PP,OPNCA1	;MOVE STD-LABEL AREA TO RECORD AREA
	JRST	OPNBBF

OPNLER:	HRRZ	AC2,ULBLK.+1	;
	TRNE	AC2,37		;IS IT FILE-NOT-FOUND?
	JRST	LUPERR		;NO, OTHER
	TLNE	FLG,OPNOUT	;
	TLNN	FLG,RANFIL!OPNIO ;RANDOM OR IO OUTPUT FILE?
	JRST	LUPERR		;NO
	PUSHJ	PP,OPNEID	;SETUP FOR AN ENTER
	XCT	UENTR.		;CREATE A NULL FILE
	 JRST	ENRERR		;ERROR RETURN
	XCT	UCLOS.
	JRST	OPNLUP		;OK TRY THE LOOKUP AGAIN
	;READ A LABEL FROM A NON DIRECTORY DEVICE.  ***OPNBBF***

OPNRLB:	TLNN	AC13,40610	;SKIP IF DEVICE IS - LPT,TTY,PTR,OR PTP
	TLNN	FLG1,NONSTD+STNDRD ;SKIP IF LABELS ARE PRESENT
	JRST	OPNBBF		;
	PUSHJ	PP,CLSYNC	;ONE BUFFER AT A TIME FOR ERROR RECOVERY
	PUSHJ	PP,READIN	;READ A LABEL INTO THE BUFFER AREA
	JRST	OPNRL1		;NORMAL RETURN
OPNRL2:	PUSHJ	PP,CLSYNC	;MULTI BUFFERED
	JRST	OPNFW4		;TRY AGAIN RETURN

OPNRL1:	PUSHJ	PP,CLSYNC	;
	PUSHJ	PP,BUFREC	;MOVE THE LABEL FROM THE BUFFER TO RECORD AREA

	;DO BEFORE BEGINNING FILE USE PROCEDURE.  PERFORM STANDARD
	;LABEL CHECKS OR CREATE A LABEL.  ***OPNABF***

OPNBBF:	TLNE	FLG,OPNIO!RANFIL!IDXFIL ;SKIP IF NOT DUMP MODE
	JRST	OPNBB1		;
	TLNE	FLG,OPNOUT	;SKIP IF NOT OUTPUT
	XCT	UOUT.		;DUMMY OUTPUT********************
OPNBB1:	MOVEI	AC1,1		;2 WORD CALL,
	PUSHJ	PP,USEPRO	;TO GET THE USE PRO. ADDRESS
	TLNN	AC13,40610	;NO LABELS - NO CKECKS
	TLNN	FLG1,STNDRD	;SKIP IF LABELS ARE STANDARD
	JRST	OPNABF		;AFTER BEG FILE
	TLNE	FLG,OPNIN	;SKIP IF NOT INPUT / IO
	JRST	OPNCSL		;STANDARD LABEL CHECK
	PUSHJ	PP,OPNCAL	;CREATE A LABEL

	;DO AFTER BEGINNING FILE LABEL PROCEDURE
	;AND WRITE OUT THE LABEL.  ***OPNENR***

OPNABF:	MOVEI	AC1,2		;TWO WORD CALL
	PUSHJ	PP,USEPRO	;TO GET USE PRO. ADR.
	TLNN	FLG,OPNOUT	;OUTPUT SKIPS
	JRST	OPNDVC
	TLNE	AC13,4		;SKIP IF NOT DIR. DEV.
	JRST	OPNENR
	TLNN	AC13,40614	;SKIP IF LPT,TTY,PTR,PTP,OR DTA,DSK.
	TLNN	FLG1,NONSTD+STNDRD ;SKIP IF ANY LABELS
	JRST	OPNDVC		;NO LABELS
	PUSHJ	PP,RECBUF	;MOVE THE LABEL INTO THE BUFFER
	JUMPGE	FLG,OPNAB1	;JUMP IF DEVICE IS NOT ASCII
	PUSHJ	PP,WRTCR	;
	PUSHJ	PP,WRTLF	;
OPNAB1:	PUSHJ	PP,WRTOUT	;WRITE THE LABEL
IFN EBCDIC ,<
	TLNN	FLG,DDMEBC	;EBCDIC?
	JRST	OPNDVC		;NO
	XCT	UCLOS.		;WRITE A TAPE MARK AFTER THE LABELS
	PUSHJ	PP,WRTWAI	;WAIT FOR ERROR CHECKING
	XCT	UOUT.		;DUMMY OUTPUT
>
	JRST	OPNDVC
	;DO AN ENTER AND SAVE THE FLAG REGISTER.  ***EXIT TO THE ACP***

OPNENR:	PUSHJ	PP,OPNEID	;SETUP UEBLK. (DUMP-MODE)
	XCT	UENTR.		;ENTER - DIRECTORY DEVICE**********
	JRST	ENRERR		;ERROR RETURN
	TLNN	FLG,RANFIL!OPNIO!IDXFIL ;DUMP MODE HAS NO DUMMY OUTPUTS
	XCT	UOUT.		;DUMMY OUTPUT*****ENTER VOIDS PREVIOUS DUMMY OUTPUTS.
OPNDVC:	MOVE	AC13,UOBLK.+1
	CALLI	AC13,4		;THE FINAL DEVCHR
	MOVEM	AC13,D.DC(I16)
	MOVEM	FLG,10(I16)	;UPDATE THE FLAGS
	TLNE	AC13,10		;IS THIS A TTY FILE?
	HRRZM	AC16,TTYOPN	;YES, REMEMBER THAT
	TLNE	FLG1,STNDRD!NONSTD	;SKIP IF LABELS ARE OMITTED
	PUSHJ	PP,ZROREC	;CLEAR THE RECORD AREA I.E.LABEL
	TLNN	AC16,SLURP	;RESTORE THE REC-AREA IF A WRITE REEL CHANGE
	POPJ	PP,		;RETURN TO THE ***ACP***
	POP	PP,AC2		;FROM,,TO
	POP	PP,AC1		;LENGTH
	HRRZM	AC2,.JBFF	;RESTORE FREE CORE
	MOVSS	AC2		;THE OTHER WAY
	ADDI	AC1,(AC2)	;UNTIL
	BLT	AC2,(AC1)	;SLURP
	POPJ	PP,		;RETURN TO THE ***"ACP"***
	;STANDARD LABELS AND INPUT OR IO
	;CHECK THE VALUE OF ID.  ***OPNABF***

OPNCSL:	PUSHJ	PP,RECSLB	;MOVE RECORD AREA TO STD-LABEL AREA
	PUSHJ	PP,OPNLID	;VALUE OF ID TO ULBLK.

	;CHECK FOR LABEL TYPE 'HDR1'
	MOVE	AC0,STDLB.	;LABEL TYPE
	TRZ	AC0,7777	;
IFN EBCDIC ,<
	TLNE	FLG,DDMEBC	;IF EBCDIC
	JRST	OECLT		;  LOOK FOR 'VOL1' IF FIRST FILE
OPNCLT:
>
	CAMN	AC0,[SIXBIT /HDR1/]	;SKIP INTO ERROR MESSAGE
	JRST	OPNCID		;CHECK VALUE OF ID
	;MISSING OR WRONG LABEL TYPE
	PUSHJ	PP,SAVAC.
	TTCALL	3,[ASCIZ/THE BEGINNING FILE LABEL IS MISSING/]
OPNCL1:	MOVE	AC2,[BYTE(5)10,2,31,20,4,14]
	PUSHJ	PP,MSOUT.
	JRST	OPNFW4		;TRY AGAIN

IFN EBCDIC ,<
OECLT:	LDB	AC2,FTFP.	;GET FILE POSITION
	SOJG	AC2,OPNCLT	;  AND RETURN IF NOT FIRST FILE ON REEL
	CAME	AC0,[SIXBIT /VOL1/]	;LABEL TYPE MUST BE 'VOL1'
	JRST	OECL1		;  ELSE ERROR MESSAGE
	PUSHJ	PP,CLSYNC	;SET TO READ ONE BUFFER AT A TIME
	PUSHJ	PP,READIN	;READ NEXT LABEL, SHLDB 'HDR1'
	JRST	.+2		;OK
	JRST	OPNRL2		;ERROR RETURN, MESSAGE & SECOND CHANCE
	PUSHJ	PP,CLSYNC	;BACK TO NORMAL MODE
	PUSHJ	PP,BUFREC	;MOVE LABEL INTO RECORD AREA
	PUSHJ	PP,RECSLB	;  THEN TO LABEL AREA
	MOVE	AC0,STDLB.	;LABEL TYPE TO AC0
	TRZ	AC0,7777	;  AND CLEAR THE GARBAGE
	JRST	OPNCLT		;TRY FOR 'HDR1'

OECL1:	TTCALL	3,[ASCIZ /LABEL "VOL1" IS MISSING/]
	JRST	OPNCL1
>

OPNCID:	HRR	AC0,STDLB.	;
	MOVE	AC1,STDLB.+1	;
	HLL	AC0,STDLB.+2	;
	ROTC	AC0,30		;JUSTIFY THE FILENAME
	CAME	AC0,ULBLK.	;CHECK FILE NAMES
	JRST	OPNIDE		;ID ERROR
	HLLZ	AC0,ULBLK.+1	;
	TRZ	AC1,-1		;CLEAR THE LABEL NUMBER
	CAMN	AC0,AC1		;CHECK EXTENSIONS
	JRST	OPNCDW		;CHECK DATE WRITTEN

	;ID ERROR.
OPNIDE:	PUSHJ	PP,SAVAC.	;
	MOVE	AC2,[BYTE (5)10,2,31,20,4,14]
	PUSHJ	PP,MSOUT.	;
	TTCALL	3,[ASCIZ/ THE VALUE OF ID DOES NOT MATCH THE LABEL ID/]
	JRST	OPNFW4

	;CHECK DATE WRITTEN
OPNCDW:	SKIPN	AC5,14(I16)	;VALUE OF DATE WRITTEN
	JRST	OPNCRN		;CHECK REEL NUMBER
	MOVE	AC0,[POINT 6,STDLB.+6,29]
	MOVEI	AC2,6		;CHECK ONLY FIRST 6 CHARS.
OPNCD1:	ILDB	AC1,AC0		;ONE FROM THE LABEL AND
	ILDB	AC6,AC5		;ONE FROM THE FILE TABLE
	TLNE	AC5,100		;SKIP IF SIXBIT
	SUBI	AC6,40		;MAKE IT SIXBIT
	CAME	AC6,AC1		;SKIP IF EQUAL
	JRST	OPNCD2		;WRONG DATE MESSAGE
	SOJN	AC2,OPNCD1	;LOOP 6 TIMES
	JRST	OPNCRN		; OK SO CHECK THE REEL NUMBER
	;WRONG DATE
OPNCD2:	MOVE	AC2,[BYTE (5)10,31,20,2,4,14]
	PUSHJ	PP,MSOUT.
	TTCALL	3,[ASCIZ /THE FILE TABLE DATE DIFFERS FROM THE FILE LABEL DATE/]
	JRST	KILL.

	;CHECK THE REEL NUMBER IF THE DEVICE IS A MAGTAPE
OPNCRN:	TLNN	AC13,20		;MAGTAPE?
	JRST	OPNABF		;NO
	HRL	AC0,STDLB.+4	;THE
	HLR	AC0,STDLB.+5	;  REAL
	ROT	AC0,-14		;  REEL
	ANDI	AC0,7777	;  NUMBER
	LDB	AC1,DTRN.	;AND WHAT IT OUGHT TO BE
	CAMN	AC0,AC1		;SKIP IF UNEQUAL
	JRST	OPNCR1		;MATCH
	LDB	AC2,FTFP.	;
	JUMPN	AC2,OPNCR1	;JUMP ITSA MULTI-FILE-REEL
	PUSHJ	PP,SAVAC.	;
	TTCALL	3,[ASCIZ /
$/]
	MOVE	AC2,[BYTE(5)10,31,20,2,4,34,14] ;FODC.R#
	PUSHJ	PP,MSOUT.	;
	TTCALL	3,[ASCIZ/ WAS MOUNTED, PLEASE MOUNT /]
	PUSHJ	PP,MSDTRN
	TTCALL	3,[ASCIZ /
THEN/]
	JRST	OPNF04		;TRY AGAIN
OPNCR1:
IFN EBCDIC ,<
	TLNE	FLG,DDMEBC	;IF EBCDIC
	XCT	MADVF.		;  SKIP TO TAPE MARK
>
	JRST	OPNABF
	;CREATE A STANDARD LABEL.  ***@POPJ***

OPNCAL:	PUSHJ	PP,OPNEID	;LOAD FILENM.EXT INTO ENTER BLOCK
	PUSHJ	PP,ZROSLA	;ZERO THE STD LABEL AREA
IFN EBCDIC,<
	LDB	AC0,FTFP.	;GET FILE POSITION
	TLNE	FLG,DDMEBC	;EBCDIC?
	SOJLE	AC0,[		;MAKE A 'VOL1' LABEL
	MOVE	AC0,[SIXBIT /VOL1/]
	MOVEM	AC0,STDLB.	;'VOL1' TO THE LABEL AREA
	PUSHJ	PP,SLBREC	;MOVE TO RECORD AREA
	PUSHJ	PP,RECBUF	;  THEN TO THE BUFFER
	PUSHJ	PP,WRTOUT	;  AND WRITE IT
	SETZM	STDLB.		;ZERO THE LABEL AREA
	JRST	.+1]		;RETURN
>
	MOVE	AC0,UEBLK.	;FILENAME
	HLLZ	AC1,UEBLK.+1	;EXT
	ROTC	AC0,14		;12 PLACES TO THE LEFT - MARCH.
	TRO	AC1,(SIXBIT /1/);FIRST LABEL
	MOVEM	AC0,STDLB.+1	;FILE
	HLLM	AC1,STDLB.+2	;DESCRIPTOR
	TLNE	AC16,OPEN+CLOSEB
	HRLI	AC1,(SIXBIT /HDR/)	;BEGINNING FILE LABEL
	TLNE	AC16,CLOSEF
	HRLI	AC1,(SIXBIT /EOF/)	;END OF FILE LABEL
	TLNE	AC16,CLOSER
	HRLI	AC1,(SIXBIT /EOV/)	;END OF VOLUME LABEL
	MOVEM	AC1,STDLB.	;
IFN EBCDIC,<
	TLNE	FLG,DDMEBC	;EBCDIC?
	PUSHJ	PP,JULIA0	;JULIAN DATE & SKIP EXIT
>
	PUSHJ	PP,TODAY.	;GET TODAY'S DATE
	SETZ	AC1,		;
	ROTC	AC0,6		;
	MOVEM	AC1,STDLB.+6	;CREATION
	MOVEM	AC0,STDLB.+7	;DATE

OPNCA1:	SETZ	AC2,
	LDB	AC0,FTFP.	;FILTAB FILE POSITION ON MAGTAPE
	IDIVI	AC0,^D10	;
	ADDM	AC1,AC2		;
	ROT	AC2,6		;
	JUMPN	AC0,.-3		;CONVERTED TO DECIMAL
	ADD	AC2,[20202020]	;SIXBITIZED

	LDB	AC1,DTRN.	;DEVTAB MAG-TAPE REEL NUMBER
	ROT	AC2,14		;
	ROTC	AC1,-6		;
	ADDI	AC1,202000	;
	MOVEM	AC1,STDLB.+4	;REEL NUMBER AND
	MOVEM	AC2,STDLB.+5	;FILE POSITION

	SETZ	AC1,		;
	MOVE	AC0,[SIXBIT /PDP10 /]
	MOVEM	AC0,STDLB.+12
	HRLZ	AC0,.JBVER
	ROTC	AC0,14
	ROT	AC1,3
	ROTC	AC0,3
	ROT	AC1,3
	ROTC	AC0,3
	ADDI	AC1,202020
	HRLZM	AC1,STDLB.+13	;PDP10 VER
	JRST	SLBREC		;MOVE STD-LABEL TO RECORD AREA AND EXIT
	;SET MAGTAPE DENSITY & PARITY
	;POSITION MAGTAPE VIA FILE TABLE FILE POSITION.  ***OPNLO***

OPNMTA:	LDB	AC5,VERNO	;GET COMPILER NUMBER
	CAIGE	AC5,3		;VERSION 3 OR GREATER
	JRST	OPNPMT		;
	XCT	UGETS.		;GET STATUS
	LDB	AC5,DENSITY	;GET PARITY & DENSITY
	ROT	AC5,-1		;DENSITY
	TLNE	AC5,400000	;PARITY?
	TROA	AC5,4		;EVEN
	TRZ	AC5,4		;ODD
	DPB	AC5,[POINT 3,AC2,28]
	XCT	USETS.		;SET STATUS
OPNPMT:
IFN EBCDIC,<
	TLNE	FLG,DDMEBC	;EBCDIC?
	XCT	MTIND.		;YES, SET INDUSTRY COMPATIBLE MODE
>
	HRLZI	AC5,HUF		;"HEAD UNDER THIS FILE" FLAG
	LDB	AC11,FTFP.	;POINT 6,6(I16),17 ... FILE POSITION ON REEL
	JUMPE	AC11,OPNF00	;JUMP IF MULTI REEL FILE		WAS OPNREW
	MOVE	AC10,AC16	;CURRENT FILE TABLE FIRST
OPNHUF:	TDNE	AC5,-17(AC10)	;SKIP IF NOT "HUF"
	JRST	OPNFND		;FOUND THE FILE
	HRRZ	AC10,11(AC10)	;NEXT FILE TABLE THAT SHARES THIS REEL
	CAIE	AC10,(I16)	;SKIP IF WE'VE MADE A COMPLETE LOOP
	JUMPN	AC10,OPNHUF	;ZERO=REEL NOT SHARED
				;FALL THRU IF REEL NEVER POSITIONED
OPNREW:	PUSHJ	PP,OPNRWD	;REWIND
	SUBI	AC11,1		;SUB 1 FOR THIS REWIND
IFN EBCDIC,<
	TLNN	FLG,DDMEBC	;EBCDIC?
	JRST	OPNR01		;NO
	IMULI	AC11,3		;3 EOF'S PER FILE
	JRST	OPNR02
OPNR01:
>
	TLNE	FLG1,NONSTD+STNDRD ;SKIP IF LABEL RECORDS OMITTED
	LSH	AC11,1		;ACCOUNT FOR "LR" EOF
OPNR02:	JUMPG	AC11,OPNFWD
	JRST	OPNFW1

OPNRWD:	XCT	MWAIT.
	XCT	SOBOT.		;STATO BEG-OF-TAPE
	XCT	MREW.		;ELSE REWIND
	POPJ	PP,

OPNFND:	ANDCAM	AC5,-17(AC10)	;CLEAR THE HUF FLAG
	TLNN	AC16,100	;REWIND REQ?
	JRST	OPNREW		;YES
	LDB	AC10,[POINT 6,6(AC10),17] ;FIGURE OUT WHERE TO GO
	SUB	AC11,AC10	;DIRECTION + MAGNITUDE
IFN EBCDIC,<
	TLNN	FLG,DDMEBC	;EBCDIC?
	JRST	OPNFN1		;NO
	IMULI	AC11,3		;3 EOF'S PER FILE
	JRST	OPNFN2
OPNFN1:
>
	TLNE	FLG1,NONSTD+STNDRD ;SKIP IF LABEL RECORDS OMITTED
	LSH	AC11,1		;ACCOUNT FOR "LR" EOF
OPNFN2:	JUMPE	AC11,OPNBOF	;GO TO THE BEG OF FILE
	JUMPG	AC11,OPNFWD	;SPACE FORWARD

OPNREV:	XCT	MBSPF.		;BACKSPACE A FILE
	XCT	MWAIT.		;WAIT FOR COMPLETION
	XCT	SZBOT.		;STATZ BOT
	JRST	OPNRE1		;PREMATURE BEG-OF-TAPE ERROR
	AOJL	AC11,OPNREV	;LOOP TILL (AC11)=0

OPNBOF:	XCT	MBSPF.		;MOVE TO BEG OF CURRENT FILE
	XCT	MWAIT.
	XCT	SOBOT.		;SKIP, BIT=BOF
	XCT	MADVF.		;MOVE TO OTHER SIDE OF EOF MARK
	JRST	OPNFW1
OPNFWD:	XCT	MWAIT.		;AVOID POSITIONING ERRORS
	XCT	MADVR.		;ADVANCE A RECORD
	XCT	MWAIT.		;WAIT
	XCT	SZEOT.		;STATZ EOT
	JRST	OPNFW2		;END OF TAPE ERROR
	XCT	SZEOF.		;STATZ EOF
	JRST	OPNFW3		;END OF FILE ERROR
	XCT	MADVF.		;ADVANCE A FILE
	SOJG	AC11,OPNFWD
OPNFW1:	ORM	AC5,D.HF(I16)	;NOTE CURRENT FILE OVER HEAD
	JRST	OPNLO		;EXIT FROM OPNPMT

OPNF00:	TLNE	AC16,100	;REWIND REQ ?
	JRST	OPNFW1		;NO
	JRST	OPNREW		;YES

OPNRE1:	TTCALL	3,[ASCIZ /UNEXPECTED BOT MARKER/]
	SKIPA
OPNFW2:	TTCALL	3,[ASCIZ /UNEXPECTED EOT MARKER/]
	SKIPA
OPNFW3:	TTCALL	3,[ASCIZ /UNEXPECTED EOF MARK/]
	PUSHJ	PP,SAVAC.
	TTCALL	3,[ASCIZ / ENCOUNTERED WHILE POSITIONING /]
	MOVE	AC2,[BYTE (5)10,31,20,14]  ;FILE ON DEVICE.
	PUSHJ	PP,MSOUT.
OPNFW4:	TLNN	AC13,120	;SKIP IF A REEL DEVICE
	JRST	KILL.		;
	TTCALL	3,[ASCIZ /
WRONG REEL? /]
OPNF04:	PUSHJ	PP,STOP.	;TYPE CONTINUE TO RETRY
	PUSHJ	PP,RSTAC.
	HRLZI	AC5,HUF		;ANOTHER TAPE WAS MOUNTED
	ANDCAM	AC5,D.HF(I16)	;CLEAR THE "HEAD-UNDER-FILE" FLAG
	JRST	OPNBP4		;TRY AGAIN

	;PLACE VALUE OF ID IN LOOKUP/ENTER BLOCK

OPNLID:	SKIPA	AC10,[POINT 6,ULBLK.]	;LOOKUP SETUP
OPNEID:	MOVE	AC10,[POINT 6,UEBLK.]	;ENTER SETUP
IFN ISAM,<
	TLNE	FLG,IDXFIL	;ISAM ?
	SKIPA	AC5,[POINT 6,DFILNM(I12)]
>
	MOVE	AC5,13(I16)	;BYTE POINTER TO VALUE OF ID
	MOVEI	AC6,11		;ID HAS 11 CHARACTERS MAX
OPNEI1:	ILDB	AC11,AC5	;PICK UP A CHAR
	TLNE	AC5,100		;SKIP IF SIXBIT
	SUBI	AC11,40		;CONVERT FROM ASCII
	IDPB	AC11,AC10	;STORE IN E BLOCK
	SOJN	AC6,OPNEI1	;LOOP 11
	SETZM	ULBLK.+3	;P,,P
	SETZM	UEBLK.+3	;PROJ,,PROG
	HLLZS	ULBLK.+1	;ZERO RIGHT HALF OF EXTENSION WORD
	HLLZS	UEBLK.+1	;   IN LOOKUP AND ENTER BLOCK
	SETZM	UEBLK.+2	;CLEAR PROTECTION AND DATE
OPNPPN:	LDB	AC5,VERNO	;GET COMPILER NUMBER
	CAIGE	AC5,3		;VERSION 3 OR OLDER?
	POPJ	PP,		;NOP
	HRRZ	AC5,22(I16)	;ADR OF PROJ,,PROG
	JUMPE	AC5,RET.1	;USE DEFAULT
	MOVE	AC5,(AC5)	;PROJECT,,PROGRAMER
	MOVEM	AC5,ULBLK.+3
	MOVEM	AC5,UEBLK.+3
	POPJ	PP,		;AND RETURN

IFN ISAM,<
OPNLIX:	MOVEI	AC10,OPNLID
	SKIPA
OPNEIX:	MOVEI	AC10,OPNEID
	TLC	FLG,IDXFIL
	PUSHJ	PP,(AC10)
	TLC	FLG,IDXFIL
	POPJ	PP,
>
	;PERFORM A USE PROCEDURE
	;CALLED WITH AN INDEX IN AC1,   ***POPJ***

USEPRO:	JUMPE	AC1,USEPR0	;JUMP IF ERROR USEPRO
	TLNN	FLG1,NONSTD!STNDRD
	POPJ	PP,		;EXIT, THERE ARE NO LABELS
USEPR0:	PUSHJ	PP,SAVAC.	;SAVE THE AC'S
	PUSHJ	PP,USESUP	;GET USE-PRO ADDRESS INTO AC1 AND AC2
	TLNE	AC16,CLOSEB+CLOSER ;SKIP IF NOT A REEL PRO
	JRST	USEPR1		;
	LDB	AC0,FTFP.	;FILE POSITION ON MTA
	JUMPN	AC0,USEPR2	;JUMP IF MULTI FILE REEL
	TLNE	AC16,CLOSEF	;SKIP IF AN OPEN USEPRO
USEPR1:	PUSHJ	PP,USESWP	;SET FOR REEL PROCEDURE
USEPR2:	PUSHJ	PP,USEXCT	;EXECUTE A PRO
	MOVE	AC16,-16(PP)	;RESTORE AC16
	TLNN	AC16,CLOSEB+CLOSER ;EXIT IF A REEL PRO
	SKIPN	-1(PP)		;OR AN ERROR PRO
	JRST	RSTAC1		;EXIT
	PUSHJ	PP,USESUP	;SETUP
	TLNN	AC16,CLOSEF	;SKIP IF A CLOSE TYPE USEPRO
	PUSHJ	PP,USESWP	;SET FOR REEL PROCEDURE
	LDB	AC0,FTFP.	;FILE POSITION
	JUMPN	AC0,RSTAC1	;EXIT, NOT A MULTI-REEL-FILE
	PUSHJ	PP,USEXCT	;ELSE PERFORM THE USE-PRO
	JRST	RSTAC1		;@POPJ

USESUP:	MOVE	AC1,-2(PP)	;INDEX FOR THE USE TABLES
	MOVEM	AC1,AC2		;
	ADDI	AC2,15(I16)	;ADR OF FILE USE PRO
	ADD	AC1,USES.	;ADR OF GENERAL USE PRO
	MOVE	FLG,-10(PP)	;RESTORE AC7
	TLNN	FLG,OPNOUT	;SKIP IF OUTPUT
	JRST	USESU1		;INPUT USE PRO
	TLNE	FLG,OPNIN	;SKIP IF NOT INPUT
	ADDI	AC1,5		;INPUT/OUTPUT USE PRO
	ADDI	AC1,5		;OUTPUT USE PRO
USESU1:	MOVE	AC1,(AC1)
	MOVE	AC2,(AC2)
	SKIPN	USES.		;
	SETZ	AC1,		;FOR STAND ALONE SORTS
	POPJ	PP,		;

USESWP:	HLRZ	AC1,AC1		;USE THE REEL ADDRESS
	HLRZ	AC2,AC2		;IN THE LEFT HALF
	POPJ	PP,		;

USEXCT:	MOVE	AC3,-2(PP)	;PP-2=AC1; USE TABLE INDEX
	TRNN	AC1,-1		;SKIP IF THERE IS A GENERAL USEPRO
	HRRZ	AC1,AC2		;GET SPECIFIC FILTAB USEPRO
	JUMPN	AC1,USEXC1	;GO PERFORM USEPRO
	JUMPN	AC3,USEXC2	;IF NO LABEL USEPRO RETURN
	AOSA	-20(PP)		;IF NO ERROR USEPRO SKIP-EXIT
USEXC1:	PUSHJ	PP,(AC1)	;XCT THE USEPRO
USEXC2:	POPJ	PP,		;
	;RECSLB.. MOVE RECORD AREA TO SIXBIT STD-LABEL AREA
	;SLBREC.. MOVE SIXBIT STD-LABEL AREA TO RECORD AREA.   ***POPJ***

RECSLB:	TLOA	AC0,400000	;
SLBREC:	TLZ	AC0,400000	;
	MOVE	AC2,STDLBP	;
	HRLZI	AC1,(POINT 7,(FLG))
	TLNN	FLG,CDMASC	;
	HRLZI	AC1,(POINT 6,(FLG))
	SKIPL	AC0		;
	EXCH	AC1,AC2		;
	MOVEI	AC0,^D80-2	;
SLBRE1:	ILDB	C,AC1		;
	TLNE	FLG,CDMASC	;
	ADDI	C,40		;
	IDPB	C,AC2		;
	SOJG	AC0,SLBRE1	;
	POPJ	PP,		;;;;;

	;READ THE LABEL INTO THE RECORD AREA.   ***POPJ***

BUFREC:	PUSHJ	PP,BUFRE0	;SETUP
IFN EBCDIC,<
	TLNN	FLG,DDMEBC	;EBCDIC?
	JRST	BUFRE3		;NO
	MOVE	AC10,[MOVE C,EBCTAB(C)]
	TLNE	FLG,CDMSIX	;SKIP IF NOT SIXBIT
	MOVE	AC10,[LDB C,[POINT 5,EBCTAB(C),26]]
	JRST	BUFRE1
BUFRE3:
>
	PUSHJ	PP,REAXCT	;SETUP AC10
BUFRE1:	SOSGE	D.IBC(I16)		;
	PUSHJ	PP,READIN	;FILL THE BUFFER
	JRST	BUFR01		;NORMAL RETURN
	JRST	CLSRL0		;EOF - COMPLAIN
BUFR01:	ILDB	C,D.IBB(I16)	;PICK UP A LABEL CHAR
	XCT	AC10		;CONVERT IF NECESSARY
	IDPB	C,AC3		;TO THE RECORD AREA
	SOJG	AC0,BUFRE1	;LOOP TILL LABEL IS IN THE RECORD AREA
	SETZM	D.IBC(I16)		;THE BUFFER IS EMPTY
	POPJ	PP,
	;WRITE OUT THE LABEL.   ***POPJ***

RECBUF:	PUSHJ	PP,BUFRE0	;SETUP
IFN EBCDIC,<
	TLNN	FLG,DDMEBC	;EBCDIC?
	JRST	RECBU2		;NO
	MOVE	AC10,[MOVS C,EBCTAB(C)]
	TLNE	FLG,CDMSIX	;SKIP IF NOT SIXBIT
	ADDI	AC10,40		;EBCTAB+40
	JRST	RECBU1
RECBU2:
>
	PUSHJ	PP,WRTXCT	;SETUP AC10
RECBU1:	SOSGE	D.OBC(I16)		;
	PUSHJ	PP,WRTOUT	;WRITE OUT THE BUFFER
	ILDB	C,AC3		;PICK UP A LABEL CHAR
	XCT	AC10		;CONVERT IF NECESSARY
	IDPB	C,D.OBB(I16)	;TO THE OUTPUT BUFFER
	SOJG	AC0,RECBU1	;LOOP TILL DONE
	POPJ	PP,

	;SET LABEL POINTER AND SIZE AND POPJ.
BUFRE0:	HRLZI	AC3,(POINT 6,(FLG))	;SIXBIT LABEL
	TLNE	FLG,CDMASC		;
	HRLZI	AC3,(POINT 7,(FLG))	;ASCII LABEL
	MOVEI	AC0,^D80-2	;STD-LABEL SIZE
	TLNE	FLG1,NONSTD	;
	HLRZ	AC0,11(I16)	;NON-STD-LABEL SIZE
	TLNN	FLG,DDMBIN	;IS FILE BINARY?
	POPJ	PP,		;NO
	HRLZI	AC3,(POINT 36,(FLG))	;MAKE ONE BYTE BE ONE WORD
	MOVEI	AC10,6		;CONVERT BYTE COUNT
	TLNN	FLG,CDMSIX	;  -
	MOVEI	AC10,5		;  -
	ADDI	AC0,-1(AC10)	;  -
	IDIV	AC0,AC10	;  TO WORD COUNT
	POPJ	PP,

	;ZERO THE STANDARD LABEL AREA.   ***POPJ***

ZROSLA:	SETZM	STDLB.		;
	MOVEI	AC1,STDLB.+1	;TO
	HRLI	AC1,STDLB.	;FROM,TO
	BLT	AC1,STDLB.+15	;ZERO 16 WORD STD LABEL AREA
	POPJ	PP,

	;MOVE SPACES TO THE RECORD AREA.   ***POPJ***

ZROREC:	MOVE	AC1,[ASCII/     /]
	MOVEM	AC1,(FLG)	;ASCII SPACES IF ASCII RECORD
	TLNN	FLG,CDMASC	;SKIP IF ASCII
	SETZM	(FLG)		;SIXBIT SPACES TO FIRST WORD
	LDB	AC1,FTMRS.	;MAX REC SIZ
	MOVEI	AC2,5		;ASSUME ASCII
	TLNN	FLG,CDMASC	;SKIP IF ASCII
	MOVEI	AC2,6		;SIXBIT DEFAULT
	ADDI	AC1,-1(AC2)	;CONVERT TO 
	IDIV	AC1,AC2		;  WORDS
	TLNN	FLG1,STNDRD	;STANDARD LABELS?
	JRST	ZRORE1		;NO
	CAIGE	AC1,16		;IF RECORD AREA LT ALABEL?
	MOVEI	AC1,16		;YES, INCLUDE THE LABEL REMNANTS
ZRORE1:	HRLI	AC2,(FLG)	;THE FROM ADR
	HRRI	AC2,1(FLG)	;THE TO ADR
	ADDI	AC1,-1(FLG)	;THE UNTIL ADR
	BLT	AC2,(AC1)	;ZRAPP!
	POPJ	PP,		;

	;SAVE THE ACS ON THE PUSH DOWN STACK.   ***"POPJ"***

SAVAC.:	POP	PP,TEMP.	;POP OFF THE RETURN
	PUSH	PP,AC16		;SAVE AC16 - AC0
	MOVEI	AC16,15		;
	PUSH	PP,(I16)	;
	SOJGE	AC16,.-1	;
	MOVE	AC16,-16(PP)	;
	JRST	@TEMP.		;LAST ENTRY IS AC0

	;RESTORE THE ACS.   ***"POPJ"***

RSTAC1:	HRRZI	AC16,RET.1
	MOVEM	AC16,TEMP.
	SKIPA
RSTAC.:	POP	PP,TEMP.	;RESTORE AC0 - AC16
	HRLZI	AC16,-16	;
	POP	PP,(I16)	;
	AOBJN	AC16,.-1	;
	POP	PP,AC16		;
	JRST	@TEMP.		;

	;FREE THE IO CHANNEL.   ***POPJ***
IFN ISAM,<
FRECH1:	SKIPA	AC2,ICHAN(I12)	;IDX-DEV'S CHAN
>

FRECHN:	LDB	AC2,FTCN.	;CHANNEL NUMBER
FRECH2:	MOVNS	AC2		;SHIFT TO THE RIGHT
	HRLZI	AC0,400000	;MASK BIT
	LSH	AC0,(AC2)	;POSITION THE MASK
	ORM	AC0,OPNCH.	;MAKES THE CHANNEL AVAILABLE
	POPJ	PP,		;

	;DISTRIBUTE THE CHANNEL NUMBER THROUGH THE UUO TABLE.   ***POPJ***

SETCN.:	LDB	AC5,FTCN.	;CHANNEL NUMBER
SETC1.:	MOVEI	AC10,ULAST.	;LAST LOCATION
	MOVE	AC6,[POINT 4,UFRST.,12]
	DPB	AC5,AC6		;INSERT THE CHAN NUMBER
	CAIE	AC10,(AC6)	;SKIP IF THE CURRENT LOC = LAST LOC
	AOJA	AC6,.-2		;LOOP TILL THE LAST LOC
	POPJ	PP,

	;RETURN A FREE CHANNEL NUMBER IN AC5

GCHAN:	SKIPN	AC5,OPNCH.	;ANY CHANNELS AVAILABLE?
	SKIPA	AC2,[BYTE (5)10,2,4,5] ;FCBO,TMOF.
	SKIPA	AC6,OPNCBP	;YES, SKIP + GET BYTE POINTER
	JRST	MSOUT.		;ERROR MESSAGE + KILL
	ILDB	AC11,AC6	;GET FIRST CHAN FLAG
	SOJE	AC11,.+2	;JUMP IF IT WAS A ONE
	AOJA	AC5,.-2		;AC5 (RIGHT) HAS CHAN NUMBER
	DPB	AC11,AC6	;NOTE THAT CHAN UNAVAILABLE
	POPJ	PP,


	;INCREMENT THE REEL NUMBER BY ONE.   ***POPJ***

INCRN.:	LDB	AC2,DTRN.	;SIXBIT ADD ONE TO CURRENT REEL NUMBER
	MOVE	AC0,AC2		;SO THE REEL NUMBER MAY BE RESTORED
	TRNE	AC2,10
	TRNN	AC2,1		;SKIP IF INC. WILL CAUSE A CARRY OUT
	AOJA	AC2,INCRN1	;INCREMENT THE REEL NUMBER
	TRNE	AC2,1000
	TRNN	AC2,100
	SKIPA	AC2,100(AC2)	;THE CARRY BIT
	JRST	INCRN2		;99 IS MAX
	TRZ	AC2,11		;THE INCREMENT
INCRN1:	DPB	AC2,DTRN.	;SAVE AS CURRENT REEL NUMBER
	POPJ	PP,

INCRN2:	MOVE	AC2,[BYTE (5)10,31,20,2,4,14]
	PUSHJ	PP,MSOUT.
	TTCALL	3,[ASCIZ /99 IS THE MAXIMUM ACCEPTABLE REEL NUMBER/]
	JRST	KILL.


SUBTTL	WRITE OUT THE BUFFER

	;ALL BUFFERED OUTPUTS ARE DONE HERE.  ***POPJ***

WRTOUT:	AOS	D.OE(I16)	;BUMP OUTPUT COUNT
	XCT	UOUT.		;DO THE OUTPUT
	POPJ	PP,		;NORMAL RETURN

WRTWAI:	XCT	UWAIT.		;FOR ALL THE ERRORS
	XCT	UGETS.		;
	TRNE	AC2,740000	;ERRORS?
	JRST	WRTERR		;THERE ARE ERRORS.
WRTFIN:	TLNE	AC13,20		;MTA?
	TRNN	AC2,2000	;EOT?
	JRST	WRTXIT		;NOT A MAGTAPE EOT
	TLNE	AC16,READ+CLOSEF+CLOSER	;CLOSE OR READ?
	JRST	WRTXIT		;YES TYPE 'F' OR 'R' LABEL OR READ
	LDB	AC0,FTFP.	;COULD BE WRITE, OPEN, OR CLOSE 'B'
	JUMPN	AC0,WRTMFR	;JUMP IF MFR
	TLO	AC16,MTAEOT	;EOT FLAG
	JRST	WRTXIT		;

WRTMFR:	TTCALL	3,[ASCIZ/ENCOUNTERED AN "EOT" ON A MULTI FILE REEL WHILE PROCESSING/]
	HRLZI	AC2,(BYTE(5)10,31,20)
	JRST	MSOUT.		;/FILE ON DEVICE/ KILL.

	;READ EOF GETS A SKIP EXIT
WRTRSX:	TLO	FLG,ATEND	;SET READ AN "EOF"
WRTRS1:	AOS	(PP)		;SKIP EXIT VIA WRITE EXIT

WRTXIT:	XCT	UGETS.		;GET STATUS
	TLNE	AC13,20		;MAGTAPE?
	TRZA	AC2,762000	;MAGTAPE.
	TRZ	AC2,760000	;OTHER.
	XCT	USETS.		;SET STATUS
	POPJ	PP,		;RETURN

WRTERR:	TLNE	AC13,20		;MTA?
	TRNN	AC2,400000	;WRITE-LOCKED?
	JRST	WRTER1		;NO
	PUSHJ	PP,SAVAC.	;IT'S A WRITE-LOCKED MAGTAPE
	TTCALL	3,[ASCIZ /$ /]
	MOVE	AC2,[BYTE(5)22,27,10,31,20,4,14]
	PUSHJ	PP,MSOUT.	;"CANNOT DO OUTPUT TO <DEVICE><FILE>
	TTCALL	3,[ASCIZ/IS THE DEVICE WRITE ENABLED?/]
	PUSHJ	PP,STOP.	;"TYPE CONTINUE TO PROCEDE"
	PUSHJ	PP,RSTAC.	;RESTORE THE ACS
	TRZ	AC2,760000	;TURN OFF THE ERROR BITS
	XCT	USETS.		;SET STATUS
	JRST	WRTOUT		;TRY AGAIN

WRTER1:	MOVE	AC2,[BYTE(5)36,31,20,10,4,14]
	PUSHJ	PP,MSOUT.	;"OUTPUT ERROR ON <DEVICE><FILE>"
	PUSHJ	PP,IOERMS	;THE ERROR
	TLNE	AC16,OPEN+CLOSEB+CLOSER+CLOSEF	;SKIP IF NOT OPEN OR CLOSE
	JRST	KILL.		;
	MOVEI	AC1,0		;ERROR USE PROCEDURE
	PUSHJ	PP,USEPRO	;PERFORM IT
	JRST	WRTFIN		;NORMAL RETURN
	JRST	KILL.		;SKIP RETURN, THERE WAS NO USEPRO

IOERMS:	XCT	UGETS.		;GET STATUS AC2*************
IOERM1:	PUSHJ	PP,ERCODE	;OUTPUT ERROR STATUS
	TRNE	AC2,400000
	TTCALL	3,[ASCIZ/ IMPROPER MODE/]
	TRNE	AC2,200000
	TTCALL	3,[ASCIZ/ DEVICE ERROR/]
	TRNE	AC2,100000
	TTCALL	3,[ASCIZ/ DATA ERROR/]
	TRNN	AC2,40000
	POPJ	PP,
	TLNE	AC13,200000	;DSK?
	TTCALL	3,[ASCIZ / QUOTA EXCEEDED, FILE STRUCTURE OR RIB FULL/]
	TLNE	AC13,100	;DTA?
	TTCALL	3,[ASCIZ / BLOCK NUMBER TOO LARGE OR DEC-TAPE IS FULL/]
	TLNN	AC13,200100	;ONLY ONE MESSAGE
	TTCALL	3,[ASCIZ/ BLOCK TOO LARGE/]
	POPJ	PP,

	;OUTPUT CONTENTS OF AC2 BITS 18-35 (ERROR STATUS)
ERCODE:	MOVEI C,"("		;
	TTCALL	1,C		;OUTPUT (
	MOVEI	AC1,6		;SIX OCTAL NUMBERS
	MOVE	AC0,[POINT 3,2,17]
ERCOD1:	ILDB	C,AC0		;GET NUMBER
	ADDI	C,"0"		;ASCIZE IT
	TTCALL	1,C		;OUTPUT IT
	SOJG	AC1,ERCOD1	;LOOP
	MOVEI	C,")"		;
	TTCALL	1,C		;OUTPUT )
	POPJ	PP,
SUBTTL	READ INTO THE BUFFER

	;ALL BUFFERED INPUTS ARE DONE HERE.  ***POPJ***

READIN:	AOS	D.IE(I16)	;BUMP INPUT COUNT
	XCT	UIN.		;***********************
	POPJ	PP,		;NORMAL RETURN
				;SKIP RETURN IF OPEN/CLOSE/READ EOF
	XCT	UWAIT.		;WAIT FOR ALL THE ERRORS********
	MOVE	AC1,D.IBH(I16)	;BUFFER LOCATION
	HRR	AC1,-1(AC1)	;BUFFER STATUS
READI1:	XCT	SZEOF.		;;;. AND .+1 MAY BE REMOVED WHEN MONITOR IS FIXED
	TRO	AC1,20000	;;;I.E. WHEN "EOF" IS STORED WITH BUFFER STATUS
	TRNE	AC1,2000	;SKIP IF AN "EOT"
	TLO	AC16,MTAEOT	;"EOT" FLAG FOR READEF+N
	TRNN	AC1,760000	;SKIP IF ANY ERRORS IN THE CURRENT BUFFER
	JRST	WRTXIT		;CLEAR THE ERRORS AND POPJ

	TRNN	AC1,20000	;SKIP IF AN EOF
	JRST	REAERR		;REAL ERRORS!
	TLNN	AC16,OPEN+CLOSEB+CLOSER+CLOSEF	;SKIP IF OPEN OR CLOSE
	JRST	WRTRSX		;JUMP, IT'S READ OR WRITE "EOF"
READI2:	TTCALL	3,[ASCIZ/READ AN "EOF" INSTEAD OF A LABEL/]
	PUSHJ	PP,SAVAC.
	MOVE	AC2,[BYTE(5)30,10,31,20,37]	;CLOSE SO KILL.
	TLNN	AC16,CLOSEF+CLOSER	;SKIP IF FILE CANNOT BE CLOSED
	MOVE	AC2,[BYTE(5) 30,10,31,20,2,14]
	PUSHJ	PP,MSOUT.	;REEL <FILE> ON <DEVICE> CANNOT BE ---
	TTCALL	3,[ASCIZ/ WRONG REEL? /]	;OPENED
	JRST	WRTRS1		;SKIP EXIT NXT INST MUST BE JRST OPNFW4

REAERR:	MOVE	AC2,[BYTE (5) 35,31,20,10,4,14]
	PUSHJ	PP,MSOUT.
	PUSHJ	PP,IOERMS	;THE ERROR
	TLNE	AC16,OPEN+CLOSEB+CLOSER+CLOSEF	;SKIP IF NOT OPEN OR CLOSE
	JRST	KILL.		;
REAER1:	MOVEI	AC1,0		;ERROR USE PROCEDURE
	PUSHJ	PP,USEPRO	;PERFORM IT.
	JRST	WRTXIT		;NORMAL RETURN
	JRST	KILL.		;SKIP RETURN - NO ERROR USE PRO
SUBTTL	TODAY.	8JAN

;CALLED BY PUSHJ PP,TODAY.
;EXIT WITH DATE IN AC0 YYMMDD
;	   TIME IN AC1 HHMMSS

AC0=0				;YYMMDD
AC1=1				;HHMMSS
AC4=4				;TEMP
AC5=AC4+1			;TEMP
AC6=AC5+1			;TEMP
PP=17				;

INTERN	TODAY.,TODA1.,TODA2.

TODAY.:	CALLI	AC4,14		;DATE UUO ((Y-64)*12+(M-1))*31+D-1
TODA1.:	IDIVI	AC4,^D31	;PICK OFF THE DAY
	ADDI	AC5,1		;MAKE IT RIGHT
	PUSHJ	PP,TODA4.	;RETURNS TWO SIXBIT NUMBERS
	DPB	AC5,DAY		;XXXXDD
	IDIVI	AC4,^D12	;PICK OFF THE MONTH
	ADDI	AC5,1		;MAKE IT RIGHT
	PUSHJ	PP,TODA4.	;RETURNS TWO SIXBIT NUMBERS
	DPB	AC5,MONTH	;XXMMDD
	MOVEI	AC5,^D64	;GET THE BASE YEAR
	ADD	AC5,AC4		;PLUS YEARS SINCE THEN
	PUSHJ	PP,TODA4.	;SIXBIT
	DPB	AC5,YEAR	;YYMMDD-DATE FINISHED

	CALLI	AC4,23		;TIME UUO GETS TIME IN MILLISECONDS
	IDIVI	AC4,^D1000	;CONVERT TO SECONDS
	PUSHJ	PP,TODA3.	;PICK OFF SECONDS IN SIXBIT
	DPB	AC5,SECOND	;XXXXSS
TODA2.:	PUSHJ	PP,TODA3.	;PICK OFF MINUTES IN SIXBIT
	DPB	AC5,MINUTE	;XXMMSS
	MOVE	AC5,AC4		;WHAT'S LEFT IS HOURS
	PUSHJ	PP,TODA4.	;TO SIXBIT
	DPB	AC5,HOUR	;HHMMSS-TIME FINISHED
	POPJ	PP,		;RETURN

TODA3.:	IDIVI	AC4,^D60	;DIVIDE BY 60 FOR TIME
TODA4.:	IDIVI	AC5,^D10	;DIVIDE OUT A DECIMAL NUMBER
	LSH	AC5,6		;MAKE ROOM FOR THE REMIANDER
	ADDI	AC5,2020(AC6)	;CONVERT TO SIXBIT
	POPJ	PP,		;RETURN

YEAR:	POINT	12,AC0,11
MONTH:	POINT	12,AC0,23
DAY:	POINT	12,AC0,35
HOUR:	POINT	12,AC1,11
MINUTE:	POINT	12,AC1,23
SECOND:	POINT	12,AC1,35
IFN EBCDIC,<
;PUSHJ PP,JULIAN
;RETURNS WITH DATE IN AC0
;AS SIXBIT   YYDDD
JULIA0:	AOS	(PP)		;TAKE A SKIP EXIT

JULIAN:	SETZ	AC0,		;
	CALLI	AC4,14		;GET DATE
	IDIVI	AC4,^D31	;PICK OFF DAY-1
	ADDI	AC5,1		;DAY OF THE MONTH
	MOVE	AC1,AC5		;SAVE THE DAY
	IDIVI	AC4,^D12	;PICK OFF MONTH - 1
	ADDI	AC4,^D64	;GET YEAR IN AC4
	EXCH	AC4,AC5		;SWAP WITH MONTH INDEX
	PUSHJ	PP,TODA4.	;STORE THE SIXBIT YEAR
	DPB	AC5,YEAR	;  IN AC0
	ADD	AC1,DAYTAB(AC4)	;ADD PREVIOUS DAYS TO DAY OF MONTH
	CAIG	AC4,2		;PAST FEBRUARY?
	JRST	JULIA1		;YES
	IDIVI	AC4,4		;CHECK FOR LEAP YEAR
	CAIG	AC5,0		;LEAP YEAR?
	ADDI	AC1,1		;YES
JULIA1:	MOVE	AC4,AC1		;
	IDIVI	AC4,^D10	;DIVIDE OUT THE
	MOVE	AC1,AC5		;  UINTS AND
	IDIVI	AC4,^D10	;  THE TENS
	LSH	AC4,6		;SHIFT OVER THE HUNDREDS
	ADD	AC5,AC4		;ADD IN THE TENS
	LSH	AC5,6		;MAKE ROOM FOR THE UNITS
	ADDI	AC5,202020(AC1)	;ADDEM IN AND SIXBITIZE
	LSH	AC5,6		;GET THEM NEXT TO THE YEAR POSITION
	ADD	AC0,AC5		;   YYDDD
	POPJ	PP,

DAYTAB:	EXP	^D0	;JAN
	EXP	^D31	;FEB
	EXP	^D59	;MAR
	EXP	^D90	;APR
	EXP	^D120	;MAY
	EXP	^D151	;JUN
	EXP	^D181	;JUL
	EXP	^D212	;AUG
	EXP	^D243	;SEP
	EXP	^D273	;OCT
	EXP	^D304	;NOV
	EXP	^D334	;DEC
>
SUBTTL	ERROR MESSAGES	5-JAN-70

	;MOVE	AC2,[BYTE (5),1,2,3,4]	;CALLING
	;JRST	MSOUT.			;SEQUENCE

MSOUT.:	PUSHJ	PP,DSPL1.		;OUTPUT BUFFER AND "CRLF"
	MOVE	AC0,[POINT 5,AC2]	;POINT AT INDEX FROM AC0
	ILDB	AC1,AC0			;PLACE IT IN AC1
	XCT	MSAGE(AC1)		;EXECUTE THE TABLE ITEM
	JRST	.-2			;GO AGAIN

		;MSDEV OUTPUTS THE SIXBIT DEVICE NAME
MSDEV.:	SKIPN	.JBAPR			;SKIP IF NOT RESET UUO
	SKIPA	AC1,AC13		;ELSE MAKE SURE U GET THE RIGHT DEV
	HRRZ	AC1,D.ICD(I16)		;GET THE CURRENT DEVICE
	TTCALL	3,[ASCIZ/ DEVICE /]
	MOVE	AC3,(AC1)		;DEVICE NAME
MSDEV1:	MOVEI	AC4,6		;6 CHARS
	SKIPA	AC1,[POINT 6,AC3]	;POINT AT IT
MSFIL1:	PUSHJ	PP,OUT6B.		;ASCIZE IT AND PLACE IN BUFFER
MSFIL2:	ILDB	C,AC1			;PICKUP THE NEXT CHAR
	CAIE	C,0			;TERMINATE ON A SPACE
	SOJGE	AC4,MSFIL1		;  OR SATISFIED CHAR COUNT
	JRST	OUTBF.		;EXIT

		;MSFIL OUTPUTS THE SIXBIT FILE NAME
MSFIL.:	MOVEI	AC4,^D30	;30 CHARS
	TTCALL	3,[ASCIZ / FILE /]
	MOVE	AC1,[POINT 6,(I16)]	;POINT AT A FILE NAME
	PUSHJ	PP,MSFIL2		;OUTPUT FILE NAME

	;OUTPUT THE VALUE-OF-ID AS [ FILE  EXT ]
MSVID:	SKIPN	AC1,13(I16)	;BP TO VALUE OF ID
	POPJ	PP,		;EXIT IF NO ID
	TTCALL	3,[ASCIZ/ [/]
	MOVEI	AC4,11		;9 CHARACTERS
MSVID1:	ILDB	C,AC1
	PUSHJ	PP,OUT6B.	;ASCIZE IT TO THE BUFFER
	SOJG	AC4,MSVID1	;LOOP 9 TIMES
	PUSHJ	PP,OUTBF.	;DUMP THE BUFFER
	TTCALL	3,[ASCIZ/]/]	;
	POPJ	PP,		;EXIT

		;OUTPUT THE SIXBIT REEL NUMBER
MSDTRN:	LDB	AC3,DTRN.		;FROM THE DEVICE TABLE
	JRST	MSSLR1			;
MSSLRN:	HRL	AC3,STDLB.+4		;THE
	HLR	AC3,STDLB.+5		;  STANDARD
	ROT	AC3,-14			;  LABEL
	ANDI	AC3,7777		;  REEL NUMBER
MSSLR1:	TTCALL	3,[ASCIZ/ REEL /]
	ROT	AC3,-14
	JRST	MSDEV1
	;THE FOLLOWING 40 LOC TABLE IS "XCT"ED FROM MSOUT.

MSAGE:	JRST	KILL.					;0
	TTCALL	3,[ASCIZ/ SHARES BUFFER AREA WITH /]	;1
	TTCALL	3,[ASCIZ/ CANNOT BE OPENED/]		;2
	TTCALL	3,[ASCIZ/, ALREADY OPEN/]		;3
	TTCALL	3,[ASCIZ/
/]							;4
	TTCALL	3,[ASCIZ/ TOO MANY OPEN FILES/]		;5
	TTCALL	3,[ASCIZ/ IS NOT OPEN/]			;6
	TTCALL	3,[ASCIZ/ FOR INPUT/]			;7
	PUSHJ	PP,MSFIL.	;30 CHARACTER FILENAME	;10
	TTCALL	3,[ASCIZ/ FOR OUTPUT/]			;11
	TTCALL	3,[ASCIZ/ IS AT END/]			;12
	TTCALL	3,[ASCIZ/ IS NOT A DEVICE/]		;13
	POPJ	PP,		;RETURN			;14
	TTCALL	3,[ASCIZ/ IS NOT AVAILABLE TO THIS JOB/];15
	TTCALL	3,[ASCIZ/ IS ASSIGNED TO ANOTHER FILE/]	;16
	TTCALL	3,[ASCIZ . CANNOT DO INPUT/OUTPUT.]	;17
	PUSHJ	PP,MSDEV.	;6 CHARACTER DEVICE NAME;20
	TTCALL	3,[ASCIZ/ CANNOT DO INPUT/]		;21
	TTCALL	3,[ASCIZ/ CANNOT DO OUTPUT/]		;22
	TTCALL	3,[ASCIZ/ OR /]				;23
	PUSHJ	PP,STOP.				;24
	TTCALL	3,[ASCIZ/INIT TOOK THE ERROR RETURN/]	;25
	TTCALL	3,[ASCIZ/DIRECTORY DEVICES MUST HAVE STANDARD LABELS/]
	TTCALL	3,[ASCIZ/ TO/]				;27
	PUSHJ	PP,MSDTRN	;DEVICE TABLE REEL NUMBER;30
	TTCALL	3,[ASCIZ/ ON/]				;31
	TTCALL	3,[ASCIZ/LABELS MAY NOT BE OMITTED FROM DTA OR DSK FILES/]
	TTCALL	3,[ASCIZ/ BECAUSE IT IS NOT OPEN/]	;33
	PUSHJ	PP,MSSLRN	;STANDARD LABEL REEL NUMBER;34
	TTCALL	3,[ASCIZ/ INPUT ERROR/]			;35
	TTCALL	3,[ASCIZ/ OUTPUT ERROR/]		;36
	TTCALL	3,[ASCIZ/ CANNOT BE CLOSED/]		;37
	;LOOKUP OR ENTER ERROR MESSAGES.   ***KILL. OR OPNENR***

LUPERR:	TDZA				;LOOKUP ERROR
ENRERR:	SETO				;ENTER ERROR
	PUSHJ	PP,SAVAC.
	MOVE	AC2,22(I16)		;GET THE OEUP FLAG
	TLNN	AC2,OEUP		;LOOP ON FILE BEING MODIFIED?
	JRST	ENRER2			;NO
	SKIPN	(PP)			;IF NOT ENTER ERROR
	JRST	ENRER2			;  EXIT
	HRRZ	AC2,UEBLK.+1		;GET THE ERROR CODE
	TRZ	AC2,777740		;  CLEAR THE REST
	CAIN	AC2,3			;IF ERROR IS "FILE BEING MODIFIED"
	JRST	ENRAGN			;  SEE IF THERE IS AN ERROR USE PROCEDURE
ENRER2:	TLNN	AC16,OPEN	;OPEN OR CLOSE UUO
	SKIPA	AC2,[BYTE (5)10,37,31,20,4,14]	;CLOSE!
	MOVE	AC2,[BYTE (5)10,2,31,20,4,14]
	PUSHJ	PP,MSOUT.		;<FILE> CANNOT BE OPENED ON <DEVICE>
	MOVEI	AC2,[ASCIZ/
LOOKUP /]
	SKIPE	(PP)			;SKIP IF LOOKUP UUO
	MOVEI	AC2,[ASCIZ/
ENTER /]
	SKIPE	PRGFLG			;RENAME FAILURE?
	MOVEI	AC2,[ASCIZ /
RENAME /]
	TTCALL	3,(AC2)			;LOOKUP (OR ENTER)
	TTCALL	3,[ASCIZ/FAILED, /]
	HRRZ	AC2,ULBLK.+1
	SKIPE	(PP)			;SKIP IF LOOKUP UUO
	HRRZ	AC2,UEBLK.+1
	TRZ	AC2,777740		;SAVE ONLY THE ERROR BITS
	PUSHJ	PP,ERCODE	;OUTPUT THE ERROR CODE
	CAIL	AC2,LEMLEN	;A LEGAL ERROR CODE?
	HRRI	AC2,LEMLEN	;NO, GIVE CATCH-ALL
	JUMPN	AC2,ENRER1	;
	SKIPE	(PP)		;SKIP IF LOOPUP
	HRRI	AC2,LEMLEN+1	;ILL-FIL-NAME NOT FIL-NOT-FND
ENRER1:	TTCALL	3,@LEMESS(AC2)		;TYPE A MESSAGE
	MOVE	AC13,D.ICD(I16)		;DEVICE NAME FOR DEVCHR
	CALLI	AC13,4			;DEVCHR
	SKIPN	(PP)			;KILL IF ENTER
	TLNN	AC13,120		;A REEL DEVICE?
	JRST	KILL.			;NO
	JUMPN	AC2,KILL.		;KILL. IF NOT UNFOUND FILE
	TTCALL	3,[ASCIZ/ WRONG REEL?  /]
	PUSHJ	PP,STOP.		;WAIT FOR CONTINUE
	PUSHJ	PP,RSTAC.		;RESTORE THE ACS
	TLNN	AC16,-1			;SKIP IF NOT CALLED W/ A PUSHJ
	POPJ	PP,			;EXIT TO RRDMP
	JUMPE	AC0,OPNLUP		;TRY
	JRST	OPNENR			;AGAIN.

	;PERFORM USE PROCEDURE AND RETRY ENTER UUO
	;LOOP TILL ENTER WINS OR USER GIVES UP IN USE-PRO.
ENRAGN:	MOVEI	AC1,0			;PERFORM
	PUSHJ	PP,USEPRO		;  ERROR USE PRO
	JRST	.+2			;NORMAL RETURN
	JRST	ENRER2			;NO USE PRO - GIVE ERROR MESS. AND KILL
	PUSHJ	PP,RSTAC.		;RESTORE ACS
IFN ISAM,<
	TLNE	FLG1,EIX		;IF INDEX FOR ISAM FILE
	JRST	OPNI00			;  EXIT HERE
>
	JRST	OPNENR			;TRY AGAIN
	;LOOKUP/ENTER ERROR MESSAGES

LEMESS:	[ASCIZ	/ FILE NOT FOUND/]
	[ASCIZ	/ UFD DOES NOT EXIST/]
	[ASCIZ	/ PROTECTION FAILURE OR DTA DIRECTORY FULL/]
	[ASCIZ	/ FILE BEING MODIFIED/]
	[ASCIZ	/RNAM/]		;RENAME FILE ALREADY EXIST
	[ASCIZ	/RNAM/]		;ILLEGAL SEQUENCE OF UUOS
	[ASCIZ	. DEVICE OR UFD/RIB DATA ERROR.]
	[ASCIZ	/ NOT A SAVED FILE/]
	[ASCIZ	/ NOT ENOUGH CORE/]
	[ASCIZ	/ DEVICE NOT AVAILABLE/]
	[ASCIZ	/ NO SUCH DEVICE/]
	[ASCIZ	/ GETSEG REQUIRES TWO RELOCATION REGISTERS/]
	[ASCIZ	/ QUOTA EXCEEDED OR NO ROOM ON FILE STRUCTURE/]
	[ASCIZ	/ WRITE LOCKED FILE STRUCTURE/]
	[ASCIZ	/ NOT ENOUGH MONITOR TABLE SPACE/]
	[ASCIZ	/ PARTIAL ALLOCATION ONLY/]
	[ASCIZ	/ ALLOCATED BLOCK NOT FREE/]

LELAST:	[ASCIZ / LOOKUP, ENTER OR RENAME ERROR/]
LEMLEN==LELAST-LEMESS
	[ASCIZ / ILLEGAL FILENAME/]
SUBTTL	CLOSE-UUO

PURGE.:	TLZ	AC16,(Z 17,)
	TLO	AC16,(Z 1,)	;MAKE PURGE BE A CLOSE UUO
	SETOM	PRGFLG		;REMEMBER TO RENAME TO ZERO

	;A CLOSE. UUO LOOKS LIKE:
	;001040,,ADR	WHERE ADR = FILE TABLE ADDRESS
	;BIT9  =0	CLOSE FILE
	;BIT9  =1	CLOSE REEL
	;BIT10 =1	LOCK,  LOCKED FILES MAY NOT BE REOPENED
	;BIT11 =1	DON'T REWIND
	;BIT12 =1	ALWAYS 1  (VS. 0 = OPEN)
	;CALL+1:	POPJ RETURN

	;EXIT IF OPTIONAL FILE IS NOT PRESENT, ERROR MESSAGE IF IT'S NOT
	;OPEN OR IF IT'S A "CLOSE REEL" AND A MULTI-FILE REEL.
	;WRITE OUT ANY ACTIVE DATA REMAINING IN THE BUFFER FROM RANDOM
	;OR IO FILES.

CLOSE.:	MOVE	FLG,10(I16)	;PICK UP THE FLAGS
	HLLZ	FLG1,D.F1(I16)	;MORE FLAGS
	TLNN	FLG,NOTPRS	;SKIP IF FILE IS NOT PRESENT
	JRST	CLOS01		;  BUT IT IS
	SETZM	PRGFLG		;INCASE IT WAS CLOSE WITH DELETE
	TLZ	FLG,OPNIN!OPNOUT!ATEND!NOTPRS!CONNEC
	MOVEM	FLG,10(I16)	;REINIT THE FLGS
	POPJ	PP,		;EXIT
CLOS01:	TLNN	FLG,OPNIN+OPNOUT
	SKIPA	AC2,[BYTE(5)10,31,20,37,33]
	SKIPA	AC13,D.DC(I16)	;PICK UP DEVICE CHARACTERISTICS
	JRST	MSOUT.		;FILE WAS NOT OPEN.
	TLNN	AC13,4		;A DIRECTORY DEVICE?
	SETZM	PRGFLG		;NO - SO WE CAN'T PURGE
	TLNE	AC13,10		;A TTY FILE?
	SETZM	TTYOPN		;YES, NOTE THAT IT'S CLOSED
	LDB	AC5,FTFP.	;FILE POSITION ON TAPE
	TLNE	AC16,400	;SKIP IF NOT CLOSE REEL
	TLOA	AC16,CLOSER	;% CLOSE REEL
	TLOA	AC16,CLOSEF	;% CLOSE FILE
	JUMPN	AC5,CLOSF5	;CLOSE "REEL" A MULTI-FILE-REEL - AN ERROR

	TLNE	AC16,CLOSER	;
	TLNE	AC13,20		;CLOSE REEL AND NOT  MTA?
	JRST	CLOS00		;NO
	TTCALL	3,[ASCIZ /CLOSE REEL IS LEGAL ONLY FOR MAG-TAPE
/]
	MOVE	AC2,[BYTE(5) 10,31,20,37,4,14]
	JRST	MSOUT.		;NON-FATAL CONTINUE WITH A POPJ

CLOS00:	PUSHJ	PP,SETCN.	;DISTRIBUTE THE CHAN NUMBER
	HLRZ	AC12,D.BL(I16)	;BUFFER LOCATION
IFN ISAM,<
	TLNE	FLG,IDXFIL	;INDEXED FILE?
	JRST	CLSISM		;YES
>
	TLNN	FLG,RANFIL+OPNIO;SKIP IF RANDOM OR IO
	JRST	CLOSE1		;
	TLNE	FLG,DDMASC!RANFIL	;SKIP IF IO-FILE
	JRST	CLOSE0		;
	TLC	FLG,OPNIN!OPNOUT!ATEND ;
	TLCE	FLG,OPNIN!OPNOUT!ATEND ;SKIP IF IO-FILE AND ATEND
	TLNN	FLG,OPNIN	;SKIP IF OPEN FOR INPUT
	PUSHJ	PP,CLSZBF	;IO-FILE AND ATEND OR OUTPUT FILE
CLOSE0:	SKIPE	6(I12)		;SKIP IF NO ACTIVE  DATA IN BUFFER
	PUSHJ	PP,RANOUT	;WRITE IT OUT
	HLLZS	UOUT.		;CLEAR IOWD POINTER
	JRST	CLOSE3		;
	;PAD THE LAST LOGICAL BLOCK IF NECESSARY.

CLOSE1:	TLNE	FLG,OPNOUT	;SKIP IF NOT AN OUTPUT FILE
	SKIPG	AC5,D.BCL(I16)	;SKIP IF BUFFER/BLOCK IS NOT 0
	JRST	CLOSE3		;
	TLNE	FLG,DDMBIN	;IF BINARY MODE,
	JRST	CLOSE3		;  WE DON'T PAD

	CAME	AC5,D.BPL(I16)	;SKIP IF = BUF/LOGBLK
	JRST	CLOSE2		;PAD THE LOGICAL BLOCK
	HRRZ	AC1,D.OBH(I16)	;ADR OF CURRENT BUF+1
	HRRZ	AC3,D.OBB(I16)	;ADR OF BYTE PTR
	SKIPL	D.OBB(I16)	;440S00,,LOC MEANS BUF EMPTY
	CAIN	AC1,-1(AC3)	;SKIP IF DATA IN BUFFER
	JRST	CLOSE3		;
CLOSE2:	IBP	D.OBB(I16)	;FAKE OUT DSKSER
	PUSHJ	PP,WRTBUF	;PAD THE LOGBLK
	SOJG	AC5,.-2		;LOOP TILL LOGBLK IS FULL

	;READ A LABEL, DO BEFORE ENDING FILE/REEL USE PROCEEDURE,
	;AND CHECK FOR "EOF/V" LABEL TYPE.

CLOSE3:	TLNN	FLG,OPNOUT!ATEND
	JRST	CLOSE8		;SKIP LABEL PROCESSING, READ AND NOT ATEND
	TLNE	FLG,OPNIN	;IF INPUT,
	PUSHJ	PP,CLSRL	;READ A LABEL
CLOSE4:	MOVEI	AC1,3		;
	PUSHJ	PP,USEPRO	;BEFORE ENDING FILE/REEL
	TLNN	FLG,OPNIN	;SKIP IF INPUT
	JRST	CLOSE6		;JUMP IF OUTPUT
	TLNE	FLG1,STNDRD	;SKIP IF NOT STD LABELS
	TLNN	AC16,CLOSER	;SKIP IF CLOSE REEL
	JRST	CLOSE7		;
	PUSHJ	PP,CLSEOV	;CHECK FOR EOV
	JRST	CLOSE7		;
	TTCALL	3,[ASCIZ /STANDARD END-OF-REEL LABELS MUST HAVE "EOV" AS THE FIRST THREE CHARACTERS/]
	MOVE	AC2,[BYTE (5)10,31,20,37]
	JRST	MSOUT.		;TYPE IT OUT

	;CREATE A LABEL,DO AFTER ENDING FILE/REEL USE PROCEEDURE,
	;WRITE OUT THE LABEL AND LOCK THE FILE.

CLOSE6:	PUSHJ	PP,CLSCAL	;CREATE STD MTA ENDING LABEL
CLOSE7:	MOVEI	AC1,4		;
	PUSHJ	PP,USEPRO	;AFTER ENDING FILE/REEL
	TLNE	FLG,OPNOUT	;SKIP IF NOT OUTPUT
	PUSHJ	PP,CLSWEL	;WRITE ENDING LABEL MAYBE

CLOSE8:	TLNE	AC16,400	;SKIP IF CLOSE FILE
	JRST	CLOSR1		;CLOSE REEL
	TLNN	AC16,200	;LOCK THE FILE?
	JRST	CLOSF1		;NO
	HRLZI	AC0,LOCK	;SET THE LOCK FLAG
	ORM	AC0,D.LF(I16)	;SAVE IT
	XCT	MREWU.		;REWIND AND UNLOAD**************
	JRST	CLOSF2
	;REWIND OR POSITION THE MTA, RESET THE FLAGS, RELEASE THE
	;DEVICE AND EXIT.  ***POPJ***ACP***

CLOSF1:	TLNE	AC16,100	;REWIND REQUEST?
	JRST	CLOSF3		;NO
	PUSHJ	PP,OPNRWD	;REWIND UUO
CLOSF2:	HRLZI	AC0,HUF		;"HUF" FLAG
	ANDCAM	AC0,D.HF(I16)	;CLEAR IT
	JRST	CLOSF4		;

CLOSF3:	LDB	AC5,FTFP.	;GET FILE POSITION
	JUMPE	AC5,CLOSF4	;DONT POSITION IF NONE IS SPECIFIED
	TLNN	FLG,OPNOUT	;OPEN FOR OUTPUT?
	JRST	CLOSF9		;NO
	TLNE	FLG1,NONSTD!STNDRD  ;LABELED FILE?
	XCT	MBSPF.		;YES, BACK INTO THE LABEL
CLOSF9:	TLNE	FLG,OPNOUT!ATEND  ;SKIP IF INPUT AND NOT "AT-END"
	XCT	MBSPF.		;BACK SPACE INTO THE FILE
	XCT	UGETS.		;
	TRZ	AC2,20000	;
	XCT	USETS.		;CLEAR THE "EOF" FLAG
	XCT	MBSPR.		;BACKUP ONE RECORD
	XCT	SZEOF.		;
	XCT	MADVF.		;UNLESS IT WAS AN "EOF"
CLOSF4:	IFN ISAM,<
	TLNN	FLG,IDXFIL	;INDEX FILE?
	JRST	CLOSF7		;NO
	PUSHJ	PP,CLSIDX	;YES, CLOSE & RELEAS THE INDEX-FILE
	PUSHJ	PP,FRECH1	;MAKE CHAN AVAILABLE
	MOVE	AC1,CORE0(I12)	;UNTIL,,FROM
	SETZM	(AC1)		;ZERO FIRST WORD
	HLRZ	AC2,AC1		;UNTIL
	HRL	AC1,AC1		;FROM,,FROM
	ADDI	AC1,1		;FROM,,TO
	BLT	AC1,(AC2)	;ZERO
CLOSF7:>
	SKIPN	PRGFLG		;PURGE?
	JRST	CLOSF8		;NO
	TLNN	FLG,OPNIN!RANFIL!IDXFIL	;SUPERSEDING?
	JRST	CLOS75		;COULD BE - GO SEE
CLOS71:	PUSHJ	PP,OPNEID	;
	SETZM	UEBLK.		;ZERO THE FILE-NAME
	XCT	URNAM.		;DELET IT *******************
	 PUSHJ	PP,ENRERR	;ERROR RET
CLOS72:	SETZM	PRGFLG		;CLEAR THE FLG
CLOSF8:	SETZM	D.DC(I16)	;DEVICE CHARACTERISTICS
	TLZ	FLG,OPNIN+OPNOUT+ATEND+NOTPRS+CONNEC
	MOVEM	FLG,10(I16)	;REINITIALIZE THE FLAGS
	HLLM	FLG1,D.F1(I16)	;REINIT MORE FLAGS
	XCT	URELE.		;RELEASE THE DEVICE**************
	JRST	FRECHN		;EXIT TO THE ***"ACP"***

CLOSF5:	MOVE	AC2,[BYTE(5)10,31,20,37,14]
	PUSHJ	PP,MSOUT.
	TTCALL	3,[ASCIZ/
THE CLOSE "REEL" OPTION MAY NOT BE USED WITH A MULTI-FILE-TAPE./]
	JRST	KILL.

;THE FOLLOWING LINES HAVE BEEN INSERTED TO REPLACE THE
;FOUR LINES AT LABEL CLOS75:  AS ORIGINALLY FOUND IN
;CBLIO.MAC AS RECEIVED FROM DEC ON THE APRIL 73  LANG
;TAPE.

;THIS CHANGE WAS NECESSITATED BY  RESDV. (CALLI 117) NOT
;BEING IMPLEMENTED IN THE TYMSHARE MONITOR.

CLOS75: LDB     AC1,  FTCN.             ;GET THE CHANNEL NUMBER
        DEVCHR  AC1,                    ;DETERMINE IF CHANNEL IN USE
        JUMPE   AC1,  CLOS71            ;CHANNEL NOT INIT'D 
        LDB     AC1,  FTCN.             ;RE-GET THE CHANNEL NUMBER
        MOVE    AC3,  [CLOSE  40]       ;BUILD THE CLOSE OPERATOR
                                        ;*NOTE*  AC3 HAS BEEN USED
                                        ;ARBITRARILY BECAUSE IT APPEARS
                                        ;TO BE UNUSED/FREE AT THIS POINT
        DPB     AC1,  [POINT 4,AC3,12]  ;INSERT THE CHANNEL NUMBER
        XCT     AC3,                    ;EXECUTE THE CLOSE
        MOVSI   AC3,  (RELEASE)         ;BUILD THE RELEASE OPERATOR
        DPB     AC1,  [POINT 4,AC3,12]  ;INSERT THE CHANNEL NUMBER
        XCT     AC3,                    ;EXECUTE THE RELEASE
        JRST    CLOS72

;THE FOLLOWING FOUR LINES HAVE BEEN REPLACED BY
;THE CODE ABOVE, FROM  CLOS75:  DOWN.

;CLOS75:	LDB	AC1,FTCN.	;GET THE CHANNEL NUMBER
;	RESDV.	AC1,		;RESET THIS CHANNEL IE DELETE
;	  JRST	CLOS71		;FAILED SO RENAME TO ZERO
;	JRST	CLOS72		;RETURN

	;CLOSE REEL, REWIND AND UNLOAD, RELEASE THE DEVICE, GENERATE
	;AN OPEN UUO AND GO DOIT.  ***OPNDEV***

CLOSR1:	TLZ	AC16,777675	;CLEAR ALL BUT REWIND&SLURP FLAGS
	TLO	AC16,OPEN!CLOSEB ;OPEN WITH A REWIND
	TLNN	FLG,RRUNER	;RERUN ON END OF REEL?
	JRST	CLOSR2		;NO
	SETZM	D.OE(I16)	;CLEAR THE NUMBER OF INS + OUTS SO
	SETZM	D.IE(I16)	;  RERUN DOESNT ROCK MAGTAPE
	PUSHJ	PP,RRDMP	;YES
	PUSHJ	PP,RSAREN	;RESTORE .JBSA, .JBREN
	PUSHJ	PP,SETCN.	;CHAN NUMBERS DISTURBED BY RRDMP CODE
	XCT	UCLOS.		;ELSE RELEASE TRYS TO DUMP "DUMMY BUFFER" CAUSED BY DUMMY OUT
				;  WHICH CAUSES REQUEST FOR OPR1 INTERVENTION!!?
CLOSR2:	TLZN	AC16,100	;SKIP IF NO REWIND
	XCT	MREWU.		;REWIND AND UNLOAD
	PUSHJ	PP,INCRN.	;INCREMENT THE DEVTAB REEL NUMBER
	PUSHJ	PP,FRECHN	;NOTE THE CHAN IS FREE
	MOVE	AC0,D.ICD(I16)	;GET THE NEXT DEVICE
	AOBJN	AC0,.+2		;JUMP IF THERE IS ONE
	PUSHJ	PP,DEVIOW	;RESET DEVICE IOWD
	MOVEM	AC0,D.ICD(I16)	;SAVE AS CURRENT IF THERE IS
	TLNN	FLG,OPNIN	;SKIP IF INPUT
	JRST	CLOSR3		;JUMP IF OUTPUT
	TTCALL	3,[ASCIZ/
$ MOUNT/]
	PUSHJ	PP,MSDTRN	;"REEL N"
	TTCALL	3,[ASCIZ/ OF/]
	MOVE	AC2,[BYTE (5)10,31,20,24,14]
	PUSHJ	PP,MSOUT.	;"FILE ON DEV" STOP0
	JRST	CLOSR4		;OPEN THE NEXT REEL

CLOSR3:	TTCALL	3,[ASCIZ/
$ MOUNT SCRATCH TAPE ON/]
	PUSHJ	PP,MSDEV.	;DEVICE
	PUSHJ	PP,STOP.	;TYPE CONT TO PRO
CLOSR4:	XCT	URELE.		;RELEASE THE DEVICE
	JRST	OPNDEV		;OPEN THE NEXT REEL
	;READ A LABEL INTO THE RECORD AREA OR ZERO IT.  ***@POPJ***

CLSRL:	TLNN	FLG,ATEND	;SKIP IF AT END
	POPJ	PP,		;
	TLNE	AC13,20		;SKIP IF NOT A MAGTAPE
	TLNN	FLG1,NONSTD+STNDRD ;SKIP IF NOT OMITTED LABELS
	POPJ	PP,		;ZERO THE RECORD AREA
	XCT	UCLOS.		;CLEAR THE EOF
	PUSHJ	PP,CLSYNC	;SET SYNCHRONOUS MODE BIT
	PUSHJ	PP,READIN	;READ A LABEL
	JRST	CLSRL1		;NORMAL RETURN
	PUSHJ	PP,CLSRL0	;EOF - NOT A LABEL?
	JRST	CLSYNC		;CLEAR SYNC-MODE AND EXIT
CLSRL1:	PUSHJ	PP,CLSYNC	;CLEAR IT
	JRST	BUFREC		;MOVE IT TO THE RECORD AREA

CLSRL0:	XCT	READI2		;EOF - SO COMPLAIN
	MOVE	AC2,[BYTE (5)35,31,20,10,4,14]
	PUSHJ	PP,MSOUT.	;
	JRST	REAER1		;TRY FOR AN ERROR USE PROCEDURE

	;CHECK FOR "EOV" AS FIRST THREE LABEL CRARACTERS

CLSEOV:	TLNE	FLG,CDMASC	;SKIP IF NOT ASCII RECORD AREA
	JRST	CLSEO1		;ASCII TEST
	HLRZ	C,(FLG)		;FIRST 3 CHARS
	CAIN	C,(SIXBIT /EOV/)
	POPJ	PP,		;OK EXIT
	JRST	RET.2		;ERROR SKIP RET
CLSEO1:	MOVE	C,(FLG)		;FIRST WORD
	TRZ	C,77777		;CLEAR EXTRANEOUS BITS
	CAMN	C,[ASCIZ /EOV/]
	POPJ	PP,		;OK EXIT
	JRST	RET.2		;ERROR SKIP EXIT
IFN ISAM,<
	;CLOSE & RELEASE THE INDEX FILE
CLSIDX:	PUSHJ	PP,SETIC	;SET THE CHANNEL NUMBER
	SKIPE	PRGFLG		;DELETE THE FILE
	JRST	CLSID2		;YES SO GO DO IT
	TLNE	FLG,OPNOUT	;OPEN FOR OPTPUT?
	PUSHJ	PP,WSTBK	;WRITE THE STATISTICS BLOCK
	XCT	ICLOS		;
	PUSHJ	PP,IOUTER	;CATCH ANY ERRORS NOW
	JRST	CLSID1		;
CLSID2:	PUSHJ	PP,OPNEIX	;
	SETZM	UEBLK.		;ZERO THE FILENAME
	XCT	IRNAM		;DELET
	 PUSHJ	PP,ENRERR	;ERROR RET
CLSID1:	XCT	IRELE		;
	POPJ	PP,

	;WRITE OUT ALL ACTIVE ISAM DATA STILL IN CORE
CLSISM:	PUSHJ	PP,SETIC	;SET INDEX FILE CHAANNEL NUMBER
	SKIPE	LIVE(I12)	;IF ANY ACTIVE DATA
	PUSHJ	PP,WWDBK	;  OUTPUT IT
	MOVE	AC13,D.DC(I16)	;RESTORE AC13 ALIAS LVL
	JRST	CLOSE4
>
	;CREATE A LABEL OR ZERO IT.  ***@POPJ***

CLSCAL:	TLNE	AC13,20		;SKIP IF DEVICE IS NOT A MTA
	TLNN	FLG1,STNDRD	;SKIP IF STANDARD LABELS
	POPJ	PP,		;CLEAR RECORD AREA
	JRST	OPNCAL		;CREATE A LABEL FOR A MTA W/ STD LABELS

	;WRITE AN ENDING LABEL AND DO FINAL ERROR CHECKS.  ***@POPJ***

CLSWEL:	SKIPN	PRGFLG		;DON'T OUTPUT IF DELETE IS NEXT
	XCT	UCLOS.		;DUMP ALL THE BUFFERS
	PUSHJ	PP,WRTWAI	;WAIT FOR ERROR CHECKING
	TLNE	AC13,20		;SKIP NOT A MAGTAPE
	TLNN	FLG1,NONSTD+STNDRD ;SKIP IF LABELS ARE NOT OMITTED
	POPJ	PP,		;
	XCT	UOUT.		;DUMMY OUTPUT
	PUSHJ	PP,RECBUF	;MOVE RECORD TO THE BUFFER AREA
	PUSHJ	PP,WRTOUT	;OUTPUT IT
	XCT	UCLOS.		;LEOT
	JRST	WRTWAI		;WAIT FOR ERROR CHECKING

	;TO KEEP OUR MTA BUFFERS STRAIGHT.  ***POPJ***

CLSYNC:	XCT	UGETS.		;SET OR CLEAR
	TRC	AC2,40		;    THE SYNCHRONOUS
	XCT	USETS.		;    MODE STATUS BIT
	POPJ	PP,		;    FOR MAGTAPE

	;ZERO THE UNUSED AREA OF THE DUMP MODE BUFFER

CLSZBF:	HRRZ	AC1,2(I12)	;LOC
	SUB	AC1,(I12)	;LOC - LOC-1
	HLRO	AC2,(I12)	;-LEN
	MOVN	AC2,AC2		;LEN
	SUBI	AC2,(AC1)	;LENGTH TO CLEAR
	HRR	AC1,2(I12)	;LOC
	HRL	AC1,AC1		;FROM
	HRRI	AC1,1(AC1)	;TO
	SETZM	-1(AC1)		;THE ZERO
	ADDI	AC2,-1(AC1)	;UNTIL
	CAIL	AC2,(AC1)	;JUST EXIT IF BUFFER IS FULL
	BLT	AC1,(AC2)	;DOIT
	POPJ	PP,
SUBTTL	WRITE-UUO

	;A WRITE. UUO LOOKS LIKE:
	;002140,,ADR	WHERE ADR = FILE TABLE ADDRESS
	;CALL+1:	0-11 RECORD SIZE IN CHARACTERS
	;		12-35 UNDEFINED
	;CALL+2:	NORMAL POPJ RETURN
	;CALL+3:	"INVALID-KEY" RETURN

	;A WADV. UUO LOOKS LIKE:
	;002200,,ADR	WHERE ADR = FILE TABLE ADDRESS
	;CALL+1:	0-11 RECORD SIZE IN CHARACTERS
	;BIT12 =1	USE 18-35 AS AN ADDRESS
	;BIT13 =0	WRITE AFTER ADVANCING
	;BIT13 =1	WRITE BEFORE ADVANCING
	;BIT14-17	ADVANCE VIA THIS LPT CHANNEL
	;BIT18-35	NUMBER OF TIMES TO ADVANCE
	;CALL+2:	NORMAL POPJ RETURN

	;SETUP AND INITIAL CHECKS.  ***WRTREC***RANDOM***
WADV.:	TLOA	AC16,WADV	;WRITE ADVANCE
WRITE.:	TLO	AC16,WRITE	;WRITE
	SETZM	NOCR.		;CLEAR NO CARRIAGE RET FLAG
	SKIPA	AC15,@UOCAL.	;OPERAND OR RETURN ADR
WRPW.:	SETOM	NOCR.		;REPORT-WRITER ENTRY
	PUSHJ	PP,WRTSUP	;SETUP
	LDB	AC3,WOPRS.	;RECORD SIZE FROM AC15
WRITE1:	TLNN	FLG,OPNOUT	;SKIP IF OPEN FOR OUTPUT
	PUSHJ	PP,ERROPN	;ERROR MESSAGE
IFN ISAM,<
	TLNE	FLG,IDXFIL	;
	JRST	IWRITE		;WRITE AN INDEX-FILE
>
	TLNE	FLG,RANFIL+OPNIO ;SKIP IF NOT RANDOM OR I/O
	JRST	RANDOM		;RANDOM AND IO EXIT HERE
	JUMPL	FLG,WRTREC	;ASCII
	TLNE	FLG,DDMBIN	;IF BINARY,
	JRST	WRTR20		;  USE THIS ROUTINE

	;CHECK AND WRITE OUT VARIABLE LENGTH RECORD SIZE
	PUSHJ	PP,WRTABP	;ADJUST THE BYTE-POINTER
IFN EBCDIC,<
	TLNE	FLG,DDMEBC	;EBCDIC?
	JRST	WEBC00		;YES - USE EBCDIC ROUTINE
>
	MOVE	AC4,D.RP(I16)	;GET RECORD SEQUENCE NUMBER
	TLNE	AC13,20		;MTA?
	HRLM	AC4,(AC1)	;YES - STORE IN THE HEADER WORD
	HRRM	AC3,(AC1)	;MOVE RECSIZE TO THE BUFFER
	AOS	D.OBB(I16)	;SO REC-SIZE IS NOT OVERWRITTEN
	MOVN	AC4,D.BPW(I16)	;MAKE BYTE COUNT
	ADDB	AC4,D.OBC(I16)	; RIGHT
	JUMPN	AC4,WRTREC	;JUMP IF BUFFER IS NOT FULL
	TLNN	FLG,CONNEC	;SKIP IF CONVERSION IS NECESSARY
	SOS	D.OBB(I16)	;BACKUP THE BYTE-POINTER
	PUSHJ	PP,WRTBUF	;ADVANCE BUFFERS
	PUSHJ	PP,WRTABP	;ADJUST BYTE-POINTER
	;MOVE RECORD TO THE BUFFER, OUTPUT IF NECESSARY.
WRTREC:	TLNN	FLG,CONNEC	;SKIP IF CONVERSION IS NECESSARY
	JUMPGE	FLG,WRTRB	;NOT-ASCII, GO BLT RECORD
	PUSHJ	PP,WRTXCT	;SETUP AC10
	TLNN	AC16,WRITE	;SKIP IF WRITE.
	PUSHJ	PP,WRTADV	;SEE IF NOW IS THE TIME TO ADVANCE
	JUMPE	AC3,WRTZRE	;TRYING TO WRITE A NULL REC?
WRTRE1:	ILDB	C,AC6		;CHAR FROM THE RECORD AREA
	XCT	AC10		;CONVERT IF NECESSARY
	IDPB	C,D.OBB(I16)	;CHAR TO THE BUFFER
	SOSG	D.OBC(I16)		;SKIP IF YOU CAN
	PUSHJ	PP,WRTBUF	;BUFFER FULL, WRITE IT OUT
	SOJG	AC3,WRTRE1	;LOOP TILL A COMPLETE RECORD IS PASSED
	JUMPGE	FLG,WRTRE4	;JUMP IF NOT ASCII
	SKIPN	NOCR.		;CR WANTED?
	PUSHJ	PP,WRTCR	;YES
WRTRE2:	JUMPL	AC16,WRTRE3	;JUMP IF "WRITE ADVANCING"
	PUSHJ	PP,WRTLF	;WRITE ASCII REC LF
	JRST	WRTRE6		;
WRTRE3:	PUSHJ	PP,WRTADV	;WADV.
	JRST	WRTRE6		;

	;ZERO FILL THE LAST PARTIAL WORD IF NECESSARY
WRTRE4:	SKIPN	AC2,D.OBC(I16)	;SKIP IF BUFFER IS NOT FULL
	JRST	WRTRE6		;JUMP FULL
WRTRE5:	MOVE	AC1,D.OBB(I16)	;OUTPUT BYTE POINTER
	TLNN	AC1,760000	;SKIP IF ZERO FILL IS NECESSARY
	JRST	WRTRE7		;
	IBP	D.OBB(I16)	;FILL IN A ZERO
	SOSLE	D.OBC(I16)		;ADJ THE BYTE COUNT
	JRST	WRTRE5		;LOOP
WRTRE6:	SKIPG	D.OBC(I16)		;BUFFER FULL?
	PUSHJ	PP,WRTBUF	;YES

	;STANDARD EXIT FOR READ AND WRITE.  ***POPJ***
	;MAY GENERATE A CLOSE UUO IF A MTA "EOT" AND A MULTI REEL FILE.

WRTRE7:	AOS	D.RP(I16)		;BUMP THE RECORD COUNT
	LDB	AC2,FTBF.	;BLOCKING-FACTOR
	JUMPE	AC2,WRTR10	;DON'T PAD IF BLK-FTR IS ZERO
	TLNN	FLG,OPNIO+RANFIL ;SKIP IF AN IO/RANDOM FILE
	SOSE	D.RCL(I16)	;DECREMENT THE RECORD/LOGICAL-BLOCK COUNT
	JRST	WRTR10		;
	MOVEM	AC2,D.RCL(I16)	;RECORDS/LOGIC BLOCK
	SETZM	D.IBC(I16)		;BE SURE THE NEXT READ GETS NEXT BUFFER
	SKIPLE	AC2,D.BCL(I16)	;BUFFERS/LOGICAL BLOCK
WRTRE9:	SOJGE	AC2,WRTR14	;PASS A BUFFER AND RETURN HERE
	MOVE	AC2,D.BPL(I16)	;RESTORE
	MOVEM	AC2,D.BCL(I16)	;    BUFFERS PER LOGICAL BLOCK
WRTR10:	SOSG	D.RRD(I16)		;SKIP IF IT'S NOT RERUN DUMP TIME
	TLNN	FLG,RRUNRC	;SKIP IF WE ARE RERUNNING
	JRST	WRTR15		;
	HRRZ	AC2,7(I16)	;RESTORE NUMBER OF RECORDS
	MOVEM	AC2,D.RRD(I16)	;    TO A RERUN DUMP
	JRST	WRTR16		;
WRTR15:	SKIPL	REDMP.		;SKIP IF A FORCED DUMP
	JRST	WRTR11		;NEITHER
WRTR16:	PUSHJ	PP,RRDMP	;DUMP
	PUSHJ	PP,RSAREN	;RESTORE .JBSA, .JBREN
WRTR11:	TLNN	AC16,READ	;SKIP IF READ
	AOS	(PP)		;
	TLNN	AC16,MTAEOT	;SKIP IF "EOT"
	POPJ	PP,		;EXIT TO THE ***"ACP"***

	HRLI	AC16,1440	;CLOSE REEL WITH REWIND
	SKIPA	AC1,FILES.	;THE FIRST FILE-TABLE
WRTR12:	HRRZ	AC1,6(AC1)	;NEXT FILE-TABLE ADR
	JUMPE	AC1,CLOSE.	;NO MORE, EXIT TO THE ***ACP***
	CAIN	AC1,(AC16)	;IS IT THE CURRENT FILE-TABLE?
	JRST	WRTR12		;YES, LOOP
	HRRZ	AC2,10(AC1)	;RECORD-AREA ADR
	CAIE	AC2,(FLG)	;SKIP IF "SAME RECORD-AREA"
	JRST	WRTR12		;ELSE LOOP

	;SAVE THE SHARED RECORD-AREA WHILE CHANGING REELS
	HLR	AC1,11(I16)	;NONSTD LABEL SIZE IN CHARS
	MOVEI	AC2,5		;ASSUME ASCII
	TLNN	FLG,CDMASC	;SKIP IF ASCII
	MOVEI	AC2,6		;SIXBIT CHAR/WORD
	IDIV	AC1,AC2		;CONVERT TO WORDS/LABEL
	SKIPN	AC1+1		;
	SUBI	AC1,1		;ROUND DOWN
	HLLZ	FLG1,D.F1(I16)	;FLAGS
	TLNN	FLG1,NONSTD	;SKIP IF NONSTD LABELS
	MOVEI	AC1,15		;STD LABEL SIZE IN WORDS (-1)
	MOVE	AC2,.JBREL	;
	SUB	AC2,.JBFF	;
	CAMLE	AC1,AC2		;WILL IT FIT IN CORE?
	PUSHJ	PP,GETCOR	;NO
	HRR	AC2,.JBFF	;"TO" ADR
	HRL	AC2,FLG		;"FROM,,TO" ADRS
	PUSH	PP,AC1		;SAVE LENGHT
	PUSH	PP,AC2		;SAVE "FROM,,TO"
	ADDB	AC1,.JBFF	;"UNTIL" AND UPDATE .JBFF
	BLT	AC2,(AC1)	;SLURP!
WRTR13:	HRLI	AC16,1442	;CLOSE REEL WITH REWIND AND SLURP FLAG SET
	JRST	CLOSE.		;DOIT!
	;PAD THE LOGICAL BLOCK IF NECESSARY.
WRTR14:	TLNN	AC16,READ	;SKIP IF READ
	JRST	WRTR17		;A WRITE
	PUSHJ	PP,READBF	;INPUT A BUF AND SKIP EXIT
	SETZM	D.IBC(I16)	;REMEMBER THAT IT'S EMPTY
	SKIPA
WRTR17:	PUSHJ	PP,WRTBUF	;OUTPUT A BUF
	TLZE	FLG,ATEND	;EOF?
	JRST	WRTR10		;GIVE HIM THE REC AND LET NXT READ GET EOF
	JRST	WRTRE9		;RETURN

	;WRITE OUT A BINARY RECORD

WRTR20:	SKIPG	D.OBC(I16)		;IF BUFFER IS FULL,
	PUSHJ	PP,WRTBUF	;  WRITE IT OUT
	MOVE	AC11,AC3	;GET RECORD SIZE IN BYTES
	MOVEI	AC12,6		;ASSUME RECORD IS SIXBIT
	TLNE	FLG,CDMASC	;IS IT ACTUALLY ASCII?
	MOVEI	AC12,5		;YES--5 BYTES PER WORD
	ADDI	AC11,-1(AC12)	;CONVERT SIZE TO WORDS AND
	IDIVI	AC11,(AC12)	;  ROUND UP

	HRL	AC5,FLG		;MOVING FROM RECORD AREA
WRTR21:	HRR	AC5,D.OBB(I16)	;MOVING TO BUFFER
	ADDI	AC5,1		;  PLUS ONE WORD
	MOVE	AC4,AC11	;IF NOT
	CAMLE	AC4,D.OBC(I16)	;  ENOUGH WORDS IN BUFFER,
	MOVE	AC4,D.OBC(I16)	;  WE WILL DO A PARTIAL MOVE NOW
	ADDM	AC4,D.OBB(I16)	;BUMP BUFFER WORD ADDRESS
	MOVN	AC12,AC4	;DECREMENT
	ADDM	AC12,D.OBC(I16)	;  BUFFER COUNT
	ADD	AC11,AC12	;  AND NUMBER RECORDS WORDS LEFT
	MOVS	AC12,AC5	;REMEMBER NEXT 'FROM',
	ADD	AC12,AC4	;  IT MAY BE NEEDED

	ADDI	AC4,(AC5)	;COMPUTE FINAL DESTINATION ADDRESS, PLUS 1
	BLT	AC5,-1(AC4)	;BLAT!!

	JUMPLE	AC11,WRTR22	;IF NO MORE TO DO, QUIT
	MOVSI	AC5,(AC12)	;NEW 'FROM' ADDRESS
	PUSHJ	PP,WRTBUF	;WRITE OUT THE BUFFER
	JRST	WRTR21		;LOOP FOR NEXT PIECE OF RECORD

WRTR22:	SKIPG	D.OBC(I16)		;IF BUFFER FULL,
	PUSHJ	PP,WRTBUF	;  WRITE IT
	JRST	WRTRE7		;GO HOME
IFN EBCDIC,<	;WRITE OUT AN EBCDIC RECORD

WEBC00:	MOVE	AC10,[MOVS C,EBCTAB(C)]  ;ASCII TO EBCDIC
	TLNE	FLG,CDMSIX	;SKIP IF NOT SIXBIT
	ADDI	AC10,40		;6BIT TO EBCDIC (EBCTAB+40)
	MOVE	AC1,D.OBH(I16)	;GET BUFFER LOCATION
	MOVE	AC0,2(AC1)	;GET BLOCK HEADER WORD
	SKIPE	AC0		;IS THERE A HEADER WORD?
	JRST	WEBC02		;YES
WEBC01:	AOS	D.OBB(I16)	;CREATE THE BLOCK HEADER WORD
	MOVN	AC0,D.BPW(I16)	;  UPDATE BYTE-POINTER
	ADDM	AC0,D.OBC(I16)	;  AND BYTE-COUNT
	HLLZ	AC0,12(I16)	;GET BLOCK SIZE
	LSH	AC0,2		;  TO LEFT TWO BYTE POSITIONS
	MOVEM	AC0,2(AC1)	;  OF FIRST BUFFER WORD
WEBC02:	HRRZ	AC0,D.FBB(I16)	;# OF FREE BUFFER BYTES
	ADDI	AC3,4		;HEADER WORD = 4 BYTES
	SUB	AC0,AC3		;IF RECORD WONT FIT
	JUMPL	AC0,WEBCBF	;  WRITE OUT THE BUFFER
	HRRM	AC0,D.FBB(I16)	;
	LSH	AC3,24		;INSERT RECORD HEADER WORD
	MOVE	AC0,[POINT 8,3]	;  IN
	MOVE	AC1,D.OBB(I16)	;OUTPUT BUFFER BYTE-POINTER
	MOVE	AC4,D.OBC(I16)	;BYTE-COUNT
	MOVEI	AC2,4		;  THE
WEBC04:	ILDB	C,AC0		;  BUFFER
	IDPB	C,AC1		;  .
	SOJLE	AC4,WEBC90	;  .
	SOJG	AC2,WEBC04	;DONE.
	LDB	AC3,WOPRS.	;RECORD SIZE
WEBC06:	SOJLE	AC4,WEBC90	;ERROR EXIT IF BUFFER IS FULL
	ILDB	C,AC6		;GET CHAR
	XCT	AC10		;CONVERT IT
	IDPB	C,AC1		;
	SOJG	AC3,WEBC06	;LOOP
	MOVEM	AC1,D.OBB(I16)	;UPDATE BUFFER HEADER
	MOVEM	AC4,D.OBC(I16)	;  AND BYTE-COUNT
	JUMPN	AC4,WRTRE7	;EXIT IF BUFFER IS NOT FULL
	HLRZ	AC0,12(I16)	;BLOCK HEADER WORD
	HRRM	AC0,D.FBB(I16)	;# OF FREE BUFFER BYTES LEFT
	PUSHJ	PP,WRTBUF	;DUMP THE BUFFER
	JRST	WRTRE7		;EXIT

	;WRITE OUT THE BUFFER
WEBCBF:	HLRZ	AC0,12(I16)	;BLOCK SIZE
	HRRM	AC0,D.FBB(I16)	;# OF FREE BUFFER BYTES
	PUSHJ	PP,WRTBUF	;
	JRST	WEBC01		;

	;ERROR NO MORE ROOM IN BUFFER
WEBC90:	TTCALL	3,[ASCIZ /INSUFFICIENT ROOM IN BUFFER FOR CURRENT RECORD /]
	MOVE	AC2,[BYTE (5)10,31,20,22,4]
	PUSHJ	PP,MSOUT.	;KILL
>
	;WRITE AND READ SETUP.  ***POPJ***

WRTSUP:	MOVE	AC13,D.DC(I16)	;DEVICE CHARACTERISTICS
	MOVE	FLG,10(I16)	;FLAGS,,RECORD LOCATION
	PUSHJ	PP,SETCN.	;SET THE IO CHANNEL NUMBER
	HRRZ	AC6,FLG		;SET UP RECORD BYTE POINTER
	LDB	AC3,FTMRS.	;FILE TABLE MAX REC SIZE
	TLNE	FLG,CDMASC	;
	TLOA	AC6,(POINT 7,)	;ASCII
	HRLI	AC6,(POINT 6,)	;SIXBIT
	POPJ	PP,		;


	;SETUP THE CONVERSION INST IN AC10 

WRTXCT:	JUMPL	FLG,WRTXC1		;JUMP IF ASCII DEV
	SKIPA	AC10,[MOVS C,CHTAB(C)]	;ASCII TO SIXBIT
WRTXC1:	MOVE	AC10,[ADDI C,40]	;SIXBIT TO ASCII
	TLNN	FLG,CONNEC		;
	HRLZI	AC10,(JFCL)		;ASCII TO ASCII
	POPJ	PP,			;
	;ADVANCING IS DONE HERE.  ***POPJ***

WRTADV:	TLCE	AC15,20		;WRTADV	OPERAND
	POPJ	PP,		;DON'T ADV THIS TIME
	HRRZ	AC4,AC15	;
	TLNE	AC15,40		;
	MOVE	AC4,(AC15)	;CHARACTER COUNT
	JUMPE	AC4,WRTAD1	;
	LDB	C,WOPCN		;
	SKIPA	AC2,WRTACP	;ADVANCE CHAR POINTER
	IBP	AC2		;
	SOJGE	C,.-1		;
	LDB	C,AC2		;C HAS THE CHARACTER
	TLNE	FLG,RANFIL+OPNIO;SKIP IF NOT A RANDOM FILE
	JRST	WRTAD2		;
	PUSHJ	PP,WRTCH	;
	SOJG	AC4,.-1		;
WRTAD1:	POPJ	PP,		;
WRTAD2:	IDPB	C,AC5		;AC5 BYTE-PTR. TO RANDOM BUFFER AREA
	SOJG	AC4,.-1		;
	POPJ	PP,		;

WRTLF:	SKIPA	C,[ 12 ]	;"LF"
WRTCR:	MOVEI	C,15		;"CR"
WRTCH:	IDPB	C,D.OBB(I16)	;TO THE BUFFER
	SOSLE	D.OBC(I16)		;SKIP IF FULL
	POPJ	PP,		;OR RETURN
WRTBUF:	PUSHJ	PP,WRTOUT
	SOS	D.BCL(I16)	;BUFFER PER LOGICAL BLOCK
	POPJ	PP,

	;SEE IF ZERO LEN RECORD IS LEGAL
WRTZRE:	SKIPE	NOCR.		;
	JRST	WRTRE2		;A WAY TO GET ONLY PAPER-ADVANCING-CHARS
	TTCALL	3,[ASCIZ /ZERO LENGTH RECORDS ARE ILLEGAL
/]
	MOVE	AC2,[BYTE (5)10,31,20,22,4]
	JRST	KILL.
	;BLT RECORD AREA TO THE BUFFER/S

WRTRB:	HRLZ	AC5,FLG		;RECORD AREA I.E. "FROM"
WRTRB1:	MOVE	AC11,AC3	;SETUP FOR THE "UNTIL"
	SUB	AC3,D.OBC(I16)	;REC-SIZE MINUS BYTE-COUNT
	JUMPGE	AC3,WRTRB2	;JUMP, USE ALL OF CURRENT BUFFER
	MOVN	AC3,AC11	;SO WE CAN ADJ THE BYTE-COUNT
	JRST	WRTRB3		;PROCEED
WRTRB2:	MOVE	AC11,D.OBC(I16)	;BYTE-COUNT
	SETZM	D.OBC(I16)		;ZERO THE BYTE COUNT
WRTRB3:	IDIVI	AC11,6		;CONVERT TO WORDS
	MOVE	AC2,AC12	;SAVE FOR ZERO FILL
	JUMPE	AC12,WRTRB4	;CHECK THE REMAINDER
	ADDI	AC11,1		;ADJ IF THERE WAS ONE
	SUBI	AC12,6		;NEGATE TRAILING NULL BYTES
WRTRB4:	SKIPE	D.OBC(I16)		;SKIP IF BUFFER IS FULL
	ADD	AC12,AC3	;ADD IN THE REC-SIZE
	ADDM	AC12,D.OBC(I16)	;SUBTRACT FROM THE BYTE-COUNT
	HRR	AC5,D.OBB(I16)	;"TO" ADDRESS
	HRRZ	AC4,AC5		;
	ADDI	AC4,-1(AC11)	;"UNTIL" ADDRESS
	HLRZ	AC12,AC5	;SAVE ORIGIN
	ADDM	AC12,AC11	;NEXT ORIGIN
	BLT	AC5,(AC4)	;SHAZAM!
	HRL	AC5,AC11	;NEXT "FROM" ADR
	HRLI	AC4,600		;NO MORE BYTES THIS WORD
	MOVEM	AC4,D.OBB(I16)	;
	SKIPLE	D.OBC(I16)		;XIT IF U CAN
	JRST	WRTRB5		;EXIT
	PUSHJ	PP,WRTBUF	;ADVANCE TO NEXT BUFFER
	PUSHJ	PP,WRTABP	;ADJ THE BYTE-PTR
	JUMPG	AC3,WRTRB1	;LOOP TILL ALL IS BLT'ED
WRTRB5:	JUMPE	AC2,WRTRE7	;EXIT IF NO NO FILL REQUIRED
	IMULI	AC2,-6		;ZERO FILL THE LAST WORD
	SETO	AC0,		;--
	LSH	AC0,(AC2)	;--
	ANDCAM	AC0,(AC4)	;DOIT
	JRST	WRTRE7		;EXIT
	;ADJUST THE BYTE-POINTER TO POINT TO NON-EX BYTE LEFT OF NEXT WORD

WRTABP:	SKIPGE	AC1,D.OBB(I16)	;
	POPJ	PP,		;
	HRLI	AC1,440600	;
IFN EBCDIC,<
	TLNE	FLG,DDMEBC	;EBCDIC?
	HRLI	AC1,441000	;
>
	ADDI	AC1,1		;
	MOVEM	AC1,D.OBB(I16)	;
	POPJ	PP,		;

ERROPN:	MOVE	AC2,[BYTE (5)10,31,20,6,14]
	PUSHJ	PP,MSOUT.	;"FILE IS NOT OPEN"
	HRLZI	AC2,(BYTE (5)11)	;"FOR OUTPUT
	TLNN	AC16,WADV!WRITE	;SKIP IF ATTEMPT TO WRITE
	HRLZI	AC2,(BYTE (5)7)	;"FOR INPUT"
	PUSHJ	PP,MSOUT.

				;IF BITS 18-23 ARE NON-ZERO THIS
ERRMR0:	TRNE	AC4,770000	;  COULD BE AN ASCII FILE
	TTCALL	3,[ASCIZ/NOT A LEGAL SIXBIT FILE... ASCII?/]
ERRMR1:	SKIPA	AC2,[BYTE (5)10,31,20,21,4,14]
ERRMRS:	MOVE	AC2,[BYTE (5)10,31,20,22,4,14]
	PUSHJ	PP,MSOUT.	;CANNOT DO OUTPUT
	TTCALL	3,[ASCIZ /THE MAXIMUM RECORD SIZE MAY NOT BE EXCEEDED/]
	JRST	KILL.

SUBTTL	READ-UUO

	;A READ UUO LOOKS LIKE:
	;002100,,ADR	WHERE ADR = FILE TABLE ADDRESS
	;CALL+1:	NORMAL RETURN
	;CALL+2:	"AT-END" OR "INVALID-KEY" RETURN

READ.:	TLO	AC16,READ	;READ UUO
	PUSHJ	PP,WRTSUP	;SETUP
	TLNN	FLG,NOTPRS	;SKIP IF OPTIONAL AND NOT PRESENT
	JRST	READ1		;
	TLOE	FLG,ATEND	;SET "AT END" PATH TAKEN
	JRST	REAAEE		;FATAL THE SECOND TIME
	MOVEM	FLG,10(I16)	;SAVE FLG
	JRST	RET.2		;SKIP EXIT
READ1:	TLNN	FLG,OPNIN	;SKIP IF OPEN FOR INPUT
	PUSHJ	PP,ERROPN	;
	TLNE	FLG,ATEND	;SKIP IF NOT "AT END"
	JRST	REAAEE		;"FILENM IS AT END" STOPR.
IFN ISAM,<
	TLNE	FLG,IDXFIL	;INDEX FILE?
	JRST	IREAD		;YES
>
	TLNE	FLG,RANFIL+OPNIO ;SKIP IF NOT RANDOM OR I/O
	JRST	RANDOM		;RANDOM AND IO EXIT HERE
IFN EBCDIC,<
	TLNE	FLG,DDMEBC	;EBCDIC?
	JRST	REBC00		;  USE EBCDIC ROUTINE
>
	PUSHJ	PP,REAXCT	;SETUP AC10
	JUMPL	FLG,READ4	;JUMP IT'S ASCII

	TLNE	FLG,DDMBIN	;IF BINARY,
	JRST	READ10		;  USE THIS ROUTINE
	;PICKUP REC-SIZE (FIRST WORD) AND CHECK AGAINST MAX-REC-SIZE.

	MOVE	AC4,D.IBC(I16)	;INPUT BYTE COUNT
	CAILE	AC4,1		;SKIP IF THE BUFFER IS EMPTY
	JRST	READ3		;
READ2:	PUSHJ	PP,READBF	;  FILL IT.
	TLNE	FLG,CONNEC	;SKIP IF WE'RE BLT'ING THE RECORD
	AOS	D.IBC(I16)		;SO THE  BYTE COUNT WILL BE RIGHT
READ21:	LDB	AC3,FTMRS.	;RESTORE AC3
	TLNE	FLG,ATEND	;CHECK FOR END-OF-FILE
	JRST	READEF		;TAKE A SKIP EXIT TO THE "ACP"
READ3:	PUSHJ	PP,REAABP	;ADJUST THE BYTE-POINTER
	AOS	D.IBB(I16)		;DONT OVERWRITE REC-SIZE
	TLNN	AC13,20		;MTA?
	JRST	READ31		;NO
	HLRZ	AC4,(AC1)	;GET RECORD SEQUENCE NUMBER
	JUMPE	AC4,READ31	;JUMP IF NO RSN
	HRRZ	AC0,D.RP(I16)	;GET RECORD COUNT
	CAME	AC4,AC0		;OK?
	JRST	REALR		;NO - LOST OR GAINED A RECORD
READ31:	HRRZ	AC4,(AC1)	;INCASE ITSA ASCII DATA WRD & NOT 6BIT CHR-CNT
	CAMGE	AC3,AC4		;SKIP IF MAX RECORD SIZE IS NOT EXCEEDED
	JRST	ERRMR0		;ERROR MESSAGE
	HRRZ	AC3,(AC1)	;MOVE IT INTO AC3
	;ANDI	AC3,7777	;
	MOVN	AC4,D.BPW(I16)	;CPW
	ADDB	AC4,D.IBC(I16)	;SUB FROM THE BYTE COUNT
	JUMPE	AC3,READ32	;ZERO LENGTH RECORD
	TLNE	FLG,CONNEC	;SKIP IF CONVERSION IS NOT NECESSARY
	JRST	READ4		;OAKAY
	JUMPN	AC4,REABR	;GO BLT
	PUSHJ	PP,READBF	;ADVANCE THE BUFFER FIRST
	PUSHJ	PP,REAABP	;ADJ THE BYTE-PTR
	TLNN	FLG,ATEND	;CHECK FOR EOF
	JRST	REABR		;THEN GO BLT
	JRST	REAAE1		;ERROR MESSAGE

	;HERE TO READ AHEAD TO FIND NEXT NON-0-LENGTH RECORD
	;IF NOT FOUND TAKE THE ATEND PATH

READ32:	LDB	AC4,FTBF.	;SKIP THE FOLLOWING TEST IF
	JUMPE	AC4,READ34	;  BLOCKING-FACTOR IS ZERO
	SOSE	D.RCL(I16)	;  OR IF THERE ARE MORE RECORDS IN
	JRST	READ34		;  THIS LOGICAL-BLOCK
	MOVEM	AC4,D.RCL(I16)	;RESTORE # OF RECORDS IN CURRENT LOGICAL-BLOCK
	SKIPLE	AC4,D.BCL(I16)	;IGNORE ANY TRAILING BUFFERS IN THIS
READ33:	PUSHJ	PP,READBF	;  LOGICAL-BLOCK
	SETZM	D.IBC(I16)	;DECLARE HIS BUFFER EMPTY
	TLZN	FLG,ATEND	;LET THE NEXT RECORD GET THE "EOF"
	SOJG	AC4,READ33	;PASS ALL OF THIS LOGICAL-BLOCK
	MOVE	AC4,D.BPL(I16)	;RESTORE THE POINTERS
	MOVEM	AC4,D.BCL(I16)	;  BUFFERS PER CURRENT LOGICAL-BLOCK

READ34:	MOVE	AC4,D.IBC(I16)	;IF THE
	CAILE	AC4,1		;  BUFFER
	JRST	READ35		;  IS EMPTY
	PUSHJ	PP,READBF	;  FILL IT.
	TLNE	FLG,CONNEC	;MAKE THE BYTE-COUNT RIGHT IF
	AOS	D.IBC(I16)	;  RECORD IS TO BE BLT'ED
	TLNE	FLG,ATEND	;EOF MEANS TAKE
	JRST	READEF		;  ATEND PATH
READ35:	PUSHJ	PP,REAABP	;ADJUST THE BYTE-POINTER
	HRRZ	AC3,(AC1)	;GET THE RECORD SIZE
	JUMPN	AC3,READ21	;EXIT HERE IF N0N-0-LENGTH RECORD
	AOS	D.IBB(I16)	;ACCOUNT FOR THE
	MOVN	AC4,D.BPW(I16)	;  HEADER
	ADDM	AC4,D.IBC(I16)	;  WORD
	JRST	READ32		;LOOP TIL EOF OR N0N-0-LENGTH RECORD
	;PASS LEADING "EOL" CHARACTERS.
READ4:	PUSHJ	PP,READCH	;GET CHAR
	TLNE	FLG,ATEND	;SKIP IF NOT "EOF"
	JRST	READEF		;"AT-END" BUT DONT INC REC COUNT
	XCT	AC10		;CONVERT IF NECESSARY
	JUMPL	C,READ4		;JUMP IF EOL CHAR
	MOVE	AC5,AC3		;SAVE ACTUAL RECORD SIZE FOR ZERO FILL

	;LOAD THE RECORD AREA FROM THE BUFFER.

READ5:	IDPB	C,AC6		;
	SOJE	AC3,READ51	;DECREMENT REC SIZE
	PUSHJ	PP,READCH	;
	TLNE	FLG,ATEND	;SKIP IF NOT "EOF"
	JRST	REAAE1		;MESS AND KILL
	XCT	AC10		;CONVERT IF NECESSARY
	JUMPGE	C,READ5		;JUMP IF NON EOL CHAR
READ52:	MOVEI	C,40		;ASCII SPACE
	TLNN	FLG,CDMASC	;
	SETZ	C,		;SIXBIT SPACE
	IDPB	C,AC6		;TRAILING SPACES
	SOJG	AC3,.-1		;FILL OUT THE RECORD WITH SPACES
	JRST	READ6
READ51:	LDB	AC3,FTMRS.	;GET MAX RECORD SIZE
	SUB	AC3,AC5		;NUMBER OF ZEROS TO FILL
	JUMPG	AC3,READ52	;DOIT

	;RECORD IS FULL.  PASS CHAR TILL AN "EOL" CHAR IS ENCOUNTERED.

READ6:	JUMPGE	FLG,READ8	;JUMP SIXBIT HAS NO "EOL"
READ7:	PUSHJ	PP,READCH	;
	XCT	AC10		;CONVERT IF NECESSARY
	TLZN	FLG,ATEND	;
	JUMPGE	C,READ7		;JUMP IF NON-EOL CHAR
READ8:	PUSHJ	PP,WRTRE7	;UPDATE DEVTAB, RERUN DUMP, ETC
	JFCL			;
	MOVEM	FLG,10(I16)	;
	POPJ	PP,		;EXIT TO THE ***"ACP"***
	;READ A BINARY RECORD

READ10:	SKIPLE	AC4,D.IBC(I16)	;IF BUFFER NOT EMPTY
	JRST	READ11		;  DON'T NEED ANOTHER
	PUSHJ	PP,READBF	;GET ANOTHER BUFFER FULL
	TLNE	FLG,ATEND	;IF NO MORE,
	JRST	READEF		;  WE ARE AT END

READ11:	LDB	AC11,FTMRS.	;GET RECORD SIZE IN BYTES
	MOVEI	AC12,6		;ASSUME DATA RECORD IS SIXBIT
	TLNE	FLG,CDMASC	;IS IT ACTUALLY ASCII?
	MOVEI	AC12,5		;YES--5 BYTES PER WORD
	ADDI	AC11,-1(AC12)	;CONVERT TO
	IDIVI	AC11,(AC12)	;  WORDS AND ROUND UP

	HRR	AC5,FLG		;DESTINATION IS RECORD AREA
READ12:	MOVE	AC4,D.IBB(I16)	;MOVING FROM BUFFER WORD
	HRLI	AC5,1(AC4)	;  PLUS 1
	MOVE	AC4,AC11	;IF SIZE IS
	CAMLE	AC4,D.IBC(I16)	;  MORE THAN THAT LEFT IN BUFFER,
	MOVE	AC4,D.IBC(I16)	;  USE ALL WORDS IN BUFFER
	ADDM	AC4,D.IBB(I16)	;BUMP BUFFER WORD ADDRESS
	MOVN	AC12,AC4	;DECREMENT
	ADDM	AC12,D.IBC(I16)	;  BUFFER COUNT
	ADD	AC11,AC12	;  AND WORDS LEFT IN RECORD

	ADDI	AC4,(AC5)	;COMPUTE FINAL DESTINATION PLUS 1
	BLT	AC5,-1(AC4)	;BLAT!!

	JUMPLE	AC11,READ8	;IF ENTIRE RECORD MOVED, WE'RE DONE
	MOVEI	AC5,(AC4)	;NEW DESTINATION ADDRESS
	PUSHJ	PP,READBF	;GET ANOTHER BUFFER FULL
	TLZN	FLG,ATEND	;IF NOT AT END,
	JRST	READ12		;  LOOP

	SETZM	D.IBC(I16)		;FORCE READ NEXT TIME
READ13:	SETZM	(AC5)		;FILL
	SOJLE	AC11,READ8	;  REST OF RECORD
	AOJA	AC5,READ13	;  WITH ZEROES
IFN EBCDIC,<	;READ A EBCDIC RECORD

REBC00:	MOVE	AC10,[MOVE C,EBCTAB(C)]	;EBCDIC TO ASCII
	TLNE	FLG,CDMSIX	;SIXBIT?
	MOVE	AC10,[LDB C,[POINT 6,EBCTAB(C),26]]	;EBCDIC TO SIXBIT
	MOVE	AC1,D.IBB(I16)	;BYTE-POINTER
	SKIPLE	AC4,D.IBC(I16)	;IS BUFFER EMPTY?
	JRST	REBC01		;NO
	PUSHJ	PP,READBF	;YES - SO FILL IT
	TLNE	FLG,ATEND	;EOF?
	JRST	READEF		;EOF!
	MOVE	AC1,D.IBB(I16)	;BYTE-POINTER
	MOVE	AC4,D.IBC(I16)	;BYTE-COUNT
	PUSHJ	PP,REBCHW	;GET BLOCK HEADER WORD TO AC0
REBC01:	PUSHJ	PP,REBCHW	;GET RECORD HEADER WORD TO AC0
	SUBI	AC0,4		;-4 FOR RECORD HRD-WRD
	CAMGE	AC3,AC0		;SIZE GT MAXIMUM SIZE?
	JRST	ERRMR1		;YES ERROR

REBC02:	SOJL	AC4,REBCG1	;ERROR IF BUFFER EMPTY
	ILDB	C,AC1		;GET A CHAR
	XCT	AC10		;CONVERT IT
	IDPB	C,AC6		;TO THE RECORD AREA
	SOJG	AC0,REBC02	;LOOP

	MOVEM	AC1,D.IBB(I16)	;SAVE BYTE-POINTER
	MOVEM	AC4,D.IBC(I16)	;  AND BYTE-COUNT
	JRST	READ8		;EXIT

	;GET HEADER WORD CHARACTER COUNT TO AC0
REBCHW:	PUSHJ	PP,REBCGC	;GET CHAR
	MOVE	AC0,C		;SAVE IT
	PUSHJ	PP,REBCGC	;GET NEXT CHAR
	LSH	AC0,10		;MAKE ROOM
	IOR	AC0,C		;AC0 = CHAR COUNT
	PUSHJ	PP,REBCGC	;PASS OVER 2 CHARS
	JRST	REBCGC		;   AND EXIT

	;RETURN A CHARACTER IN C
REBCGC:	SOJL	AC4,REBCG1
	ILDB	C,AC1
	POPJ	PP,

REBCG1:	TTCALL	3,[ASCIZ /DATA FORMAT ERROR/]	;BUFFER IS EMPTY - SHLDB MORE DATA
	MOVE	AC2,[BYTE (5)10,31,20,21,4]
	PUSHJ	PP,MSOUT.	;KILL
>
	;READ AN "EOF".  TAKE "AT-END" PATH.  ***POPJ***

READEF:	MOVEM	FLG,10(I16)	;SAVE THE FLAG REGISTER
	LDB	AC5,FTFP.	;FILE TABLE - FILE POSITION
	JUMPN	AC5,RET.2	;SKIP EXIT TO THE ***"ACP"***
	HLLZ	FLG1,D.F1(I16)	;FLAGS
	TLNE	AC13,20		;SKIP IF  NOT A MTA,ETC.
	TLNN	FLG1,STNDRD	;SKIP IF STANDARD LABELS
	JRST	RET.2		;SKIP EXIT TO THE ***"ACP"***
	PUSHJ	PP,CLSRL	;READ IN THE LABEL
	XCT	MBSPR.		;BACK OVER THE LABEL
	PUSHJ	PP,CLSEOV	;CHECK FOR "EOV"
	JRST	READE1		;OK
	JRST	RET.2		;SKIP EXIT TO ***ACP***
READE1:	HRLI	AC16,440	;CLOSE REEL UUO
	PUSHJ	PP,CLOSE.	;A READ GENERATED CLOSE UUO
	HRLI	AC16,2100	;READ UUO
	TLZ	FLG,ATEND	;TURN OFF THE EOF FLAG
	MOVEM	FLG,10(I16)	;   ALSO IN THE FILE TABLE
	JRST	READ.		;TRY AGAIN

	;READ A CHARACTER.  IGNORE ASCII NULLS.  ***POPJ***

READCH:	SOSG	D.IBC(I16)		;DECREMENT THE BYTE COUNT
	PUSHJ	PP,READBF	;INPUT IF YOU MUST
	TLNE	FLG,ATEND	;SKIP IF AT END  ("EOF") ;IS  THIS NECES???
	POPJ	PP,		;
	ILDB	C,D.IBB(I16)	;RETURN WITH A CHAR IN C
	SKIPN	C		;SKIP IF NOT A NULL CHAR
	JUMPL	FLG,READCH	;IGNORE IT IF IT IS A ASCII NULL
	POPJ	PP,		;

READBF:	PUSHJ	PP,READIN	;GET A BUFFER
	JFCL
	SOS	D.BCL(I16)	;DECREMENT BUF/LOGBU
	POPJ	PP,		;
	;BLT BUFFER/S TO THE RECORD AREA

REABR:	HRR	AC5,FLG		;RECORD AREA  I.E. "TO"
	MOVE	AC0,AC3		;SAVE ACTUAL RECORD SIZE
REABR1:	MOVE	AC11,AC3	;SETUP FOR THE "UNTIL"
	SUB	AC3,D.IBC(I16)	;REC-SIZE MINUS BYTE-COUNT
	JUMPGE	AC3,REABR2	;JUMP, USE ALL OF CURRENT BUFFER
	MOVN	AC3,AC11	;SO WE CAN ADJ THE BYTE-COUNT
	JRST	REABR3		;
REABR2:	MOVE	AC11,D.IBC(I16)	;BYTE-COUNT
	SETZM	D.IBC(I16)		;NOTE THE BUFFER IS EMPTY
REABR3:	IDIVI	AC11,6		;CONVERT TO WORDS
	JUMPE	AC12,REABR4	;CHECK THE REMAINDER
	ADDI	AC11,1		;ADJ WRDCNT IF THERE WAS ONE
	SUBI	AC12,6		;NEGATE TRAILING NULL BYTES
REABR4:	SKIPE	D.IBC(I16)		;SKIP IF THE BUFFER IS EMPTY
	ADD	AC12,AC3	;ADD IN THE REC-SIZE
	ADDM	AC12,D.IBC(I16)	;SUBTRACT FROM THE BYTE-COUNT
	HRL	AC5,D.IBB(I16)	;"FROM"
	HRRZ	AC4,AC5		;
	ADDI	AC4,-1(AC11)	;"UNTIL"
	BLT	AC5,(AC4)	;SLURP P P !!
	HRRI	AC5,1(AC4)	;NEW "TO"
	ADDM	AC11,D.IBB(I16)	;RESTORE THE BYTE-POINTER
	SKIPLE	D.IBC(I16)		;READ8 IF YOU CAN
	JRST	REABR5		;EXIT
	JUMPLE	AC3,REABR5	;EXIT IF ALL WAS BLT'ED
	PUSHJ	PP,READBF	;ADVANCE TO NEXT BUFFER
	PUSHJ	PP,REAABP	;ADJ BYTE-PTR
	TLNN	FLG,ATEND	;SKIP IF "EOF" WAS SEEN
	JRST	REABR1		;LOOP
REABR5:	ADDI	AC0,5		;ACTUAL SIZE
	LDB	AC2,FTMRS.	;MAX SIZE
	ADDI	AC2,5		;ROUND UP
	CAMN	AC0,AC2		;IF THE SAME
	JRST	READ8		;  EXIT
	IDIVI	AC0,6		;CONVERT TO
	IDIVI	AC2,6		;  WORDS
	SUB	AC2,AC0		;NUMBER OF WORDS TO ZERO FILL
	JUMPE	AC2,READ8	;EXIT IF NONE
REABR6:	SETZM	1(AC4)
	SOJLE	AC2,READ8
	AOJA	AC4,REABR6
REAAE1:	TTCALL	3,[ASCIZ/ENCOUNTERED AN "EOF" IN THE MIDDLE OF A RECORD/]
	SKIPA			;AT END ERROR
REAAEE:	TTCALL	3,[ASCIZ /"AT END" PATH HAS BEEN TAKEN/]
REAAE0:	MOVE	AC2,[BYTE (5)10,31,20,21]
	PUSHJ	PP,MSOUT.	;KILL

	;HERE IF RECORD SEQUENCE NUMBER FOUND IN LEFT SIDE OF MTA SIXBIT
	;HEADER-WORD IS NOT EQUAL TO RECORD COUNT IN FILE TABLE
	;NOTE. COUNT STARTS AT ZERO
REALR:	TTCALL	3,[ASCIZ /RECORD-SEQUENCE-NUMBER /]
	HRLO	AC12,AC4	;RSN
	PUSHJ	PP,PPOUT2	;TYPE IT
	TTCALL	3,[ASCIZ / SHOULD BE /]
	HRLO	AC12,D.RP(I16)	;RECORD COUNT
	PUSHJ	PP,PPOUT2	;TYPE IT
	JRST	REAAE0		;FINISH UP MESSAGE

	;ADJUST BYTE-POINTER TO NON-EX BYTE LEFT OF NEXT WORD

REAABP:	SKIPGE	AC1,D.IBB(I16)	;
	POPJ	PP,		;
	HRLI	AC1,440600	;
IFN EBCDIC,<
	TLNE	FLG,DDMEBC	;EBCDIC?
	HRLI	AC1,441000	;
>
	ADDI	AC1,1		;
	MOVEM	AC1,D.IBB(I16)	;
	POPJ	PP,		;

	;SETUP AC10 WITH CONVERSION INST.  ***POPJ***

REAXCT:	TLNE	FLG,DDMBIN	;IF BINARY,
	JRST	REAXC2		;  NO CONVERSION
	JUMPL	FLG,REAXC1	;JUMP IF DEV IS ASCII
	MOVE	AC10,[ADDI C,40]	;ASCII TO SIXBIT
	TLNE	FLG,CDMSIX		;SKIP IF CORE-DATA-MODE IS NOT SIXBIT
REAXC2:	MOVSI	AC10,(JFCL)		;6BIT T0 6BIT (LABELS)
	POPJ	PP,			;
REAXC1:	MOVE	AC10,[MOVE C,CHTAB(C)]	;ASCII TO ASCII
	TLNE	FLG,CDMSIX		;
	TLO	AC10,4000		;SIXBIT TO ASCII  (MOVE TO MOVS)
	POPJ	PP,
SUBTTL	RANDOM/IO-STUFF
	;RANDOM AND IO READ AND WRITE ENTER HERE FROM READ. OR WRITE.
	;	DUMP MODE POINTERS
	;(I12)+0	DUMP MODE IOWD
	;(I12)+1	TERMINATOR
	;(I12)+2	BYTE-POINTER TO NEXT RECORD
	;(I12)+3	BYTE-POINTER TO LAST RECORD
	;(I12)+4	BYTE POINTER TO FIRST RECORD
	;(I12)+5	NOT USED
	;(I12)+6	-1 IF ACTIVE DATA IN BUFFER
	;(I12)+7	-1 IF LAST UUO WAS A WRITE

	;CHECK THE FILE-LIMITS, READ IN THE LOGICAL BLOCK, AND
	;POINT AT THE RECORD.  ***WRTRE7***

RANDOM:	HLLZ	FLG1,D.F1(I16)	;GET APPEND FLAG
	HLRZ	I12,D.BL(I16)	;POINTER TO DUMP MODE POINTERS
	TLNN	FLG,RANFIL	;SKIP IF NOT SEQIO
	JRST	SEQIO		;
	PUSHJ	PP,FLIMIT	;CHECK ACTUAL KEY VS. FILE LIMITS
	JUMPE	AC4,SEQIO	;IF ACT-KEY = 0 HE WANTS SEQ READ
	LDB	AC2,FTBF.	;BLOCKING FACTOR
	SOSN	AC1,AC4		;ACTUAL KEY MINUS ONE
	TDZA	AC2,AC2		;
	IDIV	AC1,AC2		;
	IMUL	AC1,D.BPL(I16)	;BUFFER PER BLOCK
	ADDI	AC1,1		;PHYS. BLOCK NUMBER FOR USETI
	CAME	AC1,D.CBN(I16)	;SKIP IF RECORD IS IN CORE
	PUSHJ	PP,RANIN	;OTHERWISE GET IT
	SKIPA	AC5,4(I12)	;BYTE POINTER TO THE FIRST RECORD
	JRST	RANXIT		;EOF
	JUMPL	FLG,RANWRT	;JUMP IF ASCII
	TLNE	FLG,DDMBIN	;IF BINARY,
	JRST	RANDO7		;  GO TO SPECIAL ROUTINE

	LDB	AC0,FTBF.	;HOW MANY RECORDS ARE LEFT
	SUBI	AC0,1(AC2)	;  IN THIS LOGICAL BLOCK.
	MOVEM	AC0,D.RCL(I16)	;SAVE FOR RANSHF
	JUMPE	AC2,RANDO2	;JUMP IF WE'RE DONE
	LDB	AC0,FTMRS.	;MAX-REC-SIZ
RANDO1:	HRRZ	AC10,@AC5	;RECORD SIZE IN CHARS
	;ANDI	AC10,7777	;
	CAMGE	AC0,AC10	;IS CHAR-CNT TOO LARGE? ASCII FILE?
	JRST	RANDO2		;COMPLAIN
	IDIVI	AC10,6		;RECORD
	SKIPE	AC11		;SIZE
	ADDI	AC10,1		;IN
	ADDI	AC5,1(AC10)	;WORDS
	SOJG	AC2,RANDO1	;JUMP TILL NXTREC=CURREC
	MOVEM	AC5,2(I12)	;SAVE AS CURRENT RECORD
	;HERE TO CHECK THAT NEW RECORD SIZE LE THAN MAX
RANDO2:	HRRZ	AC2,@AC5	;RECORD SIZE IN CHARACTERS
	LDB	AC0,FTMRS.	;MAX RECORD SIZE
	CAMLE	AC2,AC0		;LE THAN MAX?
	PUSHJ	PP,ERRMR0	;NO - GO COMPLAIN
	JUMPN	AC2,RANWR0	;ONWARD IF NOT A ZERO LENGTH RECORD
	TLNN	AC16,READ	;READ?
	JRST	RANWR0		;WRITE!
	MOVE	AC1,12(I16)	;GET THE
	MOVE	AC1,(AC1)	;  ACTUAL KEY
	TLNE	FLG,RANFIL	;A RANDOM FILE?
	JUMPN	AC1,RANDO3	;YES  -  NEXT RECORD?
	MOVE	AC0,2(I12)	;YES - HERE TO GET NEXT NON-0-RECORD
	MOVEM	AC0,3(I12)	;  BUT FIRST UPDATE
	AOS	2(I12)		;  THE POINTERS
	AOJA	AC5,SEQIO6	;FIND THE NEXT ONE
RANDO3:	TLNN	FLG,RANFIL	;SEQIO?
	TLO	FLG,ATEND	;SET "EOF" FLAG
	AOS	D.RCL(I16)	;DONT COUNT "EOF" AS A RECORD
	MOVE	AC0,2(I12)	;UPDATE POINTERS IN CASE HE WANTS TO
	MOVEM	AC0,3(I12)	;  WRITE AFTER "EOF"
	JRST	RANXI3		;RETURN

;FILE IS BINARY.
;STEP DOWN TO CORRECT RECORD AND MOVE TO/FROM RECORD AREA.

RANDO7:	LDB	AC10,FTMRS.	;GET MAXIMUM RECORD SIZE
	MOVEI	AC11,6		;CONVERT
	TLNE	FLG,CDMASC	;  TO
	MOVEI	AC11,5		;  WORDS
	ADDI	AC10,-1(AC11)	;  *
	IDIVI	AC10,(AC11)	;  *
	MOVE	AC11,AC10	;SAVE IT

	IMULI	AC11,(AC2)	;MULTIPLY BY # RECORDS FROM TOP
	ADD	AC5,AC11	;ADD TO RECORD BYTE POINTER
	MOVEM	AC5,2(I12)	;SAVE AS CURRENT RECORD

	HRL	AC5,FLG		;GET RECORD ADDRESS
	TLNN	AC16,READ	;IS IT READ?
	JRST	RANDO9		;NO
	MOVSS	AC5		;YES--MOVING TO RECORD
	SETZM	7(I12)		;REMEMBER IT WAS A READ
	JRST	RAND10
RANDO9:	SETOM	6(I12)		;FORCE WRITE LATER
	SETOM	7(I12)		;REMEMBER IT WAS A WRITE
RAND10:	ADDI	AC10,(AC5)	;FINAL DESTINATION PLUS 1
	BLT	AC5,-1(AC10)	;BLAT!!
	JRST	RANXIT
	;SEQUENTIAL IO READ AND WRITE ARE PROCESSED HERE

SEQIO:	SKIPE	3(I12)		;SKIP IF FIRST INPUT
	JRST	SEQIO4		;ITS NOT
	MOVE	AC5,4(I12)	;FIRST RECORD
	MOVEM	AC5,3(I12)	;LAST RECORD
	MOVEI	AC1,1		;FIRST BLOCK
	JRST	SEQIO3		;READ IT IN
SEQIO4:	SKIPN	7(I12)		;SKIP IF WRITE WAS LAST
	TLNN	AC16,WRITE+WADV ;SKIP IF WRITE AFTER READ
SEQIO6:	SKIPA	AC1,D.RCL(I16)	;NUMBER OF REC TO FILL CURRENT LOGBLK
	JRST	SEQIO1		;
	JUMPN	AC1,SEQIO2	;JUMP IF RECORD IS IN CORE
SEQIO5:	HRRZ	AC1,D.BPL(I16)	;BUFFERS PER LOGBLK
	ADD	AC1,D.CBN(I16)	;USETI OPERAND (CURRENT PHYS BLOCK)
SEQIO3:	PUSHJ	PP,RANIN	;WRITE LAST BLOCK IF NECESSARY,THEN INPUT
	JRST	SEQIO2		;NOW THE RECORD IS IN CORE
	TLNN	AC16,READ	;SKIP IF NOT WRITE AFTER EOF
	JRST	SEQIO2		;WRITE
	MOVE	AC0,4(I12)	;BP TO FIRST REC
	MOVEM	AC0,3(I12)	; = BP TO LAST REC
	JRST	RANXI3

SEQIO1:	MOVE	AC5,3(I12)	;BP TO LAST RECORD
	MOVEM	AC5,2(I12)	;BP TO NEXT RECORD
	JRST	SEQIO7		;
SEQIO2:	TLNE	FLG,ATEND	;APPENDING?
	MOVEM	AC3,@2(I12)	;GIVE A REC-CNT
	SOS	D.RCL(I16)	;DECREMENT REC/LOGBLK COUNT
	MOVE	AC5,2(I12)	;CURRENT/NEXT RECORD
SEQIO7:	JUMPL	FLG,RANWRT	;JUMP IF ASCII
	TLNE	FLG,DDMBIN	;JUMP IF
	JRST	RANBIN		;  IT IS A BINARY FILE
	JRST	RANDO2		;GO CHECK THE RECORD SIZE
	;MOVE THE RANDOM/IO RECORD AREA TO THE BUFFER AREA.  ***RANXIT***
RANWR0:	ADDI	AC5,1		;POINT AT DATA NOT RECSIZ
RANWRT:	TLNN	AC16,WRITE+WADV ;IF IT'S WRITE,
	JRST	RANREA		;IT'S READ
	TLNE	FLG,DDMSIX	;SIXBIT STUFF IN THE BUFFER?
	PUSHJ	PP,RANSHF	;YES - MAKE SURE NEW RECORD FITS
	TLNN	FLG,CONNEC	;SKIP IF CONVERSION IS NECESSARY
	JUMPGE	FLG,RANRB	;SIXBIT, GO BLT THE DATA
	PUSHJ	PP,WRTXCT	;SETUP AC10
	TLNE	AC16,WADV	;IF IT'S WADV,
	PUSHJ	PP,WRTADV	;GO ADVANCE
RANWR1:	ILDB	C,AC6		;PICK UP A CHARACTER
	XCT	AC10		;CONVERT IF NECESSARY
	IDPB	C,AC5		;DEPOSIT THE CHAR.
	SOJG	AC3,RANWR1	;LOOP TILL A COMPLETE RECORD IS PROCESSED
	JUMPGE	FLG,RANWR2	;JUMP,SIXBIT HAS NO "CRLF"
	PUSHJ	PP,RANCR	;ALL ASCII RECORDS GET "CR"
	TLNE	AC16,WADV	;IF IT'S WRITE ADVANCE,
	PUSHJ	PP,WRTADV	;TRY TO
	TLNE	AC16,WRITE	;IF IT'S WRITE,
	PUSHJ	PP,RANLF	;GIVE HIM A "LF"
RANWR2:	SETOM	6(I12)		;THERE IS ACTIVE DATA IN THE BUFFER
	SETOM	7(I12)		;THE LAST COBOL UUO WAS A WRITE
	JRST	RANXIT		;TAKE A STANDARD EXIT

	;MOVE THE RANDOM/IO BUFFER AREA TO THE RECORD AREA.  ***RANXIT***
RANREA:	MOVE	AC1,AC3		;SAVE MAX RECORD SIZE IN CHARS
	TLNE	FLG,DDMSIX	;IF A SIXBIT FILE
	HRRZ	AC3,-1(AC5)	;  USE THE ACTUAL SIZE
	TLNN	FLG,CONNEC	;SKIP IF CONVERSION IS NECESSARY
	JUMPGE	FLG,RANBR	;SIXBIT, GO BLT	THE DATA
	MOVE	AC0,AC3		;SAVE ACTUAL RECORD SIZE
	PUSHJ	PP,REAXCT	;SETUP AC10
RANRE0:	ILDB	C,AC5		;PICK UP A CHARACTER
	XCT	AC10		;CONVERT IF NECESSARY
	JUMPLE	C,RANRE0	;IGNORE LEADING EOL CHARACTERS & NULLS
RANRE1:	IDPB	C,AC6		;DEPOSIT INTO RECORD AREA
	SOJE	AC3,RANRE3	;EXIT AFTER PROCESSING THE RECORD
	ILDB	C,AC5		;GET NEXT CHAR
	XCT	AC10		;CONVERT IF NECESSARY
	JUMPGE	C,RANRE1	;LOOP IF NOT AN EOL CHAR
RANRE3:	JUMPL	C,RANRE4	;ASCII AND NEEDS FILL
	JUMPL	FLG,RANRE2	;ASCII NO FILL REQUIRED
	SUB	AC1,AC0		;SIXBIT - HOW MUCH FILL?
	JUMPE	AC1,RANRE2	;JUMP IF NONE
	MOVE	AC3,AC1		;
RANRE4:	MOVEI	C,40		;ASCII SPACE
	TLNN	FLG,CDMASC	;ASCII?
	MOVEI	C,0		;NO, SIXBIT SPACE
	IDPB	C,AC6		;FILL OUT RECORD
	SOJG	AC3,.-1		;WITH SPACES
RANRE2:	SETZM	7(I12)		;THE LAST COBOL UUO WAS A READ

	;SETUP FLAG WORDS AND EXIT.  ***WRTRE7***

RANXIT:	MOVE	AC0,2(I12)	;CURRENT RECORD
	MOVEM	AC0,3(I12)	;LAST RECORD
	HRRI	AC0,-1(AC5)	;ADR OF NEXT RECORD
	MOVEM	AC0,2(I12)	;BP TO NEXT RECORD
	TLNN	AC16,READ	;SKIP IF A READ
	JRST	RANXI2		;WRITE HAS NO ATEND SKIP EXIT
	TLNN	FLG,ATEND	;SKIP IF ATEND
RANXI1:	TLZE	FLG,ATEND	;ZERO THE ATEND FLAG
RANXI3:	AOS	(PP)		;SKIP EXIT IF IT WAS SET
RANXI2:	MOVEM	FLG,10(I16)	;SAVE FLAGS
	HLLM	FLG1,D.F1(I16)	;SAVE MORE FLAGS
	HLLZS	UOUT.		;ZERO THE RIGHT HALF
	HLLZS	UIN.		;   IOWD POINTER
	JRST	WRTRE7		;EXIT TO THE ***"ACP"***

	;SIXBIT: BLT THE RECORD TO/FROM THE BUFFER AREA.

RANBR:	EXCH	AC5,AC6		;GO THE OTHER WAY
RANRB:	HRL	AC5,AC6		;FROM,,TO
	HRRZM	AC5,TEMP.	;
	TLNE	AC16,READ	;SKIP IF NOT READ
	HLRZM	AC5,TEMP.	;BUFFER ORIGIN
	MOVEI	AC4,6		;SIX PER WORD
RANBR1:	IDIV	AC3,AC4		;CONVERT TO WORDS
	JUMPE	AC4,.+2		;SKIP IF NO REMAINDER
	ADDI	AC3,1		;ELSE ACCOUNT FOR IT
	MOVE	AC0,AC3		;SAVE ACT SIZE FOR ZERO FILL
	ADDM	AC3,TEMP.	;NEXT RECORD
	ADDI	AC3,-1(AC5)	;UNTIL
	BLT	AC5,(AC3)	;ZRAPPP!
	MOVE	AC5,TEMP.	;
	ADDI	AC5,1		;POINT TO NEXT RECORD
	TLNN	AC16,READ	;SKIP IF IT'S A READ
	JRST	RANBR2		;NOP, A WRITE
	TLNE	FLG,DDMBIN	;NO FILL IF DEVICE DATA MODE
	JRST	RANRE2		;  IS BINARY
	ADDI	AC1,5		;GET MAX SIZE
	IDIVI	AC1,6		;  IN WORDS
	SUB	AC1,AC0		;WHAT'S THE DIFFERENCE?
	JUMPLE	AC1,RANRE2	;  DONE IF THE SAME
	SETZM	1(AC3)		;ZERO THE FIRST WORD
	HRLI	AC2,1(AC3)	;FROM
	HRRI	AC2,2(AC3)	;FROM , TO
	ADDI	AC1,(AC3)	;UNTIL
	CAIL	AC1,(AC2)	;DONE IF ONLY ONE WORD
	BLT	AC2,(AC1)	;FILL IN THE ZEROS
	JRST	RANRE2		;
RANBR2:	JUMPE	AC4,RANWR2	;EXIT HERE IF NO FILL REQUIRED
	HRREI	AC1,-6		;ASSUME RECORD IS SIXBIT
	TLNN	FLG,CDMSIX	;  IF NOT SIXBIT
	HRREI	AC1,-7		;  ITS ASCII
	IMUL	AC4,AC1		;ZERO FILL THE LAST DATA WORD
	SETO	AC0,		;--
	LSH	AC0,(AC4)	;--
	ANDCAM	AC0,(AC3)	;DOIT
	JRST	RANWR2

	;BINARY: BLT THE RECORD TO/FROM THE BUFFER AREA.

RANBIN:	HRL	AC5,FLG		;FROM RECORD TO BUFFER
	HRRZM	AC5,TEMP.	;SAVE BUFFER LOC
	TLNE	AC16,READ	;IF READ,
	MOVSS	AC5		;  REVERSE THE DIRECTION OF BLT
	MOVEI	AC4,6		;ASSUME SIXBIT MODE IN CORE
	TLNE	FLG,CDMASC	;IF IT IS ACTUALLY ASCII,
	MOVEI	AC4,5		;  RESET 'BYTES PER WORD'

	JRST	RANBR1
	;ALL RANDOM/IO INPUTS ARE EXECUTED FROM HERE.  OUTPUTS ARE
	;EXECUTED ONLY WHEN THERE IS ACTIVE DATA IN THE BUFFER AND
	;AND AN INPUT IS ABOUT TO OVERWRITE IT.  THE LAST ACTIVE DATA
	;IS CAUGHT BY THE CLOSE UUO.   ***POPJ***

RANIN:	SKIPGE	6(I12)		;SKIP IF THERES NOTHING TO OUTPUT
	PUSHJ	PP,RANOUT	;
	MOVEM	AC1,D.CBN(I16)	;SAVE CURRENT PHYS BLOCK NUMBER
	TLNE	FLG,RANFIL	;SKIP THE USETI IF SEQIO
	XCT	USETI.		;*****************
	HRRM	AC12,UIN.	;DUMP MODE IOWD
	LDB	AC5,FTBF.	;BLOCKING FACTOR
	TLNN	AC16,READ	;SKIP IF READ UUO
	CAIE	AC5,1		;DONT INPUT IF BLOCKING-FACTOR = 1
RANIN0:	TLNN	FLG,OPNIN!RANFIL ;DONT INPUT IF NOT OPEN FOR INPUT
	JRST	RANIN1		;NORMAL RET
	HLRO	AC0,@I12		;;-LEN
	HRRZ	AC10,(I12)	;;LOC -1
	SUB	AC10,AC0	;;LAST WORD OF BUFFER AREA
	SETOM	(AC10)		;;MARK IT
	HRRZM	AC10,TEMP.	;;SAVIT SO WE CAN DISMISS PHONY EOF'S
	XCT	UIN.		;********************
	JRST	RANIN1		;NORNAL RETURN
	MOVEM	AC2,TEMP.1	;SAVE AC2
	XCT	UGETS.		;ERROR RETURN
	MOVE	AC1,AC2		;
	PUSHJ	PP,READI1	;
RANIN1:	SKIPA	AC10,4(I12)	;BYTE POINTER TO FIRST RECORD
	 JRST	RANIN3		;EOF WAS SEEN  ;READI1 SKIP EXIT
	MOVEM	AC10,2(I12)	;POINTER TO CURRENT RECORD
	MOVEM	AC5,D.RCL(I16)	;REMAINING RECORDS IN CURRENT BLOCK
	POPJ	PP,
RANIN3:	MOVE	AC2,TEMP.1	;RESTORE AC2
	SKIPE	@TEMP.		;EOF AND SOME DATA?
	JRST	RANIN4		;NO
	TLZ	FLG,ATEND	;YES, SO TURN OFF THE EOF
	JRST	RANIN1		;  AND MAKE BELEIVE IT DIDN'T HAPPEN
RANIN4:	PUSHJ	PP,ZDMBUF	;ZERO THE DUMP MODE BUFFER
	TLNE	AC16,READ	;READ UUO?
	AOS	(PP)		;READ GETS A SKIP EXIT
	TLNE	AC16,READ	;READ UUO?
	TLNE	FLG,RANFIL	;RANDOM FILE?
	TLZ	FLG,ATEND	;YES - WRITE UUO SO CLEAR "ATEND"
	JRST	RANIN1		;TAKE NORMAL RETURN
	;ALL RANDOM/IO OUTPUTS ARE EXECUTED FROM HERE.  ***@POPJ***

RANOUT:	SETZM	6(I12)		;NOTE DATA WENT OUT
	EXCH	AC1,D.CBN(I16)	;NEXT BLOCK,,CURRENT BLOCK
	XCT	USETO.		;******************
	MOVE	AC1,D.CBN(I16)	;NEXT BLOCK BECOMES CURRENT BLOCK
	HRRM	AC12,UOUT.	;DUMP MODE IOWD
	JRST	WRTOUT		;DO IT

	;CHECK ACTUAL KEY AGAINST THE FILE-LIMIT-CLAUSES AND TAKE
	;THE INVALID-KEY RETURN IF NOT LEGAL.  ***POPJ***

FLIMIT:	MOVE	AC1,10(I12)	;PICK UP THE IOWD "FLC"
	HRRZ	AC4,12(I16)
	MOVE	AC4,(AC4)	;ACTUAL KEY
	JUMPE	AC4,RET.1	;OK IF 0, HE WANTS TO READ SEQ FROM HERE
	SKIPA
FLIMI1:	ADDI	AC1,2		;ACCOUNT FOR TWO LIMIT WORDS
	CAMLE	AC4,2(AC1)	;SKIP IF ACTKEY LE LARGER LIMIT
	JRST	.+3
	CAML	AC4,1(AC1)	;SKIP IF ACTKEY L THE SMALLER LIMIT
	POPJ	PP,		;OK EXIT
	AOBJN	AC1,FLIMI1	;
	TLNN	AC16,READ!WRITE!WADV ;SKIP IF NOT A SEEK UUO
	POPJ	PP,		;SEEK, RETURN TO ***ACP***
	POP	PP,AC0		;POP OFF RETURN ADR
FLIMIX:	TLNN	AC16,READ	;INVALID-KEY EXITSKIP IF READ
	AOS	(PP)		;SKIP OVER THE OPERAND
	JRST	RET.2		;  AND TAKE A SKIP EXIT   ***ACP***

	;ZERO THE DUMP MODE BUFFER AREA

ZDMBUF:	HLRO	AC4,(I12)	;-LEN
	HRR	AC1,(I12)	;LOC-1
	HRLI	AC1,1(AC1)	;FROM
	HRRI	AC1,2(AC1)	;TO
	SETZM	-1(AC1)		;THE ZERO
	MOVN	AC4,AC4	;LEN
	ADDI	AC4,-1(AC1)	;UNTIL
	BLT	AC1,(AC4)	;DOIT
	POPJ	PP,

RANLF:	SKIPA	C,[12]		;
RANCR:	MOVEI	C,15		;
	IDPB	C,AC5		;
	POPJ	PP,		;

	;HERE BEFORE WRITING A NEW RECORD
	;MAKE THE OLD RECORD SIZE CONFORM TO NEW SIZE
RANSHF:	CAMN	AC2,AC3		;ACTUAL-SIZE VS NEW-SIZE
	POPJ	PP,		;SKIP THIS MESS
	MOVE	AC4,D.RCL(I16)	;IF NO RECORDS FOLLOWING
	JUMPE	AC4,RANS09	;  DONE
	MOVEI	AC0,5(AC3)	;NEW SIZE
	IDIVI	AC0,6		;  IN WORDS
	MOVEI	AC1,5(AC2)	;ACTUAL SIZE
	IDIVI	AC1,6		;  IN WORDS
	SUB	AC0,AC1		;NS - AS
	JUMPE	AC0,RANS09	;SAME SIZE SO EXIT

;FIND THE LAST DATA WORD IN THIS LOGICAL BLOCK
	MOVE	AC10,AC1	;SIZE OF THIS RECORD
	MOVEI	AC2,-1(AC5)	;ADR OF THIS RECORD'S HEADER WORD
RANS01:	ADDI	AC2,1(AC10)	;ADR OF NEXT HEADER WORD
	HRRZ	AC10,@AC2	;SIZE OF NEXT RECORD IN CHARACTERS
	ADDI	AC10,5		;  --
	IDIVI	AC10,6		;  IN WORDS
	SOJG	AC4,RANS01	;LOOP IF ANY MORE
	ADDI	AC2,(AC10)	;ADR OF LAST DATA WORD
	HRRO	AC10,AC5	;ADR OF THE FIRST RECORD WORD
	ADD	AC10,AC1	;ADR OF NEXT RECORD'S HEADER WORD
	JUMPG	AC0,RANS03	;IF POSITIVE MAKE A LARGER HOLE

;NEGATIVE SO MAKE A SMALLER HOLE
	HRLS	AC10		;ADR OF NEXT RECORD HEADER WORD
	ADD	AC10,AC0	;  PLUS THE DIFFERENCE
	ADD	AC2,AC0		;THE BLT UNTIL POINTER
	BLT	AC10,(AC2)	;MOVE IT
	SETZM	1(AC2)		;TERMINATE DATA
	JRST	RANS09

;POSITIVE SO MAKE A LARGER HOLE
RANS03:	HRRZ	AC4,AC2		;ADR OF LAST DATA WORD
	SUBI	AC4,-1(AC10)	;NUMBER OF WORDS TO MOVE
	HRR	AC10,AC2	;START WITH THE LAST DATA WORD
	HRLI	AC0,(POP AC10,(AC10))
	HRLZI	AC1,(SOJG AC4,AC0)
	HRLZI	AC2,(POPJ PP,)
	PUSHJ	PP,AC0		;POP-POP-POP
RANS09:	HRRZM	AC3,-1(AC5)	;GIVE IT A HEADER WORD
	HRRZ	AC2,AC3		;RESTORE AC2
	POPJ	PP,
SUBTTL ISAM-CODE
IFN ISAM,<
	;INDEX-SEQ READ
IREAD:	TLZ	FLG1,-1		;INITIALIZE FLG1
	PUSHJ	PP,SETIC	;SET THE CHANNEL
	AOS	RWRSTA(I12)	;# OF READ/WRITE/REWRITES
	PUSHJ	PP,LVTST	;SYMKEY = LOW-VALUES ?
	 JRST	SREAD		;YES, SEQUENTIAL READ
	PUSHJ	PP,@GETSET(I12)	;ADJKEY OR GD67 OR FPORFP
	PUSHJ	PP,IBS		;LOCATE THE RECORD
	PUSHJ	PP,MOVBR	;MOVE REC FROM BUFFER TO REC-AREA
	POPJ	PP,


RRDIVK:	SKIPE	BRISK(I12)	;SKIP IF SLOW MODE
	JRST	RRDIV4		;JUMP IF FAST MODE
	TLON	FLG1,RIVK	;SET INVALID-KEY, FIRST TIME?
	JRST	IBSTO1		;YES

	;MAKE CNTRY POINT AT THE RECORD PRECEEDING THE 'NOT-FOUND' RECORD
RRDIV4:	HRRZI	AC0,-1(AC4)	;ADR OF THE RECORD HEADER WORD
	HRRZ	AC2,DRTAB	;
RRDIV3:	SKIPL	AC3,(AC2)	;ADR OF FIRST REC-HEADER WORD IN THIS BLOCK
	CAIN	AC0,(AC3)		;CURRENT RECORD?
	SKIPA	AC3,-1(AC2)	;YES, GET ADR OF PREVIOUS REC-HDR
	AOJA	AC2,RRDIV3	;NO, TRY AGAIN
	ADDI	AC3,1		;FIRST WORD AFTER HEADER
	CAME	AC2,DRTAB	;FIRST RECORD OF THE FILE?
	JRST	RRDIV2		;NO
	SETOM	NNTRY(I12)	;NOTE CNTRY POINTS TO NEXT ENTRY
	MOVE	AC0,IOWRD(I12)	;
	ADDI	AC0,2		;
	HRRM	AC0,CNTRY(I12)	;POINT AT FIRST RECORD IN BLOCK
	JRST	RRDIV1
RRDIV2:	HRRZM	AC3,CNTRY(I12)	;POINT AT FIRST REC BEFORE 'NOT -FOUND' REC
RRDIV1:	POP	PP,AC0		;
	TLNN	AC16,READ	;READ?
	AOS	(PP)		;NO, RERITE OR DELET
	JRST	RET.2		;INVALID-KEY RETURN
	;SEQUENTIAL READ
SREAD:	TLO	FLG1,SEQ	;FLAG SREAD
	SKIPE	CNTRY(I12)	;IS THIS THE FIRST READ EVER?
	JRST	SREAD1		;NO
	PUSHJ	PP,@GETSET(I12)	;SET UP SEARCH FOR LOW-VALUES
	PUSHJ	PP,IBS		;FIND FIRST DATA RECORD
	JRST	SREAD2

	;TRY FOR THE NEXT DATA REC IN THIS BLOCK
SREAD1:	SETZ	LVL,		;WE ARE AT LEVEL 0!
	HRRZ	AC4,CNTRY(I12)	;CURRENT ENTRY
	SKIPE	NNTRY(I12)	;CNTRY ALREADY POINTING AT NEXT ENTRY?
	JRST	SREAD2		;YES
	LDB	AC1,RSBP(I12)	;
	IDIV	AC1,D.BPW(I16)	;
	JUMPE	AC2,.+2		;
	ADDI	AC1,1		;
	ADDI	AC4,1(AC1)	;NEXT ENTRY
SREAD2:	SKIPE	-1(AC4)		;NULL REC = LAST REC
	CAMLE	AC4,LRW(I12)	;WAS THAT THE LAST REC?
	PUSHJ	PP,UPDOWN	;YES, GET THE NEXT
	HRRM	AC4,CNTRY(I12)	;SAVE AS CURRENT ENTRY
	SETZM	NNTRY(I12)	;NOTE CNTRY POINTS AT CURRENT ENTRY
	PUSHJ	PP,SETLRW	;SET UP LRW INCASE A 'DELET' OCCURED
	JRST	MOVBR		;MOVE RECORD FROM BUFFER TO RECORD AREA & EXIT


	;LOOK UP AND DOWN THROUGH THE INDEX FOR THE NEXT REC
UPDOWN:	ADDI	LVL,1		;UP AN INDEX LEVEL
	CAMLE	LVL,MXLVL(I12)	;ANY MORE LEVELS?
	JRST	UPDOW1		;NO, INVALID KEY EXIT

	MOVE	AC4,@CNTRY0(I12)  ;GET THE LAST ENTRY
	SKIPN	@NNTRY0(I12)	;CNTRY ALREADY AT NEXT ENTRY?
	ADD	AC4,IESIZ(I12)	;NO, THE CURRENT ENTRY
	HRRZ	AC2,@IOWRD0(I12)  ;
	ADD	AC2,IBLEN(I12)	;
	HRRZI	AC2,3(AC2)	;UPPER LIMIT
	SKIPE	(AC4)		;IF NULL, REST OF BLOCK IS EMPTY
	CAIG	AC2,(AC4)	;ANY MORE ENTRIES AT THIS LEVEL?
	PUSHJ	PP,UPDOWN	;NO, UP ANOTHER LEVEL

	HRRM	AC4,@CNTRY0(I12)  ;CURRENT ENTRY SAVED
	SETZM	@NNTRY0(I12)	;CNTRY POINTS AT CURRENT ENTRY
	SUBI	LVL,1		;DOWN AN INDEX LEVEL
	PUSHJ	PP,GETBLK	;GET NEXT BLOCK
	MOVE	AC4,@IOWRD0(I12)
	ADDI	AC4,2		;
	SKIPE	LVL		;
	ADDI	AC4,1		;CURRENT ENTRY OR REC
	POPJ	PP,

UPDOW1:	POP	PP,AC0		;POPOFF THE RETURNS
	SOJG	LVL,.-1		;
	JRST	RET.2		;INVALID KEY RETURN

	;HERE FROM GETBLK VERSION NUMBER DISCREPANCY WHEN SREADING
UDVERR:	POP	PP,AC0		;MAKE THE STACK RIGHT
	SOJG	LVL,.-1
	TLOE	FLG1,VERR	;1ST VERSION ERROR GETS ANOTHER TRY
	JRST	GETB0G		;2ND GETS A KILL.

	HRLI	AC1,2(AC4)	;MOVE CURRENT KEY TO SYMBOLIC-KEY
	HRR	AC1,23(I16)	;FROM,,TO
	MOVE	AC2,IESIZ(I12)	;
	SUBI	AC2,2		;LEN
	ADDI	AC2,-1(AC1)	;UNTIL
	BLT	AC1,(AC2)	;MOVIT

	MOVE	LVL,MXLVL(I12)	;OK - TAKE IT FROM THE TOP
	PUSHJ	PP,@GETSET(I12)	;
	PUSHJ	PP,IBS		;

	;SET LOW-VALUES TO SYMKEY
LV2SK:	MOVE	AC1,23(I16)	;SK BYTE-POINTER
	LDB	AC3,[POINT 3,KEYDES(I12),23]	;TYPE
	CAIGE	AC3,3		;DISPLAY ?
	JRST	LV2SK2		;YES

	CAIG	AC3,4		;FIXED POINT ?
	SKIPA	AC0,[1B0]	;YES, LOW-VALUE
	MOVE	AC0,[1B0+1]	;FLOATING PT. LOW-VALUE
	MOVEM	AC0,(AC1)	;TO SYMKEY
	TLNN	AC3,1		;TWO WORDS ?
	MOVEM	AC0,1(AC1)	;
	POPJ	PP,		;NO, EXIT

LV2SK2:	LDB	AC2,[POINT 12,KEYDES(I12),35]	;SIZE
	SETZ	AC0,
	IDPB	AC0,AC1		;DEPOSIT SOME LV'S
	SOJG	AC2,.-1
	POPJ	PP,
	;HERE TO DELETE A RECORD
DELET.:	TLOA	AC16,DELET	;

	;HERE TO REWRITE AN EXISTING RECORD
RERIT.:	TLO	AC16,RERIT	;
	MOVE	AC15,@UOCAL.	;
	PUSHJ	PP,WRTSUP	;
	TLNN	FLG,OPNOUT	;FILE OPEN FOR OUTPUT?
	PUSHJ	PP,ERROPN	;NO
	PUSHJ	PP,LVTST	;LOW-VALUES IN SYMBOLIC KEY?
	 JRST	LVSKER		;YES, ITS ILLEGAL

	AOS	RWRSTA(I12)
	TLZ	FLG1,-1		;INITIALIZE THE FLAG REG
	PUSHJ	PP,SETIC	;SET THE INDEX CHANNEL
	PUSHJ	PP,@GETSET(I12)	;ADJKEY OR GD67 OR FPORFP
	PUSHJ	PP,IBS		;FIND THE RECORD
	PUSHJ	PP,SETLRW	;FIND THE LAST RECORD WORD
	PUSHJ	PP,SHFREC	;MAKE SURE THE NEW REC WILL FIT
	TLNE	AC16,DELET	;DELET ?
	JRST	DEL01		;YES
	PUSHJ	PP,MOVRB	;MOVE THE RECORD
RERIT2:	PUSHJ	PP,WDBK		;WRITE THE DATA BLOCK
	JRST	RET.2

DEL01:	HRRZ	AC2,LRW(I12)	;
	SETZM	1(AC2)		;TERMINATE THE DATA BLOCK
	HRRZ	AC3,IOWRD(I12)
	CAMN	AC2,AC3		;IS DATA BLOCK EMPTY ?
	PUSHJ	PP,DEL10	;YES, GO UPDATE THE INDEX
	SKIPE	OLDBK		;ANYTHING TO DE-ALLOCATE?
	PUSHJ	PP,DALC		;YES
	JRST	RERIT2

	;IF NOT FIRST ENTRY IN THE INDEX BLOCK
	; JUST DELET THE ENTRY & EXIT
DEL10:	MOVE	AC1,USOBJ(I12)	;ADR OF EMPTY BLOCK
	MOVEM	AC1,OLDBK	;SAVE FOR DE-ALLOCATION
DEL11:	ADDI	LVL,1		;UP A LVL
	HRRZ	AC1,@CNTRY0(I12)
	HRRZ	AC0,@IOWRD0(I12)  ;
	ADDI	AC0,3
	CAME	AC0,AC1		;FIRST ENTRY THIS BLK ?
	JRST	DEL40		;NO, DELET ENTRY & EXIT

	HLL	AC1,24(I16)
	PUSHJ	PP,LVTSTI	;TEST FOR LOW-VALUES
	 JRST	DEL13		;LOW-VALUES!

	SUBI	AC1,2		;FIRST WORD OF CURRENT ENTRY
	SETZM	(AC1)		;BLOCK IS EMPTY; CLEAR THE BLOCK NUMBER
	ADD	AC1,IESIZ(I12)
	SKIPN	(AC1)		;IS IB EMPTY ?
	JRST	DEL11		;YES, UP A LEVEL & DELET ITS ENTRY
	HRRZ	AC1,@CNTRY0(I12)
	PUSHJ	PP,DEL40	;NO, DELET THIS ENTRY
	JRST	DEL50		;FIX NEXT LEVEL'S KEY

DEL13:	SETZM	OLDBK		;SAVE THIS EMPTY BLOCK
	HRRZ	AC1,@CNTRY0(I12)
	SETZM	1(AC1)		;MAKE VERSION NUMBER BE SAME AS DATA'S
	ADD	AC1,IESIZ(I12)
	SKIPN	(AC1)		;IS IB EMPTY ?
	JRST	WIBK		;YES, EXIT

	;KEY = LOW-VALUES SO JUST UPDATE BLOCK / VERSION NUMBERS
	HRRZ	AC1,@CNTRY0(I12)
	MOVE	AC2,AC1		;FIRST ENTRY
	ADD	AC1,IESIZ(I12)	;SECOND ENTRY
	MOVE	AC0,(AC1)
	MOVEM	AC0,(AC2)	;BLOCK NUMBER
	MOVE	AC0,1(AC1)
	MOVEM	AC0,1(AC2)	;VERSION NUMBER
	;DELET AN INDEX ENTRY
DEL40:	HRR	AC2,AC1
	ADD	AC1,IESIZ(I12)
	HRL	AC2,AC1		;FROM,,TO
	HLRO	AC6,@IOWRD0(I12)
	MOVNS	AC6
	ADD	AC6,@IOWRD0(I12)	;LAST WORD OF LAST ENTRY

DEL41:	CAIG	AC1,(AC6)		;STILL IN ACTIVE DATA?
	SKIPN	(AC1)		;YES, NULL ENTRY?
	JRST	DEL42		;DONE
	ADD	AC1,IESIZ(I12)	;
	JRST	DEL41

DEL42:	SUB	AC1,IESIZ(I12)	;
	BLT	AC2,-1(AC1)	;
	SETZM	(AC1)		;TERMINATE THE ENTRIES
	SETOM	@NNTRY0(I12)	;NOTE CNRTY POINTS AT NEXT ENTRY
	JRST	WIBK		;WRITE THE NEW INFO

	;OK NEXT LEVEL, UPDATE THE KEY
DEL50:	CAMN	LVL,MXLVL(I12)	;IS THERE ANOTHER LEVEL ?
	POPJ	PP,		;NO
	MOVEI	AC1,@CNTRY0(I12)
	MOVE	AC2,(AC1)
	HRLI	AC2,2(AC2)	;FROM
	HRR	AC2,1(AC1)
	ADDI	AC2,2		;FROM,,TO
	MOVE	AC3,IESIZ(I12)
	ADDI	AC3,-3(AC2)	;UNTIL
	BLT	AC2,(AC3)	;JUST THE KEY
	AOJA	LVL,WIBK
	;HERE FROM WRITE.
IWRITE:	PUSHJ	PP,LVTST	;LOW VALUES IN SYM-KEY?
	 JRST	LVSKER		;ILLEGAL!

	AOS	RWRSTA(I12)	;BUMP # OF WRITE STATEMENTS
	PUSHJ	PP,SETIC	;SET CHAN FOR INDEX FILE
	PUSHJ	PP,@GETSET(I12)	;
	PUSHJ	PP,IBS		;FIND WHERE TO INSERT
	HRRZ	AC6,D.RCL(I16)	;# OF EMPTY RECS THIS BLK
	JUMPG	AC6,IWRI02	;IS CURRENT BUFFER FULL?
	JRST	SPLTBK		;YES, MAKE SOME ROOM

IWRI01:	PUSHJ	PP,WABK		;WRITE THE AUXBUF
IWRI02:	HRRZ	AC1,DBF(I12)	;GET BLOCKING FACTOR
	CAIE	AC1,1		;DON'T NEED A HOLE IF BF = 1
	PUSHJ	PP,SHFHOL	;MAKE A HOLE
	PUSHJ	PP,SRHW		;SET THE RECORD HEADER WORD
	PUSHJ	PP,MOVRB	;INSERT THE RECORD
	PUSHJ	PP,WDBK		;MARK DATA BLOCK ACTIVE
	TLNN	FLG1,BVN	;WAS DATA BLOCK SPLIT?
	JRST	IWRIX		;NO
	SKIPE	LIVE(I12)	;ANYTHING TO BE OUTPUT?
	PUSHJ	PP,WWDBK	;YES - WWRITE OUT THE DATA

	;MAKE AN INDEX ENTRY & UPDATE THE INDEX FILE
IWRI04:	MOVE	AC1,IAKBP(I12)	;
	MOVE	AC0,NEWBK1	;
	MOVEM	AC0,-2(AC1)	;BLOCK NUMBER
	MOVE	AC2,IOWRD(I12)	;
	HLRZ	AC0,1(AC2)	;
	TRZ	AC0,-100	;CLEAR FILE FORMAT INFO
	MOVEM	AC0,-1(AC1)	;VERSION NUMBER

	MOVE	AC3,AUXBUF	;
	ADD	AC3,24(I16)	;
	ADDI	AC3,1		;
	MOVE	AC2,AC3		;
	HRLZI	AC1,7777	;MASK
	ANDCAM	AC1,AC2		;CLEAR BYTE SIZE
	AND	AC1,GDPSK(I12)	;GET KEY SIZE & SIGN
	IOR	AC2,AC1	;MERGE
	EXCH	AC3,23(I16)	;FIRST KEY OF AUXBUF VS SYMKEY
	EXCH	AC2,GDPSK(I12)	;
	PUSHJ	PP,@GETSET(I12)	;PLACE FIRST KEY OF AUXBUF IN IAKBP
	EXCH	AC3,23(I16)	;RESTORE SYMKEK POINTER
	EXCH	AC2,GDPSK(I12)	;RESTORE
	PUSHJ	PP,UDIF		;UPDATE THE INDEX FILE
	PUSHJ	PP,WIBK		;WRITE THE INDEX BLOCK

IWRIX:	SKIPE	OLDBK		;ANY BLOCKS TO DEALLOCATE
	PUSHJ	PP,DALC		;YES, DOIT
	JRST	RET.2


IWIVK:	SKIPE	BRISK(I12)	;SKIP IF SLOW MODE
	JRST	IWIVK2		;
	TLON	FLG1,WIVK	;HAVE WE BEEN HERE BEFOR?
	JRST	IBSTO1		;NO, TRY AGAIN
IWIVK2:	SUB	AC4,24(I16)	;POINT AT BEGINNING OF THIS ENTRY
	HRRZM	AC4,CNTRY(I12)	;SAVE IN CASE SEQ READ IS NEXT
IWIVK1:	POP	PP,AC0		;
	JRST	RET.3

	;UPDATE THE INDEX FILE
UDIF:	ADDI	LVL,1		;UP A LEVEL
	CAMLE	LVL,MXLVL(I12)	;ANY MORE LEVELS?
	JRST	UDIF10		;NO, MAKE A NEW LEVEL

	;UPDATE CURRENT ENTRY BLOCK & VERSION NUMBERS
	HRRO	AC2,@CNTRY0(I12) 
	MOVE	AC3,NEWBK2	;
	MOVEM	AC3,(AC2)	;NEW BLOCK NUMBER
	MOVE	AC1,1(AC2)	;THE VERSION NUMBER
	ADDI	AC1,1		;BUMP IT
	CAIN	LVL,1		;A DATA BLOCK VERSION NUMBER?
	TRZ	AC1,-100	;CLEAR THE FILE FORMAT INFO
	MOVEM	AC1,1(AC2)	;PUT IT BACK

	;MUST INDEX BLOCK BE SPLIT?
	MOVE	AC1,IBLEN(I12)	;
	ADD	AC1,@IOWRD0(I12)
	ADDI	AC1,3		;SKIP OVER THE HEADER
	SUB	AC1,IESIZ(I12)	;POINT AT LAST ENTRY
	SKIPE	(AC1)		;MUST IDXBLK BE SPLIT?
	JRST	UDIF20		;YES

	;MAKE A HOLE FOR NEW ENTRY
UDIF30:	MOVE	AC1,IESIZ(I12)	;DISPLACEMENT
	HRRO	AC2,@CNTRY0(I12)
	ADD	AC2,AC1		;
	SKIPN	(AC2)		;
	JRST	UDIF31		;NO HOLE NEEDED, JUST APPEND
UDIF33:	ADD	AC2,AC1		;
	SKIPE	(AC2)		;IS THIS LAST ENTRY?
	JRST	UDIF33		;NO
	HRRZ	AC0,AC2		;
	SUBI	AC2,1		;-1 ,, LEN
	SUB	AC0,@CNTRY0(I12)  ;LEN
	PUSHJ	PP,SHFR00	;MAKE HOLE

UDIF31:	TLNE	FLG1,WSTB	;MUST STATISTICS BLOCK BE WRITTEN?
UDIF34:	PUSHJ	PP,WSTBK	;YES
	MOVE	AC0,IAKBP(I12)	;
	ADDI	AC0,-2		;
	HRL	AC0,AC0		;FROM,,FROM
	HRR	AC0,@CNTRY0(I12)  ;FROM,,TO
	MOVE	AC1,IESIZ(I12)	;
	ADD	AC0,AC1		;
	ADD	AC1,AC0		;UNTIL
	HRRM	AC0,@CNTRY0(I12)  ;UPDATE CNTRY FOR SREAD
	BLT	AC0,-1(AC1)	;INSERT THE ENTRY
	POPJ	PP,		;EXIT TO IWRITE
	;BUMP THE VERSION NUMBER
UDIF20:	MOVE	AC2,AUXBUF
	HRRZ	AC3,@IOWRD0(I12)
	ADDI	AC3,2
	MOVE	AC0,-1(AC3)	;
	MOVEM	AC0,(AC2)	;HEADER WORD - BLOCK SIZE EXPRESSED AS 6BIT BYTES
	AOS	AC3,(AC3)	;IN THE CURRENT IDXBLK
	MOVEM	AC3,1(AC2)	;  AND IN AUXBUF

	;DECIDE WHERE TO SPLIT THE INDEX BLOCK
	MOVE	AC3,EPIB(I12)	;NUMBER OF INDEX ENTRIES
	LSH	AC3,-1		;HALVE IT
	IMUL	AC3,IESIZ(I12)	;
	ADDI	AC3,3		;
	ADD	AC3,@IOWRD0(I12)  ;FIRST ENTRY OF 2ND HALF
	TLZ	AC3,-1		;CLEAR LEFT HALF THEN COMPARE
	CAMG	AC3,@CNTRY0(I12)  ;NEW ENTRY IN FIRST HALF?
	JRST	UDIF21		;YES

	;NEW ENTRY IS IN FIRST HALF OF CURRENT IDXBLK
	;MOVE SECOND HALF TO AUXBUF
	HLRZ	AC2,@IOWRD0(I12)
	MOVNI	AC2,(AC2)	;
	ADD	AC2,@IOWRD0(I12)
	HRRZM	AC2,TEMP.	;UNTIL - FOR ZEROING IDXBLK
	SUBI	AC2,-1(AC3)	;<LEN-1> OF 2ND HALF
	ADDI	AC2,2		;SKIP OVER HEADER
	ADD	AC2,AUXBUF	;UNTIL
	HRL	AC1,AC3		;FROM
	HRR	AC1,AUXBUF	;TO
	ADDI	AC1,2		;SKIP OVER HEADER
	BLT	AC1,-1(AC2)	;

	;INSERT NEW ENTRY IN CURRENT IDXBLK
	SETZM	(AC3)		;SET LOOP CATCHER FOR UDIF33
	ADD	AC3,IESIZ(I12)	;INCLUDE THE NEW ENTRY
	MOVEM	AC2,TEMP.1
	MOVEM	AC3,TEMP.2
	PUSHJ	PP,UDIF30
	MOVE	AC2,TEMP.1
	MOVE	AC3,TEMP.2
	JRST	UDIF25		;FINISH UP

UDIF21:	TLO	FLG1,IIAB	;INSERTION IS IN AUXBUF
	ADD	AC3,IESIZ(I12)	;PUT ONE MORE ENTRY IN 1ST HALF
	CAMLE	AC3,@CNTRY0(I12)  ;NEW ENTRY FIRST IN AUXBUF?
	JRST	UDIF22		;YES

	;MOVE FIRST PART OF 2ND HALF TO AUXBUF
	HRL	AC2,AC3		;FROM
	HRR	AC2,AUXBUF	;TO
	ADDI	AC2,2		;SKIP OVER HEADER & VERSION NUMBER
	HRRZ	AC1,@CNTRY0(I12)
	SUBI	AC1,(AC3)	;LEN
	ADD	AC1,IESIZ(I12)	;INCLUDE THE CURRENT ENTRY
	HRRZM	AC1,TEMP.	;LEN OF 1ST PART
	ADDI	AC1,(AC2)	;UNTIL
	BLT	AC2,-1(AC1)	;MOVE FIRST PART
	JRST	UDIF23

	;NEW ENTRY IS FIRST IN AUXBUF
UDIF22:	SETZM	TEMP.		;LEN OF FIRST PART IS ZERO
	HRRZ	AC1,AUXBUF	;TO
	ADDI	AC1,2		;SKIP OVER THE HEADER WORD

	;INSERT THE NEW ENTRY
UDIF23:	HRRZM	AC1,TEMP.2	;AUXBUF CNTRY, SAVE FOR MAUXI
	HRR	AC0,IAKBP(I12)	;
	ADDI	AC0,-2		;
	HRL	AC0,AC0		;
	HRR	AC0,AC1		;FROM,,TO
	ADD	AC1,IESIZ(I12)	;UNTIL
	BLT	AC0,-1(AC1)	;INSERT

	;MOVE REST OF 2ND HALF TO AUXBUF
	HRR	AC0,TEMP.	;LEN OF FIRST PART
	ADD	AC0,AC3		;FROM
	HRL	AC0,AC0		;FROM,,FROM
	HRR	AC0,AC1		;TO
	MOVE	AC2,@IOWRD0(I12)
	MOVE	AC5,IESIZ(I12)	;
	IMUL	AC5,EPIB(I12)	;
	ADDI	AC2,2(AC5)	;LAST WORD OF LAST ENTRY
	HRRZM	AC2,TEMP.1	;'LEW', SAVE FOR MAUXI
	SUB	AC2,TEMP.	;
	ADDM	AC2,TEMP.	;UNTIL, FOR CLEARING CURRENT IDXBLK
	SUBI	AC2,(AC3)	;LEN-1
	ADDI	AC2,1(AC1)	;UNTIL
	BLT	AC0,-1(AC2)	;REST TO AUXBUF
	HRRZM	AC2,LRWA	;
	SOS	LRWA		;LAST ACTIVE WORD IN AUXBUF, SAVE FOR MAUXI
	;ZERO 2ND HALF OF CURRENT IDXBLK
UDIF25:	SETZM	(AC3)	;
	HRL	AC0,AC3		;
	HRRI	AC0,1(AC3)	;FROM,,TO
	HRRZ	AC1,TEMP.	;
	BLT	AC0,(AC1)	;

	;ZERO 2ND HALF OF AUXBUF
	SETZM	(AC2)		;
	HRL	AC2,AC2		;
	HRRI	AC2,1(AC2)	;FROM,,TO
	MOVE	AC1,AUXIOW	;
	HLRZ	AC0,AC1		;
	SUB	AC1,AC0		;UNTIL - END OF AUXBUF
	BLT	AC2,(AC1)	;

	;MAKE A NEW ENTRY
	PUSHJ	PP,ALC2IB	;GRAB TWO BLOCKS
	MOVE	AC0,NEWBK1	;
	MOVEM	AC0,AUXBNO	;
	MOVE	AC1,IAKBP(I12)	;
	MOVEM	AC0,-2(AC1)	;BLOCK NUMBER
	MOVE	AC2,@IOWRD0(I12)
	MOVE	AC0,2(AC2)	;
	MOVEM	AC0,-1(AC1)	;VERSION NUMBER

	MOVE	AC3,AUXBUF	;MOVE KEY TO HOLDING AREA
	HRLI	AC3,4(AC3)	;
	HRRI	AC3,(AC1)	;FROM,,TO
	MOVE	AC2,IESIZ(I12)	;
	ADDI	AC2,-2(AC3)	;
	BLT	AC3,-1(AC2)	;

	;WRITE OUT THE SPLIT BLOCKS
	MOVE	AC1,NEWBK2	;
	MOVEM	AC1,@USOBJ0(I12)  ;NEW BLOCK NUMBER FOR CURRENT IDXBLK
	PUSHJ	PP,WIBK		;CURRENT
	PUSHJ	PP,WABK		;AUXBLK
	CAMN	LVL,MXLVL(I12)	;IS THIS THE TOP INDEX LEVEL?
	PUSHJ	PP,SAVTIE	;YES, SO SAVE TOP INDEX ENTRY FOR NEW TOP-LVL
	TLZE	FLG1,IIAB	;WAS INSERTION IN AUXBUF?
	PUSHJ	PP,MAUXI	;MOVE AUXBUF TO IDXBUF
	JRST	UDIF		;UPDATE THE NEXT LEVEL
	;CREATE ANOTHER LEVEL OF INDEX
UDIF10:	CAILE	LVL,12		;MORE LEVELS AVAILABLE?
	JRST	[TTCALL 3,[ASCIZ /NO MORE INDEX LEVELS AVAILABLE TO/]
		MOVE	AC2,[BYTE (5)10,31,20]
		PUSHJ	PP,MSOUT.]	;KILL.
	AOS	MXLVL(I12)	;INCREASE MXLVL BY ONE
	MOVEI	AC11,@IOWRD0(I12)
	SKIPN	KEYCNV		;SORT IN PROGRESS?
	PUSHJ	PP,UDIF11	;NO, TRY FOR MORE CORE
	MOVE	AC3,-1(AC11)	;YES, IOWRD OF OLD TOP INDEX BLOCK
	MOVE	AC5,1(AC3)	;FIRST HEADER WORD OF OLD TOP LEVEL
	ADD	AC5,[XWD 1,0]	;BUMP THE LEVEL BY ONE
	MOVE	AC1,(AC11)	;IOWRD OF NEW TOP INDEX BLOCK
	MOVEM	AC5,1(AC1)	;SAVE AS FIRST HEADER WORD
	SETZM	2(AC1)		;VERSION NUMBER OF TOP LEVEL IS ZERO

	;MAKE AN ENTRY  POINTING AT OLD TOP-LEVEL
	HRL	AC5,IESAVE	;
	HRRI	AC5,3(AC1)	;TO
	HRRZM	AC5,@CNTRY0(I12)  ;FIRST ENTRY = CURRENT ENTRY
	HRRZ	AC2,AC5	
	ADD	AC2,IESIZ(I12)	;UNTIL
	BLT	AC5,-1(AC2)	;DOIT

	PUSHJ	PP,ALC1IB	;GET THE NEXT FREE BLOCK
	MOVE	AC1,NEWBK2	;
	MOVEM	AC1,TOPIBN(I12)	;TOP INDEX BLOCK NUMBER
	MOVEM	AC1,@USOBJ0(I12)  ;  ALSO CURRENT
	TTCALL	3,[ASCIZ /
$ /]
	MOVE	AC2,[BYTE (5)10,31,20,14]
	PUSHJ	PP,MSOUT.
	TTCALL	3,[ASCIZ / SHOULD BE REORGANIZED,
THE TOP INDEX BLOCK WAS JUST SPLIT.
/]
	JRST	UDIF34

UDIF11:	CAIN	LVL,12		;IF HIGHEST POSSIBLE LEVEL
	SKIPL	@IOWRD0(I12)	;  AND SPACE IS STILL AVAILABLE
	JRST	.+2
	JRST	UDIF12		;  USE THE ALLOCATED AREA

	;ZERO FREE CORE
	HRRZ	AC1,.JBFF
	SETZM	(AC1)
	HRL	AC0,AC1
	HRRI	AC0,1(AC1)
	HRRZ	AC1,.JBREL
	BLT	AC0,(AC1)

	HLRO	AC1,-1(AC11)	;
	MOVN	AC0,AC1		;LENGTH FOR GETSPC
	HRL	AC1,.JBFF	;DWOI
	PUSHJ	PP,GETSPC	;GET SOME SPACE
	 JRST	UDIF12		;NO MORE CORE
	MOVE	AC0,(AC11)	;IOWD FOR ALLOCATED AREA
	CAIGE	LVL,12		;SKIP IF IF CAN'T BE
	MOVEM	AC0,1(AC11)	;SAVE FOR NEXT TOP BLK SPLIT
	MOVSS	AC1		;-LEN,,LOC
	SUBI	AC1,1		;MAKE IT AN IOWD
	MOVEM	AC1,(AC11)	;SAVE AS CURRENT IOWRD

UDIF12:	SKIPE	(AC11)		;ANY CORE ALLOCATED?
	POPJ	PP,		;YES, PHEW!
	TTCALL	3,[ASCIZ /INSUFICIENT CORE WHILE ATTEMPTING TO SPLIT THE TOP INDEX BLOCK OF/]
	MOVE	AC2,[BYTE(5)10,31,20]
	PUSHJ	PP,MSOUT.	;KILL.

	;ALOCATE TWO INDEX BLOCKS

ALC2IB:	MOVE	AC1,FMTSCT(I12)	;
	MOVEM	AC1,NEWBK1	;
	MOVE	AC0,ISPB(I12)	;NUMBER OF SECTORS PER INDEX BLOCK
	ADDM	AC0,FMTSCT(I12)	;UPDATE FIRST EMPTY SECTOR AVAILABLE
ALC1IB:	MOVE	AC1,FMTSCT(I12)	;
	MOVEM	AC1,NEWBK2	;
	MOVE	AC0,ISPB(I12)	;
	ADDM	AC0,FMTSCT(I12)	;
	TLO	FLG1,WSTB	;REMEMBER TO WRITE THE STATISTICS BLOCK
	POPJ	PP,
	;DECIDE WHERE TO SPLIT THE BLOCK
SPLTBK:	TLO	FLG1,BVN	;NOTE THE BLOCK WAS SPLIT
	PUSHJ	PP,SETLRW	;BUMP THE VERSION NUMBERS
	HRRZ	AC4,CNTRY(I12)	;
	SUBI	AC4,1		;ONE FOR HEADER WORD
	HRRZ	AC5,DBF(I12)	;DATA BLOCKING FACTOR
	LSH	AC5,-1		;2ND HALF GE 1ST HALF
	MOVE	AC11,DRTAB	;
	ADD	AC11,AC5	;BEG OF 2ND HALF
	MOVE	AC10,(AC11)	;
	CAIG	AC4,(AC10)	;NEWREC IN 2ND HALF?
	JRST	SPLT01		;NO

	;MAKE HEADER WORD FOR NEWREC
	TLO	FLG1,IIAB	;NOTE INSERTION IS IN AUX BUFFER
	ADDI	AC11,1		;MAKE 1ST HALF GE 2ND HALF
	LDB	AC2,WOPRS.	;NEWREC SIZE
	MOVEM	AC2,AC6		;FIRST PART OF HEADER WORD
	JUMPGE	FLG,SPLT03	;ASCII?
	ADDI	AC2,2		;<CRLF>
	ADDI	AC6,2		;<CRLF>
	LSH	AC6,1		;MAKE ROOM FOR BIT35
	TRO	AC6,1		;MAKE IT LOOK LIKE A SEQUENCE NUMBER
SPLT03:	MOVE	AC3,IOWRD(I12)	;GET VERSION NUMBER
	HLL	AC6,1(AC3)	;HEADER WORD = VERSION # ,, RECSIZ

	;HOW MANY WORDS IN NEWREC?
	IDIV	AC2,D.BPW(I16)	;
	JUMPE	AC3,.+2		;
	ADDI	AC2,1		;
	ADDI	AC2,1		;PLUS ONE FOR HEADER WORD

	;MOVE 1ST PART OF 2ND HALF TO AUXBUF
	HRL	AC0,(AC11)	;
	HRR	AC0,AUXBUF	;FROM ,, TO
	HRRZI	AC1,-1(AC4)	;
	HRRZ	AC3,(AC11)	;ADR OF FIRST REC-HDR TO GO IN AUXBUF
	SUB	AC1,AC3		;LENGTH OF FIRST PART
	HRRZM	AC1,TEMP.	;LEN OF PART BEFORE NEW-REC
	CAIGE	AC1,0		;IS NEW-REC FIRST IN AUXBUF?
	SETZM	TEMP.		;YES
	ADD	AC1,AUXBUF	;UNTIL
	BLT	AC0,(AC1)	;FIRST PART
	MOVEM	AC6,1(AC1)	;NEWREC HEADER WORD

	;MAKE ROOM FOR NEWREC & MOVE THE REST TO AUXBUF
	HRL	AC0,(AC11)	;
	HRR	AC0,AUXBUF	;
	SKIPE	AC6,TEMP.	;LEN OF FIRST PART
	ADDI	AC6,1		;
	HRL	AC6,AC6		;
	ADD	AC0,AC6		;SKIP OVER FIRST PART
	HLL	AC3,CNTRY(I12)	;BYTE-POINTER POSITION & SIZE
	HLLM	AC3,TEMP.2	;SAVE FOR MOVRBA
	HRRM	AC0,TEMP.2	;WHERE TO MAKE INSERTION IN AUXBUF
	AOS	TEMP.2		;
	ADD	AC0,AC2		;MAKE ROOM FOR NEWREC
	HRRZ	AC2,LRW(I12)	;
	HLRZ	AC1,AC0		;
	SUBM	AC2,AC1		;
	ADD	AC1,AC0		;UNTIL
	BLT	AC0,(AC1)	;MOVIT
	JRST	SPLT02

	;MOVE 2ND HALF OF CURRENT BLOCK TO AUXBUF
SPLT01:	HRL	AC0,(AC11)	;
	HRR	AC0,AUXBUF	;FROM,,TO
	HRRZ	AC1,LRW(I12)	;
	SUB	AC1,(AC11)	;LEN
	ADD	AC1,AC0		;UNTIL
	BLT	AC0,(AC1)	;
SPLT02:	HRRZM	AC1,LRWA	;LAST-REC-WRD FOR AUXBUF

	;ZERO THE REST OF AUXBUF
	HLRZ	AC2,IOWRD(I12)	;
	MOVE	AC0,AUXBUF	;
	SUBI	AC0,1(AC2)	;
	HRLI	AC1,1(AC1)	;
	HRRI	AC1,2(AC1)	;FROM ,,TO
	HRRZ	AC2,AC0		;UNTIL
	CAIGE	AC2,(AC1)	;IF UNTIL LESS THAN TO
	JRST	SPLT04		;  SKIP THE BLT
	SETZM	-1(AC1)		;ZERO THE FIRST WORD
	EXCH	AC0,AC1		;
	BLT	AC0,(AC1)	;

	;ZERO 2ND HALF OF CURRENT BLOCK
SPLT04:	HRRZ	AC2,(AC11)	;FIRST FREE DATA WRD LOC
	SUBI	AC2,1		;LRW
	HRRZI	AC0,2(AC2)	;
	CAMLE	AC0,LRW(I12)	;CHECK BLT POINTERS
	JRST	SPLT05		;FROM GE UNTIL
	HRLI	AC0,1(AC2)	;
	SETZM	1(AC2)		;
	EXCH	AC2,LRW(I12)	;
	BLT	AC0,(AC2)	;

SPLT05:	MOVE	AC1,@AUXBUF	;GET THE VERSION NUMBER
	HLLM	AC1,(AC10)	;  SO BLOCKING FACTOR OF 1 WILL WORK
	PUSHJ	PP,ALC2BK	;GET TWO BLKNO
	MOVE	AC1,NEWBK2	;
	EXCH	AC1,USOBJ(I12)	;GIVE NEW BLKNO TO CURRENT BUFFER
	MOVEM	AC1,OLDBK	;MARK OLD ONE FOR DE-ALLOCATION
	MOVE	AC0,NEWBK1	;
	HRRZM	AC0,AUXBNO	;GIVE 2ND NEW BLKNO TO AUXBUF

	TLZN	FLG1,IIAB	;INSERTION IN AUX BLOCK?
	JRST	IWRI01		;NO
	PUSHJ	PP,WWDBK		;WRITE A DATA BLOCK
	PUSHJ	PP,MOVRBA	;INSERT
	PUSHJ	PP,WABK		;WRITE AUXBUF
	PUSHJ	PP,MAUXD	;MOVE AUXBUF TO DATABUF
	HRRZM	AC1,LRW(I12)	;
	JRST	IWRI04		;

	;ROUTINE MOVES CONTENTS OF AUXBUF TO DATA OR INDEX BUFFER
	;UPDATES CNTRY AND USOBJ SO SEQ-READS WILL WORK
MAUXD:	MOVE	AC0,LRW(I12)	;
	HRRZM	AC0,TEMP.1	;LAST RECORD WORD
MAUXI:	MOVE	AC0,TEMP.2	;
	SUB	AC0,AUXIOW	;
	ADD	AC0,@IOWRD0(I12)  ;
	HRRM	AC0,@CNTRY0(I12)  ;CURRENTRY
	MOVE	AC0,AUXBNO	;
	MOVEM	AC0,@USOBJ0(I12)  ;USETO OBJECT
	MOVE	AC1,LRWA	;
	SUB	AC1,AUXIOW	;LENGTH
	ADD	AC1,@IOWRD0(I12)  ;UNTIL
	MOVE	AC0,@IOWRD0(I12)
	ADDI	AC0,1		;
	HRL	AC0,AUXBUF	;FROM,,TO
	HRRZ	AC3,TEMP.1	;
	CAIL	AC3,(AC1)	;ANY REMNANTS LEFT?
	HRRZM	AC3,AC1		;YES, COVER THEM UP WITH ZEROES
	BLT	AC0,(AC1)	;DOIT!
	POPJ	PP,

	;SAVE TOP INDEX ENTRY FOR THE NEW TOP INDEX BLOCK
SAVTIE:	MOVE	AC2,@IOWRD0(I12)  ;
	ADDI	AC2,1		;
	HRLI	AC2,4(AC2)	;
	HRR	AC2,IESAVE	;FROM,,TO
	MOVE	AC3,NEWBK2	;
	MOVEM	AC3,(AC2)	;BLOCK NUMBER FOR THIS LEVEL
	MOVE	AC3,@IOWRD0(I12)
	MOVE	AC3,2(AC3)	;
	MOVEM	AC3,1(AC2)	;VERSION OF CURRENT IDX BLOCK
	HRR	AC3,IESIZ(I12)	;
	ADD	AC3,-1(AC2)		;UNTIL
	ADDI	AC2,2		;WHERE THE KEY WILL GO
	BLT	AC2,(AC3)	;MOVIT
	POPJ	PP,
	;MAKE TWO COPIES OF SYMKEY
	;ADJUST ONE TO MATCH IDXKEY, &ONE TO RECKEY
ADJKEY:	MOVE	AC0,23(I16)	;SYMBOLIC KEY BP
	MOVE	AC1,DAKBP(I12)	;DATA ADJUSTED KEY POINTER
	HRRM	AC1,DKWCNT(I12)	;DATA KEY WRD CNT
	MOVE	AC2,IAKBP(I12)	;INDEX ADJUSTED KEY POINTER
	HRRM	AC2,IKWCNT(I12)	;-CNT,,FRST-WRD
	LDB	AC4,[POINT 12,KEYDES(I12),35]
ADJKE1:	ILDB	C,AC0		;SYMKEY
	TLNE	FLG,CONNEC	;CONVERSION NECESSARY?
	ADDI	C,40		;YES
	IDPB	C,AC1		;RECKEY
	IDPB	C,AC2		;IDXKEY
	SOJG	AC4,ADJKE1	;
	POPJ	PP,


	;CONVERT NUMERIC DISPLAY TO ONE/TWO WRD INTEGER
GD67:	MOVEI	AC0,ACSAV0	;
	BLT	AC0,ACSAV0+16	;
	MOVE	AC16,[Z AC2,GDPSK]  ;PARAMETER
	ADD	AC16,I12	;INDEX IT
	PUSHJ	PP,@GDX.(I12)	;CALL GD6. OR GD7.
	MOVEM	AC2,@IAKBP(I12)
	MOVEM	AC2,@DAKBP(I12)
	MOVEM	AC3,@IAKBP1(I12)
	MOVEM	AC3,@DAKBP1(I12)
	HRLZI	AC0,ACSAV0
	BLT	AC0,AC16
	POPJ	PP,


	;GET SET FOR ONE/TWO WRD INTEGER
FPORFP:	MOVE	AC1,23(I16)	;SYM-KEY
	MOVE	AC0,(AC1)	;
	MOVEM	AC0,@IAKBP(I12)
	MOVEM	AC0,@DAKBP(I12)
	MOVE	AC0,1(AC1)
	MOVEM	AC0,@IAKBP1(I12)
	MOVEM	AC0,@DAKBP1(I12)
	POPJ	PP,
	;DO THE BINARY SEARCH AGAIN, THERE WAS A VERSION NUMBER DISCREPANCY
	;ROUTINE CAUSES GETBLK TO REREAD INDEX/DATA BLOCKS FROM DSK
IBSTOP:	POP	PP,AC1		;CLEAR RETURN TO IBS+1
IBSTO1:	MOVN	AC1,MXLVL(12)	;NUMBER OF IOWD'S TO ZERO
	MOVEI	AC2,USOBJ(I12)	;ADR OF FIRST IOWD
	HRL	AC2,AC1		;FOR AOBJN
	SETZM	(AC2)		;
	AOBJN	AC2,.-1		;

	;BINARY SEARCH ROUTINE FOR THE INDEX BLOCKS

IBS:	PUSHJ	PP,GETOP	;GET THE TOP LEVEL INDEX BLOCK
	JRST	.+2

IBS0:	PUSHJ	PP,GETBLK	;GET THE BLOCK INTO CORE
	MOVE	AC5,SINC(I12)	;THE SEARCH INCREMENT
	HRRZ	AC4,@IOWRD0(I12)  ;
	SUB	AC4,IESIZ(I12)	;INITIALIZE AT ZEROTH ENTRY
	ADDI	AC4,3		;ADR OF FIRST WRD OF FRST ENTRY
	MOVE	AC6,IBLEN(I12)	;TABLE LEN
	ADD	AC6,AC4		;TABLE LIMIT

IBSGE:	LSH	AC5,-1		;HALF THE INC
	CAMGE	AC5,IESIZ(I12)	;BEGINNING OF TABLE?
	JRST	IBS100		;YES, DONE
	ADD	AC4,AC5		;CURRENT ENTRY PLUS INC
IBS2:	MOVE	AC10,AC4	;
	ADD	AC10,IESIZ(I12)	;
	SKIPE	(AC10)		;NULL ENTRY?
	CAMLE	AC10,AC6	;END OF TABLE?
	JRST	IBSLT		;YES, GO OTHER WAY

	PUSHJ	PP,@ICMP(I12)	;DO THE COMPARISON
	JRST	IBSLT		;KEY LT INDEX-KEY
	JFCL			;KEY = INDEX-KEY
	JRST	IBSGE		;KEY GT INDEX-KEY

IBSLT:	LSH	AC5,-1		;HALF THE INC
	CAMGE	AC5,IESIZ(I12)	;BEG OF TABLE?
	JRST	IBS10		;YES, DONE
	SUB	AC4,AC5		;CURRENT ENTRY MINUS INC
	JRST	IBS2		;

IBS100:	MOVE	AC4,AC10	;AC10 HAS ENTRY FROM GE
IBS10:	MOVEM	AC4,@CNTRY0(I12)  ;ADR OF CURRENT ENTRY
	SETZM	@NNTRY0(I12)	;SO 'SREAD' WILL WORK IF IT'S NEXT
	SOJG	LVL,IBS0	;GO AGAIN DOWN A LEVEL
	JRST	DSRCH		;LEVEL ZERO, EXIT SEARCH ROUTINE

	;INDEX DISPLAY NON-NUMERIC COMPARE
ICDNN:	MOVE	AC1,IKWCNT(I12)	;-CNT ,, ADR OF IAK
	MOVEI	AC2,2(AC10)	;INDEX ENTRY
ICDNN1:	MOVE	AC0,(AC2)	;INDEX ENTRY
	CAME	AC0,(AC1)	;SYM-KEY = IDX-KEY
	JRST	ICDNN2		;NOT EQUAL
	ADDI	AC2,1		;NEXT
	AOBJN	AC1,ICDNN1	;LOOP IF YOU CAN
	JRST	RET.2		;EQUAL RETURN
ICDNN2:	MOVE	AC3,(AC1)	;SYM-KEY
	TLC	AC0,1B18	;
	TLC	AC3,1B18	;
	CAMG	AC0,AC3		;
	JRST	RET.3		;SYM-KEY GT IDX-KEY
	JRST	RET.1		;SYM-KEY LT IDX-KEY


	;INDEX COMPARE ONE WORD SIGNED
IC1S:	MOVE	AC0,@IAKBP(I12)	;SYM-KEY
	CAMGE	AC0,2(AC10)	;
	JRST	RET.1		;SYM-KEY LT IDX-KEY
	CAME	AC0,2(AC10)	;
	JRST	RET.3		;SYM-KEY GT IDX-KEY
	JRST	RET.2		;SYM-KEY EQ IDX-KEY

	;TWO WORD SIGNED
IC2S:	MOVE	AC0,@IAKBP(I12)	;SYM-KEY
	CAMGE	AC0,2(AC10)	;
	JRST	RET.1		;SYM-KEY LT IDX-KEY
	CAME	AC0,2(AC10)	;
	JRST	RET.3		;SYM-KEY GT IDX-KEY
	MOVE	AC0,@IAKBP1(I12)  ;NEXT WRD
	CAMGE	AC0,3(AC10)	;
	JRST	RET.1		;SK LT IK
	CAME	AC0,3(AC10)	;
	JRST	RET.3		;SK GT IK
	JRST	RET.2		;SK EQ IK

	;ONE WORD UNSIGNED
IC1U:	MOVM	AC0,@IAKBP(I12)	;SK
	MOVM	AC1,2(AC10)	;IK
	CAMGE	AC0,AC1		;
	JRST	RET.1		;SK LT IK
	CAME	AC0,AC1		;
	JRST	RET.3		;SK GT IK
	JRST	RET.2		;SK EQ IK

	;TWO WORD UNSIGNED
IC2U:	MOVM	AC0,@IAKBP(I12)	;SK
	MOVM	AC1,2(AC10)	;IK
	CAMGE	AC0,AC1		;
	JRST	RET.1		;SK LT IK
	CAME	AC0,AC1		;
	JRST	RET.3		;SK GT IK
	MOVM	AC0,@IAKBP1(I12)	;
	MOVM	AC1,3(AC10)	;
	CAMGE	AC0,AC1		;
	JRST	RET.1		;SK LT IK
	CAME	AC0,AC1		;
	JRST	RET.3		;SK GT IK
	JRST	RET.2		;SK EQ IK
	;SEACH FOR A DATA FILE KEY 
DSRCH:	MOVE	AC0,(AC4)	;GET THE BLOCK NUMBER
	JUMPN	AC0,DSRCH1	;IS IT ZERO ?
	TLNN	AC16,WRITE	;YES, TAKE INVALID KEY EXIT
	JRST	RRDIV1
	JRST	IWIVK1		;NO


DSRCH1:	PUSHJ	PP,GETBLK	;
	PUSHJ	PP,SETLRW	;SETUP LRW, POINTER TO LAST FREE RECWRD
	LDB	AC6,FTBF.	;NUMBER OF RECS THIS BLK
	HRRZ	AC4,IOWRD(I12)	;
	ADDI	AC4,2		;FIRST WORD, FIRST REC
	LDB	AC1,RSBP(I12)	;RECSIZ IN CHARS
	IDIV	AC1,D.BPW(I16)	;
	JUMPE	AC2,.+2		;
	ADDI	AC1,1		;
	JUMPE	AC1,DSNUL	;EXIT HERE IF DATA BLOCK IS EMPTY
	MOVEI	AC5,1(AC1)	;RECSIZ IN WRDS PLUS ONE
	ADDI	AC5,-1(AC4)	;5 POINTS AT NEXT RECSIZ WRD
	TLNE	FLG1,SEQ	;A SEQUENTIAL READ?
	POPJ	PP,		;YES, EXIT HERE

DSLOOP:	ADD	AC4,24(I16)	;FIRST KEY,FIRST REC
	MOVE	AC10,AC4	;
	PUSHJ	PP,@DCMP(I12)	;
	 JRST	DSLT		;
	 JRST	DSEQ		;

DSGT:	HRRZI	AC4,1(AC5)	;FIRST WRD NEXT REC
	SOJE	AC6,DSGT03	;EXIT IF NO ROOM FOR MORE RECORDS
	LDB	AC1,RSBP(I12)	;RECSIZ IN CHARS
	IDIV	AC1,D.BPW(I16)	;
	JUMPE	AC2,.+2		;
	ADDI	AC1,1		; IN WORDS
	MOVEI	AC5,1(AC1)	;RECSIZ INWORDS PLUS ONE
	ADDI	AC5,-1(AC4)	;5 POINTS AT NEXT RECSIZ WORD
	SKIPE	-1(AC4)		;SKIP IF APPENDING TO THE RECS IN THIS BLK
	JRST	DSLOOP		;
DSGT01:	HRRZI	AC4,(AC5)
	TLNN	AC16,WRITE	;LAST REC & NOT FOUND
	JRST	RRDIVK		;READ, RERIT, DELET INVALID-KEY
	JRST	DSXIT1		;THIS WILL BE THE LAST RECORD IN THIS BLOCK
DSGT03:	AOJA	AC5,DSGT01	;CNTRY MUST POINT AT RECORD NOT HEADER

DSEQ:	TLNE	AC16,WRITE	;
	JRST	IWIVK		;WRITE INVALID-KEY
DSXIT:	SUB	AC4,24(I16)	;
DSXIT1:	MOVEM	AC4,CNTRY(I12)	;
	SETZM	NNTRY(I12)	;SO SREAD WILL GET "NEXT" RECORD
	POPJ	PP,

DSLT:	TLNE	AC16,WRITE	;
	JRST	DSXIT		;NORMAL IWRITE EXIT
	SUB	AC4,24(I16)	;
	JRST	RRDIVK		;READ, RERIT, DELETE INVALID-KEY

	;NO RECORDS IN THIS DATA BLOCK
DSNUL:	TLNE	AC16,WRITE	;
	JRST	DSXIT1
	JRST	RRDIVK
	;CALL IS:  PUSHJ PP,@DCMP(I12)
	;CONVERT NUMERIC DISPLAY TO 1 OR 2 WRD INTEGER
DGD67:	MOVE	AC0,[XWD AC4, ACSAV0+4]  ;
	BLT	AC0,ACSAV0+16	;SAVE ACS
	HRRM	AC10,GDPRK(I12)  ;POINT AT CURRENT DATA KEY
	MOVE	AC16,[Z AC2,GDPRK]  ;PARAMETER
	ADD	AC16,I12	;INDEX IT
	PUSHJ	PP,@GDX.(I12)	;CONVERT, GD6. OR GD7.
	MOVE	AC0,[XWD ACSAV0+4, AC4]  ;
	BLT	AC0,AC16	;
	MOVEI	AC10,2		;POINT AT CONVERTED DATA
	JRST	@DCMP1(I12)	;OFF TO COMPARISION ROUTINE

	;DATA DISPLAY NON-NUMERIC COMPARE
DCDNN:	MOVE	AC1,DKWCNT(I12)	;-CNT ,, DAKBP
	MOVE	AC0,FWMASK(I12)	;FIRST WRD MASK
	JUMPE	AC0,DCDNN2	;JUMP ONLY ONE WRD
	AND	AC0,(AC10)	;REC-KEY
	JRST	.+2
DCDNN1:	MOVE	AC0,(AC10)	;REC-KEY
	CAME	AC0,(AC1)	;
	JRST	DCDNN3		;NOT EQ
	ADDI	AC10,1		;NEXT
	AOBJN	AC1,DCDNN1	;
DCDNN2:	MOVE	AC0,LWMASK(I12)	;LAST WRD MASK
	AND	AC0,(AC10)	;
	CAMN	AC0,(AC1)	;
	JRST	RET.2		;SYM-KEY EQ REC-KEY
DCDNN3:	MOVE	AC3,(AC1)	;
	TLC	AC0,1B18	;
	TLC	AC3,1B18	;
	CAMG	AC0,AC3		;
	JRST	RET.3		;SYM-KEY GT REC-KEY
	JRST	RET.1		;SYN-KEY LT REC-KEY

	;DATA, ONE WRD SIGNED
DC1S:	MOVE	AC0,@DAKBP(I12)	;
	CAMGE	AC0,(AC10)	;
	JRST	RET.1		;SK LT RK
	CAME	AC0,(AC10)	;
	JRST	RET.3		;SK GT RK
	JRST	RET.2		;SK EQ RK

	;DATA, TWO WRD SIGNED
DC2S:	MOVE	AC0,@DAKBP(I12)	;
	CAMGE	AC0,(AC10)	;
	JRST	RET.1		;SK LT RK
	CAME	AC0,(AC10)	;
	JRST	RET.3		;SK GT RK
	MOVE	AC0,@DAKBP1(I12);
	CAMGE	AC0,1(AC10)	;
	JRST	RET.1		;SK LT RK
	CAME	AC0,1(AC10)	;
	JRST	RET.3		;SK GT RK
	JRST	RET.2		;SK EQ RK

	;DATA, ONE WRD UNSIGNED
DC1U:	MOVM	AC0,@DAKBP(I12)	;
	MOVM	AC1,(AC10)	;
	CAMGE	AC0,AC1		;
	JRST	RET.1		;SK LT RK
	CAME	AC0,AC1		;
	JRST	RET.3		;SK GT RK
	JRST	RET.2		;SK EQ RK

	;DATA, TWO WRD UNSIGNED
DC2U:	MOVM	AC0,@DAKBP(I12)	;
	MOVM	AC1,(AC10)	;
	CAMGE	AC0,AC1		;
	JRST	RET.1		;SK LT RK
	CAME	AC0,AC1		;
	JRST	RET.3		;SK GT RK
	MOVM	AC0,@DAKBP1(I12);
	MOVM	AC1,1(AC10)	;
	CAMGE	AC0,AC1		;
	JRST	RET.1		;SK LT RK
	CAME	AC0,AC1		;
	JRST	RET.3		;SK GT RK
	JRST	RET.2		;SK EQ RK
	;GET A BLOCK, MAYBE THE TOP-BLOCK & CHECK VERSION NOS
GETOP:	MOVE LVL,MXLVL(I12)	;NOTE ITS TOP LVL
	SKIPA	AC1,TOPIBN(I12)	;THE BLOCK NO.

GETBLK:	MOVE	AC1,(AC4)	;NEXT BLKNO
	MOVE	AC2,@IOWRD0(I12)  ;CURRENT IOWRD
	MOVEM	AC2,CMDLST	;SET THE IOWD
	CAMN	AC1,@USOBJ0(I12)  ;IN CORE?
	JRST	GETB0A		;YES
GETB0E:	JUMPE	LVL,GETB0C	;JUMP IF DATA FILE
	XCT	ISETI		;INDEX FILE
	XCT	IIN		;[IN CH,CMDLST]
	SKIPA	AC2,2(AC2)	;GET NEW VERSION NO.
	  JRST	IINER		;INPUT ERROR
GETB0D:	MOVEM	AC1,@USOBJ0(I12)  ;BLKNO TO USOBJ(I12)
	SKIPE	LVL		;DATA BLOCK ALWAYS HAS VERSION NO.
	CAME	AC1,TOPIBN(I12)	;TOPBLOCK HAS NO VERSION NO.
	CAMN	AC2,1(AC4)	;SAME VERNO?
	POPJ	PP,		;YES
	JRST	GETB0B		;VERSION ERROR

GETB0A:	TLNE	FLG1,RIVK!VERR	;FORCE INPUT?
	JRST	GETB0E		;YEP
	JUMPE	LVL,GETB0F	;LEVEL 0 IS A DATA FILE
	MOVE	AC2,2(AC2)	;
	CAME	AC1,TOPIBN(I12)	;TOP-BLOCK HAS NO VERNO
	CAMN	AC2,1(AC4)	;
	POPJ	PP,

GETB0B:	TLNE	FLG1,SEQ	;SEQ READ?
	JRST	UDVERR		;SPECIAL CASE
	TLON	FLG1,VERR	;FIRST OR SECOND ERROR?
	JRST	IBSTOP		;FIRST, SO TRY AGAIN
GETB0G:	TTCALL	3,[ASCIZ /VERSION NUMBER DISCREPANCY /]
	JRST	IINER2		;

GETB0C:	SKIPN	LIVE(I12)	;MUST BLOCK BE OUTPUT?
	JRST	GETB1C		;NO
	PUSHJ	PP,WWDBK	;YES--DOIT
	JRST	GETBLK		;
GETB1C:	XCT	USETI.	
	HRRI	AC0,CMDLST
	HRRM	AC0,UIN.
	XCT	UIN.
GETB0F:	SKIPA	AC2,1(AC2)
	 JRST	UINER
	HLLZS	UIN.
	HLRZS	AC2		;VERSION NO TO RIGHT HALF
	TRZ	AC2,-100	;CLEAR OUT THE FILE FORMAT INFO
	JRST	GETB0D

	;MARK THIS BLOCK SO IT WILL BE OUTPUT
WDBK:	SETOM	LIVE(I12)	;MARK IT
	SKIPE	BRISK(I12)	;SKIP IS SLOW BUT SAFE
	POPJ	PP,
	;WRITE A DATA BLOCK
WWDBK:	MOVE	AC1,USOBJ(I12)	;
	MOVE	AC0,IOWRD(I12)	;
WWDBK1:	MOVEI	AC2,CMDLST	;
	HRRM	AC2,UOUT.	;
	MOVEM	AC0,CMDLST	;
	SETZM	LIVE(I12)	;CLEAR THE LIVE FLAG
	AOS	IOUUOS(I12)	;
	XCT	USETO.		;
	XCT	UOUT.		;
	JRST	.+2		;
	JRST	UOUTER		;OUTPUT ERROR
	HLLZS	UOUT.		;
	POPJ	PP,

	;WRITE AN INDEX BLOCK
WIBK:	MOVE	AC1,@USOBJ0(I12)
	MOVE	AC0,@IOWRD0(I12)
WIBK1:	MOVEM	AC0,CMDLST	;
	AOS	IOUUOS(I12)	;
	XCT	ISETO		;
	XCT	IOUT		;
	POPJ	PP,		;
	JRST	IOUTER		;

	;WRITE A SAT BLOCK
WSBK:	MOVE	AC1,USOBJ+13(I12)
	MOVE	AC0,IOWRD+13(I12)
	JRST	WIBK1		;

	;WRITE AUXILARY BLOCK
WABK:	MOVE	AC1,AUXBNO
	MOVE	AC0,AUXIOW
	HLL	AC0,IOWRD(I12)
	JUMPE	LVL,WWDBK1
	HLL	AC0,IOWRD+1(I12)
	JRST	WIBK1

	;WRITE STATISTICS BLOCK
WSTBK:	MOVEI	AC1,1
	MOVE	AC0,IOWRD+14(I12)
	JRST	WIBK1

	;READ A SAT BLOCK
RSBK:	MOVEM	AC1,USOBJ+13(I12)
	MOVE	AC2,IOWRD+13(I12)
	MOVEM	AC2,CMDLST
	AOS	IOUUOS(I12)
	XCT	ISETI
	XCT	IIN
	POPJ	PP,
	JRST	IINER
	;MOVE BUFFER TO RECORD  (READ)
MOVBR:	LDB	AC0,FTMRS.	;MAX-REC-SIZ
	MOVE	AC6,RECBP(I12)	;REC BYTE-POINTER
	MOVE	AC4,CNTRY(I12)	;POINTE TO DATA
	HRRZ	AC3,-1(AC4)
	TLNN	FLG,DDMASC	;ASCII ?
	JRST	MOVBR1		;NO
	LSH	AC3,-1		;
	SUBI	AC3,2		;<CRLF>
MOVBR1:	ANDI	AC3,7777
	CAMGE	AC0,AC3
	JRST	ERRMR1
	TLNN	FLG,CONNEC!DDMASC!DDMBIN!DDMEBC
	JRST	BLTBR		;SIXBIT, BLTIT
	PUSHJ	PP,WRTXCT	;SET AC10
	HRLI	AC4,(POINT 7,)	;

MOVB0A:	ILDB	C,AC4
	XCT	AC10
	JUMPLE	C,MOVB0A	;IGNOR LEADING EOLS & NULLS
MOVB0B:	IDPB	C,AC6
	SOJE	AC3,RET.1
	ILDB	C,AC4
	XCT	AC10
	JUMPGE	C,MOVB0B	;MOVE THE RECORD
	MOVEI	C,40
	TLNN	FLG,CDMASC
	MOVEI	C,0
	IDPB	C,AC6
	SOJG	AC3,.-1		;FILL WITH SPACES
	POPJ	PP,

	;BLT BUFFER TO RECORD
BLTBR:	HRRZ	AC1,-1(AC4)	;RECSIZ
	;ANDI	AC1,7777
	IDIVI	AC1,6		;IN WORDS
	JUMPE	AC2,.+2
	ADDI	AC1,1
	HRLI	AC0,(AC4)	;FROM
	HRR	AC0,AC6		;TO
	ADDI	AC1,-1(AC6)	;UNTIL
	BLT	AC0,(AC1)	;ZRAPPP!
	POPJ	PP,
	;MOVE RECORD TO AUXBUF  (WRITE)
MOVRBA:	SKIPA	AC5,TEMP.2	;POINTER TO AUXBUF

	;MOVE RECORD TO BUFFER
MOVRB:	MOVE	AC5,CNTRY(I12)	;POINTER TO BUFFER
	LDB	AC0,FTMRS.	;MAX-REC-SIZ
	MOVE	AC6,RECBP(I12)	;REC BYTE-POINTER
	LDB	AC3,WOPRS.	;
	CAMGE	AC0,AC3		;IS RECORD LEGAL SIZE?
	JRST	ERRMRS		;NO
	TLNN	FLG,CONNEC!DDMASC!DDMBIN!DDMEBC
	JRST	BLTRB		;SIXBIT - BLTIT
	PUSHJ	PP,WRTXCT	;SET AC10
	HRLI	AC5,(POINT 7,)	;

MOVR0A:	ILDB	C,AC6		;
	XCT	AC10		;
	IDPB	C,AC5		;
	SOJG	AC3,MOVR0A	;
	JUMPGE	FLG,RET.1	;IF NOT ASCII EXIT
	PUSHJ	PP,RANCR	;
	JRST	RANLF		;<CRLF> AND EXIT

BLTRB:	MOVE	AC1,AC3		;DONT DESTRY 4
	IDIVI	AC1,6		;
	JUMPE	AC2,.+2		;
	ADDI	AC1,1		;
	HRLI	AC0,(AC6)	;FROM
	HRRI	AC0,(AC5)	;TO
	ADDI	AC1,-1(AC5)	;UNTIL
	BLT	AC0,(AC1)	;
	POPJ	PP,
	;IWRITE - SO MAKE HOLE FOR REC TO FIT IN
SHFHOL:	SETZ	AC3,		;FAKE AN OLD SIZE OF ZERO
	LDB	AC1,WOPRS.	;NEW-SIZ
	JUMPGE	FLG,.+2		;ASCII REC?
	ADDI	AC1,2		;YES, ACCOUNT FOR <CRLF>
	MOVE	AC4,CNTRY(I12)	;POINT AT CURRENT REC
	JRST	SHFR10		;

	;SHUFFLE RECORDS SO NEXT RECORD WILL JUST FIT
SHFREC:	MOVE	AC4,CNTRY(I12)	;CURRENT REC
	LDB	AC1,RSBP(I12)	;OLD RECSIZ IN CHARS
	LDB	AC3,WOPRS.	;NEW RECSIZ IN CHARS
	JUMPGE	FLG,SHFR03	;
	ADDI	AC3,2		;ASCII AND WRITE OR RERIT, ADD 2 FOR <CRLF>
SHFR03:	TLNE	AC16,DELET	;DELET?
	JRST	SHFR04		;YES
	CAMN	AC3,AC1		;SAME SIZE ?
	POPJ	PP,		;YES

SHFR04:	IDIV	AC1,D.BPW(I16)	;
	JUMPE	AC2,.+2		;
	ADDI	AC1,1		;
	ADDI	AC1,1		;
	EXCH	AC1,AC3		;AC3 = OLD SIZ IN WRDS

SHFR10:	TLNE	AC16,DELET	;DELETING?
	JRST	SHFR20		;YES
	TLNN	AC16,WADV!WRITE	;IWRITE GETS A COMPLETE NEW HEADER WRD
	DPB	AC1,RSBP(I12)	;UPDATE RECSIZ
	IDIV	AC1,D.BPW(I16)	;
	JUMPE	AC2,.+2		;
	ADDI	AC1,1		;
	ADDI	AC1,1		;AC1 = NEW SIZ IN WRDS

	SUB	AC1,AC3		;AC1 = DIFF
SHFR11:	ADDM	AC1,LRW(I12)	;UPDATE LRW
	HRRO	AC2,LRW(I12)	;
	SKIPLE	D.RCL(I16)	;LAST REC THIS BLOCK?
	SETZM	1(AC2)		;NO, MAKE ZERO NEXT REC SIZ
	JUMPL	AC1,SHFR01	;BLTIT - MAKE A SMALLER HOLE

	SUB	AC2,AC1		;FROM
	HRRZ	AC0,AC2		;
	SUBI	AC0,-1(AC4)	;LEN + OLD-REC-SIZ
	SUB	AC0,AC3		;LEN
	JUMPE	AC0,RET.1	;ZERO = OLD-REC IS LAST-REC
	ADDI	AC0,1		;MOVE THE HEADER WRD ALSO

	;AC0=LEN,  AC1=DISPLACEMENT,  AC2=-1,,FROM
SHFR00:	MOVE	AC4,AC1	;POPIT - MAKE LARGER
	ADD	AC4,[POP AC2,(AC2)]
	MOVE	AC5,[SOJG AC0,AC4]
	HRLI	AC6,(POPJ PP,)
	JRST	AC4

	;SHRINK THE OLD RECORD SIZE
SHFR01:	ADDI	AC3,-1(AC4)	;FROM
	HRL	AC3,AC3		;FROM,AC3		;FROM,,FROM
	ADD	AC3,AC1		;FROM,,TO
	MOVE	AC1,LRW(I12)	;UNTIL
	BLT	AC3,(AC1)	;
	POPJ	PP,

	;SETUP TO DELETE A REC
SHFR20:	MOVNI	AC1,(AC3)	;RECSIZ + HEADER
	ADDM	AC1,LRW(I12)	;UPDATE LRW
	SETOM	NNTRY(I12)	;NOTE: CNTRY POINTS AT NEXT ENTRY
	PUSHJ	PP,SHFR01	;MOVIT
	HRRZ	AC2,LRW(I12)
	SETZM	1(AC2)		;ZERO RECSIZ MEANS END OF DATA
	POPJ	PP,
	;SET POINTER TO LAST FREE RECORD WORD
SETLRW:	LDB	AC6,FTBF.	;NUMBER OF RECS PER BLOCK
	HRRZ	AC4,IOWRD(I12)	;
	ADDI	AC4,1		;POINT AT REC-CNT
	HRRZ	AC5,D.BPW(I16)	;BYTES PER WORD
	MOVE	AC11,DRTAB	;WHERE TO STORE REC-ORIGN
	SUBI	AC11,1		;SET UP FOR PUSH
	HLRZ	AC0,(AC4)	;VERSION NUMBER
	ADDI	AC0,1		;  BUMP IT
SETLR1:	LDB	AC1,RSBP1(I12)	;RECSIZ IN CHARS
	JUMPE	AC1,SETLR2	;ZERO RECSIZ IMPLIES LAST REC
	IDIV	AC1,AC5		;
	JUMPE	AC2,.+2		;
	ADDI	AC1,1		;IN WORDS
	HRL	AC3,AC1		;RECNT IN WORDS
	HRR	AC3,AC4		;LOC OF REC-ORIGN
	PUSH	AC11,AC3		;PUSH IT IN THE DR-TABLE
	TLNE	FLG1,BVN	;SPLITTING?
	DPB	AC0,[POINT 6,(AC4),17]	;VERSION NUMBER IS SIX BITS WIDE
	ADDI	AC4,1(AC1)	;PLUS ONE FOR RECSIZ
	SOJG	AC6,SETLR1	;MORE RECORDS?
SETLR2:	MOVEM	AC6,D.RCL(I16)	;NO, ROOM FOR <N> RECS
	HRROM	AC4,AC3		;TERMINATOR (-1,,LRW+1)
	PUSH	AC11,AC3	;
	SUBI	AC4,1		;
	MOVEM	AC4,LRW(I12)	;SAVIT
	POPJ	PP,

	;SET THE INDEX CHANNEL NUMBER
SETIC:	HLRZ	I12,D.BL(I16)	;INDEX TABLE
	MOVE	LVL,MXLVL(I12)	;SET LVL TO TOP-LEVEL
	MOVE	AC5,ICHAN(I12)	;
	MOVEI	AC10,LASTIC	;
	MOVE	AC1,[POINT 4,FRSTIC,12]
	DPB	AC5,AC1		;
	CAIE	AC10,(AC1)	;
	AOJA	AC1,.-2	;
	POPJ	PP,		;

	;ALLOCATE DATA BLOCKS HERE
	;BLOCK NUMBER IS RETURNED IN NEWBK1 & NEWBK2
ALC2BK:	TLO	FLG1,BLK2	;REMEMBER TO GRAB 2 BLOCKS
	MOVE	AC2,IOWRD+13(I12)  ;
	ADD	AC2,[XWD 2,2]	;
	HRRZM	AC2,TEMP.	;FIRST WORD OF SAT BITS
	SKIPE	USOBJ+13(I12)	;IS THERE A SAT BLK INCORE?
	JRST	ALC05		;YES
ALC01:	TLZE	FLG1,WSB	;SHLD SAT BLK BE WRITTEN?
	PUSHJ	PP,WSBK		;YES
	MOVE	AC1,SBLOC(I12)	;LOC OF FIRST SAT BLK
ALC02:	PUSHJ	PP,RSBK		;GET A SAT BLK

	;NOW FIND A WORD WITH SOME EMPTY BLOCKS IN IT
	ADD	AC2,[XWD 2,2]	;FIRST WORD OF SAT BITS
	HRRZM	AC2,TEMP.	;FIRST-WRD SAVE FOR LATER
ALC05:	HRROI	AC0,-1		;WHAT WERE NOT LOOKING FOR
	CAMN	AC0,(AC2)	;ANY FREE BLOCKS?
	AOBJN	AC2,.-1		;NO, LOOP IF MORE WORDS
	CAME	AC0,(AC2)	;WHAT WAS IT?
	JRST	ALC07		;FOUND A BLOCK!

	;THAT BLOCK WAS FULL, TRY NEXT ONE
	TLNN	FLG1,TRYAGN	;HAVE WE LOOKED FROM THE BEGINNING?
	JRST	ALC20		;NO, SO DOIT
	MOVE	AC0,SBLOC(I12)	;LOC OF FIRST SAT BLOCK
	ADD	AC0,SBTOT(I12)	;NUMBER OF SAT BLOCKS
	SUBI	AC0,1		;
	CAMG	AC0,USOBJ+13(I12)  ;IS THERE A NEXT ONE?
	JRST	ALC20		;NO, TRY AGAIN, SEE IF ANY WERE DELETED
	TLZE	FLG,WSB		;WRITE OUT THE SAT-BLK?
	PUSHJ	PP,WSBK		;YES
	AOS	AC1,USOBJ+13(I12)
	JRST	ALC02		;YES, TRY NEXT SAT BLOCK

	;FOUND A BLK - FLAG IT IN USE
ALC07:	SETCM	AC0,(AC2)	;SO JFFO WILL WORK
	JFFO	AC0,ALC08	;FIND THE BIT
	JRST	ALC05		;TRY NEXT WORD
ALC08:	MOVSI	AC0,400000	;
	MOVNS	AC1		;
	LSH	AC0,(AC1)	;
	ORM	AC0,(AC2)	;FLAG IT IN USE
 	;OK - WHATS THE BLOCK NUMBER?
	HRRZ	AC0,AC2		;
	SUB	AC0,TEMP.	;
	IMULI	AC0,^D36	;
	SUBI	AC0,-1(AC1)	;
	MOVE	AC1,USOBJ+13(I12)
	SUB	AC1,SBLOC(I12)	;
	IMUL	AC1,BPSB(I12)	;
	ADD	AC0,AC1		;AC0 HAS THE LOGICAL BLKNO
	MOVE	AC1,D.BPL(I16)	;BUFFERS PER LOGICAL BLOCK
	SUBI	AC0,1		;MINUS ONE
	IMUL	AC0,AC1		;TIMES LOGICAL-BLOCK NUMBER
	ADDI	AC0,1		;  IS USETO OBJECT

	TLO	FLG1,WSB	;REMEMBER TO WRITE THE SAT BLOCK
	HRRZM	AC0,NEWBK1	;SAV THE FIRST BLKNO
	TLZN	FLG1,BLK2	;A TWO BLOCK REQ?
	JRST	WSBK		;ALLOCATE! WRITE OUT THE SAT BLOCK
	HRRZM	AC0,NEWBK2	;
	JRST	ALC07		;GO FOR NEXT ONE

	;START AT BEGINNING AND SEE IF ANY WERE DELETED
ALC20:	TLON	FLG1,TRYAGN	;FIRST RETRY?
	JRST	ALC01		;YES, TRY AGAIN
	TTCALL	3,[ASCIZ /ALLOCATION FAILURE, ALL BLOCKS ARE IN-USE/]
	JRST	IOUTE1		;& KILL.

	;DE-ALLOCATE BLOCK NUMBER FOUND IN OLDBK
DALC:	MOVE	AC1,OLDBK	;
	IDIV	AC1,D.BPL(I16)	;CONVERT PHYSICAL TO LOGICAL BLKNO
	SKIPE	AC2		;REMAINDER?
	ADDI	AC1,1		;YEP
	IDIV	AC1,BPSB(I12)	;FIND WHICH RELATIVE SATBLK IT'S IN
	ADD	AC1,SBLOC(I12)	;ABSOLUTE
	MOVEM	AC2,AC3		;SAVE RELATIVE BIT POSITION IN SATBLK
	CAME	AC1,USOBJ+13(I12)  ;IS IT IN CORE?
	PUSHJ	PP,RSBK		;NO,GO GET IT
	MOVEM	AC1,USOBJ+13(I12)  ;MAKE THIS BLK CURRENT
	IDIVI	AC3,^D36	;RELATIVE WORD POSITION
	ADD	AC3,IOWRD+13(I12)  ;ABSOLUTE WORD POSITION -2
	MOVN	AC4,AC4		;ROTATE TO THE RIGHT
	MOVEI	AC0,1		;THE MASK
	ROT	AC0,(AC4)	;
	SKIPN	AC4		;IF REMAINDER = 0
	SUBI	AC3,1		;  BACKUP A WORD
	ANDCAM	AC0,2(AC3)	;MARK IT FREE
	TLZ	FLG1,WSB
	SETZM	OLDBK		;
	JRST	WSBK
	;SETUP RECORD HEADER WORD
SRHW:	MOVE	AC4,CNTRY(I12)
	MOVE	AC1,IOWRD(I12)
	MOVE	AC1,1(AC1)
	MOVEM	AC1,-1(AC4)	;SET VERSION NUMBER & BIT35
	LDB	AC1,WOPRS.
	JUMPGE	FLG,SRHW1	;ASCII?
	ADDI	AC1,2		;ADD 2 FOR CR + LF
	MOVEI	AC0,1		;ASCII FLAG, BIT 35
	ORM	AC0,-1(AC4)	;
SRHW1:	DPB	AC1,RSBP(I12)	;THE RECORD SIZE IN CHARS
	POPJ	PP,

	;LOW-VALUE TEST
	;POPJ IF SYMKEY = LOW-VALUES, SKIP EXIT IF NOT
LVTST:	HLRZ	I12,D.BL(I16)	;SETUP I12
	MOVE	AC1,23(I16)	;RK BYTE-POINTER
	LDB	AC3,[POINT 3,KEYDES(I12),23]	;TYPE
	CAIGE	AC3,3		;DISPLAY ?
	JRST	LVTS02		;YES

LVTS01:	CAIG	AC3,4		;FIXED POINT ?
	SKIPA	AC2,[1B0]	;YES, LOW-VALUE
	MOVE	AC2,[1B0+1]	;FLOATING PT. LOW-VALUE
	CAME	AC2,(AC1)	;LOW-VALUE ?
	JRST	RET.2		;NO
	TRNE	AC3,1		;TWO WORDS ?
	POPJ	PP,		;NO, EXIT
	CAME	AC2,1(AC1)	;LV ?
	JRST	RET.2		;NO
	POPJ	PP,		;LV.

LVTS02:	LDB	AC2,[POINT 12,KEYDES(I12),35]	;SIZE
LVTS03:	ILDB	AC0,AC1
	JUMPN	AC0,RET.2	;NOT LV
	SOJG	AC2,LVTS03
	POPJ	PP,		;LOW-VALUE

	;ENTRY FOR INDEX-KEY LOW-VALUE TEST
LVTSTI:	ADDI	AC1,2		;SKIP OVER THE TWO WORD HEADER
	LDB	AC3,[POINT 3,KEYDES(I12),23]
	JUMPE	AC3,LVTS02	;DISPLAY EXITS HERE
	JRST	LVTS01		;NUMERIC DISPLAY IS NUMERIC IN THE INDEX
	;INDEX FILE INPUT ERROR
IINER:	XCT	IGETS		;GET STATUS TO AC2
	TRNE	AC2,20000	;EOF?
	TTCALL	3,[ASCIZ /FOUND AN EOF INSTEAD OF INDEX BLOCK/]
	TRNN	AC2,20000	;EOF?
	MOVE	LVL,D.DC(I16)	;DEV CHARACTERISTICS
	PUSHJ	PP,IOERM1	;NO, CHECK THE OTHERS
IINER2:	MOVE	AC2,[BYTE (5)10,31,20,21,4]
	PUSHJ	PP,MSOUT.	;FILE CANNOT DO INPUT & KILL.

	;DATA FILE INPUT ERROR
UINER:	XCT	UGETS.		;ERROR BITS
	TRNE	AC2,20000	;EOF?
	TTCALL	3,[ASCIZ /FOUND AN EOF INSTEAD OF DATA BLOCK/]
	MOVEM	LVL,CLVL(I12)	;SAVE THE LEVEL
	MOVE	LVL,D.DC(I16)	;DEV-CHAR
	TRNN	AC2,20000	;EOF?
	PUSHJ	PP,IOERM1	;NO, CHECK OTHER BITS
	TRZ	AC2,760000	;
	XCT	USETS.		;RESTORE THE STATUS
	MOVE	AC2,[BYTE (5)10,31,20,21,4,14]
	PUSHJ	PP,MSOUT.	;FILE CANNOT DO INPUT
	MOVEI	AC1,0		;ERROR USEPRO
	PUSHJ	PP,USEPRO	;DOIT
	SKIPA	LVL,CLVL(I12)	;RESTORE LVL
	JRST	KILL.		;NO USEPRO
	POP	PP,AC0		;RET FROM IBS
	POP	PP,AC0		;RET FROM READ.
	POPJ	PP,		;RET TO USER

LVSKER:	TLNE	AC16,RERIT
	TTCALL	3,[ASCIZ /REWRITE, /]
	TLNE	AC16,DELET
	TTCALL	3,[ASCIZ /DELETE, /]
	TLNE	AC16,WRITE
	TTCALL	3,[ASCIZ /WRITE, /]
	TTCALL	3,[ASCIZ /SYMBOLIC-KEY MUST NOT EQUAL LOW-VALUES/]
	HRLZI	AC2,(BYTE (5) 10,31,20)
	PUSHJ	PP,MSOUT.	;KILL. & DON'T RETURN

	;INDEX FILE OUTPUT ERROR
IOUTER:	XCT	IWAIT
	XCT	IGETS
	TRNN	AC2,740000
	POPJ	PP,		;NO ERRORS SO EXIT
	MOVE	LVL,D.DC(I16)	;DEV-CHAR
	PUSHJ	PP,IOERM1
IOUTE1:	MOVE	AC2,[BYTE (5) 10,31,20,22,4]
	PUSHJ	PP,MSOUT.	;& KILL.

	;DATA FILE OUTPUT ERROR
UOUTER:	XCT	UWAIT.
	XCT	UGETS.
	TRNN	AC2,740000
	POPJ	PP,		;NO ERRORS SO EXIT
	MOVE	AC2,[BYTE (5) 36,31,20,10,4,14]
	PUSHJ	PP,MSOUT.	;"OUTPUT ERROR ON <DEV><FILE>
	MOVEM	LVL,CLVL(I12)	;SAVE THE LEVEL	;

	MOVE	LVL,D.DC(I16)
	PUSHJ	PP,IOERMS
	MOVEI	AC1,0		;ERROR USE-PROCEDURE
	PUSHJ	PP,USEPRO
	SKIPA	LVL,CLVL(I12)	;RESTORE LVL
	JRST	KILL.		;KILL. IF NO USE-PRO
	POPJ	PP,		;TO THE USER

>
SUBTTL	RERUN-DUMP-CODE
	;SCAN FOR AN OPEN RANDOM IO FILE
RRDMP:	PUSHJ	PP,SAVAC.	;SAVE AC'S
	MOVE	AC15,REDMP.	;SAVE THE "FORCE-DUMP" FLAG
	SETZB	AC0,REDMP.	;CLEAR THE "FORCE-DUMP" FLAG
	SKIPN	OVRFN.		;IF OVERLAY FILE IS OPEN
	JRST	RRDMP6		;
	PUSHJ	PP,RRERR0	;    ABORT -- CHANNEL 0 IS IN USE
	TTCALL	3,[ASCIZ/ OVERLAY/]
	JRST	RRDMP9		;

RRDMP6:	CALLI	AC0,51		;SYSPHY UUO ;XIT IF LEVEL C
	JRST	RSTAC1		;EXIT
	HRRZ	AC16,FILES.	;POINT TO FIRST FILE TABLE
	SKIPA
RRDMP1:	HRRZ	AC16,6(I16)	;POINTER TO NEXT FILE-TABLE
	JUMPE	AC16,RRDMP2	;
	MOVE	AC13,D.DC(I16)	;DEVCHR TO 13
	MOVE	FLG,10(I16)	;FLAGS TO FLG
	TLC	FLG,OPNIN!OPNOUT
	TLCE	FLG,OPNIN!OPNOUT
	JRST	RRDMP5		;
RRDMP0:	PUSHJ	PP,RRERR0	;"DUMP ABORTED"
	TTCALL	3,[ASCIZ / IO/]
	JRST	RRDMP9		;EXIT, NO DUMP

	;SCAN FOR OPEN OUTPUT FILES
RRDMP2:	HRRZ	AC16,FILES.	;FIRST FILE-TABLE
	SKIPA
RRDMP3:	HRRZ	AC16,6(I16)	;NEXT FILE-TABLE
	JUMPE	AC16,RRDIT	;GO DUMP IT
	MOVE	FLG,10(I16)	;FLAGS
	TLNN	FLG,OPNIN!OPNOUT ;SKIP IF FILE IS OPEN
	JRST	RRDMP4		;ELSE CONT
	MOVE	AC1,5(I16)	;DEVICE POINTER
	MOVE	AC1,(AC1)	;6BIT DEVICE NAME
	MOVEM	AC1,D.RD(I16)	;SAVE IT FOR RERUN
RRDMP4:	TLNN	FLG,OPNOUT	;SKIP IF OPEN FOR OUTPUT
	JRST	RRDMP3		;LOOP
	MOVE	AC13,D.DC(I16)	;DEVCHR
	TLNN	AC13,200020	;SKIP IF DSK OR MTA
	JRST	RRDMP3		;
	PUSHJ	PP,SETCN.	;SET CHAN NUMBER
	TLNN	FLG,OPNIO!RANFIL ;SKIP IF DSK DUMP MODE
	JRST	RRBUF		;DSK/MTA BUFFERED MODE

	;DSK DUMP MODE
	PUSHJ	PP,RRCLE	;CLOSE, LOOKUP, ENTER SEQUENCE
	MOVE	AC1,D.CBN(I16)	;NEXT BLOCK
	XCT	USETI.		;
	JRST	RRDMP3		;CONT LOOP

RRDMP5:	TLNN	FLG,OPNIN!OPNOUT
	JRST	RRDMP1		;THIS FILE IS NOT OPEN = CONT
IFN EBCDIC,<
	TLNE	FLG,DDMEBC	;IF EBCDIC FILE ABORT
	JRST	[PUSHJ PP,RRERR0 ;DUMP ABORTED
		TTCALL 3,[ASCIZ /EBCDIC/]
		JRST RRDMP9]	;FILE IS OPEN.
>
	TLNE	FLG,IDXFIL	;ISAM FILE?
	JRST	RRDMP8		;YES
	TLNN	AC13,140700	;CDR, CDP, PTP, PTR, DTA?

	JRST	RRDMP1		;NO, CONT SCAN
RRDMP8:	PUSHJ	PP,RRERR0	;DUMP ABORTED
	TLNE	FLG,IDXFIL	;INDEX-SEQ-ACCESS MODE?
	TTCALL	3,[ASCIZ / ISAM/]
	TLNE	AC13,100000	;CARDS?
	TTCALL	3,[ASCIZ / CARD/]
	TLNE	AC13,40000	;LINE-PRINTER?
	TTCALL	3,[ASCIZ / LPT/]
	TLNE	AC13,600	;PAPER TAPE?
	TTCALL	3,[ASCIZ / PAPER-TAPE/]
	TLNE	AC13,100	;
	TTCALL	3,[ASCIZ / DEC-TAPE/]
RRDMP9:	TTCALL	3,[ASCIZ / FILE IS OPEN.
/]
	JRST	RRXIT		;EXIT NO DUMP

	;CLOSE LOOKUP ENTER ROUTINE

RRCLE:	XCT	UCLOS.		;CLOSE, ENSURES FILES CURRENT STATE IS PRESERVED
	PUSHJ	PP,WRTWAI	;CHECK FOR ERRORS
RRCLE1:	PUSHJ	PP,OPNLID	;SET UP LOOKUP  BLOCK
	XCT	ULKUP.		;LOOKUP
	JRST	LOOKER		;ERROR
	TLNE	AC13,100	;SKIP IF NOT DTA
	POPJ	PP,		;
RRCLE2:	PUSHJ	PP,OPNEID	;ENTER BLK
	XCT	UENTR.		;ENTER
	JRST	ENTRER		;ERROR
	POPJ	PP,		;

LOOKER:	PUSHJ	PP,LUPERR	;ERROR MESSAGE
	JRST	RRCLE1		;TRY AGAIN
ENTRER:	PUSHJ	PP,ENRERR	;
	JRST	RRCLE2		;
	;BUFFERED MODE
RRBUF:	PUSH	PP,D.OBC(I16)	;OUTPUT
	PUSH	PP,D.OBB(I16)	;BUFFER
	PUSH	PP,D.OBH(I16)	;HEADER
	HRR	AC1,D.OBH(I16)	;CURRENT BUFFER'S ADR
	ADDI	AC1,1		;MAKE BYTPTR INDICATE EMPTY BUFFER
	HRRM	AC1,D.OBB(I16)	;HDR BYTE-POINTER
	PUSHJ	PP,RRCLE	;CLOSE, LOOKUP, ENTER
	TLNE	AC13,20		;MTA?
	JRST	RRBUF5		;YES
	POP	PP,D.OBH(I16)	;OUTPUT
	POP	PP,D.OBB(I16)	;BUFFER
	POP	PP,D.OBC(I16)	;HEADER
	MOVE	AC1,D.OE(I16)	;NUMBER OF OUTPUTS
	AOJA	AC1,RRBUF2	;DSK
RRBUF2:	XCT	USETO.		;
	JRST	RRDMP3		;

	;MAG-TAPE, IF CLOSE GENERATED AN EOF BACK OVER IT
RRBUF5:	XCT	UOUT.		;DUMMY OUTPUT, ??? IT WORKS
	XCT	MBSPR.		;BACKUP ONE RECORD  (EOF)
	XCT	MWAIT.		;WAIT FOR TAPE MOTION TO STOP
	XCT	UGETS.		;GET STATUS INTO AC2
	TRNN	AC2,24000	;SKIP IF EOF OR BOT
	XCT	MADVR.		;NOT AN EOF, SPACE OVER IT

	;NOW MOVE WHAT WAS THE CURRENT BUFFER TO THE CURRENT CURRENT BUFFER
	HRR	AC2,D.OBH(I16)	;TO - 1
	HRL	AC2,(PP)	;FROM - 1
	HLRZ	AC1,(AC2)	;BUF SIZE, MAY CHANGE FROM FILE TO FILE
	ADDI	AC1,(AC2)	;UNTIL
	AOBJP	AC2,.+1		;FROM,,TO
	BLT	AC2,(AC1)	;MOVIT

	;UPDATE THE HEADER
	POP	PP,AC1		;FRST HDR WRD
	POP	PP,AC2		;BYTE-PTR
	SUBI	AC2,(AC1)	;#OF WRDS IN BFR
	HRRZ	AC1,D.OBH(I16)	;CRNT BFRS ADR
	ADD	AC2,AC1		;NEW BYTE-PTR
	MOVEM	AC2,D.OBB(I16)	;SAVIT
	POP	PP,D.OBC(I16)	;OLD BYTE-CNT
	JRST	RRDMP3		;NEXT
RC==0	;RERUN IO CHANNEL
	;DUMP THE LOWSEG
RRDIT:	MOVEI	AC3,(SIXBIT /DSK/)
	HRLZM	AC3,UOBLK.+1	;DEVICE NAME
	MOVEI	AC3,17		;DUMP MODE
	HRRZM	AC3,UOBLK.	;
	SETZM	UOBLK.+2	;ELSE LAST BUF-HDR IS OVER-WRITTEN
	OPEN	RC,UOBLK.	;
	JRST	RRERR		;ERROR
	HRROI	AC3,3		;JBTPRG
	CALLI	AC3,41		;PROGRAM NAME TO AC3
	JRST	RRERR3		;ERROR RET ;HRLZI AC3,(SIXBIT /PKC/)
	MOVEM	AC3,UEBLK.	;LOW-SEG NAME
	HRLZI	AC3,(SIXBIT /CKP/)
	HLLZM	AC3,UEBLK.+1	;EXTENSION
	SETZM	UEBLK.+3
	ENTER	RC,UEBLK.	;
	JRST	RRERR1		;ERROR

	HRRZ	AC0,.JBFF	;
	ADDI	AC0,.JBDA	;
	CAMGE	AC0,.JBREL	;SKIP IF NEXT BLT VIOLATES MEMORY
	JRST	RRDIT3		;
	CALLI	AC0,11		;EXPAND CORE
	JRST	RRERR4		;ERROR RET
RRDIT3:	MOVE	AC0,FILES.	;
	HRL	AC0,.JBFF	;FRST FREE
	MOVEM	AC0,TEMP.	;FIRST FILE TABLE
	MOVEM	PP,TEMP.1	;PP POINTER
	HRLI	AC10,TEMP.	;POINTER TO FILES. AND PP
	HRR	AC10,.JBREL	;LENGTH FOR IOWD
	HRRZ	AC1,.JBFF	;
	MOVEM	AC10,(AC1)	;INTO FIRST FREE LOC
	HRROI	AC1,-1(AC1)	;IOWD
	SETZ	AC2,		;TERMINATOR
	OUT	RC,AC1		;FIRST RECORD	;TEMP.,,(.JBREL)
	SKIPA
	JRST	RRERR2		;OUTPUT ERROR
	HRRZ	AC1,.JBFF	;SAVE JOBDATA AREA
	MOVEI	AC3,.JBDA(AC1)	;UNTIL
	BLT	AC1,(AC3)	;   STARTING AT .JBFF
	MOVNI	AC1,-140(AC10)	;IOWD FOR SECOND RECORD
	HRL	AC1,AC1		;ALL OF LOW-SEG
	HRRI	AC1,.JBDA-1	;  BUT JOB-DATA AREA
	OUT	RC,AC1		;SECOND RECORD
	SKIPA
	JRST	RRERR2		;OUTPUT ERROR
	CLOSE	RC,		;
	TTCALL	3,[ASCIZ /DUMP COMPLETED.
/]
RRXIT:	AOSN	AC15		;SKIP IF NOT FORCED
	CALLI	1,12		;EXIT IF IT WAS FORCED
	JRST	RSTAC1		;RESTORE ACS AND POPJ
RRERR0:	TTCALL	3,[ASCIZ /DUMP ABORTED /]
	POPJ	PP,		;

		;OPEN FAILED
RRERR:	PUSHJ 	PP,RRERR0	;
	TTCALL	3,[ASCIZ /OPEN FAILED. /]
	JRST	RRXIT		;

		;ENTER FAILED
RRERR1:	PUSHJ	PP,RRERR0	;
	TTCALL	3,[ASCIZ /ENTER FAILED,/]
	HRRZ	AC2,UEBLK.+1	;THE ERROR BITS
	TRZ	AC2,777740	;   NOTHING ELSE
	CAIL	AC2,LEMLEN	;LEGAL MESSAGE?
	HRRI	AC2,LEMLEN	;NO
	CAIN	AC2,0		;
	HRRI	AC2,LEMLEN+1	;ILL-FIL-MAME
	TTCALL	3,@LEMESS(AC2)	;COMPLAIN
	JRST	RRERRX		;ERROR EXIT

		;OUTPUT FAILED
RRERR2:	PUSHJ	PP,RRERR0	;
	TTCALL	3,[ASCIZ /OUTPUT ERROR, /]
	GETSTS	RC,AC2		;ERROR STATUS
	PUSHJ	PP,IOERM1	;COMPLAIN

RRERRX:	TTCALL	3,[ASCIZ /
/]
	CLOSE	RC,40		;CLOSE, BUT DONT SUPERCEDE
	JRST	RSTAC1		;EXIT

	;CAINT FIND THE PROGRAM NAME
RRERR3:	PUSHJ	PP,RRERR0	;
	TTCALL	3,[ASCIZ /CANNOT FIND PROGRAM NAME/]
	JRST	RRERRX		;

	;CORE UUO FAILED
RRERR4:	PUSHJ	PP,RRERR0
	TTCALL	3,[ASCIZ /CORE UUO FAILED/]
	JRST	RRERRX		;
	;POINTERS AND THINGS

PAT:	BLOCK	10		;PATCH AREA
WOPRS.:	POINT	12,AC15,11	;RECORD SIZE IN CHARS
WOPCN:	POINT	3,AC15,17	;LPT CHANNEL NUMBER
WRTACP:	POINT	5,WRTAC,4	;ADVANCE CHAR POINTER
WRTAC:	BYTE	(5)12,14,20,21,22,23,24,13
DENSIT:	POINT	4,22(I16),3	;MTA DENSITY & PARITY
BBRISK:	POINT	1,22(I16),5	;0 = SLOW AND SAFE,  1 = FAST & RISKY
VERNO:	POINT 6,5(I16),5	;COMPILER'S VERSION NO.
FTBN.:	POINT	6,7(I16),5	;FILE TABLE BUFFER NUMBER
FTCN.:	POINT	4,D.CN(I16),15	;FILE TABLE CHANNEL NUMBER
FTBF.:	POINT	12,12(I16),17	;FILE TABLE BLOCKING FACTOR
FTFLC:	POINT	5,6(I16),4	;FILE TABLE NUMBER OF FILE LIMIT CLAUSES
FTFP.:	POINT	6,6(I16),17	;FILE TABLE FILE POSITION
FTMRS.:	POINT	12,7(I16),17	;FILE TABLE MAXIMUM RECORD SIZE
FTIBS.:	POINT	6,D.IBB(I16),11	;FILE TABLE INPUT HEADER BYTE SIZE
FTOBS.:	POINT	6,D.OBB(I16),11	;FILE TABLE OUTPUT HEADER BYTE SIZE
STDLBP:	POINT	6,STDLB.	;STANDARD LABEL POINTER
DTRN.:	POINT	12,D.RN(I16),11	;DEVICE TABLE REEL NUMBER
DOPFS.:	POINT	10,(I16),17	;DISPLAY OPERAND FIELD-SIZE

OPNCBP:	POINT	1,OPNCH.	;POINTER TO CHAN. STATUS
	;THE TABLE IS USED TO CONVERT FROM LOWER CASE TO UPPER CASE
	;TO SIXBIT ETC.  END-OF-LINE (EOL) CHARS ARE NEGATIVE.
	;	SIXBIT	ASCII	;CHAR
CHTAB:	XWD	0,	0	;
	XWD	0,	1	;
	XWD	0,	2	;
	XWD	0,	3	;
	XWD	0,	4	;
	XWD	0,	5	;
	XWD	0,	6	;
	XWD	0,	7	;
	XWD	0,	10	;
	XWD	0,	11	;HT
	XWD	400000,	400012	;LF
	XWD	400000,	400013	;VT
	XWD	400000,	400014	;FF
	XWD	400000,	400015	;CR
	XWD	0,	16	;
	XWD	0,	17	;
	XWD	400000,	400020	;PC
	XWD	400000,	400021	;PC
	XWD	400000,	400022	;PC
	XWD	400000,	400023	;PC
	XWD	400000,	400024	;PC
	XWD	0,	25	;
	XWD	0,	26	;
	XWD	0,	27	;
	XWD	0,	30	;
	XWD	0,	31	;
	XWD	400000,	400032	;TTY EOF
	XWD	0,	33	;ALT-MODE
	XWD	0,	34	;
	XWD	0,	35	;
	XWD	0,	36	;
	XWD	0,	37	;

	XWD	0,	40	;SPACE
	XWD	1,	41	;!
	XWD	2,	42	;"
	XWD	3,	43	;#
	XWD	4,	44	;$
	XWD	5,	45	;%
	XWD	6,	46	;&
	XWD	7,	47	;'
	XWD	10,	50	;(
	XWD	11,	51	;)
	XWD	12,	52	;*
	XWD	13,	53	;+
	XWD	14,	54	;,
	XWD	15,	55	;-
	XWD	16,	56	;.
	XWD	17,	57	;/
	XWD	20,	60	;0
	XWD	21,	61	;1
	XWD	22,	62	;2
	XWD	23,	63	;3
	XWD	24,	64	;4
	XWD	25,	65	;5
	XWD	26,	66	;6
	XWD	27,	67	;7
	XWD	30,	70	;8
	XWD	31,	71	;9
	XWD	32,	72	;:
	XWD	33,	73	;;
	XWD	34,	74	;<
	XWD	35,	75	;=
	XWD	36,	76	;>
	XWD	37,	77	;?

	XWD	40,	100	;@
	XWD	41,	101	;A
	XWD	42,	102	;B
	XWD	43,	103	;C
	XWD	44,	104	;D
	XWD	45,	105	;E
	XWD	46,	106	;F
	XWD	47,	107	;G
	XWD	50,	110	;H
	XWD	51,	111	;I
	XWD	52,	112	;J
	XWD	53,	113	;K
	XWD	54,	114	;L
	XWD	55,	115	;M
	XWD	56,	116	;N
	XWD	57,	117	;O
	XWD	60,	120	;P
	XWD	61,	121	;Q
	XWD	62,	122	;R
	XWD	63,	123	;S
	XWD	64,	124	;T
	XWD	65,	125	;U
	XWD	66,	126	;V
	XWD	67,	127	;W
	XWD	70,	130	;X
	XWD	71,	131	;Y
	XWD	72,	132	;Z
	XWD	73,	133	;[
	XWD	74,	134	;\
	XWD	75,	135	;]
	XWD	76,	136	;^
	XWD	77,	137	;_
	XWD	0,	140	;
	XWD	41,	141	;A
	XWD	42,	142	;B
	XWD	43,	143	;C
	XWD	44,	144	;D
	XWD	45,	145	;E
	XWD	46,	146	;F
	XWD	47,	147	;G
	XWD	50,	150	;H
	XWD	51,	151	;I
	XWD	52,	152	;J
	XWD	53,	153	;K
	XWD	54,	154	;L
	XWD	55,	155	;M
	XWD	56,	156	;N
	XWD	57,	157	;O
	XWD	60,	160	;P
	XWD	61,	161	;Q
	XWD	62,	162	;R
	XWD	63,	163	;S
	XWD	64,	164	;T
	XWD	65,	165	;U
	XWD	66,	166	;V
	XWD	67,	167	;W
	XWD	70,	170	;X
	XWD	71,	171	;Y
	XWD	72,	172	;Z

	XWD	0,	173	;
	XWD	0,	174	;
	XWD	0,	175	;ALT-MODE
	XWD	0,	176	;ALT-MODE
	XWD	0,	177	;RUBOUT / HIGH-VALUE

IFN EBCDIC,<
;		IDX,EBC,6BT,ASC		EBCDIC	ASCII
EBCTAB:	BYTE (9)000,000,074,000	;	NUL	NUL
	BYTE (9)001,001,074,001	;	SOH	SOH
	BYTE (9)002,002,074,002	;	STX	STX
	BYTE (9)003,003,074,003	;	ETX	ETX
	BYTE (9)004,067,074,134	;	EOT	\  
	BYTE (9)005,055,074,011	;	ENQ	HT 
	BYTE (9)006,056,074,134	;	ACK	\  
	BYTE (9)007,057,074,177	;	BEL	DEL

	BYTE (9)010,026,074,134	;	BS	\  
	BYTE (9)011,005,074,134	;	HT	\  
	BYTE (9)012,045,074,134	;	LF	\  
	BYTE (9)013,013,074,013	;	VT	VT 
	BYTE (9)014,014,074,014	;	FF	FF 
	BYTE (9)015,015,074,015	;	CR	CR 
	BYTE (9)016,016,074,016	;	SO	SO 
	BYTE (9)017,017,074,017	;	SI	SI 

	BYTE (9)020,020,074,020	;	DLE	DLE
	BYTE (9)021,021,074,021	;	DC1	DC1
	BYTE (9)022,022,074,022	;	DC2	DC2
	BYTE (9)023,023,074,023	;	DC3	DC3
	BYTE (9)024,074,074,134	;	DC4	\  
	BYTE (9)025,075,074,134	;	NAK	\  
	BYTE (9)026,062,074,010	;	SYN	BS 
	BYTE (9)027,046,074,134	;	ETB	\  

	BYTE (9)030,030,074,030	;	CAN	CAN
	BYTE (9)031,031,074,031	;	EM	EM 
	BYTE (9)032,077,074,134	;	SUB	\  
	BYTE (9)033,047,074,134	;	ESC	\  
	BYTE (9)034,034,074,034	;	FS	FS 
	BYTE (9)035,035,074,035	;	GS	GS 
	BYTE (9)036,036,074,036	;	RS	RS 
	BYTE (9)037,037,074,037	;	US	US 

	BYTE (9)040,100,074,134	;	SPC	\  
	BYTE (9)041,117,074,134	;	!	\  
	BYTE (9)042,177,074,134	;	"	\  
	BYTE (9)043,173,074,134	;	#	\  
	BYTE (9)044,133,074,134	;	$	\  
	BYTE (9)045,154,074,012	;	%	LF 
	BYTE (9)046,120,074,027	;	&	ETB
	BYTE (9)047,175,074,033	;	'	ESC

	BYTE (9)050,115,074,134	;	(	\  
	BYTE (9)051,135,074,134	;	)	\  
	BYTE (9)052,134,074,134	;	*	\  
	BYTE (9)053,116,074,134	;	+	\  
	BYTE (9)054,153,074,134	;	,	\  
	BYTE (9)055,140,074,005	;	-	ENQ
	BYTE (9)056,113,074,006	;	.	ACK
	BYTE (9)057,141,074,007	;	/	BEL

	BYTE (9)060,360,074,134	;	0	\  
	BYTE (9)061,361,074,134	;	1	\  
	BYTE (9)062,362,074,026	;	2	SYN
	BYTE (9)063,363,074,134	;	3	\  
	BYTE (9)064,364,074,134	;	4	\  
	BYTE (9)065,365,074,134	;	5	\  
	BYTE (9)066,366,074,134	;	6	\  
	BYTE (9)067,367,074,004	;	7	EOT

	BYTE (9)070,370,074,134	;	8	\  
	BYTE (9)071,371,074,134	;	9	\  
	BYTE (9)072,172,074,134	;	:	\  
	BYTE (9)073,136,074,134	;	;	\  
	BYTE (9)074,114,074,024	;	<	DC4
	BYTE (9)075,176,074,025	;	=	NAK
	BYTE (9)076,156,074,134	;	>	\  
	BYTE (9)077,157,074,032	;	?	SUB

	BYTE (9)100,174,000,040	;	@	SPC
	BYTE (9)101,301,074,134	;	A	\  
	BYTE (9)102,302,074,134	;	B	\  
	BYTE (9)103,303,074,134	;	C	\  
	BYTE (9)104,304,074,134	;	D	\  
	BYTE (9)105,305,074,134	;	E	\  
	BYTE (9)106,306,074,134	;	F	\  
	BYTE (9)107,307,074,134	;	G	\  

	BYTE (9)110,310,074,134	;	H	\  
	BYTE (9)111,311,074,134	;	I	\  
	BYTE (9)112,321,073,133	;	J	[  
	BYTE (9)113,322,016,056	;	K	.  
	BYTE (9)114,323,034,074	;	L	<  
	BYTE (9)115,324,010,050	;	M	(  
	BYTE (9)116,325,013,053	;	N	+  
	BYTE (9)117,326,001,041	;	O	!  

	BYTE (9)120,327,006,046	;	P	&  
	BYTE (9)121,330,074,134	;	Q	\  
	BYTE (9)122,331,074,134	;	R	\  
	BYTE (9)123,342,074,134	;	S	\  
	BYTE (9)124,343,074,134	;	T	\  
	BYTE (9)125,344,074,134	;	U	\  
	BYTE (9)126,345,074,134	;	V	\  
	BYTE (9)127,346,074,134	;	W	\  

	BYTE (9)130,347,074,134	;	X	\  
	BYTE (9)131,350,074,134	;	Y	\  
	BYTE (9)132,351,075,135	;	Z	]  
	BYTE (9)133,112,004,044	;	[	$  
	BYTE (9)134,340,012,052	;	\	*  
	BYTE (9)135,132,011,051	;	]	)  
	BYTE (9)136,137,033,073	;	^	;  
	BYTE (9)137,155,076,136	;	_	^  

	BYTE (9)140,171,015,055	;	`	-  
	BYTE (9)141,201,017,057	;	A	/  
	BYTE (9)142,202,074,134	;	B	\  
	BYTE (9)143,203,074,134	;	C	\  
	BYTE (9)144,204,074,134	;	D	\  
	BYTE (9)145,205,074,134	;	E	\  
	BYTE (9)146,206,074,134	;	F	\  
	BYTE (9)147,207,074,134	;	G	\  

	BYTE (9)150,210,074,134	;	H	\  
	BYTE (9)151,211,074,134	;	I	\  
	BYTE (9)152,221,074,174	;	J	???
	BYTE (9)153,222,014,054	;	K	,  
	BYTE (9)154,223,005,045	;	L	%  
	BYTE (9)155,224,077,137	;	M	_  
	BYTE (9)156,225,036,076	;	N	>  
	BYTE (9)157,226,037,077	;	O	?  

	BYTE (9)160,227,074,134	;	P	\  
	BYTE (9)161,230,074,134	;	Q	\  
	BYTE (9)162,231,074,134	;	R	\  
	BYTE (9)163,242,074,134	;	S	\  
	BYTE (9)164,243,074,134	;	T	\  
	BYTE (9)165,244,074,134	;	U	\  
	BYTE (9)166,245,074,134	;	V	\  
	BYTE (9)167,246,074,134	;	W	\  

	BYTE (9)170,247,074,134	;	X	\  
	BYTE (9)171,250,074,140	;	Y	???
	BYTE (9)172,251,032,072	;	Z	:  
	BYTE (9)173,300,003,043	;	???	#  
	BYTE (9)174,152,040,100	;	???	@  
	BYTE (9)175,320,007,047	;	???	'  
	BYTE (9)176,241,035,075	;	???	=  
	BYTE (9)177,007,002,042	;	DEL	"  

	BYTE (9)200,000,074,134	;		\  
	BYTE (9)201,000,001,141	;		A  
	BYTE (9)202,000,002,142	;		B  
	BYTE (9)203,000,003,143	;		C  
	BYTE (9)204,000,004,144	;		D  
	BYTE (9)205,000,005,145	;		E  
	BYTE (9)206,000,006,146	;		F  
	BYTE (9)207,000,007,147	;		G  

	BYTE (9)210,000,010,150	;		H  
	BYTE (9)211,000,011,151	;		I  
	BYTE (9)212,000,074,134	;		\  
	BYTE (9)213,000,074,134	;		\  
	BYTE (9)214,000,074,134	;		\  
	BYTE (9)215,000,074,134	;		\  
	BYTE (9)216,000,074,134	;		\  
	BYTE (9)217,000,074,134	;		\  

	BYTE (9)220,000,074,134	;		\  
	BYTE (9)221,000,012,152	;		J  
	BYTE (9)222,000,013,153	;		K  
	BYTE (9)223,000,014,154	;		L  
	BYTE (9)224,000,015,155	;		M  
	BYTE (9)225,000,016,156	;		N  
	BYTE (9)226,000,017,157	;		O  
	BYTE (9)227,000,020,160	;		P  

	BYTE (9)230,000,021,161	;		Q  
	BYTE (9)231,000,022,162	;		R  
	BYTE (9)232,000,074,134	;		\  
	BYTE (9)233,000,074,134	;		\  
	BYTE (9)234,000,074,134	;		\  
	BYTE (9)235,000,074,134	;		\  
	BYTE (9)236,000,074,134	;		\  
	BYTE (9)237,000,074,134	;		\  

	BYTE (9)240,000,074,134	;		\  
	BYTE (9)241,000,074,176	;		???
	BYTE (9)242,000,023,163	;		S  
	BYTE (9)243,000,024,164	;		T  
	BYTE (9)244,000,025,165	;		U  
	BYTE (9)245,000,026,166	;		V  
	BYTE (9)246,000,027,167	;		W  
	BYTE (9)247,000,030,170	;		S  

	BYTE (9)250,000,031,171	;		Y  
	BYTE (9)251,000,032,172	;		Z  
	BYTE (9)252,000,074,134	;		\  
	BYTE (9)253,000,074,134	;		\  
	BYTE (9)254,000,074,134	;		\  
	BYTE (9)255,000,074,134	;		\  
	BYTE (9)256,000,074,134	;		\  
	BYTE (9)257,000,074,134	;		\  

	BYTE (9)260,000,074,134	;		\  
	BYTE (9)261,000,074,134	;		\  
	BYTE (9)262,000,074,134	;		\  
	BYTE (9)263,000,074,134	;		\  
	BYTE (9)264,000,074,134	;		\  
	BYTE (9)265,000,074,134	;		\  
	BYTE (9)266,000,074,134	;		\  
	BYTE (9)267,000,074,134	;		\  

	BYTE (9)270,000,074,134	;		\  
	BYTE (9)271,000,074,134	;		\  
	BYTE (9)272,000,074,134	;		\  
	BYTE (9)273,000,074,134	;		\  
	BYTE (9)274,000,074,134	;		\  
	BYTE (9)275,000,074,134	;		\  
	BYTE (9)276,000,074,134	;		\  
	BYTE (9)277,000,074,134	;		\  

	BYTE (9)300,000,074,173	;		???
	BYTE (9)301,000,041,101	;		A  
	BYTE (9)302,000,042,102	;		B  
	BYTE (9)303,000,043,103	;		C  
	BYTE (9)304,000,044,104	;		D  
	BYTE (9)305,000,045,105	;		E  
	BYTE (9)306,000,046,106	;		F  
	BYTE (9)307,000,047,107	;		G  

	BYTE (9)310,000,050,110	;		H  
	BYTE (9)311,000,051,111	;		I  
	BYTE (9)312,000,074,134	;		\  
	BYTE (9)313,000,074,134	;		\  
	BYTE (9)314,000,074,134	;		\  
	BYTE (9)315,000,074,134	;		\  
	BYTE (9)316,000,074,134	;		\  
	BYTE (9)317,000,074,134	;		\  

	BYTE (9)320,000,074,175	;		???
	BYTE (9)321,000,052,112	;		J  
	BYTE (9)322,000,053,113	;		K  
	BYTE (9)323,000,054,114	;		L  
	BYTE (9)324,000,055,115	;		M  
	BYTE (9)325,000,056,116	;		N  
	BYTE (9)326,000,057,117	;		O  
	BYTE (9)327,000,060,120	;		P  

	BYTE (9)330,000,061,121	;		Q  
	BYTE (9)331,000,062,122	;		R  
	BYTE (9)332,000,074,134	;		\  
	BYTE (9)333,000,074,134	;		\  
	BYTE (9)334,000,074,134	;		\  
	BYTE (9)335,000,074,134	;		\  
	BYTE (9)336,000,074,134	;		\  
	BYTE (9)337,000,074,134	;		\  

	BYTE (9)340,000,074,134	;		\  
	BYTE (9)341,000,074,134	;		\  
	BYTE (9)342,000,063,123	;		S  
	BYTE (9)343,000,064,124	;		T  
	BYTE (9)344,000,065,125	;		U  
	BYTE (9)345,000,066,126	;		V  
	BYTE (9)346,000,067,127	;		W  
	BYTE (9)347,000,070,130	;		X  

	BYTE (9)350,000,071,131	;		Y  
	BYTE (9)351,000,072,132	;		Z  
	BYTE (9)352,000,074,134	;		\  
	BYTE (9)353,000,074,134	;		\  
	BYTE (9)354,000,074,134	;		\ 
	BYTE (9)355,000,074,134	;		\ 
	BYTE (9)356,000,074,134	;		\ 
	BYTE (9)357,000,074,134	;		\ 

	BYTE (9)360,000,020,060	;		0 
	BYTE (9)361,000,021,061	;		1 
	BYTE (9)362,000,022,062	;		2 
	BYTE (9)363,000,023,063	;		3 
	BYTE (9)364,000,024,064	;		4 
	BYTE (9)365,000,025,065	;		5  
	BYTE (9)366,000,026,066	;		6  
	BYTE (9)367,000,027,067	;		7

	BYTE (9)370,000,030,070	;		8  
	BYTE (9)371,000,031,071	;		9  
	BYTE (9)372,000,074,134	;		\  
	BYTE (9)373,000,074,134	;		\  
	BYTE (9)374,000,074,134	;		\  
	BYTE (9)375,000,074,134	;		\  
	BYTE (9)376,000,074,134	;		\  
	BYTE (9)377,000,074,134	;		\  


>

END.:	END
  AGZ