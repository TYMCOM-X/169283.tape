 :
 :    REGISTER ASSIGNMENTS
 :
R0	EQ	0
R1	EQ	1
R2	EQ	2
R3	EQ	3
R4	EQ	4
R5	EQ	5
R6	EQ	6
R7	EQ	7
BASE	EQ	8
LINK	EQ	9
IBUF	EQ	0A
SB	EQ	0B
X	EQ	0C
MLB	EQ	0D
N	EQ	0E
A	EQ	0F
 :
 :   SVC TYPE DESIGNATORS
 :
IN	EQ	0
OUT	EQ	1
	BC	33
 :
 :
 :    DATA DEGMENT LAYOUT
 :
 :
	ORG	0
NEWPSW	WS	2
OLDPSW	WS	2
	ORG	((.+1)/4*2+1)*2
XX	HS	9		:ALIGN HALFWORD BUT NOT FULLWORD
	ORG	((.+1)/4*2+1)*2
YY	HS	9		:DITTO
URSA	WS	10		:USER REGISTER SAVE AREA
DRSA	WS	10		:DDT REDISTER SAVE AREA
BPNO	EQ	8		:NUMBER OF USER BREAKPOINTS
LISTA	WS	BPNO+2		:BP ADDRESS LIST
LISTO	BS	BPNO+2		:BP OPCODE LIST
LISTL	BS	BPNO		:BP LENGTH LIST
SLINK	WS	1		:LINK SAVE AREAS
TLINK	WS	1
ULINK	WS	1
VLINK	WS	1
INBUF	BS	1		:INPUT BUFFER
	ORG	./2*2+1		:INSURE ODD BOUNDARY
ROUT	BS	9		:ADDRESS OF ILL INST IN ERROR MSG
 :
 :
 :
	ORG	10000
 :
 :
 :    CONSTANTS AREA
 :
 :
LOC	WS	1		:MONITOR SET ADDRESSES (ADDR OF DATA SEG)
LOW	WS	1		:  (FIRST ADDR OF USER AREA)
UPP	WS	1		:  (LAST ADDR OF USER AREA)
PROMPT	BC	1
	DA	'*'		:STRING LENGTH 1  STRING "*"
TERR	BC	11
	DA	'ILLEGAL COMMAND"0D"0A'  :CR - 0D   LF - 0A
ALIST	WC	P		:LIST OF ROUTINE ADDRESSES
	WC	B
	WC	W
	WC	R
	WC	G
	WC	C
	WC	I
ILEN	EQ	7
ILIST	DA	'P'		:LIST OF ASCII DDT INST
	DA	'B'
	DA	'W'
	DA	'R'
	DA	'G'
	DA	'C'
	DA	'I'
DIGITS	DA	'0'		'LIST OF ASCII CODES FOR DIGITS
	DA	'1'
	DA	'2'
	DA	'3'
	DA	'4'
	DA	'5'
	DA	'6'
	DA	'7'
	DA	'8'
	DA	'9'
	DA	'A'
	DA	'B'
	DA	'C'
	DA	'D'
	DA	'E'
	DA	'F'
DLEN	EQ	6		:NUMBER OF DELIMITER CHARS
DLIST	DA	' '		:LIST OF DELIMITER CHARS
	DX	0D		:CR
	DX	0A		:LF
	DX	00
	DX	09		:HT
	DA	','
XERR	BC	11
	DA	'ILLEGAL INST. AT '
XMSG	BC	0D
	DA	'>>BREAKPOINT '
SPSW	WC	0F310		:REG SET 1, INTERUPTS ENABLE, CC=0
GMSG	BC	16
	DA	'ADDRESS OUT OF RANGE"0D"0A'
BPERR	BC	20
	DA	'BREAKPOINT NUMBER OUT OF RANGE"0D"0A'
PRERR	BC	1F
	DA	'NO BREAKPOINT TO PROCEED FROM"0D"0A'
BRLEN	EQ	13		:NUMBER OF JUMP OPCODES
BR	BC	01		:RR TYPE BRANCH OPCODE
	BC	02
	BC	03
	BC	12
	BC	13
	BC	20
	BC	21
	BC	22
	BC	23
	BC	30
	BC	31
	BC	32
RXBR	BC	41		:RX TYPE BRANCH OPCODES
	BC	42
	BC	43
	BC	52
	BC	53
	BC	0C0
	BC	0C1
 : THE ENTRY CODE INITIALLY SETS UP THE BASE REGISTER FOR THIS USER'S
 : DATA SEGMENT.  IT THEN SETS UP CODE SEQUENCES IN THE DATA SEGMENT AS
 : FOLLOWS
 :	XX	STM	0,URSA
 :		LM	0,DRSA
 :		J	XDDT
 :	YY	STM	0,DRSA
 :		LM	0,URSA
 :		LPSW	OLDPSW
 : NOTE - XX AND YY ARE ON A HALFWORD BOUNDARY THAT IS NOT A FULLWORD
 :        BOUNDARY
 :
ENTRY	L	BASE,LOC	:LOAD BASE REG FROM MONITOR SET LOCATION
	LHI	R0,0D000	: STM 0,
	STH	R0,XX,BASE	:STORE OPCODE, R, FX2
	STH	R0,YY,BASE	:DITTO
	LHI	R0,0D100	: LM 0,
	STH	R0,XX+6,BASE	:DITTO
	STH	R0,YY+6,BASE	:DITTO
	LHI	R0,5300		: J ,
	STH	R0,XX+0C,BASE	:DITTO
	LHI	R0,0C200	: LPSW ,
	STH	R0,YY+0C,BASE	:DITTO
	LA	R0,URSA,BASE	:ADDRESS OF USER REGISTER SAVE AREA
	ST	R0,XX+2,BASE	:STORE INTO 1ST INST. AT XX
	STH	R0,YY+0A,BASE	:DO THE SAME FOR SECOND INST OF YY
	EXHR	R0,R0		:USE 2 HALWORDS DUE TO ALIGNMENT
	STH	R0,YY+8,BASE
	LA	R0,DRSA,BASE	:DITTO FOR DDT REGISTER SAVE AREA
	ST	R,YY+2,BASE	:STORE IN FIRST INST OF YY
	STH	R0,XX+0A,BASE	:2ND INST IN XX REQUIRES HALFWORD STORES
	EXHR	R0,R0
	STH	R0,XX+8,BASE
	LA	R0,XDDT		:BRANCH ADDRESS FOR XX CODE
	ST	R0,XX+0E,BASE	:STORE IN THIRD INST OF XX
	LA	R0,OLDPSW,BASE	:ADDRESS OF PSW TO BE LOADED BY YY CODE
	ST	R0,YY+0E,BASE	:STORE IN 3RD INST OF YY
	LHI	R0,40		:THIS MUST BE 3RD BYTE OF ALL 6 RX3 INST.
	STB	R0,XX+2,BASE
	STB	R0,XX+8,BASE
	STB	R0,XX+0E,BASE
	STB	R0,YY+2,BASE
	STB	R0,YY+8,BASE
	STB	R0,YY+0E,BASE
	LHI	R0,7210		:PSW FLAGS FOR ENTRY TO DDT AT BREAKPOINT
	ST	R0,NEWPSW,BASE
	LA	R0,XX,BASE	:ADDR OF CODE TO SWAP REGISTERS
	ST	R0,NEWPSW+4,BASE
	LIS	IBUF,0		:CLEAR INPUT BUFFER PTR
TTY	SVC	OUT,PROMPT	:ISSUE PROMPT
	JAL	LINK,CHARM	:READ A CHAR
	JAL	LINK,TTST	:CHECK IF CHAR IS LEGAL INST. TO DDT
	JFS	TCALL		:YES - CALL APPROPRIATE ROUTINE
	SVC	OUT,TERR	:NO - ISSUE ERROR MESSAGE
TTRY	JAL	LINK,CHARM	:READ CHAR UNTIL IT IS AN INST.
	JAL	LINK,TTST	:CHECK IF LEGAL INST. TO DDT
	JFS	TCALL		:YES - CALL APPROPRIATE ROUTINE
	JBS	TTRY		:NO - TRY AGAIN
TCALL	SLLS	R1,2		:R1 PTS TO INST+1 - EXPAND INDEX TO WORD LIST
	L	R2,ALIST-1(R1)	:TABLE OF ROUTINE ADDRESSES
	JALR	LINK,R2		:CALL ROUTINE
	JBS	TTY		:DO IT OVER
TTST	LIS	R1,ILEN		:INITIALIZE LOOP COUNTER
TLOOP	LB	R2,ILIST-1(R1)	:FETCH A DDT INST.
	CLR	R0,R1		:IS THE CHAR THIS INST.
	JER	LINK		:YES - RETURN
	SIS	R1,1		:NO - DECRECMENT COUNTER
	JNBS	TLOOP		:LOOP UNLESS ZERO
	AIS	LINK,2		:SET UP SKIP RETURN
	JR	LINK
 :THE FOLLOWING HANDLES ILLEGAL INSTRUCTION TRAPS
TRAP	L	BASE,LOC	:ADDRESS OF DATA SEG FROM MONITOR
	STM	14,OLDPSW,BASE	:STORE OLD PSW
	LPSW	,NEWPSW,BASE	:LOAD PSW FROM DATA SEG
XDDT	ST	LINK,SLINK,BASE	:SAVE LINK
	L	X,OLDPSW+4,BASE	:GET ADDR OF ILL INST
	CLHI	SB,0		:WAS THIS A SPECIAL BP?
	JN	LX1		:YES - BRANCH
	LHI	NLB,BPNO*4	:SET UP FOR SEARCH OF LISTA
LX2	CL	X,LISTA-4,BASE,NLB
	JEFS	LX3		:FOUND IT
	SIS	NLB,4
	JNBS	LX2		:LOOP
LX6	LHI	NLB,-1		:NOT FOUND - THIS IS AN ILLEGAL INST.
	SVC	OUT,XERR	:GIVE ERROR MESSAGE
	LIS	R3,8		:SET UP OUTPUT BUFFER TO PRINT ADDR OF INST.
	STB	R3,ROUT,BASE
	LIS	R3,6		:6 DIGITS IN ADDRESS
XLOOP	LR	R1,X		:COPY ADDRESS
	SRLS	X,4		:DROP LAST DIGIT OF ADDRESS
	NHI	R1,0F		:ISOLATE LAST DIGIT OF ADDRESS
	LB	R2,DIGITS,R1	:FETCH ASCII FROM TABLE
	STB	R2,ROUT,BASE,R3	:STORE DIGIT IN OUTPUT BUFFER
	SIS	R3,1
	JNBS	XLOOP		:LOOP UNTIL ZERO
	LHI	R3,0D0A		: CR LF
	STH	R3,ROUT+7,BASE	:ROUT MUST BE ON ODD BOUNDARY
	SVC	OUT,ROUT,BASE	:OUTPUT ADDRESS
	JFS	LX4		:RETURN
LX3	LR	R3,NLB		:FOUND IT SAVE LISTA INDEX
	SRLS	NLB,2		:GET BP NUMBER
	SVC	OUT,XMSG	:GIVE MESSAGE ABOUT BP
	LIS	R3,3		:SET UP OUTPUT BUFFER FOR BP NUMBER
	STB	R3,ROUT,BASE
	LB	R3,DIGITS,NLB	:GET ASCII OF BP NUMBER
	STB	R3,ROUT+1,BASE	:PLACE IN BUFFER
	LIS	R3,0D		: CR
	STB	R3,ROUT+2,BASE
	LIS	R3,0A		: LF
	STB	R3,ROUT+3,BASE
	SVC	OUT,ROUT,BASE	:PRINT BP NUMBER
LX4	L	LINK,SLINK,BASE	:RESTORE LINK
	JR	LINK		:RETURN
LX1	LIS	SB,0		:THIS IS POTENTIALLY A SPECIAL BP
	CL	X,LISTA+20,BASE	:IS IT BP 8
	JE	LX5		:YES 
	CL	X,LISTA+24,BASE	:IS IT BP 9
	JE	LX5		:YES
	LIS	SB,1		:INDICATE A USER ILLEGAL INST.
LX5	LIS	N,9		:REMOVE BP 9
	JAL	LINK,SBB
	LIS	N,8		:REMOVE BP 8
	JAL	LINK,SBB
	CLHI	SB,0		:WAS THIS A USER ILL INST.
	JE	LX7		:NO
	LIS	SB,0		:CLEAR FLAG GIVE ERROR MESSAGE
	J	LX6
LX7	L	LINK,SLINK	:RESTORE LINK
	J	YY,BASE		:RETURN TO USER PROGRAMME
 : THE FOLLOWING IS THE CODE FOR THE INSTRUCTION P (PROCEED FROM BP)
P	CLHI	NLB,-1		:NLB = -1  IS ERROR
	JE	PERR
	LR	R3,NLB		:NUMBER OF LAST BP ENCOUNTERED
	SLLS	R3,2		:INDEX INTO ADDRESS LIST (LISTA)
	LB	A,LISTL,BASE,NLB :LENGTH OF INST AT LAST BP
	A	A,LISTA,BASE,R3	:PLUS ADDR OF BP GIVES ADDR OF NEXT INST
	LIS	N,8		:SET BP #8 AT THIS LOCATION
	LIS	SB,1		:INDICATE PRESENCE OF SPECIAL BP'S
	ST	LINK,SLINK,BASE	:SAVE LINK
	JAL	LINK,SSB	:SET BP
	LB	X,LISTO,BASE,NLB :CHECK IF OPCODE IS BRANCH (AT OLD BP)
	LA	R0,BR		:LIST OF BRANCH OPCODES
	LIS	R1,BRLEN	:LENGTH OF LIST
PBINS	SRLS	R1,1		:BINARY SEARCH - HALF LENGTH OF LIST
	JE	PNGO		:OPCODE IS NOT A BRANCH INST.
	LR	R2,R0		:COPY ADDR OF FIRST ENTRY IN LIST
	AR	R2,R1		:MID POINT OF LIST
	CL	X,,R2		:IS ENTRY EQUAL TO OPCODE OF OLD BP
	JEFS	PGO		:THIS IS BRANCH OPCODE
	JLBS	PBINS		:SEARCH TOP OF LIST
	LR	R0,R2		:SEARCH BOTTOM OF LIST
	JBS	PBINS
PGO	L	A,LISTA,BASE,R3	:OPCODE IS A BRANCH - GET ITS ADDRESS
	CLHI	X,41		:IF X >= 41 THEN RX TYPE BRANCH
	JGE	PRXB
	LB	R1,1,A		:GET INST - RR OR SF
	NHI	R1,0F		:ISOLATE REG NO. OR DISPLACEMENT
	CLHI	X,20		:IF X >= 20 THEN SF TYPE BRANCH
	JGEFS	PSFB
	SLLS	R1,2		:MAKE INDEX INTO REGISTER SAVE AREA
	L	A,URSA,BASE,R1	:FETCH REGISTER CONTENTS FROM SAVE AREA
	J	PBRBP		:SET A SPECIAL BP AT THIS ADDRESS
PSFB	SRLS	R1,1		:COUNT IN HALFWORDS
	NHI	X,1		:EVEN OPCCODE IS BACKWARD BRANCH
	JEFS	PSFBK
	AR	A,R1		:ADDRESS OF FORWARD BRANCH
	J	PBRBP		:SET A SPECIAL BP AT THIS ADDRESS
PSFBK	SR	A,R1		:ASDDRESS OF BACKWARD BRANCH
	J	PBRBP		:SET A SPECIAL BP AT THIS ADDRESS
PRXB	L	R0,LISTL,BASE,NLB :THIS IS RX TYPE - GET LENGTH
	SIS	R0,6		:IS IT RX3
	JEFS	PRX3
	LH	R0,2,A		:FETCH DISPLACEMENT OF RX1 OR RX2
	JGEFS	PRX3A		:IF SIGN BIT 0 THEN RX1 GO ADD X2 TO ADDR
	NHI	R0,7FFF		:REMOVE FLAG BIT OF RX2
	AR	R0,A		:ADD IN ADDR OF INST.
	AIS	R0,4		:RX2 REQUIRES INCREMENTED PC
	JFS	PRX3A		:GO ADD IN X2 TO ADDR
PRX3	LH	R0,2,A		:PICK UP RX3 FLAGS, SX2, HIGH ORDER ADDR BITS
	LR	R2,R0		:SAVE A COPY TO GET SX2 LATER
	NHI	R0,0FF		:ISOLATE HIGH ORDER BITS OF A2
	SLL	R0,10		:SHIFT INTO HIGH ORDER POSITIONS
	LHL	R1,4,A		:FETCH LOWORDER BITS OF A2
	AR	R0,R1		:GET WHOLE A2 IN R0
	NHI	R2,0F00		:ISOLATE SX2
	JEFS	PRX3A		:NO INDEXING IF SX2 = 0
	SRLS	R2,6		:GET REGISTER NUMBER TIMES 4
	A	R0,URSA,BASE,R2	:ADD REG VALUE FROM SAVE AREA
PRX3A	LH	R1,,A		:1ST HALFWORD OF INST TO GET X2 OR FX2
	NHI	R1,0F		:ISOLATE X2 OF FX2
	JEFS	PRX3B		:NO INDEXING IF X2 OF FX2 = 0
	SLLS	R1,2		:GET REGISTER NUMBER TIMES 4
	A	R0,URSA,BASE,R2	:ADD REG VALUE FROM SAVE AREA
PRX3B	LR	A,R0		:PUT BRANNCH ADDR IN A FOR SETTING BP
PBRBP	LSI	N,9		:SET SPECIAL BP #9
	JAL	LINK,SSB
PNGO	LB	X,LISTO,BASE,NLB :OPCODE OF OLD BP INST.
	STB	X,,A		:RESTORE OPCODE OF BP INST.
	L	LINK,SLINK,BASE	:RESTORE LINK
	J	YY,BASE		:BRANCH TO USER'S CODE
PERR	SVC	OUT,PRERR	:OUTPUT ERROR MESSAGE
	JR	LINK		:RETURN
 : THE FOLLOWING CODE IS THE DDT INST. B
B	ST	LINK,SLINK,BASE	:SAVE LINK
	JAL	LINK,NUM	:GET ADDRESS
	LR	A,R0
	JAL	LINK,NUM	:GET BP NUMBER
	LR	N,R0
	L	LINK,SLINK,BASE	:RESTORE LINK
	CLHI	N,BPNO-1	:N MUST BE  0 <= N <= 7
	JG	BERR
	CLHI	A,0		:A=0 MEANS REMOVE BP N
	JE	SBB
	LIS	R0,2		:FIND LENGTH OF INST AT BP - ASSUME 2 BYTES
	LB	R1,,A		:FETCH OPCODE
	LR	R2,R1
	NHI	R2,40		:THIS BIT ON MEANS RX OR RI FORMAT
	JE	BLN		:STORE LENGTH OF 2 BYTES
	LIS	R0,4		:ASSUME LENGTH 4 BYTES
	CLHI	R1,0C3		:OPCODE < C3 THEN RX TYPE
	JL	BRX
	CLHI	R1,0EA		:OPCODE >= EA THEN RI TYPE
	JGE	BRI12
	CLHI	R1,0CF		:OPCODE < CF THE RI1
	JL	BLN
	CLHI	R1,E2		:OPCODE = E2 THEN RI1
	JE	BLN
BRX	LB	R2,2,A		:IF 3RD BYTE OF INST IS 4X THEN RX3 TYPE
	NHI	R2,0F0		:ISOLATE LEFT DIGIT OF BYTE
	SIS	R2,40
	JNE	BLN		:STORE LENGTH TO RX1 OR 2
	LIS	R0,6		:LENGTH OF RX3
	J	BLN
BRI12	CLHI	R1,0EF		:OPCODE <= EF THE RI1
	JLE	BLN		:STORE LENGTH OF RI1  4 BYTES
	LIS	R0,6		:LENGTH OF RI2
BLN	STB	R0,LISTL,BASE,N	:STORE LENGTH IN TABLE
SSB	LR	R3,N		:THIS IS AN ENTRY POINT!!!
	SLLS	R3,2		:GENERATE INDEX TO ADDRESS TABLE
	ST	A,LISTA,BASE,R3	:STORE ADDRESS OF BP
	LB	X,,A		:FETCH OPCODE AGAIN (BECAUSE OF ENTRY POINT)
	STB	X,LISTO,BASE,N	:SAVE OPCODE IN TABLE
	LIS	X,0
	STB	X,,A		:PLACE 0 OPCODE IN BP LOCATION
	JR	LINK		:RETURN
SBB	LR	R3,N		:THIS IS AN ENTRY POINT!!!
	SLLS	R3,2		:GENERATE INDEX TO ADDRESS TABLE
	L	A,LISTA,BASE,R3	:FETCH ADDRESS OF BP N
	CLHI	A,0		:IF A = 0 THERE IS NO BP RETURN
	JER	LINK
	LB	X,LISTO,BASE,N	:FETCH OPCODE OF INST AT BP FROM TABLE
	STB	X,,A		:RESTORE OPCODE
	LIS	X,0		:ZERO ADDRESS TABLE ENTRY
	ST	X,LISTA,BASE,R3
	JR	LINK		:RETURN
BERR	SVC	OUT,BPERR	:ISSUE ERROR MESSAGE
	JR	LINK
 : THE FOLLOWING CODE IS THE DDT INST R
R	ST	LINK,SLINK,BASE	:SAVE LINK
	JAL	LINK,VENT	:READ USER INPUT - SET REGS A X
	LIS	R0,3		:INITIALIZE OUTPUT BUFFER
	STB	R0,ROUT,BASE
	LHI	R0,20		:PUT A SPACE ' ' AT THE ENND OF THE BUFFER
	STB	R0,ROUT+3,BASE
RLOOP	LB	R2,,A		:READ BYTE AT  A
	LR	R1,R2		:SEPERATE 2 HEX DIGITS
	NHI	R2,0F		:RIGHT DIGIT
	NHI	R1,0F0		:LEFT DIGIT
	SRLS	R1,4		:RIGHT JUSTIFY LEFT DIGIT
	LB	R2,DIGITS,R2	:INDEX TO GET CHAR REPRESENTATION
	LB	R1,DIGITS,R2	:DITTO
	STB	R2,ROUT+1,BASE	:STORE INTO OUTPUT BUFFER
	STB	R1,ROUT+2,BASE
	SVC	OUT,ROUT,BASE	:GIVE OUTPUT BUFFER TO SYSTEM
	AIS	A,1		:CHECK NEXT BYTE
	CLR	A,X		:TERMINATE IF  A > X
	JLEBS	RLOOP
 :READ & WRITE BOTH EXECUTE THIS CODE!!!
REND	LR	R4,R4		:SET CC - RESTORE BP'S IF R4 = 0
	JNFS	RET		:IF REGISTERS WERE REFERENCED THEN RETURN
	LHI	R2,BPNO*4	:REPLACE BREAKPOINTS
RDPB	L	R1,LISTA-4,BASE,R2 :SEARCH ADDRESS LIST FOR NON-ZERO ENTRIES
	JEFS	RTEST		:SKIP ZERO ENTRIES
	STB	R4,,R1		:STORE ILLEGAL OPCODE AT BP
RTEST	SIS	R2,4		:INCR INDEX INTO ADDR LIST
	JNBS	RDPB		:CONTINUE SEARCH
RET	L	LINK,SLINK,BASE	:RESTORE LINK
	JR	LINK		:RETURN
 : THE FOLLOWING CODE IS THE DDT INST W
W	ST	LINK,SLINK,BASE	:SAVE LINK
	JAL	LINK,VENT	:READ USER INPUT - SET REGS A, X
WLOOP	JAL	LINK,NXTBYT	:READ USER DATA - ONE BYTE
	STB	R0,,A		:STORE IT AT A
	AIS	A,1		:CHECK NEXT BYTE ADDRESS
	CLR	A,X		:LOOP UNTIL  A > X
	JLEBS	WLOOP
	JBS	REND		:USE SAME TERMINATION PROCEEDURE AS READ
 : THE FOLLOWING CODE IS USED BY BOTH R & W TO DETERMINE ADDR OR REG
VENT	ST	LINK,ULINK,BASE	:SAVE LINK
	JAL	LINK,CHARNM	:PEEK AT NEXT CHAR
	LIS	R4,0
	SIS	R0,52		:R4 GETS 1 IF CHAR IS "R"  ELSE 0
	JNFS	VMEM
	JAL	LINK,CHARM	:IF CHAR WAS "R" READ IT!
	LIS	R4,1		:AND SET R1 TO 1
VMEM	JAL	LINK,NUM	:READ ADDRESS
	LR	A,R0
	JAL	LINK,NUM	:READ COUNT
	LR	N,R0
	L	LINK,ULINK,BASE	:RESTORE LINK
	LR	R4,R4		:SET CONDITION CODE - ZERO IF MEMORY
	JNFS	VREGS		:ADDR REFERENCED REGISTERS
	CL	A,LOW		:CHECK IF ADDR IS IN BOUNDS
	JL	VERR1
	LR	X,A		:COMPUTE LAST ADDRESS REFERENCES
	AR	X,N
	SIS	X,1
	CL	X,UPP		:CHECK IF ADDRESS IN BOUNDS
	JG	VERR1
	LHI	R2,BPNO*4	:UNDO BREAKPOINTS
	LIS	R1,BPNO-1
VUBP	L	R3,LISTA-4,BASE,R2 :SEARCH ADDRESS LIST FOR NON-ZERO ENTRIES
	JEFS	VTST
	LB	R0,LISTO,BASE,R2 :IT IS NON-ZERO - RESTORE OPCODE
	STB	R0,,R3
VTST	SIS	R1,1		:GO TO NEXT BP
	SIS	R2,4		:IS THIS THE LAST BP
	JNBS	VUBP		:LOOP
	JR	LINK		:RETURN
VREGS	CLHI	A,0F		:IS REGISTER NUMBER VALID
	JG	VERR2
	LR	X,A		:COMPUTE LAST REG NUMBER
	AR	X,N
	SIS	X,1
	CLHI	X,0F		:IS REG NUMBER VALID
	JG	VERR2
	SLLS	X,2		:COMPUTE ADDR OF LAST BYTE IN REG SAVE AREA
	AI	X,URSA,BASE	:BASE ADDR OF SAVE AREA
	SLLS	A,2		:COMPUTE FIRST BYTE ADDR IN SAVE AREA
	AI	A,URSA,BASE	:BASE ADDR OF SAVE AREA
	JR	LINK		:RETURN
VERR1	SVC	OUT,VMSG1	:MEMORY ADDR OUT OF BOUNDS
	JFS	VER
VERR2	SVC	OUT,VMSG2	:REGISTER NUMBER INVALID
VER	L	LINK,SLINK,BASE	:RETURN TO TTY HANDLER
	JR	LINK
 : THE FOLLOWING CODE IS THE DDT INST  G
G	ST	LINK,SLINK,BASE	:STORE LINK
	JAL	LINK,NUM	:GET START ADDR
	L	LINK,SLINK,BASE	:RESTORE LINK
	LIS	SB,0		:CLEAR SPACIAL BP FLAG
	CL	R0,LOW		:MAKE SURE ADDR IN BOUNDS
	JL	GERR
	CL	R0,UPP
	JG	GERR
	LHL	R1,SPSW		:PSW FLAGS - ENABLE INTERUPTS, USER MODE
	ST	R1,OLDPSW,BASE	:STORE IN PSW LOCATION
	ST	R0,OLDPSW+4,BASE :SET PSW ADDR TO START ADDR
	J	YY,BASE		:SWAP REGISTERS AND LOAD PSW
GERR	SVC	OUT,GMSG	:ISSUE ERROR MESSAGE
	JR	LINK		:RETURN
 : THE FOLLOWING CODE IS THE DDT INST  C
C	JR	LINK		:NOT YET IMPLEMENTED
 : THE FOLLOWING CODE IS THE DDT INST  I
I	LHI	NLB,-1		:NO LAST BP
	LIS	SB,0		:NOT SPECIAL BP
	LIS	R1,BPNO*4	:ZERO BP ADDR TABLE
ILOOP	ST	SB,LISTA-4,BASE,R1 :ZERO THIS ENTRY
	SIS	R1,4		:GO TO NEXT ENTRY
	JNBS	ILOOP		:LOOP
	JR	LINK		:RETURN
 : UTILITY ROUTINE  PEEK AT NEXT CHAR
CHARNM	LIS	R4,2		:SET IBUF TO 2 WHEN DONE
CM1	CLHI	IBUF,2		:IBUF = 2 THEN CHAR ALREADY IN BUFFER
	JNFS	CNM1		:GO READ A CHAR
	L	R0,INBUF,BASE	:RETURN THE CHARACTER
	LR	IBUF,R4		:SET IBUF (2 IF CHARNM, 0 IF CHARM)
	JR	LINK
CNM1	ST	LINK,TLINK,BASE	:STORE LINK
	JAL	LINK,ZCHAR	:FIND NEXT NON-DELIMITER CHAR
	LR	IBUF,R4		:SET IBUF (2 IF CHARMN, 0 IF CHARM)
	L	LINK,TLINK,BASE	:RESTORE LINK
	JR	LINK		:RETURN
 : UTILITY ROUTINE  READ NEXT CHARACTER
CHARM	LIS	R4,0		:SET IBUF TO 0 WHEN DONE
	JBS	CM1		:USE SAME CODE AS CHARMN
 : UNTILITY ROUTINE TO READ A NUMBER
NUM	ST	LINK,TLINK,BASE	:STORE LINK
	CLHI	IBUF,2		:IS THE NEXT CHAR IN THE BIFFER
	JNFS	NUM0		:NO
	L	R0,INBUF,BASE	:READ CHAR IN BUFFER
	JFS	NUM1
NUM0	JAL	LINK,ZCHAR	:READ NEXT NON-DELIMITER CHAR
NUM1	JAL	LINK,ZDTST	:TEST IF CHAR IS DIGIT
	JFS	NUMERR		:NOT A DIGIT - GIVE ERROR MESSAGE
	LIS	IBUF,0		:INDICATE NO CHAR IN BUFFER
	L	R1,R0		:PUT FIRST DIGIT INTO ACCUMULATOR
NUM2	JAL	LINK,ZDIGIT	:READ NEXT CHAR SKIP IF DIGIT
	JFS	NEXT		:END OF NUMBER - EXIT
	SLLS	R1,4		:SHIFT ACC.
	AR	R1,R0		:ADD NEW DIGIT
	JBS	NUM2		:GET NEXT DIGIT
NUMERR	LIS	IBUF,2		:INDICATE CHAR IN BUFFER - RETURN ZERO
	LIS	R1,0		:RETURN ZERO
NEXT	LR	R0,R1		:PLACE RESULT IN R0
	L	LINK,TLINK,BASE	:RESTORE LINK
	JR	LINK		:RETURN
 : UTILITY ROUTINE TO READ A BYTE FROM THE USER
NXTBYT	ST	LINK,TLINK,BASE	:SAVE LINK
	CLHI	IBUF,2		:CHECK IF CHAR IN BUFFER
	JNFS	NXT0		:NO - GO READ ONE
	LB	R0,INBUF	:READ CHAR FROM BUFFER
	JFS	NXT
NXT0	JAL	LINK,ZCHAR	:GET A CHAR
NXT	JAL	LINK,ZDTST	:IS IT A DIGIT
	JFS	NX1		:NO - RETURN 0
	LR	R4,R0		:ACCUMULATE IN R4
	LIS	IBUF,0		:INDICATE NO CHAR IN BUFFER
	JAL	LINK,ZNXTC	:GET NEXT CHAR
	JFS	NX3		:IT WAS A DELIMITER
	JAL	LINK,ZDTST	:IS IT A DIGIT
	JFS	NX2		:NO - LEAVE IT IN THE BUFFER
	SLLS	R4,4		:ACCUM RESULT IN R4
	AR	R0,R4
NX4	L	LINK,TLINK,BASE	:RESTORE LINK
	JR	LINK		:RETURN
NX1	LIS	R4,0		:NOT NUMERIC - GIVE ZERO RESULT
NX2	LIS	IBUF,2		:INNDICATE CHAR IN BUFFER
NX3	LR	R0,R4		:RESULT SO FAR IS RESULT
	JBS	NX4		:RETURN
 : UTILITY ROUTINE TO READ NEXT NON-DELIMITER CHAR
ZCHAR	ST	LINK,VLINK,BASE	:SAVE LINK
ZC1	JAL	LINK,ZNXTC	:GET NEXT CHAR
	JBS	ZC1		:IT'S A DELIMITER - GET NEXT CHAR
	L	LINK,VLINK,BASE	:RESTORE LINK
	JR	LINK		:RETURN
 : UNTILITY ROUTINE TO READ NEXT CHAR - SKIP RETURN IF NON-DELIMITER
ZNXTC	SVC	IN,INBUF	:READ A CHAR
	LIS	R1,DLEN		:NUMBER OF DELIMITER CHARS
	LB	R0,INBUF	:GET CHAR JUST READ
ZN1	CLB	R0,DLIST-1,R1	:COMPARE TO A DELIMITER
	JER	LINK		:RETURN IF DELIMITER
	SIS	R1,1		:CHECK NEXT DELIMITER
	JNBS	ZN1		:LOOP IF ANY MORE DELIMITERS
	AIS	LINK,2		:SKIP RETURN
	JR	LINK		:RETURN
 : UNTILITY ROUTINE TO READ A DIGIT - SKIP RETURN IF DIGIT
ZDIGIT	SVC	IN,INBUF	:READ A CHAR
	LB	R0,INBUF	:LOAD THAT CHAR
ZDTST	CLHI	R0,30		:IS IT "0" - ENTRY POINT FOR DIGIT TEST
	JLR	LINK		:RETURN IF LESS THAN "0"
	CLHI	R0,39		:IS IF "9"
	JLFS	ZDSRT1		:LESS THAN "9" THEN A GOOD DIGIT
	CLHI	R0,41		:IS IT "A"
	JLR	LINK		:RETURN IF LESS THAN "A"
	CLHI	R0,46		:IS IF "F"
	JGR	LINK		:RETURN IF GREATER THAN "F"
	SI	R0,4B		:"A" + 0A
	J	RDSRT		:SKIP RETTURN
RDSRT1	SI	R0,30		:"0"
RDSRT	AIS	LINK,2		:SET UP SKIP RETURN
	JR	LINK		:RETURN
	END
