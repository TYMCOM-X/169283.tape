INTEGER OBJ,HISTRY,SPCALC,FLUSH,BRIEF,FRSTSG,EDITL,CURRGO,EXIST,
  CMND,CURCMP,ERRCNT,COMPL,ACTVL,PRNTL,FSTITM,CLRITM,HASH,
  SONPTR,SONS,TREE,BUFITM,ITMLOC,ITMDIM,TYPE,OVLNO,FMTPTR
REAL ITMMIN,ITMMAX
STRING INPUT(4),ITMNAM(4)
STRING SBSNAM(8),OVL(8),INDOVL(8),DICFIL(8),FMTFIL(8),ATRFIL(8)
*    FROM RUNCOMDS
STRING MOD5XB(3)(8)
INTEGER CTYPE,CURITM,P1,P2,COMAND,CEXEC,GO,SYSTEM,STOP,
  CHAR,DIM,VARYNG,CHECK,HLOOK
REAL VALUE(100),MINMIN,MAXMAX
STRING END(4),OVLS(10)(4),COMMA(4),COLON(4),EQUAL(4),AMPER(4),DICTF(4)
STRING DBLANK(8),FTEMP(8),DSDICT(8),DS(8)
LOGICAL EQ,TSTBIT
COMMON FV(3000)
COMMON ITEM,OBJ,SBSNAM,LSBNAM,HISTRY(100),
 SPCALC,NOPRNT,FLUSH,ITMCHK,BRIEF,
 INPUT(21),LINPUT,FRSTSG,LASTSG,NXSTRT,
 EDITL(100),LEDITL,OVL,INDOVL,INDIR
COMMON CURRGO,LASTGO,CMND,CURCMP,ERRCNT,
 COMPL(100),LCOMPL,ACTVL(100),LACTVL,PRNTL(100),LPRNTL,
 NITEMS,MULTRE,EXIST(3),FSTITM,LSTITM,CLRITM,
 HASH(199),SONPTR(25),SONS(65),TREE(100)
COMMON DICFIL,FMTFIL,ATRFIL,
 BUFITM,ITMLOC,ITMMOD,ITMDIM,ITMTYP,ITMIO,ITMOVL,
 ITMFMT,ITMMIN,ITMMAX,ITMNAM(7),LITNAM
DATA OVLS/4*" ",2*"AUXC","DICT",3*"AUXC"/
DATA DBLANK,DSDICT,DS/' ',DSDICT,DS/
DATA MXLSBN,COMAND,CEXEC,GO,SYSTEM,STOP/6,10,102,1,-2,3/
DATA LVALUE,CHECK,INT,CHAR/100,103,2,3/
DATA NOINPT,MODCON,MODCHK,VARYNG/1,16,8,64/
DATA END,LEND/"END",1/
DATA COLON,EQUAL,COMMA,AMPER/":","=",",","&"/
DATA DICTF/"DF"/,LDICTF/2/
DATA MINMIN,MAXMAX,EPS/-1.E35,1.E35,.0001/
DATA LHASH/199/
DATA N0,N1,N3,N4,N8,N10,N12,N16/0,1,3,4,8,10,12,16/
DATA N28,N32,N50,N100,N128/28,32,50,100,128/
DATA N1000,N10T6,M4/1000,1000000,-4/
DATA ISTAT,MOD5XB/2951,"5XBDF","5XBDATDF","TCOEDF"/
*
* CHECK FOR RETURN FROM EXECUTING LAST ITEM
*
IF(LSTITM.LT.N0)GOTO 610
*
* IF NOT RETURNING FROM BACK END GO GET NEXT STATEMENT
*
IF(CMND.LE.N100)GOTO 200
*
* RETURNING FROM GO EXECUTION, COMMAND EXECUTION OR
* MODCON OR MODCHECK (CMND=101,102,103 RESPECTIVELY)
*
CTYPE=CMND-N100
GOTO(10,50,150),CTYPE
*
* RETURNING FROM GO -- CHECK FOR SUSPENDED CALCULATIONS
* AND INTERNAL EDIT
*
10   IF(SPCALC.NE.N0)GOTO 70
IF(LEDITL.NE.N0)GOTO 100
*
* NORMAL RETURN FROM GO -- FLUSH PRINT LIST, RESET ALL NEGATIVE
* VALUED HISTRY CELLS TO POSITIVE, AND REINITIALIZE FLAGS
*
CALL PUBL(PRNTL,LPRNTL)
IF(EDITL(100).EQ.N1)GOTO 40
20   DO 30 CURITM=N1,NITEMS
30   HISTRY(CURITM)=IABS(HISTRY(CURITM))
40   LASTGO=CURRGO
EDITL(100)=N0
CURRGO=N0
50   LCOMPL=N0
CURITM=N0
CMND=N0
OBJ=N0
GOTO 200
*
* CALCULATIONS HAVE BEEN SUSPENDED
*
* FLUSH PRINT LIST IF ASKED (FLUSH.NE.0) AND PRINT
* MESSAGE IF ASKED (SPCALC.GT.1)
*
70   IF(FLUSH.NE.N0)CALL PUBL(PRNTL,LPRNTL)
FLUSH=N0
IF(SPCALC.GT.N1)GOTO 80
PRINT 73
73   FORMAT("0CALCULATIONS SUSPENDED")
80   SPCALC=N0
*
* SHORTEN ACTIVE LIST TO CONTAIN NO ITEMS AT OR ABOVE
* THE ITEM WHICH CAUSED CALCULATIONS TO BE SUSPENDED
*
CALL SHLIST(ITEM,ACTVL,LACTVL,N0,HISTRY)
GOTO 20
*
* AN INTERNAL EDIT HAS BEEN MADE
*
* FLUSH PRINT LIST IF ASKED (FLUSH.NE.0) 
*
100  IF(FLUSH.NE.N0)CALL PUBL(PRNTL,LPRNTL)
FLUSH=N0
*
* SHORTEN ACTIVE LIST TO CONTAIN NO ITEMS AT OR ABOVE
* THE ITEM WHICH CAUSED THE INTERNAL EDIT
*
CALL SHLIST(ITEM,ACTVL,LACTVL,N0,HISTRY)
*
* RESET ALL NEGATIVE HISTRY VALUES TO BE POSITIVE
*
DO 110 CURITM=N1,NITEMS
110  HISTRY(CURITM)=IABS(HISTRY(CURITM))
*
* MAKE ALL EDITS IN THE EDIT LIST AND SET UP FOR ANOTHER
* GO-ANALYSIS WITH THE SAME OBJECT
*
120  DO 130 I=N1,LEDITL
CURITM=EDITL(I)
130  HISTRY(CURITM)=M4
LEDITL=N0
LASTGO=CURRGO
CURRGO=N0
OBJ=N0
CMND=N1
GO TO 550
*
* RETURNING FROM MODCON OR MODCHECK
*
* IF RESULT ACCEPTED (ITMCHK=1) SET HISTRY ACCORDINGLY
* IF RESULT REJECTED (ITMCHK=0) SET HISTRY ACCORDINGLY
*
150  IF(ITMCHK.EQ.N0)GOTO 170
CALL SETHST(ITEM,HISTRY,ERRCNT)
GOTO 180
170  CALL SETERR(ITEM,HISTRY,ERRCNT)
180  ITMCHK=N0
GOTO 50
*
* CONTINUED IN DATA2DS
* CONTINUED FROM DATA1DS
*
* GET NEXT STATEMENT FROM INPUT STRING
* NON-STANDARD RETURN GOES TO GET MORE INPUT
*
200  CALL SCOPE(INPUT,NXSTRT,LINPUT,FRSTSG,LASTSG,
 DBLANK,N1,DBLANK,N1,COLON,N1,$5000)
CMND=N0
OBJ=N0
*
* STATEMENT MAY BE OF FORM --
*  1. ITEM NAME = VALUE(S)
*  2. ITEM OR SYSTEM COMMAND NAME BLANK OBJECT
*  3. ITEM OR SYSTEM COMMAND NAME
*  4. NEW MODULE NAME
*
* TRY TO BREAK OUT NAME WITH EQUAL SIGN
*
KF=FRSTSG
CALL SCOPE(INPUT,KF,LASTSG,P1,P2,N0,N0,DBLANK,N1,EQUAL,N1,$210)
CURITM=HLOOK(INPUT,P1,P2,HASH,LHASH)
*
* CURITM = 0 ==> NAME NOT IN HASH TABLE
*   < 0 ==> NAME IS OF SYSTEM COMMAND
*   > 0 ==> NAME IS USER DEFINED ITEM NAME
*
IF(CURITM)205,210,1000
*
* SYSTEM COMMAND -- SET P1 TO POINT TO = AND GO TO COMMAND
* SCANNER
*
205  P1=KF-N1
GOTO 215
*
* SEE IF FIRST WORD IS COMMAND NAME
*
210  P1=FRSTSG
P2=INDEX(INPUT,P1,LASTSG-P1+N1,DBLANK,N1,N1)+P1-N1
IF(P2.LT.P1)GOTO 230
CURITM=HLOOK(INPUT,P1,P2,HASH,LHASH)
IF(CURITM.EQ.N0)GOTO 230
P1=P2
*
* IF COMMAND IS 'SYSTEM' OBJECT NOT IN HASH TABLE BUT
* IS NEW MODULE NAME
*
215  IF(CURITM.EQ.SYSTEM)GOTO 255
*
* TRIM LEADING BLANKS AND LOOK UP OBJECT IN HASH TABLE
*
220  P1=P1+N1
IF(P1.GT.LASTSG)GOTO 9900
IF(EQ(INPUT,P1,DBLANK,N1,N1))GOTO 220
OBJ=HLOOK(INPUT,P1,LASTSG,HASH,LHASH)
IF(OBJ.NE.N0)GOTO 240
*
* OBJECT NOT ITEM NAME -- IS IT NUMBER
*
CALL NUMB(INPUT,P1,LASTSG,VAL,$225)
OBJ=VAL
GOTO 240
*
* OBJECT NOT RECOGNIZABLE -- IS THIS REALLY A MODCON ITEM
*
225  IF(CURITM.LE.N0)GOTO 9900
CALL FILE(CURITM)
IF(TSTBIT(ITMIO,MODCON))GOTO 800
GOTO 9900
*
* TRY TO MATCH WHOLE STATEMENT AS KEY WORD
*
230  CURITM=HLOOK(INPUT,FRSTSG,LASTSG,HASH,LHASH)
240  IF(CURITM)500,250,300
*
* TRY TO MATCH WHOLE STATEMENT AS NEW MODULE NAME
* 
250  P1=FRSTSG-N1
255  FTEMP=DBLANK
DO 270 I=N1,MXLSBN
260  P1=P1+N1
IF(P1.GT.LASTSG)GOTO 280
IF(EQ(INPUT,P1,DBLANK,N1,N1))GOTO 260
270  CALL MOVE(INPUT,P1,FTEMP,I,N1)
I=MXLSBN+N1
280  CALL MOVE(DICTF,N1,FTEMP,I,LDICTF)
*
* IF FILE WHOSE NAME IS IN FTEMP EXISTS IT IS THE DICTIONARY FILE
* OF A MODULE
*
CALL FILE#CHK(FTEMP,INFO,N0,$9900)
*
* WE HAVE A NEW MODULE NAME RESET SBSNAM AND GO TO DICT
* OVERLAY TO READ IN DICTIONARY AND REINITIALIZE
*
IF(FTEMP.NE.MOD5XB(1).AND.FTEMP.NE.MOD5XB(2).AND.FTEMP.NE.MOD5XB(3))
 GOTO 9900
SBSNAM=DBLANK
LSBNAM=I-N1
CALL MOVE(FTEMP,N1,SBSNAM,N1,LSBNAM)
CMND=-SYSTEM
OVL=DSDICT
GOTO 10010
*
* IF ITEM MATCHED IS INDEED A COMMAND SET UP A DUMMY COMP LIST AND
* EXECUTE IT
*
300  CALL FILE(CURITM)
IF(ITMTYP.NE.COMAND)GOTO 9900
310  LCOMPL=N1
COMPL(LCOMPL)=N10T6+N1000*ITMOVL+CURITM
CURCMP=N0
II=IABS(CURITM)
 CALL GET#C(II,FV(ISTAT),ICNT)
ICNT=ICNT+1
 CALL PUT#C(II,FV(ISTAT),ICNT)
CMND=CEXEC
GOTO 10000
*
* MATCHED A SYSTEM COMMAND
*
500  CMND=-CURITM
510 GOTO(520,9900,600,600,700,700,700,700,700,700),CMND
*
* GO
*
520  IF(OBJ)530,550,540
*
* GO SYSTEM COMMAND -- REPLACE GO WITH OBJECT AND TRY AGAIN
*
530 CMND=IABS(OBJ)
OBJ=N0
IF(CMND.EQ.GO)GOTO 9900
GOTO 510
*
* GO ITEM NAME -- CHECK IF ITEM IS COMMAND
*
540  CALL FILE(OBJ)
IF(ITMTYP.NE.COMAND)GOTO 550
*
* ITEM IS COMMAND -- SET LASTGO TO FORCE NEW GO-ANALYSIS NEXT TIME
* AND GO EXECUTE COMMAND
*
LASTGO=N100
CURITM=OBJ
GOTO 310
*
* NORMAL GO -- CALL GO-ANALYSIS
* NON-STANDARD RETURN TAKEN IF GO-ANALYSIS FAILS
*
550 PRINT 9999
9999 FORMAT("0")
CALL DSGOAN($200)
GOTO 10000
*
* STOP OR RETURN
*
600  OBJ=CMND
IF(LSTITM.EQ.N0)GOTO 610
*
* EXECUTE LAST ITEM
*
CALL FILE(LSTITM)
CURITM=LSTITM
LSTITM=-LSTITM
GOTO 310
*
* RETURNING FROM EXECUTION OF LAST ITEM OR NO LAST ITEM
*
610  IF(OBJ.EQ.STOP)CALL S#EXIT(END,LEND)
CALL SOFT#END
*
* SYSTEM COMMANDS THAT ARE HANDLED IN ANOTHER OVERLAY
*
700  OVL=DS
CALL MOVE(OVLS(CMND),N1,OVL,N3,N4)
GOTO 10010
*
* EXIT FOR MODCON OR MODCHECK
*
800  FRSTSG=P1
810  LCOMPL=N1
COMPL(LCOMPL)=N10T6+N1000*ITMOVL+CURITM
CURCMP=N0
CMND=CHECK
ITMCHK=N1
GOTO 10000
*
* CONTINUED IN DATA3DS
* CONTINUED FROM DATA2DS
*
* CONVERT ITEM'S VALUE(S)
*
1000 P1=KF-N1
*
* TRIM LEADING BLANKS
*
1010 P1=P1+N1
IF(EQ(INPUT,P1,DBLANK,N1,N1))GOTO 1010
CALL FILE(CURITM)
*
* CHECK FOR NOINPUT, AND MODCON
*
IF(TSTBIT(ITMIO,NOINPT))GOTO 9910
IF(TSTBIT(ITMIO,MODCON))GOTO 800
IF(ITMMOD.EQ.CHAR)GOTO 1200
*
* CONVERT NUMERIC VALUE(S)
*
NVALS=N0
LASTSG=LASTSG+N1
CALL MOVE(COMMA,N1,INPUT,LASTSG,N1)
*
* BREAK OUT NEXT VALUE
*
1100 CALL SCOPE(INPUT,P1,LASTSG,KF,KL,DBLANK,N1,DBLANK,N1,
 COMMA,N1,$1120)
NVALS=NVALS+N1
IF(NVALS.GT.LVALUE)GOTO 9000
CALL NUMB(INPUT,KF,KL,VALUE(NVALS),$9010)
GOTO 1100
*
* ALL VALUES CONVERTED -- CHECK MIN AND MAX
*
1120 IF(NVALS.EQ.N0)GOTO 9020
XMIN=ITMMIN-EPS
XMAX=ITMMAX+EPS
DO 1130 I=N1,NVALS
VAL=VALUE(I)
IF(VAL.LT.XMIN.OR.VAL.GT.XMAX)GOTO 9030
1130 CONTINUE
*
* CHECK IF NUMBER OF VALUES IS CORRECT FOR FIXED LENGTH ITEMS
* AND CONSISTENT FOR VARIABLE LENGTH ITEMS
*
IF(TSTBIT(ITMIO,VARYNG))GOTO 1140
IF(NVALS.NE.ITMDIM)GOTO 9050
GOTO 1150
1140 IF(NVALS.GT.ITMDIM)GOTO 9060
*
* ADJUST CURRENT LENGTH
*
IS1=ITMLOC+ITMDIM
CALL MOVE(NVALS,N1,FV(IS1),N1,N4)
1150 IF(ITMMOD.NE.INT)GOTO 1170
*
* CHECK THAT ALL VALUES ARE INTEGERS AND FIX THEM
*
DO 1160 I=N1,NVALS
VAL=VALUE(I)
IVAL=VAL+SIGN(EPS,VAL)
FVAL=IVAL
IF(IABS(VAL-FVAL).GT.EPS)GOTO 9070
1160 CALL MOVE(IVAL,N1,VALUE(I),N1,N4)
*
* ALL CHECKS PASSED -- MOVE VALUES INTO PROPER PLACE IN COMMON
*
1170 DO 1180 I=N1,NVALS
IS1=ITMLOC+I-N1
1180 FV(IS1)=VALUE(I)
GOTO 1250
*
* CONVERT CHARACTER VALUE
*
1200 L=LASTSG-P1+N1
IF(L.GT.ITMDIM)GOTO 9080
IF(.NOT.TSTBIT(ITMIO,VARYNG))GOTO 1210
*
* ADJUST CURRENT LENGTH
*
IS1=ITMLOC+(ITMDIM+N3)/N4
CALL MOVE(L,N1,FV(IS1),N1,N4)
*
* PUT VALUE AWAY IN PROPER PLACE IN COMMON
*
1210 CALL MOVE(INPUT,P1,FV(ITMLOC),N1,L)
IF(L.EQ.ITMDIM)GOTO 1250
*
* PAD VALUE WITH BLANKS
*
L=L+N1
CALL MOVE(DBLANK,N1,FV(ITMLOC),L,N1)
CALL MOVE(FV(ITMLOC),L,FV(ITMLOC),L+N1,ITMDIM-L)
*
* CHECK FOR MODCHECK REQUIREMENT
*
1250 IF(TSTBIT(ITMIO,MODCHK))GOTO 810
*
* ALL SUCCESSFUL -- SET HISTRY VALUE ACCORDINGLY
*
CALL SETHST(CURITM,HISTRY,ERRCNT)
GOTO 200
*
* GET NEXT LINE OF INPUT
*
5000 IF(LSBNAM)5020,5010,5020
5010 PRINT 5011
5011 FORMAT(" SYSTEM")
GOTO 5030
5020 PRINT 5021
5021 FORMAT("0REQUEST")
5030 CALL #READ#(INPUT,LINPUT)
LINPUT=LINPUT+N1
CALL MOVE(COLON,N1,INPUT,LINPUT,N1)
NXSTRT=N1
GOTO 200
*
* ERROR DIAGNOSTICS
*
9000 PRINT 9001
9001 FORMAT(" MORE THAN 100 VALUES GIVEN FOR ")
GOTO 9098
9010 PRINT 9011
9011 FORMAT(" '")
CALL STRPRINT(AMPER,INPUT,KF,KL,N12)
PRINT 9012
9012 FORMAT("&' MUST BE NUMERIC IN VALUE OF ")
GOTO 9098
9020 PRINT 9021
9021 FORMAT(" NO VALUE GIVEN FOR ")
GOTO 9098
9030 IF(NVALS-N1)9900,9031,9033
9031 PRINT 9032
9032 FORMAT(" THE VALUE OF ")
GOTO 9035
9033 PRINT 9034
9034 FORMAT(" ALL VALUES OF ")
9035 CALL STRPRINT(AMPER,ITMNAM,N1,LITNAM,N28)
PRINT 9036
9036 FORMAT("& MUST BE ")
IF(ITMMIN.NE.MINMIN)GOTO 9038
PRINT 9037,ITMMAX
9037 FORMAT("&LESS THAN",F12.2//)
GOTO 9099
9038 IF(ITMMAX.NE.MAXMAX)GOTO 9040
PRINT 9039,ITMMIN
9039 FORMAT("&GREATER THAN",F12.2//)
GOTO 9099
9040 PRINT 9041,ITMMIN,ITMMAX
9041 FORMAT("&BETWEEN",F12.2," AND",F12.2//)
GOTO 9099
9050 PRINT 9051,ITMDIM
9051 FORMAT(" THERE MUST BE",I3," NUMBERS IN THE VALUE OF ")
GOTO 9098
9060 PRINT 9061,ITMDIM
9061 FORMAT(" THERE CAN BE AT MOST",I3," NUMBERS IN THE VALUE OF ")
GOTO 9098
9070 IF(NVALS.GT.N1)GOTO 9071
PRINT 9032
GOTO 9072
9071 PRINT 9034
9072 CALL STRPRINT(AMPER,ITMNAM,N1,LITNAM,N28)
IF(NVALS.GT.N1)GOTO 9074
PRINT 9073
9073 FORMAT("& MUST BE A WHOLE NUMBER"//)
GOTO 9099
9074 PRINT 9075
9075 FORMAT("& MUST BE WHOLE NUMBERS"//)
GOTO 9099
9080 PRINT 9081,ITMDIM
9081 FORMAT(" THERE CAN BE AT MOST",I3," CHARACTERS IN THE VALUE OF ")
GOTO 9098
9098 CALL STRPRINT(AMPER,ITMNAM,N1,LITNAM,N28)
PRINT 9097
9097 FORMAT(" ")
9099 CALL SETERR(CURITM,HISTRY,ERRCNT)
GOTO 200
9900 PRINT 9901
9901nRMAT(" '")
CALL STRPRINT(AMPER,INPUT,FRSTSG,LASTSG,N50)
PRINT 9902
9902 FORMAT("&' NOT RECOGNIZED")
GOTO 200
9910 PRINT 9911
9911 FORMAT(" YOU MAY NOT ASSIGN A VALUE TO ")
CALL STRPRINT(AMPER,ITMNAM,N1,LITNAM,N28)
PRINT 9097
GOTO 200
10000 CLOSEFILE ATRFIL
 CLOSEFILE FMTFIL
10010 RETURN
 END
    