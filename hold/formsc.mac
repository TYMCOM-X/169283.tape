UNIVERSAL FORMSC %2.(120)	UNIVERSAL FILE TO ASSEMBLE THE FIX/FLOAT FUNCTIONS
SUBTTL	D. TODD /DRT 15-FEB-1973
;***COPYRIGHT 1972,1973 DIGITAL EQUIPMENT CORP., MAYNARD MASS.***
	SEARCH	FORPRM
IF1,<			;PASS 1 ASSEMBLY ONLY
	DEFINE	FLT(X)<
	ENTRY	FLT.'X
	SIXBIT	/FLT.'X/
FLT.'X:
IFE CPU-KA10,<
	HLRE	X+1,X	;COPY THE HI HALT OF X TO LOW X+1
	HLL	X,X+1	;FILL UPPER PART OF X WITH THE SIGH
	FSC	X,233	;FLOAT THE LOW HALT OF THE INTEGER
	SKIPGE	X	;FOR NEGATIVE NUMBERS
	AOJE	X+1,FLT.XT	;CHANGE HIGH PART TO 2'S COMPLEMENT
	FSC	X+1,255	;FLOAT THE HIGH PART
	FADR	X,X+1	;COMBINE THE TWO PARTS
>
IFE CPU-KI10,<
	FLTR	X,X	;USE THE HARDWARE
>
FLT.XT:	POPJ	P,	;RETURN X=THE FLOATING POINT NUMBER
>
	DEFINE	IFX(X)<
	ENTRY	IFX.'X
	SIXBIT	/IFX.'X/
IFX.'X:
IFE CPU-KA10,<
	MULI	X,400		;SEPERATE THE FRACTION AND EXPONENT
	EXCH	X,X+1		;PUT PARTICAL RESULT IN X
	JUMPGE	X+1,IFX.XT	;JUMP IF POSITIVE
	TRC	X+1,-1	;NEGATE THE EXPONENT
	MOVNS	X		;POSITIVE FRACTION
IFX.XT:	ASH	X,-243(X+1)	;USE EXPONENT AS INDEX
	SKIPGE	X+1		;SKIP IF POSITIVE
	MOVNS	X		;NEGATE THE RESULT
>
IFE CPU-KI10,<
	FIX	X,X
>
	POPJ	P,		;RETRURN X=FIXED NUMBER
>
>		;END OF IF1,
	PRGEND
TITLE	FLOAT 	%2.(120) ;FROM LIB40 VERSION V.32(415)	INTEGER TO REAL CONVERSION
SUBTTL	D. TODD /DRT 15-FEB-1973
;***COPYRIGHT 1972,1973 DIGITAL EQUIPMENT CORP., MAYNARD MASS.***

;36 BIT FLOAT FUNCTION
;CONVERTS A SIGNED FIXED POINT INTEGER TO FLOATING POINT
;BY BREAKING THE INTEGER INTO HIGH ORDER AND LOW ORDER
;FRACTIONS, CALCULATING AN EXPONENT, THEN ADDING THE TWO
;TOGETHER. SINGLE CONVERSION.

;THE ROUTINE IS CALLED AS FOLLOWS:
;	JSA	Q, FLOAT
;	EXP	ARG
;THE ANSWER IS RETURNED IN ACCUMULATOR A

	SEARCH	FORPRM
A=0
B=1
C=2
D=3
E=4
F=5
G=6
Q=16
P=17

	HELLO	(FLOAT,.)			;ENTRY TO FLOAT ROUTINE
	MOVE	T0,@(L)	;GET THE ARGUMENT
	PJRST	FLT.0##		;USE FLT.0 ROUTINE
	PRGEND
TITLE	IFIX 	%2.(120) ;FROM LIB40 VERSION V.032(415)	REAL TO INTEGER CONVERSION
SUBTTL	D. TODD /DRT 15-FEB-1973		ED YOURDON/KK/TWE/DMN
;***COPYRIGHT 1972,1973 DIGITAL EQUIPMENT CORP., MAYNARD MASS.***

;36 BIT FIX FUNCTION
;AN INTEGER RESULT IS OBTAINED BY SEPARATING FRACTION AND
;EXPONENT. THE FRACTION IS SHIFTED N PLACES RIGHT, WHERE
;N = 43 - (EXPONENT-200) (OCTAL)

;THE CALLING SEQUENCE FOR THE ROUTINE IS AS FOLLOWS:
;	JSA	Q, IFIX
;	EXP	ARG
;OR
;	JSA	Q,INT
;	EXP	ARG

;THE ANSWER IS RETURNED IN ACCUMULATOR A

	SEARCH	FORPRM
A=0
B=1
C=2
D=3
E=4
F=5
G=6
Q=16
P=17

	HELLO	(INT,.)			;ENTRY TO INT ROUTINE.
	JRST	IFIX1		;GO TO MAIN ROUTINE.

	HELLO	(IFIX,.)			;ENTRY TO IFIX ROUTINE
IFIX1:
	MOVE	T0,@(L)		;GET THE ARGUMENT
	PJRST	IFX.0##		;USE IFX.0
	PRGEND
TITLE FLT.0
SEARCH FORMSC,FORPRM
FLT 0
PRGEND
 
 
TITLE FLT.1
SEARCH FORMSC,FORPRM
FLT 1
PRGEND
 
 
TITLE FLT.2
SEARCH FORMSC,FORPRM
FLT 2
PRGEND
 
 
TITLE FLT.3
SEARCH FORMSC,FORPRM
FLT 3
PRGEND
 
 
TITLE FLT.4
SEARCH FORMSC,FORPRM
FLT 4
PRGEND
 
 
TITLE FLT.5
SEARCH FORMSC,FORPRM
FLT 5
PRGEND
 
 
TITLE FLT.6
SEARCH FORMSC,FORPRM
FLT 6
PRGEND
 
 
TITLE FLT.7
SEARCH FORMSC,FORPRM
FLT 7
PRGEND
 
 
TITLE FLT.10
SEARCH FORMSC,FORPRM
FLT 10
PRGEND
 
 
TITLE FLT.11
SEARCH FORMSC,FORPRM
FLT 11
PRGEND
 
 
TITLE FLT.12
SEARCH FORMSC,FORPRM
FLT 12
PRGEND
 
 
TITLE FLT.13
SEARCH FORMSC,FORPRM
FLT 13
PRGEND
 
 
TITLE FLT.14
SEARCH FORMSC,FORPRM
FLT 14
PRGEND
 
 
TITLE FLT.15
SEARCH FORMSC,FORPRM
FLT 15
PRGEND
 
 
TITLE IFX.0
SEARCH FORMSC,FORPRM
IFX 0
PRGEND
 
 
TITLE IFX.1
SEARCH FORMSC,FORPRM
IFX 1
PRGEND
 
 
TITLE IFX.2
SEARCH FORMSC,FORPRM
IFX 2
PRGEND
 
 
TITLE IFX.3
SEARCH FORMSC,FORPRM
IFX 3
PRGEND
 
 
TITLE IFX.4
SEARCH FORMSC,FORPRM
IFX 4
PRGEND
 
 
TITLE IFX.5
SEARCH FORMSC,FORPRM
IFX 5
PRGEND
 
 
TITLE IFX.6
SEARCH FORMSC,FORPRM
IFX 6
PRGEND
 
 
TITLE IFX.7
SEARCH FORMSC,FORPRM
IFX 7
PRGEND
 
 
TITLE IFX.10
SEARCH FORMSC,FORPRM
IFX 10
PRGEND
 
 
TITLE IFX.11
SEARCH FORMSC,FORPRM
IFX 11
PRGEND
 
 
TITLE IFX.12
SEARCH FORMSC,FORPRM
IFX 12
PRGEND
 
 
TITLE IFX.13
SEARCH FORMSC,FORPRM
IFX 13
PRGEND
 
 
TITLE IFX.14
SEARCH FORMSC,FORPRM
IFX 14
PRGEND
 
 
TITLE IFX.15
SEARCH FORMSC,FORPRM
IFX 15
PRGEND
 
 
	TITLE	ADJ1.	%3.(142)

	SEARCH FORPRM

;AC ASSIGNMENTS
ARG==L		;ARG POINTER

TEMOFF==T0	;HOLDS OFFSET COMPUTATION
;T1==1	;HOLDS LOOP DOUNTER (DIMENSIONALITY)
;T2==2		;HOLDS MULTIPLIER COMPUTED
TABREG==T3	;HOLDS DESTROYED ARG POINTER


	;THE FOLLOWING ALGORITHM IS IMPLEMENTED TO
	;COMPUTE ARRAY FACTORS, OFFSET AND SIZE FOR THE
	;SPECIAL CASE WHEN ALL LOWER BOUNDS ARE A 
	;CONSTANT 1 AND ALL DIMENSIONS ARE ADJUSTABLE.
	;MULT(I) ARE MULTIPLIERS
	;U(I) ARE UPPER BOUNDS (EQUIVALENT TO RANGE)

	;OFFSET=MULT(1)
	;ARRAYSIZ=MULT(1)
	;DO 10 I=2,NUMBER OF DIMENSIONS-1
	;ARRAYSIZ=ARRAYSIZ*U(I-1)
	;MULT(I)=MULT(I-1)*U(I-1)
	;OFFSET=OFFSET+MULT(I)
;10	CONTINUE
	;OFFSET=-OFFSET+BASE ADDRESS OF ARRAY

	;THE PARAMTERS PASSED ARE (INORDER):
	;POINTER TO NUMBER OF DIMENSIONS
	;POINTER TO TEMP FOR ARRAYSIZ
	;BASE ADDRESS OF ARRAY
	;POINTER TO TEMP FOR OFFSET
	;MULT(1)
	;U(1)
	;MULT(2)
	;U(2)
	;	.
	;	.
	;	.
	;MULT(N)
	;U(N)

	;**NOTE THAT THE DOUBLE PRECISION/SINGLE PRECISION
	;IS HANDLED BY PASSING A 2/1 AS MULT(1).

	HELLO	(ADJ1.)
	PUSH	P,T2		;SAVE REGISTERS USED
	PUSH	P,TABREG	;

	MOVE	T1,@0(ARG)	;FETCH DIMENSIONALITY
	MOVE	TABREG,ARG	;COPY ARG REGISTER
	MOVE	TEMOFF,@4(ARG)	;GET OFFSET WITH MULT(1)
	MOVE	T2,TEMOFF	;GET MULT(1) WITH MULT(1)
	MOVEM	T2,@1(ARG)	;INITIALIZE ARRAYSIZ
LOOP1:	SOJLE	T1,LUPDUN	;QUIT IF DONE
	MOVE	T2,@5(TABREG)	;FETCH U(I-1)
	IMULM	T2,@1(ARG)	;MULTIPLY INTO ARRAYSIZ
	IMUL	T2,@4(TABREG)	;MULT BY MULT(I-1)
	MOVEM	T2,@6(TABREG)	;FORMING MULT(I)
	ADDI	TEMOFF,0(T2)	;KEEP SUM OF OFFSET FACTORS
	ADDI	TABREG,2	;ADVANCE POINTER
	JRST	LOOP1		;GO AROUND AGAIN

LUPDUN:	MOVN	TEMOFF,TEMOFF	;NEGATE OFFSET
	ADDI	TEMOFF,@2(ARG)	;ADD ARRAY BASE ADDRESS
	MOVEM	TEMOFF,@3(ARG)	;STORE VALUE OF OFFSET
	MOVE	T2,@5(TABREG)	;FETCH U(I) FOR LAST ARRAYSIZE MULTIPLY
	IMULM	T2,@1(ARG)	;MULTIPLY TO MEM IT IN

	POP	P,TABREG	;RESTORE REGISTERS
	POP	P,T2
	GOODBY
	PRGEND
	TITLE	ADJG.	%3.(142)


	SEARCH	FORPRM
;AC ASSIGNMENTS
ARG==L		;ARGUMENT LIST

TEMOFF==T0	;USED TO COMPUTE OFFSET
;T1==1		;USED TO HOLD LOOP COUNT (DIMENSIONALITY)
;T2==2		;USED TO HOLD MULTIPLIERS
TABREG==T3	;USED TO HOLD DESTROYED ARG PTR


	;THE FOLLOWING ALGORITHM IS IMPLEMENTED TO COMPUTE
	;ARRAY FACTORS AND OFFSET AND SIZE FOR THE
	;GENERAL CASE.

	;A PARTIALLY COMPUTED OFFSET MAY BE INPUT
	;THE ALGORITHM MAY START IN AN ARBITRARY PLACE AND MULT(1)
	;MAY BE 1 (STARTING FROM SCRATCH) OR ANOTHER VALUE.
	;THE ABILITY TO START ANYWHERE IS NECESSARY SINCE
	;FACTOR AND OFFSET INFO MAY ALREADY HAVE BEEN
	;COMPUTED FOR CONSTANT ARRAY BOUNDS APPEARING IN THE
	;LIST FIRST.
	;MULT(I) ARE THE FACTORS
	;U(I) ARE THE UPPER BOUNDS
	;L(I) ARE THE LOWER BOUNDS

	;OFFSET=MULT(1)*L(1)
	;ARRAYSIZ=MULT(1)
	;DO 10 I=2,NUMBER OF DIMENSIONS-1
	;TEMP=U(I-1)-L(I-1)+1
	;MULT(I)=MULT(I-1)*TEMP
	;OFFSET=OFFSET+MULT(I)
	;ARRAYSIZ=ARRAYSIZ*TEMP
;10	CONTINUE
	;OFFSET=-OFFSET+BASE ADDRESS OF ARRAY
	;TEMP=U(I)-L(I)+1
	;ARRAYSIZ=ARRAYSIZ*TEMP

	;THE PARAMTERS ARE (IN ORDER OF APPEARANCE)
	;POINTER TO NUMBER OF DIMENSIONS
	;POINTER TO ARRAY SIZE
	;BASE ADDRESS OF ARRAY
	;POINTER TO TEMP CONTAINING OFFSET
	;MULT(1)
	;U(1)
	;L(1)
	;MULT(2)
	;U(2)
	;L(2)
	;	.
	;	.
	;	.
	;MULT(N)

	HELLO	(ADJG.)
	PUSH	P,T2		;SAVE REGISTERS USED
	PUSH	P,TABREG	;

	MOVE	T1,@0(ARG)	;FETCH DIMENSIONALITY
	MOVE	TABREG,ARG	;COPY ARG REGISTER
	MOVE	TEMOFF,@3(ARG)	;OFFSET (PASSED IN)
	MOVE	T2,@4(ARG)	;MULT(1) - (PASSED IN)
	MOVEM	T2,@1(ARG)	;INITIALIZE ARRAYSIZ
LOOP1:	IMUL	T2,@6(TABREG)	;MULT(1)*L(1)
	ADDI	TEMOFF,0(T2)	;ADD TO INITIAL OFFSET
	SOJLE	T1,LUPDUN	;QUIT IF DONE
	MOVE	T2,@5(TABREG)	;U(I-1)
	SUB	T2,@6(TABREG)	;MINUS L(I-1)
	ADDI	T2,1		;PLUS 1
	IMULM	T2,@1(ARG)	;MULTIPLY INTO ARRAYSIZ
	IMUL	T2,@4(TABREG)	;TIMES MULT(I-1)
	MOVEM	T2,@7(TABREG)	;EQUALS MULT(I)
	ADDI	TABREG,3	;INCREMENT TO NEXT BUNCH
	JRST	LOOP1		;GO AROUND AGAIN

LUPDUN:	MOVN	TEMOFF,TEMOFF	;NEGATE OFFSET
	ADDI	TEMOFF,@2(ARG)	;ADD BASE ADDRESS OF ARRAY
	MOVEM	TEMOFF,@3(ARG)	;STOR OFFSET
	MOVE	T2,@5(TABREG)	;GET U(I) FOR LAST ARRAYSIZ MULT
	SUB	T2,@6(TABREG)	;-L(I)
	ADDI	T2,1		;ADD ONE OF COURSE
	IMULM	T2,@1(ARG)	;MULT AND STACH IN ARRAY SIZE

	POP	P,TABREG	;RESTORE REGISTERS USED
	POP	P,T2
	GOODBY
	PRGEND
TITLE	ADJ. 	%2.(120) ;FROM LIB40 VERSION V.032(323)	VARIABLE DIMENSION SUBSCRIPT CALCULATOR
SUBTTL	D. TODD /DRT 15-FEB-1973	TOM OSTEN/TWE
;***COPYRIGHT 1972,1973 DIGITAL EQUIPMENT CORP., MAYNARD MASS.***

;ADJ. IS A PROGRAM CALLED AT RUN-TIME BY A FORTRAN PROGRAM
;TO CALCULATE THE MULTIPLIERS AND OFFSET FOR SUBSCRIPT CALCULATIONS
;FOR DIMENSIONS DECLARED AS SUBROUTINE ARGUMENTS. THE COMPILER
;GENERATES THE FOLLOWING SEQUENCE:
;	JSA	16, ADJ.
;	EXP	N		;DIMENSIONALITY OF ARRAY
;	ARG	X, TEMP+N+1	;ARG IS A NO-OP, X IS THE TYPE 
				;OF THE ARGUMENT,TEMP IS A PNTR
				;TYPE,TEMP+N+1 POINTS TO END OF
				;MULTIPLIER TABLE
;	EXP	U1		;ADDRESS OF NUMBER WHICH IS THE 
;				;UPPER BOUND FOR FIRST SUBSCRIPT
;	EXP	L1		;ADDRESS OF NUMBER WHICH IS THE
;				;LOWER BOUND FOR FIRST SUBSCRIPT
;	.
;	.
;	.
;	EXP	LN		;LAST LOWER BOUND ADDRESS
;THE TEMP BLOCK IS CONSTRUCTED AS FOLLOWS:

;TEMP:	SIZE OF ARRAY (EQUAL TO MULTIPLIER N)
;	OFFSET
;	MULTIPLIER N-1
;	.
;	.
;	.
;	MULTIPLIER 1
;	MULTIPLIER 0

;THE I-TH MULTIPLIER, P(I), IS DESCRIBED BY:
;	P(0) = 1
;	P(I) = P(I-1) * (U(I) - L(I) + 1)

;THE OFFSET IS DESCRIBED BY
;	OFFSET = SUM FROM 1 TO N OF P(I-1)*L(I)

	SEARCH	FORPRM
A=0
B=1
C=2
D=3
E=4
F=5
G=6
Q=16
P=17

	HELLO	(ADJ.)		;ENTRY TO ADJ. ROUTINE
	MOVEM	2,SAV2		;SAVE AC 2
	LDB	C,[POINT 3,1(Q),11]	;GET HI 3 BITS OF ARG TYPE
	SUBI	C,3		;0 RESULT MEANS D.P. OR COMPLEX
	MOVEM	C,ACFLD		;SAVE THE RESULT
	MOVNI	C, @(Q)		;GET MINUS COUNT OF DIMENSIONS
	MOVEI	B, @1(Q)	;GET TOP ADDRESS OF TEMP BLOCK
	ADDI	B, -1(C)	;SET B BACK TO BEGINNING OF TEMP BLOCK
	HRL	B, C		;AOBJN WORD IS (-CNT)ADDR
	MOVEI	A, 1		;INITIALIZE P(0) = 1
	SETZM	OFFSET		;INITIALIZE OFFSET=0

ADJ.1:	MOVEM	A, (B)		;STORE P(N)
	ADDI	Q, 2		;SET FOR NEXT PAIR OF DIMENSIONS
	MOVE	C, A		;COPY P(N)
	IMUL	C, @1(Q)	;P(N-1)*L(N)
	ADDM	C,OFFSET	;ADD INTO OFFSET
	MOVE	C, @(Q)		;GET U(N)
	SUB	C, @1(Q)	;U(N) - L(N)
	IMULI	A, 1(C)		;P(N-1)*(U(N) -L(N) +1)
	AOBJN	B, ADJ.1	;N=N+1, GO AROUND LOOP

	MOVE	C,OFFSET	;GET OFFSET BACK
	SKIPN	ACFLD		;WAS TYPE D.P. OR COMPLEX?
	ASH	C,1		;YES, MULTIPLY OFFSET BY 2 FOR
				;COMPLEX OR DOUBLE PRECISION ARG.
	MOVEM	C, (B)		;OFFSET TO NEXT TO LAST ENTRY
	MOVEM	A, 1(B)		;SIZE TO LAST ENTRY
	MOVE	2,SAV2		;RESTORE AC 2
	GOODBY	(2)	;RETURN

OFFSET:	BLOCK	1
ACFLD:	BLOCK	1	;HOLD 0 IF DOUBLE PRECISION OR COMPLEX
SAV2:	BLOCK	1	;TEMP STORAGE FOR AC 2

	PRGEND
TITLE	ILL 	%2.(120) ;FROM LIB40 VERSION V.032(323)      ZERO INPUT WORD ON ILLEG. CHARACTERS
SUBTTL	D. TODD /DRT 15-FEB-1973	/DMN/TWE
;***COPYRIGHT 1972,1973 DIGITAL EQUIPMENT CORP., MAYNARD MASS.***

;WHEN THE FLAG ILLEG. IS SET (BY CALLING ILL), 
;FLOATING POINT INPUT WORDS WILL BE CLEARED IF
;ANY ILLEGAL CHARACTERS ARE SCANNED FOR THAT WORD.
;THE ILLEG. FLAG IS CLEARED BY FORSE. AT THE END
;OF EACH FORMAT STATEMENT.

;THE CALLING SEQUENCE IS JSA Q,ILL

;THE ROUTINE 'LEGAL' ALLOWS ONE TO CLEAR THE
;ILLEG. FLAG SO THAT ILLEGAL CHARACTERS WILL
;RESULT IN THE NORMAL ILLEGAL CHARACTER RETURN.

;THE CALLING SEQUENCE IS JSA Q,LEGAL

ENTRY ILL,LEGAL
SEARCH FORPRM
A=0
B=1
C=2
D=3
E=4
F=5
G=6
Q=16
P=17

	HELLO	(ILL)
	HRRZ	T1,.JBOPS	;GET THE LOW SEG POINTER
	SETOM ILLEG.(T1)	;SET ILL CH FLAG
	GOODBY

	HELLO	(LEGAL)
	HRRZ	T1,.JBOPS
	SETZM ILLEG.(T1)	;CLEAR ILL CH FLAG
	GOODBY

	PRGEND
TITLE	ABS 	%2.(120) ;FROM LIB40 VERSION V.032(323)	S.P. ABSOLUTE VALUE FUNCTION
SUBTTL	D. TODD /DRT 15-FEB-1973	ED YOURDON/KK/TWE
;***COPYRIGHT 1972,1973 DIGITAL EQUIPMENT CORP., MAYNARD MASS.***

;SINGLE PRECISION ABSOLUTE VALUE FUNCTION
;ABS AND IABS RETURN THE ABSOLUTE VALUE OF A SINGLE PRECISION
;ARGUMENT.

;THE CALLING SEQUENCE FOR THE ROUTINES IS
;	JSA	Q, ABS
;	EXP	ARG
;THE ANSWER IS RETURNED IN ACCUMULATOR A

	SEARCH	FORPRM
A=0
B=1
C=2
D=3
E=4
F=5
G=6
Q=16
P=17


	HELLO	(ABS,.)			;ENTRY TO ABS ROUTINE
	MOVM	A,@(Q)		;GET /ARG/.
	GOODBY	(1)	;RETURN

	HELLO	(IABS,.)			;ENTRY TO IABS ROUTINE.
	MOVM	A,@(Q)		;GET /ARG/.
	JFCL	1,[HRLOI A,377777 ;/-INFIN/ IS SET TO +INFIN,
		GOODBY (1)]	;AND AN ERROR MESSAGE IS RETURNED.
	GOODBY	(1)	;RETURN

	PRGEND
TITLE	RESET	%2.(120) ;FROM LIB40 VERSION V.032(323)	RESETS ALL I/O DEVICES
SUBTTL	D. TODD /DRT 15-FEB-1973	DICK GRUEN/TWE
;***COPYRIGHT 1972,1973 DIGITAL EQUIPMENT CORP., MAYNARD MASS.***

	SEARCH	FORPRM
A=0
B=1
C=2
D=3
E=4
F=5
G=6
Q=16
P=17

	HELLO	(RESET)
	PUSH	P,L	;SAVE THE LINK REG
	JSP	P,RESET.##	;GO RESET FOROTS
	POP	P,L	;RESTORE THE LINK
	GOODBY	()	;RETURN

	PRGEND
TITLE	DIM 	%2.(120) ;FROM LIB40 VERSION V.032(323)	S.P. POSITIVE DIFFERENCE FUNCTION
SUBTTL	D. TODD /DRT 15-FEB-1973	ED YOURDON/TWE
;***COPYRIGHT 1972,1973 DIGITAL EQUIPMENT CORP., MAYNARD MASS.***

;SINGLE PRECISION DIM FUNCTION
;DIM(A,B) IS CALLED IN THE FOLLOWING MANNER:
;	JSA	Q, DIM
;	EXP	A
;	EXP	B
;DIM RETURNS THE POSITIVE DIFFERENCE OF A AND B:
;IF (A-B)>0, THEN DIM(A,B) = A-B
;IF (A-B) .LE. 0, THEN DIM(A,B) = 0

	SEARCH	FORPRM
A=0
B=1
C=2
D=3
E=4
F=5
G=6
Q=16
P=17


	HELLO	(DIM,.)			;ENTRY TO DIM ROUTINE
	MOVE	A, @(Q)		;PICK UP FIRST ARGUMENT
	CAMG	A,@1(Q)		;IF A > B, GO TO SUBTRACT.
	TDZA	A,A		;O'E, ZERO A AND GO TO EXIT.
	FSBR	A,@1(Q)		;CALC A - B.
	GOODBY	(2)	;RETURN

	PRGEND
TITLE	IDIM 	%2.(120) ;FROM LIB40 VERSION V.032(323)	INTEGER POSITIVE DIFFERENCE FUNCTION
SUBTTL	D. TODD /DRT 15-FEB-1973	ED YOURDON/KK/TWE
;***COPYRIGHT 1972,1973 DIGITAL EQUIPMENT CORP., MAYNARD MASS.***

;SINGLE PRECISION INTEGER DIM FUNCTION
;IDIM(A,B) IS CALLED IN THE FOLLOWING MANNER:
;	JSA	Q, IDIM
;	EXP	A
;	EXP	B
;IDIM RETURNS THE POSITIVE DIFFERENCE OF A AND B:
;IF (A-B) .LE. 0, THEN DIM(A,B)=0
;IF(A-B) .G. 0 , THEN DIM(A,B)=(A-B)

	SEARCH	FORPRM
A=0
B=1
C=2
D=3
E=4
F=5
G=6
Q=16
P=17

	HELLO	(IDIM,.)			;ENTRY TO IDIM ROUTINE
	MOVE	A, @(Q)		;PICK UP FIRST ARGUMENT
	CAMG	A,@1(Q)		;IF A <= B,
	MOVE	A,@1(Q)		;ANS WILL = 0.
	SUB	A,@1(Q)		;IF A > B,
	JFCL	1,[HRLOI A,377777 ;ANS = A - B,
		GOODBY (2)]	;+ OVERFLOW MAY OCCUR.
	GOODBY	(2)	;RETURN

	PRGEND
TITLE	SIGN. 	%2.(120) ;FROM LIB40 VERSION V.032(323)	S.P. AND INTEGER XFER OF SIGN FUNCTION
SUBTTL	D. TODD /DRT 15-FEB-1973	ED YOURDON/KK/TWE
;***COPYRIGHT 1972,1973 DIGITAL EQUIPMENT CORP., MAYNARD MASS.***

;SIGN(A,B) AND ISIGN(A,B) ARE CALLED IN THE FOLLOWING MANNER:
;	JSA	Q, SIGN
;	EXP	A
;	EXP	B
;IF B .GE. 0, THEN ABSF(A) IS RETURNED IN ACCUMULATOR A
;IF B .L. 0, THEN -ABSF(A) IS RETURNED IN ACCUMULATOR A

	SEARCH	FORPRM
A=0
B=1
C=2
D=3
E=4
F=5
G=6
Q=16
P=17

	HELLO	(SIGN,.)			;ENTRY TO SIGN
	MOVM	A, @(Q)		;GET MAGNITUDE OF FIRST ARGUMENT
	SKIPGE	@1(Q)		;IS SECOND ARGUMENT POSITIVE?
	MOVNS	A		;NO, NEGATE RESULT
	GOODBY	(2)	;RETURN

	HELLO	(ISIGN,.)			;ENTRY TO ISIGN
	MOVE	A,@(Q)		;FIRST ARG TO A.
	XOR	A,@1(Q)		;IF FIRST AND SECOND HAVE
	JUMPL	A,.+3		;DIFFERENT SIGNS, GO TO .+3.
	MOVE	A,@(Q)		;O'E, THE ANSWER = FIRST ARG.
	GOODBY	(2)	;RETURN
	MOVN	A,@(Q)		;ANSWER=-FIRST ARG.
	JFCL	1,.+2		;IF OVERFLOW, GO TO .+2.
	GOODBY	(2)	;RETURN
	HRLOI	A,377777	;ANSWER IS SET TO +INFINITY.
	GOODBY	(2)	;RETURN

	PRGEND
TITLE	AINT	%2.(120) ;FROM LIB40 VERSION V.032(323)	FLOATING POINT TRUNCATION FUNCTION
SUBTTL	D. TODD /DRT 15-FEB-1973	ED YOURDON /KK/TWE
;***COPYRIGHT 1972,1973 DIGITAL EQUIPMENT CORP., MAYNARD MASS.***

;FLOATING POINT TRUNCATION FUNCTION.
;TRUNCATES FRACTIONAL PART OF FLOATING POINT NUMBER
;AND RETURNS ANSWER AS A FLOATING POINT NUMBER.
;THE ROUTINE IS CALLED IN THE FOLLOWING MANNER:
;	JSA	Q,AINT
;	EXP	ARG

;THE ANSWER IS RETURNED IN AC 0.

	SEARCH	FORPRM
A=0
B=1
C=2
D=3
E=4
F=5
G=6
Q=16
P=17

	HELLO	(AINT,.)			;ENTRY TO AINT ROUTINE.
	MOVE	B,@(Q)		;ARG. TO AC 1.
	MOVM	A,B		;/ARG./ TO AC 0.
	CAML	A,MOD1		;IS /ARG/<2**26?
	JRST	AINT1		;NO, NO FRACTION BITS, EXIT.
	FAD	A,MOD1		;YES, REMOVE
	FSB	A,MOD1		;THE FRACTION BITS.
AINT1:	SKIPGE	B		;SET THE
	MOVNS	A		;CORRECT SIGN AND
	GOODBY	(1)	;RETURN

MOD1:	233400000000		;2**26

	PRGEND
TITLE	AMOD	%2.(120) ;FROM LIB40 VERSION V.32(323)	S.P. MOD FUNCTION
SUBTTL	D. TODD /DRT 15-FEB-1973	ED YOURDON/KK/DMN/TWE
;***COPYRIGHT 1972,1973 DIGITAL EQUIPMENT CORP., MAYNARD MASS.***

;FLOATING POINT SINGLE PRECISION MOD FUNCTION
;MODF(A,B) = A-[A/B]*B, WHERE [A/B] IS THE GREATEST INTEGER
;IN THE MAGNITUDE OF A/B.  THE TERM A/B MUST BE LESS THAN 
;2**26 IN MAGNITUDE.

;THE ROUTINE IS CALLED IN THE FOLLOWING MANNER:
;	JSA	Q,AMOD
;	EXP	A
;	EXP	B

	SEARCH	FORPRM
A=0
B=1
C=2
D=3
E=4
F=5
G=6
Q=16
P=17

	HELLO	(AMOD,.)			;ENTRY TO AMOD ROUTINE.
	MOVEM	C,SAVEC		;SAVE AC 2.
	MOVE	A,@(Q)		;PICK UP FIRST ARG.
	MOVE	B,@1(Q)		;PICK UP SECOND ARG.
	MOVM	C,B		;GET ABSF(B) IN C.
	FDVM	A,B		;CALCULATE A/B.
	JFCL	DETRMN		;IF OVER/UNDER FLOW, GO TO DETRMN VIA OVTRAP.
	MOVMS	B		;CALC. ABSF(A/B).
	CAML	B,MOD1		;IF A/B GE 2**26, 
	JRST	TOOLRG		;GO TO ERROR RETURN.
	FAD	B,MOD1		;OTHERWISE, TRUNCATE TO
	FSB	B,MOD1		;INTEGER.
	FMP	C,B		;C=B**ABSF([A/B])
	SKIPGE	A		;RESTORE
	MOVNS	C		;THE SIGN.
	FSB	A,C		;CALC. A-[A/B]*B.
OUT:	MOVE	C,SAVEC		;RESTORE AC 2.
	GOODBY	(2)	;RETURN
DETRMN:	MOVE	B,.JBTPC	;PICK UP FLAGS.
	TLNE	B,000100	;IF OVERFLOW, GO TO TOOLRG.
	JRST	OUT		;UNDERFLOW, A IS RESULT.
TOOLRG:	ERROR	(APR,5,1,.+1)	;TYPE AN OVERFLOW MESSAGE
	SETZ	A,		;ZERO A.
	JRST	OUT		;GO TO EXIT.
SAVEC:	0
MOD1:	233400000000		;2**26.

	PRGEND
TITLE	MOD	%2.(120) ;FROM LIB40 VERSION V.032(323)	INTEGER MOD FUNCTION
SUBTTL	D. TODD /DRT 15-FEB-1973	ED YOURDON/KK
;***COPYRIGHT 1972,1973 DIGITAL EQUIPMENT CORP., MAYNARD MASS.***

;INTEGER MOD FUNCTION
;MOD(A,B) = A-[A/B]*B, WHERE [A/B] IS THE GREATEST (IN
;MAGNITUDE) INTEGER IN A/B.  THAT IS, THE MOD FUNCTION 
;RETURNS THE REMAINDER OF THE QUOTIENT OF A AN HENCE,
;9 MOD 2 IS 1, AND SO FORTH.

;THE CALLING SEQUENCE FOR THE ROUTINE IS:
;	JSA	Q,MOD
;	ARG	0,A
;	ARG	0,B
;WHERE ARG MAY BE ANY OPCODE, THE 0 IS THE AC FIELD AND USUALLY
;DESIGNATES THE TYPE OF ARGUMENT.  A AND B ARE THE ADDRESSES
;OF THE TWO ARGUMENTS TO THE PROGRAM.

	SEARCH	FORPRM
A=0
B=1
C=2
D=3
E=4
F=5
G=6
Q=16
P=17

	HELLO	(MOD,.)			;ENTRY TO MOD ROUTINE
	MOVE	A,@(Q)		;FIRST ARG TO AC 0.
	IDIV	A,@1(Q)		;DIVIDE, REMAINDER IN AC 1.
	MOVE	A,A+1		;PUT THE ANSWER IN AC 0.
	GOODBY	(2)	;RETURN

	PRGEND
TITLE	DATE	%2.(120) ;FROM LIB40 VERSION V.32(433)	TODAY'S DATE	FORTRAN IV
SUBTTL	D. TODD /DRT 15-FEB-1973	/KK/DMN
;***COPYRIGHT 1972,1973 DIGITAL EQUIPMENT CORP., MAYNARD MASS.***


;THIS SUBROUTINE PUTS TODAY'S DATE INTO A
;DIMENSIONED TWO-WORD ARRAY.

;THE DATE WILL BE IN THE FORM:
;	17-Aug-66

;THE ROUTINE IS CALLED IN THE FOLLOWING MANNER:
;	JSA	16,DATE
;	ARG	A

;"DATE" OBTAINS THE DATE FROM THE MONITOR IN THE FORM:
;	( (YEAR-1964)*12 + (MONTH-1) )*31 + (DAY-1)

	SEARCH	FORPRM

	HELLO	(DATE)			;ENTRY TO DATE ROUTINE.
	MOVEI	1,@(16)		;GET ADDRESS OF 2 WORD ARRAY
	MOVEM	2,0(1)		;SAVE THE CONTENTS OF AC 2.
	MOVEM	3,1(1)		;SAVE THE CONTENTS OF AC 3.
	CALLI	1,14		;GET THE DATE FROM THE MONITOR.
	IDIVI	1,^D31		;DIV. BY 31 TO OBTAIN THE DAY-1.
	ADDI	2,1		;TO OBTAIN THE DAY.
	IDIVI	2,^D10		;CONVERT INTO TWO DEC. DIGITS.
	SKIPN	2		;IS THE DAY < 10?
	MOVNI	2,20		;YES, OUTPUT BLANK.
	MOVEI	0,"0"(2)	;GET FIRST DIGIT
	LSH	0,7		;MAKE SPACE
	ADDI	0,"0"(3)	;ADD IN 2ND DIGIT
	IDIVI	1,^D12		;TO OBTAIN THE MONTH
	EXCH	1,2		;SAVE YEAR IN 2
	MOVE	1,TABLE(1)	;GET MONTH IN 1
	LSHC	0,3*7		;LEFT JUSTIFY 0 & 1
	LSH	0,1		;0 = ASCII /DD-MO/
				;1 = ASCII /N-/
	MOVEI	2,^D64(2)	;GET THE YEAR
	IDIVI	2,^D10		;CONVERT INTO TWO DEC. DIGITS
	ADDI	2,"0"		;MAKE ASCII
	ADDI	3,"0"
	LSH	2,2*7+1		;SHIFT TO CHAR 3
	LSH	3,7+1		;SHIFT TO CHAR 4
	ADD	3,2		;ADD IN TO 3
	ADD	3,1		;SO LOW WORD IS IN 3
	MOVE	2,0		;PUT HIGH ORDER RESULT IN 2
	MOVEI	1,@(16)		;USER ADDRESS
	EXCH	2,0(1)		;RESTORE 2
	EXCH	3,1(1)		;AND 3 WHILE STORING RESULT
	GOODBY	(1)	;RETURN

;SUB1 CONVERTS THE DAY AND THE YEAR INTO ASCII CHARS, AND
;DEPOSITS THEM IN THE TWO WORD ARRAY.

SUB1:	ADDI	2,60		;CONVERT FIRST DIGIT TO ASCII
	IDPB	2,0		;DEPOSIT FIRST DIGIT
	ADDI	3,60		;CONVERT SECOND DIGIT TO ASCII
TABLE:	ASCII	/-Jan-/
	ASCII	/-Feb-/
	ASCII	/-Mar-/
	ASCII	/-Apr-/
	ASCII	/-May-/
	ASCII	/-Jun-/
	ASCII	/-Jul-/
	ASCII	/-Aug-/
	ASCII	/-Sep-/
	ASCII	/-Oct-/
	ASCII	/-Nov-/
	ASCII	/-Dec-/

	PRGEND
TITLE	TIME	%2.(120) ;FROM LIB40 VERSION V.022	TIME OF DAY FORTRAN IV
SUBTTL	D. TODD /DRT 15-FEB-1973	/KK
;***COPYRIGHT 1972,1973 DIGITAL EQUIPMENT CORP., MAYNARD MASS.***

;FROM	%2.(120) ;FROM LIB40 VERSION V.017.5
;THIS SUBROUTINE PUTS THE TIME OF DAY INTO TWO WORDS.
;
;THE WORDS CONTAIN THE HOUR, THE MINUTE, THE SECOND, AND THE
;TENTH OF A SECOND.

;THE FIRST WORD IS OF THE FORM:
;	02:15 (FOR A.M. TIME)
;	14:15 (FOR P.M. TIME)

;THE SECOND WORD IS OF THE FORM:
;	37.4
;
;THE ROUTINE IS CALLED IN THE FOLLOWING MANNER:
;	JSA	16,TIME
;	ARG	A
;	ARG	B
;SINCE THE OLD VERSION OF TIME HAD ONLY ONE ARGUMENT,
;TIME CHECKS TO BE SURE A SECOND ARGUMENT IS EXPECTED
;BEFORE RETURNING IT.  THE OPCODE OF THE SECOND ARGUMENT
;MUST BE 320.

;TIME OBTAINS THE TIME FROM THE MONITOR IN THE FORM:
;	TIME=THE NUMBER OF MILLISECONDS SINCE MIDNIGHT.

	SEARCH	FORPRM

	HELLO	(TIME)			;ENTRY TO ROUTINE TIME
	MOVEM	2,SAVE2		;SAVE AC 2
	MOVEM	3,SAVE3		;SAVE AC 3
	CALLI	1,23		;GET TIME IN MILLISECS FROM THE MONITOR.
	IDIVI	1,^D60000	;TOTAL MINS. IN 1, LEFTOVER MSECS. IN 2.
	MOVEM	2,TEMP1		;SAVE THE LEFTOVER MSECONDS.
	IDIVI	1,^D60		;HOURS IN 1, MINUTES IN 2.
	MOVEM	2,TEMP2		;SAVE THE MINUTES.
	HRLZI	0,440736	;SET UP POINTER.
	JSP	3,SUB1		;GO TO SUBR. TO SET UP HR. IN ASCII.
	MOVEI	1,":"		;SET UP ":".
	IDPB	1,0		;DEPOSIT ":" IN THE WORD.
	MOVE	1,TEMP2		;PICK UP THE MINUTES.
	JSP	3,SUB1		;GO TO SUBR. TO SET UP MIN. IN ASCII.
	MOVE	3,1(16)		;CHECK TO SEE
	TLC	3,320000	;IF A SECOND
	TLNE	3,777000	;ARG. IS EXPECTED.
	JRST	OUT1		;IF NOT, GO TO OUT1.
	HRLZI	0,440736	;SET UP THE NEW
	ADDI	0,1		;POINTER.
	MOVEI	1," "		;PUT IN A BLANK AS THE FIRST
	IDPB	1,0		;CHARACTER IN THE 2ND WORD.
	MOVE	1,TEMP1		;PICK UP THE MSECONDS.
	IDIVI	1,^D1000	;SECONDS IN 1, LEFTOVER MSECS. IN 2.
	MOVEM	2,TEMP1		;SAVE THE MSECS.
	JSP	3,SUB1		;GO TO SUBR. TO SET UP THE SECS. IN ASCII.
	MOVEI	1,"."		;SET UP "."
	IDPB	1,0		;IN THE WORD.
	MOVE	2,TEMP1		;PICK UP THE MSECS.
	IDIVI	2,^D100		;GET THE TENTH OF A SECOND.
	ADDI	2,60		;MAKE IT ASCII.
	IDPB	2,0		;PUT IT IN THE SECOND WORD.
	MOVE	2,SAVE2		;RESTORE AC 2.
	MOVE	3,SAVE3		;RESTORE AC 3.
	GOODBY	(2)	;RETURN
OUT1:	MOVE	2,SAVE2		;RESTORE AC 2.
	MOVE	3,SAVE3		;RESTORE AC 3.
	GOODBY	(1)	;RETURN
SUB1:	IDIVI	1,^D10		;SUBROUTINE ENTRY POINT.
	ADDI	1,60		;MAKE THE FIRST DIGIT ASCII.
	IDPB	1,0		;DEPOSIT IT IN THE WORD.
	ADDI	2,60		;MAKE THE 2ND DIGIT ASCII.
	IDPB	2,0		;DEPOSIT IT IN THE WORD.
	JRST	(3)		;RETURN TO MAIN SEQUENCE.
SAVE2:	0
SAVE3:	0
TEMP1:	0
TEMP2:	0
	PRGEND
TITLE	SLITE 	%2.(120) ;FROM LIB40 VERSION V.032(323)	SENSE LITE SETTING AND TESTING FUNCTION
SUBTTL	D. TODD /DRT 15-FEB-1973	/TWE
;***COPYRIGHT 1972,1973 DIGITAL EQUIPMENT CORP., MAYNARD MASS.***

;SENSE LIGHT SETTING AND TESTING PROGRAM
;THIS PROGRAM CAN BE ENTERED AT TWO PLACES. THE SENSE LIGHT
;TESTING PROGRAM IS CALLED IN THE FOLLOWING MANNER:
;	JSA	Q, SLITET
;	EXP	I
;	EXP	J
;I IS THE ADDRESS OF AN INTEGER ARGUMENT, AND J IS THE ADDRESS
;OF THE ANSWER. IF SENSE LIGHT I IS ON, THE ANSWER IS ONE, AND
;IF IT IS OFF, THE ANSWER IS 2.

;THE SENSE LIGHT SETTING PROGRAM IS CALLED IN THE FOLLOWING
;MANNER:
;	JSA	Q, SLITE
;	EXP	I
;I IS THE ADDRESS OF AN INTEGER ARGUMENT WHOSE VALUE IS
;BETWEEN 0 AND 36. IF I=0, ALL SENSE LIGHTS ARE TURNED OFF.
;OTHERWISE, SENSE LIGHT I IS TURNED ON.

	SEARCH	FORPRM
A=0
B=1
C=2
D=3
E=4
F=5
G=6
Q=16
P=17


	HELLO	(SLITE)			;ENTRY TO SLITE PROGRAM
	MOVN	B, @(Q)		;GET ARGUMENT
	JUMPE	B, SLITE2	;IS IT ZERO?
	MOVSI	A, 400000	;NO, PUT A ONE IN BIT 0
	ROT	A, 1(B)		;ROTATE IT INTO POSITION
	MOVE	B, LITES	;GET THE SENSE LIGHTS
	TDO	B, A		;TURN ON PROPER LIGHT
SLITE2:	MOVEM	B, LITES	;SAVE NEW SENSE LIGHTS
	GOODBY	(1)	;RETURN

	HELLO	(SLITET)			;ENTRY TO SENSE TESTING PROGRAM
	MOVN	B, @(Q)		;PICK UP ARGUMENT
	MOVSI	A, 400000	;PUT A ONE IN BIT 0
	ROT	A, 1(B)		;ROTATE IT INTO POSITION
	MOVEI	B, 1		;SET ANSWER TO ONE FOR NOW
	MOVEM	B, @1(Q)	;...
	MOVE	B, LITES	;PICK UP SENSE LIGHTS
	TDZN	B,A		;IS THE PROPER LIGHT ON?
	AOS	@1(Q)		;NO, CHANGE ANSWER TO 2
	MOVEM	B,LITES		;RESTORE WITH TESTED LIGHT OFF
	GOODBY	(2)	;RETURN

LITES:	0

	PRGEND
TITLE	SSWTCH 	%2.(120) ;FROM LIB40 VERSION V.032(323)	DATA SWITCH TESTING FUNCTION
SUBTTL	D. TODD /DRT 15-FEB-1973	/TWE
;***COPYRIGHT 1972,1973 DIGITAL EQUIPMENT CORP., MAYNARD MASS.***

; DATA SWITCH TESTING PROGRAM
;THIS PROGRAM IS CALLED IN THE FOLLOWING MANNER:
;	JSA	Q, SSWTCH
;	EXP	I
;	EXP	J
;I IS THE ADDRESS OF AN INTEGER ARGUMENT AND J IS THE ADDRESS
; OF THE ANSWER . IF DATA SWITCH I IS UP,THE ANSWER IS 2 , AND
; IF IT IS DOWN, THE ANSWER IS 1.

	SEARCH	FORPRM
A=0
B=1
C=2
D=3
E=4
F=5
G=6
Q=16
P=17

	HELLO	(SSWTCH)			;ENTRY TO SSWTCH PROGRAM
	MOVN	B, @(Q)		;PICK UP ARGUMENT
	MOVSI	A, 400000	;PUT A ONE IN BIT 0
	ROT	A,(B)		; ROTATE BIT INTO POSITION
	MOVEI	B,2		; SET ANSWER TO 2 FOR NOW
	MOVEM	B, @1(Q)	;...
	SWITCH	B,		;GET DATA SWITCHES FROM MONITOR
	TDNN	B, A		;IS PROPER SWITCH ON?
	SOS	@1(Q)		; NO, CHANGE ANSWER TO ONE
	GOODBY	(2)	;RETURN

	PRGEND
TITLE	RAN	%2.(120) ;FROM LIB40 VERSION V.032(323)	GENERATE RANDOM NUMBER FUNCTION
SUBTTL  24-OCT-1971     BRUNO G. DUERR/KK/TWE
;***COPYRIGHT 1972,1973 DIGITAL EQUIPMENT CORP., MAYNARD MASS.***

;PSEUDO RANDOM NUMBER GENERATOR AND INITIALIZING ROUTINE
;METHOD SUGGESTED BY D. H. LEHMER


;CALLING SEQUENCE FOR FUNCTION RAN:

;JSA Q,RAN
;EXP   ARG     (DUMMY ARGUMENT)
;ANSWER IS RETURNED IN ACCUMULATOR A AS A SINGLE
;PRECISION FLOATING POINT NUMBER IN THE RANGE
;0<X<1


;CALLING SEQUENCE FOR INITIALIZING SUBROUTINE SETRAN:

;JSA Q,SETRAN
;EXP   ARG (ARG IS THE ADDRESS OF A POSITIVE INTEGER <2**31)
;NOTE: IF ARG CONTAINS 0 A STANDARD STARTING VALUE IS TAKEN INSTEAD


;CALLING SEQUENCE FOR SAVRAN
SUBTTL	D. TODD /DRT 15-FEB-1973	
;***COPYRIGHT 1972,1973 DIGITAL EQUIPMENT CORP., MAYNARD MASS.***
;JSA Q,SAVRAN
;EXP ARG   (WHERE ARG IS THE ADDRESS FOR THE LAST RANDOM
;           NUMBER TO BE STORED IN INTEGER MODE)


	SEARCH FORPRM
A=0
B=1
C=2
D=3
E=4
F=5
G=6
Q=16
P=17

	HELLO	(RAN)
	MOVE A,K	;GET K [14**29(MOD2**31 -1)]
	MUL A,XN	;MULTIPLY WITH LAST RANDOM NUMBER
	ASHC A,4	;SEPARATE RESULT IN TWO 31 BIT WORDS
	LSH B,-4
	ADD A,B		;ADD THEM TOGETHER
	TLZE A,760000	;SKIP IF RESULT < 31 BITS
	ADDI A,1
	MOVEM A,XN	;STORE NEW RN IN INTEGER MODE
	HLRZ B,A	;CONVERT TO FP IN TWO STEPS IN
	FSC B,216	;ORDER TO LOOSE NO LOW ORDER
	HRLI A,A	;BITS
	FSC A,174
	FAD A,B
	GOODBY (1)	;RETURN TO CALLING PROGRAM
K:	^D630360016	;14**29(MOD 2**31 -1)
XN:	^D524287	;STARTING VALUE



	HELLO	(SETRAN)
	MOVE A,@0(Q)	;GET ARGUMENT FROM CALLING PROGRAM
	TLZ A,760000	;MASK 5 BITS FOR SAFETY
	CAIN A,0	;SKIP IF ARGUMENT NONZERO
	MOVE A,X0	;GET STANDARD STARTING VALUE
	MOVEM A,XN
	GOODBY	(1)	;RETURN
X0:	^D524287	;STANDARD STARTING VALUE FOR RAN


	HELLO	(SAVRAN)
	MOVE A,XN	;LAST RANDOM NUMBER TO AC0
	MOVEM A,@0(Q)	;STORE IN INTEGER MODE
	GOODBY	(1)	;RETURN

	PRGEND
TITLE	ERRSET	%2.(120) ;FROM LIB40 VERSION V.032(323)	SET MAXIMUM ERROR COUNT
SUBTTL	D. TODD /DRT 15-FEB-1973	T EGGERS/DMN/TWE
;***COPYRIGHT 1972,1973 DIGITAL EQUIPMENT CORP., MAYNARD MASS.***

	SEARCH	FORPRM
A=0
B=1
C=2
D=3
E=4
F=5
G=6
Q=16
P=17

	HELLO	(ERRSET)
	HRRZ	T1,.JBOPS	;GET THE LOW SEG POINTER
	MOVE	A,@(Q)		;GET MAXIMUM ERROR NUMBER
	MOVEM	A,ERRMX.(T1)	; AND STORE AWAY
	GOODBY	(1)	;RETURN

	PRGEND
TITLE	OVERFL	%2.(120) ;FROM LIB40 VERSION V.032(323)	ARITHMETIC OVEFLOW TESTING PROGRAM
SUBTTL	D. TODD /DRT 15-FEB-1973	T. EGGERS/DMN/TWE
;***COPYRIGHT 1972,1973 DIGITAL EQUIPMENT CORP., MAYNARD MASS.***

;THIS ROUTINE IS CALLED IN THE FOLLOWING MANNER:
;	JSA	Q,OVERFL
;	EXP	J
;IF OVERFLOWS HAVE OCCURRED, THE ANSWER IS SET TO 1, AND THE
;COUNTER IS CLEARED. IF THE OVERFLOW COUNTER IS 0, THE ANSWER
;IS SET TO 2.

SEARCH	FORPRM
A=0
B=1
C=2
D=3
E=4
F=5
G=6
Q=16
P=17
ENTRY	OVERFL

	HELLO	(OVERFL)
	HRRZ	T1,.JBOPS	;GET THE LOW SEG POINTER
	SETZM	@(Q)		;CLEAR OUT ANSWER WORD
	AOS	@(Q)		;SET ANSWER TO 1
	SKIPN	OVCNT.(T1)		;ANY OVERFLOWS?
	AOS	@(Q)		;NO, SET ANSWER TO 2
	SETZM	OVCNT.(T1)		;RESET OVERFLOW COUNTER
	GOODBY	(1)	;RETURN

	PRGEND
TITLE	TRACE  DUMMY ROUTINE TO DEFINE THE TRACE ENTRY IN FOROTS (FORERR)
SUBTTL	D. TODD	/DRT		05-APR-1973
;***COPYRIGHT 1973 DIGITAL EQUIPMENT CORP., MAYNARD, MASS.***

	SEARCH	FORPRM
	ENTRY	TRACE		;HELLO MACRO CAN NOT BE USED
				;SIXBIT NAME DEFINED IN TRACE (FORERR)
TRACE=TRACE.##			;DEFINE THE EXTERNAL TRACE NAME
				;TRACE.=TRACE% IN (FORINI)
	END
    RY‘