!  IOCSU MUST PRECEDE

ALT.ENTRY("$SFORW",%SFORW)
ALT.ENTRY("$RWINI",%RWINIT)
ALT.ENTRY("$READ",%READ)
ALT.ENTRY("$WRITE",%WRITE)
ALT.ENTRY("$NUMUI",%NUMUN.INIT)
ALT.ENTRY("$NUMUN",%NUMUNPK)
ALT.ENTRY("$NUMSI",%NUMSC.INIT)
ALT.ENTRY("$NUMSC",%NUMSCAN)
ALT.ENTRY("$LGCPK",%LGCPK)
ALT.ENTRY("$LGCUN",%LGCUNPK)
ALT.ENTRY("$LSCAN",%LSCAN.INIT)
ALT.ENTRY("$SCANI",%SCAN.INIT)
ALT.ENTRY("$SCAN",%SCAN)
ALT.ENTRY("$STRPI",%STRP.INIT)
ALT.ENTRY("$STRUP",%STRUP.INIT)
ALT.ENTRY("$TSTRP",%TSTRP.INIT)
ALT.ENTRY("$STRPK",%STRPK)
ALT.ENTRY("$STRUN",%STRUNPK)
ALT.ENTRY("$FLOUT",%FLOUT)
ALT.ENTRY("$POUT",%POUT)
ALT.ENTRY("$NMLIN",%NMLIN)
ALT.ENTRY("$NMLOU",%NMLOUT)
ALT.ENTRY("$SETRP",%SETRWP)

!  FIND '??' FOR DUBIOUS AREAS

! VTYP VALUES

DEF INT  AS 1
DEF REAL AS 2
DEF DOUB AS 3
DEF CPLX AS 4
DEF NUMTMAX AS CPLX   !MAX NUMERIC TYPE
DEF LGC  AS 5
DEF STR  AS 6
DEF VTYPMAX AS STR
DEF VTYPRNG AS VTYPMAX     !USED IN CASES ON VTYP
GLOBAL ALT.NAME("$FLDMA",FLDMAX(REAL:CPLX))

! FTYP VALUES

DEF SYM AS 1
DEF BIN AS 2

! FMODE VALUES

DEF SEQ AS 1
DEF VRL AS 2
DEF FRL AS 3

DEF FREEFORM AS FORM<0
DEF CORE.IO AS FN=NOFN   !ENCODE, DECODE

GLOBAL ALT.NAME("$VTYP",VTYP)
GLOBAL ALT.NAME("$VCNT",VCNT)
GLOBAL ALT.NAME("$VADR",VADR)
GLOBAL ALT.NAME("$FN",FN)
GLOBAL ALT.NAME("$FTYP",FTYP)
GLOBAL ALT.NAME("$FMODE",FMODE)
GLOBAL ALT.NAME("$RECSZ",RECSZ)
GLOBAL ALT.NAME("$FORM",FORM)
GLOBAL ALT.NAME("$CADR",CADR)
DEF NOFN AS (TEL-1)
GLOBAL ALT.NAME("$CRFG",CRFG(NOFN:FNMAX))
GLOBAL ALT.NAME("$ELCNT",ELCNT(NOFN:FNMAX))
DEF INITREC(FN) AS [ELCNT(FN) _ CRFG(FN) _ 0]

GLOBAL ALT.NAME("$SFORW",%SFORW)
GLOBAL ALT.NAME("$RWINI",%RWINIT)
GLOBAL ALT.NAME("$READ",%READ)
GLOBAL ALT.NAME("$WRITE",%WRITE)
GLOBAL ALT.NAME("$NUMUI",%NUMUN.INIT)
GLOBAL ALT.NAME("$NUMUN",%NUMUNPK)
GLOBAL ALT.NAME("$NUMSI",%NUMSC.INIT)
GLOBAL ALT.NAME("$NUMSC",%NUMSCAN)
GLOBAL ALT.NAME("$LGCPK",%LGCPK)
GLOBAL ALT.NAME("$LGCUN",%LGCUNPK)
GLOBAL ALT.NAME("$LSCAN",%LSCAN.INIT)
GLOBAL ALT.NAME("$SCANI",%SCAN.INIT)
GLOBAL ALT.NAME("$SCAN",%SCAN)
GLOBAL ALT.NAME("$STRPI",%STRP.INIT)
GLOBAL ALT.NAME("$STRUP",%STRUP.INIT)
GLOBAL ALT.NAME("$TSTRP",%TSTRP.INIT)
GLOBAL ALT.NAME("$STRPK",%STRPK)
GLOBAL ALT.NAME("$STRUN",%STRUNPK)
GLOBAL ALT.NAME("$FLOUT",%FLOUT)
GLOBAL ALT.NAME("$POUT",%POUT)
GLOBAL ALT.NAME("$NMLIN",%NMLIN)
GLOBAL ALT.NAME("$NMLOU",%NMLOUT)
GLOBAL ALT.NAME("$SETRP",%SETRWP)

!  NUMUN.INIT ARGUMENT VALUES

DEF INTFLD AS 1
DEF DECFLD AS 2
DEF EXPFLD AS 3

!  LABELS NXVAR BRANCHES TO AT END OF I/O LIST
GLOBAL ALT.NAME("$FRIEO",FRI.EOV:)    !FREE FORM INPUT
GLOBAL ALT.NAME("$FMIEO",FMI.EOV:)    !FORMATTED INPUT
GLOBAL ALT.NAME("$FROEO",FRO.EOV:)    !FREE FORM OUTPUT
GLOBAL ALT.NAME("$FMOEO",FMO.EOV:)    !FORMATTED OUTPUT

!  FOR MPK
GLOBAL ALT.NAME("$OVFLE",OVFLERR:)
GLOBAL ALT.NAME("$NUMPH",NUMPHI)
GLOBAL ALT.NAME("$NUMPL",NUMPLO)
GLOBAL ALT.NAME("$NUMPS",NUMPSGN)

! FORMAT ERRORS. RESERVE UP TO 24.
DEF MPAREN AS 1
DEF BDFMCH AS 2
DEF BDCNT AS 3
DEF EXNEST AS 4
DEF NOWDTH AS 5
DEF BDHCNT AS 6
DEF FMOVFL AS 7
DEF NOTERM AS 8
DEF LRGCNT AS 9
DEF MSMTCH AS 10
DEF NOSPEC AS 11
DEF ZRWDTH AS 12
DEF BDTSPC AS 13
DEF SHTFLD AS 14
DEF BDNSPC AS 15
! OTHER ERRORS.
DEF NMOVFL AS 25
DEF BDINCH AS 26
DEF BDBNIO AS 27
DEF TOOFAR AS 28
DEF BDCRLF AS 29
DEF RWERMAX AS BDCRLF

LOCAL RWMSG(RWERMAX)


%SETRWP (%NXVAR, %RWERR)

LOCAL OLDVAR, OLDERR

RETURN [OLDVAR<==%NXVAR; OLDERR<==%RWERR]


%SFORW
FIND ALT.NAME("$CCBIT",CCBITS)	! CARRIAGE CONTROL BIT STRING.
DEF CCFILE AS (CCBITS BAND (1SHL FN))


!  ERROR MESSAGES - IN SOME CASES (SPERR), OTHER TEXT PRECEDES

!  FORMAT ERRORS

RWMSG(MPAREN) _  'MISSING ( OR )'
RWMSG(BDFMCH) _ 'ILLEGAL CHARACTER IN FORMAT'
RWMSG(BDCNT) _ 'COUNT CANNOT PRECEDE , ) T'
RWMSG(EXNEST) _ 'MAXIMUM () NESTING LEVEL OF 10 EXCEEDED'
RWMSG(NOWDTH) _ 'MISSING WIDTH SPECIFICATION'
RWMSG(BDHCNT) _ 'MISSING OR IMPROPER H OR X COUNT'
RWMSG(FMOVFL) _ 'TOO MANY SPECIFICATIONS IN FORMAT'
RWMSG(NOTERM) _ 'MISSING STRING TERMINATOR'
RWMSG(LRGCNT) _ 'WIDTH OR COUNT TOO LARGE'
RWMSG(MSMTCH) _ ' VARIABLE'  !MISMATCH OF FIELD & VARIABLE TYPES
RWMSG(NOSPEC) _ 'FORMAT NEEDS A DATA FIELD SPECIFICATION'
RWMSG(ZRWDTH) _ 'INPUT FIELD WIDTH MUST BE >=1'
RWMSG(BDTSPC) _ 'IMPROPER T FIELD SPECIFICATION'
RWMSG(SHTFLD) _ 'OUTPUT FIELD IS TOO SHORT'
RWMSG(BDNSPC) _ 'N IN FORMAT CANNOT TAKE A STRING VALUE'

!  OTHER ERRORS:

RWMSG(NMOVFL) _ 'VALUE TOO LARGE FOR VARIABLE TYPE'
RWMSG(BDINCH) _ 'ILLEGAL CHARACTER FOR NUMERIC CONVERSION'
RWMSG(BDBNIO) _ 'BINARY FIXED LENGTH RANDOM I/O MUST END ON RECORD&
 BOUNDARY'
RWMSG(TOOFAR) _ 'I/O TO FIXED LENGTH RECORD EXCEEDS RECORD LENGTH'
RWMSG(BDCRLF) _ 'CARRIAGE RETURN NOT FOLLOWED BY LINE FEED'


LOCAL %CAP
LOCAL %NXVAL.INIT, %NXVAL, %INIT.WKON, %SPECPG, %DO.FORM
LOCAL %NXGET.INIT, %NXPUT.INIT, %NXGET, %NXGETL, %NXPUT
LOCAL  %TAB

! MACHINE DEPENDENT

LOCAL %DO.LIT.I, %DO.LIT.O, %STRUP.SAV, %STRUP.RES, SPTR(0:2)
LOCAL %GETCH
LOCAL %NUMPKG, %NUMPK.INIT, %NUMPK, %TRUNC
LOCAL %IBINSTR, %OBINSTR
LOCAL %CSIZ, %ADV.VADR
LOCAL 	%NMLST
TABLE WPVT(INT:LGC) [1,1,2,2,1]  !WDS PER VAR
DEF WPV AS WPVT(VTYP)   !EXCLUDES VTYP STRING
DEF AWDSZ AS VCNT*WPV !NO. OF WDS IN ARRAY OF VCNT ELEMENTS
DEF SCSIZ AS SSIZE(1)
DEF BELL AS 7
DEF RLDGMAX AS 8
DEF DBDGMAX AS 16
DEF SPECLIM AS (SPECMAX+1)/2  !SIZE OF ARRAY TO HOLD SPECMAX SPECS
DEF NXSPEC AS NHWV SPECP
DEF SPECPI AS HWPT(SPEC,1)

LOCAL FLDTP, FLDW, FLDD, SCALE, WAITFG
LOCAL VTYPI, VCNTI, FLDTPI, CHAR
LOCAL STRCAP   !CAN'T ACCESS TIL AFTER STRP.INIT

TABLE DGMAX(INT:DOUB) [DB.DGMAX, RL.DGMAX, DB.DGMAX]

DEF RMNEL AS (RECSZ-ELCNT(FN))     !RECSZ LARGE NO. IF NOT FRL

!  USED BY FORMSCAN, NXFLD, INFLD, OUTFLD
!    ORDER AND VALUES COINCIDE WITH FMCH ENTRIES, BELOW, AND ARE
!    DEPENDED ON BY VARIOUS PROCEDURES AS INDICATED

DEF FFLD   AS 1
DEF EFLD   AS 2
DEF DFLD   AS 3     !   DO.FORM DEPENDS ON:
DEF JFLD   AS 4
DEF IFLD   AS 5     ! = NUMTMAX
DEF LFLD   AS 6     ! = LGC
DEF SWFLD  AS 7     ! = STR
DEF SFLD   AS (SWFLD+1)     ! FORMSCAN
DEF QUOTE  AS SFLD
DEF AFLD   AS 9
DEF RFLD   AS 10
DEF OFLD   AS 11
DEF GFLD   AS 12
DEF GWFLD  AS (GFLD+1)     ! FORMSCAN
DEF PRIME  AS GWFLD
DEF UTILMAX AS  GWFLD
DEF NONUTIL(FLDTP) AS FLDTP<HFLD          !INFLD
DEF UTIL(FLDTP) AS HFLD<= FLDTP <=SLSH    !DO.FORM
DEF HFLD   AS 14
DEF XFLD   AS 15
DEF TFLD   AS 16
DEF SLSH   AS 17
DEF EOFORM AS 18     ! NXFLD
DEF DOFLDCNT AS EOFORM     ! INFLD, OUTFLD
DEF AMP    AS 19
DEF PSPEC  AS 20
DEF LPAREN AS 21     ! SPECPK, SPECUNPK
DEF RPAREN AS 22
DEF LCLRPT AS 23     ! NXFLD DOES EOFORM:LCLRPT CASE
DEF COMM   AS 23
DEF PLUS   AS 24
DEF MNUS   AS 25
DEF DOT    AS 26
DEF FMCHCNT AS DOT

TABLE FMCH(FMCHCNT) [$F, $E, $D, $J, $I, $L, $S, $", $A, $R, $O, $G, $', &
  $H, $X, $T, $/, EOLIT, $&, $P, $(, $), $,, $+, $-, $.]

!FOLLOWING IS USED IN DO.FORM
TABLE MTCHFG1(0:UTILMAX*3-1) &
!NUM![0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, &
!LGC! 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 2, 2, &
!STR! 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 2, 2]
!     F  E  D  J  I  L  SW S  A  R  O  G  GW   
DEF MTCHFG(I,F) AS MTCHFG1((I)*UTILMAX-NUMTMAX*UTILMAX+(F)-1)
TABLE VTXT(NUMTMAX:VTYPMAX) ['NUMERIC','LOGICAL','STRING']


!  OF GENERAL INTEREST:

TABLE PWR10(0:10) [1,10,100,1000,10000,100000,1000000, &
  10000000,100000000,1000000000,10000000000]
DEF BPW AS BITS.PER.WORD
DEF HUGE AS (-1 SHR 1)

DEF YES AS 1
DEF NO AS 0

!  INITIALIZATION (CALLED ONCE)

         INIT.WKON
         RETURN


%RWINIT
! INITIALIZATION (CALLED WHEN RUN COMMAND IS GIVEN)

LOCAL %NULLP

GLCNT _ 0
SETPRMPT(%NULLP); POUT(%NXPUT)
%%NULLP
RETURN

END RWINIT


!  ERROR HANDLING

LOCAL %ERR, %SPERR, %FMERR, %SP.FMERR, %SETPROC, %PRWMSG, %PRFORM

%SETPROC (%PROC)
LOCAL %X, %Y
RETURN

! OK IF ERR PROCS DESTROY RETURN SINCE THEY DON'T (RETURN)
%%ERR (N)
SETPROC(%PRWMSG)

%%SPERR (N, %PROC)
RWERR(N,%Y)

%%FMERR (N)
SETPROC(%PRWMSG)

%%SP.FMERR (N, %PROC)
RWERR(N,%X)

%%X
PUT(CARRET)
PRINT('ERROR IN FORMAT '); PRFORM; PUT(CARRET)
%%Y
PROC;RETURN

%PRWMSG
PRINT(RWMSG(N)); PUT(CARRET); RETURN

END PRWMSG

END SETPROC


%CAP

!  CHARACTER CAPACITY OF VARIABLE OF TYPE VTYP (NON-LOGICAL)

RETURN IF VTYP=STR THEN STRCAP ELSE CPW*WPV

END CAP


%NXVAL.INIT

!  IF NOT IN MID-ARRAY OR MID-COMPLEX VAR:  CALL NXVAR & IF CPLX,
!   DOUBLE VCNT & SET VTYP TO REAL, BUT SAVE ACTUAL TYPE IN VTYPI
!   (NEED TO KNOW, EG, IN FREE FORM OUTPUT).
!  ELSE:  ADVANCE VADR (TO NEXT ARRAY ELEMENT OR IMAG. PART OF CPLX)

         WAITFG _ NO; VCNT _ 1; RETURN

%%NXVAL
         IF WAITFG<==NO THEN RETURN     !SEE DO.FORM

         IF DEC VCNT=0 THEN DO
           NXVAR
           IF VTYPI _ VTYP =CPLX THEN [VTYP _ REAL; VCNT _ VCNT SHL 1]
	    VCNTI _ VCNT
         END ELSE ADV.VADR
         RETURN

END NXVAL.INIT


%READ

LOCAL %INFLD
LOCAL %OCTPK.INIT, %OCTPK, %PUTCHAR, %PUTFLD
LOCAL I, CHAR, %INCHERR, TERMFG

         NXGET.INIT
         DO FTYP OF SYM:BIN

!  BINARY INPUT

BIN:	LOOP DO
         NXVAR; IF VTYP=STR THEN IBINSTR
         DEC VADR; REPEAT AWDSZ ^INC VADR _ NXGET
	END

SYM:     SET.TERM(BELL)
         IF FREEFORM THEN DO

!  FREE FORM SYMBOLIC INPUT

! TERMFG: 1 IF PREVIOUS TERMINATOR WAS COMMA OR CARRET
!        -1 IF PREVIOUS TERM NOT COMMA OR CARRET
!         0 IF 1ST (NONBLANK) CHAR AFTER PREV TERM NOT COMMA OR CARRET

	NXVAL.INIT
         CHAR _ CARRET    !FOR 1ST TERMFG
         IF CRFG(FN) THEN INITREC(FN)
	LOOP DO
         NXVAL
! REDO WHEN <COMMA,CARRET> AFTER NON<COMMA,CARRET> TERM
REDO:    TERMFG _ IF CHAR=$, OR CHAR=CARRET THEN 1 ELSE -1
         IF FN=TEL AND ELCNT(TEL)=0 THEN PUTX(BELL)
         WHILE CHAR _ NXGET =$  THEN NULL
	 EIF $,#CHAR#CARRET THEN TERMFG _ 0
	 FIF TERMFG<0 THEN GO REDO
! TERMFG#0 HERE ==> <COMMA,CARRET> AFTER <COMMA,CARRET> ==> NULL ENTRY
         DO VTYP OF VTYPRNG

LGC:     LSCAN.INIT
         IF TERMFG=0 THEN DO
           LOOP DO
             SCAN(CHAR)
             WHILE $ # CHAR _ NXGET #$, AND CHAR#CARRET
           END
         END
         SCAN(EOLIT)

STR:     STRP.INIT
         IF TERMFG=0 THEN DO
           IF $'# CHAR #$" THEN DO
             LOOP DO
               STRPK(CHAR)
               WHILE $,# CHAR _ NXGET #CARRET
             END
           END ELSE WHILE I_ NXGETL #CHAR OR I_NXGETL =CHAR THEN STRPK(I)
!	THAT WIERD STATEMENT CHECKS FOR PAIRED DELIMITERS.
!	IF A DELIMITER IS PAIRED,IT IS TAKEN AS PART OF THE STRING.
         END
         STRPK(EOLIT)

INT: REAL: DOUB:  NUMSC.INIT
         IF TERMFG=0 THEN DO
           LOOP DO
             NUMSCAN(CHAR)
             WHILE $ # CHAR _ NXGET #$, AND CHAR#CARRET
           END
         END
         NUMSCAN(-2)

         END
	END

FRI.EOV: IF FTYP=BIN AND FMODE=FRL AND RMNEL THEN ERR(BDBNIO)

         END ELSE DO.FORM(%INFLD)     !  FORMATTED SYMBOLIC INPUT

         END

	 SET.TERM(EOLIT)
         RETURN

OVFLERR: SPERR(NMOVFL,%PUTFLD)

%INCHERR (CHAR)

SPERR(BDINCH,%PUTCHAR)

%PUTCHAR

IF CHAR>0 THEN PUT(CHAR); PUT(CARRET)

%%PUTFLD

IF NOT FREEFORM THEN [PUT(FMCH(FLDTPI)); PRINT(' FIELD: ')]
PRWMSG; RETURN

END PUTCHAR

END INCHERR


%INFLD

         IF NONUTIL(FLDTP) AND FLDW=0 THEN FMERR(ZRWDTH) !SFLD FLDW=NONE
         DO FLDTPI _ FLDTP OF DOFLDCNT

SLSH: EOFORM: &
         EIF FMODE#FRL THEN WHILE CRFG(FN)=NO THEN NXGET
	 ORIF CORE.IO THEN REPEAT RMNEL NXGET
         ELSE SETCP(FN,CP(FN)+RMNEL)   !FRL
         INITREC(FN)

TFLD:    TAB(0)

XFLD:    REPEAT FLDW NXGET

HFLD:    DO.LIT.I

SFLD:    STRP.INIT
         LOOP DO
           REPEAT RMNEL; CHAR _ NXGET; WHILE NOT CRFG(FN); STRPK(CHAR)
         END
         STRPK(EOLIT)

SWFLD:   STRP.INIT; REPEAT FLDW STRPK(NXGET); STRPK(EOLIT)

AFLD: RFLD: &
	STRP.INIT
	EIF FLDW-I_CAP>=0 THEN DO
	  REPEAT FLDW-I NXGET
	  REPEAT I STRPK(NXGET)
	END
	ORIF FLDTP=AFLD THEN DO
	  REPEAT FLDW STRPK(NXGET)
	  REPEAT I-FLDW STRPK($ )
	END
	ELSE DO  !RFLD
	  REPEAT I-FLDW STRPK($ )
    	  REPEAT FLDW STRPK(NXGET)
	END
	 STRPK(EOLIT)

LFLD: OFLD: &
         SCAN.INIT
         IF NOT CRFG(FN) THEN DO
           REPEAT FLDW DO
             IF CHAR _ NXGET =$, THEN GO OUTL; SCAN(CHAR)
           END
         END
OUTL:    SCAN(EOLIT)

GFLD:    FLDTP _ EFLD; GO NUM

IFLD: JFLD: FFLD: EFLD: DFLD: &
NUM:     NUMSC.INIT
         IF CRFG(FN) THEN GO FREE
         REPEAT FLDW DO
           IF CHAR _ NXGET = $, THEN GO FREE; NUMSCAN(CHAR)
         END
         IF FLDTP#IFLD AND FLDTP#JFLD THEN NUMSCAN(-1) ELSE DO
FREE:      NUMSCAN(-2)
         END

         END

         RETURN

END INFLD


%LSCAN.INIT

LOCAL SAVE, VAL

FLDTP _ LFLD

%%SCAN.INIT

         SAVE _ RETURN

IF FLDTP=LFLD THEN DO
         VAL _ NO
         WHILE CHAR _ SCAN #EOLIT THEN DO
           IF CHAR=$F THEN DO
IGNOR:       WHILE SCAN#EOLIT THEN NULL; GO STOR
           END
           IF CHAR=$T THEN [VAL _ YES; GO IGNOR]
         END
STOR:    LGCPK(VAL)

END ELSE DO
	OCTPK.INIT
	WHILE CHAR_SCAN=$0 OR CHAR=$  THEN NULL
	WHILE CHAR#EOLIT THEN DO
	  EIF $0<=CHAR<=$7 THEN CHAR-_$0
	  ORIF CHAR=$  THEN CHAR_0
	  ELSE INCHERR(CHAR)
	  OCTPK(CHAR); CHAR _ SCAN
	END
	OCTPK(-1)
END

%%SCAN (X)

         SAVE<=>RETURN; RETURN X

END LSCAN.INIT


%NUMSC.INIT

!  SENDS TO NUMPK:  DIGITS OF MANTISSA, LAST FOLLOWED BY -1, SIGN
!  OF MANTISSA (1 IF POS, -1 IF NEG.), AND SIGNED EXPONENT (IN
!  ACCUMULATING EXPONENT, OVERFLOW CHECKED AGAINST 1000; FINAL CHECK
!  MADE BY NUMPK)
!  SENDS 1 AS EXPONENT IF MANTISSA IS 0.

LOCAL D, P, SGNFG, SGN, ICNT, ZCNT, EXP,  INDX, STATE
TABLE NUMCH(2:10) [$+, $-, $0, $ , $E, $D, -1, -2, $.]

!  CHARACTER INDX VALUES

DEF NUM      AS 1
DEF PLUS     AS 2
DEF MNUS     AS 3
DEF ZERO     AS 4
DEF BLNK     AS 5
DEF ECHAR    AS 6
DEF DCHAR    AS 7
DEF FORM.TRM AS 8
DEF FREE.TRM AS 9
DEF DOT      AS 10

!  STATE VALUES

! DISTINGUISH BETWEEN BGN AND S.IZ BECAUSE SIGN ILLEGAL IF S.IZ

DEF BGN   AS 1               !SEEN NOTHING OR LEADING BLANKS
DEF S.IZ  AS 2               !SEEN INTEGER ZERO (NO DOT)
DEF S.INZ AS 3               !SEEN INTEGER NON-ZERO DIGIT
DEF S.DZ  AS 4               !SEEN DOT
DEF S.DNZ AS 5               !SEEN DOT & NON-ZERO DIGIT
DEF S.E   AS 6               !SEEN E OR D
DEF S.EDG AS 7               !SEEN EXPONENT DIGIT

         D _ FLDD; P _ SCALE
         SGNFG _ ICNT _ ZCNT _ EXP _ 0
         SGN _ 1
         STATE _ BGN
         NUMPK.INIT
         RETURN

%%NUMSCAN (CHAR)

         INDX _ 1
         IF $1 <= CHAR <= $9 THEN GO CASE
         REPEAT 9 IF CHAR=NUMCH(INC INDX) THEN GO CASE
         INCHERR(CHAR)
CASE:    DO INDX OF 10

DOT:     IF STATE>S.INZ THEN INCHERR(CHAR)
         D _ 0; STATE _ IF STATE=S.INZ THEN S.DNZ ELSE S.DZ

MNUS:    SGN _ -1; GO NX4
PLUS: NX4: IF SGNFG<==YES OR BGN#STATE#S.E THEN INCHERR(CHAR)

BLNK:    IF S.IZ<STATE<S.E THEN GO NXN
ZERO: NXN:  DO STATE OF S.EDG

BGN:     STATE _ S.IZ
S.IZ:    NULL
S.INZ:   INC ICNT; INC ZCNT
S.DZ:    DEC ICNT
S.DNZ:   INC ZCNT
S.E:     STATE _ S.EDG
S.EDG:   CHAR _ 0; GO NX6

           END

NUM:     CHAR _ CHAR-$0
         DO STATE OF S.EDG

BGN: S.IZ:  INC ICNT; NUMPK(CHAR); STATE _ S.INZ
S.DZ:       NUMPK(CHAR); STATE _ S.DNZ
S.INZ:      INC ICNT; GO NX1
S.DNZ: NX1: REPEAT ZCNT<==0 NUMPK(0); NUMPK(CHAR)
S.E:        EXP _ CHAR; STATE _ S.EDG
S.EDG: NX6: IF EXP _ EXP*10+CHAR >1000 THEN GO OVFLERR

         END

ECHAR: DCHAR: SGNFG _ NO
              DO STATE<==S.E OF S.EDG

S.E: S.EDG:        INCHERR(CHAR)
BGN: S.IZ: S.DZ:   ZCNT _ -1; GO NX5    !FLAGS S.EDG UPON TERMINATION
S.INZ: S.DNZ:      NUMPK(-1); NUMPK(SGN<==1)

              END

FREE.TRM: P _ D _ 0; GO NX3
FORM.TRM: NX3: DO STATE OF S.EDG

BGN: S.IZ: S.DZ: &
NX5:             NUMPK(0); NUMPK(-1); NUMPK(1); NUMPK(1)
S.INZ: S.DNZ:    NUMPK(-1); NUMPK(SGN); NUMPK(ICNT-P-D)
S.E:             INCHERR(CHAR)
S.EDG:           IF ZCNT>=0 THEN NUMPK(EXP*SGN+ICNT-D)  &
                      !IF ZCNT<0, SENT EXP 1 WHEN SAW 0 MANTISSA

               END

         END

         RETURN

END NUMSC.INIT


%OCTPK.INIT

! COROUTINE TO PACK OCTAL DIGITS IN 1 OR 2 WORDS.

LOCAL SAVE, HI, LO, CNT, TMP

	SAVE _ RETURN
	HI _ LO _ CNT _ 0
	DO WPV OF 1:2

1:	LOOP DO
	  WHILE TMP_OCTPK>=0; IF INC CNT>BPW/3 THEN GO OVFLERR
	  HI _ HI SHL 3 BOR TMP
	END

2:	LOOP DO
	  WHILE TMP_OCTPK>=0; IF INC CNT>2*BPW/3 THEN GO OVFLERR
	  [HI;LO] _ [HI;LO] DSHL 3; LO BOR_ TMP
        END

	END
	MOVE WPV FROM @HI TO VADR

%%OCTPK (X)

	SAVE<=>RETURN; RETURN X

END OCTPK.INIT

END READ


%INIT.WKON

         FLDMAX(CPLX) _ 1 + (FLDMAX(REAL) _ DGMAX(REAL)+5) SHL 1
         FLDMAX(DOUB) _ DGMAX(DOUB)+5
         RETURN

%%WRITE

LOCAL %MVFREE, %PRFREE, %OUTFLD, %EXPOUT
LOCAL %OCTUN.INIT, %OCTUN
LOCAL PFLG, TFLG, EXP, CNT, R, I
DEF POS AS ELCNT(FN)

DEF LDZMAX AS 3

         NXPUT.INIT
         IF CRFG(FN) THEN INITREC(FN)
         DO FTYP OF SYM:BIN

!  BINARY OUTPUT

BIN:	LOOP DO
         NXVAR; IF VTYP=STR THEN OBINSTR
         DEC VADR; REPEAT AWDSZ NXPUT(^INC VADR)
	END

SYM:     IF FREEFORM THEN DO

!  FREE FORM SYMBOLIC OUTPUT

	NXVAL.INIT
	LOOP DO
         NXVAL
         DO VTYP OF VTYPRNG

LGC:     MVFREE(1); NXPUT(IF LGCUNPK THEN $T ELSE $F)

STR:     MVFREE(CNT _ SCSIZ); STRUP.INIT
         REPEAT CNT NXPUT(STRUNPK)

INT:     NUMUN.INIT(INTFLD)
         MVFREE(1+CNT _ NUMUNPK)
         NXPUT(IF NUMPSGN THEN $- ELSE $ )
         REPEAT CNT NXPUT(NUMUNPK)

REAL: DOUB: &
         TFLG _ [VTYPI=CPLX]
         MVFREE(FLDMAX(VTYPI))
         LOOP DO
	   FLOUT
	   WHILE TFLG<==0  
           NXPUT($,); NXVAL
	 END

         END
	END

FRO.EOV: IF FTYP=SYM THEN NXPUT(CARRET) ELSE DO
           IF FMODE=FRL AND RMNEL THEN ERR(BDBNIO)
       END

         END ELSE DO.FORM(%OUTFLD)    !  FORMATTED SYMBOLIC OUTPUT

         END

         RETURN

%MVFREE (FLDSZ)

!  FREE FORM PRINT ZONE RULE:  ZONES ARE THREE SPACES EACH; ADVANCE
!  2 SPACES; IF NOT AT BEGINNING OF ZONE, MO BEGINNING OF NEXT 
!  ZONE.

IF POS+FLDSZ+I _ IF POS>0 THEN 4-((POS+1) MOD 3) ELSE 0 > TTYLEN-1 &
  THEN NXPUT(CARRET) ELSE REPEAT I NXPUT($ )
RETURN

END MVFREE


%POUT (%NXPUT)
LOCAL OLDP
RETURN OLDP<==%NXPUT

%FLOUT

           NXPUT(IF NUMUN.INIT(EXPFLD) THEN $- ELSE $ )
           PFLG _ NO    !USED IN PRFREE
           EIF -LDZMAX <= EXP _ NUMUNPK(R _ DGMAX(VTYP)-1) <= 0 THEN DO
             NXPUT($.); PFLG _ YES; REPEAT -EXP NXPUT($0)
             PRFREE(0)
           END
           ORIF 0 < EXP <=R THEN PRFREE(EXP)
           ELSE [PRFREE(1); NXPUT($E); EXPOUT(EXP-1)]
	   RETURN

END FLOUT


%PRFREE (N)

!  UNPACKS & WRITES N DIGITS.  WRITES R-N DIGITS (SUPPRESSING
!  TRAILING ZEROES)  PRECEDED BY '.' IF NON-ZERO ENCOUNTERED.
!  NOTE '.' NOT WRITTEN IF PFLG IS YES.

       REPEAT N NXPUT(NUMUNPK); CNT _ 0
       REPEAT R-N DO
         IF I _ NUMUNPK #$0 THEN DO
           IF NO=PFLG<==YES THEN NXPUT($.)
           REPEAT CNT<==0 NXPUT($0); NXPUT(I)
         END ELSE INC CNT
       END
       RETURN

END PRFREE


%EXPOUT (EXP)

         IF EXP<0 THEN [EXP -_; NXPUT($-)] ELSE NXPUT($+)
         I _ 2; IF EXP>99 THEN INC I
         REPEAT I [[R;EXP] _ EXP DIVMOD PWR10(DEC I); NXPUT(R+$0)]
         RETURN

END EXPOUT

END POUT


%OUTFLD

LOCAL %LDBLNK, %DECOUT

         DO FLDTP OF DOFLDCNT

SLSH: EOFORM: &
         IF FMODE#FRL THEN NXPUT(CARRET) ELSE DO
           REPEAT RMNEL NXPUT($ )
         END
         INITREC(FN)

TFLD:    TAB(1)

XFLD:    REPEAT FLDW NXPUT($ )

HFLD:    DO.LIT.O

SFLD:    STRUP.INIT
         WHILE CHAR _ STRUNPK #EOLIT THEN NXPUT(CHAR)

SWFLD:   STRUP.INIT; I _ FLDW+1
	 LOOP DO
           WHILE DEC I>0
           WHILE CHAR _ STRUNPK #EOLIT; NXPUT(CHAR)
         END
         REPEAT I NXPUT($ )

AFLD: RFLD: &
	STRUP.INIT
	EIF FLDW>=I_CSIZ THEN DO
	  REPEAT FLDW-I NXPUT($ )
	END
	FIF FLDTP=RFLD THEN DO
	  REPEAT I-FLDW STRUNPK
	END
	REPEAT I MIN FLDW NXPUT(IF I_ STRUNPK = EOLIT THEN $  ELSE I)

LFLD:    IF FLDW THEN DO
           REPEAT FLDW-1 NXPUT($ )
           NXPUT(IF LGCUNPK THEN $T ELSE $F)
         END

OFLD:	OCTUN.INIT
	LOOP DO
	  REPEAT EXP_WPV*BPW/3
	  WHILE R_OCTUN=$0; DEC EXP
	END
	IF EXP=0 THEN INC EXP; LDBLNK(EXP); NXPUT(R)
	REPEAT EXP-1 NXPUT(OCTUN)

IFLD: JFLD:    NUMUN.INIT(INTFLD)
         LDBLNK(NUMPSGN+EXP _ NUMUNPK)
         REPEAT EXP NXPUT(NUMUNPK)

FFLD:    NUMUN.INIT(DECFLD)
         IF EXP _ NUMUNPK(FLDD+SCALE)+SCALE >0 THEN DO
FFLDA:     LDBLNK(NUMPSGN+EXP+1+FLDD)
           DECOUT(EXP,FLDD)
         END ELSE DO 
           IF FLDD=0 THEN [EXP _ 1; GO FFLDA]  !OR WILL BE NO DIGITS
           LDBLNK(NUMPSGN+1+FLDD)
           NXPUT($.); REPEAT -EXP MIN FLDD NXPUT($0)   !LEADING 0'S
           REPEAT FLDD+EXP NXPUT(NUMUNPK)   !REST OF DECIMAL PART
         END

EFLD: DFLD: &
EFLDA:   NUMUN.INIT(EXPFLD)
         IF SCALE<=0 THEN DO
           IF FLDD=0 THEN FMERR(SHTFLD); R _ FLDD+SCALE
         END ELSE R _ IF SCALE<=FLDD THEN FLDD+1 ELSE SCALE
         EXP _ NUMUNPK(R)
EFLDB:   LDBLNK(6+(R MAX FLDD)); IF NOT NUMPSGN THEN NXPUT($ )
         IF SCALE>0 THEN DO
           DECOUT(SCALE,R-SCALE)
         END ELSE DO    !NO DIGITS BEFORE DECIMAL, FLDD AFTER
           NXPUT($.)
           REPEAT -SCALE MIN FLDD NXPUT($0)
           REPEAT R NXPUT(NUMUNPK)
         END
         NXPUT(FMCH(FLDTP)); EXPOUT(EXP-SCALE)

GFLD:    NUMUN.INIT(EXPFLD)
         IF 0<= EXP _ NUMUNPK(R _ FLDD) <=FLDD THEN DO   !DECIMAL OUTPUT
           LDBLNK(FLDD+6); IF NOT NUMPSGN THEN NXPUT($ )
           DECOUT(EXP,FLDD-EXP)
           REPEAT 4 NXPUT($ )
         END ELSE DO    !EXPONENTIAL TYPE OUTPUT
           FLDTP _ EFLD; IF SCALE THEN GO EFLDA
           GO EFLDB   !REROUNDING NOT NECESSARY
         END

         END

         RETURN

%LDBLNK (NUMSZ)

!  NUMSZ CHARS ARE TO BE WRITTEN IN FLDW  POSITIONS.  IF FIELD TOO
!  SHORT, ERROR, ELSE WRITE ANY LEADING BLANKS AND SIGN IF NEG.

         IF I _ (FLDW-NUMSZ) <0 THEN FMERR(SHTFLD)
          IF FLDTP # JFLD THEN REPEAT I NXPUT($ )
         IF NUMPSGN THEN NXPUT($-)
	  IF FLDTP = JFLD THEN REPEAT I NXPUT($0)
         RETURN

END LDBLNK

%DECOUT (IDIG, DDIG)

         REPEAT IDIG NXPUT(NUMUNPK)
         NXPUT($.); REPEAT DDIG NXPUT(NUMUNPK)
         RETURN

END DECOUT

END OUTFLD


%OCTUN.INIT

! COROUTINE TO RETURN OCTAL DIGIT CHARACTERS FROM ^VADR, ^(VADR+1), ETC.

LOCAL SAVE, HI
	SAVE _ RETURN
	I _ -1
	OCTUN

	LOOP DO
	  HI _ ^(VADR+INC I) ROTL 3
	  REPEAT BPW/3 OCTUN(((HI<==HI ROTL 3) BAND 7)+$0)
	END

%%OCTUN (X)
	SAVE<=>RETURN; RETURN X

END OCTUN.INIT

END INIT.WKON


%DO.FORM (%DO.FLD)

LOCAL %NXFLD.INIT, %NXFLD, %DO.UTIL, %PUTMTCH
LOCAL AMPFLG, I

	NXFLD.INIT; NXVAL.INIT; DO.UTIL
	IF FLDTP=EOFORM THEN [NXVAL; FMERR(NOSPEC)]
	LOOP DO
         NXVAL
         IF FLDTP=EOFORM THEN DO
           IF AMPFLG THEN AMPFLG _ NO ELSE DO.FLD     !DOES /
           WAITFG _ YES     !IN CASE OF N'S (RESET IF HIT ANY)
           DO.UTIL     !RESCAN
!        CHECK FOR RESCAN TO EOFORM (DUE TO 0 COUNT OR ONLY UTIL SPECS)
           IF FLDTP=EOFORM THEN FMERR(NOSPEC)
           NXVAL   !NULL IF WAITFG (NO N'S HIT) ELSE READS I/O VALUE
         END
         DO MTCHFG(I _ VTYP MAX NUMTMAX, FLDTP) OF 2
1:         SP.FMERR(MSMTCH,%PUTMTCH)
2:         FLDTP _ I
         END
         DO.FLD; DO.UTIL
	END     !OF LOOP

FMI.EOV: FMO.EOV:  IF NOT AMPFLG THEN [FLDTP _ SLSH; DO.FLD]; RETURN

%PUTMTCH

PUT(FMCH(FLDTP)); PRINT(' FIELD CANNOT BE USED WITH ')
PRINT(VTXT(I)); PRWMSG; RETURN

END PUTMTCH

%DO.UTIL
!  UTIL DOES NOT INCLUDE EOFORM

         WHILE UTIL(FLDTP _ NXFLD) THEN DOFLD; RETURN

END DO.UTIL


%SPECPG

!  SPECS ARE PACKED 1 PER TOTLB BITS.  1ST IDB BITS CONTAIN IDENTIFIER.
!  IF REPEAT COUNT: REMAINING BITS HOLD COUNT+1.  MOST
!  OTHER SPECS: NEXT FLDWB BITS HOLD FLDW+1, REST HOLD FLDD+1,
!  IF ANY FLDD. SCALE FACTOR: FLDW IS MAGNITUDE, FLDD IS 0 IF
!  NEGATIVE, ELSE 2. NO INFO BUT ID STORED FOR SFLD, SLSH,
!  EOFORM, AMP, RPAREN.  STRING LITERAL: FLDD IS 1+INDEX TO
!  STRING PTR (IN STRL TABLE).
!  A COUNT OR WIDTH STORED AS 0 INDICATES 'N' WAS SPECIFIED.
!  SOME SPECS (REPEAT END, FORMAT END, S) USE ONLY THE ID FIELD,
!  OTHERS (T, I, ETC.) DON'T USE FLDD; THE CONTENTS OF AN UNUSED
!  FIELD IS UNDEFINED EXCEPT THAT IT WILL NOT BE 0 (DUE
!  TO GETNXVAL AT SPECUNPK TIME).

!  NO. OF BITS PER FIELD
DEF IDB   AS 5
DEF FLDWB AS 8
DEF FLDDB AS 5
DEF CNTB  AS 13
DEF TOTLB AS 18
DEF REMB  AS (BPW-TOTLB)
!  MAX VALUES TO USER
DEF FLDWMAX AS 254
DEF FLDDMAX AS 30
DEF CNTMAX  AS 8190

LOCAL FCNT

DEF STRLIMAX AS (FLDDMAX-1)
DEF STRLSZ AS (INSPTSZ+1)   !SIZE OF STRL ENTRY (1 FOR VTYP)
LOCAL STRL(STRLIMAX*STRLSZ)         !STRING LITERAL POINTER TABLE
LOCAL STRLI                  !STRL PTR
!STRL PTR CORRESPONDING TO STRLI:
DEF STRLP(STRLI) AS ((STRLI-1)*STRLSZ+1)

DEF SPECMAX AS 250   !??!   !MAX NO. OF SPECS
LOCAL SPEC(SPECLIM)   !HOLDS SPECMAX SPECS
LOCAL SPECP, SPECNT


%NXFLD.INIT

LOCAL %FORMSCAN, %SPECUNPK, %TYPUNPK

LOCAL RPTLEV            !ALSO USED IN FORMSCAN
DEF RPTLEVMAX AS 10
LOCAL RPTPTR(RPTLEVMAX)
LOCAL RPTCNT(RPTLEVMAX)

LOCAL RESCAN
LOCAL SAVE, LRPT, SAVLEV
LOCAL FLDTP    !SO MAY BE RESET OUTSIDE W/O HARM TO REPEAT LOOP

         SAVE _ RETURN
         FORMSCAN
         SPECP _ SPECPI
         RPTLEV _ SCALE _ AMPFLG _ 0
         NXFLD

!  REMEMBER: AMP CAN HAVE A LCLRPT COUNT
	LOOP DO
         LRPT _ 1
CONTU:   IF SPECUNPK < EOFORM THEN DO
           REPEAT LRPT NXFLD
         END ELSE DO FLDTP OF EOFORM:LCLRPT

EOFORM:    SPECP _ RESCAN; NXFLD

LCLRPT:    LRPT _ FCNT; GO CONTU     !EVEN IF 0, N'S ARE EVALUATED

LPAREN:    IF FCNT=0 THEN DO
!          SKIP TO END REPEAT, IGNORING ANY ENCLOSED N'S
             SAVLEV _ RPTLEV; INC RPTLEV
             WHILE RPTLEV#SAVLEV THEN DO
               IF TYPUNPK=LPAREN THEN INC RPTLEV ELSE &
                 IF FLDTP=RPAREN THEN DEC RPTLEV
             END
           END ELSE [RPTPTR(INC RPTLEV) _ SPECP; RPTCNT(RPTLEV) _ FCNT]

RPAREN:    IF DEC RPTCNT(RPTLEV)>0 THEN SPECP _ RPTPTR(RPTLEV) &
             ELSE DEC RPTLEV

AMP:       AMPFLG _ [LRPT>0]

PSPEC:     SCALE _ (FLDD-1)*FLDW

         END
	END     !OF LOOP

%%NXFLD

         SAVE <=> RETURN; RETURN FLDTP


DEF NONE  AS -2
DEF NSPEC AS -1

%FORMSCAN

LOCAL %GETCNT, %NFMCH, %NFMCHL, %SPECPK, %LRPTPK, %PUTTERM
LOCAL %PFMCH, CFG, LAST     !SIMULATE PCHV
LOCAL SGN, TERM
TABLE SGNCH(0:2)[$-,0,$+]

         CFG _ 0
         SGN _ 1
         RPTLEV _ STRLI _ SPECNT _ 0; RESCAN _ SPECP _ SPECPI
	 STRUP.INIT; STRUP.SAV   !FOR ERROR MESSAGE
         IF GETCNT#NONE OR LAST#$( THEN FMERR(MPAREN)

CONT:    FLDTP _ FLDW _ FLDD _ 0
         FCNT _ GETCNT
         REPEAT FMCHCNT DO
           IF LAST = FMCH(INC FLDTP) THEN GO FCASE
         END
         GO FMCHERR

FCASE:   DO FLDTP OF FMCHCNT

EOFORM:  FMERR(MPAREN)         !HIT END BEFORE LAST )

DOT:     GO FMCHERR

COMM:    IF SGN#1 THEN GO SGNERR
         IF FCNT#NONE THEN FMERR(BDCNT); GO CONT

LPAREN:  IF FCNT=NONE THEN FCNT _ 1
         IF INC RPTLEV>RPTLEVMAX THEN FMERR(EXNEST)
         IF RPTLEV=1 THEN RESCAN _ SPECP     !BEFORE REPEAT COUNT

RPAREN:  IF FCNT#NONE THEN FMERR(BDCNT)
         IF DEC RPTLEV<0 THEN GO FMTEND

PLUS: MNUS: &
         IF SGN#1 OR FCNT#NONE THEN GO FMCHERR
         IF FLDTP=PLUS THEN INC SGN ELSE DEC SGN
         GO CONT

PSPEC:   IF 1=FLDD _ SGN<==1 THEN INC FLDD     !0 FOR -, 2 FOR +
         IF NONE=FLDW _ FCNT THEN FLDW _ 0

FFLD: EFLD: DFLD: GFLD: &
         FLDW _ GETCNT; FLDD _ 0
         IF LAST#$. THEN DO
           IF FLDTP=GFLD THEN INC FLDTP
         END ELSE DO
           IF FLDD _ GETCNT = NONE THEN FMERR(NOWDTH)
         END
         GO IFLDA

IFLD: JFLD: AFLD: RFLD: LFLD: OFLD: &
IFLDB:   FLDW _ GETCNT
IFLDA:   IF FLDW=NONE THEN FMERR(NOWDTH)
         GO SFLDA

SWFLD:   IF FLDW _ GETCNT = NONE THEN INC FLDTP
SFLDA:   PFMCH; LRPTPK

TFLD:    IF FCNT#NONE THEN FMERR(BDCNT)
         GO IFLDB

XFLD:    IF FLDW _ FCNT =NONE THEN FMERR(BDHCNT)

AMP: SLSH:   LRPTPK

HFLD: PRIME: QUOTE: &
	 STRUP.SAV
         IF HFLD=FLDTP<==HFLD THEN DO
           IF 0> FLDW _ FCNT THEN FMERR(BDHCNT)
           REPEAT FLDW IF NFMCHL=EOLIT THEN FMERR(BDHCNT)
         END ELSE DO
	   TERM _ LAST
           WHILE NFMCHL # EOLIT THEN DO
             IF LAST=TERM THEN GO OUTL
             INC FLDW
           END
           FMERR(NOTERM)
OUTL:      LRPTPK
         END
         FLDD _ STRLI

         END


OUT:     SPECPK; GO CONT

FMTEND:  IF GETCNT#NONE OR LAST#EOLIT THEN FMERR(MPAREN)
         FLDTP _ EOFORM; SPECPK; RETURN

SGNERR: LAST _ SGNCH(SGN)
FMCHERR: SP.FMERR(BDFMCH,%PUTTERM)

%PUTTERM

PUT(LAST); PUT(CARRET); PRWMSG; RETURN

END PUTTERM

%PRFORM

STRUP.RES(@STRL(1)); WHILE CHAR _ STRUNPK #EOLIT THEN PUT(CHAR)
RETURN

END PRFORM


%GETCNT

!  IF NEXT ELEMENT IN FORMAT STRING IS AN INTEGER OR 'N' SPEC, RETURNS
!  VALUE OR -1, RESPECTIVELY; IF NEITHER, RETURNS -2.
!  BLANKS ARE IGNORED.  TERMINATING CHAR IS LEFT IN TERM, AND
!  NFMCH WILL BE ONE CHAR BEYOND TERM.
!    NOTE: FOR PHASE 3, IS COMMENTED OUT.

LOCAL VAL

         VAL _ -2
GET1:    WHILE NFMCH =$  THEN NULL
         IF VAL #-1 THEN DO
           IF $0 <= LAST <= $9 THEN DO
             IF VAL<0 THEN VAL _ 0
             IF VAL _ VAL*10+LAST-$0 > CNTMAX THEN FMERR(LRGCNT)
             GO GET1
           END
!           IF LAST=$N AND VAL<0 THEN [INC VAL; GO GET1]
         END
         RETURN VAL

%PFMCH

CFG _ -1; RETURN

%%NFMCH

! IGNORE LINE FEED

IF CFG=0 THEN [WHILE LAST _ STRUNPK=LNFEED THEN NULL] ELSE CFG _ 0; RETURN LAST

%%NFMCHL

! DON'T IGNORE LINE FEED

IF CFG=0 THEN LAST _ STRUNPK ELSE CFG _ 0; RETURN LAST

END PFMCH

END GETCNT


%STRUP.SAV

!  STORES  AT STRL(STRLI+1) WHATEVER NECESSARY
!  TO RESTORE CHAR UNPACKING AT CURRENT SPTR AT A LATER TIME.
!  INCREMENTS STRLI FOR NEXT STRUP.SAV.

IF INC STRLI>STRLIMAX THEN ERR(FMOVFL)
STRL(I_STRLP(STRLI)) _ VTYP; INC I
IF VTYP=STR THEN DO
  MOVE INSPTSZ FROM SPTR TO @STRL(I)
END ELSE DO
  STRL(I) _ SPTR(0)
END
RETURN

END STRUP.SAV


%SPECPK

         IF SGN#1 THEN GO SGNERR
         IF INC SPECNT>=SPECMAX THEN FMERR(FMOVFL)
         IF  FLDTP >=LPAREN THEN DO
           NXSPEC _ [REMB, IDB, CNTB] * [0, FLDTP, INC FCNT]
         END ELSE DO
           IF FLDW>FLDWMAX OR FLDD>FLDDMAX THEN FMERR(LRGCNT)
           NXSPEC _[REMB,IDB,FLDWB,FLDDB] * [0,FLDTP,INC FLDW,INC FLDD]
         END
         RETURN

END SPECPK

%LRPTPK

IF FCNT#NONE THEN NXSPEC _ [REMB, IDB, CNTB] * [0, LCLRPT, INC FCNT]
RETURN

END LRPTPK

END FORMSCAN


%SPECUNPK

!  UNPACKS NXSPEC BY SETTING FLDTP, FLDW, FLDD, FCNT
!  (GETTING VALUES FOR LATTER 3 IF 'N' IS INDICATED)

LOCAL %GETNXVAL

         EIF TYPUNPK>=LPAREN THEN IF DEC FCNT=NSPEC THEN FCNT_GETNXVAL
         ELSE DO
           [REMB+IDB, FLDWB, FLDDB] * [,FLDW, FLDD] _ FCNT
	   DEC FLDW; DEC FLDD
	   IF FLDTP=HFLD THEN DO
	     FLDD _ @STRL(STRLP(FLDD))
	   END ELSE DO
             IF FLDW=NSPEC THEN FLDW _ GETNXVAL
             IF FLDD=NSPEC THEN FLDD _ GETNXVAL
	   END
         END
       RETURN FLDTP

%GETNXVAL

!  GET VALUE OF NEXT DATA LIST ITEM, TRUNCATE IF REAL OR DOUBLE,
!  DISALLOW IF STRING.  NEGATIVE BECOMES 0 UNLESS P SPEC.
!  NOTE:  MAGNITUDE OF VALUE NOT CHECKED

LOCAL VAL

         NXVAL
         DO VTYP OF VTYPRNG

INT:        VAL _ ^VADR; GO REALA
REAL: DOUB: VAL _ TRUNC
REALA:      IF VAL<0 AND FLDTP#PSPEC THEN VAL _ 0
LGC:        RETURN LGCUNPK
STR:        FMERR(BDNSPC)

         END
         RETURN VAL

END GETNXVAL

END SPECUNPK

%TYPUNPK

         [REMB, IDB, CNTB] * [,FLDTP, FCNT] _ NXSPEC
         RETURN FLDTP

END TYPUNPK

END NXFLD.INIT

END SPECPG

END DO.FORM


%NXGET.INIT
%%NXPUT.INIT

LOCAL SAVE, CHAR, PTR

! CASES NOT LISTED ARE ILLEGAL (PREVIOUSLY CHECKED)

DEF FR.S.SQ AS 1
DEF FR.S.VL AS 2
DEF    B.SQ AS 4
DEF    B.VL AS 5
DEF    B.FL AS 6
DEF FM.S.SQ AS 7
DEF FM.S.VL AS 8
DEF    S.FL AS 9
DEF   CS.FL AS 10
DEF LAST AS CS.FL

DEF FL.I(NEXT) BY   IF CRFG(FN) THEN RETURN $ 
         IF RMNEL=0 THEN ERR(TOOFAR)
         CHAR _ NEXT
         INC ELCNT(FN); GO FMA
  ENDM FL.I

         SAVE _ [FTYP=BIN]*3+FMODE+[NOT FREEFORM]*6
	IF CORE.IO THEN [PTR _ CHPT(CADR,-1); SAVE _ CS.FL]
         RETURN

%%NXGET


         DO SAVE OF LAST

B.FL:    IF RMNEL=0 THEN ERR(TOOFAR); INC ELCNT(FN); GO NX
B.SQ: B.VL: NX:   RETURN R(FN)

! TEL INPUT: RETURN CARRET EVEN IF CTRL G
FR.S.SQ: FR.S.VL:   LOOP DO
                      IF GETCH<0 THEN [ELCNT(FN) _ 0; RETURN CARRET]
                      WHILE CHAR=LNFEED
                    END
                    RETURN CHAR

! FORMATTED: ELCNT(FN) IS ZEROED AT SLASH (EOFORM)
FM.S.SQ: FM.S.VL:   IF CRFG(FN) THEN RETURN $ ; GETCH
             FMA:   IF CHAR=CARRET THEN [CRFG(FN) _ YES; RETURN $ ]
                    RETURN CHAR

S.FL:	FL.I(R(FN))

CS.FL:	FL.I(NCHV PTR)

	END

%%NXGETL
! SPECIAL CASE FOR FR.S.SQ AND FR.S.VL: DON'T CHANGE CTRL G TO CARRET
	LOOP DO
	  IF GETCH<0 THEN ELCNT(FN) _ 0  !CTRL G OR CARRET
	  WHILE CHAR=LNFEED
	END
	RETURN CHAR


%%NXPUT (ELT)
LOCAL CHR

         DO SAVE OF LAST

B.FL: S.FL:   IF RMNEL=0 THEN ERR(TOOFAR); INC ELCNT(FN); W(FN,ELT)
B.SQ: B.VL:   W(FN.,ELT)

FR.S.SQ: FR.S.VL: FM.S.SQ: FM.S.VL: &
         IF ELT=CARRET THEN ELCNT(FN) _ 0 ELSE INC ELCNT(FN)
	IF NOT CCFILE THEN W(FN,ELT) ELSE DO
	    IF ELCNT(FN) = 1 THEN DO
	      CHR _ -1
	      IF $  <= ELT <= $3 THEN DO
		DO ELT OF $ :$3
		  $+:	CHR _ 0
	 $*:$.:$,:$ :	CHR _ LNFEED
		  $0:	REPEAT 2 W(FN,LNFEED); CHR _ 0
		  $1:	CHR _ OCT 14	! FORMFEED	!
	 $2:$3:$/:$-:	REPEAT 3 W(FN,LNFEED); CHR _ 0
		END
		  IF CHR # 0 THEN W(FN,CHR _ IF CHR = -1 THEN LNFEED ELSE CHR)
	      END ELSE W(FN,LNFEED)
	    END ELSE IF CCFILE AND ELT=CARRET THEN WX(FN,ELT) ELSE W(FN,ELT)
	  END


CS.FL:	IF RMNEL=0 THEN ERR(TOOFAR); INC ELCNT(FN)
	NCHV PTR _ ELT

         END
         RETURN

%GETCH
! MACHINE DEPENDENT IN CR-LF HANDLING
! STORE NEXT CHARACTER IN CHAR AND RETURN -1 IF END OF LINE,
! ELSE RETURN 0. REMEMBER: GETLINE MAY STORE CARRET IN MID-LINE DUE
! TO CONTROL V.

LOCAL LPTR

EIF FN=TEL THEN DO
  IF GLCNT=0 THEN LPTR _ GETLINE(TEL)
  INC ELCNT(TEL); CHAR _ NCHV LPTR
  IF DEC GLCNT=0 THEN RETURN -1
END
ELSE DO
  LOOP [CHAR _ R(FN); INC ELCNT(FN); WHILE CHAR=EOLIT]
  IF CHAR=CARRET THEN DO
    IF R(FN)#LNFEED THEN ERR(BDCRLF); INC ELCNT(FN)
    RETURN -1
  END
END
RETURN 0

END GETCH


%TAB (WFG)
! PROCESSES T SPEC, CAREFULLY. WFG 0 IF READ, 1 IF WRITE.

LOCAL I
DEF WT(FMODE) AS FMODE+FRL

	I _ FLDW-1-ELCNT(FN)
	DO FMODE+WFG*FRL OF WT(FRL)

SEQ:	IF I<0 THEN FMERR(BDTSPC)
SEQT:	REPEAT I NXGET

WT(SEQ): IF I<0 THEN FMERR(BDTSPC); REPEAT I NXPUT($ )

VRL:	IF I<0 THEN GO FRLT
	GO SEQT

FRL: WT(FRL):	IF FLDW>RECSZ THEN ERR(TOOFAR)
		IF CORE.IO THEN DO
		  IF I<0 THEN REPEAT -I PCHV PTR ELSE REPEAT I NCHV PTR
		END ELSE SETCP(FN,CP(FN)+I)
		GO FRLA

WT(VRL): FRLT:	SETCP(FN,CP(FN)+I)
FRLA:		CRFG(FN) _ NO; ELCNT(FN) _ FLDW-1

	END
	RETURN

END TAB

END NXGET.INIT


!  MACHINE DEPENDENT PROCEDURES

%NUMPKG

FIND ALT.NAME("$MPKIN",%MPK.INIT)
FIND ALT.NAME("$MPK",%MPK)
FIND ALT.NAME("$MEXP",%MEXP)
FIND ALT.NAME("$MDFN",%MDFN)
FIND ALT.NAME("$MUXP",%MUXP)
FIND ALT.NAME("$MUPR",%MUPR)
FIND ALT.NAME("$MUPK",%MUPK)
LOCAL SAVE, EXP, I, J, R, N

%NUMPK.INIT

!  RECEIVES DIGITS FOLLOWED BY -1, SIGN OF MANTISSA (1 OR -1), AND
!  EXPONENT.  PACKS NUMBER IN ACCUMULATOR AS TYPE VTYP AND MOVES TO 
!  VADR.

         SAVE _ RETURN
         MPK.INIT; I _ 0
         WHILE N _ NUMPK >=0 THEN DO
          IF INC I<21 THEN MPK(N)   !IGNORE PAST 21ST DIGIT
         END
         NUMPSGN _ NUMPK
       IF -59<=EXP_NUMPK-I<=38 THEN MEXP(EXP)  ELSE GO OVFLERR
	IF NUMPSGN<0 THEN DO
	  IF VTYP=DOUB THEN MDFN  ELSE NUMPHI-_
	END
        MOVE WPV FROM @NUMPHI TO VADR

%%NUMPK (X)

         SAVE <=> RETURN; RETURN X

END NUMPK.INIT


%NUMUN.INIT (TYP)

LOCAL %GETSGN, %ROUND, %OUTDIG, %INTEXP
TABLE BIGNEG ['34359738368']

         SAVE _ RETURN
         MPK.INIT
         MOVE WPV FROM VADR TO @NUMPHI

         EIF TYP=INTFLD THEN DO   !SENDS >=1 AS NO. OF DIGITS
           IF VTYP=INT THEN DO
             IF NUMPHI=OCT 400000000000 THEN DO
               NUMUNPK(NUMPSGN_1); NUMUNPK(11)
               J _ CHPT(BIGNEG,-1); REPEAT 11 NUMUNPK(NCHV J)
             END ELSE DO
               NUMUNPK(GETSGN)
               NUMUNPK(INTEXP)
               REPEAT EXP DO
                 [J;NUMPHI] _ NUMPHI DIVMOD PWR10(DEC EXP); NUMUNPK(J+$0)
               END
             END
           END ELSE DO       !VTYP REAL OR DOUB
             R _ GETSGN    !SENDS SIGN AFTER ROUND (SMALL NEG. MAY
                           !ROUND TO 0)
             IF ROUND(EXP_MUXP)<=0 THEN [EXP _ 1; NUMPHI _ R _ 0]
             NUMUNPK(R); NUMUNPK(EXP); OUTDIG(EXP)
           END
         END

         ELSE DO       !TYP IS EXPFLD OR DECFLD
           R _ NUMUNPK(GETSGN)  !SEND SIGN, GET ROUNDING FACTOR
           EXP _ MUXP
           EIF TYP=EXPFLD THEN [NUMUNPK(ROUND(R)); OUTDIG(R)]
           ELSE DO
             NUMUNPK(ROUND(R+EXP))   !ROUND MAY INC EXP
             OUTDIG(R+EXP)
           END
         END
         LOOP NUMUNPK($0)

%%NUMUNPK (X)

         SAVE <=> RETURN; RETURN X


%GETSGN

NUMPSGN _ 0
IF NUMPHI<0 THEN DO
  IF VTYP#DOUB THEN NUMPHI-_ ELSE MDFN
  INC NUMPSGN
END
RETURN NUMPSGN

END GETSGN


%ROUND (N)

!  IF N>0, IT IS NO. OF SIGNIF. DIGITS TO WHICH TO ROUND.
!  NOTHING IS DONE IF N>DGMAX(VTYP) OR IF N<0.
!  N=0 IS TREATED SAME AS N>0; IF DOESN'T ROUND UP TO 1, IS LEFT AS IS
!  (ASSUMPTION IS NO DIGITS WILL BE REQUESTED, AS IN N<0 CASE).

         IF 0<= N <DGMAX(VTYP) THEN EXP _ MUPR(N)
         RETURN EXP

END ROUND


%OUTDIG (N)

!  SENDS N DIGITS OF REAL OR DOUB VALUE IN ACCUMULATOR, WITH MAX OF
!  DGMAX(VTYP)

       REPEAT N MIN DGMAX(VTYP) NUMUNPK(MUPK+$0)
         RETURN

END OUTDIG


%INTEXP

!  RETURNS & STORES IN EXP THE EXPONENT OF THE
!  INTEGER IN NUMPHI.

EXP _ 0
REPEAT 10 DO      !LAST AVAILABLE PWR10
  IF NUMPHI<PWR10(INC EXP) THEN RETURN EXP
END
RETURN INC EXP

END INTEXP

END NUMUN.INIT


%TRUNC

!  TRUNCATES REAL/DOUBLE VALUE AT VADR TO INTEGER AND RETURNS RESULT.

END TRUNC

END NUMPKG


%LGCPK (VAL)

^VADR _ IF VAL THEN -1 ELSE 0; RETURN

END LGCPK


%LGCUNPK

RETURN IF ^VADR<0 THEN YES ELSE NO

END LGCUNPK


%STRUP.RES (STRLOC())

!  UNDOES STRUP.SAV FROM STRL ENTRY STARTING AT STRLOC.

LOCAL SAVE, CNT, TYPE

TYPE _ STRLOC(0); INC STRLOC
IF TYPE=STR THEN MOVE INSPTSZ FROM STRLOC TO SPTR ELSE &
  SPTR(0) _ STRLOC(0); CNT _ HUGE
GO BELOW

%%STRUP.INIT

!  CHARACTER UNPACKING.  SENDS EOLIT AFTER LAST CHAR.

IF TYPE _ VTYP=STR THEN DO
  ISGET(SPTR,1)
END ELSE DO
  SPTR(0) _ CHPT(VADR,-1); CNT _ VCNT*CAP
END

BELOW:	SAVE _ RETURN; STRUNPK

IF TYPE=STR THEN DO
  LOOP STRUNPK(SGET(SPTR))
END ELSE DO
  LOOP DO
    WHILE DEC CNT>=0; WHILE CHAR _ NCHV SPTR(0) #EOLIT; STRUNPK(CHAR)
  END
END
LOOP STRUNPK(EOLIT)

%%STRUNPK (X)

SAVE <=> RETURN; RETURN X

END STRUP.RES


%TSTRP.INIT (CNT)

!  CHARACTER PACKING.  RECEIVES EOLIT AFTER LAST TO PACK.
!  IGNORES CHARACTERS SENT PAST CAPACITY.

LOCAL SAVE

SAVE _ RETURN; NSPUT(SPTR,CNT); GO BELOW

%%STRP.INIT

SAVE _ RETURN
IF VTYP=STR THEN DO
  IF ISPUT(SPTR,1)=0 THEN HALT  !DIANA SHOULD CATCH
BELOW:  STRCAP _ SPTR(2)
  WHILE CHAR _ STRPK #EOLIT THEN SPUT(SPTR,CHAR)
  STRPK(ESPUT(SPTR))
END ELSE DO
  SPTR(0) _ CHPT(VADR,-1); CNT _ CAP
  WHILE CHAR _ STRPK #EOLIT THEN DO
    IF DEC CNT>=0 THEN NCHV SPTR(0) _ CHAR
  END
END

%%STRPK (X)

SAVE <=> RETURN; RETURN X

END TSTRP.INIT


%DO.LIT.I

!  PROCESSES STRING LITERAL IN FORMAT.  FLDD IS PTR, FLDW IS COUNT.
!  IF FORMAT IS A STRING, SAME AS X FIELD ON INPUT.
!  OTHERWISE, READS FLDW CHARACTERS INTO LITERAL
!  AREA IN FORMAT.

LOCAL Z

IF VTYP = STR THEN REPEAT FLDW NXGET ELSE DO
    Z _ ^(FLDD+1)		! GET BYTE POINTER.
    REPEAT FLDW NCHV Z _ NXGET
END

RETURN

%%DO.LIT.O

  STRUP.RES(FLDD)
  REPEAT FLDW NXPUT(STRUNPK)
RETURN

END DO.LIT.I


%IBINSTR

!  BINARY STRING I/O.
!  PROCESS NXVAR TILL NON-STRING.

LOCAL CHAR, PTR, WD

! INPUT - READ TO END OF STRING

      VCNTI _ VCNT
      LOOP DO
	STRP.INIT
	LOOP DO
	  WD _ NXGET; PTR _ CHPT(@WD,-1)
	  LOOP DO
	    REPEAT CPW; WHILE CHAR _ NCHV PTR #EOLIT; STRPK(CHAR)
	  END
	  WHILE CHAR#EOLIT; WHILE WD BAND 1=0   !WHILE NOT LAST WD
	END
	STRPK(EOLIT)
	IF DEC VCNT#0 THEN ADV.VADR ELSE DO
	  NXVAR; VCNTI _ VCNT; IF VTYP#STR THEN RETURN
	END
      END

%%OBINSTR

! OUTPUT - WRITE CURRENT LENGTH

      VCNTI _ VCNT
      LOOP DO
	STRUP.INIT
	CHAR _ STRUNPK
	LOOP DO
	  WD _ 0; PTR _ CHPT(@WD,-1)
	  LOOP DO
	     REPEAT CPW
	    WHILE CHAR#EOLIT   !NULL, OR EOLIT WITHIN WD
	    NCHV PTR _ CHAR <== STRUNPK
	  END
	  !IF WHILE EXIT, CHAR IS EOLIT.
	  !IF REPEAT EXIT, CHAR IS 1ST CHAR OF NEXT WD.
	  WHILE CHAR#EOLIT; NXPUT(WD)
	END
	WD BOR _1; NXPUT(WD)
	IF DEC VCNT#0 THEN ADV.VADR ELSE DO
	  NXVAR; VCNTI _ VCNT; IF VTYP#STR THEN RETURN
	END
      END

END IBINSTR


%CSIZ

!  CURRENT LENGTH OF STRING OF TYPE VTYP.
!  MAY BE ANY NON-LOGICAL TYPE


IF VTYP=STR THEN RETURN SCSIZ ELSE RETURN CPW*WPV

END CSIZ


%ADV.VADR

!  ADVANCES TO NEXT VARIABLE OF TYPE VTYP.

IF VTYP#STR THEN VADR+_WPV ELSE DO
  SREMOVE(1); SARY(VADR,VCNTI-VCNT)
END
RETURN

END ADV.VADR

FIND ALT.NAME("$SFW",%SFW)
FIND ALT.NAME("$SFR",%SFR)
FIND ALT.NAME("$INTEL",%INTEL)
FIND ALT.NAME("$RLEL",%RLEL)
FIND ALT.NAME("$DBEL",%DBEL)
FIND ALT.NAME("$LGCEL",%LGCEL)
FIND ALT.NAME("$CMPEL",%CMPEL)
FIND ALT.NAME("$SKPSE",%SKPSE)
%NMLST
    LOCAL %SIXOUT, %NXTEQ
    LOCAL X,I,NDIMS,TYPE,ADDR,DC1,DC2,J,SUBSC,CNT,CHR
    TABLE TYPTAB(0:13)[1,5,0,0,2,0,0,0,3,0,0,0,4,6]
    LOCAL ITEMNAME,OFFSET,ARAYSIZE

%%NMLIN(UNIT,LIST())
	PRINT('NAMELIST INPUT NOT IMPLEMENTED YET.')
RETURN

%%NMLOUT(UNIT,LIST())
! PROCESS NAMELIST OUTPUT.
    SFW(UNIT)
    I _ 0
    NXPUT(CARRET); NXPUT($$); SIXOUT(LIST(0))	! OUTPUT $NAME
    NXPUT(CARRET)
    LOOP DO
	IF X_ LIST(INC I) = 0 THEN [NXPUT($$);RETURN] 
	SIXOUT(X); NXPUT($=)			! ITEM=
	[9,4,5,18]*[NDIMS,TYPE,,ADDR] _ X _ LIST(INC I)
	TYPE_ TYPTAB(TYPE)	! INTERNAL TYPE TO SFORW TYPES.
	IF NDIMS # 0 THEN 	CNT _ HW(@LIST(INC I)) ELSE &
				CNT _ 1
	IF TYPE = STR AND CNT > 1 THEN CNT/ _ ((HW(ADDR)+4)/5)	! ELEMNT CNT. IF ARRAY.
	SUBSC _ 0		! FOR STRING.
	WHILE CNT > 0 THEN DO
	DC1_ ^ADDR
	IF TYPE = DOUB OR TYPE = CPLX THEN DC2_ ^INC ADDR
	IF TYPE = STR  THEN SARY(DC1,SUBSC)	!OK IF SCALAR.
	J_ 1
	  WHILE DEC CNT > 0 AND NXTEQ THEN INC J	! GET NR OF SAME.
	  IF J > 1 THEN [INTEL(@J); NXPUT($*)]
	  DO VTYP_ TYPE OF VTYPRNG
	INT:	INTEL(@DC1)
	REAL:	RLEL (@DC1)
	DOUB:	DBEL (@DC1)
	LGC:	LGCEL(@DC1)
	CPLX:	NXPUT($(); CMPEL(@DC1); NXPUT($))
	STR:	DO
		NXPUT($')
		STRUP.INIT
		WHILE X_ STRUNPK # EOLIT THEN DO
		  NXPUT(X); IF X = $' THEN NXPUT(X)
		END
		NXPUT($')
		END
	  END		! OF DO VTYP_ TYPE OF ...
	NXPUT($,)
	END		! OF WHILE CNT > 0 DO ...
	I +_ NDIMS		! SKIP OVER DIMENSION INFO.
    END	! OF LOOP DO ...



%SIXOUT(X)
! TO OUTPUT X IN SIXBIT.
!
  LOCAL I,J
  LOOP [FOR I_ 30 TO 0 BY -6; WHILE J_ BYT(X,6,I)+OCT 40 # $ ; NXPUT(J)]
  RETURN
END SIXOUT

%NXTEQ
  DO VTYP_ TYPE OF VTYPRNG
INT:REAL:LGC:	RETURN [DC1 = ^INC ADDR]
DOUB:CPLX:	RETURN [DC1 = ^INC ADDR AND DC2 = ^INC ADDR]
STR:		DO
		  SARY(DC1,SUBSC); SARY(DC1,INC SUBSC)
		  RETURN SKPSE
		END
  END	! OF DO VTYP_ TYPE OF ...

END NXTEQ

END NMLST

END SFORW

END SETRWP
  /? <*