SUBTTL	Command File Descriptions
COMMENT 

The following command files make runtime routines:

1.	RUN
	One assembly, get a non-library, non-2d-segment runtime package

RUNTIM=NOCOM(LR)+HEAD+GOGOL+STRSER+IOSER+LEPRUN+MESPRO

2.	SGMNT
	Makes the non-global UPPER.REL and SAILOW.REM, which when
	loaded and run and stuff become SAISGn.REL and SAILWn.REL,
	the 2d segment runtime routines

TAILOR=HEAD+FILSPC+TAILOR/NOLO
LOWER=CALLIS+HEAD+FILSPC+LOW+GOGOL/NOLO
TAILOR.REL,UPPER=CALLIS+HEAD+UP.FAI+GOGOL+STRSER+IOSER+LEPRUN+MESPRO

5.	GSGMNT
	Makes the global model SAILOW AND UPPER, otherwise like
	 SGMNT

TAILOR=HEAD+FILSPC+TAILOR/NOLO
LOWER=CALLIS+HEAD+GLB.FAI+FILSPC+LOW+GOGOL/NOLO
TAILOR.REL,UPPER=CALLIS+HEAD+GLB+UP.FAI+GOGOL+STRSER+IOSER+LEPRUN+MESPRO

6.	SCISS.SAI
	This SAIL program, when run, uses the runtime files to
	 make a LIBSAI.REL file, the SAIL (lower-segment) library

SUBTTL	Conditional Assembly Switches, Macros
DSCR ** CONDITIONAL ASSEMBLY SWITCHES **


COM2 <
    SAILRUN__1
>;COM2
STSW (SAILRUN,0)	;IF NOBODY ELSE IS AROUND, PLAIN OLD RUNTIME ROUTINES
STSW(UPPER,0)		;NOT UPPER OR LOWER IF NEITHER SET
STSW(LOWER,0)
STSW(GLOBSW,0)		;ONLY GLOBAL IF SOMEBODY ELSE SAID SO
STSW(SEGS,0)
STSW(RENSW,1)		;RE-ENTRANT LIBRARY (HISEG) IF ON


IFL SAILRUN,<		;HELL WITH THE REST OF THIS
>

DSCR COMPIL(NAM,ENTRIES,EXTERNALS,DESCRIPTION,INTERNALS,HINHB)
CAL MACRO
PAR NAM IS 3 CHAR NAME -- TITLE WILL BE SAINAM
 ENTRIES ARE LIST OF ENTRIES CONTAINED IN THIS
  LIBRARY ASSEMBLY (INTERNALS IF NOT LIBRARY SETUP)
 EXTERNALS (OPTIONAL) ARE EXTERNALS NEEDED FOR THIS ENTRY.
 DESCRIPTION IS OPTIONAL, AND IS USED IN THE SUBTTL
  IF PRESENT.
 INTERNALS (OPTIONAL) DESCRIBE INTERNALS WHICH ARE NEVER ENTRIES.
 HINHB (OPTIONAL ANYTHING), IF NON-BLANK, INHIBITS THE HISEG)
DES IF MAKING A LIBRARY, AND IF THIS FILE IS DESIRED
  (SEE SCISS PROGRAM), A FILE OF THE NAME SAINAM.FAI
  WILL BE MADE CONTAINING ALL THE PROGRAM TEXT FROM THE
  COMPIL MACRO TO THE ENDCOM MACRO WHICH SHOULD FOLLOW
  THE CODE FOR THIS ENTRY.  ENDCOM DOES AN END IF
  IN LIBRARY COMPILE MODE.
RES THE MACRO EXPANDS TO PROVIDE A TITLE AND THE
  APPROPRIATE ENTRIES AND EXTERNALS FOR THIS ASSEMBLY.
  ALSO A SUBTTL CONTAINING THE TITLE AND OPTIONAL
  DESCRIPTION IS PROVIDED.

DEFINE COMPIL ' (NAM,ENT,EXT,DSCRP,INT,HINHB) <
SUBTTL SAI'NAM -- DSCRP
IFE ALWAYS,<
	IFDIF <><ENT>,<ENTRY ENT>
	TITLE	SAI'NAM
REN <
	IFIDN <><HINHB>,<HISEG		;LOAD TO UPPER IF POSSIBLE>
>;REN
	IFDIF <><EXT>,<EXTERN EXT>
>
NOLOW <
	IFDIF <><INT>,<INTERN INT>
IFN ALWAYS,<
IFGE SAILRUN,<
IFDIF <NAM><LOR>,<
IFDIF <><ENT>,<INTERNAL ENT>
>
>>
>;NOLOW
>


DEFINE ENDCOM (NAM) <
IFE ALWAYS,<
	END
>
>
; SWITCHES TO CONTROL LIBRARY COMPILATION

IFNDEF ALWAYS,<ALWAYS__1>

IFN ALWAYS,<DEFINE ENTINT (X) <INTERNAL X>>
IFE ALWAYS,<DEFINE ENTINT (X) <ENTRY X>>

COMMENT ORDER LOR,LUP,KNT,USC,LIN,COD,TTY,LOG,OPN,NUM,LOK,OUT
INP,WRD,BRK,CLS,MTP,ARY,CAT,SUB,EQU,PNT,PTC,CVS,CVD,SCN,CVC
CVL,POW,CVF,TBB,PTY,SGC,COR,SIM,CHN,FIL,FLS

SUBTTL	Titles, Versions
DSCR  TITLES, VERSIONS

IFN ALWAYS,<
IFGE SAILRUN,<
UP <
;  "TITLE	UPPER"	IS FOUND IN UP.FAI FILE TO MAKE OUTER PROG TITLED
>;UP
LOW <
	TITLE LOWER
>;LOW
NOUP <
NOLOW <
	TITLE RUNTIM -- SAIL RUNTIME ROUTINES
>;NOLOW

JOBVER__137
	LOC	JOBVER
	XWD	'SG2',11 ;LH IS EXECS VERNO,RH IS SAIL VERNO
	RELOC		 ; (10 IS A GOOD GUESS)
>;NOUP
>>
SUBTTL	AC Definitions
DSCR  AC DEFINITIONS


; AC DEFINITIONS FOR SERVICE AND RUNTIME ROUTINES

; ALL	    UUO ROUTS,	    IOSER		COMMENTS
;	    CORE ROUTS,
;	    STRING GC,
;	    ALLOCATION

FF__0
A_1						;TEMPS FOR ALLES
B_2						; (SOMETIMES SAVED)
C_3
D_4
		E_5		X_5		;MORE TEMPS
		Q1_6		Y_6
		Q2_7		Z_7
		Q3_10		Q_10
		T_11		CDB_11		;CHANNEL DATA BLOCK PTR
		T1_12		CHNL_12	;CHNL # FOR IOSER
LPSA_13					;TEMP, PARAM AC
TEMP_14					;TEMP ONLY
USER_15					;USER TABLE FOR RNTRNT ROUTS
SP_16						;STRING STACK
P_17						;SYSTEM STACK
SUBTTL	 CDB, SIMIO Indices For IOSER

DSCR -- CDB, SIMIO INDICES FOR IOSER
DES The I/O routines obtain their information from the user via a
  channel number -- the same kind used by the system. In order to
  find byte pointers, counts, file names, etc., the channel number is
  used to index into a block of core called a CDB (Channel Data Block).
  This CDB is filled with good data during the OPEN operation.
 The CDB, and all I/O buffers, are obtained from CORGET.
 The CHANS table in the GOGTAB area is a 20 word block containing
  pointers to the appropriate CDB's.
 Since channel numbers must appear in the AC field of IO instructions,
  one must construct IO insts. in impure places to retain re-entrancy.
  XCT INDEX,SIMIO executes the appropriate IO instruction with the
  channel number from AC CHNL, used by all routines.  See SIMIO for
  operational details.


;  SIMIO INDICES		        FORMAT OF CDBs

DMODE	__ 0	;DATA MODE	    IOSTATUS __ 0	;RETURN STATUS
DNAME	__ 1	;DEVICE		    IOIN     __ 1	;BUFFERED INPUT
BFHED	__ 2	;HEADER POINTERS    IODIN    __ 2	;DUMP INPUT
				    IOOUT    __ 3     ;BUFMODE OUT.
OBPNT	__ 3	;OUTPUT BUF. PTR.   IODOUT   __ 4	;DUMP OUTPUT
OBP	__ 4	;OUTPUT BYTE PTR.   IOCLOSE  __ 5	;CLOSE FILE
OCOWNT	__ 5	;OUTPUT BYTE COUNT  IORELEASE__ 6	;RELEASE FILE
ONAME	__ 6	;OUTPUT FILE NAME   IOINBUF  __ 7	;INBUF
OBUF	__ 7	;OUTPUT BUFFER LOC. IOOUTBUF __10	;OUTBUF
				    IOSETI   __11	;USETI
IBPNT	__10	;SAME FOR INPUT	    IOSETO   __12	;USETO
IBP	__11			    ;  13 UNUSED
ICOWNT	__12			    IOOPEN   __14	;OPEN CHANNEL
INAME	__13			    IOLOOKUP __15	;LOOKUP FILE
IBUF	__14			    IOENTER  __16	;ENTER FILE
				    IORENAME __17	;RENAME FILE

ICOUNT	__15	;INPUT DATA COUNT LIMIT ADDRESS
BRCHAR	__16	;XWD TTYDEV FLAG, INPUT BREAK CHAR ADDR
TTYDEV  __16	;LH -1 IF DEVICE IS A TTY -- USED BY OUT
ENDFL	__17	;INPUT END OF FILE FLAG ADDR
ERRTST	__20	;USER ERROR BITS SPECIFICATION WORD
PGNNO	__20	;PAGE NUMBER FOR DISPLAY FEATURE (IF FEATURE NOT INCLUDED)

^IOTLEN	__PGNNO+1	;LENGTH OF TABLE ENTRY


; INDICES INTO %SIZES, %NORMSIZ SPACE SPECIFICATION TABLES

PDLMAX	__0		;LENGTH OF SYSTEM PDL
SPMAX	__1		;LENGTH OF STRING PDL
STMAXX	__2		;LENGTH OF STRING SPACE
LPSMAX	__3		;INITIAL SIZE OF SAIL SYMBOL SPACE (COMPILER ONLY)
PPMAX	__4		;LENGTH OF PARSE STACK (COMPILER ONLY)
GPMAX	__5		;LENGTH OF SEMANTIC STACK (COMPILER ONLY)
DFMAX	__6		;LENGTH OF DEFINE PDL (COMPILER ONLY)
ARPMAX	__7		;LENGTH OF ARRAY PDL (RUNTIME ONLY)
SIZSIZ	__ARPMAX+1	;LENGTH OF THESE TABLES

LUPDL_30			;LENGTH OF UUO PDL

VERDEX__=10			;SHOULD BE DEFINED BELOW, BUT NEEDED
				; OUTSIDE OF NOUP
SUBTTL	Base (Low Segment) Data Descriptions

DSCR DATA DESCRIPTIONS, TAILORED FOR TWO SEGMENT OPERATION


NOUP <
DEFINE SGLK (ROUT) <
 XX	(,ROUT,)	;NAME OF STRING DSCRPTR GENERATING ROUTINE
 XX	(,0,)		;PLACE TO PUT A LINK
 LINK	4,.-1		;WHEREWITHAL TO GENERATE SAID LINK
>
>;NOUP
UP <
DEFINE SGLK (ROUT) <
 XX	(,ROUT,)
 XX	(,0,)
>
>;UP

DEFINE XX  (A,B,C,D) <
	IFDIF <A><>,< A :> B
	IFDIF <C><>,< C A >>>
UP <
III__140
	DEFINE XX (A,B,C,D) <
	IFDIF <A><>,< A _ III >
	III __ III + 1
	IFDIF <D><>,<III_III+D-1>
>
>;UP


COMPIL(LOR,<SAILOR>
	    ,<%UUOLNK,%ALLOC,%USRSPC,%ASK,%SPGC,%STRMRK,%ARRSRT,K.OUT,K.ZERO>
	    ,<BASE DATA, INITIALIZATION CONTROL>
	    ,<X11,X22,X33,X44>,INHIBIT)

XX	(GOGTAB,0,INTERNAL)
IFGE SAILRUN,<
XX	(DATM,0,INTERNAL)
XX	(.SKIP.,0,INTERNAL)
XX	(RPGSW,0,INTERNAL)
COM2 <
XX	(CONFIG,0,INTERNAL)
			;THIS IS 0 FOR THE RUNTIME ROUTINES.
			; <0 FOR REGULAR COMPILER, AND
			;SOMETHING >0 FOR GAG COMPILER.
XX	(ERRSPC,0,INTERNAL)
XX	(GPSAV,0,INTERNAL)
XX	(PPSAV,0,INTERNAL)
XX	(DFSTRT,0,INTERNAL)
XX	(DEFPDP,0,INTERNAL)
>;COM2

>;GE SAILRUN

XX	(%SIZES,200,INTERNAL)	;PDP ALLOCATION
XX	(,50,)			;STRING STACK
XX	(,4000,)		;STRING SPACE
XX	(,=2200,)		;SAIL FREE STORAGE AREA
XX	(,100,)			;SIZE OF PARSE PDL IN SAIL.
XX	(,100,)			;SIZE OF GENERATOR PDL IN SAIL.
XX	(,=40,)			;SAIL'S DEFINE PDP
XX	(,100,)			;ARRAY PDL.

XX	(KTLNK,0)		;LINKEND OF COUNTER BLOCKS
XX	(SGROT,0,)		;GC GENERATING ROUTINES LINKEND
XX	(STLNK,0,INTERNAL)	;STRING GC. LINKS.
XX	(SPLNEK,0,INTERNAL)	;SPACE ALLOCATION LINK.
XX	(SETLET,0,INTERNAL)	;SET LINK
IFGE SAILRUN, <
SGLK	(%ARRSRT)		;ROUTINE TO COLLECT STRING ARRAYS
>
SGLK	(%STRMRK)		;ROUTINE TO COLLECT STRING VARIABLES
SGLK	(%SPGC)			;ROUTINE TO COLLECT STRING STACK

NOUP <
	LINKEND 1,STLNK
	LINKEND	2,SPLNEK
	LINKEND	3,SETLET
	LINKEND	4,SGROT		;END THE GENERATOR ROUTINE LIST
	LINKEND	5,KTLNK
>;NOUP

XX	(%NORMSIZ,200,INTERNAL)	;NORMAL SIZES FOR ABOVE. (PDL ALLOC)
XX	(,50,)
XX	(,4000,)
XX	(,=2200,)
XX	(,100,)
XX	(,100,)
XX	(,=40,)
XX	(,100,)

XX	(ALLPDP,<IOWD 20,ALLPDL>,INTERNAL);ALLOCATION PDL
XX	(ALLPDL,<BLOCK 20>,INTERNAL,20)
XX	(%ALLCHR,0,INTERNAL)
XX	(%OCTRET,0,INTERNAL)
XX	(%ERGO,0,INTERNAL)	;ON IF LF TYPED TO ERR. GUY
XX	(%RECOV,0,INTERNAL)	;ON IF RECOVERY FROM ERR. IS POSSIBLE
XX	(DPYSW,0,INTERNAL)	;ON IF CONSOLE IS DPY
XX	(%UACS,<BLOCK 20>,INTERNAL,20) ;UUOCON ACS
XX	(%UPDL,<BLOCK LUPDL+1>,INTERNAL,LUPDL+1) ;UUOCON PDL
COM2 <
	I_0
>;COM2
NOCOM2 <
	I_SAILRUN
>;NOCOM2
IFE I,<
XX	(X11,<XWD 1,1>,INTERNAL)
XX	(X22,<XWD 2,2>,INTERNAL)
XX	(X33,<XWD 3,3>,INTERNAL)
XX	(X44,<XWD 4,4>,INTERNAL)
>;IFE I
IFGE SAILRUN, <
>;IFGE SAILRUN



XX	(UUO0,0,INTERNAL)		;SETNIT NEEDS THIS.
	UUCOR_UUO0
NOUP <
	JRST	%UUOLNK
>;NOUP
SUBTTL	Initialization Routines, Data

COMMENT  The Run-Time I/O handling routines are re-entrant.
	This means that any modifiable words or parameters
	particular to a given user must come from the user's
	core image. The pointer to this area will be found in
	location GOGTAB in the users LOWER SEGMENT.
	The I/O routines use some of the AC'S in standard ways,
	described above with the AC definitions.


DSCR ALLOCATION AND INITIALIZATION ROUTINES


COMMENT 
Part of this is not yet reentrant. In particular,
	it is called by a JSR INIT and calls ALLOC
	(not reentrant quite). 

The functions of this routine are:

1. INIT,REENT: set up UUO loc
	ask "ALLOC?"
	get a character		RESTRT: assume "S" (same)

2. Ask questions if character is "Y"
   Fill in defaults if char is not "S", else leave all as they were

3. Call ALLOC 

4. Type allocation if char is "Y"

5. Change starting and re-entry addresses,
	set up user ACs and PUSHJ to user program


SUBTTL	 SAILOR, .SEG2.

DSCR SAILOR,GOGNIT
CAL JSR
DES Called by SAIL programs to initialize storage


NOUP <

INTERNAL SAILOR
^SAILOR:

COM2 <
	I_0
>;COM2
NOCOM2<
	I_SAILRUN
>;NOCOM2

IFE I,<

^GOGNIT:
INIT:	0			;JSR INIT GETS HERE


COMMENT    Here is code to initialize the second segment, if there is none.
This occurs if one is starting a job which was saved.  The LOADER initializes
it during the load process.  The job is much easier if this is not running
on Stanford's system.


First, see if there is already a segment

LOW <
INTERNAL .SEG2.
EXTERNAL JOBHRL

	MOVEI	P,FIRGO			;INLINE CALL WHEN PART OF SAILOR SEQ.
.SEG2.:
	SKIPE	JOBHRL		;IS THERE A SEGMENT?
	 JRST	 OKGO		; YES, GO AHEAD

COMMENT  Now, if global model, get segment specifications from space blocks
of compiled programs (via REQUIRE verbs in source code). 
Segment name business is ignored in EXPO version, since segment and file
names are always equivalent (philosophical differences).


SEGTR:				;TRY AGAIN
; *** VERDEX REALLY DEFINED ABOVE ****
;VERDEX__=10			;VERSION NUMBER

COMMENT  If not enough information was supplied (global model only),
ask questions of user to obtain file names, etc.  Also (NOEXPO only),
try to ATTSEG to a segment of the desired name. In the EXPO version,
all this is combined in the GETSEG below.

ASKEM:				;MISPLACED LABEL
GETSE:	CALLI
	SETZM	SEGNAM+2
	MOVE	TEMP,[SGPPNN]
	MOVEM	TEMP,SEGNAM+3	;SET UP PPN
	HLLZS	SEGNAM+1

COMMENT  Now work is nearly done in EXPO system, but all sorts of hair 
remains otherwise.  In either case, now get segment in, get it into 2d 
segment, name it right



	SETZM	SEGNAM+4		;CLEAR LAST TWO WORDS OF GETSEG BLOCK
	SETZM	SEGNAM+5
	MOVEI	A,DEVSEG		;GET READY
	MOVEM	P,SAVPP
	CALL	A,[SIXBIT /GETSEG/]	;GET THE SEGMENT
	 JSP	 A,ERSEG		; COULDN'T
	MOVE	P,SAVPP
; NO WAY TO RENAME 2D SEGMENT, SO DON'T WORRY ABOUT IT



OKGO:	JRST	(P)			;RETURN
FIRGO:
>;LOW
SUBTTL	 Restart, Reentry Sequences

COMMENT  The initialize sequence (via SAILOR) begins here if runtime routines
are not in the second segment.  Most of the code it invokes is in second seg.
if there is one.


	SKIPE	P,SPLNEK	;IF USER SPECIFIED ANY SIZES, COLLECT THEM
	JSP	16,%USRSPC
	JRST	STRT		;DON'T MESS UP RPG SETTINGS FST TIME

; SAIL ALWAYS RE-ENTERS HERE (EVEN FIRST TIME) TO SET UP ALLOCATION


	LOC	124		;SET UP REENTER ADDRESS
	REENT
	RELOC

^REENT:	CALLI			;RESET EVERYBODY

; *****
LOW <
>;LOW
; *****

	JSP	16,%ASK		;ASK QUESTIONS AND ALLOCATE
NOSK:	HRRZ	TEMP,JOBSA	;GO TO RPG-MODE OR REGULAR START
	JRST	(TEMP)


^RESTRT:;SAIL STARTS HERE WHEN USER TYPES S<T<A<R<T>>>> AGAIN

	TDZA	TEMP,TEMP	;ESTABLISH OPERATING MODE
	MOVNI	TEMP,1		;RPG MODE
	MOVEM	TEMP,RPGSW	;RECORD IT

LOW <
	JSP	P,.SEG2.	;GET SECOND SEGMENTS
>;LOW

STRT:	CALLI
	SETZM	GOGTAB		;FORCE CORSER RE-INITIALIZATION
	JSP	16,%ALLOC	;ALLOCATE AREAS

	MOVEI	A,RESTRT	;CHANGE JOBSA AND JOBREN
	HRRM	A,JOBSA		;"S" USES OLD ALLOCATION
	MOVEI	A,REENT		;"REE" ASKS QUESTIONS AGAIN
	MOVEM	A,JOBREN
IFGE SAILRUN,<
	PUSHJ	P,K.ZERO	;ZERO OUT THE COUNTERS
>;IFGE SAILRUN
	PUSHJ	P,@INIT		;CALL USER PROGRAM
IFGE SAILRUN,<
	PUSHJ	P,K.OUT		;WRITE OUT THE COUNTERS
>;IFGE SAILRUN
	CALLI	0		;CLEAR THE I/O WORLD
	CALL6	EXIT

NOUP <
INTERNAL TYPER.,OVPCWD,ERRMSG
;THESE ARE BECUSE OF LIB40 CHANGES
; MADE CAPRICIOUSLY BY DEC
TYPER.:
ERRMSG:
OVPCWD:	JFCL
	ERR	<SOME FORTRAN ROUTINE HAS SEEN FIT TO COMPLAIN
ABOUT YOUR STYLE.  COMPLAIN TO DEC THAT THEIR ERROR MESSAGE
PROCEDURE IS NOT SUFFICIENTLY GENERAL TO ALLOW GRACEFUL INTERFACE
WITH SAIL.>
>;NOUP
SUBTTL	 Segment-Fetching Data

LOW <

NMSAV:	0			;SAVE LOGICAL SEGMENT NAME HERE
SEGDEV: 0			;SAVE UPPER SEGMENT DEVICE NAME HERE
SEGFIL:	0			;SAVE UPPER SEGMENT FILE NAME HERE
	SIXBIT	/SHR/		;DIFFERENT STROKES FOR ....
	0
SEGPPN: 0			;SAVE UPPER SEGMENT PPN HERE


DEVSEG:	SGDEVC			;USED ONLY BY EXPO'S GETSEG
SEGNAM:	FILXXX
	SIXBIT /SHR/
	0
	SGPPNN			;SPECIFIED PPN DEFAULT
	0 0			;SIX WORD BLOCK FOR GETSEG
SAVPP:	0			;P SAVED HERE OVER GETSEG
ERSEG:	TERPRI	<SAIL SEGMENT LOADING ERROR>

	CALLI 12

>;LOW
>;I
>;NOUP
LOW <
	END
>;LOW
ENDCOM(LOR)
COMPIL(LUP,<%UUOLNK,SAVE,RESTR,INSET>
	   ,<CORGET,STCLER,%RECOV,%UACS,GPSAV,GOGTAB,%UPDL,CONFIG,%ALLCHR>
	   ,<INITIALIZATION ROUTINES, UUO HANDLER, UTILITY ROUTINES>)
IFE ALWAYS,
<INTERNAL	%ALLOC, %USRSPC, %ASK
; MORE EXTERNALS
EXTERNAL	ALLPDP,ERRSPC,SETLET,%NORMSIZ,DEFPDP,DPYSW
EXTERNAL	%SIZES,PPSAV,%ERGO,SPLNEK,DFSTRT,UUO0,%OCTRET
>;IFE ALWAYS
COMMENT %ASK -- Alloc Info From User (Upper Segment Starts Here)

DSCR %ASK
CAL JSP 16,%ASK
DES Called by SAILOR and friends to request storage size parameters
 from user if program is REEntered


NOLOW <			;PUT IN UPPER SEGMENT AND ALL THAT FOLLOWS....
UP <
;IF YOU CHANGE ANYTHING BEFORE THIS CODE, ALL SAIL USERS WILL
;HAVE TO RELOAD.  THIS IS THE UPPER SEGMENT DISPATCH TABLE FOR
;INTERNAL SYMBOLS.

	USE	DSPCH		;A PC FOR VECTOR JRSTS
	USE
	BLOCK =150		;SPACE FOR THE JRSTS.
>;UP

HERE (%ASK)
	SETNIT			;SET UP P-STACK(TEMP), JOB41
	PUSH	P,16		;SAVE RETURN ADDRESS
	TERPRI
	PRINT	<ALLOC? >
	TTCALL	0,B		;ASK LEADING QUESTION AND GET ANSWER


	MOVEM	B,%ALLCHR	;2 SAVE ANSWER CHARACTER
	CAIN	B,"S"		;SAME AS LAST TIME?
	 POPJ	 P,		;YES, WHY DID YOU CALL ME?
	CAIE	B,"Y"		;  DOES USER WANT ALLOCATION?
	 JRST	 NORMAL		; NO NEW ALLOCATION, USE "NORMAL" SIZES

; ASK QUESTIONS, SAVE ANSWERS

DEFINE ASKTEL '(A) <
	ASKFOR <PDL>,PDLMAX
	ASKFOR <STRING PDL>,SPMAX
	ASKFOR <STRING SPACE>,STMAXX
IFN SAILRUN,<
COM2 <
	SKIPN	CONFIG		;CONFIGURATION.
	JRST	A
>;COM2
	ASKFOR <LPS SPACE>,LPSMAX
	ASKFOR <PARSE STACKS>,PPMAX
	ASKFOR	<DEFINE STACK>,DFMAX
A:
>
IFGE SAILRUN,<
COM2 <
	SKIPGE	CONFIG		;RUNTIMES OR GAG
	JRST	A'A
>;COM2
	ASKFOR <ARRAY STACK>,ARPMAX
COM2 <
A'A:
>;COM2
>

>

DEFINE ASKFOR & (TEXT,ADDRESS) <
	TERPRI
	PRINT	<TEXT = >
	PUSHJ	P,DECIN
	MOVE	C,%NORMSIZ+ADDRESS
	MOVEM	C,%SIZES+ADDRESS
>

	SETZM	%OCTRET		;WHEN ON, OCTIN RETURNS PLOTZLICH AT (P)
	ASKTEL (FF2)		;ASK ALLOCATION QUESTIONS
IFN SAILRUN, <
	MOVE	TEMP,PPMAX	;MAKE THESE THE SAME
	MOVEM	TEMP,GPMAX
>;SAILRUN


DEFINE ASKFOR & (TEXT,ADDRESS) <
	TERPRI
	PRINT	<TEXT = >
	DECPNT	%SIZES+ADDRESS
>

	JRST	PRIN


; STANDARD (BUILT-IN) ALLOCATIONS

NORMAL:	MOVE	TEMP,[XWD %NORMSIZE,%SIZES] ;PUT IN STANDARDS
	BLT	TEMP,%SIZES+SIZSIZ-1

	MOVE	A,%ALLCHR	;4 TYPE RESULTS IF DESIRED
	CAIN	A,"N"		;  DON'T PRINT IF
	 POPJ	 P,		; "N"

PRIN:	PRINT	<ALLOCATION:>
	ASKTEL (FF1)		;PRINT THEM OUT

	TERPRI
	POPJ	P,

IFN SAILRUN,<
COM2 <
INTERNAL TRALOC
>;COM2
^TRALOC: MOVE	TEMP,[XWD %NORMSIZE,%SIZES] ;JUST DO TRANSFER,
	BLT	TEMP,%SIZES+SIZSIZ-1	; SAIL WILL TAKE CARE OF THE LOGIC
	POPJ	P,
>
SUBTTL	 %USRSPC -- Alloc Info From REQUIRE Blocks

Comment  USRSPC -- routine to collect specifications for user spaces
   given in the REQUIRE verb. 

HERE (%USRSPC)	
BEGIN USRSPC
	MOVEI	15,1		;CLEAR FIRST 10 ACS
	MOVEI
	BLT	15,10

Comment  use AC 1 for system pdl size,
	      AC 2 for string pdl size,
	      AC 3 for string space size,
	      AC 4 for array pdl size.

P next space list element
LPSA  current space list table
USER counts entries,  current count (in AC)



L2:	MOVEI	LPSA,1(P)	;ADDRESS OF SPACE LIST TABLE
	HRLI	LPSA,USER	;FOR INDIRECT INDEXING
	MOVEI	USER,4		;ARRAY PDL FIRST

L1:	MOVE	TEMP,@LPSA	;GET ENTRY FROM TABLE
	ADDM	TEMP,(USER)	; COLLECT IN APPROPRIATE AC
	SOJG	USER,L1		;PROCEED BACK TO 1
	SKIPE	P,(P)		;PROCEED UNTIL ALL LISTS SEEN
	JRST	L2		;REPEAT FOR EACH LIST

DEFINE WHICHEVER (AC,LOC) <
	JUMPLE	AC,.+2		;0 IMPLIES NOT SPECIFIED,NEG IL
	MOVEM	AC,%NORMSIZ+LOC	;USE USER SPEC INSTEAD OF DEFAULT
>

	WHICHEVER (1,PDLMAX)
	WHICHEVER (2,SPMAX)
	WHICHEVER (3,STMAXX)
	WHICHEVER (4,ARPMAX)

	MOVE	TEMP,[XWD %NORMSIZ,%SIZES] ;PUT IN CURRENT %ALLOCATION
	BLT	TEMP,%SIZES+SIZSIZ-1	; TOO

	JRST	(16)		;RETURN

BEND USRSPC
COMMENT   Utility Subroutines for allocation

DECIN:
OCTIN:	SKIPE	%OCTRET		;IMMEDIATE RETURN?
	 POPJ	 P,		; YES

	SETZB	C,D
OCTIN1:	TTCALL	0,B
	CAIN	B,177		;RUBOUT?
	 JRST	 RUB		;AYE, THERE'S THE RUB
	CAIN	B,"U"-100	;^U?
	 JRST	 CTRLU		;INDEED
	CAIN	B,175		;ALTMODE?
	 JRST	 SETRET
	CAIN	B,12		;LINE FEED?
	 JRST	 EPOP		;YES
	CAIL	B,"0"
	CAILE	B,"9"		;I KNOW IT'S CALLED OCTIN,
	 JRST	 OCTIN1		; BUT INPUT IS IN DECIMAL!!
	SETOM	D		;FOUND SOMETHING LIKE A NUMBER
	IMULI	C,=10		;GOOD OLD NUMBER CONVERSION
	ADDI	C,-"0"(B)
	JRST	OCTIN1		;THIS IS A LOOP

SETRET:	SETOM	%OCTRET		;WILL RETURN IMMEDIATELY HENCEFORTH
	TERPRI

EPOP:	SKIPE	D		;FIND ANYTHING?
	AOS	(P)		;YES
CPOPJ:	POPJ	P,

RUB:
CTRLU:	TTCALL	3,[BYTE (7) "^","U",15,12] ;WON'T THE USER BE
	JRST	OCTIN		;START OVER
SUBTTL	 %ALLOC -- Main Allocation Routine

DSCR %ALLOC
CAL JSP 16,%ALLOC
DES Uses space parameters to allocate storage for stacks, string
 space, etc.  Sets certain universal environmental variables


COMMENT 
This routine sets up various data spaces controlled
	by the size words in the user's data table. It stores
	initial push-down pointers in the users
	AC area (FRSTACs). It sets pointers to all relevant
	areas. Core is obtained using the CORGET 
	routine. The routine assumes that the size fields are
	already set up in user's core in fixed, ????? addresses.
	So part of the code is not re-entrant. 


HERE (%ALLOC)
^ALLOC:
	SETNIT			;MAKE SURE YOU HAVE A PDL
				;AND A UUO PLACE TO TRAP TO

	SETCOR	(%SIZES+PDLMAX)	;SPACE FOR SYSTEM PDL
	PUSHJ	P,PDPMAK	;MAKE A PUSH-DOWN POINTER
	MOVEM	B,PDL(USER)
	MOVE	P,B		;USE THIS AS PDP FROM HERE TO ETERNITY
	PUSH	P,16		;FIRST OFFICIAL ACT --
				; MAKE SURE YOU CAN GET HOME

	SETCOR	(%SIZES+SPMAX)	;SPACE FOR STRING PDL
	PUSHJ	P,PDPMAK	;MAKE PDP
	MOVEM	B,SPDL(USER)
	MOVE	SP,B		;NOW HAVE A STRING PDL

	SETCOR	(%SIZES+STMAXX,<ST(USER)>,<STTOP(USER)>) ;STRING SPACE
	MOVE	C,%SIZES+STMAXX
	MOVEM	C,STMAX(USER)	;FOR STRING GARB. COLLECTOR.
	HRLI	B,(<POINT 7,0>)
	MOVEM	B,TOPBYTE(USER)	;MAGIC THAT MAKES STRINGS WORK
	MOVNI	TEMP,5
	IMUL	TEMP,%SIZES+STMAXX;NUMBER OF CHARS
	MOVEM	TEMP,REMCHR(USER)
	HLLOS	TOPSTR(USER)

IFN SAILRUN,<
COM2 <
	SKIPN	CONFIG		;ONLY FOR COMPILER, PLEASE
	 JRST	 NOLIG		;
>;COM2
	SETCOR	(%SIZES+LPSMAX,<LPSBOT(USER)>,<LPSTOP(USER)>)
	SETCOR	(%SIZES+GPMAX)
	PUSHJ	P,PDPMAK
	MOVEM	B,GPSAV		;GENERATOR STACK
	SETCOR	(%SIZES+PPMAX)
	PUSHJ	P,PDPMAK
	MOVEM	B,PPSAV		;SEMANTICS STACK
	SETCOR	(%SIZES+DFMAX)
	HRRZM	B,DFSTRT	;SAVE BASE OF DEFINE STACK
	PUSHJ	P,PDPMAK
	MOVEM	B,DEFPDP	;DEFINE STACK
	SETOM	SGLIGN(USER)	;GC MUST ALIGN STRINGS
COM2 <
NOLIG:
>;COM2
>

IFGE SAILRUN,<
COM2 <
	SKIPGE	CONFIG		;FOR RUNTIMES OR GAG
	JRST	NOARYS		;NO
>;COM2
	SETCOR	(%SIZES+ARPMAX)
	MOVEM	B,ARRPDL(USER)
	PUSHJ	P,PDPMAK	;ARRAY MARKER STACK
	PUSH	B,[-1]
	MOVEM	B,ARRPDP(USER)
COM2 <
NOARYS:
>;COM2
	HRROI	TEMP,SETLET
	POP	TEMP,SETLNK(USER)
	POP	TEMP,SPLNK(USER);SPACE LINK.
;>	HRROI	TEMP,STLNK	;STRING LINK FOR COMPILER.
	POP	TEMP,STRLNK(USER)
	POP	TEMP,SGROUT(USER);STRNGC GENERATOR ROUTINE LINKS
	POP	TEMP,KNTLNK(USER);LIST OF PROFILE COUNTER ARRAYS
	PUSHJ	P,STCLER	;CLEAR OUT ALL STRINGS
	MOVEI	TEMP,7		;INITIAL DIGS SETTING
	MOVEM	TEMP,DIGS(USER) ;FOR FLOATING POINT OUTPUT
	MOVEI	TEMP,CHANS(USER);IF CHNL HAS A VALID CHANNEL #,
	HRLI	TEMP,CHNL	; @CDBLOC(USER) REFERS TO ITS
	MOVEM	TEMP,CDBLOC(USER);CDB ADDR IN THE CHANS TABLE
	SETZM	%ERGO		;NO AUTOMATIC CONTINUE FROM ERR.

	EXTERNAL JOBVER
	MOVEI	LPSA,SPLNEK	;CHECK VERSION NUMBER AGREEMENT
	MOVEI	A,0		;NO VERSION FETCHED YET
CHKVRS:	SKIPN	LPSA,(LPSA)		;DONE?
	POPJ	P,		; YES
	SKIPN	TEMP,VERDEX(LPSA);A VERSION SPECIFIED?
	 JRST	 CHKVRS		; NO
	EXCH	A,TEMP		;A_NEW, TEMP_OLD
	HRLM	A,JOBVER	;STORE THIS VERSION
	JUMPE	TEMP,CHKVRS	;NO VERSION SEEN PREVIOSLY
	CAME	TEMP,A		;SAME VERSION?
	 ERR	 <VERSION NUMBER MISMATCH>,1
	JRST	CHKVRS



PDPMAK:	MOVNS	C
	SUBI	B,1		;PDP
	HRL	B,C
	POPJ	P,

>;NOLOW

SUBTTL	%UUOLNK -- UUO Handler (Dispatch Vector Just Below)

DSCR UUO HANDLER


NOLOW <			;INCLUDE IN UPPER SEGMENT.....
^%UUOLNK:

^UUOCON:	MOVEM	17,%UACS+17	;NOTICE UUO0 IS ABOVE HERE
	MOVEI	17,%UACS
	BLT	17,%UACS+16
	MOVE	P,[XWD -LUPDL,%UPDL]	;SET UP SPECIAL UUO PDL
	MOVE	A,JOBUUO	;GET THE INSTRUCTION
	LDB	B,[POINT 9,A,8]		;GET UUO NUMBER.
	TRNE	B,-117		;CHECK IN RANGE
	JRST	UUOTBL		;ILLUUO
	XCT	UUOTBL(B)	;GO DO RIGHT THING.
	MOVSI	17,%UACS
	BLT	17,17	;RELOAD ACCUMULATORS.
	JRST	2,@UUO0

DSCR  UUO TABLE


^^UUOTBL:PUSHJ	P,ILLUUO	;0
	PUSHJ	P,PDLOQ 	;1
	PUSHJ	P,FLOAQ 	;2
	PUSHJ	P,FIXQ   	;3
	PUSHJ	P,IOERRR  	;4
	PUSHJ	P,ERRR		;5
	PUSHJ	P,ILLUUO	;6 -- USED TO BE ERROR.
	PUSHJ	P,ARERRR	;7 -- ARRAY ERROR
	PUSHJ	P,ILLUUO	;10
	PUSHJ	P,DECPNQ	;11
	PUSHJ	P,OCTPNQ	;12
	PUSHJ	P,FLTPNQ	;13
	PUSHJ	P,ILLUUO	;14
	PUSHJ	P,ILLUUO	;15

FLTPNQ:	TERPRI	(<WELL ONE FLOATING PT NUMBER IS 1.0>)
	JRST	GODD
	


SUBTTL	 ILLUUO, PDLOV, ERR UUO Handlers

DSCR ERROR UUOS
PAR AC FIELD IS INDEX INTO ERROR ROUTINE
SID SAVES THE WORLD
DES THE ASCIZ STRING INDICATED BY THE EFFECTIVE ADDRESS IS TYPED. THEN
 THE ERROR ROUTINE INDICATED BY THE AC FIELD IS EXECUTED.
 IF `GO' IS NOT ON, THE USER IS ALLOWED TO RESPOND WITH ONE OF SEVERAL
 ALTERNATIVES.  ONE ALTERNATIVE IS CONTINUATION IF THE AC FIELD OF THE
 UUO WAS ODD. OTHERWISE, NO CONTINUATION IS POSSIBLE.  THE ACS AT THE
 TIME OF CALL ARE RESTORED IF CONTINUATION OR `DDT' IS CHOSEN.


ILLUUO:	SKIPA	A,[10B12+[ASCIZ /ILLEGAL UUO  /]]
PDLOQ:	MOVEI	A,[ASCIZ /PDL OVERFLOW/]
ERRR:
IFN SAILRUN, <
COM2 <
	ERSEEN__10000
	SKIPL	CONFIG		;COMPILER ??
	 JRST	 NOCOM
>;COM2
	TLNE	FF,ERSEEN	;IF SYNTAX ERRORS HAVE OCCURED, ONLY
	JRST	[TLNE A,40	;HALT IF THIS IS AN UNRECOV. ERROR.
		 POPJ P,	;JUST CONTINUE....
		 TERPRI <CANNOT CONTINUE ANY FARTHER>
		 SETZM %RECOV	;NOT A CHANCE
		 JRST WATNOW]
COM2 <
NOCOM:
>;COM2
>


	TTCALL	3,(A)		;PRINT MESSAGE
	LDB	B,[POINT 4,A,12] ;DISPATCH INDEX
	ROT	B,-1		;LOW ORDER BIT TO SIGN BIT
	MOVEM	B,%RECOV		;MARK %RECOVERABLE (OR NOT)
	PUSHJ	P,@URTBL(B)	;CALL ERROR ROUTINE
	MOVEI	A,0		;INFO FOR MYERR
NOCOM2 <
IFN SAILRUN <
	PUSHJ	P,MYERR		;IN COMPILER-- PRINTS LINE....
>
>;NOCOM2
COM2 <
	SKIPE	ERRSPC		;SPECIAL ERROR ROUTINE??
	PUSHJ	P,@ERRSPC	;YES -- GO DO IT.
>;COM2

LINDUN:	TERPRI
	PRINT	<CALLED FROM >
	HRRZ	A,UUO0
	SUBI	A,1
	PUSHJ	P,OCTPNQ+1
IFGE SAILRUN, <
COM2 <
	SKIPGE	CONFIG		;RUNTIMES OR GAG
	 JRST	NOLSCL
>;COM2
	PRINT	 <  LAST SAIL CALL AT >
	MOVE	A,GOGTAB
	HRRZ	A,UUO1(A)
	SOS	A
	PUSHJ	P,OCTPNQ+1
COM2 <
NOLSCL:
>;COM2
>
	TERPRI

	MOVE	A,GOGTAB
	HRRZ	B,TOPBYTE(A)
	CAML	B,STTOP(A);HAVE WE GONE OFF THE DEEP END?
	 JRST	 [PRINT <ALL BETS ARE OFF, FOLKS!
STRING SPACE EXHAUSTED UNEXPECTEDLY. WILL RESTART NOW>
		  JRST  @JOBREN]

	SKIPE	%ERGO
	JRST	GOTRY		;AUTOMATIC CONTINUE SET
WATNOW:	MOVEI	A,"?"		;PRINT ? FOR IRRECOVERABLE ERRORS,
	SKIPGE	%RECOV		;  FOR %RECOVERABLE ONES.
	MOVEI	A,"^"		;SOMETHING PRINTABLE
	TTCALL	1,A		;PRINT IT
	TTCALL	0,B		;GET RESPONSE CHAR
	CAIL	B,"a"		;lower case?
	SUBI	B,40		;YES, CONVERT TO UPPER
	CAIN	B,"E"		;RE-EDIT?
	 JRST	 EDIT		; YES
	TTCALL	11,		;CLEAR INPUT BUFFER
	CAIN	B,12		;CONTINUE AUTOMATISCH?
	SETOM	%ERGO		;YES

	CAILE	B,15		;TRY TO CONTINUE?
	JRST	NOCR

	CAIE	B,""		;CONTINUE ANYWAY OR
GOTRY:	SKIPGE	%RECOV		;CAN WE CONTINUE?
	POPJ	P,		;YES

	TERPRI	<CAN'T CONTINUE>
	JRST	WATNOW

NOCR:	CAIN	B,"S"
	 JRST	 STRTIT		;RESTART
	CAIN	B,"X"		;EXIT?
	JRST	[
	MOVSI	17,%UACS
	BLT	17,17
	CALL6	EXIT]

NOXIT:	CAIE	B,"D"
	JRST	BADRSP		;DOESN'T KNOW WHAT HE WANTS
GODD:	SKIPN	JOBDDT		;IS DDT IN CORE
	 JRST	 NODDT		;NOPE
	MOVSI	17,%UACS
	BLT	17,17
	JRST	@JOBDDT

NODDT:	TERPRI	<NO DDT>
	JRST	WATNOW

BADD__0
IFN SAILRUN,<IFDEF FTDEBUG,<IFN FTDEBUG,<BADD_1>>>

BADRSP:
IFN BADD, <
NOCOM2 <
	CAIN	B,"L"
	JRST	[TERPRI <TYPE #S TO LOOK AT STACK ELEMENT #
TYPE T TO TERMINATE AND RETURN TO ERROR HANDLER>
		JRST	INNA]
>;NOCOM2
	TERPRI	<REPLY [CR] TO CONTINUE,
[LF] TO CONTINUE AUTOMATICALLY,
"D" FOR DDT, "E" TO EDIT,
"X" TO EXIT, "S" TO RESTART,
"L" TO LOOK AT PARSE STACK>
>
IFE BADD, <
	TERPRI	<REPLY [CR] TO CONTINUE,
[LF] TO CONTINUE AUTOMATICALLY,
"D" FOR DDT, "E" TO EDIT,
"X" TO EXIT, "S" TO RESTART>
>
	JRST	WATNOW

IOERRR:	TERPRI	
	TTCALL	3,(A)
	TERPRI
	CALLI			;AVOID CLOSING FILES
	CALL	[SIXBIT/EXIT/]	;FAIL WON'T LET ME USE CALL6
STRTIT:	HRRZ	A,JOBSA
	JRST	(A)


DSCR ARRAY ERROR UUO
PAR ARRAY NAME STRING DESCRIPTOR ADDRESS IS EFFECTIVE ADDR
 INDEX NUMBER IS AC FIELD.
DES ARRAY NAME, INDEX NUMBER ARE PRINTED. THEN ERROR UUO CODE
 IS ENTERED AS ABOVE.


ARERRR:
	PRINT	<INVALID INDEX NO. >
	LDB	A,[POINT 4,JOBUUO,12]
	PUSHJ	P,DECPNQ+1
	PRINT	< FOR ARRAY >
	SETZM	%RECOV		;NON-RECOVERABLE ERROR!
	PUSHJ	P,PRASC
	JRST	LINDUN

SUBTTL	  Special Printing Routines For Error Handler

DSCR UUO ERROR MESSAGE ROUTINES AND THEIR INDICES (AC FIELD OF UUO)


^^URTBL:UPOPJ			;0-1 -- NO ACTION
	.PRSM			;2-3 -- PRINT SYMBOL PTD TO BY LPSA (SAIL)
	PRASC			;4-5 -- PRINT SYMBOL PTD TO BY UUO INSTR
	ACPRT			;6-7 -- PRNT VAL OF AC IN INSTR PRECDNG UUO
	UUOPRT			;10-11 -- PRINT THE UUO
	AC1PRT			;12-13 --PRINT AC FIELD ASSUMING RETURN FROM
				; CALL IS IN UUO1(GOGTAB)

UUOPRT: HLRZ	A,40		;LH
	PUSHJ	P,OCTPNQ+1	;TYPE IT
	HRRZ	A,40		;RH
	JRST	OCTPNQ+1	;IT TOO

DSCR PRSYM -- PRINT SYMBOL NAME
PAR SAIL SEMANTICS BLOCK ADDRESS IN LPSA
RES TYPES $PNAME STRING FROM BLOCK
SID DESTROYS A,B



COM2 <
	$PNAME __ 1
>;COM2

IFN SAILRUN,<
PRASC:	SKIPA	A,JOBUUO	;STRING DESCRITPOR
.PRSM:	HRRI	A,$PNAME(LPSA)	;STRING DESCRIPTOR
>
IFE SAILRUN,<
PRASC:.PRSM: MOVE A,JOBUUO	; STRING DESCRIPTOR
>
	HRRZ	B,(A)		;#CHARACTERS
	MOVE	A,1(A)		;STRING BP
	JRST	PRSL1		;WON'T WORK FOR ZERO LENGTH STRINS

PRSL:	ILDB	C,A		;CHARACTER
	TTCALL	1,C		;TYPE IT
PRSL1:	SOJGE	B,PRSL
UPOPJ:	POPJ	P,


AC1PRT:	MOVE	A,GOGTAB	;GET USER TABLE PTR
	SKIPA	A,UUO1(A)	;SOMEONE STORED RIGHT THING HERE

ACPRT:	HRRZ	A,UUO0
	LDB	A,[POINT 4,-2(A),12] ;AC # FROM PREV INSTR
	ADDI	A,%UACS
	JRST	DECPNQ		;PRINT IT IN DECIMAL
SUBTTL	  Code to Handle Linkage to Editors

EDIT:	
	SETZB	13,14		;PREPARE FOR PROVIDING
	SETZB	15,16		;STOPGAP WITH FILE NAME,
	MOVEI	11,0		; PAGE AND LINE NUMBERS
	TTCALL	0,B		;SEE IF FILE NAME SPECIFIED
	CAIE	B,15		;CR?
	 JRST	 GTNAM		; NO, NAME SPECIFIED

AUTO:

	TTCALL	0,B		;SNARF UP LINE FEED AFTER CR
IFL SAILRUN,<
; USE CURRENT FILE NAME UNDER COMPILATION
	MOVE	13,SRCFIL	;FILE NAME
	MOVE	14,SRCEXT
	MOVE	11,SRCPPN
	MOVE	16,FPAGNO	;CURRENT PAGE NUMBER
	SKIPN	15,ASCLIN	;LINE NUMBER IF ANY
	MOVE	15,[ASCID /00000/]
	TRO	15,1		;MAKE SURE IT'S A LINE NUMBER
	JRST	GTIT		;GO SWAP
>
COM2 <
	MOVEI	A,1
	SKIPE	ERRSPC
	PUSHJ	P,@ERRSPC	;SPECIAL FOR COMPILER....
>;COM2

IFGE SAILRUN, <
	JRST	GTIT		;GET QQSVED.RPG
>
GTNAM:	CAIE	B," "		;DELETE LEADING BLANKS
	 JRST	 MKNAMM
	TTCALL	0,B
	JRST	GTNAM

MKNAMM:	CAIN	B,15		;GO BACK ON CR
	 JRST	 AUTO
	MOVE	C,[POINT 6,13] ;COLLECT FILE NAME HERE
MKNLP:	CAIE	B," "		;DONE?
	CAIN	B,15
	 JRST	 GTIT1		; YES
	SUBI	B,40
	CAIN	B,"."-40
	SKIPA	C,[POINT 6,14] ;ADJUST TO GET EXTENSION
	IDPB	B,C		;CHAR OF FILENAME
	TTCALL	0,B
	JRST	MKNLP


GTIT1:	CAIN	B,15
	TTCALL	0,B

GTIT:	EXCH	13,14		;EXT IN REG PRECEDING NAME?
;HERE TO RUN ANY PROGRAM, EITHER SOS OR COMPIL.
; REGISTERS HAVE GOODIES IN THEM:
;		13	FILE EXTENSION IN SIXBIT
;		14	FILE NAME IN SIXBIT
;		15	LINE NUMBER IN ASCII.
;		16	PAGE NUMBER (BINARY)
;IF AC 14 IS ZERO, THIS MEANS NO FILE HAS BEEN
; SPECIFIED, AND WE WILL USE "COMPIL" TO REPEAT THE
; LAST EDIT COMMAND (THIS IS NOT A FEATURE ON MOST
; STANDARD DEC SYSTEMS -- SEE R SPROULL)
; ELSE FALL INTO EXPO VERSION ....

COMMENT  EXPORT VERSION OF EDITOR-INTERFACE
 PROVIDED BY R. SPROULL, 11-18-70
  SEE HIM FOR DETAILS ON DIDDLES TO CCL AND EDIT10

IFGE SAILRUN,<
	JUMPN	14,EDITG	;IF FILE, FIRE UP SOS
	MOVE	P,[XWD -1,[SIXBIT /SYS/
			   SIXBIT /COMPIL/
			  0  0  0  0 ]]
	CALL6	(P,RUN)		;GO RUN IT.
	JRST	4,0
>; IFGE SAILRUN
EDITG:	PUSHJ	P,RPGDSK ;SET UP FOR FILE
	MOVE	2,14 	;GET THE FILE
	PUSHJ	P,SXCON
	MOVEI	1,"."
	SKIPN	2,13     ;EXTENSION
	JRST	NOEXT
	PUSHJ	P,OUT1
	HLLZS	2	;EXTENSION.
	PUSHJ	P,SXCON
NOEXT:	SKIPN	11		;PROJ,PROG #
	JRST	NOPPN
	MOVEI	1,"["
	PUSHJ	P,OUT1
	HLRZ	1,11
	PUSHJ	P,OCTO	;OUTPUT OCTAL
	MOVEI	1,","
	PUSHJ	P,OUT1
	HRRZ	1,11
	PUSHJ	P,OCTO
	MOVEI	1,"]"
	PUSHJ	P,OUT1
NOPPN:	PUSHJ	P,CRLF
	JUMPE	15,GOED10	;IF NO LINE NUMBER, DO NOT DO THIS.
	MOVEI	1,"P"
	PUSHJ	P,OUT1
	MOVE	2,15		;LINE NUMBER
	TRZ	2,1	;FOR SURE?
ASCO:	MOVEI	1,0
	LSHC	1,7
	PUSHJ	P,OUT1
	JUMPN	2,ASCO
	MOVEI	1,"/"
	PUSHJ	P,OUT1
	MOVE	1,16	;PAGE NUMBER
	PUSHJ	P,OUTDEC
	PUSHJ	P,CRLF
GOED10:	MOVE	1,PPMAX+2 ;SIZE
	ADDI	1,4
	IDIVI	1,5	  ;TO WORDS
	MOVNS	1
	HRLS	1
	HRR	1,PPMAX	  ;BUFFER START
	ADDI	1,1
	MOVEM	1,PPMAX+2
	MOVSI	1,'EDT'
	EXCH	1,PPMAX+1
	MOVE	2,[XWD 3,PPMAX+1]
	CALLI	2,44	;WRITE IT
	JRST	DSKIT
EDT10R:	MOVE	P,[XWD 1,[SIXBIT /SYS/
			  SIXBIT /SOS/
			  0000]]
	CALL6	(P,RUN)
	JRST	4,.
DSKIT:	SETSTS	1,16	;DO NOT LOSE BUFFERS
	MOVEM	1,PPMAX+1
	CALLI	2,30	;JOB NUMBER
	MOVSI	1,'EDT'	;TO FILE NAME
	MOVEI	4,3
DGLP:	IDIVI	2,=10
	IORI	1,20(3)
	ROT	1,-6	
	SOJG	4,DGLP
	MOVSI	2,'TMP'
	SETZB	3,4
	ENTER	1,1
	CALLI	12		;FATAL
	SETSTS	1,0
	CLOSE	1,0		;FINISH
	JRST	EDT10R
RPGDSK:	CALLI
	INIT	1,0
	SIXBIT	/DSK/
	XWD	PPMAX,0
	CALLI	12
	OUTBUF	1,0
	OUTPUT	1,0
	SETZM	PPMAX+2
	MOVEI	1," "
OUT1:	AOS	PPMAX+2
	IDPB	1,PPMAX+1
	POPJ	P,
SXCON:	MOVEI	1,0
	LSHC	1,6
	ADDI	1,40
	PUSHJ	P,OUT1
	JUMPN	2,SXCON
	POPJ	P,
OCTO:	IDIVI	1,10
	HRLM	2,(P)
	SKIPE	1
	PUSHJ	P,OCTO
	HLRZ	1,(P)
	ADDI	1,"0"
	JRST	OUT1
OUTDEC:	IDIVI	1,=10
	HRLM	2,(P)
	SKIPE	1
	PUSHJ	P,OUTDEC
	HLRZ	1,(P)
	ADDI	1,"0"
	JRST	OUT1
CRLF:	MOVEI	1,15
	PUSHJ	P,OUT1
	MOVEI	1,12
	JRST	OUT1
SUBTTL	 DECPNT, OCTPNT, FIX, FLOAT UUOs

DSCR OCTPNT, DECPNT UUO'S
PAR ADDR OF WORD TO BE PROCESSED IS EFFECTIVE ADDR
RES DECPNT -- WORD TYPED IN DECIMAL
 OCTPNT -- OCTAL




OCTPNQ: HRRZ	A,(A)
	MOVEI	C,10	;KEEP RADIX IN C.
	JRST	PNT

DECPNQ:	MOVE	A,(A)
	MOVEI	C,=10
	JUMPGE	A,PNT	; GREATER 0.
	PRINT	<->
	MOVMS	A		; FOO1 _ ABS(FOO1);
PNT:	IDIV	A,C	;FAMOUS DEC RECURSIVE NUMBER PRINTER.
	IORI	B,"0"
	HRLM	B,(P)
	SKIPE	A
	PUSHJ	P,PNT
	HLRZ	B,(P)
	TTCALL	1,B
	POPJ	P,

DSCR FIX UUO (FIXQ)
PAR EFFECTIVE ADDR  WORD TO BE CONVERTED
RES FIXED POINT EQUIVALENT IN AC SPECIFIED IN AC FIELD OF UUO

FIXQ:	TRNN	A,777760	;IN AC?
	ADDI	A,%UACS		;YES
	MOVE	B,(A)		;GET ARGUMENT
	MULI	B,400	;THIS ALGORITHM STOLEN FROM F4.
	TSC	B,B
	EXCH	B,C
	ASH	B,-243(C)
	JRST	FXFLT		;STORE IN RIGHT PLACE.
	POPJ	P,

DSCR FLOAT UUO (FLOAQ)
RES LIKE FIX, BUT RETURNS FLOATING POINT EQUIVALENT OF ITS ARGUMENT

FLOAQ:	TRNN	A,777760	;IN AC?
	ADDI	A,%UACS		;YES
	MOVE	B,(A)		;GET ARGUMENT
	IDIVI	B,1B18
	SKIPE	B
	TLC	B,254000
	TLC	C,233000
	FAD	B,C
FXFLT:
	LDB	A,[POINT 4,A,12] ;RESULT REGISTER
	MOVEM	B,%UACS(A)	;STORE RESULT
	POPJ	P,
SUBTTL	 DSPLIN, etc.for Disp. Text Line on Error (Compiler)

DSCR DPYCLR
CAL PUSHJ
RES RESETS III DPY STATE IF A III DPY IS AROUND




SUBTTL	SAVE, RESTR, INSET -- General Utility Routines

DSCR SAVE
CAL PUSHJ
DES This routine saves registers 0-CHNL (12) in the user
 RACS area. It also saves the return
 address (-1(P)) in UUO1(USER), for traditional reasons,
 for the error message printout routines.
 Register USER is loaded but not saved, as is register
 TEMP

^SAVE:	MOVE	USER,GOGTAB	;USER RE-ENTRANT TABLE
	HRRZI	TEMP,RACS(USER)	;XWD FF,SAVEADDR
	BLT	TEMP,RACS+CHNL(USER) ;SAVE FF THRU CHNL
	MOVE	TEMP,-1(P)	;RETURN ADDR FROM I/O CALL
	MOVEM	TEMP,UUO1(USER)	;STORE RETURN
	POPJ	P,

DSCR RESTR
PAR LPSA -- XWD FOR ADJUSTING P-STACK (#PARAMS+RETURN ADDR)
CAL JRST
RES ACS are restored from RACS, stack is adjusted using LPSA,
 return is made through UUO1(USER)


^RESTR:	MOVSI	TEMP,RACS(USER)	;XWD SAVEADDR,FF
	BLT	TEMP,CHNL	;RESTORE
	SUB	P,LPSA		;ADJUST STACK
	JRST	@UUO1(USER)	;RETURN

DSCR INSET
CAL PUSHJ
RES String Space is adjusted so that next created string will start
 on a full-word boundary.
SID USERGOGTAB
DES REMCHR is first adjusted, and STRNGC called if necessary.
 Then TOPBYTE is adjusted.



^INSET:	MOVSI	TEMP,1		;ALIGN TO FULL WORD BOUNDARY.
	MOVE	USER,GOGTAB	;MAKE SURE
	ADDB	TEMP,TOPSTR(USER) ;MAKE NEW TOPSTR WORD.
	HLL	TEMP,TOPBYTE(USER)
	HRRI	TEMP,[BYTE (7) 0,4,3,2,1,0]
	ILDB	TEMP,TEMP	;ADJUSTMENT NEEDED.
	ADDM	TEMP,REMCHR(USER)	;UPDATE REMCHR.
	SKIPL	TEMP,TOPBYTE(USER)
	ADDI	TEMP,1
	HRLI	TEMP,440700	;POINT 7, WORD
	MOVEM	TEMP,TOPBYTE(USER)	;AND SAVE
	POPJ	P,
>;NOLOW
ENDCOM(LUP)
COMPIL(COR,<CORREL,CORGET,CORINC,CANINC,CORBIG>
	   ,<GOGTAB>
	   ,<CORGET, CORREL, ... -- CORE ALLOCATION ROUTINES>)
SUBTTL	Core Service Routines -- General Description

DSCR BEGIN CORSER

IFN ALWAYS,<BEGIN CORSER>
Comment  These are the core allocation routines for both the compiler
	and the code it compiles.  Core comes in "BLOCKs."  A block may be any
	(reasonable) length, and has the following format:

HEAD:	PREV,,NEXT		;if block not in use, free storage list pointers
		SIZE		;GREATER 0 if free, LESS0 if in use
	<SIZE-3 data words>	;whatever is to go here
	x00000,,HEAD		;x=1 if in use, 0 if free

PREV is zero if this block is first on free storage list. NEXT is zero if last

In the beginning, the world starts out as one big block, occupying space from
	the end of the (GOGTAB) user table to @JOBREL. Once a MOVE USER,GOGTAB
	has been done, LOWC(USER) and TOP(USER) indicate the total size of
	available core. FRELST(USER)  the first (only) block in free storage.
 
If GOGTAB is 0, CORGET will create a user table and make the remaining space
	look like a BLOCK.  It will create a user table and point GOGTAB at it.
	It also assures that DDT symbols are below JOBSA(lh).  Then it sets
	JOBFF to =76K out of pure spite.  Now CORGET operations may be issued.

CORGET is called with the desired size in SIZ (C). The free storage list is
	searched for the first free block (BLK) satisfying the request. The
	required block is taken from lower addresses of BLK and BLK is adjusted.
	If requested size is within a few words of the free size, all of BLK is
	given to the user. The resultant address is returned in THIS (B).

If there is no block on FRELST(USER) big enough, or if ATTOP(USER)  0, CORGET
	checks XPAND(USER) for permission (0) to expand core.  If granted, a new
	block is formed at the top after obtaining more core. It is merged with
	the top block if it is free, then the requested block is allocated from
	it.  CORGET is simple.

CORGET skips if it is successful. It does not skip if it needs to expand and
	either XPAND(USER)  0 or the CORE UUO fails.

The secret is CORREL. No compacting is done, but CORREL will merge a returning
	block with any neighboring free block.  It can do this because it can
	tell the status of each neighbor by looking at the size (POS if free)
	field or x-bit (off if free).  This tends to reduce checkerboarding.

CORREL is called with a pointer to the block to be released in THIS (B).
	It returns nothing, nor does it ever skip.

CORBIG returns in SIZ the size of the largest available block. 
NOLOW <			;INCLUDE IN UPPER SEGMENT.
SUBTTL	 Special AC Declarations

DEBCOR __0		;SWITCH FOR CORE DEBUGGING ROUTINES.
;  ACS  

SIZ	__  3			;SIZE OF BLOCK BEING OBTAINED OR RELEASED
THIS	__  2			;POINTER TO SAME
NEXT	__  1			;POINTER TO SUCCESSOR
PREV	__  5			;POINTER TO PREDECESSOR
LAST	__  6			;POINTER TO NEXT-HIGHER NEIGHBOR

TRIVIAL __=10			;AMOUNT WE'RE WILLING TO WASTE
SUBTTL	  Utility Routines

DSCR UNLINK
CAL PUSHJ
PAR Core block to be removed in AC THIS (2)
RES block is removed from CORSER free storage list
SID ACs NEXT (1) and PREV (5) are given appropriate values


UNLINK:	
	HRRZ	NEXT,(THIS)		;NEXT BLOCK
	HLRZ	PREV,(THIS)		;PREVIOUS BLOCK
	SKIPN	PREV			;IF A PREV BLOCK DOES NOT EXIST,
	 MOVEI	 PREV,FRELST(USER)	; USE FRELST POINTER
	HRRM	NEXT,(PREV)		;CHANGE ITS NEXT FIELD
	SKIPE	NEXT			;IF A NEXT BLOCK EXISTS,
	 HRLM	 PREV,(NEXT)		; CHANGE ITS PREV FIELD
	POPJ	P,			;BLOCK IN "THIS" IS NO LONGER ON FRELST

DSCR RELINK
CAL PUSHJ
PAR AC THIS  core block to be placed on free storage list
 AC LAST  last word of block +1
 AC SIZ has size of this block
DES block is placed on CORSERs free storage list
SID AC NEXT (1) is given the appropriate value


RELINK:
	HRRZM	THIS,-1(LAST)		;X-BIT _ 0, RH _ PTR TO HEAD
	MOVEM	SIZ,1(THIS)		;GREATER 0 SIZE FIELD  FREE BLOCK
	SKIPE	NEXT,FRELST(USER)	;PLACE NEW BLOCK ON FRONT OF FRELST
	 HRLM	 THIS,(NEXT)		; IF THERE IS ONE
	HRRZM	NEXT,(THIS)		;POINT TO NEXT FROM THIS
	HRRZM	THIS,FRELST(USER)	;UPDATE FRELST POINTER
	POPJ	P,			;RETURN

DSCR CORE2I
CAL PUSHJ
DES Initializes second segment core if there is a global model




DSCR BUFRST
CAL PUSHJ or JRST
RES restores ACs from CORSER routines, and returns


BUFRST:	
IFN DEBCOR,<
	SKIPE	PRTCOR			;SHOULD WE DEBUG?
	JFCL
>
	MOVSI	TEMP,BUFACS(USER)
	BLT	TEMP,LAST
	POPJ	P,

DSCR BUFSAV
CAL PUSHJ
RES Saves ACs for CORSER routine
 Initializes CORSER storage, obtains USER TABLE if GOGTAB is 0


BUFSAV:	
	SKIPE	USER,GOGTAB		;CAN WE GO AHEAD?
	 JRST	 JUSTSAVE		; YES

Comment  Use SALTAB and forget the rest if SALTAB is there. Otherwise
	set up a user table.  Don't use THIS or SIZ (B or C). 

	MOVEI	TEMP,-1			;FOR MAX CORE 
	MOVEM	TEMP,JOBFF		; IS DOING
 
;	SKIPE	USER,SALTAB		;OTHERS CAN SPECIFY SAIL SPACE
;	MOVEM	USER,GOGTAB		;SET UP GOGTAB IF SALTAB NON-ZERO
;	JUMPN	USER,JUSTSAVE		;DON'T GO THRU SAIL's ALLOCATION

; ASSUME THAT THE WORLD IS NEW

	HLRZ	USER,JOBSA		;USER TABLE ADDRESS
	MOVEM	USER,GOGTAB		;THIS TIME FOR SURE
	SKIPN	JOBDDT			;IF DDT IS IN CORE,
	 JRST	 NODDT			; MAKE SURE ITS SYMBOLS ARE PROTECTED
	HRRZ	TEMP,JOBSYM		;IF JOBSYM IS BELOW JOBFF, THEN 
	CAML	TEMP,USER		; ASSUME ALL SYMBOLS ARE BELOW.
	 TERPRI	 <YOUR SYMBOLS ARE SOON TO BE OBLITERATED>


NODDT:	MOVEI	TEMP,ENDREN-CLER+=2000(USER)	;MAKE SURE
	CAMGE	TEMP,JOBREL		; ENOUGH CORE EXISTS
	 JRST	 CORTHER		; FOR USER TABLE

	CALL6	(TEMP,CORE)		;GET ENOUGH
	 ERR	 <DRYROT -- NO ROOM FOR USER TABLE>

CORTHER:
	SETZM	(USER)			;CLEAR USER TABLE
	HRL	TEMP,USER
	HRRI	TEMP,1(USER)
	BLT	TEMP,ENDREN-CLER(USER)
	MOVEI	THIS,ENDREN-CLER(USER)	;SET UP LIMITS OF FREE SPACE
	MOVEM	THIS,LOWC(USER)		; BOTTOM
	PUSHJ	P,NEWBLK		;MAKE NEW AREA INTO A FREE BLOCK
	JRST	JUSTSAVE		;SAVE ACS

NEWBLK:	
	HRRZ	LAST,JOBREL		;END OF BIG BLOCK
NEWB1:	SETZM	(THIS)			;POINTERS WORD IN BIG BLOCK
	ADDI	LAST,1			;CONFORM TO "LAST" STANDARDS
	MOVEM	LAST,TOP(USER)		;TOP OF FREE SPACE
	PUSH	P,SIZ			;SAVE SIZE
	MOVE	SIZ,LAST		;COMPUTE SIZE OF NEW BLOCK
	SUB	SIZ,THIS		;SIZE OF BIG BLOCK
	PUSHJ	P,RELINK		;PUT ON FREE STORAGE LIST
	POP	P,SIZ			;GET SIZ BACK
	POPJ	P,


JUSTSAVE:
	MOVEI	TEMP,BUFACS(USER)
	BLT	TEMP,BUFACS+LAST(USER)
IFN DEBCOR,<
	SKIPE	PRTCOR			;SHOULD WE DEBUG?
	PUSHJ	P,CORPRT		; YES
>
	POPJ	P,


IFN DEBCOR,<
^PRTCOR:	0
>
SUBTTL	 CORGET

DSCR CORGET
CAL PUSHJ
PAR size of desired block in AC  C (3)
RES 	SUCCESS: addr of block in B, skip-return
	FAILURE: no-skip
SID none, except when called with GOGTAB 0 -- should only be done by experts
DES a block of at least the required size is obtained using first-fit algorithm.
	Up to 10 extra words may be returned, but this is not reflected in C.


^CORGET:
IFN DEBCOR,<
	SKIPE	PRTCOR
	 TERPRI	 <CORGET: >		;TELL THE PEOPLE WHO YOU ARE
>
	PUSHJ	P,BUFSAV		;SAVE AC'S, INITIALIZE WORLD PERHAPS


COR21:	ADDI	SIZ,3			;3 WORDS FOR CONTROL INFO
	SKIPE	ATTOP(USER)		;IF USER REQUESTS IT, GET BLOCK
	 JRST	 EXPAND			; AT TOP OF CORE

	MOVEI	THIS,FRELST(USER)	;THIS WILL POINT TO THE FIRST GOOD BLOCK

GETLUP:	HRRZ	THIS,(THIS)		;NEXT FREE BLOCK
	JUMPE	THIS,EXPAND		;TRY TO EXPAND CORE, NONE EXIST YET
	CAMLE	SIZ,1(THIS)		;WILL IT FIT?
	 JRST	 GETLUP			; NO, TRY NEXT

GETCOR:	AOS	(P)			;SUCCESS GUARANTEED
	HRRZM	THIS,BUFACS+THIS(USER)	;RESULT(ALMOST)
	PUSHJ	P,UNLINK		;UNLINK THIS BLOCK
	MOVE	LAST,1(THIS)		;REAL BLOCK SIZE
	CAIGE	LAST,TRIVIAL(SIZ)	;IS DIFFERENCE NEGLIGIBLE?
	 JRST	 [MOVSI TEMP,400000	;YES, USE WHOLE THING --
		  ADD   LAST,THIS	; MARK X-BIT TO INDICATE IN USE
		  HLLM	TEMP,-1(LAST)
		  JRST	GETOUT]		;AND GO FINISH OUT

	MOVEM	SIZ,1(THIS)		;NEW SIZE FOR RESULT
	HRRZ	TEMP,THIS		;SAVE START OF BLOCK (RESULT)
	ADD	THIS,SIZ		;NEW START FOR REMAINING FREE STUFF
	SUB	LAST,SIZ		;NEW SIZE FOR REMAINS
	MOVE	SIZ,LAST
	ADD	LAST,THIS		;NEW END FOR REMAINS
	HRLI	TEMP,400000		;TURN X-BIT ON
	MOVEM	TEMP,-1(THIS)		;IN USER'S BRAND NEW BLOCK
	PUSHJ	P,RELINK		;RELINK REMAINS, RESTORE ACS


GETOUT:	PUSHJ	P,GETRST		;RESTORE ACS
	SETZM	(THIS)			;PTR RETRIEVED FROM STORAGE
	MOVNS	1(THIS)			;SIZE NEG  IN USE
	ADDI	THIS,2			;USER DOESN'T SEE THIS HEADER
IFN DEBCOR,<
	SKIPE	PRTCOR
	PUSHJ	P,CORPRT
>
	POPJ	P,			;HERE'S YOUR BLOCK!

EXPAND:	SKIPE	XPAND(USER)		;IS IT ALLOWED TO EXPAND?
	 JRST	 GETRST			; NO, ERROR RETURN
	PUSH	P,SIZ			;SAVE TOTAL SIZE
	HRRZ	THIS,TOP(USER)		;THISNEW BLOCK IF NEXT LOWER IS USED
	SKIPGE	-1(THIS)		;IS TOP BLOCK FREE?
	 JRST	 GETMOR			; NO, USE WHAT YOU HAVE
	HRRZ	THIS,-1(THIS)		;UNLINK THE
	PUSHJ	P,UNLINK		; TOP BLOCK

GETMOR:	MOVE	TEMP,THIS
	ADDI	TEMP,=1024(SIZ)		;GET MORE AND THEN SOME
	POP	P,SIZ			;GET THIS BACK BEFORE YOU FORGET
	CALL6	(TEMP,CORE)		;ASK FOR MORE
	 JRST	 GETRST			;CAN'T GET IT
	PUSHJ	P,NEWBLK		;MAKE TOP LOOK LIKE FREE BLOCK
	CAMLE	SIZ,1(THIS)		;NOW SHOULD FIT
	 ERR	 <DRYROT -- EXPAND CODE GLUBBED UP>
	JRST	GETCOR			;GO GET BLOCK

GETRST:	
	 JRST BUFRST
SUBTTL	 CORINC, CANINC

DSCR CORINC 
CAL PUSHJ
PAR AC B -- Addr of block to be incremented
 AC C -- amount if increase desired
RES SUCCESS: skip-return, extra core has been granted
 FAILURE: no-skip
SID none


^^CORINC:	
IFN DEBCOR,<
	SKIPE	PRTCOR
	 TERPRI	 <CORINC:>
>
	PUSHJ	P,JUSTSAVE		;SAVE ACS
	MOVNI	FF,1			;WANT TO DO IT
	JRST	INCR

DSCR CANINC
CAL PUSHJ
PAR same as CORINC
RES No extra core is ever actually obtained
 if entire request can be granted, skip-return
 if some extra words available, no-skip, C contains possible increment
 if no extra words available, no-skip, C contains 0
SID none except as described above


^^CANINC:
IFN DEBCOR,<
	SKIPE	PRTCOR
	 TERPRI	 <CANINC: >
>
	PUSHJ	P,BUFSAV
	MOVEI	FF,0			;JUST WANT TO SEE IF IT'S POSSIBLE

; IF BLOCK IS AT TOP, CAN ALWAYS DO IT

INCR:	SUBI	THIS,2			;POINT AT REAL BLOCK HEAD
	HRRZ	LAST,THIS		;CHECK AT TOP
	SUB	LAST,1(THIS)		; ADDR OF END (SIZE IS NEG)
	CAMGE	LAST,TOP(USER)		;TOP BLOCK?
	 JRST	 MIDDLE		; NO
	JUMPE	FF,YESINC		;SUCCESS
	MOVNS	1(THIS)			;MAKE IT LOOK FREE
	ADD	SIZ,1(THIS)		;TOTAL SIZE
	HRRZS	-1(LAST)		;MAKE END LOOK FREE
	JRST	EXPAND			;EXPAND AND RETURN

MIDDLE:	SKIPGE	TEMP,1(LAST)		;NEXT BLOCK FREE?
	 JRST	 NONEATALL		; NO, FAILURE
	SUBI	TEMP,3			;AVAILABLE SIZE
	CAMLE	SIZ,TEMP		;IS THERE ENOUGH?
	 JRST	 MAYBE			; NO, FAILURE MAYBE

	JUMPE	FF,YESINC		;ALL OK, CAN DO, REPORT IT
CRXXB:	MOVNS	TEMP,1(THIS)		;MAKE IT LOOK FREE
	PUSH	P,(THIS)		;WILL RESTORE THIS IN CASE SOMEONE USED
	PUSH	P,THIS			;SAVE SIZE
	PUSH	P,SIZ			;AND POINTER
	ADDM	TEMP,(P)		;TOTAL SIZE DESIRED AFTER RETURN
	MOVE	SIZ,TEMP		;SIZE OF CURRENT "THIS"
	HRRZ	THIS,LAST		;MERGE "THIS" WITH "LAST"
	PUSHJ	P,UNLINK		;TAKE IT OFF FRELST
	ADD	LAST,1(THIS)		;AND INCREASE
	ADD	SIZ,1(THIS)
	MOVE	THIS,-1(P)		;RETRIEVE CURRENT BLOCK.
	PUSHJ	P,RELINK		;AND NOW RELINK ON FRELST.
	POP	P,SIZ
	POP	P,THIS
	PUSHJ	P,GETCOR		;GET THE BLOCK AGAIN, ONLY BIGGER
	 ERR	 <DRYROT>		;CAN'T HAPPEN
	POP	P,-2(THIS)		;GET POINTER WORD BACK
	AOS	(P)			;SUCCESS
	POPJ	P,			;BUFRST DONE BY GETCOR

YESINC:	AOS	(P)			;REPORT SUCCESS
IFN DEBCOR,<
	SKIPE	PRTCOR
	PUSHJ	P,CORPRT
>
	JRST	BUFRST

MAYBE:	ADDI	TEMP,3(LAST)		;GET TOP OF NEXT BLOCK AND SEE
	CAMGE	TEMP,TOP(USER)		;IF IT IS THE TOP ONE.
	 JRST	 NOTENUF		;NO  -- FAIL UTTERLY.
	JUMPE	FF,YESINC		;GOT IT IF ONLY GOING TO HERE.
	PUSH	P,SIZ			;SAVE AMOUNT REQUESTED.
	MOVEI	SIZ,-3(TEMP)		;THIS IS THE SIZE OF THE BLOCK WE
	SUB	SIZ,LAST		;KNOW WE CAN GET.
	MOVN	TEMP,SIZ
	ADDM	TEMP,(P)		;(P) NOW HAS EXTRA REQUIRED.
	PUSHJ	P,CRXXB			;AND WE DO SOO
	 ERR	<DRYROT>		; CAN'T HAPPEN.
	POP	P,SIZ			;RETRIEVE SIZE.
	MOVNI	FF,1			;SINCE CRXXB DESTROYED IT.
	JRST	INCR			;AND GO THROUGH AGAIN
					;THIS TIME IT WILL BE THE TOP BLOCK.


NOTENUF:
	SUBI	TEMP,3(LAST)		;UNDO WHAT WAS DONE ABOVE
	SKIPA	SIZ,TEMP		;CAN'T DO ALL, BUT CAN DO THIS MUCH

NONEATALL:
	MOVEI	SIZ,0			;CAN'T DO ANYTHING
	MOVEM	SIZ,BUFACS+SIZ(USER)
	JRST	BUFRST

SUBTTL	 CORREL

DSCR CORREL
CAL PUSHJ
PAR addr of block to be released in B
RES block is released to free storage
SID none
DES the block is merged with any adjoining free blocks


^^CORREL:
IFN DEBCOR,<
	SKIPE	PRTCOR
	 TERPRI	 <CORREL: >
>
	SKIPN	USER,GOGTAB		;MUST BE SET UP HERE
	 ERR	 <DRYROT -- CORREL CALLED WITH INITIALIZED WORLD>
	PUSHJ	P,JUSTSAVE		;SAVE ACS

; MERGE WITH LOWER NEIGHBOR (ADDRESS-WISE) IF POSSIBLE

	SUBI	THIS,2			;USER THINKS IT STARTED 2 PAST
	MOVN	SIZ,1(THIS)		;SIZE OF THIS BLOCK
	MOVE	LAST,SIZ		;ADDRESS OF UPPER
	ADD	LAST,THIS		;  NEIGHBOR

	CAMGE	THIS,LOWC(USER)		;IS ADDRESS IN RANGE?
	 ERR	 <DRYROT -- BAD ADDRESS TO BUFREL>
	CAME	THIS,LOWC(USER)		;CAN THERE BE A LOWER BLOCK
	SKIPGE	-1(THIS)		; AND IF SO, IS IT FREE?
	 JRST	 UPPET			; NO, LOOK FOR UPPER BLOCK

	HRRZ	THIS,-1(THIS)		;LOWER BLOCK
	PUSHJ	P,UNLINK		;UNLINK IT FROM LIST
	ADD	SIZ,1(THIS)		;INCREASE SIZE
	
; MERGE WITH UPPER NEIGHBOR IF POSSIBLE

UPPET:	CAMLE	LAST,TOP(USER)
	 ERR	 <YOU ARE ABOUT TO GET AN ILL MEM-REF>,1

	CAME	LAST,TOP(USER)		;IS THERE AN UPPER BLOCK?
	SKIPGE	1(LAST)			;AND IF SO, IS IT FREE?
	 JRST	 LNKRET			; NO, RELINK AND GO AWAY

UPPR:	PUSH	P,THIS
	HRRZ	THIS,LAST		;THIS  UPPER NEIGHBOR
	PUSHJ	P,UNLINK			;GET IT OUT
	ADD	LAST,1(THIS)		; INCREASE EXTENT
	ADD	SIZ,1(THIS)		; AND TOTAL SIZE
	POP	P,THIS			; GET HEADER POINTER BACK
LNKRET:	
	SKIPN	NOSHRK(USER)	;IF GIVEN PERMISSION, AND
	CAMG	LAST,JOBREL	;THIS IS THE LAST CORE BLOCK, AND
	 JRST	 LNKRT
	CAIGE	SIZ,=2046	; IT IS MORE THAN 2K LONG,
	 JRST	 LNKRT
	MOVEI	TEMP,=2046(THIS) ;THEN 1) SHRINK CORE TO 2K FOR LAST BLOCK
	CALL6	(TEMP,CORE)
	 ERR	 <DRYROT --CORSER&LNKRET>
	MOVE	LAST,JOBREL	; AND  2) ADJUST BLOCK TO INDICATE
	ADDI	LAST,1
	MOVEM	LAST,TOP(USER)		;AND RECORD NEW RESULTS.
	MOVE	SIZ,LAST	;          THE CHANGE BEFORE RELINKING
	SUB	SIZ,THIS
LNKRT:
	PUSHJ	P,RELINK		;PUT IT BACK
IFN DEBCOR,<
	SKIPE	PRTCOR
	PUSHJ	P,CORPRT
>
	JRST	GETRST			;AND GO AWAY

SUBTTL	 CORPRT, CORBIG

IFN DEBCOR,<
^CORPRT:
	SETZM	TOTFRE#			;TOTAL FREE STORAGE COUNT
	TERPRI	<FREE STORAGE: >
	PUSH	P,LPSA
	MOVE	USER,GOGTAB		;THIS STUFF IS DEBUGGING
	MOVEI	LPSA,FRELST(USER)	;JUNK FOR CORGET AND FRIENDS

CPLUP:	HRRZ	LPSA,(LPSA)		;IT SHOULD BE INTUITIVELY
	JUMPE	LPSA,DUNNN		;OBVIOUS
	PRINT	<START = >
	OCTPNT	LPSA
	MOVE	TEMP,1(LPSA)
	ADDM	TEMP,TOTFRE
	PRINT	<  SIZE =  >
	OCTPNT	TEMP
	ADD	TEMP,LPSA
	PRINT	<  END =  >
	OCTPNT	TEMP
	TERPRI
	JRST	CPLUP

DUNNN:
	PRINT	<TOTAL FREE SIZE = >
	OCTPNT	TOTFRE
	SETOM	PRTCOR
	TERPRI
	CAMLE	THIS,JOBREL
	JRST	DUNMOR
	TERPRI	<THIS BLOCK: >
	PRINT	<"THIS" = >
	MOVE	TEMP,THIS
	OCTPNT	TEMP
	PRINT	<  C-SIZE = >
	HRRZ	TEMP,SIZ
	OCTPNT	TEMP
	CAML	THIS,JOBREL
	JRST	DUNMOR
	HRREI	LPSA,-2(THIS)
	JUMPLE	LPSA,DUNMOR
	PRINT	<  BLOCK-SIZE = >
	MOVN	TEMP,1(LPSA)
	OCTPNT	TEMP

DUNMOR:	TERPRI
	POP	P,LPSA
	TTCALL	11,
	TTCALL	TEMP
	TERPRI
	POPJ	P,

>

DSCR CORBIG
CAL PUSHJ
PAR NONE
RES LARGEST AVAILABLE BLOCK IN SIZ (3,C)
SID THIS (2,B) MUNGED


^^CORBIG: SKIPN	USER,GOGTAB
	ERR	<CORBIG: INITIALIZED WORLD>
	MOVEI	SIZ,0	;"ZERO-LENGTH" BLOCK
	MOVEI	THIS,FRELST(USER)
BIGLUP:	HRRZ	THIS,(THIS)
	JUMPE	THIS,BIGDUN	;END OF FREELIST?
	CAMGE	SIZ,1(THIS)
	MOVE	SIZ,1(THIS)	;FIND MAX
	JRST	BIGLUP
BIGDUN:	SUBI	SIZ,3		;WHAT HE SEES
	POPJ	P,



Comment   No other core routines should be necessary to provide
	gross control over allocation.  Programs obtaining
	space from CORGET can carve the blocks up if necessary.
	Please put your core back when you're done with it.

					Thank You,
					The Management


>;NOLOW
ENDCOM (COR)
IFN ALWAYS,<
BEND CORSER
>

COMPIL(SGC,<STRNGC,STRGC,STCLER,SGINS,SGREM>
	   ,<GOGTAB,X11,CORGET,CORREL,CORINC,X22,CORBIG>
	   ,<STRING GARBAGE COLLECTOR ROUTINES>
	   ,<%SPGC,%STRMRK,%ARRSRT>)
;String Garbage Collector Routines 

NOLOW <			;INCLUDE IN UPPER SEGMENT.

BKSZ__=25  BKOFF__=23 MLT__5


^.CORERR:
^CORERR:
	ERR	<NO CORE FOR ALLOCATION>

DSCR STRGC(# chars desired);
CAL SAIL 
RES calls string garbage collector with #chars in -1(p)..i.e.a formal param.


HERE (STRGC)
	EXCH	A,-1(P)		;THE DESIRED A IS HERE
	PUSHJ	P,STRNGC	;COLLECT TRASH
	SUB	P,X22		;BACK UP STACK
	MOVNS	A
	ADDM	A,REMCHR(USER)
	MOVE	A,1(P)		;GET ORIGINAL "A" BACK
	JRST	2,@2(P)		;RETURN



DSCR STRNGC
CAL PUSHJ
PAR A -- number of new characters needed
 REMCHR(USER) -- has been updated by that number of chars
RES String space is compacted, new REMCHR is updated by C(A).
 Restarts if not enough room left
SID none
DES STRNGC is a two-pass process. In the first, all string descriptors
 are found and sorted into ascending sequence with respect to the locations
 of their respective texts.  String descriptors are found via the generating
 routines, described in CALSG. 
 	In the second pass, all string texts are moved down to fill any
 unused space. All descriptors are adjusted to reflect the new locations.


^STRNGC: MOVE	USER,GOGTAB	;GET USER TABLE POINTER

	MOVEM	12,SGACS+12(USER)
	MOVEI	12,SGACS(USER)
	BLT	12,SGACS+11(USER)

;               OBTAIN SPACE, INITIALIZE GARBAGE COLLECTOR ______

	HRRZ	TEMP,TOPBYTE(USER) ;MAKE SURE DIDN'T OVERFLOW

; **** BUG TRAP
	CAMG	TEMP,STTOP(USER)
	CAMGE	TEMP,ST(USER)
	 ERR	 <DRYROT AT STRNGC>
; **** EBT

	SUB	TEMP,ST(USER)	;CREATE A DIVISOR FOR DISTRIBUTION
	ADDI	TEMP,5		; OF DESCRIPTORS DURING SGSORT
	MOVEM	TEMP,INKY(USER)
	SKIPE	XPAND(USER)	;ALLOWED TO EXPAND?
	 JRST	 INSIDE		; NO
	SETOM	ATTOP(USER)	;WANT BLOCK OFF THE TOP FOR SAFETY
	MOVEI	C,=400		;REASONABLE SIZE
	PUSHJ	P,CORGET	;IF CAN'T GET IT, TROUBLE
	SKIPA			;TRY TO GET WHAT YOU CAN
	JRST	CORROK		;GOT IT
INSIDE:	SETZM	ATTOP(USER)	;CAN'T EXPAND
	PUSHJ	P,CORBIG	;HOW MUCH CAN WE HAVE?
	PUSHJ	P,CORGET	;GET THAT AMOUNT
	ERR	<DRYROT - STRNGC CAN'T GET CORE>
CORROK:	SETZM	ATTOP(USER)	;NOW CAN GET ANYWHERE
	MOVEM	B,STBUCK(USER)	;SAVE  TO BLOCK
	SETZM	(B)
	HRLS	B
	ADDI	B,1
	MOVEI	TEMP,BKOFF(B)
	BLT	B,(TEMP)
	MOVE	B,STBUCK(USER)
	ADDI	B,BKSZ		;FIRST BKSZ WORDS IS "BUCKET" LIST
	MOVNI	C,-BKSZ(C)
	JUMPGE	C,CORERR	;BAD THING
	HRL	B,C
	SUB	B,X11		;IOWD FOR WORD ALLOC IN STRNGC
	MOVEM	B,SGFRE(USER)	;FREE SPACE POINTER

	HRRZ	A,ST(USER)
	HRLI	A,(<POINT 7,0>)
	MOVEM	A,TOPBYTE(USER)		;FIRST(USER) NEW OK POSITION
	SETZM	NUMCHR(USER)		;TOTAL # CHARS PREVIOUSLY MOVED

;		  SORT THE STRINGS _________
DSCR CALSG
PAR linked list of routine addresses based at SGROUT(USER)
RES each routine in list is called to provide string descriptors
 to the sorting routine, SGSORT.
SID SGSORT uses B,C,D,E,TEMP, accepts input in A. Generating
 routines may use A-T1 (12) and TEMP for their own devices.
 Q1 through T1 will not be changed by calls on SGSORT.
DES Each generating routine should do the following:
 1) Place a string descriptor in A
 2) PUSHJ P,SGSORT or PUSHJ P,@-1(P) (addr provided on stack)
 3) Repeat the process if it knows about more strings, else return
 4) Return with a POPJ (and a flourish)

The `standard' generating routines are:
 SPSG -- collects the string stack
 STRMRK -- collects string variables linked through SGLINK(USER)
 ARRMRK -- collects string arrays found in ARRPDL
 RINGSORT -- collects PNAMES from semantic blocks in compiler
 DEFSRT -- collects saved input strings during macro recursion in compiller
These routines should provide sufficient examples.




CALSG:	MOVEI	T,SGROUT(USER)		;GET LINKED LIST OF ROUTINE NAMES
	PUSH	P,T			;SAVE FIRST POINTER
	PUSH	P,[SGSORT]		;PROVIDE ACCESS TO SORTING ROUTINE
^CALSGL:
	SKIPN	T,@-1(P)		;GO DOWN LIST UNTIL DONE
	JRST	ALLCOL			;DONE
	HRRZM	T,-1(P)			;SAVE NEW POINTER
	PUSHJ	P,@-1(T)		;CALL GENERATOR ROUTINE
	JRST	CALSGL			;DO MORE THAN ONCE


;	      SORT THE SP STACK ______

HERE(%SPGC)	HRRZ	A,SPDL(USER)	;START AT BASE OF STACK
	ADDI	A,1
	JRST	SGTST		;AND WORK UP TO CURRENT POINTER
STRNGSTACKMARKLOOP:
	PUSHJ	P,SGSORT	;SORT IT INTO LIST
SGTST:
	CAIGE	A,(SP)		;DONE?
	 JRST	 STRNGSTACKMARKLOOP ;NO
GPOPJ:	POPJ	P,		;YES, GO ON TO NEXT TYPE

;           SORT THE STRINGS IN SYMBOL TABLE ______

COMMENT   FIND THESE IN THE COMPILER -- HERE FOR COMMENT ONLY.
^RINGSORT:
IFN SAILRUN, <
	HRRZ	T,STRRNG	;LAST BLOCK IN STRING RING
	JUMPE	T,GPOPJ		;DONE WHEN 0, GO MARK VARIABLES
RGSLUP:	MOVEI	A,$PNAME(T)	;DESCRIPTOR
	PUSHJ	P,SGSORT	;SORT IT INTO LISTS
	HLRZ	T,%RSTR(T)	;NEXT BLOCK
	JUMPN	T,RGSLUP	;CONTINUE UNLESS DONE

;	    SORT STRINGS IN DEFINE STACK ______

^DEFSRT:
	HRRZ	A,DFSTRT	;SORT STRINGS ON DEFINE STACK
	HRRZ	T,DEFPDP	;TERMINATION VALUE
	SUBI	A,1		;INIT
	JRST	SGDTST		;JUMP INTO THINGS

DEFMRK:	
	PUSHJ	P,SGSORT	;SORT INTO STRUCTURE
SGDTST:
	ADDI	A,2		;AUTO-INCR DOESN'T GO FAR ENOUGH
	CAMGE	A,T		;DONE?
	JRST	DEFMRK		; NO
	POPJ	P,		; YES
>



; 	          SORT THE VARIABLES ______

HERE (%STRMRK)
	SKIPN	T,STRLNK(USER)	;GET LINK
	 POPJ	 P,		; NO STRINGS AT ALL
STMKL1:	HRRZ	A,-1(T)		;1ST STRING
	HLRZ	Q2,-1(T)	;# STRINGS THIS PROC
	JRST	SOJLP		;GO LOOP
STMKLP:	
;	SKIPN	-2(T)		;PROCEDURE ACTIVE?
;	 SETZM	 (A)		; NO, MAKE NULL STRINGS

Comment  Due to certain social pressures (WFW LIVES ON)
	strings in inactive blocks remain over garbage collection  

	PUSHJ	P,SGSORT	;SORT VARIABLES INTO LIST
SOJLP:	SOJGE	Q2,STMKLP	;SORT UNTIL DONE WITH THIS PROC (SGSORT INCRS A)

STRMK4:	HRRZ	T,(T)		;NEXT PROCEDURE
	JUMPN	T,STMKL1	; IF THERE IS ONE
	POPJ	P,		;DONE


COMMENT 
		  SORT STRING ARRAYS ______

	THE ARRPDP STACK CONTAINS POINTERS
	TO ALL ACTIVE ARRAYS.  ALL ARE ASSUMED ACTIVE AND LEGAL.  ANY
	NEGATIVE ELEMENTS IN THE STACK ARE STACK MARKERS. THE FIRST
	WORD OF EACH ARRAY BLOCK IS THE NUMBER OF DIMENSIONS IF THE
	ARRAY IS A STRING ARRAY. THE WORD JUST PREVIOUS TO IT IS THE
	(NEGATIVE) SIZE OF THE ARRAY.


HERE (%ARRSRT)
IFGE SAILRUN, <
	HRRZ	T1,ARRPDP(USER)	;POINTER TO CURRENT TOP OF ARRAY STACK
	SKIPE	T1		;IN CASE NO ARRAYS AT ALL -- NOT EVEN A PDP.
ARS1:	CAMGE	T1,ARRPDL(USER)	;DONE?
	 JRST	 LARR		;LOOK INTO ARYLS.

	SKIPL	T,(T1)		;IS IT A STACK MARKER (IGNORE THESE)?
	PUSHJ	P,ARPUTI	;SORT THE ARRAY IN.
	SOJA	T1,ARS1		;AND GET THE NEXT ARRAY.
LARR:	SKIPN	T1,ARYLS(USER)	;ANY ROVING ARRAYS TO COLLECT?
	 POPJ	 P,		;NO --ALL DONE.
LAR1:	MOVE	T,1(T1)		;CORGET -LIKE POINTER FOR THE ARRAY.
	PUSHJ	P,ARPUTI	;AND SORT IT IN.
	HRRZ	T1,(T1)		;T1 _ CDR OF LIST.
	JUMPN	T1,LAR1		;AND IF MORE
	POPJ	P,


ARPUTI:	HRRZ	A,-2(T)		; FIRST DATA WORD (SEE ARRAY GUYS FOR FORMAT)
	SKIPL	Q2,-1(A)	;STRING ARRAY?
	 POPJ	 P,		;NO, IGNORE IT
	HRRZS	Q2		;YES, GET TOTAL SIZE
	LSH	Q2,-1		;NUMBER OF STRINGS

	JRST	ARSLP

ARS3:	
	 PUSHJ	 P,SGSORT	; BUT COLLECT NON-CONSTANTS 
ARSLP:	SOJGE	Q2,ARS3		;A INCREMENTED IN SGSORT, LOOP UNTIL DONE
	POPJ	P,		;ALL DONE WITH THIS ARRAY.

>



;  SUBROUTINE ENTERED WITH A  A STRING DESCRIPTOR.  CONVERTS
;  IT TO GARBAGE COLLECTOR FORMAT.  USES B, C.D,E,TEMP
;  START CONTAINS FIRST #CHARS FOR BEGINNING OF STRING SPACE.
; WARNING ***** CLOBBERS B,C,D,E,TEMX  **********

SGSORT:	

	HLLZ	B,(A)		;GET STRING NUMBER
	JUMPE	B,SGSRT		; DON'T COLLECT CONSTANTS OR NULL STRINGS

	HRRZ	D,1(A)		;MAKE SURE STRING IN RANGE
	HRRE	C,(A)		;CHECK LENGTH CONSISTENCY

; *** BUG TRAP
	JUMPE	C,DONBUG 	;DON'T WORRY MUCH ABOUT NULL STRINGS
	JUMPL	C,BUGG
	CAMG	D,STTOP(USER)
	CAMGE	D,ST(USER)
BUGG:	 ERR	 <DRYROT AT SGSORT>,1
DONBUG:
; *** EBT

	HLLZ	B,1(A)		;GET POINTER AND SIZE FIELDS OF BP
	HRRI	B,[BYTE (7) 0,1,2,3,4,5]
	ILDB	B,B		;#CHARS REPRESENTED BY POINTER
				;C HAS ADDR FILED OF BP (SEE ABOVE)
	SUB	D,ST(USER)		; - STRING SPACE BASE
	IMULI	D,5		;#CHARS
	ADD	B,D		; + CHARS IN POINTER
	MOVEM	B,1(A)		; TO BP WORD
	ADD	C,B		; + #CHARS FIELD (D LOADED ABOVE)
	HRRZM	C,(A)		;TO #CHARS WORD
	MOVE	D,B		;NOW DISTRIBUTE STRING TO PROPER
	IMULI	D,MLT		; LIST TO SPEED SORT
	IDIV	D,INKY(USER)	; SEE ABOVE FOR INKY CALC
	ADD	D,STBUCK(USER)	;DPROPER "BUCKET" ENTRY

; *** BUG TRAP
	MOVE	TEMP,STBUCK(USER)
	CAML	D,TEMP
	CAIL	D,BKSZ(TEMP)
	 ERR	 <DRYROT AT SGSLUP>,1
; *** EBT


;  A STRING DESCRIPTOR (MARKED)  -- DBUCKET LIST THIS STRING
;  B IS START COUNT [=1(A)] -- C IS END COUNT [=(A)]

SGSLUP:	MOVE	E,D		;E_CDR(E), IN FACT
	HRRZ	D,(E)		;D_CDR(E)
	SKIPN	D		;DONE?
	JRST	INSERT		; YES, INSERT AT END
	HLRZ	TEMP,(D)	;TEMP_CAR(D)
	CAMGE	B,1(TEMP)	;NEW START LESS?
	JRST	INSERT		;YES, INSERT THIS ONE IN FRONT OF IT
	CAME	B,1(TEMP)	;NEW START SAME?
	JRST	SGSLUP		;NO, GREATER

; EQUAL START COUNTS, ARRANGE BY END COUNT, DESCENDING SEQUENCE

	CAMG	C,(TEMP)	;NEW END GT OLD?
	JRST	SGSLUP		;NO, CONTINUE
;	(JRST	INSERT)		;YES

INSERT:
	MOVE	TEMP,SGFRE(USER)
	AOBJN	TEMP,STILMOR	;EXPAND LINK SPACE
SGXPND:	
	PUSH	P,TEMP
	MOVE	B,STBUCK(USER)	;CURRENT FWS BLOCK
	MOVEI	C,=100		;GET 100 MORE
	PUSHJ	P,CORINC	;EXPAND THE BLOCK
	 ERR	<NO CORE FOR ALLOCATION>
	POP	P,TEMP
	SUB	TEMP,[(100)]	;THERE IS MORE

STILMOR:
	MOVEM	TEMP,SGFRE(USER)
	HRLM	A,(TEMP)
	HRRM	D,(TEMP)
	HRRM	TEMP,(E)
SGSRT:	ADDI	A,2		;AUTO-INDEXING
	POPJ	P,

;  FIND A DISJOINT STRING GROUP, MOVE IT BACK.
;  MARK POINTERS APPROPRIATELY.

ALLCOL:	SUB	P,X22		;REMOVE JUNK PUT ON BY CALSG

SGSWEP:
	SETZB	T,T1		;IN CASE NO STRINGS AT ALL
	MOVEI	Q2,1		;INIT STRING NO.
	MOVE	Q3,STBUCK(USER) ;WORK UP BUCKET LIST, HANDLING
	MOVEI	FF,BKSZ(Q3)	;EVERYTHING IN THE PATH
	SUBI	Q3,1
	PUSHJ	P,FSTSTR	;AFIRST LIST
	HLRZ	Q1,(A)		;Q1  FIRST MARKED DESCRIPTOR
	JRST	SGFX1		;JUMP INTO THINGS

SGFIX:	PUSHJ	P,NXTSTR	;ANEXT LIST ELEMENT
	HLRZ	Q1,(A)		;Q1  NEXT DESCRIPTOR
	CAMG	T1,1(Q1)	;INCLUDED IN OR OVERLAPPING THIS STRING
	 JRST	 SGBLT		; NO, MOVE OLD BEFORE HANDLING NEW
	PUSHJ	P,FIXPTR	;FIX UP DESCRIPTOR
	CAMGE	T1,TEMP		;OVERLAPPING STRING
	 MOVE	 T1,TEMP	; YES, USE BIGGER END POINT
	JRST	SGFIX		;CONTINUE

SGBLT:	ADDI	Q2,1		;INCREMENT STRING NUMBER
	MOVN	B,T
	ADD	B,T1		;TOTAL STRING SIZE
	SKIPN	SGLIGN(USER)	;HAVE TO ALIGN TO FW BDRY?
	 JRST	 NOLIGN		; NO
	ADDI	B,4		;YES, DO IT
	IDIVI	B,5
	IMULI	B,5		;NOW MULT OF 5 CHARS, BIG ENOUGH
NOLIGN:
	ADDM	B,NUMCHR(USER)	;NUMBER USED SO FAR
	MOVE	C,T		;STARTING COUNT FOR STRING
	PUSHJ	P,MKBPT		;PICK UP FROM HERE
	MOVE	T,TOPBYTE(USER) ;PUT DOWN HERE
	JUMPE	B,SGBLT1	;DON'T DO IT IF NOT NECESSARY
BLTLUP:	ILDB	D,C
	IDPB	D,T		;WHEEE!
	SOJG	B,BLTLUP	;MOVE 'EM ON OUT
	MOVEM	T,TOPBYTE(USER)	;RESTORE IT

SGBLT1:	JUMPE	A,STSTAT	;LAST ONE
SGFX1:	MOVE	T,1(Q1)		;INITIALIZE START OF STRING,
	MOVE	T1,(Q1)		; END OF STRING,
	MOVE	E,T		; OFFSET FOR BP FIXUPS
	SUB	E,NUMCHR(USER)	; (THIS IS THE OFFSET)
	PUSHJ	P,FIXPTR	;FIX UP THIS DESCRIPTOR
	JRST	SGFIX		;CONTINUE

NXTSTR:	HRRZ	A,(A)		;A_CDR(A)
	JUMPN	A,APOPJ		; GOT ONE, DONE
FSTSTR:	AOS	A,Q3		;END OF THAT LIST, LOOK AT NEXT
	CAMGE	A,FF		;OOOPS, THERE ARE NO MORE!
	 JRST	 NXTSTR		; YES THERE ARE
	SUB	P,X11		;DON'T RETURN, BUT MARK DONE,
	MOVEI	A,0		; AND GO OFF FOR LAST 
	JRST	SGBLT		; NOSTALGIC MOVE

FIXPTR:	MOVE	TEMP,(Q1)
	SUB	TEMP,1(Q1)		;SIZE OF STRING FOR THIS DESCRIPTOR
	HRL	TEMP,Q2		;ADD STRING NUMBER
	EXCH	TEMP,(Q1)		;PUT FIRST WORD AWAY
	MOVE	C,1(Q1)		;START COUNT
	SUB	C,E		;ADJUST TO NEW LOCATION
	PUSHJ	P,MKBPT		;MAKE A BYTE POINTER
	MOVEM	C,1(Q1)		;THIS BABY IS READY TO FLY!
APOPJ:	POPJ	P,		;ALL DONE

; MKBPT TAKES A #CHARS IN C, MAKES A BYTE POINTER RELATIVE TO ST
; OUT OF IT, LEAVES IT IN C -- DESTROYS D

MKBPT:	IDIVI	C,5		;WORD # IN C, CHAR OFLOW IN D
	ADD	C,ST(USER)		;REAL WORD #
	HLL	C,[POINT 7,0
		   POINT 7,0,6
		   POINT 7,0,13
		   POINT 7,0,20
		   POINT 7,0,27](D)  ;POINTER PART
	POPJ	P,

; FINISH UP

STSTAT:	
	SKIPN	SGLIGN(USER)	;HAVE TO LINE UP TOPBYTE?
	 JRST	 NORCLR		;NO
	MOVE	C,T1		;END CHAR # OF LAST STRING
	SUB	C,E		;ADJUST BY THE WINNING OFFSET
	PUSHJ	P,MKBPT		;MAKE A BP FOR TO BE TOPBYTE
	MOVEM	C,TOPBYTE(USER)	;FOR THE RIDICULOUS, DEMANDING SAIL
	PUSHJ	P,RESCLR	;CLEAR REST OF STRING SPACE
NORCLR:	HRLOM	Q2,TOPSTR(USER)	;NEXT NEW STRING NUMBER
	AOS	SGCCNT(USER)
	MOVN	B,STMAX(USER)
	IMULI	B,5
	ADD	B,NUMCHR(USER)
	ADD	B,SGACS+A(USER)	;#CHARS WHICH CAUSED THIS MESS IN FIRST PLACE
	MOVEM	B,REMCHR(USER)
	JUMPGE	 B,[ERR (<STRING SPACE EXHAUSTED, WILL RESTART>,1)
		    JRST @JOBREN]  ;RE-ALLOCATE
	MOVE	B,STBUCK(USER)	;RELEASE IT
	PUSHJ	P,CORREL
	HRLZI	12,SGACS(USER)
	BLT	12,12
	POPJ	P,


COMMENT Sgins, Sgrem 

DSCR SGINS
CAL PUSHJ
PAR PUSH P,[routine name]
 PUSH P,[addr of 2-word block]
RES block is used to place routine in the list of descriptor generators
 for CALSG.
SID stack adjusted


^^SGINS:
	PUSH	P,-2(P)		;ADDR OF ROUTINE
	PUSHJ	P,SGREM		;NEVER LET IT BE IN TWICE
	MOVE	USER,GOGTAB
	POP	P,UUO1(USER)
	POP	P,LPSA		;LINK BLOCK FOR NEW ROUTINE
	POP	P,-1(LPSA)	;PUT ROUTINE ADDRESS AWAY
	HRL	LPSA,SGROUT(USER);GET OLD LINK POINTER
	HLRM	LPSA,(LPSA)	;PUT IN NEW LINK POSITION
	HRRM	LPSA,SGROUT(USER);PUT NEW POINTER IN LINK HEAD
	JRST	@3(P)		;RETURN

DSCR SGREM
CAL PUSHJ
PAR PUSH P,[routine addr]
RES routine is removed from list of descriptor generators, if it was on it


^^SGREM:
	MOVE	USER,GOGTAB
	POP	P,UUO1(USER)
	POP	P,TEMP		;ADDR TO BE REMOVED
	MOVEI	LPSA,SGROUT(USER);HEAD OF LIST
SGRL:	MOVE	USER,LPSA	;PREV_THIS
	SKIPN	LPSA,(USER)	;THIS_(PREV)
	 JRST	 @2(P)		;DIDN'T FIND IT
	CAME	TEMP,-1(LPSA)	;IS THIS THE ROUTINE?
	 JRST	 SGRL		;NO, GET NEXT
	HRRZ	TEMP,(LPSA)	;YES, REMOVE IT FROM LIST
	HRRM	TEMP,(USER)
	JRST	@2(P)


DSCR STCLER
CAL PUSHJ
RES Clears all string variables on STRLNK(USER) to null strings
DES compiler only


^STCLER:
	SKIPE	SGLIGN(USER)		;CLEAR REST?
	PUSHJ	P,RESCLR	;CLEAR REST OF STRING SPACE
	SKIPN	T,STRLNK(USER)	;PARALLELS STRNGC'S LOOP
	POPJ	P,		;CLOSELY
	PUSH	P,B		;JUST IN CASE
	HRLZI	B,-1		;FOR TESTING STRING NO.
STC1:	HRRZ	A,-1(T)
	HLRZ	Q2,-1(T)
STCLLP:	SOJL	Q2,STCLD1
	TDNE	B,(A)		;DON'T COLLECT STRING CONSTANTS
	SETZM	(A)
	ADDI	A,2
	JRST	STCLLP
STCLD1:	;SETZM	-2(T)		;***** CAN'T DO THIS UNLESS PATSW IS
				; *** ON IN COMPILER!!!!!
	HRRZ	T,(T)
	JUMPN	T,STC1
	POP	P,B
	POPJ	P,

DSCR RESCLR
CAL PUSHJ 
DES Used after STRNGC. Clears remaining string space to 0 (compiler only)

RESCLR:	SKIPL	A,TOPBYTE(USER)	;CAN ZERO FIRST WORD IF 440700
	ADDI	A,1		;ELSE START AT NEXT
	SETZM	(A)
	HRLS	A
	ADDI	A,1		;BLT WORD
	MOVE	B,STTOP(USER)	;END OF STRING SPACE
	BLT	A,-1(B)		;ZERO!!
	POPJ	P,

IFGE SAILRUN,<
INTERNAL BRKMSK
^BRKMSK:	0
	FOR @& JJ_=17,0,-1 <
	<1  (JJ+=18)> + (1  JJ)>
>
>;NOLOW
ENDCOM (SGC)
IFN ALWAYS,<
NOLOW <
	^CORGET_CORGET
>;NOLOW
>;IFN ALWAYS
SUBTTL	GOGOL
SUBTTL	Some Runtime Routines Which Could Go Nowhere Else

DSCR BEGIN GOGOL
DES RUN-TIME ROUTINES WILL BE DESCRIBED BY SAIL MANUAL CALLING SEQUENCES ONLY

NOLOW <
IFN ALWAYS,<BEGIN GOGOL>
>;NOLOW
COMPIL(KNT,<K.ZERO,K.OUT>,<GETCHAN,GOGTAB>
      ,<K.ZERO, K.OUT -- PERFORMANCE COUNTING ROUTINES>)
COMMENT  Kounter Routines
IFGE SAILRUN,<
DSCR K.ZERO -- Zero out counters
CAL PUSHJ  P,K.ZERO
RES The counter arrays of the sail program loaded are  set  to  zero.
K.ZERO  determines  the location of the counter blocks via the loader
link chain (5) whose head is in the location KNTLNK(USER).  If  there
are  no  counters,  the  routine  is  essentially  a  NO-OP.  SID All
registers used by K.ZERO are saved on entry and restored on exit. SEE
K.OUT


HERE(K.ZERO)
	PUSH	P,2		;SAVE REGISTER 2
	MOVE	USER,GOGTAB
	SKIPN	2,KNTLNK(USER)	;GET LINK TO COUNTERSS
	JRST	K.ZR2		;THERE ARE NONE
	PUSH	P,3		;SAVE OTHER REGS NEEDED
	PUSH	P,4
	PUSH	P,5
K.Z1:	MOVE	3,2(2)		;GET SECOND IOWD OF HEADER BLOCK
	MOVEI	4,2(3)		;GET <.KOUNT+1>
	HRLI	4,-1(4)		;GET READY FOR BLT
	HLRO	5,3		;GET -COUNT
	MOVN	5,5		;MAKE THAT +COUNT
	HRLI	5,3		;PUT AN INDEX FIELD OF 3
	SETZM	-1(4)		;ZERO THE FIRST COUNTER
	BLT	4,@5		;ZERO THE REST
	SKIPE	2,(2)		;GET THE NEXT SET OF COUNTERS
	JRST	K.Z1		;ZERO THEM
	POP	P,5		;RESTORE THE REGISTERS
	POP	P,4
	POP	P,3
K.ZR2:	POP	P,2
	POPJ	P,		;RETURN

DSCR K.OUT -- Write out counters
CAL PUSHJ P,K.OUT
RES The values of the statement counters are written out to the
 disk.  The IOWDs used to write them are also written out in
 order to be able to know how many to read back in.  The filename
 is obtained from the header block of the first program loaded.
 The data blocks have the following form:

		--------------------------
		|   SIXBIT /FILNAM/	 |
		--------------------------
		|   LINK to other blocks |
		--------------------------
		|   IOWD  1,.+1		 |
		--------------------------
		|   IOWD  n,.KOUNT	 |
		--------------------------
		|   0			 |
		--------------------------
    .KOUNT:	|   1st counter		 |
		--------------------------
		|   . . .		 |

		|   . . .		 |
		--------------------------
		|   nth counter		 |
		--------------------------

SID No registers are permanently modified.

HERE(K.OUT)
	MOVE	USER,GOGTAB
	SKIPN	KNTLNK(USER)	;ARE THERE ANY COUNTERS
	POPJ	P,		;NO


COMMENT		First save registers 0-16


	MOVEM	16,17(P)	;SAVE IN THE STACK
	MOVEI	16,1(P)		;GET READY TO STORE 0-15
	BLT	16,16(P)	;DO IT
	ADD	P,[XWD 17,17]	;ADJUST STACK POINTER
	TLNN	P,400000	;CHECK FOR OVERFLOW
	ERR	<PDL overflow in K.OUT routine>


COMMENT 	Before the counters can be written out, it
	is necessary to chain the blocks together in the
	proper direction.  Recall that there will be multiple
	blocks only if the core image is the result of loading
	multiple compilatons.


	MOVE	2,KNTLNK(USER)	;GET LINK TO LAST BLOCK
	SKIPN	1,(2)		;GET LINK TO PREV.
	JRST	.+5		;THAT'S ALL
	MOVEI	0,1(2)		;GET ADDR OF 1st IOWD OF THIS BLOCK
	MOVEM	0,3(1)		;STORE BELOW 2nd IOQS OF PREV BLOCK
	MOVE	2,1		;CONTINUE
	JRST	.-5


COMMENT 	At this point, 1(2) contains the start of a dump
	mode command chain that will write out all of the counters.
	-1(2) contains the filename for the counter file.


	PUSHJ	P,GETCHAN	;GET AN AVAILABLE CHANNEL
	JUMPL	1,K.OERR	;NONE AVAILABLE
	MOVE	0,[XWD K.OD1,3] ;MOVE CODE TO REGISTERS
	BLT	0,16		;SO THAT IT CAN BE SAFELY MODIFIED
	DPB	1,[POINT 4,3,12]  ;STORE CHANNEL NUMBER IN OPEN INSTR
	DPB	1,[POINT 4,5,12]  ;STORE CHANNEL NUMBER IN ENTER INSTR
	MOVE	10,-1(2)	;PICK UP FILE NAME
	JRST	3		;OPEN AND ENTER,HOPEFULLY RETURNING TO .+1
K.O1:	MOVE	0,[XWD K.OD2,3] ;DO IT AGAIN
	BLT	0,7
	DPB	1,[POINT 4,3,12]  ;OUT INSTRUCTION
	DPB	1,[POINT 4,6,12]  ;RELEAS INSTRUCTION
	JRST	3


COMMENT 	The counters have been written out to the disk.  It's
	time to restore the registers and go home.


K.O2:	MOVSI	16,-16(P)	;PREPARE TO RESTORE REGS 
	BLT	16,16		; FROM THE STACK
	SUB	P,[XWD 17,17]	;ADJUST STACK POINTER
	POPJ	P,		;RETURN

K.OERR:	IOERR	<I/O error in writing counter file>


COMMENT 	The following instructions are moved into 
	registers before they are executed, since the "channel"
	portion of them must be modified at run time.


K.OD1:	OPEN	0,14		;(3) OPEN DISK ON SPECIFIED CHANNEL
	JRST	K.OERR		;(4) TROUBLE
	ENTER	0,10		;(5)
	JRST	K.OERR		;(6) RIGHT HERE IN RIVER CITY
	JRST	K.O1		;(7) READY TO WRITE 'EM OUT
	0			;(10) FILLED IN WITH FILE NAME
	SIXBIT 	/KNT/		;(11) EXTENSION
	0			;(12)
	0			;(13)
	17			;(14) DUMP MODE
	SIXBIT	/DSK/		;(15) DEVICE DISK
	0			;(16) NO BUFFERS

K.OD2:	OUT	0,1(2)		;(3) WRITE OUT COUNTERS
	JRST	6		;(4) ALL OK
	JRST	K.OERR		;(5) PROBLEMS
	RELEAS	0		;(6) CLOSE FILE
	JRST	K.O2		;(7) GO BACK TO K.OUT



>;IFGE SAILRUN
ENDCOM (KNT)
COMPIL(POW,<FPOW,POW>,<SAVE,RESTR,X33>,<POW, FPOW -- EXPON. ROUTINES>)

DSCR BEGIN UTILS

IFN ALWAYS,<	BEGIN	UTILS>
COMMENT % EXPONENTIATION CODE
  POW(EXP,ARGUMENT) OR
 FPOW(EXP,ARGUMENT) DEPENDING  %


DSCR POW, FPOW, LOGS, FLOGS(EXPONENT,ARGUMENT);
CAL SAIL
DES CALLS GENERATED BY COMPILER FOR ^ OPERATOR


^^FPOW:	PUSHJ	P,SAVE
	JSP	B,SETEXP		;SET UP, SAVE ACS
	MOVSI	B,(1.0)		;SET FOR FLOATING
	JUMPE	A,EXZERO	;0 EXPONENT

FEXLUP:	TRNE	A,1		;COLLECT PRODUCT?
	FMPR	B,C		;YES
	ASH	A,-1		;PREPARE TO LOOK AT NEXT BIT
	JUMPE	A,EXDUN		;ALL DONE IF ZERO
	FMPR	C,C		;SQUARE BASE
	JRST	FEXLUP

^^POW:	PUSHJ	P,SAVE
	JSP	B,SETEXP
	MOVEI	B,1
	JUMPE	A,EXZERO

EXPLUP:	TRNE	A,1
	IMUL	B,C
	ASH	A,-1
	JUMPE	A,EXDUN
	IMUL	C,C
	JRST	EXPLUP

EXZERO:	SKIPN	C		;0^0
	ERR	<0^0 NOT DEFINED>
EXDUN:	MOVEM	B,RACS+1(USER)
	MOVEI	LPSA,0
	JRST	RESTR

;  SET UP FOR POWER ROUTINES

SETEXP:	POP	P,UUO1(USER)	;RETURN FROM (F)EXP
	POP	P,C		;OPERAND
	POP	P,A		;EXPONENT
	SKIPGE	A		;EXP 0?
	ERR	<NEGATIVE EXPONENT NOT IN -- YOU LOSE>
	JRST	(B)		;RETURN
ENDCOM (POW)

IFGE SAILRUN,<
NOLOW <
NOUP <
COMPIL(LOG,<LOGS,FLOGS>,<SAVE,RESTR,X33>,<LOGS & FLOGS FOR F4 LINKAGE>)

EXTERNAL EXP3.0	;FORTRAN MAGIC FOR REAL^REAL

^^LOGS:	PUSHJ	P,SAVE
	FLOAT	0,-1(P)
	MOVE	1,-2(P)	;EXPONENT
	PUSHJ	P,EXP3.0
	FIX
FORGO:	MOVEM	RACS+1(USER)
	MOVE	LPSA,X33
	JRST	RESTR


^^FLOGS: PUSHJ	P,SAVE
	MOVE	0,-1(P)
	MOVE	1,-2(P)
	PUSHJ	P,EXP3.0
	JRST	FORGO
ENDCOM (LOG)
>;NOUP
>;NOLOW			;...
>			;END OF IFE SAILRUN



COMPIL(COD,<CODE,CALL>,<.SKIP.,CVSIX,X22,GOGTAB,X33>,<CODE, CALL>)

DSCR VAL_CODE(OCTAL COMMAND, REFERENCE ARG);

Comment CODE
   Reference arg is added to octal command.  CODAC(USER)
   is placed in AC 1.  The constructed word is executed, and AC 1 resaved.
   Isn't that clever?  (AC1 is also returned as the value of the call)


IFGE SAILRUN, <
HERE (CODE)	MOVE	USER,GOGTAB
	SETOM	.SKIP.		;ASSUME IT SKIPS
	PUSH	P,0
	MOVE	1,CODAC(USER)		;GET USER'S AC
	MOVE	0,-3(P)
	ADDI	0,@-2(P)		;CALCULATE THE INSTR DO BE EXECUTED
	XCT	0			;DO IT
	SETZM	.SKIP.			;DIDN'T SKIP
	MOVEM	1,CODAC(USER)
	POP	P,0
	SUB	P,X33
	JRST	@3(P)


DSCR VALUE_CALL(VAL,"FUNCTION");
CAL SAIL


^^.CALL:
HERE (CALL)
	SETOM	.SKIP.		;ASSUME A SKIP
	PUSHJ	P,CVSIX		;PARSE SIXBIT
	MOVE	TEMP,A		;SIXBIT FOR WHAT'S WANTED
	MOVE	A,-1(P)		;INPUT VALUE
	CALL	A,TEMP
	SETZM	.SKIP.		;NO SKIP, RECORD IT
	SUB	P,X22		;RETURN VALUE IN 1, WANT IT OR NOT
	JRST	@2(P)

>
ENDCOM (COD)

IFN ALWAYS,<BEND UTILS>
SUBTTL	STRING HANDLING ROUTINES
                                                                                                                                                                                                                                                                                                                                                                                       J