00010      SUBROUTINE PUBL(PLIST,LPLIST)
00020 COMMON FV(3000)
00030 COMMON ITEM,OBJ,SBSNAM,LSBNAM,HISTRY(100),
00040 &           SPCALC,NOPRNT,FLUSH,ITMCHK,BRIEF,
00050 &           INPUT(21),LINPUT,FRSTSG,LASTSG,NXSTRT,
00060 &           EDITL(100),LEDITL,OVL,INDOVL,INDIR,
00070 &           CURRGO,LASTGO,CMND,CURCMP,ERRCNT,
00080 &           COMPL(100),LCOMPL,ACTVL(100),LACTVL,PRNTL(100),LPRNTL,
00090 &           NITEMS,MULTRE,EXIST(3),FSTITM,LSTITM,CLRITM,
00100 &           HASH(199),SONPTR(25),SONS(65),TREE(100),
00110 &           DICFIL,FMTFIL,ATRFIL,
00120 &           BUFITM,ITMLOC,ITMMOD,ITMDIM,ITMTYP,ITMIO,ITMOVL,
00130 &           ITMFMT,ITMMIN,ITMMAX,ITMNAM(7),LITNAM
00140      INTEGER OBJ,HISTRY,SPCALC,FLUSH,BRIEF,FRSTSG,EDITL,CURRGO,EXIST,
00150 &            CMND,CURCMP,ERRCNT,COMPL,ACTVL,PRNTL,FSTITM,CLRITM,HASH,
00160 &            SONPTR,SONS,TREE,BUFITM,ITMLOC,ITMDIM,TYPE,OVLNO,FMTPTR
00170      REAL ITMMIN,ITMMAX
00180      ASCII INPUT,ITMNAM
00190      FILENAME SBSNAM,OVL,INDOVL,DICFIL,FMTFIL,ATRFIL
00200 *
00210 *    FROM RUNCOMDS
00220 *
00230 * PRINTS THE CURRENT VALUES OF A LIST OF ITEMS, WHERE --
00240 *       PLIST IS A VECTOR OF LENGTH LPLIST CONTAINING
00250 *       THE ITEM NOS. OF THE ITEMS WHOSE VALUES ARE TO
00260 *       BE PRINTED
00270 *
00280      INTEGER PLIST(LPLIST),FMT(93),DI,ENDCOM,CHAR,VARYNG
00290      ASCII RFMT(2),IFMT(2),AMPER,BLANK
00295      LOGICAL TSTBIT
00300 *
00310 * DEFAULT FORMATS FOR INTEGER AND REAL ITEMS
00320 *
00330      DATA RFMT/"(6F1","2.2)"/,LRFMT/8/
00340      DATA IFMT/"(1X,","9I8)"/,LIFMT/8/
00350      DATA AMPER,BLANK/"&   ","    "/
00360      DATA CHAR,VARYNG/3,64/
00370      DATA N0,N1,N3,N4,N28,N31,N32,N60,N64/0,1,3,4,28,31,32,60,64/
00380 *
00390 * IF NOTHING TO PRINT, RETURN
00400 *
00410      IF(LPLIST.LE.N0)RETURN
00420      DO 110 I=N1,LPLIST
00430 *
00440 * READ ATTRIBUTES OF CURRENT ITEM INTO COMMON
00450 *
00460      CALL FILE(PLIST(I))
00470 *
00480 * DI WILL WIND UP BEING THE NUMBER OF THINGS TO BE PRINTED --
00490 *     IN WORDS FOR INTEGER AND REAL ITEMS
00500 *     IN CHARACTERS FOR CHARACTER ITEMS
00510 *
00520      DI=ITMDIM
00530 *
00540 * CHECK WHETHER CURRENT ITEM HAS THE VARYING ATTRIBUTE
00550 *
00560      IF(.NOT.TSTBIT(ITMIO,VARYNG))GOTO 20
00580 *
00590 * CURRENT ITEM HAS VARYING ATTRIBUTE -- PICK UP ITS CURRENT LENGTH
00600 * FROM THE LAST WORD IN ITS COMMON ALLOCATION
00610 *
00620 * CONSTRUCT POINTER TO LAST WORD IN COMMON ALLOCATION USING
00630 * FACT THAT DI IS IN CHARACTERS FOR CHARACTER ITEMS AND IN
00640 * WORDS FOR INTEGER AND REAL ITEMS
00650 *
00660 10   IF(ITMMOD-CHAR)12,14,12
00670 12   IS1=ITMLOC+DI
00680      GOTO 16
00690 14   IS1=ITMLOC+(DI+N3)/N4
00700 16   CALL MOVE(FV(IS1),N1,DI,N1,N4)
00710 *
00720 * CHECK FOR SPECIAL FORMAT
00730 *
00740 20   IF(ITMFMT)70,30,70
00750 *
00760 ***** NO SPECIAL FORMAT
00770 *
00780 * PRINT ITEM'S NAME
00790 *
00800 30   CALL STRPRINT(BLANK,ITMNAM,N1,LITNAM,N28)
00810 *
00820 * FOR INTEGER AND REAL ITEMS, MOVE DEFAULT FORMAT INTO FORMAT
00830 *     VECTOR FMT
00840 * FOR CHARACTER ITEMS, USE STRPRINT TO PRINT THE ITEM'S CURRENT VALUE
00850 *
00860      GOTO(40,50,60),ITMMOD
00870 40   CALL MOVE(RFMT,N1,FMT,N1,LRFMT)
00880      GOTO 100
00890 50   CALL MOVE(IFMT,N1,FMT,N1,LIFMT)
00900      GOTO 100
00910 60   PRINT 61
00920 61   FORMAT(9X)
00930      CALL STRPRINT(AMPER,FV(ITMLOC),N1,DI,N60)
00940      GOTO 110
00950 *
00960 ***** SPECIAL FORMAT
00970 *
00980 * READ FORMAT FROM FORMAT FILE INTO FORMAT VECTOR FMT
00990 *
01000 * 32ND WORD OF EACH RECORD IS POINTER TO NEXT RECORD OR
01010 *     ZERO IF THIS IS LAST RECORD
01020 *
01030 70   KREC=ITMFMT
01040      KF=N1
01050 80   CALL #UREAD#(FMTFIL,KREC,FMT(KF),N32)
01060      KF=KF+N31
01070      IF(FMT(KF))90,100,90
01080 90   KREC=FMT(KF)
01090      GOTO 80
01100 *
01110 *****
01120 *
01130 * EVERYTHING BUT CHARACTER ITEMS WITHOUT SPECIAL FORMAT IS
01140 * PRINTED HERE
01150 *
01160 * CONSTRUCT ENDING INDEX FOR IMPLIED DO AND PRINT
01170 *
01180 100  ENDCOM=ITMLOC+DI-N1
01190      IF(ITMMOD.EQ.CHAR)ENDCOM=ITMLOC+(DI+N3)/N4-N1
01200      PRINT FMT,(FV(IS1),IS1=ITMLOC,ENDCOM)
01210 110  CONTINUE
01220 *
01230 * NULL OUT LIST OF THINGS TO BE PRINTED AND RETURN
01240 *
01250      LPLIST=N0
01260      RETURN
01270      END
00010      FUNCTION HLOOK(S,MS,LS,HASH,LHASH)
00020 *
00030 * FUNCTION TO MATCH A STRING AS AN ITEM NAME OR SYSTEM COMMAND
00040 * NAME -- WHERE
00050 *   S,MS,LS = INPUT STRING TO BE MATCHED
00060 *      HASH = IN-CORE HASH TABLE
00070 *     LHASH = SIZE OF HASH TABLE
00080 *
00090 * EACH ITEM OR SYSTEM COMMAND NAME HAS AN ENTRY IN THE HASH TABLE
00100 * WHOSE MAGNITUDE HAS THE FORM 2**28*N+I WHERE:
00110 *    N = THE NUMBER OF THE ITEM OR SYSTEM COMMAND
00120 *    I = A VIRTUAL INDEX TO BE COMPARED WITH THAT GENERATED BY
00130 *        HASHING THE INPUT STRING.  IF THE INDEX OF AN ENTRY IN THE
00140 *        CHAIN OF THE TABLE INTO WHICH THE INPUT STRING HASHES IS
00150 *        EQUAL TO THE INDEX COMPUTED FOR THE INPUT STRING, THE INPUT
00160 *        STRING IS CONSIDERED TO BE EQUAL TO THAT STRING WHICH
00170 *        GENERATED THE HASH TABLE ENTRY AT SETUP TIME AND A 
00180 C        MATCH OCCURS.
00190 * NEGATIVE ENTRIES REPRESENT SYSTEM COMMAND NAMES, POSITIVE ENTRIES
00200 * REPRESENT ITEM NAMES
00210 *
00220 * THE FUNCTION RETURNS N IF THE STRING IS AN ITEM NAME,
00230 * -N IF THE STRING IS A SYSTEM COMMAND NAME AND 0 IF THE
00240 * STRING HAS NO CORRESPONDING ENTRY IN THE HASH TABLE
00250 *
00260      INTEGER HLOOK,HASH(LHASH)
00270      ASCII S(20),T(20),BLANK
00280      DATA N0,N1,N2,N3,N4/0,1,2,3,4/
00290      DATA N2T28,N2T29,N2T34/268435456,536870912,17179869184/
00300      DATA N2T35/O400000000000/
00310      DATA BLANK/" "/
00320      L=LS-MS+N1
00330      NW=(L+N3)/N4
00340      T(NW)=BLANK
00350      CALL MOVE(S,MS,T,N1,L)
00360      INDEX=N0
00370      DO 3 I=N1,NW
00380 3    CALL EOR(N2*MOD(INDEX,N2T34)+INDEX/N2T35,T(I),INDEX)
00390 *
00400 * THIS LEFT END AROUD SHIFTS INDEX BEFORE EOR'ING IT, SO THAT
00410 * PATTERNS CAN'T CAUSE CANCELLING, AND SO THAT ALL BITS DO 
00420 * INDEED ENTER INTO THE CALCULATION OF THE VIRTUAL INDEX
00430 *
00440      LOCN=MOD(INDEX,LHASH)+N1
00450      INDEX=MOD(INDEX/LHASH+LOCN,N2T29)
00460 4    HLOOK=HASH(LOCN)/N2T28
00470      IX=MOD(IABS(HASH(LOCN)),N2T28)
00480      IF(HLOOK.EQ.N0.OR.INDEX.EQ.IX)RETURN
00490      LOCN=MOD(LOCN,LHASH)+N1
00500      GOTO4
00510      END
00520 *
00530 ********************
00540 *
00550      FUNCTION TSTBIT(WORD,BITMSK)
00560 *
00570 * FUNCTION TO FIND OUT WHETHER A WORD HAS A CERTAIN SET OF
00580 * BITS SET ON -- WHERE
00590 *    WORD = WORD TO BE TESTED
00600 *  BITMSK = MASK WORD CONTAINING THOSE BITS WISHED TESTED SET ON
00610 *
00620 * FUNCTION RETURNS TRUE IF ALL BITS ON IN BITMSK ARE ALSO ON
00630 * IN WORD, FALSE OTHERWISE
00640 *
00650      INTEGER WORD,BITMSK
00660      LOGICAL TSTBIT
00670      CALL AND(WORD,BITMSK,I)
00680      TSTBIT=I.EQ.BITMSK
00690      RETURN
00700      END
00710 *
00720 ********************
00730 *
00740      SUBROUTINE SETHST(ITEMNO,HISTRY,ERRCNT)
00750 *
00760 * SUBROUTINE TO SET AN ITEM'S HISTORY VALUE UPON SUCCESSFUL
00770 * RECOGNITION -- WHERE
00780 *  ITEMNO = NUMBER OF THE ITEM RECOGNIZED
00790 *  HISTRY = AN ARRAY OF HISTORY VALUES SUCH THAT:
00800 *     IABS(HISTRY(I)) = 0 ==> ITEM I IS CURRENTLY INACTIVE
00810 *                     = 1 ==> ITEM I WAS AN ORIGINAL ENTRY
00820 *                     = 2 ==> ITEM I HAS BEEN ASSUMED
00830 *                     = 3 ==> ITEM I HAS BEEN EDITED
00840 *                     = 4 ==> ITEM I HAS BEEN COMPUTED
00850 *                     = 5 --- NOT USED
00860 *                     = 6 ==> ITEM I WAS THE OBJECT OF A GO
00870 *                     >= 1000 ==> ITEM I WAS INCORRECTLY ENTERED
00880 *     AND HISTRY(I) < 0 ==> WHATEVER CONDITION IS INDICATED BY
00890 *                           THE MAGNITUDE (SEE ABOVE) HAS BEEN
00900 *                           ESTABLISHED SINCE THE LAST 
00910 *                           SUCCESSFUL GO
00920 *                   > 0 ==> WHATEVER CONDITION IS INDICATED BY THE
00930 *                           MAGNITUDE (SEE ABOVE) WAS ESTABLISHED
00940 *                           SOMETIME BEFORE THE LAST SUCCESSFUL GO
00950 *  ERRCNT = THE NUMBER OF ITEMS WHOSE HISTORY VALUES HAVE
00960 *           MAGNITUDES >= 1000 (SEE ABOVE)
00970 *
00980      INTEGER HISTRY(100),ERRCNT
00990      DATA N0,N1,N1000,M1,M3/0,1,1000,-1,-3/
01000      IHIST=HISTRY(ITEMNO)
01010      IF(IABS(IHIST).GE.N1000)ERRCNT=ERRCNT-N1
01020      IHIST=MOD(IHIST,N1000)
01030      HISTRY(ITEMNO)=M3
01040      IF(IHIST.EQ.N0)HISTRY(ITEMNO)=M1
01050      RETURN
01060      END
01070 *
01080 ********************
01090 *
01100      SUBROUTINE SETERR(ITEMNO,HISTRY,ERRCNT)
01110 *
01120 * SUBROUTINE TO SET AN ITEM'S HISTORY VALUE UPON FAILURE TO
01130 * ACCEPT ITS ENTRY -- WHERE ITEMNO, HISTRY AND ERRCNT ARE AS
01140 * IN SETHST
01150 *
01160      INTEGER HISTRY(100),ERRCNT
01170      DATA N1,N1000/1,1000/
01180      IHIST=HISTRY(ITEMNO)
01190      IF(IABS(IHIST).GE.N1000)GOTO 10
01200      ERRCNT=ERRCNT+N1
01210      HISTRY(ITEMNO)=IHIST+ISIGN(N1000,IHIST)
01220 10   RETURN
01230      END
01240 *
01250 ********************
01260 *
01270      SUBROUTINE SHLIST(ITEMNO,LIST,LLIST,TYPE,HISTRY)
01280 *
01290 * SUBROUTINE TO SHORTEN A LIST OF ACTIVE ITEMS
01300 * WHERE --
01310 *     ITEMNO = THE NUMBER OF AN ITEM TO BE FOUND ON THE LIST.
01320 *       LIST = AN ARRAY CONTAINING THE LIST TO BE SHORTENED
01330 *      LLIST = THE CURRENT LENGTH OF THE LIST (WILL BE ADJUSTED
01340 *       TYPE = A FLAG TO TELL WHETHER OR NOT TO INCLUDE ITEMNO ON
01350 *              THE RESULTING LIST.  IF TYPE = 0, THE LIST IS TO BE
01360 C              TRUNCATED TO CONTAIN ONLY THOSE ENTRIES PRECEEDING
01370 *              ITEMNO.  IF TYPE = 1, THE LIST WILL BE TRUNCATED TO
01380 *              INCLUDE ITEMNO AS ITS LAST ENTRY.
01390 *              BY THIS ROUTINE)
01400 *     HISTRY = AN ARRAY OF HISTORY VALUES. IF TRUNCATION OF
01410 *              THE LIST RESULTS IN DELETING AN ENTRY WHOSE VALUE
01420 *              IS I, THEN HISTRY(I) WILL BE SET TO 0 TO REFLECT
01430 *              THE FACT THAT ITEM I IS NO LONGER ACTIVE
01440 *
01450      INTEGER LIST(LLIST),TYPE,HISTRY(100)
01460      DATA N0,N1/0,1/
01470      DO 10 I=N1,LLIST
01480      IF(LIST(I).EQ.ITEMNO)GOTO 20
01490 10   CONTINUE
01500      GOTO 40
01510 20   J=I+TYPE
01520      IF(J.GT.LLIST)GOTO 40
01530      DO 30 I=J,LLIST
01540      IS1=LIST(I)
01550 30   HISTRY(IS1)=N0
01560      LLIST=J-N1
01570 40   RETURN
01580      END
  