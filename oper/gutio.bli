MODULE INOUT (RESERVE(0,1,2,3),SREG=#17,FREG=#16,VREG=#15,BREG=#14,DREGS=4)=
BEGIN
!***COPYRIGHT 1973, DIGITAL EQUIPMENT CORP., MAYNARD, MASS.***
!AUTHOR: F.J. INFANTE
GLOBAL BIND INOUV=24;	!21-AUG-72

REGISTER T1=1,T2=2,T3=3,C=3;
BIND	FLGREG=0<0,36>;

MACRO	TBLMAX=3$,
	TBLSIZ=10$;
STRUCTURE
	MATRIX[I,J]=[I*J](.MATRIX+(.I-1)*TBLSIZ+.J);
EXTERNAL	MATRIX CHNLTBL[TBLMAX,TBLSIZ];
MACRO	PHONEYBIN=1$,
	PHONEYLST=2$,
	PHONEYSRC=3$,
	EOL=#777777$;
BIND	BIN=#17,LST=#16,SRC=#15;
MACRO	STATUS(I)=CHNLTBL[I,0]$,
	DEVICE(I)=CHNLTBL[I,1]$,
	BUFFERS(I)=CHNLTBL[I,2]$,
	BUFHDR(I)=CHNLTBL[I,3]$,
	BUFPNT(I)=CHNLTBL[I,4]$,
	BUFCNT(I)=CHNLTBL[I,5]$,
	FILENAME(I)=CHNLTBL[I,6]$,
		EXTENSION(I)=CHNLTBL[I,7]<18,18>$,
		DSKERR(I)=CHNLTBL[I,7]<0,18>$,
		PROT(I)=CHNLTBL[I,8]<27,9>$,
	DIRECTORY(I)=CHNLTBL[I,9]$;
MACRO	FOUNDFLG=	35,1$,	FIRSTSTA=	17,1$,
	BIT1=	34,1$,	ENDFILE=	16,1$,
	BIT2=	33,1$,	WILDLSTFIL=	15,1$,
	BIT3=	32,1$,	INIOLIST=	14,1$,
	BIT4=	31,1$,	OBJECT=	13,1$,
	BIT5=	30,1$,	WILDOBJFIL=	12,1$,
	BIT6=	29,1$,	KI10=	11,1$,
	BIT7=	28,1$,	LISTING=	10,1$,
	BIT8=	27,1$,	TAPEND=	9,1$,
	BIT9=	26,1$,	WIND=	8,1$,
	BIT10=	25,1$,	ZERO=	7,1$,
	BIT11=	24,1$,	CROSSREF=	6,1$,
	BIT12=	23,1$,	DEBUG=	5,1$,
	SYNONLY=	22,1$,	EXPAND=	4,1$,
	ERRSW=	21,1$,	INCLUDE=	3,1$,
	EOP=	20,1$,	MACROCODE=	2,1$,
	RELFLG=	19,1$,	NOERRORS=	1,1$,
	FELFLG=	18,1$,	OPTIMIZE=	0,1$;
BIND	BMODE=	#14,AMODE=	0,
	BINARYOUTP=	1^18+1^BMODE,
	ASCIIOUTP=	1^18+1^AMODE,
	ASCIIINP=	1^19+1^AMODE;
EXTERNAL	FLGWRD;
MACRO	ADVANCEN=	30,6$,
	BACKSPACEN=	24,6$,
	FULL=		0,36$;
%(-----------------------------------------------------------------------------------------------------------------

;THE COMPONENTS OF THE MODIFIED BNF SYNTAX USED IN THE PRODUCTIONS ON THE FOLLOWING PAGE .

BNFDEFINITION      = METASYMBOL "="  BNFCOMPONENT  [ COMMENT ] "." .

BNFCOMPONENT       = ( TERMINAL l
                     METASYMBOL l
                     OR l
                     AND l
                     OPTION l
                     LIST l
                     REPEAT ) .

TERMINAL           = """ *ASCIICHARACTER """ ;TERMINAL CHARACTER STRING .

METASYMBOL         = [ *LETTER  "-" ] *LETTER  ;AN ELEMENT
                     OF THE SYNTAX DEFINED BY THE SYNTAX OR BY A LEXICAL
                     PROCESS .

OR                 = "(" BNFCOMPONENT *[ "l" BNFCOMPONENT ] ")" 
                     ;ONLY ONE OF THE BNFCOMPONENTS IS REQUIRED .

AND                = BNFCOMPONENT *[ BNFCOMPONENT ] ;ALL OF THE
                     BNFCOMPONENTS ARE REQUIRED .

OPTION             = "[" BNFCOMPONENT "]" ;USE OF THE BNFCOMPONENT IS
                     OPTIONAL .

LIST               = "+" BNFCOMPONENT ;BNFCOMPONENTS SEPERATED BY
                     COMMAS .

REPEAT             = [ REPEATCOUNT ] "*" BNFCOMPONENT ;BNFCOMPONENTS NOT SEPERATED BY
                     COMMAS, REPEATCOUNT WHEN PRESENT REQUIRES 1 <= N <= REPEATCOUNT BNFCOMPONENTS .

COMMENT            = ";" *ASCIICHARACTER .
;THE SYNTAX OF THE COMPILER'S COMMAND STRING IN MODIFIED BNF.

COMMANDSTRING	= [ OBJECTSPEC ] "," [ LISTINGSPEC ]  ( "=" \ "_" ) +SOURCESPEC .

OBJECTSPEC	= [ BINARYOUTDEV ":" ] FILESPEC ;DSK: - .REL<STANDARD>[ YOUR,JOB ] ASSUMED .

LISTINGSPEC	= [ ASCIIOUTDEV ":" ] FILESPEC ;DSK: - .LST<STANDARD>[ YOUR,JOB ] ASSUMED .

SOURCESPEC	= [ ASCIIINDEV ":" ] FILESPEC ;DSK: - ( .F4 \ - )<STANDARD>[ YOUR,JOB ] ASSUMED .

FILESPEC	= FILENAME [ "." EXTENSION ] [ PROTECTION ] [ DIRECTORY ] [ SWITCH ] .

SWITCH          = "/" SWITCHNAME [ ":" VALUE ]  \ "(" +( SWITCHNAME [ ":" VALUE ] ")" .

FILENAME	= ( "*" \ ASCIICHAR 5*[ ASCIICHAR ] ) ;EXTRA CHARACTERS IGNORED .

EXTENSION	= ( "*" \ ASCIICHAR 2*[ ASCIICHAR ] ) ;EXTRA CHARACTERS IGNORED .

PROTECTION	= "<" USER-PROTECTIONCODE PROJECT-PROTECTIONCODE OTHER-PROTECTIONCODE ">" .

DIRECTORY       = "[" PROJECT "," PROGRAMMER "]" .

PROJECT		= OCTALDIGIT 5*[ OCTALDIGIT ] ;7 OR MORE DIGITS=ERROR .

PROGRAMMER	= OCTALDIGIT 5*[ OCTALDIGIT ] ;7 OR MORE DIGITS=ERROR .

SWITCHNAME	= "A" \ "ADVANCE" \ "B" \ "BACKSPACE" \ "C" \ "CROSSREF" \ "D" \ "DEBUG" \ 
		  "E" \ "EXPAND" \ "I" \ "INCLUDE" \ "M" \ "MACROCODE" \ "N" \ "NOERRORS" \ 
		  "O" \ "OPTIMIZE" \ "T" \ "TAPEND" \ "W" \ "WIND" \ "Z" \ "ZERO" .

VALUE		= DECIMALDIGIT *[ DECIMALDIGIT ] .

BINARYOUTDEV	= "CDP" \ "MTA" \ "PTP" \ "PLT" \ "DTA" \ "DSK" \ "FHA" \ "DPA" .

ASCIIOUTDEV	= "CDP" \ "CTY" \ "LPT" \ "MTA" \ "PTP" \ "PLT" \ "PTY" \ "TTY" \ "DTA" \ "DSK" \ "FHA" \ "DPA" .

ASCIIINDEV	= "CDR" \ "CTY" \ "MTA" \ "PTR" \ "PTY" \ "TTY" \ "DTA" \ "DSK" \ "FHA" \ "DPA" .


SWITCH		ABBR.	VALUE	MEANING				RESTRICTION*
------		-----	-----	-------				------------

ADVANCE		/A:N	  N	ADVANCE MTA PAST N END-OF-FILE	MTA ONLY
				MARKS. /A=/A:1

BACKSPACE	/B:N	  N	BACKUP MTA UNTIL THE NTH
				END-OF-FILE MARK. /B=/B:1	MTA ONLY

CROSSREF	/C:N	0,1,2,3	ADD SEQUENTIAL LINE NUMBERS	LISTING MUST
				TO THE LISTING AND A TABLE	BE SPECIFIED
				SHOWING THE LINES IN WHICH
				EACH IDENTIFIER (/C:1),LABEL
				(/C:2), AND TYPE OF STATEMENT
				(/C:3) OCCURED. /C=/C:1.

DEBUG		/D:N	0,1	COMPILE LINKS TO A FORTRAN
				LEVEL DEBUGGING PROGRAM AT
				EACH STATEMENT LABEL (/D:1).
				/D=/D:1.

EXPAND		/E:N	0,1	ADD THE OBJECT FILE OUTPUT TO	LISTING MUST
				THE LISTING (/E:1). /E=/E:1.	BE SPECIFIED

INCLUDE		/I:N	0,1	COMPILE STATEMENTS WITH THE
				COMMENT CHARACTER D IN COLUMN
				1 AS IF THE D WERE A SPACE
				(/I:1). /I=/I:1.

MACROCODE	/M:N	0,1	ADD THE MACHINE LANGUAGE TRANS-	LISTING MUST
				LATION OF EACH FORTRAN STATE-	BE SPECIFIED
				MENT TO THE LISTING (/M:1).
				/M=/M:1

NOERRORS	/N:N	0,1	DO NOT OUTPUT ERRORS ON THE
				TELETYPE (/N:1). /N=/N:1.

OPTIMIZE	/OPT:N	0,1	PERFORM GLOBAL AS WELL AS LOCAL
				OPTIMIZATION ON THE CODE
				PRODUCED (/O:1). /O=/O:1.

TAPEND		/T:N	0,1	ADVANCE THE MTA TO THE		MTA ONLY
				LOGICAL-END-OF-TAPE (/T:1).
				/T=/T:1.

WIND		/W:N	0,1	REWIND THE MTA OR DTA TO THE	MTA OR DTA
				LOAD POINT (/W:1). /W=/W:1.	ONLY

ZERO		/Z:N	0,1	CLEAR THE DTA DIRECTION (\Z:1).
				DTA ONLY \Z=/Z:1.

*NO SWITCH ACTION WILL OCCUR IF A SWITCH RESTRICTION IS NOT MET.

NOTE:	A SWITCH WITH A VALUE OF ZERO CAUSES ITS ACTION TO CEASE BEFORE PROCESSING THE CURRENT FILE AND
	DOESN'T RESUME ITS ACTION UNTIL SPECIFICALLY GIVEN A NON-ZERO VALUE.  ALL SWITCHES ARE ASSUMED
	TO HAVE THE VALUE 0 INITIALLY.
EXAMPLE:

ASSUMING THE FILE "MAIN.F4" EXISTS ON YOUR DISK AREA [11,45] AND
FILES "SUB1", "SUB2.NEW", AND SUB3.NEW" EXIST ON THE DECTAPE YOU HAVE
MOUNTED ON DRIVE 2, THE COMMAND STRING:
,*_MAIN,DTA2:SUB1,*.NEW/N
IS EQUIVALENT TO THE EXPANDED COMMAND STRING:

,DSK:MAIN.LST<055>[11,45]=DSK:MAIN.F4[11,45]
,DSK:SUB1.LST<055>[11,45]=DTA2:SUB1.
,DSK:SUB2.LST<055>[11,45]/NOERRORS:1=DTA1:SUB2.NEW
,DSK:SUB3.LST<055>[11,45]/NOERRORS:1=DTA2:SUB3.NEW

-----------------------------------------------------------------------------------------------------------------)%
EXTERNAL JOBREL,JOBSA,JOBFF;
EXTERNAL CCLSW,INDEX;
EXTERNAL	JOBFFSAVE;

MACRO SKIP(OP)=
BEGIN
	VREG_1;
	OP;
	VREG_0;
	.VREG
END$,
	NOSKIP(OP)=
BEGIN
	VREG_0;
	OP;
	VREG_1;
	.VREG
END$;

MACRO	E1=1$,E2=2$,E3=3$,E4=4$,E5=5$,E6=6$,E7=7$,E8=8$,E9=9$,E10=10$,E11=11$,E12=12$,E13=13$,E14=14$,E15=15$,
	E16=16$,E17=17$,E18=18$,E19=19$,E20=20$,E21=21$,E22=22$,E23=23$,E24=24$,E25=25$,E26=26$,E27=27$,E28=28$,
	E29=29$,E30=30$;


%(-----------------------------------------------------------------------------------------------------------------

GLOBAL ROUTINE INCHWL=		INPUT THE NEXT CHARACTER FROM THE TELETYPE. RETURNS THE CHARACTER IN
				REGISTER C AND AS ITS VALUE.

GLOBAL ROUTINE OUTSTR(STR)=	OUTPUT TO THE TELETYPE THE ASCIZ STRING POINTED TO BY STR OR CRLF IF
			 	STR IS ZERO. OUTSTR(PLIT'ASCIZ=STRING ENDING WITH ASCII NULL?M?J?0')

ROUTINE ERROR(N,CHNL)=		TYPE ERROR NUMBER N USING CHNL TO SPECIFY WHICH FIELD,
			 	DEVICE, FILE, OR PROJECT PROGRAMMER NUMBER TO TYPE.
				RETURNS TO JOB STARTING ADDRESS (.JOBSA) SO THAT
				ANOTHER COMMAND STRING MAY BE TYPED. CALLED BY I/O ROUTINES TO
				TYPE FATAL I/O ERRORS ONLY.

GLOBAL ROUTINE READ=		RETURNS NEXT CHARACTER FROM SOURCE IN REGISTER C AND AS ITS VALUE,
				IF AN END-OF-FILE OCCURS THEN A -1 IS RETURNED IN REGISTER C AND AS ITS VALUE,
				IF ANY OTHER ERROR CONDITION OCCURS THE ERROR ROUTINE IS CALLED
				TO TYPE OUT THE APPROPRIATE ERROR MESSAGE. SETS THE BLANK WORD FLAG
				IF THE CURRENT WORD BEING INPUT CONTAINS 5 ASCII SPACES.

GLOBAL ROUTINE LSTOUT=		OUTPUTS THE CONTENTS OF REGISTER C AS THE NEXT LISTING CHARACTER.
				THE ERROR ROUTINE IS CALLED IF AN ERROR OCCURS.

GLOBAL ROUTINE RELOUT=		OUTPUTS THE CONTENTS OF REGISTER C AS THE NEXT WORD OF THE
				OBJECT FILE. THE ERROR ROUTINE IS CALLED IF AN ERROR OCCURS.

GLOBAL ROUTINE ERROUT(ARGS)=	CALLED WITH A VARIABLE NUMBER OF ARGUMENTS. THE FIRST ARGUMENT (ALWAYS PRESENT)
				IS THE COMPILER ERROR NUMBER, ADDITIONAL ARGUMENTS MAY BE DECIMAL VALUES
				AND/OR POINTERS TO ASCIZ STRINGS DEPENDING ON THE ERROR. RETURNS -1 AS ITS VALUE.

ROUTINE DEVCANDO(CHNL,MASK)=	TRUE (1) IF THE DEVICE CHARACTERISTICS MATCH THE
				MASK OR FALSE (0) IF THEY DON'T MATCH OF FALSE (2)
				IF THE DEVICE WAS NOT FOUND OR INITED.

ROUTINE SWAPP=			DEFINES THE SWITCH "LIST" IF ANY OF THE SWITCHES "CROSSREF", "EXPAND",
				OR "MACROCODE" APPEARED IN THE CURRENT FILE SPEC. PERFORMS THE ACTIONS SPECIFIED
				BY SWITCHES "ZERO", "TAPE", "WIND", "ADVANCE", OR "BACKSPACE"
				IF ANY WERE SPECIFIED IN THE CURRENT FILE SPEC.
				RESETS EACH ACTION SWITCH TO 0 AFTER PERFORMING THE ACTION.

ROUTINE ALLOUT=			CALLED BY THE SCAN MODULE TO ALLOCATE SPACE FOR AN OUTPUT FILE SPEC.
				STORES THE CURRENT STATE OF THE SWITCHES AT THE END OF THE FILE SPEC BEFORE
				RESETING THEM TO 0.

ROUTINE ALLIN=			SAME AS ALLOUT BUT FOR INPUT FILE SPEC.

GLOBAL ROUTINE INIT=		USES THE SCAN MODULE TO OBTAIN A COMMAND STRING. THEN USING
				THE WILD MODULE THE BINARY AND LISTING FILES IF SPECIFIED
				ARE OPENED AND ENTERED AND THE SOURCE FILE IS OPENED AND LOOKED UP.
				INIT MUST BE CALLED PRIOR TO USING THE RELOUT,LSTOUT, AND READ ROUTINES.
				IF THE INOUT MODULE IS LOADED LAST THIS WILL BE TAKEN CARE OF BY THE MODULE BODY.

GLOBAL ROUTINE NXTFIL=		USES THE WILD MODULE TO OPEN AND LOOKUP THE NEXT SOURCE FILE. RETURNS -1 IF
				AN ERROR OCCURED OR NO MORE SOURCE FILES WERE SPECIFIED.


-----------------------------------------------------------------------------------------------------------------)%
GLOBAL ROUTINE OUTMSG(MSG)=
%(-----------------------------------------------------------------------------------------------------------------
	THIS ROUTINE IS CALLED BY SPECIFYING A CHANNEL NUMBER AND A SERIES
	OF STRINGS ENCLOSED IN QUOTES. THE ROUTINE DETERMINES THE NUMBER
	OF SUCH STRINGS AND WRITES THE ENTIRE SET TO THE LISTING CHANNEL.
---------------------------------------------------------------------------------------------------------------)%
BEGIN
	EXTERNAL LSTOUT;
	LOCAL N,P;
	N_IF .(@(MSG+1))<27,9> NEQ #274 THEN 0
		ELSE .(@@(MSG+1))<0,18>;
	P_(MSG-(.N-1))<0,7>;
	INCR I FROM 1 TO (.N-1)*5 DO
		IF (C_SCANI(P)) EQL 0 THEN RETURN
			ELSE LSTOUT();
END;

GLOBAL ROUTINE INCHWL =(MACHOP TTCALL=#051;TTCALL(4,C);.C);
GLOBAL ROUTINE OUTSTR (STR) =
BEGIN
	MACHOP	TTCALL=#051;
	IF .STR EQL 0 THEN TTCALL(3,PLIT'?M?J')
	ELSE TTCALL (3,STR,0,1);
	.VREG
END;
GLOBAL ROUTINE ERROR (N,CHNL) =
BEGIN
	BIND	DEVMODE=PLIT(PLIT('BINARY OUTPUT'),PLIT('ASCII OUTPUT'),PLIT('ASCII INPUT'))-1;
	BIND	FIELD=PLIT(PLIT('OBJECT'),PLIT('LISTING'),PLIT('SOURCE'))-1;
%ERROR% BIND	ERRORS=PLIT(
%0%		PLIT('I/O#0 1 FILE 2 COULD NOT BE FOUND'),
%1%		PLIT('I/O#1 3 UFD DOES NOT EXITS'),
%2%		PLIT('I/O#2 PROTECTION FAILUTE OR DIRECTORY FULL ON 1 DEVICE 4'),
%3%		PLIT('I/O#3 1 FILE 2 IS BEING MODIFIED'),
%4%		PLIT('I/O#4 ENTER FOLLOWS LOOKUP OF 1 FILE 2'),
%5%		PLIT('I/O#5 LOOKUP FOLLOWS ENTER OF 1 FILE 2'),
%6%		PLIT('I/O#6 DEVICE ERROR, DATA ERROR, OR DATA INCONSISTENCY IN 1 UFD'),
%7%		PLIT('I/O#7 DSK ERROR NUMBER SEVEN'),
%8%		PLIT('I/O#8 DSK ERROR NUMBER TEN'),	%OCTAL DISK ERRORS %
%9%		PLIT('I/O#9 DSK ERROR NUMBER ELEVEN'),
%10%		PLIT('I/O#10 DSK ERROR NUMBER TWELVE'),
%11%		PLIT('I/O#11 DSK ERROR NUMBER THIRTEEN'),
%12%		PLIT('I/O#12 1 FILE STRUCTURE 4 HAS NO ROOM OR HAS EXCEEDED ITS QUOTA'),
%13%		PLIT('I/O#13 1 DEVICE 4 IS WRITE LOCKED'),
%14%		PLIT('I/O#14 NOT ENOUGH TABLE SPACE IN MONITOR FREE CORE FOR 1 DEVICE 4'),
%15%		PLIT('I/O#15 1 FILE 2 ONLY PARTIALLY ALLOCATED'),
%16%		PLIT('I/O#16 1 FILE 2 BLOCK NOT FREE ON ALLOCATED POSITION'),
%17%		PLIT('I/O#17 1 DEVICE 4 NOT AVAILABLE'),
%18%		PLIT('I/O#18 1 DEVICE 4 WRITE LOCKED'),
%19%		PLIT('I/O#19 HARDWARE DEVICE ERROR ON 1 DEVICE 4'),
%20%		PLIT('I/O#20 CHECKSUM OR PARITY ERROR IN 1 FILE 2'),
%21%		PLIT('I/O#21 BLOCK TOO LARGE OR QUOTA EXCEEDED FOR 1 FILE 2'),
%22%		PLIT('I/O#22 NOT ENOUGH ROOM IN CORE FOR COMMAND STRING'),
%23%		PLIT('I/O#23 WILD CHARACTERS IN OUTPUT SPECIFICATION ARE NOT SUPPORTED'),
%24%		PLIT('I/O#24 SUBFILE OUTPUT IS NOT SUPPORTED'),
%25%		PLIT('I/O#25 1 DEVICE 4 CANNOT DO 5'),
%26%		PLIT('I/O#26 NON-EXISTANT INPUT FILE'),
%27%		PLIT('I/O#27 WILD CARD FEATURE FOR DECTAPE NOT SUPPORTED'),
%28%		PLIT('I/O#28 ONLY TWO OUTPUT FILES ARE SUPPORTED'),
%29%		PLIT('I/O#29 1 DEVICE 4 ALREADY IN USE OR DOESN''T EXIST'),
%30%		PLIT('I/O#30 WILD EXTENSIONS IN OUTPUT SPECIFICATION ARE NOT SUPPORTED'),
%31%		PLIT('COR#31 NOT ENOUGH CORE FOR EXPANSION, COMPILATION TERMINATED')
		);
MACHOP	CLOSE=#070,JRST=#254;
%(-----------------------------------------------------------------------------------------------------------------
	COPY THE "N"TH PLIT OF THE ERRORS PLIT INTO LINE BUFFER T, TRANSLATING
	THE DIGITS 1-5 INTO THE APPROPRIATE INFORMATION.  USE THE CHANNEL
	NUMBER TO INDICATE IN WHICH FIELD oF THE COMMAND STRING THE
	ERROR OCCURRED AND TO PICK UP THE APPROPRIATE DEVICE, FILENAME,
	ETC. FOR THIS CHANNEL.
-----------------------------------------------------------------------------------------------------------------)%
LOCAL	P1,P2,T[20]% 100 CHARACTER LINE %;
P1_(@(ERRORS+.N)-1)<1,7>;P2_T[0]<36,7>;
INCR I FROM 1 TO @P1*5 DO	!P1 POINTS INITIALLY TO THE PLIT WORD COUNT
		SELECT C_SCANI(P1) OF NSET
0:		EXITLOOP;	!UNDEFINED CHARACTERS IN LAST WORD OF PLIT ARE SET TO ZERO
"#":		(DO REPLACEI(P2,.C) UNTIL ( C_SCANI(P1)) EQL " ";REPLACEI(P2," "));
"1":		BEGIN
%SOURCE,%
%LISTING OR%		T1_(@(FIELD+.CHNL))<36,7>;
%OBJECT%		UNTIL (C_SCANI (T1)) EQL 0 DO REPLACEI(P2,.C)
		END;
"2":		BEGIN
			T1_(FILENAME(.CHNL))<36,6>;T2_6;
%FILENAME.EXTENSION%	UNTIL (T2_.T2-1) LSS 0 DO IF (C_SCANI(T1)) NEQ 0 THEN REPLACEI(P2,.C+" ");
			REPLACEI(P2,".");T2_3;
			UNTIL (T2_.T2-1) LSS 0 DO IF (C_SCANI(T1)) NEQ 0 THEN REPLACEI(P2,.C+" ")
		END;
"3":		BEGIN
			T1_(DIRECTORY(.CHNL))<36,3>;
			REPLACEI(P2,"[");T2_6;
			UNTIL (T2_.T2-1) LSS 0
%[PROJECT,PROGRAMMER]%	DO (REPLACEI(P2,SCANI(T1)+"0"));
			REPLACEI(P2,",");T2_6;
			UNTIL (T2_.T2-1) LSS 0
			DO (REPLACEI(P2,SCANI(T1)+"0"));
			REPLACEI(P2,"]")
		END;
"4":		BEGIN
			T1_(DEVICE(.CHNL))<36,6>;T2_6;
			UNTIL (T2_.T2-1) LSS 0
%DEVICE%		DO (IF (C_SCANI(T1)) EQL 0 THEN EXITLOOP ELSE REPLACEI(P2,.C+" "));
			REPLACEI(P2,":")
		END;
"5":		BEGIN
%BINARY OUTPUT,%
%ASCII OUTPUT,OR%	T1_(@(DEVMODE+.CHNL))<36,7>;
%ASCII INPUT%		UNTIL (C_SCANI(T1)) EQL 0 DO REPLACEI(P2,.C)
		END;
OTHERWISE:	REPLACEI(P2,.C)
		TESN;
		REPLACEI(P2,0);
		OUTSTR(T[0]);
		OUTSTR(0);
		CLOSE(BIN,0);CLOSE(LST,0);CLOSE(SRC,0);
		JRST(0,.JOBSA<0,18>);
		.VREG
END;
	MACRO IOIMPM=17,1$,IODERR=16,1$,IODTER=15,1$,IOBKTL=14,1$,IODEND=13,1$;
FORWARD SFGETLINE;
GLOBAL ROUTINE READ =
BEGIN
	IF .BUFPNT(PHONEYSRC) NEQ 0 THEN 
		(IF (C_SCANI(BUFPNT(PHONEYSRC))) EQL #15 THEN SFGETLINE())
		ELSE (FLGREG<ENDFILE>_1;
		      C_EOL);
END;


GLOBAL ROUTINE SFGETLINE =
BEGIN
	EXTERNAL SIMPL,PFRDLIN,STANUM,NEWPAGE,SEQUENCE,GBLSTANUM;
	NEWPAGE(); SEQUENCE();
	IF (BUFPNT(PHONEYSRC)_SIMPL(PFRDLIN,.GBLSTANUM+.STANUM,1)) EQL 0 THEN FLGREG<ENDFILE>_1;
END;


GLOBAL ROUTINE OVERANDOUT =
BEGIN
	MACHOP CLOSE=#70;
	CLOSE (BIN,0);
	CLOSE (LST,0);
END;
GLOBAL	ROUTINE	LSTOUT =
!T1_T2_SCRATCH;
BEGIN
	MACHOP	OUTUUO=#057;
	IF (BUFCNT(PHONEYLST)_.BUFCNT(PHONEYLST)-1) GTR 0
		THEN REPLACEI(BUFPNT(PHONEYLST),.C)
		ELSE
		IF NOSKIP(OUTUUO(LST,0)) % SKIPS ON AN ERROR ONLY%
			THEN REPLACEI(BUFPNT(PHONEYLST),.C)
			ELSE
			BEGIN
				MACHOP GETSTS=#062;
				GETSTS(LST,T1);
				IF .T1<IOBKTL> THEN ERROR(E21,PHONEYLST)
					ELSE
					IF .T1<IODTER> THEN ERROR(E20,PHONEYLST)
						ELSE
						IF .T1<IODERR> THEN ERROR(E19,PHONEYLST)
							ELSE
							IF .T1<IOIMPM> THEN ERROR(E18,PHONEYLST);
			END;
	.VREG
END;
GLOBAL	ROUTINE	RELOUT =
!T1_T2_SCRATCH;
BEGIN
	MACHOP	OUTUUO=#057;
	IF (BUFCNT(PHONEYBIN)_.BUFCNT(PHONEYBIN)-1) GTR 0
		THEN REPLACEI(BUFPNT(PHONEYBIN),.C)
		ELSE
		IF NOSKIP(OUTUUO(BIN,0)) % SKIPS ON AN ERROR ONLY%
			THEN REPLACEI(BUFPNT(PHONEYBIN),.C)
			ELSE
			BEGIN
				MACHOP GETSTS=#062;
				GETSTS(BIN,T1);
				IF .T1<IOBKTL> THEN ERROR(E21,PHONEYBIN)
					ELSE
					IF .T1<IODTER> THEN ERROR(E20,PHONEYBIN)
						ELSE
						IF .T1<IODERR> THEN ERROR(E19,PHONEYBIN)
							ELSE
							IF .T1<IOIMPM> THEN ERROR(E18,PHONEYBIN);
			END;
	.VREG
END;
END ELUDOM
    