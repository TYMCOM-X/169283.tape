!  CCS EDITOR
!  IOCSU+PFU+CCOMU MUST PRECEDE


GLOBAL %CCS, S:

S:      CCS.INIT
S1:     CCS


%CCS

LOCAL %CSCAN, %CEXU

! USED IN COMMAND PROCESSING (NOT SAVED BETWEEN COMMANDS):

LOCAL SCR(NLMAX)             !SCRATCH ARRAY
LOCAL INFN                   !INPUT FILE NUMBER

!  ERROR MESSAGES TO USER OF CCS

TABLE EDILNG       ['TRUNCATED LINE AVAILABLE FOR EDIT']
TABLE NODFLT       ['NO DEFAULT NAME']
TABLE NOTIMP       ['BAD I/O SOURCE OR DESTINATION']
TABLE CNTREN       ['CANNOT RENUMBER, CHECK LINE RANGE']
TABLE BDANS        ['ILLEGAL RESPONSE IN COMMAND FILE']
TABLE DISORD       ['DISORDERLY LINE NUMBER']
TABLE PTROOM       ['NOT ENOUGH ROOM, CANNOT ENTER LINE']
TABLE NOROOM       ['NOT ENOUGH ROOM, COMMAND NOT EXECUTED']
TABLE BDLNFL       ['EDIT REQUIRES LINE NUMBERS, COPY REQUIRES NONE']
TABLE ENDSCR       ['OUT OF SCRATCH AREA, TRY SAVE AND RELOAD']
TABLE NDOPEN       ['PLEASE GIVE OPEN COMMAND FIRST']


LOCAL PTR, CNT, TEMP, I

LOCAL NCOM:, NOPF:

        OFFALT
        CCOM(NCOM)
        PF.NOPF _ NOPF

!  ACCEPT A COMMAND LINE
!  NOTE: DO OFFALT BEFORE BRANCH HERE OR TO ANY LABELS FOLLOWING
!  ABOVE OFFALT

NCOM:    FIXUP _ NCOM
         ONALT.C
 	 GETCOM
         CSCAN; CEXU
         IF PF.FN > TEL THEN INC PF.INTNO; GO NCOM

NOPF:   CERR(NDOPEN)


%CSCAN

!  CCS COMMAND LINE SCANNER

!  STORES COMMAND LINE ELEMENT IDENTIFIERS (IN EL.ID ARRAY) & INFO
!  NEEDED TO ACCESS ELEMENTS (IN EL ARRAY).
!  PF.CNUM (COMMAND NO.) RETURNED IF SCAN SUCCESSFUL, WITH 0'S IN
!  UNUSED EL.ID POSITIONS.

DEF ELW(X,Y) AS [EL(INC ELP)_(Y); EL.ID(ELP)_(X)]

LOCAL EROUT:, CRCHK:

         CSCAN.INIT

         DO PF.CNUM OF CWDCNT

K.ENT:   IF NOT FRNG THEN GO EROUT
         IF EL.ID(1)=LKY.ID THEN DO
           IF NSPCH(NXCHAR)  THEN BACKSP     !ABSORB BLANK AFTER LINE KEY
           ELW(FOR.ID,LPTR); RETURN PF.CNUM
         END

K.CLR:   K.QUIT:  K.VER:  K.RUN:  NULL

K.MERG:  FFID(0)

K.DO:   FFID(OCT 435544.000000)    !.CMD

K.EDIT:  K.MOD:  &
         IF NOT FLST THEN GO EROUT

K.DEL:   FLST

K.FAST:  K.LIST: &
         FLST; FPWD(K.TO,CRCHK); FFID(0)

K.COPY: IF NOT FLST THEN FFID(0)
COP.B:  FPWD(K.TO,%PCMDL); IF NOT FRNG THEN FFID(0)

K.MOVE: IF NOT FLST THEN GO EROUT; GO COP.B

K.REN:   FLST; FPWD(K.AS,CRCHK)
RENA:	 IF NOT FRNG THEN GO EROUT

K.OPEN:  FFID(OCT 604755.000000)  !.PGM

         END

! CR MUST FOLLOW
CRCHK:   IF NOT FCR THEN PCMDL; RETURN PF.CNUM

EROUT:   IF NXNSP#CARRET THEN CERR(BDLRNG) ELSE PCMDL


END CSCAN


%CEXU

!  EXECUTES COMMAND PF.CNUM.
!  WHEN FALL THRU TO END OF CASE STATEMENT, ALT MODE MUST BE OFF
!  (BECAUSE OF SUBSEQUENT BRANCH TO NCOM:).
!  FIXUP LOCATION SHOULD NOT INCLUDE OFFALT (WILL BE OFF WHEN 
!  GO ^FIXUP).

LOCAL %INRANG, %INTXL
LOCAL %MRGINP, %SET.INCR
GLOBAL %MKDL, %DELMKD, %UNMKDL
LOCAL %ANS

LOCAL LOKEY      !1ST KEY OF RANGE
LOCAL HIKEY      !LAST ALLOWABLE KEY
LOCAL INCR       !RANGE INCREMENT 
LOCAL LONUM      !1ST DICT. POSITION TO BE AFFECTED BY NEW RANGE
LOCAL HINUM      !POSITION OF 1ST LINE BEYOND AFFECTED RANGE IN PROG.
LOCAL TXINCT     !TEXT INPUT COUNT (NO. LINES ENTERED)
LOCAL MXINCT     !MAXIMUM TEXT INPUT COUNT

LOCAL I, J, WD(), TEMP
LOCAL LNERRB:, LOAD.B:, COP.B:
LOCAL COP.C:, LOADFX:, ENTFX:, MERGN:, LOAD.C:
LOCAL %SET.INFN


         DO PF.CNUM OF CWDCNT


K.ENT:   INRANG(1)
         FIXUP _ ENTFX     !== FIXUP TO NCOM UNTIL LINE HAS BEEN ENTERED
         EIF EL.ID(1)=LKY.ID THEN INTXL    !LPTR IS OK

         ORIF INCR<0 THEN DO   !NO INCREMENT - AT SIGN PROMPT
           PRMNUM _ K.PAT
           LOOP DO
             GETSTR(CFN); WHILE NXCHAR#CARRET; BACKSP; INTXL
           END
         END
  
         ELSE DO    !INCREMENT - LINE KEY PROMPT
           PRMNUM _ K.PLK; TEMP _ LOKEY
ENT.B:     PRMKEY _ BCD(TEMP); GETSTR(CFN)
           IF NXCHAR#CARRET THEN DO
             BACKSP; INTXL
             IF TEMP +_ INCR <= HIKEY THEN GO ENT.B
           END
         END

         OFFALT
ENTFX:   PF.DOT _ MRGINP


K.MERG: OFFALT     !SINGLE LINE ENTER FROM FILE
        SETRWE(SET.INFN,MERGN); FIXUP _ LOAD.C; ONALT
        LOOP DO
          GETSTR(INFN)
          IF NXNSP#CARRET THEN DO
            BACKSP; PF.CNUM _ K.ENT; CSCAN
            INRANG(1); IF EL.ID(1)#LKY.ID THEN CERR(BDLRNG)
            INTXL; OFFALT; PF.DOT _ MRGINP; ONALT
          END
        END

MERGN:  LNGCHK; OFFALT

LOAD.C: CLOSE(INFN)


K.DO:   OFFALT; INFN _ OPEN(EL(1),INPUT+SEQUEN+CHARACTER,OPNERR,2)
        CLOSE(CFN<==INFN); SETRWE(CFN,CFNEOF)


K.FAST: K.LIST: LIST.EXU


!K.COPY:  K.MOVE: &
!	   INLIST(1)
!             INRANG(2)
!             OFFALT
!             REPEAT LSTCNT DO
!               NXLNUM
!               IF PF.CNUM=K.MOVE THEN DO
!                 IF NOT(LONUM<=LNUM<HINUM) AND PF.KEYD(LNUM)>0 THEN DO
!                 !!IF OUTSIDE RANGE AND NOT ALREADY MARKED FOR DELETION:
!                   INC MXINCT; MKDL(LNUM)
!                 END
!               END
!               IF TXINCT=MXINCT THEN ABERR(NOROOM)
!               SCR(INC TXINCT) _ PF.CPD(LNUM)
!             END
!             IF PF.CNUM=K.MOVE THEN DO     !!SET UP FOR MRGINP
!               LONUM _ DELMKD(1,LONUM-1)+1
!               PF.NLINES _ DELMKD(HINUM,PF.NLINES)
!             END
!             PF.DOT _ MRGINP


FIND LNERRA:, HERE:, COPFX:

FIND %LIST.PAR

K.COPY: K.MOVE: &
         EIF EL.ID(1)=LST.ID THEN DO
FAST:      INLIST(1)
           EIF EL.ID(2)#RNG.ID THEN DO    !LINE LIST TO FILE OR TEL
             OFFALT
             IF OUTFN _ IF ELID(2)=0 THEN TEL ELSE &
              OPEN(EL(2),OUTMSG+SEQUEN+CHARACTER,OPNERR,2)#TEL THEN OKAY
             FIXUP _ COPFX
             ONALT
             [I;J] _ DOUBLE LIST.PAR
             REPEAT LSTCNT DO
               NXLNUM
               OUTCNT _ LLEN
               IF PF.CNUM=K.MOVE THEN MKDL(LNUM)
               UNPKTK(0,LNERRA)
             END
             OFFALT
             CLOSE(OUTFN); IF PF.CNUM=K.MOVE THEN GO DELA
             IF OUTFN=TEL THEN PF.DOT _ LNUM
           END


           ELSE DO           !LINE LIST TO RANGE
             INRANG(2)
             OFFALT
             REPEAT LSTCNT DO
               NXLNUM
               IF PF.CNUM=K.MOVE THEN DO
                 IF NOT(LONUM<=LNUM<HINUM) AND PF.KEYD(LNUM)>0 THEN DO
                 !IF OUTSIDE RANGE AND NOT ALREADY MARKED FOR DELETION:
                   INC MXINCT; MKDL(LNUM)
                 END
               END
               IF TXINCT=MXINCT THEN ABERR(NOROOM)
               SCR(INC TXINCT) _ PF.CPD(LNUM)
             END
             IF PF.CNUM=K.MOVE THEN DO     !SET UP FOR MRGINP
               LONUM _ DELMKD(1,LONUM-1)+1
               PF.NLINES _ DELMKD(HINUM,PF.NLINES)
             END
             PF.DOT _ MRGINP
           END
         END


         ELSE DO
           OFFALT
           SETRWE(SET.INFN,COP.B); IF PLNCHK(INFN) THEN ABERR(BDLNFL)
!* NOTE: IF ADD FILE-TO-FILE, MUST MOVE FOLLOWING ASSIGNMENT
           FIXUP _ COP.C
           ONALT
           EIF EL.ID(2)=RNG.ID THEN DO       !FILE TO RANGE
             INRANG(2)
!* NOTE: NOROOM ERR IF INCR>=0 AND LINE KEY>HIKEY (MXINCT EXCEEDED)
             LOOP [GETSTR(INFN); INTXL]
COP.B:       LNGCHK; OFFALT
             PF.DOT _ MRGINP
COP.C:       CLOSE(INFN)
           END


           ELSE DO       !FILE TO FILE
             CERR(NOTIMP)
           END
         END


K.MOD: &
K.EDIT:  INLIST(1); OUTFN _ TEL; PRMNUM _ K.PLK
         REPEAT LSTCNT DO
           PRMKEY _ PF.KEYD(NXLNUM)
           OUTCNT _ LLEN; UNPKTK(CHPT(IMAGE,-1),LNERRB)
EDIT.A:    IF PF.CNUM=K.EDIT THEN [OUTKEY(0,0,0); PRINTC(IMAGE)]
           GETSTR(TEL)
           IF NXCHAR#CARRET THEN DO
             BACKSP
             OFFALT
             PF.CPD(PF.DOT _ LNUM) _ PF.WTLIN(LPTR)
             PF.RELOK _ 0
             ONALT
           END
         END
         OFFALT


K.DEL: K.CLR: &
         IF EL.ID(1)=0 THEN DO     !CLEAR
           IF ANS('ALL')=YES THEN DO
             OFFALT;  PF.CLEAR;  GO NCOM
           END ELSE OFFALT

         END ELSE DO     !DELETE SPECIFIED LINES
           INLIST(1)
           OFFALT
           REPEAT LSTCNT MKDL(NXLNUM)
DELA:      PF.NLINES _ DELMKD(1,PF.NLINES)
           PF.RELOK _ 0
         END


K.REN: &
! WILL NOT MOVE OR DELETE LINES! &
         IF ELID(1)=RNG.ID THEN DO
           ELID(1) <=> ELID(2)     !MOVE RANGE INFO, ZERO LIST ID
           EL(2) _ EL(1)           !FOR %INLIST
         END
         IF INLIST(1)>1 THEN PCMDL
         IF ELID(1)#0=ELID(2) THEN DO
           !REN ADR1:ADR2 - ASSUME AS KEY(ADR1):KEY(ADR2)
           !MXINCT CHECK NOT NEEDED
           INCR _ -1
           LOKEY _ INTKEY(LONUM _ LTBL(1))
           HIKEY _ INTKEY((HINUM _ LTBL(1)+LSTCNT)-1)
         END ELSE [INRANG(2); IF LSTCNT>MXINCT THEN CERR(CNTREN)]
         IF NOT(LONUM>= LNUM _ LTBL(1) >=HINUM-LSTCNT) THEN CERR(CNTREN) 
         TXINCT _ LSTCNT; SET.INCR; DEC LNUM
         OFFALT
         REPEAT LSTCNT PF.KEYD(INC LNUM) _ BCD(LOKEY <== LOKEY+INCR)


FIND SGLD:, SGSFA:

K.RUN:   PF.UPDATE
         GOSEG(IF PF.RELOK THEN SGLD ELSE SGSFA, 0)


K.OPEN:  OFFALT
         DO PF.OPEN(EL(1)) OF -1:1
-1:      CERR(NOTIMP)  !TEL
0:       GO OPNERR  !DIDN'T OPEN IT
         END
         OKAY


K.QUIT:  OFFALT; GO QUIT
QUIT:    PF.CLOSE; CLOSE.ALL; ONALT; EXIT; HALT


         END
         RETURN


LNERRB:  MSG(LNLONG); MSG(EDILNG); GO EDIT.A

%SET.INFN
LOCAL INERR:

        LOOP DO
         IF INFN _ OPEN(EL(1),INPUT+SEQUEN+CHARACTER,INERR,2) &
          =TEL THEN CERR(NOTIMP); OKAY; RETURN INFN
INERR:   IF ERRNUM#FNFERR OR EXTQ(FIDP)=YES THEN GO OPNERR
         EXTQ(FIDP) _ YES; EXTARG(FIDP) _ 0
        END

END SET.INFN


%INRANG (I)

!  I IS INDEX INTO EL.ID & EL ARRAYS FOR LINE RANGE INFO. EL(I) IS
!  ADDRESS OF WD BEFORE 1ST WD OF SUBELEMENT LIST,
!  UNLESS EL.ID(I) IS 0, TO INDICATE DEFAULT RANGE OF 1(1) (RENUMBER).
!  ALSO SPECIAL RENUMBER CASE: IF UPPER LIMIT OMITTED, IS LAST LINE
!  IN LIST TO BE RENUMBERED.
!  CALCULATES AND STORES RANGE PARAMETERS: LOKEY, HIKEY, INCR (-1
!  IF NONE), LONUM, HINUM, MXINCT.
!  INITS TXINCT & CURSOR FOR %INTXL
!  NOTE: NEGATIVE INTEGER REPRESENTS LINE KEY.

LOCAL CONT:, NXT:, NXT1:

         IF EL.ID(I)=0 THEN [LOKEY _ INCR _ PWR10(D.DGMAX); GO INRA]
         WD _ EL(I)
         LOKEY _ -WD(1); INCR _ -1
         IF WD(2)=0 THEN HIKEY_LOKEY ELSE DO
           IF WD(2)=$: THEN HIKEY_-WD(3) ELSE DO
             INCR _ -WD(3)    !WD(2) IS (, WD(4) IS )
             IF HIKEY _ -WD(5)=0 THEN DO    !CREATE UPPER LIMIT KEY
INRA:          IF PF.CNUM=K.REN THEN LNUM _ LTBL(1)+LSTCNT ELSE DO
                 XLKLN(LOKEY,CONT); INC LNUM
                 ! LNUM IS 1ST PROG. LINE ABOVE LOWER LIMIT
               END
CONT:          HIKEY _ IF LNUM >PF.NLINES THEN LKY.MAX ELSE &
                 INTKEY(LNUM)-1
             END
           END
           IF HIKEY < LOKEY THEN CERR(BDLRNG)   !OLD CCS DISALLOWED =
         END

         XLKLN(LOKEY,NXT)
NXT:     LONUM _ LNUM
         XLKLN(HIKEY,NXT1); INC LNUM
NXT1:    HINUM _ LNUM
         ! HINUM-LONUM IS NO. OF LINES CURRENTLY IN RANGE
         MXINCT _ NLMAX MIN 1+(HIKEY-LOKEY)/(IF INCR<0 THEN 1 &
           ELSE INCR) MIN HINUM-LONUM+NLMAX-PF.NLINES

         TXINCT _ 0; RETURN

END INRANG


%INTXL

!  WRITE LINE AT LPTR ON PF AND STORE CORRESPONDING PF.CPD ENTRY
!  IN SCR ARRAY.
!  OFFALT PROTECTS AGAINST TXINCT BEING 1>NO. OF SCR ENTRIES.

         IF TXINCT = MXINCT THEN &
         ABERR(IF PF.CNUM=K.ENT THEN PTROOM ELSE NOROOM)
         OFFALT; SCR(INC TXINCT) _ PF.WTLIN(LPTR); ONALT
         RETURN

END INTXL


%MRGINP

!  MERGE THOSE LINES WHICH HAVE PF.CPD ENTRIES IN SCR ARRAY.
!  (TXINCT LINES IN ALL).  1ST KEY IS LOKEY; INCR IS CALCULATED IF
!  NEVER SPECIFIED.  1ST LNUM IS LONUM; LOKEY AND LONUM ARE UPDATED.
!  RETURNS NO. OF LAST LINE MERGED, POSSIBLY USED TO SET PF.DOT
!  (THUS DOES NOTHING BUT RETURN PF.DOT IF TXINCT IS 0.)

LOCAL MVCNT, MVDIS

         IF TXINCT=0 THEN RETURN PF.DOT
         SET.INCR
         MVCNT _ PF.NLINES-HINUM+1
         IF MVDIS _ LONUM+TXINCT-HINUM >0 THEN DO
!  MOVE DOWN LOWER PART OF EACH DICTIONARY,STARTING WITH LAST ENTRY
!  (PF.NLINES), ENDING WITH BEGINNING OF LOWER PART (HINUM).
           PTR _ PF.NLINES+1
           REPEAT MVCNT DO
             PF.CPD(PTR+MVDIS) _ PF.CPD(DEC PTR)
             PF.KEYD(PTR+MVDIS) _ PF.KEYD(PTR)
           END
         END ELSE IF MVDIS<0 THEN DO     !MOVE UP LOWER PART
           MOVE MVCNT FROM @PF.CPD(HINUM) TO @PF.CPD(LONUM+TXINCT)
           MOVE MVCNT FROM @PF.KEYD(HINUM) TO @PF.KEYD(LONUM+TXINCT)
         END
         DEC LONUM; I _ 0
         WHILE INC I <= TXINCT THEN DO
           PF.CPD(INC LONUM) _ SCR(I)
           PF.KEYD(LONUM) _ BCD(LOKEY<==LOKEY+INCR)
         END
         PF.NLINES +_ MVDIS
         PF.RELOK _ 0
         RETURN LONUM
END MRGINP


%SET.INCR

! COMPUTE INCREMENT IF NECESSARY.

IF TXINCT>1 AND INCR<0 THEN DO
  TEMP _ (HIKEY-LOKEY)/(TXINCT-1) +1
  I _ D.DGMAX+1
  WHILE TEMP <= PWR10(DEC I) THEN NULL; INCR _ PWR10(I)
END
RETURN

END SET.INCR


%MKDL (LNUM)

!  MARK LINE WITH NUMBER LNUM FOR DELETION (TURN ON SIGN BIT)

PF.KEYD(LNUM) BOR_ SGNBIT; RETURN

END MKDL


%DELMKD (LO, HI)

!  DELETE LINES MARKED FOR DELETION (SIGN BIT ON) IN RANGE OF LINE
!  NUMBERS LO TO HI; I.E., CRUNCH UNMARKED LINES.
!  RETURNS INDEX TO LAST OF CRUNCHED LINES (LO-1 IF ALL MARKED).
!  IF HI EXCEEDS LO, RETURNS LO-1; WHEN CALLED IN MOVING
!  LIST TO RANGE, WILL WORK OK IF LONUM IS 0 OR HINUM IS PF.NLINES+1.
!  ADJUST PF.DOT IF IN AFFECTED RANGE.

LNUM _ I _ LO-1
WHILE INC LNUM<=HI THEN DO
  IF PF.KEYD(LNUM)>0 THEN DO
    PF.KEYD(INC I) _ PF.KEYD(LNUM)
    PF.CPD(I) _ PF.CPD(LNUM)
  END
  IF LNUM=PF.DOT AND PF.DOT _ I =0 THEN INC PF.DOT
END
RETURN I

END DELMKD


%UNMKDL

!  UNMARK ALL LINES MARKED FOR DELETION (TURN OFF SIGN BIT).

LNUM _ 0
REPEAT PF.NLINES &
  PF.KEYD(INC LNUM) BAND_ BNOT SGNBIT
RETURN

END UNMKDL


%ANS (QUES)

!  PRINTS QUES (IF COMMAND FILE TEL), READS ANSWER AND RETURNS 1 IF YES,
!  0 IF NO.

         IF CFN=TEL THEN [MSG(QUES); PRMNUM _ K.PQM]
         LOOP DO
           GETSTR(CFN)
           IF LWALPH(NXNSP) THEN XLWUP(LASTCH)
           IF NOT($Y#LASTCH#$N) THEN RETURN [LASTCH=$Y]
           IF CFN#TEL THEN CERR(BDANS)
           MSG('WHAT')
         END

END ANS

END CEXU

END CCS
   