!COPYRIGHT 1973, DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS
!AUTHOR: S MURPHY
GLOBAL BIND MEMCV=24;		!VERSION DATE: APRIL 5, 1973




GLOBAL ROUTINE MEMCMCHK=
%(***************************************************************************
	ROUTINE TO DETECT ASSIGNMENT STATEMENTS THAT CAN BE PERFORMED TO MEMORY.
	IF THERE IS AN N-ARY EXPRESSION ON THE RIGHT HAND SIDE, SEARCHES THAT
	EXPRESSION FOR THE VAR OR ARRAYREF THAT IS ON THE LEFT HAND SIDE AND
	IF IT IS FOUND, BRINGS IT UP TO THE TOP RIGHT HAND NODE UNDER THE N-ARY
	EXPRESSION.
	IF THE STMNT CAN BE PERFORMED TO MEMORY, MEMCMPFLG IS SET IN THE
	STATEMENT NODE.
***************************************************************************)%
BEGIN
	EXTERNAL CSTMNT;
	MAP PEXPRNODE CSTMNT;
	LOCAL SAVCSTMNT;
	LOCAL PEXPRNODE LHNODE;


	%(***IF THIS STMNT IS A LOGICAL IF, WANT TO LOOK AT THE SUBSTATEMENT UNDER IT***)%
	IF .CSTMNT[SRCID] EQL IFLID
	THEN
	BEGIN
		SAVCSTMNT_.CSTMNT;	!SAVE PTR TO CURRENT STMNT
		CSTMNT_.CSTMNT[LIFSTATE];
		MEMCMCHK();

		CSTMNT_.SAVCSTMNT;	!RESTORE PTR TO CURRENT STMNT
		RETURN
	END;


	%(***ONLY WANT TO DO THIS FOR ASSIGNMENT STATEMENTS***)%
	IF .CSTMNT[SRCID] NEQ ASGNID THEN RETURN;

	LHNODE_.CSTMNT[LHEXP];

	IF .CSTMNT[A1VALFLG]
	THEN
	BEGIN
		IF VMEMCMCHK() THEN CSTMNT[MEMCMPFLG]_1;
	END
	ELSE
	IF .LHNODE[OPRCLS] EQL ARRAYREF
	THEN
	BEGIN
		IF ARRMEMCMCHK() THEN CSTMNT[MEMCMPFLG]_1;
	END
END;


GLOBAL ROUTINE VMEMCMCHK=
%(***************************************************************************
	ROUTINE TO DETECT EXPRESSIONS OF THE FORM:
		A=A+B+C+...
		A=A*B*C*...
		A=B/A
		A=A AND B AND C AND...
		A=A OR B OR C OR...
		A=A XOR B XOR C...
		A=A EQV B EQV C ...
	CALLED WITH THE GLOBAL CSTMNT POINTING TO THE STATEMENT NODE TO
	BE ANALYZED.
	IF AN OPERATION THAT CAN BE PERFORMED TO MEMORY IS DETECTED, THE
	ARG THAT MATCHES THE LHS OF THE ASSIGNMENT IS MOVED INTO THE TOP RIGHT
	NODE OF THE N-ARY TREE, AND THIS FUNCTION RETURNS TRUE
***************************************************************************)%
BEGIN
	EXTERNAL CSTMNT;
	MAP PEXPRNODE CSTMNT;
	OWN PEXPRNODE ARGNODE;
	OWN PEXPRNODE SUBNODE;
	OWN T1;
	OWN NARYOPR;



	ARGNODE_.CSTMNT[RHEXP];

	%(***CHECK FOR A=A**2, A=A**3, A=A*(POWER OF 2 PLUS 1) ***)%
	IF .ARGNODE[OPRCLS] EQL SPECOP
	THEN
	BEGIN
		IF .ARGNODE[ARG1PTR] EQL .CSTMNT[LHEXP]
		THEN
		BEGIN
			IF SPECTOMEM(.ARGNODE)		!IF THIS OPERATOR IS ONE OF
							! THE ONES IN THIS OPRCLS THAT
							! CAN BE PERFORMED TO MEMORY
			THEN RETURN TRUE
		END;
		RETURN FALSE
	END

	ELSE
	%(***CHECK FOR A=B/A***)%
	IF .ARGNODE[OPR1] EQL DIVOPF
	THEN
	BEGIN
		IF .ARGNODE[ARG2PTR] EQL .CSTMNT[LHEXP]
		THEN RETURN TRUE
	END

	ELSE
	%(****FOR BOOLEANS, ADD AND MUL - MUST SEARCH N-ARY TREE FOR MATCH TO LHEXP**)%
	IF .ARGNODE[OPRCLS] EQL BOOLEAN OR ADDORMUL(ARGNODE)
	THEN
	BEGIN
		IF .ARGNODE[ARG1PTR] EQL .CSTMNT[LHEXP]
		THEN
		BEGIN
			%(***ARG WHICH IS EQUAL TO LHS SHOULD ALWAYS BE THE 2ND***)%
			SWAPARGS(ARGNODE);
			RETURN TRUE
		END
		ELSE
		IF .ARGNODE[ARG2PTR] EQL .CSTMNT[LHEXP]
		THEN RETURN TRUE
		ELSE
		%(***SEARCH THE TOP LEVEL N-ARY NODE***)%
		BEGIN
			NARYOPR_.ARGNODE[OPERATOR];
			SUBNODE_.ARGNODE[ARG1PTR];	!(EXPR'S ARE LEFT-BALANCED)

			%(***LOOP TO SEARCH FOR THE LHS WITHIN THE TOP-LEVEL NARY
				EXPRESSION*****)%
			WHILE (.SUBNODE[OPERATOR] EQL .NARYOPR) AND
				NOT (.SUBNODE[PARENFLG])
			DO
			BEGIN
				IF .SUBNODE[ARG2PTR] EQL .CSTMNT[LHEXP]
				THEN
				BEGIN
					%(***EXCHANGE THE NODE THAT MATCHES WITH
						THE TOP-LEVEL RIGHT NODE***)%
					SUBNODE[ARG2PTR]_.ARGNODE[ARG2PTR];
					T1_.SUBNODE[A2FLGS];
					SUBNODE[A2FLGS]_.ARGNODE[A2FLGS];
					ARGNODE[A2FLGS]_.T1;
					ARGNODE[ARG2PTR]_.CSTMNT[LHEXP];
					RETURN TRUE;
				END;

				%(***TREES ARE LEFT-BALANCED - THEREFORE EITHER
					EXAMINE THE LEFT-SON OR WALK DOWN TO IT***)%
				IF .SUBNODE[A1VALFLG]
				THEN
				BEGIN
					IF .SUBNODE[ARG1PTR] EQL .CSTMNT[LHEXP]
					THEN
					BEGIN
						%(***EXCHANGE THE NODE THAT MATCHES WITH
							THE NODE AT THE TOP-LEVEL
							RIGHT*****)%
						SUBNODE[ARG1PTR]_.ARGNODE[ARG2PTR];
						T1_.SUBNODE[A1FLGS];
						SUBNODE[A1FLGS]_.ARGNODE[A2FLGS];
						ARGNODE[A2FLGS]_.T1;
						ARGNODE[ARG2PTR]_.CSTMNT[LHEXP];
						RETURN TRUE;
					END;

					RETURN;
				END
				ELSE
				SUBNODE_.SUBNODE[ARG1PTR];
			END;

		END
	END;
	RETURN FALSE;
END;





GLOBAL ROUTINE ARRMEMCMCHK=
%(***************************************************************************
	ROUTINE TO DETECT EXPRESSIONS OF THE FORM:
		A(I,J,...)=A(I,J,...)+B+C+...
		A(I,J,...)=A(I,J,...)*B*C*...
		A(I,J,...)=B/A(I,J,...)
		A(I,J,...)=A(I,J,...) AND B AND C AND...
		A(I,J,...)=A(I,J,...) OR B OR C OR...
		A(I,J,...)=A(I,J,...) XOR B XOR C...
		A(I,J,...)=A(I,J,...) EQV B EQV C ...
	CALLED WITH THE GLOBAL CSTMNT POINTING TO THE STATEMENT NODE TO
	BE ANALYZED.
	IF AN OPERATION THAT CAN BE PERFORMED TO MEMORY IS DETECTED, THE
	ARG THAT MATCHES THE LHS OF THE ASSIGNMENT IS MOVED INTO THE TOP RIGHT
	NODE OF THE N-ARY TREE, AND THE FUNCTION RETURNS TRUE
***************************************************************************)%
BEGIN
	EXTERNAL CSTMNT;
	MAP PEXPRNODE CSTMNT;
	OWN PEXPRNODE LHNODE:TSTNODE;
	OWN PEXPRNODE ARGNODE;
	OWN PEXPRNODE SUBNODE;
	OWN T1;
	OWN NARYOPR;



	%(****ROUTINE TO TEST WHETHER 'NODE' IS AN ARRAYREF WITH IDENTICAL ARGS TO THE
		ARRAYREF ON THE LEFT HAND SIDE OF THE CURRENT ASSIGNMENT STATEMENT.
		(THIS IS NECESSARY BECAUSE ARRAYREF NODES ARE NEVER COMMON SUBEXPRS)****)%
	ROUTINE ARREQLLH(NODE)=
	BEGIN
		MAP PEXPRNODE NODE;
		IF .NODE[ARGWD] EQL .LHNODE[ARGWD]	!IF NAME OF ARRAY IS SAME AND
							! SS LIST IS THE SAME COMMON SUBEXPR
		THEN
		BEGIN
			RETURN (.NODE[TARGET] EQL .LHNODE[TARGET]
				AND .NODE[OPRCLS] EQL ARRAYREF)
		END
		ELSE RETURN FALSE
	END;



	ARGNODE_.CSTMNT[RHEXP];
	LHNODE_.CSTMNT[LHEXP];


	%(***CHECK FOR A=A**2, A=A**3, A=A*(POWER OF 2 PLUS 1) ***)%
	IF .ARGNODE[OPRCLS] EQL SPECOP
	THEN
	BEGIN
		IF ARREQLLH(.ARGNODE[ARG1PTR])
		THEN
		BEGIN
			IF SPECTOMEM(.ARGNODE)		!IF THIS OPERATOR IS ONE OF
							! THE ONES IN THIS OPRCLS THAT
							! CAN BE PERFORMED TO MEMORY
			THEN RETURN TRUE
		END;
		RETURN FALSE
	END

	ELSE
	%(***CHECK FOR A=B/A***)%
	IF .ARGNODE[OPR1] EQL DIVOPF
	THEN
	BEGIN
		TSTNODE_.ARGNODE[ARG2PTR];
		IF ARREQLLH(.TSTNODE)
		THEN
		RETURN TRUE
	END

	ELSE
	%(****FOR BOOLEANS, ADD AND MUL - MUST SEARCH N-ARY TREE FOR MATCH TO LHEXP**)%
	IF .ARGNODE[OPRCLS] EQL BOOLEAN OR ADDORMUL(ARGNODE)
	THEN
	BEGIN
		TSTNODE_.ARGNODE[ARG1PTR];
		IF ARREQLLH(.TSTNODE)
		THEN
		BEGIN
			%(***ARG WHICH IS EQUAL TO LHS SHOULD ALWAYS BE THE 2ND***)%
			SWAPARGS(ARGNODE);
			RETURN TRUE
		END
		ELSE
		IF ARREQLLH(.ARGNODE[ARG2PTR])
		THEN RETURN TRUE
		ELSE
		%(***SEARCH THE TOP LEVEL N-ARY NODE***)%
		BEGIN
			NARYOPR_.ARGNODE[OPERATOR];
			SUBNODE_.ARGNODE[ARG1PTR];	!(EXPR'S ARE LEFT-BALANCED)

			%(***LOOP TO SEARCH FOR THE LHS WITHIN THE TOP-LEVEL NARY
				EXPRESSION*****)%
			WHILE (.SUBNODE[OPERATOR] EQL .NARYOPR) AND
				NOT (.SUBNODE[PARENFLG])
			DO
			BEGIN
				IF ARREQLLH(.SUBNODE[ARG2PTR])
				THEN
				BEGIN
					%(***EXCHANGE THE NODE THAT MATCHES WITH
						THE TOP-LEVEL RIGHT NODE***)%
					T1_.SUBNODE[ARG2PTR];
					SUBNODE[ARG2PTR]_.ARGNODE[ARG2PTR];
					ARGNODE[ARG2PTR]_.T1;
					T1_.SUBNODE[A2FLGS];
					SUBNODE[A2FLGS]_.ARGNODE[A2FLGS];
					ARGNODE[A2FLGS]_.T1;
					RETURN TRUE;
				END;

				%(***TREES ARE LEFT-BALANCED - THEREFORE EITHER
					EXAMINE THE LEFT-SON OR WALK DOWN TO IT***)%
				IF ARREQLLH(.SUBNODE[ARG1PTR])
				THEN
				BEGIN
					%(***EXCHANGE THE NODE THAT MATCHES WITH
						THE NODE AT THE TOP-LEVEL
						RIGHT*****)%
					T1_.SUBNODE[ARG1PTR];
					SUBNODE[ARG1PTR]_.ARGNODE[ARG2PTR];
					ARGNODE[ARG2PTR]_.T1;
					T1_.SUBNODE[A1FLGS];
					SUBNODE[A1FLGS]_.ARGNODE[A2FLGS];
					ARGNODE[A2FLGS]_.T1;
					RETURN TRUE;

				END
				ELSE
				SUBNODE_.SUBNODE[ARG1PTR];
			END;

		END
	END;

	%(***IF FALL THRU TO HERE, WERE UNSUCCESSFUL*******)%
	RETURN FALSE;
END;



GLOBAL ROUTINE SPECTOMEM(RHNODE)=
%(***************************************************************************
	TESTS WHETHER THE NODE "RHNODE" HAS AN OPERATOR IN THE "SPECOP" CLASS
	(IE THE CLASS INCLUDING P2MUL,SQR,ETC) THAT CAN BE PERFORMED TO MEMORY.
	THIS ROUTINE IS ONLY CALLED IF THE OPERATOR IS KNOWN TO BE IN OPRCLS
	"SPECOP"
***************************************************************************)%
BEGIN
	MAP PEXPRNODE RHNODE;

	%(***P2MUL,P2DIV, AND RAISE TO POWER OF 4, CANNOT BE PERFORMED TO MEMORY***)%
	IF .RHNODE[OPERSP] EQL P2MULOP OR .RHNODE[OPERSP] EQL P2DIVOP OR .RHNODE[OPERSP] EQL P4OP
	THEN RETURN FALSE;

	%(***DOUBLE PREC OPS CANNOT BE PERFORMED TO MEMORY***)%
	IF .RHNODE[VALTYPE] EQL DOUBLPREC THEN RETURN FALSE;

	%(***P2-PLUS-1 MULTIPLY, SQUARE, AND CUBE CAN BE PERFORMED TO MEMORY***)%
	RETURN TRUE;
END;
 