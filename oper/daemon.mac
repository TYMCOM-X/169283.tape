TITLE DAEMON - PROGRAM TO SERVICE USER REQUESTS V7(52)
SUBTTL D BLACK/DAL/RCC/JSL

VWHO==0			;WHO LAST UPDATED THIS CUSP
VDAEMON==7
VMINOR==0		;MINOR VERSION NUMBER
VEDIT==52

;COPYRIGHT (C) 1971; 1972 BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.

	.JBVER==137
	LOC	.JBVER
	BYTE	(3)VWHO(9)VDAEMON(6)VMINOR(18)VEDIT
	RELOC

	DEFINE	ND(SYMBOL,VALUE),<
	IFNDEF SYMBOL,<SYMBOL==VALUE>
	SYMBOL==SYMBOL	>

ND	PURESW,0	;NOT NORMALLY HIGH SEG
ND	FTSPY,1		;NON-ZERO TO ALLOW SPY FOR GETTABS AND PEEKS
ND	FTDET,1		;NON-ZERO TO RUN DAEMON DETACHED
ND	FTERR,1		;NON-ZERO TO LOG HARDWARE ERRORS
ND	FTCLCK,1	;NON-ZERO TO SUPPORT .CLOCK FUNCTION
ND	FTUSCN,0	;NON-ZERO TO ENABLE PERIODIC ERROR.SYS SAMPLING OF ALL UNITS
ND	CPUN,2		;MAX NO OF CPU'S TO LOG ERRORS ON
ND	CHNN,10		;NO OF CHANNELS  TO LOG ERRORS
ND	UNITN,40	;MAX NO OF UNITS TO LOG ERRORS
ND	ERRDEV,SIXBIT/SYS/
ND	ERRPPN,<1,,4>	;UFD (DEFAULT SYS:) FOR HARDWARE ERROR LOG FILE
ND	ERRSIZ,40	;LARGEST ERROR-FILE TRANSACTION
ND	FTFACT,1	;0 TO SUPPRESS FACT FILE AND CALLS
			;-1 TO RETURN ERROR ON .FACT FUNCTION
IFE FTFACT,<ND FTCHKPNT,0>	;RE-DEFAULT CHKPNT IF FACT TURNED OFF
ND	FTCHKPNT,1	;0 TO SUPPRESS CHKPNT FCN
ND	FCTDEV,SIXBIT/SYS/
ND	FCTPPN,<1,,4>	;UFD (DEFAULT SYS:) FOR FACT.SYS
ND	TRNSIZ,20	;LARGEST SINGLE FACT-FILE TRANSACTION
ND	MAXUCR,1000	;MAXIMUM BLOCK TO READ FROM USER CORE
ND	SLPCNT,^D60	;TIME TO SLEEP IF NO WORK
ND	PDLEN,50	;LENGTH OF PUSH DOWN LIST
ND	MAXSWP,10	;MAXIMUM NUMBER OF UNITS FOR SWAPPING
ND	DPTHLN,10	;MAX LENGTH OF PATH SPEC
ND	MAXFCT,^D800	;WORDS IN FACT BUFFER
			; - ADJUST TO BRING DAEMON CLOSE TO EVEN K BOUNDARY
ND	MAXAGE,^D600	;MAX TIME (SECS) A FACT ENTRY MAY SIT IN DAEMON
ND	CHKTIM,^D600	;SECONDS BETWEEN CHECKPOINTS
ND	USCTIM,^D3600	;SECONDS BETWEEN UNIT SCANS
ND	ICLKRQ,3	;NO OF INTERNAL CLOCK REQUEST TYPES
ND	CHKRQ,0		;CHECKPOINT REQUEST DUMMY JOB #
ND	USCRQ,-1	;UNIT SCAN REQUEST DUMMY JOB #
ND	AGERQ,-2	;DUMMY JOB TO FORCE OUT OLD FACT ENTRIES
;AC'S

SF=0		;SCANNER FLAGS
S1=1		;SCANNER PARAM REG
T1=1		;TEMP AC'S
T2=2
T3=3
T4=4
P1=5		;PERMANENT AC'S
P2=6
P3=7
J=10		;JOB NUMBER BEING SERVICED
P4=11		;PERMANENT AC
S=12		;SEGMENT NUMBER OF HIGH SEGMENT IF ANY
F=13		;FLAGS
SN=14		;SCANER'S NAME OR NUMBER ACCUMULATOR
BP=15		;BYTE POINTER FOR OUTPUT
SC=16		;16 USED AS CHAR AC IN COMMAND SCANNER
P=17		;PUSH DOWN LIST PTR

EXECT1==26	;EXEC AC T1 IN USER'S ADDRESS SPACE DURING DAEMON UUO
EXECT2==27	;EXEC AC T2

;I/O CHANNELS

DSK==6
SWP==7
FCT==10

;EXTERNS IN COMMAND SCANNER

	EXTERN	CPOPJ1,.ISCAN,MAKPJN,FILIN,F.ZER,TOCT,TPPN,TSIXN,TYIA
	EXTERN	SIXINW,NAME

;JOB DATA AREA SYMBOLS

	EXTERN	.JBREL,.JBHRL,.JBFF,.JBINT,.JBDA,.JBPFI,.JBDDT
;FLAGS IN F

L.DUMP==(1B0)		;SET IF DUMP, NOT IF DCORE
L.ANY==(1B1)		;SET IF ANY JOBS REQUIRING DAEMON SERVICE FOUND DURING SCAN
L.WJ==(1B2)		;SET IF WANT GETTAB FOR JOB
L.WS==(1B3)		;SET IF WANT GETTAB FOR HIGH SEGMENT
L.TTYA==(1B4)		;SET IF TTY IS ATTACHED
L.UUO==(1B5)		;SET IF DAEMON STARTED BY UUO
L.OPRA==(1B6)		;SET IF OPR WANTS TO KEEP IN TOUCH
L.FORC==(1B7)		;SET TO FORCE DUMP OF FACT.SYS BUFFER
L.FACT==(1B8)		;SET TO SUPPRESS FACT UUO FUNCTION
L.CHK==(1B9)		;SET TO SUPPRESS CHECKPOINT FUNCTION
L.ERR==(1B10)		;SET TO SUPPRESS LOGGING HARDWARE ERRORS
L.USC==(1B11)		;SET TO SUPPRESS UNIT SCANS
L.STOP==(1B12)		;SET IF OPR WANTS TO SHUT DOWN
R.SWIN==1B18		;SET BY FINCHK IF JOB BEING SWAPPED IN

;FLAGS IN SF (SCANER'S FLAGS)

S.EOF==1B33		;EOF ON INPUT

;CATEGORY NUMBERS FOR VARIOUS PIECES OF THE DAEMON CORE IMAGE FILE

CA.JOB==1	;JOB INFORMATION
CA.CNF==2	;CONFIGURATION TABLE
CA.DDB==3	;DDB'S
CA.COR==4	;USER'S CORE
CA.FET==5	;FEATURES IN THIS MONITOR

;ERROR CODES FOR DAEMON

E.DILF==1	;ILLEGAL FUNCTION
E.DIAD==2	;ADDRESS CHECK
E.DWNA==3	;WRONG NUMBER OF ARGUMENTS
E.DSNH==4	;SHOULD NEVER HAPPEN
E.DCWF==5	;CAN NOT WRITE FILE
E.DNPV==6	;NOT A PRIV. JOB
E.DFFB==7	;FACT FORMAT BAD
E.DPTH==10	;INVALID PATH (NO 0 FOUND TO END SFD LIST)

;DAEMON UUO FUNCTIONS

.DCORE==1	;WRITE A DCORE FILE
.CLOCK==2	;DO A WAKE
.FACT==3	;WRITE INTO THE FACT FILE
;GETTAB TABLES	DESCRIPTION			INDEX BY

.GTSTS==0	;JBTSTS WORD			JOB OR SEGMENT NUMBER
.GTADR==1	;PROTECTION,,RELOCATION 	JOB OR SEGMENT NUMBER
.GTPPN==2	;PROJECT PROGRAMMER NUMBER	JOB OR SEGMENT NUMBER
.GTPRG==3	;NAME OF PROGRAM		JOB OR SEGMENT NUMBER
.GTTIM==4	;TOTAL TIME USED		JOB NUMBER
.GTKCT==5	;KILO-CORE TICKS USED		JOB NUMBER
.GTPRV==6	;JOB PRIVILEGES			JOB NUMBER
.GTSWP==7	;SWAPPING POINTER		JOB OR SEGMENT NUMBER
.GTTTY==10	;JOB TO LDB TABLE		JOB NUMBER
.GTCNF==11	;CONFIGURATION TABLE		ITEM NUMBER
.GTNSW==12	;NON SWAPPING DATA FOR SYSTEM	ITEM NUMBER
.GTSDT==13	;SWAPPING DATA FOR SYSTEM	ITEM NUMBER
.GTSGN==14	;HIGH SEGMENT NUM BEING USED	JOB NUMBER
.GTODP==15	;ONCE ONLY DISK PARAMETERS	ITEM NUMBER
.GTLVD==16	;LEVEL D DISK PARAMETERS	ITEM NUMBER
.GTRCT==17	;DISK BLOCKS READ		JOB NUMBER
.GTWCT==20	;DISK BLOCKS WRITTEN		JOB NUMBER
.GTDBS==21	;DISK BLOCK SECONDS		JOB NUMBER
.GTTDB==22	;TOTAL DISK BLOCKS ALLOCATED	JOB NUMBER
.GTSLF==23	;TABLE OF ADDRESSES FOR GETTABS ITEM NUMBER
.GTDEV==24	;DEVICE OF SHARABLE HIGH SEG	SEGMENT NUMBER
.GTWSN==25	;SIXBIT NAMES FOR JOB QUEUES	ITEM NUMBER
.GTLOC==26	;JOB'S LOGICAL STATION		JOB NUMBER
.GTNM1==31	;FIRST HALF OF USER'S NAME	JOB NUMBER
.GTNM2==32	;SECOND HALF OF USER'S NAME	JOB NUMBER
.GTCNO==33	;CHARGE NUMBER			JOB NUMBER
.GTTMP==34	;JOB TMPCOR PARAMETERS		JOB NUMBER
.GTWCH==35	;WATCH INFORMATION		JOB NUMBER
.GTSPL==36	;SPOOL INFORMATION		JOB NUMBER
.GTRTD==37	;REAL TIME STATUS		JOB NUMBER
.GTLIM==40	;JOB TIME LIMIT			JOB NUMBER
.GTQQQ==41	;QUEUE HEADERS			ITEM NUMBER
.GTQJB==42	;JOB QUEUE			JOB NUMBER
.GTRSP==50	;JOB'S RESPONSE TIME COUNTER	JOB NUMBER
.GTSYS==51	;SYSTEM - WIDE DATA		ITEM NUMBER
.GTWHY==52	;OPR COMMENTS TO WHY RELOAD IN ASCIZ
.GTTRQ==53	;JOB'S TOTAL TIME IN RUN QUEUES	JOB NUMBER
.GTSPS==54	;SECOND PROCESSOR STATUS	JOB NUMBER
.GTC0C==55	;CPU 0 CDB CONSTANTS		ITEM NUMBER
.GTC0V==56	;CPU 0 CDB VARIABLES		ITEM NUMBER
.GTFET==71	;FEATURE - TEST TABLE
;GETTAB ITEMS FOR VARIOUS TABLES

%CNFG0==0	;CNFTBL - FIRST WORD OF 5-WORD SYSTEM NAME
%CNDT1==6	;CNFTBL - 2ND WORD OF MONITOR CREATION DATE
%CNTIM==10	;CNFTBL - TIME OF DAY IN JIFFIES
%CNDAT==11	;CNFTBL - TODAY'S DATE IN 12-BIT FORMAT
SYSSIZ==12	;CNFTBL - HIGHEST LOC IN MONITOR + 1
DEVLST==14	;CNFTBL - LH=ADDR OF DDB CHAIN
SEGPTR==15	;CNFTBL - - NUMBER OF SEGMENTS, NUMBER OF JOBS IN SYSTEM
%CNSTS==17	;CNFTBL - STATES WORD
%CNSER==20	;CNFTBL - CPU 0 SERIAL NUMBER
PTYPAR==22	;CNFTBL - LH=OFFSET FOR PTY'S, RH=NUMBER OF PTY'S
%CNVER==34	;CNFTBL - MONITOR VERSION NUMBER
%CNWHY==43	;CNFTBL - UN-ABBREVIATED WHY-RELOAD RESPONSE IN SIXBIT
%CNTIC==44	;CNFTBL - TICKS (JIFFIES) PER SECOND
%CNCHN==47	;CNFTBL - LH=POINTER TO CHANNEL DATA BLOCK CHAIN
PDBPTX==45	;PDB POINTER, POINTS TO JBTPDB IN LOW CORE.
UPTIME==15	;NSWTBL - UP TIME IN JIFFIES
%NSUPT==15	;UPTIME
%NSKTM==35	;NSWTBL - KSYS TIMER (MINUTES UNTIL SYS GOES DOWN)
%SWFIN==2	;.GTSDT - +JOB # WAITING TO SWAP OUT, OR - JOB # TO SWAP IN
MFDPPG==0	;LVDTBL - MFD PPN
SYSPPN==1	;LVDTBL - WHERE THE CUSPS ARE
FSFPPN==2	;LVDTBL - FULL FILE ACCESS PPN
SYSUNI==7	;LVDTBL - LH=ADDR OF FIRST UNIT DATA BLOCK, RH=UNISYS
SWPUNI==10	;LVDTBL - LH=ADDR OF FIRST UNIT FOR SWAP, RH=UNISWP
DACODE=='JD'	;STSTBL - QUEUE CODE FOR DAEMON QUEUE
GT.PRC==1B9	;BIT IN A GETTAB ENTRY IN NUMTAB WHICH SAYS DATA IS IN PDB
SY.ERR==0	;SYSTBL - COUNT OF SYSTEM HARDWARE ERRORS
%CCPHY==5	;CDB CONST - CPU NAME
%CCMPT==7	;CDB CONST - REL POINTER TO TABLE OF BAD ADDRESSES
%CCPAR==12	;CDB CONST - REL POINTER TO MORE PARITY INFO
%CVTPE==14	;CDB VARS - TOTAL PARITY ERRORS (HARD)
%CVSPE==15	;CDB VARS - "SPURIOUS" ERRORS (DID NOT RECUR)
%CVMPC==16	;CDB VARS - OPR CONTINUES FROM PAR ERRORS
%CVMPA==17	;CDB VARS - FIRST ADDRESS FOUND BAD, THIS SWEEP
%CVMPW==20	;CDB VARS - CONTENTS OF ABOVE LOC
%CVMPP==21	;CDB VARS - PC AT TIME OF ERROR (NOT COUNTING SWEEP)
%CVPTS==2	;CDB VARS(%CCPAR SUBTBL) - NO OF BAD ADDRESSES STORED THIS SWEEP
%CVPSC==3	;CDB VARS(%CCPAR SUBTBL) - NO OF SWEEPS BY THIS CPU
;BITS IN JBTSTS WORD - LH

JLOG==4		;LOGGED IN
JACCT==1	;THE GODLY BIT

;BITS IN JBTSTS WORD - RH

JRDC==100000	;SET IF JOB REQUIRES SERVICE BY DAEMON
JDEP==10000	;JOB WAITING IN DAEMON ERROR PAUSE

;HIBERNATE BITS - BITS RESTRICT WAKE UUO TO:

HB.RWT==1B17	;ANY JOB IN SAME PROJECT
HB.RWP==1B16	;SAME PROGRAMMER
HB.RWJ==1B15	;THIS JOB ONLY

HB.RTC==1B14	;WAKEN ON TTY CHARACTER ACTIVITY
HB.RTL==1B13	;WAKEN ON TTY LINE COMPLETE
HB.RPT==1B12	;WAKEN ON PTY ACTIVITY
HB.SWP==1B0	;SWAP OUT IMMEDIATELY

;GOBSTR ARGUMENTS

GOBJOB==0	;JOB NUMBER
GOBPPN==1	;PROJECT PROGRAMMER NUMBER
GOBNAM==2	;FILE STRUCTURE NAME
GOBSTS==4	;STATUS BITS

GOBLEN==5	;LENGTH OF BLOCK

;BITS IN GOBSTR STATUS WORD - LH

GL.NCR==200000	;NO CREATE BIT

;CHECK ACCESS UUO FUNCTIONS

AC.SUP==1	;CHECK IF MAY SUPERSEDE
AC.CRE==7	;CHECK IF MAY CREATE IN UFD

;DEVCHR BITS - LH

DV.DSK==200000	;BIT 1=1 IF DEVICE IS A DISK
DV.LNG==1000	;BIT 8=1 IF DEVICE HAS A LONG DISPATCH TABLE

;DSKCHR VALUES

D.SLB==17	;INDEX IN DSKCHR BLOCK FOR FIRST SWAPPING LOGICAL BLOCK

;CLOSE MODIFIER BITS

CL.NMB==20	;DO NOT DELETE NAME BLOCKS
;DDB ENTRIES

DEVNAM==0	;NAME OF DEVICE
.DVCHR==1	;CONTAINS JOB NUMBER
DEVSER==3	;LH POINTS TO NEXT DDB
DEVMOD==4	;CONTAINS DEVCHR BITS

		;DDB LENGTHS INCREASED BY 1 IN 5.05 FOR DEVEVM
LDDBSH==15	;LENGTH OF SHORT DDB
LDDBLN==17	;LENGTH OF DDB'S WITH LONG DISPATCH TABLES
LDDBDS==44	;LENGTH OF DISK DDB'S

;CHANNEL DATA BLOCK ITEMS

.CHSYS==1	;LH - POINTER TO NEXT CHAN DATA BLOCK
.CHLUE==1	;RH - POINTER TO UDB WITH MOST RECENT ERROR
.CHICW==2	;INITIAL CONTROL WORD FROM LAST ERROR
.CHFCW==3	;FINAL C W AS STORED BY CHANNEL
.CHCW2==4	;ERROR CONTROL WORD -2
.CHCW1==5	;ERROR CONTROL WORD -1
.CHCW0==6	;CONTROL WORD POINTED TO BY .CHFCW
.CHDW2==7	;ERROR DATA WORD -2
.CHDW1==10	;ERROR DATA WORD -1
.CHDW0==11	;DATA WORD POINTED TO BY .CHFCW
.CHMPE==12	;COUNT OF MEM PAR ERRS ON THIS CHANNEL
.CHDPE==13	;COUNT OF DEVICE PARITY ERRORS ON THIS CHANNEL
.CHNXM==14	;COUNT OF NON-EX MEMS ON THIS CHANNEL
;UNIT DATA BLOCK ITEMS

UNINAM==0	;UNIT NAME
UNILOG==1	;LOGICAL UNIT WITHIN STR
UNIHID==2	;SIXBIT HOME-BLOCK ID NAME (PACK ID)
UNISYS==3	;LH - ADDR OF NEXT UNIT DATA BLOCK IN SYSTEM
		;0 = NO MORE
UNISTR==4	;LH - ADDR OF NEXT UNIT DATA BLOCK IN STRUCTURE
		;RH - UP POINTER TO STR DATA BLOCK
UNICHN==5	;LH - ADDR OF NEXT UDB ON SAME CHANNEL (RING)
		;RH - UP POINTER TO CHAN DATA BLOCK
UNISWP==7	;POINTER TO NEXT SWAPPING UNIT
UNIHCT==10	;HARD (UNRECOVERABLE) ERRORS ON THIS UNIT
		;LH - DEVICE & SEARCH ERRORS
		;RH - DATA ERRORS
UNISCT==11	;SOFT (RECOVERABLE) ERRORS - INCREMENTED WHEN
		;RECOVERY SUCCEEDS. HALVES SAME AS UNIHCT.
UNIMCT==12	;SOFTWARE-DETECTED ERRORS (3 FIELDS OF 12 BITS)
		;SAT FAILURES, RIB REDUNDANCY ERRORS, FOLDED CHKSUM
UNIERR==13	;LAST ERROR STATUS ON DEVICE AFTER FIRST RECOVERY ATTEMPT
UNISOF==14	;ERROR STATUS BEFORE RECOVERY ATTEMPT
UNIHBN==15	;LOGICAL BLOCK NO OF LAST HARD ERROR
UNIBRC==16	;BLOCKS READ IN BUFFERED MODE
UNIBWC==17	;BLOCKS WRITTEN IN BUFFERED MODE
UNIDRC==20	;BLOCKS READ IN DUMP MODE (INCLUDING GET'S)
UNIDWC==21	;BLOCKS WRITTEN IN DUMP MODE (INCLUDING SAVE'S)
UNIMRC==22	;BLOCKS READ FOR MONITOR (SAT,UFD,MFC,BAT,SWAP)
UNIMWC==23	;BLOCKS WRITTEN FOR MONITOR
UNIICT==24	;SWAP READS (ALSO COUNTED IN UNIMWC)
UNIOCT==25	;SWAP WRITES (ALSO IN UNIMWC)
UNIMSC==26	;NO OF MONITOR & SWAPPING SEEKS
UNIUSC==27	;NO OF USER (INCLUDING GET & SAVE) SEEKS
UNIPCT==30	;SEEK INCOMPLETE ERRORS
UNISDI==32	;DATAI WORD ON LAST ERROR BEFORE RECOVERY ATTEMPT
UNIHDI==33	;DATAI WORD AFTER FAILURE OF FIRST RECOVERY ATTEMPT
UNIECT==34	;NO OF RETRIES+INITIAL ATTEMPT WHICH FAILED
		;BIT 0 SET IF SUCCESSFUL OPERATIONS SINCE ERROR
UNIHNG==35	;HUNG RECOVERYS (4 FIELDS OF 9 BITS)
		;# NOT RECOVERED BY STOPPING UNIT IN TRANSFER STATE
		;# RECOVERED BY STOPPING UNIT IN TRANSFER STATE
		;# CAUSED BY UNIT IN POSITION STATE AND RECOVERED AUTOMATICALLY
		;# RECOVERED BY RESTARTING UNIT, WHICH WAS IDLE OR TRANSFER WAIT
UNICDA==40	;RH - ADDR OF DDB FOR CURRENT FILE
;STRUUO FUNCTIONS

.FSJSL==0	;RE-ARRANGE OWN SEARCH LIST
.FSDSL==1	;DEFINE JOB'S SEARCH LIST

;ATTACH UUO BITS

AT.MON==1B0	;BIT TO FORCE TTY TO MONITOR LEVEL
AT.USR==1B1	;BIT TO FORCE TTY TO USER LEVEL

;GETLCH BITS

GL.ITY==1B0	;DEVICE IS A PTY
GL.CTY==1B1	;DEVICE IS THE CTY
GL.DSP==1B2	;DEVICE IS A DISPLAY (VT05, VT06, ETC)

;CODES IN ERROR.SYS

ER.WHY==1	;WHY RELOAD WITH COMMENTS, IF ANY
ER.CMP==2	;OPR COMPLAINTS
ER.MPE==3	;MEM PAR ERROR
ER.NXM==4	;NON-EX MEM
ER.PAG==5	;PAGING FAILURE
ER.CPE==6	;CHANNEL-DETECTED MEM PAR ERROR OR NXM
ER.HDE==10	;HARDWARE-DETECTED DEVICE ERROR
ER.SDE==11	;SOFTWARE-DETECTED DEVICE ERROR
ER.USC==40	;INFO FROM GENERAL SCAN OF ALL UNITS (EVERY HOUR)
; 60-77		;RESERVED FOR DIAGNOSTIC INFORMATION
ER.HIA==377	;HIATUS IN ERROR.SYS
ER.EOF==777	;END OF FILE FLAG

EL.HED==3	;LENGTH OF STANDARD HEADER
EL.VER==0	;FORMAT VERSION OF ERROR.SYS

;MISC

BLKSPK==3	;BITS TO SHIFT TO CONVERTS K TO BLOCKS
BLKSPP==2	;BITS TO SHIFT TO CONVERT PAGES TO BLOCKS
WRDSPB==7	;BITS TO SHIFT TO CONVERT BLOCKS TO WORDS
WRDSPK==WRDSPB+BLKSPK
C.CR==15	;ASCII CARRIAGE RETURN
C.LF==12	;ASCII LINE FEED
EE.FBM==3	;FILE BEING MODIFIED ERROR CODE FOR ENTER
F.DEV==0	;INDEX IN FILE DESCRIPTOR FOR DEVICE
F.NAM==1	;INDEX FOR NAME
F.EXT==3	;INDEX FOR EXTENSION
F.DIR==4	;INDEX FOR DIRECTORY
F.PROT==6	;INDEX FOR PROTECTION
JW.WVR==(1B6)	;VERSION WATCH BIT IN .GTWCH
IFN PURESW,<
	TWOSEG		;IF HE REALLY WANTS IT,
	RELOC	400000	;MAKE IT SHARABLE
FTSPY==0		;CAN'T SPY WITH CODE IN HIGH SEG
>
CHKFCT==0		;THIS CONTROLS CODE USED BOTH BY FACT AND CHKPNT
IFG FTFACT,<CHKFCT==1>		;SET IF ASSEMBLING FACT UUO CODE
IFN FTCHKPNT,<CHKFCT==1>	;OR IF ASSEMBLING CHKPNT
IFG MAXUCR-1000,<MAXUCR==1000>	;IMPOSE JOBPEK LIMIT
IFL MAXUCR-<1_WRDSPB>,<MAXUCR==<1_WRDSPB>>	;AT LEAST ONE BLOCK
MAXUCR==MAXUCR&<-1_WRDSPB>	;FORCE BLOCK BOUNDARY
IFE FTERR,<	IFN FTUSCN,<
PRINTX	% FTUSCN IMPOSSIBLE WITH FTERR OFF
FTUSCN==0	>>

	OPDEF	PJRST	[JRST]
	OPDEF	PJSP	[JSP]
	OPDEF	PJUMPE	[JUMPE]

	OPDEF CHKACC [CALLI 100]
	OPDEF JOBPEK [CALLI 103]
	OPDEF ATTACH [CALLI 104]
	OPDEF DAEFIN [CALLI 105]
	OPDEF FRCUUO [CALLI 106]
SUBTTL INITIALIZE

DAEMON:	JFCL			;IN CASE OF CCL ENTRY
	RESET
	SETZB	J,ZER		;J=VALUE OF QUEUE CODE FOR DAEMON QUEUE
REPEAT 0,<		;I DON'T THINK THIS IS NECESSARY (JSL)
	MOVE	T1,.JBREL	;GET .JBREL
	ADDI	T1,2000		;BUMP BY 1K (WILL RETURN LATER)
	CORE	T1,		;RESET USRREL
	  EXIT			;NEED THIS MEMORY
>; END OF REPEAT 0 ON EXTRA CORE REQUEST
	MOVE	T1,[ZER,,ZER+1]
	BLT	T1,EZER		;CLEAR STORAGE LOCATIONS
	MOVSI	F,L.TTYA	;CLEAR FLAGS, NOTE TTY ATTACHED
	MOVEI	T1,E.EINT	;REENTER ADDRESS TO START WITH
	MOVEM	T1,INTADR
	MOVE	T1,[XWD 4,INTRES]	;ROUTINE TO RESTART AFTER ERROR INTERCEPTS
	MOVEM	T1,INTBLK	;STORE IN INTERCEPT BLOCK
	MOVEI	T1,-1		;ENABLE FOR ALL ERRORS
	HRRZM	T1,INTBLK+1
	MOVEI	T1,INTBLK
	MOVEM	T1,.JBINT	;SET UP JOB INTERCEPT BLOCK
	MOVE	P,PDL		;SET UP PUSH DOWN LIST
	HRROI	T1,.GTPPN
	GETTAB	T1,		;GET OUR PPN
	  SETO	T1,
	MOVE	T2,[FSFPPN,,.GTLVD]
	GETTAB	T2,		;GET FULL FILE ACCESS PPN
	  SETZ	T2,
	MOVEM	T2,OPRPPN	;STORE AWAY FOR LATER
	CAME	T1,T2		;SKIP IF HAVE FULL FILE ACCESS
	JRST	E.NFSF		;NO GOOD - SINCE JACCT ON, MUST VERIFY
				;THAT THE JOB HAS THE SYSTEM'S BLESSING
				;(MUST PROBABLY BE LOCAL TO KEEP UNDER CONTROL)

	PJOB	T1,		;OUR JOB NUMBER
	MOVEM	T1,THSJOB	;SAVE FOR LATER

	SETOM	THSLIN		;INDICATE OUR LINE
	GETLCH	THSLIN		;GET CONTROLLING LINE NO & BITS

	MOVE	T1,[XWD SEGPTR,.GTCNF]
	GETTAB	T1,		;GET LOWEST HIGH SEG NUMBER
	  MOVEI	T1,100		;ASSUME 64 IF PRE-GETTAB MONITOR
	SOJ	T1,		;DECR TO HIGHEST JOB NUMBER
	HRRZM	T1,HJOB		;SAVE FOR JOB SCANS
;HERE TO BUILD COPY OF GETTAB TABLE FOR GTBSPY
IFN FTSPY,<
	MOVE 	T1,[PDBPTX,,.GTCNF] ;FIND WHERE JBTPDB IS
	GETTAB	T1,		; FROM MONITOR
	  SETZ	T1,		;CLEAR IF NOT THERE
	MOVEM	T1,PDBPTR	;STORE FOR USE IN GETTAB SIMULATOR
	SETZB	T4,T3		;CLEAR T4 IN CASE CANT SPY (STORED IN MAXGTB)
	MOVE	T1,[SYSSIZ,,.GTCNF] ;GET SIZE OF SYSTEM
	GETTAB	T1,
	  JRST	NOSPY
	SUBI	T1,1		;HIGHEST LOC IN MONITOR
	SPY	T1,		;SET SPY
	  JRST	NOSPY		;CANT
	MOVE	T1,.JBFF	;FIRST AVAILABLE LOC
	MOVEM	T1,GTBST	;START OF GETTAB PTRS

NXTGTB:	AOS	T4,.JBFF	;NEW FIRST FREE
	CAMG	T4,.JBREL	;SKIP IF MUST EXPAND CORE
	JRST	NXTGT1		;NO, OK
	MOVE	T1,T4
	CORE	T1,		;EXPAND CORE
	  HALT	.		;HAS TO BE THERE
NXTGT1:	HRLZ	T1,T3		;NEXT TABLE PTR
	HRRI	T1,.GTSLF
	GETTAB	T1,		;GET NEXT TABLE PTR
	  JRST	ENDGTB		;THAT'S ALL
	TLZE	T1,37		;CLEAR MONITOR XR AND INDIRECT
	TLO	T1,T1		;SET OUR AC IF TABLE EXISTS
				; (IE, IF POINTER WAS INDEXED)
	TRO	T1,400000	;SET SPY BIT
	MOVEM	T1,-1(T4)	;STORE IN TABLE OF TABLE PTRS
	AOJA	T3,NXTGTB	;LOOP FOR ALL POSSIBLE GETTABS

ENDGTB:	SUB	T4,GTBST	;CURRENT-START=NUMBER+1
	SOJ	T4,		;NUMBER OF LEGAL GETTABS
NOSPY:	MOVEM	T4,MAXGTB	;SAVE NUMBER OF LEGAL GETTABS

>;END FTSPY COND
;HERE TO FIND QUEUE # FOR DAEMON WAIT

	SETZ	T2,
FNDDAQ:	HRLZ	T1,T2		;LH T1=NEXT WORD IN TABLE
	HRRI	T1,.GTWSN	;RH=QUEUE CODES TABLE
	PUSHJ	P,GTBSPY	;GET NEXT WORD IN QUEUE CODES TABLE
	  AOJA	J,NODAEQ	;NOT THERE, MAKE DAEMON QUEUE UNFINDABLE
	MOVE	T3,[POINT 12,T1]
FNDDA1:	TLNN	T3,770000	;SKIP IF MORE CODES IN THIS WORD
	AOJA	T2,FNDDAQ	;NO MORE, TRY NEXT WORD
	ILDB	T4,T3		;T4=NEXT CODE IN SIXBIT
	CAIE	T4,DACODE	;SKIP IF FOUND DAEMON QUEUE CODE
	AOJA	J,FNDDA1	;NO, TRY NEXT, COUNT CODES SKIPPED

;HERE WHEN FOUND DAEMON QUEUE CODE, NOW FIND CTY LINE NUMBER

NODAEQ:	MOVEM	J,DAQNAM	;SAVE DAEMON QUEUE CODE
	MOVE	T1,[PTYPAR,,.GTCNF]
	PUSHJ	P,GTBSPY	;GET OFFSET FOR PTY'S
	  SETO	T1,		;CANT GET IT
	HLRES	T1		;T1=OFFSET FOR PTY=LINE NUM OF CTY+1
	SUBI	T1,1		;LINE NUMBER OF CTY
	MOVEM	T1,CTYLIN	;STORE LINE NUMBER OF CTY
	JUMPGE	T1,GETSWP	;GET SWAPPING PARAMETERS IF OK
	OUTSTR	[ASCIZ .% DONT KNOW CTY LINE NUMBER
.]
;HERE TO SET UP SWAPPING TABLES
; OUGHT TO TRY SUPER USETI TO SEE IF IT WORKS

GETSWP:	MOVEI	T2,BLKSPK	;SETUP SHIFT VALUE FOR KA10'S AND EARLY
				;KI10 MONITORS
	MOVE	T3,[LSH T1,BLKSPK-BLKSPP] ;INSTR TO CONVERT K OF SWAP STO PAGES
	SETO	T1,
	AOBJN	T1,.+1		;TEST FOR KI10 PROCESSOR
	JUMPN	T1,SETBPG	;KA - GO USE BLKSPK
	MOVE	T1,[%CNVER,,.GTCNF]
	PUSHJ	P,GTBSPY	;GET MONITOR VERSION #
	  SETZ	T1,		;??
	ANDI	T1,-1		;CLEAR CUSTOMER VERSION FIELD
	CAIGE	T1,50510	;IS IT PRE 5.05 OR ANY SOUP THEREOF?
	JRST	SETBPG		;YES, SWAPPING SPACE IS IN K
	MOVEI	T2,BLKSPP	;NO, IT COUNTS SWAPPING SPACE IN PAGES
	MOVSI	T3,(JFCL)	;NO NEED TO CONVERT PAGES TO PAGES
SETBPG:	MOVEM	T2,BLKPAG	;STORE SHIFT COUNTER
	MOVEM	T3,PKLSH	;STORE INSTR TO CONVERT SWAP CHUNKS TO PAGES
	MOVE	T1,[SWPUNI,,.GTLVD]
	PUSHJ	P,GTBSPY	;GET ADDR OF FIRST SWAP UNIT, UNISWP
	  JRST	E.NSWP		;CANT GET SWAPPING PTR
	TRNN	T1,-1		;SKIP IF UNISWP SPECIFIED
	HRRI	T1,UNISWP	;NO, USE DEFAULT
	MOVSI	T3,-MAXSWP	;MAXIMUM NUMBER OF UNITS FOR SWAPPING
	MOVS	T2,T1		;RH=ADDR OF UNIT, LH=UNISWP
GETSW1:	TRNN	T2,-1		;SKIP IF ANOTHER UNIT FOR SWAPPING
	JRST	GETSWE		;NO MORE SWAPPING UNITS
	MOVEI	T1,UNINAM(T2)	;ADDRESS OF NAME OF UNIT
	PUSHJ	P,PEKSPY	;GET NAME OF UNIT
	MOVEM	T1,.SWPUN(T3)	;STORE IN NAME TABLE
	MOVEM	T1,DAEBUF	;AND IN BLOCK FOR DSKCHR
	MOVE	T1,[D.SLB+1,,DAEBUF]
	DSKCHR	T1,		;GET FIRST BLOCK FOR SWAPPING
	  JRST	E.DSWP		;DISK ERROR?
	MOVE	T1,DAEBUF+D.SLB	;FIRST BLOCK FOR SWAPPING
	MOVEM	T1,.UNSLB(T3)	;STORE IN TABLE
	HLRZ	T1,T2		;INDEX IN UNIT DATA BLOCK FOR NEXT SWAP UNIT
	ADDI	T1,(T2)		;ADDR OF PTR TO NEXT SWAPPING UNIT
	PUSHJ	P,PEKSPY	;GET ADDRESS OF NEXT SWAPPING UNIT
	HLR	T2,T1		;STORE IN RH T2
	AOBJN	T3,GETSW1	;LOOP FOR MAXIMUM NUMBER OF SWAP UNITS
	TRNE	T2,-1		;SKIP IF END OF LINE
	OUTSTR	[ASCIZ .% NOT ENOUGH TABLE SPACE FOR SWAPPING UNITS
.]

;GET, SAVE ORIGINAL FILE STRUCTURE SEARCH LIST FOR THIS JOB

GETSWE:	MOVEI	T1,.FSDSL	;DEFINE SEARCH LIST FUNCTION
	MOVEM	T1,SRCLST	;STORE IN FUNCTION BLOCK
	SETOM	SRCLST+1	;OUR JOB
	SETOM	SRCLST+2	;OUR PPN
IFN .FSDSL-1,<MOVEI T1,1>
	MOVEM	T1,SRCLST+3	;SET TO REMOVE UNLISTED STR'S, RATHER
				;THAN PUTTING INTO PASSIVE LIST
	MOVE	T1,[XWD SRCLST,USRLST]
	BLT	T1,USRLST+3	;COPY SAME TO USER LIST AREA
	MOVEI	T3,SRCLST+3	;AND USE THIS AREA, PLEASE
	SETOB	T1,T2		;OUR JOB, PPN
	PUSHJ	P,GETSRC	;GET OUR SEARCH LIST
	SUBI	T3,SRCLST-1	;END MINUS BEGINNING=LENGTH
	MOVSI	T3,(T3)		;THATS IN LEFT HALF
	HRRI	T3,SRCLST	;WITH ADDR IN RIGHT
	MOVEM	T3,PSRCH	;SAVE SO WE CAN GET THIS BACK
	STRUUO	T3,		;TRY TO SET THIS SEARCH LIST TO SEE IF IT WORKS
	  OUTSTR [ASCIZ .% CANT DEFINE OUR OWN SEARCH LIST
.]

	MOVE	T1,[MFDPPG,,.GTLVD]
	PUSHJ	P,GTBSPY
	  SETZ	T1,
	MOVEM	T1,MFDPPN

;HERE TO FIND OUT IF JOBPEK UUO WORKS

TSTJPK:	MOVEI	T1,T2
	HRLZ	T2,THSJOB	;OUR JOB NUMBER
	HRRI	T2,1		;1 WORD FROM OUR JOB TO OUR JOB
	MOVE	T3,[SECBUF,,SECBUF]
	JOBPEK	T1,		;TRANSFER A WORD FROM US TO US
	  JRST	E.JPEK		;NOT IMPLEMENTED
;HERE TO CHECK FOR OTHER DAEMON'S RUNNING AROUND

DAECHK:	HRLZ	T1,THSJOB
	HRRI	T1,.GTPRG	;GET OUR NAME
	PUSHJ	P,GTBSPY
	  JRST	GETJIF		;THIS IS POINTLESS
	CAME	T1,[SIXBIT/DAEMON/]
	JRST	GETJIF		;IF THIS ISN'T DAEMON, NO PROBLEM
	MOVE	J,HJOB		;HIGHEST JOB IN SYSTEM
DAELUP:	CAMN	J,THSJOB	;DO NOT LOOK AT OUR JOB
	SOJG	J,DAELUP
	JUMPLE	J,GETJIF	;QUIT AFTER LOOKING AT ALL JOBS
	HRROI	T1,.GTPRG	;GETTAB POINTER FOR PROGRAM NAME
	PUSHJ	P,GTBSPY
	  SETZ	T1,		;RATHER UNLIKELY, BUT...
	CAME	T1,[SIXBIT /DAEMON/]
	SOJA	J,DAELUP	;THAT'S NOT DAEMON, TRY NEXT
	HRROI	T1,.GTSTS	;GETTAB TABLE FOR JOB STATUS
	PUSHJ	P,GTBSPY	;MUST CHECK JACCT, SINCE ANYBODY
	  SETZ	T1,		;  CAN USE A NAME
	TLNN	T1,JACCT	;IS THIS THE SYS:DAEMON?
	SOJA	J,DAELUP	;NO--AREN'T YOU GLAD WE CHECKED?
	OUTSTR	[ASCIZ	/% DAEMON ALREADY RUNNING
PLEASE KILL ONE OF US
/]
	MOVEI	T1,^D60		;WAIT FOR OPR TO DO SOMETHING ABOUT IT
	SLEEP	T1,
	JRST	DAECHK		;CHECK AGAIN
;HERE TO GET SYSTEM CLOCK RATE (JIFFIES/SECOND)

GETJIF:	MOVE	T1,[XWD %CNTIC,.GTCNF]
	PUSHJ	P,GTBSPY
	  MOVEI	T1,^D60		;DEFAULT 60 HZ
	MOVEM	T1,JIFSEC	;STORE JIFFIES PER SECOND
	IMULI	T1,^D24*^D3600	;JIFFIES PER DAY
	MOVEM	T1,JIFDAY	;HOLD FOR DIVIDE
	MOVEI	T1,^D1000	;MILLISECONDS PER SECOND
	IDIV	T1,JIFSEC	;GET MILLISECONDS PER JIFFY
	MOVEM	T1,MILJIF	;STORE THAT, TOO

;HERE TO SET UP CLOCK FUNCTION TABLE

IFN ICLKRQ!FTCLCK,<
	MOVEI	T2,-ICLKRQ	;FIRST JOB IN QUEUE
	HRRM	T2,QPNTR	;SAVE FOR LATER
	MOVE	T2,.JBFF	;GET .JBFF
	ADDI	T2,ICLKRQ	;POINT TO JOB 0
	HRRM	T2,JBTCLK	;STORE THE POINTER
IFN FTCLCK,<
	HRRZ	T1,HJOB		;HIGHEST JOB # IN SYSTEM
	MOVNI	T3,ICLKRQ+1(T1)	;-VE LENGTH OF TABLE
>
IFE FTCLCK,<
	MOVNI	T3,ICLKRQ	;INTERNAL REQUESTS ONLY
>
	HRLM	T3,QPNTR	;STORE IN POINTER
IFN FTCLCK,<
	ADDI	T2,1(T1)	;NEW .JBFF
>
	MOVEM	T2,.JBFF	;STORE BACK
	CAMG	T2,.JBREL	;DO WE ALREADY HAVE ENOUGH?
	JRST	.+3		;YES, DON'T ASK FOR MORE
	CORE	T2,		;IN CASE WE NEED IT
	  OUTSTR [ASCIZ .? CANT GET CORE FOR CLOCK TABLE
.]
	MOVE	J,QPNTR		;QUEUE POINTER
	SETZM	@JBTCLK		;CLEAN OUT THE JUNK
	AOBJN	J,.-1		;SLOW BLT
>;END FTCLCK!ICLKRQ CONDITIONAL
IFN CHKFCT,<

;HERE TO SAVE RELOAD INFORMATION IN FACT.SYS

	PUSHJ	P,BUFAGE	;DON'T LET THIS ENTRY SIT TOO LONG
	MOVE	T1,[XWD 370000,3] ;GET BASIC RELOAD ENTRY HEADER
	HRRZM	T1,FACTSZ	;NOTE 3 WORDS IN BUFFER
	MOVE	T2,THSJOB	;GET OUR JOB NO
	DPB	T2,[POINT 9,T1,17]
	MOVE	T2,THSLIN	;GET OUR LINE & CHARACTERISTICS
	TLNE	T2,(GL.CTY)	;IS IT THE CTY?
	SETO	T2,		;YES, SPECIAL CODE FOR THAT
	DPB	T2,[POINT 12,T1,29]
	MOVEM	T1,FACTBF	;(0) HEADER WORD
	MOVE	T1,OPRPPN	;(1) THIS JOB'S PPN
	MOVEM	T1,FACTBF+1
	PUSHJ	P,FACTIM	;12 BITS DATE, 24 BITS TIME
	MOVEM	T1,FACTBF+2	;(2) DATE AND TIME

;ADD HERE OTHER RELOAD INFORMATION AS DESIRED
>

;HERE TO START INTERNAL TIMERS

IFN FTCHKPNT,<
IFN CHKTIM,<
	MOVEI	J,CHKRQ		;INSERT THE CHECKPOINT REQUEST
	MOVEI	T1,CHKTIM	;INTERVAL
	MOVEM	T1,CCTIM	;SAVE CURRENT CHECKPOINT INTERVAL
	PUSHJ	P,CLKREQ	;PUT IN THE REQUEST
>;END OF CHKTIM COND
>;END OF FTCHKPNT COND
IFN FTUSCN,<
IFN USCTIM,<
	MOVEI	T1,USCTIM	;START A UNIT SCAN EVERY HOUR
	MOVEM	T1,CUTIM	;SAVE CURRENT UNIT SCAN INTERVAL
	MOVEI	J,USCRQ		;APPROPRIATE DUMMY JOB #
	PUSHJ	P,CLKREQ	;STORE THE REQUEST
>;END USCTIM COND
>;END FTUSCN COND
;HERE TO SAVE WHY-RELOAD CODE AND OPR COMMENTS IN ERROR.SYS
IFN FTERR,<

	MOVSI	T1,ER.WHY_9	;CODE FOR WHY RELOAD
	PUSHJ	P,ERRINI	;(0-2) STORE HEADER, SETUP P4 AND CLEAR BUFFER
	MOVSI	T2,%CNFG0-%CNDT1-1 ;5 WORDS OF SYSTEM NAME, 2 DATE
IFN %CNFG0,<HRRI T2,%CNFG0>
CNFLUP:	MOVEI	T1,.GTCNF	;FROM CNFTBL
	HRLI	T1,(T2)
	PUSHJ	P,GTBSPY	;PICK UP NEXT WORD
	  SETZ	T1,		;HIGHLY UNLIKELY
	PUSH	P4,T1		;(3-11) SYSTEM NAME AND DATE
	AOBJN	T2,CNFLUP	;GET IT ALL
	MOVE	T1,[XWD %CNSTS,.GTCNF]
	PUSHJ	P,GTBSPY	;STATES WORD
	  SETZ	T1,
	PUSH	P4,T1		;(12) STATES WORD
	MOVE	T1,[XWD %CNVER,.GTCNF]
	PUSHJ	P,GTBSPY	;MONITOR VERSION
	  SETZ	T1,
	PUSH	P4,T1		;(13) MON VER
	MOVE	T1,[XWD %CNSER,.GTCNF]
	PUSHJ	P,GTBSPY	;CPU 0 SERIAL NUMBER
	  SETZ	T1,
	PUSH	P4,T1		;(14) SERIAL NUMBER
	MOVE	T1,[XWD %CNWHY,.GTCNF]
	PUSHJ	P,GTBSPY	;GET WHY RELOAD CODE IN SIXBIT
	  JRST	WHYOUT		;? VERY STRANGE
	JUMPE	T1,WHYOUT	;0 MEANS FTWHY OFF
	PUSH	P4,T1		;(15) ELSE SAVE THE ANSWER
	AOBJN	P4,.+1		;(16) LEAVE SPACE FOR POINTER WORD
EW%COM==16			;RELATIVE LOC'N OF POINTER WORD
	SETZ	T2,		;START AT FIRST WORD
WHYLUP:	MOVEI	T1,.GTWHY	;GETTAB FOR WHY-RELOAD COMMENTS IN ASCIZ
	HRLI	T1,(T2)		;DESIRED WORD THEREOF
	PUSHJ	P,GTBSPY	;GET IT
	  JRST	WHYCLS		;MUST NOT BE ONE
	JUMPE	T1,WHYCLS	;STOP AT END OF STRING
	PUSH	P4,T1		;SAVE 5 CHARACTERS
	AOJA	T2,WHYLUP	;GO FOR NEXT WORD
WHYCLS:	MOVEI	T1,ERABUF+EW%COM
	SUBI	T1,(P4)		;NEG LENGTH OF COMMENTS
	JUMPN	T1,.+2		;IF ANY, STORE POINTER
	SOJA	P4,WHYOUT	;BUT IF NONE, BACK UP END POINTER
	HRLI	T1,EW%COM+1	;(SWAPPED) AOBJN POINTER TO COMMENTS
	MOVSM	T1,ERABUF+EW%COM
WHYOUT:	PUSHJ	P,ERRFIN	;CLOSE THE ERROR FILE

>;END COND ON FTERR
;HERE TO DETACH TTY

DETTTY:	HRLZ	T1,THSLIN	;LH IS NOW LINE NUMBER, RH=0 TO DETACH
	HRRZ	T2,.JBDDT	;GET ADDR OF DDT IF ANY
	JUMPN	T2,NODET	;DONT DETACH IF DDT
	OUTSTR	[ASCIZ /DETACHING
./]
	ATTACH	T1,		;DETACH OUR TTY
	  JRST	E.NATT		;CAN'T, MUST NOT BE IMPLEMENTED
NODET:	TLZ	F,L.TTYA	;NOTE NO TTY ATTACHED
	MOVEI	T1,DALOOK	;NEW RESTART ADDRESS
	MOVEM	T1,INTADR
	SETOM	WTUERR		;INIT FLAG TO CATCH RECURSIVE EXIT ATTEMPTS
SUBTTL	CHECK FOR MONITOR-INITIATED DAEMON REQUEST

;HERE WHEN DAEMON AWAKENED
; IF A HARDWARE ERROR HAS BEEN DETECTED BY THE MONITOR, RECORD THE INFO
;COLLECTED INTO ERROR.SYS.  MONITOR COUNTERS GET BUMPED ON EVERY ERROR

DALOOK:	CAMN	P,PDL		;VERIFY STACK CORRECTNESS
	JRST	.+3		;IT'S OK, CONTINUE
	MOVEM	P,PDLGUF	;OR SAVE THE BAD GUY
	MOVE	P,PDL		;RESTORE GOODNESS
	MOVEI	T1,.GTSYS	;GETTAB FOR SYSERR
IFN SY.ERR,<HRLI T1,SY.ERR>
	PUSHJ	P,GTBSPY	;PICK UP SYSERR WORD
	  JRST	DALOKJ		;WELL, WHAT CAN YOU DO?
	CAMN	T1,SERCNT	;HAS THE COUNT CHANGED?
	JRST	DALOKJ		;NO, CANT BE SYSTEM REQUEST. LOOK FOR JOB
	MOVEM	T1,SERCNT	;YES, SAVE THIS VALUE, AND LOOK FOR CAUSE
	AOS	DERCNT		;COUNT THE NUMBER OF TIMES WE SAW CHANGES IN SYSERR

IFN FTERR,<
IFE FTDET,<
	TLNE	F,L.ERR		;HAS OPR SUPPREED ERROR LOGGING?
	JRST	DALOKJ		;YES, DO NOT LOG
>;END FTDET COND
;STILL IN FTERR COND
;HERE TO LOOK FOR MEMORY PARITY ERROR INFO IN CPU DATA BLOCKS

	MOVEI	T1,DALOKJ
	MOVEM	T1,INTADR	;SET INTERCEPT ADDRESS
IFN CPUN,<
	MOVSI	P1,-CPUN	;AOBJN WORD FOR CPU TABLES
CPLOOP:	MOVEI	P2,(P1)		;COPY CPU #
	LSH	P2,1		;DOUBLE TO INDEX GETTAB CDBS
	MOVSI	T3,%CCPAR	;LOOK AT PARITY SWEEP COUNT
	HRRI	T3,.GTC0C(P2)	;POINTER TO TABLE
	MOVSI	T2,.GTC0V(P2)	;TABLE CONTAINING TABLE
	HRRI	T2,%CVPSC	;SWEEP COUNT IN SUBTABLE
	PUSHJ	P,GSUBTB
	  JRST	.+2		;TABLE MUST NOT BE THERE
	JRST	CPCMLT		;COMPARE TO LAST TOTAL
	MOVSI	T1,%CVTPE	;LOOK AT PARITY ERROR COUNT
	HRRI	T1,.GTC0V(P2)	;IN APPROPRIATE CPU DATA BLOCK
	PUSHJ	P,GTBSPY
	  SETZ	T1,		;SEEMS PRETTY UNLIKELY
	MOVE	T2,T1		;HOLD FOR ADDING IN "SPURIOUS"
	MOVSI	T1,%CVSPE	;LOOK AT SPURIOUS ERROR COUNT
	HRRI	T1,.GTC0V(P2)	;IN THIS CPU'S BLOCK
	PUSHJ	P,GTBSPY
	  SETZ	T1,		;UNLIKELY, BUT BETTER ALLOW FOR IT
	ADD	T1,T2		;ADD NON-REPRODUCABLE TO TOTAL
CPCMLT:	CAMN	T1,$CPPAR(P1)	;COMPARE TO LAST TOTAL
	JRST	CPNXM		;NO PARITY ERRORS FOUND
	MOVEM	T1,$CPPAR(P1)	;SAVE NEW VALUE
	MOVSI	T1,ER.MPE_9	;INDICATE ERROR TYPE
	PUSHJ	P,GCPERR	;AND LOG ERROR INFO
CPNXM:				;WE DON'T COUNT NXM'S YET FOR CPU
NXTCPU:	AOBJN	T1,CPLOOP	;GO LOOK AT NEXT
>;END CPUN COND

;STILL IN FTERR CONDITIONAL
;HERE TO LOOK FOR I/O ERRORS (INCLUDING CHANNEL-DETECTED MEMORY PROBLEMS)

IFN CHNN,<
	MOVSI	P1,-CHNN
	MOVE	T1,[XWD %CNCHN,.GTCNF]
	PUSHJ	P,GTBSPY	;GET START OF CHAIN OF CHANNELS
	  JRST	DVESCN		;CAN'T --IGNORE
CHELUP:	HLRZ	P2,T1		;ADDR OF CHANNEL DATA BLOCK
	JUMPE	P2,DVESCN	;END OF CHAIN
	MOVEI	T1,.CHMPE(P2)	;COUNT OF MEM PAR'S ON THIS CHAN
	PUSHJ	P,PEKSPY
	MOVE	T2,T1		;HOLD TO ACCUMULATE TOTAL CHAN ERR'S
	MOVEI	T1,.CHNXM(P2)	;COUNT OF NON-EX MEM'S
	PUSHJ	P,PEKSPY
	ADD	T2,T1
	MOVEI	T1,.CHDPE(P2)	;DEVICE PARITY ERRORS
	PUSHJ	P,PEKSPY
	ADD	T2,T1		;TOTAL ERRORS DETECTED BY CHANNEL
	CAMN	T2,$CHERR(P1)	;COMPARE TO OLD TOTAL
	JRST	NXTCHN		;SAME AS LAST TIME
	MOVEM	T2,$CHERR(P1)	;SAVE NEW VALUE
	MOVSI	T1,ER.CPE_9	;CODE FOR CHANNEL ERROR
	PUSHJ	P,GCHERR	;RECORD IT
NXTCHN:	MOVEI	T1,.CHSYS(P2)	;POINT TO POINTER TO NEXT CHANNEL BLOCK
	PUSHJ	P,PEKSPY	;GET POINTER
	AOBJN	P1,CHELUP	;GO TO NEXT CHANNEL

>;END OF CHNN CONDITIONAL
;STILL IN FTERR COND
;HERE TO PICK UP UNIT ERRORS

DVESCN:
IFN UNITN,<
	MOVSI	P1,-UNITN	;# OF UNITS WE HAVE TABLES FOR
	MOVE	T1,[XWD SYSUNI,.GTLVD]
	PUSHJ	P,GTBSPY	;GET POINTER TO ALL UNIT DATA BLOCKS
	  JRST	DALOKJ		;FRUITLESS
DVELUP:	HLRZ	P3,T1		;ADDRESS OF NEXT UNIT DATA BLOCK
	JUMPE	P3,DALOKJ	;THAT'S ALL
	MOVEI	T1,UNIHCT(P3)	;UNIT HARD ERR COUNT
	PUSHJ	P,PEKSPY
	MOVE	T2,T1		;HOLD FOR ACCUMULATION
	MOVEI	T1,UNISCT(P3)	;UNIT SOFT ERR COUNT
	PUSHJ	P,PEKSPY
	ADD	T2,T1
	MOVEI	T1,UNIMCT(P3)	;UNIT SOFTWARE ERR COUNT
	PUSHJ	P,PEKSPY
	ADD	T2,T1
	MOVEI	T1,UNIPCT(P3)	;UNIT SEEK ERROR COUNT
	PUSHJ	P,PEKSPY
	ADD	T2,T1
	MOVEI	T1,UNIHNG(P3)	;UNIT HUNG COUNTS
	PUSHJ	P,PEKSPY
	ADD	T2,T1
	CAMN	T2,$UNIER(P1)	;SAME AS LAST TIME FOR THIS UNIT?
	JRST	NXTDEV		;YES, GO ON TO NEXT
	MOVEM	T2,$UNIER(P1)	;SAVE NEW VALUE
	MOVSI	T1,ER.HDE_9
	PUSHJ	P,GDVERR	;LOG DEVICE ERROR
NXTDEV:	MOVEI	T1,UNISYS(P3)	;POINTER TO NEXT UNIT DATA BLOCK
	PUSHJ	P,PEKSPY
	AOBJN	P1,DVELUP	;LOOP IF MORE TABLES FOR CHECKING

>;END UNITN COND
>;END FTERR CONDITIONAL

;	JRST	DALOKJ		;FALL THROUGH TO CHECK FOR JOBS NEEDING SERVICE
SUBTTL LOOK FOR A JOB REQUIRING DAEMON SERVICE

DALOKJ:	HRRZ	J,HJOB		;J=HIGHEST JOB NUMBER IN SYSTEM
DALOO1:	TLZ	F,L.DUMP	;CLEAR DUMP FLAG
	MOVEM	J,CURJOB	;SAVE LAST JOB EXAMINED FOR DEBUG
	HRROI	T1,.GTSTS
	PUSHJ	P,GTBSPY	;GET JBTSTS WORD FOR JOB
	  JRST	DALOO2		;CANT GET IT?
	TRNE	T1,JRDC!JDEP	;SKIP IF DOESN'T WANT DAEMON SERVICE
	JRST	DASERV		;DOES, GO PROCESS REQUEST
	LDB	T1,QUECOD	;GET CODE FOR DAEMON QUEUE
	CAMN	T1,DAQNAM	;SKIP IF NO IN DAEMON QUEUE
	JRST	UUSERV
DALOO2:	SOJG	J,DALOO1	;LOOP FOR ALL JOBS IN SYSTEM
	TLZE	F,L.ANY		;SKIP IF NO JOBS FOUND
	JRST	DALOOK		;DID SOMETHING, GO THROUGH AGAIN

IFN CHKFCT,<
	MOVE	T1,[XWD %NSKTM,.GTNSW]
	PUSHJ	P,GTBSPY	;CHECK FOR KSYS SOON
	  SETZ	T1,		;IF CAN'T GET IT, ASSUME NOT
	JUMPE	T1,.+2		;NO KSYS--CHECK FORCE BIT
	SOJLE	T1,.+2		;IF PAST, OR LESS THAN 1 MINUTE, FORCE
	TLZE	F,L.FORC	;SHOULD WE FORCE OUT THE FACT BUFFER?
	SKIPN	T1,FACTSZ	;YES, IF ANYTHING IN IT
	JRST	NXTWAK		;NO, OR NOTHING THERE
	HRLZI	P1,(T1)		;SIZE IN P1 LEFT
	HRRI	P1,FACTBF	;POINTER
	PUSHJ	P,APPEND	;GET RID OF IT
	JRST	DALOOK
>;END OF CHKFCT COND
;HERE TO CHECK FOR EXPIRED CLOCK REQUESTS

IFN FTCLCK!ICLKRQ,<
NXTWAK:	SKIPN	T2,NEXTUP	;GET THE NEXT JOB TO WAKE
	JRST	ZZZ		;THERE WAS NONE
	MOVE	T1,[XWD %NSUPT,.GTNSW]
	PUSHJ	P,GTBSPY	;GET THE UPTIME
	  JRST	WAKJOB		;UNLIKELY, WE HOPE
	SUB	T2,T1		;GET THE DIFFERENCE
	JUMPLE	T2,WAKJOB	;WAKE ANY JOBS THAT NEED IT,
				; AND RESCAN FROM DALOOK
	IMUL	T2,MILJIF	;CONVERT TO MILLISECONDS
	TLNE	T2,-1		;IS LEFT HALF EMPTY?
	MOVEI	T2,-1		;NO, SET MAX SLEEP TIME
>;END FTCLCK!ICLKRQ COND

ZZZ:
IFE FTDET,<
	TLZE	F,L.STOP	;TEST (ONLY ONCE) FOR STOP COMMAND
	JRST	ZZZXIT		;WE GOT ONE, QUIT NOW
>; END FTDET COND
	MOVEI	T1,SLPCNT	;TIME TO SLEEP
	HRLI	T2,(HB.RWJ!HB.RTL)	;ONLY MONITOR CAN WAKE US
	HIBER	T2,		;HIBERNATE
	  SLEEP	T1,		;ON SECOND THOUGHT SLEEP
	JRST	DALOOK		;NOW LOOK AGAIN

IFE FTDET,<
ZZZXIT:	PUSHJ	P,ATTCHK	;ARE WE ATTACHED?
	  JRST	.+2		;NO, DO NOT TYPE
	OUTSTR	[ASCIZ .DAEMON shutdown
.]
	EXIT	1,		;QUIT, BUT ALLOW RESTART
	JRST	DALOOK		;NOW CONTINUE
>;END FTDET COND
;HERE TO PROCESS JOB ISSUING DAEMON UUO

;FOR DAEMON UUO'S:
;P1=USER LOCATION EXECT1=EXEC AC T1, AND CONTAINS FUNCTION REQUESTED
;P2=USER LOCATION EXECT2=EXEC AC T2, AND CONTAINS +LENGTH,ADDR OF ARGUMENT LIST

;DAEMON RETURNS BY STORING AN ERROR CODE (OR THE ORIGINAL CONTENTS OF EXECT2)
;IN EXECT1 (NOTE, T1), WHICH WILL BE PASSED BACK TO THE USER IN HIS
;CALLING REGISTER, AND 0 IN EXECT2 FOR A SUCCESSFUL (SKIP) RETURN,
;OR NON-ZERO IN EXECT2 FOR A NON-SKIP RETURN.

UUSERV:	TLO	F,L.ANY!L.UUO	;SOMETHING HAPPENED, A UUO
	MOVEI	T1,DETUSR	;NEW RESTART ADDRESS
	MOVEM	T1,INTADR
	SETZM	THSOFF		;OFFSET=0 FORLOW SEGMENT
	MOVSI	T1,.JBDA	;GET JOB DATA AREA
	MOVE	T2,J		;JOB NUMBER
	PUSHJ	P,GTUCOR	;GET JOB'S JOB DATA AREA
	MOVE	P1,USRCOR+EXECT1 ;EXEC AC T1=FUNCTION REQUESTED
	JUMPLE	P1,UUERR1	;- OR 0 IS ILLEGAL
	CAILE	P1,MAXFNC	;SKIP IF LEGAL FUNCTION
	JRST	UUERR1		;TOO BIG
	MOVE	P2,USRCOR+EXECT2 ;P2=XWD
	MOVEM	P2,SAVXWD	;SAVE XWD
	JRST	@FNCADR-1(P1)	;CALL ROUTINE TO PROCESS REQUEST

FNCADR:
	EXP	DMPUUO		;.DCORE WRITE A DCORE FILE
	EXP	CLKUUO		;.CLOCK WAKE A JOB IN THE FUTURE
	EXP	FCTUUO		;.FACT APPEND TO FACT FILE
MAXFNC==.-FNCADR
;				;4 (.DMQUE) RESERVED FOR QUEUE FUNCTION
;				;5 (.DMERR) APPEND TO ERROR.SYS
;				;6 (.DMCTL) ENABLE/DISABLE DAEMON FUNCTIONS
;HERE FOR .DCORE FUNCTION
;CALL:
;	MOVE	AC,[XWD ARGLEN,ARGLST]
;	DAEMON	AC,
;	  ERROR RETURN
;	GOOD RETURN
;ARGLST:1	;.DCORE
;	DEVICE	;0 IMPLIES DSK
;	FILNAM	;0 IMPLIES NNNDAE WHERE NNN IS JOB # ISSUEING UUO
;	EXT	;0 IMPLIES TMP
;	PROT	;0 IMPLIES MONITOR DEFAULT
;	PPN	;OR POINTER TO PATH SPEC. 0 IMPLIES DEFAULT PATH.
;		;RESERVED FOR JOB # TO DUMP

DMPUUO:
REPEAT 0,<			;I DON'T THINK THIS IS NEEDED (JSL)
	SETZM	USRCOR		;CLEAR RESULT
	MOVE	T3,[USRCOR,,USRCOR+1] ;BLT POINTER
	BLT	T3,USRCOR+5	;ZAP
>;END OF REPEAT 0 ON CLEARING USRCOR
	MOVE	T1,P2		;T1=XWD
	TLNN	T1,-1		;WAS LENGTH GIVEN?
	HRLI	T1,1		;NO, DEFAULT EVERYTHING
	HLRZ	T2,T1		;COPY NUMBER OF ARGUMENTS
	CAILE	T2,6		;MORE THAN 6 ARGUMENTS
	JRST	UUERR3		;YES--WRONG NUMBER OF ARGS
	PUSHJ	P,UADCHK	;CHECK ADDRESS
	  JRST	UUERR2		;INVALID ADDRESS
	PUSHJ	P,GTUCOR	;COPY  HIM INTO ME
GOTSPC:	SKIPN	T1,USRCOR+1	;GET DEVICE NAME
	MOVSI	T1,'DSK'	;NONE--USE DSK:
	MOVEM	T1,D.DEV	;STORE AWAY
	SKIPE	T4,USRCOR+2	;GET FILE NAME
	JRST	WASFNM		;THER WAS ONE SO DO NOT REINVENT
	MOVEI	T2,(J)		;JOB NUMBER
	PUSHJ	P,MAKPJN	;MAKE CCL NUMBER
	HRRI	T4,'DAE'	;DEFAULT FILENAME
WASFNM:	MOVEM	T4,D.NAM	;STORE FILENAME
	SKIPN	T1,USRCOR+3	;GET EXTENSION
	MOVSI	T1,'TMP'	;DEFAULT EXTENSION
	MOVEM	T1,D.EXT	;STORE EXTENSION
	LDB	T1,[POINT 9,USRCOR+4,8] ;GET PROTECTION
	MOVEM	T1,D.PROT		;STORE PROTECTION
	SKIPE	T1,USRCOR+5	;GET PPN
	JRST	CHKPTH		;HANDLE PATH OR PPN
	PUSHJ	P,GETPTH	;READ USER'S DEFAULT PATH
	JRST	STOPPN		;STORE THE PPN
CHKPTH:	TLNE	T1,-1		;IS THIS A PATH POINTER, OR A PPN?
	JRST	STOPPN		;PPN, STORE IT DIRECTLY
	ADDI	T1,2		;PATH POINTER, IGNORE FIRST 2 WORDS
	HRLI	T1,DPTHLN-2	;READ UP TO MAX LENGTH
	PUSHJ	P,UADCHK	;VALIDATE PATH ADDRESS
	  JRST	UUERR2		;BOMB NOW
	PUSHJ	P,GTUCOR	;READ PATH SPEC
	MOVSI	T1,-DPTHLN+2	;READ THIS MANY WORDS
CPYPTH:	SKIPN	T2,USRCOR(T1)	;PICK NEXT WORD OF PATH SPEC
	JRST	ENDPTH		;ZERO MARKS END
	MOVEM	T2,D.DPTH+2(T1)	;STORE FOR OUR PURPOSES
	AOBJN	T1,CPYPTH	;COPY MORE IF WE HAVE ROOM
	JRST	UUER10		;NOTE INVALID PATH TO USER

ENDPTH:	SETZM	D.DPTH+2(T1)	;FLAG END OF PATH
	MOVEI	T1,D.DPTH	;SETUP DIRECTORY POINTER
STOPPN:	MOVEM	T1,D.DIR	;STORE DIRECTORY

;HERE CHECK PRIVILEGES IF JOB # TO DUMP SPECIFIED

	JRST	NODEFT		;DUMP. NO NEED TO SETUP DEFAULTS
;HERE FOR .CLOCK FUNCTION
;CALL:
;	MOVE	AC,[XWD ARGLEN,ARGLST]
;	DAEMON	AC,
;	  ERROR RETURN
;	GOOD RETURN
;ARGLST:2	;.CLOCK
;	# SECS BEFORE WAKE ;OVERRIDES ANY PENDING REQUEST, 
;			; 0 IMPLIES IMMEDIATE WAKE

IFN FTCLCK,<

CLKUUO:	MOVE	T1,P2		;T1=XWD
	TLNN	T1,-1		;LENGTH GIVEN?
	HRLI	T1,2		;NO, DEFAULT TO 2
	HLRZ	T2,T1		;COPY THE LENGTH
	CAILE	T2,2		;NEED 2 ARGS, 0 IMPLIES 2
	JRST	UUERR3		;WRONG NUMBER OF ARGUMENTS
	PUSHJ	P,UADCHK	;CHECK THE ADDRESS
	  JRST	UUERR2		;ADDRESS CHECK
	PUSHJ	P,GTUCOR	;READ HIS CORE IMAGE
	MOVE	T1,USRCOR+1	;GET THE TIME
	PUSHJ	P,CLKREQ	;PUT IN QUEUE
	JRST	UUOKX		;EXIT

>;END FTCLCK COND
;HERE FOR .FACT FUNCTION
IFG FTFACT,<

FCTUUO:
IFE FTDET,<
	TLNE	F,L.FACT	;IS FACT SUPPRESSED?
	JRST	UUOKX		;YES, GIVE GOOD RETURN, BUT DO NOTHING
>;END FTDET COND
	HRROI	T1,.GTSTS	;GET JOB'S STATUS
	PUSHJ	P,GTBSPY	;GO READ THE MONITOR
	  JRST	UUERR4		;YOU CAN'T WIN THEM ALL
	TLNE	T1,JACCT	;LOGIN OR LOGOUT
	JRST	GTFACT		;YES--WIN
	PUSHJ	P,GETPPN	;GET CALLER'S PPN
	CAME	T1,OPRPPN	;ARE YOU A GOOD GUY?
	JRST	UUERR6		;NO--GET LOST
GTFACT:	PUSHJ	P,BUFAGE	;MARK TIME OF FIRST FACT ENTRY
	MOVE	T1,P2		;PICK UP XWD
	TLNN	T1,-1		;WAS LENGTH GIVEN?
	HRLI	T1,1		;NO, DEFAULT TO TEST NOP
	PUSHJ	P,UADCHK	;VALIDATE THE BLOCK AND SET UP FOR GTUCOR
	  JRST	UUERR2		;INVALID
	HLRZ	T4,T1		;COPY LENGTH
	SOJL	T4,UUERR3	;TOO SHORT
	CAILE	T4,TRNSIZ	;TOO LONG
	JRST	UUERR3		;YES--WRONG NUMBER OF ARGS
	JUMPE	T4,UUOKX	;ALLOW A 0-LENGTH WRITE, AS A TEST NOP UUO
	HRL	T1,T4		;PUT BACK NEW LENGTH
	AOJ	T1,		;BUMP POINTER PAST FUNCTION
	PUSHJ	P,GTUCOR	;GET USER'S ARGUMENT LIST=FACT FILE ENTRY IN USRCOR
	SKIPE	USRCOR+2	;DID USER PROVIDE DATE AND TIME?
	JRST	.+3		;YES, DO NOT RE-SPECIFY
	PUSHJ	P,FACTIM	;GET TIME IN FACT FILE FORMAT
	MOVEM	T1,USRCOR+2	;AND INSERT IT IN BUFFER
	HLRZ	T1,P2		;GET LENGTH OF ARG LIST
	MOVE	T2,USRCOR	;PICK UP HEADER WORD FOR VALIDITY CHECKING
	TLZE	T2,777000	;CHECK FOR AND CLEAR TYPE IDENTIFIER
	TLZN	T2,777		;SAME FOR JOB #.  WERE BOTH GIVEN?
	JRST	UUERR7		;NO, REFUSE REQUEST
	ANDI	T2,77		;REMOVE LINE NO
	CAIE	T2,-1(T1)	;AND VERIFY LENGTH ACCURACY
	JRST	UUERR7		;REFUSE ON ANY SUCH ERROR
	HRRZ	T1,FACTSZ	;ADDR IN FACT FILE BUFFER TO STORE
	ADDB	T2,FACTSZ	;NEW SIZE OF BUFFER CONTENTS
	MOVEI	T1,FACTBF(T1)	;"TO" ADDR IN FACT FILE BUFFER
	HRLI	T1,USRCOR	;"FROM" IS CORE COPIED FROM CALLER
	BLT	T1,FACTBF-1(T2)	;TRANSFER TO FACT FILE BUFFER
	CAIG	T2,MAXFCT	;TOO MUCH IN BUFFER?
	JRST	UUOKX		;NO--GIVE OK RETURN
	HRLZI	P1,(T2)		;SIZE OF WHOLE MESS
	HRRI	P1,FACTBF	;POINTER TO BEGINING
	PUSHJ	P,APPEND	;UPDATE FACT.SYS
	JRST	UUOKX		;RETURN TO USER

>;END COND ON FTFACT
UUER10:	MOVEI	T1,E.DPTH	;INVALID PATH SPEC
	JRST	UUERRX

UUERR7:	MOVEI	T1,E.DFFB	;FACT FORMAT BAD
	JRST	UUERRX

UUERR6:	MOVEI	T1,E.DNPV	;NO PRIVS TO DO THAT UUO
	JRST	UUERRX		;EXIT

UUERR5:	MOVEI	T1,E.DCWF	;CAN'T WRITE FILE
	JRST	UUERRX		;EXIT

UUERR4:	MOVEI	T1,E.DSNH	;SHOULD NEVER HAPPEN
	JRST	UUERRX		; BUT...

UUERR3:	MOVEI	T1,E.DWNA	;WRONG NUMBER OF ARGS
	JRST	UUERRX

UUERR2:	MOVEI	T1,E.DIAD	;ADDRESS CHECK
	JRST	UUERRX		;ERROR EXIT

IFE FTCLCK,<CLKUUO:	>
IFL FTFACT,<FCTUUO:	>
UUERR1:	MOVEI	T1,E.DILF	;ILLEGAL FUNCTION ERROR CODE
;	JRST	UUERRX

;HERE FOR DAEMON UUO ERRORS, T1=ERROR CODE

UUERRX:	SETOM	USRCOR+1	;NOTE ERROR IN FUNCTION
	MOVE	P,PDL		;RESTORE P, SINCE ERROR MAY HAVE BEEN
				;AT ANY LEVEL ON THE STACK
	JRST	UUEXIT		;AND EXIT UUO

;HERE WHEN FUNCTION COMPELETED PROPERLY, T1=RETURN CODE

IFE FTFACT,<FCTUUO:	>
UUOKX:	SETZM	USRCOR+1	;NOTE FUNCTION COMPLETED PROPERLY
	MOVE	T1,SAVXWD	;GET OLD CONTENTS OF USERS REG
UUEXIT:	MOVEM	T1,USRCOR	;STORE CODE TO RETURN TO USER
	MOVE	T1,[2,,EXECT1]	;WRITE 2 WORDS AT USER'S EXEC AC T1
	MOVE	T2,J		;WRITE IN JOB'S LOW SEGMENT
	SETZM	THSOFF		;NO OFFSET
	AOSG	WTUERR		;CHECK FOR RECURSION IN EXIT PROCESS
	PUSHJ	P,WTUCOR	;WRITE USER'S CORE
	SETOM	WTUERR		;RESET FLAG
	JRST	DETUSR		;AND FINISH USER'S REQUEST
SUBTTL PROCESS JOB REQUESTING DAEMON SERVICE

;HERE OUGHT TO RECORD STATUS OF JOB INTO ERROR.SYS IF JDEP SET

DASERV:	TLZ	F,L.UUO		;NOT A UUO
	TRNE	T1,JDEP		;IF IN ERROR PAUSE,
	AOS	JDPCNT		;NOTE WE NOTICED
	TRNN	T1,JRDC		;IF NOT COMMAND REQUEST,
	JRST	EDUMP1		;RESTART THE JOB

;HERE TO PROCESS COMMAND WHICH INVOKED DAEMON

	MOVEI	T1,DETUSR	;NEW RESTART ADDRESS
	MOVEM	T1,INTADR
	TLO	F,L.ANY		;NOTE THAT WE DID SOMETHING
	PUSHJ	P,GETTTY	;GET JOB'S TTY NUMBER
	  JRST	DETUSR		;CAN'T FIND IT
	JUMPGE	T1,HAVLIN	;GO UNLESS CTY
	SKIPGE	T1,CTYLIN	;GET CTY LINE NO IF KNOWN
	JRST	DETUSR		;OTHERWISE, MUST GIVE UP

HAVLIN:	HRLM	T1,LINE		;SAVE LINE NUMBER, IT MAY BE USEFUL

;HERE SHOULD CHECK FOR CTL/C IN JOB STATUS, DETUSR IF SET

	HRLOS	T1		;LH=LINE NUMBER, RH=DAEMON JOB
	ATTACH	T1,		;ATTACH USER TTY TO US
	  JRST	DETUSR		;GIVE UP IF CANT ATTACH USER'S TTY
	TLO	F,L.TTYA	;NOTE TTY ATTACHED
	MOVEI	T1,EDUMP	;NEW RESTART ADDRESS
	MOVEM	T1,INTADR

	HRROI	T1,.GTWCH	;WATCH BITS TABLE
	PUSHJ	P,GTBSPY
	  SETZ	T1,		;FEATURE PROBABLY OFF
	TLNE	T1,JW.WVR	;IS VERSION WATCHING ENABLED?
	PUSHJ	P,PDAEVR	;YES, PRINT DAEMON VERSION
;HERE TO SET UP DEFAULTS FOR CORE-IMAGE FILE NAME

	MOVSI	T1,'DSK'	;DEVICE DSK
	MOVEM	T1,D.DEV
	MOVE	T2,J
	PUSHJ	P,MAKPJN	;COMPUTE SIXBIT JOB NUMBER IN LH
	MOVEM	T4,CCLFIL	;SAVE SIXBIT JOB NUMBER
	HRRI	T4,'DAE'	;NAME DAE
	MOVEM	T4,D.NAM	;IS FILE NAME
	MOVSI	T1,'TMP'	;EXTENSION
	MOVEM	T1,D.EXT
	SETZM	D.PROT		;DEFAULT PROTECTION IS STANDARD
	PUSHJ	P,GETPTH	;READ USER'S PATH
	MOVEM	T1,D.DIR	;STORE POINTER AS DIRECTORY

;HERE ON, CODE IS COMMON TO UUO AND COMMAND

NODEFT:	PUSHJ	P,GETPPN	;PICK UP USER'S PPN
	MOVEM	T1,USRPPN	;SAVE FOR ACCESS CHECKING

;HERE TO SET SEARCH LIST TO BE SAME AS USER'S JOB

	MOVE	T2,T1		;USER'S PPN
	MOVE	T1,J		;JOB NUMBER
	MOVEI	T3,USRLST+3	;SPACE RESERVED FOR USER'S SEARCH LIST
	PUSHJ	P,GETSRC	;GET USER'S SEARCH LIST
	HRRZS	T3		;LAST ADDRESS STORED IN
	MOVEI	T1,USRLST	;RE-GET USER LIST ADDRESS
	SUBI	T3,USRLST-1	;T3=LENGTH-1 OF LIST
	HRLI	T1,(T3)		;FUNCTION, ETC, ALREADY SET UP IN USRLST
	STRUUO	T1,		;SET OUR SEARCH LIST TO BE SAME AS USER'S
	  PUSHJ	P,E.USTR	;NOTE FAILURE OF STRUUO, TRY TO CONTINUE

;HERE TO INITIALIZE COMMAND SCANNER

	SETZ	SF,		;CLEAR SCANNER FLAGS
	TLNE	F,L.UUO		;IS THIS THE UUO
	JRST	DAEOPN		;YES--THEN AVOID SCANER
	PUSHJ	P,ATTCHK	;JUST MAKE SURE USER DIDN'T MANAGE TO DETACH
	  JRST	DAEOPN		;IF HE DID, ASSUME DCORE AND DON'T GO INTO TI WAIT
	MOVE	S1,[IOWD COMLEN,COMLST] ;TABLE OF MONITOR COMMANDS
INISCN:	PUSHJ	P,.ISCAN	;INITIALIZE COMMAND SCANNER
	JUMPL	S1,SCNEND	;NOT A MONITOR COMMAND, ASSUME DCORE
	JUMPE	S1,DCORE	;JUMP IF DCORE COMMAND
;HERE IF DUMP COMMAND - REWRITE COMMAND AS DUMP CCL FILE
;NOTE: FILE MUST BE ON DSK, NOT TMPCOR, BECAUSE TMPCOR
; CANNOT COMMUNICATE ACROSS JOBS.

	TLO	F,L.DUMP	;NOTE DUMP INSTEAD OF DCORE
	MOVE	T2,D.DEV
	SETZ	T1,
	MOVSI	T3,C.BH		;BUFFER HEADER
	OPEN	DSK,T1		;OPEN SAID FILE STRUCTURE
	  JRST	E.OPN		;CANT OPEN FILE STRUCTURE
	MOVE	T1,CCLFIL	;CCL NAME
	HRRI	T1,'DMP'	;FILE DMP
	MOVSI	T2,'TMP'	;EXT TMP
	SETZ	T3,
	MOVE	T4,D.DIR	;USER'S DIRECTORY
	PUSHJ	P,ACCCHK	;SEE IF USER ALLOWED TO WRITE THE STR
	  JRST	E.CCLP		;DONT HAVE PRIVILEGE TO WRITE
	ENTER	DSK,T1
	  JRST	E.DENT
	PUSH	P,.JBFF
	MOVEI	T1,SECBUF
	MOVEM	T1,.JBFF	;SET ADDR OF BUFFER FOR I/O
	OUTBUF	DSK,1
	POP	P,.JBFF
	JUMPL	SC,QUIKIE	;USE QUICKIE DUMP IF DUMP CR
CLOOP:	PUSHJ	P,TYIA		;GET NEXT CHAR FROM COMMAND
	JUMPL	SC,CDONE	;ALL DONE IF END OF LINE
	CAIN	SC,"/"		;SKIP IF NOT /
	JRST	CVSLSH		;CONVERT TO CRLF
	PUSHJ	P,CCOUT		;OUTPUT THE CHAR
	JRST	CLOOP		;AND LOOP

CVSLSH:	PUSHJ	P,CCCRLF	;OUTPUT CRLF INSTEAD OF /
	JRST	CLOOP

QUIKIE:	MOVE	T1,[POINT 7,QIKNAM]
QUIKI1:	ILDB	SC,T1		;NEXT CHARACTER OF NAME
	JUMPE	SC,CDONE
	PUSHJ	P,CCOUT		;OUTPUT CHARACTER
	JRST	QUIKI1

CDONE:	PUSHJ	P,CCCRLF	;END THE LAST LINE
	CLOSE	DSK,
	RELEASE	DSK,
	JRST	DAEOPN		;GO WRITE DAEMON FILE
;HERE TO PROCESS DCORE COMMAND

DCORE:	JUMPL	SC,DAEOPN	;USE DCORE DEFAULTS IF NO NAME SPECIFIED
	PUSHJ	P,FILIN		;GET FILE NAME TO WRITE
	SKIPE	T1,F.ZER+F.DEV	;SKIP IF NO DEVICE SPECIFIED
	MOVEM	T1,D.DEV
	SKIPE	T1,F.ZER+F.NAM	;SKIP IF NO NAME SPECIFIED
	MOVEM	T1,D.NAM
	JUMPE	T1,DCORE1	;JUMP IF NO NAME SPECIFIED
	MOVSI	T1,'DAE'	;IF FILE NAME SPECIFIED, DEFAULT EXT IS DAE
	MOVEM	T1,D.EXT
DCORE1:	SKIPE	T1,F.ZER+F.EXT	;SKIP IF NO EXT SPECIFIED
	MOVEM	T1,D.EXT
	SKIPE	T1,F.ZER+F.DIR	;SKIP IF NO DIRECTORY SPECIFIED
	MOVEM	T1,D.DIR
	SKIPE	T1,F.ZER+F.PROT	;SKIP IF NO PROTECTION SPECIFIED
	MOVEM	T1,D.PROT

SCNEND:	JUMPL	SC,DAEOPN	;EXIT IF ALREADY TO BREAK CHAR
	PUSHJ	P,TYIA		;IGNORE REST OF LINE
	JUMPGE	SC,.-1
SUBTTL WRITE CORE-IMAGE FILE

;HERE TO OPEN CORE-IMAGE FILE

DAEOPN:	MOVE	T1,D.DEV	;DEVICE TO WRITE ON
	MOVE	T2,T1		;AND SAVE IN T2
	DEVCHR	T1,		;GET DEVICE CHARACTERISTICS
	TLNN	T1,DV.DSK	;SKIP IF IT IS A DISK
	JRST	E.NDSK		;CANT GO ON
	MOVEI	T1,17		;USE DUMP MODE
	SETZB	T3,CURWRD	;START AT WORD 0
	OPEN	DSK,T1		;OPEN DEVICE
	  JRST	E.OPN		;CANT OPEN IT
	MOVEI	P1,5		;NUMBER OF TIMES TO RETRY IF FILE BEING MODIFIED
	MOVE	T1,D.NAM	;FILE NAME
	HLLZ	T2,D.EXT	;EXT
	HRLZ	T3,D.PROT	;PROTECTION
	LSH	T3,^D9
	MOVE	T4,D.DIR	;DIRECTORY TO WRITE IN
	PUSHJ	P,ACCCHK	;SEE IF USER IS ALLOWED TO WRITE THE FILE
	  JRST	E.DAEP		;DONT HAVE PRIVILEGES
RE1:	MOVE	T4,D.DIR	;DIRECTORY
	ENTER	DSK,T1		;CREATE THE FILE
	  JRST	E.F1		;CANT WRITE IT
	CLOSE	DSK,		;MAKE SURE FILE EXISTS FOR UPDATING
	MOVE	T4,D.DIR	;RESET THE PPN
	LOOKUP	DSK,T1		;LOOKUP
	  JRST	E.NOUL		;WHAT?
RE2:	MOVE	T4,D.DIR	;AND ONCE AGAIN FOR UPDATE ENTER
	ENTER	DSK,T1
	  JRST	E.F2		;SIGH
	SETZB	BP,CURBLK	;START AT FIRST BLOCK OF FILE
	MOVEI	T1,NOHGH1	;NEW RESTART ADDR
	MOVEM	T1,INTADR
SUBTTL WRITE JOB INFORMATION

;HERE TO WRITE JOB INFORMATION

	MOVEI	T1,CA.JOB	;CATEGORY NUMBER FOR JOB INFORMATION
	PUSHJ	P,CATSTA	;START UP CATEGORY
	MOVE	T1,.JBVER	;(0)DAEMON VERSION NUMBER
	PUSHJ	P,DWRITE	;WRITE IT
	DATE	T1,		;(1)TODAY'S DATE
	PUSHJ	P,DWRITE	;WRITE THAT
	MSTIME	T1,		;(2)TIME OF DAY IN MILLISECONDS
	PUSHJ	P,DWRITE	;WRITE IT
	HRROI	T1,.GTSGN	;SEGMENT TABLE
	PUSHJ	P,GTBSPY	;GET HIGH SEGMENT NUMBER IF ANY
	  SETZ	T1,
	MOVE	S,T1		;SAVE SEGMENT NUMBER IN S
	HRL	T1,J		;(3)LH=JOB NUMBER, RH=SEGMENT NUMBER
	PUSHJ	P,DWRITE	;WRITE THAT
	HLRZ	T1,LINE		;(4)LH=RESERVED, RH=LINE NUMBER
	PUSHJ	P,DWRITE	;AND WRITE THAT

;HERE TO WRITE GETTAB ENTRIES FOR JOB

	SKIPL	P1,[-GTTBLN,,GTTABL] ;SKIP IF ANY GETTABS WANTED
	JRST	GTTBJE		;NO GETTABS DESIRED
GTTBLP:	HLRZ	T2,(P1)		;T2=INDEX INTO ROUTINE
	HRRZ	T1,(P1)		;T1=GETTAB TABLE
	PUSHJ	P,WGTBTH(T2)	;GET JOB OR SEGMENT OR BOTH
	AOBJN	P1,GTTBLP	;LOOP FOR GETTABS DESIRED

;HERE AFTER ALL GETTABS FOR JOB WRITTEN - WRITE SYSTEM GETTABS

GTTBJE:	PUSHJ	P,CATEND	;END OF JOB INFORMATION CATEGORY

;HERE TO WRITE CONFIGURATION TABLE

	MOVEI	T1,CA.CNF	;BEGIN CONFIGURATION TABLE CATEGORY
	PUSHJ	P,CATSTA
	MOVEI	P1,.GTCNF
	PUSHJ	P,GTTBAL	;WRITE ALL OF TABLE
	PUSHJ	P,CATEND	;END OF CONFIGURATION CATEGORY

;HERE TO WRITE FEATURE TABLE

	MOVEI	T1,CA.FET	;BEGIN FEATURE TABLE CATEGORY
	PUSHJ	P,CATSTA	;INITIALIZE IT
	MOVEI	P1,.GTFET	;THE TABLE WE WANT
	PUSHJ	P,GTTBAL	;DUMP IT ALL
	PUSHJ	P,CATEND	;END OF CATEGORY
SUBTTL WRITE DDB'S FOR JOB

;THIS IS BAD--WE SHOULD LOOK AT JOB DEVICE ASSIGNMENT TABLE
;HERE TO WRITE DDB'S FOR JOB

	MOVE	T1,[XWD DEVLST,.GTCNF]
	PUSHJ	P,GTBSPY	;GET PTR TO LIST OF DDB'S
	  JRST	EDDBS		;FORGET IT
	HLRZ	P1,T1		;SAVE IN P1
	MOVEI	T1,CA.DDB	;CATEGORY NUMBER FOR DDB'S
	PUSHJ	P,CATSTA	;START UP THE CATEGORY

;HERE FOR NEXT DDB

DDBLOP:	MOVEI	T1,.DVCHR(P1)	;ADDR OF DEVCHR WORD
	PUSHJ	P,PEKSPY
	LDB	T1,PJOBN	;GET JOB NUMBER OF OWNER OF DDB
	CAIE	T1,(J)		;SKIP IF USER'S JOB
	JRST	NXTDDB		;NO, SKIP IT

;HERE TO WRITE DDB

	MOVEI	T1,DEVMOD(P1)	;ADDR OF DEVMOD WORD
	PUSHJ	P,PEKSPY	;GET DEVMOD WORD
	MOVNI	T2,LDDBSH	;-LENGTH OF SHORT DDB
	TLNN	T1,DV.LNG	;SKIP IF DEVICE HAS LONG DDB
	JRST	DDBWRT		;SHORT, WRITE IT
	MOVNI	T2,LDDBLN	;-LENGTH OF LONG DDB
	TLNE	T1,DV.DSK	;SKIP IF NOT DSK DEVICE
	MOVNI	T2,LDDBDS	;-LENGTH OF DSK DDB'S
DDBWRT:	HRLI	P1,(T2)		;P1=-LENGTH,ADDR
	PUSHJ	P,WRTDDB	;WRITE OUT THE DDB

;HERE TO FIND NEXT DDB

NXTDDB:	MOVEI	T1,DEVSER(P1)	;ADDR OF PTR TO NEXT DDB
	PUSHJ	P,PEKSPY	;GET PTR TO NEXT DDB
	HLRZ	P1,T1		;SAVE IN P1
	JUMPN	P1,DDBLOP	;JUMP IF MORE DDB'S
	PUSHJ	P,CATEND	;END OF DDB CATEGORY
SUBTTL WRITE LOW SEGMENT AND HIGH SEGMENT IF ANY

;HERE WHEN ALL DDB'S DONE, GATHER CORE FROM JOB'S LOW SEGMENT

EDDBS:	MOVEI	T1,CA.COR	;CATEGORY NUMBER FOR USER CORE
	PUSHJ	P,CATSTA	;START UP CATEGORY
	SETZM	THSOFF		;OFFSET FOR THIS SEGMENT=0
	HRLZI	T1,MAXUCR	;GET FIRST BLOCK OF USER CORE
	HRRZ	T2,J		;SEGMENT NUMBER=JOB NUMBER
	PUSHJ	P,GTUCOR	;GET THE CORE
	MOVEI	T1,.JBREL	;ADDRESS OF .JBREL
	MOVE	T1,USRCOR(T1)	;GET .JBREL FROM USER CORE
	MOVEM	T1,SEGREL	;=SIZE OF THIS SEGMENT
	ADDI	T1,<1_WRDSPK>-1 ;HIGH SEG STARTS AT NEXT K
	TRZ	T1,<1_WRDSPK>-1
	CAIGE	T1,400000	;BUT AT LEAST 400000
	MOVEI	T1,400000
	MOVEM	T1,HGHOFF	;OFFSET FOR HIGH SEGMENT
	MOVEI	T1,.JBHRL	;ADDRESS OF .JBHRL
	HRRZ	T1,USRCOR(T1)	;GET SIZE OF HIGH SEGMENT FROM USER CORE
	SKIPE	T1		;SKIP IF NO HIGH SEGMENT
	SUB	T1,HGHOFF	;MINUS OFFSET=LENGTH OF SEGMENT
	MOVEM	T1,HGHREL	;SAVE THAT FOR LATER
	MOVE	T1,J
	PUSHJ	P,COMPRS	;OUTPUT LOW SEGMENT AS ZERO-COMPRESSED DATA

;HERE TO WRITE HIGH SEGMENT IF ANY

	SKIPN	T1,HGHREL	;SKIP IF ANY HIGH SEGMENT
	JRST	NOHIGH
	JUMPLE	S,NOHIGH	;EVEN IF HIGH SEG MUST KNOW ITS NUMBER
	MOVEM	T1,SEGREL	;SIZE OF HIGH SEGMENT
	MOVE	T1,HGHOFF	;OFFSET FOR HIGH SEGMENT
	MOVEM	T1,THSOFF	;=SIZE OF THIS SEGMENT
	HRLZI	T1,MAXUCR
	HRRZ	T2,S		;SEGMENT NUMBER FOR HIGH SEGMENT
	PUSHJ	P,GTUCOR	;GET FIRST BLOCK OF HIGH SEGMENT
	MOVE	T1,S
	PUSHJ	P,COMPRS	;WRITE HIGH SEGMENT AS ZERO-COMPRESSED DATA
SUBTTL CLOSE OUT CORE-IMAGE FILE AND FINISH UP

;HERE WHEN ALL DATA WRITTEN

NOHIGH:	MOVE	T1,PATTERN	;END FILE WITH STANDARD PATTERN
	PUSHJ	P,DWRITE
	PUSHJ	P,CATEND
	MOVEI	T1,(BP)		;ADDRESS LAST STORED IN BUFFER
	JUMPGE	BP,NOHGH1	;JUMP IF NEVER WROTE ANYTHING
	CAIE	T1,DAEBUF	;UNLESS CURRENT BUFFER EMPTY
	PUSHJ	P,BLKWRT	;WRITE LAST PARTIAL BUFFER
NOHGH1:	CLOSE	DSK,		;AND CLOSE FILE

;HERE WHEN CORE-IMAGE FILE WRITTEN

	TLNE	F,L.DUMP	;SKIP IF DCORE, NOT IF DUMP
	JRST	EDUMP

;HERE TO FINISH OFF DCORE

EDCORE:	TLNE	F,L.UUO		;SKIP IF COMMAND
	JRST	UUOKX		;IF UUO, QUIT NOW
	PUSHJ	P,CRLFPD	;PRINT <CR><LF>. TO INDICATE MONITOR MODE
	MOVSI	T2,(AT.MON)	;ENSURE RE-ATTACH IS AT MONITOR LEVEL
	IORM	T2,LINE		;BY SETTING BIT IN ATT FUNCTION

EDUMP:	TLNE	F,L.UUO		;ATTACHED?
	JRST	UUOKX		;NO--RETURN TO UUO.
	HLLZ	T2,LINE		;LH=LINE NUMBER OF USER'S TTY
	HRRI	T2,(J)		;RH=USER'S JOB NUMBER
	ATTACH	T2,		;GIVE USER BACK HIS TTY
	  PUSHJ	P,E.ATUJ	;NOTE RE-ATTACH FAILED, USER MUST GET
				;BACK TO HIS JOB HIMSELF
	TLZ	F,L.TTYA	;NOTE TTY NO LONGER ATTACHED
;HERE TO UUO USER OUT OF DAEMON REQUEST

DETUSR:	HRRZ	T1,.JBDDT	;ADDR OF DDT IF ANY
IFE FTDET,<
	TLNN	F,L.OPRA	;RE-ATTACH IF OPR WANTS CONTACT
>;END FTDET COND
	JUMPE	T1,NOREAT	;DONT REATTACH ORIGINAL TTY IF NO DDT
	HRLZ	T1,THSLIN	;LH T1=OUR ORIGINAL LINE NUMBER
	HRR	T1,THSJOB	;RH=OUR JOB NUMBER
	TLO	T1,(AT.USR)	;SET TO USER LEVEL
	ATTACH	T1,		;REATTACH TO OUR ORIGINAL LINE
	  AOS	ATTGUF
NOREAT:	MOVEI	T1,DALOOK	;NEW RESTART ADDR
	MOVEM	T1,INTADR
	TLNN	F,L.DUMP	;SKIP IF DUMP - MUST FORCE CCL RUN OF DUMP
	JRST	EDUMP1		;NO, DONT BOTHER
	MOVEI	T1,T2		;ADDRESS OF ARGUMENT LIST
	MOVE	T2,[SIXBIT /.DUMP/] ;COMMAND TO FORCE
	MOVE	T3,J		;JOB NUMBER
	FRCUUO	T1,		;FORCE COMMAND TO RUN DUMP AT CCL ENTRY POINT
	  AOS	FRCGUF		;DEBUG - COUNT SHOULD NEVER HAPPEN'S
EDUMP1:	MOVEI	T1,J		;T1=ADDRESS OF ARGUMENT LIST=JOB NUMBER
	DAEFIN	T1,		;ALL DONE, REQUE USER'S JOB
	  AOS	FINGUF		;DEBUG - NOTE AN SNH

	MOVE	T1,PSRCH	;POINTER TO ORIGINAL SEARCH LIST
	STRUUO	T1,		;RESTORE ORIGINAL SEARCH LIST
	  AOS	STRGUF		;DEBUG - COUNT FAILURES OF STRUUO
	JRST	DALOO2		;ALL DONE WITH THIS JOB
SUBTTL ERRORS

E.NPPN:	JSP	T2,SNH
	  JRST	EDUMP		;OOPS, WE LOST CONTACT
	OUTSTR	[ASCIZ .
? CANT GET USER'S PPN
.]
	JRST	EDUMP

E.OPN:	JSP	T2,CWF
	  JRST	EDUMP		;NO LONGER ATTACHED
	OUTSTR	[ASCIZ .
? CANT OPEN DEVICE .]
	PUSHJ	P,TSIXN		;TYPE DEVICE
	JRST	E.NPV1
E.DAEP:	MOVEI	T1,[ASCIZ .DAEMON.]
	JRST	E.NPV2

E.CCLP:	MOVEI	T1,[ASCIZ .CCL.]
E.NPV2:	JSP	T2,CWF
	  JRST	EDUMP		;CAN'T TYPE, WE'RE NOT ATTACHED
	OUTSTR	[ASCIZ .
? YOU DONT HAVE PRIVILEGES TO WRITE .]
	OUTSTR	(T1)
	OUTSTR	[ASCIZ . FILE.]
E.NPV1:	TLZ	F,L.DUMP	;DO NOT PROCEED WITH DUMP
	JRST	EDCORE		;END DUMP OR DCORE AS DCORE

E.DENT:	HRRZ	T1,T2		;ERR CODE TO T1 BEFORE DESTROYING T2
	JSP	T2,CWF
	  JRST	E.DNT1		;OOPS, LOST THE ATTACH
	OUTSTR	[ASCIZ .
? ENTER FAILURE .]
	PUSHJ	P,TOCT
	OUTSTR	[ASCIZ . ON CCL FILE
.]
E.DNT1:	TLZ	F,L.DUMP
	JRST	DCORE
E.NDSK:	JSP	T2,CWF
	  JRST	EDUMP
	OUTSTR	[ASCIZ .
? DAEMON FILE MUST BE WRITTEN ON A DISK
.]
	JRST	EDUMP
E.F1:	PUSHJ	P,FBMTRY
	  JRST	RE1
	JRST	E.NOUE

E.F2:	PUSHJ	P,FBMTRY
	  JRST	RE2

E.NOUE:	HRRZ	T1,T2		;SAVE ERROR CODE FOR PRINTING
	JSP	T2,CWF
	  JRST	EDUMP		;NO LONGER ATTACHED, MUST QUIT
	OUTSTR	[ASCIZ .
? ENTER FAILURE .]
	JRST	LEERR		;LOOKUP OR ENTER ERROR
E.NOUL:	HRRZ	T1,T2		;SAVE ERROR CODE FOR PRINTING
	JSP	T2,CWF
	  JRST	EDUMP		;STRANGE, WHAT?
	OUTSTR 	[ASCIZ .
? LOOKUP FAILURE .]
LEERR:	PUSHJ	P,TOCT
	OUTSTR	[ASCIZ . ON DAEMON FILE
.]
	JRST	EDUMP

E.NATT:	PUSHJ	P,ATTCHK	;CHECK TO MAKE SURE WE AREN'T DETACHED
	  AOSA	OUTGUF		;THINGS ARE VERY STRANGE, TODAY
	OUTSTR	[ASCIZ .
? DETACH UUO FAILED.]
	EXIT

E.JPEK:	OUTSTR	[ASCIZ .
? JOBPEK UUO REQUIRED, NOT IMPLEMENTED.]
	EXIT

E.NSWP:	OUTSTR	[ASCIZ .
? CANT GET SWAPPING PARAMETERS.]
	EXIT

E.DSWP:	OUTSTR	[ASCIZ .
? DSKCHR FAILURE .]
	CAME	T1,[D.SLB+1,,DAEBUF]
	PUSHJ	P,TOCT
	OUTSTR	[ASCIZ . UNIT .]
	MOVE	T2,DAEBUF
	PUSHJ	P,TSIXN
	OUTSTR	[ASCIZ .
.]
	EXIT
E.SOPN:	POP	P,T2		;RESTORE STACK
	JSP	T2,SNH
	  POPJ	P,		;CAN'T TYPE, WERE DETACHED
	OUTSTR	[ASCIZ .
? CANT OPEN SWAP UNIT .]
	MOVE	T2,T3		;GET SWAP UNIT NAME
	PUSHJ	P,TSIXN
PCRLF:	OUTSTR	[ASCIZ .
.]
CPOPJ:	POPJ	P,

E.SPTR:	JSP	T2,SNH
	  POPJ	P,		;WHAT CAN YOU DO WHEN DETACHED?
	OUTSTR	[ASCIZ .
? CANT GET SWAPPING POINTER FOR JOB.]
	PJRST	PCRLF

E.NFSF:	OUTSTR	[ASCIZ .
? PLEASE LOG IN AS .]
	PUSHJ	P,TPPN
	EXIT

E.USTR:	PUSHJ	P,ATTCHK	;ARE WE ATTACHED?
	  AOSA	OUTGUF		;LOSE
	OUTSTR	[ASCIZ	.
?CAN'T SET TO USER SEARCH LIST
.]
	AOS	STRGUF		;NOTE STRUUO FAILURE
	POPJ	P,		;TRY TO CONTINUE

E.ATUJ:	PUSHJ	P,ATTCHK	;CHECK THAT WE'RE ATTACHED TO SOMETHING
	  AOSA	OUTGUF		;NOTE WE WANTED TO TYPE BUT COULDN'T
	OUTSTR	[ASCIZ	.
?CAN'T RE-ATTACH TTY TO USER JOB
.]
	AOS	ATTGUF		;NOTE ATTACH FAILURE
	POPJ	P,

FBMTRY:	SOJLE	P1,CPOPJ1	;EXIT IF FINISHED RETRYING
	HRRZI	T4,(T2)		;ERROR CODE
	CAIE	T4,EE.FBM	;SKIP IF FILE BEING MODIFIED
	JRST	CPOPJ1		;NO, SOME OTHER ERROR
	MOVEI	T1,1
	SLEEP	T1,
	POPJ	P,
CWF:	TLNE	F,L.UUO
	JRST	UUERR5
	PUSHJ	P,ATTCHK	;NOT A UUO, ARE WE PROPERLY ATTACHED?
	  AOSA	OUTGUF		;NO, FLAG ERROR
	AOJ	T2,		;YES, SKIP RETURN
	JRST	(T2)		;RETURN

SNH:	TLNE	F,L.UUO
	JRST	UUERR4
	PUSHJ	P,ATTCHK	;COMMAND--ARE WE ATTACHED?
	  AOSA	OUTGUF		;NO, NOTE ERROR, AND TAKE NON-SKIP RETURN
	AOJ	T2,
	JRST	(T2)		;GO BACK

ATTCHK:	PUSH	P,T1		;SAVE T1
	GETLIN	T1,		;GET OUR LINE NO
	TLNN	T1,-1		;DO WE HAVE ONE?
	JRST	TPOPJ		;NO, TAKE NON-SKIP RETURN
TPOPJ1:	POP	P,T1		;YES, RESTORE T1
	JRST	CPOPJ1		;AND SKIP

CRLFPD:	PUSHJ	P,ATTCHK	;IF WE'RE ATTACHED.
	  AOSA	OUTGUF		;BUT WE AREN'T, SO DON'T
	OUTSTR	[ASCIZ	/
./]				;PRINT TO SHOW COMMAND LEVEL AGAIN
	POPJ	P,
PDAEVR:	PUSHJ	P,ATTCHK
	  AOSA	OUTGUF
	OUTSTR	DAEVER		;PRINT DAEMON VERSION STRING
	POPJ	P,

DEFINE	.ADCHR	(CHR),<
.STRG==.STRG+<<CHR>_.SHFT>
.SHFT==.SHFT-7
IFL .SHFT,<EXP	.STRG
.STRG==0
.SHFT==^D29	>>

DEFINE	.ADSTR	(STR),<
IRPC STR,<.ADCHR	("STR")	>>

DEFINE	VERSTR	(NAME,MAJOR,MINOR,EDIT,WHO),<
	XLIST
.STRG==0
.SHFT==^D29
	.ADSTR	(['NAME' )
	.ADSTR	(\MAJOR)
IFN MINOR,<.ADCHR	(MINOR+"A"-1)>
IFN EDIT,<.ADCHR	"("
	.ADSTR	(\EDIT)
	.ADCHR	")">
IFN WHO,<.ADCHR	("-")
	.ADSTR	(\WHO)>
	.ADCHR	("]")
	.ADCHR	(15)
	.ADCHR	(12)
	EXP	.STRG
LIST>

DAEVER:	VERSTR	(DAEMON,VDAEMON,VMINOR,VEDIT,VWHO)

	PURGE	.ADCHR,.ADSTR,VERSTR,.STRG,.SHFT
SUBTTL SUBROUTINES

;SUBROUTINE TO START A CATEGORY
;ARGS	T1=CATEGORY NUMBER

CATSTA:	PUSHJ	P,DWRITE	;WRITE THE CATEGORY NUMBER
	PJRST	MRKSPT		;AND MARK THE SPOT FOR THE LENGTH TO BE WRITTEN LATER

;SUBROUTINE TO END A CATEGORY

CATEND:	MOVE	T1,WRDCNT	;WORDS WRITTEN
	PJRST	WRTSPT		;REWRITE THE SPOT MARKED FOR THE LENGTH OF THE CAT

;SUBROUTINE TO GET VALUES FOR JOB AND SEGMENT AND WRITE
;ARGS	T1=GETTAB TABLE
;	J=JOB NUMBER
;	S=SEGMENT NUMBER
;ENTER	WGTJOB TO WRITE JOB ENTRY
;	WGTSEG TO WRITE SEGMENT ENTRY
;	WGTBTH TO WRITE JOB THEN SEGMENT ENTRIES

WGTBTH:	TLO	F,L.WS		;WRITE JOB AND SEGMENT
WGTJOB:	TLOA	F,L.WJ		;WRITE JOB
WGTSEG:	TLO	F,L.WS		;WRITE SEGMENT
	TLZN	F,L.WJ		;SKIP IF WANT JOB ENTRY
	JRST	WGTSG1		;NO, TRY FOR SEGMENT
	HRLM	T1,(P)		;SAVE GETTAB TABLE
	HRLI	T1,(J)		;LH=JOB NUMBER
	PUSHJ	P,GTBSPY	;GET VALUE
	  SETZ	T1,		;0 OTHERWISE
	PUSHJ	P,DWRITE	;WRITE THAT
	HLRZ	T1,(P)		;RESET THE GETTAB TABLE
WGTSG1:	TLZN	F,L.WS		;SKIP IF SEGMENT ENTRY WANTED
	POPJ	P,		;NO, EXIT
	JUMPLE	S,WGTSG2	;DON'T TRY IF NO HIGH SEG (INCLUDING SPY)
	HRLI	T1,(S)		;LH=SEGMENT NUMBER
	PUSHJ	P,GTBSPY	;GET VALUE
WGTSG2:	  SETZ	T1,		;0 OTHERWISE
	PJRST	DWRITE		;WRITE AND EXIT
;TABLE OF GETTAB'S TO WRITE FOR JOB INFORMATION
;RH=TABLE NUMBER
;LH=0 IF BOTH JOB AND SEGMENT ENTRIES WANTED
;  =1 IF JOB ONLY
;  =2 IF SEGMENT ONLY
;G MACRO HAS PARAMETERS TABLE NAME, B OR J OR S FOR BOTH OR JOB OR SEGMENT
 
	DEFINE G(X,Y)<
	XLIST
..Z==3
IFIDN <Y> <B>,<..Z==0>
IFIDN <Y> <J>,<..Z==1>
IFIDN <Y> <S>,<..Z==2>
	XWD	..Z,X
	LIST
>

GTTABL:	G	.GTSTS,B
	G	.GTPPN,B
	G	.GTPRG,B
	G	.GTTIM,J
	G	.GTKCT,J
	G	.GTPRV,J
	G	.GTSWP,B
	G	.GTRCT,J
	G	.GTWCT,J
	G	.GTTDB,J
	G	.GTDEV,S
	G	.GTNM1,J
	G	.GTNM2,J
	G	.GTCNO,J
	G	.GTTMP,J
	G	.GTWCH,J
	G	.GTSPL,J
	G	.GTRTD,J
	G	.GTLIM,J
	G	.GTSPS,J
	G	.GTRSP,J
	G	.GTTRQ,J
GTTBLN==.-GTTABL
;SUBROUTINE TO OUTPUT ALL ENTRIES OF A GETTAB TABLE
;ARGS	P1=TABLE NUMBER

GTTBAL:	MOVSS	P1		;LH=TABLE NUMBER, RH=0
GTTBA1:	MOVS	T1,P1		;T1=ENTRY NUMBER,TABLE NUMBER
	PUSHJ	P,GTBSPY
	  POPJ	P,		;NO MORE
	PUSHJ	P,DWRITE	;WRITE THE WORD
	AOJA	P1,GTTBA1	;LOOP TIL END OF TABLE

;SUBROUTINE TO OUTPUT A DDB
;ARGS	P1=XWD -WORDS, ADDR OF BEGINNING OF DDB
;VALUES	P1=ADDR OF DDB

WRTDDB:	HRLM	P1,(P)		;SAVE ADDR OF DDB
	HLRE	T1,P1		;T1=MINUS LENGTH OF DDB
	MOVNS	T1		;POSITIVE LENGTH OF DDB
	PUSHJ	P,DWRITE	;WRITE OUT LENGTH OF NEXT DDB
WRTDD1:	MOVEI	T1,(P1)		;ADDR OF NEXT WORD
	PUSHJ	P,PEKSPY	;GET NEXT WORD FROM DDB
	PUSHJ	P,DWRITE	;WRITE THE WORD
	AOBJN	P1,WRTDD1	;LOOP FOR THE DDB
	HLRZ	P1,(P)		;RESET ADDR OF DDB
	POPJ	P,		;AND EXIT
SUBTTL SUBROUTINE TO COMPRESS AND OUTPUT A SEGMENT

;SUBROUTINE TO COMPRESS AND OUTPUT A SEGMENT
;ARGS	T1=INDEX OF SEGMENT=JOB OR SEGMENT NUMBER
;	SEGREL=LENGTH OF SEGMENT
;	THSOFF=OFFSET FOR ADDR OF FIRST WORD OF THE SEGMENT
;	USRCOR=FIRST BLOCK OF USER'S CORE FOR SEGMENT

COMPRS:	JSP	T4,SAVE4	;SAVE P1-P4
	PUSH	P,REMBLK	;SAVE POINTER TO BEGINNING OF CATEGORY
	PUSH	P,REMWRD
	PUSH	P,WRDCNT
	SETZB	P1,USRADR	;START AT ADDR 0 IN SEGMENT, SAVE ADDR RETRIEVED
	SETZ	P2,		;PTR TO BUFFER OF USER'S CORE
	MOVEM	T1,THSSEG	;SAVE SIZE OF THIS SEGMENT
COMPR1:	SKIPE	USRCOR(P2)
	JRST	COMPR2		;FOUND NEXT NON-ZERO WORD
	CAML	P1,SEGREL	;SKIP IF MORE IN SEGMENT
	JRST	CPREND		;NO, END OF COMPRESSING
	ADDI	P1,1		;BUMP COUNTER TO NEXT ADDR
	CAIGE	P2,MAXUCR-1	;SKIP IF END OF BUFFER
	AOJA	P2,COMPR1	;NO, KEEP GOING
	PUSHJ	P,NXTUBK	;GET NEXT BLOCK OF USER CORE
	SETZ	P2,		;RESET PTR TO BEGINNING OF BUFFER
	JRST	COMPR1		;AND KEEP GOING
COMPR2:	HRRZM	P1,PTRADR	;SAVE ADDR OF BEGINNING OF NON-ZERO REGION
	PUSHJ	P,MRKSPT	;MARK THE SPOT SO CAN WRITE IOWD LATER
COMP2A:	ADDI	P2,1		;BUMP PTR IN BUFFER, LOOK AT NEXT WORD
	SKIPE	T1,USRCOR-1(P2)	;SKIP IF FOUND A ZERO WORD
	JRST	COMPR3		;NO, JUST WRITE AND KEEP ON
	CAML	P1,SEGREL	;SKIP IF MORE IN SEGMENT
	JRST	CPREND		;END OF COMPRESSING
	CAIGE	P2,MAXUCR	;SKIP IF THE FIRST ZERO WAS THE END OF THE BUFFER
	JRST	COMP2B		;NO, GO AHEAD
	PUSHJ	P,NXTUBK	;YES, GET NEXT BLOCK
	SETZB	P2,T1		;RESET TO BEGINNING OF BUFFER AND REMEMBER ZERO DATA
COMP2B:	SKIPN	USRCOR(P2)	;IF ONLY 1 ZERO, PRETEND REGULAR DATA
	JRST	COMPR4		;2 CONSECUTIVE ZEROS END THIS PIECE
COMPR3:	PUSHJ	P,DWRITE	;WRITE THE WORD
	CAML	P1,SEGREL	;SKIP IF NOT END OF SEGMENT
	JRST	COMPR4		;END OF SEGMENT, END OF THIS PIECE
	ADDI	P1,1		;BUMP ADDR
	CAIGE	P2,MAXUCR	;SKIP IF NOW OFF END OF BUFFER
	JRST	COMP2A		;NO, LOOK AT NEXT WORD
	PUSHJ	P,NXTUBK	;YES, GET NEXT BLOCK OF USER CORE
	SETZ	P2,		;RESET PTR TO BEGINNING OF BUFFER
	JRST	COMP2A		;AND KEEP GOING
COMPR4:	SOS	T1,PTRADR	;T1=ADDR-1 IN SEGMENT OF BEGINNING OF THIS PIECE
	ADD	T1,THSOFF	;ADD OFFSET FOR SEGMENT
	MOVN	T2,WRDCNT	;-WORDS WRITTEN
	HRL	T1,T2		;T1=IOWD PTR FOR PIECE
	PUSHJ	P,WRTSPT	;REWRITE THE IOWD IN THE FILE
	AOS	T1,WRDCNT	;WORDS WRITTEN INCLUDING THE IOWD
	ADDM	T1,(P)		;COUNT WORDS IN THIS CATEGORY
	CAMGE	P1,SEGREL	;SKIP IF END OF THIS SEGMENT
	AOJA	P1,COMPR1	;NO, LOOK FOR NEXT NON-ZERO PIECE
CPREND:	POP	P,WRDCNT	;RESTORE WORDS WRITTEN
	POP	P,REMWRD	;AND THE REST OF THE CATEGORY PTRS
	POP	P,REMBLK
	POPJ	P,
SUBTTL SUBROUTINES TO WRITE USER CORE

;SUBROUTINE TO WRITE IN USER'S CORE - MAKES NO ADDRESS CHECKS
;ARGS	T1=+LENGTH, ADDR IN SEGMENT
;	T2=INDEX OF SEGMENT=JOB OR SEGMENT NUMBER
;	J=JOB NUMBER
;	THSOFF=OFFSET FOR BEGINNING OF SEGMENT
;	USRCOR CONTAINS CORE TO BE WRITTEN OUT

WTUCOR:	JSP	T4,SAVE4	;SAVE P1-P4
	MOVEM	T2,SEGSWP	;SAVE SEGMENT NUMBER
	HLRZ	T3,T1		;NUMBER OF WORDS
	HRL	T3,J		;JOB NUMBER
	TLO	T3,400000	;SET WRITE FLAG
	HRRZ	T4,T1		;ADDR IN SEGMENT
	ADD	T4,THSOFF	;PLUS OFFSET FOR BEGINNING=ACTUAL ADDRESS
	HRLI	T4,USRCOR	;SOURCE=USRCOR
	MOVEI	T2,T3		;ADDR OF JOBPEK BLOCK
	PUSHJ	P,FINCHK	;WAIT A SEC IF HE'S BEING SWAPPED
WRTPEK:	JOBPEK	T2,		;TRY TO WRITE USER'S CORE
	  JRST	WRTSWP		;NOT IN CORE, MUST REWRITE SWAPPING SPACE
	POPJ	P,

;HERE IF MUST REWRITE SWAPPING SPACE

WRTSWP:	PUSHJ	P,FINCHK	;IF LOST BECAUSE HE'S BEING SWAPPED, WAIT
	TRZE	F,R.SWIN	;DID HE JUST COME IN?
	JRST	WRTPEK		;YES, GO PEEK AGAIN
	PUSH	P,T3		;SAVE JOBPEK ARGS
	PUSH	P,T4		; ..
	MOVE	P1,T1		;SAVE PTR TO CORE TO BE WRITTEN
	MOVEI	P2,USRCOR	;CURRENT ADDR IN OUR BUFFER
	HRRZ	T3,P1		;ADDR OF USER'S CORE TO BE WRITTEN
	IDIVI	T3,<1_WRDSPB>	;T3=BLOCKS TO SKIP, T4=WORDS TO SKIP IN BLOCK
	HRLZ	T1,SEGSWP	;SEGMENT NUMBER
	HRRI	T1,.GTSWP
	PUSHJ	P,GTBSPY	;GET SWAPPING PTR
	  JRST	E.SPTR		;CANT GET IT
	MOVEM	T1,SEGSWP	;REMEMBER SWAPPING PTR
	JUMPL	T1,OFRAG	;JUMP IF FRAGMENTED (HOW BAD CAN IT GET?)


;HERE IF NOT FRAGMENTED

	SKIPA	P3,T3		;REMEMBER BLOCKS SKIPPED
WRTSW1:	AOS	T3,P3		;SKIP ANOTHER BLOCK THIS TIME
	PUSHJ	P,WRTPEC	;DO WHAT YOU CAN IN THIS BLOCK
	SETZ	T4,		;SKIP NO MORE WORDS IN BLOCKS
	TLNE	P1,-1		;SKIP IF ALL DONE
	JRST	WRTSW1		;NO, DO NEXT BLOCK
	JRST	REDEN1		;ALL DONE, RELEASE SWP AND EXIT
;HERE IF FRAGMENTED ON SWAPPING SPACE

OFRAG:	TLZ	T1,400000	;CLEAR FRAGMENTED BIT
	HLRZ	T2,T1		;T2=ADDR OF SWP PTRS
	PUSH	P,T4		;SAVE WORDS TO SKIP
	PUSHJ	P,FRGFND	;FIND FIRST BLOCK TO REWRITE
	POP	P,T4		;RESTORE WORDS TO SKIP IN BLOCK
	JUMPE	T1,REDEN1	;EXIT IF NO MORE
OFRAG1:	MOVSM	T1,SEGSWP	;STORE SWAP PTR FOR BYTE PTRS
	HLRZ	P4,T1		;P4=K IN THIS PIECE
	LSH	P4,@BLKPAG	;P4=BLOCKS IN THIS PIECE
	SKIPA	P3,T3		;P3=BLOCKS TO SKIP
OFRAG2:	AOS	T3,P3		;SKIP ONE MORE BLOCK THIS TIME
	CAMGE	T3,P4		;SKIP IF END OF THIS PIECE
	JRST	OFRAG4		;NO, DO THIS BLOCK
	AOS	T1,SWPADR	;ADDR OF NEXT SWAP PTR
OFRAG3:	PUSHJ	P,PEKSPY	;GET NEXT SWAP PTR
	JUMPE	T1,REDEN1	;EXIT IF NO MORE
	SETZ	T3,		;SKIP NO BLOCKS AT FIRST
	TLC	T1,-1		;SET TO TEST FOR NEW PTR TO PTRS
	TLCE	T1,-1		;SKIP IF PTR TO NEW PTRS
	JRST	OFRAG1		;DO THIS PIECE
	MOVEM	T1,SWPADR	;STORE ADDR OF NEW PTRS
	JRST	OFRAG3		;AND CHASE THE NEW PTRS
OFRAG4:	PUSHJ	P,WRTPEC	;DO WHAT YOU CAN FOR THIS BLOCK
	SETZ	T4,		;SKIP NO MORE WORDS IN FURTHER BLOCKS
	TLNE	P1,-1		;SKIP IF ALL DONE
	JRST	OFRAG2		;NO, DO NEXT BLOCK
	JRST	REDEN1		;RELEASE SWP AND EXIT
;SUBROUTINE TO REWRITE ONE BLOCK ON THE SWAPPING SPACE
;ARGS	T3=BLOCKS TO SKIP IN THIS PIECE OF THE SWAPPING SPACE
;	T4=WORDS TO SKIP IN THIS BLOCK
;	SEGSWP=SWAPPING PTR
;	P1=XWD +WORDS LEFT, ADDR IN USER'S SEGMENT
;	P2=ADDR IN USRCOR OF CURRENT BEGINNING OF DATA

WRTPEC:	PUSH	P,T4		;SAVE WORDS TO SKIP
	MOVE	T2,UPDLST	;IOWD TO AVAILABLE UPDATE BUFFER
	PUSHJ	P,REDPEC	;READ IN THE BLOCK
	POP	P,T2		;RESTORE WORDS TO PRESERVE IN THIS BLOCK
	MOVEI	T3,<1_WRDSPB>	;WORDS IN THE BLOCK
	SUB	T3,T2		;T3=WORDS AVAILABLE IN THIS BLOCK
	HLRZ	T4,P1		;T4=WORDS YET TO TRANSFER
	CAMLE	T3,T4		;MINIMUM OF AVAILABLE, LEFT TO TRANSFER
	MOVE	T3,T4		;=WORDS TO WRITE IN THIS BLOCK
	MOVE	T4,T3		;SAVE IN T4
	ADDI	T2,SECBUF	;ADDR OF FIRST AVAILABLE WORD
	HRL	T2,P2		;ADDR OF NEXT DATA WORD
	ADDI	T3,(T2)		;+WORDS TO TRANSFER=LAST WORD+1
	BLT	T2,-1(T3)	;TRANSFER NEW DATA INTO BUFFER
	USETO	SWP,T1		;RESET TO WRITE IN SAME BLOCK
	OUTPUT	SWP,UPDLST	;REWRITE BLOCK
	HLRZ	T2,P1		;WORDS LEFT
	SUB	T2,T4		;-WORDS DONE=NEW WORDS LEFT
	HRL	P1,T2
	ADDI	P1,(T4)		;NEW ADDR IN USER'S SEGMENT
	ADDI	P2,(T4)		;AND NEW ADDR IN USRCOR
	STATO	SWP,740000	;SKIP IF ERRORS
	POPJ	P,
	AOS	SWWGUF		;NOTE SWAP WRITE ERROR
	JSP	T2,SNH		;NO RETURN IF UUO
	  PJRST	SWPIO1		;IF NO LONGER ATTACHED
	OUTSTR	[ASCIZ .
% SWAP WRITE ERROR UNIT .]
	PJRST	SWPIO1		;REPORT REST OF ERROR
SUBTTL SUBROUTINES TO READ USER CORE

;SUBROUTINE TO GET NEXT BLOCK OF USER CORE

NXTUBK:	MOVEI	T1,MAXUCR	;SIZE OF BLOCK TO GET
	ADDB	T1,USRADR	;ADDR OF THIS BLOCK IN SEGMENT
	MOVEI	T2,MAXUCR	;MAXIMUM TRANSFER POSSIBLE
	ADDI	T2,-1(T1)	;T2=ADDR OF LAST POSSIBLE WORD
	CAMLE	T2,SEGREL	;SKIP IF WITHIN SEGMENT
	MOVE	T2,SEGREL	;LAST WORD OF SEG IS LAST WORD OF TRANSFER
	SUBI	T2,(T1)		;MINUS START OF TRANSFER=WORDS-1
	HRLI	T1,1(T2)	;WORDS THIS TRANSFER TO LEFT HALF
	MOVE	T2,THSSEG	;SEGMENT NUMBER
;	PJRST	GTUCOR		;FALL INTO GTUCOR

;SUBROUTINE TO GET CORE FROM USER'S JOB - MAKES NO ADDRESS CHECKS
;ARGS	T1=+LENGTH, ADDR IN SEGMENT
;	T2=INDEX OF SEGMENT=JOB OR SEGMENT NUMBER
;	J=JOB NUMBER
;	THSOFF=OFFSET FOR BEGINNING OF THIS SEGMENT

GTUCOR:	JSP	T4,SAVE4	;SAVE P1-P4
	SETZM	USRCOR		;FIRST CLEAR THE BUFFER IN CASE SOMETHING GOES WRONG
	MOVE	T3,[USRCOR,,USRCOR+1]
	BLT	T3,USRCOR+MAXUCR-1
	MOVEM	T2,SEGSWP	;SAVE SEGMENT NUMBER
	HLRZ	T3,T1		;RH=NUMBER OF WORDS
	HRL	T3,J		;LH=JOB NUMBER
	HRRZ	T4,T1		;ADDR IN SEGMENT
	ADD	T4,THSOFF	;ADD OFFSET FOR BEGINNING OF SEGMENT
	HRLZS	T4		;LH=ADDR
	HRRI	T4,USRCOR	;RH=ADDR OF OUR BUFFER
	MOVEI	T2,T3
	PUSHJ	P,FINCHK	;WATCH OUT FOR HIS GETTING SWAPPED
REDPEK:	JOBPEK	T2,		;TRY TO READ CORE
	  JRST	REDSWP		;NOT IN CORE, READ SWAPPING SPACE
	POPJ	P,		;THAT WAS NICE

;HERE TO CHECK WHETHER JOB IN J IS BEING SWAPPED NOW.
; IF SO, WAIT UNTIL HE GETS IN OR OUT, AND GIVE
; NON-SKIP RETURN IF HE JUST CAME IN

FINCHK:	PUSH	P,T1		;SAVE WORK REG
	TRZ	F,R.SWIN	;ASSUME NO KNOWLEDGE
FINCK1:	MOVE	T1,[XWD %SWFIN,.GTSDT]
	PUSHJ	P,GTBSPY	;GET CURRENT VALUE OF FINISH
	  JRST	TPOPJ		;LOSE...
	CAIN	T1,(J)		;IS THIS GUY GETTING SWAPPED OUT?
	JRST	FINCK2		;YES, WAIT FOR HIM TO GET OUT
	MOVNS	T1
	CAIE	T1,(J)		;IS HE GETTING SWAPPED IN?
	JRST	TPOPJ		;NO, PROCEED
	TRO	F,R.SWIN	;YES, NOTE TO DO A JOBPEK AGAIN
FINCK2:	MOVEI	T1,1		;SMALLEST CONSTANT
	HIBER	T1,		;WAIT A JIFFIE
	  SLEEP	T1,		;OR A SECOND, IF NO HIBER
	JRST	FINCK1		;NOW LOOK AGAIN
;HERE IF MUST READ SWAPPING SPACE

REDSWP:	PUSHJ	P,FINCHK	;DID WE LOSE BECAUSE MON DECIDED TO SWAP?
	TRZE	F,R.SWIN	;DID WE SEE HIM COME IN?
	JRST	REDPEC		;YES, AND HE'S NOW IN CORE
	PUSH	P,T3		;SAVE JOBPEK ARGS
	PUSH	P,T4
	MOVE	P1,T1		;SAVE PTR TO CORE WANTED
	HRLZ	T1,SEGSWP	;LH=SEGMENT NUMBER
	HRRI	T1,.GTSWP	;SWAPPING PTR TABLE
	PUSHJ	P,GTBSPY	;GET SWAP PTR
	  JRST	REDSWE
	MOVEM	T1,SEGSWP	;SAVE PTR TO SEGMENT ON SWAPPING SPACE
	HLRE	T3,T1		;T1=SWAP PTR OR -1 IF IN CORE
	AOJE	T3,REDEN2	;EXIT IF IN CORE - TRY JOBPEK AGAIN
	HRRZ	T3,P1		;ADDR DESIRED
	LSH	T3,-WRDSPB	;T3=BLOCKS TO SKIP
	JUMPL	T1,FRAG		;JUMP IF FRAGMENTED

;HERE IF NOT FRAGMENTED, ALL ONE PIECE

	HLRZ	T2,P1		;LENGTH IN WORDS
	HRRZ	T1,P1		;ADDR DESIRED
	TRZ	T1,-<1_WRDSPB>	;MAKE WORDS TO SKIP IN FIRST BLOCK
	ADD	T2,T1		;MUST READ THE WORDS TO SKIP TOO
	MOVNS	T2		;MINUS LENGTH
	HRLZS	T2		;IN LH
	HRRI	T2,USRCOR-1	;MAKE IOWD PTR
	PUSHJ	P,REDPEC	;READ IT
	JRST	REDEND		;ALL DONE

REDSWE:	PUSHJ	P,E.SPTR	;REPORT PROBLEM GETTING SWAP PTR
	JRST	REDEND		;FINISH UP
;HERE IF FRAGMENTED ON SWAPPING SPACE

FRAG:	TLZ	T1,400000	;LH T1=ADDR OF BLOCK OF PTRS
	HLRZ	T2,T1		;IN RH OF T2
	MOVEI	P2,USRCOR-1	;FIRST ADDR FOR IOWD
	HLRZ	P3,P1		;LENGTH OF PIECE DESIRED=WORDS LEFT TO DO
	HRRZ	T1,P1		;ADDR OF FIRST WORD
	TRZ	T1,-<1_WRDSPB>	;WORDS WHICH WILL BE SKIPPED IN FIRST BLOCK
	ADD	P3,T1		;MUST READ THEM TOO
FRAG1:	PUSHJ	P,FRGFND	;FIND FIRST BLOCK TO READ
	JUMPE	T1,REDEND	;EXIT IF NO MORE TO READ
FRAGS1:	MOVSM	T1,SEGSWP	;SAVE THE PTR, SWAPPED FOR BYTE PTRS
	HLRZS	T1		;K IN THIS PIECE
	LSH	T1,@BLKPAG	;CONVERT TO BLOCKS
	SUB	T1,T3		;MINUS BLOCKS TO SKIP IN THIS PIECE
	LSH	T1,WRDSPB	;T1=TOTAL DATA WORDS IN THIS PIECE
	CAML	T1,P3		;SKIP IF LESS THAN WORDS STILL NOT READ
	MOVE	T1,P3		;THAT'S ALL WE NEED
	SUB	P3,T1		;SUBTRACT FROM WORDS LEFT TO DO
	MOVN	T2,T1		;T2=-WORDS THIS TRANSFER
	HRLZS	T2
	HRR	T2,P2		;ADDR IN CORE FOR THIS PIECE
	ADDM	T1,P2		;NEW ADDR AFTER THIS PIECE READ
	PUSHJ	P,REDPEC	;READ THIS PIECE
	JUMPE	P3,REDEND	;JUMP IF NO MORE NEEDED
	AOS	T1,SWPADR	;ADDR OF NEXT SWAPPING PTR
FRAG4:	PUSHJ	P,PEKSPY	;GET NEXT PTR
	JUMPE	T1,REDEND	;QUIT NOW IF NO MORE PTRS
	SETZ	T3,
	TLC	T1,-1		;SET TO TEST IF PTR TO NEW PTRS
	TLCE	T1,-1		;SKIP IF PTR TO NEW BLOCK OF PTRS
	JRST	FRAGS1		;COME BACK THROUGH
	MOVEM	T1,SWPADR	;STORE ADDR OF NEW BLOCK OF PTRS
	JRST	FRAG4		;AND LOOK FOR NEXT PTR
;SUBROUTINE TO FIND FIRST BLOCK TO READ
;ARGS	T2=ADDR OF NEXT WORD OF SWAPPING PTRS
;	T3=BLOCKS TO SKIP
;VALUES	T1=NEXT SWAPPING PTR
;	SWPADR=ADDR OF SWAPPING PTR

FRGFND:	HRRZ	T1,T2		;T1=ADDR OF NEXT WORD OF SWAPPING PTRS
	PUSHJ	P,PEKSPY	;T1=NEXT SWAPPING PTR
	JUMPE	T1,CPOPJ	;QUIT NOW IF NO MORE
	TLC	T1,-1		;SET TO TEST IF REAL PTR
	TLCN	T1,-1		;SKIP IF REAL PTR
	JRST	FRAG2		;ADDR OF NEW BLOCK OF PTRS
	JUMPE	T3,FRAGST	;START HERE IF NO MORE BLOCKS TO SKIP
	HLRZ	T4,T1		;T4=K IN THIS PIECE
	LSH	T4,@BLKPAG	;CONVERT TO BLOCKS
	SUB	T3,T4		;T3=BLOCKS LEFT TO SKIP
	JUMPL	T3,FRAG3	;USE THIS IF STARTS IN THIS PIECE
	AOJA	T2,FRGFND	;RH=ADDR OF NEXT PTR
FRAG2:	HRRZ	T2,T1		;RH=ADDR OF NEW BLOCK OF PTRS
	JRST	FRGFND		;START CHASING THAT
FRAG3:	ADD	T3,T4		;T3=BLOCKS TO SKIP IN THIS PIECE
FRAGST:	MOVEM	T2,SWPADR	;SAVE ADDR OF THIS PTR
	POPJ	P,
;HERE WHEN ALL THE PIECES READ

REDEND:	HRRZ	T1,P1		;ADDR DESIRED
	TRZ	T1,-<1_WRDSPB>	;CLEAR OUT ALL BUT ADDR IN 1ST BLOCK
	JUMPE	T1,REDEN0	;JUMP IF FIT EXACTLY AT BEGINNING OF BLOCK
	HRLZI	T1,USRCOR(T1)	;ADDR OF ACTUAL START OF DATA
	HRRI	T1,USRCOR	;BEGINNING OF BUFFER
	HLRZ	T2,P1		;LENGTH OF DATA
	BLT	T1,USRCOR-1(T2)	;MOVE UP DATA TO BEGINNING OF BUFFER
REDEN0:	HLRZ	T2,P1		;RE-GET LEN IN CASE JUMPED HERE
	CAIE	T2,MAXUCR	;UNLESS FULL BUFFER,
	SETZM	USRCOR(T2)	;CLEAR FIRST UNUSED LOC
	CAIL	T2,MAXUCR-1	;MORE THAN 1 UNUSED LOC?
	JRST	REDEN1		;NO, CLEAR NO MORE
	HRLZI	T1,USRCOR(T2)	;FIRST UNUSED LOC
	HRRI	T1,USRCOR+1(T2)	;SECOND "  "
	BLT	T1,USRCOR+MAXUCR-1 ;CLEAR TO END OF BUFFER
REDEN1:	RELEASE	SWP,
REDEN2:	POP	P,T4		;RESTORE JOBPEK ARGS
	POP	P,T3
	MOVEI	T2,T3		;ADDR OF JOBPEK BLOCK
	JOBPEK	T2,		;TRY AGAIN IN CASE JUST CAME INTO CORE
	  JFCL			;COULD HAPPEN FOR SHARABLE HIGH SEG
	POPJ	P,

;SUBROUTINE TO READ SWAPPING SPACE
;ARGS	T2=IOWD
;	T3=BLOCKS TO SKIP
;	SEGSWP=SWAPPING PTR
;VALUES	T1=BLOCK NUMBER READ

REDPEC:
;	HLRZ	T1,T2		;T1=LENGTH OF TRANSFER
;	CAILE	T1,-<1_WRDSPB>	;SKIP IF GT ONE BLOCK
;	HRLI	T2,-<1_WRDSPB>	;MUST READ AT LEAST ONE FULL BLOCK, IN CASE
				;READING A FEW WORDS AT THE END OF THE BLOCK
	PUSH	P,T2		;SAVE IOWD
	LDB	T4,JBYSUN	;LOGICAL UNIT IN SWAPPING LIST
	LDB	T1,JBYLKS	;LOGICAL K IN SWAPPING SPACE
	LSH	T1,@BLKPAG	;CONVERT TO BLOCKS
	ADD	T1,.UNSLB(T4)	;+FIRST BLOCK FOR SWAPPING=BEGINNING ON SWAP SPACE
	ADD	T1,T3		;PLUS BLOCKS TO SKIP
	MOVEI	T2,17		;DUMP MODE
	MOVE	T3,.SWPUN(T4)	;NAME OF UNIT
	SETZ	T4,
	OPEN	SWP,T2
	  JRST	E.SOPN
	USETI	SWP,T1		;SET TO READ FIRST BLOCK
	POP	P,T2		;RESTORE IOWD
	SETZ	T3,
	INPUT	SWP,T2		;READ
SWPIOE:	STATO	SWP,760000	;SKIP IF ERRORS
	POPJ	P,
	AOS	SWRGUF		;COUNT SWAP READ ERROR
	JSP	T2,SNH		;NO RETURN IF UUO
	  JRST	SWPIO1		;NO PRINT IF LOST THE ATTACH
	OUTSTR	[ASCIZ .
% SWAP READ ERROR UNIT .]
SWPIO1:	PUSH	P,T1		;SAVE BLOCK NUMBER READ
	GETSTS	SWP,T1		;READ ERROR STATUS
	HRLM	T1,-1(P)	;SAVE NEXT TO RETURN ADDR
	PUSHJ	P,ATTCHK	;ARE WE STILL ATTACHED?
	  JRST	SWPIO2		;NO, RESET STATUS, BUT NO PRINT
	LDB	T2,JBYSUN	;GET SWAP UNIT NUMBER
	MOVE	T2,.SWPUN(T2)	;T2=UNIT NAME
	PUSHJ	P,TSIXN		;TYPE IT
	OUTSTR	[ASCIZ . STATUS = .]
	HLRZ	T1,-1(P)	;SAVE STATUS
	PUSHJ	P,TOCT		;TYPE STATUS
SWPIO2:	HLRZ	T1,-1(P)	;RESTORE STATUS
	TRZ	T1,760000	;CLEAR ERROR BITS
	SETSTS	SWP,(T1)	;CLEAR ERROR
	JRST	TPOPJ		;RESTORE T1 AND EXIT
SUBTTL SUBROUTINES

;SUBROUTINE TO OUTPUT A CARRIAGE RETURN LINE FEED FOR DUMP CCL FILE

CCCRLF:	MOVEI	SC,C.CR		;CARRIAGE RETURN
	PUSHJ	P,CCOUT		;OUTPUT CHAR TO CCL FILE
	MOVEI	SC,C.LF		;LINE FEED - FALL INTO CCOUT

;SUBROUTINE TO OUTPUT A CHARACTER ON DUMP CCL FILE
;ARGS	SC(=16)=CHAR

CCOUT:	SOSG	C.BH+2
	OUTPUT	DSK,
	IDPB	SC,C.BH+1
	POPJ	P,
;SUBROUTINE TO COPY USER'S SEARCH LIST
;ARGS	T1=JOB NUMBER
;	T2=PPN
;	T3=ADDRESS-1 OF BLOCK TO STORE SEARCH LIST

GETSRC:	MOVEM	T1,GOBBUF+GOBJOB ;USER'S JOB NUMBER
	MOVEM	T2,GOBBUF+GOBPPN
	SETOM	GOBBUF+GOBNAM	;START AT BEGINNING OF JOB'S SEARCH LIST

GETSR1:	MOVE	T1,[GOBLEN,,GOBBUF]
	GOBSTR	T1,		;GET NEXT STR IN JOB'S SEARCH LIST
	  POPJ	P,		;ALL DONE
	MOVE	T1,GOBBUF+GOBNAM ;NEXT STR
	JUMPE	T1,CPOPJ	;EXIT IF FENCE OR
	AOJE	T1,CPOPJ	; IF END OF LIST
	PUSH	T3,GOBBUF+GOBNAM ;STORE NAME
	PUSH	T3,GOBBUF+GOBNAM+1 ;AND UNUSED WORD
	PUSH	T3,GOBBUF+GOBSTS ;AND STATUS WORD
	JRST	GETSR1		;LOOP TILL END OF LIST

;SUBROUTINE TO GET JOB'S DEFAULT PATH
;ARGS	J=JOB NUMBER WHOSE PATH TO READ
;VALUE	T1=POINTER TO PATH SPEC, OR PPN IF SFD'S NOT IMPLEMENTED

GETPTH:	HRLOI	T1,(J)		;READ JOB'S PATH FUNCTION
	MOVEM	T1,D.DPTH	;AT TOP OF PATH BLOCK
	MOVE	T1,[XWD DPTHLN,D.DPTH]
	PATH.	T1,
	  PJRST	GETPPN		;NO SFD'S-RETURN PPN
	MOVEI	T1,D.DPTH	;POINT TO PATH LIST
	POPJ	P,

;SUBROUTINE TO GET JOB'S PPN
;ARGS	J=JOB NUMBER
;VALUE	T1=PPN

GETPPN:	HRROI	T1,.GTPPN	;SETUP JBTPPN INDEX
	PUSHJ	P,GTBSPY
	  SETZ	T1,
	POPJ	P,
;SUBROUTINE TO CHECK IF USER ALLOWED TO WRITE THE FILE
;ARGS	T1=FILE NAME
;	T2=EXT
;	T3=PROTECTION
;	T4=DIRECTORY
;	CHANNEL DSK OPEN
;VALUES	T1-T4 PRESERVED
;RETURN CPOPJ IF ACCESS NOT ALLOWED
;	SKIP RETURN IF ACCESS ALLOWED

ACCCHK:	PUSH	P,T1
	PUSH	P,T2
	PUSH	P,T3
	PUSH	P,T4
	LOOKUP	DSK,T1		;LOOKUP FILE
	  JRST	CHKAC1		;DOESN'T EXIST YET
	LSH	T3,-^D27	;EXISTS, WILL SUPERSEDE, SET T3=PROTECTION
	HRLI	T3,AC.SUP	;SUPERSEDE FUNCTION
	JRST	CHKAC2
CHKAC1:	MOVE	T1,(P)		;PPN IS UFD NAME
	TLNE	T1,-1		;UNLESS PATH GIVEN
	JRST	CHKAC3		;IT'S A PROPER PPN
	JUMPE	T1,[HALT .]	;PROTECT AGAINST INTERNAL BUGS
	SKIPE	3(T1)		;DOES PATH INCLUDE ANY SFD'S?
	JRST	CHKAC5		;YES, SCAN DOWN TO FIND LAST
	MOVE	T1,2(T1)	;NO, JUST PICK UP PPN (=UFD NAME)
CHKAC3:	MOVSI	T2,'UFD'	;LOOKUP THE UFD
	MOVE	T4,MFDPPN	;DIRECTORY MFD
	LOOKUP	DSK,T1		;SEE IF UFD EXISTS
	  SETZ	T3,
CHKAC4:	TLZ	T3,777		;CLEAR OUT GARBAGE
	HLRZS	T3		;UFD PROTECTION TO RIGHT HALF
	HRLI	T3,AC.CRE	;CREATE IN UFD FUNCTION
CHKAC2:	MOVE	T2,T3		;T2=FUNCTION,,PROTECTION
	MOVE	T3,(P)		;T3=DIRECTORY
	TLNN	T3,-1		;IS IT A PATH?
	MOVE	T3,2(T3)	;YES, GET THE UFD PPN
	MOVE	T4,USRPPN	;T4=REQUESTING PPN
	MOVEI	T1,T2		;ADDR OF ACCESS-CHECK BLOCK
	CHKACC	T1,		;CHECK IF LEGAL OPERATION
	  SETZ	T1,		;DONT KNOW, ASSUME OK
	CLOSE	DSK,CL.NMB	;CLOSE SO WONT DO UPDATE ENTER
	POP	P,T4		;  BUT KEEP NAME BLOCKS FOR REFERENCE SOON
	POP	P,T3
	POP	P,T2
	JUMPE	T1,TPOPJ1	;IF GOT OK RETURN, SKIP BACK TO CALLER
TPOPJ:	POP	P,T1
	POPJ	P,
CHKAC5:	MOVEI	T2,3(T1)	;ADDR OF FIRST SFD NAME
	SKIPE	1(T2)		;IS THERE ANOTHER?
	AOJA	T2,.-1		;YES, CHECK AGAIN
	PUSH	P,0(T2)		;SAVE LAST SFD NAME
	PUSH	P,T2		;AND ITS ADDRESS
	MOVE	T1,0(T2)	;PICK UP LOWEST SFD NAME
	SETZM	0(T2)		;PREPARE TO LOOK IT UP IN NEXT HIGHER
	MOVSI	T2,'SFD'	;NAME AS GIVEN, EXT SFD
	MOVE	T4,-2(P)	;RE-GET POINTER TO PATH
	LOOKUP	DSK,T1		;GET PROTECTION OF SFD
	  SETZ	T3,		;IF NOT THERE, UNPROTECTED I GUESS
	POP	P,T2		;RESTORE POINTER TO LAST SFD IN PATH
	POP	P,0(T2)		;NOW RESTORE LAST SFD NAME
	JRST	CHKAC4		;PROCESS LIKE A UFD
;ROUTINE TO RESTART AFTER ERROR INTERCEPT
;ARGS	INTRES CONTAINS ADDRESS TO RESTART AT

INTRES:	MOVE	T1,INTBLK+2	;GET PC OF ERROR
	MOVEM	T1,INTRPC	;SAVE FOR ANALYSIS OR OUTPUT
	SETZM	INTBLK+2	;CLEAR PC
	GETLIN	T1,		;GET LINE NUMBER
	TLNN	T1,-1		;ATTACHED?
	JRST	REGO		;NO--RESTART
	GETLCH	T1		;GET LINE NUMBER
	HRLZI	T1,(T1)		;LH=LINE, RH=DETACH
	ATTACH	T1,		;DO A DET
	  AOS	ATTGUF		;WE TRIED
REGO:	HRRZ	T1,.JBDDT	;ADDR OF DDT IF ANY
IFE FTDET,<
	TLNN	F,L.OPRA	;RE-ATTACH IF SO DESIRED BY OPR
>;END FTDET
	JUMPE	T1,REGO1	;DONT ATTACH ORIGINAL LINE IF NO DDT
	HRLZ	T1,THSLIN	;OUR LINE NUMBER
	HRR	T1,THSJOB	;OUR JOB NUMBER
	TLO	T1,(AT.USR)	;SET TO USER LEVEL
	ATTACH	T1,		;TRY TO REATTACH OUR TTY
	  AOS	ATTGUF		;DEBUG - COUNT ATTACH FAILURES
REGO1:	MOVE	P,PDL		;RESET PUSH DOWN POINTER
	TLZ	F,L.TTYA!L.DUMP	;NOW DETACHED
				;DUMP BECOMES DCORE, SINCE DUMP INCOMPLETE
	AOS	INTGUF		;COUNT INTERCEPTS
	JRST	@INTADR

;COME HERE ON INTERCEPT DURING STARTUP

E.EINT:	OUTSTR	[ASCIZ	.
? ERROR INTERCEPT @PC .]
	HRRZ	T1,INTRPC	;GET SAVED PC
	PUSHJ	P,TOCT		;PRINT IN OCTAL
	OUTSTR	[ASCIZ	., BITS = .]
	HLRZ	T1,INTBLK+3	;GET TYPE INDICATOR BITS
	PUSHJ	P,TOCT		;PRINT THEM
	PUSHJ	P,PCRLF
	OUTSTR	DAEVER		;PRINT DAEMON VERSION
	EXIT			;QUIT
;SUBROUTINE TO CHECK USER ADDRESS
;ARGS	T1=XWD +LENGTH,START
;	J=JOB NUMBER
;VALUES	T1=XWD +LENGTH, ADDR IN SEGMENT
;	T2=JOB OR SEGMENT
;	THSOFF SET IF HISEG
;RETURN	CPOPJ IF BAD ADDRESS
;	CPOPJ1 IF ADDRESS IS VALID
;ALL AC'S RESPECTED

UADCHK:	PUSH	P,T1		;PRESERVE LEN,START
	HLRE	T2,T1
	SOJL	T2,TPOPJ	;NEG OR ZERO LEN NO FAIR
	ADDI	T2,(T1)		;ADDR OF LAST WORD IN GROUP
	MOVEI	T1,(J)		;JOB (LOW SEG) NO
	PUSHJ	P,JSSIZE	;GET ITS SIZE
	  JRST	TPOPJ		;SOMEBODY GOOFED
	CAILE	T2,(T1)		;IS LIST END WITHIN LOW SEG?
	AOJA	T1,HADCHK	;NO, CHECK HIGH SEG
	POP	P,T1		;RESTORE LEN,,START
	CAIGE	T2,17		;END IN AC'S?
	JRST	LOSOK		;YES, ITS OK
	MOVEI	T2,(T1)		;GET START
	CAIGE	T2,.JBPFI	;PAST MONITOR RESERVED AREA?
	POPJ	P,		;NO, ERROR
LOSOK:	MOVEI	T2,(J)		;RETURN JOB NUMBER
	SETZM	THSOFF		;AND LOW SEG FLAG
	JRST	CPOPJ1		;GOOD RETURN

HADCHK:	TRNN	T1,400000	;IS LOW SEG BIGGER THAN 128K?
	MOVEI	T1,400000	;NO, HIGH SEG STARTS HERE
	MOVEM	T1,THSOFF	;USE THAT AS OFFSET
	SUBI	T2,(T1)		;GET END RELATIVE TO HIGH SEG
	JUMPL	T2,TPOPJ	;TOO LOW FOR HIGH SEG
	EXCH	T1,0(P)		;PREPARE TO...
	SUBB	T1,0(P)		;GET ADJUSTED LEN,,START ON STACK
	TRNE	T1,400000	;TROUBLE IF
	JRST	TPOPJ		;START NOT IN HIGH SEG
	HRROI	T1,.GTSGN	;SEGMENT TABLE
	PUSHJ	P,GTBSPY	;FIND SEG NO FOR HI SEG
	  JRST	TPOPJ		;STRANGE INDEED
	JUMPLE	T1,TPOPJ	;BOMB IF NO HIGH SEGMENT
	HRLM	T1,-1(P)	;SAVE WITH RETURN ADDR
	PUSHJ	P,JSSIZE	;GET HIGH SEG SIZE
	  JRST	TPOPJ
	CAILE	T2,(T1)		;IS END WITHIN HIGH SEG?
	JRST	TPOPJ		;NO
	HLRZ	T2,-1(P)	;GET SEG NO
	JRST	TPOPJ1		;RESTORE ADJUSTED LEN,,START AND GIVE GOOD RETURN
;SUBROUTINE TO GET THE LENGTH OF A JOB OR SEGMENT
;ARGS	T1=JOB OR SEGMENT #
;VALUES	T1=0,,HIGHEST LEGAL ADDR RELATIVE TO START OF SEGMENT
;RETURN	CPOPJ IF NO SUCH JOB OR SEG NO
;	CPOPJ1 IF SUCCESSFUL

JSSIZE:	MOVSI	T1,(T1)		;JOB OR SEG NO AS ITEM
	HLLM	T1,0(P)		;SAVE IT
	HRRI	T1,.GTADR	;PROT,,RELOC TABLE IF JOB IN CORE
	PUSHJ	P,GTBSPY
	  POPJ	P,
	HLRZS	T1		;PROT = LEN OF SEGMENT
	JUMPN	T1,CPOPJ1	;RETURN UNLESS SWAPPED OUT
	HLLZ	T1,0(P)		;RE-GET JOB (SEG) NO
	HRRI	T1,.GTSWP	;JOBS SWAPPING PARAMS
	PUSHJ	P,GTBSPY
	  POPJ	P,
	ANDI	T1,777000	;NO OF PAGES ON SWAPPING DEVICE
	XCT	PKLSH		;DO SHIFT IF SWAP CHUNKS = K, NOT PAGES
	SOJA	T1,CPOPJ1	;SUCCESSFUL
SUBTTL OUTPUT SUBROUTINES

;SUBROUTINE TO MARK THE SPOT FOR DATA TO COME LATER IN THE CORE-IMAGE FILE

MRKSPT:	MOVE	T1,PATTERN	;WRITE STANDARD PATTERN
	PUSHJ	P,DWRITE
	MOVE	T1,CURBLK	;CURRENT BLOCK IN FILE
	MOVEM	T1,REMBLK	;SAVE FOR REWRITING LATER
	MOVEM	BP,REMWRD	;AND WORD ADDR
	SETZM	WRDCNT		;START COUNTING WORDS WRITTEN
	POPJ	P,

;SUBROUTINE TO WRITE ONE WORD IN THE CORE-IMAGE FILE
;ARGS	T1=WORD TO WRITE

DWRITE:	AOS	WRDCNT		;COUNT WORDS WRITTEN
	AOBJN	BP,DWRT1	;JUMP IF BUFFER NOT FULL
	SKIPE	CURBLK		;SKIP IF FIRST BLOCK OF FILE
	PUSHJ	P,BLKWRT	;NO, WRITE OUT OLD BLOCK
	SETZM	DAEBUF+1
	MOVE	BP,[DAEBUF+1,,DAEBUF+2]
	BLT	BP,DAEBUF+177
	MOVE	BP,BPSTRT	;RESET BYTE PTR TO BEGINNING OF BLOCK
	ADDI	BP,1		;POINT TO BUFFER
	AOS	CURBLK		;AND BUMP CURRENT BLOCK NUMBER
DWRT1:	MOVEM	T1,(BP)		;STORE WORD IN BLOCK
	POPJ	P,

;SUBROUTINE TO WRITE A BLOCK
;ARGS	CURBLK=BLOCK NUMBER TO WRITE

BLKWRT:	MOVE	T2,CURBLK	;BLOCK NUMBER IN FILE
	SKIPE	UPDFLG		;SKIP IF DON'T NEED TO DO USETO
	USETO	DSK,(T2)	;SET TO WRITE THIS BLOCK
	SETZM	UPDFLG		;NOTE THAT WE DONT NEED USETO NEXT TIME
	OUTPUT	DSK,DLIST	;WRITE THE BLOCK
	STATO	DSK,760000	;SKIP IF ERRORS ON THE WRITE
	POPJ	P,
	JRST	E.OERR
;SUBROUTINE TO UPDATE THE WORD MARKED BEFORE FOR UPDATING
;ARGS	T1=ACTUAL DATA
;	REMBLK=BLOCK NUMBER IN FILE CONTAINING WORD TO WRITE
;	REMWRD=ADDR IN DAEBUF OF WORD TO WRITE

WRTSPT:	MOVE	T2,REMBLK	;T2=BLOCK WHICH CONTAINS THE WORD
	MOVE	T4,REMWRD	;T4=ADDR OF WORD IN DAEBUF
	CAME	T2,CURBLK	;SKIP IF STILL IN CURRENT BLOCK
	JRST	WRTSP1		;NO, MUST UPDATE PREVIOUSLY WRITTEN BLOCK
	EXCH	T1,(T4)		;STORE IN CORE
	CAME	T1,PATTERN	;AND SEE IF WE FOUND THE RIGHT WORD
	JRST	E.BPT		;NO, SOMETHING WENT WRONG
	POPJ	P,		;BEAUTIFUL!

;HERE TO UPDATE A PREVIOUSLY WRITTEN BLOCK

WRTSP1:	USETI	DSK,(T2)	;SET TO READ THE BLOCK
	INPUT	DSK,UPDLST	;READ THE BLOCK
	STATZ	DSK,760000	;TEST FOR ERRORS
	JRST	E.WRD		;DIDN'T MAKE IT
	ADDI	T4,SECBUF-DAEBUF;CHANGE ADDR TO POINT TO SECBUF
	EXCH	T1,(T4)		;STORE DATA, GET OLD WORD
	CAME	T1,PATTERN	;COMPARE WITH PATTERN
	JRST	E.BPT		;SOMETHING WENT WRONG
	USETO	DSK,(T2)	;NOW SET TO WRITE THE BLOCK BACK OUT
	SETOM	UPDFLG		;NOTE THAT NEXT REGULAR OUTPUT MUST DO USETO
	OUTPUT	DSK,UPDLST	;REWRITE THE BLOCK
	STATO	DSK,760000	;CHECK FOR ERRORS
	POPJ	P,		;OK
E.OERR:	AOS	WRTGUF		;NOTE ERROR
	JSP	T2,SNH		;NO RETURN IF UUO
	  POPJ	P,		;QUIT IF GOT DETACHED
	OUTSTR	[ASCIZ .
? OUTPUT.]
	JRST	E.WRD1
E.WRD:	JSP	T2,SNH		;NO RETURN IF UUO
	  POPJ	P,		;DIE IF LOST TTY
	OUTSTR	[ASCIZ .
? INPUT.]
E.WRD1:	OUTSTR	[ASCIZ . ERROR, STATUS = .]
	GETSTS	DSK,T1
	PUSHJ	P,TOCT
	PJRST	PCRLF

E.BPT:	EXCH	T1,(T4)		;RESTORE ORIGINAL WORD
	JSP	T2,SNH		;DON'T COME BACK IF UUO
	  POPJ	P,		;RETURN IMMEDIATE IF NOT ATTACHED
	OUTSTR	[ASCIZ .
? TRIED TO OVERWRITE DATA WORD.]
	PJRST	PCRLF
;SUBROUTINE TO PERFORM GETTAB VIA SPY IF POSSIBLE
;ARGS	T1=GETTAB ARG
;VALUES	T1=GETTAB VALUE
;THERE IS NO NEED TO SUPPORT -2 ITEM (JOBS HIGH SEG)

GTBSPY:	JUMPGE	T1,.+2		;ENSURE THAT NEG INDEX MEANS JOB (J), NOT US
	HRLI	T1,(J)		;GET THE JOB #
IFN FTSPY,<
	PUSH	P,P1		;SAVE P1
	PUSH	P,P2		;SAVE P2
	HRRZI	P1,(T1)		;P1=TABLE NUMBER
	CAML	P1,MAXGTB	;SKIP IF LEGAL TABLE
	JRST	GTBGTB		;NO, TRY GETTAB ANYWAY
	ADD	P1,GTBST	;ADDR OF PTR FOR THIS TABLE
	MOVE	P2,(P1)		;P2 GETS MODIFIED NUMTAB WORD
	TLNE	P2,(GT.PRC)	;IS DATUM IN THE PDB?
	JRST	GTBPDB		;YES. GO HANDLE DIFFERENT FORMAT
	LDB	P2,[POINT 9,P2,8] ;NO. GET MAX ITEM VALUE
	MOVSS	T1		;AND ITEM NUMBER INTO RH OF T1
	CAIGE	P2,(T1)		;IS LEGAL MAX .GE. DESIRED?
	JRST	GTBGT1		;NO. TRY GETTAB ANYWAY, PROBABLY LOSE.
	MOVE	T1,@(P1)	;GET VALUE
GTBXIT:	POP	P,P2		;RESTORE P2
	POP	P,P1		;RESTORE P1
	JRST	CPOPJ1		;GOOD RETURN

GTBPDB:	SKIPN	PDBPTR		;IS JBTPDB BASE AVAILABLE?
	JRST	GTBGTB		;NO. USE A GETTAB
	HLRZ	P2,T1		;JOB NUMBER
	ADD	P2,PDBPTR	;PLUS JBTPDB ADDRESS
	MOVE	P2,400000(P2)	;GET ADDRESS OF WD 0 OF JOBS PDB
	ADD	P2,0(P1)	;ADD ON SPY OFFSET AND ITEM NUMBER
				; WHICH WERE BOTH IN GTBST TABLE
	MOVE	T1,(P2)		;GET THE WORD FROM THE PDB
	JRST	GTBXIT		;AND EXIT FROM GETTAB SIMULATOR

GTBGT1:	MOVSS	T1		;PUT T1 BACK TO ORIGINAL VALUE
GTBGTB:	POP	P,P2		;RESTORE P2
	POP	P,P1		;RESTORE P1
>	;END CONDITIONAL ON FTSPY

	GETTAB	T1,		;TRY GETTAB
	  POPJ	P,
IFN FTSPY,<
	AOS	GTBGUF		;DEBUG--COUNT TIMES WE THOUGHT GETTAB
>				; WOULD LOSE BUT IT DIDNT
	JRST	CPOPJ1		;WINS
;SUBROUTINE TO GET DATA FROM GETTAB SUB-TABLE
;ARGS	T3= GETTAB ARG FOR SUB-TABLE POINTER
;	T2= SUBTABLE ARG: TABLE# CONTAINING SUBTABLE,,ITEM #
;VALUE	T1= DESIRED ITEM
;SKIP RETURN IF ITEM DEFINED

GSUBTB:	PUSH	P,T3		;SAVE THAT ARG
	MOVE	T1,T3		;GET SUBTABLE POINTER
	PUSHJ	P,GTBSPY
	  JRST	GSUBTX		;TOO BAD, NO SUBTABLE
	JUMPE	T1,GSUBTX	;NO SUBTABLE EXISTS
	LDB	T3,[POINT 9,T1,8] ;GET UPPER LIMIT ON SUBTABLE
	CAIGE	T3,0(T2)	;COMPARE DESIRED ITEM #
	JRST	GSUBTX		;OOPS, OFF THE END
	HRRZS	T1		;SUBTABLE POINTER IS AN ITEM NUMBER
	ADD	T1,T2		;WITH SUB-ITEM AND TABLE
	MOVSS	T1		;SWAP TO GETTAB FORM
	PUSHJ	P,GTBSPY	;GETTAB THAT
	  JRST	GSUBTX		;LOSE
	AOS	-1(P)		;WIN, TAKE SKIP RETURN
GSUBTX:	POP	P,T3		;RESTORE T3
	POPJ	P,


;SUBROUTINE TO PERFORM PEEK VIA SPY IF POSSIBLE
;ARGS	T1=ADDR OF LOCATION DESIRED
;VALUES	T1=CONTENTS OF LOCATION

PEKSPY:
IFN FTSPY,<
	SKIPE	MAXGTB		;SKIP IF SPY ILLEGAL
	SKIPA	T1,400000(T1)	;OK, GET CONTENTS OF LOC
>	;END CONDITIONAL ON FTSPY

	PEEK	T1,		;CANT, TRY PEEK
	POPJ	P,
;SUBROUTINE TO SAVE P1-P4

SAVE4:	PUSH	P,P1
	PUSH	P,P2
	PUSH	P,P3
	PUSH	P,P4
	PUSHJ	P,(T4)
	  JRST	.+2
	AOS	-4(P)
	POP	P,P4
	POP	P,P3
	POP	P,P2
	POP	P,P1
	POPJ	P,
SUBTTL	CLOCK QUEUE SUBROUTINES

;HERE WHEN A TIMER RUNS OUT
IFN FTCLCK!ICLKRQ,<

WAKJOB:	HRRE	J,NEXTJB	;GET THE JOB NUMBER
	SETZM	@JBTCLK		;CLEAR OUT ENTRY
	PUSHJ	P,CLEANQ	;CLEAN THE QUEUE
	JUMPLE	J,WAKSLF	;JOBS .LE. 0 ARE INTERNAL
IFN FTCLCK,<
	WAKE	J,		;WAKE THE JOB
	  AOS	WAKGUF		;WE TRIED
>;END FTCLCK COND (THE INNER ONE)
IFE FTCLCK,<AOS CLKGUF>		;NOTE SHOULD NEVER HAPPEN
	JRST	DALOOK		;RESCAN THE QUEUE

WAKSLF:	PUSHJ	P,@CLKDSP(J)	;INVOKE INTERNAL ROUTINE
	JRST	DALOOK

	EXP	FRCFCT		;(-2) FORCE OUT THE FACT BUFFER
	EXP	USCAN		;(-1) CHECKPOINT THE DISK STATUS
CLKDSP:	EXP	CHECK		;(0) CHECKPOINT JOBS

	DEFINE	.IFNFT	(FT,LBL),<
IFE FT,<LBL:	..IFFT==1>>
..IFFT==0

.IFNFT	(FTCHKPNT,CHECK)
.IFNFT	(FTUSCN,USCAN)
.IFNFT	(CHKFCT,FRCFCT)
.IFNFT	(MAXAGE,FRCFCT)
IFN ..IFFT,<
	AOS	CLKGUF		;NOTE A REQUEST THAT SNH
	POPJ	P,
>
	PURGE	.IFNFT,..IFFT

;STILL IN FTCLCK!ICLKRQ CONDITIONAL
;SUBROUTINE TO ENTER A REQUEST INTO THE QUEUE
;ARGS	T1=NUMBER OF SEC TO SLEEP
;	J=JOB NUMBER
;USES T1-T4

CLKREQ:	JUMPE	T1,NULREQ	;NULL REQUEST - CLEAN Q AND WAKE IMMEDIATELY
	MUL	T1,JIFSEC	;CONVERT TO JIFFIES IN T2
	MOVE	T1,[XWD %NSUPT,.GTNSW]
	PUSHJ	P,GTBSPY	;GET BY SPY
	  JRST	NULREQ		;CAN NOT LOOSE
	ADD	T2,T1		;TIME TO GET UP
	MOVEM	T2,@JBTCLK	;STORE IN QUEUE
	PJRST	CLEANQ		;CLEAN THE QUEUE

NULREQ:	SETZM	@JBTCLK		;CLEAR THE REQUEST
	JUMPLE	J,CLEANQ	;NO WAKE IF INTERNAL REQUEST
IFN FTCLCK,<
	WAKE	J,		;WAKE THE JOB IMMEDIATELY
	  AOS	WAKGUF		;WE TRIED AND FAILED
>;END FTCLCK COND
IFE FTCLCK,<AOS CLKGUF>		;BUMP SNH COUNTER
;	PJRST	CLEANQ		;FALL THROUGH TO RE-SCAN Q

;HERE TO SORT THE QUEUE

CLEANQ:	SETZB	T2,NEXTUP	;FLAG QUEUE EMPTY
				; T2 GETS NEXT JOB TO WAKE
	PUSH	P,J		;SAVE AC J
	MOVE	J,QPNTR		;GET THE AOBJN POINTER
	HRLOI	T1,377777	;T1_UPTIME OF NEXT WAKE
FNDMIN:	SKIPE	T3,@JBTCLK	;GET FIRST TIME
	CAMG	T1,T3		;YES--IS IT BETTER
	JRST	NXTREQ		;NO--TRY NEXT
	MOVE	T1,T3		;T1_SHORTEST TIME
	HRREI	T2,(J)		;T2_JOB WITH THAT TIME
NXTREQ:	AOBJN	J,FNDMIN	;LOOP OVER ALL JOBS
	MOVEM	T1,NEXTUP	;SAVE T1
	MOVEM	T2,NEXTJB	;SAVE JOB NUMBER
	POP	P,J
	POPJ	P,

>;END FTCLCK!ICLKRQ CONDITIONAL
;SUBROUTINE TO ENSURE THAT ANY FACT FILE ENTRY
;GETS OUT IN MAXAGE SECONDS

IFN CHKFCT,<
IFN MAXAGE,<
BUFAGE:	SKIPE	FACTSZ		;IF ANYTHING THERE, REQUEST IS ALREADY IN
	POPJ	P,
	PUSH	P,J		;SAVE J
	HRROI	J,AGERQ		;SET OUR REQUEST TYPE
	MOVEI	T1,MAXAGE	;SET MAX TIME IN BUFFER
	PUSHJ	P,CLKREQ	;MAKE THE REQUEST
	POP	P,J
	POPJ	P,		;DONE

FRCFCT:	TLO	F,L.FORC	;ENSURE IT GETS DUMPED SOON
	POPJ	P,
>;END MAXAGE COND
IFE MAXAGE,<BUFAGE==CPOPJ>
>;END CHKFCT COND

;SUBROUTINE TO RETURN JOB'S CONTROLLING TTY NUMBER
;ARG	J=JOB NUMBER
;VALUE	T1=TTY NUMBER (-1 IF CTY)
;NON-SKIP RETURN IF JOB DETACHED

GETTTY:	HRROI	T1,.GTTTY	;GET JOB'S TTY DDB ADDR
	PUSHJ	P,GTBSPY	;GET ADDR OF DDB FOR USER JOB
	  POPJ	P,		;CAN'T FIND IT!!!
	JUMPE	T1,CPOPJ	;GIVE UP IF JOB IS DETACHED
IFN DEVNAM,<MOVEI T1,DEVNAM(T1)>
	PUSHJ	P,PEKSPY	;GET TTY NAME FROM DDB
	TLNN	T1,-1		;LEFT HALF 0 IF DETACHED
	POPJ	P,		;LOSE...
	HRLZI	T2,(T1)		;LINE NUMBER IN SIXBIT TO LEFT HALF
	JUMPE	T2,TTYCTY	;ONLY CTY HAS NO LINE NO
	SETZ	T1,
DAGLIN:	LSH	T2,3		;IGNORE 3 BITS OF OCTAL SIXBIT CODE
	LSHC	T1,3		;BUT GET THE NUMERIC QUANTITY
	JUMPN	T2,DAGLIN	;LOOP IF ANY MORE DIGITS
	JRST	CPOPJ1		;THAT'S ALL THERE IS TO IT

TTYCTY:	SETO	T1,		;NOTE CTY
	JRST	CPOPJ1		;AND RETURN SUCCESSFUL
;SUBROUTINE TO SCAN ALL DISK UNIT DATA BLOCKS
; RECORDING STATUS AND ERROR INFORMATION IN ERROR.SYS

IFN FTERR,<
IFN FTUSCN,<

USCAN:
IFE FTDET,<
	TLNE	F,L.USC		;IS SCAN SUPPRESSED?
	POPJ	P,		;YES, IGNORE
>;END FTDET
	MOVE	T1,[XWD SYSUNI,.GTLVD]
	PUSHJ	P,GTBSPY	;GET ADDR OF FIRST UNIT DATA BLOCK
	  POPJ	P,		;LOOKS BAD, FOLKS
USCLUP:	HLRZ	P3,T1		;ADDR OF NEXT UNIT DATA BLOCK
	JUMPE	P3,USCEND	;END OF LIST
	MOVSI	T1,ER.USC_9
	PUSHJ	P,ERRINI	;(0-3) HEADER
	MOVE	T2,XUSCL	;SETUP TO DUMP FROM LIST
	PUSHJ	P,UNIDMP	;DUMP A SET OF UNIT DATA BLOCK ITEMS
	PUSHJ	P,ERRFIN	;WRITE THAT CHUNK
	MOVEI	T1,UNISYS(P3)	;ADDR IN UDB OF POINTER TO NEXT
	PUSHJ	P,PEKSPY	;GET POINTER TO NEXT IN SYSTEM
	JRST	USCLUP		;DUMP IT

USCEND:	MOVE	T1,CUTIM	;PICK UP TIME BETWEEN SCANS
	MOVEI	J,USCRQ		;INTERNAL REQUEST CODE
	PJRST	CLKREQ		;LOG REQUEST AND RETURN
>;END FTUSCN CONDITIONAL


;SUBROUTINE TO DUMP SELECTED MONITOR ITEMS
;ARGS	T2=AOBJN WORD FOR LIST OF ITEMS
;	P3=BASE ADDR OF TABLE FROM WHICH ITEMS COME
;	P4=AOBJN WORD FOR OUTPUT BUFFER
;VALUES	P4=UPDATED BUFFER POINTER
;RETURN	CPOPJ, T1-2 BLOWN, OTHERS INTACT

UNIDMP:	MOVE	T1,0(T2)	;GET ITEM'S INDEX WITHIN TABLE
	ADDI	T1,(P3)		;ADD TABLE BASE ADDR
	PUSHJ	P,PEKSPY
	PUSH	P4,T1		;STORE IN ERROR.SYS BUFFER
	AOBJN	T2,UNIDMP	;LOOP FOR ALL ITEMS
	POPJ	P,

;STILL IN FTERR COND
;TABLES FOR UNIT DATA BLOCK ITEMS TO BE DUMPED

IFN FTUSCN,<
XUSCL:	XWD	.-ZUSCL,.+1	;AOBJN WORD FOR TABLE OUTPUT BY USCAN
	EXP	UNINAM		;(3) DEV NAM
	EXP	UNIHID		;(4) PACK ID
	EXP	UNIHCT		;(5) HARD ERROR COUNT
	EXP	UNISCT		;(6) SOFT ERROR COUNT
	EXP	UNIPCT		;(7) SEEK ERROR COUNT
	EXP	UNIHNG		;(10) HUNG COUNTS
	EXP	UNIMCT		;(11) SOFTWARE-DETECTED ERRORS
	EXP	UNIBRC		;(12) BUFFERED READS
	EXP	UNIBWC		;(13) BUFFERED WRITES
	EXP	UNIDRC		;(14) DUMP READS
	EXP	UNIDWC		;(15) DUMP WRITES
	EXP	UNIMRC		;(16) MONITOR READS
	EXP	UNIMWC		;(17) MONITOR WRITES
	EXP	UNIICT		;(20) SWAP READS
	EXP	UNIOCT		;(21) SWAP WRITES
	EXP	UNIMSC		;(22) MONITOR SEEKS
	EXP	UNIUSC		;(23) USER SEEKS
ZUSCL==.-1
>;END FTUSCN CONDITIONAL

IFN UNITN,<
XDVEL:	XWD	.-ZDVEL,.+1
	EXP	UNINAM	;(3) PHYSICAL UNIT NAME
	EXP	UNIHID	;(4) PACK (HOME BLOCK) ID
	EXP	UNIHCT	;(5) HARD ERROR COUNT
	EXP	UNISCT	;(6) SOFT ERROR COUNT
	EXP	UNIECT	;(7) RETRY COUNT
	EXP	UNISOF	;(10) 1CONI - ERROR CONI AFTER INITIAL ATTEMPT
	EXP	UNIERR	;(11) 2CONI - ERROR CONI AFTER 1ST RECALIBRATE
	EXP	UNISDI	;(12) 1DATAI - AFTER INITIAL ATTEMPT
	EXP	UNIHDI	;(13) 2DATAI - AFTER 1ST RECALIBRATE
	EXP	UNIHBN	;(14) BLOCK NO OF LAST HARD ERROR
	EXP	UNIMCT	;(15) SOFTWARE-DETECTED ERROR COUNTS
	EXP	UNIPCT	;(16) SEEK INCOMPLETE ERRORS
	EXP	UNIHNG	;(17) HUNG COUNTS
ZDVEL==.-1
>;END UNITN COND

;STILL IN FTERR COND
SUBTTL	ROUTINES TO RECORD HARDWARE ERROR INFO IN ERROR.SYS

;SUBROUTINE TO RECORD A CPU-DETECTED ERROR
;ARGS	T1=ERROR.SYS CODE IN BITS 0-8
;	P1=CPU #
;	P2=CPU # TIMES 2 (FOR GETTAB CPU TABLES)
;RETURNS CPOPJ, P1 AND P2 INTACT, P4, T1-4 BLOWN

IFN CPUN,<
GCPERR:	PUSHJ	P,ERRINI	;(0-2) SETUP BUFFER AND P4
	MOVSI	T1,%CCPHY	;PHYSICAL CPU NAME
	HRRI	T1,.GTC0C(P2)	;IN THIS CPU'S CONSTANT TABLE
	PUSHJ	P,GTBSPY
	  SETZ	T1,		;SNH
	PUSH	P4,T1		;(3) DEVICE NAME
	MOVSI	T1,%CVTPE
	PUSHJ	P,GCPVAR	;(4)TOTAL ERRORS WHICH RECURRED ON SWEEP OF CORE
	MOVSI	T1,%CVSPE
	PUSHJ	P,GCPVAR	;(5) TOTAL NOT REPRODUCABLE
	MOVSI	T1,%CVMPC	;MEM PAR CONTINUES
	PUSHJ	P,GCPVAR	;(6)
	MOVSI	T1,%CVMPP	;PC AT TIME OF ERROR
	PUSHJ	P,GCPVAR	;(7) PC (EXEC OR USER)
	MOVSI	T1,%CVMPW	;1ST WORD FOUND IN ERROR
	PUSHJ	P,GCPVAR	;(10)
	MOVSI	T1,%CVMPA	;FIRST BAD ADDRESS
	PUSHJ	P,GCPVAR	;(11)
	AOBJN	P4,.+1		;(12) SPACE FOR
EC%PAR==12			;PARITY DATA SUBTABLE POINTER
	AOBJN	P4,.+1		;(13) SPACE FOR
EC%BAT==13			;BAD ADDRESS SUBTABLE POINTER

	MOVSI	T3,%CCPAR	;SUB-TABLE POINTER FOR OTHER PAR STUFF
	HRRI	T3,.GTC0C(P2)	;FROM CONSTANTS TABLE
	MOVSI	T2,.GTC0V(P2)	;SUBTABLE IS IN CPU VAR TABLE
PARSLP:	PUSHJ	P,GSUBTB	;GET ENTRY FROM SUBTABLE
	  JRST	EPARTB		;END OF PARITY SUBTABLE
	PUSH	P4,T1		;GIVE
	AOJA	T2,PARSLP	;GET WHOLE SUBTABLE
EPARTB:	MOVEI	T1,ERABUF+EC%PAR+1	;START LOC OF PAR ENTRY -1
	SUBI	T1,(P4)		;-LENGTH WRITTEN
	JUMPE	T1,NPARTB	;IF NONE, THEN NO BAD ADDR'S EITHER
	HRLI	T1,EC%PAR+2	;REL LOC OF SUB TABLE
	MOVSM	T1,ERABUF+EC%PAR
	HRRZM	P4,ERABUF+EC%BAT

;STILL IN FTERR COND AND CPUN COND
;HERE TO RECORD BAD ADDRESSES

GBATBL:	HRRI	T2,%CVPTS	;OTHER POINTERS ARE ALREADY SET
	PUSHJ	P,GSUBTB	;NO OF BAD ADDRESSES SAVED
	  JRST	NBATTB		;NONE IF NO TABLE FOR THEM
	MOVEI	T4,(T1)		;KEEP THE COUNT
	JUMPE	T4,NBATTB	;QUIT IF NONE
	HRLI	T3,%CCMPT	;LOOK IN BAT SUBTABLE NOW
	HLLZS	T2		;START AT BEGINNING OF TABLE
BATSLP:	PUSHJ	P,GSUBTB	;GET NEXT BAD ADDRESS
	  JRST	EBATTB		;END OF SUB-TABLE
	MOVEM	T1,1(P4)	;SAVE THE BAD ADDR
	AOBJP	P4,EBATTB	;CHECK FOR BUFFER OVERFLOW
	AOJ	T2,		;READY FOR NEXT ENTRY
	SOJG	T4,BATSLP	;GET IT IF ONE WAS STORED
EBATTB:	MOVE	T1,ERABUF+EC%BAT
	MOVEI	T2,(T1)
	SUBI	T1,(P4)
	JUMPE	T1,NBATTB	;IN CASE SUB-TABLE LENGTH = 0
	SUBI	T2,ERABUF-1	;REL LOC OF FIRST WORD OF BAD ADDR TABLE
	HRLI	T2,(T1)
	MOVEM	T2,ERABUF+EC%BAT
	PJRST	ERRFIN

NBATTB:	SETZM	ERABUF+EC%BAT
	PJRST	ERRFIN		;APPEND TO ERROR.SYS AND RETURN

NPARTB:	SUBI	P4,2		;NO PARITY SUBTABLES, SO DELETE POINTERS
	PJRST	ERRFIN

GCPVAR:	HRRI	T1,.GTC0V(P2)	;CUT DOWN THE TYPING BY PUTTING THIS
	PUSHJ	P,GTBSPY	; ALL IN ONE PLACE
	  SETZ	T1,
	PUSH	P4,T1		;SAVE AN ITEM IN THE ERROR FILE
	POPJ	P,

>;END CPUN COND
;STILL IN FTERR COND
;SUBROUTINE TO RECORD A CHANNEL-DETECTED PARITY ERROR OR NON-EX MEM
;ARGS	P2=ADDRESS OF CHANNEL DATA BLOCK
;RETURN	CPOPJ, P1-P3 INTACT; P4, T1-4 BLOWN

IFN CHNN,<
GCHERR:	PUSHJ	P,ERRINI	;(0-2) HEADER, SET UP P4, CLEAR BUFFER
	MOVEI	T1,.CHLUE(P2)	;GET POINTER TO LAST UNIT WITH ERROR
	PUSHJ	P,PEKSPY
	ANDI	T1,-1		;RH ONLY
	JUMPE	T1,NODVNM	;STORE 0 IF DEVICE UNKNOWN
IFN UNINAM,<ADDI T1,UNINAM>	;ADDR OF NAME OF ERROR UNIT
	PUSHJ	P,PEKSPY	;PICK UP UNIT NAME
NODVNM:	PUSH	P4,T1		;(3) UNIT NAME
	MOVEI	T1,.CHNXM(P2)
	PUSHJ	P,PEKSPY	;GET NXM COUNT FOR THIS CHANNEL
	PUSH	P4,T1		;(4) NON-EX MEM COUNT
	MOVEI	T1,.CHMPE(P2)
	PUSHJ	P,PEKSPY
	PUSH	P4,T1		;(5) MEM PAR ERR COUNT THIS CHANNEL
	MOVEI	T1,.CHDPE(P2)
	PUSHJ	P,PEKSPY
	PUSH	P4,T1		;(6) DEVICE PARITY ERRORS
	MOVSI	T2,<.CHICW-.CHDW0-1>	;SETUP AOBJN WORD
	HRRI	T2,.CHICW(P2)	;WITH POINTER TO CHAN DATA BLOCK
GCHLUP:	MOVEI	T1,(T2)		;GET ADDR TO EXAMINE
	PUSHJ	P,PEKSPY
	PUSH	P4,T1		;(7-16) CONTROL AND DATA WORDS
	AOBJN	T2,GCHLUP
	PJRST	ERRFIN		;WRITE THE STUFF AND RETURN

>;END CHNN COND
;STILL IN FTERR COND
;SUBROUTINE TO RECORD A DISK ERROR
;ARGS	P1=AOBJN WORD FOR ALL UNITS IN SYS
;	P3=ADDR OF UNIT DATA BLOCK IN ERROR
;RETURN	CPOPJ, P1-P3 INTACT; P4,T1-4 BLOWN

IFN UNITN,<
GDVERR:	PUSHJ	P,ERRINI	;(0-2) HEADER, SETUP P4, CLEAR BUFER
	MOVE	T2,XDVEL	;LIST OF ITEMS TO DUMP
	PUSHJ	P,UNIDMP	;(3-17) DUMP THEM
	MOVEI	T1,UNIBRC(P3)	;BUFFERED READ COUNT
	PUSHJ	P,PEKSPY
	MOVE	T2,T1
	MOVEI	T1,UNIDRC(P3)	;DUMP-MODE READ COUNT
	PUSHJ	P,PEKSPY
	ADD	T2,T1
	MOVEI	T1,UNIMRC(P3)	;MONITOR READ COUNT
	PUSHJ	P,PEKSPY
	ADD	T2,T1		;GET THEM ALL TOGETHER
	PUSH	P4,T2		;(20) TOTAL READS ON THIS UNIT
	MOVEI	T1,UNIBWC(P3)	;BUFFERED WRITE COUNT
	PUSHJ	P,PEKSPY
	MOVE	T2,T1
	MOVEI	T1,UNIDWC(P3)	;DUMP MODE WRITES
	PUSHJ	P,PEKSPY
	ADD	T2,T1
	MOVEI	T1,UNIMWC(P3)	;MONITOR WRITES
	PUSHJ	P,PEKSPY
	ADD	T2,T1
	PUSH	P4,T2		;(21) TOTAL WRITES ON THIS UNIT
	MOVEI	T1,UNIMSC(P3)	;MONITOR SEEK COUNT
	PUSHJ	P,PEKSPY
	MOVE	T2,T1
	MOVEI	T1,UNIUSC(P3)	;USER SEEK COUNT
	PUSHJ	P,PEKSPY
	ADD	T2,T1
	PUSH	P4,T2		;(22) TOTAL SEEKS ON THIS UNIT
	MOVEI	T1,UNINAM(P3)
	PUSHJ	P,PEKSPY	;RE-GET UNIT NAME
	MOVEI	T2,T1		;SET POINTER TO IT
	DSKCHR	T2,		;GET UNIT CHARACTERISTICS
	  PJRST	ERRFIN		;LOOSE...
	PUSH	P4,T2		;(23) DSKCHR INFO FOR THIS UNIT
;	PJRST	ERRFIN		;FALL INTO CLOSE AND RETURN

>;END UNITN COND
;STILL IN FTERR COND
;SUBROUTINE TO APPEND TO ERROR.SYS
;ARGS	P4=LAST ADDR STORED IN ERRBUF
;BLOWS T1-3
;ALWAYS RETURNS CPOPJ

ERRFIN:	INIT	FCT,17		;OPEN A CHANNEL FOR THE PURPOSE
	ERRDEV			;OPEN DESIRED DEVICE
	0
	  JRST	E.IEF		;CAN'T INIT ERROR FILE
	MOVEI	T1,.RBSIZ-.RBCNT	;LENGTH OF DESIRED EXTENDED LOOKUP
	MOVEM	T1,.RBCNT
	MOVE	T1,[ERRPPN]
	MOVEM	T1,.RBPPN	;STORE DIRECTORY
	MOVE	T1,[SIXBIT/ERROR/]
	MOVEM	T1,.RBNAM	;STORE FILNAM
	MOVSI	T1,'SYS'
	MOVEM	T1,.RBEXT	;STORE EXT
	MOVSI	T1,(155B8)	;IF NOT FOUND, MAKE IT READ-ONLY
	MOVEM	T1,.RBPRV
	SETZM	.RBSIZ		;IF LOOKUP FAILS, LEN IS ZERO
	MOVEI	T1,ERRBUF-1	;PREPARE IOWD
	HRRM	T1,ILIST	; FOR INPUT
	HRRM	T1,OLIST	; AND FOR OUTPUT
	MOVEI	T1,-1		;MASK IN RIGHT HALF FOR ERROR CODE
	LOOKUP	FCT,EBLOCK	;DO EXTENDED LOOKUP
	  TDZN	T1,.RBEXT	;IF FILE NOT FOUND, MAKE ONE. ELSE BOMB
	ENTER	FCT,EBLOCK	;DO UPDATE
	  JRST	E.EEF		;WHAT?
	MOVE	T1,.RBSIZ	;GET SIZE IN WORDS
	SOJL	T1,ERFIL0	;DECR FOR LAST WORD
	ROT	T1,-WRDSPB	;COMPUTE LAST BLOCK
	MOVEI	T2,1(T1)	;START AT BLOCK 1
	USETI	FCT,(T2)	;READ LAST BLOCK
	ROT	T1,WRDSPB	;RESTORE WORD COUNT
	ANDI	T1,<1_WRDSPB>-1	;RELATIVE LAST WORD IN BLOCK
	INPUT	FCT,ILIST	;READ THE LAST BLOCK
	STATZ	FCT,740000	;OK?
	  JRST	E.INEF		;OOPS

;STILL IN FTERR CONDITIONAL
;HERE TO CHECK FOR MESS-UPS IN ERROR.SYS

ERCHK:	MOVS	T3,ERRBUF(T1)	;PICK UP LAST WORD
	JUMPE	T3,ERBAK	;IF 0, BACK UP TO FIND GOOD ENTRY
	CAIN	T3,ER.EOF_9	;IS IT EOF?
	JRST	ERFILL		;YES, INSERT NEW ENTRY OVER IT
ERPHIA:	MOVSI	T3,ER.HIA_9	;MARK HIATUS
	MOVEM	T3,ERRBUF(T1)	;IN THE BUFFER
	AOJA	T1,ERFILL	;THEN STORE AT NEXT WORD

ERBAK:	JUMPE	T1,ERPHIA	;STOP BACKING AT BEGINNING OF BUFFER
	SOJ	T1,		;ELSE BACK UP
	MOVS	T3,ERRBUF(T1)
	JUMPE	T3,ERBAK	;BACK UP AGAIN IF STILL 0
	CAIE	T3,ER.EOF_9	;IS THIS EOF ENTRY?
	AOJA	T1,ERPHIA	;NO, DO NOT OVERWRITE IT
	JRST	ERPHIA		;YES, STORE HIATUS MARK OVER IT

ERFIL0:	SETZ	T1,		;T1 IS NO OF WORDS FROM FILE IN BUFFER
	MOVEI	T2,1		;SO USETO WILL WRITE FIRST BLOCK
ERFILL:	SUBI	P4,ERABUF+EL.HED-1	;CALCULATE WORDS STORED
	DPB	P4,[POINT 6,ERABUF,35]	;STORE LENGTH
	ADDI	P4,EL.HED(T1)		;TOTAL WORDS TO WRITE
	MOVEI	T1,ERRBUF(T1)	;TO LOCATION
	HRLI	T1,ERABUF	;FROM
	BLT	T1,ERRBUF-1(P4)	;COPY INTO BUFFER
	MOVSI	T1,ER.EOF_9	;MARK END OF FILE
	MOVEM	T1,ERRBUF(P4)	;AT LAST LOC
	MOVNI	P4,1(P4)
	HRLM	P4,OLIST	;PUT LEN IN
	USETO	FCT,(T2)	;SET TO WRITE LAST BLOCK
	OUTPUT	FCT,OLIST
	STATZ	FCT,740000	;OK?
	  JRST	E.OUEF		;BAD EGGS
ERRXIT:	RELEAS	FCT,		;CLOSE THE CHANNEL AGAIN
	POPJ	P,

E.IEF==ERRXIT	;FOR TIME BEING,
E.EEF==ERRXIT	;AT LEAST,
E.INEF==ERRXIT	;DEFINE THESE
E.OUEF==ERRXIT	;TO EXIT
;SUBROUTINE TO INITIALIZE FOR WRITING IN ERROR.SYS
;ARGS	T1=FIRST (TYPE) WORD OF ENTRY
;VALUES	P4=IOWD ERRSIZ,ERABUF	SUITABLE FOR PUSH-ING
;	HEADER WORD SETUP (EXCEPT LENGTH)
;	DATE & TIME IN WORD 1
;	UPTIME IN WORD 2
;RETURN	CPOPJ, T1-4 BLOWN

ERRINI:	TLO	F,L.ANY		;NOTE SOMETHING DONE
	SETZM	ERABUF		;CLEAR BUFFER
	MOVE	T2,[XWD ERABUF,ERABUF+1]
	BLT	T2,ERABUF+ERRSIZ-1	;CLEAR TO END
	HRRI	T1,<EL.VER>B23+<EL.HED>B29	;FORMAT VERS & HEADER LEN
	MOVEM	T1,ERABUF	;(0) HEADER TYPE IDENTIFIER
	PUSHJ	P,NBSDAT	;GET DATE AND TIME
	MOVEM	T1,ERABUF+1	;(1) DATE (LH) AND TIME (RH)
	MOVE	T1,[XWD %NSUPT,.GTNSW]
	PUSHJ	P,GTBSPY	;GET UPTIME
	  SETZ	T1,		;SNH...
	SETZ	T2,
	ASHC	T1,-17		;JIFFIES*2**18 IN T2
	DIV	T1,JIFDAY	;DAYS IN LH, FRACTION IN RH
	MOVEM	T1,ERABUF+2	;(2) UPTIME IN STD FORMAT
	MOVE	P4,[IOWD ERRSIZ-EL.HED,ERABUF+EL.HED] ;SETUP FOR PUSHING
	POPJ	P,		;SO FAR SO GOOD
;SUBROUTINE TO RETURN DATE AND TIME IN NBS FORMAT,
; DAYS SINCE NOV 17, 1858 IN LH, FRACTION OF DAY IN RH
;USES T1-4
	RADIX	10
DATOFS==38395	;DAYS FROM NOV 17, 1858 TO JAN 1, 1964

NBSDAT:	MOVE	T1,[XWD %CNDAT,.GTCNF]
	PUSHJ	P,GTBSPY	;GET DATE IN INTERNAL (12-BIT) FORMAT
	  POPJ	P,		;SNH...
	IDIVI	T1,12*31	;T1 = YEAR - 1964
	IDIVI	T2,31		;T2 = MONTH - JAN, T3 = DAY OF MON -1
	ADD	T3,MONTAB(T2)	;T3 = DAY OF YEAR -1
	PUSH	P,ZERO		;ASSUME NOT LEAP YEAR
	CAIL	T2,2		;JAN OR FEB?
	AOS	0(P)		;NO, ENABLE ADDING ONE FOR L.Y.
	MOVEI	T4,(T1)		;HOLD  YEAR
	ADDI	T1,3		;OFFSET
	IDIVI	T1,4		;CHECK FOR THIS BEING LEAP YEAR
	CAIE	T2,3		;IS IT?
	SETZM	0(P)		;NO, NO INCREMENT
	ADDI	T3,DATOFS(T1)	;ADD DAYS FROM NOV 17, 1858 TO JAN 1, 1964
				; PLUS LEAP YEARS ALREADY PASSED SINCE 64
	MOVEI	T1,(T4)		;RESTORE YEAR SINCE 64
	IMULI	T1,365		;DAYS SINCE 64 (NOT COUNTING LY'S)
	ADDI	T3,(T1)		;T3 = DAYS SINCE 11/17/1858
				;IGNORING CENTURY GLITCH
	HRREI	T1,1964-2001(T4);CHECK FOR CENTURY CHANGE
	POP	P,T4		;T4 = 1 IF ADD 1 FOR THIS YEAR
	JUMPLE	T1,NOCENT	;JUMP IF NOT YET 2001
	IDIVI	T1,100		;GET CENTURIES SINCE 2001
	SUB	T3,T1		;DECR FOR "LOST" LEAP YEARS
	CAIE	T2,99		;IS THIS A LOST LY?
NOCENT:	ADDI	T3,(T4)		;NO, ADD 1 IF LY AND AFTER FEB
	MSTIME	T1,		;GET TIME OF DAY
	SETZ	T2,
	ASHC	T1,-17		;READY TO MAKE FRACTION OF A DAY
	DIV	T1,[24*60*60*1000]
	HRLI	T1,(T3)		;INSERT DATE WITH IT
	POPJ	P,		;RETURN

ZERO:
MONTAB:	EXP	0,31,59,90,120,151,181,212,243,273,304,334
	RADIX	8
>;END FTERR CONDITIONAL
SUBTTL	ROUTINE TO WRITE CHKPNT INFO INTO FACT FILE

IFN FTCHKPNT,<
CHECK:
IFE FTDET,<
	TLNE	F,L.CHK		;SUPPRESS BIT ON?
	POPJ	P,		;YES, DO NOT CHECKPOINT
>;END FTDET
	JSP	T4,SAVE4	;SAVE THE ACS
	MOVE	P4,FACTSZ	;CURRENT SIZE OF BUFFER CONTENTS
	MOVN	J,HJOB		;HIGHEST JOB # IN SYS
	HRLZS	J
	HRRI	J,1		;START WITH JOB 1 (0 IS NULL)
CHKLUP:	HRROI	T1,.GTSTS	;JOB'S STATUS
	PUSHJ	P,GTBSPY
	  JRST	CHKEND		;NO MORE JOBS
	TLNN	T1,JLOG		;IS THIS JOB LOGGED IN?
	JRST	CHKNXT		;NO, LOOK AT NEXT
	PUSHJ	P,BUFAGE	;ENABLE BUFFER DUMP WHEN IT GETS TOO OLD
	MOVE	T1,[200000,,10]	;FIRST WORD
	MOVEM	T1,FACTBF(P4)	;(0) CONTROL WORD WITH LENGTH
	DPB	J,[POINT 9,FACTBF(P4),17] ;(0) JOB NUMBER
	PUSHJ	P,GETTTY	;GET JOB'S TTY NUMBER
	  MOVNI	T1,2		;DETACHED-MARK SO
	DPB	T1,[POINT 12,FACTBF(P4),29]	;(0) LINE NUMBER

;STILL IN FTCHKPNT CONDITIONAL
;HERE TO FILL IN REST OF ENTRY

	HRROI	T1,.GTPPN	; JBTPPN
	PUSHJ	P,GTBSPY	;GET THE DATA
	  JRST	CHKEND		;END OF TABLE
	MOVEM	T1,FACTBF+1(P4)	;(1) PPN
	PUSHJ	P,FACTIM	;GET TIME AND DATE
	MOVEM	T1,FACTBF+2(P4)	;(2) DATE AND TIME
	HRROI	T1,.GTTIM	;RUNTIME
	PUSHJ	P,GTBSPY	;GO GET IT
	  SETZ	T1,		;MAYBE THERE'S NO SUCH TABLE
	IMULI	T1,^D1000	;AVOID MILJIF FOR PRECISION
	IDIV	T1,JIFSEC	;CONVERT TO MILLISECONDS
	MOVEM	T1,FACTBF+3(P4)	;(3) RUN TIME
	HRROI	T1,.GTKCT	;KILLO-CORE-TICKS
	PUSHJ	P,GTBSPY	;GO READ THEM
	  SETZ	T1,		;NO TABLE, MAYBE?
	MOVEM	T1,FACTBF+4(P4)	;(4) KCT
	HRROI	T1,.GTRCT	;READ COUNT
	PUSHJ	P,GTBSPY	;GET OUT OF MONITOR
	  SETZ	T1,
	TLZ	T1,777700	;CLEAR OUT JUNK BITS
	MOVEM	T1,FACTBF+5(P4)	;(5) DISK READS
	HRROI	T1,.GTWCT	;WRITE COUNT
	PUSHJ	P,GTBSPY	;GET FROM MONITOR
	  SETZ	T1,
	TLZ	T1,777700	;CLEAR INCR. BITS
	MOVEM	T1,FACTBF+6(P4)	;(6) DISK WRITES
	HRROI	T1,.GTPRG	;NAME TABLE
	PUSHJ	P,GTBSPY	;GET BY SPYING
	  SETZ	T1,
	MOVEM	T1,FACTBF+7(P4)	;(7) PROGRAM NAME
	ADDI	P4,10		;UPDATE SIZE TO NOTE 10 WORDS STORED
	CAIGE	P4,MAXFCT	;HAVE WE FILLED THE BUFFER?
	JRST	CHKNXT		;NO, LOOK FOR NEXT JOB
	HRLZI	P1,(P4)		;YES, GET LEN IN P1 LEFT
	HRRI	P1,FACTBF	;AND ADDRESS IN P1 RIGHT
	PUSHJ	P,APPEND	;UPDATE FILE
	SETZ	P4,		;NOTE BUFFER EMPTY
CHKNXT:	AOBJN	J,CHKLUP	;LOOP FOR MORE JOBS
CHKEND:	MOVEM	P4,FACTSZ	;RESTORE SIZE OF FACT THINGS
	MOVE	T1,CCTIM	;SETUP TIME FOR NEXT CHECKPOINT
	MOVEI	J,CHKRQ		;DUMMY JOB NO FOR CHKPNT
	PJRST	CLKREQ		;MAKE THE CLOCK REQUEST AND QUIT

>;END FTCHKPNT CONDITIONAL
SUBTTL FACT FILE UPDATE ROUTINE

IFN CHKFCT,<
;LOCAL ACS
A==T1		;SCRATCH ACS
B==T2
C==T3
D==T4
;SUBROUTINE TO APPEND AN ENTRY TO A FILE IN THE ACCOUNTING SYSTEM.
; THIS ROUTINE FIRST ATTEMPTS TO APPEND TO THE FILE NAMED FACT.SYS, BUT IF THIS FILE
; IS UNAVAILABLE, THEN FILES NAMED FACT.X01, FACT.X02,..., FACT.X77 WILL BE ATTEMPTED
;
;CALLING SEQUENCE:
;		MOVE P1,[XWD SIZE,ADDRESS] ;POINTER TO ENTRY TO BE APPENDED.
;		PUSHJ P,APPEND
;		RETURNS HERE IN ANY EVENT. BLOWING P1 AND P2, T1-4
;		GUARANTEE 200 WORDS FREE ABOVE ENTRY
;
APPEND:	HLRZ	P2,P1		;CONVERT P1 TO
	MOVNI	P2,(P2)		; AN AOBJN POINTER
	HRL	P1,P2		; ..
	PUSH	P,P1		;SAVE P1
	MOVEI	B,(SIXBIT /SYS/)	;TRY FACT.SYS FIRST.
APPLUP:	PUSH	P,B		;SAVE LAST EXTENSION TRIED.
APPLP1:	MOVSS	B		;SET UP ACCUMULATORS FOR THE APPNDF
	MOVE	P1,-1(P)	; SUBROUTINE (WHICH DOES THE ACTUAL APPEND).
	PUSHJ	P,APPNDF	;TRY TO APPEND ENTRY TO TRANSACTION FILE.
	  JRST	APPERR		;ERROR ON THAT TRANSACTION FILE--TRY NEXT.
	 JRST	APPBZY		;TRANSACTION FILE BUSY--TRY ANOTHER.
	POP	P,B		;NORMAL EXIT--FILE SUCCESSFULLY UPDATED.
APPXIT:	POP	P,P1		;RESTORE STACK AND P1

FCTINI:	SETZM	FACTSZ
	POPJ	P,		;*** SUBROUTINE EXIT. ***

APPERR:	POP	P,B		;NON-RECOVERABLE ERROR--TRY NEXT FILE.
	CAIN	B,(SIXBIT /SYS/)	;WAS .SYS THE LAST EXTENSION ATTEMPTED?
	MOVEI	B,(SIXBIT /X00/)	;YES, TRY .X01 NEXT.
APPERB:	CAIN	B,(SIXBIT /X77/)	;NO, TRIED ALL 64 POSSIBLE FILES ?
	JRST	APPXIT		;YES, GIVE UP.
	ADDI	B,1		;NO, TRY NEXT FILE IN SEQUENCE.
	TRNN	B,7		;CARRY INTO SECOND DIGIT ?
	ADDI	B,100-10	;YES, CAUSE SIXBIT CARRY.
	JRST	APPLUP		;TRY AGAIN.

APPBZY:	POP	P,B		;SPECIFIED FILE WAS BUSY--GET ITS EXTENSION.
	CAIE	B,(SIXBIT /SYS/)	;WAS IT .SYS ?
	JRST	APPERB		;NO, GO TRY NEXT FILE IN SEQUENCE.
	PUSH	P,[SIXBIT /   X00/]	;TRY .SYS TWICE JUST TO BE SURE.
	JRST	APPLP1

;STILL IN CHKFCT CONDITIONAL (EITHER FTFACT OR FTCHKPNT)
;SUBROUTINE TO APPEND A TRANSACTION ENTRY TO THE END OF THE ACCOUNTING FILE
; (NORMALLY, THIS IS THE FILE NAMED FACT.SYS, BUT THE EXTENSION IS A PARAMETER
; SUPPLIED TO THIS SUBROUTINE SO THAT IF FACT.SYS BECOMES FOULED UP, AN ENTRY
; MAY BE APPENDED TO AN ALTERNATE FACT.XXX FILE.)

;CALLING SEQUENCE:
;	MOVSI B,(SIXBIT /EXT/)   ;DESIRED EXTENSION FOR FACT FILE (NORMALLY .SYS)
;	MOVE P1,[XWD  -SIZE,ADDRESS]	;POINTER TO ENTRY TO BE APPENDED
;	PUSHJ P,APPNDF
;	NON-RECOVERABLE ERROR RETURN -- CAN'T APPEND TO FILE.
;	BUSY ERROR RETURN -- FILE HAS BEEN BUSY EVERY SECOND FOR TEN SECONDS.
;	NORMAL RETURN -- ENTRY HAS BEEN SUCCESSFULLY APPENDED TO THE FILE.

APPNDF:	MOVE	A,[XWD APPBLK,EBLOCK]
	BLT	A,.RBNAM	;MOVE COUNT,PPN, & NAME INTO EBLOCK
	MOVEM	B,.RBEXT	;SAVE REQUESTED EXTENSION FOR FILENAME FACT
	MOVSI	A,(177B8)	;SETUP PROTECTION
	MOVEM	A,.RBPRV
	SETZM	.RBSIZ		;AND FILE SIZE
	MOVEI	P2,^D10
	MOVEM	P2,TRYCTR	;SET NUMBER OF TIMES TO TRY IF BUSY.
	INIT	FCT,17		;OPEN SOFTWARE I/O CHANNEL FOR FACT FILE
	FCTDEV			; IN DUMP MODE
	0
	  JSP	P2,APPNDR	;IMMEDIATE ERROR RETURN IF CAN'T GET DEVICE SYS.

APPNDL:	LOOKUP	FCT,EBLOCK	;ATTEMPT TO OPEN FACT FILE FOR READING.
	  JRST	APPNDN		;LOOK-UP FAILED--PERHAPS FILE DOESN'T EXIST.
	PUSHJ	P,APPNDE	;ATTEMPT TO GRAB THE FACT FILE.
	SKIPN	P2,.RBSIZ	;FILE SIZE IN WORDS
	JRST	APPNDM		;IF ZERO LEN, NO INPUT
	SOJ	P2,		;POINT TO LAST WORD
	MOVEI	C,200(P2)
	LSH	C,-7		;COMPUTE LAST BLOCK OF FILE
	ANDI	P2,177		;P2 NOW HAS RELATIVE DEPTH (0-127) OF
	USETI	FCT,(C)		; LAST WORD IN LAST BLOCK.
	MOVEI	D,-201(P1)	;ADDR OF AVAILABLE CORE-1
	HRRM	D,ILIST		;SAVE IN IOWDS
	HRRM	D,OLIST
	AOJ	D,		;BUMP FOR BUFFER POINTER
	HRLI	D,P2		;MAKE INDEXABLE
	INPUT	FCT,ILIST	;READ LAST BLOCK OF FACT FILE INTO DUMP BUFFER.
	STATZ	FCT,740000
	  JSP	P2,APPNDR	;ERROR OR EOF WILL YIELD ERROR RETURN.

;STILL IN CHKFCT CONDITIONAL (EITHER FTFACT OR FTCHKPNT)
APPNDA:	MOVS	A,@D		;GET LAST WORD OF CURRENT FACT FILE.
	CAIN	A,777000	;END-OF-FILE ENTRY ?
	JRST	APPNDB		;YES, THINGS ARE LOOKING GOOD.
	SKIPN	A		;NO, FACT FILE SCREWED UP!  IS LAST WORD NON-ZERO ?
	TRNN	P2,-1		;OR IS THIS THE FIRST WORD OF A 200-WORD BLOCK ?
	JSP	P2,APPNDR	;YES TO EITHER QUESTION. TAKE ERROR EXIT.
	SUB	P2,[XWD 1,1]	;TRY BACKING UP OVER ZERO WORDS ATTEMPTING TO FIND
	JRST	APPNDA		; THE END-OF-FILE ENTRY.

APPNDB:	TLNN	P2,-1		;WAS END-OF-FILE ENTRY WHERE IT WAS SUPPOSED TO BE ?
	JRST	APPNDC		;YES, PROCEED.
	MOVE	A,[XWD 377000,1]	;NO, FILL WITH DUMMY ONE-WORD ENTRIES TO
	MOVEM	A,@D		; SHOW WHERE DATA LOSS MAY HAVE OCCURED.
	AOBJN	P2,.-1

APPNDC:	MOVE	A,0(P1)		;PICK UP ENTRY AS SPECIFIED IN CALLING SEQUENCE.
	MOVEM	A,@D		;STORE IN FACT FILE OUTPUT BUFFER.
	AOJ	P2,		;NEXT
	AOBJN	P1,APPNDC
	MOVSI	A,777000	;LAY DOWN END-OF-FILE ENTRY AGAIN.
	MOVEM	A,@D	
	SETCA	P2,0		;(IN PLACE OF AOS P2 FOLLOWED BY MOVNS P2)
	HRLM	P2,OLIST	;STORE CORRECT NUMBER OF WORDS TO BE WRITTEN.
	USETO	FCT,(C)
	OUTPUT	FCT,OLIST	;OUTPUT UPDATED FACT FILE.
	STATZ	FCT,740000
	  JSP	P2,APPNDR	;ERROR OR EOF WILL YIELD ERROR EXIT.
	AOSA	0(P)		;DOUBLE SKIP EXIT
FCTBSY:	AOS	BSYFCT		;COUNT BUSY ERRORS
	AOS	0(P)		;SINGLE SKIP EXIT
APPNER:	RELEASE	FCT,0		;RELEASE FACT FILE'S CHANNEL.
	POPJ	P,		;*** SUBROUTINE EXIT .***

APPNDR:	AOS	FCTGUF		;COUNT ERRORS IN FACT FILE
	HRLM	P2,FCTGUF	;AND SAVE ADDRESS WHERE DETECTED
	JRST	APPNER		;THEN EXIT

;STILL IN CHKFCT CONDITIONAL (EITHER FTFACT OR FTCHKPNT)
APPNDE:	ENTER	FCT,EBLOCK
	  JRST	.+2
	POPJ	P,		;**GOOD EXIT. THE FACT FILE IS OPEN FOR WRITING.**
	POP	P,(P)		;CORRECT THE STACK, SINCE WE WON'T POPJ
	HRRZ	P2,.RBEXT
	CAIE	P2,EE.FBM	;ERROR CODE=3 FROM DSKSER MEANS FILE BEING MODIFIED
	JSP	P2,APPNDR	; BY SOMEONE ELSE. ANY OTHER ERROR CODE LOSES.
	SOSG	TRYCTR		;TRIED OFTEN ENOUGH?
	JRST	FCTBSY		;YES, GIVE UP AFTER 10 TRIES
	MOVEI	P2,1		;WAIT A SECOND
	SLEEP	P2,
	JRST	APPNDL		;NO, TRY AGAIN BEGINNING WITH LOOK-UP. (FILE COULD
	 			; HAVE COME INTO EXISTENCE OR DIED IN THE INTERIM.)

APPNDN:	HRRZ	P2,.RBEXT	;ONLY ERROR CODE 0 IS REASONABLE ON LOOKUP FAILURE.
	JUMPN	P2,APPNDR	;ERROR EXIT ON ANY OTHER LOOKUP FAILURE.
	PUSHJ	P,APPNDE	;FACT FILE DIDN'T EXIST.  TRY TO CREATE IT.
APPNDM:	MOVEI	C,1		;POINT TO BEGIN OF FILE
	MOVEI	D,-201(P1)	;ADDR OF AVAILABLE CORE-1
	HRRM	D,OLIST
	AOJ	D,		;BUMP TO BEGINNING OF BUFFER
	HRLI	D,P2		;INDEX FOR INDIRECT ADDRESSING
	JRST	APPNDC		;GO MOVE TRANSACTION ENTRY INTO FILE AND EXIT.

;SUBROUTINE TO RETURN DATE AND TIME IN FACT-FILE (12/24 BIT) FORMAT
;VALUE	T1=BYTE (12)DATE(24)TIME
;	USES T2

FACTIM:	MOVE	T1,[XWD %CNTIM,.GTCNF]
	PUSHJ	P,GTBSPY	;GET TIME OF DAY IN JIFFIES
	  SETZ	T1,
	MOVE	T2,T1		;HOLD THAT
	MOVE	T1,[XWD %CNDAT,.GTCNF]
	PUSHJ	P,GTBSPY	;GET THE DATE IN 12-BIT FORMAT
	  SETZ	T1,
	ROT	T1,-14		;ROTATE
	IOR	T1,T2		;MUSH TOGETHER
	POPJ	P,		;DONE

;STILL IN CHKFCT COND
SUBTTL	DATA AND STORAGE, BUFFERS, ETC.

TRYCTR:	BLOCK	1	;NUMBER OF TIMES TO TRY IF FACT FILE IS BUSY
APPBLK:	EXP	<.RBSIZ-.RBCNT>		;LEN OF EXT LOOKUP, ENTER
	EXP	FCTPPN		;PPN FOR FACT FILE
	SIXBIT	/FACT/		;NAME

ILIST:	XWD	-200,0		;DUMP MODE INPUT COMMAND LIST 
	0
OLIST:	XWD	-P2,0		;DUMP MODE OUTPUT COMMAND LIST (WORD COUNT WILL
	0 			; BE FILLED IN.)

>;END CHKFCT CONDITIONAL

DLIST:
BPSTRT:	IOWD	200,DAEBUF
	0
UPDLST:	IOWD	200,SECBUF
	0
PDL:	IOWD	PDLEN,PDLIST
PATTERN:	XWD	252525,252525
PJOBN:	POINT	7,T1,6

JBYSUN:	POINT	3,SEGSWP,5
JBYLKS:	POINT	12,SEGSWP,17

QUECOD:	POINT	5,T1,14

COMLST:	SIXBIT	.DCORE.
	SIXBIT	.DUMP.
COMLEN==.-COMLST

JBTCLK:	Z	0(J)
QIKNAM:	ASCIZ	\@SYS:QUIKDM.CCL\

;LITERALS AND VARIABLES

	XLIST
	LIT
	VAR
	LIST
IFN PURESW,<RELOC>

ZER:!
CCLFIL:	BLOCK	1	;SIXBIT JOB NUMBER IN LH FOR CCL FILES
CTYLIN:	BLOCK	1	;LINE NUMBER FOR CTY
CURBLK:	BLOCK	1
CURWRD:	BLOCK	1
C.BH:	BLOCK	3
DAQNAM:	BLOCK	1
D.DEV:	BLOCK	1
D.NAM:	BLOCK	1
	BLOCK	1
D.EXT:	BLOCK	1
D.DIR:	BLOCK	1
	BLOCK	1
D.PROT:	BLOCK	1
D.DPTH:	BLOCK	DPTHLN+1	;LAST WORD SURE TO BE ZERO

EBLOCK:				;BLOCK FOR EXTENDED LOOKUPS AND ENTERS
.RBCNT:	BLOCK	1
.RBPPN:	BLOCK	1
.RBNAM:	BLOCK	1
.RBEXT:	BLOCK	1
.RBPRV:	BLOCK	1
.RBSIZ:	BLOCK	1

GTBST:	BLOCK	1	;BEGINNING OF TABLE OF GETTAB PTRS
HGHOFF:	BLOCK	1	;BEGINNING OF HIGH SEGMENT
HGHREL:	BLOCK	1	;LENGTH OF HIGH SEGMENT
HJOB:	BLOCK	1	;HIGHEST JOB NO IN RH
LINE==HJOB			;LH LINE NO OF DUMP/DCORE COMMAND
INTADR:	BLOCK	1	;ADDR TO RESTART FOR ERROR INTERCEPT
INTBLK:	BLOCK	4	;ERROR INTERCEPT BLOCK
MAXGTB:	BLOCK	1	;HIGHEST LEGAL GETTAB TABLE
MFDPPN:	BLOCK	1
PDLIST:	BLOCK	PDLEN
PTRADR:	BLOCK	1
REMBLK:	BLOCK	1
REMWRD:	BLOCK	1
SAVXWD:	BLOCK	1	;SAVE UUO XWD (FROM EXEC AC T2)
SECBUF:	BLOCK	200
SEGREL:	BLOCK	1
SEGSWP:	BLOCK	1
SWPADR:	BLOCK	1
BLKPAG:	BLOCK	1	;SHIFT COUNT TO CONVERT CHUNKS OF SWAPPING SPACE
			;(PAGES OR K'S) TO NUMBER OF BLOCKS
PKLSH:	BLOCK	1	;LSH T1,1 IF KA; JFCL IF KI
PSRCH:	BLOCK	1	;LEN,,ADDR OF OUR SEARCH LIST
SRCLST:	BLOCK	3*^D9+4	;SPACE FOR OUR SEARCH LIST
USRLST:	BLOCK	3*^D9+4	;SPACE FOR USER SEARCH LIST
THSJOB:	BLOCK	1	;OUR JOB NUMBER
THSLIN:	BLOCK	1	;OUR LINE NUMBER
THSOFF:	BLOCK	1
THSSEG:	BLOCK	1
UPDFLG:	BLOCK	1	;-1 IF MUST DO USETO FOR NORMAL WRITE, 0 IF NOT
USRADR:	BLOCK	1
USRCOR:	BLOCK	MAXUCR+<1_WRDSPB>
USRPPN:	BLOCK	1
WRDCNT:	BLOCK	1	;WORDS FROM LAST PATTERN
.SWPUN:	BLOCK	MAXSWP
.UNSLB:	BLOCK	MAXSWP
IFN FTERR,<
$CPPAR:	BLOCK	CPUN	;TOTAL PARITY ERRORS EACH CPU
$UNIER:	BLOCK	UNITN	;TOTAL I/O ERRORS EACH UNIT
$CHERR:	BLOCK	CHNN	;TOTAL ERRORS EACH CHANNEL
>;END COND ON FTERR
PDBPTR:	BLOCK	1		;ADDRESS OF JBTPDB IN MONITOR FOR SPY
NEXTUP:	BLOCK	1		;NEXT TIME TO CAUSE A WAKE
NEXTJB:	BLOCK	1		;JOB TO WAKE
CCTIM:	BLOCK	1		;CURRENT CHKPNT INTERVAL
CUTIM:	BLOCK	1		;CURRENT UNIT SCAN INTERVAL
QPNTR:	BLOCK	1		;POINTER TO QUEUE
OPRPPN:	BLOCK	1		;PPN OF THE OPERATOR
JIFSEC:	BLOCK	1	;JIFFIES PER SECOND
JIFDAY:	BLOCK	1	;JIFFIES PER DAY
MILJIF:	BLOCK	1	;MILLISECONDS PER JIFFY
SERCNT:	BLOCK	1	;LAST NOTICED COUNT OF SYSTEM HARDWARE ERRORS
DERCNT:	BLOCK	1	;NUMBER OF TIMES DAEMON HAS LOGGED ERRORS
JDPCNT:	BLOCK	1	;NUMBER OF JOBS SEEN STOPPED FOR HDW ERRORS
PDLGUF:	BLOCK	1	;DEBUG - CONTAINS ERRONEOUS P CONTENTS
GTBGUF:	BLOCK	1	;DEBUG - COUNTS MISTAKES IN GTBSPY
ATTGUF:	BLOCK	1	;DEBUG - COUNTS ATTACH FAILURES
FRCGUF:	BLOCK	1	;DEBUG - COUNTS FRCUUO FAILURES
FINGUF:	BLOCK	1	;DEBUG - COUNTS DAEFIN ERROR RETURNS
STRGUF:	BLOCK	1	;DEBUG - COUNTS STRUUO ERROR RETURNS
WAKGUF:	BLOCK	1	;DEBUG - COUNTS ERROR RETURNS FROM WAKE UUO
CLKGUF:	BLOCK	1	;DEBUG - COUNTS CLOCK REQUESTS ON UNASSIGNED CHANNELS
INTGUF:	BLOCK	1	;DEBUG - COUNTS INTERCEPTS
INTRPC:	BLOCK	1	;DEBUG - PC OF INTERCEPT
OUTGUF:	BLOCK	1	;COUNTS TIMES WE WANTED TO OUTSTR BUT WERE DETACHED
SWRGUF:	BLOCK	1	;COUNTS SWAP READ ERRORS
SWWGUF:	BLOCK	1	;COUNTS SWAP WRITE ERORS
WRTGUF:	BLOCK	1	;COUNTS FAILURES IN MARKSPT
FCTGUF:	BLOCK	1	;COUNTS FACT FILE ERRORS
BSYFCT:	BLOCK	1	;COUNTS TIMES FACT FILE BEING MODIFIED TOO LONG
CURJOB:	BLOCK	1	;DEBUG - LAST JOB SERVICED
WTUERR:	BLOCK	1	;FLAG TO PREVENT RECURSIVE CALLS OF WTUCOR WHEN
			;IT GETS IO ERRORS ON THE SWAPPING DEVICE WHILE
			;ATTEMPTING TO WRITE THE EXIT VALUES FOR A UUO.
PATT:	BLOCK	100	;SPACE FOR PATCHES
FACTSZ:	BLOCK	1		;NUMBER OF WORDS IN FACT BUFFER
IFN FTERR,<
ERRBUF:	BLOCK	ERRSIZ+2	;LAST BLOCK OF ERROR.SYS READ HERE
ERABUF=ERRBUF+<1_WRDSPB>+1	;WHERE TO PUT THE NEW STUFF
>;END COND ON FTERR
GOBBUF:
DAEBUF:	BLOCK	<1_WRDSPB>	;BUFFER FOR DUMP IO
IFN CHKFCT,<
FACTBF:	BLOCK	MAXFCT+TRNSIZ+1	;FACT FILE BUFFER
>;END COND ON CHKFCT
EZER==.-1

	END	DAEMON
  . $9