!  CCS FOR THE PDP-10                       CAROLINE DIEHL


!  MACHINE DEPENDENT MACROS

! IF INCREASE TOTAL DGMAX, MUST EXPAND PWR10 TABLE!
DEF I.DGMAX AS 5     !MAX NO. INTEGER & DECIMAL LINE KEY DIGITS (4 BITS
DEF D.DGMAX AS 3     !PER - MUST FIT IN WORD ALONG WITH SIGN BIT)
DEF TKFLDS AS 18,18     !TKCPD FIELD SIZES (CURSOR POS., COUNT)
DEF TKCPMX AS 262143
DEF LBL.DGMAX AS 5   !MAX NO. DIGITS IN FORTRAN LABEL

DEF LWUPDIF AS OCT 40     !LWR CASE CHAR MINUS UPR CASE OF SAME
DEF LESSTR(X,Y) AS (X) SHR 1 < (Y) SHR 1  !STRING COMPARISON
DEF ND.STR AS '[[[[['    !STRING LIT > WD OF ALPHA CHARS
DEF EOLITWD AS 0         !WORD OF EOLITS
DEF TABCH AS OCT 11      !HANDLED IN MACHINE DEPENDENT MANNER
DEF NSPCH(CHAR) AS ($ #CHAR#TABCH)
DEF SPCH(CHAR) AS NOT NSPCH(CHAR)


GLOBAL %CCS, G:, S:, REE:
FIND JOBREN

S:	GO S1
S2:	GO REC     !RECOVER FROM RUN UUO
G:	CLOSE.ALL  !FOR DEBUGGING - RESTART POINT
S1:	JOBREN _ REE; CCS
REE:	EXIT

\\->S


%CCS

! REQUIRES IOCSU FILE

LOCAL %CLRPRG, %OPTK.DIR, %OPTK.SEQ, %OPTK.UPD, %GETSTR
LOCAL %PRMPT, %NXNSP, %BACKSP, %OFFSET
DEF NXCHAR AS NCHV LPTR
LOCAL %OUTKEY, %PRMPTKEY, %PLNKEY
LOCAL %WDSTOR, %WDREC, %CSCAN, %CEXU
LOCAL %ERR, %ABERR, %EXERR, %LNGCHK, %CFNCLS

!  MACHINE/IMPLEMENTATION DEPENDENT I/O DATA

LOCAL FREEPTR                !PTR TO BEGINNING OF FREE BUFFER
LOCAL IMGPTR
DEF NBUFS AS 10                !IOCS ARGUMENT
TABLE F4EXT[OCT 462400.000000]
TABLE TMPEXT[OCT 645560.000000]
LOCAL FIDTBL(0:2*WPF-1)
LOCAL DSVFTB(0:WPF-1)    !DEFAULT SAVE FILE NAME. 1ST WD IS 0 IF NONE
LOCAL CSVFTB(0:WPF-1)    !CURRENT SAVE FILE NAME
LOCAL %SET.DSV
LOCAL RUNSTR(0:40)       !LAST RUN STRING; 1ST WD 0 IF NONE
LOCAL SWIT(0:10)         !PERMANENT SWITCHES

!  CCS STATE DESCRIPTORS (SAVED BETWEEN COMMANDS)

TABLE TKFNAM['CCSSC1.TMP']       !FILE CONTAINING STATEMENT TOKENS
GLOBAL TABLE SCRFNAM [OCT 434363634322]  !SIXBIT CCSSC2 - BOOT TMP FILE
LOCAL TKFN                   !FILE NO. OF SAME
LOCAL TKCPTOP                !CURSOR POSITION AT WHICH TO APPEND
                             !TKFN (MAY HAVE WRITTEN PAST BUT
                             !ESCAPED BEFORE INC'ING THIS)
DEF NLMAX AS 1024            !MAX NO. OF PROGRAM LINES
LOCAL TKCPD(NLMAX)           !DICTIONARY OF CP(TKFN)'S AND TOKEN COUNTS
LOCAL LKEYD(NLMAX)           !DICTIONARY OF LINE KEYS (DEC. DIGITS,
                             !4 BITS PER, CALLED BCD FORM)
LOCAL NLINES                 !NO. OF PROGRAM LINES
LOCAL DOTNUM                 !CURRENT LINE

! USED IN COMMAND PROCESSING (NOT SAVED BETWEEN COMMANDS):

LOCAL SCR(NLMAX)             !SCRATCH ARRAY
LOCAL INFN, OUTFN            !INPUT & OUTPUT FILE NUMBERS
LOCAL LPTR                   !INPUT LINE STRING POINTER
LOCAL CNUM                   !COMMAND NUMBER
LOCAL EL(4), ELID(4), ELP    !COMMAND LINE ELEMENTS, ELEMENT IDS
DEF SELLIM AS GLBSZ
LOCAL SEL(-1:SELLIM)         !SUBELEMENTS (LINE LIST & RANGE)
DEF LTBL(X) AS SEL((X)-2)    !LINE LIST NOS. & COUNTS
LOCAL SELP                   !SEL PTR
LOCAL LNUM

!  PROMPT PARAMETERS

LOCAL PRMNUM                 !PROMPT IDENTIFYING NO.
DEF K.PGR AS 1
DEF K.PAT AS (K.PGR+1)
DEF K.PLK AS (K.PAT+1)
DEF K.PQM AS (K.PLK+1)
DEF PRMCNT AS K.PQM
LOCAL PRMKEY                 !LINE KEY TO PRINT IF PRMNUM=K.PLK

!  COMMAND WORDS

DEF K.CLR  AS 1
DEF K.COMP AS 2
DEF K.COPY AS 3
DEF K.DEL  AS 4
DEF K.EDIT AS 5
DEF K.ENT  AS 6
DEF K.FAST AS 7
DEF K.LIST AS 8
DEF K.MERG AS 9
DEF K.MOD  AS 10
DEF K.MOVE AS 11
DEF K.QUIT AS 12
DEF K.REN  AS 13
DEF K.RUN  AS 14
DEF K.SAVE AS 15
DEF K.SWIT AS 16
DEF K.VER  AS 17

DEF CWDCNT AS K.VER
TABLE CWD(CWDCNT+1)["CLEAR","COMPILE",&
  "COPY","DELETE","EDIT","ENTER","FAST",&
  "LIST","MERGE","MODIFY",&
  "MOVE","QUIT","RENUMBER",&
  "RUN","SAVE","SWITCH","VERSION",ND.STR]

DEF CLMAX AS 8     !COMMAND LENGTH MAX
DEF INWDSZ AS (CLMAX+CPW-1)/CPW
LOCAL INWD(0:INWDSZ-1)       !MUST HOLD CLMAX CHARS

!  COMMAND LINE ELEMENT IDENTIFIERS

DEF FID.ID AS 1              !FILE IDENTIFIER INDEX
DEF LST.ID AS 2              !LINE LIST
DEF ADR.ID AS 3              !LINE ADDRESS
DEF RNG.ID AS 4              !LINE RANGE
DEF LKY.ID AS 5              !LINE KEY
DEF FOR.ID AS 6              !FORTRAN ELEMENT (STMT, LABEL, VAR)
DEF INT.ID AS 7              !POSITIVE INTEGER

!  USED IN LINE KEY AND/OR LINE TEXT OUTPUT:

LOCAL OUTCNT    !ORIGINALLY MAX NO. OF OUTPUT CHARS; DEC'D. SET TO
                !VERY LARGE NO. IF NO LIMIT
LOCAL TABSP     !LIST COMMAND: LINE INDENTATION

!  ERROR MESSAGES TO USER OF CCS

TABLE BDCMND       ['NO SUCH COMMAND']
TABLE LNLONG       ['LINE TOO LONG']
TABLE EDILNG       ['TRUNCATED LINE AVAILABLE FOR EDIT']
TABLE AMBGCM       ['AMBIGUOUS COMMAND, TYPE MORE CHARACTERS']
TABLE BDLRNG       ['ILLEGAL LINE RANGE']
TABLE LSTLNG       ['LINE LIST TOO LONG']
TABLE NODFLT       ['NO DEFAULT NAME']
TABLE NOTIMP       ['BAD I/O SOURCE OR DESTINATION']
TABLE CNTREN       ['CANNOT RENUMBER, CHECK LINE RANGE']
TABLE NOPROG       ['NO PROGRAM']
TABLE BDANS        ['ILLEGAL RESPONSE IN COMMAND FILE']
TABLE DISORD       ['DISORDERLY LINE NUMBER']
TABLE PTROOM       ['NOT ENOUGH ROOM, CANNOT ENTER LINE']
TABLE NOROOM       ['NOT ENOUGH ROOM, COMMAND NOT EXECUTED']
TABLE BDLNFL       ['EDIT REQUIRES LINE NUMBERS, COPY REQUIRES NONE']
TABLE ENDSCR       ['OUT OF SCRATCH AREA, TRY SAVE AND RELOAD']

!FILE OPEN ERRORS
TABLE FILERR(IFDERR:FBSERR) ['ILLEGAL FILE IDENTIFIER', &
 '$NEW/OLD FILE MESSAGE NOT CONFIRMED', &
 'FILE NOT FOUND', 'INVALID USER NAME', &
 'PROTECTION VIOLATION ATTEMPT', 'FILE BUSY']

!  ERROR MESSAGES TO PROGRAMMER OF CCS (HOPEFULLY NOT TO USER)

TABLE BDOPTK       ['CANNOT OPEN TOKEN FILE']
TABLE BDRDTK       ['UNEXPECTED END OF TOKEN FILE']
TABLE NOCORE       ['NOT ENOUGH CORE FOR BUFFER RING']

!  COMMAND MODELS

LOCAL CMDL(CWDCNT)
CMDL(K.ENT) _ '<LINE NUMBER> <STATEMENT>$  OR: <LINE RANGE> <CR> &
<STATEMENTS> <CR>'
CMDL(K.CLR) _ CMDL(K.QUIT) _ CMDL(K.VER) _ ''
CMDL(K.SAVE) _ '[ <FILE> ]'
CMDL(K.MERG) _ '<FILE>'
CMDL(K.EDIT) _ '<LINES OR FILE>'
CMDL(K.MOD) _ '<LINES>'
CMDL(K.DEL) _ '[ <LINES> ]'
CMDL(K.FAST) _ CMDL(K.LIST) _ '[ <LINES> ] [ TO <FILE> ]'
CMDL(K.COPY) _ '<LINES OR FILE> TO <LINE RANGE OR FILE>'
CMDL(K.MOVE) _ '<LINES> TO <LINE RANGE OR FILE>'
CMDL(K.REN) _ '[ <LINE> [ :<LINE> ] ] [ AS <LINE RANGE> ]'
CMDL(K.RUN) _ CMDL(K.COMP) _ '[ <ARGUMENTS> ]'
CMDL(K.SWIT) _ '[ <SWITCHES> ]'

LOCAL PCMDL:                 !PRINTS CMND MDL (IN CSCAN, REF'D BY CEXU)
LOCAL FIXUP                  !LABEL USED IN FIXUP AFTER ALT MODE OR
                             !UNRECOVERABLE ERROR

!  OF GENERAL INTEREST:

DEF UPALPH(X) AS ($A<=X<=$Z)
DEF LWALPH(X) AS ($A+LWUPDIF <= X <= $Z+LWUPDIF)
DEF XLWUP(X) AS X _ X-LWUPDIF   !TRANSFORM X FROM LWR TO UPR CASE
DEF NUM(X) AS ($0<=X<=$9)
LOCAL %ALPH

DEF DGMAX AS (I.DGMAX+D.DGMAX) !MAX. TOTAL LINE KEY DIGITS
TABLE PWR10(0:DGMAX) [1,10,100,1000,10000,100000,1000000,10000000, &
   100000000]
DEF LKY.MAX AS (PWR10(DGMAX)-1)        !MAX. LINE KEY VALUE

DEF SGNBIT AS (1 ROTR 1)
DEF BIGNUM AS BNOT SGNBIT
DEF BPW AS BITS.PER.WORD
DEF BPC AS (BPW/CPW)

DEF YES AS 1
DEF NO  AS 0

LOCAL CHAR, PTR, CNT, TEMP, I


!  CCS INITIALIZATION

LOCAL CFNEOF:, ERRA:, ALT:, NEWCOM:, QUIT:

         IOCS(NBUFS)
         SETRWE(CFN,CFNEOF)
         SETPRMPT(%PRMPT); TAB.OFF(%OFFSET)
         FREEPTR _ CHPT(FREE,-1); IMGPTR _ CHPT(IMAGE,-1)
         TKFN _ TEL    !FOR OPTK.DIR
         PUT(CARRET)
         OFFALT
         ALTLOC _ ALT
CLR:     CLRPRG
         OPTK.DIR

!  ACCEPT A COMMAND LINE
!  NOTE: DO OFFALT BEFORE BRANCH HERE OR TO ANY LABELS FOLLOWING
!  ABOVE OFFALT

NEWCOM:  FIXUP _ NEWCOM
         ONALT.C
         PRMNUM _ K.PGR
         LOOP [GETSTR(CFN); WHILE CHAR _ NXNSP =CARRET]
         BACKSP; IF ALPH(CHAR) THEN [WDSTOR(CLMAX,ERRA); &
           CNUM _ WDREC(CWD,ERRA)] ELSE CNUM _ K.ENT
         CSCAN; CEXU; GO NEWCOM

ERRA:    ERR(BDCMND)


ALT:     OFFALT; CLOBUF; CLIBUF; PUT(CARRET)
         IF CFN#TEL THEN [MSG('$ABORTED$'); CFNCLS]
         GO ^FIXUP


%OPTK.DIR

! CLOSE TKFN (NULL IF TEL) AND REOPEN AS DIR OUTPUT, SEQUEN
! OUTPUT, OR UPDATE.

LOCAL TKERRA:, TKERRB:, TYPE

         TYPE _ OUTPUT+DIRECT+CHARACTER; GO OP1

%%OPTK.SEQ

         TYPE _ OUTPUT+SEQUEN+CHARACTER; GO OP1

%%OPTK.UPD

         TYPE _ UPDATE+DIRECT+CHARACTER
OP1:     CLOSE(TKFN)
         SETRWE(TKFN _ OPEN(TKFNAM,TYPE,TKERRA,2), TKERRB)
         RETURN

TKERRA:  EXERR(BDOPTK)
TKERRB:  EXERR(BDRDTK)

END OPTK.DIR


%CLRPRG

! CLEARS PROGRAM

TKCPTOP _ NLINES _ DOTNUM _ DSVFTB(0) _ CSVFTB(0) _ RUNSTR(0) _ 0
SWIT(0) _ EOLIT; EXTARG(DSVFTB) _ F4EXT; RETURN

END CLRPRG


%GETSTR (FN)

INLA:    RETURN LPTR _ GETLINE(FN)

CFNEOF:  OFFALT; LNGCHK; CFNCLS; FN _ TEL; ONALT.C; GO INLA

%ERR (N)

!  FN IS LAST FILE GETSTR READ FROM.
!  HANDLES RECOVERABLE TEL INPUT ERRORS AND CFN INPUT ERRORS WHICH
!  DO NOT ABORT CFN INPUT IF FN  WAS INFN (EG, LOAD OR COPY).
!  IF FN WAS COMMAND FILE NOT TEL (EG, ENTER) ABORTS CFN INPUT AND
!  OMITS FIXUP.

         ONALT.C
         CLIBUF; MSG(N); PUT(CARRET)
         IF FN=TEL THEN GO INLA
         PRINT(FREE)
         IF FN#CFN THEN GO INLA
         OFFALT; CFNCLS; GO NEW.COM

END ERR


%EXERR (N)

!  HANDLES FATAL ERRORS THAT RESULT IN EXIT.

  OFFALT; FIXUP _ QUIT

%%ABERR (N)

!  HANDLES UNRECOVERABLE ERRORS.  CFN INPUT ABORTED.
!  DOES SAME FIXUP AS ALT MODE.

       ONALT.C
       CLIBUF; MSG(N); PUT(CARRET); IF FN#TEL THEN PRINT(FREE)
       OFFALT; CFNCLS; GO ^FIXUP

END EXERR

END GETSTR


%LNGCHK
IF ERRNUM=LNGERR THEN ERR(LNLONG); RETURN
END LNGCHK


%CFNCLS
CLOSE(CFN <== TEL); RETURN
END CFNCLS


%PRMPT

! PROMPTS AS SPECIFIED BY PRMNUM

         DO PRMNUM OF PRMCNT
K.PGR:     PUT($>)
K.PAT:     PUT($@)
K.PLK:     OUTFN _ TEL; PRMPTKEY(0,0,0)
K.PQM:     PUT($?); PUT($ )
         END
         RETURN

END PRMPT


%OFFSET

LOCAL PTR, OFF, CHAR

OFF _ 0
IF PRMNUM=K.PGR THEN DO
  PTR _ IMGPTR; WHILE SPCH(CHAR_NCHV PTR) THEN INC OFF
  IF CHAR=EOLIT OR NOT($0<=CHAR<=$9 OR CHAR=$.) THEN RETURN 0; INC OFF
  WHILE $0<=CHAR _ NCHV PTR<=$9 OR CHAR=$. THEN INC OFF
  IF CHAR=EOLIT OR SPCH(CHAR) THEN INC OFF
END
RETURN OFF

END OFFSET


%NXNSP

! RETURNS NEXT NON-BLANK

WHILE SPCH(I_NCHV LPTR) THEN NULL; RETURN I

END NXNSP


%BACKSP

PCHV LPTR; RETURN

END BACKSP


%WDSTOR (LMAX, LAB:)

!  NEXT CHAR IS ALPHABETIC.  STORES CHARS UP TO NEXT NON-ALPHA
!  IN INWD ARRAY; LPTR UPON RETURN IS BEFORE WD TERMINATOR.
!  GOES TO LAB IF NO. OF ALPHA CHARS EXCEEDS LMAX.
!  CONVERTS LOWER CASE ALPHA TO UPPER CASE.
!  NOTE: DO NOT CURRENTLY NEED FLEXIBILITY OF HAVING WDSTOR SEPARATE
!  FROM WDREC; IF NEVER DO, MERGE THEM.

       MOVE INWDSZ FROM ALL 0 TO INWD   !NOT EOLITWD!
       PTR _ CHPT(INWD,CNT _ -1)
       WHILE INC CNT<=LMAX THEN DO
         IF NOT UPALPH(CHAR _ NXCHAR) THEN DO
           IF LWALPH(CHAR) THEN XLWUP(CHAR) ELSE [BACKSP; RETURN]
         END
         NCHV PTR _ CHAR
       END
       GO LAB

END WDSTOR


%WDREC (WD(), LAB:)

! WORD RECOGNITION

!  WORD IS AT ADDR INWD, NO. OF CHARS IS IN CNT.
!  IF RECOGNIZES WORD AS WD(I), RETURNS I.
!  ALLOWS SHORTEST UNIQUE ABBREVIATION.
!  GOES TO LAB IF NO MATCH.
!  IF COMMAND LOOKUP (CWD ARRAY), MAY BE AMBIGUITY, IN WHICH CASE
!  ERR EXIT IS TAKEN.

LOCAL %COMPARE
LOCAL W, SAVE

       [W;CNT] _ CNT DIVMOD CPW
       PTR _ 0
       WHILE INWD(0) # ^WD(INC PTR) THEN DO
         IF LESSTR(INWD(0),^WD(PTR)) THEN GO NXT
       END
! INWD(0) <= ^WD(PTR)
NXT:   DO COMPARE OF -1:1
-1:      GO LAB                !<, NO MATCH
1:       INC PTR; GO NXT       !>, ONLY 1ST WD MATCH, CONTINUE
0:       SAVE _ PTR; INC PTR   !=, MATCH
         DO COMPARE OF -1:1    !AMBIGUITY CHECK
 -1: 1:    RETURN SAVE         !<, NO AMBIGUITY
  0:       ERR(AMBGCM)
         END
       END

%COMPARE

! COMPARES INWD TO COMMAND AT WD(PTR), UP TO END OF INWD.
! RETURNS -1, 0 OR 1, IF <, = OR >, RESPECTIVELY.

LOCAL J

       I _ TEMP _ -1
       WHILE INC I<W THEN DO
CA:      J _ ^(WD(PTR)+I) BAND TEMP
         IF INWD(I)#J THEN DO
           RETURN IF LESSTR(INWD(I),J) THEN -1 ELSE 1
         END
       END
       IF TEMP=-1 THEN [TEMP _ TEMP SHL (BPW-BPC*CNT); GO CA]
       RETURN 0

END COMPARE

END WDREC


%CSCAN (CNUM)

!  CCS COMMAND LINE SCANNER

!  STORES COMMAND LINE ELEMENT IDENTIFIERS (IN EL.ID ARRAY) & INFO
!  NEEDED TO ACCESS ELEMENTS (IN EL ARRAY).
!  CNUM (COMMAND NO.) RETURNED IF SCAN SUCCESSFUL, WITH 0'S IN
!  UNUSED EL.ID POSITIONS.

! PREPOSITIONAL WORDS - NO EL.ID/EL ENTRY FOR THESE

DEF K.AS   AS 1
DEF K.TO   AS 2
DEF PWDCNT AS K.TO
TABLE PWD(PWDCNT+1)["AS","TO",ND.STR]
DEF PLMAX AS 2               !MAX LENGTH OF PREP WD

DEF ELW(X,Y) AS [EL(INC ELP)_(Y); EL.ID(ELP)_(X)]

LOCAL %FCR, %FFID, %FPWD
LOCAL %FRNG, %FADR, %FLST
LOCAL EROUT:, CRCHK:
LOCAL FIDP

         MOVE 4 FROM ALL 0 TO ELID+1
         SELP _ ELP _ 0; FIDP _ FIDTBL-WPF

         DO CNUM OF CWDCNT

K.ENT:   IF NOT FRNG THEN GO EROUT
         IF EL.ID(1)=LKY.ID THEN DO
           IF NSPCH(NXCHAR)  THEN BACKSP     !ABSORB BLANK AFTER LINE KEY
           ELW(FOR.ID,LPTR); RETURN CNUM
         END

K.CLR:   K.QUIT:  K.VER:  NULL

K.SAVE:  IF FCR THEN DO
           IF ^DSVFTB=0 THEN ERR(NODFLT)
           WFID(DSVFTB); PUT(CARRET)
           ELW(FID.ID,-DSVFTB); RETURN CNUM
         END
         FFID(EXTARG(DSVFTB))

K.MERG:  FFID(F4EXT)

K.EDIT:  IF NOT FLST THEN FFID(F4EXT)

K.MOD:   IF NOT FLST THEN GO EROUT

K.DEL:   FLST

K.FAST:  K.LIST: &
         FLST; FPWD(K.TO,CRCHK); FFID(0)

K.COPY:  IF NOT FLST THEN FFID(F4EXT)
COP.B:   FPWD(K.TO,PCMDL); IF NOT FRNG THEN FFID(0)

K.MOVE:  IF NOT FLST THEN GO EROUT; GO COP.B

K.REN:   FLST; FPWD(K.AS,CRCHK); IF NOT FRNG THEN GO EROUT

K.RUN:  K.COMP:  K.SWIT:  RETURN CNUM

         END

! CR MUST FOLLOW
CRCHK:   IF NOT FCR THEN GO PCMDL; RETURN CNUM

EROUT:   IF NXNSP#CARRET THEN ERR(BDLRNG)
PCMDL:   MSG("$SHOULD BE:$"); PRINT(CWD(CNUM)); PUT($ )
         ERR(CMDL(CNUM))



%FCR

TEMP _ [NXNSP=CARRET]; BACKSP; RETURN TEMP

END FCR


%FFID (EXTDEF)

!  SCANS FOR FILE IDENTIFIER (FID) TERMINATED BY BLANK OR CR.
!  CALLED WHEN NO ALTERNATIVE TO FID, SO TAKES ERROR EXIT IF FAILS.
!  STORES FID INFO WITH SETFID; IF OK, STORES FID.ID & ARG TO BE 
!  USED IN OPEN CALL.

LOCAL EROUT:

         IF NXNSP=CARRET THEN GO PCMDL
         BACKSP; SETFID(FIDP +_ WPF, @LPTR, EXTDEF, EROUT)
         ELW(FID.ID,-FIDP); RETURN

EROUT:   ABERR(FILERR(IFDERR))

END FFID


%FPWD (K.PWD,LAB:)

!  SCANS FOR PREP. WD SPECIFIED BY K.PWD (INCL. ABBREVIATIONS).
!  IF SUCCESSFUL, RETURNS K.PWD ELSE RESETS LPTR & GOES TO LAB.
!  SPECIAL CASE: IF K.PWD IS EOLIT, RETURNS INDEX TO PREP. WD FOUND;
!  IF WD IS NONE OF THE PREP. WDS, GOES TO LAB.

LOCAL OUT:

         TEMP _ LPTR
         IF NOT ALPH(NXNSP) THEN GO OUT
         BACKSP; WDSTOR(PLMAX,OUT)
         IF I _ WDREC(PWD,OUT)=KPWD OR KPWD=0 THEN RETURN I
OUT:     LPTR _ TEMP; GO LAB

END FPWD


%FRNG

!  SCANS FOR CONSTRUCTION SPECIFIED AT ENTRY POINT.
!
!  RNG      LKEY:LKEY  OR  LKEY(LKEY)LKEY  OR  LKEY(LKEY)  OR  LKEY
!           (LKEY FORM IS 0 TO I.DGMAX DIGITS, OPTIONAL 0 TO D.DGMAX
!           DECIMAL DIGITS WITH >0 DIGITS IN ALL)
!  ADR      LKEY  OR  $  OR  .  OR  *INT  OR  ADR+INT  OR  ADR-INT
!  LST      ADR[:ADR],...,ADR[:ADR]
!
!  IF SUCCESSFUL, STORES APPROPRIATE EL.ID AND, IN EL ARRAY,
!     ADR OF WD BEFORE 1ST WD OF SUBELEMENT LIST
!                    (SEE %FRL)
!
!  RETURNS 1, WITH LPTR BEFORE CONSTRUCTION TERMINATOR.
!  IF NOT SUCCESSFUL, RESETS LPTR AND RETURNS 0.
!
!  LOW-ORDER BITS OF LFGS REPRESENT STATES AS FOLLOWS:
!
!            RNG     ADR
!    LST      :       (
!  + OR -     $       )
!     *     DIGIT     .
!
!  THUS:

DEF DOTB  AS 1
DEF DGTB  AS (1 SHL 1)
DEF ASTB  AS (1 SHL 2)
DEF RGTB  AS (1 SHL 3)
DEF DLRB  AS (1 SHL 4)
DEF SGNB  AS (1 SHL 5)
DEF LFTB  AS (1 SHL 6)
DEF CLNB  AS (1 SHL 7)
DEF LSTB  AS (1 SHL 8)
DEF ADRB  AS (1 SHL 9)
DEF RNGB  AS (1 SHL 10)

LOCAL %FRL
LOCAL LFGS

         LFGS _ RNGB; I _ FRL
         ELW(IF CNUM=K.ENT AND LFGS BAND (CLNB+RGTB)=0 THEN LKY.ID &
           ELSE RNG.ID, I)
         RETURN YES


%%FADR

         LFGS _ ADRB; ELW(ADR.ID,FRL); RETURN YES


%%FLST

         LFGS _ LSTB
         ELW(LST.ID,FRL); RETURN YES


LAB:    RETURN NO


%FRL

!    TERMINATES ON ANY SYMBOL NOT : ( + - $ ) * DIGIT .
!    STORES SUBELEMENTS IN SEL ARRAY (1 PER WD) & RETURNS ADR OF
!    WD BEFORE 1ST WD OF LIST.  SUBELEMENTS INCLUDE ANY SPECIAL
!    SYMBOL & (NEGATIVE OF) ANY NUMBER READ (LKEY STORED AS INTEGER).
!    LIST TERMINATED BY 0.

LOCAL %SVNUM, %SELW
LOCAL LVAL

! EXTRACTION OF TYPE BIT:
DEF TYPB AS (LFGS BAND (RNGB+ADRB+LSTB))

! CHECK FOR ILLEGAL STATES:
DEF NG(X) AS IF LFGS BAND (X) THEN GO OUT

DEF PARENS AS (LFTB+RGTB)

         TEMP _ LPTR
         IF CHAR_NXNSP=CARRET THEN GO OUT
         PTR _ @SEL(SELP)
         CNT _ I.DGMAX; LVAL _ 0    !LVAL RESET IN SVNUM

       LOOP DO
         EIF NUM(CHAR) THEN DO
           NG(DLRB)
           LVAL _ LVAL*10+CHAR-$0
! DON'T DEC CNT IF LEADING INTEGER ZERO
           IF NOT(LVAL=0=LFGS BAND DOTB) THEN IF DEC CNT<0 THEN GO OUT
           LFGS BOR_ DGTB
         END

         ORIF CHAR=$. THEN DO
           NG(SGNB+DLRB+ASTB+DOTB)
           LFGS BOR_ DOTB
           CNT _ D.DGMAX
         END

         ELSE DO
           EIF CHAR=$: THEN DO
             NG(ADRB+CLNB+PARENS)
             SVNUM; LFGS _ TYPB BOR CLNB
           END

           ORIF CHAR=$( THEN DO
             NG(ADRB+LSTB+CLNB+PARENS)
             SVNUM; LFGS _ TYPB BOR LFTB
           END

           ORIF CHAR=$) THEN DO
             IF LFGS BAND PARENS#LFTB THEN GO OUT
             SVNUM; LFGS _ TYPB BOR RGTB
           END

           ORIF CHAR=$+ OR CHAR=$- THEN DO
             NG(RNGB+SGNB)
             SVNUM; LFGS _ TYPB BOR (LFGS BAND CLNB) BOR SGNB
      END

           ORIF CHAR=$$ OR CHAR=$* THEN DO
             NG(BNOT(ADRB+LSTB+CLNB))
             LFGS BOR_ IF CHAR=$$ THEN DLRB ELSE ASTB
           END

           ORIF CHAR=$, THEN DO
             NG(RNGB+ADRB) 
             SVNUM; LFGS _ TYPB
           END

           ELSE GO ENDCH

           SELW(CHAR); CNT _ I.DGMAX

         END

         CHAR _ NXCHAR
       END

ENDCH:   IF LFGS BAND PARENS=LFTB THEN GO OUT
         SVNUM; SELW(0); BACKSP; RETURN PTR

OUT:     LPTR _ TEMP; GO LAB


%SELW (X)

!  SUBELEMENT WRITE WITH OVERFLOW CHECK

IF INC SELP>SELLIM THEN ERR(LSTLNG)
SEL(SELP) _ X; RETURN

END SELW


%SVNUM

!  CALLED AT : ( ) + - , (BEFORE SETTING STATE BIT) AND AT
!  TERMINATOR, TO STORE NEGATIVE OF LKEY/INTEGER PRECEDING, IF ANY.  
!  %FRL ACCUMULATED NUMBER IN LVAL, WITH LKEY DOT IGNORED
!  AND NO. OF DIGITS PAST DOT = 3-CNT.
!  MAY BE $ OR CURRENT LINE DOT OR NO LKEY AFTER );  IN ANY OTHER
!  CASE, ABSENCE OF DIGIT IS ILLEGAL.
!  0 ILLEGAL EXCEPT AFTER SIGN.

         IF LFGS BAND DLRB THEN RETURN  !PREVIOUSLY DISALLOWED $DIGIT
         IF LFGS BAND DGTB=0 THEN DO
           IF LFGS BAND RGTB THEN RETURN
           IF LFGS BAND DOTB AND TYPB#RNGB THEN [SELW($.); RETURN]
           GO OUT
         END
         IF LVAL=0 AND LFGS BAND SGNB=0 THEN GO OUT
         SELW ((LVAL<==0) * (IF LFGS BAND (SGNB+ASTB) THEN 1 ELSE &
           IF LFGS BAND DOTB THEN PWR10(CNT) ELSE PWR10(DDGMAX))*-1)
         RETURN

END SVNUM

END FRL

END FRNG

END CSCAN


%CEXU

!  EXECUTES COMMAND CNUM.
!  WHEN FALL THRU TO END OF CASE STATEMENT, ALT MODE MUST BE OFF
!  (BECAUSE OF SUBSEQUENT BRANCH TO NEWCOM:).
!  FIXUP LOCATION SHOULD NOT INCLUDE OFFALT (WILL BE OFF WHEN 
!  GO ^FIXUP).

LOCAL %PRGCHK, %OKAY, %PKTK, %UNPKTK
LOCAL %INRANG, %INLIST, %INTXL
LOCAL %MRGINP, %MOV.CPTOP, %SET.INCR, %I.NXLNUM, %NXLNUM
LOCAL %MKDL, %DELMKD, %UNMKDL
LOCAL %LIST.PAR, %XLKLN, %BCD, %INTKEY
LOCAL %ANS

LOCAL LOKEY      !1ST KEY OF RANGE
LOCAL HIKEY      !LAST ALLOWABLE KEY
LOCAL INCR       !RANGE INCREMENT 
LOCAL LONUM      !1ST DICT. POSITION TO BE AFFECTED BY NEW RANGE
LOCAL HINUM      !POSITION OF 1ST LINE BEYOND AFFECTED RANGE IN PROG.
LOCAL TXINCT     !TEXT INPUT COUNT (NO. LINES ENTERED)
LOCAL MXINCT     !MAXIMUM TEXT INPUT COUNT

LOCAL LSTCNT     !NO. LINES SPECIFIED IN LINE LIST
DEF RNGMX AS 10  !MAX NO. OF SUBRANGES IN LINE LIST

LOCAL TKCP
LOCAL I, J, WD(), TEMP
LOCAL OPNERR:, LNERRA:, LNERRB:, HERE:, LOAD.B:, COP.B:
LOCAL COP.C:, LOADFX:, COPFX:, ENTFX:, MERGN:
LOCAL %SET.INFN


         DO CNUM OF CWDCNT


K.ENT:   INRANG(1)
         FIXUP _ ENTFX     !== FIXUP TO NEWCOM UNTIL LINE HAS BEEN ENTERED
         EIF EL.ID(1)=LKY.ID THEN INTXL    !LPTR IS OK

         ORIF INCR<0 THEN DO   !NO INCREMENT - AT SIGN PROMPT
           PRMNUM _ K.PAT
           LOOP DO
             GETSTR(CFN); WHILE NXCHAR#CARRET; BACKSP; INTXL
           END
         END
  
         ELSE DO    !INCREMENT - LINE KEY PROMPT
           PRMNUM _ K.PLK; TEMP _ LOKEY
ENT.B:     PRMKEY _ BCD(TEMP); GETSTR(CFN)
           IF NXCHAR#CARRET THEN DO
             BACKSP; INTXL
             IF TEMP +_ INCR <= HIKEY THEN GO ENT.B
           END
         END

         OFFALT
ENTFX:   DOTNUM _ MRGINP


K.EDIT:  IF EL.ID(1)=LST.ID THEN GO MOD.A
         OFFALT
         SETRWE(SET.INFN,LOAD.B)
         OPTK.SEQ
         CLRPRG; FIXUP _ LOADFX
         ONALT
         TXINCT _ TKCP _ LOKEY _ 0
!  FOR MAXIMUM SPEED, LOAD CODE ELIMINATES PROCEDURE CALLS WHEREVER
!  REASONABLE.
         LOOP DO     !EXIT AT END OF FILE
           GETSTR(INFN)
           IF NXNSP#CARRET THEN DO
             PCHV LPTR; TEMP _ I _ 0; CNT _ I.DGMAX
             LOOP DO
               EIF NUM(CHAR _ NXCHAR) THEN DO
                 TEMP _ (TEMP SHL 4) BOR (CHAR-$0)
! DON'T DEC COUNT IF LEADING INTEGER ZER0
                 IF NOT(TEMP=I=0) THEN IF DEC CNT<0 THEN ERR(BDLRNG)
               END
               ORIF CHAR=$. THEN IF I=0 THEN CNT _ I _ D.DGMAX &
                 ELSE ERR(DISORD)
               ELSE GO ENDCH
             END
!            I=0 IF NO DECIMAL PART
ENDCH:       IF TEMP _ TEMP SHL (4*IF I THEN CNT ELSE D.DGMAX) <= LOKEY &
               THEN IF LOKEY=0 THEN ABERR(BDLNFL) ELSE ERR(DISORD)
             IF INC TXINCT>NLMAX THEN ABERR(NOROOM)
             IF NSPCH(CHAR)  THEN PCHV LPTR
             TKCPD(TXINCT) _ PKTK
             LKEYD(TXINCT) _ LOKEY _ TEMP
           END
         END

LOADFX:  OPTK.DIR; GO LOAD.C
LOAD.B:  LNGCHK; OFFALT; FIDP _ -EL(1)
         MOVE WPF FROM FIDP TO CSVFTB
         SET.DSV
         DOTNUM _ NLINES _ TXINCT; TKCPTOP _ TKCP; OPTK.UPD
LOAD.C:  CLOSE(INFN)


K.MERG:	OFFALT     !SINGLE LINE ENTER FROM FILE
	SETRWE(SET.INFN,MERGN); FIXUP _ LOAD.C; ONALT
	LOOP DO
	  GETSTR(INFN)
	  IF NXNSP#CARRET THEN DO
	    BACKSP; CNUM _ K.ENT; CSCAN
	    INRANG(1); IF EL.ID(1)#LKY.ID THEN ERR(BDLRNG)
	    INTXL; OFFALT; DOTNUM _ MRGINP; ONALT
	  END
	END

MERGN:	LNGCHK; OFFALT; GO LOAD.C


! VERSION, SWITCH, COMPILE & RUN CODE IS MACHINE DEPENDENT

FIND %BOOT, %BOOTW, JOBFF, JOBVER
LOCAL %SAVE, %UNSIX, %OPNTMP, SXPTR, CHAR, PTR
LOCAL TMPBUF(40), RPTR, RCNT, BLK(0:5), DONE:
LOCAL SVJOBFF, JOBNO
DEF WCH(CHAR) AS [NCHV RPTR _ (CHAR); INC RCNT]
TABLE JNKSFNM [OCT 707063]    !SIXBIT XXS
TABLE JNKRFNM [OCT 707062]    !SIXBIT XXR
TABLE RPGFNAM [OCT 636643]    !SIXBIT SVC

K.VER:	PTR _ 18; WHILE TEMP_BYT(JOBVER,3,PTR-_3)=0 THEN NULL
	LOOP DO
	  PUT(TEMP+$0); WHILE PTR-_3>=0; TEMP_BYT(JOBVER,3,PTR)
	END
	PUT(CARRET)

K.SWIT:	PTR _ CHPT(SWIT,-1)
	WHILE NCHV PTR _ NXCHAR #CARRET THEN NULL
	CHV PTR _ EOLIT

K.COMP:	TMPBUF(2) _ ^'/ZF  '; GO R1

K.RUN:	TMPBUF(2) _ ^'%3Y  '
R1:	TMPBUF(1) _ ^'FDEB '
	RPTR _ CHPT(TMPBUF+3,-1); RCNT _ 10
	!SAVE JOB NUMBER FOR TMP FILE NAMES
	EXU(OCT 47, 14, OCT 30); TEMP _ ^14; I _ 100
	SXPTR _ [6,6,24]*[36,6,@JOBNO]
	REPEAT 3 DO
	  [J;TEMP] _ TEMP DIVMOD I <== I/10
	  NCHV SXPTR _ J+OCT 20
	END
	!GET PERMANENT SWITCHES
	PTR _ CHPT(SWIT,-1)
	WHILE CHAR _ NCHV PTR #EOLIT THEN WCH(CHAR); WCH($ )
	!GET TEMPORARY SWITCHES
	LOOP DO
	  WHILE CHAR _ NXNSP = $/ OR CHAR = $%
	  LOOP [WCH(CHAR<==NXCHAR); WHILE $ #CHAR#$, AND CHAR#CARRET]
	  WCH($ ); WHILE CHAR#CARRET
	END
	BACKSP
	PTR _ CHPT(RUNSTR,-1)
	EIF CHAR#CARRET THEN DO     !SAVE DEFAULT STRING
	  TEMP _ LPTR; WHILE NCHV  PTR _ NCHV TEMP #EOLIT THEN NULL
	END
	ORIF ^RUNSTR#0 THEN LPTR _ PTR
	ELSE GO RUN1
	
	  WHILE CHAR _ NXCHAR #EOLIT THEN DO
	    IF CHAR=$$ THEN GO RUN1; WCH(CHAR)
	  END
	GO AROUND
RUN1:	  PRGCHK
	  TEMP _ LPTR; WHILE SPCH(CHAR _ PCHV TEMP) THEN NULL
	  IF ^CSVFTB=0 THEN [OPNTMP(JNKSFNM); SAVE]
	  IF CHAR#$= THEN DO    !ADD REL FILE NAME
	    IF ^DSVFTB#0 THEN DO
	      UNSIX(NAMARG(DSVFTB))
	    END ELSE DO
	      UNSIX(JOBNO+JNKRFNM); WCH($.); UNSIX(TMPEXT)
	    END
	    WCH($=)
	  END
	  UNSIX(NAMARG(CSVFTB)); WCH($.)
	  HW(@EXTARG(CSVFTB),1) _ 0; UNSIX(EXTARG(CSVFTB))
	  !WRITE PPN - DON'T USE PCHV WITH SXPTR!
	  SXPTR _ [6,6,24] * [36,3,@PPNARG(CSVFTB)]; WCH($[)
	  I _ 5; WHILE NCHV SXPTR=0 THEN DEC I; WCH($0+CHV SXPTR)
	  REPEAT I WCH(NCHV SXPTR+$0); WCH($,)
	  I _ 5; WHILE NCHV SXPTR=0 THEN DEC I; WCH($0+CHV SXPTR)
	  REPEAT I WCH(NCHV SXPTR+$0); WCH($])
	  WHILE CHAR _ NCHV LPTR #EOLIT THEN WCH(CHAR)
AROUND:		[J;TEMP] _ (RCNT+4) DIVMOD 5
	REPEAT 4-TEMP NCHV RPTR _ EOLIT   !;PRINT(TMPBUF+1)
	HW(BLK) _ RPGFNAM
	BLK(1) _ TMPBUF; HW(@BLK(1)) _ -J
	^14 _ [18,18] * [3,BLK]
	EXU(OCT 47, 14, OCT 44, DONE)    !TMPCOR UUO
	!NO TMPCOR. MUST USE TMP.
	OPNTMP(RPGFNAM)
	PTR _ CHPT(TMPBUF,4); REPEAT RCNT W(OUTFN,NCHV PTR)
DONE:	CLOSE.ALL
	SVJOBFF _ JOBFF
	BOOTW
	BLK(0) _ OCT 637163.000000 !SIXBIT SYS
	BLK(1) _ OCT 626047.000000 !SIXBIT RPG
	MOVE 4 FROM ALL 0 TO BLK+2
	^14 _ [18,18] * [1,BLK]
	EXU(OCT 47,14,OCT 35)    !RUN UUO
	!HERE IF RUN ERROR.  NO OVERLAY DONE YET, SO CONTINUE.


K.SAVE:	PRGCHK; OFFALT
	IF OUTFN _ OPEN(EL(1),OUTMSG+SEQUEN+CHARACTER,OPNERR,2) &
	    = TEL THEN ERR(NOTIMP)
	OKAY
	IF ^CSVFTB=0 OR EXTARG(CSVFTB) BAND OCT 777777.000000#TMPEXT THEN SAVE ELSE DO
	  !CURRENT SAVE FILE IS A TMP FILE, SO RENAME
	  CLOSE(OUTFN); DELETE(EL(1)); RENAME(-CSVFTB,EL(1),OPNERR)
	  MOVE WPF FROM FIDP TO CSVFTB  !CHANGE TO NEW NAME
	END
	SET.DSV


K.FAST: K.LIST: &
         IF EL.ID(1)=FID.ID THEN DO
           ELID(1) <=> ELID(2)      !MOVE FID INFO; ZERO LIST ID
           EL(2) _ EL(1)            !FOR %INLIST
         END
         GO FAST


K.COPY: K.MOVE: &
         EIF EL.ID(1)=LST.ID THEN DO
FAST:      INLIST(1)
           EIF EL.ID(2)#RNG.ID THEN DO    !LINE LIST TO FILE OR TEL
             OFFALT
             IF OUTFN _ IF ELID(2)=0 THEN TEL ELSE &
              OPEN(EL(2),OUTMSG+SEQUEN+CHARACTER,OPNERR,2)#TEL THEN OKAY
             FIXUP _ COPFX
             ONALT
             [I;J] _ DOUBLE LIST.PAR
             REPEAT LSTCNT DO
               NXLNUM
               OUTCNT _ IF CNUM=K.LIST THEN BIGNUM ELSE LLEN
               DO CNUM OF K.COPY:K.MOVE
  K.MOVE:        MKDL(LNUM)
  K.COPY:        NULL
  K.LIST:        OUTKEY(0,I,J)
  K.FAST:        IF OUTFN#TEL THEN PLNKEY ELSE OUTKEY(0,0,0)
               END
               UNPKTK(0,LNERRA)
             END
             OFFALT
             CLOSE(OUTFN); IF CNUM=K.MOVE THEN GO DELA
             IF OUTFN=TEL THEN [DOTNUM _ LNUM; IF CNUM=K.LIST THEN PUT(CARRET)]
           END


           ELSE DO           !LINE LIST TO RANGE
             INRANG(2)
             OFFALT
             REPEAT LSTCNT DO
               NXLNUM
               IF CNUM=K.MOVE THEN DO
                 IF NOT(LONUM<=LNUM<HINUM) AND LKEYD(LNUM)>0 THEN DO
                 !IF OUTSIDE RANGE AND NOT ALREADY MARKED FOR DELETION:
                   INC MXINCT; MKDL(LNUM)
                 END
               END
               IF TXINCT=MXINCT THEN ABERR(NOROOM)
               SCR(INC TXINCT) _ TKCPD(LNUM)
             END
             IF CNUM=K.MOVE THEN DO     !SET UP FOR MRGINP
               LONUM _ DELMKD(1,LONUM-1)+1
               NLINES _ DELMKD(HINUM,NLINES)
             END
             DOTNUM _ MRGINP
           END
         END


         ELSE DO
           OFFALT
           SETRWE(SET.INFN,COP.B); IF PLNCHK(INFN) THEN ABERR(BDLNFL)
!* NOTE: IF ADD FILE-TO-FILE, MUST MOVE FOLLOWING ASSIGNMENT
           FIXUP _ COP.C
           ONALT
           EIF EL.ID(2)=RNG.ID THEN DO       !FILE TO RANGE
             INRANG(2)
!* NOTE: NOROOM ERR IF INCR>=0 AND LINE KEY>HIKEY (MXINCT EXCEEDED)
             LOOP [GETSTR(INFN); INTXL]
COP.B:       LNGCHK; OFFALT
             DOTNUM _ MRGINP
COP.C:       CLOSE(INFN)
           END


           ELSE DO       !FILE TO FILE
             ERR(NOTIMP)
           END
         END


K.MOD: &
MOD.A:   INLIST(1); OUTFN _ TEL; PRMNUM _ K.PLK
         TKCP _ TKCPTOP     !FOR PKTK
         REPEAT LSTCNT DO
           PRMKEY _ LKEYD(NXLNUM)
           OUTCNT _ LLEN; UNPKTK(CHPT(IMAGE,-1),LNERRB)
EDIT.A:    IF CNUM=K.EDIT THEN [OUTKEY(0,0,0); PRINTC(IMAGE)]
           GETSTR(TEL)
           IF NXCHAR#CARRET THEN DO
             BACKSP
             OFFALT
             SETCP(TKFN,TKCPTOP)
             TKCPD(DOTNUM _ LNUM) _ PKTK; MOV.CPTOP
             ONALT
           END
         END
         OFFALT


K.DEL: K.CLR: &
         IF EL.ID(1)=0 THEN DO     !CLEAR
           IF ANS('ALL')=YES THEN DO
             OFFALT;  GO CLR
           END ELSE OFFALT

         END ELSE DO     !DELETE SPECIFIED LINES
           INLIST(1)
           OFFALT
           REPEAT LSTCNT MKDL(NXLNUM)
DELA:      NLINES _ DELMKD(1,NLINES)
         END


K.REN: &
! WILL NOT MOVE OR DELETE LINES! &
         IF ELID(1)=RNG.ID THEN DO
           ELID(1) <=> ELID(2)     !MOVE RANGE INFO, ZERO LIST ID
           EL(2) _ EL(1)           !FOR %INLIST
         END
         IF INLIST(1)>1 THEN GO PCMDL  !PCMDL IS IN %CSCAN
         IF ELID(1)#0=ELID(2) THEN DO
           !REN ADR1:ADR2 - ASSUME AS KEY(ADR1):KEY(ADR2)
           !MXINCT CHECK NOT NEEDED
           INCR _ -1
           LOKEY _ INTKEY(LONUM _ LTBL(1))
           HIKEY _ INTKEY((HINUM _ LTBL(1)+LSTCNT)-1)
         END ELSE [INRANG(2); IF LSTCNT>MXINCT THEN ERR(CNTREN)]
         IF NOT(LONUM>= LNUM _ LTBL(1) >=HINUM-LSTCNT) THEN ERR(CNTREN) 
         TXINCT _ LSTCNT; SET.INCR; DEC LNUM
         OFFALT
         REPEAT LSTCNT LKEYD(INC LNUM) _ BCD(LOKEY <== LOKEY+INCR)
         ^CSVFTB _ 0


K.QUIT:  OFFALT; GO QUIT
QUIT:    CLOSE.ALL; ONALT; EXIT


         END
         RETURN


OPNERR:  IF ERRNUM=CORERR THEN EXERR(NOCORE)
         IF ERRNUM>FNFERR THEN DO
           PRINT('CANNOT OPEN '); WFID(FIDP); PUT(CARRET)
         END
         ABERR(FILERR(ERRNUM))

LNERRA:  OFFALT; DOTNUM _ LNUM; ONALT   !ERROR LINE = DOT
         IF OUTFN#TEL THEN UNPKTK(IF K.COPY#CNUM#K.MOVE THEN &
           OUTKEY(FREEPTR,I,J) ELSE FREEPTR, HERE)
HERE:    ABERR(LNLONG)

COPFX:  IF OUTFN#TEL THEN [CLOSE(OUTFN); DELETE(-FIDP)]
         IF CNUM=K.MOVE THEN UNMKDL
         GO NEWCOM

LNERRB:  MSG(LNLONG); MSG(EDILNG); GO EDIT.A

! RECOVER FROM RUN
REC:	BOOT; OFFALT; JOBFF _ SVJOBFF; TKFN _ TEL; OPTK.UPD; SETCP(TKFN,TKCPTOP)
	PUT(CARRET); GO NEWCOM


%SAVE
	FIXUP _ COPFX
	ONALT
	FOR LNUM _ 1 TO NLINES DO
	  OUTCNT _ LLEN; PLNKEY; UNPKTK(0,LNERRA)
	END
	OFFALT
	CLOSE(OUTFN); MOVE WPF FROM FIDP TO CSVFTB
	RETURN
END SAVE


%UNSIX (WD)

	SXPTR _ [6,6,24]*[36,6,@WD]
	REPEAT 6 DO
	  IF CHAR _ NCHV SXPTR=0 THEN RETURN
	  WCH(CHAR+OCT 40)
	END
	RETURN

END UNSIX


%OPNTMP (FNAM)

	      !CREATE ARGUMENT BLOCK AT FIDTBL USING JOB NO. + FNAM.TMP.
	      !OPEN AS OUTFN.
	      MOVE WPF FROM ALL 0 TO FIDTBL
	      ^FIDTBL _ 5     !ARGUMENT COUNT
	      NAMARG(FIDTBL) _ JOBNO+FNAM
	      EXTARG(FIDTBL) _ TMPEXT
	      OUTFN _ OPEN(-FIDTBL,OUTPUT+SEQUEN+CHARACTER,OPNERR,2)
	      RETURN
	      RETURN
END OPNTMP


%SET.DSV

!SET DEFAULT SAVE INFO FROM FIDP TABLE, CLEARING NEC. ARGS
         MOVE WPF FROM FIDP TO DSVFTB
         PPNARG(DSVFTB) _ PRVARG(DSVFTB) _ HW(@EXTARG(DSVFTB),1) _ 0
         RETURN
END SET.DSV


%SET.INFN
LOCAL INERR:

	LOOP DO
         IF INFN _ OPEN(EL(1),INPUT+SEQUEN+CHARACTER,INERR,2) &
 	  =TEL THEN ERR(NOTIMP); OKAY; RETURN INFN
INERR:   IF ERRNUM#FNFERR OR EXTQ(FIDP)=YES THEN GO OPNERR
         EXTQ(FIDP) _ YES; EXTARG(FIDP) _ 0
	END

END SET.INFN


%PRGCHK
IF NLINES=0 THEN ERR(NOPROG); RETURN
END PRGCHK

%OKAY
IF CFN=TEL THEN MSG("OK$"); RETURN
END OKAY


%INRANG (I)

!  I IS INDEX INTO EL.ID & EL ARRAYS FOR LINE RANGE INFO. EL(I) IS
!  ADDRESS OF WD BEFORE 1ST WD OF SUBELEMENT LIST,
!  UNLESS EL.ID(I) IS 0, TO INDICATE DEFAULT RANGE OF 1(1) (RENUMBER).
!  ALSO SPECIAL RENUMBER CASE: IF UPPER LIMIT OMITTED, IS LAST LINE
!  IN LIST TO BE RENUMBERED.
!  CALCULATES AND STORES RANGE PARAMETERS: LOKEY, HIKEY, INCR (-1
!  IF NONE), LONUM, HINUM, MXINCT.
!  INITS TXINCT & CURSOR FOR %INTXL
!  NOTE: NEGATIVE INTEGER REPRESENTS LINE KEY.

LOCAL CONT:, NXT:, NXT1:

         IF EL.ID(I)=0 THEN [LOKEY _ INCR _ PWR10(D.DGMAX); GO INRA]
         WD _ EL(I)
         LOKEY _ -WD(1); INCR _ -1
         IF WD(2)=0 THEN HIKEY_LOKEY ELSE DO
           IF WD(2)=$: THEN HIKEY_-WD(3) ELSE DO
             INCR _ -WD(3)    !WD(2) IS (, WD(4) IS )
             IF HIKEY _ -WD(5)=0 THEN DO    !CREATE UPPER LIMIT KEY
INRA:          IF CNUM=K.REN THEN LNUM _ LTBL(1)+LSTCNT ELSE DO
                 XLKLN(LOKEY,CONT); INC LNUM
                 ! LNUM IS 1ST PROG. LINE ABOVE LOWER LIMIT
               END
CONT:          HIKEY _ IF LNUM >NLINES THEN LKY.MAX ELSE &
                 INTKEY(LNUM)-1
             END
           END
           IF HIKEY < LOKEY THEN ERR(BDLRNG)   !OLD CCS DISALLOWED =
         END

         XLKLN(LOKEY,NXT)
NXT:     LONUM _ LNUM
         XLKLN(HIKEY,NXT1); INC LNUM
NXT1:    HINUM _ LNUM
         ! HINUM-LONUM IS NO. OF LINES CURRENTLY IN RANGE
         MXINCT _ NLMAX MIN 1+(HIKEY-LOKEY)/(IF INCR<0 THEN 1 &
           ELSE INCR) MIN HINUM-LONUM+NLMAX-NLINES

         TXINCT _ 0; SETCP(TKFN, TKCP _ TKCPTOP); RETURN

END INRANG


%INLIST (I)

!  IF NO PROGRAM, ERROR.
!  I IS INDEX INTO EL.ID & EL ARRAYS FOR LINE LIST INFO. EL(I) IS
!  ADDRESS OF WD BEFORE 1ST WD OF SUBELEMENT LIST,
!  UNLESS EL.ID(I) IS 0, TO INDICATE DEFAULT LIST OF *1:$.
!  CALCULATES AND STORES LIST PARAMETERS AS FOLLOWS:
!    LSTCNT    TOTAL NO. OF LINES SPECIFIED
!    LTBL(1)   LINE NO. OF 1ST LINE OF 1ST SUBRANGE (LIST CONSTRUCTION
!              IS SUBRANGES SEPARATED BY COMMAS)
!    LTBL(2)   NO. OF LINES IN THIS SUBRANGE (>=0)
!    LTBL(3)   LINE NO. OF 2ND SUBRANGE (IF ANY)
!    ETC.
!  RETURNS NO. OF SUBRANGES READ.

LOCAL %NXADR
LOCAL MTCHFG, SAVE, CNT
LOCAL TERM

         PRGCHK
         IF EL.ID(I)=0 THEN DO     !ALL LINES
           LSTCNT _ LTBL(2) _ NLINES; LTBL(1) _ CNT _ 1
         END ELSE DO
           WD _ EL(I)
           CNT _ LSTCNT _ PTR _ I _ 0
           LOOP DO
             IF INC CNT>RNGMX THEN ERR(LSTLNG)
             SAVE _ 0; LTBL(INC I) _ NXADR
             IF TERM=$: THEN DO
               IF LTBL(INC I) _ NXADR-LTBL(I)+1 <0 THEN ERR(BDLRNG)
             END ELSE LTBL(INC I) _ MTCHFG
             LSTCNT +_ LTBL(I)
             WHILE TERM=$,
           END
         END

         I.NXLNUM; RETURN CNT

%NXADR

!  RETURNS LINE NO. CORRESPONDING TO NEXT LINE ADDRESS (BEGINNING
!  AT INC PTR). LEAVES PTR AT : , OR 0, WITH WD(PTR) IN TERM.
!  NOTE: IF NEGATIVE SUBELEMENT, IS INTEGER REPRESENTING LINE KEY OR 
!  DISPLACEMENT.

LOCAL NX1:, LKEY

         MTCHFG _ YES; LKEY _ 0
         EIF WD(INC PTR)<0 THEN DO
           XLKLN(LKEY_-WD(PTR),NX1)    !STORES RESULT IN LNUM
           GO NX2
NX1:       MTCHFG _ NO   !IS 1+GREATEST LINE NO. WITH SMALLER KEY
         END
         ORIF WD(PTR)=$. THEN LNUM_DOTNUM
         ORIF WD(PTR)=$$ THEN LNUM _ NLINES
         ELSE !IS $*! IF LNUM_-WD(INC PTR)>NLINES THEN ERR(BDLRNG)

NX2:     IF TEMP_[WD(INC PTR)=$-] OR WD(PTR)=$+ THEN DO
           IF MTCHFG=NO THEN ERR(BDLRNG)
           INC PTR; LNUM +_ IF TEMP THEN WD(PTR) ELSE -WD(PTR)
           IF NOT(1<=LNUM<=NLINES) THEN ERR(BDLRNG)
           INC PTR
         END ELSE DO     !NO DISPLACEMENT
           IF SAVE#0 AND MTCHFG=NO THEN DEC LNUM
         END

         IF LKEY=0 THEN LKEY _ INTKEY(LNUM)
         IF SAVE=0 THEN SAVE _ LKEY ELSE IF SAVE>LKEY THEN ERR(BDLRNG)
         TERM _ WD(PTR); RETURN LNUM

END NXADR

END INLIST


%I.NXLNUM

!  INITIALIZES %NXLNUM TO RETURN 1ST LINE NO. IN LTBL
!  CALLED BEFORE %INLIST RETURN.

LOCAL CNT, PTR

CNT _ -1; PTR _ 1; RETURN

%%NXLNUM

!  RETURNS (AND STORES IN LNUM) NEXT LINE NO. SPECIFIED IN LTBL.
!  BEWARE OF OVERCALLING (MAX. OF LSTCNT CALLS AFTER I.NXNLUM)!!

IF INC CNT = LTBL(PTR+1) THEN DO
  WHILE LTBL(1+PTR+_2)=0 THEN NULL; CNT _ 0
END
RETURN LNUM _ LTBL(PTR)+CNT

END I.NXLNUM


%INTXL

!  WRITE TOKENS FOR LINE AT LPTR AT TKCP AND STORE CORRESPONDING
!  TKCPD ENTRY IN SCR ARRAY.  UPDATE TKCP.
!  OFFALT PROTECTS AGAINST TXINCT BEING 1>NO. OF SCR ENTRIES.

         IF TXINCT = MXINCT THEN &
         ABERR(IF CNUM=K.ENT THEN PTROOM ELSE NOROOM)
         OFFALT; SCR(INC TXINCT) _ PKTK; ONALT
         RETURN

END INTXL


%MRGINP

!  MERGE THOSE LINES WHICH HAVE TKCPD ENTRIES IN SCR ARRAY.
!  (TXINCT LINES IN ALL).  1ST KEY IS LOKEY; INCR IS CALCULATED IF
!  NEVER SPECIFIED.  1ST LNUM IS LONUM; LOKEY AND LONUM ARE UPDATED.
!  RETURNS NO. OF LAST LINE MERGED, POSSIBLY USED TO SET DOTNUM
!  (THUS DOES NOTHING BUT RETURN DOTNUM IF TXINCT IS 0.)

LOCAL MVCNT, MVDIS

         IF TXINCT=0 THEN RETURN DOTNUM
         SET.INCR
         MVCNT _ NLINES-HINUM+1
         IF MVDIS _ LONUM+TXINCT-HINUM >0 THEN DO
!  MOVE DOWN LOWER PART OF EACH DICTIONARY,STARTING WITH LAST ENTRY
!  (NLINES), ENDING WITH BEGINNING OF LOWER PART (HINUM).
           PTR _ NLINES+1
           REPEAT MVCNT DO
             TKCPD(PTR+MVDIS) _ TKCPD(DEC PTR)
             LKEYD(PTR+MVDIS) _ LKEYD(PTR)
           END
         END ELSE IF MVDIS<0 THEN DO     !MOVE UP LOWER PART
           MOVE MVCNT FROM @TKCPD(HINUM) TO @TKCPD(LONUM+TXINCT)
           MOVE MVCNT FROM @LKEYD(HINUM) TO @LKEYD(LONUM+TXINCT)
         END
         DEC LONUM; I _ 0
         WHILE INC I <= TXINCT THEN DO
           TKCPD(INC LONUM) _ SCR(I)
           LKEYD(LONUM) _ BCD(LOKEY<==LOKEY+INCR)
         END
         NLINES +_ MVDIS
%%MOV.CPTOP
         TKCPTOP _ TKCP; ^CSVFTB _ 0
         RETURN LONUM
END MRGINP


%SET.INCR

! COMPUTE INCREMENT IF NECESSARY.

IF TXINCT>1 AND INCR<0 THEN DO
  TEMP _ (HIKEY-LOKEY)/(TXINCT-1) +1
  I _ D.DGMAX+1
  WHILE TEMP <= PWR10(DEC I) THEN NULL; INCR _ PWR10(I)
END
RETURN

END SET.INCR


%PKTK

!  EXAMINES LINE AT LPTR (WHICH ENDS IN CARRET...EOLIT).
!  WRITES TOKENS ON TKFN (CURSOR POSITION IS TKCP), UPDATES TKCP
!  AND RETURNS CORRESPONDING TKCPD ENTRY.
!  TOKEN=CHARACTER, INCLUDING LEADING BLANKS.

         CNT _ 0
         WHILE CHAR_NXCHAR#EOLIT THEN [WX(TKFN,CHAR); INC CNT]
         IF TKCP>TKCPMX THEN ABERR(ENDSCR)
         RETURN [TKFLDS]*[TKCP<==TKCP+CNT,CNT]

END PKTK


%UNPKTK (DEST, LAB:)

!  EXAMINES TOKENS AT TKCPD(LNUM) AND WRITES TEXT OF LINE ON OUTFN
!  IF DEST IS 0 ELSE AT CHAR PTR DEST.  DECS OUTCNT WITH EACH WRITE;
!  GOES TO LAB IF <0 (LINE TOO LONG).
!  RETURNS DEST (IS ADVANCED CHAR PTR IF NOT 0)
!  IMPLEMENTATION DEPENDENCY: PHASE 2 INPUT MUST BE FORMATTED,
!  SO LABEL SEPARATION IS UNNECESSARY.

LOCAL LAST, CNT

         [TKFLDS] * [TEMP,CNT] _ TKCPD(LNUM)
         SETCP(TKFN,TEMP)
         LAST _ 0
         REPEAT CNT DO
           TEMP _ R(TKFN)
           IF DEST THEN NCHV DEST _ TEMP ELSE DO
             IF LAST=LNFEED THEN DO
               REPEAT TABSP+LBL.DGMAX+1 [W(OUTFN,$ ); DEC OUTCNT]
             END
             LAST _ W(OUTFN,TEMP)
           END
           IF DEC OUTCNT<0 THEN DO
             IF DEST THEN [CHV DEST_EOLIT; PCHV DEST_CARRET]
             GO LAB
            END
         END
         IF DEST THEN REPEAT 3 NCHV DEST _ EOLIT   !FILL LAST WORD
         RETURN DEST

END UNPKTK


%OUTKEY (DEST, IFS, DFS)

! WRITES PRMKEY (LINE KEY IN DICTIONARY FORM) PLUS A BLANK, ON OUTFN IF
! DEST IS 0 ELSE AT CHAR PTR DEST.  DECS OUTCNT WITH EACH WRITE.  
!  PRMPTKEY CALLED FROM %PRMPT; PRMKEY SET BEFORE %GETSTR CALL.
! IFS IS INTEGER FIELD SIZE (BLANKS IN PLACE OF LEADING ZEROES); DFS
! IS DECIMAL FIELD SIZE (BLANKS IN PLACE OF TRAILING ZEROES).
! IFS=DFS=0 SUPPRESSES THESE ZEROES.
! RETURNS DEST (IS ADVANCED CHAR PTR IF NOT 0).

LOCAL %OUT
LOCAL FLG, KEY, TEMP

         PRMKEY _ LKEYD(LNUM)

%%PRMPTKEY (DEST, IFS, DFS)

         FLG _ NO; KEY _ PRMKEY SHL (BPW-(CNT_DGMAX)*4)
         WHILE DEC CNT>=D.DGMAX THEN DO      !PRINT INTEGER DIGITS
           [TEMP;KEY] _ [0;KEY] DSHL 4
           IF TEMP THEN FLG _ YES  !SUPPRESS LEADING ZEROES
           IF FLG THEN OUT(TEMP+$0) ELSE IF CNT-D.DGMAX<IFS THEN OUT($ )
         END
         IF KEY THEN DO  !PRINT DEC. DIGITS
           OUT($.)
           WHILE KEY THEN DO
             [TEMP;KEY] _ [0;KEY] DSHL 4; OUT(TEMP+$0); DEC DFS
           END
         END ELSE IF DFS THEN INC DFS !NO DEC. PART - BLANK DOT POSITION
         REPEAT DFS OUT($ )
         OUT($ ); RETURN DEST

%OUT (X)
  IF DEST THEN NCHV DEST _ X ELSE W(OUTFN,X); DEC OUTCNT; RETURN
END OUT


%PLNKEY

! MACHINE DEPENDENT.  SPECIAL FILE OUTPUT FOR SAVE AND FAST.
! CONVERTS LKEYD(LNUM) TO CHARS RIGHT-JUSTIFIED WITH LEADING $0'S,
! WITH TRAILING 0'S SUPPRESSED.
! STORES RESULT AT PLN & CALLS PLNW TO WRITE KEY.

LOCAL I, PLN(0:1)
DEF NXRDG AS ((KEY<==KEY SHR 4) BAND OCT 17)

         PLN(0) _ PLN(1) _ ^'00000'; TEMP _ CHPT(PLN+2)
         KEY _ LKEYD(LNUM); I _ 0
         WHILE KEY BAND OCT 17=0 THEN DO
           KEY _ KEY SHR 4
           IF INC I=DDGMAX THEN GO INT
         END
         REPEAT DDGMAX-I PCHV TEMP _ NXRDG+$0   !OUT DEC. PART
         PCHV TEMP _ $.
INT:     REPEAT IDGMAX PCHV TEMP _ NXRDG+$0
         I _ 1
         IF PLN(0)=^'00000' THEN PLN(0) _ PLN(1) ELSE INC I
         PLNW(OUTFN,PLN,I); RETURN

END PLNKEY


END OUTKEY


%MKDL (LNUM)

!  MARK LINE WITH NUMBER LNUM FOR DELETION (TURN ON SIGN BIT)

LKEYD(LNUM) BOR_ SGNBIT; RETURN

END MKDL


%DELMKD (LO, HI)

!  DELETE LINES MARKED FOR DELETION (SIGN BIT ON) IN RANGE OF LINE
!  NUMBERS LO TO HI; I.E., CRUNCH UNMARKED LINES.
!  RETURNS INDEX TO LAST OF CRUNCHED LINES (LO-1 IF ALL MARKED).
!  IF HI EXCEEDS LO, RETURNS LO-1; WHEN CALLED IN MOVING
!  LIST TO RANGE, WILL WORK OK IF LONUM IS 0 OR HINUM IS NLINES+1.
!  ADJUST DOTNUM IF IN AFFECTED RANGE.

LNUM _ I _ LO-1
WHILE INC LNUM<=HI THEN DO
  IF LKEYD(LNUM)>0 THEN DO
    LKEYD(INC I) _ LKEYD(LNUM)
    TKCPD(I) _ TKCPD(LNUM)
  END
  IF LNUM=DOTNUM AND DOTNUM _ I =0 THEN INC DOTNUM
END
^CSVFTB _ 0
RETURN I

END DELMKD


%UNMKDL

!  UNMARK ALL LINES MARKED FOR DELETION (TURN OFF SIGN BIT).

LNUM _ 0
REPEAT NLINES &
  LKEYD(INC LNUM) BAND_ BNOT SGNBIT
RETURN

END UNMKDL


%LIST.PAR

!  DETERMINES LINE KEY FIELD SIZE BY
!  EXAMINING KEYS OF ALL LINES SPECIFIED IN LTBL AND RETURNS DOUBLE
!  ARITHMETIC EXPRESSION SPECIFYING MAX. NO. OF INTEGER DIGITS
!  AND MAX. NO. OF DECIMAL DIGITS IN EXAMINED KEYS.
!  ALSO SETS TABSP (LIST INDENTATION FOR UNPKTK).
!  RETURNS ZEROES IF COMMAND IS NOT LIST.
!  ASSUMES I.NXLNUM PREV. CALLED, AND CALLS AGAIN BEFORE RETURN.

         I _ J _ TABSP _ 0
         IF CNUM=K.LIST AND LSTCNT#0 THEN DO
           TEMP _ 0; REPEAT LSTCNT TEMP BOR_ LKEYD(NXLNUM)
           I.NXLNUM
           WHILE J<D.DGMAX AND TEMP BAND HEX F=0 THEN DO
             TEMP _ TEMP SHR 4; INC J   !J=NO. OF TRAILING DECIMAL 0'S
           END
           WHILE TEMP THEN DO
             TEMP _ TEMP SHR 4; INC I    !I=TOTAL NO. DIGITS
           END
           I _ 0 MAX I-J_(D.DGMAX-J)   !ALLOWS FOR LEADING DECIMAL 0'S
           TABSP _ I+J+1      !ADD 1 FOR BLANK
           IF J>0 THEN INC TABSP      !ADD 1 FOR ., IF ANY
           IF OUTFN=TEL THEN PUT(CARRET)   !FOR BOB RASMUSSEN
         END
         RETURN [I;J]

END LIST.PAR


%XLKLN (ILKEY,LAB:)

!  TRANSFORMS ILKEY (LINE KEY IN INTEGER FORM) TO ORDINAL LINE
!  NO., STORING RESULT IN LNUM.  IF EXACT MATCH, RETURNS; IF NOT,
!  RESULT IS 1+GREATEST LINE NO. WITH SMALLER LKEY & GOES TO LAB
!  RATHER THAN RETURN.

         LNUM _ 0; TEMP _ BCD(ILKEY)
         WHILE INC LNUM<=NLINES THEN DO
           IF TEMP <= LKEYD(LNUM) THEN DO
             IF TEMP=LKEYD(LNUM) THEN RETURN; GO LAB
           END
         END
         GO LAB

END XLKLN


%BCD (ILKEY)

!  TRANSFORMS ILKEY (LINE KEY IN INTEGER FORM) TO BCD (DICTIONARY)
!  FORM
!  AND RETURNS RESULT.

LOCAL TEMP, I

         TEMP _ 0; CNT _ -4
         WHILE ILKEY THEN DO
           [ILKEY;I] _ ILKEY DIVMOD 10
           TEMP BOR_ (I SHL CNT +_ 4)
         END
         RETURN TEMP

END BCD


%INTKEY (LNUM)

LOCAL TEMP, I

!  TRANSFORMS LINE KEY CORRESPONDING TO LNUM FROM BCD (DICTIONARY
!  FORM) TO INTEGER FORM AND RETURNS RESULT.

         TEMP _ (I_LKEYD(LNUM)) BAND HEX F; CNT _ 0
         WHILE I _ I SHR 4 > 0 THEN DO
           TEMP _ TEMP + (I BAND HEX F) * PWR10(INC CNT)
         END
         RETURN TEMP

END INTKEY


%ANS (QUES)

!  PRINTS QUES (IF COMMAND FILE TEL), READS ANSWER AND RETURNS 1 IF YES,
!  0 IF NO.

         IF CFN=TEL THEN [MSG(QUES); PRMNUM _ K.PQM]
         LOOP DO
           GETSTR(CFN)
           IF LWALPH(CHAR _ NXNSP) THEN XLWUP(CHAR)
           IF NOT($Y#CHAR#$N) THEN RETURN [CHAR=$Y]
           IF CFN#TEL THEN ERR(BDANS)
           MSG('WHAT')
         END

END ANS

END CEXU


%ALPH (X)
! NOT MACRO SO X CAN HAVE SIDE EFFECT (I.E., NCHV)
RETURN [UPALPH(X) OR LWALPH(X)]
END ALPH

END CCS
   ; ;\