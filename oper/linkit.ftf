C       LINKIT.FTF
        SUBROUTINE LINK1
C
C       THIS ROUTINE LINKS THE CURRENT PIN INTO THE SIGNAL LIST
C       IT SPECIFIES, IN THE APPROPRIATE FASHION
C
        DOUBLE PRECISION ID
        DIMENSION XY(2)
C
        COMMON /HASHCON/ HASH, NHASH, THISSIG, SIGID, NEXTSIG,
     1  SIGPIN, SIGFLAG
        DOUBLE PRECISION SIGID
        INTEGER HASH, NHASH, THISSIG, SIGPIN
        LOGICAL SIGFLAG
C
        COMMON /SOCKET/ SOCID(2), NPINS, NWORDS, SOCPNT, SOCFLAG,
     1  THISSOC
        INTEGER SOCID, SOCPNT, THISSOC
        LOGICAL SOCFLAG
C
        COMMON /PINS/ PINID, CORAL(2), XPIN, YPIN, PSIG, FROMSIG,
     1  TOSIG, PPPNT, SPRING, ATTRIB, DIST, CNGWORD, NULL, PINFLAG,
     2  THISPIN
        DOUBLE PRECISION PSIG
        INTEGER PINID, CORAL, FROMSIG, TOSIG, PPPNT, SPRING,
     1  ATTRIB, CNGWORD, NULL, THISPIN
        LOGICAL PINFLAG
C
        COMMON /TITLE/ TITLE(16), MODIFY(2), NEWMOD, MODFLG, WRITEIT,
     1  XMIN, XMAX, YMIN, YMAX, PICFRAM
        INTEGER TITLE
        LOGICAL MODFLG, NEWMOD, WRITEIT, PICFRAM
C
        LOGICAL FLAG, MASK, CODES, EDGE, SOURCE
        DATA MASK / "377777777777 /
        DATA EDGE, SOURCE /"200000000000, "004000000000 /
C
C
C       FIND THE SIGNAL THIS CORRESPONDS TO
        FLAG = 0
        XY(1) = XPIN
        XY(2) = YPIN
        CALL SIGFIND(PSIG)
C
C       SKIP IF THIS IS NOT THE ONLY SIGNAL
        IF (SIGPIN .NE. 0) GO TO 110
C
C       LINK THE SIGNAL TO THE PIN AND EXIT
  100   SIGPIN = THISPIN .OR. FLAG
        SIGFLAG = .TRUE.
        CALL PUTSIG
        RETURN
C
C       MUST SEARCH SIGNALS...FIND AND REMEMBER THE CURRENT PIN
  110   IT = THISPIN
        ID = PSIG
        CODES = ATTRIB
        J = 0
C
C       DETERMINE IF BUSSED, OR NORMAL SIGNAL
        IF (SIGPIN .GT. 0) GO TO 230
C
C
C       BUSSED SIGNAL
        FLAG = "400000000000
C
C       SEARCH FOR NON-RING ELEMENTS, TEST IF BUSSED
  120   I = CORAL(1)
        IF (I .EQ. IT) GO TO 200
        CALL GETPIN(I)
        IF (SPRING .NE. 0) GO TO 120
        IF (PSIG .NE. ID) GO TO 120
C
C       HAVE FOUND PIN /I/ OF SAME BUSSED SIGNAL
  130   IF (TOSIG .EQ. 0) GO TO 170
C
C       BUSSED SIGNAL LIST CONTAINS MORE THAN ONE PIN
  140   I = TOSIG
  150   J = TOSIG
        CALL GETPIN(J)
        IF (TOSIG .NE. 0) GO TO 150
C
C       GOT STRING RUNNING FROM I TO J...FIND BEST LOCATION
  160   CALL BEST(IT, I, J)
C
C       NOW LINK THE PIN IN...APPEND /IT/ TO /I/
  170   IF (I .EQ. 0) GO TO 180
        CALL GETPIN(I)
        V = HOWFAR(XPIN, XY(1) )
        TOSIG = IT
        DIST = V
        PINFLAG = .TRUE.
  180   CALL GETPIN(IT)
        FROMSIG = I .OR. FLAG
        TOSIG = J
        PINFLAG = .TRUE.
        IF (J .EQ. 0) GO TO 190
        IF (J .EQ. I) GO TO 190
        CALL GETPIN(J)
        V = HOWFAR(XY(1), XPIN)
        CALL GETPIN(IT)
        DIST = V
        PINFLAG = .TRUE.
        CALL GETPIN(J)
        FROMSIG = IT .OR. FLAG
        PINFLAG = .TRUE.
  190   CALL PUTPIN
        IF (I .EQ. 0) GO TO 100
        RETURN
C
C       SIGNAL NOT BUSSED WITHIN SOCKET...SEARCH ALL OF SIGNAL FOR NEAREST
  200   J = SIGPIN .AND. MASK
        I = J
        V = 1000000000.0
  210   CALL GETPIN(J)
        T = HOWFAR(XPIN, XY(1) )
        IF (T .GE. V) GO TO 220
        I = J
        V = T
  220   CALL GETPIN(J)
        J = FROMSIG .AND. MASK
        IF (J .NE. 0) GO TO 210
        GO TO 160
C
C       NORMAL SIGNAL...DETERMINE ATTRIBUTES
  230   I = SIGPIN
        IF ( (CODES .AND. SOURCE) .EQ. 0) GO TO 270
C
C       THIS PIN (/IT/) IS A SIGNAL SOURCE...EXTRACT SOURCE PORTION OF LIST
        J = I
  240   CALL GETPIN(J)
        IF ( (ATTRIB .AND. SOURCE) .EQ. 0) GO TO 250
        IF (TOSIG .EQ. 0) GO TO 160
        J = TOSIG
        GO TO 240
C
C       LIST CONTAINS OTHER THAN SOURCES...CHECK
  250   IF (I .NE. J) GO TO 160
C
C       MUST PUT /IT/ FIRST
  260   FROMSIG = IT
        PINFLAG = .TRUE.
        CALL GETPIN(I)
        V = HOWFAR(XY(1), XPIN)
        CALL GETPIN(IT)
        TOSIG = I
        DIST = V
        PINFLAG = .TRUE.
        CALL PUTPIN
        GO TO 100
C
C       /IT/ IS NOT A SIGNAL PIN...SPANOUT SOURCES
  270   CALL GETPIN(I)
        IF ( (ATTRIB .AND. SOURCE) .EQ. 0) GO TO 290
        IF (TOSIG .EQ. 0) GO TO 170
        I = TOSIG
        GO TO 270
C
C       THERE ARE STILL PINS IN LIST...SPAN OVER NON-EDGE PINS
  290   J = I
  300   CALL GETPIN(J)
        IF ( (ATTRIB .AND. EDGE) .NE. 0) GO TO 320
        IF (TOSIG .EQ. 0) GO TO 310
        J = TOSIG
        GO TO 300
C
C       NO EDGE PINS...TEST IF /IT/ IS ONE
  310   IF ( (CODES .AND. EDGE) .EQ. 0) GO TO 160
C
C       IT IS EDGE...APPEND IT
        I = J
        GO TO 170
C
C       BOTH NORMAL AND EDGE PINS EXIST...TEST /IT/
  320   IF ( (CODES .AND. EDGE) .NE. 0) GO TO 330
C
C       /IT/ IS NORMAL...IT GOES BETWEEN I AND J
        IF (FROMSIG .EQ. 0) GO TO 260
        J = FROMSIG
        GO TO 160
C
C       /IT/ IS AN EDGE PIN
  330   I = J
        IF (TOSIG .NE. 0) GO TO 150
        J = 0
        GO TO 150
        END
        SUBROUTINE LINK2(IT, IN)
C
C       THIS ROUTINE LINKS THE CURRENT EXACT PIN STRING, RUNNING FROM
C       /IT/ TO /IN/, INTO THE SIGNAL LIST SPECIFIED.
C
        DOUBLE PRECISION ID
        DIMENSION XY1(2), XY2(2)
C
        COMMON /HASHCON/ HASH, NHASH, THISSIG, SIGID, NEXTSIG,
     1  SIGPIN, SIGFLAG
        DOUBLE PRECISION SIGID
        INTEGER HASH, NHASH, THISSIG, SIGPIN
        LOGICAL SIGFLAG
C
        COMMON /SOCKET/ SOCID(2), NPINS, NWORDS, SOCPNT, SOCFLAG,
     1  THISSOC
        INTEGER SOCID, SOCPNT, THISSOC
        LOGICAL SOCFLAG
C
        COMMON /PINS/ PINID, CORAL(2), XPIN, YPIN, PSIG, FROMSIG,
     1  TOSIG, PPPNT, SPRING, ATTRIB, DIST, CNGWORD, NULL, PINFLAG,
     2  THISPIN
        DOUBLE PRECISION PSIG
        INTEGER PINID, CORAL, FROMSIG, TOSIG, PPPNT, SPRING,
     1  ATTRIB, CNGWORD, NULL, THISPIN
        LOGICAL PINFLAG
C
        COMMON /TITLE/ TITLE(16), MODIFY(2), NEWMOD, MODFLG, WRITEIT,
     1  XMIN, XMAX, YMIN, YMAX, PICFRAM
        INTEGER TITLE
        LOGICAL MODFLG, NEWMOD, WRITEIT, PICFRAM
C
        LOGICAL FLAG, MASK, CODES, EDGE, SOURCE
        DATA MASK / "377777777777 /
        DATA EDGE, SOURCE /"200000000000, "004000000000 /
C
C
C       USE LINK1 IF ONLY ONE PIN IN LIST
        IF (IT .EQ. IN) CALL LINK1
        IF (IT .EQ. IN) RETURN
C
C       FIND THE SIGNAL THIS CORRESPONDS TO
        FLAG = 0
        CALL GETPIN(IN)
        XY2(1) = XPIN
        XY2(2) = YPIN
        CALL GETPIN(IT)
        XY1(1) = XPIN
        XY1(2) = YPIN
        CALL SIGFIND(PSIG)
C
C       SKIP IF THIS IS NOT THE ONLY SIGNAL
        IF (SIGPIN .NE. 0) GO TO 110
C
C       LINK THE SIGNAL TO THE PIN AND EXIT
  100   SIGPIN = THISPIN .OR. FLAG
        SIGFLAG = .TRUE.
        CALL PUTSIG
        RETURN
C
C       MUST SEARCH SIGNALS...FIND AND REMEMBER THE CURRENT PIN
  110   ID = PSIG
        CODES = ATTRIB
        J = 0
C
C       DETERMINE IF BUSSED, OR NORMAL SIGNAL
        IF (SIGPIN .GT. 0) GO TO 230
C
C
C       BUSSED SIGNAL
        FLAG = "400000000000
C
C       SEARCH FOR NON-RING ELEMENTS, TEST IF BUSSED
  120   I = CORAL(1)
        IF (I .EQ. IT) GO TO 200
        CALL GETPIN(I)
        IF (SPRING .NE. 0) GO TO 120
        IF (PSIG .NE. ID) GO TO 120
C
C       HAVE FOUND PIN /I/ OF SAME BUSSED SIGNAL
  130   IF (TOSIG .EQ. 0) GO TO 170
C
C       BUSSED SIGNAL LIST CONTAINS MORE THAN ONE PIN
  140   I = TOSIG
  150   J = TOSIG
        CALL GETPIN(J)
        IF (TOSIG .NE. 0) GO TO 150
C
C       GOT STRING RUNNING FROM I TO J...FIND BEST LOCATION
  160   CALL BEST2(IT, IN, I, J)
C
C       NOW LINK THE PIN IN...APPEND /IT/ TO /I/
  170   IF (I .EQ. 0) GO TO 180
        CALL GETPIN(I)
        V = HOWFAR(XPIN, XY1(1) )
        TOSIG = IT
        DIST = V
        PINFLAG = .TRUE.
  180   CALL GETPIN(IT)
        FROMSIG = I .OR. FLAG
        TOSIG = J
        PINFLAG = .TRUE.
        IF (J .EQ. 0) GO TO 190
        IF (J .EQ. I) GO TO 190
        CALL GETPIN(J)
        V = HOWFAR(XY2(1), XPIN)
        CALL GETPIN(IN)
        DIST = V
        PINFLAG = .TRUE.
        CALL GETPIN(J)
        FROMSIG = IN .OR. FLAG
        PINFLAG = .TRUE.
  190   CALL PUTPIN
        IF (I .EQ. 0) GO TO 100
        RETURN
C
C       SIGNAL NOT BUSSED WITHIN SOCKET...SEARCH ALL OF SIGNAL FOR NEAREST
  200   J = SIGPIN .AND. MASK
        I = J
        V = 1000000000.0
  210   CALL GETPIN(J)
        T = HOWFAR(XPIN, XY1(1) )
        IF (T .GE. V) GO TO 220
        I = J
        V = T
  220   CALL GETPIN(J)
        J = FROMSIG .AND. MASK
        IF (J .NE. 0) GO TO 210
        GO TO 160
C
C       NORMAL SIGNAL...DETERMINE ATTRIBUTES
  230   I = SIGPIN
        IF ( (CODES .AND. SOURCE) .EQ. 0) GO TO 270
C
C       THIS PIN (/IT/) IS A SIGNAL SOURCE...EXTRACT SOURCE PORTION OF LIST
        J = I
  240   CALL GETPIN(J)
        IF ( (ATTRIB .AND. SOURCE) .EQ. 0) GO TO 250
        IF (TOSIG .EQ. 0) GO TO 160
        J = TOSIG
        GO TO 240
C
C       LIST CONTAINS OTHER THAN SOURCES...CHECK
  250   IF (I .NE. J) GO TO 160
C
C       MUST PUT /STRING/ FIRST
  260   FROMSIG = IN
        PINFLAG = .TRUE.
        CALL GETPIN(I)
        V = HOWFAR(XY2(1), XPIN)
        CALL GETPIN(IN)
        TOSIG = I
        DIST = V
        PINFLAG = .TRUE.
        CALL PUTPIN
        GO TO 100
C
C       /IT/ IS NOT A SIGNAL PIN...SPANOUT SOURCES
  270   CALL GETPIN(I)
        IF ( (ATTRIB .AND. SOURCE) .EQ. 0) GO TO 290
        IF (TOSIG .EQ. 0) GO TO 170
        I = TOSIG
        GO TO 270
C
C       THERE ARE STILL PINS IN LIST...SPAN OVER NON-EDGE PINS
  290   J = I
  300   CALL GETPIN(J)
        IF ( (ATTRIB .AND. EDGE) .NE. 0) GO TO 320
        IF (TOSIG .EQ. 0) GO TO 310
        J = TOSIG
        GO TO 300
C
C       NO EDGE PINS...TEST IF /IT/ IS ONE
  310   IF ( (CODES .AND. EDGE) .EQ. 0) GO TO 160
C
C       IT IS EDGE...APPEND IT
        I = J
        GO TO 170
C
C       BOTH NORMAL AND EDGE PINS EXIST...TEST /IT/
  320   IF ( (CODES .AND. EDGE) .NE. 0) GO TO 330
C
C       /IT/ IS NORMAL...IT GOES BETWEEN I AND J
        IF (FROMSIG .EQ. 0) GO TO 260
        J = FROMSIG
        GO TO 160
C
C       /IT/ IS AN EDGE PIN
  330   I = J
        IF (TOSIG .NE. 0) GO TO 150
        J = 0
        GO TO 150
        END
        SUBROUTINE BEST(IT, IS, IN)
C
C       it IS THE BLOCK NUMBER OF THE PIN WHICH IT IS DESIRED TO PLACE
C       IN A SIGNAL SUB-LIST.  THE SUBLIST STARTS WITH PIN is AND ENDS
C       WITH PIN in.  THE LIST IS ASSUMED TO RUN FROM is TO in, AND MAY
C       HAVE ADDITIONAL PINS AT EITHER END.  THE ROUTINE SEARCHES THE
C       LIST, INCLUDING THE LINK BEYOND EACH END, FOR THE BEST PLACE
C       TO PUT it.  THE ROUTINE RETURNS is AND in AS THE BLOCK NUMBERS
C       OF THE ADJACENT PAIR OF PINS TO PUT it BETWEEN.
C
C       IF THE PIN IS TO BE PLACED AT THE END OF THE LIST, THE
C       CORRESPONDING INDEX WILL BE 0.
C
C       VARIABLES USED:
C       D       DISTANCE FROM LAST PIN TO it
C       DD      DISTANCE FROM it TO THIS PIN
C       DDIST   DISTANCE FROM LAST PIN TO THIS PIN
C       EXTRA   EXTRA WIRE NEEDED (TO BE MINIMIZED)
C
        COMMON /PINS/ N1(3), PXY(2), ID(2), FROM, TO, N2(2),
     1  ATTRIB, DIST, N3(3), THIS
        DIMENSION XY(2)
        INTEGER FROM, TO, ATTRIB, THIS, EXACT, MASK
        DATA MASK, EXACT /"377777777777, "000020000000 /
C
C       GET (X,Y) OF it
        CALL GETPIN(IT)
        XY(1) = PXY(1)
        XY(2) = PXY(2)
C
C       NOW GET START PIN OF LIST
        CALL GETPIN(IS)
C
C       SAVE AND SET UP PARAMETERS
        LAST = IN
        IS = FROM .AND. MASK
        IN = THIS
C
C       IGNORE PRECEDING ELEMENT FOR BUSSED PINS
        IF (FROM .LT. 0) GO TO 100
C
C       DETERMINE LEADING ELEMENT
        IF (IS .NE. 0 ) GO TO 110
C
C       NO PRECEDING ELEMENT, COMPUTE PARAMETERS
  100   DD = HOWFAR(XY, PXY)
        D = 0.0
        EXTRA = DD
        DDIST = 0.0
        ITEM = 0
        IX = THIS
        GO TO 130
C
C       FIND FROM, COMPUTE THAT RANGE
  110   CALL GETPIN(IS)
        DDIST = DIST
        D = HOWFAR(PXY, XY)
        EXTRA = 1000000.0
        ITEM = ATTRIB .AND. EXACT
C
C       GET THE NEXT PIN IF ANY
  120   IX = TO
        CALL GETPIN(IX)
        ITEM = ATTRIB .AND. ITEM
        DD = HOWFAR(XY, PXY)
C
C       TEST IF THIS LINK IS BETTER THAN LAST
  130   DDD = D + DD - DDIST
        IF (DDD .GE. EXTRA) GO TO 140
C
C       DO NOT PLACE IN EXACT STRINGS
        IF (ITEM .NE. 0) GO TO 140
C
C       FOUND A BETTER PLACE...SAVE PARAMETERS
        EXTRA = DDD
        IS = FROM .AND. MASK
        IN = THIS
C
C       GO ON TO NEXT PIN IF DESIRABLE
  140   CALL GETPIN(IX)
        IF ( (FROM .AND. MASK) .EQ. LAST) RETURN
        D = DD
        DDIST = DIST
        ITEM = ATTRIB .AND. EXACT
        IF (TO .NE. 0)  GO TO 120
C
C       VERIFY LAST POINT
        IF (D .GT. EXTRA)  RETURN
C
C       HERE IF BEST TO TACK ON END..DO SO
        IS = THIS
        IN = TO
        RETURN
        END
        SUBROUTINE BEST2(IT1, IT2, IS, IN)
C
C       it1 AND it2 ARE THE END BLOCKS OF THE LIST WHICH IT IS DESIRED TO
C       PLACE IN A SIGNAL SUB-LIST.  THE SUBLIST STARTS WITH PIN is AND ENDS
C       WITH PIN in.  THE LIST IS ASSUMED TO RUN FROM is TO in, AND MAY
C       HAVE ADDITIONAL PINS AT EITHER END.  THE ROUTINE SEARCHES THE
C       LIST, INCLUDING THE LINK BEYOND EACH END, FOR THE BEST PLACE
C       TO PUT it.  THE ROUTINE RETURNS is AND in AS THE BLOCK NUMBERS
C       OF THE ADJACENT PAIR OF PINS TO PUT it BETWEEN.
C
C       IF THE PIN IS TO BE PLACED AT THE END OF THE LIST, THE
C       CORRESPONDING INDEX WILL BE 0.
C
C       VARIABLES USED:
C       D       DISTANCE FROM LAST PIN TO it1
C       DD      DISTANCE FROM it2 TO THIS PIN
C       DDIST   DISTANCE FROM LAST PIN TO THIS PIN
C       EXTRA   EXTRA WIRE NEEDED (TO BE MINIMIZED)
C
        COMMON /PINS/ N1(3), PXY(2), ID(2), FROM, TO, N2(2),
     1  ATTRIB, DIST, N3(2), THIS
        DIMENSION XY1(2), XY2(2)
        INTEGER FROM, TO, ATTRIB, THIS, MASK, EXACT
        DATA MASK, EXACT /"377777777777, "000020000000/
C
C       GET (X,Y) OF it1, it2
        CALL GETPIN(IT1)
        XY1(1) = PXY(1)
        XY1(2) = PXY(2)
        CALL GETPIN(IT2)
        XY2(1) = PXY(1)
        XY2(2) = PXY(2)
C
C       NOW GET START PIN OF LIST
        CALL GETPIN(IS)
C
C       SAVE AND SET UP PARAMETERS
        LAST = IN
        IS = FROM
        IN = THIS
C
C       DETERMINE LEADING ELEMENT
        IF (FROM .NE. 0 ) GO TO 100
C
C       NO PRECEDING ELEMENT, COMPUTE PARAMETERS
        DD = HOWFAR(XY2, PXY)
        D = 0.0
        EXTRA = DD
        DDIST = 0.0
        ITEM = O
        IX = THIS
        GO TO 120
C
C       FIND FROM, COMPUTE THAT RANGE
  100   CALL GETPIN(IS)
        DDIST = DIST
        D = HOWFAR(PXY, XY1)
        EXTRA = 1000000.0
        ITEM = ATTRIB .AND. EXACT
C
C       GET THE NEXT PIN IF ANY
  110   IX = TO
        CALL GETPIN(IX)
        ITEM = ATTRIB .AND. ITEM
        DD = HOWFAR(XY2, PXY)
C
C       TEST IF THIS LINK IS BETTER THAN LAST
  120   DDD = D + DD - DDIST
        IF (DDD .GE. EXTRA) GO TO 130
C
C       DO NOT EVALUATE EXACT STRINGS
        IF (ITEM .NE. 0) GO TO 130
C
C       FOUND A BETTER PLACE...SAVE PARAMETERS
        EXTRA = DDD
        IS = FROM
        IN = THIS
C
C       GO ON TO NEXT PIN IF DESIRABLE
  130   CALL GETPIN(IX)
        IF ( (FROM .AND. MASK) .EQ. LAST) RETURN
        D = HOWFAR(PXY, XY1)
        CALL GETPIN(IX)
        ITEM = ATTRIB .AND. MASK
        DDIST = DIST
        IF (TO .NE. 0)  GO TO 110
C
C       VERIFY LAST POINT
        IF (D .GT. EXTRA)  RETURN
C
C       HERE IF BEST TO TACK ON END..DO SO
        IS = THIS
        IN = TO
        RETURN
        END
   