!FILENAME:	H3DRIV.BLI
!DATE:		1 MAR 73

%3.2%	GLOBAL BIND H3DRV=1;	!MODULE VERSION NUMBER






ROUTINE CONCAT(A,B)=
  BEGIN LOCAL  LD,LSA,LSB,X; MACHOP ILDB=#134; MACHOP IDPB=#136;
  LD_(MMC-1)<1,7>;  LSA_(A-1)<1,7>;  LSB_(B-1)<1,7>;
  INCR I FROM 1 TO 5 DO
    IF (X_ILDB(3,LSA)) GTR " "  THEN IDPB(3,LD) ELSE BREAK;
  INCR I FROM 1 TO 5 DO
    IF (X_ILDB(3,LSB)) GTR " "  THEN IDPB(3,LD) ELSE BREAK;
  END;


%3.1%	GLOBAL ROUTINE MACHINECODE(OP,TOG)=
  BEGIN  LOCAL J,X; MACHOP IDPB=#136; 
  !
  !    THIS ROUTINE GENERATES THE MNEMONIC FOR A MACHINE
  !    OP-CODE IN THE GLOBAL VARIABLE 'MMC' AND ITS SUCCESSOR.
  !
%2.25%	STRUCTURE UUONAME[I,J]=(.UUONAME+.I*2+.J)<0,36>;
%2.25%	
%2.25%	!NOTE:	EACH UUO NAME IN THIS PLIT MUST BE >= 6 CHARS AND <= 10 CHARS SO TTHAT IT WILL OCCUPPY
%2.25%	!EXACTLY TWO WORDS IN THE PLIT
%2.25%	
%2.25%	BIND UUONAME UUOOP=PLIT(
%2.25%	'CALL  ',
%2.25%	'INIT  ',
%2.25%	'UUO   ',
%2.25%	'UUO   ',
%2.25%	'UUO   ',
%2.25%	'UUO   ',
%2.25%	'UUO   ',
%2.25%	'CALLI ',
%2.25%	'OPEN  ',
%2.25%	'TTCALL',
%2.25%	'UUO   ',
%2.25%	'UUO   ',
%2.25%	'UUO   ',
%2.25%	'RENAME',
%2.25%	'IN    ',
%2.25%	'OUT   ',
%2.25%	'SETSTS',
%2.25%	'STATO ',
%2.25%	'GETSTS',
%2.25%	'STATZ ',
%2.25%	'INBUF ',
%2.25%	'OUTBUF',
%2.25%	'INPUT ',
%2.25%	'OUTPUT',
%2.25%	'CLOSE ',
%2.25%	'RELEAS',
%2.25%	'MTAPE ',
%2.25%	'UGETF ',
%2.25%	'USETI ',
%2.25%	'USETO ',
%2.25%	'LOOKUP',
%2.25%	'ENTER ');

  MMC_(MMC+1)_0;
  CASE .OP<6,3> OF
    SET

%2.25%    IF .OP LSS #040		!CASE 0
%2.25%	THEN MMC_'UU0'
%2.25%	ELSE
%2.25%	  BEGIN
%2.25%	    MMC_.UUOOP[(.OP-#040),0];
%2.25%	    (MMC+1)<0,36>_.UUOOP[(.OP-#040),1];
%2.25%	END;

    IF .OP<5,1>			! CASE 1
      THEN CONCAT(.POC[1,.OP<2,3>], .OCE[1,.OP<0,2>])
      ELSE MMC_.POC[0,.OP<0,3>];

    IF .OP<5,1>			! CASE 2
      THEN MMC_.POC[3,.OP<0,5>]
      ELSE CONCAT(.POC[2,.OP<2,3>], .OCE[.OP<4,1>,.OP<0,2>]);

    CONCAT(.POC[4,.OP<3,3>], .OCE[5,.OP<0,3>]);	! CASE 3

    CONCAT(.POC[5,.OP<2,4>], .OCE[1,.OP<0,2>]);	! CASE 4

    BEGIN			! CASE 5
    MMC_ CASE (.OP<5,1>^1 OR .OP<2,1>) OF
        SET 'HLL'; 'HRL'; 'HRR'; 'HLR' TES;
    CONCAT( .MMC, .OCE[2,.OP<3,2>] );
    CONCAT( .MMC, .OCE[0,.OP<0,2>]);
    END;

    BEGIN			! CASE 6
    MMC_ CASE (.OP<3,1>^1 OR .OP<0,1>) OF
        SET 'TR'; 'TL'; 'TD'; 'TS' TES;
    CONCAT(.MMC, .OCE[3,.OP<4,2>] );
    CONCAT(.MMC, .OCE[4,.OP<1,2>] );
    END;

    MMC_'IO';			! CASE 7

    TES;
  IF .TOG THEN (ACCUM_(ACCUM+1)_-2; PACCUM_(ACCUM-1)<0,7>);
  INCR I FROM 0 TO 1 DO
    BEGIN  REGISTER X;
    J_36;
    WHILE (J_.J-7) GTR 0 DO
      IF .(X_(MMC+.I)<.J,7>) EQL 0 THEN ( BREAK 0 ) ELSE
	IF .TOG THEN (X_..X;IDPB(X,PACCUM)) ELSE OCHAR(..X);
    END;
  IF NOT.TOG THEN OCHAR(#11)
  END;

ROUTINE LTUSED =

  !COUNT THE NUMBER OF ENTRIES USED IN THE LITERAL TABLE
  !THE VALUE OF THE ROUTINE IS THE NUMBER OF ENTRIES USED.

    BEGIN

%2.9%	REGISTER R,		!POINTER TO LT ENTRIES
%2.9%		COUNT;		!COUNT OF ENTRIES USED IN LT

	COUNT_0;
%2.27%	INCR J FROM 0 TO LTNUM-1 DO
%2.9%	    COUNT_.LTBASE[.J]<LEFTHALF>+.COUNT;
%2.9%	  RETURN .COUNT;

    END;



ROUTINE STACKFREE =

  !DETERMINE HOW MUCH STACK SPACE WAS NOT USED AND RETURN
  !THE NUMBER OF UNUSED STACK LOCATIONS AS THE VALUE OF THE ROUTINE

    DECR I FROM DEPTH-1 TO 0 DO
	IF .STACK[.I] NEQ 0 THEN RETURN DEPTH -.I -1;



ROUTINE WRITEFINAL=
%2.9%    BEGIN
    ! THIS ROUTINE WRITES THE FINAL GOOD-BYE TO THE USER
    ERRBIT_0;    ENEWLINE(); NEWLINE(); NEWLINE();
    IF (.ERRORFOUND+.WARNINGFOUND) NEQ 0 THEN
	BEGIN
	EMESSAGE("# WAR","NINGS"," =   ",3);EOUTDEC(.WARNINGFOUND); ENEWLINE();
	EMESSAGE("# ERR","ORS =","     ",3);EOUTDEC(.ERRORFOUND);ENEWLINE();
	END;
    EMESSAGE("MODUL","E LEN","GTH =",3);
%2.30%    EOUTDEC(.MODLENGTH
%2.30%	+ (IF .LSTART THEN !ADD LENGTH OF PROLOGS AND EPILOGS
%2.30%		(((9+.NOSVR)*(.NOSVR)+10)/2)));
    IF .LUNDEFLG THEN (EOCHAR("+");EOUTDEC(.NODISC));
%2.9%    EOCHAR("+");EOUTDEC(.PTREFNO + 1 + 	!PTREFNO = # PTRS - 1
%2.9%	!ADD THE NUMBER OF LITERALS
%2.9%	BEGIN
%2.9%	  REGISTER R;
%2.9%	  R_0;
%2.27%		INCR I FROM 0 TO LTNUM-1 DO
%2.9%	  R_.LTTBASE[.I]<LEFTHALF> + .R;
%2.9%	  .R
%2.9%	END
%2.23% + .PLNEXT );ENEWLINE();

    IF .STATFLG THEN	!OUTPUT THE FOLLOWING ONLY ON /S
      BEGIN

	!OUTPUT SOME ADDITIONAL COMPILATION STATISTICS

	EMESSAGE("LITER","AL TA","BLE U","SED ="," ",5);
	EOUTDEC (LTUSED());
	EOUTSTR (" OF ",4);
%2.9%	EOUTDEC (
%2.9%		BEGIN
%2.9%		  REGISTER R;
%2.9%		  R_0;
%2.27%		  INCR I FROM 0 TO LTNUM - 1 DO
%2.9%		    IF .LTBASE[.I] EQL 0 THEN EXITLOOP
%2.9%		      ELSE R_.R+1;
%2.9%		  .R*LTSIZE
%2.9%		END
%2.9%		);
	EMESSAGE (" ENTR","IES",2);
	ENEWLINE();

	!AMOUNT OF STACK USED

	EMESSAGE ("STACK"," USED"," = ",3);
	EOUTDEC (DEPTH<0,0>-(STACKFREE()));
	EOUTSTR (" OF ",4);
	EOUTDEC (DEPTH<0,0>);
	EMESSAGE (" WORD","S",2);
	ENEWLINE();

	!MAX AMOUNT OF CORE USED

	EMESSAGE ("MAX C","ORE U","SED ="," ",4);
	EOUTDEC ((.JOBREL<RIGHTHALF>+1)^(-10));
	EOUTSTR (" + ",3);
	EOUTDEC (((.JOBHRL<RIGHTHALF> AND #377777) + 1)^(-10));
	EOUTSTR (" K",2);
	ENEWLINE()
      END;


IF .CCLCTL NEQ 0 THEN CCLCTL<2,1>_1;  % SUPPRESS CRAP %
    EMESSAGE("COMPI","LATIO","N COM","PLETE",4);
    ENEWLINE();
    IF .TTYLST THEN EOUTSTR(7^14 OR 7^7 OR 7,3);
    INCR I FROM 0 TO IF .TTYLST THEN 9 ELSE 4 DO ENEWLINE();
   CCLCTL<2,1>_0; % DONE SUPPRESSING %
    IF NOT.LSTFLG THEN FORCE(2);
    IF NOT.BINFLG THEN ( FORCE(1));
    END;

%2.25%	ROUTINE DELFLINK(IND)=
%2.25%		!AT THIS POINT THE STRUCTURE OF THE TREE IN WHICH IND RESIDES
%2.25%		!HAS BEEN ALTERED A GREAT DEAL FROM THE STANDARD:
%2.25%		!CELLS ASSOCIATED WITH LABELS WILL HAVE THEIR HEADER BITS
%2.25%		!ON EVEN THO THEY AREN'T HEADERS.
%2.25%		!BACKWARD LINKS ARE NO LONGER VALID EXCEPT FOR LINE # REFERENCE
%2.25%		!CELLS WHICH MUST HAVE VALID BACKWARD LINKS.
%2.25%		!.IND IS THE INDEX OF THE CELL WE WISH TO DELETE FROM THIS
%2.25%		!NON-STANDARD TREE.
%2.25%	
%2.25%		BEGIN
%2.25%	
%2.25%		  !IF THE CELL FOLLOWING .IND IS A LINE # CELL, WE MUST FIX
%2.25%		  !UP ITS PREVF.
%2.25%	
%2.25%		  IF .CT[.CT[.IND,0]<NEXTF>,1]<OPLEFTF> EQL 0
%2.25%			THEN CT[.CT[.IND,0]<NEXTF>,0]<PREVF> _ .CT[.IND,0]<PREVF>;
%2.25%		  !LINK THE CELL BEFORE .IND TO POINT TO THE GUY .IND POINTS TO
%2.25%		  !IF THE GUY BEFORE .IND IS A HEADER, UPDATE THE NEXTF OF WORD 1
%2.25%		  !OTHERWISE WORD 0.  IT TURNS OUT THAT BY THE TIME WE REACH
%2.25%		  !.IND AT THIS POINT, HEADER BITS FOR CELLS BEFORE .IND IN THE
%2.25%		  !TREE VALIDLY INDICATE A TRUE LIST HEADER CONDITION WHEREAS
%2.25%		  !HEADER BITS FOR CELLS WHICH FOLLOW .IND MAY OR MAY NOT INDICATE
%2.25%		  !TRUE HEADERS
%2.25%	
%2.25%			  CT[.CT[.IND,0]<PREVF>,.CT[.CT[.IND,0]<PREVF>,0]<HDRF>]<NEXTF>_.CT[.IND,0]<NEXTF>;
%2.25%		  DELCELL(.IND);
%2.25%	
%2.25%		END;	!OF ROUTINE DELFLINK


%3.1%	GLOBAL ROUTINE WRITECODE(H)=
%2.25%  BEGIN LOCAL OFSET,N,M,A,I,R,T,P; BIND LUNDEWORD=(.FCNSTATE NEQ 0) AND .LUNDEFLG; 
%2.25%	MACRO	LABF(I)=CT[I,0]<PREVF>$;	!LABEL NUM OF LABEL CELL
%2.25%	!IF NO LABEL # ASSIGNED, BUMP NEXTLAB AND
%2.25%	!ASSIGN ITS VALUE TO THE LABEL #.
%2.25%	!IN ANY CASE, RETURN THE LABEL NUMBER.
%2.25%	MACRO	LABNUM(I)=IF .LABF(I) EQL 0
				THEN (LABF(I)_(NEXTLAB_.NEXTLAB+1))
				ELSE .LABF(I)$;
%2.25%	LOCAL LNSEEN;	!0 => NO BLISS-10 LINE REFS
			!OTHERWISE LINE #
%2.25%	EXTERNAL OUTDEC, EOUTPSTRING, OUTPSTRING, RLTTRANS, R50TOASCIZ;

    BIND RMNAM = .MNAM^(-8);
    ROUTINE OUTCTREF(IND) =
      BEGIN
        LOCAL V;
        V _ IF .CT[.IND]<30,6> EQL #76
          THEN -OUTSTN(.CT[.IND,2]) ELSE OUTSTR("L.",2) + OUTMOC(LABNUM(.IND));
        IF .V LSS 0 THEN -.V ELSE .V
      END;
%2.25%	!ZEROLABF FOR EACH CELL SO WE CAN USE IT TO HOLD THE
%2.25%	!CONVERTED  LABEL NO.  IN ORDER TO MAKE ALL LABEL NAMES
%2.25%	!WITHIN A MODULE UNIQUE, WE'LL ASSIGN THEM STARTING WITH
%2.25%	!L.1 IN CONSEQUTIVE ORDER.  THE LABF WILL CONTAIN THE LABEL NO.
%2.25%	!CORRESPONDING TO THE PARTICULAR LABEL CELL.

%2.25%	N_.CT[.H,1]<NEXTF>;	!GET START OF TREE

%2.25%	UNTIL .N EQL .H
%2.25%	  DO
%2.25%	    BEGIN
%2.25%	      IF .CT[.N,1]<OPLEFTF> NEQ 0 THEN !WE CAN ZERO PREVF
%2.25%	      LABF(.N)_0;	!TO INDICATE NO NUM ASSIGNED YET
%2.25%	      N_.CT[.N,0]<NEXTF>;	!LOOK AT NEXT CELL
%2.25%	    END;

    N_.CT[.H,1]<NEXTF>;
    IF .FCNSTATE NEQ 0 THEN NODISC_.NODISC+1;
    OFSET_-1; LNSEEN_0;
    IF NOT .MLFLG THEN
      UNTIL .N EQL .H DO
        IF .CT[.N,1]<FUNCF> EQL 0 THEN
          BEGIN
            M_.CT[.N,0]<NEXTF>;
%2.25%            IF NOT (.OFSET EQL -1 AND LUNDEWORD)
%2.25%		!BECAUSE WE HAVE REMOVED BACK LINKS, WE MUST NOT
%2.25%		!DO A STANDARD ERASE OF LINE # CELLS, SO WE LINK FORWARD
%2.25%		!ONLY ACROSS THIS CELL AND THEN SIMPLY RETURN IT.
%2.25%	      THEN DELFLINK(.N)
               ELSE OFSET _ .OFSET + 1;
            N_.M
          END
        ELSE
          BEGIN
            (M_CT[.N,0])<HDRF>_0;
            OFSET_.OFSET+1;
            N_.(.M)<NEXTF>
          END
    ELSE
      BEGIN
	NEWLINE();
%2.25%	!NOW OUTPUT MODULE OR ROUTINE OR FUNCTION NAME AS 
%2.25%	!ADDRESS TAG.  OUTPUT THE APPROPRIATE NAME TO THE LISTING DEVICE.

%2.25%	IF .FCNSTATE EQL 0
%2.25%	  THEN
%2.25%	    IF .STATFLG
%2.25%	      THEN EOUTPSTRING(FNAME)
%2.25%	      ELSE OUTPSTRING(FNAME)
%2.25%	  ELSE
%2.25%	    IF .STATFLG
%2.25%	      THEN EOSTN(.CT[.H,2])
%2.25%	      ELSE OUTSTN(.CT[.H,2]);
%2.25%	!OUTPUT TAG DELIMITER FOR MACRO
%2.25%	OCHAR(":");
%2.25%	!MAKE IT INTERNAL IF MODULE START ADDRESS OR GLOBAL ROUTINE
%2.25%	IF .FCNSTATE EQL 0
%2.25%	  THEN OCHAR(":")
%2.25%	  ELSE
%2.25%	    IF .ST[.CT[.H,2],0]<TYPEF> EQL GROUTINET
%2.25%	      THEN OCHAR(":");
%2.25%	!NOW END THE LINE
%2.25%	IF .STATFLG THEN ENEWLINE() ELSE NEWLINE();
        NEWLINE();
	IF LUNDEWORD THEN
	  BEGIN
            OUTSTR(#11^28 OR "  -1",5);
	    OUTSTR(#11^7 OR #11,2);
	    OUTOCT(.CT[.N,1],12);
	    NEWLINE();
	    N_.CT[.N,0]<NEXTF>
	  END;
        UNTIL .N EQL .H DO
          BEGIN
            IF .CT[.N,1]<FUNCF> EQL 0 THEN
              BEGIN
%2.25%		IF (.LNSEEN EQL 0) THEN
%2.25%	        LNSEEN_.CT[.N,1]^(-4);	!LINE NUMBER
                M_.CT[.N,0]<NEXTF>;
%2.25%	        DELFLINK(.N);
                N_.M
              END
            ELSE
              BEGIN
                OFSET_.OFSET+1;
                IF .(M_CT[.N,0]<HDRF>) THEN
                  BEGIN
%2.25%		    OUTSTR("L.",2);
%2.25%		    OUTMOC(LABNUM(.N));	!WRITE OUT THE LABEL #
%2.25%		    OCHAR(":");	!LABEL DELIMITER
                    .M_0
                  END;
                M_.CT[.N,1];
%2.25%	!OUTPUT A TAB AFTER TAG FIELD
%2.25%	OCHAR(#11);

%2.25%	!OUTPUT OPCODE MNEMONIC
                MACHINECODE(.M<FUNCF>,0);

%2.25%	!OUTPUT AC FIELD
		A_.M<ACCF>;
		SELECT .A OF NSET
		  .SREG: EXITSELECT(OUTSTR("$S",2));
		  .BREG: EXITSELECT(OUTSTR("$B",2));
		  .FREG: EXITSELECT(OUTSTR("$F",2));
		  .VREG: EXITSELECT(OUTSTR("$V",2));
		  .A: OUTOCT(1,.A,2) TESN;
                OCHAR(",");

%2.25%	!OUTPUT INDIRECT SIGN
                IF .M<INDRF> THEN OCHAR("@");

%2.25%	!OUTPUT ADDRESS IN CORRECT FORMAT
                A_.M<ADDRESSF>; I_.M<INDXF>; T_5;
                IF (R_.CT[.N,0]<RELOCF>) LEQ 9 THEN

                  CASE .R OF SET
                    IF .I EQL .FREG THEN
                      BEGIN T_0;P_OUTCONOC(.A) END
                    ELSE P_OUTCONOC(.A);
                    BEGIN T_1;P_OUTSTN(.A) END;
                    P _ OUTCTREF(.A);
%2.26%		BEGIN OUTPSTRING(ONAME); OCHAR("+"); P_7+OUTCONOC(.A); END;
%2.26%		BEGIN OUTPSTRING(GNAME); OCHAR("+"); P_7+OUTCONOC(.A); END;
		    BEGIN T_1;
		      P_
			OUTSTN(.ST[.A,1]<LEFTF>)+
			  (IF NOT .ST[.A,1]<17,1> THEN
			     OCHAR("+")+OUTCONOC(.ST[.A,1]<OFFSETF>)
			   ELSE OUTCONOC(.ST[.A,1]<OFFSETF> OR LEFTM))
		    END;
%2.25%		!ADDRESS OF CONSTANT
%2.25%		!IF THIS CAN BE A LITERAL, MAKE IT ONE AND OUTPUT AS LITERAL ADDRESS
%2.25%		IF .PT[.A,0]<RELOCF> EQL LOCRELOC	!MAKE IT A LITERAL
%2.25%		  THEN
%2.25%		    BEGIN
%2.25%		      R_CT[.N,0]<RELOCF>_LTRELOC;
%2.25%		      A_CT[.N,1]<ADDRESSF>_LTINSERT(OFFST(.PT[.A,1]));
%2.25%		      OUTPSTRING(LNAME); OCHAR("+");
%2.25%		      P_7+OUTCONOC(RLTTRANS(.A));
%2.25%		    END
%2.25%		  ELSE
%2.25%		BEGIN !ADDRESS OF CONSTANT POINTER
%2.25%		  OUTPSTRING(CNAME); OCHAR("+");
%2.25%		  P_7+OUTCONOC(RPTTRANS(.A));	!CHANGE PT IND TO OFFSET
%2.25%		END;
                    BEGIN
%2.25%		      !ADDRESS OF LITERAL
%2.25%		      OUTPSTRING(LNAME); OCHAR("+");
%2.25%		      P_7+OUTCONOC(RLTTRANS(.A));	!CHANGE LT INDEX TO LTT OFFSET
                    END;
                    BEGIN T_2;P_OUTCONOC((.A-.FNSTAT) AND 1^18-1) END;
%2.26%		BEGIN OUTPSTRING(PNAME); OCHAR("+"); P_7+OUTCONOC(.A); END
                  TES;


%2.25%	!NOW OUTPUT INDEX REG
                IF .I NEQ 0 THEN
                  BEGIN
                    P_.P+4;
                    OCHAR("(");
		    SELECT .I OF NSET
		      .SREG: EXITSELECT(OUTSTR("$S",2));
		      .BREG: EXITSELECT(OUTSTR("$B",2));
		      .FREG: EXITSELECT(OUTSTR("$F",2));
		      .VREG: EXITSELECT(OUTSTR("$V",2));
		      .I: OUTOCT(1,.I,2) TESN;
                    OCHAR(")")
                  END;

%2.25%	!NOW OUTPUT COMMENT FIELD
                  BEGIN P_(.P+.M<INDRF>+3)^(-3);
		    IF .TTYLST THEN OCHAR(#11) ELSE
                    OUTSTR(#11^21 OR #11^14 OR #11^7 OR #11,4-.P);
		    OCHAR(";");
%2.25%		!OUTPUT CODE LINE OFFSET
%2.25%		OUTOCT(.OFSET,5);
%2.25%		!THEN BLISS-10 LINE REF #, IF ANY
%2.25%			OCHAR(#11);	!TAB
%2.25%			IF .LNSEEN NEQ 0
%2.25%			  THEN
%2.25%			    BEGIN
%2.25%			      OUTOCT(.LNSEEN,4);	!LINE # IN DECIMAL
%2.25%			      LNSEEN_0;	!SO WE CAN GET NEXT ONE
%2.25%			    END;
%2.25%			!THEN ADDRESS PARAMETER TYPE
%2.25%			IF .T LSS 3
%2.25%			  THEN
%2.25%			    BEGIN
%2.25%			      OCHAR(#11);
%2.25%			      OUTPSTRING (CASE .T OF SET
%2.25%					PLIT (ASCIZ 'FORMAL');
%2.25%					PLIT (ASCIZ 'EXTERNAL');
%2.25%					PLIT (ASCIZ 'LOCAL')
%2.25%					TES)
%2.25%			    END;
                  END;
		NEWLINE();
                N_.CT[.N,0]<NEXTF>
              END;
          END;
	NEWLINE();  NEWLINE();
      END;
    MODLENGTH_.MODLENGTH + .OFSET + 1
  END;





! INITIALIZATION ROUTINE
!------------------------


ROUTINE REINIT=
    BEGIN
    ! THIS ROUTINE IS THE PRIMARY INITIALIZATION OF THE COMPILER.
    ! IT IS CALLED TO RE-INIT THE SYSTEM FOR EACH COMPILATION.

	LOCAL C,J;
        REALFS_0;     !CURRENT KLUGE
%V2H%	LABIND_0;	!ZERO INDEX OF LABEL CHAIN
	ACCUM_(ACCUM+1)_-2;
	PACCUM_(ACCUM)<36,7>;
	TIMSTAT_0;	!INITIALIZE TIMER DATA WORD
	FFSEEN_0;	!NO FORM FEED SEEN YET
	CODETOG_1;
	BLOCKPURGE(0); TOPOFTABLE_.RETOT<RIGHTHALF>;
	ENDOFSPACE_.RETOT<LEFTHALF>;
	FREEHEAD_AMNTFREE_ENDLK_0;
	CCLINIT();

	!NOW SHRINK CORE BACK DOWN TO ORIGINAL SIZE

	IF .JOBREL NEQ .SAVJBREL THEN
	  BEGIN
	    IF (.JOBSYM<RIGHTHALF> GTR 0) AND (.JOBSYM<RIGHTHALF> LSS #400000)
	     THEN	!SAVE SYMBOL TABLE IF IN LOW SEG
		BEGIN
		  REGISTER R;
		  MACHOP HLRO = #564;
		  BIND L= (NOT HLRO (R,JOBSYM)),
		  NEWSYM= (.SAVJBREL<0,18>-L),
		  OLDSYM= (.JOBSYM<0,18>);

		  INCR I FROM 0 TO L DO
			NEWSYM[.I]_.OLDSYM[.I];
		  JOBSYM<0,18> _ NEWSYM;
		END;

	    !NOW LET'S TRY TO GET RID OF THE EXCESS CORE IN THE LOWSEG
	    IF NOT DOCOREUUO (.SAVJBREL<RIGHTHALF>) THEN WARNEM (0,ERCANTSHRINK)
	END;

%2.25%	EXTCOUNT_-1;	!COUNT OF EXTERNS OUT TO MACRO LISTING
%2.25%	TEXTHD_0;	!POINTS TO TEMP EXT LIST FROM EXPHT
%2.34%	GLLIST_0;	!CLEAR GLOBAL SYMBOL TABLE
%2.19%	DECR I FROM HTSIZE-1 TO 0 DO XHT[.I]_0;
	INITIO();
	GTP_CODEPROP_0;
%2.32%	!SET UP DEFAULT MODULE NAME MAIN
%2.32%	MNAM_'MAIN'+#177^1;  MNAM+1_-2;
	BUFPT1_BUF1<0,2>; BUFPT2_BUF2<0,2>;
	BUF1_1^18; BUF2_2^18;
	ERRORFOUND_WARNINGFOUND_ERRLEVEL_0;
	LINCNT_NLINES_PGSL_0;
%2.25%	NEXTLAB_0;	!INITIALIZE NEXT ADDRESS LABEL NUMBER
%2.9%	!CLEAR LIT TABLE BASE TABLE AND
%2.9%	!LTTRANS BASE TABLE
%2.9%	  DECR I FROM LTNUM-1 TO 0 DO
%2.9%	    LTBASE[.I]_LTTBASE[.I]_0;
	DECR I FROM  PTMASK+1 TO 0 DO PT[.I,0]_PT[.I,1]_0;
        DECR I FROM 31 TO 0 DO GRAPHHEAD[.I]_0;
	DECR I FROM EXPHTSIZE-1 TO 0 DO EXPHT[.I]_0;
        TGRBLEVEL_0;
	MUSTDU_TRBLEVEL_STRDEF_MAPTB_SSTREX_STREXP_INDECS_0;
	VAL_ACCUMLENGTH_MACRODEF_0;
        CHAR_EOL;
	SYM_DEL_FUTSYM_FUTDEL_STRHED_FSTRHED_0;
	UNDECLEX_#300000;
	ENLEX_0;LOC2_0; ETP_-1; ETL_0;
        GTL_OTL_0;
	FREEVHEADER_0;
	LOADECREG_-1;
	OPTTOREGADDR_-1;
	MODLENGTH_0;
	BLOCKLEVEL_1; FCNSTATE_0;
        FUNCTIONLEVEL_NEEDDISP_0;
	NEXTOWN_NEXTGLOBAL_0;
	NOCSAV_0;
	NOPSAV_0;
	NOGBGCOL_NORECVAL_0;
	CURST_CURSTI_STRDEF_0;
	PGM_HEADER(0,0,0);
	PROGRAM_HEADER(0,0,0); PUSHBOT(.PGM,.PROGRAM);
	CODEPTR_HEADER(0,0,0); PUSHBOT(.PROGRAM,.CODEPTR);
	FCNLIST_HEADER(0,0,0);
        PLNEXT_PLBOOL_0;
        PLHEAD_HEADER(2,0,1);
        CT[.PLHEAD,2]<RIGHTHALF>_1;
        ENTHED_LSTART_NUMENT_0;
	VALIDBUF_0;
	PAGE();
	SKAN(1);
	INITSYNTAX();
BEGIN
  MAP MNAM, ACCUM;
  MACRO SPECR(I)=(CASE I OF SET SREG; BREG; FREG; VREG TES)$,
        SYNER(X,Y)=(WARNEM(X,Y); RETURN 1)$,
        LDEL=DEL<LEFTHALF>$;

  LOCAL AVLREG, VALREG, CONTIG;

  MODREGM_RESREGM_0;
  NOSVR_5;
  SREG_BREG_FREG_VREG_-1; %INDICATES NOT YET ALLOCATED%
  STKLEN(0)_STKLEN(1)_0;

  IF .LDEL EQL HMODULE THEN %PROCESS MODULE DECLARATION%
    BEGIN
	MHTIME_1;
      IF (IF .REALFS NEQ 0
            THEN (MNAM[0]_.ST[.REALFS,2];
                  MNAM[1]_.ST[.REALFS,3];
                  HPAROPEN)
            ELSE HROPEN) EQL .FUTDEL<LEFTHALF>
        THEN (HRUND();
              VALREG_SWITCHER(ALLSWL))
        ELSE VALREG_2;
     MHTIME_.TTFLAG;
      IF 0 NEQ (VALREG_
               (CASE .VALREG OF
        SET
           IF .LDEL NEQ HROCLO THEN .NDEL ELSE
           IF .FUTSYM NEQ HEMPTY THEN .NFUTSYM ELSE
           IF .FUTDEL<LEFTHALF> NEQ HEQL THEN .NFUTDEL ELSE 0;
           (-1);
           IF .FUTDEL<LEFTHALF> NEQ HEQL THEN .NFUTDEL ELSE 0;
           .NSYM
        TES))
          THEN %LOOK FOR A BEGIN OR END OF FILE, TTTER BEING
                A TRIVIAL PROGRAM AND THEREFORE RECOMPILABLE%
            (IF .VALREG NEQ -1 THEN WARNEM(.VALREG,ERSYMODBEG);
            WHILE .LDEL NEQ HBEGIN
               DO (HRUND();
                   IF .LDEL EQL HELUDOM OR .FINFLG
                     THEN (ERROR(.NDEL,ERSMNOPROG);
                           RETURN 1));
             WARNEM(.NSYM,ERSYMODBEG))
          ELSE (HRUND(); HRUND());
    END; %MODULE DECLARATION PROCESSING%

  % INITIALIZE REGISTER, LOADER, AND CONTROL IN THAT (CRITICAL) ORDER %

  RGINIT();    LIINIT();    CNINIT();

END;  % END OF REGISTER/STACK INITIALIZATION BLOCK %
  NEXTLOCAL_2+.NOSVR;
	0 END;







%%
%    PROCESS THE "ENTRIES" SWITCH BY LEAVING STE POINTERS IN
  THE LIST "ENTHED".  WRNENT CALLED BY DRIVER TO WARN USER OF
  UNDECLARED ENTRIES.
%
%%

GLOBAL ROUTINE PSWENT=
  BEGIN
    LOCAL STVEC NEWCELL;
    MACRO SYNER(A)=(WARNEM(A,ERSYENTINV); RETURN 1)$;
    
    IF .DEL<LEFTHALF> NEQ HEQL OR
       .FUTSYM NEQ HEMPTY OR
       .FUTDEL<LEFTHALF> NEQ HROPEN
      THEN SYNER(.NDEL);

    HRUND(); ENTHED_HEADER(0,0,0);
    
    DO
      (HRUND();
       IF .SYM<LSF> THEN
         (NEWCELL_GETSPACE(1);
          NEWCELL[0]_.NEWCELL^15+.NEWCELL;
          NEWCELL[1]_.SYM<STEF>;
          NUMENT_.NUMENT+1;
          PUSHBOT(.ENTHED,.NEWCELL))
                    ELSE SYNER(.NSYM))
      WHILE .DEL<LEFTHALF> EQL HCOMMA;

    IF .DEL<LEFTHALF> NEQ HROCLO OR
       .FUTSYM NEQ HEMPTY 
      THEN SYNER(.NDEL);
    HRUND();
    0
  END;


ROUTINE WRNENT=
  BEGIN
    LOCAL STVEC CDR;
    CDR_.CT[.ENTHED,1]<NEXTF>;
    WHILE .CDR NEQ .ENTHED DO 
     (IDERROR(ERSMNOENT,.CDR[1]);
      CDR_.CDR[0]<NEXTF>);
    ERASE(.ENTHED)
  END;



!--------------------------HERE IT IS FOLKS-------------------------

!
!
!              BLISS COMPILER MAIN DRIVER CODE
!             ----------------------------------
!
!




GLOBAL ROUTINE DRIVER=
BEGIN
%2.25%	EXTERNAL OUTPSTRING;
%2.29%	IF .BIO EQL 0 THEN ONCEONLY();
WHILE 1 DO
    BEGIN
    0<0,36>_STACK; 0<18,18>_-#1400; 2<0,36>_.0<0,18>;
    IF NOT REINIT() THEN (EXPRESSION(2);
    WHILE .DEL<LEFTHALF> NEQ HELUDOM AND NOT.FINFLG DO
	( HRUND(); IF .DEL<LEFTHALF> EQL HSEMCOL AND .FUTDEL<LEFTHALF> EQL HELUDOM
		THEN WARNEM(.NDEL,35) ELSE RECOVER(.NDEL,34));
  IF .ERRORFOUND EQL 0 THEN
	BEGIN
        IF .TTFLAG THEN IF .STKLEN(0) NEQ 0 THEN TIMEOUT();
	CONVEY(.SYM);CODE(#47,0,#12,0); CODEPTR_.PROGRAM;
        FNSTAT_(IF .NEEDDISP THEN
          BEGIN
            ACPDT();  %SET UP DISPLAY AND FAKE REGISTERS %
            CODE(PUSH,.SREG,.FREG,0);
            CODE(ADD,.SREG,LITA(LITLEXEME((.NOSVR+1)*#1000001)),0);
            CODEPTR_.PROGRAM;
            0
          END ELSE .NOSVR+1);
          PROMOTE(1^RELC OR 1^CNVEYC); CODEPTR _ .PGM;  FLATFUNC();
	WRITECODE(.PGM);
	LDINT(.PGM);
        IF .ENTHED NEQ 0 THEN WRNENT();
	END;);

%2.25%	IF .MLFLG THEN !OUTPUT DETAILS FOR MACRO-10
%2.25%	BEGIN
%2.25%	MREGSOUT();	!OUTPUT SPECIAL REGISTER DECLARATIONS
%2.25%	MEXTOUT();	!OUTPUT EXTERNAL DECLARATIONS
%2.25%	END;	!OF MACRO-10 DETAILS

%2.25%	MPLITOUT();	!OUTPUT THE PLIT AREA
%2.25%	MCPOUT();	!OUTPUT THE CONSTANT POINER AREA
%2.25%	MLITOUT();	!OUTPUT LITERALS AREA

%2.25%	!NOW WE SWITCH TO LOSEG VIA RELOC PSEUDO-OP IN THE CASE WHERE WE
%2.25%	!ARE GENERATING A TWOSEG PROGRAM.  OTHERWISE WE LEAVE THE LOC
%2.25%	!COUNTER AS IS.

%2.25%	IF .MLFLG THEN	!OUTPUT DETAILS FOR MACRO-10
%2.25%	BEGIN
%2.25%	IF .TWOSEGFLG THEN
%2.25%	  (OUTPSTRING(PLIT (ASCIZ 'RELOC		;TO LOW SEGMENT')); NEWLINE(););
%2.25%	NEWLINE();
%2.25%	OUTPSTRING(PLIT(ASCIZ ';GLOBAL AREA'));  NEWLINE();
%2.25%	MBLKOUT(GNAME<0,0>,.NEXTGLOBAL);	!OUTPUT GLOBAL AREA
%2.25%	NEWLINE();
%2.25%	OUTPSTRING(PLIT(ASCIZ ';OWN AREA'));  NEWLINE();
%2.25%	MBLKOUT(ONAME<0,0>,.NEXTOWN);	!OUTPUT OWN AREA
%2.25%	NEWLINE();
%2.25%	END;
%2.25%	MENDOUT();	!OUTPUT END PSEUDO-OP LINE


    IF .XREFLG THEN XREFWRITE();
    WRITEFINAL();
    FORCE(0); IF NOT .BINFLG THEN FORCE(1); IF NOT .LSTFLG THEN FORCE(2);
    FINIO();
END;
END;
CCLCTL_.(3<0,36>);
DRIVER()





!END OF H3DRIV.BLI
    B
G–