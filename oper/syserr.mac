	TITLE	SYSERR -- SYSTEM ERROR FILE PROCESSOR	OCTOBER 30, 1972	SUBTTL	K. COYE
	SALL


	EXTERNAL .SWSIX,.NAME,.SWDEC,.TSPAC
	EXTERNAL .TFBLK,.SWDTP,.TTIMN,.TTIME,.TDATN,.TDATE,.TCHAR,.CNVDT
	EXTERNAL .ISCAN,.TSCAN,.TCRLF,.CNTDT,.TSTRG,.TOCTW,.TDECW,.TSIXN,.TXWDW


	IFNDEF	ER.WHY	<ER.WHY==1>	;ERROR NUMBER FOR RELOAD
	IFNDEF	ER.MPE	<ER.MPE==3>	;CPU MEM PARITY ERROR
	IFNDEF	ER.CPE	<ER.CPE==6>	;CHANNEL ERROR REPORT
	IFNDEF	ER.DPE	<ER.DPE==10>	;DISK ERROR
	IFNDEF	ER.USC	<ER.USC==40>	;DISK STATISTICS

	ERRSAT==0
	ERRRIB==1
	ERRCHK==2
	ERRINC==3
	ERRHN1==4
	ERRHN2==5
	ERRHN3==6
	ERRHN4==7

	IFNDEF	DV.DSK	<DV.DSK==200000>	;BIT SAYS DEVICE IS DISK IN DEVCHR ARGUEMENT
	IFNDEF	DEBUGA	<DEBUGA=0>	;1 IMPLIES MONITOR OR SYSTEM DEBUGGING
	IFNDEF	PAGLM	<PAGLM==1000>	;MAX # PAGES TO BE OUTPUT ON REPORT EXCLUDING SUMMARY
	IFNDEF	PAGLIN	<PAGLIN==^D50>	;# OF LINES PER PAGE IN LISTING
	IFNDEF	HDRDAT	<HDRDAT==1>	;OFFSET OF DATE WORD IN HEADER
	IFNDEF	HDRUPT	<HDRUPT==2>	;OFFSET OF UPTIME WORD IN HEADER
	IFNDEF	SUBMAX	<SUBMAX==^D6>	;MAX # OF WORD PROCESSORS AVAILABLE
	IFNDEF	LPDL,	<LPDL==40>	;PUSHDOWN LIST LENGTH
	IFNDEF	WKSIZE,	<WKSIZE==40>	;SIZE OF WORKING BUFFER
	IFNDEF	HDSIZE,	<HDSIZE==6>	;ALLOW FOR FUTURE HEADER EXPANSION
	IFNDEF	.RBCNT,	<.RBCNT==0>	;COUNT OF ARGS FOLLOWING IN EXTENDED LOOKUP
	IFNDEF	.RBPPN,	<.RBPPN==1>	;REL LOCATION OF PPN IN LOOKUP BLOCK
	IFNDEF	.RBNAM,	<.RBNAM==2>	;REL LOCATION OF FILENAME IN LOOKUP BLOCK
	IFNDEF	.RBEXT,	<.RBEXT==3>	;REL LOCATION OF EXTENSION IN LOOKUP BLOCK
	IFNDEF	.RBSIZ	<.RBSIZ==5>	;REL LOCATION OF FILE SIZE IN WDS
	IFNDEF	.RBTIM,	<.RBTIM==35>	;REL LOCATION OF NBS CREATION DATE/TIME WORD
					;FOR EXTENDED LOOKUP
	;DEFINITIONS OF WORDS FOUND IN EACH TYPE OF ENTRY
	;FIRST THREE CHARACTER REPRESENT ERROR TYPE
	;LAST THREE REPRESENT LAST THREE CHARACTERS OF MONITOR SYMBOL
	RADIX	10		;*************** NOTE WELL *************

	;ERROR CODE 1	ER.WHY

	IFNDEF	WHYFG0,	<WHYFG0==0>
	IFNDEF	WHYDT0,	<WHYDT0==5>
	IFNDEF	WHYSTS,	<WHYSTS==7>
	IFNDEF	WHYVER,	<WHYVER==8>
	IFNDEF	WHYSER,	<WHYSER==9>
	IFNDEF	WHYWHY,	<WHYWHY==10>
	IFNDEF	WHACOM,	<WHACOM==11>	;AOB POINTER TO OPR COMMENTS

	;ERROR CODE 3	ER.MPE

	IFNDEF	MPEPHY,	<MPEPHY==0>
	IFNDEF	MPETPE,	<MPETPE==1>
	IFNDEF	MPESPE,	<MPESPE==2>
	IFNDEF	MPEMPC,	<MPEMPC==3>
	IFNDEF	MPEMPP,	<MPEMPP==4>
	IFNDEF	MPEMPW,	<MPEMPW==5>
	IFNDEF	MPEMPA,	<MPEMPA==6>
	IFNDEF	MPAPAR,	<MPAPAR==7>	;AOB POINTER TO %CCPAR TABLE
	IFNDEF	MPAMPT,	<MPAMPT==8>	;AOB POINTER TO %CCMPT TABLE

	;VALUES IN %CCPAR TABLE

	IFNDEF	MPELPA,	<MPELPA==0>
	IFNDEF	MPEMPR,	<MPEMPR==1>
	IFNDEF	MPEPTS,	<MPEPTS==2>
	IFNDEF	MPEPSC,	<MPEPSC==3>
	IFNDEF	MPEUEP,	<MPEUEP==4>
	IFNDEF	MPEPAA,	<MPEPAA==5>
	IFNDEF	MPEPAC,	<MPEPAC==6>
	IFNDEF	MPEPOA,	<MPEPOA==7>
	IFNDEF	MPEPOC,	<MPEPOC==8>
	IFNDEF	MPEPCS,	<MPEPCS==9>

	;ERROR CODE 6	ER.CPE

	IFNDEF	CPENAM,	<CPENAM==0>
	IFNDEF	CPENXM,	<CPENXM==1>
	IFNDEF	CPEMPE,	<CPEMPE==2>
	IFNDEF	CPEDPE,	<CPEDPE==3>
	IFNDEF	CPEICW,	<CPEICW==4>
	IFNDEF	CPEFCW,	<CPEFCW==5>
	IFNDEF	CPECW2,	<CPECW2==6>
	IFNDEF	CPECW1,	<CPECW1==7>
	IFNDEF	CPECW0,	<CPECW0==8>
	IFNDEF	CPEDW2,	<CPEDW2==9>
	IFNDEF	CPEDW1,	<CPEDW1==10>
	IFNDEF	CPEDW0,	<CPEDW0==11>


	;ERROR CODE 10	ER.DPE

	IFNDEF	HDENAM,	<HDENAM==0>
	IFNDEF	HDEHID,	<HDEHID==1>
	IFNDEF	HDEHCT,	<HDEHCT==2>
	IFNDEF	HDESCT,	<HDESCT==3>
	IFNDEF	HDEECT,	<HDEECT==4>
	IFNDEF	HDESOF,	<HDESOF==5>
	IFNDEF	HDEERR,	<HDEERR==6>
	IFNDEF	HDESDI,	<HDESDI==7>
	IFNDEF	HDEHDI,	<HDEHDI==8>
	IFNDEF	HDEHBN,	<HDEHBN==9>
	IFNDEF	HDEMCT,	<HDEMCT==10>
	IFNDEF	HDEPCT,	<HDEPCT==11>
	IFNDEF	HDEHNG,	<HDEHNG==12>
	IFNDEF	HDETRC,	<HDETRC==13>
	IFNDEF	HDETWC,	<HDETWC==14>
	IFNDEF	HDETSC,	<HDETSC==15>
	IFNDEF	HDEDCR,	<HDEDCR==16>


	;ERROR CODE 40	ER.USC

	IFNDEF	USCNAM,	<USCNAM==0>
	IFNDEF	USCHID,	<USCHID==1>
	IFNDEF	USCHCT,	<USCHCT==2>
	IFNDEF	USCSCT,	<USCSCT==3>
	IFNDEF	USCPCT,	<USCPCT==4>
	IFNDEF	USCHNG,	<USCHNG==5>
	IFNDEF	USCMCT,	<USCMCT==6>
	IFNDEF	USCBRC,	<USCBRC==7>
	IFNDEF	USCBWC,	<USCBWC==8>
	IFNDEF	USCDRC,	<USCDRC==9>
	IFNDEF	USCDWC,	<USCDWC==10>
	IFNDEF	USCMRC,	<USCMRC==11>
	IFNDEF	USCMWC,	<USCMWC==12>
	IFNDEF	USCICT,	<USCICT==13>
	IFNDEF	USCOCT,	<USCOCT==14>
	IFNDEF	USCMSC,	<USCMSC==15>
	IFNDEF	USCUSC,	<USCUSC==16>
	RADIX	8		;RETURN TO DEFAULT

	ER.HIA==377		;DAEMON FILE ERROR CODE
	ER.EOF==777		;DAEMON EOF MARKER CODE




	;AC CONVENTIONS

	F=0		;FLAG REGISTER

	T1=F+1		;TEMP AC'S
	T2=T1+1
	T3=T2+1
	T4=T3+1

	P1=T4+1		;AC'S PRESERVED ACROSS SUBROUTINE CALLS
	P2=P1+1
	P3=P2+1
	P4=P3+1

	MASTWD=P4+1		;USED FOR WORD RETURNED BY GETWD ROUTINE

	WKINDX=MASTWD+1		;INDEX INTO WORKING BUFFER

	CTINDX=WKINDX+1
	S=CTINDX+1		;SOFTWARE STATUS ERROR REGISTER LIKE CONI WORD FOR SOFTWARE
	P=17

	;STATUS FLAGS IN LH OF F

	F.DATE==400000		;USER HAS TYPED DATE CONSTRAINTS IF NON-ZERO
	F.READ==200000		;WORKING BUFFER IS IN THE PROCESS OF
				;BEING FILLED. EOF IS AN ERROR INDICATION
	F.TTYO==100000		;OUTPUT TO TTY IF NON-ZERO, ELSE TO BUFFER
	F.BTCK==40000		;PERFORM CHECKING ON ENTRY TO DETERMINE
	F.LSUM==20000		;PERFORM SUMMARY LISTING
				;WHETHER TO LIST OR NOT
	F.ONCE==10000		;FLAG SET TO SAY "ONCE-ONLY" CODE DONE
	F.JFFO==4000		;FLAG SET TO SAY TEXT-BIT SEEN IN JFLOOP ROUTINE
	F.DEV==2000		;FLAG SET TO INDICATE USER SPECIFIED /DEV SWITCH
	F.CHNG==1000		;FLAG TO INDICATE SYSTER ERROR COUNTERS HAVE CHANGED
	F.DISK==400		;FLAG SAYING INPUT DEVICE IS DISK
	F.SAWD==200		;FLAG SET TO SAY WE SAY A NON-ZERO DIGIT IN TYPE4 ROUTINE

	;STATUS FLAGS IN LH OF S

	S.SAT==400000		;SAT FAILURE
	S.RIB==200000		;RIB ERROR
	S.CHK==100000		;CHECKSUM ERROR
	S.SINC==40000		;SEEK INCOMPLETE ERROR
	S.HNG1==20000		;NON-RECOVERABLE CONTROLLER HANG
	S.HNG2==10000		;RECOV XFER HANG
	S.HNG3==4000		;RECOV SEEK HANG
	S.HNG4==2000		;RECOV SOFTWARE HANG
	;STATUS FLAGS IN LH OF ENTRY CHARACTERISTICS WORD

	E.LALL==400000		;SAYS LIST THIS ENTRY IN ALL CASES
	E.LNXM==200000		;SAYS LIST THIS ENTRY IF CAUSED BY A NON-EXISTANT MEMORY
	E.LPAR==100000		;SAYS LIST IF CAUSED BY PARITY ERROR
	E.LPER==40000		;SAYS LIST IF PERFORMANCE DATA ENTRY
	E.LSUM==20000		;SAYS DO SUMMATION OF ENTRY
	;STATUS FLAGS IN RH OF ENTRY CHARACTERISTICS WORD
	E.RCNT==000377		;COUNT OF # OF TIMES ENTRY TYPE PROCESSED

	ERRHRD==200000		;BIT IN HDEECT SIGNIFING HARD ERROR IF 1

	;CHANNEL ASSIGNMENTS

	INPCHN==1
	OUTCHN==2
;HERE LIES THE MACRO DEFINITIONS

	OPDEF	PJRST [JRST]


	DEFINE	FATAL (A) <JRST	[OUTSTR	[ASCIZ/? A
/]
		EXIT]
>

	DEFINE	WARN (A)	<OUTSTR	[ASCIZ/% A
/]>

	DEFINE	LOOP (A,B) <JRST	[OUTSTR	[ASCIZ/A
/]
	JRST	<B>
]>

	DEFINE	TYPEIT(A)<
	MOVEI	T1,[ASCIZ\A\]
	PUSHJ	P,.TSTRG
>



	DEFINE	SINDEX (A) <
	A==.-SUBTAB
	JRST	<.'A>
>
	SUBTTL	DUMMY MACRO DEFINITIONS
	;DUMMY MACROS -- PRIOR TO THE DEFINITION OF THE DUMMY MACROS
	;USED IN THIS PROGRAM A REFRESHER ON DUMMY MACROS MAY BE IN ORDER.
	;	DUMMY MACROS ARE USED TO HOLD SUBMACROS TO BE REDEFINED
	;AS REQUIRED AT A LATER TIME AND THEN CALLED. THE ASSEMBLER REPLACES
	;THE MACRO WITH IT'S SUBMACRO CALLS AND THEN IN TURN GENERATES THE
	;REQUIRED CODE PER THE SUBMACRO DEFINITION.

	;DUMENT -- DUMMY MACRO LEVEL 2
	;SUBMACRO TBLENT
	;ARGS
	;A-ERROR CODE
	;B-ERROR DESCRIPTION
	;C-ENTRY LEVEL CONTROL TABLE ADDRESS (.CTXXX,0)
	;D-ENTRY LEVEL PROCESSOR ADDRESS
	;E-# OF LINES OF OUTPUT GENERATED BY THIS ENTRY EXCLUDING HEADER
	;COMMENT.. THIS MACRO MUST CONTAIN UNKNOWN ENTRIES UP
	;TO THE LARGEST KNOWN ENTRY IN NUMERIC SEQUENCE

	DEFINE	DUMENT	<
	TBLENT	(0,UNKNOWN TYPE,0,DMPENT,40)
	TBLENT	(1,SYSTEM RELOADED,.CT001,PROCSA,20)
	TBLENT	(2,UNKNOWN TYPE,0,DMPENT,40)
	TBLENT	(3,CPU MEM PAR ERR,.CT003,PROCSA,43)
	TBLENT	(4,UNKNOWN TYPE,0,DMPENT,40)
	TBLENT	(5,UNKNOWN TYPE,0,DMPENT,40)
	TBLENT	(6,DATA CHANNEL ERR,.CT006,PROCSA,20)
	TBLENT	(7,UNKNOWN TYPE,0,DMPENT,40)
	TBLENT	(10,DISK UNIT ERROR,.CT010,PROCSA,24)
	TBLENT	(11,UNKNOWN TYPE,0,DMPENT,40)
	TBLENT	(12,UNKNOWN TYPE,0,DMPENT,40)
	TBLENT	(13,UNKNOWN TYPE,0,DMPENT,40)
	TBLENT	(14,UNKNOWN TYPE,0,DMPENT,40)
	TBLENT	(15,UNKNOWN TYPE,0,DMPENT,40)
	TBLENT	(16,UNKNOWN TYPE,0,DMPENT,40)
	TBLENT	(17,UNKNOWN TYPE,0,DMPENT,40)
	TBLENT	(20,UNKNOWN TYPE,0,DMPENT,40)
	TBLENT	(21,UNKNOWN TYPE,0,DMPENT,40)
	TBLENT	(22,UNKNOWN TYPE,0,DMPENT,40)
	TBLENT	(23,UNKNOWN TYPE,0,DMPENT,40)
	TBLENT	(24,UNKNOWN TYPE,0,DMPENT,40)
	TBLENT	(25,UNKNOWN TYPE,0,DMPENT,40)
	TBLENT	(26,UNKNOWN TYPE,0,DMPENT,40)
	TBLENT	(27,UNKNOWN TYPE,0,DMPENT,40)
	TBLENT	(30,UNKNOWN TYPE,0,DMPENT,40)
	TBLENT	(31,UNKNOWN TYPE,0,DMPENT,40)
	TBLENT	(32,UNKNOWN TYPE,0,DMPENT,40)
	TBLENT	(33,UNKNOWN TYPE,0,DMPENT,40)
	TBLENT	(34,UNKNOWN TYPE,0,DMPENT,40)
	TBLENT	(35,UNKNOWN TYPE,0,DMPENT,40)
	TBLENT	(36,UNKNOWN TYPE,0,DMPENT,40)
	TBLENT	(37,UNKNOWN TYPE,0,DMPENT,40)
	TBLENT	(40,DISK STATISTICS,.CT040,PROCSA,40)
>
	;DUMALL -- DUMMY MACRO LEVEL 3
	;SUBMACRO DUMXXX
	;ARGS
	;NONE USED TO HOUSE LEVEL 2 SUBMACRO DUMXXX

	DEFINE	DUMALL<
	DUM001
	DUM003
	DUM006
	DUM010
	DUM040
>

	;DUM001 -- DUMMY MACRO LEVEL 2
	;SUBMACRO TBLWRD
	;ARGS
	;A-ERROR CODE
	;B-LOCATION OF AOBJ POINTER IN ENTRY WITH REFERENCE TO WORD 0 OF BODY OF ENTRY
	;C-OFFSET OF WORD IN BODY OF ENTRY OR WITH RESPECT TO AOBJ POINTER
	;	IF C ABOVE IS NOT 0
	;D-WORD LEVEL PROCESSOR TYPE
	;E-OREDR OF LISTING
	;F-ASCIZ TEXT TO TYPEOUT OR ADDRESS OF SPECIAL ROUTINE IF D= SPECL
	DEFINE	DUM001<
	TBLWRD	(1,0,WHYFG0,ASCIE,1,<CONFIGURATION INFORMATION
	SYSTEM	NAME:		>)
	TBLWRD	(1,0,WHYDT0,ASCIE,2,<	MONITOR BUILT ON:	>)
	TBLWRD	(1,0,WHYSER,DECML,3,<	CPU SERIAL #:		>)
	TBLWRD	(1,0,WHYSTS,HAFWD,4,<	STATES WORD:		>)
	TBLWRD	(1,0,WHYVER,SPECL,5,<MONVER>)
	TBLWRD	(1,0,WHYWHY,SIXBT,6,<
RELOAD BREAKDOWN
	CAUSE:			>)
	TBLWRD	(1,WHACOM,0,ASCIE,7,<	COMMENTS		>)
>

	DEFINE	DUM003<
	TBLWRD	(3,0,MPEPHY,SIXBT,1,<PARITY ERROR TOTALS FOR >)
	TBLWRD	(3,0,MPETPE,DECML,2,<	REPRODUCIBLE:		>)
	TBLWRD	(3,0,MPESPE,DECML,3,<	NON-REPRODUCIBLE:	>)
	TBLWRD	(3,MPAPAR,MPEUEP,DECML,4,<	USER ENABLED:		>)
	TBLWRD	(3,MPAPAR,MPEPSC,DECML,5,<	CORE SWEEPS:		>)
	TBLWRD	(3,MPAPAR,MPEPCS,DECML,6,<	DETECTED BY DATA
	 CHANNEL BUT NOT
	 SEEN BY CPU:		>)
	TBLWRD	(3,0,MPEMPC,DECML,7,<	OPR CONTINUES AFTER PE:	>)
	TBLWRD	(3,0,MPEMPA,HAFWD,8,<
INFORMATION FROM LAST CORE SWEEP
	PHYSICAL ADD OF PE:	>)
	TBLWRD	(3,MPAPAR,MPEMPR,HAFWD,9,<	RELATIVE ADD OF PE:	>)
	TBLWRD	(3,0,MPEMPW,HAFWD,10,<	CONTENTS OF BAD WORD:	>)
	TBLWRD	(3,MPAPAR,MPELPA,HAFWD,11,<	PHYSICAL ADD OF LAST
	 PE SEEN DURING SWEEP:	>)
	TBLWRD	(3,0,MPEMPP,HAFWD,12,<	PC WORD AT TIME OF PE:	>)
	TBLWRD	(3,MPAPAR,MPEPTS,DECML,13,<	# PE SEEN ON THIS SWEEP:>)
	TBLWRD	(3,MPAPAR,MPEPAA,HAFWD,14,<
BOOLEAN ERROR COMPARISONS
	"AND" OF PE ADDRESSES:	>)
	TBLWRD	(3,MPAPAR,MPEPOA,HAFWD,15,<	"OR" OF PE ADDRESSES:	>)
	TBLWRD	(3,MPAPAR,MPEPAC,HAFWD,16,<	"AND" OF WORD CONTENTS:	>)
	TBLWRD	(3,MPAPAR,MPEPOC,HAFWD,17,<	"OR" OF WORD CONTENTS:	>)
	TBLWRD	(3,MPAMPT,0,SPECL,18,<BADADD>)
>

	DEFINE	DUM006<
	TBLWRD	(6,0,CPENXM,DECML,1,<DATA CHANNEL ERROR TOTALS
	NXM'S AND OVERRUNS:	>)
	TBLWRD	(6,0,CPEMPE,DECML,2,<	MEM PE SEEN BY CHANNEL:	>)
	TBLWRD	(6,0,CPEDPE,DECML,3,<	CONTROLLER DATA PE:	>)
	TBLWRD	(6,0,CPENAM,SIXBT,4,<
CHANNEL COMMAND LIST BREAKDOWN
	DEVICE	USING CHANNEL:	>)
	TBLWRD	(6,0,CPEICW,HAFWD,5,<	INITIAL CONTROL WORD:	>)
	TBLWRD	(6,0,CPEFCW,HAFWD,6,<	TERMINATION WD WRITTEN:	>)
	TBLWRD	(6,0,CPECW2,SPECL,7,<CHNDCD>)
	TBLWRD	(6,0,CPEDW2,HAFWD,8,<	3RD FROM LAST DATA WORD:>)
	TBLWRD	(6,0,CPEDW1,HAFWD,9,<	2ND FROM LAST DATA WORD:>)
	TBLWRD	(6,0,CPEDW0,HAFWD,10,<	LAST DATA WORD XFERRED:	>)
>


	DEFINE	DUM010<
	TBLWRD	(10,0,HDENAM,SIXBT,1,<DISK PARAMETERS
	UNIT NAME:		>)
	TBLWRD	(10,0,HDEHID,SIXBT,2,<	PACK IDENTIFICATION:	>)
	TBLWRD	(10,0,HDEDCR,SPECL,3,<ERDIAG>)
	TBLWRD	(10,0,HDEHCT,SPECL,4,<HARDER>)
	TBLWRD	(10,0,HDESCT,SPECL,5,<SOFTER>)
	TBLWRD	(10,0,HDEPCT,SPECL,6,<SEKINC>)
	TBLWRD	(10,0,HDEMCT,SPECL,7,<SOFDET>)
	TBLWRD	(10,0,HDEHNG,SPECL,8,<SOFHNG>)
	TBLWRD	(10,0,HDEHBN,SPECL,9,<LBNDCD>)
	TBLWRD	(10,0,HDESOF,SPECL,10,<CN1DCD>)
	TBLWRD	(10,0,HDEERR,SPECL,11,<CN2DCD>
	TBLWRD	(10,0,HDESDI,HAFWD,12,<	DATAI AT ERROR TIME:	>)
	TBLWRD	(10,0,HDEHDI,HAFWD,13,<	DATAI AT RECAL TIME:	>)
	TBLWRD	(10,0,HDEECT,SPECL,14,<RETRYS>)
	TBLWRD	(10,0,HDETRC,SPECL,15,<DISKPR>)
>


	DEFINE	DUM040<
	TBLWRD	(40,0,USCNAM,SIXBT,1,<DISK PARAMETERS
	UNIT	NAME:		>)
	TBLWRD	(40,0,USCHID,SIXBT,2,<	PACK IDENTIFICATION:	>)
	TBLWRD	(40,0,USCHCT,SPECL,3,<HARDER>)
	TBLWRD	(40,0,USCSCT,SPECL,4,<SOFTER>)
	TBLWRD	(40,0,USCMCT,SPECL,5,<SOFDET>)
	TBLWRD	(40,0,USCHNG,SPECL,6,<SOFHNG>)
	TBLWRD	(40,0,USCPCT,DECML,7,<	SEEK INCOMPLETES:	>)
	TBLWRD	(40,0,USCBRC,DECML,8,<
DISK PERFORMANCE TOTALS
	BUFFERRED READS:	>)
	TBLWRD	(40,0,USCBWC,DECML,9,<	BUFFERRED WRITES:	>)
	TBLWRD	(40,0,USCDRC,DECML,10,<	DUMP READS:		>)
	TBLWRD	(40,0,USCDWC,DECML,11,<	DUMP WRITES:		>)
	TBLWRD	(40,0,USCMRC,DECML,12,<	MONITOR READS:		>)
	TBLWRD	(40,0,USCMWC,DECML,13,<	MONITOR WRITES:		>)
	TBLWRD	(40,0,USCICT,DECML,14,<	SWAP READS:		>)
	TBLWRD	(40,0,USCOCT,DECML,15,<	SWAP WRITES:		>)
	TBLWRD	(40,0,USCMSC,DECML,16,<	MONITOR SEEKS:		>)
	TBLWRD	(40,0,USCUSC,DECML,17,<	USER SEEKS:		>)
>

	;DUMCH1 -- DUMMY MACRO LEVEL 2
	;SUBMACRO TBLCH1
	;ARGS
	;A-SWITCH ASSOCIATED WITH ENTRY
	;B-ERROR CODES TO ALWAYS LIST IF THIS SWITCH SEEN
	;C-ERROR CODES TO LIST IF CAUSED BY NXM
	;D-ERROR CODES TO LIST IF CAUSED BY PARITY ERROR
	;E-ERROR CODES TO LIST IF CAUSED BY PERFORMANCE REPORTS
	;F-ERROR CODES TO SUMMATE IF SWITCH SEEN
	;G-RELATIVE POSITION OF LINE IN THIS TABLE



	DEFINE	DUMCH1<
	TBLCH1	(ALL,<1,3,6,10,40>,0,0,0,<1,3,6,10,40>,0)
	TBLCH1	(ALLNXM,0,6,0,0,0,1)
	TBLCH1	(ALLPAR,3,0,6,0,0,2)
	TBLCH1	(ALLPER,<1,40>,0,0,0,0,3)
	TBLCH1	(ALLSUM,0,0,0,0,<1,3,6,10,40>,4)
	TBLCH1	(CHNALL,6,0,0,0,6,5)
	TBLCH1	(CHNNXM,0,6,0,0,0,6)
	TBLCH1	(CHNPAR,0,0,6,0,0,7)
	TBLCH1	(CHNSUM,0,0,0,0,6,8)
	TBLCH1	(CPUALL,<1,3>,0,0,0,<1,3>,9)
	TBLCH1	(CPUPAR,3,0,0,0,0,10)
	TBLCH1	(CPUPER,1,0,0,0,0,11)
	TBLCH1	(CPUSUM,0,0,0,0,<1,3>,12)
	TBLCH1	(DSKALL,<10,40>,0,0,0,<10,40>,13)
	TBLCH1	(DSKPAR,0,0,10,0,0,14)
	TBLCH1	(DSKPER,40,0,0,0,0,15)
	TBLCH1	(DSKSUM,0,0,0,0,<10,40>,16)
>



	;DUMCH2 -- DUMMY MACRO LEVEL 2
	;SUBMACRO TBLCH2
	;ARGS
	;A-SWITCH NAME
	;B-PROCESSING ROUTINE ADDRESS
	;C-DEFAULT NAME (OPTIONAL)

	DEFINE	DUMCH2<
	TBLCH2	(BEGIN,.SWDTP,)
	TBLCH2	(END,.SWDTP,)
	TBLCH2	(DEV,.SWSIX,)
>

	;DUMFLG -- DUMMY MARCO LEVEL 2
	;SUBMACRO TBLFLG
	;ARGS
	;A-SUMMARY COUNTER PREFIXES

	DEFINE	DUMFLG<
	TBLFLG	(NXM)
	TBLFLG	(MPE)
	TBLFLG	(DPE)
	TBLFLG	(HDE)
	TBLFLG	(HDT)
	TBLFLG	(SDE)
	TBLFLG	(SDT)
	TBLFLG	(RED)
	TBLFLG	(WRT)
	TBLFLG	(SEK)
	TBLFLG	(TPE)
	TBLFLG	(SPE)
	TBLFLG	(UEP)
	TBLFLG	(PCS)
>
	;DUMDVA -- DUMMY MARCO LEVEL 3
	;SUBMACRO DUMXXX
	;SUBMACRO DUMDV
	;ARGS
	;A-DEVICE NAME

	DEFINE	DUMDVA<
	DUMDPA
	DUMDPB
	DUMFHA
	DUMFHB
>

	DEFINE	DUMDPA<
	DUMDV	(DPA0)
	DUMDV	(DPA1)
	DUMDV	(DPA2)
	DUMDV	(DPA3)
	DUMDV	(DPA4)
	DUMDV	(DPA5)
	DUMDV	(DPA6)
	DUMDV	(DPA7)
>

	DEFINE	DUMDPB<
	DUMDV	(DPB0)
	DUMDV	(DPB1)
	DUMDV	(DPB2)
	DUMDV	(DPB3)
	DUMDV	(DPB4)
	DUMDV	(DPB5)
	DUMDV	(DPB6)
	DUMDV	(DPB7)
>


	DEFINE	DUMFHA<
	DUMDV	(FHA0)
	DUMDV	(FHA1)
	DUMDV	(FHA2)
	DUMDV	(FHA3)
>

	DEFINE	DUMFHB<
	DUMDV	(FHB0)
	DUMDV	(FHB1)
	DUMDV	(FHB2)
	DUMDV	(FHB3)
>
	;DUMSF1 -- DUMMY MACRO LEVEL 2
	;SUBMACRO TBLDEV
	;ARGS
	;A-ERROR BIT # IN CONI WORD OF DUMMY SOFTWARE DEVICE
	;B-TEXT DESCRIPTION OF BIT

	DEFINE	DUMSF1<
	TBLDEV	(0,<SAT BLOCK DISCREPANCY>)
	TBLDEV	(1,<RETRIVAL BLOCK INFORMATION ERR>)
	TBLDEV	(2,<CHECKSUM ERR>)
	TBLDEV	(3,<SEEK INCOMPLETE ERR>)
	TBLDEV	(4,<NON-RECOVERABLE CONTROLLER HANG>)
	TBLDEV	(5,<RECOVERABLE TRANSFER HANG>)
	TBLDEV	(6,<RECOVERABLE SEEK HANG>)
	TBLDEV	(7,<RECOVERABLE SOFTWARE HANG>)
>
	;DUMRC1 -- DUMMY MACRO LEVEL 2
	;SUBMACRO TBLDEV
	;ARGS
	;A-CONI ERROR BIT FROM RC10
	;B-TEXT DESCRIPTION

	DEFINE	DUMRC1<
	TBLDEV	(19,<SEARCH ERR>)
	TBLDEV	(20,<TWO UNITS SELECTED AS SAME LOGICAL UNIT>)
	TBLDEV	(21,<TRACK/SECTOR NOT BCD>)
	TBLDEV	(22,<NOT READY>)
	TBLDEV	(23,<POWER FAIL>)
	TBLDEV	(24,<SECTOR PAR ERR>)
	TBLDEV	(25,<MEMORY PAR ERR>)
	TBLDEV	(26,<CTL WORD PAR ERR>)
	TBLDEV	(27,<NXM>)
	TBLDEV	(28,<ILLEGAL WRITE>)
	TBLDEV	(29,<OVERUN>)
>
	;DUMRP1 -- DUMMY MACRO LEVEL 2
	;SUBMACRO TBLDEV
	;ARGS
	;A-ERROR BIT IN RP10 CONI WORD
	;B-TEXT DESCRIPTION

	DEFINE	DUMRP1<
	TBLDEV	(14,<CTL WORD PAR ERR>)
	TBLDEV	(15,<SECTOR PAR ERR>)
	TBLDEV	(16,<MEMORY PAR ERR>)
	TBLDEV	(17,<DISK WORD PAR ERR>)
	TBLDEV	(20,<POWER FAIL>)
	TBLDEV	(21,<SEARCH ERR>)
	TBLDEV	(22,<OVERUN>)
	TBLDEV	(23,<NXM>)
	TBLDEV	(25,<NOT READY>)
	TBLDEV	(26,<ILLEGAL WRITE>)
	TBLDEV	(27,<ILLEGAL DATAO>)
	TBLDEV	(28,<SECTOR ADDRESS ERR>)
	TBLDEV	(29,<SURFACE ADDRESS ERR>)
>
	SUBTTL	MAINLINE PROGRAM CODE
	VWHO==0
	VSYSER==2
	VMINOR==0
	VEDIT==1

	.JBVER==137
	LOC	.JBVER

	BYTE	(3)VWHO(9)VSYSER(6)VMINOR(18)VEDIT


	TWOSEG
LOWBEG:		;LOW SEGMENT WILL RESIDE HERE
	RELOC	400000

	;START -- MAINLINE PROGRAM CODE BEGINS HERE
	;SETS UP DEFAULT FILE ARGUEMENTS
	;INITIALIZES PUSHDOWN LIST
	;CLEARS WORKING STORAGE LOCATIONS

START:	RESET

	SETZ	F,		;CLEAR STATUS AC
	TLO	F,F.LSUM	;INITIALIZE TO GIVE SUMMARY BY DEFAULT
	MOVE	P,PDLPNT	;SETUP PUSHDOWN POINTER



	;INITIALIZE THE STORAGE LOCATIONS TO 0

	MOVE	T1,[XWD LOWBEG,LOWBEG+1]	;SETUP
	SETZM	LOWBEG
	BLT	T1,LOWEND	;DONE

	MOVE	T1,[XWD FLGST,FLGST+1]	;SETUP TO INITIALIZE SWITCH STORAGE LOCATIONS TO -1
	SETOM	FLGST
	BLT	T1,FLGND	;ALL NOW = -1

	MOVE	T1,[XWD	INPSPC,INPBLK]	;SETUP TO XFER DEFAULT FILE ARGS
	BLT	T1,BLTEND	; DO IT!


	;FALL INTO SYSINF ROUTINE
	;SYSINF -- ROUTINE TO GET SYSTEM INFORMATION
	;DATE,DAYTIME

SYSINF:	MOVE	T1,[XWD 11,11]	;PICKUP TODAYS DATE IN 12 BIT FORMAT
	GETTAB	T1,
	WARN	<CAN'T GET TODAYS DATE FROM MONITOR>
	MOVEM	T1,.DATE

	MSTIME	T1,		;PICKUP SYSTEM TIME IN MILLISEC
	MOVEM	T1,.TIME

	;INICHR -- ROUTINE TO INITIALIZE THE ENTRY CHARACTERISTICS TABLE

INICHR:	MOVE	T1,[XWD ENTCHR,ENTCHR+1]
	HRLZI	T2,E.LSUM	;DEFAULT TO LIST SUMMARY ONLY
	MOVEM	T2,ENTCHR
	BLT	T1,CHREND	;E.LSUM BIT SET THROUGHOUT TABLE

	PUSHJ	P,DIALOG	;GO TALK TO USER
	PUSHJ	P,SETDAT	;GO SEE IF USER TYPED /BEFORE OR /AFTER

	;FALL INTO FILACT ROUTINE
LACT -- ROUTINE TO PERFORM PRELIMINARY FILE ACTIVITY
	;DOES OPEN FOR INPUT, OUTPUT DEV
	;DOES LOOKUP FOR INPUT FILE
	;DOES ENTER FOR OUTPUT FILE
	;DEFAULTS
	;DEVICE-DSK
	;FILE-INPUT-ERROR.SYS
	;    -OUTPUT-ERROR.LST
	;PPN-USERS OWN

FILACT:	OPEN	INPCHN,INPBLK	;OPEN INPUT DEV SPECIFIED IN DIALOG
	FATAL	<CAN'T OPEN INPUT DEVICE>

	OPEN	OUTCHN,OUTBLK	;OPEN OUTPUT DEV SPECIFIED IN DIALOG
	FATAL	<CAN'T OPEN OUTPUT DEVICE>


	MOVEI	T1,INPCHN	;SETUP FOR DEVCHR CALL
	DEVCHR	T1,
	TLNN	T1,DV.DSK	;IS IT A DISK
	JRST	SHRTLK		;NO DO SHORT LOOKUP
LONGLK:	LOOKUP	INPCHN,INPFIL	;LOOK FOR ERROR FILE (DEFAULT IS ERROR.SYS)
	FATAL	<LOOKUP ERROR ON INPUT FILE>
	TLO	F,F.DISK	;REMEMBER IT WAS A DISK
	JRST	DOENTR		;NOW GO DO ENTER

SHRTLK:	LOOKUP	INPCHN,INPFIL+2	;FUDGE SHORT LOOKUP
					;NOTE THAT PPN WAS PUT IN .RBSIZ
					;TO ALLOW THIS
	FATAL	<LOOKUP ERROR ON INPUT FILE>

DOENTR:	ENTER	OUTCHN,OUTFIL	;GET READY FOR OUTPUT LISTING
	FATAL	<ENTER ERROR ON OUTPUT FILE>

	MOVE	T1,INPFIL+.RBTIM	;PICKUP CREATION DATE/TIME IN NBS FORMAT
	MOVEM	T1,FILDAT	;SAVE IT

	;FALL INTO HEADRD ROUTINE
	;HEADRD -- ROUTINE TO VERIFY HEADER SECTION OF ENTRY
	;AND XFER HEADER TO HDBUFF
	;BODY OF ENTRY TO WKBUFF
	;THEN DISPATCH TO ENTRY PROCESSOR

HEADRD:	TLZ	F,F.TTYO	;SAY PUT ALL CHARS IN OUTPUT BUFFER
ABORT:	MOVE	P,PDLPNT	;RESET PDL STACK POINTER
	TLZ	F,F.READ	;CLEAR READING FLAG AND NAME FLAG
	SETZ	S,		;CLEAR SOFTWARE ERROR BITS
CLRBUF:	SETZM	WKBUFF		;PREPARE TO CLEAR WORKING BUFFER
	MOVE	T1,[XWD	WKBUFF,WKBUFF+1]
	BLT	T1,WKBUFF+WKSIZE-1	;ZAP
	MOVE	T1,[XWD HDBUFF,HDBUFF+1]	;SETUP TO ZAP HEADER BUFFER
	SETZM	HDBUFF
	BLT	T1,HDBUFF+HDSIZE-1	;ZAP

GETWD0:	PUSHJ	P,GETWD		;GET WORD 0 OF ENTRY
EOFTRY:	LDB	T1,[POINT 9,MASTWD,8]	;PICKUP ENTRY TYPE
						;ALSO ENTRY FOR POST EOF CODE
	MOVEM	T1,ERTYPE

FILCHK:	CAIN	T1,ER.HIA	;DID DAEMON SEE FILE ERROR
	JRST	FILERR		;YUP

EOFCHK:	CAIN	T1,ER.EOF	;IS THIS THE END OF ERROR FILE
	JRST	EOFVER		;WORD WAS WRITTEN IN FILE TO INDICATE EOF
	CAILE	T1,TYPMAX	;DO I RECOGNIZE THIS TYPE OF ENTRY
	PUSHJ	P,VOIDTY	;NO DUMP IT FOR USER AND TELL HIM
	MOVEM	MASTWD,HDBUFF	;STORE WD0 OF HEADER IN HDBUFF
	LDB	T1,[POINT 6,MASTWD,29]	;PICKUP # WDS IN HEADER
	MOVEM	T1,HEADWC	;STORE IT FOR LATER
	LDB	T1,[POINT 6,MASTWD,35]	;PICKUP # WDS IN BODY
	MOVEM	T1,ENTRWC	;STORE IT
	ADD	T1,HEADWC
	MOVEM	T1,TOTWC	;SAVE TOTAL # WDS IN ENTRY
	CAILE	T1,WKSIZE+HDSIZE	;IS ENTRY LARGER THAN BUFFERS
	JRST	TOOBIG		;YES
	PUSHJ	P,HEADFL	;GO FILL HDBUFF WITH HEADER INFO
	TLNE	F,F.DATE	;DOES USER DESIRE DATE CONSTRAINTS
	PUSHJ	P,DATECK	;YES GO DO IT

	;FALL INTO CHRCHK ROUTINE
	;CHRCHK -- ROUTINE TO DETERMINE IF THIS ENTRY SHOULD BE LISTED
	;EXITS TO SKIPIT IF ENTRY NOT DESIRED
	;ELSE XFERS ENTRY TO WORK BUFFER AND DISPATCHES TO ENTRY PROCESSOR
	;SPECIFIED IN PCSTBL WORD

CHRCHK:	SKIPN	T1,ERTYPE	;PICKUP ENTRY TYPE
	JRST	XFRBUF		;ALWAYS PASS ENTRY TYPE 0
	MOVE	T2,ENTCHR(T1)	;PICKUP ENTRY CHAR WORD
	TLZ	F,F.BTCK	;CLEAR EXAMINE ENTRY FLAG
	TLNN	T2,E.LALL!E.LNXM!E.LPAR!E.LPER!E.LSUM	;ANY LISTING DESIRED
	JRST	SKIPIT		;SKIP THIS ENTRY
	TLNE	T2,E.LNXM!E.LPAR!E.LPER!E.LSUM	;ANY REASON TO DO BIT CHECKING?
	TLO	F,F.BTCK	;YES-SET FLAG TO DO IT LATER
	AOS	ENTCHR(T1)	;NO- BUMP COUNTER
	SETZ	WKINDX,		;CLEAR INDEX INTO BUFFER
	SKIPG	T1,ENTRWC	;PICKUP ENTRY LENGTH AND CHECK FOR LEGALITY
	FATAL	<ENTRY WITH ZERO LENGTH BODY SPECIFIED>
	MOVNS	T1		;PUT -LENGTH IN T1
	MOVS	WKINDX,T1	;SETUP FOR AOBJ USE
	HRRI	WKINDX,0	;SET RH OF WKINDX TO 0
XFRBUF:	TLO	F,F.READ	;NOW LETS DO BUFFER XFER
XFRMOR:	PUSHJ	P,GETWD		;LOOP HERE TO FILL WK BUFFER
	MOVEM	MASTWD,WKBUFF(WKINDX)
	AOBJN	WKINDX,XFRMOR	;IS ALL OF ENTRY IN WKBUFF

XFRDUN:	TLZ	F,F.READ	;SAY THAT BUFFER XFER COMPLETED
	MOVE	T1,ERTYPE
	CAIN	T1,ER.DPE	;IS THIS A DISK ENTRY
	PUSHJ	P,DVCHAR	;GO DO DEVICE STATISTICS STORAGE
	MOVE	P4,ERTYPE
	TLNE	F,F.BTCK	;DO WE NEED TO EXAMINE ENTRY TO DETERMINE LISTING
	PUSHJ	P,@BITCHK(P4)	;GO DO BIT CHECKING
	PUSHJ	P,HDRLST	;OUTPUT HEADER TYPE,DATE,TIME,UPTIME
	MOVE	T2,ERTYPE
	HRRZ	T1,PCSTBL(T2)	
	HLRZ	CTINDX,PCSTBL(T2)	;PICKUP CONTROL TABLE ADDRESS

	JRST	(T1)		;DISPATCH TO ENTRY PROCESSOR SPECIFIED BY PCSTBL


	;PROCSA -- STANDARD ENTRY PROCESSOR #1
	;CALL	JRST PROCSA
	;
	;RETURN	JRST ABORT	WHEN ENTRY IS PROCESSED OR ABORTED
	;OPERATION IS CONTROLLED BY ENTRY IN CONTROL TABLE
	;ROUTINE GETS AOB POINTER TO DESIRED WORD IN BUFFER
	;IF THERE IS ONE PRESENT
	;THEN DISPATCHES TO WORD PROCESSOR LEVEL
	;VIA PUSHJ	P,SUBTAB(MODE)
	;PASSES BUFFER WORD IN P2 TO WORD PROCESSOR

PROCSA:	SETZM	OFFSET		;CLEAR WORD OFFSET COUNT
	MOVE	P1,(CTINDX)	;PICKUP FIRST WORD IN CONTROL TABLE
	JUMPE	P1,ABORT	;ABORT WHEN END OF CTL TABLE SEEN
	TLNE	P1,770000	;DO WE NEED TO GET AN AOB POINTER
	PUSHJ	P,GETAOB	;YES-WORD IS IN A RELOCATABLE SUBTABLE IN ENTRY
	LDB	T2,[POINT 6,P1,11]	;PICKUP WORD LOCATION IN ENTRY
	ADD	T2,OFFSET	;OFFSET CONTAINS AOB BLOCK STARTING LOCATION
	CAMLE	T2,ENTRWC	;DONT TRY TO ACCESS WORDS OUTSIDE OF ENTRY
	AOJA	CTINDX,PROCSA	;GET NEXT WORD IN CTL TABLE
	CAILE	T2,WKSIZE	;MAKE SURE THE WORD ASKED FOR IS IN WORK BUFFER
	AOJA	CTINDX,PROCSA	;IGNORE AND GET NEXT WORD
	MOVE	P2,WKBUFF(T2)	;PICKUP DATA WORD IN WORK BUFF
	LDB	T3,[POINT 6,P1,17]	;PICKUP WORD PROCESSES MODE
	CAIG	T3,SUBMAX	;IS IT AND UNKNOWN MODE
	PUSHJ	P,SUBTAB(T3)	;ITS RECOGINIZED
	AOJA	CTINDX,PROCSA	;EITHER NOT KNOWN OR FALL HERE

GETAOB:	LDB	T2,[POINT 6,P1,5]	;PICKUP AOBJN POINTER ADDRESS IN ENTRY
					;AOB GIVEN IS WITH REF TO HEADER
	SKIPL	T2,WKBUFF(T2)	;PICKUP THE ACTUAL POINTER AND SKIP IF LEGAL
	JRST	AOBQIT		;AOBJN POINTER = 0 CLEAN UP PDL AND GO TO PROCSA
	SUB	T2,HEADWC	;CORRECT AOB POINTER FOR HEADER SIZE
	HRRZM	T2,OFFSET	;SAVE IT IN OFFSET
	MOVEM	T2,AOBPNT	;SAVE POINTER FOR SPECL ROUTINE USAGE
	POPJ	P,		;VAMOOSE



	;HERE WHEN AOBJN POINTER = POS IN LH
	;NORMALLY SHOULD NOT HAPPEN

AOBQIT:	POP	P,T2		;DUMMY POP TO FIX PDP
	AOJA	CTINDX,PROCSA	;BUMP CTINDX AND BACK TO START
	SUBTTL	DIALOG RELATED SUBROUTINES
	;DIALOG	-- SUBROUTINE TO PROVIDE FOR DIALOG WITH USER
	;TO OBTAIN THE FOLLOWING INFO:
	;INPUT DEV,FILENAME,EXT,PPN
	;OUTPUT DEV,FILENAME,EXT,PPN
	;SELECTIVE LISTING CONTROL SWITCHES
	;THE SCAN.MAC ROUTINES ARE USED TO DO THE ACTUAL STRING
	;SCANNING AND WILL LEAVE INFO IN THE INPUT SPECIFICATIONS
	;AND OUTPUT SPECIFICATIONS BLOCK OF THIS PROGRAM

DIALOG:	TLO	F,F.TTYO	;SAY ALL OUTPUT TO TTY TILL FURTHER NOTICE
	MOVE	T1,[XWD IARGLN,IARGST]	;SETUP POINTER OF LENGTH,,ADDRESS
					;POINTING TO ARG BLOCK FOR .ISCAN
	PUSHJ	P,.ISCAN	;INITIALIZE SCAN FOR INFO PICKUP

	MOVE	T1,[XWD TARGLN,TARGST]	;SETUP POINTER SAME AS ABOVE FOR .TSCAN
	PUSHJ	P,.TSCAN	;GO DO THE ACTUAL STRING SCAN
					;FOR CUSP TYPE COMMAND STRING

	;FALL INTO SETINP ROUTINE
	;SPECIFICATION BLOCKS NOW HAVE DESIRED INFO
	;LETS UPDATE THE DEFAULT INFO PLACED IN LOOKUP
	;AND INIT BLOCKS EARLIER WITH THE BLT

SETINP:	SKIPE	T1,I.DEV	;PICKUP INPUT DEVICE, SKIP IF ZERO
	MOVEM	T1,INPBLK+1
	JUMPN	T1,SETIN1
	MOVE	T1,IDVFLT
	MOVEM	T1,I.DEV
SETIN1:	SKIPE	T1,I.NAM	;FILENAME LIKEWISE
	MOVEM	T1,INPFIL+.RBNAM
	JUMPN	T1,SETIN2
	MOVE	T1,IFLFLT
	MOVEM	T1,I.NAM
SETIN2:	SKIPN	T1,I.EXT	;EXTENSION
	JRST	SETIN3		;NO EXTENSION WAS TYPED
	HLLZM	T1,INPFIL+.RBEXT	;STORE EXTENSION
	JRST	GETIPP
SETIN3:	MOVE	T1,IEXFLT
	MOVEM	T1,I.EXT
GETIPP:	SKIPE	T1,I.DIR	;PPN FOR INPUT
	MOVEM	T1,INPFIL+.RBPPN
	MOVEM	T1,INPFIL+.RBSIZ	;DUMMY TO ALLOW SHORT LOOKUP
				;AT INPFIL+2


	;NOW DO SAME FOR OUTPUT SPECIFICATIONS

SETOUT:	SKIPE	T1,O.DEV	;PICKUP OUTPUT DEVICE, SKIP IF ZERO
	MOVEM	T1,OUTBLK+1
	JUMPN	T1,SETOU1
	MOVE	T1,ODVFLT
	MOVEM	T1,O.DEV
SETOU1:	SKIPE	T1,O.NAM	;FILENAME LIKEWISE
	MOVEM	T1,OUTFIL
	JUMPN	T1,SETOU2
	MOVE	T1,OFLFLT
	MOVEM	T1,O.NAM
SETOU2:	SKIPN	T1,O.EXT	;EXTENSION
	JRST	SETOU3		;NO EXTENSION WAS TYPED
	HLLZM	T1,OUTFIL+1	;STORE EXTENSION
	JRST	GETOPP
SETOU3:	MOVE	T1,OEXFLT
	MOVEM	T1,O.EXT
GETOPP:	SKIPE	T1,O.DIR	;PPN FOR OUTPUT
	MOVEM	T1,OUTFIL+3
	MOVE	T1,[-1]		;INITIAL VALUE OF DEV
	CAME	T1,DEV		;DD USER SPECIFY /DEV
	TLO	F,F.DEV		;YES LITE THE BIT
	POPJ	P,		;RETURN

	;SETDAT	-- SUBROUTINE TO LOOK AT /END AND /BEGIN
	;SWITCHES AND CONVERT THEM TO START AND END DATE
	;CALL	PUSHJ	P,SETDAT
	;
	;RETURN	CALL+1
	;BOTH BEGIN AND END ARE INITIALIZED TO -1 FOR SCAN USE
	;STDATE=0 OR VALUE OF /BEGIN SWITCH IF TYPED
	;ENDATE=377777,,-1 OR VALUE OF /END IF TYPED
	;IF USER DOES NOT SPECIFY TIME CUTOFF ASSUME 2400 HRS.
	;USES T1,T2

SETDAT:	TLZ	F,F.DATE	;ASSUME NO DATE CONSTRAINTS DEFAULT
	SETZM	STDATE		;ZAP
	SKIPGE	T1,END		;CHECK FOR /END SWITCH
	MOVE	T1,[377777777777]	;NONE TYPED-SAY ETERNITY IS CUTOFF
	TRNN	T1,-1		;DID USER SPECIFY TIME CUTOFF AS WELL
	HRRI	T1,-1		;NO-SAY 2400 FOR HIM  TO ALLOW ALL DAY AS GOOD
	MOVEM	T1,ENDATE	;STORE AS CUTOFF DATE
	SKIPL	T2,BEGIN	;/SINCE SPECIFIED
				;-1 SAYS NO SWITCH WAS STORED
	MOVEM	T2,STDATE	;STORE AS STARTING DATE
	CAMN	T1,[377777777777]	;DID USER TYPE /END?
	CAIE	T2,-1		;SKIP IF NO /BEGIN SPECIFIED
	TLO	F,F.DATE	;SAY WE SAW A TIME SWITCH
	POPJ	P,		;RETURN

	SUBTTL	SCAN RELATED SUBROUTINES
	;DEFINP,DEFOUT -- SUBROUTINES TO SETUP PARAMETERS FOR INPUT AND OUTPUT
	;CALL	PUSHJ	P,DEFXXX FROM SCAN CODE
	;
	;RETURN	CALL +1
	;RETURNS TO SCAN WITH T1=START OF AREA	T2=LENGTH OF AREA
	;USES T1,T2

DEFINP:	MOVEI	T1,I.ST		;PICKUP ADDRESS OF START OF INPUT AREA
	MOVEI	T2,I.LNGH	;PICKUP LENGTH OF INPUT AREA
	POPJ	P,

DEFOUT:	MOVEI	T1,O.ST		;SAME AS ABOVE FOR OUTPUT AREA
	MOVEI	T2,O.LNGH
	POPJ	P,


	;CLRFLG -- SUBROUTINE TO CLEAR SWITCH FLAG STORAGE LOCATIONS
	;CALL	PUSHJ	P,CLRFLG	FROM SCAN

CLRALL:	MOVE	T1,[XWD FLGST,FLGST+1]
	SETOM	FLGST		;SCAN LIKES -1 TO INITIALIZE
	BLT	T1,FLGND

	MOVE	T1,[XWD I.ST,I.ST+1]	;SETUP TO CLEAR INPUT FILE SPEC BLOCK
	SETZM	I.ST
	BLT	T1,I.END

	MOVE	T1,[XWD O.ST,O.ST+1]	;SAME FOR OUTPUT
	SETZM	O.ST
	BLT	T1,O.END	;ZAP OUTPUT FILE SPEC AREA
	POPJ	P,		;RETURN TO SCAN CODE


	;SETSWT -- SUBROUTINE CALLED BY SCAN TO HANDLE BIT SETTING
	;IN ENTCHR TABLE AS A RESULT OF USER SWITCHES
	;CALL	PUSHJ	P,SETSWT FROM SCAN CODE
	;
	;RETURN CALL+1
	;SETS BITS IN ENTCHR TABLE AS SPECIFIED BY BYTES FOUND
	;AT @BYTDSP(ERROR CODE)
	;BYTES ARE GROUPED INTO LIST ALL,NXM CAUSED,PAR CAUSED,PER CAUSED
	;PERFORMANCE CAUSED,SUMMATION
	;BYTE FIELDS ARE DELIMITED WITH 77

SETSWT:	PUSH	P,T1		;SAVE T1
	PUSH	P,T2		;LIKEWISE
	HRRZ	T1,T2		;PICKUP FLAG ADDRESS
	SUBI	T1,FLGST	;SUBTRACT STARTING ADDRESS OF FLAGS
				;RESULT IS OFFSET OF SWITCH IN TABLE
	CAILE	T1,FLGSTP	;DO WE WISH TO SET BITS IN ENTCHR FOR THIS SWITCH ?
	JRST	DONE		;NO - JUST LET SCAN STORE IT
	MOVSI	T2,440600	;SETUP FOR 6 BITS
	HRR	T2,BYTDSP(T1)	;SETUP TO LOOK AT BYTX WHERE X IS INDEX INTO SWITCH TABLE
	HRLZI	T4,E.LALL	;SET E.LALL BIT IN MASK
ALLCHK:	ILDB	T3,T2		;PICKUP BYTE FROM BYTXXX
	JUMPE	T3,ALLCHK	;IGNORE IT
	CAIN	T3,77		;READY TO GO TO E.LNXM CHECK
	JRST	NXMCHK		;YES DISPATCH
	IORM	T4,ENTCHR(T3)	;LIGHT THE BIT
	JRST	ALLCHK		;BACK FOR MORE

NXMCHK:	HRLZI	T4,E.LNXM	;SET THE E.LNXM BIT IN MASK
NXMCON:	ILDB	T3,T2
	JUMPE	T3,NXMCON
	CAIN	T3,77		;READY TO GO TO PARCHK
	JRST	PARCHK
	IORM	T4,ENTCHR(T3)	;LIGHT THE E.LNXM BIT IN ENTRY CHAR WORD
	JRST	NXMCON		;MORE

	;FALL INTO PARCHK ROUTINE
PARCHK:	HRLZI	T4,E.LPAR	;SET THE E.LPAR BIT IN MASK
PARCON:	ILDB	T3,T2
	JUMPE	T3,PARCON
	CAIN	T3,77		;READY TO DO PERCHK?
	JRST	PERCHK		;YES
	IORM	T4,ENTCHR(T3)	;LIGHT THE LITE
	JRST	PARCON		;LOOP

PERCHK:	HRLZI	T4,E.LPER	;LIGHT THE E.LPER BIT IN MASK
PERCON:	ILDB	T3,T2
	JUMPE	T3,PERCON
	CAIN	T3,77		;READY FOR SUMCHK
	JRST	SUMCHK		;YES
	IORM	T4,ENTCHR(T3)	;LITE THE BIT IN ENTCHR TABLE
	JRST	PERCON		;LOOP

SUMCHK:	HRLZI	T4,E.LSUM
SUMCON:	ILDB	T3,T2
	JUMPE	T3,SUMCON	;IGNORE
	CAIN	T3,77		;FINI??
	JRST 	DONE		;YES EXIT
	IORM	T4,ENTCHR(T3)	;SET THE BIT
	TLO	F,F.LSUM	;SAY SOME SUMMARY WAS REQUESTED
	JRST	SUMCON

DONE:	POP	P,T2		;RESTORE T2
	POP	P,T1		;SAME
	AOS	(P)		;SKIP RETURN TO MAKE SCAN STORE FLAG
	POPJ	P,		;BACK TO SCAN

	SUBTTL	ENTRY LEVEL SUBROUTINES
	;DATECK -- SUBROUTINE TO COMPARE DATE OF THIS ENTRY AGAINST
	;/BEFORE AND /SINCE IF SPECIFIED BY USER
	;CALL	PUSHJ	P,DATECK
	;
	;RETURN	POPJ	P,	IF WITHIN RANGE
	;	JRST	ABORT	IF OUT OF RANGE
DATECK:	MOVE	MASTWD,HDBUFF+HDRDAT	;PICKUP DATE/TIME WORD IN HEADER
	CAML	MASTWD,STDATE	;IS ENTRY DATE PRIOR TO DEFINED START DATE
	CAML	MASTWD,ENDATE	;IS ENTRY DATE PAST DEFINED END DATE
	JRST	SKIPIT		;YES TO EITHER SAYS DONT DO THIS ENTRY
	POPJ	P,

FILERR:	WARN	<DAEMON HAS FLAGGED ERROR IN SYSTEM ERROR FILE>
	JRST	ABORT		;PROCESS NEXT ENTRY

TOOBIG:	WARN	<FILE ENTRY LARGER THAN WORKING BUFFER>
	SUBI	T1,1		;CORRECT FOR WORD ALREADY IN HDBUFF
	PUSHJ	P,SKIPWD	;T1 IS ALREADY SETUP
	JRST	ABORT		;GO PROCESS NEXT ENTRY

EOFVER:	PUSHJ	P,GETWD		;TRY TO GET ANOTHER WORD AFTER EOF
	WARN	<EOF MARKER FOUND IN BODY OF SYSTEM ERROR FILE>
	JRST	EOFTRY

VOIDTY:	MOVEM	T1,BADTYP	;SAVE BAD ERROR TYPE
	SETZM	ERTYPE		;LET NORMAL DISPATCH TAKE PLACE TO DUMP BUFFER AT DMPBUF
	POPJ	P,		;RETURN


	;DVCHAR -- SUBROUTINE TO GET DEVICE CHARACTERISTICS AND
	;	PUT CONTROLLER TYPE, DEVICE NAME INDEX INTO
	;	STORAGE FOR LATER USE
	;CALL	PUSHJ	P,DVCHAR
	;
	;RETURN	CALL+1

DVCHAR:	MOVE	P3,WKBUFF+HDENAM	;PICKUP DEVICE NAME
	MOVE	T1,[IOWD NAMLTH,NAMTBL]	;SETUP TO CALL SCAN
	PUSHJ	P,.NAME		;DO TABLE LOOKUP
	  JRST BADNAME
	TLZ	T1,-1		;CLEAR LH OF T1
	SUBI	T1,NAMTBL	;CALC OFFSET IN NAME TABLE
	MOVEM	T1,DVINDX	;SAVE IT
	MOVE	T1,WKBUFF+HDEDCR	;PICKUP DEVCHR WORD
	SETZ	T2,		;ASSUME IT IS AN RC10
	TRNN	T1,1B26		;IS IT A RP10
	MOVEI	T2,1		;YES
	MOVEM	T2,KONTYP	;SAVE THIS FACT
	POPJ	P,

	;CNISUM -- SUBROUTINE TO PERFORM CONI BIT SUMMATION
	;CALL	PUSHJ	P,CNISUM
	;
	;RETURN	CALL+1

CNISUM:	MOVE	T1,DVINDX	;PICKUP INDEX AS SPECIFIED BY DEVICE
	HLRZ	P1,DEVDSP(T1)	;PICKUP POINTER TO COUNTER BLOCKS
	MOVE	T3,WKBUFF+HDEECT	;PICKUP RETRY WORD
	TLNN	T3,ERRHRD	;HARD ERROR
	HRRZ	P1,DEVDSP(T1)	;NO-PICKUP SOFTPOINTER
	MOVE	T3,WKBUFF+HDESOF	;PICKUP 1CONI WORD
	MOVE	T1,KONTYP	;PICKUP CONTROLLER TYPE
	AND	T3,KONMSK(T1)	;PICKUP CONTROLLER MASK FOR ERROR BITS
	LSH	T3,@MINERB(T1)	;SHIFT WORD TO CORRESPOND TO FIRST POSSIBLE
					;ERROR BIT IN WORD
DOJFFO:	JFFO	T3,INCREM	;LOOK FOR ERROR BIT
	JRST	JFDONE		;HERE WHEN ALL BITS DONE

INCREM:	MOVE	T1,KONTYP	;PICKUP CONTROLLER TYPE
	MOVE	T1,ERINDX(T1)	;PICKUP ADDRESS OF ERR BIT TO INDEX BIT CONVERTER
	ADD	T1,T4		;INDEX INTO TABLE BY ERR BIT
	MOVE	T2,(T1)		;GET THE CORRELATED INDEX VALUE
	ADD	T2,P1		;ADD IN DEVICE OFFSET PASSED TO HERE
	AOS	(T2)		;INCREM COUNTER
	ROT	T3,(T4)		;MOVE BIT TO SIGN LOCATION
	TLZ	T3,400000	;CLEAR IT
	MOVNS	T4		;COMP SHIFT COUNT
	ROT	T3,(T4)		;RESTORE WORD TO ORIGINAL POSITION
	JRST	DOJFFO		;LOOP TILL ALL BITS DONE
JFDONE:	TLNE	F,F.DEV		;DID USER SAY DEVICE SWITCH
	PJRST	DEVCHK		;GO VERIFY THAT THIS DEVICE SHULD BE LISTED
	POPJ	P,		;JUST DO NORMAL RETURN


BADNAM:	WARN	<UNKNOWN DEVICE TYPE FOUND IN ENTRY>
	JRST	JFDONE


DEVCHK:	MOVE	T1,WKBUFF+HDENAM	;PICKUP ENTRY DEVICE NAME
	CAME	T1,DEV		;SAME AS ONE USER SPECIFIED?
	JRST	ABORT		;NO
	POPJ	P,		;NORMAL RETURN
	;SKIPIT -- SUBROUTINE TO SKIP CURRENT ENTRY IF INVALID
	;CALL	JRST	SKIPIT
	;
	;RETURN	JRST	ABORT

SKIPIT:	MOVE	T1,ENTRWC	;PICKUP TOTAL # WORDS IN HEADER
	PUSHJ	P,SKIPWD	;GO MANUALLY ADVANCE INPUT BUFF POINTER
	JRST	ABORT		;RESET AND GET NEXT ENTRY

	;HEADFL -- SUBROUTINE TO FILL THE HEADER BUFFER FROM I/O BUFF
	;CALL	PUSHJ	P,HEADFL
	;RETURN	CALL+1
	;HEADER BUFFER FILLER AS SPECIFIED BY HEADWC

HEADFL:	SETZ	WKINDX,		;CLEAR INDEX
	SKIPG	T1,HEADWC	;PICKUP # OF WORDS IN HEADER
	FATAL	<ENTRY WITH ZERO LENGTH HEADER SPECIFIED>
	SUBI	T1,1		;WD0 IS ALREADY IN HDBUFF
	MOVNS	T1
	MOVS	WKINDX,T1	;SETUP FOR AOBJ USE
	HRRI	WKINDX,1	;START AT HDBUFF+1
	TLO	F,F.READ	;SAY THAT EOF IS CLACKERS
XFRHDR:	PUSHJ	P,GETWD
	MOVEM	MASTWD,HDBUFF(WKINDX)	;STORE IT
	AOBJN	WKINDX,XFRHDR	;LOOP
	TLZ	F,F.READ	;SAY DONE WITH FILLING
	MOVE	T1,HDBUFF+HDRDAT	;PICKUP DATE/TIME OF ENTRY
	MOVEM	T1,FILEND	;CONTINUE TO SAVE AS POSSIBLE LAST ENTRY
	TLNE	F,F.ONCE	;IS THIS FIRST ENTRY SEEN IN FILE
	JRST	HDRDUN		;SKIP FOLLOWING ONCE-ONLY CODE
	MOVEM	T1,FILEST	;SAVE
	TLO	F,F.ONCE	;SAY ONCE-ONLY CODE IS DONE
HDRDUN:	POPJ	P,		;RETURN
	;DMPENT -- SUBROUTINE TO DUMP UNRECOGNIZED ENTRY
	;JRST	DMPENT
	;
	;RETURN	JRST	ABORT
DMPENT:	WARN	<DUMPING UNKNOWN ERROR TYPE IN OCTAL>
	TYPEIT	<DUMPING UNKNOWN ERROR IN OCTAL
>
	TYPEIT	<
ERROR CODE =	>
	MOVE	T1,ERTYPE
	PUSHJ	P,.TOCTW

	TYPEIT	<
>
HEADDM:	SETZM	WKINDX,		;ZERO WORKING INDEX BUFFER
	MOVE	T1,HEADWC	;PICKUP HEADER ZE
	MOVNS	T1
	MOVS	WKINDX,T1	;SET_P FOR AOBJ USE
	HRRI	WKINDX,0	;CLEAR RH OF WKINDX
	ADDI	WKINDX,HDBUFF	;SET FOR START AT HDBUFF
	PUSHJ	P,DUMPIT	;DUMP HEADER
BODYDM:	SETZ	WKINDX,
	MOVE	T1,ENTRWC	;PICKUP BODY OF ENTRY SIZE
	MOVNS	T1
	MOVS	WKINDX,T1	;SETUP FOR AOBJ USE
	HRRI	WKINDX,0	;CLEAR RH OF WKINDX
	ADDI	WKINDX,WKBUFF	;SET START OF DUMP AT WKBUFF
	PUSHJ	P,DUMPIT
	JRST	ABORT		;GO PROCESS NEXT ENTRY
DUMPIT:	MOVE	P1,(WKINDX)	;PICKUP CORRECT WORD
	PUSHJ	P,.TCRLF
	MOVE	T1,P1		;PUT WORD IN T1 FOR OUTPUT
	PUSHJ	P,.TXWDW	;GO OUTPUT IT
	AOBJN	WKINDX,DUMPIT	;LOOP TILL ENTRY DUMPED
	POPJ	P,		;RETURN
	;HDRLST -- SUBROUTINE TO TYPE HEADER INFORMATION
	;SUCH AS ENTRY TYPE, DATE OF LOGGING
	;TIME OF LOGGING, AND UPTIME OF SYSTEM AT TIME OF LOGGING
	;CALL	PUSHJ	P,HDRLST
	;
	;RETURN	CALL+1

HDRLST:	MOVE	T1,LINCNT
	MOVE	P4,ERTYPE	;PICKUP ENTRY TYPE
	ADD	T1,LINE(P4)	;ADD COUNT OF LINES IN NEXT ENTRY TO CURRENT LINE COUNT
	MOVEM	T1,LINCNT	;SAVE NEW LINE COUNT
	CAILE	T1,PAGLM	;EXCEEDING PAGE LIMIT SPECIFIED?
	PUSHJ	P,PAGXCD	;YES-WRAP UP WITH SUMMARY
	CAILE	T1,0		;CAN WE PRINT THIS ENTRY WITHOUT OVERFLOWING PAGE?
	JRST	HDRPNT		;GO DO HEADER TYPEOUT
	PUSHJ	P,.TCRLF
	PUSHJ	P,.TCRLF
	TYPEIT	<***********************************************
>
	MOVE	T1,ERTYPE
	MOVE	T1,TYPMES(T1)	;PICKUP APPROPIATE TEXT MESSAGE FOR HEADER
	PUSHJ	P,.TSTRG
	TYPEIT	< LOGGED ON >
	MOVE	T1,HDBUFF+HDRDAT	;PICKUP DATE OF ENTRY CURRENTLY BEING PROCESSED
	PUSHJ	P,GETNBS
	PUSHJ	P,.TCRLF
	TYPEIT	<AT >
	MOVE	T1,MSTIME
	PUSHJ	P,.TTIME	;GO CONVERT TO HH:MM:SS AND OUTPUT
	TYPEIT	<      MONITOR UPTIME WAS >
	HLRZ	T1,HDBUFF+HDRUPT	;PICKUP LH OF NBS DATE/TIME WORD
	CAIE	T1,0
	PUSHJ	P,SAYDAY	;DECODE #DAYS UPTIME IF ANY
	HRRZ	T1,HDBUFF+HDRUPT	;PICKUP RH OF DATE/TIME WORD
	HRL	T1,DUMDAY	;PUT DUMMY NON-ZERO DAY IN LH
	PUSHJ	P,.CNTDT	;CONVERT TO 12 BIT FORMAT
	PUSHJ	P,.TTIME	;GO DECODE UPTIME AS HH:MM:SS

	TYPEIT	<
***********************************************
>
	POPJ	P,
	;HDRPNT -- SUBROUTINE TO DO PAGE HEADER AND GIVE FORM FEED
	;CALL	JRST	HDRPNT
	;
	;RETURN	JRST	HDRLST

HDRPNT:	PUSHJ	P,TITLST	;GO DO TITLE INFO
	JRST	HDRLST		;NOW  TYPE ENTRY
	;PAGXCD -- SUBROUTINE TO HANDLE EXCEEDED PAGE LIMIT OCCURENCE
	;CALL	PUSHJ	P,PAGXCD
	;
	;RETURN	CALLS SUMLST AND EXITS

PAGXCD:	WARN	<EXCEEDED PAGE LIMIT...PERFORMING SUMMARY>
	TYPEIT	<

*************   PAGE LIMIT EXCEEDED **************>
	PUSHJ	P,SUMLST
	CLOSE	INPCHN,
	CLOSE	OUTCHN
	EXIT
	;SAYDAY -- SUBROUTINE TO EXAMINE LH OF NBS DATE/TIME WORD AND TYPEOUT
	;# OF DAYS REPRESENTED IN DECIMAL
	;SETUP	T1=LH NBS DATE/TIME WORD
	;CALL	PUSHJ	P,SAYDAY
	;
	;RETURN	CALL+1

SAYDAY:	PUSH	P,T1		;SAVE T1
	PUSHJ	P,.TDECW	;TYPE OUT # IN T1
	POP	P,P4
	SUBI	P4,1		;GET # DAYS -1
	JUMPG	P4,SAYDA1	;WASSYSTEM UP FOR MORE THAN 1 DAY
	TYPEIT	< DAY >
	JRST	SAYRET		;RETURN TO CALLER
SAYDA1:	TYPEIT	< DAYS >
SAYRET:	POPJ	P,
	;GETNBS -- SUBROUTINE TO OUTPUT DATE IN MM-DD-YYYY FORMAT
	;GETNBS -- CONVERTS FROM NBS FORMAT TO MM-DD-YYYY
	;SETUP	T1=NBS DATE/TIME WORD
	;CALL	PUSHJ	P,GETNBS


GETNBS:	PUSHJ	P,.CNTDT
	MOVEM	T1,MSTIME	;STORE FRACTIONAL PART OF DAY IN MSTIME
	MOVE	T1,T2		;PICKUP 12 BIT DATE IN T1 AS RETURNED FROM .CNTDT
	PUSHJ	P,.TDATE	;GO TYPE DATE
	POPJ	P,
	SUBTTL	WORD LEVEL SUBROUTINES
	;SUBTAB -- SUBROUTINES TO OUTPUT ENTRY WORD IN DESIRED FORMAT
	;CALL	PUSHJ	P,SUBTAB(MODE)
	;
	;RETURN	CALL+1
	;DISPATCHES TO APPROPIATE ROUTINE INTERNALLY TO DO WORD CONVERSION AND OUTPUT
SUBTAB:	SINDEX	<OCTLE>
	SINDEX	<DECML>
	SINDEX	<ASCIE>
	SINDEX	<SIXBT>
	SINDEX	<HAFWD>
	SINDEX	<SPECL>

.OCTLE:	HRRZ	T1,P1		;PICKUP POINTER TO ASCIZ TEXT
	PUSHJ	P,.TSTRG
	MOVE	T1,P2		;PICKUP WORD TO BE OUTPUT
	PJRST	.TOCTW		;SIGNED NUM TYPEOUT

.DECML:	HRRZ	T1,P1		;PICKUP POINTER TO ASCIZ TEXT
	PUSHJ	P,.TSTRG
	MOVE	T1,P2		;PICKUP WORD TO BE OUTPUT
	PUSHJ	P,.ODECW
	POPJ	P,		;GO AWAY

.ASCIE:	HRRZI	P2,WKBUFF(T2)
	HRRZ	T1,P1		;PICKUP POINTER TO ASCIZ TEXT
	PUSHJ	P,.TSTRG
	MOVE	T1,P2		;PICKUP WORD TO BE OUTPUT
	PJRST	.TSTRG

.SIXBT:	HRRZ	T1,P1		;PICKUP POINTER TO ASCIZ TEXT
	PUSHJ	P,.TSTRG
	MOVE	T1,P2		;PICKUP WORD TO BE OUTPUT
	PJRST	.TSIXN

.HAFWD:	HRRZ	T1,P1		;PICKUP POINTER TO ASCIZ TEXT
	PUSHJ	P,.TSTRG
	MOVE	T1,P2		;PICKUP WORD TO BE OUTPUT
	PJRST	.TXWDW

.SPECL:	PUSHJ	P,(P1)
	POPJ	P,

.ODECW:	PUSHJ	P,.TDECW	;GO TYPEOUT IN DECIMAL
	TYPEIT	<.>
	POPJ	P,		;SCRAM


	;SPECIAL DECODING ROUTINES

MONVER:	TYPEIT	<

MONITOR VERSION DECODE>
	TYPEIT	<
	LAST GROUP TO MODIFY:	>
	LDB	T1,[POINT 3,P2,2]
	PUSHJ	P,.TOCTW
	TYPEIT	<
	MAJOR VERSION NUMBER:	>
	LDB	T1,[POINT 9,P2,11]
	PUSHJ	P,.TOCTW
	TYPEIT	<
	MINOR VERSION NUMBER:	>
	LDB	T1,[POINT 6,P2,17]
	PUSHJ	P,.TOCTW
	TYPEIT	<
	EDIT NUMBER:		>
	HRRZ	T1,P2
	PUSHJ	P,.TOCTW
	POPJ	P,0

BADADD:	SKIPL	P2,AOBPNT	;GET THE AOBJN POINTER
	POPJ	P,		;EXIT IF NOT NEGATIVE
	TYPEIT	<

PE ADDRESSES DETECTED BY SWEEP
>
TAB031:	PUSHJ	P,TBPRNT	;HORIZ. TAB
	MOVE	T1,WKBUFF(P2)	;GET AN ADDRESS
	PUSHJ	P,.TOCTW	;DUMP IT IN OCTAL
	PUSHJ	P,.TCRLF	;CRLF
	AOBJN	P2,TAB031	;GET ANOTHER
	POPJ	P,

HARDER:	IFN	DEBUGA,<
	TYPEIT	<

UNIT HARD ERROR TOTALS>
	PUSHJ	P,DECHAF
>
	POPJ	P,
SOFTER:	IFN	DEBUGA,<
	TYPEIT	<

UNIT SOFT ERROR TOTALS>
	PUSHJ	P,DECHAF
>
	POPJ	P,
SOFDET:	IFN	DEBUGA,<
	TYPEIT	<

UNIT SOFTWARE-DETECTED ERROR TOTALS>
	TYPEIT	<
	SAT DISCREPANCIES:	>
	LDB	T1,[POINT 12,P2,11]	;PICKUP SAT ERROR BYTE
	PUSHJ	P,.ODECW
	TYPEIT	<
	RETRIEVAL INFO ERRORS:	>
	LDB	T1,[POINT 12,P2,23]	;PICKUP # RIB ERRORS
	PUSHJ	P,.ODECW
	TYPEIT	<
	CHECKSUM ERRORS:	>
	LDB	T1,[POINT 12,P2,35]	;PICKUP # CHKSUM ERRORS
	PUSHJ	P,.ODECW
>
	POPJ	P,		;GO AWAY
SEKINC:	IFN	DEBUGA,<
	TYPEIT	<
	SEEK INCOMPLETES:	>
	MOVE	T1,P2
	PUSHJ	P,.ODECW
>
	POPJ	P,

SOFHNG:	IFN	DEBUGA,<
	TYPEIT	<
	HARD XFER HANGS:	>
	MOVE	P3,[POINT 9,P2]
	ILDB	T1,P3		;PICKUP BITS 0-8
	PUSHJ	P,.ODECW
	TYPEIT	<
	SOFT XFER HANGS:	>
	ILDB	T1,P3		;PICKUP BITS 9-17
	PUSHJ	P,.ODECW
	TYPEIT	<
	SOFT SEEK HANGS:	>
	ILDB	T1,P3		;PICKUP BITS 18-27
	PUSHJ	P,.ODECW
	TYPEIT	<
	SOFT SOFTWARE HANGS:	>
	ILDB	T1,P3
	PUSHJ	P,.ODECW
>
	POPJ	P,

RETRYS:	TYPEIT	<
	RETRIES	PERFORMED:	>
	IFN	DEBUGA,<
	TLNE	P2,ERRHRD	;WAS THIS ERROR NON-RECOVERABLE?
	PUSHJ	P,TYPAST	;YES TYPE ASTERISK
>
	TLZ	P2,-1		;CLEAR LH OF P2
	MOVE	T1,P2
	PUSHJ	P,.ODECW
	POPJ	P,		;GO AWAY
TYPAST:	TYPEIT	<*  >
	POPJ	P,


	IFN	DEBUGA<
	;ROUTINE TO DECODE LH AND RH OF WORD AND PUBLISH IT
	;USED WITH UNIHCT AND UNISCT

DECHAF:	TYPEIT	<
	DATA PARITY:		>
	HRRZ	T1,P2		;PICKUP LH COUNT
	PUSHJ	P,.ODECW
	TYPEIT	<
	DEVICE OR POSITION:	>
	HLRZ	T1,P2		;PICKUP RH COUNT
	PUSHJ	P,.ODECW
	POPJ	P,		;GO BACK
>
	;DISKPR -- SUBROUTINE TO PUBLISH READ,WRITE AND SEEK STATISTICS
	;CALLED FROM PROCSA WITH PUSHJ	P,DISKPR
	;
	;RETURN	CALL+1

DISKPR:	IFN	DEBUGA,<
	TYPEIT	<

DISK PERFORMANCE TOTALS:
	READS:			>
	MOVE	T1,P2
	PUSHJ	P,.ODECW
	TYPEIT	<
	WRITES:			>
	MOVE	T1,WKBUFF+HDETWC	;PICKUP TOTAL # READS SINCE RELOAD
	PUSHJ	P,.ODECW	;PUBLISH IT
	TYPEIT	<
	SEEKS:			>
	MOVE	T1,WKBUFF+HDETSC	;PICKUP TOTAL # SEEKS SINCE RELOAD
	PUSHJ	P,.ODECW
>
	POPJ	P,
	;ERDIAG -- SUBROUTINE TO DIAGNOSE POSSIBLE CAUSE OF ENTRY
	;CALL	PUSHJ	P,ERDIAG
	;
	;RETURN	CALL+1

ERDIAG:	TYPEIT	<
	DISK CHARACTERISTICS:	>
	MOVE	T1,P2		;PICKUP DSKCHR WORD
	PUSHJ	P,.TXWDW	;TYPE IT
	TYPEIT	<

ERROR DIAGNOSIS
	>
	MOVE	P3,KONTYP	;PICKUP TYPE OF CONTROLLER 0=RC, 1=RP
	MOVE	P2,WKBUFF+HDESOF	;PICKUP 1CONI WORD
	MOVE	P4,KONMSK(P3)	;PICKUP CONTROLLER ERROR MASK
	TDNE	P4,P2		;ANY ERROR BITS LIT
	JRST	HARDCK		;YES-GO DO BIT DECODING
	TYPEIT	<SOFTWARE-DETECTED >
	MOVEI	P3,2		;SAY IT WAS A SOFTWARE DEVICE
	MOVE	P2,S		;PICKUP SOFTWARE STATUS FLAGS
	JRST	SAYIT		;PUBLISH TEXT

HARDCK:	AND	P2,P4		;APPLY MASK TO CONI WORD
	MOVE	T1,WKBUFF+HDEECT	;PICKUP RETRY WORD
	TLNN	T1,ERRHRD	;IF BIT 1 = 1 ERROR WAS NON-RECOVERABLE
	JRST	SOFTCK		;IT WAS RECOVERABLE
	TYPEIT	<NON-RECOVERABLE >
	JRST	SAYIT
SOFTCK:	TYPEIT	<RECOVERABLE >
SAYIT:	LSH	P2,@MINERB(P3)	;SHIFT WORD LEFT TILL FIRST KNOWN
					;ERROR BIT POSITION IS IN SIGN BIT
	MOVE	P4,DEVTYP(P3)	;PICKUP ASCIZ TEXT POINTER FOR ERROR BITS
	PJRST	JFLOOP		;EXIT TO TYPEOUT ENGLISH TRANSLATION
DEVTYP:	RC10DV
	RP10DV
	SOFTDV
	;CHNDCD -- SUBROUTINE TO ASSEMBLE ACTUAL COMMAND LIST
	;BASED ON TERMINATION WORD WRITTEN BY CHANNEL
	;CALL	PUSHJ P,CHNDCD
	;
	;RETURN	CALL+1

CHNDCD:	TYPEIT	<
	CHANNEL	COMMAND LIST:	>
	HLRZ	T1,WKBUFF+CPEFCW	;PICKUP TERMINATION CHANNEL WORD
	HRRZ	T2,WKBUFF+CPEICW	;PICKUP INITIAL CW
	CAMG	T1,T2		;IS TERM ADD GREATER THAN INIT CW ADDRESS
	JRST	ENTWD3		;NO ONLY WD3 IN LIST IS VALID
	CAIN	T1,1(T2)	;IS TERM ADD = INIT +1
	JRST	ENTWD2		;YES ONLY LIST WDS 2+3 OF CHAN CMD LIST
ENTWD1:	MOVE	T1,P2		;PICKUP 1ST WORD IN LIST
	PUSHJ	P,.TXWDW	;TYPE OUT IN HALFWORD FORMAT
	TYPEIT	<
				>
ENTWD2:	MOVE	T1,WKBUFF+CPECW1	;PICKUP CW #1
	PUSHJ	P,.TXWDW
	TYPEIT	<
				>
ENTWD3:	MOVE	T1,WKBUFF+CPECW0	;PICKUP WD3
	PUSHJ	P,.TXWDW
	POPJ	P,


	;CNXDCD -- ROUTINES TO DECODE CONI BITS IN CONI WORD
	;CALL	PUSHJ	P,CNXDCD
	;
	;RETURN	CALL+1

	;ENTRY FOR 1CONI WORD
CN1DCD:	TYPEIT	<
	CONI AT ERROR TIME:	>
	JRST	CONIGO

	;ENTRY FOR 2CONI WORD
CN2DCD:	TYPEIT	<
	CONI AFTER "RECAL":	>
CONIGO:	MOVE	T1,P2		;PICKUP CONI WORD
	PUSHJ	P,.TXWDW	;OUTPUT IT
	TYPEIT	<  =  >
	MOVE	T1,WKBUFF+HDEDCR	;PICKUP DSKCHR WORD
	MOVEI	P4,RP10DV	;ASSUME ITS A DISKPACK
	TRNE	T1,1B26		;IS IT A FIXED HEAD
	MOVEI	P4,RC10DV	;PICKUP CONI TABLE ADDRESS FOR RC10
	MOVE	P3,KONTYP	;PICKUP CONTROLLER TYPE
	AND	P2,KONMSK(P3)
	LSH	P2,@MINERB(P3)
	PUSHJ	P,JFLOOP	;GO DECODE BITS AND OUTPUT TEXT
	TLNE	F,F.JFFO	;DID WE SEE ANY TEXT BIT
	POPJ	P,		;YES GO AWAY
	TYPEIT	<NO ERROR BITS DETECTED>
	POPJ	P,


	;JFLOOP -- SUBROUTINE TO DECODE BITS IN WORD AND GIVE ASCIZ EXPANSION
	;SETUP	P2=WORD TO BE DECODED
	;	P4=ADDRESS OF ASCIZ TEXT POINTER CORRESPONDING TO BITS
	;CALL	PUSHJ	P,JFLOOP
	;
	;RETURN	CALL+1

JFLOOP:	TLZ	F,F.JFFO	;INITIALIZE ERROR FLAG
JFMORE:	JFFO	P2,JFFDCD	;LOOK FOR FIRST NON-ZERO BIT
	POPJ	P,		;ALL DONE
JFFDCD:	MOVE	T1,KONTYP	;PICKUP CONTROLLER TYPE
	MOVE	T1,ERINDX(T1)	;PICKUP ADDRESS OF BIT TO INDEX CONVERTER
	ADD	T1,P3		;SETUP TO ADDRESS OF BIT WE WANT
	MOVE	T2,(T1)		;GET CORRESPONDING INDEX BIT
	ADD	T2,P4		;ADD IN DEVICE OFFSET
	MOVE	T1,@T2		;PICKUP ADDRESS OF TEXT
	TLO	F,F.JFFO	;SAY WE SAY A TEXT-BIT
	PUSHJ	P,.TSTRG	;TYPEIT
JFCONT:	ROT	P2,(P3)		;BRING BIT TO SIGN POSITION
	TLZ	P2,400000	;CLEAR IT
	MOVNS	P3		;NEGATE TO ALLOW RIGHT SHIFT
	ROT	P2,(P3)		;RESTORE IT TO ORIGINAL POSIION
	JRST	JFMORE		;LOOP TILL ALL BITS DONE
	;LBNDCD -- SUBROUTINE TO CONVERT LOGICAL BLOCK NUMBERS TO PHYSICAL
	;DISK ADDRESSES.
	;SETUP	P2=LOGICAL BLOCK NUMBER OF ERROR
	;	HDEDCR=LOCATION OF DSKCHR WORD IN ENTRY
	;CALL	PUSHJ	P,LBNDCD
	;
	;RETURN	CALL+1

LBNDCD:	TYPEIT	<

ERROR ANALYSIS>
	SETZ	P1,		;P1 WILL HOLD DEVICE IDENTIFIER
	MOVEM	P2,.LBN		;STORE THE BLOCK # IN .LBN
	MOVE	P2,WKBUFF+HDEDCR	;GET THE DEVCHR WORDS
	TRNE	P2,1B26		;FIXED HEAD?
	JRST	.FHCHK		;YES-GO SEE IF IT'S A DRUM OR DISK
	TRNE	P2,1B25		;NO-IS IT A DISK PACK?
	JRST	.DPCHK		;YES-GO SEE IF IT IS AN RP02 OR RP03
.DBOMB:	WARN	<UNDECIPHERABLE DISK CHARACTERISTIC WORD>
	TYPEIT	<
UNDECIPHERABLE DISK CHARACTERISTICS WORD
>
	PJRST	.LBPRT		;PRINT THE LOGICAL BLOCK NUMBER AND EXIT

.FHCHK:	TRNE	P2,1B32		;IS IT A BURROUGHS DISK?
	MOVEI	P1,1		;NO-SET CODE FOR BRYANT DRUM RM10B
	JRST	.BLKDV		;AND DIVIDE IN BLOCK NUMBERS

.DPCHK:	TRNE	P2,1B31		;IS IT AN RP02?
	JRST	.RP3CK		;NO-MAKE SURE IT'S AN RP03
	MOVEI	P1,2		;YES-SET CODE FOR RP02
	JRST	.BLKDV		;AND DIVIDE IN BLOCK NUMBERS

.RP3CK:	TRNE	P2,1B32		;IS IT IN FACT AN RP03?
	JRST	.DBOMB		;NO-WOULD YOU BELEIVE AN RP0X?
	MOVEI	P1,3		;YES-SET CODE FOR RP03

.BLKDV:	PUSHJ	P,.DVPRT	;GO PRINT DEVICE TYPE
	PUSHJ	P,.LBPRT	;GO PRINT THE LOGICAL BLOCK NUMBER
	MOVE	P2,.LBN		;RETURN THE BLOCK NUMBER TO P2
	CAMG	P2,.MXBLK(P1)	;IS THIS BLOCK ON FIRST UNIT OF STR?
	JRST	.TCPRT		;YES-GO PRINT TRACK/CYLINDER ADDRESS
	SUB	P2,.MXBLK(P1)	;NO-SUBTRACT ONE UNIT'S WORTH OF BLOCKS
	JRST	.-3		;AND CHECK AGAIN

.TCPRT:	MOVEI	T1,[ASCIZ/
	CYLINDER:		/]
	CAIG	P1,1		;IS IT A DISK PACK?
	MOVEI	T1,[ASCIZ/
	TRACK:			/]
	PUSHJ	P,.TSTRG	;TYPE EITHER CYL OR TRK
	IDIV	P2,.TRBLK(P1)	;DIVIDE IT BY TRACKS PER UNIT
	MOVE	T1,P2		;STAND BY TO DUMP IT
	PUSHJ	P,.ODECW
	MOVE	P2,P3		;REMAINDER TO P2
	CAIG	P1,1		;IS IT A PACK?
	JRST	.SECPR		;NO-GO PRINT SECTOR ADDRESS
	MOVEI	T1,[ASCIZ/
	SURFACE:		/]
	PUSHJ	P,.TSTRG
	IDIV	P2,.SUBLK(P1)	;DIVIDE BY # BLOCKS PER SURFACE
	MOVE	T1,P2
	PUSHJ	P,.ODECW
	MOVE	P2,P3		;SAVE REMAINDER

.SECPR:	MOVEI	T1,[ASCIZ/
	SECTOR:			/]
	PUSHJ	P,.TSTRG
	IMUL	P2,.SECBK(P1)	;MULTIPLY IT BY SECTORS PER BLOCK
	MOVE	T1,P2
	PUSHJ	P,.ODECW
	POPJ	P,		;EXEUNT

.LBPRT:	MOVEI	T1,[ASCIZ/
	LOGICAL	BLOCK NUMBER:	/]
	PUSHJ	P,.TSTRG
	MOVE	T1,.LBN
	PUSHJ	P,.ODECW
	POPJ	P,

.DVPRT:	TYPEIT	<
	DEVICE	TYPE:		>
	MOVEI	T1,.DVTAB(P1)	;PICKUP ADDRESS OF ASCIZ DEVICE
	PUSHJ	P,.TSTRG	;TELL THE WORLD
	POPJ	P,		;RETURN

	;TABLES

.DVTAB:	ASCIZ/RD10/	;CAUTION DEVICE NAME MUST 4 CHAR OR LESS TO CORRECTLY INDEX INTO TABLE
	ASCIZ/RM10/
	ASCIZ/RP02/
	ASCIZ/RP03/
	ASCIZ/????/
.MXBLK:	^D4000			;4000 BLOCKS PER RD10
	^D2700			;2700 BLOCKS PER RM10B
	^D40000			;40000 BLOCKS PER RP02
	^D80000			;80000 BLOCKS PER RP03

.TRBLK:	^D20			;20 BLOCKS/TRACK ON RD10
	^D30			;30 BLOCKS/TRACK ON RM10B
	^D200			;200 BLOCKS/CYLINDER ON RP02
	^D200			;200 BLOCKS/CYLINDER ON RP03

.SUBLK:	0			;RD10 BLOCKS/SURFACE
	0			;RM10B BLOCKS/SURFACE
	^D10			;RP02 BLOCKS/SURFACE
	^D10			;RP03 BLOCKS/SURFACE

.SECBK:	4			;4 SECTORS/BLOCK ON RD10
	2			;2 PHYSICAL SECTORS PER RM10B BLOCK
	1			;1 FOR RP02
	1			;AND RP03

	SUBTTL	OUTPUT LISTING RELATED ROUTINES
	;BCKXXX -- SUBROUTINES TO DETERMINE LISTING AND SUMMATION ELIGIBILITY
	;BASED ON BITS IN ENTCHR TABLE
	;CALL	PUSHJ	P,@BITCHK(ERROR CODE)
	;
	;RETURN	CALL+1 TO LIST
	;	JRST	ABORT TO GO TO NEXT ENTRY

BCK1:	MOVE	P1,ERTYPE	;PICKUP ENTRY TYPE
	MOVE	P2,ENTCHR(P1)	;PICKUP CHAR WORD
	TLNE	P2,E.LSUM	;DO WE WANT SUMMARY
	PUSHJ	P,SUM1
	TLNN	P2,E.LNXM	;NXM CAUSED RELOAD
	JRST	B1.1
	MOVE	T1,[SIXBIT/NXM/]
	CAMN	T1,WKBUFF+WHYWHY	;CAUSED BY NXM?
	POPJ	P,		;WIN LIST IT
B1.1:	TLNN	P2,E.LPAR	;PARITY ERR CAUSED RELOAD
	JRST	B1.2
	MOVE	T1,[SIXBIT/PARITY/]
	CAMN	T1,WKBUFF+WHYWHY	;SAME AS WHY RELOAD
	POPJ	P,		;WIN
B1.2:	TLNE	P2,E.LALL	;ALWAYS LIST?
	POPJ	P,		;DOIT
	TLNE	P2,E.LPER	;PERFORMANCE 
	POPJ	P,		;WIN
	JRST	ABORT		;LISTING NOT FIT TO PRINT

BCK3:	MOVE	P1,ERTYPE
	MOVE	P2,ENTCHR(P1)	;PICKUP CHAR WORD
	TLNE	P2,E.LSUM	;SUMMARY DESIRED
	PUSHJ	P,SUM3
	TLNN	P2,E.LALL!E.LPAR
	JRST	ABORT		;LOSE
	POPJ	P,		;WIN LIST IT


BCK6:	MOVE	P1,ERTYPE	;PICKUP ENTRY TYPE
	MOVE	P2,ENTCHR(P1)	;PICKUP CHARACTERISTICS WORD
	TLNE	P2,E.LSUM	;SUMMATION DESIRED
	PUSHJ	P,SUM6		;YES-DISPATCH
	TLNE	P2,E.LALL	;ALWAYS LIST?
	POPJ	P,		;DOIT
	TLNN	P2,E.LNXM
	JRST	B6.1
	MOVE	T1,WKBUFF+CPENXM	;PICKUP NXM COUNT
	CAMN	T1,NXMTMP	;SAME AS OLD NXM COUNT?
	JRST	B6.1		;YES
	POPJ	P,		;IF TS GREATER THEN NXM CAUSED ERR
				;IF LESS RELOAD OCCURRED THEN ERROR
B6.1:	TLNN	P2,E.LPAR
	JRST	B6.2
	MOVE	T1,WKBUFF+CPEMPE
	JUMPE	T1,B6.2		;CLEARLY WAS NOT CAUSED BY PAR
	CAMN	T1,MPETMP	;SAME AS OLD
B6.2:	JRST	ABORT		;NOT CAUSED BY PAR
	POPJ	P,		;WIN LIST IT

BCK10:	MOVE	T1,ERTYPE	;PICKUP ENTRY TYPE
	MOVE	P4,ENTCHR(T1)	;PICKUP CHAR WORD
	TLNE	P4,E.LSUM	;SUMMATION DESIRED?
	PUSH	P,P4
	PUSHJ	P,SUM10		;DOIT
	POP	P,P4		;RESTORE P4
	TLNE	P4,E.LALL	;ALWAYS LIST?
	POPJ	P,		;YES-DOIT
	TLNN	P4,E.LPAR
	JRST	ABORT		;PAR ERROR IS THE ONLT SELECTABLE ERR ON DSK
				;NXM IS IMPOSSIBLE
	MOVE	T1,WKBUFF+HDESOF	;PICKUP CONI AT ERROR WORD
	TLNE	T1,4000		;PAR ERR BIT LIT?
	POPJ	P,		;YES-LIST
	JRST	ABORT		;LOSE

BCK40:	MOVE	P1,ERTYPE
	MOVE	P2,ENTCHR(P1)	;PICKUP CHAR WORD
	TLNE	P2,E.LALL	;ALWAYS LIST?
	POPJ	P,		;YES-DOIT
	TLNE	P2,E.LPER	;PERFORMANCE ENTRY REQUESTED
	POPJ	P,		;WIN-LIST IT
	JRST	ABORT		;ALL OTHER REQUESTS ARE IGNORED
				;SINCE ENTRY TYPE 40 IS PER ONLY
SUM1:	POPJ	P,

SUM3:	MOVEI	T1,TPETMP
	MOVEI	T2,TPEPER
	MOVE	T3,WKBUFF+MPETPE	;PICKUP # HARD P.E.
	PUSHJ	P,COMPAR	;LET SUBROUTINE DO UPDATING AS NECESSARY
	MOVEI	T1,SPETMP	
	MOVEI	T2,SPEPER
	MOVE	T3,WKBUFF+MPESPE	;PICKUP # SOFT MEM P.E.
	PUSHJ	P,COMPAR
	MOVEI	T1,UEPTMP
	MOVEI	T2,UEPPER
	HRRZ	P4,WKBUFF+MPAPAR	;PICKUP AOB POINTER TO DESIRED WORD
	SUB	P4,HEADWC	;SUBTRACT SIZE OF HEADER
	MOVE	T3,WKBUFF+MPEUEP(P4)	;PICKUP # USER-ENABLED P.E.
	PUSHJ	P,COMPAR
	MOVEI	T1,PCSTMP
	MOVEI	T2,PCSPER
	MOVE	T3,WKBUFF+MPEPCS(P4)	;PICKUP # CHN P.E. NOT DETECTED BY CPU
	PUSHJ	P,COMPAR
	POPJ	P,		;DONE WITH SUM3


SUM6:	MOVEI	T1,NXMTMP
	MOVEI	T2,NXMPER
	MOVE	T3,WKBUFF+CPENXM	;PICKUP # NXMS
	PUSHJ	P,COMPAR	;GO DO COMPARISON AND UPDATING
S6.1:	MOVEI	T1,MPETMP
	MOVEI	T2,MPEPER
	MOVE	T3,WKBUFF+CPEMPE	;PICKUP COUNT OF P.E. SEEN BY CHANNEL
	PUSHJ	P,COMPAR
S6.2:	MOVEI	T1,DPETMP
	MOVEI	T2,DPEPER
	MOVE	T3,WKBUFF+CPEDPE	;PICKUP # DATA P.E. SEEN FROM CONTROLLER
	PUSHJ	P,COMPAR
	POPJ	P,		;EXIT BACK TO BITCHKER

SUM10:	MOVE	P1,DVINDX
	HRRZ	P2,SOFDSP(P1)
	HLRZ	P1,SOFDSP(P1)
	MOVEI	T1,HDETMP
	MOVEI	T2,HDEPER
	MOVE	P4,WKBUFF+HDEHCT	;PICKUP HARD ERR WORD
	HLRZ	T3,P4		;PICKUP # HDEV ERRS
	PUSHJ	P,COMPAR
	MOVEI	T1,HDTTMP
	MOVEI	T2,HDTPER
	HRRZ	T3,P4		;PICKUP # HDAT ERRORS
	PUSHJ	P,COMPAR
	MOVEI	T1,SDETMP
	MOVEI	T2,SDEPER
	MOVE	P4,WKBUFF+HDESCT
	HLRZ	T3,P4		;PICKUP # SDEV ERRS
	PUSHJ	P,COMPAR
	MOVEI	T1,SDTTMP
	MOVEI	T2,SDTPER
	HRRZ	T3,P4		;PICKUP # SDAT ERRORS
	PUSHJ	P,COMPAR
	MOVEI	T1,ERRSAT(P1)
	MOVEI	T2,ERRSAT(P2)
	LDB	T3,[POINT 12,WKBUFF+HDEMCT,11]	;PICKUP # SAT FAILS
	PUSHJ	P,COMPAR
	TLNE	F,F.CHNG	;DID COUNT CHANGE ON THIS ERROR
	TLO	S,S.SAT		;SAY SAT FAILURE
	MOVEI	T1,ERRRIB(P1)
	MOVEI	T2,ERRRIB(P2)
	LDB	T3,[POINT 12,WKBUFF+HDEMCT,23]	;PICKUP # RIB ERRS
	PUSHJ	P,COMPAR
	TLNE	F,F.CHNG
	TLO	S,S.RIB
	MOVEI	T1,ERRCHK(P1)
	MOVEI	T2,ERRCHK(P2)
	LDB	T3,[POINT 12,WKBUFF+HDEMCT,35]	;PICKUP # CHKSUM ERRS
	PUSHJ	P,COMPAR
	TLNE	F,F.CHNG
	TLO	S,S.CHK

	;FALL INTO S10.1 ROUTINE
S10.1:	MOVEI	T1,ERRINC(P1)
	MOVEI	T2,ERRINC(P2)
	MOVE	T3,WKBUFF+HDEPCT	;PICKUP # SEEK INCOMP ERRORS
	PUSHJ	P,COMPAR
	MOVEI	T1,ERRHN1(P1)
	MOVEI	T2,ERRHN1(P2)
	LDB	T3,[POINT 9,WKBUFF+HDEHNG,8]	;PICKUP # HARD HANGS
	PUSHJ	P,COMPAR
	TLNE	F,F.CHNG
	TLO	S,S.HNG1
	MOVEI	T1,ERRHN2(P1)
	MOVEI	T2,ERRHN2(P2)
	LDB	T3,[POINT 9,WKBUFF+HDEHNG,17]	;PICKUP # SOFT HANG TYPE 1
	PUSHJ	P,COMPAR
	TLNE	F,F.CHNG
	TLO	S,S.HNG2
	MOVEI	T1,ERRHN3(P1)
	MOVEI	T2,ERRHN3(P2)
	LDB	T3,[POINT 9,WKBUFF+HDEHNG,26]	;PICKUP # SOFT HANGS TYPE 2
	PUSHJ	P,COMPAR
	TLNE	F,F.CHNG
	TLO	S,S.HNG3
	MOVEI	T1,ERRHN4(P1)
	MOVE	T2,ERRHN4(P2)
	LDB	T3,[POINT 9,WKBUFF+HDEHNG,35]	;PICKUP # SOFT HANGS TYPE 3
	PUSHJ	P,COMPAR
	TLNE	F,F.CHNG
	TLO	S,S.HNG4
	MOVEI	T1,REDTMP
	MOVEI	T2,REDPER
	MOVE	T3,WKBUFF+HDETRC	;PICKUP TOTAL # READS
	PUSHJ	P,COMPAR
	MOVEI	T1,WRTTMP
	MOVEI	T2,WRTPER
	MOVE	T3,WKBUFF+HDETWC
	PUSHJ	P,COMPAR
	MOVEI	T1,SEKTMP
	MOVEI	T2,SEKPER
	MOVE	T3,WKBUFF+HDETSC
	PUSHJ	P,COMPAR
	PJRST	CNISUM		;GO PERFORM CONI BIT SUMMING

SUM40:	POPJ	P,
	;COMPAR -- SUBROUTINE CALLED BY SUMMATION ROUTINES
	;TO SEE IF COUNTER IS CHANGED SINCE LAST LOOK
	;CALL	MOVEI	T1,XXXTMP	ADDRESS OF COUNT SINCE LAST RELOAD ENTRY
	;	MOVEI	T2,XXXPER	ADDRESS OF COUNT SINCE START OF SUMMATION
	;	MOVE	T3,CURRENT COUNT
	;	PUSHJ	P,COMPAR
	;
	;RETURN	CALL+1



COMPAR:	TLZ	F,F.CHNG	;CLEAR CHANGE IN COUNT FLAG
	CAME	T3,@T1		;COUNT SAME AS OLD?
	SKIPN	T3		;COUNT =0
	POPJ	P,		;YES TO EITHER ABOVE
	TLO	F,F.CHNG	;SAY COUNT CHANGED SINCE LAST LOOK
	CAML	T3,@T1		;COUNT LESS THAN TEMP?
	JRST	CNTMOR		;NO-COUNT IS MORE THAN TEMP
	MOVE	T4,@T1		;RELOAD OCCURRED THEN ERROR
				;PICKUP TEMP
	ADDM	T4,@T2		;PERM =PERM+TEMP
	SETZM	@T1		;CLEAR TEMP
	ADDM	T3,@T1		;TEMP=CURRENT COUNT
	POPJ	P,
CNTMOR:	SUB	T3,@T1		;CHANGE SINCE LAST LOOK
	ADDM	T3,@T1		;TEMP=TEMP+CHANGE
	POPJ	P,
	;TITLST -- SUBROUTINE TO OUTPUT TITLE BLOCK
	;INFO OUTPUT IS DATE AND TIME AND USER REQUESTED STRING
	;CALL	PUSHJ	P,TITLST
	;
	;RETURN	CALL+1

TITLST:	PUSHJ	P,FFPRNT	;DO FORM FEED
	TYPEIT	<
SYSTEM ERROR REPORT COMPILED ON >
	PUSHJ	P,.TDATN	;GO TYPE TODAYS DATE
	TYPEIT	< AT >
	PUSHJ	P,.TTIMN	;GO TYPE CURRENT TIME
	TYPEIT	<	PAGE >
	MOVE	T1,PAGNUM
	PUSHJ	P,.TDECW
	POPJ	P,
	;SUMLST -- SUBROUTINE TO LIST SUMMARY DATUM ON REQUEST
	;SUMMARY TOTALS ARE STORED IN WORDS SUMFST THRU SUMEND
	;ROUTINE WILL CHECK E.LSUM BIT AND OUTPUT DATA ON A ENTRY
	;BY ENTRY TYPE BASIS
	;ENTRIES NOT USED WILL CONTAIN POPJ IN DISPATCH TABLE

SUMLST:	PUSHJ	P,TITLST	;TYPE TITLE LINE
	TYPEIT	<	- SYSTEM ANALYSIS>
	TYPEIT	<
*********************************************************************************


>
	PUSHJ	P,SUMUPD	;GO UPDATE ALL COUNTERS

	PUSHJ	P,ENVLST	;GO DO ENVIRONMENT TYPEOUT
				;THINGS LIKE VERSION,FILE SPECS,SWITCHES,ETC.
	PUSHJ	P,TOTPRT	;PRINT OCCURANCE COUNTS
	MOVSI	P4,-ENTLTH	;SETUP AOBJ POINTER TO ENTCHR TABLE
SMLOOP:	MOVE	T1,ENTCHR(P4)
	TRNN	T1,E.RCNT	;ANY ENTRIES PROCESSED AT ALL?
	JRST	SMBUMP		;BUMP AND GO
	TLNE	T1,E.LSUM
	PUSHJ	P,@SUMDSP(P4)	;GO PROCESS SUMMARY LISTING
SMBUMP:	AOBJN	P4,SMLOOP
	POPJ	P,

	;TOTPRT PRINTS OUT A TOTAL OF EACH ERROR TYPE

TOTPRT:	TYPEIT	<

ENTRY OCCURANCE COUNTS>
	MOVSI	P4,-ENTLTH	;AOBJN POINTER FOR ENTCHR TABLE
TOTCON:	HRRZ	P3,ENTCHR(P4)	;PICKUP ENTCHR WORD
	ANDI	P3,377		;PICKUP BITS 29-35
	JUMPE	P3,CNTINC	;JUST BUMP AOBJ POINTER IF = 0
TOTTYP:	TYPEIT	<
	TOTAL >
	MOVE	T1,TYPMES(P4)	;GET ADDRESS OF ENTRY HEADER
	PUSHJ	P,.TSTRG
	TYPEIT	<:		>
	MOVE	T1,P3		;GET THE COUNT
	PUSHJ	P,.ODECW
CNTINC:	AOBJN	P4,TOTCON	;BUMP COUNTER & TRY AGAIN
	POPJ	P,
	;ENVLST -- SUBROUTINE TO LIST ENVIRONMENT INFORMATION AT SUMMARY TIME
	;CALL	PUSHJ	P,ENVLST
	;TYPES SYSERR VERSION NUMBER,FILE SPECS,SWITCHES
	;RETURN	CALL+1

ENVLST:	TYPEIT	<
FILE ENVIRONMENT>
	TYPEIT	<
	SYSERR VERSION >
	MOVEI	T1,VSYSER	;PICKUP VERSION NUMBER
	PUSHJ	P,.TOCTW
	TYPEIT	<(>
	MOVEI	T1,VEDIT
	PUSHJ	P,.TOCTW
	TYPEIT	<)>
	TYPEIT	<
	INPUT FILE:	>
	MOVEI	T1,I.ST
	PUSHJ	P,.TFBLK	;TYPE INPUT FILE SPEC

	TLNN	F,F.DISK	;DID WE DO EXTENDED LOOKUP ON INPUT DEV
	JRST	ENVCON		;NO
	TYPEIT	<  CREATED: >
	MOVE	T1,FILDAT
	PUSHJ	P,TYPNBS
ENVCON:	TYPEIT	<
	OUTPUT FILE:	>
	MOVEI	T1,O.ST
	PUSHJ	P,.TFBLK	;TYPE OUTPUT SPECIFICATION
	TYPEIT	<
	SWITCHES:	>

	MOVSI	P4,-FLGSTP	;SETUP FOR AOBJ OF FLAG TABLE
				;DON'T DO /BEGIN OR /END YET
SWTCON:	SKIPN	T1,FLGST(P4)	;SWITCH TYPED BY USER?
	PUSHJ	P,TYPSWT	;GO TYPE IT
	AOBJN	P4,SWTCON	;LOOP

	SKIPGE	P4,BEGIN	;DID USER TYPE /BEGIN?
	JRST	ENDCHK		;NO
	TYPEIT	< /BEGIN: >
	MOVE	T1,P4		;PICKUP DATE USER TYPED
	PUSHJ	P,TYPNBS	;TYPE DECODED VALUE

ENDCHK:	SKIPGE	P4,END		;DID HE SAY /END
	JRST	FSTDAT
	TYPEIT	< /END: >
	MOVE	T1,P4		;PICKUP WHAT USER TYPED FOR END DATE
	PUSHJ	P,TYPNBS
FSTDAT:	TYPEIT	<
	DATE OF FIRST ENTRY:	>
	MOVE	T1,FILEST
	PUSHJ	P,TYPNBS
	TYPEIT	<
	DATE OF LAST ENTRY:	>
	MOVE	T1,FILEND
	PUSHJ	P,TYPNBS
	POPJ	P,

TYPSWT:	TYPEIT	</>
	MOVE	T1,SWTABN(P4)
	PUSHJ	P,.TSIXN
	POPJ	P,
TYPNBS:	PUSHJ	P,.CNTDT
	PUSH	P,T1
	MOVE	T1,T2
	PUSHJ	P,.TDATE
	TYPEIT	< AT >
	POP	P,T1
	PUSHJ	P,.TTIME	;TYPE OUT TIME
	POPJ	P,
	;CALCULATE LOWEST NUMBERED ERROR BIT IN USE
	;AND THE NUMBER OF ERROR BITS IN WORD
	RADIX	10		;***** NOTE WELL *****

	DEFINE	TBLDEV(A,B)<
	IFL	A-MINRCB,<MINRCB==A>
	NUMRCB==NUMRCB+1
>

	MINRCB==36
	NUMRCB==0
	DUMRC1


	DEFINE	TBLDEV(A,B)<
	IFL	A-MINRPB,<MINRPB==A>
	NUMRPB==NUMRPB+1
>

	MINRPB==36
	NUMRPB==0
	DUMRP1

	DEFINE	TBLDEV(A,B)<
	IFL	A-MINSFB,<MINSFB==A>
	NUMSFB==NUMSFB+1
>

	MINSFB==36
	NUMSFB==0
	DUMSF1
	RADIX	8
	;SUMUPD -- SUBROUTINE TO AUTOMATICALLY UPDATE ALL PERMANENT
	;SUMMARY COUNTERS PRIOR TO SUMMARY LISTING
	;A DUMMY MACRO DUMFLG IS USED TO GENERATE
	;THE NECESSARY CODE AS FOLLOWS
	;SKIPE	T1,XXXTMP	;PICKUP TEMP COUNTER
	;ADDM	T1,XXXPER	;INCREMENT PERM COUNTER
	;DO NEXT COUNTER SAME.......

	DEFINE	TBLFLG(A)<
	SKIPE	T1,A'TMP
	ADDM	T1,A'PER
>

	;NOW THE ACTUAL CODE GENERATION

	XLIST
SUMUPD:	DUMFLG
	LIST


;NOW GENERATE THE SOFTWARE SUMMARY COUNTERS UPDATE
	DEFINE	DUMDV(A)<
	ZZ==0
REPEAT NUMSFB,<
	SKIPE	T1,A'ST+ZZ
	ADDM	T1,A'SP+ZZ
	ZZ==ZZ+1
>>
	XLIST
	DUMDVA
	LIST

	POPJ	P,		;RETURN
	;HERE LIES THE ROUTINES TO DO ACTUAL SUMMARY OUTPUT

	;SMLXXX -- SUBROUTINES TO LIST SUMMARY DATUM
	;CALL	PUSHJ	P,@SUMDSP(ERROR CODE)
	;
	;RETURN	CALL+1

SML1:	POPJ	P,

SML3:	PUSHJ	P,.TCRLF
	PUSHJ	P,.TCRLF
	MOVE	T1,TYPMES(P4)	;PICKUP ERROR HEADER MESSAGE
	PUSHJ	P,.TSTRG
	TYPEIT	<
	REPRODUCIBLE:		>
	MOVE	T1,TPEPER
	PUSHJ	P,.ODECW
	TYPEIT	<
	NON-REPRODUCIBLE:	>
	MOVE	T1,SPEPER
	PUSHJ	P,.ODECW
	TYPEIT	<
	USER-ENABLED:		>
	MOVE	T1,UEPPER
	PUSHJ	P,.ODECW
	TYPEIT	<
	DETECTED BY DATA
	 CHANNEL BUT NOT
	 SEEN BY CPU:		>
	MOVE	T1,PCSPER
	PUSHJ	P,.ODECW
	POPJ	P,


SML6:	PUSHJ	P,.TCRLF
	PUSHJ	P,.TCRLF
	MOVE	T1,TYPMES(P4)	;PICKUP HEADER TEXT
	PUSHJ	P,.TSTRG
	TYPEIT	<
	NXM'S SEEN BY CHANNEL:	>
	MOVE	T1,NXMPER
	PUSHJ	P,.ODECW
	TYPEIT	<
	MEM PE SEEN BY CHANNEL:	>
	MOVE	T1,MPEPER
	PUSHJ	P,.ODECW
	TYPEIT	<
	CONTROLLER DATA PE:	>
	MOVE	T1,DPEPER
	PUSHJ	P,.ODECW
	POPJ	P,


SML10:	PUSHJ	P,RPTITL	;PRINT RP10 CONTROLLER HEADER
	MOVSI	P2,-NUMRPB	;PICKUP COUNT OF NUMBER OF ENTRIES
	MOVE	P3,[XWD -^D8,0]
	PUSHJ	P,DEVSUM	;GO PUBLISH RP TOTALS FOR CONTROLLER A
	PUSHJ	P,RPTITL	;PRINT RP10 CONTROLLER HEADER
	MOVE	P3,[XWD -^D8,^D8]
	PUSHJ	P,DEVSUM	;PUBLISH RP TOTALS FOR CONTROLLER B
	PUSHJ	P,TITLST
	TYPEIT	<	- FIXED HEAD SYSTEM ANALYSIS>
	TYPEIT	<


				HARDWARE-DETECTED				SOFTWARE-DETECTED>
	TYPEIT	<

             SRH  DUL  ILL  NOT  PWR  SEC  MEM  CTL       ILL>
	TYPEIT	<  OVR  SAT  RIB  CHK  SEK  XFR  XFR  SEK  SFT
             ERR  SEL  BCD  RDY  FAL  PAR  PAR  PAR  NXM  WRT>
	TYPEIT	<  RUN  ERR  ERR  ERR  INC  HG1  HG2  HNG  HNG

>
	MOVSI	P2,-NUMRCB	;PICKUP COUNT OF NUMBER OF RC ENTRIES/BLOCK
	MOVE	P3,[XWD -^D8,^D16]
	PUSHJ	P,DEVSUM
	POPJ	P,
SML40:	POPJ	P,
	;RPTITL -- SUBROUTINE TO PRINT HEADER FOR RP10 CONTROLLER SUMMARY
	;CALL	PUSHJ	P,RPTITL
	;
	;RETURN	CALL+1

RPTITL:	PUSHJ	P,TITLST	;OUTPUT TITLE PAGE
	TYPEIT	<	- MOVABLE HEAD SYSTEM ANALYSIS>
	TYPEIT	<


				HARDWARE-DETECTED					SOFTWARE-DETECTED>
	TYPEIT	<

             CTL  SEC  MEM  WRD  PWR  SRH  OVR       NOT  ILL>
	TYPEIT	<  ILL  SEC  SUR  SAT  RIB  CHK  SEK  XFR  XFR  SEK  SFT
             PAR  PAR  PAR  PAR  FAL  ERR  RUN  NXM  RDY  WRT>
	TYPEIT	<  DTO  ADD  ADD  ERR  ERR  ERR  INC  HG1  HG2  HNG  HNG

>
	POPJ	P,
	;DEVSUM -- SUBROUTINE TO OUTPUT DEVICE ERROR COUNTS
	;SETUP	P2= -# OF WORDS IN BLOCK TO TYPEOUT
	;	P3= XWD -#DEVICES,OFFSET WITH RESPECT TO NAMTBL OF DEVICE TYPE
	;CALL	PUSHJ	P,DEVSUM


DEVSUM:	MOVE	T1,NAMTBL(P3)	;PICKUP DEVICE NAME
	PUSHJ	P,.TSIXN	;TYPE IT IN SIXBIT
	TYPEIT	<  HARD  >
	HLRZ	P1,DEVDSP(P3)	;PICKUP ADDRESS OF HARD ERROR BLOCK
	HLL	P1,P2		;PUT -WORDCOUNT IN LH OF P1
	PUSHJ	P,TYPCNT	;PUBLISH IT
	MOVSI	P1,-NUMSFB	;PICKUP SOFTWARE DETECTED ERR COUNT
	HRR	P1,SOFDSP(P3)	;PICKUP ADDRESS OF SOFT-DET ERROR BLOCK
	PUSHJ	P,TYPCNT
	TYPEIT	<
      SOFT  >
	HRRZ	P1,DEVDSP(P3)
	HLL	P1,P2		;PUT -WORDCOUNT IN LH OF P1
	PUSHJ	P,TYPCNT
	PUSHJ	P,.TCRLF
	PUSHJ	P,.TCRLF
	PUSHJ	P,.TCRLF
	PUSHJ	P,.TCRLF
	PUSHJ	P,.TCRLF
	AOBJN	P3,DEVSUM
	POPJ	P,
	;TYPCNT -- SUBROUTINE TO TYPE ERROR BLOCK COUNTS
	;SETUP	P1= -WORDCOUNT,START ADDRESS OF BLOCK TO TYPE
	;
	;CALL	PUSHJ	P,TYPCNT
	;RETURN CALL+1

TYPCNT:MOVE	T1,(P1)		;PICKUP WORD
	PUSHJ	P,TYPE4		;TYPE IT AS 5 CHARACTER DECIMAL DIGIT CHANGING 0'S TO SPACES
	PUSHJ	P,.TSPAC	;TYPE SPACE
	AOBJN	P1,TYPCNT	;LOOP TILL DONE
	POPJ	P,
	;TYPE4 -- SUBROUTINE TO TYPE 4 DIGIT DECIMAL NUMBER
	;CONVERTING LEADING ZEROS TO SPACES
	;CALL	PUSHJ	P,TYPE4

TYPE4:	MOVSI	T3,-4		;SETUP TO DO 4 DIGITS
	CAILE	T1,^D9999	;IS NUMBER TOO BIG TO TYPE IN 4 DIGITS
	MOVE	T1,^D9999	;SAY IT WAS 9999
	TLZ	F,F.SAWD	;CLEAR BIT SAYING WE SAW A NON-ZERO DIGIT
DIVST:	IDIVI	T1,^D10
	HRLM	T2,(P)		;SAVE REMAINDER ON STACK
	AOBJP	T3,.+2
	PUSHJ	P,DIVST		;ITERATE
	HLRZ	T1,(P)		;PICKUP DIGIT
	TLNE	F,F.SAWD	;HAVE WE SEEN A NON-ZERO DIGIT YET?
	JRST	DIVST1		;YES- TYPE 0 AS 0 NOT SPACE
	CAIN	T1,0		;IS IT A ZERO
	MOVEI	T1,-20		;YES CHANGE IT TO SPACE
DIVST1:	ADDI	T1,60		;DO CONVERSION TO ASCII
	TLZ	T1,-1		;CLEAR THE LH PART OF WORD
	CAIE	T1,40		;IS THIS DIGIT SPACE THEREFORE A ZERO
	TLO	F,F.SAWD	;SAY WE SAY A DIGIT
	PJRST	.TCHAR		;TYPE IT AND LOOP TILL DONE
	SUBTTL	I/O BUFFER CONTROL ROUTINES
	;SUBROUTINE SKIPWD	ADVANCES BYTE POINTER MANUALLY TO SKIP WORDS
	;CALL	PUSHJ	P,SKIPWD
	;RETURN
	;T1= # OF WORDS TO SKIP

SKIPWD:	CAMGE	T1,IBUFF+2	;ENOUGH WORDS IN BUFFER TO SKIP AND STAY IN THIS BUFFER?
	JRST	THISBF		;YES STAY HERE
	SUB	T1,IBUFF+2
	PUSHJ	P,ADVBFF	;NO- GO GET ANOTHER BUFFER
	JRST	SKIPWD		;TRY AGAIN
THISBF:	ADDM	T1,IBUFF+1	;INCREMENT BYTE POINTER
	EXCH	T1,IBUFF+2	;UPDATE BYTE POINTER AND WORD COUNT
	SUBM	T1,IBUFF+2
RETRN:	POPJ	P,


	;ADVBFF	SUBROUTINE TO READ ANOTHER BUFFER
	;CALL	PUSHJ	P,ADVBFF
	;RETURN

ADVBFF:	IN	INPCHN,
	POPJ	P,
	TLNE	F,F.LSUM	;WAS ANY SUMMARY INFO REQUESTED(DEFAULT CASE)
	PUSHJ	P,SUMLST	;YES-GO DO IT
	STATZ	INPCHN,740000
	FATAL	<INPUT ERROR READING FILE ERROR.SYS>
	CLOSE	INPCHN,
	CLOSE	OUTCHN,
	TLNE	F,F.READ	;ERROR IF WERE ARE IN THE PROCESS OF BUFFER XFER
	FATAL	<UNEXPECTED EOF DURING READ OF ERROR.SYS>
	JRST	START		;RESTART PROGRAM CUSP-STYLE


;	SUBROUTINE	GETWD	RETURNS NEXT WORD IN INPUT BUFFER
;	SIMILAR IN NATURE TO GETCHR ROUTINE IN HANDBOOK
;	CALL	PUSHJ	P,GETWD
;	RETURNS WITH WORD IN MASTWD

GETWD:	SOSGE	IBUFF+2
	JRST	GETNXI
GETOK:	ILDB	MASTWD,IBUFF+1
	POPJ	P,

GETNXI:	PUSHJ	P,ADVBFF
	JRST	GETWD

	;SUBROUTINE PUTCHR
	;CALL WITH CHAR TO BE PLACED IN OUTPUT BUFFER IN T1
	;CODE AS IN HANDBOOK

PUTCHR:	SOSG	OBUFF+2
	JRST	PUTOUT
PUTCH:	IDPB	T1,OBUFF+1
	POPJ	P,
PUTOUT:	OUT	OUTCHN,
	JRST	PUTCH
	FATAL	<ERROR DURING OUTPUT>
	SUBTTL	TELETYPE OUTPUT SUBROUTINES
	;SUBROUTINES TO PUT VARIOUS SPECIAL CHARACTER IN OUTPUT BUFFER

FFPRNT:	MOVE	T1,[-PAGLIN]
	MOVEM	T1,LINCNT
	AOS	PAGNUM
	MOVEI	T1,14		;FORM FEED
	PUSHJ	P,CHROUT
	POPJ	P,

SLPRNT:	MOVEI	T1,"/"
	PUSHJ	P,CHROUT
	POPJ	P,

CLPRNT:	MOVEI	T1,":"
	PUSHJ	P,CHROUT
	POPJ	P,


TBPRNT:	MOVEI	T1,"	"		;HORIZ. TAB
	PUSHJ	P,CHROUT
	POPJ	P,

	;CHROUT -- SUBROUTINE CALLED BY SCAN TO OUTPUT CHARS TO TTY
	;IF F.TTYO FLAG SET IN F OR TO PLACE IN OUTPUT BUFFER
	;VIA PUTCHR

CHROUT:	TLNE	F,F.TTYO	;OUTPUT TO TTY?
	JRST	TTYOUT		;YES
	PJRST	PUTCHR		;PUT IN OUTPUT BUFFER AND RETURN

TTYOUT:	OUTCHR	T1		;LET MONITOR DO OUTPUT
	POPJ	P,		;RETURN


	SUBTTL	STORAGE LOCATIONS
INPSPC:	EXP	13
	SIXBIT/DSK/
	XWD	0,IBUFF
OUTSPC:	EXP	0
	SIXBIT/DSK/
	XWD	OBUFF,0
ERRFIL:	XWD	0,35
	Z
	SIXBIT/ERROR/
	SIXBIT/SYS/
	BLOCK	32
LSTFIL:	SIXBIT/ERROR/
	SIXBIT/LST/
	Z
	Z



IARGST:	Z
	Z
	CHROUT		;LOCATION OF TYPEOUT ROUTINE IN SYSERR
	Z
	Z
IAREND==.-1
IARGLN==<IAREND-IARGST>+1	;LENGTH OF ARG BLOCK FOR .ISCAN

TARGST:	IOWD	SWTABL,SWTABN	;DUMMY NAMES FOR USE BY SCAN
	XWD	SWTABD,SWTABM
	SWTABP
	SIXBIT/SYSERR/		;LET HELPER TYPE SYS:SYSERR.HLP FOR USER HELP
	XWD	CLRALL,0
	XWD	DEFINP,DEFOUT	;POINTER TO SUBROUTINES TO SETUP
				;INPUT AND OUTPUT FILE SPEC AREAS
	Z
	Z
	SETSWT
TAREND==.-1
TARGLN==<TAREND-TARGST>Z+1		;LENGTH OF T ARG BLOCK

DUMDAY:	121165		;DUMMY NBS DAY FOR USE BY SCAN
KONMSK:	RCMASK			;MASK FOR ERROR BITS IN RC10 TYPE DEVICE
	RPMASK			;MASK FOR ERROR BIT IN A RP10 TYPE DEVICE
	SFMASK			;SOFTWARE DETECTED ERROR MASK
MINERB:	MINRCB
	MINRPB
	MINSFB
ERINDX:	RCINDX
	RPINDX
	SFINDX
IDVFLT:	SIXBIT/DSK/		;DEFAULT FILE SPECIFICATIONS
IFLFLT:	SIXBIT/ERROR/
IEXFLT:	SIXBIT/SYS/
ODVFLT:	SIXBIT/DSK/
OFLFLT:	SIXBIT/ERROR/
OEXFLT:	SIXBIT/LST/

PDLPNT:	IOWD	LPDL,PDLST
	SUBTTL	DUMMY MACRO EXPANSION AREA
	;THE FOLLOWING MACRO CODE UTILIZES THE PRINCIPLE OF THE DUMMY
	;MACRO USED EARLIER AND REDEFINES TBLENT TO GENERATE VAIOUS
	;NECESSARY DISPATCH TABLES

	;THE ENTRY PROCESSING TABLE

	DEFINE	TBLENT(A,B,C,D,E)<XWD	C,D
	TYPMAX==A
>
PCSTBL:	DUMENT


	;GENERATE THE VARIOUS ASCIZ MESSAGES TO BE USED FOR HEADER
	;ENTRY TYPE IDENTIFICATION
	;FORMAT WILL BE MESS(#) WHERE MESS IS THE ENTRY TYPE
	;DESCRIPTION AND # IS THE ERROR TYPE

	DEFINE	TBLENT(A,B,C,D,E)<
	[ASCIZ/B'(CODE 'A')/]
>


	;GENERATE THE TEXT


	XLIST
TYPMES:	DUMENT
	LIST

	;END OF ENTRY DESCRIPTOR GENERATOR


	;GENERATE THE DISPATCH TABLE TO ENTRY SUMMATION AND BIT CHECK ROUTINES
	;ALL WILL RETRN VIA POPJ	P,
	;TABLE IS INDEXED BY ERROR TYPE CODE

	DEFINE	TBLENT(A,B,C,D,E)<
IFDIF<B><UNKNOWN TYPE>,<	XWD	0,BCK'A>
	IFIDN<B><UNKNOWN TYPE>,<	XWD	0,[POPJ	P,]>
>
	;GENERATE THE TABLE

BITCHK:	DUMENT


	;GENERATE THE TABLE OF LINE COUNTS FOR OUTPUT LISTING

	DEFINE	TBLENT(A,B,C,D,E)<
	XWD	0,E
>

	RADIX	10

LINE:	DUMENT

	RADIX	8
	;GENERATE THE DISPATCH TABLE TO ENTRY SUMMATION ROUTINES
	;ALL WILL RETRN VIA POPJ	P,
	;TABLE IS INDEXED BY ERROR TYPE CODE

	DEFINE	TBLENT(A,B,C,D,E)<
IFDIF<B><UNKNOWN TYPE>,<	XWD	0,SML'A>
	IFIDN<B><UNKNOWN TYPE>,<	XWD	0,[POPJ	P,]>
>
	;GENERATE THE TABLE

SUMDSP:	DUMENT


	;GENERATE THE VARIOUS ENTRY CONTROL TABLES USING THE MACRO TBLWRD
	;TO GENERATE TABLES

	DEFINE	TBLWRD(A,B,C,D,E,F)<
	IFDIF<D><SPECL>,<	BYTE	(6)B,C,D(18)T'A'E>
	IFIDN<D><SPECL>,<	BYTE	(6)B,C,D(18)F>

>
	RADIX	10		;*********NOTE WELL***********

.CT001:	DUM001
	Z
.CT003:	DUM003
	Z
.CT006:	DUM006
	Z
	;FALL INTO BUILDING OF CT010 CONTROL TABLE
.CT010:	DUM010
	Z
.CT040:	DUM040
	Z

	RADIX	8

	;END OF ENTRY TABLE GENERATION
	;GENERATE THE NECESSARY ASCIZ TEXT FOR NON-SPECIAL ROUTINES

	DEFINE	TBLWRD(A,B,C,D,E,F)<
	IFDIF	<D><SPECL>,<
T'A'E:	ASCIZ/
F/
>>


	XLIST
	DUMALL
	LIST




	;END OF ASCIZ TEXT MACRO EXPANSION
	;SWITCH TABLES
	;THE FOLLOWING TABLES WILL BE GENERATED VIA THE DUMMY MACRO
	;DUMCH1
	;THE FIRST IS A DISPATCH TABLE TO BYTES REPRESENTING BITS TO SET
	;IN THE ENTCHR TABLE
	;NEXT IS THE ACTUAL BYTES THEMSELVES

	;TABLE FOR DISPATCH TO THE BYTE OPERANDS

	DEFINE	TBLCH1(A,B,C,D,E,F,G)<
	XWD	0,BYT'G
>

	;MAKE DISPATCH TABLE

BYTDSP:	DUMCH1
	;NOW THE BYTES THEMSELVES


	DEFINE	TBLCH1(A,B,C,D,E,F,G)<
BYT'G:	BYTE (6) B,77,C,77,D,77,E,77,F,77
>


	DUMCH1


	;SWITCH MACRO EXPANSION NEXT


	;DEFINE THE SWITCHES WE RECOGNIZE

	DEFINE	TBLCH1(A,B,C,D,E,F,G)<
	SS	(A,A,0)
>
	DEFINE	TBLCH2(A,B,C)<
	SP	(A,A,B,C)
>

	;NOW MAKE SWTCHS MACRO FOR USE WITH DOSCAN LATER

	DEFINE	SWTCHS<
	DUMCH1
	DUMCH2
>

	XLIST
	DOSCAN(SWTAB)
	LIST


	;GENERATE THE CONI BIT TEXT AND ADDRESS DISPATCHER
	RADIX	10		;****** NOTE WELL *****

	DEFINE	TBLDEV(A,B)<
	[ASCIZ\B',\]
>

	RC10DV:	DUMRC1

	DEFINE	TBLDEV(A,B)<
	[ASCIZ\B',\]
>
	RP10DV:	DUMRP1


	DEFINE	TBLDEV(A,B)<
	[ASCIZ\B',\]
>

	SOFTDV:	DUMSF1
	;NOW GENERATE THE ERROR BIT VS INDEX BIT TABLES
	;THIS ALLOWS NON-CONTIGUOUS ERROR BITS IN CONI WORD
	;TO BE COUNTED IN CONTIGUOUS COUNTERS

	DEFINE	TBLDEV(A,B)<
	ZZP==.
	RELOC	RCINDX+A-MINRCB
	ZZ
	ZZ==ZZ+1
	RELOC	ZZP
>

	XLIST
RCINDX:	REPEAT	36-MINRCB,<0>
	LIST
	ZZ==0
	DUMRC1


	DEFINE	TBLDEV(A,B)<
	ZZP==.
	RELOC	RPINDX+A-MINRPBA
	ZZ
	ZZ==ZZ+1
	RELOC	ZZP
>

	XLIST
RPINDX:	REPEAT	36-MINRPB,<0>
	LIST
	ZZ==0
	DUMRP1



	DEFINE	TBLDEV(A,B)<
	ZZP==.
	RELOC	SFINDX+A-MINSFB
	ZZ
	ZZ==ZZ+1
	RELOC	ZZP
>

	XLIST
SFINDX:	REPEAT	36-MINSFB,<0>
	LIST
	ZZ==0
	DUMSF1

	RADIX	8		;	***** DONE WITH RADIX 10 *****
	;GENERATE SIXBIT TABLE OF DEVICE NAMES

	DEFINE	DUMDV(A)<
	SIXBIT/A/
>
NAMTBL:	DUMDVA
NAMLTH=<.-1>-NAMTBL+1	;LENGTH OF TABLE OF SIXBIT NAMES

	;GENERATE CONI BIT ERROR DISPATCHER
	;RH = SOFT ERROR POINTER
	;LH = HARD ERROR POINTER

	DEFINE	DUMDV(A)<
	XWD	A'HD,A'SF
>

DEVDSP:	DUMDVA



	DEFINE	DUMDV(A)<
	XWD	A'ST,A'SP
>
SOFDSP:	DUMDVA
	;GENERATE THE DEVICE ERROR BIT MASK USING THE DUMMY MACROS

	DEFINE	TBLDEV(A,Y)<
	RCMASK==RCMASK!1B'A
>
	RCMASK==0 
	DUMRC1


	DEFINE	TBLDEV(A,Y)<
	RPMASK=RPMASK!1B'A
>
	RPMASK==0
	DUMRP1

	DEFINE	TBLDEV(A,Y)<
	SFMASK=SFMASK!1B'A
>
	SFMASK==0
	DUMSF1
	;HERE LIES THE START OF THE LOW SEGMENT STORAGE
	;AND VOLATILE MACRO TABLES

	ZZPNT==.
	RELOC	LOWBEG		;PUT THIS CODE IN NULL LOW SEG
LOWBEG:	;START OF LOW SEGMENT ZEROING AREA



INPBLK:	BLOCK	3
OUTBLK:	BLOCK	3
INPFIL:	BLOCK	36
OUTFIL:	BLOCK	3
BLTEND:	BLOCK	1		;THIS IS REALLY LAST LOCATION IN OUTFIL BLOCK
IBUFF:	BLOCK	3
OBUFF:	BLOCK	3
	;INPUT SPECIFICATION FILE BLOCK

A.ZER:			;START OF FILE ZEROING AREA FOR SCAN USE
I.ST:				;DUMMY START OF INPUT BLOCK SPECIFICATIONS
I.DEV:	BLOCK	1		;INPUT DEVICE DEFAULT TO DSK
I.NAM:	BLOCK	1		;FILENAME(NON-ZERO IF ANYTHING TYPED)
I.NAMM:	BLOCK	1		;UNUSED
I.EXT:	BLOCK	1		;EXTENSION IN LH OF WORD
I.MOD:	BLOCK	1		;UNUSED
I.MODM:	BLOCK	1		;UNUSED
I.DIR:	BLOCK	1		;PPN OR ZERO IF DEFAULT TO USER'S
I.DIRM:	BLOCK	.FXLND*2-1	;DUMMY AREA FOR COMPATIBILITY WITH SCAN
I.BFR:	BLOCK	1		;NBS STANDARD TIME/DATE ARG RET WITH /BEFORE SWITCH
I.SNC:	BLOCK	1		;NBS /SINCE ARG
I.END==.-1			;LAST LOCATION IN INPUT SPECIFICATION AREA
I.LNGH==I.END-I.ST+1		;LENGTH OF SPECIFICAATION BLOCK


	;OUTPUT SPECIFICATION FILE BLOCK

O.ST:				;DUMMY START OF OUTPUT BLOCK SPECIFICATIONS
O.DEV:	BLOCK	1		;OUTPUT DEVICE DEFAULT TO DSK
O.NAM:	BLOCK	1		;FILENAME(NON-ZERO IF ANYTHING TYPED)
O.NAMM:	BLOCK	1		;UNUSED
O.EXT:	BLOCK	1		;EXTENSION IN LH OF WORD
O.MOD:	BLOCK	1		;UNUSED
O.MODM:	BLOCK	1		;UNUSED
O.DIR:	BLOCK	1		;PPN OR ZERO IF DEFAULT TO USER'S
O.DIRM:	BLOCK	.FXLND*2-1	;DUMMY AREA FOR COMPATIBILITY WITH SCAN
O.BFR:	BLOCK	1		;NBS STANDARD TIME/DATE ARG RET WITH /BEFORE SWITCH
O.SNC:	BLOCK	1		;NBS /SINCE ARG
O.END==.-1			;LAST LOCATION IN INPUT SPECIFICATION AREA
O.LNGH==O.END-O.ST+1	;LENGTH OF SPECIFICATION BLOCK

	;TABLE OF SWITCH FLAG LOCATIONS

	DEFINE	TBLCH1(A,B,C,D,E,F,G)<
A:	BLOCK	1
>
	DEFINE	TBLCH2(A,B,C)<
A:	BLOCK	1
>

	FLGST=.			;TO ALLOW CALCULATION OF SWITCH OFFSET IN TABLE
	DUMCH1			
	FLGSTP==<.-1>-FLGST		;DO NOT SET BITS IN ENTRY CHARACTERISTICS TABLE
				;FOR ANY FLAGS PAST THIS
				;THEY ARE /BEGIN,/END,/LIM ETC.
	DUMCH2
	FLGND=.-1
	FLGLTH=FLGND-FLGST+1	;LENGTH OF TABLE


	;GENERATE THE SUMMARY COUNTERS

	DEFINE	TBLFLG(A)<
A'TMP:	BLOCK 1
A'PER:	BLOCK 1
>
SUMFST=.
	DUMFLG
SUMFND=.-1
.LBN:	BLOCK	1		;STORAGE LOCATION FOR LOGICAL BLOCK NUM OF LAST ERROR
ERTYPE:	BLOCK	1
HEADWC:	BLOCK	1
ENTRWC:	BLOCK	1
TOTWC:	BLOCK	1
.DATE:	BLOCK	1		;TODAYS DATE
.TIME:	BLOCK	1		;CURRENT TIME
STDATE:	BLOCK	1
ENDATE:	BLOCK	1
MSTIME:	BLOCK	1		;TIME IN MS OF LAST ENTRY PROCESSED
BADTYP:	BLOCK	1		;STORE ILLEGAL OR UNKNOWN ERROR TYPES HERE
OFFSET:	BLOCK	1		;STORE AOBJN OFFSET HERE FOR LATER ACCESS TO WORKING BUFFER
AOBPNT:	BLOCK	1		;AOBJN POINTER STORAGE
FILDAT:	BLOCK	1		;CREATION DATE OF SYSTEM ERROR FILE
FILEST:	BLOCK	1		;DATE/TIME OF FIRST ENTRY
FILEND:	BLOCK	1		;DATE/TIME OF LAST ENTRY
PAGNUM:	BLOCK	1
LINCNT:	BLOCK	1
KONTYP:	BLOCK	1
DVINDX:	BLOCK	1
HDBUFF:	BLOCK	HDSIZE
WKBUFF:	BLOCK	WKSIZE
PDLST:	BLOCK	LPDL
A.ZEND==.-1				;END OF AREA TO CLEAR ON INITIALIZATION
	DEFINE	TBLENT(A,B,C,D,E)<
	ENTLTH=ENTLTH+1
	TYPMAX=A
>

	;GENERATE THE ENTCHR TABLE

	ENTLTH=0
	DUMENT
ENTCHR:	BLOCK	ENTLTH
CHREND==.-1
	;GENERATE THE ACTUAL ERROR BIT COUNTERS

	DEFINE	DUMDV(A)<
A'SF:	BLOCK NUMRCB
A'HD:	BLOCK NUMRCB
>


	DUMFHA
	DUMFHB


	DEFINE	DUMDV(A)<
A'SF:	BLOCK NUMRPB
A'HD:	BLOCK NUMRPB
>
	DUMDPA
	DUMDPB

	DEFINE	DUMDV(A)<
A'ST:	BLOCK NUMSFB
A'SP:	BLOCK NUMSFB
>


	DUMDVA
LOWEND==.-1			;END OF AREA TO ZERO ON INITIALIZATION OF LOWSEG
	RELOC	ZZPNT

	XLIST
	LIT
	END	START
  I,