!***COPYRIGHT 1973, DIGITAL EQUIPEMENT CORP., MAYNARD, MASS.***
!AUTHOR: F.J. INFANTE
GLOBAL BIND ACT1V=65;	!20-JUNE-73
SWITCHES LIST;
	FORWARD
		FUNCGEN,	!P.26
		TYPEGEN,	!P.27
		TMPGEN,		!P.28
		BLDDIM,		!P.29
		BLDARRAY,	!P.32
		BLKSRCH,	!P.35
		BLDVAR,		!P.36
		OUTPUTEXPR,	!P.37
		DATALIST,	!P.38
		BLDFORMAT,	!P.39
		BLDUNIT;	!P.40

GLOBAL ROUTINE FUNCGEN (FPNT)=
BEGIN
	MAP BASE T1:T2:FPNT;REGISTER BASE R1:R2;
	EXTERNAL SAVSPACE %(SIZE,LOC)%,TYPE,IDTYPE,PROGNAME,CORMAN %()%,
		NEWENTRY %()%,STK,NAME;
	MACRO
	FCTN = 4$, ENT=1$,
	ELMNT=0,0,FULL$,ELMNT1=0,1,FULL$,ELMNT2=0,2,FULL$,
	ERR28=(RETURN ERROUT(E28))$,
	ERR40=(ENTRY[1]_R1[IDSYMBOL];RETURN ERROUT(E40))$;

	!------------------------------------------------------------------------
	!THIS ROUTINE IS CALLED WITH THE PARAMETER FPNT POINTING TO
	!THE LIST:
	!
	!IDENTIFIER (20^18+LOC) - SUBPROGRAM NAME
	!OPTION 0 - NO ARGUMENTS, ILLEGAL IF THIS IS A FUNCTION
	! OR
	!OPTION 1 - ARGUMENT LIST POINTER FOLLOWS
	!	COUNT^18+LOC - POINTS TO LIST POINTER
	!		1^18+LOC - POINTS TO LIST OF
	!		CHOICE 1 - DUMMY ARGUMENT
	!			IDENTIFIER (20^18+LOC)
	!		CHOICE 2 - DUMMY LABEL
	!
	!THE LOCATION TYPE IS NON-ZERO (4) FOR A FUNCTION STATEMENT
	!AND ZERO FOR A SUBROUTINE OR ENTRY STATEMENT.  AN ARGUMENT
	!LIST MUST BE PRESENT IF TYPE IS NON-ZERO.  IF THE FUNCTION
	!WAS TYPED, IDTYPE WILL CONTAIN THE TYPE OTHERWISE IT CONTAINS -1
	!------------------------------------------------------------------------
	R1_.FPNT[ELMNT];!R1_LOC (SUBPROGRAM NAME)
	IF ISDEFIND(R1) THEN ERR40
		ELSE IF .R1[OPERSP]NEQ VARIABLE THEN ERR40;
	IF .FPNT[ELMNT1]EQL 0 THEN ! NO ARGUMENTS
	BEGIN
		IF .TYPE EQL FCTN THEN ERR28; !FUNCTION SUBPROGRAM
		R2_0
	END
	ELSE
	BEGIN
		!--------------------------------------------------------------------
		!CREATE AN ARGUMENT LIST ON THE UNUSED PORTION OF THE
		!LEXEME STACK (STK[2] THRU STK[100]).  THIS IS NECESSARY
		!BECAUSE THE EXACT NUMBER OF ARGUMENTS IS NOT KNOWN.
		!THE ARGUMENT LIST PRODUCED BY SYNTAX CONTAINS 2 WORDS
		!(CHOICE 1) FOR EACH DUMMY ARGUMENT BUT ONLY 1 WORD
		!FOR ACH DUMMY LABEL (CHOICE 2).  THE PROPORTION OF
		!EACH ARGUMENT TYPE IS NOT KNOWN UNTIL THE LIST IS SCANNED.
		!--------------------------------------------------------------------
		T2_.FPNT[ELMNT2];T1_.T2[ELMNT];SAVSPACE(0,@T2);
		T2_STK[3]<0,0>;!T1_LOC(GENERATED ARG LIST),SET COUNT T2 TO LOC OF ARGLIST
		INCR ALST FROM @T1 TO @T1+.T1<LEFT>DO
		BEGIN
			MAP BASE ALST;
			T2_.T2+1;
			IF .ALST[ELMNT] EQL 1 THEN !DUMMY ARGUMENT
			BEGIN
				T2[ELMNT]_R2<RIGHT>_.ALST[ELMNT1];
				IF .R2[OPRCLS] EQL DATAOPR THEN T2[P1AVALFLG] _ 1;
				IF .R2[IDDIM] EQL 0
				 THEN R2[OPERSP]_FORMLVAR !IF NOT DIMENSIONED THEN VARIABLE
				 ELSE
				   BEGIN
				     LOCAL BASE DIMPTR;
				     R2[OPERSP] _ FORMLARRAY;
				      DIMPTR _ .R2[IDDIM];
				     IF .DIMPTR[ARADDRVAR] EQL 0
					THEN IF NOT  .DIMPTR[ADJDIMFLG]
					  THEN BEGIN
						LOCAL BASE PTRVAR;
						ENTRY[0] _ .R2[IDSYMBOL];
						NAME _ IDTAB;
						PTRVAR _ NEWENTRY();
						PTRVAR[VALTYPE] _ INTEGER;
						PTRVAR[OPERSP] _ FORMLVAR;
						DIMPTR[ARADDRVAR] _ .PTRVAR;
						END;
				   END;
				IF .TYPE NEQ ENT
				THEN IF .R2[IDATTRIBUT(DUMMY)]
					THEN (ENTRY[1] _ R2[IDSYMBOL]; ERROUT(87));	!DUPLICATE DUMMY ARGS
				R2[IDATTRIBUT(DUMMY)]_-1;  !DUMMY ARGUMENT
				IF .TYPE EQL FCTN THEN IF .R2<RIGHT> EQL .R1<RIGHT>
				THEN ! ARGUMENT IS SAME AS FUNCTION
				  (ENTRY[1] _ R2[IDSYMBOL]; ERROUT(71););
			END
			ELSE T2[ELMNT]_0; !DUMMY LABEL
			IF .ALST[ELMNT] NEQ 2 THEN ALST_.ALST+1; !IF ARG IS NOT A $ THE SKIP BY 1
		END;SAVSPACE(.T1<LEFT>,@T1);
		!------------------------------------------------------------------------
		!THE FOLLOWING CODE SETS UP T1 AS THE BLT POINTER
		!(SOURCE ADDRESS ^18+ DESTINATION ADDRESS AND T2 AS THE FINAL
		!ADDRESS.  R2 POINTS TO THE BEGINNING OF THE ARG BLOCK CREATED.
		!ITS FIRST WORD CONTAINS THE ARG COUNT.
		!------------------------------------------------------------------------
		STK[2]_0;	!LINK WORD
		T2_.T2-STK[3]<0,0>; !NUMBER OF ARGUMENTS
		STK[3] _ .T2;
		NAME<LEFT> _ T2_ .T2+2; !ARG BLOCK CONTAINS 2+ NUM OF ARGS
		T2_.T2-1+(T1<RIGHT>_R2_CORMAN());
		T1<LEFT>_STK[2]<0,0>; BLT(T1,0,T2);!COPY ARG LIST FROM STACK
	END;
	NAME_IDOFSTATEMENT_ENTRDATA;NAME<RIGHT>_SORTAB;T1_NEWENTRY();
	IF @IDTYPE GEQ 0 THEN R1[VALTYPE]_@IDTYPE;
	IF .TYPE NEQ ENT THEN PROGNAME _ .R1[IDSYMBOL]; !DON'T CHANGE PROGNAME IF ENTRY NODE
	IF .TYPE EQL FCTN THEN R1[OPERSP]_FNNAME
		ELSE IF .TYPE EQL ENT THEN T1[ENTNUM] _ -1;
	IF .TYPE NEQ 0	!NOT A SUBROUTINE DEFINITION
	   THEN R1[IDATTRIBUT(FENTRYNAME)] _ 1 !SET ENTRY NAME BIT FOR ALLOCATION
	ELSE	!ITS A SUBROUTINE SET A BIT TO PREVENT ALLOCATION OF
	!THE NAME AS A LOCAL
		R1[IDATTRIBUT(NOALLOC)]_1;

	T1[ENTSYM]_@R1;T1[ENTLIST]_@R2;
	SAVSPACE(.FPNT<LEFT>,@FPNT);
END;
GLOBAL ROUTINE TYPEGEN(TLST) =
BEGIN
	MAP BASE T1:T2; REGISTER BASE R1:R2;
	EXTERNAL SAVSPACE %(SIZE,LOC)%,STK,BLDARRAY %(ONEARRAY LIST POINTER)%;
	MACRO
	ELMNT=0,0,FULL$,ELMNT1=0,1,FULL$,ELMNT2=0,2,FULL$;
!-----------------------------------------------------------------------
!	THIS ROUTINE IS CALLED WITH THE PARAMETER TLST
!	POINTING TO A LIST OF ELEMTNTS. EACH
!	ELEMENT POINTS TO A LIST OF SCALAR OR ARRAY DEFINITIONS
!	(ONEARRAY) FOLLOWED BY AN OPTIONAL LIST OF VALUES. UNTIL
!	THE ROUTINES TO HANDLE DATA SPECIFICATIONS HAVE BEEN
!	WRITTEN THESE VALUE LISTS WILL BE IGNORED.
!-----------------------------------------------------------------------
	INCR DLST FROM @TLST TO @TLST+.TLST<LEFT> DO
	BEGIN
		MAP BASE DLST;
		R1_.DLST[ELMNT];
		!IF A VALUELIST IS PRESENT THEN BLDARRAY
		!MUST SAVE ALL THE SCALAR AND ARRAY NAMES IT FINDS, PROBABLY ON THE STACK
		IF BLDARRAY(.R1[ELMNT]) LSS 0 THEN RETURN .VREG;
		IF.R1[ELMNT1] NEQ 0 THEN				!OPTIONAL VALUELIST IS PRESENT
		BEGIN
			ERROUT(84);	!OPTIONAL VALUE LIST NOT SUPPORTED
			T1_.R1[ELMNT2];					!T1_LOC(VALUELIST)
!			T2_.T1[ELMNT1];					!T2_LOC(LIST OF CONSTANTS)
!			INCR CLST FROM @T2 TO @T2+.T2<LEFT> BY 2 DO
!			BEGIN
!				MAP BASE CLST;
!				IF .CLST[ELMNT] EQL 1 THEN		!CONSTANT POSSIBLY A REPEAT COUNT
!				BEGIN
!					R1_.CLST[ELMNT1];
!					IF .R1[ELMNT1] NEQ 0 THEN
!					BEGIN				!SAVE REPEATED CONSTANT SPACE
!						R2_.R1[ELMNT2];SAVSPACE(.R2<LEFT>,@R2)
!					END;
!					SAVSPACE(.R1<LEFT>,@R1);	!SAVE CONSTANT SPACE
!				END;
!			END; SAVSPACE(.T2<LEFT>,@T2);			!SAVE CONSTANT LIST SPACE
			SAVSPACE(.T1<LEFT>,.T1);			!SAVE VALUE LIST SPACE
		END
	END;
END;
GLOBAL ROUTINE TMPGEN (TYPE) =
BEGIN
	EXTERNAL TMPCNT[4],TBLSEARCH %()%;
	BIND TMPNAM=PLIT(
	%0%	SIXBIT 'TM.000',
	%1%	SIXBIT 'MF.000',
	%2%	SIXBIT 'OF.000',
	%3%	SIXBIT 'SZ.000');
	REGISTER BASE R3,R2,R1;MACHOP IDIVI=#231,LSHC=#246;
	R1_.TMPCNT[.TYPE]_.TMPCNT[.TYPE]+1;
	DECR I FROM 2 TO 0 DO (IDIVI(R1,10);LSHC(R2,-6));
	ENTRY[0]_.TMPNAM[.TYPE]+.R3<LEFT>;
	NAME_IDTAB;R3_TBLSEARCH();
	IF .TYPE EQL 0 THEN R3[OPR1]_VARFL;
	RETURN .R3
END;
GLOBAL ROUTINE BLDDIM (SSLST) =
BEGIN
	REGISTER BASE R1:R2;
	LOCAL HISIGN,LOSIGN;
	EXTERNAL NEWENTRY %()%,SAVSPACE %(SIZE,LOC)%,IDTYPE,STK,CORMAN %()%,TBLSEARCH %()%,ONEPLIT,FARRY;
	MAP BASE T1:T2:FARRY;
	MACRO ERR46 = ( ENTRY[1]_FARRY[IDSYMBOL]; ERROUT(46))$;
	MACRO
	ELMNT=0,0,FULL$,ELMNT1=0,1,FULL$,ELMNT2=0,2,FULL$,ELMNT3=0,3,FULL$;
	MACHOP BLT=#251;
	!----------------------------------------------------------------------------------------------------------
	!SSLST POINTS TO A LIST OF SUBSCRIPTS OF THE FORM:
	!
	!CHOICE 1 - SUBSCRIPT IS A CONSTANT
	!	CONSTANT (21^18+LOC)
	!CHOICE 2 - SUBSCRIPT IS AN IDENTIFIER
	!	IDENTIFIER (20^18+LOC)
	!OPTION 0 - SUBSCRIPT IS UPPER BOUND, LOWER BOUND IS ONE
	!OPTION 1 - SUBSCRIPT IS LOWER BOUND
	!	COUNT^18+LOC - POINTER TO UPPER BOUND
	!		DIVIDE
	!		CHOICE 1 - SUBSCRIPT IS A CONSTANT
	!			CONSTANT (21^18+LOC)
	!		CHOICE 2 - SUBSCRIPT IS AN IDENTIFIER
	!			IDENTIFIER (20^18+LOC)
	!
	!SINCE THE KNOWLEDGE OF WETHER OR NOT THE DIMENSIONS ARE ADJUSTABLE OR IN ERROR IS NOT KNOWN UNTIL THE
	!LIST HAS BEEN SCANNED, A PSEUDO DIMENSION NODE IS CREATED ON THE UNUSED PORTION OF THE STACK
	! (STK[2] - STK[100]).
	!----------------------------------------------------------------------------------------------------------
	BIND ADJUSTABLE=STK[2],DNUM=STK[3]<LEFT>,ASIZE=STK[3]<RIGHT>,AOFF=STK[4],MF=1,OS=2,SZ=3;
	MACRO VARFLGS=0,3,LEFT$;
	!----------------------------------------------------------------------------------------------------------
	!OMITTING THE EXTRA CODE TO FETCH CONSTANTS AND STORE VALUES, THE ARRAY SIZE, ARRAY OFFSET, AND
	!SUBSCRIPT MULTIPLICATION FACTOR ARE CALCULATED IN THE FOLLOWING MANNER:
	!
	!IF .IDTYPE GEQ DOUBLPREC THEN WORDSIZE_2 ELSE WORDSIZE_1;
	!ARRAYSIZE_.WORDSIZE;ARRAYOFFSET_0;
	!INCR I FROM 1 TO NUMBEROF DIMENSIONS DO
	!BEGIN
	!	FACTOR(.I)_.ARRAYSIZE;
	!	ARRAYOFFSET_.ARRAYOFFSET+.FACTOR(.I)*.LOWERLIMIT(.I);
	!	SUBSCRIPTSIZE_.UPPERLIMIT(.I)-.LOWERLIMIT(.I)+1;
	!	ARRAYSIZE_.ARRAYSIZE*.SUBSCRIPTSIZE;
	!END;
	!
	!FOR EXAMPLE:
	!
	!DOUBLE PRECISION A(2/5,3/5,4/5)
	!
	!WOULD PRODUCE
	!
	!FACTOR=		2	8	24
	!ARRAYOFFSET=		4	28	124
	!SUBSCRIPTSIZE=		4	3	2
	!ARRAYSIZE=		8	24	48
	!
	!THUS USING BLISS NOTATION, THE SECOND ELEMENT OF A, A(3,3,4) IS
	!.(A+2*3+8*3+24*4-124) WHICH EQUALS .(A+2) . THE ARRAY SIZE SPECIFIES THE
	!NUMBER OF WORDS OCCUPIED BY THE ARRAY, THUS IN THE ABOVE EXAMPLE ARRAY A OCCUPIES LOCATIONS A THRU A+47.
	!----------------------------------------------------------------------------------------------------------

	EXTERNAL INITLTEMP;
	ROUTINE ERRA =
	BEGIN
		ENTRY[1]_FARRY[IDSYMBOL];RETURN ERROUT(E31)
	END;
	ROUTINE ERRB (X)=
	BEGIN
		MAP BASE X;
		ENTRY[1]_X[IDSYMBOL];
		IF .X[OPERSP] GEQ FNNAME THEN ENTRY[2]_FNPLIT
			ELSE IF .X[OPERSP] GEQ ARRAYNAME THEN ENTRY[2]_ARPLIT
				ELSE RETURN ERROUT(E30);
		RETURN ERROUT(E34)
	END;
	T2_STK[3]<0,0>;
	IF .IDTYPE GEQ DOUBLPREC THEN ASIZE_2 ELSE ASIZE_1;
	ADJUSTABLE_AOFF_DNUM_0;
	INCR SS FROM @SSLST TO @SSLST+.SSLST<LEFT> DO
	BEGIN
		MAP BASE SS;
		HISIGN_LOSIGN_0;
		T2[VARFLGS]_0;T1_.SS[ELMNT];
		IF .T1[ELMNT] NEQ 0
		  THEN(IF .T1[ELMNT] EQL 2 THEN HISIGN_-1;
			T1_.T1+2;
		      )
		  ELSE T1_.T1+1;
		R1_.T1[ELMNT1];
		IF .R1[VALTYPE] NEQ INTEGER THEN RETURN ERRA();
		CASE .T1[ELMNT2] OF SET
		BEGIN	!OPTION 0 - LOWER LIMIT IS 1 BY DEFAULT
			T2[DIMENL(0)]_.ONEPLIT;
			IF .T1[ELMNT] EQL 1 THEN
			BEGIN	!CHOICE 1 - R1 = CONSTANT POINTER
				IF .HISIGN NEQ 0 THEN ERR46;!NO NEGATIVE DIMENSION
				T2[DIMENU(0)]_.R1;
			END
			ELSE
			BEGIN	!CHOICE 2 - R1 = IDENTIFIER POINTER
				IF .HISIGN NEQ 0 THEN ERR46;
				IF .R1[OPERSP] NEQ FORMLVAR THEN RETURN ERRB(.R1);
				T2[DVARUBFLG(0)]_1;T2[DIMENU(0)]_@R1;ADJUSTABLE_-1;
			END;
			IF .ADJUSTABLE EQL 0 THEN
			BEGIN
				NAME_CONTAB;ENTRY[0]_0;ENTRY[1]_.ASIZE;SYMTYPE_INTEGER;
				T2[DFACTOR(0)]_TBLSEARCH();
				AOFF_.AOFF-.ASIZE;ASIZE_.ASIZE*.R1[CONST2];
			END
			ELSE
			BEGIN
				T2[DVARFACTFLG(0)]_1;T2[DFACTOR(0)]_0;
			END;
		END;
		BEGIN	!OPTION 1 - BOTH LOWER AND UPPER LIMITS ARE SPECIFIED
			LOCAL SAVPTR;	!FOR SAVING PTR FOR CALL TO SAVSPACE
			IF .T1[ELMNT] EQL 2 THEN
			BEGIN	!CHOICE 2 - R1=IDENTIFIER POINTER
				IF .HISIGN NEQ 0 THEN ERR46;
				IF .R1[OPERSP] NEQ FORMLVAR THEN RETURN ERRB(.R1);
				T2[DVARLBFLG(0)]_1;ADJUSTABLE_-1;
			END;
			T1_.T1[ELMNT3]; !GET PTR TO UPPER BOUND BLOCK
			SAVPTR _ .T1;	!SAVING PTR FOR SAVSPACE CALL LATER
			IF .HISIGN NEQ 0 THEN IF .R1[OPERSP] EQL CONSTANT
			   THEN R1 _ MAKECNST(INTEGER,0,-.R1[CONST2]); !MAKE NEG CONST NODE
			T2[DIMENL(0)] _ .R1; !LOWER BOUND
			!T1 NOW POINTS TO UPPER BOUND PART
			!SEE IF IT IS SIGNED 
			!
			IF .T1[ELMNT1] NEQ 0 !ELMNT0 IS THE SLASH LEXEME
			  THEN(IF .T1[ELMNT1] EQL 2 THEN HISIGN _ -1 ELSE HISIGN _ 0;
				T1 _ .T1+2;
			      )
			  ELSE (HISIGN_0; T1 _ .T1+1;);
			R2_.T1[ELMNT2];
			IF .R2[VALTYPE] NEQ INTEGER THEN RETURN ERRA();
			IF .T1[ELMNT1] EQL 2 THEN
			BEGIN	!CHOICE 2 - R2 = IDENTIFIER POINTER
				IF .HISIGN NEQ 0 THEN ERR46;
				IF .R2[OPERSP] NEQ FORMLVAR THEN RETURN ERRB(.R2);
				T2[DVARUBFLG(0)]_1;ADJUSTABLE_-1;
			END;
			IF .HISIGN NEQ 0
			  THEN IF .R2[OPERSP] EQL CONSTANT THEN R2 _ MAKECNST(INTEGER,0,-.R2[CONST2]);
			T2[DIMENU(0)]_.R2;
			IF .ADJUSTABLE EQL 0 THEN
			BEGIN
				IF .R1[CONST2] %LOWER BOUND%
					GTR .R2[CONST2] %UPPER BOUND%
					  THEN (ENTRY[1] _ FARRY[IDSYMBOL];ERROUT(74));

					!ERROR IF LOWER GTR UPPER BOUND
				NAME_CONTAB;ENTRY[0]_0;ENTRY[1]_.ASIZE;SYMTYPE_INTEGER;
				T2[DFACTOR(0)]_TBLSEARCH();
				AOFF_.AOFF-.ASIZE*.R1[CONST2];
				ASIZE_.ASIZE*(.R2[CONST2]-.R1[CONST2]+1);
			END
			ELSE
			BEGIN
				T2[DVARFACTFLG(0)]_1;T2[DFACTOR(0)]_0;
			END;
			SAVSPACE(.SAVPTR<LEFT>,.SAVPTR);
		END
		TES;
		T1_.SS[ELMNT]; !FOR SAVSPACE CALL
		SAVSPACE(.T1<LEFT>,.T1);DNUM_.DNUM+1;T2_.T2+2;
	END;
	!----------------------------------------------------------------------------------------------------------
	!STK[2] THRU STK[(.DNUM+1)*2] NOW CONTAINS A DIMENSION NODE. USE THE CORMAN ROUTINE TO CREATE
	!A REAL DIMENSION NODE AND COPY THE NODE FROM THE STACK.
	!----------------------------------------------------------------------------------------------------------
	IF .ADJUSTABLE NEQ 0 THEN
	   BEGIN
		!--------------------------------------------------------------------------------------------------
		!IF THE DIMENSIONS ARE ADJUSTABLE CREATE A SPECIAL SET OF TEMPS TO BE USED BY ADJ. TO
		!CALCULATE THE MULTIPLICATIVE FACTORS. ALSO SET ADJDIMFLG
		!--------------------------------------------------------------------------------------------------
		!FOR ADJ. THEY MUST BE IN A SPECIAL ORDER
		!ASIZE
		!OFFSET
		!FACTOR N-1
		! .
		! .
		! .
		!FACTOR 1

		!CHECK FOR ADJUSTABLE ARRAY NOT A DUMMY
		IF NOT .FARRY[IDATTRIBUT(DUMMY)] THEN (ENTRY[1] _ FARRY[IDSYMBOL]; ENTRY[2] _ PLIT'A DUMMY ARRAY?0'; RETURN ERROUT(15));
		ASIZE_INITLTEMP(INTEGER);
		AOFF<LEFT>_INITLTEMP(INTEGER);
		INCR I FROM 1 TO .DNUM DO
		BEGIN
			T2_.T2-2;
			IF .T2[DFACTOR(0)] EQL 0 THEN	!SET TO 0 ABOVE IF VARIABLE
				T2[DFACTOR(0)]_INITLTEMP(INTEGER);
		END;
		T2[ADJDIMFLG]_1;
		!RESET THE DVARFACTFLG ON FIRST FACTOR AND MAKE
		!IT A ONE ALWAYS. UNFORTUANETLY WE WILL ALREADY
		!HAVE WASTED A TEMP BY THEN

		T2[DVARFACTFLG(0)]_0;
		T2[DFACTOR(0)]_ IF .FARRY[DBLFLG] THEN MAKECNST(INTEGER,0,2) ELSE .ONEPLIT;
	   END
	   ELSE AOFF<LEFT> _ MAKECNST(INTEGER,0,.AOFF); !MAKE CONST NODE FOR OFFSET VALUE
		SAVSPACE(.SSLST<LEFT>,@SSLST);
!
!NOW MAKE A REAL DIMENSION NODE TRANSFERING THE INFORMATION ON THE
!TEMPORARY STACK (STK) TO THE DIMENSION NODE OF SIZE (.DNUM+1)*2
!
	NAME<LEFT>_T2_(.DNUM+1)*2;
	T2 _ .T2-1; !ONE LESS FOR UPCOMING BLT
	T2_.T2+(T1_(NAME<RIGHT>_DIMTAB; NEWENTRY()));
	 !ADD THE PTR TO THE NEW DIMENSION NODE TO T2 (THE NUMBER OF WORDS IN THE BLOCK MINUS 1)
	BEGIN LOCAL SAVT1;
		T1<LEFT>_STK[3]<0,0>;
		SAVT1 _.T1; !SAVING T1 INCASE OF BLT INTERRUPT
		BLT(T1,0,T2); !MOVE THE BLOCK TO NEW LOCATION
		T1 _ .SAVT1;
	END;
	IF .FARRY[OPERSP] EQL FORMLARRAY
	THEN
	(  IF .ADJUSTABLE EQL 0
	   THEN BEGIN
		!MAKE A POINTER VARIABLE TO BE A COPY OF ARRAY'S SYMBOL TABLE NODE
		!AND PUT IT IN THE DIMENSON NODE
		LOCAL BASE PTRVAR;
		ENTRY[0] _ .FARRY[IDSYMBOL]; NAME _ IDTAB;
		PTRVAR _ NEWENTRY();
		PTRVAR[VALTYPE] _ INTEGER;
		PTRVAR[OPERSP]  _ FORMLVAR;	!MAKE IT A FORMAL DUMMY
		T1[ARADDRVAR] _ .PTRVAR; !PTR VARIABLE TO DIMENSION NODE
	       END;
	) ELSE T1[ARADDRVAR] _ 0;
	RETURN .T1	!PTR TO DIMENSION NODE
END;
GLOBAL ROUTINE BLDARRAY (LPNT) =
BEGIN
	MAP BASE T1:T2;REGISTER BASE R2:R1;
	EXTERNAL SAVSPACE %(SIZE,LOC)%,IDTYPE,FARRY,TYPE,STK;
	MACRO
	ELMNT=0,0,FULL$,	ELMNT1=0,1,FULL$,	ELMNT2=0,2,FULL$;
	MACRO ERR4=
	BEGIN
		ENTRY[1]_PLIT'VARIABLE';ENTRY[2]_T1[IDSYMBOL];ENTRY[3]_SUBSPLIT;
		RETURN ERROUT(E4)
	END$;
	MACRO ERR41=
	BEGIN
		ENTRY[1]_FARRY[IDSYMBOL];
		ENTRY[2]_T1[IDSYMBOL];RETURN ERROUT(E41)
	END$;
	MACRO
	ERR42=(ENTRY[1]_T1[IDSYMBOL];RETURN ERROUT(E42))$,
	ERR34(X)=(ENTRY[1]_T1[IDSYMBOL];ENTRY[2]_PLIT'X';
		RETURN ERROUT(E34))$;
	BIND BASE CBLOCK=STK[2];
	LOCAL POINTER;

ROUTINE CHKCOMMON=	!CHECKS COMMON DECLARATIONS
BEGIN
			BEGIN	!COMMON STATEMENT
				IF .T1[IDATTRIBUT(INCOM)] THEN ERR42
					ELSE IF .T1[IDATTRIBUT(DUMMY)] THEN ERR34(DUMMY)
						ELSE IF .T1[IDATTRIBUT(INEXTERN)] THEN ERR34(EXTERNAL)
						ELSE IF .T1[OPRSP1] EQL FNNAME1 THEN ERR34(FUNCTION);
				T1[IDATTRIBUT(INCOM)]_1;
				IF .CBLOCK<LEFT> EQL 0 THEN
				BEGIN
					CBLOCK<LEFT>_CBLOCK<RIGHT>_@T1;
				END
				ELSE
				BEGIN
					CBLOCK[IDCOLINK]_@T1;CBLOCK<RIGHT>_@T1;
				END;
			END
END;	!OF CHKCOMMON
	!----------------------------------------------------------------------------------------------------------
	!THE PARAMETER LPNT POINTS TO A LIST OF ONEARRAY'S, THAT IS TO SAY EACH ELEMENT OF THE LIST POINTED TO
	!BY LPNT IS A POINTER TO A LIST OF THE FORM:
	!
	!IDENTIFIER (20^18+LOC) - FIRST ARRAY NAME
	!OPTION 0 OR OPTION 1 - ADDITIONAL ARRAY NAMES AND SUBSCRIPTS FOLLOW
	!	COUNT^18+LOC - LIST POINTER
	!
	!THE LOCATION IDTYPE CONTAINS THE VARIABLE TYPE TO BE SET IN EACH ARRAY NAME. IF IDTYPE IS LESS THAN ZERO,
	!NO TYPE IS SPECIFIED AND AN OPTION 0 (NO SUBSCRIPTS) IS ILLEGAL. IDTYPE IS SET LESS THAN ZERO FOR
	!DIMENSION, EXTERNAL, PROTECT, AND GLOBAL STATEMENTS.
	!----------------------------------------------------------------------------------------------------------
	INCR OA FROM .LPNT TO .LPNT+.LPNT<LEFT> DO
	BEGIN
		MAP BASE OA;	!OA STANDS FOR ONEARRAY
		R1_.OA[ELMNT];FARRY_T1_.R1[ELMNT];IF .TYPE NEQ 4 THEN IDTYPE_.T1[VALTYPE];
		IF .R1[ELMNT1] EQL 0 THEN
		BEGIN	!OPTION 0 - NO SUBSCRIPTS
			CASE .TYPE OF SET
			ERR4;	!DIMENSION
			BEGIN	!GLOBAL
				IF .T1[IDATTRIBUT(INCOM)]THEN ERR34(COMMON)
					ELSE IF .T1[IDATTRIBUT(INEXTERN)]THEN ERR34(EXTERNAL);
				T1[IDATTRIBUT(INGLOB)]_1
			END;
			BEGIN	!EXTERNAL
				IF .T1[IDATTRIBUT(INCOM)] THEN ERR34(COMMON);
				T1[IDATTRIBUT(INEXTERN)]_1; T1[OPERSP] _ FNNAME
			END;
			BEGIN	!PROTECT
				IF .T1[PARENLSTFLG] THEN
					IF .T1[OPERSP] LEQ FORMLARRAY THEN
						(T1[IDATTRIBUT(ISPROT)]_1;EXITCASE);
				ERR4
			END;
			BEGIN	 STATEMENT
				IF .T1[IDDIM] NEQ 0
				THEN IF .IDTYPE GEQ DOUBLPREC
					THEN IF .T1[VALTYPE] LSS DOUBLPREC
					  THEN(R2 _ .T1[IDDIM];
						IF NOT .R2[ADJDIMFLG]
						THEN BEGIN
						       R2[ARASIZ] _ .R2[ARASIZ]*2;
							T2 _ .R2[ARAOFFSET];
							R2[ARAOFFSET] _ MAKECNST(INTEGER,0,2*.T2[CONST2]);
							DECR I FROM .R2[DIMNUM]-1 TO 0 DO
							BEGIN
							   T2 _ .R2[DFACTOR(.I)];
							   R2[DFACTOR(.I)] _ MAKECNST(INTEGER,0,2*.T2[CONST2]);
							END;
						     END
						 ELSE
							BEGIN !DO ONLY FOR FIRST FACTOR IF ADJUSTABLE
							   T2 _ .R2[DFACTOR(0)];
							   R2[DFACTOR(0)] _ MAKECNST(INTEGER,0,2*.T2[CONST2]);
							END;
						);
				IF .T1[IDATTRIBUT(INTYPE)] 
				THEN IF .T1[VALTYPE] NEQ .IDTYPE
					THEN ( ENTRY[1] _ T1[IDSYMBOL]; RETURN ERROUT(89));
				T1[IDATTRIBUT(INTYPE)] _ 1;
				T1[VALTYPE]_.IDTYPE
			END;
			CHKCOMMON();	!ROUTINE TO CHECK COMMON DECLARATION
			TES;
		END
		ELSE

		BEGIN	!OPTION 1 - ARRAY NAMES AND SUBSCRIPTS
			MAP BASE FARRY;
			LOCAL SAVSTK;
			ROUTINE IDCHECK =
			BEGIN
				IF .T1[OPERSP] GTR FORMLVAR THEN !IS NAME ALREADY ARRAY OR FUNCTION?
				BEGIN !YES ERROR
					ENTRY[1]_T1[IDSYMBOL];
					ENTRY[2]_IF .T1[OPERSP] GEQ FNNAME THEN FNPLIT ELSE ARPLIT;
					RETURN ERROUT(E34)
				END;
				IF .T1[OPERSP] EQL VARIABLE THEN T1[OPERSP]_ARRAYNAME
					ELSE T1[OPERSP]_FORMLARRAY;
				IF @TYPE NEQ 4 THEN
					IF.T1[VALTYPE] NEQ @IDTYPE THEN ERR41;
				CASE @TYPE OF SET
				EXITCASE;	!DIMENSION
				BEGIN	!GLOBAL
					IF .T1[IDATTRIBUT(INCOM)] THEN ERR34(COMMON)
						ELSE IF .T1[IDATTRIBUT(INEXTERN)] THEN ERR34(EXTERNAL);
					T1[IDATTRIBUT(INGLOB)]_1
				END;
				BEGIN	!EXTERNAL
					IF .T1[IDATTRIBUT(INCOM)] THEN ERR34(COMMON);
					ERROUT(102);
				END;
				BEGIN	!PROTECT
					T1[IDATTRIBUT(ISPROT)]_1
				END;
				BEGIN	!TYPE STATEMENT
				IF .T1[IDATTRIBUT(INTYPE)] 
				THEN IF .T1[VALTYPE] NEQ .IDTYPE
					THEN ( ENTRY[1] _ T1[IDSYMBOL]; RETURN ERROUT(89))
					ELSE T1[IDATTRIBUT(INTYPE)] _ 1;
					T1[VALTYPE]_.IDTYPE
				END;
				CHKCOMMON();	!CHECK COMMON DECLARATIONS
				TES;
			END;
			IF @IDTYPE LSS 0 THEN IDTYPE_.T1[VALTYPE];
			IF IDCHECK() LSS 0 THEN RETURN .VREG;
			R2_.R1[ELMNT2];
			IF .R2[ELMNT] EQL 0 THEN T2 _ .R2[ELMNT1] !ID FOLLOWED BY DIMENSIONS
				ELSE T2 _ .R2[ELMNT2]; !ID FOLLOWED BY REPEATED COLON ID
			SAVSTK_.STK[2]; !SAVING COMMON LIST POINTERS IF PROCESSING COMMON LISTS

			IF (T2_BLDDIM(.T2)) LSS 0 THEN RETURN .VREG
				ELSE FARRY[IDDIM]_.T2;
			STK[2]_.SAVSTK;
			IF .R2[ELMNT] EQL 0 THEN SAVSPACE(.R2<LEFT>,@R2)
			!ELSE GET THE REPEATED SET OF IDENTIFIERS
			ELSE
			BEGIN
				POINTER_.R2[ELMNT1];SAVSPACE(.R2<LEFT>,@R2);
				INCR ARLST FROM @POINTER TO @POINTER+.POINTER<LEFT> BY 2 DO
				BEGIN
					MAP BASE ARLST;
					IF .ARLST[ELMNT] EQL 0 THEN EXITLOOP;
					R2_.ARLST[ELMNT1];T1_.R2[ELMNT];SAVSPACE(0,@R2);
					IF IDCHECK() LSS 0 THEN RETURN .VREG
						ELSE T1[IDDIM]_.T2;
				END;SAVSPACE(.POINTER<LEFT>,@POINTER);
			END;
		END;SAVSPACE(.R1<LEFT>,@R1);
	END;SAVSPACE(.LPNT<LEFT>,@LPNT);
END;
GLOBAL ROUTINE BLKSRCH	(BLKNAME)=
BEGIN
	REGISTER BASE R1:R2;
	EXTERNAL NEWENTRY %()%,COMBLKPTR;
	!---------------------------------------------------------------------------------
	!THIS ROUTINE FINDS OR CREATES THE COMMON BLOCK "NAME" AND
	!RETURNS A POINTER TO IT.
	!---------------------------------------------------------------------------------
	R1_.COMBLKPTR<LEFT>;
	UNTIL .R1 EQL 0 DO
	BEGIN
		IF .R1[COMNAME] EQL .BLKNAME THEN RETURN .R1;
		R1_.R1[NEXCOMBLK];
	END;
	ENTRY[0]_.BLKNAME;
	NAME_COMTAB;R2_NEWENTRY();
	RETURN .R2
END;
GLOBAL ROUTINE BLDVAR (VPNT)=
BEGIN
	MAP  BASE	T1:T2;REGISTER BASE R1:R2;
	EXTERNAL SAVSPACE %(SIZE,LOC)%,NEWENTRY %()%,ARRXPND %(NAME,SUBSCRIPTS)%;
	MACRO
	ELMNT=0,0,FULL$,ELMNT1=0,1,FULL$,ELMNT2=0,2,FULL$;
	!--------------------------------------------------------------------------
	!THE PARAMETER VPNT POINTS TO THE LIST:
	!
	!IDENTIFIER (20^18+LOC) - THE SCALAR OR ARRAY VARIABLE
	!OPTION 0 OR OPTION 1 - SUBSCRIPTS FOLLOW
	!		1^18+LOC - POINTER TO SUBSCRIPT LIST POINTER
	!			COUNT^18+LOC - POINTER TO A LIST OF SUBSCRIPT EXPRESSIONS
	!OPTION 0 OR OPTION 1 - FIELDSPEC FOLLOWS
	!		COUNT^18+LOC - POINTER TO FIELDSPEC LIST
	!--------------------------------------------------------------------------
	T1_.VPNT;T2_.T1[ELMNT];!T2_LOC(IDENTIFIER)
	IF .T2[IDATTRIBUT(NAMNAM)] THEN RETURN (ENTRY[1] _ T1[IDSYMBOL];ERROUT(E6));
	IF .T1[ELMNT1] EQL 0 THEN
	BEGIN
	    IF .T2[PARENLSTFLG] THEN
		IF NOT .T2[IDATTRIBUT(FENTRYNAME)] THEN
		BEGIN
			ENTRY[2]_T2[IDSYMBOL];
			IF .T2[OPRSP1] EQL FNNAME1 THEN (ENTRY[1]_FNPLIT; RETURN ERROUT(E4))
		END;
		T1_.T1+2;!T1_LOCATION OF FIELDSPEC OPTION
		T2<LEFT>_IDENT;
	END
	ELSE
	BEGIN
		IF .T2[OPERSP] NEQ ARRAYNAME THEN
			IF .T2[OPERSP] NEQ FORMLARRAY THEN
				(ENTRY[1]_T2[IDSYMBOL];ENTRY[2]_PLIT'AN ARRAY';RETURN ERROUT(E15));
		R1_.T1[ELMNT2];R2_.R1[ELMNT];SAVSPACE(0,@R1); !CHANGED 1 TO 0
		INCR SCR FROM @R2 TO @R2+.R2<LEFT> DO
		BEGIN
			MAP BASE SCR;MACRO SCRFLGS=0,0,LEFT$,SCRPTR=0,0,RIGHT$;
			R1_.SCR[ELMNT];			SCR[SCRPTR]_@R1;SCR[SCRFLGS]_0;
			IF .R1[OPRCLS] NEQ DATAOPR THEN
				IF .R1[OPRCLS] NEQ ARRAYREF THEN EXITBLOCK;
		END;
		IF (T2_ARRXPND(@T2,@R2)) LSS 0 THEN T2 _ 0;T1_.T1+3;!T1_LOCATION OF FILEDSPEC OPTION
		T2<LEFT>_ARRAYREF;
	END;
	IF .T1[ELMNT] NEQ 0 THEN !FIELDSPEC
	BEGIN

		T2<LEFT>_FIELDREF;
		R2_.T1[ELMNT1];SAVSPACE(.R2<LEFT>,@R2);!IGNORE FILEDSPECS FOR NOW
	END; SAVSPACE(.VPNT<LEFT>,@VPNT);
	RETURN .T2!RETURN POINTER TO SCALAR OR ARRAY EXPRESSION
END;
GLOBAL ROUTINE OUTPUTEXPR=
BEGIN
	MAP BASE T1:T2;REGISTER BASE R1:R2;
	EXTERNAL CORMAN %()%,POOL,SAVSPACE %(SIZE,LOC)%,PIN,POUT,STK,SP,
		SYNTAX %(META)%,CHAR %()%,LITPOINTER;
	MACHOP BLT=#251;
	MACRO GETCHAR=(POOL[R1_.R1+1]_SIGCHAR)$,
		GETALLCHAR=(POOL[R1_.R1+1]_CHAR())$,ELMNT=0,0,FULL$;

!	LABEL OUT1,OUT2;
!	LOCAL LEVEL;
!	!--------------------------------------------------------------------
!	!THIS ROUTINE SCANS AND SAVES EACH CHARACTER UNTIL AN EOL OR
!	!THE FIRST ZERO PARENTHESIS LEVEL COMMA OR RIGHT PAREN IS
!	!ENCOUNTERED.  IT THEN CREATES A LITSTRING LEXEME AND PUTS IT
!	!ON THE STACK.  THIS LITERAL IS USED WHEN EXECUTING AN OUTPUT
!	!STATEMENT TO FIRST LIST THE EXPRESSION TO BE EVALUATED.  THE
!	!ROUTINE THEN RESETS THE CHARACTER POOL POINTERS SO THAT THE
!	!LITERAL STRING WILL BE RESCANNED AS INPUT AND CALLS SYNTAX
!	!TO EVALUATE THE LIGICAL EXPRESSION.
!	!--------------------------------------------------------------------
!	IF .POUT LSS .PIN THEN
!	BEGIN
!		!--------------------------------------------------------------
!		!MOVE UNREAD CHARACTERS IN POOL TO BEGINNING OF POOL
!		!AND RESET THE POOL POINTERS ACCORDINGLY
!		!--------------------------------------------------------------
!		T1<LEFT>_POOL[.POUT+1];T1<RIGHT>_POOL[0];
!		T2_POOL[PIN_.PIN-.POUT];BLT(T1,0,T2);
!		R1_POUT_-1;
!	END ELSE R1_POUT_PIN_-1;LEVEL_0;
!  OUT1: DO GETCHAR UNTIL
!	BEGIN
!		IF DIGIT(C) THEN
!		BEGIN
!			R2_0;DO (R2_.R2*10+.C-"0";GETCHAR)WHILE DIGIT(C);
!			IF .C EQL "H" THEN
!				DO (IF GETALLCHAR EQL EOL THEN LEAVE OUT1) UNTIL (R2_.R2-1) EQL 0;
!		END;
!		IF .C EQL "'" THEN
!		  OUT2: DO GETALLCHAR UNTIL
!			BEGIN
!				IF .C EQL "'" THEN
!					IF GETALLCHAR NEQ "'" THEN LEAVE OUT2;
!				IF .C EQL EOL THEN LEAVE OUT1; 0
!			END;
!			IF .C EQL "=" THEN
!				IF GETCHAR NEQ "=" THEN LEAVE OUT1;
!		IF .C EQL EOL THEN LEAVE OUT1;
!		IF .LEVEL EQL 0 THEN
!			IF .C EQL "," THEN LEAVE OUT1
!				ELSE IF .C EQL ")" THEN LEAVE OUT1;
!		IF .C EQL "(" THEN LEVEL_.LEVEL+1
!			ELSE IF .C EQL "[" THEN .LEVEL_.LEVEL+1
!				ELSE IF .C EQL ")" THEN LEVEL _.LEVEL-1
!					ELSE IF .C EQL "]" THEN LEVEL_.LEVEL-1;
!		0
!	END;
!	IF .PIN EQL .POUT THEN PIN_.R1;POUT_-1;!RESET POINTERS FOR RESCAN
!	NAME<LEFT>_(.R1+1)/5+1;R2_CORMAN();R2<LEFT>_.R1+1;
!	T1_(.R2)<36,7>;T2_-1;DO REPLACEI(T1,.POOL[T2_.T2+1])UNTIL .T2 EQL R1;
!	IF SYNTAX(EXPRESSION) LSS 0 THEN
!	BEGIN
!		SAVSPACE((.R1+1)/5+1,@R2);
!		ENTRY[0]_PLIT'OUTPUTEXPR';RETURN ERROUT(E1)
!	END;
!	NAME_LITTAB;R1_CORMAN();
!	IF .FIRSTLIT EQL 0 THEN FIRSTLIT_@R1
!		ELSE (.LITPOINTER<RIGHT>)<RIGHT>_@R1;
!	R1[CLINK]_0;LITPOINTER<RIGHT>_@R1;
!	R1[VALTYPE]_LITERAL;R1[OPRCLS]_DATAOPR;R1[OPERSP]_CONSTANT;
!	R1[LITSIZ]_.R2<LEFT>;R1[LITADDR]_@R2;
!	T1_.STK[.SP];STK[.SP]_LSTRING^18+.R1<RIGHT>;
!	STK[SP_.SP+1]_.T1[ELMNT];SAVSPACE(0,@T1);
	RETURN -1
END;
GLOBAL ROUTINE DATALIST (LPNT)=
BEGIN
	MAP BASE T1:T2;REGISTER BASE R1:R2;
	EXTERNAL TBLSEARCH,SP,DOXPN;
	EXTERNAL BLDVAR%(VPNT)%,SAVSPACE %(SIZE,LOC)%,TYPE,ONEPLIT,STK,CORMAN %()%;
	EXTERNAL GENLAB,NEWENTRY,DATASUBCHK;
	MACRO
	ELMNT=0,0,FULL$,ELMNT1=0,1,FULL$,ELMNT2=0,2,FULL$,ELMNT3=0,3,FULL$,
	ERR38=(RETURN ERROUT(38))$, !INDEX VARIABLE NOT VARIABLE
	ERR44=(ENTRY[1]_R1[IDSYMBOL];RETURN ERROUT (E44))$;
	BIND DATA=0,NORMAL=1,OUTPUT=2,READD=3,WRITEE=4;
	LABEL IO1;
	!
	!MACROS FOR DATALIST NODE GENERATION FOR IOLISTS,DATA LISTS
	!
	MACRO SIZOFARRAY=
	BEGIN
	  IF NOT .SYMBL[DBLFLG]
		THEN(IF NOT .T2[ADJDIMFLG]
			THEN MAKECNST(INTEGER,0,.T2[ARASIZ])
			ELSE .T2[ARASIZ]	!PTR TO TEMP FOR ADJ DIMENSION
		    )
		ELSE(IF NOT .T2[ADJDIMFLG]
			THEN MAKECNST(INTEGER,0,.T2[ARASIZ]/2)
			ELSE(	NAME _ EXPTAB;
				T1 _ NEWENTRY();
				!MAKE A DIVIDE NODE .T2[ARASIZ]/2
				T1[ARG1PTR] _ .T2[ARASIZ];
				T1[ARG2PTR] _ MAKECNST(INTEGER,0,2);
				T1[A1VALFLG] _ T1[A2VALFLG] _ 1; !SETTING FLAGS
				T1[OPERATOR] _ INTDIVIDE;
				T1[PARENT] _ .R1;	!POINTS BACK TO DATA LIST NODE
				.T1	!PTR TO ASSIGN TO SCALLCT
			    )
		     )
	END$;
	MACRO IODATANODE(X)=
	IO1: BEGIN
		NAME _ IOLTAB;	!IOLIST TABLE
		R1_X;
		IF .TYPE EQL READD THEN
		  (T2 _ .R1[ELMNT]; T2[IDATTRIBUT(STORD)] _ 1;)
		ELSE
		IF .TYPE EQL DATA THEN
		  BEGIN
			T2_.R1[ELMNT];
			T2[IDATTRIBUT(INDATA)] _ 1;
			IF .T2[IDATTRIBUT(DUMMY)] THEN (ENTRY[1] _ T2[IDSYMBOL]; ERROUT(66); LEAVE IO1);
		   END;
		IDOFSTATEMENT _  IF .R1[ELMNT1] NEQ 0 THEN DATACALL
					ELSE (R1_.R1[ELMNT]; !PTR TO SYMBOL
						IF .R1[IDDIM] NEQ 0 THEN (NAME<LEFT>_ 3;SLISTCALL) ELSE DATACALL
					    );
		R1_NEWENTRY();
		R1[OPERSP] _ .IDOFSTATEMENT;  !DATACALL OR SLISTCALL
		IF .LISTLINK EQL 0
		  THEN (LISTLINK<LEFT>_LISTLINK<RIGHT>_.R1)
		  ELSE (LISTLINK[CLINK] _ .R1; LISTLINK<RIGHT>_.R1);
		R1[OPRCLS] _ IOLSCLS;	!IOLIST CLASS
		R1[DCALLELEM] _ BLDVAR(X);
		IF .VREG LSS 0 THEN (R1[DCALLELEM] _ 0; RETURN -1); !VREG IS -1 IF BLDVAR FOUND AN ERROR
		IF .R1[OPERSP] EQL SLISTCALL
		THEN BEGIN
			LOCAL BASE SYMBL;
			SYMBL _ .R1[DCALLELEM];
			T2 _ .SYMBL[IDDIM]; !PTR TO DIMENSION NODE
			R1[SCALLCT] _ SIZOFARRAY;	!PTR TO NODE CONTAINING NUM OF ELEMENTS IN ARRAY
		    END;
	END$;
	MACRO IODONODE(X)=
	BEGIN
		IDOFSTATEMENT_NAME_DODATA;
		NAME<RIGHT> _ IOLTAB;
		T1_NEWENTRY();
		T1[CLINK]_ .X<LEFT>; X<LEFT>_ .T1;
		T1[OPRCLS]_STATEMENT;
		T1[DOLBL] _ .IOLBL;	!PSEUDO LABEL MADE BY IOCONTNODE
		T2_.IOLBL[SNDOLNK]; 
		IOLBL[SNDOLVL] _ .IOLBL[SNDOLVL]+1;
		NAME<LEFT> _ 1; IOLBL[SNDOLNK] _ CORMAN();
		(.VREG)<LEFT>_.T1; (.VREG)<RIGHT>_.T2; !LINKING IN ENDING LBL TO DO NODE AND LABEL TABLE
	END$;
	MACRO IOCONTNODE(X)=
	BEGIN
		IDOFSTATEMENT_NAME_CONTDATA;	!NODE IDENTIFICATION AND SIZE
		NAME<RIGHT> _ IOLTAB;
		T1_NEWENTRY();
		T1[OPRCLS]_STATEMENT;
		X[CLINK] _ .T1; X<RIGHT> _ .T1;
		IOLBL _ T1[SRCLBL]_ GENLAB();
		IOLBL[SNHDR] _ .T1	!PTR TO CONTINUE IN LABEL TABLE NODE
	END$;
	LOCAL BASE LISTLINK;	!PTR TO FIRST<LEFT> AND LAST<RIGHT> NODES IN DATALIST CHAIN
	!---------------------------------------------------------------------
	!THIS ROUTINE IS CALLED WITH LPNT POINTING TO A LIST OF
	!DATAITEMS.  EACH DATAITEM CONSISTS OF:
	!
	!CHOICE-1,IF TYPE IS OUTPUT THEN
	!	LITSTING-(22^18+LOC)
	!	LOGICALEXPR-(LOC)
	!		IF NOT TYPE OUTPUT THEN
	!	DATAITEM-(LOC)
	!CHOICE-2
	!	LIST-(COUNT^18+LOC)
	!		DATAITEM
	!	OPTION-0 OR
	!	OPTION-1
	!		LOOPPART
	!---------------------------------------------------------------------
	LISTLINK_0;	!INITIALIZING FOR LIST INPARENS
	INCR DATLST FROM @LPNT TO @ LPNT+.LPNT<LEFT> BY 2 DO
	BEGIN
		MAP BASE DATLST;
		IF .DATLST[ELMNT] EQL 1 THEN	!A DATAITEM OR OUTPUTEXPR
		BEGIN
			IF .TYPE EQL OUTPUT THEN (DATLST_.DATLST+1;EXITBLOCK);
			IODATANODE(.DATLST[ELMNT1]);
		END
		ELSE	!AN IMPLIED DO LOOP OR LIST ENCLOSED IN PARENS
		BEGIN
			LOCAL BASE LNKLST; !TEMPORARY HOLDER OF LINKLIST
			LOCAL TDOSYM; !TEMPORARY HOLDER OF DO INDEX SYMBOL PTR
			LNKLST _ 0;  !INIT LOCAL
			R1_.DATLST[ELMNT1];R2_.R1[ELMNT];  !R2_LOC(DATAITEM LIST)
			IF .R1[ELMNT1] NEQ 0
			 THEN (!IMPLIED DO LOOP COMING UP ; R2 HAS PTR  TO IMPLIED  DO LIST
				T1_@R2+.R2<LEFT>; T2_TDOSYM_@.T1[ELMNT];
				IF .TYPE EQL DATA
				THEN
				  BEGIN
					IF .T2[VALTYPE] NEQ INTEGER THEN RETURN ERROUT(104);
					STK[SP_.SP+1] _.T2; !SAV PTR TO INDEX SYMBOL ON STACK
				  END;
				IF .T2[OPRCLS] NEQ DATAOPR THEN ERR38
				  ELSE IF .T2[OPRSP1] NEQ VARIABL1 THEN ERR38;
				R2<LEFT>_.R2<LEFT>-2; !RESET LIST PTR SO THAT LAST ITEM (INDEX PTR)
							!DOESN'T GET PROCESSED AS AN IODATANODE
				);
			IF (LNKLST _ DATALIST(.R2)) LSS 0 THEN RETURN .VREG;
			IF .R1[ELMNT1] NEQ 0 THEN	!IMPLIED DO LOOP
			BEGIN
				LOCAL  BASE DONOD:IOLBL;	!LABEL OF CONTINUE ENDING IMPLIED DO LOOP
				IOCONTNODE(LNKLST);	!GEN A CONTINUE NODE
				IODONODE(LNKLST);	!GEN A DO LOOP NODE
				DONOD_.LNKLST<LEFT>; !SET UP BY IODONODE
				DONOD[DOSYM]_.TDOSYM;	!STK[2]_LOC(INDEX VARIABLE)
				R2_.R1[ELMNT2]; SAVSPACE(.R1<LEFT>,.R1); !R2_LOC(LOOPPART)
				R1_.R2[ELMNT];
				!R1 POINTS TO INITIAL VALUE
				IF .TYPE EQL DATA THEN
					 IF .R1[OPERSP] NEQ CONSTANT THEN ERR44;
				IF .R1[VALTYPE] NEQ INTEGER THEN ERR44;
				DONOD[DOM1]_@R1;R1_.R2[ELMNT1];	!_LOC(INITIAL VALUE)
				!R1 POINTS TO FINAL VALUE
				IF .TYPE EQL DATA THEN
					 IF .R1[OPERSP] NEQ CONSTANT THEN ERR44;
				IF .R1[VALTYPE] NEQ INTEGER THEN ERR44;
				DONOD[DOM2]_@R1;	!_LOC(FINAL VALUE)
				IF .R2[ELMNT2] EQL 0 THEN	!INPLIED INCREMENT OF 1
				BEGIN
					DONOD[DOM3]_.ONEPLIT;
				END
				ELSE	!INCREMENT SPECIFIED
				BEGIN
					T1_.R2[ELMNT3];R1_.T1[ELMNT];SAVSPACE(0,.T1);
					IF .TYPE EQL DATA THEN
						IF .R1[OPERSP] NEQ CONSTANT THEN ERR44;
					IF .R1[VALTYPE] NEQ INTEGER THEN ERR44;
					DONOD[DOM3]_.R1<RIGHT>;
				END;
				IF .TYPE EQL DATA
				THEN IF .SP GTR 0
					THEN (	DATASUBCHK(.DONOD[CLINK],.SP,STK[1]<0,0>);
						SP _ .SP-1;
					     );
				SAVSPACE(.R2<LEFT>,.R2);
			END;
			IF .LISTLINK EQL 0
			THEN LISTLINK_.LNKLST
			ELSE (LISTLINK[CLINK]_.LNKLST<LEFT>;
				LISTLINK<RIGHT> _ .LNKLST<RIGHT>
			     );
		END;
	END;
	RETURN .LISTLINK	!POINTS TO FIRST ELEMENT IN LIST
END;
GLOBAL ROUTINE BLDFORMAT (FPNT)=
BEGIN
	MAP BASE T1:T2:FPNT;REGISTER BASE R1:R2;
	EXTERNAL SAVSPACE %(SIZE,LOC)%,STK,BLDVAR %(VPNT)%,TBLSEARCH %()%,
		 TYPE;
	MACRO
	ELMNT=0,0,FULL$,ELMNT1=0,1,FULL$,ELMNT2=0,2,FULL$, ELMNT3=0,3,FULL$,
	ERR25=(RETURN ERROUT(E25))$,
	ERR19=(RETURN ERROUT(E19))$,
	ERR15(X)=BEGIN
			ENTRY[1]_R2[IDSYMBOL];
			ENTRY[2]_X;RETURN ERROUT(E15)
		END$,
	ERR34=(ENTRY[1]_R2[IDSYMBOL];ENTRY[2]_PLIT'PARAMETER';RETURN ERROUT(E34))$;
	ROUTINE EOE=
	BEGIN
		!--------------------------------------------------------------------------------------------------
		!R2=LOC (END OR ERR IDENTIFIER)
		!T1=LOC (LABEL OR VARIABLE CHOICE)
		!T2=LOC (LABEL OR VARIABLE LIST)
		!--------------------------------------------------------------------------------------------------
		IF .T1[ELMNT] EQL 1 THEN !LABEL
		BEGIN
			IF .T2[VALTYPE] NEQ INTEGER THEN ERR25
				ELSE IF .T2[CONST2] GTR 99999 THEN ERR19;
			ENTRY[0]_.T2[CONST2];NAME_LABTAB;T2_TBLSEARCH();
			T2[SNREF] _ .T2[SNREF]-1;	!DON'T COUNT REFERENES
							!TO FORMAT LABELS IN I/O STATEMENTS
		END
		ELSE	!VARIABLE
		BEGIN
			IF (T2_BLDVAR(@T2)) LSS 0 THEN RETURN .VREG;
		END;SAVSPACE(.T1<LEFT>,@T1);
		IF .R2[IDSYMBOL] EQL SIXBIT 'END' THEN
			(IF .STK[6] EQL 0 THEN STK[6]_@T2 ELSE ERR34)
			ELSE IF .R2[IDSYMBOL] EQL SIXBIT 'ERR' THEN
				(IF .STK[5] EQL 0 THEN STK[5]_@T2 ELSE ERR34)
				ELSE IF .R2[IDSYMBOL] EQL SIXBIT'FORMAT' THEN
					(IF .STK[4] EQL 0 THEN STK[4] _ .T2 ELSE ERR34)
					ELSE ERR15 (PLIT'END OR ERR OR FORMAT');
	END;
	!----------------------------------------------------------------------------------------------------------
	!THIS ROUTINE IS CALLED WITH THE PARAMETER FPNT POINTING TO
	!A FORMAT SPECIFICATION.  SEE EXPANSION OF METASYMBOL IOSPEC FOR
	!DETAILS.  THE FORMAT POINTER IS RETURNED IN STK[4].  IT MAY BE
	!A LABEL (LOC) LITSTRING (LOC), ASTERISK - STANDARD FORMAT CONVERSIONS (-1)
	!AN ARRAY NAME OR NAMELIST NAME (LOC[IDENTIFIER]) OR NOT SPECIFIED (0).
	!THE END AND ERR BRANCH LOCATIONS ARE RETURNED IN STK[6] AND STK[5]
	!RESPECITVELY.  THEY MAY BE LABELS (LOC), VARIABLES (LOC) OR NOT
	!SPECIFIED (0).
	!----------------------------------------------------------------------------------------------------------
	CASE .FPNT[ELMNT] OF SET
	0;!NEVER OCCURS,INSERTED FOR SPEED ONLY
	BEGIN!LABEL
		R1_.FPNT[ELMNT1];
		IF .R1[VALTYPE] NEQ INTEGER THEN ERR25
			ELSE IF .R1[CONST2] GTR 99999 THEN ERR19;
		ENTRY[0]_.R1[CONST2];NAME_LABTAB;STK[4]_TBLSEARCH()
	END;
	BEGIN!ARRAY NAME NAMELIST NAME OR END/ERR
		R2_.FPNT[ELMNT1];
		IF (.FPNT[ELMNT2] EQL 0) OR (.FLAG NEQ 0)  THEN !ARRAY NAME OR NAMELIST NAME
								!OR NO END= OR ERR= EXPECTED
		BEGIN
			IF .R2[OPRSP1] EQL ARRAYNM1 THEN STK[4]_.R2
			ELSE IF .TYPE NEQ 0 THEN
				IF .R2[IDATTRIBUT(NAMNAM)] THEN STK[4]_@R2
					ELSE ERR15(PLIT'ARRAY OR NAMELIST NAME')
				ELSE ERR15(PLIT'ARRAY NAME');
		END
		ELSE !END=/ERR=/FORMAT=
		BEGIN
			T1_.FPNT[ELMNT3];T2_.T1[ELMNT1]; !T1 HAS PTR TO OPTIONAL (= CONST OR VARIABLE)
			  !T2 HAS PTR TO SYMBOL NODE THAT SHOULDCONTAIN
				 !'END' OR 'ERR' OR 'FORMAT'
			IF EOE() LSS 0 THEN RETURN .VREG;
		END;
	END;
	BEGIN!LITSTRING
		STK[4]_.FPNT[ELMNT1]
	END;
	BEGIN!ASTERISK
		STK[4]_-1
	END
	TES;
END;

GLOBAL ROUTINE BLDUNIT (UPNT)=
BEGIN
	MAP BASE UPNT:T1:T2;REGISTER BASE R1:R2;
	EXTERNAL SAVSPACE %(SIZE,LOC)%,STK,BLDFORMAT %(FPNT)%,BLDVAR %(UPNT)%;
	EXTERNAL CNVNODE;
	MACRO
	ELMNT=0,0,FULL$,ELMNT1=0,1,FULL$,ELMNT2=0,2,FULL$,ELMNT3=0,3,FULL$,
	ERR15(X)=(ENTRY[1]_X;ENTRY[2]_PLIT'INTEGER';RETURN ERROUT(E15))$;
	!----------------------------------------------------------------------------------------------------------
	!THIS ROUTINE IS CALLED WITH THE PARAMETER UPNT POINTING
	!TO A UNITSPEC OPTIONALLY FOLLOWED BY A FORMATID.  SEE
	!EXPANSIONS OF THE METASYMBOLS IOSPEC, UNITSPEC AND FORMATID FOR
	!DETAILS.  A UNIT NUMBER MAY BE AN INTEGER CONSTANT OR AN INTEGER
	!VARIABLE.  IF A FORMAT IS PRESENT THE ROUTINE BLDFORMAT IS CALLED
	!TO SCAN THE FORMAT.  UPON EXIT FROM THIS ROUTINE THE FOLLOWING
	!LOCATIONS WILL BE DEFINED:
	!
	!	STK[2]=UNIT
	!	STK[3]=RECORD
	!	STK[4]=FORMAT
	!	STK[5]=ERR
	!	STK[6]=END
	!----------------------------------------------------------------------------------------------------------
	R1_.UPNT[ELMNT];R2_.R1[ELMNT1];  !R2_LOC(CONSTANT OR VARIABLE)
	IF .R1[ELMNT] EQL 1 THEN !INTEGER CONSTNAT
	BEGIN
		IF .R2[VALTYPE] NEQ INTEGER THEN ERR15 (PLIT SIXBIT 'UNIT');
		STK[2]_.R2
	END
	ELSE !VARIABLE
	BEGIN
		T2 _ .R2[ELMNT];	!PTR TO IDENTIFIER OR CONSTANT NODE
		IF .T2[VALTYPE] NEQ INTEGER THEN ERR15 (T2[IDSYMBOL]);
		IF (STK[2]_BLDVAR(.R2)) LSS 0 THEN RETURN .VREG;
	END;
	IF .R1[ELMNT2] NEQ 0 THEN !RECORD NUMBER
	BEGIN
		STK[3] _ T1 _ .R1[ELMNT3];
		IF .T1[VALTP1] NEQ INTEG1
		  THEN  STK[3] _ CNVNODE(.T1,INTEGER,0);
	END ELSE STK[3]_0;SAVSPACE(.R1<LEFT>,@R1);
	STK[4]_STK[5]_STK[6]_0;
	IF .UPNT[ELMNT1] NEQ 0 THEN !FORMAT, END/ERR
	BEGIN
		R2_.UPNT[ELMNT2];
		T1 _ .R2[ELMNT];
		R1_-1; !INIT INDEX FOR USE IN LOOP
		INCR FMT FROM .T1 TO .T1+.T1<LEFT> DO
		BEGIN
			MAP BASE FMT;
			FLAG _ 0; !SIGNAL BLDFORMAT FOR POSSIBLE END= OR ERR=
			R1_.R1+1; !INCREMENT INDEX (FIRST TIME TO 0)
			IF BLDFORMAT(.FMT[ELMNT]) LSS 0 THEN RETURN .VREG;
			SAVSPACE(.FMT[ELMNT]<LEFT>,.FMT[ELMNT]);
			IF .R1 EQL 2 THEN EXITLOOP;!CHECKS FOR ATMOST 3 PARTS TO FORMAT
						!I.E. (FORMAT=N,END=N,ERR=N)
		END;
		T1 _ .R2[ELMNT]; SAVSPACE(.T1<LEFT>,.T1);
	END;
	SAVSPACE(.UPNT<LEFT>,@UPNT);
END;
END ELUDOM
  c@$