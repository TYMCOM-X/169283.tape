

1.0   INTRODUCTION
	CHARACTER SET
	MULTIPLE STATEMENTS PER LINE
	LINE FORMAT
	    COMMENTS
	    CONTINUATION LINES

2.0   CONSTANTS, VARIABLES, AND EXPRESSIONS
	CONSTANTS
	    INTEGER
	    REAL
	    DOUBLE PRECISION
	    OCTAL
	    COMPLEX
	    LOGICAL
	    LITERAL
		HOLLERITH & RIGHT HOLLERITH
		STRING
	    LABEL
	VARIABLES
	    SCALAR
	    ARRAY
	EXPRESSIONS
	    ARITHMETIC
	    LOGICAL
	    STRING

3.0   ASSIGNMENT STATEMENTS
	ARITHMETIC ASSIGNMENT
	GO TO ASSIGNMENT
	STRING ASSIGNMENT


4.0   CONTROL STATEMENTS
	GO TO STATEMENT
	    UNCONDITIONAL GO TO
	    ASSIGNED GO TO
	    COMPUTED
	IF STATEMENT
	     ARITHMETIC
	     LOGICAL
	DO STATEMENT
	    IMPLIED DO
	    CONTINUE
	PAUSE 
	STOP
	QUIT
	END
5.0     DATA TRANSMISSION
          FORMATTED I/O
            FIELD SPECIFICATIONS
                INTEGER                         I
                REAL                            F,E
                DOUBLE PRECISION                D
                GENERAL                         G
                OCTAL                           O
                LOGICAL                         L
                ALPHANUMERIC                    A
                RIGHT ALPHANUMERIC              R
                STRING                          S
                HOLLERITH                       H
                TEXT                            ' '," "
                SPACING                         X,T
                END OF RECORD                   /
                NO END OF RECORD                &
          ACCEPT/DISPLAY (FORMATLESS TERMINAL I/O)
          FILE HANDLING
                OPEN
                CLOSE
                READ/WRITE
                POSITION
                FUNCTIONS
                  POSITION
                  SIZE


6.0   SPECIFICATION STATEMENTS
	STORAGE SPECIFICATION
	    DIMENSION
	    COMMON
	    EQUIVALENCE
	DATA SPECIFICATION
	    DATA STATEMENT
	    BLOCK DATA
	TYPE SPECIFICATION
	    IMPLICIT
	    INTEGER
	    REAL
	    DOUBLE PRECISION
	    COMPLEX
	    LOGICAL
	    STRING
	EXTERNAL



7.0   SUBPROGRAM STATEMENTS
	STATEMENT FUNCTIONS
	FUNCTION DEFINITIONS
	SUBROUTINE DEFINITIONS
	    CALL
	    RETURN
	ENTRY STATEMENTS
	PROGRAM STATEMENTS




1.0	GENERAL

CHARACTER SET
	THE FULL ASCII CHARACTER SET WILL BE ACCEPTED BY THE
	COMPILER.  NON-PRINTING CHARACTERS WILL BE IGNORED AS 
	MEANINGLESS AND A NON-FATAL WARNING MESSAGE WILL BE
	PRINTED.
	LOWER CASE ALPHABETICS WILL BE TREATED AS UPPER CASE BY THE
	COMPILER.  LITERAL STRINGS OF LOWER CASE CHARACTERS WILL NOT
	BE CONVERTED.
	IN ADDITION, THE FOLLOWING CHARACTERS WILL BE APPROPRIATELY
	INTERPRETED BY THE COMPILER; HORIZONTAL TAB, LINE FEED,
	VERTICAL TAB, FORM FEED, AND CARRIAGE RETURN.


MULTIPLE STATEMENTS PER LINE
	MORE THAN ONE STATEMENT PER LINE WILL BE ALLOWED BY THE
	COMPILER.  STATEMENTS WILL BE SEPARATED BY ; (SEMICOLON).
	STATEMENTS AFTER THE FIRST ARE NOT ALLOWED TO HAVE LABELS
	NOR CAN THESE STATEMENTS BE CONTINUATIONS OF PREVIOUS
	STATEMENTS.


LINE FORMAT
	COMMENTS
	    ANY LINE WHOSE FIRST NON-BLANK CHARCTER IS * (ASTERISK)
	    IS COMPILED AS A LINE OF COMMENT.  A COMMENT LINE MAY
	    APPEAR ANYWHERE IN THE SOURCE CODE.  COMMENTS MAY ALSO
	    APPEAR ON THE SAME LINE AS A STATEMENT IF IT IS
	    PRECEDED BY ! (EXCLAMATION MARK).  THE CHARACTERS
	    AFTER THE EXCLAMATION MARK WILL BE TREATED AS
	    COMMENTS UP TO THE END OF LINE.

	CONTINUATION LINES
	    SOURCE STATEMENTS WHICH REQUIRE MORE THAN ONE LINE ON 
	    THE TERMINAL MAY BE CONTINUED BY TERMINATING EACH
	    OF THE INTERMEDIATE LINES WITH A LINE FEED,
	    RESERVING THE CARRIAGE RETURN FOR THE FINAL LINE OF
	    THE STATEMENT.


2.0   CONSTANTS, VARIABLES, AND EXPRESSIONS


CONSTANTS
 	A FORTRAN CONSTANT IS A FIXED UNVARYING QUANTITY.  THERE ARE
	FOUR CLASSES OF CONSTANTS.
	   1.	NUMERIC VALUES - INTEGER,REAL,DOUBLE PRECISION,COMPLEX,
				  AND OCTAL.
	   2.	TRUTH VALUES - LOGICAL CONSTANTS
	   3.	LITERAL DATA - HOLLERITH AND STRING CONSTANTS
	   4.	LABEL CONSTANTS

    INTEGER CONSTANTS
	AN INTEGER CONSTANT CONSISTS OF FROM ONE TO ELEVEN DECIMAL
	DIGITS WRITTEN WITHOUT A DECIMAL POINT.  A NEGATIVE INTEGER
	MUST BE PRECEDED BY A MINUS SIGN; A POSITIVE INTEGER MAY
	BE PRECEDED BY A PLUS SIGN.  AN INTEGER CONSTANT MUST BE
	WITHIN THE RANGE -(2^35) TO +(2^35-1).  WHEN USED AS
	A SUBSCRIPT,  THE VALUE OF AN INTEGER CONSTANT IS TAKEN
	MODULO 2^18.

    REAL CONSTANTS
	REAL CONSTANTS ARE WRITTEN AS A STRING OF DECIMAL DIGITS
	OPTIONALLY INCLUDING A DECIMAL POINT.  REAL CONSTANTS
	MAY BE GIVEN A DECIMAL SCALE FACTOR BY APPENDING AN E
	FOLLOWED BY A SIGNED OR UNSIGNED INTEGER CONSTANT.  THE
	FIELD FOLLOWING THE LETTER E MUST NOT BE BLANK BUT MAY
	BE ZERO.
	A REAL CONSTANT HAS PRECISION TO EIGHT DIGITS.  THE
	MAGNITUDE MUST BE WITHIN THE RANGE 0.14X10^-38 TO
	1.7X10^38.

    DOUBLE PRECISION CONSTANTS
	A DOUBLE PRECISION CONSTANT IS SPECIFIED BY A STRING OF 
	DECIMAL DIGITS OPTIONALLY INCLUDING A DECIMAL POINT.  A
	DECIMAL SCALE FACTOR MAY BE SPECIFIED BY
	APPENDING A D FOLLOWED BY A SIGNED OR UNSIGNED INTEGER
	CONSTANT.  THE FIELD FOLLOWING THE D MUST NOT BE BLANK
	BUT MAY BE ZERO.
	DOUBLE PRECISION CONSTANTS HAVE PRECISION TO 16 DIGITS. 
	THE MAGNITUDE OF A DOUBLE PRECISION CONSTANT MUST LIE 
	BETWEEN 0.14X10^-38 AND 1.7X10^38.

    OCTAL CONSTANTS
	AN OCTAL CONSTANT IS SPECIFIED BY A SEQUENCE OF OCTAL DIGITS
	ENCLOSED IN SINGLE QUOTES AND PRECEDED BY THE LETTER O.
	A MAXIMUM OF TWELVE OCTAL DIGITS ARE PERMITTED IN EACH 
	CONSTANT.  THE DIGITS ARE STORED RIGHT JUSTIFIED.  IF AN 
	OCTAL CONSTANT IS STORED IN A TWO WORD FIELD, THE DIGITS 
	ARE RIGHT JUSTIFIED IN THE HIGH ORDER WORD IF TWELVE
	OR FEWER DIGITS ARE SPECIFIED.  OTHERWISE THE CONSTANT IS 
	RIGHT JUSTIFIED IN THE TWO WORD FIELD.  WHEN A SIGN IS
	SPECIFIED, IT PRECEDES THE LETTER O.

    COMPLEX CONSTANTS
	COMPLEX CONSTANTS ARE WRITTEN AS AN ORDERED PAIR OF
	REAL CONSTANTS SEPARATED BY A COMMA AND ENCLOSED IN
	PARENTHESES.  THE FIRST CONSTANT OF THE PAIR REPRESENTS
	THE REAL PART OF THE COMPLEX NUMBER AND THE SECOND 
	CONSTANT REPRESENTS THE IMAGINARY PART.  EACH REAL 
	CONSTANT MAY BE SIGNED.  THE ENCLOSING PARENTHESES
	ARE PART OF THE CONSTANT AND MUST ALWAYS APPEAR,
	REGARDLESS OF CONTEXT.


    LOGICAL CONSTANTS
	THE TWO LOGICAL CONSTANTS, .TRUE. AND .FALSE., HAVE THE
	INTERNAL VALUES -1 AND 0 RESPECTIVELY.  THE ENCLOSING PERIODS 
	ARE PART OF THE CONSTANT AND MUST ALWAYS APPEAR.  
	LOGICAL QUANTITIES MAY BE OPERATED ON IN EITHER ARITHMETIC OR
	LOGICAL EXPRESSIONS.  ONLY THE SIGN IS TESTED TO DETERMINE
	THE TRUTH VALUE OF A LOGICAL VARIABLE.

    LITERAL CONSTANTS
	THERE ARE TWO TYPES OF LITERAL CONSTANTS, HOLLERITH AND
	STRING.  HOLLERITH CONSTANTS ARE WORD ORIENTED WITH UNUSED
	CHARACTERS IN THE WORD BEING CONVERTED TO SPACES.
	STRING CONSTANTS ARE CHARACTER ORIENTED, USING AS MANY
	STORAGE WORDS AS NECESSARY AND LEAVING UNUSED CHARACTERS
	UNDEFINED.

	HOLLERITH CONSTANTS
	    A HOLLERITH CONSTANT MAY BE EITHER OF TWO FORMS:
	     A.	A STRING OF CHARACTERS IN THE FORM
		    NHX(1)X(2)...X(N)
		WHERE X(1),X(2),...,X(N) ARE THE CHARACTERS IN
		THE CONSTANT AND N IS THE NUMBER OF CHARACTERS
		FOLLOWING THE R.  CHARACTERS ARE STORED LEFT JUSTIFIED 
		WITH BLANK PADDING.
	     B.	A STRING OF CHARACTERS IN THE FORM
		    NRX(1)X(2)...X(N)
		WHERE X(1),X(2),...,X(N) ARE THE CHARACTERS IN THE
		CONSTANT AND N IS THE NUMBER OF CHARACTERS FOLLOWING
		THE R.  CHARACTERS ARE STORED RIGHT JUSTIFIED
		WITH BLANK PADDING.
	    HOLLERITH CONSTANTS MAY BE ENTERED AS A STRING OF UP TO 5
	    7-BIT ASCII CHARACTERS PER VARIABLE (10 CHARACTERS IF
	    VARIABLE IS DOUBLE PRECISION OR COMPLEX).  A TAB IS
	    COUNTED AS A SINGLE CHARACTER.

	STRING CONSTANTS
	    A STRING CONSTANT IS A SEQUENCE OF CHARACTERS ENCLOSED IN
	    SINGLE OR DOUBLE QUOTE MARKS.  THE VALUE OF A
	    STRING CONSTANT IS THE STRING OF CHARACTERS INSIDE THE
	    DELIMITING QUOTE MARKS.




    LABEL CONSTANTS
	A LABEL CONSTANT IS DEFINED AS A STRING OF 1 TO 5 DECIMAL
	DIGITS PRECEDED BY A $ (DOLLAR SIGN).  IT IS USED IN SUBPROGRAM
	ARGUMENT LISTS TO IDENTIFY A STATEMENT HAVING A LABEL 
	IDENTIFIED BY THE DIGIT STRING.  THE ADDRESS OF THIS
	STATEMENT IS PASSED TO THE CALLED SUBPROGRAM.


VARIABLES
	A FORTRAN VARIABLE IS A UNIT OF STORAGE IDENTIFIED 
	BY A SYMBOLIC NAME.  THIS SYMBOLIC NAME OR
	IDENTIFIER MUST BE 1 TO 6 ALPHANUMERIC CHARACTERS,
	THE FIRST OF WHICH MUST BE ALPHABETIC.  VARIABLES 
	IDENTIFY DATA WHOSE VALUES MAY CHANGE DURING
	EXECUTION OF A PROGRAM.

	VARIABLES MAY BE ANY OF THE SIX VALID DATA TYPES -
	INTEGER, REAL, DOUBLE PRECISION, LOGICAL ,COMPLEX ,AND
	STRING.  IF A VARIABLE HAS NOT BEEN ASSIGNED A SPECIFIC
	TYPE IN A TYPE DECLARATION STATEMENT OR IMPLICIT 
	STATEMENT, THEN THE FOLLOWING CONVENTION IS ASSUMED.
	IF THE FIRST LETTER OF THE VARIABLE NAME IS I,J,
	K,L,M, OR N THEN ITS TYPE IS INTEGER.
	IF THE FIRST LETTER OF THE IDENTIFIER IS ANY
	OTHER, THE VARIABLE TYPE IS REAL.

	VARIABLES ALWAYS SPECIFY VALUES.  THE VALUE
	SPECIFIED BY THE IDENTIFIER IS ALWAYS THE CURRENT
	VALUE IN ITS ASSIGNED STORAGE AREA.  BEFORE A
	VARIABLE HAS BEEN ASSIGNED A VALUE, ITS CONTENTS 
	ARE UNDEFINED.


    SCALARS
	A SCALAR VARIABLE REPRESENTS A SINGLE QUANTITY, OCCUPYING
	ONE STORAGE WORD IF INTEGER, REAL, OR LOGICAL, AND TWO
	STORAGE WORDS IF DOUBLE PRECISION OR COMPLEX.  STRING
	VARIABLES OCCUPY (N/5)+1 WORDS WHERE N IS THE DECLARED
	STRING LENGTH.


    ARRAYS
	AN ARRAY VARIABLE REPRESENTS AN N DIMENSIONAL SET OF
	QUANTITIES.  AN ELEMENT OF THE SET IS SPECIFIED BY THE
	ARRAY NAME FOLLOWED BY A SUBSCRIPT LIST ENCLOSED IN
	PARENTHESES.  THE NUMBER OF SUBSCRIPTS AND THEIR
	RANGES MUST BE DECLARED PRIOR TO ANY ARRAY REFERENCES.

	THE SUBSCRIPT LIST IS A SEQUENCE OF ARITHMETIC EXPRESSIONS
	SEPARATED BY COMMAS.  NON-INTEGER EXPRESSIONS ARE CONVERTED 
	TO INTEGER VALUES.  SUBSCRIPTS MAY THEMSELVES BE 
	SUBSCRIPTED EXPRESSIONS.  THE DEPTH OF SUBSCRIPT NESTING
	IS UNLIMITED.

	ARRAYS ARE STORED IN INCREASING STORAGE LOCATIONS WITH
	THE FIRST SUBSCRIPT VARYING MOST RAPIDLY AND THE LAST 
	VARYING LEAST RAPIDLY.


EXPRESSIONS
	THERE ARE THREE KINDS OF FORTRAN EXPRESSIONS; ARITHMETIC
	LOGICAL, AND STRING.  THE VALUE OF AN ARITHMETIC EXPRESSION
	IS ALWAYS A NUMERIC CONSTANT.  THE VALUE OF A LOGICAL
	EXPRESSION IS TRUE OR FALSE.  THE VALUE OF A STRING
	EXPRESSION IS A SEQUENCE OF CHARACTERS.

    ARITHMETIC EXPRESSIONS
	A SIMPLE ARITHMETIC EXPRESSION MAY BE A SINGLE CONSTANT,
	VARIABLE, ARRAY ELEMENT, FUNCTION REFERENCE, OR AN ARITHMETIC
	EXPRESSION ENCLOSED IN PARENTHESES.  THE EXPRESSION
	MAY BE INTEGER, REAL, DOUBLE PRECISION, OR COMPLEX.  
	ARITHMETIC EXPRESSIONS ARE FORMED BY COMBINING
	TWO OR MORE SIMPLE ARITHMETIC EXPRESSIONS WITH 
	ARITHMETIC OPERATORS.  THESE OPERATORS ARE:
		**, ^	EXPONENTIATION
		*	MULTIPLICATION
		/	DIVISION
		+	ADDITION
		-	SUBTRACTION

	FULL MIXED MODE EXPRESSIONS MAY OCCUR WHENEVER AN ARITHMETIC
	EXPRESSION IS ALLOWED IN THE SYNTAX.  THE ONLY EXCEPTION
	IS THAT A COMPLEX QUANTITY CAN NOT BE COMBINED WITH A DOUBLE
	PRECISION QUANTITY.


	NO TWO ARITHMETIC OPERATORS MAY APPEAR CONSECTUTIVELY
	IN THE SAME EXPRESSION.


    LOGICAL EXPRESSIONS
	A LOGICAL EXPRESSION CONSISTS OF CONSTANTS, VARIABLES,
	FUNCTION REFERENCES, AND ARITHMETIC EXPRESSIONS SEPARATED
	BY A LOGICAL OPERATOR OR RELATIONAL OPERATOR.  THE RESULT
	OF A LOGICAL EXPRESSION HAS THE VALUE .TRUE. (NEGATIVE)
	OR .FALSE. (POSITIVE OR ZERO).  TRUE AND FALSE CONDITIONS
	WILL BE TESTED AS NEGATVE AND POSITIVE RESPECTIVELY.

	LOGICAL OPERATORS ARE AS FOLLOWS WHERE P AND Q ARE EXPRESSIONS:
	.NOT.P		HAS THE VALUE .TRUE. ONLY IF P IS .FALSE.,
			AND HAS THE VALUE .FALSE. ONLY IF P IS .TRUE.
	P.AND.Q		HAS THE VALUE .TRUE. ONLY IF P AND Q ARE BOTH
			.TRUE., AND HAS THE VALUE .FALSE. IF EITHER
			P OR Q IS .FALSE.
	P.OR.Q		(INCLUSIVE OR) HAS THE VALUE .TRUE. IF 
			EITHER P OR Q IS .TRUE., AND HAS THE VALUE
			VALUE .FALSE. ONLY IF BOTH P AND Q ARE
			.FALSE.
	P.XOR.Q		(EXCLUSIVE OR) HAS THE VALUE .TRUE. IF 
			EITHER P OR Q BUT NOT BOTH ARE .TRUE. AND
			HAS THE VALUE FALSE OTHERWISE.
	P.EQV.Q		(EQUIVALENCE) HAS THE VALUE .TRUE. IF P AND Q
			ARE BOTH .TRUE. OR IF BOTH ARE .FALSE. AND
			HAS THE VALUE .FALSE OTHERWISE.


	RELATIONAL OPERATORS ARE AS FOLLOWS:
	.GT. OR >	GREATER THAN
	.GE.    >=	GREATER THAN OR EQUAL TO
	.LT.    <	LESS THAN
	.LE.    <=	LESS THAN OR EQUAL TO
	.EQ.    ==	EQUAL TO
	.NE.    #	NOT EQUAL TO


    STRING EXPRESSIONS
	A STRING EXPRESSION IS FORMED BY COMBINING STRING CONSTANTS
	OR VARIABLES WITH THE BINARY STRING OPERATOR + (PLUS).
	THE VALUE OF THE RESULT IS A STRING FORMED BY THE CONCATENATION
	OF THE TWO OPERANDS.

	STRINGS MAY ALSO BE MANIPULATED THROUGH THE USE OF SEVERAL 
	LIBRARY FUNCTIONS.
	LENGTH
	LEFT
	RIGHT
	SUBSTR
	INDEX
	STR
	VAL
	CHAR
	ASC


3.0   ASSIGNMENT STATEMENTS


    ARITHMETIC ASSIGNMENT STATEMENTS
	THE STANDARD FORM OF THIS STATEMENT IS V=E WHERE V IS A
	VARIABLE NAME OR ARRAY ELEMENT OF ANY TYPE AND E IS AN
	ARITHMETIC EXPRESSION.  THIS FORM IS EXTENDED TO
	V=V1=V2=...=E WHERE THE VI ARE VARIBLES AND E IS ANY 
	ARITHMETIC EXPRESSION.

    GO TO ASSIGNMENT STATEMENT
	LABEL VALUES MAY BE GIVEN TO VARIBLES THROUGH A STATEMENT
	OF THE FORM 
	    ASSIGN K TO I
	WHERE K IS A STATEMENT LABEL AND I IS A VARIBLE OF ANY TYPE 
	EXCEPT DOUBLE PRECISION OR COMPLEX.  THE VARIABLE NAME USED
	IN THIS STATEMENT WILL BE IMPLICITLY TYPED AS A LABEL
	VARIABLE AND A DIAGNOSTIC WARNING MESSAGE IS GENERATED WHENEVER
	THE VARIABLE IS USED IN AN ARITHMETIC EXPRESSION.


    STRING ASSIGNMENT STATEMENT
	THE STRING REPLACEMENT STATEMENT IS A SPECIAL FORM OF THE
	ARITHMETIC STATEMENT V=E WHERE V IS A STRING VARIABLE
	AND E IS A STRING EXPRESSION.

4.0   CONTROL STATEMENTS


GO TO STATEMENTS
    ALL FORMS OF THE GO TO STATEMENT MAY APPEAR ANYWHERE IN THE 
    SOURCE PROGRAM, EXCEPT AS THE TERMINAL STATEMENT OF A DO LOOP.

    UNCONDITIONAL GO TO
	USE:	UNCONDITION TRANSFER TO INDICATED LABEL
	FORM:	GO TO N
		WHERE N IS A STATEMENT LABEL.
	RULES:	N MUST BE A STATEMENT LABEL DEFINED IN THE CURRENT
		SOURCE MODULE.  REFERENCED LABELS WHICH ARE
		UNDEFINED WILL BE IDENTIFIED AS ERRORS AT COMPILE TIME.

    ASSIGNED GO TO
	USE:	A CONDITIONAL TRANSFER DEPENDING UPON WHAT
		STATEMENT LABEL WAS ASSIGNED TO THE CONTROL
		VARIABLE.
	FORMS:	GO TO I
		GO TO I (N1,N2,...,NN)
		    WHERE I IS A VARIABLE AND N1,N2,...NN ARE
		    STATEMENT NUMBERS.
	RULES:	THE VARIABLE I MUST HAVE BEEN USED IN AN ASSIGN
		STATEMENT PRIOR TO THE EXECUTION OF THE GO TO.

		IF THE LIST OF STATEMENT NUMBERS APPEARS, THE
		I MUST HAVE BEEN ASSIGNED ONE OF THE STATEMENT
		NUMBERS APPEARING IN THE LIST.  IF I IS NOT
		IN THE LIST, CONTROL IS TRANSFERRED TO THE NEXT
		EXECUTABLE STATEMENT.

    COMPUTED GO TO
	USE:	A CONDITIONAL TRANSFER TO ONE OF A SET OF 
		STATEMENT LABELS DEPENDING ON THE VALUE OF A
		CONTROL EXPRESSION COMPUTED AT RUN TIME.
	FORM:	GO TO (N1,N2,...,NN) E
		    WHERE E IS A GENERAL EXPRESSION AND THE NI
		    ARE STATEMENT LABELS.
	RULES:	THE NI MUST ALL BE LABELS DEFINED IN THE CURRENT
		SOURCE MODULE.

		THE VALUE OF E MUST COMPUTE TO AN INTEGER VALUE
		GREATER THAN ZERO AND LESS THAN OR EQUAL TO THE
		NUMBER OF STATEMENT LABELS IN THE LIST.

		ONCE THE VALUE OF E IS COMPUTED AND VERIFIED,
		THEN A TRANSFER TO THE STATEMENT LABEL IN THE
		CORRESPONDING POSITION IS EXECUTED.  IF THE VALUE
		IS INVALID, THEN THE NEXT EXECUTABLE STATEMENT
		IS EXECUTED.

		THE COMMA SPECIFIED AFTER THE RIGHT PARENTHESIS BY
		STANDARDS, IS OPTIONAL.




IF STATEMENT

    ARITHMETIC IF STATEMENT
	USE:	TO PROVIDE MULTIPLE WAY TRANSFER DEPENDING ON THE
		VALUE OF A CONTROL EXPRESSION.
	FORM:	IF (E) N1,N2,N3
		    WHERE E IS AN ARITHMETIC EXPRESSION AND N1,N2,
		    N3 ARE LABELS FOR STATEMENTS IN THE CURRENT 
		    SOURCE MODULE.
	RULES:	ALL THREE LABELS, N1, N2, AND N3, MUST APPEAR
		IN THE STATEMENT.

		IF THE EXPRESSION VALUE IS LESS THAN ZERO, TRANSFER
		TO THE STATEMENT LABEL N1.  IF THE VALUE IS EQUAL
		TO ZERO, TRANSFER TO N2.  IF THE VALUE IS GREATER THAN 
		ZERO, TRANSFER TO STATEMENT N3.


    LOGICAL IF STATEMENT
	USE:	TO PROVIDE A TWO WAY BRANCH BASED ON THE TRUTH
		VALUE OF A LOGICAL EXPRESSION.
	FORMS:	IF (E) S
		IF (E) S .ELSE. S2
		    WHERE E IS A LOGICAL EXPRESSION AND S AND S2 ARE
		    COMPLETE STATEMENTS.
	RULES:	S CAN NOT BE A DO STATEMENT OR ANOTHER LOGICAL IF.

		IF THE VALUE OF THE EXPRESSION IS TRUE, EXECUTE S.
		AFTER EXECUTION OF S, CONTROL PASSES TO THE NEXT
		SEQUENTIAL STATEMENT UNLESS S IS A GO TO OR
		ARITHMETIC IF; IN THESE CASES, CONTROL IS 
		TRANSFERRED AS INDICATED.
		IF THE VALUE IS FALSE, EXECUTE S2 IF THE .ELSE.
		CLAUSE IS PRESENT; OTHERWISE EXECUTE THE NEXT SEQUENTIAL
		STATEMENT.


DO STATEMENT
	USE:	DEFINITION OF CONTROLLED LOOPING MECHANISM
	FORM:	DO N V=M1,M2,M3
		    WHERE V IS THE SCALAR INDEX VARIABLE, N IS
		    THE STATEMENT NUMBER OF THE LAST STEP IN THE
		    REPETITION, M1 IS THE INITIAL VALUE OF THE 
		    INDEX VARIABLE, M2 IS THE FINAL VALUE AND
		    M3 IS THE INCREMENT.
	RULES:	EACH OF THE INDEXING PARAMETERS M1,M2, AND M3
		MAY BE ANY ARITHMETIC EXPRESSION WITH POSITIVE OR
		NEGATIVE VALUES.

		M3 IS OPTIONAL BUT M1 AND M2 MUST ALWAYS APPEAR.
		IF M3 IS NOT SPECIFIED, IT IS ASSUMED TO BE 1.

		THE RANGE OF THE DO IS ALWAYS EXECUTED AT LEAST
		ONCE.  THE VALUES M1, M2, AND M3 ARE EVALUATED
		ONLY ONCE AT THE BEGINNING OF THE LOOP.

		THE STANDARD NESTING AND TRANSFER RESTRICTIONS ARE
		ASSUMED.

		SUCCESSIVE ITERATIONS ARE DETERMINED BY THE FOLLOWING
		STEPS:
		1. THE VALUE OF V IS INCREMENTED BY M3.
		2. THE VALUE OF V IS COMPARED WITH M2.
		    IF M3 IS POSITIVE, IS V GREATER THAN M2?
		    IF M3 IS NEGATIVE, IS V LESS THAN M2?
		3. IF THE APPROPRIATE RELATION IS TRUE, CONTROL IS
		   PASSED TO THE STATEMENT FOLLOWING THE TERMINUS
		   OF THE DO LOOP.
		4. IF THE VALUE OF M3 IS ZERO THE LOOP IS EXD 
		   INDEFINITELY.

		THE DO LOOP INDEX BECOMES MATERIALIZED ON THE 
		FOLLOWING CONDITIONS:
		1. WHEN CONTROL PASSES OUT OF THE RANGE OF THE DO
		   BY EXECUTION OF A GO TO, IF, OR RETURN STATE-
		   MENT INSIDE THE LOOP.
		2. A CALL IS EXECUTED WITH THE DO INDEX AS A PARAMETER.
		3. IF AN END= OR ERR= CONSTRUCT APPEARS IN AN
		   I/O STATEMENT INSIDE THE LOOP.

		THE TERMINAL STATEMENT OF A DO LOOP MAY BE ANY
		EXECUTABLE STATEMENT EXCEPT:
		1. DO
		2. GO TO
		3. ARITHMETIC IF
		4. RETURN





    CONTINUE STATEMENT
	USE:	TO SERVE AS A DUMMY STATEMENT ANYWHERE IN THE PROGRAM.
	FORM:	CONTINUE
	RULES:	NO CODE IS GENERATED FOR THE STATEMENT.

		THE PRIMARY USE OF THE CONTINUE STATEMENT IS AS A
		REFERENCE POINT FOR CONTROL STATEMENTS, ESPECIALLY
		AS THE LAST STATEMENT OF A DO LOOP.


    IMPLIED DO LOOPS
	USE:	REPEATED EXECUTION OF A SINGLE STATEMENT
	FORM:	(S), V=M1,M2,M3
		    WHERE S IS AN EXECUTABLE STATEMENT AND V, M1,
		    M2, AND M3 ARE DEFINED AS FOR EXPLICIT DO LOOPS.
	RULES:	THE PRIMARY USE OF THIS STATEMENT IS 
		TO REPLACE DO LOOPS WHICH HAVE ONLY ONE 
		EXECUTABLE STATEMENT.

		THE PARAMETERS V, M1, M2, AND M3 FOLLOW THE SAME
		RULES AS THE ANALAGOUS QUANTITIES IN AN EXPLICIT DO.


PAUSE STATEMENT
	USE:	TO TEMPORARILY SUSPEND EXECUTION OF A PROGRAM
	FORMS:	PAUSE
		PAUSE N
		    WHERE N IS AN INTEGER OR STRING CONSTANT.
	RULES:	EXECUTION OF THE PAUSE STATEMENT CAUSES N
		IF PRESENT, TO BE WRITTEN ON THE TERMINAL AND THE 
		PROGRAM TO BE SUSPENDED.  TYPING THE CCS COMMAND
		CONTINUE CAUSES EXECUTION TO BE RESUMED AT THE NEXT
		SEQUENTIAL STATEMENT.


STOP STATEMENT
	USE:	CAUSES PROGRAM EXECUTION TO BE TERMINATED AND 
		CONTROL RETURNED TO CCS.
	FORMS:	STOP
		STOP N
		    WHERE N IS AN INTEGER OR STRING CONSTANT.
	RULES:	EXECUTION OF THE STOP STATEMENT CAUSES N, IF
		PRESENT, TO BE WRITTEN ON THE TERMINAL AND THE
		PROGRAM TO BE HALTED.  THE PROGRAM CAN NOT BE CONTINUED.


QUIT STATEMENT
	USE:	TO RETURN DIRECTLY TO TYMEX WITHOUT FIRST RETURNING
		TO THE CCS COMMAND MODE.
	FORM:	QUIT N
		    WHERE N IS AN OPTIONAL STRING OR INTEGER CONSTANT.
	RULES:	EXECUTION OF THIS STATEMENT CAUSES N, IF
		PRESENT, TO BE PRINTED AT THE TERMINAL.  IMMEDIATELY
		AFTER THIS, THE USER IS RETURNED TO TYMEX.


END STATEMENT
	USE:	TO INDICATE THE LAST LINE OF A SOURCE MODULE.
	FORM:	END
	RULES:	THE END STATEMENT IMPLIES A STOP STATEMENT IN
		A MAIN MODULE AND A RETURN STATEMENT IN A SUBPROGRAM
		MODULE.

		THE END STATEMENT MAY NOT BE LABELED.




6.0   SPECIFICATION STATEMENTS
	THE STANDARD RULE ABOUT PLACEMENT OF SPECIFICATION 
	STATEMENTS BEFORE ALL EXECUTABLE STATEMENTS IS RELAXED TO
	ALLOW PLACEMENT OF THE STATEMENTS ANYWHERE IN THE SOURCE 
	PROGRAM AS LONG AS THEY APPEAR BEFORE ANY EXECUTABLE
	REFERENCES TO THE VARIABLES THEY SPECIFY.  THE IMPLICIT
	STATEMENT, HOWEVER, MUST ALWAYS APPEAR BEFORE ALL
	OTHER SPECIFICATION STATEMENTS.


STORAGE SPECIFICATION

    DIMENSION STATEMENT
	USE:	RESERVE STORAGE FOR ARRAYS.
	FORM:	DIMENSION A1,A2,...AN
		    WHERE AI IS AN ARRAY DECLARATION OF THE FORM
			NAME (MIN1/MAX1,MIN2/MAX2,...,MINK/MAXK)
		    MINI AND MAXI BEING THE MINIMUM AND MAXIMUM
		    VALUES THAT SUBSCRIPT I MAY ATTAIN.
	RULES:	THE MINIMUM AND MAXIMUM SPECIFICATIONS MAY BE INTEGER
		CONSTANTS OR INTEGER DUMMY VARIABLES.  IF OMITTED, 
		THE MINIMUM IS ASSUMED TO BE ONE.

		ARRAY NAMES MAY NOT BE DIMENSIONED MORE THAN ONCE 
		IN A PROGRAM MODULE.

		EACH ARRAY REFERENCE WILL CAUSE 
		THE VALUE OF EACH SUBSCRIPT TO BE COMPARED TO
		THE SPECIFIED RANGE.  IF THE VALUE IS LEGAL,
		EXECUTION WILL CONTINUE NORMALLY; OTHERWISE AN
		ERROR MESSAGE IS PRINTED AND THE PROGRAM PAUSES.




    COMMON STATEMENT
	USE:	TO CAUSE DESIGNATED DATA ITEMS TO BE ALLOCATED
		STORAGE IN AN AREA AVAILABLE TO OTHER MODULES.
	FORM:	COMMON /A1/V11,...,V1N/A2/V21,...V2N...
		    WHERE THE AI ARE IDENTIFIERS INDICATING
		    BLOCK NAMES AND THE VIK ARE VARIABLE NAMES.
	RULES:	THE VIK MAY CONTAIN DIMENSION INFORMATION.

		THE BLOCK NAME MAY NOT BE THE NAME OF A SUBPROGRAM.

		THE /AI/ CONSTRUCT IS OPTIONAL.  IF IT
		APPEARS, THE DECLARED VIK ARE IN LABELLED COMMON.
		IF THE /AI/ CONSTRUCT IS NOT USED, THE VIK
		ARE IN BLANK COMMON.  TWO CONSECUTIVE SLASHES CAN
		BE USED TO INDICATE BLANK COMMON.

		A GIVEN COMMON BLOCK NAME MAY APPEAR MORE THAN
		ONCE IN A COMMON STATEMENT OR IN A PROGRAM
		MODULE.  ALL VIK ARE ASSIGNED TO THE COMMON
		BLOCKS IN THE ORDER OF THEIR APPEARANCE.
		THE ALLOCATION IS SUBJECT TO ANY EQUIVALENCE
		DECLARATIONS AFFECTING COMMON VARIABLES.

		THE VIK MUST BE VARIABLE IDENTIFIERS, EITHER
		SCALAR OR ARRAY.  DUMMY NAMES ARE NOT PERMITTED.



    EQUIVALENCE STATEMENT
	USE:	TO CONSERVE STORAGE BY HAVING SEVERAL 
		VARIABLES USE THE SAME LOCATION.
	FORM:	EQUIVALENCE (K1),(K2),...,(KN)
		    WHERE EACH KI IS AN IDENTIFIER LIST OF THE FORM
		    A,B,C,...
	RULES:	THE IDENTIFIERS IN THE LISTS MAY SPECIFY SCALARS,
		ARRAYS, OR ARRAY ELEMENTS.  DUMMY ARGUMENTS
		ARE NOT PERMITTED IN THE LIST.

		THERE MUST BE AT LEAST TWO LIST ELEMENTS IN EACH KI.

		EACH ELEMENT OF A GIVEN LIST IS ASSIGNED THE
		SAME STORAGE LOCATION.

		THE EFFECT OF AN EQUIVALENCE STATEMENT UPON
		COMMON BLOCK ASSIGNMENT MAY BE THE LENGTHENING
		OF THE COMMON BLOCK.  HOWEVER, THE EXTENSION
		MAY ONLY OCCUR BEYOND THE LAST ASSIGNMENT
		MADE FOR THAT BLOCK BY ANY COMMON STATEMENT
		IN THE SAME PROGRAM MODULE.

		WHEN TWO VARIABLES OR ARRAY ELEMENTS SHARE 
		STORAGE THROUGH EQUIVALENCE,  THE IDENTIFIERS
		MAY NOT BOTH APPEAR IN COMMON STATEMENTS IN
		THE SAME PROGRAM MODULE.




DATA SPECIFICATION


    DATA STATEMENT
	USE:	TO SPECIFY VALUES OF VARIABLES AT COMPILE TIME.
	FORM:	DATA LIST/D1,D2,...,DN/,LIST/DN+1,DN+2,...,DM/
		    WHERE LIST IS A VARIABLE ARRAY REFERENCE OR IMPLIED
		    DO CONSTUCTION OR A LIST OF THESE ITEMS
		    ENCLOSED IN PARENTHESES AND THE DI ARE DATA
		    ITEMS.
	RULES:	DATA ITEMS MAY BE NUMERIC CONSTANTS, 
		LITERALS,STRING CONSTANTS,OCTAL CONSTANTS, OR
		LOGICAL CONSTANTS.  THE CONSTRUCT N*DI MAY
		ALSO BE USED AS A DATA ITEM WHERE N IS AN 
		INTEGER CONSTANT SPECIFYING THE NUMBER OF TIMES
		THE DATA ITEM IS REPEATED.

		WHEN THE TYPE OF THE DATA AND THE TYPE OF THE 
		VARIABLE DISAGREE, THE DATA IS CONVERTED TO THE 
		TYPE OF THE VARIABLE ACCORDING TO THE ARITHMETIC
		ASSIGNMENT RULES.  A WARNING MESSAGE WILL NOTIFY
		THE USER OF THIS CONVERSION.


    BLOCK DATA SUBPROGRAM STATEMENT
	USE:	TO DECLARE A DATA SPECIFICATION SUBPROGRAM.
	FORM:	BLOCK DATA I
		    WHERE I IS AN OPTIONAL MODULE NAME
	RULES:	THIS SUBPROGRAM IS USED TO INITIALIZE STORAGE ARES 
		WITH DATA BY USING THE DATA STATEMENT.  ONLY
		LABELLED COMMON VARIABLES CAN BE INITIALIZED IN
		THIS SUBPROGRAM.  

		NO EXECUTABLE STATEMENT MAY APPEAR IN THIS MODULE.

		A NAME MAY BE GIVEN TO A BLOCK DATA AND MORE THAN
		ONE BLOCK DATA MODULE MAY APPEAR WITHIN A PROGRAM.

		USE OF THE BLOCK DATA SUBPROGRAM IS OPTIONAL.


    IMPLICIT STATEMENT
	USE:	TO ALTER THOSE DEFAULT TYPING CONVENTIONS WHICH
		ARE BASED ON THE FIRST LETTER OF THE IDENTIFIER.
	FORM:	IMPLICIT T1(A11,A12,...,A1N),...,TM(AM1,...,AMK)
		    WHERE TI IS A DATA TYPE AND THE AIJ ARE
		    SINGLE ALPHABETIC CHARACTERS OR RANGES.
	RULES:	VALID DATA TYPES INCLUDE INTEGER, REAL, LOGICAL,
		DOUBLE PRECISION, AND COMPLEX.

		THE AIJ MAY SPECIFY RANGES OF LETTERS BY 
		SEPARATING THE FIRST AND LAST CHARACTER
		OF THE RANGE BY A - (MINUS).

		THIS STATEMENT CAUSES ANY IDENTIFIER WHICH IS
		NOT EXPLICITLY TYPED, AND WHOSE FIRST CHARACTER
		IS ONE OF THOSE SPECIFIED IN THE IMPLICIT
		STATEMENT, TO BE CLASSIFIED ACCORDING TO THE
		THE TYPE APPEARING BEFORE THE LIST IN WHICH THE
		CHARACTER APPEARS.

		THE IMPLICIT STATEMENT MUST PRECEDE ALL OTHER
		SPECIFICATION STATEMENTS IN THE MODULE.

		THERE MUST BE NO CONFLICTING SPECIFICATIONS
		WITHIN A MODULE.  HOWEVER, THE DECLARATIONS
		NEED NOT AGREE ACROSS MODULES.


    EXPLICIT TYPE DECLARATION STATEMENTS
	USE:	TO EXPLICITLY TYPE THOSE VARIABLES IN THE THE LIST
		AS BEING A SPECIFIC TYPE, OVERRIDING ANY IMPLICIT
		TYPING CONVENTION
	FORMS:	INTEGER V1,V2,...,VN
		REAL V1,V2,...VN
		LOGICAL V1,V2,...,VN
		DOUBLE PRECISION V1,V2,...,VN
		COMPLEX V1,V2,...,VN
		STRING V1(L1),V2(L2),...,VN(LN)
		    WHERE VI IS A VARIABLE IDENTIFIER AND LI IS AN
		    INTEGER CONSTANT.
	RULES:	THE VARIABLE IDENTIFIERS CAN BE SCALAR OR ARRAY
		NAMES AND MAY CONTAIN DIMENSION INFORMATION.

		VARIABLE IDENTIFIERS MUST APPEAR IN A TYPE STATE-
		MENT ONLY ONCE WITHIN A PROGRAM MODULE.

		THE (LI) COSTRUCT IS ONLY APPLICABLE FOR STRING
		DECLARATIONS.  LI SPECIFIES THE MAXIMUM NUMBER
		OF CHARACTERS IN THE STRING.


EXTERNAL STATEMENT
	USE:	TO DECLARE IDENTIFIERS TO BE SUBPROGRAM NAMES.
	FORM:	EXTERNAL V1,V2,...,VN
		    WHERE THE VI ARE SUBPROGRAM NAMES.
	RULES:	EXTERNAL NAMES ARE RESERVED THROUGHOUT THE
		THE MODULE AND MAY NOT BE USED LATER IN ANOTHER
		DECLARATION.

		IF AN EXTERNAL SUBPROGRAM NAME IS USED AS AN
		ARGUMENT TO ANOTHER EXTERNAL PROCEDURE, IT MUST
		APPEAR IN AN EXTERNAL STATEMENT IN THE
		CALLING SUBPROGRAM.




7.0   SUBPROGRAM STATEMENTS

	THERE ARE THREE TYPES OF FORTRAN SUBPROGRAMS :  THE 
	ARITHMETIC STATEMENT FUNCTION, THE FUNCTION, AND THE
	SUBROUTINE.  THE ARITHMETIC STATEMENT FUNCTION IS A 
	SINGLE STATEMENT WHICH MAY ONLY BE REFERENCED IN THE
	MODULE IN WHICH IT APPEARS.  THE FUNCTION AND SUBROUTINE
	ARE SEPARATE AND COMPLETE MODULES CONFORMING TO ALL THE
	RULES OF FORTRAN PROGRAMS.

	SUBPROGRAM DEFINITION STATEMENTS CONTAIN DUMMY IDENTIFIERS
	REPRESENTING THE ARGUMENTS OF THE SUBPROGRAM.  THE DUMMY
	IDENTIFIERS ARE REPLACED BY THE ACTUAL ARGUMENTS WHEN 
	THE SUBPROGRAM IS EXECUTED.  DUMMY ARGUMENTS MAY BE REPRESENTED
	BY SCALAR IDENTIFIERS OR BY ARRAY NAMES.  DUMMY ARRAYS
	MUST BE DIMENSIONED WITHIN THE SUBPROGRAM.  THE ACTUAL
	ARGUMENTS MAY BE SCALARS, ARRAY NAMES OR ELEMENTS, AND
	ARITHMETIC, LOGICAL, OR STRING EXPRESSIONS.


	THE FOLLOWING FUNCTIONS ARE INCLUDED IN THE BASIC LIBRARY:
	ABS	INT	MOD	SIGN	DIM	EXP
	ALOG	ALOG10	SIN	COS	SQRT	ATAN
	ATAN2	TAN	MAX0	MIN0	AINT	IFIX
	FLOAT	AMAX1	AMIN1
	A CALL TO THE PROPER ENTRY POINT IN EACH ROUTINE IS 
	GENERATED ACCORDING TO THE TYPE OF THE ARGUMENT.

	IN-LINE CODE RATHER THAN A SUBPROGRAM CALL IS GENERATED
	FOR THE FOLLOWING:
	MAX0	MIN0	AMAX1	AMIN1	SNGL	DBLE
	CMPLX	REAL	MOD	ABS	IFIX	SIGN
	ISIGN	DIM	IDIM
	IF ANY OF THE ABOVE ARE DECLARED EXTERNAL, IT WILL BE
	REFERENCED BY A SUBPROGRAM CALL RATHER THAN BY IN-LINE
	CODE.



STATEMENT FUNCTIONS
	USE:	TO DEFINE ARITHMETIC STATEMENT FUNCTIONS.
	FORM:	F(A1,A2,...,AN)=E
		    WHERE F IS THE FUNCTION IDENTIFIER, THE AI
		    ARE THE DUMMY PARAMETERS AND E IS AN EXPRESSION
		    WHICH DOES NOT CONTAIN A REFERENCE TO F.
	RULES:	STATEMENT FUNCTIONS ARE SINGLE VALUED FUNCTIONS WITH 
		AT LEAST ONE ARGUMENT.  THE TYPE OF THE FUNCTION IS
		DETERMINED BY THE TYPE OF THE FUNCTION IDENTIFIER.

		THE DUMMY IDENTIFIERS MUST AGREE IN NUMBER AND TYPE 
		WITH THE ACTUAL ARGUMENTS IN THE FUNCTION CALL.

		IDENTIFIERS WHICH DO NOT APPEAR AS DUMMY NAMES 
		IN THE ARGUMENT LIST ARE TREATED AS ORDINARY
		VARIABLES.  THE FUNCTION DEFINING EXPRESSION E
		MAY INCLUDE EXTERNAL FUNCTION CALLS AND REFERENCES
		TO OTHER STATEMENT FUNCTIONS.

		ALL ARITHMETIC STATEMENT FUNCTION DEFINITIONS
		MUST PRECEDE THE FIRST EXECUTABLE STATEMENT OF THE 
		SUBPROGRAM.

		THE VALUE OF THE FUNCTION F IS ACCESSED BY THE
		CONSTRUCT F(B1,B2,...,BN) WHERE THE BI ARE THE
		ACTUAL ARGUMENTS.  THIS CONSTRUCT MAY APPEAR
		WHENEVER AN ARITHMETIC EXPRESSION IS VALID.



FUNCTION DEFINITION STATEMENT
	USE:	TO DEFINE A MODULE AS A FUNCTION SUBPROGRAM.
	FORM:	T FUNCTION F (A1,A2,...,AN)
		    WHERE T IS AN OPTIONAL TYPE SPECIFICATION, F IS THE
		    FUNCTION IDENTIFIER, AND THE AI ARE DUMMY
		    ARGUMENTS.
	RULES:	T IS EITHER INTEGER, REAL, DOUBLE PRECISION,
		COMPLEX, OR LOGICAL.  IF T IS NOT PRESENT,
		THE FUNCTION IS TYPED BY THE FIRST CHARACTER OF 
		ITS IDENTIFIER.

		THE CONSTUCT (A1,A2,...,AN) IS OPTIONAL.

		THE VALUE OF A FUNCTION SUBPROGRAM IS ACCESSED
		AS IS THE VALUE OF A STATEMENT FUNCTION.

		WITHIN THE FUNCTION MODULE, THE FUNCTION IDENTIFIER
		F MUST NOT BE USED AS A DUMMY ARGUMENT OR APPEAR
		IN ANY NON-EXECUTABLE STATEMENT OTHER THAN AS A SCALAR
		VARIABLE IN AN EXPLICIT TYPE STATEMENT.  IT MUST BE
		ASSIGNED A VALUE DURING EXECUTION OF THE SUBPROGRAM.
		THE VALUE OF THIS VARIABLE UPON LEAVING THE 
		SUBPROGRAM IS TREATED AS THE FUNCTION VALUE.

		THE ONLY FORTRAN STATEMENTS NOT ALLOWED IN A FUNCTION 
		MODULE ARE SUBROUTINE, BLOCK DATA AND ANOTHER
		FUNCTION STATEMENT.


SUBROUTINE STATEMENT
	USE:	TO DEFINE A MODULE AS A SUBROUTINE SUBPROGRAM.
	FORM:	SUBROUTINE V (A1,A2,...,AN)
		    WHERE V IS THE SUBROUTINE IDENTIFIER AND AI
		    ARE THE DUMMY ARGUMENTS.
	RULES:	THE AI MAY BE $ (DOLLAR SIGN) TO INDICATE THAT THE
		ITH ARGUMENT IS TO BE USED AS A STATEMENT LABEL.

		THE CONSTRUCT (A1,A2,...AN) MAY BE OMITTED IF THERE
		IS NO ARGUMENT LIST.

		THE SUBROUTINE IDENTIFIER V CAN NOT BE USED AS A
		DUMMY ARGUMENT OR APPEAR IN ANY NON-EXECUTABLE
		STATEMENT IN THE MODULE OTHER THAN AS A SCALAR IN
		AN EXPLICIT TYPE STATEMENT.  IT MAY, HOWEVER, APPEAR
		IN ANY EXECUTABLE STATEMENT IN THE MODULE.

		UNLIKE FUNCTION SUBPROGRAMS, THERE IS NO VALUE
		ASSOCIATED WITH THE SUBROUTINE IDENTIFIER V.
		A SUBROUTINE SUBPROGRAM MAY USE ONE OR MORE OF ITS
		DUMMY IDENTIFIERS TO REPRESENT RESULTS.

		SINCE A SUBROUTINE HAS NO VALUE ASSOCIATED WITH IT,
		IT CAN NOT BE REFERENCED AS A BASIC ELEMENT IN AN
		EXPRESSION.  CONTROL IS TRANSFERRED TO A SUBROUTINE
		SUBPROGRAM BY A CALL STATEMENT.

		THE ONLY FORTRAN STATEMENTS NOT ALLOWED IN A 
		SUBROUTINE SUBPROGRAM ARE FUNCTION, BLOCK DATA, AND
		ANOTHER SUBROUTINE STATEMENT.




    CALL STATEMENT
	USE:	TO TRANSFER TO A SUBROUTINE SUBPROGRAM.
	FORM:	CALL V (A1,A2,...,AN)
		    WHERE V IS THE IDENTIFIER OF THE SUBPROGRAM
		    AND (A1,A2,...,AN) IS AN OPTIONAL ARGUMENT LIST.
	RULES:	THE AI ARE CALLED THE ACTUAL ARGUMENTS AND MAY BE
		A SCALAR IDENTIFIER, AN ARRAY ELEMENT, AN ARRAY
		NAME, AN EXTERNAL SUBPROGRAM NAME, AN EXPRESSION
		OR A LABEL CONSTANT.


    RETURN STATEMENT
	USE:	TO CAUSE TRANSFER TO CALLING PROGRAM.
	FORM:	RETURN E
		    WHERE E IS AN OPTIONAL ARITHMETIC EXPRESSION.
	RULES:	IF E IS NOT PRESENT, CONTROL IS TRANSFERRED TO
		THE CALLING PROGRAM AT THE NEXT SEQUENTIAL
		STATEMENT FOLLOWING THE SUBROUTINE CALL.

		THE EXPRESSION E IS EVALUATED AND CONVERTED TO AN
		INTEGER VALUE I.  THE ITH STATEMENT NUMBER ARGUMENT
		IN THE DUMMY LIST INDICATES THE STATEMENT IN THE
		CALLING PROGRAM WHICH WILL RECEIVE CONTROL.

		THE RETURN EXPRESSION FEATURE CAN ONLY BE USED
		IN SUBROUTINE SUBPROGRAMS; NOT IN FUNCTIONS.

		A RETURN STATEMENT IN A MAIN PROGRAM IS TREATED AS 
		A STOP STATEMENT.


ENTRY STATEMENT
	USE:	TO PROVIDE ADDITIONAL ENTRIES INTO A FUNCTION OR
		SUBROUTINE SUBPROGRAM.
	FORM:	ENTRY V (A1,A2,...,AN)
		    WHERE V IS THE ENTRY IDENTIFIER, (A1,A2,...,AN)
		    IS AN OPTIONAL ARGUMENT LIST, AND THE AI ARE
		    DUMMY ARGUMENTS.
	RULES:	ANY NUMBER OF ENTRY STATEMENTS MAY APPEAR IN EACH
		SUBPROGRAM MODULE.

		THE ENTRY STATEMENT ALLOWS ENTRY INTO A SUBPROGRAM
		AT A PLACE OTHER THAN THAT DEFINED BY THE SUB-
		ROUTINE OR FUNCTION STATEMENT.  ANY NUMBER OF 
		ENTRY STATEMENTS MAY BE USED IN EACH MODULE.

		EXECUTION BEGINS AT THE FIRST EXECUTABLE STATEMENT
		FOLLOWING THE ENTRY STATEMENT.

		APPEARANCE OF AN ENTRY STATEMENT IN A SUBPROGRAM
		DOES NOT PRECLUDE THE RULE THAT STATEMENT FUNCTIONS
		MUST PRECEDE THE FIRST EXECUTABLE STATEMENT IN THE
		MODULE.

		ENTRY STATEMENTS ARE NON-EXECUTABLE AND DO NOT AFFECT 
		THE EXECUTION FLOW OF A MODULE.

		AN ENTRY STATEMENT MAY NOT APPEAR IN A MAIN PROGRAM,
		NOR MAY A SUBPROGRAM REFERENCE ITSELF THROUGH ITS
		ENTRY POINTS.

		AN ENTRY STATEMENT MAY NOT APPEAR IN THE RANGE OF A
		DO OR AN EXTENDED DO CONSTRUCTION.

		THE DUMMY ARGUMENTS IN THE ENTRY STATEMENT NEED NOT 
		AGREE IN ORDER, NUMBER, OR TYPE WITH THE PARAMETERS
		IN THE SUBROUTINE OR FUNCTION DEFINITION STATEMENT
		OR IN OTHER ENTRY STATEMENTS IN THE SAME MODULE.
		HOWEVER, THE ARGUMENTS FOR EACH CALL OR FUNCTION
		REFERENCE MUST AGREE WITH THE DUMMY ARGUMENTS
		IN THE SUBROUTINE, FUNCTION, OR ENTRY STATEMENT
		THAT IS REFERENCED.



PROGRAM STATEMENT
	USE:	TO SUPPLY AN IDENTIFIER FOR A MAIN PROGRAM.
	FORM:	PROGRAM V
		    WHERE V IS AN IDENTIFIER SPECIFYING THE
		    MAIN PROGRAM.
	RULES:	THIS STATEMENT ONLY HAS MEANING FOR MAIN PROGRAMS.
		IF USED, IT MUST BE THE FIRST STATEMENT OF THE MODULE.


   m _Ú