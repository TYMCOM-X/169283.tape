
!**COPYRIGHT 1972,1973 DIGITAL EQUIPMENT CORPORATION, MAYNARD MA 01754**
!AUTHOR NORMA ABEL

GLOBAL BIND GRAPV=96;			!VERSION NUMBER 7/11/73
EXTERNAL TOP,BOTTOM;
FORWARD ASSLOOKER;
OWN P,PA,PB,PREV,PC;
OWN PO,P1,P2,P3,HEAD,TAIL;
MAP PHAZ2 PA:PB:PC:P:PREV;
EXTERNAL THISLEVL,TBLSEARCH,CORMAN,ASIPTR;
FORWARD LOKEXIT;
MAP BASE TOP;
EXTERNAL QQ,LOOP;
EXTERNAL OLDHEAD;
MAP PHAZ2 QQ;
EXTERNAL EXITNO;
EXTERNAL EXITLST;
BIND LLLSIZ=50;		!SIZE OF LOCAL LABEL TABLE (LIST)
BIND EXITSIZ=20;		!SIZE OF EXITLST (DECLARED IN GLOBAL)
OWN LLLNO,LLL[LLLSIZ];
MAP PHAZ2 PO:P1:P2:P3:HEAD:TAIL;
EXTERNAL RGP,FGP;
OWN T,TLEND;
!TLEND IS USED TO KEEP LEND (THE END OF THE PHYSICAL PROGRAM)
!FROM SEEMING TO BE LOGICALLY DISCONNENTED FROM THE GRAPH OF THE
!PROGRAM

EXTERNAL RGRAPH,FGRAPH;
MAP PHAZ2 P:PA;

MAP PHAZ2 OLDHEAD;
EXTERNAL LEND;

!STRUCTURE FOR RGRAPH AND FGRAPH ONLY TO MAKE IT
!BEHAVE LIKE A VECTOR ITSELF INSTEAD OF A POINTER TO POOL.
!WE WILL ALSO USE POOL FROM THE BOTTOM UP, TO EXTEND STACK SIZE
!BY LETTING IT THINK IT HAS POOL ALSO.

	STRUCTURE INDVECT[IX]=
		(@.INDVECT+.IX);

MAP INDVECT RGRAPH:FGRAPH;


!************************************
!*******************************

ROUTINE LNKREV(X,Q)=
BEGIN
	EXTERNAL OPTERR;
	MAP PHAZ2 Q;
	!X IS THE PREDECESSOR OF Q
	T_.Q[PREDPTR];
	RGRAPH[.RGP]<PREDLNK>_.T;
	Q[PREDPTR]_RGRAPH[.RGP];
	RGRAPH[.RGP]<PREDES>_.X;
	RGP_.RGP+1;
	IF .RGP GTR POOLSIZ/2 THEN OPTERR(1);
END;

!**********************************

ROUTINE LNKFWD(X,Q)=
BEGIN
	EXTERNAL OPTERR;
	MAP PHAZ2 Q;
	!X IS THE SUCCESSOR FO Q
	T_.Q[SUCPTR];
	FGRAPH[.FGP]<SUCLNK>_.T;
	Q[SUCPTR]_FGRAPH[.FGP];
	FGRAPH[.FGP]<SUCC>_.X;
	FGP_.FGP+1;
	IF .FGP GTR POOLSIZ/2 THEN OPTERR(1);
END;
!FOR EACH LABEL THAT IS ENCOUNTERED AS A BRANCH THE
!ROUTINE LOKEXIT IS CALLED.  THIS ROUTINE EXAMINES THE LLL (LOCAL
!LABEL LIST) AND EXITLST (EXIT LABEL LIST), ETC. TO
!DETERMINE THE NATURE OF THE BRANCH.  THE ROUTINE RETURNS
!	0	LOCAL LABEL, BRANCH WITHIN GRAPH OF CURRENT DO
!	1	EXIT, BOTTOM IS THE DESTINATION
!	2	IT IS A JUMP BACK TO A LABEL IN A NESTED DO
!			PREVIOUSLY PROCESSED AND WILL BE CONSIDERED
!			AS AN EXTENDED RANGE .PA[SNEXTND] IS THE DESTINATION
MACRO LNKBOT=
	BEGIN
		IF .P NEQ .LEND THEN
		BEGIN
			LNKFWD(.LEND,.P);
			LNKREV(.P,.LEND);
		END;
	END$;
!
!NOTE: SXENTND POINTS TO THE DO DEPH ANALYSIS TREE SO WE NEED AN INDEIRECT
MACRO LNKEXTND = 
	BEGIN
		PA_.PA[SNEXTND];
		LNKFWD(.PA[DOSRC],.P);
		LNKREV(.P,.PA[DOSRC]);
	END$;
MACRO IOBRANCH=
BEGIN
	IF .P[IOERR] NEQ 0 THEN
		BEGIN
		PA_.P[IOERR];
		HOOKUP(.PA);
	END;
	IF .P[IOEND] NEQ 0 THEN
	BEGIN
		PA_.P[IOEND];
		HOOKUP(.PA);
	END
END;$;

!***************************************
!
ROUTINE HOOKUP(PA)=
!TO SHORTEN CODE THIS ROUTINE WAS CREATED TO CALL LOKEXIT TO
!DETERMINE THE NATURE OF A BRANCH AND LINK IT INTO THE GRAPH
!CORRECTLY
BEGIN

MAP BASE PA;

	CASE LOKEXIT(.PA) OF SET
	BEGIN
		LNKREV(.P,.PA[SNHDR]);
		LNKFWD(.PA[SNHDR],.P);
	END;
	LNKBOT;
	LNKEXTND
	TES;

END;

ROUTINE ABSGOCHK=
BEGIN
	!UNDER NO CIRCUMSTANCES CAN THE GRAPH BE DISCONNECTED
	!THIS MEANS THAT STATEMENTS THAT FOLLOW AN ABSOLUTE
	!BRANCH THAT ARE UNLABELED MUST BE ELIMINATED. WE
	!MUST BE CAREFUL WITH THE STOP END AND RETURN END
	!COMBINATIONS, HOWEVER, SINCE WE MUST NOT ELIMINATE THE
	!END STATEMENT.
	!MODULE OWN P POINTS TO THE ABSOLUTE BRANCH STATEMENT.

	LOCAL BASE LABLE;


	IF .P[SRCLINK] EQL 0 THEN RETURN;
	PC_.P[SRCLINK];
	IF .PC[SRCLBL] EQL 0 THEN
	BEGIN
		IF .PC[SRCID] EQL ENDID THEN RETURN;

		!NOW CHECK FOR STOP END/ RETURN END
		IF .P[SRCID] EQL STOPID AND .PC[SRCID] EQL ENDID THEN
			RETURN;

		IF .P[SRCID] EQL RETUID AND .PC[SRCID] EQL ENDID THEN
			RETURN;

		IF .PC[SRCID] EQL ENTRID THEN RETURN;

		!OTHERWISE, THROW IT OUT

		DO
		BEGIN
			!IF WE ARE REMOVING A DO MARK IT AS GONE
			IF .PC[SRCID] EQL DOID THEN
			BEGIN
			REGISTER BASE T;
				PC[DOREMOVED]_1;
				!IF THE DO ENDS AT  LABEL
				!THAT HAS ONLY THIS DO AT IT
				!WE WILL DELETE THE WHOLE LOOP
				T_.PC[DOLBL];
				IF .T[SNDOLVL] EQL 1 THEN
				DO
					PC_.PC[SRCLINK]
				UNTIL .PC[SRCLBL] EQL .T;
			END;
			PC_.PC[SRCLINK];
			!WE ALSO WANT TO GET RID OF
			!LABELED STATEMENTS THAT ARE NEVER REFERENCED
			IF .PC[SRCLBL] NEQ 0 THEN
			BEGIN
				LOCAL BASE LABLE;
				LABLE_.PC[SRCLBL];
				IF .LABLE[SNREFNO] EQL 1 THEN
				!ONLY REFERENCE WAS LABLE ITSELF
					PC[SRCLBL]_0;
			END;
		END UNTIL .PC[SRCLBL] NEQ 0 OR .PC[SRCID] EQL ENDID;

		!FILL IT INTO P

		P[SRCLINK]_.PC;
	END;
END;

ROUTINE GRAPH=
BEGIN
	!BUILD THE PROGRAM GRAPH FOR EACH INDIVIDUAL STATEMENT.
	!P POINTS TO THE CURRENT STATEMENT. PREV POINTS TO THE
	!PREVIOUS STATEMENT OR IS ZERO IF THE PREVIOUS STATEMENT 
	!WAS AN ABSOLUTE BRANCH.

	MACRO INFLOOP=
		IF .PA EQL .P[SRCLBL] THEN OPTERR(6)$;

	EXTERNAL ENTRY,OPTERR,LOOP,LEND;

	IF .PREV NEQ 0 THEN
	BEGIN
		!MAKE THE ABSOLUTE TRANSFER FOLLOWER CATCH UP
		!BY SETTING TO0 TO INDICATE
		!THAT THERE IS REALLY MORE HERE.
		TLEND_0;
		LNKREV(.PREV,.P); LNKFWD(.P,.PREV);
	END ELSE
	BEGIN
		!WE WANT TO ELIMINATE UNREACHABLE STATEMENTS
		!LIKE A COLLECTION OF FORMAT STATEMENTS AFTER THE
		!CODE BEFORE THE END STATEMENT.
		!REMEMBER TO GET HERE PREV WAS 0 INDICATING THAT
		!THE PREVIOUS STATEMENT WAS A BRANCH.

		IF .P[SRCLBL] NEQ 0 THEN	!THE STATEMENT IS LABELED
		BEGIN
			IF .P[SRCID] EQL FORMID THEN
			BEGIN
				RETURN;
				!BY RETURNING WE WILL EFFECTIVELY IGNORE THIS STMT.
			END;
		END;
	END;

SELECT .P[SRCID] OF NSET
GOTOID:BEGIN				!UNCONDITIONAL GO TO
	PA_.P[GOTOLBL];
	INFLOOP;
	HOOKUP(.PA);
	PREV_0;
	IF .P[SRCLINK] NEQ 0 THEN TLEND_.P;
	ABSGOCHK();
END;
CGOID:	BEGIN				!COMPUTED GO TO
	!A COMPUTED GOTO IS NOT AN ABSOLUTE BRANCH, SINCE IF THE
	!INDEX IS OUT OF RANGE CONTROL IS TRANSFERRED TO THE NEXT
	!STATEMENT.
	DECR I FROM .P[GOTONUM]-1 TO 0 DO
	BEGIN
		PA_@(.P[GOTOLIST]+.I);		!PA BOUND TO BASE
		INFLOOP;
		HOOKUP(.PA);
	END;
	PREV_.P;
	END;				!COMPUTED GO TO
AGOID:	BEGIN				!ASSIGNED GO TO
		ENTRY_.P[SRCISN];
		IF .P[GOTOLIST] EQL 0 THEN	!OPTIONAL LIST IS NOT PRESENT
		BEGIN				!YOU LOSE
						!PICK UP LIST THAT IS
			ASSLOOKER(.P[AGOTOLBL]);!LINKED OFF
						!ASIPTR. THROUGH ALL
						!ASSIGN STATEMENTS
						!BY PHASE 1.
			!INTERPRETATION OF **THE STANDARD**
			!IF WE HAVE HAD TO BUILD THE LIST, WE
			!WILL (BY DEFINITION) GO TO A LABEL ON
			!THE LIST. THAT MAKES THIS AN ABSOLUTE
			!BRANCH AND IT WILL BE TREATED A SUCH

			IF .P[GOTONUM] EQL 0 THEN
				(P[GOTOLIST]_0; OPTERR(2));
			PREV_0;
			IF .P[SRCLINK] NEQ 0 THEN TLEND_.P;
			ABSGOCHK();
		END;
						!OPTIONAL LIST IN NODE
						!HURRAY!
		DECR I FROM .P[GOTONUM]-1 TO 0 DO
		BEGIN
			PA_@(.P[GOTOLIST]+.I);	!SAME AS COMPUTED GO TO
			INFLOOP;
			HOOKUP(.PA);
			!THIS IS NOT AN ABSOLUTE BRANCH
			PREV_.P;
		END;
	END;			!ASSIGNED GO TO
IFLID:	BEGIN				!LOGICAL IF
					!ONLY TRICKY CASE
	!FIRST ET THE OPTIMIZERS CORE FOR THE STATEMENT
	PC_.P;		!SAVE P
	P_.P[LIFSTATE];
	NAME<LEFT>_5;
	P[SRCOPT]_CORMAN();
	P[SUCPTR]_FGRAPH[0];
	P[PREDPTR]_RGRAPH[0];
	P_.PC;		!RESTORE P

	!THE IF STATEMENT BECOMES THE PREDECOESSOR OF LIFSTATE
		
		LNKREV(.P,.P[LIFSTATE]);
!
	!LIFSTATE BECOMES THE SUCCESSOR OF THE IF STATEMENT

		LNKFWD(.P[LIFSTATE],.P);

	!NOW THE TRICKY PART
	!	THE SUCCESSOR OF LIFSTATE
	!	**NOTE IT IS NOT THE NEXT STATEMENT IF LIFSTATE IS A BRANCH
	!
		PREV_0;
		PC_.P;		!SAVE P
		P_.P[LIFSTATE];	!TRICK GRAPH
		GRAPH();
		!

		!IF PREV IS NOT ZERO NOW IT WAS NOT A BRANCH STATEMENT
		!
		P_.PC;		!RESTORE P
		IF .PREV NEQ 0 THEN
		BEGIN
			!
			!LIFSTATE IS A PREDECESSOR OF THE NEXT STATEMENT
				LNKREV(.P[LIFSTATE],.P[SRCLINK]);
			!
			!THE NEXT STATEMENT IS A SUCCESSOR OF LIFSTATE
			!
				LNKFWD(.P[SRCLINK],.P[LIFSTATE]);
		END ELSE P[TRUEISBR]_1;

		!
	PREV_.P;
	END;
IFAID:	BEGIN				!ARITHMETIC IF
	PA_.P[AIFLESS];
	INFLOOP;
	HOOKUP(.PA);
	PA_.P[AIFEQL];
	INFLOOP;
	HOOKUP(.PA);
	PA_.P[AIFGTR];
	INFLOOP;
	HOOKUP(.PA);
	PREV_0; TLEND_.P;
	ABSGOCHK();
	END;				!ARITHMETIC IF
WRITID:	BEGIN
		IOBRAHCH;
		PREV_.P;
		END;
READID:		BEGIN
		IOBRANCH;
		PREV_.P;
		END;
CALLID:	BEGIN			!CALL STATEMENT
	!NEED TO CHECK FOR LABELS AS PARAMETERS AND ASSIGN-ED VARIABLES
	!
	IF .P[CALLIST] NEQ 0 THEN
	BEGIN
		LOCAL ARGUMENTLIST AG;
		AG_.P[CALLIST];
		INCR I FROM 1 TO .AG[ARGCOUNT] DO
		BEGIN
			PA_.AG[.I,ARGNPTR];
			IF .PA[OPRCLS] EQL LABOP THEN
			BEGIN	!LABEL AS PARAMETER
				HOOKUP(.PA);
				P[LABLARGS]_1;
			END ELSE	!CHECK FOR ASSIGN-ED VARIABLE
			BEGIN
				!CHECK TO SEE IF IT IS A VARIALE THAT
				!APPEARED IN AN ASSIGN STATEMENT
				!IF SO LOOK IT UP
				IF .PA[OPR1] EQL VARFL THEN
					IF .PA[IDATTRIBUT(INASSI)] THEN
						ASSLOOKER(.PA);
			END;
		END;		!INCR LOOP ON PARAMETERS
	END;			!PARAMETERS AT ALL
	PREV_.P;
	END;			!CALL STATEMENT
DOID:	BEGIN		!DO STATEMENT
	!NOTE THAT THIS IS AN INNER DO (ALREADY PROCESSED
	!WE ADJUST PREV AND P TO START THE GRAPHING PROCESS
	!UP AGAIN AT THE STATEMENT AFTER THE DO.
	!THERE IS ONE OTHER THING TO DO:
	!1. IF A PREVIOUS LOOP HAD A BRANCH OUT TO  A LABEL
	!   WE MUST SEE IF THE LABEL IS DEFINED HEREIN (IN THE
	!   CURRENT LOOP AND LINK THEM UP.

	!1 FIRST. IF THERE ARE OPTIMIZERS WORDS TO GO WITH THIS LOOP

	IF .P[SRCOPT] NEQ 0 THEN
	BEGIN
		!IF THERE WERE EXITS FROM THIS LOOP THEY
		!ARE IN A LINKED LIST FROM EXTLST
		IF .P[EXTLST] NEQ 0 THEN
		BEGIN
			!EXAMINE THE LABELS ON THE LINKED LIST
			!AND SEE IF THEY ARE IN LLL (LOCAL LABEL
			!LIST.

			PC_.P[EXTLST];
			WHILE .PC NEQ 0 DO
			BEGIN
				PA_.PC[LEFTP];
				HOOKUP(.PA);
				!LOOK AT NEXT ITEM OM LINKED LIST
				PC_.PC[RIGHTP];
			END;
		END;	!EXTLST IS ZERO
	END;


		P_.P[DOLBL];		!TERMINATION LABEL
		!TO KEEP LABEL USEAGES STRAIGHT WE SHOULD
		!INCREMENT THE LOCAL LABEL COUNT FOR THE DO LABEL
		!THIS IS MOST EASILY DONE BY CALLING LOKEXIT.
		LOKEXIT(.P);
		P_.P[SNHDR];		!TERMINATION STATEMENT
		PREV_.P;
	END;
RETUID:	BEGIN		!RETURN STATEMENT
		LNKBOT;
		PREV_0; TLEND_.P;
		ABSGOCHK();
	END;
STOPID:	BEGIN		!STOP STATEMENT
		LNKBOT;
		PREV_0;TLEND_.P;
		ABSGOCHK();
	END;
ENTRID:	BEGIN		!ENTRY, SUBROUTINE OR FUNCTION STATEMENT
	!THIS SHOULD BE AN ENTRY, WE ARE IN THE "MAIN" PROGRAM
		LNKFWD(.P,.TOP);
		LNKREV(.TOP,.P);
		PREV_.P;
	END;
OTHERWISE:	PREV_.P;
TESN;				!END OF SELECT
!THIS ALL DOES NOT CATCH BRANCHES BACK OR CONNECT WITH
!INNER (MORE INNER, NOT NECESSARILY INNERMOST) LOOPS.
!TO DO THIS WE MUST LOOK AT THE LABEL OF THE STATEMENT, IF ANY,
!AND SEE IF THERE WAS A REFERENCE PREVIOUSLY MADE FROM THE
!*INSIDE*. SNEXTND IS A LABEL TABLE FIELD WHICH  IS SET TO LOO
!IN MAKLLL AND UPDATED IN DOCOLLAPSE SO THAT IT POINTS TO
!THE OUTERMOST LOOP OF ANY NEST WHUCH CONTAINS THE LABEL IN QUESTION.

	IF .P[SRCLBL] NEQ 0 THEN
	BEGIN
		PA_.P[SRCLBL];
		IF .PA[SNEXTND] NEQ 0 AND 
		   .PA[SNEXTND] NEQ .LOOP AND
		   .PA[SNREFNO] NEQ 1 THEN
				LNKEXTND;
	END;
END;

FORWARD LOKENTRANCE,MAKLLL;

GLOBAL ROUTINE GPHBLD =
BEGIN
!BUILD THE FORWARD AND REVERSE GRAPHS FOR THE PROGRAM
!TOP IS FIRST STATEMENT 
!BOTTOM IS LAST STATEMENT
!
	EXTERNAL ISN,MOVLAB,LOOP;
	EXTERNAL LEND,LOCELMIO,P2SKSTMNT,BACKST,SAVSPACE,CSTMNT;
	MAP BASE TOP:T:CSTMNT:TLEND:LEND;

!MACRO DEFINING BIT TO SET FOR P2S DONE ON THIS STATEMENT

P_.TOP;
!PRIME THE EXIT LIST
!FIRST ZERO IT
INCR I FROM 0 TO 19 DO
EXITLST[.I]_0;

EXITLST[0]_.TOP[DOLBL];
EXITNO_0;

!FIRST CHECK FOR THE DO TERMINATIZN BEING A LOGICAL IF.
!IF IT IS, MAKE A CONTINUE AND MOVE ALL DOS THAT TERMINATE ON THE
!LOGICAL IF TO THE CONTINUE. SINCE WE PROCESS FROM INSIDE OUT,
!THIS WILL ONLY BE DONE ON THE INNERMOST OF ANY NEST OF DOS THAT END
!ON A LOGICAL IF.

IF .LEND[SRCID] EQL IFLID THEN
BEGIN
	!MAKE THE CONTINUE
	NAME<LEFT>_SRCSIZ;
	P_CORMAN();
	!SET FIELDS IN STATEMENT
	P[OPRCLS]_STATEMENT;
	P[SRCID]_CONTID;
	!LINK IT INTO THE ENCODED SOURCE TREE
	P[SRCLINK]_.LEND[SRCLINK];
	LEND[SRCLINK]_.P;
	!CALL THE EXTERNAL ROUITNE TO DO THE LABEL MOVING HASSLE
	MOVLAB(.LEND[SRCLBL],		!LABEL TABLE POINTER TO 
					!GET LOOP ENDING INFO
		.P,			!STATEMENT TO MAKE NEW ENDING
		.TOP);			!STARTING WITH THIS LOOP
	!NOW ADJUST LEND TO BE THIS NEW STATEMENT
	LEND_.P;
END;

P_.TOP;
!GET OPTIMIZERS SPECIAL 5 WORDS PER STATEMENT FOR EACH STATEMENT
	!GET OPTIMIZERS WORDS FOR THIS STATEMENT (THE DO)
	CSTMNT_.P;
	ISN_.CSTMNT[SRCISN];
	IF NOT .P[P2SDONE] THEN
	P2SKSTMNT();
	P[P2SDONE]_1;
	NAME<LEFT>_5;
	P[SRCOPT]_CORMAN();
	P[SUCPTR]_FGRAPH[0];
	P[PREDPTR]_RGRAPH[0];
	P_.P[SRCLINK];
	!NO NEED TO RETRY THE ONE WE JUST DID

	!NOW GET THEM FOR THE STATEMENT IN THE LOOP
	WHILE .P NEQ .BOTTOM DO
	BEGIN
		IF .P[SRCID] NEQ DOID AND .P[SRCOPT] EQL 0 THEN
		BEGIN
			CSTMNT_.P;
			IF NOT .P[P2SDONE] THEN
			P2SKSTMNT();
			P[P2SDONE]_1;
			NAME<LEFT>_5;
			P[SRCOPT]_CORMAN();
			P[SUCPTR]_FGRAPH[0];
			P[PREDPTR]_RGRAPH[0];
		END ELSE
		IF .P[SRCID] EQL DOID THEN
		BEGIN
			T_.P[DOLBL];
			P_PREV_.T[SNHDR];
			!P WILL BE ADJUSTED IN THE STATEMNT AFTER THE NEXT END
		END;
		P_.P[SRCLINK];
	END;
	MAKLLL();		!COLLECT LOCAL LABLES

!IF THIS IS REALLY A LOOP (I.E. NOT THE MAIN PROGRAM) THEN
!MAKE LEND A PREDECESSOR OF TOP.
!THIS IS TO HANDLE THE CASE ILLUSTRATED BY THE EXAMPLE:
!	DO 10 -------
!	  = A
!	.
!	.
!	.
!	A =
! 10

!IF IT WERE NOT DONE THE DEFINITION POINT OF A AT ITS USE WOULD
!INDICATE THAT A WAS A REGION CONSTANT

	IF .LOOP NEQ 0 THEN LNKREV(.LEND,.TOP);


!START THE GRAPH WITH THE STATEMENT AFTER THE DO LOOP
	CSTMNT_
PREV_.TOP;
TLEND_0;

P_.TOP[SRCLINK];
EXITNO_0;		!INITIALIZE EXITNO
DO
BEGIN
	CSTMNT_.P;
	ISN_.CSTMNT[SRCISN];
	GRAPH();
	P_.P[SRCLINK];
END UNTIL .P EQL .BOTTOM;
!IF THIS ISNT A MAIN PROGRAM AN THERE WERE LOOP EXITS
!GO FIND THE ENTRANCES
IF .LOOP NEQ 0 AND .EXITNO NEQ 0 THEN
LOKENTRANCE();		!COLLECT LOOP ENTRANCES

!NOW CHECK OUR LITTLE ABSOLUTE FOLLOWER TO INSURE THAT
!THE NODE THAT IS DESIGNATED AS LEND IS CONNECTED TO THE REST OF THE GRAPH
!FIRST GET RID OF ANY FORMAT STATEMENTS BETWEEN BETWEEN TLEND AND LEND
	IF .TLEND NEQ 0 THEN
	BEGIN
		IF .TLEND[SRCLINK] NEQ 0 THEN
		BEGIN
			P_.TLEND[SRCLINK];
			WHILE .P[SRCID] EQL FORMID DO
				P_.P[SRCLINK];
			!NOW IF P IS LEND LINK TLEND TO LEND AND QUIT
			IF .P EQL .LEND THEN
			BEGIN
				LNKREV(.TLEND,.LEND);
				LNKFWD(.LEND,.TLEND);
				RETURN;
			END;
		END;
	END;


	IF .TLEND NEQ 0 AND .LOOP EQL 0 THEN
		IF .TLEND[SRCLINK] NEQ .LEND
		 AND .TLEND[SRCLBL] EQL 0
		 AND (.TLEND[SRCID] NEQ RETUID
		 AND .TLEND[SRCID] NEQ ENDID)  THEN
			LEND_.TLEND
		ELSE
			IF (.TLEND[SRCID]  EQL GOTOID OR .TLEND[SRCID] EQL STOPID)
			 AND
			.TLEND[SRCLINK] EQL .LEND THEN
				!BELIEVE IT OR NOT, WE HAVE TO
				!KEEP FROM DISCONNECTING BY
				!INSURING THAT LEND IS LINKED IN.
				!MOVING LEND UP ONE TO TLEND WILL
				!BE WRONG IF THERE ARE EXITS WHICH HAVE
				!BEEN LINKED TO LEND PREVIOUSLY.
				BEGIN
					LNKREV(.TLEND,.LEND);
					LNKFWD(.LEND,.TLEND);
				END

				!YET ANOTHER SPECIAL SITUATION. 
				!	GO TO 2
				!4	STOP
				!	FORMAT
				!	.
				!	END
				!WILL BE DISCONNECTED WITHOUT THIS ADDITIONAL
				!PRECAUTION
				ELSE
				BEGIN
					IF .TLEND[SRCID] EQL STOPID AND .TLEND[SRCLBL] NEQ 0 THEN
					BEGIN
						P_.TLEND[SRCLINK];
						WHILE .P[SRCID] EQL FORMID DO
							P_.P[SRCLINK];
						!NOW IF P IS LEND HOOK UP LEND TO TLEND
						IF .P EQL .LEND THEN
						BEGIN
							LNKREV(.TLEND,.LEND);
							LNKFWD(.LEND,.TLEND);
						END;
					END;
				END;
END;				!GRAPHBUILDER ROUTINE

!*****
!OBSCENITY IS IN THE EYE OF THE BEHOLDER
!*****
!IT STANDS FOR ASSIGN LOOKER

ROUTINE ASSLOOKER(VAR)=

BEGIN
	EXTERNAL OPTERR;
	!LOOK AT LINKED LIST OF ASSIGN STATEMENTS
	!VAR IS SYMBOL TABLE POINTER FOR ASSIGNED VARIABLE
	!P IS STATEMENT POINTER
	!FOR EACH MATCH ENCOUNTERER
	!P IS PREDECESSOR OF *LABELED* STATEMENT
	! *LABELED* STATEMENT IS PREDECESSOR OF STMT
	MAP BASE PB;
	NAME<LEFT>_10;
	PB_.ASIPTR<LEFT>;				!PICK UP GLOBAL POINTER
	P[GOTOLIST]_CORMAN();				!GET 10 WORDS FOR LIST
	P[GOTONUM]_0;
	WHILE .PB NEQ 0 DO
	BEGIN
		IF .VAR EQL .PB[ASISYM] THEN

		BEGIN
			!BUILD OPTIONAL LIST PROGRAMMER DID NOT PROVIDE
			(.P[GOTOLIST]+.P[GOTONUM])<RIGHT>_.PB[ASILBL];
								!PUT LABEL IN LIST
			P[GOTONUM]_.P[GOTONUM]+1;	!UP COUNT
			ENTRY_.P[SRCISN];		!FOR ERROR MESSAGE
			IF .P[GOTONUM] GTR 10 THEN (OPTERR(2); RETURN);
		END ELSE
		!SPECIAL *TRY HARDER* FOR ARRAY REFERENCES
		BEGIN
			LOCAL BASE EXPR;
			MAP BASE VAR;
			IF .VAR[OPRCLS] EQL ARRAYREF THEN
			BEGIN
				EXPR_.PB[ASISYM];
				IF .EXPR[OPRCLS] EQL ARRAYREF THEN
				IF .VAR[ARG1PTR] EQL .EXPR[ARG1PTR] THEN
					!USE THIS ONE
				BEGIN
			!BUILD OPTIONAL LIST PROGRAMMER DID NOT PROVIDE
			(.P[GOTOLIST]+.P[GOTONUM])<RIGHT>_.PB[ASILBL];
								!PUT LABEL IN LIST
			P[GOTONUM]_.P[GOTONUM]+1;	!UP COUNT
			ENTRY_.P[SRCISN];		!FOR ERROR MESSAGE
			IF .P[GOTONUM] GTR 10 THEN (OPTERR(2); RETURN);
				END;
			END;
		END;
		PB_.PB[ASILINK];
	END;
END;

GLOBAL ROUTINE DOCOLLAPSE=
BEGIN
	EXTERNAL VERYFRST;
	EXTERNAL LABTBL,SAVSPACE,RGPHBAS,FGPHBAS,OPTERR;
	MAP BASE T;
	!CREATE A COLLAPSED DO NODE
	!   SUCCESSOR OF DO (IN GRAPH) IS
	!      STATEMENT FOLLOWING TERMINATION
	!      PLUS ALL OTHER EXITS

	MAP PHAZ2 TOP:PB:BOTTOM;

	VERYFRST_0;

	TOP[PREDPTR]_RGRAPH[0];	!REINITIALIZE GRAPH POINTERS. PREDPTR WILL BE
	TOP[SUCPTR]_FGRAPH[0];	!   FILLED BY GPHBLD FOR OUTER LOOP
	TOP[LEVEL]_0;		!INITIALIZE OTHER FIELDS
	TOP[BUSY]_0;
	TOP[PREDOM]_0;
	TOP[POSTDOM]_0;
	TOP[ACC]_0;

	!MAKE A NEW BOTTOM.
	!IT WILL BE LEND FOR THE PURPOSES OF COLLAPSING THE DO TO
	!A SINGLE NODE

	BOTTOM_.LEND;

	!STEP THRU EXITLST BUILDING GRAPH
	FGP_.FGPHBAS; RGP_.RGPHBAS;
	!FIRST GET OPTIMIZERS WORDS FOR BOTTOM IF THEY ARENT ALREADY THERER
	IF .BOTTOM[SRCOPT] EQL 0 THEN
	BEGIN
		NAME<LEFT>_5;
		BOTTOM[SRCOPT]_CORMAN();
	END;
	!AT ANY REATE REINITIALIZE THE GRAPHING FOR IT
	BOTTOM[SUCPTR]_FGRAPH[0];
	BOTTOM[PREDPTR]_RGRAPH[0];
	!ZERO OTHER FIELDS
	BOTTOM[BUSY]_BOTTOM[LEVEL]_BOTTODOM]_BOTTOM[POSTDOM]_0;
	BOTTOM[ACC]_0;

	!HOOK TOP TO BOTTOM
	LNKREV(.TOP,.BOTTOM);
	LNKFWD(.BOTTOM,.TOP);

	RGPHBAS_.RGP; FGPHBAS_.FGP;
	IF .RGP GTR (POOLSIZ/2-20) THEN OPTERR(1);


	!MAKE A LINKED LIST OF THE EXITS (OTHER THAN FULLMENT) FROM
	!THIS LOOP. THE LIST HAS THE LINK IN THE RIGHT HALF OF THE 
	!WORD AND A POINTER TO THE LABEL TABLE ENTRY FOR THE EXIT
	!IN THE LEFT HALF.

	IF .EXITNO NEQ 0 THEN
	BEGIN
		NAME<LEFT>_.EXITNO;
		PA_CORMAN();

		!PA POINTS TO CORE FOR LIST
		!SET FIELDS IN OPTIMIZERS WORDS
		TOP[EXTLST]_.PA;

		INCR I FROM 1 TO .EXITNO DO
		BEGIN
			!NOTE EXITLST IS A GLOBAL THAT WAS ZEROED IN
			!GPHBLD

			IF .PA NEQ .TOP[EXTLST] THEN
			!THIS IS NOT THE START
				(.PA-1)<RIGHT>_.PA;
			PA[LEFTP]_.EXITLST[.I];
			PA_.PA+1;
		END;
		!HEAD WILL POINT TO LAST OPEN LINK
		HEAD_.PA-1;
	END;


	!NOW GIVE BACK THE OPTIMIZERS WORDS FOR THE STATEMENTS IN THE
	!LOOP. NOT FOR TOP OR BOTTOM, HOWEVER.
	P_.TOP[SRCLINK];
	IF .P EQL .BOTTOM THEN RETURN;
	WHILE .P[SRCLINK] NEQ .BOTTOM DO
	BEGIN
		IF .P[SRCOPT] NEQ 0 THEN
		SAVSPACE(4,.P[SRCOPT]);
		P[SRCOPT]_0;
		!CHECK FOR LOGICAL IF AND GET LIFSTATE TOO
		IF .P[SRCID] EQL IFLID THEN
		BEGIN
			PC_.P[LIFSTATE];
			IF .PC[SRCOPT] NEQ 0 THEN
			SAVSPACE(4,.PC[SRCOPT]);
			PC[SRCOPT]_0;
		END;
		P_.P[SRCLINK];
	END;

END;

ROUTINE LOKENTRANCE=

BEGIN
	!AFTER GPHBLD WE CHECK OUT LLL TO SEE WHICH LABELS ARE
	!LOOP ENTRANCES.
	!THE STATEMENTS WHICH ARE ENTRANCES ARE PUT INTO THE
	!GRAPH WITH TOP AS PREDECESSOR AND AS SUCCESSORS OF TOP
	!TOP IN AFFECT WILL SERVE AS THE SUPER ENTRY

	!WE WILL ALSO CHECK TO SEE IF THE LOOP HAS NO EXITS AND SO THE
	!CONTROL WORD AND INDUCTION VARIABLES MAY NOT NEED MATERIALIZATION

	LOCAL T1;

	IF .EXITNO EQL 0 THEN TOP[NEDSMATRLZ]_0;

	DECR I FROM .LLLNO-1 TO 0 DO
	BEGIN
		PA_.LLL[.I]<RIGHT>;
		T1_.PA[SNREFNO];
		!THE TOTAL NUMBER OF REFERENCES TO THIS LABEL
		!SUBTRACT THE NUMBER OF DO LOOPS THAT END HERE
		!(THEY ARE NOT ENTRANCES), AND ADD 1 FOR THIS
		!DO LOOP
		IF .PA EQL .TOP[DOLBL] THEN
			T1_.T1-.PA[SNDOLVL]+1;

		IF .LLL[.I]<LEFT> NEQ .T1 THEN
		BEGIN
						!THIS IS AN ENTRANCE
			PB_.PA[SNHDR];
			!DONT INCLUDE STATEMENTS THAT WILL MAKE
			!BLOW-UPS OR FORMATS
			IF .PB[SRCOPT] NEQ 0 AND .PB[SRCID] NEQ FORMID THEN
			LNKREV(.TOP,.PB);
		END;
	END;
END;
ROUTINE LOKEXIT (LABLE)=
BEGIN
	EXTERNAL OPTERR,LOOP;
	!SEARCH LLL FOR LABEL
	!IF NOT THERE IT IS A LOOP EXIT
	!ADD TO LOOP EXIT LIST
	!LABEL IS DELIBERATELY MISSPESSED

	MAP PHAZ2 BOTTOM;

	MAP PEXPRNODE LABLE;

!	IF THERE ARE NO LABELS OTHER THAN THE TERMINATING LABEL
!	THIS IS LLL[0] AND WILL BE COUGHT IN THE DECR LOOP
	DECR I FROM .LLLNO-1 TO 0  DO

	IF .LLL[.I]<RIGHT> EQL .LABLE THEN (LLL[.I]<LEFT>_.LLL[.I]<LEFT>+1; RETURN 0);

	!IF HERE LABEL WAS NOT ON LIST FOR CURRENT
	!LOOK AT SNEXTND FIELD

	IF .LABLE[SNEXTND] NEQ 0 AND
	 .LABLE[SNEXTND] NEQ .LOOP THEN
			RETURN 2;


	DECR I FROM .EXITNO TO 0 DO
		IF .EXITLST[.I] EQL .LABLE THEN RETURN 1;
	EXITNO_.EXITNO+1;
	!MAKE SURE WE ARE NOT OVERFLOWING AND QUIT IF WE ARE
	IF .EXITNO GEQ EXITSIZ THEN OPTERR(1);
	EXITLST[.EXITNO]_.LABLE;

	RETURN 1;
END;
ROUTINE MAKLLL=
BEGIN
	EXTERNAL OPTERR;
	LABEL ADDLOC;
	!LLL IS LOOP LABEL LIST.
	!IT IS THE LIST OF LABELS THAT APPEAR IN THE LOOP
	!(I.E. ON STATEMENT IN THE LOOP)
	!LLLNO CONTAINS THE NUMBER OF LOCAL LABELS COUNTING FROM 1.
	!LLL[0] IS ALWAYS THE NOTMAL LOOP EXIT

	LLLNO_1;
	LLL[0]_2^18+.TOP[DOLBL];		!COUNT AND POINTER
	!THE COUNT IS 2:
		!ONE FOR THE REFERENCE IN THE DO STATEMENT
		!ONE FOR THE LABEL DEFINITION ITSELF
	PA_.TOP[DOLBL];
	PA[SNEXTND]_.LOOP;

	!SNEXTND POINTS BACK TO THE DO DEPTH ANALYSIS FROM WHICH WE CAN
	!ALWAYS GET TO THE DO STATEMENT ITSELF

	P_.TOP[CLINK];
	DO
	BEGIN
		ADDLOC:
		IF .P[SRCLBL] NEQ 0 AND .P[SRCLBL] NEQ .TOP[DOLBL] THEN
		BEGIN
			PA_.P[SRCLBL];
			!CHECK TO SEE IF THE LABEL IS DEFINED BUT
			!NEVER REFERENCED. IN THIS CASE THE SNREFNO
			!WILL BE ONE. DO NOT COUNT IT IF THIS
			!IS THE CASE. IN THEORY THIS SHOULD TAKE CARE OF
			!THE FORMAT LABEL  THAT IS USED ONLY AS A FORMAT.
			!REFERENCES TO FORMAT LABELS IN I/O STATEMENTS IS
			!NOT INCLUDED IN SNREFNO.
			IF .PA[SNREFNO] EQL 1 THEN LEAVE ADDLOC;
			!CHECK FOR OVERFLOW OF LIST AND QUIT IF FOUND
			IF .LLLNO GEQ LLLSIZ THEN OPTERR(1);
			LLL[.LLLNO]_1^18+.P[SRCLBL];
			LLLNO_.LLLNO+1;
			!SET SNEXTND FIELD OF THE LABEL TABLE ENTRY
			PA[SNEXTND]_.LOOP;

		END;
		!IF THIS IS A DO LOOP WE WANT TO SKIP THE LABELS
		!THAT ARE DEFINED WITHIN IT. BUT WE WANT TO
		!UPDATE THE SNEXTND FIELD OF THE LABEL TABLE ENTRIES
		!FOR THEM TO POINT TO THE OUTER-MORE LOOP WE ARE
		!NOW PROCESSING. ALSO BE CAREFUL THAT THIS IS NOT
		!THE MAIN PROGRAM.

		IF .P[SRCID] EQL DOID THEN
		BEGIN
			PB_.P[DOLBL];
			!UNTIL WE ARE OUT OF THIS INNER MORE LOOP
			WHILE .P[SRCLBL] NEQ .PB DO
			BEGIN
				!IF THE STATEMENT IS LABELED AND THE
				!LABEL IS NOT ALSO THE TERMINATING LABEL
				!OF THE CURRENT LOOP BEING PROCESSED
				!(TOP).
				!DONT UPDATE SNEXTND TO 0 (THE VALUE
				!OF LOOP) IF THIS IS THE MAIN PROGRAM
				IF .LOOP NEQ 0 THEN
				BEGIN
					IF .P[SRCLBL] NEQ 0 AND
					.P[SRCLBL] NEQ .TOP[DOLBL] THEN
					BEGIN
						!GET THE LABEL TABLE POINTER
						PA_.P[SRCLBL];
						PA[SNEXTND]_.LOOP;
					END;
				END;
				!LOOK AT NEXT ENTRY
				P_.P[SRCLINK];
			END;
		END;
		!IF WE JUST WENT THROUGH A DO LOOP THERE ARE TWO
		!POSSIBLE VALUES OF P AT THIS POINT:
		!1. IT POINTS TO THE TERMINATING STATEMENT OF A
		!   PROPERLY NESTED LOOP AND THE NEXT UPDATE OF P
		!   WILL POINT TO THE NEXT STATEMENT OF INTEREST IN
		!   PROCESSING THIS LOOP.
		!2. IT POINT TO THE TERMINATING LABEL OF AN INNER MORE
		!   DO WHICH IS ALSO THE TERMINATING LABEL OF
		!   THE CURRENT LOOP (TOP). THE NEXT UPDATE WILL
		!   POINT TO BOTTOM AND THE PROCESS TERMINATE
		P_.P[CLINK]
	END UNTIL .P EQL .BOTTOM;
END;
FORWARD DOMINATE,REFLOOD,PDOMINATE;
ROUTINE MOORE=
BEGIN
!DO FORWARD MOORE FLOOD
!HEAD  POINTS TO TOP OF GRAPH
!INITIALIZE ITS LEVEL TO 1.
!FOLLOW THE SUCCESORE CHAIN (P1 IS FOLLOWING CHAIN, P2 IS POINTING
!	AT ACTUAL SUCCESSOR STATEMENT NODE).
!INITIALIZE THE LEVEL NUMBER AND PREDOMINATORE FIELDS OF EACH SUCCESSOR.
!ALSO LINK THE NODES TOGETHER IN MOORE FLOOD ORDER (TAIL IS USED FOR THIS).
HEAD[LEVEL] _1;
DO
BEGIN
	P1_.HEAD[SUCPTR];
	WHILE .P1[CESLNK] NEQ 0 DO
	BEGIN
		P2_.P1[CESSOR];
		IF .P2[LEVEL] EQL 0 THEN
		BEGIN
			P2[LEVEL] _.HEAD[LEVEL] + 1;
			P2[PREDOM] _ .HEAD;
			TAIL[BUSY] _ .P2;
			TAIL_.P2;
		END;
		P1_.P1[CESLNK];
	END;
	HEAD_.HEAD[BUSY];
END UNTIL .HEAD EQL 0;
END;

!***********************************************
ROUTINE SANDBAG=
BEGIN
	!THE NAME IS IN KEEPING WITH THE FLOOD IDEA
	!THE ROUTINE REINITIALIZES THE LEVEL FIELDS OF THE
	!OPTIMIZERS WORDS TO TRY AGAIN ON EITHER A FORWARD OR REVERSE
	!MOORE FLOOD.
DO
BEGIN
	HEAD[LEVEL]_0;		!ZERO LEVEL FOR FLOOD ALGORITHM
	OLDHEAD_.HEAD[BUSY];
	!ALSO ZERO BUSY FIELD SO FORWARD BUSY LIST WILL TERMINATE
	HEAD[BUSY]_0;
	HEAD_.OLDHEAD;
END UNTIL .HEAD EQL 0;
END;

!*****************************************************

GLOBAL ROUTINE FLOOD =
BEGIN
	MAP PHAZ2 TOP;
	EXTERNAL OPTERR;
!ASSIGN MOORE FLOOD NUMBER AND SET UP BUSY LIST FOR 
!PREDOMINATOR ALGORITHM

!GET POSTDOMINATORS FIRST
REFLOOD();
PDOMINATE();
!ZERO BUSY LIST AND LEVEL FIELDS FROM POSTDOMINATOR ALGORITHM
HEAD_.OLDHEAD;
SANDBAG();
HEAD_.TOP;  TAIL _ .TOP;
HEAD[PREDOM]_.HEAD;
MOORE();

!WAIT ONE MINUTE. BEFORE PLUNGING AHEAD GIVE A CHECK
!ON THE CONNECTIVITY OF THE GRAPH. SOME PROGRAMS JUST
!ARE NOT CONNECTED AND WE SHOULD FIND OUT NOW RATHER THAN
!LATER
IF .TOP[POSTDOM] EQL 0 THEN
BEGIN
	!THIS IMPLIES THAT WE WERE UNABLE TO GET THE POSTDOMINATORS
	!ALL THE WAY TO THE FRONT OF THE BUS.
	!SO WE WILL TRY TO ELIMINATE STATEMENTS NOT REACHABLE
	!FROM THE ENTRY
	HEAD_.TOP;
	PREV_.TOP;
	!NOT REACHABLE MEANS IT DIDNT GET A LEVEL NUMBER IN THE FORWARD
	!MOORE FLOOD WE JUST DID
	WHILE .HEAD NEQ .LEND DO
	BEGIN
		IF .HEAD[LEVEL] EQL 0 THEN
			PREV[SRCLINK]_.HEAD[SRCLINK]
		ELSE
			PREV_.HEAD;
		HEAD_.HEAD[SRCLINK];
	END;		!WHILE LOOP
	LEND_.PREV[SRCLINK];
	HEAD_.TOP;
	!NOW TRY TO GET POSTDOMINATORS AGAIN
	SANDBAG();	!ZERO FIELDS
	REFLOOD();
	PDOMINATE();
	!IF WE STILL DIDNIT MAKE IT GIVE UP
	IF .TOP[POSTDOM] EQL 0 THEN OPTERR(5);

	!IF WE ARE NOT QUITTING THEN GET THOSE FORWARD FLOOD
	!NEMBERS BACK
	HEAD_.OLDHEAD;
	!FIRST REINITIALIZE THE FIELD
	SANDBAG();
	HEAD_TAIL_.TOP;
	MOORE();
END;
DOMINATE();
END;

!*********************************************

ROUTINE DOMINATE =
BEGIN

	EXTERNAL CSTMNT,ISN;
	MAP BASE CSTMNT;

!FIND PREDOMINATORS IN THE FORWARD GRAPH
!THE NOCHANGE GOVERNS THE ITERANTION. IT IS INIATIALLY TRUE
!AND BECOMES FALSE WHEN NO NODES WERE UPDATED ON AN ENTIRE PASS.
!THE SUCCESSORS OF HEAD ARE EXAMINED.
!P3 FOLLOWS THE SUCCESSOR LIST. PO POINTS TO THE ACTUAL SUCCESSOR.
!THE PREDOMINATOR OF EACH SUCCESSOR IS EXAMINED. THE LEVEL (MOORE FLOOD)
!IF THE SUCCESSOR IS COMPARED WITH THE LEVEL OF THE NODE (P1, INITIALLY
! HEAD) UNDER CONSIDERATION. THE PREDOMINATOR CHAINS ARE JUGGLED
!BACKWARD UNTIL THE LEVELS ABD EQUAL. THE PREDOMINATORE OF PO IS
!CHANGED IF APPROPRIATE.
LOCAL NOCHANGE;
HEAD_.TOP;
HEAD[PREDOM]_.TOP;		!STOPS IT AT TOP
DO
BEGIN
NOCHANGE _ 1;
DO
BEGIN
	!CSTMNT AND ISN FOLOW THE PROCESS FOR DEBUGGING PURPOSES.
	CSTMNT_.HEAD;
	ISN_.CSTMNT[SRCISN];
	P1_.HEAD;
	P3_.P1[SUCPTR];
	 WHILE .P3[CESLNK] NEQ 0 DO
	BEGIN
		PO_.P3[CESSOR];
		P2_.PO[PREDOM];
		WHILE .P1 NEQ .P2 DO
			IF .P1[LEVEL] LSS .P2[LEVEL] THEN
			P2_.P2[PREDOM] ELSE P1_.P1[PREDOM];
		IF .PO[PREDOM] NEQ .P1 THEN
		BEGIN
			PO[PREDOM] _ .P2;
			NOCHANGE _ 0;
		END;
		P3_.P3[CESLNK];
	END;
	HEAD_.HEAD[BUSY];
END UNTIL .HEAD EQL 0;
HEAD_.TOP;
END UNTIL .NOCHANGE;
END;

!***********************************************************

ROUTINE REFLOOD=
BEGIN
!ASSIGN MOORE FLOOD NUMBER AND SET UP BUSY LIST FOR 
!POSTDOMINATOR ALGORITHM
!SEE COMMENTS IN ROUTINE MOORE FOR THE ALGORITHM. IT IS
!IDENTICAL TO THE PREDOMINATOR *FLOODING* PROCESS EXCEPT THAT
!IT IS STARTED AT LEND INSTEAD OF TOP.
!THE VARIABLES P1 AND P2 AND TAIL ALSO HAVE THE SAME FUNCTIONS.

	EXTERNAL CSTMNT,ISN;
	MAP BASE CSTMNT;

! LEND IS THE SUPEREXIT

HEAD_.LEND;
TAIL_.LEND;
OLDHEAD_.HEAD;
HEAD[POSTDOM]_.HEAD;
HEAD[LEVEL] _1;
DO
BEGIN
	CSTMNT_.HEAD;
	ISN_.CSTMNT[SRCISN];
	P1_.HEAD[PREDPTR];
	WHILE .P1[CESLNK] NEQ 0 DO
	BEGIN
		P2_.P1[CESSOR];
		IF .P2[LEVEL] EQL 0 THEN
		BEGIN
			P2[LEVEL] _.HEAD[LEVEL] + 1;
			P2[POSTDOM] _ .HEAD;
			TAIL[BUSY] _ .P2;
			TAIL_.P2;
		END;
		P1_.P1[CESLNK];
	END;
	HEAD_.HEAD[BUSY];
END UNTIL .HEAD EQL 0;
END;

!******************************************************

ROUTINE PDOMINATE =
BEGIN
!FIND POSTDOMINATORS IN THE REVERSE GRAPH
!SEE DOMINATE FOR DETAILS OF ALGORITHM. IT IS IDEBTICAL TO
!THE PREDOMINATORE ALGORITHM. THE VARIABLES PO,P1,P2 PREFORM
!THE SAME FUNCTIONS, EXCEPT THAT , OF COURSE, IT IS
!PREDECESSOR CHAINS THAT ARE FOLLOWED INSTEAD OF SUCCESSOR CHAINS
!AND THE POSTDOM FIELD THAT IS UPDATED.


	EXTERNAL CSTMNT,ISN;
	MAP BASE CSTMNT;
LOCAL NOCHANGE;
HEAD_.OLDHEAD;
DO
BEGIN
NOCHANGE _ 1;
DO
BEGIN
	CSTMNT_.HEAD;
	ISN_.CSTMNT[SRCISN];
	P1_.HEAD;
	P3_.P1[PREDPTR];
	 WHILE .P3[CESLNK] NEQ 0 DO
	BEGIN
		PO_.P3[CESSOR];
		P2_.PO[POSTDOM];
		WHILE .P1 NEQ .P2 DO
			IF .P1[LEVEL] LSS .P2[LEVEL] THEN
			P2_.P2[POSTDOM] ELSE P1_.P1[POSTDOM];
		IF .PO[POSTDOM] NEQ .P1 THEN
		BEGIN
			PO[POSTDOM] _ .P2;
			NOCHANGE _ 0;
		END;
		P3_.P3[CESLNK];
	END;
	HEAD_.HEAD[BUSY];
END UNTIL .HEAD EQL 0;
HEAD_.OLDHEAD;
END UNTIL .NOCHANGE;
END;
EXTERNAL DWP;
EXTERNAL LOOPTR;
MAP BASE LOOPTR;
OWN DOWALK[32];
GLOBAL ROUTINE WALKER =
BEGIN
	!GET A DO LOOP TO PROCESS
	!CODE FOR FIRST TIME THROUGHT ONLY

	EXTERNAL OPTERR;

	IF .DWP EQL -1 THEN
	BEGIN
		DWP_0;
		LOOPTR_DOWALK[0]_.DLOOPTREE;
	END ELSE
	BEGIN
		!GRONK THE POINTER JUST PROCESSED
		!********************************
		!
		!NOTE: THIS IS A DESTRUCTIVE WALK
		!
		!********************************

		DWP_.DWP-1;
		IF .DWP LSS 0 THEN RETURN 0;
		LOOPTR_.DOWALK[.DWP];
		IF .LOOPTR[NEXTDO] NEQ 0 THEN
			LOOPTR[NEXTDO]_0
		ELSE
			LOOPTR[PARLVL]_0;
	END;

	!NOW THE WALK PART
	WHILE .LOOPTR[NEXTDO] NEQ 0 DO
	BEGIN
		DWP_.DWP+1;
		IF .DWP GEQ 31 THEN OPTERR(1);
		LOOPTR_DOWALK[.DWP]_.LOOPTR[NEXTDO];
	END;

	WHILE .LOOPTR[PARLVL] NEQ 0 DO
	BEGIN
		DWP_.DWP+1;
		IF .DWP GEQ 31 THEN OPTERR(1);
		LOOPTR_DOWALK[.DWP]_.LOOPTR[PARLVL];
		WHILE .LOOPTR[NEXTDO] NEQ 0 DO
		BEGIN
			DWP_.DWP+1;
			IF .DWP GEQ 31 THEN OPTERR(1);
			LOOPTR_DOWALK[.DWP]_.LOOPTR[NEXTDO];
		END;
	END;

	RETURN .LOOPTR
END;
    -96k