C       QUIT.FTF
        SUBROUTINE QUIT
C
C       THIS ROUTINE DOES ALL PROCESS-END ACTIVITIES
C
        COMMON /TITLE/ TITLE(16), MODIFY(2), NEWMOD, MODFLG, WRITEIT,
     1  XMIN, XMAX, YMIN, YMAX, PICFRAM
        INTEGER TITLE
        LOGICAL MODFLG, NEWMOD, WRITEIT, PICFRAM
C
    1   FORMAT(' DATA-BASE HAS BEEN MODIFIED...'/
     1  ' OLD MODIFICATION LABELED "',2A5,'",'/
     2  ' PLEASE ENTER NEW LABEL :' $ )
    2   FORMAT(/' ENTER NEW DATA-BASE FILE NAME, IF DESIRED :' $)
C
C       DETERMINE IF NEW MOD
        IF (.NOT. NEWMOD) GO TO 130
C
C       NEW MOD...GET LABEL
        TYPE 1, MODIFY
        IF (.NOT. FETCHL(I) ) GO TO 110
C
C       LABEL ENTERED...GET IT
        MODIFY(1) = 0
        MODIFY(2) = 0
        J = NOWCH(5, KANDO)
        CALL MPUTCH(J, 1, MODIFY(1) )
        DO 100 I = 2, 10
        J = NEXTCH(5, KANDO)
        IF (.NOT. KANDO) GO TO 110
  100   CALL MPUTCH(J, I, MODIFY(1) )
C
C       THAT IS DONE...NOW DETERMINE NEW FILE IF ANY
  110   TYPE 2
        IF (.NOT. FETCHL(I) ) GO TO 130
        IF (.NOT. DBTEST(3) ) GO TO 110
C
C       DONE...WRITE DATA-BASE IF NECESARY
  130   IF (WRITEIT) CALL DBWRI
D       CALL KLUTZ
        CALL EXIT
        END
        SUBROUTINE DBWRI
C
C       THIS ROUTINE IS USED TO OUTPUT A DATABASE.  IT IS ASSUMED
C       THAT THE FILE IS CLOSED.  THE FILE IS OPENED, AND THE DATA-BASE
C       PREAMBLE IS RESERVED.  THE TABLE FILES ARE OPENED, COPIED
C       TO THE DATABASE, AND THEN ARE CLOSED AGAIN.  FINALLY THE
C       PREAMBLE IS WRITTEN, AND THE DATA-BASE CLOSED, BEFORE RETURNING
C       .TRUE. WITH EVERYTHING RESTORED.
C
        EXTERNAL DBBOUT, DBSOUT
C
        COMMON /DBPRE/ DBTITLE(16), DBMOD(2), DBMFLG, DBSNO, DBSFORM(2),
     1  DBBLOK(4, 8), DBEND, DBXMIN, DBXMAX, DBYMIN, DBYMAX
        INTEGER DBTITLE, DBMOD, DBSNO, DBSFORM, DBBLOK, DBEND
        LOGICAL DBMFLG
C
        COMMON /FILES/ FILES(7, 8)
        INTEGER FILES, FSIGNAL(7)
        EQUIVALENCE (FILES(1, 5), FSIGNAL(1) )
C
        COMMON /DTABASE/ DTABASE(9)
        INTEGER DTABASE
C
        COMMON /TITLE/ TITLE(16), MODIFY(2), NEWMOD, MODFLG, DBWRITE,
     1  XMIN, XMAX, YMIN, YMAX, PICFRAM
        INTEGER TITLE
        LOGICAL MODFLG, NEWMOD, DBWRITE, PICFRAM
C
C       FIRST OPEN THE FILE
        CALL WOPEN(DTABASE(1) )
C
C       COPY STUFF TO THE PREAMBLE BLOCK
        DO 100 I = 1, 16
  100    DBTITLE(I) = TITLE(I)
        DBMOD(1) = MODIFY(1)
        DBMOD(2) = MODIFY(2)
        DBMFLG = MODFLG
        DBXMIN = XMIN
        DBXMAX = XMAX
        DBYMIN = YMIN
        DBYMAX = YMAX
        NWINDB = 130
        WRITE (DTABASE(1) # 1) DBTITLE, DBMOD, DBMFLG, DBSNO, DBSFORM,
     1  NWINDB, DBBLOK, DBEND, DBXMIN, DBXMAX, DBYMIN, DBYMAX
        IBLOCK = 2
C
C       DETERMINE HOW MUCH SPACE EXISTS FOR BUFFERING
        CALL DYNARY(ISPACE)
        ISPACE = MIN0(ISPACE, 4*NWINDB)
C
C       NOW OUTPUT THE BLOCKS OF DATA TO THE DATA-BASE
        DO 110 I = 1, 4
        ISIZE = MIN0(ISPACE, (FILES(2, I)*FILES(3, I))+NWINDB)
         CALL DYNARY(IERR, DBBOUT, ISIZE, 0, ISIZE, IBLOCK,
     1   FILES(1, I), DBBLOK(1, I) )
  110    CONTINUE
C
C       NOW OUTPUT THE SIGNALS TO THE DATABASE
        ISIZE = MIN0(ISPACE, (FSIGNAL(2)*FSIGNAL(3))+NWINDB)
        CALL DYNARY(IERR, DBSOUT, ISIZE, 0, ISIZE, IBLOCK,
     1  DBBLOK(1, 5), DBSFORM(1), DBSNO)
C
C       WRITE THE REST OF THE TABLES TO THE FILE
        DO 120 I = 6, 8
        ISIZE = MIN0(ISPACE, (FILES(2, I)*FILES(3, I))+NWINDB)
         CALL DYNARY(IERR, DBBOUT, ISIZE, 0, ISIZE, IBLOCK,
     1   FILES(1, I), DBBLOK(1, I) )
  120    CONTINUE
C
C       FINISH UP
        DBEND = IBLOCK
        WRITE (DTABASE(1) # 1) DBTITLE, DBMOD, DBMFLG, DBSNO, DBSFORM,
     1  NWINDB, DBBLOK, DBEND, DBXMIN, DBXMAX, DBYMIN, DBYMAX
C
C       DONE..NOW CLEAN UP
        CALL WCLOSE(DTABASE)
        RETURN
        END
        SUBROUTINE DBBOUT(LIST, LSIZE, IBLOCK, FILE, BLOCK)
C
C       THIS ROUTINE BUFFERS A SET OF DATA TO THE DATA-BASE FILE FROM
C       THE FILE SPECIFIED BY FILE, ACCORDING TO THE INFORMATION IN
C       FILE, AND USING THE TEMPORARY STORAGE LIST.
C
        INTEGER LIST(1), FILE(7), BLOCK(4)
C
        COMMON /DTABASE/ DTABASE(9)
        INTEGER DTABASE
C
C       FIRST CLOSE FILE IF NECESSARY
        IF (FILE(4) ) CALL WCLOSE(FILE)
C
C       NOW INITIALIZE THE FILE BLOCK FOR TRANSFER IF NECESSARY
        BLOCK(1) = IBLOCK
        IF (FILE(3) .LE. 0) GO TO 110
        MSIZE = DTABASE(2)
        IFS = FILE(2)
        FILE(2) = MSIZE
        CALL WOPEN(FILE)
        NWORDS = IFS*FILE(3)
        MWORDS = LSIZE/MSIZE*MSIZE
C
C       NOW DETERMINE HOW MANY WORDS TO TRANSFER, DO 1 SET
  100   NXFER = MIN0(NWORDS, MWORDS)
        READ (FILE(1) ) (LIST(I), I = 1, NXFER)
        WRITE (DTABASE(1) ) (LIST(I), I = 1, NXFER)
        NWORDS = NWORDS - NXFER
        IF (NWORDS .GT. 0) GO TO 100
C
C       THE TRANSFER IS DONE.. CLOSE THE FILE
        CALL WCLOSE(FILE)
        FILE(2) = IFS
C
C       NOW COPY ADDITIONAL INFORMATION INTO THE FILE BLOCK
  110   IBLOCK = POSITION(DTABASE(1) )
        BLOCK(2) = IBLOCK - BLOCK(1)
        BLOCK(3) = FILE(2)
        BLOCK(4) = FILE(3)
C
C       DONE...EXIT
        RETURN
        END
        SUBROUTINE DBSOUT(LIST, LSIZE, IBLOCK, BLOCK, FORM, NO)
C
C       THIS ROUTINE BUFFERS THE TABLE OF SIGNALS TO THE DATA-BASE FROM
C       THE SIGNAL TABLE.  IT USES DATA IN BLOCK, AND THE TEMP ARRAY
C       LIST, OF SIZE LSIZE.
C
        INTEGER LIST(1), BLOCK(4), FORM(2)
C
        COMMON /FILES/ FILES(7, 4), FSIGNAL(7)
        INTEGER FSIGNAL
C
        COMMON /DTABASE/ DTABASE(7)
        INTEGER DTABASE
C
        COMMON /HASHCON/ NHASH, NBLOCK, THISSIG, SIGID(2), NEXT,
     1  NEXTPIN, SIGWRIT, DSHEAD(2), CDSN
        INTEGER THISSIG, SIGID, DSHEAD, CDSN
        LOGICAL SIGWRIT
C
C       FIRST OF ALL, SET SOME NUMBERS FROM /HASHCON/
        FORM(1) = DSHEAD(1)
        FORM(2) = DSHEAD(2)
        NO = CDSN
        MSIZE = DTABASE(2)
C
C       INITIALIZE THE BLOCK
        BLOCK(1) = IBLOCK
        BLOCK(3) = 4
        BLOCK(4) = 0
C
C       COMPUTE HOW MUCH SPACE IS AVAILABLE
        NWORDS = LSIZE/MSIZE*MSIZE
C
C       GET AN ENTRY, IF GOOD, PUT IT INTO THE LIST
        NITEM = 1
        DO 120 N = 1, NBLOCK
         CALL GETSIG(N)
         IF (SIGID(1) .EQ. 0) GO TO 120
         IF ( (NEXTPIN .AND. "377777777777) .EQ. 0) GO TO 120
         BLOCK(4) = BLOCK (4) + 1
         JCOUNT = 1
C
C       COPY THE ENTRY TO THE LIST
  100    LIST(NITEM) = SIGID(JCOUNT)
         IF (JCOUNT .EQ. 3) LIST(NITEM) = 0
         NITEM = NITEM + 1
         JCOUNT = JCOUNT + 1
         IF (NITEM .LE. NWORDS) GO TO 110
C
C       HAVE TO WRITE THE LIST OUT
        WRITE (DTABASE(1) ) (LIST(I), I = 1, NWORDS)
         NITEM = 1
C
C       DETERMINE IF ENTIRE SIGNAL ELEMENT IS DONE
  110    IF (JCOUNT .LE. 4) GO TO 100
C
C       END OF LOOP
  120    CONTINUE
C
C       WRITE LAST PARTIAL BLOCK OUT IF NECESSARY
        NITEM = NITEM - 1
        IF (NITEM .GT. 0) WRITE (DTABASE(1) ) (LIST(I), I = 1, NITEM)
        IBLOCK = POSITION(DTABASE(1) )
        BLOCK(2) = IBLOCK - BLOCK(1)
C
C       HERE WHEN WE'VE GOTTEN ALL SIGNALS..EXIT
        RETURN
        END
