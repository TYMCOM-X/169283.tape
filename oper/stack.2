	TITLE	STACK	V.002	10-MAR-69

;COPYRIGHT BY DIGITAL EQUIPMENT CORP.
;MAYNARD, MASSACHUSETTS  1968


	JOBVER=137
	LOC JOBVER
	OCT	2
	RELOC

ACDEV=	1
ACFILE=	2
ACEXT=	3
ACDEL=	4
ACPNTR=	5

CTL=	0
IN0=	0
IN1=	1
IN2=	2

C=	10
%0=0
%1=1
%2=2
%3=3
%4=4
%5=5
%6=6
%7=7
%10=10
%11=11
%12=12
%13=13
%14=14
%15=15
%16=16
P=	17

	TAB=	11
	LF=	12
	FF=	14
	CR=	15

STARTA:	CALLI
	CALLI	%1,24	;ARE WE UNDER 1,1
	CAME	%1,[1000001]
	JRST	STT1
	INIT	1,0
	SIXBIT/DSK/
	XWD	OUTBUF,0
	HALT	.
	ENTER	1,NEW
	JRST	STT	;BATCH AREA IS WRITE PROTECT OR DOESN'T EXIST
	CLOSE	1,
	SETZM	NEW
	RENAME	1,NEW
	HALT	.
STT1:	SETZM	OUTDIR
	SETZM	OUTDIR+1
	SETZM	OUTDIR+2
	SETZM	NEW	;ZERO FOR OTHER ENTERS TO HERE
	SETZM	NEW+3	;ZERO PJ-PG NUMBER
	JRST	START
STT:	SETZM	NEW
	HRRZ	%1,NEW+1	;GET REASON WHY ENTER FAILED
	CAILE	%1,2	;NO UFD OR WRITE PROTECT
	JRST	STT1	;FAILED BECAUSE FILE WAS BEING MODIFIED
	MOVEI	%11,[ASCII/DO YOU WISH TO CREATE BATCH AREA
/]
	PUSHJ	P,TYPMSG
	INPUT	0,
	PUSHJ	P,TTYIN	;GET ANSWER
	CAIE	C,"Y"
	JRST	STT1
	CAIE	%1,2
	JRST	STT2	;MUST CREATE UFD
	LOOKUP	IN1,OUTDIR	;TAKE OFF PROTECTION
	HALT	.
STT3:	CLOSE	1,
	SETZM	OUTDIR+2
	RENAME	1,OUTDIR
	HALT	.
	JRST	STT1

STT2:	ENTER	1,OUTDIR
	HALT	.
	JRST	STT3
START:	RELEASE	0,
	RELEASE	1,
	RELEASE	IN2,
STAR:	MOVE	P,[XWD  -30,PSET]	;SET UP PUSH DOWN POINTER
	PUSHJ	P,D13	;PUT IN BATCH AREA PJ-PG NUMBER
	SETZM	OUTDEV	;ZERO OUTPUT DEVICE WORD
	SETZ	%16,	;CLEAR FLAG REGISTER
	PUSHJ	P,CTLSET	;OUTPUT A "*"
	SETZM	ADEV
	SETZM	TBL
	SETZM	TBL+1
	SETZM	TBL+2
	SETZM	SCANN
	SETZM	FLG
	PUSHJ	P,NAME1	;GET FIRST WORD OF COMMAND SRTING
	CAIN	C,"_"	;IS THERE AN OUTPUT DEVICE
	JRST	COM1	;NO
	MOVE	%13,AZDEV	;REMEMBER ASCII NAME OF OUTPUT DEVICE
	MOVEM	%13,AZD
	MOVE	%13,AZDEV+1
	MOVEM	%13,AZD+1	;IT CAN BE UPTO SIX ASCII CHARACTERS
	MOVEM	ACDEV,OUTDEV	;THIS IS THE SIXBIT NAME
	PUSHJ	P,NAME1	;GET SECOND WORD FROM COMMAND STRING
	CAIE	C,"_"	;THIS BETTER BE THE DELIMITER
	JRST	CMERR
	CAIN	ACFILE,0	;WAS THERE A FILE SPECIFIED
	JRST	COM1-1		;NO
	TLO	%16,40	;YES - SET FLAG
	MOVEM	ACFILE,OUTDIR	;ONLY THE OUTPUT OPTION SHOULD HAVE A FILE NAME HERE
	MOVEM	ACEXT,OUTDIR+1	;HERE IS THE ONLY PLACE AN EXTENSION IS ALLOWED
	PUSHJ	P,OUT	;INITIALIZE OUTPUT DEVICE
COM1:	SETOM	FLG	;THIS IS A FLAG FOR WHICH SIDE OF THE"_" WE ARE ON
	SETZM	ADEV
	TRNE	%16,34
	JRST	OTH	;JUMP IF NOT /I OR /O JUMP
	TRNN	%16,2	;IS /O SPECIFIED
	TRO	%16,1	;MAKE SURE /I FLAG IS SET
	PUSHJ	P,NAMEA	;GET INPUT DEVICE
	CAIN	ACDEV,0	;BETTER NOT BE ZERO
	JRST	CMERR
	MOVEM	ACDEV,INDEV	;PUT IN FOR INITIALIZATION
	PUSHJ	P,IN	;INITIALIZE INPUT DEVICE
	PUSHJ	P,NAME1	;NOW GET INPUT FILE NAME
	CAIN	C,":"	;BETTER NOT HAVE THIS AS A DELIMITER
	JRST	CMERR
	MOVEM	ACFILE,INDIR	;BPUT FILE NAME IN DIRECTORY
	MOVEM	ACEXT,INDIR+1	;AND INPUT EXTENSION
	MOVEM	C,SAVC	;AND SAVE COMMAND STRING DELIMITER
	PUSHJ	P,INLOK	;DO LOOKUP ON INPUT FILE
	MOVE	%13,INCHR
	TRNN	%16,2
	TLNN	%13,200000
	JRST	TOP2-1
	MOVE	%13,INDIR+3
	CAME	%13,[1000003]	;BUT WAS IT BATCH AREA
	JRST	TOP2-1	;NO
	PUSHJ	P,READL	;LOOK FOR PJ-PG NUMBER ON FIRST LINE
	PUSHJ	P,NOTYOU
	JRST	.+2
	JRST	TOP2
	MOVE	%13,[1000003]
	MOVEM	%13,INDIR+3
	LOOKUP	IN1,INDIR
	HALT	.
	PUSHJ	P,MOVEA	;MOVE THE FILE TO OUTPUT DEVICE
TOP2:	PUSHJ	P,NAME1	;GET NEXT NAME
	MOVEM	C,SAVC	;SAVE DELIMITER, RETURN TO START IS MADE WHEN SAVC CONTAINS
			;A CR AND AN END OF FILE HAS BEEN SEEN
	SKIPN	ACDEV	;IS THERE A DEVICE SPECIFICATION
	JRST	TOP1	;NO - THEN IT MUST BE A FILE NAME
	MOVEM	ACDEV,INDEV	;THERE IS A DEVICE SPECIFICATION
	TLO	%16,4	;DON'T INSERT EOF WHEN YOU SEE THE NEXT JOB CARD
	PUSHJ	P,IN	;INITIALIZE THE NEW DEVICE
	MOVE	%13,INCHR	;GET CHARACTERISTICS OF INPUT DEVICE
	TLNN	%13,4	;IS THERE A DIRECTORY
	JRST	TOP4
	PUSHJ	P,D13	;RESET PJ-PG NUMBERS
	PUSHJ	P,NAME1	;GET FILE NAME
	SKIPN	ACFILE	;IT WASN'T A FILE NAME
	JRST	CMERR
	MOVEM	C,SAVC
TOP1:	TLNN	%16,100
	JRST	.+3
	PUSHJ	P,CLOSE1
	PUSHJ	P,OUTLOK	;CREATE A NEW OUTPUT FILE
	MOVEM	ACFILE,INDIR
	TLZ	%16,100
	MOVEM	ACEXT,INDIR+1
TOP3:	MOVE	%13,PJG
	MOVEM %13,INDIR+3
	TLNN	%16,600
	PUSHJ	P,INLOK	;DO LOOKUP ON FILE
	TLZ	%16,600
	MOVE	%13,INCHR	;GET INPUT DEVICE CHARS.
	TLNN	%13,200000
	JRST	TOP20
	MOVE	%13,INDIR+3
	CAME	%13,[1000003]	;IS IT BATCH AREA?
	JRST	TOP20	;NO
	PUSHJ	P,READL	;READ FIRST LINE, LOOK FOR PJ-PG NUM.
	PUSHJ	P,NOTYOU
	JRST	.+2
	JRST	TOP2
	MOVE	%13,[1000003]
	MOVEM	%13,INDIR+3
	LOOKUP	IN1,INDIR	;REOPEN FILE
	HALT	.
TOP20:	PUSHJ	P,MOVEB	;MOVE THE FILE TO OUTPUT DEVICE
	JRST	TOP2	;AND KEEP GOING


TOP4:	XCT	TTYIN	;IT ISN'T A DIRECTORY DEVICE
	CAIN	C,CR	;SO DEVICES SHOULD BE SEPERATED BY A COMMA
	JRST	.+3
	CAIE	C,","
	JRST	CMERR
	MOVEM	C,SAVC
	JRST	TOP3

MOVEA:	TRNN	%16,2	;IS IT /O?
	JRST	MOVE	;NO IT IS /I
	JRST	OTH2	;/O
MOVEB:	TLNN	%16,6000
	JRST	MOVEB1
	TRNN	%16,1	;IS IT /I
	JRST	OTH2
	JRST	MOVE1	;/I
MOVEB1:	MOVEI	%7,"$"
	TLZ	%16,6000
	JRST	MOVE1+1
OTH:
	TRNE	%16,10	;WHICH SWITCHES ARE SET
	JRST	SS	;SELECTIVELY OUTPUT OR DELETE
	TRNE	%16,20
	JRST	DELET	;STRAIGHT DELETE
	TRNE	%16,4
	JRST	LIST	;LIST
OTH2:	TLNN	%16,40	;DID USER SPECIFY A FILE
	PUSHJ	P,OUTC	;GENERATE OUTPUT NAME AND ENTER IT
	MOVE	%13,INCHR	;GET CHARACTERISTICS OF INPUT DEVICE
	TLNN	%13,200000
	JRST	OTH1	;NOT BATCH AREA
	MOVE	%13,PJG
	CAME	%13,[1000003]	;DISK, BUT IS IT BATCH AREA
	JRST	OTH1	;USER'S AREA
	PUSHJ	P,PJPG	;GET USER'S PJ-PG NUMBER
	PUSHJ	P,READL	;READ FIRST LINE AND LOOK FOR PJ-PG NUMBER
	PUSHJ	P,NOTYOU	;NOT HIS FILE
	JRST	.+2
	JRST	OTH20
OTH1:	TLO	%16,4	;THIS IS SO THAT AN $EOF WON'T BE INSERTED
	PUSHJ	P,SWAP	;MOVE FILES
	POPJ	P,

OUTC:
	CLOSE	IN2,
	JRST	OUTLOK

SWAP:		;THIS SWAPS FILES,RETURNS WHEN AN END OF FILE IS SEEN
	PUSHJ	P,GETCH
	PUSHJ	P,DEPIST
	JRST	.-2



OTH20:	MOVE	C,SAVC
	CAIE	C,CR
	POPJ	P,
	JRST	START
;LIST THE DIRECTORY BY LISTING THE FILE NUMBER AND FIRST LINE
LIST:
	TRNN	%16,2	;UNLESS OJOB IS SPECIFIED, IJOB IS DEFAULT
	TRO	%16,1	;MAKE IJOB DEFAULT
	SKIPN	OUTDEV	;TTY IS DEFAULT OUTPUT DEVICE
	PUSHJ	P,DLST	;MAKE IT DEFAULT OUTPUT DEVICE
	PUSHJ	P,NAMEA	;GET INPUT DEVICE NAME
	CAIN	ACDEV,0	;DEVICE SHOULD BE SPECIFIED
	JRST	CMERR
	MOVEM	ACDEV,INDEV	;PUT IN FOR INITIALIZATION
	PUSHJ	P,IN	;INITIALIZE
	MOVE	%13,INCHR	;GET INPUT DEVICE CHARACTERISTICS
	TLNN	%13,200000
	JRST	LIST1	;JRST IS DECTAPE
	MOVE	%13,INDIR+3
	CAME	%13,[1000003]	;ARE WE TALKING ABOUT BATCH AREA
	JRST	LIST1
	PUSHJ	P,PJPG	;YES - GET USERS PJ-PG NUMBER
	MOVE	%6,INPJG	;SAVE PROJ-PROG NUMBER
	PUSHJ	P,NAME1
	MOVEM	C,SAVC
LIST6:	MOVEM	ACFILE,INDIR	;PUT CURRENT JOB IN DIRECTORY
	MOVEM	%6,INDIR+3	;RESTORE PROJ-PROG NUMBER
	LOOKUP	IN1,INDIR	;IS CURRENT JOB IN DIRECTORY?
	JRST	START	;WHEN WE GET HERE WE ARE THROUGH WITH LISTING
	PUSHJ	P,READL	;BUT ARE SOMEONE ELSE'S PJ-PG NUMBERS ON FIRST CARD
	JRST	LIST7	;YES - FORGET IT
	TRNN	%16,1	;IF /O SKIP LINE-FEED
	PUSHJ	P,GETCH
	PUSHJ	P,PLINE	;IT'S AVAILABLE TO HIM, PRINT LINE
LIST7:	MOVE	C,SAVC
	CAIN	C,CR
	JRST	STAR
	PUSHJ	P,NAME1
	MOVEM	C,SAVC
	JRST	LIST6	;AND CONTINUE LISTING


;GET USERS PJ-PG NUMBER
PJPG:
	SETZM	PJ	;CLEAR AREA TO STORE NUMBERS
	SETZB	%1,PG
	CALLI	%1,24	;THIS UUO WILL RETURN NUMBERS IN AC1
	HLRM	%1,PJ	;SEPERATE AND STORE
	HRRM	%1,PG
	POPJ	P,
SETIO:		;SET AS EITHER IJOBNN OR OJOBNN
	TRNE	%16,1	;IF 1 IS SET THEN IJOBNN
	SKIPA	%10,[SIXBIT/IJOB01/]
	MOVE	%10,[SIXBIT/OJOB01/]
	MOVEM	%10,IO	;STORE FOR FURTHER USE
	POPJ	P,


PLINE:		;PRINT A LINE - FOR LISTING DIRECTORIES
	PUSHJ	P,LOUT	;THIS WILL PRINT OUT THE IJOB NUMBER
	PUSHJ	P,LIST3	;THIS WILL PRINT THE FIRST LINE OF FILE
	PUSHJ	P,CRF	;INSERT CR,LF
	MOVEM	%12,OUTBUF+1	;PUT POINTER BACK
	OUTPUT	IN2,	;AND OUTPUT LINE
	MOVE	%12,OUTBUF+1	;RESET OUR POINTER
	POPJ	P,


DLST:			;DEFAULT OUTPUT DEVICE FOR LISTING
	MOVSI	%0,(SIXBIT/TTY/)
	MOVEM	%0,OUTDEV
	PUSHJ	P,OUT
	POPJ	P,
;READ THE FIRST LINE OF A FILE AND SEE IF SOMEONE ELSE'S PJ-PG
;NUMBER IS IN THE FIRST LINE,  USED FOR LISTING OR DELETING BATCH AREA
READL:
	SETZM	S1	;CLEAR SOME WORKING SPACE
	SETZM	S2
	SETZM	S3
	SETZ	%13,
	MOVEM	%11,TEMP	;SAVE POINTERS IN CASE FILE MUST BE READ LATER
	MOVE	%15,INBUF+2	;AND SAVE COUNT
READL1:	EXCH	%7,S1	;SAVE CHARACTER IN CASE IT IS PART OF PJ-PG NO.
	EXCH	%7,S2	;THIS WILL SAVE THE FIRST OF TWO TO BE SAVED
	EXCH	%7,S3
	PUSHJ	P,GETCH	;GET ANOTHER CHARACTER
	CAIN	%7,CR	;HAVE WE REACHED THE END OF THE LINE?
	JRST	READL2	;OK RETURN IF NO PROJ_-PROG NUMBER
	CAIE	%7,","	;WE ARE ONLY INTERESTED IF WE SEE A COMMA
	JRST	READL1	;KEEP READING
	AOJ	%13,	;INCREMENT COMMA COUNT
	CAIE	%13,2	;SECOND COMMA SHOULD BE IN PJ-PG NO.
	JRST	READL1	;KEEP SCANNING
	MOVE	%13,S3
	SUBI	%13,60
	CAIL	%13,0
	CAILE	%13,10
	TDZA	%13,13
	LSH	%13,3	;THIS WILL ZERO 13 AND SKIP
	MOVE	%1,S2	;CONVERT PROJECT NUMBER
	SUBI	%1,60	;CHANGE TO BINARY
	CAIL	%1,0	;IS IT A DIGIT?
	CAILE	%1,10
	TDZA	%13,13	;IF NOT DIGIT, ZERO WHOLE WORKS
	ADD	%13,%1	;CONTINUE FORMING DIGIT
	LSH	%13,3	;MAKE ROOM FOR NEXT DIGIT
	MOVE	%7,S1
	SUBI	%7,60
	ADD	%13,%7
	CAME	%13,PJ	;DO THE PROJECT NUMBERS MATCH
	JRST	READL3	;NO TAKE ERROR RETURN
	SETZ	%1,	;YES - NOW CHECKPROGRAMMER NUMBER
	PUSHJ	P,FGET	;THIS FILL RETURN WITH THE NUMBER FOLLOWING THE COMMA
	CAME	%1,PG	;DOES THE PROGRAMMER NUMBER MATCH
	JRST	READL3	;NO
READL2:	MOVE	%11,TEMP
	MOVEM	%15,INBUF+2
	JRST	SPOP

READL3:	MOVE	%11,TEMP	;THIS IS NOT USER'S FILE
	MOVEM	%15,INBUF+2	;RESET POINTERS AND COUNT
	POPJ	P,
LIST2:			;OUTPUT ANY CHARACTER EXCEPT A CR
			;THIS IS USED FOR OUTPUTING A SINGLE LINE
	PUSHJ	P,GETCH	;GET A CHARACTER
	CAIN	%7,15	;IF CR RETURN NORMAL
	POPJ	P,
	PUSHJ	P,DEPIST	;DEPOSIT IT
	JRST	SPOP	;RETURN CALLING ADR +2



LIST1:
	PUSHJ	P,NAME1	;GET A FILE NAME AS IF THE /A SWITCH WERE SET
	MOVEM	C,SAVC	;SAVE DELIMITER
	MOVEM	ACFILE,INDIR
	MOVE	%13,INPJG	;GET INPUT PJ-PG NUMBER
	MOVEM	%13,INDIR+3
	LOOKUP	IN1,INDIR	;OPEN FILE
	HALT	.	;SHOULD NEVER GET HERE
	TRNN	%16,1	;IF /O SKIP LINE-FEED
	PUSHJ	P,GETCH
	PUSHJ	P,PLINE	;PRINT FILE NUMBER AND FIRST LINE
	MOVE	C,SAVC
	CAIE	C,CR
	JRST	LIST1
	JRST	STAR


LIST3:
	PUSHJ	P,LIST2	;OUTPUT A CHARACTER
	POPJ	P,	;HERE IF CR
	JRST	.-2	;HERE FOR ANYTHING ELSE

;THE FOLLOWING CODE IS USED TO DELETE FILES
DELET:
	TLO	%16,40	;DON'T OPEN FILE IF /A
	MOVE	%13,OUTCHR	;GET CHARACTERISTICS OF OUTPUT DEVICE
	TLNN	%13,4	;PROCEED ONLY IF DIRECTORY DEVICE
	JRST	START
	TRNN	%16,40	;/A SET
	JRST	DELET3	;NO
	MOVE	%13,OUTDEV	;YES MUST INITIALIZE INPUT
	MOVEM	%13,INDEV
	MOVE	%13,OUTDIR+3	;DON'T FORGET PJ-PG NUMBER
	MOVEM	%13,INDIR+3
	PUSHJ	P,IN	;INITIALIZE IT
DELET3:	TRNN	%16,2	;IF NOT SPECIFICALLY OJOBS, ASSUME IJOB FOR DELETING
	TRO	%16,1	;THIS IS DEFAULT CASE
	TLNN	%13,200000	;DECTAPE OR DISK
	JRST	DECDEL	;DECTAPE
	PUSHJ	P,NAMEA	;GET NAME OF FILE TO BE DELETED
	MOVEM	C,SAVC	;SAVE DELIMITER OF COMMAND STRING
	CAIN	ACFILE,0	;IF NO FILE SPECIFIED, THEN COMMAND ERROR
	JRST	CMERR
	MOVE	%6,OUTDIR+3	;SAVE PROJECT PTROGAMMER NUMBER
DELET2:	MOVEM	ACFILE,INDIR	;PUT FILE TO BE DELETED IN INPUT DDIRECTORY
	MOVE	%13,OUTDIR+3	;IUNDER WHICH DIRECTORY IS FILE?
	MOVEM	%13,INDIR+3
	CAME	%13,[1000003]	;THIS IS BATCH AREA
	JRST	UDEL	;FILE TO BE DELETED FROM USER'S AREA
	MOVE	%13,OUTDEV	;INITIALIZE CHANNEL ONE
	MOVEM	%13,INDEV	;SO THAT FIRST LINE CAN BE READ
	PUSHJ	P,IN	;INITIALIZE INPUT DEVICE
	PUSHJ	P,INLOK	;OPEN FILE SO THAT FIRST LINE CAN BE READ
	PUSHJ	P,READL	;THIS WILL READ FIRST LINE NAD LOOK FOR PJ_PG NO.
	PUSHJ	P,NOTYOU	;USER TRIED TO DELETE A FILE THAT WASN'T HIS
	PUSHJ	P,DFIL	;IT IS HIS SO DELETE IT
	MOVE	C,SAVC	;NOTYOU RETURNS HERE
	CAIN	C,CR	;ARE WE THROUGH WITH COMMAND STRING
	JRST	START	;YES
	PUSHJ	P,NAME1	;GET NAME OF NEXT FILE TO BE DELETED
	MOVEM	C,SAVC	;SAVE DELIMITER
	JRST	DELET2	;AND REPEAT


DFIL:	PUSHJ	P,HIGST	;LOOK FOR HIGEST JOB
	MOVEM	ACFILE,OUTDIR	;PREPARE TO DELETE FILE
	MOVEM	%6,OUTDIR+3
	LOOKUP	IN2,OUTDIR	;OPEN FILE
	HALT	.
	CLOSE	IN2,	;TEEL RENAME WHICH FILE
	MOVEM	%6,OUTDIR+3	;MAKE SURE PJ-PG NUMBER IS THERE
	SETZM	OUTDIR	;DELETE
	RENAME	IN2,OUTDIR
	HALT .
	MOVEM	%5,OUTDIR	;HIGHEST EXISTING JOB RETURNED IN AC5
	LOOKUP	IN2,OUTDIR	;OPEN FILE
	HALT	.
	CLOSE	IN2,	;CLOSE IT SO RENEMAE WILL KNOW
	CAML	ACFILE,%5	;ARE WE DELETING HIGHEST JOB?
	POPJ	P,	;IT WAS HIGHEST FILE
	MOVEM	ACFILE,OUTDIR	;ACFILE CONTAINS NAME OF FILE TO BE DELETED
	RENAME	IN2,OUTDIR	;NOW WE HAVE DELETED FILE AND FILLED IN SPACE
	HALT	.
	POPJ	P,
;DELETE A FILE FROM THE USER'S DIRECTORY AND THEN FILL IN THE SPACE
UDEL:	PUSHJ	P,HIGST	;GET HIGHEST JOB NAME
	MOVE	%13,OUTDIR	;OUTDIR CONTAINS FIRST JOB WHICH DOESN'T EXIST
	MOVEM	%13,HIGJOB	;SAVE IT SO WE WILL KNOW WHEN TO STOP
DELET1:	MOVEM	ACFILE,OUTDIR	;INSERT FILE TO BE DELETED
	LOOKUP	IN2,OUTDIR	;OPEN THAT FILE
	JRST	ERIN	;USER TRIED TO DELETE A FILE WHICH DIDN'T EXIST
	CLOSE	IN2,	;CLOSE IT FOR RENAME
	SETZM	OUTDIR	;THIS WILL DELETE IT
	RENAME	IN2,OUTDIR
	HALT	.
	MOVE	C,SAVC	;WHAT WAS LAST COMMAND DELIMITER
	CAIE	C,CR	;IF CR, WE ARE THROUGH
	JRST	UDEL1	;STILL HAVE SOME MORE FILES  DELETE
	JRST	DEN	;THIS WILL FILL INTHE SPACES AND RESTART
UDEL1:	PUSHJ	P,NAME1	;GET NAME OF NEXT FILE TO BE DELETED
	MOVEM	C,SAVC	;SAVE COMMAND STRING DELIMITER
	JRST	DELET1	;AND CONTINUE


NEX:		;THIS ROUTINE IS ENTERED WITH AN IJOB OR
			;OJOB NAME IN AC%0, IT THEN INCREMENTS 
			;THIS NAME
	LDB	%13,[POINT 4,,35]	;SET POINTER TO DIGIT NUMBER
	CAIL	%13,11	;IS IT ^D9?
	JRST	NEX1	;YES
	AOJ	%0,	;NO - THEN SIMPLE INCREMENT
	POPJ	P,
NEX1:	SETZ	%13,	;WE MUST ZERO DIGIT NUMBER AND INCREMENT TENS NUMBER
	DPB	%13,[POINT 4,,35]	;CHANGE 9 TO 0
	LDB	%13,[POINT 4,,29]	;GET OTHER NUMBER
	CAIL	%13,11	;IS IT LESS THAN ^D9?
	JRST	NEX2	;NO
	ADDI	%0,100	;YES - THEN INCREMENT IT
	POPJ	P,
NEX2:	HALT	.
;THIS CODE FILES IN THE HOLES IN THE DIRECTORY AFTER SOME FILES HAVE BEE DELETED
DEN:
	PUSHJ	P,HIGST	;GET HIGHEST CONSECUTIVE FILE NAME
	MOVE	%1,OUTDIR	;OUTDIR CONTAINS FIRST FILE TO FAIL ON LOOKUP
	CAML	%1,HIGJOB	;HIGJOB CONTAINS FIRST FILE NOT THERE BEFORE ANY WERE DELETED
	JRST	START	;THIS MEANS ALL SPACES ARE FILLED
	MOVEM	%1,NEW	;THIS IS FIRST	SPACE,IT WILL BE FILLED WITH A HIGHER JOB
	MOVE	%0,%1	;PUT IN AC0 SO THAT IT CAN BE INCREMENTED
MVIN:	PUSHJ	P,NEX	;NEX WILL INCREMENT FILE NAME IN AC0
	CAML	%0,HIGJOB	;HAVE WE REACHED THE TOP?
	JRST	START	;YES RETURN
	MOVEM	%0,OUTDIR	;WE ARE LOOKING FOR NEXT HIGHEST FILE TO USE AS A FILLER
	LOOKUP	IN2,OUTDIR	;HAVE WE FOUND A FILE?
	JRST	MVIN	;NO - INCREMENT AND KEEP LOOKING
	CLOSE	IN2,	;YES - CLOSE FOR RENAME
	MOVE	%13,OUTDIR+3	;BE SURE PJ-PG NUMBER IS SAME
	MOVEM	%13,NEW+3	;NEW CONTAINS NAME OF HOLE TO BE FILLED
	RENAME	IN2,NEW	;HOLE HAS BEEN FILLED
	HALT	.
	MOVE	%0,NEW	;GET NAME OF NEXT HOLE
	PUSHJ	P,NEX	;INCREMENT FILE NAME
	MOVEM	%0,NEW	;NEW CONTAINS NAME OF FIRST MISSING FILE
	MOVE	%0,OUTDIR	;THIS FILE WAS JUST DELETED
	JRST	MVIN
;DELETE A FILE FROM DECTAPE
DECDEL:
	PUSHJ	P,DDIN	;DO INITIALIZATION TO READ IN DECTAPE DIRECTORY
DEC3:	PUSHJ	P,NAMEA	;GET NAME OF FILE TO BE DELETED
	PUSH	P,C
	CAIN	ACFILE,0	;BETTER NOT BE ZERO
	JRST	CMERR
	PUSHJ	P,DELONE	;DELETE THAT FILE
	POP	P,C	;GET COMMAND STRING DELIMITER BACK
	CAIE	C,CR	;IS COMMAND STRING POINTER AT CR?
	JRST	DEC3	;NO CONTINUE
	PUSHJ	P,UPDAT	;YES, CLOSE IN THE HOLES
	PUSHJ	P,DDO	;READ DIRECTORY BACK OUT
	JRST	START	;AND GO GET ANOTHER COMMAND STRING

DDO:	OUTPUT	0,	;THIS IS DUMMY OUTPUT
	USETO	%0,144	;THIS IS WHERE THE DIRECTORY WILL GO
	MOVEI	%4,^D127*5
	MOVEM	%4,OUTIN+2
DEC4:	MOVE	%4,OUTIN	;GET ADRESS OF BUFFER
	OUTPUT	0,(%4)	;OUT GOES DIRECTORY
	RELEASE	0,	;AND CLOSE IT
	POPJ	P,

DDIN:
	MOVE	%13,OUTDEV	;GET NAME OF DECTAPE FROM WHICH FILE IS TO BE DELETED
	MOVEM	%13,.+3	;MUST REINITIALIZE IN ORDER TO GET DIRECTORY
	RELEASE	IN2,
	INIT	0,20	;INITIALIZE IN MODE WHICH WILL ALLOW US TO GET DIRECTORY
	Z
	XWD	OUTBUF,OUTIN
	HALT	.
	USETI	%0,144	;GET READY TO GET DIRECTORY
	INPUT	0,
	POPJ	P,	;GET IT
;DELETE ONE FILE FROM DECTAPE
DELONE:
	HRRZ	%10,OUTIN+1	;GET ADRESS OF BUFFER
	ADDI	%10,^D83	;GET ADRESS OF BEGINNING OF FILE NAMES
	MOVEI	%1,^D22	;THIS WILL BE FILE COUNT
DEC1:	CAMN	ACFILE,(%10)	;FILE WE ARE LOOKING FOR IS IN ACFILE
	JRST	FOUND	;FILE HAS BEEN FOUND
	AOJ	%10,	;ADVANCE TO NEXT FILE
	SOJG	%1,DEC1	;DECREMENT COUNTER AND TRY AGAIN
	JRST	ERIN	;ERROR - FILE NOT FOUND
FOUND:	SETZM	(%10)	;FILE FOUND - DELETE IT
	SETZM	26(%10)	;AND ITS EXTENSION
	MOVEI	%4,^D22	;WHAT WAS THE NUMBER OF THAT FILE?
	SUB	%4,%1	;AC1 WAS OLD COUNTER
	AOJ	%4,	;AC4 NOW CONTAINS THE NUMBER OF THAT FILE IN THE DIRECTORY
	MOVEI	%5,^D83*7	;HOW MANY SLOTS ARE THERE
	SETZ	%2,	;THIS WILL BE USED TO ZERO A SLOT
	HRLI	%0,(POINT 5,,35)	;SPECIAL POINTER, SINCE SLOTS ARE FIVE BITS
	HRR	%0,OUTIN+1	;ADRESS OF BEGINNING OF BUFFER
DEC2:	ILDB	%3,%0	;GET A NUMBER FROM A SLOT
	CAMN	%3,%4	;DOES THIS BLOCK BELONG TO FILE JUST DELETED?
	DPB	%2,0	;YES - ZERO SLOT
	SOJG	%5,DEC2	;DECREMENT SLOT COUNT AND TRY AGAIN
	POPJ	P,	;ALL THROUGH

;CLOSE IN THE HOLES IN A DECTAPE DIRECTORY CREATED BY DELETING FILES
UPDAT:
	MOVE	%0,IO	;WORKING WITH IJOBS OR OJOBS?
UPDAT2:	PUSHJ	P,SEE	;IS THIS JOB IN THE DIRECTORY
	JRST	UPDAT1	;YES- THEN GET NEXT JOB AND CHECK IT
	PUSHJ	P,DECN	;NO - FIIL IN THIS HOLE
	CAML	%0,%4	;ARE THERE ANY JOBS HIGHER
	POPJ	P,	;NO - ALL THROUGH
	PUSH	P,%0	;YES - SAVE PRESENT NAME
	MOVE	%0,%4	;WE KNOW THE JOB IN AC4 IS THERE, BUT WHERE IN THE DIRECTORY IS TI
	PUSHJ	P,SEE	;THE ADRESS OF IT IN THE DIRECTORY WILL BE RETURNED IN AC1
	POP	P,%0	;THUS WE WILL RETURN HERE
	MOVEM	%0,(%1)	;THIS OVERWRITES THAT HIGHEST FILE WITH A NEW NAME WHICH IS CONSECUTIVE
UPDAT1:	PUSHJ	P,NEX	;INCREMENT THE LOWEST CONSECUTIVE AND CONTINUE
	JRST	UPDAT2


SEE:
	MOVEI	%3,^D22	;THIS IS THE NUMBER OF FILES IN A DIRECTORY
	HRRZ	%1,OUTIN+1	;GET ADRESS OF DIRECTORY
	ADDI	%1,^D83	;SKIP FIRST 83 WORDS WHISH CONTAIN SLOTS
SEE1:	CAMN	%0,(%1)	;DO WE HAVE A MATCH
	POPJ	P,	;YES
	AOJ	%1,	;NO - INCREMENT POINTER AND KEEP LOOKING
	SOJG	%3,SEE1	;HAVE WE LOOKED AT ALL THE FILES?
	JRST	SPOP	;YES
;FIND THE HIGHEST JOB IN THE DECTAPE DIRECTORY, SO WE CAN USE IT TO FILL IN HOLES
DECN:
	MOVE	%1,IO	;GET JOB TYPE (%IJOB OR OJOB)
	AND	%1,[XWD -1,770000]	;MASK OUT LAST TWO LETTERS
	HRRZ	%2,OUTIN+1	;GET ADRESS OF BUFFER
	ADDI	%2,^D83	 FIRST 83 WORDS
	MOVEI	%3,^D22	;FILE COUNT
	SETZ	%4,	;HIGHEST JOB NAME WILL BE RETURNED IN 4
	TLO	%4,400000	;MAKE IT VERY NEGATIVE
DECN1:	MOVE	%5,%1	;GET MASK
	XOR	%5,(%2)	;XOR WITH CURRENT FILE NAME
	LSH	%5,-^D12	;SHIFT TO IGNORE LAST TWO LETTERS
	JUMPN	%5,DECN2	;IF RESULT IS ZERO, THEN IT IS OUR TYPE
	CAMG	%4,(%2)	;IS IT HIGHER THAT CURRENT FILE?
;NOTE SINCE SIXBIT FOR IJOB AND OJOB SETS THE LEFT MOST BIT THEY ACTUALLY ARE NEGATIVE NUMBERS
;HOWEVER, IJOB04 IS HIGHER THAN IJOB01
	MOVE	%4,(%2)	;MAKE IT HIGHEST JOB SO FAR
DECN2:	AOJ	%2,	;INCREMENT POINTED	 TO FILE NAME
	SOJG	%3,DECN1	;ARE WE ALL THROUGH
	POPJ	P,	;YES
SS:
	MOVE	%13,PJG
	CAMN	%13,[1000003]
	SETOM	TEMPA
	TRNE	%16,20	;SELECTIVELY DELETING?
	JRST	SDEL	;YES
	SETZM	OUTDIR+3	;DEFAULT OUTPUT FOR DISK IS USERS AREA
	PUSHJ	P,NAMEA	;GET INPUT DEVICE NAME
	SETZM	SAVC
	CAIN	ACDEV,0	;MUST SPECIFY A DEVICE
	JRST	CMERR
	MOVEM	ACDEV,INDEV	;PUT SIXBIT NAME IN FOR INITIALIZATION
	PUSHJ	P,IN	;INITIALIZE INPUT DEVICE
	MOVE	%13,INCHR	;GET CHARACTERISTICS OF INPUT DEVICE
	TLNN	%13,4	;DOES IT HAVE A DIRECTORY
	JRST	START	;NO - DON'T BOTHER
	PUSHJ	P,SS3	;GO AND LIST UNTIL USER RESPONDS WITH A "Y"
	JRST	START	;HE NEVER RESPONDED
	MOVE	%13,OUTCHR	;GET CHARACTERISTICS OF OUTPUT DEVICE
	TLNN	%13,1	;IT BETTER BE ABLE TO DO OUTPUT
	JRST	CMERR
SS4:	MOVE	%13,OUTCHR	;IS OUTPUT DEVICE TTY
	TLNE	%13,10
	PUSHJ	P,OUT	;REINITIALIZE TTY
	PUSHJ	P,OUTLOK	;YES - CREAT AN OUTPUT NAME AND ENTER IT
	OUTPUT	IN2,
	MOVE	%12,@IND
	LOOKUP	IN1,INDIR	;SINCE WE HAVE READ THE FIRST LINE WE MUST REOPEN THE FILE
	HALT	.
	INPUT 	%1,
	MOVE	%11,INBUF+1	;GET INPUT POINTER
	TLO	%16,4	;THIS MEANS DON'T INSERT $EOF
	PUSHJ	P,SWAP	;MOVE OUT FILE
	MOVEM	%12,OUTBUF+1	;PUT POINTER BACK
	CLOSE	IN2,	;AND OUTPUT FILE
	PUSHJ	P,SS2	;KEEP LISTING
	JRST	START	;NO MORE
	JRST	SS5
SS3:
	TLNE	%16,2
	SETZM	TEMPA
	JRST	SS5
SS2:	MOVE	C,SAVC
	CAIN	C,CR
	POPJ	P,
SS5:	PUSHJ	P,NAME1
	MOVEM	C,SAVC
	MOVEM	ACFILE,INDIR
	MOVE	%13,INPJG
	MOVEM	%13,INDIR+3
	LOOKUP	IN1,INDIR	;WHEN ITS NOT THERE, WE ARETHROUGH LISTING
	POPJ	P,
	SKIPN	TEMPA	;ARE WE IN BATCH AREA
	JRST	.+3	;NO
	PUSHJ	P,READL	;YES - DOES HE HAVE ACCESS TO THIS FILE
	JRST	SS2	;NO
	PUSHJ	P,COMP
	CAIE	C,"Y"	;DID HE TYPE "Y"?
	JRST	SS2	;NO
	JRST	SPOP	;YES GO BACK AND PERFORM REQUIRED OPERATION
COMP:	MOVEI	%13,OBUF+1	;NOW LIST TO TTY, WE MUST OPEN ANOTHER CHANNEL
	MOVEM	%13,IND	;INDIRECTS WILL BE DONE THROUGH HERE
	MOVEI	%13,OBUF+2
	MOVEM	%13,IND+1
	INIT	3,0	;OPEN UP TTY
	SIXBIT/TTY/
	XWD	OBUF,0
	JRST	.
	OUTPUT	3,
	MOVE	%12,OBUF+1	;GET POINTER
	MOVE	%14,[OUTPUT %3,]	;WE WANT TO OUTPUT UNDER DIFFERENT CHANNEL
	EXCH	%14,GETOUT+1	;THIS IS ONLY A TEMPORARY CHANGE
	PUSHJ	P,LOUT	;LIST JOB NUMBER
	PUSHJ	P,LIST3	;LIST FIRST LINE
	PUSHJ	P,CRF	;STICK IN A CR,LF
	MOVEM	%12,OBUF+1	;PUT POINTER BACK IN HEADER
	RELEASE	 %3,	;AND OUTPUT TO USER
	MOVEI	%13,OUTBUF+1	;NOW RESET THE OUTPUT ROUTINES
	MOVEM	%13,IND
	MOVEI	%13,OUTBUF+2
	MOVEM	%13,IND+1
	EXCH	%14,GETOUT+1	;NOW ITS SET TO OUTPUT ON CHANNEL 2
	PUSHJ	P,INITTY	;INITIALIZE TTY YO GET USER'S RESPONSE
	INPUT	0,	;GET HIS MESSAGE
	PUSHJ	P,TTYIN	;GET USER'R RESPONSE
	RELEASE %0,
	POPJ	P,
;SELECTIVELY DELETE
SDEL:
	PUSHJ	P,HIGST	;GET NAME OF HIGHEST JOB
	MOVE	%13,OUTDIR	;THIS IS FIRST ONE TO FAIL
	MOVEM	%13,HIGJOB	;SAVE FOR FUTURE
	RELEASE	IN2,	;WE DON'T NEED CHANNEL 2
	MOVE	%13,OUTDEV	;WE MUST OPEN UP CHANNEL ONE SINCE ALL DELETE ROUTINES USE IT
	MOVEM	%13,INDEV
	MOVE	%13,OUTDIR+3
	MOVEM	%13,INDIR+3
	PUSHJ	P,IN	;OPEN CHANNEL ONE
	PUSHJ	P,SETIO	;SET JOB TYPE
	MOVE	%13,OUTCHR	;GET OUTPUT DEVICE CHARACTERISTICS
	TLNN	%13,4	;DOES IT HAVE A DIRECTORY?
	JRST	START	;NO - THEN FORGET IT
	PUSH	P,[OCT -1]	;THIS IS A MARKER FOR PUSH DOWN LIST
	TLNN	%13,200000;DISK?
	JRST	SDEC	;NO DECTAPE
	PUSHJ	P,DS3	;GO AND LIST FIRST LINES
	JRST	START	;NEVER SAID YES
	PUSH	P,INDIR	;SAVE FILES TO BE DELETED
SDEL1:	PUSHJ	P,DS2	;KEEP LISTING
	JRST	SDEL2	;ALL THROUGH LISTING
	PUSH	P,INDIR	;SAVE FILE NAMES
	JRST	SDEL1	;KEEP LISTING
SDEL2:	POP	P,INDIR	;NOW GET THOSE NAMES BACK
	LOOKUP	IN1,INDIR	;OPEN THOSE FILES TO BE DELETED
	JRST	SDEL3	;TRIED TO OPEN ON -1
	CLOSE	1,	;CLOSE FOR RENAME
	SETZM	INDIR	;ZERO FOR DELETE
	RENAME	1,INDIR
	HALT	.
JRST	SDEL2
	;KEEP DELETING
SDEL3:	MOVE	13,IO
	CAME	13,[SIXBIT/IJOB01/]
	JRST	STAR
	RELEASE	1,
	PUSHJ	P,OUT		;NOW REINITIALIZE OUTPUT DEVICE
	JRST	DEN	;FILL IN THE HOLES IN DIRECTORY AND GO TO START
ASS3:
	TLNE	%16,2
	SETZM	TEMPA
	MOVE	%0,IO	;GET JOB TYPE
	SOJL	%0,.+2	;DECREMENT BECAUSE WE MUST IMMEDIATELY INCREMENT
ASS2:	MOVE	%0,INDIR	;GET CURRENT JOB
	PUSHJ	P,NEX	;INCREMENT IT
	MOVEM	%0,INDIR	;PUT IN DIRECTORY
	MOVE	%13,PJG
	MOVEM	%13,INDIR+3
	LOOKUP	IN1,INDIR	;WHEN ITS NOT THERE, WE ARETHROUGH LISTING
	POPJ	P,
	SKIPN	TEMPA	;ARE WE IN BATCH AREA
	JRST	.+3	;NO
	PUSHJ	P,READL	;YES - DOES HE HAVE ACCESS TO THIS FILE
	JRST	ASS2	;NO
	PUSHJ	P,COMP
	CAIE	C,"Y"	;DID HE TYPE "Y"?
	JRST	ASS2	;NO
	JRST	SPOP	;YES GO BACK AND PERFORM REQUIRED OPERATION
;SELECTIVELY DELETE FROM DECTAPE
SDEC:
	PUSHJ	P,DS3	;LIST FIRST LINES
	JRST	START	;NEVER SAW A "Y"
	PUSH	P,INDIR	;SAVE NAMES OF FILES TO BE DELETED
SDEC2:	PUSHJ	P,DS2	;KEEP LISTING
	JRST	SDEC1	;THROUGH LISTING
	PUSH	P,INDIR	;SAVE NAMES OF FOLES TO BE DELETED
	JRST	SDEC2	;KEEP LISTING
SDEC1:	PUSHJ	P,DDIN	;INITIALIZE FOR DIRECTORY READ IN
SDEC4:	POP	P,ACFILE	;GET THE NAME OF A FILE TO BE DELETED
	CAMN	ACFILE,[OCT -1]	;HAVE WE DELETED ALL FILES
	JRST	SDEC3	;YES
	PUSHJ	P,DELONE	;DELETE THAT FILE
	JRST	SDEC4	;AND GET ANOTHER FILE NAME
SDEC3:	MOVE	13,IO
	CAMN	13,[SIXBIT/IJOB01/]
	PUSHJ	P,UPDAT	;FILL IN HOLES IN DIRECTORY
	PUSHJ	P,DDO	;READ OUT DIRECTORY
	JRST	START	;ALL THROUGH

DS3:	MOVE	%13,IO
	CAME	%13,[SIXBIT/IJOB01/]
	JRST	SS3
	JRST	ASS3
DS2:	MOVE	%13,IO
	CAME	%13,[SIXBIT/IJOB01/]
	JRST	SS2
	JRST	ASS2
;OUTPUT THE NUMBER OF THE IJOB OR OJOB IN DECIMAL FORM
;THIS IS USED BY THE LISTING ROUTINE
LOUT:
	PUSHJ	P,CRF	;OUTPUT CR,LF
	MOVE	%2,[POINT 6,INDIR,23]	;GET POINTER TO FILE NAME NUMBERS
	ILDB	%7,%2	;GET TENS COMPONENT
	ADDI	%7,40	;MAKE ASCII
	CAIE	%7,"0"	;IS IT ZERO?
	PUSHJ	P,DEPIST	;NO - DEPOSIT
	ILDB	%7,%2	;GET DIGIT COMPONENT
	ADDI	%7,40	;MAKE ASCII
	PUSHJ	P,DEPIST	;DEPOSIT IT
	MOVEI	%7,"."	;ADD "." TO MAKE IT NEAT
	PUSHJ	P,DEPIST
	MOVEI	%7,TAB	;AND A TAB
	PUSHJ	P,DEPIST
	POPJ	P,	;ALL THROUGH


;OUTPUT A CR,LF TO USERS FILE
CRF:
	MOVEI	%7,CR
	PUSHJ	P,DEPIST
	MOVEI	%7,LF
	PUSHJ	P,DEPIST
	POPJ	P,

DEFLT:	TRNE	%16,4
	SKIPA	%13,[SIXBIT/TTY/]
	MOVSI	%13,(SIXBIT/DSK/)
	MOVEM	%13,OUTDEV
	TRNE	%16,4
	SKIPA	%13,[ASCIZ/TTY/]
	MOVE	%13,[ASCIZ/DSK/]
	MOVEM	AZD
	JRST	COM1


CMERR:	MOVEI	%11,[ASCIZ/?COMMAND ERROR/]
	PUSHJ	P,TYPMSG
	JRST	CARR



;DEFAULT AREA FOR DISK SPECIFICATION
D13:	MOVE	%13,[1000003]
	MOVEM	%13,INDIR+3
	MOVEM	%13,OUTDIR+3
	MOVEM	%13,PJG
	MOVEM	%13,INPJG
	POPJ	P,


MOVE:	PUSHJ	P,OUTLOK	;GENERATE OUTPUT FILE

	PUSHJ	P,GETCH	;GET A CHARACTER
MOVE2:	CAIE	%7,"$"	;IS IT "$"
	JRST	ERJOB	;NO - NO JOB CARD
	PUSHJ	P,JOB	;YES - BUT SEE IF ITS "$JOB
MOVE1:	PUSHJ	P,GETCH	;GET ANOTHER CHARACTER
	CAIN	%7,"$"
	JRST	DOLLAR	;THIS REQUIRES FURTHER ANALYSIS
	TLZ	%16,4	;ZERO $EOF FLAG
	PUSHJ	P,DEPIST	;DEPOSIT THAT CHARACTER
	JRST	MOVE1	;AND KEEP GOING


;GET A CHARACTER FROM INPUT FILE
GETCH:	SOSGE	INBUF+2
	JRST	GETIN
	ILDB	%7,%11
	CAIN	%7,0
	JRST	GETCH
	CAIN	%7,32
	JRST	EOFD	;ANOTHER FORM OF END OF FILE
	POPJ	P,

;DEPOSIT THAT CHARACTER
DEPIST:	SOSGE	@IND+1
	JRST	GETOUT
	IDPB	%7,%12
	POPJ	P,


;"$" HAS BEEN SEEN
DOLLAR:
	PUSHJ	P,ESET	;SAVE THE NEXT THREE LETTERS
	CAIE	%1,"O"	;SECOND LETTER MUST BE "O"
	JRST	DOL2	;IT WASN'T, THEN IT MUST BE COMMENT
	CAIE	%0,"E"	;WAS IT $EOJ" OR "EOF"
	JRST	DOL	;NO
	CAIE	%7,"F"
	JRST	DOL1	;THEN IT COULD ONLY HAVE BEEN EOJ
	TLO	%16,4	;NO $EOF INSERTED
	JSR	WOR
	JRST	MOVE1+1	;AND LOOK FOR JOB CARD
DOL2:	JSR	WOR	;TYPE OUT LINE AND CONTINUE
	JRST	MOVE1+1
DOL1:	CAIE	%7,"J"	;WAS IT $EOJ
	JRST	DOL2	;NO - THEN IT WAS A COMMENT
	TLO	%16,100
	TLO	%16,40
	TLO	%16,4	;TURN OFF INSERT $EOF FLAG
	JSR	WOR	;TYPE OUT LINE
	TLO	%16,4
RR:	TLZ	%16,40
	CAIN	%7,"$"
	TLO	%16,60000
	TLO	16,600
	POPJ	P,
DOL:	CAIE	%0,"J"	;WAS IT $JOB?
	JRST	DOL2	;NO - THEN ONLY COMMENT
	CAIE	%7,"B"
	JRST	DOL2
	TLNN	%16,4	;INSERT $EOF IF IT WAS NOT THERE
	PUSHJ	P,INSERT
	TLZ	%16,40
	TLZ	%16,4	;NEW JOB CARD REQUIRE NEW"EOF"
	JRST	DOL2

;"$" HAS BEEN SEEN, SAVE NEXT THREE LETTERS
ESET:
	PUSHJ	P,GETCH
	MOVEM	%7,E1
	PUSHJ	P,GETCH
	MOVEM	%7,E2
	PUSHJ	P,GETCH
	MOVEM	%7,E3
	MOVE	%0,E1
	MOVE	%1,E2
	POPJ	P,

WOR:	0		;OUTPUT REST OF LINE
	PUSHJ	P,ETYP	;OUTPUT THOSE THREE LETTERS
	PUSHJ	P,LIST3	;AND REST OF LINE
WOR1:	PUSHJ	P,DEPIST	;THIS IS CR
	PUSHJ	P,GETCH
	CAIE	%7,CR
	CAIN	%7,LF
	JRST	WOR1
	CAIN	%7,FF
	JRST	WOR1
	JRST	@WOR
;A JOB CARD IS REQUIRED AT THIS POINT
;IF IT IS THERE PRINT IT AND RETURN, OTHERWISE INDICATE AN ERROR
CH:
	MOVE	%13,OUTCHR
	TLNN	%16,200000	;DISK?
	POPJ	P,	;NO
	MOVE	%13,OUTDIR+3	;GET PJ-PG NUMBER
	CAME	%13,[1000003]
	POPJ	P,	;NOT BATCH AREA
	MOVE	%0,OUTDIR	;GET NAME OF FILE JUST CLOSED
	PUSHJ	P,NEX	;INCREMENT IT
	MOVEM	%0,HIGJOB
	JRST	DEN	;AND CLEAN UP ANY HOLES
JOB:
	PUSHJ	P,ESET	;SAVE THREE LETTERS
	CAIE	%0,"J"
	JRST	ERJOB
	CAIE	%1,"O"
	JRST	ERJOB
	CAIE	%7,"B"
	JRST	ERJOB
	PUSHJ	P,ETYP	;OUTPUT THOSE THREE LETTERS AND RETURN
	POPJ	P,
GETOUT:	MOVEM	%12,@IND
	OUTPUT	IN2,
	MOVE	%12,@IND
	JRST	DEPIST

GETIN:	INPUT	IN1,
	MOVE	%11,INBUF+1
	MOVEM	%11,TEMP
	MOVE	%15,INBUF+2
	STATO	IN1,762000
	JRST	GETCH
	STATO	IN1,742000
	JRST	EOFD
	JRST .

	DEFINE DE(A)
<	MOVEI	%7,"A"
	PUSHJ	P,DEPIST
		>

INSERT:
	DE($)
	DE(E)
	DE(O)
	DE(F)
	PUSHJ	P,CRF
	POPJ	P,


ETYP:
	MOVEI	%7,"$"
	PUSHJ	P,DEPIST
	SETZ	%1,
ETYP1:	MOVE	%7,E1(%1)
	PUSHJ	P,DEPIST
	AOJ	%1,
	CAIGE	%1,3
	JRST	ETYP1
	POPJ	P,
CTLSET:
	PUSHJ	P,INITTY	;INITIALIZE TTY
	PUSHJ	P,CRLF		;OUTPUT CARRIAGE RETURN - LINE FEED
	MOVEI	%0,"*"	;TELL USER WE ARE READY FOR COMMAND
	IDPB	%0,CTOBUF+1
	OUTPUT	CTL,	;OUT GOES THE "*"
	INPUT	CTL,	;HERE COMES THE COMMAND STRING
	POPJ	P,





EOFD:
	TLNN	%16,40
	JRST	EO1
	PUSHJ	P,CLOSE1
	MOVE	C,SAVC
	CAIE	C,CR
	JRST	EOFD1
	JRST	START

EO1:	TRNN	%16,1
	JRST	.+4

	MOVE	C,SAVC	;GET LAST COMMAND STRING DELIMITER
	CAIE	C,15	;WAS IT A CR?
	JRST	EOFD1	;NO - GO BACK AND CONTINUE INTREPING COMMAND STRING
	PUSHJ	P,CLOSE
	PUSHJ	P,CH
	TRNN 	%16,1	;TEST FOR /O
	JRST	OTEST	;IT IS /O
	JRST	STAR	;ALL THROUGH
OTEST:	MOVE	C,SAVC
	CAIE	C,15
	JRST	EOFD1
	JRST	STAR


EOFD1:		;THIS IS A SIMPLE ROUTINE TO ALLOW ONE TO
		;POP UP TWO LEVELS

	SUB	P,[1000001]
	POPJ	P,





CLOSE:
	TLNN	%16,4	;SHOULD WE PUT IN $EOF IF NONE PRESENT
	PUSHJ	P,INSERT	;YES
	TLZ	%16,4	;ZERO THHAT FLAG FOR NEXT TIME
CLOSE1:	MOVEM	%12,OUTBUF+1	;PUT POINTER BACK FOR PROPER OUTPUT
	CLOSE	IN2,
	POPJ	P,
CRLF:	MOVEI	%10,15	;OUTPUT A CARRIAGE RETURN-LINE FEED
	PUSHJ	P,TYO
	MOVEI	%10,12	;NOW THE LINE FEED

TYO:	SOSG	CTOBUF+2	;DECREMENT BUFFER COUNT
	OUTPUT	CTL,	;BUFFER WAS EMPTY
DEP:	IDPB	%10,CTOBUF+1	;DEPOSIT CHAR.
	CAIE	C,FF	;IS CHAR. A FORM FEED
	POPJ	P,

;ROUTINES FOR OUTPUTING ERROR MESSAGESERROUT:
TYPMSG:	PUSHJ P,INITTY	;INTIALIZE TTY
	PUSHJ	P,CRLF	;OUTPUT A CARRIAGE RETURN
	TLOA	%11,(POINT 7,,)	;THIS IS POINTER FOR ERROR MESSAGE
TYPMS1:	PUSHJ	P,TYO	;OUTPUT CHAR.
	ILDB	%10,11	;LOAD A CHAR. FROM ERROR MESSAGE
	JUMPN	%10,TYPMS1	;ALL ERROR MESSAGES END WITH A ZERO
	OUTPUT	CTL,
	POPJ	P,	;THROUGH WITH ERROR MESSAGE

CARR:	PUSHJ	P,CRLF	;COMMON EXIT FOR ERROR MESSAGES
	PUSHJ	P,CRLF
	JRST	START	;GO TO VERY BEGINNING

;INITIALIZE TTY FOR ERROR MESSAGES
INITTY:	CLOSE CTL,
	RELEAS CTL,
ITD:	INIT CTL,1
	SIXBIT /TTY/
	XWD CTOBUF,CTIBUF
	HALT
	INBUF CTL,1
	OUTBUF CTL,1
	OUTPUT CTL,
	POPJ P,
;INPUT ERROR FILE NOT FOUND
ERIN:
	MOVEI	%11,[ASCIZ/?INPUT ERROR.../]
	PUSHJ	P,TYPMSG
	SETZM	AZDEV
	MOVEI	%11,AZFIL
	PUSHJ	P,TYPMS1-1
	SKIPN	AZEXT
	JRST	ERIN1
	MOVEI	%10,"."
	XCT	DEP	;THIS WILL DEPOSIT IT
	MOVEI	%11,AZEXT
	PUSHJ	P,TYPMS1-1
ERIN1:	MOVEI	%11,[ASCIZ/ FILE NOT FOUND/]
	PUSHJ	P,TYPMS1-1
	JRST	CARR


;DEVICE NOT AVAILABLE
ERDEV:
	MOVEI	%11,[ASCIZ/?DEVICE /]
	PUSHJ	P,TYPMSG
	SETZM	AZEXT
	MOVEI	%11,AZDEV
	PUSHJ	P,TYPMS1-1
	MOVEI	%11,[ASCIZ/ NOT AVAILABLE/]
	PUSHJ	P,TYPMS1-1
	JRST	CARR	;PUT IN CR,LF ARE GO TO START


;OUTPUT DEVICE NOT AVAILABLE, PUT ASCII OUTPUT NAME IN PROPER STORAGE
;AND THEN PRETEND IT WAS AN INPUT DEVICE
OUTER:
	MOVE	%11,AZD
	MOVEM	%11,AZDEV
	MOVE	%13,AZD+1
	MOVEM	%13,AZDEV+1
	JRST	ERDEV
;AN ERROR RESULTS IF THE FIRST FOUR CHARACTERS IN EVERY JOB ARE "$JOB"
ERJOB:
	MOVEI	%11,[ASCIZ/?NO JOB CARD/]
	PUSHJ	P,TYPMSG
	JRST	CARR
TRMERR:	MOVEI	%11,[ASCIZ/?TRANSMISSION ERROR/]
	PUSHJ	P,TYPMSG
	JRST	CARR



;THE USER HAS TRIED TO OUTPUT OR DELETE A FILE FROM THE BATCH AREA THAT BELONGS TO SOMEONE ELSE
NOTYOU:
	TRNE	%16,40
	JRST	SPOP
	PUSH	P,%11	;SAV AC11
	MOVEI	%11,AZFIL	;GET ADRESS OF ASCII FILE NAME
	PUSHJ	P,TYPMSG	;OUTPUT TO TTY
	MOVEI	%11,[ASCIZ/ NOT YOUR FILE
/]
	PUSHJ	P,TYPMS1-1
	POP	P,%11
	JRST	SPOP
;THE FOLLOWING CODE IS THE COMMAND STRING DECODER
NAMEA:	PUSHJ	P,SETIO	;SET JOB TYPE
NAME1:	SETZB	ACDEV,AZDEV	;ZERO THE REGISTERS WHICH WILL RETURN THE NAMES
	SETZB	ACDEL,AZEXT
	SETZM	AZTEM+1
	SETZB	ACFILE,AZTEM
	SETZB	ACEXT,AZFIL
	SETO	%14,
	TRNE	%16,10
	PUSHJ	P,ATEST
	TRNN	%16,4	;IS /L SWITCH SET
	TRNE	%16,40	;IS /A SWITCH SET?
	PUSHJ	P,ATEST	;YES 
	SKIPE	FLG
	PUSHJ	P,SCAN	;SCAN TO SEE IF A PJ-PG NUMBER IS IN STRING
NAME3:	MOVE	%15,[POINT 7,AZTEM-1,35]	;THIS IS A POINTER FOR DEPOSITING THE 
		;ASCII CHARACTERS IN CASE AN INPUT
		;ERROR IS DETECTED--FOR THEN WE WILL 
		;HAVE TO PRINT THESE NAMES OUT
	MOVSI	ACPNTR,(POINT 6,0)	;SET POINTER
	SETZ	%13,
	MOVEI	%0,0	;THE SIXBIT NAME WILL BE STORED IN THE AC0

GETIOC:	PUSHJ	P,TTYIN	;GET INPUT CHARACTER
	CAIG	C,12
	JRST	OVER
	CAIN	C,":"	;HAVE WE BEEN GETTING A DEVICE NAME
	JRST	DEVICE	;YES
	CAIN	C,"."	;OR A FILE NAME
	JRST	NAME	;YES
	CAIN	C,","	;THIS IS ANOTHER WAY TO GET A FILE NAME
	JRST	TERM
	CAIE	C,"_"	;ONE KIND OF SEPERATOR
	CAIG	C,15	;THIS ALSO MEANS WE AHVE FINISHED A TERM
	JRST	TERM	;TERM HAS BEEN READ
	CAIN	C,LF
	POPJ	P,
	CAIE	C,"("
	CAIN	C,"/"	;IS THERE A SWITCH?
	JRST	GETSW	;YES
	CAIE	C,"["	;IS THERE A PJ-PG NUMBER
	JRST	GET2	;NO
	SKIPE	FLG	;BUT IF ITS ON THE LEFT OF "_", WE HAVE ALREADY SEEN IT
	PUSHJ	P,ARR	;THIS WILL GET AROUND IT
	PUSHJ	P,PNUM	;ANALYSIS PJ-PG NUMBER
	JRST	GETIOC	;ARR RETURNS HERE
GET2:	SUBI	C,40		;CONVERT TO 6-BIT
	TLNE	ACPNTR,770000	;HAVE WE STORED SIX BYTES?
	IDPB	C,ACPNTR	;NO, STORE IT
	ADDI	C,40	;CONVERT BACK TO ASCII FOR ERROR MESSAGES
	IDPB	C,%15	;STORE IN AC13
	JRST	GETIOC	;GET ANOTHER CHAR.		;GET NEXT CHARACTER
;SCANN THE RIGHT OF "_" TO SEE IF A PJ-PG NUMBER IS PRESENT
SCAN:
	SKIPE	SCANN	;FORGET IT IF WE HAVE ALREADY BEEN HERE
	POPJ	P,
	SETOM	SCANN	;MAKE SURE WE COME HERE ONLY ONCE
	MOVE	%13,CTIBUF+1	;SAVE POINTER FOR COMMAND STRING
SCAN1:	PUSHJ	P,TTYIN	;GET A CHARACTER FROM COMMAND STRING
	CAIE	C,"["	;HAVE WE SEEN SOMETHING
	JRST	SCAN2	;NO - SEE IF WE ARE TO END OF STRING
	PUSHJ	P,PNUM	;A PJ-PG NUMBER IS PRESENT - ANALYIZE IT
	JRST	SCAN3	;ALL THROUGH
SCAN2:	CAIE	C,CR	;ARE WE AT END OF COMMAND STRING
	JRST	SCAN1	;NO KEEP GOING
SCAN3:	MOVEM	%13,CTIBUF+1	;ALL THROUGH - PUT POINTER BACK
	POPJ	P,


OVER:	MOVEI	C,CR
	POPJ	P,


ARR:
	PUSHJ	P,TTYIN	;GET A CHARACTER
	CAIN	C,"]"	;HAVE WE COME TO END OF PJ-PG NUMBER
	JRST	SPOP	;YES - WE HAVE SKIPPED OVER IT
	CAIE	C,CR	;NO - DON'T LET THEM TRY TO FOOL US BY LEAVING THE "]" OUT
	JRST	ARR	;KEEP SKIPPING
	JRST	CMERR


;THE /A SWITCH IS PRESENT
;WHEN THE /A SWITCH IS SEEN THE DIRECTORY OF THE DISK OR DTA
;IS READ INTO CORE AND A SEARCH IS MADE TO SEE WHICH JOBS ARE
;PRESENT. THERE IS A THREE WORD TABLE (TBL), IF A JOB IS PRESENT
;THE CORRESPONDING BIT IS SET IN THE TABLE
ATEST:
	SKIPN	FLG	;ARE WE TO RIGHT OF "_"
	POPJ	P,	;NO
	AOS	ADEV
	MOVE	%7,ADEV	;HAVE WE BEEN HERE BEFORE
	CAILE	%7,1
	JRST	.+3
	TRNN	%16,20
	POPJ	P,
	CAIL	%7,3
	JRST	ATEST1	;NORMALLY WE WILL BRANCH HERE
	TRNE	%16,20	;BUT FIRST WE MUST DO SOME INITIALIZING
	AOS	ADEV
	MOVE	%7,IO	;SET JOB TYPE
	SOJ	%7,
	MOVEM	%7,AAA	;THIS WILL HOLD CURRENT FILE
	MOVEI	%13,TBL
	MOVEM	%13,TN
	SETZM	WC
	MOVE	%13,INCHR
	TLNN	%13,200000	;IS IT THE DISK?
	JRST	ADTA
	INIT	0,14
	SIXBIT/SYS/
	XWD 0,ABUF
	JRST	ERDEV
	INPUT	0,
	MOVE	%13,INPJG
	TRNN	%16,20
	JRST	AT6
	MOVE	%13,PJG
	JUMPN	%13,AT3
AT6:	JUMPN	%13,AT3
	PUSHJ	P,PJPG
	MOVE	%13,PG
	HRL	%13,PJ
AT3:	MOVEM	%13,ADIR
	MOVSI	%13,(SIXBIT/UFD/)
	MOVEM	%13,ADIR+1
	LOOKUP	IN0,ADIR
	HALT	.
	INPUT	0,
AT1:	PUSHJ	P,GETN	;GO GET THE FIRST FILE PRESENT
	SKIPN	%13	;IF NO FILE, 13=0
	JRST	AT2
	MOVE	%1,AAA
	LSH	%1,-^D12
	LSHC	%13,-^D12
	CAME	%13,%1	;MASK TO SEE IF IN FORM OF OJOBXX OR IJOBXX
	JRST	AT1	;KEEP SETTING BITS UNTIL NO MORE FILES
	LSHC	%13,^D12
	PUSHJ	P,SETN	;THIS ROUTINE WILL SET THE BIT
	JRST	AT1
AT2:	PUSHJ	P,GETF	;THIS ROUTINE LOOKS AT THE BIT TABLE AND RETURNS NAME OF NEXT FILE
	CAIN	%13,0	;IF NONE THERE AT ALL FORGET IT
	JRST	STAR
	MOVEM	%13,NEXF	;NEXF CONTAINS NAME OF NEXT FILE
ATEST1:	PUSHJ	P,GETF	;GET ANOTHER FILE
	CAIN	%13,0
	JRST	LST	;WE MUST DO THIS LOOK AHEAD BECAUSE WHEN WE RETURN WITH
	EXCH	%13,NEXF	;LAST FILE, WE MUST THROW A CR IN AS THE DELIMITER
	MOVEI	C,","
LST1:	MOVE	ACFILE,%13
	JRST	EOFD1	;JUMP UP TWO LEVELS
LST:	MOVE	%13,NEXF	;WE ARE HERE FOR THE LAST TIME
	MOVEI	C,CR
	JRST	LST1
;THIS IS ROUTINE TO READ IN DIRECTORY OF DECTAPE
ADTA:	MOVE	%13,INDEV
	MOVEM	%13,.+2
	INIT	1,14
	Z
	XWD	%0,ABUF
	JRST	ERDEV
	USETI	%1,144
	INPUT	1,
	HRRZ	%2,ABUF+1
	ADDI	%2,^D83
	MOVEI	%1,^D22
ADTA1:	MOVE	%13,(%2)
	MOVE	%11,AAA
	LSH	%11,-^D12
	LSHC	%13,-^D12
	CAME	%13,%11
	JRST	ADTA3
	LSHC	%13,^D12
	JRST	ADTA2
ADTA3:	AOJ	%2,
	SOJG	%1,ADTA1
	PUSHJ	P,IN
	JRST	AT2
ADTA2:	HLRZ	%14,26(%2)
	CAIE	%14,0
	JRST	ADTA3
	PUSHJ	P,SETN
	JRST	ADTA3
GETN:
	PUSHJ	P,GETN1
	MOVE	%13,14
	PUSHJ	P,GETN1
	LSH	%14,-^D18
	JUMPN	%14,GETN
	POPJ	P,
GETN1:	SOSGE	ABUF+2
	JRST	GETN2
	ILDB	%14,ABUF+1
	POPJ	P,
GETN2:	INPUT	1,
	STATO	%1,762000
	JRST	GETN1
	HALT	.
	JRST	TRMERR


;THIS ROUTINE LOKOKS AT THE BIT TABLE AND RETURNS THE NEXT FILE
GETF:
	MOVE	%13,TN	;THIS IS POINTER TO WORD IN THE TABLE
	MOVE	%14,WC	;THIS IS POINTER TO BIT
	CAIGE	%13,TBL+2	;WE DON'T WANT TO LOOK PAST THE TABLE
	JRST	GETF2
	CAILE	%14,32
	JRST	LAST		;WE HAVE LOOKED AT THE WHOLE TABLE
GETF2:	MOVE	%0,(%13)	;GET THE WORD OF THE TABLE
	LSH	%0,(%14)	;MAKE IT SO THAT THE BIT WE ARE LOOKING AT IS THA SIGN BIT
	TLNE	%0,400000	;IS IT SET?
	JRST	GETF1	;YRS
	AOS	%14,WC	;NO INCREMENT POINTER AND CONTINUE
	CAIGE	%14,^D36
	JRST	GETF2
	AOS	%13,TN	;MUST INCREMENT WORD POINTER
	CAIL	%13,TBL+3
	JRST	LAST
	SETZB	%14,WC
	JRST	GETF2
GETF1:	SUBI	%13,TBL	;NOW WE MUST FIGURE OUT WHICH JOB IT IS
	IMULI	%13,^D36	;NO. OF WORDS*^D36
	ADD	%13,%14	;ADD NO. OF BITS IN THAT WORD
	AOJ	%13,
	AOS	%14,WC
	CAIGE	%14,^D36
	JRST	GETF3
	SETZM	WC
	AOS	TN
GETF3:	SETZ	%14,
	IDIVI	%13,12	;NOW CONVERT TO DECIMAL
	LSH	%14,^D32
	LSH	%13,2
	LSHC	%13,4	;WE MUST DO SOME SHIFTING BECAUSE WE MUST AND THE TYPE
	TDO	%13,AAA	;OVER THE DECIMAL NUMBERS
	POPJ	P,	;RETURN WITH JOB NAME IN %13
LAST:	SETZ	%13,
	POPJ	P,
;THIS ROUTINE IS CALLED WITH A FILE NAME, EX. IJOB23
;IT CONVERTS THIS NAME TO A NUMBER AND SETS A BIT IN A TABLE
SETN:	TDZ	%13,AAA
	SETZ	%3,
	LSHC	%13,-4
	LSH	%14,-^D32
	LSH	%13,-2
	IMULI	%13,12
	ADD	%13,%14
	MOVEI	%14,TBL
SETN2:	CAIG	%13,^D35
	JRST	SETN1
	SUBI	%13,^D36
	AOJ	%14,
	JRST	SETN2
SETN1:	SOJ	%13,
	MOVE	%0,(%14)
	ROT	%0,(%13)
	TLO	%0,400000
	MOVN	%13,%13
	ROT	%0,(%13)
	MOVEM	%0,(%14)
	POPJ	P,
DEVICE:	MOVE	%13,AZTEM	;ASCII NAME WAS BEING STORED HERE
	MOVEM	%13,AZDEV	;STORE ASCII DEVICE NAME
	MOVE	%13,AZTEM+1	;IT COULD BE SIX ASCII CHARACTERS
	MOVEM	%13,AZDEV+1
	MOVE	ACDEV,0	;DEVICE NAME
NAME7:	MOVE	%13,CTIBUF+1	;SAVE COMMAND STRING POINTER
	PUSHJ	P,TTYIN	;GET A CHARACTER
	CAIN	C,"["	;IS THERE A PJ-PG NUMBER THROWN IN
	JRST	NAME4	;YES
	CAIE	C,"("	;HOW ABOUT A SWITCH
	CAIN	C,"/"	;THERE ARE TWO FORMS OF SWITCHES
	JRST	NAME5	;GO ANALYIZE SWITCH
	MOVEM	%13,CTIBUF+1	;IT OK TO RETURN
	JRST	NAME6
NAME5:	PUSHJ	P,GETSW3	;ANALYIZE SWITCH
	JRST	NAME7	;THERE STILL COULD BE A PJ-PG NUMBER
NAME4:	PUSH	P,%1	;DON'T LET THEM DESTROY THE DEVICE NAME
	SKIPE	FLG	;DON'T BOTHER WITH PJ-PG NUM IF ON RIGHT OF "_"
	PUSHJ	P,ARR	;SKIP AROUND IT
	PUSHJ	P,PNUM	;ANALYIZE THE PJ-PG NUMBER
	POP	P,%1	;GET DEVICE NAME BACK, ARR RETURNS HERE
	JRST	NAME7	;KEEP LOOKING IN COMMAND STRING
NAME6:	CAIE	C,CR	;UNLESS WE HAVE SEEN A CR, MAKE SURE IT APPEARS THAT WE HAVE SEEN A DEVICE
	MOVEI	C,":"
	POPJ	P,
NAME:	MOVE	ACFILE,0	;FILE NAME
	MOVE	%13,AZTEM	;GET ASCII FILE NAME
	MOVEM	%13,AZFIL	;STORE ASCII NAME
	MOVE	%13,AZTEM+1	;IT MAY BE SIX LETTERS
	MOVEM	%13,AZFIL+1
	MOVE	ACDEL,C		;SET DELIMITER
	SETZ	AZTEM
	SETZM	AZTEM+1
	JRST	NAME3		;GET NEXT SYMBOL

TERM:	CAIE	ACDEL,0		;IF NO PREVIOUS DELIMITOR, OR
	JRST TERM1
	MOVE	%13,AZTEM	;SET ASCII FILE NAME
	MOVEM	%13,AZFIL
	MOVE	%13,AZTEM+1
	MOVEM	%13,AZFIL+1
	MOVE	ACFILE,0	;SET FILE
TERM1:	CAIE	ACDEL,"."	;IF PERIOD,
	JRST	TERM2
	MOVE	%13,AZTEM
	MOVEM	%13,AZEXT	;STORE ASCII EXTENSION
	HLLZ	ACEXT,0	;SET EXTENSION
TERM2:	CAIN	ACFILE,0
	POPJ	P,		;EXIT
	TRNE	ACFILE,777777	;IF FILE NAME IS A SINGLE NUMBER, IT MUST BE EXPANDED TO A JOB NAME
	POPJ	P,	;SINCE NAME IS LEFT JUSTIFIED, IF WE GET HERE IT WASN'T A SINGLE NUMBER
	TLNE	ACFILE,77	;IF NUMBER, THESE BITS MUST ALSO BE ZERO
	POPJ	P,	;NORMAL NAME
	MOVEM	ACFILE,NEXF
	LSH	ACFILE,-^D24	;RIGHT JUSTIFY IT
	TRNN	ACFILE,77	;IF IT WAS A SINGLE NUMBER, MOVE IT SOME MORE
	LSH	ACFILE,-6
	PUSH	P,C	;SACE DELIMITER
	PUSHJ	P,SETIO	;SET JOB TYPE
	POP	P,C
	SOS	IO	;IO IS NOW EITHER IJOB00 OR OJOB00
	CAIL	ACFILE,21	;WE MUST STILL MAKE SURE IT IS A NUMBER
	CAILE	ACFILE,31
	JRST	TERM4	;ITS NOT A SINGLE DIGIT
	IOR	ACFILE,IO	;IT IS A SINGLE DIGIT, MAKE IT A JOB NUMBER
	JRST	TERM5
TERM4:	CAIL	ACFILE,2121	;IS IT A DOUBLE NUMBER
	CAILE	ACFILE,3131
	JRST	TERM6	;NO - JUST A SHORT NAME
	IOR	ACFILE,IO	;A DOUBLE DIGIT - EXPAND INTO JOB NAME
TERM5:	AOS	IO	;RESET JOB TYPE
	POPJ	P,
TERM6:	MOVE	ACFILE,NEXF
	JRST	TERM5

;COME HERE ONLY IF A SWITCH HAS BEEN DETECTED
GETSW:	PUSHJ	P,GETSW3	;ANALYIZE SWITCH 
	JRST	GETIOC	;CONTINUE SCANNING


GETSW3:	SKIPE	FLG
	JRST	GET	;SWITCHES MUST BE TO LEFT OF "_"
	CAIN	C,"("	;WHAT FORM OF SWITCH
	SETZ	%14,	;THIS WILL BE A TEMPORARY FLAG
	PUSHJ	P,TTYIN	;GET NEXT CHARACTER
GETSW1:	CAIE	C,"I"	;WAS IT AN I	
	JRST	O	;NO - TRY O
	TRNE	%16,1	;HAS I SWITCH BEEN SET
	JRST	CMERR	;YES - THEN COMMAND ERROR
	ADDI	%16,1	;NO - SET IT
	JRST	GETSW2	;CONTINUE LOOKING AT SWITCHES
;THE REST OF THE SWITCHES ARE ANALYIZED IN A SIMILAR MANNER

GET:	PUSHJ	P,TTYIN
	CAIE	C,"U"
	JRST	CMERR
	JRST	U	;ONLY "U" SWITCH ALLOWED TO RIGHT OF _


O:	CAIE	C,"O"
	JRST	L
	TRNE	%16,2
	JRST	CMERR
	ADDI	%16,2
	JRST	GETSW2
L:	CAIE	C,"L"
	JRST	S
	TRZ	%16,40
	TRNE	%16,34
	JRST	CMERR
	ADDI	%16,4
	JRST	GETSW2
S:	CAIE	C,"S"
	JRST	D
	TRZ	%16,40
	TRNE	%16,14
	JRST	CMERR
	ADDI	%16,10
	JRST	GETSW2
D:	CAIE	C,"D"
	JRST	U
	TRNE	%16,24
	JRST	CMERR
	ADDI	%16,20
	JRST	GETSW2
U:	CAIE	C,"U"
	JRST	A	;TRY A
	SKIPE	FLG
	JRST	U1
	SETZM	PJG
	SETZM	OUTDIR+3	;USER ARE FOR OUTPUT
	JRST	GETSW2
U1:	SETZM	INDIR+3
	SETZM	INPJG
	JRST	GETSW2
A:	TRNE	%16,54
	JRST	GETSW2
	ADDI	%16,40
	MOVE	%13,CTIBUF+1
A1:	PUSHJ	P,TTYIN
	CAIN	C,CR
	JRST	CMERR
	CAIE	C,"_"
	JRST	A1
	MOVEI	%7,2
A2:	PUSHJ	P,TTYIN	;FOR THE A SWITCH THERE CAN BE ONLY ONE INPUT DEVICE
	CAIN	C,":"
	SOJ	%7,
	SKIPN	%7
	JRST	CMERR	;TWO DEVICES WERE SEEN
	CAIE	C,CR
	JRST	A2
	MOVEM	%13,CTIBUF+1
GETSW2:	SKIPE	%14	;IF SWITCH WAS OF FORM /I, THEN WE ARE ALL THROUGH
	POPJ	P,
	SKIPE	FLG
	POPJ	P,	;IF WE ARE TO RIGHT OF "_" 
	PUSHJ	P,TTYIN
	CAIE	C,")"
	JRST	GETSW1	;GO ANALYIZE NEW SWITCH
	POPJ	P,

TTYIN:	ILDB	C,CTIBUF+1	;GET CHARACTER
	CAIE	C," "		;SKIP BLANKS
	CAIN	C,"	"	;AND TABS
	JRST	TTYIN
	POPJ	P,		;NO, EXIT
;ANALIZE PROJECT-PROGRAMMER NUMBER
PNUM:
	SKIPE	FLG	;SKIP IF ON LEFT OF "_"
	JRST	PNUM1
	TLOE	%16,1	;HAVE WE ALREADY SEEN A PJ-PG NUMBER ON THIS SIDE
	JRST	CMERR	;YES
	MOVEI	%1,OUTDIR+3	;SET UP SO THAT IT WILL BE PUT IN OUTPUT DIRECTORY
	MOVEM	%1,S1	;WILL INDIRECT THROUGH HERE
PNUM2:	SETZ	%1,
	PUSHJ	P,GETDIG	;GET A NUMBER
	CAIE	C,","	;MUST BE SEPERATED BY COMMA
	JRST	CMERR
	HRLM	@%1,S1	;PUT IN FORTH WORD OF PROPER DIRECTORY
	SETZ	%1,
	PUSHJ	P,GETDIG	;NOW GET SECOND NUMBER
	CAIE	C,"]"	;IS IT PROPER FORM
	JRST	CMERR	;NO
	HRRM	@%1,S1	;STORE IN RIGHT HALF
	SKIPN	FLG
	POPJ	P,	;ALL THROUGH
	MOVE	%13,@S1
	MOVEM	%13,PJG
	POPJ	P,


;PROJECT PROGRAMMER NUMBER SEEN TO RIGHT OF "_"
PNUM1:	TLOE	%16,2
	JRST	CMERR
	MOVEI	%1,INDIR+3
	MOVEM	%1,S1
	JRST	PNUM2


;GET A NUMBER FROM COMMAND STRING
;KEEP FORMING NUMBER UNTIL NON-DIGIT CHARACTER IS SEEN
;NUMBER IS RETURNED IN AC1
FGET:
	PUSHJ	P,GETCH
	CAIL	%7,60
	CAILE	%7,71	;IS THIS CHARACTER A DIGIT
	POPJ	P,	;NOW WE HAVE THE WHOLE NUMBER
	SUBI	%7,60	;MAKE BINARY
	LSH	%1,3	;MAKE ROOM FOR NEW DIGIT
	ADD	%1,%7	;KEEP FORMING NUMBER
	JRST	FGET	;GO GET NEXT CHAR.

GETDIG:
	PUSHJ	P,TTYIN
	CAIL	C,60
	CAILE	C,71
	POPJ	P,
	SUBI	C,60
	LSH	%1,3
	ADD	%1,C
	JRST	GETDIG

;FIND THE HIGEST IJOB OR OJOB
HIGST:
	SETZM	OUTDIR	;CLEAR OUTPUT DIRECTORY
	MOVE	%6,OUTDIR+3	;SAVE PROJ-PROG NUMBER
	MOVE	%0,IO	;GET CHARACTERISTIC NAME(%IJOB01 OR OJOB01)
HIGST3:	MOVE	%5,%0	;PUT CURRENT NAME IN AC5
	EXCH	%5,OUTDIR	;PUT CURRENT NAME IN DIRECTORY AND SAVE LAST NAME
	PUSHJ	P,LUP	;DO LOOKUP
HIGST2:	PUSHJ	P,NEX	;INCREMENT FILE NAME
	JRST HIGST3	;AND KEEP GOING


LUP:
	MOVEM	%6,OUTDIR+3	;PUT PROJ-PROG NUMBER BACK IN
	LOOKUP	IN2,OUTDIR	;IS THIS JOB THERRE
	JRST	.+2	;NO - SO WE HAVE FOUND THE HIGHEST
	POPJ	P,	;YES - GO BACK AND GET NEXT HIGHTEST JOB
	HRRZ	%1,OUTDIR+1	;WHY DID LOOKUP FAIL?
	CAIN	%1,3	;DID SOME ONE DO AN ENTER ON THAT FILE
	POPJ	P,	;YES - THEN THE FILE IS REALLY THERE
	CAIE	%5,0	;IF 5=%0, THEN FAILED ON FIRST LOOKUP
	JRST	EOFD1	;THIS WILL POP BACK TWO LEVELS
	MOVE	%5,IO	;DOCTOR AC5
	SOJ	%5,	;THIS IS FILE BEFORE FIRST FILE NOT FOUND
	JRST	EOFD1	;GO UP TWO LEVELS


SPOP:	AOS	(P)
	POPJ	P,
IN:		;INITIALIZE INPUT DEVICE
	INIT	IN1,0
INDEV:	Z	;INPUT DEVICE NAME WILL BE PUT HERE
	XWD	%0,INBUF
	JRST	ERDEV	;GENERATE "DEVICE NOT AVAILABLE" MESSAGE
	MOVE	%13,INDEV	;GET INPUT DEVICE NAME
	CALLI	%13,4	;GET ITS CHARACTERISTICS
	MOVEM	%13,INCHR	;STORE FOR FUTURE REFERENCE
	POPJ	P,


OUT:	OPEN	IN2,SPEC1	;INITIALIZE OUTPUT DEVICE
	JRST	OUTER	;OUTPUT DEVICE NOT AVAILABLE
	OUTPUT	IN2,	;DO DUMMY OUTPUT
	MOVE	%12,OUTBUF+1	;GET POINTER
	MOVE	%13,OUTDEV	;GET OUTPUT DEVICE NAME
	CALLI	%13,4	;GET IT GHARACTERISTICS
	MOVEM	%13,OUTCHR	;STORE FOR FUTURE REFERENCE
	POPJ	P,

SPEC1:	Z
OUTDEV:	BLOCK 1	;OUTPUT DEVICE NAME WILL PUT HERE
	XWD	OUTBUF,OUTIN


INLOK:	MOVE	%13,INPJG
	MOVEM	%13,INDIR+3
	LOOKUP	IN1,INDIR	;DO LOOKUP ON INPUT FILE
	JRST	ERIN
	MOVE	%13,INCHR	;GET INPUT DEVICE CHARACTERISTICS
	TLNN	%13,10	;IS INPUT FROM TTY:
	POPJ	P,	;NO - ALL THROUGH
	PUSH	P,%11
	MOVEI	%11,[ASCIZ/
TTY INPUT PLEASE:
/]
	PUSHJ	P,TYPMSG+1
	OUTPUT	0,
	POP	P,%11
	POPJ	P,


OUTLOK:	MOVE	%13,OUTCHR	;GET OUTPUT DEVICE CHARACTERISTICS
	TLNN	%13,4	;IS IT A DIRECTORY DEVICE?
	POPJ	P,
	MOVE	%13,PJG
	MOVEM	%13,OUTDIR+3
	PUSHJ	P,HIGST	;YES - GET NEXT UNUSED FILE NAME
	ENTER	IN2,OUTDIR	;AND ENTER IT
	JRST	ENTFAL
	POPJ	P,
ENTFAL:
	PUSHJ	P,ITD
	MOVE	%13,OUTDIR+3
	CAME	%13,[1000003]	;IN BATCH AREA?
	JRST	NBA	;NO
	HRRZ	%13,OUTDIR+1	;YES
	CAIE	%13,2
	CAIN	%13,1	;NO BATCH PJ-PG
	SKIPA	%11,[[ASCII/?NO BATCH AREA
/]]
NBA:	MOVEI	%11,[ASCII/?CANNOT ENTER FILE
/]
	PUSHJ	P,TYPMSG
	JRST	CARR


AZD:	BLOCK 2	;OUTPUT FILE NAME
TEMPA:	BLOCK 1
E1:	Z
E2:	Z
E3:	Z
AZTEM:	BLOCK 2
AZFIL:	BLOCK 2	;FOR ASCII FILE NAME
AZDEV:	BLOCK 2	;FOR ASCII DEVICE NAME
AZEXT:	BLOCK 1	;FOR ASCII EXTENSION

PSET:	BLOCK	30

CTIBUF:	BLOCK	3
CTOBUF:	BLOCK	3
INBUF:	BLOCK	3
OBUF:	BLOCK 3
IND:	XWD 0,OUTBUF+1
	XWD 0,OUTBUF+2
OUTBUF:	BLOCK	3
OUTIN:	BLOCK	3
INCHR:	BLOCK	1
OUTCHR:	BLOCK	1
IO:	BLOCK	1
SCANN:	Z
AAA:	BLOCK 1
ADEV:	Z
HIGJOB:	BLOCK 1
CPJG:	Z

S1:	Z
S2:	Z
S3:	Z
INPJG:	Z
PJ:	Z
PG:	Z
PJG:	Z
FLG:	BLOCK 1
SAVC:	Z
INDEV2:	BLOCK 1

INDIR:	BLOCK	4

NEW:	SIXBIT /DSK/
	BLOCK	2
	OCT 1000003
TN:	Z
WC:	Z
NEXF:	Z
TBL:	BLOCK 3
ABUF:	BLOCK	3
ADIR:	BLOCK 4
OUTDIR:	OCT 1000003
	SIXBIT/UFD/
	BLOCK	2





TEMP:	BLOCK	1



	END	STARTA
                                                                                                                                                                     .>,o