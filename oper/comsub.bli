
!**COPYRIGHT 1972,1973 DIGITAL EQUIPMENT CORPORATION, MAYNARD MA 01754**
!AUTHOR: NORMA ABEL/HPW
GLOBAL BIND COMSV=186;		!VERSION DATE: 24-JULY-1973

!***************************************************************
!	COMMON SUB EXPRESSION ELIMINATION MODULE.
!	LOCAL AND GLOBAL BOTH INCLUDED TOGETHER WITH
!	MOTION OF CONSTANT EXPRESSIONS OUT OF LOOPS IN THE GLOBAL CASE
!	THE LOCAL CONTROL ROUTINE IS LOCELIM.
!	THE GLOBAL CONTROL ROUTINE IS GLOBELIM.
!******************************************************************
!	NOTE:
!		THERE ARE TWO WAYS USED TO DISTINGUISH BETWEEN THE
!		LOCAL AND GLOBAL CASES.
!			1. BACKST=0; GLOBAL CASE
!			   BACKST#0; LOCAL CASE
!			2. FLGRG<OPTIMIZE>=1; GLOBAL CASE
!			   FLGRG<OPTIMIZE>=0; LOCAL CASE
!		TESTS ON THESE ARE MADE INTERCHANGABLY. THE
!		TWO WAYS ARE PRESENT FOR HISTORIC REASONS.

EXTERNAL CORMAN,LENTRY,QQ,TOP,BOTTOM,TPREV;
MAP PEXPRNODE LENTRY;
FORWARD TBLSRCH,DELETE,MAKETRY,GETOPTEMP,XPUNGE;
OWN P,PAE,PHI,PB,PA,PC,PO,T;
EXTERNAL LOCLNK;
OWN P1,LSTWARNLINE,P2,CNSTMOTFLG;
MAP PEXPRNODE P1:P2;
MAP PEXPRNODE P:PHI:PAE:PA:PB:PC:QQ:PO;
EXTERNAL MAKEPR;

MAP PHAZ2 TPREV;
FORWARD HASHIT,LOCLMOV,GLOBMOV,LOCLDEPD,GLOBDEPD;
OWN STHASCMN;		!USED BY LOCAL COMMONSUB EXPRESSIONS TO
			!TO SAVE A SCAN OF EHASH IF THE STATEMENT
			!WAS NOT EVEN ONE THAT POTENTAILLY HAD A
			!COMMON SUB-EXPRESSION (LIKE END).


OWN	TS,		!TEMP USED THROUGH OUT
	NAN,		!NEEDS A NEGATE USED TO HELP SEE
			!A-B AND B-A AND -A*B AND A*-B AS THE SAME
	VARHOLDER,	!USED IN SPECIAL LOCAL CASES SEE UNRYMATCHER
	NEDCOR;		!FLAG SET BY TBLSRCH TO INDICATE IF THE
			!HASH TABLE HAS A FREE REUSABLE SPACE OR
			!CORE IS NEEDED FOR THE ENTRY. 1=LATTER.

ROUTINE CMNMAK(PAE,NAN)=

BEGIN
	!CREATE A COMMON SUB-EXPRESSION NODE POINTING TO
	!THE EXPRESSION
	!A COMMON SUB-EXPRESSION NODE HAS
	!	OPRCLS - CMNSUB
	!	OPERSP - NULL
	!	A SINGLE ARGUMENT (ARG2PTR) POINTING TO
	!	THE EXPRESSION (OR SINGLE VARIABLE)

	MAP PEXPRNODE PAE;
	!THIS ROUTINE IS CALLED IN BOTH THE GLOBAL AND LOCAL CASES
	!THIS IS THE POINT AT WHICH THEY DIVERGE.
	!A POINTER TO A CMNSUB *EXPRESSION NODE* IS RETURNED IN THE LOCAL
	!CASE. A POINTER TO A TEMP IN THE GLOBAL CASE.
	!IN BOTH CASES PHI[TEMPER] IS SET CORRECTLY AND RETURNED.

	!IF THE FLAG NAN (NEEDS A NEGATE) IS SET, COMPLEMENT/RESET
	!THE NEGFLAGS IN THE EXPRESSION BEFORE IT BECOMES THE
	!COMMON SUBEXPRSSSION.

	IF .NAN THEN
	BEGIN
		!FOR AN ADD COMPLEMENT THE FLAGS
		IF .PAE[OPR1] EQL ADDOPF THEN
		BEGIN
			PAE[A1NEGFLG]_NOT .PAE[A1NEGFLG];
			PAE[A2NEGFLG]_NOT .PAE[A2NEGFLG];
		END ELSE
		IF .PAE[OPRCLS] EQL ARITHMETIC THEN
		!MULTIPLE, DIVIDE,EXPONENTIATE
		BEGIN
			PAE[A1NEGFLG]_0;
			PAE[A2NEGFLG]_0;
		END;
	END;

	IF NOT .FLGREG<OPTIMIZE> THEN
	BEGIN
		NAME<LEFT>_4;
		P_CORMAN();
		P[OPRCLS]_CMNSUB;
		P[ARG2PTR]_.PAE;
		IF .PAE[VALTYPE] NEQ CONTROL THEN
			P[VALTYPE]_.PAE[VALTYPE]
		ELSE
			P[VALTYPE]_LOGICAL;
		IF .PAE[OPRCLS] EQL DATAOPR THEN
		P[A2VALFLG]_1;
		PHI[TEMPER]_.P;
		!CALL ROUTINE THAT WILL ADD EXPRESSION TO LINKED LIST
		LOCLMOV(.P);


	END ELSE		!GLOBAL CASE
	BEGIN
		P_PHI[TEMPER]_GETOPTEMP(IF .PAE[VALTYPE] EQL CONTROL THEN
			 LOGICAL ELSE .PAE[VALTYPE]);
		P[IDADDR]_.PAE;
		!CALL ROUTINE THAT CREATS AND LINKS IN ASSIGNMENT STATEMENT
		GLOBMOV(.PAE,.PHI[STPT],.P);
	END;

	.PHI[TEMPER]
END;



ROUTINE STPRECLUDE(CNODE)=
BEGIN
	!PART OF THE COUNT HASSLE.
	!IF A COMMON - SUB EXPRESSION HAS JUST BEEN FOUND
	!THAT IS PART OF AN NARY STRUCTURE IT MAY HAVE TO BE DELETED.
	!FOR THE GLOABL CASE IT MUST BE DELETED TO PREVENT IT FROM
	!APPEARING TO BE A CONSTANT COMPUTATION. IN THE LOCAL CASE
	!IT MAY OCCUR WHEN AN NARY ENTRY HAS BEEN MADE WHILE WALKING ONE
	!TREE AND IT IS DISCOVERED THAT (WHILE WALKING ANOTHER TREE)
	!THE WHOLE THING COLLAPSES UPWARD AS A COMMON-SUB.

	MAP BASE QQ:TS:CNODE;

	QQ_.CNODE[PARENT];
	!SEE IF IT NARY

	IF (.QQ[OPR1] EQL .CNODE[OPR1]) AND  .QQ[A2VALFLG] THEN
	BEGIN
		!NOW ITS NARY CHECK FOR B OP B OP B
		IF (.CNODE[ARG1PTR] EQL .CNODE[ARG2PTR]) AND
		   (.CNODE[ARG2PTR] EQL .QQ[ARG2PTR]) THEN
			!GET THE #$$$() OUT
			RETURN;
		HASHIT(.QQ,SKEW);
		TS_TBLSRCH();
		!IF ITS THIS ONE (JUDGING BY SHAPE AND NOT
		!A COMMON SUB IN ITS OWN RIGHT ALREADY FOR OTHER
		!REASONS THEN DELETE IT
		IF .FLAG THEN
			IF .TS[TEMPER] EQL 0 AND .TS[NBRCH] THEN
				DELETE(.TS,1);
	END;
END;
ROUTINE NARY2(CNODE)=
	!ROUTINE CALLED FROM MATCHER WHEN A MATCH ON A SKEWED
	!TREE HAS BEEN MADE. A SKEWED NODE IS OP A OP B. WE
	!NEED TO DELETE FROM THE HASH TABLE USED OF
	!ANYTHING OP A AND B OP ANYTHING, AT THE SAME TIME
	!BEING CAREUL NOT TO *MESS-UP* B OP B OP B OP B OP B.
BEGIN
	OWN BSAMEFLG;
	MAP PEXPRNODE CNODE;

	ROUTINE BOPBOPB(SHAPE)=
	BEGIN
		MAP BASE TS;
		!LOCAL ROUTINE TO SAVE SOME CODE SPACE
		!HASHES EXPRESSION OF SHAPE SHAPE, LOOKS
		!IT UP IN THE TABLE AND DELETES IT USE COUNT BY 1
		!SET UP HASH KEY
		HASHIT(.QQ,.SHAPE);
		!DO TABLE LOOKUP
		TS_TBLSRCH();
		!IF ENTRY WAS IN THE TABLE AND IT MATCHES
		!IN SHAPE WITH THE ONE NOW CONSIDERED, THEN
		!DECREASE ITS USE COUNT BY 1. SEE DOCUMENTATION
		!FOR A DETAILED DESCRIPTION OF WHY, WHO, HOW.
		IF .FLAG THEN
			IF .TS[TEMPER] EQL 0 THEN
			IF (.SHAPE EQL SKEW AND .TS[NBRCH]) OR
			   (.SHAPE EQL STGHT AND NOT .TS[NBRCH]) THEN
				 DELETE(.TS,1);
	END;

	QQ_.CNODE[ARG1PTR];
	!FIRST DECIDE IF THIS IS A OP A. IT IS A PROPBLEM, IF IT IS
	BSAMEFLG_0;
	IF .QQ[ARG2PTR] EQL .CNODE[ARG2PTR] THEN BSAMEFLG_1;
	IF .QQ[A1VALFLG] AND .QQ[A2VALFLG] THEN
	BEGIN
		IF .BSAMEFLG AND .QQ[ARG1PTR] EQL .CNODE[ARG2PTR] THEN
		!WE HAVE B OP B OP B
		ELSE
			BOPBOPB(STGHT);
	END
	ELSE
	BEGIN
		!LOOK DOWN ONE MORE
		QQ_.QQ[ARG1PTR];
		IF .BSAMEFLG AND .QQ[ARG2PTR] EQL .CNODE[ARG2PTR] THEN
		!WE HAVE B OP B OP B
		ELSE
		BEGIN
			!FOR THE HASH, WHICH DEPENDS ON QQ
			!IN THIS CASE, MOVE QQ BACK UP
			QQ_.CNODE[ARG1PTR];
			BOPBOPB(SKEW);
		END;
	END;
	QQ_.CNODE[PARENT];
	IF .QQ[OPR1] EQL .CNODE[OPR1]
	THEN
	BEGIN
		IF .BSAMEFLG AND .QQ[ARG2PTR] EQL .CNODE[ARG2PTR] THEN
		!ONCE AGAIN B OP B OP B
		ELSE
			BOPBOPB(SKEW);
	END;
END;

!
!********************************************
!

%*********************************
MACROS TO CHECK PROPER VALFLAGS AND CALL REA FOR THE NEXT LEVEL UP
OF AN EXPRESSION THAT HAS JUST BEEN MATCHED.
************************************%

MACRO ARGSBOTH(NOD)=
		IF .NOD[A1VALFLG] AND .NOD[A2VALFLG] THEN REA(.NOD)$;
MACRO ARGS1(NOD)=
		IF .NOD[A1VALFLG] THEN REA(.NOD)$;

MACRO ARGS2(NOD)=
		IF .NOD[A2VALFLG] THEN REA(.NOD)$;

FORWARD CHKHAIR,REA,CMNLNK;


ROUTINE NEXTUP(EXPR)=
BEGIN
	!CASE STATEMENT CONTROL ON LOOKING AT THE NEXT EXPRESSION
	!UP AFTER A MATCH.

	MAP BASE EXPR;

	IF .EXPR EQL 0 THEN RETURN;
	CASE .EXPR[OPRCLS] OF SET

		ARGSBOTH(EXPR);		!BOOLEAN
		RETURN;			!DATAOPR - ILLEGAL
		!RELATIONALS ARE SPECIAL. AT THIS POINT
		!WE ARE ONLY INTERESTED IN THE RELATIONAL ITSELF
		!AND NOT THE LOCAL SPECIAL SINGLE VARIABLE CASE AT ALL
		!REA WOULD INCLUDE THIS SPECAIL CASE.
		!WE WILL CALL XPUNGE DIRECTLY TO PREVENT THIS
		IF .EXPR[A1VALFLG] AND .EXPR[A2VALFLG] THEN XPUNGE(.EXPR,STGHT);
		RETURN;			!FNCALL
		ARGSBOTH(EXPR);		!ARITHMETIC
		ARGS2(EXPR);		!TYPECNV
		RETURN;			!ARRAYREF
		RETURN;			!CMNSUB - ILLEGAL
		ARGS2(EXPR);		!NEGNOT
		ARGS1(EXPR);		!SPECOP
		RETURN;			!FIELDREF
		RETURN;			!STORECLS
		RETURN;			!REGCONTENTS
		RETURN;			!LABOP
		RETURN;			!STATEMENT
		RETURN;			!IOLSCLS
		BEGIN			!INLINFN
			IF .EXPR[ARG2PTR] NEQ 0 THEN
			BEGIN
				ARGSBOTH(EXPR)
			END ELSE
				ARGS1(EXPR);
		END
	TES;
END;
EXTERNAL REPLACARG;
ROUTINE UNRYMATCH(CNODE,NAN,PHI)=
BEGIN
!FIXES UP (PERFORMS MATCHER FUNCTIONS ) FOR A UNARY SHAPE
!(TYPECNV,ARRAYREF SPECIAL CASE, LIBRARY FUNCTION).
!PHI IS POINTER TO HASHED ENTRY (INDEX).
!NAN SHOULD BE SET ONLY ON NOT NODES, TYPECNV NODES OR FUNCTION CALLS

	MAP PEXPRNODE CNODE:PHI;
	IF .PHI[USECNT] EQL 1 THEN
	BEGIN
		PHI[USECNT]_2;
		!MAKE CMNSUB NODE AND FIX UP OLD ENTRY
		!WE MUST SET PC BEFORE THE CALL TO CMNMAK
		!IN ORDER TO CORRECTLY HANDLE THE SPECIAL LOCAL
		!COMMON SUB-EXPRESSION CASE OF A SINGLE VARIABLE
		!SUBSCRIPT OR UNDER A RELATIONAL. IN THIS
		!CASE PHI[TEMPER] HOLDS THE POINTER TO THE
		!EXPRESSION FOR RELINKING. CMNMAK WILL CHANGE 
		!PHI[TEMPER]

		IF .CNODE[OPRCLS] EQL DATAOPR THEN
			PC_.PHI[TEMPER] ELSE PC_.PHI[LKER];

		!FIRST RESET ANY NEG FLAGS ON THE NODE WE ARE
		!ABOUT TO MAKE A COMMON SUB-EXPRESSION
		!QQ IS USED AS A TEMP
		QQ_.PHI[LKER];
		IF .QQ[OPRCLS] NEQ DATAOPR THEN
		BEGIN
			QQ[A1NEGFLG]_0;
			QQ[A2NEGFLG]_0;
		END;

		T_CMNMAK(.PHI[LKER],0);
		CMNLNK(.PC,UNARY,.PHI[NEDSANEG],.PHI);
		!QQ CONTAINS THE PARENT POINTER ON RETURN.
		!BUT BE CAREFUL**********.
		!CHECK FOR THE SPECIAL LOCAL CASE OF
		!RELATIONAL OR ARRAYREF, CUZ QQ WILL POINT TO
		!THE RELATIONAL OR ARRAYREF.
		IF .CNODE[OPRCLS] EQL DATAOPR THEN
			QQ_.QQ[PARENT];
		NEXTUP(.QQ);
	END ELSE
	BEGIN
		PHI[USECNT]_.PHI[USECNT]+1;
		T_.PHI[TEMPER];
	END;
	!NOW FIX UP CURRENT REFERENCE (IN ALL CASES)
	!NOT THE SPECIAL TEST FOR THE SAME REASON AS DESCRIBED ABOVE
	!. VARHOLDER IS THE MODULE OWN THAT POINTS TO THE EXPRESSION
	!IN THIS CASE

	CMNLNK(IF .CNODE[OPRCLS] EQL DATAOPR THEN .VARHOLDER ELSE .CNODE,UNARY,.NAN,.PHI);
	IF .CNODE[OPRCLS] EQL DATAOPR THEN
	ELSE
		CHKHAIR(.CNODE,.PHI);
END;
ROUTINE CHK4OPS(CNODE)=
BEGIN
	!IF WE HAVE A OP A OP A OP A
	!WHEN WE ARE MATCHING A OP A WITH A OP A WE
	!WOULD UNLESS OTHERWISE PREVENTED ENTER INTO THE
	!HASH TABLE CMN(A OP A) OP A. IF THERE IS ANOTHER
	!A OP A OP A OP A IN THE WORLD THIS WILL
	!LEAD TO A FALSE MATCH AND INCORRECT CODE.
	!THE PURPOSE OF THIS ROUTINE IS TO PREVENT THAT
	!TROUBLE MAKING ENTRY. 0 IS RETURNED IF THE ENTRY IS OK
	!1 IF NOT.

	MAP PEXPRNODE CNODE:TS;

	IF NOT .CNODE[A1VALFLG] THEN
	BEGIN
		!THE TREE MUST BE SKEWED.
		TS_.CNODE[ARG1PTR];
		!CHECK FOR A OP A
		IF .TS[ARG2PTR] EQL .CNODE[ARG2PTR] THEN
		BEGIN
			!IF ARG1 IS THE NODE WERE SUBSTITUTING THEN
			!THIS IS THE BAD CASE.
			IF .TS[ARG1PTR] EQL .T THEN
			RETURN(1);
		END;
	END;
END;
ROUTINE MATCHER(CNODE,SHAPE,NAN,PHI)=
!CALLED ON A HIT IN THE HASH TABLE.
!PHI POINTS TO THE MATCHING ENTRY.
!CNODE IS EXPRESSION NODE.
!SHAPE IS UNARY,STGHT(STRAIGHT), OR SKEW(SKEWED) OF CURRENT EXPRESSION
!SEE ROUTINE HASHIT FOR PICRURES OF THE TREE SHAPES
!NAN IS NEEDS A NEGATIVE(NEGATION)
BEGIN
	EXTERNAL OLDHEAD;
	MAP PHAZ2 CNODE:PHI:T;
	!GO TO SPECIAL ROUTINE IF SHAPE IS UNARY
	IF .SHAPE EQL UNARY THEN
	BEGIN
		UNRYMATCH(.CNODE,.NAN,.PHI);
		RETURN;
	END;
	IF .PHI[USECNT] EQL 1 AND .PHI[TEMPER] EQL 0  THEN
	BEGIN
		PHI[USECNT]_2;
		IF .SHAPE EQL SKEW THEN		!SKEWED TREE
		BEGIN
			!ALSO CATCH B*B*B*B, TEST AFTER NARY2 WILL
			!STOP ALL COMMON SUBS OR MERELY CORRECT THE
			!SITUATION FOR B*B*B, HOPEFULLY, THIS WILL
			!PERMIT B*B*B*B TO BECOME (T=B*B,T*T).
			IF .CNODE[ARG1PTR] EQL .PHI[LKER] THEN
			BEGIN
				PHI[USECNT]_1;
				!GET OUT
				RETURN;
			END;
			NARY2(.CNODE);		!PRECLUDE TRIPLES ELIMINATED BY MATCH
			IF .PHI[NBRCH] THEN	!ENTRY IN HASH TABLE IS ALSO SKEWED
			BEGIN
				QQ_.CNODE[ARG1PTR];
				PB_MAKEPR(.CNODE[OPRCLS],	!MAKE A STRAIGHT ONE
				.CNODE[OPERSP],
				.CNODE[VALTYPE],
				.CNODE[ARG2PTR],
				.QQ[ARG2PTR]);
				PB[DEFPT1]_.CNODE[DEFPT2];
				PB[DEFPT2]_.QQ[DEFPT2];
				PB[A1FLGS]_.CNODE[A2FLGS];
				PB[A2FLGS]_.QQ[A2FLGS];
				NARY2(.PHI[LKER]);	!ELIMINATE TRIPLES PRECLUDED BY MATCH
				T_CMNMAK(.PB,.NAN);	!MAKE A CMN SUB
				PC_.PHI[LKER];
				PB[PARENT]_.PC[PARENT];
				PHI[LKER]_.PB;
			END ELSE
			BEGIN
				T_CMNMAK(.PHI[LKER],.NAN);	!MAKE A CMNSUB
				!PRECLUDE IF NECESSARY
				STPRECLUDE(.PHI[LKER]);
				PC_.PHI[LKER];
			END;			!FIX UP TREE
		END ELSE
		BEGIN		!SHAPE IS STRAIGHT
			!MAKE CMNSUB NODE
			T_CMNMAK(.CNODE,.NAN);
			!IF FIRST NODE WAS SKEWED, MAKE THE ONE
			!WE *KEEP* STRAIGHT. ALSO PRECLUDE OTHERS
			!PRECLUDED BY THIS MATCH.
			IF .PHI[NBRCH] THEN
			BEGIN
				NARY2(.PHI[LKER]);
				PC_.PHI[LKER];
				PHI[LKER]_.CNODE;
			END ELSE
			BEGIN
				!FIRST NODE WAS STRAIGHT
				!BUT STILL HAVE THE COUNT HASSLE
				STPRECLUDE(.PHI[LKER]);
				PC_.PHI[LKER];
				PHI[LKER]_.CNODE;
			END;
		END;
		!FIX UP HASH TABLE EXPRESSION PTRS
		!PC IS POINTER TO THE EXPRESSION
		CMNLNK(.PC,IF .PHI[NBRCH] THEN SKEW ELSE STGHT,.PHI[NEDSANEG],.PHI);
		!QQ POINTS TO *PARENT* ON RETURN FROM CMNLNK
		IF NOT CHK4OPS(.CNODE) THEN
		NEXTUP(.QQ);
	END ELSE
	BEGIN
		PHI[USECNT]_.PHI[USECNT]+1;	!USECNT ATR 1
		!IF THIS IS A SKEWED TREE DELETE
		!HASH ENTRIES PRECLUDED BY THIS MATCH
		IF .SHAPE EQL SKEW THEN
			NARY2(.CNODE)
		ELSE
			STPRECLUDE(.CNODE);

		T_.PHI[TEMPER];			!POINT TO TEMP FOR SUBSTITUTION
	END;
	!LINK UP THE COMMON SUB EXPRESSION (CURRENT ONE)
	CMNLNK(.CNODE,.SHAPE,.NAN,.PHI);
	!LOOK AT THE COMMON SUBEXPRESSION TO SEE IF THERE
	! ARE OTHERS UNDER IT
		CHKHAIR(.CNODE,.PHI);
END;							!MATCHER
!*********************************
ROUTINE CMNLNK(CNODE,SHAPE,NAN,PHI)=
BEGIN
	EXTERNAL LOKCALST,BACKST;
!LINK UP THE COMMON SUB-EXPRESSION IN ITS PLACE

	MAP PHAZ2 QQ;
	MAP BASE CNODE:PHI:T;
	EXTERNAL MAKPR1,SETNEG,SAVSPACE;
	EXTERNAL CHOSEN,GLOBREG,ITMCT,SPECCASE;
	OWN OLDT,NEGT;
	LABEL ADJCTL;

	T[EXPRUSE]_.PHI[USECNT];

	!INITIALIZE FLAG TO 0
	FLAG_0;

	IF .SHAPE EQL SKEW THEN
	BEGIN
		CNODE[A2NEGFLG]_0;
		IF .NAN THEN
		BEGIN
			CNODE[ARG2PTR]_MAKPR1(.CNODE[PARENT],NEGNOT,NEGOP,.CNODE[VALTYPE],0,.T);
			CNODE[A2VALFLG]_0;
		END
		ELSE
		BEGIN
			CNODE[ARG2PTR]_.T;
			CNODE[A2VALFLG]_1;
		END;
		!THE TREE LOOKSE LIKE THIS
		!	  *(CNODE)
		!    *        *
		!*(QQ)	  	*(JUST BECOME T)

		!	  *(QQ)
		!    *        *
		! *(WILL BECOME QQ WE CARE ABOUT)
		!			*(WILL GO AWAY)

		QQ_.CNODE[ARG1PTR];
		!SAVE DEFINITION POINT. IF QQ[ARG1PTR] IS NOT
		!AN EXPRESSION THEN THIS BECOMES THE DEFINITION POINT
		!OF THE DATAOPR, ETC.
		TS_.QQ[DEFPT1];
		!THERE IS YET ANOTHER HASSLE.****NEG/NOT FLGS
		!WE MUST MOVE THEM UP IF POSSIBLE. THE CONDITIONS ARE
		!IF NEG IS SET AND CNODE DOESNT HAVE NOT SET, COMPLEMENT
		!NEG IN PARENT ELSE BUILD NEG NODE AND INSERT. THE
		!SAME IS TRUE FOR NOTS. SET REFERS TO THE ARG1FLGS OF
		!THE TOP ONE OF THE QQ  NODES IN THE ABOVE DIAGRAM.

		IF .QQ[A1NEGFLG] THEN
		BEGIN
			IF NOT .CNODE[A1NOTFLG] THEN
			BEGIN
				CNODE[A1NEGFLG]_NOT .CNODE[A1NEGFLG];
				QQ_.QQ[ARG1PTR];
			END ELSE
				QQ_MAKPR1(.CNODE,NEGNOT,NEGOP,.QQ[VALTYPE],0,.QQ);
		END ELSE
		IF .QQ[A1NOTFLG] THEN
		BEGIN
			IF NOT .CNODE[A1NEGFLG] THEN
			BEGIN
				CNODE[A1NOTFLG]_NOT .CNODE[A1NOTFLG];
				QQ_.QQ[ARG1PTR];
			END ELSE
				QQ_MAKPR1(.CNODE,NEGNOT,NOTOP,.QQ[VALTYPE],0,.QQ);
		END ELSE
		QQ_.QQ[ARG1PTR];
		CNODE[ARG1PTR]_.QQ;
		!SET DEFINITION POINT OF NODE JUST SUBSTITUTED
		CNODE[DEFPT2]_.PHI[STPT];
		!NOW, DEPENDING ON WHETHER OR NOT QQ IS A 
		!DATAOPR OR CMNSUB SET DEFPT1, VALFLAGS AND
		!PARENT POINTER

		IF .QQ[OPRCLS] EQL DATAOPR OR .QQ[OPRCLS] EQL CMNSUB THEN
		BEGIN
			CNODE[DEFPT1]_.TS;
			CNODE[A1VALFLG]_1;
		END ELSE
		BEGIN
			!AN EXPRESSION
			CNODE[DEFPT1]_.QQ[DEFPT1];
			QQ[PARENT]_.CNODE;
		END;
		!MAKE SURE QQ POINTS TO CNODE PARENT BEFORE
		!RETURN AS THIS FEATURE IS USED BY NEXTUP
		QQ_.CNODE[PARENT];
	END ELSE
	BEGIN
		!HERE, ONCE AGAIN, WE HAVE THE SPECAIL LOCAL (SINGLE VARIABLE) CASE.
		!CNODE IS A POINTER TO THE EXPRESSION AND WILL
		!ITSELF FUNCTION AS THE PARENT
		!NO OTHER CASE LOOKS FOR COMMON SUBS IN AN ARRAYREF
		!OR RELATIONAL.****THIS IS AN IMPORTANT CONCEPT****.
		!THE GLOBAL CASE  DOES LOOK FOR RELATIONALS SO AN
		!ADDITIONAL TEST ON BACKST IS ALSO NECESSARY

		!SAVE VALUE OF T
		OLDT_.T;
		IF (.CNODE[OPRCLS] EQL ARRAYREF OR
		.CNODE[OPRCLS] EQL RELATIONAL)  AND .BACKST NEQ 0 THEN
		BEGIN
			QQ_.CNODE;
			CNODE_.PHI[LKER];
			!IF IT IS A RELATIONAL WE MUST
			!SET A SPECIAL FLAG SO THAT
			!THE REGISTER ALLOCATOR WILL KNOW THAT
			!IT MAY HAVE TO BE MOVED TO ANOTHER
			!REGISTER IF THIS IS AN AOBJN LOOP.
			IF .QQ[OPRCLS] EQL RELATIONAL THEN
				T[CSFULLWDFLG]_1;
		END ELSE
		BEGIN
			QQ_.CNODE[PARENT];
			!IF T IS A VARIABLE (THIS IS THE GLOBAL CASE9
			!DONT SET THE PARENT TO T. DONT SET THE PARENT
			!AT ALL.
			IF .T[OPRCLS] EQL CMNSUB THEN
				CNODE[PARENT]_.T;
		END;

		IF .NAN THEN NEGT_
			MAKPR1(.QQ,NEGNOT,NEGOP,.CNODE[VALTYPE],0,.T);
		IF .QQ[OPRCLS] EQL STATEMENT THEN
		BEGIN
			IF .NAN THEN
			IF SETNEG(.QQ,0) THEN ELSE
				(T_.NEGT;FLAG_1;);
			REPLACARG(.QQ,.CNODE,.T);
			IF .T[IDDOTO] EQL SIXBIT ".O" THEN
				IF .QQ[SRCID] EQL ASGNID THEN
					IF .QQ[SRCOPT] NEQ 0 THEN
						QQ[OPDEF]_.PHI[STPT];
		END
		ELSE
		IF .QQ[OPRCLS] EQL FNCALL THEN
		BEGIN
			LOCAL ARGUMENTLIST AG;
			IF .NAN THEN (T_.NEGT;FLAG_1;);
			AG_.QQ[ARG2PTR];
			!SET UP PARMS INCASE WE HAVE
			!TO CALL LEAFSUBSTITUTE TO LOCATE IT
			ITMCT_1;
			GLOBREG[0]_.CNODE;
			CHOSEN[0]_.T;
			SPECCASE_0;
			LOKCALST(.AG,.AG[ARGCOUNT],.CNODE,.T);
		END ELSE
		IF .QQ[ARG1PTR] EQL .CNODE AND .QQ[OPRCLS] NEQ ARRAYREF THEN
		BEGIN
			IF .NAN THEN
				IF SETNEG(.QQ,1) THEN ELSE
					(T_.NEGT;FLAG_1;);
			QQ[ARG1PTR]_.T;
			IF .T[OPRCLS] EQL CMNSUB OR .T[OPRCLS] EQL DATAOPR THEN
				QQ[A1VALFLG]_1;
			QQ[DEFPT1]_.PHI[STPT];
		END ELSE
		BEGIN
			IF .NAN THEN
				IF SETNEG(.QQ,0) THEN ELSE
					(T_.NEGT;FLAG_1;);
			QQ[ARG2PTR]_.T;
			IF .T[OPRCLS] EQL CMNSUB OR .T[OPRCLS] EQL DATAOPR THEN
				QQ[A2VALFLG]_1;
			QQ[DEFPT2]_.PHI[STPT];
		END;

		!ONE MORE THING. IF THE PARENT IS
		!A CONTROL TYPR BOOLEAN WE HAVE TO CHANGE IT
		!TO CONTROL, CUZ CODE GENERATION CANNOT HANDLEE
		!A VALUE UNDER A BOOLEAN OR TYPE CONTROL
		T_.QQ;
		ADJCTL:
		WHILE .T[OPRCLS] EQL BOOLEAN AND .T[VALTYPE] EQL CONTROL
		DO
		BEGIN
			!CHANGE TO LOGICAL
			T[VALTYPE]_LOGICAL;
			!LOOK AT NEXT PARENT
			T_.T[PARENT];
			!CHECK FOR ORPHAN
			IF .T EQL 0 THEN LEAVE ADJCTL;
		END;

		!RESTORE NODE SPACE FREED, IF ANY
		IF .NAN THEN
			IF .FLAG THEN ELSE SAVSPACE(EXSIZ-1,.NEGT);
		T_.OLDT;
		IF .T[OPRCLS] EQL CMNSUB THEN
		BEGIN
			!THE CHECK FOR THE VALFLG BEINGON
			!A CMNSUB NODE IS EQUIVALENT TO THE
			!SPECIAL CASE CHECK FOR THE LOCAL
			!UNARY SUBSCRIPT OR RELATIONAL.
			!IT IS CLEAR THAT THE SPACE FOR A
			!SYMBOL TABLE NODE DOES NOT GET FREED.
			IF .T[ARG2PTR] NEQ .CNODE
			AND NOT .T[A2VALFLG] THEN
				SAVSPACE(EXSIZ-1,.CNODE);
		END;
	END;
END;

ROUTINE CHKHAIR(CNODE,PHI)=
BEGIN
	LOCAL BASE ARGNODE;
!
!CHECK NODE FOR HAVING ANOTHER COMMON SUB-EXPRESSION UNDER IT
!IF IT DOES SET CMNUNDER FLAG IN HASH TABLE NODE.

	EXTERNAL TOP,LENTRY;
	MAP BASE TOP:PA;
	MAP PEXPRNODE CNODE:PHI;
MACRO ARG1CHK=
BEGIN
	ARGNODE_.CNODE[ARG1PTR];
	IF .ARGNODE[OPRCLS] EQL CMNSUB OR .ARGNODE[IDDOTO] EQL SIXBIT".O" THEN
		PHI[CMNUNDER]_1;
END$;
MACRO ARG2CHK=
BEGIN
	ARGNODE_.CNODE[ARG2PTR];
	IF .ARGNODE[OPRCLS] EQL CMNSUB OR .ARGNODE[IDDOTO] EQL SIXBIT".O" THEN
		PHI[CMNUNDER]_1;
END$;

	CASE .CNODE[OPRCLS] OF SET

	!BOOLEAN
	BEGIN
		ARG1CHK;
		ARG2CHK;
	END;
	!DATAOPR
		RETURN;
	!RELATIONAL
	BEGIN
		ARG1CHK;
		ARG2CHK;
	END;
	!FNCALL
		RETURN;
	!ARITHMETIC
	BEGIN
		ARG1CHK;
		ARG2CHK;
	END;
	!TYPCNV
		ARG2CHK;
	!ARRAYREF
		RETURN;
	!CMNSUB
		RETURN;
	!NEGNOT
		ARG2CHK;
	!SPECOP
		ARG1CHK;
	!FIELDREF
		RETURN;
	!STORECLS
		RETURN;
	!RECONTENTS
		RETURN;
	!LABOP
		RETURN;
	!STATEMENT
		RETURN;
	!IOLSCLS
		RETURN;
	!INLINFN
	BEGIN
		ARG1CHK;
		IF .CNODE[ARG2PTR] NEQ 0 THEN
			ARG2CHK;
	END

	TES;
END;

MACRO
REVARG=
ENTRYP[HA1]_.CNODE[ARG2PTR];
ENTRYP[HDEF1]_.CNODE[DEFPT2];
ENTRYP[HA2]_.CNODE[ARG1PTR];
ENTRYP[HDEF2]_.CNODE[DEFPT1];$,

REGARG=
ENTRYP[HA1]_.CNODE[ARG1PTR];
ENTRYP[HDEF1]_.CNODE[DEFPT1];
ENTRYP[HA2]_.CNODE[ARG2PTR];
ENTRYP[HDEF2]_.CNODE[DEFPT2];$,

SREVARG=
ENTRYP[HA1]_.CNODE[ARG2PTR];
ENTRYP[HDEF1]_.CNODE[DEFPT2];
ENTRYP[HA2]_.QQ[ARG2PTR];
ENTRYP[HDEF2]_.QQ[DEFPT2];$,

SREGARG=
ENTRYP[HA1]_.QQ[ARG2PTR];
ENTRYP[HDEF1]_.QQ[DEFPT2];
ENTRYP[HA2]_.CNODE[ARG2PTR];
ENTRYP[HDEF2]_.CNODE[DEFPT2];$;

!
!********************************************
!
OWN TALLY;
GLOBAL ROUTINE HASHIT(CNODE,SHAPE)=
BEGIN
	EXTERNAL LOOPNO;
	OWN PHAZ2 ENTRYP;
	MAP PHAZ2 CNODE;
	!CREATE HASH TABLE ENTRY FOR LOOKUP; THE GLOBAL ENTRY IS USED.
	!ENTRY IS FILLED WITH THE HASH KEY ELEMENTS. THESE ARE
	!THE OPERATOR, ARGUMENTS(S) AND DEFINITION POINTS.
	!THE MACROS PRECEEDING THIS ROUTINE HELP ASSURE THAT
	!ARGUMENTS ARE IN THEIR PROPER ORDER.
	!NODE:*******NO DOT ON ASSIGNMENT TO ENTRYP
	ENTRY_0;  ENTRYP_ENTRY;
	ENTRY+1_0; 
	NAN_0;
	ENTRYP[BLKID]_.LOOPNO;
	CASE .SHAPE OF SET
	!
	!UNARY
	!
	!TYPECNV, ARRAYREF WITH SIMPLE VARIABLE AS RESULTANT SUBSCRIPT
	!ALSO LIBRARY FUNCTIONS OF A SINGLE ARGUMENT
	!ALSO SPECIAL OPERATORS WHICH ARE ARG1 TYPES INSTEAD OF ARG2.
		BEGIN
			!IF THE ITEM IS A VARIABLE (THIS IS SPECIAL ARRAYREF CASE
			IF .CNODE[OPRCLS] EQL DATAOPR AND .CNODE[OPERSP] NEQ CONSTANT  THEN
			BEGIN
				ENTRYP[HOP]_VARFL;
				ENTRYP[HDEF1]_0;
				ENTRYP[HA2]_.CNODE;
				ENTRYP[HDEF2]_0;
				ENTRYP[HA1]_0;
			END ELSE
			!ITS NOT THE ARRAY REF CASE ASK IF ITS A FINCTION CALL
			IF .CNODE[OPRCLS] EQL FNCALL THEN
			BEGIN
				ENTRYP[HOP]_.CNODE[ARG1PTR];
				ENTRYP[HA1]_1;
				ENTRYP[HDEF1]_0;
				ENTRYP[HA2]_.CNODE[ARG2PTR];
				ENTRYP[HDEF2]_.CNODE[DEFPT2];
			END ELSE
			!NOT A FUNCTION CALL EITHER. CHECK FOR
			!SPECIAL OPERATOR
			IF .CNODE[OPRCLS] EQL SPECOP THEN
			BEGIN
				IF .CNODE[A1NEGFLG] THEN
					NAN_1;
				ENTRYP[HOP]_.CNODE[OPERATOR]+.CNODE[A1NOTFLG];
				REGARG;
			END ELSE
			!NOW TREAT  EVERYONE THE SAME
			!(TYPECNV AND NEGNOT
			BEGIN
				IF .CNODE[A2NEGFLG] THEN NAN_1;
				ENTRYP[HOP]_.CNODE[OPERATOR]+.CNODE[A2NOTFLG];
				REGARG;
			END;

		END;
		!
		!STRAIGHT
		!
		!      OP
		!    *    *
		!  *        *
		!DATA     DATA
		BEGIN
			IF .CNODE[OPRCLS] EQL ARITHMETIC THEN
			BEGIN
			!ARITHMETIC NODES ARE A SPECIAL CASE
			!BECAUSE THE SKELETON OPTIMIZER HAS
			!ELIMINATED SUBTRACT NODES IN FAVOR OF
			!ADDS WITH PROPER NEG FLAGS SET. WE
			!ALSO WISH TO RECOGNIZE A-B AND B-A AS
			!THE SAME EXPRESSION (PLUS NEGATE ON ONE OF THEM).

			!TALLY IS THE SUM OF THE NEGATE FLAGS
			!PRESENT IN THE NODE.
			TALLY_.CNODE[A1NEGFLG]+.CNODE[A2NEGFLG];
			IF .CNODE[OPR1] EQL ADDOPF THEN
			!ADDS ARE A SPECIAL CASE
			BEGIN
				ENTRYP[HOP]_.CNODE[OPERATOR]+.TALLY+
				.CNODE[A1NOTFLG]^1+.CNODE[A2NOTFLG]^2;
				!IN ALL CASES THE EXPRESSION WILL BE
				!CONSIDERED TO BE A-B. THIS IS
				!TALLY =1 AND A2NEGFLG SET. TALLY = 1
				!AND A1NEGFLG SET IS B-A WHICH NEEDS
				!A NEGATION (NAN SET).
				IF .TALLY AND .CNODE[A1NEGFLG] THEN
				NAN_1 ELSE NAN_0;
				!MAKE SURE ONCE AGAIN THAT ARGS ARE
				!IN THE CORRECT ORDER. IN GENERAL,
				!THEY ARE PROPERLY ORDERED BY CANONICALIZATION
				!WHEN NEWLY FOUND COMMON SUBS ARE INVOLVED
				!WE MAY NEED TO ORDER THEM HERE.
				IF .CNODE[ARG1PTR] GTR  .CNODE[ARG2PTR] THEN
				BEGIN
					REVARG;
					IF .TALLY THEN NAN_NOT .NAN;
				END ELSE 	!ARGS ARE ALREADY IN RIGHT ORDER
				BEGIN
					REGARG;
				END;
			END ELSE	!END OF ADD OPERATION CASE

			BEGIN
				IF .TALLY THEN NAN_1 ELSE NAN_0;
				ENTRYP[HOP]_.CNODE[OPERATOR]+
				.CNODE[A1NOTFLG]^1+.CNODE[A2NOTFLG];
				!MULTIPLY IS ALSO SOMEWHAT SPECIAL
				IF .CNODE[OPR1] EQL MULOPF THEN
				BEGIN
					!CHECK ARG ORDER AGAIN
					IF .CNODE[ARG1PTR] GTR .CNODE[ARG2PTR] THEN
					BEGIN
						REVARG;
					END ELSE	!ARGS IN PRDER
					BEGIN
						REGARG;
					END;
				END ELSE	!NOT A MULTIPLY
				BEGIN
					REGARG;
				END;
			END;	!END OF NOT ADD BUT STILL ARITHMETIC
			END ELSE	!END OF ARITHMETIC
			BEGIN
				NAN_0;
				ENTRYP[HOP]_.CNODE[OPERATOR]+
				.CNODE[A1NOTFLG]^1+.CNODE[A2NOTFLG];
				REGARG;
			END;
		END;	!END OF STRAIGHT CASE
	!
	!SKEWED TREES
	!
	!      OP(CNODE)
	!    *    *
	!  *        *
	!OP(QQ)    DATA
	!   *
	!     *
	!    DATA
	!
	BEGIN
		QQ_.CNODE[ARG1PTR];
		IF .CNODE[OPRCLS] EQL ARITHMETIC THEN
		BEGIN	!ARITHMETIC NODE
			!TALLY CONTAINS THE NUMBER OF NEGATIVES ON THE EXPRESSION
			TALLY_.CNODE[A2NEGFLG]+.QQ[A2NEGFLG];
			IF .CNODE [OPR1] EQL ADDOPF THEN
			BEGIN	!AN ADD
				ENTRYP[HOP]_.CNODE[OPERATOR]+.TALLY
				+.CNODE[A1NOTFLG]^1+.CNODE[A2NOTFLG]^2;
				!TALLY AND A NEGATE (GLAG) ON THE SECOND
				!NODE DETERMINE IF A NEGATE IS NEEDED
				!ON THE COMMON SUB.
				IF .TALLY AND .QQ[A2NEGFLG] THEN NAN_1 ELSE NAN_0;
				!INSURE ARGS ARE ORDERED BY SYMBOL TABLE ADDRESS
				IF .QQ[ARG2PTR] GTR .CNODE[ARG2PTR] THEN
				BEGIN	!THEY NEED SWITCHING
					SREVARG;
					IF .TALLY THEN NAN_NOT .NAN;
				END ELSE	!THEY DONT NEED SWITCHING
				BEGIN
					SREGARG;
				END;
			END ELSE	!NOT AN ADD
			BEGIN
				NAN_.TALLY;
				ENTRYP[HOP]_.CNODE[OPERATOR]
				+.CNODE[A1NOTFLG]^1+.CNODE[A2NOTFLG];
				IF .CNODE[OPR1] EQL MULOPF THEN
				BEGIN	!A MULTIPLY
					!WORRY ABOUT ARG ORDER AGAIN
					IF .QQ[ARG2PTR] GTR .CNODE[ARG2PTR] THEN
					BEGIN
						!NEED REORDERING
						SREVARG;
					END ELSE
					BEGIN	!NO REORDERING NEEDED
						SREGARG;
					END
				END ELSE	!NOT MULTIPLY
				BEGIN
					SREGARG;
				END
			END;
		END ELSE	!END ARITHMETIC
		BEGIN	!NOT ARITHMETIC
			ENTRYP[HOP]_.CNODE[OPERATOR]
			+.CNODE[A1NOTFLG]^1+.CNODE[A2NOTFLG];
			SREGARG;
		END;
	END	!END SKEWED TREE CASE
	TES;
END;				!HASHIT
!****************************************
FORWARD CHKDOMINANCE;
ROUTINE XPUNGE(CNODE,SHAPE)=
BEGIN
	EXTERNAL BACKST;
	!TREE HAS BEEN WALKED TO THE LEAF*OPERATOR*LEAF
	!POINT. THE EXPRESSION WILL NOW BE HASHED, ETC.

	MAP PEXPRNODE CNODE;
	!THE LOCAL AND GLOBAL CASES ARE DISTINGUISHED HERE
	!BY A TEST ON THE VALUE OF BACKST. BACKST MUST BE
	!ZERO IN THE GLOBAL CASE. THE CHECK IS NECESSARY SINCE
	!THE GLOBAL CASE REQUIRES MUCH CHECKING NOT NECESSARY IN THE
	!LOCAL CASE.

	IF .BACKST NEQ 0 THEN		!LOCAL CASE
	BEGIN
		HASHIT(.CNODE,.SHAPE);
		PHI_TBLSRCH();
		IF .FLAG THEN MATCHER(.CNODE,.SHAPE,.NAN,.PHI)
		ELSE
		BEGIN
			PHI_
			MAKETRY(.PHI,.CNODE);
			IF .SHAPE EQL SKEW THEN
			PHI[NBRCH]_1;
			IF .NAN THEN
			PHI[NEDSANEG]_1;
			PHI[STPT]_0;
		END;
	END ELSE CHKDOMINANCE(.CNODE,.SHAPE);	!GLOBAL CASE
END;
!
!****************************************************
!
ROUTINE CHKINIT(VAR)=
BEGIN
	!ROUTINE CHECKS TO SEE WHETHER OR NOT VAR IS
	!INITIALIZED

	MAP BASE VAR;
	EXTERNAL WARNOUT;

	!IT IS NOT INITIALIZED (WE ALREADY KNOW ITS A MAIN SECTION OF CODE
	!AND THE DEFINITION POINT IS LENTRY) IF
	!	1. IT IS NOT IN A DATA STATEMENT
	!	2. IT IQ NOT A FORMAL
	!	3. IT IS NOT A CONSTANT
	!	4. IT IS NOT A COMPILER VARIABLE
	!	5. IT IS NOT IN COMMON
	!	6. IT IS NOT IN AN EQUIVALENCE STATEMENT

	IF NOT .VAR[IDATTRIBUT(INDATA)] AND
	   .VAR[OPR1] NEQ CONSTFL AND
	   NOT .VAR[FORMLFLG] AND
	   .VAR[IDDOTO] NEQ SIXBIT".O"
	   AND NOT .VAR[IDATTRIBUT(INCOM)]
	   AND NOT .VAR[IDATTRIBUT(INEQV)]
	  AND .LSTWARNLINE NEQ .VAR THEN
	BEGIN
		!NOT THE MISSING DOT IS DELIBERATE.
		!ENTRY IS TO CONTAIN A POINTER TO THE SIXBIT SYMBOL
		ENTRY[1]_VAR[IDSYMBOL];
		WARNOUT(79);
		LSTWARNLINE_.VAR;
	END;
END;

ROUTINE JACKUP(STMT)=
BEGIN

	!INSERT A CONTINUE INFRONT OF OF STATEMENT IF IT IS LABELED
	!STMT POINTS TO A STATEMENT.

	MAP BASE STMT:PB;

	!IN ANY CASE I NEED THE STATEMENT INFRONT OF STMT
	!A LINEAR SEARCH TECHNIQUE IS USED.

	PB_.TOP;

	WHILE .PB[SRCLINK] NEQ .STMT DO
		PB_.PB[SRCLINK];

	IF .STMT[SRCLBL] NEQ 0 THEN
	BEGIN
		!WE SHOULD ONLY DO THIS ONCE FOR EACH SITUATION.
		NAME<LEFT>_SRCSIZ;
		PA_CORMAN();
		PA[SRCID]_CONTID;
		PA[OPRCLS]_STATEMENT;
		!MAKE A DUMMY CONTINUE
		!AND LINK IT IN
		PA[SRCLINK]_.STMT;
		PB[SRCLINK]_.PA;
		PA[SRCLBL]_.STMT[SRCLBL];
		STMT[SRCLBL]_0;
		!ALSO PATCH UP THE LABEL TABLE
		!USE PA AS A TEMP HERE.
		PA_.PA[SRCLBL];
		PA[SNHDR]_.PB[SRCLINK];
		!MAKE PB THE THING WE RETURN
		PB_.PB[SRCLINK];
	END;

	!IN ANY CASE RETURN PB
	.PB
END;
ROUTINE CHKVIABLPLACE(STMT)=
BEGIN

	MAP BASE PB:PA;
	EXTERNAL CSTMNT;
	REGISTER PHAZ2 PLACE;

	!STMT POINTS TO A STATEMENT (AS DOES PLACE). IT IS THE MOTION
	!PLACE OF AN EXPRESSION. IF IT IS A MULTIPLE BRANCH WE MUST
	!INSERT THE COMPUTATION IN FRONT OF THE STATEMENT. TO 
	!ACCOMPLISH THIS WE WILL NOW INSERT A CONTINUE IN FRONT OF THE
	!AND MOVE ANY LABEL ORIGINALLY ON STMT BACK TO THIS CONTINUE.
	!THE NEW PLACE IS RETURNED TO CHKDOMINANCE (THE CALLER).

	PLACE_.STMT;
	SELECT .PLACE[SRCID] OF NSET

	GOTOID:	PLACE_JACKUP(.PLACE);

	AGOID:	PLACE_JACKUP(.PLACE);

	CGOID:	PLACE_JACKUP(.PLACE);

	CALLID:	BEGIN
		!A MINOR EXCEPTION. WE WILL INSERT THE COMPUTATION
		!A THE POSTDOMINSTOR IF WE HAVE LABELS

		IF .PLACE[LABLARGS] THEN
		!IF THERE ARE LABEL ARGS
		BEGIN
			PLACE_.PLACE[POSTDOM];
			IF .PLACE EQL .CSTMNT OR
			.PLACE[SRCLBL] NEQ 0 THEN
				PLACE_JACKUP(.PLACE);
		END;
		END;

	IFAID:	PLACE_JACKUP(.PLACE);

	READID:	BEGIN
		!AGAIN A MINOR EXCEPTION
		IF .PLACE[IOEND] NEQ 0 OR .PLACE[IOERR] NEQ 0 THEN
		!THE READ IS REALLY ALSO A BRANCH
		BEGIN
			PLACE_.PLACE[POSTDOM];
			IF .PLACE EQL .CSTMNT OR .PLACE[SRCLBL] NEQ 0 THEN
				PLACE_JACKUP(.PLACE);
		END;
		END;

	WRITID:	BEGIN
		!HASSLE NOT NECESSARY IF THERE ARE NO BRANCHES
		IF .PLACE[IOEND] NEQ 0 OR .PLACE[IOERR] NEQ 0 THEN
			PLACE_JACKUP(.PLACE);
		END;

	IFLID:	BEGIN
		!ONLY A PROBLEM IF TRUE BRANCH IS A BRANCH
		IF .PLACE[TRUEISBR] THEN
			PLACE_JACKUP(.PLACE);
		END;

	TESN;

	.PLACE
END;
ROUTINE CHKDOMINANCE(CNODE,SHAPE)=
BEGIN

	!MACRO TO SET PARENFLG AND RETURN
	!PARENFLG WILL TRIGGER LOCAL
	!COMMON SUB-EXPREESION ELIMINATION AFTER GLOBAL OPTIMIZATION
	!IS DONE. ON ASSIGNMENT STATEMENTS ONLY

	MACRO SETPANGO=
	BEGIN
		!IF .CSTMNT[SRCID] EQL ASGNID THEN
		!	CSTMNT[PARENFLG]_1;
		RETURN;
	END$;


EXTERNAL LOOP,LEND,WARNOUT,SKERR,ISN;
LOCAL ADJPLACE;		!FLAG TO SET PLACE BACK TO CORRECT PLACE
MAP PHAZ2 PB;
LOCAL BASE PLACE;
EXTERNAL CSTMNT;	!POINTS TO THE STATEMENT
MAP BASE CSTMNT;
	OWN DEF1PLACE,DEF2PLACE;

!******
!MAKE SURE THAT THE PLACE TO WHICH MOTION WOULD OCCUR
!HAS THE CURRENT STATEMENT (CSTMNT POINTS TO IT) AS POSTDOMINATOR.
!THIS INVOLVES:
!	1.DETERMINING THE PLACE TO WHICH MOTION WOULD OCCUR.
!	2.LOOKING FOR CSTMNT ON THE PREDOMINATOR LIST OF
!	  THE PLACE TO WHICH MOTION WOULD OCCUR.
!	3. IF 2 IS FALSE THEN THE PARENFLG IS SET ON THE
!	 STATEMENT (IF AN ASSIGNMENT). THIS IS A FUDGE TO
!	PERMIT LOOKING FOR LOCAL COMMON SUBS IN SUCH
!	STATEMENTS AT THE END OF OPTIMIZATION (PHA2).

MAP PEXPRNODE CNODE;
	!IF EITHER DEFPT IS THE CURRENT STATEMENT DO NOT
	!CONSIDER THIS STATEMENT FOR GLOBAL COMMON SUBS.
	!DO NOT SET THE FLAG TO CAUSE IT TO GET LOCAL ONES EITHER.
	!IF SUCH WERE DONE TROUBLE MIGHT INSUE. IT WOULD ALOS WASTE
	!TIME.

	IF .CNODE[DEFPT1] EQL .CSTMNT OR
	   .CNODE[DEFPT2] EQL .CSTMNT THEN RETURN;
	IF .CNODE[DEFPT1] EQL .CNODE[DEFPT2] THEN
	BEGIN
		PLACE_.CNODE[DEFPT2];
		IF .PLACE EQL .LENTRY AND .SHAPE EQL STGHT AND .LOOP EQL 0 THEN
		BEGIN
			CHKINIT(.CNODE[ARG1PTR]);
			CHKINIT(.CNODE[ARG2PTR]);
		END;
	END
	ELSE
	BEGIN
		!MUST TAKE SHAPE INTO CONSIDERATION
		IF .SHAPE EQL SKEW THEN
		BEGIN
			PB_.CNODE[ARG1PTR];
			DEF1PLACE_.PB[DEFPT2];
			DEF2PLACE_.CNODE[DEFPT2];
			!MAKE PB POINT TO SOMEPLACE USEFUL FOR LATER
			PB_.PB[ARG2PTR];
		END ELSE
		BEGIN
			DEF1PLACE_.CNODE[DEFPT1];
			DEF2PLACE_.CNODE[DEFPT2];
			PB_.CNODE[ARG1PTR];
		END;

		!NO MATTER THE SHAPE OF THE NODE PB NOW POINTS
		!TO LOGICAL ARG1 AND CNODE[ARG2PTR] TO LOGICAL ARG2.
		!DEF1PLACE AND DEF2PLACE POINT TO THE CORRESPONDING
		!DEFINITION POINTS. WE WILL NOW USE THIS INFO
		!TO CHECK FOR THE VARIBALE BEING INITIALIZED

		IF .LOOP EQL 0 THEN	!MAIN COFE SECTION
		BEGIN
			IF .DEF1PLACE EQL .LENTRY THEN
				CHKINIT(.PB);
			IF .DEF2PLACE EQL .LENTRY THEN
				CHKINIT(.CNODE[ARG2PTR]);
		END;

		PB_.CSTMNT;		!PB IS TEMP
		DO
			PB_.PB[PREDOM]
		UNTIL .PB EQL .DEF1PLACE
		OR   .PB  EQL .DEF2PLACE
		OR   .PB EQL .TOP;
		PLACE_.PB;
		!WE CAN ONLY LOOK AS FAR AS TOP BUT MAYBE IT IS
		!REALLY SUPPOSED TO BE LENTRY
		IF .PB EQL .TOP THEN
			IF .DEF1PLACE NEQ .TOP THEN
				IF .DEF2PLACE  NEQ .TOP THEN
					PLACE_.LENTRY;

	END;
	!PLACE NOW POINTS TO THE STATEMENT THAT IS THE DEFPT OF THE
	!EXPRESSION.  WE CHECK TO SEE IF PA POSTDOMINATES PLACE
	!IF THIS IS A MAIN PROGRAM LENTRY (WHICH COULD POSSIBLY BE THE
	!VALUE OF PLACE AT THIS POINT) IS THE  DUMMY CONTINUE WHICH
	!DOES NOT HAVE THE OPTIMIZERS WORDS (POSTDOM, PREDOM ,ETC.)
	!THEREFOR, WE WILL TEST AND ADJUST
	IF .PLACE EQL 0 THEN SETPANGO;


	ADJPLACE_0;
	IF .PLACE EQL .LENTRY THEN
		(PLACE_.TOP;
			ADJPLACE_1);

	PB_.PLACE;		!PS IS TEMP AGAIN
	DO
		PB_.PB[POSTDOM]
	UNTIL .PB EQL .CSTMNT
	OR    .PB EQL .BOTTOM
	OR    .PB EQL .LEND
	OR    .PB EQL 0;
	IF .PB EQL 0 THEN SKERR();
	!THE GRAPH IS BAD CALL SKERR FOR NOW.
	IF .PB EQL .BOTTOM THEN SETPANGO;   !THIS WILL NOT BE CONSIDERED
	IF .PB EQL .LEND AND .CSTMNT NEQ .LEND THEN SETPANGO
	ELSE
	BEGIN
		!ONE MORE THING. (AINT THERE ALWAYS)
		!CHECK THE VIABILITY OF THE MOTION PLACE
		!AND ADJUST IT APPROPRIATELY
		PLACE_CHKVIABLPLACE(.PLACE);

		!THIS IS THE SAME AS XPUNGE
			HASHIT(.CNODE,.SHAPE);
		PHI_TBLSRCH();
		IF .FLAG THEN MATCHER(.CNODE,.SHAPE,.NAN,.PHI)
		ELSE
		BEGIN
			PHI_
			MAKETRY(.PHI,.CNODE);
			IF .SHAPE EQL SKEW THEN
			PHI[NBRCH]_1;
			IF .NAN THEN PHI[NEDSANEG]_1;
			IF .ADJPLACE THEN 
				PHI[STPT]_.LENTRY
			ELSE
				PHI[STPT]_.PLACE;
		END;
	END;
END;
!
!***************************************************
!

FORWARD LOCELMIO;
ROUTINE ELIM(STMT)=
BEGIN
	MAP BASE STMT;
	EXTERNAL CSTMNT,BACKST,TOP,LEND;
	MAP BASE TOP;
	MAP BASE BACKST;
	!CONTROLLING ROUTINE AT THE STATEMENT LEVEL FOR
	!COMMON SUB-EXPRESSION ELIMINATION, BOTH GLOBAL
	!AND LOCAL. ONLY STATEMENTS MENTIONED EXPLICITLY
	!IN THIS ROUTINE CAN EVEN POTENTIALLY HAVE
	!COMMON SUB-EXPRESSIONS.THOSE STATEMENT TYPES ARE:
	!ASSIGNMENT,LOGICAL IF, DO, ARITHMETIC IF,READ, WRITE.

	!IF WE ARE OPTIMIZING AND THIS STATEMENT IS A DO TERMINATOR
	!IF A NEST OF DOS AND IT CONTAINS COMPUTATION DO NOT
	!REDO COMMOON SUB STUFF ON IT.

	IF .FLGREG<OPTIMIZE> THEN
	BEGIN
		IF .STMT[SRCISN] NEQ 0 AND .STMT EQL .LEND
		AND .STMT[P2SDONE] AND NOT .TOP[INNERDOFLG] THEN
			RETURN;
	END;

	!ASSIGNMENT STATEMENTS
	IF .STMT[SRCID] EQL ASGNID THEN
		BEGIN
			PAE_.STMT[LHEXP];
			IF .PAE[OPRCLS] EQL ARRAYREF THEN
			REA(.PAE);
			REA(.STMT[RHEXP]);
		END;

	!LOGICAL IF
	IF .STMT[SRCID] EQL IFLID THEN
	BEGIN
		REA(.STMT[LIFEXPR]);
		IF NOT .FLGREG<OPTIMIZE> THEN
		BEGIN
			!THE SPECIAL CHECK IS NECESSARY TO
			!AVOID PROCESSING THE STATEMENT
			!FOLLOWING THE LOGICAL IF TWICE IN THE
			!GLOBAL CASE. THE TRUE BRANCH IS ON
			!THE PROCESSING LIST AS A SPEARATE ENTITY
			!BY ITSELF IN THE GLOBAL CASE.

			!HOOK ALL LOCALS FOUND SO FAR TO THE
			!IF PART

			LOCLDEPD();
			STMT[SRCCOMNSUB]_.BACKST[SRCLINK];
			BACKST[SRCLINK]_0;
			LOCLNK_0;

			CSTMNT_.STMT[LIFSTATE];
			ELIM(.STMT[LIFSTATE]);
		END;
	END;

	!DO STATEMENT
	IF .STMT[SRCID] EQL DOID THEN
	BEGIN
		REA(.STMT[DOLPCTL]);
	END;

	!ARITHMETIC IF
	IF .STMT[SRCID] EQL IFAID THEN
	BEGIN
		REA(.STMT[AIFEXPR]);
	END;

	!I/O STATEMENTS
	IF NOT .FLGREG<OPTIMIZE> THEN
	BEGIN
		IF .STMT[SRCID] EQL READID THEN
			LOCELMIO(.STMT);
		IF .STMT[SRCID] EQL WRITID THEN
			LOCELMIO(.STMT);
	END;
END;			!ELIM
!
!***************************************************
!
!
EXTERNAL BACKST; MAP PEXPRNODE BACKST;
!

OWN SAVCSTMNT;
GLOBAL ROUTINE LOCELIM(STMT)=
BEGIN
EXTERNAL CSTMNT,LOOPNO;
MAP PEXPRNODE STMT:CSTMNT;
!************************************
!CONTROL FOR LOCAL COMMONSUB-EXPRESSION ELIMINATION
!**************************************
	SAVCSTMNT_.CSTMNT;
	LOCLNK_0;
	STHASCMN_0;
	BACKST[SRCLINK]_0;
	LOOPNO_.CSTMNT[SRCISN];
	ELIM(.STMT);
	IF .STHASCMN THEN
	BEGIN
		LOCLDEPD();
		CSTMNT[SRCOPT]_.BACKST[SRCLINK];
	END;
	CSTMNT_.SAVCSTMNT;

	!THE ABOVE STATEMENT EITHER ZEROES THE POINTER TO COMMON
	!SUB-EXPRESSIONS OR SETS IT TO POINT TO THEM CORRECTLY
END;
!
!********************************************************
!
EXTERNAL EHASH; 
FORWARD FINDTHESPOT;
GLOBAL ROUTINE MOVCNST =
BEGIN
!MOVE ALL REGION CONSTANT EXPRESSIONS OUT OF THE LOOP
	EXTERNAL QQ;
	MAP BASE PB:QQ:PHI;
	LOCAL BASE CNODE;	!USED TO POINT TO EXPRESSION
	EXTERNAL LOKCALST;
	INCR K FROM 0 TO EHSIZ-1 DO
	BEGIN
		PHI_.EHASH[.K];
		WHILE .PHI NEQ 0 DO
		BEGIN
			!DONT MARK ENTRIES EMPTY HERE
			!ELSE SUBSTITUTION OF NARY NODES
			!WILL BE INCORRECT. INSTEAD DELETE AT
			!END.

			IF .PHI[STPT] EQL .LENTRY		!PLACE TO GO IS ENTRY
			AND
			.PHI[USECNT] EQL 1	!WASN'TA COMMON
							!SUB-EXPRESSION
			THEN
			BEGIN
				!MAKE AN ASSIGNMENT STATEMENT
				!OF .OXXXXX=EXPRESSION
				NAME<LEFT>_SRCSIZ+ASGNSIZ;
				PO_CORMAN();
				PO[OPRCLS]_STATEMENT;
				PO[SRCID]_ASGNID;
				!SET FLAG THAT SAYS P2S IS ALREADY DONE ON THIS
				PO[P2SDONE]_1;
				!LINK IT INTO TREE OUTSIDE LOOP
				!FINDTHESPOT RETURNS P1 POINTING 
				!TO THE PLACE TO LINK IT
				FINDTHESPOT(.LENTRY);
				PO[SRCLINK]_.P1[SRCLINK];
				P1[SRCLINK]_.PO;
				!LOOK AT THE EXPRESSION
				CNODE_.PHI[LKER];
				P1_		!JUST A TEMP
				PO[LHEXP]_GETOPTEMP(IF .CNODE[VALTYPE] EQL
					 CONTROL THEN LOGICAL ELSE .CNODE[VALTYPE]);
				PO[A1VALFLG]_1;
				!SET FLAG THAT SAYS THE TEMP HAS MOVED
				!OUT OF THE LOOP, SO TEMP BECOMES
				!UNRECYCLABLE
				P1[IDATTRIBUT(TOLENTRY)]_1;

				!IF THE EXPRESSION IS NARY MAKE A
				!STRAIGHT ONE, AND DO THE ELIMINATION
				!HASSLE (SEE MATCHER, NARY2 FOR
				!BLOODY DESCRIPTION OF THE COMPLETE HASSLE).
				IF .PHI[NBRCH] THEN
				BEGIN		!OMIGOD ITS NARY
					!ON THE OTHERHAND IT MAY
					!HAVE BEEN NARY BUT ISNT ANY
					!MORE. CHECK AND RESET NBRCH
					!FOR FUTURE TESTS.
					IF .CNODE[A1VALFLG] THEN
					BEGIN
						PHI[NBRCH]_0;
						!SET PB
						PB_.CNODE;
					END
					ELSE
					BEGIN		!U LOSE ITS NARY
						QQ_.CNODE[ARG1PTR];
						PB_MAKEPR(.CNODE[OPRCLS],
						.CNODE[OPERSP],
						.CNODE[VALTYPE],
						.CNODE[ARG2PTR],
						.QQ[ARG2PTR]);
						!SET THE VALFLGS
						PB[A1VALFLG]_1;
						PB[A2VALFLG]_1;
						!CAREFULLY COPY THE NEG
						!AND NOT FLAGS
						PB[A1NEGFLG]_.CNODE[A2NEGFLG];
						PB[A1NOTFLG]_.CNODE[A2NOTFLG];
						PB[A2NEGFLG]_.QQ[A2NEGFLG];
						PB[A2NOTFLG]_.QQ[A2NOTFLG];
						NARY2(.CNODE);
					END;
				END ELSE
				BEGIN
					!IT STRAIGHT, SO DO THE NARY/
					!STRAIGHT THING. ALSO SET UP PB
					STPRECLUDE(.CNODE);
					PB_.CNODE;
				END;

				!SET UP FOR LINKING THE REFERENCE
				T_.PO[LHEXP];
				PO[RHEXP]_.PB;

				!SET FLAG
				CNSTMOTFLG_1;
				CMNLNK(.CNODE,IF .PHI[NBRCH] THEN SKEW
						ELSE STGHT,0,
						.PHI);
				!RESET FLAG
				CNSTMOTFLG_0;
				!SET PARENT POINTER
				PB[PARENT]_.PO;
			END;		!IF STATEMENT
			!FIRST GET THE NEXT PHI. IF WE DELETE FIRST
			!CLINK WILL, BY DEFINITION, BE ZERO.
			!SO WE WILL PICK UP THE NEW PHI AND THEN DELETE
			!BUT SAVE THE OLD PHI FOR DELETION
			PO_.PHI;
			PHI_.PHI[CLINK];
			!NOW DELETE THE ENTRY
			DELETE(.PO,1);
		END;			!WHILE
	END;				!INCR
END;
ROUTINE REA(STKPAE)=
!PAE IS AN EXPRESSION POINTER
BEGIN
!THIS ROUTINE IS NAMED IN HONOR OF REA RAILWAY EXPRESS.
!***********************************
!
!AS IS NOT OBVIOUS IT DEALS WITH COMMON EXPRESSION ELIMINATION.
!IT DOES THE BASIC TREE WALK THROUGH THE TREES.
!IT IS CALLED BY ELIM AND CALLS XPUNGE TO HASH AND MATCH
!THE PHILOSOPHY BEHIND EACH SECTON OF CODE IS THE SAME.
!WALK THE TREE BASED ON THE SETTING OF THE VALFLGS (SAYS
!NODE UNDER HERE IS LEAF IS SET). WALK BRANCHES BEFORE LOOKING
!AT CURRENT NODE ITSELF.
!ALSO CHECK FOR THE SKEWED TREE CASE.

REGISTER PHAZ2 PAE;
PAE_.STKPAE;
STHASCMN_1;
CASE .PAE[OPRCLS] OF SET
!
!BOOLEAN
!
	BEGIN
			IF NOT .PAE[A1VALFLG] THEN REA(.PAE[ARG1PTR]);
			IF NOT .PAE[A2VALFLG] THEN REA(.PAE[ARG2PTR]);
			IF .PAE[A1VALFLG] AND .PAE[A2VALFLG] THEN XPUNGE(.PAE,STGHT)
			ELSE
			BEGIN
				
				QQ_.PAE[ARG1PTR];
				IF .QQ[OPERATOR] EQL .PAE[OPERATOR] 
				AND 		!N-ARY WITH LEAVES
				.QQ[A2VALFLG] AND .PAE[A2VALFLG] 
					AND NOT .QQ[PARENFLG] THEN
				XPUNGE(.PAE,PSKEW);
			END;			!ELSE PART SKEWED TREE
	END;				!BOOLEAN CLASS OPERATORS
!
!DATAOPR
!
		RETURN;		!DO NOTHING
!
!RELATIONAL
!
	BEGIN
		IF NOT .PAE[A1VALFLG] THEN REA(.PAE[ARG1PTR]);
		IF NOT .PAE[A2VALFLG] THEN REA(.PAE[ARG2PTR]);
		!LOCAL CASE TEST OB BACKST
		!GLOBAL CASE BACKST **MUST** BE ZERO (0)
		IF .BACKST NEQ 0 THEN
		BEGIN
			VARHOLDER_.PAE;
			IF .PAE[A1VALFLG] THEN
			BEGIN
				QQ_.PAE[ARG1PTR];
				IF .QQ[OPRCLS] EQL DATAOPR AND .QQ[OPERSP] NEQ CONSTANT THEN
					XPUNGE(.QQ,UNARY);
			END;
			IF .PAE[A2VALFLG] THEN
			BEGIN
				QQ_.PAE[ARG2PTR];
				IF .QQ[OPRCLS] EQL DATAOPR AND .QQ[OPERSP] NEQ CONSTANT  THEN
					XPUNGE(.QQ,UNARY);
			END;
		END ELSE
		!GLOBAL OPTIMIZER SHOULD FIND THEM
	
			IF .PAE[A1VALFLG] AND .PAE[A2VALFLG] THEN
				XPUNGE(.PAE,STGHT);
	END;


!
!FNCALL - FUNCTION CALL 
!
	BEGIN
		LOCAL ARGUMENTLIST TMP;
		!STEP THROUGH ARGUMENTS. EACH ARGEUMENT HAS THE FUNCTION
		!NODE AS PARENT
		TMP_.PAE[ARG2PTR];
			INCR I FROM 1 TO .TMP[ARGCOUNT] DO
			BEGIN
				QQ_.TMP[.I,ARGNPTR];
				REA(.QQ);
			END;
		!QQ_.PAE[ARG1PTR];
		!!TRY TO ELIMINATE LIBRARY FUNCTIONS WITH 1 ARGUMENT
	END;			!FNCALL
!
!ARITHMETIC
!
	BEGIN
		IF NOT .PAE[A1VALFLG] THEN REA(.PAE[ARG1PTR]);
		IF NOT .PAE[A2VALFLG] THEN REA(.PAE[ARG2PTR]);
		IF .PAE[A1VALFLG] AND .PAE[A2VALFLG] THEN XPUNGE(.PAE,STGHT)
		ELSE
		BEGIN
			QQ_.PAE[ARG1PTR];
			IF .QQ[OPR1] EQL .PAE[OPR1] AND
			.PAE[OPR1] NEQ DIVOPF
			AND NOT .QQ[PARENFLG]
			AND		!N-ARY WITH LEAVES
			.QQ[A2VALFLG] AND .PAE[A2VALFLG] THEN
			XPUNGE(.PAE,PSKEW);
			!LOOK DOWN ONCE MORE
			IF .PAE[A1VALFLG] AND .PAE[A2VALFLG] THEN
				XPUNGE(.PAE,STGHT);
		END;
	END;
!
!TYPCNV
!
	BEGIN
		IF NOT .PAE[A2VALFLG] THEN REA(.PAE[ARG2PTR]);
		IF .PAE[A2VALFLG] THEN XPUNGE(.PAE,UNARY);
	END;
!
!ARRAYREF
!
	BEGIN
		IF .PAE[ARG2PTR] EQL 0 THEN RETURN;
		IF .PAE[A2VALFLG] AND .BACKST NEQ 0 THEN
		!SPECIAL CASE FOR LOCAL ONLY
		BEGIN
			VARHOLDER_.PAE;
			QQ_.PAE[ARG2PTR];
			!ITS A NON-CONSTANT LEAF. CONSTANT LEAVES SHOULD HAVE
			!BEEN FOLDED INTO THE OFFSET.
			IF .QQ[OPRCLS] EQL DATAOPR AND .QQ[OPERSP] NEQ CONSTANT  THEN
				!THE NEG AND/OR NOT FLAGS CANNOT BE SET.
				!WE ARE NOT PREPARED TO HASH THEM. IN
				!GENERAL THIS WILL NOT PREVENT MUCH CUZ THE
				!FLAGS DONT MAKE A LOT OF SENSE ON THE SUBSCRIPT
				!ANYWAY.
				IF NOT .PAE[A2NEGFLG] AND NOT .PAE[A2NOTFLG] THEN
					XPUNGE(.QQ,UNARY);
		END ELSE
		REA(.PAE[ARG2PTR]);
	END;
	!
	!CMNSUB
	!
		RETURN;		!SHOULDNT HAPPEN
	!
	!NEGNOT
	!
		BEGIN
			IF NOT .PAE[A2VALFLG] THEN REA(.PAE[ARG2PTR]);
			IF .PAE[A2VALFLG] THEN XPUNGE(.PAE,UNARY);
		END;
	!
	!SPECOP
	!
		BEGIN
			IF NOT .PAE[A1VALFLG] THEN REA(.PAE[ARG1PTR]);
			IF .PAE[A1VALFLG] THEN XPUNGE(.PAE,UNARY);
		END;
	!
	!FIELDREF
	!
		RETURN;		!NOT IN RELEASE 1
	!
	!STORECLS
	!
		RETURN;
	!
	!REGCONTENTS
	!
		RETURN;
	!
	!LABOP
	!
		RETURN;
	!
	!STATEMENT
	!
		RETURN;
	!
	!IOLSCLS
	!
		RETURN;		!SEE REAIO
	!
	!INLINFN
	!
	BEGIN
		IF NOT .PAE[A1VALFLG] THEN REA(.PAE[ARG1PTR]);
		IF .PAE[A1VALFLG] THEN
			IF .PAE[ARG2PTR] EQL 0 THEN
				XPUNGE(.PAE,UNARY);
		IF NOT .PAE[A2VALFLG] THEN
			IF .PAE[ARG2PTR] NEQ 0 THEN
				REA(.PAE[ARG2PTR]);
		IF .PAE[A1VALFLG] AND .PAE[A2VALFLG] THEN
			XPUNGE(.PAE,STGHT);
	END;
TES;
END;
ROUTINE REAIO(CLSTCALL)=
BEGIN
	!EXAMINE THEN IOLSTCALL, E1LISTCALL, E2LISTCALL
	!FOR EXPRESSIONS TO HASH
	!CLSTCALL IS A POINTER TO AN I/O LIST.
	!WALK THAT TREE LOOKING FOR EXPRESSIONS TO EXPUNGE.
	MAP BASE CLSTCALL;
	LOCAL BASE P;
	IF .CLSTCALL[OPRCLS] EQL STATEMENT THEN RETURN;

	STHASCMN_0;
	CASE .CLSTCALL[OPERSP] OF SET
	!DATACALL
	BEGIN						!LEGAL ONLY RECURSIVELY
		P_.CLSTCALL[DCALLELEM];
		IF .P[OPRCLS] NEQ DATAOPR THEN
		REA(.P)
	END;
	!
	!SLISTCALL
	BEGIN						!LEGAL ONLY RECURSIVELY
		!NOTHING TO DO
	END;
	!
	!IOLSTCALL
	BEGIN
		P_.CLSTCALL[IOLSTPTR];
		WHILE .P NEQ 0 DO
		BEGIN
			REAIO(.P);
			P_.P[SRCLINK];
		END;
	END;
	!
	!E1LISTCALL
	;	!RELEASE >1
	!E2LISTCALL
	;	!RELEASE >1
	TES;
END;							!REAIO
GLOBAL ROUTINE LOCELMIO(PO)=
!CONTROL FINDING OF COMMON SUB EXPRESSIONS IN THE LOCAL CASE
!(ONLY ONE DONE FOR RELEASE ONE) IN I/O LISTS. CALLED BU ELIM.
!CALLS REAIO TO WALK TREES
BEGIN
	MAP BASE PO;
	REGISTER BASE IOLSTT;
	EXTERNAL BACKST;
	MAP BASE BACKST;

	IF .BACKST EQL 0 THEN RETURN;
	!RESET THE LINKING POINTER FOR LOCAL GOMMON SUBS.
	!THIS PRECLUDES LOCELMIO FROM EVER BEING USED RECURSIVELY
	!(CORRECTLY, THAT IS).
	LOCLNK_0;

	!PO POINTS AT IO STATEMENT

	!IN RELEASE 1 THERE IS NEVER A COMMON SUB ON AN I/O
	!STATEMENT ITSELF SO WE WILL ZERO THE FIELD. THIS
	!ALSO HELPS MAKE SURE THE GLOBALLY USED FIELDS ARE CLEARED.
	PO[SRCOPT]_0;

	!ROUTINE DOES LOCAL ELIMINATION ON IOLSTCALL (RELEASE 1)
	!E1LISTCALL AND E2LISTCALL (RELEASE >1)
	IF .PO[IOLIST] NEQ 0 THEN
	BEGIN
		IOLSTT_.PO[IOLIST];
		WHILE .IOLSTT NEQ 0 DO
		BEGIN
			IF .IOLSTT[OPRCLS] NEQ STATEMENT THEN
			BEGIN
				IF .IOLSTT[OPERSP] EQL IOLSTCALL THEN
				BEGIN
					REAIO(.IOLSTT);
					LOCLDEPD();
					IOLSTT[SRCCOMNSUB]_.BACKST[SRCLINK];
					BACKST[SRCLINK]_0;
					LOCLNK_0
				END;
			END;
			IOLSTT_.IOLSTT[CLINK];
		END;
	END;
END;
GLOBAL ROUTINE GLOBELIM=
BEGIN
	LOCAL PHAZ2 PO;
	EXTERNAL CSTMNT,LOOP,ISN,LENTRY;
	MAP BASE CSTMNT:LENTRY:TOP:PAE;
!********************************************
	!GLOBAL COMMON SUB-EXPRESSION ELIMINATION CONTROLLER
	!
!**************************************************

		CNSTMOTFLG_0;
		LSTWARNLINE_0;
	PO_.TOP;
	DO
	BEGIN
		CSTMNT_.PO;
		ISN_.CSTMNT[SRCISN];
		IF .PO[SRCID] NEQ DOID THEN
		ELIM(.PO);
		PO_.PO[BUSY];
	END UNTIL .PO EQL 0;
	!WE DO NOT WANT TO MOVE CONSTANT COMPUTATIONS IF THIS IS THE
	!MAIN PROGRAM
	!TO DO SO WOULD PESSIMIZE THE CODE.

	GLOBDEPD();
	IF .LOOP NEQ 0 THEN
	MOVCNST();

	!ONE MORE TINY ITEM TO CATCH. IF ANYTHING WAS
	!MOVED OUTSIDE OF THE LOOP AND THE LOOP WAS LABELED
	!WE MUST MOVE THE LABEL BACK TO THE ANYTHING.
	!THIS CODE IS HERE TO CATCH BOTH COMMON SUB-EXPFESSIONS
	!AND CONSTANT COMPUTATIONS.

	!SEE IF ANYTHING WAS MOVED
	IF .LENTRY[SRCLINK] NEQ .TOP THEN
	BEGIN
		!THE TEMP PAE POINTS TO THE STATEMENT THAT == ANYTHING
		PAE_.LENTRY[SRCLINK];
		!JUST AN EXTRA CHECK THAT THIS (PAE) IS NOT LABELED
		!AND OF COURSE THAT TOP IS LABELED.
		IF (.PAE[SRCLBL] EQL 0) AND (.TOP[SRCLBL] NEQ 0) THEN
		BEGIN
			!USE PO AS A TEMP TO POINT TO THE LABEL TABLE.
			!MOVE THE LABEL.
			!ZERO TOPS LABEL FIELD
			!FIX THE LABEL TABLE ENTRY.
			PO_
			PAE[SRCLBL]_.TOP[SRCLBL];
			TOP[SRCLBL]_0;
			PO[SNHDR]_.PAE;
		END;
	END;
END;
OWN EHASHP;

!THE FOLLOWING FEW ROUTINES ARE UTILITY ROUTINES FOR DEALING WITH
!THE EXPRESSION HAS TABLE.
GLOBAL ROUTINE TBLSRCH=
BEGIN
LABEL LOKER;
MAP PEXPRNODE P;
	LOCAL T;
	!LOOK UP AN EXPRESSION IN THE EXPRESSION HASH TABLE.
	!THE ROUITNE HASHIT HAS FILLED IN THE GLOBAL ENTRY
	!WITH THE PROPER PARAMETERS.
	!RETURNS FLAG IF FOUND 1
	!ELSE
	!POINTER TO ENTRY IF FOUND
	!USES GLOBALS ENTRY AND FLAG
	!IF FLAG IS SET TPREV POINTS TO
	!PREVIOUS ENTRY ON LIST IF ANY.  ZERO IF NONE
	T_ABS(.(ENTRY+2) XOR .(ENTRY+1)) MOD EHSIZ;
	EHASHP_EHASH[.T]<0,0>;
	IF .EHASH[.T] EQL 0 THEN
	BEGIN
		FLAG_0;
		TPREV_EHASH[.T]<0,0>;
		NEDCOR_1;
		RETURN(.TPREV);
	END ELSE
	P_.EHASH[.T];
	TPREV_.P;
	NEDCOR_0;
	LOKER:
	DO
	BEGIN
		IF .P[EMPTY] THEN LEAVE LOKER;
		PC_.P+1;
		IF @.PC EQL .(ENTRY+1) THEN
		BEGIN
			PC_.PC+1;
			IF @.PC EQL .(ENTRY+2) THEN
			BEGIN
			PC_.PC+1;
			IF @.PC EQL .(ENTRY+3) THEN
			BEGIN
				FLAG_1;
				RETURN(.P);
			END;
			END;
		END;
		TPREV_.P;
		P_.P[CLINK];
	END UNTIL .P EQL 0;		!EQL 0
	FLAG_0;
	IF .P EQL 0 THEN
		NEDCOR_1;
	RETURN(.TPREV);
END;

OWN THISBLK,MOREFLG;
GLOBAL ROUTINE MAKETRY (PLACE,CNODE)=
BEGIN
	EXTERNAL LOOPNO;
	OWN PHAZ2 ENTRYP;
	MAP PEXPRNODE CNODE;
	MAP PHAZ2 PLACE;
	!ENTERS AN ENTRY INTO HASH TABLE
	!PLACE POINTS TO WHERE IT GOES
	!ZERO MEANS WE NEED CORE FOR IT
	ENTRYP_ENTRY<0,0>;
	IF .NEDCOR THEN
	BEGIN
		NAME<LEFT>_6; PLACE_CORMAN();
		TPREV[CLINK]_.PLACE;
	END ELSE

	!IT IS POSSIBLE THAT PLACE POINTS TO A FULL ENTRY WHICH
	!POINTS TO AN EMPTY ENTRY. OBVIOUSLY, IT IS THE EMPTY
	!ENTRY THAT WE DESIRE TO USE.

	IF NOT .PLACE[EMPTY] THEN PLACE_.PLACE[CLINK];
	PLACE[USECNT]_1;
	PLACE[EMPTY]_0;
	PLACE[CMNFLGS]_0;
	PLACE[TEMPER]_0;
	PLACE[BLKID]_.LOOPNO;
	PLACE[HOP]_.ENTRYP[HOP];
	PLACE[HA1]_.ENTRYP[HA1];
	PLACE[HA2]_.ENTRYP[HA2];
	PLACE[HDEF1]_.ENTRYP[HDEF1];
	PLACE[HDEF2]_.ENTRYP[HDEF2];
	PLACE[LKER]_.CNODE;
	!THE SPECIAL CASE FOR LOCAL COMMON SUB-EXPRESSIONS OF A
	!SINGLE VARIABLE AS A SUBSCRIPT OF UNDER A RELATIONAL
	!SET TEMPER TO THE MODULE OWN VARHOLDER FOR LATER USE
	!IN UNRYMATCHER.
	!THIS IS THE ONLY PLACE WHERE A DATAOPR SHOULD OCCUR.
	IF .CNODE[OPRCLS] EQL DATAOPR THEN
		PLACE[TEMPER]_.VARHOLDER;
	.PLACE
END;

EXTERNAL PREV;
MAP PHAZ2 P:QQ:P1:PO:PREV;
GLOBAL ROUTINE DELETE(NOD,NUMB)=
BEGIN
	LOCAL T;
	MAP PHAZ2 NOD;
	!TPREV POINTS TO PREVIOUS MODE, IF ANY
	!NOD POINTS TO ENTRY IN HASH TABLE
	!LINK TO BEGINNING OF EMPTY LIST
	!THE TEMP T IS NECESSARY TO INSURE A CORRECT NEGATIVE VALUE
	LABEL ENDLOK;

	T_.NOD[USECNT]-.NUMB;
	!IF IS BECAME UNUSED
	IF .T LEQ 0 THEN
	BEGIN

		NOD[EMPTY]_1;
		NOD[USECNT]_0;
		PREV_.NOD[CLINK];		!PREV IS A TEMP
		IF .NOD[CLINK] EQL 0 THEN RETURN;
		IF .PREV[EMPTY] THEN RETURN;
			!LINK OUT ENTRY THAT BECAME EMPTY AND PUT IT AT
			!THE END OF THE LIST.
			!NOTE THAT TPREV WAS SET BY TBLSRCH TO POINT
			!TO THE ENTRY BEFORE NOD.
			ENDLOK:
			WHILE 1
			DO			!LOOK FOR END OF LIST
			BEGIN
				TPREV_.PREV;
				PREV_.PREV[CLINK];
				IF .PREV EQL 0 THEN
				BEGIN
					TPREV[CLINK]_.NOD;
					NOD[CLINK]_0;
					LEAVE ENDLOK;
				END ELSE
				IF .P[EMPTY] THEN
				BEGIN
					NOD[CLINK]_.PREV;
					TPREV[CLINK]_.NOD;
					LEAVE ENDLOK;
				END;
			END;
				IF @.EHASHP EQL .NOD THEN
					EHASH[.EHASHP-EHASH<0,0>]_.TPREV;
	END			!ENTRY GOING EMPTY
	ELSE	!PUT NEW COUNT INTO NODE
		NOD[USECNT]_.T;

END;
	!HASH NODE
	!
	! -----------------------------------
	! *                *                *
	! *     USECNT     *     CLINK      *
	! *		   *		    *
	! -----------------------------------
	! *		   *		    *
	! *  BLKID	   *    HOP	    *
	! *		   *		    *
	! -----------------------------------
	! *		   *		    *
	! *    HA1	   *     HA2	    *
	! *		   *		    *
	! -----------------------------------
	! *		   *		    *
	! *    HDEF1	   *     HDEF2	    *
	! *  		   *		    *
	!------------------------------------
	! *                *                *
	! *     TEMPER     *      LKER      *
	! *		   *		    *
	! -----------------------------------
	! *		   *		    *
	! *   NBRCH	   *	STPT	    *
	! *		   *		    *
	! -----------------------------------

!			FIRST BIT OF BLKID IS 1 IF BLOCK DELETED
!
!**********************************
!
ROUTINE FINDTHESPOT(PLACE)=
BEGIN
	MAP BASE PLACE;
	MAP BASE P1;

		!PUT AT THE END OF ALL OTHER
		!POSSIBLE STATEMENTS AT THIS
		!POINT
		!UNLESS THEY WERE PUT THERE WHILE PROCESSING AN
		!INNER MORE, EARLIER LOOP. IN WHICH CASE PUT IT
		!AT THE BEGINNING. THE TEST ON SRCOPT =0 IS THIS
		!INNER-MORE CONDITION NOT HOLDING.

		P1_.PLACE[SRCLINK];
		PREV_.PLACE;

			WHILE .P1[SRCISN] EQL 0
			 AND .P1[SRCID] EQL ASGNID
			AND .P1[SRCOPT] EQL 0  DO
			BEGIN
				PREV_.P1;
				P1_.P1[SRCLINK];
			END;
			P1_.PREV;
END;

ROUTINE GLOBMOV(CNODE,PLACE,OTEMP)=
!MOVE GLOBAL COMMON SUB-EXPRESSION TO FINAL RESTING PLACE.
BEGIN
	EXTERNAL LOOP;
	MAP BASE LOOP;
	LOCAL T;
	MAP PHAZ2 PLACE:T:OTEMP:CNODE;
!CALLED BY GLOBAL OPTIMIZER ONLY.
!CNODE WILL POINT TO THE COMMON SUB-EXPRESSION ITSELF. (NOT
!A COMMON SUB-EXPRESSION **NODE**.
!PLACE POINTS TO THE PLACE WHERE THE STATEMENT THAT IS BUILT
!WILL BE LINKED IN. OTEMP IS THE LHS OF THE STATEMENT.

!THE BASIC FUNCTION OF THE ROUTINE IS TO BUILD T=CMNSB STATEMENT
!AND LINK IT INTO THE ENCODED SOURCE TREE.
		IF .PLACE EQL .LENTRY THEN
		BEGIN
			!SET FLAG TO SAY THAT IT
			!GOES OUT OF SCOPE
			OTEMP[IDATTRIBUT(TOLENTRY)]_1;
		END ELSE
		!IF THIS IS A NESTED LOOP SET TOLENTRY ANYWAY.
		BEGIN
			!FIRST IS IT A PROGRAM LOOP
			IF .LOOP NEQ 0 THEN
				!DO DEPTH TREE HOLDS LEVEL.
				!ONE MEANS NONE NESTED IN IT.
				IF .LOOP[LEVEL] NEQ 1 THEN
					OTEMP[IDATTRIBUT(TOLENTRY)]_1;
		END;

		!GENERATE
		!  T=EXPRESSION NODE
		!MAKE SOURCE NODE

		NAME<LEFT>_SRCSIZ+ASGNSIZ;
		PO_CORMAN();
		PO[OPRCLS]_STATEMENT;
		PO[SRCID]_ASGNID;
		PO[A1VALFLG]_1;

		!RETURNS P1 POINTING TO THE PLACE TO
		!PUT IT.
		FINDTHESPOT(.PLACE);
		!LINK IT IN

		PO[SRCLINK]_.P1[SRCLINK];
		P1[SRCLINK]_.PO;
		!PTR TO CMNSUB
		PO[RHEXP]_.CNODE;
		!****NOTE****
		!CANNOT SET EXPRESSION PARENT
		!AS TEMP IS NOT YET LINKED
		!BACK IN. MUST SET PARENT IN
		!GLOBLDEPD
		PO[LHEXP]_.OTEMP;
		PO[P2SDONE]_1;
END;
ROUTINE LOCLMOV(CNODE)=
BEGIN
	!CALLED ONLY IN THE LOCAL COMMON SUB-EXPRESSION ELIMINATION
	!CASE. TEMPER IN THIS CASE POINTS TO A COMMON SUB-
	!**EXPRESSION NODE**. A LINKED LIST OF SUCH IS MADE AT
	!LOCLNK, BACKST POINTS TO THE TOP OF THE LIST.


	MAP BASE CNODE;
	MAP BASE LOCLNK:BACKST;

	IF .LOCLNK EQL 0 THEN
	BEGIN
		LOCLNK_.CNODE;
		BACKST[SRCLINK]_.CNODE;
	END ELSE
	BEGIN
		LOCLNK[SRCLINK]_.CNODE;
		CNODE[SRCLINK]_0;
		LOCLNK_.CNODE;
	END;
END;
!
!
!TEMPORARY HANDLING BY THE OPTIMIZER
!NOT VERY SOPHISTICATED OR FAST

!
GLOBAL ROUTINE GETOPTEMP(VTYP)=			!GET A TEMPORARY FOR THE OPTIMIZER
!THE SCHEME IS CRUDELY THIS:
!	VERYFRST (NOT MNUMONIC OR APROPRIATE BUT THERE) IS A COUNTER
!	A NAME IS MADE WITH .OVERYFRST. IF IT IS IN THE TABLE WITH
!	TO ENTRY SET IT IS NOT USED AND VERYFRST IS INCREMENTED UNTIL
!	EITHER AN OLD ENTRY THAT IS NOT USED IS FOUND OR A NEW
!	ENTRY IS MADE. VERYFRST IS REINITIALIZED TO ZERO BY
!	DOCOLLAPSE.

BEGIN
	EXTERNAL TBLSEARCH;


	EXTERNAL NOFRTEMP,FRSTLNK,VERYFRST;
	LOCAL HEAD;
	MAP BASE HEAD;

	NAME_IDTAB;
	WHILE 1 DO
	BEGIN
		ENTRY_SIXBIT'.O'+MAKNAME(VERYFRST);
		!LOOK IT UP IN THE SYMBOL TABLE
		HEAD_TBLSEARCH();
		!IF ITS THERE
		IF .FLAG THEN
		BEGIN
			!IF IT WAS USED TO MOVE SOMETHING OUT OF
			!A LOOP (TOLENTRY IS SET) OR ALREADY USED IN THIS
			!CURRENT LOOP (IDDIM = TOP) THEN DONT REUSE IT NOW
			IF .HEAD[IDATTRIBUT(TOLENTRY)] OR .HEAD[IDDIM] EQL .TOP THEN
				VERYFRST_.VERYFRST+1
			ELSE
			BEGIN
				!VALUE TYPE MUST BE THE SAME OR DONT REUSE IT
				IF .HEAD[VALTYPE] EQL .VTYP THEN
				BEGIN
					!SET THE FIELD IDDIM TO THIS LOOP
					!TO PREVENT LATER ERRONEOUS REUSE.
					HEAD[IDDIM]_.TOP;
					RETURN(.HEAD);
				END ELSE
					VERYFRST_.VERYFRST+1;
			END;
		END ELSE	!ITS NOT IN THE SYMBOL TABLE
		BEGIN
			!FILL IN THE FIELDS VALTYPE AND IDDIM.
			HEAD[VALTYPE]_.VTYP;
			VERYFRST_.VERYFRST+1;
			HEAD[IDDIM]_.TOP;
			RETURN(.HEAD);
		END;
	END;
END;

!********************************************************
MACRO OPTMP(NOD)=
	.NOD[OPRCLS] EQL DATAOPR AND .NOD[IDDOTO] EQL SIXBIT".O"$;
ROUTINE ARGCMN(ANODE,LG)=
BEGIN
	!LG IS LOCAL - GLOBAL SWITCH.
	!ANODE SHOULD BE EITHER A POINTER TO A CMNSUB NODE (LOCAL)
	!OR AN OPTIMIZER CREATED VARIABLE STARTING WITH .O (GLOBAL)
	!THE ROUTINE RETURNS 1 IF EITHER OF THESE CONDITIONS IS TRUE.
	!IF IT IS RETURNING A ONE THE GLOBAL QQ ALSO CONTAINS THE
	!USECNT FIELD OF THE HASH TABLE ENTRY;

	EXTERNAL QQ;
	MAP BASE ANODE:T;

	IF .LG THEN
	BEGIN
		IF OPTMP(ANODE) THEN
		BEGIN
			QQ_.ANODE[EXPRUSE];
			RETURN(1);
		END
		ELSE
			RETURN(0)
	END ELSE	!LG=0(LOCAL)
	BEGIN
		IF .ANODE[OPRCLS] EQL CMNSUB THEN
		BEGIN
			QQ_.ANODE[EXPRUSE];
			RETURN(1);
		END
		ELSE
			RETURN(0);
	END;

END;

ROUTINE LOK1SUBS(CNODE,LG)=
BEGIN
	!DETERMINE IF ARG1 OF CNODE IS A :
	!	CMNSUB NODE (IF LG=0)
	!	A .O TEMP (IF LG=1)
	!THIS IS THE CONTROLLING CASE. THE REAL WORK IS DONE BY ARGCMN.
	!THIS ROUTINE RETURNS THE LOGICAL VALUE RETURNED TO IT BY
	!ARGCMN.

	MAP PEXPRNODE CNODE;

	RETURN(

	CASE .CNODE[OPRCLS] OF SET

		ARGCMN(.CNODE[ARG1PTR],.LG);	!BOOLEAN
		0;				!DATAOPR
		ARGCMN(.CNODE[ARG1PTR],.LG);	!RELATIONAL
		0;				!FNCALL
		ARGCMN(.CNODE[ARG1PTR],.LG);	!ARITHMETIC
		0;				!TYPECNV
		0;				!CMNSUB
		0;				!NEGNOT
		ARGCMN(.CNODE[ARG1PTR],.LG);	!SPECOP
		0;				!FIELDREF
		0;				!STORCLS
		0;				!REGCONTENTS
		0;				!LABOP
		0;				!STATEMENT
		0;				!IOLCLS
		ARGCMN(.CNODE[ARG1PTR],.LG)	!INLINFN
		TES);
END;

ROUTINE LOK2SUBS(CNODE,LG)=
BEGIN
	!FUNCTIONS EXACTLY THE SAME AS LOK1SUBS, EXCEPT ON
	!ARG2 OF CNODE.

	MAP BASE CNODE;

	RETURN(
	CASE .CNODE[OPRCLS] OF SET

		ARGCMN(.CNODE[ARG2PTR],.LG);	!BOOLEAN
		0;				!DATAOPR
		ARGCMN(.CNODE[ARG2PTR],.LG);	!RELATIONAL
		0;				!FNCALL
		ARGCMN(.CNODE[ARG2PTR],.LG);	!ARITHMETIC
		ARGCMN(.CNODE[ARG2PTR],.LG);	!TYPECNV
		0;				!ARRAYREF
		0;				!CMNSUB
		ARGCMN(.CNODE[ARG2PTR],.LG);	!NEGNOT
		0;				!SPECOP
		0;				!FIELDREF
		0;				!STORCLS
		0;				!REGCONTENTS
		0;				!LABOP
		0;				!STATEMENT
		0;				!IOLCLS
		BEGIN				!INLINFN
			IF .CNODE[ARG2PTR] NEQ 0 THEN
				ARGCMN(.CNODE[ARG2PTR],.LG)
		END
	TES);
END;

ROUTINE DELLNK(CNODE)=
BEGIN
	!REMOVE COMMON SUB-EXPRESSION CNODE FROM THE LINKED LISTOF
	!SAME HEADED BY BACKST.

	EXTERNAL BACKST;
	MAP BASE BACKST:PREV:P1:CNODE;

	!INITIALIZE THINGS
	PREV_.BACKST;
	P1_.BACKST[SRCLINK];

	!LOOK THROUGH THE LIST
	WHILE .P1 NEQ 0 DO
	BEGIN
		IF .P1 EQL .CNODE THEN
		BEGIN
			PREV[SRCLINK]_.CNODE[SRCLINK];
			RETURN;
		END;
		PREV_.P1;
		P1_.P1[SRCLINK];
	END;
END;
ROUTINE LOCLDEPD=
BEGIN
	!EXAMINE LINKED LIST OF COMMON SUB-EXPRESSIONS. BACKST
	!IS THE HEAD OF THE LIST. EXPRESSIONS ARE ORDERED
	!FROM THE BOTTOM - UP IN THE TREE SENSE.
	!THIS IS THE CONTROLLING ROUTINE FOR THE GENERAL PROCESS:
	!	DETERMINE IF EACH EXPRESSION HAS OTHER COMMON-SUBS UBDER IT
	!	IF SO, LOOK THESE UP IN THE HASH TABLE.
	!	IF THE USE COUNT OF THE SUBORDINATE = THE USECNT OF
	!	THE PARENT, THEN REMOVE THE LITTLE ONE, AND ITS
	!	COMMON SUB-EXPRESSION NODE.

	OWN PEXPRNODE EXPR;
	MAP BASE T:PAE;
	EXTERNAL BACKST;
	MAP BASE BACKST;

	EXPR_.BACKST[SRCLINK];

	!FOR EACH EXPRESSION ON THE LIST
	WHILE .EXPR NEQ 0 DO
	BEGIN
		IF .EXPR[A2VALFLG] THEN
			HASHIT(.EXPR[ARG2PTR],UNARY)
		ELSE
			HASHIT(.EXPR[ARG2PTR],STGHT);
		!LOOK UP THE EXPRESSION IN THE HASH TABLE
		PHI_TBLSRCH();
		!IF THERE ARE COMMON SUBS UNDER IT
		IF .PHI[CMNUNDER] THEN
		BEGIN
			!LOOK AT EACH ARG OF THE EXPRESSION.
			!FIRST LOOK AT REAL EXPRESSION
			PAE_.EXPR[ARG2PTR];

			!LOK1SUBS AND LOK2SUBS RETURN 1 IF WE ARE
			!INTERESTED IN THIS ONE AND THE USE COUNT IN THE
			!GLOBAL QQ

			IF LOK1SUBS(.PAE,0) THEN
				IF .QQ EQL .PHI[USECNT] THEN
				BEGIN
					T_.PAE[ARG1PTR];
					PAE[ARG1PTR]_.T[ARG2PTR];
					!RESET VALFLGS 
					PAE[A1VALFLG]_0;
					DELLNK(.T);
					!ALSO FIX PARENT
					T_.PAE[ARG1PTR];
					T[PARENT]_.PAE;
				END;
			IF LOK2SUBS(.PAE,0) THEN
				IF .QQ EQL .PHI[USECNT] THEN
				BEGIN
					T_.PAE[ARG2PTR];
					PAE[ARG2PTR]_.T[ARG2PTR];
					!RESET VALFLG
					PAE[A2VALFLG]_0;
					DELLNK(.T);
					!FIX PARENT TOO
					T_.PAE[ARG2PTR];
					T[PARENT]_.PAE;
				END;
		END;
		EXPR_.EXPR[SRCLINK];
	END;			!WHILE
	!CLEANUP THE EXPRESSION NODES THAT HAVE EXPRUSE LEFT IN THEM

	EXPR_.BACKST[SRCLINK];
	WHILE .EXPR NEQ 0 DO
	BEGIN
		EXPR[EXPRUSE]_0;
		EXPR_.EXPR[SRCLINK];
	END;
	!ALSO GO THROUGH THE HAS TABLE AND MARK THE ENTRIES EMPTY
	!THIS IS NECESSARY EVEN USING THE ISN AS BLKID, AS
	!ATATEMENTS INSERTED BY SUCH THINGS AS DO LOOPS
	!WILL HAVE ISN ZERO AND MATCH, WHEN THEY SHOULDNT

	DECR I FROM EHSIZ-1 TO 0 DO
	BEGIN
		EXPR_.EHASH[.I];
		WHILE .EXPR NEQ 0 DO
		BEGIN
			EXPR[EMPTY]_1;
			EXPR_.EXPR[CLINK];
		END;
	END;
END;
	
%*****************
	THIS MACRO CHECKS FOR THE CONDITIONS THAT THE ASSIGNMENT STATEMENT
	WAS CREATED BY THE OPTIMIZER FOR GLOBAL COMMON SUB-EXPRESSION ELIMINATION
*******************%
MACRO OPTCMN(NOD)=
BEGIN
	REGISTER BASE TMP;
	IF .NOD[SRCISN] EQL 0 AND .NOD[SRCID] EQL ASGNID
	THEN
	BEGIN
		TMP_.NOD[LHEXP];
		IF NOT .PAE[A2VALFLG] AND OPTMP(TMP) THEN
		1 ELSE 0
	END ELSE	0
END$;


ROUTINE GLOBDEPD=
BEGIN
	!FOR GLOBAL OPTIMIZATION ONLY
	!LOOK FOR GROUPS OF STATEMENTS CREATED BY THE OPTIMIZER
	!FOR COMMON SUB-EXPRESSION ELIMINATION.
	!WHEN FOUND, LOOK AT GLOBAL COMMON SUB TEMPS, HASH
	!THE EXPRESSIONS TO WHICH THEY CORRESPOND, LOOK THEM UP.
	!IF USECNT OF DEPENDENT ONE = USECNT OF PARENT ONE THEN
	!SEE IF THE DEPENDENT ONE IS IN THIS GROUP OF STATEMENTS
	!. IF THAT IS TRUE THEN ELIMINATE THE DEPENDENT ONE.

	MAP BASE PAE:T:P1:PO:TPREV:PHI;

	EXTERNAL SAVSPACE,TOP,LEND,QQ,LOOP,LENTRY;
	LABEL WHL1,WHL2;

	!MACRO TO SET PARENT POINTERS STRAIGHT

	MACRO SETDAD=
	BEGIN
		IF .PAE[SRCID] EQL ASGNID THEN
			IF NOT .PAE[A2VALFLG] THEN
			BEGIN
				PO_.PAE[RHEXP];
				PO[PARENT]_.PAE;
			END;
	END$;
	OWN GHEAD,SAVTOP;

	SAVTOP_.TOP;		!SAVE VALUE OF TOP


	!ADJUST PARENT POINTERS TWIXT LENTRY AND TOP
	PAE_.LENTRY;
	WHILE .PAE NEQ .TOP DO
	BEGIN
		SETDAD;
		PAE_.PAE[SRCLINK];
	END;

	!IF THIS IS A MAIN PROGRAM, ALL THE GOODIES ARE LINKED
	!BETWEEN LENTRY AND TOP AND WILL NEVER BE LOOKED AT
	!AGAIN IF WE DONT DO IT NOW. SO WE WILL ADJUST TOP TO BE
	!LENTRY IF THIS IS A MAIN PROGRAM.

	IF .LOOP EQL 0 THEN
	BEGIN
		PAE_.LENTRY; PREV_.LENTRY;
	END ELSE
	BEGIN
		PAE_.TOP;
		PREV_.TOP;
	END;

	WHILE .PAE NEQ .LEND DO
	BEGIN
		!PARENT POINTERS COULD NOT BE SET EARLIER. MAKE SURE
		!THEY ARE SET NOW. NEED TO LOOK ONLY AT OPTIMIZER
		!CREATED ASSIGNMENTS BUT WILL DO IT FOR ALL
		!ASSIGNMENTS AS EXTRA ASSURANCE.

		GHEAD_.PAE;
		!FOR ALL THOSE IN THIS GROUP THAT WE ARE INTERESTED IN
		WHILE OPTCMN(PAE) DO
		BEGIN
			PO_.PAE[RHEXP];
			!NOW, SET THE PARENT OF THE EXPRESSION
			PO[PARENT]_.PAE;
			HASHIT(.PO,STGHT);
			PHI_TBLSRCH();
			IF .PHI[CMNUNDER] THEN
			BEGIN
				IF LOK1SUBS(.PO,1) THEN
				BEGIN
					!COMPARE USECNTS
					IF .QQ EQL .PHI[USECNT] AND .QQ GEQ 2 THEN
					BEGIN
						TPREV_.PREV;
						P1_.GHEAD;
						WHL1:
						!LOOK FROM THE START OF THE GROUP TO HERE
						WHILE .P1 NEQ .PAE DO
						BEGIN
							IF .P1[LHEXP] EQL
								.PO[ARG1PTR] THEN
							BEGIN
								TPREV[SRCLINK]_.P1[SRCLINK];
								T_.PO[ARG1PTR];
								PO[ARG1PTR]_.T[IDADDR];
								PO[A1VALFLG]_0;
								!FIX PARNET
								T_.PO[ARG1PTR];
								T[PARENT]_.PO;
								IF .P1 EQL .GHEAD THEN
								GHEAD_.P1[SRCLINK];
								SAVSPACE(ASGNSIZ+SRCSIZ-1,.P1);
								LEAVE WHL1;
							END;
							TPREV_.P1;
							P1_.P1[SRCLINK];
						END;
					END;
				END;
				!THAT WAS THE FIRST ARG, NOW THE SECOND
				!LOKXSUBS RETURNS YHE USECNT OF THE DEPENDENT
				!EXPRESSION IN QQ.
				IF LOK2SUBS(.PO,1) THEN
				BEGIN
					IF .QQ EQL .PHI[USECNT] AND .QQ GEQ 2 THEN
					BEGIN
						TPREV_.PREV;
						P1_.GHEAD;
						WHL2:
						!LOOK FROM THE START TO THIS ONE
						WHILE .P1 NEQ .PAE DO
						BEGIN
							IF .P1[LHEXP] EQL
							.PO[ARG2PTR] THEN
							BEGIN
								TPREV[SRCLINK]_.P1[SRCLINK];
								T_.PO[ARG2PTR];
								PO[ARG2PTR]_.T[IDADDR];
								!RESET VALFLG
								PO[A2VALFLG]_0;
								!FIX PARENT
								T_.PO[ARG2PTR];
								IF .P1 EQL .GHEAD THEN
								GHEAD_.P1[SRCLINK];
								T[PARENT]_.PO;
								SAVSPACE(ASGNSIZ+SRCSIZ-1,.P1);
								LEAVE WHL2;
							END;
							TPREV_.P1;
							P1_.P1[SRCLINK];
						END;
					END;
				END;
			END;		!PHI[CMNUNDER]
			PAE_.PAE[SRCLINK];
		END;
		IF .PAE EQL .LEND THEN RETURN;
		PREV_.PAE;
		PAE_.PAE[SRCLINK];
	END;
	!CLEANUP THE SYMBOL TABLE ENTRIES
	DECR I FROM SSIZ-1 TO 0 DO
	BEGIN
		PAE_.SYMTBL[.I];
		WHILE .PAE NEQ 0 DO
		BEGIN
			IF .PAE[IDDOTO] EQL SIXBIT".O" THEN
				PAE[TARGET]_0;
			PAE_.PAE[SRCLINK];
		END;
	END;
	!RESTORE THE VALUE OF TOP
	TOP_.SAVTOP;
END;
  @b