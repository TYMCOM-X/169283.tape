GLOBAL BIND TABLV=111;		!VERSION DATE 12-JULY-73
!EDITED 2-OCT-72 -FI
!EDITED AUG 30,1972 - SRM
!EDITED AUG 25,1972 - SRM
!EDITED AUG 24,1972 (22:45) - SRM
!EDITED AUG 24,1972 - SRM
!EDITED AUG 18, 1972 (21:15) - SRM
!EDITED AUG 14,1972 - SRM
!EDITED AUG 10, 1972 - SRM
!EDITED AUG 9,1972 - SRM


!COPYRIGHT 1972,1973, DIGITAL EQUIPMENT CORPORATION, MAYNARD MA**
!AUTHOR: S. MURPHY
!

BIND DEBUGFLG=1;			!COMPILE SWITCH TO LEAVE CONSISTENCY CHECKS IN

%(****************************************
	TO OPTIMALLY TEST WHOLE-WD FLAGS FOR TRUE AND FALSE
****************************************)%
BIND	TRUE= -1,
	FALSE= 0;
MACRO	TRUTH(X)= X NEQ 0$,
	FALSITY(X)= X EQL 0$;

BIND	AOBINCR=#1000001;			!INCREMENT FOR AOBJN


%(****************************************
	DEFINE BYTES FOR WHOLE, LEFT HALF, AND RIGHT HALF
****************************************)%
MACRO 	WHOLE=0,36$ ;

		
%(**********************************************************************
	STRUCTURE FOR AN EXPRESSION NODE
************************************************************************)%



%(************************************************************
	DEFINE THE FIELDS AND SUBFIELDS IN AN EXPRESSION NODE
************************************************************)%

BIND EXOPWD=1;			!WORD IN WHICH THE OPERATOR FIELD
					! AND FLAGS FIELD
					! ARE CONTAINED (USE A MACRO ONLY BECAUSE
					! WHEN THIS NUMBER CHANGES A LARGE
					! NUMBER OF SUBFIELD DEFINITIONS
					! MUST BE CHANGED)
%(*****DEFINE MAIN FIELDS****************************)%
MACRO
	FIRSTWORD=0,0,FULL$,
	PARENT=0,0,RIGHT$,		!PTR TO PARENT-NODE
	OPERATOR=0,EXOPWD,RIGHT$,		!OPERATOR FIELD
	EXPFLAGS=0,EXOPWD,LEFT$,	
	OPERWORD=0,EXOPWD,WHOLE$,
	TARGET=0,2,WHOLE$,
	ARGWD=0,3,WHOLE$,			!WD HOLDING PTRS TO THE 2 ARGS
	ARGWDOFFSET=3$,
	ARG1PTR=0,3,LEFT$,
	ARG2PTR=0,3,RIGHT$;
MACRO
	COMPLEXITY=0,0,LEFT$;		!THIS FIELD IS USED ONLY DURING REGISTER ALLOCATION

%(**********SUBFIELDS IN OPERATOR FIELD*************************)%
MACRO
	VALTYPE=0,EXOPWD,13,5$,		!TYPE FOR VALUE
	OPRCLS=0,EXOPWD,8,5$,		!CLASS OF OPERATOR
	OPERSP=0,EXOPWD,5,3$,		!SPECIFIC OPERATOR WITHIN CLASS


	%(***NOTE THAT OF THE 3 FREE BITS AT THE RIGHT END OF THE OPERATOR FIELD,
		BIT 35 IS USED AS A SPECIAL FLAG BIT IN
		1. TYPE-CONVERSION NODES: FLAG FOR NO CONVERSION
	*******)%

	%(***SUBFIELDS OF OPERSP FIELD*****)%
	OPRSP1=0,EXOPWD,6,2$,		!1ST 2 BITS OF OPERSP (THIS FIELD IS 00 FOR
					! ADD AND SUB, 01 FOR MUL AND DIV
	OPRSP2=0,EXOPWD,5,2$,		!LAST 2 BITS OF OPERSP FIELD -
					! USED TO DIFFERENTIATE ADD,SUB,MUL,DIV
					! ALSO USED IN TYPE CONVERSION NODES TO DIFFERENTIATE
					! FROMINT, FROMREL, FROMDBLPRC,
					! FROMCMPLX
	OPRSBIT0=0,EXOPWD,7,1$,		!1ST BIT OF OPERSP FIELD - FOR AN ARITH
					! NODE, THIS BIT IS SET ONLY FOR OPERSP EXPONEN
					! FOR A TYPE-CONVERSION NODE THIS BIT IS SET
					! FOR FROMINT,FROMREAL,FROMDBLPRC,FROMCMPLX
					!  AND NOT SET FOR FROMOCT,FROMCTL,FROMLIT,FROMDOCT
	OPRSBIT2=0,EXOPWD,5,1$,		!3RD BIT OF OPERSP FIELD - FOR AN ARITH
					! NODE, THIS BIT IS SET ONLY FOR SUB AND MUL
	OPR1=0,EXOPWD,5,8$,		!OPRCLS AND OPERSP FIELDS CONCATENATED
	OPR2=0,EXOPWD,6,7$;		!OPRCLS FIELD AND 1ST 2 BITS OF OPERSP FIELD

	%(***SUBFIELDS OF THE ABOVE "MAIN" SUBFIELDS***)%
MACRO
	VALTP1=0,EXOPWD,15,2$,		!MIDDLE 2 BITS OF VALTYPE ARE
					! ALL THATS NEEDED FOR GETA1OPIX AND ARITHOPIX
	VALTP2=0,EXOPWD,15,3$,		!FIRST 3 BITS OF VALTYPE ARE
					! IDENTICAL TO THE OPERSP FIELD FOR A TYPECNV
					! NODE TO CONVERT FROM THAT VALTYPE
	DBLFLG=0,EXOPWD,16,1$,		!THE 2ND BIT OF VALTYPE IS FLAG
					! FOR 2 WD VAL (DOUBLE PREC OR COMPLEX)
	SDBLFLG=0,EXOPWD,6,1$;		!THE 2ND BIT OF OPERSP FOR A
					!NODE OF OPRCLS "TYPECNV" IS FLAG FOR SOURCE
					!IS A 2 WD VAL

MACRO
	BOOLOPR=0,EXOPWD,5,2$,		!BOOLEAN OPERATOR IS SPECIFIED BY RIGHT
					! 2 BITS OF OPERSP FIELD
	BOOLCLS=0,EXOPWD,6,1$,		!BOOLEAN CLASS (AND/OR OR XOR/EQV) IS
					! SPECIFIED BY THE LEFTMOST OF THESE 2
	BOPRFLG=0,EXOPWD,5,1$;		!THE 2ND DIVIDES BOOLEANS INTO 2 OTHER
					! CLASSES - OR/XOR AND AND/EQV

MACRO	PARENLSTFLG=0,EXOPWD,7,1$;	!FLAG FOR NAME WHICH SHOULD HAVE
					! AN ARGLST FOLLOWING (THIS BIT IS
					! 1ST BIT OF OPERSP FIELD OF A DATA ITEM)
MACRO	FORMLFLG=0,EXOPWD,5,1$;	!IN OPERSP FIELD FOR A DATA ITEM, FLAG
					! FOR "FORMAL" (NOTE HOWEVER THAT THIS BIT
					! IS ALSO SET IN THE OPERSP FIELD OF A TEMPORARY)

	%(****MACRO TO CONSTRUCT AN "OPR1" FIELD*****)%
MACRO
	OPR1C(OPCLS,OPSP)=(OPCLS^3 OR OPSP)$;
MACRO	OPR2C(OPCLS,OPSP)=(OPCLS^2 OR OPSP^(-1))$;

	%(****TO CONSTRUCT AN OPERATOR FIELD****)%
MACRO OPERC(VTYP,OPCLS,OPSP)=(VTYP^13 OR OPCLS^8 OR OPSP^5)$;

	%(***TO GET A VALTP1 FIELD FROM A VALTYPE****)%
MACRO	VTP1(VLTP)=(VLTP^(-2) AND (#3))$;


	%(***TO GET A VALTP2 FIELD (FIRST 3 BITS) FROM A VALTYPE***)%
MACRO	VTP2(VLTP)=(VLTP^(-2))$;







%(*******FLAGS IN EXPFLAG FIELD (THESE ARE SET BY PHASE 2 SKEL AND USED BY PHASE 3*******)%
MACRO
	PARENFLG=0,EXOPWD,35,1$,		!FLAG FOR PARENS AROUND THIS NODE (IN SOURCE)
	RVRSFLG=0,EXOPWD,33,1$,			!"VAL OF 2ND SON SHOULD BE
						! COMPUTED BEFORE 1ST SON
	STOREFLG=0,EXOPWD,32,1$,		!RESULT MUST BE STORED AFTER IT IS COMPUTED
	RESRFFLG=0,EXOPWD,31,1$,		!FLAG FOR "UNDER THIS NODE THERE IS A
						! REFERENCE TO THE VAR INTO WHICH THE RESULT
						! OF THE WHOLE EXPRESSION WILL BE STORED
	FNCALLSFLG=0,EXOPWD,30,1$,		!FLAG FOR "FN CALLS OCCUR UNDER THIS
						! NODE
	ALCRETREGFLG=0,EXOPWD,29,1$,		!VAL OF THIS NODE IS TO BE COMPUTED
						! IN THE "FN RETURN REG" 
	A1VALFLG=0,EXOPWD,28,1$,		!FIRST ARG IS A COMMON SUBEXPR THAT 
						! WAS ALREADY COMPUTED ELSEWHERE
						! OR A LEAF
	LABLARGS=A1VALFLG$,			!SET ON A CALL STATEMENT
						!ONLY TO  INDICATE THERE
						!ARE LABEL ARGS
	TRUEISBR=A1VALFLG$,			!SET ONLY ON LOGICAL IF
						!TO INDICATE THE THE TRUE
						!BRANCH IS A BRANCH.
	A1NOTFLG=0,EXOPWD,27,1$,		!APPLY 'NOT' TO 1ST ARG
	A1NEGFLG=0,EXOPWD,26,1$,		!NEGATE 1ST ARG
	A1SAMEFLG=0,EXOPWD,25,1$,		!LOC OF COMPUTATION FOR PARENT EQLS
						! LOC OF VALUE OF FIRST ARG
	A1IMMEDFLG=0,EXOPWD,24,1$,		!1ST ARG IS IMMED CONSTANT
	A2VALFLG=0,EXOPWD,23,1$,		!2ND ARG IS A COMMON SUBEXPR THAT WAS ALREADY
						! COMPUTED ELSEWHERE
						! OR A LEAF
	A2NOTFLG=0,EXOPWD,22,1$,		! APPLY NOT TO 2ND ARG
	A2NEGFLG=0,EXOPWD,21,1$,		!NEGATE 2ND ARG
	A2SAMEFLG=0,EXOPWD,20,1$,		!LOC OF COMPUTATION FOR PARENT EQLS 
						! LOC OF VALUE OF 2ND ARG
	A2IMMEDFLG=0,EXOPWD,19,1$,		!2ND ARG IS AN IMMED CONSTANT
	MEMCMPFLG=0,EXOPWD,18,1$;		!VALUE COMPUTED TO MEMORY

MACRO	CSFULLWDFLG=RVRSFLG$;		!IN A COMMON SUBEXPR NODEWHERE THE
					! COMMON-SUBEXPR IS A SINGLE VARIABLE (EG A
					! VAR USED IN RELATIONALS OR SUBSCRIPTS)
					! THIS FLAG IS SET IF THE WHOLE VARIABLE MUST BE LOADED
					! (EG IT IS USED IN A RELATIONAL), RATHER
					! THAN THE RIGHT-HALF BEING USABLE REGARDLESS OF
					! WHATS IN THE LEFT HALF (EG IT IS USED AS A SS ONLY)


	%(***DEFINE SUBFIELDS OF THE FLAGS FIELD***)%

	%(*****FLAGS FOR EACH OF THE 2 ARGS***)%
MACRO
	A1FLGS=0,EXOPWD,24,5$,
	A2FLGS=0,EXOPWD,19,5$;

	%(****LAST 4 FLAGS - NEG, NOT, SAME, IMMED****)%
	MACRO
		A1FLG1=0,EXOPWD,24,4$,
		A2FLG1=0,EXOPWD,19,4$;
	%(***A2IMMEDFLG CONCATENATED WITH MEMCMPFLG***)%
	MACRO A2IMMEMCMPFLGS=0,EXOPWD,18,2$;

	%(***NEG AND NOT FLAGS******************)%
	MACRO
		A1NGNTFLGS=0,EXOPWD,26,2$,
		A2NGNTFLGS=0,EXOPWD,21,2$;

	%(****TO CLEAR THE FLAGS FOR ARG1, OR FOR ARG2*****)%
	MACRO CLRA1FLGS(ANODE)=
		ANODE[EXPFLAGS]_.ANODE[EXPFLAGS] AND (NOT #003700)$;

	MACRO CLRA2FLGS(ANODE)=
		ANODE[EXPFLAGS]_.ANODE[EXPFLAGS] AND (NOT  #000076)$;

	%(******TO SWAP THE FLAGS FOR ARG1 AND ARG2 (WHEN ARE ALSO SWAPPIG THE 2 ARGS******)%

	%(***VALUE FOR A1FLGS OR A2FLGS FIELD WHEN ONLY THE VAL FLG IS SET***)%
BIND	VLFLSET=#20;

MACRO
	SWAPFLGS(NODE) =
	BEGIN
		REGISTER T1;
		T1_.NODE[A1FLGS];
		NODE[A1FLGS]_.NODE[A2FLGS];
		NODE[A2FLGS]_.T1;
	END $;

	%(****TO SET THE FLAGS FOR ARG1 TO THOSE FOR ARG2 AND CLEAR THOSE FOR ARG2 ****)% 
	MACRO A2TOA1FLGS(NODE)=
	BEGIN
		NODE[A1FLGS]_.NODE[A2FLGS];
		CLRA2FLGS(NODE);
	END$;

	%(***TO MOVE FLAGS FOR A SON INTO THE FLAG FIELD OF ITS PARENT (WHEN
		LINKING THE SON DIRECTLY UP TO THE PARENT'S PARENT***)%
MACRO
	RAISEFLGS(PARFLGS,SONFLGS)=
	BEGIN
		REGISTER T1;
		T1_(PARFLGS XOR SONFLGS) AND NGNTFLGMSK;	!TAKE XOR OF NEGFLGS AND 
								! NOTFLGS OF PARENT AND SON
		.T1 OR (SONFLGS AND VLIMSMMSK)		!USE VALFLG, SAMEFLG 
								! AND IMMEDFLG FOR SON
	END$;

	%(***MASK FOR NEG AND NOT FLAGS WITHIN A1FLGS/A2FLGS FIELDS***)%
BIND	NGNTFLGMSK=#14;

	%(***MASK FOR VALFLG,SAMEFLG, AND IMMEDFLG FIELDS WITHIN A1FLG/A2FLG FIELDS***)%
BIND	VLIMSMMSK=#23;




%(*********SUBFIELDS OF TARGET FIELD***********)%
MACRO
	INREGFLG=0,2,35,1$,		!FLAG FOR VAL LEFT IN A REG
	TARGTAC=0,2,23,4$,		!AC TO BE COMPUTED IN
	TARGAUX=0,2,27,4$,		!EXTRA AC TO COMPUTE IN, USED FOR
					! RELATIONALS (WHICH ARE "COMPUTED" IN A DIFFERENT
					! REG FROM THE ONE THAT HOLDS THE VALUE)
	TARGTMEM=0,2,0,23$,		!MEMORY REF TO GET AT FINAL RESULT
	TARGADDR=0,2,0,18$,		!ADDRESS FIELD FOR RETRIEVING RESULT
	TARGXF=0,2,18,4$,		!INDEX FIELD FOR RETRIEVING RESULT
	TARGIF=0,2,22,1$,		!INDIRECT FIELD FOR RETRIEVING RESULT
	TARGIXF=0,2,18,5$;		!INDIRECT AND INDEX FIELDS
%(***TO GET TARGTAC, TARGXF,  OR TARGAUX FIELD FROM A TARGET WD INTO THE AC BITS OF AN INSTR***)%
%(****OR TO GET TARGET-REG FOR AN ASSIGNMENT-STATEMENT NODE INTO THE AC BITS OF AN INSTR***)%
MACRO	GETTAC(NODE)=(.NODE[TARGET] AND #17^23)$,
	GETTXF(NODE)=((.NODE[TARGET] AND #17^18)^5)$,
	GETTAUX(NODE)= ((.NODE[TARGET] AND #17^27)^(-4))$,
	GETASMNREG(STMNTNODE)= (.STMNTNODE[CW4] AND #17^23)$,
	GETAIFREG(AIFNODE)=(.AIFNODE[CW5] AND #17^23)$;

	%(***GET THE INDEX AND INDIRECT BITS OF A TARGET WD***)%
MACRO GETTXFI(NODE)=(.NODE[TARGET] AND #37^18)$;


MACRO	IXFLD(REG)=REG^18$;



%(************************************************************
	DEFINE THE STRUCTURE FOR AN EXPRESSION NODE
************************************************************)%
STRUCTURE PEXPRNODE[FTP,WD,POS,SIZE]=

	%(***THE ARG "FTP" SELECTS THE ACCESSING ALGORITHM***)%
	CASE .FTP OF SET

		%(****FOR MOST FIELDS****)%
		(@.PEXPRNODE+.WD)<.POS,.SIZE>


		TES;





%(********************************************************
	VALUES FOR SUBFIELDS OF OPERATOR FIELD
************************************************************)%

%(*******VALUES FOR VALTYPE FIELD*****)%
BIND
	OCTAL=0,		!00000
	LOGICAL=1,		!00001
	CONTROL=4,		!00100 - CONTROL-TYPE BOOLEAN
	DOUBLOCT=8,		!01000
	LITERAL=12,		!01100
	INTEGER=16,		!10000
	BYTE=17,		!10001
	INDEX=18,		!10010
	REAL=20,		!10100
	DOUBLPREC=24,		!11000
	COMPLEX=28;		!11100 

	%(**NOTE THAT IN THE ABOVE THE 2ND BIT IS A FLAG FOR
		DOUBLE WD***)%
	%(***NOTE ALSO THAT THE 2ND AND 3RD  BITS DETERMINE THE CODE TO BE
		GENERATED IN MANY CASES (WHERE INDEX,BYTE,LOG ARE 
		TREATED AS INTEGER); AND THAT THESE 2 BITS ARE
		REFERENCED AS THE FIELD "VALTP1" *******)%
	%(***NOTE ALSO THAT IF THE FIRST 3 BITS OF THE VALTYPES OF 2 NODES
		ARE IDENTICAL, NO TYPE-CONVERSION OPERATION IS  NECESSARY
		WHEN COMBINING THE 2 NODES ARITHMETICALLY 
	*****)%
	%(***NOTE ALSO THAT THE OPERSP FIELD FOR A TYPE CONVERSION NODE IS EQUAL
		TO THE FIRST 3 BITS OF THE ORIGINAL TYPE
	****)%


	%(***VALUES FOR VALTP1 FIELD (BITS 2 AND 3  OF VALTYPE)***)%
BIND
	INTEG1=VTP1(INTEGER);	!00

	%(***VALUES FOR VALTP2 FIELD (BITS 1,2,3 OF VALTYPE)***)%
BIND
	LOGICAL2=LOGICAL^(-2),
	REAL2=REAL^(-2);


	%(***TO TEST WHETHER A GIVEN VALTYPE IS DOUBLE-WD***)%
MACRO	DBLFROMVAL(VLTP)=
	(VLTP^(-3) AND 1)$;


	%(***TO TEST WHETHER A VALTYPE IS ONE THAT IS NEVER "CONVERTED", 
		IE IS ALWAYS USED AS A BIT PATTERN. THE TYPES THAT THIS IS TRUE
		OF  ARE:  LOGICAL,OCTAL,DOUBLE-OCTAL,LITERAL, AND CONTROL***)%
MACRO	BITPTNVALTYP(VLTP)=
	VLTP LSS INTEGER$;




%(******VALUES FOR OPRCLS FIELD********)%
BIND
	BOOLEAN=0,		!00000
	DATAOPR=1,		!00001
	RELATIONAL=2,		!00010
	FNCALL=3,		!00011
	ARITHMETIC=4,		!00100
	TYPECNV=5,		!00101
	ARRAYREF=6,		!00110
	CMNSUB=7,		!00111
	NEGNOT=8,		!01000
	SPECOP=9,		!01001		;A SPECIAL CASE TO BE OPTIMIZED
						!(P2MUL,SQUARE,...)
	FIELDREF=10,		!01010
	STORECLS=11,		!01011
	REGCONTENTS=12,		!01100
	LABOP=13,		!01101
	STATEMENT=14,		!01110
	IOLSCLS=15,		!01111		;ELEMENT IN AN IOLIST
	INLINFN=16;		!10000		;A FN TO BE GENERATED IN LINE


%(********VALUES FOR OPERSP FIELD**************)%

	%(****FOR OPRCLS BOOLEAN****)%
BIND
	ANDOP=0,		!000
	OROP=1,		!001
	EQVOP=2,		!010
	XOROP=3;		!011

	%(***BIT 35 OF EXOPWD IS USED AS A FLAG IN A BOOLEAN NODE FOR "ARG2HAS VALTYPE
		CONTROL, ARG1 IS A MASK" ****)%



	%(****FOR OPRCLS DATA ITEM****)%
BIND
	CONSTANT=0,		!000
	TEMPORARY=1,		!001
	VARIABLE=2,		!010
	FORMLVAR=3,		!011
	ARRAYNAME=4,		!100
	FORMLARRAY=5,		!101
	FNNAME=6,		!110
	FORMLFN=7;		!111

	%(***DEFINE SUBFIELD OF OPERSP FOR DATA-ITEMS THAT DIFFERENTIATES
		FN AND FORMAL FN FROM ARRAY AND FORML ARRAY FROM VAR AND FORML VAR***)%
	MACRO	DATOPS1=OPRSP1$;	!FIRST 2 BITS OF OPERSP

	%(***DEFINE VALUES OF DATOPS1 FIELD***)%
BIND	VARIABL1=1,
	ARRAYNM1=2,
	FNNAME1=3;

	%(***TO TEST FOR AN DATA ITEM AN ENTRY IN THE SYMBOL TABLE (AS OPPOSED TO A 
		CONSTANT OR TEMPORARY*****)%
MACRO	SYMBOL(NODE)=(.NODE[OPERSP] GEQ VARIABLE)$;

	%(****FOR OPRCLS RELATIONAL****)%
BIND
	L=1,			!001
	E=2,			!010
	LE=3,			!011
	GE=5,			!101
	N=6,			!110
	G=7;			!111

MACRO
	EQREL(MODE) = (MODE AND #1) EQL 0$;		!E AND N  HAVE LAST BIT=0

MACRO
	REVREL(M) = M XOR #6$;			!"REVERSE" RELATIONAL FROM M (EG FOR
						! REVREL(GE) GET LE )
MACRO
	CMREL(M)= M XOR 4$;			!TO GET "COMPLEMENT" OF A CONDITION

	%(****FOR OPRCLS FNCALL****)%
BIND
	NONLIBARY=0,		!NOT A LIBRARY FUNCTION
	LIBARY=1;		!A LIBARY FUNCTION

	%(****FOR OPRCLS ARITHMETIC****)%
BIND
	ADDOP=0,		!000
	SUBOP=1,		!001
	MULOP=2,		!010
	DIVOP=3,		!011
	EXPONOP=4;		!100

	%(***TO TRANSFORM ADD TO SUB, SUB TO ADD; MUL TO DIV, DIV TO MUL***)%
MACRO
	CMPLSP(NODE)=
		(NODE[OPERATOR]_.NODE[OPERATOR] XOR #40)$;	!CHANGE RIGHTMOST BIT OF OPERSP
								! (RIGHTMOST BIT OF OPERSP IS 
								! 5 BITS FROM RIGHT END OF
								! OPERATOR FIELD

	%(***TEST FOR OPERATOR EITHER ADD OR SUB****)%
MACRO
	ADDORSUB(NODE) = .NODE[OPR2] EQL OPR2C(ARITHMETIC,ADDOP)$;
	%(***TEST FOR OPERATOR FIELD EITHER MUL OR DIV***)%
MACRO
	MULORDIV(NODE) = .NODE[OPR2] EQL OPR2C(ARITHMETIC,MULOP)$;

	%(***TO TEST FOR OPERATOR (*KNOWN TO BE ARITH*) EQUAL TO EXPONENTIATION***)%
MACRO
	EXPONEN(NODE) = .NODE[OPRSBIT0]$;	!FIRST BIT OF OPERSP FIELD

	%(***TO TEST FOR OPERATOR (*KNOWN TO BE ARITH*) EQUAL TO SUB OR DIV****)%
MACRO
	SUBORDIV(NODE)= (.NODE[OPRSBIT2])$;	!3RD BIT OF OPERSP FIELD IS SET FOR
						! DIV AND SUB

	%(***TO TEST FOR AN OPERATOR (OF UNKNOWN OPRCLS) EQUAL TO ADD OR MUL****)%
MACRO 
	%(***OPRCLS MUST BE ARITHMETIC, OPERSP MUST HAVE ITS 1ST AND 3RD BITS 0****)%
	ADDORMUL(NODE)=((.NODE[OPERWORD] AND (#37^8 OR #5^5)) EQL (ARITHMETIC^8))$;


	%(*****TO TEST FOR A NODE OF UNKNOWN OPRCLS TO BE COMMUTATIVE - 
		VAL IS TRUE FOR ALL BOOLEANS AND FOR ADD AND MUL*********)%
MACRO	COMMUTATIVE(NODE)=
	(.NODE[OPRCLS] EQL BOOLEAN OR ADDORMUL(NODE) )$;
 


	%(****FOR OPRCLS TYPECNV****)%
BIND
	FROMOCT=0,		!000
	FROMCTL=1,		!001
	FROMDOCT=2,		!010
	FROMLIT=3,		!011
	FROMINT=4,		!100
	FROMREAL=5,		!101
	FROMDBLPRC=6,		!110
	FROMCMPLX=7;		!111

	%(***NOTE THAT THIS FIELD IS EQUAL TO THE FIRST 3 BITS OF THE VALTYPE
		FIELD FOR THE VALUE BEING CONVERTED FROM(THE VALTYPE FIELD 
		ON THIS NODE SPECIFIES THE TYPE TO CONVERT TO)****)%


MACRO
	NOCNVFLG=0,EXOPWD,0,1$;		!BIT 35 OF EXOPWD IS USED AS A FLAG FOR "NO ACTUAL
					! CONVERSION TAKES PLACE"

	%(***TEST WHETHER ANY CODE MUST BE GENERATED FOR A GIVEN TYPE-CONVERSION NODE***)%
	MACRO NOCNV(TPCNODE)=
	BEGIN
		(
		(.TPCNODE[NOCNVFLG])		!IF FLAG WAS SET TO NOT ACTUALLY CONVERT
		OR
		(.TPCNODE[VALTP2] EQL .TPCNODE[OPERSP])
		OR
		(	(.TPCNODE[OPERSP] LSS FROMINT)	!CONVERTING FROM LOGICAL/OCTAL
							! OR DOUBLE-OCTAL OR CONTROL OR LITERAL
			AND
			( (NOT .TPCNODE[DBLFLG]) OR .TPCNODE[SDBLFLG])	!AND IF THE DESTIN IS
									!DBL WD, SO IS THE SRC
		)
		)
		AND (NOT .TPCNODE[A2IMMEDFLG])	!IF THE ARG UNDER THE TYPE-CNV
						! IS THE RIGHT HALF OF AN AOBJN VAR,
						! MUST LOAD IT
	END$;



	%(***FOR OPRCLS NEGNOT***************************)%
BIND
	NEGOP=0,
	NOTOP=1;

	%(****FOR OPRCLS SPECOP (SPECIAL OPS INTRODUCED BY PHASE 2 SKEL)***)%
BIND
	P2MULOP=0,		!MULTIPLY BY A POWER OF 2
	P2DIVOP=1,		!DIVIDE BY A POWER OF 2
	P2PL1OP=2,		!MULTIPLY BY A POWER OF 2 PLUS 1
	SQROP=3,		!SQUARE (RAISE TO POWER OF 2)
	CUBOP=4,		!CUBE (RAISE TO POWER OF 3)
	P4OP=5,			!RAISE TO POWER OF 4
	EXPCIOP=6;		!RAISE TO A  CONSTANT INTEGER POWER
				! (NOT HANDLED IN RELEASE 1)


	%(***FOR OPRCLS STORECLS****************************)%
BIND
	STARVAL=0,		!STORE CONTENTS OF AN ARRAY ELEM
	STARADDR=1;		!STORE PTR TO AN ARRAY ELEMENT


	%(***FOR OPRCLS IOLSCLS (FOR IOLIST ELEMENTS)***)%
BIND
	DATACALL=0,
	SLISTCALL=1,
	IOLSTCALL=2,
	S1LISTCALL=3,			!AN SLISTCALL DETECTED IN PHASE 2 SKEL -
					! MAY HAVE MORE THAN ONE ARRAYREF
					! (NOT IN RELEASE 1)
	ELISTCALL=4;			! NOT IN RELEASE 1


	%(***FOR OPRCLS INLINFN (FNS TO BE GENERATED IN LINE)****)%
BIND
	ABSFN=0,
	SIGNFN=2,
	DIMFN=3,
	MODFN=4,
	MAXFN=5,
	MINFN=6;

	%(***MACRO TO DETERMINE FOR A GIVEN IN-LINE-FN WHETHER THE ARG SHOULD BE PUT
		INTO THE REG-FOR-COMPUTATION BEFORE THE VAL IS COMPUTED (FOR ABS,IABS
		AND SIGN, DO NOT WANT TO LOAD THE ARG IN ADVANCE) ****)%
	MACRO ILFINRFC(OPSP)=(OPSP GEQ DIMFN)$;




	%(****VALS FOR OPR1 FIELD FOR SOME OF THE OPERATORS*****)%
BIND
	ADDOPF=OPR1C(ARITHMETIC,ADDOP),
	SUBOPF=OPR1C(ARITHMETIC,SUBOP),
	MULOPF=OPR1C(ARITHMETIC,MULOP),
	DIVOPF=OPR1C(ARITHMETIC,DIVOP),
	EXPONOPF=OPR1C(ARITHMETIC,EXPONOP),
	CONSTFL=OPR1C(DATAOPR,CONSTANT),
	VARFL=OPR1C(DATAOPR,VARIABLE),
	NEGFL=OPR1C(NEGNOT,NEGOP),
	MODFNFL=OPR1C(INLINFN,MODFN),
	STARVLFL=OPR1C(STORECLS,STARADDR),
	SLISTCLFL=OPR1C(IOLSCLS,SLISTCALL);BIND
	P2MULOPF=OPR1C(SPECOP,P2MULOP),
	P2DIVOPF=OPR1C(SPECOP,P2DIVOP),
	P2PL1OPF=OPR1C(SPECOP,P2PL1OP);
BIND
	SQROPF=OPR1C(SPECOP,SQROP),
	CUBOPF=OPR1C(SPECOP,CUBOP),
	P4OPF=OPR1C(SPECOP,P4OP);
BIND
	EXPCIF=OPR1C(SPECOP,EXPCIOP);


	%(***VALUES OF OPERATOR FIELD FOR SOME OF THE OPERATORS***)%
BIND	REALCONST=OPERC(REAL,DATAOPR,CONSTANT),
	INTCONST=OPERC(INTEGER,DATAOPR,CONSTANT),
	DOUBLCONST=OPERC(DOUBLPREC,DATAOPR,CONSTANT),
	CPLXCONST=OPERC(COMPLEX,DATAOPR,CONSTANT),
	LITCONST=OPERC(LITERAL,DATAOPR,CONSTANT),
	INTVAR=OPERC(INTEGER,DATAOPR,VARIABLE),
	INDEXVAR=OPERC(INDEX,DATAOPR,VARIABLE);
BIND	INTDIVIDE=OPERC(INTEGER,ARITHMETIC,DIVOP);

BIND	ABSFNOP=OPERC(REAL,INLINFN,ABSFN),
	IABSFNOP=OPERC(INTEGER,INLINFN,ABSFN),
	SIGNFNOP=OPERC(REAL,INLINFN,SIGNFN),
	ISIGNFNOP=OPERC(INTEGER,INLINFN,SIGNFN),
	DIMFNOP=OPERC(REAL,INLINFN,DIMFN),
	IDIMFNOP=OPERC(INTEGER,INLINFN,DIMFN),
	MODFNOP=OPERC(INTEGER,INLINFN,MODFN),
	MAXFNOP=OPERC(INTEGER,INLINFN,MAXFN),
	MINFNOP=OPERC(INTEGER,INLINFN,MINFN),
	AMAXFNOP=OPERC(REAL,INLINFN,MAXFN),
	AMINFNOP=OPERC(REAL,INLINFN,MINFN);

BIND	CMPLXOP=OPERC(COMPLEX,TYPECNV,FROMREAL),
	DBLEOP=OPERC(DOUBLPREC,TYPECNV,FROMREAL),
	DFLOATOP=OPERC(DOUBLPREC,TYPECNV,FROMINT),
	FLOATOP=OPERC(REAL,TYPECNV,FROMINT),
	IDINTOP=OPERC(INTEGER,TYPECNV,FROMDBLPRC),
	INTOP=OPERC(INTEGER,TYPECNV,FROMREAL),
	IFIXOP=OPERC(INTEGER,TYPECNV,FROMREAL),
	REALOP=OPERC(REAL,TYPECNV,FROMCMPLX),
	SNGLOP=OPERC(REAL,TYPECNV,FROMDBLPRC);


BIND	LTOP=OPERC(CONTROL,RELATIONAL,L),
	EQOP=OPERC(CONTROL,RELATIONAL,E),
	LEOP=OPERC(CONTROL,RELATIONAL,LE),
	GEOP=OPERC(CONTROL,RELATIONAL,GE),
	NEOP=OPERC(CONTROL,RELATIONAL,N),
	GTOP=OPERC(CONTROL,RELATIONAL,G);

BIND	FIXOP=OPERC(INTEGER,TYPECNV,FROMREAL);
BIND	IOLSTCFL=OPERC(0,IOLSCLS,IOLSTCALL),
	DATACLFL=OPERC(0,IOLSCLS,DATACALL);

BIND	DOSTATEMENT=STOPERC(STATEMENT,DOID);
BIND	CONTSTATEMENT=STOPERC(STATEMENT,CONTID);

	


%(********VALUES FOR SPECIAL OPERATOR SUBFIELDS***********)%

	%(****USED FOR OPRCLS BOOLEAN*****)%
BIND
	ANDORCLS=0,		!VALUE OF BOOLCLS FOR AND/OR NODES
	ANDOPF=0,		!VALUE OF BOPRFLG FOR AND/EQV NODES
	XOROROPF=1;		!VALUE OF BOPRFLG FOR OR/XOR NODES



%(****************************************
	TO CHECK FOR VALUES THAT FIT IN SINGLE WD
****************************************)%
MACRO	SINGLWD(NODE)= NOT (.NODE[DBLFLG])$;


%(***************************************************************************
	TO TEST A CONSTANT NODE FOR BEING AN IMMEDIATE-SIZE CONSTANT
***************************************************************************)%


MACRO IMMEDCNST(NODE)=
BEGIN
	EXTERNAL KDPRL;		!THESE GLOBALS ARE USED IN CALLING THE MACRO MODULE
	EXTERNAL C1H,C1L,C2H,COPRIX;	! THAT ROUNDS REAL NUMBERS
	EXTERNAL CNSTCM;

	CASE .NODE[VALTP1] OF SET
	%(***INTEGER CONSTANTS ARE IMMED SIZE IFF ABSOLUTE VAL IS LESS THAN 777777***)%
	(ABS(.NODE[CONST2]) LEQ #777777);
	%(***REAL CONSTANTS ARE IMMED SIZE IFF THE RIGHT HALF WD IS
		ALL 0'S*******)%
	BEGIN
		%(***BECAUSE WE KEEP 2 WDS OF PRECISION THRUOUT COMPILE TIME,
			WE MUST EXAMINE WHAT THE ROUNDED CONSTANT WILL BE***)%
		C1H_.NODE[CONST1]; C1L_.NODE[CONST2]; COPRIX_KDPRL;	!ROUND THE NUMBER IN C1H-C1L
		CNSTCM();						! LEAVING THE RESULT IN C2H
		(.C2H AND #777777) EQL 0
	END;
	%(***DOUBLE-PREC CONSTANTS CAN NOT BE TREATED IMMED MODE***)%
	FALSE;
	%(***COMPLEX CONSTANTS CAN BE TREATED IMMED MODE IFF THE REAL PART IS
		IMMED SIZE AND THE IMAGINARY PART IS 0***)%
	((.NODE[CONST1] AND #777777) EQL 0) AND (.NODE[CONST2] EQL 0)
	TES
END$;

%(***TO TEST FOR A CONSTANT NEGATIVE***********)%
MACRO NEGATIVC(CNNODE)=
	BEGIN
		IF .CNNODE[VALTP1] EQL INTEG1
		THEN
		.CNNODE[CONST2] LSS 0
		ELSE
		.CNNODE[CONST1] LSS 0
	END$;







%(*****************OPCODE FIELDS USED EXPLICITLY***************************)%
BIND
	JRSTOC=#254^27,
	JUMPOC=#320^27,
	SKIPOC=#330^27,
	SKIPGEOC=#335^27;
BIND
	INDBIT=1^22;		!INDIRECT BIT

BIND	
	ADDBOCD=#273,
	ADDIOCD=#271,
	ADDMOCD=#272,
	AOJAOCD=#344,
	AOSOCD=#350,
	ASHOCD=#240,
	CAIOCD=#300,
	CAMOCD=#310,
	DMOVEOCD=#120,
	DMOVEMOCD=#124,
	FADRBOCD=#147,
	FADRMOCD=#146,
	FDVRMOCD=#176,
	FIXOCD=#122,
	FLTROCD=#127,
	FSCOCD=#132,
	HRLZIOCD=#515,
	IDIVMOCD=#232,
	IMULMOCD=#222,
	JRSTOCD=#254,
	JUMPOCD=#320,
	JUMPGEOCD=#325,
	JUMPLOCD=#321,
	MOVEIOCD=#201,
	MOVEOCD=#200,
	MOVEMOCD=#202,
	MOVNIOCD=#211,
	MOVNMOCD=#212,
	MOVNSOCD=#213,
	MOVSIOCD=#205,
	SETCAMOCD=#452,
	SETCMBOCD=#463,
	SETZBOCD=#403,
	SETOBOCD=#477,
	SKIPOCD=#330,
	SOJAOCD=#364,
	SOSOCD=#370,
	SUBIOCD=#275,
	SUBMOCD=#276;

%(***************************************************************************	
	DEFINE THE FIELDS OF THE NODES USED FOR IOLISTS (OPRCLS=IOLSCLS)
***************************************************************************)%

	%(***FIELDS IN ALL IOLSCLS NODES***)%
MACRO
	IOLSTLBL=0,0,LEFT$;
	%(***FIELDS IN DATACALL NODES***)%
MACRO
	DCALLELEM=0,1,LEFT$;

	%(***FIELDS IN SLISTCALL NODES***)%
MACRO
	SCALLELEM=0,1,LEFT$,
	SCALLCT=0,2,RIGHT$;

	%(****NOTE THAT FOR IOLSTCALL NODES, S1LISTCALL NODES, AND ELISTCALL NODES,
		THE 3RD WORD (0,2,LEFT AND 0,2,RIGHT) IS USED FOR SRCCMPLX AND
		SRCCOMNSUB *****)%



	%(***FIELDS IN IOLSTCALL NODES***)%
MACRO
	IOLSTPTR=0,1,LEFT$;

	%(***FIELDS IN S1LISTCALL AND ELISTCALL NODES***)%
MACRO
	ECNTPTR=0,3,LEFT$,		!PTR TO EXPRESSION FOR NUMBER OF ELEMS
					! OF EACH ARRAY TO BE PROCESSED

	ELSTPTR=0,1,LEFT$;

	%(***FIELDS IN S1LIST NODES***)%
MACRO
	S1INCR=0,3,RIGHT$;

	%(***FIELDS OF THE ELEMENTS OF THE LINKED LIST UNDER AN E2LISTCALL***)%
MACRO
	E2INCR=0,1,LEFT$,		!PTR TO EXPRESSION FOR INCREMENT TO BE
					! USED FOR THIS ARRAY
	E2ARREFPTR=0,1,RIGHT$;		!PTR TO ARRAYREF NODE





%(***************************************************************************
	DEFINE AN OBJECT-CODE WORD AS A STRUCTURE.
	DEFINE THE FIELDS OF THAT WORD FOR FOROTS ARG BLOCKS.
***************************************************************************)%

STRUCTURE OBJECTCODE[WD,POS,SIZE]=
   (.OBJECTCODE+.WD)<.POS,.SIZE> ;



	%(***DEFINE THE FIELDS OF AN INSTRUCTION***)%
MACRO
	OBJADDR=0,0,18$,	!ADDRESS FIELD
	OBJIXF=0,18,5$,		!INDIRECT AND INDEX FIELDS
	OBJREG=0,23,4$,		!REGISTER FIELD
	OBJOPCOD=0,27,9$;		!OPCODE
	%(***DEFINE THE FIELDS USED FOR FOROTS ARG BLOCKS***)%
MACRO
	OTSWHOLE=0,0,36$,
	OTSCNT=0,27,9$,
	OTSTYPE=0,23,4$,		!VALUE-TYPE ALWAYS GOES IN BITS 9-12
	OTSINX=0,18,4$,		!INDEX FIELD
	OTSIND=0,22,1$,		!INDIRECT BIT
	OTSADDR=0,0,18$,		!ADDRESS FIELD
	OTSUNIT=0,0,18$,		!UNIT NUMBER ALWAYS GOES INTO BITS 18-35
	OTSFORM=0,0,18$,		!PTR TO FORMAT 
	OTSARRFMTFLG=0,35,1$,		!FLAG FOR "FORMAT STMNT IS AN ARRAY"
	OTSFSIZ=0,18,17$,	!FORMAT SIZE
	OTSIDN=0,27,9$,		!FOR AN IOLIST ELEMENT - IDENTIFIES THE CLASS OF ELEM
	OTSMEMRF=0,0,23$;		!THE 23 BITS DESCRIBING MEMORY REFERENCE


	%(***DEFINE VALUES FOR IDN FIELD FOR IOLIST ELEMENTS***)%
BIND
	OTSZER=0,
	OTSDATA=1,
	OTSSLIST=2,
	OTSFIN=4,
	OTSELIST=3;


BIND
	OTSZERWD=OTSZER^27,
	OTSFINWD=OTSFIN^27;


	%(***DEFINE ARG TYPE CODES THAT ARE USED FOR FOROTS CALLS***)%
BIND	ADDRTYPE=#7,		!TYPE CODE FOR A LABEL
	IMMEDTYPE=0;		!TYPE CODE INDICATING TO PICK UP ARG IMMED MODE


%(***************************************************************************
	SPECIFIC VALUES FOR FIELDS IN AN ARITHMETIC-IF NODE
***************************************************************************)%

	%(***VALUES FOR AIFLBEQV FIELD****)%
BIND
	NOLBEQV=0,
	LELBEQV=1,		!LSS LABEL SAME AS EQL LABEL
	LGLBEQV=2,		!LSS LABEL SAME AS GTR LABEL
	GELBEQV=3;		!GTR LABEL SAME AS EQL LABEL

	%(***VALUES FOR AIFLBNXT FIELD*******)%
BIND
	NOLBNXT=0,
	LLBNXT=1,		!LSS LABEL IS NEXT STMNT
	ELBNXT=2,		!EQL LABEL IS NEXT STMNT
	GLBNXT=3;		!GTR LABEL IS NEXT STMNT


	%(***WHEN SWAP THE GTR AND LESS LABELS (BECAUSE MULTIPLY BY -1), USE THE
		FOLLOWING MACRO TO ADJUST THE "AIFLBNXT" AND "AIFLBEQV"  FIELDS***)%
	MACRO SWPAIFFLGS(STMNT)=
	BEGIN
		IF .STMNT[AIFLBNXT]		!IF LAST BIT OF AIFLBNXT IS ON
		THEN
		STMNT[AIFLBNXT]_.STMNT[AIFLBNXT] XOR #2;	!THEN COMPLEMENT 1ST BIT
		IF .STMNT[AIFLBEQV]				!IF LAST BIT OF AIFLBEQV ON
		THEN
		STMNT[AIFLBEQV]_.STMNT[AIFLBEQV] XOR #2;	!THEN COMPLEMENT 1ST BIT
	END$;


%(***************************************************************************
	DEFINE THE STRUCTURE OF AN ARGUMENT LIST.
	CERTAIN FIXED FIELDS ON THE LIST WILL BE REFERENCED SIMPLY BY NAME.
	FIELDS CORRESPONDING TO THE NTH ARG WILL BE REFERENCED BY [N,NAME]
	NOTE THAT THE FIRST ARG HAS N=1 (NOT!!!! 0)
	NOTE THAT THE COUNT FIELD OF THE LIST WILL BE POSITIVE AND EQUAL
	TO THE NUMBER OF ARGS.
***************************************************************************)%

STRUCTURE ARGUMENTLIST[ARGINDEX,WD,POS,SIZE]=
	(@.ARGUMENTLIST+2+(.ARGINDEX-1)+.WD)<.POS,.SIZE>;


	%(***DEFINE THE FIXED FIELDS THAT OCCUR AT THE START OF EVERY ARGUMENT LIST - 
		DEFINE ALL THESE FIELDS IN TERMS OF A NEGATIVE NUMBER OF WDS FROM THE
		ENTRY FOR THE FIRST ARGUMENT (HENCE HAVE THE ARGINDEX FIELD=1) ***)%
MACRO
	ARGLABEL=1,-2,LEFT$,
	ARGLINK=1,-2,RIGHT$,
	ARGCOUNT=1,-1,RIGHT$;

	%(***DEFINE THE FIELDS THAT ARE REPEATED FOR EACH ARGUMENT. 
		WILL ALWAYS REFERENCE THESE FIELDS BY A REF OF THE FORM:
			ALIST[N,FIELDNAME]
		WHERE N IS THE NUMBER OF THE ARGUMENT DESIRED
	*********)%
MACRO
	ARGNPTR=0,RIGHT$,		!PTR TO THE EXPRESSION NODE FOR THE ARG
	AFLGFLD=0,LEFT$,		!FLAGS
	AVALFLG=0,35,1$;		!FLAG IS SET IF ARG IS A DATA ITEM OR
					! COMMON SUBEXPR


	%(***DEFINE THE FOLLOWING FIELD SO THAT PHASE 1 CAN REFERENCE THE AVALFLG
		BY USING A "BASE" STRUCTURE ON A GIVEN WORD*****)%
MACRO	P1AVALFLG=0,0,35,1$;


	%(***DEFINE MACRO THAT DESCRIBES NUMBER OF WDS NECESSARY IN AN ARGLIST THAT
		INCLUDES "ACT" NUMBER OF ARGS***)%
MACRO	ARGLSTSIZE(ACT)=(2+ACT)$;





%(***************************************************************************
	DEFINE THE STRUCTURE THAT WILL BE MAPPED ON THE LIBRARY FN ATTRIBUTE
	TABLE.
	FOR EACH LIBRARY-FN WILL HAVE A "LIBRARY-FN-INDEX" THAT INDICATES ITS
	POSITION IN THIS TABLE. THE FIRST ENTRY HAS INDEX =0.
***************************************************************************)%
STRUCTURE LIBATTSTR[FNINDEX,WD,POS,SIZE,CODE,ARGTYP1]=
	%(***FOR MOST FIELDS BOTH "CODE" AND "ARGTYP1" ARE 0***)%
	IF .CODE EQL 0
	THEN
	(.LIBATTSTR+2*.FNINDEX+.WD)<.POS,.SIZE>

	%(***FOR GENERIC FUNCTIONS ONLY - TO PICK UP THE NAME OF THE ACTUAL
		FUNCTION TO USE FOR A GIVEN ARG-TYPE.
		HAVE "CODE" EQUAL TO 1, "ARGTYP1" EQUAL TO THE VALTP1
		FIELD OF THE ARGUMENT.
	**********)%
	ELSE
	%(***GO INDIRECT THRU  THE "ATTGENPTR" FIELD - ADD "ARGTYP1" TO
		THE PTR IN THAT FIELD TO GET A PTR TO THE WD THAT
		INDICATES THE ACTUAL FN TO USE (THAT WD WILL ITSELF CONTAIN
		A PTR BACK TO A FUNCTION-TABLE ENTRY)
	*******)%
	(.(.LIBATTSTR+2*.FNINDEX+.WD)<.POS,.SIZE> + .ARGTYP1)<0,36>;

	%(***DEFINE MACROS THAT DESCRIBE THE FIELDS FOR A GIVEN FUNCTION INDEX***)%
MACRO
	ATTFNATTRIB=0,0,36,0,0$,	!THE FIRST WORD OF THE ENTRY WILL BE
					! COPIED INTO THE SYMBOL TABLE ENTRY
					! FOR THE FUNCTION NAME (INTO THE IDFNATTRIB FIELD)
	ATTINLINFLG=0,35,1,0,0$,	!BIT 0 OF 1ST WD IS FLAG FOR IN-LINE-FN
	ATTGENERFLG=0,33,1,0,0$,	! GENERIC FN FLAG
	ATTARGTYP=0,28,5,0,0$,	! VALTYPE FOR EXPECTED ARG
	ATTRESTYPE=0,23,5,0,0$,	! VALTYPE OF RESULT
	ATTARGCT=0,18,5,0,0$,	! NUMBER OF ARGS EXPECTED
	ATTNEWOPR=0,0,18,0,0$,	!OPERATOR TO BE SUBSTITUTED FOR FN CALL
				! IF THIS FN IS TO BE GENERATED IN LINE
	ATTGENPTR=1,0,18,0,0$,	!FOR GENERIC FNS ONLY - PTR TO SUBTABLE
				! DESCRIBING WHICH FNS TO USE FOR EACH ARG TYPE
	ATTACTFN=1,0,18,1$;	!FOR GENERIC FNS ONLY - TO GET A PTR TO
				! THE ACTUAL FN TO USE WILL GO INDIRECT THRU
				! THE "ATTGENPTR" FIELD AND THEN ADD ON THE TYPE OF THE ARG


	BIND	ILGARGTYPE=-1;	!FOR GENERIC FNS - IF A GIVEN ARG TYPE IS ILLEGAL
				! THE "ATTACTFN" FIELD FOR THAT TYPE WILL CONTAIN THIS CODE
	BIND	VARGCTFLG=#37;	!FUNCTIONS THAT CAN TAKE AN ARBITRARY NUMBER OF
				! ARGS (EG MAX,MIN) HAVE THE "ATTARGCT" SET TO THIS VAL



%(***************************************************************************
	DEFINE THE STRUCTURE TO BE MAPPED ON THE LIST OF ARG-CODES
	AND CORRESPONDING  VALUES THAT OCCURS UNDER AN OPEN STATEMENT
***************************************************************************)%

STRUCTURE OPENLIST[ARGINDEX,WD,POS,SIZE]=
	(@.OPENLIST+.ARGINDEX+.WD)<.POS,.SIZE>;


	%(***DEFINE THE FIELDS USED FOR A GIVEN INDEX***)%
MACRO	OPENLCODE=0,LEFT$,	!CODE FOR FOROTS FOR THIS ARG
	OPENLPTR=0,RIGHT$;	!PTR TO THE CONSTANT TABLE OR SYMBOLTABLE
				! ENTRY FOR THE VALUE FOR THIS ARG TO FOROTS

	%(***DEFINE VALUES FOR OPENLCODE***)%
BIND	OPNCDIALOG=01,		!DIALOG
	OPNCACCESS=02,		!ACCESS
	OPNCDEVICE=03,		!DEVICE
	OPNCBUFCOUNT=04,	!BUFFER COUNT
	OPNCBLOCKSIZE=05,	!BLOCK SIZE
	OPNCFILENAME=06,	!FILE NAME
	OPNCPROTECTION=07,	!PROTECTION
	OPNCDIRECTORY=#10,	!DIRECTORY
	OPNCLIMIT=#11,		!LIMIT
	OPNCMODE=#12,		!MODE
	OPNCFILESIZE=#13,	!FILE SIZE
	OPNCRECORDSIZE=#14,	!RECORD SIZE
	OPNCDISPOSE=#15,	!DISPOSE
	OPNCVERSION=#16,	!VERSION
	OPNCREELS=#17,		!REELS
	OPNCMOUNT=#20,		!MOUNT
	OPNCERROR=#21,		!ERROR
	OPNCASSOCIATE=#22;	!ASSOCIATE

%(***************************************************************************
	DEFINE THE STRUCTURE OF THE SYMBOL TABLE
***************************************************************************)%
STRUCTURE SYMTABENTRY[DMY,WD,POS,SIZE]=
	(@.SYMTABENTRY+.WD)<.POS,.SIZE>;





%(***************************************************************************
	DEFINE THE STRUCTURE OF THE DIMENSION TABLE
***************************************************************************)%
STRUCTURE DIMENTRY[DMY,WD,POS,SIZE]=
	(@.DIMENTRY+.WD)<.POS,.SIZE>;
MACRO DIMNUM=0,0,18,16$;			!NUMBER OF DIMENSIONS
MACRO	ADJDIMFLG=0,0,35,1$;			!FLAG FOR ADJUSTABLY DIMENSIONED
MACRO 	ARASIZ=0,0,RIGHT$;			!NUMBER OF WDS IN THE ARRAY
						!PTR TO A CONSTANT TABLE ENTRY UNLESS
						! ARRAY IS ADJ DIMENSIONED,
						! IN WHICH CASE, HAVE PTR TO A TMP
MACRO	ARAOFFSET=0,1,LEFT$;			!VALUE OF OFFSET FOR THIS
						! ARRAY IF DIMENSIONS ARE
						! CONSTANT; POINTER TO LOC
						! IN WHICH THE OFFSET WILL
						! BE STORED IF DIMENSIONS
						! ARE VARIABLE
MACRO	ARADDRVAR=0,1,RIGHT$;		!FOR FORMAL ARRAYS THAT ARE NOT ADJUSTABLY
						! DIMENSIONED, THIS FIELD POINTS 
						! TO A "PSEUDO" SYMBOL TABLE ENTRY
						! FOR THE ARRAY NAME WITH THE TYPE
						! FIELD SET TO INTEGER. IT IS THIS SYMBOL
						! THAT IS USED IN THE ADDRESS CALC
MACRO	DIMENS(X)=0,2+2*X,FULL$,		!DIMENSIONS FOR THE XTH DIMENSION
	DIMENL(X)=0,2+2*X,LEFT$,		!LOWER BOUND OF DIMENSION X
	DIMENU(X)=0,2+2*X,RIGHT$,		!UPPER BOUND OF DIMENSION X
	DVARLBFLG(X)=0,3+2*X,34,1$,		!FLAG FOR LOWER BOUND A  VARIABLE
	DVARUBFLG(X)=0,3+2*X,33,1$,		! FOR UPPER BOUND A VARIABLE
	DVARFACTFLG(X)=0,3+2*X,35,1$,		! FOR FACTOR A VARIABLE
	DFACTOR(X)=0,3+2*X,RIGHT$;		!FACTOR THAT SS FOR THIS
						! DIMENSION IS MULTIPLIED BY
						! THIS IS A PTR TO A CONSTANT TABLE ENTRY
						! IF PRECEEDING DIMENSIONS WERE CONSTANT,
						! A PTR TO A SYMBOL TABLE ENTRY FOR A
						! VAR IN WHICH THE VAL IS STORED IF VARIABLE
MACRO FIRSTDIM=0,2,WHOLE$;

	%(***THE SUBENTRY FOR A GIVEN DIMENSION***)%
STRUCTURE DIMSUBENTRY[WD,POS,SIZE]=
	(@.DIMSUBENTRY+.WD)<.POS,.SIZE>;

MACRO
	DIMLB=0,LEFT$,
	DIMUB=0,RIGHT$,
	VARLBFLG=1,34,1$,			!FLAG FOR "LOWER BOUND ON THIS DIMENSION
						! A VARIABLE
	VARUBFLG=1,33,1$,			!UPPER BOUND A VARIABLE
	VARFACTFLG=1,35,1$;			!FACTOR FOR THIS DIMENSION A VARIABLE
MACRO	DIMFACTOR=1,RIGHT$;		!FACTOR TO MULTIPLY SS OF THIS DIMENSION




%(*********
	DEFINE VALUES OF LABEL TABLE FIELDS USED FOR PEEPHOLING
**********)%

	%(***VALUES FOR SNSTATUS FIELD***)%
BIND	OUTPBUFF=2,			!LABEL IS OUT OF THE PEEPHOLE BUFFER
	INPBUFF=1,			!LABEL IS STILL IN THE PEEPHOLE BUFFER
	UNRESOLVED=0;			!LABEL IS UNRESOLVED
BIND	LBTBENDMK=0;				!VALUE OF NXTLAB FIELD
						! FOR LAST LINK




%(**************
	DEFINE STRUCTURE FOR PEEPHOLE BUFFER
****************)%

	%(***SIZE OF PEEPHOLE BUFFER ENTRIES****)%
BIND PBFENTSIZE=3;			!NUMBER OF WORDS IN EACH PEEPHOLE BUFFER ENTRY
BIND PBFSIZE=25*PBFENTSIZE + 2;		!NUMBER OF WORDS IN THE PEEPHOLE BUFFER
					! (KEEP 1 WD AFTER THE LAST ENTRY TO HOLD
					! A POSSIBLE LABEL AND A POSSIBLE ISN)


	%(****STRUCTURE FOR LOOKING AT A PEEPHOLE*******)%
	%(*******THE ARG INST INDICATES WHICH INSTRUCTION OF THE PEEPHOLE***)%
STRUCTURE	PEEPHOLE[INST,WD,POS,SIZE]=
	(@.PEEPHOLE + PBFENTSIZE*.INST +.WD)<.POS,.SIZE>;


	%(****STRUCTURE FOR A PEEPHOLE BUFFER ENTRY***)%
STRUCTURE PEEPFRAME[WD,POS,SIZE]=
	(.PEEPFRAME+.WD)<.POS,.SIZE>;

	%(***STRUCTURE FOR A PTR TO  A PEEPHOLE BUFFER ENTRY*****)%
STRUCTURE PPEEPFRAME[WD,POS,SIZE]=
	(@.PPEEPFRAME+.WD)<.POS,.SIZE>;


%(*****DEFINE FIELDS FOR PEEPHOLE BUFFER FRAME*****)%
MACRO	PBFISN=0,WHOLE$,		!ISN FOR STMNT BEGUN BY THIS INSTR
					! -1 FOR INSTRS THAT DO NOT START STMNTS
	 PBFLABEL=1,LEFT$,			!PTR TO LABEL TABLE ENTRY FOR THE 1ST
						!  LABEL ASSOCIATED WITH THIS
						! LOC
	PBFSYMPTR=1,RIGHT$,			!0 IF ADDR FIELD IS A LABEL
						!1 IF ADDR FIELD HAS NO SYMBOLIC REPR
						!2 IF ADDR FIED IS A PTR TO THE SIXBIT
						! FOR AN IMPLICITLY CALLED FUNCTION
						!3 IF ADDR IS A PTR TO A SYMBOL TABLE ENTRY
						! FOR AN EXPLICITLY CALLED FN
						! OTHERWISE A PTR TO THE SYMBOL TABLE,CONSTANT
						! TABLE OR TEMP TABLE ENTRY FOR THIS ADDR FIELD
	PBFINSTR=2,WHOLE$,
	PBFADDR=2,RIGHT$,		!ADDRESS FIELD OF THE INSTR
	PBFOPCOD=2,27,9$,		! OP-CODE
	PBFOPKEY=2,27,5$,		! LAST 5 BITS OF OPCODE, USED AS
					! KEY IN PEEPHOLE OPTIMIZER
	PBFREG=2,23,4$,			!REG FIELD
	PBFINDEX=2,18,4$,		!INDEX AND INDIRECT FIELDS
	PBFMEMREF=2,0,23$;		!ADDRESS,INDIRECT, AND INDEX FIELDS
BIND	NOLABEL=0;				!FLAG FOR "NO LABEL YET ASSOCIATED
						! WITH THIS LOC"
BIND	NOISN=-1;		!CODE FOR "NO ISN ASSOCIATED WITH THIS INSTR"
				! (IE THE INSTR IS IN THE MIDDLE OF A STMNT)

%(*******SPECIAL VALS FOR PBFSYMPTR FIELD*******)%
BIND
	PBFLABREF=0,			!ADDRESS FIELD IS A LABEL, RH IS AN INSTRUCTION
	PBFNOSYM=1,			!ADDRESS FIELD IS AN OCTAL CONSTANT, RH IS AN INSTR
	PBFIMFN=2,			!ADDR FIELD IS A PTR TO AN IMPLICITLY CALLED FN
	PBFEXFN=3,			!ADDR FIELD IS A PTR TO AN EXPLICITLY CALLED FN
	PBF2LABREF=4,			!BOTH HALVES OF WD ARE PTRS TO LABEL TABLE
					! ENTRIES
	PBF2NOSYM=5,			!BOTH HALVES OF WD ARE OCTAL CONSTANTS WITH
					! NO SYMBOLIC REPRESENTATION
	PBFFORMAT=6,			!RIGHT HALF WORD IS FORMAT ADDRESS
	PBFLLABREF=7,			!LEFT HALF IS A LABEL REFERENCE
					!USED PRIMARILY FOR ARGUMENT BLOCKS TO
					!FOROTS FOR THE END=,ERR= WORD
	PBFENTRY=8;			!FOR A GLOBAL ENTRY (AS SUBROUTINE
					!OR ENTRY NAME).


BIND	PBFCODMAX=16;		!CAN NEVER USE ANY NUMBER GTR THAN 16 AS A SPECIAL
				! CODE VALUE FOR PSYMPTR, BECAUSE ANY NUMBER GTR
				! THAN 16 MIGHT BE THE ADDRESS OF A NODE


%(***************************************************************************
	TO GENERATE A JRST INSTRUCTION
***************************************************************************)%
MACRO JRSTGEN(ADDR)=
BEGIN
	PBOPWD_JRSTOC OR ADDR;
	PSYMPTR_PBFLABREF;			!FLAG FOR "ADDRESS FIELD OF THIS INSTR IS
						! A LABEL"
	OBUFF();
END$;


	%(***TO GENERATE JRST INDIRECT***)%
MACRO JRSTIGEN(ADDR)=
BEGIN
	PBOPWD_JRSTOC OR INDBIT OR ADDR;
	PSYMPTR_PBFLABREF;
	OBUFF();
END$;
%(***************************************************************************
	DEFINE THE VARIOUS WAYS OF BUILDING INDICES INTO THE OPGENDISPATCH TABLE.
	EACH KIND OF INDEX IS COMPOSED OF SOME COMBINATION OF THE FLAG AND OPERATOR
	FIELDS OF THE NODES FOR WHICH CODE IS TO BE GENERATED.
***************************************************************************)%


	%(****TO GET THE VAL OF AN ARGNODE INTO THE REG FOR COMPUTATION OF THE PARENT (WHEN
		THE VAL OF THE SON IS WITHIN REACH OF 1 INSTR.
		DEPENDS ON THE VALS OF NEGFLG,NOTFLG,SAMEFLG,IMMEDFLG
		FOR THE ARG INVOLVED, ALSO ON THE VALUE-TYPE OF THE ARG.
	*******)%
MACRO	GETA1OPIX(PNODE,ANODE)=
	BEGIN
		(.PNODE[A1FLG1]^2 + .ANODE[VALTP1] +(IF .KA10FLG THEN OPGETA ELSE OPGETI))
	END$;

MACRO	GETA2OPIX(PNODE,ANODE)=
	BEGIN
		(.PNODE[A2FLG1]^2 + .ANODE[VALTP1] + (IF .KA10FLG THEN OPGETA ELSE OPGETI))
	END$;

	%(***FOR DO-LOOPS - DONT ACTUALLY HAVE AN EXPRESSION NODE BUT WANT TO GET VAL
		HOW TO DO SO DEPENDS ON VAL OF IMMEDFLG, VALTYPE AND NEGATE FLAG***)%
MACRO	DOGETAOPIX(IMFLG,VLTP,NEGFLAG)=
	(NEGFLAG^4+IMFLG^2 + VLTP + (IF .KA10FLG THEN OPGETA ELSE OPGETI))$;





	%(****TO COMPUTE THE VALUE OF A NON-CONTROL BOOLEAN NODE. CODE TO BE GENERATED
		DEPENDS ON A2NOTFLG, A2IMMEDFLG, AND MEMCMPFLG AND THE OPERSP***)%
MACRO	BOOLOPIX(PNODE)=
	(.PNODE[A2NOTFLG]^4 + .PNODE[A2IMMEMCMPFLGS]^2 + .PNODE[OPERSP] + OPGBOO)$;


	%(******TO SKIP THE NEXT INSTRUCTION WHEN A RELATIONAL HAS THE VAL INDICATED
		BY 'SKPCND'. CODE TO BE GENERATED DEPENDS ON WHETHER THE ARGS
		OF THE RELATIONAL ARE SINGLE OR DOUBLE WD AND WHETHER
		THE 2ND ARG IS IMMED*******)%
	%(*****(NOTE THAT IF THIS IS EVER CHANGED, THEN DPIMMRELOPIX DEFINED
		BELOW SHOULD ALSO BE CHANGED)***)%
	MACRO RELOPIX(PNODE,ANODE,SKPCND)=
	BEGIN
		REGISTER MODE;			!MODE ON WHICH TO SKIP
		MODE_.PNODE[OPERSP];		!MODE SPECIFIED IN RELATIONAL
		IF FALSITY(SKPCND)
		THEN MODE_CMREL(.MODE);		!IF WANT TO SKIP ON REL FALSE

		.ANODE[DBLFLG]^4 + .PNODE[A2IMMEDFLG]^3 + .MODE + OPGREL
	END$;


	%(****FOR A RELATIONAL BETWEEN A DOUBLE-PREC AND ZERO. CAN USE SAME
		CODE AS USE TO COMPARE A REAL TO ZERO (SEE RELOPIX ABOVE)***)%
	MACRO	DPIMMRELOPIX(PNODE,SKPCND)=
	BEGIN
		REGISTER MODE;	!MODE ON WHICH TO SKIP
		MODE_.PNODE[OPERSP];
		IF FALSITY(SKPCND)
		THEN MODE_CMREL(.MODE);	!IF WANT TO SKIP ON RELATIONAL FALSE

		1^3 + .MODE + OPGREL	!HAVE A2IMMEDFLG (SINCE COMPARE TO 0)
					! AND DO NOT HAVE DOUBLE-WD COMPARE)
	END$;



	%(*****TO COMPUTE THE VAL OF AN ARITHMETIC NODE.
		DEPENDS ON THE VALS A2IMMEDFLG,MEMCMPFLG,VALTYPE, AND OPERSP OF THE PARENT
		NOTE THAT EXPONENTIATION NODES WERE CONVERTED TO FUNCTION-CALLS DURING
		THE COMPLEXITY WALK. HENCE NEVER HAVE TO GET OPGNTA INDEX FOR EXPONEN
	********)%
MACRO	ARITHOPIX(PNODE)=
	BEGIN
		(.PNODE[A2IMMEMCMPFLGS]^4+.PNODE[OPRSP2]^2+.PNODE[VALTP1]+
			(IF .KA10FLG THEN OPGARA ELSE OPGARI))
	END$;


	%(*********FOR THE ADD TO MEMORY FOR A DO-LOOP********)%
MACRO	DOARITHOPIX(VLTP,MCPFLG,IMFLG,NEGFLAG)=
		%(***HAVE A2IMMEDFLG=IMFLG,  MEMCMPFLG=MCPFLG,
			OPERATOR IS ADD IF NEGFLAG IS 0, SUB IF NEGFLAG IS 1***)%
	(IMFLG^5 + MCPFLG^4 + (ADDOP+NEGFLAG)^2 + VLTP + (IF .KA10FLG THEN OPGARA ELSE OPGARI))$;



	%(*****TO COMPUTE THE VAL OF A TYPE CONVERSION NODE.
		WILL BE GENERATING CODE ONLY WHEN  DESTIN  TYPE
		IS REAL,INTEGER,DOUBLEPREC,OR COMPLEX (IE NEVER HAVE
		TO DEAL WITH OCTAL,DOUBLE-OCTAL,LOGICAL,LITERAL,OR CONTROL)
		THUS ONLY NEED TO DIFFERENTIATE BETWEEN THESE 4 TYPES
		THE TYPE TO BE CONVERTED TO (SPECIFIED BY THE VALTYPE FIELD OF THE
		TYPE-CONVERION NODE).
		THE OPERSP FIELD OF THE TYPE CONVERSION NODE, INDICATES
		THE ORIGINAL TYPE BEING CONVERTED.
	*******)%
	MACRO	TPCNVIX(PNODE)= (.PNODE[OPERSP]^2 + .PNODE[VALTP1] + 
			(IF .KA10FLG THEN OPGTCA ELSE OPGTCI))$;




	%(****TO COMPUTE THE VALUE OF A NEGNOT NODE.  WHEN PHASE 2 SKELETON IS PRESENT,
		THERE WILL BE FEW OF THESE. (EG FOR F(-X), NOT(-X))*********)%

	%(***WHEN A2NEG,A2NOT, OR A2SAMEFLG IS SET, WILL USE GETA2OPIX TO GET THE ARG
		INTO A REG, AND THEN USE THE FOLLOWING INDEX*****)%
MACRO	NEGNOT1IX(PNODE)=
	(.PNODE[MEMCMPFLG]^3 + .PNODE[OPERSP]^2 + .PNODE[VALTP1] + (IF .KA10FLG THEN OPGN1A ELSE OPGN1I))$;

	%(***OTHERWISE, USE AN INDEX BASED ON A2IMMED, MEMCMP, OPERSP, VALTP1****)%
MACRO	NEGNOT2IX(PNODE)=
	(.PNODE[A2IMMEMCMPFLGS]^3 + .PNODE[OPERSP]^2 + .PNODE[VALTP1] + (IF .KA10FLG THEN OPGN2A ELSE OPGN2I))$;

	%(***TO COMPUTE THE VALUE OF A P2MUL OR P2PL1MUL  -
		CODE TO BE GENERATED DEPENDS ON VALTYPE OF THE NODE AND
		ON WHICH OP IS TO BE PERFORMED****)%
MACRO	SPECOPIX(PNODE)=
	BEGIN
		%(***IF ARG IS IMMEDIATE AND OPERATION IS P2PLUS1-MULTIPLY OR CUBE, HAVE A
			SPECIAL CASE***)%
		IF .PNODE[A1IMMEDFLG]
		THEN
		BEGIN
			IF .PNODE[OPERSP] EQL P2PL1OP
			THEN (.PNODE[A1NEGFLG]^2 + .PNODE[VALTP1] + OPP21I)
			ELSE
			IF .PNODE[OPERSP] EQL CUBOP
			THEN (.PNODE[A1NEGFLG]^2 + .PNODE[VALTP1] + OPCUBI)
			ELSE
			(.PNODE[OPERSP]^3 + .PNODE[A1NEGFLG]^2 +.PNODE[VALTP1]
				+(IF .KA10FLG THEN OPGSPA ELSE OPGSPI))
		END
		ELSE
		(.PNODE[OPERSP]^3 + .PNODE[A1NEGFLG]^2 +.PNODE[VALTP1]
			+(IF .PNODE[MEMCMPFLG] THEN OPGSPM		!FOR OPS DONE TO MEMORY DONT CARE
									! WHETHER ARE KA OR KI
				ELSE IF .KA10FLG THEN OPGSPA ELSE OPGSPI))
	END$;



	%(***TO GENERATE CODE FOR AN IN-LINE FUNCTION WHEN ARG1 FOR THAT FN IS ALREADY IN REGFORC**)%
MACRO	ILFIX(PNODE)=
	BEGIN
		IF .PNODE[A2IMMEDFLG]
		THEN
		.PNODE[OPERSP] + OPGILI
		ELSE
		.PNODE[OPERSP] + OPGILF
	END$;

	%(***TO GENERATE CODE FOR AN IN-LINE FN WHEN ARG IS NOT IN REGFORCOMP (USED FOR
		ABS,IABS (NOT IN RELEASE 1), AND SIGN ***)%
MACRO	ILF1IX(PNODE)=
	(.PNODE[OPERSP] + OPGIL1) $;


	%(*****TO PERFORM THE ACTION SPECIFIED FOR A "STORECLS" NODE (WHICH IS USED
		WHEN EITHER A PTR TO AN ARRAY ENTRY OR THE CONTENTS OF THAT
		ENTRY MUST BE STORED IN A TEMPORARY************)%
MACRO	STCLSOPIX(PNODE)=
	(IF .PNODE[DBLFLG] AND (.PNODE[OPERSP] EQL STARVAL)	!FOR STORING A DOUBL-WD VAL
	THEN (.KA10FLG^1 +.PNODE[A2SAMEFLG] + OPGSTD)
	ELSE (.PNODE[OPERSP]^1 + .PNODE[A2SAMEFLG] + OPGSTC))$;


	%(*****TO STORE A VALUE THAT HAS BEEN COMPUTED****)%
MACRO	STOROPIX(PNODE)=
	BEGIN
		.PNODE[DBLFLG] + (IF .KA10FLG THEN OPGSTA ELSE OPGSTI)
	END$;

	%(******TO STORE THE VALUE OF THE RHS OF AN ASSIGNMENT STMNT
		INTO THE LHS. CODE TO BE GENERATED DEPENDS ON WHETHER THE VAL MUST
		BE NEGATED OR COMPLEMENTED, AND ON THE VALTYPE*****)%
	MACRO ASNOPIX(PNODE,LHSNODE)=
	BEGIN
		%(***IF THIS STATEMENT HAS A2IMMEDFLG AND A2SAMEFLG BOTH SET, IT
			MUST BE THAT THE RHS IS A REGCONTENTS NODE FROM WHICH WE
			ONLY WANT TO USE THE RIGHT HALF (BECAUSE IT IS AN AOBJN WD).***)%
		IF .PNODE[A2IMMEDFLG] AND .PNODE[A2SAMEFLG]
		THEN
		OPGASR

		ELSE
		.PNODE[A1NGNTFLGS]^2 + .LHSNODE[VALTP1] + (IF .KA10FLG THEN OPGASA ELSE OPGASI)
	END$;


	%(****TO GENERATE CODE FOR AN ARITHMETIC-IF STATEMENT**********)%

MACRO
	AIFIX(STMNODE,CNEXPR)=
		(.STMNODE[AIFFLGS]^1 +
			(IF .CNEXPR[OPRCLS] EQL DATAOPR
			THEN 0
			ELSE .CNEXPR[INREGFLG])
			+ OPGAIF)$;

	%(***TO INIT A LOGICAL VALUE TO TRUE OR FALSE (-1 OR 0). CODE
		TO BE GENERATED DEPENDS ON WHETHER VAL IS TO BE LEFT IN A REG AND
		ON THE VAL TO BE STORED
		NOTE THAT "LOGVAL" IS EXPECTED TO BE 777777777777 FOR "TRUE"
	*****)%
MACRO	SETLOGIX(PNODE,LOGVAL)=
	((LOGVAL AND #2) + .PNODE[INREGFLG] + OPGSET)$;


	%(*****TO TRANSFER CONTROL WHEN A SPECIFIED VAR HAS THE SPECIFIED VAL TRUE OR FALSE.
		CODE TO BE GENERATED DEPENDS ON WHICH CONDITION TRANSFER IS DESIRED
		AND ON WHETHER THE VAL IS IN A REG
		NOTE THAT "JMPCND" IS EXPECTED TO BE 777777777777 FOR "TRUE"
****)%
MACRO	CNDVTRIX(NODE,JMPCND)=
	BEGIN
		IF .NODE[OPRCLS] EQL DATAOPR
		THEN
		((JMPCND AND #2) + OPGVTS)
		ELSE
		((JMPCND AND #2) + .NODE[INREGFLG] + OPGVTS)
	END$;


	%(*******TO TRANSFER TO ONE LABEL IF A SPECIFIED VALUE IS TRUE
		AND TO ANOTHER IF THE VAL IS FALSE.
		CODE TO BE GENERATED DEPENDS ON WHETHER THE VAL TO BE GENERATED
		IS IN A REG.
	********)%
MACRO	ALTTRIX(NODE)=
	BEGIN
		IF .NODE[OPRCLS] EQL DATAOPR
		THEN
		OPGALT
		ELSE
		(.NODE[INREGFLG] + OPGALT)
	END$;



%(**************************************************
	DEFINE STRUCTURE FOR OPGENTABLE ENTRY - 
	FOR A GIVEN TYPE OF NODE, WILL HAVE A SERIES OF SUCH ENTRIES, ONE
	FOR EACH INSTRUCTION TO BE GENERATED
******************************************************)%


STRUCTURE OPGENTRY[WD,POS,SIZE]=
	(@.OPGENTRY+.WD)<.POS,.SIZE>;

%(**************FIELDS FOR AN OPGENTRY***********)%
MACRO
	REGSPEC=0,LEFT$,			!SPECIFIES WHERE TO GET
						! REG TO BE USED
	MEMSPEC=0,RIGHT$,			!SPECIFIES WHERE TO GET
						! MEMREF TO BE USED
	PATTERN=1,WHOLE$;		!PATTERN WORD FOR INSTR TO
						! BE GENERATED

%(*********DEFINE VALUES FOR REGSPEC AND MEMSPEC FIELDS*********)%
BIND
	FRPTN=0,		!REG OR MEMREF FIELD USED AS IS IN WD 1 OF OPGENTABLE ENTRY
	FRRFC=1,		!REG FIELD IN THE GLOBAL "REGFORCOMP" SHOULD BE
				! ADDED IN TO THE REG FIELD IN WD 1
				! (OR THE REG SPECIFIED BY "REGFORCOMP" 
				! SHOULD BE USED AS THE MEMREF FIELD
	IMFN=2,			!USE THE IMPLICIT FN NAME PTED TO BY TREEPTR
	WD1IMF=3,		!USE THE IMPLICIT-FN NAME POINTED TO BY THE RH OF THE PATTERN WD
	RGIMFN=4,		!USE THE IMPLICIT-FN NAME POINTED TO BY THE RH OF
				! THE PATTERN WD INDEXED BY THE "REGFORCOMP"
	A1CNST=5,		!ARG1 IS IMMED CNST
	A2CNST=6,		!ARG2 IS IMMED CNST
	A1CNNG=7,		!USE NEG OF THE IMMED CNST ARG1
	A2CNNG=10,		!USE NEG OF THE IMMED CNST ARG2
	PTRA2=#11,		!USE THE ARG2PTR FIELD IN THE PARENT
	NGPTR2=#12,		!USE THE NEG OF THE ARG2PTR FIELD OF THE PARENT
	P2PTR2=#13,		!USE 2**(VAL OF ARG2PTR) MINUS 1
				! (THIS IS USED FOR P2DIV)
	A1LAB=#14,		!USE THE LABEL INDICATED BY A1LABEL
	A2LAB=#15,		!USE THE LABEL INDICATED BY A2LABEL
	A3LAB=#16,		!USE THE LABEL INDICATED BY A3LABEL
	FROMC1H=#17,		!USE THE CONTENTS OF THE GLOBAL C1H,
				! THERE IS NO SYMBOL ASSOCIATED WITH THIS ADDR FIELD
	PARTMP=#20,		!USE THE TMP POINTED TO BY THE ADDR PART
				! OF THE TARGET WD OF THE PARENT NODE (IE THE NODE
				! POINTED TO BY TREEPTR); IGNORE THE INDIRECT BIT
				! OF THE TARGET WD
	FROMA1=#21,		!TARGET FIELD OF ARG1 IS MEMREF FIELD
	FROMA2=#22,		!TARGET FIELD OF ARG2
	FROMPAR=#23;		!TARGET FIELD OF PARENT (IE NODE PTED TO BY TREEPTR)




%(***********************************************************************
	TO GET REG OR MEMREF OR OPERATOR FIELD FROM EITHER A TARGET WD IN AN EXPRESSION
	NODE OR A PATTERN WORD IN AN OPGENTABLE ENTRY
*****************************************************************)%

MACRO
	OPFLD(WORD) = WORD AND #777^27$,
	REGFLD(WORD) = WORD AND #17^23$,

	MEMFLD(WORD) = WORD AND #37777777$;


	%(****DEFINES SPECIFIC REGS USED FOR COMPILED CODE*****)%
BIND RETREG=0;			!REG IN WHICH THE VAL OF A FN IS RETURNED
BIND STKREG=17;		!STACK REG FOR FNS/SUBRS
BIND ARGREG=16;			!CONTAINS PTR TO ARGLIST FOR FNS/SUBRS





%(*********MACROS USED FOR REGISTER ALLOCATION***********************)%



%(*****TO DETERMINE WHETHER A NODE IS EVALUATED BY MEANS OF A CALL TO A LIBRARY FN,
	(IF SO THEN IF THE 2ND ARG IS A CONSTANT WILL HAVE TO ALLOCATE CORE FOR IT)***)%
MACRO USEFNCALL(PNODE)=
BEGIN
	%(***DOUBLE-PREC OPS ON THE KA10 ARE EVALUATED BY LIBRARY FNS***)%
	IF .PNODE[VALTYPE] EQL DOUBLPREC
	THEN
	.KA10FLG
	ELSE
	%(****EXPONENTIATION IS PERFORMED BY LIBRARY FNS***)%
	(.PNODE[OPR1] EQL EXPONOPF)
END$;


%(****FOR REGISTER ALLOCATION - GET THE REGISTER WHICH IS TO BE THE NTH ASSIGNED.
	FOR BOTTOMMOST ROUTINES THIS WILL BE REGISTER N+2 (FIRST ASSIGNED IS 2) 
	FOR NON-BOTTOMMOST ROUTINES THIS WILL BE REGISTER 15-N (FIRST ASSIGNED IS 15).
*********)%
MACRO ASNREG(N1)=
BEGIN
	IF .BTTMSTFNFLG
	THEN N1+2
	ELSE #15-N1
END$;

	%(***INVERSE OF ASNREG - TO GET THE INDEX FOR A GIVEN REG***)%
MACRO INVASNREG(REG)=
BEGIN
	IF .BTTMSTFNFLG
	THEN REG-2
	ELSE #15-REG
END$;


%(****GET THE INDEX FOR THE REGISTER AFTER THE REGISTER INDICATED BY THE INDEX 'IX'****)%
MACRO NXREG(IX)=
BEGIN
	IF .BTTMSTFNFLG
	THEN IX+1
	ELSE IX-1
END$;


%(***GIVEN A BIT PATTERN REPRESENTING A SET OF REGS (BIT 0 THE REG OF IX 0, BIT
	1 THE REG OF IX 1, ETC), RETURN THE PATTERN REPRESENTING THE REGS FOLLOWING THESE***)%
MACRO	NXREGPATTERN(BITPTN)=
BEGIN
	%(***FOR BOTTOMOST FNS, BIT 0  IS REG 2, BIT 1 REG 3, ETC - 
		HENCE SHOULD SHIFT THE BITS TO THE RIGHT***)%
	IF .BTTMSTFNFLG
	THEN BITPTN^(-1)
	ELSE
	%(***FOR NON-BOTTOMOST FNS, BIT 0 IS REG 15, BIT 1 REG 14, ETC -
		HENCE SHOULD SHIFT THE BITS TO THE LEFT***)%
	BITPTN^1
END$;


%(***GIVEN A BIT PATTERN REPRESENTING A SET OF REGS, RETURN THE PATTERN REPRESENTING
	THE REGS PRECEEDING EACH OF THESE***)%
MACRO	PREVREGPATTERN(BITPTN)=
BEGIN
	%(***FOR BOTTOMMOST FNS, BIT 0 IS REG 2, BIT 1 REG 3 ETC - HENCE
		SHOULD SHIFT BITS TO THE LEFT TO GET BIT FOR PREVIOUS REG***)%
	IF .BTTMSTFNFLG
	THEN BITPTN^1
	ELSE
	%(***FOR NON-BOTTOMOST FNS BIT 0 IS REG 15,BIT 1 IS REG 14 ETC- HENCE SHIFT RIGHT***)%
	BITPTN^(-1)
END$;

%(****TO DETERMINE WHETHER THE REGISTER AFTER THE REGISTER INDICATED Y THE INDEX 'IX' IS
	FREE. BITS 0-15 OF 'BSYRS' REPRESENT REGISTERS OF INDEX 0-15.
	THE BIT FOR A REGISTER IS SET IFF THAT REG IS FREE*******)%
MACRO NXREGFREE(BSYRS,IX)=
BEGIN
	EXTERNAL CLRWDS;
	REGISTER NXTREG;
	%(***GET INDEX FOR REGISTER FOLLOWING THE REG WITH INDEX IX. FOR BOTTOMOST ROUTINES
		THIS WILL BE IX+1, FOR NON-BOTTOMOST ROUTINES IT WILL BE IX-1***)%
	NXTREG_IX;
	IF .BTTMSTFNFLG
	THEN NXTREG_.NXTREG+1
	ELSE NXTREG_.NXTREG-1;

	IF .NXTREG LSS 0
	THEN FALSE
	ELSE
	%(***CHECK WHETHER THE BIT CORRESPONDING TO NXTREG IS SET IN BSYRS***)%
	(BSYRS AND NOT .CLRWDS[.NXTREG]) NEQ 0
END$;


%(****TO TEST WHETHER AN OPERATION 'CLOBBERS' THE REGISTER FOLLOWING THE ONE IN
	WHICH IS IS PERFORMED.
	THIS TEST DOES NOT INCLUDE DOUBLE-PREC (OR COMPLEX) OPERATIONS,
	WHICH THE REGISTER ALLOCATOR HANDLES BY SIMPLY NEVER 
	ASSIGNING ODD REGISTERS WHEN IN "DOUBLE-WD MODE"
********)%
MACRO CLBNXREG(NODE)=
	((.NODE[OPERATOR] EQL INTDIVIDE) OR (.NODE[OPR1] EQL MODFNFL)
	OR (.KA10FLG AND ((.NODE[OPERATOR] EQL IFIXOP) OR (.NODE[OPERATOR] EQL FLOATOP))))$;


%(******MACROS FOR GOING BETWEEN "DOUBLE-WD MODE" REGISTER ALLOCATION AND
	"SINGLE-WD MODE" REGISTER ALLOCATION.
	FOR DOUBLE-WORD OPERATIONS, NEVER ASSIGN ODD REGISTERS TO
	ANY COMPUTATIONS.
	THE "SET OF BUSY REGS" MAY NEED TO HAVE THESE TRANSFORMATIONS PERFORMED ON IT
		1. ACROSS A TYPE CONVERSION NODE (WHEN CONVERTING BETWEEN DOUBLE-WD
			AND SINGLE-WD VALUES
		2. ACROSS A RELATIONAL NODE THAT COMPARES DOUBLE-WD VALUES (BUT
			HAS A SINGLE-WD RESULT)
		3. ACROSS AN ARRAY-REF NODE FOR A DOUBLE-PREC ARRAY (THE ADDRESS ARITHMETIC 
			IS SINGLE-WD)
		4. ACROSS A BOOLEAN  WHOSE ARGS ARE DOUBLE-WD (RESULT IS ALWAYS SINGLE-WD
*************)%

	%(******WHEN GOING DOWN FROM SINGLE-WD CALCULATIONS TO DOUBLE-WD CALCULATIONS
		THE SET OF REGISTERS THAT CANNOT BE ASSIGNED MUST
		NOW INCLUDE
			1. ANY REGISTER THAT PRECEEDS A REGISTER HOLDING A VAL TO
				BE PRESERVED (SINCE A DOUBLE-WD COMPUTATION
				ON THE PRECEEDING REG CLOBBERS THE FOLLOWING ONE)
			2. ANY ODD REGISTER.
	***********)%

	MACRO DPBSYREGS(SPBSYRS)=
	BEGIN
		IF .BTTMSTFNFLG
		THEN
		%(***FOR BOTTOMMOST ROUTINES (FOR WHICH BIT 0 IN BUSY-WD REPRESENTS REG2,
			BIT 1 IS REG 3, BIT 2 REG 4, ....******)%
		(SPBSYRS AND SPBSYRS^1) AND #525252525252

		ELSE
		%(***FOR NON-BOTTOMMOST ROUTINES (FOR WHICH BIT 0 REPRESENTS REG 15, BIT 1 REG 14,
			BIT 2 REG 15.....******)%
		(SPBSYRS AND SPBSYRS^(-1)) AND #252525252525
	END$;

	%(*********WHEN GOING DOWN FROM DOUBLE-WD CALCULATION TO SINGLE-WD
		CALCULATIONS.
		THE SET OF REGISTERS AVAILABLE ONCE AGAIN CAN INCLUDE
		THEN ODD REGISTERS EXCEPT FOR THOSE REGISTERS CONTAINING THE RIGHT-HALF
		OF A DOUBLE-WD RESULT WHICH WAS BEING SAVED.
	************)%
	MACRO SPBSYREGS(DPBSYRS)=
	BEGIN
		IF .BTTMSTFNFLG
		THEN
		%(***FOR BOTTOMOST ROUTINES (FOR WHICH BIT 0 REPRESENTS REG 2, BIT 1 REG 3, ETC***)%
		(DPBSYRS OR #252525252525) AND ((DPBSYRS OR #252525252525)^(-1) OR #400000000000)
		ELSE
		%(***FOR NON-BOTTOMMOST ROUTINES (BIT 0 REPRESENTS REG 15, BIT 1 REG 14,ETC***)%
		(DPBSYRS OR #525252525252) AND ((DPBSYRS OR #525252525252)^1)
	END$;



%(*****WHEN COMING BACK UP FROM DOUBLE-WD OPS UP TO SINGLE-WD OPS, MUST MARK BITS
	IN "CLOBBREGS"(WD INDICATING WHICH REGS WERE CLOBBERED IN CALCULATING THE VAL
	OF AN EXPRESSION) FOR THE ODD REGS FOLLOWING EACH EVEN REG USED
*******)%
MACRO SETDPCLOBB=
	(CLOBBREGS_.CLOBBREGS OR .CLOBBREGS^(IF .BTTMSTFNFLG THEN (-1) ELSE 1))$;






%(****TO SWAP HALVES OF A WORD IN MEMORY****)%
MACHOP MOVSS=#207;
MACHOP MOVE=#200;
MACRO SWAPHALVES(PTR,OFFST) =
BEGIN
	REGISTER T1;
	MOVE (T1,PTR);
	MOVSS (0,OFFST,T1)
END$;


%(*****TO SWAP THE 2 ARGS UNDER AN EXPRESSION NODE**************)%
MACRO
	SWAPARGS(NODE)=
	BEGIN
		SWAPHALVES(NODE,ARGWDOFFSET);
		SWAPFLGS(NODE);
	END$;




%(****TO PERFORM A BLOCK TRANSFER *******)%
MACHOP BLT=#251;

MACRO BLOCKTR(SRCLOC,DESTIN,BLLNTH)=
BEGIN
	REGISTER T1;
	T1<LEFT>_SRCLOC;
	T1<RIGHT>_DESTIN;
	BLT(T1,(DESTIN)<0,0>+BLLNTH-1);
END$;


%(****TO PICK UP A HALF-WD VAL WITH SIGN EXTENDED****)%
MACHOP HRREI=#571;

MACRO	EXTSIGN(VAL)=
BEGIN
	REGISTER AA1;
	AA1_VAL;
	HRREI(AA1,0,AA1)
END$;


%(***TO DO AN ARITHMETIC SHIFT BY A COMPILE TIME CONSTANT***)%
MACHOP ASH=#240;

MACRO ARITHSHIFT(VAL,BITCT)=
BEGIN
	REGISTER T1;
	T1_VAL;
	ASH(T1,(BITCT AND #777777))
END$;



%(****TO COUNT THE NUMBER OF BITS THAT ARE ON IN A GIVEN WORD****)%
MACRO ONESCOUNT(WD)=
BEGIN
	REGISTER COUNT;
	REGISTER T1;
	T1_WD;
	COUNT_0;
	UNTIL .T1 EQL 0
	DO
	BEGIN
		T1_.T1 AND (NOT(-.T1));
		COUNT_.COUNT+1;
	END;
	.COUNT
END$;

%(*******TO CLEAR A GIVEN BIT IN A GIVEN WORD (THE ARG IX INDICATES THE BIT
	TO BE CLEARED, PTN1 IS THE WORD TO CLEAR IT FROM********)%
MACRO
	CLRBIT(PTN1,IX)=BEGIN
				EXTERNAL CLRWDS;
				 PTN1 AND .CLRWDS[IX]
			END $;

%(*******TO SET A GIVEN BIT IN A GIVEN WD*******)%
MACRO
	SETBIT(PTN1,IX) =BEGIN
				EXTERNAL CLRWDS;
				 PTN1 OR NOT(.CLRWDS[IX])
			END $;

%(****TO TEST A GIVEN BIT OF A GIVEN WD***********)%
MACRO
	BITSET(PTN1,IX)=BEGIN
				EXTERNAL CLRWDS;
				 ((IX GEQ 0) AND (PTN1 AND NOT(.CLRWDS[IX])) NEQ 0)
			END$;





%(*****TO MAKE AN ENTRY IN THE CONSTANT TABLE - SET UP GLOBALS FOR
	TBLSEARCH AND CALL IT ****************)%

MACRO MAKECNST(TYPE,CNH,CNL) =
BEGIN
	EXTERNAL TBLSEARCH;
	NAME_CONTAB;
	ENTRY[0]_CNH;
	ENTRY[1]_CNL;
	SYMTYPE_TYPE;
	TBLSEARCH()
END$;

%(**********TO MAKE A CONSTANT TABLE ENTRY FOR THE NEGATIVE OR THE
		COMPLEMENT("NOT") OF SOME OTHER CONSTANT TABLE ENTRY*****)%

MACRO NEGCNST(CNNODE)=
	BEGIN
		IF .CNNODE[VALTYPE] EQL  DOUBLPREC OR .CNNODE[VALTYPE] EQL REAL
		THEN
		%(***FOR DOUBLE-PREC NEG - USE ASSEMBLY LANG ROUTINE**)%
		BEGIN
			EXTERNAL C1H,C1L,C2H,C2L,COPRIX,KDNEGB,CNSTCM;
			C1H_.CNNODE[CONST1];
			C1L_.CNNODE[CONST2];
			COPRIX_KDNEGB+.CKA10FLG;
			CNSTCM();
			MAKECNST(.CNNODE[VALTYPE],.C2H,.C2L)
		END
		ELSE
		 MAKECNST(.CNNODE[VALTYPE], -.CNNODE[CONST1], -.CNNODE[CONST2])
	END$;

MACRO NOTCNST(CNNODE)= MAKECNST(.CNNODE[VALTYPE], NOT .CNNODE[CONST1], NOT .CNNODE[CONST2])$;

%(****TO MAKE CONSTANT TABLE ENTRY FOR NOT(-X) - "NTNGCNST"
	OR -(NOT X) - "NGNTCNST"*********)%
MACRO NTNGCNST(CNNODE)=
	BEGIN
		IF .CNNODE[VALTYPE] EQL DOUBLPREC OR .CNNODE[VALTYPE] EQL REAL
		THEN
		%(***FOR DOUBLE-PREC USE ASSEMBLY LANG ROUTINE TO GET NEG**)%
		BEGIN
			%(***DNEGCNST GETS ITS ARG IN THE GLOBALS C1H,C1L***)%
			C1H_ .CNNODE[CONST1];
			C1L_.CNNODE[CONST2];
			COPRIX_KDNEGB+.CKA10FLG;
			CNSTCM();
			MAKECNST(.CNNODE[VALTYPE],NOT .C2H, NOT .C2L)
		END
		ELSE
		MAKECNST(.CNNODE[VALTYPE], NOT (-.CNNODE[CONST1]), NOT (-.CNNODE[CONST2]))
	END$;

MACRO NGNTCNST(CNNODE)=
	BEGIN
		IF .CNNODE[VALTYPE] EQL DOUBLPREC OR .CNNODE[VALTYPE] EQL REAL
		THEN
		BEGIN
			%(***DNEGCNST GETS ITS ARG IN THE GLOBALS C1H,C1L***)%
			C1H_NOT .CNNODE[CONST1];
			C1L_NOT .CNNODE[CONST2];
			COPRIX_KDNEGB+.CKA10FLG;
			CNSTCM();
			MAKECNST(.CNNODE[VALTYPE],.C1H,.C1L)
		END
		ELSE
		MAKECNST(.CNNODE[VALTYPE],-(NOT .CNNODE[CONST1]), -(NOT .CNNODE[CONST2]))
	END$;



%(******************************
	MACROES TO FORM INDICES  INTO THE TABLE FOR CONSTANT FOLDING
********************************)%

	%(***TO FOLD BOOLEAN OPERATIONS***)%
MACRO	KBOOLOPIX(PNODE)=
	(.PNODE[OPERSP] + KBOOLBASE)$;

	%(***TO FOLD ARITHMETIC OPERATIONS****)%
MACRO	KARITHOPIX(PNODE)=
	(.PNODE[OPRSP2]^2 + .PNODE[VALTP1] + (IF .CKA10FLG THEN KARIAB  ELSE KARIIB) )$;

	%(*******TO FOLD AN ARITH OP, WHEN NO EXPRESSION NODE WAS BUILT (VLTP IS THE VALTP1 FIELD)***)%
MACRO	KKARITHOP(VLTP,OPSP)=
	(OPSP^2 + VLTP + (IF .CKA10FLG THEN KARIAB ELSE KARIIB))$;


	%(****TO CONVERT A CONSTANT OF ONE VALUE TYPE TO ANOTHER****)%
MACRO KTPCNVIX(TPCNODE)=
	(.TPCNODE[OPERSP]^3 + .TPCNODE[VALTP2] +KTYPCB)$;


	%(****TO CONVERT A CONSTANT FROM ONE VALTYPE TO ANOTHER WHEN NO EXPRESSION
		NODE WAS BUILT FOR THE TYPE CONVERSION. (VLTP IS THE VALTP2 FIELD)***)%
MACRO	KKTPCNVIX(VLTP,OPSP)=
	(OPSP^3 + VLTP + KTYPCB)$;


	%(***TO FOLD SPECIAL OPERATORS (P2MUL,P2DIV)  - USED ONLY BY PHASE 2***)%
MACRO	KSPECOPIX(PNODE)=
	(.PNODE[OPERSP]^2 + .PNODE[VALTP1] + KSPECB)$;


	%(***TO FOLD IN-LINE FNS********)%
MACRO	KILFOPIX(PNODE)=
	(.PNODE[OPERSP] + (IF .PNODE[VALTP1] EQL INTEG1 THEN KILFBA ELSE KILFBR))$;

	%(*****FOR CNODE ARITHMETIC OR BOOLEAN
		CHECK TO SEE IF A SKEWED TREE IS AN NARYNODE*****)%

	MACRO NARYNODE(CNODE,AR1NODE)=
	(.CNODE[OPR1] EQL .AR1NODE[OPR1]
	AND
	.CNODE[OPR1] LSS DIVOPF
	AND
	NOT .CNODE[A1NEGFLG] AND NOT .CNODE[A1NOTFLG]
	AND
	NOT .AR1NODE[PARENFLG])$;




%(***************************************************************************
	TO GET CORE TO BUILD A NODE OF A CERTAIN TYPE.
	AT PRESENT  CALL CORMAN WITH NAME<LEFT> EQUAL TO THE SIZE
	NEEDED (SRM - AUG 18,1972)
***************************************************************************)%

MACRO	GETCORE(NDSIZ,NDTYP)=
BEGIN
	NAME<LEFT>_NDSIZ;
	CORMAN()
END$;

	%(***NODE SIZES****)%
BIND	IOLCSIZ=3;	!FOR AN IOLISTCALL NODE

	%(***NODE TYPE CODES***)%
BIND	IOLCCD=1;	!FOR AN IOLISTCALL NODE

%(***************************************************************************
	MACROS USED FOR CONSISTENCY CHECKING - FOR DEBUGGING THE COMPILER
***************************************************************************)%


%(***TO CHECK WHETHER ARE WALKING DOWN ONTO A LEGAL NODE***)%
MACRO DEBGNODETST(NODE)=
BEGIN
	EXTERNAL NODERR;
	IF DEBUGFLG			!A COMPILE TIME CONSTANT 
	THEN
	BEGIN
		IF .NODE EQL 0
		THEN NODERR();
	END;
END$;




!MACROS FOR THE FLAGS ASSOCIATED WITH A DO LOOP


%******
	FLAGS ASSOCIATED WITH A DO LOOP FOR CODE GENERATION
	INNERDOFLG=0,1,35,1				!FLAG SET BY PHASE 1 ON INNER DO LOOP
*****%
	MACRO
		FLCWD=0,1,34,1$,			!FULL CONST WORD INITIAL VALUE AND
							!LOOP CONTROL
							!SET IN DOXPND OR BY THE OPTIMIZER
		SSIZONE=0,1,33,1$,			!STEP SIZE ONE
							!SET IN DOXPND OR BY OPTIMIZER
		SSIZIMMED=0,1,32,1$,			!STEP SIZE IS AN IMMEDIATE CONSTANT (INTEGER)#1
		INITLIMMED=0,1,31,1$,			!INITIAL VALUE IS IMMEDIATE
							!SET IN DOXPN OR OPTIMIZER
		REALARITH=0,1,30,1$,			!DO SYMBOL IS REAL SO ALL ARITHMETIC MUST BE
							!REAL
		INITLTMP=0,1,29,1$,			!INITL VALUE NEEDS COMPUTATION
		SSIZINTMP=0,1,28,1$,			!STEP SIZE IN A TEMP
		IVARINREG=0,1,27,1$,			!DO INDUCTION VARIABLE IS IN A REGISTER
							!SET BY OPTIMIZER
		NEDSMATRLZ =0,1,26,1$,			!LOOPHAS EXIT
		CTLSAMEFLG=0,1,25,1$,			!CONTROL EXPR WAS COMPUTED INTO
							! THE REG IN WHICH IT WILL
							! BE USED
		NOFLCWDREG=0,1,23,1$,			!IF THE DO INDEX OF THIS LOOP
							! IS NOT MATERIALIZED, THEN
							! AOBJN SHOULD NOT BE USED FOR
							! THE LOOP
		SSIZNEGFLG=0,1,22,1$,			!STEP SIZE IS A NAGATIVE INTEGER IMMED
							! CONSTANT AND HENCE MUST BE NEGATED
							! WHEN IT IS PICKED UP (IE
							! AT LOOP END MUST DO SUBI RATHER
							! THAN ADDI)
		DOREMOVED=0,1,21,1$,			!OPTIMIZER HAS DELETED DO LOOP
		CTLNEG=0,1,20,1$,			!CTL VAL MUST BE NEGATED WHEN IT IS
							! PICKED UP (THIS IS ALWAYS SET IF CTL
							! VAL IS A CONSTANT BUT NOT FLCWD
		CTLIMMED=0,1,19,1$,			!CTL VAL IS AN IMMED CONST
		INITLNEG=0,1,18,1$;			!INITL VALUE MUST BE NEGATED WHEN
							! IT IS PICKED UP

%*****
	TO ACCESS RIGHT AND LEFT HALVES OF A WORD THROUGH A
	CASE,WD,POS,SIZ STRUCTURE.
	USED ON DOSP AND SNDOLNK LIST
*****%

MACRO
	RIGHTP = 0,0,RIGHT$,
	LEFTP =0,0,LEFT$;

%*****
	MACROS TO PICK UP COMBINATIONS OF THE FLAGS
*****%

MACRO
	DOFLGS = 0,1,28,7$,		!ALL INDEX USED FLAGS
	OTHDOFLGS=0,1,27,8$;		!ALL THE FLAGS EXCEPT INNERDO AND FLCWD
!******
!	FIELDS IN DOWDP USED TO DETERMINE
!	IF IT IS VALID TO KEEP THE DO INDEX VARIABLE IN A 
!	REGISTER THROUGHOUT THE LOOP
!*****

	MACRO
		DOISUBS=0,35,1$,
		DONOAOBJN=0,34,1$,	!FLAG FOR "DONT USE AOBJN FOR THIS LOOP
					! IF VAL OF INDEX IS NOT MATERIALIZED
		DOINDUC=0,0,18$,
		DOREGPTR=0,18,17$;

   H<m