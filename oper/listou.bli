!AUTHOR F.INFANTE
!COPYRIGHT 1973, DIGITAL EQUIPMENT CORP., MAYNARD,MASS.
GLOBAL BIND LISOV=32;	!VERSION DATE:12-JUNE-73
!THE ROUTINES IN THIS MODULE ARE FOR THE PURPOSE
!OF GENERATING THE FOLLOWING THINGS:
%	THE MACRO EXPANDED LISTING OF THE CODE GENERATED
I	.THE GENERATION OF THE RELOCATABLE BINARY INFORMATION IN THE
	 .REL FILE
%
EXTERNAL RDATWD,RELOUT;	!CONTAINS CURRENT REL DATA WD

EXTERNAL LSTOUT,ERROUT,
	LOWLOC,	!CURRENT LOWSEG AVAILABLE LOCATION
	HILOC,	!CURRENT HISEG AVAILABLE LOCATION
	RELBLOCK,	!RELOCATABLE BINARY BLOCK
	RELDATA,	!DATA WORD <LEFT> = CURRENT BLOCK NUMBER
				   !<RIGHT> = CURRENT DATA COUNT
	RELOCWD;	!THE RELOCATION WORD FOR THE BLOCK
!
MACRO EXITUUO = #047000000012$;
!
!
EXTERNAL RELOCPTR;	!2 BIT BYTE PTR TO RELOCWD
MACRO RBLOKTYPE = RELBLOCK[0]<LEFT>$,
	RDATCOUNT = RELBLOCK[0]<RIGHT>$,
	RRELOC = RELBLOCK[1]$,
	RDATA(I) = (RELBLOCK+2)[I]$,
	RBLKSIZ = #22$,	!SIZE OF REL DATA BLOCK
	ZDATCNT = RELDATA<RIGHT>$,	!CURRENT COUNT OF DATA WORDS MAX IS 18
	CBLK = RELDATA<LEFT>$;	!CURRENT BLOCK TYPE
!
!
!DEFINE THE LOADER BLOCK TYPES AND DATA INFORMATION
!
MACRO	RCODE = 1$,	!CODE AND DATA BLOCK
	RSYMBOL = 2$,	!SYMBOL BLOCK
		RGLOBDEF = 4^30$,	!GLOBAL DEF IN RSYMBOL
		RLOCDEF = #10^30$,	!LOCAL DEF IN RSYMBOL
		RLOCREQ = #10^30$,	!LOCAL REQUEST IN RSYMBOL
		RLOCFIX = #50^30$,	!LOCAL FIXUP FOR COMMON BLOCK VARIABLE
		RGLOBREQ = #60^30$,	!GLOBAL REQUEST
		RGLOB0 = 0$,	!CHAINED GLOBAL REQUEST
		RGLOB4 = #400000$,	!ADDITIVE GLOBAL IN RSYMBOL
	RHISEG = 3$,	!HISEG BLOCK
	RENTRY = 4$,	!ENTRY BLOCK
	REND =   5$,	!END BLOCK
	RNAME  = 6$,	!NAME BLOCK
	RSTART = 7$,	!START ADDRESS BLOCK
	RLOCAL = #10$,	!LOCAL BLOCK
	RPOLISH = #11$,	!POLISH FIXUP BLOCK


	RELN =  0$,	!NO RELOCATION BITS
	RELRI = 1$,	!RELOCATE RIGHT
	RELL = 2$,	!RELOCATE LEFT
	RELB = 3$;	!RELOCATE BOTH HALVES
MACRO CRLF=
BEGIN
CHR_ #15; LSTOUT(); CHR _ #12; LSTOUT()
END$;
ROUTINE DMPSYMTAB=	!DUMPS THE SYMBOL TABLE TO REL FILE
BEGIN
EXTERNAL SYMTBL,LABTBL,FRSTLNK,RADIX50,ZOUTBLOCK,PROGNAME;
LOCAL BASE  SYMPTR,LABL;
	DECR I FROM SSIZ-1 TO 0 DO
	BEGIN
		IF (SYMPTR _ .SYMTBL[.I]) NEQ 0
		THEN BEGIN
			DO BEGIN
				IF .SYMPTR[IDATTRIBUT(INCOM)]
				THEN
				  BEGIN
					MAP BASE R2;
					R2 _ .SYMPTR[IDSYMBOL]; RDATWD _ RLOCREQ+RADIX50();
					ZOUTBLOCK(RSYMBOL,RELN);
					RDATWD _ .SYMPTR[IDADDR];	!COMMON BLOCK OFFSET
					ZOUTBLOCK(RSYMBOL,RELN);
					R2 _ .SYMPTR[IDCOMMON]; R2 _ .R2[COMNAME];
					RDATWD _ RGLOBREQ + RADIX50();
					ZOUTBLOCK(RSYMBOL,RELN);
					R2 _ .SYMPTR[IDSYMBOL]; RDATWD _ RLOCFIX + RADIX50();
					ZOUTBLOCK(RSYMBOL,RELN);
				  END
				ELSE
				IF .SYMPTR[OPRSP1] NEQ FNNAME1 AND
				NOT .SYMPTR[IDATTRIBUT(NOALLOC)] THEN
				  BEGIN
					R2 _ .SYMPTR[IDSYMBOL];
					RDATWD _ RLOCREQ + RADIX50();
					ZOUTBLOCK(RSYMBOL,RELN);
					RDATWD _ .SYMPTR[IDADDR];
					ZOUTBLOCK(RSYMBOL,RELRI);
				  END;
			   END WHILE (SYMPTR _ .SYMPTR[CLINK]) NEQ 0;
		      END;
	END;
	!
	!DUMP THE LOCAL LABLES NOW
	!
	DECR I FROM LASIZ-1 TO 0 DO
	BEGIN
	  IF (SYMPTR _ .LABTBL[.I]) NEQ 0 THEN
		BEGIN
		  DO BEGIN
			LABL _ 0;
			R1 _ .SYMPTR[SNUMBER];
			LABL<30,6> _ IF .R1 GTR 99999 THEN (R1 _ .R1-99999; SIXBIT "M" ) ELSE SIXBIT "P";
			DO (
				LABL _ .LABL ^(-6);
				R2 _ .R1 MOD 10; R1 _ .R1/10;
				LABL<30,6> _ (#20[.R2]<0,0>); !MAKING ROOM FOR NEXT
				IF .R1 EQL 0 THEN EXITLOOP;
	   		   ) WHILE 1;
			R2 _ .LABL;
			RDATWD _ RLOCREQ + RADIX50();
			ZOUTBLOCK(RSYMBOL,RELN);
			RDATWD _ .SYMPTR[SNADDR];
			ZOUTBLOCK(RSYMBOL,RELRI);
!
		     END WHILE (SYMPTR _ .SYMPTR[CLINK]) NEQ 0;
		END;
	END;
!
!DUMP THE LOCAL TEMPORARIES NAMES
!
	WHILE .FRSTLNK NEQ 0
	DO (
		MAP BASE FRSTLNK;
		R2 _ .FRSTLNK[IDSYMBOL];
			RDATWD _ RLOCREQ + RADIX50();
			ZOUTBLOCK(RSYMBOL,RELN);
			RDATWD _ .FRSTLNK[IDADDR];
			ZOUTBLOCK(RSYMBOL,RELRI);
		FRSTLNK _ .FRSTLNK[CLINK]
	   );
END;	!OF DMPSYMTAB
ROUTINE ZSIXBIT(ZVAL)=	!CONVERT ZVAL TO SIXBIT SYMBOL
BEGIN
R2 _ SIXBIT 'P';
DECR I FROM 5 TO 0 DO
BEGIN
	R2 _ .R2^(-6); R2<30,6> _ (.ZVAL MOD 10) + #40; ZVAL _ .ZVAL/10;
	IF .ZVAL EQL 0 THEN EXITLOOP;
END;
RETURN .R2
END;
GLOBAL ROUTINE ZOUTMSG(PTR)=
BEGIN
	PTR_(.PTR-1)<0,7>;
	UNTIL (CHR_SCANI(PTR)) EQL 0 DO LSTOUT();
END;
ROUTINE ZOUTSYM=
!R2 CONTAINS SYMBOL IN SIXBIT TO BE LISTED
DECR I FROM 5 TO 0 DO
BEGIN
	R1 _ 0; LSHC(R1,6);
	IF .R1 GTR 0
	  THEN (CHR _ .R1+#40; LSTOUT())
	  ELSE RETURN
END;
!
ROUTINE ZOUTCON=
BEGIN
!LIST A CONSTANT IN OCTAL ; R2 CONTAINS VALUE
CHR _ "["; LSTOUT();
DECR I FROM 11 TO 0 DO
BEGIN
	R1 _ 0; LSHC(R1,3);
	CHR _ .R1 + #60; LSTOUT();
END;
CHR _ "]"; LSTOUT()
END;
ROUTINE COMCOM=
BEGIN
	EXTERNAL LSTOUT;
	CHR_",";LSTOUT();LSTOUT()
END;
ROUTINE ZOUTOCT=	!LIST OCTAL HALF WORD OR FULL WORD
			!R2<LEFT> CONTAINS HALF WORD OCTAL VALUE
BEGIN
	REGISTER I;
	R1 _ 0; I _ 6;
	DO (LSHC(R1,3); I_ .I-1; IF .I EQL 0 THEN EXITLOOP;) WHILE .R1 EQL 0;
	DO ( CHR_#60[.R1]<0,0>; LSTOUT();
		R1 _ 0; LSHC(R1,3);
	   ) WHILE (I_.I-1) GEQ 0;
	.VREG
END; !OF ZOUTOCT
ROUTINE RADIX50=	!R2 CONTAINS THE SYMBOL IN SIXBIT LEFT JUSTIFIED
			!CONVERT IT TO RADIX 50
BEGIN
REGISTER R50;
MACRO SIXALPHA(X) =MOVEI(VREG,-#40,X) LEQ ("Z"-#100)$, !SIXBIT ALPHA
	SIXDIGIT(X) =MOVEI(VREG,-#20,X) LEQ 9$; !SIXBIT DIGIT
R50_0;
DO (
	R1 _ 0; LSHC(R1,6);
	IF SIXALPHA(R1) THEN R1 _ .R1 -#26
	  ELSE IF SIXDIGIT(R1) THEN R1 _ .R1 -#17
	    ELSE R1 _ #45;	!A . BY DEFAULT
	R50 _ .R50*#50; R50 _ .R50 + .R1;
   ) WHILE .R2 NEQ 0;
RETURN .R50
END;

ROUTINE LSTINST(IPTR)=
BEGIN
%
ROUTNE LISTS ON LISTING DEVICE THE MACRO -10 MNEMONICS OF THE INSTRUCTIONS BEING GENERATED
%
MACRO
	IISN	= (@IPTR)<FULL>$,	!LINENUMBER OF INSTRUCTION
	ILABEL	= (@IPTR+1)<LEFT>$,
	IADDRPTR	= (@IPTR+1)<RIGHT>$,
	IOPCODE	= (@IPTR+2)<27,9>$,
	IAC	= (@IPTR+2)<23,4>$,
	IINDIR = (@IPTR+2)<22,1>$,
	IINDEX = (@IPTR+2)<18,4>$,
	IEFFADDR = (@IPTR+2)<RIGHT>$;
EXTERNAL CODELINES;
MACRO HEADRSW = CODELINES<LEFT>$;
LOCAL OPPOINT;
EXTERNAL OPMNEM;
!
ROUTINE ZOUDECIMAL=
BEGIN
!	DECIMAL OUTPUT VALUE IN R1
LOCAL Z[6];
INCR I FROM 0 TO 5 DO
	(Z[.I] _ (.R1 MOD 10);
	 R1 _ .R1/10;
	 IF .R1 EQL 0 THEN
		(DECR J FROM .I TO 0 DO (CHR _  .Z[.J] +#60; LSTOUT());
		 RETURN
		);
	)
END;
GLOBAL ROUTINE ZOUOFFSET=
BEGIN
LOCAL Z[6];
!LIST IN ASCII THE VALUE OF R1 A REGISTER
IF .R1 LSS 0 THEN CHR _ "-" ELSE CHR _ "+";
LSTOUT();
R2<LEFT> _ ABS(.R1);
ZOUTOCT();	!OCTAL OUTPUT VALUE IN R2<LEFT>
END;
ROUTINE ZLABLMAK(ILABLPT)=
BEGIN
%R1 CONTAINS LABEL IN BINARY%
MAP BASE ILABLPT;
R1_.ILABLPT[SNUMBER];
IF .R1 GTR 99999 THEN R1 _ .R1-99999; !REDUCE TO NICE RANGE
ZOUDECIMAL(); !OUTPUT VALUE OF R1 IN DECIMAL
		  IF .ILABLPT[SNUMBER] GTR 99999
			THEN CHR _ "M" ELSE CHR _ "P";
		  LSTOUT(); .VREG
END;	!OF ROUTINE ZMAKLABL
IF .HEADRSW NEQ #777777
	THEN(ZOUTMSG(PLIT ASCIZ '?M?J?M?JLINE	LOC	LABEL	GENERATED CODE?M?J');
		CODELINES _ 0;
		HEADRSW _ #777777
	    );
CRLF;
IF (R1 _ .IISN) GEQ 0
	THEN IF .R1 EQL 0 THEN ( CHR _ "*"; LSTOUT()) ELSE ZOUDECIMAL();
CHR _ #11; LSTOUT(); !TAB
IF .IADDRPTR EQL PBFENTRY
	THEN(MAP BASE R2;
		CHR _ #15; LSTOUT(); CHR _ #12; LSTOUT(); CHR _ #11; LSTOUT();
		R2 _ .IEFFADDR; R2 _ .R2[IDSYMBOL]; ZOUTSYM();
		CHR _ ":"; LSTOUT();
		RETURN
	    );
!
!GEN THE RELATIVE LOCATION (OCTAL)
!
R2<LEFT> _ .CODELINES<RIGHT>; ZOUTOCT(); CHR _ #11; LSTOUT(); %TAB%
CODELINES _ .CODELINES + 1;
IF  .ILABEL NEQ 0 	!LIST A LABEL
  THEN 	(
	 LOCAL BASE LABPT;
	 LABPT _ .ILABEL;
	 DO
	 (
	 ZLABLMAK(.LABPT);
	 CHR _ ":"; LSTOUT(); CRLF;
	 CHR _ #11; LSTOUT(); LSTOUT(); !TAB
         ) WHILE (LABPT _ .LABPT[SNNXTLAB]) NEQ 0;
	);

CHR _ #11; LSTOUT();	!TAB
!NOW DO THE INSTRUCTION LISTING
!
IF .IOPCODE NEQ 0
THEN(
	OPPOINT _ (OPMNEM-#111)[.IOPCODE]<0,6>;	!MNEMONIC TABLE POINTER
	INCR I FROM 0 TO 5 DO
	  (CHR _SCANI(OPPOINT,CHR);	!GET A CHARACTER
	   IF(CHR _ .CHR + #40 ) LEQ #100 THEN EXITLOOP;
	   LSTOUT()
	  )
    );
CHR _ #11;	LSTOUT();	!TAB
!AC FIELD
!
IF .IAC LEQ 7 
  THEN (CHR _ .IAC + #60; LSTOUT())
   ELSE (CHR _ "1"; LSTOUT();
	 CHR _ (.IAC + #50); LSTOUT()
 	);
CHR _ ","; LSTOUT();
!
!INDIRECT BIT
!
IF .IINDIR NEQ 0 THEN (CHR _ "@"; LSTOUT());
!
!ADDRESS
!
BEGIN BIND ZADDR = IADDRPTR; MAP BASE ZADDR;
  IF .IADDRPTR GTR PBF2LABREF
    THEN
	(IF SYMBOL(ZADDR)
	  THEN ( R2 _ .ZADDR[IDSYMBOL];
		ZOUTSYM()
		)
	  ELSE IF .ZADDR[OPERSP] EQL CONSTANT
		THEN ( IF .ZADDR[DBLFLG] OR .ZADDR[VALTYPE] EQL REAL
			THEN(IF .ZADDR[CONADDR] EQL .IEFFADDR
				THEN R2 _ .ZADDR[CONST1]
				ELSE R2 _ .ZADDR[CONST2]
			    )
			ELSE R2 _ .ZADDR[CONST2]; !ELSE INTEGER OR LOGICAL OR BYTE
			RETURN ZOUTCON()
		     )
		ELSE
			(R2_.ZADDR[IDSYMBOL]; ZOUTSYM(););
	IF (R1 _ EXTSIGN(.IEFFADDR) -.ZADDR[IDADDR]) NEQ 0 THEN ZOUOFFSET();
       )
  ELSE IF .IADDRPTR GTR 3 THEN BEGIN END
    ELSE IF .IADDRPTR GTR 2
	THEN BEGIN MAP BASE R2;
		R2_.IEFFADDR; R2 _ .R2[IDSYMBOL];
		ZOUTSYM()
	     END
	ELSE IF .IADDRPTR GTR 1
		THEN !DOTTED FUNCTION NAME
		  (R2 _@(.IEFFADDR);
		   ZOUTSYM()
		  )
		ELSE  IF .IADDRPTR GTR 0	!NO SYMBOLIC ADDR
			THEN (R2<LEFT> _ .IEFFADDR; ZOUTOCT()) !IMMEDIATE MODE VALUE
			ELSE  ZLABLMAK(.IEFFADDR);
END;
!
!INDEX FIELD
!
IF .IINDEX NEQ 0
  THEN ( CHR _ "("; LSTOUT();
	IF .IINDEX LEQ 7
		THEN (CHR _ .IINDEX +#60; LSTOUT())
		ELSE (CHR _ "1"; LSTOUT();CHR _ .IINDEX +#50; LSTOUT()
		     );
	 CHR _ ")"; LSTOUT();
	);
END;	!OF ROUTINE LSTINST
ROUTINE DMPRELONLST=
BEGIN
	CRLF;
	INCR I FROM 0 TO .RDATCOUNT+1 DO
	BEGIN
		R2 _.RELBLOCK[.I];
		DECR J FROM 11 TO 0
		DO (	R1 _ 0; LSHC(R1,3);
			CHR _ #60[.R1]<0,0>;
			LSTOUT();
		   );
		CRLF;
	END;
	.VREG
END;
GLOBAL ROUTINE ZDMPBLK=
BEGIN
%OUTPUT THE RELBLOCK TO THE REL FILE%
IF .ZDATCNT NEQ 0
THEN
  BEGIN
	RBLOKTYPE _ .CBLK;
	RRELOC _ .RELOCWD; !RELOCATION BITS
	RDATCOUNT _ .ZDATCNT;
	INCR I FROM 0 TO .RDATCOUNT+1 DO
	  (CHR _ .RELBLOCK[.I]; RELOUT());
	IF .FLGREG<EXPAND> THEN IF .FLGREG<LISTING> THEN DMPRELONLST();
	ZDATCNT _ 0; RELOCWD _ 0; RELOCPTR _ (RELOCWD-1)<0,2>; !REINITIALIZE
  END;

  .VREG
END;	!OF ROUTINE ZDMPBLK
GLOBAL ROUTINE ZOUTBLOCK(ZBLKTYPE,RELBITS)=
BEGIN
EXTERNAL RELOUT;
%
ROUTINE OUTPUTS THE RELOCATABLE DATA IN RDATWD TO THE REL FILE
USES A 20 WORD BUFFER TO STORE DATA AS DEFINED BY THE LOADER
SPECIFICATIONS.
ZBLKTYPE IS THE BLOCK TYPE TO BE OUTPUT NOW
RELBITS IS THE RELOCATION INFORMATION ASSOCIATED WITH THE CURRENT WORD OF DATA
%
!
!
!BEGIN ZOUTBLOCK HERE
!
IF .ZDATCNT EQL RBLKSIZ-2 THEN ZDMPBLK();
IF .ZBLKTYPE NEQ .CBLK
THEN
  (ZDMPBLK(); CBLK _ .ZBLKTYPE); !DUMP OUT OLD BLOCK BEGIN A NEW TYPE
	IF (.CBLK EQL RCODE) AND (.ZDATCNT EQL 0)
	THEN	( !PUT OUT ADDRESS WORD AS FIRST WORD OF CODE BLOCK
		 REPLACEI(RELOCPTR,RELRI);
		 RDATA(0)_.HILOC;	!START ADDR FOR LOADING CODE OR DATA
		RELDATA _ .RELDATA+1; !INCREMENT ZDATCNT
		);
REPLACEI(RELOCPTR,.RELBITS);
RDATA(.ZDATCNT) _ .RDATWD;
RELDATA _ .RELDATA+1;	!INCREMENTING ZDATCNT
END;	!OF ROUTINE ZOUTBLOCK
ROUTINE DATAOUT(ZBLKTYPE,RELBITS)=
BEGIN
%
ROUTINE BUILDS RELOCATABLE BINARY BLOCKS FOR DATA INITIALIZATION
%
EXTERNAL ZDMPBLK;
	IF .ZDATCNT EQL RBLKSIZ-2 THEN ZDMPBLK();
	IF .ZBLKTYPE NEQ .CBLK THEN (ZDMPBLK(); CBLK _ .ZBLKTYPE;);
	REPLACEI(RELOCPTR,.RELBITS);
	RDATA(.ZDATCNT) _ .RDATWD;
	RELDATA _ .RELDATA + 1;
END;	!OF DATAOUT
GLOBAL ROUTINE OUTDATA(SYMADDR,SYMVALUE,SYMPT)=
BEGIN
%
ROUTINE INSTRUCTS LOADER ABOUT INITIALIZATION OF LOW SEG DATA AS SPECIFIED
IN DATA STATEMENTS.  SYMPT IS PTR TO SYMBOL BEING INITIALIZED.
SYMVALUE IS VALUE TO USE IN ITIALIZATION. SYMADDR IS THE ALLOCATED
ADDRESS OF THE SYMBOL
%
EXTERNAL ZDMPBLK;
MAP BASE R2:SYMPT;
BIND RDATBLK = #21;	!LOADER BLOCK TYPE FOR DATA FIXUP
	IF .SYMPT[IDATTRIBUT(INCOM)]
	THEN BEGIN	!DO SPECIAL BLOCK 1 FIXUP
		IF .ZDATCNT GTR RBLKSIZ-5 THEN ZDMPBLK();	!NO ROOM LEFT IN BUFFER FOR NEXT 3 WORDS
		R2 _ .SYMPT[IDCOMMON]; !PTR TO COMMON BLOCK NODE
		R2 _ .R2[COMNAME];
		RDATWD _ RGLOBREQ + RADIX50();
		DATAOUT(RDATBLK,RELN);
		RDATWD _ (1^18) + .SYMADDR<RIGHT>;
		DATAOUT(RDATBLK,RELN);
		RDATWD _ .SYMVALUE;
		DATAOUT(RDATBLK,RELN);
	     END
	ELSE BEGIN
		IF .ZDATCNT GTR RBLKSIZ-4 THEN ZDMPBLK(); !NO ROOM LEFT IN BUFFER FOR 2 WORDS
		RDATWD _ (1^18)+.SYMADDR<RIGHT>;
		DATAOUT(RDATBLK,RELRI);
		RDATWD _ .SYMVALUE;
		DATAOUT(RDATBLK,RELN);
	     END;
END;	!OF OUTDATA
ROUTINE ROUIMFUN(FUNCPTR,FUNAME)=	!OUTPUT FUNCTION REQUEST GLOBAL
BEGIN
			RDATWD_.FUNCPTR<LEFT>^18; ZOUTBLOCK(RCODE,RELN);
			R2 _ .FUNAME; !SIXBIT SYMBOL NAME
			RDATWD_(RGLOBREQ +RADIX50()); ZOUTBLOCK(RSYMBOL,RELN);
			RDATWD_RGLOB0^18 + .HILOC;
			ZOUTBLOCK(RSYMBOL,RELRI)
END;
ROUTINE ROURLABEL(LABLPTR)=
BEGIN
MAP BASE LABLPTR;
		 RDATWD<LEFT> _ .LABLPTR<LEFT>;
		IF .LABLPTR[SNSTATUS] NEQ OUTPBUFF  THEN 
			IF .LABLPTR[SNDEFINED] NEQ #777777 THEN(LABLPTR[SNADDR]_0;LABLPTR[SNDEFINED]_#777777);
		 RDATWD<RIGHT> _ .LABLPTR[SNADDR];
!
!AT THIS POINT RDATWD<RIGHT> CONTAINS EITHER 0 (IF FIRST TIME LABEL REFERENCED)
! OR A HI-SEG CHAIN ADDRESS IF NOT FIRST REFERENCE AND STILL UNDEFINED
! OR THE HI-SEG ADDRESS OF THE INSTRUCTION THE LABEL DEFINES
! THE VALUE OUTPBUFF MEANS THE LABEL HAS BEEN DEFINED TO LOADER
!
		 ZOUTBLOCK(RCODE,IF .LABLPTR[SNADDR] EQL 0 THEN RELN ELSE RELRI);
		!RELOCATE (RELRI) ONLY IF NOT FIRST REFERENCE
		IF  .LABLPTR[SNSTATUS] NEQ OUTPBUFF  THEN LABLPTR[SNADDR] _ .HILOC; !CHAIN THE REQUEST
END;	!END OF ROURLABEL
ROUTINE ROUSYM(INSTRUCTION,INSADDR)=	!RELOCATABLE SYMBOLIC OUTPUT
BEGIN
	MACRO ADD=3$,SUBT=4$;
	MACRO POLISHREL(OP,OPER1,RELOC1,OPER2,RELOC2,SYM)=
	BEGIN
		RDATWD _ OP;	!MEANS NEXT WD IS FULL WD OPERAND
		ZOUTBLOCK(RPOLISH,RELN);
		RDATWD _ OPER1;	!FULL WORD
		ZOUTBLOCK(RPOLISH,RELOC1);
		RDATWD _ OPER2;
		ZOUTBLOCK(RPOLISH,RELOC2);
		RDATWD _ #777777^18 + .HILOC;	!RIGHT HALF CHAINED FIXUP,, ADDRESS
		ZOUTBLOCK(RPOLISH,RELRI);
	END$;
		MAP BASE R2;
		LOCAL BASE SYMPTR; SYMPTR _ .INSADDR<RIGHT>;
		!NOW CHECK FOR SUBROUTINE OR FUNCTION CALL
		IF NOT SYMBOL(SYMPTR)
		THEN (RDATWD _ .INSTRUCTION;  ZOUTBLOCK(RCODE,RELRI);
			RETURN
		     );
		IF .SYMPTR[OPRSP1] EQL FNNAME1 
		  THEN 
			IF (NOT .SYMPTR[IDATTRIBUT(FENTRYNAME)])
				THEN IF (NOT .SYMPTR[IDATTRIBUT(DUMMY)])
					THEN (ROUIMFUN(.INSTRUCTION,.SYMPTR[IDSYMBOL]);
				RETURN
			);
		!HERE IF NOT A FUNCTION CALL OR SUBROUTINE CALL
		RDATWD _ .INSTRUCTION;
		IF ( EXTSIGN(.INSTRUCTION<RIGHT>)) LSS (-#400)
		THEN
			(RDATWD<RIGHT> _ 0;
			 ZOUTBLOCK(RCODE,RELN);
				IF NOT .SYMPTR[IDATTRIBUT(INCOM)] THEN
				 POLISHREL(ADD^18+1,EXTSIGN(.INSTRUCTION<RIGHT>),
					RELN,0,RELRI,.SYMPTR)	!GENERAT A POLISH FIXUP BLOCK
	   		ELSE
			   BEGIN
				RDATWD _ ADD^18+2;	!NEXT WD IS GLOBAL REQUEST
				ZOUTBLOCK(RPOLISH,RELN);
				R2 _ .SYMPTR[IDCOMMON]; R2 _ .R2[COMNAME];
				 RDATWD _ RGLOBDEF + RADIX50();  !A GLOBAL REQUEST POLISH FIXUP
				 ZOUTBLOCK(RPOLISH,RELN);
				  RDATWD _ #1777777;	!1^18 + -1
				 ZOUTBLOCK(RPOLISH,RELN);
				 RDATWD _ .INSTRUCTION<RIGHT>^18+#777777;
				 ZOUTBLOCK(RPOLISH,RELN);
				 RDATWD _ .HILOC^18;
				  ZOUTBLOCK(RPOLISH,RELL);  !FINALLY O/P THE FIXUP ADDRESS
			   END;
			   RETURN
			)
		ELSE
		IF .SYMPTR[IDATTRIBUT(INCOM)]
		    THEN	!GENERATE INSTRUCTION
		      (
			ZOUTBLOCK(RCODE,RELN);	!OUTPUT THE INSTRUCTION
			R2 _ .SYMPTR[IDCOMMON]; R2 _ .R2[COMNAME];
			RDATWD _ (RGLOBREQ + RADIX50());
			ZOUTBLOCK(RSYMBOL,RELN);	!OUTPUT SYMBOL BLOCK
			RDATWD _ RGLOB4^18 + .HILOC;	!THE FIXUP REQUEST
			ZOUTBLOCK(RSYMBOL,RELRI);
			RETURN
		      )
			ELSE ZOUTBLOCK(RCODE,RELRI);	!OUTPUT THE INSTRUCTION
 END;
FORWARD GMULENTRY;
ROUTINE OUTMOD(CODEPTR,	!PTR TO BLOCK OF CODE TO BE GENERATED
		COUNT)=		!#OF INSTRUCTIONS TO BE GENERATED
BEGIN
%
ROUTINE GENERATES THE RLOCATABLE BINARY INSTRUCTIONS FOR THE OMPILER. ALSO
RESPONSIBLE OFR CALLING ROUTINES THAT GENERATE THE MACRO CODE LISTING
AND THE ROUTINES THAT GENERATE SYMBOL INGORMATION FOR THE LOADER
%
REGISTER CODEBLOCK;
MAP BASE R2;
MACRO INSTLABEL = (@CODEBLOCK)[.I+1]<LEFT>$,
	INSADDR = (@CODEBLOCK)[.I+1]<RIGHT>$,
	INSTRUCTION = (@CODEBLOCK)[.I+2]$;
!
!LOOP ON COUNT WHERE COUNT IS THE NUMBER OF INSTRUCTIONS TO BE GENERATED
!BUT ONE-HALF THE SIZE OF THE CODE BLOCK
!
CODEBLOCK _ .CODEPTR<RIGHT>;
IF .FLGREG<LISTING> THEN IF .FLGREG<MACROCODE> 
THEN  INCR I FROM 0 TO .COUNT-1  DO
	LSTINST((.CODEBLOCK)[.I*3]);
!START RELOCATABLE BINARY GENERATON IF REQUESTED
IF .FLGREG<OBJECT>
THEN 
     INCR I FROM 0 TO (.COUNT-1)*3 BY 3 DO
     BEGIN
	LABEL REL1;
  REL1: IF .INSADDR GTR PBFENTRY
	  THEN (ROUSYM(.INSTRUCTION,.INSADDR); LEAVE REL1)	!SYMBOLIC- IDENTIFIER,CONSTANT OR TEMP
	  ELSE		!EITHER NOT SYMBOLIC, OR LABEL OR FUNCTION CALL OR LIBRARY FUNCTION CALL "DOTTED"
	   CASE .INSADDR OF SET
	%
	0 - LABEL ADDRESS - PTR TO LABEL IN RH OF INSTRUCTION
	%
		ROURLABEL(.INSTRUCTION);	!RELOCATABLE LABEL O/P
	%
	1- NO SYMBOLIC ADDRESS OUTPUT THE INSTRUCTION
	%
		BEGIN
			RDATWD _ .INSTRUCTION;
			ZOUTBLOCK(RCODE,RELN);
			LEAVE REL1
		END;
	%
	2- FUNCTION CALL DOTTED
	%
		ROUIMFUN(.INSTRUCTION,@(.INSTRUCTION<RIGHT>));	!RELOCATABLE  IMPLICIT FUNCTION CALL
	%3- FUNCTION CALL NOT "DOTTED"
	%
		BEGIN MAP BASE R2;
			R2_.INSTRUCTION<RIGHT>;
			ROUIMFUN(.INSTRUCTION,.R2[IDSYMBOL]);
		END;
	%4-USED IN OUTMDA, NOT HERE
	%
	BEGIN END;
	%5-USED IN OUTMDA, NOT HERE
	%
	BEGIN END;
	%6-USED IN OUTMOD, NOT HERE
	%
	BEGIN END;
	%7-USED IN OUTMDA, NOT HERE
	%
	BEGIN END;
	%8-PBFENTRY, A GLOBAL ENTRY SYMBOL
	%
	BEGIN
		GMULENTRY(.INSTRUCTION<RIGHT>); !SPECIAL CASE FOR GLOBAL ENTRY DEFINITIONS(NOT AN INSTRUCTION)
		HILOC _ .HILOC-1; !DECREMENT HILOC TO OFFSET THE INCREMENT
					!COMING AT END OF LOOP SO THAT
					!NEXT INSTRUCTION WILL HAVE SAME ADDR
					!AS THAT ASSIGNED TO ENTRY SYMBOL
	END
	TES;
!
!LEAVE REL1 EXPRESSION COMES HERE
!
	IF .INSTLABEL NEQ 0
	 THEN
	(LOCAL BASE LINLABEL;
	 LINLABEL _ .INSTLABEL;
	 DO
	 BEGIN
	 IF .LINLABEL[SNADDR] GEQ #3000! ASSUME NO MORE THAN 3000 REFERENCES ELSE DEFINED
	 THEN (
		RDATWD _ .LINLABEL[SNADDR]^18+.HILOC;
		ZOUTBLOCK(RLOCAL,RELB);
		);
	   LINLABEL[SNSTATUS]_OUTPBUFF;	!DEFINE IT (HAS PASSED THRU PBUFF)
	   LINLABEL[SNADDR] _ .HILOC;	!DEF THE SYMBOL NOW
	 END WHILE (LINLABEL_.LINLABEL[SNNXTLAB]) NEQ 0;
	);
	HILOC _ .HILOC + 1;	!INCREMENT HISEG AVAILABLE LOCATION
      END;	!END OF INCR LOOP
.VREG
END;	!OF ROUTINE
GLOBAL ROUTINE OUTMDA(ARPTR,ARCOUNT)=
BEGIN
%
	ROUTINE OUTPUTS TO THE REL FILE THE ARG BLOCKS
	FOR ALL STATEMENTS THAT USE THEM. THESE INCLUDE IOLISTS,
	FUNCTION OR SUBROUTINE ARGUMENTS LISTS, AND
	OTHER ARG LISTS.

	THE CALL IS MADE TO THIS ROUTINE WITH A PTR TO THE ARGUMENT
	CODE WORDS AND A COUNT OF THE NUMBER OF WORDS TO GENERATE.
	THE FORMAT OF THE BLOCK OF WORDS IS SIMILAR TO THAT USED
	IN A CAL TO OUTMOD TO OUTPUT INSTRUCTIONS.
%

EXTERNAL ZOUOFFSET;
EXTERNAL CODELINES,LSTOUT,ZLABLMAK,ZOUTOCT,COMCOM,OUTMSG,ZOUTSYM;
MAP BASE R1:R2;
OWN HDRSW;
MACRO ILABEL = (@ARPTR)[.I+1]<LEFT>$,
	IADDRPTR = (@ARPTR)[.I+1]<RIGHT>$,
	ILADDR = (@ARPTR)[.I+2]<LEFT>$,
	IRADDR = (@ARPTR)[.I+2]<RIGHT>$,
	IARGWD = (@ARPTR)[.I+2]<FULL>$;

!
INCR I FROM 0 TO (.ARCOUNT-1)*3 BY 3 DO
  BEGIN
	IF .FLGREG<LISTING> THEN IF .FLGREG<MACROCODE> 
	THEN
	BEGIN
		CHR _ #11;LSTOUT();
		R2<LEFT> _ .CODELINES<RIGHT>; ZOUTOCT(); CHR _ #11; LSTOUT();
		CODELINES _ .CODELINES+1;
		IF .ILABEL NEQ 0 THEN(ZLABLMAK(.ILABEL); CHR_":"; LSTOUT());
		CHR_#11; LSTOUT(); !TAB
	END;
	SELECT .IADDRPTR OF NSET
	PBFLABREF:	EXITSELECT
			(
			IF .FLGREG<LISTING> THEN IF .FLGREG<MACROCODE>  THEN
			BEGIN
			 R2<LEFT>_.ILADDR; ZOUTOCT();
			 COMCOM(); ! ",,"
			 ZLABLMAK(.IRADDR); 
			END;
			IF .FLGREG<OBJECT> THEN
				ROURLABEL(.IARGWD);
			);

	PBFNOSYM:	EXITSELECT
			(
			IF .FLGREG<LISTING> THEN IF .FLGREG<MACROCODE>  THEN
			BEGIN
			 R2<LEFT>_.ILADDR; ZOUTOCT();
			 COMCOM();
			 R2<LEFT>_.IRADDR; ZOUTOCT();
			END;
			IF .FLGREG<OBJECT> THEN
			 (RDATWD _ .IARGWD; ZOUTBLOCK(RCODE,RELN));
			);
	PBF2NOSYM:	EXITSELECT
			(
			IF .FLGREG<LISTING> THEN IF .FLGREG<MACROCODE>  THEN
			BEGIN
			 R2<LEFT>_.ILADDR; ZOUTOCT();
			 COMCOM();
			 R2<LEFT>_.IRADDR; ZOUTOCT();
			END;
			IF .FLGREG<OBJECT> THEN
			 (RDATWD _ .IARGWD; ZOUTBLOCK(RCODE,RELN));

			);
	PBFIMFN:	EXITSELECT
			(
			IF .FLGREG<LISTING> THEN IF .FLGREG<MACROCODE>  THEN
			BEGIN
			 R2<LEFT> _ .ILADDR; ZOUTOCT();
			 COMCOM();
			 R2 _ @.IRADDR; ZOUTSYM();
			END;
			IF .FLGREG<OBJECT> THEN
			  ROUIMFUN(.IARGWD,@.IRADDR);

			);
	PBFEXFN:	EXITSELECT
			(
			IF .FLGREG<LISTING> THEN IF .FLGREG<MACROCODE>  THEN
			BEGIN
			 R2<LEFT> _ .ILADDR; ZOUTOCT();
			 COMCOM();
			 R2 _ .IRADDR; R2 _ .R2[IDSYMBOL]; ZOUTSYM();
			END;
			IF .FLGREG<OBJECT> THEN
			 (R2_.IRADDR; ROUIMFUN(.IARGWD,.R2[IDSYMBOL]));
			);
	PBF2LABREF:	EXITSELECT
			(IF .FLGREG<LISTING> THEN IF .FLGREG<MACROCODE>  THEN
			BEGIN
			 ZLABLMAK(.ILADDR); COMCOM(); ZLABLMAK(.IRADDR);
			END;
			IF .FLGREG<OBJECT> THEN
			 (R1 _ .ILADDR; R2 _ .IRADDR;
			  RDATWD _ .R1[SNADDR]^18 +  .R2[SNADDR];
			  ZOUTBLOCK(RCODE,RELB);
			 );
			);
	6:		EXITSELECT
			BEGIN
			  IF .FLGREG<LISTING> THEN IF .FLGREG<MACROCODE>  THEN
			   BEGIN
				R2<LEFT> _.ILADDR; ZOUTOCT();
				COMCOM();
				R2<LEFT>_ .IRADDR; ZOUTOCT();
			   END;
			  IF .FLGREG<OBJECT> THEN
			   BEGIN
				RDATWD _ .IARGWD; ZOUTBLOCK(RCODE,RELRI);
			   END;
			END;
	OTHERWISE:	BEGIN
			IF .FLGREG<LISTING> THEN IF .FLGREG<MACROCODE>  THEN
			(
			 R2<LEFT> _ .ILADDR; ZOUTOCT();
			 COMCOM();
			  R2 _ .IADDRPTR;
			   IF .R2[OPERSP] EQL CONSTANT
				THEN ( IF .R2[VALTYPE] EQL REAL OR .R2[DBLFLG]	!THIS DEPENDENT ON VALTYPE VALUES
					THEN R2 _ .R2[CONST1] !THEN REAL DP OR CMPLX
					ELSE R2 _ .R2[CONST2]; !ELSE INTEGER OR LOGICAL OR BYTE
					 ZOUTCON()
					)
				ELSE (R2 _ .R2[IDSYMBOL]; ZOUTSYM();
					R2 _ .IADDRPTR;
					IF (R1 _ EXTSIGN(.IRADDR) - .R2[IDADDR]) NEQ 0 THEN ZOUOFFSET();
				     );
			);
			IF .FLGREG<OBJECT> THEN ROUSYM(.IARGWD,.IADDRPTR);
			END;
	TESN;
	IF .FLGREG<LISTING> THEN IF .FLGREG<MACROCODE>  THEN CRLF;
	IF .FLGREG<OBJECT> THEN
	(IF .ILABEL NEQ 0
	 THEN(	R2 _ .ILABEL;
		IF .R2[SNADDR] GTR #3000	!ARBITARY # OF REFERENCES
		THEN (
			RDATWD _ .R2[SNADDR]^18+.HILOC;
			ZOUTBLOCK(RLOCAL,RELB);
		     );
		R2[SNSTATUS] _ OUTPBUFF;	!THRU THE OUTPUT BUFFFER
		R2[SNADDR] _ .HILOC;	!DEFINING THE SYMBOL NOW
	     );
	HILOC _ .HILOC + 1;	!INCREMENT HISEG AVAILABLE LOCATION
	);
  END; !OF INCR I DO
END;	!OF OUTMDA
GLOBAL ROUTINE ZENDALL(STADDR)=	!FINISHES OUTPUT OF REL FILE
			!FOR CURRENT PROGRAM
			!DUMPS SYMBOL DTABLE
			!DUMPS NEWLY DEFINED SYMBOLS
			!OUTPUTS "END" BLOCK
BEGIN
EXTERNAL ZOUTBLOCK,RADIX50,ZDMPBLK,PROGNAME,DMPSYMTAB;
	DMPSYMTAB();	!DUMP THE SYMBOL TABLE TO REL FILE
	RDATWD _ EXITUUO; ZOUTBLOCK(RCODE,RELN); !CALLI 12,0  EXIT
	IF .PROGNAME EQL SIXBIT'MAIN.' THEN (RDATWD _ .STADDR; ZOUTBLOCK(RSTART,RELRI)); !START ADDRESS BLOCK
	 RDATWD_.HILOC; ZOUTBLOCK(REND,RELRI);
	RDATWD _ .LOWLOC; ZOUTBLOCK(REND,RELRI);
	ZDMPBLK(REND)
END;
ROUTINE GMULENTRY(MULSYM)=
BEGIN
!GENERATE AN ENTRY DEFINITION (GLOBAL) IN REL FILE FOR MULTIPLE ENTRY
!NAMES; OUTMOD MUST HAVE  ALREADY BEEN CALLED TO DUMP ANY CODE IN PBUFF
!
MAP BASE MULSYM;
	R2 _ .MULSYM[IDSYMBOL];
	RDATWD _ (RGLOBDEF+RADIX50());
	ZOUTBLOCK(RSYMBOL,RELN);
	RDATWD _ .HILOC<RIGHT>;
	ZOUTBLOCK(RSYMBOL,RELRI)
END;
  @›