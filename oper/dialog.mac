TITLE	DIALOG - MODULE TO PERFORM DIALOGUES - V001
SUBTTL	D BLACK  NOV 24 71
EDITNO==1	;EDIT NUMBER
VDIALOG==1	;MAJOR VERSION NUMBER
VMINOR==0	;MINOR VERSION NUMBER
VWHO==0		;WHO LAST EDITED

;COPYRIGHT 1971, BY DIGITAL EQUIPMENT CORP., MAYNARD, MASS.

;SYMBOLS WHICH ARE PARAMETERS OF DIALOG ITSELF (PREFIX DP)

IFNDEF DP.PDL,<DP.PDL==30>	;LENGTH OF PUSH DOWN LIST
IFNDEF DP.AMX,<DP.AMX==^D10>	;MAX NO. OF ANSWERS INSIDE PARENS
IFNDEF DP.LMX,<DP.LMX==^D80>	;MAX NO. OF CHARS. ALLOWED IN INPUT LINE
		;NOT COUNTING EOL OR NULL
COMMENT "

ASSEMBLY INSTRUCTIONS:

.COMPIL DIALOGUE

LOADING INSTRUCTIONS:

.LOAD DIALOG, USER PROGRAMS

DEBUGGING INSTRUCTIONS:

.DEBUG DIALOG, USER PROGRAMS

BY DEPOSITING NON-ZERO IN LOCATION DEBUG WITH DDT, DIALOG WILL
 OUTPUT ALL FILE STUFF TO TTY TOO INSIDE <>.
"
;THE FOLLOWING MACROS(AND SUBROUTINES BY THE SAME NAME) ARE USED TO ASK
; CUSTOMER QUESTIONS AND GET HIS ANSWERS:
;SOME ANSWERS ARE NUMERIC, WHILE OTHERS ARE CHOICES LIKE Y OR N
; OR AN ITEM OUT OF A LIST.  ALL ANSWERS ARE CHECKED FOR REASONABLENESS.
; THE GOAL IS TO PREVENT AS MANY ERRORS AS POSSIBLE, SINCE ERRORS
; ARE NOT USUALLY DISCOVERED UNTIL THE MONITOR IS LOADED AND SOMETIMES
; EVEN THEN IT IS HARD TO FIND THE PROBLEM.  ALL NUMERIC ANSWERS ARE
; CHECKED FOR MIN AND MAX AS INDICATED INSIDE PARENS WITH A -
; SEPARATING THE MIN AND MAX.  IF A NUMERIC QUESTION
; DOES NOT HAVE A RANGE SPECIFIED, DIALOG WILL PRINT
; ? INTERNAL DIALOG ERROR - ABOVE QUESTION MUST HAVE (...,MIN-MAX) -
; EDIT DIALOG.
; AND EXIT.  NOTE: (MIN-?) IS OK TO MEAN NO UPPER BOUND
;  THE PROGRAMMER MUST EDIT DIALOG TO FIX HIS BUG.
;  THE CUSTOMER SHOULD NEVER SEE THIS MESSAGE, SINCE IT IS A DEBUGGING
;  AID AND SHOULD BE CAUGHT DURING TESTING.
;EACH MACRO HAS A TEXT QUESTION AS AN ARGUMENT.  THE ANSWER IS RETURNED
; IN AC N.  IF AN ERROR IS DETECTED, THE QUESTION IS
; REASKED AT NEXT HIGHER LEVEL OF VERBOSITY.  RETURN IS ALWAYS WITH
; A SUCCESSFUL VALUE.  THE CUSTOMER MAY HAVE CHANGED LEVELS OF VERBOSITY
; USING THE /HELP: FEATURE.  LOCATION SAVLV HAS CURRENT PERMANENT LEVEL,
; WHILE LEVEL FOR CURRENT QUESTION IS KEPT IN AC LV.

;ASKYN  - ANSWER Y OR N, (Y=1, N=0) NOTE: OPPOSITE FROM ASKLST
;	  HOWEVER MORE USEFUL, SINCE CAN OUTPUT DIRECTLY IN XP MACRO
;	  WHERE XP SYMBOL,1 MEANS Y AND XP SYMBOL,0 MEANS N.
;	(Y,N) MUST APPEAR IN QUESTION AS A PROMPT.  FOR CONSISTENCY
;	THE Y MUST BE BEFORE THE N SO CR ALWAYS MEANS Y.
;ASKDEC - ANSWER DECIMAL NUMBER.  QUESTION SHOULD HAVE (DEFAULT,MIN-MAX).
;	IF NO DEFAULT IS REASONABLE(SUCH AS NUMBER OF JOBS), ONLY
;	(MIN-MAX) IS REQUIRED.
;ASKOCT - ANSWER OCTAL NUMBER.  QUESTION SHOULD HAVE (DEFAULT,MIN-MAX)
;	IF NO DEFAULT IS REASONABLE, ONLY (MIN-MAX) IS REQUIRED.
;ASKLIN - ANSWER OCTAL LINE NUMBER OR CTY
;ASKSTR - ANSWER ARBITRARY STRING.  STORED IN ASCSTR AS ASCIZ.
;	N=NO. OF CHARS IN STRING NOT COUNTING NULL OR CRLF.
;ASKLST - ANSWER ONE OF THE ITEMS IN THE PROMPTING LIST IN PARENS.
;	N=0,1,2,... IE POSITION OF ANSWER IN LIST.  IF ANSWER IS NOT
;	IN LIST OR ABBREVIATION IS NOT UNIQUE, THE QUESTION IS REASKED
;	AT HIGHER LEVEL OF VERBOSITY.  ERROR MESSAGES ARE:
;	? TYPE ENOUGH TO UNIQUELY DISTINGUISH ANSWER
;	? ANSWER WITH ONE OF THE CHOICES INSIDE ( )
;	? INTERNAL DIALOG ERROR - NO "(" IN ABOVE MESSAGE -
;	EDIT DIALOG AND ADD (ANS0,ANS1,...)
;	? INTERNAL DIALOG ERROR - TOO MANY POSSIBLE ANSWERS ABOVE -
;	EDIT DIALOG AND INCREASE DP.AMX

;TO ASK A MULTIPLE LINE QUESTION, THE FOLLOWING SPECIAL MACROS:
;ASKMN  - ANSWER M OR M,N WHERE M AND N ARE OCTAL LINE
;	NUMBERS OR JUST CTY
;ASKMNP - ANSWER M,P OR M-N,P WHERE M,N, AND P ARE OCTAL LINE NUMBERS


;TO OUTPUT TO TTY, FILE OR BOTH, USE THE FOLLOWING:
; USUAL FILE OUTPUT RADIX IS OCTAL, WHILE TTY OUTPUT RADIX IS DECIMAL,
; UNLESS NAME HAS OCT OR DEC IN IT, IN WHICH THE RADICES ARE THE SAME.

;BTHOUT - OUTPUT DECIMAL TO BOTH TTY AND FILE, FILE AS A COMMENT(IE ; INSERTED)
;BTHOCT - OUTPUT OCTAL TO BOTH TTY AND FILE, FILE AS A COMMENT
;FILEOUT - OUTPUT TO FIL ONLY
;FILCOM - OUTPUT TO FILE ONLY AS A MULTI-LINE COMMENT(IE ; INSERTED)
;TTYOUT - OUTPUT TO TTY ONLY(DECIMAL)(USUAL)
;TTYOCT - OUTPUT TO TTY ONLY(OCTAL)(UNUSUAL)
;FILSTR - OUTPUT STRING IN ASCSTR TO FILE
;FILDEC - OUTPUT TO FILE WITH RADIX DECIMAL INSTEAD OF OCTAL
;FILDC2 - OUTPUT TO FILE WITH RADIX DECIMAL, AT LEAST 2 CHARS
;ALL OF THE ABOVE MACROS(AND SUBROUTINES) CAN HAVE A SECOND
; ARGUMENT WHICH IS THE LOCATION OF A VALUE TO BE SUBSTITUTED FOR * IN
; THE FIRST ARGUMENT.  THE VALUE CAN BE LEFT JUSTIFIED SIXBIT OR A NUMBER.
; IF THE LOCATION OF THE VALUE IS AC N, NO EXTRA INSTRUCTION IS GENERATED
; SINCE THE MACRO USUALLY PICKS UP THE LOCATION AND PUTS IT IN N.
; HOWEVER IT IS RECOMENDED THAT N BE INCLUDED AS THE SECOND ARGUMENT
; TO INDICATE TO THE READER THAT A SUBSTITION IS GOING TO TAKE PLACE USING N.
; ELSE NEW CODE MAY BE INTRODUCED WHICH USES N BEFORE THE MACRO CALL.
; WHENEVER THE CHARACTER @ IS SEEN IT IS CONVERTED TO CRLF.  THIS
; MAKES IT NICER FOR FORMATTING THE MESSAGES INSIDE <>, SINCE
; THE > CAN ALWAYS BE ON THE SAME LINE, EVEN WHEN CRLF IS WANTED.

;EXAMPLE:
;	ASKYN	<LPT(Y,N)[LINE PRINTER AT STATION *]>,OSN
;	FILOUT	<MACRLP	*@>,N

;ALL SUBROUTINES WHICH IMPLEMENT THE MACROS HAVE THE SAME CALLING
; SEQUENCE:
;CALL:	MOVE	LV,QUESTION LEVEL -1 FOR SHORT, 0 FOR PROMPT, 1 FOR LONG
;	MOVE	N,+NUMBER OR LEFT JUSTFIED SIXBIT TO BE
;				; SUBSTITUTED FOR *
;	MOVEI	T1,ADR OF ASCIZ MESSAGE
;	PUSHJ	P,ASKXXX OR FILXXX OR TTYXXX OR BTHXXX
;	ALWAYS RETURN WITH ANSWER IN N( AND STRING IN ASCSTR) OR
;	ORIGINAL CONTENTS OF N IF JUST OUTPUT ROUTINE.

;A HELP FILE MAY BE USED.
;THE FILE MUST BE IN THE FORM
;<TERMINATOR> <SWITCH> <TAB> <TEXT> <TERMINATOR>
;THE TERMINATOR IS DETERMINED BY SYMBOL C.TMFH AND IS CURRENTLY
;<CONTROL> A. IT MUST BE ONE CHARACTER.
;THE TEXT WILL BE COPIED FROM AFTER THE TAB TO THE NEXT TERMINATOR,
;SO IT SHOULD BE CONSTRUCTED CAREFULLY. NOTE PARTICULARLY THAT SINCE TO
;POSITION THE FILE THE CODE FIRST FINDS A TERMINATOR AND THEN READS TO
;A TERMINATOR IT WILL BE MORE EFFICIENT IF EACH SWITCH IS PRECEEDED BY
;TWO TERMINATORS.



;MACRO FHLPOS IS PROVIDED TO HELP POSITION THE HELP FILE.
; FHLPOS STRING,TAG POSITIONS THE FILE TO THE TEXT AFTER "STRING",
;AND TRANSFERS TO "TAG" IF THE STRING CANT BE FOUND. IF THE STRING
;HAS BEEN COMPUTED, IT SHOULD BE SIXBIT CHARACTERS LEFT JUSTIFIED IN
;ACCUMULATOR WD, AND THE FIRST ARGUMENT SHOULD BE *, E.G.
; FHLPOS *,ERROR

;FHLPOA IS THE SAME EXCEPT IT DOES NOT LOOK FOR A TAB AFTER THE TEXT

;SUBROUTINES HAVE BEEN PROVIDED TO COPY THE TEXT FROM THE HELP
;FILE TO THE OUTPUT FILE OR TTY.

;FHLPTT - COPIES TEXT FROM THE CURRENT POSITION OF THE HELP FILE TO
;THE NEXT TERMINATOR TO TTY

;FHLPFL - COPIES TEXT FROM THE CURRENT POSITION TO THE NEXT TERMINATOR
;TO THE OUTPUT FILE

;FHLPFC - COPIES TEXT FROM THE CURRENT POSITION TO THE NEXT TERMINATOR
;TO THE OUTPUT FILE AS A COMMENT, I.E. WITH A ; AT THE BEGINNING OF EACH LINE
;SOME CONVENTIONS:
;ALL SINGLE LINE ANSWERS ARE ANSWERED ON THE SAME LINE AS QUESTIONS.
; THIS SAVES PAPER. THE FORMAT IS QUESTION(WITHOUT QUESTION MARK)
; FOLLOWED BY COLON AND ONE SPACE.

;ONLY THE ASK MACROS ADD ANY CHARACTERS TO THE TEXT IN THE FIRST
; ARGUMENT.  THE BEGINNING OF THE MESSAGE IS INSERTED AN ";	" AS
; A COMMENT FOR THE FIL, AND ": " IS APPENDED TO THE END
; OF THE QUESTION SO THAT ALL QUESTIONS LOOK ALIKE.  NONE OF THE
; OUTPUT ONLY MACROS ADD ANY SPECIAL CHARACTERS.

;BY CONVENTION PROMPTING IN () APPEARS BEFORE LONG DIALOG IN [].
; THUS A USER CAN TYPE ^O IF THE USER GETS BORED, AND GET THE MOST USEFUL
; OUTPUT FIRST.

;IF JUST A CR IS GIVEN TO A QUESTION WHICH HAS A LIST, THE FIRST
; ITEM IS ASSUMED.  THIS IS TRUE FOR DECIMAL AND OCTAL QUESTIONS TOO.

;ALL NUMERIC QUESTIONS MUST HAVE A RANGE SUPPLIED.
; IF ONE IS NOT, THE USER GETS:
; ? INTERNAL DIALOG ERROR - NO (...,MIN-MAX) IN ABOVE QUESTION -
; EDIT DIALOG AND INCLUDE IN QUESTION.

;ALL ERRORS WHICH ARE DIALOG'S RATHER THAN THE CUSTOMER'S, ARE PRECEDED
; WITH ? INTERNAL DIALOG ERROR - FOLLOWED BY THE PROBLEM AND WHAT
; THE PROGRAMMER SHOULD DO TO DIALOG.  NOTE THAT
; THE CUSTOMER SHOULD NEVER SEE THESE, SINCE THEY ARE DEBUGGING AIDS.

;ALL ERROR MESSAGES START WITH "? ". THE SPACE FOLLOWING ? MAKES THEM
; DISTINGUISHABLE FROM MONITOR ERROR WHICH HAVE NO SPACE.

;ALL STRINGS ARE ASCIZ INCLUDING AS INPUT FROM TTY.
; ALL EOL CHARS(CR,LF,FF,VT,ESC,ALT1,ALT2,^Z,^C) ARE STRIPPED OUT
; AND ARE REPLACED BY A NULL.  THIS MAKES IT EASY TO SCAN STRINGS
; SINCE END IS ALWAYS DECTECTED BY JUMPE CH,
; OUTPUT TO FILE MUST PUT CRLF BACK IN EXPLICITLY BY USING
; @ OR FCRLF ROUTINE.  THIS MAKES OUTPUT FILE MORE INDEPENDENT FROM
; USER INPUT.

;TO HELP THE READER OF DIALOG:
; ALL JUMPS ARE DOWN THE PAGE, EXCEPT LOOPS
; MOST PUSHJ ARE TO ROUTINES DOWN THE PAGE

;DEFINE THE MACROS:
; THE FOLLOWING MACROS SUFFIX ": " TO ASK QUESTION
; AND GET ANSWER ON SAME LINE

DEFINE	CAL	(XXX,A,B,%C)<
	XLIST		;;ALWAYS TURN OFF LISTING
IFNB <B>,<IFDIF <B> <N>,<MOVE	N,B>>	;;PICK UP VALUE TO BE SUBSTITUTED FOR *
	JSP	T1,%C		;;SETUP T1 WITH MESSAGE ADR AND JUMP AROUND
				;; MESSAGE WHICH MAY BE TOO BIG TO FIT
				;; IN REMOTE LITERAL.
	ASCIZ	\A: \		;;THE QUESTION WITH ": "
	INTERN	XXX		;;DECLARE INTERN SO MACRO WILL NOT THINK XXX A MACRO
%C:!	PUSHJ	P,XXX		;;CALL THE SUBROUTINE XXX
IFE RJRSTF,<LIST>		;;TURN LISTING BACK ON UNLESS INSIDE RJRST MACRO
>

DEFINE	ASKYN	(A,B)<
	CAL	ASKYN,<A>,B>

DEFINE	ASKDEC	(A,B)<
	CAL	ASKDEC,<A>,B>

DEFINE	ASKOCT	(A,B)<
	CAL	ASKOCT,<A>,B>

DEFINE	ASKLIN	(A,B)<
	CAL	ASKLIN,<A>,B>

DEFINE	ASKSTR	(A,B)<
	CAL	ASKSTR,<A>,B>

DEFINE	ASKLST	(A,B)<
	CAL	ASKLST,<A>,B>


;THE FOLLOWING MACROS DO NOT HAVE ANY CHARACTERS ADDED TO QUESTION

DEFINE	CAL2	(XXX,A,B,%C)<
	XLIST			;;ALWAYS TURN OFF LISTING
IFNB <B>,<IFDIF <B> <N>,<MOVE	N,B>>	;;PICKUP VALUE TO BE SUBSTITUTED FOR *
	JSP	T1,%C		;;SETUP T1 WITH MESSAGE ADR AND JUMP AROUND
				;; MESSAGE WHICH MAY BE TOO LONG FOR MACRO
				;; REMOTE LITERAL TABLE(14 WORDS)
	ASCIZ	\A\		;;THE QUESTION WITH NO ADDED CHARACTERS
	INTERN	XXX		;;DECLARE INTERN SO MACRO WILL NOT THINK XXX A MACRO
%C:!	PUSHJ	P,XXX		;;CALL THE SUBROUTINE TO JUST OUTPUT
IFE RJRSTF,<LIST>		;;TURN LISTING BACK ON UNLESS INSIDE RJRST MACRO
>

DEFINE	CAL3	(XXX,A,B,%C)<
	XLIST			;;ALWAYS TURN OFF LISTING
IFNB <B>,<IFDIF <B> <N>,<MOVEI	N,B>>	;;PICKUP VALUE TO BE SUBSTITUTED FOR *
	JSP	T1,%C		;;SETUP T1 WITH MESSAGE ADR AND JUMP AROUND
				;; MESSAGE WHICH MAY BE TOO LONG FOR MACRO
				;; REMOTE LITERAL TABLE(14 WORDS)
	ASCIZ	\A\		;;THE QUESTION WITH NO ADDED CHARACTERS
	INTERN	XXX		;;DECLARE INTERN SO MACRO WILL NOT THINK XXX A MACRO
%C:!	PUSHJ	P,XXX		;;CALL THE SUBROUTINE TO JUST OUTPUT
IFE RJRSTF,<LIST>		;;TURN LISTING BACK ON UNLESS INSIDE RJRST MACRO
>
DEFINE	ASKMN	(A,B)<
	CAL2	ASKMN,<A>,B>

DEFINE	ASKMNP	(A,B)<
	CAL2	ASKMNP,<A>,B>

DEFINE	BTHOUT	(A,B)<
	CAL2	BTHOUT,<A>,B>

DEFINE	BTHOCT	(A,B)<
	CAL2	BTHOCT,<A>,B>

DEFINE	FILOUT	(A,B)<
	CAL2	FILOUT,<A>,B>

DEFINE	FILCOM	(A,B)<
	CAL2	FILCOM,<A>,B>

DEFINE	FILOUD	(A,B)<
	CAL3	FILOUT,<A>,B>

DEFINE	TTYOUT	(A,B)<
	CAL2	TTYOUT,<A>,B
>

DEFINE	TTYOCT	(A,B)<
	CAL2	TTYOCT,<A>,B>

DEFINE	FILSTR	(A,B)<
	CAL2	FILSTR,<A>,B>

DEFINE	FILDEC	(A,B)<
	CAL2	FILDEC,<A>,B>

DEFINE	FILDC2	(A,B)<
	CAL2	FILDC2,<A>,B>

DEFINE	EREXIT	(A,B)<
	CAL2	EREXIT,<A>,B>
DEFINE	FHLPOS	(A,B)<
	XLIST
IFB <A>,<PRINTX FHLPOS MACRO MAY CLOBBER WD>
IFB <B>,<PRINTX FHLPOS MACRO MAY CLOBBER WD>
IFDIF <A>,<*>,<
	MOVE	WD,[SIXBIT \A\]
>
	INTERN	FHLPOS
	PUSHJ	P,FHLPOS
	  JRST	B
	LIST
>

DEFINE	FHLPOA	(A,B)<
	XLIST
IFB <A>,<PRINTX FHLPOA MACRO MAY CLOBBER WD>
IFB <B>,<PRINTX FHLPOA MACRO MAY CLOBBER WD>
IFDIF <A>,<*>,<
	MOVE	WD,[SIXBIT \A\]
>
	INTERN	FHLPOA
	PUSHJ	P,FHLPOA
	  JRST	B
	LIST
>
;DEFINE REMOTE MACROS WHICH ARE JUMPED TO ON UNUSUAL CASES
; INCLUDE CODE IN-LINE SO READABLE, BUT INDENT 2 TABS, JUST AS
; IF MULTI-LINE LITERAL.
;USED INSTEAD OF MULTI-LINE LITERAL BECAUSE MACRO LISTS
; SOURCE INSIDE OF MACROS INSIDE OF LITERALS

DEFINE	RJRST	(A,%B)<
	XLIST		;;TURN OFF LISTING SOURCE IN EXPANSION
RJRSTF==1		;;FLAG INSIDE OF RJRST, SO CAL MACRO
			;; WILL NOT TURN LIST BACK ON
	SKIPA		;;ALLOW MACRO IN ERROR RETURN OR AFTER TEST INSTR.
	JRST	%B	;;BY PASS UNUSUAL CODE
	A		;;THE UNUSAL CODE
RJRSTF==0		;;FLAG NO LONGER INSIDE RJRST MACRO
			;; SO FUTURE CAL MACROS WILL TURN LIST ON
%B:!	LIST		;;TURN LISTING BACK ON
>

DEFINE	RJUMPE	(AC,A,%B)<
	XLIST
RJRSTF==1		;;FLAG INSIDE OF RJRST, SO CAL MACRO
			;; WILL NOT TURN LIST BACK ON
	SKIPE	AC	;;CONDITION OF UNUSUAL CODE?
	JRST	%B	;;NO, BY PASS UNUSUAL CODE
	A		;;THE UNUSUAL CODE
RJRSTF==0		;;FLAG NO LONGER INSIDE RJRST MACRO
			;; SO FUTURE CAL MACROS WILL TURN LIST ON
%B:!	LIST		;;TURN LISTING BACK ON
>

DEFINE	RJUMPL	(AC,A,%B)<
	XLIST
RJRSTF==1		;;FLAG INSIDE OF RJRST, SO CAL MACRO
			;; WILL NOT TURN LIST BACK ON
	SKIPL	AC	;;CONDITION OF UNUSUAL CODE?
	JRST	%B	;;NO, BY PASS UNUSUAL CODE
	A		;;THE UNUSUAL CODE
RJRSTF==0		;;FLAG NO LONGER INSIDE RJRST MACRO
			;; SO FUTURE CAL MACROS WILL TURN LIST ON
%B:!	LIST
>

DEFINE	RJUMPN	(AC,A,%B)<
	XLIST
RJRSTF==1		;;FLAG INSIDE OF RJRST, SO CAL MACRO
			;; WILL NOT TURN LIST BACK ON
	SKIPN	AC	;;CONDITION OF UNUSUAL CODE?
	JRST	%B	;;NO, BY PASS UNUSUAL CODE
	A		;;THE UNUSUAL CODE
RJRSTF==0		;;FLAG NO LONGER INSIDE RJRST MACRO
			;; SO FUTURE CAL MACROS WILL TURN LIST ON
%B:!	LIST
>
DEFINE	RJUMPGE	(AC,A,%B)<
	XLIST
RJRSTF==1		;;FLAG INSIDE OF RJRST, SO CAL MACRO
			;; WILL NOT TURN LIST BACK ON
	SKIPGE	AC	;;CONDITION OF UNUSUAL CODE?
	JRST	%B	;;NO, BY PASS UNUSUAL CODE
	A		;;THE UNUSUAL CODE
RJRSTF==0		;;FLAG NO LONGER INSIDE RJRST MACRO
			;; SO FUTURE CAL MACROS WILL TURN LIST ON
%B:!	LIST
>

RJRSTF==0		;START FLAG AT 0 MEANING NOT INSIDE RJRST
;PARAMETERS:
;ACS
F=0		;FLAGS
  ;LH(DEFINED AS 36 BIT QUANTITIES):
  F.MTCH==1B0	;MATCH FOUND IN FNDASK ROUTINE
  F.OFO==1B1	;OUTPUT FILE OPEN.  FILE CALLS IGNORED IF 0
		; NEEDED SO ASK ROUTINES CAN BE USED TO ASK ABOUT FILE NAME
  F.TF==1B2	;TTY/FIL FLAG, 1 ON FIRST CHAR TO FILE
		; USED FOR DEBUG FEATURE TO PRINT <> ON TTY
		; SET BY TTYPUT ROUTINE, CLEARED BY FILPUT ROUTINE
  F.CTY==1B3	;CTY IS AN ACCEPTABLE OCTAL NUUMBER IF 1
		; SET BY ASKLIN, CLEARED BY ASKDEC,ASKOCT,ASKNUM ROUTINES
  F.FLF==1B4	;LAST CHAR ON FILE WAS LINE FEED
		; USED TO PRECEDE NEXT CHAR WITH ; TO MAKE A COMMENT IN FILE
		; IF F.COM IS ALSO ON.  SET, CLEARED AND LOOKED AT BY FILPUT ONLY
  F.COM==1B5	;MAKE ALL LINES TO FILE BE COMMENT IF THIS FLAG IS ON
		; USES F.FLF TO KNOW WHEN TO PUT ; OUT
		; SET AND CLEARED BY FILCOM AND TTYIN ROUTINES ONLY
		; LOKED AB BY FILPUT ROUTINE
  F.LPAR==1B6	;LEFT PAREN SEEN BY TTYOUT IN TTY OUTPUT STREAM.
		; USED TO SUPPRESS PROMPTING IF IN SHORT HELP MODE
		; CLEARED WHEN RIGHT PAREN SEEN.  SET, CLEARED,
		; AND USED BY TTYOUT ROUTINE ONLY.
  F.LBRK==1B7	;LEFT BRACKET SEEN BY TTYOUT IN TTY OUTPUT STREAM
		; YSED TO SUPPRESS EXPLANATION UNLESS IN LONG MODE
		; SET, CLEARED AND TESTED BY TTYOUT ROUTINE ONLY
  F.CONZ==1B8	;CONTROL Z TYPED IN ON TTY, SET BY TTYGET
  F.EXP==1B9	;IN LSTEXP, SET IF EXPLAIN, CLEARED IF LIST
  F.HOPN==1B10	;SET IF FGEN EXPLAIN FILE IS OPEN FOR READING
  F.HRRD==1B11	;SET IF READING EXPLAIN FILE A SECOND TIME
		; IF FILE WAS OPEN, MAY START SEARCHING PAST THE ENTRY DESIRED.
		; AT END OF FILE, REREAD FROM THE BEGINNING ONCE.
  F.2DEC==1B12	;SET IF WANT AT LEAST TWO CHARS IN DECIMAL OUTPUT
  F.FHLC==1B13	;SET IF LOOKING FOR TAB AFTER TEXT IN FGEN HELP FILE

N=1		;NUMERIC VALUE OF ASKED QUESTION.
		; ALSO USED TO SUBSTITUTE FOR * IN ALL STRINGS.
		; CAN BE LEFT JUSTIFIED SIXBIT.
		; YES ANSWERS ARE 1, NO ANSWERS ARE 0.
T1=2		;TEMPORARY AC. USUALLY ADR OF ASCIZ MESSAGE ON SUB CALL.
T2=T1+1		;FOR REMAINDER IN DIVISION
WD=4		;WORD AC ON CALLS TO GETWRD(LEFT JUSTIFIED SIXBIT)
B=5		;BYTE POINTER TO TEXT STRING
R=6		;INPUT AND OUTPUT RADIX
LV=7		;MODE OF ASKING QUESTIONS(-1=SHORT,0=PROMPT,1=LONG)
I=10		;INDEX FOR LOOP COUNTS
CH=11		;CHARACTER AC
P=17		;PD POINTER

;SAVGET LOCATIONS

.SGDEV==11	;AC FROM RUN OR GET WHICH CONTAINS DEVICE FROM WHICH DIALOG PROGRAM WAS RUN
.SGPPN==17	;AC WHICH CONTAINS DIRECTORY
;SPECIAL ASCII CHARACTERS(NEVER CODE IN OCTAL SO CAN USE CREF):
C.RUB==177	;RUBOUT
C.ALT1==175	;OLD ALT MODES
C.ALT2==176	;OLD ALT MODE ON SOME TTYS
C.ESC==33	;MAP ALTS INTO ESCAPE
C.CONZ==32	;CONTROL Z
C.FF==14	;FORM FEED
C.CR==15	;CARIAGE RETURN
C.LF==12	;LINE FEED
C.CONC==3	;CONTROL C
C.TMFH==1	;CONTROL A IS TERMINATOR IN FGEN AUXILIARY HELP FILE
;IO CHANNELS:
TTYCHN==0	;TTY INPUT AND OUTPUT CHANNEL
FILCHN==1	;FILE OUTPUT CHANNEL
FHLPCH==2	;FGEN AUXILIARY HELP FILE CHANNEL

;IO STATUS BITS:
IO.EOF==20000	;END OF FILE

;NUMBER OF I/O BUFFERS
NFILBF==2	;NUMBER OF BUFFERS FOR FILE OUTPUT
NFHLPB==2	;NUMBER OF BUFFERS FOR FGEN AUXILIARY HELP FILE

;OPDEFS:
OPDEF	PJRST	[JRST]	;EQUIVALENT TO PUSHJ POPJ PAIR
OPDEF	PJUMPE	[JUMPE]	;EQUIVALENT TO JUMPE [PJRST]

;INTERNS TO HELP MACRO BECAUSE SOME MACRO NAMES ARE ALSO TAGS
INTERN	FILCOM
SUBTTL	ASK ROUTINES - ASK QUESTION ON TTY, FILE AND GET ANSWER

;LSTEXP - ROUTINE TO DO LIST OR EXPLAIN MODE FOR FGEN
;CALL:	MOVEI	N,1 OR 2 FOR LIST OR EXPLAIN
;	PUSHJ	P,LSTEXP
;	RETURNS WHEN DONE

LSTEXP:	CAIE	N,1		;SKIP IF LIST, NOT IF EXPLAIN
	TLOA	F,(F.EXP)	;SET EXPLAIN FLAG FOR EXPLAIN
	TLZ	F,(F.EXP)	;CLEAR EXPLAIN FLAG FOR LIST
ASKLEX:	TTYOUT	<switch(switch to list or explain)[
Type name of switch to be listed or explained or ALL or /HELP.
Type extra carriage return when through.]@@>
LEXLOP:	PUSHJ	P,TTYIN		;GET SWITCH TYPED
	  JRST	ASKLEX		;/HELP TYPED
	JUMPE	CH,LEXXIT	;EXIT IF BLANK LINE
	PUSHJ	P,GETWRD	;GET SWITCH NAME
	RJUMPN	CH,<MOVE N,WD	;;N=SWITCH NAME TYPED
		    TTYOUT <? unknown switch *@>
		    JRST ASKLEX>
	CAMN	WD,[SIXBIT .ALL.]	;SKIP IF NOT "ALL"
	JRST	ALLLEX		;DO ALL SWITCHES IN TABLE AND EXIT
	PUSHJ	P,LEXSWT	;LIST OR EXPLAIN THIS SWITCH
	  JRST	ASKLEX		;ILLEGAL SWITCH, RETYPE PROMPT
	JRST	LEXLOP		;OK, WAIT FOR ANOTHER

LEXXIT:	MOVE	LV,SAVLV	;RESTORE PERMANENT HELP LEVEL
	POPJ	PND RETURN

;HERE IF WANT ALL SWITCHES
ALLLEX:	HRLZ	T1,FTLEN	;AOBJN PTR TO TABLE
ALLLE1:	PUSH	P,T1		;SAVE AOBJN PTR
	SKIPN	WD,@FTTAB	;SKIP IF HAVE A SWITCH HERE
	JRST	ALLLE2		;NO, IGNORE IT
	TLZ	WD,777700	;CLEAR JUNK
	TLO	WD,'FT '	;MAKE SWITCH BE FT...
	PUSHJ	P,LEXSWT	;LIST OR EXPLAIN THIS SWITCH
	  JFCL			;IGNORE ERRORS THAT SHOULDN'T HAPPEN
ALLLE2:	POP	P,T1		;RESTORE AOBJN PTR
	AOBJN	T1,ALLLE1	;LOOP FOR WHOLE TABLE
	POPJ	P,		;RETURN
;LEXSWT - ROUTINE TO LIST OR EXPLAIN ONE SWITCH
;CALL:	MOVE	WD,SWITCH NAME
;	PUSHJ	P,LEXSWT
;	RETURN HERE IF UNKNOWN SWITCH
;	RETURN HERE IF FOUND, LIST OR EXPLAIN DONE

LEXSWT:	HLRZ	N,WD		;N=FIRST THREE CHARS
	TRZ	N,77		;ONLY LOOK AT FIRST TWO
	CAIE	N,'FT '		;SKIP IF FT...
	RJRST	<MOVE N,WD
		 TTYOUT <? unknown switch *@>
		 POPJ P,>
	TLZ	WD,777700	;CLEAR UNWANTED JUNK
	RJUMPE	WD,<TTYOUT <? unknown switch@>
		    POPJ P,>
	PUSHJ	P,FNDSWT	;FIND SWITCH IN TABLE
	MOVE	N,WD		;N=SWITCH NAME, WT1=INDEX IN TABLE
	TLO	N,'FT '		;ADD BACK "FT"
	RJUMPGE	T1,<TTYOUT <? unknown switch *@>
		    POPJ P,>
	PUSH	P,N		;SAVE NAME OF SWITCH IN CASE EXPLAINING
	SKIPL	@FTTAB		;SKIP IF VALUE IS ON
	JRST	LEXSW1		;NO, SWITCH IS OFF
	TTYOUT	<*,-1>
	JRST	LEXSW2
LEXSW1:	TTYOUT	<*,0>
LEXSW2:	POP	P,WD		;RESTORE NAME OF SWITCH TO LOOKUP EXPLANATION
	AOS	(P)		;OK, GIVE SKIP RETURN AND FINISH UP
	TLNE	F,(F.EXP)	;SKIP IF LIST, NOT IF EXPLAIN
	PJRST	LEXSW3		;DO EXPLAIN
	TTYOUT	<@>
	POPJ	P,

;HERE TO EXPLAIN SWITCH
;HERE TO POSITION FGEN HELP FILE AT EXPLANATION FOR THIS SWITCH, WD IS SET UP
LEXSW3:	FHLPOS	*,LEXSWE
	PUSHJ	P,FHLPTT	;COPY TO TTY
LEXSWE:	TTYOUT	<@>
	POPJ	P,		;RETURN
;FNDSWT - ROUTINE TO FIND A SWITCH IN THE TABLE
;CALL:	MOVE	WD, SWITCH NAME WITH "FT" CLEARED
;	PUSHJ	P,FNDSWT
;	RETURN	N=INDEX OF SWITCH IN TABLE, OR GE 0 IF NOT IN TABLE

FNDSWT:	HRLZ	T1,FTLEN	;AOBJN PTR TO SWITCH TABLE

FNDSW1:	HRLOI	N,77		;N=MASK FOR 4 CHARS
	AND	N,@FTTAB	;N=NEXT SWITCH NAME IN TABLE
	CAME	N,WD		;SKIP IF FOUND MATCH
	AOBJN	T1,FNDSW1	;NO, TRY NEXT IN TABLE
	POPJ	P,
;ASKYN - ROUTINE TO ASK AND ACCEPT A Y OR N ANSWER
; USED WHEN ONLY CHOICE OF PRESENCE OR ABSENCE IS POSSIBLE
;CALL:	ASKYN	<...(Y,N)[...]>
;	RETURN	N=1 IF Y, N=0 IF N
; NOTE: (Y,N) MUST BE IN THIS ORDER, SO USER KNOWS DEFAULT ALWAYS IS Y

ASKYN:	PUSHJ	P,ASKLS1	;ASK QUESTION, GET ANSWER POSITION IN N
	MOVS	T1,ASKTAB+0	;IS FIRST PROMPT
	CAIE	T1,'Y  '	;Y FOR YES?
	JRST	ASKYNE		;NO, ERROR
	MOVS	T1,ASKTAB+1	;YES, IS SECOND PROMPT
	SKIPN	ASKTAB+2	;ARE THERE MORE THAN TWO CHOICES?
	CAIE	T1,'N  '	;NO, IS IT N?
ASKYNE:	RJRST	<EREXIT	<ASKYN called without (Y,N) in above message>,>
	JUMPE	N,ASKY		;FIRST ITEM IN LIST(Y)?

;HERE ON N ANSWER
	TDZA	N,N		;RETURN 0

;HERE ON Y ANSWER
ASKY:	MOVEI	N,1		;RETURN 1
	POPJ	P,
;ROUTINE TO ASK QUESTON WITH PROMPTING ANSWERS IN A LIST IN PARENS
;CALL:	ASKLST	<...(ANS0,ASN1,ANS2,...)[...]>
;	RETURN HERE WITH N=0,1,2,...
;	IF JUST CR TYPED, N=0 TO MEAN FIRST ITEM BY DEFAULT
;ABBREVIATIONS ARE ALLOWED LIKE MONITOR COMMANDS
; IF WRONG ANSWER IS GIVEN, THE FOLLOWING ERROR MESSAGE IS TYPED:
; ? ANSWER MUST BE ONE OF (ANS0,ANS1,ANS2,...)
; FOLLOWED BY A REPEAT OF QUESTION IN NEXT LONGEST MODE
;IF A LIST OF PROMPTINGS IS NOT INCLUDED IN PARENS,
; ? INTERNAL DIALOG ERROR  - NO CHOICES IN PARENS - EDIT DIALOG


ASKLST:	PUSHJ	P,ASKLS1	;ASK AND GET ANSWER
	MOVS	T1,ASKTAB+0	;IS FIRST PROMPT
	CAIE	T1,'Y  '	;Y
	CAIN	T1,'N  '	; OR N?
	JRST	ASKLSE		;YES, ERROR SHOULD USE ASKYL INSTEAD
	MOVS	T1,ASKTAB+1	;IS SECOND PROMPT
	CAIE	T1,'Y  '	;Y
	CAIN	T1,'N  '	;OR N?
ASKLSE:	RJRST	<EREXIT	<ASKLST called with (Y,N) in above question
- Edit DIALOG to call ASKYN instead of ASKLST@>,>
	POPJ	P,		;RETURN WITH N SET TO POSITION OF ANSWER

;SUBROUTINE TO DO THE WORK OF ASKING AND GETTING ANSWER.
;CALLED BY ASKLST AND ASKYN

ASKLS1:	PUSHJ	P,ASKBG		;STANDARD ASK ROUTINE BEGINNING
				; SAVE ADR OF QUESTION AND N ON STACK, OUTPUT CRLF
				; TO FILE, OUTPUT QUESTION AS COMMENT TO FILE

;LOOP TO ASK QUESTION OVER AGAIN AFTER ERROR OR /HELP
ASKOVR:	MOVE	N,(P)		;REESTORE ORIGINAL N INCASE THIS IS LOOP
				; SO * SUBSTITUTION WILL BE THE SAME
	HRRZ	T1,-1(P)	;ADR OF MESSAGE
	PUSHJ	P,TTROUT	;OUTPUT TO TTY
	HRRZ	T1,-1(P)	;ADR OF ASK MESSAGE
	PUSHJ	P,SETASK	;SET UP LIST OF CHOICES IN ASKTAB
				; FROM SCANNING LIST OF PROMPTINGS
	PUSHJ	P,TTYIN		;ASK FOR INPUT LINE, OUTPUT TO FILE AS COMMENT
	  JRST	ASKOVR		;/HELP TYPED, REASK IN DESIRED HELP MODE
	PUSHJ	P,FNDASK	;NO, LOOK FOR HIS ANSWER IN ASKTAB
	  AOJA	LV,ASKOVR	;NOT THERE, ASK QUESTION AGAIN WITH MORE HELP
				; BY MAKIN LEVEL ONE HIGHER
	JRST	ASKXIT		;FOUND, RESTORE LEVEL
				; TO THAT BEFORE QUESTION AND RETURN
;ROUTINE TO SCAN MESSAGE FOR PROMPTING ANSWERS
;CALL:	MOVEI	T1,ADR OF ASCIZ STRING
;	PUSHJ	P,SETLST
;	  RETURN ONLY IF ANSWERS IN PARENS FOUND
;	ELSE PRINT ? INTERNAL DIALOG ERROR - NO ( IN ABOVE MESSAGE,
; ADD (ANS0,ASN1,ASN2...) TO DIALOG BY EDITING
; B IS PRESERVED

SETASK:	HRLI	T1,440700	;FORM LH OF BYTE POINTER
	PUSH	P,B		;SAVE BYTE POINTER(NOT AN ARGUMENT)
				; CALLER MAY HAVE SOMETHING IN IT
	PUSH	P,N		;SAVE POSSIBLE SUBSTITUTION

;LOOP TO FIND LEFT PAREN
ASK0:	ILDB	CH,T1		;GET NEXT CHAR IN ASK MESSAGE
	RJUMPE	CH,<EREXIT <? No (ANS0,ASN1,...) in above question - Edit DIALOG>,>
	CAIE	CH,"("		;LEFT PAREN?
	JRST	ASK0		;NO, KEEP LOOKING
	MOVEI	N,0		;SET ANSWER INDEX TO 0
	MOVE	B,T1		;SETYUP BYTE POINTER TO PROMPTING LIST FOR GETWRD

;LOOP TO BREAK PROMPTING ANSWERS - N=0,1,... FOR EACH ANSWER
ASK2:	PUSHJ	P,GETWRD	;GET NEXT WORD INSIDE PARENS
	CAIE	CH,"*"		;SKIP IF WANT SUBSTITUTION
	JRST	ASK2A		;NO, KEEP CHECKING
	JUMPN	WD,ASK2E	;JUMP IF SOMETHING PRECEEDED *, ERROR
	MOVE	WD,(P)		;RESTORE SUBSTITUTION
ASK2A:	MOVEM	WD,ASKTAB(N)	;ANS STORE ANSWER AWAY
	CAILE	N,DP.AMX	;MORE THAN MAX. NO. OF ANSWERS FOR DIALOG?
	RJRST	<EREXIT <too many prompts in above question - Edit DIALOG@>,>
	CAIN	CH,","		;WAS BREAK CHAR A COMMA?
	AOJA	N,ASK2		;YES, GO BACK AND GET NEXT PROMPTING WORD
	SETZM	ASKTAB+1(N)	;CLEAR LAST ARG PLUS 1 AS END FLAG
	POP	P,N		;RESTORE N
	POP	P,B		;RESTORE CALLERS BYTE POINTER
	CAIN	CH,")"		;NO, WAS BREAK RIGHT PAREN?
	POPJ	P,		;YES, RETURN
ASK3E:	EREXIT	<special character inside () above
Edit DIALOG and remove it.>,

ASK2E:	EREXIT	<error in above question - Edit DIALOG@>,>
;ROUTINE TO FIND ONE OF A LIST OF ANSWERS IN ASKTAB USING ASCIZ STRING
;CALL:	MOVE	POSSIBLE ANSWERS TO ASKTAB+0,+1,... STORE 0 IN LAST+1
;				(SEE SETASK ROUTINE)
;	MOVE	B,BYTE POINTER TO ASCIZ STRING
;	PUSHJ	P,FNDASK
;	  NOT FOUND RETURN, ERROR MESSAGE PRINTED
;	OK RETURN, N = POSITION OF ANSWER IN LIST = 0,1,2
;	N=0 IF JUST A CR TYPED
; ALLOW 0 IN ASKTAB+0 AS LEGAL ANSWER TO MEAN NO DEFAULT

FNDASK:	PUSHJ	P,GETWRD	;GET USER SUPPLIED ANSWER
	TLZ	F,(F.MTCH)	;CLEAR MATCH FOUND FLAG
	SETZB	N,SAVN		;SET ANSWER INDEX TO 0
	JUMPE	WD,ASK8		;JUST A CR TYPED?
	MOVEI	T1,0		;NO, FORM MASK FOR ABBREVIATION
ASK5:	ROT	T1,6		;MOVE MASK LEFT 1 CHAR POSITION
	IORI	T1,77		;SET LOW ORDER CHAR MASK
	TDNN	WD,T1		;ANY CHARS IN THESE LOW ORDER POSITIONS?
	JRST	ASK5		;NO, LOOK AT NEXT CHAR TO LEFT
	LSH	T1,-6		;YES, MOVE MASK SO ONLY COVERS CHARS NOT TYPED
	MOVE	T2,ASKTAB(N)	;GET FIRST POSSIBLE ANSWER. MAYBE 0 IF
				; NO DEFAULT ALLOWED, IE (,ANS0,ANS1,...)

;LOOP TO SCAN FOR MATCH WITH PROMPTING ANSWERS STORED IN ASKTAB
ASK6:	CAMN	T2,WD		;SKIP IF NOT EXACT MATCH
	JRST	ASK9		;YES, TAKE THIS IMMEDIATELY
	TDZ	T2,T1		;CLEAR OUT CHARS USER DID NOT TYPE
	CAME	T2,WD		;MATCH THE CHARS HE DID TYPE?
	JRST	ASK7		;NO, GO GET NEXT ANSWER
	MOVEM	N,SAVN		;YES, SAVE ANSWER INDEX
	TLOE	F,(F.MTCH)	;ALREADY FOUND A MATCH?
	RJRST	<TTYOUT	<? Type enough to uniquely distinguish answer@>
		 POPJ	P,>	;ERROR RETURN
ASK7:	SKIPE	T2,ASKTAB+1(N)	;GET NEXT PROMPT, IS THERE ONE?
	AOJA	N,ASK6		;YES, BUMP ANSWER INDEX
	TLNN	F,(F.MTCH)	;NO, WAS A MATCH FOUND?
	RJRST	<TTYOUT	<? Answer with one of the choices inside parens@>
		 POPJ	P,>	;ERROR RETURN
ASK8:	MOVE	N,SAVN		;YES, RETURN THE MATCH INDEX
ASK9:	SKIPN	ASKTAB(N)	;SKIP IF DEFAULT ALLOWED
	RJRST	<TTYOUT <? No default allowed@>
		POPJ P,>
	JRST	CPOPJ1		;GIVE OK RETURN
;ROUTINE TO ASK QUESTION AND GET DECIMAL ANSWER AND CHECK FOR LIMITS
;CALL:	ASKDEC	<QUESTION(DEFAULT,MIN-MAX)[...]>
;	RETURN HERE WITH N AS VALUE OF ANSWER, CR ASSUMES DEFAULT

ASKDEC:	MOVEI	R,12		;SET RADIX TO DECIMAL
	JRST	ASKNUM		;GO ASK QUESTION AND CHECK ANSWER

;ROUTINE TO ASK QUESTION AND GET OCTAL LINE NUMBER OR CTY
;CALL:	ASKLIN	<QUESTION(DEFAULT,MIN-MAX)[...]>
;	RETURN HERE WITH N AS VALUE OR 'CTY', CR ASSUMES DEFAULT

ASKLIN:	MOVEI	R,10		;SET RADIX TO OCTAL
	TLO	F,(F.CTY)	;FLAG THAT CTY IS OK OCTAL NUMBER
	JRST	ASKNM1		;ASK QUESTION, ETC

;ROUTINE TO ASK QUESTION AND GET OCTAL ANSWER AND CHECK FOR LIMITS
;CALL:	SAME AS ASKDEC, EXCEPT ANSWER CONVERTED AS OCTAL

ASKOCT:	MOVEI	R,10		;SET RADIX TO OCTAL
ASKNUM:	TLZ	F,(F.CTY)	;FLAG THAT CTY IS NOT ACCEPTABLE NUMBER
ASKNM1:	PUSHJ	P,ASKBG		;STANDARD ASK ROUTINE BEGINNING
				; SAVE ADR OF QUESTION AND N ON STACK, OUTPUT CRLF
				; TO FILE, OUTPUT QUESTION AS COMMENT TO FILE

;LOOP TO ASK QUESTON AGAIN IF SYNTAX ERROR OR OUT OF RANGE OR /HELP
ASKAGN:	MOVE	N,(P)		;REESTORE ORIGINAL N IN CASE THIS IS LOOP
				; SO * SUBSTITUTION WILL BE THE SAME
	HRRZ	T1,-1(P)	;ADR OF MESSAGE
	PUSHJ	P,TTROUT	;ASK USER ON TTY
	SETOM	DFAULT		;SET DEFAULT TO NONE FOUND YET
				; USER CANNOT TYPE IN -1
	SETZM	MINLIM		;SET MIN LIMIT TO 0
	MOVSI	T1,'?  '	;SET MAX LIMIT TO BIG POS. NO.
				; WHICH WILL ALSO PRINT IF BELOW MIN
	MOVEM	T1,MAXLIM	;TO VERY BIG NUMBER
	HRRZ	B,-1(P)		;ADR OF QUESTION
	HRLI	B,440700	;FORM BYTE POINTER TO IT

;LOOP TO FIND FIRST PAREN
ASKN0:	ILDB	CH,B		;GET NEXT CHAR
	JUMPE	CH,ASKN2	;ERROR IF END OF STRING FOUND
	CAIE	CH,"("		;LEFT PAREN?
	JRST	ASKN0		;NO, KEEP LOOKING
;LOOP TO LOOK FOR DEFAULT, MIN AND MAX INSIDE PARENS
ASKN1:	PUSHJ	P,GETNUM	;GET NUMERIC FIELD
ASKN1B:	CAIE	CH,"*"		;SKIP IF * FOUND
	JRST	ASKN1C		;NO, PROCEED
	JUMPN	N,ASKN2		;JUMP IF SOMETHING BEFORE THE *
	MOVE	N,(P)		;PICK UP VALUE FOR SUBSTITUTION
	PUSHJ	P,SKBLNK	;SKIP TO NEXT TERMINATOR
	JRST	ASKN1B		;AND LOOP
ASKN1C:	CAIN	CH,"-"		;DASH TO SEPARATE MIN-MAX
	JRST	ASKN3		;YES, FOUND MIN
	CAIE	CH,"C"		;YES, AND IS BREAK A C?
	JRST	ASKN1A		;NO, GO CHECK OTHER BREAK CHARS
	JUMPN	N,ASKN2		;JUMP IF SOMETHING BEFORE THE *
	PUSHJ	P,GETWRD	;YES, GET REST OF WORD
	MOVEI	N,'CR '		;GET READY IF CR TO STORE CR AS DEFAULT
	CAME	WD,[SIXBIT /R/]	;IS IT R AFTER C?
				;YES,  STORE DEFAULT CR
				; USED TO GET OUT OF LOOP IN REMGEN
	TLNN	F,(F.CTY)	;NOT CR, IS CTY A LEGAL ANSWER?
	JRST	ASKN1A		;NO, GO CHECK OTHER BREAKS
	CAME	WD,[SIXBIT /TY/] ;IS REST OF WORD "TY"?
	JRST	ASKN2		;NO, PRINT ERROR
	MOVEI	N,'CTY'		;STORE ARG AS TYPED
ASKN1A:	SKIPGE	DFAULT		;ALREADY STORED DEFAULT?
	MOVEM	N,DFAULT	;NO, STORE DEFAULT, IN CASE JUST TYPES CR
	CAIN	CH,")"		;IS THIS THE ONLY NUMBER
	JRST	ASKN4		;YES, GO GET USER ANSWER
	CAIN	CH,","		;IS BREAK A COMMA?
	JRST	ASKN1		;YES, GO GET NEXT NUMBER IN LIST
ASKN2:	EREXIT	<above question must have(...,min-max) - Edit DIALOG>,

;HERE WHEN MIN FOUND
ASKN3:	MOVEM	N,MINLIM	;STORE MINIMUM LIMIT
	PUSHJ	P,GETNUM	;GET NEXT NUMBER
	CAIN	CH,"?"		;NO MAX SPECIFIED?
	JRST	ASKN3A		;YES, SET TO INFINITY
	CAIE	CH,"*"		;NO, IS MAX. SUBSTITUTABLE ARG?
	JRST	ASKN3B		;NO, GO CHECK FOR RIGHT PAREN
	SKIPA	N,(P)		;YES, USE VALUE WHICH WAS SUBSTITUTED
ASKN3A:	MOVSI	N,'?  '		;SET MAX TO PLUS INFINITY
	PUSHJ	P,SKBLNK	;SKIP TO NEXT NON-BLANK
ASKN3B:	CAIE	CH,")"		;BETTER BE RIGHT PAREN
	JRST	ASKN2		;NO, ERROR
	MOVEM	N,MAXLIM	;STORE MAX LIMIT

;HERE WHEN FIRST () ALL SCANNED FOR DEFAULT, MIN AND MAX
ASKN4:	PUSHJ	P,TTYIN		;GET USER ANSWER FROM TTY, OUTPUT TO FILE
				; AS COMMENT
	  JRST	ASKAGN		;/HELP TYPED, ASK AGAIN
	JUMPE	CH,ASKN5	;JRST CR TYPED?(GO USE DEFAULT IF YES)
	PUSHJ	P,GETNUM	;NO, GET NUMBER USER TYPED
	JUMPE	CH,ASKN5A	;END OF STRING?
	TLNN	F,(F.CTY)	;NO, IS CTY A POSSIBLE OCTAL NUMBER?
	RJRST	<TTYOUT	<? Type single number followed by carriage return@>
		 AOJA	LV,ASKAGN>	;ASK AGAIN AT HIGHER LEVEL
	CAIE	CH,"C"		;YES, WAS BREAK C?
	JRST	ASKN4B		;NO, PRINT ERROR
	JUMPN	N,ASKN4B	;JUMP IF SOMETHING PRECEDED C
	PUSHJ	P,GETWRD	;YES, GET REST OF WORD
	JUMPE	CH,ASKN4B	;IS THIS END OF LINE?(IE JUST C TYPED)
	CAME	WD,[SIXBIT /TY/] ;YES, IS WORD REST OF CTY?
	CAMN	WD,[SIXBIT /T/] ;OR ABBREVIATION?
	JRST	ASKN4B		;YES, ALLOW IT
	RJRST	<TTYOCT	<? Type octal line number or CTY followed by carriage return@>
		 AOJA	LV,ASKAGN> ;ASK AGAIN AT HIGHER LEVEL
ASKN4B:	MOVSI	N,'CTY'		;YES, RETURN LEFT JUSTFIED CTY AS OCTAL NO.
	JRST	ASKN6		;SKIP RANGE CHECK

;HERE IF JUST CR TYPED AS ANSWER, USE DEFAULT IF THERE IS ONE
ASKN5:	MOVS	N,DFAULT	;GET DEFAULT IF ONE SPECIFIED
	CAME	N,[SIXBIT /CR/]	;WAS DEFAULT CR?
	CAMN	N,[SIXBIT /CTY/] ;WAS DEFAULT CTY?
	JRST	ASKN6		;YES, BY PASS RANGE CHECK
	MOVSS	N		;RESTORE TO UNSWAPPED STATE
	RJUMPL	N,<TTYOUT	<? No default allowed, type a number@>
		 AOJA	LV,ASKAGN> ;ASK AGAIN AT HIGHER LEVEL
;HERE TO CHECK RANGE OF ANSWER
ASKN5A:	CAMN	N,DFAULT	;SKIP IF NOT DEFAULT VALUE
	JRST	ASKN6		;IF DEFAULT NOT IN RANGE, MUST BE SPECIAL TERMINATOR
	CAML	N,MINLIM	;LESS THAN MIN?
	CAMLE	N,MAXLIM	;NO, EXCEED MAX?
	RJRST	<TTYOUT	<? Must be in range *>,MINLIM
	 	TTYOUT	<-*@>,MAXLIM
	 	AOJA	LV,ASKAGN>	;ASK AGAIN AT NEXT LONGER MODE
ASKN6:	JRST	ASKXIT		;STANDARD ASK EXIT - RESTORE ORIGINAL
				; HELP LEVEL, POP QUESTION ADR, AND RETURN

;ROUTINE TO ASK QUESTION AND GET STRING FOR ANSWER
;CALL:	ASKSTR	<QUESTION*>,X

ASKSTR:	PUSHJ	P,ASKBG		;STANDARD ASK ROUTINE BEGINNING
				; SAVE ADR OF QUESTION AND N ON STACK, OUTPUT CRLF
				; TO FILE, OUTPUT QUESTION AS COMMENT TO FILE

;LOOP TO ASK QUESTION OVER AGAIN AFTER REQUEST FOR HELP
ASKST1:	MOVE	N,(P)		;REESTORE ORIGINAL N INCASE THIS IS LOOP
				; SO * SUBSTITUTION WILL BE THE SAME
	HRRZ	T1,-1(P)	;ADR OF MESSAGE
	PUSHJ	P,TTROUT	;TYPE IT ON TTY
	PUSHJ	P,TTYIN		;WAIT FOR INPUT, OUTPUT TO FILE
				; AS COMMENT
	  JRST	ASKST1		;/HELP TYPED, REASK AT DESIRED HELP MODE
	JRST	ASKXIT		;COMMON EXIT FROM ASK ROUTINES
				; POP OLD N AND QUESTION ADR, RESTORE HELP LEVEL
;ROUTINE TO ASK FOR M-N<EOL> OR M<EOL> ON REPEATED LINES UNTIL BLANK LINE
; SYNTAX AND OUTPUT TO FILE
;CALL:	FILOUT	<DEFINE	MAC???>	;START MACRO DEFINITION IN FILE
;	ASKMN	<ASK MESSAGE@>
;	RETURN WHEN ALL ANSWERS HAVE BEEN CHECKED AND OUTPUT

ASKMN:	MOVEI	R,^D8		;ASSUME OCTAL RADIX FOR IO
	PUSHJ	P,FILLAB	;OUTPUT LEFT ANGLE BRACKET, CRLF TO FILE
				; AS BEG OF MACRO DEFINITION
	PUSHJ	P,ASKBG		;STANDARD ASK ROUTINE BEGINNING
				; SAVE ADR OF QUESTION AND N ON STACK, OUTPUT CRLF
				; TO FILE, OUTPUT QUESTION AS COMMENT TO FILE

;LOOP TO ASK QUESTION IN CASE OF ERROR OR /HELP
ASKM0:	MOVE	N,(P)		;RESTORE ORIGINAL N IN CASE THIS IS LOOP
				; SO * SUBSTITUTION WILL BE THE SAME
	HRRZ	T1,-1(P)	;ADR OF MESSAGE
	PUSHJ	P,TTROUT	;OUTPUT TO TTY

;LOOP TO GET NEXT LINE OF INPUT
ASKMLP:	PUSHJ	P,TTYIN		;GET TTY LINE
	  JRST	ASKM0		;/HELP TYPED, ASK AGAIN
	JUMPE	CH,ASKPXT	;NO, DID HE TYPE A BLANK LINE MEANING ALL DONE?
	PUSHJ	P,GETMN		;NO, SCAN FOR M OR M-N AND STOP ON NON-BREAK
	RJUMPN	CH,<TTYOCT <? Type octal M-N or M@>
		AOJA	LV,ASKM0>	;RAISE LEVEL OF VERBOSCITY AND ASK AGAIN
	FILSTR	<L *@>;		;OUTPUT SAME STRING HE TYPED IN WITH MACRO
				; NAME PRECEDING IT SO COMMON CAN
				; REDEFINE AS IT PLEASES.
	JRST	ASKMLP		;AND GO GET NEXT LINE OF INPUT


;ROUTINE TO ASK FOR M-N,P<EOL>, GET REPEATED LINES OF INPUT
; UNTIL BLANK LINE, ANS OUTPUT TO FILE
;CALL:	FILOUT	<DEFINE	MAC???>	;START MACRO DEFINITON IN FILE
;	ASKMNP	<ASK MESSAGE@>
;	RETURN WHEN ALL ANSWERS HAVE BEEN CHECKED AND OUTPUT

ASKMNP:	MOVEI	R,^D8		;ASSUME OCTAL RADIX FOR IO
	PUSHJ	P,FILLAB	;OUTPUT LEFT ANGLE BRACKET, CRLF TO FILE
				; AS BEG OF MACRO DEFINITION
	PUSHJ	P,ASKBG		;STANDARD ASK ROUTINE BEGINNING
				; SAVE ADR OF QUESTION AND N ON STACK, OUTPUT CRLF
				; TO FILE, OUTPUT QUESTION AS COMMENT TO FILE

;LOOP TO ASK FOR MULTI LINE INPUT AGAIN IN CASE OF ERROR
ASKP0:	MOVE	N,(P)		;RESTORE ORIGINAL N IN CASE THIS IS LOOP
				; SO * SUBSTITUTION WILL BE THE SAME
	HRRZ	T1,-1(P)	;ADR OF MESSAGE
	PUSHJ	P,TTROUT	;OUTPUT TO  TTY

;LOOP TO GET NEXT LINE OF INPUT
ASKPLP:	PUSHJ	P,TTYIN		;GET NEXT LINE FROM TTY
	  JRST	ASKP0		;/HELP TYPED, ASK AGAIN
	JUMPE	CH,ASKPXT	;NO, BLANK LINE MEANING END
	PUSHJ	P,GETMN		;NO, GET M OR M-N
	CAIE	CH,","		;IS BREAK A COMMA?
	JRST	ASKPE		;NO, ERROR, PRINT MESAGE AND ASK AGAIN
	PUSHJ	P,GETOCT	;GET OCTAL P
	JUMPE	CH,ASKP1	;IS THIS END OF STRING?
ASKPE:	TTYOUT	<? Type octal M-N,P or M,P@>
	AOJA	LV,ASKP0	;RAISE LEVEL AND ASK AGAIN

ASKP1:	FILSTR	<L *@>;		;OUTPUT TO FILE ENTIRE ANSWER WITH MACRO
				; NAME PRECEDING IT WHICH COMMON WILL DEFINE
				; AS IT PLEASES.
	JRST	ASKPLP		;AND GO GET ANOTHER LINE OF INTPUT
;ROUTINE TO SETUP ALL ASK ROUTINES
; OUTPUTS CRLF TO FILE, OUTPUT QUESTION AS COMMENT, PUT ADR OF QUESTION ON STACK
; PUT ARG FOR * SUBSTITUTION (N) ON STACK SO QUESTION CAN BE REASKED.
;CALL:	MOVEI	T1,ADR OF QUESTION
;	PUSHJ	P,ASKBG
;	RETURN HERE WITH T1 ON END OF LIST

ASKBG:	EXCH	T1,(P)		;SAVE ADR OF MESSAGE ON STACK
	PUSH	P,N		;SAVE ARG FOR * SUBSTITUTION IN CASE
				; OF ERROR AND QUESTION MUST BE REASKED
				; COMMON ASK EXIT(ASKXIT) WILL POP THESE OFF
	PUSH	P,T1		;SAVE RETURN ON END
	PUSHJ	P,FCRLF		;OUTPUT CRLF TO FILE
	HRRZ	T1,-2(P)	;ADR OF QUESTION
	PJRST	FILCOM		;OUTPUT AS A COMMENT, PUTTING ; IN FRONT
				; OF EVERY LINE IN QUESTION

;HERE TO EXIT ASKMN AND ASKMNP
ASKPXT:	PUSHJ	P,FILRAB	;OUTPUT RIGHT ANGLE BRACKET,CRLF TO FILE

;HERE TO EXIT FROM ALL ASK ROUTINES
ASKXIT:	MOVE	LV,SAVLV	;RESTORE VERBOSCITY LEVEL BEFORE QUESTION ASKED
				; OR AS SET BY /HELP:XXX
	POP	P,T1		;THROW AWAY * SUBSTITUTION ARG( AC N)
				; N HAS ANSWER IN IT NOW
	POP	P,T1		;POP OFF T1
	JRST	FILOT2		;CLEAR LF FLAG SO FOLLOWING OUTPUT WONT
				; ACCIDENTALLY GET ; IN FRONT. THEN RETURN.
SUBTTL	GET ROUTINES - SCAN AND CHECK IN CORE STRINGS

;ROUTINE TO GET OCTAL LINE NUMBER OR "CTY"
;CALL:	MOVE	B,BYTE POINTER
;	PUSHJ	P,GETLIN
;	ALWAYS RETURN, N=VALUE OR SIXBIT CTY
;	STOP IN FIRST NON-OCTAL CHAR OR NON-CTY
;	CALLER MUST CHECK FOR LEGAL BREAK CHARACTER

GETLIN:	PUSHJ	P,GETOCT	;GET OCTAL NUMBER
	JUMPN	N,CPOPJ		;RETURN IF GOT SOME VALUE
	CAIE	CH,"C"		;IS BREAK "C"?
	POPJ	P,		;NO, MAYBE 0 OR CR, LET CALLER CHECK
	PJRST	GETMN1		;SEE IF REST IS CTY

;ROUTINE TO SYNTAX CHECK M-N OR M FOLLOWED BY ANY BREAK
;CALL:	MOVE	B,BYTE POINTER
;	PUSHJ	P,GETMN
;	ALWAYS RETURN HERE, BREAK IN CH

GETMN:	PUSHJ	P,GETOCT	;GET OCTAL LINE NUMBER
	CAIN	CH,"C"		;SKIP IF NOT START OF CTY
	JRST	GETMN1		;YES, SEE IF IS CTY
	CAIE	CH,"-"		;IS BREAK -?
	POPJ	P,		;NO, LET CALLER CHECK FURTHER
	MOVEI	CH,","		;YES, CHANGE TO , SO MACRO WILL ACCEPT
	DPB	CH,B		;IN OUTPUT FILE
	PJRST	GETOCT		;GET SECOND OCTAL DIGIT

GETMN1:	PUSHJ	P,GETWRD	;YES, GET REST OF WORD
	MOVSI	N,'CTY'		;ASSUME CTY
	CAMN	WD,[SIXBIT /TY/]	;IS IT REST OF CTY?
	POPJ	P,		;YES, RETURN WITH CTY IN N
	MOVEI	CH,"C"		;NO, RETURN ORIGINAL BREAK FOR CALLER
				; TO GET ERROR WHEN CHECKS IT
	POPJ	P,		;RETURN, CALLER CHECK FOR BREAK
;ROUTINE TO GET DECIMAL FROM STRING
;CALL:	MOVE	B,BYTE POINTER
;	PUSHJ	P,GETDEC
;	ALWAYS RETURN HERE, BREAK IN CR, VALUE IN N
;CALLER MUST CHECK FOR PROPER BREAK

GETDEC:	MOVEI	R,12		;SET RADIX TO DECIMAL
	PJRST	GETNUM		;GET NUMBER


;ROUTINE TO GET OCTAL NUMBER FROM STRING
;SAME CALL AS GETDEC

GETOCT:	MOVEI	R,10		;SET RADIX TO OCTAL
				; FALL INTO GETNUM

;ROUTINE TO GET NUMBER FROM STRING
;CALL:	MOVE	R,RADIX
;	MOVE	B,BYTE POINTER
;	PUSHJ	P,GETNUM
;	ALWAYS RETURN HERE, BREAK IN CH, VALUE IN N
;CALLER MUST CHECK FOR PROPER BREAK, GETNUM STOPS ON FIRST NON-NUMERIC

GETNUM:	MOVEI	N,0		;SET VALUE TO 0
	PUSHJ	P,SKBLNK	;SKIP LEADING BLANKS(SPACES AND TABS)
GETN0:	JUMPE	CH,CPOPJ	;IS THIS END OF STRING
	CAIL	CH,"0"		;LESS THAN 0?
	CAIL	CH,"0"(R)	;LESS THAN RADIX
	PJRST	SKBLK1		;YES, RETURN - SKIP TO FIRST NON-BLANK
	IMUL	N,R		;MULTIPLY OLD NUMBER BY RADIX
	ADDI	N,-"0"(CH)	;ADD IN VALUE OF THIS CHAR
	ILDB	CH,B		;GET NEXT CHAR IN STRING
	JRST	GETN0		;GET ANOTHER CHAR



;ROUTINE TO GET A WORD FROM AN ASCIZ STRING.  FILTERS OUT TAB, SPACE
; STOPS ON ANY NON-ALPHA NUMERIC, CALLER MUST CHECK FOR LEGAL BREAK
;CALL:	MOVE	B,BYTE POINTER
;	PUSHJ	P,GETWRD
;	RETURN WITH SIXBIT WD LEFT JUSTIFIED, BREAK IN CH

GETWRF:	PUSH	P,[PUSHJ P,FHLPRC] ;INSTRUCTION TO GET NEXT CHAR
	JRST	GETWR1		;READ ASCIZ STRING FOR SIXBIT

GETWRD:	PUSH	P,[ILDB CH,B]	;INSTRUCTION TO GET NEXT CHAR
GETWR1:	PUSHJ	P,GETSKB	;SKIP LEADING BLANKS(SPACES, TABS)
	MOVEI	WD,0		;SET WORD TO 0 FOR RETURN
	MOVE	T1,[XWD	440600,WD] ;SET SIX BIT BYTE POINTER TO WD

;LOOP TO ACCUMULATE AFTER LEADING SPACES AND TABS
GETWLP:	JUMPE	CH,GETWX1	;END OF STRING?
	CAIL	CH,"0"		;LESS THAN 0?
	CAILE	CH,"9"		;LESS THAN OR EQUAL TO 9?
	JRST	GETWD2		;YES, SEE IF LETTER?
	JRST	GETWD3		;NO, NUMBER, STORE

;HERE IF NOT NUMBER
GETWD2:	CAIL	CH,"A"+40	;LOWER CASE?
	TRC	CH,40		;YES, CONVERT TO UPPER CASE
	CAIL	CH,"A"		;LESS THAN A
	CAILE	CH,"Z"		;LESS THAN OR EQUAL TO Z?
	PJRST	GETWRX		;SKIP TRAILING BLANKS TO FIRST NON-BLANK
				; AND RETURN TO CALLER
;HERE IF A LETTER OR NUMBER - CONVERT TO SIXBIT AND STORE
GETWD3:	SUBI	CH,40		;CONVERT TO SIXBIT
	TLNE	T1,770000	;OVERFLOWED WD YET?
	IDPB	CH,T1		;NO, STORE NEXT SIXBIT CHAR
	XCT	(P)		;GET NEXT CHAR
	JRST	GETWLP		;AND CHECK IT

GETWRX:	PUSHJ	P,SKBLK1	;RETURN FIRST NON-BLANK AFTER TRAILING SPACES
GETWX1:	POP	P,(P)
	POPJ	P,

GETSKB:	XCT	-1(P)		;GET NEXT CHAR
GETSK1:	CAIE	CH," "		;SPACE?
	CAIN	CH,"	"		;TAB?
	JRST	GETSKB		;YES, GET NEXT CHAR
	POPJ	P,		;NO, FOUND NON-BLANK
;ROUTINE TO GET TTY LINE, AND SCAN FOR DEV:PI
; WHERE DEV IS 3 CHAR OR LESS AND PI IS # FOR 0-7
;CALL:	PUSHJ	P,GETDPI
;	  ERROR RETURN, /HELP , DEV TOO LONG, OR PI TOO BIG
;	OK RETURN, BREAK IN CH, WD=0 IF JUST CR TYPED

GETDPI:	PUSHJ	P,TTYIN		;GET NEXT LINE
	  POPJ	P,		;/HELP TYPED, REASK IN DESIRED HELP MODE
	MOVEI	WD,0		;SET JUST CR TYPED INDICATION
	JUMPE	CH,CPOPJ1	;JUST A BLANK LINE?
	PUSHJ	P,GETWRD	;NO, GET FIRST WORD
	JUMPE	WD,ASKDPE	;ARE THERE ANY CHAR IN DEVICE NAME?
	CAIE	CH,","		;IS BREAK CHAR COMMA?
	POPJ	P,		;NO, ERROR
	TRNE	WD,777777	;IS DEVICE 3 CHAR OR LESS?
ASKDPE:	RJRST	<TTYOUT	<? device-mnemonic must be 3 char or less@>
		 POPJ	P,>	;GO TRY AGAIN
	PUSHJ	P,GETDEC	;GET PI NO.
	CAILE	N,SM.PI		;LEGAL PI?
	RJRST	<MOVEI N,SM.PI	;GET MAXIMUM LEGAL PI
		 TTYOUT	<? PI-channel must be * or less@>
		 POPJ	P,>	;GO TRY AGAIN
	JRST	CPOPJ1		;YES, GIVE LEGAL RETURN


;ROUTINE TO SKIP LEADING BLANKS(SPACES AND TABS)
;CALL:	MOVE	B,BYTE POINTER
;	PUSHJ	P,SKBLNK	OR SKBLK1 IF FIRST CHAR ALREADY IN CH
;	FIRST NON-BLANK RETURNED IN CH

SKBLNK:	ILDB	CH,B		;GET NEXT CHAR
SKBLK1:	CAIE	CH," "		;SPACE?
	CAIN	CH,"	"	;TAB?
	JRST	SKBLNK		;YES, GET NEXT CHAR
	POPJ	P,		;NO, RETURN WITH FIRST NON-BLANK IN CH
SUBTTL	FGEN AUXILIARY HELP FILE ROUTINES

;ROUTINE TO OUTPUT FROM THE AUXILIARY FILE TO TTY

FHLPTT:	PUSH	P,[PUSHJ P,FHLPRC] ;INSTRUCTION TO GET NEXT CHAR TO OUTPUT
	MOVSI	N,'*  '		;EASY WAY TO MAKE SURE * COMES OUT RIGHT
	JRST	TTYOLP		;TYPE OUT STRING

;ROUTINE TO OUTPUT FROM THE AUXILIARY FILE TO THE OUTPUT FILE
;CALL:	PUSHJ	P,FHLPFC TO OUTPUT AS A COMMENT
;	PUSHJ	P,FHLPFL TO OUTPUT AS TEXT

FHLPFC:	TLO	F,(F.COM)	;NOTE OUTPUT AS A COMMENT
FHLPFL:	PUSH	P,[PUSHJ P,FHLPRC] ;INSTRUCTION TO GET NEXT CHAR TO OUTPUT
	MOVSI	N,'*  '		;EASY WAY TO MAKE SURE * COMES OUT RIGHT
	JRST	FILOLP		;OUTPUT TO FILE

;ROUTINE TO POSITION THE AUXILIARY FILE
;CALL:	MOVE	WD,SIXBIT TEXT TO FIND
;	PUSHJ	P,FHLPOS
;	ERROR RETURN - CANT FIND IT
;	OK RETURN - FILE POSITIONED AFTER TAB
;
;	NOTE LOOKS FOR TERMINATOR FIRST, TO BE FOLLOWED IMMEDIATELY BY TEXT IN WD

FHLPOA:	TLZA	F,(F.FHLC)	;NOTE DONT WANT TAB AFTER TEXT
FHLPOS:	TLO	F,(F.FHLC)	;NOTE LOOKING FOR A TAB AFTER TEXT
	TLZ	F,(F.HRRD)	;CLEAR REREADING FLAG
FHLPS0:	PUSHJ	P,FHLPRD	;READ NEXT CHAR FROM AUX FILE
FHLPS3:	JUMPL	CH,FHLPEF	;JUMP IF END OF AUX FILE
	JUMPN	CH,FHLPS0	;LOOK FOR TERMINATOR
FHLPS1:	MOVE	T1,[POINT 6,WD]	;BYTE PTR FOR DESIRED STRING
FHLPS2:	TLNN	T1,770000	;SKIP IF NEED MORE CHARS TO MATCH
	JRST	FHLPFN		;FOUND WHAT WAS DESIRED
	ILDB	N,T1		;N=NEXT CHAR NEEDED (IN SIXBIT)
	JUMPE	N,FHLPFN	;JUMP IF THAT'S ALL THATS NEEDED
	PUSHJ	P,FHLPRD	;GET NEXT CHAR FROM AUX FILE
	JUMPL	CH,FHLPEF	;JUMP IF END OF FILE
	JUMPE	CH,FHLPS1	;IF TERMINATOR, START LOOKING AGAIN
	CAIL	CH,140		;SKIP IF NOT LOWER CASE
	SUBI	CH,40		;MAKE UPPER CASE FOR COMPARISON
	CAIE	N,' '-" "(CH)	;SKIP IF THIS CHAR MATCHES
	JRST	FHLPS0		;NO, MOVE TO NEXT TERMINATOR
	JRST	FHLPS2		;YES, KEEP ON

;HERE IF FOUND END OF AUX FILE
FHLPEF:	TLNE	F,(F.FHLC)	;SKIP IF NOT LOOKING FOR TAB AFTER TEXT
	TLOE	F,(F.HRRD)	;SKIP IF NOT ALREADY REREADING THE FILE
	POPJ	P,		;CANT FIND DESIRED STRING
	TLZ	F,(F.HOPN)	;CLEAR OPEN FLAG TO RESTART AT BEGINNING OF FILE
	JRST	FHLPS0		;NO, MAY HAVE STARTED PAST THE PLACE
;HERE WHEN FILE POSITIONED AS REQUESTED
FHLPFN:	TLNN	F,(F.FHLC)	;SKIP IF LOOKING FOR TAB AFTER STRING
	JRST	CPOPJ1		;NO, ALL SET
FHLPF1:	PUSHJ	P,FHLPRD	;SKIP TO TAB
	JUMPLE	CH,FHLPS3	;JUMP IF TERMINATOR FOUND
	CAIE	CH,"	"	;SKIP IF FOUND TAB
	JRST	FHLPF1		;KEEP ON
	JRST	CPOPJ1		;GIVE GOOD RETURN

;THIS ROUTINE READS A CHAR FROM THE AUXILIARY HELP FILE FOR MESSAGES
FHLPRC:	PUSHJ	P,FHLPRD	;GET NEXT CHAR
	JUMPGE	CH,CPOPJ	;OK IF REAL CHAR
	SETZ	CH,		;TURN EOF INTO END OF STRING
	POPJ	P,
;ROUTINE TO READ NEXT CHAR FROM FGEN AUXILIARY HELP FILE

FHLPRD:	TLNE	F,(F.HOPN)	;SKIP IF HELP FILE IS NOT YET OPEN
	JRST	FHLPR1		;ALREADY OPEN, GO AHEAD
	INIT	FHLPCH,0
FGDEV:	SIXBIT	.SYS.
	XWD	0,FHIBUF
	  JRST	FHLPE1		;CANT INIT SYS?
	MOVE	CH,FGPPN	;PPN FOR HELP FILE
	MOVEM	CH,FHNAME+3	;STORE FOR LOOKUP
	LOOKUP	FHLPCH,FHNAME	;LOOKUP FILE
	  JRST	FHLPE1		;CANT FIND FILE
	TLO	F,(F.HOPN!F.HRRD) ;NOTE OPEN AND ON SECOND PASS
	PUSH	P,.JBFF##	;SAVE JOBFF
	MOVEI	CH,FHLPBF	;ADDR OF FHELP FILE BUFFERS
	MOVEM	CH,.JBFF	;SET UP TO ALLOCATE BUFFERS
	INBUF	FHLPCH,NFHLPB	;ALLOCATE INPUT BUFFERS
	POP	P,.JBFF		;RESTORE JOBFF
FHLPR1:	SETZ	CH,		;CLEAR CH IN CASE ERROR IN IN SUBROUTINE
	SOSG	FHIBUF+2
	PUSHJ	P,[IN FHLPCH,
		   POPJ P,
		   JRST	FHLPER]
	JUMPL	CH,CPOPJ	;GIVE UP IF ERROR READING
	ILDB	CH,FHIBUF+1	;GET NEXT CHAR
	JUMPE	CH,FHLPR1	;IGNORE NULLS
	CAIN	CH,C.RUB	;AND RUBOUTS
	JRST	FHLPR1
	CAIL	CH,175		;DO THE ALTMODE THING
	MOVEI	CH,C.ESC
	CAIN	CH,C.TMFH	;SKIP IF NOT OUR TERMINATOR
	SETZ	CH,		;RETURN 0 FOR TERMINATOR FOR CONVENIENCE
	POPJ	P,

FHLPER:	TLZ	F,(F.HOPN)	;CLEAR OPEN FLAG
	RELEASE	FHLPCH,
FHLPE1:	SETO	CH,
	POPJ	P,
SUBTTL	TTY INPUT ROUTINES

;ROUTINE TO ACCEPT 1 LINE FROM TTY, MOVE IT TO ASCSTR
;REMOVE EOLS, AND COMMENTS, AND ADD A NULL TO MAKE IT ASCIZ
; LOOK FOR /H AND HANDLE IT
;OUTPUT LINE WITH PRECEDING ; TO FILE
;CALL:	PUSHJ	P,TTYIN
;	  NON SKIP RETURN IF USER TYPES /HELP, CALLER MUST REASK QUESTION
;	    LEVEL SET AS USER WISHES IN LV FOR THIS QUESTION,
;	    AND IN SAVLV FOR FUTURE
;	SKIP RETURN WITH B SETUP AS BYTE POINTER TO BEG OF STRING
;	CH = 0 IF JUST A BLANK LINE TYPED
;	N = NUMBER OF CHARACTERS NOT COUNTING EOLS OR NULLS
;	B = BYTE POINTER TO STRING JUST READ IN


TTYIN:	TLO	F,(F.COM)	;FLAG OUTPUT TO FILE AS COMMENTS SO ALL
				; CALLS TO FILOUT WILL PUT PRECEDING ;
	PUSHJ	P,TTYGET	;GET NEXT CHAR, OUTPUT TO FILE, SKIP COMMENTS, EOL=0
	MOVEI	N,0		;SETUP LENGTH OF STRING TO 0
	MOVE	B,[XWD 440700,ASCSTR] ;BYTE POINTER

;LOOP TO COPY CHARS FROM TTY TO CORE BUFFER(ASCSTR)
TTYINB:	IDPB	CH,B		;STORE AWAY
	JUMPE	CH,TTYINC	;IF EOL CHAR, RETURN
	PUSHJ	P,TTYGET	;GET NEXT CHAR
	CAIGE	N,DP.LMX	;LESS THAN MAX LINE LENGTH?
				; ASCSTR ALWAYS HAS ROOM FOR NULL
	TLZ	F,(F.COM)	;CLEAR FLAG FOR FILE COMMENTS
	AOJA	N,TTYINB	;YES, OK TO STORE NEXT CHAR
	TTYOUT	<? Line too long@>
	AOJA	LV,FILOT2	;INCREASE LEVEL BY 1 FOR THIS QUESTION
				; AND PRETEND /HELP TYPED BY GIVING NO-SKIP
				; RETURN SO CALLER WILL REASK QUESTION

;HERE WHEN STRING ALL STORED IN CORE BUFFFER
TTYINC:	TLZ	F,(F.COM)	;CLEAR FLAG FOR FILE COMMENTS
	MOVE	B,[XWD 440700,ASCSTR] ;BYTE POINTER TO CORE BUFFER
	PUSHJ	P,SKBLNK	;SKIP BLANKS(SPACE, TAB)
	CAIN	CH,"/"		;IS FIRST NON-BLANK A SLASH?
	JRST	TTYINH		;YES, GO DO /HELP
	MOVE	B,[XWD 440700,ASCSTR] ;SETUP BYTE POINTER TO
				; BEG OF CORE BUFFER FOR CALLER
	TLZ	F,(F.COM)	;CLEAR COMMENT FLAG
	JRST	CPOPJ1		;GIVE NON-HELP RETURN
;HERE ON LEADING / FROM TTYIN ROUTINE - SEE IF /HELP
; REST OF INPUT LINE ALEADY COPIED TO FILE AND CORE BUFFER(ASCSTR)
; OK TO DESTROY ASKTAB+0,... SINCE GOING TO GIVE NON-SKIP RETURN
TTYINH:	PUSH	P,N		;SAVE CCALLERS N IN CASE * SUBSTITUTION
				; WHEN QUESTION REASKED
	MOVEI	T1,[ASCIZ /(HELP)/] ;SETUP ONLY CHOICE AS IF PROMPT
	PUSHJ	P,SETASK	;IN CHOICES TABLE(ASKTAB)
	PUSHJ	P,FNDASK	;SCAN CHARS AFTER / TO SEE IF HELP
	  AOJA	LV,TTYIH1	;NO, GIVE HIM HELP WITH HELP
				; AT NEXT LONGER HELP MODE
	PJUMPE	CH,RAISE1	;IS BREAK EOL?(IF YES, JUST INCREASE
				; LEVEL OF VERBOSCITY BY 1 FOR THIS QUESTION
				; BY ADDING TO LV BUT NOT TO SAVLV
	CAIE	CH,":"		;IS BREAK COLON?
	AOJA	LV,TTYIH1	;NO, ASK HELP QUESTION
				; AT NEXT LONGER MODE
	MOVEI	T1,[ASCIZ /(,SHORT,PROMPT,LONG)/] ;SETUP UP CHOICES TO /HELP:
				; N=0 MEANS JUST CR TYPED
	PUSHJ	P,SETASK	;IN ASKTAB+0,1,...
	PUSHJ	P,FNDASK	;FIND THE ONE HE TYPED
	  AOJA	LV,TTYIH1	;NOT FOUND, INCREASE HELP LEVEL
	JUMPE	N,RAISE1	;DID HE TYPE JUST CR?
				; IF YES, JUST INCREASE LEVEL FOR THIS QUESTION
	SUBI	N,2		;NO, FORM -1,0,1 FOR SHORT,PROMPT,LONG
	TLZ	F,(F.COM)	;CLEAR COMMENT FLAG
	JRST	HELP0		;GO STORE NEW PERMANENT HELP LEVEL

;HERE TO RAISE LEVEL 1 FOR THIS QUESTION ONLY
RAISE1:	TLZ	F,(F.COM)	;CLEAR COMMENT FLAG
	AOJA	LV,HELP1	;INCREMENT LEVEL BY ONE, BUT DO NOT
				; REMEMBER IN MEMORY(SAVLV)
				; AND RETURN
TTYIH1:	TLZA	F,(F.COM)	;CLEAR COMMENT FLAG AND GO TO TTYHP1

;ROUTINE TO TYPE HELP QUESTION
; CALLED AT BEGINNING ONCE ONLY AND WHENEVER /HELP:XXX MISTYPED
;CALL:	PUSHJ	P,TTYHLP

TTYHLP:	PUSH	P,N		;SAVE CALLER N INCASE * SUBSTITUTION
				; WHEN QUESTION REASKED
TTYHP1:	ASKLST	</HELP(PROMPT,SHORT,LONG)[
All # are decimal unless stated otherwise
Unique abbrivation allowed everywhere to all questions
/HELP reasks a question in next longer mode
/HELP:xxx sets mode permanently.  Modes are:
SHORT is short
PROMPT has choices in ()
LONG has choices in () and explanation in []]>
	CAIN	N,1		;ANSWER 1(SHORT)
	SETOM	N		;YES, SET LEVEL TO SHORT
	CAIN	N,2		;ANSWER 2(LONG)?
	MOVEI	N,1		;YES, SET LEVEL TO LONG

;HERE TO STORE NEW PERMANENT HELP LEVEL
HELP0:	MOVEM	N,SAVLV		;SET PERMANENT LEVEL OF HELP
	MOVE	LV,N		;SET CURRENT LEVEL TO THE SAME
HELP1:	POP	P,N		;RESTORE ORIGINAL N(IN CASE THIS
				; IS HELP IN MIDDLE OF A QUESTION)
	POPJ	P,		;GIVE NON-SKIP RETURN SO QUESTION
				; WILL BE REASKED

;ROUTINE TO GET ONE CHAR FROM TTY, CHECK FOR EOLS, PUT CHAR IN  FILE
; AND SKIP OVER COMMENTS. ALSO CHECK FOR /HELP

TTYGET:	PUSHJ	P,TTYGT1	;GET NEXT CHAR FROM TTY AND PUT IN FILE
	  POPJ	P,		;IT WAS AN EOL, RETURN, F.COM CLEARED
	CAIE	CH,";"		;NO, WAS IT ";" FOR A COMMENT?
	POPJ	P,		;NO, RETURN

;LOOP TO THROW AWAY COMMENTS USER TYPED IN AFTER ANSWER
TTYGT0:	PUSHJ	P,TTYGT1	;YES, GET NEXT CHAR
	  POPJ	P,		;IT WAS AN EOL, RETURN WITH F.COM CLEARED
	JRST	TTYGT0		;NOT AN EOL, THROW IT AWAY AND GET NEXT CHAR


;ROUTINE TO GET ONE CHAR FROM TTY, CHECK FOR EOL, PUT CHAR IN FILE
;CALL:	PUSHJ	P,TTYGT1
;	  EOL RETURN CH=0, F.COM CLEARED(MAKE FILE OUTPUT NO LONGER BE COMMENTS)
;	NOT AN EOL RETURN, CH IS CHAR

TTYGT1:	SOSG	TIBUF+2		;DECREMENT INPUT TTY BUFFER COUNT
	RJRST	<IN	TTYCHN,	;GET NEXT BUFFER FROM MONITOR
		 JRST	TTYGT2	;NO ERRORS
		 STATO	TTYCHN,IO.EOF ;END OF FILE ON TTY?
		 JRST	TTYGT2	;NO, IGNORE ERROR
		 JRST	TTYZ>	;YES, SET CONTROL Z FLAG
TTYGT2:	ILDB	CH,TIBUF+1	;GET NEXT CHAR FROM BUFFER
	JUMPE	CH,TTYGT1	;IS IT NULL?
	CAIE	CH,C.RUB	;IGNORE RUBOUTS
	CAIN	CH,C.CR		;IS IT CR?
	JRST	TTYGT1		;YES, SKIP
	CAIL	CH,C.LF		;LESS THAN LINE FEED?
	CAILE	CH,C.CR		;NO, LESS THAN CARRIAGE RETURN?
	SKIPA			;NO, NOT AN EOL
	JRST	TTYEOL		;YES, CONSIDER AS EOL
	CAIE	CH,C.ESC	;ESCAPE?
	CAIL	CH,C.ALT1	;OLD ALTMODE?
	JRST	TTYEOL		;YES, TREAT AS EOL
	CAIE	CH,C.CONC	;CONTROL C?
	CAIN	CH,C.CONZ	;CONTROL Z?
	JRST	TTYZ		;YES, SET FLAG(OLDER MONITORS STORE ^Z IN BUFFER)
	PUSHJ	P,FILPUT	;STORE CHAR IN FILE
	JRST	CPOPJ1		;AND SKIP RETURN

;HERE WHEN CONTROL Z SEEN OF END OF FILE SET ON TTY
TTYZ:	CLOSE	TTYCHN,		;TURN OFF EOF FOR TTY
				; CLEAR EOF SO CAN DO MORE INPUTS
	TLO	F,(F.CONZ)	;FLAG CONTROL Z SEEN
TTYEOL:	PUSHJ	P,FCRLF		;OUTPUT CRLF TO FILE
	MOVEI	CH,0		;RETURN 0 AS EOL CHAR
	POPJ	P,		;GIVE EOL RETURN
SUBTTL	OUTPUT ROUTINES - TTY AND FILE

;ROUTINE TO TYPE INTERNAL DIALOG ERROR ON TTY AND FILE, THEN EXIT TO MONITOR
;USE TTCALL IN CASE TTY COULD NOT BE INITED
;CALL:	EREXIT	<MESSAGE>,

EREXIT:	PUSH	P,T1		;SAVE ADR OF MESSAGE
	OUTSTR	[ASCIZ /
? Internal DIALOG error - /]
	OUTSTR	(T1)		;THE CALLERS MESSAGE
	FILOUT	<@? Internal DIALOG error - >
	POP	P,T1		;RESTORE MESSAGE ADR
	PUSHJ	P,FILOUT	;OUTPUT TO FILE
	EXIT			;EXIT TO MONITOR


;ROUTINE TO OUTPUT TO FILE IN DECIMAL AND SUBSTITUTE FOR *
;CALL:	MOVEI	T1,ADR OF MESSAGE
;	PUSHJ	P,FILDEC
;	ALWAYS RETURN HERE, N PRESERVED

FILDC2:	TLO	F,(F.2DEC)	;ASK FOR AT LEAST TWO CHARS OUTPUT
FILDEC:	MOVEI	R,12		;SET RADIX TO DECIMAL
	PJRST	FILOT1		;DO OUTPUT AND SUBSTITUTION

;ROUTINE TO OUTPUT TO FILE AND SUBSTITUTE FOR *
; VALUE OR SIXBIT IN N
;CALL:	MOVEI	T1,ADR OF ASCIZ STRING TO OUTPUT
;	MOVE	N,NUMBER OR LEFT JUSTIFIED SIXBIT
;	PUSHJ	P,FILOUT
;	ALWAYS	RETURN HERE, N PRESERVED

FILCOM:	TLOA	F,(F.COM)	;SET FLAG TO PRECEDE ALL LINE WITH ;
				; AS A COMMENT IN FILE
FILOUT:	MOVEI	R,10		;SET OUTPUT RADIX TO OCTAL FOR MACRO
FILOT1:	HRLI	T1,440700	;FORM LH OF BYTE POINTER
	PUSH	P,[ILDB CH,T1]	;INSTRUCTION TO GET NEXT CHAR
FILOLP:	XCT	(P)		;GET NEXT CHAR IN OUTPUT MESSAGE
	PJUMPE	CH,FILT2A	;RETURN IF END OF STRING
	CAIN	CH,"*"		;NOT EOS, IS IT ASTERISK?
	PUSHJ	P,EITAST	;YES, SUBSTITUTE N FOR IT
	  PUSHJ	P,FILPUT	;ARG TO EITAST OR OUTPUT CHAR
	JRST	FILOLP		;LOOP AND GET NEXT CHAR


;HERE ON END OF STRING
FILT2A:	POP	P,(P)		;REMOVE INSTRUCTION FROM STACK
FILOT2:	TLZ	F,(F.COM!F.2DEC) ;NOW CLEAR FLAG SO NEXT CALLER CAN USE
				; FILOUT OR FILCOM WITHOUT HAVING TO SET OR CLEAR
				; TO INDICATE COMMENT OR NOT
	POPJ	P,		;RETURN
;ROUTINE TO OUTPUT TO BOTH FILE AND TTY
; SUBSTITUTE FOR * VALUE OR SIXBIT IN N, PRECEDE EACH
; LINE IN FILE WITH ; SO A COMMENT
;CALL:	MOVEI	T1,ADR OF ASCIZ STRING
;	PUSHJ	P,BTHOUT	FOR DECIMAL OR BTHOCT FOR OCTAL
;	ALWAYS RETURN HERE, N PRESERVED

BTHOCT:	SKIPA	R,[EXP 10]	;OCTAL RADIX
BTHOUT:	MOVEI	R,12		;OCTAL OUTPUT FOR FILE
	PUSH	P,T1		;SAVE ADR OF ASCIZ MESSAGE
	PUSHJ	P,FILCOM	;OUTPUT TO FILE AS A COMMENT
	POP	P,T1		;RESTORE ADR OF MESSAGE AND
				; FALL INTO TTYOUT


;ROUTINE TO OUTPUT TO TTY IN DECIMAL
; SUBSTITUTE FOR * VALUE OR SIXBIT IN N
; OUTPUT INSIDE PARENS AND BRACKETS DEPENDING ON HELP LEVEL
;CALL:	MOVEI	T1,ADR OF ASCIZ STRING
;	PUSHJ	P,TTYOUT
;	ALWAYS RETURN HERE, N PRESERVED

TTYOCT:	MOVEI	R,10		;OCTAL RADIX(RARE) FOR TTY
	JRST	TTROUT		;GO DO REST OF TTYOUT

TTYOUT:	MOVEI	R,12		;SET RADIX TO DECIMAL FOR PEOPLE
TTROUT:	HRLI	T1,440700	;FORM LH OF BYTE POINTER
	PUSH	P,[ILDB CH,T1]	;INSTRUCTION TO GET NEXT CHAR
TTYOLP:	XCT	(P)		;GET NEXT CHAR INTO CH
	PJUMPE	CH,TTYNOW	;IF EOL, FORCE OUT TTY NOW
	CAIN	CH,"["		;LEFT BRACKET?
	TLO	F,(F.LBRK)	;YES, FLAG INSIDE EXPLANATION
	TLNE	F,(F.LBRK)	;ARE WE INSIDE AN EXPLANATION?
	JUMPLE	LV,TTYSBK	;YES, IS HELP LEVEL SHOR OR PROMPT?
	CAIN	CH,"("		;NO, LONG MODE, IS THIS CHAR LEFT PAREN?
	TLO	F,(F.LPAR)	;YES, FLAG INSIDE PROMPTING
	TLNE	F,(F.LPAR)	;ARE WE INSIDE PROMPTING?
	JUMPL	LV,TTYSPR	;YES, IS HELP LEVEL SHORT?

;HERE IF HELP LEVEL PERMITS THESE CHARS TO BE OUTPUT
	CAIN	CH,"*"		;NO, IS IT ASTRISCK?
	PUSHJ	P,EITAST	;YES, SUBSTITUTE N FOR IT
	  PUSHJ	P,TTYPUT	;ARG TO EITAST OR OUTPUT CHAR ROUTINE

;HERE TO SUPPRESS PROMPTING INSIDE PARENS(SHORT MODE ONLY)
TTYSPR:	CAIN	CH,")"		;WAS CHAR JUST OUTPUT RIGHT PAREN?
	TLZ	F,(F.LPAR)	;YES, CLEAR INSIDE PROMPTING FLAG

;HERE TO SUPPRESS EXPLANATION INSIDE BRACKETS(SHORT AND PROMPT MODES)
TTYSBK:	CAIN	CH,"]"		;WAS CHAR JUST OUTPUT RIGHT BRACKET?
	TLZ	F,(F.LBRK)	;YES, CLEAR INSIDE EXPLANATION
	JRST	TTYOLP		;LOOP AND GET NEXT CHAR
;ROUTINE TO SUBSTITUTE FOR * IN OUTPUT TO FIL OR TTY USING N
;CALL:	MOVE	N,[SIXBIT / /] OR DECIMAL NUMBER
;	MOVEI	R,RADIX
;	MOVE	T1,BYTE POINTER
;	CAIN	CH,"*"
;	PUSHJ	P,EITAST
;	  PUSHJ	P,FILPUT OR TTYPUT
;	RETURN	HERE WITH T1 AND N PRESERVED

EITAST:	PUSH	P,T1		;SAVE BYTE POINTER TO STRING
	TLNN	N,77000		;DOES N HAVE A SIXBIT ARG?
	JRST	EITAS2		;NO, OUTPUT AS A NUMBER

;HERE TO OUTPUT N AS SIXBIT FOR *
	MOVE	WD,[XWD 440600,N] ;SETUP BYTE POINTER TO SIXBIT ARG
EITAS1:	ILDB	CH,WD		;GET NEXT SIXBIT CHAR
	JUMPE	CH,TPOPJ1	;IS IT END OF SIXBIT?
	ADDI	CH,40		;CONVERT TO ASCII
	XCT	@-1(P)		;OUTPUT CHAR TO TTY OR FIL ACCORDING
				; TO ARG IN CALLING SEQUENCE
	TLNE	WD,770000	;BYTE POINTER EXHAUSTED WD?
	JRST	EITAS1		;NO, KEEP GETTING SIXBIT CHARS
	JRST	TPOPJ1		;YES, RETURN

;HERE TO CONVERT N AND OUTPUT ACCORDING TO CURRENT RADIX
EITAS2:	MOVE	WD,@-1(P)	;GET ADR OF CHAR PUT ROUTINE FOR TTY OR FILE
				; (TTYPUT OR FILPUT)
	MOVE	T1,N		;MOVE NO. TO DOUBLE AC
	CAIG	N,^D9		;SKIP IF GREATER THAN TWO CHARS
	TLNN	F,(F.2DEC)	;ONE CHAR, SKIP IF WANT AT LEAST TWO
	JRST	EITAS3		;GO AHEAD AS PLANNED
	MOVEI	CH,"0"		;OUTPUT LEADING ZERO
	PUSHJ	P,(WD)		;OUTPUT IT
EITAS3:	PUSHJ	P,EITSUB	;CALL RECURSIVE OUTPUT ROUTINE
TPOPJ1:	POP	P,T1		;RSTORE BYTE POINTER
CPOPJ1:	AOS	(P)		;SET FOR SKIP RETURN
CPOPJ:	POPJ	P,		;RETURN

EITSUB:	IDIVI	T1,(R)		;DIVIDE REMAINING NUMBER BY RADIX
	HRLM	T2,(P)		;SAVE REMAINDER ON STACK
	JUMPE	T1,EITSB1	;REMAINING NUMBER ALL GONE?
	PUSHJ	P,EITSUB	;NO, DIVIDE REMINING NUMBER BY RADIX AGAIN
EITSB1:	HLRZ	CH,(P)		;GET MOST RECENT CHAR CONVERTED
	ADDI	CH,"0"		;CONVERT TO ASCII
	PJRST	(WD)		;OUTPUT CHAR TO TTY OR FIL AS SPECIFIED
				; IN CALLING SEQUENCE
				; RETURN TO EITSB1 UNTIL ALL CHAR OUTPUT
;ROUTINE TO OUTPUT JUST A STRING AND SUBSTITUTE ASCSTR FOR *
;CALL:	FILSTR	<MESSAGE*MESSAGE@>

FILSTR:	HRLI	T1,440700	;FORM LH OF BYTE POINTER
STRLOP:	ILDB	CH,T1		;GET NEXT CHAR
	JUMPE	CH,CPOPJ	;END OF STRING?
	CAIN	CH,"*"		;IS THIS ASTERISK?
	JRST	STRSUB		;YES, SUBSTITUTE STRING IN ASCSTR
	PUSHJ	P,FILPUT	;NO, STORE THIS CHAR IN FILE OUTPUT BUFFER
	JRST	STRLOP		;GO GET NEXT CHAR

STRSUB:	PUSH	P,T1		;SAVE BYTE POINTER SO FAR
	MOVEI	T1,ASCSTR	;SETUP TO OUTPUT FROM WHERE USER TYPED IN
	PUSHJ	P,FILOUT	;OUTPUT STRING TO FILE
	POP	P,T1		;RESTORE BYTE POINTER TO WHERE LEFT OFF
	JRST	STRLOP		;GO GET NEXT CHAR(SKIP OVER * ITSELF)

;ROUTINE TO OUTPUT LEFT ANGLE BRACKET CRLF TO FILE
;CALL:	PUSHJ	P,FILLAB

FILLAB:	MOVEI	CH,"<"		;LEFT ANGLE BRACKET
	PUSHJ	P,FILPUT	;PUT IN OUTPUT FILE
	PJRST	FCRLF		;OUTPUT CRLF TO FILE

;ROUTINE TO OUTPUT RIGHT ANGLE BRACKET CRLF TO FILE
;CALL:	PUSHJ	P,FILRAB

FILRAB:	MOVEI	CH,">"		;RIGHT ANGLE BRACKET
	PUSHJ	P,FILPUT	;PUT IN OUTPUT FILE
				; FALL INTO FCRLF

;ROUTINE TO OUTPUT CRLF TO FILE
;CALL:	PUSHJ	P,FCRLF

FCRLF:	MOVEI	CH,C.CR		;OUTPUT CR
	PUSHJ	P,FILPUT	;TO FILE
	MOVEI	CH,C.LF		;THEN LINE FEED
				; FALL INTO FILPUT
;ROUTINE TO OUTPUT 1 CHAR TO OUTPUT FILE, IF @ SUBSTITUTE CRLF
; OUTPUT TO TTY TOO IF DEBUGGING FLAG IS SET(DEBUG)
;INSERT PRECEDING ; IF FIRST CHAR ON A LINE AND F.COM SET
;CALL:	MOVEI	CH,CHAR
;	PUSHJ	P,FILPUT
;	RETURN CH PRESERVED

FILPUT:	TLNN	F,(F.OFO)	;OUTPUT FILE OUTPUT YET?
	POPJ	P,		;NO, MUST BE ASKING QUESTION ABOUT OUTPUT FILE
	CAIN	CH,"@"		;YES, IS THIS CHAR THE CRLF CHAR?
	PJRST	FCRLF		;YES, OUTPUT CRLF TO FILE AND RETURN
	SKIPE	DEBUG		;NO, ARE WE DEBUGGING?
	TLOE	F,(F.TF)	;YES, IS THIS THE FIRST CHAR TO FIL
				; AFTER TTY OUTPUT?
	JRST	FILPU1		;NO, LEFT ANGLE ALREADY OUTPUT
	PUSH	P,CH		;YES, SAVE CHAR
	MOVEI	CH,"<"		;FLAG START OF OUTPUT WITH LEFT ANGLE
	PUSHJ	P,TTYPU1	;ON TTY
	POP	P,CH		;RESTORE REAL FIRST CHAR TO FILE
FILPU1:	TLZE	F,(F.FLF)	;WAS LAST CHAR OUTPUT TO FILE A LF?
	TLNN	F,(F.COM)	;YES, SHOULD THIS LINEN BE A COMMENT IN FILE?
	JRST	FILPU2		;NO, SO OUTPUT IT
	PUSH	P,CH		;YES, SAVE FIRST CHAR OF LINE
	MOVEI	CH,";"		;INSTEAD PUT OUT SEMI-COLON AS COMMENT CHAR
	PUSHJ	P,FILPU3	; AS FIRST CHAR ON LINE
	MOVEI	CH,";"		;OUTPUT 2 ; IN CASE COMMENT IS IN MACRO
	PUSHJ	P,FILPU3	;SO WONT SAVE COMMENT IN MACRO EXPANSION
	MOVEI	CH,"	"	;TAB
	PUSHJ	P,FILPU3	;OUTPUT TAB
	POP	P,CH		;RESTORE FIRST CHAR OF COMMENT
FILPU2:	CAIN	CH,C.LF		;IS THIS CHAR A LINE FEED?
	TLO	F,(F.FLF)	;YES, FLAG LAST CHAR OUTPUT WAS A LINE FEED
				; FOR NEXT CALL TO FILPUT
FILPU3:	SKIPE	DEBUG		;DEBUGGING SO WANT TO SEE FILE OUTPUT
	PUSHJ	P,TTYPU1	;YES, OUTPUT TO TTY TOO
	SOSG	FOBUF+2		;DECREMENT BUFFER COUNTER
	PUSHJ	P,[OUT	FILCHN,	;BUFFER FULL, GIVE TO MONITOR
		   POPJ	P,	;NO ERRORS
		   JRST FILERR]	;FILE ERROR, COMPLAIN AND START OVER
	IDPB	CH,FOBUF+1	;STORE CHAR IN BUFFER
	POPJ	P,		;RETURN
;ROUTINE TO OUTPUT CRLF TO TTY
;CALL:	PUSHJ	P,TCRLF

TCRLF:	MOVEI	CH,C.CR		;CR CHAR
	PUSHJ	P,TTYPUT	;OUTPUT TO TTY
	MOVEI	CH,C.LF		;LINE FEED CHAR
				; FALL INTO TTYPUT ROUTINE

;ROUTINE TO OUTPUT 1 CHAR TO TTY, IF @ SUBSTITUTE CRLF
;CALL:	MOVEI	CH,CHAR
;	PUSHJ	P,TTYPUT
;	RETURN CH PRESERVED

TTYPUT:	CAIN	CH,"@"		;IS THIS THE CRLF CHAR?
	PJRST	TCRLF		;YES, OUTPUT CRLF ON TTY AND RETURN
	SKIPE	DEBUG		;NO, ARE WE DEBUGGING?
	TLZN	F,(F.TF)	;YES, IS THIS FIRST CHAR ON TTY AFTER FIL?
	JRST	TTYPU1		;NO, OK TO OUTPUT
	PUSH	P,CH		;YES, SAVE REAL FIRST CHAR
	MOVEI	CH,">"		;AND INDICATE TERMINATION OF FILE OUTPUT
	PUSHJ	P,TTYPU1	;OUTPUT TO TTY
	POP	P,CH		;RESTORE REAL FIRST TTY CHAR

;SUBROUTINE TO REALLY OUTPUT 1 CHAR TO TTY
TTYPU1:	SOSG	TOBUF+2		;ROOM IN THIS OUTPUT BUFFER?
	OUTPUT	TTYCHN,		;NO, SO OUTPUT 
	IDPB	CH,TOBUF+1	;THEN STORE THIS CHAR IN BUFFER
	POPJ	P,		;RETURN

;SUBOURINTE TO FORCE OUT CURRENT BUFFER NOW
;CALL:	PUSHJ	P,TTYNOW

TTYNOW:	OUTPUT	TTYCHN,		;GIVE BUFFER TO MONITOR
	POP	P,(P)		;REMOVE INSTRUCTION FROM STACK
	POPJ	P,		;RETURN
SUBTTL	DATA STORAGE
;VARIABLES:
; THESE ARE STRICTLY INTERNAL TO DIALOG AND ARE NEVER OUTPUT IN FILE
;ONES NOT CLEARED IN MAIN LOOP, INSTEAD SET TO INITIAL VALUES ONLY ON GET.
; THUS ^C START DOES NOT INITIALIZE:


HELPF:	-1		;FLAG TO TYPE /HELP ONLY ONCE THRU LOOP OR START
DEBUG:	0		;PATCH NON-ZERO TO DEBUG BY HAVING FIL OUTPUT TO TTY TOO
			; COME OUT ON TTY INSIDE <>
SAVLV:	0		;CURRENT PERMANENT VERBOSICITY LEVEL FOR ASKING QUESTIONS
			; AC LV MAY BE DIFFERENT IF USER HAS CHANGED
			; LEVEL FOR THIS QUESTION ONLY
			; LEVELS ARE -1 FOR SHORT, 0 FOR PROMPT,
			; AND 1 OR GREATER FOR LONG
			; INITIALLY SET TO PROMPT ON A GET
FHNAME:	SIXBIT	.FGEN.	;LOOKUP BLOCK FOR FGEN AUXILIARY HELP FILE
	SIXBIT	.HLP.
	0
	0

RUNDEV:	BLOCK	1	;DEVICE FROM RUN OR GET
RUNPPN:	BLOCK	1	;DIRECTORY FROM RUN OR GET
FGPPN:	BLOCK	1	;DIRECTORY TO USE FOR HELP FILE

;VARIABLES CLEARED EACH TIME THROUGH MAIN LOOP FOR A NEW GEN:

VARBEG:			;FIRST LOC CLEARED ON MAIN LOOP
PDLIST:	BLOCK	DP.PDL+1	;PD LIST
ASKTAB:	BLOCK	DP.AMX+1	;TABLE TO STOR POSSIBLE ANSWERS
				; SETUP BY ASKLST WITH PROMPTING INSIDE ()
				; LAST ENTRY MUST BE ZERO AS FLAG OF END
				; FIRST ENTRY MAYBE 0 TO MEAN NO DEFAULT
				; IE (,ANS0,ANS1,...)
ASCSTR:	BLOCK	<DP.LMX+4+1>/5	;STRING FOR TTY INPUT LINE(SEE TTYIN)
			; ENOUGH ROOM FOR DP.LMX CHAR, PLUS NULL
SAVN:	BLOCK	1	;PLACE TO SAVE MATCH INDEX IN ASKLST SUB
MINLIM:	BLOCK	1	;MIN VALUE FOR ASK QUESTION.  SET BY NOS. INSIDE ()
			; WHICH PRECED A DASH.
MAXLIM:	BLOCK	1	;MAX VALUE FOR ASK QUESTION.  SET BY NOS. INSIDE
			; WHICH FOLLOW A DASH.
DFAULT:	BLOCK	1	;DEFAULT FOUND FIRST INSIDE () IN ASK QUESTION
			; BY SETLST ROUTINE
;FILE 4 WORD ENTER BLOCK:
OUTNAM:	BLOCK	1	;FILE NAME
OUTEXT:	BLOCK	1	;FILE EXTENSION
OUTDAT:	BLOCK	1	;FILE DATE
OUTPPN:	BLOCK	1	;FILE PROJECT, PROGRAMMER NUMBER
SAVPPN:	BLOCK	1	;SAVE PPN FOR MESSAGE AFTER ENTER
;BUFFER HEADERS:
TIBUF:	BLOCK	3	;TTY INPUT BUFFER HEADER
TOBUF:	BLOCK	3	;TTY OUTPUT BUFFER HEADER
FOBUF:	BLOCK	3	;FILE OUTPUT BUFFER HEADER
FHIBUF:	BLOCK	3	;FGEN AUXILIARY HELP FILE INPUT BUFFER HEADER

;BUFFERS
FILBUF:	BLOCK	NFILBF*203	;BUFFERS FOR OUTPUT FILE
FHLPBF:	BLOCK	NFHLPBF*203	;BUFFERS FOR FHELP FILE

;POINTERS TO FGEN SWITCH TABLE
FTTAB:	BLOCK	1	;POINTER TO TABLE READ FROM FILE
FTLEN:	BLOCK	1	;MINUS LENGTH OF WHOLE TABLE
	END
    )vf