! TIO -- TIO DRIVER ROUTINE (MAIN)

LOCAL TMP ! ALWAYS ASSUMED TO HAVE VALUE OF ZERO INIT (FOR GE-TOKEN)

FIND JOBSA, JOBDDT, JOBVER, JOBREN


GLOBAL ALTMOD:, %NXCMD, %CMDEXU, BEGIN:, PRMBUF(0:4), DOCMD:, DEBSW, ESW
GLOBAL ALTRET:, ALTDDT:, %LISOUT

GLOBAL TABLE ERRTAB (1:14) ['TOO MANY FILES OPEN **SYSTEM ERROR**',&
'BAD MODE **SYSTEM ERROR**',&
'ILLEGAL FILE NAME SPECIFICATION',&
'FILE OPEN NOT CONFIRMED PROPERLY',&
'FILE NOT FOUND',&
'INVALID USER NAME',&
'PROTECTION VIOLATION',&
'FILE BUSY',&
'SYSTEM ERROR',&
'END-OF-FILE **SYSTEM ERROR**',&
'LINE TOO LONG',&
'ILLEGAL OPERATION ON THE TELETYPE',&
'SYSTEM ERROR',&
'MONITOR OUT OF CORE']

DEF TRMASK AS OCT 770000.000000
DEF LCMASK AS OCT 770000.000000

DEF TYPE.A AS OCT 4340.440000
DEF  LCH.A AS OCT 2200.000000
DEF TYPE.B AS OCT 5024.226002
DEF  LCH.B AS OCT 2031.000000
DEF TYPE.C AS OCT 7400.444004
DEF  LCH.C AS OCT 2000.000000
DEF TYPE.D AS OCT 4400.000000
DEF  LCH.D AS OCT 2000.000000
DEF TYPE.E AS OCT 4724.444306
DEF  LCH.E AS OCT 2020.000000
DEF TYPE.F AS OCT 7400.244004
DEF  LCH.F AS OCT 2000.000000
DEF TYPE.G AS OCT 7424.442252
DEF  LCH.G AS OCT    0.000000
DEF TYPE.I AS OCT 4752.440245
DEF  LCH.I AS OCT 2020.000000
DEF TYPE.J AS OCT 5024.236002
DEF  LCH.J AS OCT 2031.000000
DEF TYPE.N AS OCT 4724.244146
DEF  LCH.N AS OCT 2020.000000

TABLE ONOFF(0:3) [&
! 0! 'HELP',&
! 1! 'OFF',&
! 2! 'ON',&
! 3! 0]

TABLE PARA(0:8) [1,2,4,8,16,32,64,128,-1]

TABLE PARC(0:17) [0,1,2,3,4,5,7,10,14,19,26,36,50,69,96,131,-1]

TABLE BAUDRATE (0:7) [110,150,300,400,600,1200,-1]

TABLE BAUDWRD (0:20) [&
! 0! 'HELP',&
! 1! 'A',&
! 2! 'B',&
! 3! 'C',&
! 4! 'D',&
! 5! 'E',&
! 6! 'F',&
! 7! 'G',&
! 8! 'J',&
! 9! 'N',&
!10! 'I',&
!11! 0]

TABLE LCHTAB(0:11) [0, LCH.A, LCH.B, LCH.C, LCH.D, LCH.E,&
        LCH.F, LCH.G, LCH.J, LCH.N, LCH.I]

TABLE BAUDTAB(0:11) [0, TYPE.A, TYPE.B, TYPE.C, TYPE.D, TYPE.E,&
        TYPE.F, TYPE.G, TYPE.J, TYPE.N, TYPE.I]

TABLE HLP(0:2) [&
! 0! 'HELP',&
! 1! 0]

TABLE PARWRD(0:5) [&
! 0! 'HELP',&
! 1! 'ON',&
! 2! 'EVEN',&
! 3! 'OFF',&
! 4! 'NONE',&
! 5! 0]

TABLE LFCRWRD(0:3) [&
! 0! 'HELP',&
! 1! 'LF',&
! 2! 'CR',&
! 3! 0]

TABLE CMDWRD(0:36) [&
! 0! 'HELP',&
! 1! 'DDT',&
! 2! 'LIST',&
! 3! 'QUIT',&
! 4! 'CREDITS',&
! 5! 'CHARGES',&
! 6! 'INSTRUCTIONS',&
! 7! 'CAPABILITIES',&
! 8! 'VERSION',&
! 9! 'DELAY',&
!10! 'INPUT',&
!11! 'OUTPUT',&
!12! 'PARITY',&
!13! 'HALFDUPLEX',&
!14! 'HDX',&
!15! 'FULLDUPLEX',&
!16! 'FDX',&
!17! 'PARAMETERS',&
!18! 'A',&
!19! 'B',&
!20! 'C',&
!21! 'XON',&
!22! 'LF',&
!23! 'TAB',&
!24! 'WIDTH',&
!25! 'LC',&
!26! 'FORM',&
!27! 'CRLF',&
!28! 'FFILL',&
!29! 'TABFILL',&
!30! 'FILLER',&
!31! 'TIC',&
!32! 'ID',&
!33! 'EXPLAIN',&
!34! 'TERMINAL',&
!35! 'SAVE',&
!36! 0]

TABLE TERMINAL (0:30) [&
! 0! 'HELP',&
! 1! 'CRT',&
! 2! 'TTY37',&
! 3! 'TYM310',&
! 4! 'TYM311',&
! 5! 'DCT500',&
! 6! 'TTY33',&
! 7! 'TTY35',&
! 8! 'TYM200',&
! 9! 'TYM201',&
!10! 'TYM100',&
!11! 'TYM211',&
!12! 'TYM221',&
!13! 'TI725',&
!14! 'NCR260',&
!15! 'EXECUPORT',&
!16! 'UNIVAC',&
!17! 'MEMOREX',&
!18! 'TERMINET360',&
!19! 'TYM212',&
!20! 'TYM213',&
!21! 'TYM110',&
!22! 'TI733',&
!23! 'TI735',&
!24! 0]

DEF LISLOW AS 4 ! LOWEST TOKEN FOR IMPLIED 'LIST'
DEF LISHGH AS 8 ! HIGHEST TOKEN FOR IMPLIED 'LIST'

TABLE LISWRD(0:28) [&
! 0! 'HELP',&
! 1! 'CREDITS',&
! 2! 'CHARGES',&
! 3! 'INSTRUCTIONS',&
! 4! 'CAPABILITIES',&
! 5! 'VERSION',&
! 6! 'ALL',&
! 7! 'ID',&
! 8! 'FILLER',&
! 9! 'PARAMETERS',&
!10! 'A',&
!11! 'B',&
!12! 'C',&
!13! 'INPUT',&
!14! 'OUTPUT',&
!15! 'DUPLEX',&
!16! 'PARITY',&
!17! 'LF',&
!18! 'XON',&
!19! 'WIDTH',&
!20! 'TAB',&
!21! 'LC',&
!22! 'FORM',&
!23! 'CRLF',&
!24! 'FFILL',&
!25! 'TABFILL',&
!26! 'TIC',&
!27! 'DELAY',&
!28! 0]

BEGIN:  OFFALT                          ! TURN OFF ALL INTERRUPTS
        CMD.NO _ 1                      ! INITIAL PROMPT NUMBER
        IOCS(14*2)                      ! SET UP IOCS (2 BUF/CHAN)
        TERMCH_CAR.RET                  ! TURN OFF COMPLAINER

! DONE WITH INITIAL VARIABLE SETTING, SO,
! TYPE HOWDY MESSAGE
        MSG('$TIO - VERSION '); NUMOUT(LH(@JOBVER),10)
        PUT($.); IF RH(@JOBVER) < 10 THEN PUT($0)
        NUMOUT(RH(@JOBVER),10)
        IF RH(@JOBDDT) # 0 THEN MSG('$LOADED WITH DDT') ! IF DDT HERE, SAY SO
        PUT(CAR.RET)

! THIS IS THE MAIN COMMAND LOOP
! INTERRUPTS ARE ENABLED BEFORE A COMMAND WORD IS ACCEPTED AND IS
! DISABLED AFTER THE COMMAND EXECUTER (NXCMD) IS CALLED.
! NXCMD WILL DISABLE INTERRUPTS AFTER IT HAS DONE SOME PART OF THE
! COMMAND SUCH THAT AN ESCAPE WOULD BE FOOLISH (I.E., NON-EXECUTABLE)

DOCMD:  LOOP DO

! THIS IS THE COMPLAINER. TYPES OUT ANYTHING THAT WAS NOT SCANNED
! ON THE LAST COMMAND EXECUTE.  (IE, WHEN COMMAND SCANNER
! BECOMES SLOPPY)

        IF TERMCH # CAR.RET THEN DO ! EXTRA TEXT
          MSG('$$"')
          WHILE CHAR_NCHV POINTER#CAR.RET AND CHAR#E.O.LIT THEN PUT(CHAR)
          MSG('"$IS EXTRA AND HAS BEEN IGNORED.$')
          END

        ALTLOC _ ALTMOD ! SET ALTMOD CONTROL
        ONALT.C; IF NXCMD = TRUE THEN INC CMD.NO.
        OFF.ALT

        END ! OF THE COMMAND LOOP DO (DOCMD:)

ALTMOD: IF ESW = TRUE AND RH(@JOBDDT) # 0 THEN DO
          ALTLOC_ALTDDT; JOBSA _ DOCMD; MSG('$DDT$'); GO ^RH(@JOBDDT)
ALTDDT: MSG('$ESC FROM DDT: BREAKPOINTS NOT SET!$')
          END
ALTRET: ALTLOC_ALTMOD
         !ESCAPE HERE! OFF.ALT
          IF DEBSW=FALSE=ESW THEN DO
            CLOBUF; CLIBUF
            END

        MSG('$$(ESC)$')
        TERMCH _ CAR.RET ! TURN OFF COMPLAINER
        POINTER _ CHPT(@PRMBUF(4),-1) !NO MORE INPUT,CLEAR IMAGE LINE!
! FINISHED ESCAPE PROCESSING
        GO DOCMD

! *** PROCEDURE NXCMD *** !
! THIS IS THE COMMAND DISPATCHER
! NO ARGUMENTS
! RETURNS TRUE IF OKAY COMMAND ELSE FALSE
%NXCMD

LOCAL TMP.1

        TMP _ 0 ! MAKE SURE TMP HAS A ZERO, FOR GETOKEN
        TMP.1 _ POINTX(PRMBUF); NCHV TMP.1 _ $$
        INSC(CMD.NO,@TMP.1,10)
        CHV TMP.1 _ $:; NCHV TMP.1 _ $ ; NCHV TMP.1 _ E.O.LIT
        TMP.1 _ 0; POINTER _ CHPT(@PRMBUF(4),-1) ! NULL POINTER OUT!
        TMP.1 _ GETOKEN (@TMP,CMDWRD,FALSE,FALSE,'MQUMES','MHLMES',@PRMBUF(0))
        IF TMP.1 # RESWRD THEN DO

! BAD CMD WRD

          EIF TMP.1 = BADRES THEN DO
            MSG('$COMMAND NOT RECOGNIZED$')
            YELLOWBALL; CLIBUF
            END
          ORIF GTYPE = DELIMT AND TERMCH = CAR.RET THEN NULL
          ELSE GIVEUP ! DO ERROR PROCESSING
          TERMCH _ CAR.RET ! TURN OFF COMPLAINER
          RETURN FALSE
          END

! GOOD COMMAND WORD
        IF (LISLOW <= TOKEN <= LISHGH) THEN DO
          TERMCH _ $ ; POINTER _ LASTOK; TOKEN _ 2
          END
        RETURN CMDEXU(TOKEN) ! EXECUTE COMMAND

END NXCMD

! *** PROCEDURE CMDEXU *** !
! ARG:1 IS THE COMMAND NUMBER FROM CMDWRD
! RETURNS 'TRUE' TO INCREMENT PROMPT,
! FALSE OTHERWISE
%CMDEXU(ARG.1)

LOCAL SAVFIDTBL(0:20) ! FOR SAVE COMMAND - FID TABLE
LOCAL TMP.1, TMP.2, TMP.3, TMP.4, TMP.5, TMP.6, TMP.7, TMP.8 ! TEMP VARIABLES
LOCAL SAVOERR: ! SAVE COMMAND OPEN ERROR LOC.

        TMP_0 ! TMP ALWAYS ASSUMED TO HAVE ZERO

        DO ARG.1 OF 1:40

1:      !DDT! IF (DEBSW=TRUE OR ESW=TRUE) AND RH(@JOBDDT) # 0 THEN DO
          INC CMD.NO
          ALTLOC _ ALTDDT
          JOBSA _ DOCMD
          MSG('$DDT$'); GO ^RH(@JOBDDT)
          END
        GIVEIN

2:      !LIST! IF GETOKEN(@TMP,LISWRD,FALSE,FALSE,'?.LIST','HELP.LIST','$OPTION: ') # RESWRD THEN GIVEUP
        DO TOKEN OF 1:27

        1: MSG('WRITTEN BY TYMSHARE$'); RETURN FALSE
        2: MSG('NO PREMIUM CHARGE$'); RETURN FALSE
        3: INFORMATION('INSTXT'); RETURN FALSE
        4: INFORMATION('CAPTXT'); RETURN FALSE
        5: MSG('VERSION '); NUMOUT(LH(@JOBVER),10); PUT($.)
            IF LH(@JOBVER) < 10 THEN PUT($0)
            NUMOUT(RH(@JOBVER),10); PUT(CAR.RET); RETURN FALSE

        6: !ALL! FOR TMP.1 _ 10 TO 27 BY 1 LISOUT(TMP.1)
          RETURN FALSE
        7:8:9:10:11:12:13:14:15:16:17:18:19:20:21:22:23:24:25:26:27: LISOUT(TOKEN)
          RETURN FALSE
        END

        GIVEIN

3:      !QUIT! CLOSE.ALL; MSG('$E.O.J.$'); EXIT; HALT

LISHGH+1: !DELAY! IF GETOKEN(@TMP,LFCRWRD,FALSE,FALSE,'?.DELAY','HELP.DELAY','$DELAY AFTER LF OR CR? ')&
        # RESWRD THEN GIVEUP
        AUXCAL(OCT 14,(IF TOKEN=1 !LF! THEN 0 ELSE -1)) !SET DELAY
        RETURN TRUE

LISHGH+2: !INPUT! IF GETOKEN(@TMP,HLP,TRUE,FALSE,'?.INPUT','HELP.INPUT','$INPUT BAUD RATE? ')&
        # NUMBER THEN GIVEUP
        TMP.1 _ -1
        LOOP WHILE BAUDRATE(INC TMP.1) # -1 AND BAUDRATE(TMP.1)#TOKEN
        IF BAUDRATE(TMP.1) = -1 THEN GIVEUP
        AUXCAL(OCT 15,TMP.1) ! SET INPUT RATE
        RETURN TRUE

LISHGH+3: !OUTPUT! IF GETOKEN(@TMP,HLP,TRUE,FALSE,'?.OUTPUT','HELP.OUTPUT','$OUTPUT BAUD RATE? ')&
        # NUMBER THEN GIVEUP
        TMP.1 _ -1
        LOOP WHILE BAUDRATE(INC TMP.1) # -1 AND BAUDRATE(TMP.1) # TOKEN
        IF BAUDRATE(TMP.1) = -1 THEN GIVEUP
        AUXCAL(OCT 16,TMP.1) ! SET OUTPUT RATE
        RETURN TRUE

LISHGH+4: !PARITY! IF GETOKEN(@TMP, PARWRD,FALSE,FALSE,'?.PARITY','HELP.PARITY','$PARITY? ')&
        # RESWRD THEN GIVEUP
        AUXCAL(OCT 17, IF (TOKEN=1 OR TOKEN=2) THEN TRUE ELSE FALSE)
        RETURN TRUE

LISHGH+5:LISHGH+6: !HALF-DUPLEX! AUXCAL(OCT 20,-1) ! HALF-DUPLEX
        RETURN TRUE

LISHGH+7:LISHGH+8: !FULL-DUPLEX! AUXCAL(OCT 20,0) ! FULL-DUPLEX
        RETURN TRUE

LISHGH+9: !PARAMETERS! GETOKEN(@TMP, HLP,TRUE,FALSE,'?.PARAM','HELP.PARAM','$A TO: ')
        IF GTYPE # NUMBER THEN GIVEUP
        TMP.1 _ -1
        LOOP WHILE PARA(INC TMP.1) # -1 AND PARA(TMP.1) # TOKEN
        IF PARA(TMP.1) = -1 THEN GIVEUP
        GETOKEN(@TMP, HLP,TRUE,FALSE,'?.PARAM1','HELP.PARAM1','$B TO: ')
        IF GTYPE # NUMBER OR (NOT (0<= TOKEN <=7)) THEN GIVEUP
        TMP.2 _ TOKEN ! TMP.2 = PARAMETER 'B'
        GETOKEN(@TMP, HLP,TRUE,FALSE,'?.PARAM2','HELP.PARAM2','$C TO: ')
        IF GTYPE # NUMBER THEN GIVEUP
        TMP.3 _ -1
        LOOP WHILE PARC(INC TMP.3) # -1 AND PARC(TMP.3) # TOKEN
        IF PARC(TMP.3) = -1 THEN GIVEUP
        AUXCAL(OCT 21,TMP.1); AUXCAL(OCT 22,TMP.2); AUXCAL(OCT 23,TMP.3)
        RETURN TRUE

LISHGH+10: !A! IF GETOKEN(@TMP, HLP, TRUE, FALSE, '?.A','HELP.A','$A TO: ')&
        # NUMBER THEN GIVEUP
        TMP.1 _ -1
        LOOP WHILE PARA(INC TMP.1) # -1 AND PARA(TMP.1) # TOKEN
        IF PARA(TMP.1) = -1 THEN GIVEUP
        AUXCAL(OCT 21,TMP.1)
        RETURN TRUE

LISHGH+11: !B! IF GETOKEN(@TMP, HLP, TRUE, FALSE, '?.B','HELP.B','$B TO: ')&
        # NUMBER THEN GIVEUP
        IF NOT(0 <= TOKEN <=7) THEN GIVEUP
        AUXCAL(OCT 22, TOKEN)
        RETURN TRUE

LISHGH+12: !C! IF GETOKEN(@TMP, HLP, TRUE, FALSE, '?.C','HELP.C','$C TO:')&
        # NUMBER THEN GIVEUP
        TMP.1 _ -1
        LOOP WHILE PARC(INC TMP.1) # -1 AND PARC(TMP.1) # TOKEN
        IF PARC(TMP.1) = -1 THEN GIVEUP
        AUXCAL(OCT 23, TMP.1)
        RETURN TRUE

LISHGH+13: !XON! IF GETOKEN(@TMP, ONOFF, FALSE, FALSE, '?.XON','HELP.XON','$XON WHEN NECESSARY? (ON OR OFF) ')&
        # RESWRD THEN GIVEUP
        AUXCAL(OCT 24,(IF TOKEN=1 !OFF! THEN -1 ELSE 0))
        RETURN TRUE

LISHGH+14: !LF! IF GETOKEN(@TMP, ONOFF, FALSE, FALSE, '?.LF','HELP.LF','$ASSUME LF AFTER CR? (ON OR OFF) ')&
        # RESWRD THEN GIVEUP
        SETLCH(OCT 2.000000,(IF TOKEN=1 !OFF! THEN TRUE ELSE FALSE))
        RETURN TRUE

LISHGH+15: !TAB! IF GETOKEN(@TMP, ONOFF, FALSE, FALSE, '?.TAB','HELP.TAB','$EXPAND TAB ON INPUT? (ON OR OFF) ')&
        # RESWRD THEN GIVEUP
        SETLCH(OCT 10.000000,(IF TOKEN = 1 !OFF! THEN TRUE ELSE FALSE))
        RETURN TRUE

LISHGH+16: !WIDTH! IF GETOKEN(@TMP, HLP, TRUE, FALSE, '?.WIDTH','HELP.WIDTH','$WIDTH OF TERMINAL (CHARS): ')&
        # NUMBER THEN GIVEUP
        IF NOT (17 <= TOKEN <= 200) THEN GIVEUP
        AUXCAL(OCT 27,TOKEN)
        RETURN TRUE

LISHGH+17: !LC! IF GETOKEN(@TMP, ONOFF, FALSE, FALSE, '?.LC', 'HELP.LC', '$LOWER CASE ACCEPTED? (ON OR OFF) ')&
        # RESWRD THEN GIVEUP
        SETLCH(OCT 20.000000,(IF TOKEN = 1 !OFF! THEN FALSE ELSE TRUE))
        RETURN TRUE

LISHGH+18: !FORM! IF GETOKEN(@TMP, ONOFF, FALSE, FALSE, '?.FORM', 'HELP.FORM','$EXPAND FORM FEED ON OUTPUT? (ON OR OFF) ')&
        # RESWRD THEN GIVEUP
        SETLCH(OCT 1.000000,(IF TOKEN=1 !OFF! THEN TRUE ELSE FALSE))
        RETURN TRUE

LISHGH+19: !CRLF! IF GETOKEN(@TMP, ONOFF, FALSE, FALSE, '?.CRLF', 'HELP.CRLF', '$TYPE CRLF ON TTY WIDTH OVERFLOW? (ON OR OFF) ')&
        # RESWRD THEN GIVEUP
        SETLCH(OCT 200.000000,(IF TOKEN=1 !OFF! THEN TRUE ELSE FALSE))
        RETURN TRUE

LISHGH+20: !FFILL! IF GETOKEN(@TMP, HLP, TRUE, FALSE, '?.FFILL', 'HELP.FFILL', '$FORM FEED FILLER COUNT TO: ')&
        # NUMBER THEN GIVEUP
        IF NOT (0 <= TOKEN <= 3) THEN GIVEUP
        AUXCAL(OCT 30, TOKEN)
        RETURN TRUE

LISHGH+21: !TABFILL! IF GETOKEN(@TMP, HLP, TRUE, FALSE, '?.TABFILL', 'HELP.TABFILL', '$TAB FILLER COUNT TO: ')&
        # NUMBER THEN GIVEUP
        IF NOT(0 <= TOKEN <=3) THEN GIVEUP
        AUXCAL(OCT 31, TOKEN)
        RETURN TRUE

LISHGH+22: !FILLER! IF GETOKEN(@TMP, HLP, TRUE, FALSE, '?.FILLER', 'HELP.FILLER', '$TAB AND FORM FEED FILLER COUNT TO: ')&
        # NUMBER THEN GIVEUP
        IF NOT(0 <= TOKEN <= 3) THEN GIVEUP
        AUXCAL(OCT 30, TOKEN); AUXCAL(OCT 31, TOKEN)
        RETURN TRUE

LISHGH+23:LISHGH+24: !TIC!!ID!  GETOKEN(@TMP, BAUDWRD, TRUE, FALSE, '?.TIC','HELP.TIC','$PARAMETERS: ')
        TMP.7 _ TMP.8 _ 0 ! LCH BITS TO BE SET (7=BITS,8=MASK)
        EIF GTYPE = RESWRD THEN DO
          TMP.2 _ BAUDTAB(TOKEN)
          TMP.8 _ (IF TERMCH # CAR.RET THEN OCT 20.000000 ELSE OCT 2233.000000)
          TMP.7 _ LCHTAB(TOKEN) BAND TMP.8
          END
        ORIF GTYPE = NUMBER THEN DO
          TMP.2 _ -1
          LOOP WHILE BAUDRATE(INC TMP.2) # -1 AND BAUDRATE(TMP.2) # TOKEN
          IF BAUDRATE(TMP.2) = -1 THEN GIVEUP
          TMP.2 _ ( (TMP.2 SHL 13) BAND OCT 160000) BOR ( (TMP.2 SHL 16) BAND OCT 1.600000)
          TMP.8 _ (IF TERMCH # CAR.RET THEN OCT 20.000000 ELSE OCT 2233.000000)
          TMP.7 _ GETLCH BAND TMP.8
          END
        ELSE GIVEUP
        IF TERMCH # CAR.RET THEN DO
! C.R. NOT TERMINATING, GET ANOTHER PAIR
          GETOKEN(@TMP, BAUDWRD, TRUE, FALSE, '?.TIC1', 'HELP.TIC1', '$OUTPUT PARAMETER: ')
          EIF GTYPE = RESWRD THEN DO
            TMP.3 _ BAUDTAB(TOKEN)
            TMP.8 _ OCT 2233.000000
            TMP.7 BOR _ (LCHTAB(TOKEN) BAND OCT 2213.000000)
            END
          ORIF GTYPE = NUMBER THEN DO
            TMP.3 _ -1
            LOOP WHILE BAUDRATE(INC TMP.3) # -1 AND BAUDRATE(TMP.3) # TOKEN
            IF BAUDRATE(TMP.3) = -1 THEN GIVEUP
            TMP.3 _ ( (TMP.3 SHL 13) BAND OCT 160000) BOR ( (TMP.3 SHL 16) BAND OCT 1.600000)
            TMP.8 _ OCT 2233.000000
            TMP.7 BOR _ (GETLCH BAND OCT 2213.000000)
            END
         ELSE GIVEUP
! AT THIS POINT, TMP.2 CONTAINS THE INPUT PARAMETERS,
! AND TMP.3 CONTAINS THE OUTPUT PARAMETERS; SO, MERGE THE
! INPUT STUFF TO HERE
          TMP.2 _ (TMP.3 BAND OCT 777776.177777) BOR (TMP.2 BAND OCT 1.600000)
          END

! NOW, TMP.2 = PARAMETERS
        SETTMC(TMP.2, (IF TMP.2 BAND OCT 777776.000000 = 0 THEN OCT 777776.000000 ELSE TRMASK))
        LCHSET(TMP.7,BNOT TMP.8) ! SET LINE AND TERMINAL CHARACTERISTICS
        RETURN TRUE

LISHGH+25: !EXPLAIN! GETOKEN(@TMP, CMDWRD, TRUE, FALSE, '?.EXPLAIN','HELP.EXPLAIN','$COMMAND NAME? ')
        EIF GTYPE = RESWRD THEN INFORMATION(CMDWRD(TOKEN))
        ORIF GTYPE = NUMBER THEN INFORMATION('WHATS.A.NUMBER')
        ORIF GTYPE = DELIMT THEN INFORMATION('WHATS.A.DELIMETER')
        ELSE GIVEUP
        RETURN FALSE

LISHGH+26: !TERMINAL! IF GETOKEN(@TMP, TERMINAL, FALSE, FALSE, '?.TERMINAL', 'HELP.TERMINAL', '$WHAT TYPE OF TERMINAL DO YOU HAVE? ')&
        # RESWRD THEN GIVEUP
        DO TOKEN OF 1:30
        1: !CRT! SETTMC(TYPE.A,TRMASK); LCHSET(LCH.A,LCMASK)
        2: !TTY37! SETTMC(TYPE.B,TRMASK); LCHSET(LCH.B,LCMASK)
        3:4:5: !TYM310,TYM311,DCT500! SETTMC(TYPE.C,TRMASK); LCHSET(LCH.B,LCMASK)
        6:7:8:9: !TTY33,TTY35,TYM200,TYM201! SETTMC(TYPE.D,TRMASK); LCHSET(LCH.D,LCMASK)
        10:11:12:13:14:15: !TYM100,TYM211,TYM221,TI725,NCR260,EXECUPORT! SETTMC(TYPE.E,TRMASK); LCHSET(LCH.E,LCMASK)
        16: !UNIVAC! SETTMC(TYPE.F,TRMASK); LCHSET(LCH.F,LCMASK)
        17:18: !MEMOREX,TERMINET360! SETTMC(TYPE.G,TRMASK); LCHSET(LCH.G,LCMASK)
        19:20:21:22:23: !TYM212,TYM213,TYM110,TI733,TI735! SETTMC(TYPE.I,TRMASK); LCHSET(LCH.I,LCMASK)
        END
        RETURN TRUE

LISHGH+27: !SAVE! IF TERMCH = CAR.RET THEN DO
          MSG('$TO FILE: '); POINTER _ NXLIN ! GET FNAME
          END
        TMP.1 _ TMP.2 _ POINTX(TOKBUF) ! POINTER TO TOKEN BUFFER
        COPYSTRING(POINTER,@TMP.1) ! COPY TO NEW LOCATION
        POINTER _ CHPT(''); TERMCH _CAR.RET ! TURN OFF COMPLAINER
        NCHV TMP.1 _ E.O.LIT !0TERMINATE FILE NAME
        SETFID(SAVFIDTBL,@TMP.2,OCT 634166.000000,SAVOERR)
        TMP.2 _ OPEN(-SAVFIDTBL,OUTMSG+DIRECT+WORD,SAVOERR,1)
!NOW, WRITE THE FOLLOWING PROGRAM:
!L0:    MOVE    L6
!L1:    SETTMC
!L2:    MOVE    L7
!L3:    SETLCH
!L4:    EXIT    1,
!L5:    JRST    L4
!L6:    0
!L7:    0
! THIS IS A CHEAT WAY, BUT ESSENTIALLY A 'SAVE' FILE IS REPRODUCED
! WITH THE LOCATIONS L6 AND L7 GIMMICKED TO THE CORRECT VALUES.
DEF OUTSAVE(VAL) AS WX(TMP.2,OCT VAL)
        OUTSAVE(777775.000117); OUTSAVE(000150.000140)
        OUTSAVE(000000.000150); OUTSAVE(254200.000000)
        OUTSAVE(777777.000132); OUTSAVE(000146.001777)
        OUTSAVE(777770.000137); OUTSAVE(200000.000146)
        OUTSAVE(047000.777763); OUTSAVE(200000.000147)
        OUTSAVE(051340.000000); OUTSAVE(047040.000012)
        OUTSAVE(254000.000144)
        WX(TMP.2,GETTMC); WX(TMP.2,GETLCH)
        OUTSAVE(254000.000140); OUTSAVE(0)
        CLOSE(TMP.2)
        RETURN TRUE

SAVOERR: PUT(CAR.RET); MSG(ERRTAB(ERRNUM)); PUT(CAR.RET)
        RETURN FALSE

        END ! NEW COMMANDS BEFORE THIS 'END'

END CMDEXU

! PROCEDURE: LISOUT
 A NUMBER (AS PER LISWRD) TO LIST DATA FROM
%LISOUT(WRD)

LOCAL TMP.1, TMP.2

        DO WRD OF 7:27

        8: !FILLER! MSG('FORM FEED FILLER COUNT = '); NUMOUT( (GETTMC SHR 21) BAND OCT 3,10); PUT(CAR.RET)
          MSG('TAB FILLER COUNT = '); NUMOUT ( (GETTMC SHR 19) BAND OCT 3,10); PUT(CAR.RET)
        9: !PARAMETERS! TMP.1 _ GETTMC
        MSG('A = '); NUMOUT(PARA((TMP.1 SHR 9) BAND OCT 7),10); PUT(CAR.RET)
        MSG('B = '); NUMOUT((TMP.1 SHR 5) BAND OCT 7,8); PUT(CAR.RET)
        MSG('C = '); NUMOUT(PARC(TMP.1 BAND OCT 17),10); PUT(CAR.RET)
       10: !A! MSG('A = '); NUMOUT(PARA((GETTMC SHR 9) BAND OCT 7),10); PUT(CAR.RET)
       11: !B! MSG('B = '); NUMOUT((GETTMC SHR 5) BAND OCT 7,8); PUT(CAR.RET)
        12: !C! MSG('C = '); NUMOUT(PARC(GETTMC BAND OCT 17),10); PUT(CAR.RET)
       13: !INPUT! MSG('INPUT BAUD RATE = '); NUMOUT(BAUDRATE((GETTMC SHR 16) BAND OCT 7),10); PUT(CAR.RET)
       14: !OUTPUT! MSG('OUTPUT BAUD RATE = '); NUMOUT(BAUDRATE((GETTMC SHR 13) BAND OCT 7),10); PUT(CAR.RET)
       15: !DUPLEX! IF GETTMC BAND OCT 400 = 0 THEN MSG('FULL DUPLEX OPERATION$') ELSE MSG('HALF DUPLEX OPERATION$')
       16: !PARITY! IF GETTMC BAND OCT 10000 = 0 THEN MSG('NO PARITY SENT$') ELSE MSG('EVEN PARITY SENT$')
       17: !LF! IF GETLCH BAND OCT 2.000000 = 0 THEN MSG('LINE FEED ASSUMED AFTER A CARRIAGE RETURN INPUT$') ELSE MSG('LINE FEED NOT ASSUMED AFTER A CARRIAGE RETURN INPUT$')
       18: !XON! IF GETTMC BAND OCT 40000.000000 = 0 THEN MSG('XON-XOFF SENT AT APPROPRIATE TIMES$') ELSE MSG('XON-XOFF NEVER SENT$')

       19: !WIDTH! MSG('TERMINAL CARRIAGE WIDTH = '); NUMOUT( (GETTMC SHR 23) BAND OCT 377,10); PUT(CAR.RET)
       20: !TAB! IF GETLCH BAND OCT 10.000000 = 0 THEN MSG('TABS EXPANDED WHEN SENT$') ELSE MSG('TABS NOT EXPANDED - SENT WITHOUT TRANSLATION$')
       21: !LC! IF GETLCH BAND OCT 20.000000 = 0 THEN MSG('LOWER CASE CHARACTERS CONVERTED TO UPPER CASE ON INPUT$') ELSE MSG('LOWER CASE CHARACTERS NOT TRANSLATED ON INPUT$')
       22: !FORM! IF GETLCH BAND OCT 1.000000 = 0 THEN MSG('FORM FEEDS EXPANDED WHEN SENT$') ELSE MSG('FORM FEEDS NOT EXPANDED - SENT WITHOUT TRANSLATION$')
       23: !CRLF! IF GETLCH BAND OCT 200.000000 = 0 THEN MSG('CRLF TYPED WHEN TERMINAL CARRIAGE WIDTH OVERFLOW OCCURS$') ELSE MSG('NO CRLF TYPED WHEN TERMINAL CARRIAGE WIDTH OVERFLOW OCCURS$')
       24: !FFILL! MSG('FORM FEED FILLER COUNT = '); NUMOUT( (GETTMC SHR 21) BAND OCT 3,10); PUT(CAR.RET)
       25: !TABFILL! MSG('TAB FILLER COUNT = '); NUMOUT( (GETTMC SHR 19) BAND OCT 3,10); PUT(CAR.RET)
       26: !TIC! NULL
        27: !DELAY!MSG(IF GETLCH BAND OCT 2000.000000 = 0 THEN 'DELAY OCCURS AFTER THE LINE FEED$' ELSE 'DELAY OCCURS AFTER THE CARRAIGE RETURN$')
        END

        RETURN TRUE

END LISOUT

        \\-> BEGIN
    P 
r