TITLE	OPSER - OPERATOR SERVICE PROGRAM - %5(21)

SUBTTL	FRANK NATOLI/DAL/PFC/DAL/JE	3-JUNE-72


;*** COPYRIGHT 1970,1971,1972  DIGITAL EQUIPMENT CORP., MAYNARD MASS. ***


	IFNDEF FTAUTO,<FTAUTO==-1>	;AUTO COMMAND FILE PROCESSOR

	IFNDEF FTTLOG,<FTTLOG==-1>	;LOG OF TELETYPE ACTIVITY
	IFE FTTLOG,<DSKOUT==CPOPJ>	;MAKE NO-OP OF CALLS

	IFNDEF PDLSIZ,<PDLSIZ==40>	;SIZE OF PUSHDOWN LIST
	IFNDEF HGHPTY,<HGHPTY==14>	;NBR OF SUBJOBS MINUS ONE
	IFNDEF SNOOZT,<SNOOZT==1>	;ST SLEEP TIME WHEN WAITING
	IFNDEF MOSTBF,<MOSTBF==^D30>	;MOST CONSEC BUFFERS FROM PTY
	IFNDEF CHANCE,<CHANCE==3>	;SECS WILL WAIT FOR PTY TO WAKE
	IFNDEF TYPTIM,<TYPTIM==^D45>	;SECS REQUIRED TO TYPE LINE
	IFNDEF MAXCTC,<MAXCTC==4>	;MAX NBR ^C'S TO WAKE JOB
	IFNDEF LINSIZ,<LINSIZ==^D134>	;MAX CHARS/LINE

	IFNDEF DSKSIZ,<DSKSIZ==203>	;ST SIZE OF DISK BUFFER
	IFNDEF PTYSIZ,<PTYSIZ==23>	;ST SIZE OF TTY BUFFER


	NPTLTH==-<HGHPTY+1>




;VERSION NUMBERS
VWHO==:0		;WHO LAST DEITED THIS FILE
VOPSER==:5		;OPSER VERSION NUMBER
VMINOR==:0		;MINOR VERSION NUMBER
VEDIT==:26		;EDIT NUMBER

	LOC	137
	BYTE	(3)VWHO(9)VOPSER(6)VMINOR(18)VEDIT
	RELOC


	TWOSEG				;RE-ENTRANT HISEG
	RELOC 400000			;START HISEG HERE
	OPDEF	HIBER	[CALLI 72]
	OPDEF	WAKE	[CALLI 73]
	OPDEF	SET	[CALLI 75]
	OPDEF	DAEMON	[CALLI 102]
	OPDEF	ATTACH	[CALLI 104]
	OPDEF	FRCUUO	[CALLI 106]
	OPDEF	TRMNO.	[CALLI 115]
	OPDEF	DVRST.	[CALLI 122]
	OPDEF	DVURS.	[CALLI 123]
	OPDEF	MONRET	[EXIT 1,]
	OPDEF	STOPCD	[HALT]
	OPDEF	PJRST	[JRST]
	OPDEF	PJSP	[JSP]


;IO ERROR STATUS BITS

	IOIMPM==400000
	IODERR==200000
	IODTER==100000
	IOBKTL==40000
	IOEOF==20000
;ACCUMULATORS

	F=0		;PROGRAM STATUS BITS
	T1=1		;SCRATCH
	T2=T1+1
	T3=T2+1
	T4=T3+1
	T5=T4+1
	LASU=10		;LAST SUBJOB USED
	W=11		;SUPER TEMP
	MJOB=12		;LOADED WITH JOBSTS ON CALL TO "ISJOB"
	CMD=13		;INPUT WORD
	SJB=14		;SUBJOB REFERENCE
	PT1=15		;BYTE POINTER
	DATA=16		;ASCII CHARACTER REGISTER
	P=17		;PUSHDOWN POINTER



;ASCII CHARACTERS

	CTRLA==1	;^A
	CTRLB==2	;^B
	CTRLC==3	;^C
	EOT==4		;EOT (^D)
	BELL==7		;BELL (^G)
	TAB==11		;HORIZONTAL TAB (^I)
	LF==12		;LINE FEED (^J)
	VT==13		;VERTICAL TAB (^K)
	FF==14		;FORM FEED (^L)
	CR==15		;CARRIAGE RETURN (^M)
	CTRLO==17	;^O
	CTRLZ==32	;^Z
	ALT==33		;STANDARD ALTMODE
	SP==40		;SPACE
	ALT175==175	;OLD 175 ALTMODE
	ALT176==176	;OLD 176 ALTMODE
	DEL==177	;DELETE
;GETTAB TABLES

	JBTSTS==0	;JOB STATUS BITS
	JBTADR==1	;LH=LENGTH-1
	PRJPRG==2	;PROJECT-PROGRAMMER
	JBTPRG==3	;PROGRAM BEING RUN
	JBTSWP==7	;SWAPPING DATA
	TTYTAB==10	;TELETYPE TRANSLATOR TABLE
	CNFTBL==11	;CONFIGURATION DATA
	NSWTBL==12	;NON-SWAPING DATA
	JBTSGN==14	;HIGH SEGMENT TABLE
	STSTBL==25	;SIXBIT NAMES FOR JOB QUEUE CODES
	.GTC0C==55	;START OF LIST OF CDB GETTAB TABLES
	.GTC0V==56
	.GTC1C==57
	.GTC1V==60
	.GTC2C==61
	.GTC2V==62
	.GTC3C==63
	.GTC3V==64
	.GTC4C==65
	.GTC4V==66
	.GTC5C==67
	.GTC5V==70



;BITS IN JBTSTS TABLE

	JWSIZ==5	;SIZE OF WAIT CODE
	JWPOS==^D14	;RIGHTMOST BIT OF CODE

	JRUN==400000	;RUN STATE
	CMWB==200000	;COMMAND WAIT
	CJACCT==100000	;LEVEL C JACCT
	JNA==40000	;JOB NUMBER ASSIGNED
	JERR==20000	;FATAL ERROR - CANNOT CONTINUE
	JSWP==2000	;SWAPPED OUT
	JLOG==4		;JOB LOGGED IN
	JACCT==1	;^C DISABLED
	CLKR==1B18	;JOB HAS A CLOCK REQUEST (USED TO TELL HIBER
			; FROM SLEEP)

;CPU DATA BLOCK ASSIGNMENTS

	CPRUN==36
	CPPHY==5
;CNFTBL ASSIGNMENTS

	SYSNAM==0	;SYSTEM NAME
	DEVOPR==13	;NAME OF CURRENT OPERATOR
	SEGPTR==15	;RH=JOBN
	STATES==17	;STATES WORD
	PTYOFS==22	;LH=NUMBER OF FIRST PTY IN SYSTEM
	OPRLDB==26	;ADDRESS OF THE OPERATORS LINE DATA BLOCK

	SCNSER==1B11	;(STATES) IMAGE SCANNER SERVICE JOBSTS UUO



;NSWTBL ASSGINMENTS

	UPTIME==15	;TIME SINCE SYSTEM WAS LOADED
	SYSKTM==35	;TIME TO END OF THE WORLD

;DEVCHR UUO BITS

	DVOUT==1	;CAN DO INPUT
	DVIN==2		;CAN DO OUTPUT
	DVDIR==4	;HAS A DIRECTORY
	DVAVAL==40	;AVAILABLE

	ASSCON==1B18	;ASSIGNED BY CONSOLE
	ASSPRG==1B19	;ASSIGNED BY PROGRAM

;DAEMON FUNCTIONS

	.CLOCK==2	;ENTER IN CLOCK QUEUE


;SET UUO FUNCTIONS

	SETOPR==10	;CHANGE DEVOPR AND OPRLDB
	.KSYS==11	;STOP TIMESHARING IN A WHILE
	SETRUN==15
	LOGMAX==16
	BATMAX==17
	BATMIN==20

;VALUES FROM SCNSER

	LDBDCH==15	;TTYCHR VALUES
	LDRDSR==44000	;DATASET OR REMOTE
	DDBLDB==14	;OFFSET FROM START OF DDB TO LDB POINTER
	DVCHR==1	;OFFSET FROM START OF DDB TO UNIT NUMBER
;JOB DATA ASSIGNMENTS

	EXTERN .JBSA	;LH=ORIGINAL .JBFF
	EXTERN .JBFF	;DYNAMIC PROGRAM BREAK
	EXTERN .JBREL	;HIGHEST LEGAL ADDRESS
	EXTERN .JBREN	;RE-ENTRY ADDRESS
	.JBVER==:137	;JOB VERSION



;CHANNEL ASSIGNMENTS

	DEFINE GETCHN(SYM)<
	SYM==ZZ
	ZZ==ZZ-1
>
	ZZ==17

IFN FTAUTO,<GETCHN (AUTOC)>	; AND/OR ONE FOR THE AUTO FILE
IFN FTTLOG,<GETCHN (LOGC)>	; AND/OR ONE FOR THE LOG FILE


	IFG HGHPTY-ZZ,<
PRINTX	NOT ENOUGH IO CHANNELS
PRINTX	REASSEMBLE WITH SMALLER VALUE OF "HGHPTY"
	PASS2
	END
>



;SUBJOB STATUS BITS (STORED IN SJBFLG TABLE)

	SHH==1B0	;SILENCE PTY
			; MUST BE SIGN BIT
	DALSHH==1B1	;SILENCE TILL JLOG&INREQ COME ON
	ERONLY==1B2	;ONLY PRINT ERROR LINES
	TSIL==1B3	;PUT EVERYTHING INTO DISK LOG



;HIBERNATE UUO BITS

	IOATV==1B11	;ANY STANDARD IO
	PTYATV==1B12	;PTY IO
	TTLATV==1B13	;TELETYPE LINE ACTIVITY
	TTCATV==1B14	; CHARACTER ACTIVITY

	STHIB==(IOATV!PTYATV!TTLATV)
;JOBSTS UUO BITS

	JSJNA==1B0	;MONITOR JOB NUMBER ASSIGNED
	JSJLOG==1B1	;JOB LOGGED IN (LOGIN DONE, OR LOGOUT BEGUN)
	MONMOD==1B2	;MONITOR COMMAND MODE
	OUTRDY==1B3	;OUTPUT AVAILABLE
	INREQ==1B4	;INPUT REQUEST - PTY IN TI WAIT
	JSACCT==1B5	;^C DISABLED



;FLAG BITS (LH)

	BRK==1B18	;LAST CHARACTER INPUTTED FROM CONSOLE WAS
			; A BREAK CHARACTER - INPUT LINE DONE
			; MUST BE SIGN BIT
	LCR==1B19	;LAST CHAR FROM PTY WAS A CARRIAGE RETURN
	HEADR==1B20	;SET IF A HEADER HAS PEEN PUT ON A MESSAGE
	MSG==1B21	;SET WHEN SENDING TEXT TO SUBJOBS
	CMD1==1B22	;TEST UNIQUENESS OF COMMAND
	AUXQ==1B23	;ANOTHER BIT MEANING QUIET
	REPL==1B24	;LEADING STAR OR EXCLAM TYPED
	PTBSY==1B25	;SOME IO ACTION ON LAST PASS TO IOCHK
	NOREP==1B26	;MONITOR LIED ABOUT PTY HAVING OUTPUT READY
	SBOD==1B27	;SOMEONE RUNNING A JOB
	QUIET==1B28	;DO NOT SEND DATA TO TTY
	FREETB==1B29	;A FREE TAB WAS TYPED BY TABOUT
	WASCOM==CMD1	;LAST CALL TO SUBROUTINE WHATJB WAS TERMINATED
			; BY A COMMA, INDICATING THERE ARE MORE
			; REFERENCES LEFT
	SLEEPR==1B30	;FORCE SLEEP NOT HIBER
	MSH==1B31	;SET WITH MSGLEVEL
	CCLST==1B32	;CCL START
	TIMO1==1B33	;SOMEONE SITTING ON CONSOLE

IFN FTAUTO,<AUTOM==1B34>	;AUTO MODE IN EFFECT
IFE FTAUTO,<AUTOM==0>		;ZERO IF AUTO CODE NOT ASSEMBLED
IFN FTTLOG,<OFILE==1B35>	;LOG FILE OPENED
IFE FTTLOG,<OFILE==0>		;ZERO IF LOG CODE NOT ASSEMBLED

	RENBIT==777777-OFILE
SUBTTL	PROGRAM STARTUP

REEN:	TLZ	F,RENBIT		;ZERO VARIOUS BITS
	JRST	SETUP			;AND REJOIN REGULAR CODE

OPSER:	TDZA	F,F			;ZERO & SKIP
	MOVSI	F,CCLST			;LOAD CCLST,,0

	RESET				;RESET THE WORLD
	SETZM	LOWBEG			;ZERO FIRST LOC OF STORAGE
	MOVE	T1,[LOWBEG,,LOWBEG+1]	;LOAD BLT XWD
	BLT	T1,LOWEND		;BLT ZEROES TO END

	SETZ	T1,			;START WITH ZERO
	MOVE	T2,[PTYOFS,,CNFTBL]	;GET PTYOFS
	GETTAB	T2,			; FROM THE MONITOR
	  JRST	LOOP50			;DON'T KNOW
	HLRZ	T1,T2			;COPY INDEX
	MOVEM	T1,PTY0LN		;STORE PTYOFS
	SOJA	T1,END50		;STORE TCONLN
LOOP50:	GETLCH	T1			;GET CHARACTERISTICS
	TLNE	T1,(1B1)		;SKIP IF NOT CTY
	JRST	END50			;DONE
	MOVEI	T1,1(T1)		;INCR COUNT
	JRST	LOOP50			;KEEP GOING
END50:	HRRZM	T1,TCONLN		;STORE

	MOVEI	T1,REEN			;LOAD RE-ENTRY ADDRESS
	MOVEM	T1,.JBREN		;STORE IN .JBDATA
	MOVEI	T1,WARNTB		;GET INITIAL KSYS POINTER
	MOVEM	T1,WARNTM		;STORE FOR LATER
SETUP:	TLO	F,BRK			;LAST CHAR A BREAK
	MOVE	P,[IOWD PDLSIZ,PDL]	;MAKE PUSHDOWN POINTER
	PUSHJ	P,JIFINI		;COMPUTE JIFFIES PER SECOND
	PUSHJ	P,INTINI		;SET UP FOR CONTROL C INTERCEPT
	SETZ	LASU,			;LAST USED = 0
	SETO	T1,			;PUT -1 IN T1
	WAKE	T1,			;WAKE MYSELF
	  JFCL				;DON'T REALLY CARE
	MOVSI	T1,STHIB		;LOAD STANDARD HIBERNATE CODE
	HIBER	T1,			;STICK IN MONITOR
	  JFCL

	IFN	FTAUTO,<
	TLZN	F,CCLST			;SKIP IF CCL START
	JRST	MAIN			;NOT
	MOVEI	PT1,PACF		;POINT TO AUTO MESSAGES
	PUSHJ	P,MOUT			;STICK IN OUTPUT BUFFER
	MOVSI	T1,'SYS'		;LOAD INPUT DEVICE
	GETLIN	T2,			;LOAD TTY NAME
	MOVE	T3,[DEVOPR,,CNFTBL]	;GET THE NAME OF OPR
	GETTAB	T3,			; FROM THE MONITOR
	  JRST	LOCAL			;SHOULD NEVER HAPPEN
	CAMN	T2,T3			;ARE WE DEVOPR?
	MOVSI	T2,'OPR'		;YES--USE OPR.ATO
	MOVE	T3,T2			;COPY TTY NAME
	WHERE	T3,			;GET OUR STATION NUMBER
	  JRST	LOCAL			;DO NOT KNOW
	MOVE	T4,[SIXBIT /OPR0/]	;GET THE STATION NUMBER
	WHERE	T4,			; OF THE CENTRAL SITE
	  JRST	LOCAL			;ONLY REMOTE STATIONS
	CAMN	T3,T4			;ARE WE AT LOCAL STATION?
	JRST	LOCAL			;YES--USE OPR OR TTY
	LSHC	T3,-3			;SHIFT I OCTIT INTO T4
	LSH	T3,3			;SHIFT IN 3 ZEROS
	LSHC	T3,3			;GENERATE SIXBIT
	ADDI	T3,2020			; ..
	LSH	T3,6			;PUT IN LH OF RH
	TRNN	T3,170000		;LEADING ZERO
	LSH	T3,6			;YES--TRIM IT OFF
	HRLI	T3,'OPR'		;PREFIX WITH OPR
	MOVE	T4,T3			;COPY NAME OF OPR
	DEVNAM	T4,			;GET NAME OF OPR'S TTY
	  JRST	LOCAL			;SO CLOSE
	CAMN	T2,T4			;ARE WE OPRNN?
	MOVE	T2,T3			;YES--USE OPRNN NOT TTY115
LOCAL:	MOVSI	T3,'ATO'		;LOAD EXTENSION
	SETZ	T4,			;NO PPN
	PUSHJ	P,FAUTO			;SETUP AUTO FILE
>
SUBTTL	GENERAL PROGRAM LOOP

MAIN:	TLO	F,BRK			;SET BIT(S) TO START
	TLZ	F,QUIET!MSG!AUXQ	;CLEAR BIT(S) TO START
	SKPINL				;CLEAR ^O
	  JFCL				;DON'T CARE - JUST DO INPUT
	PUSHJ	P,STARTL		;START THE LINE
	TRNN	F,-1			;SKIP IF ANYBODY RUNNING
	JRST	TTWAIT			;GO INTO TTYIOW

	IFN	FTAUTO,<
	TLNN	F,AUTOM			;SKIP IF IN AUTO MODE
	JRST	NO2			;NOT
	PUSHJ	P,IOCHK			;CHECK PTY'S
	PUSHJ	P,STARTL		;MAY NEED NEW * OR !
	JRST	TTWAIT			;GO PROCESS COMMAND
>
NO2:	SKPINC				;SKIP IF A CHAR IS AVAILABLE
	  JRST	IOENDM			;NONE - GO SCAN PTY'S
	SKPINL				;SKIP IF ENTIRE LINE TYPED
	  SKIPA				;SKIP
	JRST	TTWAIT			;THERE IS - GO READ IT
	TLOE	F,TIMO1			;SET CHECK BIT & SKIP IF ZERO
	JRST	IOENDM			;TWICE ON - DON'T COUNTDOWN
	MOVEI	T1,TYPTIM		;WAIT N SECONDS TO FINISH LINE
TIMOLA:	MOVEI	T2,1			;LOAD 1
	SLEEP	T2,			;SLEEP FOR A WHILE
	SKPINL				;SKIP IF HE FINISHED THE LINE
	  SKIPA				;NO HE DIDN'T
	JRST	TTWAIT			;DONE - GO DIGEST
	SOJG	T1,TIMOLA		;COUNTDOWN

IOENDM:	PUSHJ	P,IOCHK			;GO CHECK PTY'S
	TLNE	F,PTBSY			;SKIP IF NO PTY ACTION
	JRST	MAIN			;SOME - GO LOOP
	MOVSI	T1,STHIB		;LOAD STANDARD HIBERNATE BITS
	MOVEI	T2,SNOOZT		; AND ST SLEEP TIME
	TLNN	F,SLEEPR		;SLEEP? 
	HIBER	T1,			;HIBERNATE
	  SLEEP	T2,			;GO TO SLEEP....
	PUSH	P,LASU			;SAVE THE DEFAULTS
	PUSH	P,SJB			; ..
	MOVE	T1,[SYSKTM,,NSWTBL]	;GET TIME TO KSYS
	SKIPE	KSYNC			;SKIP IF NO KSYS COMMAND
	GETTAB	T1,			; FROM THE MONITOR
	  SETZ	T1,			;NO GETTAB - LEAVE SYS ALONE
	JUMPE	T1,.+3			;DO NOT WARN IF COUNTER IS 0
	CAMG	T1,@WARNTM		;TIME TO GIVE A WARNING?
	PUSHJ	P,WARN			;YES--GIVE THE WARNING
	IFN	FTAUTO,<
	SKIPN	ATOTIM			;ANY DEFERED FILES
	JRST	MPOP			;NO--LOOP BACK FOR MORE
	PUSHJ	P,GETUPT		;GET UPTIME IN MS.
	CAMGE	T1,ATOTIM		;TIME TO RUN AN AUTO FILE?
	JRST	MPOP			;NO--LOOK FOR WORK
	MOVEI	PT1,PACF		;SAY AUOT FILE
	PUSHJ	P,MOUT			; SO OPR WILL KNOW
	MOVE	T5,[ATOT1,,T1]		;SET UP BLT POINTER
	BLT	T5,T5			;LOAD THE ACS
	SETZM	ATOTIM			;PREVENT A LOOP
	PUSHJ	P,FAUTO			;GIVE A FORCED AUTO
	JRST	MPOP			;LOOP FOR MORE
>
MPOP:	POP	P,SJB			;RESTORE DEFAULTS
	POP	P,LASU			; ..
	JRST	MAIN			;BACK TO WORK
SUBTTL	COMMAND SCANNER

TTWAIT:	TLZ	F,TIMO1			;ACKNOWLEDGE RECEPTION
	PUSHJ	P,STTYIN		;GET FIRST CHAR OF LINE
	JUMPL	F,MAIN			;JUST <CR>
	CAIN	DATA,";"		;SKIP IF NOT COMMENT
	JRST	MAIN			;IGNORE LINE
	CAIE	DATA,":"		;SKIP IF COMMAND TO ME
	JRST	NOTME			;NOT - JUMP AROUND
	PUSHJ	P,COMDEC		;GO INTERPRET
	  JRST	MAIN			;RECYCLE
	JRST	MAIN			;SAME

NOTME:	CAIN	DATA,"-"		;SKIP IF NOT DASH
	JRST	DEFAU1			;IT IS - GIVE DEFAULT
	CAIN	DATA,"#"		;IS THIS A MONITOR JOB
	JRST	MONJOB			;YES--SEE WHICH ONE

	PUSH	P,DATA			;SAVE FIRST CHAR
	PUSHJ	P,SIXIN			;GET FIRST SIXBIT WORD
	PUSHJ	P,RESCA1		; AND DO A RESCAN
	CAIE	DATA,"-"		;SKIP IF A DASH
	JRST	DEFAU2			;NOT DASH - SEND ENTIRE LINE
	POP	P,DATA			;RESTORE CHARACTER
	CAIN	DATA,"B"		;SKIP IF NOT ASCII B
	PUSHJ	P,CHKBAT		;GO SEE IF BATCON LIVES
	  JRST	NOT2			;SKIP CODE
	PUSH	P,DATA			;SAVE CHARACTER
	PUSHJ	P,STTYIN		;GET FIRST "B"
	PUSHJ	P,DECIN			;SEE IF DEC NBR FOLLOWING
	CAIN	DATA,"-"		;SKIP IF NOT
	JRST	HAVNBR			;WAS IN BN- FORMAT
	PUSHJ	P,RESCA1		;RESCAN
	PUSHJ	P,STTYIN		;SWALLOW THE "B"
	PUSHJ	P,SIXIN			;GET SIXBIT WORD
	MOVS	CMD,CMD			;SWAP HALVES
	CAIE	CMD,'ALL'		;SKIP IF "ALL" MNEMONIC
	CAIN	CMD,'AL '		; OR THIS CONTRACTION OF
	JRST	HAVNBR			;GOT IT
	CAIE	CMD,'A  '		;LAST POSSIBLE
	JRST	SOMELS			;WILD GOOSE CHASE
HAVNBR:	PUSHJ	P,RESCA1		;DO RESCAN
	POP	P,DATA			;CLEAR PDL
	HRRZ	LASU,SJB		;UPDATE LASU
	JRST	GOTNBR			;AND GO SEND LINE

SOMELS:	PUSHJ	P,RESCA1		;DO RESCAN
	POP	P,DATA			;CLEAR STACK & FALL THROUGH
NOT2:	CAIG	DATA,"9"		;SKIP IF NON-NUMERIC
	CAIGE	DATA,"0"		;SKIP IF NUMERIC
	JRST	ALPHA1			;BETTER BE ALPHABETIC
	PUSHJ	P,DECIN			;INPUT A DECIMAL NUMBER
	CAIE	DATA,"-"		;SKIP IF DASH IS DELIMITER
	JRST	ERR1			;NO DASH
	PUSHJ	P,SJBLIM		;CHECK LIMITS
	  JRST	MAIN			;BAD NUMBER - RESTART
	JRST	GOTNBR			;GO TO TRANSFER CODE

ALPHA1:	PUSHJ	P,SIXIN			;GET INPUT WORD
	PUSHJ	P,FINMNE		;GO FIND MNEMONIC
	  JRST	MAIN			;RECYCLE ON ERROR
	JRST	GOTNBR			;GO PROCESS TEXT

MONJOB:	PUSHJ	P,DECIN			;GET THE NUMBER
	CAIN	DATA,"-"		;DELIMITED BY -
	JRST	FNDSJB			;YES--SET UP SJB.
	PUSHJ	P,RESCA1		;NO--SEND AS TEXT
	JRST	DEFAU1			; TO LAST SUBJOB

FNDSJB:	SETO	T2,			;FLAG
	MOVEI	SJB,1B18		;ALL SUBJOBS
	PUSH	P,[LOOKMJ]		;SUBROUTINE
	PUSHJ	P,RUNSUB		;RUN ONCE FOR EACH SUBJOB
	JUMPL	T2,ERR1			;DO I KNOW HIM
	MOVE	SJB,T2			;YES--LOAD SJB
	JRST	SKIP1			;SEND THE LINE(S)

LOOKMJ:	PUSHJ	P,UJBSTS		;GET THE STATUS
	CAIN	CMD,(T1)		;SAME JOB NUMBER
	HRRZ	T2,SJB			;YES--COPY SUBJOB NUMBER
	POPJ	P,			;RETURN

DEFAU2:	POP	P,DATA			;RESTORE DATA
DEFAU1:	HRRZ	SJB,LASU		;LOAD WITH LAST REF
SUBTTL	SENDING TEXT TO SUBJOBS

GOTNBR:	TRNN	SJB,1B18		;SKIP IF "ALL" USED
	JRST	JUST1			;SINGLE REFERENCE
	PUSHJ	P,CHKBAT		;SEE IF BATCON LIVES
	  JRST	SKIP1A			;DOESN'T - SKIP CODE
	MOVEI	DATA,"-"		;LOAD DASH
	PUSHJ	P,PTYOUT		;SEND IT TO BATCON
SKIP1A:	MOVNI	SJB,1			;RESTORE SJB
	JRST	SKIP1			;AND SKIP THIS CODE

JUST1:	TDNE	F,USE(SJB)		;SKIP IF SUBJOB FREE
	JRST	SKIP1			;INIT'ED - SKIP CODE
	PUSHJ	P,IPTY			;INITIALIZE A PTY
	  JRST	MAIN			;NO MORE PTY'S

SKIP1:	TLO	F,MSG			;DO NOT FORMAT INPUT LINE
	PUSHJ	P,STTYIN		;GET NEXT CHAR
	CAIN	DATA,"-"		;DOUBLE DASH? 
	JRST	MULN			;YES

TLOOP1:	PUSH	P,[PTYOUT]		;LOAD ADDR OF SUBROUTINE
	PUSHJ	P,RUNSUB		;GO EXEC IT
	JUMPL	F,FINONE		;EOL - FINISHED
	PUSHJ	P,TTYIN			;GET NEXT CHAR
	JRST	TLOOP1			;CIRCLE

MULN:	PUSHJ	P,STTYIN		;GET NEXT CHAR ON LINE
	JUMPL	F,ERR1			;NOT A BREAK CHAR, PLS
	PUSH	P,DATA			;SAVE ON PDL
TLOOP2:	PUSHJ	P,TTYIN			;GET NEXT CHAR
	CAMN	DATA,(P)		;MATCH?
	JRST	END2			;YES - EXIT FROM LOOP
	PUSH	P,[PTYOUT]		;PUSH ADDR OF ROUTINE
	PUSHJ	P,RUNSUB		;GO EXEC IT
	JRST	TLOOP2			;CIRCLE

END2:	POP	P,(P)			;RESTORE PDL
FINONE:	PUSH	P,[DUMPT]		;PUT ADDR ON STACK
	PUSHJ	P,RUNSUB		;GO EXEC IT
	JRST	MAIN			;CIRCLE

ERR1:	PUSHJ	P,CMDERR		;GO TYPE ERROR MESSAGE
	JRST	MAIN			;AND RESTART
SUBTTL	COMMAND DECODER AND DISPATCHER

COMDEC:	PUSHJ	P,SIXIN			;GO GET INPUT WORD
	JUMPL	F,YES4			;EOL IS GOOD
	CAIE	DATA,SP			; OR TERMINATED BY A SPACE
	PJRST	CMDERR			;FUNNY TYPEIN

YES4:	TLZ	F,CMD1			;ZERO THIS BIT TO START
	MOVE	T1,CMD			;LOAD INPUT WORD
	SETO	T2,			;FILL WITH ONES
LOOP4:	LSH	T2,-6			;SHIFT RIGHT 6
	LSH	T1,6			;SHIFT LEFT 6
	JUMPN	T1,LOOP4		;JUMP IF MORE
	MOVSI	T1,-LSTSIZ		;MAKE AOBJN XWD
LOOP4A:	CAMN	CMD,COMLST(T1)		;SKIP IF NO MATCH
	JRST	FOUND			;PERFECT MATCH!
	MOVE	T3,COMLST(T1)		;LOAD IT UP
	TDZ	T3,T2			;MASK OUT UNUSED BITS
	CAME	CMD,T3			;SKIP IF IT NOW MATCHES
	JRST	NO4			;NOPE
	TLOE	F,CMD1			;SET AND SKIP IF FIRST TIME
	PJRST	DUPLIC			;DUPLICATE COMMAND
	HRRZ	T4,T1			;REMEMBER INDEX HERE
NO4:	AOBJN	T1,LOOP4A		;SEARCH THROUGH TABLE
	TLNN	F,CMD1			;SKIP IF SOME MATCH
	PJRST	CMDERR			;TYPE ERROR MESSAGE
	MOVE	T1,T4			;LOAD UP INDEX
FOUND:	TLZ	T1,-1			;ZERO LH
	ROT	T1,-1			;DIVIDE BY 2 AND SAVE REMAINDER
	MOVE	T2,DSPTBL(T1)		;LOAD XWD DISPATCH ADDR
	JUMPL	T1,(T2)			;GO DISPATCH
	MOVS	T2,T2			;SWAP HALVES
	PJRST	(T2)			;GO EXEC

DUPLIC:	PJSP	PT1,MOUT
	ASCIZ	/? Command not unique
/
	DEFINE	NAMES<
	X FREE,FREENO		;NEXT FREE SUBJOB
	X SYSTAT,RESCO1		;RUN SYSTAT CUSP
	X DEFINE,SJNAM		;DEFINE MNEMONICS
	X ERROR,SETERR		;ONLY ERROR LINES
	X EXIT,FINISH		;EXIT TO MONITOR
	X WHAT,WHAT		;WHAT COMMAND
	X K,KILL		;LOGOUT SUBJOB
	X KILL,KILL		;LOGOUT SUBJOB
	X KJOB,KILL		;SAME AS KILL
	X KSYS,KSYS		;STOP THE SYSTEM
	X STOP,SETMON		;PUT IN MONITOR MODE
	X TTYTST,TTYTST		;TEST OUT CONSOLE
	X RESOURCES,RESCO1	;TYPE SYSTEM RESOURCES
	X DAYTIME,RESCO1	;DAYTIME COMMAND
	X QUEUE,RESCO1		;RUN QUEUE CUSP
	X JCONT,RESCO1		;5S03 FORCED CONTINUE
	X SEND,RESCO1		;SEND TTY COMMAND
	X LOGIN,LOGIN		;RUN LOGIN
	X CURRENT,CURS		;TYPE CURRENT SUBJOB
	X SET,SETCMD		;SET COMMAND
	X SILENCE,PTOFF		;SILENCE PTY SUBJOB
	X SLOGIN,SLOGIN		;SILENT LOGIN (SETS DALSHH BIT)
	X REVIVE,PTON		;LISTEN TO IT AGAIN
	X MSGLVL,SETLEV		;SET MESSAGE LENGTH
	X DEVICE,DEVREQ		;GET A DEVICE
	IFN	FTAUTO,<
	X CONTINUE,CONT		;CONTINUE AUTO FILE
>
	X HELP,HELP		;BRIEF EXPLANATION OF OPSER
	X TSILENCE,TPTOFF	;SAME AS SILENCE BUT LEAVE LOG ON
	X RESTRICT,DEVRST	;RESTRICT DEVICE
	X UNRESTRICT,DEVURS	;UNRESTRICT DEVICE

	IFN FTAUTO,<
	X AUTO,AUTO		;AUTO FILE COMMAND
>
	IFN FTTLOG,<
	X TLOG,TLOG		;ENTER LOG FILE
	X CLOSE,CLOSED		;CLOSE LOG FILE
>>

DEFINE	SNAMES<
	X RUN,SETRN		;'SET RUN CPUN'
	X LOGMAX,SETLOG		;'SET LOGMAX N'
	X BATMAX,SETBMX		;'SET BATMAX N'
	X BATMIN,SETBMN		;'SET BATMIN N'
	>
	DEFINE X(A,B)<
	<SIXBIT/A/>
>

COMLST:	NAMES

	LSTSIZ==.-COMLST	;HOW MANY COMMANDS THERE ARE

SETLST:	SNAMES

	SETSIZ==.-SETLST
;XWD DISPATCH TABLE MACRO

	DEFINE	X(A,B)<
	IFE	ZZ&1,<
	DEFINE	XX(C)<
	XWD	B,C
>>
	IFN	ZZ&1,<
	XX	B
>
	ZZ==ZZ+1
>
	ZZ==0

DSPTBL:	NAMES

	IFN	ZZ&1,<XX 0>

	ZZ==0

SETDSP:	SNAMES

	IFN	ZZ&1,<XX 0>UBTTL	:FREE - :TTYTST

FREENO:	PUSHJ	P,FSUB			;GET NBR OF FIRST FREE SUB
	  POPJ	P,			;THERE WEREN'T ANY
	MOVEI	PT1,[ASCIZ/First free = /]
	PUSHJ	P,MOUT			;TYPE MESSAGE
	HRRZ	T1,SJB			;LOAD NBR
	PUSHJ	P,DECOUT		;TYPE IN DECIMAL
	PJRST	CRLF			;END WITH RETURN



TTYTST:	MOVEI	DATA,40			;START WITH OCTAL 40
	PUSHJ	P,TTYOUT		;TYPE CHAR
	CAIGE	DATA,77			;TYPE UP TO 77
	AOJA	DATA,.-2		;KEEP GOING
	PUSHJ	P,CRLF
	MOVEI	DATA,100		;NOW START WITH OCTAL 100
	PUSHJ	P,TTYOUT		;TYPE CHAR
	CAIGE	DATA,137		;GO UP TO OCTAL 137
	AOJA	DATA,.-2
	PUSHJ	P,CRLF
	MOVEI	DATA,140		;NOW START WITH 140
	PUSHJ	P,TTYOUT		;TYPE THAT
	CAIGE	DATA,174		;GO UP TO 174
	AOJA	DATA,.-2
	MOVEI	PT1,[BYTE(7)BELL,CR,LF]	;ASCIZ STRING
	PJRST	MOUT			;TYPE ON CONSOLE
SUBTTL	:CURRENT - :MSGLEVEL

CURS:	PUSHJ	P,LOUD			;TURN TTY BACK ON
	MOVEI	PT1,[ASCIZ/Current subjob = /]
	PUSHJ	P,MOUT
	HRRZ	SJB,LASU
	PUSHJ	P,PUTNAM
	PJRST	CRLF



SETLEV:	JUMPL	F,TOOFEW		;MUST HAVE ARGUMENT
	PUSHJ	P,DECIN			;GET A NUMBER
	JUMPGE	F,CMDERR		;NO MORE PLEASE
	JUMPE	CMD,SETOK0		;ZERO IS ONE POSSIBILITY
	CAIE	CMD,1			;ONE IS THHE OTHER
	PJRST	CMDERR			;TELL HIM THAT
	TLZA	F,MSH			;SHORT MESSAGES
SETOK0:	TLO	F,MSH			;LONG ONES
	POPJ	P,			;RETURN
SUBTTL	:SILENCE - :REVIVE - :STOP - :KILL - :ERROR - :TSILENCE

PTOFF:	PUSH	P,[PTSETB]		;PUSH ADDR OF ROUTINE
	PUSHJ	P,RUNSA			;GO EXEC
	POPJ	P,			;RETURN

PTSETB:	MOVSI	T1,(SHH)		;LOAD SILENCE BIT
	IORM	T1,SJBFLG(SJB)		;OR BIT IN
	POPJ	P,			;AND RETURN



PTON:	PUSH	P,[PTCLRB]		;PUSH ADDR OF ROUTINE
	PUSHJ	P,RUNSA			;GO EXEC
	POPJ	P,			;RETURN

PTCLRB:	MOVSI	T1,(SHH!ERONLY!TSIL)	;LOAD SILENCE BIT
	ANDCAM	T1,SJBFLG(SJB)		;CLEAR BIT FROM TABLE
	POPJ	P,			;AND RETURN



SETMON:	PUSH	P,[STOPJB]		;PUSH ADDR OF SUBR
	PUSHJ	P,RUNSA			;EXECUTE
	POPJ	P,			;RETURN



KILL:	PUSH	P,[RPTY]		;LOAD SUBR ADDR
	PUSHJ	P,RUNSA			;EXEC
	POPJ	P,



SETERR:	PUSH	P,[ERSET]		;PUSH ADDRESS OF SUBROUTINE
	PUSHJ	P,RUNSA			;RUN SUB FOR EACH ARG
	POPJ	P,			;RETURN

ERSET:	MOVSI	T1,(ERONLY)		;SAMBERG BIT
	IORM	T1,SJBFLG(SJB)		;TUNR IT ON
	POPJ	P,			;RETURN

TPTOFF:	PUSH	P,[PTSET2]
	PUSHJ	P,RUNSA
	POPJ	P,

PTSET2:	MOVSI	T1,(TSIL!SHH)
	IORM	T1,SJBFLG(SJB)
	POPJ	P,
SUBTTL	:SLOGIN & :LOGIN

SLOGIN:	PUSHJ	P,FSUB			;GO FIND A FREE SUBJOB
	  POPJ	P,			;NONE AVAILABLE
	PUSHJ	P,IPTY			;NOW GET A FREE PTY
	  POPJ	P,			;NONE THERE
	MOVSI	T1,(DALSHH)		;LOAD SPECIAL SILENCE BIT
	IORM	T1,SJBFLG(SJB)		;IOR INTO SUBJOB STATUS FLAGS
	JUMPL	F,LOGIN1		;JUMP INTO REGULAR LOGIN NOW
	PUSHJ	P,RESCA1		;DO RESCAN
	PUSHJ	P,STTYIN		;SWALLOW COLON
	PJRST	SLOOP0			;FALL INTO RESCOM ROUTINE



LOGIN:	JUMPGE	F,RESCOM		;IF MORE TO COME, JUST XFR
	PUSHJ	P,FSUB			;GET FIRST FREE SUBJOB
	  POPJ	P,			;NONE
	PUSHJ	P,IPTY			;GET A PTY FOR SUBJOB
	  POPJ	P,			;NONE
LOGIN1:	MOVEI	PT1,[ASCIZ/LOGIN /]	;LOAD ADDR OF STRING
	PUSHJ	P,PTMOUT		;SEND TO SUBJOB
	GETPPN	T3,			;GET MY PROJ,PROG
	  JFCL
	HLRZ	T1,T3			;PUT PROJECT INTO RH OF T3
	PUSHJ	P,PTOCT			;TYPE AT SUBJOB
	MOVEI	DATA,"/"		;LOAD A SLASH
	PUSHJ	P,PTYOUT		;SEND CHAR
	HRRZ	T1,T3			;LOAD PROGRAMMER NUMBER
	PUSHJ	P,PTOCT			;TYPE THAT
	MOVEI	DATA,CR			;LOAD RETURN
	PUSHJ	P,PTYOUT		;SEND THAT
	MOVEI	DATA,LF			;FINALLY A LINE FEED
	PJRST	PTYOUT			;BREAK CHAR FOR LINE
SUBTTL	:SYSTAT - :RESOURCES - :QUEUE - :SEND - :JCONT

RESCO1:	PUSHJ	P,RESCOM		;DO RESCOM LIKE COMMAND
	  POPJ	P,			;NO BANANAS
LOOP10:	PUSHJ	P,GBUF			;GET REPLY
	PUSHJ	P,UJBSTS		;GET JOBSTS
	SETCA	T1,T1			;COMPLEMENT T1
	TLNE	T1,(MONMOD!INREQ)	;SKIP IF BOTH WERE ON
	JRST	LOOP10			;KEEP CIRCLING
	PJRST	RPTYN			;RELEASE PTY


RESCOM:	PUSHJ	P,FSUB			;GET FIRST FREE SUBJOB
	  POPJ	P,			;FORGET IT
	PUSHJ	P,IPTY			;GET A PTY FOR IT
	  POPJ	P,			;NONE
	PUSHJ	P,RESCA1		;DO A RESCAN
SLOOP0:	PUSHJ	P,STTYIN		;SWALLOW THE COLON
SLOOP1:	PUSHJ	P,TTYIN			;GET NEXT CHAR
	PUSHJ	P,PTYOUT		;SEND THE CHAR TO THE PTY
	JUMPGE	F,SLOOP1		;JUMP IF MORE TO COME
	AOS	(P)			;GIVE SKIP RETURN
	PJRST	DUMPT			;SEND BUFFER
SUBTTL	:SET

;SET COMMAND, SCAN FOR ARGUMENTS WE ARE TO HANDLE, THEN IF NONE,
;GO TO 'RESCO1' TO PASS COMMAND ON TO MONITOR.

SETCMD:	PUSHJ	P,SIXIN		;MUST BE SOME MORE TYPEIN
	JUMPE	CMD,TOOFEW	;MUST HAVE ANOTHER ARGUMENT
	CAIE	DATA,SP		;MUST BE TERMINATED BY A SPACE
	PJRST	CMDERR		;NOT GOOD TYPEIN
	TLZ	F,CMD1		;ZERO "FOUND A MATCH" BIT
	MOVE	T1,CMD		;GET ARGUMENT
	SETO	T2,		;SET T2 TO -1
SETCM1:	LSH	T2,-6		;THEN MAKE A MASK
	LSH	T1,6		; USING ONLY THE NUMBER OF
	JUMPN	T1,SETCM1	; CHARACTERS TYPED IN
	MOVSI	T1,-SETSIZ	;MAKE AN AOBJN WORD
SETCM2:	CAMN	CMD,SETLST(T1)	;SKIP IF NOT PERFECT MATCH
	JRST	SETCM4		;MATCH, GO SERVICE
	MOVE	T3,SETLST(T1)	;GET ENTRY ON TABLE
	TDZ	T3,T2		;USE ONLY NUMBER OF CHARACTERS TYPED IN
	CAME	CMD,T3		;PARTIAL MATCH?
	JRST	SETCM3		;NO, TRY NEXT
	TLOE	F,CMD1		;PARTIAL, ANY OTHERS?
	PJRST	DUPLIC		;YES, TYPE ERROR MESSAGE
	HRRZ	T4,T1		;REMEMBER INDEX OF PARTIAL MATCH
SETCM3:	AOBJN	T1,SETCM2	;TRY NEXT ARGUMENT, IF ONE
	TLNN	F,CMD1		;FOUND A UNIQUE PARTIAL MATCH?
	JRST	RESCO1		;NO, PASS IT ON TO MONITOR
	MOVE	T1,T4		;YES, GET INDEX
SETCM4:	TLZ	T1,-1		;CLEAR LH OF T1
	ROT	T1,-1		;DEVIDE BY TWO
	MOVE	T2,SETDSP(T1)	;GET DISPATCH ENTRY
	JUMPL	T1,(T2)		;DISPATCH IF INDEX WAS ODD
	MOVS	T2,T2		;IF INDEX EVEN, DISPATCH ON LEFT HALF
	PJRST	(T2)		;AND GO

;SET RUN, SET LOGMAX, SET BATMAX, SET BATMIN, ARE SIMULATED MONITOR
; SET COMMANDS IMPLEMENTED VIA APPROPRIATE PRIVILEDGED SETUUO'S.

SETRN:	JUMPL	F,TOOFEW	;NOT ENOUGH ARGUMENTS?
	PUSHJ	P,SIXIN		;GET NEXT ARGUMENT
	JUMPE	CMD,CMDERR	;NO NEXT ARGUMENT?
	SETZ	T1,		;CLEAR T1 IN CASE ONLY ONE ARGUMENT
	JUMPL	F,SETRN1	;COULD BE LAST ARGUMENT
	CAIE	DATA,SP		;OR MAYBE ONE FOLLOWS
	PJRST	CMDERR		;BUT NO SPACE LOSES
	MOVE	T1,CMD		;SAVE ARGUMENT
	PUSHJ	P,SIXIN		;AND GET ANOTHER
	JUMPE	CMD,CMDERR	;MUST BE ONE
	JUMPGE	F,CMDERR	;AND ONLY ONE
SETRN1:	PUSHJ	P,SETCK0	;DECODE LAST ARGUMENT
	  JRST SETRN3		;NOT A VALID CPU NAME
	JUMPE	T1,SETRN4	;IF T1=0, COMMAND WAS "SET RUN CPXN"
	CAME	T1,[SIXBIT /NO/];WAS COMMAND "SET RUN NO CPXN"?
	JRST	SETRN2		;NO, TRY "ONLY"
	PUSHJ	P,SETMSK	;SET UP A MASK OF CURRENTLY RUNNING CPU'S
	ANDCM	T1,T3		;CLEAR OUT THIS CPU
	JRST	SETRN5		;AND ISSUE SETUUO

SETRN2:	CAME	T1,[SIXBIT /ONLY/];WAS "SET RUN ONLY CPXN"?
	JRST	CMDERR		;NO, ERROR
	MOVE	T1,T3		;YES, ONLY SET THIS ONE
	JRST	SETRN5

SETRN3:	CAME	CMD,[SIXBIT /ALL/];WAS COMMAND "SET RUN ALL"?
	JRST	CMDERR		;NO, ERROR
	MOVEI	T1,77		;MASK TO RUN ALL POSSIBLE CPU'S
	JRST	SETRN5

SETRN4:	PUSHJ	P,SETMSK	;GET MASK FOR RUNNING CPU'S
	IOR	T1,T3		;AND ADD THIS TO OTHERS
SETRN5:	SKIPN	T1		;WILL ANY BE RUNNABLE?
	PJRST	NORUN		;NO, PRINT ERROR MESSAGE
	HRLI	T1,SETRUN	;GET SETUUO FUNCTION
	SET	T1,		;AND SET NEW SPECIFICATION
	PJRST	NOPRIV		;NOT LOGGED IN AS 1,2
	POPJ	P,		;AND RETURN


;SUBROUTINE TO MAKE A MASK OF ALL RUNNING CPU'S IN AC T1. T3 RESPECTED.

SETMSK:	SETZ	T1,		;CLEAR REGISTER TO BUILD MASK
	MOVEI	T4,1		;MASK FOR CPU0
	MOVE	T5,[-6,,RUNTBL] ;TABLE OF GETTAB ARGUMENTS
SETMS1:	MOVE	T2,(T5)		;GET AN ENTRY
	GETTAB	T2,		;GET RUNNABILITY WORD
	  TLO	T2,400000	;ERROR RETURN MEANS UNRUNNABLE
	SKIPL	T2		;SKIP IF CPU NOT RUNNING
	IOR	T1,T4		;IS RUNNING, LIGHT BIT
	LSH	T4,1		;MOVE TO NEXT CPU POSITION
	AOBJN	T5,SETMS1	;AND LOOK AT NEXT IF ANY
	POPJ	P,		;ALL THROUGH

;SUBROUTINE TO CHECK VALIDITY OF A PHYSICAL OR LOGICAL CPU NAME AND
;CREATE A BIT MASK TO BE USED FOR THE .STRUN SETUUO.
;CALL	MOVE	CMD,[CPU NAME]
;	PUSHJ	P,SETCK0
;	ERROR RETURN		;NOT A VALID NAME
;	NORMAL RETURN		;BIT MASK IN AC T3
;T1 RESPECTED

SETCK0:	HLLZ	T3,CMD		;GET LEFTMOST THREE CHARACTERS
	CAMN	T3,[SIXBIT /CPU/];LOGICAL NAME?
	JRST	SETCK2		;YES, MAKE MASK
	MOVE	T3,[-6,,PHYTBL]	;AOBJN WORD TO LIST OF GETTAB ARGUMENTS
SETCK1:	MOVE	T2,(T3)		;GET ARGUMENT
	GETTAB	T2,		;GET PHYSICAL NAME OF THIS CPU
	  SETZ	T2,		;NONE?
	CAME	T2,CMD		;THIS ONE?
	AOBJN	T3,SETCK1	;NO, TRY NEXT IF ANY
	JUMPGE	T3,CPOPJ	;NOT A VALID NAME?
SETCK2:	HRRZ	T4,CMD		;GET CPU NUMBER
	LSH	T4,-14		;RIGHT JUSTIFY IF
	SUBI	T4,20		;AND REDUCE TO BINARY
	CAIG	T4,5		;TOO LARGE A NUMBER?
	SKIPGE	T4		;NO, TOO SMALL?
	POPJ	P,		;NOT A LEGAL CPU NUMBER.
	MOVE	T3,PHYTBL(T4)	;GETTAB ARGUMENT FOR THIS CPU
	GETTAB	T3,		;GET PHYSICAL CPU NAME
	  POPJ	P,		;DOESN'T EXIST, ERROR
	MOVEI	T3,1		;MASK FOR CPU0
SETCK3:	SOJL	T4,CPOPJ1	;THIS CPU?
	LSH	T3,1		;NO, TRY NEXT
	JRST	SETCK3

;TABLE OF GETTAB ARGUMENTS FOR CPU'S

PHYTBL:	CPPHY,,.GTC0C
	CPPHY,,.GTC1C
	CPPHY,,.GTC2C
	CPPHY,,.GTC3C
	CPPHY,,.GTC4C
	CPPHY,,.GTC5C
RUNTBL:	CPRUN,,.GTC0V
	CPRUN,,.GTC1V
	CPRUN,,.GTC2V
	CPRUN,,.GTC3V
	CPRUN,,.GTC4V
	CPRUN,,.GTC5V
SETLOG:	JUMPL	F,CMDERR	;MUST HAVE AN ARGUMENT
	PUSHJ	P,DECIN		;GET DECIMAL ARGUMENT
	JUMPGE	F,CMDERR	;ANY MORE IS AN ERROR
	HRLI	CMD,LOGMAX	;GET SETUUO FUNCTION
	SET	CMD,		;AND SET IT UP
	  JRST	SETBAD		;SOMETHING WRONG
	POPJ	P,

SETBMX:	JUMPL	F,CMDERR
	PUSHJ	P,DECIN
	JUMPGE	F,CMDERR
	HRLI	CMD,BATMAX
	SET	CMD,
	  JRST	SETBAD
	POPJ	P,

SETBMN:	JUMPL	F,CMDERR
	PUSHJ	P,DECIN
	JUMPGE	F,CMDERR
	HRLI	CMD,BATMIN
	SET	CMD,
	  JRST	SETBAD
	POPJ	P,


DEVRST:	JUMPL	F,TOOFEW	;NOT ENOUGH TEXT
	PUSHJ	P,SIXIN		;GET DEVICE NAME
	JUMPE	CMD,CMDERR	;NO DEVICE NAME?
	CAIE	DATA,":"	;TERMINATOR A COLON?
	PJRST	CMDERR		;NOT A COLON, ERROR
	DVRST.	CMD,		;RESTRICT DEVICE
	  JRST	DEVERR		;ERROR RETURN, EITHER NON-EX OR NO PRIVS
	POPJ	P,		;GOOD RETURN

DEVURS:	JUMPL	F,TOOFEW	;NOT ENOUGH TEXT?
	PUSHJ	P,SIXIN		;GET DEVICE NAME
	JUMPE	CMD,CMDERR	;NO DEVICE NAME?
	CAIE	DATA,":"	;MUST HAVE COLON TERMINATOR
	PJRST	CMDERR		;IF NOT, ERROR
	DVURS.	CMD,		;UNRESTRICT DEVICE
	  JRST	DEVERR		;ERROR
	POPJ	P,		;GOOD RETURN


SETBAD:	SKIPA	T5,[CMDERR]	;IF PRIV T HE COMAND ERROR
DEVERR:	MOVEI	T5,NOBE		;IF PRIV THEN NO SUCH DEVICE
	MOVEI	T1,T2		;SET UP POINTER
	MOVE	T2,[1,,777]		;PROTECTION
	GETPPN	T3,		;GET OUR PPN
	  JFCL			;PROTECTION FROM JACCT
	MOVE	T4,T3		;COPY PPN
	CHKACC	T1,		;CAN WE DELETE
	  SETZ	T1,		;YES--GO AHEAD
	JUMPE	T1,(T5)		;YES--THEN WE ARE [OPR]
	JRST	NOPRIV		;LOOSE
SUBTTL	:EXIT COMMAND

FINISH:	TLZ	F,SBOD			;START WITH ZERO
	MOVSI	SJB,NPTLTH		;MAKE XWD PTR
FINISL:	TDNN	F,USE(SJB)		;SKIP IF IN USE
	JRST	NOFIN1
	PUSHJ	P,ISJOB			;SKIP IF JNA IS ON
	  JRST	NOFIN2			;FREE
	TLOE	F,SBOD			;SET & SKIP IF FIRST TIME
	JRST	MULTI			;SECOND OR THIRD
	MOVEI	PT1,[ASCIZ/? Job(s) running on /]
	PUSHJ	P,MOUT			;SEND THAT STRING
	SKIPA
MULTI:	PUSHJ	P,COMOUT		;TYPE A COMMA
	PUSHJ	P,PUTNAM		;AND THE SUBJOB NAME
	JRST	NOFIN1			;AND END LOOP
NOFIN2:	PUSHJ	P,RPTYN			;RELEASE PTY
NOFIN1:	AOBJN	SJB,FINISL		;LOOP FOR ALL SUBJOBS
	TLNN	F,SBOD			;SKIP IF SOMEBODY RUNNING
	EXIT				;AUF WIEDERSEHEN
	PJSP	PT1,MOUT
	ASCIZ	/
TYPE ":KILL ALL" TO LOG ALL OFF
/
SUBTTL	:KSYS COMMAND AND SYSTEM KILLER

KSYS:	JUMPL	F,KNONE		;JUMP IF NO ARGUMENT
	PUSHJ	P,STTYIN	;GET A CHAR
	SETZ	SJB,		; AND CLEAR SJB
	CAIN	DATA,"+"	;WAS IT +HHMM
	JRST	GETKTM		;YES--GO READ TIME
	MSTIME	SJB,		;WHAT TIME IS IT NOW
	IDIVI	SJB,^D1000*^D60	;CONVET TO MINS
	PUSHJ	P,RDX60		;GET THE TIME
	  POPJ	P,		;ERROR
	CAILE	CMD,^D24*^D60	;MORE THAN 24 HRS.
	JRST	BADTIM		;YES--BAD TIME
	JRST	SETK		;LOCK IT IN
KNONE:	SETZ	CMD,		;CLEAR THE KSYS TIME
	JRST	SETK1		;STORE THE TIME
GETKTM:	PUSHJ	P,RDX60W	;GET TIME TO KSYS
	  POPJ	P,		;ERROR
SETK:	SUB	CMD,SJB		;SUBTRACT TIME NOW
	SKIPGE	CMD		;IS IT POSITIVE
	ADDI	CMD,^D60*^D24	;NO--ADD A DAY
	CAIL	CMD,5		;AT LEAST FIVE MIN.
	JRST	SETK1		;YES--SKIP THE WARNING
	MOVEI	PT1,ATL5	;LOAD A WARNING
	PUSHJ	P,MOUT	;GIVE THE MESSAGE
	MOVEI	CMD,5		;NO--SLOW ERIC DOWN
SETK1:	HRLI	CMD,.KSYS	;SET UP FUNCTION
	SET	CMD,		;SET KSYS
	  JRST	SETUER		;ERROR RETURN
	MOVEM	T1,KSYNC	;SAVE FOR SYNC
	MOVEI	T1,WARNTB	;GET POINTER TO TABLE
	MOVEM	T1,WARNTM	;STORE AS WARN POINTER
	HRRZ	T1,CMD		;COPY TIME TO KSYS
	JUMPE	T1,CPOPJ	;DO NOT WARN IF 0
	PJRST	WARN		;PUT IN THE REQUEST
SETUER:	PJSP	PT1,MOUT	;GIVE ERROR MESSAGE
	ASCIZ	/? You can not stop timesharing
/
	RADIX	10
WARNTB:	EXP	300,30,15,5,3,1,-1	;TIMES TO CALL WARN
	RADIX	8
	EXP	400000000000	;SOMETHING VERY SMALL
WARN:	PUSH	P,T1			;SAVE T1 (MIN. TO KSYS)
	PUSHJ	P,FSUB			;FIND A FREE SUBJOB
	  JRST  XPOPJ			;NONE CLEAR STACK AND RETURN
	PUSHJ	P,IPTY			;GO INIT A PTY.
	  JRST	XPOPJ			;NONE AROUND CLEAN UP AND RETURN
	POP	P,T4			;RESTORE T4
	AOS	WARNTM			;POINT TO NEXT TIME
	CAMG	T4,@WARNTM		;ONLY GIVE ONE MESSAGE
	JRST	.-2			; BUMP POINTER AGAIN
	JUMPL	T4,EWORLD		;END THE WORLD
	MOVEI	PT1,[ASCIZ /SEND ALL OPSER: Timesharing ends in /]
	PUSHJ	P,PTMOUT		;SEND THE STRING
	PUSHJ	P,DECPTY		;DECMAL OUTPUT TO PTY
	MOVEI	PT1,[ASCIZ / min.
/]
	PUSHJ	P,PTMOUT		;SEND THE STRING
	PUSHJ	P,DUMPT			;DUMP THE BUFFER
	HRLOI	CMD,377777
	IFN	FTAUTO,<
	MOVN	CMD,ATOTIM
	PUSHJ	P,GETUPT
	ADD	CMD,T1
>
	PJRST	SETDA1

DECPTY:	IDIVI	T4,12			;DIVIDE BY 10
	PUSH	P,T5			;SAVE REMAINDER
	SKIPE	T4			;SKIP IF DONE
	PUSHJ	P,DECPTY		;LOOP FOR MORE
	POP	P,T1			;RESTORE A DIGIT
	MOVEI	DATA,60(T1)		;COPY AND CONVERT
	PJRST	PTYOUT			;LOOP FOR MORE
;HERE TO KILL ALL THE USERS JOBS

EWORLD:	MOVEI	PT1,[ASCIZ /SEND ALL TIMESHARING IS OVER
/]
	PUSHJ	P,PTMOUT		;SEND THE MESSAGE
	PUSHJ	P,DUMPT			;DUMP THE BUFER
	MOVSI	T1,TTYTAB		;INDEX OF TTY USERS
ELOOP:	MOVS	T2,T1			;FLIP HALVES
	GETTAB	T2,			;GET THE TTY
	  JRST	KJOBS			;ALL DETACHED KILL THEM
	PUSHJ	P,CHKATT		;SEE IF ATTACHED
	  AOJA	T1,ELOOP		;NO--LEAVE ALONE
	MOVEI	T3,LDBDCH(T3)		;GET LINE CHAR.
	PEEK	T3,			;PEEK INTO MONITOR
	TRNN	T3,LDRDSR		;DATASET OR REMOTE
	AOJA	T1,ELOOP		;DO NOT KILL
	MOVEI	T2,DVCHR(T2)		;POINT TO DEVCHR WORD
	PEEK	T2,			; AND PEEK FROM MONITOR
	LDB	T2,[POINT 7,T2,23]	;GET LINE NUMBER
	HRLZ	T2,T2			;COPY TO LEFT HALF
	TLO	T2,(1B0)		;PLACE AT TOP LEVEL
	ATTACH	T2,			;DETACH THE JOB
	  JFCL				;WE TRIED
	AOJA	T1,ELOOP		;LOOP FOR MORE LOOSERS
;HERE TO MOP UP ALL DETACHED JOBS (EXCEPT DAEMON)

KJOBS:	PUSHJ	P,ISJOB			;IS SJB INITED
	  PUSHJ	P,RPTYN			;NO--CLAEN UP
	PUSHJ	P,FSUB			;FIND A FREE SUBJOB
	  POPJ	P,			;NO FREE SUBJOBS
	PUSHJ	P,IPTY			;AND INIT A PTY ON IT
	  POPJ	P,			;NO MORE PTY'S
	MOVEI	T1,(SJB)		;GET THE CHAN
	DEVNAM	T1,			;GET THE FILE NAME
	  POPJ	P,			;PRIOR TO 5.03
	HRLZ	T1,T1			;COPY UNIT TO LEFT HALF
	MOVE	T2,[POINT 6,T1]		;SET A BYTE POINTER
	SETZ	T3,			;CLEAR RESULT
KSLP0:	ILDB	T4,T2			;LOAD A DIGIT
	JUMPE	T4,KSYS1		;DONE
	LSH	T3,3			;MULT BY 8
	ADDI	T3,-20(T4)		;ADD IN NEXT DIGIT
	JRST	KSLP0			;LOOP FOR MORE DIGITS
KSYS1:	ADD	T3,PTY0LN		;FIX FOR PTYOFS
	PUSH	P,T3			;SAVE ON STACK
	MOVSI	T1,TTYTAB		;LOAD INDEX OF TTYTAB
KSLP1:	MOVS	T2,T1			;LH=JOB , RH=TTYTAB
	GETTAB	T2,			;GET DDB POINTER
	  JRST	KSYS2			;END OF TTYTAB
	SKIPN	T2			;SKIP IF DDB
	AOJA	T1,KSLP1		;ELSE LOOK AT NEXT JOB
	MOVSI	T3,(T1)			;GET JOB NUMBER
	GETTAB	T3,			;AND JBTSTS WORD
	  JRST	KSYS2			;SHOULD NEVER HAPPEN
	TLNN	T3,JNA			;IS IT A JOB?
	AOJA	T1,KSLP1		;NO.
	TLNN	T3,JACCT		;IS IT GODLY?
	JRST	KSYS4			;NO--NOT A DAEMON
	MOVS	T3,T1			;COPY JOB NUMBER
	HRRI	T3,JBTPRG		;GET PROGRAM NAME
	GETTAB	T3,			;FROM THE MONITOR
	  STOPCD .			;MUST BE THERE
	CAMN	T3,[SIXBIT /DAEMON/]	;IS IT A DAEMON
	AOJA	T1,KSLP1		;YES--DO NOT KSYS
KSYS4:	PUSHJ	P,CHKATT		;SEE IF ATTACHED
	  SKIPA				;NO--GO KILL OFF
	AOJA	T1,KSLP1		;YES--REAL USER
	POP	P,T2			;RESTORE LINE NUMBER
	HRLZ	T2,T2			;PUT IN LEFT HALF
	HRR	T2,T1			;PUT JOB IN RH
	TLO	T2,(1B0)		;COMMAND LEVEL
	ATTACH	T2,			;ATTACH
	  AOJA	T1,KSLP1		;OOPS
	MOVEI	PT1,[ASCIZ /HALT
DCORE KSYS
FINISH
GET SYS:INITIA
CSTART
;DET
/]
	PUSHJ	P,PTMOUT		;PUMP THE MESSAGE OVER
	JRST	KJOBS			;LOOP FOR MORE JOBS
KSYS2:	POP	P,T1			;CLEAN UP PDL
	POPJ	P,			;RETURN

;CHECK TO SEE IF ATTACHED (ARGS T1=JOB # T2=ADDR. OF DDB)
; SKIP RETURNS IF ATTACHED

CHKATT:	HRRZ	T3,T1			;COPY JOB NO.
	TRMNO.	T3,			;GET LINE NUMBER
	  JRST	.+2			;UUO FAILED
	JRST	CPOPJ1			;HAS LINE # MUST BE
					; ATTACHED
	JUMPE	T3,CPOPJ		;UUO WORKED
					; ASSUME DETACHED
	MOVEI	T3,DDBLDB(T2)		;OLD MONITOR
	PEEK	T3,			;GO LOOK AT CORE
	TRNE	T3,-1			;REAL LDB LINK
	AOS	(P)			;YES--WIN
	POPJ	P,			;RETURN
SUBTTL	:CONTINUE COMMAND

	IFN	FTAUTO,<
CONT:	MOVEI	T1,AUTOC
	DEVCHR	T1,
	JUMPE	T1,CNTCON
	TLO	F,AUTOM
	POPJ	P,
>
SUBTTL	:HELP COMMAND

HELP:	PUSH	P,SJB		;SAVE SUBJOB NUMBER
	PUSH	P,LASU		;SAVE LAST REFERENCE
	PUSHJ	P,FSUB		;FIND A FREE PTY
	  POPJ	P,		;NONE--CAN NOT HELP YOU
	PUSHJ	P,IPTY		;INIT A PTY
	  POPJ	P,		;OUT OF PTY'S
	MOVEI	PT1,[ASCIZ /HELP OPSER
/]
	PUSHJ	P,PTMOUT	;GIVE THE LINE TO THE PTY
	PUSHJ	P,DUMPT		;DO THE OUTPUT TO THE PTY
	PUSHJ	P,LOOP10	;GET THE TEXT
	POP	P,LASU		;RESTORE DEFAULTS
	POP	P,SJB		; ..
	POPJ	P,		;RETURN
SUBTTL	:DEFINE COMMAND

SJNAM:	JUMPL	F,TOOFEW		;MUST HAVE SOME ARGUMENTS
	PUSHJ	P,SIXIN			;GET SIXBIT WORD
	JUMPE	CMD,CMDERR		;NO NULLS ALLOWED
	CAIE	DATA,"="		;MUST END WITH EQUALS
	PJRST	CMDERR			;ERROR
	CAMN	CMD,[SIXBIT /ALL/]	;ALL?
	PJRST	NOALL			;YES--COMMAND ERROR
	LDB	T1,[POINT 6,CMD,5]	;GET FIRST CHAR.
	CAIL	T1,'A'			;LESS THAN A
	CAILE	T1,'Z'			;GREATER THAN Z
	PJRST	CMDERR			;YES--COMMAND ERROR
	PUSH	P,CMD			;SAVE ON PDL
	PUSHJ	P,WHATJB		;GET SUBJOB REF
	  PJRST	XPOPJ			;TYPO
	POP	P,CMD			;RESTORE CMD
	TRNE	SJB,1B18		;CANNOT USE ALL HERE
	PJRST	NOALL			;TELL HIM
	TDNN	F,USE(SJB)		;MUST BE IN USE
	PJRST	NOTACT			;NOT IN USE
	PUSHJ	P,ONLY1			;NO LIST ALLOWED
	MOVSI	T1,NPTLTH		;MAKE XWD PTR
	CAME	CMD,MNEMON(T1)		;SKIP IF DUPLICATE
	AOBJN	T1,.-1			;LOOP FOR ENTIRE TABLE
	JUMPGE	T1,STORE		;NO MATCH - GO STORE
	TLZ	T1,-1			;ZERO LH
	CAIN	T1,(SJB)		;SKIP IF NOT NEW ONE
	POPJ	P,			;RE-TYPE
	SETZM	MNEMON(T1)		;ZERO OLD LOC
	MOVEM	CMD,MNEMON(SJB)		;INSERT NEW ONE
	PUSHJ	P,DECOUT		;TYPE NUMBER
	PJSP	PT1,MOUT		;AND THIS MESSAGE
	ASCIZ	/ Was mnemonic's old value
/
STORE:	MOVEM	CMD,MNEMON(SJB)		;STORE IN TABLE
	POPJ	P,			;RETURN
SUBTTL	:WHAT COMMAND

WHAT:	PUSH	P,[TSTAT]		;PUSH ADDR OF SUBR
	PUSHJ	P,RUNSA			;GO EXECUTE
	IFN	FTAUTO,<
	SKIPN	T3,ATOTIM		;SKIP IF AUTO FILE PENDING
>
	POPJ	P,			;ELSE RETURN
	IFN	FTAUTO,<
	PUSHJ	P,LOUD			;TURN ON TTY
	MOVEI	PT1,[ASCIZ /
Next AUTO file at /]
	PUSHJ	P,MOUT			;TYPE THE NOISE
	PUSHJ	P,GETUPT		;GET THE UP TIME
	SUB	T3,T1			;GET THE DISTANCE AWAY
	MSTIME	T1,			;GET THE CURRENT TIME
	ADD	T1,T3			;GET TIME OF DAY
	IDIV	T1,[DEC 24*60*60*1000]	;MAKE MOD 1 DAY
	MOVE	T1,T2			;USE REMAINDER
	PUSH	P,[TTYOUT]		;OUTPUT TO TTYOUT
	PUSHJ	P,HAVTIM		;TYPE AS TIME
	PJRST	CRLF			;GIVE A CRLF AND RETURN
>


TSTAT:	PUSHJ	P,LOUD			;TURN ON TTY
	PUSHJ	P,PUTNAM		;TYPE SUBJOB NAME
	PUSHJ	P,TABOUT		;AND A TAB

	PUSHJ	P,ISJOB			;SKIP WITH JNA ON - LOAD MJOB
	  PJRST	NOTLOG			;CANNOT DO WITH JNA OFF
	HRRZ	T1,MJOB			;LOAD JOB NUMBER
	PUSHJ	P,DECOUT		;TYPE IT
	PUSHJ	P,TABOUT		;FOLLOWED BY A TAB

	HRLZ	T4,MJOB			;LOAD JOB INTO LH
	HRRI	T4,PRJPRG		;SET FOR PPN
	GETTAB	T4,			;GET FROM MONITOR
	  SETZ	T4,			;FUNNY ERROR RETURN
	SETZM	DGTCNT			;ZERO DIGIT COUNT
	HLRZ	T1,T4			;PUT PROJ# IN T1
	PUSHJ	P,OCTOUT		;TYPE THAT
	PUSHJ	P,COMOUT		;TYPE A COMMA
	HRRZ	T1,T4			;LOAD PROG# INTO T1
	PUSHJ	P,OCTOUT		;TYPE THAT
	PUSHJ	P,TABOUT		;SPACE OVER
	MOVE	T1,DGTCNT		;LOAD DIGIT COUNT
	CAIGE	T1,7			;SKIP IF MORE THAN 7
	PUSHJ	P,TABOUT		;TYPE ANOTHER TAB

	HRLZ	T1,MJOB			;PUT JOB IN LH
	HRRI	T1,JBTPRG		;GET PROGRAM NAME
	GETTAB	T1,			;FROM MONITOR
	  MOVE	T1,[SIXBIT/? ?????/]	;LOAD BONER RETURN
	PUSHJ	P,SIXBP			;PRINT THAT
	PUSHJ	P,TABOUT		;AND A TAB
	HRLZ	T2,MJOB			;PUT JOB IN LH
	HRRI	T2,JBTSTS		;GET JOB STATUS
	GETTAB	T2,			;FROM MONITOR
	  SETZ	T2,			;TAKE 0 FOR DEFAULT
	MOVEI	T1,'^C'			;LOAD DEFAULT ^C
	JUMPGE	T2,GOTSTA		;JUMP IF RUN BIT OFF
	LDB	T3,[POINT JWSIZ,T2,JWPOS]
	IDIVI	T3,3
	HRLZ	T1,T3			;PUT QUOTIENT IN LH
	HRRI	T1,STSTBL		;SIXBIT JOB QUEUE CODES
	GETTAB	T1,			;FROM MONITOR
	  MOVE	T1,CTBL(T3)		;LOAD LEVEL-C DEFAULTS
	LDB	T1,PTRS(T4)		;GET APPROPRIATE 2 CHARS
	CAIE	T1,'SL'			;IS JOB IN SLEEP QUEUE?
	JRST	GOTSTA			;NO--PRINT STATE
	TRNN	T2,CLKR			;CLOCK REQUEST?
	MOVEI	T1,'HB'			;NO--JOB IS HIBERING
GOTSTA:	ROT	T1,-^D12		;LEFT JUSTIFY
	PUSHJ	P,SIXBP			;TYPE SIXBIT
	TLNN	T2,JSWP			;SKIP IF LOWSEG IS SWAPPED
	JRST	NOLSWP			;NOT
	PUSHJ	P,SPOUT			;TYPE A SPACE
	HRLZ	T2,MJOB			;PUT JOB IN LH
	HRRI	T2,JBTSWP		;SET UP FOR SWAPPER DATA
	GETTAB	T2,			;ASK MONITOR FOR IT
	  SETZ	T2,			;MYSTERIOUS NO
	MOVSI	T1,'SW '		;DEFAULT SW
	SKIPGE	T2			;SKIP IF NOT FRAGMENTED
	MOVSI	T1,'SF '		;REPLACE SW WITH SF
	PUSHJ	P,SIXBP			;TYPE STATE
NOLSWP:	PUSHJ	P,TABOUT		;TAB OVER
	HRRZ	T1,MJOB			;LOAD JOB NBR INTO T1
	RUNTIM	T1,			;GET MILLISEC RUNTIME
	PUSH	P,[TTYOUT]		;SEND TO TTY
	PUSHJ	P,HAVTIM		;TYPE ON CONSOLE THE TIME
	TLNN	F,MSH			;LONG MODE?
	PJRST	CRLF			;CONCLUDE WITH CR-LF
	PUSHJ	P,TABOUT		;PUT OUT A TAB
	PUSHJ	P,UJBSTS		;GET THE JOB STATUS
	MOVE	T2,[ASCII .     .]	;SET UP A BLANK WORD
	TLNE	T1,(JSJLOG)		;LOGGED IN
	TLC	T2,(<"L"+" ">B6)	;YES--MAKE AN L
	TLNE	T1,(MONMOD)		;MONITOR MODE?
	TLC	T2,(<"M"+" ">B13)	;YES--MAKE AN M
	TLNE	T1,(INREQ)		;INPUT REQUEST?
	TLC	T2,15			;YES--MAKE AN H
	TLNE	T1,(OUTRDY)		;OUTPUT READY
	TRC	T2,<"O"+" ">B27		;YES--MAKE AN O
	TLNE	T1,(JSACCT)		;IS THE PRIV BIT ON?
	TRC	T2,<"A"+" ">B34		;YES MAKE AN A
	TLNE	T2,1			;INREQ?
	TRO	T2,100000		;CONVERT H TO I
	MOVEI	PT1,T2
	SETZ	T3,			;MAKE A NULL
	PUSHJ	P,MOUT			;PRINT
	PJRST	CRLF			;END WITH CRLF
PTRS:	POINT	12,T1,11
	POINT	12,T1,23
	POINT	12,T1,35


CTBL:	SIXBIT	.RNWSTS.
	SIXBIT	.STAUMQ.
	SIXBIT	.DADTDC.
	SIXBIT	.MTIOTT.
	SIXBIT	.SLNL^C.
	SIXBIT	.??????.
SUBTTL	:AUTO COMMAND

	IFN	FTAUTO,<
AUTO:	PUSHJ	P,TIMEAF		;SEE IF TIME-OF-DAY FILE
	  POPJ	P,			;IT WAS ALL DONE.
	PUSHJ	P,GETSPC		;GET FILSPEC
	  POPJ	P,			;RETURN ON ERROR
FAUTO:	SKIPN	T1			;SKIP IF DEVICE TYPEIN
	MOVSI	T1,'DSK'		;GIVE HIM DISK
	MOVEM	T1,BLK3+1		;STORE IN OPEN BLOCK
	DEVCHR	T1,			;GET CHARACTERISTICS
	JUMPE	T1,NOBE			;JUMP IF NON-EXISTANT
	TLNN	T1,DVIN			;SKIP IF INPUT DEVICE
	PJRST	NOTIN			;NOT - FLAG HIM
	MOVEI	T1,AUTIB		;LOAD ADDR OF IBUF HDR
	MOVEM	T1,BLK3+2		;STORE IN OPEN BLOCK
	PUSHJ	P,AUTREL		;RELEASE OLD CHANNEL, IF ANY
	OPEN	AUTOC,BLK3		;OPEN NEW ONE
	  PJRST	NOINTX			;SOMEONE ELSE HAS DEVICE
	TLO	F,AUTOM			;SET AUTO BIT
	PUSH	P,.JBFF			;PUT .JBFF ON PDL
	INBUF	AUTOC,3			;FILL TO 2K MARK IN LOWSEG
	POP	P,.JBFF			;RESTORE .JBFF
	MOVE	T1,BLK3+1		;GET BACK DEVNAM
	DEVCHR	T1,			;GET CHARS
	TLNN	T1,DVDIR		;SKIP IF IT HAS A DIRECTORY
	POPJ	P,			;NONE - RETURN NOW
	SKIPN	T1,T2			;LOAD FILNAME INTO T1
	MOVE	T1,[SIXBIT/OPSER/]	;LOAD DEFAULT
	SKIPE	T2,T3			;SKIP IF NO EXT TYPED
	TRZA	T2,T2			;ZERO RH
	MOVSI	T2,'ATO'		;LOAD DEFAULT
	SETZ	T3,			;ZERO T3
	LOOKUP	AUTOC,T1		;TRY TO LOOKUP FILE
	  PJRST	CNFND			;NO SOAP
	POPJ	P,			;OK - RETURN

CNFND:	PUSHJ	P,AUTREL		;RELEAS AUTO CHANNEL
	MOVEI	PT1,[ASCIZ/? LOOKUP failure /]
	PUSHJ	P,MOUT			;TYPE REASON FOR FAILURE
	HRRZ	T1,T2			;LOAD ERROR CODE INTO T1
	PUSHJ	P,OCTOUT		;TYPE ON CONSOLE
	PJRST	CRLF			;SUFFIX WITH CR-LF
AUTREL:	TLZ	F,AUTOM			;ZERO BIT
	RELEAS	AUTOC,			;RELEASE CHANNEL
	PUSH	P,T1			;SAVE T1
	HLRZ	T1,.JBSA		;GET ORIGINAL .JBFF
	TRO	T1,1777			;ROUND TO NEAREST K
	CORE	T1,			;RESET LOWSEG CORE
	  JFCL				;WHY I DON'T KNOW
	POP	P,T1			;RESTORE T1
	POPJ	P,			;RETURN


NOTIN:	PJSP	PT1,MOUT
	ASCIZ	/? Device cannot do input
/
;HERE TO DO TIME-OF-DAY AUTO FILES

TIMEAF:	JUMPL	F,CPOPJ1		;RETURN IF EOL
	PUSHJ	P,SAVACS		;SAVE THE ACS
	PUSHJ	P,STTYIN		;GET NEXT NON-BLANK
	CAIE	DATA,"/"		;SWITCH?
	JRST	NOSWT			;NO--THEN NO SWITCH
	JUMPL	F,CPOPJ1		;TRANSFER IF EOL
	PUSHJ	P,TTYIN			;GO GET A CHAR
	CAIE	DATA,"+"		;TIME FROM NOW?
	JRST	TIMABS			;NO ABSOLUTE TIME
	PUSHJ	P,TTYIN			;GET A CHAR
	PUSHJ	P,TIMEX			;GET THE TIME
	  POPJ	P,			;SYNTAX ERROR
TIMSTR:	PUSHJ	P,SETDAE		;POKE DAEMON
	PUSHJ	P,GETSPC		;GET THE FILSPEC
	  POPJ	P,			;ERROR
	MOVE	CMD,[T1,,ATOT1]		;STORE THE AC'S BACK
	BLT	CMD,ATOT5		; UNTIL I NEED THEM
	POPJ	P,			;RETURN

TIMABS:	PUSHJ	P,TIMEX			;GET THE TIME
	  POPJ	P,			;SYNTAX ERROR
	TIMER	T1,			;GET CURRENT TIME OF DAY
	SUB	CMD,T1			;GET JIFFIES TO WAIT
	JUMPLE	CMD,CPOPJ1		;SKIP RETURN IF PAST
	JRST	TIMSTR			;GO STORE THE TIME

TIMEX:	PUSHJ	P,RDX60			;GET TIME OF DAY
	  POPJ	P,			;SYNATX ERROR
	IMULI	CMD,^D60000		;CONVERT TO MS
	JRST	CPOPJ1			;RETURN
NOSWT:	MOVEM	DATA,SAVCH		;STORE CHAR
	JRST	CPOPJ1			;RETURN
SETDAE:	PUSHJ	P,GETUPT		;GET THE UPTIME
	ADD	T1,CMD			;TIME TO GET UP
	MOVEM	T1,ATOTIM		;TIME TO GET UP
>
SETDA1:	MOVE	T1,[SYSKTM,,NSWTBL]	;GET THE TIME
	GETTAB	T1,			; TO KSYS
	  SETZ	T1,			;FROM THE MONITOR
	SUB	T1,@WARNTM		;FIX FOR WARNINGS
	IMULI	T1,^D60000		;CONVERT TO SECONDS
	SKIPG	T1			;ZERO?
	HRLOI	T1,377777		;YES--MAKE LARGE
	CAMG	T1,CMD			;DOES END COME FIRST?
	MOVE	CMD,T1			;YES--SET THE SHORTER LIMIT
	IDIVI	CMD,^D1000		;CONVERT TO SECONDS
	MOVE	T1,[2,,T2]		;2 WORDS IN T2 AND T3
	MOVEI	T2,.CLOCK		;FUNCTION
	MOVEI	T3,(CMD)		;ARGUMENT
	DAEMON	T1,			;LINE UP FOR JD WAIT
	  PJRST CHKDAE			;SEE WHAT WENT WRONG
	POPJ	P,			;RETURN
SUBTTL	:DEVICE COMMAND

DEVREQ:	JUMPL	F,TOOFEW		;MUST BE SOME MORE TYPEIN
	PUSHJ	P,SIXIN			;GET DEVNAM
	JUMPE	CMD,CMDERR		;NO NULLS
	CAIE	DATA,":"		;MUST END IN COLON
	PJRST	CMDERR			;BOO-BOO
	MOVE	T1,CMD			;STORE IN T1
	PUSHJ	P,SIXIN			;GET DEVLOG
	CAIE	DATA,":"		;MUST END IN COLON
	PJRST	CMDERR			;TELL HIM OF ERROR
	MOVE	T2,CMD			;LOAD INTO T2
	PUSHJ	P,WHATJB		;WHAT SUBJOB GETS DEVICE
	  POPJ	P,			;TYPO
	TRNE	SJB,1B18		;SKIP IF NOT ALL
	PJRST	NOALL			;TELL HIM JUST ONE
	TDNN	F,USE(SJB)		;SKIP IF IN USE
	PJRST	NOTACT			;NOT ACTIVE
	PUSHJ	P,ONLY1			;ACCEPT ONLY FIRST ARG
CHK20:	SKIPN	T3,T2			;LOAD LOGICAL NAME
	MOVE	T3,T1			;NO, TAKE PHYSICAL NAME
	DEVCHR	T3,			;GET CHARACTERISTICS
	TRNE	T3,ASSCON		;SKIP IF ASSIGNED BY CONSOLE
	JRST	GOAHD3			;IT IS - DO REASSIGN
	PUSH	P,F			;SAVE FLAGS
	TLZ	F,AUTOM!QUIET!AUXQ	;TURN OFF ALL SILENCE FLAGS
	MOVEI	PT1,[ASCIZ/Type "ASSIGN /]
	PUSHJ	P,MOUT			;STICK INTO OUTPUT BUFFER
	PUSHJ	P,SIXBP			;PRINT PHYSICAL NAME
	JUMPE	T2,FINLX		;JUMP IF NO LOGICAL NAME
	PUSHJ	P,COLOUT		;TYPE A COLON
	EXCH	T1,T2			;PUT LOGICAL NAME IN T1
	PUSHJ	P,SIXBP			;TYPE THAT
	EXCH	T1,T2			;RESTORE AC'S
FINLX:	MOVEI	PT1,[ASCIZ/<cr>CONTINUE<cr>"/]
	PUSHJ	P,MOUT			;FINISH OFF MESSAGE
	POP	P,F			;RESTORE FLAGS
	MONRET				;RETURN TO MONITOR
	JRST	CHK20			;LOOP

GOAHD3:	SKIPN	T4,T2			;PUT LOG NAME INTO T4
	MOVE	T4,T1			;NO LOG NAME - USE PHYSICAL NAME
	PUSHJ	P,UJBSTS		;GET JOBSTS
	HRRZ	T3,T1			;PUT JOB NUMBER INTO T3
	REASSI	T3,			;REASSIGN THE DEVICE
	POPJ	P,			;AND RETURN
SUBTTL	:CLOSED - :TLOG

	IFN	FTTLOG,<

CLOSED:	TLZ	F,OFILE			;ZERO FILE OPENED BIT
	RELEAS	LOGC,			;RELEASE LOG FILE
	POPJ	P,			;RETURN NOW

TLOG:	PUSHJ	P,CLOSED		;CLOSE LOG FILE
	PUSHJ	P,GETSPC		;GET FILSPEC
	  POPJ	P,			;ERROR RETURN
	SKIPN	T1			;SKIP IF DEVSPEC
	MOVSI	T1,'DSK'		;LOAD DEFAULT DISK
	MOVEM	T1,BLK3+1		;STORE IN OPEN BLOCK
	DEVCHR	T1,			;GET CHARACTERISTICS
	JUMPE	T1,NOBE			;IF NULL, NO SUCH DEV
	TLNN	T1,DVOUT		;SKIP IF CAN DO OUTPUT
	PJRST	NOTOUT			;CANNOT DO
	MOVEM	T1,LOGFIL		;STORE IN CORE
	MOVSI	T1,LOGOB		;LOAD ADDR OF OUTPUT BUF IN LH
	MOVEM	T1,BLK3+2		;STORE IN OPEN BLOCK
	OPEN	LOGC,BLK3		;OPEN DEVICE
	  PJRST	NOINTX			;NOT AVAILABLE
	MOVEI	T1,LOGOBB		;LOAD ADDR OF BUFFERS
	EXCH	T1,.JBFF		;STICK IN .JBFF
	OUTBUF	LOGC,1			;ALWAYS 1 BUFFER
	MOVEM	T1,.JBFF		;RESTORE .JBFF
	SKIPN	T1,T2			;LOAD FILNAME IN T1
	MOVE	T1,[SIXBIT/OPSER/]	;THAT IS DEFAULT
	MOVEM	T1,LOGFIL+1		;STORE IN CORE
	SKIPE	T2,T3			;LOAD EXT INTO T2
	TRZA	T2,-1			;ZERO RH
	MOVSI	T2,'LOG'		;DEFAULT IS LOG
	MOVEM	T2,LOGFIL+2		;REMEMBER THAT TOO
	MOVEM	T4,LOGFIL+3		;STORE PPN
	PUSHJ	P,UPDATE		;ACCESS FILE
	  POPJ	P,			;FAILURE
	TLO	F,OFILE!QUIET		;ANNOUNCE OPENING WITH SILENCE
	SETOM	FRCLOG		;FORCE THIS STUFF OUT TO LOG
	MOVEI	PT1,[	BYTE(7)CR,FF,TAB,"O","P"
			ASCIZ/SER TRANSACTION LOG

	/]
	PUSHJ	P,MOUT
	MOVE	T3,[-5,,LOGNAM]		;POINTER TO GETTAB NUMBERS
	HRRZI	T2,CNFTBL		;SET UP TO GET SYSTEM NAME
TLOG1:	MOVE	T1,T2			;GET ARGUMENT
	GETTAB	T1,			;GET WORD OF NAME
	  SETZ	T1,			;ERROR RETURN = NULL
	MOVEM	T1,(T3)			;STORE IN BUFFER
	ADD	T2,[1,,0]		;NEXT WORD
	AOBJN	T3,TLOG1		;AND LOOK AT NEXT, IF ANY
	MOVEI	PT1,LOGNAM		;GET POINTER TO BUFFER
	PUSHJ	P,MOUT			;AND OUTPUT IT
	PUSHJ	P,TABOUT		;OUTPUT A TAB
	MOVE	T1,[5,,CNFTBL]		;POINTER TO FIRST WORD OF SYSDAT
	GETTAB	T1,			;GET WORD
	  SETZ	T1,			;ERROR RETURN=NULL
	MOVEM	T1,LOGDAT		;PUT IN BUFFER
	MOVE	T1,[6,,CNFTBL]
	GETTAB	T1,
	  SETZ	T1,
	MOVEM	T1,LOGDAT+1		;SECOND WORD OF DATE
	MOVEI	PT1,LOGDAT
	PUSHJ	P,MOUT
	PUSHJ	P,CRLF
	PUSHJ	P,CRLF
	DATE	T1,			;WHAT'S TODAYS DATE
	IDIVI	T1,^D31			;GET DAY-1 IN T2
	PUSH	P,T1			;SAVE QUOTIENT ON PDL
	MOVEI	T1,1(T2)		;LOAD DAY INTO T1
	PUSHJ	P,DECOUT		;TYPE IN DECIMAL
	POP	P,T1			;RESTORE QUOT
	IDIVI	T1,^D12			;LEAVE MONTH-1 IN T2
	PUSH	P,T1			;SAVE QUOT AGAIN
	MOVE	T1,MONTAB(T2)		;GET SIXBIT TYPOUT
	PUSHJ	P,SIXBP			;SEND THAT
	POP	P,T1			;GET YEAR BACK
	ADDI	T1,^D64			;SUM TO TODAY'S YEAR MOD 100
	PUSHJ	P,DECOUT		;TYPE IN DECIMAL
	PUSHJ	P,TABOUT		;TAB OVER
	PUSH	P,[EXP DSKOUT]		;PUSH ADDR OF ROUTINE
	PUSHJ	P,TIMOUT		;SEND THE CURRENT TIME
	MOVEI	PT1,[ASCIZ/
	Job /]
	PUSHJ	P,MOUT			;SEND THAT
	PJOB	T1,			;GET MY JOB NUMBER
	PUSHJ	P,DECOUT		;TYPE IN DECIMAL
	MOVEI	PT1,[ASCIZ/		[/]
	PUSHJ	P,MOUT			;TYPE THAT
	GETPPN	T1,			;GET MY PROJ,PROG
	  JFCL				;SOMETIME NON-SKIP
	PUSH	P,T1			;SAVE ON STACK
	HLRZ	T1,T1			;PUT PROJ IN T1
	PUSHJ	P,OCTOUT		;TYPE IN OCTAL
	PUSHJ	P,COMOUT		;AND A COMMA
	POP	P,T1			;RESTORE PPN
	TLZ	T1,-1			;ZERO LH
	PUSHJ	P,OCTOUT		;TYPE IN OCTAL
	MOVEI	PT1,[ASCIZ	/
/]
	PUSHJ	P,MOUT			;LIST CRLF
	SETZM	FRCLOG			;CLEAR FLAG
	POPJ	P,			;AND RETURN
;SUBR TO PERFORM LOOKUP,ENTER,USETO SEQUENCE TO APPEND TO FILE

UPDATE:	MOVE	T1,LOGFIL+1		;RETRIEVE FILNAME
	MOVE	T2,LOGFIL+2		;AND EXTENSION
	SETZ	T3,			;ZILCH THAT OUT
	MOVE	T4,LOGFIL+3		;GET PPN
	MOVEI	T5,1			;LOAD DEFAULT USETO BLK
	LOOKUP	LOGC,T1			;TRY TO FIND FILE
	  JRST	DENTER			;NOT THERE - DO ENTER
	HLRE	T3,T4			;GET LENGTH IN T3
	JUMPGE	T3,GBLKN		;JUMP IF BLOCKS GIVEN
	IDIV	T3,[-<DSKSIZ-3>]	;COMPUTE NBR OF BLOCKS
	SKIPE	T4			;SKIP IF NO REMAINDER
	ADDI	T3,1			;WRITE AFTER PARTIALLY USED BLK
GBLKN:	MOVEI	T5,1(T3)		;LOAD LENGTH+1

DENTER:	MOVE	T1,LOGFIL+1		;RELOAD FILNAME
	MOVE	T2,LOGFIL+2		;AND EXTENSION
	SETZ	T3,			;ZERO OUT THAT
	MOVE	T4,LOGFIL+3		;RELOAD PPN
	ENTER	LOGC,T1			;ENTER FILE
	  PJRST	NOENT			;CANNOT DO
	OUTPUT	LOGC,			;DO DUMMY LOGOUT
	USETO	LOGC,(T5)		;SELECT BLOCK
	PJRST	CPOPJ1			;GIVE SKIP RETURN
NOENT:	PUSHJ	P,CLOSED		;FINISH OFF OLD ONE
	MOVEI	PT1,[ASCIZ/? ENTER failure /]
	PUSHJ	P,MOUT			;TYPE THAT
	HRRZ	T1,T2			;LOAD ERROR CODE INTO T1
	PUSHJ	P,OCTOUT		;AND TYPE IN OCTAL
	PJSP	PT1,MOUT		;END WITH THIS MESSAGE
	ASCIZ	/ on LOG file
/


DSKOUT:	TLNN	F,OFILE			;SKIP IF FILE OPENED
	POPJ	P,			;IGNORE CHAR
	SOSLE	LOGOB+2			;SKIP IF BUFFER FULL
	JRST	PUTB9			;MORE ROOM
	PUSHJ	P,SAVACS		;SAVE REGISTERS
	CLOSE	LOGC,			;CLOSE FILE - RETAIN CHANNEL
	PUSHJ	P,UPDATE		;RE-OPEN FILE
	  POPJ	P,			;UNSUCCESSFUL
PUTB9:	IDPB	DATA,LOGOB+1		;STORE IN BUFFER
	POPJ	P,			;RETURN


NOTOUT:	PJSP	PT1,MOUT		;TYPE MESSAGE
	ASCIZ	/? Device cannot do output
/
MONTAB:	SIXBIT	/-JAN-/
	SIXBIT	/-FEB-/
	SIXBIT	/-MAR-/
	SIXBIT	/-APR-/
	SIXBIT	/-MAY-/
	SIXBIT	/-JUN-/
	SIXBIT	/-JUL-/
	SIXBIT	/-AUG-/
	SIXBIT	/-SEP-/
	SIXBIT	/-OCT-/
	SIXBIT	/-NOV-/
	SIXBIT	/-DEC-/
>
SUBTTL	SUBROUTINE TO GET A FILSPEC

;CALLED BY	PUSHJ	P,GETSPC
;		  ERROR
;		NORMAL
;
;ON SUCCESSFUL RETURN, REGISTERS T1 THRU T4 ARE LOADED AS FOLLOWS:
;	T1 = DEVICE SPEC
;	T2 = FILE NAME
;	T3 = EXTENSION
;	T4 = PPN
;IF NO TYPEIN WAS GIVEN FOR A CATEGORY, 0 IS RETURNED IN THE REGISTER

	IFN	FTTLOG!FTAUTO,<
GETSPC:	SETZB	T1,T2			;ZERO OUT ALL TO START
	SETZB	T3,T4
	JUMPL	F,CPOPJ1		;RETURN NOW IF DONE
	PUSHJ	P,SIXIN			;GET SIXBIT WORD
	CAIE	DATA,":"		;SKIP IF DEVICE SPEC
	JRST	NOTDEV			;I GUESS NOT
	MOVE	T1,CMD			;STICK IN APPROPRIATE AC
	PUSHJ	P,SIXIN			;GET NEXT WORD
NOTDEV:	MOVE	T2,CMD			;LOAD FILNAME
	JUMPL	F,CPOPJ1		;RETURN IF DONE
	CAIE	DATA,"."		;SKIP IF EXTENSION
	JRST	MBPPN			;NOPE - MAYBE A PPN
	PUSHJ	P,SIXIN			;LOAD THAT
	HLLO	T3,CMD			;LOAD EXT INTO AC
	JUMPL	F,CPOPJ1		;RETURN IF LINE DONE
MBPPN:	CAIE	DATA,"["		;SKIP IF START OF PPN
	PJRST	BADFIL			;BAD FILSPEC
	PUSHJ	P,OCTIN			;GET FIRST NUMBER
	CAIN	DATA,","		;MUST END WITH COMMA
	TLNE	CMD,-1			;AND BE LESS THAN 777777
	PJRST	BADFIL			;IT WASN'T
	HRLZ	T4,CMD			;STICK IN LH OF T4
	PUSHJ	P,OCTIN			;GET PROGRAMMER NUMBER
	CAIN	DATA,"]"		;CHECK FOR CLOSE BRACKET
	TLNE	CMD,-1			;AND LT 777777
	PJRST	BADFIL			;TYPO
	HRRI	T4,(CMD)		;LOAD INTO RH OF T4
	PUSHJ	P,STTYIN		;GET NEXT NON-BLANK CHAR
	JUMPL	F,CPOPJ1		;IF BREAK CHAR, A.O.K.
BADFIL:	PJSP	PT1,MOUT		;TYPE ANNOYING MESSAGE
	ASCIZ	/? Bad file spec
/
>
SUBTTL	SUBROUTINES

;CALLED BY	PUSH	P,[ADDR]
;		PUSHJ	P,RUNSUB
;		ALWAYS RETURN
;
; RUNSUB WILL CALL THE SUBROUTINE AT ADDR, AND WILL PERFORM ALL
;MANIPULATIONS OF REGISTER SJB INCLUDING ACTIVITY CHECKS AND
;ALL EXPANSIONS.  IT ENDS BY POPPING THE RETURN PC ONTO THE
;PUSHED ARGUMENT AND POPJ'ING, SO THE CALLER SHOULD NOT DO A
;POP UPON RETURN TO CLEAR THE STACK

RUNSUB:	TRNN	SJB,1B18		;SKIP IF ALL
	JRST	RUNONE			;NOT ALL - JUST ONE ARG
	MOVSI	SJB,NPTLTH		;MAKE AOBJN WORD
RUNSU0:	TDNE	F,USE(SJB)		;SKIP IF THIS ONE'S FREE
	PUSHJ	P,@-1(P)		;PUSHJ TO SUBROUTINE
	  JFCL				;IGNORE ERRORS
	AOBJN	SJB,RUNSU0		;LOOP FOR ALL
	MOVNI	SJB,1			;MAKE ALL AGAIN
	PJRST	APOPJ			;CLEAR PDL & RETURN

RUNONE:	TDNN	F,USE(SJB)		;SKIP IF IN USE
	JRST	RUNER1			;NOT - ERROR
	PUSHJ	P,@-1(P)		;CALL SUBROUTINE
	  JFCL				;DON'T CARE ABOUT ERRORS
	PJRST	APOPJ			;CLEAR STACK & POPJ

RUNER1:	POP	P,-1(P)
	PJRST	NOTACT
;CALLED BY	PUSH	P,[ADDR]
;		PUSHJ	P,RUNSA
;		ALWAYS RETURN
;
; RUNSA INTERPRETS SUBJOB LISTS IN COMMANDS AND CALLS SERIALLY
;THE SUBRROUTINE AT ADDR.  RUNSA ALSO CLEARS THE STACK OF THE
;PUSHED ARG BEFORE RETURNING.

RUNSA:	PUSHJ	P,WHATJB		;WHAT SUBJOB REF?
	  PJRST	APOPJ			;CLEAR STACK AND RETURN
	PUSH	P,-1(P)			;PUT ADDR ON TOP OF STACK
	PUSHJ	P,RUNSUB		;AND CALL RUNSUB
	TLNE	F,WASCOM		;WAS LAST DELIMITER A COMMA
	JRST	RUNSA			;YES, GO GET NEXT ARG
	PJRST	APOPJ			;NO, RETURN NOW



;CALLED BY	MOVEI	SJB,NNN
;		PUSHJ	P,CSTOP
;		  HERE IF STOPPED IN ^C
;		HERE IF NOT

CSTOP:	PUSHJ	P,UJBSTS		;GET JOBSTS
	SETCA	T1,T1			;COMPLEMENT RESULT
	TLNE	T1,(MONMOD!INREQ)	;SKIP IF BOTH WERE ON
	AOS	(P)			;NOT - INCR RETURN PC
	POPJ	P,			;RETURN
;SUBROUTINE TO START A LINE

STARTL:	TLNE	F,REPL			;SKIP IF WE MUST
	POPJ	P,
	MOVEI	DATA,"*"
	MOVSI	SJB,NPTLTH		;LOAD AOBJN WORD
STAR1:	TDNN	F,USE(SJB)		;SKIP IF IN USE
	JRST	ESTAR1			;NOT
	PUSHJ	P,UJBSTS		;GET JOBSTS
	TLNN	T1,(INREQ)		;SKIP IF IN INPUT WAIT
	SKIPA	DATA,["!"]		;LOAD THAT CHAR
ESTAR1:	AOBJN	SJB,STAR1		;LOOP FOR ALL
	PUSHJ	P,TTYOUT		;TYPE IT
	TLO	F,REPL			;REMEMBER I DID
	POPJ	P,			;RETURN
;CALLED BY	PUSHJ	P,FSUB
;		  NO FREE SUBJOBS
;		HERE WITH NBR OF FREE SJB IN AC-SJB

FSUB:	MOVSI	SJB,NPTLTH		;MAKE AOBJN XWD
FLOOP1:	TDNE	F,USE(SJB)		;SKIP IF FREE
	AOBJN	SJB,FLOOP1		;LOOP FOR ALL
	JUMPGE	SJB,NOFREE		;JUMP IF ALL IN USE
	HRRZ	LASU,SJB		;LOAD AS DEFAULT
	PJRST	CPOPJ1			;SKIP BACK



;CALLED BY	MOVEI	CMD,NNNNN
;		PUSHJ	P,SJBLIM
;		  HERE IF C(CMD) IS NOT A VALID SJB NBR
;		HERE IF OK, WITH SJB LOADED UP FROM CMD

SJBLIM:	JUMPL	CMD,OUTBND		;NO NEGATIVE SJB
	CAILE	CMD,HGHPTY		;SKIP IF UNDER LIMIT
	  PJRST	OUTBND			;NOT - PRINT ERROR MESSAGE
	MOVEI	SJB,(CMD)		;LOAD UP SJB
	MOVEI	LASU,(SJB)		;UPDATE LAST USED
	PJRST	CPOPJ1			;SKIP BACK



;CALLED BY	PUSHJ	P,CHKBAT
;		  HERE IF NO BATCON AT USER LEVEL
;		HERE IF OPSER IS RUNNING ONE

CHKBAT:	MOVSI	T1,'B  '		;LOAD NECESSARY MNEMONIC
	MOVSI	SJB,NPTLTH		;MAKE XWD
	CAME	T1,MNEMON(SJB)		;SKIP IF MATCH
	AOBJN	SJB,.-1			;LOOP FOR ALL
	JUMPGE	SJB,CPOPJ		;RETURN IF NO MATCH
	PUSHJ	P,UJBSTS		;GET JOBSTS
	TLNE	T1,(MONMOD)		;SKIP IF NOT IN MONITOR MODE
	POPJ	P,			;NOPE
	MOVS	T1,T1			;PUT JOB NUMBER IN LH
	HRRI	T1,JBTPRG		;AND PROGRAM NAME INDEX IN RH
	GETTAB	T1,			;GET FROM MONITOR TABLE
	  POPJ	P,			;STRANGE ERROR
	CAMN	T1,[SIXBIT/BATCON/]	;ACCEPTED NAME FOR BATCH
	AOS	(P)			;GIVE SKIP RETURN
	POPJ	P,			;GO BACK TO CALLER
;CALLED BY	MOVE	CMD,[SIXBIT/WORD/]
;		PUSHJ	P,FINMNE
;		  HERE IF WORD IS NOT IN MNEMONIC TABLE
;		HERE IF IT IS, WITH SJB LOADED
;
;IF C(CMD)=SIXBIT/ALL/, THE SKIP RETURN IS GIVEN WITH C(SJB)=-1

FINMNE:	JUMPE	CMD,NOMNE		;NO NULLS
	CAMN	CMD,[SIXBIT/ALL/]	;SKIP IF NOT ALL
	JRST	SETALL			;IT IS - SET REGISTERS
	MOVSI	SJB,NPTLTH		;MAKE XWD POINTER
	CAME	CMD,MNEMON(SJB)		;SKIP IF MATCH
	AOBJN	SJB,.-1			;LOOP FOR ALL
	JUMPGE	SJB,NOMNE		;JUMP IF NO MATCH AT ALL
	MOVEI	LASU,(SJB)		;UPDATE LAST USED
	PJRST	CPOPJ1			;JUMP BACK WITH SKIP

SETALL:	TRNN	F,-1			;SKIP IF ANY ARE IN USE
	PJRST	ALLFR			;ALL FREE - TELL HIM
	MOVNI	SJB,1			;PUT -1 IN SJB
	PJRST	CPOPJ1			;SKIP BACK



;CHECKING SUBJOBS FOR OUTPUT

IOCHK:	TLZ	F,PTBSY			;ZERO BIT TO START
	MOVSI	SJB,NPTLTH		;LOAD AOBJN XWD
IOCHK0:	TDNN	F,USE(SJB)		;SKIP IF IN USE
	JRST	ENDIO0			;NOT
	PUSHJ	P,UJBSTS		;GET JOBSTS
	TLNN	T1,(OUTRDY)		;SKIP IF OUTPUT AVAILABLE
	JRST	ENDIO0			;NONE
	TLO	F,PTBSY			;SET FIND BIT
	PUSHJ	P,GBUF			;GO GET BUFFER(S)
	PUSHJ	P,ISJOB			;SKIP IF JNA STILL SET
	  PUSHJ	P,RPTYN			;GO RELEAS
ENDIO0:	AOBJN	SJB,IOCHK0		;LOOP
	POPJ	P,			;RETURN
;CALLED BY	MOVEI	SJB,NNN
;		PUSHJ	P,UJBSTS
;		ALWAYS RETURN
;
;REGISTER T1 IS LOADED WITH JOBSTS

UJBSTS:	MOVEI	T1,(SJB)		;LOAD SUBJOB TO CHECK
	JOBSTS	T1,			;CHECK IT
	  STOPCD CPOPJ			;THAT SHOULDN'T HAPPEN
	POPJ	P,			;RETURN



;CALLED BY	MOVEI	SJB,NNN
;		PUSHJ	P,ISJOB
;		  HERE IF JNA OFF FOR THAT SUBJOB
;		HERE IF JNA ON, WITH MJOB LOADED WITH JOBSTS

ISJOB:	MOVE	MJOB,T1			;SAVE C(T1)
	PUSHJ	P,UJBSTS		;GET JOBSTS
	EXCH	MJOB,T1			;GET JOBSTS INTO MJOB
	JUMPL	MJOB,CPOPJ1		;SKIP IF JNA ON
	POPJ	P,			;REGULAR POPJ IF NOT
;CALLED BY	PUSHJ	P,WHATJB
;		  ERROR
;		NORMAL
;
;CALLED AT EOL SUBJOB REFERENCES

WHATJB:	TLZ	F,WASCOM		;IC'S
	MOVEI	SJB,(LASU)		;START WITH LAST USED
	JUMPL	F,CPOPJ1		;SKIP BACK IF NO INPUT
	PUSHJ	P,STTYIN		;GET FIRST NON-BLANK
	JUMPL	F,CPOPJ1		;REPEAT EOL CHECK
	CAIG	DATA,"9"		;SKIP IF OVER ASCII-9
	CAIGE	DATA,"0"		;SKIP IF OVER ASCII-0
	JRST	ALPHA2			;ALPHABETIC
	PUSHJ	P,DECINZ		;GO GET DECIMAL NUMBER
	CAIN	DATA,","		;SKIP IF NOT TERMED BY COMMA
	TLOA	F,WASCOM		;COMMA - SET BIT
	JUMPGE	F,CMDERR		;IF NOT COMMA, MUST BE EOL
	PJRST	SJBLIM			;GO CHECK LIMITS

ALPHA2:	PUSHJ	P,SIXINZ		;GET SIXBIT WORD
	CAIN	DATA,","		;DO ABOVE CHECK
	TLOA	F,WASCOM
	JUMPGE	F,CMDERR
	PJRST	FINMNE			;SEARCH MNEMONIC TABLES
;CALLED BY	MOVEI	T1,NBR
;		PUSH	P,[EXP ADDR]
;		PUSHJ	P,TIMOUT
;		ALWAYS RETURN WITH STACK ADJUSTED
;
;TYPES TIME AS LOADED INTO T1 TO OUTPUT ROUTINE AT ADDR

TIMOUT:	MSTIME	T1,			;READ CLOCK
HAVTIM:	MOVEI	T3,3			;WILL TYPE NN:NN:NN
TIME1:	IDIV	T1,DIVTBL-1(T3)		;SPLIT DIGITS DOWN
	PUSH	P,T2			;SAVE REMAINDER
	IDIVI	T1,^D10			;SPLIT INTO 2 DIGITS
	MOVEI	DATA,"0"(T1)		;LOAD FIRST IN ASCII
	PUSHJ	P,@-2(P)		;GO SEND CHAR
	MOVEI	DATA,"0"(T2)		;LOAD SECOND
	PUSHJ	P,@-2(P)		;SEND THAT TOO
	POP	P,T1			;RESTORE REMAINDER
	SOJLE	T3,APOPJ		;JUMP IF DONE
	MOVEI	DATA,":"		;LOAD COLON
	PUSHJ	P,@-1(P)		;DISPATCH
	JRST	TIME1			;SEND THAT

DIVTBL:	DEC	1000,60*1000,60*60*1000
;CONTROL-C INTERCEPT LOGIC

;CALLED BY	PUSHJ	P,INTINI
;		RETURNS HERE WITH TRAP SET
INTINI:	SKIPE	.JBDDT##		;DEBUGGING OPSER?
	POPJ	P,			;YES, DO NOT SET UP ^C TRAP
	MOVEI	T1,INTBLK		;POINT TO INTERCEPT BLOCK
	MOVEM	T1,.JBINT##		;STORE FOR CONKLIN 
	MOVEI	T1,INTRPT		;POINTER TO INTERUPT BLOCK
	MOVEM	T1,INTBLK		;STORE AWAY
	MOVEI	T1,2			;CONTROL C
	MOVEM	T1,INTBLK+1
	SETZM	INTBLK+2		;CLEAR ENABLE FLAGS
	SETZM	INTBLK+3		; ..
	POPJ	P,			;RETURN

;HERE FROM MONITOR ON A CONTROL-C

INTRPT:	TLZ	F,RENBIT		;CLEAR A BUNCH OF BITS
	TLO	F,BRK			;MAKE PTY LOOK DONE
	CLRBFI				;REMOVE THE CONTROL C
	MOVE	P,[IOWD PDLSIZ,PDL]	;RESET PDL TO TOP
	PUSHJ	P,INTINI		;RESET THE TRAP
	PUSHJ	P,FINISH		;TRY TO :EXIT
	JRST	SETUP			;ACTIVE SUBJOBS MESSAGES
					; HAVE BEEN SENT. GO BACK
					; AND LISTEN.

;GET THE UPTIME
;USES T1 AND T2 ANSWER IN T1

GETUPT:	MOVE	T1,[UPTIME,,NSWTBL]	;THIS ROUTINE DOES
	GETTAB	T1,			; THE OBVIOUS THING
	  SETZ	T1,			; OF GETTING THE UPTIME
	IMULI	T1,^D1000		; THEN CONVERTING TO
	IDIV	T1,JIFSEC		; MILLISECONDS.
	POPJ	P,			;RETURN

JIFINI:	MOVE	T1,[STATES,,CNFTBL]	;COMPUTE THE NUMBER OF
	GETTAB	T1,			;JIFFIES PER SECOND
	  SETZ	T1,			; ..
	TLNN	T1,(1B6)		;IS THE 50 CYCLE BIT ON?
	SKIPA	T1,[^D60]		;NO--ASSUME 60
	MOVEI	T1,^D50			;YES--ASSUME 50
	MOVEM	T1,JIFSEC		;STORE AWAY
	POPJ	P,

;SUBROUTINE TO TURN ON TTY OUTPUT
;CALLED BY	PUSHJ	P,LOUD
;		RETURN HERE
;BITS ARE RESTORED BY THE MATCHING POPJ. DO NOT CALL ANY TTY OR PTY
;INPUT ROUTINES WHILE STATUS BITS ARE MESSED UP.
LOUD:	MOVEM	F,SAVEF			;SAVE FLAGS
	TLZN	F,AUTOM!QUIET!AUXQ	;CLEAR SOME BITS
	POPJ	P,			;NONE SET-- JUST GO
	POP	P,(P)			;FIX STACK
	PUSHJ	P,@1(P)			;CALL SUBROUTINE
	  JFCL
	IOR	F,SAVEF			;TURN BITS BACK ON
	POPJ	P,			;RETURN
SUBTTL	TELETYPE IO SUBROUTINES

SPOUT:	MOVEI	DATA,SP
	PJRST	TTYOUT

COMOUT:	MOVEI	DATA,","
	PJRST	TTYOUT

COLOUT:	MOVEI	DATA,":"
	PJRST	TTYOUT

TABOUT:	MOVEI	DATA,TAB
	PJRST	TTYOUT

TABOU1:	TLNE	F,AUXQ!QUIET!AUTOM	;ECHO TAB?
	JRST	DSKTAB			;FOR :TSILENCE 
	PUSH	P,DATA			;SAVE DATA
	MOVEI	DATA,TAB		;LOAD A TAB
	TLON	F,FREETB		;HAVE WE GIVEN A TAB
	PUSHJ	P,TTYOUT		;PRINT A TAB
	POP	P,DATA			;RESTORE CHAR.


;CALLED BY	MOVEI	DATA,CHAR
;		PUSHJ	P,TTYOUT
;
;SUBR WILL ECHO TO LOG FILE

TTYOUT:	TLNE	F,AUTOM!QUIET!AUXQ	;SKIP IF BOTH OFF
	JRST	DSKTST			;FOR :TSILENCE
	PUSHJ	P,DSKOUT		;PUT IN LOG ALSO
	TLZ	F,REPL			;ZERO BIT
	OUTCHR	DATA			;SEND CHAR TO MONITOR
	POPJ	P,			;RETURN

	IFN	FTTLOG,<
DSKTAB:	MOVE	W,SJBFLG(SJB)		;GET FLAGS FOR SUBJOB
	TLNN	W,(TSIL)		;:TSILENCE MODE?
	POPJ	P,			;NO--RETURN
	PUSH	P,DATA			;SAVE CHAR
	MOVEI	DATA,TAB		;PICK UP TAB
	TLON	F,FREETB		;FLAG THE RAB AND GIVE JUST 1
	PUSHJ	P,DSKOUT		;TYPE THE TAB ON THE DISK
	POP	P,DATA			;RESTORE DATA
DSKTST:	SKIPE	FRCLOG		;DO WE WANT TO FORCE THIS INTO LOG?
	JRST	DSKOUT			;YES-- GO LOG IT
	MOVE	W,SJBFLG(SJB)		;GET SUBJOB FLAGS
	TLNN	W,(TSIL)		;:TSILENCE MODE?
	POPJ	P,			;NO--JRST RETURN
	PJRST	DSKOUT			;YES--PUT ON DISK
>
	IFE	FTTLOG,<
DSKTAB:
DSKTST:	POPJ	P,
>
;SUBR TO RETURN NEXT NON-BLANK CHAR

STTYIN:	PUSHJ	P,TTYIN			;GET NEXT CHAR
	CAIN	DATA,SP			;SKIP IF NON-SPACE
	JRST	STTYIN			;GO IGNORE
	POPJ	P,			;RETURN



;SUBR TO RESCAN TO BEGINNING OF BUFFER

RESCA1:	TLZ	F,BRK			;ZERO BREAK BIT
	PUSH	P,[POINT 7,TTIBUF]	;PUSH ORIGINAL POINTER
	POP	P,TTIPTR		;POP BACK IN PTR SPOT
	POPJ	P,			;RETURN
;SUBR TO GET NEXT CHAR FROM TTY INPUT BUFFER

TTYIN:	PUSHJ	P,SAVACS		;SAVE REGISTERS
	MOVE	DATA,SAVCH		;LOAD THE SAVED CHAR
	SETZM	SAVCH			;CLEAR THE SAVINGS ACCOUNT
	JUMPN	DATA,CPOPJ		;JUMP IF ANYTHING WAS SAVED
	TLZ	F,REPL			;ZERO BEG OF LINE FLAG
	JUMPGE	F,GETB3			;JUMP IF MORE CHARS LEFT

FILBUF:	MOVEI	T1,LINSIZ		;LOAD SIZE IN BYTES
	MOVE	PT1,[POINT 7,TTIBUF]	;LOAD POINTER TO BEG OF BUF
	MOVEM	PT1,TTIPTR		;STORE FOR LATER USE

FILL1:	SOJL	T1,TOOMCH		;JUMP IF LINE TO LARGE
	PUSHJ	P,GENIN			;LOAD A CHAR
	IDPB	DATA,PT1		;STORE IN BUFFER
	PUSHJ	P,ISBRK			;CHECK IF BREAK CHARACTER
	  JRST	ITIS			;IT IS ONE
	JRST	FILL1			;KEEP LOOPING

TOOMCH:	PUSHJ	P,GENIN			;GET NEXT CHAR
	PUSHJ	P,ISBRK			;CHECK FOR BREAK CHAR
	  SKIPA
	JRST	TOOMCH			;IGNORE ALL NON-BREAK
	MOVEI	PT1,[ASCIZ/? Input line too long
/]
	PUSHJ	P,MOUT			;YELL AND SCREAM AT HIM
	MOVSI	T1,(<LF>B6)		;LOAD LF & NULLS
	MOVEM	T1,TTIBUF		;STORE IN BUFFER
	JRST	GETB3			;PROCEDE

ITIS:	SETZ	DATA,			;MAKE MANY 0 BITS
	IDPB	DATA,PT1		;FORM WONDERFUL ASCIZ STRING
GETB3:	ILDB	DATA,TTIPTR		;GET FROM BUFFER
	JUMPE	DATA,FILBUF		;IGNORE NULLS
	TLO	F,BRK			;SET BREAK BIT
	PUSHJ	P,ISBRK			;SKIP IF NON-BREAK
	  POPJ	P,			;RETURN N

	TLZ	F,BRK			;NOT BREAK
	CAIN	DATA,CTRLA		;SKIP IF NOT ^A
	MOVEI	DATA,CTRLC		;TRANSLATE TO ^C
	CAIN	DATA,CTRLB		;SKIP IF NOT ^B
	MOVEI	DATA,CTRLO		;TRANSLATE TO ^O
	TLNE	F,MSG			;SKIP IF NOT PTY TEXT
	POPJ	P,			;OTHERWISE RETURN NOW

	CAIN	DATA,CR			;SKIP IF NOT CR
	JRST	GETB3			;IGNORE THEM
	CAIL	DATA,140		;SKIP IF UPPER CASE
	SUBI	DATA,40			;TRANSLATE TO UPPER
	CAIN	DATA,TAB		;SKIP IF NOT TAB
	MOVEI	DATA,SP			;MAKE INTO SPACE
	POPJ	P,			;RETURN WITH CHAR
GENIN:	IFN	FTAUTO,<
	TLNN	F,AUTOM			;SKIP IF WE'RE IN AUTO MODE
	JRST	GENIN1			;NOT--SKIP CODE
GENIN2:	SOSG	AUTIB+2			;DDECR COUNT & SKIP IF MORE LEFT
	IN	AUTOC,			;ADVANCE BUFFERS
	JRST	GENIN3			;SKIP THIS CODE
	PUSHJ	P,SAVACS		;SAVE ALL REGISTERS
	GETSTS	AUTOC,T1		;LOAD STATUS INTO T1
	PUSHJ	P,AUTREL		;RELEASE THE CHANNEL
	MOVEI	PT1,[ASCIZ/? AUTO file read error
/]
	TRNN	T1,IOEOF		;SKIP IF END OF FILE
	PUSHJ	P,MOUT			;TYPE ON CONSOLE
	MOVE	DATA,BRKLST		;LOAD A BREAK CHAR
	PJRST	DSKOUT			;SEND TO LOG FILE

GENIN3:	ILDB	DATA,AUTIB+1		;LOAD A BYTE
	JUMPE	DATA,GENIN2		;JUMP IF NULL TO NEXT BYTE
	PJRST	DSKOUT			;SEND TO LOG
>
GENIN1:	INCHWL	DATA			;LOAD A BYTE
	JUMPE	DATA,GENIN1		;IGNORE NULLS
	PJRST	DSKOUT			;SEND TO LOG
;CALLED BY	MOVEI	SJB,NNN
;		PUSHJ	P,PUTNAM
;		ALWAYS RETURN
;
;TYPES SUBJOB MNEMONIC, IF ONE, ELSE SUBJOB NUMBER IN DECIMAL

PUTNAM:	SKIPE	T1,MNEMON(SJB)		;LOAD T1 WITH MNEMONIC, IF ANY
	PJRST	SIXBP			;TYPE SIXBIT
	MOVEI	T1,(SJB)		;LOAD SUBJOB NUMBER
	PJRST	DECOUT			;TYPE IN DECIMAL



;CALLED BY	MOVE	T1,[SIXBIT/NAME/]
;		PUSHJ	P,SIXBP
;		ALWAYS RETURN
;
;TYPES WORD IN SIXBIT

SIXBP:	MOVE	PT1,[POINT 6,T1]	;LOAD POINTER
SIXBP1:	ILDB	DATA,PT1		;GET FIRST CHAR
	JUMPE	DATA,CPOPJ		;RETURN IF DONE
	ADDI	DATA,40			;MAKE ASCII OF SIXBIT
	PUSHJ	P,TTYOUT		;TYPE IT
	TLNE	PT1,770000		;SKIP IF PTR DONE
	JRST	SIXBP1			;NO - MORE BYTES TO GO
	POPJ	P,			;RETURN



;CALLED BY	MOVEI	PT1,[ASCIZ/message/]
;		PUSHJ	P,MOUT
;		ALWAYS RETURN
;
;TYPES MESSAGE AT ADDRESS IN RH OF PT1

MOUT:	HRLI	PT1,440700		;MAKE ASCII POINTER
MOUT1:	ILDB	DATA,PT1		;LOAD FIRST BYTE
	JUMPE	DATA,CPOPJ		;RETURN IF NULL
	PUSHJ	P,TTYOUT		;TYPE CHAR
	JRST	MOUT1			;GO GET NEXT BYTE
;SUBR TO TYPE RETURN-LINE-FEED

CRLF:	MOVEI	DATA,CR			;LOAD RETURN
	PUSHJ	P,TTYOUT		;TYPE THAT
	MOVEI	DATA,LF			;LOAD LINE FEED
	PJRST	TTYOUT			;TYPE THAT



;SUBR TO TYPE RETURN-FORM-FEED

CRFF:	MOVEI	DATA,CR			;LOAD RETURN
	PUSHJ	P,TTYOUT		;TYPE THAT
	MOVEI	DATA,FF			;LOAD FORM FEED
	PJRST	TTYOUT			;TYPE THAT
;CALLED BY	MOVEI	T1,NBR
;		MOVEI	T3,RADIX
;		PUSHJ	P,NBROUT
;
;TYPES C(T1) IN RADIX IN T3
;CALL DECOUT FOR DECIMAL, OCTOUT FOR OCTAL

OCTOUT:	SKIPA	T3,CPOPJ		;LOAD 10 IN RADIX REGISTER
DECOUT:	MOVEI	T3,^D10			;LOAD DECIMAL 10
NBROUT:	IDIVI	T1,(T3)			;DIVIDE BY RADIX
	HRLM	T2,(P)			;PUT REMAINDER ON PDL
	SKIPE	T1			;SKIP IF DONE
	PUSHJ	P,NBROUT		;KEEP GOING
	HLRZ	DATA,(P)		;RETRIEVE LAST DIGIT
	ADDI	DATA,"0"		;MAKE ASCII OF BINARY
	PJRST	TTYOUT			;TYPE ON CONSOLE



;CALLED BY	PUSHJ	P,SIXIN
;		ALWAYS RETURN
;
;INPUTS SIXBIT WORD FROM TTY
;DELIMITER IS FIRST NON-ALPHANUMERIC CHARACTER

SIXIN:	PUSHJ	P,STTYIN		;GET FIRST NON-BLANK CHAR
SIXINZ:	SETZ	CMD,			;START WITH ZERO
	MOVE	PT1,[POINT 6,CMD]	;LOAD POINTER
SIXI1:	CAIL	DATA,"0"		;SKIP IF TOO SMALL
	CAILE	DATA,"Z"		;FALL THROUGH IF TOO LARGE
	POPJ	P,			;RETURN
	CAILE	DATA,"9"		;SKIP IF NUMERIC
	CAIL	DATA,"A"		;SKIP IF NON-ALPHANUMERIC
	JRST	SIXI2			;GO DEPOSIT
	POPJ	P,			;RETURN
SIXI2:	SUBI	DATA,40			;CONVERT TO SIXBIT
	TLNE	PT1,770000		;SKIP IF POINTER DONE
	IDPB	DATA,PT1		;DEPOSIT INTO REGISTER
	PUSHJ	P,TTYIN			;FETCH NEXT CHAR
	JRST	SIXI1			;GET NEXT CHAR
;SUBR TO INPUT DECIMAL NBR - RESULT IN REGISTER CMD

DECIN:	PUSHJ	P,STTYIN		;GET FIRST NON-BLANK
DECINZ:	SETZ	CMD,			;START WITH ZERO
DEC1:	CAIL	DATA,"0"		;SKIP IF TOO SMALL
	CAILE	DATA,"9"		;SKIP IF DECIMAL
	POPJ	P,			;RETURN
	IMULI	CMD,^D10		;MULTIPLY BY 10
	ADDI	CMD,-"0"(DATA)		;ADD DIGIT IN
	PUSHJ	P,TTYIN			;GET NEXT CHARACTER
	JRST	DEC1			;LOOP



;SUBR TO INPUT OCTAL NBR - RESULT IN REGISTER CMD

OCTIN:	PUSHJ	P,STTYIN		;GET FIRST NON BLANK
OCTINZ:	SETZ	CMD,			;START WITH ZERO
OCT1:	CAIL	DATA,"0"		;SKIP IF TOO SMALL
	CAILE	DATA,"7"		;SKIP IF OCTAL
	POPJ	P,			;RETURN
	ASH	CMD,3			;MAKE ROOM FOR DIGIT
	TRO	CMD,-"0"(DATA)		;PUT DIGIT IN
	PUSHJ	P,TTYIN			;GET NEXT CHAR
	JRST	OCT1			;LOOP FOR NEXT
;RDX60W -- INPUT A RADIX 60 NUMBER FROM COMMAND STRING
;RDX60  -- DITTO (CHARACTER ALREADY IN DATA)
;FORMATS ARE XXYYZZ OR XX:YY:ZZ
;CALL:	PUSHJ	P,RDX60/RDX60W
;	  RETURN IF COMMAND ERROR
;	RETURN WITH WORD IN CMD
;USES T1, T2, T3	UPDATES DATA (SEPARATOR)

RDX60W:	PUSHJ	P,TTYIN			;PRIME THE PUMP

RDX60:	MOVEI	T2,0			;PRESET TEMPORARY RESULT
RDX601:	IMULI	T2,^D100		;ADVANCE TO NEXT RESULT
	JUMPL	F,RDX605		;JUMP IF END OF LINE
	PUSHJ	P,DECINZ		;GET NEXT SUPER-DIGIT
	ADD	T2,CMD			;ADD TO ACCUMULATOR
	CAIE	DATA,":"		;SEE IF MORE TO COME
	JRST	RDX605			;NO--GO CONVERT RESULT
	TLNE	T2,(777B8)		;DON'T ALLOW OVERFLOW
	JRST	BADTIM			;ERROR IF TIME TOO LARGE
	CAIL	CMD,^D60		;DON'T ALLOW GARBAGE IN
	JRST	BADTIM			;ERROR IF DIGIT TOO LARGE
	JUMPL	F,RDX605		;JUMP IF EOL
	PUSHJ	P,TTYIN			;SKIP SEPARATOR
	JRST	RDX601			;LOOP BACK FOR MORE

RDX605:	MOVEI	CMD,0			;CLEAR RESULT
RDX606:	IDIVI	T2,^D100		;SEPARATE TYPEIN
	HRLM	T3,(P)			;STORE LEAST DIGIT AWAY
	SKIPE	T2			;SKIP IF ALL DONE
	PUSHJ	P,RDX606		;IF NOT, DO SOME MORE

	JFCL	17,.+1			;CLEAR OVERFLOW
	HLRZ	T1,(P)			;GET BACK HIGHEST DIGIT
	IMULI	CMD,^D60		;MAKE ROOM IN RESULT
	ADD	CMD,T1			;INCLUDE RESULT
	CAIL	T1,^D60			;SEE IF ERROR
	JRST	BADTIM			;COMPLAIN IF COMPONENT TOO BIG
	JRST	CPOPJ1			;RETURN

BADTIM:	PJSP	PT1,MOUT		;COMMAND ERROR
	ASCIZ	/?  Bad time specified
/
;CALLED BY	MOVEI	DATA,CHAR
;		PUSHJ	P,ISBRK
;		  HERE IF BREAK CHAR
;		HERE IF NOT
;
;HARMS NO REGISTERS

ISBRK:	PUSH	P,T1			;SAVE T1
	MOVSI	T1,-BRKLTH		;MAKE XWD OF TBL LENGTH
	CAME	DATA,BRKLST(T1)		;MATCH?
	AOBJN	T1,.-1			;NO, CHECK NEXT ONE
	SKIPL	T1			;SKIP IF MATCH
	AOS	-1(P)			;SKIP RETURN
	POP	P,T1			;RESTORE T1
	POPJ	P,			;RETURN TO CALLER

BRKLST:	EXP	CTRLC,BELL,LF,VT,FF,CTRLZ,ALT,ALT175,ALT176

	BRKLTH==.-BRKLST
SUBTTL	PTY IO ROUTINES

;CALLED BY	MOVEI	SJB,NNN
;		PUSHJ	P,IPTY
;		  ERROR
;		SUCCESS
;
;INITS FIRST FREE PTY ON CHANNEL=C(SJB)

IPTY:	SETZM	BLK3			;START WITH PTY
	SETO	T1,			; FOR GENERIC PTY
ONMORE:	MOVEI	T2,(T1)			;LOAD DIGIT
	LSHC	T2,-3			;SPLIT DIGITS
	LSH	T2,3			;SHIFT HIGH ORDER LEFT BY 3
	LSHC	T2,3			;SHIFT DOUBLE BACK
	LSH	T2,6			;LH JUSTIFIED 6BIT ON XWD
	TRO	T2,202000		;MAKE 6BIT
	TRNN	T2,570000		;SKIP IF HIGH ORDER NOT 0
	LSH	T2,6			;SHIFT OUT OF XWD
	SKIPGE	T1			;FIRST TIME?
	HRRI	T2,0			;YES--GENERIC PASS DOWN DDBS
	HRLI	T2,'PTY'		;PUT PTY IN 6BIT IN LH
	MOVEM	T2,BLK3+1		;STORE IN OPEN BLOCK
	DEVCHR	T2,			;CHECK IT OUT
	JUMPE	T2,NOMOR		;IF ZERO, NO MORE PTY'S
	TLNE	T2,DVAVAL		;SKIP IF NOT AVAILABLE
	TRNE	T2,ASSPRG		;SKIP IF NOT INIT'ED ALREADY
	AOJA	T1,ONMORE		;INCR COUNT & RESTART

	MOVEI	T2,PTBSIZ		;LOAD SIZE OF BLOCK
	IMULI	T2,(SJB)		;MULTIPLY BY SUBJOB OFFSET
	MOVEI	T3,PTBFS(T2)		;LOAD BUFFERS ADDR INTO T3
	HRLI	T2,PTOB(T2)		;PUT OUTPUT HDR ADDR IN LH
	ADDI	T2,PTIB			;MAKE INPUT HDR ADDR IN RH
	MOVEM	T2,BLK3+2		;STORE IN OPEN BLOCK
	MOVSI	T2,(SJB)		;PUT SUBJOB NBR IN LH
	LSH	T2,5			;SHIFT INTO AC POSITION
	MOVE	T4,T2			;SAVE FOR LATER USE
	IOR	T2,[OPEN BLK3]		;MAKE OPEN INSTRUCTION
	XCT	T2			;INIT PTY
	AOJA	T1,ONMORE		;LOSE - TRY NEXT ONE
	TDO	F,USE(SJB)		;SET IN USE BIT
	EXCH	T3,.JBFF		;PUT BUFFER ADDR IN .JBFF
	MOVE	T1,T4			;LOAD SUBJOB IN AC POSITION
	IOR	T1,[OUTBUF 1]		;MAKE OUTBUF UUO
	XCT	T1			;DO IT
	MOVE	T1,T4			;LOAD SUBJOB AGAIN
	IOR	T1,[INBUF 1]		;MAKE INBUF UUO
	XCT	T1			;DO THAT
	MOVEM	T3,.JBFF		;RESTORE .JBFF
	MOVE	T1,T4			;RELOAD SUBJOB
	TLO	T1,(OUTPUT)		;MAKE OUTPUT UUO
	XCT	T1			;DO IT ONCE
	XCT	T1			;ONE MORE TIME
	MOVE	T1,T4			;LOAD AGAIN
	IOR	T1,[STATO IODERR]	;CHECK FOR DEVICE ERROR
	XCT	T1			;SKIP IF SO
	PJRST	CPOPJ1			;NONE - ALL IS FINE
	PUSHJ	P,RPTYN			;RELEASE PTY & SUBJOB
	PJSP	PT1,MOUT		;TYPE MESSAGE
	ASCIZ	/? No more tty DDB's
/
;CALLED BY	MOVEI	SJB,NNN
;		PUSHJ	P,STOPJB
;		  ERROR
;		JOB STOPPED IN ^C STATE

STOPJB:	PUSHJ	P,CSTOP			;SKIP IF NOT STOPPED ALREADY
	  PJRST	CPOPJ1			;SKIP BACK IF DONE
	PUSH	P,[EXP MAXCTC]		;PUSH ON LIST
STOP1:	MOVEI	DATA,CTRLC		;LOAD ASCII ^C
	PUSHJ	P,PTYOUT		;SEND TO SUBJOB
	PUSHJ	P,QGBUF			;GET REPLY
	PUSHJ	P,CSTOP			;SKIP IF NO SOAP
	  PJRST	XPOPJ1			;DONE - SKIP BACK
	SOSL	(P)			;DECREMENT COUNT
	JRST	STOP1			;STILL TIME
	POP	P,(P)			;CLEAR STACK OF GARBAGE
	PUSHJ	P,QMESG			;TYPE ST QUEST MESG
	PUSHJ	P,UJBSTS		;GET JOBSTS
	TLNE	T1,(JSACCT)		;SKIP IF NO JACCT
	PJRST	STUCK			;ANNOUNCE STUCK IN JACCT
	PJSP	PT1,MOUT
	ASCIZ	/ cannot be put in monitor mode
/
STUCK:	PJSP	PT1,MOUT
	ASCIZ	/ is stuck with JACCT on
/
DUMPT:	MOVEI	T1,PTBSIZ		;GET UNIT SIZE OF PTY BLOCK
	IMULI	T1,(SJB)		;INCR TO THIS PTY'S BLOCK
	MOVE	T1,PTOB(T1)		;LOAD ADDR OF 2ND WORD OF BUFFER
	SKIPN	2(T1)			;SKIP IF ANY DATA IN BUFFER
	POPJ	P,			;RETURN TO CALLER

DUMPT1:	IFN	FTAUTO,<
	TLNN	F,AUTOM			;SKIP IF IN AUTO MODE
	JRST	DUMPT2			;NOT -- GET FROM TTY
	PUSHJ	P,UJBSTS		;GET JOBSTS
	TLNE	T1,(INREQ)		;WANTS INPUT?
	JRST	DUMPT2			;YES IT DOES
	TLNE	T1,(OUTRDY)		;WANTS TO BARF?
	PUSHJ	P,GBUF			;YES -- BARF OVER CONSOLE
>
DUMPT2:	MOVSI	T1,(SJB)		;PUT SUBJOB NBR IN LH
	LSH	T1,5			;SHIFT TO AC POSITION
	TLO	T1,(OUTPUT)		;MAKE OUTPUT UUO
	XCT	T1			;SEND BUFFER
	POPJ	P,			;RETURN



PTMOUT:	HRLI	PT1,440700		;MAKE ASCII POINTER
PTMOU1:	ILDB	DATA,PT1		;GET A CHAR
	JUMPE	DATA,CPOPJ		;RETURN IF NULL
	PUSHJ	P,PTYOUT		;SEND TO PTY
	JRST	PTMOU1			;LOOP
PTOCT:	IDIVI	T1,8			;BREAK WORD DOWN
	HRLM	T2,(P)			;STORE DIGIT ON PDL
	SKIPE	T1			;SKIP IF DONE
	PUSHJ	P,PTOCT			;GO ON
	HLRZ	DATA,(P)		;RETRIEVE DIGIT
	ADDI	DATA,"0"		;MAKE ASCII OF BINARY

PTYOUT:	MOVEI	T1,PTBSIZ		;GET SIZE OF PTY BLOCK
	IMULI	T1,(SJB)		;COMPUTE OFFSET
	PUSH	P,T1			;SAVE ON PDL
	SOSG	PTOB+2(T1)		;DECR BYTE COUNT
	PUSHJ	P,DUMPT			;FORCE BUFFER
	POP	P,T1			;RESTORE POINTER ADDRESS
	IDPB	DATA,PTOB+1(T1)		;STORE BYTE
	PUSHJ	P,ISBRK			;CHECK IF BREAK CHAR
	  PJRST	DUMPT			;IT IS--SEND BUFFER
	POPJ	P,			;RETURN
GBUF:	MOVE	T1,SJBFLG(SJB)		;NOW GET SJB STATUS
	TLNN	T1,(DALSHH)		;:SLOGIN IN PROGRESS?
	JRST	GBUF6			;NO--PROCEED
	PUSHJ	P,UJBSTS		;YES--GET THE JOB STATUS
	TLNN	T1,(JSJLOG)		;LOGGED IN?
	JRST	GBUF6			;NO--CONTINUE
	TLNN	T1,(OUTRDY)		;REAL OUTPUT?
	JRST	GBUF6		;NO--FREE CALL
	MOVSI	T1,(DALSHH)		;YES--CLEAR THE SILENCE BIT
	ANDCAB	T1,SJBFLG(SJB)		; AND RELOAD THE AC
GBUF6:	TLNN	T1,(SHH!DALSHH!ERONLY)	;SKIP IF ANY  BIT ON
	TLZA	F,QUIET			;ZERO BIT OUT
QGBUF:	TLOA	F,QUIET			;JUST SEND TO LOG FILE
	TLO	F,AUXQ			;TURN ON ANOTHER BIT
	SETZM	EAFLAG			;PRENTEND WE ARE NOT IN AUTO MODE
	TLZE	F,AUTOM			;ARE WE IN AUTO MODE?
	SETOM	EAFLAG			;YES--NOTE THAT FACT
	TLZ	F,HEADR			;GIVE A HEADER
	PUSH	P,[EXP MOSTBF]		;PUSH MAX NBR OF BUFFERS
	MOVEI	T1,PTBSIZ		;LOAD SIZE OF UNIT BLOCK
	IMULI	T1,(SJB)		;INCR TO THIS SUBJOB
	MOVEI	T2,PTIB+1(T1)		;LOAD BYTE POINTER ADDR INTO T2
	PUSH	P,T2			;STACK IT
	MOVEI	T1,PTIB+2(T1)		;LOAD BYTE COUNT ADDR INTO T2
	PUSH	P,T1			;STACK THAT TOO
	TLO	F,LCR!NOREP		;INITIAL FLAGS

GBUF1:	PUSH	P,[EXP CHANCE]		;STORE NBR OF TRIES
	SOSGE	-3(P)			;DECR COUNT & SKIP IF OK
	JRST	MCR			;HE LOSES

GBUF2:	PUSHJ	P,UJBSTS		;GET JOBSTS
	TLNN	T1,(OUTRDY)		;SKIP IF OUTPUT READY
	JRST	DECRL			;COUNTDOWN
	HRLZ	T1,SJB			;GET SJB NBR IN LH
	LSH	T1,5			;SHIFT TO AC POSITION
	TLO	T1,(INPUT)		;MAKE INPUT UUO
	XCT	T1			;EXECUTE IT
	SKIPG	@-1(P)			;SKIP IF BYTE COUNT POSITIVE
	JRST	DECRL			;FALSIE BITSY
GBUF4:	SOSL	@-1(P)			;SKIP IF BUFFER EMPTY
	JRST	GBUF5			;HOP OVER SOME CODE
	POP	P,(P)			;POP CHANCE OFF STACK
	JRST	GBUF1			;RESTART
GBUF5:	ILDB	DATA,@-2(P)		;GET BYTE
	JUMPE	DATA,GBUF4		;IGNORE NULLS
	CAIN	DATA,EOT		;AND ^D'S
	JRST	GBUF4			;......

	PUSHJ	P,ISBRK			;IS IT A BREAK CHAR?
	  JRST	NOCHNG			;YES--SKIP CODE
	TLNN	F,LCR			;SKIP IF LAST CHAR A CR
	JRST	END5			;HOP OVER SOME CODE
	CAIN	DATA,CR			;SKIP IF NOT ANOTHER CR
	JRST	GBUF4			;IT IS--IGNORE IT
	PUSH	P,DATA			;SAVE THE CHARACTER
	MOVEI	T1,BELL			;LOAD A BELL
	EXCH	DATA,T1			;PLACE IN RIGHT AC
	CAIE	T1,"%"
	CAIN	T1,"?"
	PUSHJ	P,CHKWRN		;SEND DING TO TTY
	TLZ	F,FREETB		;CAUSE A TAB TO HAPPEN
	CAIN	T1,"?"			;QUEST MARK?
	PUSHJ	P,CHKERR		;YES--RING TTY
	POP	P,DATA			;RESTORE CHARACTER
END5:	CAIN	DATA,CR			;SKIP IF NOT CR
	TLOA	F,LCR			;A CR!
	TLZ	F,LCR			;ZILCH BIT
NOCHNG:	CAILE	DATA,41			;BIGGER THAN A SPACE
	PUSHJ	P,HEAD0			;YES--DO ALL GOOD THINGS
	PUSHJ	P,TABOU1		;SEND THE CHARACTOR
	CAIN	DATA,LF			;IS THIS A LINE FEED?
	TLO	F,AUXQ			;YES--START BEING QUIET
	JRST	GBUF4			;GET THE NEXT ONE


DECRL:	SOSLE	(P)			;DECR COUNT
	JRST	TIMLFT			;TIME STILL LEFT
MCR:	SUB	P,[4,,4]		;DISHONESTLY POP 4 MJOBS
	PUSHJ	P,CRLF			;TYPE CR-LF
	TLZ	F,QUIET!AUXQ		;INSURE LOAD MODE BACK ON
	SKIPE	EAFLAG			;IN AUTO MODE?
	TLO	F,AUTOM			;YES--RELIGHT THE BIT
	POPJ	P,			;RETURN TO CALLER

TIMLFT:	PUSHJ	P,UJBSTS		;GET JOBSTS
	TLNE	T1,(INREQ)		;IS INREQ ON?
	JRST	GBUF2			;YES--BE DONE WITH IT
	MOVEI	T1,SNOOZT		;LOAD ONE
	SLEEP	T1,			;SLEEP FOR A WHILE
	JRST	GBUF2			;CONTINUE
RPTY:	PUSHJ	P,STOPJB		;STOP THAT JOB!
	  POPJ	P,			;LOSE
	PUSHJ	P,ISJOB			;SKIP IF JNA ON
	  PJRST	RPTYN			;NOT--JUST RELEASE CHANNEL
	MOVEI	PT1,LGOMSG		;LOGOUT MESSAGE
	PUSHJ	P,PTMOUT		;SEND MESSAGE
	PUSHJ	P,QGBUF			;GET REPLY
	PUSHJ	P,UJBSTS		;GET JOBSTS OF PTY
	JUMPL	T1,.-2			;LOOP IF JNA STILL ON

RPTYN:	SETZM	MNEMON(SJB)		;CLEAR MNEMONIC
	SETZM	SJBFLG(SJB)		;CLEAR FLAGS
	TDZ	F,USE(SJB)		;CLEAR IN USE FLAG
	MOVSI	T1,(SJB)		;LOAD INTO LH
	LSH	T1,5			;SHIFT INTO AC POSITION
	TLO	T1,(RELEAS)		;MAKE RELEASE UUO
	XCT	T1			;GET RID OF PTY
	POPJ	P,			;RETURN TO CALLER

LGOMSG:	ASCIZ	\DEASSI
KJOB OPRKJO.LOG=/W/B/Z:0/VD:P
\



CHKERR:	MOVE	T2,SJBFLG(SJB)		;GET THE FLAGS
	TLNE	T2,(ERONLY)		;DOES HE WANT ERRORS
	TLZ	F,QUIET			;YES MAKE NOISE
	PUSHJ	P,HEAD0			;GIVE A HEADER
	PJRST	TTYOUT			;GO PRINT

CHKWRN:	TLZ	F,AUXQ			;CLEAR THE AUX FLAG
	PUSHJ	P,TTYOUT		;GIVE A DING
	TLO	F,AUXQ			;PUT THE BIT BACK ON
	POPJ	P,0			;BACK TO WORK
HEAD0:	TLZN	F,AUXQ			;ARE WE QUIET
	POPJ	P,			;NO WE WERE REVIVED
HEAD:	TLOE	F,HEADR			;HAVE WE GIVEN A HEADER
	POPJ	P,			;GAVE ONE
	PUSH	P,DATA			;SAVE DATA
	PUSH	P,[EXP TTYOUT]		;STORE ADDR OF OUTPUT ROUTINE
	PUSHJ	P,TIMOUT		;TYPE CURRENT TIME
	MOVEI	DATA,"("		;OPEN PARENS
	PUSHJ	P,TTYOUT		;SENT
	PUSHJ	P,PUTNAM		;NAME OF SUBJOB
	CAIN	LASU,(SJB)		;LAST IN LAST OUT?
	JRST	GBUF3			;YES--PROCEED
	MOVEI	DATA,"\"		;LOAD A BACKSLASH
	PUSHJ	P,TTYOUT		;SEND TO TTY
	EXCH	SJB,LASU		;GET RIGHT SUBJOB
	PUSHJ	P,PUTNAM		;SEND HIS NAME OUT
	EXCH	SJB,LASU		;GET OTHER ONE BACK
GBUF3:	MOVEI	PT1,[ASCIZ/)
/]
	PUSHJ	P,MOUT			;PRINT THE HEADER
	PUSHJ	P,TABOU1		;GIVE A TAB
	POP	P,DATA			;RESTORE DATA
	POPJ	P,			;RETURN
SUBTTL	ERROR MESSAGE SUBROUTINES

QMESG:	MOVEI	PT1,[ASCIZ/? Subjob /]	;LOAD ADDR OF THAT MESG
	PUSHJ	P,MOUT			;TYPE ON CONSOLE
	PJRST	PUTNAM			;TYPE ITS NAME

ALLFR:	PJSP	PT1,MOUT
	ASCIZ	/? No active subjobs
/
CMDERR:	PJSP	PT1,MOUT
	ASCIZ	/? Command error
/
NOALL:	PJSP	PT1,MOUT
	ASCIZ	/? Cannot use all
/
NOBE:	PJSP	PT1,MOUT
	ASCIZ	/? No such device
/
NOFREE:	PJSP	PT1,MOUT
	ASCIZ	/? No free subjobs
/
NOINTX:	PJSP	PT1,MOUT
	ASCIZ	/? cannot open device
/
NOMNE:	PJSP	PT1,MOUT
	ASCIZ	/? No such mnemonic
/
NOMOR:	SKIPG	T1
	AOJA	T1,ONMORE
	PJSP	PT1,MOUT
	ASCIZ	/? No free PTY's
/
NOTACT:	PUSHJ	P,QMESG
	PJSP	PT1,MOUT
	ASCIZ	/ is not active
/
NOTLOG:	PJSP	PT1,MOUT
	ASCIZ	/? No job number assigned
/
NORUN:	PJSP	PT1,MOUT
	ASCIZ	/? No runnable CPU's in specification
/
NOPRIV:	PJSP	PT1,MOUT
	ASCIZ	/? OPR only command.
/
ONLY1:	TLNN	F,WASCOM
	POPJ	P,
	PJSP	PT1,MOUT
	ASCIZ	/[Will only use first argument]
/
OUTBND:	PJSP	PT1,MOUT
	ASCIZ	/? No such subjob
/
TOOFEW:	PJSP	PT1,MOUT
	ASCIZ	/? Too few arguments
/
CHKDAE:	CAMN	T1,[2,,T2]
	JRST	NODAEM
	PJSP	PT1,MOUT
	ASCIZ	/? DAEMON UUO Error
/

NODAEM:	PJOB	T1,
	WAKE	T1,
	  POPJ	P,
	TLO	F,SLEEPR
	PJSP	PT1,MOUT
	ASCIZ	/%DAEMON not running
/

PACF:	ASCIZ	/[Processing auto command file]
/

ATL5:	ASCIZ	/% :KSYS has a minimum of 5 min.
/

CNTCON:	PJSP	PT1,MOUT
	ASCIZ	/?  Can't continue
/
SUBTTL	JUNK AREA

SAVACS:	EXCH	T1,(P)
	PUSH	P,T2
	PUSH	P,T3
	PUSH	P,T4
	PUSH	P,T5
	PUSH	P,PT1
	PUSHJ	P,(T1)
	  SKIPA
	AOS	-6(P)
	POP	P,PT1
POPALL:	POP	P,T5
	POP	P,T4
	POP	P,T3
	POP	P,T2
	POP	P,T1
	POPJ	P,


APOPJ1:	AOS	(P)
APOPJ:	POP	P,-1(P)
	POPJ	P,


XPOPJ1:	AOS	-1(P)
XPOPJ:	POP	P,(P)
	POPJ	P,


CPOPJ1:	AOS	(P)
CPOPJ:	POPJ	P,8



	ZZ==1
USE:	REPEAT	HGHPTY+1,<
	EXP	ZZ
	ZZ==ZZ_1
>
	XLIST	;LITERALS
	LIT
	LIST
SUBTTL	LOW SEGMENT BLOCKS

	RELOC				;SWITCH TO LOSEG

LOWBEG:

INTBLK:	BLOCK	4		;BLOCK FOR CORTROL-C TRAP
JIFSEC:	BLOCK	1		;JIFFIES PER SECOND
EAFLAG:	BLOCK	1		;AUTO MODE FLAG
SAVEF:	BLOCK	1		;SAVE AREA
KSYNC:	BLOCK	1		;SYNC FOR KSYS
SAVCH:	BLOCK	1		;SAVED CHARACTOR
WARNTM:	BLOCK	1		;@ TO WARNTB
BLK3:	BLOCK	3		;GENERAL OPEN BLOCK
PTY0LN:	BLOCK	1		;LINE NUMBER OF PTY0
DGTCNT:	BLOCK	1		;FOR COUNTING DIGITS
PDL:	BLOCK	PDLSIZ		;PUSHDOWN LIST
TCONLN:	BLOCK	1		;CTY LINE NUMBER
TTIBUF:	BLOCK	LINSIZ/5+1	;INPUT BUFFER
TTIPTR:	BLOCK	1		;POINTER TO IT

SJBFLG:	BLOCK	HGHPTY+1	;SUBJOB FLAGS
MNEMON:	BLOCK	HGHPTY+1	;FOR MNEMONICS


;***** DO NOT SEPARATE THE FOLLOWING *****
PTIB:	BLOCK	3		;INPUT BUFFER
PTOB:	BLOCK	3		;OUTPUT BUFFER
PTBFS:	BLOCK	PTYSIZ*2	;TWO OF THEM

	PTBSIZ==.-PTIB

	BLOCK	<3+3+PTYSIZ*2>*HGHPTY

;***** END OF DO NOT SEPARATE BLOCK *****
	IFN	FTTLOG,<

FRCLOG:	BLOCK	1		;SET NON-ZERO TO FORCE THINGS INTO THE LOG
LOGNAM:	BLOCK	5		;SYSTEM NAME FROM CNFTBL
LOGDAT:	BLOCK	2		;SYSTEM CREATION DATE FROM CNFTBL
LOGFIL:	BLOCK	4		;REMEMBER LOG FILE SPECS
LOGOB:	BLOCK	3		;BUFFER HEADER
LOGOBB:	BLOCK	DSKSIZ		;ONE BUFFER
>
	IFN	FTAUTO,<
AUTIB:	BLOCK	3		;BUFFER HEADER
ATOTIM:	BLOCK	1
ATOT1:	BLOCK	1
ATOT2:	BLOCK	1
ATOT3:	BLOCK	1
ATOT4:	BLOCK	1
ATOT5:	BLOCK	1
>


	LOWEND==.-1

	END	OPSER
 t@: