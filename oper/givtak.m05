TITLE GIVTAK - TAKE A FILE FROM 1 PDP10 AND GIVE TO ANOTHER
SUBTTL - J. MARCIN 2/21/72

VSAVIT==5
JOBVER=137
	LOC JOBVER	;PUT VERSION NUMBER IN JOB DATA AREA
	XWD 0,VSAVIT
	RELOC

EXTERNAL JOBREL

;AC'S
F=0
A=1
B=2
C=3
D=4
N=5
BADLIM=6	;LIMIT OF TOTAL # OF BLKS.IN ORIG FILE TO BE TRANSMITTED
COUNT=7	;BLK NO. PRESENTLY BEING TRANSMITTED
BDCNT=10	;# OF BLKS LEFT TO BE RETRANSMITTED
NOBLX=11	;# OF BLKS OF CHKSUM ONLY TO SEND
CODE=12
LASBLK=13	;TOTAL # OF BLKS.
CHKSUM=14
CH=15
BP=16
P=17

SYS32==212	;SERIAL NO. OF SYSTEM 32
SYS31==53	;SERIAL NO. OF SYSTEM 31

;FLAGS IN RIGHT HALF OF F
LOKOK==1	;LOOKUP ON .OLD FILE OK.
BADLOK==2	;LOOKUP ON BAD FILE OK
ENDFND==4	;END OF FILE FOUND
SENDAT==10	;SEND DATA AND CHKSUM
ERRBAD==20	;LAST I/O ERROR WAS ON .BAD FILE
FIRSTF==40	;FIRST TIME THRU...
CONTF==100	;CONTROL 252 ENCOUNTERED
CONTF1==200	;LEGAL  CODE RECIEVED
EXT252==400	;EXTRA 252 FOUND WHEN NOT EXPECTED
DONORF==1000	;USER IS DONOR
NO252==2000	;IGNORE 252'S 
EXT123==4000	;EXTRA 252 CHR WAS A 1,2,OR3
USEBIT==400000	;USE BIT
OLDBAD==LOKOK+BADLOK

;I/O CHANNELS
TTY==1
DSK==2
DSKO==3

;UUO'S
RESET==0
GETCOR==11
EXIT==12
SLEEP==31
GETTAB==41

GIVTAK:	JRST NORUN
	CALLI RESET
	MOVE P,PDP
GETTTY:	INIT TTY,214	;INIT TTY IN IMAGE MODE(NO ECHO)
	SIXBIT /TTY/
	TTYI
	CALLI EXIT
	INBUF TTY,2	;2 INPUT BUFFERS
	TRO F,NO252
	MOVEI CH,1
	PUSHJ P,OUT1
	MOVEI CH,2
	PUSHJ P,OUT1
	MOVEI CH,3
	PUSHJ P,OUT1
	MOVEI CH,4
	PUSHJ P,OUT1
TRYAGN:	PUSHJ P,INCH
	CAIE CH,1
	JRST TRYAGN
	PUSHJ P,INCH
	CAIE CH,2
	JRST TRYAGN
	PUSHJ P,INCH
	CAIE CH,3
	JRST TRYAGN
	PUSHJ P,INCH
	CAIE CH,4
	JRST TRYAGN
TRY1:	JRST TRY2
;	MOVE A,[XWD 20,11]
;	CALLI A,GETTAB
;	JRST MISERR
;	CAIE A,SYS31
;	CAIN A,SYS32
;	JRST TRY2
;	MOVE 1,[XWD -1,6]	;GET PRIVLEGES FOR THIS JOB
;	CALLI 1,GETTAB
;	JRST MISERR
;	TRZ 1,100000	;SET LOGOUT ON DISCONNECT
;	CALLI 1,-11	;AND SET PRIVLEGES FOR THIS JOB
;	JFCL
TRY2:	SETZB F,ZERST
	TRO F,NO252
	MOVE A,[XWD ZERST,ZERST+1]
	BLT A,JOBREL
	SETO CODE,
	PUSHJ P,INCH
	CAIE CH,10	;SENDING A NEW FILE NAME?
	JRST SYNERR
	MOVEI N,^D12
	MOVE BP,[POINT 6,USRNAM]
GETNXT:	PUSHJ P,INCH
	ANDI CH,377
	CAIN CH,11
	JRST GOTNAM
	IDPB CH,BP
	SOJGE N,GETNXT
	CAIE CH,11
	JRST SYNERR
GOTNAM:	SKIPN ,USRNAM
	SKIPE ,USRNAM+1
	SKIPA A,[XWD 20,11]
	JRST GETFNM
	CALLI A,GETTAB	;FIND OUT SERIAL NO. OF MACHINE
	JRST MISERR
	CAIN A,SYS32	;IF 32, GET PPN
	JRST SQZIT
	INIT DSK,	;IF NOT, GET PPN WITH A LOOKUP
	SIXBIT /DSK/
	0
	JRST MISERR
	MOVEI A,3	;GET 3 WD EXTENDED LOOKUP
	HRRZI B,USRNAM
	HRLZI C,(SIXBIT/A/)
	HRLZI D,(SIXBIT/B/)
	LOOKUP DSK,A
	JFCL	;DOESN'T MATTER IF LOOKUP FAILS
	CAIN B,USRNAM	;SAME AS BEFORE?
	JRST BADNAM	;YEP...ERROR
	MOVEM B,PPN	;NO, SAVE PPN
	RELEASE DSK,
	JRST GETFNM
SQZIT:	SKIPE ,USRNAM+1
	JRST BADNAM
	LDB A,[POINT 6,USRNAM,35]
	JUMPE A,BADNAM
	MOVE A,USRNAM
	CALLI A,-3
	MOVEM A,PPN
GETFNM:	MOVE BP,[POINT 6,FILNAM]
	MOVEI N,^D9
	PUSHJ P,GETWD
RORD:	PUSHJ P,INCH
	CAIN CH,3
	JRST GIVFIL
	CAIN CH,4
	JRST GETFIL
	JRST SYNERR

FINFIL:	PUSHJ P,LOKFIL
	POPJ P,0
	MOVE LASBLK,D
	HLRES LASBLK,LASBLK	;GET TRUE FILESIZ
	MOVMS LASBLK	;FIRST READ LAST BLOCK
	SUBI LASBLK,1
	ROT LASBLK,-7
	ADDI LASBLK,1
	HRRZS LASBLK,LASBLK	;SAVE LAST BLOCK NUMBER
	AOS (P)
	POPJ P,0


NORUN:	TTCALL 3,[ASCIZ/
THIS PROGRAM IS NOT EXECUTABLE FROM THE PDP10.  FOR MORE INFORMATION,
CALL YOUR ACCOUNT REPRESENTATIVE.
/]
	CALLI EXIT

GIVFIL:	TRO F,DONORF
	PUSHJ P,GETDSK
	PUSHJ P,FINFIL
	JRST  LOKERR
	MOVEI CH,1
	PUSHJ P,OUT1	;ANSWER FILE FOUND
	MOVE N,LASBLK
	PUSHJ P,NUMOUT	;OUTPUT SIZE
	PUSHJ P,CHKCNT	;CHECK SIZE OF HDCNT
	MOVE BDCNT,LASBLK
	PUSHJ P,COMBAD	;COMPUTE # OF BLKS SENT BEFORE ERROR
	PUSHJ P,INCH
	CAIN	CH,3	;DOES NEITHER OLD OR BAD EXIST?
	JRST GIV
	CAIE CH,1
	CAIN CH,2
	SKIPA
	JRST MISERR
	MOVEI N,2
	SETZ NOBLX,
	MOVE BP,[POINT 8,NOBLX,19]
	PUSHJ P,GETWD
	ADD BADLIM,NOBLX	;ADJUST BADLIM
	JUMPLE NOBLX,GIV
	TRZA F,SENDAT
GIV:	TRO F,SENDAT
	TRZ F,ENDFND+NO252
	MOVEI COUNT,1
GIV1:	PUSHJ P,CHKHD
	JRST NXT1	;BIT SET
	USETI DSK,@COUNT	;BIT NOT SET, PREPARE TO INPUT BLK
	INPUT DSK,
	STATZ DSK,740000
	JRST INOERR
	STATZ DSK,20000
	TRO F,ENDFND
	MOVE CHKSUM,COUNT
	PUSHJ P,ESCOUT
	MOVEI CH,10	;PREPARE TO SEND CODE
	TRNN	F,SENDAT
	MOVEI CH,7
	PUSHJ P,OUT1
	MOVE N,COUNT
	PUSHJ P,NUMOUT
	MOVE BP,DSKIN+1	;GET BYT POINTER FROM RING HEADER
	MOVEI CH,4	;MAKE IT A 4 BIT BYTE
	DPB CH,SIZBP
	HRRZ C,BP
	SUBI C,1
	MOVE B,@C
	TLNN B,USEBIT
	CALLI DSK,10
	MOVEI N,1100
GIV2:	ILDB CH,BP
	LSH CH,4
	ILDB A,BP
	ADD CH,A
	ROT CHKSUM,^D11
	XOR CHKSUM,CH
	TRNE  F,SENDAT
	PUSHJ P,OUCH
	SOJG N,GIV2
	TLZ B,USEBIT
	MOVEM B,@C
	IMUL CHKSUM,ONES
	IDIV CHKSUM,PRIME
	MOVM CHKSUM,CHKSUM+1
	PUSHJ P,NUM03	;OUTPUT CHKSUM
	PUSHJ P,CHKCHR
	TRNN F,SENDAT
	SOJG NOBLX,NXT1
	TRO F,SENDAT
	JUMPL BDCNT,GIV3	;DONE IF BDCNT=0
	SOJE BADLIM,OVRLIM	;TOO MANY SENT
NXT1:	CAMGE COUNT,LASBLK
	AOJA COUNT,GIV1
	MOVEI A,5	;SLEEP FOR 5 SEC TO GIVE RECIP. A CHANCE
	CALLI A,SLEEP	;TO CATCH UP
	PUSHJ P,CHKCHR	;GET ANY INFO SENT
	JUMPGE BDCNT,GIV1-1
GIV3:	PUSHJ P,ESCOUT
	MOVEI CH,4
ONLAST:	PUSHJ P,OUT1	;OUTPUT LAST CODE
ENDIT:	PUSHJ P,ESCOUT
	MOVEI CH,12
	PUSHJ P,OUT1
	SETSTS TTY,0	;RESET TTY
	TTCALL 1,0
	RELEASE TTY,
	CALLI EXIT

GETFIL:	TRZ F,DONORF	;USER IS RECIP
	PUSHJ P,GETDSK
	TRO F,FIRSTF
	PUSHJ P,FINFIL	;IS OLD FILE ON DSK?
	JFCL
GET2:	MOVEM LASBLK,OLDSIZ
	PUSHJ P,LOKBAD	;YES-DOES .BAD EXIST?
	JFCL	;NO
	TRNE F,LOKOK	;YES,(SIZE IN LASBLK)
	JRST ONEFIL
	MOVEI CH,2
	TRNN F,BADLOK	;DOES BAD EXIST?
	MOVEI CH,3	;NEITHER FILE EXISTS
	SKIPA
ONEFIL:	MOVEI CH,1	;.OLD EXISTS
	PUSHJ P,OUT1	;AND TELL DONOR
	CAIN CH,3
	JRST SIZES
	CAMG LASBLK,OLDSIZ
	SKIPA N,OLDSIZ	;SEND LARGER SIZE
	MOVE N,LASBLK
	PUSHJ P,NUMOUT
SIZES:	SKIPN ,LASBLK
	TRZA F,BADLOK	;IF ZER SIZE, PRETEND FILE NOT THERE...
	MOVEM LASBLK,BADSIZ
	SETZ LASBLK,
	MOVE BP,[POINT 8,LASBLK,19]
	MOVEI N,2
	PUSHJ P,GETWD
	JUMPE LASBLK,BIGFIL
	CAIL LASBLK,177777	;LESS THAN LEGAL LIMIT?(^D65535)
	JRST BIGFIL	;YEP. ERROR
	MOVE BDCNT,LASBLK
	PUSHJ P,COMBAD	;COMPUTE # OF BLKS SENT BEFORE ERROR
	TRNE F,OLDBAD	;EITHER OLD OR BAD EXIST?
	ADD BADLIM,LASBLK	;YES, INCREASE NO. OF TRIES
	PUSHJ P,CHKCNT	;CHECK SIZE OF HDCNT
	TRZ F,NO252
	PUSHJ P,SET1
GETIT:	PUSHJ P,CHKCHR
	TRZ F,CONTF+CONTF1
	MOVE COUNT,CODE
	SETO CODE,
	JUMPE COUNT,BADSUM
	CAMLE COUNT,LASBLK
	JRST BADSUM
	PUSHJ P,CHKHD	;SEE IF THIS BLK IS IN YET?
	JRST MID1	;BLK ALLREADY GOOD..JUST TELL DONOR
	TRNN F,SENDAT
	JRST GETDT1	;READ DSK BLK TO COMPARE CHKSUM INSTEAD OF GETTING DATA
	MOVE BP,[POINT 4,DSKBLK]
	MOVEI N,1100	;SET UP TO ACCEPT 1100 BYTES
	MOVE CHKSUM,COUNT
MIDBLK:	PUSHJ P,INCH	;GET 1 BYTE
	PUSHJ P,CHK252	;SEE IF CHR IS 252
	SKIPA	;NOT 252 OR LEGAL 252 CHARACTER
	JRST GETIT	;ILLEGAL 252 CHARACTER
	TRZN F,EXT252	;LEGAL 252 FOUND?
	JRST MIDB	;NO, JUST A REGULAR CHR.
	TRZE F,EXT123	;YES, WAS IT LT. OR EQ. 3?
	JRST MIDB	;YES...OK(WAS 21,223 OR 252)
MIDC:	CAIN CH,7	;WAS IT A 7?
	JRST FUDGIT+1	;YES
	CAIE CH,10
	JRST GETIT	;IT WAS NOT A 10 OR 7
FUDGIT:	TROA F,SENDAT
	TRZ F,SENDAT
	TRO F,CONTF+CONTF1
	JRST GETIT
MIDB:	ROT CHKSUM,^D11
	XOR CHKSUM,CH
	MOVE A,CH
	ANDI A,360
	LSH A,-4	;GET LEFT MOST 4 BITS
	IDPB A,BP	;DEPOSIT
	ANDI CH,17	;GET RIGHT MOST 4 BITS
	IDPB CH,BP	;DEPOSIT
	SOJG N,MIDBLK	;DECREMNT COUNT
	PUSHJ P,ENDBLK	;GO WRITE A FULL BLK OUT
MIDA:	MOVEI N,3
	SETZ A,
	MOVE BP,[POINT 8,A,11]
	PUSHJ P,GETWD
	SKIPA
	JRST GETIT	;ILLEGAL CHR AFTER 252 FOUND...
	TRZN F,EXT252	;WAS A REG. CHR FOUND?
	JRST MIDA1	;YES, KEEP GOING
	TRZN F,EXT123	;WAS IT A 252-1,2,3?
	JRST MIDC	;NO, GO CHECK IT.
MIDA1:	IMUL CHKSUM,ONES
	IDIV CHKSUM,PRIME
	MOVM CHKSUM,CHKSUM+1
	CAME CHKSUM,A
	JRST CHKBLK
	PUSHJ P,SETHD
MID1:	SOJ BADLIM,	;DECREMENT NO. OF BLKS SENT
	PUSHJ P,ESCOUT
	MOVEI CH,6
	PUSHJ P,OUT1
	MOVE N,COUNT
	PUSHJ P,NUMOUT
	JUMPG BDCNT,GETIT
	JRST RENMIT

GETDT1:	CAMLE COUNT,BADSIZ	;IS BLK TOO BIG FOR .BAD FILE?
	JRST BADSUM
	TRNN F,OLDBAD
	JRST SYNERR
	TRNN F,BADLOK
	JRST MIDA
	USETI DSKO,@COUNT
	INPUT DSKO,DSKLST
	STATZ DSKO,760000
	JRST INOER1
	MOVE BP,[POINT 4,DSKBLK]
	PUSHJ P,COMCHK
	JRST MIDA

CHKBLK:	TRNE F,LOKOK	;WAS LOOKUP ON FILE OK?
	CAMLE COUNT,OLDSIZ	;IS BLK TOO BIG FOR .OLD FILE?
	JRST BADSUM	;YES..
	USETI DSK,@COUNT
	INPUT DSK,
	STATZ DSK,760000
	JRST INOERR
	MOVE BP,DSKCHK+1
	MOVEI CH,4
	DPB CH,SIZBP
	PUSHJ P,COMCHK
	IMUL CHKSUM,ONES
	IDIV CHKSUM,PRIME
	MOVM CHKSUM,CHKSUM+1
	CAME A,CHKSUM
	JRST BADSUM
	MOVE A,DSKCHK+1
	ADDI A,1
	HRLZS A,A
	HRRI A,DSKBLK
	HRRZ B,A
	ADDI B,177
	BLT A,@B
	PUSHJ P,ENDBLK
	JRST MID1-1
BADSUM:	SOJG BADLIM,GETIT
	JRST OVRLIM

;COMPUT CHKSUM IF FROM BLK INSTEAD OF INPUT

COMCHK:	MOVEI N,1100
	MOVE CHKSUM,COUNT
COM1:	ILDB CH,BP
	LSH CH,4
	ILDB D,BP
	ADD CH,D
	ROT CHKSUM,^D11
	XOR CHKSUM,CH
	SOJG N,COM1
	POPJ P,0

CHKRET:	TRNE F,DONORF	;IS USER DONOR?
	POPJ P,0	;YES, RETURN
CHKCHR:	TTCALL 13,0	;NO, IS THERE A CHR TO BE INPUT?
	JRST CHKRET	;NO, GO SEE IF I SHOULD RETURN
	PUSHJ P,INCH	;YES, INPUT IT
	CAIN CH,252	;ESCAPE INPUT?
	JRST ESCFND	;YES, GO PROCESS IT
	TRNN F,CONTF	;NO, DID WE ALLREADY GET ONE?
	JRST CHKCHR	;NO, FLAGS SHOULD BE OK, GET NEXT CHR
	TRNE F,CONTF1	;YES, DID WE GET VALID CODE?
	JRST BLKIN	;YES, GET BLK NO.
	CAIN CH,12	;IST IT A 12??
	JRST ENDIT	;YES,EXIT!!
	TRNN F,DONORF	;NO , IS THIS THE DONOR?
	JRST RECIN	;NO, GO CHECK RECIP CODES
CHKSIX:	CAIN CH,6	;YES, IS CODE A 6?
	JRST SETCF1	;YES, GET BLK NO.
	JRST CHKCLR	;NO, CLEAR ALL IF NOT A 252
SETCF1:	TRO F,CONTF1	;YES, SET FLAG FOR LEGAL CODE FOUND...
	JRST CHKCHR	;AND GET NXT CHAR.
BLKIN:	JUMPGE CODE,.+3	;CODE<0?
	MOVE CODE,CH	;YES,SAVE CH
	JRST CHKCHR	;AND GET NXT
	LSH CODE,10	;CODE >0, SHIFT LEFT 8 BITS
	ADD CODE,CH	;AND ADD NEW CHR.
	TRNN F,DONORF	;DONOR?
	POPJ P,0	;NO - ALL SET - RETURN(REINIT IN MAIN LINE)
	PUSH P,COUNT	;SAVE OLD COUNT
	MOVE COUNT,CODE	;GET THIS BLK NO.
	PUSHJ P,SETHD	;SET BIT IN HDCNT AND ADJUST BDCNT IF NECESARY
	POP P,COUNT	;RESTORE COUNT
CHKCLR:	CAIE CH,252	;WAS LAST CHR 252?
CLRALL:	TRZ F,CONTF	;NO, ZERO CONTROL
	TRZ F,CONTF1	;YES, ZER ONLY CODE
	SETO CODE,	;RESET CODE TO ALL ONES
	JRST CHKCHR	;AND GO GET NEXT SEQUENCE
ESCFND:	TROE F,CONTF	;SET CONTF - WAS IT SET BEFOORE?
	TRNN F,CONTF1	;YES - WAS CODE INPUT?
	JRST CHKCHR	; NO, GET NXT CHR
	TTCALL 13,0	;CHR TO BE INPUT?
	SKIPA	;NO - SLEEP
	JRST NXTCIN	;YES, GO GET IT
	MOVEI A,5
	CALLI A,SLEEP	;WAIT 5 SEC
	TTCALL 13,0	;CAN A CHR BE INPUT?
	JRST CLRALL	;NO - RESET ALL
NXTCIN:	PUSHJ P,INCH	;INPUT CHR
	PUSHJ P,FIX123	;CHECK FOR 1,2,3 AND SUBSTITUTE 252,21,223
	JRST BLKIN	;FOUND A 1,2,OR 3
	TRNE F,DONORF	;DONOR?
	JRST CHKSIX	;YES...CHECK FOR 6
RECIN:	CAIN CH,7	;SENDING ONLY CHKSUM?
	JRST REC1	;YES, ZERO BIT
	CAIE CH,10
	JRST CHKCLR	;NEITHER 10 NOR 7 - CLEAR ALL
	TROA F,SENDAT
REC1:	TRZ F,SENDAT
	JRST SETCF1

CHK252:	TRZ F,EXT252+EXT123
	CAIE CH,252
	POPJ P,0
	PUSHJ P,INCH
FIX123:	CAIN CH,1
	MOVNI	CH,252
	CAIN CH,2
	MOVNI CH,21
	CAIN CH,3
	MOVNI CH,223
	JUMPG CH,.+2
	TRO F,EXT123
	CAIN CH,10
	MOVNI CH,10
	CAIN CH,7
	MOVNI CH,7
END123:	JUMPL CH,.+3
ILLCHR:	AOS (P)	;ILLEGAL CHR AFTER 252 FOUND
	POPJ P,0
	MOVMS CH,CH
	TRO F,EXT252
	POPJ P,0

SET123:	CAIN CH,252
	MOVNI CH,1
	CAIN CH,21
	MOVNI CH,2
	CAIN CH,223
	MOVNI CH,3
	JRST END123

;COMPUTE LIMIT FOR BAD SENDS
COMBAD:	MOVE A,LASBLK
	MOVE BADLIM,A
	IDIVI A,^D10
	ADDI A,5	;10% +5
	ADD BADLIM,A
	POPJ P,0

;SET UP BP FOR HDCNT
SETBP:	CAMLE COUNT,LASBLK
	JRST SETEND
	MOVE A,COUNT
	IDIVI A,^D36
	MOVE BP,[POINT 1,HDCNT]
	JUMPN B,.+3
	SUBI A,1	;FIX FOR MULTIPLES OF 36
	MOVEI B,44
	ADD BP,A
	LDB A,BITBP
	SUB A,B
	DPB A,BITBP
SETEND:	POPJ P,0

;CHK FOR BIT SET
CHKHD:	PUSHJ P,SETBP
	LDB A,BP
	SKIPN ,A
	AOS (P)
	POPJ P,0

;SET BIT IF NECESSARY
SETHD:	PUSHJ P,CHKHD
	POPJ P,0	;IF ALLREADY SET, RETURN
	SOJ BDCNT,
	MOVEI A,1
	DPB A,BP
	POPJ P,0

SET1:	MOVE A,FILNAM
	HRLZI B,(SIXBIT/BAD/)
	HRLZI C,100000
	MOVE D,PPN
	ENTER DSKO,A
	JRST LERBAD
	POPJ P,0

ENDBLK:	USETO DSKO,@COUNT
	OUTPUT DSKO,DSKLST
	STATZ DSKO,760000
	JRST INOER1
	TRZN F,FIRSTF
	POPJ P,0
	TRNE F,BADLOK
	POPJ P,0
	CLOSE DSKO,
	PUSHJ P,LOKBAD
	JRST LERBAD
	PUSHJ P,SET1
	POPJ P,0

;CHECK SIZE OF HDCNT AND EXPAND SIZE OF CORE IF NECESSARY
CHKCNT:	MOVE A,LASBLK
	IDIVI A,44	;GET NO. OF WDS NEEDED
	ADDI A,1
	SUBI A,SIZHD	;GET DIFFERENCE
	SKIPG ,A
	POPJ P,0	;OK, SIZE IS < ALLREADY SET UP
	MOVEI B,HDCNT
	ADDI B,SIZHD
	ADD B,A
	CALLI B,GETCOR
	JRST MISERR
	POPJ P,0	;RETURN

;LOOKUP FILENAM,EXTENSION
LOKFIL:	MOVE A,FILNAM
	HLLZ B,FILNAM+1
	SETZ C,
	MOVE D,PPN
	LOOKUP DSK,A
	JRST CHKERR
	AOS (P)
	TRO F,LOKOK
	POPJ P,0
CHKERR:	HRRZS B,B
	JUMPE B,.+2
	JRST LOKERR
	POPJ P,0

;LOOKUP FILENAME, "BAD"
LOKBAD:	MOVE A,FILNAM
	HRLZI B,(SIXBIT/BAD/)
	SETZ C,
	MOVE D,PPN
	LOOKUP DSKO,A
	POPJ P,0
	TRNN	F,FIRSTF
	JRST .+3
	TRO F,BADLOK
	JRST FINFIL+2
	AOS (P)
	POPJ P,0

RENMIT:	CLOSE DSKO,
	MOVE A,[XWD 12,16]
	CALLI A,GETTAB	;GET STANDARD PROTECION
	JRST MISERR
	MOVEM A,STPROT
	TRZN F,LOKOK	;WAS THERE A GOOD LOOKUP ON THE FILE?
	JRST RENAM1	;NO, JUST RENAME BAD TO EXT
	PUSHJ P,LOKFIL	;LOOKUP FILE
	JRST LOKERR
	SETZB A,B
	SETZ C,
	MOVE D,PPN
	RENAME DSK,A
	JRST LOKERR
	CLOSE DSK,
	RELEASE DSK,
RENAM1:	PUSHJ P,LOKBAD	;BE SURE TO CHECK SIZE OF OLD VS. NEW HERE!!!
	JRST LERBAD
	CAMGE LASBLK,BADSIZ
	JRST RENAM2	;SHORTEN FILE!
	MOVE A,FILNAM
	HLLZ B,FILNAM+1
	MOVE C,STPROT	;GET STANDARD PROTECTION
	MOVE D,PPN
	RENAME DSKO,A
	JRST LOKERR
HAP1:	RELEASE DSKO,
	MOVEI B,^D20
	MOVEI N,5
HAPMSG:	PUSHJ P,ESCOUT
	TTCALL 15,N
	TTCALL 15,B
	TTCALL 13,0	;IS A CHR WAITING?
	JRST HAP2	;NO, KEEP TELLING DONOR I AM HAPPY
	PUSHJ P,INCH	;YES, GETIT
	CAIE CH,252
	JRST HAP2	;IF NOT 252, IGNORE IT
	PUSHJ P,INCH
	CAIN CH,12
	JRST ENDIT	;SAYS DONOR HAPPY AND EXITED.GOOD, I WILL TO!
HAP2:	SOJG B,HAPMSG	;RECIP IS HAPPY!!! KEEP TELLING MIDDLEMAN
	JRST ENDIT	;ONLY 2000 TIMES...OR TIL DONOR HAPPY
RENAM2:	MOVEI A,11	;NO. OR ARGUMENTS
	MOVEM A,EXTARG
	MOVEM LASBLK,FILSIZ	;SAV NEW FILE SIZE
	MOVE A,STPROT
	MOVEM A,EXTARG+4
	RENAME DSKO,EXTARG	;DO EXTENDED RENAME
	JRST EXTERR
	JRST HAP1

GETDSK:	TRNN F,DONORF
	JRST GETDK1
	INIT DSK,13	;INIT DSK BUFFERED BINARY MODE
	SIXBIT /DSK/
	DSKIN
	JRST MISERR
	INBUF DSK,1
	POPJ P,0
GETDK1:	INIT DSKO,17
	SIXBIT/DSK/
	0
	JRST MISERR
	INIT DSK,13
	SIXBIT /DSK/
	DSKCHK
	JRST MISERR
	INBUF DSK,1
	POPJ P,0

;ANY KIND OF ERR...OR MESSAGE
ESCOUT:	MOVEI A,252
	TTCALL 15,A
	POPJ P,0

;ERROR MESSAGE FOLLOWS
ERROUT:	TRNE F,NO252	;IF TOO EARLY, DON'T DO IT!
	POPJ P,0
	PUSHJ P,ESCOUT
	MOVEI CH,11
	PUSHJ P,OUT1
	POPJ P,0

;OUT OF SYNC ERROR
SYNERR:	PUSHJ P,ERROUT
	MOVEI CH,164
	JRST ONLAST

;ERROR ON EXTENDED RENAME
EXTERR:	MOVE B,EXTARG+3
LERBAD:	ADDI B,200	;ERROR WAS ON .BAD FILE
;LOOKUP, ENTER OR RENAME ERROR
LOKERR:	PUSHJ P,ERROUT
	HRRZ CH,B
	ADDI CH,142
	JRST ONLAST

;INPUT OR OUTPUT ERROR
INOERR:	PUSHJ P,ERROUT
	GETSTS DSK,CH	;GET ERROR BITS
	HRLI CH,0	;ZER OUT LEFT HALF
	LSH CH,-15	;SHIFT
	ADDI CH,100
	TRZE F,ERRBAD	;ERROR ON .BAD FILE?
	ADDI CH,200	;YES...ADD 200
	JRST ONLAST
INOER1:	PUSHJ P,ERROUT
	GETSTS DSKO,CH
	TRO F,ERRBAD	;SET FLAG FOR BAD FILE ERROR
	JRST INOERR+2

;FILE TOO BIG
BIGFIL:	PUSHJ P,ERROUT
	MOVEI CH,165
	JRST ONLAST

; NO. OF BLKS SENT IS OVER LIMIT(10%)
OVRLIM:	PUSHJ P,ERROUT
	MOVEI CH,166
	JRST ONLAST

;MISC. ERROR
MISERR:	PUSHJ P,ERROUT
	MOVEI CH,163
	JRST ONLAST

;USER NAME NOT VALID
BADNAM:	PUSHJ P,ERROUT
	MOVEI CH,167
	JRST ONLAST

;I/O ROUTINES
OUCH:	TRNE F,NO252
	JRST OUT1
	PUSHJ P,SET123	;SUBSTITUE 1,2,3 FOR 252,21,223
	PUSHJ P,ESCOUT	;CH WAS A 1,2,OR 3
OUT1:	TTCALL 15,CH
	POPJ P,0

INCH:	SOSLE ,TTYI+2
	JRST INCH1
INCH2:	INPUT TTY,
	STATO TTY,20000
	JRST INCH3
	CLOSE TTY,
	JRST INCH2
INCH3:	SKIPG TTYI+2
	JRST INCH2
INCH1:	ILDB CH,TTYI+1
	ANDI CH,377
	CAIN CH,252
	TRNN F,NO252
	POPJ P,0
	ILDB CH,TTYI+1
	ANDI CH,377
	CAIE CH,12
	JRST SYNERR
	JRST ENDIT

;INPUT "N" 8 BIT BYTES
GETWD:	PUSHJ P,INCH
	ANDI CH,377
	TRNE F,NO252
	JRST GET1
	PUSHJ P,CHK252
	SKIPA	;NOT A 252, OR FOUND A LEGAL CHR
	JRST ILLCHR	;252 FOLLOWED BY ILLEGAL CHR
	TRNN F,EXT252
	JRST GET1	;CHR WAS NORMAL
	TRNN F,EXT123	;WAS IT A 1,2,OR3?
	POPJ P,0	;NO, RETURN
GET1:	IDPB CH,BP
	SOJG N,GETWD
	POPJ P,0

;OUTPUT A NUMBER IN 2 8 BIT BYTES
NUMOUT:	MOVE BP,[POINT 8,N,19]
	ILDB CH,BP
	PUSHJ P,OUCH
	ILDB CH,BP
	PUSHJ P,OUCH
	POPJ P,0
NUM03:	MOVE BP,[POINT 8,CHKSUM,11]
	ILDB CH,BP
	PUSHJ P,OUCH
	JRST NUMOUT+1

;STORAGE
TTYI:	BLOCK 3
DSKIN:	BLOCK 3
DSKLST:	IOWD 200,DSKBLK
	0
DSKBLK:	BLOCK 200
DSKCHK:	BLOCK 3
PDP:	XWD -20,.
	BLOCK 21
PATCH:	BLOCK 20
ONES:	XWD 111,111111
PRIME:	^D16777213
BITBP:	POINT 6,BP,5
SIZBP:	POINT 6,BP,11
SIZHD==70
ZERST:	0
STPROT:	0	;STANDARD PROTECTION
USRNAM:	BLOCK 2
EXTARG:	0	;NO. OF ARGUMENTS IN EXTENDED RENAME
PPN:	0
FILNAM:	BLOCK 7	;FILENAME AND EXTENSION
FILSIZ:	0	;NEW FILE SIZE
BADSIZ:	0	;ORIGINALSIZE OF .BAD FILE
OLDSIZ:	0	;SIZE OF .OLD FILE
HDCNT:	BLOCK SIZHD
;EXPAND IF LASBLK>70(>2016.BLK FILE)
	END GIVTAK
