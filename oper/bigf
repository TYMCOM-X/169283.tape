        SUBROUTINE BEGIN
C
C       COMMON DECLARATIONS FOR MIP
C DECLARATIONS MADE 6/13/73
        COMMON /MIPCOM/ V,AV,WDCNT,DUEL,PRIM,IR,IK,RI,L,M,N
        COMMON /MIPCOM/ Q,QP,QPP,NETA,MAXETA,PRIM,NODUAL,NOPRIM
        COMMON /MIPCOM/ BIG,NPM,MP1,NP1,DELTA,UNB,ITYPE,ISTAR,IRP,IRPP

        COMMON /LINCNT/ LINE
C       LINE IS CURRENT LINE NO. IN CREATE FILE
C
C       DICT IS ALOCAL ARRAY ONLY
C       SETIT UP A BLANK COMMON AND LET IT
C    BE OVER WRITTEN LATER
C
        COMMON DICT(0/4002)
        TYPE INTEGER DICT
        TYPE INTEGER V,AV,CB,CN,WDCNT,DUEL ,PRIM,UNB,RI
C
C
C
C       COMPUTE M AND N FOR DYNAMIC DIMENSIONING
C

        IFLAG =0
        IFLAG2 = 0
        LINE = 0
C
C       OPEN INPUT FILE
C
        CALL BFILE(1,LPDAT,0,'INPUT')
C
C       READ TITLE
C
19      READ (1,12,END = 90001) ITEMP
        IF(ITEMP .EQ. 'ROW I') GO TO 20
        LINE = LINE + 1
        GO TO 19
20      READ(1, 12, END=90001) ITEMP
12      FORMAT(2A5)
        LINE = LINE + 1
        IF(ITEMP .EQ. M) GO TO 22
        IF(ITEMP .EQ. '     ') GO TO 90004
        IFLAG =  IFLAG + 1
        GO TO 20

22      IFLAG2 = 0
23      READ(1, 13, END=90001) ITEMP, ITEMP2
13      FORMAT(A1,A5)
        LINE = LINE + 1
        IF(ITEMP.EQ.'S'.OR.ITEMP.EQ.'Z'.OR.ITEMP.EQ.'F'.AND.
     +  ITEMP2.EQ.'     ') GO TO 25

        IF(ITEMP.EQ.' '.AND.ITEMP2.EQ.'     ') GO TO 90005
        DO 24 I = 0, IFLAG2
        IF(ITEMP2 .EQ. DICT(IFLAG+I)) GO TO 23
24      CONTINUE

        IFLAG2 = IFLAG2 + 1
        DICT(IFLAG+IFLAG2) = ITEMP2
        GO TO 23

25      IFLAG2 = IFLAG2 + 1
        IF(IFLAG2.EQ.1 .OR. IFLAG.EQ.1) GO TO 90001
        IF(IFLAG.GT.2001 .OR. IFLAG2.GT.2001) GO TO 26
        IFLAG = IFLAG + 1
        IFLAG2 = IFLAG2 + 1
        GO TO 23
        IF(IERR .LT. 0) GO TO 90002
26      TYPE 90000
90000   FORMAT(/1X,'PROBLEM SIZE TOO BIG, EXECUTION ABORTED.'/)
        GO TO 90002

90004   TYPE 90006
        TYPE 90008, LINE
        GO TO 90002

90006   FORMAT(/1X,'BLANK LINE OR ILLEGAL FORMAT IN ROW ID INPUT.'/)
        GO TO 90002

90005   TYPE 90007
        TYPE 90008
90007   FORMAT(/1X,'BLANK LINE OF ILLEGAL FORMAT IN MATRIX INPUT.'/)
        GO TO 90002
90001   TYPE 90003
90003   FORMAT(/1X,'PREMATURE END OF FILE. CHECK INPUT FORMAT.'/)
        GO TO 90002
90008   FORMAT(/1X,'REFER TO LINE NUMBER', I6,/)

C
C       OPEN TEMPORARY FILE
C
        OPEN(2,'ROWCOL', OUTPUT, BINARY)

C
C       CALL START VIA DYNARY TO ALLOCATE SPACE FOR ARRAYS
C

        M = IFLAG - 1
        N = IFLAG2 - 1
        NPM = N+M+2
        NP1 =N+1
        MP1 = M+1
        MAXETA = M+1
        CALL DYNARY(IERR,START,MP1,M,N,N,N,M,N,M,M,N,NPM,NP1,MP1,
     +  N,N,MAXETA,N,N,NPM)
90002   END
        SUBROUTINE START(A,B,C,BU,BL,CB,CN,CBC,BETA,PI,NFLAG,TEMP,
     +  ETA,PIP,ALPHA,INDETA,INDA,RINV,DICT)
C
C       COMMON DECLARATIONS FOR MIP
C DECLARATIONS MADE 6/13/73
        COMMON /MIPCOM/ V,AV,WDCNT,DUEL,PRIM,IR,IK,RI,L,M,N
        COMMON /MIPCOM/ Q,QP,QPP,NETA,MAXETA,PRIM,NODUAL,NOPRIM
        COMMON /MIPCOM/ BIG,NPM,MP1,NP1,DELTA,UNB,ITYPE,ISTAR,IRP,IRPP

        COMMON /LINCNT/ LINE
C       LINE IS CURRENT LINE NO. IN CREATE FILE
        TYPE INTEGER DICT
        TYPE INTEGER V,AV,CB,CN,WDCNT,DUEL ,PRIM,UNB,RI
C
C
        DIMENSION A(1),B(1),C(1),BU(1),BL(1),CB(1),CN(1),CBC(1),
     +  BETA(1),PI(1),NFLAG(1),TEMP(1),ETA(1),PIP(1),ALPHA(1)
        DIMENSION INDETA(1),INDA(1),RINV(1),DICT(0/1)   
        DIMENSION NAMES(5)
        DATA /5HCHSIN,5HOBJEC,3HRHS,5HROW I/
        
        COMMON /DICTC/ DICT(0/4002)
        TYPE INTEGER DICT
CCOMMON DECLARATIONS HERE
C
C       INITIALIZE UPPER AND LOWER BOUNDS
C
C
C       INITIALIZE DICT TO BLANKS
C
        DO 5 I = 1, N+M
5       DICT(I) = 5H

C
C       SET VALUE FOR INFINITY
C
        

        BIG = 1.E38

13      FORMAT(5A5)

C
C       READ TABLEAU OPTION, TOLERANCES AND OPTIONAL OUTPUT INDICATOR
C
        READ(1,20) ISW
20      FORMAT(A5)
        READ(1,21) TOL,TOL1,OPTION
21      FORMAT(2G,I)
        WRITE (ID,10)
10      FORMAT(/)
        WRITE (ID,30) (ITIT(I), I = 1,5)
30      FORMAT(20X,5A5,/1X,70('-'))

        CHSIN = 0.
C
C       READ...
C       1) OBJECTIVE FUNCTION NAME
C       2) CHSIN OPTION FOR MINIMISATION
C       3) ROW ID
C
40      READ (1,50) NAME, A9, A1
50      FORMAT(A5,A1,1X,A5)
        WRITE(5,55) NAME, A9, A1
55      FORMAT(1X,A5,A1,9X,A5)

42      DO 100 I = 1, 4
        IF(NAME - NAMES(I)) 100, 60, 100
60      GO TO (70, 80, 90, 110), I
70      CHSIN = 1.
        GO TO 40

80      OBJ1 = A1
        GO TO 40
90      RHS1 = A1
        GO TO 40

100     CONTINUE

        GO TO 40

110     CONTINUE

C
C       CALL RD ROW TO SET UP ROW ID-S AND VALUES.
C
C
        CALL RDROW(CB,B,DICT)

C
C       CALL CONVA TO READ INPUT FILE AND CONVERT 
C       MATRIX TO COLUMN FORMAT.
C
C
        CALL CONVA(KX,DICT,A,TEMP,C,CN)
C
C       CAL RDLST TO READ UPPER AND LOWER BOUNDS, AND 
C       DETERMINE CONSTRAINTS ON VARIABLES
C

        CALL RDLST(KX,NFLAG,BU,BL,DICT)

C
C       CONVERT A MATRIX TO FINAL FORM.  ADJUST 
C       CONSTRAINTS AGAINST POSITIVE LOWER BOUNDS.
C

        CALL CONVF(BETA,B,A,TEMP,PI,BU,BL,INDA)
        CALL MAIN(A,B,C,BU,BL,CB,CN,CBC,BETA,PI,NFLAG,TEMP,ETA,
     +  PIP,ALPHA,INDETA,INDA,RINV,DICT)
        
        RETURN
        END
       SUBROUTINE CONVA(KX,DICT,A,TEMP,C,CN)
C
C       COMMON DECLARATIONS FOR MIP
C DECLARATIONS MADE 6/13/73
        COMMON /MIPCOM/ V,AV,WDCNT,DUEL,PRIM,IR,IK,RI,L,M,N
        COMMON /MIPCOM/ Q,QP,QPP,NETA,MAXETA,PRIM,NODUAL,NOPRIM
        COMMON /MIPCOM/ BIG,NPM,MP1,NP1,DELTA,UNB,ITYPE,ISTAR,IRP,IRPP

        COMMON /LINCNT/ LINE
C       LINE IS CURRENT LINE NO. IN CREATE FILE
        TYPE INTEGER DICT
        TYPE INTEGER V,AV,CB,CN,WDCNT,DUEL ,PRIM,UNB,RI
C
C
C       COMMON DECLARATIONS FOR MIP
C DECLARATIONS MADE 6/13/73
        COMMON /MIPCOM/ V,AV,WDCNT,DUEL,PRIM,IR,IK,RI,L,M,N
        COMMON /MIPCOM/ Q,QP,QPP,NETA,MAXETA,PRIM,NODUAL,NOPRIM
        COMMON /MIPCOM/ BIG,NPM,MP1,NP1,DELTA,UNB,ITYPE,ISTAR,IRP,IRPP

        COMMON /LINCNT/ LINE
C       LINE IS CURRENT LINE NO. IN CREATE FILE
        TYPE INTEGER DICT
        TYPE INTEGER V,AV,CB,CN,WDCNT,DUEL ,PRIM,UNB,RI
C
C
        DIMENSION DICT(0/1),A(1),TEMP(1),C(1),CN(1)
        DIMENSION IA(1),ITEMP(1)
        EQUIVALENCE (A(1),IA(1)),(TEMP(1),ITEMP(1))
C
C       CONVA CREATES AN M * N MATRIX FROM THE INPUT FILE
C       GENERATED BY CREATE.  THIS MATRIX IS STORED
C       COLUMN-WISE WITH THE  THE WORD COUNT 
C       AND STARTING ADDRESS OF THE I-TH COLUMN IN INDA(I).
C       THIS MATRIX IS CREATED IN 2 PASSES. THE FIRST PASS READS THE
C       INPUT FILE AND STORES EACH ELEMENT ENCOUNTERED ON A TEMPOREARY
C       FILE -ROWCOL-.  ENTRIES ON THIS FILE ARE OF THE FORM -
C       ROW INDEX, COLUMN INDEX, VALUE.
C
C       CONVA THEN MANIPULATES THIS FILE, RETRIEVING ALL ELEMENTS OF THE 
C       I-TH COLUMN (I RUNS FROM 1 TO M) AND PLACING THEM IN A
C       TEMPORARY VECTOR -PI-.  THIS VECTOR IS COMPRESSED (BY SQUEEZING
C       ZEROES) AND PLACED IN VECTOR -A-. -A- IS THEN WRITTEN TO THE
C       MATRIX FILE
C
C
C       UPON ENTRY TO -CONVA- THE INPUT FILE IS POSITIONED AT
C       LINE 'ROW ID' + 1
C
        NDICT = M
        IND = 1
        KURROW = 0
        KURI = 0
        KURCOL = 0
        KURJ = 0
C       SET SIZE LIMIT OF TEMP FILE VECTORS
        LIM = (NP1/3) * 3
C
C       BEGINNING OF MAIN LOOP
C
C       READ AN ENTRY FROM CREATE FILE
C
C       
2000    READ(1,2010,END=6020) KX, ICOL, IROW,VAL
2010    FORMAT(A1,1X,A5,1X,A5,1X,G)
        LINE = LINE + 1
C       CHECK FOR END OF MATRIX
        IF(KX .NE. ' ') GO TO 3000
C       CHECK FOR BLANK LINES
        IF((ICOL .EQ.'     ') .OR. (IROW .EQ. '     ') GO TO 1500
        IF(KURROW .EQ. 0) GO TO 1000
        IF(KURROW .EQ. IROW) GO TO 1100
1000    KURROW = IROW
C       GET ROW INDEX
        KURI = IDICT(IROW, DICT, M)
      IF(KURI .LT. 0) GO TO 6000
1100    IF(KURCOL .EQ.0) GO TO 1200
        IF(KURCOL .EQ. ICOL) GO TO 1300
1200    KURCOL = ICOL
C
C       GET COLUMN INDEX
        KURJ = JDICT(ICOL, DICT, M, N)
C
C       CHECK TO SEE IF THIS IS AN OBJECTIVE FUNCTION COEFFICIENT
C
1300    IF(KURI .NE. 0) GO TO 1400
C
C       ENTER OBJECTIVE FUNCTION COEFFICIENT
C
        C(KURJ) = VAL
        CN(KURJ) = KURJ + M
C       NOW GO READ ANOTHER ENTRY
        GO TO 2000
C
C       MAKE ROW, COLUMN, VALUE ENTRY, BUT FIRST CHECK TO SEE
C       IF BUFFER FULL
C
        IF((IND+2) .LE. LIM) GO TO 1400
        IND = IND - 1
        WRITE (2) (TEMP(I), I = 1, IND)
1400    ITEMP(IND) = IROW
        ITEMP(IND+1) = ICOL
        TEMP(IND+2) = VAL
        IND = IND + 3
        GO TO 2000

1500    TYPE 1510, LINE
1510    FORMAT(/1X,'REFER TO LINE NUMBER ',I8,/)
        TYPE 1520
1520    FORMAT(/1X,'BLANK LINE IN VARIABLE INPUT, IGNORED'/)
        GO TO 2000

6000    TYPE 1520
        TYPE 6010,IROW,ICOL, VAL
6010    FORMAT(/1X,'FOLLOWING ENTRIES NOT IDENTIFIED ON ROW ID'
     +  ' LIST IGNORED',/)
        KURROW = 0
        GO TO 2000
C
C       HERE FOR PREMATURE EOF
C
6020    TYPE 1520
        TYPE 6030
6030    FORMAT(/1X,'PREMATURE END OF FILE ON CREATE FILE',/)
        GO TO 7000
C
C       FLAG END OF FILE AND REWIND
C
3000    END FILE 2
        REWIND 2
        CLOSE(2)
        RETURN
        END




        SUBROUTINE CONVF(BETA,B,A,TEMP,PI,BU,BL,INDA)
C
C       COMMON DECLARATIONS FOR MIP
C DECLARATIONS MADE 6/13/73
        COMMON /MIPCOM/ V,AV,WDCNT,DUEL,PRIM,IR,IK,RI,L,M,N
        COMMON /MIPCOM/ Q,QP,QPP,NETA,MAXETA,PRIM,NODUAL,NOPRIM
        COMMON /MIPCOM/ BIG,NPM,MP1,NP1,DELTA,UNB,ITYPE,ISTAR,IRP,IRPP

        COMMON /LINCNT/ LINE
C       LINE IS CURRENT LINE NO. IN CREATE FILE
        TYPE INTEGER DICT
        TYPE INTEGER V,AV,CB,CN,WDCNT,DUEL ,PRIM,UNB,RI
C
C
        DIMENSION BETA(1),B(1),A(1),TEMP(1),PI(1),BU(1),BL(1)
        DIMENSION INDA(1)
CCOMMON DECLARATIONS HERE
        DIMENSION IA(1)
        EQUIVALENCE (A(1),IA(1))
C
C       CONVF TAKES THE TEMPORARY FILE -ROWCOL- CONTAINING 3 WORD
C       ENTRIES OF THE FORM; ROW INDEX, COLUMN INDEX, VALUE AND 
C       WRITES THEM TO THE  A MATRIX FILE -AMTFIL-
C       IN COLUMN FORMAT, I.E. THE ENTRY IN THE ARRAY -INDETA(I) 
C       CONTAINES THE WORD COUNT AND RECORD POSITION OF THE
C       I-TH COLUMN OF A.
C       CONVF ALSO ADJUSTS THE B, C, AND BETA VECTORS TO COMPENSATE 
C       FOR POSITIVE LOWER BOUNDSS
C
C
C       RE-OPEN TEMP FILE FOR INPUT
C
        OPEN(2,'ROWCOL',INPUT,BINARY)

C
C       OPEN A MATRIX FILE
C

        AU = 3
        OPEN(3,'AMTFIL',RANDIO(130),BINARY)

C
C       INITIALIZE BETA VECTOR
C
        DO 3010 I = 1, M
3010    BETA(I) = B(I)

C
C       NOW READ THE -ROWCOL- FILE AND CONSTRUCT THE
C       I-TH COLUMN OF A, WHERE A RUNS FROM 1 TO N.
C
C       GET INITIAL POSITION OF A FILE
        AV = POSITION(AU)
C       SET INITIAL COLUMN INDEX TO A
        IND = 1
C
C       INITIALIZE A VECTOR TO ZERO
C

3020    DO 3100 I = 1,M
3100    A(I) = 0.
3150    READ(2,END=3600) (TEMP(II), II = 1, LIM)
C       INITIALIZES NUMBER OF ENTRIES FOR THIS COLUMN
        NENT = 0


        DO 3500 II = 1, LIM-3, 3
C       LOOK FOR ELEMENT IN CURRENT COLUMN
        IF(ITEMP(II+1) .NE. IND) GO TO 3500
C       ENTRY IN CURRENT COLUMN
        PI(ITEMP(II)) = TEMP(II+2)
        NENT = NENT + 1
        IF(NENT .EQ. M) GO TO 3600
3500    CONTINUE

C

CHAVE WE PROCESSED ALL COLUMNS
C
        IF(IND .EQ. N) GO TO 4500
        IND = IND + 1
        GO TO 3150
C
C
C       HERE WHEN VECTOR FILLED OR  EOF ENCOUNTERED
C
3600    REWIND 2
C
C       AT THIS POINT WE HAVE THE IND-TH COLUMN OF A
C       IN VECTOR -PI-.
C
C       NOW ADJUST CONSTRAINTS FOR POSITIVE LOWER BOUNDS
C
        IF(BL(IND) .LE. 0) GO TO 3620
        SUB = BL(IND)
        BL(IND) = 0

        IF(BL(IND) .EQ. BIG) GO TO 3602
        BU(IND) = BU(IND) - SUB
3603    DO 3610 I = 1, M
        IF(PI(I) .EQ. 0) GO TO 3610
        B(I) = B(I) - SUB * PI(I)
        BETA(I) = B(I)
3610    CONTINUE

3620    CONTINUE
C
C       COMPRESS VECTORS BY SQUEEZING ZEROES
C
C       I IS INDEX TO A
C       J IS INDEX TO PI
C
        I = 1
        DO 400 J = 1, NENT
C       CHECK FOR 2 OR MORE CONTIGUOUS ZEROES
C
        IF(PI(J) .NE. 0) GO TO 3850
        IF(PI(J+1).NE. 0) GO TO 3850
C       HERE TO COUNT SQUEEZED ZEROES
        DIMENSION IA(1)
        IA(I) = 2
        J = J + 2
3700    IF(PI(J) .NE. 0) GO TO 3900
C       INCREASE ZERO COUNT
        IA(I) = IA(I) + 1
        J = J + 1
        IF(J .LE. M) GO TO 100
C       FALL THROUGH INDICATES DONE WITH PI
        GO TO 4100
3900    J = J -1
C       RESET INDEX AND CONTINUE LOOP
        GO TO 3800
3850    A(I) = PI(J)
3800    I = I + 1
4000    CONTINUE


C
C       WRITE COLUMN TO A MATRIX FILE
C

4100    AV = POSITION(AU)
        KK = AV
        WRITE(AU#AV) (A(K), K = 1, I)
C
C       SET WORD COUNT AND POSITION
C
        INDA(IND) = (I**18) .OR. AV
        GO TO 3020
C
C       HERE WHEN FINISHED OUT COMPLETE MATRIX
C
C**** ADD STATISTICS ABOUT SPARCITY OF MATRIX
        RETURN
        END


        FUNCTION IDICT(IR, KDICT,M)
C       NO COMMON REQUIRED
        DIMENSION KDICT(0/1)
        
C       IDICT RETURNS AS ITS VALUE THE INDEX TO DICT WHERE
C       (DICT(I)) = IR. IF NO MATCHING ENTRY IS FOUND IN THE
C       FIRST M ENTRIES , A NEGATIVE VALUE IS RETURNED.

        DO 100 I = 0, M
        IF(KDICT(I) .EQ. IR) GO TO 200
100     CONTINUE

        IDICT = -1
        RETURN

200     IDICT = I
        RETURN
7000    END


        FUNCTION JDICT(IC, KDICT, M,N)
        DIMENSION KDICT(0/1)
C
C       COMMON DECLARATIONS FOR MIP
C DECLARATIONS MADE 6/13/73
        COMMON /MIPCOM/ V,AV,WDCNT,DUEL,PRIM,IR,IK,RI,L,M,N
        COMMON /MIPCOM/ Q,QP,QPP,NETA,MAXETA,PRIM,NODUAL,NOPRIM
        COMMON /MIPCOM/ BIG,NPM,MP1,NP1,DELTA,UNB,ITYPE,ISTAR,IRP,IRPP

        COMMON /LINCNT/ LINE
C       LINE IS CURRENT LINE NO. IN CREATE FILE
        TYPE INTEGER DICT
        TYPE INTEGER V,AV,CB,CN,WDCNT,DUEL ,PRIM,UNB,RI
C
C
C
C       JDICT SEARCHES FROM KDICT(M+1) THROUGH KDICT(N)
C       FOR A MATCH WITH -IC-.  IF NO MATCH IS FOUND,
C       N IS INCREMENTED, AND THE VALUE OF JDICT IS RETURNED
C       AS N
C
C
        IF(N .NE.0) GO TO 100
        KDICT(1) = IC
        JDICT = 1
        N = 1
        RETURN


100     DO 200 I = M+1, M+N
        IF(KDICT(I) .EQ. IC) GO TO 300
200     CONTINUE

        N = N + 1
        KDICT(N) = IC
        JDICT = N
        RETURN
300     JDICT = I
        RETURN
7000    END
        SUBROUTINE RDROW(CB,B,DICT)
C
C       COMMON DECLARATIONS FOR MIP
C DECLARATIONS MADE 6/13/73
        COMMON /MIPCOM/ V,AV,WDCNT,DUEL,PRIM,IR,IK,RI,L,M,N
        COMMON /MIPCOM/ Q,QP,QPP,NETA,MAXETA,PRIM,NODUAL,NOPRIM
        COMMON /MIPCOM/ BIG,NPM,MP1,NP1,DELTA,UNB,ITYPE,ISTAR,IRP,IRPP

        COMMON /LINCNT/ LINE
C       LINE IS CURRENT LINE NO. IN CREATE FILE
        TYPE INTEGER DICT
        TYPE INTEGER V,AV,CB,CN,WDCNT,DUEL ,PRIM,UNB,RI
C
C
        DIMENSION DICT(0/1)
C
C       RDROW READS THE ROW NAMES  AND VALUES AND ENTERS 
C       THE INPUT FILE UPON ENTRY SHOULD BE POSITIONED AT LINE
C       'ROW ID' + 1.C
C


C       
C       READ ROW ID, R,H,S, VALUES
C
C       LAST ROW IS MATRIX TITLE
C

C
C       INITIALIZE FIRST ENTRY IN DICT. THIS IS OBJECTIVE 
C       FUNCTION NAME.
        DICT(1) = OBJ1
20      READ(1,30) KX, B, ITAIL, Y
30      FORMAT(A1,A1,1X,A5,1X,G)
        IF(KX .EQ. ' ') GO TO 70
        IF(OPTION .EQ. 0) GO TO 200
        TYPE 37
37      FORMAT(1X,'MATRIX')
        GO TO 200
70      IF(OPTION .EQ. 0) GO TO 71
C       MAKE ENTRY IN DICT FOR THIS ROW. INDEX TO DICT IS
C       RETURNED IN I..
        TYPE 35,KX, KB, ITAIL, Y
35      FORMAT(1X,A1,10X,A1,1X,A5,1X,G)
71      I = NDICT(ITAIL,DICT,M)
        CB(I) =I
C       CHECK FOR OBJECTIVE FUNCTION NAME
        IF(OBJ1 .EQ. ITAIL) GO TO 160
        IF(KB .NE. '0') GO TO 120
C       EQUALITY CONSTRAINT
        NFLAG(I) = 33
        B(I) = Y
        GO TO 160
120     IF(KB .NE. '+') GO TO 130
C       LESS THAN CONSTRAINT
        NFLAG(I) = 5
        B(I) = Y
        GO TO 160

130     IF(KB .NE. '-') GO TO 140
C       GREATER THAN CONSTRAINT
       NFLAG(I) = 4
        B(I) = - Y
        GO TO 160

140     TYPE 142,  LINE
142     FORMAT(/1X,'REFER TO LINE NUMBER ',I8,/)
        TYPE 144, ITAIL
144     FORMAT(/1X,'ILLEGAL SIGN CODE FOR ROW ID ',A5, ',IGNORED.',/)
        GO TO 20

160     CONTINUE 
        GO TO 20
200     RETURN
        END


        FUNCTION NDICT(NAM,KURN,DICT)
C
C
C       NDICT SEARCHES THE FIRST M ENTRIES OF DICT FOR A
C       MATCH WITH -IR-. IF NO MATCH IS FOUND, THEN THE PROGRAM IS
C       ABORTED.
C       IF A MATCH IS FOUND, THEN ITS INDEX TO DICT IS RETURNED
C       AS THE VALUE OF THE FUNCTION
C       IF -IR- IS THE OBJECTIVE FUNCTION NAME THEN
C       IT IS ENTERED IN THE FIRST SLOT OF DICT
C
        IF(NAM .EQ. OBJ1) GO TO 300

        DO 100 I = 1, M
        IF(DICT(I) .EQ. NAM) GO TO 200
100     CONTINUE
        IF(KURN .GE. M) GO TO 420
        KURN = KURN + 1
        DICT(KURN) = IR
        NDICT = KURN
        RETURN

        IF(M .GE. 2000) GO TO 400
        M = M + 1
        NDICT = M
        DICT(M) = IR
        RETURN

300     DICT(0) = IR
        NDICT = 0
        RETURN

200     NDICT = I
        RETURN

400     TYPE 410, LINE
410     FORMAT(/1X,'REFER TO LINE NUMBER ', I8,/)
        TYPE 420
420     FORMAT(/1X,'MAXIMUM NUMBER OF ROWS EXCEEDED.')

420     FORMAT(/1X,'MAXIMUN NUMBER OF ROWS EXCEEDED.'
        END
        SUBROUTINE RDLST(KX,NFLAG,BU,BL,DICT)
C
C       COMMON DECLARATIONS FOR MIP
C DECLARATIONS MADE 6/13/73
        COMMON /MIPCOM/ V,AV,WDCNT,DUEL,PRIM,IR,IK,RI,L,M,N
        COMMON /MIPCOM/ Q,QP,QPP,NETA,MAXETA,PRIM,NODUAL,NOPRIM
        COMMON /MIPCOM/ BIG,NPM,MP1,NP1,DELTA,UNB,ITYPE,ISTAR,IRP,IRP        COMMON /LINCNT/ LINE
C       LINE IS CURRENT LINE NO. IN CREATE FILE
        TYPE INTEGER DICT
        TYPE INTEGER V,AV,CB,CN,WDCNT,DUEL ,PRIM,UNB,RI
C
C
        DIMENSION NFLAG(1),BU(1),BL(1),DICT(1)
C
C       RDLST READS THE INPUT FILE AND ENTERS VALUES FOR UPPER AND
C       LOWER BOUNDS AND FROZEN VARIABLES.
C
C
C       INITIALIZE NFLAG
C
        DO 100 I =M+1, N
100     NFLAG(I) = 0.
C
C       INITIALIZE LOWER BOUNDS = O, AND UPPER BOUNDS = INFINITY
C

        DO 4940 I = M+1, M+N
        BL(I) = 0
4940    BU(I) = BIG


490     IF(KX .EQ. 'S') GO TO 498
        IF(KX .EQ. 'B') GO TO 494
        IF(KX .EQ. 'Z') ICOUNT = 'FREEZ'
        IF(KX .EQ. 'F') ICOUNT = 'FREE'
        OPT1 = ICOUNT
        IF(OPTION .EQ> 0) GO TO 491
        TYPE 531, ICOUNT
531     FORMAT(/1X,'VARIABLES UNDER OPTION ',A5)
491     READ(1,525) KX, INAME
525     FORMAT(A1,A5)
        IF(KX .EQ. 'S') GO TO 498
        IF(KX .EQ. 'B') GO TO 494
        IF(KX .EQ. 'F') ICOUNT ='FREE'
        IF(KX .EQ. 'Z') ICOUNT = 'FREEZ'
        IF(OPTION .EQ. 0) GO TO 527
        IF8ICOUNT .EQ. OPT1) GO TO 527
        OPT1 = ICOUNT
        TYPE 531, OPT1
532     FORMAT(1X,A5)

527     DO 492 J = 1, N
        IF(INAME .NE. DICT(M+J)) GO TO 492
        IF(ICOUNT .NE. 'FREEZ') GO TO 10
C       VARIABLE IS FREE
        NFLAG(M+J) = 2
        BL(J) = -BIG
        GO TO 20

C       HERE WHEN VARIABLE IS FROZEN
10      NFLAG(M+J) = 3
        BU(J) = 0
        BL(J) = 0
20      IF(OPTION .EQ. 1) TYPE 532, DICT(M+J)
        GO TO 491
492     CONTINUE


497     TYPE 493, INAME, ICOUNT
493     FORMAT(1X,'NO VARIABLE NAMED ',A5,' CHECK OPTION ',A5)
        KSTOP = 1

        RETURN

494     IF(OPTION .EQ. 0) GO TO 533
        TYPE 534
534     FORMAT(1X,'BOUNDED VARIABLES',/,1X,
     +'VARIABLE',3X,'U.BOUND',5X,'L.BOUND',/)
533     READ(1,526) KX,INAME, TEMP1, TEMP2
526     FORMAT(A1,A5,2G)
        IF(KX .EQ. 'S') GO TO 498
        ICOUNT = 'BOUND'

        DO 495 J = 1, N
        IF(INAME .NE. DICT(M+J)) GO TO 495
        IF(NFLAG(M+J) .NE. 2) GO TO 521
        TYPE 522, DICT(M+J)
        KSTOP = 1 
        RETURN

521     IF(NFLAG(M+J) .NE. 3) GO TO 524
        TYPE 523, DICT(M+J)
        KSTOP = 1 
        RETURN
522     FORMAT(1X,'FREE VARIABLE ',A5, ' HAS BEEN BOUNDED.',/.
     +  1X,'EXECUTION ABORTED.'/)
523     FORMAT(1X,'FROZEN VARIABLE ',A5,' HAS BEEN BOUNDED.,/1X,
     +  'CHECK OPTIONS IN INPUT. EXECUTION ABORTED.')

C       HERE WHEN WHEN WE HVE A BOUNDED VARIABLE
524     NFLAG(M+J) = 1
C       READ ANOTHER VARIABLE
        GO TO 533

495     CONTINUE
        GO TO 497
C 
C       AT THIS POINT WE ARE AT THE END OF BOUNDED VARIABLES
C
C       WE MUST ADJUST THE VALUE OF THE OBJECTIVE FUNCTION
C       TO COMPENSATE FOR VARIABLES WITH A POSITIVE LOWER BOUND
C
        OBVAL = 0
        DO 600 I = 1, N
        IF(BL(I)) 600,600,590
590     OBVAL = OBVAL - BL(I) * C(I)
        RETURN
        END
        SUBROUTINE RDLST(KX,NFLAG,BU,BL,DICT)
C
C       COMMON DECLARATIONS FOR MIP
C DECLARATIONS MADE 6/13/73
        COMMON /MIPCOM/ V,AV,WDCNT,DUEL,PRIM,IR,IK,RI,L,M,N
        COMMON /MIPCOM/ Q,QP,QPP,NETA,MAXETA,PRIM,NODUAL,NOPRIM
        COMMON /MIPCOM/ BIG,NPM,MP1,NP1,DELTA,UNB,ITYPE,ISTAR,IRP,IRPP

        COMMON /LINCNT/ LINE
C       LINE IS CURRENT LINE NO. IN CREATE FILE
        TYPE INTEGER DICT
        TYPE INTEGER V,AV,CB,CN,WDCNT,DUEL ,PRIM,UNB,RI
C
C
C
C       COMMON DECLARATIONS FOR MIP
C DECLARATIONS MADE 6/13/73
        COMMON /MIPCOM/ V,AV,WDCNT,DUEL,PRIM,IR,IK,RI,L,M,N
        COMMON /MIPCOM/ Q,QP,QPP,NETA,MAXETA,PRIM,NODUAL,NOPRIM
        COMMON /MIPCOM/ BIG,NPM,MP1,NP1,DELTA,UNB,ITYPE,ISTAR,IRP,IRPP

        COMMON /LINCNT/ LINE
C       LINE IS CURRENT LINE NO. IN CREATE FILE
        TYPE INTEGER DICT
        TYPE INTEGER V,AV,CB,CN,WDCNT,DUEL ,PRIM,UNB,RI
C
C
        DIMENSION NFLAG(1),BU(1),BL(1),DICT(1)
C
C       RDLST READS THE INPUT FILE AND ENTERS VALUES FOR UPPER AND
C       LOWER BOUNDS AND FROZEN VARIABLES.
C
C
C       INITIALIZE NFLAG
C
        DO 100 I =M+1, N
100     NFLAG(I) = 0.
C
C       INITIALIZE LOWER BOUNDS = O, AND UPPER BOUNDS = INFINITY
C

        DO 4940 I = M+1, M+N
        BL(I) = 0
4940    BU(I) = BIG


490     IF(KX .EQ. 'S') GO TO 498
        IF(KX .EQ. 'B') GO TO 494
        IF(KX .EQ. 'Z') ICOUNT = 'FREEZ'
        IF(KX .EQ. 'F') ICOUNT = 'FREE'
        OPT1 = ICOUNT
        IF(OPTION .EQ> 0) GO TO 491
        TYPE 531, ICOUNT
531     FORMAT(/1X,'VARIABLES UNDER OPTION ',A5)
491     READ(1,525) KX, INAME
525     FORMAT(A1,A5)
        IF(KX .EQ. 'S') GO TO 498
        IF(KX .EQ. 'B') GO TO 494
        IF(KX .EQ. 'F') ICOUNT ='FREE'
        IF(KX .EQ. 'Z') ICOUNT = 'FREEZ'
        IF(OPTION .EQ. 0) GO TO 527
        IF8ICOUNT .EQ. OPT1) GO TO 527
        OPT1 = ICOUNT
        TYPE 531, OPT1
532     FORMAT(1X,A5)

527     DO 492 J = 1, N
        IF(INAME .NE. DICT(M+J)) GO TO 492
        IF(ICOUNT .NE. 'FREEZ') GO TO 10
C       VARIABLE IS FREE
        NFLAG(M+J) = 2
        BL(J) = -BIG
        GO TO 20

C       HERE WHEN VARIABLE IS FROZEN
10      NFLAG(M+J) = 3
        BU(J) = 0
        BL(J) = 0
20      IF(OPTION .EQ. 1) TYPE 532, DICT(M+J)
        GO TO 491
492     CONTINUE


497     TYPE 493, INAME, ICOUNT
493     FORMAT(1X,'NO VARIABLE NAMED ',A5,' CHECK OPTION ',A5)
        KSTOP = 1

        RETURN

494     IF(OPTION .EQ. 0) GO TO 533
        TYPE 534
534     FORMAT(1X,'BOUNDED VARIABLES',/,1X,
     +'VARIABLE',3X,'U.BOUND',5X,'L.BOUND',/)
533     READ(1,526) KX,INAME, TEMP1, TEMP2
526     FORMAT(A1,A5,2G)
        IF(KX .EQ. 'S') GO TO 498
        ICOUNT = 'BOUND'

        DO 495 J = 1, N
        IF(INAME .NE. DICT(M+J)) GO TO 495
        IF(NFLAG(M+J) .NE. 2) GO TO 521
        TYPE 522, DICT(M+J)
        KSTOP = 1 
        RETURN

521     IF(NFLAG(M+J) .NE. 3) GO TO 524
        TYPE 523, DICT(M+J)
        KSTOP = 1 
        RETURN
522     FORMAT(1X,'FREE VARIABLE ',A5, ' HAS BEEN BOUNDED.',/.
     +  1X,'EXECUTION ABORTED.'/)
523     FORMAT(1X,'FROZEN VARIABLE ',A5,' HAS BEEN BOUNDED.,/1X,
     +  'CHECK OPTIONS IN INPUT. EXECUTION ABORTED.')

C       HERE WHEN WHEN WE HVE A BOUNDED VARIABLE
524     NFLAG(M+J) = 1
C       READ ANOTHER VARIABLE
        GO TO 533

495     CONTINUE
        GO TO 497
C 
C       AT THIS POINT WE ARE AT THE END OF BOUNDED VARIABLES
C
C       WE MUST ADJUST THE VALUE OF THE OBJECTIVE FUNCTION
C       TO COMPENSATE FOR VARIABLES WITH A POSITIVE LOWER BOUND
C
        OBVAL = 0
        DO 600 I = 1, N
        IF(BL(I)) 600,600,590
590     OBVAL = OBVAL - BL(I) * C(I)
        RETURN
        END
        SUBROUTINE MAIN
C
CCOMMON DECLARATIONS HERE
C       DUAL PATH
C
C       SET NUMBER OF ITERATIONS 0
100     L = 0
C       COMPUTE MIN(BETA(I)), WHERE NFLAG(CB(I) .NE.2
        CALL FMIN(NFLAG,CB,BETA)
        IF(Q .GE. 0) GO TO 700
C       IR DESIGNATES OUTGOING ROW, CALL DUAL TO DETERMIN INCOMING
C       VARIABLE

200     CALL DUAL(IRES,RINV,CBC,A,C,ALPHA,ETA,TEMP,INDETA,INDA)
C       IF DUAL UNSUCCESSFUL GO TO 300
        IF(IRES .NE. 0) GO TO 300

        CALL PIVOT(IRES,IR,IK,ALPHA,ETA,BETA,CB,CN,TEMP,INDETA)
C
C       FOR EVERY BETA(I) .GT. BU(I) CALL COMPLE|
C

        DO 200 I = 1, M
        IF(BETA(I).LE. BU(I)) GO TO 200
        IR = I
        CALL COMPLE(BU,BETA,NFLAG,CB,CBC,INDETA)

        IF(DUAL - 1) 700,100,700
C       TAKE PRIMAL PATH
300     IF(DUAL .NE. 1) GO TO 400
C
C       SOLUTIO IS DUAL FEASIBLE BUT CANNOT TAKE DUAL ITERATIONS.
C       FATAL ERROR. NO OPTIMAL SOLUTION. PRINT MESSAGE AND QUIT.
C
        TYPE 5000
C********AD D FORMAT STATEMENT AND QUIT.

C       TRY TO TAKE A DUAL ITERATION

400     L = L + 1
        IF(L .LE. M) GO TO 600
C       UNABLE TO TAKE A DUAL ITERATION
        NODUAL = 1
C       PROCEED TO CHECK IF THE LAST PRIMAL ITERATION WAS SUCCESSFUL
        IF(NOPPRIM .NE. 1) GO TO 800

C       CANNOT TAKE A PRIMAL OR DUAL ITERATION.
C       NO OPTIMAL SOLUTION. PRINT ERROR MESSAGE AND QUIT.
C
C******ADD ERROR MESSAGE AND QUIT
500     TYPE 5100
5100    FORMAT(1X,'FATAL ERROR')
600     IF(BETA(L) GO TO 400
        IF(NFLAG(CB(L) .EQ.2) GO TO 400
        IR = L
        GO TO 200

C       SOLUTION IS PRIMAL FEASIBLE, ONLY PRIMAL ITERATIONS 
C       REQUIRED


700     PRIM = 1
C       BRANCH IF PROBLEM IS SOLVED
        IF(DUAL .EQ. 1) GO TO 2200
C        PRIMAL PATH

800     K = 0
C       BTRAN THE VECTOR PF CURRENT BASIC COSTS AND STORE IN PIP

        DO 900 I = 1, M
900     PIP(I) = 0.

        CALL BTRAN(PIP,RINV,ETA,TEMP,INDETA)
        IF(N.EQ.M) GO TO 1100

        DO 1000 I = M+1, N
1000    PIP(I) =0.

        DO 1300 I = 1, N
        CALL GETA(CN(I),INDA,TEMP,A)


        DO 1200 J = 1, M
1200    T = T + PIP(J) * A(J) -C(J)

        PI(I) = TEMP
1300    CONTINUE

C       COMPUTE MIN(PI(I). IK IS INDEX ASSOCIATED WITH
C       THE MIN
        CALL PIMIN(PI)
        IF((DELTA .GE. 0) .OR.(NFLAG(CN(I99 .EQ. 3)) GO TO 2300

C       IK DESIGNATES INCOMING VARIABLE.  CALL PRIMAL TO
C       DETERMINE INCOMING VARIABLE.
1400    CALL PRIMAL(IRES,A,ALPHA,BETA,BU,ETA,TEMP,INDETA,CB,NFLAG)
C       GO TO 1900 IF NOT SUCCESSFUL
        IF(IRES .NE. 0) GO TO 1900

        GO TO (1600, 1500, 1700), ITYPE
1500    CALL COMPLE(IR,BU,BETA,NFL{AG,CB,CBC,INDETA)
1600    CALL PIVOT(IRES,IR,IK,ALPHA,ETA,BETA,CB,CN,TEMP,INDETA)
        GO TO 1800

1700    CALL UBITER(IK)
1800    IF(PRIM .EQ. 1) GO TO 800
C       DUE FOR A DUAL ITERATION.  PROCEED TO DUAL PATH.
        GO TO 100

1900    IF(PRIM .EQ. 1) GO TO 2400
2000    K = K + 1
        IF(K .GT. N) GO TO 2100
        IF((NFLAG(CN(K)) .EQ.3) .OR. (PI(K) .GE.0)) GO TO 2000
        IK = K

        GO TO 1400
        
C
C       UNABLE TO TAKE DUAL ITERATION.  PROCEED TO CHECK IF
C       LAST DUAL ITERATION WAS SUCCESSFUL
C

2100    NOPRIM = 1
        IF(NODUAL .NE. 1) GO TO 100
C
C       THERE SI NO SOLUTION
C
        GO TO 500

C
C       PRINT OR WRITE OPTIMAL PRIMAL SOLUTION AND BOJECTIVE VALUE
C       PRINT OR WRITE DUAL SOLUTION, I.E. THE SHADOW PRICES.
C
2200    CONTINUE
C****** ADD OUTPUT STATEMENTS HERE
        RETURN

C
C       SOLUTION IS DUAL FEASIBLE, ONLY DUAL ITERATIONS REQUIRED
C
2300    DUAL= 1
        IF(PRIM .EQ. 1) GO TO 2200
C       TAKE DUAL PATH
        GO TO 100

OC
C       SOLUTION IS PRIMAL FEASIBLE, BUT CANNOT TAKE PRIMAL 
C       ITERATIONS. NO OPTIMAL SOLUTION.  PRINT ERROR MESSAGE AND
C       QUIT.
C***** ADD MESSAGE
2400    CONTINUE
        RETURN
        END
        SUBROUTINE WRETA(IND,TEMP,ETA,INDETA)
        DIMENSION TEMP(1),ETA(1),INDETA(1)
        DIMENSION ITEMP(1)
        EQUIVALENCE  (TEMP(1),ITEMP(1))
C
C       COMMON DECLARATIONS FOR MIP
C DECLARATIONS MADE 6/13/73
        COMMON /MIPCOM/ V,AV,WDCNT,DUEL,PRIM,IR,IK,RI,L,M,N
        COMMON /MIPCOM/ Q,QP,QPP,NETA,MAXETA,PRIM,NODUAL,NOPRIM
        COMMON /MIPCOM/ BIG,NPM,MP1,NP1,DELTA,UNB,ITYPE,ISTAR,IRP,IRPP

        COMMON /LINCNT/ LINE
C       LINE IS CURRENT LINE NO. IN CREATE FILE
        TYPE INTEGER DICT
        TYPE INTEGER V,AV,CB,CN,WDCNT,DUEL ,PRIM,UNB,RI
C
C
C
C       WRETA WRITES A VECTOR TO ETAFIL.
C       THE FORMAT OF THIS VECTOR IS (IND,E1,E2,...EM).
C       WHERE IND IS THE COLUMN INDEX OF THE VECTOR.  THE E'S ARE
C       COMPONENTS OF THE VECTOR, ANY OF THE E'S MAY REPRESENT
C       SQUEEZED ZERO ELEMENTS OF THE VECTOR.  THE NUMBER OF ZEROES
C       SQUEEZED IS AN INTEGER. (THIS DISTINGUISHES IT FROM AN ORDINARY
C       COMPONENT SINCE THE HIGH ORDER 10 BITS WOULD BE NON-ZERO FOR A
CCOMMON DECLARATIONS HERE
C
C


C       SET COLUMN INDEX IN FIRST ENTRY
        ITEMP(1) = IND
      
        I = 1
        DO 400 J = 1, M
C       I IS INDEX TO ITEMP
C       J IS INDEX TO ETA
  
C       CHECK FOR 2 OR MORE CONTIGUOUS ZEROES
        IF(ETA(J) .NE. 0) GO TO 250
        IF(ETA(J+1) .NE. 0) GO TO  250
C       HERE TO COUNT SQUEEZED ZEROES

C       SET INITIAL COUNT OF SQUEEZED ZEROES
        ITEMP(I) = 2
        J = J+2
100     IF(ETA(J) .NE. 0) GO TO 300
C       INCREASE ZERO COUNT
        ITEMP(I) = ITEMP(I) + 1
        J = J + 1
        IF(J .LE. M) GO TO 100

C       FALL THROUHG INDICATES WE ARE DONE WITH ETA
        GO TO 500

300     J = J - 1
C       RESET INDEX AND CONTINUE LOOP
        GO TO 200

250     TEMP(I) = ETA(J)
200     I = I + 1
400     CONTINUE


C      WRITE OUT VECTOR TO ETAFIL AND RETURN
C
500     KK = V
C
C       SAVE NEXT AVAILABLE RECORD NUMBER IN V
C
        V = POSITION(U)
C       SAVE RECORD ADDRESS
        WRITE(U#V) (ITEMP(K), K = 1, I)
C       INCREMENT COUNT OF ETA VECTORS
        NETA = NETA + 1
C       SET WORD COUNT AND RECORD ADDRES AND RETURN
        INDETA(NETA) = (I**18) .OR. KK
        RETURN
        END
        SUBROUTINE GETA(II,INDA,TEMP,A)
        DIMENSION INDA(1),TEMP(1),A(1)
        DIMENSION ITEMP(1)
        EQUIVALENCE (TEMP(1),ITEMP(1))
C
C       COMMON DECLARATIONS FOR MIP
C DECLARATIONS MADE 6/13/73
        COMMON /MIPCOM/ V,AV,WDCNT,DUEL,PRIM,IR,IK,RI,L,M,N
        COMMON /MIPCOM/ Q,QP,QPP,NETA,MAXETA,PRIM,NODUAL,NOPRIM
        COMMON /MIPCOM/ BIG,NPM,MP1,NP1,DELTA,UNB,ITYPE,ISTAR,IRP,IRPP

        COMMON /LINCNT/ LINE
C       LINE IS CURRENT LINE NO. IN CREATE FILE
        TYPE INTEGER DICT
        TYPE INTEGER V,AV,CB,CN,WDCNT,DUEL ,PRIM,UNB,RI
C
C
C
C       GETA READS THE I-TH  COLUMN OF THE A MATRIX INTO ARRAY
C       -A-.  IT EXPANDS THE VECTOR BY UNSQUEEZING ZEROES.
C
CCOMMON DECLARATIONS HERE
C
C       THE RECORD NUMBER OF THE I-TH VECTOR IS CONTAINED

C       IN THE LOW ORDER 18 BITS OF INDA(I)
C       THE WORD COUNT IS CONTAINED IN THE HIGH ORDER 18 BITS OF
C       INDA(I)

C       OBTAIN RECORD NUMBER
        AV = "777777 .AND. INDA(II)
C       OBTAIN WORD COUNT
        WDCNT = (INDA(II) .AND. "777777000000)/(2**18)
        LIM = WDCNT + 1
C       GET COMPRESSED VECTOR FROM A FILE
        READ (AU#AV) (TEMP(JJ), JJ = 1, WDCNT)
        
        J=1
        DO 800 I = 1, WDCNT
C       CHECK FOR SQUEEZED ZEROES
        IF(("777400000000 .AND. TEMP(I)) .NE. 0) GO TO 700
C       HERE FOR SQUEEZED ZEROES
        ISQ = ITEMP(I)
C       ISQ = NUWMBER OF SQUEEZED ZEROES
C       EXPAND VECTOV

        DO 60 K = I, I + ISQ - 1
        A(J) = 0.
        J = J + 1
        GO TO 800
700     A(J) = TEMP(I)
        J = J +1
800     CONTINUE

        RETURN
        END

        SUBROUTINE GETETA(IND,INDX,ETA,TEMP,INDETA)
        DIMENSION ETA(1),TEMP(1),INDETA(1)
        DIMENSION ITEMP(1)
C
C       COMMON DECLARATIONS FOR MIP
C DECLARATIONS MADE 6/13/73
        COMMON /MIPCOM/ V,AV,WDCNT,DUEL,PRIM,IR,IK,RI,L,M,N
        COMMON /MIPCOM/ Q,QP,QPP,NETA,MAXETA,PRIM,NODUAL,NOPRIM
        COMMON /MIPCOM/ BIG,NPM,MP1,NP1,DELTA,UNB,ITYPE,ISTAR,IRP,IRPP

        COMMON /LINCNT/ LINE
C       LINE IS CURRENT LINE NO. IN CREATE FILE
        TYPE INTEGER DICT
        TYPE INTEGER V,AV,CB,CN,WDCNT,DUEL ,PRIM,UNB,RI
C
C
        EQUIVALENCE (TEMP(1),ITEMP(1))
C
C       GETETA READS A RECORD FROM THE FILE -ETAFIL- OR CONSTRUCTS
C       GETETA READS WHEN THE QUANTITY IN -INDETA(IND) IS POSITVE.
C       THIS IS THE WORD COUNT AND RECORD NUMBER.  IF THE QUANTITY IS 
C       NEGATIVE THIS INDICATES THAT THIS REPRESENTS A VECTOR OF THE 
C       FORM (0,0,...,-1,0,...,0) WHERE THE -1 IS IN THE-IND-TH PLACE.
C
CCOMMON DECLARATIONS HERE
        IF(INDETA(IND)) 100,1000,300
C
C       CONSTRUCT COMPLEMENTARY VECTOR
C
100     DO 200 I = 1,M
200     ETA(I) = 0.
        ETA(-IND) = -1
C       SET COLUMN INDEX
        INDX = -IND
C
        RETURN

C       OBTAIN RECORD NUMBER
        V = "777777 .AND. INDETA(IND)
C       OBTAIN WORD COUNT
        WDCNT = (INDETA(IND) .AND. "777777000000)/(2**18)

C
        LIM = WDCNT + 1
C       GET COMPRESED VECTOR FROM ETA FILE
        READ (U#V) (TEMP(II),II = 1,LIM)
C       SET INDEX OF NON-ELEMENTARY COLUMN
        INDX = ITEMP(1)

        J = 1
500     DO 800 I = 2, LIM
C       CHECK FOR SQUEEZED ZEROES
        IF(("777400000000 .AND. TEMP(I)) .NE. 0) GO TO 700
C       HERE FOR SQUEEZED ZEROES
        ISQ = ITEMP(I)
C       ISQ = NUMBER OF SQUEEZED ZEROES
C       EXPAND VECTOR

        DO 600 K = I, I + ISQ -1
        ETA(J) = 0.
        J = J + 1
600     CONTINUE
        I = ISQ + I + 1
        GO TO 800
700     ETA(J) = TEMP(I)
        J= J + 1

800     CONTINUE
        RETURN
        END
        SUBROUTINE BTRAN(ROW,ETA,TEMP,INDETA)
        DIMENSION ROW(1),ETA(1),INDETA(1),TEMP(1)
C
C       COMMON DECLARATIONS FOR MIP
C DECLARATIONS MADE 6/13/73
        COMMON /MIPCOM/ V,AV,WDCNT,DUEL,PRIM,IR,IK,RI,L,M,N
        COMMON /MIPCOM/ Q,QP,QPP,NETA,MAXETA,PRIM,NODUAL,NOPRIM
        COMMON /MIPCOM/ BIG,NPM,MP1,NP1,DELTA,UNB,ITYPE,ISTAR,IRP,IRPP

        COMMON /LINCNT/ LINE
C       LINE IS CURRENT LINE NO. IN CREATE FILE
        TYPE INTEGER DICT
        TYPE INTEGER V,AV,CB,CN,WDCNT,DUEL ,PRIM,UNB,RI
C
C
C
C       BTRAN POST-MULTIPLIES A VECTOR IN COL BY THE ALMOST-ELEMENTARY
C       MATRICES IN THE ETA FILE. THESE ARE APPLIED IN REVERSE ORDER.
C       IF THE ETA FILE IS EMPTY THE VECTOR -ROW- CONTAINS THE UPDATED
C       COLUMNS.
C
C
CCOMMON DECLARATIONS HERE
C
C
C       IF ETA FILE IS EMPTY RETURN.
        IF(NETA .EQ. 0) RETURN
      
C       GET A VECTOR FROM ETA FILE.
C *****CHECK FOR PREMATURE EOF?
C
        DO 1000 JJ = NETA, 1, -1
        CALL GETETA(JJ,RI,ETA,TEMP,INDETA)

C       INDEX TO NON-ELEMENTARY COLUMN IS IN -RI-
C
        DO 900 J= 1,M
        IF(J .NE. RI) GO TO 900
        TROW = 0.
        TRINV =0.
        DO 700 K= 1,M
        TROW = TROW + ROW(K) * ETA(K)
        TRINV = TRINV + RINV(K) * ETA(K)
700     CONTINUE

        ROW(RI) = TROW
C****** FLAG FROM DUAL
        RINV(K) = TRINV


900     CONTINUE

1000    CONTINUE
        RETURN
        END

        SUBROUTINE PIVOT(IRES,ALPHA,ETA,BETA,CB,CN,TEMP,INDETA)
        DIMENSION ALPHA(1),ETA(1),BETA(1),CB(1),CN(1),TEMP(1),INDETA(1)
        TYPE INTEGER CB,CN
C
C       COMMON DECLARATIONS FOR MIP
C DECLARATIONS MADE 6/13/73
        COMMON /MIPCOM/ V,AV,WDCNT,DUEL,PRIM,IR,IK,RI,L,M,N
        COMMON /MIPCOM/ Q,QP,QPP,NETA,MAXETA,PRIM,NODUAL,NOPRIM
        COMMON /MIPCOM/ BIG,NPM,MP1,NP1,DELTA,UNB,ITYPE,ISTAR,IRP,IRPP

        COMMON /LINCNT/ LINE
C       LINE IS CURRENT LINE NO. IN CREATE FILE
        TYPE INTEGER DICT
        TYPE INTEGER V,AV,CB,CN,WDCNT,DUEL ,PRIM,UNB,RI
C
C
C
C       SET SUCCESSFUL FLAG BY DEFAULT
C
        IRES = 0
C
C       REGULAR PIVOTAL OPERATION
C
C       IK IS THE INCOMING COLUMN.  IR IS THE OUTGOING ROW.
C       ALPHA IS THE UPDATED IK-TH COLUMN OF THE A MATRIX

C
CCOMMON DECLARATIONS HERE
C


C
C       COMPUTE ETA VECTOR
C
        T = -1./ALPHA(IR)
        DO 100 I = 1, M
100     ETA(I) = ALPHA(I) * T
        ETA(IR) = -T
C
C       WRITE OUT TO ETA FILE THE INDEX IR AND THE ETA VECTOR
        CALL WRETA(IR)
C       SWITCH LABELS OF THE VARIABLES IN THE IR-TH ROW AND IK-TH
C       COLUMN.
        IT = CB(IR)
        CB(IR) = CN(IK)
        CN(IK) = IT
C
C       UPDATE THE BETA VECTOR BY PRE-MULTIPLICATION BY THE

C       ELEMENTARY MATRIX.

        CALL FTRAN(BETA,ETA,TEMP,INDETA)

        NOPRIM = 0
        NODUAL = 0
        END
        SUBROUTINE FMIN(NFLAG,CB,BETA)
        DIMENSION NFLAG(1),CB(1),BETA(1)
C
C       COMMON DECLARATIONS FOR MIP
C DECLARATIONS MADE 6/13/73
        COMMON /MIPCOM/ V,AV,WDCNT,DUEL,PRIM,IR,IK,RI,L,M,N
        COMMON /MIPCOM/ Q,QP,QPP,NETA,MAXETA,PRIM,NODUAL,NOPRIM
        COMMON /MIPCOM/ BIG,NPM,MP1,NP1,DELTA,UNB,ITYPE,ISTAR,IRP,IRPP

        COMMON /LINCNT/ LINE
C       LINE IS CURRENT LINE NO. IN CREATE FILE
        TYPE INTEGER DICT
        TYPE INTEGER V,AV,CB,CN,WDCNT,DUEL ,PRIM,UNB,RI
C
C
        TYPE INTEGER CB
C
C       FMIN COMPUTES  Q = MIN(BETA(I)) FOR NON-FREE
C       VARIABLES. FOR FREE VARIABLES NFLAG(BETA(CB(I))) = 2
C       IR IS THE INDEX CORRESPONDING TO THE MINIMUM
CCOMMON DECLARATIONS HERE
C

C       SET DUMMY FIRST VALUE
        TEMP = BIG
        DO 300 J = 1, M
        IF(NFLAG(CB(J)) .EQ. 2) GO TO 300
        IF(TEMP - BETA(J)) 300,300,210
210     TEMP = BETA(J)
        IR = J
300     CONTINUE

        Q = TEMP
        RETURN  
        END
        SUBROUTINE PIMIN(PI)
        DIMENSION PI(1)
C
C       COMMON DECLARATIONS FOR MIP
C DECLARATIONS MADE 6/13/73
        COMMON /MIPCOM/ V,AV,WDCNT,DUEL,PRIM,IR,IK,RI,L,M,N
        COMMON /MIPCOM/ Q,QP,QPP,NETA,MAXETA,PRIM,NODUAL,NOPRIM
        COMMON /MIPCOM/ BIG,NPM,MP1,NP1,DELTA,UNB,ITYPE,ISTAR,IRP,IRPP

        COMMON /LINCNT/ LINE
C       LINE IS CURRENT LINE NO. IN CREATE FILE
        TYPE INTEGER DICT
        TYPE INTEGER V,AV,CB,CN,WDCNT,DUEL ,PRIM,UNB,RI
C
C
C
C       PIMIN COMPUTES DELTA = MIN(PI(I))
C
CCOMMON DECLARATIONS HERE

        DELTA = PI(1)
        IK = 1

        DO 100 I = 2, N
        IF(DELTA - PI(I)) 100,100,50
50      DELTA = PI(I)
        IK = I
100     CONTINUE

        RETURN
        END
        SUBROUTINE QPMIN(BETA,ALPHA,NFLAG,CB)
        DIMENSION BETA(1),ALPHA(1),NFLAG(1),CB(1)
        TYPE INTEGER CB
C
C       COMMON DECLARATIONS FOR MIP
C DECLARATIONS MADE 6/13/73
        COMMON /MIPCOM/ V,AV,WDCNT,DUEL,PRIM,IR,IK,RI,L,M,N
        COMMON /MIPCOM/ Q,QP,QPP,NETA,MAXETA,PRIM,NODUAL,NOPRIM
        COMMON /MIPCOM/ BIG,NPM,MP1,NP1,DELTA,UNB,ITYPE,ISTAR,IRP,IRPP

        COMMON /LINCNT/ LINE
C       LINE IS CURRENT LINE NO. IN CREATE FILE
        TYPE INTEGER DICT
        TYPE INTEGER V,AV,CB,CN,WDCNT,DUEL ,PRIM,UNB,RI
C
C
        
C
C       QPMIN COMPUTES THE MIN OF BETA(I)/ALPHA(I) WHERE
C       BETA(I) .GT. 0, ALPHA(I) .GT. 0 AND NFLAG(CB(I)) .NE. 2
C       IRP IS THE INDEX ASSOCIATED WITH THE MIN.
C
C       SET A DUMMY FIRST VALUE
C
        QP = BIG
        DO 100 I = 1,M
        IF(ALPHA(I) .LE. 0) GO TO 100
        IF(BETA(I) .LT. 0)  GO TO 100
C       IS VARIABLE FREE
        IF(NFLAG(CB(I)) .EQ. 2) GO TO 100
        IF(BETA(I)) 50,40,50
40      TEMP = 0.
        GO TO 60

60      IF(TEMP .GT. QP) GO TO 100
        QP =TEMP
        IRP = I
100     CONTINUE
        RETURN
        END
        SUBROUTINE QPPMN(BETA,ALPHA,BU,CB,NFLAG)
        DIMENSION ALPHA(1),BU(1),CB(1),NFLAG(1),BETA(1)
        TYPE INTEGER CB
C
C       COMMON DECLARATIONS FOR MIP
C DECLARATIONS MADE 6/13/73
        COMMON /MIPCOM/ V,AV,WDCNT,DUEL,PRIM,IR,IK,RI,L,M,N
        COMMON /MIPCOM/ Q,QP,QPP,NETA,MAXETA,PRIM,NODUAL,NOPRIM
        COMMON /MIPCOM/ BIG,NPM,MP1,NP1,DELTA,UNB,ITYPE,ISTAR,IRP,IRPP

        COMMON /LINCNT/ LINE
C       LINE IS CURRENT LINE NO. IN CREATE FILE
        TYPE INTEGER DICT
        TYPE INTEGER V,AV,CB,CN,WDCNT,DUEL ,PRIM,UNB,RI
C
C
C
C       QPPMN COMPUTES QPP = MIN(BETA(I)-BU(I))/ALPHA(I) WHEN
C       NFLAG(CB(I)) .NE. 2, BETA(I9 .GE. 0, ALPHA(I) .LT. 0,
C       AND BU(I) .LT. INFINITY.
C       IRPP IS THE INDEX ASSOCIATED WITH THE MINIMUM
C
C       SET DUMMY FIRST VALUE
        QPP = BIG

        DO 100 I = 1, M
        IF(BETA(I) .LT. 0) GO TO 100
        IF(ALPHA(I) .GT. 0) GO TO 100
        IF(BU(I) - BIG) 50,100,100
50      IF(NFLAG(CB(I) .EQ. 2) GO TO 100
        TEMP = (BETA(I) - BU(I))/ALPHA(I)
        IF(QPP .LT. TEMP) GO TO 100
        QPP = TEMP
        IRPP = I
100     CONTINUE

        RETURN
        END
        SUBROUTINE FTRAN(COL,ETA,TEMP,INDETA)
       DIMENSION COL(1),ETA(1),TEMP(1),INDETA(1)
C
C       COMMON DECLARATIONS FOR MIP
C DECLARATIONS MADE 6/13/73
        COMMON /MIPCOM/ V,AV,WDCNT,DUEL,PRIM,IR,IK,RI,L,M,N
        COMMON /MIPCOM/ Q,QP,QPP,NETA,MAXETA,PRIM,NODUAL,NOPRIM
        COMMON /MIPCOM/ BIG,NPM,MP1,NP1,DELTA,UNB,ITYPE,ISTAR,IRP,IRPP

        COMMON /LINCNT/ LINE
C       LINE IS CURRENT LINE NO. IN CREATE FILE
        TYPE INTEGER DICT
        TYPE INTEGER V,AV,CB,CN,WDCNT,DUEL ,PRIM,UNB,RI
C
C
C
C       FTRAN PRE-MULTIPLIES THE VECTOR IN COL BY THE LAST
C       (NETA-NN+1) MATRICES IN THE ETA FILE.
C       IF THE ETA FILE IS EMPTY THE UPDATED COEFFICIENTS ARE
C       ALREADY IN COL.
C
CCOMMON DECLARATIONS HERE
C


        IF(NETA .EQ. 0) RETURN
C       NETA IS NUMBER OF MATRICES IN NETA

        DO 1000 I = NETA, 1, -1
C       IF CALLED WITH NN = NETA WE NEED THE LAST MATRIX WHICH
C       IS STILL IN CORE.
        IF(NN - NETA) 600,700,600
600     CALL GETETA(I,RI,ETA,TEMP,INDETA)
C       GETETA GETS THE I-TH MATRIX IN ETAFIL, AND RETURNS THE INDEX
C       TO THE NON-ELEMENTARYY COLUMN IN RI

700     DO 900 J = 1, M
        IF(J .EQ. RI) GO TO 800
       COL(J) = COL(J) + COL(RI) * ETA(J)
        GO TO 900
800     COL(J) = COL(J) * ETA(J)
900     CONTINUE
1000    CONTINUE


C      ADD PARAMETRIC PROGRAMMING HOOKS
C       COL NOW CONTAINS THE UPDATE COEFFICIENTS
        RETURN
        END
        SUBROUTINE DUAL(IRES,RINV,CBC,A,C,ALPHA,ETA,TEMP,INDETA,INDA)
        DIMENSION RINV(1),CBC(1),A(1),C(1),ALPHA(1),TEMP(1)
        DIMENSION INDETA(1),INDA(1)
C
C       NORMAL PHASE FOR FINDING AN INCOMING VARIABLE FOR DUAL
C       ITERATION.  OUGOING VARIABLE IS IR.
C
CCOMMON DECLARATIONS HERE
C
        IRES = 0
        ITYPE = 0
        UNB = 0.
        Q = BIG
C
C       INITIALIZE THE RINV VECTOR
C
        DO 50 I = 1, M
50      RINV(I) = 0.
        RINV(IR) = 1.
        
        CALL BTRAN(CBC,1,RINV,ETA,TEMP,INDETA)

        DO 500 I = 1, N
C       GET THE I-TH COLUMN OF THE A MATRIX
C       DONT RETRIEVE COLUMNS OF FROZEN VARIABLES
        IF(NFLAG(CB(I)) .EQ. 3) GO TO 500
C       GET THE I-TH COLUMN OF THE A MATRIX
        CALL GETA(I,INDA,TEMP,A)
        TU = 0.
C       COMPUTE PRODUCT OF CBC (ROW) BY A(I) (COL)
        DO 100 J =1,M
100     TU = TU + CBC(J) * A(J)
        TU = TU - C(I)
        IF(TU) 500,500,200
200     TL = 0.

        DO 300 J = 1, M
        IF(TL) 400,500,500
400     QP = TU/TL
C       SET FLAG FOR AT LEAST 1 NEGATIVE DENOMINATOR
        IRES = 1
      IRES = 1
        UNB = 1
        IF(Q .LT. QP) GO TO 500
        Q = QP
        IK = I
500     CONTINUE

        IF(Q .LT. BIG) GO TO 700
        IF(UNB .EQ. 0) GO TO 900
C       SET UNSUCCESSFUL FLAG
        UNB = 1
        GO TO 800
700     ITYPE = 4
C
C       INCOMING COLUMN IS IK, FTRAN AND STORE IN ALPHA
        CALL FTRAN(A(1),1,ETA,TEMP,INDETA)

        DO 750 I = 1, M
750     ALPHA(I) = A(I)
800     RETURN

900     TYPE 2000
2000    FORMAT(1X,'FATAL ERROR. SOLUTION IS INFEASIBLE')
C***** DEBUG DUMP TO BE ADDED
        END
        SUBROUTINE PRIMAL(IRES,A,ALPHA,BETA,BU,ETA,TEMP,INDETA,CB,
     +  NFLAG)
        DIMENSION A(1),ALPHA(1),BETA(1),BU(1),ETA(1),TEMP(1)
        DIMENSION INDETA(1),CB(1),NFLAG(1)
        TYPE INTEGER CB
C
C       COMMON DECLARATIONS FOR MIP
C DECLARATIONS MADE 6/13/73
        COMMON /MIPCOM/ V,AV,WDCNT,DUEL,PRIM,IR,IK,RI,L,M,N
        COMMON /MIPCOM/ Q,QP,QPP,NETA,MAXETA,PRIM,NODUAL,NOPRIM
        COMMON /MIPCOM/ BIG,NPM,MP1,NP1,DELTA,UNB,ITYPE,ISTAR,IRP,IRPP

        COMMON /LINCNT/ LINE
C       LINE IS CURRENT LINE NO. IN CREATE FILE
        TYPE INTEGER DICT
        TYPE INTEGER V,AV,CB,CN,WDCNT,DUEL ,PRIM,UNB,RI
C
C
C       IRES = 0 SUCCESSFUL, = 1 UNSUCCESSFUL
CCOMMON DECLARATIONS HERE
C
        IRES = 0
        QP = BIG
        QPP = BIG
        UNB = 0
        ITYPE = 0
C       RETRIEVE THE IK-TH COLUMN OF A
        CALL GETA(IK)


        DO 30 I = 1, M
30      ALPHA(I) = A(I)

        CALL FTRAN(ALPHA,ETA,TEMP,INDETA)
         D0 100 I = 1, M
        IF(A(I)) 100,100,40
40      UNB = 1
100     CONTINUE

        IF(UNB .EQ. 0) GO TO 200
C
C       COMPUTE QP = MIN( BETA(I)/ALPHA(I)) FOR BETA(I).GE. 0
C       AND ALPHA(I) .GT. 0
C
C       IRP IS THE INDEX ASSOCIATED WITH THE MINIMUM
C
        CALL QPMIN(BETA,ALPHA,NFLAG,CB)
C
C       COMPUTE QPP = MIN((BETA(I)-BU(I))/ALPHA(I)) FOR
C       BETA(I) .GE. 0, BU(I) .NE. INFINITY,AND ALPHA(I) .LT. 0
C       IRPP IS THE INDEX ASSOCIATED WITH THE MINIMUM
C
        CALL QPPMN(BE,ALPHA,BU,CB,NFLAG)
C
C       COMPUTE Q = MIN(QP,QPP)
C
        Q = QP
        IR = IRP
        IF(Q .LT. QPP) GO TO 200
        Q = QPP
        IR = IRPP

200     IF(Q .TL. BIG) GO TO 300
        IF(BU(IK) .LT. BIG) GO TO 400
C       SET FLAG UNSUCCESSFUL
        IRES = 1
        IF(UNB .NE. 0) RETURN
C       FATAL ERROR. SOLUTION IS UNBOUNDED
        TYPE 1000
1000    FORMAT(1X,'FATAL ERROR SOLUTION IS UNBOUNDED')
C**** ADD QUIT AND DUMP


300     IF(Q .LT. BU(IK)) GO TO 350
        IF(Q .EQ. QP) GO TO 400
        ITYPE = 2
500     RETURN
350     ITYPE = 1
        GO TO 500
400     ITYPE = 3
        GO TO 500
        END
        SUBROUTINE COMPLE(BU,BETA,NFLAG,CB,CBC,INDETA)
        DIMENSION BU(1),BETA(1),NFLAG(1),CB(1),CBC(1),NFLAG(1)
        TYPE INTEGER CB
C
C       COMMON DECLARATIONS FOR MIP
C DECLARATIONS MADE 6/13/73
        COMMON /MIPCOM/ V,AV,WDCNT,DUEL,PRIM,IR,IK,RI,L,M,N
        COMMON /MIPCOM/ Q,QP,QPP,NETA,MAXETA,PRIM,NODUAL,NOPRIM
        COMMON /MIPCOM/ BIG,NPM,MP1,NP1,DELTA,UNB,ITYPE,ISTAR,IRP,IRPP

        COMMON /LINCNT/ LINE
C       LINE IS CURRENT LINE NO. IN CREATE FILE
        TYPE INTEGER DICT
        TYPE INTEGER V,AV,CB,CN,WDCNT,DUEL ,PRIM,UNB,RI
C
C
C
C       COMPLEMENTARY ITERATION
C       UPDATE FIRST COLUMN COEFFICIENT OF ROW IR
C
CCOMMON DECLARATIONS HERE
        
        IF( BU(IR) .LT. BIG ) GO TO 100
100     BETA(IR) = BU(IR) - BETA(IR)
C
CINOTHE THAT HTE COMPLEMENT IS IN THE BASIS
C
200     NFLAG(CB(I)) = -1
C
C       ACCOUNT FOR THE COMPLEMENT IN THE BASIS
C
        CBC(IR) = -CBC(IR)
C
C       SET FLAGE FOR COMPLEMENTARY BASIS
C******CHECK FLAG FOR OVERRUN OF ARRAY
        NETA = NETA + 1
C
C       SET INDEX OF COMPLEMENTARY VECTOR IN INDETA
C
        INDETA(NETA) = -IR
        NOPRIM =0
        NODUAL =0
        RETURN
END
.ED
    @UÖ