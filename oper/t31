1  INTEGER OBJ,HISTRY(100),SPCALC,FLUSH,BRIEF,FRSTSG,EDITL,CURRGO,EXIST,CMND,CURCMP,ERRCNT,COMPL,ACTVL,PRNTL,FSTITM,CLRITM,HASH,SONPTR,SONS,TREE,BUFITM,ITMLOC,ITMDIM,TYPE,OVLNO,FMTPTR
2  COMMON FV(3000)
3  COMMON ITEM,OBJ,SBSNAM,LSBNAM,HISTRY,SPCALC,NOPRNT,FLUSH,ITMCHK,BRIEF,INPUT(21),LINPUT,FRSTSG,LASTSG,NXSTRT,EDITL(100),LEDITL,OVL,INDOVL,INDIR
4 COMMON  CURRGO,LASTGO,CMND,CURCMP,ERRCNT,COMPL(100),LCOMPL,ACTVL(100),LACTVL,PRNTL(100),LPRNTL,NITEMS,MULTRE,EXIST(3),FSTITM,LSTITM,CLRITM
5 COMMON  HASH(199),SONPTR(25),SONS(65),TREE(100),DICFIL,FMTFIL,ATRFIL,BUFITM,ITMLOC,ITMMOD,ITMDIM,ITMTYP,ITMIO,ITMOVL,ITMFMT,ITMMIN,ITMMAX,ITMNAM(7),LITNAM
6  REAL ITMMIN,ITMMAX
7  STRING INPUT(4),ITMNAM(4)
8  STRING SBSNAM(8),OVL(8),INDOVL(8),DICFIL(8),FMTFIL(8),ATRFIL(8)
9 * 
10 *FROM RUNCOMDS
11  INTEGER ALL,EXITEM,CLEAR,CEXEC,CURITM,CSONNO,CURSON
12  STRING DICTF(4),FMTF(4),ATRF(4),MSGF(4)
13  STRING DBLANK(8),MSGFIL(8),DSPHSH(8),DSDATA(8)
14  DATA MXLSBN,ALL,CLEAR,CURSON,CEXEC/6,0,7,0,102/
15  DATA DICTF,FMTF,ATRF,MSGF/'DF','FF','AF','MF'/
16  DATA DBLANK,DSPHSH,DSDATA/' ','DSPHSH','DSDATA'/
17  DATA N0,N1,N2,N1000,N10T6/0,1,2,1000,1000000/
18  DATA M10/-10/
19  EXITEM=N0
20  IF(CMND.NE.N0)GOTO 10
21 * 
22 *  USER JUST STARTED -- THIS IS THE FIRST OVERLAY CALLED
23 * 
24 *  NULL OUT INPUT STRING TO FORCE SCOPE FAILURE IN DATADS
25 * 
26  LINPUT=N0
27  NXSTRT=N0
28 * 
29 *  IS THERE A MODULE NAME IN COMMON
30 * 
31  IF(LSBNAM.NE.N0)GOTO 20
32 * 
33 *  NO MODULE NAME IN COMMON -- ZERO OUT PARAMETERS NORMALLY READ
34 *  FROM MODULE'S BINARY DICTIONARY FILE AND READ IN PROTOTYPE
35 *  HASH TABLE CONTAINING ENTRIES FOR SYSTEM COMMANDS ONLY
36 * 
37  NITEMS=100
38  FSTITM=N0
39  LSTITM=N0
40  CLRITM=N0
41  MULTRE=N0
42  DICFIL=DSPHSH
43  OPEN(3,DICFIL,INPUT,BINARY)
44  READ(3)HASH
45  GOTO 40
46 * 
47 *  CHECK FOR CLEAR COMMAND
48 * 
49  10   IF(CMND.EQ.CLEAR)GOTO 100
50 * 
51 *  INITIAL MODULE NAME GIVEN OR SWITCHING MODULES
52 * 
53 *  CONSTRUCT NAMES OF BINARY DICTIONARY FILE (DICFIL),
54 *  ATTRIBUTE FILE (ATRFIL), AND FORMAT FILE (FMTFIL) FROM
55 *  MODULE NAME AND SUFFIXES
56 * 
57  20   LSBNAM=MIN0(LSBNAM,MXLSBN)
58  L=LSBNAM+N1
59  DICFIL=DBLANK
60  CALL MOVE(SBSNAM,N1,DICFIL,N1,LSBNAM)
61  CALL MOVE(DICTF,N1,DICFIL,L,N2)
62  ATRFIL=DBLANK
63  CALL MOVE(SBSNAM,N1,ATRFIL,N1,LSBNAM)
64  CALL MOVE(ATRF,N1,ATRFIL,L,N2)
65  FMTFIL=DBLANK
66  CALL MOVE(SBSNAM,N1,FMTFIL,N1,LSBNAM)
67  CALL MOVE(FMTF,N1,FMTFIL,L,N2)
68 * 
69 *  CONSTRUCT NAME OF BANNER MESSAGE FILE AND CALL ROUTINE TO
70 *  DUMP IT IF IT EXISTS
71 * 
72  MSGFIL=DBLANK
73  CALL MOVE(SBSNAM,N1,MSGFIL,N1,LSBNAM)
74  CALL MOVE(MSGF,N1,MSGFIL,L,N2)
75  CALL FDUMP(MSGFIL,$30)
76 * 
77 *  READ IN ALL ASSUMED VALUES
78 * 
79  30   CALL ASMVAL(ALL)
80 * 
81 *  READ MODULE'S PARAMETERS FROM BINARY DICTIONARY FILE
82 * 
83  OPEN(3,DICFIL,INPUT,BINARY)
84  READ(3)NITEMS,MULTRE,FSTITM,LSTITM,CLRITM,HASH,SONPTR,SONS,TREE,EXIST
85 * 
86 *  SET ITEM TO BE EXECUTED TO FIRST ITEM
87 * 
88  EXITEM=FSTITM
89 * 
90 *  INITIALIZE COMMON
91 * 
92  40   ITEM=N0
93  OBJ=N0
94  DO 50 I=N1,NITEMS
95  50   HISTRY(I)=N0
96  SPCALC=N0
97  NOPRNT=N0
98  FLUSH=N0
99  ITMCHK=N0
100  BRIEF=N0
101  LEDITL=N0
102  CURRGO=N0
103  LASTGO=N0
104  CURCMP=N0
105  LCOMPL=N0
106  LACTVL=N0
107  LPRNTL=N0
108  ERRCNT=N0
109  BUFITM=N0
110 * 
111 *  SEE IF AN ITEM'S RELATION CODE SHOULD BE EXECUTED
112 * 
113  IF(EXITEM.EQ.N0)GOTO 70
114 * 
115 *  BUILD A COMPUTATION LIST OF ONE ITEM TO EXECUTE THE ITEM AS
116 *  A COMMAND WITH PRINTING SUPPRESSED
117 * 
118  CALL FILE(EXITEM)
119  LCOMPL=N1
120  COMPL(LCOMPL)=N10T6+N1000*ITMOVL+EXITEM
121  CMND=CEXEC
122  60   CLOSE(4)
123  70   IF(INDIR.EQ.N0)OVL=DSDATA
124  INDIR=-INDIR
125  CLOSE(3)
126  RETURN
127 * 
128 * 
129 * 
130 *  CLEAR COMMAND
131 * 
132 *  SEE IF AN OBJECT WAS GIVEN
133 * 
134  100  IF(OBJ.NE.N0)GOTO 110
135 * 
136 *  NO OBJECT -- CLEAR ALL ITEMS
137 * 
138 *  READ IN ALL ASSUMED VALUES, SET ITEM TO BE EXECUTED TO
139 *  THE CLEAR ITEM, AND GOTO RE-INITIALIZE COMMON
140 * 
141  CALL ASMVAL(ALL)
142  EXITEM=CLRITM
143  GOTO 40
144 * 
145 *  OBJECT GIVEN
146 * 
147 *  READ IN ASSUMED VALUE OF OBJECT (IF ANY)
148 * 
149  110  CALL ASMVAL(OBJ)
150 * 
151 *  IF OBJ IS CURRENTLY IN ERROR , BUMP ERROR COUNT DOWN
152 * 
153  IF(IABS(HISTRY(OBJ)).GE.N1000)ERRCNT=ERRCNT-N1
154 * 
155 *  IS THERE AN ACTIVE LIST
156 * 
157  IF(LACTVL.GT.N0)GOTO 120
158 * 
159 *  NO ACTIVE LIST
160 * 
161 *  JUST SET HISTORY OF OBJ TO ZERO AND GET OUT
162 * 
163  HISTRY(OBJ)=N0
164  GOTO 60
165 * 
166 *  THERE IS AN ACTIVE LIST
167 * 
168 *  REVOVE FROM ACTIVE LIST OBJ (IF ON ) AND ALL OTHER ITEMS
169 *  WHOSE VALUES DEPEND ON OBJ DIRECTLY OR INDIRECTLY
170 * 
171  120  HISTRY(OBJ)=M10
172  DO 150 I=N1,LACTVL
173  CURITM=ACTVL(I)
174  IF(CURITM.EQ.OBJ)GOTO 140
175  CSONNO=N0
176  130  CSONNO=CSONNO+N1
177  CALL GETSON(CURITM,CSONNO,CURSON,N0,$150,$150)
178  IF(HISTRY(CURSON).NE.M10)GOTO 130
179  IF(IABS(HISTRY(CURITM)).GE.N1000)ERRCNT=ERRCNT-N1
180  HISTRY(CURITM)=M10
181  140  ACTVL(I)=N0
182  150  CONTINUE
183  DO 160 CURITM=N1,NITEMS
184  IF(HISTRY(CURITM).EQ.M10)HISTRY(CURITM)=N0
185  160  CONTINUE
186  J=N0
187  DO 180 I=N1,LACTVL
188  IF(ACTVL(I))170,180,170
189  170  J=J+N1
190  ACTVL(J)=ACTVL(I)
191  180  CONTINUE
192  LACTVL=J
193  GOTO 60
194  END
195  SUBROUTINE FILE(ITEMNO)
196  INTEGER OBJ,HISTRY(100),SPCALC,FLUSH,BRIEF,FRSTSG,EDITL,CURRGO,
                         EXIST,CMND,CURCMP,ERRCNT,COMPL,ACTVL,PRNTL,FSTITM,CLRITM,HASH,
                          SONPTR,SONS,TREE,BUFITM,ITMLOC,ITMDIM,TYPE,OVLNO,FMTPTR
197  COMMON FV(3000)
198  COMMON ITEM,OBJ,SBSNAM,LSBNAM,HISTRY,
                         SPCALC,NOPRNT,FLUSH,ITMCHK,BRIEF,
                         INPUT(21),LINPUT,FRSTSG,LASTSG,NXSTRT,
                         EDITL(100),LEDITL,OVL,INDOVL,INDIR
199 COMMON  CURRGO,LASTGO,CMND,CURCMP,ERRCNT,
                         COMPL(100),LCOMPL,ACTVL(100),LACTVL,PRNTL(100),LPRNTL,
                         NITEMS,MULTRE,EXIST(3),FSTITM,LSTITM,CLRITM
200 COMMON  HASH(199),SONPTR(25),SONS(65),TREE(100),
                         DICFIL,FMTFIL,ATRFIL,
                         BUFITM,ITMLOC,ITMMOD,ITMDIM,ITMTYP,ITMIO,ITMOVL
201 COMMON  ITMFMT,ITMMIN,ITMMAX,ITMNAM(7),LITNAM
202  REAL ITMMIN,ITMMAX
203  STRING INPUT(4),ITMNAM(4)
204  STRING SBSNAM(8),OVL(8),INDOVL(8),DICFIL(8),FMTFIL(8),ATRFIL(8)
205 * 
206 *FROM RUNCOMDS
207 * 
208 *  SUBROUTINE TO READ THE ATTRIBUTES OF AN ITEM FROM THE
209 *  MODULE'S ATTRIBUTE FILE INTO COMMON, WHERE ITEMNO IS THE
210 *  NUMBER OF THE ITEM WHOSE ATTRIBUTES ARE TO BE READ
211 * 
212  STRING COLON(4)
213  DATA COLON/:/
214  DATA N0,N1,N28/0,1,28/
215 * 
216 *  IF ITEM'S ATTRIBUTES ARE ALREADY IN CORE, RETURN
217 * 
218  IF(ITEMNO.EQ.BUFITM)GOTO 1
219  BUFITM=ITEMNO
220 * 
221 *  READ THE ITEM'S ATTRIBUTES USING THE ITEM'S NUMBER AS
222 *  A RECORD INDEX
223 * 
224  OPEN(4,ATRFIL,RANDIO,BINARY)
225  READ(4)(BUFITM)ITMLOC,ITMMOD,ITMDIM,ITMTYP,ITMIO,
                        ITMOVL,ITMFMT,ITMMIN,ITMMAX,ITMNAM
226 * 
227 *  COMPUTE LENGTH OF ITEM'S FIRST NAME (NAMES ARE IN ITMNAM
228 *  ENDED BY COLONS)
229 * 
230  M=N1
231  CALL SCOPE(ITMNAM,M-N28,K,LITNAM,N0,N0,N0,N0,COLON,N1,$2)
232  1    RETURN
233 * 
234 *  ITEM HAS NO NAME
235 * 
236  2    LITNAM=N0
237  GOTO 1
238  END
239  SUBROUTINE ASMVAL(ITEMNO)
240  INTEGER OBJ,HISTRY(100),SPCALC,FLUSH,BRIEF,FRSTSG,EDITL,CURRGO,
                         EXIST,CMND,CURCMP,ERRCNT,COMPL,ACTVL,PRNTL,FSTITM,CLRITM,HASH,
                          SONPTR,SONS,TREE,BUFITM,ITMLOC,ITMDIM,TYPE,OVLNO,FMTPTR
241  COMMON FV(3000)
242  COMMON ITEM,OBJ,SBSNAM,LSBNAM,HISTRY,
                         SPCALC,NOPRNT,FLUSH,ITMCHK,BRIEF,
                         INPUT(21),LINPUT,FRSTSG,LASTSG,NXSTRT,
                         EDITL(100),LEDITL,OVL,INDOVL,INDIR
243 COMMON  CURRGO,LASTGO,CMND,CURCMP,ERRCNT,
                         COMPL(100),LCOMPL,ACTVL(100),LACTVL,PRNTL(100),LPRNTL,
                         NITEMS,MULTRE,EXIST(3),FSTITM,LSTITM,CLRITM
244 COMMON  HASH(199),SONPTR(25),SONS(65),TREE(100),
                         DICFIL,FMTFIL,ATRFIL,
                         BUFITM,ITMLOC,ITMMOD,ITMDIM,ITMTYP,ITMIO,ITMOVL,
                         ITMFMT,ITMMIN,ITMMAX,ITMNAM(7),LITNAM
245  REAL ITMMIN,ITMMAX
246  STRING INPUT(4),ITMNAM(4)
247  STRING SBSNAM(8),OVL(8),INDOVL(8),DICFIL(8),FMTFIL(8),ATRFIL(8)
248 * 
249 *FROM RUNCOMDS
250 * 
251 *  SUBROUTINE TO READ ASSUMED VALUES FOR AN ITEM INTO ITS 
252 *  ALLOCATED STORAGE IN FV, WHERE ITEMNO IS THE NUMBER OF THE
253 *  ITEM WHOSE ASSUMED VALUES (IF ANY) ARE TO BE READ
254 * 
255 *  IF ITEMNO=0 ASSUMED VALUES FOR ALL ASSUMABLE ITEMS ARE READ
256 * 
257  INTEGER ALL,ASSUME
258  DATA ALL,ASSUME/0,2/
259  DATA N0,N10000/0,10000/
260  IF(ITEMNO.NE.N0)GOTO 10
261  LOCN=N10000
262  GOTO 20
263  10   CALL FILE(ITEMNO)
264  IF(ITMTYP.NE.ASSUME)GOTO 100
265  LOCN=ITMLOC
266  20   READ(3)I1,I2
267  30   IF(I1.EQ.N0.OR.I1.GT.LOCN)GOTO 100
268  IF(ITEMNO.NE.N0)IF(I1-LOCN)50,40,50
269  40   READ(3)(FV(I),I=I1,I2),I1,I2
270  GOTO 30
271  50   READ(3)(TEMP,I=I1,I2),I1,I2
272  GOTO 30
273  100  RETURN
274  END
275  SUBROUTINE FDUMP(FILE,*)
276 * 
277 *  SUBROUTINE TO PRINT A BCD FILE WITH OR WITHOUT LINE
278 *  NUMBERS, WHERE FILE IS THE NAME OF THE FILE TO BE DUMPED
279 * 
280 *  NON-STANDARD RETURNS
281 *    1 -- FILE DOES NOT EXIST OR IS NOT BCD
282 * 
283  INTEGER INFO(4),FSTCHR
284  STRING TEXT(80),BUFF(2048),BLANK(4),CZERO(4)
285  STRING FILE(8)
286  LOGICAL EQ
287  DATA BLANK,CZERO/ ,0/
288  DATA N0,N1,N3,N7,N72,N510,N512/0,1,3,7,72,510,512/
289 * 
290 *  CHECK FOR EXISTANCE OF FILE
291 * 
292  CALL FILE#CHK(FILE,INFO,N1,$99)
293 * 
294 *  IS FILE BCD?
295 * 
296  IF(INFO(N1).NE.N0)GOTO 99
297 * 
298 *  FILE EXISTS AND IS BCD -- INITIALIZE FOR DUMP
299 * 
300  FSTCHR=N0
301  NWDS=N512
302 * 
303 *  READ 1ST RECORD OF FILE AND DECIDE WHETHER OR NOT FILE HAS
304 *  LINE NUMBERS
305 * 
306  10   CALL #READ#(FILE,TEXT,LTEXT,$50)
307  IF(FSTCHR.NE.N0)GOTO 20
308 * 
309 *  FIRST TIME THROUGH -- CHECK IF FILE HAS LINE NUMBERS AND
310 *  SET FSTCHR APPROPRIATELY
311 * 
312  FSTCHR=N1
313  IF(EQ(TEXT,N1,CZERO,N1,N1))FSTCHR=N7
314 * 
315 *  IF NO LINE NUMBERS GET OUT AND READ A LINK AT A TIME
316 * 
317  IF(FSTCHR.EQ.N1)GOTO 30
318 * 
319 *  PRINT CURRENT LINE OF FILE WITH LINE NUMBERS AND GO BACK FOR
320 *  NEXT LINE
321 * 
322  20   CALL STRPRINT(BLANK,TEXT,FSTCHR,LTEXT,N72)
323  GOTO 10
324 * 
325 *  FILE HAS NO LINE NUMBERS -- READ IT UNBUFFERED A LINK AT A
326 *  TIME -- INFO(3) HAS NUMBER OF LINKS
327 * 
328  30   CLOSE(6)
329  NLINKS=INFO(N3)
330  DO 40 LINK=N1,NLINKS
331 * 
332 *  GET NEXT LINK
333 * 
334  CALL #UREAD#(FILE,LINK,BUFF,NWDS)
335  NWDSP=NWDS
336 * 
337 *  IF WE READ A FULL LINK (IE. NWDS STILL = 512) SET NUMBER OF
338 *  WORDS TO PRINT TO 510 SINCE G.E. USES LAST TWO WORDS OF LINK
339 *  TO POINT TO NEXT LINK
340 * 
341  IF(NWDSP.EQ.N512)NWDSP=N510
342 * 
343 *  PRINT OUT THIS LINK OF FILE (WE CAN GET AWAY WITH THIS SINCE
344 *  END OF RECORD MARK FOR BCD FILES IS A WORD CONTAINING 
345 *  CR LF RO RO)
346 * 
347  PRINT 34,(BUFF(J),J=N1,NWDSP)
348  34   FORMAT('0',S)
349  40   CONTINUE
350  50   CLOSE(6)
351  RETURN
352  99   RETURN N1
353  END
354  SUBROUTINE GETSON(ITEMNO,SONNO,SON,IGNORE,*,*)
355  INTEGER OBJ,HISTRY(100),SPCALC,FLUSH,BRIEF,FRSTSG,EDITL,CURRGO,
                         EXIST,CMND,CURCMP,ERRCNT,COMPL,ACTVL,PRNTL,FSTITM,CLRITM,HASH,
                          SONPTR,SONS,TREE,BUFITM,ITMLOC,ITMDIM,TYPE,OVLNO,FMTPTR
356  COMMON FV(3000)
357  COMMON ITEM,OBJ,SBSNAM,LSBNAM,HISTRY,
                         SPCALC,NOPRNT,FLUSH,ITMCHK,BRIEF,
                         INPUT(21),LINPUT,FRSTSG,LASTSG,NXSTRT,
                         EDITL(100),LEDITL,OVL,INDOVL,INDIR
358 COMMON  CURRGO,LASTGO,CMND,CURCMP,ERRCNT,
                         COMPL(100),LCOMPL,ACTVL(100),LACTVL,PRNTL(100),LPRNTL,
                         NITEMS,MULTRE,EXIST(3),FSTITM,LSTITM,CLRITM
359 COMMON  HASH(199),SONPTR(25),SONS(65),TREE(100),
                         DICFIL,FMTFIL,ATRFIL,
                         BUFITM,ITMLOC,ITMMOD,ITMDIM,ITMTYP,ITMIO,ITMOVL,
                         ITMFMT,ITMMIN,ITMMAX,ITMNAM(7),LITNAM
360  REAL ITMMIN,ITMMAX
361  STRING INPUT(4),ITMNAM(4)
362  STRING SBSNAM(8),OVL(8),INDOVL(8),DICFIL(8),FMTFIL(8),ATRFIL(8)
363 * 
364 *FROM RUNCOMDS
365 * 
366 *  GETS ONE OF AN ITEM'S SONS, WHERE -
367 *ITMNO = ITEM NO. OF ITEM WHOSE SON IS TO BE RETURNED
368 *SONNO = NUMBER OF SON TO BE RETURNEE
369 *  SON = ITEM NO. OF RETURNED SON
370 *    IGNORE = ITEM NO. OF SON TO BE IGNORED BY THIS CALL
371 * 
372 *  NON-STANDARD RETURNS --
373 *    1 -- ITEM DOES NOT HAVE SONNO SONS
374 *    2 -- ITEM HAS NO SONS AT ALL
375 * 
376  INTEGER SONNO,SON,FSPTR,SPTR
377  DATA FSPTR,LSPTR/0,0/
378  DATA N1,N2,N4/1,2,4/
379 * 
380 *  GET POINTERS TO FIRST AND LAST SONS OF ITEM
381 * 
382  CALL MOVE(SONPTR,ITEMNO,FSPTR,N4,N1)
383  CALL MOVE(SONPTR,ITEMNO+N1,LSPTR,N4,N1)
384  LSPTR=LSPTR-N1
385 * 
386 *  IF NO SONS RETURN 2
387 * 
388  IF(FSPTR.GT.LSPTR)RETURN N2
389 * 
390 *  GET POINTER TO SONNO-TH SON OF ITEM
391 * 
392  10   SPTR=FSPTR+SONNO-N1
393 * 
394 *  IF NO SONNO--TH SON RETURN 1
395 * 
396  IF(SPTR.GT.LSPTR)RETURN N1
397 * 
398 *  GET SONNO-TH SON OF ITEM
399 * 
400  CALL MOVE(SONS,SPTR,SON,N4,N1)
401 * 
402 *  SEE IF WE SHOULD IGNORE IT -- IF SO, BUMP SONNO AND START OVER
403 * 
404  IF(SON.NE.IGNORE)RETURN
405  SONNO=SONNO+N1
406  GOTO 10
407  END
  