TITLE LOGIN - V54(73) - 1 APR 72
SUBTTL J LEONARD MODS /TW/DJB/DAL/RCC/JSL

VWHO==0
VLOGIN==54
VMINOR==0
VEDIT==73

;(C) COPYRIGHT 1969, 1970, 1971, 1972 DIGITAL EQUIPMENT CORP., MAYNARD MASS.

.JBVER=137
LOC .JBVER
	BYTE	(3)VWHO(9)VLOGIN(6)VMINOR(18)VEDIT
	RELOC

	TWOSEG

INTERN VLOGIN,LOGIN,.JBVER

;CONDITIONAL ASSEMBLY SWITCHES
IFNDEF FACTSW,<FACTSW=1>	;INCLUDE ACCOUNTING CODE
IFNDEF SUPNOT,<SUPNOT==1>	;NON-ZERO TO SUPPRESS NOTICE.TXT WITH / IN PPN
IFNDEF LEVDSW,<LEVDSW==1>	;NON-ZERO TO INCLUDE LEVEL D CODE
IFNDEF LEVCSW,<LEVCSW==1>	;NON-ZERO TO INCLUDE LEVEL C CODE
CDSW==LEVDSW&LEVCSW		;IF NON-ZERO INCLUDE CODE FOR BOTH
IFNDEF	FASTLG,<FASTLG==1>	;NON-ZERO TO INCLUDE ACCT.SYS DIR IN HI SEG
IFN	FACTSW,<
IFNDEF	FAILOG,<FAILOG==1>>	;ENABLE FACT FILE LOGGING OF LOGIN/ATTATCH FAILURES
IFE	FACTSW,<FAILOG==0>	;NO POINT IF NO FACT FILE
IFNDEF DAEMSW,<DAEMSW==1>	;NON-ZERO TO USE DAEMON TO WRITE FACT FILE
;ERROR CODES FOR TYPES OF LOGIN ERRORS (FOR PTY JOBS)
;**** NOTE ERROR COMMENTS SHOULD ALL BEGIN WITH A QUESTION MARK
;**** AND FOR PTY JOBS INCLUDE AN ERROR TYPE OF THE FORM
;**** (#) WHERE # IS ONE OF THE FOLLOWING:

ERR.NF==1	;NON FATAL
ERR.SF==2	;SEMI FATAL
ERR.FT==3	;FATAL
ERR.SS==4	;STOP SCHEDULING (E.G. NO ACCT.SYS)

;SEE SUBROUTINE ERRLIN

;AC ASSIGNMENTS

F=0	;FLAGS
A=1	;4 ACS FOR LOOKUPS AND GENERAL WORK
B=2
C=3
D=4

T=5	;TEMP
E==T	;FOR UFDSET
CALC=6	;FOR ACCOUNTING
R=7	;FOR RADIX PRINT
M=10	;MESSAGE ADDRESSES
BP=11	;BYTE POINTER
PP=12	;PROJECT PROGRAMMER PAIR
N=13	;NUMBERS IN OR OUT
N1=14	;N+1 FOR RADIX PRINT
CH=15	;CHARACTERS
WD=16	;WORDS
IO==WD	;USED BY UFDSET
P=17	;PUSHDOWN POINTER

;IO CHANNELS

TTY==1	;TELETYPE
UFD==2	;FOR DISK IO
USR==3	;FOR CHECKING USER FILES
US1==4	;THESE TWO USED BY UFDSET
FCT==6	;FOR THE FACT FILE
;PARAMETERS FROM COMMOD.MAC

RIBPPN==1
RIBNAM==2
RIBEXT==3
RIBPRV==4
RIBALC==11
RIBQTF==22
RIBQTO==23
RIBQTR==24
RIBUSD==25
RIBSTS==17
  RIPBDA==1
  RIPCRH==4
  RIPBFA==10
  RIPHRE==100
  RIPHWE==200
  RIPSCE==400
  RIPLOG==400000	;LH
  RIPDIR==400000	;RH
  RIPNDL==200000	;RH - DO NOT DELETE BIT
  RIPABC==20000

DEVNAM==0
;FLAGS - LH OF F

FL.TYO==1	;STUFF IN TTY OUTPUT BUFFER
FL.MSG==2	;SUPPRESS MESSAGE IF ON
FL.WKD==4	;ON IF THIS IS A WEEKDAY
FL.FDX==10	;ON IF THIS IS A FULL-DUPLEX LINE
FL.RAS==20	;READ ACCOUNT FILE SYNC (I.E., TO RD 1ST WD)
L.WRTL==40	;SET IF WRITE LOCK FOR STR
FL.NMC==100	;WANT TO CHECK NAME
L.FRE1==FL.NMC	;FREE BIT FOR UFDSET
FL.ACC==200	;SET IF READING ACCT.SYS, NOT IF AUXACC.SYS
L.SIN==FL.ACC	;ALWAYS OFF FOR UFDSET
FL.BRK==400	;SET IF BREAK CHAR DETECTED IN COMMAND LINE
L.FRE2==FL.BRK	;FREE BIT FOR UFDSET
FL.BSJ==1000	;SET IF BATCH JOB SUBJOB
FL.LVD==2000	;SET IF LEVEL D IN C-D LOGIN
FL.BAT==4000	;SET IF THIS JOB IS A BATCH JOB
L.NCR==10000	;SET IF NO CREATE FOR AN STR
L.OPR==20000	;SET IF MY TTY IS OPR OR CTY
L.SOPR==40000	;SET IF I AM ON PTY UNDER OPR, CTY OR A 1,2 JOB
FL.ATT==100000	;SET IF ATTACH COMMAND
FL.WLD==200000	;WILD CARD PROGRAMER

;RH OF F

R.ACRE==1		;SET IF ANY CREATES ALLOWED ON ANY STR'S
R.ASTR==2		;SET IF ANY STR'S IN THIS JOB'S SEARCH LIST

;SPECIAL PPN CHARACTERS

UNISYM=="#"	;CHARACTER FOR CREATE UNIQUE PPN
UNIPRG==777776	;INTERNAL VALUE FOR UNIQUE PPN

;DAEMON FUNCTIONS

D.FACT==3	;WRITE FACT FILE ENTRY
;CALLI ADDRESSES

CI.RES==0	;RESET
CI.DDO==3	;DDT OUT
CI.COR==11	;CORE CONTROL
CI.EXI==12	;EXIT
CI.DAT==14	;DATE
CI.LGI==15	;LOGIN
CI.LGO==17	;LOGOUT
CI.TIM==22	;TIME IN JIFFIES
CI.MST==23	;TIME IN MILLISECS
CI.JOB==30	;JOB NUMBER
CI.SLP==31	;SLEEP
CI.PEK==33	;PEEK
CI.GTT==34	;GET TTY LINE NUMBER
CI.RUN==35	;RUN UUO
CI.SWP==36	;SET WRITE PROTECT OR WRITE ENABLE HI-SEG
CI.GET==41	;GET SYSTEM TABLES
CI.STN==43	;SETNAM
CI.TMP==44	;TEMPORARY IN-CORE TABLES
CI.CHR==45	;DSKCHR UUO - GET DISK CHARACTERISTICS
CI.DVP==55	;DEVPPN - GET PPN FOR DEVICE (EG SYS)
CI.CPN==74	;CHANGE PPN
CI.SET==75	;SET UUO

;PARAMETERS

MAXENT==20	;MAX SIZE OF ENTRY IN ACCT.SYS

ACCFOR==2	;FORMAT VERSION NUMBER FOR MOST RECENT FORMAT OF ACCT.SYS
AC1FOR==0	;FORMAT VERSION NUMBER FOR AUXACC.SYS

FBMTRY==^D10	;TIMES TO RETRY TO ENTER OR RENAME UFD

;BITS IN RH STATES WORD

ST.NLG==1		;NO LOGINS
ST.NRM==2		;LOCAL LOGINS ONLY
ST.BO==4		;BATCH LOGINS ONLY

;BITS IN LH STATES WORD

ST.NSC==100	;SET IF NEW SCANNER SERVICE

;BITS IN LEFT HALF OF TTCALL GETLIN RETURN

TT.PTY==400000	;BIT IN LH(TTBITS) SET IF PTY
TT.CTY==200000	;BIT IN LH(TTBITS) SET IF CTY
TT.DS==40000	;SET IF DATA SET TTY
TT.RM==4000	;SET IF REMOTE (HARDWIRED) TTY
TT.RO==		;SET IF REMOTE CTY OR OPR
HDXBTS==410006	;ANY OF THESE BITS IMPLIES HALF DUPLEX
;BITS IN DSKCHR AC RETURN

.UPSAF==1B4	;SET IF FILE STRUCTURE IS SINGLE ACCESS

;ASCII CHARACTERS

CNTRLC==3	;CONTROL C
LF==12		;LINE FEED
VT==13		;VERTICAL TAB
FF==14		;FORM FEED
CR==15		;CARRIAGE RETURN
ALTMOD==33	;STANDARD ALTMODE

;STORAGE MACROS
DEFINE U(A)<	UU(A,1)>
.ZZ=140

	DEFINE UU(A,B)<
	RELOC
A:	BLOCK B
.ZZ==.ZZ+B
	RELOC
>
OPDEF STRUUO [CALLI 50]
.FSDSL==1	;FUNCTION TO DEFINE SEARCH LIST

OPDEF PJRST [JRST]
OPDEF RESCAN [TTCALL 10,]
OPDEF CTLJOB [CALLI 65]

;WORDS IN ACCT.SYS ENTRY

PPWRD==0	;PROJECT, PROGRAMMER NUMBER
CODWRD==1	;CODE
PRVWRD==2	;PRIVILEGE BITS
NM1WRD==3	;1ST HALF OF USERS NAME
NM2WRD==4	;2ND HALF OF USERS NAME
TIMWRD==5	;LEGAL LOGIN TIMES
PLCWRD==6	;PLACES MAY LOGIN WITH THIS PASSWORD
PROWRD==7	;USER PROFILE BITS
RCNWRD==11	;NAME OF CUSP TO RUN
RCDWRD==12	;DEVICE FROM WHICH TO RUN CUSP
RCPWRD==13	;DIRECTORY FROM WHICH TO RUN CUSP
CRGWRD==14	;CHARGE NUMBER
XPDWRD==15	;EXPIRATION DATE

MLON	;FOR MACRO

EXTERN .JBFF,.JBREL,.JBSA,.JBHRL	;IN .JBDAT
;BITS IN LH USER PROFILE WORD

P.SPCR==10000		;SPOOL CDR
P.SPCP==4000		;SPOOL CDP
P.SPTP==2000		;SPOOL PTP
P.SPPL==1000		;SPOOL PLT
P.SPLP==400		;SPOOL LPT

;BITS IN RH USER PROFILE WORD

P.PWBT==1		;PASSWORD REQUIRED FOR BATCH
P.PWTS==2		;PASSWORD REQUIRED FOR TIMESHARING
P.NMBT==4		;NAME REQUIRED FOR BATCH
P.NMTS==10		;NAME REQURED FOR TS
P.LGBT==20		;MAY LOGIN UNDER BATCH
P.LGBS==40		;MAY LOGIN AS BATCH SUBJOB
P.LGRM==100		;MAY LOGIN AT REMOTE (HARDWIRED) TTY
P.LGDS==200		;MAY LOGIN AT DATA SET TTY
P.LGRO==400		;MAY LOGIN AT REMOTE OPR OR CTY
P.LGLC==1000		;MAY LOGIN AT LOCAL TTY
;NOTE MAY ALWAYS LOGIN AT LOCAL OPR OR CTY

MAXFS==9	;MAXIMUM NUMBER OF FILE STRUCTURES PER USER

AC1BLK==5	;NUMBER OF WORDS PER BLOCK IN AUXACC.SYS ENTRIES

EXLLEN==26	;LENGTH OF ARGUMENT LIST FOR EXTENDED LOOKUP/ENTER/RENAME

EXLPPN==RIBPPN	;ENTRY FOR DIRECTORY NAME (PROJECT, PROGRAMMER NUMBER)
EXLNAM==RIBNAM	;FILE NAME
EXLEXT==RIBEXT	;EXT
EXLERR==RIBEXT	;ERROR CODE
EXLPRV==RIBPRV	;CREATION DATE, TIME, PRIVS, MODE
EXLALC==RIBALC	;BLOCKS ALLOCATED
EXLQTR==RIBQTR	;RESERVED QUOTA
EXLQTF==RIBQTF	;FIRST COME, FIRST SERVED QUOTA
EXLQTO==RIBQTO	;LOGGED-OUT QUOTA
EXLUSD==RIBUSD	;FREE BLOCKS LEFT WITH RESPECT TO LOGGED-IN QUOTA
EXLSTS==RIBSTS	;STATUS BITS
;GETTAB ARGS

JBTSTS==0
  JACCT==1
  JLOG==4
PRJPRG==2
JBTPRG==3
TTYTAB==10

CNFTBL==11
  DEVOPR==13
  PTYPAR==22
NSPTBL==12
  SYSKTM==35		;TIME TILL SYSTEM SHUTDOWN

;SET UUO FUNCTIONS

STFWAT==6	;SET WATCH BITS
STFSPL==5	;SET SPOOL BITS

SHFWAT==^D12	;BITS TO SHIFT WATCH BITS TO POSITION FOR SET UUO
SHFSPL==0	;BITS TO SHIFT SPOOL BITS TO POSITION FOR SET UUO

OPDEF ATTACH [CALLI 104]
SUBTTL EXIT SEQUENCE

	RELOC	400000
;THIS PAGE IS PUT HERE SO IT CAN CLEAR ALL OF CORE
;ABOVE ITSELF, THUS NOT LEAVING PASSWORDS LYING AROUND

LAST:	TLNE	F,FL.ATT	;SKIP IF LOGIN, NOT IF ATTACH
	JRST	ALAST		;FINISH UP ATTACH
	LDB	A,WATBTS	;GET WATCH BITS
IFN SHFWAT,<LSH A,SHFWAT>
	HRLI	A,STFWAT	;SET WATCH FUNCTION
	CALLI	A,CI.SET	;SET WATCH BITS
	  JFCL
	LDB	A,SPLBTS	;GET SPOOL BITS
IFN SHFSPL,<LSH A,SHFSPL>
	HRLI	A,STFSPL	;SET SPOOL FUNCTION
	CALLI	A,CI.SET	;SET SPOOL BITS
	  JFCL
	CALLI	CI.RES		;RETRIEVE I/O BUFFERS
	SKIPN	D,ENTRY+RCNWRD	;SKIP IF RUN UUO TO BE EXECUTED
	JRST	NORUN		;NO, DONT SET IT UP
	SKIPN	C,ENTRY+RCDWRD	;YES, SKIP IF DEVICE SPECIFIED
	MOVSI	C,(SIXBIT .SYS.) ;NO, ASSUME SYS
	SETZB	T,CALC
	MOVE	R,ENTRY+RCPWRD	;PPN
NORUN:	SETZB	M,LASTX		;CLEAR CORE
	MOVE	B,[XWD 5,LASTX]		;PREPARE TO DELETE CORE FILES
	CALLI	B,CI.TMP	;DELETE TEMP FILES
	  JFCL			;IGNORE ERROR RETURN
	MOVE	A,LGIARG	;NOW LOG THE GUY IN
	CALLI	A,CI.LGI
	JFCL
	MOVE	BP,TOLO1
NORUN1:	MOVE	A,[XWD LASTX,LASTX+1]
	BLT	A,@.JBREL
	SETZM	.JBSA		;CLEAR START ADDRESS SINCE PROG NO LONGER THERE
	MOVE	A,[XWD TOLO,LASTX]
	BLT	A,LASTX+ETOLO-TOLO ;TRANSFER TO LOW SEG
	MOVEM	BP,LASTX+TOLO1-TOLO
	JUMPE	D,LASTX+FRUN-TOLO ;JUMP IF NO RUN UUO
	JRST	LASTX		;DO RUN UUO

TOLO:	MOVEI	BP,C
	CALLI	BP,CI.RUN	;RUN CUSP
FRUN:	SETZ	A,		;NO RUN UUO OR RUN UUO FAILED
	CALLI	A,CI.STN	;CLEAR NAME
	HRLZI	A,1		;GET RID OF HIGH SEG
	CALLI	A,CI.COR
	  JFCL
TOLO1:	CALLI	1,CI.EXI	;MONRET
ETOLO:	CALLI	0,CI.EXI	;AND EXIT IN CASE OF CONTINUE
ALAST:	MOVEI	M,CRLFPD
	PUSHJ	P,MSG		;MAKE IT LOOK GOOD
	HRRZ	A,ATTJOB	;JOB TO BE ATTACHED TO
	HRL	A,TTBITS	;LINE NUMBER OF TTY
	TLO	A,400000	;FORCE TTY TO MONITOR LEVEL
	ATTACH	A,		;ATTACH JOB TO TTY
	  JRST	NOATT		;WOOPS, COULDNT!
;	JRST	FLUSHX		;FALL INTO FLUSHX

FLUSHX:	SETSTS	TTY,0		;TURN ON ECHOING
	SETZB	D,LASTX		;CLEAR CORE IF UNSUCCESSFUL LOGIN
	MOVE	BP,[CALLI CI.LGO]	;KILL KJOB
	JRST	NORUN1

;***** DO NOT SEPARATE THE FOLLOWING

LGIARG:	XWD -LGISIZ,PPN		;THE DATA FOR LOGIN UUO

U(PPN)			;THE PRJPRG NUMBER
U(PRIVWD)			;THE PRIVILEGE WORD
U(NAME)
U(NAME2)			;REST OF NAME
U(CHGNO)

;*** END OF DO NOT SEPARATE
UU(LASTX,0)

LGISIZ==LASTX-PPN
SUBTTL STARTUP

;START HERE

LOGIN:	JFCL		;IN CASE OF CCL ENTRY
	CALLI	CI.RES		;RESET THE WORLD
	INIT	TTY,200		;TURN OFF ECHOING IN CASE FULL DUPLEX
	SIXBIT /TTY/		;AND THE TELETYPE
	XWD	TOB,TIB
	  CALLI	CI.LGO		;FORGET IT IF NO TTY
	INIT	UFD,17		;GET A DISK IN DUMP MODE
	SIXBIT	/SYS/		;LOOKUP ACCOUNTING FILES IN SYS
	XWD	0,0		;NO HEADERS
	  CALLI	CI.LGO		;THIS IS ALSO UNFIXABLE
	MOVE	P,PDPLST	;GET THE PUSHDOWN STACK
	SETZ	F,		;ALL FLAGS OFF
	SETZM	UFDDAT		;CLEAR DATE OF LATEST UFD
	SETZM	UFDTIM		;AND TIME
	HRROI	A,JBTSTS
	CALLI	A,CI.GET	;GET JBTSTS WORD FOR THIS JOB
	  SETZ	A,		;ASSUME OK
	TLNE	A,JACCT		;SKIP IF JACCT NOT ON
	TLNN	A,JLOG		;IF JACCT ON, PROCEED IF JOB NOT LOGGED IN
	JRST	LOGIN2		;OK, EITHER NOT JACCT OR NOT LOGGED IN
	MOVEI	M,[ASCIZ .?Please KJOB or DETACH.]
	PUSHJ	P,MSG
	CALLI	12		;EXIT
LOGIN2:	MOVNI	C,1		;GET THE TTY CHARACTERISTICS
	TTCALL	6,C
	CAMN	C,[-1]		;IF A NOOP, ASSUME HDX
	MOVSI	C,10000
	MOVEM	C,TTBITS
	MOVEM	C,CNTLJT
	TLNN	C,HDXBTS	;SKIP IF HALF DUPLEX
	TLOA	F,FL.FDX	;SET FULL DUPLEX FLAG
	SETSTS	TTY,0		;TURN ON ECHOING
	INBUF	TTY,1
	OUTBUF	TTY,1
	MOVE	A,[XWD 17,11]	;MAGIC CODES FOR LOC STATES IN SYS
	CALLI	A,CI.GET	;GET TABLE ENTRY
	  MOVEI	A,0		;ZERO IF ERROR RETURN
	MOVEM	A,STATES	;SAVE FOR LATER
	MOVE	A,[XWD DEVOPR,CNFTBL]	;GET OPR DEVICE NAME
	CALLI	A,CI.GET	; FROM MONITOR
	  MOVSI A,(SIXBIT /CTY/)	;ASSUME CTY IF IT WONT TELL US
	MOVEM	A,SAVOPR		;STORE FOR LATER USE
	CALLI	A,CI.GTT		;GET MY TTY NAME
	MOVEM	A,MYTTY		;SAVE IT
	TLNN	C,TT.CTY		;IS MY TTY THE CTY?
	CAMN	A,SAVOPR		;OR THE OPR?
	TLO	F,L.OPR			;YES. REMEMBER THAT IN FLAG AC
IFN CDSW,<
	LDB	A,LVDBTS
	CAIE	A,0
	TLO	F,FL.LVD
>

	MOVEI	A,^D5		;LET THE GUY TRY 5 TIMES
	MOVEM	A,LOGTRY

IFN LEVDSW,<MOVE B,SYSPPX	;LEVEL D DEFAULT SYSPPN>
IFE LEVDSW,<IFN LEVCSW,<MOVE B,MFDPPN ;LEVEL C DEFAULT SYSPPN>>

IFN CDSW,<
	TLNN	F,FL.LVD
	MOVE	B,MFDPPN
>	;END CONDITIONAL ON CDSW

	MOVSI	A,(SIXBIT .SYS.)
	CALLI	A,CI.DVP	;GET PPN FOR SYS
	  MOVE	A,B		;DEFAULT
	MOVEM	A,SYSPPN

	CALLI	A,CI.DAT	;TODAY'S DATE
	MOVEM	A,DATE		;SAVE FOR LATER

	CALLI	A,CI.JOB	;GET JOB NUMBER
	MOVEM	A,THSJOB	;SAVE FOR LATER
SUBTTL COMMAND SCANNER

;HERE TO DECIDE WHAT COMMAND INVOKED US
	RESCAN			;SET TO RESCAN COMMAND
CMSCNA:	PUSHJ	P,GETCOM	;GET 1ST ARG=MONITOR COMMAND
	SETZ	N,
	HLLZ	A,WD		;A=1ST 3 CHARS OF COMMAND
	PUSHJ	P,GETMSK	;GET MASK IN C FOR CHARS TYPED
	TRO	C,-1		;NEED RH SET
	MOVSI	D,-COMLEN
COMSCN:	HRR	A,COMLST(D)	;SET RH A=RH D FOR COMPARE
	CAMN	A,COMLST(D)	;CHECK FOR EXACT MATCH
	JRST	(A)		;DISPATCH IF EXACT MATCH
	MOVE	B,COMLST(D)	;NO, CHECK FOR ABBREVIAATION
	AND	B,C		;CHECK ONLY NUM CHARS TYPED
	CAME	A,B		;SKIP IF MATCH
	JRST	CMSCN1		;NO
	CAIE	N,0		;SKIP IF NO PREVIOUS MATCH
	TLOA	N,-1		;SET LH TO NOTE TOO MANY MATCHES
	HRRZ	N,A		;SAVE DISPATCH ADDR IN N
CMSCN1:	AOBJN	D,COMSCN	;LOOP
	JUMPG	N,(N)		;IF EXACTLY 1 MATCH, DISPATCH
CMSCN2:	TLNE	F,FL.BRK	;SKIP IF NOT END OF COMMAND LINE
	JRST	LOGDIS
	PUSHJ	P,GET2WD	;IGNORE NEXT ARG
	JRST	CMSCN2		;AND LOOP TILL END OF LINE (BREAK CHAR)

	DEFINE	COMTAB(A)<
	IRP A,<XWD SIXBIT \   A\,A'DIS>>

COMLST:	COMTAB <LOG,ATT,R,RUN>
COMLEN=.-COMLST

;HERE IF R SOMETHING

RDIS==CMSCNA

;HERE IF RU DEVICE SOMETHING

RUNDIS:	PUSHJ	P,GETCOM
	JRST	CMSCNA
;HERE IF ATTACH

ATTDIS:	PUSHJ	P,DECIN		;READ JOB NUMBER TO BE ATTACHED TO
	MOVEM	N,ATTJOB	;SAVE JOB NUMBER
	TLO	F,FL.ATT	;NOTE ATTACH
ATTD1:	CAIN	CH,"["		;SKIP IF NOT YET TO PPN
	JRST	ATTD2		;READ PPN
	PUSHJ	P,TYI		;READ NEXT CHAR
	JRST	ATTD1		;AND LOOP TILL [

ATTD2:	PUSHJ	P,OCTIN		;READ PROJECT NUMBER
	CAIG	N,-1		;MAY NOT EXCEED 6 DIGITS
	CAIE	CH,","		;MUST END WITH COMMA
	JRST	PPERR
	JUMPE	N,PPERR		;MUST BE SOMETHING THERE
	HRLZ	PP,N		;SAVE PROJECT NUMBER
	PUSHJ	P,OCTIN		;READ PROGRAMMER NUMBER
	JUMPE	N,PPERR		;MUST BE SOMETHING THERE
	CAILE	N,-1		;BUT NOT TOO MUCH
	JRST	PPERR
	HRR	PP,N		;SAVE PROGRAMMER NUMBER
	MOVEM	PP,PPN		;STORE PPN
ATTD3:	CAIE	CH,ALTMOD	;ALTMOD IS LEGAL BREAK CHAR
	CAIG	CH,CR		;OR VERTICAL PAPER MOTION
	JRST	NOJBMS		;OK, PROCEED WITH ATTACH
	PUSHJ	P,TYI		;NO, IGNORE REST OF LINE
	JRST	ATTD3
SUBTTL TYPE FIRST MESSAGE, CHECK STATES BITS

;HERE IF LOGIN

LOGDIS:	MOVE	A,STATES

;HERE TO TYPE JOB NUMBER, MONITOR NAME, AND TTY NUMBER

CTYOK:	TLNN	A,ST.NSC	;SKIP IF NEW SCANNER SERVICE
	JRST	ONTTY		;OLD SCANNER SERVICE TYPES THIS FOR US
	MOVEI	M,[ASCIZ .JOB .]
	PUSHJ	P,MSG
	MOVE	N,THSJOB	;GET JOB NUMBER
	PUSHJ	P,DECPRT
	PUSHJ	P,SPACE
	MOVNI	C,5
CONFLP:	MOVEI	A,11
	HRLI	A,5(C)
	CALLI	A,CI.GET	;GET NEXT WORD OF MONITOR NAME
	  JRST	ONTTY
	MOVEI	M,A
	SETZ	B,
	PUSHJ	P,MSG
	AOJL	C,CONFLP
	PUSHJ	P,SPACE
ONTTY:	MOVE	BP,[XWD 440600,MYTTY]	;SIXBIT BYTES FROM TTY NAME
ACCT4A:	ILDB	CH,BP		;GET A BYTE
	JUMPE	CH,ACCT4B	;STOP WHEN ALL CHARS DONE
	ADDI	CH,40		;MAKE IT ASCII
	PUSHJ	P,TYO		;TYPE IT
	TLNE	BP,770000	;ALL BYTES YET?
	JRST	ACCT4A		;NO.
ACCT4B:	PUSHJ	P,CRLF		;YES

NOJBMS:	MOVE	C,TTBITS
	MOVE	B,STATES	;GET STATE OF SYSTEM
	TLNN	C,TT.PTY	;SKIP IF PTY
	JRST	TTYGO
	SETO	A,		;REQUEST CONTROLLER OF OWN JOB
	CTLJOB	A,		; ..
	  JRST	TTYGO		;NOT IMPLEMENTED
	PUSHJ	P,ISBATC	;SEE IF BATCH IS IMMEDIATE CONTROLLER
	  JRST	NISBAT		;NO
	TLO	F,FL.BAT!L.SOPR	;REMEMBER THIS IS A BATCH JOB
	JRST	TTYGO		;YES, GO AHEAD, ALL CHECKING ALREADY DONE
NXTLVL:	SUBI	A,1		;RESET A=CONTROLLING JOB
	MOVE	WD,CNTLJP	;SAVE CONTROL JOB PPN OF PREVIOUS LEVEL
	PUSHJ	P,ISBATC	;SEE IF IT IS BATCH
	  JRST	NISBAT		;NO
	TLO	F,FL.BSJ	;YES, WE HAVE A BATCH JOB SUBJOB
	MOVEM	WD,CNTLJP	;USE CONTROL JOB PPN OF BATCH JOB
	MOVSI	C,TT.RM		;PRETEND REMOTE JOB
	JRST	TTYGO
NISBAT:	MOVE	D,CNTLJP	;PPN OF CONTROL JOB
	CAME	D,ALPPPN	;STOP IF REACH JOB WITH ALL PRIVILEGES
	JRST	NISBT1
	TLO	F,L.SOPR	;NOTE SUB OF 1,2 JOB
	JRST	TTYGO
NISBT1:	MOVE	D,A		;SAVE PREVIOUS JOB IN D
	HRLZ	C,A		;FIND JOB'S TTY DDB
	HRRI	C,TTYTAB
	CALLI	C,CI.GET	;FROM JOB'S TTY POINTER
	  JRST	TTYGO		;ASSUME NOTHING
IFN DEVNAM,<MOVEI C,DEVNAM(C)>
	CALLI	C,CI.PEK	;GET TTY NAME
	TLNN	C,-1		;IS IT DETACHED?
	JRST	TTYGO		;YES, DO NOT CONTINUE SCAN
	CTLJOB	A,		;GET NEXT CONTROLLING JOB NUMBER
	  JRST	TTYGO
	AOJN	A,NXTLVL	;LOOP TILL REACH BATCH OR TOP
	HRLZ	C,D
	HRRI	C,TTYTAB
	CALLI	C,CI.GET	;GET TTYTAB ENTRY FOR THAT JOB
	  SETZ	C,
IFN DEVNAM,<MOVEI C,DEVNAM(C)>
	CALLI	C,CI.PEK	;GET DEVNAM ENTRY=TTY NAME OF CONTROL JOB
	HRLZ	A,C		;A=SIXBIT LINE NUMBER
	CAIE	A,0		;SKIP IF CTY
	CAMN	C,SAVOPR	;IS IT THE OPR?
	TLO	F,L.SOPR	;FLAG SUBJOB OF OPR.
	SETZ	C,
	MOVE	BP,[POINT 6,A]
	JUMPN	A,ISPTY1	;JUMP IF NOT CTY
	MOVE	C,[XWD PTYPAR,CNFTBL]
	CALLI	C,CI.GET	;GET PTY OFFSET
	  SETO	C,
	HLRES	C		;C=OFFSET FOR FIRST PTY
	SUBI	C,1		;-1=LINE NUMBER OF CTY
	JUMPGE	C,ISPTY2	;JUMP IF HAVE CTY LINE NUMBER
	MOVSI	C,TT.CTY	;NO, FAKE TTBITS
	JRST	ISPTY3		;WE KNOW ITS THE CTY

ISPTY1:	ILDB	WD,BP
	JUMPE	WD,ISPTY2	;JUMP IF NO MORE CHARS
	LSH	C,3
	ADDI	C,-20(WD)
	JRST	ISPTY1

ISPTY2:	TTCALL	6,C		;GET LINE BITS FOR CONTROL JOB TTY
ISPTY3:	MOVEM	C,CNTLJT	;SAVE LINE BITS FOR CONTROL JOB TTY
;FALL INTO TTYGO
SUBTTL CHECK PPN

;B=STATES	C=TTBITS FOR TTY OR CONTROL JOB TTY

TTYGO:	TLNE	F,FL.ATT	;SKIP IF LOGIN, NOT IF ATTACH
	JRST	ATTCHK		;DONT NEED THIS FOR ATTACH
	TLNE F,L.OPR!L.SOPR	;OR OPER OR HIS SUB?
	JRST PPNGO		;YES. OK TO GO
	TRNE B,ST.NLG		;NO LOGIN?
	JRST NOTAVL		;YES. THIS GUY DOESNT GET IN.
	TLNE C,TT.DS!TT.RM	;NON-LOCAL?
	TRNN B,ST.NRM		;AND STATES SAYS LOCAL ONLY?
	SKIPA			;NO. OK
	JRST NORMT		;GO GIVE NO-REMOTE MESSAGE
	TLNE F,FL.BAT		;BATCH JOB?
	JRST	PPNGO1		;YES, CHECKING ALREADY DONE
	TRNN B,ST.BO		;NO. BATCH ONLY ONES ALLOWED?
	SKIPA			;NO
	JRST BOMES		;YES. TELL HIM BATCH ONLY

PPNGO:	MOVE N,[XWD SYSKTM,NSPTBL]	;FIND OUT IF SYSTEM IS DOWN
	CALLI N,CI.GET		;GET TAB
	 SETZ N,
	JUMPE N,PPNGO1		;OK TO GO
	JUMPG	N,PPNGO3	;JUMP IF SYSTEM GOING DOWN SOON
	TLNN	C,TT.CTY	;ALREADY DOWN, ALLOW LOGIN IF CTY OR SUB OF CTY
	TLNE	F,L.OPR!L.SOPR	; OR OPR OR SUB OF OPR OR 1,2
	JRST	PPNGO1		;OK
	JRST	NOTAVL		;ELSE NOT AVAILABLE
PPNGO3:	CAIL N,^D24*^D60	;OVER A DAY TO GO?
	JRST PPNGO1		;YES. DONT WARN HIM.
	MOVEI M,[ASCIZ .Timesharing will cease in .]
	PUSHJ P,MSG
	IDIVI N,^D60
	PUSH P,N1		;SAVE MINUTES
	JUMPE N,PPNGO2		;SEE IF HOURS NONZERO
	PUSHJ P,DECPRT		;YES. PRINT HOURS
	MOVEI M,[ASCIZ . hours .]
	PUSHJ P,MSG
PPNGO2:	POP P,N			;RESTORE MINUTES
	PUSHJ P,DECPRT
	MOVEI M,[ASCIZ \ minutes.
\]
	PUSHJ P,MSG
;FALL INTO PPNGO1
;HERE TO BEGIN CHECKING PPN

PPNGO1:

;HERE TO COMPUTE BIT IN TIMES WORD TO CHECK

LOGIN1:	TLZ	F,FL.MSG+FL.WKD+FL.RAS		;TRY AGAIN ENTRY
	MOVE	A,DATE		;TODAY'S
	IDIVI	A,^D31*^D12	;YEAR TO A
	IDIVI	B,^D31		;MO TO B, DAY TO C
	MOVEI	N,4(C)		;01-JAN-64 WAS A WEDNESDAY
	MOVE	BP,[XWD 440300,[EXP 033614625035]]
	MOVE	D,B		;COPY MONTH
	ILDB	C,BP		;GET OFFSET
	SOJGE	D,.-1		;FOR RIGHT MONTH
	ADDM	C,N		;PUT IN DAY
	TRNE	A,3		;LEAP YEAR?
	AOJA	N,.+3		;NO
	CAILE	B,1		;JAN OR FEB?
	AOS	N		;NO.
	ADDM	A,N		;PLUS YEAR
	ASH	A,-2		;PLUS LEAP YEARS
	ADDM	A,N		; ..
	IDIVI	N,7		;DAYS PER WEEK
	CAILE	N1,1		;SAT OR SUN?
	TLO	F,FL.WKD	;NO. WEEKDAY.
	MOVEM	N1,SAVEDA	;SAVE DAY OF WEEK
	CALLI	A,CI.MST
	IDIV	A,[EXP ^D1000*^D60*^D60]
	MOVSI	B,400000	;MAKE A BIT FOR THE CURRENT HOUR
	TLNN	F,FL.WKD	;WEEKDAY?
	MOVEI	B,4000		;NO. USE LOW 12 BITS
	TLNN	F,FL.WKD	;WEEKDAY?
	ASH	A,-1		;NO. USE TWO-HOUR SHIFTS
	MOVNS	A
	LSH	B,0(A)		;PUT BIT IN TUNE WITH TIME
	MOVEM	B,NOWBIT	;SAVE.
;HERE TO GET PPN

	SETZM	RDHED		;FOR THE DUMP IO
	MOVEI	CH,"#"		;CUE THE NUMBER
	TLNE	F,FL.BRK	;IF NO BREAK CHAR YET,JUST KEEP READING
	PUSHJ	P,ECHOON	;TURN ON ECHOING
	PUSHJ	P,OCTIN		;FIRST THING IS OCTAL NUMBER
	CAIN	CH,"/"		;SLASH BREAK?
	TLOA	F,FL.MSG	;YES. MARK NO MESSAGE
	CAIN	CH,","		;ORDINARY COMMA BREAK?
	JRST	.+2		;SOME GOOD BREAK
	JRST	PPERR		;NO GOOD. COMPLAIN
	JUMPE	N,PPERR		;ALSO CANT BE 0
	CAILE	N,-1		;ALSO ONLY 6 DIGITS
	JRST	PPERR
	HRLZ	PP,N		;PUT IN AC PP
	TLO	F,FL.WLD	;LIGHT *=-2 BIT
	PUSHJ	P,OCTIN		;GET PROGRAMMER NUMBER
	SETSTS	TTY,200		;TURN OFF ECHOING
	CAIE	CH,ALTMOD	;BREAK CHAR ALTMODE?
	CAIG	CH,CR		;OR OTHER GOOD BREAK CHAR?
	JUMPN	N,.+2		;YES, IS NUMBER THERE?
	JRST	PPERR		;NO.
	CAILE	N,-1		;..
	JRST	PPERR		;NO GOOD.
	HRR	PP,N		;MAKE AN XWD
	MOVEM	PP,PPN		;SAVE AS ARGUMENT FOR CALLI

;INSERT HERE CODE TO HANDLE PATH DEFINITION AND LOGIN SWITCHES

ATTCHK:	MOVSI	A,ST.NSC
	TDNN	A,STATES	;SKIP IF NEW SCANNER SERVICE
	TLNE	PP,-2		;SKIP IF  PROJ 1
	JRST	CHECKS		;NOT PROJ 1, GO AHEAD
	MOVSI	A,TT.PTY
	TDNE	A,TTBITS	;DONT ALLOW PROJ 1 ON PTY
	JRST	NOREMT		;IN OLD SCANNER
CHECKS:	CAME	PP,SYSPPN	;SYSPPN CAN ALWAYS LOGIN
	CAME	PP,MFDPPN	;BUT IF MFDPPN IS NOT SYSPPN,
	JRST	STACCT
	JRST	NOMFDP		;DONT ALLOW MFDPPN
SUBTTL SEARCH ACCT.SYS

;HERE TO SEARCH ACCT.SYS FOR USER'S ENTRY

STACCT:	MOVE	A,[SIXBIT /ACCT/]	;LOOK FOR THE SYSTEM FILE
	MOVSI	B,(SIXBIT /SYS/)	;..
	SETZB	C,ENTRY		;CLEAR ENTRY IN CASE NO ACCT.SYS
	MOVE	D,[XWD ENTRY,ENTRY+1]
	BLT	D,ENTRY+MAXENT-1
	MOVE	D,SYSPPN	;WHERE THE ACCT FILE IS
	LOOKUP	UFD,A		;TRY TO READ IT
	  JRST	NOSYS		;CANT. GO DIE.
STACC1:	HLRE	A,D		;SAVE LENGTH OF ACCT.SYS
	JUMPGE	A,.+3		;BLOCKS IF POSITIVE
	SUBI	A,^D127		;COUNT 1 FOR LAST PARTIAL BLOCK
	IDIV	A,[-^D128]	;CONVERT TO BLOCKS IF WORDS
	MOVEM	A,ACCTLN	;ALWAYS SAVE BLOCKS
	SETZM	ACCKNT		;CLEAR COUNT OF READS ON ACCT.SYS
	TLO	F,FL.ACC	;SET FLAG TO NOTE READING ACCT.SYS

;HERE TO FIND DIRECTORY OF ACCT.SYS, IF ANY,
;	AND BUILD IT IN THE HI SEGMENT IF NONE.
IFN	FASTLG,<
	SKIPE	DACCFL		;IF TABLE NOT BUILT
	CAME	A,DACCL		;OR LENGTHS DIFFER
	JRST	REBILD		;BUILD TABLE IMMEDIATELY
	PUSHJ	P,SNOOZE	;ELSE SLEEP
	JRST	LUKUPP		;UNTIL TABLE FINISHED
				;OR WE GET IMPATIENT
REBILD:	SETZB	A,RDHED		;FORCE NEXT READ TO INPUT
	CALLI	A,CI.SWP	;WRITE-ENABLE HIGH SEGEMENT
	  JFCL			;DON'T REALLY KNOW WHAT TO DO IF IT FAILS
	MOVEM	A,SVPROT	;SAVE OLD PROTECTION
	SETOM	DACCFL		;INDICATE BUILD-IN-PROGRESS
	AOSG	DLOCK		;CHECK LOCK
	JRST	BDACCT		;GO BUILD TABLE
	PUSHJ	P,SNOOZE	;IN-PROGRESS, WAIT AWHILE
	JRST	RSPROT		;GOT BUILT WHILE WE WAITED
				;FALL OUT HERE IF NO ACTION IN 10 SECS
BDACCT:	MOVE	A,ACCTLN	;LENGTH OF ACCT.SYS
	MOVEM	A,DACCL		;SAVE IN HI-SEG
	ADDI	A,DACC(A)	;HIGHEST ADDRESS WE NEED
	HRRZ	WD,.JBHRL	;HIGHEST WE GOT
	CAMG	A,WD		;DO WE HAVE ENUF?
	JRST	COREOK		;SURE
	HRLZS	A		;NO, SETUP TO GET MORE
	CALLI	A,CI.COR	;GET ENUF CORE FOR TABLES
	  JRST	NOSYS		;FATAL ERROR-INSUFFICIENT CORE
COREOK:	PUSHJ	P,RDUFD		;GET FORMAT WORD
	  JRST	NOSYS		;WHA???
	HRRZM	WD,ENTSIZ	;SAVE SIZE OF ENTRIES IN ACCT.SYS
	HLRZS	WD		;GET FORMAT IN RIGHT
	CAIE	WD,ACCFOR	;BETTER BE OURS
	JRST	BADFOR		;BAD NEWS
	MOVEI	A,200		;BLOCK LENGTH
	IDIV	A,ENTSIZ	;OVER ENTRY SIZE IS ENTRIES PER BLOCK
				;B GETS REMAINDER
	SETZ	A,
	MOVEI	C,1		;FIRST WORD OF BLOCK IS ALREADY USED
NXTABC:	MOVE	PP,UFDBUF(C)	;GET FIRST PPN OF THIS BLOCK
	MOVEM	PP,DACC(A)	;STORE IN TABLE
	SUB	C,B		;POINT TO FIRST PPN IN NEXT BLOCK
	JUMPGE	C,.+2		;DON'T LET IT GO NEGATIVE
	ADD	C,ENTSIZ	;KEEP RESULT MODULO ENTSIZE
	SETZM	RDHED		;FORCE A READ
	PUSHJ	P,RDUFD
	  JRST	.+2		;ALL DONE-EOF
	AOJA	A,NXTABC	;LOOK FOR PPN IN THIS BLOCK
	SETZB	A,DAUXFL	;FORCE REBUILD OF AUX TABLE
	HRLOM	A,DACCFL	;SET TABLE-FINISHED SW
	SETOM	DLOCK		;UNLOCK THE CODE
RSPROT:	MOVE	A,SVPROT	;REGET OLD PROTECTION
	CALLI	A,CI.SWP	;WRITE PROTECT IF IT WAS BEFORE
	  JFCL			;DON'T BE SILLY
;HERE TO FIND USER'S PPN IN TABLE

LUKUPP:	MOVE	PP,PPN		;GET USER'S PPN
	MOVN	A,DACCL		;LENGTH OF TABLE
	HRLZS	A		;FOR AOBJN LOOP
	CAML	PP,DACC(A)	;SCAN FOR HIGHER PPN
	AOBJN	A,.-1		;CONTINUE SEARCH IF NOT
	HRRZS	A		;DISCARD COUNTER IN A LEFT
	SOJL	A,PPERR1	;BEWARE THE RIDICULOUS
	HRRZM	A,ACCKNT	;SET POINTER INTO ACCT.SYS
	USETI	UFD,1(A)	;SETUP FOR DESIRED BLOCK

;	FIND THE ADDRESS OF THE FIRST PPN IN THIS BLOCK

	MOVE	D,ENTSIZ	;JUST TO HAVE IT THERE
	HRRZ	B,A		;COPY BLOCK COUNT
	ASH	B,7		;TIMES 200 (BLOCK LENGTH)
	IDIV	B,D
	MOVN	B,C		;NEGATIVE REMAINDER
	AOJGE	B,.+2		;ALLOW ONE FOR FORMAT WORD
	ADD	B,D		;GET POINTER INTO BLOCK
	MOVNI	C,177(D)	;-(BLOCK LEN + ENTSIZ - 1)
	IDIV	C,D		;C GETS -(NO OF ENTRIES/BLOCK)
	SETZM	RDHED		;FORCE A READ
	PUSHJ	P,RDUFD		;GET THE RIGHT BLOCK
	  JRST	PPERR1		;I HOPE IT'S HIS FAULT
	MOVE	WD,UFDBUF(B)	;GET FIRST PPN OF BLOCK
	CAME	WD,DACC(A)	;CHECK TABLE ACCURACY
	JRST	BADTAB		;IT LIED--REBUILD IT
	HRLI	B,-200(B)	;REMAINING COUNT IN BLOCK
	HRRI	B,UFDBUF-1(B)	;MAKES IOWD FOR FIRST PPN OF BLOCK
	MOVEM	B,RDHED		;THAT ENABLES USE OF RDUFD, WHICH
				;MASKS BLOCK BOUNDARIES
>;*** END OF CONDITIONAL ON FASTLG
;HERE TO FIND USER'S ENTRY (IF ANY)

RDACCT:	MOVN	A,ENTSIZ	;GET SIZE AS A COUNT
	HRLZS	A		;FOR AOBJN
RDACT1:	PUSHJ	P,RDUFD		;GET A WORD
	  JRST	PPERR1		;GOT TO EOF
	MOVEM	WD,ENTRY(A)	;STORE IN TEMP BLOCK
	AOBJN	A,RDACT1	;GET REST OF ENTRY
	MOVE	A,ENTRY+PPWRD	;CHECK FOR THE PPN
	HLRZ	B,A		;PROJ. IN FILE
	HLRZ	D,PPN		;PROJ SUPPLIED
	CAMLE	B,D		;PASSED IT YET?
	JRST	PPERR1		;YES. NOT THERE.
	CAMN	A,PPN		;IS THIS IT?
	JRST	PPNHIT		;YES. LOOK AT ENTRY
	CAME	B,D		;SAME PROJECT
	JRST	NXTPP		;NO. DON'T LOOK FOR #
	MOVE	WD,PPN		;PICK UP PPN
	TRNN	WD,1B18		;WILD ENTRY?
	JRST	NXTPP		;NO. GO ON.
	HRRZI	A,(A)		;COPY PROG NBR.
	CAIN	A,UNIPRG	;MATCH WILD NO
	JRST	PPNHIT		;YES. LOOK AT ENTRY
IFE	FASTLG,<
	JRST	RDACCT		;GO FOR NEXT
NXTPP==	RDACCT	>
IFN	FASTLG,<
NXTPP:	AOJL	C,RDACCT	;MORE IN THIS BLOCK?

;	WE HAVE NOW READ AN ENTIRE BLOCK WITHOUT FINDING THIS PPN
;	EITHER THE TABLE WAS INCORRECT, OR PPN DOESN'T EXIST
;	ACCKNT HAS BEEN INCREMENTED AT LEAST ONCE SINCE STORING
;	AND TWICE IF WE HAVE READ INTO NEXT BLOCK

	MOVE	A,ACCKNT	;GET TABLE POINTER
	MOVE	A,DACC-1(A)	;GET FIRST PPN THIS BLOCK
	CAMN	A,ENTRY+PPWRD
	JRST	PPERR1		;IF MATCH, TABLE IS OK, SO PPN IS BAD
	PUSHJ	P,RDUFD		;HOWEVER, OUR ESTIMATE OF ENTRIES/BLOCK
	  JRST	PPERR1		;  MAY BE OFF BY 1, SO CHECK THE NEXT
	MOVE	A,ACCKNT	;READ MAY HAVE INCREMENTED BLOCK NO
	CAMN	WD,DACC-1(A)	;IS TABLE CORRECT FOR THIS BLOCK?
	JRST	PPERR1		;PPN IS WRONG
BADTAB:	USETI	UFD,1		;PREPARE TO SCAN ENTIRE FILE
	JRST	REBILD		;AND BUILD A NEW TABLE
>;*** END OF CONDITIONAL ON FASTLG


SUBTTL CHECK ACCT.SYS ENTRY
;HERE TO DECIDE IF USER MAY LOGIN

PPNHIT:	HLRZ	A,ENTRY+XPDWRD	;GET EXPIRATION DATE OF PPN
	CAMGE	A,DATE		;SKIP IF DATE GE TODAY
	JRST	EXPPPN		;NO, PPN HAS EXPIRED
	MOVE	C,ENTRY+PROWRD
	MOVE	A,TTBITS
	TLNN	A,TT.PTY	;SKIP IF PTY
	JRST	ASKLOK		;SEE IF MAY LOGIN AT THIS TERMINAL
	TLNE	F,FL.BSJ	;SKIP IF NOT BATCH JOB SUBJOB
	TRNE	C,P.LGBS	;SKIP IF MAY NOT LOGIN AS SUBJOB
	JRST	.+2		;OK
	JRST	NOLGTS
	MOVE	B,CNTLJP	;CONTROL JOB PPN
	CAME	B,ALPPPN	;OK IF RUN BY JOB WITH ALL PRIVILEGES
	CAMN	B,PPN		;OK IF RUN BY SAME PPN
	TLNE	F,FL.BRK	;BUT ONLY IF TYPED ON SAME LINE
	JRST	.+2		;BECAUSE OF OLD BATCHES
	JRST	PSWOK
	MOVE	A,CNTLJT	;GET LINE BITS FOR CONTROL JOB
ASKLOK:	TLNE	F,L.OPR!L.SOPR	;OK IF OPR OR SUB OF OPR OR 1,2
	JRST	LOGOK
	MOVEI	B,P.LGLC	;LOCAL BIT
	TLNE	A,TT.RM		;SKIP IF NOT REMOTE HARDWIRED TTY
	MOVEI	B,P.LGRM	;REMOTE BIT
	TLNE	A,TT.DS		;SKIP IF NOT DATA SET TTY
	MOVEI	B,P.LGDS
	TLNE	A,TT.RO		;SKIP IF NOT REMOTE CTY OR OPR
	MOVEI	B,P.LGRO
	TDNN	B,C		;SKIP IF MAY LOGIN AT THIS TERMINAL
	JRST	NOLGTS
LOGOK:	TRNN	C,P.PWTS	;SKIP IF PASSWORD REQUIRED
	JRST	PSWOK		;NO, DONT ASK
	TRNN	C,P.NMTS	;SKIP IF NAME REQUIRED
	JRST	GETCOD		;NO, GET PASSWORD

;HERE TO GET NAME

	TLO	F,FL.NMC
	MOVEI	M,[ASCIZ .Name: .]
	PUSHJ	P,MSG
	PUSHJ	P,GET2WD	;GET NAME
	MOVEM	A,NAME
	MOVEM	B,NAME2
;HERE TO GET PASSWORD

GETCOD:	PUSHJ	P,CODGET
	PUSHJ	P,CRLF
	MOVEM	A,CODE		;SAVE THE PASSWORD TO INCLUDE IN FACT FILE
	MOVEI	B,(BP)
	CAIL	B,B
	JRST	TRYAGN		;TRY AGAIN IF MORE THAN 6 CHARS
	TLNN	F,FL.NMC	;NAME CHECK IN ORDER?
	JRST	NAMEOK
	MOVE	A,ENTRY+NM1WRD	;YES. CHECK THE NAME.
	MOVE	B,ENTRY+NM2WRD
	CAMN	A,NAME		;..
	CAME	B,NAME2		;SECOND HALF
	JRST	BADNAM
NAMEOK:
CHECK0:	MOVE	A,ENTRY+CODWRD	;RIGHT CODE?
	CAME	A,CODE		;..
	JRST	TRYAGN		;NO. HE LOSES.
SUBTTL SET UP DISK UFDS

;HERE IF ALL TYPEINS NEEDED TO LOGIN ARE VALIDATED

PSWOK:	TLNE	F,FL.FDX	;SKIP IF HALF DUPLEX
	SETSTS	TTY,0
	OUTPUT	TTY,		;CLEMENTS SAYS THIS WILL BRING BACK ECHOING
	TLNE	F,FL.ATT	;ENOUGH IF ATTACH
	JRST	ACCT		;DONT NEED TO SET UP UFD'S, ETC.
	MOVE	A,ENTRY+PRVWRD	;AND PRIV WD
	MOVEM	A,PRIVWD
	MOVE	A,ENTRY+NM1WRD
	MOVEM	A,NAME
	MOVE	A,ENTRY+NM2WRD
	MOVEM	A,NAME2
	MOVE	A,ENTRY+CRGWRD
	MOVEM	A,CHGNO		;CHARGE NUMBER
	CLOSE	UFD,0		;NOW CLEAR SOME IO
	SETZB	C,RDHED		;..
	TLNE	F,L.OPR!L.SOPR	;SKIP IF NOT OPR OR SON OF OPR
	JRST	CHECK2		;DONT DO THESE CHECKS FOR CTY OR OPR
	HLRZ	A,PPN		;WHO IS THIS AGAIN?
	MOVE	B,ENTRY+TIMWRD	;YES. USE THEM.
	TDNN	B,NOWBIT	;IS IT TIME FOR THIS GUY?
	JRST	NOPRIM		;NO. HE LOSES.
CHECK2:
IFN LEVDSW,<
	MOVEI	A,.FSDSL	;FUNCTION TO DEFINE SEARCH LIST
	SETOB	B,C		;USE OUR JOB, PPN
	MOVEI	D,1		;DELETE ALL
	MOVE	T,[XWD 4,A]
	STRUUO	T,		;DEFINE EMPTY SEARCH LIST
	  JFCL
>	;END CONDITIONAL ON LEVDSW

	CALLI	A,CI.MST	;GET THE TIME
	TRZ	A,7B20		;CLEAR A DIGIT
	TRO	A,1B18		;SET FIRST DIGIT TO 4
	TLNE	F,FL.WLD	;WILD CARD?
	HRRM	A,PPN		;YES--STORE FUNNY PPN
	MOVE	A,PPN		;PPN
	CALLI	A,CI.CPN	;CHANGE TO OUR PPN NOW
	  JRST	NOTHER		;NOT IMPLEMENTED
	GETPPN	A,		;DONT CARE ABOUT OTHER USERS,
	  JRST	NOTHER		;BUT WOULD TELL IF OTHERS SAME PPN
	MOVEI	M,[ASCIZ .Other jobs same PPN
.]
	PUSHJ	P,MSG
NOTHER:

IFN CDSW,<TLNE	F,FL.LVD>
IFN LEVDSW,<JRST CHECK1		;LOG HIM IN.>
IFN LEVCSW,<
CUFRTR:	MOVEI	T,FBMTRY	;TIMES TO RETRY IF ENTER FAILS
CUFRT1:	MOVE	A,PPN
	MOVSI	B,(SIXBIT .UFD.)
	MOVE	D,MFDPPN
	LOOKUP	UFD,A		;SEE IF UFD EXISTS
	  JRST	CNOUFD
	JRST	CWILD		;THERE SEE IF WILD
CNOUFD:	TRNE	B,-1		;SKIP IF NO UFD
	JRST	CUFLKE		;SOME OTHER ERROR
	HLLZS	B		;CLEAR ERROR CODE, ETC
	PUSHJ	P,SETPAK	;OPEN THE DISK PACK WITH THE MOST ROOM
	MOVEI	C,0		;CURRENT DATE AND TIME
	MOVE	D,MFDPPN
	ENTER	UFD,A		;TRY TO MAKE A UFD FOR USER
	  JRST	CUFENE
	SETZB	B,ZERO
	MOVE	A,[IOWD 1,ZERO]
	OUTPUT	UFD,A
	CLOSE	UFD,0		;AN EMPTY UFD
	STATO	UFD,740000	;ERRORS?
	JRST	ACCT		;NO.
	GETSTS	UFD,N
	MOVEI	M,[ASCIZ /UFD OUTPUT failure /]
	JRST	CCNTMK

CUFENE:	MOVEI	M,[ASCIZ /UFD ENTER failure /]
	HRRZS	B		;B=ENTER ERROR CODE
	CAIN	B,3		;SKIP IF NOT FILE BEING MODIFIED
	SOJG	T,CUFSLP	;YES, KEEP TRYING FOR A WHILE
	JRST	CUFLK1		;GIVE UP
CUFLKE:	MOVEI	M,[ASCIZ /UFD LOOKUP failure /]
CUFLK1:	HRRZ	N,B
CCNTMK:	MOVEI	N1,ERR.NF	;NON FATAL ERROR (1)
	PUSHJ	P,ERRLIN
	PUSHJ	P,OCTPRT	;TYPE ERROR CODE
	PUSHJ	P,CRLF
	JRST	ACCT

CUFSLP:	MOVEI	A,1
	CALLI	A,SLEEP		;SLEEP FOR ONE SECOND AND RETRY
	JRST	CUFRT1

CWILD:	TLNN	F,FL.WLD	;WILD?
	JRST	ACCT		;NO--WIN
	AOS	PPN		;BUMP PPN
	JRST	CUFRT1		;TRY AGAIN
>	;END CONDITIONAL ON LEVCSW
CHECK1:
IFN LEVDSW,<
	MOVE	A,[SIXBIT .AUXACC.]
	MOVSI	B,(SIXBIT .SYS.)
	SETZB	C,RDHED
	MOVE	D,SYSPPN
	LOOKUP	UFD,A		;LOOK FOR AUXACC.SYS
	  JRST	NOAUXA		;NOPE
	TLZ	F,FL.ACC	;NOTE READING AUXACC.SYS NOW
IFN	FASTLG,<
	SKIPE	DAUXFL		;MUST WE BUILD AUX TABLE?
	JRST	LUKAUX		;NO>
	PUSHJ	P,RDUFD		;READ 1ST WORD, CONTAINS FORMAT VERSION NUMBER
	  JRST	NOAUXA		;NOT THERE?
	HLRZS	WD		;WD=FORMAT VERSION NUMBER
	CAIE	WD,AC1FOR
	JRST	BADFRA		;WRONG TYPE
IFE	FASTLG,<
	HLRE	A,D
	JUMPGE	A,.+2		;IF +, NO OF BLOCKS, ELSE WORDS
	IDIV	A,[-^D128]	;APPROXIMATION OF POSITION IN FILE BASED
	IMUL	A,ACCKNT	;ON POSITION OF USER IN ACCT.SYS
	IDIV	A,ACCTLN	;BLOCKS READ IN ACCT*LENGTH AUXACC/LENGTH ACCT
	SKIPN	A
	MOVEI	A,1		;A MUST BE AT LEAST 1
	CAIN	A,1
	JRST	ACC1A
	SETZM	RDHED		;IF NOT 1ST BLOCK, FORCE NEW INPUT
>;** END OF ZERO COND ON FASTLG
IFN	FASTLG,<
	SETZ	A,		;PREPARE TO WRITE ENABLE
	CALLI	A,CI.SWP	;WR-ENABLE HI SEG
	  JFCL			;WHAT CAN YOU DO?
	MOVEM	A,SVPROT	;HANG ON TO OLD PROT CODE
	MOVE	A,ACCKNT	;ACCT.SYS POSITIION
	MOVEM	A,SAVKNT	;PROTECT TEMPORARILY
	SETZM	ACCKNT
	TLO	F,FL.ACC	;LIES: IT ENABLES COUNTING ON AUXACC
	MOVN	A,DACCL		;LENGTH OF ACCT.SYS
	HRLZS	A		;FOR AOBJN
	MOVEI	B,DACC		;SETUP POINTER
	ADD	B,DACCL		;FOR AUX TABLE
	HRLI	B,A		;INDIRECT POINTER TO DACC+DACCL 
				;INDEXED BY A
AUXSCN:	PUSHJ	P,RDUFD
	  JRST	AUXEND		;END OF FILE
	AOJN	WD,AUXSCN	;SCAN FOR -1 (BEGIN OF ENTRY FLAG)
	PUSHJ	P,RDUFD		;GET AND IGNORE ENTRY LENGTH
	  JRST	AUXEND
	PUSHJ	P,RDUFD		;GET PPN
	  JRST	AUXEND
	CAMGE	WD,DACC(A)	;IS THIS PPN .GE. THAT IN DACC TABLE?
	JRST	AUXSCN		;NO, GO GET NEXT
	MOVE	WD,ACCKNT	;PICK UP CURRENT BLOCK NO
	MOVEM	WD,@B		;STORE IN FREE TABLE LOCATION
	AOBJN	A,AUXSCN	;GO FOR MORE IF ROOM
AUXDUN:	TLZ	F,FL.ACC	;DISABLE BLOCK COUNTING
	MOVE	A,SAVKNT	;GET POINTER INTO ACCT.SYS
	MOVEM	A,ACCKNT	;RESTORE COUNTER
	SETOM	DAUXFL		;INDICATE TABLE OK
	MOVE	A,SVPROT	;PICK UP OLD PROTECTION
	CALLI	A,CI.SWP	;RESTORE
	  JFCL
LUKAUX:	MOVE	A,ACCKNT	;WHERE WERE WE IN ACCT.SYS?
	ADD	A,DACCL		;CORRECT ADDRESS IN AUX TABLE
	MOVE	A,DACC(A)	;PICK UP AUX BLOCK
	AOJLE	A,.		;SHOULDN'T NEVAH BE NEG
>;*** END OF CONDITIONAL ON FASTLG

ACC1E:	USETI	UFD,(A)
	SETZM	RDHED	;FORCE READ OF THAT BLOCK
ACC1A:	PUSHJ	P,RDUFD		;NOW TRY TO FIND START OF ENTRY
	  JRST	BACKUP		;TOO FAR, BACK UP 1
	AOJN	WD,ACC1A	;ALL ONES (-1) STARTS ENTRY
	PUSHJ	P,RDUFD		;READ LENGTH OF ENTRY
	  JRST	BACKUP
	MOVNI	CALC,-1(WD)
	PUSHJ	P,RDUFD		;READ PPN
	  JRST	BACKUP
	CAMLE	WD,PPN		;PASSED USER?
	JRST	BACKUP		;YES, BACK UP 1 BLOCK
ACC1F:	CAME	WD,PPN		;THIS USER?
	JRST	SKACC1		;NO, READ FORWARD TO FIND HIM
ACC1G:	JUMPGE	CALC,NOSTR	;JUMP IF NO STR'S FOR THIS USER
	IDIVI	CALC,AC1BLK	;DIVIDE BY SIZE OF EACH BLOCK IN ENTRY
	TRZ	F,R.ACRE!R.ASTR	;CLEAR ANY CREATE AND ANY STR FLAGS
ACC1B:	PUSHJ	P,RDUFD		;READ NEXT FILE STRUCTURE NAME
	  JRST	ACC1J
	MOVE	M,WD		;M=STR NAME FOR UFDSET
	PUSHJ	P,RDUFD		;RESERVED QUOTA
	  JRST	ACC1J
	MOVE	B,WD		;B=RESERVED QUOTA FOR UFDSET
	PUSHJ	P,RDUFD		;FIRST COME, FIRST SERVED QUOTA
	  JRST	ACC1J
	MOVE	C,WD		;C=FCFS QUOTA FOR UFDSET
	PUSHJ	P,RDUFD		;LOGGED-OUT QUOTA
	  JRST	ACC1J
	MOVE	D,WD		;D=LOGGED OUT QUOTA FOR UFDSET
	PUSHJ	P,RDUFD		;BITS ABOUT FILE STRUCTURE
	  JRST	ACC1J
	MOVE	A,[XWD 1,M]
	DSKCHR	A,		;SEE IF STR IS IN SYSTEM
	  JRST	ACC1H		;NO, DO NOT PUT IN SEARCH LIST
	TLNE	A,(.UPSAF)	;SKIP IF NOT SINGLE ACCESS
	JRST	ACC1H		;CANT BE FOR US YET SO DONT INCLUDE THIS STR
	TLZ	F,L.WRTL+L.NCR
	TLNE	WD,S.SWL	;SKIP IF NOT READ ONLY
	TLO	F,L.WRTL
	TLNE	WD,S.NCR	;NO SKIP IF NO CREATE
	TLO	F,L.NCR
	TLNN	F,L.WRTL!L.NCR	;CAN WE CREATE ON THIS STR
	TRO	F,R.ACRE	;YES-INDICATE CREATION POSSIBLE
	MOVEI	IO,TYO		;ADDR OF OUTPUT ROUTINE
	MOVE	N1,MFDPPN
	MOVE	A,PPN
	PUSHJ	P,UFDSET	;SET UP UFD FOR USER ON THIS STR
	  JRST	.+2		;DIDN'T MAKE IT
	TRO	F,R.ASTR	;DID-SET SOME-STR FLAG
	MOVSI	A,RIPBDA+RIPBFA+RIPCRH+RIPHRE+RIPHWE+RIPSCE
	TDNN	A,SRCBUF+EXLSTS ;SKIP IF ERRORS
	JRST	ACC1H		;NONE TODAY THANK YOU
	MOVE	M,UFDFSN	;NAME OF FILE STRUCTURE
	PUSHJ	P,SIXMSG	;TYPE IT
	MOVEI	M,[ASCIZ . file errors exist
.]
	PUSHJ	P,MSG
ACC1H:	AOJL	CALC,ACC1B	;LOOP FOR ALL STRS IN ENTRY
ACC1K:	TRZN	F,R.ASTR	;ARE ANY STR'S DEFINED IN SEARCH LIST?
	JRST	NOSTR		;NO, WARN SO
	TRNE	F,R.ACRE	;ARE ANY CREATES ALLOWED?
	JRST	ACCT		;YES, ALL HAPPY
	MOVEI	M,[ASCIZ .% Search list does not allow creates
.]
	JRST	STRWRN		;ISSUE WARNING
NOSTR:	MOVEI	M,[ASCIZ .% Search list is empty
.]
	JRST	STRWRN

ACC1J:	MOVEI	M,[ASCIZ /Format or read error in AUXACC.SYS
/]
	PUSHJ	P,MSG		;SAY SO
	JRST	ACC1K		;AND GO LOOK FOR OTHER PROBLEMS

IFN	FASTLG,<
AUXEND:	MOVE	WD,ACCKNT	;AT END OF FILE, FORCE LAST BLOCK
	MOVEM	WD,@B
	JRST	AUXDUN		;AND PROCEED>
BACKUP:	SOJE	A,SKACC2	;BACK UP BLOCK COUNTER AND STOP READING IF BEGINNING
	JRST	ACC1E		;READ NEXT PREVIOUS BLOCK IN UFD

SKACC1:	PUSHJ	P,RDUFD		;SKIP FORWARD TO USER
	  JRST	NOINAU		;EOF - NOT THERE
	AOJN	WD,SKACC1	;SEARCH FOR -1 FLAG--START OF ENTRY
	PUSHJ	P,RDUFD		;READ NUMBER OF WORDS THAT FOLLOW
	  JRST	NOINAU
	MOVNI	CALC,-1(WD)	;-LENGTH - USED AT ACC1G
	PUSHJ	P,RDUFD		;READ PPN
	  JRST	NOINAU
	CAMG	WD,PPN		;PAST USER?
	JRST	ACC1F		;NO - KEEP LOOKING FOR HIM
SKACC2:	HLLO	C,PPN		;C=PROJ,-1=DEFAULT
	CAMLE	WD,C		;PAST DEFAULT?
	JRST	NOINAU		;YES - NOT THERE
	CAMN	WD,C		;AT DEFAULT?
	JRST	ACC1G		;YES - USE THIS
	HRLZ	B,PPN		;PROG NO TO B LEFT
	JUMPGE	B,ACC1F		;KEEP LOOKING UNLESS WILD PROG NO
	HRRI	C,UNIPRG	;COMPARE AGAINST WILD CARD
	CAME	WD,C		;ONE OF THOSE?
	JRST	ACC1F		;KEEP LOOKING
	JRST	ACC1G		;GOT IT

NOAUXA:	MOVEI	M,CNSYSF
	JRST	NOSLC
NOINAU:	MOVEI	M,[ASCIZ /No entry in AUXACC.SYS
/]
NOSLC:	MOVEI	N1,ERR.NF	;NON FATAL ERROR (1)
	PUSHJ	P,ERRLIN
	MOVEI	M,NOSLUF
STRWRN:	PUSHJ	P,MSG
;	JRST	ACCT		;FALL THROUGH TO ACCT
>	;END CONDITIONAL ON LEVDSW
SUBTTL WRITE FACT FILE ENTRY

ACCT:	RELEAS	UFD,0		;MAKE WAY FOR LATER IO

IFN FACTSW,<
	PUSHJ	P,ACCTA		;PUT IN ACCOUNTING DATA
	MOVE	CALC,FCTWD	;GET CONTROL WORD
	PUSHJ	P,APPEND	;STICK IT INTO FACT.SYS
	JRST	ACCT1		;GO ON

ACCTA:	CALLI	A,CI.GTT	;TTY LINE NAME
	JUMPN	A,ACCTA1	;JUMP IF HAVE A LINE (NOT DET)
	MOVNI	A,2		;DET BECOMES -2
	JRST	ACCTA4
ACCTA1:	HRLZ	D,A		;D=LINE NUMBER
	JUMPE	D,ACCTA3	;JUMP IF CTY
	MOVE	C,[POINT 6,D]
	SETZ	A,
ACCTA2:	ILDB	B,C		;GET NEXT CHAR OF LINE NUMBER
	JUMPE	B,ACCTA4	;JUMP IF NO MORE CHARS
	IMULI	A,10		;CONVERT TO BINARY
	ADDI	A,-20(B)	;FROM OCTAL SIXBIT
	JRST	ACCTA2
ACCTA3:	SETO	A,		;CTY BECOMES -1
ACCTA4:	LSH	A,6		;SHIFT LEFT 6 BITS
	ANDI	A,777700	;JUST 12 BITS
	TLNN	F,FL.ATT	;SKIP IF ATTACH, NOT IF LOGIN
	JRST	ACCTA5		;LOGIN
	IOR	A,FCTAHD	;ATTACH HEADER
	MOVE	B,ATTJOB	;TARGET JOB
	JRST	ACCTA6		;GO STORE THEM
ACCTA5:	IOR	A,FCTHED	;LOGIN HEADER
	MOVE	B,THSJOB	;GET JOB NUMBER
ACCTA6:	MOVEM	A,FCTDAT	;PUT IN ENTRY
	DPB	B,[POINT 9,FCTDAT,17]
	MOVE	A,PPN
	MOVEM	A,FCTDAT+1	;PROJ PROG NO. TO FACT ENTRY
	MOVE	A,DATE		;ALSO DATE AND TIME
	CALLI	B,CI.TIM	;TIME IN JIFFIES
	ROT	A,-14
	IOR	B,A
	MOVEM	B,FCTDAT+2	;DATE AND TIME.
	POPJ	P,		;RETURN TO WRITE IT
>
SUBTTL TYPE DATE, TIME, AND MESSAGE OF THE DAY

ACCT1:	CALLI	CI.RES		;RECLAIM IO SPACE
	INIT	TTY,0		;GET THE TTY AGAIN
	SIXBIT /TTY/
	XWD	TOB,TIB
	JRST	LAST		;UNLIKELY, BUT...
	TLNE	F,FL.ATT		;SKIP IF LOGIN, NOT IF ATTACH
	JRST	LAST		;NEED NO MORE FOR ATTACH
	TLNN	F,FL.WLD	;WILD PPN
	JRST	ACCT2		;NO--HE KNOWS WHO HE IS
	MOVEI	M,[ASCIZ /You are logged in as /]
	PUSHJ	P,MSG
	HLRZ	N,PPN		;GET PROJECT
	PUSHJ	P,OCTPRT	;PRINT
	MOVEI	CH,","		;PRINT A ,
	PUSHJ	P,TYO		;DONE
	HRRZ	N,PPN		;GET PROGRAMMER
	PUSHJ	P,OCTPRT	;PRINT
	PUSHJ	P,CRLF		;ADD CRLF
ACCT2:	CALLI	A,CI.MST	;GET TIME OF DAY
	IDIVI	A,^D60000	;TO MINUTES
	IDIVI	A,^D60		;NOW BREAK IN MINS AND HRS
	MOVE	N,A		;HOURS
	PUSHJ	P,DECPR2
	MOVE	N,B		;MINUTES
	PUSHJ	P,DECPR2
	MOVEI	CH,11		;TAB
	PUSHJ	P,TYO
ACCT3:	MOVE	A,DATE
	IDIVI	A,^D31		;THE USUAL DATE PRINTER
	MOVEI	N,1(B)		;DAY OF MONTH
	PUSHJ	P,DECPR2
	IDIVI	A,^D12		;MONTH AND YEAR
	MOVE	B,MONTAB(B)
	MOVEM	B,DATEMP
	SETZM	DATEMP+1	;FOR ASCIZ, DDTOUT
	MOVEI	M,DATEMP
	PUSHJ	P,MSG
	MOVEI	N,^D64(A)	;YEAR
	PUSHJ	P,DECPR2
	MOVEI	CH,11
	PUSHJ	P,TYO
	MOVE	A,SAVEDA	;DAY OF WEEK
	MOVEI	M,WEEKDA(A)
	PUSHJ	P,MSG		;TYPE DAY OF WEEK
ACCT4:	PUSHJ	P,CRLF

ACCT5:	PUSHJ	P,DAYMES
	RELEASE	TTY,0
	JRST	LAST
SUBTTL I/O SUBROUTINES

;SUBROUTINE TO INPUT CHARS TO 1ST NON-ALPHANUMERIC
;VALUES	WD=SIXBIT CHARS
;	CH=TERMINATING CHAR
;	FL.BRK BIT IN LH F=1 IF TERMINATING CHAR IS A BREAK CHAR

GETCOM:	MOVE	BP,[POINT 6,WD]
	SETZ	WD,
	PUSHJ	P,SST
	JRST	.+2
GETCM1:	PUSHJ	P,TYI		;GET NEXT CHAR
	CAIL	CH,"0"		;SKIP IF NOT A NUMBER
	CAILE	CH,"9"		;SKIP IF A NUMBER
	JRST	.+2		;NOT A NUMBER
	JRST	GETCMS		;IT IS A NUMBER, STORE AND LOOP
	CAIL	CH,"A"		;SKIP IF NOT A LETTER
	CAILE	CH,"Z"		;SKIP IF A LETTER
	PJRST	ISBRK		;NOT NUMBER OR LETTER, GIVE UP
GETCMS:	SUBI	CH,40		;MAKE SIXBIT
	TLNE	BP,770000
	IDPB	CH,BP
	JRST	GETCM1

;SUBROUTINE TO INPUT CHARS TO 1ST NON-SIXBIT CHAR - SAVE 2 WORDS OF CHARS
;VALUES	A,B=SIXBIT CHARS
;	CH=TERMINATING CHAR
;	FL.BRK BIT IN LH F=1 IF TERMINATING CHAR IS A BREAK CHAR
;CALL AT GETNL1 WITH CH=CHAR IF 1ST CHAR ALREADY READ (MUST SETUP)

GET2WD:	SETZB	A,B
	MOVE	BP,[POINT 6,A]
GETNL:	PUSHJ	P,TYI		;GET NEXT CHAR
GETNL1:	CAIGE	CH,40		;SKIP IF SIXBIT CHAR
	PJRST	ISBRK		;NO, END OF THIS STRING
	SUBI	CH,40		;CONVERT TO SIXBIT
	CAME	BP,[XWD 600,B]
	IDPB	CH,BP
	JRST	GETNL

;SUBROUTINE TO SKIP SPACES PRECEEDING AN ARG
;VALUES	CH=FIRST NON-SPACE CHAR

SST:	PUSHJ	P,TYI		;GET NEXT CHAR
	CAILE	CH,40	;SKIP IF CHAR TO IGNORE
	POPJ	P,
	PUSHJ	P,ISBRK
	TLNE	F,FL.BRK
	POPJ	P,
	JRST	SST
;SUBROUTINE TO SET BIT FL.BRK IN LH F IF CHAR IN CH IS A BREAK CHAR
;ARGS	CH=ASCII CHARACTER
;VALUES	FL.BRK BIT IN LH F=1 IF CHAR IS A BREAK CHAR

ISBRK:	CAIN	CH,ALTMOD	;SKIP IF NOT ALTMODE
	JRST	ISBRKY		;ALTMODE IS A BREAK CHAR
	CAIL	CH,LF		;SKIP IF NOT BREAK
	CAILE	CH,FF		;SKIP IF BREAK (LF-FF)
	POPJ	P,
ISBRKY:	TLO	F,FL.BRK	;SET BREAK CHAR BIT
	POPJ	P,

;SUBROUTINE TO CREATE A MASK IN C FOR ACTUAL CHARS IN A
;ARGS	A=SIXBIT CHARS LEFT JUSTIFIED
;VALUES	C=MASK OF ALL ONES IN NON-ZERO CHAR POSITIONS

GETMSK:	SETZ	C,
	JUMPE	A,CPOPJ
	TLO	C,770000
	PUSH	P,A
GETMS1:	LSH	A,6
	JUMPE	A,APOPJ
	ASH	C,-6
	JRST	GETMS1
APOPJ:	POP	P,A
	POPJ	P,

;SUBROUTINE TO DETERMINE IF JOB NUMBER IN A IS A BATCH JOB
;ARGS	A=JOB NUMBER
;RETURN	CPOPJ IF JOB IS NOT BATCH
;	CPOPJ1 IF JOB IS BATCH

ISBATC:	HRLZ	D,A
	HRRI	D,PRJPRG	;SELECT TABLE OF PPN'S
	CALLI	D,CI.GET	;GET PPN FOR JOB
	  POPJ	P,		;GETTING NOWHERE
	MOVEM	D,CNTLJP	;SAVE CONTROL JOB PPN
	CAME	D,ALPPPN	;MUST HAVE ALL PRIVILEGES TO BE BATCH
	POPJ	P,
	HRLZ	D,A
	ADDI	D,JBTPRG
	CALLI	D,CI.GET	;GET NAME OF PROGRAM RUNNING
	  POPJ	P,		;JUST NOT MAKING IT
	CAME	D,[SIXBIT .BATCON.]
	POPJ	P,		;NOT BATCON IS NOT BATCH
	JRST	CPOPJ1
ECHOON:	SETSTS	TTY,0		;TURN ON ECHOING
	JRST	TYO

SPACE:	MOVEI	CH,40
TYO:	TLO	F,FL.TYO	;MARK NEED OUTPUT
	SOSG	TOB+2
	OUTPUT	TTY,0
	IDPB	CH,TOB+1
	CAIL	CH,15		;TIME FOR A BREAK?
	POPJ	P,0		;NO
	OUTPUT	TTY,0		;YES. FORCE OUT
	TLZ	F,FL.TYO	;DONT NEED IT NOW
	POPJ	P,0		;RETURN

TYI:	TLZE	F,FL.TYO	;WANT OUTPUT?
	OUTPUT	TTY,0		;YES.
TYI1:	SOSLE	TIB+2
	JRST	TYIOK
	INPUT	TTY,0
	STATZ	TTY,20000	;EOF?

	  JRST	INCNTC		;TREAT AS A CONTROL C
TYIOK:	ILDB	CH,TIB+1
	JUMPE	CH,TYI1		;FLUSH	NULLS
	CAIE	CH,177		;IGNORE RUBOUT
	CAIN	CH,CR		;CR?
	JRST	TYI1		;JUNK AND GET LF
	CAIL	CH,175		;SKIP IF NOT ALTMODE
	MOVEI	CH,ALTMOD
	CAIN	CH,CNTRLC	;CONTROL C?
	JRST	INCNTC		;YES, QUIT
	TLNE	F,FL.BRK	;IF LOGIN LINE, ALTMODE IS OK
	CAIE	CH,ALTMOD	;ALTMODE?
	JRST	TYIOK1
	MOVSI	CH,ST.NSC
	TDNN	CH,STATES	;SKIP IF NEW SCANNER SERVICE
	JRST	INCNTC		;OLD SCANNER SERVICE, ALTMODE IS CONTROL C
	MOVEI	CH,ALTMOD
TYIOK1:	CAIL	CH,140		;LOWER CASE?
	TRZ	CH,40		;MAKE IT UPPER.
	POPJ	P,0
SUBTTL ROUTINES TO APPEND TO FACT FILE
IFN FACTSW,<

;SUBROUTINE TO APPEND AN ENTRY TO A FILE IN THE ACCOUNTING SYSTEM.
; THIS ROUTINE FIRST ATTEMPTS TO APPEND TO THE FILE NAMED FACT.SYS, BUT IF THIS FILE
; IS UNAVAILABLE, THEN FILES NAMED FACT.X01, FACT.X02,..., FACT.X77 WILL BE ATTEMPTED
; IN THAT ORDER, AND AN ERROR MESSAGE PRINTED ONLY IF ALL SUCH FILES ARE UNAVAILABLE.
;
;CALLING SEQUENCE:
;		MOVE CALC,[XWD SIZE,ADDRESS] ;POINTER TO ENTRY TO BE APPENDED.
;		PUSHJ P,APPEND
;		RETURNS HERE IN ANY EVENT.
;

APPEND:	PUSH P,CALC		;SAVE POINTER TO ENTRY TO BE APPENDED.
IFN DAEMSW,<
	HLRE	B,CALC		;GET LENGTH IN B
	SOJ	CALC,		;BACK UP POINTER
	MOVMS	B		;POS LENGTH
	HRLI	CALC,1(B)	;LEN INCLUDING DAEMON FUN IN LEFT HALF
	MOVEI	B,D.FACT	;SPECIFY FACT FUNCTION
	MOVEM	B,0(CALC)	;IN DAEMON REQUEST BLOCK
	DAEMON	CALC,		;ASK DAEMON TO WRITE FACT FILE
	  JRST	.+2		;DAEMON NOT RUNNING, OR FAILED
	JRST	APPXIT		;MADE IT, TAKE THE EAXY WAY
>;*** END OF CONDITIONAL ON DAEMSW
	MOVEI B,(SIXBIT /SYS/)	;TRY FACT.SYS FIRST.
APPLUP:	PUSH P,B		;SAVE LAST EXTENSION TRIED.
APPLP1:	MOVSS B			;SET UP ACCUMULATORS FOR THE APPNDF
	MOVE CALC,-1(P)		; SUBROUTINE (WHICH DOES THE ACTUAL APPEND).
	PUSHJ P,APPNDF		;TRY TO APPEND ENTRY TO TRANSACTION FILE.
	JRST APPERR		;ERROR ON THAT TRANSACTION FILE--TRY NEXT.
	JRST APPBZY		;TRANSACTION FILE BUSY--TRY ANOTHER.
	POP P,B			;NORMAL EXIT--FILE SUCCESSFULLY UPDATED.
APPXIT:	POP P,CALC
	POPJ P,			;*** SUBROUTINE EXIT. ***

APPERR:	POP P,B			;NON-RECOVERABLE ERROR--TRY NEXT FILE.
	CAIN B,(SIXBIT /SYS/)	;WAS .SYS THE LAST EXTENSION ATTEMPTED?
	MOVEI B,(SIXBIT /X00/)	;YES, TRY .X01 NEXT.
APPERB:	CAIN B,(SIXBIT /X77/)	;NO, TRIED ALL 64 POSSIBLE FILES ?
	JRST APPLUZ		;YES, GIVE UP.
	ADDI B,1		;NO, TRY NEXT FILE IN SEQUENCE.
	TRNN B,7		;CARRY INTO SECOND DIGIT ?
	ADDI B,100-10		;YES, CAUSE SIXBIT CARRY.
	JRST APPLUP		;TRY AGAIN.

APPBZY:	POP P,B			;SPECIFIED FILE WAS BUSY--GET ITS EXTENSION.
	CAIE B,(SIXBIT /SYS/)	;WAS IT .SYS ?
	JRST APPERB		;NO, GO TRY NEXT FILE IN SEQUENCE.
	PUSHJ P,DELAYM		;YES, INFORM USER OF DELAY.
	PUSH P,[SIXBIT /   X00/] ;TRY .SYS TWICE JUST TO BE SURE.
	JRST APPLP1
DELAYM:	JSP M,MSG		;TELL USER TO BE PATIENT IF DELAY OCCURS.
	ASCIZ /Wait PLS....
/

APPLUZ:	MOVEI M,APPLZM		;IN THE UNLIKELY EVENT THAT ALL FACT FILES
	PUSHJ P,MSG		; ARE INACCESSIBLE, TELL USER TO GET HELP.
	JRST APPXIT
APPLZM:	ASCIZ /Accounting system failure....
Call the Operator.
/
;SUBROUTINE TO APPEND A TRANSACTION ENTRY TO THE END OF THE ACCOUNTING FILE
; (NORMALLY, THIS IS THE FILE NAMED FACT.SYS, BUT THE EXTENSION IS A PARAMETER
; SUPPLIED TO THIS SUBROUTINE SO THAT IF FACT.SYS BECOMES FOULED UP, AN ENTRY
; MAY BE APPENDED TO AN ALTERNATE FACT.XXX FILE.)

;CALLING SEQUENCE:
;	MOVSI B,(SIXBIT /EXT/)   ;DESIRED EXTENSION FOR FACT FILE (NORMALLY .SYS)
;	MOVE CALC,[XWD  -SIZE,ADDRESS]	;POINTER TO ENTRY TO BE APPENDED
;	PUSHJ P,APPNDF
;	NON-RECOVERABLE ERROR RETURN -- CAN'T APPEND TO FILE.
;	BUSY ERROR RETURN -- FILE HAS BEEN BUSY EVERY HALF-SECOND FOR TEN SECONDS.
;	NORMAL RETURN -- ENTRY HAS BEEN SUCCESSFULLY APPENDED TO THE FILE.

;THE FOLLOWING ACCUMULATORS ARE USED BY THIS SUBROUTINE (AND MAY BE CLOBBERED):
	A=1
	B=2
	C=3
	D=4
	CALC=6
	N=13
	P=17 	;PUSH-DOWN POINTER

;THE FOLLOWING SOFTWARE I/O CHANNEL IS USED:
	FCT=6

;**** CAUTION **** THIS NEXT PARAMETER MUST BE SET LARGE ENOUGH FOR THE PARTICULAR
;*****************  PROGRAM WHICH CALLS THIS APPNDF SUBROUTINE:
	TRANSZ=10   	;MAXIMUM SIZE OF TRANSACTION ENTRY TO BE APPENDED.

;THESE CALLI VALUES MUST BE DEFINED
	SLEEP=31


APPNDF:	MOVEM B,APPEXT		;SAVE REQUESTED EXTENSION FOR FILENAME FACT
	MOVEI N,^D20
	MOVEM N,TRYCTR		;SET NUMBER OF TIMES TO TRY IF BUSY.
	INIT FCT,17		;OPEN SOFTWARE I/O CHANNEL FOR FACT FILE
	SIXBIT /SYS/		; IN DUMP MODE.
	0
	JSP N,APPNDR		;IMMEDIATE ERROR RETURN IF CAN'T GET DEVICE SYS.

APPNDL:	MOVE A,[SIXBIT /FACT/]
	MOVE B,APPEXT
	MOVEI C,0
	MOVE D,FCTPP
	LOOKUP FCT,A		;ATTEMPT TO OPEN FACT FILE FOR READING.
	JRST APPNDN		;LOOK-UP FAILED--PERHAPS FILE DOESN'T EXIST.
	PUSHJ P,APPNDE		;ATTEMPT TO GRAB THE FACT FILE.
	HLRE N,D		;THE ENTER SUCCEEDED.  PICK UP LENGTH OF FILE.
	SKIPLE	N		;SKIP IF - WORDS
	IMUL	N,[-^D128]	;CONVERT BLOCKS TO - WORDS
	SETCA	N,		;NEGATE AND SUBTRACT ONE
	ROT N,-7
	ADDI N,1		;COMPUTE LAST BLOCK NUMBER WITHIN THE FACT FILE.
	HRRZM N,FCTBLK		;SAVE IT FOR USETI AND USETO.
	ROT N,7
	ANDI N,177		;N NOW HAS RELATIVE DEPTH (0-127) OF
	USETI FCT,@FCTBLK	; LAST WORD IN LAST BLOCK.
	MOVE	A,[IOWD 200,FCTBUF]
	MOVEM	A,ILIST	;SET UP IOLIST
	SETZM	ILIST+1
	INPUT FCT,ILIST		;READ LAST BLOCK OF FACT FILE INTO DUMP BUFFER.
	STATZ FCT,740000
	JSP N,APPNDR		;ERROR OR EOF WILL YIELD ERROR RETURN.

APPNDA:	MOVS A,FCTBUF(N)	;GET LAST WORD OF CURRENT FACT FILE.
	CAIN A,777000		;END-OF-FILE ENTRY ?
	JRST APPNDB		;YES, THINGS ARE LOOKING GOOD.
	SKIPN A			;NO, FACT FILE SCREWED UP!  IS LAST WORD NON-ZERO ?
	TRNN N,-1		;OR IS THIS THE FIRST WORD OF A 200-WORD BLOCK ?
	JSP N,APPNDR		;YES TO EITHER QUESTION. TAKE ERROR EXIT.
	SUB N,[XWD 1,1]		;TRY BACKING UP OVER ZERO WORDS ATTEMPTING TO FIND
	JRST APPNDA		; THE END-OF-FILE ENTRY.

APPNDB:	TLNN N,-1		;WAS END-OF-FILE ENTRY WHERE IT WAS SUPPOSED TO BE ?
	JRST APPNDC		;YES, PROCEED.
	MOVE A,[XWD 377000,1]	;NO, FILL WITH DUMMY ONE-WORD ENTRIES TO
	MOVEM A,FCTBUF(N)	; SHOW WHERE DATA LOSS MAY HAVE OCCURED.
	AOBJN N,.-1

APPNDC:	MOVE A,0(CALC)		;PICK UP ENTRY AS SPECIFIED IN CALLING SEQUENCE.
	MOVEM A,FCTBUF(N)	;STORE IN FACT FILE OUTPUT BUFFER.
	ADDI N,1
	AOBJN CALC,APPNDC
	MOVSI A,777000		;LAY DOWN END-OF-FILE ENTRY AGAIN.
	MOVEM A,FCTBUF(N)
	SETCA N,0		;(IN PLACE OF AOS N FOLLOWED BY MOVNS N)
	HRLM N,OLIST		;STORE CORRECT NUMBER OF WORDS TO BE WRITTEN.
	MOVEI	N,FCTBUF-1	;START OF IO WORD
	HRRM	N,OLIST
	SETZM	OLIST+1
	USETO FCT,@FCTBLK
	OUTPUT FCT,OLIST	;OUTPUT UPDATED FACT FILE.
	STATZ FCT,740000
	JSP N,APPNDR		;ERROR OR EOF WILL YIELD ERROR EXIT.
	AOS 0(P)		;DOUBLE SKIP EXIT
FCTBSY:	AOS 0(P)		;SINGLE SKIP EXIT
	;NON-SKIP ERROR RETURN IS CALLED BY JSP, SO THAT ERROR PC IS IN ACC N.
APPNDR:	RELEASE FCT,0		;RELEASE FACT FILE'S CHANNEL.
	POPJ P,			;*** SUBROUTINE EXIT .***
APPNDE:	MOVE A,[SIXBIT /FACT/]	;SHORT SUBROUTINE TO TRY TO DO AN ENTER ON THE
	MOVE B,APPEXT		; FACT ACCOUNTING FILE.  IN CASE OF FAILURE
	MOVEI C,0		; IT WILL SLEEP A HALF-SECOND THEN TRY AGAIN.
	MOVE D,FCTPP
	ENTER FCT,A
	JRST .+2
	POPJ P,			;**GOOD EXIT. THE FACT FILE IS OPEN FOR WRITING.**
	POP P,N			;CORRECT PUSH-DOWN STACK.
	HRRZ N,B
	CAIE N,3		;ERROR CODE=3 FROM DSKSER MEANS FILE BEING MODIFIED
	JSP N,APPNDR		; BY SOMEONE ELSE. ANY OTHER ERROR CODE LOSES.
	MOVEI	N,1
	CALLI N,SLEEP		;TRY AGAIN IN A SECOND.
	SOSG TRYCTR		;TRIED OFTEN ENOUGH ?
	JRST FCTBSY		;YES, THE FILE IS BUSY AND HAS BEEN FOR TEN SECONDS.
	JRST APPNDL		;NO, TRY AGAIN BEGINNING WITH LOOK-UP. (FILE COULD
	 			; HAVE COME INTO EXISTENCE OR DIED IN THE INTERIM.)


APPNDN:	TRNE B,-1		;ONLY ERROR CODE 0 IS REASONABLE ON LOOKUP FAILURE.
	JSP N,APPNDR		;ERROR EXIT ON ANY OTHER LOOKUP FAILURE.
	PUSHJ P,APPNDE		;FACT FILE DIDN'T EXIST.  TRY TO CREATE IT.
	SETZB N,FCTBLK		;SUCCESSFULLY CREATED. SET POINTERS TO
	AOS FCTBLK		; BEGINNING OF FILE.
	JRST APPNDC		;GO MOVE TRANSACTION ENTRY INTO FILE AND EXIT.


;STORAGE LOCATIONS, BUFFERS, ETC.

U(TRYCTR) 		;NUMBER OF TIMES TO TRY IF FACT FILE IS BUSY
U(FCTBLK)		;BLOCK NUMBER FOR USETI AND USETO
U(APPEXT)		;EXTENSION FOR THE FILENAME FACT (NORMALLY .SYS)


UU(ILIST,2)		;INPUT COMMAND LIST
UU(OLIST,2)		;OUTPUT COMMAND LIST

UU(FCTBUF,200+TRANSZ+1)	;RESERVE BUFFER BIG ENOUGH TO APPEND MAXIMUM SIZE
	 			; TRANSACTION ENTRY TO A FULL 200 WORD BUFFER.
>	;END OF IFN FACTSW CONDITIONAL
SUBTTL SUBROUTINE TO SET UP A UFD

IFN LEVDSW,<
;SUBROUTINE TO SET UP A UFD FOR USE  V002
;ARGS	A=USER'S PPN
;	B=A+1=RESERVED QUOTA
;	C=B+1=FIRST COME FIRST SERVED QUOTA
;	D=C+1=LOGGED OUT QUOTA
;	N1=N+1=MFD PPN
;	M=NAME OF STR
;	IO=ADDRESS OF ROUTINE TO TYPE A CHAR
;	CH=ACCUMULATOR TO CONTAIN CHAR TO BE TYPED
;	F=FLAG REGISTER
;	  L.WRTL=BIT IN LH OF F = 1 IF USER REQUESTS WRITE LOCK
;	  L.NCR=BIT IN LH F = 1 IF USER REQUESTS NO CREATE SET
;	  L.SIN=BIT IN LH F = 1 IF SINGLE ACCESS REQUESTED
;	  L.FRE1=AVAILABLE BIT IN LH OF F
;	  L.FRE2=AVAILABLE BIT IN LH OF F
;	P=PUSH DOWN LIST POINTER
;
;IF D=-1 ASSUME NO UFD DESIRED - PERFORM OTHER OPERATIONS
;
;	USR=FREE I/O CHANNEL
;	US1=FREE I/O CHANNEL
;
;CALL	PUSHJ	P,UFDSET
;ERROR	DONT PROCEED (MESSAGE TYPED)
;OK	STR IS IN SEARCH LIST (WARNING MAY BE TYPED)
;
;ASSUMES SYMBOLS FOR AC'S ABOVE DEFINED, LOCATIONS CPOPJ, CPOPJ1 DEFINED
;
;USES U AND UU MACROS TO RESERVE STORAGE FOR EITHER HIGH OR LOW
;SEGMENT OPERATION.
;
;ROUTINES DEFINED HERE:
;
;MSG:	 TYPES STRING OF ASCII CHARS TO FIRST NULL
;SIXMSG:	 TYPES CONTENTS OF M AS SIXBIT CHARS
;CRLF:	 TYPES CARRIAGE RETURN LINE FEED
;OCTPRT: TYPES CONTENTS OF N AS OCTAL NUMBER
;MPOPJ:	 POP P,M FOLLWED BY POPJ P,
;R.USR:	 READS NEXT WORD FROM CHANNEL USR INTO A (BUFFER HEADER RH.USR, BUFFER B.USR)
;ADDSTR: ADD FILE STRUCTURE TO SEARCH LIST
;DISSTR: DELETE FILE STRUCTURE FROM SEARCH LIST

MNTSUB==1		;DECLARE IN CASE DISMOUNT SUBROUTINE ALSO APPEARS
UFDGIL==^D360		;TIMES TO TRY TO GET UFD INTERLOCK
UFDALC==0		;BLOCKS TO ALLOCATE FOR UFDS (0=STANDARD)
RACEY==2		;VALUE OF LEVEL D FIELD IN STATES WORD FOR MONITORS
			;WHICH INCLUDE RACE CONDITION IMPROVEMENTS
RESRVD==0		;NON ZERO WHEN RESERVED QUOTA IMPLEMENTED
;ARGUMENTS FOR EXTENDED LOOKUP, ENTER, RENAME

EXLLEN==26	;LENGTH OF ARGUMENT LIST
EXLPPN==1	;DIRECTORY NAME
EXLNAM==2	;FILE NAME
EXLEXT==3	;EXT
EXLALC==11	;BLOCKS ALLOCATED FOR FILE
EXLDEV==16	;DEVICE ON WHICH FILE LOOKED UP IS
EXLSTS==17	;STATUS BITS
  RIPLOG==400000	;LH BIT IS LOGGED IN BIT
  RIPDIR==400000	;RH BIT IS DIRECTORY BIT
EXLQTR==24	;RESERVED QUOTA
EXLQTF==22	;FIRST COME, FIRST SERVED QUOTA
EXLQTO==23	;LOGGED-OUT QUOTA
EXLUSD==25	;BLOCKS USED

CHRUFB==1	;UFBTAL WORD
CHRLEN==14	;LENGTH OF DSKCHR BLOCK
  D.MC==10000	;BIT IN LH OF DSKCHR AC RETURN=1 IF MOUNT COUNT=0

;GETTAB TABLES
  CNFTBL==11	;CONFIGURATION TABLE FOR GETTAB
  SEGPTR==15	;INDEX FOR SEGMENTS, JOBS

	OPDEF STRUUO [CALLI 50]

SRCDSL==1	;STRUUO FUNCTION TO SET NEW SEARCH LIST
  STRJMX==9	;MAXIMUM NUMBER OF STRS PER JOB
  SRWPS==3	;WORDS PER STR ENTRY IN SEARCH LIST
  S.SWL==400000	;SOFTWARE WRITE LOCK
  S.NCR==200000	;NO CREATE BIT
  SE.ILF==0	;ILLEGAL FUNCTION RETURN
RDFFST==3	;STRUUO FUNCTION TO REDEFINE FILE STRUCTURE ***
  S.SIN==200000	;SINGLE ACCESS
ULKSTR==6	;STRUUO FUNCTION TO TEST/SET UFD INTERLOCK
UCLSTR==7	;STRUUO FUNCTION TO CLEAR UFD INTERLOCK


	OPDEF GOBSTR [CALLI 66]

GOBJOB==0	;INDEX FOR JOB NUMBER IN ARG LIST
GOBPPN==1	;INDEX FOR PPN
GOBNAM==2	;INDEX FOR STR NAME

	OPDEF PJRST [JRST]

	DEFINE UFDSEM(TEXT)<
	XLIST
	MOVEI	N1,[ASCIZ \TEXT\]
	JRST	UFDSMP
	LIST
>
	EXTERN	.JBFF

UFDSET:	MOVEM	A,UFDUPN	;SAVE USER'S PPN
	MOVEM	N1,UFDMPN	;AND MFD PPN
	MOVEM	M,UFDFSN	;AND NAME OF STR
	MOVE	N,B		;N=RESERVED QUOTA
	MOVE	M,C		;M=FCFS QUOTA
	MOVE	CH,D		;CH=LOGGED OUT QUOTA
	MOVEI	N1,UFDGIL	;NUMBER OF TIMES TO TRY FOR UFD INTERLOCK
UFDSTA:	MOVEI	B,ULKSTR	;USER-MODE UFD INTERLOCK FUNCTION
	PUSHJ	P,STUFC1	;TEST/SET UFD INTERLOCK
	  JRST	STUFBS		;BUSY, SLEEP AND RETRY
	MOVE	B,UFDFSN
	MOVEI	A,14
	MOVEI	C,RH.USR
	OPEN	USR,A		;INIT THIS FILE STRUCTURE
	  JRST	UFDSE2		;HOW CAN THIS BE?
	AOJE	CH,UFDOK	;JUMP IF NO UFD OPERATIONS DESIRED
	SUBI	CH,1		;NO, RESTORE LOGGED OUT QUOTA
	MOVEI	A,B.USR
	MOVEM	A,.JBFF
	INBUF	USR,1		;DECLARE OUR 1 BUFFER
	PUSHJ	P,SETEXL	;SET UP SRCBUF FOR EXTENDED LOOKUP OF UFD
	SETZB	C,SRCBUF+4	;CLEAR REST OF LOOKUP BLOCK
	MOVE	A,[XWD SRCBUF+4,SRCBUF+5]
	BLT	A,SRCBUF+EXLLEN-1
	SETZ	B,		;CLEAR FLAG FOR FIRST TRY
UFDERT:	LOOKUP	USR,SRCBUF	;LOOKUP UFD
	  SKIPA	A,SRCBUF+EXLEXT	;GET ERROR CODE IN A
	JRST	UFDEX		;UFD EXISTS, LOOK AT IT
	TRNE	A,-1		;SKIP IF NO UFD
	JRST	UFDSE3		;THERE'S SOMETHING WRONG WITH THIS UFD
				;FALL THROUGH TO BUILD UFD
;HERE IF MUST CREATE A UFD

	JUMPN	B,UFDENT	;JUMP IF NOT FIRST TIME
	MOVEM	N,SRCBUF+EXLQTR	;STORE RESERVED QUOTA
	MOVEM	M,SRCBUF+EXLQTF	;AND FCFS
	MOVEM	CH,SRCBUF+EXLQTO ;AND LOGGED OUT QUOTA
IFN RESRVD,<ADD	M,N	;LOGGED IN QUOTA=FCFS+RESERVED>
	JUMPE	M,UFDOK		;NO UFD IF LOGGED IN QUOTA = 0
UFDENT:	PUSHJ	P,SETEXL	;SET UP FOR EXTENDED ENTER OF UFD
	MOVE	A,[XWD RIPLOG,RIPDIR]	;SET DIRECTORY BIT AND LOGGED IN BIT
	MOVEM	A,SRCBUF+EXLSTS
IFN UFDALC,<MOVEI A,UFDALC	;BLOCKS TO ALLOCATE FOR UFD
	MOVEM	A,SRCBUF+EXLALC
>
	MOVEI	B,FBMTRY	;TIMES TO RETRY IF BUSY
	ENTER	USR,SRCBUF	;TRY TO CREATE A UFD
	  JRST	UFDSE1		;IDENTIFY ENTER FAILURE
	SETSTS	USR,17		;CHANGE TO DUMP MODE SO CLOSE WONT DUMP BUFFERS
	USETO	USR,2		;WRITES BLOCK 1 WITH ZEROS
	CLOSE	USR,		;AN EMPTY UFD
	JRST	UFDOK		;ALL SET
;HERE IF UFD ALREADY EXISTS

UFDEX:	TLNE	F,FL.WLD
	JRST	RETRYA
	MOVEM	N,SRCBUF+EXLQTR	;STORE RESERVED QUOTA
	MOVEM	M,SRCBUF+EXLQTF	;AND FCFS
	MOVEM	CH,SRCBUF+EXLQTO ;AND LOGGED OUT QUOTA
	LDB	A,[POINT 12,SRCBUF+EXLPRV,35] ;DATE
	LDB	B,[POINT 11,SRCBUF+EXLPRV,23] ;AND TIME OF UFD
	CAMGE	A,UFDDAT		;OLD?
	JRST	UFDEXA		;YES.
	CAME	A,UFDDAT		;SAME?
	JRST	UFDEXB		;NO. NEW. UPDATE.
	CAMGE	B,UFDTIM		;SAME DATE. TIME OLD?
	JRST	UFDEXA		;NO.
UFDEXB:	MOVEM	A,UFDDAT		;STORE NEWEST TIME
	MOVEM	B,UFDTIM		;AND DATE
UFDEXA:	MOVE	A,SRCBUF+EXLSTS	;STATUS BITS
	TRNE	A,RIPNDL	;SKIP IF NO DELETE NOT ON
	JRST	UFDOK		;CANT DO RENAME IF NO DELETE ON
	SKIPG	SRCBUF+EXLUSD	;IS THE USED COUNT .LE. 0?
	TLO	A,RIPLOG	;NO. MAYBE BAD. SIMULATE CRASH/REENTRY
	TLON	A,RIPLOG	;SKIP IF LOGGED IN BIT ALREADY ON
	JRST	UFDEX2		;NO, GO SET IT AND PROCEED
	MOVE	B,[XWD SEGPTR,CNFTBL]
	CALLI	B,CI.GET	;GET NUMBER OF JOBS
	  MOVEI	B,100		;ASSUME 64
	MOVNI	B,-1(B)
	HRLZS	B		;LH B=-NUMBER OF REAL JOBS
UFDEX1:	MOVEI	A,1(B)		;A=NEXT JOB NUMBER
	CAMN	A,THSJOB	;IS IT THIS ONE?
	JRST	UFDEX4		;YES, DONT BOTHER
	MOVEM	A,CHRBUF+GOBJOB
	MOVE	A,UFDFSN
	MOVEM	A,CHRBUF+GOBNAM	;NAME OF STR
	MOVE	A,UFDUPN
	MOVEM	A,CHRBUF+GOBPPN
	MOVEI	A,CHRBUF
	GOBSTR	A,		;SEE IF STR IS IN THAT JOB'S SEARCH LIST
	  JRST	UFDEX4		;NOT IN THIS JOBS LIST OR NOT OUR PPN
	JRST	UFDEX5		;OK IS IN SOMEBODY ELSES SEARCH LIST SAME PPN
UFDEX4:	AOBJN	B,UFDEX1	;LOOP FOR ALL JOBS
;HERE TO LOOKUP ALL FILES AND RECOMPUTE RIBUSD

	SETZB	A,C
	MOVE	B,UFDFSN
	MOVEM	B,CHRBUF	;SAVE FOR DSKCHR
	OPEN	US1,A		;OPEN FILE STRUCTURE
	  JRST	UFDSE2
	SETZM	SRCBUF+EXLUSD	;CLEAR USED WORD
	MOVE	A,[XWD CHRUFB+1,CHRBUF]
	DSKCHR	A,		;GET CURRENT UFBTAL
	  JRST	UFDS9A
ALLK1:	PUSHJ	P,R.USR		;READ NEXT WORD OF UFD
	  JRST	UFDRER		;READ ERROR (MAY BE EOF)
	MOVEM	A,SECBUF+EXLNAM ;FILE NAME
	PUSHJ	P,R.USR		;READ NEXT WORD OF UFD (EXT)
	  JRST	UFDRER		;READ ERROR
	SKIPN	SECBUF+EXLNAM	;SKIP IF REAL NAME
	JRST	ALLK1		;UFD'S DO HAVE ZEROS
	HLLZM	A,SECBUF+EXLEXT ;STORE EXT
	MOVE	A,UFDUPN	;USER'S PPN
	MOVEM	A,SECBUF+EXLPPN
	MOVEI	A,EXLALC
	MOVEM	A,SECBUF	;SET NUMBER OF ARGS TO GET ALC WORD
	LOOKUP	US1,SECBUF	;LOOKUP FILE
	  JRST	ALLK1		;SOMETHING WRONG, FORGET IT
	MOVE	A,SECBUF+EXLALC ;GET BLOCKS ALLOCATED FOR THIS FILE
	ADDM	A,SRCBUF+EXLUSD ;COUNT FOR ALL FILES
	JRST	ALLK1
;HERE IF READ ERROR (MAY BE EOF)

UFDRER:	CLOSE	US1,
	GETSTS	USR,A		;A=ERROR CODE
	MOVEI	M,[ASCIZ . UFD READ error, status = .]
	TRNN	A,20000		;SKIP IF ERROR, NOT EOF
	JRST	UFDSE4		;TELL USER ABOUT ERROR, NO UFD
	MOVE	B,CHRBUF+CHRUFB	;PREVIOUS UFBTAL
	CAMN	B,[XWD 400000,0] ;IF NO PREVIOUS REFERENCES, UFBTAL CHANGED
	JRST	UFDEX3		;SO WE CANT DO ANYTHING ABOUT IT
	MOVE	A,[XWD CHRUFB+1,CHRBUF]
	DSKCHR	A,		;GET NEW UFBTAL
	  JRST	UFDS9A
	SUB	B,CHRBUF+CHRUFB	;OLD-NEW=-DIFFERENCE FREE
	ADDM	B,SRCBUF+EXLUSD	;=DIFFERENCE ALLOCATED
	JRST	UFDEX3		;ALL SET


UFDEX2:	MOVEM	A,SRCBUF+EXLSTS	;MAKE SURE LOGGED IN BIT IS ON
UFDEX5:	LDB	A,LVDBTS	;LEVEL D FIELD IN STATES WORD
	CAIL	A,RACEY		;IF LESS THAT RACE CONDITION STUFF, DONT
	SETOM	SRCBUF+EXLUSD	;USE MONITOR'S COPY OF UFBTAL TO COMPUTE RIBUSD
UFDEX3:	MOVEI	B,FBMTRY	;TIMES TO RETRY IF BUSY
UFDRRT:	PUSHJ	P,SETEXL	;SET UP SRCBUF FOR EXTENDED RENAME
	CALLI	A,23		;MSTIME
	IDIVI	A,^D60000	;IN MINUTES
	CALLI	B,14		;DATE
	DPB	A,[POINT 11,B,23]	;PUT IN TIME IN MINUTES
	DPB	B,[POINT 23,SRCBUF+EXLPRV,35] ;PUT DATE AND TIME IN RIB
	RENAME	USR,SRCBUF
	  SKIPA	A,SRCBUF+EXLEXT
	JRST	UFDOK

	MOVEI	M,[ASCIZ . UFD RENAME failure .]
	JRST	UFDSE4

UFDSE3:	MOVEI	M,[ASCIZ . UFD LOOKUP failure .]
UFDSE4:	PUSHJ	P,UFDSER	;TYPE ERROR LINE
	  JRST	UFDRRT		;RETRY RENAME
	JRST	UFDOK

UFDSE1:	MOVEI	M,[ASCIZ . UFD ENTER failure .]
	PUSHJ	P,UFDSER	;TYPE ERROR LINE
	  JRST	UFDERT		;RETRY ENTER
	MOVEI	M,[ASCIZ .No UFD created
.]
	PUSHJ	P,MSG		;TELL POOR USER WE CANT MAKE A UFD
UFDOK:
REPEAT 0,<MOVEI	A,UFDFSN
	DSKCHR	A,		;NEED TO SEE IF MC=0
	  JRST	UFDSE2		;BAD LUCK
	TLNN	A,D.MC		;SKIP IF MOUNT COUNT=0
	JRST	UFDOK1		;NO
	SETZ	N,		;YES, REDEFINE STR
	TLNE	F,L.SIN		;IF SINGLE REQUEST, PASS ON TO MOUNT UUO
	TLO	N,S.SIN
	MOVEM	N,MNTFSN
	MOVE	B,UFDFSN	;AND FILE STRUCTURE NAME
	MOVEM	B,MNTTYP
	SETOM	UFDDMJ		;USE JOB'S JOB NUMBER
	SETOM	UFDDMP		;AND PPN
	MOVEI	A,RDFFST
	MOVEM	A,UFDMTP	;SET FUNCTION
	MOVEI	A,UFDMTP
	STRUUO	A,		;REDEFINE THE FILE STRUCTURE
	  JRST	UFDS7A		;NO, DONT
>
UFDOK1:	PUSHJ	P,ADDSTR	;ADD STR TO JOBS SEARCH LIST

;HERE TO CLEAR UFD INTERLOCK

	PUSHJ	P,STUFCL	;CLEAR UFD INTERLOCK
	  JRST	CPOPJ1		;WHAT?
	JRST	CPOPJ1		;ALL DONE

UFDSER:	HRRZS	A,SRCBUF+EXLEXT	;ERROR CODE
	CAIN	A,3		;SKIP IF NOT FILE BEING MODIFIED
	SOJG	B,UFDSR1	;JUMP IF CAN STILL RETRY
	EXCH	M,UFDFSN
	PUSHJ	P,SIXMSG
	EXCH	M,UFDFSN
	PUSHJ	P,MSG		;IDENTIFY FAILURE
	HRRZ	N,A		;N=ERROR CODE
	PUSHJ	P,OCTPRT
	PUSHJ	P,CRLF
	JRST	CPOPJ1
UFDSR1:	MOVEI	A,1
	CALLI	A,SLEEP		;SLEEP FOR ONE SECOND
	POPJ	P,
;HERE WHEN UFD INTERLOCK IS BUSY - SLEEP AND RETRY

STUFBS:	TLNE	F,FL.WLD
	JRST	RETRYB
	MOVEI	A,1
	CALLI	A,CI.SLP	;SLEEP FOR 1 SECOND
	SOJG	N1,UFDSTA
	UFDSEM <UFD interlock busy>

UFDSE2:	PUSHJ	P,STUFCL
	  JFCL
	UFDSEM <Cant OPEN>


;SUBROUTINE TO TEST/SET OR CLEAR UFD INTERLOCK
;ENTER AT STUFCL TO CLEAR
;ENTER AT STUFC1 WITH B=FUNCTION
;RETURN POPJ IF FAILED
;RETURN CPOPJ1 IF OK

STUFCL:	MOVEI	B,UCLSTR
STUFC1:	LDB	A,LVDBTS	;LEVEL D FIELD IN STATES WORD
	CAIGE	A,RACEY		;SKIP IF INCLUDES RACE CONDITION STUFF
	JRST	CPOPJ1		;NO, PRETEND WORKS
	MOVE	A,[XWD 3,B]
	MOVE	C,UFDFSN
	MOVE	D,UFDUPN
	STRUUO	A,
	  POPJ	P,
	PJRST	CPOPJ1

;SUBROUTINE TO SET UP HEADER FOR EXTENDED LOOKUP/ENTER/RENAME OF UFD

SETEXL:	MOVEI	A,EXLLEN-1	;LENGTH OF ARG LIST
	MOVEM	A,SRCBUF
	MOVE	A,UFDUPN	;NAME IS USER'S PPN
	MOVEM	A,SRCBUF+EXLNAM
	MOVSI	A,(SIXBIT .UFD.)	;EXT IS UFD
	MOVEM	A,SRCBUF+EXLEXT
	MOVE	A,UFDMPN	;DIRECTORY IS MFD
	MOVEM	A,SRCBUF+EXLPPN
	POPJ	P,

R.USR:	SOSLE	RH.USR+2
	JRST	R.USOK
	INPUT	USR,
	STATZ	USR,760000
	POPJ	P,
R.USOK:	ILDB	A,RH.USR+1
	JRST	CPOPJ1
;THIS ROUTINE ADDS FILE STRUCTURE NAMED IN UFDFSN TO THE
;FILE STRUCTURE SEARCH LIST, OR DELETES THE FILE STRUCTURE FROM IT.
;ENTER AT ADDSTR TO ADD OR AT DISSTR TO DELETE.

L.DIS==L.FRE1
L.PEND==L.FRE2

REPEAT 0,<DISSTR:	MOVEI	A,B
	MOVE	B,UFDFSN
	JOBSTR	A,
	  POPJ	P,		;NOT IN SEARCH LIST, OK
	TLOA	F,L.DIS		;SET FLAG NOTING DISMOUNT
>
ADDSTR:	TLZ	F,L.DIS		;CLEAR FLAG, NOTING ADD
	SETZB	E,UFDDMF	;SET FLAG TO REMEMBER
;;	TLNE	F,L.DIS		;SKIP IF ADDING AN STR
;;	AOS	UFDDMF		;SET FLAG TO DELETE
	MOVEI	A,SRCDSL
	MOVEM	A,UFDMTP	;SET FUNCTION TO DEFINE SEARCH LIST
	SETOB	B,UFDDMJ	;START JOBSTR WITH -1
	SETOM	UFDDMP		;CLEAR JOB AND PPN SO USES VALUES FOR THIS JOB
	TLZ	F,L.PEND	;BORROW THIS BIT TO MEAN FILE STRUCTURE THERE
MAKSRC:	MOVE	A,[XWD 3,B]
	JOBSTR	A,		;GET USER'S NEXT FILE STRUCTURE
	  JRST	UFDSE8		;SYSTEM PROBLEM
;;	TLNN	F,L.DIS		;SKIP IF DISMOUNT
	JUMPE	B,MAKSR2	;MOUNT STOPS AT FENCE
	AOJE	B,MAKSR2	;JUMP IF END OF LIST
	SOS	B
	MOVEM	B,MNTTYP+1(E)
	JUMPE	B,MAKSR1	;DONT DSKCHR THE FENCE
	MOVE	A,[XWD 1,B]
	DSKCHR	A,		;GET CURRENT STATUS OF THIS FILE STRUCTURE
	  JRST	UFDSE9		;CANT FAIL
	MOVE	B,MNTTYP+1(E)	;GET BACK FILE STRUCTURE NAME
	CAME	B,UFDFSN	;AND SEE IF WE ALREADY EXIST
	JRST	MAKSR1		;NO
	TLO	F,L.PEND
;;	TLNE	F,L.DIS		;SKIP IF ACTUALLY DELETING
;;	JRST	MAKSRC		;AND IGNORE THIS FILE STRUCTURE
MAKSR0:	MOVE	A,D
	LSH	A,-4		;ROTATE A TO MATCH UP D.SWL AND L.WRTL
	XOR	A,F		;COMPARE WRITE LOCK STATES
	TLNN	A,L.WRTL	;SKIP IF DIFFERENT
	JRST	CPOPJ		;NO CHANGE
	TLC	D,S.SWL
	SETZ	C,
MAKSR1:	MOVEM	C,MNTTYP+2(E)	;SAVE PROJECT,PROGRAMMER NUMBER
	MOVEM	D,MNTTYP+3(E)	;SAVE WRITE PROTECT REQUEST
	ADDI	E,3
	JRST	MAKSRC		;LOOP FOR ALL USER'S FILE STRUCTURES
UFDSE8:	UFDSEM <System error - JOBSTR UUO failed>
UFDS9A:	PUSHJ	P,STUFCL
	  JFCL
UFDSE9:	UFDSEM <System error - DSKCHR UUO failed>

MAKSR2:	TLZE	F,L.PEND
	JRST	MAKSR3		;DONT ADD FILE STRUCTURE 
MAKSRA:	SKIPN	MNTTYP+1(B)	;B STARTS AT 0 FROM ABOVE
	JRST	MAKSRB		;THE FENCE IS A 0
	ADDI	B,3
	CAIE	B,(E)		;IF END, NO FENCE
	JRST	MAKSRA
	JRST	MAKSR4		;OK TO PROCEED
MAKSRB:	MOVE	C,E		;IF FENCE, MUST MOVE EVERYTHING DOWN 1 ENTRY
MAKSRL:	CAIG	B,(C)		;SKIP IF MORE
	JRST	MAKSR4
	MOVE	A,MNTTYP(C)
	MOVEM	A,MNTTYP+3(C)
	SOJA	C,MAKSRL
MAKSR4:	MOVE	A,UFDFSN
	MOVEM	A,MNTTYP+1(B)	;ADD NEW FILE STRUCTURE
	SETZB	A,MNTTYP+2(B)
	TLNE	F,L.WRTL
	TLO	A,S.SWL		;A SET TO 0 ABOVE
	TLNE	F,L.NCR
	TLO	A,S.NCR
	MOVEM	A,MNTTYP+3(B)
	ADDI	E,3
MAKSR3:	MOVEI	A,UFDMTP
	HRLI	A,4(E)		;LENGTH OF ARGUMENT LIST
	STRUUO	A,
	  JRST	UFDSE6
	POPJ	P,
UFDSE6:;;	TLNE	F,L.DIS
;;	JRST	UFDSE5
	MOVEI	N1,[ASCIZ .Cant add to your File Structure Search List.]
;;	JRST	UFDSSE
;;UFDSE5:	MOVEI	N1,[ASCIZ .Cant remove File Structure from Search List.]
	JRST	UFDSSE
UFDS7A:	PUSHJ	P,STUFCL
	  JFCL
;;UFDSE7:	MOVEI	N1,[ASCIZ .CANT REDEFINE FILE STRUCTURE .]
UFDSSE:
IFE SE.ILF,<
	JUMPE	A,CPOPJ		;JUMP IF ILLEGAL FUNCTION - NOT IMPLEMENTED
>
IFN SE.ILF,<
	CAIN	A,SE.ILF	;SKIP IF NOT ILLEGAL FUNCTION
	POPJ	P,		;ASSUME NOT IMPLEMENTED
>
	MOVEI	CH,"?"
	PUSHJ	P,(IO)
	PUSHJ	P,UFDSMB	;TYPE ERROR CODE IF BATCH
	MOVE	M,UFDFSN
	PUSHJ	P,SIXMSG
	MOVEI	CH," "
	PUSHJ	P,(IO)
	MOVE	M,N1
	PUSHJ	P,MSG
	MOVE	N,A
	PUSHJ	P,OCTPRT
	PJRST	CRLF

UFDSMP:	MOVEI	CH,"?"
	PUSHJ	P,(IO)
	PUSHJ	P,UFDSMB	;TYPE ERROR CODE IF BATCH
	MOVE	M,UFDFSN
	PUSHJ	P,SIXMSG
	MOVEI	CH," "
	PUSHJ	P,(IO)
	MOVE	M,N1
	PUSHJ	P,MSG
	PJRST	CRLF

;SUBROUTINE TO TYPE ERROR CODE IF BATCH JOB

UFDSMB:	TLNN	F,FL.BAT	;SKIP IF BATCH JOB
	POPJ	P,		;NO, FORGET IT
	PUSH	P,M		;SAVE M
	MOVEI	M,[ASCIZ .(1).]
	PUSHJ	P,MSG		;TYPE NON FATAL ERROR CODE
	POP	P,M		;RESTORE M
	POPJ	P,		;AND RETURN
RETRYA:	PUSHJ	P,STUFCL
	  JFCL
RETRYB:	AOS	PPN
	CLOSE	UFD,
	JRST	CHECK1

;SUBROUTINE TO SLEEP TEN SECONDS OR UNTIL DACCFL IS SET POS

SNOOZE:	MOVEI	B,^D10		;10 SECOND COUNTER
SNOOZ1:	SKIPLE	DACCFL		;IS DIRECTORY THERE?
	POPJ	P,		;YES, NON-SKIP RETURN
	MOVEI	A,1		;SETUP FOR THE LITTLE SLEEP
	CALLI	A,CI.SLP	;SLEEEP ONE SEC
	SOJG	B,SNOOZ1	;KEEP YOUR PANTS ON
	AOS	0(P)		;FOR TEN SECONDS, THEN
	POPJ	P,		;RETURN IMPATIENT
;SUBROUTINE TO OUTPUT ACCUMULATOR M AS SIXBIT CHARS

SIXMSG:	PUSH	P,M
	MOVE	M,[POINT 6,(P)]	;M=BYTE POINTER
SIXMSL:	ILDB	CH,M
	JUMPE	CH,MPOPJ	;QUIT AT FIRST NULL BYTE
	ADDI	CH,40
	PUSHJ	P,0(IO)
	TLNE	M,770000	;OR END OF WORD
	JRST	SIXMSL
MPOPJ:	POP	P,M
	POPJ	P,

;THIS ROUTINE OUTPUTS ACCUMULATOR N AS AN OCTAL NUMBER

REPEAT 0,<
OCTPRT:	IDIVI N,10
	HRLM N1,0(P)		;SAVE EACH CHAR ON THE STACK
	SKIPE N
	PUSHJ P,OCTPRT		;RECURSE AS NECESSARY
	HLRZ CH,0(P)		;NOW RETRIEVE LAST CHAR
	ADDI CH,60		;MAKE ASCII
	JRST 0(IO)		;OUTPUT AND ASCEND A LEVEL- EXIT WHEN DONE

CRLF:	MOVEI	M,[ASCIZ .
.]
MSG:	HRLI M,440700
MSGL:	ILDB CH,M
	JUMPE CH,CPOPJ
	PUSHJ P,0(IO)
	JRST MSGL
>

LVDBTS:	POINT	3,STATES,9
UU(RH.USR,3)
UU(B.USR,205)
UU(CHRBUF,CHRLEN)
UU(SRCBUF,EXLLEN)
UU(SECBUF,EXLALC+1)
U(UFDMPN)
U(UFDUPN)
U(UFDFSN)
U(UFDMTP)
U(UFDDMJ)
U(UFDDMP)
U(UFDDMF)
MNTTYP=UFDDMF
U(MNTFSN)
U(MNTNUM)
UU(MNTBLK,SRWPS*STRJMX)
>	;END CONDITIONAL ON LEVDSW

SUBTTL I/O SUBROUTINES
CRLF:	MOVEI	M,[ASCIZ /
/]

MSG:	TLZE	F,FL.TYO
	OUTPUT	TTY,0
	OUTSTR	(M)		;OUTPUT TO TTY
	POPJ	P,0

OCTPRT:	MOVEI	R,^D8
	JRST	RDXPRT

DECPR2:	MOVEI	CH,"0"		;IF NEED LEADING DIGIT
	CAIG	N,11
	PUSHJ	P,TYO		;TYPE A ZERO
DECPRT:	MOVEI	R,12
RDXPRT:	IDIVI	N,(R)
	HRLM	N+1,0(P)
	SKIPE	N
	PUSHJ	P,RDXPRT
	HLRZ	CH,0(P)
	ADDI	CH,"0"
	JRST	TYO

RDUFD:	SKIPGE	WD,RDHED
	JRST	RDUFD1		;ALREADY READING
	MOVE	WD,[IOWD 200,UFDBUF]
	MOVEM	WD,RDHED
	SETZM	RDHED+1
	TLNE	F,FL.ACC	;SKIP IF READING AUXACC.SYS
	AOS	ACCKNT		;KEEP COUNT OF BLOCKS READ ON ACCT.SYS
	INPUT	UFD,RDHED
	STATZ	UFD,760000	;ERRORS OR EOF?
	POPJ	P,0		;YES. NONSKIP RETURN

RDUFD1:	AOBJN	WD,.+1		;NEXT WORD
	MOVEM	WD,RDHED
	MOVE	WD,0(WD)	;GET DATUM

IFE	FASTLG,<
	TLON	F,FL.RAS	;FIRST WORD?
	JRST	RDUFD2		;YES. GO MAKE SPECIAL CHECKS
>
IFN	FASTLG,<
	TLO	F,FL.RAS	;JUST SET IT, NO SKIP
>
CPOPJ1:	AOS	0(P)		;SKIP RETURN
CPOPJ:	POPJ	P,0

IFE	FASTLG,<
RDUFD2:	HRRZM	WD,ENTSIZ	;SAVE SIZE OF ENTRIES
	HLRZS	WD
	CAIE	WD,ACCFOR
	JRST	BADFOR
	POP	P,0(P)		;REMOVE SUBR ENTRY
	JRST	RDACCT		;AND TRY AGAIN TO READ A BLOCK
>;*** END OF CONDITIONAL ON FASTLG

IFN LEVCSW,<
;INIT THE DISK PACK WITH THE MOST ROOM LEFT ON IT
;IN ORDER TO WRITE A UFD FOR THIS USER
SETPAK:	PUSH	P,A		;SAVE NAME
	PUSH	P,B		;SAVE EXTENSION
	PUSH	P,T		;SAVE TEMP
	MOVE	A,[SIXBIT .DPA0.] ;LOOK AT 1ST PACK
	MOVE	T,[XWD 3,A]	;WANT 3 WORDS RETURNED
	CALLI	T,CI.CHR
	JRST	SETXIT		;NO DISK PACKS, RETURN
	PUSH	P,A		;SAVE NAME
	PUSH	P,C		;SAVE AMOUNT OF ROOM LEFT

SETP1:	MOVE	T,[XWD 3,A]
	ADDI	A,10000		;SET A = NEXT PACK
	CALLI	T,CI.CHR	;GET CHARACTERISTICS
	JRST	SETP2		;THROUGH IF DEV DOESN'T EXIST
	TLNE	T,4000		;PRIVATE?
	JRST	SETP2		;YES, DONE

	CAMLE	C,(P)		;MORE ROOM ON THIS THAN PREVIOUS MOST EMPTY?
	TLNE	T,3000		;YES. THIS DRIVE USABLE?
	JRST	SETP1		;NO, LOOK AT NEXT
	MOVEM	A,-1(P)		;YES. SAVE NAME
	MOVEM	C,(P)		;SAVE AMOUNT OF ROOM
	JRST	SETP1		;LOOK AT NEXT DRIVE

SETP2:	POP	P,B
	POP	P,B		;NAME OF PACK WE WANT
	MOVEI	A,17		;OPEN IN MODE 17
	SETZM	C		;NO BUFFER HEADERS
	OPEN	UFD,A		;OPEN IT
	CALLI	CI.LGO		;LOSE

SETXIT:	POP	P,T
	POP	P,B		;RESTORE AC'S
	POP	P,A
	POPJ	P,		;AND RETURN
>	;END CONDITIONAL ON LEVCSW
BADFRA:	MOVEI	N1,ERR.NF	;NON FATAL ERROR
	JRST	BADFR1

BADFOR:	MOVEI	N1,ERR.SS	;STOP SCHEDULING
BADFR1:	MOVEI	M,BDFRMS
	JRST	NOSYS1
DECIN:	SETZ	N,		;START WITH NOTHING
DECIN1:	PUSHJ	P,TYI		;READ NEXT DIGIT
	CAIL	CH,"0"		;SKIP IF NOT A NUMBER
	CAILE	CH,"9"		;SKIP IF DECIMAL DIGIT
	POPJ	P,		;ALL DONE
	IMULI	N,^D10		;BUMP PREVIOUS BY TENS PLACE
	ADDI	N,-"0"(CH)	;AND ADD IN NEW DIGIT
	JRST	DECIN1

OCTIN:	MOVEI	N,0		;START WITH NO NUMBER
	TLZN	F,FL.WLD	;WILD PPN
	JRST	OCTIN1		;NO--DO NOT ALLOW *
	PUSHJ	P,TYI		;EAT A CHAR
	CAIE	CH,UNISYM	;WILD?
	JRST	OCTIN2		;NO
	MOVEI	N,UNIPRG	;FLAG WILD
	TLO	F,FL.WLD	;SET THE FLAG
	JRST	TYI		;EAT TERMINATOR
OCTIN1:	PUSHJ	P,TYI		;GET A CHAR
OCTIN2:	CAIL	CH,"0"		;OCTAL DIGIT?
	CAILE	CH,"7"
	POPJ	P,0		;NO
	ASH	N,3
	ADDI	N,-60(CH)	;ACCUMULATE THE NUMBER
	JRST	OCTIN1		;LOOP

SUBTTL ERROR CONDITIONS

NOMFDP:	MOVEI	M,[ASCIZ /May not login as MFD PPN
/]
	JRST	ERR1

NOREMT:	MOVEI	M,[ASCIZ /Project 1 may not be PTY
/]
	JRST	ERR1

PPERR1:	PUSHJ	P,CODGET	;GET PSW TO MAKE IT LOOK GOOD
	PUSHJ	P,CRLF
	MOVEM	A,CODE		;SAVE THE PASSWORD HE TRIED
PPERR:
BADNAM:			;ALL SAME ERROR, SO DONT HELP HACKERS
TRYAGN:	MOVEI	M,[ASCIZ /INVALID ENTRY - Try again
/]
ERR1:	TTCALL	11,0		;CLEAR FURTHER TYPEIN
	SETZM	TIB+2		;AND REST OF THIS BUFFER
	TLNE	F,FL.ATT	;NO SKIP IF ATTACH
	JRST	NOATT		;NO RETRIES FOR ATTACH
	SOSG	LOGTRY
	JRST	FLUSH
	MOVEI	N1,ERR.FT	;FATAL ERROR
	PUSHJ	P,ERRLIN
IFN	FAILOG,<
	PUSHJ	P,ACCTA		;SETUP FACT FILE ENTRY FOR FAILURE
	MOVE	A,FCTFMD	;MODIFY HEADER FOR FAILURE TYPE AND EXTENDED LEN
	ADDM	A,FCTDAT
	MOVE	A,CODE		;THIS IS THE PASSWORD HE TRIED
	MOVEM	A,FCTDAT+3	;HANG ONTO IT
	MOVE	A,CNTLJP	;THIS IS THE PPN OF THE CONTROL JOB
	MOVEM	A,FCTDAT+4
	MOVE	CALC,FCTFWD	;GET FAILURE HEADER WORD
	PUSHJ	P,APPEND	;STICK THE WHOLE THING INTO FACT.SYS

>;END OF CONDITIONAL ON FAILOG
	TLO	F,FL.BRK	;NOTE END OF LINE
	MOVEI	M,3
	CALLI	M,CI.SLP	;SLOW DOWN PTY PROGRAMS
				; TRYING TO BREAK SYSTEM
	JRST	LOGIN1

NOATT:	MOVEI	M,NOATMS	;CANT ATTACH MESSAGE
	PUSHJ	P,MSG		;COMPLAIN ABOUT ATTACH FAILING
	JRST	FLUSH		;AND GIVE UP
;SUBROUTINE TO ASK FOR AND READ PASSWORD
;VALUES	A=SIXBIT PASSWORD

CODGET:	TLNE	F,FL.FDX	;SKIP IF NOT FDX LINE
	JRST	FDXCOD		;YES.
HDXCOD:	CALLI	A,CI.TIM	;MUST MAKE MASK
	TRO	A,1		;FOR RANDOM NUMBERS
	MOVNI	B,3		;THREE OVERLAYS
MASK2:	MOVNI	C,6		;6 CHARS LONG
MASK1:	IMULI	A,-3		;RANDOM CHAR
	HRRZ	N,A
	IDIVI	N,76		;NO SPACE OR QUEST MK
	MOVEI	CH,41(N1)	;THE CHAR
	PUSHJ	P,TYO		;OUTPUT IT
	AOJL	C,MASK1		;MAKE A LINE
	MOVEI	CH,15		;NOW A CR W/O LF
	PUSHJ	P,TYO		;..
	AOJL	B,MASK2		;THREE LINES
	PUSHJ	P,GET2WD	;COLLECT THE PASSWORD
	MOVEI	CH,"*"		;MASK FOR DISPLAY TERMINALS
	MOVEI	N,6		;COUNT
	PUSHJ	P,TYO		;PRINT ENOUGH TO ERASE PASSWORD
	SOJG	N,.-1		;LOOP
	POPJ	P,		;EASY

FDXCOD:	MOVEI	M,[ASCIZ /Password: /]	;REQUEST CODE
	PUSHJ	P,MSG		;..
	PJRST	GET2WD

BOMES:	MOVEI	M,BOMSG
	JRST	DODAYM

NORMT:	MOVEI	M,LCLMSG	;SAY LOCAL ONLY
	JRST	DODAYM

NOLGTS:	MOVEI	M,NOTSMS
	TLNE	F,FL.ATT	;SKIP IF LOGIN, NOT IF ATTACH
	MOVEI	M,NOTSAT	;MAY NOT ATTACH HERE MESSAGE
	MOVEI	N1,ERR.SF	;SEMI FATAL ERROR
	PUSHJ	P,ERRLIN	;TYPE BEGINNING OF LINE
	MOVEI	M,NOTSM1	;LOCAL MESSAGE
	TRNE	B,P.LGRM	;SKIP IF NOT REMOTE HARDWIRED TTY
	MOVEI	M,NOTSM2	;REMOTE MESSAGE
	TRNE	B,P.LGDS	;SKIP IF NOT DATA SET TTY
	MOVEI	M,NOTSM3	;DATA SET MESSAGE
	TRNE	B,P.LGRO	;SKIP IF NOT REMOTE CTY OR OPR
	MOVEI	M,NOTSM4	;REMOTE CTY OR OPR MESSAGE
	TLNE	F,FL.BSJ	;SKIP IF NOT BATCH JOB SUBJOB
	MOVEI	M,NOTSM5	;SUBJOB MESSAGE
	PUSHJ	P,MSG
	JRST	FLUSH
EXPPPN:	MOVEI	M,EXPPMS
	MOVEI	N1,ERR.FT	;FATAL ERROR
	JRST	NOSYS1		;BOMB BATCH

NOPRIM:	MOVEI	M,[ASCIZ /Some other time
/]
NOSYS2:	MOVEI	N1,ERR.SF	;SEMI FATAL ERROR
	JRST	NOSYS1
NOSYS:	TLNE	F,L.OPR!L.SOPR	;SKIP IF NOT OPR OR SON OF OPR
	JRST	PSWOK		;CTY OR OPR CAN LOGIN EVEN IF NO ACCT.SYS
	MOVEI	M,CNSYSF
	MOVEI	N1,ERR.SS	;STOP SCHEDULING
NOSYS1:	PUSHJ	P,ERRLIN
	JRST	FLUSH

NOTAVL:	MOVEI	M,DWNMSG
DODAYM:	MOVEI	N1,ERR.SS	;STOP SCHEDULING
	PUSHJ	P,ERRLIN	;SAY SYSTEM IS DOWN
	TLZ	F,FL.MSG	;CLEAR SLASHED PPN FLAG
	PUSHJ	P,DAYMES	;TYPE MESSAGE OF THE DAY
				; AND FALL INTO FLUSHER
FLUSH:	MOVEI	M,CRLFPD
	PUSHJ	P,MSG
	MOVEI	CH,4
	PUSHJ	P,TYO
	JRST	FLUSHX		;GO CLEAR CORE AND KJOB

INCNTC:	MOVEI	M,CRLFPD
	PUSHJ	P,MSG
	JRST	FLUSHX
DAYMES:	INIT	UFD,0
	SIXBIT	/SYS/		;GET SYS:NOTICE.TXT
	XWD	0,DIB		;IN BUFFERED MODE
	POPJ	P,		;NO SYS. WELL....
	MOVE	A,[SIXBIT /NOTICE/]
	MOVSI	B,(SIXBIT /TXT/)	;NAME OF MESSAGE FILE
	SETZB	C,D
	LOOKUP	UFD,A		;FIND FILE?
	POPJ	P,		;NO. WELL, FORGET IT.
IFN SUPNOT,<
	LDB	A,[POINT 12,C,35]	;DATE OF NOTICE.TXT
	CAMLE	A,UFDDAT		;NEWER THAN UFD?
	JRST	ACCT5B			;YES. GO PRINT IT
	CAME	A,UFDDAT		;SAME DAY?
	JRST	ACCT5C		;NO. OLDER.
	LDB	B,[POINT 11,C,23]	;TIME OF NOTICE.TXT
	CAML	B,UFDTIM	;NEWER THAN LAST LOGIN?
	JRST	ACCT5B		;YES. TYPE IT.
ACCT5C:	TLNE	F,FL.MSG		;NO. SUPPRESS IF REQUESTED.
	POPJ	P,0		;SUPPRESS
>
ACCT5B:	SOSLE	DIB+2		;MORE CHARS?
	JRST	ACCT5A		;YES
	INPUT	UFD,0		;GET A BUFFER
	STATZ	UFD,760000	;ANY ERRORS OR EOF?
	POPJ	P,		;YES, EXIT
ACCT5A:	ILDB	CH,DIB+1	;GET A CHAR
	CAIN	CH,14		;IF A FORMFEED, DONT
	MOVEI	CH,12		;JUST A LF WILL DO
	PUSHJ	P,TYO		;OUTPUT CHARACTER
	JRST	ACCT5B		;LOOP

;SUBROUTINE TO START AN ERROR LINE WITH ?(#) (# IF PTY)
;ARGS	M=ADDR OF ASCII TEXT
;	N1=ERROR CODE IF BATCH

ERRLIN:	MOVEI	CH,"?"		;START WITH QUESTION MARK
	PUSHJ	P,TYO		;TYPE IT
	MOVE	CH,TTBITS	;GET TTY CHARACTERISTICS
	TLNN	CH,TT.PTY	;SKIP IF PTY JOB
	PJRST	MSG		;NO, TYPE TEXT AND RETURN
	MOVEI	CH,"("		;PAREN FOR CONSISTENCY CHECKING
	PUSHJ	P,TYO		;TYPE IT
	PUSH	P,N		;SAVE N
	MOVE	N,N1		;ERROR CODE
	PUSHJ	P,DECPRT	;TYPE ERROR CODE
	POP	P,N		;RESTORE N
	MOVEI	CH,")"		;FINISH UP
	PUSHJ	P,TYO		;TYPE IT
	PJRST	MSG		;TYPE TEXT AND RETURN
SUBTTL MESSAGES

CRLFPD:	ASCIZ /
./
EXPPMS:	ASCIZ	/PPN has expired
/
DWNMSG:	ASCIZ /System not available
/
LCLMSG:	ASCIZ /No remote users. Try again later.
/
NOATMS:	ASCIZ /
? Can't ATT to job/
NOTSMS:	ASCIZ /May not login /
NOTSAT:	ASCIZ /May not ATTACH /
NOTSM1:	ASCIZ /local
/
NOTSM2:	ASCIZ /remote
/
NOTSM3:	ASCIZ /data set
/
NOTSM4:	ASCIZ /remote CTY or OPR
/
NOTSM5:	ASCIZ /BATCH job subjob
/
BOMSG:	ASCIZ /Only BATCH users may login. Try again later

/
CNSYSF:	ASCIZ	/Cant access system fileS
/
NOSLUF:	ASCIZ	/No Search List or UFD's created
/
BDFRMS:	ASCIZ	/Wrong Format Version Number in system files
/
SUBTTL DATA AND STORAGE

;STORAGE

MONTAB:	ASCII /-Jan-/
	ASCII /-Feb-/
	ASCII /-Mar-/
	ASCII /-Apr-/
	ASCII /-May-/
	ASCII /-Jun-/
	ASCII /-Jul-/
	ASCII /-Aug-/
	ASCII /-Sep-/
	ASCII /-Oct-/
	ASCII /-Nov-/
	ASCII /-Dec-/

WEEKDA:	ASCIZ	.Sat.
	ASCIZ	.Sun.
	ASCIZ	.Mon.
	ASCIZ	.Tue.
	ASCIZ	.Wed.
	ASCIZ	.Thur.
	ASCIZ	.Fri.

WATBTS:	POINT	5,ENTRY+PROWRD,4
SPLBTS:	POINT	5,ENTRY+PROWRD,9
IFN	FASTLG,<
ENTSIZ:	16			;SIZE OF ACCT.SYS ENTRIES
DACCFL:	0			;DIRECTORY IS NOT BUILT
DLOCK:	-1			;AND NO-ONE IS BUILDING IT
DAUXFL:	0			;AUX TABLE MUST ALSO BE BUILT
DACCL:	0			;EXPECTED LENGTH OF ACCT.SYS = LENGTH OF TABLE
>;*** END OF CONDITIONAL ON FASTLG
UU(DATEMP,2)

IFN FACTSW,<
FCTAHD:	XWD	240000,3
FCTHED:	XWD	100000,3
FCTFMD:	XWD	20000,2	;MODIFIER FOR FAILURE-TYPE ENTRIES
;** DO NOT SEPARATE THESE TWO LINES **
U(DAEFCT)		;GETS DAEMON FUNCTION CODE TO WRITE FACT FILE
UU(FCTDAT,TRANSZ)

FCTWD:	XWD	-3,FCTDAT
FCTFWD:	XWD	-5,FCTDAT	;APPEND CONTROL WORD FOR FAILURES
>
UU(RDHED,2)
UU(TOB,3)
UU(TIB,3)
UU(DIB,3)

PDPLST:	IOWD 20,PDL
UU(PDL,21)

MFDPPN:	XWD	1,1		;PPN FOR MFD
IFN LEVDSW,<SYSPPX: XWD	1,4	;PPN FOR SYSTEM FILES>
ALPPPN:	XWD	1,2		;ALL PRIVILEGES
UU(ENTRY,MAXENT)	;DATA FROM ACCT.SYS
U(LOGTRY)	;TRIES AT LOGGING IN
U(TTBITS)	;TELETYPE DESCRIPTOR
U(STATES)		;SYSTEM STATES
IFE FASTLG,<U(ENTSIZ)>	;SIZE OF ENTRY BLOCK IN ACCT.SYS
U(NOWBIT)		;TIME OF DAY AS A BIT
U(ACCTLN)		;LENGTH OF ACCT.SYS IN BLOCKS
U(ACCKNT)		;NUMBER OF BLOCKS READ ON ACCT.SYS
U(SAVEDA)
U(SYSPPN)
U(MYTTY)
U(UFDDAT)		;DATE OF MOST RECENT UFD
U(UFDTIM)		;AND ITS TIME
U(THSJOB)		;THIS JOB NUMBER
IFN FASTLG,<U(SVPROT)	;TEMP FOR SETUWP
U(SAVKNT)>		;TEMP FOR BUILDING AUX DIR
IFN LEVCSW,<U(ZERO)>
IFE	LEVDSW,<UU(SRCBUF,5)>
CNTLJT==SRCBUF+1
CNTLJP==SRCBUF+2
SAVOPR==SRCBUF+3
ATTJOB==SRCBUF+4

MFDPP==MFDPPN
FCTPP==SYSPPN		;FACT FILE IS IN SYS UFD

U(CODE)
U(DATE)
IFN FACTSW,<UFDBUF==FCTBUF>
IFE FACTSW,<UU(UFDBUF,201)>
UU(ZZMAX,0)

	XLIST	;LITERALS
	LIT
	LIST	;LITERALS

DACC:	Z		;MUST BE AT END---
; AT RUNTIME, THIS BECOMES A DIRECTORY FOR ACCT.SYS
LGIEND:	END	LOGIN
  