	TITLE FORERR %2.(147) ERROR PROCESSING MODULE FOR THE FOROTS SYSTEM
	SUBTTL	D. TODD /DRT/     04-APR-1973


;***COPYRIGHT 1972,1973 DIGITAL EQUIPMENT CORP., MAYNARD, MASS.***
	ENTRY	FORER%		;ENTRY POINT TO FORERR - MUST BE DEFINED BEFORE


	SEARCH	FORPRM	;GLOBAL SYMBOLS DEFINED IN FORPRM

VERNO==2		;MAJOR VERSION NUMBER
VEDIT==110		;MAJOR EDIT NUMBER
VMINOR==0		;MINOR EDIT NUMBER
VWHO==0			;WHO EDITED LAST

VERERR==BYTE (3)VWHO(9)VERNO(6)VMINOR(18)VEDIT

;	DEFINE THE LOADING
	SEGMEN
HGH.AC==T5			;NUMBER OF AC'S TO SAVE


;CONTROL FFLAGS IN THE LEFT HALF OF THE MESSAGE TABLE ENTRIES
;	FOLLOWING FLAGS ARE CONTAINED IN T5 DURING ERROR PROCESSING

ER.HDR==400000	;MESSAGE HEADER TO BE TYPED OUT
ER.DDB==200000	;DEVICE INFO TO BE TYPED OUT
ER.EDB==100000	;EXTENDED DEVICE INFO TO BE TYPED (IMPLIES ER.DDB)
ER.MSG==040000	;ASSOCIATED SPECIAL ROUTINE (ROUTINE ADDRESS)
ER.USR==020000	;USER'S ADDRESS IS NOT AVAILABLE FOR MESSAGE HEADER
	SUBTTL FORERR ENTRY POINTS DEFINED BY ERRDIR IN (FORRM)
ERDIR%:		;DEFINE THE BEGINNING OF THE DISPATCH TABLE
	SALL

	ERRDIR
FORER%:	PUSHJ	P,.+1		;SAVE THE CALLING PC
	ADD	P,[XWD HGH.AC+1,HGH.AC+1]	;MAKE ROOM TO SAVE THE AC'S
	MOVEM	HGH.AC,(P)	;SAVE THE LAST AC
	MOVEI	HGH.AC,-HGH.AC(P)	;GET THE BEGINNING OF THE SAVE AREA
	BLT	HGH.AC,-1(P)	;SAVE THE AC'S
	N.==HGH.AC+1		;DEFINE THE STACK DEPTH
	PUSH	P,P4		;SAVE P4 FOR A BASE REGISTER
	N.=N.+1			;ACCOUNT FOR IT
				;THE AC'S PLUS RETURN ADDRESS
	HRRZ	P4,.JBOPS	;GET THE LOW SEGMENT POINTER
	MOVE	T3,-N.(P)	;GET THE XCT ADDR +1
	HLRZ	T4,(T3)		;GET THE TYPE AND SEVERITY CODE
	ANDI	T4,757		;SAVE THE INDEX AND AC FIELD
	ROT	T4,-5		;POSITION THE AC FIELD
	PUSH	P,T4		;SAVE THE TYPE CODE ON THE  STACK
	N.=N.+1			;COUNT THE SEVERITY CODE AND TYPE CODE
	ANDCMI	T4,-1		;CLEAR THE RIGHT HALR
	ROT	T4,5		;GET THE SEVERITY CODE BACK
	HRLM	T4,(P)		;PUT THE SEVERITY IN THE LEFT HALF
	HLRZ	T4,-1(T3)	;GET THE CLASS CODE
	LSH	T4,-5		;GET THE AC FIELD
	ANDI	T4,17		;SAVE FOUR BITS
	MOVEI	T1,FORRTN	;GET THE RETURN ADDRESS
	HLL	T1,ERDIR%(T4)	;GET THE CLASS NAME
	PUSH	P,T1		;SAVE ON THE STACK
	N.=N.+1		;COUNT THE PUSH
	HRRZ	T1,ERDIR%(T4)	;GET THE DISPATCH ADDRESS
NN.==N.			;DEFINE THE STACK DEPTH FOR THE REST
	JRST	(T1)		;GO TO THE ERROR CLASS ROUTINE
FORRTN:				;RETURN FROM THE CLASS ROUTINE
	N.=N.-1			;ACCOUNT FOR THE POPJ BACK HEHRE
	HRRZ	T3,@-N.(P)	;GET THE RETURN ADDRESS
	JUMPN	T3,FORRT3	;IS A RETURN SPECIFIED
FORRT0:	PUSHJ	P,TRAC%%	;GIVE A USERS TRACE
	MOVEI	T3,EXIT%##	;NO, USE SYSTEM RETURN
	OUTSTR	[ASCIZ /
? Job aborted
/]
FORRT3:	MOVEM	T3,-N.(P)	;SET THE RETURN ADDRESS
FORRT1:	POP	P,(P)		;GET THE TYPE CODE AND SEVERITY OFF THE STACK
	N.=N.-1
	POP	P,P4		;RESTORE THE BASE REG
	N.=N.-1		;ACCOUNT
	MOVSI	HGH.AC,-HGH.AC(P)	;SET A BLT POINT TO RESTORE THE AC'S
	BLT	HGH.AC,HGH.AC	;RESTORE THE AC'S
	SUB	P,[XWD HGH.AC+1,HGH.AC+1] ;MAKE THE STACK RIGHT
	N.=N.-HGH.AC
	POPJ	P,		;RETURN
	N.=N.-1

SYSRET:	POP	P,T0		;RETURN TO MONITOR VIA EXIT
	JRST	FORRT0		;LOAD THE EXIT RETURN

USRRET:	POP	P,T0		;REMOVE THE CALLING ADDRESS
	JRST	FORRT1		;EXIT
	SUBTTL	TY%XXX GENERAL PURPOSE OUTPUT ROUTINES TO THE TTY
;				;ROUTINE TO TYPE A STRING ON THE
				;CURRENT OUTPUT DEVICE
;	CALL
;	TYPSTR (ADDR OF STRING)		;CALLED BY THE TYPE STRING MACRO
;	(RETURN)
TY%STR:	MOVE	T2,(P)		;GET THE ARGUMENT
	MOVEI	T2,@(T2)	;GET THE LOCATION OF THE MESSAGE
	HRLI	T2,100		;SET UPPER CASE SHIFT MODE
TY%FI1:	MOVE	T1,(T2)		;GET A FIVBIT WORD
	TRNN	T1,1		;CHECK FOR LAST WORD OF THE STRING
	TLO	T2,400000	;YES, LAST WORD SET FLAG
TY%FI3:	SETZ	T0,		;CLEAR THE OUTPUT WORD
	LSHC	T0,5		;GET FIVE BITS
	CAIN	T0,37		;IS THIS A CASE SHIFT
	JRST	[TLC  T2,40	;YES, COMPLEMENT CASE SHIFT
		JRST	TY%FI3]	;GET THE NEXT CHARACTER
	JUMPE	T0,.+2		;JUMP IS A FIVBIT BLANK SEEN
	TSOA	T0,T2		;SET UP THE CASE SHIFT
	MOVEI	T0," "		;GET A BLANK
	JUMPN	T1,.+2		;CHECK FOR END OF WORD
	AOJGE	T2,TY%FI1	;CONTINUE UNLESS END OF STRING
	OUTCHR	T0		;OUTPUT THE ASCII CHARACTER
	JUMPN	T1,TY%FI3	;ANY CHARACTERS LEFT
	JUMPGE	T2,TY%FI3	;AND NOT LAST WORD 
	POPJ	P,		;UNLESS END OF STRING

TY%SIX:				;OUTPUT THE SIXBIT WORD IN T1
	SETZ	T0,		;CLEAR THE RECEIVER OF THE SIXBIT CHARACTER
	LSHC	T0,6		;GET A SIXBIT CHARACTER
	ADDI	T0," "		;CONVERT TO ASCII
	OUTCHR	T0		;OUTPUT THE CHARACTER
	JUMPN	T1,TY%SIX	;CONTINUE, IF ANY CHARACTERS LEFT
	POPJ	P,		;RETURN

TY%XWD:	HRLM	T0,(P)		;SAVE THE RIGHT HALF
	HLRZS	T0		;GET THE LEFT HALF
	PUSHJ	P,TY%OCT	;TYPE IT
	OUTSTR	[ASCIZ/,/]	;TYPE A COMMA
	HLRZ	T0,(P)		;GET THE RIGHT HALF
;	PJRST	TY%OCT		;TYPE IT
TY%OCT:	SKIPA	T2,[10]		;SET OCTAL RADIX
TY%DEC:	MOVEI	T2,^D10		;SET DECIMAL RADIX
TY%RDX:	JUMPGE	T0,TYRDX1	;JUMP IF +
	OUTSTR	[ASCIZ /-/]	;SUMP A MINUS SIGN
	MOVNS	T0		;NEGATE THE NUMBER
TYRDX1:IDIVI	T0,(T2)		;GET A DIGIT
	HRLM	T1,(P)		;SAVE ON THE STACK
	SKIPE	T0		;ANY DIGITS LEFT
	PUSHJ	P,TYRDX1	;YES, CONTINUE
	HLRZ	T0,(P)		;GET A DIGIT BACK
	ADDI	T0,"0"		;CONVERT TO ASCII
	CAILE	T0,"9"		;IF DIGIT IS GREATER THAN 9
	ADDI	T0,"A"-"0"	;CONVERT TO LETTERS
	OUTCHR	T0		;OUTPUT
	POPJ	P,		;RETURN FOR NEXT DIGIT

TY%TIM:			;PRINT THE TIME IN TO "HH:MM:SS.HH"
	ADDI	T0,5		;ROUND OFF THE HUNDREDTHS OF SECONDS
	IDIVI	T0,^D1000	;COMPUTE SECONDS
	PUSH	P,T1		;SAVE THOUSANDS OF A SECOND
	IDIVI	T0,^D60		;COMPUTE MINUTES
	PUSH	P,T1		;SAVE MINUES
	JUMPE	T0,TY%TI2	;SKIP IF NO MINUTES
	IDIVI	T0,^D60		;COMPUTE HOURS
	PUSH	P,T1		;SAVE THE MINUTES
	JUMPE	T0,TY%TI1	;SKIP IF NO HOURS
	PUSHJ	P,TY%DEC	;TYPE THE HOURS
	OUTSTR	[ASCIZ /:/]	;TYPE A SEPERATOR
TY%TI1:	POP	P,T0		;GET THE MINUTES BACK
	PUSHJ	P,TY%DEC	;TYPE THE MINUTES
	OUTSTR	[ASCIZ /:/]	;TYPE A SEPERATOR
TY%TI2:	POP	P,T0		;GET THE SECONDS BACK
	PUSHJ	P,TY%DEC	;TYPE THE SECONDS
	OUTSTR	[ASCIZ /./]	;TYPE A SEPERATOR
	POP	P,T0		;GET THE THOUSANDS BACK
	IDIVI	T0,^D10		;CHANGE TO HUNDREDTHS
	IDIVI	T0,^D10
	IORI	T0,"0"		;CONVERT TO ASCII
	OUTCHR	T0		;TYPE IT
	MOVEI	T0,(T1)
	PJRST	TY%DEC		;TYPE THE HUNDREDTHS
	SUBTTL TY%DDB ROUNTINE TO DUMP THE DEVICE BLOCK INFO.
TY%DDB::			;ROUTINE TO OUTPUT THE DEVICE DATA BLOCK
	TLNE	P3,IO.EDC	;ENCODE/DECODE ERROR
	JRST	[OUTSTR [ASCIZ  /ENCODE-DECODE ERROR/]
		JRST	TYPDD6]	;FINISH UP LINE
	OUTSTR	[ASCIZ/!/]	;TYPE A !
	HRRE	T0,DD.UNT(P3)	;GET THE FLU
	PUSHJ	P,TY%DEC	;TYPE THE FLU
	OUTSTR	[ASCIZ/!/]
	MOVE	T1,DD.DEV(P3)	;GET THE DEVICE NAME
	PUSHJ	P,TY%SIX	;TYPE OUT THE DEVICE IF ONE
	OUTSTR	[ASCIZ/:/]		;TYPE A COLON
TYPDD1:	SKIPN	T1,DD.NAM(P3)	;GET THE FILE NAME
	JRST	TYPDD2		;NO FILE NAME
	PUSHJ	P,TY%SIX	;TYPE THE FILE NAME
	HLLZ	T1,DD.EXT(P3)	;GET THE EXTENSION
	JUMPE	T1,TYPDD2	;NULL EXTENSION
	OUTSTR	[ASCIZ/./]		;TYPE A PERIOD
	PUSHJ	P,TY%SIX	;TYPE OUT THE EXTENSION
TYPDD2:	SKIPN	T3,DD.PPN(P3)	;GET THE PPN
	JRST	TYPDD4		;NO PPN SKIP
	OUTSTR	[ASCIZ/[/]		;TYPE A LEFT BRACKET
	MOVE	T0,T3		;GET THE PPN FOR XWD PRINT
	TLNN	T3,-1		;IS THIS A PPN OR A POINTER
	MOVE	T0,2(T3)	;THIS IS A SFD LIST, GET PPN
	PUSHJ	P,TY%XWD	;TYPE OUT THE HALF WORDS
	TLNE	T3,-1		;CKECK FOR SFD LIST
	JRST	TYPDD3		;NO QUIT
	SKIPN	T1,3(T3)	;YES, GET SFD NAME
	JRST	TYPDD3		;NONE LEFT
	OUTSTR	[ASCIZ/,/]	;TYPE A COMMA
	PUSHJ	P,TY%SIX	;TYPE OUT SFD ENTRY
	AOJA	T3,.-4		;CONTINUE UNTIL LIST TERNIMATOR
TYPDD3:	OUTSTR	[ASCIZ/]/]		;TYPE A CLOSING BRACKET
TYPDD4:	LDB	T1,[POINT 9,DD.PRV(P3),8]  ;GET THE PROTECTION CODE
	JUMPE	T1,TYPDD5	;NO PROTECTION, SKIP IT
	OUTSTR	[ASCIZ/</]	;TYPE A <
	MOVE	T0,T1		;ALIGN THE PROTECTION
	TRNN	T0,700		;CHECK THE OWNER'S FIELD
	OUTSTR	[ASCIZ /0/]	;ZERO, TYPE A ZERO
	TRNN	T0,70		;CHECK THE PROJECT FIELD
	OUTSTR	[ASCIZ /0/]	;ZERO, TYPE A ZERO
	PUSHJ	P,TY%OCT	;TYPE IT
	OUTSTR	[ASCIZ/>/]	;GET CLOSEING BRACKET
TYPDD5:	OUTSTR	[ASCIZ \/\]
	TYPSTR	OP.SWT##+2	;TYPE /ASSCESS=
	OUTSTR	[ASCIZ /=/]
	LDB	T1,[POINT 4,DD.BLK(P3),9];GET THE ACCESS INDEX
	TYPSTR	ACC.TB##(T1)	;TYPE THE VALUE
	OUTSTR	[ASCIZ \/\]
	TYPSTR	OP.SWT##+12	;TYPE /MODE=
	OUTSTR	[ASCIZ /=/]
	LDB	T1,[POINT 4,DD.BLK(P3),13];GET THE MODE INDEX
	TYPSTR	MOD.TB##(T1)	;TYPE THE VALUE
TYPDD6:	OUTSTR	[ASCIZ/
/]				;END THIS LINE
	POPJ	P,		;RETURN
	SUBTTL ERROR MESSAGE PROCESSOR
TY%HDR:
	SKPINC			;KILL ^O TYPE OUT
	JFCL
	OUTSTR	[ASCIZ/
%/]	;TYPE A WARNING FLAG
	HLRZ	T0,-2(P)	;GET THE SEVERITY CODE
	PUSHJ	P,TY%OCT	;OUTPUT IN OCTAL
	TLNE	T5,ER.USR	;IS THERE A USER'S CALL
	JRST	TY%HD1		;NO, SKIP THE USER'S ADDRESS
	OUTSTR	[ASCIZ / User's call @ /]
	HRRZ	T0,USR.PC(P4)	;GET THE USER'S PC
	MOVSI	T1,(POP P,(P))	;CHECK FOR THE FORJAK CALL
	CAMN	T1,@T0
	HRRZ	T0,@.JB41
	SUBI	T0,1		;POINT TO THE INSTRUCTION
	PUSHJ	P,TY%OCT	;TYPE IT
TY%HD1:	OUTSTR	[ASCIZ / FOROTS Call @ /];TYPE IT
	HRRZ	T0,-NN.-1(P)	;GET THE ERROR MACRO ADDRESS
	SUBI	T0,1		;POINT TO THE XCT
	PUSHJ	P,TY%OCT	;TYPE IT
	OUTSTR	[ASCIZ / class /]
	HLLZ	T1,-1(P)		;GET THE CLASS NAME
	PUSHJ	P,TY%SIX	;type OUT THE SIXBIT
	OUTSTR	[ASCIZ / type /]
	HRRZ	T0,-2(P)	;GET THE TYPE CODE
	PUSHJ	P,TY%OCT	;TYPE IT
	OUTSTR	[ASCIZ/
/]				;END UP THE ERROR MESSAGE
	POPJ	P,		;RETURN TO SOMEONE

;THE FOLLOWING ENTRIES ARE NOT DEFINED
ER%UUO:ER%QUE:ER%UNF:ER%US0:ER%US1:ER%US2:
ERCALL:	PUSHJ	P,TY%HDR	;TYPE THE HEADER
	TYPSTR	[FIVBIT (UNDEFINED ENTRY IN FORERR)]
	POPJ	P,
	SUBTTL SYS ERROR PROCESSOR
ER%SYS:
	HRRZ	T5,-1(P)	;GET THE TYPE CODE
	CAILE	T5,SYS.MX		;CHECK FOR IN RANGE
	PJRST	ERCALL		;UNDEFINED ENTRY
	MOVE	T5,SYSTAB(T5)	;GET THE ERROR ENTRY
	TLNE	T5,ER.HDR	;HEADER TO BE TYPED
	PUSHJ	P,TY%HDR	;YES, TYPE IT
	TLNN	T5,ER.MSG	;MESSAGE TO BE TYPE
	PJRST	@T5		;NO, ROUTINE DISPATCH
	TYPSTR	(@T5)		;YES, TYPE THE MESSAGE
	POPJ	P,		;EXIT
SYSTAB:				;SYSTEM ERROR TABLE
XWD ER.HDR!ER.MSG,[FIVBIT (FOROTS system error)]			;(0)
XWD	,SYS01								;(1)
XWD ER.HDR!ER.MSG,[FIVBIT (ARGUMENT BLOCK not in the correct format)]	;(2)
XWD ER.HDR!ER.MSG,[FIVBIT (MONITOR not built to support FOROTS)]	;(3)
XWD ,SYSRET								;(4)
XWD ER.HDR!ER.MSG,[FIVBIT (USER PROGRAM HAS REQUESTED MORE CORE THAN IS AVAILABLE)]	;(5)
SYS.MX==.-SYSTAB-1		;SYSTBL SIZE

SYS01:			;PRINT THE TIMES OUT
	SKPINC		;KILL ^O TYPE OUT
	JFCL
	OUTSTR	[ASCIZ /
END OF EXECUTION
CPU TIME: /]
	SETZ	T0,		;ASK FOR OUT RUNTIME
	RUNTIME	T0,		;GET THE TOTAL RUNTIME
	SUB	T0,RUN.TM(P4)	;MINUS THE STARTING TIME
	PUSHJ	P,TY%TIM	;TYPE THE TIME OUT
	OUTSTR	[ASCIZ /	ELAPSED TIME: /]
	MSTIME	T0,		;GET THE TIME OF DAY
	SUB	T0,DAY.TM(P4)	;GET THE STARTING TIME
	JUMPGE	T0,.+2		;CHECK FOR AFTER MIDNIGHT
	ADD	T0,[^D1000*^D3600*^D24]	;ADD MILLISECONDS IN A DAY
	JUMPL	T0,.-1		;MAY BE MANYS DAY OF RUNNING
	PUSHJ	P,TY%TIM	;TYPE THE TIME OUT
	CALLI	12		;EXIT TO MONITOR
	SUBTTL OPN ERROR PROCESSOR
ER%OPN:
	HRRZ	T5,-1(P)	;GET THE TYPE CODE
	MOVNS	T5		;NEGATE THE TYPE CODE
	JUMPN	T5,EROPN1	;JUMP IF NO ZERO
	HRRZ	T5,DD.EXT(P3)	;GET THE ERROR CODE
EROPN1:	MOVE	T5,OPNTAB(T5)	;GET THE DISPATCH ENTRY
	PUSHJ	P,TY%HDR	;TYPE THE HEADER ALWAYS
	TLNE	T5,ER.DDB	;DD.BLK TO BE TYPED
	PUSHJ	P,TY%DDB	;YES, TELL THE USER THE DEVICE AND FILE
	TLNN	T5,ER.MSG	;TYPE A MESSAGE
	PJRST	@T5	;NO, GO TO THE TABLE ADDRESS
	TYPSTR	(@T5)		;YES, TYPE THE ERROR MESSAGE
	POPJ	P,		;RETURN
XWD ER.MSG!ER.DDB,[FIVBIT (Dialog file can not be opened)]		;(-14)
XWD ER.MSG!ER.DDB,[FIVBIT (Illegal FORTRAN logical unit number)]		;(-13)
XWD ER.MSG!ER.DDB,[FIVBIT (Record length missing for RANDOM access)]		;(-12)
XWD ,OPN11							;(-11)
XWD ER.MSG,[FIVBIT (Too many devices open FIFTEEN MAX)]			;(-10)
XWD ER.MSG!ER.DDB,@DATTAB						;(-7)
XWD ER.MSG!ER.DDB,@OPNTAB+12						;(-6)
XWD ER.MSG!ER.DDB,@OPNTAB+11						;(-5)
XWD ER.MSG!ER.DDB,@DATTAB						;(-4)
XWD ER.MSG!ER.DDB,@SYSTAB;(ENTRY NOT USED)				;(-3)
XWD ER.MSG!ER.DDB,[FIVBIT (Illegal ACCESS for device)]			;(-2)
XWD ER.MSG!ER.DDB,[FIVBIT (Illegal MODE for device)]			;(-1)
OPNTAB:
XWD ER.MSG!ER.DDB,[FIVBIT (File was not found)]				;(0)
XWD ER.MSG!ER.DDB,[FIVBIT (No directory for project programmer number)]	;(1)
XWD ER.DDB,OPN02							;(2)
XWD ER.MSG!ER.DDB,[FIVBIT (File was being modified)]			;(3)
XWD ER.MSG!ER.DDB,[FIVBIT (Rename file name already exists)]		;(4)
XWD ER.MSG!ER.DDB,@SYSTAB						;(5)
XWD ER.MSG!ER.DDB,[FIVBIT (Bad UFD or bad RIB)]				;(6)
XWD ER.MSG!ER.DDB,@SYSTAB						;(7)
XWD ER.MSG!ER.DDB,@SYSTAB						;(10)
XWD ER.MSG!ER.DDB,[FIVBIT (Device not available)]			;(11)
XWD ER.MSG!ER.DDB,[FIVBIT (No such device)]				;(12)
XWD ER.MSG!ER.DDB,@SYSTAB+2						;(13)
XWD ER.MSG!ER.DDB,[FIVBIT (No room or quota exceeded)]			;(14)
XWD ER.MSG!ER.DDB,[FIVBIT (Write lock error)]				;(15)
XWD ER.MSG!ER.DDB,[FIVBIT (Not enough monitor table space)]		;(16)
XWD ER.MSG!ER.DDB,[FIVBIT (Partial allocation only)]			;(17)
XWD ER.MSG!ER.DDB,[FIVBIT (Block not free on allocation)]		;(20)
XWD ER.MSG!ER.DDB,[FIVBIT (Can not supersede an existing directory)]	;(21)
XWD ER.MSG!ER.DDB,[FIVBIT (Can not delete or rename a non empty directory)];(22)
XWD ER.MSG!ER.DDB,[FIVBIT (SFD not found)]				;(23)
XWD ER.MSG!ER.DDB,[FIVBIT (Search list empty)]				;(24)
XWD ER.MSG!ER.DDB,[FIVBIT (SFD nested too deeply)]			;(25)
XWD ER.MSG!ER.DDB,[FIVBIT (No create on for specified SFD path)]	;(26)
XWD ER.MSG!ER.DDB,[FIVBIT (LOOKUP ENTER or RENAME error)]		;(??)
OPN02:			;PROTECTION OR DTA FULL ERROR
	MOVE	T1,DD.STS(P3)	;GET THE DEVICE STATUS
	TLNE	T1,DV.DTA	;DTA DEVICE
	TYPSTR	([FIVBIT (DTA Diretory is full)])
	TLNE	T1,DV.DSK	;DSK DEVICE
	TYPSTR	([FIVBIT (Protection failure)])
	POPJ	P,		;RETURN
OPN11:				;OPEN STATEMENT ERROR
	EXCH	P2,P3		;SWAP THE DEVICE POINTER
	PUSHJ	P,TY%DDB	;TYPE WHAT WE HAVLE
	EXCH	P2,P3		;SWAP IT BACK
	TYPSTR	OPN11Z		;TYPE OPEN ERROR
	OUTSTR	[ASCIZ \
/\]	;/
	JUMPG	G3,OPN112	;JUMPE IF NOT A SWITCH PROBLEM
	MOVE	T4,-NN.+1+T1(P)	;RELOAD AC T1
	TYPSTR	T4		;TYPE THE SWITCH NAME
	OUTSTR	[ASCIZ /=	is not /]
	MOVEI	T1,[ASCIZ /unique/]
	JUMPN	G3,.+2		;JUMPE IF NOT UNIQUE
	MOVEI	T1,[ASCIZ /defined/]
	OUTSTR	(T1)		;TYPE IT
	POPJ	P,
OPN112:	TYPSTR	OP.SWT##(G3)	;TYPE THE SWITCH NAME
	OUTSTR	[ASCIZ /=/]
	MOVE	T0,-NN.+1+T1(P)	;GET THE SWITCH VALUE
	MOVE	T1,T0		;COPY INCASE SIXBIT
	LDB	T4,[POINT 3,OP.DSP##(G3),8]	;GET THE VALUE TYPE
	CAIN	T4,5		;DECIMAL
	PUSHJ	P,TY%DEC
	CAIN	T4,4		;OCTAL
	PUSHJ	P,TY%OCT
	CAIN	T4,1		;FIVBIT
	TYPSTR	T0
	CAIN	T4,2		;SIXBIT
	PUSHJ	P,TY%SIX
	OUTSTR	[ASCIZ /	is an invalid argument/]
	POPJ	P,		;RETURN
OPN11Z:	FIVBIT (SWITCH ERROR DURING DIALOG OR OPEN STATEMENT SCAN)	;(-11)
	SUBTTL APR ARITHMETIC FAULT ERROR PROCESSOR
FXU=1B11	;FLOATING EXPONENT UNDERFLOW FLAG
FOV=1B3		;FLOATING OVERFLOW BIT
NDV=1B12	;NO DIVIDE BIT
ER%APR:		;ENTRY TO APR FAULT
	AOS	OVCNT.(P4)	;COUNT THE APR FAULT
	SOSGE	ERRMX.(P4)	;COUNT THE ERRORS
	POPJ	P,		;TOO MANY DON'T PRINT
	HRRZ	T4,-NN.(P)	;GET THE ERROR MACRO PC
	HRRZ	T5,-1(P)	;GET THE TYPE CODE
	SOJGE	T5,ERAPR1	;SPECIAL ENTRY FOR A MESSAGE TYPE
	MOVE	T4,.JBTPC	;GET THE APR TRAP LOC
	HLRZ	T5,T4		;GET THE TRAP BITS
	ANDI	T5,(FXU!FOV!NDV)	;SAVE THE FLAG BITS
	LSH	T5,-5		;MAKE A MESSAGE POINTER
	TRZE	T5,(1B8)	;INDEX
	IORI	T5,1B33		;BETWEEN 0-7
ERAPR1:	MOVE	T5,APRTAB(T5)		;GET THE FLAGS
	PUSHJ	P,TY%HDR	;TYPE OUT THE HEADER
	TYPSTR	(@T5)		;TYPE THE ERROR MESSAGE
	OUTSTR	[ASCIZ /	PC= /]
	MOVEI	T0,-1(T4)	;GET THE ERROR LOCATION
	PUSHJ	P,TY%OCT	;60;TYPE OUT THE PC
	OUTSTR	[ASCIZ /
/]
	POPJ	P,		;RETURN
APRTAB:
	XWD	ER.USR,[FIVBIT (Integer overflow)]	;(1)
	XWD	ER.USR,[FIVBIT (Integer divide check)];(2)
	XWD	ER.USR,[FIVBIT (Illegal APR trap)]	;(3)
	ARG	ER.USR,@APRTAB+2			;(4)
	XWD	ER.USR,[FIVBIT (Floating overflow)]	;(5)
	XWD	ER.USR,[FIVBIT (Floating divide check)];(6)
	XWD	ER.USR,[FIVBIT (Floating underflow)]	;(7)
	SUBTTL LIB LIBRARY ERROR FAULT PROCESSOR
ER%LIB:				;ENTRY POINT
	SOSGE	ERRMX.(P4)	;COUNT THE LIB ERROR
	JRST	USRRET		;IGNORE THE ERROR MESSAGE
	PUSHJ	P,TY%HDR	;TYPE THE HEADER
	PJRST	ER%MSG		;AND THE MESSAGE
	SUBTTL DAT DATA ERROR FAULT PROCESSOR
ER%DAT:				;ENTRY POINT
	HRRZ	T5,-1(P)	;GET THE TYPE CODE
	CAILE	T5,DAT.MX	;IN THE TABLE RANGE
	JRST	ERCALL		;NO, TYPE A MESSAGE
	MOVE	T5,DATTAB(T5)	;GET THE DISPATCH ENTRY
	TLNE	T5,ER.HDR	;HEADER TO BE TYPED
	PUSHJ	P,TY%HDR	;TYPE THE HEADER
	TLNE	T5,ER.DDB	;DEVICE BLOCK TO BE TYPED
	PUSHJ	P,TY%DDB	;TELL THE USER ABLOUT THE DEVICE
	TLNN	T5,ER.MSG	;IS THERE AN ERROR MESSAGE
	PJRST	@T5		;NO, GO TO THE ROUTINE
	TYPSTR	@T5		;TYPE THE STANDARD ERROR
	POPJ	P,		;NO RETURN

DATTAB:
XWD	,ERCALL							;(0)
XWD ER.HDR!ER.DDB,DAT1						;(1)
XWD ER.HDR!ER.DDB!ER.MSG,
[FIVBIT (LSCW Illegal in binary record or reading ASCII)]	;(2)
XWD ER.HDR!ER.DDB!ER.MSG,
[FIVBIT (Check sub error reading binary records)]		;(3)
XWD ER.HDR!ER.DDB!ER.MSG,
[FIVBIT (Input output list greater than record size)]		;(4)
XWD ,DAT5							;(5)
XWD ER.HDR!ER.DDB!ER.MSG,
[FIVBIT (Input output list without data conversion in format)]	;(6)
XWD ER.HDR!ER.DDB!ER.EDB,DAT7					;(7)
XWD ER.HDR!ER.DDB!ER.MSG,
[FIVBIT (Attempt to READ beyond valid input)]	;(10)
XWD ER.HDR!ER.DDB!ER.MSG,
[FIVBIT (Variable cannot be found in NAMELIST block)]	;(11)
XWD ER.HDR!ER.MSG,
[FIVBIT (REREAD before first READ is illegal)]		;(12)
XWD ER.HDR!ER.MSG,
[FIVBIT (can not RANDOM ACCESS a SEQUNTIAL file)]		;(13)
XWD ER.HDR!ER.MSG!ER.DDB,
[FIVBIT (BACKSPACE illegal for device)]			;(14)
DAT.MX==.-DATTAB-1	;DEFINE THE TABLE SIZE
	SUBTTL SPECIAL DATA ERROR FAULT PROCESSING

DAT1:				;TYPE 1 ENTRY POINT
	TYPSTR	DAT1C	;TYPE THE MESSAGE
	PUSH	P,[0]		;COUNT TO THE BAD CHARACTR
	LDB	T0,G2		;GET THE BAD CHARACTER
	OUTSTR	[ASCIZ / [ /]	;SET UP FOR THE CHARACTER
	OUTCHR	T0		;OUTPUT THE CHARACTER
	OUTSTR	[ASCIZ / ]
/]				;AND A CLOSING BRACKET
	MOVE	T3,FBG.BP(P4)	;GET THE POINTER TO THE BEGINNING OF THE FORMAT
DAT1A:	ILDB	T0,T3		;DUMPR THE FORMAT STATEMENT
	OUTCHR	T0		;OUTPUT THE FORMAT STATEMENT
	CAMN	T3,G2		;IS THIS THE BAD CHARACTR
	MOVEM	T2,(P)		;YES SAVE THE POSITION
	CAME	T3,FEN.BP(P4)	;CHECK FOR END OF FORMAT
	AOJA	T2,DAT1A	;NO, CONTINUE
	OUTSTR	[ASCIZ/
/]				;YES, FINISH THE LINE
	POP	P,T2		;GET THE BAD CHARACTER POSITION
	MOVEI	T0," "		;GET A BLANK
	SOJL	T2,.+3		;COLUMN COUNTER
	OUTCHR	T0		;OUTPUT A SPACE
	SOJGE	T2,.-1		;CONTINUE UNTIL UNDER BAD CHARACTER
	OUTSTR	[ASCIZ/^
/]		;DUMP AN UP ARROW
	POPJ	P,		;RETURN
DAT1C:	FIVBIT (Illegal character in format statement)

DAT5:				;ASTERICK FILL ROUTINE FOR OUTPUT
IFE ASTFL,<JRST	ERCALL	;ASTERFIL IS TURNED OFF>

IFN ASTFL,DB	T1,WPOINT##	;GET THE FIELD WIDTH
	MOVEI	T0,"*"		;GET AN ASTERICK TO FILL WITH
	JSP	P1,OBYTE.##	;OUTPUT AN ASTERICK
	SOJG	T1,OBYTE.##	;CONTINUE FILLING
	POPJ	P,		;RETURN TO ROUTINE>

DAT7:				;ILLEGAL CHARACTER IN INPUT ROUTINE
	MOVE	T2,FST.DY(P4)	;GET THE CURRENT ENCODED FORMAT STATEMENT
	MOVE	T2,-1(T2)	;GET THE ASCII FORMAT POINTER
	HLRZ	T1,T2		;GET THE WORD IN THE FORMAT
	ANDI	T1,677777	;CLEAR THE ENCODING FLAG
	IMULI	T1,5		;FIVE CHARACTR/WORD
	HRLI	T2,(POINT 7,0);GET A BYTE POINTER TO THE STRING
	ILDB	T0,T2		;GET A CHARACTER
	OUTCHR	T0		;TYPE IT
	SOJG	T1,.-2		;CONTINUE THRU THE FORMAT
	OUTSTR	[ASCIZ /
/]
	TYPSTR	DAT7A		;TYPE THE MEGGAGE 
	LDB	T0,DD.HRI+1(P3)	;GET THE ILLEGAL CHARACTER
	OUTSTR	[ASCIZ / [ /]	;SET UP FOR THE CHARACTER
	OUTCHR	T0		;OUTPUT THE CHARACTER
	OUTSTR	[ASCIZ / ]
/]				;AND A CLOSING BRACKET
	MOVE	T1,DD.HRI(P3)	;GET THE CURRENT BUFFER
	HRRZ	T4,DD.BUF(P3)	;GET THE BUFFER SIZE
	ADDI	T4,-2(T1)	;GET THE END OF THE BUFFER
	MOVE	T3,POS.TB+1(P4)	;GET THE BEGINNING OF THE RECORD
	CAIG	T1,(T3)		;CHECK FOR BEGINNING OF BUFFER
	CAIL	T1,(T4)		;CHECK FOR THE END
	MOVE	T3,T1		;NO, START PRINTING AN THE BEGINNING OF THE BUFFER
	TLO	T3,(POINT 7,0,35);SET UP THE BYTE SIZE
	SETZ	T2,		;COUNT THE COLUMNS
DAT7B:	ILDB	T0,T3		;GET A CHARACTER
	OUTCHR	T0		;TYPE IT
	CAME	T3,DD.HRI+1(P3)	;IS THIS THE CHARACTR
	JRST	DAT7C		;NO
	PUSH	P,T2		;SAVE THE POSITION
	MOVN	T2,DD.HRI+2(P3)	;GET THE REMAINING CHARACTER COUNT
DAT7C:	CAIE	T0,12		;IS THIS A LINE FEED
	AOJN	T2,DAT7B	;END OF BUFFER OR LINE FEED
	POP	P,T2		;GET THE SPACING COUNT
	CAIE	T0,12		;LINE FEED ALREADY OUT
	OUTSTR	[ASCIZ /
/]				;DO, DUMP IT
	MOVEI	T0," "		;GET A SPACING BLANK
	SOJL	T2,.+3		;FIRST CHARACTER BAD
	OUTCHR	T0		;OUTPUT A SPACING CHARACTER
	SOJGE	T2,.-1		;CONTINUE SPACING
	OUTSTR	[ASCIZ /^
/]				;OUTPUT A POINTER
	JRST	SYSRET		;TAKE SYSTEM RETURN
DAT7A:	FIVBIT	(Illegal character in data)
	SUBTTL DEV DEVICE ERROR FAULT PROCESSOR
ER%DEV:
	HRRZ	T4,-1(P)	;GET THE TYPE CODE
	JUMPN	T4,ERDEV1	;CHECK FOR GETSTS UUO CALL
	HLLZ	T1,DD.UNT(P3)	;GET THE CHANNEL NUMBER
	TLO	T1,(GETSTS)	;GET A STATUS UUO
	XCT	T1		;GET THE DEVICE STATUS
	JFFO	T0,.+1		;GET THE MESSAGE INDEX
	CAILE	T1,^D22		;IS THE INDEX IN RANGE
	POPJ	P,		;NO, EXIT
	HRRZI	T4,-^D18(T1)	;GET THE MESSAGE INDEX
ERDEV1:	MOVE	T5,DEVTAB(T4)	;GET THE FLAGS
	CAIE	T4,4		;EOF CALL
	JRST	ERDEV2		;NO, MUST BE AN ERROR CALL
	MOVE	T1,DD.STS(P3)	;GET THE DEVICE STATS
	TLNN	T1,DV.DSK!DV.DTA!DV.TTA	;DON'T CLOSE IF THESE DEVS
	PUSHJ	P,CLOSI.##	;DO INPUT CLOSE
	HRRZ	T1,ERR.PC(P4)	;YES, IS THERE A RETURN ADDRESS
	JUMPN	T1,ERDEV4	;YES, SET FLAGS
	PUSHJ	P,TY%HDR	;TYPE A HEADER LINE
	PUSHJ	P,TY%DDB	;TYPE THE DEVICE INFO
	JRST	ERDEV5		;EXIT WITH MESSAGE
ERDEV2:	HLRZ	T1,ERR.PC(P4)	;ERROR CALL IS THERE A RETURN ADDRESS
	JUMPE	T1,ERDEV3	;NO RETURN ADDRESS
ERDEV4:	MOVEM	T1,USR.PC(P4)	;CHANGE THE USR'S PC ADDRESS
	POPJ	P,		;RETURN
ERDEV3:	PUSHJ	P,TY%HDR	;TYPE THE HEADER
	PUSHJ	P,TY%DDB	;AND DEVICE INFO
	PUSH	P,T5		;SAVE T5
	TLZE	P3,IO.OPN	;CLEAR THE OPEN BIT
	PUSHJ	P,RELE%%##	;RELEASE THE CHANNEL
	POP	P,T5		;RESTORE T5
ERDEV5:	TYPSTR	(@T5)		;TYPE THE MESSAGE
	JRST	SYSRET		;TAKE THE SYSTEM RETURN


DEVTAB:			;DEVICE ERROR MESSAGE TABLE
	XWD	,[FIVBIT (Write protected)]			;(0)
	XWD	,[FIVBIT (Device error)]			;(1)
	XWD	,[FIVBIT (Parity error)]			;(2)
	XWD	,[FIVBIT (Block too large or quota exceeded)]	;(3)
	XWD	,[FIVBIT (End of file)]				;(4)
	SUBTTL MSG TYPE A MESSAGE OUT
ER%MSG:
	MOVE	T5,@-NN.(P)	;GET THE MESSAGE ADDRESS
	OUTSTR	(T5)		;OUTPUT THE MESSAGE
	OUTSTR	[ASCIZ /
/]
	JRST	USRRET		;RETURN TO THE ERROR MACRO
SUBTTL	FORTRAN TRACE ROUTINES
		ENTRY	TRACE%
	SIXBIT	/TRACE./	;NAME FOR TRACE
TRACE%:
	PUSHJ	P,SAVE.##	;SAVE THE AC'S FOR USER CALL
TRAC%%:				;FOROTS ENTRY WHEN AC'S ARE SAVED
	MOVEI	T5,(P)		;GET THE CURRENT STACK POSITION

	OUTSTR	[ASCIZ/
Name	(Loc)	 <<----	Caller	(Loc)	<#Args>	[Arg Types]
/]
	MOVEI	T5,(P)		;GET THE CURRENT STACK POINTER
TRACE1:	HRRZ	T4,USR.PC(P4)	;GET THE USER'S CALLING ADDRESS
	PUSHJ	P,GETCAZ	;ADDRESS CHECK IT
	POPJ	P,		;RETURNS T3= PUSHJ ADDRESS+1
TRACE2:	MOVE	T1,-1(T3)	;YES, GET THE SIXBIT SUBROUTINE NAME
	PUSHJ	P,TY%SIX	;TYPE THE SUBROUTINE NAME OUT
	OUTSTR	[ASCIZ/	(/]
	MOVEI	T0,(T3)		;ENTRY POINT TO THE SUBROUTINE
	PUSHJ	P,TY%OCT
	OUTSTR	[ASCIZ/) <<---	 /]	;AND A CLOSEING PAREN
	PUSH	P,T4		;SAVE THE ADDRESS OF THE PUSHJ +1
	SUBI	T5,1		;SET THE STACK BACK ONE
	PUSHJ	P,GETCAL	;GET THE NEXT CALL
	JRST	TRACE3		;END OF TRACE TO THE MAIN PROGAM
	EXCH	T4,(P)		;GET THE OLD PUSHJ+1 ADDRESS
	PUSHJ	P,TYPTRC	;TYPE THE TRACE
	POP	P,T4		;RESTORE THE NEW POINTER
	JRST	TRACE2		;CONTINUE
TRACE3:
	POP	P,T4		;RESTORE THE OLD POINTER
	HRRZ	T3,.JBSA	;GET THE STRATING ADDRESS
	SKIPA	T1,[SIXBIT /MAIN./]	;MAIN PROGRAM CALL
TYPTRC:	MOVE	T1,-1(T3)	;GET THE CALLING SUBROUTINE NAME
	PUSHJ	P,TY%SIX	;TYPE THE NAME
	OUTSTR	[ASCIZ/+/]	;
	MOVEI	T0,(T4)		;GET THE CALFER ADDRESS
	SUBI	T0,1(T3)	;MINUS THE ENTRY POINT
	PUSHJ	P,TY%OCT	;TYPE THE OFFSET FROM THE ENTRY
	OUTSTR	[ASCIZ/(/]	;LEFT PAREN
	MOVEI	T0,-1(T4)	;GET THE PUSHJ ADDRESS
	PUSHJ	P,TY%OCT	;TYPE IT
	OUTSTR	[ASCIZ /)	<#/];#ARGUEMENTS
	MOVE	T4,-2(T4)	;GET THE MOVEI ADDRESS
	HLL	T4,-1(T4)	;BUILD AN AOBJN POINTER
	HLRE	T0,T4		;GET THE ARGUMENT COUNT
	MOVMS	T0		;MAKE POSITIVE
	PUSHJ	P,TY%DEC	;TYPE IT OUT
	OUTSTR	[ASCIZ />	[/]	;TYPE A CLOSING BRACKET
	JUMPGE	T4,TYPTR2	;JUP IF NO ARGUMENTS
TYPTR1:	LDB	T1,[POINT 4,(T4),12]	;GET THE ARGUMENT TYPE
	IDIVI	T1,5		;FIVE ENTRIES / WORD
	MOVE	T0,TYPCOD	;GET THE ASCII TYPE CODE
	IMULI	T2,7		;GET THE SHIFT COUNT
	ROT	T0,7(T2)	;POSITION THE CHARACTER
	OUTCHR	T0		;OUTPUT THE ASCII CHARACTER
	AOBJN	T4,TYPTR1	;CONTINUE THRU THE ARGLIST
TYPTR2:	OUTSTR	[ASCII/]
/]				;CLOSING BRACKET
	POPJ	P,		;RETURN
;		 0123456701234567
TYPCOD:	ASCII	/ULIUFUOSDUUUCUUK/
;ROUTINE TO NEXT THE NEXT SUBROUTINE CALL FROM THE STACK
;	ENTRY		T5=THE STACK ADDRESS TO START THE SEARCH
;			PUSHJ	P,GETCAL
;	RETURN		(NON-SKIP)	;END OF STACK
;			(SKIP)		;T4= THE ADDRESS+1 OF THE PUSHJ
;					;T3=THE PUSHJ INSTRUCTION
GETCAL:
	CAIGE	T5,STK.SV(P4)	;IS THE THE BEGINNING OF THE STACK
	POPJ	P,		;YES, END OF SEARCH
	HRRZ	T4,(T5)		;GET THE STACK ENTRY
GETCAZ:	PUSHJ	P,ADRCHK	;IS THIS A VALID ADDRESS
	SOJA	T5,GETCAL	;NO, GET THE NEXT ENTRY
	MOVE	T3,-1(T4)	;GET THE CALLING INSTRUCTION
	HLRZ	T1,T3		;GET THE OP CODE
	CAIE	T1,(PUSHJ P,)	;IS IT A PUSHJ P,
	SOJA	T5,GETCAL	;NO, GET THE NEXT ENTRY
	HLRZ	T1,-2(T4)	;GET THE INSTRUCTION BEFORE THE PUSHJ
	CAIE	T1,(MOVEI L,)	;MUST LOAD THE ARGUMENT LIST
	SOJA	T5,GETCAL	;NO, GET THE NEXT ENTRY
	HLRZ	T1,(T3)		;GET THE TARGET INSTRUCTION
	CAIN	T1,(JRST 1,)	;CHECK FOR CONCEALED ENTRY
	HRR	T3,(T3)		;YES, GO TO THE TRUE ENTRY
	JRST	CPOPJ1		;SKIP RETURN


;ROUTINE TO ADDRESS CHECK THE CONTENTS OF AC T4
;	ENTRY		MOVE	T4,ADDRESS TO BE CHACKED
;			PUSHJ	P,ADRCHK
;	RETURN		(NON-SKIP)	;INVALID ADDRESS
;			(SKIP)		;VALID ADDRESS

ADRCHK:				;ENTRY POINT
	CAIG	T4,140		;CHECK THE LIMITS OF THE LOW SEGMENT
	POPJ	P,		;BELOW THE LOW SEGMENT EXIT
	CAMG	T4,.JBREL	;CHECK FOR A VALID LOW SEG ADDRESS
	JRST	CPOPJ1		;YES, GIVE A SKIP RETURN
	SKIPN	T1,.JBHRL	;IS THERE A HIGH SEGMENT
	POPJ	P,		;NO, ERROR
	CAIGE	T4,400010	;ABOVE THE BEGINNING OF THE HIGH SEGMENT
	POPJ	P,		;NO, EXIT
	CAIGE	T4,(T1)		;BELOW THE END OF THE HIGH SEGMENT
CPOPJ1:	AOS	(P)		;YES, SKIP RETURN
CPOPJ:	POPJ	P,		;ERROR RETURN
	END
	SUBTTL MSG TYPE A MESSAGE OUT
ER%MSG:
	OUTSTR	@T5	;TYPE THE MESSAGE
	POPJ	P,
	LIT
	END
   ".: