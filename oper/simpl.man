












                                 SIMPL

                            Reference Manual


























                                                         Caroline Diehl
                                                         January 26, 1972
                                                         Revision 4.0
$
                               SIMPL Reference Manual

                                 Table of Contents


Section 1.  Basic Elements of SIMPL

1.A  Constants (KON) ....................................
1.B  Identifiers (ID) ...................................
1.C  Variables and Arrays ...............................
       1.C.1  Floating Arrays ...........................
       1.C.2  Indirect Addressing -^ ....................
       1.C.3  Storage Word (SW) .........................
       1.C.4  Address Operator - @ ......................
1.D  Labels .............................................
1.E  Arithmetic Expression ..............................
       1.E.1  Standard Mathematical Operators ...........
       1.E.2  Bit Operators .............................
       1.E.3  Rules Governing Operands ..................
       1.E.4  Operator Precedence .......................
       1.E.5  The AE Classification .....................
1.F  Constant Expression (KONEX) ........................
1.G  Relational Expression ..............................
1.H  Logical Expression .................................
1.I  Conditional Expression .............................
1.J  Operators with Side Effects ........................
       1.J.1  INC and DEC ...............................
       1.J.2  Assignment - _ ............................
       1.J.3  Deferred Assignment - <== .................
       1.J.4  Storage Word Modification .................
1.K  Functions and Other Operators ......................
       1.K.1  Character and Half Word Handling ..........
          1.K.1.1  CH (and HW) ..........................
          1.K.1.2  CHPT and (HWPT) ......................
          1.K.1.3  CHV (and HWV) ........................
          1.K.1.4  NCHV (and NHWV) ......................
          1.K.1.5  PCHV (and PHWV) ......................
       1.K.2  Bit Field Manipulation ....................
          1.K.2.1  BYT Function .........................
          1.K.2.2  Word Packing and Unpacking ...........
       1.K.3  Terminal Input and Output - TTY ...........
1.L  Primary (PRIM) .....................................
1.M  Doubleword Manipulation ............................
       1.M.1  Doubleword Arithmetic Expression ..........
       1.M.2  Doubleword Assignment .....................


Section 2.  Program Structure

2.A  Statement Delimiters ...............................
2.B  Compound Statements ................................
       2.B.1  Compounding Short Statements ..............
       2.B.2  Compounding with DO...END .................
2.C  Line Continuation - & ..............................
2.D  Comments - ! .......................................


Section 3.  Statements of SIMPL

3.A  Declaration Statements .............................
       3.A.1  LOCAL Declaration .........................
       3.A.2  TABLE Statement ...........................
       3.A.3  GLOBAL and FIND ...........................
       3.A.4  BASE Statement ............................
3.B  Value Manipulation .................................
       3.B.1  Assignment Statement ......................
       3.B.2  Doubleword Assignment Statement ...........
       3.B.3  Storage Word Modification .................
       3.B.4  Exchange Statement ........................
       3.B.5  MOVE Statement ............................
       3.B.6  INC and DEC ...............................
       3.B.7  NCHV and NHWV .............................
       3.B.8  PCHV and PHWV .............................
3.C  Transfer of Control ................................
       3.C.1  Unconditional Transfer - GO ...............
       3.C.2  Case Statement ............................
3.D  Conditional Statements .............................
       3.D.1  The STMT Classification ...................
       3.D.2  IF Statement ..............................
       3.D.3  EIF Statement .............................
3.E  Loop Control Statements ............................
       3.E.1  WHILE Statement ...........................
       3.E.2  REPEAT Statement ..........................
       3.E.3  FOR Statement .............................
       3.E.4  LOOP Statement ............................
3.F  Miscellaneous Statements ...........................
       3.F.1  NULL ......................................
       3.F.2  HALT ......................................
       3.F.3  EXIT ......................................


Section 4.  SIMPL Procedures

4.A  Procedure Declaration ..............................
4.B  Procedure Definition ...............................
4.C  Parameters and Arguments ...........................
4.D  Procedure Call and RETURN ..........................
4.E  Parameter Declarations .............................
4.F  Scope of Names .....................................
4.G  Procedure Entry Points ............................. 
4.H  RETURN as an SW .................................... 


Section 5.  SIMPL Macros

5.A  Macro Definition ...................................
5.B  Macro Expansion ....................................
5.C  UNDEF Statement ....................................


Appendix A.  Implementation Dependencies

A.1  XDS 940 ............................................
A.2  PDP-10 .............................................


Index ...................................................



Please direct any comments on this manual to Caroline Diehl.
#1
$
                                Section 1
                            Basic Elements of SIMPL


1.A.  Constants (KON)

    All values are integer.  The maximum value is 2 -1, where  N is
    the number of bits in a word.

    1.  Decimal

              Example: 0,179


    2.  Octal

         To specify an octal constant, precede the value with the word
         OCT; for example, OCT 77 designates octal 77.

    3.  Hexadecimal

         To specify a hexadecimal constant, precede the value with the
         word HEX; for example, HEX 7FFA designates hexadecimal
         7FFA.

    4.  Character

         Preceding a character by the $ symbol yields its internal
         representation as a right-justified integer.  For example,
         when generating code for the PDP-10, SIMPL evaluates the
         constant $A as octal 101, the ASCII code for the
         character A.

    5.  String

         To designate a string constant, surround the string with
         single or double quote marks.  The enclosed characters are
         stored however characters are stored on the machine being
         used, followed by at least one string terminator, the
         definition of which is also machine dependent.  As many
         terminators are added as necessary to fill the last word
         of the string.  If the last word of the string is already
         full (that is, if the number of characters is a multiple
         of the number of characters per word), a word of terminators
         is added.

         The value of a string constant is the address of the first
         word of the string.


              Example:

              The constant "ABCDEF" is stored on the Sigma 7 as

               C1C2C3C4     C5C60000
              Word 1         Word 2

              and its value is the address of "word 1" of this diagram.

    6.  Miscellaneous

        The value of the following constants are machine dependent:

        a.  EOLIT - the string terminator (0 on PDP-10 and Sigma 7)

        b.  CHARSPERWORD - the number of characters per word (5 on
                           PDP-10, 4 on Sigma 7)

        c.  BITSPERWORD - the number of bits per word

        d.  CARRET - the internal representation of the carriage
                     return character.

        e.  LNFEED - the internal representation of the line feed
                     character

    Periods are ignored within all constant types above except
    character and string constants.  Thus they can be used
    for decorative purposes, possibly to show separation
    between different parts of a word, without having any
    effect on the value.  For example, HEX 3C1C2C3 can also
    be written as HEX 3.C1C2C3, or HEX 3.C1.C2.C3.  The
    miscellanous constants might be made more readable by adding
    periods, as in CHARS.PER.WORD or CAR.RET.

1.B. Identifiers (ID)

    SIMPL variables, labels, procedures and macros are named with
    identifiers (IDs) which must begin with an alphabetic character (A
    to Z) and include only alphanumeric characters (A to Z, 0 to 9)
    thereafter.  Thus, the following are legal identifiers:

              A
              X12
              NMBUFND


    Periods are ignored within identifiers and may therefore  be used
    for decorative purposes, possibly to clarify the meaning of a
    particular string of characters.  For example, NMBUFND could
    alternately be written as NMBUF.ND, or NM.BUF.ND, or any
    combination within the same program, and SIMPL will equate all such
    forms to the identifier NMBUFND.

    The alphabetic strings that have a special meaning to SIMPL
    (reserved words, such as OCT, HEX, EOLIT) may not be used as
    identifiers.  However, a reserved word will be recognized as such
    only if it is terminated by a  space (or a non-alphanumeric
    character).  Thus, HEX C1 is read as a constant, but HEXC1 is an
    identifier.

    Any identifier may represent only one language element at a time.
    (See Section 4.F for information on scope of names when a SIMPL
    program  contains procedures.)


1.C. Variables and Arrays

    Each variable occupies a word of storage.  A variable may be simple
    (not subscripted) or have a single subscript (forming a
    one-dimensional array).  Variables are named with identifiers
    and must always be declared by the user.  (Note: When
    generating code for certain machines, SIMPL will initialize
    variables to 0, but this is not a standard SIMPL specification.
    Thus, if variables are to be initialized, the user should do so
    himself.)

    To declare a simple variable, type the identifier in the LOCAL
    declaration statement as follows:

    LOCAL ID

    To declare an array, follow its identifier  by the subscript limits
    in parentheses, in the form ID(KON:KON).  For example,

    LOCAL B(3:50)

    declares the 48-element array B.  If the subscript lower limit is
    1, it need not be specified.  For example,

    LOCAL SP(35) is equivalent to LOCAL SP(1:35)

    Note: A subscript limit may in fact be any constant expression,
          including -KON; expressions are discussed in Section 1.E
          and 1.F.  Other types of declaration statements, and a
          statement that specifies the default subscript lower
          limit, are explained in Section 3.A.

    Refer to a simple variable by its identifier, and to an array
    element by the array identifier followed by the  subscript in
    parentheses.  The subscript may be any arithmetic expression.  Thus
    B(4) and PTR(JCT+1) are legal references to array elements.  The
    user must himself check that when referencing an array element, the
    value of the subscript lies within the range of the limits as
    specified in the declaration statement.  SIMPL does not perform any
    subscript checking and will react unpredictably if a subscript is
    out of range.

    An array identifier may be typed alone, not followed by a
    subscript, in which case its value is the base address of the array
    (the address of its 0th element).  For example, if an array is
    declared as B(3:50), the value of B+3 is the address of array
    element B(3), and B+4 is the address of B(4), and so on.  It can be
    seen from this that a simple variable and array cannot have the
    same identifier.

      1.C.1  Floating Arrays

    The user may also declare a "floating array", as follows:

    LOCAL ID()

    This allocates one word of storage which can be referenced by the
    identifier ID and set to a value which is then taken to be the base
    address of an array identified by ID.  This allows, for example,
    parts of an array to be addressed by different identifiers than
    that of the entire array. If the statement

    LOCAL TEXT(200),BLK1(),BLK2()

    is followed by the statements that set BLK1 to the value of TEXT
    (the base address of the array TEXT), and BLK2 to TEXT+100, then
    BLK1(x) is equivalent to TEXT(x), and BLK2(x) is equivalent to
    TEXT(x+100). Changing the value of BLK1 or BLK2 effectively moves
    or  "floats" the arrays they identify.  For example, exchanging
    their values causes BLK2 to reference the lower half of TEXT and
    BLK1 the upper half, rather than vice versa.


      1.C.2  Indirect Addressing -^

    The up arrow may be used to designate indirect addressing, that is,
    to refer to a word whose address is a specified value.  Thus, ^X
    refers to the variable whose address is stored in X.  What follows
    the ^ may be an identifier, subscripted or not, or an arithmetic
    expression in parentheses.  (Note: It may be any primary, as
    described in Section 1.L.) For example, suppose that an array is
    declared as

    LOCAL B(3:50)

    Since B is evaluated as the base address of the array, ^(B+3)
    refers to B(3) and can be used anywhere that B(3) can to address
    that particular storage word.


      1.C.3  Storage Word (SW)

    The different ways of addressing a storage word in SIMPL may be
    summarized as follows:

    1.  An identifier typed alone; e.g., X, BLK1

    2.  An identifier followed by a subscript in parentheses; e.g.,
         B(7), BLK1(I), PTR(L+3).

    3.  Indirect addressing using the  ^; e.g., ^X, ^PTR(L+3), ^(B+3).

    These three constitute the language element SW (storage word).

      1.C.4  Address Operator -@

    @ is a unary operator that operates on any storage word reference
    (SW) and returns the address of that word.  Note that the ^ and @
    cancel each other's effect.

    Example:

    If an array is declared as

    LOCAL B(3:50)

    then @B(3) is equal to B+3 (since B is the base address of the
    array).

1.D.  Labels

    A label may be an identifier followed by a colon, or, within the
    case statement (Section 3.C.2), a constant followed by a colon;
    that is,

    ID:
    or
    KON:   (only  within the case statement)

    A label may appear only at the beginning of a line. Since a line
    may be blank, a label may appear alone.  A line may have more than
    one label;  for example,

    L3: CPYRD:   statement

    Declaration statements, procedure heads and ends, and macro
    definition statements may not be labelled.

    Unlike variables and procedure heads, labels do not normally have
    to be declared.  For example, SIMPL can assume that an ID after
    the word GO identifies a label, since "GO variable" and "GO
    procedure" are illegal constructions.  In this case declaring the
    label would be redundant.  However, it is possible to use an ID
    where its function is not implicitly declared; for example, in the
    statement

    A_LAB

    which specifies that the value of LAB be stored in A, SIMPL can
    only  know what LAB identifies if an explicit declaration has been
    made. It may identify a label, enabling the user to branch
    indirectly by typing

    GO ^A

    In this case, then, LAB would have to be declared a label.

    To declare a label, type it in the LOCAL declaration statement, as
    follows:

    LOCAL ID:

    The KON: form of a label is declared within the case statement, the
    only statement in which it can appear.

1.E.  Arithmetic Expression

         1.E.1  Standard Mathematical Operators

         All arithmetic is fixed point.

         Binary operators:

         +     Addition
         -     Subtraction
         *     Multiplication (machine dependency: low-order word of
                  the result)
         /     Division
         MOD   Modulo operator; if x and y are both positive, x MOD
               y yields the remainder of the division of x by y in
               the standard mathematical sense of modulus.  If x or
               y is not positive, the results are unpredictable.
         MAX   Maximum
         MIN   Minimum

         Unary operators:

         ABS   Absolute value
         -     Negative; 2's complement (unary minus)

         1.E.2  Bit Operators

         These operators perform the specified operations on the bits
         of their operands.

         Binary operators:

         BAND   Binary and                  BITS.PER.WORD
         BOR    Binary inclusive or         bits at
         BXOR   Binary exclusive or         a time
         BEQV   Binary equivalence
         SHL    Logical left shift
         SHR    Logical right shift
         ROTL   Circular left shift
         ROTR   Circular right shift

         Unary operator:

         BNOT  Binary not; 1's complement

         The second operand of the shift operators specifies the shift
         count and must have a positive value.  For example, X SHL 3
         is calculated to be X shifted left 3 bit positions; the value
         of the expression X SHL -3 is not predictable.

    Note that the operators that are words as opposed to symbols, such
    as ABS and MOD, must be terminated by a space (or a
    non-alphanumeric character) since SIMPL allows identifiers to begin
    with these words.  For example, the strABSB and MOD2 are
    recognized as identifiers, not as operators and operands.

         1.E.3  Rules Governing Operands

         All of the above operators can operate
         on the SIMPL language element known as the primary, or PRIM
         (the complete definition of which is given in Section
         1.L).  Included in the PRIM category are a constant
         (KON), a storage word reference (SW), and a unary operator
         with its operand (such as @SW, ABS PRIM, -PRIM, and BNOT
         PRIM).


              Example:                           Illustrates:
              HEX FF + ABS J                     KON + ABS SW
              @X MOD Y                           @SW MOD SW
              ^C(I)*-3                           SW*-KON

         Clearly then, the operands in these examples all qualify
         as primaries.

       The expression resulting from the use of any of the arithmetic
       operators may be enclosed in parentheses and operated on
       further; that is, the expression enclosed in parentheses also
       qualifies as a primary.  Thus,

       (HEX FF + ABS J)+2
       (@X MOD Y)*(^C(I)*-3)

       are allowed as expressions.

1.E.4   Operator Precedence

       Several operators may appear in a single expression, as
       illustrated above or in the expression A+B/C.  The sequence of
       operations is given below.  Each numbered item in the list
       represents a level of precedence.  Several operators
       of the same precedence in a single expression are applied from
       left to right; for example, X-Y-Z is evaluated as (X-Y)-Z.

       1.      An expression in parentheses. For example, the
               sequence of operations in the evaluation of X-Y-Z can be
               reversed by using parentheses as follows:  X-(Y-Z).

       2.      Any unary operations.

       3.      The shift operations:  SHL, SHR, ROTL, ROTR.

       4.      The other bitwise operations:  BAND, BOR, BXOR, BEQV.
               Thus, A BOR B SHL 4 is evaluated as A BOR (B SHL 4).

       5.      Multiplication, division and MOD.  Thus, X2 MOD 4/2 is
               calculated as (X2 MOD 4)/2 (i.e., left to right), and
               X*Y SHL 4 is equivalent to X*(Y SHL 4).

       6.      Addition and subtraction.  For example, A+B/C is
               calculated  as A+(B/C).

       7.      MAX and MIN.  Thus, A+B MAX C is evaluated as the 
               maximum of A+B and C.

1.E.5    The  AE Classification

       An expression resulting from the use of the arithmetic
       operators is called an arithmetic expression, or AE.  As
       explained above, many of the arithmetic operators take primaries
       as their operands.  The AE classification also includes a
       primary alone, so that all of the following are classified as
       arithmetic expressions:

       16
       PTR
       ^ADR(K)
       BNOT S2
       A+B/C
       (A+3)

       The term AE as described here will be useful in defining other
       language elements of SIMPL.  For example, since a subscript may
       be any arithmetic expression, the general method of referencing
       an array element is

       ID(AE)

       Note that an AE may be parenthesized whenever desired;
       it will still qualify as an AE.

1.F  Constant Expression (KONEX)

     The previous section describes the AE, or arithmetic expression,
     classification.  A subset of this classification is the
     KONEX, or constant expression, which is an arithmetic
     expression having only KON type operands (excluding the string
     constant type of KON).  This classification can be used
     wherever it has been mentioned that a KON can be used.
     Thus, the general form of a LOCAL array declaration is
     LOCAL ID(KONEX:KONEX), and a label in a case statement can
     take the form KONEX:.

     This feature is valuable when used in conjunction with
     SIMPL macros, explained in Section 5.  For example, BUFSZ
     and NBUFS can be defined as the constants 200 and 5, so
     that the statement LOCAL A(BUFSZ*NBUFS) would be
     equivalent to LOCAL A(1000).

1.G.     Relational Expression

       The relational operators, or RELOPs, are:

       <       less than
       <=      less than or equal to
       =       equal to
       #       not equal to
       >=      greater than or equal to
       >       greater than

       Relational operators operate on arithmetic expressions (AEs)
       to form relational expressions, or RELs, which have logical
       values (true or false).  The different forms a relational
       expression may take are:

       1.      AE1 RELOP AE2

               Examples:

               A<3
               SYNTAB(IEW)=0
               HEX 17*X>=J+1 or (HEX 17*X)>=(J+1)

               Note from the last example that parentheses around the
               arithmetic expressions are optional; the arithmetic
               operators have a higher precedence than the relational.

              The order of evaluation of the AE's in a relational
              expression is a machine dependency.  For example, in
              an expression such as ^PTR < ^INC PTR, in which INC
              PTR increments the value of PTR by 1, it is possible
              that PTR on the left will be evaluated after PTR has
              been incremented on the right.

       2.      AE1 RELOP AE2 RELOP AE3

               This is equivalent to an AND of the values of the
               expressions AE1 RELOP AE2 and AE2 RELOP AE3.
               For example, $A<=CHAR<=$Z is true if CHAR is both
               greater than or equal to $A and less than or equal to
               $Z.  If either or both of the expressions $A<=CHAR and
               CHAR<=$Z  are false, then $A<=CHAR<=$Z is false.

               Note that when this form of the relational expression
               is used, the evaluation of the expression is ended as
               soon as a false condition is encountered.  Thus, if the
               first condition to be checked, AE1 RELOP AE2, is false,
               the value of the whole expression is considered false
               and AE2 RELOP AE3 is not evaluated.

       3.      AE

               An AE alone may be used as a relational expression: it
               is true if its value is non-zero, false if its value
               is zero.

       4.      NOT REL

               Each of the above forms may be preceded by NOT to form
               a relational expression whose value is the logical NOT
                of the value of the expression modified.

               For example:

               NOT A<3          true if A>=3
                                false if A<3

               NOT $A<=CHAR<=$Z  true if $A>CHAR or CHAR>$Z
                                 false if $A<=CHAR  and CHAR<=$Z

               NOT FLG           true if FLG=0
                                 false if FLG#0

1.H.     Logical Expression

       As explained above in the description of relational expressions,
       a REL may be preceded by the logical operator NOT to form a
       construction that is also classified as a REL.

       Relational expressions may be operated on by the logical
       operators AND and OR as well; that is,

       REL1 AND REL2         Example:  A=6 AND NOT CD<3
       REL1 OR REL2                     A=6 OR B>=BNOT J

       Parentheses around the RELs are optional, since the relational
       operators have a higher precedence than the logical.

       The expressions resulting from the use of the logical operators
       are called logical expressions and may themselves be
       parenthesized and operated on by NOT, AND, and OR.  For example:

       NOT(CHAR<$A OR CHAR>$Z)
       (A<3 AND B<4) OR C=6
       (A=6 OR B>=BNOT J) AND (X<Y OR Z=1)

       In fact, the logical expression (LE) classification includes
       all of the following:

       x
       x {OR/AND] x
       x {OR/AND] x {OR/AND] x...   any number of ORs and ANDs

       where x may be REL, (LE), or NOT(LE).  (Remember that REL
       includes the construction NOT REL.)

       It can be seen from this that several logical operators may
       appear in a single expression without benefit of parentheses
       to clearly indicate the precedence of operations.  The
       precedence after parenthesized expressions are evaluated is:
       first NOT, followed by AND,  and finally, OR.  Thus,

       A=6 AND NOT CD<3 OR C=6

       is evaluated as

       (A=6 AND (NOT CD<3)) OR C=6

       The evaluation of a logical expression is ended as soon as it
       is known whether the expression is true or false. For example,
       the expression

       b OR c OR d OR e

       is considered true as soon as an operand is encountered  that is
       true. Thus, if b is false and c is true, b OR c is true, as is
       therefore the entire expression; no further evaluation is made.

       This rule is especially significant when the expression
       includes a construction that has a side effect when evaluated,
       such as INC SW, which increments SW and is evaluated as the
       incremented value.  Consider the expression:

       INC K>10 AND INC J>1

       K will be incremented. If the incremented value is less than or
       equal to 10, INC K>10 is false, so that the entire expression
       is false; INC J>1 is never evaluated,
       which means that J is not incremented.
       However, if  INC K is greater than 10, SIMPL proceeds to
       evaluate INC J>1, so that J will be incremented in this case.

       When a logical expression is enclosed in brackets, it is given
       an arithmetic rather than a logical value: 1 if the LE is
       true and 0 if it is false.  For example,

       2+[B=3]
       2+[A=6 OR B>=BNOT J]

       Each of the above expressions equals 2 if the enclosed LE
       is false, and 3 if it is true.

       The construction [LE] is classified as a primary; thus it
       can be operated on by an arithmetic operator (as
       shown above) and can be used wherever it is stated in this
       document that a primary can be used.

1.I      Conditional Expression

       The conditional expression takes the form

       IF LE THEN AE1 ELSE AE2

       and is a primary that is evaluated as AE1 if  the logical
       expression LE is true, and AE2 if LE is false.

       Example 1:

               2* IF I=100 THEN J ELSE J+1

       is evaluated as 2*J if I=100, and 2*(J+1) if I #100

       Example 2:

               PCP(IF A<3 THEN 1 ELSE 0)

       references the storage word PCP(1) if A<3, and PCP(0) if A>=3.
       Note that this could also have been written as

       PCP([A<3])

       Example 3:

               Y-(IF X>Z THEN A ELSE B)*2

       is evaluated as Y-A*2 if X>Z and Y-B*2 if X<=Z.
       Note that if the parentheses are omitted, the multiplication
       by 2 applies to B only.  The user should guard against errors of
        this nature when operating on conditional expressions.

1.J      Operators with Side Effects

       The SIMPL constructions using the operators described below
       are classified as primaries; each of them not only has an
       arithmetic value as do other primaries,
       but also has the side effect of taking some specific action.
       The NCHV and PCHV operators, also in this category, are
       explained in Section 1.K.

1.J.1    INC and DEC

       INC and DEC are unary operators that operate on any storage
       word reference (SW).  INC SW increments SW by 1 and returns
       the incremented value.  Similarly, DEC SW decrements SW by 1
       and returns the decremented value.  Note that the value of the
       storage word referenced is actually changed when either of these
       operators is used.  For example, if I=0, INC I sets I to 1 and
       returns the value 1, so that the next use of INC I would set I
       to  2 and return the value 2, and so on.

       The constructions INC SW and DEC SW are thus classified
       as primaries (PRIM); however, they also classify as statements
       in themselves, that increment and decrement the SW.

1.J.2    Assignment - _

       The assignment operation takes the form

       LP_AE

       and constitutes a primary which causes the value of the AE
       (arithmetic expression) to be stored in the left part (LP);
       the primary is evaluated as that value. For a complete list of
       legal left parts, refer to Section 3.B.1, the description of
       this construction when used as a statement.

       Example 1:

       P(I_SYM(LOC)-J)

       sets I to the value of the expression SYM(LOC)-J and
       references the array element P(I).

       Example 2:

       The relational expression

       $ <=CHAR_TTY

       causes a character to be read from the terminal, stored in
       CHAR and compared to a blank.

       Note that if the AE of LP_AE is itself an assignment, the
       construction appears as, for example,

       X_Y_I

       which assigns the value of I to both X and Y.  In general
       this extends to

       LP1_LP2_...LPn_AE

1.J.3    Deferred Assignment - <==

       The deferred assignment operator is used as follows:

       SW<==AE

       This construction is classified as a primary only.  It has
       the same side effect as regular assignment; that is, it stores
       the value of AE, an arithmetic expression, in SW, a storage
       word. However, this primary is evaluated not as the value of AE,
       but as the value of SW before the assignment is made.   In other
       words, the assignment is deferred until after the value of the
       primary is taken to  be SW.

       Example 1:

       The statements

       J_K
       K_T

       assign the value of K to J and then set K to the value of T.
       This can alternately be written as

       J_K<==T

       Example 2:

       The value of the expression

       BFSZ*LNK<==BLK(N)+1

       is BFSZ multiplied by whatever is the value of LNK immediately
       before the expression is encountered.  After the expression is
       so evaluated, the value of BLK(N)+1 is assigned to LNK.

       Note that not all the forms of the LP, the left part of a
       regular assignment, may appear to the left of the <==; only an
       SW is permitted.


1.J.4   Storage Word Modification

       The storage modification operation may be unary or 
       binary.  The unary operations are represented by

       SW -_
       SW ABS_
       SW BNOT_

       That is, a storage word followed by any of the unary
       arithmetic operators, followed by a back arrow.  The
       specified operation is performed on the SW, so that, for
      example, SW-_ is equivalent to SW_-SW (but produces more
       efficient code).

       The binary arithmetic operators, excluding the shift
       operators and MOD, may similarly be used for storage
       modification, as follows:

       SW+_AE

       In this case, SW is incremented by the value of AE.

       When used as primaries, these constructions are evaluated
       as the modified value of the storage word; however,
       they may also be used as statements in themselves.

1.K      Functions and Other Operators


1.K.1    Character and Half Word Handling


1.K.1.1       CH (and HW)

       CH is a function that takes two arithmetic expressions as
       arguments; that is,

       CH(AE1,AE2)

       It returns the value of the character (the size of which is a
       machine dependency) located AE2 character positions from the
       first character of the word addressed by AE1.  In other
       words,

       AE1 is the word address
       AE2 is the character displacement

       The second argument may be omitted, in which case it is assumed
       to be zero; CH(AE) is equivalent to CH(AE,0).

       Example  1 (machine dependent - Sigma 7):

       If the value of the simple variable A is HEX 12345678,
       CH(@A) equals HEX 12 and CH(@A,1) equals HEX 34.

       Example 2:

       The statement

       TS_'ABCDEF'

       stores the value of the string constant 'ABCDEF' in TS.
       Since this value is the address of the first word of the string,
       CH(TS) equals $A (whatever is the internal representation of the
       character A), and CH(TS,5) equals $F.

       The above examples use the CH construction as a primary whose
       value is the character addressed; however, it can also be used
       to set a character to a value.  For example, the assignment

       CH(TS,1)_$G

       stores the internal representation of the character G in the
       second character position of the string 'ABCDEF'.  Thus, the
       CH construction can also be used as an LP, the left part of
       an assignment.

       Half words are handled in a perfectly analogous way.  The
       function  is  HW rather than CH; AE2 is a half word displace-
       ment.


1.K.1.2       CHPT (and HWPT)

       CHPT is a function that takes the same type of arguments
       as the CH function, that is,

       CHPT(AE1,AE2)
          or
       CHPT(AE1) if AE2=0

       where AE1 is the word address and AE2 is the character
       displacement.

       The value returned is a character pointer which may then be used
       with the CHV, NCHV or PCHV  operator, described
       below. The actual  value need not be known and should not be
       altered by the user.

       The CHPT construction may also be used as an LP, the
       left part of an assignment.

       CHPT (SW1,SW2)_AE

       where the value of AE is a character pointer, assigns
       to SW1 the corresponding word address, and to SW2, the
       character displacement (a value between 0 and CHARS.PER.WORD-1).

       The HWPT function is perfectly analogous to CHPT,
       with half word rather than character displacement.


1.K.1.3   CHV (and HWV)

       CHV is a unary operator that operates on a storage
       word (SW) whose value is the character pointer that the
      CHPT function returns.

       CHV returns the character  to which its
       argument points; that is, if PTR=CHPT(AE1,AE2), then
       CHV PTR = CH(AE1,AE2).

       The CHV construction can be used in the same ways that CH can -
       as a PRIM or as an LP (the left part of an assignment).
       The CH description (above) includes an  explanation and
       illustration of this.

       HWV is the corresponding operator for half word handling.

1.K.1.4       NCHV (and NHWV)

       NCHV is a unary operator  that operates on a
       storage word  (SW) whose value is the character pointer that
       the CHPT function returns. NCHV SW increments SW so that it
       points to the next character and returns that character (the CHV
        of the incremented character pointer).

       The NCHV construction can be used in the same ways that the CHV
       construction can: as a primary (evaluated as the next character)
       or as the left part of an assignment (where it may be
       used to set the next character to a particular value).  For
       example, the statements

       TS_'ABCDEF'
       P_CHPT(TS,-1)

       store in P the pointer to the character preceding the first
       character of the string 'ABCDEF' (displacement of -1), so that

       1.      Used as a primary, NCHV P would have the value
               $A; its next use would be evaluated as $B, and so on.

       2.      Used as an LP (the left part of an assignment),
               NCHV P would store the specified value in the first
               character position of the string; its next such use
               would store into the next position, and so on.

       A third use of the NCHV SW construction is as a statement in
       itself, in which case it simply increments the pointer SW so
       that it points to the next character.

       For corresponding half word handling, use NHWV SW, where SW
       has the value of the half word pointer HWPT(AE1,AE2); it
       will increment SW and refer to the next half word.


1.K.1.5  PCHV (and PHWV)

      The constructions PCHV SW and PHWV SW are perfectly analogous
      to NCHV SW and NHWV SW; they decrement rather than incre-
      ment SW, to return the previous rather than the next character
      or half word.

1.K.2    Bit Field Manipulation

1.K.2.1    BYT Function

       BYT is a function that returns a byte of any size from any
       position in a word.  It takes three arguments:

       BYT(AE,AE1,AE2)

       The value of AE is the word, and

       AE1 is the field width (number of bits in the byte)
       AE2 is the bit displacement from the right (positive only)

       For example, if the following is a diagram of the variable A,

       HEX C           HEX 2A1          HEX 6BF2
       4 bits          12 bits          16 bits

       then BYT(A,4,28)=HEX C, BYT(A,12,16)=HEX 2A1, and
       BYT(A,16,0)=HEX 6BF2.

       The BYT construction may be  used as a primary, in which case
       it is evaluated as explained above, or it may be used to set a
       byte to a value (as an LP, or left part of an assignment).
       As an example of  the latter, consider the statement

       BYT(A,4,28)_HEX F

       which stores the value HEX F   in the byte referenced by BYT(A,4,
       28).  Note that when the BYT construction is used as a left
       part, its form  must be

       BYT(SW,AE1,AE2)

1.K.2.2    Word Packing and Unpacking

       The SIMPL construction

       [KONEX1,KONEX2,...,KONEXn]*[AE1,AE2,...,AEn]

       is a primary that returns the value of the word formed by
       packing the values of the listed arithmetic expressions into
       bit fields whose widths are specified by the listed constants.
       In other words, the first KONEX1 bits of the word will hold the
       value of AE1, the next KONEX2 bits, the value of AE2, and so on.
       The sum of the constants must be the total number of bits in
       a word.  Each AEi is evaluated in the usual way (i.e., as a
       word value); KONEX1 bits are taken from the right of the value,
       so that an AE value too large for its field will be truncated
       from the left.

       Example 1:

       [4,12,16]*[HEX C,X,^PTR+1]

       where X=HEX 2A1  and ^PTR+1=HEX 6BF2, returns the value of the
       variable A as diagrammed in the BYT function description, above.

       The construction

       [KONEX1,KONEX2,...,KONEXn]*[LP1,LP2,...,LPn]

       can be used as an LP (left part of an assignment) to unpack bit
       fields from a word.  The value of the AE (of LP_AE) is divided
       into  n bit fields as specified by the listed constants, and LPi
       is  assigned the value in its corresponding field.  The sum of
       the constants must be BITS.PER.WORD.

       Example 2:

       Assume that the variable A has the value of the primary shown
       Example 1.  Then

       [4,12,16]*[X,Y,Z]_A

       assigns HEX C  to X, HEX 2A1  to Y, and HEX 6BF2  to Z.   
       Suppose that we want to assign the value of only the second 
       field of A:

       [4,12,16]*[,Y,]_A

       assigns HEX 2A1  to Y. An LP1 was not specified, so the first four
       bits of A were not assigned to a left part.  The third field
       was also ignored, since a third left part was not listed.

1.K.3

       TTY is a function with no arguments.  It may be used as a
       primary, in which case it accepts a character of input from
       the terminal and is evaluated as the internal representation
       of the character read.  For example:

       CHAR_TTY

       reads a character from the terminal and stores its value
       in CHAR.

       TTY may also be used as follows:

       TTY_AE

       where it is an LP, or left part of an assignment.  In this case,
       the character represented by the value of the AE is printed on
       the terminal.  Thus, if CHAR has the value $A,

       TTY_CHAR

       prints an A on the terminal.

1.L      Primary (PRIM)

       Several SIMPL constructions described in this section have been
       classified as primaries (PRIM), and it has been stated that
       certain operators can take only primaries as their operands.

       Listed here are all those constructions which constitute the
       PRIM category and examples of each.  This is an important
       classification, since it is from primaries that arithmetic
       expressions are built, and therefore relational and logical
       expressions as well.

       1.      Constant (KON) -  $A,17
       2.      Storage word reference (SW) - B, ^PTR(I)
       3.      Unary operator with its operand - ABS PRIM, -17, NCHV
               SW, @VAR(J1)
       4.      Function with its argument list, if any -
               CH(@A), BYT(Q,5,6), TTY
               Special word packing function -
                          [4,12,16]*[HEX C,X,^PTR+1]
       5.      Arithmetic expression in parentheses - (I+3),
               (TRM BAND S(I))
       6.      Relational expression in square brackets (value of 1 if
               true, 0 if false) - [B=3], [NOT SYM(IW)<C]
       7.      Conditional expression - IF B<7 THEN J ELSE J+1
       8.      Assignment operation - I_SYM(LOC)-J
       9.      Deferred assignment - X<==Y
       10.     Storage Word Modification - B-_,CNT+_D+2
       11.     Procedure calls (explained in Section 4) -  CLR,
               TYP2(VAL)

       Note that a PRIM may be parenthesized
       whenever desired; it will still qualify as a PRIM.

1.M      Doubleword Manipulation

1.M.1    Doubleword Arithmetic Expression

      The doubleword arithmetic expression, or DAE, yields a
      doubleword value that can be assigned to a double
      left part (see below).  A simple form of the DAE is

      [AE1;AE2]

      where AE1 is the most significant, and AE2 the least
      signficant, word of the value.  For example,

      [-1;0]
      [A;X*Y]

      The operators used in forming doubleword arithmetic expressions
      are explained below.  Note the different operand types:
      DMUL, MODDIV and DIVMOD operate only on AEs (single word
      arithmetic expressions), while each of the remaining operators
      takes a DAE as its first argument.  All return doubleword values.

      Expression (DAE):                    Result:

      AE1 DMUL AE2                  Doubleword product of AE1 and AE2
      AE1 MODDIV AE2                Modulo division.  Most significant
                                    word of result is remainder; least
                                    significant is quotient.  (More
                                    efficient than DIVMOD on certain
                                    machines, such as Sigma 7)
      AE1 DIVMOD AE2                Modulo division.  Most significant
                                    word of result is quotient; least
                                    significant is remainder.  (More
                                    efficient than MODDIV on certain
                                    machines, such as PDP-10)

      DAE DMODDIV AE                Same result as MODDIV
      DAE DDIVMOD AE                Same result as DIVMOD
      DAE DSHL AE                   Doubleword logical left shift
      DAE DSHR AE                   Doubleword logical right shift
      DAE DROTL AE                  Doubleword circular left shift
      DAE DROTR AE                  Doubleword circular right shift

      Examples:

      CP DIVMOD EBUFSZ
      [X,Y] DMODDIV B
      C DMUL FPC DSHL 2

      To improve the readability of an expression such as the last
      example above, SIMPL allows any DAE to be parenthesized; thus
      C DMUL FPC DSHL 2 may also be typed as (C DMUL FPC) DSHL 2.

      The second operand of the shift operators (the AE) specifies the
      shift count and must have a positive value.  A negative shift
      count yields unpredictable results.

      Another form of the doubleword arithmetic expression is DOUBLE
      preceding a call to a procedure that terminates with a RETURN
      DAE statement.  In addition, DAEs can be passed as arguments
      to a procedure.  Additional details are included in the de-
      scription of procedures, in Section 4 of this document.

1.M.2    Doubleword Assignment

      The doubleword assignment construction is

      DLP_DAE

      where DLP, the double left part, takes the form [LP1,LP2].
      The most significant word of DAE is assigned to LP1, and the
      least significant to LP2.  This construction classifies as a
      SIMPL statement or as a DAE.  Note that since the DAE of
      DLP _ DAE may be another doubleword assignment, whose DAE
      may be another assignment, and so on, the following
      construction is permitted:

      DLP1 _ DLP2 _ ...DLPn _ DAE

      with the result that DAE is assigned to each of the DLPs listed.

      Either LP of the DLP may be omitted, as in

      [LP;] _ DAE DMODDIV AE

      where the remainder of the division of DAE by AE is stored in
      the specified left part.  Similarly, [;LP] can be used as a
      DLP reference to the least significant word of a doubleword
      value (the quotient, in the above example).

      Note: Neither AE of the DAE form [AE1;AE2] may be omitted.

$
                               Section 2
                         Program Structure


2.A      Statement Delimiters

       A SIMPL program is made up of statements, usually separated by
       carriage returns.  Successive occurrences of a certain type of
       statement, known as the SST or short statement, may be separated
       by semicolons rather than carriage returns if desired. A
       subset of SIMPL statements will be classified in this
       document as SSTs; one of them is the assignment statement.
       Thus, the statements

       I_1
       A2_0
       NEWCHAR(J)_6

       may alternately be typed as:

       I_1; A2_0; NEWCHAR(J)_6

       A label may appear at the beginning of this line, before the
       statement I_1. But the other statements cannot be labelled,
       since a label may never appear in mid-line.

2.B      Compound Statements

       Several SIMPL statements may be compounded to form a single
       statement.

2.B.1    Compounding Short Statements

       Short statements may be compounded as follows:

       [SST1;SST2;...;SSTn]

       A label is not permitted within the brackets.

       This construction is itself classified as an SST.  Thus an
       example of the IF statement, whose simplest general form is
       IF LE THEN statement, is

       IF IK=0 THEN [J_1;K(I)_I]
           LE          SST

       Note that without the surrounding brackets, the semicolon
       serves merely to separate the SSTs as does the carriage return.
       Thus,

       IF IK=0 THEN J_1;K(I)_I
            SST           SST

2.B.2    Compounding with DO...END

       Any SIMPL statements may be compounded through the use of the
       DO...END construction, which takes the form

       DO
       statement1
       statement2
       ...
       statementN
       END

       Any of the statements compounded in this way may be labelled.
       The only restriction is that on labelling in general - a label
       must appear at the beginning of a line.  If the statements are
       SSTs (short statements), they may be separated by semicolons if
       desired, but a carriage return must follow DO and precede END.

       The DO...END construction itself is considered a single
       statement and can therefore be labelled, compounded, and what-
       ever else can be done with a SIMPL statement.  Note, however,
       that it does not fall into the SST classification.

       Example:

               A compound statement may follow  the word THEN
       in an IF statement, so that the following is allowed:

       IF PL THEN DO
       J_1
       K_[PL>=1]
       I(K)_PL
       END

2.C      Line Continuation -&

       An & followed by a carriage return is ignored by SIMPL,
       thereby allowing program line continuation over any
       number of physical lines.  For example,

       L1: IF I=0 THEN J_0 ELSE &
           P(I)_RCDPNT(I)

       is read by SIMPL exactly as  though it had been entered as

       L1:  IF I=0 THEN J_0 ELSE P(I)_RCDPNT(I)

       Note that &  does not allow the user to have labels in mid-line;
       in the example here, a label cannot precede P(I) when the line
       is continued just as it cannot when line continuation is not
       used.

2.D      Comments -!

       Program comments may be entered using the exclamation point.
       To enter a comment at the end of a line, precede it by a !.
       Anything typed between the ! and the end of the line (except
       for another !; see below) will be ignored.  For example,

       DCTPTR_@DCTTBL(0)    !THE DICTIONARY PTR

       Any characters typed between exclamation points are ignored,
       thereby allowing comments to be entered in mid-line.
       For example,

       DCTPTR  !THE DICTIONARY PTR!   _@DCTTBL(0)

       The second exclamation point indicates the end of the comment.
$
                               Section 3
                          Statements of SIMPL

3.A      Declaration Statements

3.A.1    LOCAL Declaration

       The LOCAL statement is used to declare variables and
       procedures, which must always be declared, and labels,
       which may be declared.  Details on the declaration of any of
       these language elements may be found in the section describing
       that element.

       The general form of the LOCAL statement is

       LOCAL d1
          or
       LOCAL d1,d2,...,dN

       where dI may be any of the declarations listed below.

       General form:            Element declared:

       ID                         Simple variable
       ID(KONEX1:KONEX2)          Array with subscript range
                                  KONEX1 to KONEX2
       ID(KONEX)                  Array with subscript range 1 to KONEX
       ID()                       Floating array
       ID:                        Label
       %ID                        Procedure

       The declaration of a SIMPL language element must precede its
       first use.  Redeclaration (successive declarations using the
       same identifier) is not permitted.

3.A.2    TABLE Statement

      The TABLE statement may be used to declare read-only variables
      and arrays and fill them with specified constant values (which
      cannot be changed).  The constant values may be represented
      by the KONEX construction (such as BITS.PER.WORD/2)
      or by a string constant (such as "ABCDE").  The table
      statement takes the form:

      TABLE d1
        or
      TABLE d1,d2,...,dN

      where dI may be any of the declarations explained below.

      To declare a simple variable ID and set it to the value of KONEX,
      enter the declaration

      ID[KONEX]

      in the TABLE statement; for example,

      TABLE X[0]

      To declare an array and set its elements to a list of values,
      first enter the array declaration as it would appear in any other
      declaration statement; that is, ID(KONEX1:KONEX2) or ID(KONEX). 
      Follow this immediately by a list of constants enclosed in
      brackets, for example,

      TABLE ABC(0:3)[1,2,3,0]

      If fewer constants are listed than array elements declared, SIMPL
      fills the rest of the constant list with zeroes.  Thus, in the
      above example, the closing bracket could follow the 3 in the
      constant list, and ABC(3) would still be initialized to 0. 
      Listing more constants than elements declared is considered an
      error by SIMPL.

      The constant list may also include the construction
      KONEX1(KONEX2), which indicates the repetition of the value
      KONEX2, KONEX1 times. For example,

      TABLE FCB(8)[3,0,0,0,0,0,0,1]

      can more easily be entered as follows:

      TABLE FCB(8)[3,6(0),1]

3.A.3    GLOBAL and FIND

      A number of SIMPL source files can be compiled separately and
      loaded together in such a way that they share procedures,
      variables and other language elements.  Two types of declaration
      statements must be used to accomplish this sharing of elements:
      GLOBAL and FIND, which take the same form as the LOCAL statement:

      GLOBAL list of declarations
      FIND list of declarations

      The GLOBAL statement must be used in place of LOCAL when the
      declared element is to be referenced from another file (that is,
      when it is to be shared).  Similarly, the FIND statement must be
      used to declare that an element is to be found elsewhere than
      in the current file; the SIMPL loader will search the other
      files entered for a GLOBAL statement declaring that element.

      It is not necessary, in FINDing an array, to enter the
      declaration exactly as it appears in the GLOBAL statement.  As
      long as there is a constant within the parentheses - to
      distinguish it from a floating array, whose declaration is ID() -
      the array will be found.  For example, an array declared as

      GLOBAL HEAD(0:100)

      may be found with

      FIND HEAD(0:100)

      or just

      FIND HEAD(0)

      or FIND HEAD followed by any parenthesized constant.

      TABLE statements may also be GLOBALly declared; for 
      example

      GLOBAL TABLE COMWD(4)['EDIT', 'LIST', 'RUN', 'ZZZZZ']

      which may be found by

      FIND COMWD(1)

3.A.4    BASE Statement

      When the subscript lower limit is not specified in a LOCAL, 
      GLOBAL or TABLE array declaration, the limit is normally assumed
      to be 1; that is,

      LOCAL ID(50)

      is equivalent to LOCAL ID(1:50).  However, the BASE statement may
      be used to change the default lower limit to a specified
      constant. 

      BASE KONEX

      sets the default lower limit to the value of KONEX.  For example,
      BASE 0 causes LOCAL ID(50) to be equivalent to LOCAL ID(0:50).
      The specified limit applies to all subsequent array declarations
      and may be changed at any time by another BASE statement.

3.B      Value Manipulation

       The statements described here are SSTs (short statements) that
       can be used to store values into a word, doubleword, half word,
       character, or bit field, exchange and move values,
        and increment or decrement the value of a storage word.

       Most of these constructions can also be used as primaries,
       as explained in Section 1.

3.B.1    Assignment Statement

       The assignment statement takes the form

       LP_AE

       and stores the value of the AE (an arithmetic expression) in
       whatever is specified by the LP, or left part.  The following
       is a complete list of legal left parts:

       1.      Storage word reference (SW).

       2.      Character and half word references:

               CH(AE1,AE2)      HW(AE1,AE2)
               CHPT(SW1,SW2)    HWPT(SW1,SW2)
               CHV SW           HWV SW
               NCHV  SW         NHWV SW
               PCHV SW          PHWV SW

       3.      Bit field references:  BYT(SW,AE1,AE2) and
               [KONEX1,KONEX2,...,KONEXn]*[LP1,LP2,...,LPn]

       4.      TTY, designating terminal output; for example, TTY_$A
               prints out the  character A.

       Since the assignment construction also qualifies as a primary,
       the AE of LP_AE may be another assignment, whose AE may be
       another assignment, and  so on, allowing the construction:

       LP1_LP2_...LPn_AE

3.B.2   Doubleword Assignment Statement

      The doubleword assignment statement takes the form

      DLP _ DAE

      and stores the value of DAE (a doubleword arithmetic expression)
      in the specified double left part, DLP, which may take any
      of the forms

      [LP1;LP2]
      [LP1;]
      [;LP2]

      LP1 is assigned to the most significant, and LP2 the least
      significant, word of the DAE.  Since the doubleword assignment is
      itself classified as a DAE, the following type of construction is
      permitted:

      DLP1_DLP2_..._DLPn_DAE

      where DAE is assigned to each of the DLPs listed.

      Further information on doubleword manipulation may be found in
      Section l.

3.B.3   Storage Word Modification

      The operation performed by a storage word modification
      statement may be unary or binary.

      An SW followed by any unary arithmetic operator, followed
      by a back arrow, causes the specified operation to be
      performed on the SW.  Thus, SW-_ negates the contents
      of SW.

      The binary arithmetic operators, excluding the shift
      operators and MOD, may similarly be used for storage
      modification, as follows:

      SW+_AE

      In this case, SW is incremented by the value of AE.

      This construction also qualifies as a primary; thus,
  
      A_B BNOT_

      leaves the 1's complement of B in both B and A.

3.B.4   Exchange Statement

       The exchange statement takes the form

       SW1<=>SW2

       and exchanges the values of the specified storage words.


3.B.5  MOVE Statement

       The MOVE statement may be used to move a number of values from
       one set of consecutive locations to another, as follows:

       MOVE AE1 FROM AE2 TO AE3

       AE1 specifies how many values are to be moved.
       AE2 is the address from which to move the first value.
       AE3 is the address to which to move the first value.

       For example,

       LOCAL BLK(0:49),TEST(100)
       .
       .
       .
       MOVE 50 FROM BLK TO TEST+1

       replaces TEST(1) by the value of BLK(0), TEST(2) by BLK(1), and
       so on, until 50 values have been moved.  This statement could
       also have been written as

       MOVE 50 FROM @BLK(0) TO @TEST(1)

       The MOVE statement may also be used to store a single specified
       value in a number of consecutive locations, as follows:

       MOVE AE1 FROM ALL AE2 TO AE3

       AE2 specifies the value to be moved.  For example,

       MOVE N FROM ALL 0 TO STP

       stores 0 in STP(0) to STP(N-1).

3.B.6    INC and DEC

       INC SW

       increments the specified storage word.

       DEC SW

       decrements the specified storage word.

3.B.7    NCHV and NHWV

       The NCHV statement takes the form

       NCHV  SW

       where SW is a storage word whose value is a character pointer
       (as returned by the CHPT function; see Section 1.K.1).  NCHV SW
       increments SW so that it points to the next character.

       NHWV SW

       is the corresponding statement for half word handling (a half
       word pointer is returned by the HWPT function).

3.B.8    PCHV and PHWV

      The statements PCHV SW and PHWV SW are perfectly analogous to
      NCHV SW and NHWV SW: they decrement rather than increment
      SW, to point to the previous rather than the next character
      or half word.

3.C      Transfer of Control

       3.C.1     Unconditional Transfer: GO

               The GO statement may take either of the forms

               GO ID
                 or
               GO ^PRIM

               The first form transfers control to the statement
               labelled ID:.  When the second form is used, the loca-
               tion to which the transfer is made is the value of PRIM
               (a primary).  For example,

               LOCAL A,LAB1:,LAB2:
               A_LAB1    !NECESSITATES DECLARATION
               GO ^A     !SAME AS GO LAB1
               A_LAB2
               GO ^A     !SAME AS GO LAB2
               LAB1:  statement
               LAB2:  statement

               The variable A is assigned the value of LAB1, so that
               GO ^A branches to the statement labelled LAB1.  A is
               then reset to LAB2, changing the effect of GO ^A.  Note
               that the actual value of a label need not be known and
               should not be altered by the user. It is very unlikely,
               for example, that a label value plus 1 will address the
               next statement. When then might the  PRIM of GO ^PRIM be
               some arithmetic expression?  Consider the following
               case:  the user has stored in an array named W some data
                (which are machine instructions) that he wishes to
               branch to. Since W is evaluated as the  base address of
               the array, the statement

               GO ^(W+I)

               will branch to the Ith entry in the array W.

       3.C.2     Case Statement

               The case statement takes the form

               DO AE OF KONEX1:KONEXn
               statements (some labelled with constants
               that lie in the range KONEX1 to KONEXn)
               END

               KONEX1:KONEXn indicates the range of expected values of
               the AE, an arithmetic expression; if the AE should have
               a value out of this range, the results will be
               unpredictable. SIMPL evaluates the AE and then searches
               within the case statement for a statement labelled with
               a KONEX whose value is the value of the AE.  If found,
               control transfers to that statement and execution
               continues  sequentially with the next statement until
               another  constant label or the END of the case statement
               is encountered. Unless a statement was executed that
               transferred control elsewhere, execution then continues
               with the statement following the case statement (that
               is, following the END).  If a statement labelled with
               the value of the AE is not found within the case
               statement, SIMPL does nothing but continue execution
               with the statement  following the END. KONEX1 need not
               be specified if its value is 1; that is,

               DO AE OF KONEX

               is equivalent to

               DO AE OF 1:KONEX

               Example:

               DO LOB OF 6
               2: 4:  5:  GO RTEST
               1:         LAB _ GEN(SUM)
                          INC GSUM
               3:         BRF(BLP) _ LAB
               6:         VAL _ 0
               END

               If the value of LOB is 2, 4, or 5, a transfer to the
               statement labelled RTEST is made. If LOB equals 1,
               the statements LAB_GEN(SUM) and INC GSUM are executed,
               followed by whatever follows the END.  Similarly, if
               LOB equals 3 or 6, the statement so labelled is executed
               and SIMPL proceeds with the statement after the END.

               Note that the above example illustrates multiple
               labels on a statement, a useful construction within
               the case statement.  Note also that the constant labels
               need not appear in any particular order.

               Constant labels are permitted nowhere else in a SIMPL
               program other than within a case statement.  The same
               constant label may appear within different case
               statements in the same program; each case statement
               searches only up to its own END for a constant label.
               Since  GO KONEX is not permitted by SIMPL,  a branch to
               any statement within the case statement implies that
               that statement must be labelled with an identifier.
               For example, suppose that the above example is to be
               extended so that if  LOB equals 1, an additional
               statement, VAL_0, is to be executed.  VAL_0 already
               appears within the case statement and can be branched to
               as follows:

               DO LOB OF 6
               2: 4: 5:  GO RTEST
               1:        LAB _ GEN(SUM)
                         INC GSUM; GO TP
               3:        BRF(BLP) _ LAB
               6: TP:    VAL _ 0
               END

               Here we have added GO TP (taking the option to separate
               it from INC GSUM with a semicolon rather than a
               carriage return).   The statement labelled 6: is now
               also labelled TP:.

               The user may branch from outside the case statement to
               anywhere within it; the subsequent transfer of control
               follows the same rules as when a "normal" entry into
               the case statement is made.  Thus, if the statement
               labelled 3: in the above example were changed to

               ABC: 3: BRF(BLP)_LAB

               then GO ABC appearing outside the case statement would
               transfer control here. BRF(BLP) would be set to LAB and
               execution would continue with the statement following
               the  END.

               Note that since a constant label terminates execution
               within the case statement (by transferring control to
               the statement following the END), SIMPL will not proceed
               from any line, even a blank line, to one that is
               labelled with a constant.  For example, if the case
               statement appears in part as:

               DO CHAR OF $A:$Z
               $Q:$R:$Z:
               $L:$M:$N: GO NTCH
               .
               .
               .
               END

               and CHAR equals $Q,$R or $Z, the effect will be the
               same as if those three labels were excluded from the
               case statement:  control would transfer to the
               statement after the  END.  Note that this is equivalent
               to omitting the labels $Q:, $R:, and $Z from within the
               case statement.

               SIMPL reacts  unpredictably if the value of the AE does
               not lie within the specified range. It is, however,
               simple enough to check for this condition by using the
               IF statement; for example,

               IF $A<=CHAR<=$Z THEN DO CHAR OF $A:$Z
               .
               .
               .
               END ELSE GO INP.ERR

               A complete description of the IF statement can be found
               in Section 3.D.2.

3.D      Conditional Statements

       3.D.1     The STMT Classification

               The discussion of conditional and loop control state-
               ments will refer to the STMT classification.  This
               includes the following constructions:

               1.    Any SST, or short statement.  Remember that
                     this includes the construction [SST1;...;SSTn]
               2.    The IF statement, explained below.
               3.    The case statement.
               4.    A compound statement formed by using
                     DO...END.  Remember that any statements
                     can be compounded in this way.

       3.D.2     IF Statement

               The IF statement takes the form

               IF LE THEN STMT1
                   or
               IF LE THEN STMT1 ELSE STMT2

               If the logical expression (LE) specified is
               true, STMT1 is executed; unless STMT1 caused
               a transfer of control to another statement, execution
               continues with the statement following  the IF
               statement.  If the LE specified is false and an
               ELSE  clause is not provided, SIMPL continues  with the
               next statement.  If the LE is false and an ELSE
               clause is provided, STMT2 is executed; execution con-
               tinues with the next statement unless STMT2 transferred
               control elsewhere.

               Example 1:

               IF X=ASYM THEN X_0
               Y_0

               If X equals ASYM, X is set to 0; if X does not equal
               ASYM, its value is unchanged.  In either case, Y
               is then set to 0,

               Example 2:

               IF I>A OR J<B  THEN [LC(I)_1;R(TR)_TR] ELSE GO L2

               If the expression I>A OR J<B is true, the compound
               statement [LC(I)_1;R(TR)_TR] is executed, followed by
               the statement after the IF statement.  If the expression
               is false, control transfers to the statement labelled
               L2.

               An IF statement qualifies as an SST (short statement)
               only if all of the statements contained within it are
               SSTs.

               Since the THEN or ELSE clause may contain another IF
               statement, which may contain another IF statement, and
               so on, constructions like the following are possible:

               IF ... THEN ... ELSE IF ... THEN ...
               IF ... THEN ... ELSE IF ... THEN ... ELSE ...
               IF ... THEN IF ... THEN ... ELSE ...

               Note that the ELSE clause in the last example is part
               of the second IF statement; it matches the THEN clause
               closest to it.  The rule for matching THEN and ELSE
               clauses is similar to the rule for matching parentheses:
               they are matched from the inside out.

               Suppose that a construction is desired like the
               last one listed above but with the ELSE matching the
               outer THEN.  Two solutions are possible:

               IF ... THEN IF ... THEN ... ELSE NULL ELSE ...

               A dummy ELSE clause (NULL does
               nothing ) is inserted to match the inner THEN so that
               the other ELSE clause matches the outer THEN.  Or,
               if the statement following the inner THEN is an SST,
               it may be enclosed in square brackets (a "compound
               statement" only one statement long); that is,

               IF ... THEN [IF ... THEN ...]ELSE ...

       3.D.3     EIF Statement

               The EIF statement takes  the form

               EIF LE1 THEN STMT1
               ORIF LE2 THEN STMT2
               .
               .
               .
               ORIF LEn THEN STMTn
                FIF LE THEN STMT
                   or
                ELSE STMT

               EIF and FIF are mnemonics for "Either IF" and
               "Finally IF".  The construction must begin with EIF.
               The ORIF lines are optional, and the ending line
               must begin with either FIF or ELSE.

               The first logical expression is evaluated.  If it is
               true, STMT1 is executed; unless STMT1 caused a transfer
               of control to another statement, execution continues
               with the statement following the EIF statement.  If the
               LE is false, SIMPL proceeds to the next line and
               evaluates its LE.  When a true  logical expression is
               found, the corresponding statement is executed and
               SIMPL transfers out of the EIF statement.  A false
               LE causes the next line to be examined.  If all
               the LEs listed are false, and the construction
               ends with an ELSE line, the ELSE statement is executed.
               If there is no ELSE line (that is, if the ending line
               begins with FIF), SIMPL will naturally fall through
               to the statement following the  EIF statement if all
               the LEs are false.

               Example:

               EIF TYPE(I2)#2 THEN GO ERR
               ORIF WTP=4 THEN [APPL_ABQ;J_0]
               ORIF WTP=5 THEN BPPL_ABQ
               ELSE GO CHK

               The effect of this construction can be achieved
               through nested IF statements, but the latter is
               easily liable to appear complicated and difficult to
               read, especially if any of the statements contained
               within is long (such as a  DO...END compounded
               statement).  The EIF statement is provided as a more
               convenient method  of testing a number of conditions.

               Any of the lines in the EIF statement may be labelled.
               The user may branch from outside the EIF statement to
               anywhere within it; SIMPL does not disallow entering
               the construction at an ORIF (or FIF) rather than at the
               EIF.

               Note that the EIF statement falls into neither the SST
               nor the STMT classification.

3.E      Loop Control Statements

       3.E.1     WHILE Statement

              The WHILE statement takes the form

              WHILE LE THEN STMT

              The statement following THEN is executed and reexecuted
              as long as the logical expression (LE) specified is
              true.  As soon as the LE becomes false, execution
              continues with the statement following the WHILE
              statement.  For example,

              SUM_I_0
              WHILE INC I<=N THEN SUM_SUM+A(I)

              After these two statements are executed, SUM contains
              the sum of array elements A(1) through A(N), and I is
              equal to N+1.

              A WHILE statement qualifies as an SST (short statement)
              only if the statement following THEN is an SST.

       3.E.2  REPEAT Statement

               The REPEAT statement takes the form

               REPEAT AE STMT

               It executes the statement STMT as many times as
               specified by the value of the arithmetic expression AE. 
               For example, 

               REPEAT LLEN TTY_NCHV PTR

               The AE is evaluated only once, when the state-
               ment is first encountered; any change made to
               its value during loop execution has no effect 
               on the REPEAT count.

               The REPEAT statement qualifies as an SST (short
               statement) if the statement to be repeated is an SST.

       3.E.3  FOR Statement

               The simplest form of the FOR statement is

               FOR SW_ITPT STMT

               where ITPT, the iteration part, specifies those values
               of the storage word SW for which the statement STMT (the
               FOR "loop") is to be executed.  For example,

               SUM_0
               FOR I_1 TO 10 SUM_SUM+A(I)

               stores in SUM the sum of array elements A(1) to A(10).

               The general form of the ITPT is

               AE1 BY AE2 TO AE3
                      or
               AE1 TO AE3 BY AE2

               AE1 is an arithmetic expression specifying the initial
               value to be assigned to SW.  AE2 specifies the value by
               which SW is incremented as long as the result is less
               than or equal to the limit A3.

               The FOR loop is executed each time the SW is assigned
               a value.  The value of the SW upon falling through the
               FOR statement is the last value of SW for which the loop
               is executed.  If the loop is never executed, as in FOR
               I_N TO 1 BY -1 where N equals 0, the value of the SW
               immediately thereafter is unpredictable.

               As shown in the example above, the BY clause may be
               omitted; BY 1 is assumed.  The TO clause may also be
               omitted, in which case some other means of exiting the
               FOR loop must be provided.  For example,

               FOR J_1 BY 1 DO
               .
               .
               IF CHAR_TTY=CAR.RET THEN GO OUT
               .
               END

               The exit from this loop is made when a carriage return
               character is read from the terminal.

               If both the BY and the TO clauses are omitted, so
               that the ITPT consists of only an AE, the STMT following
               the ITPT is executed once, with the value of AE assigned
               to SW.  This is a useful feature in view of the fact
               that several ITPTs may be specified in a single FOR
               statement, separated by commas; in general,

               FOR SW_ITPT1,ITPT2,...,ITPTn STMT

               For example,

               FOR RPC_1,6,8 TO 11,12 TO 18 BY 2 DO
               .
               .
               END

               The values of RPC for which the DO...END STMT is
               executed are 1,6,8,9,10,11,12,14,16 and 18.  Note that
               the commas completely separate the ITPTs, so that, for
               example, the BY 2 above refers only to 12 TO 18, and has
               no effect on any other ITPTs listed.

               When a number of ITPTs are listed in this way, the first
               ITPT is evaluated and the loop executed for the
               specified value(s), then the second ITPT is evaluated,
               and so on, so that if a FOR statement begins

               FOR I_1 TO J, M TO N ...

               M and N are not evaluated until after the loop is
               executed for I_1 TO J.

               The AEs in an ITPT are evaluated once, when the ITPT is
               first encountered.  Thus if a variable is included in
               any of the AEs, changing the value of that variable
               within the FOR loop does not affect the increment or
               limit originally calculated for the ITPT.

               Similarly, if the value of the SW is changed within
               the FOR loop, the change will not be recognized in
               the test for when to terminate loop execution. 

               Suppose that the SW in a FOR statement takes either of
               the forms ID(AE) or ^(AE), where AE includes a variable.
               Changing that variable within the  FOR loop does not
               result in the modification of a different SW.  The
               address of the SW is noted by SIMPL when the FOR
               statement is first encountered and is not affected by
               any changes within the loop. 

               If a transfer out of a FOR loop is made by means of a
               GO statement, a subsequent GO back into the loop can be
               made without disturbing the progress of the SW test and
               modification, just as though the statements executed
               outside the loop had instead been located within it. 
               However, the result of transferring into a FOR loop from
               outside the loop is unpredictable in any other case,
               that is, if the last transfer out of the loop was made
               after the usual completion of the iterations on the SW
               rather than by means of a GO statement. The FOR statement
               qualifies as an SST (short statement) if the statement
$
               comprising the FOR loop is an SST. 

       3.E.4  LOOP Statement

              The LOOP statement takes the form

              LOOP STMT

              where STMT may contain the special short state-
              ments

              WHILE LE
              REPEAT AE
              FOR SW _ ITPT1,...,ITPTn

              which may be used for exit from the loop and do
              not have any meaning outside of the LOOP statement.
              If these statements are not used, the LOOP STMT
              is simply executed over and over again; some explicit
              means of exit must be encoded in the loop.  For example,

              LOOP NCHV LPTR _ GETCH(CHKLN)

              where GETCH is a procedure that reads a character
              from the terminal and branches to CHKLN when a
              CARRET is encountered.

              The WHILE LE statement specifies that loop execution
              is to be repeated as long as the specified logical
              expression is true.  As soon as the LE becomes false,
              execution continues with the statement following
              the LOOP statement.  For example

              LOOP [GETLINE; WHILE CHAR _ NCHV LPTR=CARRET]

              Where GETLINE is a procedure that reads a line of
              input and stores a corresponding pointer in LPTR.
              The effect of this statement is to ignore all lines
              that begin with the character CARRET.

              The above example qualifies as a short statement (SST)
              because the statement comprising the loop is an SST;
              the statement

              LOOP DO
                 NXADR     ! SETS TERMCH
                 IF TERMCH=$: THEN ERR(BCLN)
                 LSTCNT_LSTCNT+LTBL(I)
                 WHILE TERMCH#$,
                 IF INC CNT=RNGMX THEN ERR(LNG)
              END

              is not an SST.

              The REPEAT AE statement may be used to specify that
              the LOOP code be executed AE times, after which 
              control passes to the statement following the LOOP
              STMT.  In other words, the loop exit takes place
              the AE+1st time that the REPEAT AE statement is
              encountered.  As in the regular REPEAT statement,
              the AE is evaluated only once.

               Similarly, the FOR SW _ ITPT1,...,ITPTn  statement may be
               used to specify values of SW for which the LOOP code is to
               be executed, following the same rules as those of the
               regular FOR statement.

               Note that if the special WHILE, REPEAT, or FOR statement
               is the first statement of the LOOP STMT, the resulting
               construction is equivalent to the regular WHILE, REPEAT
               or FOR statement.

3.F.     Miscellaneous Statements

       3.F.1     NULL

               NULL

               has exactly that effect.

       3.F.2     HALT

               HALT

               traps (attempts to execute an illegal instruction).

       3.F.3     EXIT

               EXIT

               provides a normal return to the supervisory level.
$
                               Section 4
                           SIMPL Procedures


4.A.     Procedure Declaration

       Procedures are named with identifiers and must always be
       declared.  To declare a procedure, precede its identifier
       with a % in the LOCAL statement; that is,

       LOCAL %ID

4.B.     Procedure Definition

       A procedure is defined as follows:

       %ID(par1, par2,...,parN)
        statements constituting the procedure
       END ID

       where parI is a parameter  declaration (explained in Section
       4.E). There may be no parameters, in which case the procedure
       head is simply

       %ID

       The identifier typed in the procedure head must appear
       in that procedure's END statement.
       Procedure definitions must be placed after the main program
       with no statements between the end of one procedure and the
       head of the next.


4.C.     Parameters and Arguments

       Input to a procedure is made through parameters.  Procedures
       that do not require input from the calling program have no
       parameters.  The maximum allowable number of parameters is
       a machine dependency (14 on the Sigma 7 or PDP-10).  When
       a procedure is called, arithmetic expressions (the "arguments"
       to the procedure) are listed in place of the parameters; the
       first parameter is given the value of the first argument listed,
       the second parameter is assigned the second argument, and so
       on.  It is left up to the user to check that the number of
       arguments at calling time matches the number of parameters
       specified in the procedure definition; SIMPL does not make this
       check.  If fewer arguments are given than parameters specified,
       the extra parameters will be assigned values unknown to the
       user. If more arguments are given than parameters specified, the
       extra arguments will be ignored.

       Parameters are local to the procedure definition; a parameter
       may have the same identifier as another language element outside
       the procedure without conflict (that is, without affecting
       the outside element in any way).

4.D.     Procedure Call and RETURN

       To call a procedure, type its identifier followed by
       the list of arguments, if any; that is,

       ID
        or
       ID(arg1, arg2,...,argN)

       Note: Section 4.H describes entry into a procedure at some point
             other than its beginning.

       A procedure may be used  either as a statement or as a function
       reference. A procedure call that appears alone classifies as
       a statement (an SST); the statements contained within the
       procedure are executed until a

       RETURN

       statement is encountered, at which time control transfers to the
       statement following the procedure call.

       A procedure may be used as a function reference (that is,
       to return a value).  A procedure call of this type, classified
       as a primary, causes SIMPL to execute the statements of
       the procedure until a statement of the form

       RETURN AE

       is encountered, at which time the value of the AE, an
       arithmetic expression, is returned.

       For example, suppose a program includes the statement

       CLEAR; S_2*SQR(A)+I

       and the procedure definitions

       %CLEAR
       .
       .
       RETURN
       END CLEAR
       %SQR(X)
       .
       .
       RETURN Z
       END SQR

       The procedure CLEAR is used as a statement.  SQR is used as a
       primary in an arithmetic expression; the value of Z as evaluated
       in the procedure is returned.

       If a procedure is used as a statement but the return is made
       through a RETURN AE statement, the value returned will
       simply be ignored.  If a procedure is used as a primary but the
       return is made through a simple RETURN statement, some
       unpredictable value will be returned.

       In addition to RETURN AE, SIMPL allows the construction
       RETURN DAE, where DAE is a doubleword arithmetic expression.
       When RETURN DAE is used, the procedure call must be preceded
       by the word DOUBLE; this construction (DOUBLE procedure call)
       is classified as a DAE.

       Note that a RETURN is automatically generated if SIMPL
       falls through to the end of a procedure because a RETURN
       or transfer out of the procedure was accidentally omitted.

       When a procedure is called, its return point is saved,
       specifying where control is to be transferred when a RETURN is
       encountered within that procedure.  Any previous value of
       the return point is destroyed.

       Once a transfer out of a procedure through a RETURN statement
       has been made, SIMPL assumes the user is temporarily
       finished with that procedure, and no longer retains the value
       of the return point.  However, if a transfer out of a procedure
       is made by some means other than a RETURN, the value of the
       return point is saved.  Thus, if a transfer back into the
       procedure is made (by some means other than a call, which would
        destroy the previous return point value), a subsequent RETURN
       in the procedure would return to the originally calculated
       return point, as though a transfer out of the procedure had not
       been made.  This implies that procedures can be nested with
       the expected results.  For example,

       %SVAL(X)
       .
       .
       TPRT
       !RETURNS HERE FROM TPRT
       .
       .
       RETURN
       %TPRT
       .
       .
       RETURN
       END TPRT
       END SVAL

       If SVAL is called from the main program, its return point will
       be saved throughout the call to and return from the
       procedure TPRT, so that the RETURN in SVAL will transfer
       control to the statement following the call to SVAL in the main
       program.

       The limit to the depth of nesting is 10 procedures (an
       implementation dependency).  The general rule for the
       placement of procedure definitions is that they must be located
       at the very end of the block containing them, be it the main
       program or another procedure.

       Another method of transferring out of a procedure other than
       the normal RETURN is by means of the GO statement.
       As explained above, the user may GO out of a procedure and GO
       back into it without losing the value of the return point, as
       long as the procedure is not called again before the
       transfer back into it is made (since that would destroy the
       original return point value).

       The information given here about the return point value tells us
       what to expect when a transfer into a procedure is made
       through a GO statement rather than a call, and a RETURN is
       encountered in the procedure.  The subsequent action taken by
       SIMPL depends on how the last transfer out of that procedure was
       made. If it was made by some means other than a RETURN
       statement, the return point value saved the last time the
       procedure was called will have been retained.  If the last
       transfer out of the procedure was made through a RETURN
       statement, however, the return point value will not have been
       retained and the action taken by SIMPL will be unpredictable.

       Finally, the above information implies that procedures are
       not recursive.

4.E.     Parameter Declarations

       A parameter may represent a variable used within the procedure,
       or an address, a label, or another procedure name.  The type of
       language element that the parameter represents is specified in
       the procedure head, in the parameter declaration list.  This
       list tells SIMPL how to interpret the argument passed, but the
       type of the argument is not checked against the type of the
       parameter.  It is left up to the user to check, for example,
       that an address is passed as an argument when the corresponding
       parameter has been declared an address.

       A parameter may be declared in any of the following ways:

       1.      ID              Simple variable value
       2.      @ID             Address
       3.      ID()            Base address of array ID
       4.      ID:             Label
       5.      %ID             Procedure name

       These declarations are explained in detail below.  Note their
       similarity to the declarations that can be made in the LOCAL
       statement.  The parameter declarations do not include
       ID(KONEX:KONEX);  the LOCAL declarations do not include @ID. 
       The two types of  declarations also differ in that the LOCAL
       statement declares  but does not allocate space for labels and
       procedure names. Each parameter declaration does allocate a word
       in which the value of the argument passed will be stored.


       1.  ID

       The value of the argument passed is stored in the simple
       variable  ID. Note that if the argument is a variable, any
       changes made to ID within the procedure will not affect that
       variable.  SIMPL merely passes its value.  For example, suppose
       the procedure

       %CUBE(X)
       X_X*X*X; RETURN X
       END CUBE

       is called as a primary, as CUBE(VAR). The value returned
       will be VAR cubed.  The variable VAR will not be affected.

       SIMPL also allows the values of DAEs (doubleword arithmetic
       expressions) to be passed through parameters.  When this is
       done, two identifiers must be specified in the parameter list,
       one for each word of the value.  For example, the procedure
       SPROC might be headed

       %SPROC(X,Y)

       and called with SPROC(DAE), where DAE is any form of doubleword
       arithmetic expression.


       2.  @ID

       The parameter represents  an address; SIMPL therefore auto-
       matically performs indirect addressing on ID whenever it is
       used within the procedure. For example, a statement of the form
       LP_ID would assign to LP the value stored in the word addressed
       by the value passed through ID.  The user may specify at
       calling time a variable whose value will be changed from within
       the procedure, by passing the address of that variable (rather
       than just its value as in 1. above). For example, suppose the
       procedure

       %CUBE(@X)
       X_X*X*X
       END CUBE

       is called as a statement, as CUBE(@VAR).  First indirection is
       performed on each X in the expression X*X*X so that
       the value of VAR is cubed.  Then indirection is  applied
       to the left part, storing this value into VAR.

       Note that this can be achieved less conveniently by passing
       the address without declaring it to be one, and then explicitly
       applying indirection:

       %CUBE(XADR)
       ^XADR_^XADR*^XADR*^XADR
       END CUBE

       3.  ID()

       This declaration is similar to 2. above in that it declares
       ID to be an address and it can be used to affect variables
       outside the procedure. The argument passed becomes the base
       address of the array ID.  For example, suppose that the main
       program includes the array B(3:50) and a procedure headed

       %PROC(Z())

       Since B represents the base address of the array B(3:50),
       calling this procedure by PROC(B) causes  Z(i) to
       reference B(i); calling PROC(@B(2)) causes Z(i) to
       reference B(i+2).  Z(i) appearing as a left part (of an
       assignment statement)  would store into the corresponding
       element of the array B.

       4.  ID:

       The parameter represents a label.  For example, if the
       procedure headed

       %FCHK(L:)

       is called as FCHK(EOF) the statement GO L in the procedure
       will transfer to the line labelled EOF.  Note that (as usual
       when a label is used in an arithmetic expression) EOF must
       be a declared label in the calling program in order to be
       passed as an argument.

       5.  %ID

       A procedure name will be passed.  For example, if the
       procedure headed

       %PR(%SPR)

       is called as PR(%VAL), then a call to SPR within the
       procedure effectively calls the procedure VAL.
       Note that it is the procedure name that is passed, not its
       value. The  latter occurs when the argument is an actual
       procedure call (used as a function reference, it qualifies as a
       primary, which is a form of AE).  For example, calling the
       procedure headed %CUBE(X) by CUBE(ABC), where ABC is a procedure
       with no parameters, causes  SIMPL to pass the value returned
       from ABC as the argument to CUBE.

4.F.     Scope of Names

       As noted above, parameters are local to the procedure
       definition.  To use other identifiers locally within a
       procedure, declare them in a LOCAL statement within the
       procedure; as usual, a label normally does not
       require declaration.  If SIMPL encounters in a procedure an
       identifier that is not local to that procedure, it searches
       for the declaration of that element in the outer block,
       which will be the main program or (in the case of nested
       procedures) another procedure.  If the identifier is not
       found there, either in a LOCAL  statement or parameter list or
       as a label, the next outer block is searched, and so on.  Some
       type of declaration or use of the identifier as a label must
       appear in the procedure or in one of its outer blocks.

       Example 1:

               LOCAL %A,%B,%C,I,Z
               Z_I_0
               .
               .
               %A(X)
               INC Z
               .
               .
               %B
               LOCAL I
               IF Z>100 THEN I_X+1
               .
               .
               END B
               %C
               LOCAL J
               IF I=100 THEN J_-1
               .
               .
               END C
               END A


       Here the outer block for procedure A is the main program and
       the outer block for B and C is A.  Procedure C declares a local
       J; since the identifier J is not declared elsewhere, J is
       undefined anywhere except within C.   Procedure C references I,
       which is  declared neither in C nor in its outer block A, but in
       the next outer block, the main program; thus it refers to the
       global I.  The I referenced in the procedure B is local to B;
       the X referenced there is declared in the outer block A, as a
       parameter.  The Z in procedures A and B is declared in the main
       program.

       Example 2:

               LOCAL %D,%E
               .
               .
               EOF:
               .
               .
               %D
               .
               .
               GO EOF
               .
               .
               END D
               %E
               .
               .
               GO ERR
               .
               .
               ERR:
               .
               .
               END E

       When GO EOF is encountered within the procedure D, SIMPL
       finds the label EOF not in D, but in the outer block (the main
       program).  Suppose that D also includes the statement GO ERR,
       where ERR is a label in the procedure E, as illustrated.
       When this statement is encountered in D, SIMPL first
       finds that ERR is not local to D, so it looks in the outer
       block, the main program, and doesn't find any information
       on ERR there,  either:  end of search, and error!  The way to
       satisfy this search is to declare ERR in the main program.  Once
       SIMPL is so satisfied that the label ERR does exist, it will
       transfer to that label, which happens to be located in
       the procedure E.

       Example 3:

               LOCAL %IOPK,%OPEN,%CLOSE
               .
               .
               %IOPK
               LOCAL %FNLU,BUF(2000)
               %FNLU
               .
               .
               END FNLU
               %OPEN
               .
               .
               END OPEN
               %CLOSE
               .
               .
               END CLOSE
               END IOPK


       The procedures OPEN and CLOSE can be called from the main
       program, and they in turn can call the procedure FNLU,
       since  FNLU is declared and defined in their outer block,
       the procedure IOPK.  Since it is local to IOPK, however,
       FNLU cannot be called directly from the main program.
       Similarly, the array BUF cannot be referenced outside of
       IOPK.  This procedure entry and data protection is a useful
       feature of SIMPL. In this example, the OPEN and CLOSE proce-
       dures might perform certain checks before calling FNLU, and
       the programmer might wish to protect himself (or someone
       else adding code to the main program) from accessing FNLU
       until these different checks have been made.  He is also
       protecting the array BUF from accidental manipulation outside
       of IOPK, at the same time allowing it to be
       manipulated freely in all of the procedures in his package.

       Example 4:

       Continuing from Example 3, suppose that the programmer wishes to
       remove the restrictions on entry into the procedure FNLU, that
       is, to allow it to be called directly from the main program.
       If FNLU were still declared local to  IOPK, the definition
       of the procedure FNLU would not extend beyond IOPK; thus
       another %FNLU declaration outside of IOPK would find no
       corresponding procedure  definition.  The correct solution,
       of course, is to declare FNLU only in the main program.

       If for some reason the programmer wished to retain the FNLU
       procedure local to IOPK but have a different FNLU that
       could be accessed from the main program, he could simply declare
        and define an FNLU in both places, that is

               LOCAL %IOPK,%OPEN,%CLOSE,%FNLU
               .
               .
               %FNLU
               .
               .
               END FNLU
               %IOPK
               (remainder as in Example 3)
               .
               .
               .


4.G.     Procedure Entry Points

       A procedure may have several entry points, each with its own
       name and parameter list.  Procedure entry points are declared in
       the same way as procedures, that is,

       LOCAL %ID

       and called in the same way -- by typing the identifier followed
       by the list of arguments, if any.  An entry point is indicated
       within a procedure by two % signs preceding the identifier
       rather than a single %.  For example,

       %EXUC(X,Y,Z:,N)
       .
       .
       %%EXU(X,Y,Z:)
       .
       .
       RETURN
       END EXUC

       EXU identifies an entry point to the procedure EXUC.  Since EXUC
       requires an argument that EXU does not, EXU has one less
       parameter. When EXUC is called, SIMPL proceeds in the usual
       manner, falling through the entry point EXU (assuming it has not
       encountered a RETURN before that point).  When EXU is called,
       execution begins at the indicated point within the procedure,
       and the subsequent RETURN transfers control as usual, to the
       statement following the call. 

       The following rules apply to entry point parameter lists:

       1.  Any identifiers in an entry point parameter list that also
           appear in previous parameter lists within the procedure must
           be declared the same way as in the previous lists; they
           identify the same elements.  Thus, in the above example, X
           and Y can only be declared as simple variables, and Z as a
           label, in EXU's parameter list.

       2.  New parameters can be introduced at an entry point,
           declaring those identifiers locally at that point.  In our
           example here, the EXU entry point might be changed to
           %%EXU(X,Y,Z:,A). If this is done and an outer-declared A is
           referenced before this point, then falling through to here
           would cause a declaration conflict.

           A nested procedure can reference all the identifiers local
           to the procedure in which it is nested.  If the outer
           procedure has multiple entry points, this includes not only
           those identifiers declared at the procedure head (in the
           parameter list or a declaration statement), but also those
           in the entry point parameter lists.

           Consider the following example:

           LOCAL %RW,%R,%W
           %RW
           LOCAL %GETCHK
           %%R(FN)
           IF TYP(FN)=DIR THEN GETCHK
           .
           .
           RETURN
           %%W(FN,VAL)
           .
           .
           GETCHK
           .
           RETURN
           %GETCHK
           IF ID(BUF(FN))=0 THEN DO
           .
           .
           RETURN
           END GETCHK
           END RW

           Here the procedure RW has three entry points (RW, R and W)
           and one nested procedure, GETCHK.  When GETCHK is
           called from R or W, it can reference FN since FN is local
           to RW.  Suppose that procedure entry points were not
           available to the user, and R and W were therefore separate
           procedures.  In order to create a situation in which both
           R and W could call GETCHK and GETCHK could reference FN,
           GETCHK would have to be a separate procedure local to
           neither (declared in an outer block), having FN as a
           parameter. 

4.H.     RETURN as an SW

       We have discussed  at length when SIMPL does or does not save
       the value of the return point of a procedure.  That
       value is, in fact, saved in a storage word that can be
       referenced by the identifier RETURN.

       Since the former value of the return point is destroyed when
       a procedure is called, SIMPL procedures are not recursive.
       Using RETURN as an SW, however, the user can effectively have
       recursion by saving and later restoring the proper return
       point values.

       The value of RETURN should not be manipulated by the user, but
       only stored back into a RETURN, either into another procedure's
       RETURN or back into itself.  As an example of the latter, consider

       %PROC
       .
       .
       SAVE _ RETURN; DOIT; RETURN _ SAVE
       .
       .
       RETURN
       %%DOIT
       .
       .

       END PROC

       DOIT is an entry point within PROC and is usually called from
       outside PROC.  If called from within PROC, DOIT destroys PROC's
       RETURN value.  To circumvent this, the value of RETURN is saved
       before calling DOIT and restored after the return from DOIT has
       been made.

$
                               Section 5
                             SIMPL Macros

5.A.     MACRO Definition

       To define a macro that consists of a single SIMPL line or
       part of a line, use the DEF statement, as follows:

       DEF ID(ID1,ID2,...,IDn) AS definition

       ID is the macro identifier.  The parenthesized IDs
       are the parameters used in the macro definition; they are
       local to that definition.  The maximum number of parameters
       a macro may have is an implementation dependency.  A macro
       may have no parameters, in which case the DEF statement
       takes the form

       DEF ID AS definition

       The definition is terminated by a carriage return and can
       be anything that may be typed in a SIMPL program: a statement
       or part of one, several short statements separated by
       semicolons, an operator, any SIMPL language elements.  The
       characters between AS and the carriage return are not checked
       for syntax when the DEF statement is encountered.

       Examples:

       DEF ADD AS +
       DEF SUM(X,Y) AS X+Y
       DEF FIX(X1,X2,X3) AS _X1-ABS(X2/X3)
       DEF CNT AS IF INC X>100 THEN GO ERR; DEC Z

       A macro may also consist of more than a single line.  A
       multiple-line macro is defined in the same way as a single-
       line macro -- with a DEF statement -- except that BY replaces
       the word AS, and the definition is terminated not by a car-
       riage return but by ENDM ID, where ID is the macro
       identifier.  For example,

       DEF RCGO(X) BY
       IF DEC ECNT(X)>=0 THEN RETURN CPTR(X)
       IF WLAB(FN)#W.ERR THEN WLAB(FN)_WSET
       GO ^RLAB(FN)_RADDR(X)
       ENDM RCGO

       The definition consists of all the characters between BY and
       ENDM, including all carriage returns (four in this example).
       A carriage return is not required after BY or before ENDM.  
       For example, if the above DEF statement were modified 
       so that it ended with

       GO ^RLAB(FN)_ ENDM RCGO

       it could be used as in

       RCGO(N) RINIT

       A macro definition must precede the first use of the macro and
       is local to the procedure in which it appears.  The DEF
       statement may not be labelled.

5.B.   Macro Expansion

       To use a macro, type its identifier followed by the list of
       arguments, if any; that is,

       ID
       or
       ID(arg1,arg2,...,argN)

       When SIMPL encounters the use of a macro having no parameters
       it simply substitutes the text of the macro definition in
       place of the macro identifier.  For example, if ADD and SUB
       are defined as

       DEF ADD AS +
       DEF SUB AS -
       DEF NBLKS AS 15

       then

       D_A ADD B SUB NBLKS

       is equivalent to

       D_A + B - 15


       If a macro has parameters, arguments must be specified when the
       macro is used.  Each argument replaces its corresponding
       parameter in the macro definition.  The argument can be, like
       the definition itself, absolutely anything that may be typed in-
       to a SIMPL program.  When SIMPL encounters the use of a macro
       having parameters, it substitutes the arguments for  the
       parameters in the macro definition and generates the result
       in place of the macro call.  For example, suppose
       a macro is defined as

       DEF SUM(X,Y) AS X+Y

       and used in the statement

       Z_SUM(A,B)

       A+B is generated in place of SUM(A,B), so that this state-
       ment becomes Z_A+B.  Only after a macro is expanded in this
       way  is the statement syntactically examined by SIMPL.  Thus,
       if the macro SUM is used as follows

       P_Q*SUM(R,S)

       then this statement becomes

       P_Q*R+S

       where the product of Q and R is added to S.  If SUM were
       instead defined as

       DEF SUM(X,Y) AS (X+Y)

       the statement P_Q*SUM(R,S) would become

       P_Q*(R+S)

       Remember that anything is legal as an argument.  The macro
       SUM as just defined could be used as SUM(F1_F,2*Z) in which
       case it would expand to (F1_F+2*Z), a primary assigning
       F+2*Z to F1.

       Commas normally separate macro arguments; however, SIMPL
       matches parentheses within an argument list and does not
       consider commas between them to be separators.  For example,

       X _SUM(A(J),PRC(2,C))

       is a permitted use of the macro SUM; the second argument
       is PRC(2,C).  Anywhere except within parentheses, commas
       do separate arguments, so that, for example, ([18,18]*[A,B],Q)
       is interpreted by SIMPL as listing four arguments.

       Macros are expanded from left to right; thus, the user
       cannot define the macros

       DEF BAR AS (A,B)
       DEF FOO(X,Y) AS X+Y/2

       and use them together as FOO BAR, expecting BAR to be expanded
       first as the arguments to FOO.  Instead, the construction FOO
       BAR would in this case be illegal.

       A procedure may redefine a macro originally defined on some
       outer level.

       %PROG
       LOCAL %P1, %P2
       DEF NBUFS AS 30
       .                        !CANNOT BE REDEF'D HERE
       .
       %P1
       DEF NBUFS AS 12
       .
       .
       END P1
       %P2
       .
       .

       The second DEF statement above redefines NBUFS so that it is 12
       rather than 30 within the procedure P1.  NBUFS resumes its
       definition as 30 within the procedure P2.

       As noted by the comment in this example, redefinition is not
       permitted within a single program level.

       Two additional examples of the use of macros are given below.

       Consider the user who needs to reference the four bit index
       field of a number of storage words, a field displaced 17 bits
       from the right.  He could define a macro

       DEF XFLD(X) AS BYT(X,4,17)

       and enjoy the convenience of entering such statements as

       I_XFLD(WD1)
       XFLD(C)_0

       The following macro

       DEF DO.FOR(A,B,C) BY
       A_B_1
       WHILE INC A<=C THEN ENDM DO.FOR

       might be used as in

       SUM_0
       DO.FOR (I,1,10) SUM_SUM+X(I)

       where it sums array elements X(1) through X(10).

5.C.     UNDEF Statement

       A procedure can undefine a macro defined on some outer level,
       through the use of the statement

       UNDEF ID

       where ID is the macro identifier.  This would be used, for
       example, in a procedure containing a local variable ID which
       also identifies a macro in the main program.  The effect of
       the UNDEF statement is local to the procedure in which the
       statement appears.  An UNDEF statement may not be labelled.

       The same rule applies for undefinition as for redefinition:
       it is not permitted within a single program level.


$


                         APPENDIX A

                 IMPLEMENTATION DEPENDENCIES


This section lists any SIMPL features which have not been implemented
on particular machines, and describes additional features (not
previously documented in this manual) which are machine-exclusive
and are not planned for implementation on any other systems.

A.1   XDS 940

      None of the following has been implemented in the 940
      version of SIMPL:

         Half word handling
         CHPT(SW1,SW2) as an LP (left part)
         MOVE AE1 FROM AE2 TO AE3
         Storage word modification (B-_; CNT+_D+2)
         GLOBAL TABLE statements
         FOR or LOOP statements

      On the 940, MAX and MIN are functions rather than arithmetic
      operators.  They may take two or more arguments; that is,

      MAX(AE1,AE2,...,AEn)
      MIN(AE1,AE2,...,AEn)

      System calls may be made on the 940 through use of the back
      slash, as follows:

      /ID1(SW,AE1,AE2,AE3,GO ID)

      /BRS KON (AE1,AE2,AE3,GO ID)

      where

      ID1 is any opcode that the assembler will recognize (such
          as a SYSPOP or machine instruction).

      SW  contains the contents of the address field.

      KON is the BRS number.

      AE1,AE2, and AE3 specify the contents of the A, B and
          X registers.  These arguments are optional but are order-
          dependent when specified.  For example, if only the contents
          of the A and X registers need to be specified, the corres-
          ponding arguments must be separated by two commas; the 
          second comma terminates a null B register argument.

      GO ID must be specified when the return from the call may be
          either skip or non-skip.  ID is the label to be branched to
          if the non-skip return is taken.  GO ID may be preceded by
          any number of register arguments (including none); the only
          restriction is that it be the last argument listed.

      These constructions may stand alone as statements or qualify
      as AE's which are evaluated as the contents of the A register
      after the call is made (or, if preceded by DOUBLE, the contents
      of the A and B registers).

      Examples:

      /BRS 113
      /STB(BREG)
      /BIO(FILE,COUNT,,WHERE,GO SHORT)
      /BRS48 (MSP(LIT),GO NO)

A.2   PDP-10

      Two back slashes will be used to precede any SIMPL
      constructions that are exclusive to the PDP-10.

      The statement

      //->ID

      where ID is a label previously allocated on the same
      program level, specifies ID to be the starting location of the
      program.

$
                                    Index

Indicates the section(s) containing a discussion of the subject

ABS  1.E.1
Address operator  1.C.4
AE  1.E
AND 1.H
Arguments
    function  1.K
    procedure  4.C
    macro  5.B
Arithmetic expression  1.E
    doubleword  1.M.1
Arrays  1.C
Assignment
    deferred  1.J.3
    doubleword  1.M.2, 3.B.2
    primary  1.J.2
    statement  3.B.1

BAND  1.E.2
BASE  3.A.4
BEQV  1.E.2
Bit manipulation  1.E.2, 1.K.3
BITSPERWORD  1.A
BNOT  1.E.2
BOR  1.E.2
BXOR  1.E.2
BYT  1.K.2.1

Call, procedure  4.D
CARRET  1.A
Case statement  3.C.2
CH  1.K.1.1
Character
    constant  1.A
    manipulation  1.K.1
CHARSPERWORD  1.A
CHPT  1.K.1.2
CHV  1.K.1.3
Comments  2.D
Compound statements  2.B
Conditional
    expression  1.I
    statements  3.D
Constants  1.A

DAE  1.M.1
DDIVMOD  1.M.1
DEC  1.J.1, 3.B.6
Decimal constant  1.A
Declaration  3.A
    BASE statement  3.A.4
    FIND  3.A.3
    GLOBAL  3.A.3
    label  1.D
    LOCAL  3.A.1
    parameter  4.E
    procedure  4.A
    TABLE  3.A.2
    variable and array  1.C
DEF  5.A
Deferred assignment  1.J.3
DIVMOD  1.M.1
DLP  1.M.2
DMODDIV  1.M.1
DMUL  1.M.1
DO...END compounding  2.B.2
DO AE...  (case statement)  3.C.2
DOUBLE  4.D
Doubleword
    arithmetic expression  1.M.1
    assignment  1.M.2, 3.B.2
    manipulation  1.M
    operators  1.M.1
DROTL  1.M.1
DROTR  1.M.1
DSHL  1.M.1
DSHR  1.M.1

EIF statement  3.D.3
ELSE  3.D.2, 3.D.3
END  2.B.2, 3.C.2, 4.B
EOLIT  1.A
Exchange statement  3.B.4
EXIT   3.F.3

FIF  3.D.3
FIND  3.A.3
Floating array  1.C.1
FOR statement  3.E.3, 3.E.4
Functions  1.K

GLOBAL  3.A.3
GO  3.C.1

Half word manipulation  1.K.1
HALT  3.F.2
HEX  1.A
Hexadecimal constants  1.A
HW   1.K.l.1
HWPT  1.K.1.2
HWV  1.K.2.3

Identifiers  1.B
IF  3.D.2
INC  1.J.1, 3.B.6
Indirect addressing  1.C.2
Input, terminal  1.K.3

KON  1.A
KONEX  1.F

Labels  1.D
LE  1.H
Line continuation  2.C
LNFEED  1.A
LOCAL  3.A.1
Logical expression  1.H
LOOP statement  3.E.4

Macro
    definition  5.A
    expansion   5.B
MAX  1.E.1
MIN  1.E.1
MOD  1.E.1
MODDIV  1.M.1
MOVE  3.B.5

NCHV  1.K.l.4, 3.B.7
NHWV  1.K.1.4, 3.B.7
NOT  1.G, 1.H
NULL  3.F.1

OCT  1.A
Octal constant  1.A
OR  1.H
ORIF  3.D.3
Output, terminal  1.K.3

Parameters
    procedure  4.C, 4.E
    macro  5.A
PCHV  1.K.1.5, 3.B.8
PHWV  1.K.1.5, 3.B.8
Primary  1.L
Procedure  4
    call  4.D, 4.G
    declaration  4.A
    definition  4.B
    RETURN  4.D, 4.H

REL  1.G
Relational expression  1.G
REPEAT  3.E.2, 3.E.4
RETURN  4.D, 4.H
ROTL  1.E.2
ROTR  1.E.2

Semicolon  2.A, 2.B.1
Shift operators  1.E.2, 1.M.2
SHL  1.E.2
SHR  1.E.2
Statement
    compounding  2.B
    delimiters  2.A
    descriptions  3
STMT  3.D.1
Storage word  1.C.3
    modification  1.J.4, 3.B.3
String constant  1.A
Subscripted variable  1.C
SW  1.C.3

TABLE  3.A.2
Terminal I/O  1.K.3
TTY  1.K.3

UNDEF  5.C

Variables  1.C

WHILE  3.E.1, 3.E.4
Word packing and unpacking  1.K.2.2

.  1.A, 1.B
^  1.C.2
@  1.C.4
_ 1.J.2, 1.J.4
&  2.C
!  2.D
<==  1.J.3
<=>  3.B.4
                                                                                                                                                                                                                                                                                                                                      5.'{