        TITLE   SCALERS
        INTERN  READSC,ISC,EXPAND


;
; SUBROUTINE READSC
;
; THIS ROUTINE READS A SCALER
;
; ARGUMENTS -
;
;  R1 - RADIX (BASE) TO USE
;  R2 - SCALE FACTOR TO APPLY TO NUMBER IN TERMS OF POWERS
;       OF THE RADIX. THUS FOR MONEY, A RADIX OF TEN AND A SCALE
;       FACTOR OF TWO WOULD BE USED. FRACTIONAL PARTS OF LESS
;       SIGNIFICANCE THAN ALLOWED FOR BY THE SCALE FACTOR
;       ARE THROWN AWAY. NO ROUNDING IS PERFORMED.
;  R3 - NUMBER OF BITS THAT NUMBER IS TO FIT INTO. THIRTY SIX IS A
;       NORMAL INTEGER. SEVENTY TWO IS A NORMAL DOUBLE PRECISION
;       INTEGER. THE ROUTINE CAN HANDLE ANYTHING FROM 1 TO 72.
;       LEADING ONES ARE DELETED FROM NEGATIVE NUMBERS SO THAT THE
;       SIGN BIT BECOMES THE LEFT MOST BIT OF THE BIT FIELD.
;  R4 - ADDRESS OF STORAGE WORD FOR RETURNING FIELD LENGTH. IF THE
;       GIVEN FIELD LENGTH IS BIG ENOUGH THEN THAT VALUE IS RETURNED.
;       IF THE GIVEN FIELD LENGTH IS NOT BIG ENOUGH THEN THE MINIMUM
;       ACCEPTABLE FIELD LENGTH IS RETURNED. IN THIS CASE, READSC
;       RETURNS A FUNCTION VALUE THAT IS GOOD ONLY IF THE MINIMUM
;       FIELD LENGTH IS USED FOR STORING IT.
;       IF R4 <= 0 THEN NO VALUE IS RETURNED.
;  R5 - ADDRESS OF STORAGE WORD FOR RETURNING ERROR CODE. IF R5 IS
;       <= ZERO THEN NO ERROR CODE IS RETURNED. THE ERROR CODES ARE:
;                1 = SOFT WARE OVERFLOW. NUMBER WILL NOT FIT IN GIVEN
;                    FIELD LENGTH.
;                0 = NO ERROR
;               -1 = HARDWARE OVERFLOW. NUMBER WILL NOT FIT IN 72 BITS
;               -2 = ILLEGAL CHARACTER ENCOUNTERED. POSSIBLE CAUSES:
;                       TWO DECIMAL POINTS READ
;                       NON-NUMERIC CHARACTER READ BEFORE READING
;                         NEEDED RIGHT BRACKET OR PARANTHESES
;               -3 = ILLEGAL SPECIFIED FIELD LENGTH. MUST BE >= 0 AND
;                    <= 72.
;               -4 = ILLEGAL RADIX. MUST BE >=2.
;  R6 - FLAG WORD. THE BITS (COUNTING FROM THE RIGHT) HAVE THE FOLLOWING
;       MEANINGS:
;               1 - IF ON, COMMAS ARE IGNORED
;               2 - IF ON, LEADING MINUS SIGN IS ALLOWED
;               3 - IF ON, TRAILING MINUS SIGN IS ALLOWED
;               4 - IF ON, SURROUNDING BRACKETS ARE ALLOWED FOR
;                   INDICATING A NEGATIVE NUMBER
;               5 - IF ON, SURROUNDING PARANTHESES ARE ALLOWED FOR
;                   INDICATING A NEGATIVE NUMBER
;               6 - IF ON, SURROUNDING ANGLE BRACKTETS ( "<>" )
;                   ARE ALLOWED FOR INDICATING A NEGATIVE NUMBER
;               7 - IF ON, DECIMAL POINTS ARE NOT ALLOWED
;       IF BITS 2 THROUGH 6 ARE ALL OFF THEN NO NEGATIVE NUMBERS
;       CAN BE ENTERED. THUS THE NUMBER IS A MAGNITUDE ONLY NUMBER
;       AND REQUIRES ONE LESS BIT OF FIELD LENGTH TO STORE IT. IN THIS
;       CASE, READSC MAY RETURN A NUMBER WITH THE LEFTMOST BIT "ON".
;       THIS IS NOT A SIGN BIT.
;  R7 - ADDRESS OF BYTE POINTER DEFINING INPUT STRING. THE BYTE
;       POINTER SHOULD POINT ONE CHARACTER IN FRONT OF THE
;       STRING SUCH THAT A "ILDB AC,PTR" WILL RETRIEVE THE FIRST
;       CHARACTER IN THE STRING.
;
;
; READSC RETURNS THE NUMBER RIGHT JUSTIFIED IN THE REGISTERS ONE
; AND TWO. THUS A 36 BIT FIELD LENGTH WOULD BE RETURNED IN REGISTER TWO.
;
; IN ALL CASES, THE BYTE POINTER IS LEFT POINTING TO THE LAST
; CHARACTER THAT WAS LEGALLY PART OF THE NUMBER. THAT MEANS THAT
; AN "ILDB AC,PTR" INSTRUCTION WILL RETRIEVE THE NEXT CHARACTER AFTER
; THE NUMBER.
;
; BLANKS MAY PRECEED THE NUMBER. BLANKS MAY COME BETWEEN THE NUMBER
; AND THE VARIOUS NEGATIVE INDICATORS.
;
;
;


; MACHINE DEFINITION. 0 = KA10, ELSE KI10
KI10=1

; REGISTER DEFINITIONS
AC=1    ; AND USES 2
CHR=3
STKPTR=16
FLAGS=15
RES=4   ; AND USES 5 AND 6
TMP=7   ; AND USES 10
TMP2=11
TMP3=12
FL=4
MAG=3
MAGFLG=5

; FLAG DEFINITIONS
COMMA=1
LMINUS=2
TMINUS=4
BRCK=10
PARA=20
ABRCK=40
DECFLG=100

; INTERNAL STORAGE WORDS
RADIX:  Z
SCALE:  Z
FLDLEN: Z
ERRWRD: Z
MINLEN: Z
BYTPTR: Z
MAXDIG: Z
BYTPT2: Z
CHRCNT: Z
MINFLG: Z
LAST:   Z
DECPNT: Z
RET:    Z
IRET:   Z
STKWRD: XWD     -^D72,.
        BLOCK   ^D72

; TABLES FOR HANDLING VARIOUS FLAVORS OF NEGATIVE INDICATORS..
FTEST:  EXP     LMINUS,BRCK,PARA,ABRCK
CTEST:  EXP     "-","[","(","<"
CEND:   EXP     0,"]",")",">"
TLEN=4

; MACRO FOR DECREMENTING BYTE POINTER. USES REGISTER "TMP".
DEFINE  PCHV    (A)
<       MOVE    TMP,A
        ADD     TMP,[70000000000]
        CAIGE   TMP,0
        SUB     TMP,[430000000001]
        MOVEM   TMP,A>

; MACRO FOR DOING DOUBLE PRECISION NEGATE
DEFINE  NEGATE  (A)
<       IFE     KI10,
<       SETCA   A,
        SETCA   A+1,
        TLZ     A+1,400000
        ADDI    A+1,1
        TLZE    A+1,400000
        ADDI    A,1>
        IFN     KI10,
<       DMOVN   A,A>>

; MACRO FOR DOING DOUBLE MOVES
DEFINE  DBLMOV  (A,B)
<       IFE     KI10,
<       MOVE    A,B
        MOVE    A+1,B+1>
        IFN     KI10,
<       DMOVE   A,B>>

READSC: MOVEM   17,RET
        CAIGE   1,2
        JSP     17,ILLRDX
        MOVEM   1,RADIX
        ADDI    1,"0"-1         ; CALCULATE MAX LEGAL DIGIT SIZE
        MOVEM   1,MAXDIG
        MOVEM   2,SCALE
        CAIG    3,^D72
        CAIGE   3,0
        JSP     17,ILLFLD
        MOVEM   3,FLDLEN
        MOVEM   4,MINLEN
        MOVEM   5,ERRWRD
        MOVEM   6,FLAGS
        MOVEM   7,BYTPTR

        SETZM   LAST            ; FLAG FOR BRACKETS ETC...
        SETZM   DECPNT          ; FLAG FOR DECIMAL POINT...
        SETZM   MINFLG          ; FLAG FOR MINUS NUMBERS...
        SETZM   RES             ; INITIALIZE RESULT TO ZERO...
        SETZM   RES+1

;
;       STRIP OFF LEADING BLANKS
;
        ILDB    CHR,@BYTPTR
        CAIN    CHR," "
        JRST    .-2

;
;       TEST FOR ALL FLAVORS OF LEADING MINUS INDICATORS
;
        HRLZI   AC,-TLEN
MLOOP:  TDNE    FLAGS,FTEST(AC)
        CAME    CHR,CTEST(AC)
        JRST    MLOOPE
        MOVE    CHR,CEND(AC)
        MOVEM   CHR,LAST
        SETOM   MINFLG
        ILDB    CHR,@BYTPTR
        CAIN    CHR," "
        JRST    .-2
        JRST    MDONE
MLOOPE: AOBJN   AC,MLOOP
        SETZM   MINFLG
MDONE:  PCHV    @BYTPTR


;
; THIS IS THE MAIN LOOP FOR BUILDING THE NUMBER...
;

RLOOP:  ILDB    CHR,@BYTPTR     ; GET NEXT CHARACTER

        TRNE    FLAGS,COMMA     ; COMMA TEST
        CAIE    CHR,","
        JRST    RL2
        JRST    RLOOP

RL2:    CAIE    CHR,"."         ; DECIMAL POINT TEST
        JRST    RL3
        TRNN    FLAGS,DECFLG
        SKIPE   DECPNT
        JSP     17,ILLCHR
        SETOM   DECPNT
        JRST    RLOOP

RL3:    CAMG    CHR,MAXDIG      ; TEST FOR VALID DIGIT
        CAIGE   CHR,"0"
        JRST    RLEND

        SKIPN   DECPNT          ; TEST FOR TRUNCATION
        JRST    RL4
        SKIPG   SCALE
        JRST    RLOOP
        SOS     SCALE

;
;       ADD IN NEW DIGIT
;
RL4:    JFCL    17,.+1          ; CLEAR OVER FLOW FLAGS
        MUL     RES+1,RADIX
        IMUL    RES,RADIX
        ADD     RES,RES+1
        JOV     HOVR
        MOVE    RES+1,RES+2
        ADDI    RES+1,-"0"(CHR)
        TLZE    RES+1,400000
        ADDI    RES,1
        TLZE    RES,400000
        JRST    HOVR
        JRST    RLOOP


;
;       NUMBER IS READ IN.
;       CHECK FOR MATCHING BRACKETS AND TRAILING MINUS SIGNS
;
        ILDB    CHR,@BYTPTR
RLEND:  CAIN    CHR," "         ; STRIP OFF TRAILING BLANKS
        JRST    .-2

        SKIPN   LAST
        JRST    RLEND2
        CAMN    CHR,LAST
        JRST    RLEND4
        JSP     17,ILLCHR

RLEND2: TRNN    FLAGS,TMINUS
        JRST    RLEND3
        SKIPN   MINFLG
        CAIE    CHR,"-"
        JRST    RLEND3
        SETOM   MINFLG
        JRST    RLEND4

RLEND3: PCHV    @BYTPTR         ; PUT BACK LAST CHARACTER


;
;       THE TRAILING MINUS INDICATORS HAVE NOW BEEN PROPERLY
;       HANDLED. NOW ADJUST FOR ANY LEFT OVER SCALING FACTOR..
;
RLEND4: JFCL    17,.+1          ; RESET OVER FLOW FLAGS

SCLP1:  SKIPG   SCALE
        JRST    SCLP1E
        SOS     SCALE
        MUL     RES+1,RADIX
        IMUL    RES,RADIX
        ADD     RES,RES+1
        MOVE    RES+1,RES+2
        JRST    SCLP1
SCLP1E: JOV     HOVR

SCLP2:  SKIPL   SCALE
        JRST    RLEND5
        AOS     SCALE
        MOVE    RES+2,RES+1
        IDIV    RES,RADIX
        DIV     RES+1,RADIX
        JRST    SCLP2

;
;       THE NUMBER IS NOW PROPERLY SCALED. ALL THAT REMAINS IS
;       TO NEGATE AND TRUNCATE LEADING ONES IF NECESSARY AND SEE
;       IF IF WILL FIT IN THE GIVEN FIELD LENGTH.
;
RLEND5: DBLMOV  1,RES
        MOVE    3,MINFLG
        TRNE    FLAGS,LMINUS,TMINUS,BRCK,PARA,ABRCK
        JRST    .+2
        MOVEI   3,1
        MOVE    4,FLDLEN
        MOVE    5,MINLEN
        MOVE    6,ERRWRD
        JSP     17,REDUCE
        JRST    @RET


;
; ERROR HANDLERS
;

ILLRDX: MOVNI   TMP,4
        JRST    DOERR

ILLFLD: MOVNI   TMP,3
        JRST    DOERR

HOVR:   MOVNI   TMP,1
        JRST    DOERR

ILLCHR: PCHV    @BYTPTR
        MOVNI   TMP,2
DOERR:  SKIPLE  ERRWRD
        MOVEM   TMP,@ERRWRD
        JRST    @RET




;
; SUBROUTINE ISC
;
; THIS ROUTINE CONVERTS A SCALER INTO A STRING
;
; ARGUMENTS -
;  R1 - NUMBER
;  R2 - NUMBER
;  R3 - RADIX (BASE)
;  R4 - FIELD LENGTH
;  R5 - 0 = SIGNED NUMBER, NOT 0 = MAGNITUDE ONLY
;  R6 - ADDRESS OF BYTE POINTER FOR RETURNING STRING
;
; RETURNS -
;  R1 - CHARACTER COUNT (DOES NOT INCLUDE TERMINATING EOLIT)
;  R2 - SIGN OF NUMBER
;
ISC:    MOVEM   17,IRET
        MOVEM   3,RADIX
        MOVEM   6,BYTPT2

        MOVE    STKPTR,STKWRD
        SETZM   CHRCNT          ; ZERO CHARACTER COUNT
        SETZM   MINFLG          ; SET MINUS FLAG

        MOVE    3,MAGFLG
        JSP     17,EXPAND       ; EXPAND NUMBER
        JUMPN   MAGFLG,DOM
        JUMPGE  AC,DOM
        NEGATE  AC
        SETOM   MINFLG

DOM:    DBLMOV  RES,AC

        PUSHJ   STKPTR,OLOOP
        SETZ    CHR,
        IDPB    CHR,@BYTPT2
        MOVE    1,CHRCNT
        MOVE    2,MINFLG
        JRST    @IRET

OLOOP:  MOVE    RES+2,RES+1
        IDIV    RES,RADIX
        DIV     RES+1,RADIX
        ADDI    RES+2,"0"
        HRLM    RES+2,(STKPTR)
        SKIPN   RES
        SKIPE   RES+1
        PUSHJ   STKPTR,OLOOP
        HLRZ    CHR,(STKPTR)
        IDPB    CHR,@BYTPT2
        AOS     CHRCNT
        POPJ    STKPTR,

;
; SUBROUTINE TO EXPAND NUMBER
;
; ARGUMENTS -
;  R1 - NUMBER
;  R2 - NUMBER
;  R3 - 0 = SIGNED NUMBER, ELSE MAGNITUDE ONLY
;  R4 - FIELD LENGTH
;
;
FAST=0  ; 0 = COMPILE FAST VERSION, NOT ZERO = COMPILE SHORT VERSION
        IFE     FAST, <
EXPAND: JUMPN   MAG,DOPOS       ; IF MAG ONLY, TREAT AS POSTIVE
        XCT     SHFTAB(FL)      ; TEST FOR NEGATIVE
        JRST    DONEG

DOPOS:  AND     AC,ETRTB(FL)
        AND     AC+1,ETRTB2(FL)
        JRST    (17)

DONEG:  ORCM    AC,ETRTB(FL)
        ORCM    AC+1,ETRTB2(FL)
        JRST    (17)

;
; TABLE FOR EXPAND TO USE IN FINDING SIGN BIT...
;
SHFTAB=.-1
D72=^D72
D36=^D36
AD=1
BIT=1
BC=0
LR=0

REPEAT D72, <BC=BC+1

IFE LR, <TRNE AC+AD,BIT>
IFN LR, <TLNE AC+AC,BIT>

BIT=BIT_1

IFE BIT-1000000, <BIT=1
IFE LR, <XLR=1>
IFN LR, <XLR=0>
LR=XLR>

IFE BC-D36, <AD=0>>

;
; TABLE USED FOR EXTRACTING POSITIVE NUMBERS
; AND MASKING IN SIGN BITS
;
ETRTB=.-1
REPEAT D36, < Z >
BIT=1
ETRTB2=.-1
REPEAT D36, < EXP BIT
BIT=BIT_1
BIT=BIT+1>
REPEAT D36, < EXP -1> >

        IFN     FAST, <
EXPAND: MOVE    TMP3,FL
        CAILE   TMP3,^D36
        SUBI    TMP3,^D36
        SETZ    TMP2,
        CAIN    TMP3,^D36
        JRST    .+3
        HRLZI   TMP2,400000
        ASH     TMP2,-^D35(TMP3)

        JUMPN   MAG,DOPOS
        SETZ    TMP,
        MOVEI   TMP+1,1
        LSHC    TMP,-1(FL)
        TDNN    AC,TMP
        TDNE    AC+1,TMP+1
        JRST    DONEG

DOPOS:  CAILE   FL,^D36
        JRST    DOPOS2
        SETZ    AC,
        ANDCM   AC+1,TMP2
        JRST    (17)
DOPOS2: ANDCM   AC,TMP2
        JRST    (17)

DONEG:  CAILE   FL,^D36
        JRST    DONEG2
        SETO    AC,
        IOR     AC+1,TMP2
        JRST    (17)
DONEG2: IOR     AC,TMP2
        JRST    (17) >

        END
    