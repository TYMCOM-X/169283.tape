MAP BASE CSTMNT;





!COPYRIGHT 1972,1973, DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS
!AUTHOR: S. MURPHY
GLOBAL BIND SKSTV=68;		!VERSION DATE: 6/4/73




GLOBAL ROUTINE P2SKSTMNT=
%(***************************************************************************
	PERFORM PHASE 2 SKELETON OPTIMIZATIONS ON THE STATEMENT POINTED
	TO BY THE GLOBAL "CSTMNT"
***************************************************************************)%

BEGIN
	EXTERNAL P2REGCNTS;
	EXTERNAL INPFLAG;		!SET THIS FLAG FOR INPUT STMNTS
	EXTERNAL USERFNFLG;		!THIS FLAG WILL GET SET FOR ANY STMNT THAT
					! INCLUDES USER FUNCTIONS
	EXTERNAL DOWDP;			!THIS GLOBAL IS USED IN DETERMINING WHETHER
					! A DO INDEX IS TO USE AOBJN/LIVE IN A REG
	MAP OBJECTCODE DOWDP;


	%(***DEFINE A MACRO TO USE FOR IO STMNTS TO CHECK WHETHER THE UNIT NO OR THE
		RECORD NUMBER IS EQUAL TO THE INDEX OF THE EMBRACING DO LOOP, AND
		IF SO TO SET FLAG INDICATING NOT TO USE AN AOBJN FOR THE LOOP***)%
	MACRO CHKFORDOREF=
	BEGIN
		IF .CSTMNT[IOUNIT] EQL .DOWDP[DOINDUC] OR .CSTMNT[IORECORD] EQL .DOWDP[DOINDUC]
		THEN DOWDP[DONOAOBJN]_1;
	END$;


	%(***AT START OF A STMNT, CAN INIT NEGFLG AND NOTFLG TO FALSE***)%
	NEGFLG_FALSE;
	NOTFLG_FALSE;

	USERFNFLG_FALSE;	!FLAG FOR "STMNT INCLUDES USER FNS" - INIT TO FALSE
	%(***PROCESS THIS STMNT IN A MANNER DETERMINED BY ITS SRCID***)%
	CASE .CSTMNT[SRCID] OF SET
	SKASMNT();		!FOR ASSIGNMENT
	SKASSI();		! ASSIGN
	SKCALL();		! CALL
	BEGIN END;		! CONTINUE (DO NOTHING)
	DOP2SKL();		! DO
	BEGIN END;		! ENTRY (DO NOTHING)
	SKASMNT();		! COMNSUB (SAME AS ASSIGNMENT IN FORMAT)

	BEGIN END;		! GOTO
	SKAGO();		! ASSIGNED GOTO
	SKCGO();		! COMPUTED GOTO
	SKARIF();		! ARITHMETIC IF
	SKLOGIF();		! LOGICAL IF
	SKRETURN();		! RETURN
	BEGIN END;		! STOP

	BEGIN			!READ
		CHKFORDOREF;	!CHECK FOR RECORD OR UNIT EQL TO DO INDEX
		INPFLAG_TRUE;
		SKIOLIST();	
	END;
	BEGIN			! WRITE
		CHKFORDOREF;	!CHECK FOR RECORD OR UNIT EQL TO DO INDEX
		INPFLAG_FALSE;
		SKIOLIST();
	END;
	BEGIN			! DECODE
		SKDECENC();
		INPFLAG_TRUE;
		SKIOLIST();
	END;
	BEGIN			! ENCODE
		SKDECENC();
		INPFLAG_FALSE;
		SKIOLIST();
	END;
	BEGIN			! REREAD
		INPFLAG_TRUE;
		SKIOLIST();
	END;
	BEGIN			! FIND
		CHKFORDOREF;	!CHECK FOR RECORD OR UNIT EQL TO DO INDEX
	END;
	BEGIN END;		! CLOSE
	BEGIN END;		! INPUT (NOT IMPLEMENTED IN RELEASE 1)
	BEGIN END;		! OUTPUT (NOT IMPLEMENTED IN RELEASE 1)

	BEGIN END;		! BACKSPACE
	BEGIN END;		! BACKFILE
	BEGIN END;		! REWIND
	BEGIN END;		! SKIP FILE
	BEGIN END;		! SKIP RECORD
	BEGIN END;		! UNLOAD
	BEGIN END;		! RELEASE
	BEGIN END;		! ENDFILE

	BEGIN END;		! END
	BEGIN END;		! PAUSE
	BEGIN END;		! OPEN
	SKSFN();		!SFN
	BEGIN END;		! FORMAT
	BEGIN END;		! BLT
	BEGIN END;		! OVERLAY ID
	TES;


	%(***IF ARE IN AN INNER DO LOOP, CHECK FOR CONDITIONS THAT PREVENT
		THE LOOP INDEX FROM BEING MAINTAINED IN A REGISTER, OR FROM BEING
		HANDLED WITH AN AOBJN***)%
	P2REGCNTS();
END;

GLOBAL ROUTINE SKASMNT=
%(***************************************************************************
	PERFORM PHASE 2 SKELETON OPTIMIZATIONS ON AN ASSIGNMENT STATEMNT
***************************************************************************)%
BEGIN
	EXTERNAL DOWDP;
	MAP OBJECTCODE DOWDP;
	OWN PEXPRNODE RHNODE:LHNODE:SSNODE;


	%(***PROCESS RIGHT HAND SIDE***)%
	IF NOT .CSTMNT[A2VALFLG]
	THEN
	BEGIN
		RHNODE_.CSTMNT[RHEXP];
		NEGFLG_FALSE;
		NOTFLG_FALSE;
		CSTMNT[RHEXP]_(.P2SKL1DISP[.RHNODE[OPRCLS]])(.RHNODE);
		IF .NEGFLG THEN
		 CSTMNT[A2NEGFLG]_NOT .CSTMNT[A2NEGFLG];	!IF A NEG IS PROPAGATED FROM BELOW,
								! COMPLEMENT THE NEGFLG IN THE STMNT NODE

		IF .NOTFLG THEN			!IF A NOT IS PROPAGATED UP FROM BELOW
		 CSTMNT[A2NOTFLG]_NOT .CSTMNT[A2NOTFLG];	! COMPLEMENT THE NOT FLAG IN THE STMNT
	END;

	%(**PROCESS LEFT HAND SIDE - IT MUST BE EITHER A SIMPLE VARIABLE,
		OR AN ARRAY REFERENCE*****)%
	IF NOT .CSTMNT[A1VALFLG]
	THEN
	%(***IF LEFT HAND SIDE IS NOT A SIMPLE VARIABLE***)%
	BEGIN
		LHNODE_.CSTMNT[LHEXP];
		IF .LHNODE[OPRCLS] NEQ ARRAYREF THEN RETURN CGERR();

		%(***IF LEFT HAND SIDE IS AN ARRAYREF - OPTIMIZE THE ADDRESS CALCULATION**)%
		IF NOT .LHNODE[A2VALFLG]
		THEN
		BEGIN
			SSNODE_.LHNODE[ARG2PTR];
			NEGFLG_FALSE;
			NOTFLG_FALSE;
			LHNODE[ARG2PTR]_(.P2SKL1DISP[.SSNODE[OPRCLS]])(.SSNODE);
			IF .NEGFLG THEN SSNODE[A2NEGFLG]_1;
			IF .NOTFLG THEN SSNODE[A2NOTFLG]_1;
		END;
	END;

	%(***IF THE VAR ON THE LEFT HAND SIDE OF THIS ASSIGNMENT STMNT IS EQUAL
		TO THE DO INDEX OF THE CURRENT DO LOOP, DONT WANT TO USE AOBJN
		IF THE INDEX IS NOT MATERIALIZED***)%
	IF .DOWDP[DOINDUC] EQL .CSTMNT[LHEXP] THEN DOWDP[DONOAOBJN]_1;
END;




GLOBAL ROUTINE SKSFN=
%(***************************************************************************
	PERFORM P2 SKEL OPTIMS ON THE EXPRESSION UNDER A STMNT FN
***************************************************************************)%
BEGIN
	OWN PEXPRNODE RHNODE;
	RHNODE_.CSTMNT[SFNEXPR];

	%(***INIT FLAGS FOR PROPAGATING NEGATES AND NOTS***)%
	NEGFLG_FALSE;
	NOTFLG_FALSE;

	CSTMNT[SFNEXPR]_(.P2SKL1DISP[.RHNODE[OPRCLS]])(.RHNODE);
END;



GLOBAL ROUTINE SKRETURN=
%(***************************************************************************
	PERFORM P2SKEL OPS ON THE EXPR UNDER A RETURN STMNT
***************************************************************************)%
BEGIN
	OWN PEXPRNODE RHNODE;
	IF (RHNODE_.CSTMNT[RETEXPR]) NEQ 0 THEN
	CSTMNT[RETEXPR]_(.P2SKL1DISP[.RHNODE[OPRCLS]])(.RHNODE);
END;

GLOBAL ROUTINE SKAGO=
%(***************************************************************************
	ROUTINE TO PERFORM PHASE 2 SKEL OPTIMS ON AN ASSIGNED GOTO.
	OPTIMS MAY BE PERFORMED ON THE ADDRESS CALC FOR THE ASSIGNED VAR
	(WHICH MAY BE AN ARRAY REF)
***************************************************************************)%
BEGIN
	OWN PEXPRNODE AGOVAR;

	AGOVAR_.CSTMNT[AGOTOLBL];

	IF .AGOVAR[OPRCLS] EQL ARRAYREF
	THEN
	CSTMNT[AGOTOLBL]_(.P2SKL1DISP[.AGOVAR[OPRCLS]])(.AGOVAR);

END;

GLOBAL ROUTINE SKCGO=
%(***************************************************************************
	ROUTINE TO PERFORM PHASE 2 SKELETON OPTIMIZATIONS ON A
	COMPUTED GOTO STATEMENT.
	PERFORM OPTIMIZATIONS ON THE COMPUTED EXPRESSION, AND THEN IF
	THE EXPRESSION COLLAPSES TO A CONSTANT, TRANSFORM THE STMNT
	TO A GOTO.
***************************************************************************)%
BEGIN
	EXTERNAL DOWDP;
	MAP OBJECTCODE DOWDP;
	OWN PEXPRNODE CGOEXP;

	CGOEXP_.CSTMNT[CGOTOLBL];

	%(***PERFORM PHASE 2 SKEL OPTIMS ON THE COMPUTED EXPRESSION***)%
	IF .CGOEXP[OPRCLS] NEQ DATAOPR
	THEN
	CGOEXP_(.P2SKL1DISP[.CGOEXP[OPRCLS]])(.CGOEXP);

	%(***IF EXPRESSION HAS REDUCED TO A CONSTANT, CHANGE STMNT TO A GOTO**)%
	IF .CGOEXP[OPR1] EQL CONSTFL
	THEN
	BEGIN
		%(***GET PTR TO THE LABEL TO BE USED (THE CONSTANT MUST ALWAYS BE
			INTEGER)****)%

		IF .CGOEXP[CONST2] GEQ .CSTMNT[GOTONUM] OR .CGOEXP[CONST2] LEQ 0
		THEN
		%(***IF CONSTANT IS LARGER THAN NUMBER OF LABELS IN LIST, OR LESS THAN 0***)%
		SKERR()
		ELSE
		CSTMNT[GOTOLBL]_@(.CSTMNT[GOTOLIST]+.CGOEXP[CONST2]);

		CSTMNT[SRCID]_GOTOID;
	END

	ELSE
	BEGIN
		CSTMNT[CGOTOLBL]_.CGOEXP;

		%(***CHECK FOR THE "COMPUTED" VAR EQUAL TO THE DO-LOOP INDEX.
			IF IT IS, THEN THIS DO LOOP SHOULD NOT USE AOBJN***)%
		IF .CGOEXP EQL .DOWDP[DOINDUC]
		THEN DOWDP[DONOAOBJN]_1;
	END;
END;

GLOBAL ROUTINE SKLOGIF=
%(***************************************************************************
	PERFORM PHASE 2 SKELETON OPTIMIZATIONS ON A LOGICAL IF STATEMENT
	CALLED WITH THE GLOBAL "CSTMNT" POINTING TO THE STATEMENT.
***************************************************************************)%
BEGIN
	EXTERNAL DOWDP;			!GLOBAL USED IN DETERMINING WHETHER THE DO-LOOP
					! EMBRACING THIS STMNT SHOULD USE AOBJN OR
					! HAVE ITS INDEX KEPT IN A REG
	MAP OBJECTCODE DOWDP;
	EXTERNAL P2SKL1DISP;			!DISPATCH TABLE INDICATING BY OPRCLS
						! WHICH ROUTINE OF P2SKEL IS TO BE
						! USED FOR AN EXPRESSION

	OWN PEXPRNODE CONDEXPR;
	OWN BASE SAVSTMNT;			!SAVE PTR TO THIS STMNT WHILE PROCESS
						! THE SUB-STATEMNET

	%(***PERFORM PHASE 2 SKELETON ON THE CONDITIONAL EXPRESSION***)%
	CONDEXPR_.CSTMNT[LIFEXPR];
	CONDEXPR_(.P2SKL1DISP[.CONDEXPR[OPRCLS]])(.CONDEXPR);
	CSTMNT[LIFEXPR]_.CONDEXPR;
	%(***IF PROPAGATED A NOT BACK UP FROM THE CONDITIONAL EXPR***)%
	IF .NOTFLG
	THEN CSTMNT[A1NOTFLG]_1;

	%(***IF CONDEXPR IS A CONSTANT, CHANGE THE LOGIF TO A CONTINUE FOLLOWED BY 
		THE SUBSTATEMENT****)%
	IF .CONDEXPR[OPR1] EQL CONSTFL
	THEN
	BEGIN
		FOLDLIF();
		RETURN;
	END

	%(***IF THE "CONDITIONAL EXPRESSION" IS SIMPLY THE LOOP INDEX OF THE INNERMOST
		EMBRACING DO LOOP, DO NOT WANT TO USE AOBJN FOR THAT DO LOOP***)%
	ELSE
	IF .CONDEXPR EQL .DOWDP[DOINDUC] THEN DOWDP[DONOAOBJN]_1;



	%(***PERFORM PHASE 2 SKELETON OPTIMIZATIONS ON THE SUBSTATEMENT ***)%
	SAVSTMNT_.CSTMNT;
	CSTMNT_.CSTMNT[LIFSTATE];

	%(***IF THE SUBSTATEMENT IS 'CONTINUE' CAN ELIMINATE THE CONDITIONAL ALTOGETHER***)%
	IF .CSTMNT[SRCID] EQL CONTID
	THEN
	%(***CHANGE THE LOGIF TO A CONTINUE***)%
	SAVSTMNT[SRCID]_CONTID

	ELSE
	P2SKSTMNT();

	CSTMNT_.SAVSTMNT;
END;

GLOBAL ROUTINE SKARIF=
%(***************************************************************************
	PERFORM PHASE 2 SKELETON OPTIMIZATIONS ON AN ARITHMETIC IF
	STATEMENT.
	CALLED WITH THE GLOBAL CSTMNT POINTING TO THE STATEMENT.
***************************************************************************)%
BEGIN
	EXTERNAL DOWDP;		!GLOBAL USED IN DETERMINING WHAT TO DO WITH THE
				! INDEX OF THE CURRENT DO LOOP
	MAP OBJECTCODE DOWDP;
	EXTERNAL P2SKL1DISP;			!DISPATCH TABLE INDICATING BY OPRCLS WHICH
						! ROUTINE OF P2SKEL TO USE FOR AN EXPRESSION
	OWN PEXPRNODE CONDEXPR;	!THE CONDITIONAL EXPRESSION UNDER THE STMNT

	OWN PEXPRNODE ARG1NODE:ARG2NODE;	!THE 2 ARGS UNDER CONDEXPR

	OWN PEXPRNODE RPTLBL;		!THE LABEL THAT OCCURS TWICE IN THIS STMNT (IF
					! ANY 2 OF THE 3 LABELS ARE THE SAME)

	CONDEXPR_.CSTMNT[AIFEXPR];

	%(***PERFORM PHASE 2 SKEL OPTIMIZ'S ON THE ARITH EXPRESSION UNDER THIS IF STMNT***)%

	CONDEXPR_(.P2SKL1DISP[.CONDEXPR[OPRCLS]])(.CONDEXPR);

	CSTMNT[AIFEXPR]_.CONDEXPR;
	CSTMNT[A1NEGFLG]_.NEGFLG<0,1>;

	%(***IF THE CONDITIONAL EXPRESSION IS A CONSTANT, CHANGE THE ARIF INTO A GOTO***)%
	IF .CONDEXPR[OPR1] EQL CONSTFL
	THEN
	BEGIN
		FOLDAIF();
		RETURN;
	END

	%(***IF THE "CONDITIONAL EXPRESSION" IS SIMPLY THE DO LOOP INDEX,
		DO NOT KEEP THAT INDEX IN THE RIGHT HALF OF AN AOBJN WD***)%
	ELSE
	IF .CONDEXPR EQL .DOWDP[DOINDUC] THEN DOWDP[DONOAOBJN]_1;




	%(***DETERMINE WHICH (IF ANY) OF THE 3 LABELS ON THE IF ARE IDENTICAL TO EACHOTHER***)%
	IF .CSTMNT[AIFLESS] EQL .CSTMNT[AIFEQL]
	THEN
	BEGIN
		%(***IF ALL 3 LABELS ARE IDENTICAL - MAKE THIS NODE BE A GOTO***)%
		IF .CSTMNT[AIFLESS] EQL .CSTMNT[AIFGTR]
		THEN
		BEGIN
			CSTMNT[SRCID]_GOTOID;
			CSTMNT[GOTOLBL]_.CSTMNT[AIFLESS];
		END

		ELSE
		CSTMNT[AIFLBEQV]_LELBEQV
	END

	ELSE
	IF .CSTMNT[AIFGTR] EQL .CSTMNT[AIFEQL]
	THEN
	CSTMNT[AIFLBEQV]_GELBEQV

	ELSE
	IF .CSTMNT[AIFLESS] EQL .CSTMNT[AIFGTR]
	THEN
	CSTMNT[AIFLBEQV]_LGLBEQV

	ELSE
	CSTMNT[AIFLBEQV]_NOLBEQV;


	%(***CHECK FOR THE ARITH EXPR A SUM OR DIFFERENCE - THEN
		IF OPERATION IS NOT DOUBLE-PREC WE WILL WANT TO GENERATE
		CODE TO TEST THE RELATION OF THE 2 TERMS UNDER THE SUM/DIFFERENCE
		RATHER THAN COMPUTING THE VALUE OF IT (WHEN
		ANY 2 OF THE 3 LABELS ARE IDENTICAL)****)%
	IF ADDORSUB(CONDEXPR) AND (NOT .CONDEXPR[DBLFLG]) AND (.CSTMNT[AIFLBEQV] NEQ NOLBEQV)
		AND (.CSTMNT[SRCLINK] NEQ 0)	!IF THIS ARITH IF IS THE TRUE BRANCH
						! UNDER A LOGICAL IF, CANNOT TRANSFORM
						! THIS ARITH IF TO A LOG IF
	THEN
	BEGIN
		%(***WANT TO TRANSFORM THE ARITHMETIC TO A LOGICAL IF-GOTO, FOLLOWED BY A GOTO***)%

		OWN RELOPERATOR;
		OWN BASE GONODE1:GONODE2;

		CSTMNT[SRCID]_IFLID;

		NAME<LEFT>_SRCSIZ+GOSIZ;
		GONODE1_CORMAN();
		GONODE1[OPRCLS]_STATEMENT;
		GONODE1[SRCID]_GOTOID;
		NAME<LEFT>_SRCSIZ+GOSIZ;
		GONODE2_CORMAN();
		GONODE2[OPRCLS]_STATEMENT;
		GONODE2[SRCID]_GOTOID;

		%(***DETERMINE WHAT RELATIONAL TO SUBSTITUTE FOR THE ARITHMETIC OPERATOR
			AND WHICH LABELS TO PUT ON EACH OF THE "GOTO"S***)%
		CASE .CSTMNT[AIFLBEQV] OF SET
		%(***IF NONE OF THE 3 LABELS ARE IDENTICAL, HAVE AN ERROR***)%
		CGERR();

		%(***IF LESS LABEL SAME AS EQL LABEL***)%
		BEGIN
			RELOPERATOR_LE;		!RELATIONAL BECOMES LE
			GONODE1[GOTOLBL]_.CSTMNT[AIFLESS];	!WHEN REL IS TRUE, GO
						! LABEL FOR LESS OR EQ
			GONODE2[GOTOLBL]_.CSTMNT[AIFGTR];
		END;

		%(***FOR LESS LABEL SAME AS GTR LABEL***)%
		BEGIN
			RELOPERATOR_N;		!RELATIONAL BECOMES NE
			GONODE1[GOTOLBL]_.CSTMNT[AIFLESS];	!WHEN REL IS TRUE, GOTO
						! LABEL FOR GTR OR LESS
			GONODE2[GOTOLBL]_.CSTMNT[AIFEQL];
		END;

		%(***FOR GTR LABEL SAME AS EQL LABEL***)%
		BEGIN
			RELOPERATOR_GE;		!RELATIONAL BECOMES GE
			GONODE1[GOTOLBL]_.CSTMNT[AIFGTR];	!WHEN REL IS TRUE, GOTO
						! LABEL FOR GTR  OR EQL
			GONODE2[GOTOLBL]_.CSTMNT[AIFLESS];
		END;
		TES;

		%(***FOR THE LABEL THAT OCCURED TWICE IN THE ORIGINAL STMNT,
			MUST DECREMENT THE REFERENCE COUNT SINCE IT IS NOW REFERENCED
			ONLY ONCE IN THE LOGICAL IF***)%
		RPTLBL_.GONODE1[GOTOLBL];
		RPTLBL[SNREFNO]_.RPTLBL[SNREFNO]-1;

		%(***IF ARITHMETIC EXPR WAS (A-B),  WILL WANT THE REALATIONAL
			A.RELAOPERATOR.B 
			TURN OFF THE NEGATE-FLAG ON ARG2
		*****)%
		IF .CONDEXPR[A2NEGFLG]
		THEN CONDEXPR[A2NEGFLG]_0

		ELSE
		%(***IF ARITHMETIC EXPRESSION WAS (A+B), THEN THE
			RELATIONAL IS OF THE FORM:
			A.RELAOPERATOR.(-B)
			SINCE WE CANNOT HANDLE AN A2NEGFLG ON A RELATIONAL WE 
			WILL EITHER:
				1. IF B IS A CONSTANT, NEGATE IT
			   OR	2. MULTIPLY THE RELATIONAL BY -1
		*******)%
		BEGIN
			ARG2NODE_.CONDEXPR[ARG2PTR];
			IF .ARG2NODE[OPR1] EQL CONSTFL
			THEN CONDEXPR[ARG2PTR]_NEGCNST(ARG2NODE)
			ELSE
			BEGIN
				%(**NEGATE THE 1ST ARG***)%
				ARG1NODE_.CONDEXPR[ARG1PTR];
				IF .ARG1NODE[OPR1] EQL CONSTFL
				THEN CONDEXPR[ARG1PTR]_NEGCNST(ARG1NODE)
				ELSE CONDEXPR[A1NEGFLG]_NOT .CONDEXPR[A1NEGFLG];

				%(***REVERSE THE SENSE OF THE RELATIONAL IF IT IS GE OR LE***)%
				IF .RELOPERATOR EQL LE THEN RELOPERATOR_GE
				ELSE
				IF .RELOPERATOR EQL GE THEN RELOPERATOR_LE;
			END;
		END;
		%(***TRANSFORM THE CONDEXPR INTO A RELATIONAL***)%
		CONDEXPR[OPERATOR]_OPERC(CONTROL,RELATIONAL,.RELOPERATOR);

		%(***TRANSFORM THE ARITH-IF STMNT INTO A LOGICAL IF***)%
		CSTMNT[SRCID]_IFLID;
		CSTMNT[AIFLBEQV]_0;
		CSTMNT[LIFSTATE]_.GONODE1;

		%(**INSERT THE EXTRA GOTO INTO THE PROGRAM***)%
		GONODE2[CLINK]_.CSTMNT[CLINK];
		CSTMNT[CLINK]_.GONODE2;

	END;

END;

GLOBAL ROUTINE SKASSI=
%(***************************************************************************
	TO PERFORM PHASE 2 SKEL OPTIMS ON AN ASSIGN STMNT.
	IF THE VAR ASSIGNED TO IS AN ARRAYREF, THERE MAY BE SOME OPTIMS THAT
	CAN BE PERFORMED ON THE ADDRESS ARITH.
***************************************************************************)%
BEGIN
	EXTERNAL P2SKLARR;
	OWN PEXPRNODE SYMNODE;
	SYMNODE_.CSTMNT[ASISYM];
	IF .SYMNODE[OPRCLS] EQL ARRAYREF
	THEN P2SKLARR(.SYMNODE);
END;



GLOBAL ROUTINE SKDECENC=
%(***************************************************************************
	TO PERFORM PHASE 2 SKEL OPTIMS ON ENCODE/DECODE STMNTS
***************************************************************************)%
BEGIN
	OWN PEXPRNODE ENCVAR;
	EXTERNAL P2SKLARR;

	ENCVAR_.CSTMNT[IOVAR];

	%(***OF THE ENCODE/DECODE ARRAY IS ACTUALLY AN ARRAYREF NODE (IE
		IT INCLUDES AN OFFSET) PERFORM P2SKEL OPTIMS  ON THE ADDR
		CALC****)%
	IF .ENCVAR[OPRCLS] EQL ARRAYREF
	THEN 
	CSTMNT[IOVAR]_P2SKLARR(.ENCVAR);

END;

GLOBAL ROUTINE SKCALL=
%(***************************************************************************
	PERFORM PHASE 2 SKEL OPTIMIZS ON ALL ARGS OF A CALL STMNT
***************************************************************************)%
BEGIN
	OWN ARGUMENTLIST ARGLST;
	OWN PEXPRNODE ARGNODE;

	ARGLST_.CSTMNT[CALLIST];		!PTR TO ARG LIST

	%(***IF THERE ARE NO ARGS, RETURN***)%
	IF .ARGLST EQL 0 THEN RETURN;

	%(***WALK THRU THE ARGS***)%
	INCR CT FROM 1 TO .ARGLST[ARGCOUNT]
	DO
	BEGIN
		IF NOT .ARGLST[.CT,AVALFLG]
		THEN
		BEGIN
			NEGFLG_FALSE;
			NOTFLG_FALSE;
			ARGNODE_.ARGLST[.CT,ARGNPTR];
			ARGLST[.CT,ARGNPTR]_(.P2SKL1DISP[.ARGNODE[OPRCLS]])(.ARGNODE);
		END;
	END;
END;


GLOBAL ROUTINE SKIOLIST=
%(***************************************************************************
	ROUTINE TO PERFORM PHASE 2 SKEL OPTIMIZATIONS ON AN IOLIST.
	WILL MAKE 3 PASSES OVER THE LIST:
		1.PERFORM PHASE 2 SKEL OPTIMS ON THE EXPRESSIONS UNDER THE LIST ELEMS
		2.DETECT DO-LOOPS THAT CAN BE FOLDED INTO ELISTS AND FOLD
		  THEM (NOT IMPLEMENTED IN RELEASE 1)
		3. DETECT GROUPS OF DATACALLS AND SLISTCALLS THAT CAN BE FOLDED
		  INTO A SINGLE IOLISTCALL AND FOLD THEM
	CALLED WITH THE GLOBAL CSTMNT POINTING TO A STATEMENT WITH A POTENTIAL IOLIST
***************************************************************************)%
BEGIN
	LOCAL BASE IOLELEM;
	LOCAL PEXPRNODE ARGNODE;
	LOCAL BASE SAVSTMNT;
	EXTERNAL DOWDP;		!GLOBAL USED IN DETERMINING WHETHER A GIVEN LOOP CAN
				! HAVE ITS LOOP INDEX LIVE IN A REGISTER
	MAP OBJECTCODE DOWDP;

	%(***IF THIS STMNT HAS NO IOLIST, RETURN***)%
	IF .CSTMNT[IOLIST] EQL 0 THEN RETURN;

	%(***SAVE PTR TO THIS STATEMENT (WILL RECURSE THRU STMNT ROUTINES  IF THERE ARE
		ANY STMNTS ON THIS IOLIST*******)%
	SAVSTMNT_.CSTMNT;

	%(***WALK THRU THE IOLIST PERFORMING PHASE 2 SKEL OPTIMS ON EACH ELEM***)%
	IOLELEM_.CSTMNT[IOLIST];
	UNTIL .IOLELEM EQL 0
	DO
	BEGIN
		IF .IOLELEM[OPRCLS] EQL STATEMENT
		THEN
		BEGIN
			CSTMNT_.IOLELEM;
			P2SKSTMNT();
		END

		ELSE
		IF .IOLELEM[OPRCLS] EQL IOLSCLS
		THEN
		BEGIN
			%(***FOR A DATACALL NODE, PERFORM PHASE 2 SKEL OPTIMS ON
				EXPRESSIONS UNDER THIS NODE***)%
			IF .IOLELEM[OPERSP] EQL DATACALL
			THEN
			BEGIN
				NEGFLG_FALSE;
				NOTFLG_FALSE;
				ARGNODE_.IOLELEM[DCALLELEM];
				IOLELEM[DCALLELEM]_(.P2SKL1DISP[.ARGNODE[OPRCLS]])(.ARGNODE);

				%(***CHECK WHETHE ARG TO FOROTS IS THE INDEX OF
					THE CURRENT DO LOOP. IF SO, WILL NOT WANT IT
					TO BE AN AOBJN LOOP (PROBLEMS WITH USING RIGHT-HALF OF REG)**)%
				ARGNODE_.IOLELEM[DCALLELEM];
				IF .ARGNODE EQL .DOWDP[DOINDUC] THEN DOWDP[DONOAOBJN]_1;
			END;
		END;

		%(***GO ON TO NEXT ELEMENT***)%
		IOLELEM_.IOLELEM[CLINK];

	END;

	%(****RESTORE CSTMNT*********)%
	CSTMNT_.SAVSTMNT;
	%(***WALK THRU THE LIST PERFORMING FOLDING OF DO-LLOPS.
		NOT IMPLEMENTED IN RELEASE 1 (AUG 17,1972 - SRM) ***)%


	%(***WALK THRU THE LIST, FOLDING GROUPS OF ELEMS THAT CAN FORM A SINGLE IOLIST***)%
	FOLDIOLST();
END;

GLOBAL ROUTINE FOLDIOLST=
%(***************************************************************************
	ROUTINE TO WALK THRU AN IOLIST FOLDING TOGETHER GROUPS OF ELEMENTS THAT CAN
	BE HANDLED BY A SINGLE CALL TO THE OPERATING SYSTEM ROUTINE IOLST.
	FOLDS TOGETHER BLOCKS OF DATACALL, SLISTCALL, AND ELISTCALL NODES
	SUCH THST:
		1.NO DO-STATEMENT NODES OR CONTINUE-STATEMENT NODES WITH
			DO TERMINATION LABELS OCCUR BETWEEN NODES
		2. FOR AN INPUT STATEMENT, NO ELEMENT IN A BLOCK HAS A VALUE WHICH
			IS DEPENDENT ON AN EARLIER ELEMENT IN THE BLOCK.
	CALLED WITH THE GLOBAL CSTMNT POINTING TO THE STATEMENT WHOSE IOLIST IS TO
	BE FOLDED.
***************************************************************************)%
BEGIN
	EXTERNAL CIOCALL;	!PTR TO CURRENT IOLISTCALL NODE BEING BUILT
	EXTERNAL CIOCLAST;	!PTR TO LAST ELEMENT ON THE IOLISTCALL NODE BEING BUILT
	MAP BASE CIOCALL:CIOCLAST;
	OWN BASE IOLELEM:PREVELEM;
	EXTERNAL INPFLAG;		!FLAG IS SET IF STMNT IS AN INPUT STMNT


	%(***GET PTR TO 1ST ELEM ON IOLIST*****)%
	IOLELEM_.CSTMNT[IOLIST];

	%(***IF THERE IS ONLY ONE ELEMENT ON THE LIST, RETURN***)%
	IF .IOLELEM[CLINK] EQL 0 THEN RETURN;

	%(***TRY TO FORM AN IOLISTCALL NODE FROM THIS ELEMENT TOGETHER WITH THE
		ELEMENT FOLLOWING IT, AND PUT THAT NODE UNDER THE IOLIST FIELD OF
		THE IO STMNT*****)%
	IF .IOLELEM[OPRCLS] EQL IOLSCLS
	THEN
	BEGIN
		IOLELEM_FORMIOLST(.IOLELEM);		!FORMIOLIST RETURNS A PTR TO
							! THE IOLIST FORMED OR (IF
							! UNSUCCESSFUL) A PTR TO IOLELEM
		CSTMNT[IOLIST]_.IOLELEM;
	END
	ELSE
	CIOCALL_-1;


	UNTIL .IOLELEM[CLINK] EQL 0
	DO
	BEGIN
		PREVELEM_.IOLELEM;
		IOLELEM_.IOLELEM[CLINK];
		%(***A STATEMENT NODE ALWAYS CAUSES TERMINATION OF AN IOLIST***)%
		IF .IOLELEM[OPRCLS] EQL STATEMENT
		THEN
		CIOCALL_-1

		ELSE
		IF .IOLELEM[OPRCLS] EQL IOLSCLS
		THEN
		BEGIN
			%(***IF THERE IS NO IOLST CURRENTLY BEING BUILT, SEE 
				WHETHER CAN MEKE ONE OF THIS ELEM AND THE
				ONE FOLLOWING IT
			*******)%
			IF .CIOCALL EQL -1
			THEN
			BEGIN
				IOLELEM_FORMIOLST(.IOLELEM);
				PREVELEM[CLINK]_.IOLELEM;
			END

			ELSE
			%(***ON INPUT, IF THE VALUE OF THIS EXPRESSION IS DEPENDENT
				ON THE CONTENTS OF THE IOLIST BEING FORMED,
				THEN TRY TO START A NEW IOLIST WITH THIS ELEM AND
				THE ONE FOLLOWING IT
			****)%
			IF .INPFLAG AND DEFONCIOL(.IOLELEM)
			THEN
			BEGIN
				%(***TERMINATE CURRENT IOLIST***)%
				CIOCALL_-1;

				IOLELEM_FORMIOLST(.IOLELEM);
				PREVELEM[CLINK]_.IOLELEM;
			END

			ELSE
			%(***IF THIS ELEMENT CAN BE ADDED TO THE IOLIST BEING
				FORMED, ADD IT***)%
			BEGIN
				%(***REMOVE THIS ELEM FROM THE IOLIST BY LINKING THE
					IOLISTCALL NODE (WHICH DIRECTLY PRECEEDED IT)
					TO THE ELEMENT AFTER IT***)%
				CIOCALL[CLINK]_.IOLELEM[CLINK];

				%(***PUT THIS ELEMENT UNDER THE IOLISTCALL NODE***)%
				CIOCLAST[CLINK]_.IOLELEM;
				IOLELEM[CLINK]_0;
				CIOCLAST_.IOLELEM;

				%(***SET "CURRENT IOLIST ELEMENT" TO BE THE IOLISTCALL NODE***)%
				IOLELEM_.CIOCALL;
			END;

		END;
	END;
END;

GLOBAL ROUTINE FORMIOLST(IOLELEM)=
%(***************************************************************************
	ROUTINE TO TRY TO FORM A SINGLE IOLSTCALL NODE
	FROM THE IOLIST ELEMENT "IOLELEM" AND THE IOLIST ELEMENT THAT FOLLOWS
	IT.
	IF THIS ROUTINE IS SUCCESSFUL IN FORMING AN IOLIST, IT
	SETS THE GLOBAL CIOCALL TO POINT TO THE IOLISTCALL NODE CREATED, AND THE
	GLOBAL CIOCLAST TO POINT TO THE "LAST" ELEMENT UNDER THAT LIST (IE THE 2ND
	ELEMENT).
	IF IT WAS UNSUCCESSFUL, IT SETS CIOCALL TO -1
	RETURNS A PTR TO THE NODE FORMED IF SUCCESSFUL, A PTR TO IOLELEM IF NOT.
	IS CALLED WITH THE GLOBAL INPFLAG=TRUE IF THE STMNT INVOLVED IS AN INPUT STMNT.
***************************************************************************)%
BEGIN
	EXTERNAL CIOCALL;		!PTR  TO CURRENT IOLISTCALL NODE BEING BUILT
	EXTERNAL CIOCLAST;		!PTR TO LAST ELEMENT UNDER CIOCALL
	MAP BASE IOLELEM;
	OWN BASE IOLNODE;
	OWN BASE NXTELEM;
	EXTERNAL INPFLAG;		!FLAG IS SET IF THIS STMNT IS AN INPUT
					! STMNT - THIS FLAG SHOULD BE SET PRIOR TO ENTERING
					! THIS ROUTINE


	CIOCALL_-1;
	%(****IF IOLELEM IS THE LAST ELEM ON THE IOLIST, CANNOT DO ANYTHING***)%
	IF .IOLELEM[CLINK] EQL 0 THEN RETURN .IOLELEM;
	%(***IF THE 1ST NODE CONTAINS FN-CALLS, CANNOT FORM AN IOLST***)%
	IF CONTFN(.IOLELEM) THEN RETURN .IOLELEM;

	NXTELEM_.IOLELEM[CLINK];

	%(***IF THE 2ND NODE IS A STMNT, CANNOT FORM AN IOLST***)%
	IF .NXTELEM[OPRCLS] EQL STATEMENT THEN RETURN .IOLELEM;

	%(***FOR INPUT STMNTS, THE VAL OF THE 2ND ARG CANNOT BE
		DEPENDENT ON THE VAL OF THE 1ST ***)%
	IF .INPFLAG
	THEN
	BEGIN
		IF IODEPNDS(.NXTELEM,.IOLELEM) THEN RETURN .IOLELEM;

	END;

	%(***MAKE A NEW NODE - OPRCLS=IOLSCLS, OPERSP=IOLSTCALL****)%
	IOLNODE_GETCORE(IOLCSIZ,IOLCCD);
	IOLNODE[OPERATOR]_IOLSTCFL;
	IOLNODE[IOLSTPTR]_.IOLELEM;

	%(***SET THE LINK FIELD OF THE NODE CREATED TO PT TO THE ELEM AFTER THE LAST
		ELEM REMOVED FROM TH IOLIST AND PUT UNDER THIS IOLISTCALL***)%
	IOLNODE[CLINK]_.NXTELEM[CLINK];

	%(***SET THE LINK OF THE LAST ELEM UNDER THE IOLSTCALL TO 0***)%
	NXTELEM[CLINK]_0;

	%(***SET UP THE GLOBALS CIOCALL (PTR TO IOLSTCALL NODE BEING FORMED) AND CIOCLAST (PTR
		TO LAST ELEM UNDER CIOCALL) ****)%
	CIOCALL_.IOLNODE;
	CIOCLAST_.NXTELEM;
	RETURN .IOLNODE;
END;


GLOBAL ROUTINE IODEPNDS(IOELEM2,IOELEM1)=
%(***************************************************************************
	ROUTINE TO DETERMINE WHETHER THE IOLIST ELEMENT IOELEM2 HAS A VALUE
	WHICH IS DEPENDENT ON THE EVALUATION OF IOLELEM1.
	THIS ROUTINE IS ONLY CALLED FOR INPUT IOLISTS - HENCE IT CAN
	BE ASSUMED THAT THE ELEMENT UNDER A DATACALL CAN ONLY BE A
	VARIABLE OR ARRAYREF.
	THIS ROUTINE IS ONLY CALLED FOR BOTH IOLELEM1 AND IOLELEM2 WITH
	OPRCLS=IOLSCLS
***************************************************************************)%
BEGIN
	OWN PEXPRNODE ARGNOD1:ARGNOD2;
	MAP BASE IOELEM1:IOELEM2;

	CASE .IOELEM2[OPERSP] OF SET

	%(***FOR 2ND ELEM A DATACALL*****)%
	BEGIN
		ARGNOD2_.IOELEM2[DCALLELEM];

		IF .ARGNOD2[OPRCLS] EQL ARRAYREF AND .ARGNOD2[ARG2PTR] NEQ 0
		THEN
		BEGIN
			%(***CHECK FOR THE SS EXPRESSION DEPENDENT ON IOELEM1***)%
			CASE .IOELEM1[OPERSP] OF SET
			%(***FOR IOELEM1 A DATACALL***)%
			BEGIN
				ARGNOD1_.IOELEM1[DCALLELEM];
				%(***IF ARG UNDER IOELEM1 IS AN ARRAYREF , SEE IF THAT
					ARRAYNAME OCCURS ANYWHERE UNDER THE SS EXPR FOR
					IOELEM2***)%
				IF .ARGNOD1[OPRCLS] EQL ARRAYREF
				THEN
				RETURN CONTVAR(.ARGNOD2[ARG2PTR],.ARGNOD1[ARG1PTR])

				%(**IF ARG UNDER IOELEM1 IS A VARIABLE, SEE IF THAT
					VAR OCCURS ANYWHERE IN THE  SS EXPR FOR IOELEM2***)%
				ELSE
				RETURN CONTVAR(.ARGNOD2[ARG2PTR],.ARGNOD1);
			END;

			%(***FOR IOELEM1 AN SLISTCALL***)%
			BEGIN
				%(**IF THE SS EXPR FOR IOELEM2 CONTAINS ANY OF THE
					ARRAY NAMES UNDER THIS NODE, THEN IOELEM2 IS DEP***)%

				%(****NOTE AUG 18, 1972 - WE CAN PRESENTLY ONLY
					HANDLE SLISTS WITH A SINGLE ARRAY (RELEASE 1) - SRM***)%

				RETURN CONTVAR(.ARGNOD2[ARG2PTR],.IOELEM1[SCALLELEM]);
			END;

			%(***IF IOELEM1 IS AN IOLSTCALL NODE - HAVE AN ERROR***)%
			SKERR();

			%(***IF IOELEM1 IS AN ELIST - NOT IN RELEASE 1***)%
			BEGIN END;

			TES;
		END
		ELSE
		RETURN FALSE;
	END;

	%(***FOR IOELEM2 AN SLISTCALL NODE*****)%
	%(*****FOR RELEASE 1 - NO PART OF AN SLISTCALL CAN BE DEPENDENT ON THE
		PRECEEDING IOLIST ELEMENT - SRM - AUG 18,1972***)%
	RETURN FALSE;

	%(***FOR IOELEM2 AN IOLISTCALL NODE - SHOULD NEVER GET HERE***)%
	SKERR();

	%(***FOR IOELEM2 AN ELISTCALL - NOT IMPLEMENTED IN VERSION 1***)%
	BEGIN END;

	TES;

END;

GLOBAL ROUTINE DEFONCIOL(IOELEM)=
%(***************************************************************************
	TEST WHETHER THE LOC SPECIFIED BY THE IOLIST ELEMENT IOELEM
	IS AFFECTED BY CHANGES IN VALUES OF ANY VARIABLES UNDER THE
	IOLISTCALL NODE POINTED TO BY THE GLOBAL "CIOCALL" 
	IOELEM IS KNOWN TO BE AN ELEMENT ON AN IOLIST FOR AN INPUT STMNT
***************************************************************************)%
BEGIN
	EXTERNAL CIOCALL;
	MAP BASE CIOCALL;
	MAP BASE IOELEM;
	OWN BASE IOELEM1;

	IOELEM1_.CIOCALL[IOLSTPTR];

	%(***CHECK FOR IOELEM DEPENDENT ON EACH ELEMENT UNDER CIOCALL***)%
	UNTIL .IOELEM1 EQL 0
	DO
	BEGIN
		IF IODEPNDS(.IOELEM,.IOELEM1) THEN RETURN TRUE;
		IOELEM1_.IOELEM1[CLINK];
	END;

	RETURN FALSE;
END;


!AUTHOR: NORMA ABEL
OWN CTR;




!ROUINE TO HANDLE P2SKELETON FUNCTIONS FOR DO STATEMENTS
GLOBAL ROUTINE DOP2SKL=
BEGIN
	EXTERNAL CHOSEN;
EXTERNAL CSTMNT,MAKPR1,NEGFLG,NOTFLG,DOWDP,CDONODE,MAKEPR;
!CSTMNT POINTS AT THE ENCODED SOURCE NODE
LOCAL BASE DOEXPR;
	EXTERNAL P2SKL1DISP;

MAP OBJECTCODE DOWDP;
MAP BASE CSTMNT:CDONODE;

!INITIALIZE NEGFLG AND NOTFLG TO FALSE
	NEGFLG_FALSE;
	NOTFLG_FALSE;

	DOEXPR_.CSTMNT[DOLPCTL];
	!CALL THE DISPATCH
	IF .DOEXPR[OPRCLS] NEQ DATAOPR THEN
		CSTMNT[DOLPCTL]_
		(.P2SKL1DISP[.DOEXPR[OPRCLS]])(.DOEXPR);
	!SET UP (IF NECESSARY FOR THE LEAF SUBSTITUTION OF
	!REG-CONTENTS NODES FOR THE DO INDUCTION VARIABLE

!TO INSURE OPTIMAL (HA-HA)  USEAGE OF THE INDUCTION VARIABLE IN
!A REGISTER ON AN INNER DO LOOP THE GLOBAL CDONODE WILL
!POINT BACK TO THE DO STATEMENT SO THAT FLAGS CAN BE SET AND
!UNSET PROPERLY (CHANGE FOR LARGE SORCE SOLUTION********)
!DOWDP WILL ALSO POINT TO A WORD OF THE FORMAT
!
!	!-------------------------------!
!	!X!Y!         	! DOINDUC	!
!	!-------------------------------!

!WHERE X IS THE INNERDOFLG AND IS USED TO SIGNAL THAT
!REGCONTENTS NODE SUBSTITUTION IS STILL VALID.
!Y IS SET WHILE PROCESSING THE STMNTS IN THE LOOP IF THE LOOP INDEX IS
! USED IN A CONTEXT THAT PREVENTS USE OF AN AOBJN IF THE LOOP INDEX IS TO
! BE LEFT IN A REGISTER (EG IF THE LOOP INDEX IS USED AS AN ARG TO FOROTS OR
! IN A COMPUTED GOTO
!DOREGPTR POINTS TO THE REGCONTENTS NODE
!DO INDUC POINTS TO THE INDUCTION VARIABLE




	IF .CSTMNT[INNERDOFLG] THEN
	BEGIN
		DOWDP_0;
		CDONODE_.CSTMNT;
		DOWDP[DOINDUC]_.CSTMNT[DOSYM];
		CSTMNT[NEDSMATRLZ]_0;
		DOWDP[DOISUBS]_1;
		DOWDP[DONOAOBJN]_0;	!FLAG THAT INDICATES THAT FOUND THE
					! LOOP INDEX USED IN A CONTEXT THAT
						! PREVENTS USE OF AOBJN
		!WE WILL TRY TO DETECT LOCAL LABELS AND NOT
		!STOP KEEPING THE INDEX VARIABLE IN A REG
		!CUZ OF SUCH. HERE WE WILL MAKE A LIST OF
		!ALL LABELS WHICH APPEAR ON STATEMENTS IN THE
		!RANGE OF THE LOOP
		!CHOSEN IS USED TO HOLD THIS INFO.

		CTR_1;
		CHOSEN[0]_.CDONODE[DOLBL];
		!THE DO TERMINATING LABEL WONT BE COUNTED AGAIN

		DOEXPR_.CDONODE[SRCLINK];
		WHILE .DOEXPR[SRCLBL] NEQ .CDONODE[DOLBL] DO
		BEGIN
			IF .DOEXPR[SRCLBL] NEQ 0 THEN
			BEGIN
				CHOSEN[.CTR]_.DOEXPR[SRCLBL];
				CTR_.CTR+1;
				IF .CTR GEQ 32 THEN
				BEGIN
					!CHOSEN IS FULL. FORGET IT.
					DOWDP[DOISUBS]_0;
					CDONODE[NEDSMATRLZ]_1;
					RETURN;
				END;
			END;
			DOEXPR_.DOEXPR[SRCLINK];
		END;
	END;
END;			!ROUTINE
FORWARD LOOKOUT,LOKIOUT;

MACRO QUIT=
BEGIN
	DOWDP[DOISUBS]_0;
	CDONODE[NEDSMATRLZ]_1;
END$;
GLOBAL ROUTINE P2REGCNTS=
BEGIN
	!DEPENDING ON THE STATEMENT TYPE
	!DETERMINE IF THE INDUCTION VARIABLE CAN BE KEPT IN
	!A REGISTER THROUGHOUT THE ENTIRE LOOP.
	!THE THINGS THAT PREVENT THIS ARE:
	!	1.TRANSFER OUT OF LOOP
	!	2.LOOP ENTRANCE
	!	3.OUTPUT DOING STATEMENT WHICH WRITES THE 
	!	  INDUCTION VARIABLE BY ITSELF.
	!	4.A NON-LIBRARY FUNCTION REFERENCE WITH
	!	  DO INDUCTION VARIABLE AS PARAMETER OF IN COMMON.
	EXTERNAL DOWDP;
	EXTERNAL CDONODE;
	MAP BASE CDONODE;
	EXTERNAL CSTMNT;
	MAP BASE CSTMNT;
	MAP OBJECTCODE DOWDP;
	!ASSUMES ORDERING OF SRCIDS
	EXTERNAL USERFNFLG;
	OWN LBLPTR;

	OWN BASE ARGNOD;

	%(***IF ARE AT THE TERMINATION LABEL OF THE DO LOOP WHOSE STMNT
		NODE WAS THE LAST DO STMNT SEEN (HENCE ARE AT THE TERMINATION
		OF AN INNERMOST-LOOP)****)%
	IF (.CSTMNT[SRCLBL] EQL .CDONODE[DOLBL]) AND (.CSTMNT[SRCLBL] NEQ 0)

	THEN
	BEGIN
		%(***IF THE FLAG "DOISUBS" HAS BEEN TURNED OFF WHILE PROCESSING
			THE STATEMENTS IN THIS LOOP, MUST SET "NEDSMATRLZ" FLAG
			ON THE DO-LOOP NODE***)%
		IF NOT .DOWDP[DOISUBS]
		THEN CDONODE[NEDSMATRLZ]_1;

		%(***IF THE FLAG "DONOAOBJN" HAS BEEN SET WHILE PROCESSING
			THE STATEMENTS IN THIS LOOP, MUST UNDO THE DETERMINATION
			THAT THIS LOOP BE HANDLED WITH AN AOBJN***)%
		IF .DOWDP[DONOAOBJN]
		THEN
		BEGIN
			CDONODE[NOFLCWDREG]_1;	!SET FLAG SO THAT THE OPTIMIZER WONT LATER
						! DECIDE TO HAVE THE LOOP BE HANDLED
						! BY AN AOBJN THAT LIVES IN A REG

			IF .CDONODE[FLCWD] AND NOT .CDONODE[NEDSMATRLZ]
			THEN UNFLDO(.CDONODE);
		END;

	END;

	IF NOT .DOWDP[DOISUBS] THEN RETURN;


	!CHECK FOR HARMLESS STATUS QUO FORMAT
	IF .CSTMNT[SRCID] EQL FORMID THEN RETURN;
	IF .CSTMNT[SRCID] GEQ ENCOID THEN
		(QUIT; RETURN);


	IF .USERFNFLG THEN
	BEGIN
		ARGNOD_CDONODE[DOSYM];
		IF .ARGNOD[IDATTRIBUT(INCOM)] THEN
		QUIT
	END;

	CASE .CSTMNT[SRCID] OF SET
	!ASSIGNMENT
	BEGIN
		IF NOT .DOWDP[DOISUBS] THEN
			CDONODE[NEDSMATRLZ]_1;
	END;
	!
	!ASSIGN STATEMENT
	BEGIN END;		!ILLEGAL
	!
	!CALL
	QUIT;
	!
	!CONTINUE
	BEGIN
	END;
	!
	!DOID
	BEGIN END;		!ILLEGAL
	!
	!ENTRID		!ILLEGAL
	BEGIN END;

	!
	!COMNSUB
	BEGIN END;
	!
	!GOTOID
	LOOKOUT(.CSTMNT[GOTOLBL]);
	!
	!AGOTOT
	BEGIN
		IF .CSTMNT[GOTOLIST] EQL 0 THEN QUIT
		ELSE
		DECR I FROM .CSTMNT[GOTONUM]-1 TO 0 DO
		BEGIN
			LBLPTR_@(.CSTMNT[GOTOLIST]+.I);
			LOOKOUT(.LBLPTR);
		END;
	END;
	!
	!CGOTO
	BEGIN
		DECR I FROM .CSTMNT[GOTONUM]-1 TO 0 DO
		BEGIN
			LBLPTR_@(.CSTMNT[GOTOLIST]+.I);
			LOOKOUT(.LBLPTR);
		END;
	END;

	!ARITHMETIC IF
	BEGIN
		LOOKOUT(.CSTMNT[AIFLESS]);
		LOOKOUT(.CSTMNT[AIFEQL]);
		LOOKOUT(.CSTMNT[AIFGTR]);
	END;
	!
	!LOGICAL IF
	BEGIN
		LOCAL BASE T1;
		T1_.CSTMNT;
		CSTMNT_.CSTMNT[LIFSTATE];
		P2REGCNTS();
		CSTMNT_.T1;
		IF NOT .DOWDP[DOISUBS] THEN
			CDONODE[NEDSMATRLZ]_1;
	END;
	!
	!RETURN
		QUIT;
	!
	!STOP
	BEGIN END;
	!
	!READ
	BEGIN
		IF .CSTMNT[IOEND] EQL 0 AND .CSTMNT[IOERR] EQL 0 THEN
		BEGIN
			IF NOT .DOWDP[DOISUBS] THEN
				 CDONODE[NEDSMATRLZ]_1;
		END ELSE
				LOKIOUT();
	END;
	!
	!WRITE
	BEGIN
		IF .CSTMNT[IOEND] EQL 0 AND .CSTMNT[IOERR] EQL 0 THEN
		BEGIN
			IF NOT .DOWDP[DOISUBS] THEN
				CDONODE[NEDSMATRLZ]_1;
		END ELSE
			LOKIOUT();
	END;
	!
	!DECODE
	BEGIN
		IF NOT .DOWDP[DOISUBS] THEN 
			CDONODE[NEDSMATRLZ]_1;
	END;
	!
	!ENCODE
	BEGIN
		IF NOT .DOWDP[DOISUBS] THEN
			CDONODE[NEDSMATRLZ]_1;
	END;
	TES;
	IF .CSTMNT[SRCLBL] NEQ 0 THEN
	BEGIN
		IF .CDONODE[DOLBL] EQL .CSTMNT[SRCLBL] THEN
		DOWDP[DOISUBS]_0;
	END;
END;
ROUTINE LOOKOUT(LABLE)=
BEGIN
	EXTERNAL CHOSEN,DOWDP,CDONODE;
	MAP BASE CDONODE;
	MAP OBJECTCODE DOWDP;
	!SEARCH THE VECTOR CHOSEN FOR THE LABEL
	!LABLE. IF NOT THERE THEN RESET DOWDP[DOISUBS] AND
	!SET NEDSMATRLZ. (THE MACRO QUIT).

	INCR I FROM 0 TO .CTR DO
	BEGIN
		IF .CHOSEN[.I] EQL .LABLE THEN
		RETURN;
	END;

	!IF WE GOT HERE THEN IT IS AN EXIT
	QUIT;
END;

!*********************************************************
ROUTINE LOKIOUT=
BEGIN
	EXTERNAL CSTMNT;
	EXTERNAL DOWDP;
	MAP OBJECTCODE DOWDP;
	MAP BASE CSTMNT;
	!CSTMNT POINTS TO AN I/O STATEMENT.
	!LOOK AT IOEND AND IOERR TO SEE IF THEY ARE LOCAL

	IF .CSTMNT[IOEND] NEQ 0 THEN
		LOOKOUT(.CSTMNT[IOEND]);

	IF .CSTMNT[IOERR] NEQ 0 THEN
		LOOKOUT(.CSTMNT[IOERR]);
END;
!
!**************************************************************

  D+:Æ