TITLE CDRSTK---INPUT SPOOLER FOR MULTIPROGRAMMING BATCH
;  COPYRIGHT 1971,1972 DIGITAL EQUIPMENT CORP., MAYNARD, MASS.
SUBTTL	7-DEC-71/A.W.LYONS/AWL

EDITOR==0
VERNUM==12
VCUSTM==0
VPATCH==40

VLEFT=VCUSTM+VERNUM*100+EDITOR*100000

TWOSEG

MLON

LOC 137
VLEFT,,VPATCH
RELOC

;CONDITIONAL ASSEMBLIES

IFNDEF	MAXCOR,<MAXCOR=^D64>	;SYSTEM MAXIMUM CORE IN K
IFNDEF	MAXCAR,<MAXCAR=^D10000>	;MAXIMUM CARDS OUTPUT
IFNDEF	DEFCOR,<DEFCOR=^D25000>	;DEFAULT CORE IN WORDS
IFNDEF	DEFPAG,<DEFPAG=^D200>	;DEFAULT PAGES
IFNDEF	DEFTIM,<DEFTIM=^D300>	;DEFAULT TIME IN SECONDS
IFNDEF	DEFWID,<DEFWID=^D80>	;DEFAULT CARD WIDTH IN COLS.
IFNDEF	MAXWID,<MAXWID=^D80>	;MAXIMUM CARD WIDTH
IFNDEF	CODEWD,<CODEWD=0>	;$PASSWORD CARD REQUIRED AT SITE
IFNDEF	OPEROK,<OPEROK=0>	;OPERATOR O.K. NOT NECESSARY TO
				; SIMULATE END OF JOB CARDS
IFNDEF	SPOOLR,<SPOOLR=0>	;USE SPOOL COMMANDS
				; IF -1, KLUDGE $FORTRAN DATA
IFNDEF	SUBROU,<SUBROU=0>	;USE SUBROUTINE "TRYUFD" TO
				; LOOKUP/ENTER UFD'S
				;IF .NQ. 0, USE CDRSTK CODE
IFNDEF	JST026,<JST026=0>	;DEFAULT TO 026 MODE
IFNDEF	JST029,<JST029=0>	;DEFAULT TO D029 MODE


OPDEF	TTCALL[51B8]
OPDEF	OUTCHR[TTCALL 1,]
OPDEF	OUTSTR[TTCALL 3,]
OPDEF	INCHWL[TTCALL 4,]
OPDEF	INCHSL[TTCALL 5,]
OPDEF	SKPINL[TTCALL 14,]
OPDEF	PJRST[JRST]
OPDEF	HIBERN[CALLI 72]	;HIBERNATE UUO

;ACCUMULATORS

F=0	;FLAGS  LH==PERMANENT----RH==TEMPORARY
T1=1	;TEMPORARY STORAGE REGISTERS
T2=2
T3=3
T4=4
P1=5	;PRESERVED STORAGE
P2=6
P3=7
P4=10
G1=11	;GLOBAL STORAGE
G2=12
G3=13
G4=14
C=15	;CHARACTERS
M=16	;MESSAGE POINTER
P=17	;PUSH-DOWN POINTER
SUBTTL	FLAG BITS IN ACC. "F"

;FLAGS (LH OF F)

NOQUE=1		;MAKE NO QUEUE ENTRY FOR THIS JOB
ASCII=2		;ASCII MODE SPECIFIED
CREFSP=4	;/CREF DETECTED ON $LANGUAGE OR $DECK CARD
IMAGE=10	;IMAGE MODE FLAG
BINARY=20	;BINARY MODE FLAG
SUPRES=40	;SUPPRESS TRAILING SPACES
SIXFL=100	;READ DECK AS 026 CARD CODE
NINEFL=200	;READ DECK AS D029 CARD CODE
MULTI=400	;MULTI/SINGLE
GOFLAG=1000	;IS "GO" REQUIRED AFTER "STOP" TEXT
STOP=2000	;PAUSE AT NEXT EOF
DECK=4000	;UNDER THE INFLUENCE OF A $DECK CARD==1
JOBS=10000	;TYPE EACH $JOB TO OPERATOR
DOLLAR=20000	;TYPE EACH $ CARD TO OPERATOR
ALL=40000	;TYPE ALL CARDS TO OPERATOR
FIRST=100000	;TYPE FIRST FATAL ERROR MESSAGE OF JOB
EACH=200000	;TYPE EACH ERROR MESSAGE OF JOB
SHORT=400000	;SHORT/LONG MESSAGES TO OPERATOR

;FLAGS (RH OF F)

MESGOK=1	;ALLOW OPERSTOR TO OUT MESSAGE TO FILE.LOG
HIGHIN=2	;HIGH SEGMENT IS IN CORE NOW
CBLCRD=4	;ALLOW /S AS VALID $LANGUAGE SWITCH(COBOL ONLY)
STAR=10		;ACTIVE/INACTIVE BIT 0--"*", 1--"!"
FORSEE=20	;$FOR/$F4/$F40 SEEN
FATSEE=40	;FATAL ERROR DETECTED IN DECK
CDRFLA=100	;PHYSICAL DEVICE 0==CDR
DATCDS=200	;$DATA WAS LAST CDRSTK CONTROL CARD SEEN
LANGUE=400	;ENTERED SWITCH PROCESSING FROM A $LANGUAGE CARD
CARDER=1000	;ERROR DETECTED ON CARD FLAG
REPLCE=2000	;CREATE UNIQUE FILE NAME?
OCTALN=4000	;CONVERT THIS NUMBER TO OCTAL
FRSTWD=10000	;FIRST WORD DETECTED FROM ACCT.SYS?
EODERR=20000	;MISSING EOD CARD
TYPED=40000	;OPERATOR TYPED IN SWITCH
FATAL=100000	;FATAL ERROR DETECTED
OKAY=200000	;FILE OUTPUT OKAY FLAG
CONTIN=400000	;CONTINUED ON NEXT CARD ("-" SEEN AT END OF CARD)
SUBTTL	I/O CHANNELS, DEFAULTS, LITERALS

;I/O CHANNELS

DSK=1
TTY=2
CDR=3
DSK1=4
DSK2=5
DSK3=6
UFD=7


;LITERALS

CNTLC=3		;CONTROL C
CR=15
LF=12
TAB=11
SPACE=40
COMMA=54

;ASSORTED SYMBOLS USED WHEN CHECKING ACCT.SYS AND AUXACC.SYS
; ENTRY FOR USER
; REFERENCED IN $PASSWORD CARD PROCESSING

BADUSR=20
NAMREQ=4
OKGUY=1
ACCFOR=2
FORMAT=2
AC1BLK=5

SUBTTL	INITIALIZATION AND MAIN TTY INTERFACE LOOP

;HERE TO START STACK, INITIALIZE DEFAULTS, AND
; LOOP THROUGH ANY OPERATOR ACTIONS PRIOR TO THE
; "START" COMMAND BEING ISSUED.

EXTERN	.JBFF, .JBREL, .JBREN, .JBINT, .HELPR, QUEUER
INTERN	QUEUEM, QUEUEN

START:	RESET			;START HERE
	MOVE	P,PDLINI	;INITIALIZE PUSHDOWN LIST
	PUSHJ	P,GETHGH	;MAKE SURE HAVE HIGH SEGMENT
	PUSHJ	P,CLEAR		;CLEAR OUT LOW STORAGE
				; AND RESET DEFAULTS
	MOVE	T1,.JBFF	;GET INITIAL JOBFF
	ADDI	T1,4*36		;ADD ROOM FOR 4 CDR BUFFERS
	MOVEM	T1,JOBSV1	;PRESERVE SIZE FOR LATER RESETTING
	PUSHJ	P,RELHGH	;RELEASE HIGHSEGMENT
STRTUP:	PUSHJ	P,CTLSET	;SET UP TTY I/O
RETRY:
RETRY1:	PUSHJ	P,GOGO		;GET OPER TYPE-IN
	  JRST	RETRY1		;JUST KEEP WAITING
	PUSHJ	P,RELHGH	;RELEASE UNTIL NEEDED
	JRST	RETRY		;REOUTPUT "*" TO OPERATOR
SUBTTL	INTERACTIVE COMMANDS


;HERE ARE THE ROUTINES FOR INPUT AND PROCESSING OF
; INTERACTIVE COMMANDS DURING A STACK RUN.  THESE ROUTINES
; WILL BE ACCESSED PRIOR TO EACH CARD INPUT.

SLEEP1:	MOVEI	T1,1		;SLEEP FOR A SEC.
SLEEP2:	MOVE	T2,T1		;COPY SLEEP ARG
	IMULI	T2,^D1000	;MAKE T2===MILLISECS
	HIBERN	T2,		;USE HIBERNATE UUO
	SLEEP	T1,		;SLEEP IF HIBER NOT IN
OPERIN:	SKPINL	0		;OPERATOR INPUT A LINE YET?
	POPJ	P,		;NO, RETURN TO CALL
GOGO:	PUSHJ	P,RELHGH
	INPUT	TTY,		;GO TO GET TYPE-IN
	TRO	F,TYPED		;SET TYPED IN BIT
	PUSHJ	P,GETHGH	;GET HIGH SEGMANT
	JRST	GOGO1		;GO TO PROCESS
SUBTTL	CDR INPUT ROUTINES


CDRTRP:	HRRZ	T1,JOBIN1	;GET INTERCEPT CODE
	CAIE	T1,2		;WAS A CONTROL C DETECTED?
	JRST	CDRTP1
	EXIT	1,		;EXIT WITHOUT RELEASE
CDRTP1:	TRNN	F,OKAY		;WHEN DID TRAP OCCUR
	JRST	CDRTR1		;BETWEEN JOBS
	PUSHJ	P,GETHGH	;IN A JOB, PREPARE FOR OPERATOR TELL
	JRST	NOCARD		;GO ADVISE OPERATOR
CDRTR1:	POP	P,T1		;TRAP OCCURS AFTER TWO PUSHJ'S
	POP	P,T1		;TO CLEAR THE PUSHDOWN LIST
	PUSHJ	P,RELHGH
	RELEAS	CDR,		;CROCK, BUT WE MUST RELEASE BEFORE LOWLOW
	MOVE	T1,JOBSV1
	MOVEM	T1,.JBFF
	PUSHJ	P,LOWLOW	;GO DO THE CORE
CDRTRY:	RELEASE	CDR,		;RELEASE FOR NAP
	PUSHJ	P,RELHGH
	SETZM	JOBIN2
	SETZM	JOBIN3
	SKIPG	T1,ZZZSAV	;RETRIEVE SLEEP ARGUMENT
	MOVEI	T1,5		;LOAD DEFAULT OF 5
	PUSHJ	P,SLEEP2	;DO THE SLEEP THING
CDRSET:	PUSHJ	P,RELHGH	;RID OF HIGH SEGMENT
	MOVEI	T1,10		;SET UP FOR IMAGE MODE
	TLNE	F,ASCII		;ASCII MODE SPECIFIED?
	MOVEI	T1,1		;YES, USE ASCII LINE MODE
	TRZ	F,CDRFLA	;INITIALIZE DEVICE FLAG
	SKIPN	T2,PHYNAM	;WAS DEVICE SPECIFIED?
	JRST	NORM		;NO FOLLOW OLD PATH
	HRLI	T1,400000
	JRST	NORM1		;USE OLD DEVICE NAME
NORM:	MOVE	T2,INDEV	;DEVICE NAME
NORM1:	MOVEI	T3,CDRBUF	;CARD READER BUFFER
	OPEN	CDR,T1		;DO THE OPEN
	  JRST	CDRTRY		;TRY LATER
	INBUF	CDR,4

NORMX:
	MOVEI	T1,CDR		;GET CHANNEL NUMBER
	DEVNAM	T1,		;GET REAL DEVICE NAME
	MOVEI	T1,0		;PHYSICAL==LOGICAL DEVICE
	MOVEM	T1,PHYNAM	;STORE FOR LATER
	MOVE	T1,INDEV	;GET DEVICE NAME FOR DEVCHR
	DEVCHR	T1,		;FIND OUT ABOUT REAL DEVICE
	TLNE	T1,100000	;IS DEVICE A REAL CDR?
	JRST	CDRGO		;YES--RETAIN CDR AS DEVICE
	TRO	F,CDRFLA	;DEVICE .NQ. CDR
	MOVEI	T1,4*<203-36>	;THEREFORE BIGGER INPUT BUFFERS
	ADDM	T1,JOBSV1	;  SO FUDGE UP JOBSV1
	TLNN	T1,30		;IS DEVICE A MAG TAPE??
	TLO	F,MULTI		;NO, DEFAULT TO /SINGLE IF NOT
	TLO	F,ASCII		;READ DEVICE IN ASCII MODE
	TLZ	F,BINARY+SIXFL+NINEFL
	HRLZI	T1,700		;TO UPDATE BUFFER HEADER
	MOVEM	T1,CDRBUF+1	; TO ASCII MODE
	SKIPE	PSAVER		;P#,,P# SPECIFIED??
	JRST	NORM2		;YES, USE SPECIFIED #,,#
	MOVE	T1,RUNNER	;NO, GET PPN OF RUNNER
	MOVEM	T1,PSAVER	;AND SAVE FOR LATER
NORM2:	MOVE	T2,PSAVER	;FOR ACCESS UUO
	PUSHJ	P,CHACCS	;TO DO ACCESS UUO
	  JRST	NOACCS		;NO ACCESS FOR THIS USER
	MOVE	T1,NEW		;GET FILE NAME
	MOVE	T2,NEWEXT	;AND EXTENSION
	SETZ	T3,		;ZERO OUT OLD RESPONSES
	MOVE	T4,PSAVER	;AND PROJ,,PROG
;	INBUF	CDR,4		;FOUR BUFFERS .NQ. CDR
;NO-OP THE ABOVE INBUF AS AN INBUF HAS ALREADY BEEN DONE AT NORM1+3
	LOOKUP	CDR,T1		;GET INPUT FILE
	  JRST	.+2
	JRST	.+3
	  PUSHJ	P,GETHGH	;GET HIGH SEG
	  JRST	STARFL		;FILE NOT FOUND
	MOVSI	T1,(SIXBIT /CTL/)
	MOVEM	T1,NEWEXT	;SET EXTENSION NAME
CDRGO:	MOVE	T1,CRDIMG	;POINTER FOR CARD IMAGE
	TLNE	F,ASCII		;ASCII MODE?
	MOVE	T1,CRDASC	;POINTER FOR ASCII IMAGE
	MOVEM	T1,CDRBUF+1	;STORE BYTE POINTER
	TRZE	F,EODERR	;GET HERE VIA NO EO JOB
	  POPJ	P,		;YES, CONTINUE WITH $JOB CARD
NXCRD0:	SETZM	CRDCNT		;INITIALIZE CARD COUNTER
	TRO	F,STAR		;ENTER ACTIVE MODE
NXCARD:	PUSHJ	P,OPERIN	;ANY OPERATOR TYPEIN
NXCD1:	TRZ	F,TYPED		;ANY SWITCHES ARE ON THIS CARD
	TRNN	F,CARDER	;ANY ERRORS DETECTED ON CARD?
	JRST	NXCD2		;NO CARD ERRORS
	PUSHJ	P,GETHGH
	PUSHJ	P,CDERR		;OUT STERR MESSAGE TO FILE.LOG
NXCD2:
	PUSHJ	P,RELHGH	;YES, RELEASE IT FOR NOW
	SETZM	CARDB		;CLEAR OUT ANY OLD CARD IMAGES
	MOVE	T1,CDCLR	;TOP AND BOTTOM OF CARD IMAGE
	BLT	T1,BOTTOM	;FROM TOP TO BOTTOM
FILES:	MOVEI	P4,-33		;DEFAULT TO 029(IMAGE MODE ONLY)
	TLNE	F,NINEFL	;WAS D029 MODE SPECIFIED?
	MOVEI	P4,-22		;YES--SET UP FOR LSH
	TLNE	F,SIXFL		; OR WAS 026 MODE SPECIFIED?
	MOVEI	P4,-11		;YES--SET UP
	AOS	T1,CRDCNT	;INCREMENT AND SAVE CARD COUNT
	MOVE	P1,ASCPNT	;ASCII CHARACTER POINTER
	TLNE	F,IMAGE+BINARY	;NON ASCII??
	MOVE	P1,IMGPNT	;IMAGE CHARACTER POINTER
	TRO	F,FRSTWD	;CHECK COLUMN #1
FILE1:	SETZM 	COLUMN		;INITIALIZE COLUMN COUNT
FILES1:	PUSHJ	P,INCHAR	;GET FRST CHARACTER
	  JRST	NXCARD		;CARD IN ERROR RETURN
GOTONE:	MOVE	T2,COLUMN	;KEEP COLUMN COUNT GOING
	TLNN	F,ASCII
	JRST	GOTON1		;NO, GO IMAGE ROUTE
	IDPB	C,P1		;UNCONVERTED CHARACTER IS IN "C"
GOTO2:	CAIN	C,LF		;END OF LINE YET?
	JRST	GOTON2		;YES, GO TO DISPATCH
	JRST	FILES1		;NO, GET NEXT CHARACTER
GOTON1:	CAIGE	T2,MAXWID	;TO SPECIFIED POINT
	IDPB	T1,P1		;LOADING CHARACTERS INTO CARDB
	AOS	T1,COLUMN	;INCREMENT AN SAVE
	TLNN	F,BINARY
	JRST	GOTO3		;BYPASS BINARY PROCESSING
	CAIG	T1,MAXWID
	JRST	FILES1
	JRST	GOTON2
GOTO3:	CAIG	T1,MAXWID	;GR THAN DEFAULT (^D80) OR /WID??
	JRST	FILES1		;NOT YET
	TLNE	F,IMAGE		;IMAGE MODE??
	JRST	GOTON2		;IMAGE MODE--GET NEXT CARD
	MOVEI	T1,CR		;LOAD A <CR>
	IDPB	T1,P1		;AND OUT TO CDR BUFF
	MOVEI	T1,LF		;LOAD A <LF>
	IDPB	T1,P1		;AND OUT TO CDR BUFFER
GOTON2:	PUSHJ	P,CMATCH	;GO TO PROCESS CARD
	JRST	NXCARD		;GET NEXT CARD
SUBTTL	CHARACTER INPUT ROUTINES


INCHAR:	SOSG	CDRBUF+2	;TAKE A CHARACTER
	PUSHJ	P,CDRIN		;NONE LEFT, GET NEXT BUFFER
	ILDB	C,CDRBUF+1	;GET THE CHARACTER INTO "C"
	TRZN	F,FRSTWD	;FIRST TIME THROUGH HERE?
	JRST	INCH1		;RET*RN FOR NEXT CHARACTER
	TLNE	F,ASCII		;IS THIS ASCII MODE??
	  JUMPE	C,INCHAR	;RETURN FOR NEXT CHARACTER
	CAIE	C,7417		;WAS IT 4-CORNER EOJ
	CAIN	C,0017		;OR REGULAR EOJ
	JRST	CREOF		;REACHED END OF JOB
	CAIN	C,3776		;FUNNY HEADER OR TRAILER IN DECK
	JRST	NOHEAD		;YES, DON'T WANT TO SEE IT
	CAIE	C,4242		;026 MODE(OLD DESIGNATOR)
	JRST	NOTSIX		;NOT AN 026 DESIGNATOR
	TLO	F,SIXFL		;YES, O.K. USE 026 AS MODE UNTIL RESET
	TLZ	F,NINEFL+BINARY+IMAGE+ASCII
	MOVEI	T1,SPACE	;MAKE CHARACTER==SPACE
	JRST	CPOPJ1		;AND GO TO PROCESS
NOTSIX:	CAIE	C,5252		;D029 DESIGNATOR(OLD)
	JRST	NOTNIN		;NOT AN OLD D029 INDICATION
	TLO	F,NINEFL	;D029 MODE UNTIL MODE CHANGE
	TLZ	F,SIXFL+BINARY+IMAGE+ASCII
	MOVEI	T1,SPACE	;MAKE CHARACTER==SPACE
	JRST	CPOPJ1		;AND GO TO PROCESS
NOTNIN:	TLNN	F,BINARY	;COULD THIS BE BINARY??
	JRST	INCH1		;NOT SPECIFIED AS BINARY
	MOVE	T1,C		;COPY FIRST COLUMN
	ANDI	T1,7		;GET LAST 3 BITS
	CAIN	T1,5		;7-9 PUNCHED??
	JRST	INCH1		;YES, MUST BE BINARY
	CAIN	C,2102		;IMAGE "$"??
	JRST	INCHA		;YES, THAT'S OKAY
	PUSHJ	P,GETHGH	;GET HIGH SEGMANT
	PUSHJ	P,MODERR
	PUSHJ	P,RELHGH
	JRST	INCH1
INCHA:	TLZ	F,BINARY	;TURN OFF BINARY MODE SWITCH
	MOVE	P1,ASCPNT
	IFN	JST026,<
	TLO	F,SIXFL>
	IFN	JST029,<
	TLO	F,NINEFL>
INCH1:	TLNE	F,BINARY	;IS THIS BINARY MODE??
	MOVE	T1,C		;YES, COPY C INTO T1
	TLNN	F,IMAGE		;IN IMAGE MODE??
	JRST	INCHA1		;NO, JUST GO AROUND
	MOVE	T1,C		;DUPLICATE IMAGE IN T1
	MOVE	T2,COLUMN	;GET COLUMN COUNTER
	ADDI	T2,1
	CAMN	T2,WIDSAV	;AT END OF CARD??
	CAIE	C,7777		;END OF IMAGE MODE??
	JRST	INCHA1		;NO, CARRY ON
	RELEASE	DSK2,		;THE END OF A FILE
	TLZ	F,IMAGE+DECK
	POP	P,T1		;GOT HERE VIA PUSHJ
	HRLZI	T1,000700
	HLLM	T1,CARBUF+1
	SETZM	CDRBUF+2
	JRST	NXCARD
INCHA1:	TLNN	F,BINARY	;NO BINARY LEADERS
	CAIE	C,4242		;LEADER CARD??
	JRST	INCHA2		;NO, GO AROUND
	MOVEI	T1,SPACE	;MAKE CHARACTER A SPACE
	JRST	CPOPJ1		;AND RETURN FOR NEXT CHARACTER
INCHA2:	TLNN	F,ASCII+BINARY+IMAGE
	PJRST	CHPROC		;YES--GET ASCIZ VALUE
	JRST	CPOPJ1		;DON'T PROCESS--TAKE WHAT'S GIVEN

CDRIN:	IN	CDR,		;GET NEXT CARD IMAGE
	JRST	GOODIN		;WE WON
	TRNE	F,CDRFLA	;IS DEVICE REALLY A CDR?
	  JRST	CDRINA		;NO, CHECK EOT AND EOF FOR NON-CDR
	GETSTS	CDR,T2		;GET ITS STATUS
	TRNN	T2,OKAY		;FIXABLE ERROR?
	  JRST	CDRIN1		;NO, YOU LOSE
	PUSHJ	P,GETHGH
	PUSHJ	P,READER	;YES,GIVE CHANCE TO FIX
	PUSHJ	P,RELHGH
	JRST	CDRIN		;AND RETURN TO RETRY
CDRINA:	STATZ	CDR,2000	;END OF TAPE??
	  JRST	ENDFL2
CDRIN1:	STATO	CDR,20000	;EOF .NQ. DEVICE CDR
	POPJ	P,		;NO, RETURN
CREOF:	PUSHJ	P,GETHGH	;ATTACH HIGH SEGMENT
	SKIPE	T1,ERRFIL	;ANY ERROR FILE DURING THIS RUN??
	TRZ	F,FATSEE	;CLEAR OUT FATAL ERROR BIT
	TRZN	F,FATSEE	;ANY FATAL ERRORS DURING RUN
	JRST	CDREOF		;NONE, CLOSE FILES NORMAL ROUTE
	TRO	F,FATAL			; TO CLOSE PROPERLY
	SKIPN	T1,OLNAME	;REALLY HAVE FILES TO QUEUE
	TLO	F,NOQUE		;NO QUEUE ENTRY FOR THIS JOB
	MOVEI	T1,3		;TO RESET SCORE
	MOVEM	T1,SCORE	;RESET SCORE--ZEROED AT FATAL ERROR
	JRST	CDREOF		;AND FINISH THIS JOB

GOODIN:	SETZM	HNGCNT		;ZERO COUNT OF HUNG INTERCEPTS
	SKIPE	CDRBUF+2	;IS ITEM COUNT NON-ZERO?
	POPJ	P,0		;YES - ALL'S WELL SO RETURN
	JRST	CDRIN		;NO - CDRSRX FED ME A 0-LENGTH BUFFER
				;(IT IS A MONITOR BUG)

NOHEAD:	SOSG	CDRBUF+2	;ANY CHARACTERS LEFT
	  POPJ	P,		;NO, RETURN TO NXCARD
	ILDB	C,CDRBUF+1	;FLUSH A CHARACTER
	JRST	NOHEAD		;KEEP GOING UNTIL FINISH CARD
SUBTTL	POST E.O.J. DISPATCHING

;HERE IS SUBROUTINE INVOKED AFTER PROCESSING CDRSTK EOF
;  CARD--HERE THE CORE IS RETRIEVED AND THE PROPER END
;  CONDITION (I.E. PAUSE, STOP, /SINGL) IS DETERMINED


ENDFIL:	PUSHJ	P,RELHGH	;RELEASE HIGH SEGMENT
	TLNN	F,STOP		;OPERATOR REQUEST PAUSE?
	JRST	ENDFL1		;NO, GO AROUND
	PUSHJ	P,GETHGH	;YES, MESSAGE IN HIGHSEG
	PUSHJ	P,STOPS		; YES--OUTPUT "PAUSE" TEXT
	PUSHJ	P,RELHGH	;RELEASE HIGH SEGMENT
ENDFL1:	TRZN	F,EODERR	;GET HERE VIA MISSING EOD CARD?
	JRST	ENDFLX		;NO
	PUSHJ	P,GETHGH	;YES, GET HIGH SEG BACK
	PUSHJ	P,INITI1	;RE-ESTABLISH DEFAULTS, ETC AND RETURN TO $JOB
	MOVE	T1,JOBSV1		;GET SAVED JOBFF
	MOVEM	T1,.JBFF		;RESTORE IT
	PUSHJ	P,LOWLOW		;RESTORE ORIG. CORE SIZE
	TRO	F,STAR
	TRNE	F,CDRFLA
	TLO	F,ASCII
	POPJ	P,0
ENDFLX:	MOVE	P,PDLINI	;RESET PUSHDOWN LIST
	SETZM	REMFLG		;NOW FIND IF WE'RE LOCAL OR REMOTE
	MOVSI	T1,'CTY'	;GET STATION NUMBER OF CENTRAL SITE
	WHERE	T1,		;...
	  JRST	ENDFLY		;ASSUME CDR LOCAL IF NO REMOTE UUO'S
	MOVEI	T2,CDR		;NOW GET STATION NO. OF CDR
	WHERE	T2,		;...
	  HALT	.		;(THIS WHERE SHOULD NOT FAIL)
	CAIN	T1,(T2)		;SKIP IF NOT CENTRAL
	  JRST	ENDFLY
	SETOM	REMFLG		;NOW WE KNOW WE'RE REMOTE!
ENDFLY:	MOVE	T1,JOBSV1	;SAVED VALUE OF .JBFF
	MOVEM	T1,.JBFF	;RESTORE .JBFF
	PUSHJ	P,LOWLOW	;RESTORE PREVIOUS CORE ASSIGNMENT
	TLNE	F,MULTI		;MULTI MODE REQUESTED?
	JRST	ENDFL2		;NO, GO MAKE READY FOR OPERATOR
	PUSHJ	P,GETHGH	;YES, GET HIGH SEG NOW
	PUSHJ	P,INITIA	;REINITIALIZE PARAMETERS
	TRO	F,STAR		;TO GO INTO ACTIVE MODE
	MOVEI	C,LF		;TO SIMULATE A "START"
	PUSHJ	P,GETWD		;GO DO A "START"
	SKIPN	REMFLG
	TRNE	F,CDRFLA
	JRST	CDRSET		;AND THEN START THE JOB
	IN	CDR,		;FLUSH EOF CARD (HERE IFF LOCAL CDR)
	JFCL			;IGNORE ERRORS
	AOS	CDRBUF+2	;(THIS IS PURELY EMPIRICAL!!!!)
	JRST	NXCRD0		;GO GET NEXT CARD
ENDFL2:
	OUTSTR	REAMES		;"READY"
	OUTSTR	CRLF
	JRST	START		;GO BACK TO THE OPERATOR WAIT
				; TYPE-IN

SUBTTL	TTY I/O

;SUBROUTINE TO OUTPUT "*" TO OPERATOR WHEN CDRSTK
; IS INACTIVE OR "!" WHEN CDRSTK IS ACTIVE



CTLSET:	OUTSTR	CRLF		;OUT A <CR-LF>
	TRNN	F,STAR		;INACTIVE MODE??
	OUTSTR	STARRY
	TRNE	F,STAR		;ACTIVE MODE??
	OUTSTR	WAKEUP
	POPJ	P,
SUBTTL	CHARACTER INTERROGATION


CHPROC:	ROTC	C,-6		;RETRIEVE INDEX INTO LEFT
	LSH	M,-36		;AND INTO RIGHT
	ANDI	C,77		;MASK OUT GARBAGE
	HRR	T1,LEFT(C)	;GET LEFT INDEX VALUE
	ADD	T1,RIGHT(M)	;AND ADD RIGHT INDEX VALUE
	ANDI	T1,777		;ELIMINATE EXCESS
	CAILE	T1,317		;ERROR ??
	  JRST	CDRERR		;YES, OUTPUT ERROR CHARACTER
	ANDI	C,7		;GET LAST DIGIT OF LEFT INDEX
	SKIPE	C		;FALL THROUGH IF ZERO
	CAIG	M,3		;RT HALF GR 3 AND LH EQ 0
	JRST	CHPRO2		; O.K. VALUE
	  JRST	CDRERR		;ILLEGAL VALUE
CHPRO2:	MOVE	T1,LEFT(T1)	;GET THE POSSIBLE CHARACTERS
	LSH	T1,(P4)		;POSITION CHARACTER BY MODE
	ANDI	T1,777		;RETRIEVE CHARACTER
	CAIG	T1,177		; ERROR CHARACTER--T1=>200 ?
	JRST	CPOPJ1		;NON-ERROR , GOT CHAR.

CDRERR:	AOS	T1,HOLLER	;UPDATE AND SAVE ERROR COUNT
	MOVE	T3,COLUMN	;SAVE COLUMN COUNT
	MOVEM	T3,COLERR	;IN COLUMN ERROR
	AOS	T3,COLERR	;UPDATE COLUMN IN ERROR COUNT
	MOVE	T2,CRDCNT	;FOR TOTAL ERRORS ACCEPTABLE
	CAIL	T1,^D200	; EITHER 200 OR 1/10 OF CARDS
	IDIVI	T2,^D10		; IF CARD COUNT GR 200(10)
	CAMLE	T1,T2		;ACCEPTABLE?
	  JRST	BADNWS		;NO--NOT ACCEPTABLE
	TRO	F,CARDER	;SET ERROR FLAG FOR FILE.CTL OUT
	MOVEI	T1,"\"		;REPLACE BAD CHARACTER WITH "\"
	JRST	CPOPJ1		;RETURN FOR REST OF CARD

BADNWS:	PUSHJ	P,GETHGH
	MOVEI	T1,"\"		;REPLACE BAD CHARACTER WITH "\"
	SETZM	HOLLER		;START OFF WITH 0 NEXT TIME
	IDPB	T1,P1		;REPLACE BAD CHARACTER
	PUSHJ	P,TIME1		;TIMESTAMP ERROR MESSAGE
	MOVEI	T4,^D30		;PREPARE TO OUT MESSAGE
	MOVE	T2,[POINT 7,HOLER]
	PUSHJ	P,LOGCR1	;OUT THE MESSAGE TO FILE.LOG
	TRO	F,FATAL		;THIS IS A FATAL ERROR
	POPJ	P,
SUBTTL	CARD INTERROGATION

;HERE IS WHERE EACH CARD IS CHECKED FOR A "$" IN COL. 1
;  AND DISPATCHING FOR CONTROL CARDS IS INITIATED.


CMATCH:	TLNE	F,BINARY	;IN BINARY MODE??
	JRST	EDECK		;BINARY PROCESSING
CMATCA:	TLNE	F,ALL		;OUT ALL CARDS TO OPERATOR??
	OUTSTR	CARDB		;YES, OUTPUT THIS CARD
	MOVE	P1,ASCPNT	;ASCII CHARACTER POINTER
	TLNE	F,ASCII		;IS THIS ASCII MODE??
	JRST	CMATC1		;YES, DON'T WORRY ABOUT COLUMN
	SOSG	COLUMN		;ANY CHARACTERS LEFT?
	POPJ	P,		;RETURN TO NEXT CARD
CMATC1:	MOVE	T1,WIDSAV	;WAS ANY NON STANDARD WIDTH
	SUBI	T1,DEFWID	; SPECIFIED VIA /WIDTH
	CAIN	T1,0		;OF ANY MAGNITUDE?
	JRST	CMATC2		;NONE, GO SUPPRESS TRAILING BLANKS
	PUSHJ	P,LOPOFF	;YES, GO DO IT
	JRST	CMATC3		;GO INTERROGATE CARD
CMATC2:	TLNE	F,IMAGE		;IMAGE MODE SPECIFIED??
	JRST	CMATC3		;YES, DON'T ATTEMPT DELETION
	TLNE	F,SUPRES	;DELETE TRAILING SPACES??
	PUSHJ	P,GOBACK	;YES, DELETE TRAILING SPACES
CMATC3:	TLNE	F,IMAGE		;IMAGE MODE??
	JRST	CDECK		;YES, JUST DROP INTO FILE
	ILDB	T1,P1		;RETRIEVE COLUMN 1
	CAIE	T1,"$"		;CONTROL CARD??
	JRST	CDECK		;NO, CHECK IF UNDER DECK OR LANGUAGE CARD
	PUSHJ	P,GETHGH	;YES, PREPARE TO PROCESS
	PJRST	CONTRO		;GO TO PROCESS, RETURN TO CARD
CDECK:	TRZN	F,CONTIN	;IS THIS A CONTINUATION
	JRST	DDECK		;NO, GO PAST CONTINUATION
	CAIE	T1,"/"		;IS THIS A SWITCH??
	JRST	DDECK		;NO, BYPASS PROCESSING
	PUSHJ	P,GETHGH	;GET APPROPRIATE ROUTINES
	JRST	CHECK		;GO TO PROCESS
DDECK:	TLNE	F,DECK		;UNDER INFLUENCE OF $DECK CARD?
	JRST	DECKED		;YES, GO PROCESS
	TRNE	F,EODERR	;WAS ERROR FLAG SET??
	POPJ	P,		;YES, FLUSH CARD
				;NO, FALL THROUGH TO CTLOUT
				;TO PUT CARD INTO FILE.CTL

SUBTTL	CTL FILE OUTPUT ROUTINES


CTLOUT:	MOVEI	T4,DEFWID	;NO. CHARACTERS/CARD
	ADDI	T4,2		;PLUS <CR-LF>
	MOVE	T3,ASCPNT	;ASCII CHARACTER POINTER
CTLOU1:	ILDB	T1,T3		;GET A CHARACTER
	SKIPE	T1		;FLUSH BLANKS
	PUSHJ	P,OUTCTL	;AND OUT IT TO FILE.CTL
	CAIE	T1,LF		;END OF LINE DETECTED?
	SOJG	T4,CTLOU1	;NO, GO BACK FOR ALL OF CARD
	POPJ	P,		;YES, RETURN

OUTCTL:	TRNN	F,OKAY		;SET TO 1 BY $JOB CARD
	POPJ	P,		;FILE NOT INITTED,,NO OUTPUT
	SOSG	OUTBUF+2	;DECRIMENT COUNT
	JRST	OUTCT2		;GO TO DO OUTPUT
OUTCT1:	IDPB	T1,OUTBUF+1	;GET A CHARACTER TO OUTPUT
	POPJ	P,		;NONE LEFT
OUTCT2:	AOS	G3,BLKCNT	;KEEP BLOCK COUNT GOING
	OUTPUT	DSK,		;OUTPUT A BUFFER
	JRST	OUTCT1		;RETURN FOR NEXT BUFFER
	POPJ	P,
SUBTTL	BINARY CARD SPECIAL ROUTINES

;HERE IS ROUTINE ENTERED FOR EACH CARD THAT IS
;  AFTER A /BINARY OR A $REL.
;     THIS SUBROUTINE DETERMINES IF THIS CARD IS IN BINARY FORMAT
;     BY CHECKING FOR A 7-9 PUNCH IN COLUMN #1.  THIS
;     SUBROUTINE ALSO GETS THE WORD COUNT AND CHECKSUM FROM THE
;     CARD.

EDECK:	MOVE	P1,IMGPNT	;IMAGE CHARACTER POINTER
	ILDB	T1,P1		;GET COLUMN 1 FROM CARD
	TRNE	T1,5		;REALLY BINARY CARD??
	JRST	EDEC1		;YES, CONTINUE PROCESSING
	JRST	CMATCA		;NO, PROCESS NORMALLY
EDEC1:	LSH	T1,-6		;GET WORD COUNT
	ILDB	T2,P1		;GET COLUMN 2
	SETZB	T3,T4
	MOVE	T3,T1		;COPY WORD COUNT
	IMULI	T3,3		;NO OF 12 BIT BYTES
	MOVEM	T3,BINWRD	;SAVE NUMBER OF WORDS
	MOVE	T4,IMGPNT	;IMAGE CHARACTER POINTER
	SETZ	G3,
EDECK1:	ILDB	C,P1		;GET NEXT BYTE
	DPB	G3,P1		;CLEAR OUT OLD STUFF
	IDPB	C,T4		;STORE IN CARDB
	SOJGE	T3,EDECK1	;GET ALL BYTES
	SETZB	T3,T4		;FOR CHECKSUM
	SUBI	T1,1		;FIX COUNT FOR CHECKSUM COMPUTATION

;SUBROUTINE TO COMPUTE THE CHECKSUM FROM A BINARY CARD
; ENTERED FROM EDECK WITH T2 CONTAINING THE CARD
;  CHECKSUM AND T1 CONTAINING THE NUMBER OF ENTRIES
;  TO ADD TO ACCUMULATE THE CHECKSUM.  THE CHECKSUM IS
;  ACCUMULATED IN T3 AND COMPRESSED TO A 12 BIT VALUE.

SUMCHK:	ADD	T3,CARDB(T1)	;CHECKSUM FOUND BY ADDING
	SOJGE	T1,SUMCHK	; DATA WDS. USING 2'S COMPLIMENT ARITHMATIC
	MOVE	T1,T2		;COPY CARD CHECKSUM INTO T1
	LSHC	T3,-30		; THEN SPLITTING THE SUM INTO THREE
	LSH	T4,-14		; 12-BIT BYTES AND ADDING THESE
	ADD	T3,T4		; TOGETHER USING 1'S COMPLIMENT
	LSHC	T3,-14		; ARITHMATIC TO FORM A 12 BIT
	LSH	T4,-30		; CHECKSUM
	ADD	T3,T4
	TRZE	T3,770000
	AOS	T3
	CAMN	T3,T1		;CARD CHECKSUM==COMPUTED CHECKSUM??
	JRST	DDECK		;YES, GO STORE CARD IN FILE
	  PUSHJ	P,GETHGH	;GET HIGH SEG
	  JRST	BITERR		;OUTPUT MESSAGE TO FILE.LOG
SUBTTL	FILE OUTPUT ROUTINES


DECKED:	MOVEI	T4,DEFWID	;MAX CHARACTERS PER CARD
	TLNN	F,IMAGE		;IS THIS AN IMAGE MODE CARD??
	ADDI	T4,2		;PLUS APPENDED <CR><LF>
	TLNE	F,BINARY
	MOVE	T4,BINWRD	;WORDS TO SAVE IN FILE
	TLNN	F,BINARY
	JRST	.+3
	HRLZI	T2,1400
	HLLM	T2,CARBUF+1
	MOVE	T2,ASCPNT	;ASCII CHARACTER POINTER
	TLNN	F,IMAGE+BINARY	;IMAGE OR BINARY MODE??
	JRST	DECKD1		;NEITHER
	MOVE	T2,IMGPNT	;IMAGE CHARACTER POINTER
DECKD1:	ILDB	T1,T2		;GET ONE CARD CHARACTER
	PUSHJ	P,DECKD2
	TLNE	F,BINARY	;BINARY MODE??
	JRST	.+3		;YES, COUNT CHARACTERS
	TLNE	F,SUPRES	;SUPPRESS TRAILING BLANKS
	JRST	DECK7		;YES, GO TO DO IT
	SOJG	T4,DECKD1	;NO, GET NEXT CHARACTER
	TLNE	F,SUPRES
	TLNE	F,IMAGE+BINARY	;EITHER ASCII OR IMAGE MODE??
	POPJ	P,		;YES, DON'T APPEND CR/LF
	MOVEI	T1,CR
	PUSHJ	P,DECKD2
	MOVEI	T1,LF
	PUSHJ	P,DECKD2
	POPJ	P,		;RETURN TO NEXT CARD

DECK7:	CAIE	T1,LF		;END OF CARD INPUT YET?
	JRST	DECKD1		;NO--RETURN FOR MORE
	POPJ	P,		;YES, RETURN

DECKD2:	TRNN	F,OKAY		;OK TO OUT TO FILE??
	POPJ	P,		;NO, OFFENDER WAS TOLD
	SOSG	CARBUF+2	;YES, GO DO IT
	JRST	DECKD4
DECKD3:	TLNN	F,IMAGE+BINARY	;WHERE ZEROS COUNT
	CAIE	T1,0		;WHERE NULLS DON'T COUNT
	IDPB	T1,CARBUF+1	;LOAD THIS CHARACTER
	POPJ	P,


DECKD4:	AOS	G3,BLKCNT	;KEEP BLOCK COUNT GOING
	OUT	DSK2,		;DO THE OUTPUT
	JRST	DECKD3
	PUSHJ	P,GETHGH	;TO PROCESS ERROR
	PUSHJ	P,DECFAI	;GO OUTPUT MESSAGE
	JRST	NXCARD
SUBTTL	BLANK SUPPRESSION


;HERE TO SUPPRESS TRAILING BLANKS

GOBACK:	MOVEI	T4,20		;LENGTH OF CARDB--CARD BUFFER
	SETZ	T2,		;INITIALIZE FOR CHARACTER CHECK
	JRST	GOBAC		;ZERO INPUT SUPPLIED <CR><LF>
GOBAC1:	MOVE	T3,CARDB(T4)	;GET 5 CHARACTERS INTO T3
	JUMPE	T3,GOBAC+1	;DON'T PLAY WITH BLANK LINES
	CAME	T3,BLANKS	;WORD==5 BLANKS?
	JRST	GOBAC2		;NO--FIRST NON-SPACE DETECTED
GOBAC:	SETZM	CARDB(T4)	;ZERO SPACES
	SOJGE	T4,GOBAC1	;RETURN FOR MORE
GOBAC2:	MOVEI	T1,5		;CHARACTERS PER WORD
	MOVE	P2,T4		; RETAIN INDEX IN P2
GOBAC5:	SETZ	T4,		;INITIALIZE FOR WORK
	ROTC	T3,-7		;PEEL OFF ONE CHARACTER
	LSH	T4,-36		;AND RT JUSTIFY IN T4
	CAIN	T4,SPACE	;IS CHARACTER A SPACE?
	SOJG	T1,GOBAC5	; YES, RETURN TO NEXT CHARACTER
	CAIN	T1,5		;FULL LINE YET?
	JRST	GOBAC6		;YES, APPEND <CR><LF>
	MOVEI	P3,5		;NO, START BACK OVER THIS WORD
	SUB	P3,T1		;REVERSE POSITIONAL COUNT
	SETZ	T4,		;TO MASK BACK OVER
GOBAC7:	LSH	T4,7		;PUT MASK TOGETHER
	ADDI	T4,177		;MASK VALUE PER CHARACTER
	SOJG	P3,GOBAC7	;TO COMPLETE THE MASK
	LSH	T4,1		;BACK TO ASCII
	MOVE	T3,CARDB(P2)	;GET CARD IMAGE
	TDZ	T3,T4		;BLANK OUT SPACES
	MOVEM	T3,CARDB(P2)	;RETURN TO CARD IMAGE
GOBAC6:	ADDI	P2,1		;INCREMENT CARD IMAGE INDEX
	MOVE	T3,CRLF		;PUT <CR-LF> INTO BUFFER
	MOVEM	T3,CARDB(P2)	;APPEND <CR><LF>
	MOVE	T1,CARDB	;GET FIRST FIVE FROM CARD
	CAME	T1,CRLF		;JUST A <CR-LF>??
GOBAC4:	POPJ	P,		;AND RETURN
	MOVE	T1,SPCRLF	;TO PUT A SPACE IN FRONT FOR <CR-LF>
	MOVEM	T1,CARDB	;AND ONLY THAT
	POPJ	P,		;TO RETURN
SUBTTL	/WIDTH CHARACTER SUPPRESSION

;HERE TO LOP OFF CHARACTERS THAT EXTEND BEYOND ANY WIDTH
;     SPECIFICATION
;  ENTERED AFTER EACH CARD IS READ IN AFTER A /WIDTH LESS
;  THAN 80 HAS BEEN SPECIFIED.
;    THE NUMBER OF CHARACTERS TO DELETE IS IN T1

LOPOFF:	MOVE	T4,CARDB	;RETRIEVE COLUMN #1 OF CARD
	LSH	T4,-35		;JUST COLUMN #1
	CAIN	T4,"$"		;IS THIS A $CARD??
	JRST	CPOPJ1		;YES, SUPPRESS TRAILING BLANKS
	MOVEI	T4,17		;LENGTH OF CARD BUFFER
	TLNE	F,IMAGE
	MOVEI	T4,31		;LARGER CARD BUFFER FOR IMAGE MODE
LOPOF:	MOVEI	T3,5
	TLNE	F,IMAGE
	SUBI	T3,2
LOPOF1:	MOVE	T2,CARDB(T4)	;START AT TAIL END OF CARD
LOPOF2:	TLNE	F,IMAGE		;IMAGE MODE??
	LSH	T2,-1
	TLNE	F,IMAGE
	LSH	T2,-5
	LSH	T2,-7		;PEEL OFF A CHARACTER
	AOJE	T1,LOPOUT	;ARE WE DONE?
	SOJE	T3,LOPMOR
	JRST	LOPOF2
LOPMOR:	MOVEM	T2,CARDB(T4)
	SOJG	T4,LOPOF
LOPOUT:	TLNE	F,IMAGE		;IMAGE MODE FOR THIS CARD
	LSH	T2,1
	MOVEM	T2,CARDB(T4)	;RETURN CARD VALUE
;	TRNE	F,CDRFLA	;IF CDR INPUT, EXIT HERE
;	TLNE	F,IMAGE
;	POPJ	P,
;	ADDI	T4,1		;FOR THE CASE OF F4 DISK INPUT
;	MOVE	T2,CRLF
;	MOVEM	T2,CARDB(T4)	;SO MAKE SURE "CARD" ENDS RIGHT
;NOOP THE ABOVE CODE - IT IS NOT USEFUL**********************************
	POPJ	P,
SUBTTL	CHARACTER TABLES

;TABLE "LEFT" CONTAINS ASCII CHARACTERS AND INDEX VALUES
; INTO TABLE "RIGHT" KEYED BY THE VALUE OF THE FIRST SIX 
; BIT VALUE OF THE IMAGE MODE REPRESENTATION OF THE CHARACTER


; THE FORMAT OF TABLES "LEFT" AND "RIGHT" IS AS FOLLOWS:
;     "XWD" 029 ASCII-D029 ASCII,,026 ASCII-INDEX VALUE

;     ASCII VALUES OF "200" RESULT IN "HOLLERITH ERRORS"
;     INDEX VALUES OF 320 AND GREATER RESULT IN ERROR

LEFT:	XWD	040040,040000		;<SPACE>
	XWD	071071,071023		;"9"
	XWD	070070,070046		;"8"
	XWD	200200,200320		;ERROR/ERROR
	XWD	067067,067071		;"7"
	XWD	004004,004320		;ERROR
	XWD	042042,134320		;""","/",ERROR
	XWD	032032,032320		;"^Z",ERROR
	XWD	066066,066114		;"6"------------WORD #10
	XWD	200200,200040		;ERROR
	XWD	075075,047057		;"=","'"
	XWD	200200,200320		;ERROR
	XWD	065065,065106		;"5"
	XWD	176176,176320		;
	XWD	047047,136320		;"'","^"
	XWD	025025,025320		;"^U"
	XWD	064064,064137		;"4"------------WORD #20
	XWD	100100,100030		;"@"
	XWD	200200,200034		;ERROR
	XWD	063063,063320		;"3"
	XWD	200200,200052		;ERROR
	XWD	043043,075320		;"#","="
	XWD	200200,200320		;ERROR
	XWD	200200,200320		;ERROR
	XWD	114114,114162		;"L"------------WORD #30
	XWD	023023,023063		;"^S"
	XWD	044044,044236		;"$"
	XWD	200200,200320		;ERROR
	XWD	113113,113015		;"K"
	XWD	022022,022320		;"^R"
	XWD	135041,072320		;"!",":"
	XWD	200200,200320		;ERROR
	XWD	124124,124205		;"T"------------WORD #40
	XWD	200200,200276		;ERROR
	XWD	054054,054303		;","
	XWD	024024,024320		;"^T"
	XWD	200200,200241		;ERROR
	XWD	200200,200320		;ERROR
	XWD	062062,062320		;"2"
	XWD	026026,026320		;"^V"
	XWD	072072,137230		;":","_"--------WORD #50
	XWD	200200,200177		;ERROR
	XWD	112112,112246		;"J"
	XWD	021021,021320		;"^Q"
	XWD	200200,200307		;ERROR
	XWD	031031,031320		;"^Y"
	XWD	200200,200320		;ERROR
	XWD	123123,123320		;"S"
	XWD	200200,200253		;ERROR----------WORD #60
	XWD	134135,073204		;"]",";"
	XWD	200200,200252		;ERROR
	XWD	164164,164320		;SMALL "T"
	XWD	200200,200314		;ERROR
	XWD	200200,200320		;ERROR
	XWD	200200,200320		;ERROR
	XWD	200200,200320		;ERROR
	XWD	200200,200320		;ERROR----------WORD #70
	XWD	061061,061320		;"1"
	XWD	200200,200320		;ERROR
	XWD	140140,140320		;"'"
	XWD	200200,200320		;ERROR
	XWD	200200,200320		;ERROR
	XWD	200200,200320		;ERROR
	XWD	200200,200320		;ERROR

RIGHT:	XWD	200200,200000		;ERROR----------WORD #100
	XWD	200200,200001
	XWD	200200,200002
	XWD	200200,200003
	XWD	200200,200004
	XWD	200200,200005
	XWD	057057,057006		;"/"
	XWD	200200,200007
	XWD	200200,200010		;ERROR----------WORD #110
	XWD	200200,200011
	XWD	200200,200012
	XWD	200200,200013
	XWD	060060,060320		;"0"
	XWD	132132,132320		;"Z"
	XWD	131131,131320		;"Y"
	XWD	200200,200320		;ERROR
	XWD	130130,130014		;"^["-----------WORD #120
	XWD	033033,033015		;"X"
	XWD	077077,045016		;"?","%"
	XWD	007007,007017		;"^G"
	XWD	127127,127320		;"W"
	XWD	027027,027320		;"^W"
	XWD	076076,043320		;">","#"
	XWD	006006,006320		;"^F"
	XWD	126126,126320		;"V"------------WORD #130
	XWD	012012,012320		;<LF>
	XWD	137137,042320		;"_","""
	XWD	005005,005320		;"^E"
	XWD	125125,125320		;"U"
	XWD	045045,050320		;"%","("
	XWD	200200,200320		;ERROR
	XWD	055055,055320		;"-"
	XWD	122122,122020		;"R"------------WORD #140
	XWD	121121,121320		;"Q"
	XWD	030030,030021		;"^X"
	XWD	120120,120022		;"P"
	XWD	200200,200320		;ERROR
	XWD	136134,046320		;"\","&"
	XWD	037037,037320		;"^_"
	XWD	117117,117320		;"O"
	XWD	010010,010320		;"^H"-----------WORD #150
	XWD	073073,076320		;";",">"
	XWD	036036,036052		;"^^"
	XWD	116116,116320		;"N"
	XWD	200200,200320		;ERROR
	XWD	051051,133320		;")","["
	XWD	035035,035320		;"^]"
	XWD	115115,115320		;"M"
	XWD	052052,052320		;"*"------------WORD #160
	XWD	034034,034320		;"^\"
	XWD	175175,072320		;11-0 (026==:)
	XWD	172172,172320		;LITTLE "Z"
	XWD	171171,171320		;LITTLE "Y"
	XWD	200200,200320		;ERROR
	XWD	170170,170320		;LITTLE "X"
	XWD	200200,200320		;ERROR
	XWD 	200200,200320		;ERROR----------WORD #170
	XWD	200200,200320		;ERROR
	XWD	167167,167320		;LITTLE "W"
	XWD	200200,200320		;ERROR
	XWD	200200,200320		;ERROR
	XWD	200200,200320		;ERROR
	XWD	166166,166320		;LITTLE "V"
	XWD	143143,143320		;LITTLE "C"
	XWD	200200,200320		;ERROR----------WORD #200
	XWD	200200,200320		;ERROR
	XWD	165165,165320		;LITTLE "U"
	XWD	200200,200320		;ERROR
	XWD	154154,154320		;LITTLE "L"
	XWD	046046,053320		;"&"<"+"
	XWD	111111,111320		;"I"
	XWD	110110,110320		;"H"
	XWD	200200,200320		;ERROR----------WORD #210
	XWD	107107,107320		;"G"
	XWD	177177,177320		;<DELETE>
	XWD	041136,041320		;"!","^","!"
	XWD	017017,017320		;"^O"
	XWD	106106,106320		;"F"
	XWD	200200,200320		;ERROR
	XWD	053053,074320		;"+","<"
	XWD	016016,016320		;"^N"-----------WORD #220
	XWD	105105,105320		;"E"
	XWD	011011,011320		;<TAB>
	XWD	050050,135320		;"(","]"
	XWD	015015,015320		;<LF>
	XWD	104104,104320		;"D"
	XWD	074074,051320		;"<",")"
	XWD	014014,014320		;<FF>
	XWD	173173,077320		;LEFT BRACE,"?"-WORD #230
	XWD	151151,151320		;LITTLE "I"
	XWD	150150,150320		;LITTLE "H"
	XWD	200200,200320		;ERROR
	XWD	147147,147320		;LITTLE "G"
	XWD	200200,200320		;ERROR
	XWD	163163,163320		;LITTLE "S"
	XWD	200200,200320		;ERROR
	XWD	146146,146320		;LITTLE "F"-----WORD #240
	XWD	101101,101320		;"A"
	XWD	001001,001320		;"^A"
	XWD	200200,200320		;ERROR
	XWD	145145,145320		;LITTLE "E"
	XWD	200200,200320		;ERROR
	XWD	142142,142320		;LITTLE "B"
	XWD	200200,200320		;ERROR
	XWD	144144,144320		;LITTLE "D"-----WORD #250
	XWD	200200,200320		;ERROR
	XWD	153153,153320		;LITTLE "K"
	XWD	174174,174320		;LITTLE "L"
	XWD	162162,162320		;LITTLE "R"
	XWD	161161,161320		;LITTLE "Q"
	XWD	200200,200320		;ERROR
	XWD	160160,160320		;LITTLE "P"
	XWD	200200,200320		;ERROR----------WORD #260
	XWD	200200,200320		;ERROR
	XWD	200200,200320		;ERROR
	XWD	157157,157320		;LITTLE "O"
	XWD	200200,200320		;ERROR
	XWD	200200,200320		;ERROR
	XWD	200200,200320		;ERROR
	XWD	156156,156320		;LITTLE "N"
	XWD	200200,200320		;ERROR----------WORD #270
	XWD	200200,200320		;ERROR
	XWD	200200,200320		;ERROR
	XWD	155155,155320		;LITTLE "M"
	XWD	200200,200320		;ERROE
	XWD	200200,200320		;ERROR
	XWD	103103,103320		;"C"
	XWD	003003,003320		;"^C"
	XWD	056056,056320		;","------------WORD #300
	XWD	013013,013320		;<VT>
	XWD	200200,200320		;ERROR
	XWD	102102,102320		;"B"
	XWD	002002,002320		;"^B"
	XWD	133133,077320		;"[","?"
	XWD	200200,200320		;ERROR
	XWD	141141,141320		;LITTLE "A"
	XWD	200200,200320		;ERROR----------WORD #310
	XWD	200200,200320		;ERROR
	XWD	000000,000320		;<NULL>
	XWD	200200,200320		;ERROR
	XWD	152152,152320		;LITTLE "J"
	XWD	200200,200320		;ERROR
	XWD	200200,200320		;ERROR
	XWD	020020,020320		;"^P"
	XWD	000200,200320		;NUL/ERROR------WORD #320
SUBTTL	COMMON SUBROUTINES


CPOPJA:	PUSHJ	P,CTLSET	;OUTPUT A "*" OR A "!"
CPOPJ1:	AOS	(P)		;INCREMENT PUSH DOWN POINTER
CPOPJ:	POPJ	P,		;AND RETURN

REENTR:	SKIPN	RENSW		;ARE WE ALREADY DONE?
	EXIT			;YES, CALL EXIT
	JRST	START		;AND RETURN TO START OF STACK

GETHGH:	TROE	F,HIGHIN	;HIGH SEGMENT IN CORE?
	POPJ	P,		;YES, DON'T NEED ANOTHER
	MOVEI	T1,ACCSAV	;PLACE TO SAVE AC'S 0-17
	BLT	T1,RITE		;SAVE AC'S IN LOW SEGMENT
	MOVSI	P1,(SIXBIT /SYS/)	;RETRIEVE
	MOVE	P2,YALL		;YOUR NAME
	SETZB	P3,P4
	SETZ	G1,
	MOVEI	G2,P1
	GETSEG	G2,		;GET HIGH SEGMENT
	  HALT	.		;QUIT IF NO HIGH OR SHR SEGS
	MOVE	T1,LOWPNT	;POINTER TO RETRIEVE AS'S
	BLT	T1,P		;RESTORE AC'S
	POPJ	P,

RELHGH:	TRZN	F,HIGHIN	;IS HIGH SEGMENT IN AT TIME
	  POPJ	P,		;NO, JUST RETURN
	HRLZI	T1,1		;TO RELEASE HIGH SEGMENT
LOWLOW:	CORE	T1,		;RELEASE HIGH OR RESTORE .JBFF
	  HALT	.		;BETTER HALT IF RELEASE FAILS
	POPJ	P,		;RETURN TO LOW SEG PROCESSING

;SUBROUTINE TO EXIT FROM CDRSTK AFTER OPERATOR TYPEIN


GETOUT:	PUSHJ	P,RELHGH	;RELEASE HIGHSEG FIRST
	SKIPN	T1,JOBSV1	;RETRIEVE .JBFF IF ANY
	EXIT
	MOVEM	T1,.JBFF	;AND REPLACE PRESENT VALUE
	CORE	T1,
	  HALT	.
	EXIT

CHACCS:	SETZ	T1,		;INITIALIZE THIS AC
	MOVE	T3,RUNNER	;GET PPN OF RUNNER OF THIS JOB
	MOVEI	T4,T1
	CHKACC	T4,
	SETZB	T3,T4		;NO UUO, NO ACCESS, NO ERROR
	JUMPN	T4,CPOPJ	;JUMP TO POPJ IF ERROR
	JRST	CPOPJ1		;TAKE GOOD RETURN

NOACCS:	PUSHJ	P,GETHGH	;TO GET MESSAGE
	OUTSTR	NOTYOU		;TELL HIM
	JRST	START		;AND RETURN TO BEGINNING
SUBTTL	FIXED STORAGE



PDL:	BLOCK	63
PDLINI:	-63,,PDL-1
bufhed:	iowd	200,buflog
BUFHAD:	0
SAVACL:	0
DATOFS=^D38395
DATANM:	0
DEFNAM:	SIXBIT	/DECKA@/
NEW:	SIXBIT	/JOBAAA/
NEWEXT:	SIXBIT	/CTL/		;OUTPUT FILE DEFAULTS
	BLOCK	1
NEWPPN:	0
OUPUT:	EXP	0
OUDEV:	0
	XWD	OUTBUF,0
LOGOUT:	EXP	0
	0
	XWD	LOGBUF,0
CAROUT:	EXP	0
	0
	XWD	CARBUF,0
OUDIR:	0
	SIXBIT	/UFD/
	BLOCK	2
FAKOUT:	SIXBIT	/JOBAAA/
DEFEXT:	SIXBIT	/CTL/
YALL:	SIXBIT	/CDRSTK/
BLANKS:	ASCIZ	/     /
WAKEUP:	ASCIZ	/!/
STARRY:	ASCIZ	/*/
CRLF:	ASCIZ	/
/
SPCRLF:	ASCIZ	/ 
/
REAMES:	ASCIZ	/READY/
QUEUEN==<SIXBIT /CDRSTK/>
QUEUEM==QUEUEN_-^D18

CRDIMG:	POINT	12,0,35
CRDASC:	POINT	7,0,35
IMGPNT:	POINT	12,CARDB
ASCPNT:	POINT	7,CARDB
CDCLR:	XWD	CARDB,CARDB+1
LOWPNT:	XWD	ACCSAV,F
TOP:

RUNNER:	BLOCK	1	;PPN OF PERSON RUNNING THIS JOB
LOCSAV:	BLOCK	1	;LOCATION
QUECAL:	BLOCK	1	;LINE 0 OF QUEUE CALLING BLOCK
QUECA1:	BLOCK	1
QUECA2:	BLOCK	1
PPNS:	BLOCK	1	;PROJ,,PROG PAIR
OLNAME:	BLOCK	1	;FILE NAME
SEQSAV:	BLOCK	1	;ARGUMENT FROM $SEQUENCE CARD
PRISAV:	BLOCK	1	;PRIORITY
QUECA7:	BLOCK	1
QUEC10:	BLOCK	1
QUEC11:	BLOCK	1
AFTTIM:	BLOCK	1	;AFTER SPECIFICATION
DEDTIM:	BLOCK	1	;DEADLINE SPECIFICATION
CHASAV:	BLOCK	1	;CHARGE SPECIFICATION
NAMSAV:	BLOCK	2	;NAME--12 CHARACTERS
DEPSAV:	BLOCK	1	;DEPENDANCY
CORTIM:	BLOCK	1	;CORE IN K WORDS,,TIME
PAGCAR:	BLOCK	1	;PAGES,,CARDS
TAPPTI:	BLOCK	1	;FT. OF PAPER TAPE,,PLOT TIME
QUEC23:	BLOCK	1	;UNIQUE FILENAME
QUEC24:	BLOCK	1	;FILE NAME
QUEC25:	BLOCK	1
QUEC26:	BLOCK	1
QUEC27:	BLOCK	1
QUEC30:	BLOCK	1
QUECTL:	BLOCK	14
QUELOG:	BLOCK	14
QUEC31:	BLOCK	1
ZZZSAV:	BLOCK	1	;CDR SLEEP ARGUMENT
TIMER:	BLOCK	1
JOBSV1:	BLOCK	1	;SAVE JOBFF HERE
CDRBUF:	BLOCK	3
CTIBUF:	BLOCK	3
OUTBUF:	BLOCK	3
LOGBUF:	BLOCK	3
CARBUF:	BLOCK	3
BUFIN:	BLOCK	3
ENTSIZ:	BLOCK	1
ACTBLK:	BLOCK	1
PHYNAM:	BLOCK	1
WIDSAV:	BLOCK	1
FILBAS:	BLOCK	1
BUFLOG:	BLOCK	40	;FOLLOWING LOCATIONS OVERLAYED WITH ACCT.SYS
QXXFIL:	BLOCK	1	; AND AUXACC.SYS INFORMATION
QXXFLS:	BLOCK	13
FORFIL:	BLOCK	1
FORFLS:	BLOCK	14
COBFIL:	BLOCK	1
COBFLS:	BLOCK	14
MACFIL:	BLOCK	1
MACFLS:	BLOCK	14
ALGFIL:	BLOCK	1
ALGFLS:	BLOCK	14
BINWRD:	BLOCK	1	;BINARY WORD COUNT*3
ERRFIL:	BLOCK	1	;ERROR FILE NAME
ERREXT:	BLOCK	1	;ERROR FILE'S EXTENSION
ERRWD:	BLOCK	1	;LOOKUP/ENTER ERROR
ERRPPN:	BLOCK	1	;PPN FOR ERROR FILE
HOURS:	BLOCK	1
MINUTE:	BLOCK	1
SECOND:	BLOCK	1
MILSEC:	BLOCK	1
MESAGE:	BLOCK	4	;MESSAGE FROM OPERATOR VIA TELL
HOLLER:	BLOCK	1
DEVTEM:	BLOCK	1
NAMTEM:	BLOCK	1
EXTTEM:	BLOCK	1
PSAVER:	BLOCK	1
NAME:	BLOCK	1
NAME1:	BLOCK	1
DEVICE:	BLOCK	1
FILCNT:	BLOCK	1
ACCSAV:	BLOCK	1
ACBUF:	BLOCK	16	;SAVE ACS HERE AT GETSEG
;**************************END OF OVERLAYED STORAGE
RITE:	BLOCK	1
RDHED:	BLOCK	1
RDREAD:	BLOCK	1
ACOUNT:	BLOCK	1
LOWSL:	BLOCK	1	;LOWER INDEX FOR ACCT.SYS SEARCH
HIGHSL:	BLOCK	1	;UPPER INDEX FOR ACCT.SYS SEARCH
SROFS:	BLOCK	1	; SEARCH OFFSET FOR ACCT.SYS SEARCH
DECKNO:	BLOCK	1	;COUNT OF NUMBER OF DECKS
JOBIN:	BLOCK	1
JOBIN1:	BLOCK	1
JOBIN2:	BLOCK	1
JOBIN3:	BLOCK	1
HNGCNT:	BLOCK	1	;COUNT OF HUNG INTERCEPTS
OLDPC:	BLOCK	1	;PLACE TO STORE JOBIN2
PASSWD:	BLOCK	1	;PASSWORD FROM $PASSWORD CARD
BLKCNT:	BLOCK	1	;DISK BLOCKS OUTPUT SO FAR
CRDCNT:	BLOCK	1	;PRESENT CARD NUMBER
COLUMN:	BLOCK	1	;PRESENT CARD COLUMN NUMBER
COLERR:	BLOCK	1	;COLUMN IN ERROR
INDEV:	BLOCK	1	;INPUT DEVICE NAME IN SIXBIT
SCORE:	BLOCK	1	;KEEP TRACK OF CARD ORDER
RENSW:	BLOCK	1	;REENTER SWITCH
THSFIL:	BLOCK	1
THSEXT:	BLOCK	1
THSPRT:	BLOCK	1	;PROTECTION CHANGE IF ANY
THSPPN:	BLOCK	1
REMFLG:	BLOCK	1	;-1 IF REMOTE, 0 IF CENTRAL
CARDB:	BLOCK	33	;CARD IMAGE STORED HERE

BOTTOM:
	BLOCK	5	;GUARD (1 LOCN IS NECESSARY BECAUSE OF BAD BLT)
SUBTTL	HIGH SEGMENT FOR CDRSTK


RELOC 	400000

SUBTTL	CORE CLEAR AND INITIALIZATION


CLEAR:	MOVEI	16,1		;SET UP TO ZERO ACS
	SETZB	0,TOP		;INIT ACS AND STORAGE
	BLT	16,16		;ZERO OUT THE ACS
	MOVE	T1,[XWD TOP,TOP+1]
	BLT	T1,BOTTOM-1	;ZERO OUT STORAGE AREA
	MOVEI	T1,REENTR	;GET REENTER ADDRESS
	MOVEM	T1,.JBREN	;AND STORE FOR REENTER
	PUSHJ	P,INITTY	;INITIALIZE TTY BEFORE GET JOBFF
	MOVEI	T1,JOBIN	;ADDRESS TO PROCESS
	MOVEM	T1,.JBINT	;FOR DEVICE O.K. INTERCEPT
	MOVE	T1,[XWD 4,CDRTRP]
	MOVEM	T1,JOBIN	;SET UP FOR TRAPPING
	MOVE	T1,[XWD 400000,1]
	MOVEM	T1,JOBIN1
INITIA:	MOVSI	T1,'CDR'	;AS DEFAULT INPUT DEVICE
	MOVEM	T1,INDEV	;AND SAVE AS INPUT DEVICE
INITI1:	SETOM	RENSW		;BE PREPARED FOR RE-ENTER
	GETPPN	T1,		;GET PPN OF JOB RUNNER
	JFCL			;IF PRIV JOB WITH .JACCT SET
	MOVEM	T1,RUNNER	;SAVE AS JOB RUNNER
	MOVEI	T1,MAXWID	;TO RESET WIDTH
	MOVEM	T1,WIDSAV	; TO 80 COLUMNS
	TRO	F,HIGHIN	;HIGH SEG IS IN RIGHT NOW
	TLZ	F,ASCII+SIXFL+NINEFL	;CLEAR MODES NOW
	TRZ	F,FRSTWD+FATAL+FATSEE+STAR
	MOVSI	T1,(SIXBIT /QA@/)
	MOVEM	T1,DATANM	;DEFAULT DATA FILE NAME
	MOVSI	T1,(SIXBIT /DSK/)
	MOVEM	T1,OUDEV	;DEFAULT OUTPUT DEVICE SETUP
	MOVEM	T1,LOGOUT+1	;LOG FILE DEVICE =DSK
	MOVEM	T1,CAROUT+1	;AND CARD FILE OUT ALSO
	MOVE	T1,[SIXBIT /JOBAAA/]
	MOVEM	T1,FAKOUT	;RESET DEFAULT FILE NAME
	SETZM	FILCNT		;START WITH NO FILES TO EXECUTE
	IFN	JST026,<
	TLO	F,SIXFL		;SET DEFAULT MODE TO 026>
	IFN	JST029,<
	TLO	F,NINEFL	;SET DEFAULT MODE TO D029>
	POPJ	P,		;RETURN TO PROCESSING


;HERE IS SUBROUTINE TO INITIALIZE TTY FOR OPERATOR/USER I.O.

INITTY:	MOVEI	T1,1		;MODE==1
	MOVSI	T2,(SIXBIT /TTY/)
	MOVE	T3,[XWD 0,CTIBUF]
	SETZ	T4,
	OPEN	TTY,T1		;OPEN DEVICE "TTY"
	  EXIT			;DIE IF NO TTY
	INBUF	TTY,1
	POPJ	P,

SUBTTL	OPERATOR'S INTERACTIVE COMMANDS

;HERE ARE THE ROUTINES FOR PROCESSING OF THE OPERATOR'S
;  INTERACTIVE COMMANDS DURING A CDRSTK RUN.  THESE ROUTINES
;  WILL BE ACCESSED PRIOR TO EACH CARD READ IF TYPE-IN OCCURED.


GOGO1:	PUSHJ	P,NXCHAR	;GET A CHARACTER
	CAIN	C,CR		;WAS A NULL LINE INPUT
	PUSHJ	P,NXCHAR	;YES, GET LINE FEED
	CAIN	C,LF		;FLUSH LINE FEED
	JRST	CPOPJA		; AND RETURN TO WAKE OPERATOR
	SETZ	T1,		;INITIALIZE TO SAVE CHARACTER
	MOVE	T3,[POINT 6,T1]
	MOVEI	T4,6		;SAVE FIRST SIX CHARACTERS
	CAIE	C,"/"		;OPERATOR SWITCH TYPED IN?
	JRST	GOGO2		;NO, USER
	TRO	F,TYPED		;SET TYPED IN FLAG
	JRST	OPERSW		;AND GO TO PROCESS FLAG
GOGO2:	PUSHJ	P,SIXCH2	;GET TYPEIN
TESTER:	PUSHJ	P,TRYIT		;GO SETUP MASK FOR TYPEIN
	MOVSI	M,-NOCRDS	;SEARCH COMMAND TABLE FOR MATCH
TESTR:	MOVE	T3,TABLE(M)	;GET NEXT ENTRY FROM TABLE
	TDZ	T3,T2		;MASK OUT BLANKS
	CAMN	T1,TABLE(M)	;DIRECT MASK MATCH?
	JRST	GOTMAT		;YES, GO PROCESS IT
	CAME	T1,T3		;MATCH MASKED WORD
	JRST	NOGOT		;NO, TRY ANOTHER ENTRY
	TROE	T4,1		;SET FIRST TIME FLAG
	TROA	T4,2		; OR MORE IF APPLICABLE
	MOVE	P1,M		;COPY CURRENT INDEX
NOGOT:	AOBJN	M,TESTR		;KEEP SEARCHING TABLE
	MOVE	M,P1		;RETRIEVE INDEX
	CAIN	T4,1		;MATCH ONLY ONCE?
GOTMAT:	JRST	@DISP1(M)	;GO TO PROCESS COMMAND

TESTRA:	OUTSTR	[ASCIZ/
? COMMAND ERROR, TYPE "H" FOR HELP
/]
	JRST	GOTOIT

;"COMAND" IS THE MACRO WHICH CONTAINS THE FULL TABLE OF LEGAL
; OPERATOR COMMANDS AND THE ADDRESSES OF EACH FOR DISPATCH.

DEFINE COMAND<
	C	EXIT,GETOUT
	C	GO,GOTOCD
	C	HELP,HELP
	C	KILL,KILLS
	C	MCORE,MCORES
	C	MSGLVL,MSGLEV
	C	PAUSE,PAUSES
	C	RESET,START
	C	START,STARTS
	C	STOP,STOPS
	C	TELL,TELLS
	C	WHAT,WHATS
	C	ZZZ,ZZZS
>

DEFINE	C(A,B)<
	<SIXBIT /A/>
>
TABLE:	COMAND
NOCRDS=.-TABLE

DEFINE	C(A,B)<
	Z	B
>
DISP1:	COMAND
SUBTTL	INTERACTIVE COMMAND ROUTINES

GOTOCD:	TLZ	F,GOFLAG	;TO CONTINUE AS BEFORE STOPPED
	SETZM	MESAGE+3	;TO RECEIVE MESSAGE
	MOVEI	T4,^D22
	MOVE	T3,[POINT 6,MESAGE]
	MOVE	T2,[POINT 6,OPRCON]
CALL5:	ILDB	T1,T2		;GAT A CHARACTER
	IDPB	T1,T3		;STORE FOR FILE.LOG
	SOJG	T4,CALL5	;GET ALL OF MESSAGE
	TRNE	F,MESGOK	;CAN THIS BE OUTPUT??
	PUSHJ	P,STLOPR	;YES, OUT THIS TEXT
	PUSHJ	P,CTLSET	;OUTPUT A CHARACTER TO OPERATOR
	JRST	GOTOIT		;AND CONTINUE

HELP:	MOVE	T1,[SIXBIT /CDRSTK/]
	PUSHJ	P,.HELPR	;CALL SUB-ROUTINE
GOTOIT:	TLNN	F,GOFLAG	;CONTINUE WITH CDR INPUT??
	JRST	GOTOI2		;YES, SEE WHERE WE WERE
	OUTSTR	[ASCIZ/
*/]
	JRST	GOGO		;KEEP WAITING FOR THE "GO"
GOTOI2:	TRNN	F,OKAY		;ANY ACTIVE JOBS
	PUSHJ	P,CTLSET	;TO WAKE OPERATOR
	POPJ	P,		;RETURN TO ACTIVE JOB


KILLS:	TRNN	F,OKAY		;IS ANY JOB ACTIVE
	JRST	NOTJOB		;NO, TELL OPERATOR
	PUSHJ	P,LOGCRD	;OUT CARD TO FILE.LOG
	MOVE	T3,[POINT 7,OPRAB]	;FROM OPRAB
	MOVE	T2,[POINT 6,MESAGE]	;TO MESAGE
	ILDB	P1,T3		;GET A CHARACTER
	SUBI	P1,SPACE	;MAKE IT SIXBIT
	IDPB	P1,T2		;DEPOSIT CHARACTER INTO MESAGE
	SOJG	T4,.-3		;GET ALL CHARACTERS
	PUSHJ	P,STLOPR	;GO WAKE OPERATOR
	TRO	F,FATSEE	;FATAL ERROR SIMULATED HERE
	TRZ	F,OKAY		;DISCONTINUE OUTPUT
	JRST	GOTOIT

MCORES:	PUSHJ	P,GETARG	;GET CORE ARGUMENT
MCORE1:	CAILE	T1,MAXCOR	;ASKING FOR TOO MUCH?
	  JRST	CORERR		;YES, LET HIM KNOW
	CAIG	T1,256		;IF GR. THAN 256, ASSUME NOT K
	IMULI	T1,^D1000	;IF LS. THAN 256, MAKE IT K
	HRLM	T1,CORTIM	;SAVE CORE ARGUMENT
	JRST	GOTOIT
CORERR:	OUTSTR	[ASCIZ/
? OVER SYSTEM MAX., TYPE "C" TO CONT
  OR A NEW ARG
/]
	PUSHJ	P,CTLSET	;OUTPUT "*" TO OPERATOR
	INPUT	TTY,		;GET RESPONSE
	PUSHJ	P,NXCHAR	; GET A CHARACTER
	CAIN	C,"C"		;WAS IT A "C"
	JRST	GOTOIT		;RETURN TO CALLER
	SETZ	T1,		;INITIALIZE T1
	PUSHJ	P,GETAR1	;NO, SEE WHAT HE INPUT
	JRST	MCORE1		;AND PLUG INTO CORSAV

;SUBROUTINE TO GET DECIMAL ARGUMENT FROM MCORE OR ZZZ
; AND CONVERT THE ARGUMENT TO OCTAL FOR LATER USAGE

GETARG:	SETZ	T1,		;INITIALIZE T1 FOR DIGITS
	TRNN	F,TYPED		;WHO MADE THIS REQUEST
	PUSHJ	P,GETONE	;CARD INPUT
	TRNE	F,TYPED
	PUSHJ	P,NXCHAR	;PICK UP FIRST DIGIT
GETAR1:	CAIN	C,LF		;BETTER NOT BE LINE FEED
	  JRST	NOARG		;NEED SOME ARGUMENT
	SUBI	C,"0"		;MAKE DIGIT SIXBIT
	CAIL	C,0		;GET NUMBER WHICH
	CAILE	C,^D9		; IS BETWEEN 0-9
	JRST	GETARG		;RETURN FOR NUMBER
	ADD	T1,C
CALLER:	TRNN	F,TYPED		;REQUEST FROM CARDS?
	PUSHJ	P,GETONE	;YES, GET NEXT CARD CHARACTER
	TRNE	F,TYPED		;REQUEST FROM OPERATOR?
	PUSHJ	P,NXCHAR	;YES, GO GET IT
	CAIN	C,CR		;ONLY ONE DIGIT?
	JRST	CALLER		;YES, GET LINE FEED
	CAIN	C,LF		;END OF INPUT?
	POPJ	P,		;YES, RETURN TO CALLER
	SUBI	C,"0"		;SIXBIT CHARACTER
	CAIL	C,0		;BETWEEN 0-9
	CAILE	C,^D9
	  JRST	NOARG		;MUST BE A BAD ARGUMENT
	IMULI	T1,^D10		;SHIFT CHARACTERS SO FAR
	ADD	T1,C		;AND MERGE DIGITS
	JRST	CALLER		;GET ANOTHER DIGIT
NOARG:	OUTSTR	[ASCIZ/
? NUMERIC ARGUMENT NEEDED
/]
	JRST	GOTOIT		;RETURN FROM ERROR

MSGLEV:	SETZB	G1,G2		;INITIALIZE SHORT,FIRST,EACH
	TLZ	F,SHORT+EACH+FIRST+ALL+DOLLAR+JOBS
MSGLV1:	PUSHJ	P,NXCHAR	;GET A CHARACTER
	CAIN	C,CR		;END OF TYPE-IN YET?
	JRST	MSGLV1		;YES, RETRIEVE <LF>
	CAIN	C,LF		;TRUE END OF TYPE-IN?
	JRST	MSGLV2		;TIME TO USE TYPE-IN
	SUBI	C,"0"		;DIGITIZE TYPE-IN
	CAIL	C,0		;ARGUMENTS MUST BE BETWEEN
	CAILE	C,3		;        0-3
	  JRST	NOARG1		;ERROR--TELL OPERATOR
	MOVE	G3,G2		;GET ARGS IN POSITION
	MOVE	G2,G1		;FOR LATER USE
	MOVE	G1,C		;STARTING AT BOTTOM
	JRST	MSGLV1		;RETURNING UNTIL FULL
MSGLV2:	CAIN	G1,3		;SPECIAL CASE OF
	MOVEI	G1,4		;"ALL" REQUESTED
	LSH	G3,^D17		;POSITION AS FOUND IN FLAGS
	LSH	G2,^D15
	LSH	G1,^D12
	IOR	G3,G2		;GROUP BITS AS FOUND IN "F"
	IOR	G3,G1
	TLZ	G3,7777
	TLO	F,(G3)		;SET FLAGS
	JRST	GOTOIT		;RETURN TO OUTPUT

NOARG1:	OUTSTR	[ASCIZ/
? ARGUMENT ERROR
/]
	JRST	GOTOIT		;RETURN FOR ANOTHER CHANCE

STARTS:	TRNE	F,OKAY		;ALREADY RUNNING
	  JRST	BADSTA		;YES, TELL TYPER
	PUSHJ	P,GETWD		;SET UP COMMAND FROM "START"
	JRST	.+2		;TO EXECUTE GOOD COMMAND
	  JRST	RETRY		;RETURN TO OPERATOR AFTER ERROR
	SETZM	JOBIN2
	SETZM	JOBIN3
	PUSHJ	P,CTLSET	;OUT A "!" TO OPERATOR
	JRST	CDRSET		;GO TO START CDR
BADSTA:	OUTSTR	[ASCIZ/
? TYPE KILL FIRST, ANOTHER JOB IS RUNNING
/]
	JRST	GOTOIT		;LIKE NOTHING EVER HAPPENED

PAUSES:	TLO	F,STOP		;SET PAUSE AT NEXT EOF FLAG
	JRST	GOTOIT		;RETURN TO OUTPUT


STOPS:	MOVEI	T3,6		;PREPARE TO OUTPUT NAME
	MOVE	T4,[POINT 7,C]	;AS ASCII STRING IN "C"
	MOVE	T2,[POINT 6,OLNAME]
	SETZB	C,M		;ZERO C AND C+1 FOR ASCIZ
RESET1:	ILDB	T1,T2		;GET SIXBIT CHARACTER
	ADDI	T1,40		;MAKE IT ASCII
	CAIE	T1,SPACE	;IGNOR BLANKS
	IDPB	T1,T4		;AND SAVE IT IN "C"
	SOJG	T3,RESET1	;GOT ALL 6 YET?
	CAIN	C,0		;WAS A NAME SPECIFIED??
	  JRST	DECCHK
	OUTSTR	[ASCIZ /NAME-/]
	OUTSTR	C		;OUTPUT JOBNAME
DECCHK:	SKIPN	T1,DECKNO	;ANY DECK NUMBER?
	  JRST	CARCHK		;NONE, CHECK CARD NUMBER
	OUTSTR	[ASCIZ/
DECK #/]
	PUSHJ	P,DECOUT	;SUBROUTINE TO OUT DECIMAL
CARCHK:	SKIPN	T1,CRDCNT
	  JRST	DOIT
	OUTSTR	[ASCIZ/
CARD #/]
	PUSHJ	P,DECOUT	;OUTPUT DECIMAL NUMBER
	TLNE	F,GOFLAG	;HERE FROM REEN OR WHAT
	OUTSTR	[ASCIZ/
!/]
DOIT:	TLZE	F,GOFLAG	;HEHE FROM REEN OR WHAT
	POPJ	P,		;RETURN TO CDRSTK
	TLO	F,GOFLAG	;WILL NEED A "GO"
	MOVEI	T4,^D24
	MOVE	T3,[POINT 6,MESAGE]
	MOVE	T2,[POINT 6,OPRSTP]
CALL2:	ILDB	T1,T2
	IDPB	T1,T3
	SOJG	T4,CALL2
	TRNE	F,MESGOK
	PUSHJ	P,STLOPR
	JRST	GOTOIT

;SUBROUTINE TO OUTPUT A DECIMAL NUMBER FROM AN OCTAL NUMBER
;  CALLED BY:  PUSHJ  P,DECOUT
;  WITH AN OCTAL NUMBER IN T1
;  AND OUTPUTS DIRECTLY TO TTY

DECOUT:	IDIVI	T1,^D10		;DIVIDIE BY RADIX
	HRLM	T2,(P)		;SAVE REMAINDER
	SKIPE	T1		;SEE IF ANYTHING REMAINS
	PUSHJ	P,DECOUT	;YES, LOOP BACK WITH PD LIST
	HLRZ	T1,(P)		;GET BACK A DIGIT
	ADDI	T1,"0"		;CONVERT TO ASCII
	OUTCHR	T1		;OUTPUT TO OPERATOR
	POPJ	P,		;RETURN

TELLS:	TRNN	F,OKAY		;ANY ACTIV JOBS YET?
	JRST	NOTJOB		;NO, NONE
	OUTSTR	[ASCIZ /TYPE
*/]
	INPUT	TTY,		;HE RESPONDED, GET TEXT
	SETZM	MESAGE		;CLEAR OUT ANY OLD TEXT
	SETZM	MESAGE+1
	SETZM	MESAGE+2
	SETZM	MESAGE+3	;BEFORE NEW TEXT ENTERED
	MOVEI	T4,^D24		;24 CHARACTER MESSAGE
	MOVE	T3,[POINT 6,MESAGE]
TELLS1:	PUSHJ	P,NXCHAR	;GET A CHARACTER
	CAIE	C,CR		;END OF MESSAGE??
	CAIN	C,LF		; DETECTED YET??
	JRST	TELLS2		;OUT TO FILE.CTL OR RETURN
	SUBI	C,40		;MAKE IT SIXBIT
	SOJL	T4,TELLS1	;GOT ENOUGH
	IDPB	C,T3		;STORE THE CHARACTER
	JRST	TELLS1		;RETURN FOR MORE
TELLS2:	TRNN	F,MESGOK	;HAS FILE.LOG BEEN INITTED
	JRST	CPOPJ1		;NO, DON'T ATTEMPT OUTPUT
	PUSHJ	P,STLOPR	; TAG MESSAGE AS OPERATOR MESSAGE
	JRST	GOTOIT		;RETURN WHEN FINISHED

WHATS:	TRNN	F,OKAY		;DON'T BOTHER IF NO JOB
	JRST	NOTJOB
	TLO	F,GOFLAG	;NO OPERATOR RESPONSE REQUIRED
	PUSHJ	P,STOPS		;OUTPUT THE TEXT
	JRST	GOTOIT		;AND RETURN TO CDRSTK

ZZZS:	PUSHJ	P,GETARG	;GET ARGUMENT INTO T1
	MOVEM	T1,ZZZSAV	;SAVE FOR CDR ROUTINES
	JRST	GOTOIT		;RETURN

NOTJOB:	OUTSTR	[ASCIZ/
?NO ACTIVE JOB
/]
	JRST	GOTOIT		;RETURN
SUBTTL	COMMAND PROCESSOR

;HERE IS WHERE "START" COMMAND IS PROCESSED
; AND DISK I/O IS INITIALIZED

EXTERN	.TRUFD

BEGIN:	SETZM	BUFLOG		;TO CLEAR OUT ANY RESIDUE
	MOVE	T1,[XWD BUFLOG,BUFLOG+1]
	BLT	T1,BUFLOG+21	;CLEAR OUT THE OLD
	SETZM	BUFLOG+25	;BUT RETAIN LIMITS
BEGIN1:	OPEN	DSK,OUPUT	;OPEN OUTPUT DEVICE
	  JRST	INFAI		;"OUTPUT DEVICE INIT FAILURE"
	OPEN	DSK1,LOGOUT
	  JRST	INFAI
LOOKUP:	MOVE	T1,RUNNER	;WHO IS RUNNING THIS JOB
	CAMN	T1,PPNS		;  RUNNING OWN JOB??
	JRST	LOOKU1		;SURELY HAS A UFD
LOOKP1:
IFE	SUBROU,<
	MOVE	T1,PPNS		;FOR USAGE BY TRYUFD
LOOKP2:	MOVE	T2,OUDEV	; "              "
	CAIN	T2,0		;IS THERE A REAL DEVICE
	MOVSI	T2,'DSK'	; DEFAULT==DSK
	MOVEI	T3,BUFLOG	;COMMON WORK AREA
	PUSHJ	P,.TRUFD	;GO TRY THIS UFD
	  JRST	UFDFAI		; BAD RETURN
	JRST	WILD		;RETURN FROM LOOKUP SUCCESSFUL
	JRST	LOOKU1		;RETURN FROM ENTER SUCCESSFUL

WILD:	HRRZ	T1,NEWPPN	;GET RIGHT HALF OF ORIGINAL PPN
	CAIE	T1,-2		; WAS IT WILD PROGRAMMER??
	  JRST	LOOKU1		;NO, LEGITIMATE USER
	AOS	T1,PPNS		;INCREMENT PPN
	JRST	LOOKP2		;AND GIVE IT ANOTHER TRY
>
IFN	SUBROU,<
	MOVEI	T1,6		;FOR GRABBING INTERLOCK
	MOVEM	T1,BUFLOG	; BUFLOG--BUFLOG+7
	MOVE	T1,OUDEV	;GET OUTPUT DEVICE NAME
	CAIN	T1,0		;SHOULD NEVER HAPPEN,
	MOVSI	T1,(SIXBIT /DSK/)  ; BUT BE SAFE.
	MOVEM	T1,BUFLOG+1	;STORE HERE
	MOVE	T1,PPNS		;GET USER'S PPN
	MOVEM	T1,BUFLOG+2	;INTO BUFLOG+2
	MOVEI	T1,^D360	;#OF TIMES TO TRY INTERLOCK(6 MINS.)
	JRST	LOOKRA		;DON'T NAP YET
LOOKER:	MOVEI	T3,1		;ONE SECOND IS SUFFICIENT
	SLEEP	T3,		;Z-Z-Z
LOOKRA:	MOVE	T2,[XWD 3,BUFLOG]
	CALLI	T2,50		;INTERLOCK UUO
	  SOJGE	T1,LOOKER	;KEEP TRYING
	CAIGE	T1,0		;REALLY MAKE IT THROUGH
	  JRST	LOCFAI		;NO, SHOULD HAVE INTERLOCK
LOOKR1:	MOVEI	T1,17		;OPEN IN DUMP MODE
	MOVE	T2,OUDEV	;GET STRUCTURE NAME
	SETZ	T3,
	OPEN	UFD,T1		;TO LOOKUP AND ENTER UFD
	  JRST	INFAL		;CAN'T DO IT
	MOVEI	T1,25		;# WDS. IN EXTENDED LOOKUP
	MOVEM	T1,BUFLOG	;INTO BUFLOG
	MOVE	T1,PPNS		;RETRIEVE P#,P#
	MOVEM	T1,BUFLOG+2	;AND STORE IN WD. #3
	MOVE	T1,[XWD 1,1]	;SYSTEM PROJ,,PROG
	MOVEM	T1,BUFLOG+1	; GOES IN WD. #2
	MOVSI	T1,(SIXBIT /UFD/)  ;EXTENSION==UFD
	MOVEM	T1,BUFLOG+3	;STORED IN WORD #4
	SETZM	OUDIR+2
	LOOKUP	UFD,BUFLOG	;HAVE UFD FOR THIS P#,P# ?
	  JRST	LOOKR2		;TO MAKE UP A USER UFD
	HRRZ	T1,NEWPPN	;MAKING UP PROG# FOR USER??
	CAIE	T1,-2		;RIGHT HALF TELLS US
	JRST	LOOKOK		;HAS ONE ALREADY
	PUSHJ	P,LOCREL	;RELEASE INTERLOCK FOR THIS PPN
	MOVEI	T1,1
	ADDM	T1,PPNS		;INCREMENT PPN
	JRST	LOOKP1		;AND RETURN FOR NEXT TRY
LOOKR2:	HRRZ	T1,BUFLOG+3	;GET ERROR CODE
	CAIE	T1,0		;"FILE NOT FOUND"??
	  JRST	LOOKOK		;NOT FILE NOT FOUND, SO TRY TO GO
	MOVEI	T1,25		;FOR EXTENDED ENTER
	MOVEM	T1,BUFLOG	;25 WORDS TO EXTENDED ENTER
	MOVE	T1,[XWD 1,1]	;GET SYSTEM PROJ,PROG
	MOVEM	T1,BUFLOG+1	;INTO WORD #2
	MOVE	T1,PPNS		;GET USER PPN
	MOVEM	T1,BUFLOG+2	;INTO WORD #3
	MOVSI	T1,(SIXBIT /UFD/)   ;EXTENSION==UFD
	MOVEM	T1,BUFLOG+3	;STORED IN WD. #4
	MOVEI	T1,400000	;PHYSICAL DEVICE
	MOVEM	T1,BUFLOG+17	;DIRECTORY FILE PROTECT BIT
	ENTER	UFD,BUFLOG	;DO THE ENTER
	  JRST	UFDFAI
	SETZM	OUDIR+2
	USETO	UFD,2
LOOKOK:	RELEASE	UFD,
	HRRZ	T1,NEWPPN	;WHAT WAS ORIGINAL PPN??
	CAIN	T1,-2		;A FUDGE NUMBER??
	TRO	F,FRSTWD	;YES, TELL LATER
	MOVE	T1,RUNNER	;IS USER RUNNING THIS JOB?
	CAMN	T1,PPNS		;IN HIS OWN AREA
	JRST	LOOKU1		;YES, HE DOESN'T HAVE INTERLOCK
	TLNE	T1,777776	;IS THIS PROJECT #1
	JRST	LOOKU1		;IF NOT PROJ. 1 -- NO INTERLOCK
	PUSHJ	P,LOCREL	;GO RELEASE INTERLOCK
>
LOOKU1:	MOVSI	T1,(SIXBIT /LOG/)
	MOVEM	T1,NEW+1	;EXTENSION
	MOVE	T1,PPNS
	MOVEM	T1,NEWPPN
	SETZM	NEW+2		;CLEAR FOR LOOKUP
	LOOKUP	DSK,NEW		;SEE IF UNIQUE
	SKIPA	T1,NEW+1	;YES, IT'S UNIQUE
	  JRST	MAKEIT		;GO MAKE A UNIQUE NAME
	TRNN	T1,-1		;IS IT A UNIQUE TYPE PROBLEM?
	JRST	ENTER		;NO, TRY THIS NAME
MAKEIT:	AOS	T1,FAKOUT	;INCREMENT DEFAULT NAME
	MOVE	T2,T1		;COPY NAME INTO T2
	ANDI	T2,77		;GET LAST CHARACTER
	CAIG	T2,72		;"Z"--STAY WITHIN ALPHABETICS
	JRST	MADEIT		;O.K. GO TRY TO USE
	ADDI	T1,47		;675 POSSIBLE ALPHA DEFAULTS
MADEIT:	MOVEM	T1,FAKOUT	;REPLACE FILE NAME
	MOVEM	T1,NEW		;SAVE FOR ENTER
	JRST	LOOKU1		;GO BACK AND TRY AGAIN
ENTER:	SETZM	NEW+2		;CLEAR FOR ENTER
	MOVSI	T1,'CTL'	;IS THERE A .CTL FILE HERE??
	MOVEM	T1,NEWEXT	; FOR LOOKUP
	LOOKUP	DSK,NEW		;DO THE LOOKUP TO SEE
	SKIPA	T1,NEW+1	;UNIQUE FILE??
	  JRST	MAKEIT		;NOT UNIQUE, GET A UNIQUE NAME
	TRNE	T1,-1		;WHY DID LOOKUP FAIL??
	JRST	MAKEIT		;
	SETZM	NEW+2		;AND CLEAR FOR ENTER
	MOVE	T2,PPNS		;COPY PPN FOR ACCESS UUO
	PUSHJ	P,CHACCS	;GO AND CHECK ACCESS
	  JRST	FAILAC
	MOVE	T1,NEW		;TO SAVE NAME FOR QUEUER
	MOVEM	T1,OLNAME	;FOR QUEUE CALL
	MOVE	T1,PPNS		;RESET PROJ,PROG PAIR
	MOVEM	T1,NEWPPN	;AND SAVE FOR LATER
	MOVSI	T1,(SIXBIT /CTL/)
	MOVEM	T1,NEWEXT	;SETUP FILE.CTL
	ENTER	DSK,NEW		;ENTER OUTPUT FILE
	  JRST	DSKFAI		;CAN'T ENTER FILE "NEW"
	SETZM	NEW+2		;ZERO OUT MONITOR RESPONSE
	MOVSI	T1,(SIXBIT /LOG/)
	MOVEM	T1,NEWEXT
	MOVE	T1,PPNS		;GET P#,P#
	MOVEM	T1,NEWPPN	;READY FOR ENTER
	ENTER	DSK1,NEW	;TRY ENTER
	  JRST	DS1FAI
	PUSHJ	P,STLOG		;START FILE.LOG
	TRO	F,MESGOK	;MESSAGE FROM OPERATOR O.K. NOW
	MOVE	T1,FAKOUT	;GET DEFAULT NAME
	MOVEM	T1,NEW		;AND SAVE IT IN NEW
	SETZM	BUFLOG		;TO CLEAN UP BEFORE END
	MOVE	T1,[XWD BUFLOG,BUFLOG+1]
	BLT	T1,BUFLOG+25	;CLEAN OUT ALL OLD STUFF
	POPJ	P,		;AND RETURN

FAILAC:	OUTSTR	NOTYOU		;NO ACCESS TO FILE
	JRST	ENTFA1		;GO CONTINUE ERROR
UFDFAI:	RELEASE	UFD,
	HRRZ	T1,BUFLOG+3	;GET ERROR TYPE FROM MONITOR
	JRST	ENTFAL
DSKFAI:	RELEASE	DSK,
	HRRZ	T1,NEWEXT	;GET ERROR TYPE FROM MONITOR
	JRST	ENTFAI
DS1FAI:	RELEASE	DSK1,
	HRRZ	T1,NEWEXT	;GET ERROR TYPE FROM MONITOR
	JRST	ENTFAI

;SUBROUTINE TO RELEASE INTERLOCK--CALLED AFTER CREATION OF UFD
; AND CALLED FROM ERROR ROUTINES INFAL AND ENTFAL

IFN	SUBROU,<
LOCREL:	MOVEI	T1,7		;NUMBER OF WORDS
	MOVEM	T1,BUFLOG	;GOES INTO BUFLOG - WORD #1
	MOVE	T1,OUDEV	;GET STRUCTURE NAME
	CAIN	T1,0		;SHOULD NEVER HAPPEN, BUT
	MOVSI	T1,(SIXBIT /DSK/)
	MOVEM	T1,BUFLOG+1	;SAVE STRUCTURE NAME
	MOVE	T1,PPNS		;GET USER PROJECT,,PROG PAIR
	MOVEM	T1,BUFLOG+2	;INTO WORD #3
	MOVE	T2,[XWD 3,BUFLOG]
	CALLI	T2,50		;TO RELEASE INTERLOCK
	  JRST	LOCFAI		;CAN'T RELEASE INTERLOCK
	POPJ	P,		;AND RETURN
>
SUBTTL	COMMAND SCANNER PARSE

;HERE TO PARSE OPERATOR'S "START" COMMAND STRING
;  FORMAT:  *START DEVICE:FILE.EXT[PRO,PRG] /SWITCH /SWITCH
;
;  DEFAULT DEVICE==CDR

GETWD:	MOVSI	T1,'CDR'	;TO RESET DEFAULT INPUT DEVICE
	MOVEM	T1,INDEV	;==CDR
	CAIN	C,LF		;NO ARGUMENTS SPECIFIED?
	JRST	NAMST1		;NONE, GO STRAIGHT DEFAULTS
	SETZM	NEW+1		;ZERO EXTENSION FIELD FOR USER
	CAIE	C,"/"		; WAS FORMAT==START/SWITCH ??
	JRST	GETNB		;NO, NOT THAT WAY
	PUSHJ	P,OPERSW	;YES, GO PROCESS SWITCH
	  JRST	CMDERR		; THE SWITCH LOST
GETNB:	SETZ	T1,		;GET FIRST WORD OF TYPEIN
	CAIE	C,LF		;AT END OF COMMAND YET??
	CAIN	C,CR
	JRST	NAMST1		;YES, PROCESS TO HERE
	PUSHJ	P,SIXCHR	;NO, GET NEXT COMPONENT
	CAIE	C,SPACE		;TERMINATOR==SPACE
	JRST	.+3		;NO, SEE WHAT TO DO
	PUSHJ	P,NXCHAR	;YES, GET NEXT CHARACTER
	JRST	.-3		;AND SEE IF IT'S A SPACE
	CAIE	C,"/"		;SWITCH SPECIFIED
	JRST	GETNC		;NO, SEARCH ON
	PUSHJ	P,OPERSW	;GO PROCESS SWITCH
	  JRST	CMDERR		;ERROR IN TYPE-IN
	JRST	GETNB		;GET NEXT PART OF COMMAND STRING
GETNC:	CAIN	C,":"		;DEVICE SPECIFICATION??
	JRST	DEVSET		;YES, GO SET DEVICE
	CAIN	C,"."		;NAME.EXT SPECIFICATION?
	JRST	NAMSET		;YES, GO SET IN PLACE
	CAIN	C,"["		;P#,P# DETECTED??
	JRST	NAMSET		;GO PROCESS
	CAIE	C,CR		;END OF LINE DETECTED??
	CAIN	C,LF
	JRST	NAMSET		;MAY HAVE "NAME<CR><LF>"
CMDERR:	OUTSTR	[ASCIZ/
? COMMAND ERROR
/]
	JRST	CPOPJA		;RETURN TO OPERATOR WAIT



DEVSET:	MOVEM	T1,INDEV	;SET INPUT DEVICE NAME
	JRST	GETNB		;RETURN TO GET NEXT PART

NAMSET:	JUMPE	T1,EXTIN
	SKIPN	NAMTEM		;NAME ALREADY SPECIFIED?
	MOVEM	T1,NAMTEM	;SET NAME
	SETZ	T1,
EXTIN:	CAIN	C,"["
	JRST	PNUMIN
	CAIE	C,"."
	JRST	NAMST1		;GOT HERE WITH <CR><LF>
	PUSHJ	P,SIXCHR	;GET EXTENSION
	HLLM	T1,EXTTEM	;RETAIN EXTENSION
NAMST1:	CAIN	C,CR		;AT END OF LINE YET??
	PUSHJ	P,NXCHAR	;YES, GET <LF>
	CAIE	C,LF		;END OF THE LINE??
	JRST	GETNB		;NO, RETURN FOR COMMAND
	SKIPE	T1,NAMTEM	;RETRIEVE TEMP NAME
	MOVEM	T1,NEW	;SET NAME TO SPECS
	SKIPE	T1,EXTTEM	;RETRIEVE EXTENSION
	MOVEM	T1,NEW+1
	SETZM	NAMTEM
	TRO	F,STAR		;WE'RE GOING NOW
	POPJ	P,		;GO START JOB

PNUMIN:	SETZ	T1,		;INITIALIZE TI
	PUSHJ	P,NXCHAR	;GET A CHARACTER
	CAIN	C,SPACE
	JRST	.-2
PNUMN1:	CAIL	C,"0"		;WHICH IS NUMERICAL
	CAILE	C,"9"
	  JRST	CMDERR		;ERROR IF NOT IN RANGE
	SUBI	C,"0"		;DIGITIZE INPUT
	LSH	T1,3		;PREPARE DESTINATION
	ADD	T1,C		;UPDATE CHARACTERS
	PUSHJ	P,NXCHAR	;GET NEXT CHARACTER
	CAIN	C,SPACE
	JRST	.-2
	CAIE	C,","		;P#,,P# DELIMETER?
	JRST	PNUMN1		;NOT YET, FIX NUMBER
	HRLZM	T1,PSAVER	;YES, RETAIN PROJ. NUMBER
	SETZ	T1,		;CLEAN START
	PUSHJ	P,NXCHAR	;GET DIGIT
	CAIN	C,SPACE
	JRST	.-2
PNUMN2:	CAIL	C,"0"		;MUST BE A DIGIT
	CAILE	C,"9"		;BETWEEN 0-9
	  JRST	CMDERR		;ERROR IF NOT
	SUBI	C,"0"		;DIGITIZE TYPE-IN
	LSH	T1,3		;PREPARE DESTINATION AC
	ADD	T1,C		;UPDATE CHARACTERS
	PUSHJ	P,NXCHAR	;GET NEXT DIGIT
	CAIN	C,SPACE
	JRST	.-2
	CAIE	C,"]"		;END OF PROJ,,PROG PAIR YET??
	JRST	PNUMN2		;NO, KEEP PICKING UP CHARS.
	HRRM	T1,PSAVER	;YES, END--RETAIN PROJ. NUMBER
	JRST	GETNB		;RETURN FOR ANY MORE TYPEIN
SUBTTL	LOG FILE OUTPUT

STLOG:	PUSHJ	P,TIME1		;TIMESTAMP THE LINE
	MOVE	T2,[ASCII /DATE/]
	PUSHJ	P,OUTLO5	;OUTPUT "DATE"
	PUSHJ	P,OUTTAB	;FOLLOWED BY A TAB
	PUSHJ	P,DATE1		;GET TODAY'S DATE
	MOVEI	P3,5		;GETTAB COUNTER
	MOVE	P2,[XWD 0,11]
STLOG1:	MOVE	T2,P2
	GETTAB	T2,		;GET SYSTEM NAME
	JRST	STLOG2		;AT END OF SYSTEM NAME
	ADD	P2,[XWD 1,0]
	PUSHJ	P,OUTLO5	;OUTPUT SYSTEM NAME
	SOJG	P3,STLOG1	;RETURN FOR MORE NAME
STLOG2:	PUSHJ	P,OUTTAB	;FOLLOWED BY A TAB OUT
	MOVE	T2,[ASCII /CDRST/]
	PUSHJ	P,OUTLO5	;OUT SYS NAME
	MOVE	T2,[ASCII /K VER/]
	PUSHJ	P,OUTLO5	;TITLE
	MOVEI	T1,SPACE	;INSERT SPACE AFTER TITLE
	PUSHJ	P,OUTLOG	;OUT THE SPACE
	MOVEI	T2,VERNUM	;RETRIEVE VERSION NUMBER
	PUSHJ	P,VEROUT	;OUTPUT VERSION NUMBER
	MOVEI	T1,VCUSTM	;GET CUSTOMER'S EDITION
	JUMPE	T1,STLOG3
	ADDI	T1,"@"		; AS AN ALPHABETIC
	PUSHJ	P,OUTLOG	; INTO FILE.LOG
STLOG3:	MOVEI	T2,VPATCH	;GET THE PATCH LEVEL
	JUMPE	T2,STLOG4	;A VERGIN VERSION--HOW NICE!
	MOVEI	T1,"("		;OH WELL!!
	PUSHJ	P,OUTLOG	;TO BRACKET THE PATCH LEVEL
	PUSHJ	P,VEROUT	;MAKE IT NUMBER OF TIMES
	MOVEI	T1,")"		;ENCLOSE IT
	PUSHJ	P,OUTLOG	;FOR NEATNESS SAKE
STLOG4:	MOVEI	T2,EDITOR	;WHO MODIFIED THIS??
	JUMPE	T2,STLOG5	;0==DEC DEVELOPMENT
	MOVEI	T1,"-"		;DASH BEFORE EDITOR NUMBER
	PUSHJ	P,OUTLOG	;INTO THE FILE.LOG
	PUSHJ	P,DATOUT	;FOLLOWED BY EDITOR'S NUMBER
STLOG5:	MOVEI	T1,SPACE	;FOLLOWED BY A SPACE
	PUSHJ	P,OUTLOG	;BEFORE DEVICE NAME
	MOVEI	T4,4		;DEVICE NO GREATER THEN 4 LETTERS
	MOVE	T3,[POINT 6,PHYNAM]
	SKIPN	PHYNAM		;PHYSICAL NAME SPECIFIED??
	MOVE	T3,[POINT 6,INDEV]
	PJRST	STOPR1		;OUTPUT DEVICE NAME AND <CR><LF>

STLIN2:	PUSHJ	P,TIME1		;TIMESTAMP LINE
	MOVE	T2,[ASCII /STACK/]
	PUSHJ	P,OUTLO5	;OUT LINE TITLE
	PUSHJ	P,OUTTAB	;FOLLOWED BY A TAB
	PJRST	OUTLIN		;OUTPUT <CR><LF> AND RETURN


STLOPR:	PUSHJ	P,TIME1		;TIME STAMP LINE
	MOVE	T2,[ASCII /STOPR/]
	PUSHJ	P,OUTLO5	;OUTPUT LINE TITLE
	PUSHJ	P,OUTTAB	;TAB OVER ON LINE
	MOVEI	T4,^D24		;MAXIMUM MESSAGE=24 CHARACTERS
	MOVE	T3,[POINT 6,MESAGE,]
STOPR1:	ILDB	T1,T3		;GET A "MESSAGE" CHARACTER
	ADDI	T1,SPACE	;CONVERT TO ASCII
	PUSHJ	P,OUTLOG	;OUT IT TO FILE.CTL
	SOJG	T4,STOPR1	;RETURN TIL END OF "MESSAGE"
	PJRST	OUTLIN		;OUT <CR><LF> AFTER MESSAGE

OUTLO5:	MOVEI	T4,5		;5 CHARACTER COUNTER
OUTLO6:	MOVE	T3,[POINT 7,T2]
OUTL5A:	ILDB	T1,T3		;GET A CHARACTER
	SKIPE	T1
	PUSHJ	P,OUTLOG	;GO TO OUT IT
	SOJG	T4,OUTL5A	;GET ALL 5 CHARACTERS
	POPJ	P,		;RETURN AT END

LOGCRD:	PUSHJ	P,TIME1		;TIMESTAMP LINE
	MOVE	T2,[ASCII /CARD /]
	PUSHJ	P,OUTLO5	;OUT THE CHARACTERS
	PUSHJ	P,OUTTAB	;OUT A TAB FOLLOWING "CARD"
LOGCRA:	MOVEI	T4,DEFWID	;SET UP CHARACTER COUNT
	ADDI	T4,2		;DON'T FORGET <CR-LF>
	MOVE	T2,[POINT 7,CARDB]
LOGCR1:	ILDB	T1,T2
	PUSHJ	P,OUTLOG	;OUT THE CHARACTER FROM CARDB
	CAIE	T1,LF		;CEASE OUTPUT AT <LF>
	SOJG	T4,LOGCR1	;RETURN UNTIL END OF CARD
	TLNE	F,SUPRES	;SUPPRESS TRAILING BLANKS?
	JRST	LOGCR3		;YES
	SKIPN	M		;NO <CR><LF>
LOGCR2:	PUSHJ	P,OUTLIN	;OUTPUT LINE TERMINATORS
LOGCR3:	SETZ	M,		;CLEAR LINE TERMINATOR FLAG
	POPJ	P,		;AND RETURN


;SUBROUTINE TO INSERT A TAB INTO OUTPUT STREAM

OUTTAB:	MOVEI	T1,TAB		;TAB==11
	PJRST	OUTLOG		;OUT TO FILE.LOG AND RETURN

;SUBROUTINE TO OUT <CR><LF> TO FILE.CTL

OUTLIN:	MOVEI	T1,CR		;CR==12 (CARR RETURN)
	PUSHJ	P,OUTLOG	;OUTPUT <CR>
	MOVEI	T1,LF		;LF==15  (LINE FEED)
	;PJRST	OUTLOG		FALL DOWN TO OUTLOG

OUTLOG:	TRNN	F,OKAY		;OKAY TO OUTPUT
	JRST	MAKERR		;GO CHECK IF WANT AN ERROR FILE
OUTLG1:				;RETURN FROM ERROR FILE MAKER
	SOSG	LOGBUF+2
	JRST	OUTLO2
OUTLO1:	IDPB	T1,LOGBUF+1	;GET THE CHARACTER
	POPJ	P,		;RETURN

OUTLO2:	AOS	G3,BLKCNT	;KEEP BLOCK COUNT UP TO DATE
	OUT	DSK1,		;OUTPUT THIS BUFFER
	JRST	OUTLO1		;AND RETURN FOR MORE
	OUTSTR	[ASCIZ /?LOG FILE OUTPUT FAILURE
/]
	CLOSE	DSK1,		;CLOSE FILE
	OUTSTR	CARDB
	POPJ	P,		;AND RETURN FOR NOW

MAKERR:	SKIPE	P3,ERRFIL	;ERROR FILE ALREADY ESTABLISHED??
	  JRST	OUTLG1		;YES, GO OUTPUT TO IT
	OPEN	DSK1,LOGOUT	;OPEN THE RIGHT CHANNEL
	  JRST	INFAI		;OPEN FAILED
	PUSH	P,T2		;SAVE CONTENTS OF T2
	MOVE	T2,[SIXBIT /CDRUSR/]
	MOVEM	T2,ERRFIL	;SAVE ERROR FILE NAME
	MOVEM	T2,OLNAME	; AND SAVE IT AS FILENAME
	MOVSI	T2,'LPT'	;GET DEFAULT EXTENSION
	MOVEM	T2,ERREXT	;AND PUT INTO CORE
	SETZM	ERRWD		;CLEAR OUT WORD THREE
	MOVE	T2,RUNNER	;GET PPN OF JOB RUNNER
	MOVEM	T2,ERRPPN	;AND SAVE AS ERROR PPN
	ENTER	DSK1,ERRFIL	;ENTER THIS FILE
	  JRST	.+1		;FOR NOW*******
	POP	P,T2		;GET SAVED AC BACK
	JRST	OUTLG1		;AND GO DO OUTPUT


DATE1:	SETZ	T3,		;PREPARE FOR ASCIZ OUT
	DATE	T1,		;GET DATE INTO T1
	IDIVI	T1,^D31		;START WITH DAY-1 IN T2
	ADDI	T2,1		;MAKE IT EXACT
	MOVE	T4,T1		;RETAIN T1
	PUSHJ	P,DATOUT	;OUT THE DAY
	MOVE	T1,T4		;RETRIEVE T1
	IDIVI	T1,^D12		;GET MONTH INDEX
	MOVE	T2,[ASCII /-JAN-/
		    ASCII /-FEB-/
		    ASCII /-MAR-/
		    ASCII /-APR-/
		    ASCII /-MAY-/
		    ASCII /-JUN-/
		    ASCII /-JUL-/
		    ASCII /-AUG-/
		    ASCII /-SEP-/
		    ASCII /-OCT-/
		    ASCII /-NOV-/
		    ASCII /-DEC-/](T2)
	MOVE	P2,T1		;SAVE T1
	PUSHJ	P,OUTLO5	;OUT MONTH NAME
	MOVEI	T2,^D64(P2)	;GET THE YEAR
	PUSHJ	P,DATOUT	;OUT THE YEAR
	MOVEI	T1,SPACE	;SPACE OVER AFTER DATE
	PJRST	OUTLOG		;OUTPUT SPACE AND RETURN

VEROUT:	IDIVI	T2,^D8		;RADIX CONVERSION
	JRST	.+2
DATOUT:	IDIVI	T2,^D10		;RADIX CONVERTER
	MOVEI	T1,"0"(T2)	;RADIX CONVERT
	PUSHJ	P,OUTLOG	;OUT ONE CHARACTER
	MOVE	T2,T3		;RETRIEVE REMAINDER
	CAILE	T2,"9"
	JRST	DATOUT		;YES, OUTPUT IT
	MOVEI	T1,"0"(T2)
	PJRST	OUTLOG


TIME1:	MSTIME	T1,		;GET PRESENT TIME IN MILLISECS.
	IDIVI	T1,^D1000	;CONVERT TO SECS
	IDIVI	T1,^D3600	;GET HRS INTO T1
	PUSHJ	P,LOGTIM	;OUT HRS TO FILE.LOG
	MOVEI	T1,":"		;FOLLOWED BY COLON
	PUSHJ	P,OUTLOG	;OUT DELIMETER
TIME2:	MOVE	T1,T2		;RETRIEVE MIN/SEC
	IDIVI	T1,^D60		;GET MINS INTO T1
	PUSHJ	P,LOGTIM	;OUT MINS TO FILE.LOG
	MOVEI	T1,":"		;FOLLOWED BY COLON
	PUSHJ	P,OUTLOG	;OUT THE COLON
	MOVE	T1,T2		;GET SECONDS
	PUSHJ	P,LOGTIM	;OUTPUT TO FILE.LOG
	MOVEI	T1,SPACE	;FOLLOWED BY A SPACE
	PJRST	OUTLOG		;OUT SPACE AND RETURN

LOGTIM:	MOVE	T3,T1		;ARGUMENT INTO T3
	IDIVI	T3,^D10		;SPLIT INTO T3 AND T4
LOGTM1:	CAILE	T3,^D9		;WAS IT 3 DIGITS?
	JRST	GOT3		;YES, PROCESS SEPARETELY
LOGTM2:	ADDI	T3,"0"		;MAKE DIGIT ASCII
	MOVE	T1,T3		;PREPARE FOR OUTPUT
	PUSHJ	P,OUTLOG	;OUT THE DIGIT
	ADDI	T4,"0"		;MAKE ASCII
	MOVE	T1,T4		;READY FOR OUTPUT
	PJRST	OUTLOG		;DO IT AND RETURN

GOT3:	MOVE	T2,T3		;FURTHER BREAK OF DIGIT
	IDIVI	T2,^D10		; INTO T2-T3-AND T4
	CAILE	T2,^D9
	JRST	GOT4
GOT3A:	ADDI	T2,"0"		;TO OUTPUT T2
	MOVE	T1,T2		;OUT T2 FIRST
	PUSHJ	P,OUTLOG
	JRST	LOGTM1		;RETURN TO OUT ALL OF DIGITS

GOT4:	MOVE	T1,T2
	IDIVI	T1,^D10
	ADDI	T1,"0"
	PUSHJ	P,OUTLOG
	JRST	GOT3A

;ROUTINE TO OUTPUT ".ASSIGN DSK QUE" AS FIRST COMMAND IN
; FILE.CTL WHEN CDRSTK USER IS OTHER THAN SYSTEM OPERATOR


STCTL:	MOVE	T2,[ASCII /.ASSI/]
	PUSHJ	P,SET5		;OUTPUT TO FILE.CTL
	MOVE	T2,[ASCII /GN DS/]
	PUSHJ	P,SET5		;OUT TO FILE.CTL
	MOVE	T2,[ASCII /K QUE/]
	PUSHJ	P,SET5		;OUT TO FILE.CTL
	PUSHJ	P,TABCTL	;OUT A TAB TO FILE.CTL
	PUSHJ	P,TABCTL
	PJRST	CDRMAD		;END LINE AND RETURN TO CALLER


;HERE WHEN AN EOF HAS BEEN DETECTED IN THE INPUT DECK


CDREOF:	MOVE	T1,SCORE	;RETRIEVE CARD ORDER COUNT
	SKIPE	T2,ERRFIL	;GET HERE WITH AN ERROR FILE??
	JRST	RELFIL		;YES, GO CLEAN UP
	CAIGE	T1,2		;LEGALLY ACTIVE JOB??
	  JRST	ENDING		;ONLY ONE EOF PER JOB
	SETZM	SCORE
	TRZ	F,MESGOK+STAR
	TLZ	F,BINARY+IMAGE+SIXFL+NINEFL
	TRNE	F,FATSEE	;FATAL ERROR DETECTED ON THIS CARD
	POPJ	P,		;YES, GET NEXT CARD
	PUSHJ	P,TIME1		;TIMESTAMP FOR LOG FILE
	MOVE	T2,[ASCII /STSUM/]
	PUSHJ	P,OUTLO5	;OUTPUT LINE HEADER
	PUSHJ	P,OUTTAB	;OUTPUT A TAB TO LOG FILE
	MOVEI	T4,^D18
	MOVEI	M,1		;NO <CR><LF> YET
	MOVE	T2,[POINT 7,ENDMS1]
	PUSHJ	P,LOGCR1	;OUTPUT MESSAGE.TEXT
	MOVE	T1,CRDCNT	;RETRIEVE CARD COUNT
	PUSHJ	P,LOGTIM	;AND OUTPUT IT IN DECIMAL
	MOVEI	T1,SPACE	;SEPARATE OUTPUT
	PUSHJ	P,OUTLOG
	MOVE	T2,[ASCII /CARDS/]
	PUSHJ	P,OUTLO5	;OUTPUT "CARDS"
	SETZM	CRDCNT		;ZERO CARD COUNTER
	MOVEI	T1,COMMA	;OUT COMMA IN TEXT
	PUSHJ	P,OUTLOG	; TO FILE.LOG
	MOVEI	T1,SPACE	;FOLLOWED BY A SPACE
	PUSHJ	P,OUTLOG
	MOVE	T1,DECKNO	;RETRIEVE NUMBER OF DECKS
	PUSHJ	P,LOGTIM	;OUTPUT AS DECIMAL NUMBER
	MOVEI	T1,SPACE	;FOLLOWED BY A SPACE
	PUSHJ	P,OUTLOG
	MOVE	T2,[ASCII /FILES/]
	PUSHJ	P,OUTLO5	;AND THE WORD "FILES"
	MOVEI	T1,","		;DELIMIT FILES FROM BLKS
	PUSHJ	P,OUTLOG	;WITH A COMMA
	MOVEI	T1,SPACE	;AND A SPACE
	PUSHJ	P,OUTLOG	;BEFORE THE #OF BLOCKS
	MOVE	T1,BLKCNT	;RETRIEVE NUMBER OF BLOCKS
	PUSHJ	P,LOGTIM	;OUTPUT AS A DECIMAL NUMBER
	MOVEI	T1,SPACE	;FOLLOWED BY A SPACE
	PUSHJ	P,OUTLOG	;BEFORE "BLKS"
	MOVE	T2,[ASCII /BLKS /]
	PUSHJ	P,OUTLO5	;OUTPUT "BLKS"
	SETZM	BLKCNT		;FOR NEXT TRIP
	PUSHJ	P,OUTLIN	; FOLLOWED BY <CR><LF>
	SETZM	DECKNO		;ZERO DECK NUMBER
	SKIPN	T1,HOLLER	;ANY HOLLERITH ERRORS?
	JRST	DUMP		;NONE TO REPORT
	PUSHJ	P,OUTTAB	;OUT A TAB
	PUSHJ	P,OUTTAB	;AND ANOTHER TAB
	MOVE	T1,HOLLER	;HOW MANY ERRORS(HOLLERITH)?
	PUSHJ	P,LOGTIM	;OUTPUT A DECIMAL NUMBER
	MOVEI	T1,SPACE	;FOLLOWED BY A SPACE
	PUSHJ	P,OUTLOG	;OUT SPACE TO FILE.LOG
	MOVEI	T4,^D18		;AND MESSAGE TEXT
	MOVE	T2,[POINT 7,ENDMS2]
	PUSHJ	P,LOGCR1	;OUTPUT MESSAGE TEXT
	SETZM	HOLLER		;HOUSEKEEP ERROR COUNTER

;SUBROUTINE TO SET UP "%ERR:.DUMP ----" IF $DUMP CARD USED

DUMP:	MOVEI	T4,20		;LENGTH OF A DUMP CARD
	MOVE	T3,QUECTL	;WHERE $DUMP CARD SAVED
	CAIN	T3,0		;DID USER WANT DUMP?
	JRST	CRFFIL		;NO, MAKE CREF REQUEST??
DUMPA:	MOVE	T1,QUECTL(T4)	;GET CARD IMAGE INTO T1
	MOVEM	T1,CARDB(T4)	;AND MOVE TO CARD BUFFER
	SETZM	QUECTL(T4)	;CLEAN UP AFTER USE
	SOJGE	T4,DUMPA	;GET IT ALL
	MOVE	T2,[ASCII /%ERR:/]
	PUSHJ	P,SET5		;OUT THE LINE HEADER
	PUSHJ	P,CTLOUT	;FOLLOWED BY .DUMP COMMAND

;SUBROUTINE TO SET UP "%FIN:.CREF" IF /CREF SEEN

CRFFIL:	TLZN	F,CREFSP	;/CREF DETECTED??
	JRST	FILDEL		;NO, GO TO DELETE FILES
	MOVE	T2,[ASCII /%FIN:/]
	PUSHJ	P,SET5		;GO TO SET-UP COMMAND STRING
	MOVE	T2,[ASCII /.CREF/]
	PUSHJ	P,SET5
	PUSHJ	P,TABCTL	;TAB OVER FOR COMMENT
	PUSHJ	P,TABCTL	;TWICE
	PUSHJ	P,CDRMAD	;TAG LINE OF OUTPUT
				;AND FALL THROUGH TO DELETE FILES


;SUBROUTINES TO EMPTY FILE LISTS AND SET UP
; COMMANDS FOR DELETION OF THESE FILES

FILDEL:	TRZ	F,CARDER	;INSURE NO ERR MESSAGES TO FILE.CTL AFTER FILE CLOSED
	SETZ	G1,		;FOR TEMPORARY USE
	HRR	G1,FILCNT	;RETRIEVE FILE COUNT
	CAIG	G1,0		;IS IT OVER ZERO?
	JRST	SAVDEL		;NO, BYPASS
	MOVE	T2,[ASCII /%FIN:/]
	PUSHJ	P,SET5		;TO DELETE CREATED FILES
	MOVE	T2,[ASCII /.DEL /]
	PUSHJ	P,SET5		;THAT ARE OF NO USE AFTER BATCH
	MOVEI	P1,5		;FILES TO FOLLOW ON THIS LINE
	MOVE	G1,FILCNT	;HOW MANY FILES??
	TLZ	G1,SHORT	;CLEAR REUSE BIT
	MOVEM	G1,FILCNT	;AND REPLACE PROPER VALUE
	CAIG	G1,0		;ANY FILES TO DELETE?
	JRST	DELQUE		;NO, GO SEE IF ANY .CDR FILES
	SETZ	G2,		;INITIALIZE COUNTER
	JRST	FILD1A		;GO PICK UP FIRST FILE NAME
FILDE1:	MOVEI	T1,","		;GET A COMMA
	PUSHJ	P,OUTCTL	;OUT IN COMMAND STRING
FILD1A:	MOVE	T3,BUFLOG(G2)	;GET DEVICE NAME IF ANY SPECIFIED
	CAIN	T3,0		;WAS THERE ANY??
	JRST	FILDE2		;NO, GO GET FILENAME
	MOVE	T2,T3		;COPY SIXBIT DEVICE NAME
	DEVCHR	T2,		;GET DEVICE CHARACTERISTICS
	TLNN	T2,4		;DIRECTORY DEVICE??
	JRST	FILDE2		;NO, GO GET FILENAME
	PUSHJ	P,NAMOUT	;OUTPUT TO COMMAND STRING
	MOVEI	T1,":"		;FOLLOWED BY DELIMETER
	PUSHJ	P,OUTCTL	;OUTPUT TO COMMAND STRING
FILDE2:	ADDI	G2,1		;UPDATE COUNTER
	MOVE	T3,BUFLOG(G2)	;GET FILE NAME
	CAIN	T3,0		;ANY FILENAME SPECIFIED?
	JRST	FILD2A		;NO, GO SEE WHERE WE ARE
	PUSHJ	P,NAMOUT	;OUTPUT FILENAME
	ADDI	G2,1		;UPDATE COUNTER
	MOVE	T3,[SIXBIT /.REL/]
	PUSHJ	P,NAMOUT	;OUTPUT EXTENSION--.REL
FILD2A:	CAML	G2,FILCNT	;DONE YET??
	JRST	DELQUE		;YES, GO CHECK .CDR FILES
	SOJG	P1,FILDE1	;RETURN FOR COMMA IF LINE NOT FULL
FILDE3:	PUSHJ	P,RELINE	;MAKE A NEW LINE
	JRST	FILD1A		;AND RETURN FOR NEXT FILE
DELQUE:	MOVE	G1,QXXFIL	;GET COUNT
	CAIG	G1,0		;WERE THERE ANY .CDR FILES
	JRST	DELFOR		;NO, GO CHECK FORTRAN
DELQU1:	MOVEI	T1,","		;DELIMIT FILES
	PUSHJ	P,OUTCTL	;TO FILE.CTL
DELQU2:	MOVE	T3,QXXFIL(G1)
	SETZM	QXXFIL(T1)
	PUSHJ	P,NAMOUT
	MOVE	T3,[SIXBIT /.CDR/]
	PUSHJ	P,NAMOUT
	SOJE	G1,DELFOR
	SOJG	P1,DELQU1
	PUSHJ	P,RELINE
	JRST	DELQU2

DELFOR:	MOVE	G1,FORFIL	;GET NUMBER OF FORTRAN FILES
	CAIG	G1,0		;WERE THERE ANY CREATED THIS JOB?
	JRST	DELCOB		;NO, GO CHECK COBOL
DELFR1:	MOVEI	T1,","		;OUTPUT A COMMA TO COMMAND STRING
	PUSHJ	P,OUTCTL	;AFTER LAST FILE NAME
DELFR2:	MOVE	T3,FORFIL(G1)	;GET A FILENAME FROM LIST
	SETZM	FORFIL(G1)	;SCRATCH OFF LIST
	PUSHJ	P,NAMOUT	;OUTPUT THE FILENAME
	MOVE	T3,[SIXBIT /.F4/]
	PUSHJ	P,NAMOUT	;FOLLOWED BY EXTENSION
	SOJE	G1,DELCOB	;ANY FILES REMAINING??
	SOJG	P1,DELFR1	;YES, ANY ROOM LEFT ON LINE?
	PUSHJ	P,RELINE	;NO ROOM, GET NEXT LINE
	JRST	DELFR2		;AND GET NEXT FILENAME FROM LIST

DELCOB:	MOVE	G1,COBFIL	;GET COUNT OF COBOL FILES
	CAIG	G1,0		;WERE THERE ANY?
	JRST	DELMAC		;NO, GO CHECK MACRO FILES
DELCB1:	MOVEI	T1,","		;PUT OUT A COMMA
	PUSHJ	P,OUTCTL	;IN COMMAND STRING
DELCB2:	MOVE	T3,COBFIL(G1)	;GET A FILENAME OFF LIST
	SETZM	COBFIL(G1)	;SCRATCH FROM LIST
	PUSHJ	P,NAMOUT	;OUTPUT NAME TO FILE.CTL
	MOVE	T3,[SIXBIT /.CBL/]
	PUSHJ	P,NAMOUT	;FOLLOWED BY EXTENSION
	SOJE	G1,DELMAC	;ANY MORE FILES TO DELETE?
	SOJG	P1,DELCB1	;ANY MORE ROOM ON THIS LINE?
	PUSHJ	P,RELINE	;NO ROOM, GET A NEW LINE
	JRST	DELCB2		;AND GO GET NEXT FILE
DELMAC:	MOVE	G1,MACFIL	;GET MACRO FILE COUNT
	CAIG	G1,0		;ARE THERE ANY FILES TO DELETE?
	JRST	DELALG		;NO, GO CHECK ALGOL
DELMC1:	MOVEI	T1,","		;GET A COMMA
	PUSHJ	P,OUTCTL	;INTO COMMAND STRING
DELMC2:	MOVE	T3,MACFIL(G1)	;GET A FILENAME FROM LIST
	SETZM	MACFIL(G1)	;SCRATCH OFF OF LIST
	PUSHJ	P,NAMOUT	;OUTPUT FILENAME TO COMMAND
	MOVE	T3,[SIXBIT /.MAC/]
	PUSHJ	P,NAMOUT	;FOLLOWED BY EXTENSION OF .MAC
	SOJE	G1,DELALG	;ANY FILENAMES LEFT ON LIST?
	SOJG	P1,DELMC1	;ANY ROOM LEFT ON THIS LINE?
	PUSHJ	P,RELINE	;NO ROOM, GET A NEW LINE
	JRST	DELMC2		;GET THE NEXT FILE NAME IN LIST

DELALG:	MOVE	G1,ALGFIL	;GET COUNT OF ALGOL FILES ON LIST
	CAIG	G1,0		;WERE THERE ANY LISTED?
	JRST	SAVDE1		;NO, GO DISPOSE OF FILE.CTL
DELAG1:	MOVEI	T1,","		;GET A COMMA DELIMETER
	PUSHJ	P,OUTCTL	;INTO OUTPUT COMMAND STRING
DELAG2:	MOVE	T3,ALGFIL(G1)	;GET A FILE NAME FROM LIST
	SETZM	ALGFIL(G1)	;SCRATCH NAME FROM LIST
	PUSHJ	P,NAMOUT	;PUT FILE NAME INTO COMMAND STRING
	MOVE	T3,[SIXBIT /.ALG/]
	PUSHJ	P,NAMOUT	;FOLLOWED BY EXTENSION OF .ALG
	SOJE	G1,SAVDE1	;ANY OF THESE FILES REMAINING?
	SOJG	P1,DELAG1	;YES, AND ANY ROOM LEFT ON LINE?
	PUSHJ	P,RELINE	;NO ROOM, GET A NEW LINE STARTED
	JRST	DELAG2		;AND GO GET NEXT NAME ON LIST

RELINE:	PUSHJ	P,CDRMAD	;END THIS LINE OUTPUT TO FILE.CTL
	MOVE	T2,[ASCII /%FIN:/]
	PUSHJ	P,SET5		;START LINE WITH "%FIN:"
	MOVE	T2,[ASCII /.DEL /]
	PUSHJ	P,SET5		;           ".DEL"
	MOVEI	P1,5		;RESET FILES PER LINE COUNTER
	POPJ	P,		;AND RETURN FOR MORE
SAVDE1:	PUSHJ	P,ENDINP	;START A NEW LINE OF OUTPUT
SAVDEL:	SETZM	FILBAS		;TO CLEAR UP FILE NAME LIST
	MOVE	T1,[XWD FILBAS,BUFLOG]
	BLT	T1,HOURS
RELFIL:	RELEASE	DSK,		;CLOSE FILE.CTL AND RELEASE CHANNEL
	RELEASE	DSK1,		;CLOSE FILE.LOG """""""""""
	TLZE	F,DECK		;IS IT ALREADY RELEASED?
	PUSHJ	P,EODCR1	;GO CLEAR OUT THIS FILE FIRST
	RELEASE DSK3,
	RELEASE	UFD,
	SKIPE	T1,ERRFIL	;ERROR FILE CREATED??
	JRST	QUEUP+1		;YES, GO QUEUE IT UP FOR LISTING
	TRZ	F,OKAY
	TRZN	F,FATAL
	JRST	QUEUP
	HRLZI	T1,40000
	MOVEM	T1,DEPSAV
QUEUP:	TLZN	F,NOQUE		;?MAKE QUEUE ENTRY FOR USER?
	PUSHJ	P,OUTQUE	;YES, GO MAKE QUEUE ENTRY
	SETZM	OLNAME		;GOOD-BY FILE
	SETZM	SEQSAV		; AND SEQUENCE NUMBER
ENDING:	SETZM	SCORE		;FOR INSURANCE
	JRST	ENDFIL
SUBTTL	CARD SORT ROUTINE

;HERE TO DISPATCH CONTROL CARDS OR STORE CARDS IN THEIR
; APPROPRIATE FILES DEPENDING ON THE CONTENTS OF CARD COLUMN
; #1 IN THE CASE OF "$" CARDS OR THE EXISTENCE
; OF AN OPEN DISK FILE


CONTRO:	PUSHJ	P,GETSIX	;GET THE CONTROL CARD NAME
	CAIN	C,"$"		;"$$" CARD??
	JRST	CTLOUT		;AND OUT CARD IMAGE TO FILE.CTL
	TLNE	F,DOLLAR	;OUT TO OPR??
	OUTSTR	CARDB		;YES, DO IT
	MOVSI	T4,-NOCDS	;NUMBER OF TABLE ENTRIES
MATCH1:	HLLZ	T2,T1
	XOR	T2,CRD(T4)	;USE THE FIRST THREE CHARACTERS
	TLNN	T2,777777	;MATCH ??
	JRST	(T2)		;GO TO PROCESS THE CARD
	AOBJN	T4,MATCH1
CRDBAD:	TRO	F,FATAL		;SET FATAL ERROR FLAG
	TRNN	F,STAR		;ATTEMPT TO OUTPUT??
	JRST	CDERR3		;NO, DON'T BOTHER
	TLNE	F,BINARY	;THIS A BINARY CARD??
	JRST	CDERR		;YES, DON'T ATTEMPT OUTPUT
	TLNE	F,DECK		;BAD DECK CARD
	PUSHJ	P,CDRMAD	;YES, END FILE.CTL LINE
	TLNN	F,EACH		;OPERATOR WANT TO SEE EACH FATAL
	TLZE	F,FIRST		;SHOULD FIRST FATAL BE OUTPUT?
	OUTSTR	CARDB		;YES, GIVE IT TO OPERATOR
CDERR:	PUSHJ	P,TIME1		;START LOGFILE LINE WITH TIME
	MOVE	T2,[ASCII /STERR/]	;LINE TITLE
	PUSHJ	P,OUTLO5	;OUTPUT PART OF LINE
	PUSHJ	P,OUTTAB
	MOVE	T2,[ASCII /CARD#/]
	PUSHJ	P,OUTLO5	;OUTPUT TEXT
	MOVE	T1,CRDCNT	;CARD NUMBER==CRDCNT
	PUSHJ	P,LOGTIM	;OUTPUT AS DECIMAL
	PUSHJ	P,OUTTAB
	TRNN	F,FATAL		;GET HERE WITH FATAL ERROR
	JRST	CDERR1		;NO, GO AROUND
	TRO	F,FATSEE	;FATAL ERROR SEEN, REMEMBER
	MOVE	T2,[ASCII /FATAL/]
	PUSHJ	P,OUTLO5	;START MESSAGE OUT
	MOVE	T2,[ASCII / CARD/]
	PUSHJ	P,OUTLO5
	JRST	CDERR2
CDERR1:	MOVE	T2,[ASCII /COL#/]
	PUSHJ	P,OUTLO5	;OUTPUT TEXT
	MOVE	T1,COLERR	;RETRIEVE COLUMN LOCATION
	PUSHJ	P,LOGTIM	;OUTPUT AS DECIMAL
CDERR2:	PUSHJ	P,OUTTAB	;TAB OVER FOR FILENAME
	MOVE	T2,[ASCII /FILE-/]
	PUSHJ	P,OUTLO5
	MOVE	T1,FILCNT	;GET PRESENT FILE INDEX
	MOVE	T2,FILBAS(T1)	;GET PRESENT FILE NAME
	CAIN	T2,0		;WAS THERE ANY??
	MOVE	T2,OLNAME	;NO, DEFAULT TO JOB NAME
	TLNN	F,DECK		;UNDER A $LANG OR $DECK??
	MOVE	T2,OLNAME	;NO, IN MAIN JOB
	MOVE	T3,[POINT 6,T2]
	MOVEI	T4,6		;CHARACTERS
CDFILR:	ILDB	T1,T3		;GET ONE CHARACTER
	ADDI	T1,SPACE	;MAKE IT ASCII
	PUSHJ	P,OUTLOG	;SEND IT ON ITS WAY
	SOJG	T4,CDFILR	;TO GET WHOLE NAME
	PUSHJ	P,OUTLIN	;TERMINATE THIS LINE OUT
	TLNE	F,BINARY	; IS THIS A BINARY CARD??
	JRST	CDERR3		;YES, DON'T ATTEMPT OUTPUT
	PUSHJ	P,OUTTAB	;TAB OVER ON NEXT LINE
	PUSHJ	P,OUTTAB
	SETZ	M,
	PUSHJ	P,LOGCRA	;OUTPUT CARD IMAGE
CDERR4:
	TRZE	F,CARDER	;HERE VIA HOLLERITH ERROR?
	POPJ	P,		;YES, RETURN
	TRNE	F,FATAL		;GET HERE VIA FATAL ERROR
	PUSHJ	P,CDREOF	;YES, END JOB HERE
CDERR3:	TRZ	F,FATAL		;TO KEEP CARDS ROLLING
	POPJ	P,		;RETURN TO NEXT CARD


CRD:
	<SIXBIT /ALG/>+ALGCRD
	<SIXBIT /COB/>+COBCRD
	<SIXBIT /DAT/>+DATCRD
	<SIXBIT /DEC/>+DECCRD
	<SIXBIT /DUM/>+DUMCRD
	<SIXBIT /EOD/>+EODCRD
	<SIXBIT /ERR/>+BERROR
	<SIXBIT /FOR/>+FORCRD
	<SIXBIT /F4/>+FORCRD
	<SIXBIT /F40/>+FORCRD
	<SIXBIT /JOB/>+JOBCRD
	<SIXBIT /MAC/>+MACCRD
	<SIXBIT /MOD/>+MODCRD
	<SIXBIT /NOE/>+NERROR
	<SIXBIT /PAS/>+PASCRD
	<SIXBIT /REL/>+RELCRD
	<SIXBIT /SEQ/>+SEQCRD
	<SIXBIT /STP/>+STPCRD
NOCDS=.-CRD
SUBTTL	$JOB AND $PASSWORD CARD PROCESSING

;$JOB CARD PROCESSING


JOBCRD:	TLNE	F,JOBS		;OUT TO OPERATOR??
	OUTSTR	CARDB		;YES, DO IT
	TRZ	F,EODERR	;ZERO EOD MISSING FLAG
	MOVE	T1,SCORE	;CHECK CARD ORDER
	PUSH	P,P1		;SAVE CARD CHARACTER POINTER
	CAILE	T1,1		;EOD AND OR SEQUENCE?
	PUSHJ	P,DECERR	;NEITHER
	POP	P,P1		;RETRIEVE CARD CHARACTER POINTER
	MOVEI	T1,2		;$JOB SETS SCORE==2
	MOVEM	T1,SCORE	;RESET SCORE
	MOVE	T4,SEQSAV	;HOLD ONTO SEQUENCE NUMBER
	SETZM	LOCSAV		;TO INITIALIZE STORED INFORMATION
	MOVE	T1,[XWD LOCSAV,LOCSAV+1]
	BLT	T1,QUEC31	;FROM QBLANK TO QUEC31
	MOVEM	T4,SEQSAV	;KEEP SEQUENCE NUMBER
	MOVE	T1,[XWD DEFPAG,0]
	MOVEM	T1,PAGCAR	;PAGES,,CARDS
	MOVE	T1,[XWD DEFCOR,DEFTIM]
	MOVEM	T1,CORTIM	;CORE,,TIME
	HRLZI	T1,200000	;SO THAT ONLY ONE JOB RUNS AT
	MOVEM	T1,DEPSAV	; ANY ONE TIME
	MOVE	T1,FAKOUT	;TO USE AS DEFAULT
	MOVEM	T1,NEW		;FOR NON-SPECIFIC $JOB
	AOS	T1,DECKNO	;TO COUNT FILE.LOG AND FILE.CTL
	AOS	T1,DECKNO	;UPDATE AND SAVE DECK NUMBER
JOBCD2:	PUSHJ	P,GETSIX	;GET CARD INFORMATION
	CAIE	C,SPACE		;DELIMETER==SPACE??
	JRST	JOBCD1		;NO, GO PROCESS
	CAIN	T1,0		; C==SPACE, AND T1==0 ??
	JRST	JOBCD2		;YES, GET NEXT "SIX"
JOBCD1:	CAIE	C,")"		;GOT PROJECT #?
	CAIN	C,"["		;IN EITHER 026 OR 029
	JRST	GOTPRJ		;YES, USE DEFAULT NAME
	CAIN	C,"/"		;SWITCHES ONLY
	JRST	LOOK1		;GO STRAIGHT DEFAULT ROUTE
	MOVEM	T1,NEW		;READY JOB NAME FOR ENTER
JOBCR1:	PUSHJ	P,GETONE	;LOOK FOR DELIMETERS
	CAIN	C,"-"		;CONTINUATION REQUEST
	TRO	F,CONTIN	;SET CONTINUATION FLAG
	CAIE	C,")"		;026 MODE==="["
	CAIN	C,"["		;GOT PROJ NO NOW
	JRST	GOTPRJ		;YES--GO SAVE IT
	CAIN	C,"/"		;SWITCH SPECIFICATION
	JRST	LOOK1		;YES--PREPARE TO PROCESS IT
	CAIE	C,CR		;END OF CARD
	CAIN	C,LF		; DETECTED YET??
	JRST	LOOK1		;YES--INIT AND GOTO NXT CARD
	JRST	JOBCR1		;NO--CARRY ON WITH THIS CARD
GOTPRJ:	CAIE	T1,0		;NO SPACE OR COMMA??
	MOVEM	T1,NEW
	MOVEI	T4,6		;SIX CHARACTERS AT MOST
	SETZB	T1,FILCNT	;START FRESH
GETPRJ:	PUSHJ	P,GETONE	;GET A DIGIT
	CAIN	C,SPACE		;SPACES LOOK FUNNY AS PROJ NOS.
	JRST	GETPRJ		;SO, FLUSH THEM HERE
	CAIE	C,"/"		;PROJECT NUMBER TERMINATOR DETECTED?
	CAIN	C,","		;END OF PROJECT NUMBER YET?
	JRST	GOTPRO		;YES, GO GET PROGRAM NUMBER
	CAIN	C,"("		;EQ. "]" IN 026 MODE
	JRST	WILDPR		;A WILD PROGRAMMER IS LOOSE
	CAIE	C,"]"		;DEFAULT PROGRAMMER NUMBER??
	  JRST	GETPR1		;NO, GO NORMAL ROUTE
WILDPR:	HRLM	T1,NEWPPN	;GET PROJECT NUMBER STORED
	MOVEI	T1,-2		;FOR PROGRAMMER NUMBER
	JRST	LOADEM		;GO FIX UP DUMMY PPN
GETPR1:
	CAIL	C,60
	CAILE	C,67
	  JRST	DELBAD
	SUBI	C,60		;GET DIGIT
	LSH	T1,3		;SHIFT TO ACCOMODATE NEXT DIGIT
	ADD	T1,C		;ADD NEXT DIGIT
	SOJGE	T4,GETPRJ	;RETURN FOR NEXT CHARACTER
GOTPRO:	HRLM	T1,NEWPPN	;SAVE PROJECT NUMBER
	MOVEI	T4,6		;SIX CHARACTERS AT MOST
	SETZ	T1,		;CLEAR T1
GETPRO:	PUSHJ	P,GETONE	;GET A DIGIT
	CAIE	C,"#"		;IS THIS A WILD PROGRAMMER REQUEST
	CAIN	C,SPACE		;FLUSH SPACES HERE
	JRST	GETPRO
	CAIN	C,"\"		;D029
	JRST	LOADEM		;******WATCH OUT FOR ERROR PROBLEMS
	CAIE	C,"("		;HE FORGOT /026
	CAIN	C,"]"		;END OF PROJECT PROG PAIR?
	JRST	LOADEM		;YES, LOAD THEM
	CAIL	C,60
	CAILE	C,67
	  JRST	DELBAD
	SUBI	C,60		;GET DIGIT
	LSH	T1,3
	ADD	T1,C
	SOJGE	T4,GETPRO	;RETURN FOR CHARACTER
LOADEM:	CAIN	T1,0		;DESIRING DEFAULT OF -2??
	MOVEI	T1,-2		;YES, GIVE IT TO HIM
	HRRM	T1,NEWPPN	;STORE PROG NUMBER
	MOVE	T1,NEWPPN	;RETRIEVE PROJ,,PROG
	MOVEM	T1,PPNS		;SAVE TO USE FOR ENTER
	JRST	JOBCR1		;RETURN FOR REST OF CARD

LOOK1:	SKIPE	PPNS
	JRST	LOOK2		;P#,P# SPECIFIED
LOKBAD:	OUTSTR	[ASCIZ/
?INVALID PROJ,,PROG PAIR SPECIFIED
/]
	TLNN	F,EACH		;OPERATOR WANT TO SEE EACH FATAL
	TLNE	F,FIRST		;OPER WANT TO SEE FATAL CARD?
LOKBD1:	OUTSTR	CARDB
	TLO	F,NOQUE		;NO QUEUE ENTRY FOR THIS FILE
	SETZM	SCORE
	POPJ	P,		;RETURN FOR NEXT CARD

DELBAD:	OUTSTR	[ASCIZ/
?UNKNOWN DELIMITER "/]
	OUTCHR	C
	OUTSTR	[ASCIZ/" IN PROJECT,,PROGRAMMER PAIR
/]
	JRST	LOKBD1

LOOK2:	MOVE	T1,RUNNER	;WHO IS RUNNING THIS JOB?
	TLNN	T1,777776	;IS THIS PROJECT #1??
	JRST	LOOK3		;YES, IT'S O.K.
	CAMN	T1,NEWPPN	;USER IN OWN AREA??
	JRST	LOOK3		;O.K. FOR THIS USER
	MOVEI	T2,TTY		;GET DEVICE "TTY" CHANNEL NUMBER
	WHERE	T2,		;DO A WHERE ON THIS GUY
	JRST	LOKBAD		;UUO LOSES
	HRLZ	T2,T2		;GET STATION NUMBER
	ADD	T2,[XWD 100,2]	;PLUS PPN FUDGE FACTOR
	CAME	T1,T2		;ARE THEY EQUAL?
	  JRST	LOKBAD		; NO, BAD USER
LOOK3:	MOVEI	T4,20		;COUNTER TO SAVE $JOB CARD
BUFFIL:	MOVE	T1,CARDB(T4)	;IN BUFLOG
	MOVEM	T1,QUECTL(T4)	;UNTIL AFTER $PASSWORD
	SOJGE	T4,BUFFIL
	MOVEM	P1,QUECTL+22	;SAVE BYTE POINTER
	MOVEM	C,QUECTL+23	;AND LAST CHARACTER DETECTED
	IFN	CODEWD,<
	JRST	BUFFLA
>
	MOVE	T2,RUNNER	;WHO IS RUNNING THIS JOB??
	CAME	T2,NEWPPN	;RUNNING OWN JOB??
	JRST	PASCR1		;GO THROUGH ACCT.SYS FOR THIS GUY
BUFFLA:	SETO	T1,
BUFFLB:	SETZ	T3,
	MOVE	T4,[XWD 3,T1]
	JOBSTR	T4,
	  JRST	BUFFLD		;NON-EXISTANT UUO
	TLNE	T3,OKAY		;WILL THIS STRUCTURE WIN??
	  JRST	BUFFLB		;NO, KEEP LOOKING FOR WINNER
BUFFLC:	CAIE	T1,0
	CAMN	T1,[XWD -1,-1]
BUFFLD:	MOVSI	T1,(SIXBIT /DSK/)
	MOVEM	T1,OUDEV
	MOVEM	T1,LOGOUT+1
	MOVEM	T1,CAROUT+1
	PJRST	ACC1JA		;O.K. FOR THIS USER

PASCR1:	IFE	CODEWD,<
	MOVE	T1,RUNNER	;WHO'S RUNNING THIS JOB??
	CAMN	T1,NEWPPN	;RUNNING OWN JOB?
	JRST	ACC1JA		;YES, GO AROUND ACCT STUFF
	MOVEI	T2,TTY		;GET TTY DEVICE CHANNEL NUMBER
	WHERE	T2,		;GET STATION NUMBER
	JRST	PASCR2		;NON UUO
	HRLZ	T2,T2		;GET STATION NUM INTO LH
	ADD	T2,[XWD 100,2]	;ADD FUDGE FACTOR
	CAMN	T1,T2		;IS THIS THE GUY
	JRST	PASCR3		;YES, HE'S A REMOTE 1,,2
PASCR2:	TLNE	T1,777776	;IS THIS PROJECT 1
>
	JRST	ACC1JA		;NO-DON'T TRY LOOKUP IN ACCT.SYS
PASCR3:	TRZ	F,FRSTWD	;INITIALIZE FLAG FOR ACCT.SYS
	HRRI	T1,17		;TO OPEN IN DUMP MODE
	MOVSI	T2,(SIXBIT /SYS/)
	SETZB	T3,RDHED
	open	dsk3,t1
	  JRST	NOACCT		;OUTPUT ERROR MESSAGE
	MOVE	T1,[SIXBIT /ACCT/]
	MOVSI	T2,(SIXBIT /SYS/)
	setz	t3,
	MOVSI	T4,(SIXBIT /SYS/)
	DEVPPN	T4,		;WHO OWNS SYS?
	  MOVE	T4,[XWD 1,1]	;DEFAULT
	LOOKUP	DSK3,T1
	  JRST	NOACCT		;CAN'T FIND ACCT.SYS
	HLRE	T1,T4		;SAVE LENGTH OF ACCT.SYS
	JUMPGE	T1,.+3		;BLOCKS IF POSITIVE
	SUBI	T1,^D127	;COUNT 1 FOR LAST PARTIAL BLOCK
	idiv	t1,[-^d128]	;convert words to blocks
	MOVEM	T1,ACTBLK	;SAVE BLOCKS
	MOVEM	T1,HIGHSL	;SAVE AS UPPER BARRIER FOR SEARCH
	SETZB	T2,ACOUNT	;READ ON ACCT.SYS BLOCKS
	MOVEI	M,105		;INSURE COUNT KEPT IN ACCT.SYS


SEARCH:	MOVEI	T1,1		;SO WILL READ FIRST BLOCK
	JRST	SRREAD		;GO TO READ THE FIRST BLOCK HERE
SRLOOP:	MOVE	T1,LOWSL	;GET LOWER SEARCH LIMIT
	ADD	T1,HIGHSL	;ADD UPPER SEARCH LIMIT
	LSH	T1,-1		;AND DIVIDE BY 2
SRREAD:	USETI	DSK3,(T1)	;POINT TO BLOCK TO BE READ
	SETZM	RDHED		;FORCE A READ OF BLOCK
	PUSHJ	P,RDUFD		;GO AND READ A BLOCK
	  JRST	PPERR		;EOF DETECTED
	MOVE	M,PPNS		;GET USER SPECIFIED PPN
	MOVEI	T3,-1(T1)	;GET CURRENT BLOCK NUMBER-1
	ASH	T3,7		;MULTIPLY BY BLOCK SIZE OF 128
	SUBI	T3,1		;SUBTRACT LENGTH OF FILE DESCRIPTOR
	MOVE	T4,ENTSIZ	;GET ENTRY LENGTH
	ADD	T3,T4		;ADD LENGTH OF ONE ENTRY
	SETZ	T2,		;CLEAR AN AC FOR DIVIDE
	DIV	T2,T4		;DIVIDE BY ENTRY LENGTH
	SUB	T4,T3		;SUBTRACT REMAINDER FROM ENTRY
	MOVEM	T4,SROFS	;SAVE OFFSET
	CAML	M,BUFLOG(T4)	;HAVE WE GONE TOO FAR??
	JRST	SRCKG		; NO, SEE IF FAR ENOUGH
	SUBI	T1,1		;YES, SET HIGH LIMIT TO
	MOVEM	T1,HIGHSL	; CURRENT -1
	CAML	T1,LOWSL	; IS HIGHER TOO LOW??
	JRST	SRLOOP		; NO, CONTINUE SEARCH
	  JRST	PPERR		;CAN'T LOCATE THIS PPN
SRCKG:	MOVE	T3,T1		;GET CURRENT BLOCK NUMBER
	ASH	T3,7		;MULTIPLY BY BLOCKSIZE OF 128
	SUBI	T3,1		;SUBTRACT LENGTH OF FORMAT DESCRIPTOR
	SETZ	T2,		;CLEAR T2 FOR DIVIDE
	DIV	T2,ENTSIZ	;DIVIDE BY ENTRY LENGTH
	MOVEI	T4,^D128	;GET BLOCK SIZE
	SUB	T4,T3		;SUBTRACT REMAINDER
	SKIPE	BUFLOG(T4)	;ZERO MEANS LAST BLOCK OF FILE
	CAMG	M,BUFLOG(T4)	;HAVE WE GONE FAR ENOUGH??
	JRST	SRFND		; YES, BLOCK IS FOUND
	ADDI	T1,1		;NO, SET LOWER LIMIT TO
	MOVEM	T1,LOWSL	; CURRENT + 1
	CAMG	T1,HIGHSL	;IS LOWER LIMIT TOO HIGH?
	JRST	SRLOOP		; NO, CONTINUE WITH SEARCH
	  JRST	PPERR		;YES, PPN NOT IN ACCT.SYS
SRFND:	MOVEM	T1,ACOUNT	;PRETEND WE READ THIS MANY
	MOVE	T2,BUFHED	;GET A FRESH POINTER
	MOVE	T1,SROFS	; RETRIEVE SEARCH OFFSET
	HRL	T1,T1		;COPY INTO LEFT HALF
	ADD	T2,T1		;UPDATE WORD POINTER
	MOVEM	T2,RDHED	;AND SAVE WORD POINTER


RDACCT:	MOVN	T1,ENTSIZ	;ENTRY SIZE AS COUNT
	HRLZS	T1		;FOR AOBJN
RDACT1:	PUSHJ	P,RDUFD		;GET A WORD
	  JRST	PPERR		;EOF DETECTED
	MOVEM	T2,CARDB(T1)	;STORE IN TEMP BLOCK
	AOBJN	T1,RDACT1	;GET REST OF ENTRY
	MOVE	T1,CARDB	;RETRIEVE P#,P#
RDACT2:	CAMLE	T1,PPNS		;PASSED IT YET?
	  JRST	PPERR		;YES, NOT THERE
	CAME	T1,PPNS		;EXACT MATCH
	  JRST	RDACCT		;NO, GO ON
	SETZM	BUFLOG		;CLEAR UP BUFFER BEFORE CONTINUING
	MOVE	T1,[XWD BUFLOG,BUFLOG+1]
	BLT	T1,BUFLOG+177	;CLEAR OUT ANY ACCT.SYS IMAGE
	HRRZ	T1,PPNS		;PLAYING WITH FUDGED NUMBERS?
	CAIE	T1,-2		; FOR PROGRAMMER NUMBER??
	JRST	RDAC2		;NOPE
	MSTIME	T1,		;GET THIS USER A PROGRAMMER NUMBER
	TRO	T1,CONTIN	;LITE THE RITE BIT
	HRRM	T1,PPNS		;FOR THIS JOB
RDAC2:
	MOVE	T1,CARDB+7	;GET ASSORTED INFO BITS
	TRNN	T1,BADUSR	;CAN USER LOG IN UNDER BATCH??
	  JRST	USRBAD		;NO, NOT THIS USER
	TRNN	T1,NAMREQ	;IS USER NAME REQUIRED?
	  JRST	RDAC2A		;NO, BYPASS NAME CHECK
	MOVE	T2,NAMSAV	;RETRIEVE NAME VALUE
	MOVE	T3,NAMSAV+1
	CAMN	T2,CARDB+3	;NAMES EQUAL??
	CAME	T3,CARDB+4
	  JRST	BADNAM		;NO--HAVE A BAD NAME
RDAC2A:	MOVE	T2,CARDB+3	;GET USER NAME FROM ACCT.SYS
	MOVEM	T2,NAMSAV
	MOVE	T2,CARDB+4
	MOVEM	T2,NAMSAV+1	;AND RETAIN IN NAMSAV FOR QUEUE
	MOVE	T2,CARDB+1	;GET ACCT.SYS PASSWORD
	MOVEM	T2,PASSWD	;SAVE THE PASSWORD FROM ACCT.SYS
	TRNN	T1,OKGUY	;IS PASSWORD REQUIRED FOR THIS GUY
	  JRST	RDACT3		;NO, LET HIM THROUGH THE GATE
	POPJ	P,		;AND RETURN FOR NEXT CARD
SUBTTL	$PASSWORD CARD PROCESSING

;$PASSWORD CARD PROCESSING

PASCRD:	IFE	CODEWD,<
	MOVE	T1,SCORE	;CHECK CARD ORDER
	CAIGE	T1,2		;SCORE SET BY $JOB CARD ?
	  JRST	CDERR4		;NO, $JOB CARD MISSING
>
PASCD1:	PUSHJ	P,ANYSIX	;GET THE PASSWORD
	CAIE	C,SPACE		;DELIMITED BY A SPACE??
	JRST	PASCD2		;NO, SHOULD BE LINE TERMINATOR
	CAIN	T1,0		;NONE DETECTED??
	JRST	PASCD1		;RETURN FOR MORE CHARACTERS
PASCD2:	CAME	T1,PASSWD	;IS PASSWORD CORRECT?
	  JRST	PPERR		;NO, GO TELL ABOUT ERROR
PASSBY:	SETZM	PASSWD		;CLEAR PASSWORD BEFORE GOING ON
	MOVE	T1,SCORE	;CHECK SCORE TO MAKE SURE
	CAIN	T1,3		; HAVEN'T BEEN THROUGH HERE BEFORE
	  POPJ	P,
	MOVEI	T1,3		;$PASS CARD SEEN SETS SCORE==3
	MOVEM	T1,SCORE	;UPDATE THE SCORE
RDACT3:	RELEASE	DSK3,		;RELEASE DEVICE SYS
AUXCHK:	HRRI	T1,17		;PREPARE TO SCAN AUXACC.SYS
	MOVSI	T2,(SIXBIT /SYS/)
	SETZB	T3,RDHED	;INITIALIZE READ HEADER
	OPEN	DSK3,T1		;IN DUMP MODE
	  JRST	NAUXAC		;NO WAY TO CHECK AUXACC.SYS
	MOVE	T1,[SIXBIT /AUXACC/]
	MOVSI	T2,(SIXBIT /SYS/)
	SETZB	T3,G4		;PREPARE FOR LOOKUP INTO AUXACC
	MOVSI	T4,(SIXBIT /SYS/)
	DEVPPN	T4,		;GET PPN FOR DEVICE SYS
	  MOVE	T4,[XWD 1,1]	;DEFAULT PPN FOR DEVICE SYS
	LOOKUP	DSK3,T1		;LOOKUP SYS:AUXACC.SYS
	  JRST	NAUXAC		;NO AUXACC.SYS
	TRO	F,FRSTWD	;DON'T DO ACCT CHECK FOR AUXACC
	PUSHJ	P,RDUFD		;GO GET CONTROL WORD
	  JRST	NOAUXA		;FIRST WORD NOT THERE
	HLRE	T1,T4		;LENGTH OF ENTRIES
	JUMPGE	T1,.+2		;IF +, NUMBER OF BLOCKS
	IDIV	T1,[-^D128]	; IF -, CONVER TO BLOCKS
	IMUL	T1,ACOUNT	;APPROXIMATE POSITION IN AUXACC
	IDIV	T1,ACTBLK	;  BASED ON POSITION IN ACCT.SYS
	SKIPN	T1		;CANNOT BE A ZERO POSITION
	MOVEI	T1,1		;SO DUMMY UP TO 1
	CAIN	T1,1		;WAS IT FIRST BLOCK?
	JRST	ACC1A		;YES, READ
	SETZM	RDHED		;NO, FORCE A READ
ACC1E:	USETI	DSK3,(T1)
ACC1A:	PUSHJ	P,RDUFD		;TRY TO FIND START OF ENTRY
	  JRST	BACKUP		;TOO FAR, BACK UP 1
	CAME	T2,[-1]		;"-1" MARKS BEGINNING OF ENTRY
	JRST	ACC1A		;RETURN TO ROLL FORWARD
	PUSHJ	P,RDUFD		;READ LENGTH OF ENTRY
	  JRST	BACKUP		;GONE TOO FAR, GO BACK 1 ENTRY
	MOVNI	G4,-1(T3)	;LENGTH OF ENTRY
	PUSHJ	P,RDUFD		;READ PPN
	  JRST	BACKUP
	CAMLE	T2,PPNS		;PASSED THIS USER YET?
	  JRST	BACKUP		;YES, BACKUP ONE
ACC1F:	CAME	T2,PPNS		;THIS USER??
	  JRST	SKACC1		;NO, READ FORWARD TO FIND
ACC1G:	IDIVI	G4,AC1BLK	;DIVIDE BY SIZE OF ENTRIES
	HRLZS	G4		; TO GET RELATIVE POSITION
	MOVEM	G4,SAVACL	;AND SAVE
	SETZB	T3,BUFLOG
	JUMPGE	G4,ACC1I
ACC1B:	PUSHJ	P,RDUFD		;TO GET WORD #3 OF AUXACC.SYS
	  JRST	ACCT		;NOT THERE, GO TO DEFAULT
	MOVEM	T2,OUDEV	;STORE PHYSICAL DEVICE NAME
	MOVEM	T2,LOGOUT+1
	MOVEM	T2,CAROUT+1
	PUSHJ	P,RDUFD		;TO READ RESERVED QUOTA
	  JRST	ACCT
	MOVEM	T2,BUFLOG+24	;SAVE FOR UFD CREATION
	PUSHJ	P,RDUFD		;TO READ FCFS QUOTA
	  JRST	ACCT
	MOVEM	T2,BUFLOG+22	;AND SAVE FOR UFD CREATE
	PUSHJ	P,RDUFD		;TO READ LOGGED-OUT QUOTA
	  JRST	ACCT		;GO THE DEFAULT ROUTE
	MOVEM	T2,BUFLOG+23	;AND SAVE FOR UFD CREATE
	PUSHJ	P,RDUFD		;TO READ STATUS BITS
	JRST	ACCT
	TLNN	T2,600000	;ABLE TO READ AND CREATE ON STR
	JRST	ACC1J		;YES, USE THIS STRUCTURE
ACC1H:	AOBJN	G4,ACC1B	;NO, AT END OF USER ENTRY
ACC1I:
ACCT:	MOVSI	T1,(SIXBIT /DSK/)
	MOVEM	T1,OUDEV	;TRY WITH DEFAULT DEVICE
	MOVEM	T1,LOGOUT+1	; OF DSK
	MOVEM	T1,CAROUT+1
	HRLOI	T1,377777
	MOVEM	T1,BUFLOG+22	;A LARGE FCFS QUOTA----DEFAULTS
	MOVEM	T1,BUFLOG+23	;A LARGE LOGGED OUT QUOTA
	MOVEM	T1,BUFLOG+24	;AND A LARGE PRESERVED QUOTA
ACC1J:	RELEASE	DSK3,

ACC1JA:	MOVEI	T1,3		;TO RESET SCORE COUNT
	MOVEM	T1,SCORE	;SO DON'T COME THIS WAY AGAIN
	MOVEI	T4,20		;TO RETRIEVE $JOB CARD
RDAC3A:	MOVE	T2,QUECTL(T4)
	MOVEM	T2,CARDB(T4)	;AND RETURN TO CARD BUFFER
	SETZM	QUECTL(T4)	;CLEAR OUT GARBAGE IN QUEUE CALL
	SOJGE	T4,RDAC3A	;RETURN TO FILL CARD BUFFER
	SETZM	BUFLOG+25	;TO CLEAR OUT OLD AUXACC.SYS
	MOVE	T1,[XWD BUFLOG+25,BUFLOG+26]
	BLT	T1,BUFLOG+177	;CLEAR OUT UNNECESSARY INFO
LOOK2A:	TRO	F,OKAY		;SET I/O OK FLAG
	TRZ	F,FRSTWD	;FINISHED WITH THIS FLAG FOR LOGIN
	PUSHJ	P,BEGIN		;START DSK I/O
	SKIPN	P1,SEQSAV	;ANY SEQUENCE NUMBER SPECIFIED?
	JRST	LOOK2C		;NONE SPECIFIED
	MOVE	T2,[ASCII /$SEQU/]
	PUSHJ	P,SET5		;OUT THESE CHARACTERS TO FILE.CTL
	MOVE	T2,[ASCII /ENCE /]
	PUSHJ	P,SET5		;OUT TO FILE.CTL
	MOVE	T1,P1		;COPY SEQUENCE NUMBER INTO T1
	SETZB	P1,T3		;INITIALIZE T3
LOOK2B:	IDIVI	T1,^D10		;BREAK TO MAKE ASCII
	ADDI	T2,"0"		;ASCII THE REMAINDER
	LSH	T3,-7		;SHIFT NUMBER RIGHT FOR NXT CHARACTER
	LSH	T2,^D29		;GET THIS DIGIT IN PLACE
	ADD	T3,T2		;PUT DIGITS TOGETHER
	SETZ	T2,		;CLEAN UP THE MESS
	CAILE	T1,^D9		;IS THAT THE END
	JRST	LOOK2B		; NO, GET NEXT DIGIT
	ADDI	T1,"0"		; YES, ASCII THIS DIGIT
	LSH	T3,-7		;PREPARE T3 TO RECEIVE
	LSH	T1,^D29		;GET LAST DIGIT IN PLACE
	ADD	T3,T1		;PUT THEM ALL TOGETHER
	MOVE	T2,T3		;PRINT FROM T2
	PUSHJ	P,SET5		;GO DO THE PRINTING
	PUSHJ	P,ENDINP	;GO END THIS LINE TO FILE.CTL
LOOK2C:	PUSHJ	P,LOGCRD	;OUTPUT $JOB CARD TO FILE.LOG
	PUSHJ	P,CTLOUT	;AND TO FILE.CTL
	TRZN	F,FRSTWD	;DID WE FUDGE THIS PPN FOR USER
	JRST	LOOK2D		;NO, HE GAVE IT HIMSELF
	MOVE	T2,[ASCII /;PPN /]
	PUSHJ	P,SET5		;TO OUT MESSAGE
	MOVE	T2,[ASCII /SET B/]
	PUSHJ	P,SET5
	MOVE	T2,[ASCII /Y CDR/]
	PUSHJ	P,SET5
	MOVE	T2,[ASCII /STK
/]
	PUSHJ	P,SET5
LOOK2D:
	MOVE	P1,QUECTL+22	;RETRIEVE $JOB CARD BYTE POINTER
	MOVE	T1,RUNNER	;WHO IS RUNNING THIS JOB?
	CAMN	T1,[XWD 1,2]
	JRST	LOOK4
	MOVSI	T1, (SIXBIT /QUE/)
	MOVE	T2,[1,,T1]
	DSKCHR	T2,
	  JRST	LOOK4		;"QUE" NOT LOGICALLY ASSIGNED
	PUSHJ	P,STCTL		;START FILE.CTL WITH
				;  ".ASSIGN DSK QUE"
LOOK4:
	SKIPE	T1,LOCSAV	;IF NQ 0, WANT TO OUTPUT
	PUSHJ	P,LOCSTA	; A ".LOCATE N" TO FILE.CTL
	MOVE	C,QUECTL+23	;RETRIEVE LAST $JOB CHARACTER
	CAIE	C,CR		;GET HERE AT END OF $JOB CARD?
	CAIN	C,LF
	POPJ	P,		;YES, GO TO NEXT CARD
	JRST	CHECK		;GO TO PROCESS SWITCH



RDUFD:	SKIPGE	T2,RDHED	;ARE WE ALREADY READING?
	JRST	RDUFD1		;YES, WAIT UNTIL FINISHED
	MOVE	T2,BUFHED	;PREPARE TO READ
	MOVEM	T2,RDHED
	SETZM	RDHED+1
	CAIE	M,0		;KEEP COUNT WHEN READING ACCT.SYS
	AOS	M,ACOUNT	;UPDATE BLOCKS READ COUNT
	INPUT	DSK3,RDHED	;INPUT ONE BLOCK
	STATZ	DSK3,760000	;ERRORS OR EOF ?
	  POPJ	P,		;YES, NOSKIP TO ERROR

RDUFD1:	AOBJN	T2,.+1		;NEXT WORD
	MOVEM	T2,RDHED
	MOVE	T2,0(T2)	;GET DATUM
	TRON	F,FRSTWD	;FIRST WORD OF FILE ?
	JRST	RDUFD2		;YES, GO MAKE SPECIAL CHECKS
	AOS	0(P)		;TAKE SKIP RETURN
	POPJ	P,

RDUFD2:	HRRZM	T2,ENTSIZ	;SAVE SIZE OF ENTRIES
	HLRZS	T2		;IN RT HALF OF T2
	CAIE	T2,ACCFOR	;ACCFOR==2
	  JRST	NOACCT		;IMPROPER ACCT.SYS
	POP	P,0(P)
	JRST	RDACCT

BACKUP:	SOJE	T1,SKACC2	;BACK UP BLOCK COUNTER
	SETZM	RDHED		;FORCE INPUT AT NEXT CALL TO READ
	JRST	ACC1E		;READ NEXT PREVIOUS BLOCK
SKACC1:	PUSHJ	P,RDUFD		;SKIP FORWARD TO USER
	  JRST	NOINAU		;EOF--NOT THERE
	CAME	T2,[-1]		;-1 MARKS BEGINNINGOF ENTRY
	JRST	SKACC1
	PUSHJ	P,RDUFD		;READ NO. OF WDS THAT FOLLOW
	  JRST	NOINAU
	MOVNI	M,-1(T2)
	PUSHJ	P,RDUFD		;READ PPN
	  JRST	NOINAU
	CAMG	T2,PPNS		;GONE PASE THIS USER?
	JRST	ACC1F		;NO, KEEP LOOKING FOR HIM
SKACC2:	HLLO	T3,PPNS
	CAMLE	T2,T3
	  JRST	NOINAU
	CAME	T2,T3
	JRST	ACC1F
	JRST	ACC1G

PPERR:	OUTSTR	[ASCIZ/
? PASSWORD IN ERROR
/]
PPERR1:	TLO	F,NOQUE		;NO QUEUE ENTRY FOR THIS USER
	TRO	F,FATAL
	TLNN	F,EACH		;WANT TO SEE EACH FATAL CARD??
	TLZE	F,FIRST		;WANT TO SEE FIRST FATAL ERROR
	OUTSTR	CARDB		;OUT THE CARD TO TTY
	SETZM	SCORE		;ZERO SCORE
	JRST	CDERR3		;GO TO ERROR PROCESSING

NOACCT:	OUTSTR	[ASCIZ/
? ACCT.SYS NOT FOUND
/]
	JRST	GETOUT		;FATAL ERROR
USRBAD:	OUTSTR	[ASCIZ/
? NOT AN AUTHORIZED BATCH USER, JOB FLUSHED
/]
	SETZM	SCORE
	JRST	PPERR1

BADNAM:	OUTSTR	[ASCIZ/
? IMPROPER USER NAME, JOB FLUSHED
/]
	SETZM	SCORE
	JRST	PPERR1

NAUXAC:	OUTSTR	[ASCIZ/
?AUXACC.SYS NOT FOUND
/]
	JRST	GETOUT		;NOTHING ELSE CAN DO

NOAUXA:	OUTSTR	[ASCIZ/
?NO AUXACC.SYS ENTRY
/]
	JRST	PPERR1

BADFOR:	OUTSTR	[ASCIZ/
?BAD FORMAT--AUXACC.SYS
/]
	JRST	GETOUT		;TO EXIT TO MONITOR

NOINAU:	OUTSTR	[ASCIZ/
?NO ENTRY IN AUXACC.SYS
/]
	JRST	PPERR1

SUBTTL	CONTROL CARD PROCESSING

;$ALGOL CARD PROCESSING


ALGCRD:	PUSHJ	P,STDECK	;INITIALIZE FILE.CTL
	MOVSI	T2,(SIXBIT /ALG/)	;ADD PROPER EXTENSION
	PUSHJ	P,LOOKEN	;DO A LOOKUP AND ENTER
	MOVE	T3,T1		;GET NAME FOR OUTPUT
	PUSHJ	P,FILNAM	;SAVE FILENAME
	PUSHJ	P,NAMOUT	;PUT NAME INTO FILE.CTL
	AOS	T1,ALGFIL
	MOVEM	T3,ALGFIL(T1)
	MOVE	T3,[SIXBIT /.ALG /]
	PUSHJ	P,NAMOUT	;OUTPUT EXT
	CAIN	C,SPACE		;WHAT'S NEXT CHARACTER?
	PUSHJ	P,GETONE	;TO FLUSH SPACES
	CAIN	C,SPACE		;STILL HAVE SPACES
	JRST	.-2		;YES, FLUSH THEM OUT
	CAIN	C,"/"		;WAS A SWITCH SPECIFIED?
	PUSHJ	P,ACHECK	;SURE WAS!
	CAIN	C,"%"		;026 FLAVOR OF "("
	MOVEI	C,"("		; SO MAKE IT == "("
	CAIN	C,"("		;PROCESSOR SWITCHES WANTED?
	PUSHJ	P,BCHECK	;YES, GO TAKE CARE OF THEM
	CAIN	C,"-"		;CONTINUATION REQUEST
	TRO	F,CONTIN	;TO RETURN LATER
	MOVE	T3,[SIXBIT ./LIST.]
	PUSHJ	P,NAMOUT	;DEFAULT SWITCH ==/LIST
	PJRST	CDRMAD		;GO TO NEXT CARD

;$COBOL CARD PROCESSING

COBCRD:	PUSHJ	P,STDECK	;INITIALIZE FILE.CTL
	TRO	F,CBLCRD	;ALLOW "/SEQ" ON $COBOL
	MOVSI	T2,(SIXBIT /CBL/)	;ADD PROPER EXTENSION
	PUSHJ	P,LOOKEN	;DO LOOKUP//ENTER
	MOVE	T3,T1		;SET NAME IN FOR CTL FILE OUT
	PUSHJ	P,FILNAM	;REGISTER FILENAME ON EXECUTE LIST
	PUSHJ	P,NAMOUT	;OUT FILENAME WHILE HERE
	AOS	T1,COBFIL
	MOVEM	T3,COBFIL(T1)
	MOVE	T3,[SIXBIT /.CBL /]
	PUSHJ	P,NAMOUT	;OUT TO CTL FILE
	CAIN	C,SPACE		;WHAT IS NEXT CHARACTER
	PUSHJ	P,GETONE	;TO FLUSH BLANKS
	CAIN	C,SPACE		;ANY MORE??
	JRST	.-2		;YES, FLUSH THEM
	CAIN	C,"/"		;SWITCH SPECIFIED??
	PUSHJ	P,ACHECK	;YES, GO GET IT
	CAIN	C,"%"		;026 CHARACTER FOR "("
	MOVEI	C,"("		; FOR OUTPUT TO FILE.CTL
	CAIN	C,"("		;PROCESSOR SWITCHES INCLUDED??
	PUSHJ	P,BCHECK	; GO TO PROCESS
	CAIN	C,"-"		;CONTINUATION
	TRO	F,CONTIN	;TO RETURN LATER
	MOVE	T3,[SIXBIT ./LIST.]
	PUSHJ	P,NAMOUT	;USE THE DEFAULT
	TRZ	F,CBLCRD	;$COBOL CARD FINISHED
	PJRST	CDRMAD		;TAG AND GO TO NEXT CARD

;$DECK CARD PROCESSING


DECCRD:	PUSHJ	P,WHSCOR	;IS SEQUENCING CORRECT?
	  JRST	DECER1		;NO, CRY FOUL
	AOS	T1,DECKNO	;UPDATE DECK COUNT
	TLZE	F,DECK		;UNDER A DECK
	PUSHJ	P,EODCR1	;END PRESENT DECK
	PUSHJ	P,CTLOUT	;COPY CARD INTO FILE.CTL
	TRZ	F,REPLCE	;ZERO OUT REPLACE FLAG
DECCR1:	PUSHJ	P,STDCK1	;GET SPECS FROM CARD
	TRNE	F,REPLCE	;SHOULD EXTENSION BE FURNISHED??
	MOVSI	T2,'CDR'	; NO, DEFAULT
	TLNE	F,BINARY	;BINARY DECK??
	MOVSI	T2,'REL'	;DEFAULT EXTENSION TO 'REL'
	TLO	F,DECK		;SET THE DECK FLAG
	PUSHJ	P,LOOKEN
	MOVE	T3,T1		;COPY FILE NAME INTO T3
	TRNE	F,REPLCE	;WHO SPECIFIED FILENAME??
	TLNN	F,BINARY	;DELETE $REL FILES AT END
	JRST	DECCR		;NOT RESULT OF $REL
	PUSHJ	P,FILNAM	;TO STORE FILENAME
	JRST	.+2
DECCR:	SOS	T1,FILCNT
	TLO	F,DECK		;SET DECK FLAG
DECCRA:	CAIN	C,SPACE		;WHAT'S NEXT ON CARD
DECCR2:	PUSHJ	P,GETONE	;GET A CHARACTER
	CAIN	C,SPACE		;IS IT A SPACE?
	JRST	DECCR2
	CAIN	C,"/"		;WAS SWITCH SPECIFIED?
	JRST	CHECK		;GO PROCESS SWITCH
	CAIN	C,"-"		;CONTINUED ON NEXT CARD?
	TRO	F,CONTIN	;YES, SET FLAG
	CAIE	C,CR		;END OF CARD YET?
	CAIN	C,LF		;CR OR LF==END OF CARD
	POPJ	P,		;EXIT AT END
	JRST	DECCR2

;$DATA CARD PROCESSING


DATCRD:	PUSHJ	P,WHSCOR	;IS SEQUENCING CORRECT?
	  JRST	DECER1		;NO, DISREGARD CARD
	PUSHJ	P,CTLOUT
	TLZE	F,DECK
	PUSHJ	P,EODCR1	;GO END THIS FILE OF OUTPUT
	AOS	T1,DECKNO	;TO ADD DATA FILE TO FILE COUNT
	IFN	SPOOLR,<
	TRNN	F,FORSEE
	JRST	DATACD
	MOVE	T2,[ASCII /.ASSI/]
	PUSHJ	P,SET5
	MOVE	T2,[ASCII /GN DS/]
	PUSHJ	P,SET5
	MOVE	T2,[ASCII /K CDR/]
	PUSHJ	P,SET5
	PUSHJ	P,TABCTL	;TAB OVER FOR ANNOUNCEMENT
	PUSHJ	P,TABCTL
	PUSHJ	P,CDRMAD
>
DATACD:	PUSHJ	P,GETSIX	;GET FILENAME
	SETZ	T2,
	CAIN	T1,0		;WAS FILENAME SPECIFIED??
	JRST	FULDEF		;NO, GO FULL DEFAULT ROUTE
	MOVE	P4,T1		;SAVE FILENAME
	SETZ	T1,		;ERASE OLD COPY
	CAIE	C,"."		;EXTENSION SPECIFIED??
	JRST	DATCA1		;NO EXTENSION SPECIFIED
	PUSHJ	P,GETSIX	;GET EXTENSION
DATCA1:	TRZ	F,REPLCE	;DON'T ALLOW NAME FUDGE
	MOVE	T2,T1		;EXTENSION IN T2 FOR ENTER
	MOVE	T1,P4		;DON'T FORGET NAME
	SETZ	T3,
	PUSHJ	P,LOOKEN	;DO THE ENTER
	JRST	DATCRB		;BYPASS .SET SPOOL
FULDEF:	PUSHJ	P,DATNAM	;GET DEFAULT NAME 
DATCRA:	MOVSI	T2,(SIXBIT /CDR/)	;DEFAULT EXTENSION
	TRO	F,REPLCE	;DO A LOOKUP ON .CDR FILES
	SETZ	T3,
	PUSHJ	P,LOOKEN
	MOVE	P4,T1		;SAVE FUDGED NAME
	IFN	SPOOLR,<
	TRNN	F,FORSEE	;FORTRAN DATA??
	JRST	DATAC1		;NO, BYPASS THIS OUTPUT
	MOVE	T2,[ASCII /.REN /]
	PUSHJ	P,SET5
	MOVE	T2,[ASCII /FOR02/]
	PUSHJ	P,SET5
	MOVE	T2,[ASCII /.DAT=/]
>
DATAC1:	IFE	SPOOLR,<
	MOVE	T2,[ASCII /.SET /]
	PUSHJ	P,SET5
	MOVE	T2,[ASCII /CDR /]
>
	PUSHJ	P,SET5
	MOVE	T3,P4
	PUSHJ	P,NAMOUT
	AOS	T1,QXXFIL	;UPDATE .CDR FILE COUNT
	MOVEM	T3,QXXFIL(T1)
	MOVE	T2,[ASCII /.CDR/]
	PUSHJ	P,SET5
	IFE	SPOOLR,<
	PUSHJ	P,TABCTL	;SO EVERYTHING LINES UP PRETTY
>
	PUSHJ	P,CDRMAD
DATCRB:	TLO	F,DECK
DATCR1:	MOVE	T2,[ASCII /.EXEC/]
	PUSHJ	P,SET5		;AND OUT ".EXEC" TO FILE.CTL
	MOVE	T2,[ASCII . /MAP.]
	PUSHJ	P,SET5
	MOVE	T2,[ASCII /:MAP/]
	PUSHJ	P,SET5
	MOVE	T2,[ASCII /.LPT/]
	PUSHJ	P,SET5		;WITH A SPOOLABLE EXTENSION
	MOVE	T2,[ASCII . /REL.]
	PUSHJ	P,SET5		;SET INTO FILE.CTL
	MOVEI	T1,SPACE	;GET SPACE INTO OUTPUT STRING
	PUSHJ	P,OUTCTL	;AND OUT IT TO FILD.CTL
	MOVE	G1,FILCNT	;RETRIEVE FILE COUNT
	TLZ	G1,SHORT	;STRIP ANY STATUS BIT
	MOVEM	G1,FILCNT	;AND SET UP FOR ADDITION
	SKIPE	G1,ENDINP	;DONT PLAY WITH EMPTY TABLE
	MOVE	G4,FILCNT	;GET END OF FILE COUNT LIST
	SUB	G4,FILBAS	;AND NUMBER OF PERTINENT ENTRIES
	SUB	G1,FILBAS
	CAIN	G1,0
	HRR	G1,FILCNT
	MOVE	G2,FILBAS
	SETZ	T3,		;MAKE A FLAG HERE
	TLO	T3,SHORT	;SET LEFT SIGN OF FILCNT
	ADDM	T3,FILCNT	;TO RESET FILCNT AT NEXT $LANG
DATCD1:	MOVE	T3,BUFLOG(G2)	;GET A FILENAME
DATCA:	CAIN	T3,0		;WAS A DEVICE SPECIFIED?
	JRST	.+4		;NO, GO AROUND
	PUSHJ	P,NAMOUT	;OUT DEVICE NAME
	MOVEI	T1,":"		;FOLLOWED BY ":"
	PUSHJ	P,OUTCTL	;OUT TO FILE.CTL
	ADDI	G2,1		;INCREMENT COUNTER
	MOVE	T3,BUFLOG(G2)
	CAIE	T3,0
	JRST	DATC1A
	ADDI	G2,1
	CAML	G2,G4		;AT THE END YET??
	JRST	DATCD2		;YES, GO DO NEXT PART
	JRST	DATCD1		;NO, GET NEXT NAME
DATC1A:	TRNN	F,FRSTWD	;PUT OUT A COMMA??
	JRST	DATC1B		;NO, BYPASS THIS TRIP
	MOVEI	T1,","		;SET A COMMA IN STREAM
	PUSHJ	P,OUTCTL	;OUTPUT THE COMMA
	MOVEI	T1,SPACE	;FOLLOWED BY A SPACE
	PUSHJ	P,OUTCTL
DATC1B:	PUSHJ	P,NAMOUT	;OUT TO FILE.CTL
	ADDI	G2,1		;UPDATE POSITION POINTER
	MOVE	T3,[SIXBIT /.REL/]
	PUSHJ	P,NAMOUT	;AND OUT TO FILE.CTL
	TRO	F,FRSTWD	;COMMAS AFTER THIS POINT
DATC2A:	CAML	G2,G4		;POINTERS EQUAL YET??
	JRST	DATCD2		;YES, THATS ALL FOR TABLE
	JRST	DATCD1		;AND RETURN FOR NEXT SPEC
DATCD2:	TRZ	F,FRSTWD	;FOR NEXT TIME
	HRRZ	T3,FILCNT	;TO UPDATE BASE POINTER
	MOVEM	T3,FILBAS	; AND SAVE AS BASE POINTER
DATCD3:	TRO	F,DATCDS	;$DATA LAST SEEN
	CAIN	C,SPACE		;WHAT WAS LAST CHARACTER?
DATCD4:	PUSHJ	P,GETONE	;TO FLUSH SPACES
	CAIN	C,SPACE		;KEEP FLUSHING SPACES
	JRST	DATCD4		;TO FETCH NEXT CHARACTER
	CAIN	C,"/"		;SWITCH SPECIFICATION??
	PUSHJ	P,ACHECK	;YES, GO PROCESS SWITCH, BUT RETURN
	CAIN	C,"%"		;START OF SWITCH SPECS??
	MOVEI	C,"("		;TO KEEP IT STRAIGHT
	CAIN	C,"("		;IS IT START OF SWITCHES??
	JRST	MAKPER		;YES, GO SET UP COMMAND STRING
	CAIN	C,"-"		;CONTINUATION SPECIFIER??
	TRO	F,CONTIN	;SET CONTINUATION FLAG
	CAIN	C,CR		;LINE TERMINATOR??
	CAIE	C,LF
	JRST	DATCD5
	JRST	DATCD4		;RETURN FOR NEXT CHARACTER
DATCD5:	IFN	SPOOLR,<
	TRNN	F,FORSEE	;FORTRAN DECK SEEN LAST??
	JRST	DATCD6		;NO GO AROUNG THIS PART
	PUSHJ	P,CDRMAD	;GO TAG THIS LINE
	MOVE	T2,[ASCII /.DEAS/]
	PUSHJ	P,SET5		;GO TO BUILD THE COMMAND
	MOVE	T2,[ASCII / CDR/]
	PUSHJ	P,SET5
	PUSHJ	P,TABCTL	;TAB OVER FOR LABEL
	PUSHJ	P,TABCTL	;ANOTHER TAB
	PUSHJ	P,CDRMAD	;OUTPUT ANNOUNCEMENAT
	MOVE	T2,[ASCII /.REN /]
	PUSHJ	P,SET5
	MOVE	T3,P4		;COPY FILENAME
	PUSHJ	P,NAMOUT
	MOVE	T2,[ASCII /.CDR=/]
	PUSHJ	P,SET5
	MOVE	T2,[ASCII /FOR02/]
	PUSHJ	P,SET5
	MOVE	T2,[ASCII /.DAT/]
	PUSHJ	P,SET5
>
DATCD6:	PJRST	CDRMAD		;TAG LINE AND END IT

MAKPER:	MOVE	T2,[ASCII / %/]	;FOR SWITCH SPECIFICATION
	PUSHJ	P,SET5		;AND GO SEND TO FILE.CTL
MAKPR1:	PUSHJ	P,GETONE	;GET NEXT CHARACTER
	CAIE	C,")"		;END OF SWITCH SPECIFICATION??
	CAIN	C,"<"
	JRST	DATCD4		;YES, RETURN FOR NEXT CHARACTER
	CAIE	C,";"		;END OF THIS LINE??
	CAIN	C,CR
	JRST	DATCD5		;RETURN FOR PROPER WRAP UP
	CAIN	C,","		;NEXT SWITCH??
	JRST	MAKPER		;YES, START IT OFF RIGHT
	MOVE	T1,C		;COPY CHARACTER FOR OUTPUT
	PUSHJ	P,OUTCTL	;AND COPY IT OUT
	JRST	MAKPR1		;AND KEEP IN THIS LOOP

;$DUMP CARD PROCESSING

DUMCRD:	PUSHJ	P,WHSCOR	;CHECK CARD ORDER AND RETURN
	  JRST	DECER1		;OUT-OF-ORDER
	PUSHJ	P,CTLOUT	;OUT CARD IMAGE TO FILE.CTL
	MOVE	T1,CARDB	;GET COL. 1-5 OF CARD
	MOVE	T2,[XWD 50000,0]
	ADD	T1,T2		;MAKE $==.
	MOVEM	T1,CARDB	;AND SAVE IN CARD BUFFER
	MOVEI	T3,20		;TO RESAVE ALL OF CARD
DMCDSV:	MOVE	T1,CARDB(T3)	;GET PART OF CARD
	MOVEM	T1,QUECTL(T3)	;AND SAVE FOR END OF JOB
	SOJGE	T3,DMCDSV	;TO GET ALL OF CARD
	POPJ	P,		;GO TO NEXT CARD

;$ERROR AND $NOERROR CARD PROCESSING
;  THESE ROUTINES MERELY OUTPUT THE CARD IMAGE AFTER
;  OUTPUTTING THE APPROPRIATE BATCON COMMAND.
;  EITHER OF THESE CARDS CAUSES AN AUTOMATIC END OF DECK.

BERROR:	PUSHJ	P,WHSCOR	;CHECK CARD ORDER AND RETURN HERE
	  JRST	DECER1		;DECK/S OUT OF ORDER
	PUSHJ	P,EODCRD	;END DECK AND OUTPUT CARD IMAGE
	MOVE	T2,[ASCII /.IF(E/]
	PUSHJ	P,SET5		;TO SET UP FILE.CTL COMMAND STRING
	MOVE	T2,[ASCII /RROR)/]
	PUSHJ	P,SET5		;ROOT COMMAND NOW SET-UP
	JRST	RESTOC		;FOR REST OF CARD
NERROR:	PUSHJ	P,WHSCOR	;CHECK CARD ORDER
	  JRST	DECER1		;OUT OF PROPER ORDER
	PUSHJ	P,EODCRD	;OUTPUT CARD IMAGE AND END FILE
	MOVE	T2,[ASCII /.IF(N/]
	PUSHJ	P,SET5		;TO SET UP COMMAND STRING
	MOVE	T2,[ASCII /OERR/]
	PUSHJ	P,SET5
	MOVE	T2,[ASCII /OR) /]
	PUSHJ	P,SET5		;FINISH THE ROOT OF THIS STRING
RESTOC:	PUSHJ	P,GETONE	;GET NEXT CHARACTER FROM CARD
	CAIE	C,CR		;END OF CARD DETECTED YET??
	CAIN	C,LF
	PJRST	CDRMAD		;YES, GO LABEL LINE
	MOVE	T1,C		;PUT IT INTO APPROPRIATE AC
	PUSHJ	P,OUTCTL	;OUTPUT CHARACTER
	JRST	RESTOC		;GO BACK

;$EOD CARD PROCESSING

EODCRD:	PUSHJ	P,CTLOUT	;OUT CARD TO FILE.CTL
EODCR1:	TLZ	F,DECK		;NO LONGER UNDER $DECK CARD
	MOVSI	T1,(SIXBIT /CDR/)
	MOVE	T2,INDEV	;IF INPUT DEVICE==CDR
	TLNN	T1,T2		;ASCII IF INPUT DEVICE NOT CDR
	TLZ	F,ASCII		
	SKIPE	T1,THSPRT	;SHOULD PROTECTION BE CHANGED?
	RENAME	DSK2,THSFIL	; YES, CHANGE TO REQUESTED PROTECTION
	RELEASE	DSK2,		;CLOSE FILE
	SETZM	THSPRT		;CLEAR OUT OLD PROTECTION
	MOVEI	T1,^D80		;TO RESET WIDTH
	MOVEM	T1,WIDSAV
	POPJ	P,		;RETURN TO NEXT CARD


;$FORTRAN/$F4 CARD PROCESSING

FORCRD:	PUSHJ	P,STDECK	;INITIALIZE FILE.CTL
	MOVSI	T2,(SIXBIT /F4/)	;EXTENSION
	TRO	F,FORSEE
	PUSHJ	P,LOOKEN	;DO A LOOKUP AND ENTER
	MOVE	T3,T1		;SET UP FOR OUT
	PUSHJ	P,FILNAM
	PUSHJ	P,NAMOUT	;OUT FILENAME IN T1
	MOVEI	T1,^D72		;DEFAULT COLUMNS
;	MOVEM	T1,WIDSAV	;SAVE AS WIDTH SPECS
;(TEMP) DO NOT FORCE 72 COL WIDTH AS LOPOFF DOESN'T WORK********
	AOS	T1,FORFIL
	MOVEM	T3,FORFIL(T1)
	MOVE	T3,[SIXBIT /.F4 /]
	PUSHJ	P,NAMOUT	;OUT TO CTL FILE
	CAIN	C,SPACE
	PUSHJ	P,GETONE
	CAIN	C,SPACE
	JRST	.-2
	CAIN	C,"/"		;SWITCH SPECIFIED?
	PUSHJ	P,ACHECK	;YES, GO PROCESS
	CAIN	C,"%"		;026 CHARACTER FOR "("
	MOVEI	C,"("		;FOR OUTPUT TO FILE.CTL
	CAIN	C,"("		;PROCESSOR SWITCHES TO INCLUDE?
	PUSHJ	P,BCHECK	;YES, GO PROCESS
	MOVE	T3,[SIXBIT ./LIST.]
	PUSHJ	P,NAMOUT	;OUT IT TO NAME.CTL
	PJRST	CDRMAD		;GO GET NEXT CARD

;$MACRO CARD PROCESSING

MACCRD:	PUSHJ	P,STDECK	;INITIALIZE FILE.CTL
	MOVSI	T2,(SIXBIT /MAC/)
	PUSHJ	P,LOOKEN	;LOOKUP AND ENTER
	MOVE	T3,T1
	PUSHJ	P,FILNAM
	PUSHJ	P,NAMOUT	;OUT TO CTL
	AOS	T1,MACFIL
	MOVEM	T3,MACFIL(T1)
	MOVE	T3,[SIXBIT /.MAC /]
	PUSHJ	P,NAMOUT	;WITH ITS EXTENSION
	CAIN	C,SPACE		;SEE NEXT CHARACTER
	PUSHJ	P,GETONE	;IS NOT A SPACE
	CAIN	C,SPACE		;BE PERSISTANT
	JRST	.-2		;KEEP FLUSHING BLANKS
	CAIN	C,"/"		;ANY SWITCHES USED
	PUSHJ	P,ACHECK	;YES, GO TO GET THEM
	MOVE	T3,[SIXBIT ./LIST.]
	PUSHJ	P,NAMOUT	;AND OUT TO CTL FILE
	PJRST	CDRMAD
SUBTTL	CARD USED SUBROUTINES

;SUBROUTINE USED TO START FILES BY $LANGUAGE CARDS
; AND $DECK CARD


STDECK:	PUSHJ	P,WHSCOR	;WHAT'S THE SEQUENCING SCORE?
	  JRST	DECER1		;FOUL !!!
	TRZ	F,REPLCE	;INITIALIZE DECK REPLACER
	TRZE	F,DATCDS	;GET HERE AFTER $DATA CONTROL
	TRZ	F,FORSEE	;YES, RESET $FORTRAN FLAG
	MOVEI	T1,^D80		;TO RESET WIDTH SPECS
	MOVEM	T1,WIDSAV	;UNTIL NEXT OVERRIDE
SDECK1:	AOS	T1,DECKNO	;UPDATE DECK NUMBER
	PUSHJ	P,CTLOUT	;COPY CARD TO FILE.CTL
	TLO	F,DECK		;UNDER JURISDICTION OF DECK
	PUSHJ	P,COMPIN	;.COMP /C INTO FILE.CTL
	SETZB	G4,T3		;INITIALIZE FOR TEMPORARY USE
STDCK1:	SETZ	T1,
	CAIE	C,"("		;ONLY SWITCHES ON CARD??
	CAIN	C,"/"		;TEST
	JRST	NDEVSP
	CAIN	C,"%"		;026 CHARACTER FOR "("??
	JRST	NDEVSP
	PUSHJ	P,GETSIX	;GET A SPECIFIED FILENAME
	CAIE	C,SPACE		;CHAR == SPACE??
	JRST	.+3		;NO CARRY ON WITH PROCESSING
	CAIN	T1,0		;AND FILENAME == 0??
	JRST	STDCK1		;BOTH CONDITIONS--FLUSH BLANKS
	CAIE	C,":"		;WAS DEVICE SPECIFIED?
	JRST	NDEVSP		;NO DEVICE SPECIFIED--CDR
	CAMN	T1,[SIXBIT /CDR/]
	JRST	STDCK1		;GO BACK FOR NAME
	MOVE	G4,T1		;COPY DEVICE NAME
	JRST	STDCK1		;RETURN FOR FILENAME,ETC


NDEVSP:	MOVE	T4,T1		;SAVE FILENAME
	MOVE	T3,G4
	PUSHJ	P,FILNAM	;SAVE FILE NAME FOR DELETION
	SETZ	T3,		;INITIALIZE FOR PROJ,,PROG 
	MOVE	T1,T4
	CAIN	T1,0		;WAS IT SPECIFIED??
	PJRST	GETNAM		;NO, START WITH DUMMY NAME AND GO
	CAIN	C,"["		;PPN SPECIFIED??
	PUSHJ	P,PROJSP	;YES, GO PROCESS
	TLNN	F,BINARY	;IS THIS A BINARY FILE??
	JRST	NDEVS1		;NO, NOT FROM $REL CARD
	MOVSI	T2,(SIXBIT /REL/)
	POPJ	P,		;EXTENSION==="REL"
NDEVS1:	CAIN	C,"."		;WAS EXTENSION SPECIFIED?
	JRST	EXTSP		;YES, GO GET IT
	SETZ	T2,
NDEVS2:	CAIE	C,SPACE		;IS CHARACTER==SPACE
	JRST	NDEVS3		;NO, USE THIS DELIMETER
	PUSHJ	P,GETONE	;GET NEXT CHARACTER
	JRST	NDEVS2		;AND SEE WHAT IT IS
NDEVS3:	CAIN	C,"["		;PROJ,,PROG SPECIFICATION??
	PJRST	PROJSP		;GET SPECIFIED PPN
	POPJ	P,
EXTSP:	MOVE	T2,T1		;SAVE FILENAME
	PUSHJ	P,GETSIX	;GET EXTENSION
	EXCH	T1,T2		;FILE==T1,EXTENSION==T2
EXTSP1:	CAIE	C,SPACE		;DELIMETER==SPACE??
	JRST	EXTSP2		;NO - USE THIS DELIMETER
	PUSHJ	P,GETONE	;GET NEXT DELIMETER
	JRST	EXTSP1		;AND SEE WHAT IT IS
EXTSP2:	CAIN	C,"["		;PROJ,,PROG PAIR SPECIFIED??
	PJRST	PROJSP		;YES, GET WHAT IS SPECIFIED
	SETZ	T3,		;TO AVOID TROUBLE ON ENTER
	POPJ	P,		;NAME SPECIFIED, USE FOR NOW

PROJSP:	MOVE	G3,T1		;SAVE ANY FILE NAME
	MOVE	G4,T2		;AND EXTENSION
	SETZB	T1,T3		;INITIALIZE
PRJSP1:	PUSHJ	P,GETONE	;GET A CHARACTER
	CAIN	C,SPACE
	JRST	PRJSP1
	CAIE	C,"/"
	CAIN	C,","		;END OF PROJECT NUMBER??
	JRST	PRJSP2		;YES, GO GET PROG NUMBER
	LSH	T3,6		;SAVE SIXBIT VALUE IN T3
	SUBI	C,40		;MAKE IT SIXBIT
	ADD	T3,C
	SUBI	C,20		;MAKE IT A DIGIT
	LSH	T1,3		;SAVE NUMERIC VALUE IN T1
	ADD	T1,C
	JRST	PRJSP1		;GO GET NEXT CHARACTER
PRJSP2:	HRLZ	T2,T1
	MOVEM	T3,MINUTE	;SAVE SIXBIT PROJ. NUMBER
	SETZB	T1,T3
PRJSP3:	PUSHJ	P,GETONE	;GET THE NEXT CHARACTER
	CAIN	C,SPACE
	JRST	PRJSP3
	CAIN	C,"]"
	JRST	ACCES1
	LSH	T3,6
	SUBI	C,40
	ADD	T3,C
	LSH	T1,3
	SUBI	C,20
	ADD	T1,C
	JRST	PRJSP3		;RETURN FOR REMAINING CHARACTERS

ACCES1:	ADD	T2,T1		;PUT PROJ# WITH PROG#
	MOVE	T3,T2		; AND INTO AC T3
	SETZB	T1,T4		;FOR ACCESS UUO
	MOVE	T2,PPNS		;RETRIEVE USER PPN
	CHKACC	T1,		;CAN HE DO THAT
	  SETZ	T3,
	CAIE	T1,0		;ACCESS O.K.??
	SETZB	T1,T2		;NO, CLEAR OUT OLD
	MOVE	T1,G3
	MOVE	T2,G4
	TRO	F,REPLCE	;SET TO REPLACE
	POPJ	P,
FILNAM:	MOVE	T1,FILCNT	;GET COUNT FOR INDEX
	MOVEM	T3,BUFLOG(T1)	;SAVE FILENAME OR EXT.
	AOS	T1,FILCNT	;INCREMENT COUNTER
	POPJ	P,		;RETURN

COMPIN:	MOVE	T2,[ASCII /.COMP/]
	PUSHJ	P,SET5		;OUT 5 CHARACTERS TO FILE.CTL
	MOVE	T2,[ASCII . /COM.]
	PUSHJ	P,SET5
	MOVE	T2,[ASCII .PILE .]
SET5:	MOVEI	T4,5
	MOVE	T3,[POINT 7,T2]	;LOCATION OF CHARACTERS IS T2
	PJRST	CTLOU1		;OUT CHARACTERS AND RETURN

GETNAM:	TRO	F,REPLCE	;REPLACE DEFAULTS
	MOVE	T1,DEFNAM	;GET THE LAST DEFAULT
	ADDI	T1,1		;MAKE IT NEXT STEP
	MOVEM	T1,DEFNAM	;SAVE IT
	ANDI	T1,77		;WHAT'S LAST LETTER
	CAIG	T1,72		;BIGGER THAN A ZEBRA
	JRST	GETNM1		;NO, IT'S O.K.
	MOVEI	T1,46		;TO GET BACK TO ALPHA
	ADDM	T1,DEFNAM	;STORE IT AWAY FOR LATER
GETNM1:	MOVE	T1,DEFNAM	;RESTORE T1
	POPJ	P,

DATNAM:	HLLZ	T1,DATANM	;GET LAST DEFAULT
	ADD	T1,[XWD 1,0]	;INCREMENT NAME
	HLLM	T1,DATANM	;REPLACE OLD NAME WITH NEW
	HLRZ	T1,DATANM	;GET SCRATCH COPY OF NAME
	ANDI	T1,77		;GET LAST NAME CHARACTER
	CAIG	T1,72		;HAVE WE OVERFLOWN??
	JRST	DATNM1		;NO, WE'RE SAFE
	HRLZI	T1,46		;ADD THE OFFSET
	ADDM	T1,DATANM	; TO THE FILE NAME
DATNM1:	MOVE	T1,DATANM	;PICK UP LAST GOOD NAME
	POPJ	P,



LOOKEN:	RELEASE	DSK2,		;START WITH CLOSE
	TRNN	F,OKAY		;SHOULD FILE BE OPENED??
	POPJ	P,		;NO, ILLEGAL USER
	OPEN	DSK2,CAROUT
	SETZ	T4,		;INITIALIZE FOR PPN HOLDING
	MOVE	T4,T3		;WAS A PPN SPECIFIED??
LOOKN1:	SETZ	T3,		;CLEAR NAME+2
	CAIN	T4,0		;WAS ANY PPN SPECIFIED?
	MOVE	T4,NEWPPN	;GET P#,P#
	PUSH	P,T4		;SAVE THE PPN IN CASE
	TRNE	F,REPLCE	;REPLACE FILE.LANGUAGE
	LOOKUP	DSK2,T1		;DO A LOOKUP
	JRST	LOOKN2
	TLNE	F,DECK
	JRST	LOOKN3
	PUSHJ	P,DATNAM
	POP	P,T4		;RETRIEVE SAVED PPN
	JRST	LOOKN1
LOOKN3:	PUSHJ	P,GETNAM
	POP	P,T4		;RETRIEVE SAVED PPN
	JRST	LOOKN1
LOOKN2:	HLLZ	T2,T2
	POP	P,T4		;RETRIEVE SAVED PPN
	SETZ	T3,
	MOVEM	T4,THSPPN	;SAVE THE PPN
	ENTER	DSK2,T1
	  JRST	DECFAI
	MOVEM	T1,THSFIL	;SAVE THIS FILE'S NAME
	HLLZM	T2,THSEXT	;AND THIS FILE'S EXTENSION
	TRZ	F,REPLCE	;BEFORE NEXT TIME THROUGH HERE
	POPJ	P,

;SUBROUTINE USED TO INSERT APPROPRIATE TEXT INTO FILE.CTL
;     ENTERED WITH THE SIXBIT TEXT IN AC T3

NAMOUT:	MOVEI	P2,6
	MOVE	T2,[POINT 6,T3]
	SETZ	T4,		;CLEAR WORD+1
NAMOU1:	ILDB	T1,T2
	ADDI	T1,40
	CAIE	T1,40
	PUSHJ	P,OUTCTL
	SOJG	P2,NAMOU1	;ONLY WANT SIX 
	POPJ	P,


;SUBROUTINES TO TERMINATE LINES OF INPUT TO FILE.CTL
;     ENDINP--APPENDS <CR><LF> TO THE INPUT LINE
;     CDRMAD--APPENDS THE MESSAGE "CREATED BY CDRSTK"<CR><LF>
;             TO THE LINE

ENDINP:	MOVEI	T1,CR		;END THIS LINE OF OUTPUT
	PUSHJ	P,OUTCTL
	MOVEI	T1,LF		; WITH <CR><LF>
	PJRST	OUTCTL

;SUBROUTINE TO APPEND THE TEXT "CREATED BY CDRSTK" AFTER
;     INSTRUCTIONS GENERATED BY CDRSTK WHICH ARE THEN
;     INSERTED INTO THE CONTROL FILE

CDRMAD:	PUSHJ	P,TABCTL
	MOVE	T2,[ASCII /;CREA/]
	PUSHJ	P,SET5
	MOVE	T2,[ASCII /TED B/]
	PUSHJ	P,SET5
	MOVE	T2,[ASCII /Y CDR/]
	PUSHJ	P,SET5
	MOVE	T2,[ASCII /STK
/]
	PUSHJ	P,SET5
	POPJ	P,

LOCSTA:	MOVE	G1,T1		;SAVE STATION NUMBER
	MOVE	T2,[ASCII /.LOCA/]
	PUSHJ	P,SET5
	MOVE	T2,[ASCII /TE /]
	PUSHJ	P,SET5
	ADDI	G1,"0"		;MAKE PRINTABLE
	MOVE	T1,G1		;RETRIEVE STATAION NUMBER
	PUSHJ	P,OUTCTL
	PUSHJ	P,TABCTL	;TAB OVER TWICE FOR
	PUSHJ	P,TABCTL	;FOR AN IMPORTANT ANNOUNCEMENT
	PJRST	CDRMAD


;$MODE CARD PROCESSING

MODCRD:	TRNE	F,OKAY
	PUSHJ	P,CTLOUT
	CAIE	C,"/"		;NO SPACE DETECTED ON $MODE
MODCRX:	PUSHJ	P,GETONE	;GET A CHARACTER
	CAIE	C,"/"		;FIND INITIAL DELIMETER
	JRST	MODCRX		;KEEP SEARCHING FOR "/"
	PUSHJ	P,GETSIX	;GET THE SWITCH NAME
	PUSHJ	P,USERSW	;NO, GO TO PROCESS SWITCH
	POPJ	P,

;$RELOC CARD PROCESSING

RELCRD:	TLZ	F,ASCII+IMAGE+SIXFL+NINEFL
	TLO	F,BINARY	;SET BINARY MODE FLAG
	JRST	DECCRD		;LIKE A $DECK FROM HERE

;$SEQUENCE CARD PROCESSING

SEQCRD:	MOVE	T1,SCORE	;GET THE PRESENT SCORE
	PUSH	P,P1		;IN CASE P1 HAS POINTER
	CAIE	T1,0		;HERE O.K.??
	PUSHJ	P,DECERR	;NO, END A JOB AND START ANOTHER
	POP	P,P1		;RETRIEVE SAVED A.C.
	PUSHJ	P,NUMARG	;GET THE SEQUENCE NUMBER
	MOVEM	T1,SEQSAV	;SAVE IT FOR USER
	POPJ	P,		;RETURN TO NEXT CARD

;$STPAUSE CARD PROCESSING

STPCRD:	MOVE	T1,SCORE	;RETRIEVE SCORE COUNT
	CAIN	T1,0		;BETWEEN DECKS?
	SETZM	CRDCNT		;SO, NO CARD NUMBERS OUTPUT
	TLNE	F,DOLLAR+ALL	;ALREADY OUTPUT ONCE?
	JRST	STPCD1		;YES, ONCE IS ENOUGH
	OUTSTR	CARDB		;OUTPUT CARD IMAGE TO OPERATOR
	OUTSTR	[ASCIZ /
/]
STPCD1:	TLZ	F,GOFLAG
	PUSHJ	P,STOPS
	JRST	.+1		;PAUSES RETURNS WITH CPOPJ1
	POPJ	P,		;RETURN TO NEXT CARD

DECERR:	IFN	OPEROK,<
	OUTSTR	[ASCIZ/? MISSING EOJ CARD, TYPE "A" TO APPEND
AN EOJ, "F" TO FLUSH THIS CARD
*/]
	INCHWL	T1,
DECERA:	INCHWL	T2,		;UNTIL END OF LINE
	CAIE	T2,LF		;END YET?
	JRST	DECERA		;NO GO BACK
	CAIE	T1,"A"		;DESIRE TO APPEND?
	JRST	NXCARD		;NO--FLUSH THIS CARD
>
	MOVE	T2,[ASCII /;EOJ /]
	PUSHJ	P,SET5		;OUT THIS TEXT
	PUSHJ	P,TABCTL	;MOVE OVER A TAB
	PUSHJ	P,TABCTL	;AND ANOTHER
	PUSHJ	P,TABCTL	;TO LINE UP CORRECTLY
	PUSHJ	P,CDRMAD	;WITH COMMENT
	TRO	F,EODERR
	PJRST	CDREOF

DECER1:	PUSHJ	P,TIME1		;TIMESTAMP ERROR MESSAGE
	MOVE	T2,[ASCII /STERR/]
	PUSHJ	P,OUTLO5	;OUTPUT MESSAGE TYPE
	PUSHJ	P,OUTTAB	;FOLLOWED BY A TAB
	MOVE	T2,[ASCII /CARD#/]
	PUSHJ	P,OUTLO5	;FOLLOWED BY DECK POSITION
	MOVE	T1,CRDCNT	;GET PRESENT CARD NUMBER
	PUSHJ	P,LOGTIM	;OUTPUT TO FILE .LOG
	PUSHJ	P,OUTTAB	;FOLLOWED BY A TAB
	MOVE	T2,[ASCII /CARD /]
	PUSHJ	P,OUTLO5	;ERROR MESSAGE
	MOVE	T2,[ASCII /SEQUE/]
	PUSHJ	P,OUTLO5
	MOVE	T2,[ASCII /NCING/]
	PUSHJ	P,OUTLO5
	MOVE	T2,[ASCII / ERRO/]
	PUSHJ	P,OUTLO5
	MOVE	T2,[ASCII /R   /]
	PUSHJ	P,OUTLO5
	PJRST	CDERR2		;TO FINISH UP ERROR PROCESSING

TABCTL:	MOVEI	T1,TAB
	PJRST	OUTCTL		;OUT A TAB TO FILE.CTL AND RETURN


;SUBROUTINE TO DETERMINE IF CARD SEQUENCING IS PROPER

WHSCOR:	MOVE	T1,SCORE	;RETRIEVE CARD SEQUENCE COUNT
	IFE	CODEWD,<
	CAIGE	T1,3		;IS SEQUENCE PROPER
>
	IFN	CODEWD,<
	CAIGE	T1,2		;IS IT OKAY??
>
	POPJ	P,		;TAKE AN ERROR
	MOVEI	T1,^D80
	MOVEM	T1,WIDSAV	;RESET WIDTH HERE
	JRST	CPOPJ1		;IT'S A HIT


;SUBROUTINE TO INPUT SIX CHARACTERS FROM CDR-
;  RETURN TO CALLING ROUTINE WITH SIX CHARACTERS IN T1
;  AND TERMINAL CHARACTER IN C

GETSIX:	MOVEI	T4,6
	SETZ	T1,		;PREPARE T1 FOR INFO
	MOVE	T3,[POINT 6,T1]
GETVI1:	ILDB	C,P1		;GET A CHARACTER
GETVI2:	CAILE	C,140
	SUBI	C,40		;CAPITALIZE LOWER CASE
	CAIN	C,15
	JRST	GETVI1
	CAIG	C,132		;IS C OUT OF RANGE
	CAIGE	C,60		;OF ALPHABETICS
	POPJ	P,		;YES, ALL DONE NOW
	CAIGE	C,101		;IS IT ALPHABETIC
	CAIG	C,71		;OR NUMERIC
	JRST	GOTSIX
	POPJ	P,		;NON-ALPHANUMERIC--RETURN
GOTSIX:	SOJL	T4,GETVI1	;GOT THE SIX YET??
	SUBI	C,40		;MAKE C SIXBIT
	IDPB	C,T3		;DEPOSIT THE CHARACTER
	JRST	GETVI1		;RETURN FOR NEXT CHARACTER

GETONE:	ILDB	C,P1		;GET ONE CHARACTER FROM CARDB
	JUMPE	C,GETONE	;FLUSH BLANKS
	CAILE	C,140		;NEED TO BE CAPITALIZED ?
	SUBI	C,40		;YES, CAPITALIZE IT
	POPJ	P,		;RETURN TO SENDER

ANYSIX:	MOVEI	T4,6		;ANY SIX CHARACTERS WILL DO
	SETZ	T1,		;BUT START FRESH
	MOVE	T3,[POINT 6,T1]
ANYSX:	SETZ	C,
	ILDB	C,P1		;GET NEXT CHARACTER
	CAIN	C,SPACE		;FLUSH LEADING SPACES
	JRST	ANYSX
	JRST	SIXER
ASIXER:	ILDB	C,P1		;GET NEXT CHARACTER
SIXER:	CAILE	C,140		;NEED TO CAPITALIZE??
	SUBI	C,SPACE
	CAIN	C,CR
	JRST	ASIXER		;YES, GET <LF>
	CAIN	C,LF		;END??
	POPJ	P,		;YES, END THIS INPUT
	SOJL	T4,ASIXER	;GOT ALL SIX YET?
	SUBI	C,SPACE		;SIXBIT IT
	CAIL	C,0
	IDPB	C,T3		;AND SAVE IT
	JRST	ASIXER
SUBTTL	OPERATOR SWITCHES

;HERE ARE THR ROUTINES WHICH PROCESS OPERATOR SWITCH TYPE-IN

OPERSW:	PUSHJ	P,SIXCHR	;GET THE SWITCH NAME INTO T1
	CAIN	T1,SPACE	;FLUSH BLANK SPACE
	JRST	OPERSW		; TO FLUSH THE BLANK
USERSW:	PUSHJ	P,TRYIT
	MOVSI	M,-NOSWIT	;GET NUMBER OF SWITCHES
SWITLP:	MOVE	T3,SWIT(M)	;RETRIEVE A SWITCH FROM TABLE
	TDZ	T3,T2		;MASK OUT EXTRA TABLE CHARS
	CAMN	T1,SWIT(M)	;COMPARE TYPE-IN VS.TABLE
	JRST	@SWITGO(M)	;AND DISPATCH IF EQUAL
	CAME	T1,T3		;COMPARE TYPE-IN VS.TABLE(MASKED)
	JRST	LPSWIT		;UNEQUAL-GET NEXT ENTRY
	TROE	T4,1		;SET FIRST DETECT FLAG
	TROA	T4,2		;SET SECOND DETECT FLAG
	MOVE	P2,M		;SAVE INDEX
LPSWIT:	AOBJN	M,SWITLP	;SEEN ALL ENTRIES YET?
	CAIN	T4,1		;ONLY ONE MATCH?
	JRST	@SWITGO(P2)	;YES, DISPATCH TO IT
	TRZE	F,TYPED		;WHOSE ERROR
	  JRST	OPERR		;OPERATOR TYPE-IN ERROR
	  PJRST	ERROR1		;USER'S ERROR

DEFINE	SWICH,<
	C	ASCII,ASCSW
	C	BINARY,BINSW
	C	D029,D029SW
	C	HELP,HELSW
	C	IMAGE,IMASW
	C	MULTIF,MULSW
	C	SINGLE,SINSW
	C	SUPPRE,SUPSW
	C	WIDTH,WIDSW
	C	026,SW026
>

DEFINE	C(A,B)<
	<SIXBIT /A/>
>

SWIT:	SWICH
NOSWIT=.-SWIT

DEFINE	C(A,B)<
	Z	B
>

SWITGO:	SWICH

ASCSW:	TLZ	F,NINEFL+SIXFL+BINARY+IMAGE
	TLNE	F,CDRFLA	;FOR DEVICE==CDR, SKIP TO DEFAULT
	TLO	F,ASCII		;SET ASCII SWITCH
	JRST	SUPFN1

BINSW:	PUSHJ	P,DEVCHK	;CHECK IF DEVICE IS LEGAL
	  JRST	SUPFN1		;ILLEGAL DEVICE
	TLZ	F,NINEFL+SIXFL+IMAGE+ASCII
	TLO	F,BINARY
	JRST	SUPFN1		;TO FIND WAY OUT

D029SW:	PUSHJ	P,DEVCHK	;CHECK IF DEVICE IS LEGAL
	  JRST	SUPFN1		;DEVICE IS ILLEGAL
	TLO	F,NINEFL	;SET D029 FLAG
	TLZ	F,SIXFL+BINARY+IMAGE+ASCII
	JRST	SUPFN1		;GO TO PROPER EXIT

MULSW:	TLZA	F,MULTI		;ZERO FLAG
SINSW:	TLO	F,MULTI		;SET FLAG
	JRST	SUPFN1		;AND RETURN

SUPSW:	TRNN	F,TYPED		;WHOSE REQUEST IS THIS?
	JRST	SUPUSR		;FROM A CARD
SUPOPR:	PUSHJ	P,NXCHAR	;GET A TYPED IN CHARACTER
	CAIN	C,SPACE
	JRST	SUPOPR
	CAIN	C,"Y"		;GET DOWN TO BUSINESS
	JRST	AFFIRM		;A "YES" REQUEST
	CAIN	C,"N"		;OR A "NO" REQUEST??
	JRST	NEGATV		;NEGATIVE--
	CAIN	C,"O"		;"ON" OR "OFF"??
	PUSHJ	P,NXCHAR	;NEXT CHARACTER WILL TELL
	CAIN	C,"N"		;REQUESTED "ON"
	JRST	AFFIRM		;YES, TURN "ON"
	CAIN	C,"F"		;OR REQUESTED "OFF"?
	JRST	NEGATV		;GO TO TURN "OFF"
	  PJRST	NOARG1		;LEARN TO SPELL!!!!!!
SUPUSR:	PUSHJ	P,GETONE	;GET A CARD CHARACTER
	CAIN	C,SPACE
	JRST	SUPUSR
	CAIN	C,"Y"		;A "YES" REQUEST?
	JRST	AFFIRM		;YES IT'S A "YES"
	CAIN	C,"N"		;OR A "NO"??
	JRST	NEGATV		;GO TO "NO"
	CAIN	C,"O"		;"ON" OR "OFF" REQUESTED??
	PUSHJ	P,GETONE	;YES, GET NEXT CHARACTER
	CAIN	C,"N"		;ON==YES
	JRST	AFFIRM		;GO TO SET "ON" BIT
	CAIN	C,"F"		;OFF==NO
	JRST	NEGATV		;GO TO SET BIT TO OFF
	  PJRST	CRDBAD		;TAKE ERROR RETURN
AFFIRM:	TLO	F,SUPRES	;DO THE SUPPRESSION
	JRST	SUPFIN		;TO READ IN ALL OF ARGUMENT
NEGATV:	TLZ	F,SUPRES	;PREPARE FOR 80 COLUMNS
	MOVEI	T1,DEFWID
	MOVEM	T1,WIDSAV
SUPFIN:	CAIE	C,SPACE		;END OF ARGUMENT ENCOUNTERED??
	CAIN	C,CR
	JRST	SUPFN1		;YES, RETURN TO CALLER
	TRNN	F,TYPED		;WHERE TO GET CHARACTER FROM
	JRST	FINUSR		;CARD!
	PUSHJ	P,NXCHAR	;TTY!
	JRST	SUPFIN
FINUSR:	PUSHJ	P,GETONE	;GET A CARD CHARACTER
	JRST	SUPFIN
SUPFN1:	TRZN	F,TYPED		;WHO CALLED??
	JRST	CHECK1		;CALLED BY CARD USER
	JRST	CPOPJA		;RETURN TO OPERATOR


IMASW:	PUSHJ	P,DEVCHK	;IS THIS A LEGAL MODE FOR DEVICE?
	  JRST	SUPFN1		;NO, NOT LEGAL
	TLO	F,IMAGE		;SET IMAGE MODE FLAG
	MOVE	T1,[POINT 12,0,35]
	MOVEM	T1,CARBUF+1
	TLZ	F,NINEFL+SIXFL+BINARY+ASCII
WIDSW:	TRNE	F,TYPED
	JRST	WIDSW1
	PUSHJ	P,NUMARG
	MOVEM	T1,WIDSAV
	JRST	SUPFN1
WIDSW1:	PUSHJ	P,GETARG
	MOVEM	T1,WIDSAV	;RESET MAXIMUM WITH SPECS
	JRST	SUPFN1		;FOR PROPER RETURN

SW026:	PUSHJ	P,DEVCHK	;CHECK IF THIS DEVICE LEGAL 026
	  JRST	SUPFN1		;NOT A LEGAL DEVICE
	TLO	F,SIXFL		;SET THE 026 MODE FLAG
	TLZ	F,NINEFL+BINARY+IMAGE+ASCII
	JRST	SUPFN1

OPERR:	OUTSTR	[ASCIZ *
? ILLEGAL SWITCH, TYPE "HELP" FOR HELP
*]
	JRST	CPOPJA		;RETURN TO OPERATOR
HELSW:	MOVE	T1,[SIXBIT /CDRSTK/]
	PUSHJ	P,.HELPR	;TO OUTPUT HELP TEXT
	JRST	SUPFN1
SUBTTL	USER SWITCHES

;HERE ARE THE ROUTINES WHICH PROCESS USER SWITCHES


ACHECK:	TRO	F,FRSTWD+LANGUE	;GOT HERE FROM $LANG
CHECK:	PUSHJ	P,GETONE	;GET A CHARACTER INTO "C"
CHECK1:	CAIE	C,0		;FLUSH BLANKS
	CAIN	C,"/"		;A SWITCH DELIMETER?
	JRST	CHECK		; YES, FLUSH IT
	CAIE	C,SPACE		;FLUSH SPACES
	CAIN	C,","		;AND COMMAS
	JRST	CHECK		;FROM SWITCH PROCESS
	CAIN	C,";"		;START OF A COOMENT
	JRST	CHECK2		;YES, GO FLUSH COMMENT
	CAIE	C,"-"		;CONTINUATION
	JRST	CHECKA		;NO, GO AROUND
	TRO	F,CONTIN	;YES, SET FLAG
	JRST	CHECK		;GET NEXT CHARACTER
CHECKA:	CAIE	C,CR		;IS CHARACTER A <CR>
	CAIN	C,LF		;OR A <LF>?
	JRST	CHECK3		;YES, END OF CARD DETECTED
	CAIN	C,"%"		;026 PROCESSOR SWITCH DELIMITER??
	MOVEI	C,"("		;MAKE IT ASCII
	CAIE	C,"("		;PROCESSOR SWITCHES??
	JRST	CHECKB		;CARRY ON WITH PROCESSING
	TRNE	F,LANGUE	;IS THIS A LANGUAGE DECK??
	JRST	BCHECK		;YES, GO PROCESS
CHECKB:	SETZ	T1,		;INIT FOR SAVING CHARACTERS
	MOVE	T3,[POINT 6,T1]	;SET BYTE POINTER FOR T1
	MOVEI	T4,6		;SIX CHARACTER SWITCH
SWITCH:	SUBI	C,40		;CONVERT NAME TO SIXBIT
	IDPB	C,T3		;STORE IT IN T1
TRIAL:	PUSHJ	P,GETONE	;READY TO USE T1?
	CAIN	C,"_"		;026 VERSION OF ":"
	JRST	TRYONE		;YES, TERMINATE
	CAIE	C,":"		;SWITCH NAME TERMINATOR
	CAIN	C,SPACE
	JRST	TRYONE		;YES PROCESS THE SWITCH
	CAIE	C,"/"
	CAIN	C,CR
	JRST	TRYONE
	SOJG	T4,SWITCH	;NO, GET ALL SIX CHARACTERS

TRYONE:	TRZ	F,TYPED		;FROM CARDS
	PUSHJ	P,TRYIT
	MOVSI	M,-TABLEN	;PREPARE SWIT TABLE SEARCH
SWILP:	MOVE	T3,TABL1(M)	;GET NEXT TABLE ENTRY
	TDZ	T3,T2		;MASK OUT EXCESS CHARACTERS
	CAMN	T1,TABL1(M)	;EXACT MATCH?
	JRST	SWIFND		; YES, GO TO PROCESS
	CAME	T1,T3		;MATCH MASKED?
	JRST	SWINEQ		; NOT EVEN MASKED!
	TROE	T4,1		;MATCHES MASKED, FIRST OCCUR?
	TROA	T4,2		;NO, SET SECOND OCCUR
	MOVE	P2,M		;YES, GET INDEX
SWINEQ:	AOBJN	M,SWILP		;END OF SWITCHES YET?
	CAIE	T4,1		;DID ONLY ONE SWITCH MATCH
	  PJRST	ERROR1		;SWITCH IN ERROR
	MOVE	M,P2		;YES, SAVE INDEX
SWIFND:	MOVE	T1,DISP(M)	;GET DISPATCH ADDRESS INTO T1
SWIFN1:	CAIE	C,":"		;GET ALL OF SWITCH
	CAIN	C,SPACE		; VERBIAGE PASSED THRU
	JRST	@T1		;ALL GONE, DO SWITCH
	CAIE	C,","
	CAIN	C,"_"
	JRST	@T1
	CAIE	C,CR
	CAIN	C,LF
	JRST	@T1
	PUSHJ	P,GETONE	; GET NEXT CHARACTER
	JRST	SWIFN1		;AND LOOK OVER 

CHECK2:	PUSHJ	P,GETONE	;GOT HERE AT COMMENT
	CAIE	C,CR		;END OF CARD DETECTED?
	JRST	CHECK2		;KEEP LOOKING
CHECK3:	TRZN	F,LANGUE	;HERE FROM $LANGUE CARD??
	JRST	NXCARD		;NO, BYPASS AND GET NXT CARD
	TRZE	F,FRSTWD	;WANT TO RETURN FOR DEFAULTS?
	POPJ	P,		;YES, GO THAT ROUTE
	POP	P,T1		;GOT HERE VIA PUSHJ
	PUSHJ	P,CDRMAD	;TAG THE OUTPUT LINE
	POPJ	P,		;RETURN FOR NEXT CARD

BCHECK:	TRNE	F,DATCDS	;$DATA CARD??
	JRST	CHECK3		;GO TO RETURN
	MOVE	T1,C		;COPY CHARACTER FOR OUTPUTTER
	PUSHJ	P,OUTCTL	; TO FILE.CTL
BCHEK1:	PUSHJ	P,GETONE	;GET NEXT CHARACTER
	CAIE	C,CR		;END OF CARD??
	JRST	BCHEK2		;NO, KEEP LOOKING AT CARDS
	MOVEI	C,")"		;TO END THIS STRING
	JRST	BCHEK3
BCHEK2:	CAIN	C,SPACE		;IS THIS A BLANK?
	JRST	BCHEK1		;YES, GET NEXT CHARACTER
	CAIN	C,"<"		;026 REPRESENTATION OF ")"
	MOVEI	C,")"		; MAKE THIS CHARACTER==ASCII
	CAIE	C,")"		;END OF SWITCHES??
	JRST	BCHECK		;NO, OUTPUT THIS CHARACTER
BCHEK3:	MOVE	T1,C		;COPY CHARACTER FOR OUTPUT
	PUSHJ	P,OUTCTL	; TO FILE.CTL
	MOVEI	T1,SPACE	;FOLLOWED BY A SPACE
	PUSHJ	P,OUTCTL	;OUTPUT TO FILE.CTL
	JRST	ACHECK		;TO RETURN PROPERLY


; "NAMES" IS THE MACRO FOR SWITCH PROCESSING.
;	ITS FORMAT IS:
;		C SWITCH NAME,DISPATCH ADDRESS

DEFINE 	NAMES<
	C AFTER,AFTERS
	C ASCII,ASCSW
	C BINARY,BINSW
	C C,CREFSW
	C CARDS,CARDS
	C CORE,CORES
	C CREF,CREFSW
	C CHARGE,CHARGE
	C D029,D029SW
	C DEADLI,DEADLS
	C DEPEND,DEPENS
	C FEET,FEETS
	C IMAGE,IMASW
	C L,LISTSW
	C LOCATE,LOCATS
	C LIST,LISTSW
	C M,MACEXP
	C MACRO,MACEXP
	C N,NOLSW
	C NAME,NAMED
	C NOLIST,NOLSW
	C PAGES,PAGES
	C PRIORI,PRIOS
	C PROTEC,PROTS
	C RESTAR,RESTRS
	C S,SEQSW
	C SEQUEN,SEQSW
	C SUPPRE,SUPSW
	C TIME,TIMES
	C TPLOT,TTIME
	C UNIQUE,UNIOS
	C WIDTH,WIDSW
	C 026,SW026
>

;"TABL1" LISTS USER SWITCHES DERIVED FROM NAMES

DEFINE	C(A,B)<
	<SIXBIT /A/>
>
TABL1:	NAMES
TABLEN=.-TABL1

;"DISP" IS THE SWITCH DISPATCH TABLE DERIVED FROM NAMES

DEFINE 	C(A,B)<
	Z	B
>
DISP:	NAMES
DISLEN=.-DISP
SUBTTL	USER SWITCH ROUTINES

AFTERS:	PUSHJ	P,DEDAFT	;GO AND CONVER TIME
	MOVEM	T1,AFTTIM	;RETAIN FOR QUEUE CALL
	JRST	CHECK		;RETURN UNTIL END OF CARD

CARDS:	PUSHJ	P,NUMARG	;GET NUMERIC ARGUMENT
	HRRM	T1,PAGCAR	;RETAIN FOR QUEUER CALL
	JRST	CHECK1		;RETURN FOR SWITCH OR EXIT

CORES:	PUSHJ	P,NUMARG	;GET NUMERIC ARGUMENT
	CAIG	T1,256		;MUST WANT "CDRSTK" TO MAKE "K"
	IMULI	T1,^D1000	;MAKE IT CORE FOR QUEUER
CORES1:	HRLM	T1,CORTIM	;SAVE FOR QUEUE CALL
	JRST	CHECK1		;AND GET SWITCHES OR EXIT

CREFSW:	TRNE	F,LANGUE	;IS THIS A $LANGUAGE CARD??
	TLNN	F,DECK		;AND IS THIS SWITCH LEGAL HERE??
	JRST	CHECK		;NO, GET NEXT SWITCH
	MOVE	T2,[ASCII . /C .]
	PUSHJ	P,SET5		;OUT TO FILE.CTL
	TRZ	F,FRSTWD	;SO DON'T RETURN FOR DEFAULTS
	TLO	F,CREFSP	;/CREF SPECIFIED
	JRST	CHECK		;AND RETURN

CHARGE:	PUSHJ	P,GETONE	;FLUSH THE TERMINATOR
	SETZM	CHASAV		;FLUSH ANY OLD INFORMATION
	MOVEI	T4,6		;SIX CHARACTER MAXIMUM
	MOVE	T3,[POINT 6,CHASAV,]
	JRST	NAMES1		;GO TO NEXT CHARACTER READ

DEADLS:	PUSHJ	P,DEDAFT	;GO TO CONVERT TIME
	MOVEM	T1,DEDTIM	;SAVE FOR QUEUE CALL
	JRST	CHECK		;AND RETURN

DEPENS:	PUSHJ	P,NUMARG	;GET NUMERIC ARGUMENT
	MOVEM	T1,DEPSAV	;SAVE FOR QUEUE CALL
	JRST	CHECK1		;RETURN TO MORE OR EXIT

FEETS:	PUSHJ	P,NUMARG	;GET FEET ARGUMENT
	HRLM	T1,TAPPTI	;SAVE FOR QUEUE CALL
	JRST	CHECK1		;RETURN FOR MORE OR EXIT

LISTSW:	TRNE	F,LANGUE	;IS THIS A $LANGUAGE CARD??
	TLNN	F,DECK		;LEGALLY HERE??
	JRST	CHECK		;DISREGARD THIS SWITCH
	MOVE	T2,[ASCII . /L .]
	PUSHJ	P,SET5		;OUT TO FILE.CTL
	TRZ	F,FRSTWD	;BYPASS DEFAULTS FOR THIS $LANG CARD
	JRST	CHECK		;AND RETURN
LOCATS:	PUSHJ	P,NUMARG	;GET NUMBER ARGUMENT
	MOVEM	T1,LOCSAV	;SAVE FOR BATCH
	PUSHJ	P,LOCSTA	;TO ENTER FILE.CTL
	JRST	CHECK1		;AND RETURN

MACEXP:	TRNE	F,LANGUE	; LANGUAGE CARD?
	TLNN	F,DECK		;HERE LEGALLY??
	JRST	CHECK		;NO, FORGET THIS
	MOVE	T2,[ASCII . /L .]
	PUSHJ	P,SET5		;OUT TO FILE.CTL
	MOVE	T2,[ASCII /(M) /]
	PUSHJ	P,SET5		;OUT TO FILE.CTL
	TRZ	F,FRSTWD	;TO BYPASS DEFAULTS FOR .COMP
	JRST	CHECK		;AND RETURN FOR NEXT SWITCH

NAMED:	PUSHJ	P,GETONE	;FLUSH TERMINATOR
	SETZM	NAMSAV		;ZERO OUT ANY OLD NAME
	SETZM	NAMSAV+1	; THAT STILL REMAINS
	MOVEI	T4,^D12		;12 CHARACTER MAXIMUM
	MOVE	T3,[POINT 6,NAMSAV,]
NAMES1:	SUBI	C,40		;CONVERT TO SIXBIT
NAMES2:	SOJL	T4,.+2		;GOT ENOUGH YET
	IDPB	C,T3		;SAVE CHARACTER
	PUSHJ	P,GETONE	;GET NEXT CHARACTER
	CAIE	C,CR		;<CR> DETECTED
	CAIN	C,LF		; OR <LF>
	JRST	CHECK1		;YES-RETURN FROM TDRMINAL CHAR
	CAIE	C,"/"		;BUMP INTO ANOTHER SWITCH HERE?
	CAIN	C,COMMA		;OR A DELIMITER
	JRST	CHECK		;YES, END OF THIS NAME
	SUBI	C,40		;CONVERT TO SIXBIT
	JRST	NAMES2		;RETURN FOR NEXT CHARACTER

NOLSW:	TRNE	F,LANGUE	;ON $LANGUAGE CARD??
	TLNN	F,DECK		;AND LEGALLY HERE??
	JRST	CHECK		;NOT LEGALLY HERE
	MOVE	T2,[ASCII . /N .]
	PUSHJ	P,SET5		;OUT TO FILE.CTL
	TRZ	F,FRSTWD	;TO BYPASS DEFAULT SWITCH
	JRST	CHECK		;AND RETURN FOR NEXT SWITCH

PAGES:	PUSHJ	P,NUMARG	;GET PAGE ARGUMENT
	HRLM	T1,PAGCAR	;RETAIN FOR QUEUER CALL
	JRST	CHECK1		;RETURN FOR NEXT

PRIOS:	PUSHJ	P,NUMARG	;GET PRIORITY ARGUMENT
	MOVEM	T1,PRISAV	;SAVE IT
	JRST	CHECK1		;RETURN
PROTS:	TRO	F,OCTALN	;CONVERT DIGITS TO OCTAL
	PUSHJ	P,NUMARG	;GET PROTECTION ASKED
	TRZ	F,OCTALN	;RETURN TO DEFAULT
	TRZ	F,FRSTWD	;CLEAR CONVERT TO OCTAL BIT
	CAILE	T1,777		;REASONABLE REQUEST?
	  JRST	ERROR1		;NO, NOT REASONABLE
	TLNE	F,DECK		;IS THIS FOR A CARD DECK??
	JRST	PROT1		; YES, JUST PROTECT THIS FILE
	LSH	T1,^D9		;POSITION FOR QUEUE REQUEST
	ADDM	T1,PRISAV	;STORE FOR QUEUE CALL
	JRST	CHECK1		;RETURN FOR NEXT SWITCH OR CARD
PROT1:	LSH	T1,^D27		;POSITION PROTECTION SPECIFICATION
	MOVEM	T1,THSPRT	;AND SAVE FOR RENAME AT END
	JRST	CHECK1		;AND RETURN FOR MORE

RESTRS:	PUSHJ	P,GETONE	;GET A CHARACTER
	CAIE	C,"_"		;026 VERSION OF ":"
	CAIN	C,":"		;AT DELIMETER YET??
	JRST	RESTRS		;NO, KEEP LOOKING
	PUSHJ	P,GETONE	;GET SECOND CHARACTER
	MOVE	T1,DEPSAV	;DESTINATION
	CAIE	C,"E"		;A "YES" VOTE
	CAIE	C,"F"		;OR AN OFF REQUEST
	TLO	T1,SHORT	;EITHER "YES" OR "ON"
	MOVEM	T1,DEPSAV	;RETURN TO QUEUE CALLER
RESTR1:	PUSHJ	P,GETONE	;WHAT'S NEXT
	CAIE	C,"/"		;ANOTHER SWITCH?
	CAIN	C,SPACE		;OR A SPACE BEFORE SWITCH
	JRST	CHECK1		;YES, RETURN TO SWITCH PROCESSOR
	CAIN	C,","		;COMMA BETWEEN SWITCHES?
	JRST	CHECK		;YES, GET NEXT SWITCH
	CAIE	C,CR		;<CR> DETECTED?
	CAIN	C,LF		;OR A <LF>
	JRST	CHECK1		;YES, RETURN TO CDRSTK
	JRST	RESTR1		;NO-KEEP SEARCHING


SEQSW:	TRNE	F,LANGUE	;HERE FROM $LANGUAGE
	TLNN	F,DECK		;LEGALLY??
	JRST	CHECK		;NO, FLUSH THIS SWITCH
	TRNN	F,CBLCRD	;THIS IS A COBOL SWITCH
	JRST	CRDBAD		;CAN'T DO IT
	MOVE	T2,[ASCII / (S) /]
	PUSHJ	P,SET5		;OUT TO FILE.CTL
	MOVEI	T1,^D72		;RESET WIDTH
	MOVEM	T1,WIDSAV	;FOR SEQUENCED COBOL DECKS
	TRZ	F,FRSTWD	;SO DON'T RETURN FOR DEFAULTS
	JRST	CHECK		;AND RETURN TO NEXT SWITCH

TIMES:	PUSHJ	P,TIMECK	;GET TIME ARGUMENT COMPONENTS
	PUSHJ	P,TIMADD	;AND AMALGUMATE THEM
	HRRM	T1,CORTIM	;RETAIN FOR QUEUER
	JRST	CHECK1		;AND RETURN

TTIME:	PUSHJ	P,NUMARG	;GET # OF MINUTES
	HRRM	T1,TAPPTI	;SAVE FOR QUEUE CALL
	JRST	CHECK1		;RETURN
UNIOS:	PUSHJ	P,NUMARG	;GET NUMERIC ARGUMENT
	CAIL	T1,0		;NEGATIVE NUMBER??
	CAILE	T1,2		;IN RANGE OF 0-2??
	  JRST	ERROR1		;NOT BETWEEN 1-3
	MOVE	T2,DEPSAV	;RETRIEVE FINAL RESTING PLACE
	LSH	T1,^D32		;POSITION BITS
	TLO	T2,(T1)		;SET BITS
	MOVEM	T2,DEPSAV	;RETURN TO QUEUE CALLER
	JRST	CHECK1		;AND RETURN TO SWITCH PROCESSOR

SUBTTL	SWITCH SUBROUTINES

NUMARG:	SETZ	T1,		;INIT
NUMAR1:	PUSHJ	P,GETONE	;GET A CHARACTER
NUMAR2:	CAIE	C,":"		;COLON SEEN?
	CAIN	C,"."		;OR PERIOD ?
	POPJ	P,		;RETURN TO CALLER
	CAIE	C,SPACE		;SPACE SEEN?
	CAIN	C,","		;OR COMMA?
	POPJ	P,		;YES, RETURN TO CALLER
	CAIE	C,"_"		;_==:
	CAIN	C,CR		; END OF LINE YET?
	POPJ	P,
	CAIE	C,"-"		;DAYS-MONTH-YEARS
	CAIN	C,LF		;LINE FEED YET?
	POPJ	P,		;YES RETURN
	CAIN	C,"/"		;AT NEXT SWITCH??
	POPJ	P,		;YES, RETURN
	CAIL	C,"0"		;ARGUMENT BETWEEN 0
	CAILE	C,"9"		;AND 9
	JRST	KCHECK		;OR THE ALPHA "K"?
	SUBI	C,"0"		;DIGITIZE CHARACTER
	TRNN	F,OCTALN	;OCTAL OR DECIMAL CONVERSION??
	JRST	DECNUM		; DECIMAL
	IMULI	T1,10		;DO THE OCTAL CONVERT
	JRST	DECNM1		;AND KEEP WORKING
DECNUM:	IMULI	T1,^D10		;SHIFT T1 OVER FOR NEXT DIGIT
DECNM1:	ADD	T1,C		;PUT CHAR IN AT TAIL END
	JRST	NUMAR1		;RETURN FOR MORE

KCHECK:	CAIE	C,"K"		;WAS NUMBER SUFFIXED WITH "K"
	  PJRST	ERROR1		;NO, SWITCH IS ILLEGAL
	IMULI	T1,^D1000	;USE THE K FACTER
	JRST	NUMAR1		;RETURN TO PROCESS NUMBER


TIMECK:	SETZB	T4,SECOND	;INITIALIZATION
	SETZB	T1,MINUTE	;DON'T GIVE HOURS FOR FREE
	CAIN	C,"+"		;FUTURE TIME SPECIFICATION?
	MSTIME	T1,		;YES GET TIME IN MSTIME
	IDIVI	T1,^D1000	;CONVERT TO SECONDS
	MOVE	T4,T1		;AND SAVE IN T4
	CAIN	C,"."		;FRACTIONAL SPECIFICATION
	JRST	MSEC		;YES GO PROCESS
TIMEC1:	PUSHJ	P,NUMARG	;GET ONE ARGUMENT
	MOVE	T2,MINUTE	;TO UPGRADE HOURS
	MOVEM	T2,HOURS	;UPGRADE HOURS
	MOVE	T2,SECOND	; TO UPGRADE MINUTES
	MOVEM	T2,MINUTE	;UPGRADE MINS.
	MOVEM	T1,SECOND	;AND STORE LAST ARG AT BOTTOM
	CAIE	C,"_"
	CAIN	C,":"		;MORE ARGUMENTS?
	JRST	TIMEC1		;YES, GO PROCESS
	CAIE	C,"."		;FRACTIONAL PART FOLLOWS?
	POPJ	P,		;NO, LEAVE TIME ARG ROUTINE
MSEC:	PUSHJ	P,NUMARG	;GET FRACTIONAL ARGUMENT
	MOVEM	T1,MILSEC	;SAVE IT
	POPJ	P,		;RETURN TO TIME ROUTINE
TIMADD:	SKIPE	T3,HOURS	;RETRIEVE ANY HOUR ARGUMENT
	IMULI	T3,^D3600	;MAKE HOURS==SECS
	MOVE	T1,T3		;KEEP SECS. IN T1
	SKIPE	T3,MINUTE	;RETRIEVE MINS. IF ANY
	IMULI	T3,^D60		;MAKE MINS==SECS
	ADD	T1,T3		;ADD TO SECS
	ADD	T1,SECOND	;ADD IN SECONDS
	ADD	T1,T4		;AND FUTURE
	POPJ	P,		;RETURN

DEDAFT:	SETZB	T1,BUFLOG	;ZERO STORAGE POINTS
	SETZB	T2,HOURS
	SETZB	T3,MINUTE
	SETZB	T4,SECOND
	SETZM	MILSEC
	PUSHJ	P,GETONE	;GET THE FIRST CHARACTER
	CAIE	C,"+"		;A FUTURE RELATIVE TIME?
	JRST	DEDAF1		;NO, SOME TIME SPECIFIED
	PUSHJ	P,TIMECK	;GO GET COMPONENTS
	SKIPN	HOURS		;SEE IF OF FORM +HHMM RATHER THAN +HH:MM:SS
	SKIPE	MINUTE		;...
	  CAIA			;SKIP, BECAUSE +HH:MM:SS
	PUSHJ	P,[MOVE T1,SECOND	;IT'S OF FORM +HHMM
		   IDIVI T1,^D100	;CONVERT TO HOURS & MINUTES
		   MOVEM T1,HOURS	;STORE HOURS
		   MOVEM T2,MINUTE	;AND MINUTES
		   SETZM SECOND		;CLEAR SECONDS FIELD
		   POPJ P,0]		;RETURN TO MAIN-LINE
	PUSHJ	P,TIMADD	;AND AMALGUMATE INTO SECS.
	IMULI	T1,^D1000
	MOVEM	T1,MILSEC	;SAVE MILSECS IN MILSEC
	JRST	GOTNOW
DEDAF1:	CAIN	C,SPACE		;IS CHARACTER A SPACE?
	JRST	DEDAFT		;YES, GET NEXT CHARACTER
	CAIN	C,CR		;END OF SPECIFICATION
	JRST	GOTNOW		;YES, FALL THROUGH
	CAIL	C,"0"		;IS CHARACTER A NUMBER
	CAILE	C,"9"		;BETWEEN 0-9?
	JRST	MONTH		;NO DAY SPECIFIED?
	PUSHJ	P,NUMAR2	;GET ALL OF DAY SPECIFIED
	MOVE	T4,T1		;SAVE DAY IN T4
	CAIE	C,SPACE		;END OF DATE SPECIFIER
	CAIE	C,"-"		;END OF DAY DELIMETER
	JRST	HOURTM		;HAVE TIME NEXT?
	PUSHJ	P,GETONE	;GET NEXT CHARACTER
MONTH:	CAIL	C,"0"		;IS THIS A NUMBER FOR MONTH
	CAILE	C,"9"		;BETWEEN 0-9
	JRST	MONTH1		;NO, CHECK ALPHAS
	PUSHJ	P,NUMAR2	;GET MONTH NUMBER
	MOVE	T3,T1		;SAVE MONTH NUMBER
	JRST	YEAR		;GET YEAR SPECIFICATION IF THERE
MONTH1:	SETZ	T3,
	MOVEI	P3,3		;CHARACTERS TO MONTH
MONTH2:	SUBI	C,SPACE		;MAKE SIXBIT
	LSH	T3,6		;PREPARE TO STORE LETTER
	ADD	T3,C		;STORE THE LETTER
	PUSHJ	P,GETONE	;GET NEXT CHARACTER
	CAIE	C,"-"		;END OF MONTH SPECIFIER?
	SOJGE	P3,MONTH2	;MAKE SURE HAVE ALL OF MONTH
MONTH4:	MOVSI	P3,-MONEND
MONTH5:	HRLZ	P2,T3
	XOR	P2,MONTAB(P3)
	TLNN	P2,777777	;ARE TWO VALUES EQUAL?
	JRST	MONTH6		;YES, GO OUT
	AOBJN	P3,MONTH5	;GET NEXT ENTRY
	  JRST	CDERR		;ERROR

MONTAB:
	<SIXBIT /JAN/>+0
	<SIXBIT /FEB/>+^D31
	<SIXBIT /MAR/>+^D59
	<SIXBIT /APR/>+^D90
	<SIXBIT /MAY/>+^D120
	<SIXBIT /JUN/>+^D151
	<SIXBIT /JUL/>+^D181
	<SIXBIT /AUG/>+^D212
	<SIXBIT /SEP/>+^D243
	<SIXBIT /OCT/>+^D273
	<SIXBIT /NOV/>+^D304
	<SIXBIT /DEC/>+^D334
MONEND=.-MONTAB

MONTH6:	HRRZ	T3,P3		;GET NUMBER OF MONTH-1
	ADDI	T3,1		;NUMBER OF MONTH
YEAR:	CAIE	C,"-"		;DELIMETER PRESENT?
	PUSHJ	P,GETONE	;NO, GET IT THROUGH
	PUSHJ	P,NUMARG	;GET YEAR SPECIFIER
	SUBI	T1,^D64		;TO CONVERT TO EXPECTED FORMAT
	IMULI	T1,^D12
	SUBI	T3,1
	ADD	T1,T3
	SUBI	T4,1
	IMULI	T1,^D31
	ADD	T1,T4
	MOVEM	T1,BUFLOG
YEAR1:	CAIE	C,SPACE
	JRST	YEAR2
	PUSHJ	P,GETONE
	JRST	YEAR1
YEAR2:	SETZB	T4,T1		;ZERO TIME ARG IN CASE NONE SPECIFIED
	CAIL	C,"0"
	CAILE	C,"9"
	 JRST	HOURTM
	PUSHJ	P,NUMAR2	;(NOTE THAT T1 WAS CLEARED AT YEAR2)
	MOVE	T4,T1		;SAVE ARGUMENT IN T4 (HACK)

HOURTM:	SETZM	MILSEC		;ZERO OUT FINAL POINT
	CAIE	C,SPACE		;FLUSH SPACES
	JRST	HRTM1		;PASSED SPACES HERE
	PUSHJ	P,GETONE	;GET A CHARACTER
	JRST	HOURTM		;TO FLUSH SPACES
HRTM1:	MOVE	T1,T4		;GET TIME ARG INTO T1
	IDIVI	T1,^D100	;HRS IN T1, MIN IN T2
	IMULI	T1,^D60		;CONVERT HRS TO MINS
	ADD	T1,T2		;GET MINS TOGETHER
	IMULI	T1,^D60		;CONVERT TO SECS
	IMULI	T1,^D1000	;AND THEN TO MILSECS
	MOVEM	T1,MILSEC	;AND SAVE FOR LATER

GOTNOW:	SKIPN	T2,BUFLOG	;HAVE A DATE ALREADY?
GETNOW:	DATE	T2,		;NO, GET TODAYS
	IDIVI	T2,^D12*^D31	;T2=YEARS-1964
	IDIVI	T3,^D31		;T3=MOS.-JAN,T4=DAYS-1
	HRRZ	P3,MONTAB(T3)
	ADD	T4,P3		;T4=DAYS-JAN 1
	SETZ	P3,		;LEAP YEAR ADDITIVE IF JAN-FEB
	CAIL	T3,2		;WHAT'S THE MONTH
	MOVEI	P3,1		;ADDITIVE IF MAP-DEC
	MOVE	T1,T2		;SAVE YEARS FOR REUSE
	IDIVI	T2,4
	CAIE	T3,0		;IS THIS A LEAP YEAR
	SETZ	P3,		;NO,FLUSH ADD
	ADDI	T4,DATOFS(T2)	;T4=DAYS BEFORE 1-JAN-64+SINCE
				; 1-JAN+ALLOWANCE FOR ALL LEAP YEARS SINCE 64
	MOVE	T2,T1		;RESTORE YEARS SINCE 1964
	IMULI	T2,^D365	;DAYS SINCE 1964
	ADD	T4,T2		;T4=DAYS EXCEPT FOR 100 YR FUDGE
	HRREI	T2,^D64-^D99(T1)
	JUMPLE	T2,GETNW1
	IDIVI	T2,^D100
	SUB	T4,T2
	CAIE	T3,^D99
GETNW1:	ADD	T4,P3
	MOVE	T1,MILSEC
	IDIVI	T1,^D330
	HRLZI	T4,(T4)		;GET DATE IN LH
	ADD	T1,T4		;ADD IN TIME (OVERFLOW DATE IF PAST MIDNIGHT)
	POPJ	P,

SUBTTL	QUEUE CALL ROUTINE


OUTQUE:	SETZM	LOCSAV		;WORD 0 OF QUEUE CALL
	MOVEI	T1,VERNUM	;LINE 1 STARTS WITH VERNUM
	LSH	T1,^D27		; LEFT JUSTIFIED
	ADDI	T1,201		; AND "201" RT JUSTIFIED
	MOVEM	T1,QUECAL	; PUT INTO QUEUE CALL ARGUMENT
	MOVE	T1,[XWD 31014,2]
	SKIPE	T2,ERRFIL	;WAS AN ERROR FILE NAMED??
	SUBI	T1,1		;ONLY ONE FILE FOR QUEUER
	MOVEM	T1,QUECA1	;HEADER LENGTH==31
				;2 FILES OF LENGTH 14 IN REQUEST
	MOVSI	T1,'LPT'
	MOVEI	T2,CDR		;TO DO THE WHERE
	WHERE	T2,		;GET THE STATION LOCATION
	  SETZ	T2,		;DEFAULT TO ZERO
	SKIPN	T2		;GREATER THAN ZERO??
	  JRST	OUTQUX		;NO, JUST USE LPT
	LSH	T2,6		;SHIFT OVER TO PUT IN MESSAGE
	HLR	T3,[SIXBIT /S0 /]
	ADD	T2,T3		;TO APPEND STATION NUMBER
	HRR	T1,T2		;PUT DEVICE NAME TOGETHER
OUTQUX:	SKIPN	T2,ERRFIL
	MOVSI	T1,'INP'
	MOVEM	T1,QUECA2	;FLAG QUEUE CALL AS INPUT
	MOVE	T1,OLNAME	;FOR FILE NAME
	MOVEM	T1,QUELOG+7	;FILE.LOG NAME
	MOVEM	T1,QUECTL+7	;FILE.CTL NAME
	HRLZI	T1,4000		;FOR LOGOUT BY BATCON
	ADDM	T1,DEPSAV	;IN LH OF WD. 20 OF QUEUE CALL
	MOVE	T1,PRISAV	;HAS USER SPECIFIED OWN PROTECTION?
	TRNE	T1,777000	;ANY CHANGE COUNTS
	JRST	OUTQU1		;LET HIM HAVE OWN WAY
	MOVE	T1,[XWD 12,16]
	GETTAB	T1,		;GET STANDARD PROTECTION
	MOVSI	T1,055000	;DEFAULT PROTECTION==055
	LSH	T1,-22		;GET PROTECTION IN POSITION
	ADDM	T1,PRISAV	;AND SAVE IT IN QUEUE CALL
	SKIPN	T1,ERRFIL	;ANY ERROR FILE ESTABLISHED?
	JRST	OUTQU1		;NO, BYPASS SPECIAL PROCESSING
	MOVE	T1,[SIXBIT /CDRSTK/]
	MOVEM	T1,NAMSAV	;AND DUB THIS USER AS "CDRSTK"
	MOVE	T1,[SIXBIT /-ERROR/]
	MOVEM	T1,NAMSAV+1	; -ERROR"
	SETZM	DEPSAV		;CLEAR DEPENDS PARAMETER
	MOVE	T1,[XWD 10,2]
	MOVEM	T1,CORTIM	;FOR LIMIT OUT SPECIFICATION
	MOVE	T1,PRISAV	;TO RESET PRIORITY
	TRZ	T1,77		;CLEAR OUT ANY OLD PRIORITY
	TRO	T1,50		; AND RESET PRIORITY TO 40
	MOVEM	T1,PRISAV	; AND SAVE


OUTQU1:	MOVSI	T1,(SIXBIT /CTL/)
	SKIPE	T2,ERRFIL	;ANY ERROR FILE TO LIST??
	MOVSI	T1,'LPT'	; YES, MAKE EXTENSION=='LPT'
	MOVEM	T1,QUECTL+10	;PUT EXTENSION IN CALL
	MOVSI	T1,(SIXBIT /LOG/)
	MOVEM	T1,QUELOG+10
	MOVE	T1,OUDEV
	MOVEM	T1,QUELOG	;DEVICE==DSK
	MOVEM	T1,QUECTL	;FOR FILE.LOG AND FILE.CTL
	MOVE	T1,PPNS		;RETRIEVE USER PROJ,,PROG PAIR
	SKIPE	T2,ERRFIL	;ANY ERROR FILE GENERATED??
	MOVE	T1,RUNNER	; YES, GET RUNNER'S PPN
	MOVEM	T1,QUELOG+1
	MOVEM	T1,QUECTL+1
	MOVEM	T1,QUEC23
	SKIPE	T2,ERRFIL	;NEED PPN IN OTHER PLACES?
	MOVEM	T1,QUECA2+1	; YES, PUT IT IN!!
	MOVEI	T1,111301	;SPACING==1,FORMAT==ASCII
				;POST DISPOSITION==DELETE,1 COPY
	SKIPE	T2,ERRFIL	;ERROR FILE EXIST??
	MOVEI	T1,111201	;MAKE DISPOSITION==RENAME
	MOVEM	T1,QUELOG+13
	MOVEM	T1,QUECTL+13
	MOVEI	T1,1
	MOVEM	T1,QUELOG+12
	MOVEM	T1,QUECTL+12
	MOVE	T1,[XWD 62,LOCSAV]
	SKIPE	T2,ERRFIL	;ANY ERROR FILE??
	MOVE	T1,[XWD 46,LOCSAV]
	PUSHJ	P,QUEUER	;NOTIFY QUEUER
	SETZM	ERRFIL		;CLEAR OUT ANY OLD ERROR FILE NAME
	POPJ	P,		;RETURN TO NEXT JOB
SUBTTL	COMMONLY USED SUBROUTINES

;SUBROUTINE TO MASK OUT SWITCH/COMMAND TABLE ENTRIE(S)
;     TO TH NUMBER OF CHARACTERS INPUT BY OPERATOR OR CARD

TRYIT:	MOVE	T4,T1		;COPY INPUT INTO T4
	MOVNI	T2,1		;SET UP MASK IN T2
	LSH	T2,-6		;PEEL OFF ONE CHARACTER
	LSH	T4,6		;AND ONE OFF OF COMMAND OR SWITCH
	JUMPN	T4,.-2		;KEEP GOING UNTIL NO CHARACTERS
	POPJ	P,		;RETURN WITH MASK IN T2

;SUBROUTINE TO INPUT NEXT TTY CHARACTER


NXCHAR:	ILDB	C,CTIBUF+1	;INPUT A CHARACTER
	CAIN	C,32		;^Z
	JRST	CONTZ		; EXIT ON ^Z
	CAIE	C,CNTLC		;CONTROL C INPUT?
	JRST	NXCHR1		;NO, GET NEXT CHARACTER
	ILDB	C,CTIBUF+1	;GET <CR>
	ILDB	C,CTIBUF+1	;GET <LF>
CONTZ:	POP	P,T1		;GOT HERE VIA A PUSHJ
	MOVEI	T1,1		;TO EXIT WITHOUT DISRUPTION
	EXIT	T1,		;DO THE GRACEFUL EXIT
	JRST	GOTOIT		;RETURN TO OPERATOR IF "CONT"
NXCHR1:	CAIE	C,177		;IS THIS A DELETE??
	CAIN	C,TAB		;FLUSH TABS HERE
	JRST	NXCHAR		;RETURN FOR NEXT CHARACTER
	CAIL	C,174		;ALTMODES??
	MOVEI	C,33		;YES
	JUMPE	C,NXCHAR	;FLUSH BLANKS
	CAILE	C,140		;LOWER CASE ALPHA??
	SUBI	C,40		;YES, CAPITALIZE IT
	POPJ	P,		;RETURN WITH CHARACTER IN "C"


;SUBROUTINE TO INPUT STRING OF UP TO 6 CHARACTERS WITH
; THE FIRST CHARACTERS RETURNED IN T1,  ANY SUBSEQUENT
; CHARACTERS PRIOR TO THE SPACE, COMMA, OR <LF> ARE
; FLUSHED AND THE TERMINAL CHARACTER IS RETURNED IN "C".

SIXCHR:	MOVEI	T4,6
	MOVE	T3,[POINT 6,T1]
SIXCH1:	PUSHJ	P,NXCHAR	;INPUT ONE CHARACTER
SIXCH2:	CAIN	C,CR		;END OF LINE??
	JRST	SIXCH1		;RETRIEVE <LF> AND HIT POPJ
	CAIG	C,"Z"		;IS "C" OUT OF RANGE
	CAIGE	C,"0"		;OF ALPHANUMERICS??
	POPJ	P,		;YES, IT'S TERMINATOR
	CAIGE	C,"A"		;IS IT ALPHABETIC?
	CAIG	C,"9"		;OR NUMERIC?
	JRST	ALPNUM		;EITHER IS ACCEPTABLE
	POPJ	P,
ALPNUM:	SOJL	T4,SIXCH1	;HAVE SIX CHARACTERS YET?
	SUBI	C,40		;MAKE CHARACTER SIXBIT
	IDPB	C,T3		;DEPOSIT CHARACTER IN T1
	JRST	SIXCH1		;AND RETURN FOR NEXT CHARACTER

SUBTTL	ERROR MESSAGES


ERROR1:	TRZE	F,TYPED		;WHOSE ERROR IS THIS??
	  JRST	OPERR		;OPERATOR'S
	PUSHJ	P,TIME1		;START LINE WITH TIMESTAMP
	MOVE	T2,[ASCII /STERR/]
	PUSHJ	P,OUTLO5	;OUTPUT TO FILE.LOG
	PUSHJ	P,OUTTAB	;FOLLOWED BY A TAB
	MOVE	T2,[ASCII /CARD#/]
	PUSHJ	P,OUTLO5	;FOLLOWED BY #CARD#"
	MOVE	T1,CRDCNT	;GET CARD COUNT
	PUSHJ	P,LOGTIM	;OUTPUT CARD COUNT
	PUSHJ	P,OUTTAB	;TAB OVER 
	MOVE	T2,[ASCII /SWITC/]
	PUSHJ	P,OUTLO5	;"SWITCH ERROR"
	MOVE	T2,[ASCII /H ERR/]
	PUSHJ	P,OUTLO5
	MOVE	T2,[ASCII /OR/]
	PUSHJ	P,OUTLO5
	PUSHJ	P,CDERR2
	JRST	CHECK

DEVCHK:	TRNN	F,CDRFLA		;DEVICE==CDR??
	JRST	CPOPJ1		;YES, JUST CONTINUE PROCESSING
	PUSHJ	P,TIME1		;TIMESTAMP FIRST LINE OF MESSAGE
	MOVE	T2,[ASCII /STERR/]
	PUSHJ	P,OUTLO5	;OUTPUT MESSAGE TYPE TO FILE.LOG
	PUSHJ	P,OUTTAB	;FOLLOWED BY A TAB
	MOVE	T2,[ASCII /CARD#/]
	PUSHJ	P,OUTLO5
	MOVE	T1,CRDCNT	;WHAT IS THE CARD NUMBER??
	PUSHJ	P,LOGTIM	;OUTPUT AS A DECIMAL NUMBER
	PUSHJ	P,OUTTAB	;FOLLOWED BY A TAB
	MOVE	T2,[ASCII /MODE /]
	PUSHJ	P,OUTLO5	;FOLLOWED BY ERROR TYPE
	MOVE	T2,[ASCII /ERROR/]
	PUSHJ	P,OUTLO5	;"MODE ERROR"
	TRO	F,CARDER	;NOT REALLY A FATAL ERROR, JUST ADVISE
	PJRST	CDERR2

INFAL:	IFN	SUBROU,<
	PUSHJ	P,LOCREL	;GO BACK TO RELEASE INTERLOCK>
INFAI:	OUTSTR	[ASCIZ/
? OUTPUT DEVICE INIT FAILED
/]
	TRZ	F,OKAY+STAR
	TLO	F,NOQUE
	TRO	F,FATAL
	  PJRST	CRDBAD		;ADD INSULT TO INJURY
ENTFAL:	PUSH	P,T1		;SAVE ERROR CODE
	IFN	SUBROU,<
	PUSHJ	P,LOCREL	;GO WAY BACK TO RELEASE INTERLOCK
>
	POP	P,T1		;RETRIEVE ERROR CODE FOR MESSAGE
ENTFAI:	OUTSTR	[ASCIZ/
? ENTRY FAILED
/]
	CAIN	T1,0		;REALLY AN ERROR
	  JRST	ENTFA1		;???????????????
	SUBI	T1,1		;FOR PROPER TABLE POSITION
	CAIGE	T1,26		;TRULY AN ERROR FAILURE?
	OUTSTR	@ENTFL(T1)	;YES, OUTPUT THE APPROPRIATE ERROR
ENTFA1:	TRZ	F,OKAY+STAR
	TRO	F,FATAL
	TLO	F,NOQUE
	OUTSTR	CARDB
	  PJRST	CRDBAD		;BAD CARD ABORTS JOB

ENTFL:	EXP	ERFNF		;FILE NOT FOUND
	EXP	ERIPP		;INCORRECT PROJ,,PROG PAIR
	EXP	ERPRT		;PROTECTION FAILURE
	EXP	ERFBM		;FILE BEING MODIFIED
	EXP	ERAEF		;ALREADY EXISTING FILENAME
	EXP	ERISU		;ILLEGAL SEQUENCE OF UUO
	EXP	ERTRN		;DEVICE OR DATA ERROR
	EXP	ERNSF		;NOT A SAVED FILE
	EXP	ERDNA		;DEVICE NOT AVAILABLE
	EXP	ERNSD		;NO SUCH DEVICE
	EXP	ERILU		;ILLEGAL UUO
	EXP	ERNRM		;NO ROOM OR QUOTA EXCEEDED
	EXP	ERWLK		;WRITE LOCK ERROR
	EXP	ERNET		;NOT ENOUGH TABLE SPACE IN CORE
	EXP	ERPOA		;PARTIAL ALLOCATION ONLY
	EXP	ERBNF		;BLOCK NOT FREE ON ALLOCATED POSITION
	EXP	ERRSD		;CAN'T SUPERCEDE AN EXISTING DIRECTORY
	EXP	ERDNE		;CAN'T DELETE A NON-EMPTY DIRECTORY
	EXP	ERSNF		;SUB-DIRECTORY NOT FOUND
	EXP	ERSLE		;SEARCH LIST EMPTY
	EXP	ERLVL		;NESTING TOO DEEP IN SFD
	EXP	ERNCE		;NO LEGAL STRUCTURE FOR THIS JOB

ERFNF:	ASCIZ	/  FILE NOT FOUND
/

ERIPP:	ASCIZ	/  INCORRECT PROJECT PROGRAMMER PAIR
/

ERPRT:	ASCIZ	/  PROTECTION FAILURE
/

ERFBM:	ASCIZ	/  FILE BEING MODIFIED
/

ERAEF:	ASCIZ	/  ALREADY EXISTING FILENAME
/

ERISU:	ASCIZ	/  ILLEGAL SEQUENCE OF UUO S
/

ERTRN:	ASCIZ	/  DEVICE OR DATA ERROR
/

ERNSF:	ASCIZ	/  NOT A SAVED FILE
/
ERDNA:	ASCIZ	/  DEVICE NOT AVAILABLE
/

ERNSD:	ASCIZ	/  NO SUCH DEVICE
/

ERILU:	ASCIZ	/  ILLEGAL UUO
/

ERNRM:	ASCIZ	/  NO ROOM OR QUOTA EXCEEDED
/

ERWLK:	ASCIZ	/  WRITE-LOCK ERROR
/

ERNET:	ASCIZ	/  NOT ENOUGH TABLE SPACE
/

ERPOA:	ASCIZ	/  PARTIAL ALLOCATION ONLY
/
ERBNF:	ASCIZ	/  BLOCK NOT FREE ON ALLOCATED POSITION
/

ERRSD:	ASCIZ	/  CAN'T SUPERCEDE AN EXISTING DIRECTORY
/

ERDNE:	ASCIZ	/  CAN'T DELETE A NON-EMPTY DIRECTORY
/

ERSNF:	ASCIZ	/  SUB-DIRECTORY NOT FOUND
/

ERSLE:	ASCIZ	/  SEARCH LIST EMPTY
/

ERLVL:	ASCIZ	/  NESTING TOO DEEP ON SFD
/

ERNCE:	ASCIZ	/  NO LEGAL STRUCTURE FOR THIS JOB
/


NOCARD:	PUSH	P,T1		;GET AN AC TO WORK WITH
	MOVE	T1,JOBIN2	;GET PC OF TRAP
	MOVEM	T1,OLDPC	;AND SAVE IT
	HRRZ	T1,JOBIN3	;GET CHANNEL NO.
	SETZM	JOBIN2		;CLEAR INTERRUPT LOCNS SO THAT WE CAN
	SETZM	JOBIN3		;  GET HERE AGAIN
	CAIE	T1,CDR		;IS INTERCEPT FOR CDR?
	JRST	[OUTSTR	[ASCIZ	/?HUNG OUTPUT DEVICE - TYPE "CONT" TO TRY AGAIN
/]
		EXIT	1,
		JRST	NOCRD1]
NOCRD1:	MOVEI	T1,^D10		;SLEEP FOR 10 SEC
	SLEEP	T1,		;...
	AOS	HNGCNT		;COUNT OCCURRENCES
	POP	P,T1
	JRSTF	@OLDPC		;RETRY


READER:	OUTSTR	[ASCIZ/
?CARD READER MOTION ERROR, REPLACE LAST CARD AND TYPE "CONT"
*/]
READR1:	INPUT	TTY,		;GET A RESPONSE
	MOVEI	T1,10
	TLNE	F,ASCII
	MOVEI	T1,1
	SETSTS	CDR,(T1)
	PUSHJ	P,NXCHAR	;GET A CHARACTER
	MOVE	T1,C		;SAVE FIRST CHARACTER IN T1
	PUSHJ	P,NXCHAR	;GET NEXT CHARACTER
	CAIE	C,LF		;END OF TYPE-IN DETECTED?
	JRST	.-2		;NO, KEEP FLUSHING CHARACTERS
	CAIN	T1,"C"		;DID HE WANT TO CONTINUE??
	JRST	READR2		;GO WAKE THE OPERATOR AGAIN
	OUTSTR	[ASCIZ /?
	*/]
	JRST	READR1

READR2:	OUTSTR	[ASCIZ/
!/]
	POPJ	P,		;RETURN TO CALLER




BITERR:	PUSHJ	P,TIME1		;TIMESTAMP THE LINE
	MOVE	T2,[ASCII /STERR/]
	PUSHJ	P,OUTLO5
	PUSHJ	P,OUTTAB
	MOVE	T2,[ASCII /BINAR/]
	PUSHJ	P,OUTLO5
	MOVE	T2,[ASCII /Y CAR/]
	PUSHJ	P,OUTLO5
	MOVE	T2,[ASCII /D ERR/]
	PUSHJ	P,OUTLO5
	MOVE	T2,[ASCII /OR***/]
	PUSHJ	P,OUTLO5
	TRO	F,FATAL
	PUSHJ	P,OUTLIN	;OUTPUT THIS LINE
	PJRST	CDERR		;FOLLOWED BY SPECIFICS

MODERR:	PUSHJ	P,TIME1		;TIMESTAMP OUTPUT
	MOVE	T2,[ASCII /STERR/]
	PUSHJ	P,OUTLO5	;CLASSIFY MESSAGE AS ERROR
	PUSHJ	P,OUTTAB
	MOVE	T2,[ASCII /NON-B/]
	PUSHJ	P,OUTLO5	;START MESSAGE TO USER
	MOVE	T2,[ASCII /INARY/]
	PUSHJ	P,OUTLO5
	MOVE	T2,[ASCII / CARD/]
	PUSHJ	P,OUTLO5
	MOVE	T2,[ASCII / IN B/]
	PUSHJ	P,OUTLO5
	MOVE	T2,[ASCII /INARY/]
	PUSHJ	P,OUTLO5
	MOVE	T2,[ASCII / DECK/]
	PUSHJ	P,OUTLO5
	TRO	F,FATAL
	PUSHJ	P,OUTLIN
	PJRST	CDERR

STARFL:	OUTSTR	[ASCIZ/
?CANNOT FIND FILE
/]
	SETZM	PHYNAM
	TRZ	F,STAR
	JRST	STRTUP

LOCFAI:	OUTSTR	[ASCIZ/
?INTERLOCK FAILURE
/]
	TRZ	F,STAR
	  PJRST	CRDBAD



DECFAI:	OUTSTR	[ASCIZ/
? ENTER FAILED FOR DATA OR LANGUAGE FILE
/]
	HRRZ	T2,T2		;GET MONITOR DETECTED ERROR TYPE
	CAIN	T2,0		;A REAL ERROR OR A BUG??
	JRST	DECFA1		;A BUG*****
	SUBI	T2,1		;SET FOR ERROR PRINTING
	CAIGE	T2,20		;WITHIN RANGE??
	OUTSTR	@ENTFL(T2)	;TELL TYPE OF ERROR
DECFA1:	OUTSTR	CARDB		;OUTPUT OFFENDING CARD
	TRZ	F,STAR+DECK	;ZERO START AND DECK FLAGS
	TLO	F,NOQUE		;SET NO QUEUE ENTRY FLAG
	  JRST 	CRDBAD		;GO BADMOUTH USER
SUBTTL	"HELP" MESSAGES


NOTYOU:	ASCIZ	/?NO ACCESS PRIVS FOR FILE
/

OPRAB:	ASCIZ	/JOB ABORTED BY OPERATOR /
OPRSTP:	SIXBIT	/JOB STOPPED BY OPERATOR /
OPRCON:	SIXBIT	/CONTINUED BY OPERATOR /

ENDMS1:	ASCIZ	/END OF FILE AFTER /
ENDMS2:	ASCIZ	/HOLLERITH ERRORS
/

HOLER:	ASCIZ	/JOB ABORTED-HOLLERITH ERRORS
/



XLIST				;LITERALS
LIT
LIST

RELOC

ENDER:	END	START
 )%)