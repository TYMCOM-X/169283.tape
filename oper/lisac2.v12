BASE 0

GLOBAL %NEWGET

%NEWGET


GLOBAL USER(10), CUST(81), ICODE, MODE, IER, PPN

GLOBAL IOTAB(WPF)

LOCAL %BYPT, %NUMOUT, %MAKE.SIXBIT

LOCAL %INIT.NEWGET, %RET.USER.AND.PPN.INFO, %RET.USER.INFO
LOCAL %SEARCH, %LOOK.FOR.IT, %RET.CUST.AND.NUM.INFO, %RET.CUST.INFO
LOCAL %GET.NEXT, %SAVE.INFO, %OPEN.FILE, %SET.UP.ADDR
LOCAL %MAKE.OVER, %DEL.RECORD, %FIND.ROOM


LOCAL CHK.ERR:,GO.BACK:

LOCAL USRBLK(128), USR.CH, N.USR.BLK, USER.NAMES, USER.EXT
LOCAL CUSBLK(1280), CUS.CH, N.CUS.BLK, CUSTOM.NAMES,CUSTOM.EXT
LOCAL SIZE.USER.NAMES, SIZE.CUSTOM.ERS
LOCAL INDEX, P1, PTR, SPACE, SAVE.SIZE, SAVE.ADDR(25), WD.CNT

!ICODE VALUES
DEF INIT.READ AS 1
DEF INIT.UPDATE AS 2
DEF READ.SPECIFIC AS 3
DEF READ.NEXT AS 4
DEF WRITE.ENTRY AS 5
DEF CLOSE.ACTG AS 6
DEF REMOVE AS 7
DEF NXT.USER.FOR.CUST AS 8
DEF CHG.SITE.ONLY AS 9

!MODE VALUES
DEF ASC.USER.MODE AS -2
DEF SIX.USER.MODE AS -1
DEF ASC.CUST.MODE AS 0
DEF SIX.CUST.MODE AS 1

!IER VALUES
DEF OK AS 0
DEF NOT.FOUND AS 1
DEF END.OF.FILE AS 2
DEF MISC.ERR AS 3
DEF FILE.BUSY AS 4

!WORDS IN USER
DEF RET.PPN AS 0
DEF RET.P.CODE AS 1
DEF RET.T.CODE AS 2
DEF RET.SLS AS 3
DEF RET.U.CUST AS 4
DEF RET.SITES AS 5
DEF RET.PRIV AS 7
DEF RET.USER.NAME AS 8

!WORDS IN CUST
DEF RET.C.NUM AS 0
DEF RET.B.DIST AS 1
DEF RET.CUST.NAME AS 9
DEF RET.ADDR AS 15
DEF RET.MAIL.ADD AS 45
DEF RET.MIN AS 75
DEF RET.TIMSH AS 77
DEF RET.ST.INV AS 81

!WORDS IN USRBLK
DEF WD.PPN AS 0
DEF WD.CODES AS 1
DEF WD.PRIV AS 1
DEF WD.SLS.CUST AS 2
DEF WD.U.SIZE AS 1
DEF WD.SITES AS 3
DEF WD.USER.NAME AS 4

!WORDS IN CUSBLK
DEF WD.B.DIST AS 0
DEF WD.CUST AS 0
DEF WD.ST.INV AS 0
DEF WD.MIN AS 0
DEF WD.TIMSH AS 0
DEF WD.C.SIZE AS 1
DEF WD.CUST.NAME AS 7
DEF WD.ADDR AS 13

LOCAL REC.CHANGED
   DEF NOT.CHANGED AS 0
   DEF CHANGED AS 1

LOCAL U.SEQ.FLG
LOCAL C.SEQ.FLG
   DEF NOT.CALLED AS 0
   DEF CALLED AS 1

LOCAL BEEN.HERE
   DEF ALLREADY AS OCT 525252525252

DEF ASC.RET(A,B,C) AS [P1 _ CHPT(A,-1); PTR _ BYPT(B,1,6);&
	REPEAT C NCHV P1 _ NCHV PTR + OCT 40]
DEF B.DIST AS BYT(CST(WD.B.DIST),8,18)
DEF CK.ROOM(A,B) AS IF INDEX + A >= SIZE.BLOCK * B
DEF C.SIZE AS BYT(CST(WD.C.SIZE),7,28)
DEF CST(A) AS CUSBLK(INDEX+A)
DEF CUST.MODE AS MODE >= ASC.CUST.MODE
DEF CUST.NUM AS BYT(CST(WD.CUST),17,0)
DEF CUST.WRITE AS [SETCP(CUS.CH,FIXCP(N.CUS.BLK)); WB(CUS.CH,SIZE.BLOCK*10,CUS.BLK)]
DEF END.OF.ADDR AS OCT 77
DEF END.OF.LINE AS OCT 76
DEF GET.C.OVERFLOW(A) AS [N.CUS.BLK _ A; READ.FROM.CUST]
DEF GET.U.OVERFLOW(A) AS [N.USR.BLK _ A; READ.FROM.USER]
DEF FIXCP(A) AS (A-1) * SIZE.BLOCK
DEF INC.C.INDEX AS INDEX + _ C.SIZE
DEF INC.U.INDEX AS INDEX + _ U.SIZE
DEF MAX.CODE AS 9
DEF MIN.BIT AS BYT(CST(WD.MIN),1,17)
DEF MAX.CST.SIZE AS 66
DEF MIN.CST.SIZE AS 13
DEF MIN.USER.SIZE AS 6
DEF NOT.THERE AS -1
DEF OPEN.ALL(A,B,C) AS A _ OPEN(-IOTAB,B,C)
DEF OPER.BIT(A) AS BYT(A,1,15)
DEF P.CODE AS BYT(USR(WD.CODES),6,20)
DEF PRIV.BITS AS BYT(USR(WD.PRIV),5,26)
DEF READ.FROM.CUST AS [SETCP(CUS.CH,FIXCP(N.CUS.BLK));&
	RB(CUS.CH,SIZE.BLOCK * 10,CUSBLK); INDEX _ 0]
DEF READ.FROM.USER AS [SETCP(USR.CH,FIXCP(N.USR.BLK));&
	RB(USR.CH,SIZE.BLOCK,USRBLK); INDEX _ 0]
DEF RECORD.OUT AS IF USER.MODE THEN USER.WRITE ELSE CUST.WRITE
DEF RET(A) AS [IER _ A; GO GO.BACK]
DEF SIGN.BIT AS OCT 400000000000
DEF SIZE.BLOCK AS 128
DEF SLSMN AS BYT(USR(WD.SLS.CUST),15,18)
DEF ST.INV.BIT AS BYT(CST(WD.ST.INV),1,33)
DEF T.CODE AS BYT(USR(WD.CODES),7,0)
DEF THERE AS 0
DEF TIMSH.BIT AS BYT(CST(WD.TIMSH),1,32)
DEF U.CUST.N AS BYT(USR(WD.SLS.CUST),17,0)
DEF USER.MODE AS MODE <= SIX.USER.MODE
DEF USER.WRITE AS [SETCP(USR.CH,FIXCP(N.USR.BLK)); WB(USR.CH,SIZE.BLOCK,USRBLK)]
DEF U.SIZE AS BYT(USR(WD.U.SIZE),4,32)
DEF USR(A) AS USRBLK(INDEX+A)
DEF VERSION AS 16

!START HERE

IER _ 0; REC.CHANGED _ NOT.CHANGED
IF 0 < ICODE <= MAX.CODE THEN DO ICODE OF INIT.READ:MAX.CODE

INIT.READ: INIT.UPDATE: IF BEEN.HERE # ALLREADY THEN INIT.NEWGET
   PPNARG(IOTAB) _ PPN
   EIF USER.MODE THEN DO
	NAMARG(IOTAB) _ USER.NAMES; EXTARG(IOTAB) _ USER.EXT
	OPEN.FILE(DIRECT+IF ICODE=INIT.UPDATE THEN UPDATE ELSE INPUT+WORD)
	SIZE.USER.NAMES _ SIZE(USR.CH)/SIZE.BLOCK
	N.USR.BLK _ 1; READ.FROM.USER; U.SEQ.FLG _ NOT.CALLED
   END
   ORIF CUST.MODE THEN DO
	NAMARG(IOTAB) _ CUSTOM.NAMES; EXTARG(IOTAB) _ CUSTOM.EXT
	OPEN.FILE(DIRECT+IF ICODE=INIT.UPDATE THEN UPDATE ELSE INPUT+WORD)
	SIZE.CUSTOM.ERS _ SIZE(CUS.CH)/SIZE.BLOCK
	N.CUS.BLK _ 1; READ.FROM.CUST; C.SEQ.FLG _ NOT.CALLED
   END
   ELSE RET(MISC.ERR)

READ.SPECIFIC: IF SEARCH # THERE THEN RET(NOT.FOUND)
   EIF USER.MODE THEN RET.USER.INFO
   ORIF CUST.MODE THEN RET.CUST.INFO
   ELSE RET(MISC.ERR)

READ.NEXT: GET.NEXT
   EIF USER.MODE THEN RET.USER.AND.PPN.INFO
   ORIF CUST.MODE THEN RET.CUST.AND.NUM.INFO
   ELSE RET(MISC.ERR)

CLOSE.ACTG: EIF USER.MODE THEN CLOSE(USR.CH)
   ORIF CUST.MODE THEN CLOSE(CUS.CH)
   ELSE RET(MISC.ERR)

NXT.USER.FOR.CUST: IF USER.MODE THEN DO
	LOOP [GET.NEXT; WHILE USER(RET.U.CUST) # U.CUST.N]
	RET.USER.AND.PPN.INFO
   END ELSE RET(MISC.ERR)

WRITE.ENTRY: IF CUST.MODE THEN SET.UP.ADDR
   EIF USER.MODE AND U.SEQ.FLG = CALLED THEN DO
	IF USER(RET.PPN) # USR(WD.PPN) THEN RET(MISC.ERR)
   END
   ORIF CUST.MODE AND C.SEQ.FLG = CALLED THEN DO
	IF CUST(RET.C.NUM) # CUST.NUM THEN RET(MISC.ERR)
	IF SAVE.SIZE # C.SIZE THEN RET(MISC.ERR)
   END
   ELSE IF SEARCH = THERE THEN [DEL.RECORD; INC REC.CHANGED; FIND.ROOM]
   SAVE.INFO; RECORD.OUT

REMOVE: IF SEARCH = NOT.THERE THEN RET(NOT.FOUND)
   DEL.RECORD; RECORD.OUT

CHG.SITE.ONLY: IF SEARCH # THERE THEN RET(NOT.FOUND)
   USR(WD.SITES) _ USER(RET.SITES)
   USER.WRITE

END ELSE RET(MISC.ERR)

RET(OK)


GO.BACK: RETURN

CHK.ERR: IF ERRNUM = EOFERR AND U.SEQ.FLG = CALLED THEN RET(END.OF.FILE)
   RET(MISC.ERR)


%INIT.NEWGET
LOCAL LIC, DIDIT:
IOCS(2)
^OCT 14 _ -OCT 20
EXU(OCT 47,OCT 14,OCT 41,DIDIT)
EXIT
DIDIT: LIC _ ^OCT 14
   IF OPER.BIT(LIC) # 1 THEN DO
	MSG('$YOU MUST SHOW YOUR OPER LICENSE TO RUN THIS PROGRAM.$')
	EXIT
   END
P1 _ CHPT('USERNA.MES',-1)
   SETFID(IOTAB,@P1,0,CHK.ERR)
   USER.NAMES _ NAMARG(IOTAB); USER.EXT _ EXTARG(IOTAB)
P1 _ CHPT('CUSTOM.ERS',-1)
   SETFID(IOTAB,@P1,0,CHK.ERR)
   CUSTOM.NAMES _ NAMARG(IOTAB); CUSTOM.EXT _ EXTARG(IOTAB)
BEEN.HERE _ ALLREADY
RETURN
END INIT.NEWGET


%RET.USER.AND.PPN.INFO
USER(RET.PPN) _ USR(WD.PPN)

%%RET.USER.INFO
MOVE 9 FROM ALL 0 TO USER + 1
USER(RET.P.CODE) _ P.CODE
USER(RET.T.CODE) _ T.CODE
USER(RET.SLS) _ SLSMN
USER(RET.U.CUST) _ U.CUSTN
USER(RET.SITES) _ USR(WD.SITES)
USER(RET.PRIV) _ PRIV.BITS
IF MODE = ASC.USER.MODE THEN DO
   ASC.RET(USER+RET.USER.NAME,USRBLK+INDEX+WD.USER.NAME,12)
END ELSE MOVE 2 FROM USRBLK+INDEX+WD.USER.NAME TO USER+RET.USER.NAME
RETURN
END RET.USER.AND.PPN.INFO


%RET.CUST.AND.NUM.INFO
LOCAL CHAR, LINE.CNT, CHAR.CNT
CUST(RET.C.NUM) _ CUST.NUM

%%RET.CUST.INFO
MOVE 99 FROM ALL 0 TO CUST + 1
CUST(RET.B.DIST) _ B.DIST
IF MODE = ASC.CUST.MODE THEN DO
   ASC.RET(CUST+RET.CUST.NAME,CUSBLK+INDEX+WD.CUST.NAME,30)
   SPACE _ $ 	!SPACE
   P1 _ CHPT(CUST+RET.ADDR,-1)
END ELSE DO
   MOVE 5 FROM CUSBLK+INDEX+WD.CUST.NAME TO CUST+RET.CUST.NAME
   SPACE _ $  - OCT 40
   P1 _ BYPT(CUST+RET.ADDR,1,6)
END
PTR _ BYPT(CUSBLK+INDEX+WD.ADDR,1,6)
LINE.CNT _ 5
LOOP DO
   CHAR.CNT _ 30
   LOOP DO
	WHILE CHAR _ NCHV PTR  # END.OF.LINE
	IF MODE = ASC.CUST.MODE THEN CHAR + _ OCT 40
	DEC CHAR.CNT
	NCHV P1 _ CHAR
   END
   DEC LINE.CNT
   IF CHAR.CNT > 0 THEN REPEAT CHAR.CNT NCHV P1 _ SPACE
   IF CHAR _ NCHV PTR = END.OF.LINE THEN CHAR _ NCHV PTR
   WHILE CHAR # END.OF.ADDR
   IF PTR+_OCT 60000000000 < 0 THEN PTR-_OCT 440000000001
END
IF LINE.CNT > 0 THEN REPEAT LINE.CNT * 30 NCHV P1 _ SPACE
CUST(RET.MAIL.ADD) _ 0
CUST(RET.MIN) _ MIN.BIT
CUST(RET.TIMSH) _ TIMSH.BIT
CUST(RET.ST.INV) _ ST.INV.BIT
RETURN
END RET.CUST.AND.NUM.INFO



%SEARCH
EIF USER.MODE THEN DO
   N.USR.BLK _ USER(0) MOD 101 + 1
   READ.FROM.USER
   RETURN LOOK.FOR.IT
END
ORIF CUST.MODE THEN DO
   N.CUS.BLK _ (CUST(0) MOD 53) * 10 + 1
   READ.FROM.CUST
   RETURN LOOK.FOR.IT
END
ELSE RET(MISC.ERR)
END SEARCH


%GET.NEXT
EIF USER.MODE THEN DO
   IF U.SEQ.FLG = CALLED THEN INC.U.INDEX ELSE U.SEQ.FLG _ CALLED
   LOOP DO
	IF USR(WD.PPN) > 0 THEN RETURN
	INC N.USR.BLK
	READ.FROM.USER
   END
END
ORIF CUST.MODE THEN DO
   IF C.SEQ.FLG = CALLED THEN INC.C.INDEX ELSE C.SEQ.FLG _ CALLED
   LOOP DO
	IF CST(WD.CUST) > 0 THEN RETURN
	INC N.CUS.BLK
	READ.FROM.CUST
   END
END
ELSE RET(MISC.ERR)
END GET.NEXT


%SAVE.INFO
EIF USER.MODE THEN DO
   IF USR(WD.PPN) = 0 THEN MOVE U.SIZE FROM ALL 0 TO USRBLK+INDEX
   USR(WD.PPN) _ USER(RET.PPN)
   P.CODE _ USER(RET.P.CODE)
   T.CODE _ USER(RET.T.CODE)
   SLSMN _ USER(RET.SLS)
   U.CUST.N _ USER(RET.U.CUST)
   USR(WD.SITES) _ USER(RET.SITES)
   PRIV.BITS _ USER(RET.PRIV)
   IF MODE = ASC.USER.MODE THEN DO
	MAKE.SIXBIT(USER+RET.USER.NAME,USRBLK+INDEX+WD.USER.NAME,12)
   END ELSE MOVE 2 FROM USER+RET.USER.NAME TO USRBLK+INDEX+WD.USER.NAME
   U.SIZE _ MIN.USER.SIZE
END
ORIF CUST.MODE THEN DO
   IF CST(WD.CUST) = 0 THEN MOVE C.SIZE FROM ALL 0 TO CUSBLK+INDEX
   CUST.NUM _ CUST(RET.C.NUM)
   B.DIST _ CUST(RET.B.DIST)
   IF MODE = ASC.CUST.MODE THEN DO
	MAKE.SIXBIT(CUST+RET.CUST.NAME,CUSBLK+INDEX+WD.CUST.NAME,30)
   END ELSE DO
	MOVE 5 FROM CUST+RET.CUST.NAME TO CUSBLK+INDEX+WD.CUST.NAME
   END
   MOVE WD.CNT FROM SAVE.ADDR TO CUSBLK+INDEX+WD.ADDR
   MIN.BIT _ CUST(RET.MIN)
   TIMSH.BIT _ CUST(RET.TIMSH)
   ST.INV.BIT _ CUST(RET.ST.INV)
   C.SIZE _ SAVE.SIZE
END
ELSE RET(MISC.ERR)
RETURN
END SAVE.INFO


%SET.UP.ADDR
LOCAL TMP, DIFF, CHR.CNT, TST.PTR, AMT.DIV, AMT.ADD
IF MODE = ASC.CUST.MODE THEN DO
   DIFF _ OCT 40
   SPACE _ $ 
   P1 _ CHPT(CUST+RET.ADDR,-1)
END ELSE DO
   DIFF _ 0
   SPACE _ $  - OCT 40
   P1 _ BYPT(CUST+RET.ADDR,1,6)
END
PTR _ BYPT(SAVE.ADDR,1,6)
WD.CNT _ 0
REPEAT 5 DO
   TST.PTR _ P1	!FIND COUNT FOR LAST NON-SPACE CHARACTER
   CHR.CNT _ 0
   FOR TMP _ 1 TO 30 IF NCHV TST.PTR # SPACE THEN CHR.CNT _ TMP
   TST.PTR _ P1
   FOR TMP _ 1 TO CHR.CNT [NCHV PTR_NCHV TST.PTR+DIFF; INC WD.CNT]
   NCHV PTR _ END.OF.LINE; INC WD.CNT
   P1 + _ IF MODE = ASC.CUST.MODE THEN 6 ELSE 5
END
REPEAT 2 [NCHV PTR _ END.OF.ADDR; INC WD.CNT]
AMT.DIV _ IF MODE = ASC.CUST.MODE THEN 5 ELSE 6
AMT.ADD _ IF WD.CNT MOD AMT.DIV = 0 THEN 0 ELSE 1
WD.CNT _ WD.CNT/AMT.DIV + AMT.ADD
SAVE.SIZE _ MIN.CST.SIZE + WD.CNT
RETURN
END SET.UP.ADDR



%MAKE.OVER
IF USER.MODE THEN DO
   USR(WD.PPN) _ SIGN.BIT BOR (SIZE.USER.NAMES + _ 1)
   USER.WRITE
   N.USR.BLK _ SIZE.USER.NAMES
   MOVE SIZE.BLOCK FROM ALL 0 TO USRBLK
   INDEX _ 0
   RETURN
END ELSE DO
   CST(WD.CUST) _ SIGN.BIT BOR (SIZE.CUSTOM.ERS + _ 1)
   CUST.WRITE
   N.CUS.BLK _ SIZE.CUSTOM.ERS
   MOVE SIZE.BLOCK * 10 FROM ALL 0 TO CUSBLK
   INDEX _ 0
   RETURN
END
END MAKE.OVER



%BYPT(Y,P1,S)
RETURN [6,6,6,18]*[IF P1>=0 THEN 36-S*(P1 MOD(36/S)-1)&
	ELSE 36-S*(36/S-(-P1) MOD (36/S)+1),S,0,&
	IF P1>=0 THEN Y+P1/(36/S) ELSE Y+(P1+1)/(36/S)-1]
END BYPT


%NUMOUT(N)
LOCAL I
TABLE TEN(7)[1,10,100,1000,10000,100000,1000000]
IF N < 0 THEN [MSG('-'); N - _]
IF N >= TEN(6) THEN [MSG('>1000000.'); RETURN]
I _ 0; WHILE N >= TEN(I+1) THEN INC I
WHILE I >= 0 THEN [PUT($0 + N/TEN(I)); N _ N MOD TEN(I); DEC I]
RETURN
END NUMOUT


%MAKE.SIXBIT(FROMADR,TOADR,N)
LOCAL FROMP, CHAR
FROMP _ CHPT(FROMADR,-1)
PTR _ BYPT(TOADR,1,6)
REPEAT N DO
   IF CHAR _ NCHV FROMP # EOLIT THEN NCHV PTR _ (CHAR-$ ) BAND OCT 77&
	ELSE NCHV PTR _ EOLIT
END
RETURN
END MAKE.SIXBIT



%DEL.RECORD
EIF USER.MODE THEN MOVE SIZE.BLOCK - (INDEX + U.SIZE) FROM &
   USRBLK + INDEX + U.SIZE TO USRBLK + INDEX
ORIF CUST.MODE THEN MOVE SIZE.BLOCK * 10 - (INDEX + C.SIZE) FROM &
   CUSBLK + INDEX + C.SIZE TO CUSBLK + INDEX
ELSE RET(MISC.ERR)
RETURN
END DEL.RECORD



%OPEN.FILE(OPEN.MODE)
LOCAL OPEN.ERR:, OPEN.COUNT
OPEN.COUNT _ 10
LOOP DO
   IF USER.MODE THEN OPEN.ALL(USR.CH,OPEN.MODE,OPEN.ERR) ELSE &
	OPEN.ALL(CUS.CH,OPEN.MODE,OPEN.ERR)
   RETURN
   OPEN.ERR: IF DEC OPEN.COUNT < 0 THEN RET(FILE.BUSY)
   WHILE ERRNUM = FBSERR
END
GO CHK.ERR
END OPEN.FILE



%LOOK.FOR.IT
IF USER.MODE THEN DO
 WHILE USER(RET.PPN) # USR(WD.PPN) THEN DO
   EIF USR(WD.PPN) = 0 THEN DO
	IF ICODE = WRITE.ENTRY THEN CK.ROOM(MIN.USER.SIZE,1) THEN MAKE.OVER
	RETURN NOT.THERE
   END
   ORIF USR(WD.PPN) < 0 THEN DO
	IF REC.CHANGED = CHANGED THEN USER.WRITE
	GET.U.OVERFLOW(HW(USRBLK+INDEX,1))
   END
   ELSE [INC.U.INDEX; CK.ROOM(0,1) THEN RETURN NOT.THERE]
 END
 RETURN THERE
END ELSE DO
 WHILE CUST(RET.C.NUM) # CUST.NUM THEN DO
   EIF CST(WD.CUST) = 0 THEN DO
	IF ICODE = WRITE.ENTRY THEN CK.ROOM(SAVE.SIZE,10) THEN MAKE.OVER
	RETURN NOT.THERE
   END
   ORIF CST(WD.CUST) < 0 THEN DO
	IF REC.CHANGED = CHANGED THEN CUST.WRITE
	GET.C.OVERFLOW(HW(CUSBLK+INDEX,1))
   END
   ELSE [INC.C.INDEX; CK.ROOM(0,10) THEN RETURN NOT.THERE]
 END
 RETURN THERE
END
END LOOK.FOR.IT



%FIND.ROOM
EIF USER.MODE THEN DO
   WHILE USR(WD.PPN) > 0 THEN INC.U.INDEX
   CK.ROOM(MIN.USER.SIZE+1,1) THEN [LOOK.FOR.IT; RETURN]
   IF USR(WD.PPN) < 0 THEN DO
	USR(WD.PPN+MIN.USER.SIZE) _ USR(WD.PPN)
	USR(WD.PPN) _ 0
   END
   RETURN
END
ORIF CUST.MODE THEN DO
   WHILE CST(WD.CUST) > 0 THEN INC.C.INDEX
   CK.ROOM(SAVE.SIZE,10) THEN [LOOK.FOR.IT; RETURN]
   IF CST(WD.CUST) < 0 THEN DO
	CST(WD.CUST+SAVE.SIZE) _ CST(WD.CUST)
	CST(WD.CUST) _ 0
   END
   RETURN
END
ELSE RET(MISC.ERR)
END FIND.ROOM


END NEWGET
 