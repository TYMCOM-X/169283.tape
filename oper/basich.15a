TITLE	BASIC	V015A	23-NOV-70
SUBTTL		PARAMETERS AND TABLES

;VERSION 15A	23-NOV-70/KK
;VERSION 15	17-AUG-1970/KK
;VERSION 14	16-JUL-1970/AL/KK
;VERSION 13	15-SEPT-1969
;UPDATED WITH VERSION RECEIVED FROM APPLIED LOGIC ON 11-FEB-69
;FILE  CAPABILITIES BY T.MCGETTIGAN 18-MAR-69
;EDITED BY N. PAPPAS (COURTESY OF CCC) 25-MAR-69
;CYPH "OLD" PATCH 28 MAR 69
;ALC FIXES OF 31-MAR-69 BY N. PAPPAS ON 3-APR-69



	JOBVER=137
	VERNUM=010015

	LOC JOBVER
	VERNUM
	RELOC
	HISEG

;CONDITIONAL ASSEMBLY PARAMETERS
;  THE VERSION OF BASIC SUPPLIED BY APPLIED LOGIC CORPORATION
;  IS ASSEMBLED WITH THE PARAMETERS BELOW SET TO -1.  APPLIED
;  LOGIC CORPORATION HAS NOT NECESSARILY TESTED VERSIONS OF
;  BASIC ASSEMBLED OTHERWISE AND DOES NOT GUARANTEE TO
;  MAINTAIN ANY SUCH VERSIONS.

FTRND=-1		;-1 IF RANDOM FACILITY, ELSE 0
FTMAT=-1		;-1 IF MATRIX FACILITY, ELSE 0
FTSTR=-1		;-1 IF STRING FACILITY, ELSE 0
MLON

;AC DEFINITIONS
			;PRINCIPAL USES:
F=7			;FLAGS
T=1			;POINTER TO NXCH
T1=2
A=3			;SEARCH ARGUMENT
B=4			;POINTER AFTER SEARCH
C=5			;XWD CHARACTER-FLAGS,CHAR
D=6			;BUILD INSTS HERE
N=0			;RUNTIME ACCUMULATOR REGISTER
R=12			;POINTER TO ROLL BEING USED
LP=16
L=16
E=10
G=11
X1=13			;)
X2=14			;)TEMP REGS
Q=15			;PUSHDOWN LIST FOR FNX ARGS.
P=17			;PUSHDOWN LIST
IOS=6
T3=10
T4=11
T2=16
CHR=13

;OP CODE ROLL
	INTERNAL	CMDCEI,CMDFLO,DECCEI,DECFLO,IFNCEI,IFNFLO
	INTERNAL	RELCEI,RELFLO,STACEI,STAFLO

	EXTERNAL UFD,FILNM,IBF
	EXTERNAL CATFLG,DEVICE,ININI1,OBF
	EXTERNAL NEWOL1,SPEC,CORN,CORNTO
	EXTERNAL CECAD,CECON,CEFCL,CEFOR,CEGSB,CENXT
	EXTERNAL	CEPTM,CESAD,CESEX,CESTM,CEVSP,FLARA
	EXTERNAL	FLCAD,FLCON,FLFCL,FLFOR,FLGSB,FLLIT
	EXTERNAL	FLNXT,FLPTM,FLSAD,FLSCA,FLSEX,FLSTM,FLVSP
	EXTERNAL	CELAD,FLLAD
	EXTERNAL	CECOD,FLCOD,CETMP,FLTMP,CEARG,FLARG,CESVR,FLSVR
	EXTERNAL CETXT,FLTXT,CELIN,FLLIN
	EXTERNAL	ARAROL ,ARATOP ,ARGROL ,C3 ,CADROL ,CEIL ,CMDROL ,CODROL 
	EXTERNAL	COMTOP ,CONROL ,CURDEV ,CUREXT ,CURNAM ,DATAFF ,DATLIN ,DECROL 
	EXTERNAL	DETER ,DRMBUF ,ELETOP ,ES2 ,FADROL ,FCLROL ,FCNLNK ,FCNROL 
	EXTERNAL	FILDIR ,FLOOR ,FMTPNT ,FORROL ,FRSTLN ,FUNAME ,FUNLOW ,FUNSTA 
	EXTERNAL	GSBROL ,HPOS ,IFNROL ,INPFLA ,JOBFF ,JOBOPC ,JOBREL ,JOBREN
	EXTERNAL	JOBSA ,LADROL ,LASTLN  ,LINROL ,LITROL 
	EXTERNAL	LOWEST ,LOWSTA ,LZ ,MINFLG ,MORFLA ,NUMFLA ,NUMRES ,NXTROL 
	EXTERNAL	OLDFLA ,ONCESW ,PAKFLA ,PINPUT ,PIVOT ,PLIST ,PREAD ,PSHPNT 
	EXTERNAL	PSHROL ,PTMROL ,REGPNT ,RELROL ,RENFLA ,ROLMSK ,ROLTOP ,RUNFLA 
	EXTERNAL	SADROL ,SB1M1 ,SB2M1 ,SCAROL ,SEQPNT ,SEXROL ,STAROL ,STMROL 
	EXTERNAL	STRFLA ,SVRBOT ,SVRROL ,SVRTOP ,SX ,TABVAL ,TEMP1 ,TEMP2 
	EXTERNAL	TEMP3 ,TMPLOW ,TMPPNT ,TMPROL ,TOPSTG ,TTYBUF ,TXTROL
	EXTERNAL	TYO ,VARBOT ,VARFRE ,VARROL ,VECT1 ,VECT2 ,VPAKFL ,VRANX 
	EXTERN	VSPROL,TYI
	EXTERN	LETSW,PDP6SW,MTIME
	EXTERN	REFROL
	EXTERN	VRANT,FLREF,CEREF,REFROL
	EXTERN	DSKIFL,DSKOFL,IBDSK
STAFLO:
IFN FTSTR,<
	Z	XCHAN+60000(SIXBIT /   CHA/)
>
	Z	XDATA+40000(SIXBIT /   DAT/)
	Z	XDEF+40000(SIXBIT /   DEF/)
	Z	XDIM(SIXBIT /   DIM/)
	Z	XEND(SIXBIT /   END/)
	Z	XFILE+40000(SIXBIT/   FIL/)
	Z	XFNEND+60000(SIXBIT /   FNE/)
	Z	XFOR+20000(SIXBIT /   FOR/)
	Z	XGOSUB+60000(SIXBIT /   GOS/)
	Z	XGOTO+60000(SIXBIT /   GOT/)
	Z	XIF+20000(SIXBIT /   IF /)
	Z	XINPUT+60000(SIXBIT /   INP/)
	Z	XLET+20000(SIXBIT /   LET/)
IFN FTMAT,<
	Z	XMAT+20000(SIXBIT /   MAT/)
>
	Z	XNEXT+60000(SIXBIT /   NEX/)
	Z	XON+20000(SIXBIT /   ON /)
	Z	XPRINT+60000(SIXBIT /   PRI/)
IFN FTRND,<
	Z	XRAN+60000(SIXBIT /   RAN/)
>
	Z	XREAD+60000(SIXBIT /   REA/)
	Z	NXTST1(SIXBIT /   REM/)
	Z	XREST+40000(SIXBIT /   RES/)
	Z	XRETRN+60000(SIXBIT /   RET/)
	Z	XSCRAT+40000(SIXBIT/   SCR/)
	Z	XSTOP+40000(SIXBIT /   STO/)
	Z	XWRIT+60000(SIXBIT/   WRI/)
STACEI:
;TABLE OF BASIC COMMANDS

DEFINE YYY (A,B)<
	EXP	SIXBIT /A/ + 'A'ER + 'B'0000>

CMDFLO:	YYY BYE
	YYY CAT
	YYY DEL
	YYY GOO
	YYY KEY
	YYY LEN
	YYY LIS
	YYY NEW
	YYY OLD
	YYY REN
	YYY REP
	YYY RES
	YYY RUN
	YYY SAV
	YYY SCR
	YYY SYS
	YYY TAP
	YYY UNS
	YYY WEA
CMDCEI:
;CHARACTER TYPE TABLE.
;FLAGS IN LEFT HALF OF CTTAB+<LETTER> FOR <LETTER> BELOW 100,	
;FLAGS IN RIGHT HALF OF CTTAB+<LETTER-100> OTHERWISE.

DEFINE WWW (FL,VAL)<
	XLIST
FL=<	Z	0,(VAL)>
	LIST>

WWW F.APOS,1B0		;	'
WWW F.COMA,1B1		;	,
WWW F.CR,1B2		;	<RETURN, OR LF,VT,FFEED>
WWW F.DIG,1B3		;	<NUMERAL>
WWW F.DOLL,1B17
WWW F.EQAL,1B4		;	=
WWW F.ESC,1B5		;	<ESCAPE OR ALTMODE>
WWW F.LCAS,1B6		;	<LOWER CASE LETTER>
WWW F.LETT,1B7		;	<LOWER OR UPPER CASE LETTER>
WWW F.STR,1B8		;	(
WWW F.MINS,1B9		;	-
WWW F.PER,1B10		;	.
WWW F.PLUS,1B11		;	+
WWW F.QUOT,1B12		;	"
WWW F.RPRN,1B13		;	)
WWW F.SLSH,1B14		;	/
WWW F.STAR,1B15		;	*
WWW F.SPTB,1B16		;	<SPACE OR TAB>

F.NU=0			;ASCII CODES THAT ARE TREATED AS NULLS.
F.OTH=0			;OTHER CHARACTERS ANALYSED BY BASIC WITHOUT THE USE OF FLAGS.

F.TERM=F.CR+F.APOS	;EITHER TERMINATES THE ANALYZABLE PORTION OF A BASIC STATEMENT.
CTTAB:
	XWD	F.NU,	F.STR	;NULL	, @
	XWD	F.STR,	F.LETT	;	, A
	XWD	F.STR,	F.LETT	;	, B
	XWD	F.STR,	F.LETT	;	, C
	XWD	F.STR,	F.LETT	;	, D
	XWD	F.STR,	F.LETT	;	, E
	XWD	F.STR,	F.LETT	;	, F
	XWD	F.STR,	F.LETT	;	, G
	XWD	F.STR,	F.LETT	;	, H
	XWD	F.SPTB,	F.LETT	;TAB	, I
	XWD	F.CR,	F.LETT	;LF	, J
	XWD	F.CR,	F.LETT	;VER.TAB, K
	XWD	F.CR,	F.LETT	;FFEED	, L
	XWD	F.CR,	F.LETT	;CR	, M
	XWD	F.STR,	F.LETT	;	, N
	XWD	F.STR,	F.LETT	;	, O
	XWD	F.STR,	F.LETT	;	, P
	XWD	F.STR,	F.LETT	;	, Q
	XWD	F.STR,	F.LETT	;	, R
	XWD	F.STR,	F.LETT	;	, S
	XWD	F.STR,	F.LETT	;	, T
	XWD	F.STR,	F.LETT	;	, U
	XWD	F.STR,	F.LETT	;	, V
	XWD	F.STR,	F.LETT	;	, W
	XWD	F.STR,	F.LETT	;	, X
	XWD	F.STR,	F.LETT	;	, Y
	XWD	F.STR,	F.LETT	;	, Z
	XWD	F.ESC,	F.STR	;ESC	, [
	XWD	F.STR,	F.STR	;	, \
	XWD	F.STR,	F.STR	;	, ]
	XWD	F.STR,	F.OTH	;	, ^
	XWD	F.STR,	F.OTH	;	, _
	XWD	F.SPTB,	F.STR		;SPACE	, <ACCENT GRAVE>
	XWD	F.STR,	F.LETT+F.LCAS	; !	, <LOWER CASE> A
	XWD	F.QUOT,	F.LETT+F.LCAS	; "	, <LOWER CASE> B
	XWD	F.STR,	F.LETT+F.LCAS	; #	, <LOWER CASE> C
	XWD	F.DOLL,	F.LETT+F.LCAS	; $	, <LOWER CASE> D
	XWD	F.STR,	F.LETT+F.LCAS	; %	, <LOWER CASE> E
	XWD	F.OTH,	F.LETT+F.LCAS	; &	, <LOWER CASE> F
	XWD	F.APOS,	F.LETT+F.LCAS	; '	, <LOWER CASE> G
	XWD	F.OTH,	F.LETT+F.LCAS	; (	, <LOWER CASE> H
	XWD	F.RPRN,	F.LETT+F.LCAS	; )	, <LOWER CASE> I
	XWD	F.STAR,	F.LETT+F.LCAS	; *	, <LOWER CASE> J
	XWD	F.PLUS,	F.LETT+F.LCAS	; +	, <LOWER CASE> K
	XWD	F.COMA,	F.LETT+F.LCAS	; , 	, <LOWER CASE> L
	XWD	F.MINS,	F.LETT+F.LCAS	; -	, <LOWER CASE> M
	XWD	F.PER,	F.LETT+F.LCAS	; .	, <LOWER CASE> N
	XWD	F.SLSH,	F.LETT+F.LCAS	; /	, <LOWER CASE> O
	XWD	F.DIG,	F.LETT+F.LCAS	; 0	, <LOWER CASE> P
	XWD	F.DIG,	F.LETT+F.LCAS	; 1	, <LOWER CASE> Q
	XWD	F.DIG,	F.LETT+F.LCAS	; 2	, <LOWER CASE> R
	XWD	F.DIG,	F.LETT+F.LCAS	; 3	, <LOWER CASE> S
	XWD	F.DIG,	F.LETT+F.LCAS	; 4	, <LOWER CASE> T
	XWD	F.DIG,	F.LETT+F.LCAS	; 5	, <LOWER CASE> U
	XWD	F.DIG,	F.LETT+F.LCAS	; 6	, <LOWER CASE> V
	XWD	F.DIG,	F.LETT+F.LCAS	; 7	, <LOWER CASE> W
	XWD	F.DIG,	F.LETT+F.LCAS	; 8	, <LOWER CASE> X
	XWD	F.DIG,	F.LETT+F.LCAS	; 9	, <LOWER CASE> Y
	XWD	F.OTH,	F.LETT+F.LCAS	; :	, <LOWER CASE> Z
	XWD	F.OTH,	F.STR		; ;	, <LEFT BRACE>
	XWD	F.OTH,	F.STR		; <	, <VERTICAL BAR>
	XWD	F.EQAL,	F.STR		; =	, <RIGHT BRACE>
	XWD	F.OTH,	F.STR		; >	, <TILDE>
	XWD	F.STR,	F.STR		; ?	, <RUBOUT>
DEFINE FAIL (A,AC)<
	XLIST
	XWD	001000+AC'00,[ASCIZ /A/]
	LIST
>

%OPD=1	;OPDEF UUO COUNTER
DEFINE OPCNT (A)<
%OPD=%OPD+1
IFG %OPD-37,<PRINTX <TOO MANY UUO'S>>
OPDEF A	[<%OPD>B8]>
	OPCNT	(PRNM)
	OPCNT	(PRTX)
	OPCNT	(GOSUB)
	OPCNT	(ARFET1)
	OPCNT	(ARFET2)
	OPCNT	(ARSTO1)
	OPCNT	(ARSTO2)
	OPCNT	(ARSTN1)
	OPCNT	(ARSTN2)
	OPCNT	(DATA)
	OPCNT	(ADATA1)
	OPCNT	(ADATA2)
	OPCNT	(SDIM)
IFN FTMAT,<
	OPCNT	(MATRD)
	OPCNT	(MATPR)
	OPCNT	(MATSCA)
	OPCNT	(MATCON)
	OPCNT	(MATIDN)
	OPCNT	(MATTRN)
	OPCNT	(MATINV)
	OPCNT	(MATADD)
	OPCNT	(MATSUB)
	OPCNT	(MATMPY)
	OPCNT	(MATZER)
>
	OPCNT	(PRNTB)
IFN FTSTR,<
	OPCNT	(STRUUO)
	OPCNT	(SVRADR)
	OPCNT	(PRSTR)
>
	OPCNT	(DONFOR)
	OPCNT	(MATINP)

MAXUUO=%OPD

STAR=.
LOC	41
	JSR	UUOH
RELOC	STAR

	INTERN UUOHAN
	EXTERN	UUOH
UUOHAN:	PUSH	P,UUOH		;RETURN ADDRS ON PUSH-DOWN LIST
	LDB	X1,[POINT 9,40,8]
IFL MAXUUO-37, <
	CAILE	X1,MAXUUO
	JRST	INLSYS		;ILLEGAL UUO.
>
UUOTBL:	JRST	.(X1)
	JRST	FAILER
	JRST	PRNMER
	JRST	PRTXER
	JRST	GOSBER
	JRST	AFT1ER
	JRST	AFT2ER
	JRST	AST1ER
	JRST	AST2ER
	JRST	ASN1ER
	JRST	ASN2ER
	JRST	DSKRT
	JRST	ADT1ER
	JRST	ADT2ER
	JRST	SDIMER
IFN FTMAT,<
	JRST	MTRDER
	JRST	MTPRER
	JRST	MTSCER
	JRST	MTCNER
	JRST	MTIDER
	JRST	MTTNER
	JRST	MTIVER
	JRST	MTADER
	JRST	MTSBER
	JRST	MTMYER
	JRST	MTZRER
>
	JRST	PRNTBR		;EXECUTE THE TAB FUNCTION IN "PRINT"
IFN FTSTR,<
	JRST	SUUOEX
	JRST	SAD1ER
	JRST	PRSTRR
>
	JRST	FORCOM
	JRST	MATIN
DSKRT:	LDB	X1,[POINT	4,40,12]
	JRST	.+1(X1)
	JRST	DATAER		;DATA 0, UUO.
	JRST	INSET		;DATA 1, -- SETS UP FOR READ#.
	JRST	INCLR		;DATA 2, -- CLEARS AFTER READ#.
	JRST	EOF		;DATA 3, -- IF END# UUO.
	JRST	XRES		;DATA 4, -- RESTORE# UUO.
	JRST	SCATH		;DATA 5, -- SCRATCH# UUO.
	JRST	IPDSK		;DATA 6, -- SETS UP FOR WRITE#.
	JRST	CODSK		;DATA 7, -- CLEARS AFTER WRITE#.
	JRST	LINSST		;DATA 10, -- SETS UP SOURCE LINE NUMBER.
IFN FTSTR,<
SUUOEX:	LDB	X1,[POINT 4,40,12]	;STRING UUOS USE THE AC FIELD
	CAILE	X1,MASUUO		;AS AN EXTENSION OF THE OPCODE.
	HALT	.

UUOSTR:	JRST	.(X1)
	JRST	GETSTR
	JRST	PUTSTR
	JRST	COMSTR
	JRST	INSTR
	JRST	GETVEC
	JRST	PUTVEC
MASUUO=.-UUOSTR-1

	OPDEF	STRFET	[STRUUO 1,]
	OPDEF	STRSTO	[STRUUO 2,]
	OPDEF	STRIF	[STRUUO 3,]
	OPDEF	STRIN	[STRUUO 4,]
	OPDEF	VECFET	[STRUUO 5,]
	OPDEF	VECPUT	[STRUUO 6,]
>;ASSEMBLE ABOVE IF INCLUDING STRING FACILITY
;TABLE OF INTRINSIC FUNCTIONS


DEFINE ZZZ. (X,Y,Z) <
	OPDEF ZZZZ. [SIXBIT /X/]
		ZZZZ. Y'B+'Z'0000
>


IFNFLO:
	ZZZ.	(ABS,ABS)
	ZZZ.	(ATN,ATAN)
	ZZZ.	(COS,COS)
	ZZZ.	(COT,COT)
	ZZZ.	(DET,DET,4)
	ZZZ.	(EXP,EXP)
	ZZZ.	(INT,AINT)
	ZZZ.	(LOG,ALOG)
	ZZZ.	(NUM,NUM,4)
IFN FTRND,<
	ZZZ.	(RND,FRAN,4)
>
	ZZZ.	(SGN,SGN)
	ZZZ.	(SIN,SIN)
	ZZZ.	(SQR,SQRT)
	ZZZ.	(TAN,TAN)
IFNCEI:

;TABLE OF RELATIONS FOR IFSXLA

DEFINE ZZZ. (X,Y)<
OPDEF ZZZZ.	[X]
		ZZZZ.	(Y)>
RELFLO:	ZZZ.	3435B11,CAML
	ZZZ.	3436B11,CAME
	ZZZ.	   74B6,CAMLE
	ZZZ.	3635B11,CAMG
	ZZZ.	75B6,CAMN
	ZZZ.	   76B6,CAMGE
RELCEI:
	EXTERN	LINNUM,LNINS
	SUBTTL	COMMAND SCANNER AND EDITOR
;COLD START

BASIC:	CALLI	0
	MOVE	P,PLIST
	SETZM	IFIFG
	SETZM	UXFLAG
	SETZB	LP,ODF
	SETZM	MTIME
	SETOM	RENFLA		;ALLOW REENTERS.
	SKIPN	ONCESW		;FIRST TIME, SET THINGS UP
	JRST	BASI1
	SETZM	ONCESW
	HLRZ	T,JOBSA
	MOVEM	T,FLTXT		;TXTROL ON BOTTOM OF FREE SPACE
	MOVEM	T,CETXT
	MOVE	T,JOBREL	;LINROL ON TOP
	MOVEM	T,FLLIN
	MOVEM	T,CELIN
	HRLM	T,JOBSA		;MAKE SAVE COMMAND SAVE ALL
	HRRZI	T,REENTR
	HRRM	T,JOBREN

	SETOM	PDP6SW		;NON ZERO ON PDP-6
	JFCL	1,.+1		;CLEAR FLOATING OVERFLOW(OR PC CHANGE)
	JRST	.+1		;SET PC CHANGE ON A PDP-6
	JFCL	1,.+2		;TEST FOR PC CHANGE FLAG
	SETZM	PDP6SW		;SWITCH IS A 0 FOR PDP-10(HERE ON PDP-10)

	EXTERN	MONLVL
	HRLZI	X1,400000
	MOVEM	X1,MONLVL	;MONLVL CONTAINS THE
	MOVE	X1,[XWD 17,11]	;PROTECTION CODE "DON'T DELETE"
	CALLI	X1,41		;BIT APPROPRIATE TO THE MONITOR
	JRST	BASI1		;LEVEL UNDER WHICH BASIC IS RUNNING.
	TLNN	X1,(7B9)
	JRST	BASI1
	HRLZI	X1,100000
	MOVEM	X1,MONLVL

BASI1:	PUSHJ	P,TTYIN		;SET UP BUFFERS AND INIT TTY
	SKIPE	CURNAM
	JRST	UXIT
	SETZM	RUNFLA
ASKNEW:	PUSHJ	P,INLMES

	ASCIZ	/
NEW OR OLD--/			;FALL INTO FIXUP

FIXUP:	OUTPUT			;WRITE LAST MESSAGE
	EXTERN JOBAPR,JOBTPC
	SKIPE	CORN
	JRST	NAMED
	MOVE	X1,[SIXBIT /DSK/]	;INITIALIZE BASIC WITH
	MOVEM	X1,CURDEV		;CURRENT DEVICE==DSK
	MOVE	X1,[SIXBIT /NONAME/]
	MOVEM	X1,CURNAM		;CURRENT NAME==NONAME
	MOVE	X1,[SIXBIT /BAS/]
	MOVEM	X1,CUREXT		;CURRENT EXT==BAS
NAMED:	SETOM	CORN
	MOVEI	X1,^D9
CLR:	SETZM	ACTBL-1(X1)
	SETOM	LNINS-1(X1)
	SETZM	LINNUM-1(X1)
	SOJG	X1,CLR
	SETZM	IFIFG
	SETZM	ODF
	MOVEI	X1,OVFLCM	;IGNORE OVFLOW DURING COMMANDS.
	HRRM	X1,JOBAPR
	MOVEI	X1,10		;SETUP ARITH OVFLOW TRAP
	CALLI	X1,16
	MOVEI	X1,TXTROL
	MOVEM	X1,TOPSTG	;EDIT TIME. ONLY TXTROL IS STODGY.
;				;OTHER ROLLS MOVE.
	MOVE	T,CELIN	;CLOBBER ALL COMPILE ROLLS WITH "CELIN"
	MOVEI	X1,LINROL	;PROTECT TXTROL +LINROL FROM CLOBBER:
	PUSHJ	P,CLOB
				;FALL INTO MAINLP
;MAIN LOOP FOR EDITOR/MONITOR

MAINLP:	MOVE	P,PLIST
	PUSHJ	P,LOCKOF		;TURN OFF REENTR LOCK
	PUSHJ	P,INLINE	;READ A LINE
	PUSHJ	P,GETDNM	;LOOK FOR SEQUENCE NO
	JRST	COMMAN		;NONE.  GO INTERPRET COMMAND
	SKIPN	CURNAM		;MAKE SURE THERE IS A CURRENT FILE NAME.
	JRST	ASKNEW

;HERE, WE HAVE SEQUENCED LINE INPUT.  NUMBER IS IN N,
;POINTER TO FIRST CHAR AFTER NUMBER IS IN T

	PUSHJ	P,LOCKON
	PUSHJ	P,ERASE
	PUSHJ	P,INSERT
	PUSHJ	P,LOCKOF
	JRST	MAINLP

;HERE ON COMMAND

COMMAN:	MOVEI	R,CMDROL
	TLNE	C,F.TERM	;TEST FOR NULL COMMAND
	JRST	MAINLP
	PUSHJ	P,SCNLT1		;SCAN COMMAND
	PUSHJ	P,SCNLT2
	JRST	COMM1			;SECOND CHAR NOT A LETTER
	PUSHJ	P,SCNLT3
	JRST	COMM1			;THIRD CHAR NOT A LETTER

;NOW THE FIRST THREE LETTERS OF THE COMMAND ARE PACKED IN LH OF A.

	PUSHJ	P,SEARCH	;LOOK FOR COMMAND
	JRST	COMM1		;NOT FOUND
	HRRZ	X1,(B)
	SKIPE	CURNAM
	JRST	COMM01
	CAIE	X1,OLDER
	CAIN	X1,NEWER
	JRST	COMM01
	JRST	ASKNEW
COMM01:	TRZN	X1,40000
	JRST	(X1)
	PUSHJ	P,QST
	JRST	COMM1
	JRST	1(X1)

;"GOODBY" OR "BYE"
GOOER:	PUSHJ	P,QSA		;"GOODBYE"
	ASCIZ	/DBYE/
	JRST	BYEER		;AND "BYE"
BYEER:	MOVE	A,[XWD 17,11]	;BYE AND GOO ARE NOT IMPLEMENTED
	CALLI	A,41		;FOR NON-LOGIN SYSTEMS--SO
	JRST	.+1		;FIND OUT WHAT TYPE OF SYSTEM
	TLNE	A,100000	;BASIC IS RUNNING UNDER.
	JRST	BYEER5		;LOGIN SYSTEM--GO EXECUTE.
	PUSHJ	P,TTYIN		;NON-LOGIN SYSTEM--SEND MESSAGE OUT.
	PUSHJ	P,INLMES
	ASCIZ	/
THE BYE AND GOODBYE COMMANDS ARE NOT YET IMPLEMENTED.  IF YOU
WISH TO LOG OFF THE SYSTEM, USE THE FOLLOWING PROCEDURE:

	1.  TYPE "SYSTEM" AND THEN DEPRESS THE RETURN KEY.
	2.  TYPE "K" AND THEN DEPRESS THE RETURN KEY.

YOU WILL THEN BE LOGGED OFF THE SYSTEM.
/
	OUTPUT
	JRST	BASIC
BYEER5:	MOVSI	A,(SIXBIT /SYS/)
	MOVEM	A,FILDIR
	MOVE	A,[SIXBIT /LOGOUT/]
	MOVEM	A,FILDIR+1
	SETZM	FILDIR+2
	SETZM	FILDIR+3
	SETZM	FILDIR+4
	SETZM	FILDIR+5
	MOVSI	A,1
	HRRI	A,FILDIR
	CALL	A,[SIXBIT /RUN/]
	PUSHJ	P,TTYIN
	PUSHJ	P,INLMES
	ASCIZ	/LOGOUT FAILED TRY AGAIN
/
	OUTPUT
	JRST	BASIC

;"CATALOG" OR "CAT" 
;     RESULTS IN A LISTING OF USER PROGRAMS ON TTY
;     WHILE RUNNING "BASIC"

CATER:	PUSHJ	P,QSA
	ASCIZ	/ALOG/
	JRST	.+1
	SETZM	CATFLG		;FLAG IS ZERO FOR DSK, NE 0 FOR DTA'S.
	MOVSI	A,(SIXBIT/DSK/)
	TLNE	C,F.TERM
	JRST	CAT2
	PUSHJ	P,ATOMSX
	JUMPN	A,.+2
	MOVSI	A,(SIXBIT/DSK/)
	CAIN	C,72
	PUSHJ	P,NXCH
	TLNN	C,F.TERM
	JRST	CATFAL
CAT2:	MOVEM	A,DEVICE
	CALL	A,[SIXBIT/DEVCHR/]
	TLNN	A,200100
	JRST	CATFAL
	TLNN	A,200000
	SETOM	CATFLG
	MOVEI	0,IBF		;ININI1:          14
	MOVEM 	0,DEVICE+1  	;DEVICE:
	MOVEI	0,14		;DEVICE+1:        IBF
	MOVEM	0,ININI1
	OPEN	3,ININI1	;TRY TO GET THE CAT DEVICE.
	JRST 	NODEV		
	MOVEI	0,DBUF3
	MOVEM	0,JOBFF
	INBUF	3,1		
	INIT	2,1		;INIT THE TTY FOR LISTING.
	SIXBIT	/TTY/
	XWD	OBF,
	JRST	NOGET
	MOVEI	0,LINB2
	MOVEM	0,JOBFF
	OUTBUF	2,1
	PUSHJ	P,CLRF
	SKIPN	CATFLG
	JRST	DSKHAN
DTAHAN:	USETI	3,144		;POINT TO THE DIRECTORY BLOCK.
	INPUT	3,
	STATUS	3,IOS
	TRNE	IOS,740000	;ERROR?
	JRST	NOGET		;YES.
	MOVEI	X2,^D82		;NO.
	MOVEI	B,^D22
	MOVEM	B,CATFLG
	ADD	X2,IBF+1	;SET UP BYTE POINTERS TO FILENAMES
	ADD	B,X2		;AND EXTENSIONS.
CATLP:	ILDB	0,X2
	ILDB	1,B
	JUMPE	0,CATTST	;GO TO CATTST IF NO FILENAME HERE.
	MOVEM	0,FILNM
	HLLZM	1,FILNM+1
	PUSHJ	P,CLSTU3	;OUTPUT FILENAME AND EXT.
CATTST:	SOSG	CATFLG		;ONLY 22 FILES ON A DECTAPE.
	JRST	UXIT
	JRST	CATLP

DSKHAN:	CALLI	T1,24		;PREPARE FOR LOOKUP
	MOVEM	T1,UFD		;UFD  : P# ,P#
	MOVSI	0,(SIXBIT/UFD/)	;UFD+1:SIXBIT /UFD/
	MOVEM	0,UFD+1		;UFD+2:
	SETZM	UFD+2
	MOVE	0,[XWD 1,1]	;UFD+3: 1 ,, 1
	MOVEM	0,UFD+3
	LOOKUP	3,UFD		;LOOKUP DIRECTORY
	JRST	NOGET		;ERROR
CLSTU1:	SOSLE	IBF+2
	JRST	CLSTU5
CLSTU2:	INPUT	3,		;FOR ERROR AND EOF CHECK
	STATUS	3,IOS
	TRNN	IOS,760000	;ERROR OR EOF?
	JRST	CLSTU5		;NO.
	TRZN	IOS,20000	;YES, EOF?
	JRST	NOGET		;NO, ERROR.
	JRST	UXIT		;YES, EOF.
CLSTU5:	ILDB	0,IBF+1
	JUMPE	0,CLSTU2
	MOVEM	0,FILNM
	SOS	IBF+2
	ILDB	X2,IBF+1
	HLLZM	X2,FILNM+1
	PUSHJ	P,CLSTU3	;OUTPUT FILENAME AND EXT.
	JRST	CLSTU1

CLSTU3:	MOVEI	T4,6
	MOVE	0,FILNM
	PUSHJ	P,SIXOUT
	JUMPE	T4,.+2
	PUSHJ	P,SPACES
	MOVEI	T4,4
	MOVE	0,FILNM+1
	JUMPE	0,CLSTU6
	MOVEI	CHR,56
	PUSHJ	P,PUT
	SOJ	T4,
	PUSHJ	P,SIXOUT
	JUMPE	T4,CLSTU4
CLSTU6:	PUSHJ	P,SPACES
CLSTU4:	PUSHJ	P,CLRF
	POPJ	P,
SPACES:	MOVEI	CHR,40
	PUSHJ	P,PUT
	SOJG	T4,.-1
	POPJ	P,
SIXOUT:	MOVE	T2,[POINT 6,0]
SIX02:	ILDB	CHR,T2
	JUMPE	CHR,SIX01
	ADDI	CHR,40
	PUSHJ	P,PUT
	SOJ	T4,
	TLNN	T2,770000
SIX01:	POPJ	P,
	JRST	SIX02
CLRF:	MOVEI	CHR,15
	PUSHJ	P,PUT
	MOVEI	CHR,12
PUT:	SOSG	OBF+2		;PREPARE OUTPUT
	OUTPUT	2,
	IDPB	CHR,OBF+1
	POPJ	P,


;DELETE (DEL) ROUTINE

DELER:	PUSHJ	P,QSA
	ASCIZ	/ETE/
	JRST	.+1
	TLNE	C,F.CR			;DOES DELETE HAVE ANY ARGUMENTS?
	JRST	BADDEL			;NO. DONT ALLOW.
DELIM:	PUSHJ	P,GETNUM
	JRST	COMM1
	MOVEM	N,FRSTLN
	TLNN	C,F.CR
	TLNE	C,F.COMA
	JRST	DELIM2
	TLNN	C,F.MINS
	JRST	COMM1
	PUSHJ	P,NXCH
	PUSHJ	P,GETNUM
	JRST	COMM1
DELIM2:	MOVEM	N,LASTLN
	PUSH	P,C
	PUSHJ	P,DELL1
	POP	P,C
	TLNN	C,F.COMA
	JRST	DELIM3
	PUSHJ	P,NXCH
	JRST	DELIM
DELIM3:	TLNE	C,F.CR
	JRST	UXIT
	JRST	COMM1
DELL1:	MOVE	A,FLLIN		;FIND FIRST LINE TO DELETE
DELL2:	CAML	A,CELIN
	POPJ	P,		;THERE IS NONE
	HLRZ	N,(A)		;GET LINE NO
	CAMLE	N,LASTLN	;DONE?
	POPJ	P,
	CAMGE	N,FRSTLN
	AOJA	A,DELL2	
	PUSHJ	P,LOCKON
	PUSHJ	P,ERASE
	PUSHJ	P,LOCKOF
	JRST	DELL1		;GO LOOK FOR FIRST LINE AGAIN


;WEAVE COMMAND

WEAER:	PUSHJ	P,QSA
	ASCIZ	/VE/
	JRST	.+1
	PUSHJ	P,FILNAM
	JUMP	WEAV
	OPEN	WEAVI
	EXTERN	WEAVI,WEAV
	JRST	NODEV
	HLLZS	FILDIR+1		;LEVEL D FIX.
	SETZM	FILDIR+2
	SETZM	FILDIR+3
	LOOKUP	FILDIR
	JRST	NOGET
GETT2:	SETZM	BADGNN
	INBUF	1


GETT1:	PUSHJ	P,INLINE
	PUSHJ	P,GETDNM
	JRST	[TLNN  C,F.CR
		JRST   BADGET
		JRST   GETT1]
	MOVEM	N,BADGNN		;LAST GOOD LINE WEAVED
	PUSHJ	P,LOCKON
	PUSHJ	P,ERASE
	PUSHJ	P,INSERT
	PUSHJ	P,LOCKOF
	JRST	GETT1

;THIS ROUTINE PICKS UP A LINE NUMBER AND STOPS ON THE FIRST
;NON-DIGIT CHARACTER, INCLUDING SPACES AND TABS.
;IT IS USED BY OLD, WEAVE, AND MAINLP.

GETDNM:	MOVEI	X1,5
	C,F.DIG
	POPJ	P,
	MOVEI	N,-60(C)
GETD1:	MOVE	G,T
	PUSHJ	P,NXCHS
	SOJE	X1,CPOPJ1
	TLNN	C,F.DIG
	JRST	CPOPJ1
	IMULI	N,^D10
	ADDI	N,-60(C)
	JRST	GETD1
LENER:	PUSHJ	P,QSA
	ASCIZ	/GTH/
	JRST	.+1
	PUSHJ	P,LOCKON	;ROUTINE TO CALCULATE PROGRAM LENGTH IN CHARS.
	PUSHJ	P,PRESS		;NOTE#### LENGTH DOES NOT INCLUDE
	PUSHJ	P,LOCKOF		;LINE NUMBERS!
	MOVE	T,CETXT
	SUB	T,FLTXT
	IMULI	T,5
	PUSHJ	P,PRTNUM
	PUSHJ	P,INLMES
	ASCIZ / CHARACTERS/
	PUSHJ	P,PCRLF
	JRST	FIXUP

;TTCALL DEFINITION FOR "TAPE" AND "KEY"
OPDEF	TTCALL	[51B8]
;TTY BACK TO KEYBOARD
BIT16=2
KEYER:	SETO	A,
	TTCALL	6,A
	TLZ	A,BIT16
	TTCALL	7,A
	JRST	BASIC
;TTY INTO PAPERTAPE READER
TAPER:	PUSHJ	P,QSA
	ASCIZ	/E/
	JRST	.+1
	SETO	A,
	TTCALL	6,A
	TLO	A,BIT16
	TTCALL	7,A
	JRST	BASIC
;ROUTINE TO LIST FILE
EXTERN REVFL

EXTERN RETUR1
LISER:	PUSHJ	P,QSA
	ASCIZ	/T/
	JRST	.+1
	SETZI	F,		;ASSUME NO HEADING DESIRED.
	PUSHJ	P,QSA
	ASCIZ /NH/
	SETOI	F,		;HEADING IS DESIRED, OR CMD ERROR
	SETZM	REVFL
	PUSHJ	P,QSA
	ASCIZ	/REV/
	JRST 	.+2
	SETOM	REVFL
NUMER:	PUSHJ	P,LINLIM	;GET LINE LIMITS OR ERROR
	SKIPE	RETUR1
	PUSHJ	P,NXCH
	JUMPE	F,LISTX		;SKIP HEADING-
	PUSH	P,T
	PUSH	P,C

	PUSHJ	P,INLMES	;NO, PRINT IT.
	ASCIZ /

/
	PUSHJ	P,LIST01		;TYPE THE HEADING
	PUSHJ	P,INLMES		;AND A FEW BLANK LINES
	ASCIZ /



/
	POP	P,C
	POP	P,T
LISTX:	SKIPE	REVFL
	JRST	LIST4
	JRST	LIST1

LIST01:	PUSH	P,T		;SAVE POINTER TO INPUT LINE
	PUSH	P,C		;SAVE CURRENT CHAR.
	HLRZ	T,CURDEV
	CAIN	T,<SIXBIT /   DSK/>	;PRINT DEVICE ONLY IF UNCOMMON.
	JRST	LIST02
	MOVE	T,CURDEV	;PRINT THE
	PUSHJ	P,PRNSIX	;DEVICE NAME
	MOVSI	T,320000	;PRINT THE
	PUSHJ	P,PRNSIX	;:.
LIST02:	MOVE	T,CURNAM
	PUSHJ	P,PRNSIX
	HLRZ	T,CUREXT		;DONT PRINT EXT. UNLESS UNCOMMON
	CAIN	T,<SIXBIT /   BAS/>
	JRST	LIST03
	TLO	T,16		;INSERT SIXBIT "." BEFORE EXT
	PUSHJ	P,PRNSIX
LIST03:	PUSHJ	P,TABOUT	;EXECUTE A FORMAT ","
	CALLI	X1,23
	IDIVI	X1,^D60000
	IDIVI	X1,^D60
	MOVEI	A,":"		;THE SEPARATION CHAR BETWEEN FIELDS.
	PUSHJ	P,PRDE2	
	PUSHJ	P,TABOUT		;ANOTHER FORMAT ","
	CALL	X1,[SIXBIT /DATE/]
	IDIVI	X1,^D31
	AOJ	X2,
	MOVE	A,X2
	IDIVI	A,^D12
	AOJ	B,
	ADDI	A,^D64
	MOVE	T,X2
	PUSHJ	P,LIST06
	MOVEI	C,"-"
	PUSHJ	P,OUCH
	MOVEI	T,DATTBL-1(B)
	SETZ	D,
	PUSHJ	P,PRINT
	MOVEI	C,"-"
	PUSHJ	P,OUCH
	MOVE	T,A
	PUSHJ	P,LIST06
	POP	P,C		;RECOVER INPUT CHAR
	POP	P,T		;RECOVER INPUT POINTER
	POPJ	P,
LIST06:	IDIVI	T,^D10
	MOVEI	C,60(T)
	PUSHJ	P,OUCH
	MOVEI	C,60(T1)
	JRST	OUCH


LIST1:	PUSH	P,C
	PUSH	P,T
	MOVE	A,FLLIN
LIST2:	CAML	A,CELIN		;READ LINE LIMITS
	JRST	LIST3		;DONE IF NO MORE
	HLRZ	T,(A)		;T := LINE NO
	CAMG	T,LASTLN
	CAMGE	T,FRSTLN	;AFTER FIRST TO PRINT?
	AOJA	A,LIST2		;NO
	SKIPE	RENSW		;FOR SAVE/REPLACE ONLY
	JRST	.+3		;(NOT FOR LIST) SET UP THE
	PUSHJ	P,PRTNUM	;LINE NUMBER AS A
	JRST	LIST25		;SEQUENCE NUMBER.
	MOVE	T,TYO+2
	JUMPLE	T,LIST22
	IDIVI	T,5
	JUMPE	T1,LIST22
	SETZ	C,		;PAD WITH NULLS SO THAT THE LINE
	PUSHJ	P,OUCH		;NUMBER STARTS IN A NEW WORD.
	SOJG	T1,.-1
LIST22:	HLRZ	T,(A)
	SETZM	NUMCOT
	PUSHJ	P,PRTNUM
	MOVE	T,NUMCOT
	SUBI	T,5
	MOVE	T1,@TYO+1
	JUMPE	T,LIST23
LIST21:	LSH	T1,-7		;PAD WITH LEADING ZEROES (RE-
	TLO	T1,300000	;QUIRED BY THE LINED CUSP).
	IBP	TYO+1
	SOS	TYO+2
	AOJL	T,LIST21
LIST23:	TRO	T1,1		;SET THE "SEQ. NO." BIT.
	MOVEM	T1,@TYO+1
LIST25:	MOVE	T,(A)
	MOVEI	D,15		;QUOTE CHAR
	PUSHJ	P,PRINT
	PUSHJ	P,INLMES
	ASCIZ /
/
	AOJA	A,LIST2
LIST3:	POP	P,T
	POP	P,C
	CLOSE
	SETZI	F,
	SKIPE	RETUR1
	JRST	NUMER
	SETZM	REVFL
	SKIPE	RENSW
	JRST	RENFIL
	JRST	BASIC
LIST4:	PUSH	P,C
	PUSH	P,T
	MOVE	A,CELIN
	CAMG	A,FLLIN
	JRST	LIST3
	SOJ	A,
LIST5:	HLRZ	T,(A)
	CAML	T,FRSTLN
	CAMLE	T,LASTLN
	JRST	LIST6
	PUSHJ	P,PRTNUM
	MOVE	T,(A)
	MOVEI	D,15
	PUSHJ	P,PRINT
	PUSHJ	P,INLMES
	ASCIZ	/
/
LIST6:	SOJ	A,
	CAMGE	A,FLLIN
	JRST	LIST3
	JRST	LIST5



DATTBL:	ASCIZ	/JAN/	;TABLE OF MONTHS, USED BY HEADING TYPEOUT.
	ASCIZ	/FEB/
	ASCIZ	/MAR/
	ASCIZ	/APR/
	ASCIZ	/MAY/
	ASCIZ	/JUN/
	ASCIZ	/JUL/
	ASCIZ	/AUG/
	ASCIZ	/SEP/
	ASCIZ	/OCT/
	ASCIZ	/NOV/
	ASCIZ	/DEC/


NEWER:	SETZM	OLDFLA		;FLAG WOULD BE -1 FOR "OLD" REQUEST.
	PUSHJ	P,INLMES
	ASCIZ /NEW /
	JRST	NEWOLD
OLDER:	SETOM	OLDFLA
	PUSHJ	P,INLMES
	ASCIZ /OLD /
NEWOLD:	PUSHJ	P,INLMES
	ASCIZ /FILE NAME--/
	OUTPUT
	PUSHJ	P,INLINE
	PUSHJ	P,FILNAM
	JUMP	NEWOL1
	SKIPN	OLDFLA		;OLDFILE NAME?
	JRST	NEWOL2		;NO. ASSUME NEW NAME IS OK FOR NOW.

	OPEN	SPEC		;YES
	JRST	NODEVC		;ILLEGAL DEV NAME. BOMB CURNAM.
	HLLZS	FILDIR+1	;LEVEL D FIX.
	SETZM	FILDIR+2
	SETZM	FILDIR+3
	LOOKUP	FILDIR		;REALLY AN OLD FILE?
	JRST	NOCUR		;CAN'T FIND FILE.
	MOVE	C,NEWOL1	;FOUND FILE OR NON-DIR DEV.
	CALLI	C,4		;CAN THIS DEVICE
	TLNN	C,2		;INPUT?
	JRST	NOIN		;NO.
NEWOL2:	MOVE	C,[XWD	F.CR,15]
	PUSHJ	P,LINL1		;HAVING ACCEPTED THE NAME, DO A "DELETE"
	PUSHJ	P,SCRER1
	PUSHJ	P,NAMOVE	;ACCEPT NEW CURRENT FILNAM
	MOVE	X1,NEWOL1
	MOVEM	X1,CURDEV
	SKIPE	OLDFLA
	JRST	GETT2		;OLD FILE. FINISH BY GETTING IT.
	JRST	BASIC

;ROUTINE TO CHANGE CURRENT NAME

RENER:	PUSHJ	P,QSA
	ASCIZ	/AME/
	JRST	.+1
	TLNN	C,F.TERM	;IS THERE A NAME TO RENAME TO?
	JRST	RENA1		;YES
	PUSHJ	P,INLMES	;PROMPT USER FOR A NAME
	ASCIZ	/FILE NAME--/
	OUTPUT
	PUSHJ	P,INLINE	;THERE BETTER BE A NAME NOW.
RENA1:	SETZM	OLDFLA		;REQUEST FOR NEW FILE
	PUSHJ	P,FILNAM
	JUMP	CURDEV			;SAVE DEVICE IN CURNAM
	TLNN	C,F.TERM
	JRST	COMM1
	PUSHJ	P,NAMOVE		;SET CURINFO FROM FILDIR
	JRST	UXIT
				;ROUTINE TO SAVE NEW COPY OR AN OLD FILE
REPER:	PUSHJ	P,QSA
	ASCIZ	/LACE/
	JRST	.+1
	SETOM	OLDFLA
	JRST	SAVER0
;ROUTINE TO RENUMBER THE BASIC PROGRAM THAT IS IN CORE.
;THE COMMAND IS 
;       RESEQUENCE NN,MM,LL
;WHERE NN IS THE FIRST NUMBER AND LL IS THE STEP VALUE.
;IF OMITTED, LL, OR BOTH NUMBERS=10

;ALL LINE NUMBERS LESS THAN MM WILL NOT BE RESEQUENCED. MM MUST NOT
;BE GREATER THAN NN

;A NUMBER IS A LINE NUMBER IF:
;IT IS THE FIRST ATOM ON A LINE.
;	IT FOLLOWS AN ATOM BEGINNING WITH THE LETTERS:
;		"GOS"   OR   "GOT"   OR   "THE"
;ALSO, AFTER THE ATOM "GOTO" HAS BEEN IDENTIFIED, THE NUMBER

;FOLLOWING A COMMA IS A LINE NUMBER.
;REENTRY IS NOT ALLOWED DURING "RESEQUENCE".

RESER:	PUSHJ	P,QSA
	ASCIZ	/EQUENCE/
	JRST	.+1
	PUSHJ	P,LIMITS
	MOVE	N,LASTLN	;GET THE SECOND NUMBER(::=LOWEST)
	HRRZM	N,LOWEST
	MOVEI	N,^D10		;IF FIRST ARG=0, ASSUME FIRST LINE=10
	SKIPN	FRSTLN
	MOVEM	N,FRSTLN
	TLNN	C,F.COMA	;IS THERE A THIRD ARG (THE INCREMENT)?
	JRST	RES1		;NO. LET INCREMENT =^D10
	PUSHJ	P,NXCH
	PUSHJ	P,GETNUM
	JRST	COMM1

RES1:	MOVEM	N,LASTLN	;SAVE INCREMENT
SEQ1:	HRLZ	A,LOWEST	;SEARCH FOR FIRST LINE TO CHANGE
	MOVEI	R,LINROL
	PUSHJ	P,SEARCH
	JFCL
	CAMN	B,FLLIN		;RESEQ ALL LINES?
	JRST	.+4			;YES.
	HLRZ	N,-1(B)			;NO. MAKE SURE LINE ORDER WILL NOT CHANGE
	CAML	N,FRSTLN
	JRST	RESERR
	MOVN	X2,B
	ADD	X2,CELIN	;THIS IS THE NUMBER OF LINES TO RESEQ
	SUBI	X2,1
	IMUL	X2,LASTLN
	ADD	X2,FRSTLN
	CAILE	X2,^D99999
	JRST	SEQOV
	PUSHJ	P,LOCKON	;DONT ALLOW REENTRY.
	MOVE	E,CELIN	;COMPUTE NUMBER OF LINES
	SUB	E,B
	JUMPE	E,UXIT	;NOTHING TO RENUMBER
	MOVN	L,E
	MOVSI	L,(L)
	SUB	B,FLLIN
	MOVEM	B,LOWSTA
	HRR	L,B
	PUSH	P,L		;SAVE L FOR SECOND LOOP.
	HRL	B,B		
	SUB	L,B

;THE LOOP THAT COPIES EACH LINE FOLLOWS:
SEQ2:	MOVE	D,[POINT 7,LINB0]	;BUILD EACH LINE IN LINB0. THEN REINSERT IT.
	MOVEM	D,SEQPNT
	HRRZ	F,L
	ADD	F,FLLIN
	HRRZ	T,(F)
	HRLI	T,440700	;POINTER TO OLD LINE IS IN G
				;F USED AS A FLAG REGISTER FOR " ' ETC.
;THE FLAGS ARE
			REST.F=1	;COPY  THE REST (APOST SEEN)
			TOQU.F=2	;COPY TO QUOTE SIGN
			COMM.F=4	;LINE NUMBER FOLLOWS ANY COMMA
			NUM.F=10	;NEXT NUMBER IS LINE NUMBER
;THE CHARACTER/ATOM LOOP:
SEQ3:	PUSHJ	P,NXCHS		;GET NEXT CHAR, EVEN IF SPACE OR TAB
	TLNE	C,F.CR
	JRST	SEQCR
	TLNE	C,F.QUOT		;TEST FOR QUOTE CHAR
	TLCA	F,TOQU.F		;REVERSE QUOTE SWITCH AND COPY THIS CHAR
	TLNE	F,TOQU.F
	JRST	SEQCPY
	TLNE	C,F.APOS
	TLOA	F,REST.F		;APOST SEEN, COPY REST
	TLNE	F,REST.F
	JRST	SEQCPY
	MOVE	G,T			;SAVE POINTER
	TLNN	F,NUM.F		;EXPECTING A LINE NUMBER?
	JRST	SEQ4			;NO. LOOK FOR KEYW ATOMS
	TLNN	C,F.DIG
	JRST	SEQCPY
	JRST	SEQNUM			;GO TRANSLATE LIN NUMBER
SEQ4:	TLNE	F,COMM.F
	TLNN	C,F.COMA
	JRST	.+3
	TLO	F,NUM.F		;THIS COMMA IMPLIES NUMBER TO FOLLOW
	JRST	SEQCPY
	PUSHJ	P,ALPHSX		;PUT NEXT ALL-LETTER ATOM IN A
	MOVEI	B,SEQTND-SEQTBL	;SET INDEX FOR TABLE OF KEYWORDS PRECEDING LINE NUMBERS
	MOVE	T,G			;RESET CHAR POINTER TO START OF ATOM.
	CAMN	A,SEQTBL(B)
	TLOA	F,NUM.F+COMM.F		;WE FOUND A KEYWORD
	SOJGE	B,.-2
	LDB	C,T
SEQCPY:	IDPB	C,SEQPNT
	JRST	SEQ3

SEQTBL:	SIXBIT /GOSUB/		;TABLE OF KEYWORDS PRECEDINGLINE NUMBERS
	SIXBIT /GOTO/
SEQTND:	SIXBIT /THEN/

SEQNUM:	PUSH	P,G		;SAVE POINTER IN CASE OF "GLOBAL" LINE NUMBER
	PUSHJ	P,GETNUM
	HALT	.
	CAMGE	N,LOWEST
	JRST	SEQB1		;DONT RESEQ THIS NUMBER
	MOVEI	R,LINROL
	HRLZ	A,N
	PUSHJ	P,SEARCH
	JRST	SEQBAD
SEQCAL:	SUB	B,FLLIN
	SUB	B,LOWSTA
	IMUL	B,LASTLN
	ADD	B,FRSTLN		;THIS IS THE NEW LINE NUMBER
	MOVE	X1,B
	PUSHJ	P,MAKNUM		;DEPOSIT THE NUMBER IN LINB0
	POP	P,X1			;CLEAR PLIST A LITTLE
SEQCA1:	TLZ	F,NUM.F
	LDB	C,T
	PUSHJ	P,NXCHS+1
	JRST	SEQ3+1
SEQBAD:	MOVE	T,N		;PRINT "GLOBAL" LINE NUMBER
	PUSHJ	P,PRTNUM
	PUSHJ	P,INLMES
	ASCIZ / IN LINE /
	HLRZ	T,(F)
	PUSHJ	P,PRTNUM
	PUSHJ	P,PCRLF
;IN A ROLL, AND THEN PRINTED AT THE END, WITH REENTRY ALLOWED.
SEQB1:	POP	P,T			;POINT TO BAD NUMBER.
	LDB	C,T
	TLZ	F,NUM.F
	JRST	SEQCPY			;COPY IT
SEQCR:	IDPB	C,SEQPNT
	HLRZ	N,(F)
	PUSHJ	P,ERASE		;ERASE OLD LINE COPY
	MOVE	T1,SEQPNT		;POINT TO END OF LINE FOR NEWLIN
	PUSHJ	P,NEWLIN		;INSERT NEW ONE WITH OLD LINE NUMBER.
	AOBJN	L,SEQ2			;DO NEXT LINE
	POP	P,L
	ADD	L,FLLIN
	MOVE	N,FRSTLN
	HRLM	N,(L)
	ADD	N,LASTLN
	AOBJN	L,.-2
	JRST	UXIT			;FINISHED. ALLOW REENTRY.
SEQOV:	PUSHJ	P,INLMES
	ASCIZ /COMMAND ERROR (LINE NUMBERS MAY NOT EXCEED 99999)
/
	JRST	FIXUP
;ROUTINE TO SAVE PROGRAM

SAVER:	PUSHJ	P,QSA
	ASCIZ	/E/
	JRST 	.+1
	SETZM	OLDFLA		;SAVE "NEW" FILE ONLY
SAVFIL:
SAVER0:	PUSHJ	P,FILNAM
	JUMP	SAVE1
	PUSHJ	P,LIMITS
	MOVE	A,SAVE1		;CAN THE DEVICE
	CALLI	A,4		;BE
	TLNN	A,1		;OUTPUT TO?
	JRST	NOOUT		;NO.
	OPEN	SAVI
	EXTERN	SAVE1,SAVI
	JRST	NODEV		;ILLEGAL DEVICE NAME
	PUSHJ	P,LOCKON		;DONT ALLOW REENTRY UNTIL 
;					;SAVE IS CHANGED TO BUILD TEMP FILE AND RENAME.
	HLLZS	FILDIR+1	;LEVEL D FIX.
	SETZM	FILDIR+2
	SETZM	FILDIR+3
	SKIPE	OLDFLA		;TRYING TO SAVE NEW FILE?
	JRST	SAVE3
	TLNN	A,4		;YES, DOES THE DEVICE HAVE A DIR?
	JRST	SAVE2		;NO.
	LOOKUP	FILDIR		;YES, DOES THE FILE EXIST?
	JRST	SAVE2		;NO, GOOD
	JRST	NOTNEW
SAVE3:	LOOKUP	FILDIR		;IS THIS REALLY AN OLDFILE?
	JRST	NOGET		;NO. GRONK.
SAVE2:	CLOSE			;OTHERWISE REPLACE WILL APPEND.
	HLLZS	FILDIR+1	;LEVEL D FIX.
	SETZM	FILDIR+2
	SETZM	FILDIR+3
	ENTER	FILDIR
	JRST	NOSAVE
	OUTBUF	1
	EXTERN	RENSW
	SETOM	RENSW
	JRST	LIST1

RENFIL:	SETZM	RENSW
	MOVE	A,SAVE1		;IF THE DEVICE IS A DECTAPE,
	CALL	A,[SIXBIT/DEVCHR/] ;THE RENAME WILL FAIL AND IS UN-
	TLNE	A,100		;NECESSARY ANYWAY, SO RETURN IMMEDIATELY.
	JRST	BASIC		
	OPEN	SAVI		;THIS STRANGE PROCEDURE IS
	JRST	NODEV		;FOLLOWED BECAUSE THE GETTAB UUO ENTRY
	PUSHJ	P,LOCKON	;THAT CONTAINS THE INSTALLATION STANDARD
	HLLZS	FILDIR+1	;PROTECTION CODE IS NOT IMPLEMENTED IN
	SETZM	FILDIR+2	;THE 4 SERIES MONITOR.
	SETZM	FILDIR+3
	LOOKUP	FILDIR
	JRST	NOGET
	CLOSE
	HLLZ	A,FILDIR+2
	TLZ	A,777
	IOR	A,MONLVL	;MONLVL CONTAINS THE APPROPRIATE
	MOVEM	A,FILDIR+2	;"DON'T DELETE" BIT.
	HLLZS	FILDIR+1
	SETZM	FILDIR+3
	RENAME	FILDIR
	JRST	NOREN
	JRST	BASIC
NOREN:	PUSHJ	P,TTYIN
	PUSHJ	P,INLMES
	ASCIZ	/FILE SAVED BUT NOT PROTECTED
/
	OUTPUT
	JRST	BASIC

;ROUTINE TO CLEAR TXTROL.

SCRER:	PUSHJ	P,QSA
	ASCIZ	/ATCH/
	JRST	.+1
	PUSH	P,[EXP UXIT]
SCRER1:	MOVE	X1,FLTXT
	MOVEM	X1,CETXT
	MOVE	X1,FLLIN
	MOVEM	X1,CELIN
	POPJ	P,

;ROUTINE TO RETURN TO THE SYSTEM.

SYSER:	PUSHJ	P,QSA
	ASCIZ	/TEM/
	JRST	.+1
	CALLI	12

;ROUTINE TO UNSAVE FILES "UNS" OR "UNSAVE"
UNSER:	PUSHJ	P,QSA
	ASCIZ	/AVE/
	JRST	.+1
	SETZM	OLDFLA
UNSVFL:	PUSHJ	P,FILNAM
	JUMP	SAVE1
	MOVE	A,SAVE1
	CALL	A,[SIXBIT/DEVCHR/] ;DEVICE MUST BE DISK OR DECTAPE.
	TLNN	A,200100
	JRST	NOUSDV
	OPEN	SAVI
	JRST	NODEV
	HLLZS	FILDIR+1	;LEVEL D FIX.
	SETZM	FILDIR+2
	SETZM	FILDIR+3
	LOOKUP	FILDIR		;LOOKUP THE FILENAME
	JRST	NOGET
	CLOSE
	SETZM	FILDIR
	RENAME	FILDIR		;ZERO DIRECTORY ENTRY
	JRST	NOUNSV
	JRST	BASIC
SUBTTL	COMMAND SUBROUTINES
;ROUTINE TO PICK UP FILE NAME AND SET UP FOR DSK ACTION

FILNAM:	POP	P,B
	PUSHJ	P,FILSET
FILN1:	PUSHJ	P,ATOMSX
	MOVEI	X1,":"
	CAIE	X1,(C)
	JRST	.+3
	MOVEM	A,@(B)		;ITS A DEVICE. PRIME NEXT INIT.
	JRST	FILN2
	TLNN	C,F.PER
	JRST	FILN3
	JUMPE	A,COMM1		;A FILE NAME MUST PRECEED THE EXT.
	CAIE	X2,FILDIR	;IS THIS THE FIRST DOT?
	JRST	COMM1		;NO. GRONK.
	MOVEM	A,FILDIR
	MOVEI	X2,FILDIR+1	;EXPECT AN EXT 
FILN2:	PUSHJ	P,NXCH
	JRST	FILN1
FILN3:	JUMPN	A,FILN4
	HRRZ	A,B		;WHO WANTS A FILENAME?
	CAIN	A,UNSVFL+1
	JRST	FILN6
	CAIN	A,SAVFIL+1
FILN6:	CAIE	X2,FILDIR
	JRST	COMM1
	SKIPN	A,CURNAM
	JRST	COMM1		;THERE IS NO CURRENT NAME.
	MOVEM	A,(X2)
	HLLZ	A,CUREXT
	MOVEM	A,FILDIR+1
	MOVEI	X2,FILDIR
	CAIA
FILN4:	MOVEM	A,(X2)
	MOVEI	A,DRMBUF
	MOVEM	A,JOBFF
	JRST	1(B)

;ROUTINE TO CONVERT NEXT ATOM TO SIXBIT
ALPHSX:	SKIPA	D,[Z (F.LETT)]
ATOMSX:	HRLZI	D,F.DIG+F.LETT
	TLZ	B,777777	;SET LH OF A+1 TO 0
	MOVEI	A,0
	MOVE	X1,[POINT 6,A]
ATOMS1:	TDNN	C,D
	POPJ	P,
	PUSHJ	P,SCNLTN	;PACK THIS LETTER INTO A.
	JFCL		;SCNLTN HAS SKIP RETURN.
	TLNE	X1,770000
	JRST	ATOMS1
	POPJ	P,

FILSET:	MOVEI	A,<SIXBIT /   DSK/>
	HRLI	A,<SIXBIT /   BAS/>
	HRLZM	A,@(B)
	HLLZM	A,FILDIR+1
	CALLI	X2,24		;GET PROJ-PROG NUMBER
	MOVEM	X2,FILDIR+3	;SET USER'S I-D
	MOVEI	X2,FILDIR
	POPJ	P,

NAMOVE:	MOVE	X1,FILDIR
	MOVEM	X1,CURNAM
	MOVE	X1,FILDIR+1
	MOVEM	X1,CUREXT
	POPJ	P,

;ROUTINES TO SET LINE LIMITS
LIMITS:	TLNE	C,F.TERM
	JRST	LIMIT1
	PUSHJ	P,GETNUM
LIMIT1:	MOVEI	N,0
	MOVEM	N,FRSTLN
	TLNE	C,F.TERM
	JRST	LIMIT2
	TLNN	C,F.COMA
	JRST	COMM1
	PUSHJ	P,NXCH
	PUSHJ	P,GETNUM
LIMIT2:	MOVSI	N,1
	MOVEM	N,LASTLN
	POPJ	P,
LINLIM:	SETZM	RETUR1
	SKIPN	REVFL
	TLNE	C,F.TERM
	JRST	LINL3
	PUSHJ	P,GETNUM
LINL1:	MOVEI	N,0
	MOVEM	N,FRSTLN
	TLNN	C,F.TERM
	JRST	LINL4
LINL6:	MOVEM	N,LASTLN
	POPJ	P,
LINL4:	TLNN	C,F.COMA
	JRST	LINL5
	SETOM	RETUR1
	JRST	LINL6
LINL5:	TLNN	C,F.MINS
	JRST	COMM1
	PUSHJ	P,NXCH
	PUSHJ	P,GETNUM
LINL2:	MOVSI	N,1
	MOVEM	N,LASTLN
RETRN:	HRRZ	C,C
	CAIN	C,54
	SETOM	RETUR1
	POPJ	P,
LINL3:	SETZM	FRSTLN
	MOVSI	N,1
	MOVEM	N,LASTLN
	POPJ	P,

;A NONPRINTING ROUTINE SIMILAR TO PRTNUM:

MAKNUZ: SETZM @SEQPNT ;CLEAR JUNK BEFORE LINE NO CALC
MAKNUM:	IDIVI	X1,^D10
	JUMPE	X1,MAKN1
	PUSH	P,X2
	PUSHJ	P,MAKNUM
	POP	P,X2
MAKN1:	MOVEI	X2,60(X2)
	IDPB	X2,SEQPNT
	POPJ	P,
;ROUTINE TO ERASE LINE.  LINE NO IN N.

ERASE:	HRLZ	A,N		;LOOK FOR LINE
	MOVEI	R,LINROL
	PUSHJ	P,SEARCH
	POPJ	P,		;NONE.  GO TO INSERTION

	MOVE	D,(B)		;PICK UP LOC OF LINE
	HRLI	D,440700	;MAKE BYTE POINTER
	MOVEI	T1,0		;TO USE IN DEPOSITING
ERAS1:	ILDB	C,D		;GET CHAR
	DPB	T1,D		;CLOBBER IT
	CAIE	C,15		;CARRIAGE RET?
	JRST	ERAS1		;NO.  GO FOR MORE

	SETOM	PAKFLA		;MARK FACT THAT THERE IS A HOLE

	MOVEI	E,1		;REMOVE ENTRY FROM LINE TABLE
	JRST	CLOSUP

;HERE WE HAVE A LINE OF INPUT AND THERE IS NO EXISTING LINE

INSERT:	MOVE	T1,[POINT 7,LINB0]
	MOVE	T,G		;RESTORE PNTR TO 1ST CHR
INSE2:	ILDB	C,T		;GET NEXT CHAR
INSE3:	CAIN	C,15		;CHECK FOR CAR RET
	JRST	INSE4
	IDPB	C,T1
	JRST	INSE2

INSE4:	JUMPL	T1,CPOPJ	;CR SEEN.  DONE IF JUST DELETION
	IDPB	C,T1		;STORE THE CR
	MOVEI	C,0		;CLEAR REST OF WORD
	TLNE	T1,760000
	JRST	.-3
	JRST	NEWLIN

;AT THIS POINT, N CONTAINS A LINE NUMBER AND LINB0 CONTAINS
;A NON-EMPTY INSERTED LINE.  T1 CONTAINS ADDRESS OF LAST
;WORD OF THE LINE.

NEWLIN:	MOVEI	T1,(T1)		;COMPUTE LINE LENGTH
	SUBI	T1,LINB0-1

	ADD	T1,CETXT	;COMPUTE NEW CEILING OF TEXT ROLL
	CAMGE	T1,FLLIN	;ROOM FOR LINE PLUS LINROL ENTRY?
	JRST	NEWL1		;YES
NEWL0:	SUB	T1,CETXT	;ASK FOR MORE CORE
	MOVE	E,T1
	ADDI	E,1
	PUSHJ	P,PANIC
	ADD	T1,CETXT

NEWL1:	MOVE	D,CETXT	;LOC OF NEW LINE
	MOVE	T,D		;CONSTRUCT BLT PNTR
	HRLI	T,LINB0
	BLT	T,-1(T1)	;MOVE THE LINE
	MOVEM	T1,CETXT	;STORE NEW CEILING


;HERE, LINE IS IN PLACE, ITS LOC IN D, LINE NUMBER IN N.
;MUST STILL PUT LINE NUMBER IN LINROL.

NEWNBR:	PUSH	P,D		;*****JUST IN CASE*****
	MOVEI	R,LINROL
	HRLZ	A,N
	PUSHJ	P,SEARCH
	JRST	.+2
	HALT	.		;*****IMPOSSIBLE CONDITION*****

	MOVEI	E,1
	PUSHJ	P,OPENUP	;MAKE ROOM FOR IT
	POP	P,D		;*****OTHER HALF OF JUST IN CASE*****
	HRRI	A,(D)		;CONSTRUCT LINROL ENTRY
	MOVEM	A,(B)		;STORE ENTRY
	POPJ	P,		;ALL DONE
SUBTTL COMMAND ERROR MESSAGES
NOOUT:	PUSHJ	P,TTYIN
	PUSHJ	P,INLMES
	ASCIZ	/CANNOT OUTPUT TO THIS DEVICE/
	OUTPUT
	JRST	BASIC
NOIN:	PUSHJ	P,TTYIN
	PUSHJ	P,INLMES
	ASCIZ	/CANNOT INPUT FROM THIS DEVICE/
	OUTPUT
	JRST	BASIC
COMM1:	PUSHJ	P,INLMES
	ASCIZ /WHAT?
/
COMM1A:	SKIPE	CURNAM		;HAS A NEW OR OLD FILE BEEN SPECIFIED YET?
	JRST	FIXUP		;YES, SAY "READY"
	JRST	ASKNEW		;NO, ASK "NEW OR OLD"

BADDEL:	PUSHJ	P,INLMES	;DELETE COMMAND HAD NO ARGUMENTS.
	ASCIZ /DELETE COMMAND MUST SPECIFY WHICH LINES TO DELETE
/
	JRST	COMM1A

NOSAVE:	PUSHJ	P,TTYIN
	PUSHJ	P,INLMES
	ASCIZ	?CANNOT SAVE/REPLACE ?
	MOVE	T,FILDIR
	PUSHJ	P,PRNSIX
	HLRZ	T,FILDIR+1
	CAIN	T,<SIXBIT/   BAS/>
	JRST	.+3
	TLO	T,16
	PUSHJ	P,PRNSIX
	PUSHJ	P,INLMES
	ASCIZ	/
/
	OUTPUT
	JRST	BASIC
	
NOUNSV:	PUSHJ	P,TTYIN
	PUSHJ	P,INLMES
	ASCIZ	/UNSAVE DID NOT WORK
/
	OUTPUT
	JRST	BASIC

CATFAL:	PUSHJ	P,TTYIN
	PUSHJ	P,INLMES
	ASCIZ	/CATALOG DEVICE MUST BE DISK OR DECTAPE
/
	OUTPUT
	JRST	BASIC
NOUSDV:	PUSHJ	P,TTYIN
	PUSHJ	P,INLMES
	ASCIZ	/UNSAVE DEVICE MUST BE DISK OR DECTAPE
/
	OUTPUT
	JRST	BASIC

NOCUR:
NOGET:	PUSHJ	P,TTYIN
	PUSHJ	P,INLMES
	ASCIZ	/FILE NOT SAVED/
	OUTPUT
	JRST	BASIC
TTYIN:	SETZM	TABFG		;FORMAT ON TABS
	MOVEI	T,TTYBUF	;SET UP TTY BUFFS
	MOVEM	T,JOBFF
	INIT	1
	SIXBIT	/TTY/
	XWD	TYO,TYI
	HALT	.-3
	INBUF	1
	OUTBUF	1
	POPJ	P,

	EXTERN BADGNN,BADMSG,CRLFMS
BADGET:	MOVEI	T,BADMSG
	MOVE	X1,[POINT 7,BADGNN]
	MOVEM	X1,SEQPNT
	MOVE	X1,BADGNN		;LAST GOOD LINE NUMBER.
	TLNN	X1,-1		;HAS IT BEEN CHANGED ALREADY?
	PUSHJ P,MAKNUZ  ;NO, MAKE THE NUMBER
	CALL	T,[SIXBIT /DDTOUT/ ]
	MOVEI	T,CRLFMS
	CALL	T,[SIXBIT /DDTOUT/ ]
	JRST	GETT1


NODEVC:
NODEV:
	PUSHJ	P,TTYIN
	PUSHJ	P,INLMES
	ASCIZ /NO SUCH DEVICE/
	OUTPUT
	JRST	BASIC

NODEVX:	PUSHJ	P,TTYIN
	PUSHJ	P,INLMES
	ASCIZ	/
NO SUCH DEVICE
/
	OUTPUT
	JRST	UXIT

NOTNEW:	PUSHJ	P,TTYIN
	PUSHJ	P,INLMES
	ASCIZ /DUPLICATE FILE NAME. REPLACE OR RENAME/
	OUTPUT
	JRST	BASIC

RESERR:	PUSHJ	P,INLMES
	ASCIZ /COMMAND ERROR (YOU MAY NOT OVERWRITE LINES OR CHANGE THEIR ORDER)
/
	OUTPUT
	JRST	BASIC
SUBTTL COMPILER MAIN LOOP

;BEGINNING OF COMPILATION

RUNER:	MOVEI	A,0
        PUSHJ P,QSA             ;IS IT RUNNH
	ASCIZ /NH/
	MOVEI	A,1		;NO, PRINT HEADING
        TLNN    C,F.TERM
        JRST   COMM1
	JUMPE	A,RUNNH		;SHALL WE PRINT THE HEADING?
	PUSHJ	P,INLMES	
	ASCIZ	/
/
	PUSHJ	P,LIST01	;PRINT HEADING SANS <RETURN>
	OUTPUT
	PUSHJ	P,INLMES
	BYTE (7) 15,12,12	;SKIP TWO LINES
RUNNH:	PUSHJ	P,LOCKON	;PROTECT REST OF COMPILATION
	PUSHJ	P,PRESS		;GUARANTEE SOURCE DOESN'T MOVE!!!
	MOVEI	X1,CODROL		;COMPILE TIME.
	MOVEM	X1,TOPSTG		;TXT,LIN,CODROLS ARE STODGY. OTHERS MOVE.
	MOVEI	R,LINROL
	PUSHJ	P,SLIDRL	;SLIDE LINROL DOWN NEXT TO TXTROL.
	JRST	RUNER1

SLIDRL:	MOVE	X2,CEIL(R)
	HRRZ	X1,CEIL-1(R)	;SLIDE ROLL DOWN  NEXT TO LOWER ROLL
	ADD	X2,X1
	HRL	X1,FLOOR(R)	;SET UP BLT TO MOVE ROLL
	SUB	X2,FLOOR(R)
	HRRZM	X1,FLOOR(R)	;SET NEW ROLL FLOOR
	BLT	X1,(X2)
	MOVEM	X2,CEIL(R)
	POPJ	P,

RUNER1:	MOVEM	X2,FLCOD
	MOVEM	X2,CECOD	;CODROL IS ALSO PACKED IN PLACE.
	MOVEI	X1,CODROL	;PREPARE TO CLOBBER ALL ROLLS ABOVE CODROL
	MOVE	T,JOBREL		;USE THIS VALUE.
	PUSHJ	P,CLOB		;DO THE CLOBBERING.
	MOVEI	F,0		;CLEAR COMPILATION FLAGS
	MOVEI	T,0		;SET UP AC FOR CALLI.
	CALLI	T,27		;GET TIME OF START.
	MOVEM	T,MTIME		;SAVE TIME AT START OF RUNER
	SETOM	RUNFLA	;AND USE IT AS RUN FLAG
	SETZM	DATAFF		;CLEAR DATA FLAG
	SETZM	DSKIFL
	SETZM	DSKOFL
	SETOM	TMPLOW	;NO TEMPORARIES USED YET.

	MOVEI	F,REFROL	;CREATE A ROLL OF ZEROS
	PUSHJ	P,ZERROL

;NOW MARK THIS ROLL TO SHOW WHAT PARTS OF THIS PROG ARE INSIDE OF FUNCTIONS:
LUKDEF:	MOVEI	A,LUKDEF+1	;SCAN FOR NEXT "DEF" STA
	PUSHJ	P,NXLINE	;PREPARE TO READ THE NEXT LINE.
	MOVEI	X1,[ASCIZ/DEFFN/]
	PUSHJ	P,QST		;IS IT A "DEF" STA?
	JRST	LUKD3		;NO. GO ON TO NEXT LINE

	HRRZ	B,C		;YES. SAVE FN NAME.

	MOVEI	A,LUKD2
LUKD1:	PUSHJ	P,NXCH		;NOW LOOK FOR EQUAL SIGN
	TLNE	C,F.TERM
	JRST	LUKD3		;NO EQUAL. ITS A MULTILINE DEF.
	TLNN	C,F.EQAL
	JRST	LUKD1		;TRY NEXT CHAR.
	JRST	LUKD3-1		;ITS A ONE LINE DEF. IGNORE IT.

LUKD2:	MOVEI	A,LUKD2+2		;MARK EVERY LINE OF THIS MULTILINE FN!
	ROT	B,-7		;PUT FUNCTION NAME IN FIRST CHAR POSITION
	PUSHJ	P,NXLINE
	MOVEM	B,(G)		;NOW THIS LINE CONTAINS THE NAME OF ITS FN.
	MOVEI	X1,[ASCIZ /FNEND/]
	PUSHJ	P,QST		;END OF THE FN?
	CAIA
	MOVEI	A,LUKDEF+1		;YES. SCAN FOR NEXT DEF.

LUKD3:	AOBJN	L,(A)		;GET NEXT LINE, IF THERE IS ONE.
	JRST	RUNER2


;FINISHED MARKING FUN LINES. NOW SET UP A CLEAR LADROL...
RUNER2:	MOVEI	F,LADROL
	PUSHJ	P,ZERROL
	JRST	EACHLN

;ROUTINE TO MAKE A ROLL OF ZEROS =IN LNTH TO LINROL.
ZERROL:	MOVE	R,F
	MOVE	E,CELIN	;COMPUTE LENGTH OF ROLL
	SUB	E,FLLIN
	JUMPE	E,NOEND		;NOTHING TO DO

	MOVN	L,E		;SAVE FOR LINE CNTR.
	MOVSI	L,(L)
	PUSHJ	P,BUMPRL	;ADD TO (EMPTY) ROLL
	MOVE	T,FLOOR+(F)	;CLEAR IT TO 0S
	SETZM	(T)
	HRL	T,T
	ADDI	T,1
	MOVE	T1,CEIL+(F)
	CAILE	T1,(T)		;SUPPRESS BLT IF ONLY 1 LINE
	BLT	T,-1(T1)
	POPJ	P,
;SO FAR, WE HAVE SET UP LADROL FOR ADDRESSES & CHAINS FOR LABLES
;ALSO, L IS A WORD TO AOBJN & COUNT THROUGH LINES.
;BEGIN COMPILATION OPERATIONS FOR EACH LINE

EACHLN:	MOVE	P,PLIST		;FIX P LIST IN CASE LAST INST FAILED
	PUSHJ	P,LOCKOF	;CHECK REENTER REQUEST
	PUSHJ	P,LOCKON
	MOVE	X1,TMPLOW
	MOVEM	X1,TMPPNT	;NO UNPROTECTED TEMPORARIES USED YET.
	SETZM	LETSW
	SETZM	REGPNT		;REG IS FREE
	SETZM	PSHPNT		;NO "PUSH" INSTS GENERATED YET
	SETOM	STRFLA		;NO STRINGS OR STR VARS SEEN YET
	SKIPE	FUNAME		;IN MIDST OF MULTI-LINE FUNCTION
	JRST	EACHL2		;YES, DONT TOUCH ARGUMENT ROLL
	MOVE	X1,FLARG		;NO FUNCTION ARGS YET
	MOVEM	X1,CEARG
EACHL2:	PUSHJ	P,NXLINE	;SET UP POINTER TO THIS LINE.
	MOVSI	A,(SIXBIT /REM/)	;PREPARE FOR COMMENT
	TLNE	C,F.TERM	;NULL STATEMENT?
	JRST	EACHL1		;YES. ELIDED "REM" (FIRST CHAR WAS AN APOSTROPHE)
	PUSHJ	P,SCNLT1		;SCAN FIRST LTR
	CAIE	C,"("
	TLNE	C,F.EQAL+F.DIG+F.DOLL	;ELIDED LETTER?
	JRST	ELILET		;YES.  POSSIBLE ASSUMED "LET"
			;NOTE: THE VALUE OF A MULTI-LINE FUNCTION MAY NOT
			;BE ASSIGNED BY AN ELIDED LET. E.G., THIS IS ILLEGAL:
			;FNA=Q*R+1
	PUSHJ	P,SCNLT2		;SCAN SECOND LETTER.
	JRST	ILLINS		;SECOND CHAR WAS NOT A LETTER.
	MOVS	X1,A
	CAIE	X1,(SIXBIT /IF/)
	CAIN	X1,(SIXBIT /ON/)
	JRST	EACHL1
	CAIE	X1,(SIXBIT /FN/)	;ELIDED LET FNX=  ?
	JRST	EACHL3		;NO.
	PUSHJ	P,SCNLT3
	JRST	ILLINS
	TLNE	C,F.EQAL	;IS FOURTH CHAR AN '=' SIGN?
	JRST	ELILET		;YES, ELIDED STATEMENT
	JRST	EACHL1		;NO, BETTER BE FNEND.

EACHL3:	PUSHJ	P,SCNLT3		;ASSEMBLE THIRD LETTER OF STATEMENT IN A
	JRST	ILLINS		;THIRD CHAR WAS NOT A LETTER
	CAMN	A,[624555000000]	;FIX FOR REM
	HRRZ	C,C			;TWO LINES.
	JRST	EACHL1

ELILET:	MOVSI	A,(SIXBIT /LET/)	;ASSUME A "LET" STATEMENT.
	MOVS	T,D			;GO BACK TO THE FIRST LETTER.
	HRLI	T,440700
	PUSHJ	P,NXCHK

;HERE, FIRST 3 LTRS OF VERB (SIXBIT) ARE IN A.  USE TBL LOOKUP AND DISPATCH.

EACHL1:	MOVEI	R,STAROL
	PUSHJ	P,SEARCH	;LOOK IN STATEMENT TYPE TABLE
	JRST	ILLINS		;NO SUCH, GO BITCH
	HRRZ	A,(B)		;FOUND.

	MOVE	X1,CECOD	;PUT REL ADDRS IN LADROL
	SUB	X1,FLCOD
	MOVE	X2,FLLAD
	ADDI	X2,(L)
	HRLM	X1,(X2)
	HRLI	D,(MOVEI L,)
        TRZN   A,20000          ;EXECUTABLE?
	JRST	EACHL6
	EXTERN SORCLN
	PUSHJ	P,BUILDI	;FORCE STORE OF SOURCE LINE
	MOVE D,[MOVEM L,SORCLN]	;NUMBER IN SORCLN.
	PUSHJ	P,BUILDI
EACHL6:	MOVE	X1,A

	TRZN	X1,40000	;MORE TO COMMAND?
	SOJA	X1,EACHL5	;NO. JUST DISPATCH
	PUSHJ	P,QST		;CHECK REST OF COMMAND
	JRST	ILLINS

EACHL5:	TLNN	C,F.STR
	JRST	1(X1)
	CAME	C,[1000000043]
	FAIL	<ILLEGAL CHARACTER>
	MOVEI	X2,1(X1)
	CAIE	X2,XREST+1
	CAIN	X2,XINPUT+1
	JRST	2(X1)
	CAIN	X2,XREAD+1
	JRST	XINPUT+2
	CAIN	X2,XPRI1
	JRST	FFO
	FAIL	<ILLEGAL CHARACTER>
;HERE ON END OF STATEMENT XLATION

NXTSTA:	TLNN	C,F.TERM		;CHECK FOR END OF LINE
	JRST	GRONK


;ENTER HERE FROM ERROR ROUTINE

NXTST1:	MOVSI	D,(DATA 2,)
	SKIPE	DSKIFL
	PUSHJ	P,BUILDI
	SETZM	DSKIFL
	MOVSI	D,(DATA 7,)
	SKIPE	DSKOFL
	PUSHJ	P,BUILDI
	SETZM	DSKOFL
	AOBJN	L,EACHLN
NOEND:	PUSHJ	P,INLMES	;IF NONE, DIDNT SEE END
	ASCIZ	/
NO END INSTRUCTION
/
				;FALL INTO UXIT



;END OF COMPILE/EXECUTE PHASE

	EXTERN	UXFLAG
EXTERN	CLOSED,RENAMD


UXIT:	SETZM	FUNAME
	MOVE	P,PLIST
	SETZM	NUMCOT
	SETZM	TABFG	;ZERO TAB FUNCTION FLAG
	SETZB	LP,IFIFG
	SETZM	ODF
	DEFINE R(A)
<	IRP	A
<	RELEASE	^D<A>,	>>
        R<1,2,3,4,5,6,7,8,9>     ;DISK DATA FILES 1-9
	SKIPN	UXFLAG		;END OF PROGRAM EXECUTION?
	JRST	UXIT1		;NO.
	SETZM	UXFLAG		;YES.
	MOVEI	X1,^D9
	MOVEI	A,3
UXIT2:	CAMN	A,ACTBL-1(X1)	;ACTBL ENTRY = 3 IF FILE
	JRST	.+3		;IS BEING WRITTEN.
	SOJG	X1,UXIT2
	JRST	UXIT1
	MOVE	X2,FILD-1(X1)
	MOVEM	X2,LOK
	MOVEI	X2,@BA-1(X1)
	MOVEM	X2,JOBFF
	XCT	INITI-1(X1)
	JRST	NODEVX		;OUTPUT MESSAGE "NO SUCH DEVICE"
	DPB	X1,[POINT 4,LOKUP,12]	;AND GIVE UP BECAUSE
	HLLZS	LOK+1		;ALL DEVICES ARE THE SAME.
	SETZM	LOK+2
	SETZM	LOK+3
	XCT	LOKUP
	JRST	LOKFAL		;OUTPUT THE MESSAGE "NO FILE
	DPB	X1,[POINT 4,CLOSED,12]	 ;ON CHANNEL N" AND COME BACK
	XCT	CLOSED		;TO TRY
	HLLZS	X2,LOK+2	;TO PROTECT THE OTHER FILES.
	TLZ	X2,777
	IOR	X2,MONLVL	;MONLVL CONTAINS THE "DON'T DELETE " BIT.
	MOVEM	X2,LOK+2
	HLLZS	LOK+1
	SETZM	LOK+3
	DPB	X1,[POINT 4,RENAMD,12]
	XCT	RENAMD
	JRST	.+1		;RENAME FAILS FOR DECTAPES.
UXIT4:	SOJG	X1,UXIT2	;RETURN HERE FROM LOKFAL MESSAGE.
	JRST	UXIT
UXIT1:	SETZM	RUNFLA
	SKIPE	MTIME		;IS THERE SOME RUN TIME?
	PUSHJ	P,RTIME
	PUSHJ	P,TTYIN		;INIT TTY IN CASE OF ^O
	PUSHJ	P,INLMES
	ASCIZ	/
READY
/
	JRST	FIXUP		;GO TO MAIN LOOP AFTER CLEARING ROLLS


SUBTTL	PROGRAM "LOADER"
;HERE AFTER END STATEMENT

LINKAG:	MOVEI	R,CONROL	;SLIDE RUNTIME ROLLS DOWN INTO PLACE.
	PUSHJ	P,SLIDRL
	CAIGE	R,TMPROL
	AOJA	R,.-2		;SLIDE NEXT ROLL.
	MOVEM	X2,VARFRE	;FIRST FREE LOC IS CEIL OF TMPROL.

	MOVE	E,CETMP	;CHECK ARRAY REQUIREMENTS
	MOVE	T,FLARA
	JRST	LK2A

LK1:	HLRZ	X1,(T)		;KNOW SIZE?
	JUMPN	X1,LK2		;YES, JUMP
	MOVSI	X2,^D11		;(11,1) IS STANDARD DIM
	AOJ	X2,
	MOVEI	X1,^D11
	MOVE	A,1(T)
	CAMGE	T,FLSVR	;DEFAULT SIZE OF STRING VECTORS IS (11,1)
	AOJE	A,.+2		;IMPLICIT 2-DIM ARRAY?
	JRST	.+3
	HRRI	X2,^D11
	MOVEI	X1,^D121
	MOVEM	X2,1(T)
	HRLM	X1,(T)		;STORE SIZE
LK2:	ADD	E,X1		;ADD LENGTH TO IT
	ADDI	T,2		;ON TO NEXT ENTRY
	CAMG	T,FLSVR		;IS THIS ONE A STRING VECTOR?
	JRST	LK2A		;NO.
	HLRZ	X2,-1(T)		;LOOK AT FIRST DIMENSION
	SOJLE	X2,LK2A		;IS IT 1(AND THUS A VECTOR)?
	HRRZ	X2,-1(T)	;NO. LOOK AT SECOND DIMENSION
	SOJLE	X2,LK2A		;IS IT 1(AND THUS A VECTOR)?
	SETZM	RUNFLA		;NO. FATAL ERROR.
	PUSHJ	P,INLMES
	ASCIZ /STRING VECTOR IS 2-DIM ARRAY
/

LK2A:	CAMN	T,FLSVR		;BEGINNING OF SVRROL SCAN?
	MOVEM	E,SVRBOT		;YES, REMEMBER BOTTOM OF VECTOR POINTERS
	CAMGE	T,CESVR
	JRST	LK1

LK3:	SETOM	VPAKFL		;DONT TRY TO PRESS VARAIBLE SPACE NOW!
	SUB	E,CESVR	;WE NEED THIS MANY LOCS
	PUSHJ	P,VCHE1	;IS THERE ROOM FOR (E) LOCS?
	ADD	E,CETMP	;CALCULATE TOP OF ARRAY SPACE.
	MOVEM	E,SVRTOP	;SAVE IT.
	MOVEM	E,VARFRE	;THIS IS ALSO FIRST FREE WORD.

LK4:	MOVE	T,FLFCL
	MOVEI	R,FCNROL
LINK0A:	CAML	T,CEFCL
	JRST	LINK0C		;NO MORE FCN CALLS
	HLLZ	A,(T)		;LOOK UP FUNCTION
	PUSHJ	P,SEARCH
	JRST	LINK0B		;UNDEFINED
	MOVE	A,(B)		;DEFINED.  GET ADDRESS.
	HRLM	A,(T)
	AOJA	T,LINK0A
LINK0B:	SETZM	RUNFLA
	PUSHJ	P,INLMES
	ASCIZ	/UNDEFINED FUNCTION -- FN/
	LDB	C,[POINT 7,A,6]
	ADDI	C,40
	PUSHJ	P,OUCH
	PUSHJ	P,INLMES
	ASCIZ	/
/
	AOJA	T,LINK0A

LINK0C:	MOVE	B,FLFOR	;UNSAT FORS?
	CAML	B,CEFOR
	JRST	LINK0D

	MOVEI	T,[ASCIZ /FOR WITHOUT NEXT/]
	MOVE	L,(B)		;GET POINTER TO LINE NUMBER
	PUSHJ	P,FAILR		;PRINT ERROR MSG
	ADDI	B,5		;MORE UNSAT FORS?
	JRST	LINK0C+1
LINK0D:	SKIPG	DATAFF		;WAS DATA OMITTED?
	JRST	LINK0E		;NO
	PUSHJ	P,INLMES
	ASCIZ	/NO DATA/
	SETZM	RUNFLA

LINK0E:	SKIPN	RUNFLA		;GO INTO EXECUTION?
	JRST	UXIT		;NO

	MOVE	C,FLCOD

;CODE ROLL IS IN PLACE.  C CONTAINS ITS FLOOR

LINK0:	MOVE	T,FLFCL	;LINK FCN CALLS
	MOVE	T1,CEFCL
	MOVE	A,FLCOD
	MOVEI	B,0
	PUSHJ	P,LINKUP

LINK1A:	MOVE	T,FLARA	;LINK ARRAY REFS
	MOVE	T1,CESVR
	MOVE	A,T
	MOVEI	B,2
	PUSHJ	P,LINKUP

LINK1B:	MOVE	T,FLARA	;STORE ARRAY ADDRESSES IN ARAROL
	MOVE	G,CETMP
	JRST	LINK1D
LINK1C:	HLRZ	X1,(T)		;GET ARRAY LENGTH
	HRRM	G,(T)		;STORE ABS ADDRS
	ADD	G,X1		;COMPUTE ADDRS OF NEXT ARRAY
	ADDI	T,2		;GO TO NEXT ENTRY
LINK1D:	CAMGE	T,T1
	JRST	LINK1C
LINK1:	MOVE	T,FLCAD	;LINK CONST REFS
	MOVE	T1,CECAD
	MOVE	A,FLCON
	MOVEI	B,1
	PUSHJ	P,LINKUP

LINK2:	MOVE	T,FLPTM	;LINK TEMPORARY REFS (PERM AND TEMP)
	MOVE	T1,CETMP
	MOVE	A,T
	MOVEI	B,1
	PUSHJ	P,LINKUP

LINK3:	MOVE	T,FLLAD	;LINK GOTO DESTINATIONS
	MOVE	T1,CELAD
	MOVE	A,FLCOD
	MOVEI	B,0
	PUSHJ	P,LINKUP

LINK4:	MOVE	T,FLSCA	;LINK SCALARS
	MOVE	T1,CEVSP
	MOVE	A,T
	MOVEI	B,1
	PUSHJ	P,LINKUP


LINK6:	MOVE	T,FLGSB	;LINK GOSUB REFS
	MOVE	T1,CEGSB
	MOVE	A,T
	MOVEI	B,1
	PUSHJ	P,LINKUP
	MOVE	T,FLGSB
LINK7:	CAML	T,T1		;PUT SUBRTN ADDRSES IN GSBROL
	JRST	LINK8
	HLRZ	X1,(T)
	ADD	X1,FLLAD
	HLRZ	X1,(X1)
	ADD	X1,C
	MOVEM	X1,(T)
	AOJA	T,LINK7

LINK8:	MOVE	T,FLNXT	;LINK REVERSE REFS IN FORS
	MOVE	T1,CENXT
	MOVE	A,FLCOD
	MOVEI	B,0
	PUSHJ	P,LINKUP

LINK9:	MOVE	T,FLSAD	;LINK POINTERS TO TXTROL
	MOVE	T1,CESAD
	MOVE	A,FLLIT
	MOVEI	B,1
	PUSHJ	P,LINKUP

LINKZ:	MOVE	X1,FLSCA	;ZERO OUT SCALARS AND STRING VARS
	MOVE	X2,CEVSP
	PUSHJ	P,BLTZER
	MOVE	X1,CETMP	;ZERO OUT ARRAY ELEMENTS AND STRING VECTORS.
	MOVE	X2,ARATOP
	PUSHJ	P,BLTZER
;BEGIN EXECUTION

EXECUT:	SETZM	FCNLNK		;INITIALIZE FCN CALLS
	PUSHJ	P,RESTOR	;SET TO START AT BEGINNING OF DATA
	MOVEI	R,0		;POINTER TO GOSUB RTRN
	PUSHJ	P,PCRLF		;<RETURNS> SIGNAL END OF COMPILATION.
	PUSHJ	P,PCRLF

;INITIALIZE SOME SWITCHES:
	SETZM	INPFLA		;NO INPUT CURRENTLY BEING READ
	SETZM	NUMFLA
	SETZM	TABVAL
	SETZM	FMTPNT		;CLOBBER FORMAT PNTR
	SETZM	TABFG
	MOVEI	X1,^D9
EXEC2:	SETOM	LNINS-1(X1)
	SETZM	HPOS-1(X1)
	SETZM	PINPNM-1(X1)
	SOJG	X1,EXEC2
	SETZB	N,HPOS+9	;SET UP AC N FOR RND FN.
	SETOM	UXFLAG
	SETOM	N,NUMRES		;NO MAT INPUT HAS OCCURRED YET
IFN FTRND,<
	PUSHJ	P,WRANB		;INITAILIZE THE "STANDARD" RANDOM NUMBERS.
>
	MOVEI	X1,OVTRAP
	HRRM	X1,JOBAPR
	MOVEI	X1,10
	CALLI	X1,16
	PUSHJ	P,LOCKOF		;EXECUTION MAY BE INTERRUPTED.
	SETZM	IFIFG
	SETZM	ODF
	EXTERN	QLIST
	MOVE	Q,QLIST
	JRST	@FLCOD		;BYE...

;SUBROUTINE TO LINK ROLL ENTRIES

;CALL WITH A=ORG OF VALUE ROLL, B=INCREMENT (0 IF EXPLICIT REL LOC)
;T=FLOOR OF SRC ROLL, T1=CEIL OF SRC ROLL

LINKUP:	MOVE	X2,A
	MOVSI	X1,C

LNKP1:	CAML	T,T1		;FINISHED ROLL?
	POPJ	P,
	HRRZ	A,(T)		;FIRST LOC IN CHAIN
	JUMPN	B,.+3		;EXPLICIT ADDRS?
	HLRZ	X2,(T)		;YES.  COMPUTE IT
	ADD	X2,C
	JUMPE	A,LNKP3		;SPECIAL CASE--CHAIN VOID

LNKP2:	HRR	X1,A		;ONE LINK IN CHAIN
	HRRZ	A,@X1
	HRRM	X2,@X1
	JUMPN	A,LNKP2

LNKP3:	JUMPN	B,.+2		;EXPLICIT ADDRS?
	AOJA	T,LNKP1		;YES, JUST BUMP ROLL PNTR
	ADD	T,B		;NO, ADD EXPLICIT INCREMENT
	ADD	X2,B		;  (ALSO TO DEST ROLL)
	JRST	LNKP1

BLTZER:	HRL	X1,X1		;ZERO OUT CORE
	SETZM	(X1)
	AOJ	X1,
	BLT	X1,-1(X2)
	POPJ	P,
SUBTTL	STATEMENT GENERATORS

IFN FTSTR, <

;CHANGE STATEMENT

; CHANGE <VECTOR> TO <STRING>
;		OR
;CHANGE <STRING> TO <VECTOR>

;COMPILES A FETCH AND PUT WHICH INTERFACE WITH THE "PUTSTR" ROUTINE

XCHAN:	ASCIZ	/NGE/
	HRLI	F,1		;ALLOW STRINGS, BUT NOT STRING VECTORS
	TLNE	C,F.QUOT	;STRING LITERAL?
	JRST	XCHAN1		;YES
	PUSHJ	P,VECTOR	;PROCESS A VECTOR OR A STRING
	CAIN	A,4		;GOOD FORMAT?
	JRST	GRONK		;NO
	JUMPE	A,.+3		;IS IT A VECTOR?
	PUSHJ	P,FLET2		;NO, FINISH REGISTERING STRING
	JRST	XCHAN1+1

	MOVSI	D,(VECFET)
	PUSHJ	P,BUILDA	;GENERATE VECTOR FETCH
	PUSHJ	P,QSF		;"TO" MUST FOLLOW
	ASCIZ /TO/
	PUSHJ	P,FORMLS	;PROCESS STRING NAME
	MOVSI	D,(STRSTO)
XCHAN2:	SKIPE	STRFLA		;WAS THERE EXACTLY ONE STRING IN THIS STA?
	JRST	ILFORM		;NO
	PUSHJ	P,BUILDA	;BUILD APPROPRIATE STORE UUO
	JRST	NXTSTA

XCHAN1:	PUSHJ	P,FORMLS	;PROCESS STRING NAME
	PUSHJ	P,STRFCH	;GENERATE FETCH
	PUSHJ	P,QSF
	ASCIZ /TO/
	PUSHJ	P,VECTOR	;REGISTER VECTOR NAME
	MOVSI	D,(VECPUT)
	JRST	XCHAN2		;GO BUILD STORE UUO
>;ASSEMBLE ABOVE IF INCLUDING STRING FACILITY
;DATA STATEMENT

;<DATA STA>::= DATA <DEC NBR!STRING> [,<DEC NBR!STRING>...]

;NOTE:	A DATA STRING ::= "  <ANY CHARS EXCEPT CR,LF>  "
;	OR	::= <A LETTER><ANY CHARS EXCEPT COMMA OR APOST,CR,LF>

;NO CODE IS GENERATED FOR A DATA STATEMENT
;RATHER, THE DATA STATEMENT IN THE SOURCE
;TEXT ARE REREAD AT RUN TIME.
XDATA:	ASCIZ	/A/
	SKIPL	DATAFF		;ALREADY SEEN DATA?
	MOVEM	L,DATAFF	;NO.  REMEMBER WHERE FIRST ONE IS
	PUSHJ	P,DATCHK	;CHECK FOR LEGAL DATA
	FAIL	<DATA NOT IN CORRECT FORM>
	JRST	NXTSTA


;SUBROUTINE TO CHECK DATA LINE
;ALSO CALLED AT RUN TIME TO CHECK INPUT LINE
;(NOTE.. <RETURN> NOT CHECKED AFTER INPUT LINE)

DATCHK:	TLNN	C,F.LETT+F.QUOT	;LETTER OR QUOT SIGN FIRST
	JRST	DATCH2		;NO, EVALUATE NUMBER
	PUSH	P,[DATCH3]	;YES, ASSUME STRING AND SKIP OVER
	JRST	SKIPDA

DATCH2:	PUSH	P,X1
	PUSHJ	P,EVANUM
	JRST	[POP P,X1
		 POPJ	P,]
	POP	P,X1
DATCH4:	CAIE	C,"&"		;IF "&", ASSUME MATINPUT TERM
	TLNE	C,F.TERM	;MORE?
	JRST	CPOPJ1		;NO. RETURN
	TLNN	C,F.COMA	;DID FIELD END CORRECTLY?
	POPJ	P,		;NO. ERROR
	PUSHJ	P,NXCH		;YES. SKIP COMMA
	JRST	DATCHK		;AND GO TO NEXT ITEM.

DATCH3:	POPJ	P,
	JRST	DATCH4
;DEF STATEMENT

;<DEF STA> ::= DEF FN<LETTER>(<ARGUMENT>) = <EXPRESSION>

;GENERATED CODE IS:
;	JRST	<A>		;JUMP AROUND DEF
;	XWD	0,0		;CONTROL WORD
;	MOVEM	N,(B)		;SAVE ARGUMENT IN TEMPORARY
;	...
;	(EVALUATE EXPRESSION)
;	JRST	RETURN		;GO TO RETURN SUBROUTINE
;<A>:	...			;INLINE CODING CONTINUES...

;SEE GOSUB STATEMENT FOR USE OF CONTROL WORD.

;DURING EXPRESSION EVALUATION, LOCATION
;FUNARG CONTAINS ASCII REPRESENTATION OF ARGUMENT NAME.
;ROUTINES CALLED BY FORMLA CHECK FOR USE OF ARGUMENT AND RETURN POINTER
;TO FIRST WORD ON TEMPORARY ROLL.

;PRIOR TO GEN OF FIRST EXPRESSION EVALUATION, THE "REAL" TEMPORARY
;ROLL IS SAVED ON "STMROL" AND AN EMPTY "TEMROL" IS CREATED.
;AFTERWARDS, THE NEW "TEMROL" ENTRIES ARE ADDED TO THE PERMANENT
;TEMPORARY ROLL "PTMROL" AND "TEMROL" IS RESTORED.
;THUS EACH DEFINED FUNCTION HAS ITS OWN SET OF TEMPORARIES
;AND CANNOT CONFLICT WITH TEMPORARIES USED BY THE EXPRESSION
;BEING EVALUATED AT THE POINT OF THE CALL.

;NOTE. SPECIAL CASE:  CHECK FOR FUNCTION DEF AS LAST LINE OF PROGRAM 
;SUPPRESSES GEN OF "JRST" INSTR.  COMPILATION WILL FAIL
;("NO END STATEMENT"); HOWEVER THE WORD AFTER LADROL WOULD BE
;CLOBBERED IF "JRST" WERE GENNED.

XDEF:	ASCIZ	/FN/		;HANDLE THE FN PART AUTOMATICALLY
	SKIPE	FUNAME		;ARE WE IN MIDST OF MULTI-LINE DEF?
	FAIL <NESTED DEF>
	MOVSI	D,(JFCL)	;MAKE SURE NOT FIRST WRD OF CODE
	MOVE	X1,CECOD
	CAMG	X1,FLCOD
	PUSHJ	P,BUILDI
	TLNN	C,F.LETT	;MAKE SURE LETTER FOLLOWS.
	JRST	GRONK
	PUSHJ	P,SCNLT1	;SCAN FCN NAME.
	PUSH	P,A		;SAVE FCN NAME WITH COUNT OF ZERO ARGUMENTS
	MOVEM	A,FUNAME	; FN'NAME IN BODY OF FUNCTION
;ADD FUNCTION NAME TO FCNROL

XDEF1:	MOVEI	R,FCNROL	;LOOK FOR FCN NAME IN FCNROL
	PUSHJ	P,SEARCH
	JRST	.+3
	SETZM	FUNAME
	FAIL	<FUNCTION DEFINED TWICE>
	MOVEI	E,1		;ADD TO FCNROL
	PUSHJ	P,OPENUP
	ADD	A,CECOD	;CONSTRUCT PNTR TO CONTROL WORD
	SUB	A,FLCOD	;STORE IN FCNROL ENTRY.
	ADDI	A,1		
	MOVEM	A,(B)		

	MOVE	B,L		;GET JRST DESTINATION
	AOBJP	B,.+1		;DONT GEN JRST IF LAST LINE OF SOURCE.
	MOVSI	D,(JRST)
	PUSHJ	P,BUILDI	;GEN JRST INSTR.
	MOVEM	B,FUNSTA	;REMEMBER WHERE THIS JRST IS
	MOVEI	D,0		;BUILD ZERO CONTROL WORD
	PUSHJ	P,BUILDI

;SCAN FOR ARGUMENT NAME.

XDEF2:	CAIE	C,"("	;ANY ARGUMENTS?
	JRST	XDEF4		;NO

XDEF2A:	PUSHJ	P,NXCHK		;SKIP "("
	PUSHJ	P,SCNLT1	;ASSEMBLE ARGUMENT NAME
	TLNN	C,F.DIG
	JRST	.+3
	DPB	C,[POINT 7,A,13]
	PUSHJ	P,NXCHK

	MOVEI	R,ARGROL	;NOW ADD THIS NAME TO THE ARGUMENT LIST
	MOVE	B,FLARG		;NOW CHECK ARGROL, FOR TWO IDENTICAL ARGS
XDEF2C:	CAML	B,CEARG
	JRST	XDEF2D
	CAME	A,(B)
	AOJA	B,XDEF2C
	SETZM	FUNAME
	JRST	GRONK

XDEF2D:	MOVEI	E,1		;ADD NEW ARG TO ROLL
	PUSHJ	P,OPENUP
	MOVEM	A,(B)
	AOS	(P)		;COUNT THE ARGUMENT
	TLNE	C,F.COMA	;ANY MORE ARGS?
	JRST	XDEF2A		;YES

XDEF3:	TLNN	C,F.RPRN	;FOLLOWING PARENTHESIS?
	JRST	[SETZM	FUNAME
		JRST	GRONK]	;NO.
	PUSHJ	P,NXCHK		;YES. SKIP IT.
XDEF4:	PUSHJ	P,ARGCHK	;CHECK FOR RIGHT NUMBER OF ARGUMENTS
;GEN CODE TO EVALUATE EXPRESSION.

	MOVE	X1,FLTMP	;SAVE TEMP ROLL AS STMROL
	MOVEM	X1,FLSTM
	MOVEM	X1,CETMP	;AND EMPTY TMPROL
	MOVE	X1,TMPLOW	;SAVE TEMP POINTER
	MOVEM	X1,FUNLOW
	SETOM	TMPLOW
	SETOM	TMPPNT
	TLNN	C,F.EQAL	;MULTI LINE FN?
	JRST	XDEFM		;YES
	PUSHJ	P,NXCHK		;NO. SKIP EQUAL SIGN
	SETZM	FUNAME		;SIGNAL THAT THIS IS NOT A MULTI-LINE FN

	PUSHJ	P,FORMLA	;GEN THE EXPRESSION
	PUSHJ	P,EIRGNP	;GET IT IN REG

;NOW BUILD AN INSTRUCTION THAT WILL TELL RETURN HOW MANY ARGS TO POP
;OFF THE PUSH LIST
	
	POP	P,B		;ARGCHK PUT THE ADDRESS OF A CONSTANT IN HERE
XDEFE:	MOVSI	D,(MOVE T,)
	PUSHJ	P,BUILDA
	MOVE	X2,CETMP	;RESTORE TMPROL, SAVE TEMPORARIES FOR FCN
	MOVE	X1,CESTM
	MOVEM	X2,CEPTM
	MOVEM	X2,FLTMP
	MOVEM	X1,CETMP
	MOVEM	X1,FLSTM

	HRRE	X1,FUNLOW	;RESTORE TMPLOW
	MOVEM	X1,TMPLOW
	HRRZ	X1,FUNSTA	;-1(X1) IS LOC OF JRST AROUND FUNCTION
	ADD	X1,FLCOD
	HRRZ	X2,CECOD	;JRST TO THE NEXT INST TO BE CODED
	ADDI	X2,1
	HRRM	X2,(X1)

	MOVE	D,[JRST FRETRN]
	JRST	XRET1		;USE RETURN CODE TO BUILD INST

XDEFM:	POP	P,X1		;MULTI-LINE DEF. SAVE THE ARGCOUNT PARAMETER FOR FNEND
	HRLM	X1,FUNSTA
	MOVE	X1,CEFOR		;SAVE NUMBER OF ACTIVE FORS
	SUB	X1,FLFOR		;FOR A CHECK OF FORS HALF IN DEF
	HRLM	X1,FUNLOW
	JRST	NXTSTA
;DIM STATEMENT
;<DIM STA> ::= DIM <LETTER>[$](<NUMBER>[,<NUMBER>])[,<LETTER>[$](<NUMBER>[,<NUMBER>])...]

;FOR EACH ARRAY, HAVE ONE-WORD ENTRY IN VARROL
;WHICH POINTS TO TWO-WORD ENTRY IN ARAROL
;WHOSE FORMAT IS:
;	(<LENGTH OF ARRAY>)<PNTR>
;	(<LEFT DIM>+1)<RIGHT DIM>+1
;DURING COMPILATION, <PNTR> IS CHAIN OF REFERENCES.
;DURING EXECUTION, <PNTR> IS ADDRS OF FIRST WORD.

XDIM:	SETZI	F,		;ALLOW STRING VECTORS.
	PUSHJ	P,ARRAY		;REGISTER ARRAY NAME
	CAIE	A,5		;STRING VECTOR? ELSE..
	JUMPN	A,GRONK		;NON-0 RESULT FLAG-SYNTAX ERROR.
	CAIE	C,"("	;CHECK OPENING PAREN
	JRST	GRONK
	ADD	B,FLOOR(F)	;COMPUTE LOC OF ROLL ENTRY
	SKIPLE	1(B)		;DIMENSION FLAG SHOULD BE 0 OR -1
	FAIL	<VARIABLE DIMENSIONED TWICE>
	PUSHJ	P,NXCHK		;SKIP PARENTHESIS
	PUSHJ	P,GETNU	;FIRST DIMENSION
	JRST	GRONK		;NOT A NUMBER
	HRRZ	D,N		;SAVE FIRST DIM
	AOBJN	D,.+1		;D::= XWD 1,<FIRST DIM+1>
	MOVEM	D,1(B)		;STORE IN ARAROL (IN CASE 1 DIM)
	MOVEI	N,1		;IN CASE ONE DIMENSION
	TLNN	C,F.COMA	;TWO DIMS?
	JRST	XDIM1		;NO
	PUSHJ	P,NXCHK		;YES. SKIP COMMA.
	JUMPN	A,GRONK		;STRING VECTOR HAS TWO DIMS?
	PUSHJ	P,GETNU	;GET SECOND DIM
	JRST	GRONK		;NOT A NUMBER
	ADDI	N,1
	HRL	D,N		;NOW D HAS XWD <COLS+1>,<ROWS+1>
	MOVSM	D,1(B)		;STORE IN ROLL SWAPPED
XDIM1:	IMULI	N,(D)		;COMPUTE LENGTH OF ARRAY
	HRLM	N,0(B)		;STORE IN ROLL

XDIMFN:	TLNN	C,F.RPRN	;CHECK CLOSING PAREN
	JRST	GRONK
	PUSHJ	P,NXCHK		;LOOK FOR COMMA
	TLNN	C,F.COMA
	JRST	NXTSTA		;NO. DONE WITH THIS STATEMENT.
	PUSHJ	P,NXCHK		;SKIP THE COMMA.
	JRST	XDIM		;KEEP SCANNING.
;END STATEMENT

;<END STA> ::= END

XEND:	MOVE	X1,FLLIN	;CHECK THAT IT IS LAST STA
	ADDI	X1,1(L)
	CAME	X1,CELIN
	FAIL	<END IS NOT LAST>

	SKIPN	FUNAME
	JRST	XEND1
	PUSHJ	P,INLMES
	ASCIZ	/
NO FNEND FOR DEF FN/
	MOVEI	T,FUNAME
	SETZ	D,
	PUSHJ	P,PRINT
	PUSHJ	P,INLMES
	ASCIZ/
/
	JRST	UXIT

XEND1:	MOVE	D,[JRST UXIT]	;COMPILE TERMINAL EXIT
	PUSHJ	P,BUILDI
	JRST	LINKAG		;GO FINISH UP AND EXECUTE
;FOR STATEMENT

;CALCULATE INITIAL, STEP, AND FINAL VALUES
;
;SET INDUCTION VARIABLE TO INITIAL VALUE
;AND JUMP TO END IF IND VAR > FINAL
;INCREMENTING IS HANDLED AT CORRESPONDING NEXT.

;FIVE WORD ENTRY PLACED ON FORROL FOR USE
;BY CORRESPONDING NEXT STATEMENT:

;	CURRENT VALUE OF L (FOR "FOR WITHOUT NEXT" MESSAGE)
;<REL.  ADRS IN CODROL OF JUST TO END OF-NEXT>
;	<POINTER TO INDUCTION VARIABLE>
;	<POINTER TO INCREMENT>
;	<CURRENT VALUE OF TMPLOW>


XFOR:	TLNN	C,F.LETT	;MAKE SURE VARIABLE IS FIRST.
	JRST	GRONK
	MOVE	A,L		;SAVE L FOR POSSIBLE ERROR MSG
	MOVEI	R,FORROL
	PUSHJ	P,RPUSH
	PUSHJ	P,REGLTR	;REGISTER ON SCAROL
	CAIN	A,1		;BETTER BE SCALAR
	TLNN	C,F.EQAL	;BETTER HAVE EQUAL
	JRST	GRONK
	PUSHJ	P,NXCHK		;SKIP EQUAL SIGN.
	PUSH	P,B		;SAVE THE VARIABLE POINTER
	PUSHJ	P,FORMLA	;GEN THE INITIAL VALUE
	PUSHJ	P,EIRGNP
	MOVSI	D,(MOVEM N,)	;GEN STORE INITIAL IN VARIABLE
	MOVE	B,(P)
	PUSHJ	P,BUILDA
	PUSHJ	P,QSF		;LOOK FOR "TO"
	ASCIZ /TO/
	PUSHJ	P,FORMLA	;GEN THE UPPER BOUND.
	JUMPL	B,XFOR4		;EXCEPT FOR THE SPECIAL
	HLRZ	X1,B		;CASE OF A POSITIVE
	ANDI	X1,ROLMSK	;CONSTANT, FORCE THE
	CAIN	X1,CADROL	;UPPERBOUND TO BE
	JRST	.+3		;STORED IN A
XFOR4:	PUSHJ	P,EIRGEN	;PERMANENT
	PUSHJ	P,SIPGEN	;TEMPORARY.
	PUSH	P,B		;REMEMBER WHERE IT IS
	TLNN	C,F.TERM	;IS THERE A STEP CLAUSE?
	JRST	XFOR2		;LOOK FOR EXPLICIT "STEP"
	MOVE	T,[POINT 7,[BYTE (35)"STEP1"(7)15]]
	PUSHJ	P,NXCHK		;GET "S" IN CASE OF CR		;IMPLICIT "STEP1"
XFOR2:	PUSHJ	P,QSA		;LOOK FOR "BY"
	ASCIZ	/BY/
	JRST	.+2
	JRST	.+3
	PUSHJ	P,QSF		;LOOK FOR "STEP"
	ASCIZ	/STEP/

	PUSHJ	P,FORMLA	;XLATE AND GEN INCREMENT
	SETZM	CATFLG		;CATFLG=0 SAYS STEP IS NOT A CONSTANT.
	HLRZ	X1,B
	ANDI	X1,ROLMSK
	CAIE	X1,CADROL
	JRST	XFOR6
	SETOM	CATFLG		;EXCEPT FOR THE SPECIAL
	JRST	.+3		;CASE OF A CONSTANT,
XFOR6:	PUSHJ	P,EIRGEN	;SAVE THE STEP VALUE
	PUSHJ	P,SIPGEN	;IN A PERMANENT TEMP.

	EXCH	B,0(P)		;EXCH WITH TOP OF PDL
	PUSH	P,B		;SAVE LOC OF UPPER BOUND
	MOVE	B,-2(P)		;GET INDUCTION VAR IN REG
	PUSHJ	P,EIRGEN
	SKIPE	CATFLG
	JRST	XFOR3
	MOVE	B,-1(P)		;GET THE INCREMENT POINTER
	MOVSI	D,(DONFOR)	;BUILD DONFOR EXCEPT FOR A
	PUSHJ	P,BUILDA	;CONSTANT STEP.

XFOR3:	MOVE	X1,-1(P)
	POP	P,B		;BUILD COMPARE INSTR (IT
	MOVSI	D,(CAMLE N,)	;DOESN'T MATTER WHAT IT
	SKIPGE	X1		;IS IF DONFOR IS THERE).
	MOVSI	D,(CAMGE)
	PUSHJ	P,BUILDA
	MOVSI	D,(JRST)	;DUMMY JRST INSTRUCTION
	PUSHJ	P,BUILDI

	MOVE	A,CECOD
	SUB	A,FLCOD		;SAVE LOC FOR NEXT'S JRST
	SKIPE	RUNFLA		;WAS JRST ACTUALLY 
	MOVEI	A,-2(A)		;NO. DONT ALLOW SPACE FOR IT.
	MOVEI	R,FORROL
	PUSHJ	P,RPUSH
	POP	P,A
	EXCH	A,(P)
	PUSHJ	P,RPUSH		;SAVE INDUCTION VARIABLE
	EXCH	A,(P)		;GET INCREMENT
	PUSHJ	P,RPUSH
	POP	P,B		;GET POINTER TO INDUCTION VARIABLE.
	MOVSI	D,(MOVEM N,)	;BUILD THE STORE THAT WILL BE USED
	PUSHJ	P,BUILDA	;BY NEXT.

	MOVEI	R,FORROL
	MOVE	A,TMPLOW	;SAVE THIS LEVEL OF PROTECTION TO BE RESTORED BY NEXT
	PUSHJ	P,RPUSH
	MOVE	A,TMPPNT	;PROTECT TEMPS USED BY THIS "FOR"
	MOVEM	A,TMPLOW	;IN THE RANGE OF THE FOR.
	JRST	NXTSTA
;FNEND STATEMENT

;<FNEND STA> ::= FNEND

XFNEND:	ASCIZ /ND/
	SKIPN	A,FUNAME	;MUST FOLLOW A MULTI-LINE FN DEF
	FAIL <FNEND BEFORE DEF>
	SETZM	FUNAME		;SIGNAL END OF FN
	TLO	A,(177B13)	;ASSEMBLE THE SCALAR NAME OF THE RESULT
	PUSHJ	P,SCAREG		;REGISTER IT AS A SCALAR
	PUSHJ	P,EIRGNP	;GET THE RESULT IN REG
	HLRZ	B,FUNSTA	;RECOVER THE ADDRESS OF THE ARGUMENT COUNT
	HRLI	B,CADROL
	HLRZ	X1,FUNLOW	;THIS IS # OF WDS IN FORROL AT START OF DEF
	ADD	X1,FLFOR
	CAME	X1,CEFOR	;ARE ALL NEXTS INSIDE OF DEF COMPLETE?
	FAIL <FNEND BEFORE NEXT>
	JRST	XDEFE		;FINISH UP END OF FN

;GOSUB STATEMENT XLATE

XGOSUB:	ASCIZ	/UB/
	SKIPE	FUNAME
	FAIL	<GOSUB WITHIN DEF>
	PUSHJ	P,GETNUM	;READ STATEMENT NUMBER
	JRST	GRONK
	HRLZ	A,N
	MOVEI	R,LINROL	;LOOK UP LINE NO
	PUSHJ	P,SEARCH
	FAIL	<UNDEFINED LINE NUMBER >,1
	SUB	B,FLLIN	;SUCCESS.  SAVE REL LOC IN LINROL
	HRLZ	A,B
	MOVEI	R,GSBROL
	PUSHJ	P,SEARCH
	JRST	.+2
	JRST	XGOS1
	MOVEI	E,1
	PUSHJ	P,OPENUP
	MOVEM	A,(B)
XGOS1:	SUB	B,FLGSB
	HRLI	B,GSBROL
	MOVSI	D,(GOSUB)
	PUSHJ	P,BUILDA
	JRST	NXTSTA



;GOTO STATEMENT

XGOTO:	ASCIZ	/O/
XGOFIN:	PUSH	P,[Z NXTSTA]	;BUILD GOTO AND END STA
XGOFR:	PUSHJ	P,GETNUM	;BUILD GOTO AND RETURN
	FAIL	<ILLEGAL LINE REFERENCE >
	HRLZ	A,N		;LOOK FOR DESTINATION
	MOVEI	R,LINROL
	PUSHJ	P,SEARCH
	FAIL	<UNDEFINED LINE NUMBER >,1

	SUB	B,FLLIN	;NOW CHECK FOR JUMP INTO/OUTOF FUNCTION
	MOVE	X1,FLREF
	ADD	X1,B
	MOVE	X1,(X1)
	CAME	X1,FUNAME	;BOTH MUST BE ZERO OR SAME FUNCTION.
	FAIL	<ILLEGAL LINE REFERENCE >,1

	HRLI	B,LADROL
	MOVSI	D,(JRST)
	PUSHJ	P,BUILDA	;BUILD INSTR
	POPJ	P,
;IF STATEMENT

;<IF STA> ::= IF <EXPRESSION> <RELATION> <EXPRESION> THEN <NUMBER>
;	OR
;	::= IF <STRING EXPRESSION><RELATION><STRING EXPESSION> THEN <NUMBER>

; WHERE <STRING EXPRESSION>::= <LETTER>$[(EXPRESSION)]
; OR	::= " <ANY CHARS EXCEPT CR,LF> "

;RELATION IS LOOKED UP IN TABLE (RELROL)
;WHICH RETURNS INSTRUCTION TO BE EXECUTED
;IF ONE OF THE EXPRESSIONS BEING COMPARED IS
;IN THE REG, THAT ONE WILL BE COMPARED AGAINST
;THE OTHER IN MEMORY.  IF NECESSARY, THE
;INSTRUCTION IS CHANGED TO ITS CONTRAPOSITIVE
;BY FUDGING BUTS IN THE OP CODE

;IF STATEMENT

XIF:	PUSHJ	P,QSA
	ASCIZ/END#/
	JRST	IFSX7		;HERE FOR NORMAL IF STATEMENTS.
	TLNN	C,F.DIG		;HERE FOR IF END# STATEMENTS.
	JRST	GRONK
	SUBI	C,60
	TRNN	C,777777
	JRST	GRONK
	MOVSI	D,(DATA 3,)
	HRR	D,C
	PUSHJ	P,BUILDI
	PUSHJ	P,NXCH
	JRST	IFSX5
IFSX7:	PUSHJ	P,FORMLS	;LEFT SIDE, MAY BE A STRING.
	PUSHJ	P,GPOSGE	;MAKE SURE IT IS POSITIVE
	PUSHJ	P,PUSHPR	;SAVE IT
	PUSHJ	P,SCNLT1	;FIRST CHAR OF RELATION IN A.
	MOVEI	X1,">"
	CAIE	X1,(C)		;NEXT CHAR ">"?
	TLNE	C,F.EQAL	;OR "="?
	PUSHJ	P,SCN2		;PUT TWO CHAR RELATION IN A(SIXBIT)
	JFCL
IFSX2:	MOVEI	R,RELROL	;RELATION TABLE
	PUSHJ	P,SEARCH
	FAIL	<ILLEGAL RELATION>
	HRLZ	D,(B)		;SAVE RELATION INSTR
	PUSH	P,D
	PUSHJ	P,FORMLS	;RIGHT SIDE, MAY ALSO BE A STRING
IFN FTSTR,<
	SKIPN	STRFLA		;IF STRFLA=0, THEN EXACTLY ONE SIDE WAS A STRING.
	FAIL <MIXED STRINGS AND NUMBERS>
>
	PUSHJ	P,GPOSGE
	TLNN	B,ROLMSK	;IS RIGHT SIDE IN REG?
	JRST	IFSX4		;YES, LEAVE IT
	PUSHJ	P,EXCHG		;NO. SWAP WITH LEFT SIDE.
	MOVE	D,0(P)		;FUDGE INSTRUCTION FOR CONTRAPOSITIVE RELATION.
	TLNE	D,1000		;(EQUAL, NOT EQUAL DON'T CHANGE.)
	TLC	D,6000		;(OTHERS DO).
	MOVEM	D,0(P)

IFSX4:
IFN FTSTR,<
	SKIPL	STRFLA		;NUMERIC COMPARE?
	JRST	IFSX6		;NO, STRING.
>
	PUSHJ	P,EIRGNP	;MOVE TO REG
	PUSHJ	P,POPPR		;GET OTHER SIDE BACK
	POP	P,D		;GET STASHED OP CODE
	PUSHJ	P,BUILDA	;BUILD COMPARE INSTRUCTION
IFSX5:	PUSHJ	P,THENGO	;LOOK FOR "THEN" OR "GOTO"
	JRST	XGOFIN		;USE GOTO CODE TO GEN JRST INSTR

IFN FTSTR,<
IFSX6:	PUSHJ	P,STRFCH	;SETUP ONE STRING
	PUSHJ	P,POPPR		;GET OTHER ONE BACK
	MOVSI	D,(STRIF)	;STRING COMPARE UUO
	PUSHJ	P,BUILDA	;COMPARE UUO EITH OTHER STRING ADDRESS
	POP	P,D
	PUSHJ	P,BUILDI	;BUILD THE RELATION
	JRST	IFSX5		;FINISH UP (THE OTHER STR POINTER WILL BE IN N)
>;ASSEMBLE ABOVE IF INCLUDING STRING FACILITY
;INPUT STATEMENT

;<INPUT STA> ::= INPUT (<SCALAR> ! <ARRAY REF>)[,(<SCALAR>!<ARRAY REF>)...]


XINPUT:	ASCIZ /UT/
	JRST	XINP5		;ENTER HERE FOR INPUT STATEMENTS.
	PUSHJ	P,NXCH		;ENTER HERE FOR INPUT#/READ# STATEMENTS.
	TLNN	C,F.DIG
	JRST	GRONK
	MOVSI	D,(DATA 10,)
	SETOM	DSKIFL
	HRR	D,THELIN
	PUSHJ	P,BUILDI
	SUBI	C,60
	TRNN	C,777777
	JRST	GRONK
	MOVSI	D,(DATA 1,)
	HRR	D,C
	PUSHJ	P,BUILDI
	PUSHJ	P,NXCH
	TLNN	C,F.COMA
	JRST	GRONK
	PUSHJ	P,NXCH
XINP5:
XIN6:	MOVE	D,[PUSHJ P,DOINPT];FETCH SETUP INSTR.

;ENTER HERE FROM READ STATEMENT.


XINP0:	PUSHJ	P,BUILDI	;CONSTRUCT SETUP INSTR

XINP1:	TLNN	C,F.LETT	;CHECK THAT LETTER IS NEXT.
	JRST	GRONK
	SETZI	F,		;STRINGS MAY BE INPUT
	PUSHJ	P,REGLTR	;GET VARIABLE
	JUMPE	A,XINP2		;JUMP IF ARRAY
	CAIG	A,4		;STRING VARIABLE?
	JRST	XINP1A		;NO
IFN FTSTR,<
	CAIG	A,6		;VARIABLE?
	JRST	XINP6		;YES
>
	JRST	ILFORM		;NO, ATTEMPT TO BOMB A LITERAL

XINP1A:	CAILE	A,1		;ONLY ARRAY AND SCALAR ALLOWED
	JRST	ILVAR
	MOVSI	D,(DATA)	;SCALAR DATA INSTR
	PUSHJ	P,BUILDA
	JRST	XINP3

XINP2:	PUSH	P,B		;SAVE VARIABLE POINTER
	PUSHJ	P,XARG		;XLATE ARGS
	MOVSI	D,(ADATA1)	;GET CORRECT DATA INSTR
	JUMPE	B,XINP2A
	HRRZ	X1,(P)		;GET ADRESS OF VARIABLE 2-WD BLOCK
	ADD	X1,FLARA
	SKIPN	1(X1)		;MARK	2-DIM
	SETOM	1(X1)
	MOVSI	D,(ADATA2)
XINP2A:	EXCH	B,(P)		;SAVE NO OF ARGS, GET VARIABLE
	PUSHJ	P,BUILDA	;BUILD DATA INSTR
	POP	P,B		;GET NO OF ARGS
	PUSHJ	P,GENARG

XINP3:	TLNN	C,F.COMA	;MORE?
	JRST	NXTSTA          ;NO
	PUSHJ	P,NXCHK		;YES. SKIP COMA
	JRST	XINP1

IFN FTSTR,<
XINP6:	PUSHJ	P,FLET2		;STRING. FINISH REGISTERING
	MOVSI	D,(STRIN)	;STRING VARIABLE DATA UUO
	PUSHJ	P,BUILDA	;BUILD, WITH ADDRESS
	JRST	XINP3
>
;LET STATEMENT

;<LET STA> ::= [LET] (<SCALAR>!<ARRAY REF>) = <EXPRESSION>
;		OR
;<LET STA> ::= [(LET)] <LETTER>$[EXPRESSION] = <STRING EXPRESSION>

XLET:	TLNN	C,F.LETT	;MAKE SURE FIRST CHAR IS LETTER.
	JRST	GRONK
	SETZI	F,		;ALLOW STRING "LET"
	SETOM	LETSW		;LOOK FOR LH OF LET STA
XLET0:	PUSHJ	P,FORMLS
	SKIPGE	LETSW		;WAS THIS DEFINITELY A RH EXPRESSION?
	TLNN	C,F.COMA+F.EQAL	;NO, IS IT DEFINITELY A LH EXP?
	JRST	XLET1A		;IT BETTER BE A RIGHT HALF.

IFN FTSTR,<
	SKIPL	STRFLA		;STRING LET?
	JRST	XLET3
>
	PUSH	P,[EXP 1]	;FLAG IN CASE SCALAR
	PUSH	P,B
XLET1:	PUSHJ	P,NXCHK		;SKIP EQUAL SIGN
	SOS	LETSW
	JRST	XLET0		;COUNT THIS LH AND LOOK FOR ANOTHER


XLET1A:	MOVMS	LETSW
	SOSG	LETSW		;WAS THERE AT LEAST ONE LEFT HALF?
	JRST	GRONK		;NNOPE.
IFN FTSTR,<
	SKIPL	E,STRFLA		;STRING LET STA?
	JRST	XLET4		;YES.
>
	PUSHJ	P,EIRGEN	;GET RESULT IN REG
	MOVEM	B,TEMP1		;SAVE THE NEGATIVE RESULT CHECK
XLET1B:	MOVE	D,[MOVEM N, (MOVNM N,)]
	SKIPG	-1(P)
	MOVE	D,[ARSTO1 N, (ARSTN1 N,)]
	SKIPL	-1(P)
	JRST	XLET2
	MOVE	D,[ARSTO2 N, (ARSTN2 N,)]
	MOVE	X1,0(P)		;DEFAULT ARRAY SIZE (10,10)
	ADD	X1,FLARA
	SKIPN	1(X1)
	SETOM	1(X1)

XLET2:	SKIPGE	TEMP1	;CHECK FOR NEGATIVE RESULT
	MOVS	D,D	;NEGATIVE. GET CORRECT INSTR.
XLET2A:	POP	P,B		;RESTORE RESULT PNTR
	PUSHJ	P,BUILDA	;BUILD STORE INSTR
	POP	P,B	;CHECK TRASH FROM PUSHLIST.
	JUMPG	B,XLET2B	;ARRAY REF?
	PUSHJ	P,GENARG;YES. GEN ARGS FIRST.
XLET2B:	SOSLE	LETSW
	JRST	XLET1B		;THERE IS ANOTHER LEFT HALF
	JRST	NXTSTA

IFN FTSTR,<
XLET3:	PUSHJ	P,PUSHPR	;REMEMBER ADDRESS OF RESULT POINTER.
	JRST	XLET1	;GO TRANSLATE THE RIGHT SIDE

XLET4:	CAME	E,LETSW	;WAS EVERY PART OF THIS LET A STRING?
	FAIL <MIXED STRINGS AND NUMBERS>
XLET4A:	PUSH	P,B		;SAVE LOCATION OF RH STRING
	PUSHJ	P,STRFCH	;"FETCH" RIGHT HALF STRING
	PUSHJ	P,POPPR		;GET ADDRESS OF LEFT HALF POINTER BACK
	MOVSI	D,(STRSTO)	;BUILD THE STRING MOVE INSTRUCTION.
	PUSHJ	P,BUILDA
	POP	P,B
	SOSLE	LETSW		;ANYMORE LH OF LETS?
	JRST	XLET4A		;YES.
	JRST	NXTSTA
>;ASSEMBLE ABOVE IF INCLUDING STRING FACILITY
IFN FTMAT,<
;MAT STATEMENT

;MAT STATEMENTS DIVIDE INTO A NUMBER OF DIFFERENT
;STATEMENTS (MAT READ, ...)   THESE POSSIBILITIES ARE TESTED
;ONE AT A TIME BY CALLS TO QSA.

;<MAT READ STA> ::= MAT READ <LETTER>[(<EXP>,<EXP>)] [,<LETTER>[(<EXP>,<EXP>...]]

XMAT:	HLLI	F,		;ALLOW STRINGS FOR READ,PRINT,INPUT
	PUSHJ	P,QSA		;MAT READ?
	ASCIZ /READ/
	JRST	XMAT2		;NO.  GO TRY MAT PRINT
XMAT1:	PUSHJ	P,ARRAY		;GET ARRAY NAME
	CAIE	A,5		;STRING VECTOR?
	JUMPN	A,GRONK
	MOVSI	D,(MATRD)
	SKIPL	DATAFF		;DATA SEEN?
	HLLOS	DATAFF		;NO.  SET NO DATA FLAG
	PUSHJ	P,XMACOM		;GO CHECK DIMENSIONS AND BUILD UUO.
	TLNN	C,F.COMA	;IS THERE ANOTHER ARRAY TO READ?
	JRST	NXTSTA		;NO.
	PUSHJ	P,NXCHK		;YES. SKIP COMMA
	TLNE	C,F.TERM	;END OF ARRAY LIST?
	JRST	NXTSTA		;YES.
	JRST	XMAT1

;<MAT PRINT STA>::= MAT PRINT <LETTER>[(<EXP>,<EXP>)] [[;!,] <LETTER>[(<EXP>,<EXP>)...]

XMAT2:	PUSHJ	P,QSA		;MAT PRINT?
	ASCIZ	/PRINT/
	JRST	XMAT3		;NO. MUST HAVE VARIABLE NAME.
XMAT2A:	PUSHJ	P,ARRAY		;REGISTER NAME
	CAIE	A,5		;STRING VECTOR?
	JUMPN	A,GRONK
	MOVSI D,(MATPR)
	PUSHJ	P,CHKFMT	;CHECK FORMAT CHARACTER
	TLNN	D,140
	JRST	GRONK		;FAIL IF ILLEGAL
	PUSHJ	P,XMACOM	;GO CHECK DIMENSIONS AND BUILD UUO
	TLNE	C,F.TERM	;IS FORMAT CHAR FOLLOWED BY END OF STA?
	JRST	NXTSTA		;YES.
	JRST	XMAT2A		;PROCESS NEXT ARRAY NAME

;<MAT SCALE STA> ::= MAT <LETTER>=(<EXPRESSION>)*<LETTER>

XMAT3:	PUSH	P,[Z NXTSTA]	;ALL REMAINING MAT STATEMENTS MAY HAVE
				;ONE OPERAND, BUT NOT A LIST OF THEM.
	PUSHJ	P,QSA
	ASCIZ /INPUT/
	JRST	XMAT3A
	PUSHJ	P,VECTOR	;REGISTER VECTOR NAME 
	CAIE	A,5		;STRING VECTOR?
	JUMPN	A,GRONK		;OR NUMBER VECTOR?
	MOVSI	D,(MATINP)	;YES. BUILD MAT INPUT
	JRST	BUILDA


XMAT3A:	HRLI	F,-1		;REMAINING MATOPS CANT HAVE STRINGS.
	PUSHJ	P,ARRAY		;REGISTER THE VARIABLE
	JUMPN	A,GRONK		;CHECK FOR ILLEGAL ARRAY NAME.
	TLNN	C,F.EQAL	; CHECK FOR EQUAL SIGN.
	JRST	GRONK
	PUSHJ	P,NXCHK		;SKIP EQUAL.
	CAIE	C,"("	;SCALAR MULTIPLE?
	JRST	XMAT4		;NO
	PUSHJ	P,NXCHK		;SKIP PARENTHESIS
	PUSH	P,B
	PUSHJ	P,FORMLA	;YES.  GEN MULTIPLE
	PUSHJ	P,EIRGNP
	PUSHJ	P,QSF		;SKIP MULTIPLY SIGN
	ASCIZ	/)*/
	PUSH	P,[MATSCA]	;GET OP CODE.
	JRST	XMAT9A
;<MAT SETUP STA> ::= MAT ZER!CON!IDN <LETTER>[(<EXPRESSION>,<EXPRESSION>)]

XMAT4:	PUSHJ	P,QSA		;MAT ZER?
	ASCIZ /ZER/
	JRST	XMAT5		;NO.
	MOVSI	D,(MATZER)	;YES.
	JRST	XMACOM

XMAT5:	PUSHJ	P,QSA		;MAT CON?
	ASCIZ /CON/
	JRST	XMAT6
	MOVSI	D,(MATCON)	;YES.
	JRST	XMACOM

XMAT6:	PUSHJ	P,QSA		;MAT IDN?
	ASCIZ /IDN/
	JRST	XMAT7		;NO
	MOVSI	D,(MATIDN)	;YES.

;COMMON GEN FOR MAT ZER,CON,IDN,REA

XMACOM:	CAIE	C,"("		;EXPLICIT DIMENSIONS?
	JRST	XMAT9D		;NO.
	PUSH	P,B		;SAVE B,D.
	PUSH	P,D
	PUSHJ	P,XARG		;TRANSLATE ARGUMENTS
	PUSH	P,B		;SAVE COUNT OF ARGUMENTS
	MOVE	B,-2(P)		;GET BACK THE REGISTRY OF THE ARRAY.
	MOVSI	D,(SDIM)		;BUILD SDIM INSTR.
	PUSHJ	P,BUILDA
	POP	P,B		;GET THE ARGUMENT COUNT.
	JUMPN	B,XMACO1	;ONE ARG OR TWO?
	MOVE	D,[JUMP 2,ONCESW] ;ONE. FAKE DIMENSIONS OF (0,N)
	PUSHJ	P,BUILDI
	SETZI	B,

XMACO1:	PUSHJ	P,GENARG		;GEN ARGS
	JRST	XMAT9C		;RESTORE AC,S AND BUILD.

XMACMI:		

;<MAT FCN STA> ::= MAT<LETTER> = INV!TRN (<LETTER>)

XMAT7:	PUSHJ	P,QSA		;MAT INV?
	ASCIZ	/INV(/
	JRST	XMAT8		;NO
	MOVSI	D,(MATINV)	;YES. GET OP CODE.
	JRST	XMITCM

XMAT8:	PUSHJ	P,QSA		;MAT TRN?
	ASCIZ	/TRN(/
	JRST	XMAT9		;NO.
	MOVSI	D,(MATTRN)	;YES. GET OP CODE.
XMITCM:	PUSH	P,B		;FINISH MAT INV,TRN.
	PUSH	P,D
	PUSHJ	P,ARRAY
	JUMPN	A,GRONK
	PUSHJ	P,QSF
	ASCIZ	/)/
	JRST	XMAT9B		;
;<MAT OPERATOR STA>::=MAT <LETTER>=<LETTER>+!-!*<LETTER>

XMAT9:	PUSH	P,B		;SAVE RESULT LOCATION
	PUSHJ	P,ARRAY
	JUMPN	A,GRONK
	MOVEI	D,0		;LETTER FOLLOWED BY OPERATOR
	TLNN	C,F.PLUS+F.MINS+F.STAR
	JRST	XMAT10		;NO OPERATOR. MUST BE MAT COPY
	TLNN	C,F.MINS+F.STAR
	MOVSI	D,(MATADD)
	TLNN	C,F.PLUS+F.STAR
	MOVSI	D,(MATSUB)
	TLNN	C,F.PLUS+F.MINS
	MOVSI	D,(MATMPY)
	PUSH	P,D		;SAVE OPERATION
	PUSHJ	P,NXCHK		;SKIP OPERATOR
	MOVSI	D,(MOVEI T,)	;GEN T:= ADRS OF FIRST ARRAY

	PUSHJ	P,BUILDA	;ENTER HERE FROM SCALAR MULTIPLE

XMAT9A:	PUSHJ	P,ARRAY		;SECOND ARRAY
	JUMPN	A,GRONK		;NOT ARRAY NAME

;ENTER HERE FROM MAT INV, TRN

XMAT9B:	MOVSI	D,(MOVEI T1,)
	PUSHJ	P,BUILDA
XMAT9C:	POP	P,D
	POP	P,B
XMAT9D:	PUSHJ	P,BUILDA
	POPJ	P,		;RETURN TO NXTSTA (OR TO PROCESS NEXT ITEM IN PRINT,READ, OR INPUT LIST.)

XMAT10:	PUSH	P,B		;FOR MAT COPY, FAKE MAT B=(1)*A
	MOVE	D,[MOVSI N,(1.0)];PUT CONSTANT 1.0 IN REG FOR SCALE
	PUSHJ	P,BUILDI	;BUILD INST TO GET SCAL FACTOR
	POP	P,B		;GET SOURCE MAT BACK
	PUSH	P,[MATSCA]
	JRST	XMAT9B

>;ASSEMBLE ABOVE IF INCLUDING MATRIX FACILITY
;NEXT STATEMENT

;<NEXT STA> ::= NEXT <SCALAR>

;EXPECT TO FIND 5-WORD ENTRY ON TOP OF FORROL
;DISCRIBING INDUCTION VARIABLE AND LOOP ADDRESS

;WORD IS PUSHED ON NXTROL OF FOLLOWING FORM:
;	(<REL ADRS OF TOP OF LOOP>) <REL ADRS OF JRST TO IT>
;THIS WORD USED TO FIX UP REFERENCE AT END OF
;COMPILATION.
XNEXT:	ASCIZ /T/
	PUSHJ	P,REGLTR
	CAIE	A,1		;BETTER BE SCALAR
	JRST	GRONK
	MOVE	X1,CEFOR	;UNSAT FOR?
	CAMG	X1,FLFOR
	FAIL	<NEXT WITHOUT FOR>
	CAME	B,-3(X1)	;CHECK INDUCTION VARIABLE
	FAIL	<NEXT WITHOUT FOR>

XNEX1:	PUSHJ	P,POPFOR
	MOVEM	B,TMPLOW	;RESTORE PREVIOUS LEVEL OF TEMPORARY PROTECTION
	MOVEM	B,TMPPNT	;BECAUSE THIS IS THE END OF THE "FOR" RANGE .
	PUSHJ	P,POPFOR	;GEN INCREMENT TO REG
	PUSHJ	P,EIRGEN
	PUSHJ	P,POPFOR	;FADR TO INDUCTION VAR
	MOVSI	D,(FADR)
	PUSHJ	P,BUILDA
	PUSHJ	P,POPFOR	;GET LOC OF RETURN

	MOVEI	X1,1(B)		;ADD TO ADDRS CHAIN OF NEXT WORD
	ADD	X1,FLCOD
	MOVE	X2,L
	AOBJP	X2,XNEX2	;DONT LINK IF LAST STATEMENT!
	ADD	X2,FLLAD
	MOVE	A,(X2)
	HRRM	A,(X1)
	MOVEI	A,1(B)
	HRRM	A,(X2)

XNEX2:	MOVSI	A,(B)		;ADD WORD TO NXTROL FOR LINKAGE
	MOVEI	R,NXTROL
	PUSHJ	P,RPUSH
	SUB	B,FLNXT
	HRLI	B,NXTROL
	MOVSI	D,(JRST)	;BUILD JRST INSTR
	PUSHJ	P,BUILDA
	PUSHJ	P,POPFOR	;POP OFF THE SAVED VALUE OF L
	JRST	NXTSTA
;SUBR TO POP TOP OF FORROL. USED ONLY BY XNEXT.


POPFOR:	SOS	X1,CEFOR	;POP TOP OF FORROL
	MOVE	B,(X1)
	POPJ	P,
;ON STATEMENT

;<ON STA> ::= ON <EXPRESSION> GOTO!THEN <STA NUMBER> [,<STA NUMBER>...]

;CREATES A CALL TO A RUNTIME ROUTINE THAT CHECKS THE RANGE OF THE ARGUMENT
;AND RETURNS TO THE APPROPRIATE JRST:
;	JSP	A,XCTON
;	Z	(ADDRESS OF NEXT STATEMENT)
;	<NEST OF>
;	<GOTO'S >

XON:	PUSHJ	P,FORMLA	;EVALUATE INDEX
	PUSHJ	P,EIRGNP	;GET IN REG
	MOVE	D,[JSP A,XCTON]
	PUSHJ	P,BUILDI	;BUILD THE RUNTIME CALL
	SETZI	D,		;BUILD ADDRESS OF NEXT STATEMENT
	MOVE	B,L
	AOBJP	B,.+3		;DONT BUILD IF LAST STATEMENT
	HRLI	B,LADROL
	PUSHJ	P,BUILDA
	PUSHJ	P,THENGO	;TEST FOR "THEN" OR "GOTO"
	
XON1:	PUSHJ	P,XGOFR		;BUILD A JRST TO THE NEXT NAMED STATEMENT
	TLNN	C,F.COMA	;MORE?
	JRST	NXTSTA		;NO
	PUSHJ	P,NXCHK		;YES. SKIP COMMA
	JRST	XON1		;PROCESS NEXT LINE NUMBER

;THE FOLLOWING CODE IS THE MAJORITY OF THE CODE FOR DISK FILE HANDLING
	EXTERN	DREL,CURLIN
	EXTERN INITI,INITO,FILD,ACTBL,LOK,LOKUP,LINB0,OUTDSK,STADSK
	EXTERN	OBDSK,ENT,OUTDSK,ENTDSK

;FILE STATEMENT
;FORMAT
;     FILES FNAME,FNAME,ETC
; FILES STATEMENT MUST PRECEED ANY COMMAND THAT IS ASSOCIATED
; WITH CREATING A NEW FILE OR REFERENCING AN OLD FILE.
; THE NAMES ARE POSITIONAL, WHERE FNAME1 CORRESPONDS TO
; SOFTWARE CHANNEL #1,ETC. UP TO #9

XFILE:	ASCIZ/ES/		;ANALYZE "FILES" STATEMENT
	TLNE	C,F.TERM	;SHOULD BE SOMETHING FOLLOWING
	JRST	GRONK
	MOVEI	X1,^D9
	SETZM	ACTBL-1(X1)
	SOJG	X1,.-1
	MOVEI	X2,1		;SET LOOP COUNT
XFIL1:	CAILE	X2,^D9		;ONLY 9 FILES ALLOWED
	JRST	TMF		;ERROR
	PUSHJ	P,ATOMSX	;GET FILE NAME
	JUMPE	A,XFIL2
	MOVEM	A,FILD-1(X2)	;INSERT IT IN FILE DIRECTORY STACK
	MOVEI	X1,@BA-1(X2)	;GET BUFFER ADDRESS
	MOVEM	X1,JOBFF	;
	XCT	INITI-1(X2)	;INIT ANOTHER CHANNEL
	JRST	NODEVX
	DPB	X2,[POINT 4,IBDSK,12]
	XCT	IBDSK
	DPB	X2,[POINT 4,LOKUP,12]	;PREPARE FOR LOOKUP
	MOVEM	A,LOK		;INSERT FILE NAME
	HLLZS	LOK+1
	SETZM	LOK+2
	SETZM	LOK+3		;ZERO PG-PG NO.
	XCT	LOKUP		;DO LOOKUP
	SKIPA	X1,[OCT 2]	;FILE NOT THERE - NO READ ALLOWED
	MOVEI	X1,1		;ALLOW READING
	MOVEM	X1,ACTBL-1(X2)	;PUT KEY IN ACCESS TABLE
XFIL2:	MOVEI	X1,";"		;"," OR ";" ALLOWED AS DELIMITER
	CAIE	X1,(C)
	TLNE	C,F.COMA
	JRST	.+2
	JRST	NXTSTA		;NO MORE FILES
	PUSHJ	P,NXCH		;MORE FILES, PREPARE TO READ NEXT NAME
	AOJA	X2,XFIL1	;INCREMENT COUNTER AND CONTINUE


	DEFINE R(A)
<	IRP	A
<	EXP	DO'A+1	>>
OUTPT:	R<1,2,3,4,5,6,7,8,9>
	DEFINE R(A)
<	IRP	A
<	EXP	DO'A+2
	EXTERN	DO'A	>>
OUTCNT:	R<1,2,3,4,5,6,7,8,9>
	DEFINE R(A)
<	IRP	A
<OPS'A:	OCT	1
	SIXBIT/DSK/
	XWD	DO'A,0
	INTERN	OPS'A	>>
	R<1,2,3,4,5,6,7,8,9>
	DEFINE R(A)
<	IRP	A
<IPS'A:	OCT	1
	SIXBIT/DSK/
	XWD	0,DI'A
	INTERN	IPS'A	>>
	R<1,2,3,4,5,6,7,8,9>

	DEFINE R(A)
<	IRP	A
<	EXP	DI'A+1
	EXTERN	DI'A	>>
INPT:	R<1,2,3,4,5,6,7,8,9>

	DEFINE	R(A)
<	IRP	A
<	EXP	DI'A+2	>>
INCNT:	R<1,2,3,4,5,6,7,8,9>

	DEFINE R(A)
<	IRP	A
<	EXP	DBUF'A
	EXTERN	DBUF'A,LINB'A	>>
BA:	R<1,2,3,4,5,6,7,8,9>

	DEFINE R(A)
<	IRP	A
<	POINT 7,LINB'A	>>
LINPT:	R<0,1,2,3,4,5,6,7,8,9>


	EXTERN	IFIFG,ODF
INSET:	SETOM	IFIFG		;SET INPUT FROM DISK FLAG
	HRRZ	LP,40		;GET CHANNEL NUMBER
	MOVE	X1,ACTBL-1(LP)
	CAIN	X1,0		;GET CORRESPONDING ACCESS CODE
	JRST	FNR		;IF=0, FILE NEVER ACCESSED
	CAIE	X1,1		;IF NOT EQUAL TO 1, FILE NOT OK FOR READING
	JRST	ILRD		;ILLEGAL READ ERROR MESSAGE
	POPJ	P,

INCLR:	SETZM	IFIFG		;CLEAR INPUT FROM DISK FLAG
	POPJ	P,		;COME HERE BEFORE INPUT FROM TTY


EOF:	HRRZ	X1,40		;END OF FILE TEST.
	MOVE	X2,ACTBL-1(X1)	;ACTBL ENTRY = 1 MEANS A READABLE FILE.
	JUMPE	X2,FNR
	CAIE	X2,1
	JRST	EOF6
	DPB	X1,[POINT 4,STADSK,12]
	SKIPN	T,PINPNM-1(X1)	;CHECK THE LINE BUFFER FIRST.
	JRST	EOF3
	PUSHJ	P,DELAWY
	TLNN	C,F.CR
	JRST	CPOPJ1
	SETZM	PINPNM-1(X1)
EOF3:	MOVE	T,@INPT-1(X1)	;GET POINTER
	MOVE	X2,@INCNT-1(X1)	;GET COUNTER.
EOF5:	JUMPE	X2,EOF2
	ILDB	C,T
	CAIG	C,15		;LINE TERMINATOR?
	CAIGE	C,12
	JRST	.+2
	JRST	EOF4
	JUMPE	C,EOF4		;NULL?
	CAIN	C,40		;BLANK SPACE?
	JRST	EOF4
	CAIN	C,11		;TAB?
	JRST	EOF4
	CAIN	C,54		;COMMA?
	JRST	EOF4
	CAIG	C,71		;IT HAD BETTER BE A LINE NUMBER.
	CAIGE	C,60
	JRST	EOF7
	JRST	CPOPJ1
EOF4:	SOJA	X2,EOF5
EOF2:	XCT	STADSK		;NEED NEW INPUT.
	POPJ	P,
	DPB	X1,[POINT 4,INDSK,12]
	XCT	INDSK
	JRST	EOF3

EOF6:	PUSHJ	P,TTYIN
	PUSHJ	P,INLMES
	ASCIZ	/
IF END ASKED FOR UNREADABLE FILE IN /
	JRST	IMP1

EOF7:	PUSHJ	P,TTYIN
	PUSHJ	P,INLMES
	ASCIZ	/
BAD DATA READ DURING IF END IN LINE /
	JRST	IMP1


XRES:	HRRZ	X1,40		;HERE FOR RESTORE UU0
	MOVE	X2,ACTBL-1(X1)	;GET CHANNEL NUMBER
	CAIN	X2,0		;IF=0 NEVER REFERENCED IN "FILES" STATEMENT
	JRST	FNR
XRES0:	DPB	X1,[POINT 4,DREL,12]	;DEPOSIT CHANNEL NUMBER FOR RELEASE
	XCT	DREL			;DO RELEASE
	MOVEI	X2,@BA-1(X1)	;GET BUFFER ADDRESS
	MOVEM	X2,JOBFF
	XCT	INITI-1(X1)	;INIT THAT CHANNEL
	JRST	NODEVX
	DPB	X1,[POINT 4, IBDSK, 12]
	XCT	IBDSK
	MOVE	X2,FILD-1(X1)	;GET FILE NAME
	MOVEM	X2,LOK		;SET FOR LOOKUP
	HLLZS	LOK+1
	SETZM	LOK+2
	SETZM	LOK+3		;ZERO PJ-PG
	DPB	X1,[POINT 4,LOKUP,12]	;SET CHANNEL FOR LOOKUP
	XCT	LOKUP		;DO LOOKUP
	JRST	LOKFAL
	MOVE	X2,ACTBL-1(X1)
	CAIE	X2,3
	JRST	XRES00
	DPB	X1,[POINT 4,CLOSED,12]
	XCT	CLOSED
	HLLZ	X2,LOK+2
	TLZ	X2,777
	IOR	X2,MONLVL
	MOVEM	X2,LOK+2
	HLLZS	LOK+1
	SETZM	LOK+3
	DPB	X1,[POINT 4,RENAMD,12]
	XCT	RENAMD
	JRST	.+1		;RENAME FAILS FOR DECTAPES.
	MOVEI	X2,1
	MOVEM	X2,ACTBL-1(X1)
	JRST	XRES0
XRES00:	MOVEI	X2,1		
	MOVEM	X2,ACTBL-1(X1)	;SET ACCESS TABLE FOR READ
	POPJ	P,


;SCRATCH# STATEMENT
;FORMAT
;     SCRATCH# 4,7,8
; PREPARES COMPILER FOR WRITING ON DISK
; IF IT IS DESIRED TO CREATE A FILE THEN THIS
; COMMAND SHOULD PRECEED THE WRITE STATEMENT

XSCRAT:	ASCIZ /ATCH#/		;HERE ON SCRATCH COMMAND
	TLNE	C,F.TERM	;THERE BETTER BE SOMETHING
	JRST	GRONK		
	MOVSI	D,(DATA 10,)
	HRR	D,THELIN	;RH CONTAINS LINE NUMBER.
	PUSHJ	P,BUILDI	;BUILD LINE UUO.
SRAER1:	TLNN	C,F.DIG
	JRST	GRONK
SRAER2:	SUBI	C,60		;GET CHANNEL NUMBER
	TRNN	C,777777
	JRST	GRONK
	MOVSI	D,(DATA 5,)	;SET TO BUILD SCRATCH UUO	
	HRR	D,C		;RH=CHANNEL NUMBER
	PUSHJ	P,BUILDI	;BUILD SCRATCH UUO
	PUSHJ	P,NXCH		;ANYMORE CHANNELS
	TLNN	C,F.COMA	;IF IT DOES NOT = "," - NO
	JRST	NXTSTA		;GET NEXT COMMAND
	PUSHJ	P,NXCH		;GET NEXT CHANNEL NUMBER OR "#"
	TLNE	C,F.DIG
	JRST	SRAER2		;CHANNEL NO.
	HRRZ	D,C
	CAIE	D,43
	JRST	GRONK		;NOT CHAN. NO, NOT #.
	PUSHJ	P,NXCH
	JRST	SRAER1



;SCRATCH UUO
SCATH:	HRRZ	X1,40		;GET CHANNEL NUMBER
	MOVE	X2,ACTBL-1(X1)	;GET ACCESS CODE
	CAIN	X2,0		;IF=0 NEVER REFERENCED IN "FILES" STATEMENT
	JRST	FNR
	MOVEI	X2,@BA-1(X1)	;GET BUFFER ADDRESS
	MOVEM	X2,JOBFF
	XCT	INITO-1(X1)	;DO INIT
	JRST	NODEVX
	DPB	X1,[POINT 4,OBDSK,12]	;SET CHANNEL FOR OUTBUF
	XCT	OBDSK		;DO "OUTBUF"
	MOVE	X2,FILD-1(X1)	;GET FILE NAME
	MOVEM	X2,ENT		;SET FOR ENTER
	HLLZS	ENT+1		;LEVEL D FIX.
	SETZM	ENT+2
	SETZM	ENT+3
	DPB	X1,[POINT 4,ENTDSK,12]	;SET CHANNEL FOR ENTER
	XCT	ENTDSK		;DO ENTER
	JRST	ENFAIL		;ENTER FAILED
	DPB	X1,[POINT 4,OUTDSK,12]	;SET FOR DUMMY OUTPUT
	XCT	OUTDSK		;DO DUMMY OUTPUT
	MOVEI	X2,3		;FILE OK FOR WRITING
	MOVEM	X2,ACTBL-1(X1)	;TELL ACCESS TABLE
	MOVEI	X2,^D990
	MOVEM	X2,LINNUM-1(X1)
	SETOM	LNINS-1(X1)
	POPJ	P,


;WRITE# STATEMENT
;FORMAT
;     WRITE #1
; CAUSES DATA TO BE OUTPUT TO DISK ON CHANNEL #N.

XWRIT:	ASCIZ /TE#/		;WRITE# COMMAND SAME AS PRINT#
	JRST	FFO+1		;WRITE# ENTERS HERE.
FFO:	PUSHJ	P,NXCH		;PRINT# ENTERS HERE, ONE CHARACTER BEHIND.
	TLNN	C,F.DIG		;SHOULD BE CHANNEL NUMBER
	JRST	GRONK
	SETOM	DSKOFL
	MOVSI	D,(DATA 10,)	;BUILD LINE UUO
	HRR	D,THELIN	;GET CURRENT LINE NUMBER
	PUSHJ	P,BUILDI	;BUILD UUO
	SUBI	C,60		;GET CHANNEL NUMBER
	TRNN	C,777777
	JRST	GRONK
	MOVSI	D,(DATA 6,)	;BUILD PRINT TO DISK UUO
	HRR	D,C		;RV=CHANNEL NUMBER
	PUSHJ	P,BUILDI	;BUILD UUO
	PUSHJ	P,NXCH
	TLNN	C,F.COMA	;MUST BE A COMMA DELIMITER.
	JRST	GRONK
	PUSHJ	P,NXCH
XWRIT1:	SETOM	STRFLA
	TLNE	C,F.QUOT
	JRST	XWRTQT		;STRING CONSTANT.
	PUSHJ	P,FORMLS
IFN FTSTR,<
	SKIPL	STRFLA
	JRST	XWRTSR
>
	PUSHJ	P,GPOSNX	;NUMERIC DATA.
	MOVSI	D,(PRNM)
	PUSHJ	P,BUILDA
	JRST	XWRTLP

XWRTQT:	PUSH	P,T		;A STRING CONSTANT.
	PUSHJ	P,QSKIP
	JRST	GRONK
	MOVSI	D,(PRTX)
	PUSHJ	P,BUILDI
	POP	P,D
	PUSHJ	P,BUILDI

XWRTLP:	TLNE	C,F.TERM	;LOOP.
	JRST	NXTSTA
	TLNN	C,F.COMA
	JRST	GRONK
	PUSHJ	P,NXCH
	JRST	XWRIT1
IFN FTSTR,<
XWRTSR:	MOVSI	D,(PRSTR)	;A STRING VARIABLE.
	PUSHJ	P,BUILDA
	JRST	XWRTLP
>


IPDSK:	HRRZ	LP,40		;GET CHANNEL NUMBER
	MOVE	X2,ACTBL-1(LP)	;GET ACCESS CODE
	CAIN	X2,0		;WAS FILE REFERENCED IN "FILES" STATEMENT?
	JRST	FNR		;NO
	CAIE	X2,3		;OPEN FOR WRITING?
	JRST	ILWRT		;NO
	SETOM	ODF
	SETOM	LNINS-1(LP)
	POPJ	P,

CODSK:	MOVEI	C,15
	PUSHJ	P,OUCH
	MOVEI	C,12
	PUSHJ	P,OUCH
	SETZB	LP,ODF		;CLEAR CHAN. SPEC. & INPUT FROM DSK FLAG
	POPJ	P,


LINSST:	HRRZ	X1,40		;HERE ON LINE UUO
	MOVEM	X1,CURLIN	;SET CURRENT LINE NUMBER
	POPJ	P,
;PRINT STATEMENT

;<PRINT STA> ::= PRINT [<PRT ELT> [,!;<PRT ELT>][,!;]
;<PRT ELT> ::=<EXPRESSION>!"<TEXT>"!TAB(<EXPRESSION>)

XPRINT:	ASCIZ	/NT/
XPRI1:	TLNE	C,F.TERM	;CR?
	JRST	XPCRLF
XPRI2:	SETOM	STRFLA		;NEXT PRINT ELEMENT MAY BE A STRING
	TLNE	C,F.QUOT	;QUOTES?
	JRST	XPNQT		;YES
	PUSHJ	P,QSA
	ASCIZ /TAB/		;TAB FIELD?
	CAIA			;NO, ASSUME EXPRESSION
	JRST	XPRTAB		;YES, DO THE TAB

;PRINT EXPRESSION

PRNEXP:	PUSHJ	P,FORMLS	;GEN THE EXPRESSION
IFN FTSTR,<
	SKIPL	STRFLA		;WAS ELEMENT A STRING?
	JRST	XPNSTR		;YES.
>
	PUSHJ	P,GPOSNX	;MOVE TO REG IF UNCOMPLEMENTED OR INDEXED.
	MOVSI	D,(PRNM)	;SET UP OP CODE
	PUSHJ	P,CHKFMT	;SET FORMAT CODE
	PUSHJ	P,BUILDA	;GEN PRINT UUO
	JRST	XPRFIN		;GO FOR MORE


;PRINT TAB

XPRTAB:	PUSHJ	P,FORMLA		;EVALUATE TAB SUBEXPRESSION
	PUSHJ	P,EIRGNP		;MOVE IT INTO REG
	MOVSI	D,(PRNTB)		;CALL THE TAB INTERPRETER
XPRTA1:	PUSHJ	P,CHKFMT
	PUSHJ	P,BUILDI		;YES, BUILD THE INST.
	JRST	XPRFIN

;PRINT QUOTED TEXT

XPNQT:	PUSH	P,T		;SAVE POINTER TO FIRST CHAR
XPNQT1:	PUSHJ	P,QSKIP		;READ BEYOND CLOSING QUOTE.
	JRST	GRONK		;NO TERMINAL  QUOTE CHAR
	MOVSI	D,(PRTX)
	PUSHJ	P,CHKFMT	;CHECK FORMAT CHARACTER
	PUSHJ	P,BUILDI
	POP	P,D		;BUILD BYTE PNTR
	PUSHJ	P,BUILDI
XPRFIN:	TLNE	C,F.TERM		;CR AT END OF LINE?
	JRST	NXTSTA
	JRST	XPRI2		;NO.  GO FOR MORE

;HERE FOR PRINT WITH NO ARGUMENTS.  GEN CARRIAGE RETURN.

XPCRLF:	MOVE	D,[PUSHJ P,PCRLF]
	PUSHJ	P,BUILDI
	JRST	NXTSTA

;CHECK FORMAT CHAR (PRINT AND MAT PRINT)

CHKFMT:	TLNE	C,F.TERM
	TLO	D,40		;CR ... AC = 1
	CAIN	C,";"
	TLO	D,100
	TLNE	C,F.COMA	;, .... AC=3
	TLO	D,140
	TLNN	D,140		;WAS THERE A FMT CHAR?
	TLO	D,100		;NO. ASSUME ";"
	CAIE	C,";"
	TLNE	C,F.COMA	;SKIP FMT CHAR IF THERE WAS ONE.
	JRST	NXCHK		;YES.  SKIP
	POPJ	P,

IFN FTSTR,<
XPNSTR:	MOVSI	D,(PRSTR)
	PUSHJ	P,CHKFMT	;CHECK FORMAT CHARACTER
	PUSHJ	P,BUILDA	;BUILD STRING PRINT UUO
	JRST	XPRFIN		;FINISH AND LOOK FOR MORE TO PRINT
>
;RANDOM IZE STATEMENT

IFN FTRND,<
XRAN:	ASCIZ /DOM/
	PUSHJ	P,QSA
	ASCIZ	/IZE/
	JFCL
	TLNN	C,F.TERM
	JRST	ILLINS
	MOVE	D,[PUSHJ P,RANDER]
	PUSHJ	P,BUILDI		;BUILD CALL TO RUNTIME RANDOMIZER
	JRST	NXTSTA			
>;ASSEMBLE ABOVE IF INCLUDING RANDOM FACILITY



;READ STATEMENT

XREAD:	ASCIZ /D/
	SKIPL	DATAFF		;DATA SEEN YET?
	HLLOS	DATAFF	;NO.  SET NO DATA FLAG.
	MOVE	D,[PUSHJ P,DOREAD]
	JRST	XINP0		;GO FINISH WITH INPUT CODE




;RESTORE STATEMENT

XREST:	ASCIZ	/TORE/
	JRST	XREST1		;ENTER HERE FOR RESTORE STATEMENTS.
	MOVSI	D,(DATA 10,)	;ENTER HERE FOR RESTORE# STATEMENTS.
	HRR	D,THELIN
	PUSHJ	P,BUILDI
XRES2:	PUSHJ	P,NXCH
XRES3:	TLNN	C,F.DIG
	JRST	GRONK
XRES4:	SUBI	C,60
	TRNN	C,777777
	JRST	GRONK
	MOVSI	D,(DATA 4,)
	HRR	D,C
	PUSHJ	P,BUILDI
	PUSHJ	P,NXCH
	TLNN	C,F.COMA
	JRST	NXTSTA
	PUSHJ	P,NXCH
	TLNE	C,F.DIG
	JRST	XRES4
	HRRZ	D,C
	CAIE	D,43
	JRST	GRONK
	JRST	XRES2
XREST1:	MOVE	D,[PUSHJ P,RESTON]
IFN FTSTR,<
	TLNN	C,F.STAR+F.DOLL
	SOJA	D,XRES1
	TLNE	C,F.DOLL	;RESTORE ONLY STRINGS?
	ADDI	D,1
	PUSHJ	P,NXCHK		;SKIP $ OR *
>
XRES1:	PUSHJ	P,BUILDI
	JRST	NXTSTA



;RETURN STATEMENT XLATE

XRETRN:	ASCIZ	/URN/
	SKIPE	FUNAME
	FAIL	<RETURN WITHIN DEF>
	MOVE	D,[JRST RETURN]
XRET1:	PUSHJ	P,BUILDI	;XDEF ENTERS HERE TO COMPLETE A FN DEF.
	JRST 	NXTSTA



;STOP STATEMENT

XSTOP:	ASCIZ	/P/
	MOVE	D,[JRST UXIT]
	PUSHJ	P,BUILDI
	JRST	NXTSTA
;GEN CODE TO EVALUATE FORMULA
;POINTER TO (POSSIBLY NEGATIVE) RESULT RETURNED IN B

;THIS LOOP HANDLES SUMS OF TERMS, CALLS TERM TO HANDLE PRODUCTS
;AND SO ON
;THE ENTRY FORMLA REGARDS STRING EXPRESSIONS AS ILLEGAL.
;THE ENTRY FORMLS WILL EVALUATE AN EXPRESSION OR REGISTER A STRING EXPRESSION

FORMLS:
IFN FTSTR,<
	SETZI	F,		;THIS ENTRY TRANSLATES STRING AND NUMBER EXPRESSIONS.
	TLNE	C,F.QUOT	;STRING LITERAL?
	JRST	REGSLT		;REGISTER STRING LITERAL
	TLNN	C,F.LETT	;IS A VARIABLE FIRST?
>
FORMLA:	SETOI	F,		;CANNOT BE A STRING EXPRESSION.
	PUSHJ	P,TERM		;GET FIRST TERM

;ENTER HERE FOR MORE SUMMANDS

FORM1:	TLNN	C,F.PLUS+F.MINS	;IS BREAK PLUS OR "-"?
	POPJ	P,		;NO, SO DONE WITH FORMULA
	MOVMS	LETSW		;THIS CANT BE LH(LET)
	TLO	F,-1		;AFTER FIRST TERM, STRINGS ARE ILLEGAL.
	PUSHJ	P,PUSHPR	;PART RESLT TO SEXROL
	PUSHJ	P,TERM		;GEN SECOND TERM
	TLNE	B,ROLMSK	;IS SECOND TERM IN REG?
	PUSHJ	P,EXCHG		;NO.  LETS DO FIRST TERM FIRST
	PUSHJ	P,EIRGEN	;FIRST SUMMAND TO REG
	PUSH	P,B		;SAVE SIGN INFORMATION
	PUSHJ	P,POPPR		;GET SECOND SUMMAND
	SKIPGE	(P)		;IS CONTENT OR REG NEGATIVE?
	TLC	B,MINFLG	;YES, NEGATE SECOND SUMMAND
	MOVSI	D,(FADR N,)	;FETCH INSTRUCTION
	PUSHJ	P,BUILDS	;BUILD ADD OR SUB INSTR
	POP	P,B		;REG PNTR WITH SIGN
	AND	B,[XWD MINFLG,0]
	JRST	FORM1		;GO LOOK FOR MORE SUMMANDS
;LOOP TO GEN CODE FOR MULTIPLY AND DIVIDE
;CALLS FACTOR TO HANDLE EXPRESSIONS INVOLVING ONLY INFIX OPS AND "^"

TERM:	PUSHJ	P,FACTOR	;GEN FIRST FACTOR

;ENTER HERE FOR MORE FACTORS

TERM1:	TLNN	C,F.STAR+F.SLSH		;MUL OR DIV FOLLOWS?
	POPJ	P,				;NO, DONE WITH TERM.
	MOVMS	LETSW		;THIS CANT BE LH(LET)
	TLO	F,-1	;AFTER FIRST FACTOR, STRINGS ARE ILLEGAL.
	HRRZS	0(P)				;SET MUL FLAG.
	TLNN	C,F.STAR			;IS IT MULTIPLY?
	HRROS	0(P)		;NO. SET DIV FLAG
TERM2:	PUSHJ	P,NXCHK		;SKIP OVER CONNECTIVE
	PUSHJ	P,PUSHPR	;STASH PARTIAL RESULT ON SEXROL
	PUSHJ	P,FACTOR	;GEN NEXT FACTOR
	SKIPGE	(P)		;IS SECOND FACTOR A DIVISOR?
	PUSHJ	P,SITGEN	;YES. IT CANNOT STAY IN REG.
	TLNE	B,ROLMSK	;IS SECOND FACTOR IN REG?
	PUSHJ	P,EXCHG		;NO. LETS GET FIRST FACTOR.
	MOVE	X1,CESEX		;PEEK AT DIVISOR OR SECOND FACTOR.
	MOVE	X2,-1(X1)
	TLZE	X2,MINFLG		;IS IT MINUS?
	TLC	B,MINFLG		;YES. CHANGE SIGNS OF BOTH.
	MOVEM	X2,-1(X1)		;NOW DIVISION OR SECOND FACTOR IS PLUS.
	PUSHJ	P,EIRGEN	;GEN FIRST FACTOR OR DIVIDEND
	PUSH	P,B		;SAVE SIGN INFORMATION
	PUSHJ	P,POPPR		;GET SECOND OPERAND
	MOVSI	D,(FMPR N,)	;GET CORRECT INSTRUCTION
	SKIPGE	-1(P)
	MOVSI	D,(FDVR N,)
	PUSHJ	P,BUILDA	;BUILD MUL OR DIV INSTR
	POP	P,B		;REG PNTR WITH SIGN
	JRST	TERM1		;GO LOOK FOR MORE FACTORS
;GEN CODE FOR ATOMIC FORMULAS, EXPONENTIATION, AND INFIX SIGNS
;SIGN IS STASHED IN LH OF PUSH-DOWN LIST WORD WITH RETURN ADDRS
;EXPLICIT SIGN IS NOT USED UNTIL AFTER EXPONENTIATION
;IS CHECKED FOR.


FACTOR:	PUSH	P,C		;STASH SIGN IN PUSH LIST.
	TLNE	C,F.MINS	;EXPLICIT MINUS SIGN?
	TLC	C,F.PLUS+F.MINS	;YES. PRETEND IT WAS PLUS CALLING ATOM.

FACT2:	PUSHJ	P,ATOM		;GEN FIRST ATOM


FACT2A:	CAIE	C,"^"	;EXPONENT FOLLOWS?
	JRST	SNOEXI		;NO.  GO NOTE SIGN AND RETURN.
	MOVMS	LETSW		;THIS CANT BE LH(LET)
	PUSHJ	P,NXCHK		;YES.  SKIP EXPONENTIATION SIGN
	PUSHJ	P,PUSHPR	;STASH BASE ON SEXROL
	PUSHJ	P,ATOM		;GEN THE EXPONENT
	PUSHJ	P,EXCHG		;EXCHANGE BASE AND EXPONENT
	PUSHJ	P,EIRGNP	;GET POSITIVE BASE IN REG
	PUSHJ	P,POPPR		;GET EXPONENT IN AC1
	MOVSI	D,(MOVE 1,)
	PUSHJ	P,BUILDS
	MOVE	D,[PUSHJ 17,EXP3.0]
	PUSHJ	P,BUILDI	;BUILD CALL TO EXPONENTIATION ROUTINE
	MOVEI	B,0		;ANSWER LANDS IN REG
	JRST	FACT2A


;SIGN NOTE AND EXIT
;COMPLEMENT SIGN IF "-" AND APPROPRIATE FLAGS ON PD LIST.
;THEN RETURN FROM SUBROUTINE.

SNOEXI:	POP	P,X1
	TLNE	X1,F.MINS		;IS SAVED SIGN MINUS?
	TLC	B,MINFLG		;YES. COMPLEMENT
	POPJ	P,
;GEN CODE FOR SIGNED ATOM.

ATOM:	PUSH	P,C		;SAVE SIGN INFO.
	TLNE	C,F.PLUS+F.MINS	;EXPLICIT SIGN?
	PUSHJ	P,NXCHK		;YES. SKIP SIGN
	TLNE	C,F.LETT	;LETTER?
	JRST	FLETTR		;YES. VARIABLE OR FCN CALL.
	TLNE	C,F.DIG+F.PER	;NUMERAL OR DECIMAL POINT?
	JRST	FNUMBR		;YES. LITERAL OCCURRENCE OF NUMBER
	CAIE	C,"("	;SUBEXPRESSION?
	JRST	ILFORM		;NO.  ILLEGAL FORMULA

FSUBEX:	PUSHJ	P,NXCHK		;SUBEXPR IN PARENS.  SKIP PAREN
	PUSHJ	P,FORMLA	;GEN THE SUBEXPRESSION
	TLNN	C,F.RPRN	;BETTER HAVE MATCHING PAREN
	JRST	ILFORM		;NO.  GRONK.
	PUSHJ	P,NXCHK		;SKIP PARENTHESIS
	JRST	SNOEXI		;GO TEST SIGN AND RETURN.


;HERE WHEN ATOMIC FORMULA IS A NUMBER

FNUMBR:	PUSHJ	P,EVANUM	;EVALUATE NUMBER (IN N)
	FAIL	<ILLEGAL CONSTANT>
	MOVE	X1,0(P)		;GET SIGN FLAG
	CAIE	C,"^"		;EXPONENT FOLLOWS?
	TLNN	X1,F.MINS		;OR IS IT PLUS ANYWAY?
	JRST	FNUM1		;YES.  DONT FUDGE SIGN
	MOVN	N,N		;NEGATE NUMBER
	SETZM	0(P)		;AND CLEAR SIGN INFO.

FNUM1:	MOVE	B,FLCON	;SEARCH CONSTANT ROLL
FNUM2:	CAML	B,CECON	;(UNSORTED--CANT USE SEARCH)
	JRST	FNUM3		;NOT FOUND
	CAME	N,(B)		;THIS ONE?
	AOJA	B,FNUM2		;NO. GO TO NEXT.
	SUB	B,FLCON	;FOUND. CALC REL ADDRESS IN CONROL.
	JRST	FNUM4

FNUM3:	MOVEI	R,CONROL	;PUSH ON CONROL
	MOVE	A,N
	PUSHJ	P,RPUSH
	MOVEI	R,CADROL	;PUT ADDRS ON CONST ADDRS ROLL
	MOVEI	A,0
	PUSHJ	P,RPUSH
	SUB	B,FLCAD	;GET REL ADDRS

FNUM4:	HRLI	B,CADROL	;MAKE POINTER
	JRST	SNOEXI		;GO LOOK AT SIGN AND RETURN.

NNUM:	PUSH	P,[EXP 1]	;REGISTER THE CONSTANT IN "N"
	JRST	FNUM1
;XLATE AND GEN ATOMIC FORMULA BEGINNING WITH LETTER

FLETTR:	PUSHJ	P,REGLTR
	CAILE	A,4	;IS CODE >4?
	AOS	STRFLA	;YES. STRING SEEN.
	JRST	.+1(A)
	JRST	XARFET		;ARRAY REF
	JRST	SNOEXI		;SCALAR.  JUST RETURN
	JRST	XINFCN		;INTRINSIC FCN
	JRST	XDFFCN		;DEFINED FCN
	JRST	ILVAR
IFN FTSTR,<
	JRST	XARFET		;STRING VECTOR. PROCESS WITH ARRAY CODE!
	JRST	XSTR		;TRANSLATE STRING REFERENCE.
	JRST	XLIT		;TRANSLATE LITERAL STRING REFERENCE.
>
FLET2:	PUSH	P,[EXP 1]	;PUSH AN IMPLICIT PLUS SIGN ON PLIST
	JRST	FLETTR+1	;FINISH REGISTERING VARIABLE.

IFN FTSTR,<
STRFCH:	SKIPGE	STRFLA		;BUILD STRING FETCH IF STRING STA
	POPJ	P,		;NOT A STRING STA, DO NOTHING
	MOVSI	D,(STRFET)
	JRST	BUILDA
>

XARFET:	PUSH	P,B
	PUSH	P,F
	PUSHJ	P,REGFRE	;FREE REG
	PUSHJ	P,XARG
	POP	P,F
	SKIPGE	STRFLA		;STRING VECTOR?
	SKIPL	LETSW		;NO, IS IT LH OF ARRAY-LET?
	JRST	XARF1		;DO A FETCH AS USUAL.
	TLNN	C,F.COMA+F.EQAL	;IS IT DEFINITELY LH OF ARRAY-LET?
	JRST	XARF1		;NO.

	POP	P,X1		;YES. DON'T FETCH! RETURN TO LH(LET)
	SUB	P,[XWD 6,6]	;ADJUST THE PUSHLIST TO ESC FORMLS
	PUSH	P,B		;SAVE THE ARGUMENT FLAG
	PUSH	P,X1		;SAVE THE ARRAY POINTER
	JRST	XLET1

XARF1:	PUSH	P,B
	MOVSI	D,(ARFET1)
IFN	FTSTR,<
	SKIPL	STRFLA	;STRING VECTOR?
	MOVSI	D,(SVRADR)	;YES. FETCH STRING POINTER ADRESS.
>
	JUMPE	B,XARFFN
	SKIPL	STRFLA
	FAIL <STRING VECTOR HAS 2 DIMS>
	MOVSI	D,(ARFET2)
	MOVE	X1,-1(P)	;MARK DOUBLE ARRAY
	ADD	X1,FLOOR(F)
	SKIPN	1(X1)
	SETOM	1(X1)
XARFFN:	POP	P,B
	EXCH	B,0(P)
	PUSHJ	P,BUILDA
	POP	P,B
	PUSHJ	P,GENARG
	MOVEI	B,0		;REG POINTER
	SKIPL	STRFLA		;STRING VECTOR?
	PUSHJ	P,SITGEN	;YES,SAVE ADDRESS POINTER
	JRST	SNOEXI
;GEN FUNCTION CALLS

XDFFCN:	PUSH	P,D		;SAVE FCN NAME
	PUSHJ	P,REGFRE	;SAVE ANY SUBEXPRESSION
	PUSHJ	P,PUSHPR	;SAVE FUNCTION LOCATION
	MOVE	D,[PUSHJ P,SAVACS]
	PUSHJ	P,BUILDI
	CAIE	C,"("	;ANY ARGS?
	JRST	XDFF2		;NO
	SETZM	PSHPNT		;INITIALIZE COUNT OF PUSH INSTS GENNED
XDFF1:	PUSHJ	P,NXCHK
	PUSH	P,LETSW
	MOVMS	LETSW
	PUSHJ	P,FORMLA	;GEN THE ARGUMENT IN REG
	POP	P,LETSW
	JUMPGE	B,.+2
	PUSHJ	P,EIRGP1
	MOVSI	D,(PUSH Q,)	;BUILD ARGUMENT PUSH
	PUSHJ	P,BUILDA
	AOS	PSHPNT		;COUNT THE PUSH
	AOS	(P)		;ALSO SAVE THE COUNT FOR CHECK OF ARGS
	TLNE	C,F.COMA		;MORE ARGS?
	JRST	XDFF1		;YES

	TLNN	C,F.RPRN		;CHECK FOR MATCHING PAREN
	JRST	GRONK
	SETZM	PSHPNT		;RESET THE PUSH COUNT AGAIN
	PUSHJ	P,NXCHK		;SKIP PAREN

XDFF2:	PUSHJ	P,ARGCHK	;CHECK FOR RIGHT NUMBER OF ARGUMENTS
	POP	P,X1		;GET RID OF POINTER TO ARG# CONSTANT
	PUSHJ	P,POPPR		;GET BACK FUNCTION LOC
	MOVSI	D,(GOSUB)
	PUSHJ	P,BUILDA	;GEN THE CALL
	MOVEI	B,0		;ANSWER IS IN REG
	JRST	SNOEXI

;ROUTINE TO CHECK NUMBER OF ARGUMENTS AND CREATE A CONSTANT TO POP THEM
;OFF THE PUSH LIST.  CALLED WITH	XWD FCNAME,# OF ARGS
;AT LOCATION -1(P)	RETURNS WITH A POINTER TO CONSTANT
;AT THAT LOCATION.

ARGCHK:	HRRZ	N,-1(P)
	HRL	N,N		;N NOW CONTAINS THE CONSTANT TO SUBTRACT FROM P
	PUSHJ	P,NNUM		;REGISTER THIS CONSTANT
	MOVE	N,-1(P)		;GET FCN NAME
	MOVEM	B,-1(P)		;SAVE ADDRESS OF CONSTANT
	HRR	N,B		;ASSEMBLE FADROL ENTRY...
	HLLZ	A,N		;SETUP SEARCH ARGUMENT
	MOVEI	R,FADROL	; XWD FCNAME,CONSTANT ADDRESS
	PUSHJ	P,SEARCH
	JRST	ARGCH1		;FIRST TIME FCN SEEN. PUT ENTRY IN ROLL
	CAMN	N,(B)		;FCN SEEN BEFORE. SAME NUMBER OF ARGS?
	POPJ	P,
	SETZM	FUNAME
	FAIL	<INCORRECT NUMBER OF ARGUMENTS>

ARGCH1:	MOVEI	E,1		;ADD FCN REF TO FADROL
	PUSHJ	P,OPENUP
	MOVEM	N,(B)
	POPJ	P,

XINFCN:	PUSH	P,B		;SAVE FCN LOC
	PUSHJ	P,REGFRE	;PROTECT ANY PARTIAL RESULT
	CAIN	C,"("	;IS THERE AN ARGUMENT?
	JRST	XINF2		;YES. TRANSLATE IT
	TRNN	B,40000		;CAN FN HAVE NO ARGS?
	FAIL	<INCORRECT NUMBER OF ARGUMENTS>
	JRST	XINF3		;YES. GO ON TO IFN CALL.

XINF2:	PUSHJ	P,NXCHK		;SKIP OVER THE "("
	PUSHJ	P,FORMLA	;EVALUATE THE ARGUMENT
	PUSHJ	P,EIRGNP	;GET ARGUMENT INTO REG.
	PUSHJ	P,XARG2	;CHECK AND SKIP ")"
XINF3:	POP	P,D
	TRZ	D,40000		;TURN OFF NO-ARG BIT, IF ON
	HRLI	D,(PUSHJ P,)
	PUSHJ	P,BUILDI
	MOVEI	B,0		;RESULT IN REG.
	JRST	SNOEXI

IFN FTSTR,<
XLIT:	PUSH	P,[EXP 1]	;IMPLICIT PLUS SIGN PRECEDES STRING.
XSTR:	JRST	SNOEXI	;POINTER ADDRESS IN (B) FOR BUILDING
>
;ROUTINE TO XLATE ARGUMENTS
;RETURNS WITH ARGS ON SEXROL.  B IS O IF ONE ARG, -1 IF TWO.

XARG:	PUSHJ	P,NXCHK		;SKIP PARENTHESIS.
	PUSH	P,LETSW		;SAVE LETSW WHILE TRANSL ARGS
	MOVMS	LETSW		;THE COMMA FOLLOWING AN ARG IS NOT LH(LET)!
        PUSH  P,STRFLA          ;GEN FIRST ARGUMENT
        SETOM STRFLA
        PUSHJ P,FORMLA
        SKIPL STRFLA
        FAIL <NESTED STRING VECTORS>
        POP   P,STRFLA
	PUSHJ	P,GPOSNX
	PUSHJ	P,SITGEN
	PUSHJ	P,PUSHPR
	MOVEI	B,0
	TLNN	C,F.COMA		;COMMA FOLLOWS?
	JRST	XARG1		;NO. ONE ARG.
	PUSHJ	P,NXCHK		;YES GEN AND SAVE SECOND ARG
	PUSHJ	P,FORMLA
	PUSHJ	P,GPOSNX
	PUSHJ	P,SITGEN
	PUSHJ	P,PUSHPR
	MOVNI	B,1		;DBL ARG FLAG
XARG1:	POP	P,LETSW		;RESTORE LETSW

XARG2:	TLNN	C,F.RPRN		;MUST HAVE PARENTHESIS
	JRST	ILFORM
	JRST	NXCHK		;IT DOES. SKIP PAREN AND RETURN.


;ROUTINE TO GEN ARGUMENTS

GENARG:	JUMPE	B,GENAFN		;ONE OR TWO ARGS?
	PUSHJ	P,POPPR		;TWO
	PUSHJ	P,EXCHG
	PUSHJ	P,GENAF1

GENAFN:	PUSHJ	P,POPPR
GENAF1:	MOVSI	D,(JUMP 2,)
	JRST	BUILDA
;ROUTINE TO ANALYZE NEXT ELEMENT
;CALL:	PUSHJ	P,REGLTR
;RETURNS ROLL PNTR IN B, CODE IN A
;CODE IS: 0-ARRAY, 1-SCALAR, 2-INTRINSIC FCN, 3-DEFINED FCN, 4-FAIL
;		5-STRING VECTOR, 6-STRING VARIABLE, 7-STRING LITERAL.

REGLTR:	PUSHJ	P,SCNLT1	;LTR TO A, LEFT JUST 7 BIT
	HRRI	F,SCAROL	;ASSUME SCALAR
	TLNE	C,F.LETT	;ANOTHER LETTER?
	JRST	REGFCN		;YES.  GO LOOK FOR FCN REF
	TLNN	C,F.DIG		;DIGIT FOLLOWS?
	JRST	REGARY		;NO, GO CHECK FOR ARRAY
	DPB	C,[POINT 7,A,13];ADD DIGIT TO NAME
	PUSHJ	P,NXCHK		;GO ON TO NEXT CHAR
IFN FTSTR,<
	TLNE	C,F.DOLL	;STRING VARIABLE?
	JRST	REGSTR		;YES. REGISTER IT.
>

;RETURN HERE IF REGARY SAYS NOT ARRAY
;RETURN HERE IF REGFCN SAYS FOLLOWED BY KEYWORD.

REGL1:	TLNE	A,17		;IS THIS A SCALAR?
	JRST	REGL1A		;NO. DON'T LOOK FOR FCN ARGUMENT
	MOVE	B,FLARG		;IS THIS A FN ARG?
	CAML	B,CEARG		;SEARCH UNORDERED ARGROL
	JRST	REGL1A		;NOT A FN ARG
	CAME	A,(B)
	AOJA	B,.-3		;TRY NEXT ROLL ENTRY.

	JRST	FARGRF		;YES
REGL1A:	MOVEI	R,VARROL	;NO. SCALAR
	PUSHJ	P,SEARCH	;IN VARIABLE ROLL?
	JRST	REGL2		;NO

	HRRZ	D,(B)		;YES.  GET PNTR TO SCAROL
	JRST	REGL3

REGL2:	MOVEI	E,1		;ADD TO SCALAR ROLL OR VSPROL
	PUSHJ	P,OPENUP
	ADD	A,CEIL(F)	;COMPUTE PNTR TO ROLL
	SUB	A,FLOOR(F)
	HRRZ	D,A		;SAVE ROLL POINTER
	MOVEM	A,(B)
	MOVEI	R,(F)	;PUT NULL ENTRY ON ROLL
	MOVEI	A,0
	PUSHJ	P,RPUSH

;	B ::= REL LOC OF ROLL ENTRY

REGL3:	MOVE	B,D		;B ::= REL LOC OF ROLL ENTRY
	TLO	B,(F)	;MAKE ROLL POINTER AND SKIP
	JRST	REGSCA

;COME HERE ON REF TO FCN ROL

;CALCULATE ADDRESS OF THIS FUNCTION ARGUMENT.
FARGRF:	SUB	B,CEARG	;NOW ADDRESS IS -NN FOR FIRST ARG, -1 FOR NNTH ARG, ETC.
	HRLI	B,PSHROL

REGSCA:	MOVEI	A,1		;CODE SAYS SCALAR
	POPJ	P,		;RETURN

SCAREG:	MOVEI	F,SCAROL	;REGISTER THE CONTENTS OF A AS SCALAR
	JRST	REGL1A
REGARY:	CAIE	C,"("
	TLNE	C,F.DOLL	;ARRAY OR POSSIBLE SRVECTOR REF?
	CAIA
	JRST	REGL1		;NO.  TREAT AS SCALAR
IFN FTSTR,<
	TLNE	C,F.DOLL	;STRING VARIABLE?
	JRST	REGSTR		;YES.
>
REGA0:	HRRI	F,ARAROL	;NUMERICAL ARRAY GOES ON ARAROL.

REGA1:	TLO	A,1		;MAKE ARRAY NAME DIFFERENT FROM SCALAR
	MOVEI	R,VARROL	;LOOK FOR VARIABLE NAME
	PUSHJ	P,SEARCH
	JRST	REGA2		;NOT ALREADY USED
	HRRZ	D,(B)		;GET POINTER TO ARAROL
	JRST	REGA3		;ALREADY USED

REGA2:	MOVEI	E,1		;ADD NEW ARRAY NAME TO VARIABLE ROLL
	PUSHJ	P,OPENUP
	ADD	A,CEIL(F)	;COMPUTE ARRAY OR STRING VECTOR ROLL POINTER
	SUB	A,FLOOR(F)
	ORI	A,400000	;SET ARRAY FLAG
	MOVEM	A,(B)
	HRRZ	D,A		;SAVE ARAROL POINTER
	MOVEI	R,(F)	;TWO ZEROS ON ARAROL (NULL ENTRY)
	MOVEI	A,0
	PUSHJ	P,RPUSH		
	PUSHJ	P,RPUSH

REGA3:	MOVE	B,D		;RECONSTRUCT PNTR
	ANDI	B,377777	;B := REL ADDRS IN ARRAY ROLL
	HRLI	B,(F)	;B := POINTER TO ENTRY ON ROLL
	MOVEI	A,0		;ARRAY CODE
	POPJ	P,


;SUBROUTINE TO REGISTER ARRAY NAME.
;(USED BY DIM,MAT)

ARRAY:	HRRI	F,ARAROL		;ASSUME ITS NOT A STRING
	TLNN	C,F.LETT
	JRST	REGFAL
	PUSHJ	P,SCNLT1	;NAME TO A
IFN FTSTR,<
	TLNE	C,F.DOLL	;STRING VECTOR?
	JRST	ARRAY2		;YES, HANDLE DIFFERENTLY
	TLNE	C,F.DIG
	JRST	ARRAY4
>
	PUSHJ	P,REGA0		;FINISH REGISTERING
ARRAY1:	MOVE	X1,B		;SET DEFAULT TO 2-DIM ARRAY
	ADD	X1,FLOOR(F)
	SKIPN	1(X1)
	SETOM	1(X1)
	POPJ	P,

IFN FTSTR,<
ARRAY4:	DPB	C,[POINT 7,A,13]
	PUSHJ	P,NXCHK
	TLNN	C,F.DOLL
	JRST	REGFAL
	PUSHJ	P,NXCHK
	CAIE	C,"("
	JRST	ARRAY5
	JRST	REGFAL
ARRAY2:	PUSHJ	P,NXCHK		;SKIP THE DOLLAR SIGN.
	CAIN	C,"("	;VECTOR?
	JRST	ARRAY3		;YES.
ARRAY5:	TLNE	F,1		;STRING VARAIBLE. ASSUME STRING VECTOR?
	JRST	REGSTR		;NO. ASSUME STRING
ARRAY3:	PUSHJ	P,REGSVR	;REGISTER STRING VECTOR
	JRST	ARRAY1		;SET DEFAULT, IF NECESSARY
>

VECTOR:	PUSHJ	P,ARRAY		;REGISTER VECTOR
	CAIE	A,5		;WAS A STRING REGISTERED?
	JUMPN	A,CPOPJ		;WAS AN ARRAY REGISTERED?
	MOVE	X2,1(X1)
	JUMPG	X2,.+4		;EXPLICIT DIMENSION?
	MOVNI	X2,-2		;NO.  CALL IT A VECTOR OF UNKNOWN DIM.
	MOVEM	X2,1(X1)
	POPJ	P,
	JUMPLE	X2,CPOPJ	;IMPLICIT DIMENSIONS?
	TLNE	X2,777776	;NO. IS THIS A ROW VECTOR?
	TRNN	X2,777776	;OR A COLUMN VECTOR?
	POPJ	P,		;YES.
	FAIL <USE VECTOR, NOT ARRAY,>

IFN FTSTR,<
REGSTR:	JUMPL	F,GRONK		;REGISTER STRING, IF STRING IS LEGAL
	TLO	A,10		;MAKE STRING NAME DIFFERENT FROM OTHER NAMES.
	HRRI	F,VSPROL	;POINTER WILL GO ON VARIABLE SPACE ROLL
	TLNE	C,F.DOLL	;SKIP DOLLAR SIGN?
	PUSHJ	P,NXCHK		;SKIP DOLLAR SIGN
	CAIN	C,"("	;IS IT A STRING VECTOR?
	JRST	REGSVR		;YES.
	PUSHJ	P,REGL1		;REGISTER STRING.
	JRST	REGS1		;FIX VARIABLE TYPE CODE.

REGSLT:	MOVEI	R,LITROL	;REGISTER STRING LITERAL ON LITROL
	AOS	STRFLA		;STRING SEEN.
	MOVE	A,T		;THIS IS THE STRING POINTER
	PUSHJ	P,RPUSH		;PUSH POINTER ONTO LITERAL ROLL
	MOVEI	R,SADROL	;MOVE LITROL ADDRESS ON STR-LIT-ADR ROLL
	MOVEI	A,0
	PUSHJ	P,RPUSH
	SUB	B,FLSAD	;GET REL ADRESS
	HRLI	B,SADROL	;SET UP POINTER.
	PUSHJ	P,QSKIP		;SKIP OVER LITERAL
	JRST	GRONK		;NO TERMINAL QUOTE CHAR
	JRST	XLIT		;FINISH PROCESSING LIT.
>

QSKIP:	PUSHJ	P,NXCH		;SKIP TO NEXT QUOTE CHAR.
	TLNE	C,F.CR		;TERMINAL QUOTE MISSING?
	POPJ	P,		;YES
	TLNN	C,F.QUOT	;END OF STRING?
	JRST	QSKIP		;NO, GO ON.
	PUSHJ	P,NXCH		;YES. GET NEXT CHAR AND RETURN.
	JRST	CPOPJ1

IFN FTSTR,<
REGSVR:	HRRI	F,SVRROL	;REGISTER STRING VECTOR
	TLO	A,11		;MAKE NAME DIFFERENT FROM THE OTHERS
	TLNE	C,F.DOLL	;DOLLAR SIGN?
	PUSHJ	P,NXCHK		;YES, SKIP IT

	PUSHJ	P,REGA1		;REGISTER AS AN ARRAY

REGS1:	CAIE	A,4		;DID REGISTRATION FAIL?
	ADDI	A,5		;NO. FIX TYPE CODE.
	POPJ	P,
>

;NOTE:  IF THE SAME VARIABLE NAME IS USED AS A SCALAR, ARRAY,
;	STRING VECTOR, AND STRING, IT WILL BE DISTINGUISHED IN "VARROL"
;	BY THE FOLLOWING 4-BIT ENDINGS:
;	SCALAR 0;  ARRAY 1;  STRING 10;  STRING VECTOR 11.
;TABLE OF MIDSTATEMENT KEYWORDS:

KWTBL:	ASCII /BY/
	ASCII /GOTO/
	ASCII /STEP/
	ASCII /THEN/
	ASCII /TO/
	Z

;REGISTER FUNCTION NAME
;FIRST LETTER HAS BEEN SCANNED

;IT IS POSSIBLE THAT WE HAVE SCANNED A ONE-LETTER VARIABLE NAME
;FOLLOWED BY ONE OF THE KEYWORDS "TO" , "THEN", OR "STEP".
;FIRST WE LOOK AHEAD TO SEE IF THIS IS SO;
;IF IT IS WE GO BACK TO SCALAR CODE.

REGFCN:	PUSH	P,C		;SAVE T,C AROUND LOOK-AHEAD.
	PUSH	P,T
	MOVEI	X1,KWTBL	;TBL OF KEYWORDS

REGF1:	PUSHJ	P,QST	;TEST THIS KEYWORD.
	JRST	REGF2
	POP	P,T
	POP	P,C		;KEYWORD FOUND; ASSUME ONE-LETTER SCALAR.
	JRST	REGL1

REGF2:	MOVEI	X1,1(X1)	;NOT CURRENT KEYWORD
	MOVE	T,(P)		;RESTORE POINTERS DESTROYED BY QST
	MOVE	C,-1(P)
	SKIPE	(X1)		;MORE TO TEST?
	JRST	REGF1	;YES
	POP	P,T	;NO, NOT KEYWORD.
	POP	P,C
;HAVE DETERMINED THAT WE MUST BE SCANNING A FUNCTION NAME
;IF SYNTAX IS LEGAL.

;WE SCAN THE SECOND LETTER AND CHECK FOR
;INTRINSIC OR DEFINED FUNCTION.

REGF3:	PUSHJ	P,SCNLT2
	JRST	REGFAL		;NOT A LETTER
	CAMN	A,[SIXBIT /FN/]		;DEFINED FUNCTION?
	JRST	REGDFN		;YES. GO REGISTER DEFINED NAME.

;HERE WE HAVE FN NAME NOT BEGINNING WITH "FN"
;LOOK FOR IT IN TABLE OF INTRINSIC FUNCTIONS.

	PUSHJ	P,SCNLT3	;CONSTRUCT WHOLE NAME
	JRST	REGFAL
	MOVEI	R,IFNROL	;INTRINSIC FCN TABLE
	PUSHJ	P,SEARCH
	JRST	REGFAL
	MOVMS	LETSW		;CAN'T BE LH(LET)
	HRRZ	B,(B)		;PICK UP ADDRS
	MOVEI	A,2		;INTRINSIC FCN CODE.
	POPJ	P,		;RETURN "XINFCN" DOES ITS OWN ")" CHECK.
;HERE TO REGISTER DEFINED FUNCTION NAME
;THE "FN" HAS ALREADY BEEN SCANNED

;SCAN IDENTIFYING LETTER AND PUTTING ENTRY IN
;FUNCTION CALL ROLL

REGDFN:	PUSHJ	P,SCNLT1	;PUT FUNCTION NAME IN A
	CAMN	A,FUNAME	;IS THIS THE NAME OF THE CURRENT MULTI-LINE FN?
	JRST	REGFNA		;YES. REGISTER IT AS A SCALAR
	MOVE	D,A		;NO, REAL FUNCTION CALL.  SAVE NAME FOR ARGCHK
	MOVEI	R,FCLROL	;FUNCTION CALL ROLL
	PUSHJ	P,SEARCH	;USED THIS ONE YET?
	JRST	.+2
	JRST	REGFC1		;ALREADY SEEN A REF
	MOVEI	E,1
	PUSHJ	P,OPENUP
	MOVEM	A,(B)
	PUSHJ	P,REGFC1	;SET B UP FOR KLUDGE TEST
	MOVE	X1,FLSEX	;FIX UP SAVED FCN REFS
REGFC0:	CAML	X1,CESEX	;KLUDGE!!!
	JRST	REGFC1+1
	HLRZ	X2,(X1)		;GET THE ROLL NUMBER
	CAIN	X2,FCLROL	;FCLROL?
	CAMLE	B,(X1)		;YES. IS SEXREF NOW WRONG?
	AOJA	X1,REGFC0	;NO
	AOS	(X1)		;YES. CORRECT IT
	AOJA	X1,REGFC0

REGFC1:	SUB	B,FLFCL
	HRLI	B,FCLROL
	MOVEI	A,3		;DEFINED FCN CODE
	POPJ	P,		;DON'T CHECK FOR () YET

CHKPRN:	CAIE	C,"("
REGFAL:	MOVEI	A,4		;FAIL IF NO PAREN
	POPJ	P,

REGFNA:	TLO	A,(177B13)	;CREATE SPECIAL NAME FOR CURRENT FUNCTION
	JRST	SCAREG		;REGISTER IT AS A SCALAR

	SUBTTL	SUBROUTINES USED BY GEN ROUTINES

;PUSHPR - PUSH PARTIAL RESULT ON SEXROL

PUSHPR:	MOVEI	R,SEXROL
	MOVE	A,B		;SAVE POINTER IN A
	PUSHJ	P,RPUSH
	SUB	B,FLSEX	;MAKE POINTER
	TLNN	A,ROLMSK	;IS IT A POINTER TO REG?
	HRROM	B,REGPNT	;YES, SET POINTER FOR SITGEN TO USE
	POPJ	P,

;POPPR - POP PARTIAL RESULT FROM SEXROL

POPPR:	MOVEI	R,SEXROL
	MOVE	B,CESEX
	SUBI	B,1		;COMPUTE ADDRS OF TOP OF SEXROL
	PUSH	P,(B)		;SAVE THE CONTENT
	MOVEI	E,1
	PUSHJ	P,CLOSUP
	POP	P,B		;POPPED POINTER TO B
POPPFN:	TLNN	B,ROLMSK	;POINTER TO REG?
	SETZM	REGPNT		;YES.  CLEAR MEMORY
	POPJ	P,
;EXCHG - EXCHANGE CURRENT PNTR WITH TOP OF SEXROL

EXCHG:	MOVE	X1,CESEX
	MOVEI	X2,-1(X1)	;FIX PNTR IF REG SAVED
	SUB	X2,FLSEX
	TLNN	B,ROLMSK
	HRROM	X2,REGPNT
	EXCH	B,-1(X1)
	JRST	POPPFN		;GO FIX PNTR IF REG POPPED

;REGFRE - GUARANTEE THAT NO PART RESULT IS IN REG

REGFRE:	SKIPN	REGPNT	;SUBEXP IN THE REG?
	POPJ	P,		;NO
	MOVE	X1,FLSEX	;YES.  COMPUTE WHERE
	ADD	X1,REGPNT
	EXCH	B,(X1)		;GET THE POINTER, SAVE CURR PNTR
	PUSHJ	P,SITGEN	;STORE IN TEMP
	MOVE	X1,FLSEX	;RECOMPUTE LOC IN SEXROL
	ADD	X1,REGPNT
	EXCH	B,(X1)
	SETZM	REGPNT		;CLOBBER REGPNT SINCE REG IS EMPTY
	POPJ	P,
;GPOSGE - GUARANTEE POSITIVE GEN

GPOSGE:	JUMPGE	B,CPOPJ		;RETURN IF ALREADY POSITIVE
				;FALL INTO EIRGEN

;EIRGEN - EXP IN REG GEN

EIRGEN:	TLNN	B,ROLMSK	;ALREADY IN REG?
	POPJ	P,		;DO NOTHING
ERGNFN:	PUSHJ	P,REGFRE	;FREE UP REG
	MOVSI	D,(MOVE N,)	;GET MOVE INSTR
	PUSHJ	P,BUILDS	;BUILD MOVE INSTR
	MOVEI	B,0		;POSITIVE REG POINTER
	POPJ	P,

;EIRGNP - EXP IN REG GEN POSITIVE

EIRGNP:	JUMPGE	B,EIRGEN	;POSITIVE?
EIRGP1:	TLNE	B,ROLMSK	;NO. IN REG?
	JRST	ERGNFN		;NO.  GO MOVE
	MOVSI	D,(MOVN N,)	;YES,NEGATIVE N
	PUSHJ	P,BUILDI
	MOVEI	B,0		;POSITIVE REG PNTR
	POPJ	P,
;SIPGEN - STORE IN PERMANENT TEM GEN

SIPGEN:	MOVEI	R,PTMROL
	JRST	SITGN1

;SITGEN - STORE IN TEMP GEN

SITGEN:	MOVEI	R,TMPROL
SITGN1:	TLNE	B,ROLMSK	;IS EXPR IN REG?
	POPJ	P,		;NO.  DONT DO ANYTHING
	MOVEI	A,0		;PREPARE ZERO TO PUSH ON ROLL
	MOVSI	D,(MOVEM N,)	;GET CORRECT INSTR
	JUMPGE	B,.+2
	MOVSI	D,(MOVNM N,)
	CAIE	R,TMPROL	;STORE ON TMPROL?
	JRST	SITG2		;NO. USE PTMROL
	AOS	B,TMPPNT	;WHICH TEMP TO USE?
	MOVE	X1,FLTMP
	ADD	X1,B
	CAML	X1,CETMP	;NEED MORE TMP SPACE?
	PUSHJ	P,RPUSH	;YES.  PUSH A ZERO ONTO TMPROL
	MOVE	B,TMPPNT	;CONSTRUCT TMP ROLL POINTER
SITG1:	HRLI	B,(R)
	PUSH	P,B	;SAVE ADRESS POINTER
	PUSHJ	P,BUILDA	;BUILD STORE INSTR
	POP	P,B		;RECONSTRUCT POINTER
	POPJ	P,

SITG2:	PUSHJ	P,RPUSH		;PUSH A ZERO ONTO PTMROL
	SUB	B,FLPTM
	JRST	SITG1		;FINISH CONSTRUCTING ADRESS POINTER
;GPOSNX - GUARANTEE POSITIVE AND UNINDEXED GEN

GPOSNX:	TLNE	B,400000+PSHROL	;NEGATIVE OR INDEXED BY (P)?
	PUSHJ	P,EIRGNP	;YES. FORCE INTO REG
	POPJ	P,
BUILDP:	TLO	D,Q		;INSTRUCTION IS INDEXED BY PLIST POINTER
	SUB	B,PSHPNT	;ADJUST THE ADDRESS FOR ANY PUSH INSTS GENNED BY 
	ADDI	B,1
	HRR	D,B		;	A CURRENT FN CALL

;ROUTINE TO ADD CODE TO CODROL.
;A WORD IS ASSUMED IN D
;RETURN REL ADDRS IN B

BUILDI:	SKIPN	RUNFLA		;ARE WE GOING TO RUN?
	POPJ	P,		;NO.  DONT GEN CODE
	MOVEI	E,1
	MOVEI	R,CODROL
	PUSHJ	P,BUMPRL
	MOVEM	D,(B)
	SUB	B,FLCOD
	POPJ	P,


;BUILD SIGNED INSTRUCTION WITH ADDRESS
;CHECK SIGN IN B AND CHANGE UP CODE BITS

BUILDS:	JUMPGE	B,BUILDA	;POSITIVE?
	TLC	D,010000	;NO.  CHANGE MOVE TO MOVN,ETC.
				;FALL INTO BUILDA


;BUILDA - BUILD INSTRUCTION WITH LINKED ADDRESS
;INSTRUCTION SKELETON IS IN D, ADDRESS POINTER IS IN B

BUILDA:	SKIPN	RUNFLA		;ARE WE GOING TO RUN?
	POPJ	P,		;NO.  DONT BUILD
	TLZE	B,PSHROL		;SPECIAL TEST FOR ROLL WITH ABSOLUTE ADDRESSES
	JRST	BUILDP		;YES, PSHROL. DO BUILDI INDEXED BY (Q)
	TLZ	B,400000
	JUMPE	B,BUILDI	;ITEM IS IN REG . USE ADDRESS ZERO

	PUSH	P,B		;SAVE THE POINTER
	PUSHJ	P,BUILDI	;ADD INSTR WITH 0 ADDRS TO CODE
	MOVE	X1,CECOD	;LOC+1 OF THE INSTR
	POP	P,X2		;COMPUTE ADDRS LOCATION
	LDB	R,[POINT 17,X2,17]
	ADD	X2,FLOOR(R)
	MOVE	R,(X2)		;GET NEXT ADDRS IN CHAIN
	HRRM	R,-1(X1)	;STORE IT IN THE INSTR
	SUB	X1,FLCOD
	SUBI	X1,1
	HRRM	X1,(X2)		;STORE CURR ADDRS IN ROLL PNTD TO
	POPJ	P,
	SUBTTL UTILITY SUBROUTINES
;SUBROUTINES FOR GENERAL ROLL MANIPULATION

CLOSUP:	MOVN	X1,E		;COMPUTE NEW END OF ROLL
	ADDB	X1,CEIL(R)	;AND STORE IT
	MOVE	X2,B		;CONSTRUCT BLT WORD
	ADD	X2,E
	MOVS	X2,X2
	HRR	X2,B
	BLT	X2,-1(X1)		;MOVE DOWN TOP OF ROLL
	POPJ	P,

CLOB:	MOVEI	T1,COMTOP	;ROUTINE TO CLOBBER ALL MOVEABLE ROLLS
	MOVEM	T,FLOOR(T1)		;T CONTAINS CLOBBER VALUE.
	MOVEM	T,CEIL(T1)
	CAILE	T1,1(X1)	;DO NOT CLOBBER ROLLS <=(X1)
	SOJA	T1,.-3
	POPJ	P,



OPEN2:	MOVE	X2,E		;IS THERE ROOM ABOVE THIS STODGY ROLL?
	ADD	X2,CEIL(R)	;THE NEW CEILING
	CAMLE	X2,FLOOR+1(R)
	JRST	OPENU0		;NO ROOM, PACK OTHER ROLLS UP
	ADDM	E,CEIL(R)	;THERE IS ROOM, INCREMENT CEILING
	POPJ	P,

OPENU0:	SUB	B,FLOOR(R)
	PUSHJ	P,PANIC
	ADD	B,FLOOR(R)

OPENUP:	CAMG	R,TOPSTG		;OPEN UP THE TOP STODGY ROLL?
	JRST	OPEN2		;YES. OPEN UPWARDS, NOT DOWN
	MOVN	X2,E
	MOVE	X1,TOPSTG	;DO NOT MOVE STODGY ROLLS
	ADD	X2,FLOOR+1(X1)
	CAMGE	X2,CEIL+0(X1)
	JRST	OPENU0		;NEED MORE ROOM
	HRL	X2,FLOOR+1(X1)	;CONSTRUCT BLT WORD
	SUB	B,E		;FIRST WORD OF GAP
	BLT	X2,-1(B)	;MOVE ROLLS DOWN

	MOVEI	X1,1(X1)		;ADJUST POINTERS FOR ROLLS JUST BLT'D.
	MOVN	X2,E
OPEN1:	ADDM	X2,FLOOR(X1)
	CAML	X1,R
	POPJ	P,
	ADDM	X2,CEIL(X1)
	AOJA	X1,OPEN1


;RPUSH - PUSH A ON TOP OF DESIGNATED ROLL

RPUSH:	MOVEI	E,1
	PUSHJ	P,BUMPRL	;MAKE ROOM
	MOVEM	A,(B)		;STORE WORD
	POPJ	P,

;ROUTINE TO ADD TO END OF ROLL
;E CONTAINS SIZE, R CONTAINS ROLL NUMBER

BUMPRL:	MOVE	B,CEIL(R)
	ADD	B,E
	CAIE	R,ROLTOP
	SKIPA	X1,FLOOR+1(R)
	HRRZ	X1,JOBREL
	CAMLE	B,X1
	JRST	BUMP1
	EXCH	B,CEIL(R)
	POPJ	P,

BUMP1:	MOVE	B,CEIL(R)
	CAIE	R,CODROL
	CAIN	R,SEXROL
	JRST	.+2
	JRST	OPENUP
	ADDI	E,^D10		;***EXTRA 10 LOCS
	PUSHJ	P,OPENUP
	MOVNI	X1,^D10	;TAKE BACK THE 10 LOCS
	ADDM	X1,CEIL(R)
	POPJ	P,


;BINARY SEARCH OF SORTED ROLL
;CALL WITH KEY IN A
;RETURN IN B ADDRS OF FIRST
;ENTRY NOT LESS THAN KEY
;SKIP RETURN IF LEFT SIDES EQUAL

SEARCH:	MOVE	B,FLOOR(R)
	SKIPA	X1,CEIL(R)
SEAR1:	MOVEI	B,1(X2)
	CAIGE	B,(X1)
	JRST	SEAR2
	CAML	B,CEIL(R)
	POPJ	P,
	JRST	SEAR3

SEAR2:	MOVEI	X2,@X1
	ADD	X2,B
	ASH	X2,-1
	CAMLE	A,(X2)
	JRST	SEAR1
	HRRI	X1,0(X2)
	CAIGE	B,(X1)
	JRST	SEAR2

SEAR3:	HLLZ	X2,(B)
	CAMN	X2,A
	AOS	(P)
	POPJ	P,
;ROUTINE TO QSA FOR "THEN" OR "GOTO" (USED IN "IF", "ON" STATEMENTS)
THENGO:	PUSHJ	P,QSA
	ASCIZ /THEN/
	CAIA
	POPJ	P,
	PUSHJ	P,QSA
	ASCIZ /GOTO/
	FAIL <ILLEGAL FORMAT>
	POPJ	P,

;COMMON SUBROUTINE RETURNS

CPOPJ1:	AOS	(P)
CPOPJ:	POPJ	P,

;ERROR RETURNS

ILFORM:	FAIL	<ILLEGAL FORMULA>
ILVAR:	FAIL	<ILLEGAL VARIABLE>
GRONK:	FAIL	<ILLEGAL FORMAT>
ILLINS:	FAIL	<ILLEGAL INSTRUCTION>


;COMPILATION ERROR


FAILER:	SKIPN	RUNFLA		;IS THIS THE FIRST ERROR IN COMPILATION?
	JRST	FAIL0		;NO.
	PUSHJ	P,INLMES	;YES. SETUP <CRLF> TO FOLLOW HEADING.
	ASCIZ /
/
FAIL0:	PUSHJ	P,FAIL1
	JRST	NXTST1

FAIL1:	MOVE	T,40
FAILR:	MOVEI	D,0
	PUSHJ	P,PRINT
	LDB	X1,[POINT 4,40,12]	;IS AC FIELD NONZERO?
	JUMPE	X1,FAIL2		;NO.
	MOVE	T,N			;YES, ATTACH NUMBER IN 'N' TO MSG
	PUSHJ	P,PRTNUM
FAIL2:	PUSHJ	P,INLMES
	ASCIZ / IN /
	MOVE	T,L
	ADD	T,FLLIN
	HLRZ	T,(T)
	PUSHJ	P,PRTNUM
	PUSHJ	P,INLMES
	ASCIZ	/
/
	SETZM	RUNFLA
	POPJ	P,

;ROUTINES TO ALLOW AND DELAY REENTRY.
;LOCKON TEMPORARILY PREVENTS REENTRY
;LOCKOF ALLOWS REENTRY AND REENTERS IF THERE IS A STANDING REQUEST
;REENTR MAKES A REENTRY OR MAKES A REQUEST AND CONTINUES
LOCKON:	SKIPGE	RENFLA
	SETZM	RENFLA		;TURN ON REENTER PROTECT
	POPJ	P,

LOCKOF:	SKIPLE	RENFLA
	JRST	BASIC		;ACT ON OLD REENTER REQUEST
	SETOM	RENFLA		;ALLOW REENTER
	POPJ	P,

REENTR:	SKIPGE	RENFLA
	JRST	BASIC		;REENTER IF ALLOWED
	AOS	RENFLA		;MAKE REQUEST BY SETTING FLAG PLUS
	JRST	2,@JOBOPC
;ROUTINE TO READ CHARACTER, SKIPPING BLANKS
;CALL:	MOVE	T,<POINTER TO CHAR BEFORE FIRST>
;	PUSHJ	P,NXCH
;	...	RETURN, C:= (<FLAGS>)CHARACTER

NXCHS:	ILDB	C,T		;DOESNT SKIP TAB OR BLANK
	CAIE	C," "
	CAIN	C,11
	POPJ	P,
	CAIA			;SKIP INTO NXCH

NXCH:	ILDB 	C,T		;FETCH NEXT CHARACTER
	HLL	C,CTTAB(C)	;GET FLAGS FROM CTTAB
	TRNE	C,100
	HRL	C,CTTAB-100(C)
	TLNE	C,F.SPTB	;SPACE OR TAB?
	JRST	NXCH		;YES. IGNORE
	POPJ	P,

NXCHD:	ILDB	C,T
NXCHD2:	HLL	C,CTTAB(C)
	TRNE	C,100
	HRL	C,CTTAB-100(C)
	POPJ	P,

;GET NEXT CHAR, BUT CHECK FOR ILLEGAL CHARS (CHARS THAT COULD ONLY BE IN A STRING)
NXCHK:	PUSHJ	P,NXCH
	TLNE	C,F.STR
	FAIL	<ILLEGAL CHARACTER>
	POPJ	P,

;SCAN INITIAL LETTER, LETTER IS PLACED LEFT
;JUSTIFIED IN A, 7-BIT ASCII.

SCNLT1:	HRRZ	A,C
	ROT	A,-7
	JRST	NXCH

;SCAN SECOND LETTER, NON-SKIP RETURN IF NOT LETTER.
;MAKE 7-BIT LETTER LEFT JUST IN A
;INTO 6-BIT. THAN PUT 6-BIT CURRENT LETTER IN A.

SCNLT2:	TLNN	C,F.LETT
	POPJ	P,
SCN2:	TLNN	A,400000	;ENTER HERE TO PROCESS NON-LETTER CHARS
	TLZA	A,200000
	TLO	A,200000
	LSH	A,1
	MOVE	X1,[POINT 6,A,5]
	JRST	SCNLTN	

;ENTER HERE TO SCAN SECOND CHAR EVEN IF BOTH ARE NOT LETTERS.


;SCAN THIRD LETTER, NON-SKIP IF NOT LETTER.
;PUT 6-BIT LETTER TO 3RD 6-BIT FIELD IN A.

SCNLT3:	TLNN	C,F.LETT
	POPJ	P,
SCN3:	MOVE	X1,[POINT 6,A,11]

;NOW PUT 6-BIT LETTER INTO A, ADJUSTING LOWER CASE, INCREMENTING POINTER.

SCNLTN:	TLNN	C,F.LCAS
	TRC	C,40
	IDPB	C,X1
	AOS	(P)
	JRST	NXCH


;THIS ROUTINE IS USED AT RUNTIME BY THE READ# STATEMENTS.
;DELAWY SKIPS THROUGH DELIMITERS AND STOPS ON THE FIRST
;NON-TAB, NON-SPACE, NON-COMMA.

DELAWY:	LDB	C,T
	PUSHJ	P,NXCHD2
	TLNN	C,F.COMA+F.SPTB
	POPJ	P,
	PUSHJ	P,NXCH
	JRST	.-3


;QUOTE SCAN AND TEST
;CALL WITH PATTERN ADDRS IN X1
;SKIP IF EQUAL.	C,T UPDATED TO LAST CHAR SCANNED.
QST:	HRLI	X1,440700	;MAKE BYTE PNTR TO PATTERN
QST1:	ILDB	X2,X1		;GET PATTERN CHAR
	JUMPE	X2,CPOPJ1	;DONE ON NULL
	SUBI	X2,(C)
	JUMPE	X2,.+4		;DO CHARACTERS MATCH?
	TLNE	C,F.LCAS	;NO. LOWER CASE LETTER?
	CAME	X2,[ EXP -40]	;YES. SAME LETTER OF ALPHABET?
	JRST	QST2		;NO. MATCH FAILS
	PUSHJ	P,NXCH
	JRST	QST1
QST2:	ILDB	X2,X1		;ON FAIL
	JUMPN	X2,.-1		;SKIP TO NULL
	POPJ	P,


;QUOTE SCAN OR FAIL
;CALL WITH INLINE PATTERN
;GO TO GRONK IF NO MATCH

QSF:	POP	P,X1
	PUSHJ	P,QST
	JRST	GRONK
	JRST	1(X1)


;QUOTE SCAN WITH ANSWER
;CALL WITH INLINE PATTERN
;SKIP ON SUCCESS		;ON FAIL, RETURN WITH C,T RESTORED

QSA:	POP	P,X1		;GET PATTERN ADDRESS
	PUSH	P,C		;SAVE C,T
	PUSH	P,T
	PUSHJ	P,QST		;SAVE STRING
	JRST 	.+2
	JRST	QSA1		;MATCH
	POP	P,T		;NO MATCH.  BACK UP
	POP	P,C
	JRST	1(X1)

QSA1:	POP	P,X2
	POP	P,X2
	JRST	2(X1)

;ROUTINE TO READ NEXT INTEGER FROM SCANNED LINE
;CALL:	MOVE	T,POINTER TO FIRST CHAR
;	PUSHJ	P,GETNUM
;	...	FAIL RETURN
;	...	SUCCESS RETURN, INTEGER IN N

GETNU:	TDZA	X1,X1		;GET A NUMBER OF ANY LENGTH.
GETNUM:	MOVEI	X1,5		;GET A NUMBER OF AT MOST 5 DIGS
	TLNN	C,F.DIG		;NUMERAL?
	POPJ	P,		;NO.  FAIL RETURN
	MOVEI	N,-60(C)	;YES.  ACCUMULATE FIRST DIGIT
GETN1:	MOVE	G,T		;SAVE PNTR FOR USE BY INSERT
	PUSHJ	P,NXCH		;GET NEXT CHAR
	SOJE	X1,CPOPJ1	;EXIT IF FIVE DIGITS ALREADY
	TLNN	C,F.DIG		;NUMERAL?
	JRST	CPOPJ1		;NO.  RETURN.
	IMULI	N,^D10		;YES.  ACCUMULATE NUMBER
	ADDI	N,-60(C)
	JRST	GETN1		;GO FOR MORE
	EXTERN	STODSK
;ROUTINE TO READ A LINE INTO LINB0
;CALL:	PUSHJ	P,INLINE

INLINE:	PUSH	P,X1
	SETZB	X1,T1
	SKIPE	IFIFG
	SKIPA	T,LINPT(LP)
	MOVE	T,LINPT
	JRST	INLI1A


INLI1:	ILDB	C,TYI+1		;GET CHAR
	JRST	INLB
INLA:	SOSGE	@INCNT-1(LP)
	JRST	DSKIN
	ILDB	C,@INPT-1(LP)
INLB:	CAIE	C,15		;CR??
	CAIN	C,0
	SOJA	T1,INLI1A
	CAIN	C,"_"		;DELETE?
	JRST	INLI3		;YES
	CAIE	C,30		;<CONTROL-X>?
	CAIN	C,175		;ALTMODE?
	JRST	INLI4		;YES.  IGNORE LINE
	CAIE	C,21	;IGNORE XON,XOFF
	CAIN	C,23
	SOJA	T1,INLI1A
	CAIG	C,14		;LINE TERMINATOR?
	CAIGE	C,12
	CAIA
	JRST	INLI2		;YES.  GO FINISH UP
	CAIGE	T1,^D94		;ROOM FOR CHAR+1 MORE? (5*23-1)
	JRST	INLB1		;YES.
	SKIPN	IFIFG		;DISK?
	JRST	INLI1A		;NO, FORGET REST OF LINE.
	JRST	INERR		;YES, ERROR EXIT.
INLB1:	IDPB	C,T		;STORE CHAR
INLI1A:	SKIPE	IFIFG
	AOJA	T1,INLA
	SOSLE	TYI+2		;MORE INPUT?
	AOJA	T1,INLI1	;YES.  BUMP COUNT AND GO GET MORE
	INPUT
	STATZ	20000
	JRST	BASIC
	STATO	740000
	AOJA	T1,INLI1
INLSYS:	PUSHJ	P,TTYIN
	PUSHJ	P,INLMES
	ASCIZ /SYSTEM ERROR/
	JRST	UXIT

INLI2:	MOVEI	C,15		;DONE.  PUT CR IN BFR.
	IDPB	C,T
	POP	P,X1
RESCAN:	SKIPN	IFIFG
	SKIPA	T,LINPT
	MOVE	T,LINPT(LP)
	SKIPE	IFIFG
	JRST	INLI8
	SETZM	HPOS		;CARRIAGE POSITION := LFT MRGN
	JRST	NXCH		;GET FIRST CHAR AND RETURN
INLI8:	SETZM	HPOS(LP)
	JRST	NXCH

INLI3:	SOJE	T1,INLI1A	;BACKARROW HANDLER, IGNORE IF AT LEFT
	MOVEI	C,4
	IBP	T		;BACK UP BYTE POINTER A LA JHB
	SOJG	C,.-1
	SUBI	T1,1
	SOJA	T,INLI1A

INLI4:	MOVEI	T,DELMSG	;ACKNOWLEDGE ALTMODE
	CALL	T,[SIXBIT /DDTOUT/]

	POP	P,X1
	JRST	INLINE

DELMSG:	ASCIZ	/ DELETED
/

;ROUTINE TO START READING NEXT LINE OF PROGRAM
NXLINE:	MOVE	T,FLLIN
	ADDI	T,(L)
	MOVE	T,(T)
	MOVS	D,T		;SAVE LINE START
        HRRZM   D,THELIN
	HRLI	T,440700
	MOVE	G,FLREF	;SETUP REFROL REFERENCE.
	ADDI	G,(L)
	JRST	NXCH


DSKIN:  DPB     LP,[POINT 4,INDSK,12] ;DISK INPUT
	XCT	INDSK
	DPB	LP,[POINT 4,STADSK,12]
	XCT	STADSK
	JRST	EOFFAL
	DPB	LP,[POINT 4,STODSK,12]
	XCT	STODSK
	JRST	INLA
	JRST	INLSYS
	EXTERN	INDSK
	EXTERN	THELIN
;PRINTING SUBROUTINES

;PRINT TO QUOTE CHAR
;CALL:	MOVE	T,<ADDRS OF MSG>
;	MOVE	D,<QUOTE CHAR>
;	PUSHJ	P,PRINT
;CALL:	MOVE	T,<ADDRS OF MSG>
;	MOVE	D,<QUOTE CHAR>
;	PUSHJ	P,PRINT
;ALTERNATE CALL: PRINT1, IF BYTE PNTR IN T.


PRINT:	HRLI	T,440700
PRINT1:	ILDB	C,T
	CAMN	C,D
	POPJ	P,
	PUSHJ	P,OUCH		;OUTPUT THE CHAR
	JRST	PRINT1


OUCH:	SKIPE	ODF		;DISK?
	JRST	DSKOT		;YES.
	SKIPG	TYO+2		;NO.
	OUTPUT
	SOS	TYO+2
	IDPB	C,TYO+1
	CAIE	C,12
	AOSA	HPOS
	SETZM	HPOS
	POPJ	P,
DSKOT:	SKIPG	@OUTCNT-1(LP)
	JRST	DOS
	SOS	@OUTCNT-1(LP)
	IDPB	C,@OUTPT-1(LP)
	CAIE	C,12
	AOSA	HPOS(LP)
	SETZM	HPOS(LP)
	POPJ	P,
DOS:	DPB	LP,[POINT 4,OUTDSK,12]
	XCT	OUTDSK
	JRST	DSKOT

;ROUTINE TO PRINT SIXBIT CHARACTERS IN ACCUM "T".
;IGNORES BLANKS.


PRNSIX:	MOVE	T1,[POINT 6,T]
	ILDB	C,T1
	JUMPE	C,PRNS1		;SKIP A BLANK
	ADDI	C,40
	PUSHJ	P,OUCH
PRNS1:	TLNE	T1,770000		;ALL SIX PRINTED?
	JRST	PRNSIX+1
	POPJ	P,
;SPECIAL DECIMAL PRINT ROUTINE.  PRINTS X1,X2 AS DECIMAL NUMBERS
;SEPARATED BY THE CHARACTER IN ACCUM "A".
;IF X1 OR X2 ARE ZERO, THEY PRINT AS "00".

PRDE2:	MOVE	T,X1
	PUSHJ	P,PRDE1
	MOVE	C,A
PRDE2A:	PUSHJ	P,OUCH
	MOVE	T,X2
	MOVEI	A,177
PRDE1:	MOVEI	C,"0"		;A ONE DIGIT NUMBER?
	CAIG	T,^D9
	PUSHJ	P,OUCH		;YES. PUT OUT LEADING ZERO.
	JRST	PRTNUM

;SPECIAL RUNTIME PRINTER
RTIME:	PUSHJ	P,INLMES
	ASCIZ /

TIME:  /
	SETZM	X1		;SET UP AC FOR CALLI.
	CALLI	X1,27		;GET TIME NOW.
	SUB	X1,MTIME	;GET ELAPSED TIME.
	IDIVI	X1,^D10		;REMOVE THOUSANDTHS.
	IDIVI	X1,^D100	;SECS TO X1, TENTHS AND HUNDREDS TO X2.
	MOVE	T,X1		;OUTPUT THE
	PUSHJ	P,PRTNUM	;SECONDS.
	MOVEI	C,"."		;OUTPUT ., THE TENTHS,
	PUSHJ	P,PRDE2A	;AND THE HUNDREDTHS. 
	PUSHJ	P,INLMES
	ASCIZ	/ SECS.
/
	SETZM	MTIME
	OUTPUT
	POPJ	P,

;NUMBER PRINTER (PRINTS INTEGER IN T)


PRTNUX:	TDZA	X1,X1		;CHECK WHETHER ROOM FOR ZERO BEFORE PRINT.
PRTNX1:	MOVE	X1,B		;CHECK ROOM FOR INT. OF THIS SIZE " "
	MOVEI	X1,5(X1)
	PUSHJ	P,CHROOM
PRTNX2:	PUSHJ	P,PSIGN

PRTNUM:	IDIVI	T,^D10
	JUMPE	T,PRTN1
	PUSH	P,T1
	PUSHJ	P,PRTNUM
	POP	P,T1
PRTN1:	MOVEI	C,60(T1)
	AOS	NUMCOT
	JRST	OUCH




PSIGN:	MOVEI	C," "		;PRINT "SIGN" (BLANK OR MINUS)
	JUMPGE	N,.+2
	MOVEI	C,"-"
	SKIPN	ODF
	JRST	OUCH
	CAIN	C," "
	POPJ	P,
	JRST	OUCH


;MESSAGE PRINTER

INLMES:	EXCH	T,(P)	;GET MSG ADR AND SAVE T.
	MOVEI	D,0		;END ON NULL
	PUSHJ	P,PRINT		;PRINT THE MESSAGE
	EXCH	T,(P)
	JRST	CPOPJ1	;RTN AFTER MSG.
	SUBTTL CORE COMPRESSION AND EXPANSION
;PANIC - ROUTINE TO COMPRESS CORE

PANIC:	PUSHJ	P,PRESS		;COMPRESS MEMORY
	MOVE	X2,TOPSTG	;IS THERE ROOM BETWEEN STODGY AND
	MOVE	X1,FLOOR+1(X2)	;MOVEABLE ONES?
	SUB	X1,CEIL(X2)
	CAML	X1,E		;ENOUGH ROOM?
	POPJ	P,

	MOVE	X1,JOBREL	;EXPAND BY 1K
	ADDI	X1,2000
	CALL	X1,[SIXBIT /CORE/]
	JRST	.+2		;CANT
	JRST	PANIC		;OK.  GO MOVE ROLLS

PANIC1:	PUSHJ	P,TTYIN
	PUSHJ	P,INLMES
	ASCIZ	/OUT OF ROOM/
	JRST	UXIT


PRESS:	PUSH	P,G		;SAVE AC
	PUSH	P,A
	SKIPN	PAKFLA		;ARE LINES PACKED?
	JRST	PRESS5		;YES
	SETZM	PAKFLA

PRESS1:	MOVE	X1,FLTXT	;LOOK FOR EMPTY SPACE
PRESS2:	CAML	X1,CETXT		;TRHOUGH LOOKING?
	JRST	PRESS5
	SKIPE	(X1)		;A FREE WORD?
	AOJA	X1,PRESS2	;NO

	MOVEI	X2,1(X1)	;YES
PRESS3:	CAML	X2,CETXT
	JRST	PRESS4		;FREE TO END
	SKIPN	(X2)
	AOJA	X2,PRESS3	;LOOK FOR NON-FREE WORD

	SUB	X1,X2		;X1 :=-LNG OF MOVE
	MOVE	A,FLLIN
PRES3A:	CAML	A,CELIN	
	JRST	PRES3B
	HRRZ	G,(A)
	CAML	G,X2
	ADDM	X1,(A)
	AOJA	A,PRES3A

PRES3B:	MOVE	G,CETXT
	ADD	G,X1
	MOVEM	G,CETXT
	ADD	X1,X2
	HRL	X2,X1
	MOVSS	X2
	BLT	X2,-1(G)
	JRST	PRESS2

PRESS4:	MOVE	A,X1	;KLUDGE IF FREE TO END--MOVE IT ABOVE
	SUB	A,X1
	ADDM	A,CETXT
;ROUTINE TO MOVE ROLLS UP

PRESS5:	MOVEI	G,ROLTOP	;HIGHEST MOVABLE ROLL
	MOVE	X1,JOBREL	;X1 IS PREVIOUS FLOOR
				;NOTE: TOP WORD OF USR CORE IS LOST

PRESS6:	MOVE	X2,CEIL(G)	;GET OLD CEIL AND FLOOR
	MOVE	A,FLOOR(G)
	SUBI	X2,1		;SET UP X2 FOR POP LOOP
	ORCMI	X2,777777
	MOVEM	X1,CEIL(G)	;NEW CEILING

PRESS7:	CAILE	A,(X2)		;DONE?
	JRST	PRESS8
	POP	X2,-1(X1)	;MOVE ONE WORD
	SOJA	X1,PRESS7

PRESS8:	MOVEM	X1,FLOOR(G)	;NEW FLOOR
	SOS	G		;GO TO NEXT LOWER ROLL
	CAMLE	G,TOPSTG	;IS THIS ROLL MOVEABLE?
	JRST	PRESS6		;YES. GO PRESS IT.
PRESS9:	POP	P,A
	POP	P,G	;RESTORE G
	POPJ	P,	;RETURN
;SPACE CHECK, PANIC AND PRESS FOR VARIABLE SPACE, WHICH
;RANGES FROM (VARBOT) TO (JOBREL).  NEXT AVAILABLE WORD IS
;(VARFRE). THE MAXIMUM LENGTH ALLOWED FOR A LITERAL OR
;INPUT STRING IS

LITLEN=^D21

;IN WORDS.

VCHECK:	MOVEI	E,LITLEN	;CALCULATE WORD LENGTH. ASSUME LITLEN
	SKIPGE	G		;STRING LITERAL?
	PUSHJ	P,MCHPWD	;NO. CHANGE MINUS CHARS TO PLUS WORDS
VCHE1:	MOVE	X1,VARFRE	;IS THERE ROOM FOR A STRING OF WORD LENGTH (E)?
	ADD	X1,E
	CAMGE	X1,JOBREL
	POPJ	P,		;YES.

VPANIC:	SKIPE	VPAKFL		;CAN WE MAKE ROOM WITH A GARBAGE COLLECTION?
	JRST	.+3		;NO, ASK FOR CORE
	PUSHJ	P,VPRESS	;POSSIBLY.
	JRST	VCHE1		;TRY AGAIN

	MOVE	X1,JOBREL	;CALL FOR MORE CORE.
	ADDI	X1,2000
	CALL	X1,[SIXBIT /CORE/]
	JRST	PANIC1		;CANT GET CORE
	JRST	VCHE1

;THE ROLL VSPROL CONTAINS POINTERS INTO VARIABLE SPACE.  EACH ENTRY
;CONTAINS	0   [NO SPACE ASSIGNED]
;		XWD -(LENGTH IN CHARS),ADDRESS FIRST WORD

VPRESS:	PUSH	P,G
	PUSH	P,C
IFN FTSTR,<
	PUSH	P,E
	PUSH	P,A
	MOVE	G,VARBOT

VPR0:	HRRZI	X2,-1		;THE LOWEST ADDRESS WILL GO INTO X1
	MOVE	A,FLVSP		;A POINTS TO EACH ENTRY ON THE ROLL.
	SETZI	X1,		;X1 WILL GET THE LOC OF NEXT LOWEST POINTER

VPR1:	CAML	A,SVRTOP
	JRST	VPR2		;SEARCH FOR MINIMUM IS OVER.
	CAMN	A,CEVSP		;STARTING TO SCAN VSPROL?
	MOVE	A,SVRBOT	;YES. NOW SCAN STRING VECTOR SPACE.
	HRRZ	E,(A)		;GET POINTER ADDRESS.
	JUMPE	E,VPR11		;NULL POINTER?
	CAML	E,G		;HAVE WE MOVED THIS STRING ALREADY?
	CAMG	X2,E		;NO, IS IT A LOWER STRING ADDRESS?
VPR11:	AOJA	A,VPR1		;NO. LOOK AT NEXT STRING.

	MOVE	X1,A		;WE HAVE FOUND A STRING WITH LOWER ADDRESS.
	MOVE	X2,E
	AOJA	A,VPR1

VPR2:	JUMPE	X1,VPR3		;ANY MORE STRINGS TO MOVE?
	HLRE	E,(X1)		;CALCULATE WORD LENGTH..
	JUMPN	E,.+3		;IS THIS A NULL STRING?
	SETZM	(X1)		;YES. IGNORE IT.
	JRST	VPR0

	HRL	G,(X1)		;GET THE OLD ADDRESS OF THIS STRING
	MOVN	C,E		;GET WORD LENGTH
	CAIL	C,1000		;****PATCH FOR NULL STRINGS
	MOVEI	C,1
	ADDI	C,4
	IDIVI	C,5
	MOVE	E,C
	ADDI	E,-1(G)
	HRRZ	X2,(X1)		;GET THE OLD STRING ADDRESS
	CAIN	X2,(F)		;IS THIS THE STRING WE ARE NOW MOVING?
	HRRM	G,F		;YES, UPDATE OUR CURRENT POINTER
	HRRM	G,(X1)		;STORE THE NEW ADDRESS
	BLT	G,(E)	;MOVE THE STRING DOWN
	AOS	G,E		;LOOK FOR A HIGHER ADDRESS NEXT TIME
	MOVEM	E,VARFRE
	JRST	VPR0

VPR3:	POP	P,A
	POP	P,E
>;ASSEMBLE IF INCLUDING STRING FACILITY
	POP	P,C
	SETOM	VPAKFL		;STRINGS ARE TIGHTLY PACKED
	JRST	PRESS9		;POP G AND EXIT
SUBTTL DECIMAL NUMBER EVALUATE/PRINT
;ROUTINE TO EVALUATE NUMBER
;T: PNTR TO FIRST CHAR, C: FIRST CHAR
;NON-SKIP IS FAIL RETURN
;RETURN NUMBER IN N

;N: ACCUM NBMR, B: SCA FAC, D: DIG CNT, USE FLGS IN LEFT OF F

EVANUM:	SETZB	N,B		;CLEAR ACS
	MOVEI	D,8
	MOVEI	F,(F)		;CLEAR LH OF F

	TLNE	C,F.PLUS	;SKIP +
	JRST	EVAN1
	TLNN	C,F.MINS	;CHECK FOR -
	JRST	EVAN2		;NO
	TLO	F,F.MIN		;SET MINUS FLG
EVAN1:	SKIPN	IFIFG
	JRST	EV1
	PUSHJ	P,NXCHD
	JRST	.+2
EV1:	PUSHJ	P,NXCH
EVAN2:	TLNN	C,F.DIG		;DIGIT?
	JRST	EVAN3		;NO

	TLO	F,F.NUM		;DIGIT SEEN FLAG
	JUMPE	N,EVAN2A	;DONT COUNT LEADING ZEROS
	SOJG	D,EVAN2A	;COUNT DIGIT,  GO ACCUM IF OK
;			REST OF DIGITS ARE INSIGNIFIGANT.
	AOJA	B,EVAN2B	;LEAD OR TRAIL 0, FUDGE SCA FAC

EVAN2A:	IMULI	N,^D10		;ACCUMULATE DIGIT
	ADDI	N,-60(C)
EVAN2B:	TLNE	F,F.DOT		;DECIMAL SEEN?
	SUBI	B,1		;YES.  COUNT DOWN SCALE FACT
	JRST	EVAN1		;GO TO NEXT CHAR

EVAN3:	TLNN	C,F.PER		;NOT DIGIT.  DEC PNT?
	JRST	EVAN4		;NO.
	TLOE	F,F.DOT		;YES, SET FLG & CHK ONLY ONE
	POPJ	P,		;2 DEC PNTS
	JRST	EVAN1
EVAN4:	TLNN	F,F.NUM		;DID WE SEE A DIGIT?
	POPJ	P,		;NO.  WHAT A LOUSY NUMBER

	MOVEI	X1,"E"
	CAIE	X1,(C)		;EXPLICIT SCALE FACTOR?
	JRST	EVAN8		;NO
	SKIPN	IFIFG
	JRST	EV2
	PUSHJ	P,NXCHD
	JRST	.+2
EV2:	PUSHJ	P,NXCH		;DO LOOK AHEAD
	TLNE	C,F.PLUS	;SCALE FACTOR SIGN
	JRST	EVAN5
	TLNN	C,F.MINS
	JRST	EVAN6
	TLO	F,F.MXP
EVAN5:	SKIPN	IFIFG
	JRST	EV3
	PUSHJ	P,NXCHD
	JRST	.+2
EV3:	PUSHJ	P,NXCH
EVAN6:	TLNN	C,F.DIG		;CHK FOR DIGIT
	POPJ	P,
	MOVEI	A,-60(C)	;SAVE FIRST EXPON DIGIT
	SKIPN	IFIFG
	JRST	EV4
	PUSHJ	P,NXCHD
	JRST	.+2
EV4:	PUSHJ	P,NXCH
	TLNN	C,F.DIG		;IS THERE A SECOND DIGIT
	JRST	EVAN7		;NO
	IMULI	A,^D10		;YES.  ACCUMULATE IT
	ADDI	A,-60(C)
	SKIPN	IFIFG
	JRST	EV5
	PUSHJ	P,NXCHD
	JRST	.+2
EV5:	PUSHJ	P,NXCH		;DO LOOK AHEAD

EVAN7:	TLNE	F,F.MXP		;NEG EXPON?
	MOVN	A,A		;YES.  NEGATE IT
	ADD	B,A		;ADD TO SCALE FACTOR
EVAN8:	JUMPE	N,CPOPJ1	;IGNORE SCALE IF NUMBER IS 0
EVAN8A:	MOVE	X1,N		;)
	IDIVI	X1,^D10		;)REMOVE ANY TRAILING ZEROS
	JUMPN	X2,EVAN8B	;)  IN MANTISSA.  (REASON:
	MOVE	N,X1		;)  SO THAT, E.G., .1,
	AOJA	B,EVAN8A	;)  .10, .100, ..., ARE THE SAME)
EVAN8B:	TLO	N,233000	;FLOAT N
	FAD	N,[0]
	SETZM	LIBFLG		;CLEAR OVER/UNDERFLOW FLAG.
EVAN8C:	CAIGE	B,^D15		;SCALE UP IF .GE. 10^15
	JRST	EVAN8D
	SUBI	B,^D14		;SUBTRACT 14 FROM SCALE FACTOR
	FMPR	N,D1E14		;MULTIPLY BY 10^14
	JRST	EVAN8C		;GO LOOK AT SCALE AGAIN
EVAN8D:	CAML	B,[EXP -^D4]	;SCALE DOWN IF .LT. 10^-4
	JRST	EVAN8E
	ADDI	B,^D18		;ADD 18 TO SCALE
	FMPR	N,D1EM18	;MULTIPLY BY 10^-18
	JRST	EVAN8D		;GO LOOK AT SCALE AGAIN
EVAN8E:	FMPR	N,DECTAB(B)	;SCALE N
	TLNE	F,F.MIN		;MINUS?
	MOVN	N,N		;YES.  NEGATE IT
	SKIPE	LIBFLG		;SKIP IF NO OVER/UNDERFLOW.
	JRST	CPOPJ
	JRST	CPOPJ1		;SUCCESS RETURN, NUMBER IN N
;ROUTINE TO PRINT NUMBER

OUTNUM:	SKIPN	ODF
	SETOM	NUMFLA		;A NUMBER IS BEING TYPED OUT
	MOVM	T,N
	JUMPN	T,OUTN1E
	SKIPN	ODF
	JRST	PRTNUX
	MOVEI	C," "
	PUSHJ	P,OUCH
	JRST	PRTNX2
OUTN1E:	PUSH	P,E		;DO NOT CLOBBER E (FOR MATRX)
	MOVEI	E,0		;CHANGE IN EXPONENT
OUTN1A:	CAMG	T,D1E14		;SCALE IF .GT. 10^14
	JRST	OUTN1B
	ADDI	E,^D18		;ADD 18 TO SCALE
	FMPR	T,D1EM18	;AND MULTIPLY BY 10^-18
	JRST	OUTN1A
OUTN1B:	CAML	T,D1EM4		;SCALE IF .LT. 10^-4
	JRST	OUTN1C
	SUBI	E,^D14		;SUBTRACT 14 FROM SCALE
	FMPR	T,D1E14		;AND MULT BY 10^14
	JRST	OUTN1B		;GO SEE IF MORE SCALING
OUTN1C:	MOVE	A,T		;LOOK UP IN DEC ROLL
	MOVEI	R,DECROL
	PUSHJ	P,SEARCH
	JFCL			;DONT CARE IF FOUND
	CAME	A,(B)		;FUDGE BY 1 IF EXACT MATCH
	SUBI	B,1
	SUBI	B,DECTAB	;FIND DIST FROM MIDDLE
	JUMPN	E,OUTN2		;(NOT INTEGER IF WE SCALED)
	CAIGE	B,^D8		;CHK 8 DIG INTEGER
	CAIGE	B,0
	JRST	OUTN2
	CAML	T,FIXCON	;IS THIS 2^26?
	JRST	OUTN1D		;YES, ITS 27 BIT INT.
	MOVE	X1,T
	FAD	X1,FIXCON	;INTEGER?
	FSB	X1,FIXCON
	CAME	X1,T
	JRST	OUTN2		;NOT SUCH (LOST FRACTIONAL PART)
	FAD	T,FIXCON	;SUCH.  FIX NUMBER
	TLZ	T,377400
OUTN1D:	TLZ	T,377000	;(IN CASE 27-BIT INTEGER)
	POP	P,E		;RESTORE E
	SKIPN	ODF
	JRST	PRTNX1
	MOVEI	C," "
	PUSHJ	P,OUCH
	SETZM	NUMCOT
	JRST	PRTNX2

OUTN2:	SETZM	EXTFG
	FDVR	T,DECTAB(B)	;GET MANTISSA
	FMPR	T,DECTAB+5
	TRNN	T,7
	SETOM	EXTFG
	FADR	T,FIXCON
	TLZ	T,377400	;FIX
	CAMGE	T,[EXP ^D1000000]
	JRST	.+3
	IDIVI	T,^D10		;ROUNDING MADE 7 DIGITS
	ADDI	B,1		;MAKE IT 6 AGAIN
	CAIL	T,^D100000	;ROUNDING MADE 5 DIGITS?
	JRST	.+3
	IMULI	T,^D10		;YES.  MAKE 6 AGAIN
	SUBI	B,1
	ADDB	B,E		;ADD TOGETHER TWO PARTS OF SCALE
	AOJ	E,
	CAILE	E,6
	SETZM	EXTFG
	CAMG	E,[OCT -7]
	SETZM	EXTFG
	SKIPN	EXTFG
	JUMPL	E,.+2		;BETWEEN 10^-1 AND 10^6?
	CAILE	E,6
	SKIPA	E,[EXP 1]		;NO. PRINT 1 DIG BEFORE POINT
	PUSHJ	P,CHKNEF	;PRINT WITHOUT EXP (CHK ROOM FOR ^8 SP)
	PUSHJ	P,CHKEF		;PRINT WITH EXP (CHK ROOM FOR ^14 SP)
	SKIPN	ODF
	JRST	.+3
	MOVEI	C," "
	PUSHJ	P,OUCH
	PUSHJ	P,PSIGN		;PRINT "SIGN"
	SKIPN	EXTFG
	JUMPN	E,OUTN3		;SHOULD DEC. POINT PRECEDE NUMBER?
	MOVEI	C,"0"		;YES,SEND OUT LEADING ZERO.
	PUSHJ	P,OUCH
	PUSHJ	P,DNPRN2	;AND DECIMAL POINT.
	SKIPN	EXTFG
	JRST	OUTN3
	AOJG	E,OUTN33
	MOVEI	C,"0"
	PUSHJ	P,OUCH
	JRST	.-3
OUTN33:	SETZ	E,
OUTN3:	SETZM	EXTFG
	PUSHJ	P,DNPRNT	;GO PRINT NUMBER WITH DECIMAL


;HERE TO PRINT EXPONENT

	
	POP	P,E		;RESTORE E
	JUMPE	B,CPOPJ
	SKIPN	ODF
	JRST	OUTN5
	AOS	HPOS(LP)
	PUSHJ	P,INLMES
	ASCIZ	/E/
	JRST	OUTN6
OUTN5:	PUSHJ	P,INLMES
	ASCIZ	/ E/
OUTN6:	MOVEI	C,"+"
	JUMPGE	B,.+2		;SPIT OUT SIGN
	MOVEI	C,"-"
	PUSHJ	P,OUCH
	MOVM	T,B		;USE PRTNUM TO PRINT EXPON
	JRST	PRTNUM


;SUBROUTINE USED BY OUTNUM TO PRINT DECIMAL NUMBER.  PRINTS
;SIX DIGITS (INTEGER IN T) WITH CONTENTS(E) DIGITS
;TO THE LEFT OF DECIMAL POINT

DNPRNT:	MOVEI	D,-1		;SIGNAL TRAILING ZERO UNLESS...
	JUMPE	B,.+2		;E-NOTATION
	MOVEI	D,0
DNPRN0:	IDIVI	T,^D10		;GET LAST DIGIT
	JUMPE	T,DNPRN1	;IS IT FIRST?
	JUMPN	T1,.+2		;NON ZERO DIGIT?
	SKIPA	T1,D		;NO, STASH ZERO OR TRAILZERO
	MOVEI	D,0		;YES. TRAILER IS OVER.
	HRLM	T1,(P)		;NO.  STASH DIGIT
	PUSHJ	P,DNPRN0	;CALL DNPRNT RECURSIVELY
	HLRE	T1,(P)		;RESTORE DIGIT
	JUMPGE	T1,.+3		;ORDINARY DIGIT?
	JUMPLE	E,CPOPJ		;NO, TRAILZERO. AFTER DECIMAL POINR?
	MOVEI	T1,0		;NO, STASH A ZERO.


	EXTERN EXTFG

DNPRN1:	MOVEI	C,60(T1)	;PRINT DIGIT
	PUSHJ	P,OUCH
	SOJN	E,CPOPJ		;COUNT DIGITS.  POINT NEXT?
DNPRN2:	MOVEI	C,"."		;YES.  PRINT POINT
	JRST	OUCH

;CHECK FOR ROOM ON A LINE FOR E-FORM NUMBER:
CHKEF:	MOVEI	X1,^D14		;NEED 14 SP TO PRINT THIS NUMBER.
	SKIPN	ODF
	JRST	CHKEF2
	ADD	X1,HPOS(LP)
	CAILE	X1,^D72
	JRST	NUMIN1
	POPJ	P,
CHKEF2:	PUSH	P,B		;SAVE EXPONENT
	PUSHJ	P,CHROOM	;FIND ROOM OR DO CRLF
	POP	P,B
	POPJ	P,

;CHECK FOR ROOM FOR NON-EFORM DECIMAL NUMBER.
CHKNEF:	CAIL	E,0
	SETZM	EXTFG
	SKIPE	EXTFG
	SKIPA	X1,[EXP ^D14]
	MOVEI	X1,^D9		;ASSUME THIS NUMBER WILL TAKE 8
	SKIPN	ODF
	JRST	CHKNF2
	CAIN	X1,^D9
	AOS	X1
	ADD	X1,HPOS(LP)
	CAILE	X1,^D72
	PUSHJ	P,NUMIN1
	SKIPA
CHKNF2:	PUSHJ	P,CHROOM
	MOVEI	B,0		;NO EXPONENT.
	JRST	CPOPJ1		;SKIP-RTN

;POWER-OF-TEN TABLE.

D1EM18:	OCT	105447113564	;10^-18

DECFLO:
D1EM4:	OCT	163643334273	;10^-4
	OCT	167406111565
	OCT	172507534122
	OCT	175631463146
DECTAB:	DEC	1.0		;10^0
	DEC	1.0E1
	DEC	1.0E2
	DEC	1.0E3
	DEC	1.0E4
	DEC	1.0E5
	DEC	1.0E6
	DEC	1.0E7
	DEC	1.0E8
	DEC	1.0E9
	DEC	1.0E10
	DEC	1.0E11
	OCT	250721522451	;10^12
	OCT	254443023471
D1E14:	OCT	257553630410	;10^14
DECCEI:

MAXEXP=^D38
DECFIX:	EXP 225400000000
FIXCON:	EXP 233400000000

;FLAGS USED BY DECIMAL READER/PRINTER

F.NUM=200000	;DIGIT SEEN
F.MIN=100000	;MINUS SEEN
F.MXP=40000	;MINUS EXPONENT
F.DOT=20000	;DECIMAL POINT SEEN
	SUBTTL RUN-TIME ROUTINES

;RUN-TIME GOSUB ROUTINES

GOSBER:	MOVE	X1,@40
	MOVE	R,FCNLNK
	HRLM	R,@40		;SAVE PRECEDING CALL
	MOVE	R,40		;FETCH CURRENT CALL
	MOVEM	R,FCNLNK
	TRNN	X1,777777	;IF FCN, BEGINS AT CTRL WRD + 1
	HRRI	X1,1(R)
	TLNN	X1,777777	;CHECK RECURSIVE CALL
	JRST	(X1)

	PUSHJ	P,INLMES	;RECURSIVE CALL
	ASCIZ	/SUBROUTINE OR FUNCTION CALLS ITSELF IN /
GOSR2:	PUSH	P,[Z UXIT]	;PRINT LINE NUMBER AND END EXECUTION
GOSR3:	MOVE	T,SORCLN	;PRINT LINENUMBER AND CONTINUE EXECUTION.
	PUSHJ	P,PRTNUM
	PUSHJ	P,INLMES
	ASCIZ	/
/
	POPJ	P,

FORCOM:	MOVEI	X1,313		;RUNTIME COMPARE FIX-DONT USE IF CON
	SKIPGE	@40
	ADDI	X1,2
	DPB	X1,[POINT 9,@(P),8]   ;SET UP COMPARE FOR ENTIRE LOOP
	POPJ	P,

XCTON:	JUMPLE	N,XCTON1	;IS ON ARGUMENT <=0?
	FAD	N,FIXCON
	HRRZ	T,N		;GET INTEGER PART
	JUMPE	T,XCTON1
	ADDI	T,(A)		;GET THE "GOTO" ADDRESS
	CAMGE	T,(A)		;IS IT IN RANGE?
	JRST	@(T)		;YES, GOGO

XCTON1:	PUSHJ	P,INLMES
	ASCIZ /ON EVALUATED OUT OF RANGE IN /
	JRST	GOSR2


;HERE ON OVFLOW ERROR
OVTRAP:	PUSH	P,X1		;SAVE THIS REG IN CASE FALSE ALARM.
	HRRZ	X1,JOBTPC	;GET TRAP ADDRESS.
	CAML	X1,FLCOD	;TRAP IN USER PROG?
	CAMLE	X1,CECOD
	JRST	OVFIG2		;NO. FALSE TRAP.(NOT BY USER)
	PUSH	P,ODF
	SETZM	ODF		;ERROR MESSAGE MUST NOT GO TO DSK.
	MOVE	X1,JOBTPC	;GET TRAP FLAGS.
	SKIPE	PDP6SW		;PDP6 COMPUTER?
	JRST	OVTR0		;YES.  ASSUME OVFLOW.
	TLNE	X1,(1B11)	;UNDERFLOW?
	JRST	UNTRAP		;YES
	TLNE	X1,(1B12)	;ZERO DIVIDE?
	JRST	DVTRAP		;YES.
	TLNN	X1,(1B3)
	JRST	OVFIGN		;NOT OVFLOW EITHER. IGNORE.
OVTR0:	PUSHJ	P,INLMES
	ASCIZ	/
OVERFLOW IN /
	SKIPL	N		;NEG OVFLOW?
OVTR2:	HRLOI	N,377777	;LRG NUMBER
	SKIPG	N
	MOVE	N,MIFI		;LRG NEG NUMBER
OVTR1:	PUSHJ	P,GOSR3
OVFIGN:	POP	P,ODF
OVFIG2:	MOVEI	X1,10
	CALLI	X1,16
	SETOM	LIBFLG
	POP	P,X1
	JRST	@JOBTPC

OVFLCM:	PUSH	P,X1
	JRST	OVFIG2

UNTRAP:	PUSHJ	P,INLMES
	ASCIZ	/
UNDERFLOW IN /
	SETZI	N,		;RESULT IS ZERO.
	JRST	OVTR1

DVTRAP:	PUSHJ	P,INLMES
	ASCIZ	/
DIVISION BY ZERO IN /
	JRST	OVTR2
	EXTERN	IFNFLG		;IFNFLG DISTINGUISHES BETWEEN "RETURN"
				;AND END OF FNX PROCESSING.
RETURN:	SETZB	T,IFNFLG	;GOSUB RETURN, NOTHING ON PLIST.
	JRST	.+2
FRETRN:	SETOM	IFNFLG
	MOVE	R,FCNLNK
	JUMPE	R,BADRET	;CHECK RETURN TOO FAR
	MOVS	X1,(R)		;FETCH LINK BACK
	HRRZS	(R)		;MARK SUBR NOT IN USE
	MOVEI	R,(X1)
	MOVEM	R,FCNLNK
	POP	P,X2		;SAVE REAL RETURN LOCATION
	SUB	Q,T		;POP ANY ARGUMENTS OFF THE PUSH LIST
	SKIPN	IFNFLG
	JRST	(X2)		;RETURN
RESACS:	POP	P,T		;RESTORE AC'S, EXCEPT 0, X2, AND P.
	POP	P,T1
	POP	P,A
	POP	P,B
	POP	P,C
	POP	P,D
	POP	P,F
	POP	P,E
	POP	P,G
	POP	P,R
	POP	P,X1
	POP	P,T2
	JRST	(X2)

SAVACS:	HRRZ	N,P
	SUBI	N,PLIST
	CAILE	N,250
	JRST	MNYDEF
	POP	P,N
	PUSH	P,T2
	PUSH	P,X1
	PUSH	P,R
	PUSH	P,G
	PUSH	P,E
	PUSH	P,F
	PUSH	P,D
	PUSH	P,C
	PUSH	P,B
	PUSH	P,A
	PUSH	P,T1
	PUSH	P,T
	PUSH	P,N
	POPJ	P,

MNYDEF:	PUSHJ	P,INLMES
	ASCIZ	/TOO MANY FN'S IN /
	JRST	GOSR2

BADRET:	PUSHJ	P,INLMES
	ASCIZ	/RETURN BEFORE GOSUB IN /
	JRST	GOSR2

IFN FTRND,<
;RUN-TIME RANDOMIZER
RANDER:	CALL	N,[SIXBIT /MSTIME/]
	IMUL	N,N		;USE THE 31 LOW ORDER BITS OF MILLESECS IN DAY ^2
	TLZ	N,760000
	JRST	WRANB		;PRIME RANDOM FCN AND RETURN.
>;ASSEMBLE ABOVE IF INCLUDING RANDOM FACILITY
	
;RUN-TIME ROUTINES FOR READ AND INPUT

DOREAD:	MOVE	R,[XWD NXREAD,PREAD]
	SETZM	INPFLA		;READ, NOT INPUT
	POPJ	P,		;SET UP TO READ

	EXTERN	PINPNM
DOINPT:	SKIPN	IFIFG
	SETZM	PINPUT		;FORCE NEW LINE
	SETZM	MORFLA		;SIGNAL BEGINNING OF INPUT
	MOVE	R,[XWD NXINPT,PINPUT]
	POP	P,INPFLA	;SAVE ERROR RETURN
	JRST	@INPFLA

;ROUTINE TO GET A DATA WORD

DATAER:	SKIPN	IFIFG
	JRST	DATAE1
	SKIPN	T,PINPNM-1(LP)
	JRST	NXINPT
	PUSHJ	P,DELAWY
	JRST	DATR0
DATAE1:	SKIPN	T,(R)		;MORE ON SAME LINE?
	JRST	DATR1		;NO
	PUSHJ	P,NXCH		;PUT FIRST CHAR OF NEXT NUMBER IN C
DATR0:	PUSHJ	P,EVANUM
	PUSHJ	P,SSKIP		;IT WASN'T A NUMBER, TRY NEXT
	MOVEM	N,@40		;STORE THE DATA WORD
	SKIPE	IFIFG
	PUSHJ	P,DELAWY
	SKIPE	INPFLA		;END OF LINE TEST.
	TLNN	C,F.CR
	TLNE	C,F.TERM	
	SETZI	T,		
	SKIPN	IFIFG
	JRST	DATAE2
	MOVEM	T,PINPNM-1(LP)
	JRST	DATR01
DATAE2:	MOVEM	T,(R)
DATR01:	POP	P,X1
	SKIPN	T		;END OF A LINE?
	SKIPN	INPFLA		;YES, IS THIS INPUT?
	JRST	(X1)		;NO, RETURN
	MOVEM	X1,INPFLA	;YES, RESTART NEXT ERROR FROM HERE.
	JRST	(X1)

DATR1:	MOVS	X1,R		;DISPATCH ADDRS FOR MORE DATA
	JRST	(X1)

;ROUTINE TO GET A DATA STRING

INSTR:
IFN FTSTR,<
SDATAE:	SKIPN	IFIFG
	JRST	SDAT1
	SKIPN	T,PINPNM-1(LP)
	JRST	NXSINP
	PUSHJ	P,DELAWY
	JRST	SDATR0
SDAT1:	MOVE	T,1(R)		;GET CURRENT LINE POINTER
	SKIPE	INPFLA		;INPUT,INSTRUCTION?
	MOVE	T,(R)		;YES, SHARE POINTER WITH NUMBER DATA
	SKIPN	T		;MORE ON CURRENT STRING DATA LINE?
	JRST	SDATR1		;NO. HUNT FOR NEXT DATA LINE
	PUSHJ	P,NXCH		;GET FIRST CHAR
SDATR0:	PUSHJ	P,REDSTR	;READ THE STRING AND STORE IT
	PUSHJ	P,SSKIP		;BAD STRING
	SKIPE	IFIFG
	PUSHJ	P,DELAWY
	SKIPE	INPFLA		;END OF LINE TEST.
	TLNN	C,F.CR
	TLNE	C,F.TERM	
	SETZI	T,		
	SKIPN	IFIFG
	JRST	SDAT2
	MOVEM	T,PINPNM-1(LP)
	JRST	DATR01
SDAT2:	MOVEM	T,1(R)		;SAVE STRING DATA POINTER.
	SKIPE	INPFLA		;INPUT?
	MOVEM	T,(R)		;YES , SHARE POINTER
	JRST	DATR01

SDATR1:	MOVS	X1,R		;DISPATCH ADDRESS FOR STRING DATA..
	JRST	1(X1)
>;ASSEMBLE ABOVE IF INCLUDING STRING FACILITY

;GET AN ARRAY DATA WORD

ADT1ER:	PUSH	P,40		;DATAER NEEDS STORE LOC
	SETZM	40
	PUSHJ	P,DATAER
	POP	P,40
	JRST	AST1ER	;GO STORE THE WORD

ADT2ER:	PUSH	P,40
	SETZM	40
	PUSHJ	P,DATAER
	POP	P,40
	JRST	AST2ER

;GO TO NEXT LINE OF DATA

NXREAD:	TDZA	X1,X1		;GET NEXT DATA LINE FOR NUMBER ITEM
NSRSTR:	MOVEI	X1,1		;GET NEXT DATA LINE FOR STRING ITEM
	MOVE	T,DATLIN(X1)	;GET NXT DATA LINE NO
	AOBJP	T,NXRE2		;JUMP IF OUT OF DATA
	MOVEM	T,DATLIN(X1)
	HRRZ	T,(T)		;GET ADDRS OF SOURCE LINE
	HRLI	T,440700
	PUSHJ	P,NXCH
	PUSH	P,X1
	PUSHJ	P,QSA		;LOOK FOR "DATA"
	ASCIZ	/DATA/
	JRST	[POP P,X1
		JRST NXREAD+2]
	POP	P,X1
IFN FTSTR,<
	JUMPG	X1,SDATR0	;GO GET STRING?
>
	JRST	DATR0		;NO, GO GET NUMBER
;REQUEST NEXT LINE OF INPUT

NXVINP:	SETOI	X1,		;GET LINE AND RETURN TO "MATIN"
	JRST	NXSIN1
NXINPT:	TDZA	X1,X1		;GET A LINE OF INPUT; NUMBER ITEM NEXT
NXSINP:	MOVEI	X1,1	;GET A LINE OF INPUT; STRING ITEM NEXT
NXSIN1:	SKIPN	MORFLA		;START OF INPUT?
	JRST	NXIN1		;YES
	PUSHJ	P,INLMES
	ASCIZ	/NOT ENOUGH INPUT--ADD MORE
/
NXIN1:	SKIPN	IFIFG
	SETZB	LP,ODF
	JUMPN	LP,NXIN5
	PUSHJ	P,INLMES
	ASCIZ	/ ?/
	OUTPUT
NXIN5:	MOVE	T,LINPT(LP)
	PUSHJ	P,INLINE	;READ THE LINE AND GET FIRST CHAR.
	TLNE	C,F.CR		;NULL LINE?
	JUMPL	X1,CPOPJ1	;YES. ALLOW THIS ON MAT INPUT
	MOVE	T,LINPT(LP)
	JUMPE	LP,NXIN6
NXIN8:	PUSHJ	P,NXCH
	TLNE	C,F.CR
	JRST	NXIN5
	MOVEI	A,4
	TLNN	C,F.DIG
	JRST	IMP
	PUSHJ	P,NXCHD
	TLNN	C,F.DIG
	JRST	.+3
	SOJGE	A,.-3
	JRST	IMP
	HRRZ	A,C
	CAIN	A,11
	JRST	.+3
	CAIE	A,"D"
	JRST	NXIN6
	MOVEI	C,40
	DPB	C,T
NXIN6:	SKIPN	IFIFG
	JRST	NXIN2
	MOVEM	T,PINPNM-1(LP)
	JRST	NXIN9
NXIN2:	MOVEM	T,PINPUT
	PUSHJ	P,DATCHK	;CHECK
	JRST	.+1
NXIN9:	JUMPE	X1,DATAER	;GET NUMBER ITEM
IFN FTSTR,<
	JUMPG	X1,SDATAE		;GET STRING ITEM
>
	POPJ	P,

INPERP:	POP	P,X1		;GET RID OF CALL TO NXVINP!
INPERR:	SKIPE	IFIFG
	JRST	IMP
	PUSHJ	P,INLMES
	ASCIZ	/INPUT DATA NOT IN CORRECT FORM--RETYPE LINE
/
	SETZM	PINPUT
INPER1:	HRRZ	X1,INPFLA
	JRST	(X1)		;START LINE OVER.

;RESTORE DATA POINTER

RESTOR:	PUSHJ	P,RESTOS	;RESTORE BOTH NUMBERS AND STRINGS
RESTON:	TDZA	X1,X1		;RESTORE NUMERIC DATA
RESTOS:	MOVEI	X1,1		;RESTORE STRINGS
	MOVE	T,DATAFF
	ADD	T,FLLIN
	SUB	T,[XWD 1,1]
	MOVEM	T,DATLIN(X1)
	SETZM	PREAD(X1)		;CLEAR CURRENT LINE POINTER
	POPJ	P,


NXRE2:	PUSHJ	P,INLMES	;OUT OF DATA
	ASCIZ	/OUT OF DATA IN /
	HRRZ	T,L
	PUSHJ	P,PRTNUM
	PUSHJ	P,INLMES
	ASCIZ	/
/
	JRST	UXIT

INERR:	SETZM	ODF
	PUSHJ	P,TTYIN
	PUSHJ	P,INLMES
	ASCIZ/
DATA FILE LINE TOO LONG IN LINE /
	JRST	IMP1

PTXER1:	SETZM	ODF
	PUSHJ	P,TTYIN
	PUSHJ	P,INLMES
	ASCIZ	/
ILLEGAL CHARACTER IN STRING IN LINE /
	JRST	IMP1

PTXER2:	SETZM	ODF
	PUSHJ	P,TTYIN
	PUSHJ	P,INLMES
	ASCIZ	/
STRING TOO LONG FOR DATA FILE LINE IN LINE /
	JRST	IMP1


IMP:	PUSHJ	P,INLMES
	ASCIZ	/BAD DATA INTO LINE /
IMP1:	HRRZ	T,CURLIN
IMP2:	PUSHJ	P,PRTNUM
	PUSHJ	P,INLMES
	ASCIZ	/
/
	JRST	UXIT

FNR:	PUSHJ	P,INLMES
	ASCIZ/ FILE NEVER ESTABLISHED - REFERENCED IN LINE /
	JRST	IMP1
ENFAIL:	SETZM	ODF
	PUSHJ	P,INLMES
	ASCIZ	/FAILURE ON ENTER IN LINE /
	JRST	IMP1


ILWRT:	SETZM	ODF
	PUSHJ	P,INLMES
	ASCIZ	/ILLEGAL DSK WRITE IN LINE /
	JRST	IMP1
ILRD:	PUSHJ	P,INLMES
	ASCIZ	/ILLEGAL DSK READ IN LINE /
	JRST	IMP1

RENFAL:	PUSHJ	P,TTYIN
	PUSHJ	P,INLMES
	ASCIZ	/
NO FILE ON CHANNEL /
	HRRZ	T,X1
	PUSHJ	P,PRTNUM
	PUSHJ	P,INLMES
	ASCIZ	/
/
	JRST	UXIT4

LOKFAL:	PUSHJ	P,INLMES
	ASCIZ/FILE /
	MOVE	T,FILD-1(X1)
	PUSHJ	P,PRNSIX
	PUSHJ	P,INLMES
	ASCIZ/ NOT FOUND BY RESTORE COMMAND IN LINE /
	JRST	IMP1

EOFFAL:	POP	P,X1
	PUSHJ	P,INLMES
	ASCIZ/EOF IN LINE /
	HRRZ	T,CURLIN
	PUSHJ	P,PRTNUM
	PUSHJ	P,INLMES
	ASCIZ	/
/
	JRST	UXIT


TMF:	PUSHJ	P,INLMES
	ASCIZ/TOO MANY FILES
/
	JRST	UXIT
;RUNTIME MAT INPUT ROUTINE

MATIN:	PUSHJ	P,DOINPT		;SETUP INPUT LOOP
	HRRZ	X1,40		;GET VECTOR 2-WD BLOCK ADDRESS
	HRRZ	X2,(X1)		;GET ADDRESS OF FIRST ELEMENT
	MOVEM	X2,NUMRES	;SAVE THIS VALUE FOR COUNTING ELEMENTS LATER
	HLRZ	X1,(X1)		;GET MAXIMUM VECTOR SIZE
	ADD	X1,X2		;UPPER BOUND OF VECTOR
	MOVEM	X1,ELETOP	;SAVE FOR COMPARISON LATER
	HRRM	X2,40		;SET UP ELEMENT ADDRESS FOR DATA ROUTINES

MATIN1:	MOVEI	X1,MATIN4	;POINT "INPUT ERR" TO SPECIAL ROUTINE
	HRL	X1,40		;REMEMBER FIRST ELEMENT ON LINE
	MOVEM	X1,INPFLA
	PUSHJ	P,NXVINP	;INPUT THE LINE

MATIN5:	CAIA		;THERE IS ANOTHER ELEMENT.
	JRST	MATIN6	;NULL LINE. NO MORE ELEMENTS.
	HRRZ	X1,40		;MAY WE ACCEPT ANOTHER ELEMENT?
	CAML	X1,ELETOP
	JRST	MATIN3		;NO
	AOS	40		;POINT TO NEXT ELEMENT
	PUSH	P,[EXP MATIN2]	;YES. SETUP RETURN FROMDATA ROUTINE
IFN FTSTR,<
	CAML	X1,SVRBOT	;NUMBER OR STRING VECTOR?
	JRST	SDATAE		;STRING
>
	JRST	DATAER		;NUMBER

MATIN2:	SETOM	MORFLA		;AT LEAST ONE ELE HAS BEEN RECEIVED.
	TLNE	C,F.COMA	;MORE ON THIS LINE?
	JRST	MATIN5	;YES
	TLNE	C,F.TERM	;NO. END OF INPUT?
	JRST	MATIN6		;YES. SETUP "NUM" FUNCTION AND RETURN
	CAIN	C,"&"		;NO. MORE ON NEXT LINE?
	JRST	MATIN1		;YES
	JRST	INPERR		;SOME OTHER TERMINAL CHAR. VERY BAD.

MATIN3:	PUSHJ	P,INLMES
	ASCIZ /TOO MANY ELEMENTS -- RETYPE LINE
/
	JRST	INPER1

MATIN4:	HLRZ	X1,INPFLA	;AN ERROR HAS OCCURRED. START LINE OVER
	HRRM	X1,40		;WITH SAME ELEMENT
	JRST	MATIN1

MATIN6:	HRRZ	X1,40		;CALCULATE NUMBER OF ELEMENTS
	SUB	X1,NUMRES
	TLO	X1,233400	;FLOAT  RESULT
	FSB	X1,FIXCON
	MOVEM	X1,NUMRES
	POPJ	P,
	EXTERN	QUOFL1

IFN FTSTR,<
REDSTR:	SKIPE	INPFLA
	JRST	REDS9
	TLNN	C,F.LETT+F.QUOT
	POPJ	P,
REDS9:	AOS	(P)		;THIS IS A LEGITIMATE STRING
	PUSH	P,G
	PUSH	P,E
	PUSHJ	P,GETSTR
	SETZ	G,
	PUSHJ	P,VCHECK	;MAKE SPACE
	SKIPN	IFIFG
	JRST	REDS4
	MOVEI	X1,F.COMA+F.CR+F.SPTB+F.QUOT
	JRST	.+2
REDS4:	MOVEI	X1,F.COMA+F.TERM	;ASSUME A STRING WITHOUT QUOTES
	SETZM	QUOFL1
	TLNN	C,F.QUOT	;IS IT A QUOT STRING?
	JRST	REDS1		;NO
	SETOM	QUOFL1
	MOVEI	X1,F.QUOT+F.CR
	PUSHJ	P,NXCHD		;SKIP QUOTE
REDS1:	SETZI	X2,		;INITIALIZE COUNT
	SKIPE	(F)		;NEW STRING?
	SETZM	VPAKFL		;NO, GARBAGE NOW EXISTS
	HRR	F,VARFRE	;GET FREE LOCATION
	HRRM	F,@N		;STORE ADDRESS OF STRING
REDS2:	TLNN	C,(X1)
	JRST	REDS6
	SKIPE	QUOFL1
	JRST	REDQOT
	TLNN	C,F.QUOT
	JRST	REDS8
REDS7:	POP	P,E
	POP	P,G
	SOS	(P)
	POPJ	P,
REDQOT:	TLNN	C,F.QUOT
	JRST	REDS7
	PUSHJ	P,NXCHD
	JRST	REDS8
REDS6:	IDPB	C,F		;STORE A CHAR
	PUSHJ	P,NXCHD
	SOJA	X2,REDS2	;COUNT THE CHAR

REDS8:	HRRZ	X1,F		;GET NEW FREE LOCATION
	POP	P,E
	POP	P,G
	JRST	PUTST2

SSKIP:	SKIPE	INPFLA		;IS THIS INPUT OR READ?
	JRST	SSKP1		;INPUT. CANT SKIP ANY FIELDS
	PUSHJ	P,SKIPDA	;SKIP OVER A DATA FIELD
	HALT	.		;IMPOSSIBLE ERROR
	POP	P,X1
	TLNE	C,F.TERM	;END OF DATA LINE?
	JRST	-4(X1)		;YES. FORCE DATA SEARCH
	JRST	-3(X1)		;RETURN TO DATAER OR SDATAE

SSKP1:	ADD	P,[XWD -2,-2]	;CLEAN UP PUSH LIST
	JRST	INPERR

;ROUTINE THAT SKIPS OVER ONE DATA FIELD
SKIPDA:	TLNE	C,F.QUOT	;QUOTE STRING?
	JRST	QSKIP		;YES, USE QSKIP ROUTINE
	TLNE	C,F.COMA+F.TERM	;FIELD TERMINATOR?
	JRST	CPOPJ1
	PUSHJ	P,NXCH	
	JRST	.-3
>;ASSEMBLE ABOVE IF INCLUDING STRING FACILITY


IFE FTSTR,<
SKIPDA:	POPJ	P,	;STRINGS NOT ALLOWED. DATA ERROR
SSKIP:	ADD	P,[XWD -2,-2]	;CLEAN UP PUSHLIST
	JRST	INPERR
>
	SUBTTL RUN-TIME ROUTINES FOR PRINTING

;RUNTIME STRING CONSTANT PRINTER.
PRTXER:	MOVE	T,@(P)
	SKIPE	ODF		;DISK?
	JRST	PRTXDS		;YES.
	AOS	(P)		;NO.
	SETZ	LP,
	PUSHJ	P,TABBER
	SETZM	NUMFLA
	MOVEI	D,42
	PUSHJ	P,PRINT1
	JRST	FINPNT

PRTXDS:	SKIPE	LNINS-1(LP)	;DISK. NEED A LINE NUMBER?
	PUSHJ	P,NUMINS	;YES.
	HRLOI	G,377777	;NO.
	PUSHJ	P,PRTXD1
PRTXD3:	MOVE	T,@(P)
	AOS	(P)
PRTXD8:	MOVEI	C," "		;OUTPUT A DELIMITER.
	PUSHJ	P,OUCH
	PUSHJ	P,PRTXD4
	JUMPN	G,PRTXD5
	MOVEI	C,40
	JRST	PRTXD0
PRTXD5:	ILDB	C,T		;OUTPUT THE STRING.  WHEN USED
	SOJGE	G,.+2		;BY PRTXER ROUTINE, THIS SECTION STOPS
	JRST	PRTXD4		;ON A QUOTE CHARACTER -- WHEN USED
	CAIN	C,42		;BY PRSTRR ROUTINE, THE COUNT OF
	JRST	PRTXD4		;CHARACTERS IS IN G.
PRTXD0:	PUSHJ	P,OUCH
	JRST	PRTXD5
PRTXD4:	SKIPN	QUOFLG		;OUTPUT A QUOTE?
	POPJ	P,		;NO.
	MOVEI	C,42		;YES.
	JRST	OUCH

EXTERN	QUOFLG
PRTXD1:	SETZM	QUOFLG		;QUOFLG NE 0 SAYS MUST
PRTXD9:	MOVEI	X1,^D71		;WRITE THIS STRING WITH QUOTES.
	SUB	X1,HPOS(LP)
	JUMPG	X1,.+3
	PUSHJ	P,NUMIN1
	JRST	PRTXD9
	SETOM	X2
	JUMPN	G,PRTXD7
	MOVEI	C,40
	AOJA	G,.+2
PRTXD7:	ILDB	C,T
	SOJGE	G,.+2		;SEE NOTE ABOUT G AND "
	POPJ	P,		;AT PRTXD5 ROUTINE.
	CAIE	C,42
	JRST	PRTXDD
	CAIG	G,1000
	JRST	PTXER1
	POPJ	P,
PRTXDD:	HLL	C,CTTAB(C)
	TRNE	C,100
	HRL	C,CTTAB-100(C)
	TLNE	C,F.CR
	JRST	PTXER1		;IF STRING CONTAINS SPACE, TAB,
				;OR COMMA, IT MUST BE WRITTEN WITH QUOTES.
	TLNN	C,F.SPTB+F.COMA
	JRST	PRTXD6
	SKIPN	QUOFLG
	SUBI	X1,2		;ONCE ONLY, SUBTRACT THE 2 SPACES
	SETOM	QUOFLG		;THE QUOTES TAKE UP.
PRTXD6:	SOJG	X1,PRTXD7
	AOJN	X2,PTXER2	;STRING IS TOO LONG FOR LINE.
	MOVEI	D,^D72
	SUB	D,HPOS(LP)
	SUB	D,X1
	PUSHJ	P,NUMIN1
	ADD	D,HPOS(LP)
	CAIL	D,^D72
	JRST	PTXER2
	MOVEI	X1,^D72
	SUB	X1,D
	JRST	PRTXD7



FINPNT:	MOVE	X1,FMTPNT	;FINISH WITH CR?
	CAIE	X1,1
	JRST	FINPT2		;NO


PCRLF:	PUSHJ	P,INLMES
	ASCIZ	/
/
	SETZM	NUMFLA
	SETZM	TABVAL
FINPT2:	OUTPUT
	POPJ	P,
;RUN-TIME NUMBER PRINTER

PRNMER:	SKIPE	ODF		;DISK?
	JRST	PRNMDS		;YES.
	SETZ	LP,		;NO.
	PUSHJ	P,TABBR
	MOVE	N,@40		;GET THE NUMBER
	PUSHJ	P,OUTNUM
	AOS	TABVAL		;CAUSE A SPACE TO FOLLOW NUMBER.
	JRST	FINPNT
PRNMDS:	SKIPE	LNINS-1(LP)	;DISK.  NEED A LINE NO.?
	PUSHJ	P,NUMINS	;YES.
	MOVE	A,HPOS(LP)	;NO.
	CAILE	A,^D62		;ROOM FOR "INTEGER" PLUS 1 SPACE?
	PUSHJ	P,NUMIN1	;NO. NEW LINE.
	MOVE	N,@40
	JRST	OUTNUM

;RUN-TIME TAB PRINTER


PRNTBR:	SETOM TABFG
	SETZ	LP,
	PUSHJ	P,TABBR		;CALCULATE AMOUNT OF SPACING REQUESTED BY
				;LAST FORMAT CHAR.  ADD THAT TO "TABVAL"
				;BUT DO NOT PUT OUT THE SPACES.
	JUMPLE	N,FINPNT	;ALSO IGNORE ZERO AND MINUS TABS.
	SKIPGE	B,TABVAL	;IGNORE TAB IF <RETURN> IS NEXT.
	JRST	FINPNT
	FAD	N,FIXCON
	TLZ	N,377400	;NOW THE DESIRED COLUMN IS A FIXED NUMBER
	SUB	N,HPOS(LP)	;ARE WE ALREADY PAST THIS COLUMN, TAKING INTO ACCOUNT
	SUB	N,B		;FURTHER SPACING WHICH HAS ALREADY BEEN REQUESTED (SUBTRACTED HERE)
	JUMPLE	N,FINPNT	;YES,IGNORE REQUEST
	ADDM	N,TABVAL	;NO, ADD THE DIFFERENCE TO THE SPACING  REQUEST
	JRST	FINPNT

NUMIN1:	MOVEI	C,15		;OUTPUT END OF LINE AND THEN
	PUSHJ	P,OUCH		;FALL INTO LINE NUMBER ROUTINE.
	MOVEI	C,12
	PUSHJ	P,OUCH


NUMINS:	MOVEI	X2,12		;NEW LINE NUMBER.
	ADDB	X2,LINNUM-1(LP)
	CAILE	X2,^D99990
	JRST	NUMLRG
	PUSH	P,T
	MOVE	T,@OUTCNT-1(LP)
	JUMPLE	T,NUMIN2
	IDIVI	T,5
	JUMPE	T1,NUMIN2
	SETZ	C,		;PAD WITH NULLS SO THAT THE LINE
	PUSHJ	P,OUCH		;NUMBER STARTS IN A NEW WORD.
	SOJG	T1,.-1
NUMIN2:	MOVE	T,LINNUM-1(LP)
	SETZM	NUMCOT
	PUSHJ	P,PRTNUM
	MOVEI	T,5
	MOVEM	T,HPOS(LP)
	MOVE	T,NUMCOT
	SUBI	T,5
	MOVE	T1,@OUTPT-1(LP)
	MOVE	T1,(T1)
	JUMPE	T,NUMIN3
NUMIN4:	LSH	T1,-7		;PAD WITH LEADING ZEROES (RE-
	TLO	T1,300000	;QUIRED BY THE LINED CUSP).
	IBP	@OUTPT-1(LP)
	SOS	@OUTCNT-1(LP)
	AOJL	T,NUMIN4
NUMIN3:	TRO	T1,1		;SET THE "SEQ. NO." BIT.
	MOVE	T,@OUTPT-1(LP)
	MOVEM	T1,(T)
	POP	P,T
	SETZM	LNINS-1(LP)
	POPJ	P,

EXTERN	TABFG,NUMCOT


NUMLRG:	SETZM	ODF
	PUSHJ	P,TTYIN
	PUSHJ	P,INLMES
	ASCIZ	/
ATTEMPT TO WRITE A LINE NUMBER > 99,990 IN FILE ON CHANNEL /
	HRRZ	T,LP
	JRST	IMP2

;TAB CONTROL

;"TABBER" CALLS "TABBR" AND THEN THEN MOVES SPACES OR A CRLF TO THE TTYOUT BUFFER.
;"TABB2" CREATES THE ACTUAL SPACES, ACCORDING TO A COUNT THEN IN "B"
;"TABBR" ANALYSES THE LAST FORMAT CHARACTER USING "TABB1" AND
;"TABB3", WHICH HANDLE THE COMMA AND SEMICOLON, RESPECTIVELY.
;"NUMFLA" IS MINUS IF THE LAST ITEM TYPED OUT WAS A NUMBER
;"TABVAL" CONAINS THE NUMBER OF SPACES WAITING TO BE TYPED OUT
;(OR IS NEGATIVE IF A <RETURN> MUST FOLLOW.)


TABBER:	PUSHJ	P,TABBR		;PROCESS LAST FORMAT CHAR
TABER1:	MOVEI	X1,0		;TABBER CALLS ALLOW A PRINT FIELD OF ANY SIZE
CHROOM:	MOVE	B,TABVAL
	ADD	X1,B		;TOTAL SPACE NEEDED FOR FIELD
	ADD	X1,HPOS
	CAIL	X1,^D72
	JRST	PCRLF		;NO ROOM, GO TO NEXT LINE.
	JUMPL	B,PCRLF
	JUMPE	B,CPOPJ		;NO SPACING TO DO.
TABB2:	MOVEI	C," "		;HERE TO PUT OUT SPACES
	PUSHJ	P,OUCH
	SOJG	B,TABB2
	SETZM	TABVAL
	POPJ	P,

TABBR:	LDB	X1,[POINT 4,40,12]
	EXCH	X1,FMTPNT	;GET OLD POSITION AND SAVE NEW FORMAT
TABBR2:	MOVE	A,TABVAL
	JUMPL	A,SETCR		;<RETURN> IS NEXT. IGNORE SPACING
	ADD	A,HPOS
	JRST	.+1(X1)
	POPJ	P,		;NO FMT CHAR
	POPJ	P,		;<CR> WAS TYPED WHEN FIRST SEEN.
	JRST	TABB3		;SEMICOLON
TABB1:	CAILE	A,^D56		;COMMA.
	JRST	SETCR
	SKIPE	TABFG
	JRST	TAB23		;TAB FUNCTION IN EFFECT-NO FORMATING
	IDIVI	A,^D14
	JUMPE	B,.+3
	SUBI	B,^D14
	MOVNS	B
	ADDB	B,TABVAL
	POPJ	P,
TAB23:	SETZM	TABFG		;ZERO TAB FUNCTION FLAG
	POPJ	P,

TABB3:	CAILE A,^D69   		;HERE ON SEMICOLON
	JRST	SETCR
	SKIPE	TABFG
	JRST	TAB23
	AOSGE	NUMFLA		;WAS A NUMBER LAST ITEM?
	AOS	TABVAL		;YES.
	POPJ	P,

SETCR:	SETOM	TABVAL		;FORCE <RETURN TO BE NEXT>
	SETZM	TABFG
	POPJ	P,

TABOUT:	PUSH	P,LP
	SETZ	LP,
	MOVEI	X1,3		;ROUTINE TO SPACE OVER TO NEXT COMMA ZONE.
	PUSHJ	P,TABBR2
	PUSHJ	P,TABER1
	POP	P,LP
	POPJ	P,
IFN FTSTR,<
	SUBTTL  RUN-TIME STRING MANIPULATION ROUTINES.


;GETSTR IS CALLED WITH THE ADDRESS OF A POINTER IN REG.
;THE ROUTINE SETS UP THE POINTER IN F, AND THE NEGATIVE COUNT OR
;(FOR LITERAL STRINGS) A POSITIVE QUANTITY IN G. (G=0 IF NULL STRING)

;GETSTR ALSO CHECKS FOR ADEQUATE SPACE TO MOVE STRING.

GETSTR:	PUSHJ	P,PNTADR	;GET ADDRESS OF STRING POINTER
	MOVE	F,@N		;GET STRING POINTER.
	HLRE	G,F		;PUT NEGATIVE CHAR LENGTH IN G, IF NOT LITERAL.
	JUMPG	G,CPOPJ	;IF ITS A LITERAL, ALL FINISHED.
	HRLI	F,440700	;NOT LITERAL, INITIALIZE POINTER.
	POPJ	P,

;ROUTINE TO SET UP A NUMBER VECTOR INSTEAD OF A STRING
GETVEC:	HRRZ	F,@40		;THE LEFT SIDE OF (F) IS ZERO, IMPLYING VECTOR ADR,
	MOVE	G,(F)		;GET VECTOR LENGTH
	JUMPL	G,GETVF		;NEGATIVE? 
	FAD	G,FIXCON	;FIX THE LENGTH
	TLZ	G,777400
	HLRZ	X1,@40		;DOES THE LENGTH EXCEED VECTOR BOUNDS?
	MOVNS	G
	ADD	X1,G
	JUMPLE	X1,.+2
	AOJA	F,CPOPJ		;NO. POINT TO FIRST "CHAR" AND RETURN

GETVF:	SETZM	ODF
	PUSHJ	P,INLMES
	ASCIZ /IMPOSSIBLE VECTOR LENGTH IN /
	JRST GOSR2

;GETCH GETS THE NEXT CHAR OF A STRING INTO (C), WHERE THE BYTE POINTER
;AND COUNT ARE IN (F) AND (G) AS SETUP ABOVE.  WHEN THE END OF THE
;STRING IS REACHED, (G) ::=0
;GETCH DOES A SKIP RETURN UNLESS THE END OF STRING HAS BEEN REACHED.
GETCHE:	SETZI	G,		;MARK END OF STRING
GETCH:	SETZI	C,		;ASSUME END OF STRING
	JUMPE	G,CPOPJ		;THIS IS END OF STRING
	ILDB	C,F		;NOT END OF STRING, GET NEXT CHAR
	JUMPG	G,.+2		;LITERAL STRING?
	AOJA	G,CPOPJ1		;NO, SHORTEN COUNT AND RETURN
	CAIN	C,42		;QUOTE CHAR?
	JRST	GETCHE		;YES, TERMINATE STRING
	JRST	CPOPJ1

;ROUTINE TO GET NEXT VECTOR ELE AS A CHARACTER
GETEL:	AOJG	G,CPOPJ		;IS THERE ANOTHER ELEMENT?
	MOVE	C,(F)		;YES. GET IT
	JUMPL	C,GETELF		;TOO SMALL TO BE AN ASCII
	PUSH	P,R
	LDB	R,[POINT 8,C,8]		;GET EXPONENT
	TLZ	C,777000		;TURN IT OFF
	LSH	C,-233(R)		;SHIFT INTO INTEGER POSTION
	POP	P,R
	TRNN	C,777600		;STATISTICALLY ADEQUATE CHECK ON CHAR
	AOJA	F,CPOPJ1	;BUMP ELEMENT POINTER AND RETURN

GETELF:	SETZM	ODF
	PUSHJ	P,INLMES
	ASCIZ /NON-ASCII CHAR SEEN IN /
	JRST	GOSR2

CHLEN=5*LITLEN			;MAX CHAR LENGTH OF A LITERAL

;PUTSTR IS ENTERED WITH THE ADDRESS OF THE RESULT POINTER IN REG

PUTSTR:	PUSHJ	P,PNTADR	;GET ADDRESS OF BYTE POINTER
	PUSHJ	P,VCHECK	;MAKE SPACE
	SKIPE	@N		;WAS STRING PREVIOUSLY NULL?
	SETZM	VPAKFL		;NO. STRINGS WILL NOT BE TIGHTLY PACKED.
	MOVE	X1,VARFRE	;START STRING AT NEXT FREE LOCATION
	MOVEM	X1,@N
	HRLI	X1,440700	;INITIALIZE POINTER
	SETZI	X2,		;INITIALIZE COUNT OF LENGTH.

PUTST1:	PUSH	P,[EXP PUTST3]
	TLNN	F,-1		;IS (F) A STRING POINTER?
	JRST	GETEL		;NO. GET NEXT VECTOR ELEMENT
	JRST	GETCH		;YES. GET NEXT CHAR
PUTST3:	JRST	PUTST2		;END OF STRING, NO MORE CHARS
	HRRM	X1,VARFRE		;AND SAVE
	IDPB	C,X1		;STORE CHAR
	SOJA	X2,PUTST1	;COUNT CHAR

PUTST2:	HRLM	X2,@N		;SAVE IT IN POINTER.
	AOJ	X1,		;UPDATE FREE SPACE
	HRRM	X1,VARFRE	;SAVE NEW FREE LOCATION
	POPJ	P,

;ROUTINE TO MOVED CHANGED CHARS INTO A VECTOR
PUTVEC:	HRRZ	X1,@40		;GET VECTOR ADDRESS 
	MOVE	N,X1		;SAVE FIRST LOC ADDRESS FOR LENGTH STORE
	HLRZ	X2,@40		;GET SIZE

PUTV1:	PUSHJ	P,GETCH		;GET CHAR
	JRST	PUTV9		;NO MORE CHARS
	SOJL	X2,PUTVF	;ROOM FOR ANOTHER CHAR?
	TLO	C,233400	;YES. FLOAT IT
	FSB	C,FIXCON
	MOVEM	C,1(X1)
	AOBJP	X1,PUTV1	;COUNT CHARS IN LEFT HALF OF X1

PUTV9:	HLRZ	X1,X1		;GET SIZE
	HRLI	X1,233400	;FLOAT IT
	FSB	X1,FIXCON
	MOVEM	X1,@N		;FIRST ELEMENT GETS SIZE
	POPJ	P,

PUTVF:	PUSHJ	P,INLMES
	ASCIZ /NO ROOM FOR STRING IN /
	JRST	GOSR2
;COMSTR COMPARES TWO STRINGS. ONE HAS BEEN FETCHED. THE POINTER
;TO THE OTHER IS IN REG.  THE COMPARE RELATION IS IN (P)
;COMSTR GETS A PAIR OF CHARS, ONE FROM EACH STRING, USING "GETPCH".
;WHEN IT REACHES THE END OF ONE OR BOTH STRINGS, OR WHEN IT FINDS
;AN UNEQUAL CHAR PAIR, THE ROUTINE USES THIS PAIR OF CHACTERS
;WHILE EXECUTING THE RELATION (NOTE: FIRST, HOWEVER, A CHECK IS MADE
;FOR TRAILING BLANKS).

COMSTR:	PUSH	P,F
	PUSH	P,G		;SAVE THE "FETCHED" STRING
	PUSHJ	P,GETSTR	;FETCH THE OTHER STRING
	POP	P,T1
	POP	P,T		;NOW BOTH STRINGS ARE "FETCHED"

IFST1:	PUSHJ	P,GETPCH	;GET PAIR OF CHARS IN (A) AND (C)
	JUMPG	X2,IFST3	;HAVE BOTH STRINGS ENDED?
	JUMPE	X2,IFST2	;HAS ONE STRING ENDED?
	CAMN	C,A		;ARE THESE TWO CHARS THE SAME?
	JRST	IFST1		;YES. LOOK AT NEXT PAIR

IFST2:	SETOI	X2,		;CHECK BOTH STRINGS FOR TRAILING BLANKS
	CAIN	C," "		;IS THIS CHAR A BLANK?
	PUSHJ	P,IFST4		;YES, GO CHECK STRING
	PUSHJ	P,EXCH6		;LOOK AT OTHER STRING
IFST2A:	AOJLE	X2,IFST2+1

IFST3:	HLLZ	X1,@(P)	;GET RELATION
	AOS	(P)
	IOR	X1,[Z A,C]	;SETUP COMPARE
	XCT	X1
	POPJ	P,		;RETURN AND "GOTO"
	JRST	CPOPJ1		;RETURN AND STAY IN LINE

IFST4:	PUSHJ	P,GETCH		;IS BLANK REALLY A TRAILING BLANK?
	POPJ	P,
	CAIN	C," "		;IS NEXT CHAR A BLANK?
	JRST	.-3		;YES KEEP LOOKING
	MOVEI	C," "		;NO. USE BLANK FOR COMPARE
	POPJ	P,

;ROUTINE TO GET A PAIR OF CHARS
GETPCH:	SETOI	X2,	;COUNT TERMINATED STRINGS IN X2
	PUSHJ	P,GETCH
	AOJ	X2,		;NON-SKIP RETURN MEANS STRING ENDED
	PUSHJ	P,EXCH6		;LOOK AT OTHER STRING
	PUSHJ	P,GETCH
	AOJ	X2,

EXCH6:	EXCH	T,F		;MOVE OTHER STRING INFO TO (C),(F),(G)
	EXCH	T1,G
	EXCH	A,C
	POPJ	P,
;PRSTRR PRINTS A STRING WHOSE POINTER IS ADDRESSED IN (40)

PRSTRR:	SKIPE	ODF		;DISK?
	JRST	PRSTDS		;YES.
	SETZ	LP,		;NO.
	PUSH	P,G		;SAVE G (FOR MAT READ AND PRINT)
	PUSHJ	P,PNTADR	;GET ADR OF STRING POINTER
	PUSHJ	P,GETSTR	;SETUP STRING FETCH
	PUSHJ	P,TABBER	;MOVE TO TAB STOP
	SETZM	NUMFLA		;THIS ITEM IS NOT NUMERIC
	PUSHJ	P,GETCH		;GET NEXT CHAR
	JRST	PRSTR1		;FINISH UP PRINT ITEM
	PUSHJ	P,OUCH		;PRINT CHAR
	JRST	.-3

PRSTDS:	PUSHJ	P,PNTADR	;DISK.
	PUSHJ	P,GETSTR
	MOVE	T,F
	SKIPE	LNINS-1(LP)	;NEED A LINE NUMBER?
	PUSHJ	P,NUMINS	;YES.
	MOVMS	G,G		;NO.
	PUSHJ	P,PRTXD1
	PUSHJ	P,GETSTR
	MOVMS	G,G
	MOVE	T,F
	JRST	PRTXD8

PRSTR1:	JUMPE	LP,.+3
	MOVEI	C,42		;TRAILING QUOTE
	PUSHJ	P,OUCH
	POP	P,G
	JRST	FINPNT

>;ASSEMBLE ABOVE FOR STRINGS

MCHPWD:	MOVN	X1,G		;+WORDLEN IN E _ -CHARLEN IN G
	ADDI	X1,4
	IDIVI	X1,5
	MOVE	E,X1
	POPJ	P,

IFN FTSTR,<
;ROUTINE TO PUT ADRESS OF POINTER IN REG
PNTADR:	HRRZ	N,40		;GET UUO ADDRESS
	MOVE	X1,@N		;GET WORD IT ADDRESSES
	JUMPGE	X1,CPOPJ	;ALL DONE IF THIS IS A REAL POINTER
	TLNN	X1,377777	;ALL DONE IF THIS IS NEGATIVE COUNT
	HRRZ	N,X1		;(X1) IS REAL POINTER ADDRESS
	POPJ	P,
>;ASSEMBLE ABOVE IF INCLUDING STRING FACILITY
SUBTTL	SUBSCRIPTED VARIABLE FETCH/STORE ROUTINES

;MATRIX ELEMENT FETCH/STORE UUO ROUTINES


IFN	FTSTR, <
SAD1ER:	MOVE	D,[JRST SADEND]	;FETCH ADR OF ARRAY ELEMENT
	JRST	AFT1ER+1
>

ASN1ER:	MOVE	D,[MOVNM N,(A)] ;NEGATIVE ARRAY STORE
	JRST	.+3
AST1ER:	SKIPA	D,[MOVEM N,(A)]	;POSITIVE ARRAY STORE
AFT1ER:	MOVSI	D,A(MOVE N,)	;ARRAY FETCH
	MOVEI	A,0		;PSEUDO LEFT HALF
	MOVE	B,40		;ARRAY ADDRESS
	HRRZ	C,1(B)		;TRY RIGHT DIMENSION
	TRNN	C,777776	;ROW VECTOR?
	HLRZ	C,1(B)		;NO, MUST BE COLUMN VECTOR
	JRST	AFT2C		;FINISH UP WITH 2-DIM CODE

ASN2ER:	MOVE	D,[MOVNM N,(A)] ;NEGATIVE ARRAY STORE
	JRST	.+3
AST2ER:	SKIPA	D,[MOVEM N,(A)]	;POSITIVE ARRAY STORE
AFT2ER:	MOVSI	D,A(MOVE N,)	;ARRAY FETCH
	MOVE	B,40		;ARRAY ADDRESS
	HLRZ	C,1(B)		;LEFT DIMENSION
	PUSHJ	P,SUBSCR	;GET AND FIX SUBSCRIPT IN E
	HRRZ	A,1(B)
	IMUL	A,E		;LEFT SCRIPT TIMES RIGHT DIM!
	HRRZ	C,1(B)		;RIGHT DIMENSION
AFT2C:	PUSHJ	P,SUBSCR	;GET AND FIX SUBSCRIPT IN E
	ADD	A,E		;ADD TO LEFT DIM
	ADD	A,(B)		;ADD ARRAY ADDRS
	XCT	D               ;DO THE OPERATION
	POPJ	P,		;RETURN

IFN	FTSTR, <
SADEND:	HRRZI	N,(A)		;PUT STRING VECTOR POINTER ADDRESS IN N
	TLO	N,(1B0)		;MAKE IT LOOK LIKE AN ADDRESS, NOT A POINTER
	POPJ	P,
>
;ROUTINE TO FETCH AND CHECK SUBSCRIPT

;CALL:	MOVE	C,DIMENSION
;	PUSHJ	P,SUBSCR

SUBSCR:	MOVE	E,@-1(P)		;GET SUBSCRIPT
	AOS	-1(P)		;SKIP ARGUMENT
	MOVE	E,(E)
	FAD	E,[XWD 233400,0];FIX SUBSCRIPT
	TLZ	E,777400
	CAMGE	E,C		;CHECK DIMENSION
	POPJ	P,
				;ON ERROR, FALL INTO DIMERR


;DIMENSION ERR ROUTINE

DIMERR:	SETZM	ODF
	PUSHJ	P,INLMES
	ASCIZ	/DIMENSION ERROR IN /
	JRST	GOSR2
	SUBTTL	MATRIX OPERATION RUN-TIME ROUTINES

IFN FTMAT, <
;SET MATRIX DIMENSION -- SDIM UUO


SDIMER:	MOVSI	C,1		;DONT FAIL IN SUBSCR
	PUSHJ	P,SUBSCR	;FIRST DIM
	HRLZ	A,E		;SAVE IT
	PUSHJ	P,SUBSCR	;SECOND DIM
	HRR	A,E
	AOBJP	A,MS0CHK		;GO CHECK DIMS AND STORE THEM
>
IFN FTMAT, <
;MATRIX OPERATION SETUP ROUTINE
;USE ENTRY POINT MS2 IF 2 ARGS, MS1 IF 1 ARG, MS0 OR MS0CHK IF 0 ARGS.
;ALL ENTRIES EXPECT MS0 EXCEPT DIMENSION [XWD ROWS,COLS]
;  OF DESTINATION TO BE SET UP IN A AND CHECK FOR ROOM
;  AND SET DIMENSION OF DESTINATION.
;AT CALL, LOCATION 40 CONTAINS THE ADDRS OF DESTINATION DOPE VECTOR,
;  RIGHT SIDE OF T1 CONTAINS ADDRS OF DOPE VECTOR FOR ARG 1
;  RIGHT SIDE OF T CONTAINS ADDRS OF DOPE VECTOR FOR ARG 2
;RIGHT SIDES OF T1,T,B ARE REPLACED WITH ADDRESSES OF ELEMENTS 0,0
;  OF ARG 1, ARG 2, DEST, RESPECTIVELY, WITHOUT CHANGING LEFT SIDES,
;  AND THE RESULTS ARE STORED IN TEMP1, TEMP2, AND TEMP3, RESPECTIVELY.
;THE MAXIMUM ROW NUMBER OF DEST IS STORED IN SB1M1, THE MAXIMUM
;  COLUMN NUMBER OF DEST IS STORED IN SB2M1
;E, T1, AND G ARE SET TO FIRST ROW NUMBER, FIRST COL NUMBER,
;  AND RELATIVE LOCATION OF FIRST ELEMENT, RESPECTIVELY
;IT IS INTENDED THAT E, T1, G, TEMP1, TEMP2, TEMP3 BE SET UP FOR
;  IMMEDIATE CALL TO MLP, AND THAT ELEMENTS OF FIRST
;  ARGUMENT, SECOND ARGUMENT, AND DESTINATION BE ACCESSED
;  BY INDIRECT ADDRESSING THROUGH TEMP1, TEMP2, AND TEMP3, RESPECTIVELY.

MS2:	HRR	T,(T)		;ADDRS OF FIRST ARG
MS1:	HRR	T1,(T1)		;ADDRS OF SECOND OR ONLY ARG
MS0CHK:	HRR	B,40		;DOPE VECTOR OF DEST
	HLLZ	X1,A		;CHECK NEW DIMENSION
	IMULI	X1,(A)		;X1 := (TOTAL SIZE)0
	CAMLE	X1,0(B)		;IS THERE ROOM IN ARRAY?
	JRST	DIMERR		;NO.  DIMENSION ERROR
	MOVEM	A,1(B)		;STORE NEW DIMENSION

MS0:	HRR	B,40		;ENTER HERE FOR NO DIM CHECK
	MOVE	A,1(B)		;FETCH DIMENSIONS
	SUB	A,[XWD 1,1]	;E := (MAX ROW)MAX COL
	HLRZM	A,SB1M1		;FIRST DIMENSION -1
	HRRZM	A,SB2M1		;SECOND DIMENSION -1

	HRR	B,(B)		;ADDRS OF DEST (LEAVE IN B FOR MINV)
	MOVEM	T1,TEMP1	;STORE FIRST XCT INSTRUCTION
	MOVEM	T,TEMP2		;STORE SECOND XCT INSTRUCTION
	MOVEM	B,TEMP3		;STORE THIRD XCT INSTRUCTION

;NOW SETUP E, T1, AND G FOR "MLP"

	SKIPE	E,SB1M1		;MORE THAN 0'TH ROW?
	MOVEI	E,1		;YES.  USE FIRST
	SKIPE	T1,SB2M1		;MORE THAN 0'TH COL
	MOVEI	T1,1		;YES.  USE FIRST
	MOVE	G,SB2M1		;CALCULATE FIRST ELT OF RESLT
	ADDI	G,1
	IMULI	G,(E)
	ADDI	G,(T1)
	POPJ	P,
>
IFN FTMAT, <
;MATRIX OPERATION MAIN LOOP

;ON CALLING, T, T1, G ARE SET UP TO ROW NUMBER, COL NUMBER, AND
;  REL LOC OF CURRENT ELEMENT IN DESTINATION MATRIX.
;MLP EXECUTES THE CONTENT OF TEMP1, TEMP2, TEMP3 FOR EACH
;  ELEMENT OF CURRENT ROE.  AT END OF ROW, MLP RETURNS
;  WITHOUT SKIP TO ALLOW ONCE-PER-ROW OPERATIONS TO BE PERFORMED.
;  WHEN ALL ROWS HAVE BEEN PROCESSED, MLP RETURNS WITH SKIP.
;NOTE SPECIAL CODING SO THAT ROW AND COLUMN VECTORS ARE
;  HANDLED CORRECTLY.

MLP:	XCT	TEMP1
	XCT	TEMP2
	XCT	TEMP3

	ADDI	G,1
	CAMGE	T1,SB2M1
	AOJA	T1,MLP
	SKIPE	SB2M1		;MORE THAN A 0'TH COL?
	AOJA	G,.+2		;YES.  SKIP 0'TH COL
	TDZA	T1,T1		;NO.  SET TO USE 0'TH COL
	MOVEI	T1,1		;YES AGAIN.  SET TO USE COL 1.

	CAML	E,SB1M1		;ALL ROWS USED?
	AOS	(P)		;YES.  SET FOR SKIP RETURN
	AOJA	E,CPOPJ		;BUMP ROW AND RETURN
>
IFN FTMAT, <
;MATRIX READ ROUTINE

;SET UP AND CALL MLP. FOR EACH ELEMENT, THE FOLLOWING
;ARE PERFORMED:
;	TEMP1:	PUSHJ	P,MTRELT
;	TEMP2:	...	;(SKIPPED)
;	TEMP3:	MOVEM	N,<DEST>(G)
;MTRELT READS A NUMBER INTO N

MTRDER:	MOVE	T1,[PUSHJ P,MTRELT]
	PUSHJ	P,DOREAD
	HRRZ	X1,@40		;GET ADRESS OF ZEROTH ELEMENT
	CAML	X1,SVRBOT	;IS THIS A STRING VECTOR?
	JRST	MTRDS		;ELEMENTS WILL BE STRINGS.
	HRLI	B,G(MOVEM N,)
MTRD1:	PUSHJ	P,MS0		;SET UP FOR LOOP
	SETZM	40		;NOP THE STORE THAT DATAER USES
MTRD2:	PUSHJ	P,MLP		;EXECUTE LOOP
	JRST	.-1		;NO ACTION ON ROW
	POPJ	P,

;ROUTINE CALLED BY MTRDER TO PRINT AN ELEMENT

MTRELT:	PUSHJ	P,DATAER
	JRST	CPOPJ1		;SKIP SECOND XCT

MTRDS:	MOVSI	T1,(SKIPA)
	MOVSI	B,G(STRIN)
	JRST	MTRD1


;MATRIX PRINT ROUTINE

;SET UP AND CALL MLP:
;	TEMP1:	PUSH	P,T
;	TEMP2:	PRNM	<FORMAT CODE>,<DEST>(G)
;	TEMP3:	POP	P,T
MTPRER:	MOVE	T1,[PUSH P,T1]	;TO SAVE T1 AROUND PRNM
	PUSHJ	P,MS0		;SET UP FOR LOOP
	HLL	B,40		;PICK UP UUO AC FIELD
	TLZ	B,777000	;CONSTRUCT PRNM INSTR
	SKIPE	SB1M1		;VECTOR?
	SKIPN	SB2M1
	JRST	.+3		;YES. ALLOW <CR> FORMAT
	TLNN	B,(Z 16,)		;OH, NO.  TREAT <RET> FORMAT ==<COMA> FORMAT.
	HRLI	B,(Z 3,)		;IT WAS <RET>FORM. CHANGE TO <COMA>FORM.
	HRRZ	X1,@40
	CAMGE	X1,SVRBOT	;NUMBER ARRAY?
	TLO	B,G(PRNM)	;YES, SETUP NUMBER UUO
	CAML	X1,SVRBOT	;STRING ARRAY?
	TLO	B,G(PRSTR)	;YSE SEUP STRING PRINT UUO.$
	MOVEM	B,TEMP2		;SET UP TEMP2 AND TEMP3
	MOVE	X1,[POP P,T1]
	MOVEM	X1,TEMP3

MTP2D:	PUSHJ	P,.+3		;TWO BLANK LINES
MTP1D:	PUSHJ	P,MLP		;PRINT A ROW
	JRST	MTPRE1		;NOW SEE WHETHER TO SPACE BETW ROWS
	PUSHJ	P,PCRLF
	PUSHJ	P,PCRLF
	POPJ	P,

MTPRE1:	SKIPE	SB1M1		;VECTOR OR ARRAY?
	SKIPN	SB2M1
	JRST	MTP1D		;ARRAY... SPACE BETW ROWS
	JRST	MTP2D		;VECTOR...DONT SPACE BETW ROWS
>
IFN FTMAT, <
;MATRIX ADD AND SUBTRACT ROUTINES

;SET UP AND CALL MLP:
;	TEMP1:	MOVE	N,<ARG 2>(G)	;OR MOVN
;	TEMP2:	FADR	N,<ARG 1>(G)
;	TEMP3:	MOVEM	N,<DEST>(G)
MTADER:	TLOA	T1,G(MOVE N,)		;MAKE ADD INSTR (T LOADED WITH MOVEI)
MTSBER:	HRLI	T1,G(MOVN N,)		;MAKE SUBTRACT INSTR
	HRLI	T,G(FADR N,)		;FETCH
	HRLI	B,G(MOVEM N,)
	MOVE	A,1(T)		;GET AND CHECK DIMENSIONS OF ARGS
	CAME	A,1(T1)
	JRST	DIMERR
	PUSHJ	P,MS2		;SET UP MATRIX LOOP
	JRST	MTRD2		;FINISH -- NO EACH ROW RTN


;MATRIX SCALE ROUTINE

;SET UP AND CALL MLP:
;	TEMP1:	MOVE	A,<ARG 1>(G)
;	TEMP2:	FMPR	A,N
;	TEMP3:	MOVEM	A,<DEST>(G)
MTSCER:	HRLI	T1,G(MOVE A,)
	MOVSI	T,(FMPR A,N)
MTSC1:	HRLI	B,G(MOVEM A,)
	MOVE	A,1(T1)
	PUSHJ	P,MS1
	JRST	MTRD2
>
IFN FTMAT, <
;MATRIX ZERO, IDENTITY, AND ONE ROUTINES

;SET UP AND CALL MLP:
;		..IDEN..	..ZERO..	..ONE..
;	TEMP1:	SETZM@TEMP3	SETZM @TEMP3	CAIA
;	TEMP2:	CAMN T,T1	CAIA		...
;	TEMP3:	MOVEM A,<DEST>(G)......................

MTIDER:	SKIPA	T,[CAMN E,T1]
MTZRER:	MOVSI	T,(CAIA)
	SKIPA	T1,[SETZM @TEMP3]
MTCNER:	MOVSI	T1,(CAIA)
MTCN1:	HRLI	B,G(MOVEM D,)
	MOVSI	D,(DEC 1.0)	;CONSTANT 1.0 TO STORE
	JRST	MTRD1		;GO FINISH WITH READ CODE


;MATRIX TRANSPOSE ROUTINE

;SET UP AND CALL MLP:
;A CONTAINS RELATIVE LOC OF CURRENT ELE IN SOURCE
;	TEMP1 :	FETCH SOURCE ELEMENT
;	TEMP2 :	UPDATE SOURCE INDEX
;	TEMP3 :	STORE DESTINATION ELEMENT


MTTNER:	MOVS	A,1(T1)		;FETCH DESTINATION DIMENSION
	HRLI	T1,A(MOVE N,)
	HLRZ	T,A		;E := ADDI A,<NBR ROWS>
	HRLI	T,(ADDI A,)
	HRLI	B,G(MOVEM N,)
	PUSHJ	P,MS1		;SET UP AND CHK DIMENSION

MTTN1:	MOVE	A,SB1M1		;A := <NBR ROWS>*COL + ROW
	ADDI	A,1
	IMUL	A,T1
	ADD	A,E

	PUSHJ	P,MLP		;MOVE A ROW
	JRST	MTTN1
	POPJ	P,
>


IFN FTMAT, <
;MATRIX MULTIPLY ROUTINE

;SET UP AND CALL MLP
;FOR EACH ELEMENT OF DESTINATION MATRIX, CALL SUBROUTINE
;	MYELT TO FORM THE DOT PRODUCT OF THE APPROPRIATE ROW AND COLUMN


MTMYER:	MOVE	A,1(T)		;CHECK DIMENSIONS
	HLRZ	D,1(T1)		;D := INNER DIMENSION
	CAIE	D,(A)		;SAME AS FIRST ARG?
	JRST	DIMERR		;NO
	HRR	A,1(T1)

	HRLI	T1,T1(MOVEI X2,)	;TO COMPUTE ADDRS OF 1ST ELT 2ND ARG
	HRLI	T,(MOVEI X1,)	;DITTO 1ST ARG
	HRLI	B,G(MOVEM N,)	;STORE INSTR
	PUSHJ	P,MS2		;SETUP NEW DIMENSIONS AND MLP ARGS
	MOVEI	X1,1(A)		;PREPARE TO SKIP ROW ZERO IF..
	CAIE	D,1		;INNER DIM=1?
	ADDM	X1,TEMP1
	MOVE	B,[PUSHJ P,MYELT]	;CALL TO ELT COMPUTATION
	EXCH	B,TEMP2

	CAIE	D,1		;INNER DIM 1?  (IE PROD OF VECTORS)
	ADDI	B,1		;NO.  SKIP 0'TH COL OF 1'ST ARG
	JUMPE	E,MTMY2		;DONT SKIP FIRST ROW IF ONLY 1

MTMY1:	ADDM	D,B		;NEXT ROW OF FIRST ARG
MTMY2:	PUSHJ	P,MLP
	JRST	MTMY1
	POPJ	P,

;SUBROUTINE TO COMPUTE ELEMENT OF PRODUCT
;X1 CONTAINS ADDRS OF 1ST ELT OF 1ST ARG FOR DOT PRODUCT,
;  AFTER FIRST XCT BELOW, X2 CONTAINS ADDRS OF SAME FOR 2ND ARG

MYELT:	XCT	B
	MOVEI	N,0		;TO ACCUMULATE DOT PRODUCT
	MOVEI	C,-1(D)	;NUMBER OF ADDS= REAL INNER DIMENSION

MYEL1:	PUSH	P,R
	MOVE	R,(X1)		;PRODUCT OF 2 ELTS
	FMPR	R,(X2)
	FADR	N,R		;ADD INTO DOT PRODUCT
	ADDI	X2,1(A)		;NEXT ROW OF 2ND ARG
	POP	P,R
	SOJLE	C,CPOPJ		;DONE?
	AOJA	X1,MYEL1	;NO.  TO NEXT ELT
>
	SUBTTL	RUN-TIME MATRIX INVERTER

IFN FTMAT, <
;SUBROUTINE TO CALL MATRIX INVERTER

MTIVER:	MOVS	A,1(T1)		;MAKE SURE SQUARE MATRIX
	CAME	A,1(T1)
	JRST	DIMERR

	HRLI	T1,G(SKIPA A,)	;MOVE DESTINATION
	PUSHJ	P,MTSC1		;(USE MTCNER CODE)
	SKIPE	SB1M1	;GO INVERT UNLESS ONLY ELT IS (0,0)
	JRST	MINVB

	SUBI	B,3
	MOVEM	B,TEMP3		;ONLY ELEMENT IS (0,0)
	AOS	SB1M1		;FOOL MINV INTO THINKING ITS (1,1)
	JRST	MINVB

;THIS PORTION OF THE MAT INVERSE PROG RUNS IN ACS 0-7

JLOOP:
	PHASE	0

ZERO:	CAMN	JX,NT		;SKIP SAME COL
	JRST	JXIT
	MOVE	IX,@TEMP1	;A(I,J)=A(I,J)+A(NT,J)*A(I,NT)
	FMPR	IX,(KX)	;***
MOD:	FADRM	IX,0(JX)	;ADDR MODIFIED BY OUTER LOOP
JXIT:	CAMGE	JX,SB1M1	;LOOP DONE?
	AOJA	JX,ZERO
	JRST	IXIT2		;YES RETURN

	DEPHASE

;SOME AC DEFS FOR MINV

NT=10		;OUTERMOST LOOP INDEX
IX=11		;I SUBSCRIPT
JX=12		;J SUBSCRIPT
KX=13		;SCRATCH INDEX REG
LX=14		;    "     "    "
TAC1=16		;   "   (MUST BE SAVE & RESTORED)
>
IFN FTMAT, <
;MAIN ROUTINE ENTERS HERE TO SET UP REGS
;ROUTINE EXPECTS	1) ARRAY ADDR IN TEMP3
;			2) ORDER OF ARRAY IN SB1M1
;ROUTINE USES	1) VECT1 & VECT2 AS SCRATCH
;		2) SB2M1 AS CNT OF ELEMENTS / ROW

MINVB:	HRRZS	TEMP3		;MAKE SURE ADDR ONLY
	PUSH	P,TAC1
	MOVE	TAC1,SB1M1	;GET ORDER
	ADDI	TAC1,1		;ADD ONE FOR 0'TH ROW & COL
	MOVEM	TAC1,SB2M1	;SAVE IN SB2
	MOVSI	TAC1,(1.0)	;INIT DETERM.
	MOVEM	TAC1,DETER
	HRLZI	TAC1,JX		;SET INDEX REG IN
	HLLZM	TAC1,TEMP1	;TEMP1 FOR INDIRECT
	MOVE	TAC1,[XWD JLOOP,ZERO]
	BLT	TAC1,7		;PUT JLOOP INTO ACS

	MOVEI	NT,1		;INITIALIZE OUTER LOOP
MINVLP:	MOVE	TAC1,NT
	IMUL	TAC1,SB2M1	;CALC (NT,NT) SUBSCR
	ADD	TAC1,NT
	ADD	TAC1,TEMP3	;***
	MOVEM	TAC1,TEMP2	;SAVE IT FOR LATER
	CAMN	NT,SB1M1	;LAST ITER?
	JRST	FOUND1		;SAVE SEARCH STUFF
	MOVM	TAC1,(TAC1)	;GET A(NT,NT)
	MOVE	IX,NT		;INITIALIZE SEARCH

LUPI:	MOVE	KX,SB2M1	;CALC I INDEX
	IMUL	KX,IX
	ADD	KX,TEMP3	;***
	MOVE	JX,NT		;INIT J INDEX
LUPJ:	MOVE	LX,KX
	ADD	LX,JX		;FINISH INDEX FOR ELEMENT
	MOVM	LX,(LX)		;GET IT
	CAMGE	LX,TAC1		;IS IT LARGER THAN PRESENT
	JRST	LUPEND		;NO
	MOVE	TAC1,LX		;YES SAVE IT
	MOVEM	IX,VECT1(NT)	;AND INDEXES
	MOVEM	JX,VECT2(NT)
LUPEND:	CAMGE	JX,SB1M1	;END OF J LOOP LOGIC
	AOJA	JX,LUPJ
	CAMGE	IX,SB1M1
	AOJA	IX,LUPI
>
IFN FTMAT, <
FOUND:	CAMN	NT,VECT1(NT)
	MOVNS	DETER
	CAMN	NT,VECT2(NT)
	MOVNS	DETER
	PUSHJ	P,FSWAP
FOUND1:	MOVE	TAC1,@TEMP2	;GET PIVOT ELEMENT
	JUMPE	TAC1,SING	;TEST FOR SINGULARITY
	MOVEM	TAC1,PIVOT	;SAVE IT
	FMPRM	TAC1,DETER	;PERPETUATE DETERM
	MOVSI	TAC1,(1.0)	;1./A(NT,NT)
	FDVRM	TAC1,PIVOT	;***

	MOVEI	IX,1		;SET UP I
ILOOP:	CAMN	IX,NT		;SKIP SAME ROW
	JRST	IXIT		;AS PIVOT ROW
	MOVE	LX,SB2M1	;CALCULATE ALL ROW OFFSETS
	IMUL	LX,IX
	ADD	LX,TEMP3	;LX= IX*N+A
	MOVE	KX,LX
	ADD	KX,NT		;KX=LX+NT
	MOVN	TAC1,PIVOT	;GET -PIVOT
	FMPRM	TAC1,(KX)	;A(I,NT)=A(I,NT)/(-A(NT,NT))
	MOVEI	JX,1		;SET J LOOP START
	MOVE	TAC1,SB2M1
	IMUL	TAC1,NT
	ADD	TAC1,TEMP3	;TAC=NT*N+A
	HRRM	TAC1,TEMP1	;STORE FOR @TEMP1(JX)
	HRR	MOD,LX	;SAT ADDR IN INNER LOOP
	PUSH	P,IX
	JRST	ZERO		;GO
IXIT2:	POP	P,IX

IXIT:	CAMGE	IX,SB1M1	;RETURN HERE FROM ACS
	AOJA	IX,ILOOP
	MOVEI	JX,1		;SET LOOP FOR LAST COL
	MOVE	TAC1,PIVOT	;GET PIVOT
LCOL:	FMPRM	TAC1,@TEMP1	;A(NT,J)=A(NT,J)/A(NT,NT)
	CAMGE	JX,SB1M1	;DONE
	AOJA	JX,LCOL
	MOVEM	TAC1,@TEMP2	;A(NT,NT)=PIVOT
	CAMGE	NT,SB1M1	;INVERSE DONE?
	AOJA	NT,MINVLP	;NOPE, ITER AGAIN
>
IFN FTMAT, <
;HERE WHEN INVERSE DONE PUT MATRIX BACK TOGETHER

	MOVE	NT,SB1M1	;DO LOOP IN REVERSE ORDER
INVFIX:	SOJLE	NT,OUT		;FINISHED
	PUSHJ	P,BSWAP		;SWAP ROW - COL IN REV.
	JRST	INVFIX

BSWAP:	MOVE	KX,VECT2(NT)
	MOVE	LX,VECT1(NT)	;SET REGS
	JRST	SWAP
FSWAP:	MOVE	KX,VECT1(NT)
	MOVE	LX,VECT2(NT)
SWAP:	MOVE	TAC1,NT
	IMUL	TAC1,SB2M1
	IMUL	KX,SB2M1	;CALC BOTH ROW OFFSETS
	ADD	TAC1,TEMP3
	ADD	KX,TEMP3	;***
	MOVEI	JX,1
	HRLI	TAC1,JX
	HRLI	KX,JX
SWP1:	MOVE	IX,@TAC1
	EXCH	IX,@KX		;EXCHANGE ITEMS IN ROWS
	MOVEM	IX,@TAC1
	CAMGE	JX,SB1M1
	AOJA	JX,SWP1
	MOVEI	IX,1
	MOVE	TAC1,NT
	MOVE	KX,SB2M1
	ADD	KX,TEMP3	;GET COL ADDR
	HRLI	TAC1,KX
	HRLI	LX,KX
SWP2:	MOVE	JX,@LX
	EXCH	JX,@TAC1
	MOVEM	JX,@LX
	CAML	IX,SB1M1	;CHECK DONE
	POPJ	P,		;RETURN
	ADD	KX,SB2M1	;TO NEXT COL
	AOJA	IX,SWP2

;HERE TO RETURN OR MAKE SINGULAR

SING:	SETZB	ZERO,DETER
OUT:	POP	P,TAC1
DETB:	MOVE	ZERO,DETER
	POPJ	P,0


>
	SUBTTL	INTRINSIC FUNCTIONS (ADAPTED FROM LIB4 V.005)
;SINGLE PRECISION ABSOLUTE VALUE FUNCTION
;ABS AND IABS RETURN THE ABSOLUTE VALUE OF N SINGLE PRECISION
;ARGUMENT.

;THE ANSWER IS RETURNED IN ACCUMULATOR N

ABSB:	MOVMS	N		;GET MAGNITUDE OF ARGUMENT
	POPJ	P,		;EXIT
;FLOATING POINT SINGLE PRECISION ARCTANGENT FUNCTION
;ATAN(X) = X(B0+A1(Z+B1-A2(Z+B2-A3(Z+B3)**-1)**-1)**-1)
;WHERE Z=X^2, IF 0<X<=1

;IF X>1, THEN ATAN(X) = PI/2 - ATAN(1/X)
;IF X>1, THEN RH(A) =-1, AND LH(A) = -SGN(X)
;IF X<1, THEN RH(A) = 0, AND LH(A) =  SGN(X)

ATANB:				;ENTRY TO ARCTANGENT ROUTINE
	MOVM	T, N		;GET ABSF OF ARGUMENT
	CAMG	T, A1		;IF A<2^-33, THEN RETURN WITH...
	POPJ	P,		;ATAN(X)=X
	HLLO	B, N		;SAVE SIGN, SET RH(A) = -1
	CAML	T, A2		;IF A>2^33, THEN RETURN WITH
	JRST	AT4		;ATAN(X) = PI/2
	MOVSI	T1, (1.0)	;FORM 1.0 IN T1
	CAMG	T, T1		;IS ABSF(X)>1.0?
	TRZA	B, -1		;IF T .LE. 1.0, THEN RH(A) = 0
	FDVM	T1, T		;B IS REPLACED BY 1.0/B
	TLC	B, (B)		;XOR SIGN WITH .G. 1.0 INDICATOR
	MOVEM	T, C3		;SAVE THE ARGUMENT
	FMP	T, T		;GET B^2
	MOVE	T1, KB3		;PICK UP N CONSTANT
	FAD	T1, T		;ADD B^2
	MOVE	N, KA3		;ADD IN NEXT CONSTANT
	FDVM	N, T1		;FORM -A3/(B^2 + B3)
	FAD	T1, T		;ADD B^2 TO PARTIAL SUM
	FAD	T1, KB2		;ADD B2 TO PARTIAL SUM
	MOVE	N, KA2		;PICK UP -A2
	FDVM	N, T1		;DIVIDE PARTIAL SUM BY -A2
	FAD	T1, T		;ADD B^2 TO PARTIAL SUM
	FAD	T1, KB1		;ADD  B1 TO PARTIAL SUM
	MOVE	N, KA1		;PICK UP A1
	FDV	N, T1		;DIVIDE PARTIAL SUM BY A1
	FAD	N, KB0		;ADD B0
	FMP	N, C3		;MULTIPLY BY ORIGINAL ARGUMENT
	TRNE	B, -1		;CHECK .G. 1.0 INDICATOR
	FSB	N, PIOT		;ATAN(N) = -(ATAN(1/A)-PI/2)
	CAIA			;SKIP
AT4:	MOVE	N, PIOT		;GET PI/2 AS ANSWER
NEGANS:	SKIPGE	B		;LH(A)= -SGN(T) IF B>1.0
	MOVNS	N		;NEGATE ANSWER
	POPJ	P,		;EXIT

A1:	145000000000		;2**-33
A2:	233000000000		;2**33
KB0:	176545543401		;0.1746554388
KB1:	203660615617		;6.762139240
KB2:	202650373270		;3.316335425
KB3:	201562663021		;1.448631538
KA1:	202732621643		;3.709256262
KA2:	574071125540		;-7.106760045
KA3:	600360700773		;-0.2647686202
PIOT:	201622077325		;PI/2
;FLOATING POINT TRUNCATION FUNCTION
;TRUNCATES FRACTIONAL PART OF FLOATING POINT NUMBER
;AND RETURNS ANSWER AS N FLOATING POINT NUMBER. THE
;ALGORITHM MAKES USE OF THE NORMALIZING PROPERTIES OF FAD.
;ROUTINE EXITS WITH (T)=ZERO IF NUMBER WAS AN INTEGER.

AINTB:	MOVE	B,N		;SAVE ARGUMENT
	MOVMS	N		;GET ABSF(ARG)
	SKIPGE	B		;NEGATIVE?
	FAD	N,ALMST1	;YES. MAKE AINT[-2.3]=-3  ETC.
	CAML	N,MOD1		;IS ARGUMENT<=2**26?
	JRST	NEGANS		;YES; IT MUST BE AN INTEGER ALREADY
	FAD	N,MOD1
	FSB	N,MOD1		;NOW FRACTIONAL PART HAS BEEN LOST
	JRST	NEGANS		;CHECK SIGN AND EXIT.

MOD1:	XWD 233400,000000	; 2**26

ALMST1:	XWD 200777,777777	;1.0-<SMALLEST QUANTITY>
;FLOATING POINT SINGLE PRECISION LOGARITHM FUNCTION
;LOG(ABSF(X)) IS CALCULATED BY THE SUBROUTINE, AND AN
;ARGUMENT OF ZERO IS RETURNED AS MINUS INFINITY. THE ALGORITHM IS

;LOGE(X) = (I + LOG2(F))*LOGE(2)
;WHERE X = (F/2)*2^(I+1), AND LOG2(F) IS GIVEN BY
;LOG2(F) = C1*Z + C3*Z^3 + C5*Z^5 - 1/2
;AND Z = (F-SQRT(2))/(F+SQRT(2))

ALOGB:	JUMPL	N,ALOGB1	;TEST FOR LOG OF NEG NUMBER.
ALOGB2:	MOVMS	N		;GET ABSF(X)
	JUMPE	N, LZERO	;CHECK FOR ZERO ARGUMENT
	CAMN	N, ONE		;CHECK FOR 1.0 ARGUMENT
	JRST	ZERANS		;IT IS 1.0 RETURN ZERO ANS.
	ASHC	N, -33		;SEPARATE FRACTION FROM EXPONENT
	ADDI	N, 211000	;FLOAT THE EXPONENT AND MULT. BY 2
	MOVSM	N, C3		;NUMBER NOW IN CORRECT FL. FORMAT
	MOVSI	N, 567377	;SET UP -401.0 IN N
	FADM	N, C3		;SUBTRACT 401 FROM EXP.*2
	ASH	T, -10		;SHIFT FRACTION FOR FLOATING
	TLC	T, 200000	;FLOAT THE FRACTION PART
	FAD	T, L1		;B = T-SQRT(2.0)/2.0
	MOVE	N, T		;PUT RESULTS IN N
	FAD	N, L2		;A = N+SQRT(2.0)
	FDV	T, N		;B = B/A
	MOVEM	T, LZ		;STORE NEW VARIABLE IN LZ
	FMP	T, T		;CALCULATE Z^2
	MOVE	N, L3		;PICK UP FIRST CONSTANT
	FMP	N, T		;MULTIPLY BY Z^2
	FAD	N, L4		;ADD IN NEXT CONSTANT
	FMP	N, T		;MULTIPLY BY Z^2
	FAD	N, L5		;ADD IN NEXT CONSTANT
	FMP	N, LZ		;MULTIPLY BY Z
	FAD	N, C3		;ADD IN EXPONENT TO FORM LOG2(X)
	FMP	N, L7		;MULTIPLY TO FORM LOGE(X)
	POPJ	P,		;EXIT

LZERO:	PUSH	P,ODF
	SETZM	ODF
	PUSHJ	P,INLMES	
	ASCIZ /LOG OF ZERO IN /
	PUSHJ	P,GOSR3		;PRINT LINE NUMBER.
	MOVE	N, MIFI		;PICK UP MINUS INFINITY
	POP	P,ODF
	POPJ	P,		;EXIT

;COMMON EXITS:
ZERANS:	SETZI	N,		;MAKE ARG ZERO
	POPJ	P,		;EXIT

;CONSTANTS FOR ALOGB

ONE:	201400000000
L1:	577225754146		;-0.707106781187
L2:	201552023632		;1.414213562374
L3:	200462532521		;0.5989786496
L4:	200754213604		;0.9614706323
L5:	202561251002		;2.8853912903
ALOGB1:	PUSH	P,N		;SAVE ARGUMENT
	PUSH	P,ODF
	SETZM	ODF
	PUSHJ	P,INLMES
	ASCIZ /LOG OF NEGATIVE NUMBER IN /
	PUSHJ	P,GOSR3		;PRINT LINE NUMBER
	POP	P,ODF
	POP	P,N		;GET ARG
	JRST	ALOGB2		;USE ABS VALUE.

L7:	200542710300		;0.69314718056
MIFI:	XWD 400000,000001	;GOAL POSTS. LARGEST NEGATIVE NUMBER.

IFN FTMAT, <
;NUMB RETURNS THE NUMBER OF ELEMENTS IN THE LAST VECTOR THAT WAS INPUT
;BY "MAT INPUT"


NUMB:	MOVE	N,NUMRES
	POPJ	P,

>


;THE SIGNUM FUNCTION

SGNB:	JUMPE	N,ZERANS	;TEST FOR ZERO.
	MOVE	B,N		;SAVE SIGN
	MOVSI	N,(1.0)		;ANSWER IS 1.0 * ...
	JRST	NEGANS		;SIGN.


;FLOATING POINT SINGLE PRECISION SINE AND COSINE FUNCTION
;THE ARGUMENT IS IN RADIANS.
;ENTRY POINTS ARE SIN AND COS.
;COS CALLS SIN TO CALCULATE SIN(PI/2 + X)

;THE ROUTINE CALCULATES SINES AFTER REDUCING THE ARGUMENT TO
;THE FIRST QUADRANT AND CHECKING THE OVERFLOW BITS TO DETERMINE
;THE QUADRANT OF THE ORIGINAL ARGUMENT
;000 - 1ST QUADRANT
;001 - 2ND QUADRANT, X=-(X-PI)
;010 - 3RD QUADRANT, X=-(X-PI)
;011 - 4TH QUADRANT, X=X-3*PI/2-PI/2
;THE ALGORITHM USES N MODIFIED TAYLOR SERIES TO CALCULATE
;THE SINE OF THE NORMALIZED ARGUMENT.


COSB:				;ENTRY TO COSINE RADIANS ROUTINE
	FADR	N,PIOT		;ADD PI/2
				;FALL INTO SINE ROUTINE

SINB:				;ENTRY TO SINE RADIANS ROUTINE
	MOVE	T, N		;PICK UP THE ARGUMENT IN T
	MOVEM	T, SX		;SAVE IT
	MOVMS	T		;GET ABSF OF ARGUMENT
	CAMG	T, SP2		;SINX = X IF X<2^-10
	POPJ	P,		;EXIT WITH ANS=ARG
	FDV	T, PIOT		;DIVIDE X BY PI/2
	CAMG	T, ONE		;IS X/(PI/2) < 1.0?
	JRST	S2		;YES, ARG IN 1ST QUADRANT ALREADY
	MULI	T, 400		;NO, SEPARATE FRACTION AND EXP.
	ASH	T1, -202(T)	;GET X MODULO 2PI
	MOVEI	T, 200		;PREPARE FLOATING FRACTION
	ROT	T1, 3		;SAVE 3 BITS TO DETERMINE QUADRANT
	LSHC	T, 33		;ARGUMENT NOW IN RANGE (-1,1)
	FAD	T, SP3		;NORMALIZE THE ARGUMENT
	JUMPE	T1, S2		;REDUCED TO FIRST QUAD IF BITS 00
	TLCE	T1, 1000		;SUBTRACT 1.0  FROM ARG IF BITS ARE
	FSB	T, ONE		;01 OR 11
	TLCE	T1, 3000		;CHECK FOR FIRST QUADRANT, 01
	TLNN	T1, 3000		;CHECK FOR THIRD QUADRANT, 10
	MOVNS	T		;01,10

S2:	SKIPGE	SX		;CHECK SIGN OF ORIGINAL ARG
	MOVNS	T		;SIN(-X) = -SIN(X)
	MOVEM	T, SX		;STORE REDUCED ARGUMENT
	FMPR	T, T		;CALCULATE X^2
	MOVE	N, SC9		;GET FIRST CONSTANT
	FMP	N, T		;MULTIPLY BY X^2
	FAD	N, SC7		;ADD IN NEXT CONSTANT
	FMP	N, T		;MULTIPLY BY X^2
	FAD	N, SC5		;ADD IN NEXT CONSTANT
	FMP	N, T		;MULTIPLY BY X^2
	FAD	N, SC3		;ADD IN NEXT CONSTANT
	FMP	N, T		;MULTIPLY BY X^2
	FAD	N, PIOT		;ADD IN LAST CONSTANT
S2B:	FMPR	N, SX		;MULTIPLY BY X
	POPJ	P,		;EXIT



SC3:	577265210372		;-0.64596371106
SC5:	175506321276		;0.07968967928
SC7:	606315546346		;0.00467376557
SC9:	164475536722		;0.00015148419

SP2:	170000000000		;2**-10
SP3:	0			;0
CD1:	90.0
SCD1:	206712273406

;FLOATING POINT SINGLE PRECISION SQUARE ROOT FUNCTION
;THE SQUARE ROOT OF THE ABSOLUTE VALUE OF THE ARGUMENT IS
;CALCULATED. THE ARGUMENT IS WRITTEN IN THE FORM
;	X=	F*(2**2B)	WHERE 0<F<1
;SQRT(X) IS THEN CALCULATED AS (SQRT(X))*(2**B)
;SQRT(F) IS CALCULATED BY N LINEAR APPROXIMATION, THE NATURE
;OF WHICH DEPENDS ON WHETHER 1/4 < F < 1/2 OR 1/2 < F < 1,
;FOLLOWED BY TWO ITERATIONS OF NEWTON'S METHOD.


SQRTB:				;ENTRY TO SQUARE ROOT ROUTINE
	MOVE	T, N		;PICK UP THE ARGUMENT IN T
	JUMPL	T,SQRMIN	;SQRT OF NEGATIVE NUMBER?
SQRT1:	JUMPE	T, ZERANS	;CHECK FOR ARGUMENT OF ZERO
	ASHC	T, -33		;PUT EXPONENT IN T, FRACTION IN T1
	SUBI	T, 201		;SUBTRACT 201 FROM EXPONENT
	ROT	T, -1		;CUT EXP IN HALF, SAVE ODD BIT
	HRRM	T,EX1		;SAVE FOR FUTURE SCALING OF ANS
				;IN FSC N,. INSTRUCTION
	LSH	T, -43		;GET BIT SAVED BY PREVIOUS INST.
	ASH	T1, -10		;PUT FRACTION IN PROPER POSITION
	FSC	T1, 177(T)	;PUT EXPONENT OF FRACT TO -1 OR 0
	MOVEM	T1, N		;SAVE IT. 1/4 < F < 1
	FMP	T1, SQCON1(T)	;LINEAR FIRST APPROX,DEPENDS ON
	FAD	T1, SQCON2(T)	;WHETHER 1/4<F<1/2 OR 1/2<F<1.
	MOVE	T, N		;START NEWTONS METHOD WITH FRAC
	FDV	T, T1		;CALCULATE X(0)/X(1)
	FAD	T1, T		;X(1) + X(0)/X(1)
	FSC	T1, -1		;1/2(X(1) + X(0)/X(1))
	FDV	N, T1		;X(0)/X(2)
	FADR	N, T1		;X(2) + X(0)/X(2)
	XCT	EX1
	POPJ	P,		;EXIT

SQCON1:	0.8125			;CONSTANT, USED IF 1/4<FRAC<1/2
	0.578125		;CONSTANT, USED IF 1/2<FRAC<1
SQCON2:	0.302734		;CONSTANT, USED IF 1/4<FRAC<1/2
	0.421875		;CONSTANT, USED IF 1/2<FRAC<1

SQRMIN:	PUSH	P,T	;SAVE ARG
	PUSH	P,ODF
	SETZM	ODF
	PUSHJ	P,INLMES
	ASCIZ /SQRT OF NEGATIVE NUMBER IN /
	PUSHJ	P,GOSR3		;PRINT LINE NUMBER
	POP	P,ODF
	POP	P,T		;GET ARG
	MOVMS	T
	JRST	SQRTB+1		;USE ABSOLUTE VALUE
;TANGENT/COTANGENT -- USE SIN AND COS
;SHALL WE GET N REAL TAN ROUTINE?

;TANGENT (X) = SIN(X)/COS(X)
;COTAN (X)=TAN(PI/2-X)

COTB:	MOVNS	N		;CALCULATE -X...
	FADR	N,PIOT		; PLUS PI/2
TANB:	MOVEM	N,C3		;SAVE IT
	PUSHJ	P,COSB		;CALCULATE COSINE
	JUMPE	N,TANB1		;IS COS=ZERO?
	EXCH	N,C3		;SAVE COS, GET ARGUMENT
	PUSHJ	P,SINB		;CALCULATE SINE
	FDVR	N,C3		;CALCULATE SIN/COS
	POPJ	P,		;EXIT

TANB1:	PUSH	P,ODF
	SETZM	ODF
	PUSHJ	P,INLMES
	ASCIZ ?TAN OF PI/2 OR COTAN OF ZERO IN ?
	PUSHJ	P,GOSR3		;PRINT LINE NUMBER AND EXIT WITH LARGE ANSWER.
	HRLOI	N,377777
	POPJ	P,
;FLOATING POINT SINGLE PRECISION EXPONENTIAL FUNCTION
;THE ARGUMENT IS RESTRICTED TO THE FOLLOWING RANGE
;	-88.028<X<88.028
;IF X<-88.028, THE PROGRAM RETURNS ZERO AS THE ANSWER
;IF X>88.028, THE PROGRAM RETURNS +INFINITY AS THE ANSWER
;THE RANGE OF THE ARGUMENT IS REDUCED AS FOLLOWS:
;EXP(X) = 2**(X*LOG(B)BASE2) = 2**(M+F)
;WHERE M IS AN INTEGER AND F IS N FRACTION
;2**M IS CALCULATED BY ALGEBRAICALLY ADDING M TO THE EXPONENT
;OF THE RESULT OF 2**F. 2**F IS CALCULATED AS

;2**F = 2(0.5+F(A+B*F^2 - F-C(F^2 + D)**-1)**-1

;THE ROUTINE HAS THE FOLLOWING CALLING SEQUENCE:
;	PUSHJ	P, EXP
;
;THE ARGUMENT IS IN N
;THE ANSWER IS RETURNED IN ACCUMULATOR N


	EXTERN	EX1

EXPB:				;ENTRY TO EXPONENTIAL ROUTINE
	MOVE	T, N		;PICK UP THE ARGUMENT IN T
	MOVM	N, T		;GET ABSF(X)
	CAMLE	N, E7		;IS ARGUMENT IN PROPER RANGE?
	JRST	EXTOLG		;EXP TOO LARGE.;##MSG +CON OR STOP?

EXP1:	SETZM	ES2		;INITIALIZE ES2
	MULI	T, 400		;SEPARATE FRACTION AND EXPONENT
	TSC	T, T		;GET N POSITIVE EXPONENT
	MUL	T1, E5		;FIXED POINT MULTIPLY BY LOG2(B)
	ASHC	T1, -242(T)	;SEPARATE FRACTION AND INTEGER
	AOSG	T1		;ALGORITHM CALLS FOR MULT. BY 2
	AOS	T1		;ADJUST IF FRACTION WAS NEGATIVE
	HRRM	T1, EX1		;SAVE FOR FUTURE SCALING
	ASH	A, -10		;MAKE ROOM FOR EXPONENT
	TLC	A, 200000	;PUT 200 IN EXPONENT BITS
	FADB	A, ES2		;NORMALIZE, RESULTS TO A AND ES2
	FMP	A, A		;FORM X^2
	MOVE	N, E2		;GET FIRST CONSTANT
	FMP	N, A		;E2*X^2 IN N
	FAD	A, E4		;ADD E4 TO RESULTS IN A
	MOVE	T, E3		;PICK UP E3
	FDV	T, A		;CALCULATE E3/(F^2 + E4)
	FSB	N, T		;E2*F^2-E3(F^2 + E4)**-1
	MOVE	T1, ES2		;GET F AGAIN
	FSB	N, T1		;SUBTRACT FROM PARTIAL SUM
	FAD	N, E1		;ADD IN E1
	FDVM	T1, N		;DIVIDE BY F
	FAD	N, E6		;ADD 0.5
	XCT	EX1		;SCALE THE RESULTS
	POPJ	P,		;EXIT

E1:	204476430062		;9.95459578
E2:	174433723400		;0.03465735903
E3:	212464770715		;617.97226953
E4:	207535527022		;87.417497202
E5:	270524354513		;LOG(B), BASE 2
E6:	0.5
E7:	207540071260		;88.028
EXTOLG:	PUSH	P,ODF
	SETZM	ODF
	JUMPG	T,EXTOL1
	PUSHJ	P,INLMES
	ASCIZ	/
UNDERFLOW IN EXP IN /
	PUSHJ	P,GOSR3
	SETZ	N,
	POP	P,ODF
	POPJ	P,
EXTOL1:	PUSHJ	P,INLMES
	ASCIZ /
OVERFLOW IN EXP IN /
	PUSHJ	P,GOSR3		;PRINT LINE NUMBER
	HRLOI	N,377777	;GET LARGEST ANSWER AND RETURN.
	POP	P,ODF
	POPJ	P,
;SINGLE PRECISION EXP.2 FUNCTION
;THIS ROUTINE CALCULATES A FLOATING POINT NUMBER TO A FIXED
;POINT POWER. THE CALCULATION IS A**B, WHERE T IS OF THE FORM

;	T=Q(0) + Q(1)*2 + Q(2)*4 + ...WHERE Q(I)=0 OR 1

;THE BASE IS IN ACCUMULATOR N
;AND THE EXPONENT IS IN ACCUMULATOR (N+1) WHEN THE ROUTINE IS
;CALLED. THE ANSWER IS RETURNED IN ACCUMULATOR N.
;EXP.2 IS CALLED ONLY BY EXP.3.  IT IS GUARANTEED THAT THE
;BASE AND THE EXPONENT ARE NON-ZERO.


	EXTERN	LIBFLG
EXP2.0:	PUSH	P,T		;SAVE FOR OVER/UNDERFLOW CHECKING.
	PUSH	P,N
	SETZM	LIBFLG		;CLEAR THE OVER/UNDERFLOW FLAG.
	MOVSI	T1,(1.0)
	JUMPGE	T,FEXP2
	MOVMS	T
	FDVRM	T1,N
	MOVSI	T1,(1.0)
	JRST	FEXP2
FEXP1:	FMP	N, N		;FORM A**N, FLOATING POINT
	LSH	T, -1		;SHIFT EXPONENT FOR NEXT BIT
FEXP2:	TRZE	T, 1		;IS THE BIT ON?
	FMP	T1, N		;YES, MULTIPLY ANSWER BY A**N
	JUMPN	T, FEXP1	;UPDATE A**N UNLESS ALL THROUGH
	MOVE	N, T1		;PICK UP RESULT FROM T1
	SKIPE	LIBFLG		;IF OVER/UNDERFLOW,
	JRST	FEXP4		;GO TO FEXP4.
	POP	P,T		;CLEAR OFF PLIST.  DO NOT POP INTO N!!!!
	POP	P,T		;(BECAUSE THE ANSWER IS IN N).
	POPJ	P,		;EXIT

FEXP4:	POP	P,N		;OVER/UNDERFLOW ROUTINE.
	POP	P,T
	MOVM	T1,N
	CAMG	T1,ONE
	JRST	.+3		;/BASE/>1,EXP>0 MEANS OVER.
	JUMPG	T,.+3		;/BASE/>1,EXP<0 MEANS UNDER.
	JRST	EXP3D3		;/BASE/<1,EXP>0 MEANS UNDER.
	JUMPG	N,EXP3D3	;/BASE/<1,EXP<0 MEANS OVER.
	JUMPG	N,.+3		;THIS IS OVER. WHAT IS THE SIGN?
	TRNE	T,1
	JRST	FEXP5
	PUSHJ	P,EXP3D2
	HRLOI	N,377777
	POPJ	P,
FEXP5:	PUSHJ	P,EXP3D2
	MOVE	N,MIFI
	POPJ	P,
;SINGLE PRECISION FORTRAN IV EXP.3 FUNCTION
;THIS ROUTINE CALCULATES A FLOATING POINT NUMBER RAISED TO A
;FLOATING POINT POWER. THE CALCULATION IS
;	A**B= EXP(B*LOG(N))

;IF THE EXPONENT IS AN INTEGER THE 
;RESULT WILL BE COMPUTED USING "EXP2.0" .

;THE CALLING SEQUENCE FOR THE ROUTINE IS AS FOLLOWS:
;	PUSHJ	P, EXP3.0
;THE BASE IS IN ACCUMULATOR N
;AND THE EXPONENT IS IN ACCUMULATOR (N+1) WHEN THE ROUTINE
;IS CALLED. THE RESULT IS RETURNED IN ACCUMULATOR N.




EXP3.0:	JUMPE	T,EXP3A		;IS EXPONENT ZERO?
	JUMPN	N,EXP3A0	;IS BASE ZERO?
	JUMPL	T,EXPB3		;ERROR IF BASE=0, EXP <0.
	POPJ	P,		;IMMED. RETURN IF BASE=0, EXP>=0.
EXP3A0:	MOVM	A,T		;SET UP ABS VAL OF EXPON FOR SHIFTING
	JUMPL	N,EXP3C		;IS BASE NEGATIVE?
EXP3A1:	MOVEI	T1,0		;CLEAR AC T1 TO ZERO
	LSHC	T1,11		;SHIFT 9 PLACES LEFT
	SUBI	T1,200		;TO OBTAIN SHIFTING FACTOR
	JUMPLE	T1,EXP3GO	;IS T1 > 0
	HRRZ	B,T1		;SET UP B AS AN INDEX REG.
	CAILE	B,43
	JRST	EXP3GO
	MOVEI	T1,0		;CLEAR OUT AC T1
	LSHC	T1,(B)		;SHIFT LFT BY CONTENTS OF B
	JUMPN	A,EXP3GO	;IS EXPONENT AN INTEGER ?
	SKIPGE	T		;YES, WAS  IT NEG. ?
	MOVNS	T1		;YES, NEGATE IT
	MOVE	T,T1		;MOVE INTEGER INTO T
	JRST	EXP2.0		;OBTAIN RESULT USING EXP2.0
EXP3GO:	PUSH	P,T		;SAVE EXPONENT
	PUSHJ	P,ALOGB		;CALCULATE LOG OF N
	SETZM	LIBFLG		;CLEAR THE OVER/UNDERFLOW FLAG.
	FMPR	N,(P)		;CALCULATE B*LOG(N)
	POP	P,T		;RESTORE EXP.
	SKIPE	LIBFLG		;EXP3D AND EXP3D1 ARE ERROR ROUTINES.
	JRST	EXP3D
	MOVM	T,N
	CAMLE	T,E7
	JRST	EXP3D1
	PUSHJ	P, EXPB		;CALCULATE EXP(B*LOG(N))
	POPJ	P,		;RETURN

EXP3D:	MOVM	T,N
	CAML	T,ONE
	JRST	EXP3A		;UNDERFLOW IN ARG TO EXP MEANS ANS=1.
	JUMPG	N,EXP3D3	;OVERFLOW MEANS OVER/UNDER IN ANS.
EXP3D2:	PUSH	P,ODF
	SETZM	ODF
	PUSHJ	P,INLMES
	ASCIZ	/
OVERFLOW IN /
	JRST	LRGNS1
EXP3D1:	JUMPG	N,EXP3D2	;LARGE ARG TO EXP MEANS OVER/UNDER IN ANS.
EXP3D3:	PUSH	P,ODF
	SETZM	ODF
	PUSHJ	P,INLMES
	ASCIZ	/
UNDERFLOW IN /
	PUSHJ	P,GOSR3
	POP	P,ODF
	SETZ	N,
	POPJ	P,



EXP3A:	MOVSI	N,(1.0)		;ANSWER IS 1.0
	POPJ	P,

EXPB3:	PUSH	P,ODF
	SETZM	ODF
	PUSHJ	P,INLMES
	ASCIZ /ZERO TO A NEGATIVE POWER IN /
LRGNS1:	PUSHJ	P,GOSR3
	POP	P,ODF
	HRLOI	N,377777	;LARGEST ANSWER.
	POPJ	P,

EXP3C:	MOVE	X1,A
	FAD	X1,FIXCON
	FSB	X1,FIXCON
	CAMN	A,X1
	JRST	EXP3A1		;NEGATIVE BASE, INTEGRAL POWER
	PUSH	P,N		;SAVE ARGUMENTS
	PUSH	P,T
	PUSH	P,ODF
	SETZM	ODF
	PUSHJ	P,INLMES
	ASCIZ /ABSOLUTE VALUE RAISED TO POWER IN /
	PUSHJ	P,GOSR3
	POP	P,ODF
	POP	P,T
	POP	P,N
EXP3C0:	MOVMS	N
	JRST	EXP3A0
	SUBTTL	RUN-TIME RANDOM NUMBER ROUTINES

IFN FTRND, <
;;WRANB -- PSEUDO-RANDOM RESET/WARMUP
; PUSHJ	P,WRANB
;
;THE ARG IS IN ACCUMULATOR A
;
; 1.	USES STANDARD BASIC "PUSHJ" CALLING SEQUENCE.
; 2.	W IS A BIT VECTOR (BITS 05-35 SIGNIFICANT).
; 3.	RETURNS NO USEFUL VALUE IN AC Z.
; 4.	CREATES A BASIS OF "NNN" VECTORS AT VRANT IN VRAN,
;	BASED ON THE WARMUP ARGUMENT W. (STANDARD VALUE
;	IS W=0.) RESETS VRAN'S OWN INDEX. USES VRAN LOCATIONS
	;		VRANR	; VRAN OWN INDEX RESET VALUE.
	;		VRANW	; VRAN'S WARMUP CONSTANT.
	;		VRANT	; VRAN'S VECTOR-TABLE.
	;		VRANN	; NEGATIVE TABLE LENGTH.
; 5.	FORTRAN AC ASSIGNMENTS ARE
;	N=00	; FUNCTION-VALUE RETURN AC.
;	T=1	; SCRATCH AC.
;	P=17	; PUSHDOWN LIST
;	T1=2	; INDEX AC.
;	A=3	; INDEX AC.
; 6.	WRAN MAY BE USED FREELY TO REPEAT A PREVIOUSLY GENERATED
;	SEQUENCE (BY CALLING WRAN WITH THE PREVIOUSLY USED VALUE
;	FOR W), OR TO CAUSE THE GENERATION OF A COMPLETELY NEW
;	SEQUENCE (BY CALLING WRAN WITH A NEW VALUE FOR W).


	...=0	; ELLIPSIS (FOR CONVENIENCE).
>


IFN FTRND, <
WRANB:	XOR	N,VRANW		;   ADJUST,
	TLZ	N,(37B4)	;   IGNORE BITS 00-04,
	JUMPE	N,WRANB		;   REJECT 0.
	MOVSI	T1,VRANN		; ESTABLISH OUTER LOOP.
WRAN2:	MOVNI	A,6	; ESTABLISH INNER LOOP.
WRAN3:	MOVE	T,N		; COPY ARGUMENT,
	ROT	T,13		;   POSITION BITS 05-10 FOR
	XOR	T,N		;   MOD 2 SUM WITH BITS 30-35.
	ROT	T,-6		; USE RESULT AS NEW
	LSHC	N,6		;   ARGUMENT BITS 30-35.
	AOJN	A,WRAN3		; SIX BYTES DONE? NO, BACK.
	MOVEM	N,VRANT(T1)	; YES, ARGUMENT IS BASIS VECTOR.
	AOBJN	T1,WRAN2		; "NNN" VECTORS DONE? NO, BACK.
	MOVE	N,VRANR		; RESET VRAN OWN INDEX.
	MOVEM	N,VRANX		; (AFTER RESTORING AC'S!)
	POPJ	P,			; RETURN (OVER "ARG").


;FRANB -- FLOATING-POINT PSEUDO-RANDOM GENERATOR.

; PUSHJ	P,FRANB
;
; 1.	USES STANDARD BASIC "PUSHJ" CALLING SEQUENCE.
; 3.	RETURNS IN AC N A FLOATING-POINT NUMBER AS AN
;	INSTANCE OF A REAL RANDOM VARIABLE UNIFORMLY
;	DISTRIBUTED ON THE OPEN INTERVAL (0,1).
; 4.	REQUIRES THE VECTOR GENERATOR FUNCTION VRAN.
;VRAN
; 5.	FORTRAN AC ASSIGNMENTS ARE
FRANB:
FRAN1:	PUSHJ	P,VRANB		; GET RANDOM VECTOR,
	LSH	N,-9		;   SCALE TO MANTISSA,
	JUMPE	N,FRAN1		;   REJECT ZERO.
	TLO	N,(1B1)		; FORCE EXPONENT OF 2^0,
	FAD	N,[1B1]		;   NORMALIZE.
	POPJ	P,		; RETURN (IGNORE "ARG").
>
IFN FTRND, <
;VRAN7B -- 36-BIT PSEUDO-RANDOM GENERATOR.

;; NAME SHOULD ALWAYS BE
;; "VRANXX", WHERE "XX" IS THE ASSEMBLED VALUE OF
;; THE PARAMETER "NNN". (SEE 6. BELOW.) USE ONLY THE
;; STATISTICALLY BEST "EEE" VALUE FOR EACH "NNN" VALUE.

; PUSHJ	S,VRANB
;
; 1.	USES STANDARD BASIC "PUSHJ" CALLING SEQUENCE.
; 3.	RETURNS IN AC N A 36-BIT PSEUDO-RANDOM VECTOR.
;		VRANX	; AC STORAGE, OWN INDEX.
;		VRANR	; OWN INDEX RESET VALUE.
;		VRANW	; WARMUP CONSTANT.
;		VRANT	; VECTOR-TABLE.
;		VRANN	; NEGATIVE TABLE LENGTH.
; 6.	VRAN HAS THREE ASSEMBLY PARAMETERS:
	RADIX 10
	NNN=7	; VECTOR-TABLE SIZE.
	EEE=3	; VECTOR-TABLE OFFSET.
	RADIX 8
	W=013702175435	; VECTOR-TABLE GENERATOR.
;	WHICH ARE USED TO ESTABLISH AN INITIAL TABLE OF
;	"NNN" BASIS VECTORS <V[J] : 0 .LE. J .LT. NNN>, AND TO
;	GENERATE SUCCESSIVE VECTORS ACCORDING TO THE RULE:
;	V[NNN+J] = (V[0+J] + V[EEE+J]) MODULO (2^36) : 0 .LE. J.
;	(SEE RANPAK.TXT FOR ADMISSABLE VALUES FOR <NNN,EEE,W>,
;	AND A DISCUSSION OF THE ALGORITHM.)

	VRANN=-NNN	; NEGATIVE TABLE LENGTH (FOR WRAN).
>

IFN FTRND, <
VRANB:	MOVE	T1,VRANX		; SET UP OWN INDEX.
	MOVE	N,VRANT+NNN(T1)	; ADDEND V[E+J] IF J .LT. N-E.
	TRNN	T1,(1B0)		; [J.LT.N-E]=[RH(T1).LT.0]?
	MOVE	N,VRANT+0(T1)	; ADDEND V[E+J] IF J .GE. N-E.
	ADDB	N,VRANT+NNN-EEE(T1)	; AUGEND V[0+J] AND RESULT V[N+J].
	AOBJN	T1,VRAN1		; STEP J; J.GT.N? NO,OVER.
	MOVE	T1,VRANR		; YES, RESET J.
VRAN1:	MOVEM	T1,VRANX		; SAVE OWN INDEX.
	POPJ	P,		;EXIT

VRANR:	XWD	-<NNN+1>,-<NNN-EEE>	; OWN INDEX RESET VALUE.

VRANW:	EXP	W		; WARMUP CONSTANT (FOR WRAN).
>
	END	BASIC
                                                                                                                                                                                                                                                                                                                                                                                                       S{X