	UNIVERSAL  SCNDCL -- DECLARATIONS FOR COMMAND SCANNER

	IF1,<		;DEFINE ONLY DURING PASS 1

;DEFINE MACRO TO PASS DECLARATIONS ON TO EACH SUB-MODULE
	DEFINE	SCNDCL,<
	SUBTTL	P.CONKLIN/DJB/DMN/PFC -- %3(173)	31-OCT-72

	LALL

;***COPYRIGHT 1970, 1971, 1972, 1973 DIGITAL EQUIPMENT CORP., MAYNARD, MASS.***

	SALL		;;SUPPRESS MACRO LISTINGS

	SCNDC1		;;GET REST OF DECLARATIONS
>	;END OF SCNDCL


CUSTVR==0		;CUSTOMER VERSION
DECVER==3		;DEC VERSION
DECMVR==0		;DEC MINOR VERSION
DECEVR==173		;DEC EDIT VERSION


;ASSEMBLY INSTRUCTIONS:
;.COMPILE	C,SCNMAC,SCAN,HELPER
;THEN LOAD THE .REL FILE WITH ANY PROGRAM


	SEARCH	C,SCNMAC	;SEARCH PARAMETERS FOR THIS FILE

;AC NAMES

T1=1		;TEMPORARIES
T2=2
T3=3
T4=4

P1=5		;PRESERVED ACS FOR CALLING ROUTINES
P2=6
P3=7
P4=10

P=17		;PUSH-DOWN POINTER
	SUBTTL	PARAMETERS AND DEFAULTS

;ASSEMBLY PARAMETERS

ND DEBUG,1		;1=INCLUDE DEBUGGING FEATURES
ND DEBUGA,0		;1=INCLUDE ADDRESSES IN ERROR MESSAGES
ND PURESW,1		;1=REENTRANT VERSION
ND FTDIAL,0		;1=SUPPORT DIALOGUE MODE
ND ECHOC,0		;1=ECHO COMMAND STRING AS CHARACTER PROCESSED
ND ECHOW,0		;1=ECHO COMMAND STRING AS WORD PROCESSED
ND ECHOP,0		;1=ECHO COMMAND STRING AS PHRASE PROCESSED
ND LN.ABF,200		;LENGTH OF INDIRECT BUFFER
ND FTSFD,-1		;SUB-FILE DIRECTORIES
ND INDEPT,^D10		;MAX. INDIRECT DEPTH (-1=INF., 0=NONE)


DM PRO,777,0,277	;PROTECTION
DM RUN,7,-1,1		;RUN OFFSET

;COMPLETE DEFINITION OF DECLARATIONS MACRO
	DEFINE	SCNDC1,<

	SEARCH	C,SCNMAC	;;USE SYMBOLS FROM C.MAC+SCNMAC.MAC

XP %%SCAN,CUSTVR*1B2+DECVER*1B11+DECMVR*1B17+DECEVR
	PURGE	CUSTVR,DECVER,DECMVR,DECEVR

IFN PURESW,<
	TWOSEG
	RELOC	400000
>
>	;END OF SCNDC1
	SUBTTL	REVISION HISTORY

;%1 (SCANER) -- 6/71 WITH 5.03 MONITOR

;A)  MOVE MACROS TO C.MAC AND SCNMAC.MAC.  USE ALL BIT AND
;	BYTE DEFINITIONS FROM C.MAC.  DEFINE FILE SPEC AREA
;	IN SCNMAC.MAC.
;B)  RESTRICT AC USAGE TO 1-10 (1-4 TEMPS, 5-10 PRESERVED).
;	FLAGS AND MASK MOVED TO CORE.  NAME MOVED TO 7, CHARACTER
;	TO 10.
;C)  INDIRECT I/O REDUCED TO CHANNEL 0 AND READ ONE BLOCK AT A TIME.
;D)  CHARACTER CODING CHANGED TO FOLLOWING:  ESCAPE=0, END OF LINE=-1,
;	END OF FILE=-2.  OCCASIONALLY 200 IS END OF LINE (SAVCHR).
;E)  ALL UUOS AND THEIR BITS, BYTES, AND FUNCTIONS ARE SYMBOLIZED WITH
;	C.MAC.
;F)  CALLING SEQUENCES CHANGED TO BE A BLOCK POINTED TO FROM AC1 TO GIVE
;	UPWARD GROWTH COMPATIBLY.  MANY PARAMETERS ARE OPTIONAL.
;G)  INDIRECT/CCL CODE PLACED UNDER CONDITIONAL.
;H)  TYPEOUT CHARACTER ROUTINE SEPARATED.  CAN BE ARGUMENT.
;I)  ALLOW PROGRAM TO SPECIFY A PRESET INDIRECT FILE.
;J)  CHANGE ALL INTERNALS TO INCLUDE PERIOD IN NAME.
;K)  WHEN SKIPPING OVER RESCANNED LINE, AVOID POSSIBLE TT IN WAIT.
;L)  RECODE EOF HANDLING TO COVER ALL CASES.
;M)  ADD TSCAN ARGS TO GIVE USER CONTROL AT KEY POINTS IN SCAN.
;N)  CHANGE MESSAGE FROM "ILLEGAL COMMAND SYNTAX CHARACTER" TO
;	"ILLEGAL CHARACTER".  TYPEOUT ASCII 7,11-15,33 MNEMONICALLY.
;O)  IMPLEMENT MULTIPLE OUTPUT SPECS FOR COMPILERS.  IF MULT. OUTPUT,
;	THE = (OR _) IS MANDATORY.
;P)  ADD WORDS FOR /BEFORE/SINCE.  SWITCH SCAN WILL BE IMPLEMENTED
;	LATER.  ALSO ADD .GTNOW (INTERNAL DATE FORMAT CONVERTER).
;Q)  ADD MESSAGE "?PROTECTION SWITCH ILLEGAL IN INPUT FILE".
;	REMOVE "? TOO MANY INPUT FILES".
;R)  IMPLEMENT /RUN/RUNOFFSET SWITCHES.
;S)  IN VERB MODE, PERIOD BEFORE VERB SETS STICKY DEFAULTS.
;	CHANGE LOGIC SO VERBS FOR A FILE APPEAR AFTER THE
;	FILES DEFINITION.
;T)  DEFEAT ^O BEFORE TYPING * / OR #.
;U)  IN VERB MODE, ADD NEW MESSAGE
;	? EXCESS ARGUMENTS STARTING WITH ....
;V)  IN VERB MODE, IGNORE LEADING /.  THIS ALLOWS /HELP TO
;	WORK IN ANY PROGRAM.
;W)  .VSCAN WILL RETURN ONLY AT TOP LEVEL EOF.
;X)  GENERALIZE /HELP ARGUMENT TO GIVE SIXBIT PROGRAM NAME
;	(-1 FOR GETTAB 3)  TO USE AS ARGUMENT TO HELPER.
;Y)  PUT LIMIT OF 10 ON INDIRECT FILES (ASSEMBLY PARAM)
;	ADD MESSAGES:
;	? INDIRECT SPECIFICATION INCOMPLETE
;	? TOO MANY INDIRECT FILES
;	? WILDCARD ILLEGAL IN INDIRECT SPECIFICATION
;Z)  IN FILE SCAN, FORCE NAME TO LEFT HALF.
;AA)  IN /RUN, DON'T ALLOW SWITCHES.
;AB)  IF NO FILE NAME, MAKE FILE SPEC STICKY.
;AC)  DETECT NULL DEVICE PROPERLY.
;AD)  IMPLEMENT PATH SPECIFICATION. ALSO NOTATIONS [,] [P,]
;	[,P] AND [-].
;AE)  ADD ROUTINE .GTSPC TO MOVE FILE SPEC TO STORAGE.
;AF)  ADD DEFAULT DEVICE 'DSK:' IF USER TYPES PART OF A SPEC BUT
;	OMITS THE DEVICE.
;AG)  ADD INTERNAL (STANDARD) SWITCHES WHICH COMPETE EQUALLY
;	FOR ABBREVIATIONS, BUT ON EXACT EQUIVALENCE THE CALLER'S
;	SWITCHES OVERRIDE.
;AH)  ADD MESSAGE: ? AMBIGUOUS SWITCH.
;AI)  IF SWITCH TABLES GIVE NO MAX, THEN ALWAYS GO TO PROCESSOR.
;	IF SWITCH TABLES OMIT POINTER (LH=0), CALL ROUTINE
;	POINTED TO BY RH.
;AJ)  ALLOW KEYWORD SWITCHES TO GET VALUE "0" TO CLEAR INDEX.
;AK)  EXPAND TWO WORD SIXBIT SCAN TO BE MULTIWORD.
;AL)  ADD /HELP:SWITCHES TO LIST ACTUAL SWITCH TABLE.
;AM)  ADD SWITCH TABLE PREFIX '*' TO MEAN ALL ABBREVIATIONS ARE
;	EXACT MATCHES.
;AN)  ADD STANDARD SWITCHES /DENSITY,/OKNONE,/PARITY,/PHYSICAL,
;	/PROTECTION,/STRS.
;AO)  ADD MESSAGES:
;	? IMPROPER PROJECT NUMBER
;	? IMPROPER PROGRAMMER NUMBER
;	? SFD DEPTH GREATER THAN 5
;	? NULL SFD ILLEGAL
;	? NO SWITCH SPECIFIED
;	? SWITCH VALUE NEGATIVE
;AP)  CORRECT LOGIC WHICH MEMORIZED STICKY SWITCHES.
;AQ)  # PREFIX ON DECIMAL INPUT IMPLIES OCTAL INPUT.
;AR)  ALLOW - ON DECIMAL/OCTAL INPUT.
;AS)  RECODE ALGORITHM WHICH HANDLES CONTINUATION, COMMENTS, AND
;	MULTIPLE SPACES TO HANDLE ALL CASES CORRECTLY.
;AT)  ADD CHKACC UUO ON INDIRECT FILES LOOKUPS IN CASE CALLER
;	HAS JACCT ON.
;AU)  IF NO . IN @, CHECK .(NUL) AFTER .CCL.
;AV)  SKIP SEQUENCE NUMBERS IN @ FILE.
;AW)  RECODE END/ERROR LOGIC ON @ FILES TO ALWAYS HANDLE CCL
;	FILES CORRECTLY.  IN PARTICULAR, DELETE .TMP FILES
;	AFTER SUCCESSFUL CCL CALL.
;AX)  CHANGE OCTAL FATAL MESSAGE TO RH(N) FOR CONSISTENCY.
;AY)  ON ERROR IN INDIRECT FILE, SKIP TO END OF LINE.
;AZ)  ON VERB @ ERROR, TERMINATE @ FILE.
;BA)  WHEN DOING MONRT., RESET ALL I/O.  IF NOT LOGGED IN,
;	EXCLUDE THE ^D IN PREVIOUS VERSIONS.
;BB)  ADD NEW ROUTINE (.TFBLK) TO TYPE SCANNER STYLE FILESPEC AREA.
;BC)  ADD NEW ROUTINE (.TDIRB) TO TYPE DIRECTORY IN SINGLE WORD,
;	SFD, OR SCANNER FORMATS.
;BD)  ADD NEW ROUTINE (.TFCHR)  TO TYPE POSSIBLE FUNNY CHARS.
;	IT HANDLES CONTROL AND LOWER CASE FLAGGING.
;BE)  EXPAND ALL P,PN HANDLING TO ALLOW ONE SIXBIT WORD INSTEAD
;	OF TWO OCTAL HALF WORDS.
;BF)  CHANGE CALLS TO ALL TYPEOUT ROUTINES TO PASS ARGS IN T1.
;BG)  REMOVE ALL OUTSTR/OUTCHR CALLS EXCEPT PROMPTS.
;BH)  HANDLE SIGNED NUMBERS IN RADIX TYPER.
;BI)  CHANGE SAVEN CALL TO BE PUSHJ.
;BJ)  INTERN F.NAM AS FLAG FOR SWITCH SCANNERS.

;%2(127) -- 5/72 WITH DIRECT %2.

;130	REMOVE INTERNS. MAKE ALL DOT SYMBOLS INTERN WITH ::.
;131	REMOVE # OUTPUT ON INDIRECT CONTINUATIONS (SPR 10-7212).
;132	BAN MULTIPLE BUFFER INDIRECT FILE ONLY ON DTA (SPR 10-7212).
;133	SPLIT .TICHT FROM .TICHE
;134	FIX BUG IN .CNVDT
;135	ADD .CNTDT (INVERSE OF .CNVDT)
;136	CREATE .PSCAN FOR PEOPLE WITH PARTIAL SCAN NEEDS
;137	CHANGE ALLDON TO .ALDON
;140	CLEAR SCANPC ON .CLRBF
;141	ADD PROTECTIVE TESTS TO CNVDAT
;142	ADD TTY INPUT AND  MONRET ROUTINES IN ISCAN CALL
;143	CHANGE RUNXYZ TO N.XYZ; USE .FX SYMBOLS
;144	ADD /BEFORE/SINCE SWITCHES
;145	ALLOW / BETWEEN PROJ AND PROG IN DIRECTORIES
;146	DON'T FLUSH NULL FILE SPECS
;147	ADD DATE/TIME SCANNERS.
;150	ADD .OSCAN ROUTINE.
;151	ADD /OPTION SWITCH TO SELECT OPTIONS FROM SWITCH.INI FILE.
;152	ADD .SWFIL TO HANDLE FILE SWITCHES
;153	CANCEL 145 AS A BAD IDEA.
;154	HANDLE MISSING DIRECTORIES IN OPTIONS LOOKUPS.  CORRECT BUG
;	WHICH DECREMENTED START ADDRESS ON OPTIONS NOT FOUND.
;155	CREATE ROUTINE .TERRP (WAS FMADDR)
;156	SPLIT INTO 4 SUB-MODULES--SCAN, OUTPUT, DATE, SAVE
;157	CREATE UNIVERSAL SCNDCL TO PASS PARAMETERS TO EACH SUB-MODULE
;160	HANDLE NUMBERS IN ILL.CHAR MESSAGE
;161	UPDATE LASCHR ON STRING INPUT (.TIGET)
;162	DEFINE .SCANZ AND .SCANL FOR SEGMENT SHUFFLERS
;163	CLEAN UP EXTERNS WITH GLOB.SNO
;164	GIVE USER EXIT ONLY ON HIS OWN SWITCHES
;165	ADD .TTABC ROUTINE TO TYPE A TAB, ETC.
;166	ALLOW FOR PARTIAL WORD IN LAST WORD OF IND. FILE BUFFER
;167	ADD .TTIME, .TDATE TO TYPE OUT DATE AND TIME
;170	MAKE MULTIWORD AREA HANDLE WORST CASE (30. WORDS)
;171	FIX .TRDXW TO HANDLE 1B0 CORRECTLY
;172	FIX .NAME ON SIX LETTER * SWITCHES
;173	CORRECT PDL ERROR IN .FMSGX ROUTINE IF .TSCANNING

>	;END OF IF1 FROM FIRST PAGE
	PRGEND
	TITLE	.SCAN -- GENERALIZED USER MODE COMMAND SCANNER

	SEARCH	SCNDCL		;GET SCAN DECLARATIONS
	SCNDCL			;INITIALIZE LISTING, ETC.

;ENTRY POINTS

	ENTRY	.ISCAN		;ONLY INITIALIZER SINCE THAT MUST BE CALLED
	SUBTTL	DEFINITIONS FOR THIS SUB-MODULE

;AC NAMES

N=P3		;NUMBER OR NAME ACCUMULATION  PRESERVED ONLY AT TOP LEVEL
C=P4		;CHARACTER INPUT	      PRESERVED ONLY AT TOP LEVEL
			;WITH THE FOLLOWING ENCODING:
			;  -2   =EOF
			;  -1   =EOL
			;   0   =ESCAPE OR ALTMODE
			;  1-177=ASCII CHARACTER
			;THUS, TO TEST FOR END OF COMMAND LINE,
			;	JUMPLE	C,...JUMP ON EOL...

	PURGE	P3,P4	;NOT USED IN THIS SUB-MODULE

;I/O CHANNELS

IFN INDEPT,<
IND==0		;INDIRECT FILE (TEMPORARY; ONLY OPEN WHEN PC IS IN SCAN)
>

;CHARACTERS

C.TE==200	;TEMPORARY EOL CODE FOR SAVCHR FLAG

;TEMPORARY DEFS UNTIL DEFINED LATER ON

IF1,<	FXNOTO==1
	FXNOTI==1>
	SUBTTL	INITIALIZE

;.ISCAN--SUBROUTINE TO INITIALIZE COMMAND SCANNER
;CALL	AC1=XWD LENGTH,BLOCK
;	BLOCK+0=0 OR IOWD PTR TO A LIST OF LEGAL MONITOR COMMANDS
;		IF 0, NO RESCAN IS DONE
;	BLOCK+1=RH 0 OR SIXBIT CCL NAME
;		  IF 0, NO CCL MODE
;		LH 0 OR ADDRESS OF STARTING OFFSET
;	BLOCK+2=RH 0 OR ADDRESS OF CHARACTER TYPEOUT ROUTINE
;		  IF 0, OUTCHR WILL BE DONE FROM T1
;		LH 0 OR ADDRESS OF CHARACTER INPUT ROUTINE
;			MUST SAVE ALL ACS, CHAR IN P4
;	BLOCK+3=0 OR POINTER (XWD LEN,BLOCK) TO INDIRECT FILE BLOCK
;		  A.DEV NE 0 TO USE BLOCK
;	BLOCK+4=RH 0 OR ADDRESS OF MONRET ROUTINE
;VALUE	AC1=INDEX IN TABLE OF COMMANDS IF FOUND(0,1,...), ELSE -1


.ISCAN::MOVEM	P,SAVPDP	;PRESET PDL MEMORY
	SETZM	SAVCAL		;CLEAR CALL MEMORY
	PUSHJ	P,.SAVE4##	;SAVE P1-P4
	HLRZ	T2,T1		;GET ARGUMENT COUNT
	PUSHJ	P,.GTWRD	;GET BLOCK+0
	MOVEM	T3,SWTPTR	;STORE POINTER TO COMMAND NAMES
	PUSHJ	P,.GTWRD	;GET BLOCK+1
IFN INDEPT,<
	HRRZM	T3,CCLNAM	;SAVE CCL NAME
	TRNE	T3,-1		;IF SETUP, CHECK OFFSET
	HLRZ	T3,T3		;GET ADDRESS OF OFFSET
	TRNE	T3,-1		;SKIP FETCH IF 0
	MOVE	T3,(T3)		;GET OFFSET
	MOVE	P1,T3		;SAVE FOR LATER TEST
>
	PUSHJ	P,.GTWRD	;GET BLOCK+2
	HLRZM	T3,TYPIN	;SAVE CHARACTER TYPEIN ROUTINE
	HRRZS	T3		;CLEAR TYPEIN NAME
	PUSH	P,T3		;SAVE CHARACTER TYPEOUT ROUTINE

	PUSHJ	P,.GTWRD	;GET BLOCK+3
IFN INDEPT,<
	SKIPN	A.DEV-A.ZER(T3)  ;SEE IF DEVICE
	MOVEI	T3,0		;NO--CLEAR POINTER
	MOVEM	T3,USRIND	;SET FLAG OF USER SUPPLIED IND. FILE
	JUMPE	T3,ISCANI	;PROCEED IF NO FILE
	HRLZ	T4,T3		;SETUP BLT
	HRRI	T4,A.ZER	;  FROM USER
	HLRZ	T3,T3		;  TO A.ZER
	CAILE	T3,A.EZER-A.ZER+1
	MOVEI	T3,A.EZER-A.ZER+1
	BLT	T4,A.ZER-1(T3)	;BUT NOT TOO FAR
>
ISCANI:	PUSHJ	P,.GTWRD	;GET BLOCK+4
	HRRZM	T3,MONRT	;SAVE USER MONRET
	HRREI	C,.CHEOL	;PRESET EOL JUST IN CASE
	SETZM	ZCOR		;CLEAR CORE
	MOVE	T1,[ZCOR,,ZCOR+1]
	BLT	T1,EZCOR
IFN INDEPT,<
	GETPPN	T1,		;GET OUR PPN
	  JFCL			;(IN CASE OF JACCT)
	MOVEM	T1,OURPPN	;SAVE FOR LATER USE
	CAIE	P1,1		;SEE IF OFFSET IS ONE
	JRST	ISCANR		;NO--SKIP ON
	AOS	FLCCL		;YES--INDICATE CCL (WITH FLAG FOR TMPCOR POSSIBLE)
	SETOM	FLCCMD		;ALSO INDICATE CCL OR COMMAND
ISCANR:	SETOM	RUNOFF		;CLEAR RUN OFFSET
IFG INDEPT,<
	MOVEI	T1,INDEPT	;PRESET INDIRECT FILE
	SKIPN	A.DEV		;  COUNT TO CORRECT
	CAIN	P1,1		;  VALUE IF OFFSET ONE
	MOVEM	T1,INDCNT	;  OR IND. FILE POINTER
>
>

	POP	P,T1		;RESTORE NAME OF TYPEOUT ROUTINE
	PUSHJ	P,.TYOCH##	;INITIALIZE TYPEOUT ROUTINES
	SETOM	CALCNT		;PRESET CALL COUNTER
	PJOB	T1,		;GET THIS JOB'S NUMBER
	MOVN	P1,T1		;COMPLEMENT
IFN INDEPT,<
	PUSHJ	P,.MKPJN	;MAKE INTO SIXBIT
	SKIPE	CCLNAM		;IF CCL SETUP,
	HRLM	T1,CCLNAM	;  STORE JOB NUMBER
>
	JOBSTS	P1,		;GET THIS JOB'S STATUS
	JRST	[AOS  FLNLGI	;UNKOWN--SET FLAG
		 JRST NOJBST]	;  AND CONTINUE
	TXNN	P1,JB.ULI	;SEE IF LOGGED IN
	SETOM	FLNLGI		;NO--SET FLAG

NOJBST:	MOVE	T1,.JBREL	;SAVE CURRENT CORE
	HRL	T1,.JBFF	;ALSO SAVE .JBFF
	MOVEM	T1,SAVCOR	;  FOR LATER TO RESTORE

IFN INDEPT,<
	SKIPN	FLCCL		;SKIP IF CCL ENTRY
	JRST	COMND		;NO, LOOK FOR MONITOR COMMAND
	MOVSI	T1,'DSK'	;CCL DEVICE IS DSK
	MOVEM	T1,A.DEV
	MOVE	T1,CCLNAM	;CCL NAME
	MOVEM	T1,A.NAM
	HRLOI	T1,'TMP'	;CCL EXTENSION
	MOVEM	T1,A.EXT
	PJRST	COMND2		;RETURN INDICATING NOT A COMMAND


;.MKPJN--SUBROUTINE TO MAKE CCL JOB NUMBER
;CALL:	MOVE	T1,JOB NUMBER
;	PUSHJ	P,.MKPJN
;RETURNS VALUE IN RH(T1)
;CHANGES T2, T3, T4

.MKPJN::MOVEI	T4,3		;MAKE TEMP FILE NAME
MAKPJ1:	IDIVI	T1,^D10		; BY TRIED AND
	ADDI	T2,'0'		; TRUE CCL
	LSHC	T2,-6		; TECHNIQUE
	SOJG	T4,MAKPJ1	; ..
	HLRZ	T1,T3		;POSITION ANSWER
	POPJ	P,
>
;HERE ON A NORMAL START

COMND:	SKIPN	SWTPTR		;SEE IF ANY COMMANDS
	JRST	COMND2		;NO--IGNORE RESCAN
	RESCAN	1		;BACK UP TTY INPUT TO SEE IF COMMAND
	  SKPINC		;SEE IF ANYTHING THERE
	    JRST COMND2		;NO--MUST HAVE COME FROM CUSP LEVEL
COMNDG:	PUSHJ	P,.SIXSW	;GET SIXBIT WORD
	JUMPLE	C,.+2		;IF END OF LINE, GIVE UP GRACEFULLY
	JUMPE	N,COMNDG	;IF NULL, LOOP BACK FOR MORE
	JUMPE	N,COMND1	;SKIP TESTS IF NO COMMAND ON LINE
	MOVE	T1,SWTPTR	;POINTER TO LIST OF LEGAL SWITCHES
	PUSHJ	P,.NAME		;SEE IF ON LIST
	  JRST	COMND1		;NO--SKIP OVER COMMAND
	SETOM	FLCCMD		;YES--FLAG AS SUCH AND REEAT SEPARATOR
	SKIPG	T2,C		;SEE IF END-OF-LINE
	MOVEI	T2,C.TE		;YES--SET TEMPORARY CODE FOR SAVCHR
	CAIE	T2," "		;IF NOT A SPACE,
	MOVEM	T2,SAVCHR	;  CAUSE IT TO BE REUSED
	SKIPG	C		;SEE IF END OF LINE
	SETZM	SCANPC		;YES--CLEAR SCANNER SINCE C.TE WILL
				;  BE PICKED UP AGAIN
	HRRZ	T2,SWTPTR	;ADDR OF LIST -1
	HRRZI	T1,-1(T1)	;1=ADDRESS-1 OF COMMAND
	SUB	T1,T2		;1=INDEX INTO TABLE
	POPJ	P,		;END INITIALIZATION (.ISCAN)

COMNDS:	SKPINC			;SEE IF ANYTHING STILL THERE
	  TLOA	C,-1		;NO--SET END-OF-LINE
	PUSHJ	P,.TIALT	;GET NEXT CHARACTER
COMND1:	JUMPG	C,COMNDS	;LOOP FOR END OF LINE
COMND2:	SETO	T1,
	MOVEM	C,LASCHR	;SAVE FOR REUSE LATER

	POPJ	P,		;END OF .ISCAN
SUBTTL TRADITIONAL COMMAND SCANNER

;.TSCAN--SUBROUTINE FOR TRADITIONAL COMMAND SCANNER
;ARGS	AC1=XWD LENGTH,BLOCK
;	BLOCK+0=0 OR IOWD POINTER TO LIST OF SWITCH NAMES
;			(IOWD XXXXXL,XXXXXN)
;	BLOCK+1=LH ADDRESS OF DEFAULT SWITCH TABLE (XXXXXD)
;		RH ADDRESS OF PROCESSOR SWITCH TABLE (XXXXXM)
;	BLOCK+2=LH ADDRESS OF (FUTURE)
;		RH ADDRESS OF SWITCH POINTERS FOR STORING (XXXXXP)
;	BLOCK+3=LH TYPE OF HELP (0=NONE, 1=STRING, 2=SUBROUTINE)
;		  IF GT 77, NAME OF PROGRAM IN WHOLE WORD
;		  IF -1 IN WORD, USE JOB TABLE
;		RH LOCATION OF HELP
;	BLOCK+4=LH 0 OR SUBROUTINE TO CLEAR ALL ANSWERS
;		RH 0 OR SUBROUTINE TO CLEAR FILE ANSWERS
;	BLOCK+5=LH SUBROUTINE TO ALLOCATE INPUT FILE AREA
;		RH SUBROUTINE TO ALLOCATE OUTPUT FILE AREA
;		  BOTH RETURN T1=START OF AREA, T2=LENGTH
;	BLOCK+6=LH 0 OR SUBROUTINE TO MEMORIZE STICKY DEFAULTS
;		RH 0 OR SUBROUTINE TO APPLY STICKY DEFAULTS
;	BLOCK+7=LH 0 OR SUBROUTINE TO CLEAR STICKY DEFAULTS
;		RH FLAGS TO CONTROL SCAN:
;		   1B18=MORE THAN ONE OUTPUT SPEC POSSIBLE
;	BLOCK+10=LH (FUTURE)
;		 RH 0 OR ROUTINE TO STORE SWITCH VALUES
;			;ENTERRED WITH T1=VALUE, T2=POINTER
;			;NON-SKIPS IF SCAN SHOULD NOT STORE
;			;SKIPS IF SCAN SHOULD STORE (T1-2 OK)
.TSCAN::MOVE	T2,(P)		;PRESERVE CALLING
	MOVEM	T2,SAVCAL	;  LOCATION
	MOVE	T2,.JBREL	;GET SIZE OF CORE
	HRL	T2,.JBFF	; AND CURRENT USAGE
	MOVEM	T2,SAVCOR	; AND SAVE IT
	PUSHJ	P,.SAVE4##	;SAVE P1-P4
	MOVE	C,LASCHR	;RESTORE LAST CHARACTER
	MOVEM	P,SAVPDP	;SAVE PUSH DOWN LIST POINTER
	PUSHJ	P,SETPR4	;SET STANDARD PARAMETERS
	PUSHJ	P,.GTWRD	;GET BLOCK+4
	HLRZM	T3,CLRANS	;SUBROUTINE TO CLEAR ANSWER AREA
	HRRZM	T3,CLRFIL	;SUBROUTINE TO CLEAR FILE AREA
	PUSHJ	P,.GTWRD	;GET BLOCK+5
	TLNE	T3,-1		;(REQUIRED)
	TRNN	T3,-1		;(REQUIRED)
	HALT	.		;PROTECTION
	HLRZM	T3,ALLIN	;SUBROUTINE TO ALLOCATE INPUT AREA
	HRRZM	T3,ALLOUT	;SUBROUTINE TO ALLOCATE OUTPUT AREA
	PUSHJ	P,.GTWRD	;GET BLOCK+6
	HLRZM	T3,MEMSTK	;SUBROUTINE TO MEMORIZE STICKY DEFAULTS
	HRRZM	T3,APPSTK	;SUBROUTINE TO APPLY STICKY DEFAULTS
	PUSHJ	P,.GTWRD	;GET BLOCK+7
	HLRZM	T3,CLRSTK	;SUBROUTINE TO CLEAR STICKY DEFAULTS
	HRRZM	T3,USRFLG	;STORE AWAY USER'S PARAMETER FLAGS
	PUSHJ	P,.GTWRD	;GET BLOCK+10
	HRRZM	T3,STRSWT	;ADDRESS OF ROUTINE TO STORE RESULTS
	HRRZM	P,FLVERB	;SET FLVERB .GT. 0

	AOSE	CALCNT		;COUNT CALL
	JRST	RESTRT		;IF NOT FIRST, DO A RESTART
	SKIPE	FLCCMD		;SKIP IF NEITHER CCL OR COMMAND
	JRST	RESTRL		;THEY REQUIRE NO *
RESTRT:
IFN DEBUG,<
	CAME	P,SAVPDP
	JRST	E.PDL		;FAIL IF PDL PHASE ERROR
>
	MOVE	T1,SAVCOR	;RESTORE CORE
	HLRM	T1,.JBFF	;RESTORE FIRST FREE
	TLZ	T1,-1		;CLEAR JUNK
	CAME	T1,.JBREL	;  TO ITS INITIAL
	CORE	T1,		;  SETTING IF IT
	  JFCL			;  WAS CHANGED
	AOJGE	C,.+2		;SEE IF EOF
	PUSHJ	P,.ALDON	;YES--GO TO MONITOR
	HRREI	C,.CHEOL	;SETUP EOL
IFN INDEPT,<
	SKIPE	A.DEV		;SEE IF INDIRECT
	JRST	RESTRC		;YES--SKIP END TEST
	SKIPE	FLCCL		;SEE IF CCL MODE
	SOS	.JBSA		;YES--RESTORE STARTING ADDRESS
>
	SKPINL			;SEE IF ANY INPUT
	  JFCL			;DON'T CARE, BUT DEFEAT ^O
	SKIPE	FLCCMD		;SEE IF IN TRADITIONAL MODE
	PUSHJ	P,.MONRT	;NO--RETURN TO MONITOR
RESTRC:
IFN INDEPT,<
	SKIPN	A.DEV		;SEE IF INDIRECT FILE
>
	OUTSTR	[ASCIZ /*/]	;NO--TYPE THE ASTERISK
IFN INDEPT,<
	SKIPE	FLIIND		;SEE IF INTERACTIVE INDIRECT
	OUTSTR	[ASCIZ /#/]	;YES--TYPE FLAG
>
	SETZM	SCANPC		;CLEAR SCANNER
	SUBTTL	MAIN LOOP FOR TRADITIONAL COMMAND SCANNING

;HERE TO START ONE PASS THROUGH THE CUSP (ONE COMMAND LINE)

RESTRL:	SETOM	FLOUT		;FLAG THAT NOT TO = YET
	SKIPE	CLRANS		;SEE IF USER WANTS CONTROL
	PUSHJ	P,@CLRANS	;YES--CLEAR ANSWERS
IFN INDEPT,<
	SETOM	OPTION		;CLEAR /OPTION
>

;HERE TO SCAN ONE SIDE OF COMMAND LINE

RESTRS:	SETZM	P.ZER		;ZERO OUT DEFAULTS
	MOVE	T1,[P.ZER,,P.ZER+1]
	BLT	T1,P.EZER
	SKIPE	CLRSTK		;SEE IF USER WANTS CONTROL
	PUSHJ	P,@CLRSTK	;YES--CLEAR STICKY DEFAULTS

;HERE TO SCAN ONE FILE SPECIFICATION

RESTRF:	SETZM	SWTCNT		;FLAG TO ALLOW SWITCHES
	PUSHJ	P,.FILIN	;GET NEXT FILE SPECIFICATION

	JUMPLE	C,INFIL		;IF END OF LINE OR
	CAIE	C,"+"		;IF PLUS CAIN	C,","		;IF COMMA, MUST BE ON INPUT
	JRST	INOFIL
	CAIE	C,"="		;IF EQUAL OR
	CAIN	C,"_"		;IF LEFT ARROW, MUST BE OUTPUT
	JRST	OUTFIL
IFN INDEPT,<
	CAIN	C,"@"		;IF @, INDIRECT FILE COMING
	JRST	INDFIL
>
	PJRST	E.ILSC		;GO ISSUE ILLEGAL SYNTAX CHAR MESSAGE
;HERE TO SEE IF INPUT OR OUTPUT FILE JUST FOUND

INOFIL:	MOVEI	T1,U.MOUT	;SEE IF MULTIPLE OUTPUT POSSIBLE
	TDNE	T1,USRFLG	;TEST USER'S FLAGS
	SKIPL	FLOUT		;YES--SEE IF = SEEN YET
	JRST	INFIL		;GO DO INPUT FILE
	JRST	OUFIL		;GO DO OUTPUT FILE

;HERE WHEN A SPECIFICATION FOR OUTPUT SIDE IS FOUND

OUTFIL:	AOSE	FLOUT		;SET/TEST IF ALREADY PAST THIS POINT
	JRST	E.TMO		;YES--WARN OF BAD OUTPUT SPEC
OUFIL:	MOVE	T1,F.MODM	;GET FILE MODIFIERS
	TXNE	T1,FXNOTO	;CHECK ILLEGAL ONES
	JRST	E.FMO		;ERROR IF WRONG ONES
	SKIPG	F.BFR		;SEE IF /BEFORE
	SKIPLE	F.SNC		;OR /SINCE
	JRST	E.FMO		;YES--ERROR
	PUSHJ	P,@ALLOUT	;ALLOCATE SOME OUTPUT SPACE
	JRST	INFIL1		;GO COPY SPEC AND LOOP

;HERE WHEN A SPECIFICATION FOR INPUT SIDE FOUND

INFIL:	AOS	FLOUT		;FORCE ANY OUTPUT SPEC ILLEGAL
	MOVE	T1,F.MODM	;GET FILE MODIFIERS
	TXNE	T1,FXNOTI	;CHECK ILLEGAL ONES
	JRST	E.FMI		;ERROR IF WRONG ONES
	PUSHJ	P,@ALLIN	;ALLOCATE SOME INPUT SPACE
INFIL1:	PUSHJ	P,.GTSPC	;AND COPY RESULTS TO IT
INFIL2:	CAIE	C,"="		;IF =, OR
	CAIN	C,"_"		;  IF _,
	JRST	RESTRS		;  GO TO LOOP 1/2 LINE
	JUMPG	C,RESTRF	;IF NOT END, LOOP BACK FOR MORE
IFN INDEPT,<
	SKIPE	N.DEV		;SEE IF RUN COMMAND PENDING
	JRST	RUNCMD		;YES--GO DO IT
>
	SKIPE	SCANPC		;SEE IF ANYTHING YET
	POPJ	P,		;YES--RETURN TO USER
;HERE WHEN NO ARGUMENTS TYPED, DO APPROPRIATE THING

IFN INDEPT,<
	SKIPE	A.DEV		;SEE IF INDIRECT
	JRST	RESTRT		;YES--JUST LOOP BACK
>
	SKIPE	FLCCMD		;SEE IF COMMAND MODE
	POPJ	P,		;YES--RETURN TO USER
	PJUMPE	C,.DILOG	;GO TO DIALOGUE PROCESSING
	JRST	RESTRT		;IF ALL ELSE FAILS, TRY AGAIN

;HERE WHEN INDIRECT FILE SPECIFIER COMING

IFN INDEPT,<
INDFIL:	PUSHJ	P,.GTIND	;SET UP NAME OF INDIRECT FILE
	JRST	RESTRT		;AND GO BACK THROUGH THE LOOP
>
;HERE WHEN ALL DONE AND USER SAID TO RUN SOMETHING

IFN INDEPT,<
RUNCMD:	MOVE	0,N.DEV		;GET DEVICE
	MOVX	1,FX.NDV	;GET NULL DEVICE MASK
	TDNE	1,N.MOD		;TEST SPECIFICATION
	MOVSI	0,'SYS'		;YES--CHANGE TO 'SYS:'
	MOVE	1,N.NAM		;GET FILE NAME
	HLLZ	2,N.EXT		;GET EXTENSION IF ANY
	MOVE	4,N.DIR		;GET DIRECTORY IF ANY
	JUMPE	4,RUNCM1	;IF DEFAULT, PROCEED
	TLNN	4,-1		;SEE IF PROJECT OMITTED
	HLL	4,OURPPN	;YES--FILL IN SELF
	TRNN	4,-1		;SEE IF PROGRAMMER OMITTED
	HRR	4,OURPPN	;YES--FILL IN SELF
RUNCM1:	SETZB	3,5		;CLEAR REST OF ARGUMENTS
	HRLZ	6,RUNOFF	;GET OFFSET
	SKIPL	RUNOFF		;SEE IF DEFAULT
	JRST	RUNCM2		;NO--PROCEED
	TLZ	6,-1		;YES--CLEAR OFFSET
	SKIPE	FLCCL		;SEE IF CCL MODE
	TLO	6,1		;YES--SET CCL MODE OFFSET
RUNCM2:	RUN	6,		;RUN THE PROGRAM
	MOVE	P,SAVPDP	;IF FAILURE, GIVE MESSAGE
	MOVEI	T1,[ASCIZ /
? Run linkage failure /]
	PUSHJ	P,.TSTRG##	;TYPE IT
	HRRZ	T1,6		;OUTPUT ERROR
	PUSHJ	P,.TOCTW##	;  CODE
	MOVEI	T1,N.DEV	;SET POINTER TO RUN BLOCK
	PUSHJ	P,.TFBLK##	;AND TYPE IT
	PUSHJ	P,.TCRLF##	;END LINE
	PUSHJ	P,.TCRLF##	;AND LEAVE SPACE
	CLRBFI			;CLEAR TYPE AHEAD
	MOVE	T1,.JBSA	;GET START ADDRESS
	JRST	(T1)		;AND START OVER
>
SUBTTL VERB FORM COMMAND SCANNER

;.VSCAN --SUBROUTINE FOR VERB ARGS FORM OF COMMAND SCANNER
;	RETURNS CPOPJ IF EOF DURING COMMAND OR CCL AT TOP LEVEL
;ARGS	AC1=XWD LENGTH,BLOCK
;	BLOCK+0=IOWD POINTER TO LIST OF SWITCH NAMES
;			(IOWD XXXXXL,XXXXXN)
;	BLOCK+1=LH ADDRESS OF DEFAULT SWITCH TABLE (XXXXXD)
;		RH ADDRESS OF PROCESSOR SWITCH TABLE (XXXXXM)
;	BLOCK+2=LH ADDRESS OF (FUTURE)
;		RH ADDRESS OF SWITCH POINTERS FOR STORING (XXXXXP)
;	BLOCK+3=LH TYPE OF HELP (0=NONE, 1=STRING, 2=SUBROUTINE)
;		  IF GT 77, NAME OF PROGRAM IN WHOLE WORD
;		  IF -1 IN WORD, USE JOB TABLE
;		RH LOCATION OF HELP
;	BLOCK+4=LH LENGTH OF FXXX AND PXXX AREAS
;		RH START OF FXXX (PER FILE SWITCHES)
;	BLOCK+5=LH (FUTURE)
;		RH START OF PXXX (STICKY FORM OF FXXX)
;	BLOCK+6=NAME OF OPTION LINES (0 IF THIS PROGRAM'S NAME)


.VSCAN::MOVEM	P,SAVPDP	;SAVE PUSH DOWN LIST POINTER
	PUSHJ	P,SETPR4	;SET STANDARD PARAMETERS
	PUSHJ	P,.GTWRD	;GET BLOCK+4
	MOVE	P1,T3		;SAVE POINTER TO FXXX
	PUSHJ	P,.GTWRD	;GET BLOCK+5
	TLZ	T3,-1		;GET START OF PXXX
	SUBI	T3,(P1)		;GET OFFSET TO PXXX FROM FXXX
	MOVEM	T3,SWTPFO	;STORE FOR LATER
	HRRZM	P1,SWTPFF	;STORE START OF FXXX
	HLRZ	T3,P1		;GET LENGTH OF FXXX
	ADDI	T3,(P1)		;GET END+1
	SOS	T3		;GET END
	MOVEM	T3,SWTPFL	;SAVE END FOR LATER
	PUSHJ	P,.GTWRD	;GET BLOCK+6
IFN INDEPT,<
	MOVEM	T3,VOPTN	;SAVE AS OPTION FILE LINE NAME
>
	SETOM	FLVERB		;NOTE VERB FORM
	MOVE	C,SAVCHR	;RESTORE RESCANNED CHARACTER
VRSTRT:
IFN DEBUG,<
	CAME	P,SAVPDP
	JRST	E.PDL
>
	SETZM	SCANPC		;INDICATE START OF LINE FOR SCAN
	SETZM	FLDOT		;CLEAR DOT SEEN FLAG
	CAMG	C,[.CHEOF]	;SKIP IF NOT AT EOF
	PUSHJ	P,.ALDON	;AT END--GO DO EOF PROCESSING
	CAMG	C,[.CHEOF]	;SKIP IF NOT STILL AT EOF
	JRST	VEOF		;GO HANDLE FINAL END
IFN INDEPT,<
	SKIPN	A.DEV		;SEE IF INDIRECT
>
	SKIPE	FLCCMD		;NO--SEE IF CCL OR COMMAND
	JRST	VRSTR1		;YES--SUPPRESS OUTPUT
	SKPINL			;NO--DEFEAT ^O
	  JFCL
	OUTSTR	[ASCIZ ./.]	;THEY DONT NEED /
VRSTR1:
IFN INDEPT,<
	SKIPE	FLIIND		;SKIP IF NOT INTERACTIVE INDIRECT FILE
	OUTSTR	[ASCIZ /#/]	;LET USER KNOW WE ARE DEMANDING INPUT
>
	HRREI	C,.CHEOL	;CLEAR ALT FLAG

VRSTRL:
IFN INDEPT,<
	SETOM	OPTION		;CLEAR /OPTION
>
	PUSHJ	P,.KEYWD	;PROCESS THE VERB
	  JRST	VRSTNL		;GO HANDLE NO VERB YET
	MOVE	C,LASCHR	;RESTORE CHARACTER JUST IN CASE

;HERE AT END OF COMMAND
	JUMPLE	C,.+2		;IF EOL, LOOK FOR OPTION
	PJRST	E.INCL		;ELSE, ISSUE ERROR MESSAGE
IFN INDEPT,<
	SKIPE	N.DEV		;SEE IF /RUN
	JRST	RUNCMD		;YES--GO HANDLE IT
	AOSN	OPTION		;SEE IF /OPTION
	JRST	VRSTRT		;NO--LOOP
	SOS	OPTION		;YES--CORRECT FOR AOS
	MOVE	T3,VOPTN	;GET OPTION NAME
	PUSHJ	P,OSCANV	;ENTER MIDDLE OF OSCAN
>
	JRST	VRSTRT		;LOOP
;HERE BEFORE VERB SEEN
VRSTNL:	CAIN	C,"/"		;SEE IF /
	JRST	VRSTRL		;YES--LET USER PRECEDE VERBS THIS WAY
IFN INDEPT,<
	CAIN	C,"@"		;SEE IF INDIRECT FILE
	PUSHJ	P,.GTIND	;YES--GET SPECIFICATION
>
	CAIN	C,"."		;SEE IF STICKY FLAG
	JRST	VDOT		;YES--GO SET FLAG
	JUMPLE	C,VRSTRT	;LOOP IF NULL LINE
	PJRST	E.ILSC		;ELSE, GO TO ERROR MESSAGE

VDOT:	SETOM	FLDOT		;SET DOT FLAG
	JRST	VRSTRL		;LOOP FOR KEYWORD
VEOF:
IFN INDEPT,<
	SKIPN	A.DEV		;SEE IF IND
>
	SKIPN	FLCCMD		;SEE IF CCL OR COMMAND
	JRST	VRSTRT
	POPJ	P,		;ALL DONE, RETURN TO CALLER
	SUBTTL	OPTION FILE SCANNER

;.OSCAN -- SUBROUTINE TO SCAN OPTIONS FILE (DSK:SWITCH.INI[,])
;	RETURNS CPOPJ AFTER UPDATING GLOBAL SWITCHES FROM FILE
;	THIS ROUTINE SHOULD BE CALLED AFTER TSCAN OR PSCAN
;		BUT BEFORE DEFAULTING.
;	IT SHOULD BE CALLED BETWEEN ISCAN AND VSCAN FOR VERBS.
;ARGS:	AC1=XWD LENGTH,BLOCK
;	BLOCK+0=IOWD POINTER TO LIST OF SWITCH NAMES
;			(IOWD XXXXXL,XXXXXN)
;	BLOCK+1=LH ADDRESS OF DEFAULT SWITCH TABLE (XXXXXD)
;		RH ADDRESS OF PROCESSOR SWITCH TABLE (XXXXXM)
;	BLOCK+2=LH ADDRESS OF (FUTURE)
;		RH ADDRESS OF SWITCH POINTERS FOR STORING (XXXXXP)
;	BLOCK+3=LH TYPE OF HELP (0=NONE, 1=STRING, 2=SUBROUTINE)
;		  IF GT 77, NAME OF PROGRAM IN WHOLE WORD
;		  IF -1 IN WORD, USE JOB TABLE
;		RH LOCATION OF HELP
;	BLOCK+4=NAME OF OPTIONS TO SELECT IN FILE (0 IF NAME OF PROGRAM)

IFN INDEPT,<
.OSCAN::PUSHJ	P,.SAVE4##	;SAVE P1-4
	PUSH	P,LASCHR	;SAVE ORIGINAL LAST-CHAR
	HRRZM	P,LASCHR	;FAKE OUT PSCAN
	PUSHJ	P,.PSCAN	;SETUP FOR PSCAN
	  JRST	OPTNSX		;HERE ONLY IF ERROR IN FILE
	PUSHJ	P,.GTWRD	;GET BLOCK+4
OSCANV:	JUMPN	T3,OSCAN1	;OK IF NAME
	HRROI	T3,.GTPRG	;ELSE, GET
	GETTAB	T3,		; PROGRAM NAME
	  JRST	OPTNSY		;GIVE UP IF WE CAN'T
	JUMPE	T3,OPTNSY	;GIVE UP IF NO NAME
OSCAN1:	SKIPE	A.DEV		;SEE IF IND FILE OPEN
	JRST	OPTNSY		;YES--GIVE UP UNTIL IND FILES NEST
	MOVEM	T3,OPTNAM	;SET OPTION NAME
	MOVE	T1,[OPTSPC,,F.ZER]
	BLT	T1,F.MODM	;COPY PRESET SPEC
	SETZM	F.DIR		;CLEAR DIRECTORY
	MOVE	T1,[F.DIR,,F.DIR+1]
	BLT	T1,F.EZER	; AND REST OF SPEC
	PUSHJ	P,GTINDF	;SET INDIRECT FILE SPEC
	;STILL UNDER INDEPT

	AOSE	OPTION		;IF OPTION IS -1,
	SOS	OPTION		;  MAKE IT 0
;HERE TO LOOP OVER LINES IN FILE LOOKING FOR OUR SET OF OPTIONS
OPTNSF:	AOJL	C,OPTNSW	;SEE IF END OF FILE
	SETOB	C,LASCHR	;CLEAR CHARACTER
	SETZM	SCANPC		;INDICATE START OF LINE
	PUSHJ	P,.SIXSW	;GET SIXBIT WORD
	CAME	N,OPTNAM	;SEE IF NAME WE WANT
	JRST	OPTNSD		;NO--SKIP THIS LINE
	SKIPN	OPTION		;SEE IF /OPTION
	CAIN	C,":"		;NO--SEE IF SPECIAL OPTION LINE
	JRST	.+2		;NO--CHECK FOR USER WANTING SPECIAL
	JRST	OPTNSL		;NOT /OPTION AND NO COLON--OK
	SKIPE	OPTION		;SEE IF /OPTION
	CAIE	C,":"		;YES--SEE IF COLON IN FILE
	JRST	OPTNSD		;NO--GIVE UP ON THIS LINE
	PUSHJ	P,.SIXSW	;YES--GET OPTION NAME IN FILE
	CAMN	N,OPTION	;SEE IF IT MATCHES REQUEST
	JRST	OPTNSL		;YES--GO DO THIS ONE
;HERE TO LOOP OVER LINE DISCARDING IT
OPTNSD:	JUMPLE	C,OPTNSF	;BACK TO MAIN LOOP AT END OF LINE
	PUSHJ	P,.TICHR	;GET ONE CHARACTER
	JRST	OPTNSD		;LOOP

;HERE TO LOOP OVER SWITCHES IN LINE
OPTNSL:	JUMPLE	C,OPTNSX	;EXIT IF DONE
	CAIE	C,"/"		;LOOK FOR SLASH
	CAIN	C,","		;OR COMMA
	MOVEI	C," "		;YES--OK
	CAIE	C," "		;SEE IF OK CHAR OR SPACE
	JRST	E.ILSC		;NO--IMPROPER CHARACTER
	PUSHJ	P,.KEYWD	;GET NEXT SWITCH
	  JRST	OPTNSL		;SKIP EXTRA SEPARATORS
	MOVE	C,LASCHR	;RESTORE CHARACTER
	JRST	OPTNSL		;LOOP UNTIL DONE
;HERE WHEN OPTION NOT FOUND OR NO FILE
OPTNSW:	MOVE	N,OPTION	;SEE IF OPTION SPECIFIED
	SKIPN	FLVERB		;IF VERB, ERROR
	JUMPE	N,OPTNSX	;ELSE, IF NAME THEN ERROR
	MOVEI	T1,[ASCIZ /% No option /]
	PUSHJ	P,.TSTRG##	;GIVE USER WARNING
	MOVE	T1,N		;POSITION OPTION
	PUSHJ	P,.TSIXN##	;TYPE IT
	PUSHJ	P,.TCRLF##	;TYPE END OF LINE
;HERE WHEN DONE WITH OPTIONS FILE
OPTNSX:	PUSHJ	P,KILIND	;KILL INDIRECT FILE
OPTNSY:	SETZM	OPTNAM		;CLEAR OPTIONS MODE
	SETZM	N.DEV		;CANCEL ANY /RUN SWITCH
	POP	P,LASCHR	;RESTORE LAST CHAR FOR REGULAR FILES
	POPJ	P,		;RETURN TO CALLER

;FILE SPEC FOR DSK:SWITCH.INI[,]/PHYSICAL/OKNONE

OPTSPC:	'DSK   '
	'SWITCH'
	-1
	'INI',,-1
	<FX.DIR!FX.NOM!FX.PHY>
	<FX.DIR!FX.NOM!FX.PHY>
>	;END INDEPT
	SUBTTL	PARTIAL SCANNER

;.PSCAN --SUBROUTINE TO INITIALIZE PARTIAL MODE SCANNER
;	RETURNS CPOPJ AFTER INITIALIZING.  IN CASE OF ANY
;	FATAL ERRORS (.FMSGE/X), WILL RESTORE CONTROL AND PDP
;	AT RETURN FROM THIS CALL.
;	THIS SHOULD BE CALLED BEFORE EACH PROMPT OR LINE
;	OF INPUT.
;	SKIP RETURNS IF NO PROMPT NEEDED
;ARGS	AC1=XWD LENGTH,BLOCK
;	BLOCK+0=IOWD POINTER TO LIST OF SWITCH NAMES
;			(IOWD XXXXXL,XXXXXN)
;	BLOCK+1=LH ADDRESS OF DEFAULT SWITCH TABLE (XXXXXD)
;		RH ADDRESS OF PROCESSOR SWITCH TABLE (XXXXXM)
;	BLOCK+2=LH ADDRESS OF (FUTURE)
;		RH ADDRESS OF SWITCH POINTERS FOR STORING (XXXXXP)
;	BLOCK+3=LH TYPE OF HELP (0=NONE, 1=STRING, 2=SUBROUTINE)
;		  IF GT 77, NAME OF PROGRAM IN WHOLE WORD
;		  IF -1 IN WORD, USE JOB TABLE
;		RH LOCATION OF HELP

.PSCAN::MOVE	T2,(P)		;GET RETURN POINT
	MOVEM	T2,SAVCAL	;SAVE FOR ERROR
	MOVEM	P,SAVPDP	;SAVE PUSH-DOWN POINTER
	SKIPE	N.DEV		;SEE IF /RUN PENDING
	JRST	RUNCMD		;YES--GO DO IT
	SKIPN	A.DEV		;SEE IF INDIRECT
	SKIPLE	LASCHR		;OR IN MIDDLE OF LINE
	AOS	(P)		;YES--NO PROMPT
	SKIPG	LASCHR		;SEE IF AT END OF LINE
	SETZM	SCANPC		;YES--PRESET BLANK COMPRESSOR
	SETZM	FLVERB		;INDICATE .PSCAN
	SETOB	C,LASCHR	;PRESET TO NEW LINE
				;FALL INTO SETPR4

;SETPR4 -- SUBROUTINE TO STORE STANDARD PARAMETERS FROM GLOBAL CALLS
;	HANDLES ARGUMENT BLOCK THROUGH BLOCK+3
;CALL:	MOVE	T1,[LENGTH,,BLOCK]
;	PUSHJ	P,SETPR4
;USES T1-4

SETPR4:	HLRZ	T2,T1		;SETUP COUNTER FOR .GTWRD
	PUSHJ	P,.GTWRD	;GET BLOCK+0
	MOVEM	T3,SWTPTR	;SAVE POINTER FOR SCANNING
	ADDI	T3,1		;ADVANCE TO TABLE POINTER
	HRLI	T3,P1		;INCLUDE INDEX POINTER
	MOVEM	T3,SWTCHN	;SET ADDRESS FOR MESSAGES
	PUSHJ	P,.GTWRD	;GET BLOCK+1
	HLRZ	T4,T3		;GET DEFAULT TABLE
	SKIPN	T4		;SKIP IF ONE SETUP
	SKIPA	T4,[[0]]	;NO--SET LOCATION OF ZERO
	HRLI	T4,P1		;INCLUDE INDEX
	MOVEM	T4,SWTCHD	;STORE FOR LATER
	HRRZ	T4,T3		;GET MAX,PROCESSOR TABLE
	SKIPN	T4		;SKIP IF ONE SETUP
	SKIPA	T4,[[0]]	;NO--SET LOCATION OF ZERO
	HRLI	T4,P1		;INCLUDE INDEX
	MOVEM	T4,SWTCHM	;STORE FOR LATER
	PUSHJ	P,.GTWRD	;GET BLOCK+2
	HRRZ	T4,T3		;GET STORAGE POINTER TABLE
	SKIPN	T4		;SKIP IF ONE SETUP
	SKIPA	T4,[[0]]	;NO--SET LOCATION OF ZERO
	HRLI	T4,P1		;INCLUDE INDEX
	MOVEM	T4,SWTCHP	;STORE FOR LATER
	PUSHJ	P,.GTWRD	;GET BLOCK+3
	CAME	T3,[-1]		;SEE IF DEFAULT NAME
	JRST	STRPRH		;NO--GO STORE AWAY
	HRROI	T3,.GTPRG	;YES--GET CURRENT
	GETTAB	T3,		;  PROGRAM'S NAME
	  MOVEI	T3,0		;CLEAR IF NOT AVAILABLE

STRPRH:	MOVEM	T3,SWTHLP	;STORE HELP POINTERS
	POPJ	P,		;RETURN

;.GTWRD -- SUBROUTINE TO GET NEXT WORD FROM USER'S PARAMETER LIST
;CALL:	MOVE	T1,ADDRESS OF TABLE
;	MOVE	T2,COUNTER OF LENGTH TO GO
;	PUSHJ	P,.GTWRD
;RETURNS WITH T1 INCREMENTED, T2 DECREMENTED, T3=CONTENTS OR 0

.GTWRD::SOJL	T2,GETWRX	;DECREMENT COUNTER--CHECK OVERRUN
	SKIPA	T3,(T1)		;GET USER'S VALUE
GETWRX:	MOVEI	T3,0		;GET 0 DUE TO OVERRUN
	AOS	T1		;ADVANCE POINTER FOR NEXT TIME
	POPJ	P,		;RETURN
	SUBTTL	INDIRECT FILE SETUP AND FINISH

;.ALDON -- SUBROUTINE TO HANDLE EOF WHEN READING COMMANDS
;IF INDIRECT MODE, IT CLEARS IND AND EOF AND RETURNS
;ELSE, IT GOES TO MONITOR AND RETURNS ON A CONTINUE


.ALDON::HRREI	C,.CHEOL	;CLEAR EOF
IFN INDEPT,<
	SKIPN	USRIND		;SEE IF USER SUPLIED INDIRECT
	SKIPN	A.DEV		;IF INDIRECT, GO BACK TO NORMAL MODE
	PJRST	.MONRT		;NO INDIRECT--GO HANDLE
	PUSHJ	P,KILIND	;CLEAN UP INDIRECT PROCESSING
	SKIPE	FLCCMD		;IF COMMAND OR CCL MODE
	HRREI	C,.CHEOF	;  RETURN EOF
>
	POPJ	P,		;NO--CLEAR OUT INDIRECT FILE AND BACK TO TTY


;FILE SCANNING ERRORS

E.TMO:	M.FAIL	<More than one output file illegal>
E.FMO::	M.FAIL	<File switches illegal in output file>
E.FMI::	M.FAIL	<Protection switch illegal in input file>
E.INCL:	MOVEI	T1,[ASCIZ /
? Excess arguments starting with "/]
	JRST	.+2
E.ILSC:	MOVEI	T1,[ASCIZ /
? Illegal character "/]
	PUSHJ	P,.TSTRG##
	MOVE	T1,C		;GET CHARACTER IN ERROR
	PUSHJ	P,.TFCHR##	;OUTPUT CHARACTER
	JUMPE	N,ILSC1		;JUMP IF NO WORD
	MOVEI	T1,[ASCIZ /" following word "/]
	PUSHJ	P,.TSTRG##	;TYPE STRING
	MOVE	T1,N		;POSITION WORD
	TLC	N,(77B5)	;SEE IF FIRST
	TLCE	N,(77B5)	;  WORD IS
	TLNN	N,(77B5)	;  0 OR -1
	JRST	[PUSHJ P,.TDECW##	;YES--TYPE AS DECIMAL
		 JRST  ILSC1]	; ..
	PUSHJ	P,.TSIXN##	;NO--TYPE AS SIXBIT
ILSC1:	MOVEI	T1,""""		;DOUBLE QUOTE
	PUSHJ	P,.TCHAR##	;AND TYPE IT
	JRST	.FMSGE		;AND BOMB USER

IFN DEBUG,<
E.PDL:	OUTSTR	[ASCIZ	/?
? PDL phase error
/]
	MONRT.			;DIE WITHOUT TOUCHING ANY AC OR CORE
	JRST	.-1		;LOOP HOPELESSLY
>
;.GTIND--SUBROUTINE TO READ INDIRECT FILE SPECIFIER
;STORED IN AUXILIARY BLOCK STARTING AT A.ZER

IFN INDEPT,<
.GTIND::PUSHJ	P,.FILIN	;GET FILE SPECIFIER
	SETCM	T1,F.NAMM	;GET NAME MASK
	SKIPE	F.NAM		;SEE IF NAME TYPED
	JUMPN	T1,E.IWI	;YES--ERROR IF WILD
	SKIPN	T1,F.EXT	;GET EXTENSION
	SETOM	T1		;KLUDGE IF NOT TYPED
	TRC	T1,-1		;SEE IF
	TRNE	T1,-1		; WILDCARD
	JRST	E.IWI		;YES--BOMB
	SETCM	T1,F.DIRM	;GET DIRECTORY MASK
	MOVX	T2,FX.DIR	;SEE IF
	TDNE	T2,F.MOD	; DIRECTORY TYPED
	JUMPN	T1,E.IWI	;YES--BOMB IF WILD

GTINDF:
IFG INDEPT,<
	MOVEI	T1,INDEPT	;IF FIRST, RESET COUNTER
	SKIPN	A.DEV		; ..
	MOVEM	T1,INDCNT	;TO LIMIT DEPTH
				;  THIS IS NEEDED TO PROTECT
				;  THE USER FROM INFINITE
				;  INDIRECT LOOPS (PARTICULARLY
				;  IF JACCT IS ON)
>
	SKIPE	B.IND+1		;IF ALREADY ONE OPEN,
	PUSHJ	P,KILIND	;  GO BIND IT OFF
	MOVE	T1,[F.ZER,,A.ZER]
	BLT	T1,A.EZER	;TRANSFER TO AUXILIARY BLOCK
INDGT1:	SKIPN	T1,A.EXT	;SKIP IF EXT SPECIFIED
	HRLOI	T1,'CCL'	;DEFAULT IS CCL
	MOVEM	T1,A.EXT
	SKIPN	T1,A.NAM	;SKIP IF NAME SPECIFIED
	MOVE	T1,CCLNAM
	MOVEM	T1,A.NAM
	SKIPN	T1,A.DEV
	JRST	E.ISI		;ERROR IF NO DEVICE
	DEVCHR	T1,		;GET CHARACTERISTICS
	TXNE	T1,DV.TTA	;SKIP IF NOT AN INTERACTIVE DEVICE
	SETOM	FLIIND		;NOTE INTERACTIVE
IFG INDEPT,<
	SOSGE	INDCNT		;DECREMENT COUNT TO PROTECT USER
	JRST	E.TMID		;TOO FAR--BOMB OUT
>
	JUMPLE	C,.POPJ		;EXIT IF END OF LINE
E.ISI:	M.FAIL	<Indirect specification incomplete>
IFG INDEPT,<
E.TMID:	MOVEI	N,A.ZER		;POINT TO FILE SPEC JUST READ IN
	SETOM	T2		;SET FLAG FOR NO ERROR CODE TO PRINT
	PUSHJ	P,KILINB	;CLEAR INDIRECT FILE, BUT NOT FILE NAME
	M.FAIF	<Too many indirect files>
>
E.IWI:	MOVEI	N,F.ZER		;POINT TO FILE SPEC
	SETOM	T2		;FLAG FOR NO ERROR CODE
	PUSHJ	P,KILINB	;CLEAR INDIRECT FILE, BUT NOT FILE NAME
	M.FAIF	<Wildcard illegal in indirect specification>
>
	SUBTTL	DIALOG MODE COMMAND SCANNER

;HERE ON AN ALTMODE AFTER A NULL COMMAND LINE TO DO A DIALOGUE

.DILOG::
IFE FTDIAL,<
	M.FAIL	<Dialogue mode not supported>
>
IFN FTDIAL,<
	PRINTX	? DIALOGUE MODE NOT YET IMPLEMENTED
>
	SUBTTL	SUBROUTINES FOR COMMAND INPUT -- FILE SPECIFICATION

;.FILIN -- INPUT WHAT USER TYPES AS THE NEXT FILE SPECIFICATION
;REMEMBER PERMANENT ("STICKY") DEFAULTS
;APPLY STICKY (USER SUPPLIED) DEFAULTS
;PROCESSES SWITCHES, DEVICE, NAME, EXT., AND DIRECTORY
;RETURN ON FIRST BREAK NOT LEGITIMATELY PART OF A FILE SPEC.
;  (ALSO ON SOME SYNTAX ERRORS LIKE "*X")
;
;A FILE SPECIFICATION IS CRUDELY DESCRIBED AS FOLLOWS:
;	NOT MORE THAN ONE EACH OF
;		DEVICE:
;		FILENAME
;		.EXTENSION
;		[PROJECT,PROGRAMMER]
;		[,PROG] [PROJ,] [,]  IMPLY DEFAULT TO LOGGED IN NUMBER.
;		ANY OF ABOVE EXTENDED FOR SFDS: [P,PN, SFD1,SFD2,...]
;		[-] FOR DEFAULT DIRECTORY
;	ANY NUMBER OF NON-OBVIOUSLY CONFLICTING SWITCHES
;		/NAME
;		/NAME:VALUE
;		WHERE VALUE CAN BE A NUMBER, A NAME, A TIME, ETC.
;SOME SWITCHES APPLY TO FILE NAMES, OTHERS ARE GLOBAL TO THE COMMAND.
;THE DEVICE, EXTENSION, DIRECTORY, AND FILE SWITCHES ARE STICKY
;IF THEY APPEAR BEFORE A FILE NAME, AND LOCAL IT AFTER OR IF
;NO FILE NAME APPEARS.  SPACES MAY BE INSERTED FREELY WHERE NEEDED
;OR DESIRED BETWEEN WORDS, BUT MAY NOT SEPARATE THE PARTS OF A WORD.
;FOR EXAMPLE, "/SWITCH:VALUE" IS OK, BUT "/ SWITCH : VALUE" LOSES.
;
;CALL:	SET ZEROES OR DEFAULTS INTO P.XXX AREA
;	PUSHJ	P,.FILIN
;	RETURN WITH TYPE-INS IN F.XXX AREA, P.XXX UPDATED
;	FLFSP =0 IF NULL, =-1 IF SOMETHING TYPED
;USES T2, T3, T4, N, M    UPDATES C (SEPARATOR)

.FILIN::PUSHJ	P,.SAVE1##	;PRESERVE P1
	SETZM	F.ZER-1		;ZERO FILE RESULT AREA
	MOVE	T1,[F.ZER-1,,F.ZER]
	BLT	T1,F.EZER
	SETOM	F.BFR		;DEFAULT FLAG FOR /BEFORE
	SETOM	F.SNC		; AND /SINCE
	SKIPE	CLRFIL		;SEE IF USER WANTS CONTROL
	PUSHJ	P,@CLRFIL	;YES--GO TO HIM
	JRST	FILIN2		;GO START THE READ

;HERE WHEN SOMETHING FOUND
FILIN1:	SETOM	FLFSP		;SET SOMETHING FOUND FLAG

;HERE TO READ ANOTHER WORD
FILIN2:	PUSHJ	P,.TIAUC	;START THE READ
;HERE WITH WORD, SEE WHAT KIND OF SEPARATOR

FILIN3:	PUSHJ	P,.NAMEC	;READ REST OF WORD
	CAIN	C,":"		;SEE IF DEVICE
	JRST	FILDEV		;YES

	JUMPE	N,FILIN4	;IF NULL, NOT A FILE NAME
	SKIPE	F.NAM		;FILE NAME--SEE IF SECOND TIME
	JRST	E.DFN		;YES--ISSUE DUPL. ERROR
	PUSHJ	P,.LEFTX	;GUARANTEE LH=0
	MOVEM	N,F.NAM		;OK--SAVE NAME
	MOVEM	T1,F.NAMM	;AND MASK
	SETOM	FLFSP		;FLAG THAT SOMETHING FOUND
	PUSHJ	P,FILSTK	;GO MEMORIZE STICKY DEFAULTS

FILIN4:	CAIN	C,"."		;SEE IF EXTENSION
	JRST	FILEXT		;YES
	CAIN	C,"["		;SEE IF DIRECTORY
	JRST	FILDIR		;YES
	CAIN	C,"/"		;SEE IF SWITCH
	SKIPE	SWTCNT		;EXCEPT IF ALREADY VERB OR SWITCH
	JRST	.+2		;NO
	JRST	FILSW		;YES
	CAIN	C," "		;SEE IF WORD SEPARATOR
	JRST	FILIN2		;YES--LOOP BACK FOR MORE WORK
	SKIPN	F.NAM		;SKIP IF FILE NAME SPECIFIED
	PUSHJ	P,FILSTK	;NO, SAVE STICKY DEFAULTS

IFN ECHOP,<
	OUTSTR	[ASCIZ /BEFORE DEFAULTS:	/]
	PUSHJ	P,TFILE		;TYPE OUT F.XXX FOR DEBUGGING
>
	PJRST	APLSTK		;GO APPLY USER DEFAULTS AND RETURN
;HERE WHEN SLASH -- SWITCH COMMING

FILSW:	PUSHJ	P,.KEYWD	;PROCESS SWITCH
	  JRST	E.NSS		;ERROR IF NO SWITCH
	JUMPLE	C,FILINR	;IF END, FLAG SPEC
	JRST	FILINN		;GO LOOK AT BREAK CHAR

;HERE WHEN COLON SEEN -- PREVIOUS WORD IS DEVICE

FILDEV:	SETCM	T1,MASK		;GET COMPLEMENT OF WILDCARD MASK
	JUMPE	N,E.NDV		;ERROR IF NO DEVICE
	JUMPN	T1,E.WDV	;WILDCARD ERROR
	SKIPE	F.DEV		;VERIFY NOT SECOND ONE
	JRST	E.DDV		;ERROR IF TWO
	MOVEM	N,F.DEV		;SAVE
	JRST	FILIN1		;GO READ SOME MORE

;HERE WHEN PERIOD SEEN -- NEXT WORD IS EXTENSION

FILEXT:	PUSHJ	P,.NAMEW	;GO GET THE EXTENSION
	PUSHJ	P,.LEFTX	;PUT INTO LEFT HALF-WORD
	SKIPE	F.EXT		;VERIFY NOT SECOND ONE
	JRST	E.DEX		;ERROR IF TWO
	HLR	N,MASK		;PUT MASK IN RIGHT HALF
	MOVEM	N,F.EXT		;SAVE
	JRST	FILINR		;GO PROCESS NEW BREAK
;HERE WHEN LEFT SQUARE BRACKET SEEN -- DIRECTORY COMING

FILDIR:	MOVX	P1,FX.DIR	;GET DIRECTORY FLAG
	TDNE	P1,F.MODM	;SEE IF SET ALREADY
	JRST	E.DDR		;YES--DOUBLE DIRECTORY ERROR
	IORM	P1,F.MOD	;NO--SET IT
	IORM	P1,F.MODM	; AND IN MASK
	PUSHJ	P,.NOCTW	;GET OCTAL NAME
	PUSHJ	P,.LEFTX	;MOVE TO LEFT HALF-WORD
IFN FTSFD,<
	CAIE	C,"-"		;SEE IF DEFAULT CODE
	JRST	FILDR1		;NO--PROCEED
	SKIPE	NULFLG		;YES--VERIFY NULL NUMBER
	JRST	E.CDR		;NO--ERROR
	ANDCAM	P1,F.MOD	;CLEAR FLAG
	PUSHJ	P,.TIAUC	;GET NEXT CHARACTER
	JRST	FILDR4		;AND FINISH BELOW
>
FILDR1:	TLNE	T1,(1B0)	;SEE IF WILD-CARD OFF
	JUMPL	N,[MOVEM N,F.DIR  ;AND SIXBIT TYPEIN
		   MOVEM T1,F.DIRM
		   JRST  FILDR2]
	CAIE	C,","		;MUST HAVE COMMA NOW
	JRST	E.CDR		;ERROR IF NOT
	TRNE	N,-1		;MAKE SURE THAT
	JRST	E.IPJN		;YES--NAUGHTY USER
	HLLZM	N,F.DIR		;SAVE
	HLLZM	T1,F.DIRM	;AND MASK
	PUSHJ	P,.NOCTW	;GET PROGRAMMER
	PUSHJ	P,.LEFTX	;PUT INTO LEFT HALF-WORD
	TRNE	N,-1		;MAKE SURE THAT PROGRAMMER
	JRST	E.IPGN		;BAD--NAUGHTY USER
	HLRM	N,F.DIR		;SAVE
	HLRM	T1,F.DIRM	;AND MASK
FILDR2:
IFN FTSFD,<
	MOVEI	P1,F.DIR	;PRESET TO ACCUMULATE SUB-DIRECTORIES
FILDR3:	CAIE	C,","		;SEE IF SFD NEXT
	JRST	FILDR4		;NO--EXIT DIRECTORY CODE
	ADDI	P1,2		;ADVANCE ACCUMULATION POINTER
	CAIL	P1,F.DIR+2*.FXLND  ;PROHIBIT OVERFLOW
	JRST	E.SFDL		;NO--BOMB USER
	PUSHJ	P,.NAMEW	;GET WILD NAME
	PUSHJ	P,.LEFTX	;FORCE TO LEFT END
	MOVEM	N,(P1)		;STORE NAME
	MOVEM	T1,1(P1)	;AND MASK
	JUMPE	N,E.NSFD	;NULL FIELD--ERROR
	JRST	FILDR3		;AND LOOP FOR MORE
FILDR4:
>
	CAIE	C,"]"		;MUST HAVE END NOW
	JUMPG	C,E.RDR		;CATCH IMPROPERLY FORMATTED DIRECTORY
	JUMPG	C,FILIN1	;PROCESS SEPARATOR UNLESS EOL
				;FALL INTO FILINR

;HERE WHEN NEXT BREAK CHARACTER TO BE ANALYZED

FILINR:	SETOM	FLFSP		;NOTE THAT SOMETHING HAS HAPPENED
FILINN:	JRST	FILIN3		;AND GO PROCESS SEPARATOR


;.GTSPC -- ROUTINE TO BLT THE FILE SPEC ACCUMULATED
;	TO SOME MORE PERMANENT PLACE
;CALL:	MOVEI	T1,START OF AREA
;	MOVEI	T2,LENGTH OF AREA
;	PUSHJ	P,.GTSPC
;USES T1, T2

.GTSPC::CAIGE	T1,.JBDA	;PROTECT AC'S
	HALT	.		;AGAINST JUNK CALL
	CAILE	T2,.FXLEN	;MAKE SURE NOT TOO LONG
	MOVEI	T2,.FXLEN	;SHRINK IF SO
	ADDI	T2,(T1)		;COMPUTE END PLUS ONE
	HRLI	T1,F.ZER	;COPY FROM F.XXX
	BLT	T1,-1(T2)	;  TO END OF AREA
	SKIPL	FLVERB		;SEE IF VERB MODE
	POPJ	P,		;RETURN
				;YES--FALL INTO STICKY DEFAULT APPLIER
				;FALL HERE FROM ABOVE

;APLSTK -- APPLY USER'S STICKY DEFAULTS
;CALL:	PUSHJ	P,APLSTK
;RETURN WITH T1 .NE. 0 IF 'DSK' SUPPLIED BY THIS ROUTINE

APLSTK:	MOVE	T1,P.DEV	;APPLY DEVICE--PICK UP STICKY
	SKIPN	F.DEV		;SEE IF USER TYPED SOMETHING
	MOVEM	T1,F.DEV	;NO--SUPPLY HIS STICKY DEVICE
	SKIPE	F.EXT		;SEE IF EXTENSION
	JRST	APLST1		;YES--GO ON
	MOVX	T1,FX.NUL	;NO--SET NULL EXT. BIT
	IORM	T1,F.MOD	;FOR LATER
	IORM	T1,F.MODM	;AND IN MASK
	MOVE	T1,P.EXT	;APPLY EXTENSION
	MOVEM	T1,F.EXT	; ..
APLST1:	MOVE	T2,[P.DIR,,F.DIR]
	MOVX	T1,FX.DIR	;GET DIRECTORY FLAG
	TDNN	T1,F.MODM	;SEE IF DIRECTORY SPECIFIED
	BLT	T2,F.DIR+.FXLND-1  ;NO--COPY DEFAULT
	MOVE	T1,P.MOD	;APPLY ALL FILE SWITCHES
	ANDCM	T1,F.MODM	;MASK HERE USED TO INDICATE WHICH WERE TYPED
	IORM	T1,F.MOD	; ..
	MOVE	T1,P.MODM	; ..
	IORM	T1,F.MODM	; ..
	MOVX	T1,FX.ADD	;PREPARE TO SEE IF +
	IORM	T1,F.MODM	;INDICATE THAT WE WORRIED
	CAIN	C,"+"		;CHECK FOR FOLLOWING CHAR
	IORM	T1,F.MOD	;YES--SET FLAG
	MOVE	T1,P.BFR	;GET /BEFORE
	SKIPN	F.BFR		;CHECK THIS ONE
	MOVEM	T1,F.BFR	;STORE
	MOVE	T1,P.SNC	;GET /SINCE
	SKIPN	F.SNC		;CHECK
	MOVEM	T1,F.SNC	;STORE
	SKIPE	APPSTK		;SEE IF USER WANTS CONTROL
	PUSHJ	P,@APPSTK	;YES--GO TO HIM

	SKIPE	FLFSP		;SEE IF SOME FILE HERE
	SKIPE	F.DEV		;YES--SEE IF DEVICE SPECIFIED
	JRST	APLST2		;YES--SKIP DEFAULTING
	MOVSI	T1,'DSK'	;NO--SPECIFY DSK
	MOVEM	T1,F.DEV	;  AS DEVICE
	MOVX	T1,FX.NDV	;GET NULL DEVICE BIT
	IORM	T1,F.MOD	;SET INTO SPECIFICATION
	IORM	T1,F.MODM	; AND INDICATE WE DID

APLST2:
IFN ECHOP,<
	OUTSTR	[ASCIZ /AFTER USER DEFAULTS:	/]
	PUSHJ	P,TFILE
>
	POPJ	P,		;RETURN
;SUBROUTINE TO TYPE OUT F.XXX AREA

IFN ECHOP,<
TFILE:	MOVE	T2,F.DEV
	PUSHJ	P,.TSIXN##
	OUTSTR	[ASCIZ /:/]
	MOVE	T2,F.NAM
	PUSHJ	P,.TSIXN##
	OUTSTR	[ASCIZ /./]
	HLLZ	T2,F.EXT
	PUSHJ	P,.TSIXN##
	MOVE	T1,F.DIR
	PUSHJ	P,.TPPNW
	MOVE	T1,F.MOD
	PUSHJ	P,.TXWDW
	OUTSTR	[ASCIZ /
	  MASKS:	/]
	MOVE	T2,F.NAMM
	PUSHJ	P,.TSIXN##
	OUTSTR	[ASCIZ /./]
	HRLZ	T2,F.EXT
	PUSHJ	P,.TSIXN##
	MOVE	T1,F.DIRM
	PUSHJ	P,.TPPNW
	MOVE	T1,F.MODM
	PUSHJ	P,.TXWDW
	PJRST	.TCRLF##
>
	SUBTTL	SUBROUTINES FOR COMMAND INPUT -- SWITCH OR VERB PROCESSING

;.KEYWD -- SWITCH/VERB SCANNER
;CALL:	PUSHJ	P,.KEYWD
;NON-SKIP RETURN IF NO KEYWORD PRESENT
;SKIP RETURN IF KEYWORD AFTER ARGUMENTS ARE SCANNED
;USES T1-4

.KEYWD::PUSHJ	P,.SAVE2##	;SAVE P1 (SWITCH INDEX)
				;  AND P2 (LOCAL/REMOTE INDEX)
	PUSHJ	P,.SIXSW	;GET NAME
	AOS	SWTCNT		;COUNT RECURSION
	JUMPE	N,.POPJ		;RETURN IF NO KEYWORD

;THIS NEXT CODE SEARCHES USER AND STANDARD SWITCH TABLES TO
;FIND A POSSIBLY ABBREVIATED MATCH.  USER OVERRIDES STANDARD.
;IN ANY TABLE, SEVERAL MATCHING CAUSES DUPLICATE MESSAGE,
;AS DOES ONE ABBREV. IN EACH TABLE.
;EXACT IN EITHER TABLE WINS.

	AOS	(P)		;SET FOR SKIP RETURN (WE FOUND A KEYWORD)
	MOVEI	P1,0		;FLAG NOTHING FOUND YET
	MOVE	T1,SWTPTR	;POINTER TO USER'S SWITCHES
	PUSHJ	P,.NAME		;SEE IF USER'S SWITCH
	  JRST	[JUMPL T1,KEYWDU  ;IF NO MATCH, JUST SEARCH STANDARD ONES
		 SETOM P1	;IF SEVERAL, SET FLAG
		 JRST  KEYWDU]	;  AND SEARCH STANDARD
	MOVEI	P2,SWTCHC	;POINT TO USER'S SWITCH TABLES
	JUMPL	T1,KEYWDG	;DONE IF EXACT MATCH ON USER
	MOVE	P1,T1		;ELSE, SAVE SOLUTION
KEYWDU:	MOVE	T1,[IOWD STSWTL,STSWTN]	;IOWD PTR TO LIST OF SWITCHES
	PUSHJ	P,.NAME		;LOOK-UP NAME IN TABLE
	  JRST	[JUMPG T1,E.DPS	;IMPRECISE--GIVE UP
		 JUMPL P1,E.DPS	 ;FIRST TIME WAS IMPRECISE--GIVE UP
		 JUMPE P1,E.UKS  ;NOT FOUND--IF NOT USER EITHER, GIVE UP
		 MOVE  T1,P1	;IF USER, GET HIS POINTER BACK
		 JRST  KEYWDG]	;  AND GO PROCESS IT
	JUMPL	T1,KEYWDS	;IF EXACT, GO PROCESS IT
	SKIPE	P1		;STANDARD ABBR. IF ALSO USER ABBR.,
	JRST	E.DPS		;  GIVE ERROR
KEYWDS:	MOVEI	P2,STDSWC	;POINT TO STANDARD SWITCH TABLES
KEYWDG:	MOVEI	P1,0		;CLEAR INDEX
	MOVEI	T2,@SWN(P2)	;GET START OF NAME TABLE
	MOVEI	P1,(T1)		;GET ADDRESS OF SWITCH
	SUBI	P1,(T2)		;GET OFFSET OF SWITCH

	MOVE	T1,@SWM(P2)	;GET PROCESSOR OR TABLE POINTER
	HRRZ	N,@SWD(P2)	;GET DEFAULT VALUE
	CAIN	C,":"		;SEE IF VALUE SPECIFIED
	JRST	KEYWD1		;YES--GO CHECK INTO IT
	SKIPL	FLVERB		;SEE IF VERB MODE
	JRST	KEYWD0		;NO--PROCEED
	JUMPLE	C,KEYWD0	;YES--IF NULL, PROCEED
	CAIE	C," "		;UNLESS SPACE,
	MOVEM	C,SAVCHR	;  CAUSE RESCAN OF CHARACTER
	JRST	KEYWD1		;THEN GO GET ARGS
;HERE WHEN DEFAULT NEEDED
KEYWD0:	TLNN	T1,-1		;SEE IF MAX SET
	JUMPN	T1,(T1)		;NO--DIRECT ACTION
	JUMPGE	T1,.SWDPB	;YES--GO STORE DEFAULT
	JUMPE	N,E.UKD		;IF NO DEFAULT, ERROR
	JRST	KEYWD3		;ELSE, STORE IT
KEYWD1:	JUMPG	T1,(T1)		;IF SPECIAL PROCESSOR, GO DO IT
	JUMPE	T1,E.MSW	;IF NO VALUE LEGAL, GIVE ERROR

	PUSHJ	P,.SIXSW	;VALUE IS ANOTHER KEYWORD--GET IT
	MOVE	T1,@SWM(P2)	;REFETCH SUB-KEY POINTER
	PUSHJ	P,.NAME		;LOOK IT UP
	  JRST	KEYWD2		;NOT FOUND
	SUB	T1,@SWM(P2)	;DETERMINE INDEX AS VALUE
	MOVEI	N,(T1)		;PLACE IN VALUE (1,2,...)
	JRST	KEYWD3		;AND GO STORE IT AWAY

KEYWD2:	CAME	N,['0     ']	;SEE IF 0
	JUMPN	N,E.UKK		;NO--ERROR IF NOT BLANK
	MOVEI	N,0		;YES--SET ZERO

KEYWD3:	MOVE	T2,@SWP(P2)	;LOOK AT POINTER
	TLNN	T2,-1		;SEE IF SET
	JUMPN	T2,(T2)		;NO--GO PROCESS DIRECTLY
	JRST	.SWDPB		;AND GO STORE
;HERE WHEN SWITCH VALUE IS A DECIMAL NUMBER

.SWDEC::PUSHJ	P,.DECNW	;GET THE NUMBER
	JRST	.SWMAX		;AND STORE IT

;HERE WHEN SWITCH IS AN OCTAL NUMBER

.SWOCT::PUSHJ	P,.OCTNW	;GET OCTAL WORD
	JRST	.SWMAX		;AND STORE AWAY

;HERE WHEN SWITCH VALUE IS A MULTIPLE WORD SIXBIT QUANTITY

.SWSXM::PUSHJ	P,.SIXMW	;GET SEVERAL WORDS
	JRST	.SWDPB		;AND STORE THEM

;HERE WHEN SWITCH VALUE IS A ONE WORD SIXBIT QUANTITY

.SWSIX::PUSHJ	P,.SIXSW	;GET THE WORD
	JRST	.SWDPB		;AND STORE IT

;HERE WHEN SWITCH VALUE IS A DATE/TIME FIELD IN THE PAST

.SWDTP::PUSHJ	P,.DATIP	;GET DATE,,TIME
	JRST	.SWDPB		;AND STORE IT

;HERE WHEN SWITCH VALUE IS A DATE/TIME FIELD IN THE FUTURE

.SWDTF::PUSHJ	P,.DATIF	;GET DATE,,TIME
	JRST	.SWDPB		;AND STORE IT

;HERE WHEN SWITCH VALUE IS A DATE/TIME FIELD

.SWDTM::PUSHJ	P,.DATIM	;GET DATE,,TIME
	JRST	.SWDPB		;AND STORE IT
;HERE WHEN SWITCH TAKES A FILE SPECIFICATION AS ITS VALUE

.SWFIL::MOVE	T1,[F.ZER,,G.ZER]
	BLT	T1,G.EZER	;SAVE CURRENT SPEC
	SETZM	F.ZER		;CLEAR FILE SPEC
	MOVE	T1,[F.ZER,,F.ZER+1]
	BLT	T1,F.EZER
	PUSHJ	P,FILIN2	;GO GET FILE SPEC
	SETZM	FLFSP		;CLEAR FOUND FLAG
	HRRZ	T1,@SWP(P2)	;USE POINTER AS STARTING POINT
	HLRZ	T2,@SWM(P2)	;USE MAX AS LENGTH
	PUSHJ	P,.GTSPC	;COPY RESULTS
	MOVE	T1,[G.ZER,,F.ZER]
	BLT	T1,F.EZER	;RESTORE ORIGINAL SPECIFICATION
	PJRST	.SWDON		;GO FINISH UP
;HERE ON A HELP SWITCH
;	ARG TO SCANNER IS TYPE AND ADDRESS OF HELP PROCESSOR 
;	LH CONTAINS TYPE OF PROCESSOR, RH CONTAINS VALUE
;	TYPE 0=NO HELP AVAILABLE
;	TYPE 1=ASCIZ STRING, RH=ADDR OF STRING
;	TYPE 2=SUBROUTINE TO BE CALLED, RH=ADDR OF SUBROUTINE

FILSHP:	CAIN	N,HELPSWITCHES	;SEE IF /HELP:SWITCHES
	JRST	FILHLS		;YES--GO LIST THEM
	SKIPN	T1,SWTHLP	;SKIP IF HELP PROCESSOR SPECIFIED
	JRST	FILNOH		;NO, CANT HELP HIM
	HLRZ	T2,T1		;YES, GET CODE
	CAIN	T2,1		;SKIP IF NOT ASCIZ STRING
	JRST	FILTXH		;GO TYPE STRING
	CAIN	T2,2		;SKIP IF NOT SUBROUTINE TO BE CALLED
	PJRST	(T1)		;CALL SUBROUTINE
	CAILE	T2,77		;SEE IF NAME CODE
	JRST	FILHLP		;YES--GO DO IT
	HALT	FILSHX		;UNKNOWN TYPE
FILTXH:	TLZA	T1,-1		;WORD=ADDR OF TEXT STRING
FILNOH:	MOVEI	T1,[ASCIZ /% I can't help you, please read the manual/]
	PUSHJ	P,.TSTRG##	;TYPE STRING
	PUSHJ	P,.TCRLF##	;AND TOP OFF WITH CRLF
	JRST	FILSHX

FILHLP:	PUSHJ	P,.HELPR##	;GO CALL HELPER TO READ SYS: FILE
	JRST	FILSHX		;AND RESTART
;HERE WHEN /HELP:SWITCHES TYPED TO LIST THE SWITCHES

FILHLS:	MOVEI	P2,2		;SET COUNTER
FILHLA:	MOVEI	T1,[ASCIZ /Switches are:/]
	CAIN	P2,1		;SEE IF SECOND PASS
	MOVEI	T1,[ASCIZ /Standard ones:/]
	PUSHJ	P,.TSTRG##	;TYPE HEADER
	MOVE	P1,SWTPTR	;GET POINTER
	CAIN	P2,1		;UNLESS SECOND SHOT
	MOVE	P1,[IOWD STSWTL,STSWTN]
	MOVEI	N,7		;PRESET COUNT FOR FIRST LINE
	JRST	FILHLC		;GO START TYPEOUTS
FILHLB:	PUSHJ	P,.TCOMA##	;SEPARATE SWITCHES BY A COMMA
	SOJG	N,FILHLC	;COUNT OFF SWITCHES IN LINE
	MOVEI	T1,[ASCIZ /
	/]
	PUSHJ	P,.TSTRG##	;START NEW LINE
	MOVEI	N,^D8		;RESET COUNTER
FILHLC:	PUSHJ	P,.TSPAC##	;PRECEDE EACH SWITCH BY A SPACE
	MOVE	T1,1(P1)	;GET NEXT SWITCH
	PUSHJ	P,.TSIXN##	;TYPE IT
	AOBJN	P1,FILHLB	;LOOP UNTIL DONE
	PUSHJ	P,.TCRLF##	;TYPE END OF LINE
	SOJG	P2,FILHLA	;LOOP FOR TWO SHOTS

;HERE AT END OF HELP OUTPUT

FILSHX:	PUSHJ	P,CLRBFN	;SKIP TO EOL ON INPUT
	JRST	.FMSGX		;GO CLEAN UP AND RESTART
;HERE AFTER A NUMERIC SWITCH VALUE TO CHECK AGAINST MAX

.SWMAX::HLRZ	T1,@SWM(P2)	;CHECK MAX
	JUMPE	T1,.SWDPB	;IF NO MAX, LET IT PASS
	JUMPL	N,E.SVNG	;IF NEGATIVE, GIVE UP
	CAMLE	N,T1
	JRST	E.SVTL		;IF NOT IN BOUNDS, GIVE ERROR

;HERE WHEN READY TO STORE VALUE OF A SWITCH

.SWDPB::MOVE	T2,@SWP(P2)	;GET POINTER TO STORAGE LOCATION
	SKIPE	STRSWT		;SEE IF CALLER WANTS CONTROL
	CAIN	P2,STDSWC	;YES--SEE IF HIS SWITCH
	JRST	.+2		;NO
	JRST	[PUSHJ P,@STRSWT  ;YES--GO TO HIM
		   PJRST .SWDON   ;HE SAYS WE SHOULD NOT STORE
		 JRST .+1]	  ;HE SAYS STORE
	TLNN	T2,-1		;SEE IF BYTE POINTER
	HALT	.		;NO--USER SETUP ERROR
	LDB	T4,[POINT 6,T2,11]  ;GET BYTE SIZE
	MOVE	T3,T2		;POINT TO FLAG FIELD
	CAIGE	T4,^D36		;IF PARTIAL, THEN
	AOS	T3		;  IN NEXT WORD
	LDB	T1,T3		;SEE IF ALREADY SOMETHING THERE
	SKIPL	FLVERB		;IN VERB, ALLOW CHANGES
	CAMN	T1,[-1]		;IF -1,
	JRST	FILSWN		;  THEN NOTHING YET
	CAIGE	T4,^D36		;SEE IF FULL WORD
	JUMPE	T1,FILSWN	;NO--OK IF MASK ABSENT
IFN INDEPT,<
	SKIPE	OPTNAM		;SEE IF OPTION FILE
	JRST	.SWDON		;YES--JUST GIVE UP SINCE ALREADY SET
>
	JRST	E.DSW		;NO--DUPLICATE SWITCH

FILSWN:	CAILE	T4,^D36		;SEE IF MULTI-WORD VALUE
	JRST	FILSWW		;YES--GO DO IT
	DPB	N,T2		;NO--LET HARDWARE STORE VALUE
	SETOM	T1		;PREPARE TO UPDATE MASK
	CAIGE	T4,^D36		;SEE IF LT FULL WORD
	DPB	T1,T3		;YES--STORE MASK
	SKIPL	FLDOT		;SEE IF . (STICKY) FLAG SET
	PJRST	.SWDON		;AND RETURN TO CALLER
	TLZ	T2,-1		;GET POINTER ADDRESS
	CAIE	T2,F.MOD	;SEE IF LOCAL FXXX
	JRST	FILSW1		;NO--TRY BELOW
	HRRI	T3,P.MOD	;YES--SWITCH TO PXXX
	DPB	N,T3		;STORE VALUE
	HRRI	T3,P.MODM	;AND MASK
	DPB	T1,T3		;STORE MASK
	PJRST	.SWDON		;AND COMPLETE
FILSW1:	CAML	T2,SWTPFF	;SEE IF
	CAMLE	T2,SWTPFL	;  USER FXXX
	PJRST	.SWDON		;NO--JUST FINISH
	ADD	T2,SWTPFO	;SHIFT TO PXXX
	ADD	T3,SWTPFO	; ..
	HLL	T2,T3		;RESTORE POINTER
	DPB	N,T2		;STORE VALUE
	DPB	T1,T3		;STORE MASK
	PJRST	.SWDON		;AND COMPLETE

;HERE WHEN STORE IS TO MULTIPLE WORDS

FILSWW:	LDB	T1,[POINT 6,T2,11]	;GET NUMBER OF WORDS
	MOVN	T1,T1		;COMPLEMENT
	HRLI	T2,.NMUL	;GET SOURCE
	ADDI	T1,77+2-1(T2)	;SET LENGTH TO LAST ADDRESS (77 IS TWO WORDS)
	BLT	T2,(T1)		;TRANSFER DATA

;HERE AT END OF SWITCH OR VERB PROCESS

.SWDON::SOS	SWTCNT		;BACK UP RECURSION
	POPJ	P,		;AND RETURN TO CALLER
;HERE TO DEFINE STANDARD SWITCHES PROCESSED HERE IN SCANNER

	DEFINE	SWTCHS,<
SP BEFORE,F.BFR,.SWDTP,
SL DENSITY,<POINTR (F.MOD,FX.DEN)>,DENS,DENSIN
SL *HELP,<0,,FILSHP>,HELP,HELPTEXT
SS OKNONE,<POINTR (F.MOD,FX.NOM)>,1
IFN INDEPT,<
SP OPTION,OPTION,.SWSIX,OPT
>
SL PARITY,<POINTR (F.MOD,FX.PAR)>,PAR,PARODD
SS PHYSICAL,<POINTR (F.MOD,FX.PHY)>,1
SP PROTECTION,<POINTR (F.MOD,FX.PRO)>,.SWOCT,PRO
IFN INDEPT,<
SP RUN,N.ZER,.SWFIL,RNL
SP RUNOFFSET,RUNOFF,.SWOCT,RUN
>
SP SINCE,F.SNC,.SWDTP,
SS STRS,<POINTR (F.MOD,FX.STR)>,1
>

;NOW BUILD THE TABLES FROM THE SWTCHS MACRO
	MX.OPT==1
	PD.OPT==0
	MX.RNL==N.EZER-N.ZER+1
	PD.RNL==0
	DOSCAN	(STSWT)
;HERE WE BUILD THE KEYS

KEYS (DENS,<200,556,800,INSTALLATION>)
KEYS (HELP,<SWITCHES,TEXT>)
KEYS (PAR,<EVEN,ODD>)
;FILE SPECIFICATION ERROR MESSAGES

E.DFN:	M.FAIN	<Double file name illegal>
E.WDV:	M.FAIN	<Device wildcard illegal>
E.NDV:	M.FAIL	<Null device illegal>
E.DDV:	M.FAIN	<Double device illegal>
E.DEX:	M.FAIN	<Double extension illegal>
E.CDR:	HLRZS	N
	M.FAIO	<Comma required in directory>
E.DDR:	PUSHJ	P,.NOCTW	;GRAB PROGRAMMER NUMBER FOR MESSAGE
	M.FAIO	<Double directory illegal>
E.RDR:	HLRZS	N
	M.FAIO	<Right bracket required in directory>
E.IPJN:	TRNN	N,-1		;DON'T POSITION IF OK
	HLRZS	N
	M.FAIO	<Improper project number>
E.IPGN:	TRNN	N,-1		;DON'T POSITION IF OK
	HLRZS	N
	M.FAIO	<Improper programmer number>
IFN FTSFD,<
E.SFDL:	MOVEI	N,F.ZER
	MOVEI	T2,.FXLND-1
	M.FAIF	<SFD depth greater than>
E.NSFD:	M.FAIL	<Null SFD illegal>
>
E.UKS:	M.FAIN	<Unknown switch>
E.DPS:	M.FAIN	<Ambiguous switch>
E.NSS:	M.FAIL	<No switch specified>
E.UKK::	M.FAIN	<Unknown switch value>
E.UKD:	MOVE	N,@SWN(P2)
	M.FAIN	<Unknown default for switch>
E.DSW:	MOVE	N,@SWN(P2)
	M.FAIN	<Double switch illegal>
E.MSW:	MOVE	N,@SWN(P2)
	M.FAIN	<No modifier allowed on switch>
E.SVTL::M.FAID	<Switch value too large>
E.SVNG::M.FAID	<Switch value negative>
;FILSTK -- MEMORIZE STICKY DEFAULTS
;CALL:	PUSHJ	P,FILSTK
;	RETURNS AFTER NON-ZERO F.XXX COPIED TO P.XXX
;USES T1, T2

FILSTK:	SKIPGE	FLVERB		;SEE IF VERB MODE
	POPJ	P,		;YES--DON'T SAVE
	SKIPE	T1,F.DEV	;COPY DEVICE
	MOVEM	T1,P.DEV
	SKIPE	T1,F.EXT	;COPY EXTENSION
	MOVEM	T1,P.EXT
	MOVE	T2,[F.DIR,,P.DIR]
	MOVX	T1,FX.DIR	;SET DIRECTORY FLAG
	TDNE	T1,F.MODM	;SEE IF SET
	BLT	T2,P.EZER	;YES--COPY DIRECTORY
	MOVE	T1,F.MOD	;COPY FILE MODIFIERS
	MOVE	T2,F.MODM
	ANDCAM	T2,P.MOD
	IORM	T1,P.MOD
	IORM	T2,P.MODM
	SKIPE	T1,F.BFR	;/BEFORE
	MOVEM	T1,P.BFR
	SKIPE	T1,F.SNC	;/SINCE
	MOVEM	T1,P.SNC
	SKIPE	MEMSTK		;SEE IF USER WANTS CONTROL
	PJRST	@MEMSTK		;YES--GO TO HIM
	POPJ	P,		;RETURN
	SUBTTL	SUBROUTINES FOR COMMAND INPUT -- SUBSUBROUTINES

;.DATIF -- ROUTINE TO SCAN DATE AND TIME ARGUMENT IN FUTURE
;.DATIG -- DITTO (CHARACTER ALREADY IN C)
;CALL:	PUSHJ	P,.DATIF/.DATIG
;	RETURN WITH VALUE IN INTERNAL FORMAT IN N
;USES T1-4	UPDATES C (SEPARATOR)

.DATIF::PUSHJ	P,.TIAUC	;PRIME THE PUMP

.DATIG::SETZM	FLFUTR		;CLEAR FUTURE RELATIVE
	SETZM	FLFUTD		;SET DEFAULT
	AOS	FLFUTD		;  TO FUTURE
	CAIE	C,"+"		;SEE IF FUTURE RELATIVE
	JRST	DATIF1		;NO--JUST GET DATE-TIME
	AOS	FLFUTR		;YES--SET FUTURE REL FLAG
	PUSHJ	P,.TIAUC	;GET ANOTHER CHARACTER
DATIF1:	PUSHJ	P,DATIM		;GET DATE/TIME
	CAMGE	N,NOW		;SEE IF IN FUTURE
	JRST	E.NFTR		;NO--NOT FUTURE ERROR
	POPJ	P,		;RETURN

;.DATIP -- ROUTINE TO SCAN DATE AND TIME ARGUMENT IN THE PAST
;.DATIQ -- DITTO (CHARACTER ALREADY IN C)
;CALL:	PUSHJ	P,.DATIP/.DATIQ
;	RETURN WITH VALUE IN INTERNAL FORMAT IN N
;USES T1-4	UPDATES C (SEPARATOR)

.DATIP::PUSHJ	P,.TIAUC	;PRIME THE PUMP

.DATIQ::SETZM	FLFUTR		;CLEAR PAST RELATIVE
	SETOM	FLFUTD		;SET DEFAULT TO PAST
	CAIE	C,"-"		;SEE IF PAST RELATIVE
	JRST	DATIP1		;NO--JUST GET DATE-TIME
	SOS	FLFUTR		;YES--SET PAST REL FLAG
	PUSHJ	P,.TIAUC	;GET ANOTHER CHARACTER
DATIP1:	PUSHJ	P,DATIM		;GET DATE/TIME
	CAMLE	N,NOW		;SEE IF IN PAST
	JRST	E.NPST		;NO--NOT PAST ERROR
	POPJ	P,		;RETURN
;.DATIM -- ROUTINE TO SCAN DATE AND TIME ARGUMENT
;.DATIC -- DITTO (CHARACTER ALREADY IN C)
;CALL:	PUSHJ	P,.DATIM/.DATIC
;	RETURN WITH VALUE IN INTERNAL FORMAT IN N
;USES T1-4	UPDATES C (SEPARATOR)

.DATIM::PUSHJ	P,.TIAUC	;PRIME THE PUMP

.DATIC::SETZM	FLFUTR		;CLEAR RELATIVE FLAG
	SETZM	FLFUTD		;CLEAR DEFAULT FLAG
	CAIE	C,"+"		;SEE IF FUTURE RELATIVE
	JRST	DATIC1		;NO--PROCEED
	AOS	FLFUTR		;YES--SET FLAG
	JRST	DATIC2		;AND PROCEED
DATIC1:	CAIE	C,"-"		;SEE IF PAST RELATIVE
	PJRST	DATIM		;NO--JUST GET ABS DATE
	SOS	FLFUTR		;YES--SET FLAG
DATIC2:	PUSHJ	P,.TIAUC	;GET NEXT CHAR
				;AND FALL INTO DATE/TIME GETTER

;DATIM -- ROUTINE TO INPUT DATE/TIME
;CALL:	SET FLFUTR TO -1 IF PAST RELATIVE, 0 IF ABSOLUTE, +1 IF FUTURE RELATIVE
;	SIMILARLY FOR FLFUTD TO INDICATE DEFAULT DIRECTION IF FLFUTR=0
;	GET NEXT CHARACTER IN C
;	PUSHJ	P,DATIM
;RETURN WITH TRUE DATE/TIME IN N IN INTERNAL SPECIAL FORMAT
;	SETS NOW TO CURRENT DATE/TIME
;USES T1-4, UPDATES C
;
;TYPE-IN FORMATS:
;	(THE LEADING +- IS HANDLED BY CALLER)
;
;	[ [  DAY IN WEEK	    ]		     ]
;	[ [     NNND		    ]		     ]
;	[ [ [   MM-DD  [-Y   ] ]  : ] [HH[:MM[:SS]]] ]
;	[ [ [  MMM-DD  [-YY  ] ]    ]		     ]
;	[ [ [  DD-MMM  [-YYYY] ]    ]		     ]
;	[	       MNEMONIC			     ]
;WHERE:
;	D	LETTER D
;	DD	DAY IN MONTH (1-31)
;	HH	HOURS (00-23)
;	MM	MONTH IN YEAR (1-12)
;	    OR	MINUTES (00-59)
;	MMM	MNEMONIC MONTH OR ABBREV.
;	SS	SECONDS (0-59)
;	Y	LAST DIGIT OF THIS DECADE
;	YY	LAST TWO DIGITS OF THIS CENTURY
;	YYYY	YEAR
;	DAY IN WEEK IS MNEMONIC OR ABBREVIATION
;	MNEMONIC IS A SET OF PREDEFINED TIMES
				;DESCRIBED ABOVE
				;FALL HERE FROM .DATIC

DATIM:	SKIPE	T1,FLFUTR	;SEE IF FORCED DIRECTION
	MOVEM	T1,FLFUTD	; YES--THAT IMPLIES DEFAULT
	SETOM	VAL1		;CLEAR RESULT WORDS
	MOVE	T1,[VAL1,,VAL2]
	BLT	T1,VAL9		; ..
	PUSHJ	P,.GTNOW##	;GET CURRENT DATE/TIME
	MOVEM	T1,NOW		;SAVE FOR LATER TO BE CONSISTENT
	CAIL	C,"0"		;SEE IF DIGIT
	CAILE	C,"9"		; ..
	JRST	.+2		;NO--MNEMONIC FOR SOMETHING
	JRST	DATIMD		;YES--GO GET DECIMAL
;HERE IF STARTING WITH ALPHA, MIGHT BE DAY, MONTH, OR MNEMONIC
	PUSHJ	P,.SIXSC	;GET SIXBIT WORD
	JUMPE	N,E.ILSC	;ILLEGAL SEPARATOR IF ABSENT
	MOVE	T1,MNDPTR	;POINT TO FULL TABLE
	PUSHJ	P,.NAME		;LOOKUP IN TABLE
	  JRST	E.UKNM		;ERROR IF NOT KNOWN
	MOVEI	N,(T1)		;GET
	SUBI	N,DAYS		;  DAY INDEX
	CAIL	N,7		;SEE IF DAY OF WEEK
	JRST	DATIMM		;NO--LOOK ON
;HERE WHEN DAY OF WEEK RECOGNIZED
	SKIPN	T1,FLFUTD	;GET DEFAULT DIRECTION
	JRST	E.NDSP		;ERROR IF NONE
	MOVEM	T1,FLFUTR	;SET AS FORCED DIRECTION
	HLRZ	T2,NOW		;GET DAYS
	IDIVI	T2,7		;GET DAY OF WEEK
	SUB	N,T3		;GET FUTURE DAYS FROM NOW
	SKIPGE	N		;IF NEGATIVE,
	ADDI	N,7		;  MAKE LATER THIS WEEK
	HLLZ	T1,NOW		;CLEAR CURRENT
	SKIPL	FLFUTD		;SEE IF FUTURE
	TROA	T1,-1		;YES--SET MIDNIGHT MINUS EPSILON
	SUBI	N,7		;NO--MAKE PAST
	HRLZ	N,N		;POSITION TO LEFT HALF
	ADD	N,T1		;MODIFY CURRENT DATE/TIME
	PUSH	P,N		;SAVE DATE
	PUSHJ	P,DATIC		;GO CHECK TIME
	  HRRZ	N,(P)		;NO--USE VALUE IN DATE
	POP	P,T1		;RESTORE DATE
	HLL	N,T1		;  TO ANSWER
	JRST	DATIMX		;CHECK ANSWER AND RETURN
;HERE IF MONTH OR MNEMONIC
DATIMM:	MOVEI	N,(T1)		;GET MONTH
	SUBI	N,MONTHS-1	;  AS 1-12
	CAILE	N,^D12		;SEE IF MONTH
	JRST	DATIMN		;NO--MUST BE MNEMONIC
	MOVEM	N,VAL6		;YES--STORE MONTH
	CAIE	C,"-"		;MUST BE DAY NEXT
	JRST	E.MSDD		;NO--ERROR
	PUSHJ	P,.DECNW	;YES--GET IT
	JUMPLE	N,E.NGTM	;ERROR IF NEGATIVE
	CAILE	N,^D31		;VERIFY IN RANGE
	JRST	E.DTTL		;ERROR IF TOO LARGE
	MOVEM	N,VAL5		;SAVE AWAY
	JRST	DATIY0		;AND GET YEAR IF PRESENT

;HERE IF MNEMONIC
DATIMN:	MOVE	N,(T1)		;GET NAME OF SWITCH
	M.FAIN	<Mnemonic date/time switches not implemented>
;HERE IF STARTING WITH DECIMAL NUMBER
DATIMD:	PUSHJ	P,.DECNC	;YES--GO GET FULL NUMBER
	JUMPL	N,E.NGTM	;ILLEGAL IF NEGATIVE
	CAIE	C,"D"		;SEE IF DAYS
	JRST	DATIN		;NO--MUST BE -
	MOVE	T1,FLFUTD	;YES--RELATIVE SO GET FORCING FUNCTION
	MOVEM	T1,FLFUTR	; AND FORCE IT
	JUMPE	T1,E.NDSP	;ERROR IF DIRECTION UNCLEAR
	CAIL	N,1B18		;VERIFY NOT HUGE
	JRST	E.DTTL		;ERROR--TOO LARGE
	MOVEM	N,VAL5		;SAVE RELATIVE DATE
	PUSHJ	P,.TIAUC	;GET NEXT CHARACTER (SKIP D)
	PUSHJ	P,DATIC		;GO CHECK FOR TIME
	  MOVEI	N,0		;0 IF NONE
	HRL	N,VAL5		;INCLUDE DAYS IN LH
	JRST	DATITR		;GO DO RELATIVE RETURN
;HERE WHEN DIGITS SEEN WITHOUT A FOLLOWING D
DATIN:	CAIE	C,"-"		;SEE IF DAY/MONTH COMBO
	JRST	DATIT		;NO--MUST BE INTO TIME
	CAILE	N,^D31		;MUST BE LESS THAN 31
	JRST	E.DTTL		;NO--ERROR
	JUMPE	N,E.DTZR	;VERIFY NOT ZERO
	MOVEM	N,VAL5		;SAVE VALUE
	PUSHJ	P,.TIAUC	;SKIP OVER MINUS
	CAIL	C,"0"		;SEE IF DIGIT NEXT
	CAILE	C,"9"		; ..
	JRST	DATMMM		;NO-- MUST BE MNEMONIC MONTH
	PUSHJ	P,.DECNC	;YES-- MUST BE MM-DD FORMAT
	JUMPLE	N,E.NGTM	;BAD IF LE 0
	CAILE	N,^D31		;VERIFY LE 31
	JRST	E.DTTL		;BAD
	EXCH	N,VAL5		;SWITCH VALUES
	CAILE	N,^D12		;VERIFY MONTH OK
	JRST	E.DTTL		;BAD
	JRST	DATMM1		;GO STORE MONTH
;HERE WHEN TIME SEEN BY ITSELF
DATIT:	PUSHJ	P,DATIG		;GET REST OF TIME
	  HALT	.		;CAN NOT GET HERE
	SKIPN	FLFUTR		;SEE IF RELATIVE
	JRST	DATIRN		;NO--GO HANDLE AS ABS.
;HERE WITH DISTANCE IN N
DATITR:	SKIPGE	FLFUTR		;IF PAST,
	MOVN	N,N		;  COMPLEMENT DISTANCE
	ADD	N,NOW		;ADD TO CURRENT DATE/TIME
	JRST	DATIMX		;CHECK ANSWER AND RETURN
;HERE WHEN DD- SEEN AND MNEMONIC MONTH COMING
DATMMM:	PUSHJ	P,.SIXSC	;GET MNEMONIC
	MOVE	T1,MONPTR	;GET POINTER TO  MONTH TABLE
	PUSHJ	P,.NAME		;LOOKUP IN TABLE
	  JRST	E.UKMN		;NO GOOD
	MOVEI	N,(T1)		;GET MONTH
	SUBI	N,MONTHS-1	;  AS 1-12
;HERE WITH MONTH INDEX (1-12) IN T1
DATMM1:	MOVEM	N,VAL6		;SAVE FOR LATER
DATIY0:	CAIE	C,"-"		;SEE IF YEAR NEXT
	JRST	DATIRA		;NO--GO HANDLE TIME
;HERE WHEN YEAR NEXT AS ONE, TWO, OR FOUR DIGITS
	SETZB	N,T1		;CLEAR DIGIT AND RESULT COUNTERS
DATIY:	PUSHJ	P,.TIAUC	;GET NEXT DIGIT
	CAIL	C,"0"		;SEE IF NUMERIC
	CAILE	C,"9"		; ..
	JRST	DATIY1		;NO--MUST BE DONE
	IMULI	N,^D10		;ADVANCE RESULT
	ADDI	N,-"0"(C)	;INCLUDE THIS DIGIT
	AOJA	T1,DATIY	;LOOP FOR MORE, COUNTING DIGIT
DATIY1:	JUMPE	T1,E.ILYR	;ERROR IF NO DIGITS
	CAIE	T1,3		;ERROR IF 3 DIGITS
	CAILE	T1,4		;OK IF 1,2, OR 4
	JRST	E.ILYR		;ERROR IF GT 4 DIGITS
	MOVE	T2,N		;GET RESULT
	IDIVI	T2,^D100	;SEP. CENTURY
	IDIVI	T3,^D10		;SEP. DECADE
	CAIG	T1,2		;IF ONE OR TWO DIGITS,
	SETOM	T2		;  FLAG NO CENTURY KNOWN
	CAIN	T1,1		;IF ONE DIGIT,
	SETOM	T3		;  FLAG NO DECADE KNOWN
	MOVEM	T4,VAL7		;SAVE UNITS
	MOVEM	T3,VAL8		;SAVE DECADE
	MOVEM	T2,VAL9		;SAVE CENTURY
;HERE WITH VAL5-9 CONTAINING DAY, MONTH, YEAR, DECADE, CENTURY
DATIRA:	SOS	VAL5		;MAKE DAYS 0-30
	SOS	VAL6		;MAKE MONTHS 0-11
	PUSHJ	P,DATIC		;GET TIME IF PRESENT
	  SKIPG	FLFUTD		;IGNORE ABSENCE
	JRST	DATIRN		; UNLESS FUTURE
;HERE IF FUTURE WITHOUT TIME
	MOVEI	T1,^D59		;SET TO
	MOVEM	T1,VAL2		; 23:59:59
	MOVEM	T1,VAL3		; ..
	MOVEI	T1,^D23		; ..
	MOVEM	T1,VAL4		; ..
;HERE WITH VAL2-9 CONTAINING PARSE OR -1 IF TO BE FILLED IN
;	STRATEGY IS TO FILL-IN HOLES LESS SIGNIFICANT THAN
;	MOST SIGN. FIELD WITH 0; AND TO FILL IN MORE SIGNIFICANT
;	HOLES WITH CURRENT VALUE.  THEN IF WRONG DIRECTION FROM
;	NOW, ADD/SUB ONE TO FIELD JUST ABOVE MOST SIGNIFICANT DIFFERENT
;	(FIELD CARRY NOT NEEDED SINCE IT WILL HAPPEN IMPLICITLY).
DATIRN:	MOVE	T1,NOW		;GET CURRENT DATE/TIME
	PUSHJ	P,.CNTDT##	;CONVERT TO EASY FORMAT
	MOVE	T3,T1		;SAVE MSTIME
	IDIVI	T3,^D1000	; AS SECONDS
	ADD	T2,[^D1964*^D12*^D31]  ;MAKE REAL
	MOVEI	T4,7		;TRY 8 FIELDS
DATIRB:	MOVE	T1,T2		;POSITION REMAINDER
	IDIV	T1,[1
		    ^D60
		    ^D60*^D60
		    1
		    ^D31
		    ^D31*^D12
		    ^D31*^D12*^D10
		    ^D31*^D12*^D10*^D10](T4)  ;SPLIT THIS FIELD FROM REST
	SKIPL	VAL2(T4)	;SEE IF DEFAULT
	JRST	[TLO T3,-1	;NO--FLAG TO ZERO DEFAULTS
		 JRST DATRIC]	;AND CONTINUE LOOP
	SETZM	VAL2(T4)	;DEFAULT TO ZERO
	SKIPL	T3		;SEE IF NEED CURRENT
	MOVEM	T1,VAL2(T4)	;YES--SET THAT INSTEAD
DATRIC:	CAME	T1,VAL2(T4)	;SEE IF SAME AS CURRENT
	JRST	DATIRD		;NO--REMEMBER FOR LATER
	CAIN	T4,3		;SEE IF TIME FOR TIME
	HRRZ	T2,T3		;YES--GET IT
	SOJGE	T4,DATIRB	;LOOP UNTIL ALL DONE
;HERE WHEN FILLED IN CURRENT FOR SIGNIFICANT DEFAULTS
DATIRD:	MOVE	T3,T4		;MAKE COPY OF INDEX
	JUMPL	T3,DATIRF	;JUMP IF ALL DONE
DATIRE:	SKIPGE	VAL2(T3)	;SEE IF DEFAULT
	SETZM	VAL2(T3)	;CLEAR DEFAULT
	SOJGE	T3,DATIRE	;LOOP UNTIL DONE
DATIRF:	AOS	N,T4		;SAVE DEFAULT POINT
	PUSHJ	P,DATIRM	;MAKE CURRENT DATE, TIME
	MOVE	T4,FLFUTD	;GET DEFAULT DIRECTION
	XCT	[CAMGE	T1,NOW
		 JFCL
		 CAMLE	T1,NOW]+1(T4)  ;SEE IF OK
	JRST	DATIRR		;YES--GO RETURN
	SKIPG	FLFUTD		;NO--SEE WHICH DIRECTION
	SOSA	VAL2(N)		;PAST
	AOS	VAL2(N)		;FUTURE
DATIRR:	PUSHJ	P,DATIRM	;REMAKE ANSWER
	MOVE	N,T1		;MOVE TO ANSWER
;HERE WITH FINAL RESULT, CHECK FOR OK
	RADIX	10
DATIMX:	CAMLE	N,[<1964-1859>*365+<1964-1859>/4+<31-18>+31,,0]
	POPJ	P,		;OK--RETURN
	RADIX	8
	M.FAIL	<Date/time out of range>

;SUBROUTINE TO MAKE DATE/TIME
DATIRM:	MOVE	T1,VAL4		;GET HOURS
	IMULI	T1,^D60		;MAKE INTO MINS
	ADD	T1,VAL3		;ADD MINS
	IMULI	T1,^D60		;MAKE INTO SECS
	ADD	T1,VAL2		;ADD SECS
	IMULI	T1,^D1000	;MAKE INTO MILLISECS
	MOVE	T2,VAL9		;GET CENTURIES
	IMULI	T2,^D10		;MAKE INTO DECADES
	ADD	T2,VAL8		;ADD DECADES
	IMULI	T2,^D10		;MAKE INTO YEARS
	ADD	T2,VAL7		;ADD YEARS
	IMULI	T2,^D12		;MAKE INTO MONTHS
	ADD	T2,VAL6		;ADD MONTHS
	IMULI	T2,^D31		;MAKE INTO DAYS
	ADD	T2,VAL5		;ADD DAYS
	SUB	T2,[^D1964*^D12*^D31]  ;REDUCE TO SYSTEM RANGE
	PJRST	.CNVDT##	;CONVERT TO INTERNAL FORM AND RETURN
;SUBROUTINE TO GET TIME IF SPECIFIED
;RETURNS CPOPJ IF NO TIME, SKIP RETURN IF TIME
;  WITH TIME IN RH(N) AS FRACTION OF DAY
;USES T1-4, N

DATIC:	CAIE	C,":"		;SEE IF TIME NEXT
	POPJ	P,		;NO--MISSING TIME
	PUSHJ	P,.DECNW	;GET DECIMAL NUMBER FOR TIME
;HERE WITH FIRST TIME FIELD IN N
	JUMPL	N,E.NGTM	;ERROR IF NEGATIVE
	CAIL	N,^D24		; AND GE 24,
	JRST	E.DTTL		;GIVE ERROR--TOO LARGE
DATIG:	MOVEM	N,VAL4		;SAVE HOURS
	CAIE	C,":"		;SEE IF MINUTES COMING
	JRST	DATID		;NO--DONE
	PUSHJ	P,.DECNW	;YES--GET IT
	CAIL	N,^D60		;SEE IF IN RANGE
	JRST	E.DTTL		;NO--GIVE ERROR
	JUMPL	N,E.NGTM	;ERROR IF NEG
	MOVEM	N,VAL3		;SAVE MINUTES
	CAIE	C,":"		;SEE IF SEC. COMING
	JRST	DATID		;NO--DONE
	PUSHJ	P,.DECNW	;GET SECONDS
	CAIL	N,^D60		;CHECK RANGE
	JRST	E.DTTL		;NO--GIVE ERROR
	JUMPL	N,E.NGTM	;ERROR IF NEG
	MOVEM	N,VAL2		;SAVE SECONDS
;HERE WITH TIME IN VAL2-4
DATID:	SKIPGE	T1,VAL4		;GET HOURS
	MOVEI	T1,0		;  UNLESS ABSENT
	IMULI	T1,^D60		;CONV TO MINS
	SKIPL	VAL3		;IF MINS PRESENT,
	ADD	T1,VAL3		;  ADD MINUTES
	IMULI	T1,^D60		;CONV TO SECS
	SKIPL	VAL2		;IF SECS PRESENT,
	ADD	T1,VAL2		;  ADD SECONDS
	MOVEI	T2,0		;CLEAR OTHER HALF
	ASHC	T1,-^D17	;MULT BY 2**18
	DIVI	T1,^D24*^D3600	;DIVIDE BY SECONDS/DAY
	MOVE	N,T1		;RESULT IS FRACTION OF DAY IN RH
	JRST	.POPJ1		;RETURN
;DATE/TIME ERRORS

E.NFTR:	M.FAIL	<Date/time must be in the future>
E.NPST:	M.FAIL	<Date/time must be in the past>
E.NGTM:	M.FAIL	<Negative number in date/time>
E.NDSP:	M.FAIL	<Not known whether past or future in date/time>
E.DTTL:	M.FAIL	<Field too large in date/time>
E.DTZR:	M.FAIL	<Field zero in date/time>
E.UKMN:	M.FAIL	<Unrecognized month in date/time>
E.ILYR:	M.FAIL	<Illegal year format in date/time>
E.MSTM:	M.FAIL	<Missing time in date/time>
E.UKNM:	M.FAIL	<Unrecognized name in date/time>
E.MSDD:	M.FAIL	<Missing day in date/time>


;MNEMONIC WORDS IN DATE/TIME SCAN

	DEFINE	XX($1),<
	EXP	<SIXBIT	/$1/>>

DAYS:	XX	WEDNESDAY
	XX	THURSDAY
	XX	FRIDAY
	XX	SATURDAY
	XX	SUNDAY
	XX	MONDAY
	XX	TUESDAY

MONTHS:	XX	JANUARY
	XX	FEBRUARY
	XX	MARCH
	XX	APRIL 
	XX	MAY
	XX	JUNE
	XX	JULY
	XX	AUGUST
	XX	SEPTEMBER
	XX	OCTOBER
	XX	NOVEMBER
	XX	DECEMBER

SPDATM:	XX	LUNCH
LSPDTM==.-DAYS

;POINTERS

MONPTR:	IOWD	^D12,MONTHS
MNDPTR:	IOWD	LSPDTM,DAYS
;.NOCTW -- INPUT AN OCTAL NAME FROM COMMAND STRING
;.NOCTC  -- DITTO (CHARACTER ALREADY IN C)
;DIFFERS FROM .NAMEW IN THAT OCTAL IS NORMAL
;
;NAME IS OCTAL IF LEAD # OR ? OR 0-7, NAME IF LEAD A-Z
;
;CALL:	PUSHJ	P,.NOCTC/.NOCTW
;	RETURN WITH VALUE IN N AND MASK
;USES T1-T4    UPDATES C (SEPARATOR)

.NOCTW::PUSHJ	P,.TIAUC	;PRIME THE PUMP

.NOCTC::SETZB	N,NULFLG	;INITIALIZE MASK AND WORD
	CAIE	C,"*"		;LOOK FOR WILD-CARD
	JRST	NOCST		;NO--TRY THE HARD WAY
	TRO	N,-1		;YES--FUDGE A SUITABLE NAME
	PUSHJ	P,.TIAUC	;GET NEXT CHARACTER
	PJRST	NAMER		;AND GO FINISH UP

NOCST:	SETOM	T2		;INITIALIZE MASK
	CAIL	C,"A"		;SEE IF NUMBER
	PJRST	NAMST		;NO--GO GET NAME FORMAT
	PJRST	NAMNU1		;YES--GO GET IT
;.NAMEW -- INPUT A SIXBIT NAME FROM COMMAND STRING
;.NAMEC  -- DITTO (CHARACTER ALREADY IN C)
;NAME CAN BE:
;	*	MASK WILL BE 0
;	#NN?N	MASK WILL BE 0 FOR 3-BITS AT EACH ?
;	AA?A	MASK WILL BE 0 FOR 6-BITS AT EACH ?
;# PRECEEDS AN OCTAL FIELD.  OPTIONAL SINGLE SUFFIX OF
;	K,M,G FOR 2**9,18,27
;
;CALL:	PUSHJ	P,.NAMEC/.NAMEW
;	RETURN WITH WORD IN N AND MASK
;NOTE--ON NULL FIELD N=0, M=-1
;USES T1, T2, T3, T4    UPDATES C (SEPARATOR)

.NAMEW::PUSHJ	P,.TIAUC	;PRIME THE PUMP

.NAMEC::MOVEI	N,0		;CLEAR NAME
	SETOM	NULFLG		;SET NULL TYPEIN FLAG
	CAIE	C,"*"		;LOOK FOR FULL WILD-CARD
	JRST	NAMST		;NO--GO GET NAME
	HRLZI	N,'*  '		;PUT IN NAME FOR THE RECORD
	MOVEI	T2,0		;SET WILD MASK
	PUSHJ	P,.TIAUC	;GO GET ANOTHER CHARACTER
	JRST	NAMER		;AND GO FINISH UP

;HERE TO READ THE NAME IN

NAMST:	SETOM	T2		;INITIALIZE TO FULL MASK
	CAIE	C,"#"		;SEE IF OCTAL SPECIFICATION
	JRST	NAMWD		;NO--GET ALPHANUMERIC

NAMNUR:	SETOM	NULFLG		;INDICATE SOMETHING FOUND
NAMNU:	PUSHJ	P,.TIAUC	;YES--GET NEXT ODGIT
NAMNU1:	CAIE	C,"?"		;SEE IF WILD CARD
	JRST	NAMNU2		;NO--STUFF
	LSH	T2,3		;YES--GET 0 INTO MASK
	LSH	N,3		;UPDATE NAME
	TRO	N,7		;FORCE NAME NON-ZERO
	JRST	NAMNUR		;LOOP BACK FOR MORE
NAMNU2:	CAIL	C,"0"		;SEE IF OCTAL
	CAILE	C,"7"
	JRST	NAMNUE		;NO--MUST BE AT END
	ROT	T2,3		;ADVANCE MASK
	TRO	T2,7		;FORCE THE BITS ON
	LSH	N,3		;ADVANCE ACCUMULATOR
	ADDI	N,-"0"(C)	;ADD IN THIS ODGIT
	JRST	NAMNUR		;AND LOOP BACK FOR MORE
;HERE WHEN COMPLETED AN OCTAL FIELD

NAMNUE:	PUSHJ	P,OCTMUL	;ALLOW OCTAL SUFFIX
	SKIPE	T1		;SEE IF SOMETHING THERE
	SETOM	NULFLG		;YES--SET FLAG
	SETOM	T3
	LSHC	T2,(T1)
	JRST	NAMER		;RETURN

;HERE WHEN TIME TO READ AN ALPHA-NUMERIC FIELD

NAMWD:	MOVEI	T1,0		;CONSTANT TO STORE IN MASK
	MOVE	T4,[POINT 6,N]	;INITIALIZE NAME POINTER
	MOVE	T3,[POINT 6,T2]	;INITIALIZE MASK POINTER

NAMWDC:	CAIE	C,"?"		;SEE IF WILD CARD
	JRST	NAMWD1		;NO--STUFF
	TLNE	T3,(77B5)	;YES--UPDATE MASK
	IDPB	T1,T3
	JRST	NAMWDS		;GO UPDATE NAME

NAMWD1:	PUSHJ	P,.TICAN	;SEE IF ALPHA-NUMERIC
	  JRST	NAMER		;RETURN IF NOT
	TLNE	T3,(77B5)	;PREVENT OVERFLOW
	IBP	T3		;UPDATE MASK
NAMWDS:	SUBI	C," "-' '	;CONVERT TO SIXBIT
	TLNE	T4,(77B5)	;PREVENT OVERFLOW
	IDPB	C,T4		;UPDATE NAME
	PUSHJ	P,.TIAUC	;GET NEXT CHARACTER
	SETOM	NULFLG		;FLAG THAT SOMETHING IS THERE
	JRST	NAMWDC		;LOOP BACK TO PROCESS

NAMER:	SKIPN	NULFLG		;SEE IF SOMETHING PRESET
	MOVEI	T2,0		;NO--CLEAR MASK
	MOVEM	T2,MASK
IFE ECHOW,<
	POPJ	P,
>
IFN  ECHOW,<
NAMER1:	MOVE	T2,N
	PUSHJ	P,.TSIXW
	OUTSTR	[ASCIZ / :: /]
	HLRZ	T1,MASK
	PUSHJ	P,.TOCTW##
	OUTSTR	[ASCIZ /,,/]
	HRRZ	T1,MASK
	PUSHJ	P,.TOCTW##
	PJRST	.TCRLF##
>
;.NAME -- LOOKUP NAME IN TABLE ALLOWING FOR UNIQUE ABBREVIATIONS
;ALWAYS CHECK FOR EXACT MATCH FIRST.
;CALL:	MOVE	N,NAME
;	MOVE	T1,[IOWD LENGTH,START OF TABLE]
;	PUSHJ	P,.NAME
;	ERROR RETURN IF UNKNOWN OR DUPLICATE
;	AND WITH T1.LT.0 IF NOT MATCH, .GT.0 IF SEVERAL MATCHES
;	SKIP RETURN IF FOUND WITH T1 POINTING TO ENTRY
;	AND WITH LH(T1)=0 IF ABBREVIATION, OR T1.LT.0 IF EXACT MATCH
;USES T2, T3, T4

.NAME::	JUMPGE	T1,[SETOM T1	;FLAG UNKNOWN
		    POPJ P,]	;ERROR RETURN
	PUSHJ	P,.SAVE1##	;SAVE P1
	PUSH	P,T1		;SAVE ARGUMENT
	MOVE	T3,N		;SET ARG TO MASK MAKER
	PUSHJ	P,.MKMSK	;MAKE MASK
	MOVE	P1,T1		;SAVE FOR MATCHING
	POP	P,T1		;RECOVER ARGUMENT
	SETOM	T2		;SET ABBREVIATION MATCH COUNTER
	AOS	T1		;POSITION POINTER
NAME1:	MOVE	T3,(T1)		;FETCH TABLE ENTRY
	TLNE	T3,(3B1)	;NOTE THAT * IS 12 IN SIXBIT
	JRST	NAME2		;NOT FORCED MATCH
	LSH	T3,6		;SEE IF IT MATCHES
	XOR	T3,N		;EVEN IN AN ABBR.
	TRZ	T3,77		;CLEAR LAST CHAR SINCE WE DON'T KNOW IT
	AND	T3,P1		; ..
	JUMPE	T3,.POPJ1	;YES--GIVE MATCH RETURN
	JRST	NAME3		;NO--LOOP
NAME2:	XOR	T3,N		;SEE IF EXACT MATCH
	JUMPE	T3,.POPJ1	;YES--A WINNER
	AND	T3,P1		;SEE IF A SUITABLE ABBREVIATION
	JUMPN	T3,NAME3	;NO--LOOP BACK FOR MORE
	MOVE	T4,T1		;SALT AWAY THE LOCATION JUST IN CASE
	AOS	T2		;YES--COUNT 
NAME3:	AOBJN	T1,NAME1	;ADVANCE--LOOP IF NOT DONE YET
	HRRZ	T1,T4		;RESTORE LOCATION OF A WINNER
	JUMPE	T2,.POPJ1	;DONE--JUMP IF ONE ABBREVIATION
	MOVE	T1,T2		;GIVE FLAG TO CALLER
	POPJ	P,		;NONE OR TWO, SO FAIL
;.MKMSK -- MAKE MASK CORRESPONDING TO NON-BLANKS IN SIXBIT WORD
;CALL:	MOVE	T3,WORD
;	PUSHJ	P,.MKMSK
;RETURN WITH MASK IN T1
;USES T2

.MKMSK::MOVEI	T1,0		;CLEAR MASK
	MOVSI	T2,(77B5)	;START AT LEFT END
MAKMS1:	TDNE	T3,T2		;SEE IF SPACE HERE
	IOR	T1,T2		;NO--IMPROVE MASK
	LSH	T2,-6		;MOVE RIGHT ONE CHAR
	JUMPN	T2,MAKMS1	;LOOP UNTIL DONE
	POPJ	P,		;RETURN


;.LEFTX -- FORCE NAME AND MASK INTO LEFT HALF WORD IF NEEDED
;NEEDED BECAUSE OCTAL INPUT IS RIGHT ADJUSTED
;CALL:	MOVE	N,WORD
;	PUSHJ	P,.LEFTX
;	RETURN WITH N,MASK UPDATED (RH JUNK)
;	  AND WITH T1=MASK
;USES NO ACS

.LEFTX::MOVE	T1,MASK		;SETUP MASK
	TLNE	N,-1		;SEE IF LH=0 (NEED TO SWITCH)
	POPJ	P,		;NO
	HRLZ	N,N		;YES--REVERSE NAME
	HRLO	T1,T1		;REVERSE MASK ALSO
	MOVEM	T1,MASK		;AND STORE IT AWAY
	POPJ	P,
;.DECNW -- INPUT A DECIMAL WORD FROM COMMAND STRING
;.DECNC  -- DITTO (CHARACTER ALREADY IN C)
;IF IT STARTS WITH #, THEN OCTAL TYPEIN
;TERMINATES AT FIRST NON-DECIMAL CHARACTER
;THROWS AWAY ANY CHARACTERS BEFORE THE LAST 10 OR SO
;CALL:	PUSHJ	P,.DECNC/.DECNW
;	RETURN WITH WORD IN N
;USES T1	UPDATES C (SEPARATOR)

.DECNW::PUSHJ	P,.TIAUC	;PRIME THE PUMP

.DECNC::CAIN	C,"#"		;SEE IF OCTAL FLAGGED
	PJRST	.OCTNW		;YES--GO READ OCTAL FIELD
	PUSHJ	P,SEENEG	;SEE IF NEGATIVE
	CAIN	C,"#"		;NOW CHECK FOR OCTAL
	PJRST	OCTIN2		;YES--GO READ CHAR AND GET OCTAL
DECIN1:	CAIL	C,"0"		;SEE IF DECIMAL
	CAILE	C,"9"		; ..
	PJRST	DECMUL		;NO--AT END, SO HANDLE SUFFIX
	IMULI	N,^D10		;YES--MULTIPLY NUMBER
	ADDI	N,-"0"(C)	;INCORPORATE DIGIT
	PUSHJ	P,.TIAUC	;GET NEXT CHARACTER
	JRST	DECIN1		;LOOP BACK FOR MORE

;DECMUL -- HANDLE DECIMAL SUFFIX MULTIPLIER
;	K,M,G FOR 10**3,6,9
;CALL:	MOVE	N,NUMBER
;	PUSHJ	P,DECMUL
;	RETURN	WITH NUMBER MULTIPLIED BY SUFFIX
;USES T1  (MULTIPLIER--RETURNED)	UPDATES C (SEPARATOR)

DECMUL:	MOVEI	T1,1		;INITIALIZE SUFFIX MULTIPLIER
	CAIN	C,"K"		;K = 1 000
	MOVEI	T1,^D1000
	CAIN	C,"M"		;M = 1 000 000
	MOVE	T1,[^D1000000]
	CAIN	C,"G"		;G =1 000 000 000
	MOVE	T1,[^D1000000000]
	IMUL	N,T1		;APPLY TO NUMBER
	CAILE	T1,1		;SEE IF SUFFIX
	PUSHJ	P,.TIAUC	;YES--GET ONE MORE CHARACTER
	SKIPE	FLNEG		;SEE IF NEGATIVE
	MOVNS	N		;YES--CHANGE NUMBER
IFE ECHOW,<
	POPJ	P,
>
IFN ECHOW,<
	PJRST	NAMER
>
;.OCTNW -- INPUT AN OCTAL WORD FROM COMMAND STRING
;.OCTNC  -- DITTO (CHARACTER ALREADY IN C)
;TERMINATES AT FIRST NON-OCTAL CHARACTER
;THROWS AWAY ANY CHARACTERS BEFORE THE LAST TWELVE
;CALL:	PUSHJ	P,.OCTNC/.OCTNW
;	RETURN WITH WORD IN N
;USES T1    UPDATES C (SEPARATOR)

.OCTNW::PUSHJ	P,.TIAUC	;PRIME THE PUMP

.OCTNC::PUSHJ	P,SEENEG	;SEE IF NEGATIVE
OCTIN1:	CAIL	C,"0"		;SEE IF OCTAL
	CAILE	C,"7"		;  ..
	PJRST	OCTMUL		;NO--AT END, SO HANDLE SUFFIX
	LSH	N,3		;YES--MULTIPLY NUMBER
	ADDI	N,-"0"(C)	;INCORPORATE DIGIT
OCTIN2:	PUSHJ	P,.TIAUC	;GET NEXT CHARACTER
	JRST	OCTIN1		;LOOP BACK FOR MORE

;OCTMUL -- HANDLE OCTAL SUFFIX MULTIPLIER
;	K,M,G FOR 2**9,18,27
;CALL:	MOVE	N,NUMBER
;	PUSHJ	P,OCTMUL
;	RETURN WITH NUMBER MULTIPLIED BY SUFFIX
;USES T1 (LEFT SHIFT--RETURNED)    UPDATES C (SEPARATOR)

OCTMUL:	MOVEI	T1,0		;INITIALIZE SUFFIX MULTIPLIER
	CAIN	C,"K"		;K = 1 000
	MOVEI	T1,^D9
	CAIN	C,"M"		;M = 1 000 000
	MOVEI	T1,^D18
	CAIN	C,"G"		;G = 1 000 000 000
	MOVEI	T1,^D27
	LSH	N,(T1)		;APPLY TO NUMBER
	SKIPE	FLNEG		;SEE IF NEGATIVE
	MOVNS	N		;YES--CHANGE ANSWER
IFE ECHOW,<
	JUMPE	T1,.POPJ	;RETURN IF NOT SUFFIX
	PJRST	.TIAUC		;IF SUFFIX, GO GET SEPARATOR
>
IFN ECHOW,<
	SKIPE	T1		;SEE IF SUFFIX
	PUSHJ	P,.TIAUC	;YES--GET SEPARATOR
	JRST	NAMER
>
;SEENEG -- SEE IF NEGATIVE NUMBER COMING
;ALSO CLEARS N
;CALL:	MOVEI	C,NEXT CHAR
;	PUSHJ	P,SEENEG
;USES NO ACS

SEENEG:	SETZB	N,FLNEG		;CLEAR N AND NEGATIVE FLAG
	CAIE	C,"-"		;SEE IF NEGATIVE NUMBER
	POPJ	P,		;NO--RETURN
	SETOM	FLNEG		;YES--SET FLAG
	PJRST	.TIAUC		;GET NEXT CHAR AND RETURN
;.SIXSW -- INPUT A SIXBIT WORD FROM COMMAND STRING
;.SIXSC  -- DITTO (CHARACTER ALREADY IN C)
;TERMINATES AT FIRST NON-ALPHANUMERIC CHARACTER
;THROWS AWAY ANY CHARACTERS BEYOND THE FIRST SIX
;CALL:	PUSHJ	P,.SIXSC/.SIXSW
;	RETURN WITH WORD IN N
;USES T1    UPDATES C (SEPARATOR)

.SIXSW::PUSHJ	P,.TIAUC	;PRIME THE PUMP

.SIXSC::MOVEI	N,0		;CLEAR NAME
	MOVE	T1,[POINT 6,N]	;INITIALIZE BYTE POINTER FOR WORD

SIXS1:	PUSHJ	P,.TICAN	;SEE IF CHARACTER IS ALPHA-NUMERIC
	  POPJ	P,		;NO--ALL DONE
	SUBI	C," "-' '	;CONVERT TO SIXBIT
	TLNE	T1,(77B5)	;DON'T OVERFLOW
	IDPB	C,T1		;STORE CHARACTER
	PUSHJ	P,.TIAUC	;GO GET ANOTHER CHARACTER
	JRST	SIXS1		;LOOP BACK TO PROCESS IT


;.SIXMW -- INPUT A SIXBIT MULTIPLE WORD FROM COMMAND STRING
;.SIXMC  -- DITTO (CHARACTER ALREADY IN C)
;TERMINATES AT FIRST NON-ALPHANUMERIC CHARACTER
;THROWS AWAY ANY CHARACTERS BEYOND THE BUFFER
;CALL:	PUSHJ	P,.SIXMC/.SIXMW
;	RETURN WITH STRING IN .NMUL
;USES T1	UPDATES C (SEPARATOR)

.SIXMW::PUSHJ	P,.TIAUC	;PRIME THE PUMP

.SIXMC::SETZM	.NMUL		;CLEAR ACCUMULATOR
	MOVE	T1,[.NMUL,,.NMUL+1]
	BLT	T1,.NMUE	; ..
	MOVE	T1,[POINT 6,.NMUL]	;INITIALIZE BYTE POINTER

SIXM1:	PUSHJ	P,.TICAN	;SEE IF LEGITIMATE ALPHA-NUMERIC
	  POPJ	P,		;NO--MUST BE DONE
	SUBI	C," "-' '	;CONVERT TO SIXBIT
	CAME	T1,[POINT 6,.NMUE,35]	;SEE IF OVERFLOW
	IDPB	C,T1		;NO--STORE
	PUSHJ	P,.TIAUC	;GET NEXT CHARACTER
	JRST	SIXM1		;LOOP BACK TO PROCESS IT
	SUBTTL	SUBROUTINES FOR COMMAND INPUT -- GET NEXT CHARACTER

;.TICAN -- CHECK CHARACTER FOR ALPHA-NUMERIC
;ALPHA-NUMERIC IS A-Z OR 0-9
;CALL:	MOVEI	C,UPPER CASE ASCII CHARACTER
;	PUSHJ	P,.TICAN
;	  RETURN IF NOT ALPHA-NUMERIC
;	SKIP RETURN IF ALPHA-NUMERIC
;PRESERVES ALL ACS

.TICAN::CAIL	C,"0"		;SEE IF BELOW NUMERICS
	CAILE	C,"Z"		;OR IF ABOVE ALPHABETICS
	POPJ	P,		;YES--RETURN
	CAILE	C,"9"		;SEE IF NUMERIC
	CAIL	C,"A"		;OR IF ALPHABETIC

.POPJ1::AOS	(P)		;YES--SKIP RETURN
.POPJ::	POPJ	P,		;RETURN

;.TIAUC -- INPUT ONE COMMAND CHARACTER HANDLING LOWER CASE CONVERSION
;CALL:	PUSHJ	P,.TIAUC
;	RESULT IN C
;USES NO ACS

.TIAUC::PUSHJ	P,.TIALT	;GO GET NEXT CHAR

;.TIMUC -- CONVERT LOWER CASE CHARACTER TO UPPER CASE
;CALL:	MOVEI	C,CHARACTER
;	PUSHJ	P,.TIMUC
;	RETURN WITH UPDATED C
;USES NO ACS

.TIMUC::CAIGE	C,"A"+40	;SEE IF LOWER CASE
	POPJ	P,		;NO--RETURN
	CAIG	C,"Z"+40
	SUBI	C,40		;YES--CONVERT
	POPJ	P,		;RETURN
;.TIALT -- INPUT ONE COMMAND CHARACTER HANDLING ALT-MODES
;CALL:	PUSHJ	P,.TIALT
;	RESULT IN C
;USES NO ACS

.TIALT::SKIPN	C		;SEE IF IN ALT-MODE
	POPJ	P,		;YES--RETURN
				;NO--FALL INTO .TICHR


;.TICHR -- INPUT ONE COMMAND CHARACTER HANDLING SPACING, CONTINUATION,
;AND CONTROL CHARACTERS
;ALT-MODE AND LINE-FEED ARE KEPT DISTINCT
;CALL:	PUSHJ	P,.TICHR
;	RESULT IN C
;USES NO ACS

.TICHR::PUSH	P,T1		;SAVE TEMP

;TYI--COROUTINE TO HANDLE SPECIAL BLANK COMPRESSION,
;  HYPHENATION, AND COMMENTS
;THE TRICK IS TO :
;  1-COMPRESS MULTIPLE SPACES
;  2-IGNORE LEADING SPACES ON EACH LINE
;  3-IGNORE TRAILING SPACES ON EACH LINE
;  4-IGNORE COMMENTS ON EACH LINE (;FOO)
;  5-IGNORE LINE FEEDS PRECEEDED BY HYPHEN (CONTINUATION)
;
;ONE SPECIAL STORAGE AREA IS USED--SCANCH
;	RH CONTAINS THE LAST CHARACTER IN SOME CASES
;THE COROUTINE PC IS IN SCANPC
;	THIS IS 0 UNTIL A NON-SPACE IS SEEN IN A LINE
;	IT IS RESET TO 0 AT THE TOP LEVEL
;BY CONVENTION, T1 IS USED FOR CALLS AND IS PRESERVED ACROSS
;	THE ENTIRE ROUTINE
	HRRE	C,SCANCH	;PICKUP PREVIOUS CHAR IF ANY
	SKIPE	T1,SCANPC	;RESTORE COROUTINE PC
	JRST	(T1)		;DISPATCH
	HRREI	C,.CHEOL	;ELSE, START NEW LINE

;HERE AT START OF LINE--REMOVE LEADING BLANKS
TYIF:	JSP	T1,TISCN	;GET NEXT CHAR AND DISPATCH
	  JRST	TYIX		;EOL--RETURN INDICATING NULL LINE
	  JRST	TYIF		;SPACE--STRIP IT
	  JRST	TYIM		;MINUS--POSSIBLE CONTINUATION LINE

;HERE TO RETURN CURRENT CHARACTER
TYIR:	JSP	T1,TYIP		;RETURN C

;HERE AFTER RETURNING SOMETHING
TYIN:	JSP	T1,TISCN	;GET
	  JRST	TYIE		;EOL--GIVE END
	  JRST	TYIS		;SPACE--MAY NEED TO COMPRESS IT
	  JRST	TYIM		;MINUS--MAYBE CONTINUATION
	JRST	TYIR		;ELSE--GIVE TO CALLER

;HERE WHEN SPACE SEEN
TYIS:	JSP	T1,TISCN	;GET
	  JRST	TYIE		;EOL--THROW AWAY SPACE AND RETURN EOL
	  JRST	TYIS		;SPACE--COMPRESS
	  JRST	.+2		;MINUS--PROCEED
	JRST	TYIQ		;ELSE--GIVE SPACE THEN THIS CHAR
	HRLI	C," "		;RETURN SPACE
	JSP	T1,TYIL		;GO ISSUE SPACE

;HERE WHEN HYPHEN SEEN
TYIM:	JSP	T1,TISCN	;GET
	  JRST	TYID		;EOL--CONTINUATION LINE COMING
	  JRST	TYIT		;SPACE--MAYBE IRRELEVANT SPACE
	  JRST	.+1		;MINUS--NOT CONTINUATION
	HRLI	C,"-"		;ELSE--RETURN MINUS
	JRST	TYII		; AND THEN RE-DISPATCH
;HERE WHEN HYPHEN THEN SPACE SEEN
TYIT:	JSP	T1,TISCN	;GET
	  JRST	TYID		;EOL--CONTINUATION LINE
	  JRST	TYIT		;SPACE--COMPRESS
	  JRST	.+1		;MINUS--FALSE CALL
	HRLI	C,"-"		;RETURN FIRST MINUS
	JSP	T1,TYIL		;  TO CALLER

;HERE WHEN TIME TO RETURN SPACE
TYIQ:	HRLI	C," "		;RETURN SPACE
TYII:	JSP	T1,TYIL		;  TO CALLER
	CAIN	C,"-"		;SEE IF MINUS
	JRST	TYIM		;YES--POSSIBLE HYPHEN
	JRST	TYIR		;NO--REGULAR CHARACTER

;HERE AT END OF LINE TO BE CONTINUED
TYID:	SKIPE	A.DEV		;SEE IF INDIRECT
	SKIPE	FLIIND		; BUT NOT INTERACTIVE
	OUTSTR	[ASCIZ /#/]	;NOTIFY USER
	JRST	TYIF		;AND START OVER

;HERE WITH LITERAL TO GIVE USER IN LH(C)
;	RH(C) HAS LAST CHAR READ FROM INPUT
TYIL:	MOVEM	C,SCANCH	;SAVE LAST CHAR FOR LATER
	HLRES	C		;GET LITERAL FOR CALLER
IFN DEBUG,<
	PJRST	TYIP		;RETURN CHARACTER TO USER
>

;HERE AT END OF NON-NULL LINE
TYIE:
IFN DEBUG,<
	JSP	T1,TYIP		;RETURN IT TO USER
	HALT	TYIF		;ERROR IF USER SCREWS UP
>

;HERE WITH CHARACTER TO GIVE USER
;	T1=PLACE TO RETURN TO ON NEXT ENTRY TO COROUTINE
TYIP:	MOVEM	T1,SCANPC	;SAVE COROUTINE PC FOR NEXT TIME
	MOVEM	C,LASCHR	;SAVE AS LAST CHARACTER

;HERE TO RETURN FROM THE TYI COROUTINE

TYIX:	POP	P,T1		;RESTORE TEMP
IFN ECHOC,<
	OUTCHR	C
>
	POPJ	P,
;TISCN--SUBROUTINE USED BY TYI TO STRIP COMMENTS AND DISPATCH
;CALL:	JSP	T1,TISCN
;	  HERE IF EOL
;	  HERE IF SPACE
;	  HERE IF HYPHEN
;	HERE FOR ALL ELSE
;ALWAYS GIVES CHARACTER IN C
;USES NO ACS

TISCN:	SKIPLE	SAVCHR		;SEE IF CHAR LEFT FROM BEFORE
	JRST	[MOVE C,SAVCHR	;YES--GET IT
		 SETZM SAVCHR	;CLEAR OUT REMEMBERED CHARACTER
		 CAIN  C,C.TE	;SEE IF FUNNY EOL CODE
		 HRREI C,.CHEOL	;YES--SET REAL CODE
		 JRST .+2]	;AND PROCEED
	PUSHJ	P,.TICHT	;NO--GET ONE FROM INPUT

	JUMPLE	C,(T1)		;GIVE EOL RETURN
	CAIN	C," "		;TRY SPACE
	JRST	1(T1)		;SKIP ONCE
	CAIN	C,"-"		;TRY HYPHEN
	JRST	2(T1)		;SKIP TWICE
	CAIE	C,";"		;TRY SEMICOLON
	JRST	3(T1)		;NO--SKIP THREE

;HERE WHEN COMMENT SEEN

	PUSHJ	P,.TICHT	;GET NEXT CHAR
	JUMPG	C,.-1		;LOOP TO EOL
	JRST	(T1)		;GIVE EOL RETURN
;.TICHT -- INPUT ONE CHARACTER AND HANDLE ALL EQUIVALENCES
;.TICHE -- INPUT ONE CHAR AND HANDLE ALL EXCEPT TAB
;ALT-MODE AND LINE FEED ARE KEPT DISTINCT
;CALL:	PUSHJ	P,.TICHE/T
;	RETURN WITH RESULT IN C
;USES NO ACS

.TICHT::PUSHJ	P,.TICHE	;GET CHAR HANDLING MOST EQUIVS
	CAIN	C,.CHTAB	;SEE IF TAB
	MOVEI	C," "		;YES--MAKE INTO SPACE
	POPJ	P,		;RETURN

.TICHE::
TYICH1:	PUSHJ	P,.TIGET	;GET ONE CHARCTER
	JUMPL	C,.POPJ		;IF END-OF-LINE, RETURN
	JUMPE	C,TYICH1	;IGNORE NULLS
	CAIE	C,.CHCRT	;IGNORE CARRIAGE RETURNS
	CAIN	C,.CHDEL	;IGNORE RUBOUTS
	JRST	TYICH1		; ..
	CAIE	C,.CHALT	;MAKE VARIOUS FLAVORS OF ALT-MODE
	CAIN	C,.CHAL2	;  BEHAVE THE SAME
	HRREI	C,.CHALX	; ..
	CAIN	C,.CHESC	;OR STANDARD ONE
	HRREI	C,.CHALX	;YES--SET CODE
	CAIN	C,.CHESC	;IF SOME TYPE OF ALT-MODE,
	PUSHJ	P,.TCRLF##	;  GIVE A FREE CR/LF
	CAIL	C,.CHLFD	;MAKE LINE FEED
	CAILE	C,.CHFFD	;  AND FORM FEED
	JRST	.+2		;  (NOT TRUE)
	HRREI	C,.CHEOL	;  ALL INTO END-OF-LINE
	CAIN	C,.CHCNC
	JRST	[SETZM SCANPC	;^C SO CLEAR LINE FLAGS
		 JRST  TYICHF]	;AND HANDLE AS ^Z
	CAIN	C,.CHCNZ	;MAKE ^C AND ^Z
TYICHF:	JRST	[HRREI C,.CHEOF	;  BE END OF FILE
		 JRST  .+1]	;  ..
	MOVEM	C,LASCHR	;SAVE CHARACTER FOR LATER ON
	POPJ	P,		;NO--RETURN
	SUBTTL	INDIRECT FILE HANDLING

;.TIGET -- SUBROUTINE TO GET ONE CHARACTER FROM COMMAND INPUT
;	AND HANDLE MULTIPLE FILES AND INDIRECTING
;CALL:	PUSHJ	P,.TIGET
;	RETURN WITH RESULT IN C
;USES NO ACS

.TIGET::PUSHJ	P,TIGET		;GO DO IT
	MOVEM	C,LASCHR	;SAVE LAST CHARACTER
	POPJ	P,		;RETURN

TIGET:
IFN INDEPT,<
	SKIPE	A.DEV		;SEE IF INDIRECT
	JRST	TYIIND		;YES--GET NEXT CHAR FROM FILE INSTEAD OF TTY
>
	CAMN	C,[.CHEOF]	;IF TTY INPUT WRONG, GIVE IT BACK
	POPJ	P,		;RETURN
	SKIPE	TYPIN		;SEE IF CALLER SUPPLYING TYPIN
	PJRST	@TYPIN		;YES--GET FROM HIM
	INCHWL	C		;NO--GET FROM USER
	POPJ	P,		;RETURN

;HERE TO GET NEXT CHAR FROM INDIRECT OR CCL FILE

IFN INDEPT,<
TYIIND:	SKIPE	B.IND+1		;SKIP IF INDIRECT OR CCL FILE NOT SET UP
	PJRST	TYIIGT		;READY TO READ NEXT CHAR

;HERE TO OPEN INDIRECT OR CCL FILE

	SETZM	INDUSI		;CLEAR USETI POINTER
	MOVE	C,A.DEV		;GET DEVICE
	DEVCHR	C,		;GET ITS CHARACTERISTICS
	TXNN	C,DV.DSK	;SEE IF DISK
	TXNE	C,DV.DIR	;OR NOT DIRECTORY DEVICE
	JRST	.+2		;OK
	HRROS	INDUSI		;NO--NO USETI LOGIC
	PUSHJ	P,TYIINL	;GO LOOK AT FILE
	  JRST	TYINGF		;CAN'T--RETURN EOF

;HERE TO GET INDIRECT CHARACTER
TYIIGT:	SKIPL	C,B.IND+1	;SEE IF AT END OF WORD
	TLNN	C,(76B5)	; ..
	SKIPE	FLSOL		;YES--SEE IF END OF LINE
	PJRST	TYIIGC		;NO--JUST GET CHARACTER
	PUSHJ	P,TYIIGC	;YES--MIGHT BE A SEQUENCE NUMBER
				;  SO GET NEXT CHARACTER
	AOJL	C,TYINGF	;EXIT IF EOF
;STILL UNDER INDEPT

	PUSH	P,T1		;MAKE ROOM
	MOVE	T1,B.INDC	;GET CHAR COUNT
	CAIGE	T1,5		;SEE IF SOME MORE LEFT
	JRST	TYIIGN		;NOT ENOUGH--IGNORE SEQ. TEST
	MOVE	T1,@B.IND+1	;GET FIRST WORD OF LINE
	TRNN	T1,1		;SEE IF FLAG SET
TYIIGN:	JRST	[POP  P,T1	;NO--RESTORE TEMP
		 SOS  C		;CORRECT OFFSET COUNT
		 POPJ P,]	;AND RETURN
	MOVEI	T1,5		;GOT A SEQUENCE--ZAP 5 MORE CHARS
TYIIGL:	PUSHJ	P,TYIIGC	;GET CHAR TO THROW AWAY
	AOJL	C,TYINGP	;EXIT IF EOF
	SOJG	T1,TYIIGL	;NO--LOOP UNTIL CAUGHT UP
	POP	P,T1		;RESTORE TEMP

;HERE TO READ ONE CHAR FROM BUFFER

TYIIGC:	SOSLE	B.INDC			;SKIP IF NO MORE CHARS IN CORE
	JRST	TYIIG2		;OK, GET NEXT
	SKIPN	B.IND		;SKIP IF NOT CCL IN CORE
	JRST	TYINGF		;IF CCL IN CORE, ALL DONE
	AOS	C,INDUSI	;ADVANCE USETI POINTER
	MOVEI	C,-1(C)		;GET RH(PREVIOUS VALUE)
	JUMPE	C,TYIIG1	;JUMP IF FIRST TIME
	PUSHJ	P,TYIINL	;LOOKUP FILE AGAIN
	  JRST	TYINGF		;CAN'T GIVE EOF
	SKIPGE	C,INDUSI	;UPDATE USETI COUNTER
	JRST	TYINGF		;GIVE EOF IF NOT DISK
	CAILE	C,1		;OMIT INITIAL POSITIONING
	USETI	IND,(C)		;TELL MONITOR TO POSITION FILE

TYIIG1:	IN	IND,		;DEVICE, READ NEXT BUFFER
	  JRST	TYIIGA		;NO PROBLEMS--GO PICK UP DATA
	STATZ	IND,IO.EOF	;SKIP IF GOT SOME DATA
	  JRST	TYINGF		;EOF
TYIIGA:	MOVE	C,B.IND+2	;GET CHARACTER COUNTER
	MOVEM	C,B.INDC	;STORE IN SAFE PLACE
	RELEAS	IND,		;FREE UP INDIRECT CHANNEL
TYIIG2:	ILDB	C,B.IND+1
	CAIL	C,.CHLFD	;SEE IF AT END OF LINE
	CAILE	C,.CHFFD	; ..
	JRST	[SKIPE C	;NO--SEE IF NON-NULL
		 SETOM FLSOL	;YES--FLAG STARTED LINE
		 POPJ  P,]	;AND RETURN
	SETZM	FLSOL		;CLEAR FLAG TO INDICATE START OF NEXT LINE
	POPJ	P,

TYINGP:	POP	P,T1		;RESTORE T1
TYINGF:	HRREI	C,.CHEOF	;IF TTY INPUT IMPROPER, FLAG EOF
	POPJ	P,		;RETURN
;STILL UNDER INDEPT

;TYIINL -- ROUTINE TO LOOKUP INDIRECT FILE
;CALL:	PUSHJ	P,TYIINL
;NON-SKIP IF FAILURE
;SKIP IF OK
;PRESERVES ALL ACS

TYIINL:	PUSH	P,T1		;SAVE ACS AS ADVERTIZED
	PUSH	P,T2		;WHICH REMINDS ME OF THE COMMENT I ONCE SAW
	PUSH	P,T3		;TO THE EFFECT THAT IF YOU DONT UNDERSTAND THIS,
	PUSH	P,T4		;YOU HAVE NO RIGHT TO BE READING THIS CODE
	SKIPG	FLCCL		;SKIP IF CCL, WHICH NEEDS TMPCOR
	JRST	TYIIN1		;NO, MUST BE DEVICE
	MOVE	T1,[.TCRRF,,T2]	;CORE FUNCTION TO READ AND DELETE FILE
	HRLZ	T2,CCLNAM	;NAME OF CCL FILE
	MOVE	T3,[IOWD LN.ABF,A.BUF]	;BUFFER
	TMPCOR	T1,
	  JRST	TYIIN1		;NO SUCH FILE, TRY DEVICE
	IMULI	T1,5		;THIS MANY CHARS
	MOVEM	T1,B.INDC	;FAKE BUFFER HEADER
	MOVE	T1,[POINT 7,A.BUF]	;BYTE PTR
	MOVEM	T1,B.IND+1
	JRST	TYIIN4		;GO GET FIRST CHAR
TYIIN1:	SETZ	T1,
	MOVE	T2,A.DEV
	MOVEI	T3,B.IND
	OPEN	IND,T1		;OPEN INDIRECT DEVICE
	  JRST	E.INDO		;NOT TODAY
	SKIPN	T1,A.NAM	;SKIP IF FILE NAME
	JRST	TYIIN4		;NONE SPECIFIED, ASSUME OK
	HLLZ	T2,A.EXT
	SETZ	T3,
;STILL UNDER INDEPT

TYIIN2:	MOVE	T4,A.DIR
	JUMPE	T4,TYIIN3	;PROCEED IF DEFAULT
	TLNN	T4,-1		;SEE IF PROJECT
	HLL	T4,OURPPN	;NO--DEFAULT TO MINE
	TRNN	T4,-1		;SEE IF PROGRAMMER
	HRR	T4,OURPPN	;NO--DEFAULT TO ME
	MOVEM	T4,A.DIR	;SAVE RESULT
TYIIN3:	LOOKUP	IND,T1		;LOOKUP INDIRECT FILE
	  JRST	TYININ		;CANT MAKE IT
	LSH	T3,-^D27	;POSITION PROTECTION
	MOVE	T1,T3		;SETUP FOR CHKACC
	HRLI	T1,.ACRED	;SET FUNCTION "READ"
	MOVE	T3,OURPPN	;GET THIS PPN
	SKIPN	T2,A.DIR	;GET FILE'S DIRECTORY
	MOVE	T2,T3		;USE USER IF DEFAULTED
	MOVEI	T4,T1		;POINT TO ARGS
	CHKACC	T4,		;ASK MONITOR IF READ OK
	  MOVEI	T4,0		;ASSUME YES IF NOT IMPLEMENTED
	MOVEI	T2,ERPRT%	;PRESET PROTECTION FAILURE
	JUMPN	T4,E.INDL	;IF PROTECTED, GO GIVE ERROR

	PUSH	P,.JBFF
	MOVEI	T1,A.BUF
	MOVEM	T1,.JBFF
	INBUF	IND,1
IFN DEBUG,<
	MOVE	T1,.JBFF	;SEE HOW MUCH MONITOR GRABBED
	CAILE	T1,A.BUFE	;COMPARE WITH OUR FIXED ALLOCATION
	HALT	.+1		;GIVE UP IF MONITOR IS A HOG
>
	POP	P,.JBFF
TYIIN4:	POP	P,T4
	POP	P,T3
	POP	P,T2
	POP	P,T1
	JRST	.POPJ1		;SKIP RETURN

TYININ:	SKIPLE	INDUSI		;SEE IF FIRST TIME HERE
	JRST	E.INDL		;NO--JUST GIVE UP
	MOVX	T4,FX.NUL	;PRESET FOR TEST
	TDNE	T4,A.MOD	;SEE IF NULL EXTENSION SPECIFIED
	TLZN	T2,-1		;YES--SKIP IF NOT A NULL EXTENSION
	JRST	E.INDL		;NO--GIVE LOOKUP ERROR
	JUMPN	T2,E.INDL	;JUMP IF STRANGE ERROR
	SETZM	A.EXT		;NO--CLEAR EXTENSION
	JRST	TYIIN2		;AND TRY AGAIN
;HERE ON INDIRECT ERRORS

E.INDL:	HRREI	C,.CHEOF	;LOOKUP ERROR--FLAG EOF
	PUSHJ	P,KILINB	;CLEAR INDIRECT FILE BUT LEAVE NAME
	TLZ	T2,-1		;CLEAR JUNK
	SKIPE	OPTNAM		;SEE IF OPTION MODE
	JRST	[CAIE	T2,ERSNF%	;IS DIRECTORY MISSING?
		 CAIN	T2,ERSLE%	;OR SEARCH LIST EMPTY?
		 JRST	EINDL2		;YES--NO MESSAGE
		 SOJLE	T2,EINDL2	;JUMP IF NOT FOUND
		 AOJA	T2,.+1]		;ELSE GIVE MESSAGE
	SKIPLE	FLCCL		;SEE IF CCL MODE
	JUMPE	T2,[SETZM FLCCMD  ;CLEAR COMMAND MODE
		    SETZM FLCCL   ;CLEAR CCL MODE
		    SOS   .JBSA   ;RESTORE STARTING ADDRESS
		    JRST  EINDL2]
	MOVEI	N,A.DEV		;GET POINTER TO FILE SPEC
	M.FAIF	<Indirect file LOOKUP error>
EINDL2:	SOS	(P)		;ALLOW FOR .POPJ1
	JRST	TYIIN4		;RETURN

E.INDO:	HRREI	C,.CHEOF	;OPEN ERROR--FLAG EOF
	MOVE	N,A.DEV		;GET DEVICE NAME
	PUSHJ	P,KILIND	;KILL INDIRECT FILE AND NAME
	M.FAIN	<Can't OPEN indirect device>
;KILIND -- ROUTINE TO CLEAR INDIRECT FILE
;KILINB -- ROUTINE TO CLEAR INDIRECT FILE BUT NOT NAME
;CALL:	PUSHJ	P,KILIND/KILINB
;USES T1

KILIND:	SKIPE	B.IND+1		;SEE IF INDIRECT OPEN
	SKIPG	FLCCL		;SEE IF CCL FILE
	JRST	KILIN2		;YES--GO RELEASE I/O
	SETOM	FLCCL		;SET TO NORMAL CCL MODE
	SKIPN	B.IND		;SEE IF TEMP CORE
	JRST	KILIN1		;YES--GO ZAP IT
	PUSHJ	P,TYIINL	;REOPEN FILE
	  JRST	KILIN2		;CAN'T--GIVE UP
	SETZB	T1,T2		;YES--DELETE FILE
	SETZB	T3,T4		; ..
	RENAME	IND,T1		; ..
	  JFCL			;IGNORE ERROR
	JRST	KILIN2		;GO FINISH UP
KILIN1:	MOVE	T1,[.TCRDF,,T2]	;DELETE
	HRLZ	T2,CCLNAM	;  TEMP CORE
	MOVE	T3,[IOWD LN.ABF,A.BUF]
	TMPCOR	T1,		;  FILE
	  JFCL			;IGNORE ERROR
KILIN2:	SETZM	A.DEV		;CLEAR INDIRECT DEVICE
KILINB:	RELEAS	IND,		;RELEASE CHANNEL
	SETZM	B.ZER		;CLEAR INDIRECT STUFF
	MOVE	T1,[B.ZER,,B.ZER+1]
	BLT	T1,B.EZER	; ..
	POPJ	P,		;RETURN
>	;END OF INDEPT
	SUBTTL	SUBROUTINES FOR ERROR MESSAGE OUTPUT

;.FMSG -- ISSUE FATAL MESSAGE AND RESTART JOB
;CALL:M.FAIL	<MESSAGE>

.FMSG::	PUSHJ	P,.TERRP
	JRST	.FMSGE		;GO FINISH UP

;.FMSGN -- ISSUE FATAL MESSAGE WITH SIXBIT ARGUMENT FROM N
;CALL:	M.FAIN	<MESSAGE>
;.FMSGD -- ISSUE FATAL MESSAGE WITH DECIMAL ARGUMENT N
;CALL:	M.FAID <MESSAGE>
;.FMSGO -- ISSUE FATAL MESSAGE WITH OCTAL ARGUMENT N
;CALL:	M.FAIO <MESSAGE>

.FMSGN::MOVEI	T4,.TSIXN##	;GET SIXBIT TYPER
	JRST	FMSGXE		;GO DO THINGS

.FMSGD::MOVEI	T4,.TDECW##	;GET DECIMAL TYPER
	JRST	FMSGXE		;GO DO THINGS

.FMSGO::MOVEI	T4,.TOCTW##	;GET OCTAL TYPER

FMSGXE:	PUSHJ	P,.TERRP	;TYPE LEADING ? AND MESSAGE
	MOVE	T1,N		;GET ARGUMENT
	PUSHJ	P,(T4)		;TYPE IT
	JRST	.FMSGE		;GO FINISH UP

;.FMSGF -- ISSUE FATAL MESSAGE WITH FILE DESCRIPTOR
;CALL:	MOVEI	N,ADDR OF FILE DESCRIPTOR
;	HRR	T2,ERROR CODE (OR -1 IF NONE)
;	M.FAIF	<MESSAGE>
;CHANGES	T1,T2,T3
;RESTORES P TO VIRGIN STATE
;JUMPS TO RESTART

.FMSGF::HRL	N,T2		;N=ERROR CODE
	PUSHJ	P,.TERRP
	JUMPL	N,FMSGF1	;IF NO ERROR CODE, SKIP TYPE OUT
	HLRZ	T1,N		;ERROR CODE
	PUSHJ	P,.TOCTW##
	PUSHJ	P,.TSPAC##
FMSGF1:	HRRZ	T1,N		;GET FILE POINTER
	PUSHJ	P,.TFBLK##	;TYPE FILE BLOCK
				;FALL INTO .FMSGE
;.FMSGE -- FINISH UP FATAL ERROR PROCESSING
;.FMSGX -- SAME EXCEPT DON'T CLEAR TYPE AHEAD
;CALL:	JRST	.FMSGE
;RESTORES P TO VIRGIN STATE
;JUMPS TO RESTART

.FMSGE::PUSHJ	P,.CLRBF	;CLEAR OUT ANY TYPE-AHEAD
	SKIPG	FLVERB		;SEE IF VERB MODE
	SKIPN	A.DEV		;YES--SEE IF INDIRECT FILE
	JRST	.+2		;NO--LEAVE CHARACTER ALONE
	HRREI	C,.CHEOF	;YES--FORCE EOF

.FMSGX::PUSHJ	P,.TCRLF##	;SEND CR/LF
	PUSHJ	P,.TCRLF##	;SEND ANOTHER
	MOVE	P,SAVPDP	;RESTORE P
	SKIPGE	FLVERB		;SKIP IF VERB FORM
	JRST	VRSTRT		;VERB RESTART
	SKIPN	T1,SAVCAL	;SEE IF SOME CALL SAVED
	JRST	FMSGEX		;NO--GO DIE
	MOVEM	T1,(P)		;YES--RESTORE IT
	SKIPN	FLVERB		;SEE IF TRAD. MODE
	POPJ	P,		;NO--PART. MODE SO START IT OVER
	MOVEM	T1,-5(P)	;YES--RESTORE BEFORE .SAVE4 AREA
	HRRI	T1,.SAVX4##	;RESET .SAVE4 RETURN POINT
	MOVEM	T1,(P)		; ..
	JRST	RESTRT		;AND GO START OVER

FMSGEX:	PUSHJ	P,.MONRT	;RETURN
	EXIT			;TOLERATE NO NONSENSE
;.CLRBF -- ROUTINE TO CLEAR TYPE-AHEAD
;	IF INDIRECT, IT GOES TO END OF THIS LINE
;CALL:	PUSHJ	P,.CLRBF
;USES ONLY C

.CLRBF::
IFN INDEPT,<
	SKIPE	B.IND+1		;SEE IF INDIRECT OPEN
	JRST	CLRBFN		;YES--GO DO IT
>
	CLRBFI			;NO--CLEAR TYPE AHEAD
	JRST	CLRBFX		;GO CLEAN UP

;ROUTINE TO SKIP TO END OF LINE

CLRBFN:	MOVE	C,LASCHR	;GET LAST INPUT CHARACTER
	SKPINC			;SEE IF TTY INPUT
IFN INDEPT,<
	  SKIPE	B.IND+1		;OR INDIRECT FILE
	JRST	.+2		;YES--SKIP ON
>
	HRREI	C,.CHEOL	;NO--DUMMY UP EOL
	JUMPLE	C,CLRBFX	;CLEAN UP WHEN DONE
	PUSHJ	P,.TICHR	;GET NEXT CHAR
	JRST	CLRBFN		;CONTINUE UNTIL DONE

CLRBFX:	SETZM	SAVCHR		;CLEAR SAVED CHARACTER
	SETZM	SCANPC		;CLEAR BLANK COMPRESSOR
	CAME	C,[.CHEOF]	;IF NOT EOF,
	HRREI	C,.CHEOL	;  SET EOL
	MOVEM	C,LASCHR	;SAVE AS LAST CHAR
	POPJ	P,		;AND RETURN
;.MONRT -- EITHER RETURN TO MONITOR OR, IF NOT LOGGED IN, DO A KJOB
;CALL:	PUSHJ	P,.MONRT		(FLAG FLNLGI SET)
;PRESERVES ALL ACS

.MONRT::SKIPE	FLNLGI		;SEE IF WE ARE LOGGED IN
	JRST	MONRT1		;NO--MUST GO KJOB
IFN INDEPT,<
	PUSHJ	P,KILIND	;CLEAR INDIRECT STUFF
	SETZM	FLCCL		;CLEAR CCL MODE
>
	SETZM	FLCCMD		;CLEAR COMAND MODE
	SKIPE	MONRT		;SEE IF CALLER WANTS CONTROL
	PJRST	@MONRT		;YES--GIVE IT TO HIM
	RESET			;CLEAR ALL I/O
	MONRT.			;YES--RETURN TO MONITOR
	POPJ	P,		;IN CASE OF CONTINUE

MONRT1:	SKIPG	FLNLGI		;SEE IF NOT KNOWN IF LOGGED IN
	OUTSTR	[ASCIZ /

.KJOB
/]
	LOGOUT			;KILL THE JOB




;.TERRP -- SUBROUTINE TO TYPE ADDRESS OF CALL TO FATAL ERROR
;AND TO TYPE THE ? AND THE TEXT ARGUMENT
;CALL:	MOVEI	T1,ASCIZ STRING
;	PUSHJ	P,.TERRP
;USES T1

.TERRP::PUSH	P,T1
IFE DEBUGA,<
	MOVEI	T1,[ASCIZ /
? /]
>
IFN DEBUGA,<
	MOVEI	T1,[ASCIZ /
? (/]
>
	PUSHJ	P,.TSTRG##	;OUTPUT STRING
IFN DEBUGA,<
	MOVE	T1,(P)		;GET ARGUMENT
	HRRZI	T1,-1(T1)	;ADDRESS OF CALL TO FATAL ERROR PROCESSOR
	PUSHJ	P,.TOCTW##	;TYPE ADDRESS
	MOVEI	T1,[ASCIZ /) /]
	PUSHJ	P,.TSTRG##	;OUTPUT IT
>
	POP	P,T1		;RESTORE T1
	PUSHJ	P,.TSTRG##	;OUTPUT STRING
	PJRST	.TSPAC##		;OUTPUT SPACE AND RETURN
	SUBTTL	STORAGE

STDSWC:			;POINTERS TO STANDARD (LOCAL) SWITCH TABLES
	STSWTN(P1)
	STSWTP(P1)
	STSWTM(P1)
	STSWTD(P1)

	;OFFSETS FOR TABLES
SWN==0		;NAME TABLE
SWP==1		;POINTERS TABLE
SWM==2		;MAX,,PROCESSOR TABLE
SWD==3		;DEFAULT TABLE

	XLIST		;LITERALS
	LIT
	LIST
	RELOC		;SWITCH TO LOW SEG
.SCANZ::!		;START OF SCAN LOW SEG

;THESE LOCATIONS ARE USED TO FETCH AND STORE PARAMETERS

SWTPTR:	BLOCK	1		;POINTER TO NAMES OF SWITCHES
SWTCHC:!		;POINTERS TO USER'S SWITCH TABLES
SWTCHN:	BLOCK	1		;TABLE OF SWITCH NAMES
SWTCHP:	BLOCK	1		;TABLE OF POINTERS FOR STORING
SWTCHM:	BLOCK	1		;TABLE OF MAX,,PROCESSOR
SWTCHD:	BLOCK	1		;TABLE OF DEFAULTS
SWTPFF:	BLOCK	1		;FIRST LOCATION OF USER FXXX
SWTPFL:	BLOCK	1		;LAST LOCATION OF USER FXXX
SWTPFO:	BLOCK	1		;OFFSET PXXX-FXXX

SWTHLP:	BLOCK	1		;ADDR OF HELP PROCESSOR

CLRANS:	BLOCK	1		;ROUTINE TO CLEAR ANSWERS
CLRSTK:	BLOCK	1		;ROUTINE TO CLEAR STICKY DEFAULTS
CLRFIL:	BLOCK	1		;ROUTINE TO CLEAR FILE
ALLIN:	BLOCK	1		;ROUTINE TO ALLOCATE INPUT FILE
ALLOUT:	BLOCK	1		;ROUTINE TO ALLOCATE OUTPUT FILE
MEMSTK:	BLOCK	1		;ROUTINE TO MEMORIZE STICKY DEFAULTS
APPSTK:	BLOCK	1		;ROUTINE TO APPLY STICKY DEFAULTS
USRFLG:	BLOCK	1		;USER SUPPLIED FLAGS
  U.MOUT==1B18		;MULTIPLE OUTPUT SPECS. ARE POSSIBLE
STRSWT:	BLOCK	1		;USER ROUTINE FOR SWITCH HANDLING


SAVCOR:	BLOCK	1		;INITIAL VALUE OF LOW SEG CORE SIZE
IFN INDEPT,<
CCLNAM:	BLOCK	1		;NAME OF CCL INDIRECT FILE
USRIND:	BLOCK	1		;USER POINTER TO IND SPEC
OURPPN:	BLOCK	1		;OUR PROJECT-PROGRAMMER NUMBER
OPTNAM:	BLOCK	1		;CODE NAME IN SWITCH.INI
VOPTN:	BLOCK	1		;OPTNAM FOR VERB MODE
>
TYPIN:	BLOCK	1		;ROUTINE TO INPUT ONE CHARACTER
MONRT:	BLOCK	1		;ROUTINE TO RETURN TO MONITOR


ZCOR:!			;START OF AREA TO ZERO ON INITIAL LOAD

SAVCHR:	BLOCK	1		;SAVED CHARACTER IN .TICHR FOR SPACE/HYPHEN
CALCNT:	BLOCK	1		;CALL COUNTER FOR .TSCAN
LASCHR:	BLOCK	1		;LAST CHARACTER READ
SCANPC:	BLOCK	1		;PC IN CHARACTER SCAN (0=START OF LINE)
SCANCH:	BLOCK	1		;CHARACTER IN SCAN
IFN INDEPT,<
N.ZER:!			;BLOCK FOR /RUN COMMAND
N.DEV:	BLOCK	1		;DEVICE
N.NAM:	BLOCK	2		;NAME
N.EXT:	BLOCK	1		;EXTENSION
N.MOD:	BLOCK	2		;MODIFIERS
N.DIR:	BLOCK	2*.FXLND	;DIRECTORY
N.EZER==.-1
RUNOFF:	BLOCK	1		;OFFSET

A.ZER:!			;BLOCK FOR INDIRECT COMMAND
A.DEV:	BLOCK	1		;DEVICE
A.NAM:	BLOCK	1		;NAME
A.NAMM:	BLOCK	1		;NAME MASK
A.EXT:	BLOCK	1		;EXTENSION AND MASK
A.MOD:	BLOCK	1		;MODIFIERS
A.MODM:	BLOCK	1		;MODIFIER MASK
A.DIR:	BLOCK	1		;DIRECTORY
A.DIRM:	BLOCK	2*.FXLND-1	;DIRECTORY MASK
A.EZER==.-1
A.BUF:	BLOCK	LN.ABF+3	;BUFFER TO READ INDIRECT FILE
A.BUFE==.

B.ZER:!			;START OF INDIRECT AREA
B.IND:	BLOCK	3		;BUFFER HEADERS FOR INDIRECT FILE
				;    ALSO FLAGS:
				;	+0 IS 0 IF TMPCOR, NOT 0 IF FILE
				;	+1 IS NON ZERO IF FILE OPEN
B.INDC:	BLOCK	1		;COUNT OF BYTES IN BUFFER
FLIIND:	BLOCK	1		;FLAG FOR INTERACTIVE INDIRECT
INDUSI:	BLOCK	1		;USETI FOR INDIRECT FILE
B.EZER==.-1
>
IFG INDEPT,<
INDCNT:	BLOCK	1		;COUNT OF @ SINCE TTY: INPUT
>
P.ZER:!			;START OF AREA FOR FILE DEFAULTS
P.DEV:	BLOCK	1		;LAST STICKY DEVICE TYPED BY USER
P.EXT:	BLOCK	1		;LAST STICKY EXT,,MASK TYPED BY USER
P.MOD:	BLOCK	1		;LAST STICKY FILE SWITCHES TYPED BY USER
P.MODM:	BLOCK	1		;LAST STICKY FILE SWITCHES MASK TYPED BY USER
P.DIR:	BLOCK	1		;LAST STICKY DIRECTORY TYPED BY USER
P.DIRM:	BLOCK	2*.FXLND-1	;LAST STICKY DIRECTORY MASK TYPED BY USER
P.BFR:	BLOCK	1		;LAST STICKY /BEFORE
P.SNC:	BLOCK	1		;LAST STICKY /SINCE
P.EZER==.-1

FLFSP:	BLOCK	1		;FLAG SOMETHING FOUND
F.ZER:!			;START OF AREA FOR FILE TYPE-INS
F.DEV:	BLOCK	1		;DEVICE (ALWAYS NON-ZERO IF ANYTHING TYPED)
F.NAM::	BLOCK	1		;NAME (NON-ZERO IF NAME TYPED)
F.NAMM:	BLOCK	1		;NAME MASK
F.EXT:	BLOCK	1		;EXT,,MASK (NON-ZERO IF DOT TYPED)
F.MOD:	BLOCK	1		;FILE SWITCHES
F.MODM:	BLOCK	1		;FILE SWITCH MASK (ON IF TYPED)
F.DIR:	BLOCK	1		;DIRECTORY (DIR!DIRM ZERO IF DEFAULT DIRECTORY)
F.DIRM:	BLOCK	2*.FXLND-1	;DIRECTORY MASK
F.BFR:	BLOCK	1		;/BEFORE
F.SNC:	BLOCK	1		;/SINCE
F.EZER==.-1
SWTCNT:	BLOCK	1		;RECURSION COUNTER FOR FILIN
G.ZER:	BLOCK	F.EZER-F.ZER+1	;PUSH DOWN FOR FILE SWITCHES
G.EZER==.-1

FXNOTI==FX.PRO		;ILLEGAL ON INPUT FILE
FXNOTO==FX.NOM!FX.STR	;ILLEGAL ON OUTPUT FILE

IFN INDEPT,<
OPTION:	BLOCK	1	;NAME OF /OPTION
>
SAVPDP:	BLOCK	1		;SAVE PUSH DOWN POINTER IN CASE FATAL ERROR
SAVCAL:	BLOCK	1		;SAVE LOCATION OF CALL
.NMUL::	BLOCK	^D30		;MULTIPLE WORD RESULT
.NMUE==:.-1
VAL1==.NMUL		;TEMP IN DATE/TIME ROUTINES
VAL2==.NMUL+1
VAL3==.NMUL+2
VAL4==.NMUL+3
VAL5==.NMUL+4
VAL6==.NMUL+5
VAL7==.NMUL+6
VAL8==.NMUL+7
VAL9==.NMUL+8

MASK:	BLOCK	1		;MASK AFTER WORD ACCUMULATION
NOW:	BLOCK	1		;HOLDS CURRENT DATE/TIME
NULFLG:	BLOCK	1		;-1 IF FIELD NOT NULL

FLCCL:	BLOCK	1		;CCL MODE (-1 AFTER @ SEEN, 1 BEFORE)
FLCCMD:	BLOCK	1		;CCL OR COMMAND MODE
FLSOL:	BLOCK	1		;SEEN SOMETHING ON THIS LINE
FLVERB:	BLOCK	1		;FLAG FOR MODE OF SCANNING (LT 0 VERB,=0 P, GT 0 TRAD)
FLNEG:	BLOCK	1		;FLAG FOR NEGATIVE NUMBER
FLNLGI:	BLOCK	1		;FLAG FOR NOT LOGGED IN (+1 IF DON'T KNOW)
FLOUT:	BLOCK	1		;FLAG FOR = SEEN
FLDOT:	BLOCK	1		;FLAG FOR . SEEN
FLFUTR:	BLOCK	1		;FUTURE/PAST RELATIVE
FLFUTD:	BLOCK	1		;FUTURE/PAST DEFAULT
				;BOTH: -1 PAST, 0 ABS, +1 FUT

EZCOR==.-1		;END OF AREA TO ZERO
.SCANL==:.-.SCANZ	;LENGTH OF SCAN LOW SEG

	PRGEND
	TITLE	.TOUTS -- SUBROUTINES FOR OUTPUT
	SUBTTL	P.CONKLIN/DJB/PFC/DMN		11-OCT-72

	SEARCH	SCNDCL		;GET SCAN DECLARATIONS
	SCNDCL			;INITIALIZE LISTING, ETC.

;ENTRY POINTS

	ENTRY	.TYOCH
;.TYOCH -- INITIALIZE TYPEOUT ROUTINE
;CALL:	MOVEI	T1,ADDR. OF ROUTINE
;	PUSHJ	P,.TYOCH
;RETURNS PREVIOUS ADDR. IN T1

.TYOCH::EXCH	T1,TYPOUT	;SWAP ADDR.
	POPJ	P,


;.TFBLK -- TYPE SCANER STYLE FILE BLOCK
;CALL:	MOVEI	T1,ADDR OF BLOCK
;	PUSHJ	P,.TFBLK
;USES T1-4

.TFBLK::MOVE	T4,T1		;SAVE AWAY ARGUMENT
	SKIPN	T1,.FXDEV(T4)
	JRST	TFBLK1
	PUSHJ	P,.TSIXN	;TYPE DEVICE
	PUSHJ	P,.TCOLN	;TYPE COLON
TFBLK1:	MOVE	T1,.FXNAM(T4)
	PUSHJ	P,.TSIXN	;TYPE NAME
	HLLZ	T3,.FXEXT(T4)	;GET EXTENSION
	MOVX	T2,FX.NUL	;SEE IF USER
	TDNE	T2,.FXMOM(T4)	;  ..
	TDNE	T2,.FXMOD(T4)	;  TYPED A DOT
	JUMPE	T3,TFBLK2	;YES--IS THIS A NULL EXTENSION
	MOVEI	T1,"."		;GET DOT
	PUSHJ	P,.TCHAR	;TYPE IT
	MOVE	T1,T3		;GET EXTENSION
	PUSHJ	P,.TSIXN
TFBLK2:	MOVEI	T1,.FXDIR(T4)	;POSITION TO DIRECTORY
	TLO	T1,2		;FLAG FOR BIWORDS
				;FALL INTO .TDIRB
;.TDIRB -- TYPE A DIRECTORY BLOCK
;CALL:	MOVEI	T1,ADDRESS OF DIRECTORY WORD OR PATH OR BIWORDS
;	TLO	T1,0 FOR WORD, 1 FOR PATH, 2 FOR BIWORDS
;	PUSHJ	P,.TDIRB
;USES T1-4

.TDIRB::
IFE FTSFD,<
	SKIPE	T1,(T1)		;SEE IF SOMETHING
	PJRST	.TPPNW		;YES--PRINT IT
	POPJ	P,
>
IFN FTSFD,<
	MOVE	T4,T1		;SAVE POINTER
	SKIPN	T1,(T4)		;SEE IF SOMETHING THERE
	JRST	[HLRZ T2,T4	;NO--SEE IF BIWORDS
		 CAIN T2,2	; ..
		 SKIPN 2(T4)	;YES--SEE IF SOMETHING LATER ON
		 POPJ	P,	;NO--RETURN
		 JRST TDIRB1]	;PROCEED WITH OUTPUT
	TLNE	T4,-1		;SEE IF STRAIGHT
	JRST	TDIRB1		;NOPE--DO IT THE HARD WAY
	TLNE	T1,-1		;YES--SEE IF SFD
	PJRST	.TPPNW		;NO--JUST UFD
	MOVEI	T4,2(T1)	;YES--CHANGE POINTER

TDIRB1:	HLRZ	T1,T4		;GET LENGTH
	SUBI	T1,2		;SET FLAG -1 FOR SINGLE, 0 FOR BIWORDS
	PUSH	P,T1		;SAVE FOR LATER TESTING
	HRLI	T4,-.FXLND+1	;SET LENGTH
	MOVEI	T1,"["		;OUTPUT BREAK
	PUSHJ	P,.TCHAR	; ..
	MOVE	T1,(T4)		;GET UFD
	JUMPL	T1,[PUSHJ P,.TSIXN
		    JRST  TDIRB2]
	PUSHJ	P,.TXWDW	;TYPE IT
TDIRB2:	AOBJP	T4,TDIRB3	;LOOP UNTIL DONE
	SKIPL	(P)		;IF BIWORDS,
	AOS	T4		;  MOVE UP ONE EXTRA
	SKIPL	(P)		;CHECK ONE OR TWO WORDS TO
	SKIPN	1(T4)		;  SEE IF DONE YET
	SKIPE	(T4)		; ..
	JRST	.+2		;NO
	JRST	TDIRB3		;YES--RETURN TYPING LAST BREAK
	PUSHJ	P,.TCOMA	;TYPE A COMMA
	MOVE	T1,(T4)		;GET SFD NAME
	PUSHJ	P,.TSIXN	;TYPE IT
	JRST	TDIRB2		; AND LOOP UNTIL DONE
TDIRB3:	POP	P,(P)		;THROW AWAY FLAG
	JRST	TPPNW1		;AND FINISH UP
>
;.TDATN -- TYPE TODAY'S DATE IN STANDARD FORMAT
;.TDATE -- TYPE DATE IN STANDARD FORMAT OF DD-MMM-YY
;CALL:	MOVEI	T1,DATE IN SYSTEM FORMAT FROM DATE UUO
;	PUSHJ	P,.TDATE/.TDATN
;USES T1-4

.TDATN::DATE	T1,		;GET TODAY'S DATE

.TDATE::PUSHJ	P,.SAVE1##	;SAVE P1
	IDIVI	T1,^D31		;GET DAYS
	MOVE	T4,T1		;SAVE REST
	MOVEI	T1,1(T2)	;GET DAYS AS 1-31
	MOVEI	T2," "		;FILL WITH SPACE
	PUSHJ	P,.TDEC2	;TYPE IN DECIMAL
	IDIVI	T4,^D12		;GET MONTHS
	MOVEI	T1,[ASCIZ /-Jan/
		    ASCIZ /-Feb/
		    ASCIZ /-Mar/
		    ASCIZ /-Apr/
		    ASCIZ /-May/
		    ASCIZ /-Jun/
		    ASCIZ /-Jul/
		    ASCIZ /-Aug/
		    ASCIZ /-Sep/
		    ASCIZ /-Oct/
		    ASCIZ /-Nov/
		    ASCIZ /-Dec/](P1)	;GET ASCII
	PUSHJ	P,.TSTRG	;TYPE IT
	MOVEI	T1,^D64(T4)	;GET YEAR SINCE 1900
	MOVNS	T1		;NEGATE TO GET - SIGN
	PJRST	.TDECW		;TYPE IT AND RETURN
;.TTIMN -- TYPE CURRENT TIME IN STANDARD FORMAT
;.TTIME -- TYPE TIME IN STANDARD FORMAT OF HH:MM:SS
;CALL:	MOVEI	T1,TIME IS MILLISEC SINCE MIDNIGHT
;	PUSHJ	P,.TTIME/.TTIMN
;USES T1-4

.TTIMN::MSTIME	T1,		;GET CURRENT TIME

.TTIME::IDIV	T1,[^D3600000]	;GET HOURS
	MOVE	T4,T2		;SAVE REST
	MOVEI	T2," "		;FILL WITH SPACE
	PUSHJ	P,.TDEC2	;TYPE TWO DIGITS
	PUSHJ	P,.TCOLN	;TYPE COLON
	MOVE	T1,T4		;RESTORE REST
	IDIVI	T1,^D60000	;GET MINS
	MOVE	T4,T2		;SAVE REST
	PUSHJ	P,TDEC2Z	;TYPE TWO DIGITS WITH 0 FILLER
	PUSHJ	P,.TCOLN	;TYPE COLON
	MOVE	T1,T4		;RESTORE THE REST
	IDIVI	T1,^D1000	;GET SECONDS
TDEC2Z:	MOVEI	T2,"0"		;FILL WITH 0
				;FALL INTO .TDEC2

;.TDEC2 -- TYPE DECIMAL AT LEAST TWO DIGITS
;CALL:	SAME AS .TDECW WITH T2=FILLER CHAR (" " OR "0")

.TDEC2::JUMPL	T1,.TDECW	;JUMP IF NEGATIVE
	CAILE	T1,^D9		;SEE IF ONE DIGIT
	PJRST	.TDECW		;NO--JUST OUTPUT
	EXCH	T1,T2		;GET FILLER
	PUSHJ	P,.TCHAR	;TYPE
	MOVEI	T1,"0"(T2)	;CONVERT DIGIT
	PJRST	.TCHAR		;OUTPUT IT AND RETURN
;.TFCHR -- TYPE POSSIBLY FUNNY CHARACTER
;CALL:	MOVEI	T1,CHARACTER
;	PUSHJ	P,.TFCHR
;USES T1, T2

.TFCHR::CAIL	T1,40		;SEE IF CONTROL CHARACTER
	JRST	TFCHR5		;NO--PROCEED
	MOVSI	T2,-LNSPCH	;SET SCAN LOOP
TFCHR2:	HLL	T1,SPCH(T2)	;MAKE T1 AGREE
	CAME	T1,SPCH(T2)	;SEE IF MATCH
	AOBJN	T2,TFCHR2	;NO--LOOP
	JUMPGE	T2,TFCHR3	;NO MATCH--PROCEED
	MOVEI	T1,"<"		;MATCH--TYPE INDICATOR
	PUSHJ	P,.TCHAR	; ..
	HLLZ	T1,SPCH(T2)	;GET MNEMONIC
	PUSHJ	P,.TSIXN	;TYPE IT
	MOVEI	T1,">"		;CLOSE
	PUSHJ	P,.TCHAR	;  INDICATOR
	POPJ	P,		;AND RETURN

TFCHR3:	ADDI	T1,100		;CONVERT
	PUSH	P,T1		; AND SAVE CHAR
	MOVEI	T1,"^"		;SET INDICATOR
	JRST	TFCHR6		;AND GO FINISH UP

TFCHR5:	CAIGE	T1,140		;SEE IF LOWER CASE
	PJRST	.TCHAR		;NO--JUST TYPE IT
	SUBI	T1,40		;YES--CONVERT TO UPPER
	PUSH	P,T1		;SAVE FOR A MINUTE
	MOVEI	T1,"'"		;SET INDICATOR
TFCHR6:	PUSHJ	P,.TCHAR	;ISSUE INDICATOR
	POP	P,T1		;RESTORE FIXED CHAR
	PJRST	.TCHAR		;AND TYPE IT

;TABLE OF MNEMONIC,,CHARACTER

SPCH:	'EOF',,.CHEOF
	'EOL',,.CHEOL
	'ALT',,.CHALX
	'BEL',,.CHBEL
	'TAB',,.CHTAB
	'LF ',,.CHLFD
	'VT ',,.CHVTB
	'FF ',,.CHFFD
	'CR ',,.CHCRT
	'ESC',,.CHESC
LNSPCH==.-SPCH
;.TCRLF -- TYPE CARRIAGE RETURN/LINE FEED
;CALL:	PUSHJ	P,.TCRLF
;PRESERVES ALL ACS

.TCRLF::PUSH	P,T1		;SAVE CHARACTER
	MOVEI	T1,.CHCRT	;GET CARRIAGE RETURN
	PUSHJ	P,.TCHAR
	MOVEI	T1,.CHLFD	;GET LINE FEED
	PUSHJ	P,.TCHAR	;TYPE IT
	POP	P,T1		;RESTORE CHARACTER
	POPJ	P,		;RETURN


;.TPPNW -- SUBROUTINE TO TYPE A PPN
;CALL:	MOVE	T1,PPN
;	PUSHJ	P,.TPPNW
;USES	T1, T2, T3

.TPPNW::PUSH	P,T1		;SAVE ARGUMENT
	MOVEI	T1,"["
	PUSHJ	P,.TCHAR
	POP	P,T1		;RECOVER ARGUMENT
	JUMPL	T1,[PUSHJ P,.TSIXN
		    JRST  TPPNW1]
	PUSHJ	P,.TXWDW	;TYPE XWD
TPPNW1:	MOVEI	T1,"]"
	PJRST	.TCHAR


;.TSIXN -- TYPE OUT SIXBIT WORD
;CALL:	MOVE	T1,WORD
;	PUSHJ	P,.TSIXN
;USES T1, T2

.TSIXN::MOVE	T2,T1		;MOVE ARGUMENT
TSIXN1:	JUMPE	T2,.POPJ	;LOOP UNTIL ONLY BLANKS LEFT
	MOVEI	T1,0		;CLEAR NEXT CHARACTER
	LSHC	T1,6		;GET NEXT CHARACTER
	ADDI	T1," "-' '	;CONVERT TO ASCII
	PUSHJ	P,.TCHAR	;TYPE IT
	JRST	TSIXN1		; ..
;.TXWDW -- TYPE OUT N AS TWO OCTAL HALF-WORDS
;CALL:	MOVE	T1,WORD
;	PUSHJ	P,.TXWDW
;USES T1, T2, T3

.TXWDW::PUSH	P,T1		;PRESERVE ARGUMENT
	HLRZ	T1,T1
	PUSHJ	P,.TOCTW
	PUSHJ	P,.TCOMA	;ISSUE COMMA
	POP	P,T1		;RESTORE ARGUMENT
	HRRZ	T1,T1
			;FALL INTO .TOCTW


;.TDECW -- TYPE OUT SIGNED DECIMAL NUMBER
;.TOCTW -- TYPE OUT SIGNED OCTAL NUMBER
;.TRDXW -- TYPE OUT SIGNED NUMBER (RADIX IN T3)
;	(IF RADIX .GT. 9, WILL USE ALPHAS AFTER DIGITS)
;CALL:	MOVE	T1,NUMBER
;	PUSHJ	P,.TOCTW/.TDECW/.TRDXW
;USES T1, T2, T3

.TOCTW::SKIPA	T3,[10]		;INITIALIZE FOR OCTAL RADIX
.TDECW::MOVEI	T3,^D10		;INITIALIZE FOR DECIMAL RADIX

.TRDXW::JUMPGE	T1,TRDXW1	;CHECK FOR NEGATIVE
	MOVE	T2,T1		;SAVE AWAY ARGUMENT
	MOVEI	T1,"-"		;YES--GET MINUS
	PUSHJ	P,.TCHAR	;PRINT IT
	MOVE	T1,T2		;RESTORE NUMBER
TRDXW1:	IDIV	T1,T3		;DIVIDE BY RADIX
	MOVMS	T2		;GET MAGNITUDE
	HRLM	T2,(P)		;SAVE REMAINDER
	SKIPE	T1		;SEE IF ANYTHING LEFT
	PUSHJ	P,TRDXW1	;YES--LOOP BACK WITH PD LIST
	HLRZ	T1,(P)		;GET BACK A DIGIT
	ADDI	T1,"0"		;CONVERT TO ASCII
	CAILE	T1,"9"		;SEE IF OVERFLOW DIGITS
	ADDI	T1,"A"-"9"	;YES--SWITCH TO ALPHABETICS
	PJRST	.TCHAR		;TYPE IT AND RETURN
;.TSTRG -- TYPE ASCIZ STRING
;CALL:	MOVEI	T1,LOCTN. OF STRING
;	PUSHJ	P,.TSTRG
;USES T1

.TSTRG::HRLI	T1,(POINT 7)	;CONVERT ADDRESS TO POINTER
	MOVEM	T1,TEMSTR	;STORE IN TEMP LOCATION
TSTRG1:	ILDB	T1,TEMSTR	;GET NEXT CHARACTER
	JUMPE	T1,.POPJ	;RETURN WHEN DONE
	PUSHJ	P,.TCHAR	;OUTPUT CHARACTER
	JRST	TSTRG1		;LOOP UNTIL DONE


;.TCHAR -- TYPE ASCII CHARACTER
;CALL:	MOVEI	T1,CHARACTER
;	PUSHJ	P,.TCHAR
;PRESERVES ALL ACS

;.TSPAC -- TYPE ASCII SPACE
;.TTABC -- TYPE ASCII TAB
;.TCOMA -- TYPE ASCII COMMA
;.TCOLN -- TYPE ASCII COLON
;CALL:	PUSHJ	P,.TXXXX
;USES T1

.TCOLN::MOVEI	T1,":"		;GET COLON
	PJRST	.TCHAR		;ISSUE AND RETURN
.TCOMA::MOVEI	T1,","		;GET COMMA
	PJRST	.TCHAR		;ISSUE AND RETURN
.TTABC::MOVEI	T1,.CHTAB	;GET TAB
	PJRST	.TCHAR		;ISSUE AND RETURN

.TSPAC::MOVEI	T1," "		;GET SPACE
.TCHAR::SKIPE	TYPOUT		;SEE IF SPECIAL ROUTINE
	PJRST	@TYPOUT		;YES--GO DO IT INSTEAD
	OUTCHR	T1		;LET MONITOR DO IT
.POPJ:	POPJ	P,		;AND RETURN


;DATA STORAGE AREA

	RELOC
.TOUTZ::!			;START OF LOW CORE AREA
TYPOUT: BLOCK	1		;ROUTINE TO TYPE ONE CHARACTER
TEMSTR:	BLOCK	1		;TEMPORARY USED IN STRING OUTPUT
.TOUTL==:.-.TOUTZ		;LENGTH OF LOW CORE AREA
	RELOC
	PRGEND
	TITLE	.CNTDT -- GENERALIZED DATE/TIME SUBROUTINE

	SEARCH	SCNDCL		;GET SCAN DECLARATIONS
	SCNDCL			;INTIALIZE LISTINGS, ETC.

;ENTRY POINTS

	ENTRY	.CNTDT,.CNVDT,.GTNOW
;.CNTDT -- SUBROUTINE TO CONVERT FROM INTERNAL DATE/TIME FORMAT
;CALL:	MOVE	T1,DATE/TIME
;	PUSHJ	P,.CNTDT
;	RETURN WITH T1=TIME IN MS., T2=DATE IN SYSTEM FORMAT (.LT. 0 IF ARG .LT. 0)
;USES T1-4

.CNTDT::PUSH	P,T1		;SAVE TIME FOR LATER
	JUMPL	T1,CNTDT6	;DEFEND AGAINST JUNK INPUT
	HLRZ	T1,T1		;GET DATE PORTION (DAYS SINCE 1858)

	RADIX	10		;**** NOTE WELL ****
	ADDI	T1,365*400+24*4-<2001-1859>*365-<2001-1859>/4-31-30+17	;MAKE INTO DAYS SINCE JAN 1, 1601

	IDIVI	T1,365*400+24*4+1  ;SEPARATE UNITS OF 400
	LSH	T1,2		;MULT ANSWER BY 4
	IDIVI	T2,365*100+24	;SEPARATE CENTURIES
	CAIN	T2,4		;SEE IF LAST ONE
	SOSA	T2		;YES--BACK OFF
	JRST	.+2		;CONTINUE SKIP
	MOVEI	T3,365*100+24	;SET TO FULL (LEAP) CENTURY
	ADD	T1,T2		;INCLUDE CENTURIES IN RESULT
	IMULI	T1,25		;MULT ANSWER BY 25
	IDIVI	T3,365*4+1	;SEPARATE UNITS OF 4
	ADD	T1,T3		;INCLUDE IN ANSWER
	LSH	T1,2		;MULT ANSWER BY 4
	MOVE	T3,T4		;PROMOTE AC
	IDIVI	T3,365		;SEPARATE YEARS
	CAIN	T3,4		;SEE IF END OF LEAP YEAR
	SOSA	T3		;YES--BACK OFF YEAR
	JRST	.+2		;CONTINUE SKIP
	MOVEI	T4,365		;SET FOR END OF YEAR
	ADDI	T1,1601(T3)	;GET REAL YEAR
				;T1 HAS YEAR, T4 HAS DAY IN YEAR

	MOVE	T2,T1		;COPY YEAR TO SEE IF LEAP YEAR
	IDIVI	T2,400		;SEE IF MULT OF 400
	JUMPE	T3,CNTDT1	;YES--PROCEED
	MOVE	T2,T1		;GET NEW COPY
	IDIVI	T2,100		;SEE IF MULT OF 100
	JUMPE	T3,[MOVEI T3,1	;YES--FLAG AS NO L.Y.
		    JRST  CNTDT1] ;AND PROCEED
	MOVE	T2,T1		;GET NEW COPY
	IDIVI	T2,4		;SEE IF MULT OF 4
				;T3 IS 0 IF LEAP YEAR
	;UNDER RADIX 10 **** NOTE WELL ****

CNTDT1:	SUBI	T1,1964		;SET TO SYSTEM ORIGIN
	IMULI	T1,31*12	;CHANGE TO SYSTEM PSEUDO DAYS
	JUMPN	T3,CNTDT2	;IF NOT LEAP YEAR, PROCEED
	CAIGE	T4,31+29	;LEAP YEAR--SEE IF BEYOND FEB 29
	JRST	CNTDT5		;NO--JUST INCLUDE IN ANSWER
	SOS	T4		;YES--BACK OFF ONE DAY
CNTDT2:	MOVSI	T2,-11		;LOOP FOR 11 MONTHS

CNTDT3:	CAMGE	T4,MONTAB+1(T2)	;SEE IF BEYOND THIS MONTH
	JRST	CNTDT4		;YES--GO FINISH UP
	ADDI	T1,31		;NO--COUNT SYSTEM MONTH
	AOBJN	T2,CNTDT3	;LOOP THROUGH NOVEMBER

CNTDT4:	SUB	T4,MONTAB(T2)	;GET DAYS IN THIS MONTH
CNTDT5:	ADD	T1,T4		;INCLUDE IN FINAL RESULT

CNTDT6:	EXCH	T1,(P)		;SAVE ANSWER, GET TIME
	TLZ	T1,-1		;CLEAR DATE
	MUL	T1,[24*60*60*1000]	;CONVERT TO MILLI-SEC.
	ASHC	T1,17		;POSITION RESULT
	POP	P,T2		;RECOVER DATE
	POPJ	P,		;RETURN

;.GTNOW -- COMPUTE CURRENT TIME IN SPECIAL FORMAT
;CALL:	PUSHJ	P,.GTNOW
;RETURNS WITH RESULT IN T1
;USES T2, T3, T4

.GTNOW::MSTIME	T1,		;GET SYSTEM TIME IN MILLISECONDS
	DATE	T2,		;GET SYSTEM DATE IN COMMON FORMAT
				;FALL INTO .CNVDT
	;UNDER RADIX 10 **** NOTE WELL ****

				;FALL HERE FROM .GTNOW

;.CNVDT -- CONVERT ARBITRARY DATE TO SPECIAL FORMAT
;CALL:	MOVE	T1,TIME IN MILLISEC.
;	MOVE	T2,DATE IN SYSTEM FORMAT (Y*12+M)*31+DAY  SINCE 1/1/64
;	PUSHJ	P,.CNVDT
;RETURNS WITH RESULT IN T1 (.GT.0; OR -1 IF BEYOND SEPT. 27,2217)
;	NOTE THAT IN SPECIAL FORMAT, THE LEFT HALF DIVIDED
;	  BY 7 GIVES THE DAY OF THE WEEK (0=WED.)
;USES T2, T3, T4

.CNVDT::PUSHJ	P,.SAVE1##	;PRESERVE P1
	PUSH	P,T1		;SAVE TIME FOR LATER
	IDIVI	T2,12*31	;T2=YEARS-1964
	CAILE	T2,2217-1964	;SEE IF BEYOND 2217
	JRST	GETNW2		;YES--RETURN -1
	IDIVI	T3,31		;T3=MONTHS-JAN, T4=DAYS-1
	ADD	T4,MONTAB(T3)	;T4=DAYS-JAN 1
	MOVEI	P1,0		;LEAP YEAR ADDITIVE IF JAN, FEB
	CAIL	T3,2		;CHECK MONTH
	MOVEI	P1,1		;ADDITIVE IF MAR-DEC
	MOVE	T1,T2		;SAVE YEARS FOR REUSE
	ADDI	T2,3		;OFFSET SINCE LEAP YEAR DOES NOT GET COUNTED
	IDIVI	T2,4		;HANDLE REGULAR LEAP YEARS
	CAIE	T3,3		;SEE IF THIS IS LEAP YEAR
	MOVEI	P1,0		;NO--WIPE OUT ADDITIVE
	ADDI	T4,<1964-1859>*365+<1964-1859>/4+<31-18>+31(T2)
				;T4=DAYS BEFORE JAN 1,1964 +SINCE JAN 1
				; +ALLOWANCE FOR ALL LEAP YEARS SINCE 64
	MOVE	T2,T1		;RESTORE YEARS SINCE 1964
	IMULI	T2,365		;DAYS SINCE 1964
	ADD	T4,T2		;T4=DAYS EXCEPT FOR 100 YR. FUDGE
	HRREI	T2,64-100-1(T1)	;T2=YEARS SINCE 2001
	JUMPLE	T2,GETNW1	;ALL DONE IF NOT YET 2001
	IDIVI	T2,100		;GET CENTURIES SINCE 2001
	SUB	T4,T2		;ALLOW FOR LOST LEAP YEARS
	CAIE	T3,99		;SEE IF THIS IS A LOST L.Y.
GETNW1:	ADD	T4,P1		;ALLOW FOR LEAP YEAR THIS YEAR
	CAILE	T4,^O377777	;SEE IF TOO BIG
GETNW2:	SETOM	T4		;YES--SET -1

	POP	P,T1		;GET MILLISEC TIME
	MOVEI	T2,0		;CLEAR OTHER HALF
	ASHC	T1,-17		;POSITION
	DIV	T1,[24*60*60*1000]  ;CONVERT TO 1/2**18 DAYS
	HRL	T1,T4		;INCLUDE DATE
	POPJ	P,		;RETURN
	;UNDER RADIX 10 **** NOTE WELL ****

MONTAB:	EXP	0,31,59,90,120,151,181,212,243,273,304,334,365
	RADIX	8
	PRGEND
	TITLE	.SAVE -- SUBROUTINES TO SAVE AND RESTORE P1-P4

	SEARCH	SCNDCL		;GET SCAN DECLARATIONS
	SCNDCL			;INITIALIZE LISTING, ETC.

;ENTRY POINTS

ENTRY	.SAVE1,.SAVE2,.SAVE3,.SAVE4
;.SAVE1 -- SUBROUTINE TO SAVE P1 FOR A SUBROUTINE
;CALL:	PUSHJ	P,.SAVE1
;RETURN	POPJ OR .POPJ1, RESTORES P1 AND EXITS AS SKIP OR NON-SKIP

.SAVE1::EXCH	P1,(P)		;SAVE P1, GET CALLER PC
	MOVEM	P1,1(P)		;SAVE CALLER ONE DOWN
	MOVE	P1,(P)		;RESTORE P1
	PUSHJ	P,@1(P)		;CALL SUBROUTINE
	  JRST	RET1		;NON-SKIP RETURN
	AOS	-1(P)		;SKIP RETURN
	JRST	RET1		;RESTORE P1 AND EXIT

;.SAVE2 -- SUBROUTINE TO SAVE P1 AND P2 FOR A SUBROUTINE
;CALL:	PUSHJ	P,.SAVE2
;RETURN	POPJ OR .POPJ1, RESTORES P1 AND P2 AND EXITS AS SKIP OR NON-SKIP

.SAVE2::EXCH	P1,(P)		;SAVE P1, GET CALLER PC
	PUSH	P,P2		;SAVE P2
	MOVEM	P1,1(P)		;SAVE CALLER ONE DOWN
	MOVE	P1,-1(P)	;RESTORE P1
	PUSHJ	P,@1(P)		;CALL SUBROUTINE
	  JRST	RET2		;NON-SKIP RETURN
	AOS	-2(P)		;SKIP RETURN
	JRST	RET2		;RESTORE P1 AND P2 AND EXIT

;.SAVE3 -- SUBROUTINE TO SAVE P1 AND P2 AND P3 FOR A SUBROUTINE
;CALL:	PUSHJ	P,.SAVE3
;RETURN POPJ OR .POPJ1, RESTORES P1-3 AND SKIPS OR NOT

.SAVE3::EXCH	P1,(P)		;SAVE P1, GET CALLER PC
	PUSH	P,P2		;SAVE P2
	PUSH	P,P3		;SAVE P3
	MOVEM	P1,1(P)		;SAVE CALLER ONE DOWN
	MOVE	P1,-2(P)	;RESTORE P1
	PUSHJ	P,@1(P)		;CALL SUBROUTINE
	  JRST	RET3		;NON-SKIP RETURN
	AOS	-3(P)		;SKIP RETURN
	JRST	RET3		;RESTORE P1-3 AND EXIT
;.SAVE4 -- SUBROUTINE TO SAVE P1-4 FOR A SUBROUTINE
;CALL:	PUSHJ	P,.SAVE4
;RETURN POPJ OR .POPJ1, RESTORES P1-4 AND SKIPS OR NOT

.SAVE4::EXCH	P1,(P)		;SAVE P1, GET CALLER PC
	PUSH	P,P2		;SAVE P2
	PUSH	P,P3		;SAVE P3
	PUSH	P,P4		;SAVE P4
	MOVEM	P1,1(P)		;SAVE CALLER ONE DOWN
	MOVE	P1,-3(P)	;RESTORE P1
	PUSHJ	P,@1(P)		;CALL SUBROUTINE
.SAVX4::  JRST	RET4		;NON-SKIP RETURN
	AOS	-4(P)		;SKIP RETURN

RET4:	POP	P,P4		;RESTORE P4
RET3:	POP	P,P3		;RESTORE P3
RET2:	POP	P,P2		;RESTORE P2
RET1:	POP	P,P1		;RESTORE P1
	POPJ	P,		;RETURN

	END
    ~ 