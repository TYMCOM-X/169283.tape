BASE 0

!PROCEDURES
GLOBAL %LISACT
FIND %INITTTY,%HASH,%GETNUM,%GETOCT,%GETTOKEN,%LISTABLE
FIND %CHR.OUT,%OCTWD.OUT,%OCTOUT,%NUMOUT,%SIXOUT,%MAKE.SIXBIT
FIND %CHOOSE,%DATOUT,%GETDUM
LOCAL %LOOK.NAME,%CHK.IO.ERR,%CHK.ACT.ERR
LOCAL %OPEN.LUD
LOCAL %LUD.LOOK,%INITNONAME,%LIST.RECORD,%ADRESS.OUT,%LUD.OVERFLOW

DEF SIZE.BLK AS 128

!ID'S
FIND TOKEN(0)
GLOBAL USER(20),CUST(150),PPN,IER,ICODE,MODE
GLOBAL NUMBER,NAME.HASH,LOC.HASH,P,GETCMD:,CH.OUT
GLOBAL LISTFLG
LOCAL CH.LUD,CMD,LIST
LOCAL L.INDEX,L.BLK(SIZE.BLK),TEMP,NAME(2)



!COMMANDS
DEF CMD.LIST AS 1
DEF CMD.ENDIT AS 2
DEF CMD.HELP AS 3


!FLAGS IN LISTFLG
DEF USER.LST AS 1
DEF CUST.LST AS 2

! SIZE OF TABLES
DEF N.CMDS AS 3	!NUMBER OF PRIMARY COMMANDS
DEF N.LISTS AS 3 !NUMBER OF LIST COMMANDS

!TABLES
GLOBAL TABLE CMDS(1:N.CMDS)['LIST','QUIT','HELP']
GLOBAL TABLE LISTS(1:N.LISTS)['USER','PPN','CUSTOMER']

!MACRO'S
DEF ACTSIT(A) AS BYT(USER(5),1,(BITS.PER.WORD-1)-A)
DEF COLON AS CHR.OUT($:)
DEF CALL.GETACT(A,B) AS [ICODE_A; MODE_B; GETDUM]
DEF CHECK.NO.MORE.IN(A) AS [IF NCHV P=EOLIT THEN A; PCHV P]
DEF CR AS CHR.OUT(CARRET)
DEF ENTER.NAME AS '$ENTER USER NAME: '
DEF FIXCP(A) AS (A-1)*SIZE.BLK	!COMPUTE CURSOR POS. FROM BLK. NO.
DEF LUD.READ AS [RB(CH.LUD,SIZE.BLK,L.BLK); L.INDEX_0]
DEF LUD(A) AS L.BLK(L.INDEX+A)
DEF GETNAME AS [CHECK.NO.MORE.IN(MSG(ENTER.NAME));GETTOKEN(2);MAKE.SIXBIT(TOKEN,NAME,12)]
DEF GETCUST AS [CHECK.NO.MORE.IN(MSG('$ENTER CUSTOMER NO: ')); GETNUM]
DEF NAME.MATCH AS NAME(0)=USER(8) AND NAME(1)=USER(9)
DEF NOT.VALID AS [MSG('$NOT A VALID USER.$');CLOSE.ALL;GO GETCMD]
DEF NO.ACT AS [MSG('NO ACCOUNTING RECORD FOR '); SIXOUT(@NAME(0),12)]
DEF NO.CUST AS [MSG('NO ACCOUNTING RECORD FOR '); NUMOUT(CUST(0));GO GETCMD]
DEF OV.BLK AS HW(@LUD(0),1)
DEF SIZE.LUD.ENT AS BYT(LUD(2),7,0)
DEF SP AS CHR.OUT(SPACE)
DEF SPACE AS $ 
DEF VERSION AS 1
DEF WHAT AS [MSG('?$'); GO GETCMD]


!LABELS
LOCAL LUD.ERR:,CHK.ERR:
%LISACT
	!MAINLINE
START: IOCS(2); INITNONAME
\\->START
GETCMD: LISTFLG _ 0
	 CH.OUT _ OPEN('TEL',SEQUEN+OUTPUT+CHARACTER,CHK.ERR,2)
	CR; PUT($:); P _ GETLINE(TEL); GETTOKEN(0)
	IF CMD _ CHOOSE(N.CMDS,CMDS) = 0 THEN WHAT
	OPEN.LUD

DO CMD OF 1:N.CMDS

CMD.LIST: CHECK.NO.MORE.IN([LISTABLE(N.LISTS,LISTS); COLON])
    GETTOKEN(0)
    WHILE LIST _ CHOOSE(N.LISTS,LISTS) = 0 THEN[CR;LISTABLE(N.LISTS,LISTS); COLON;&
	GETTOKEN(0)]

	DO LIST OF 1:N.LISTS

	1:    LISTFLG _ USER.LST; GETNAME
	   IF LUD.LOOK(NAME) = 0 THEN LOOK.NAME
	USER(0) _ LUD(0)
	A1: CALL.GETACT(1,-1); CHK.ACT.ERR
	    CALL.GETACT(3,-1); IF IER =1 THEN NO.ACT
	    CHK.ACT.ERR;LIST.RECORD

	2: LISTFLG _ USER.LST
	MSG('ACCOUNT: '); GETOCT; HW(@TEMP,0) _ NUMBER
	MSG('USER NO.: '); GETOCT; HW(@TEMP,1) _ NUMBER
	USER(0) _ TEMP
	GO A1
	3: LISTFLG _ CUST.LST; GETCUST
	CUST(0) _ NUMBER
	CALL.GETACT(1,1); CHK.ACT.ERR
	CALL.GETACT(3,1); IF IER = 1 THEN NO.CUST
	LIST.RECORD

	END

CMD.ENDIT: CLOSE.ALL; MSG('$E.O.J.$'); EXIT

CMD.HELP: MSG('LEGAL COMMANDS ARE:$')
   LISTABLE(N.CMDS,CMDS); MSG('.$')


END
  GO GETCMD





%LUD.LOOK(ADR)
	!LOOK UP NAME IN ADR,ADR+1 IN LUD
HASH(^ADR,^(ADR+1))
SETCP(CH.LUD,FIXCP(LOC.HASH)); LUD.READ 
WHILE NAME.HASH # LUD(4) THEN DO	
	L.INDEX+_SIZE.LUD.ENT
	IF LUD(0)=0 THEN RETURN 0
	IF LUD(0)<0 THEN LUD.OVERFLOW
	END
RETURN 1
END LUD.LOOK


%LOOK.NAME
	!SEARCH FOR NAME IN ACCTG.
CALL.GETACT(1,-1); CHK.ACT.ERR
LOOP DO
	CALL.GETACT(4,-1)
	IF NAME.MATCH THEN [LIST.RECORD; GO GETCMD]
	IF IER = 2 THEN NOT.VALID
	CHK.ACT.ERR
END
END LOOK.NAME


%CHK.ACT.ERR
	!CHECK ACCTG. ERROR
IF IER = 0 THEN RETURN
MSG('ERROR ON '); IF MODE < 0 THEN MSG('USERNA.MES') ELSE MSG('CUSTOM.ERS')
CR

DO IER OF 1:4
1: MSG('ENTRY NOT FOUND.')
2: MSG('END OF FILE FOUND.')
3: MSG('ERROR ON FILE.')
4: MSG('MISC. ERROR.')
END
EXIT
END CHK.ACT.ERR



%CHK.IO.ERR
	!TAKE CARE OF ALL I/O ERRORS FROM IOCS...
CHK.ERR: MSG('ERROR ON ');WFID(FIDP);MSG('...');CR
  DO ERRNUM OF TMFERR:CORERR
FNDERR: MSG('BAD FILE MODE OR TYPE')
IFDERR: MSG('ILLEGAL FILE IDENTIFIER')
FNFERR: MSG('FILE NOT FOUND')
IUSERR: MSG('INVALID USER NAME')
PRTERR: MSG('PROTECTION FAILURE')
EOFERR: MSG('END OF FILE')
 END
MSG('.$ERROR ');NUMOUT(ERRNUM);EXIT
END CHK.IO.ERR


%LUD.OVERFLOW
	!READ LUD OVERFLOW BLOCK
SETCP(CH.LUD,OV.BLK*SIZE.BLK)
LUD.READ
RETURN
END LUD.OVERFLOW




%INITNONAME
	!INIT PROGRAM
INITTTY(GETCMD)
CMD _ 0
HW(@PPN,0) _ 1; HW(@PPN,1) _ OCT 42313
MSG('$LIST ACCOUNTING - VERSION '); NUMOUT(VERSION);MSG('$$$')
MOVE 72/CHARS.PER.WORD FROM ALL 0 TO TOKEN
 RETURN
END INITNONAME



%LIST.RECORD(LISTNUM)
DO LISTFLG OF 1:2

1: MSG('$USER NAME: '); SIXOUT(@USER(8),12)
    MSG('$PPN: '); OCTWD.OUT(USER(0))
    MSG('$PRICING CODE: '); OCTOUT(USER(1))
    MSG('$TRACKING CODE: '); NUMOUT(USER(2))
    MSG('$DISTRICT: '); NUMOUT(USER(3)/100)
    MSG('$SALESMAN: '); NUMOUT(USER(3)-(USER(3)/100)*100)
    MSG('$CUSTOMER: '); NUMOUT(USER(4))
	FOR TEMP _ 31 TO 35 DO
		IF ACTSIT(TEMP) = 1 THEN [MSG('$SITE: '); NUMOUT(TEMP)]
	END
	IF BYT(USER(7),1,1)=1 THEN MSG('$TYMSHARE')
	IF BYT(USER(7),1,0)=1 THEN MSG('$ACCOUNT SUPERVISOR')
2: SIXOUT(@CUST(9),30)
	MSG('$BILLING DISTRICT: '); NUMOUT(CUST(1))
	MSG('$TAX: '); NUMOUT(CUST(2))
	MSG('$BILLING REGION: '); NUMOUT(CUST(78))
	IF CUST(75)=1 THEN MSG('$MINIMUM CUSTOMER.')
	IF CUST(77)=1 THEN MSG('$NON-TIMESHARING CUSTOMER.')
	IF CUST(79)#-1 THEN [MSG('$NEXT MONTHS BILLING DISTRICT: ');&
				NUMOUT(CUST(79))]
	IF CUST(80)#-1 THEN [MSG('$NEXT MONTHS BILLING REGION: ');&
				NUMOUT(CUST(80))]
	MSG('$P.O.: '); SIXOUT(@CUST(3),30)
	ADRESS.OUT(0)
	REPEAT 30 SP
	NUMOUT(CUST(76))
	IF CUST(45)#0 THEN ADRESS.OUT(30)
END
CR; RETURN
END LIST.RECORD




%ADRESS.OUT(INDEX)
	!OUTPUT ADDRESS IN 5[LINES OF 30 CHARS
CR; TEMP _ 0
REPEAT 5 DO
	IF BYT(CUST(15+TEMP+INDEX),6,30)=0 THEN RETURN
	SIXOUT(@CUST(15+TEMP+INDEX),30); TEMP+_5; CR
END
RETURN
END ADRESS.OUT


%OPEN.LUD
	!LOOK FOR LUD.SYS ON DSK
	CH.LUD_OPEN('(SYS)LUD.SYS',DIRECT+INPUT+WORD,LUD.ERR)
	RETURN
LUD.ERR:CHK.IO.ERR
END OPEN.LUD





END LISACT
