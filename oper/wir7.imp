WIR7.IMP
        WIRE WRAP IMPLEMENTATION SPECIFICATION--SECTION 7
                FUNCTIONAL UNIT FOR START-UP

        THIS IS THE INITIAL FUNCTIONAL UNIT INVOKED, AND CONCERNS
ITSELF WITH JOB START OPERATIONS.  THESE INCLUDE INITIALIZATION,
TELLING THE USER THAT THE PROGRAM IS THERE, AND RECOGNIZING INITIAL
CONTROL COMMANDS.

        CALLS ROUTINES: FUSED
                        CPPROM
                        FETCHL
                        LPARSE

        THE PROCESS:

        1       TYPE... ' * * * W I R R A P * * *';
                  TYPE... 'date AND time';
                  TYPE... ' START SESSION:' ;
                  INITIALIZE TEMP FILE NAMES WITH USER NUMBER;
                  SET uncola = .FALSE.:
                  PROMPT;  CALL FETCHL;  RETURN:





        7.2     LOGICAL FUNCTION DBREAD ( file )

        THIS ROUTINE IS USED TO INPUT A DATABASE:  THE FILE IS FOUND,
OPENED, AND THE PREAMBLE READ AND VERIFIED.  THE TITLE IS OUTPUT AND
VERIFIED BY THE USER.  THE FILE IS CLOSED AND REOPENED WITH THE
APPROPRIATE RECORD SIZE.  SUCCESSIVE TABLES ARE COPIED TO THE
APPROPRIATE FILES.  IT IS FINALLY CLOSED, ALL FILES ARE CLOSED AND
SET UP CORRECTLY.  A RETURN IS MADE:  IF ANY ERRORS OCCUR, RETURN
.FALSE.; ELSE RETURN .TRUE.

        THE ROUTINE MAKES USE OF THE DATABASE PREAMBLE, THE FORM OF
WHICH IS REPRODUCED HERE:

WORD    VARIABLE        USAGE
----------------------------------------------------------
1-16    TITLE           BOARD DESCRIPTION (TEXTC, 16A5 FORMAT)
17-18   MODIFY          MODIFICATION LEVEL (TEXTC, A10 FORMAT)
19      MODFLG          MODIFICATION FLAG...SET WHEN WIRING
                           DOCUMENT HAS BEEN GENERATED; CLEARED
                           WHEN NEW .MODIFY. HAS BEEN ENTERED

20      SIGNO           CURRENTLY DEFINED SIGNAL NUMBER
21-22   SIGFORM         CURRENTLY DEFINED SIGNAL FORMAT (A10 FORMAT)

23      DB:SIZE         SIZE OF DATABASE BLOCK (WORDS)

24      X:BLOCK         START BLOCK OF X-CHANNEL TABLE
25      X:NUMBER        NUMBER OF BLOCKS IN X-CHANNEL TABLE
26      X:SIZE          SIZE OF EACH ENTRY IN X-CHANNEL TABLE
27      X:ENTRY         NUMBER OF ENTRIES IN X-CHANNEL TABLE

28      Y:BLOCK         START BLOCK OF Y-CHANNEL TABLE
29      Y:NUMBER        NUMBER OF BLOCKS IN Y-CHANNEL TABLE
30      Y:SIZE          SIZE OF EACH ENTRY IN Y-CHANNEL TABLE
31      Y:ENTRY         NUMBER OF ENTRIES IN Y-CHANNEL TABLE

32      SOC:BLOCK       START BLOCK OF SOCKET TABLE
33      SOC:NUMBER      NUMBER OF BLOCKS IN SOCKET TABLE
34      SOC:SIZE        SIZE OF EACH ENTRY IN SOCKET TABLE
35      SOC:ENTRY       NUMBER OF ENTRIES IN SOCKET TABLE

36      PIN:BLOCK       START BLOCK OF PIN TABLE
37      PIN:NUMBER      NUMBER OF BLOCKS IN PIN TABLE
38      PIN:SIZE        SIZE OF EACH ENTRY IN PIN TABLE
39      PIN:ENTRY       NUMBER OF ENTRIES (PINS) IN PIN TABLE

40      SIG:BLOCK       START BLOCK OF SIGNAL TABLE
41      SIG:NUMBER      NUMBER OF BLOCKS IN SIGNAL TABLE
42      SIG:SIZE        SIZE OF EACH ENTRY IN SIGNAL TABLE
43      SIG:ENTRY       NUMBER OF ENTRIES IN SIGNAL TABLE

44      LIB:BLOCK       START BLOCK OF PLUG LIBRARY TABLE
45      LIB:NUMBER      NUMBER OF BLOCKS IN PLUG LIBRARY TABLE
46      LIB:SIZE        SIZE OF EACH ENTRY IN PLUG LIBRARY TABLE
47      LIB:ENTRY       NUMBER OF ENTRIES IN PLUG LIBRARY TABLE

48      PID:BLOCK       START BLOCK OF PLUG-ID TABLE
49      PID:NUMBER      NUMBER OF BLOCKS IN PLUG-ID TABLE
50      PID:SIZE        SIZE OF EACH ENTRY IN PLUG-ID TABLE
51      PID:ENTRY       NUMBER OF ENTRIES IN PLUG-ID TABLE

52      PLG:BLOCK       START BLOCK OF PLUG-PIN TABLE
53      PLG:NUMBER      NUMBER OF BLOCKS IN PLUG-PIN TABLE
54      PLG:SIZE        SIZE OF EACH ENTRY IN PLUG-PIN TABLE
55      PLG:ENTRY       NUMBER OF ENTRIES IN PLUG-PIN TABLE

56      END:BLOCK       FIRST FREE BLOCK IN DATABASE
----------------------------------------------------------

        CALLS ROUTINES: DYNARY

        THE PROCESS:

        1       CHECK OUT file--IF SUCCESS, GO TO 2; ELSE BITCH AND
                RETURN .FALSE.

        2       COPY /CPGLOB/IDFILE<5> INTO /DTABASE/FILENAME;
                OPEN file;  READ PREAMBLE INTO inline;  CLOSE file;
                !VERIFY!  X:BLOCK + X:NUMBER = Y:BLOCK;
                Y:BLOCK + Y:NUMBER = SOC:BLOCK;
                SOC:BLOCK + SOC:NUMBER = PIN:BLOCK;
                PIN:BLOCK + PIN:NUMBER = SIG:BLOCK;
                SIG:BLOCK + SIG:NUMBER = LIB:BLOCK;
                LIB:BLOCK + LIB:NUMBER = PID:BLOCK;
                PID:BLOCK + PID:NUMBER = PLG:BLOCK;
                PLG:BLOCK + PLG:NUMBER = END:BLOCK;
                IF ALL SUCCEED, GO TO 3;  ELSE TYPE 'DATABASE WRONG FORM';
                RETURN .FALSE.:

        3       TYPE .TITLE.;  IF .MODIFY., TYPE 'MOD', .MODIFY.;
                TYPE 'VERIFY THAT THIS IS CORRECT DATABASE, TYPE Y/N';
                SET FILE TO DB:SIZE:

        4       GET INPUT;  IF 'N', RETURN .FALSE.;  IF 'Y' OR
                CARRIAGE RETURN; GO TO 5;  ELSE TYPE 'EH?';  GO TO 4:

        5       OPEN file;  READ PARAMETERS;  CALL DYNARY(SPACE);
                CALL DYNARY(IERR, DBBUFIN, SPACE, 0, *:BLOCK, *:NUMBER,
                        *:FILE, *:SIZE, *:ENTRY), FOR EACH OF * = 
                        [X, Y, SOC, PIN, LIB, PID, AND PLG] AND USING
                        CORRESPONDING F:FILE:

        6       CALL DYNARY(IERR, DBSIGIN, SPACE, 0, SIG:BLOCK,
                        SIG:NUMBER, SIG:SIZE, SIG:ENTRY):

        7       CLOSE file;  RETURN .TRUE.:




        7.3     SUBROUTINE DBBUFIN ( buffer, bufsiz, block, nblock, file,
                                ensize, nentry)

        THIS ROUTINE BUFFERS nblock BLOCKS OF SIZE /DTABASE/SIZE
STARTING AT BLOCK NUMBER block;  file IS OPENED WITH RECORD SIZE THE SAME,
AND DATA IS COPIED AS REQUIRED.  WHEN DONE, file IS CLOSED, AND THE 
PARAMETERS ensize AND nentry ARE PLACED IN THE FILE DEFINITION.

        THE PROCESS:

        1       IF nblock .EQ. 0, GO TO 4;
                COMPUTE MBLOCK = bufsiz/(/DTABASE/SIZE);
                NWORDS = nblock*(/DTABASE/SIZE);
                MSIZE = MBLOCK*(/DTABASE/SIZE);
                LBLOCK = MIN(nblock, MBLOCK);
                LSIZE = LBLOCK*(/DTABAS/SIZE);
                SET file:SIZE = /DTABASE/SIZE;
                POSITION DATABASE TO block;  OPEN file:

        2       READ LSIZE WORDS INTO buffer;
                WRITE LSIZE WORDS ONTO file;
                COMPUTE NWORDS = NWORDS - LSIZE;
                IF NWORDS .EQ. 0, GO TO 3;
                COMPUTE LSIZE = MIN(LSIZE, NWORDS);
                GO TO 2:

        3       CLOSE file:

        4       SET file:SIZE = ensize;  file:NUMBER = nentry;
                RETURN:



        7.4     SUBROUTINE DBSIGIN ( buffer, bufsiz, block, nblock,
                                ensize, nentry )

        THIS ROUTINE BUFFERS THE SIGNALS INTO MEMORY, AND HASHES THEM INTO
THE SIGNAL TABLE.

        CALLS ROUTINES: SIGFIND

        THE PROCESS:

        1       COMPUTE MBLOCK = bufsiz/(DTABASE/SIZE);
                LBLOCK = MIN(MBLOCK, nblock);  NWORD = ENSIZE*NENTRY;
                MWORD = LBLOCK*(/DTABASE/SIZE);
                SET FSIGNAL:SIZE = ensize;  MIN = 1;  END = 0:

        2       COMPUTE MAX = END+NWORD;  READ BUFFER(MIN:MAX);

        3       COPY ID<2>, FLAG, rbn;  I = SIGFIND(ID);
                /HASHCON/.NEXT. = FLAG;  /HASHCON/.NEXTPIN. = rbn;
                CALL SIGOUT:

        4       NWORD = NWORD - ensize;
