TITLE PIP V.016
SUBTTL REVISED 7 APRIL 1969 V.CONSENTINO,REVISED 9/20/69  D.R.PRIVITERA
	LOC 137
	OCT	16
	RELOC

;PERIPHERAL INTERCHANGE PROGRAM
;"COPYRIGHT 1969, DIGITAL EQUIPMENT CORP.,MAYNARD,MASS.

;THIS FILE HAS 5 CONDITIONAL ASSEMBLY SWITCHES (WCH,DISK30,BLOC0,RIMSW,CCLSW)
;AND 1 CONDITIONAL PARAMETER (SYSPP).

;FOLLOWING IS A DESCRIPTION OF THE USE OF EACH SWITCH AND THE PARAMETER:
;-----------------------------------------------------------------------

;WCH=0  PIP IS ASSEMBLED FOR PDP-10 AND ASSUMES NEW FORMAT DECTAPES.

;WCH=1  PIP IS ASSEMBLED FOR PDP-6 AND ASSUMES OLD FORMAT DECTAPES.


;DISK30=0 PIP IS ASSEMBLED TO RUN WITH 10/40, 10/50 MONITOR SYSTEMS.

;DISK30=1 PIP IS ASSEMBLED TO RUN WITH 10/30 DISK SYSTEM.


;BLOC0=0 PIP ALLOWS COPYING OF BLOCK0 (DECTAPE).

;BLOC0=1 PIP WILL NOT ALLOW BLOCK0 TO BE COPIED.


;RIMSW=0 /Y SWITCH OPTION UNAVAILABLE. (ALSO UNAVAILABLE FOR OLD FORMAT DECTAPES)

;RIMSW=1 /Y SWITCH OPTION AVAILABLE.


;CCLSW=0 PIP WILL NOT PROCESS CCL COMMANDS.(ALSO TRUE FOR 10/30 DISK SYSTEM)

;CCLSW=1 PIP WILL EXECUTE CCL COMMANDS FROM DISK.


;SYSPP:XWD PROJECT,PROGRAMMER - IF DEFINED AS SHOWN, PIP USES IT AS THE SYSTEM P,P#.
;				IF UNDEFINED PIP WILL USE 1,1 AS THE SYSTEM P,P#.


;CONDITIONAL ASSEMBLY SWITCH SETUP (NORMAL CONFIGURATION)
;---------------------------------
    IFNDEF WCH,    <WCH=0>
    IFNDEF DISK30, <DISK30=0>
    IFNDEF BLOC0,  <BLOC0=0>
    IFNDEF RIMSW,  <RIMSW=0>
    IFNDEF CCLSW,  <CCLSW=1>
    IFN DISK30,    <CCLSW=0>
    IFN WCH,       <RIMSW=0>
;EXTERNAL JOB DATA SYMBOLS USED BY THIS PROGRAM

EXTERNAL JOBFF,JOBSA,JOBREL,JOBREN

;FLAG ASSIGNMENTS (RIGHT HALF)

LINE=1		;ASCII LINE MODE PROCESSING
BMOD=2		;BINARY PROCESSING
TBMOD=4		;SUPPRESS TRAILING SP, CHANGE MULTIPLE SP TO TABS
DFLG=10		;DELETE FILES MODE, ERROR IN SMALL PIP
LFLG=20		;LIST DIRECTORY
NSMOD=40	;IGNORE INPUT SEQUENCE NUMBERS
RFLG=100	;RENAME FILE MODE, ERROR IN SMALL PIP
SQMOD=200	;GENERATE SEQUENCE NUMBERS
STS=400		;END OF LINE SEEN, OUTPUT SEQUENCE NUMBER NEXT
SPMOD=1000	;SUPPRESS TRAILING SPACES, ERROR IN SMALL PIP
XFLG=2000	;COPY DECTAPE MODE, ERROR IN SMALL PIP
ZFLG=4000	;CLEAR DECTAPE DIRECTORY
SUS=10000	;SEQUENCE NUMBER GENERATION IN PROGRESS
SPOK=20000	;SPACE WAS LAST CHARACTER
ESQ=40000	;STOP OUTPUTTING SEQ NUM, RESUME OUTPUTTING DATA
SNI=100000	;DO NOT INCREMENT SEQUENCE NUMBER
MTFLG=200000	;MTA REQUEST RECEIVED
OSFLG=400000	;GENERATE SEQ. NOS. INCR. BY ONE

;FLAG ASSIGNMENTS (LEFT HALF)

OFLG=1		;BLOCK 0 COPY
RIMFLG=2	;RIM FORMAT INPUT (OUT TO DTA)
PFLG=4		;FORTRAN PROGRAM OUTPUT FORMAT CONVERSION
PCONV=10	;COLUMN 1 CONVERSION IN PROGRESS
NEWFIL=20	;NEW FILE JUST INITIATED
CHKFLG=40	;PARENTHESES CHECK MODE
IFLG=100	;SELECT IMAGE MODE
GFLG=200	;KEEP GOING IF THERE ARE I/O ERRORS
IBFLG=400	;SELECT IMAGE BINARY MODE
REDFLG=1000	;=1 IF ANY FILES ARE INPUT (OTHER THAN DIRECTORIES)
;
;
;	;AUXFLG ASSIGNMENTS (SPECIAL CATALOG BITS) (LEFT HALF)
;
DTFLG=400000	;=1 CATALOG DATES ONLY
TIFLG=200000	;=1    "    TIME
SIFLG=100000	;=1    "    SIZE
PRFLG=40000	;=1    "    PROTECTIONS
;AUXFLG ASSIGNMENTS (LEFT HALF)

QFLG=1		;PLEASE PRINT SWITCH SET
NSPROT=2	;NON-STANDARD DISK OUTPUT PROTECTION
SBIN=4		;36-BIT PR. ON REL. ETC. FILES
NOMORE=20	;IGNORE ANY SWITCHES BUT MTA FROM NOW ON
CDRFLG=40	;CONVERT COLS 73-80 TO SPACES + /C
RSDCFL=200	;USED FOR MERGING FILES, =1 IF FILE HAS EXTENSION
		;REL,SAV,DMP,CHN OR OTHERWISE = 0
FRSTIN=400	;THIS IS THE FIRST INPUT FILE (USED IN FILE
		;MERGE COMMAND) = 0 FOR FIRST INPUT

;MTAREQ ASSIGNMENTS (RIGHT HALF)

MTAFLG=1	;MTA ADVANCE ONE FILE
MTBFLG=2	;MTA BACKSPACE ONE FILE
MTTFLG=4	;MTA SKIP TP LOGICAL EOT
MTWFLG=10	;MTA REWIND
MTFFLG=20	;MTA MARK EOF
MTUFLG=40	;MTA REWIND AND UNLOAD
MTDFLG=100	;MTA ADVANCE ONE RECORD
MTPFLG=200	;MTA BACKSPACE ONE RECORD
MT8FLG=400	;MTA SET 800 B.P.I.
MT5FLG=1000	;MTA SET 556 B.P.I.
MT2FLG=2000	;MTA SET 200 B.P.I.
MTEFLG=4000	;MTA SELECT EVEN PARITY

;AUXFLG ASSIGNMENTS (RIGHT HALF)

LPTOUT=10	;LPT OUTPUT
FFLG=20		;LIST SHORT DISK DIRECTORY
ONEOUT=40	;ONE OUTPUT FILE INITIALIZED
CDRIN=100	;CARDS IN
MTAOUT=200	;OUTPUT TO MTA
MTAIN=400	;INPUT FROM MTA
TTYIN=1000	;INPUT FROM TTY
READ1=2000	;LOOK FOUND NEW INPUT FILE, NO READ YET.
DTAOUT=4000	;OUTPUT TO DTA
DSKOUT=10000	;OUTPUT TO DSK
DTAIN=20000	;INPUT FROM DTA
DSKIN=40000	;INPUT FROM DSK
TTYOUT=100000	;OUTPUT TO TTY
PPTIN=200000	;INPUT FROM PTR
PPTOUT=400000	;OUTPUT TO PTP
;CALFLG ASSIGNMENTS (RHS) FOR DESCRIBING A BLOCK OF INFORMATION
;FOUND BY THE COMMAND SCANNER.

FNEX=1		;=1 WHEN FN.EX=*.*, *.EXT, FN.* (WHEN MORE
		;THAN ONE FN.EX IS IMPLIED).
MATEX=2		;FILE EXTENSIONS MUST MATCH
MATFN=4		;FILE NAMES MUST MATCH
NEWDEV=10	;A NEW INPUT DEVICE WAS GIVEN
NEWPP=20	;A NEW #P-P WAS GIVEN

;DEVICE CHANNEL ASSIGNMENTS

COM=0		;STORED COMMAND INPUT CHANNEL
CON=1		;COMMAND INPUT CHANNEL
OUT=2		;OUTPUT DEVICE
IN=3		;INPUT DEVICE
TAPE=4		;MTA POSITIONING
DIR=5		;DISK DIR. READ
BLKIN=6		;INPUT FOR 10/30 DISK FILES

;ACCUMULATOR ASSIGNMENTS

T1=1		;GENERAL PURPOSE
T2=2		;G.P.
T3=3		;G.P.
CHR=4		;INPUT CHARACTER
P=5		;PUSHDOWN POINTER
FLAG=6		;FLAG REGISTER
T4=7		;G.P.
IOS=10		;IO STATUS BITS
T5=11		;G.P.
T6=12		; G.P.
AUXFLG=13	;AUXILIARY FLAG REGISTER
T7=14		;G.P.
DOUT=15		;DIVIDED NO. FOR OUTPUT
DOUT1=16	;REMAINDER, DOUT+1
;ASCII CHARACTERS

S2=32		;END OF FILE CHARACTER

;MISCELLANEOUS PARAMETERS

DTABIT=4	;DEVCHR BIT FOR DECTAPE IDENTIFICATION
INHIB=1		;OUTPUT RELEASE INHIBIT BIT
TABSP=10	;SPACES PER TAB
PTRBIT=200	;DEVCHR BIT FOR PTR
PTPBIT=400	;DEVCHR BIT FOR PTP
DSKBIT=200000	;DEVCHR BIT FOR DSK
MTABIT=20	;DEVCHR BIT FOR MTA
LPTBIT=40000	;DEVCHR BIT FOR LPT
TTYBIT=10	;DEVCHR BIT FOR TTY
CDRBIT=100000	;DEVCHR FOR CDR
DENS2=200	;MTA 200 BPI
DENS5=400	;MTA 556 BPI
DENS8=600	;MTA 800 BPI
PARE=1000	;MTA EVEN PARITY
LDP=4000	;MTA LOAD POINT STATUS
HPAGE=20

;LSTLIN MACRO DEFINITION

DEFINE	LSTLIN (Z),<
	SKIPA   T1,[POINT 7,Z]
	PUSHJ   P,PUT
	ILDB    CHR,T1
	JUMPN   CHR,.-2>
PIP1:
IFN CCLSW,<
	TDZA	FLAG,FLAG	;NORMAL ENTRY TO ACCEPT COMMANDS FROM TTY
	SETO	FLAG,		;CCL ENTRY TO READ COMMANDS FROM DISK FILE
	SETZM	COMFLG		;CLEAR PERMANENT STATUS IN CASE OF ERROR>
	MOVEI	T1,DSKDR	;ASSUME NO DISK FOR TEST
	MOVE	0,[SIXBIT /DSK/]
	CALLI	0,4		;DEVCHR REQUEST: IS THERE A DSK 
	JUMPE	0,P1		;0 IF NO DISK: USE DSKDR
	MOVE	T1,JOBFF	;DISK: PREPARE TO SAVE C(JOBFF)
	HRRZ	T2,JOBREL
	CAIL	T2,6000		;CURRENT SIZE 4K
	JRST	P1		;YES
	MOVEI	T2,7777		;NO. EXPAND TO 4K
	CALLI	T2,11		;CORE UUO
	JRST	DERR7		;CORE UNAVAILABLE
P1:	HRRZM	T1,SVJBFF	;SAVE JOBFF SO BUFFERS CAN BE CREATED
IFE CCLSW,<
	JRST	PIP>
IFN CCLSW,<
	JUMPE	FLAG,PIP	;ENTER PIP IF NO COMMAND FILE
	CALLI	0		;RESET
	INIT	COM,0		;INIT DSK FOR COMMAND INPUT
	SIXBIT	/DSK/
	XWD	0,CFI
	JRST	CER1		;CAN'T INIT
	CALLI	T1,30		;GET JOB NBR.
	MOVEI	0,3
	IDIVI	T1,^D10
	ADDI	T2,"0"-40
	LSHC	T2,-6
	SOJG	0,.-3
	HLLM	T3,CFILE	;INSERT JOB NBR IN CCL INIT
	HLLM	T3,CER1+2	;INSERT IN ERROR MESSAGE ALSO
	LOOKUP	COM,CFILE	;LOOKUP COMMAND FILE
	JRST	CER2		;NOT FOUND
	INBUF	COM,1		;1 BUFFER ONLY
	MOVE	0,JOBFF		;SAVE JOBFF NOW
	HRRZM	0,SVJBFF	;TO LEAVE COMMANDS INTACT WHEN BUFFERS RECREATED
	SETOM	COMFLG		;SUCCESS: COMMAND FILE REQUESTED
	JRST	PIP2
CER1:	JSP	T1,PTEXT
	SIXBIT	/?FILE@###PIP.TMP@INIT@FAILURE!/
CER2:	MOVEI	T6,CFILE	;POINT TO FILE NAME
	JRST	DERR4		;USE DISK ERROR PRINTER>
DERR7:	JSP	T1,PTEXT
	SIXBIT	/?4K@NEEDED!/
PIP:	CALLI 0		;REINITIALIZE WHEN RESTARTED MANUALLY
IFN CCLSW,<
	SETZM	COMFLG	;ALLOW START COMMAND IN CCL
	>
PIP2:	JSP T5,INICN1	;INITIALIZE THE TTY
;	******************************************PATCHED OUT*****
;	MOVEI 0,15	;PRINT CAR.RET., LINE FEED
;	IDPB 0,TFO+1
;	MOVEI 0,12
;	IDPB 0,TFO+1
	SETZM TOTBRK	;CLEAR PAREN COUNTER
	MOVEI 0,TABSP
	MOVEM 0,TABCT	;INITIALIZE TAB COUNT
	MOVE 0,ZRO
	MOVEM 0,SQNUM	;INITIALIZE SEQUENCE NUMBERS
	RELEAS CON,	;RELEASE TTY FOR USE AS IN-OUT DEVICE

MAINA1:	SETZB FLAG,FILNAM   ;INITIALIZE FOR FIRST/NEXT COMMAND STRING
	SETZB AUXFLG,DEVICE
	HRRZI 0,(SIXBIT /SYS/)
	HRLZM 0,ADSK
	MOVE 0,[XWD FILNAM,FILNAM+1]
	BLT 0,AB
	PUSHJ P,NAME	;GO SCAN DESTINATION PORTION OF COMMAND STRING
	SKIPE XNAME	;NO SCAN OVERSHOOT ALLOWED
	JRST ERR6A
	SKIPN T5,NSWTCH	;NON-NULL DESTINATION NAME?
	SKIPN SSWTCH	;YES, LEFT ARROW SEEN?
	JRST ERR6	;NO, SO THIS IS A BAD COMMAND
	MOVE 0,DEVICE
	MOVEM 0,ODEV	;SAVE DEVICE NAME FOR LATER USAGE
	PUSHJ P,DEVTST	;SAVE DEVICE TYPE
	PUSHJ P,ABCHK
	PUSHJ P,PROTK	;CHECK PROTECTION
	MOVE 0,AB
	MOVEM 0,ABOUT	;GET MTA CONTROL NUMBERS FO R OUT
	MOVE 0,AUX
	MOVEM 0,AUXOUT
	MOVE 0,[XWD FILNAM,DTON]
	BLT 0,DTON+1	;SAVE DESTINATION FILE NAME
	SETZM DTON+3    ;ZERO 4TH WD OF DIRECTORY ENTRY
	TRNN AUXFLG,DSKOUT	;DISK OUTPUT?
	JRST M3		;NO
	MOVE 0,[XWD PR,DTON+2]	;YES, SAVE PR, P-P NO.
	BLT 0,DTON+3

M3:	SETZM SSWTCH	;TERMINATE DESTINATION FILE SCAN
	SETZM DEVICE	;MUST NOT LET O/DEV. CARRY OVER AS I/DEV.
	PUSHJ P,DESCRP	;GET A UNIT DESCRIPTOR (INPUT).
	TLNN AUXFLG,QFLG;/Q?
	JRST M2
	HRRZI 0,(SIXBIT /SYS/)
	HRLZM 0,DEVICE
	HRLZM DEVA
	MOVE 0,QPIP
	MOVEM 0,FILNAM
	SETZM FILEX
	MOVE 0,[XWD 1,1]
	MOVEM 0,PP
	SOS ESWTCH	;NO MORE COMMAND STRING
	TRZ AUXFLG,DTAIN+DSKIN+CDRIN+PPTIN+TTYIN+MTAIN
	PUSHJ P,CHECK1

M2:	TLO AUXFLG,NOMORE	;NO MORE SWITCHES BUT MTA ALLOWED
	TLNE FLAG,OFLG	;BLOCK 0 COPY?
	JRST BLOCK0	;YES
	TRNN FLAG,XFLG	;(RX) ILLEGAL REQUEST
	JRST .+3
	TRNE FLAG,RFLG
	JRST ERR6A
	TLNN FLAG,RIMFLG
	JRST M1
IFN WCH,<
	JRST RIMTB>
IFE WCH,<
	TRNN AUXFLG,PPTOUT
	JRST ERR5B
	TRNN AUXFLG,DTAIN
	JRST ERR5B>

M1:	MOVEI T4,1	;ASCII LINE MODE ASSUMED
	PUSHJ P,OUTLOK
	PUSHJ P,M4
	HRRM T4,OMOD
	MOVEI T4,1
	PUSHJ P,INLOOK
	PUSHJ P,M4
	HRRM T4,ININI1
	PUSHJ P,FNSET	;NOW DEVICE, DEVA CORRECT FOR START
	JRST OMOD1

M4:	TLNN FLAG,IFLG
	JRST .+3
	TRO T4,10	;IM. MODE
	TRZ T4,1
	TRNN FLAG,BMOD
	JRST .+3
	TRO T4,14	;BIN. MODE
	TRZ T4,1
	TLNE FLAG,IBFLG	;ASCII TO START.  IB MODE?
	TRO T4,13	;YES
	TRNE FLAG,XFLG	;COPY MODE?
	POPJ P,		;YES, DON'T ALTER DATA MODE
	TRNE FLAG,DFLG+RFLG	;DELETE OR RENAME?
	TRO T4,20	;DIRECTORY WILL BE WRITTEN, DON'T
	POPJ P,		;COMPUTE WORD COUNT MODE NEEDED.
;IF OUTPUT DEVICE IS MTA PERFORM ALL PRE-TRANSFER REQUESTS
;SUCH AS REWIND.  IF OUTPUT DEVICE IS MTA, AND THERE IS NO 
;INPUT DEVICE, EXIT.  FOR OTHER MTA OUTPUT, PREPARE INIT
;DENSITY AND PARITY.

OUTLOK:	TRNN AUXFLG,MTAOUT	
	POPJ P,		;OUT IS NOT MTA
	MOVE T3,ABOUT
	MOVE T1,AUXOUT
	MOVEI T6,INOMTA
	JRST MT1

;SAME FOR INPUT DEVICE.

INLOOK:	TRNN AUXFLG,MTAIN
	POPJ P,		;IN IS NOT MTA
	MOVE T3,AB
	MOVE T1,AUX
	MOVEI T6,INIMTA
	JRST MT1
OMODE:	MOVE T1,DTJBFF
	MOVEM T1,JOBFF
OMOD:	INIT OUT,0	;INITIALIZE OUTPUT DEVICE
ODEV:	0
	XWD OBF,OBI
	JRST ERR1	;UNAVAILABLE ERROR
	OUTBUF OUT,1	;TRY ONE OUTBUFFER FOR SIZE
	MOVE T1,DTJBFF
	EXCH T1,JOBFF
	SUB T1,DTJBFF
	HRRZ 0,JOBREL
	SUB 0,DTJBFF
	ASH 0,-1	;COMPUTE HOW MANY OUTPUT BUFFERS
	IDIVM 0,T1	;FIT IN HALF THE AVAILABLE SPACE
	OUTBUF OUT,(T1)	;SET UP OUTPUT BUFFERS
	MOVE 0,OBF+1
	MOVEM 0,SVOBF	;SAVE ORIGINAL MODE SETTING
	MOVE 0,JOBFF
	HRRZM 0,SVJBF1	;PREPARE TO RECLAIM INBUFFER SPACE
	POPJ P,

OMOD1:	PUSHJ P,OMODE	;GO INITIALIZE OUTPUT DEVICE
	TRNN FLAG,ZFLG	;Z COMMAND TYPED?
	JRST MAINA2
	PUSHJ P,DTCLR	;YES, GO CLEAR DIRECTORY
	TRZ FLAG,ZFLG	;DROP /Z
	RELEASE OUT,
	RELEASE DIR,
	SKIPE DEVICE
	JRST OMOD1
	JRST PIP2
MAINA2:	TRNE   FLAG,RFLG+DFLG	;RENAME OR DELETE FILE MODE?
	JRST   DTDELE		;YES
	TLNE   FLAG,RIMFLG	;RIM?
	JRST   RIMTB
	TRNE   FLAG,XFLG	;TRANSFER EVERYTHING MODE?
	JRST   PRECOP		;YES
MAINA3:	TRNN   AUXFLG,FFLG	;LIST DSK DIR SHORT?
	TRNE   FLAG,LFLG	;LIST DIRECTORY?
	JRST   DTPDIR		;YES
	PUSHJ  P,ININIT		;INITIALIZE INPUT FILE
	TRNE   AUXFLG,DTAIN
	PUSHJ  P,DTADIR		;INIT DTA DIR
	TRNN   AUXFLG,DSKIN
	JRST   MAINA4
	PUSHJ  P,DSKDIR		;OR DSK
MAINA4:	PUSHJ  P,LOOK		;GET A FILE TO COPY
	JRST   MAINA5		;NO MORE
	LOOKUP IN,ZRF
	JRST   ERR3		;LOOKUP FAILURE
IFN WCH,<
MAINA6:	TRNN  AUXFLG,DTAIN+DTAOUT
	JRST  .+5
	HLRZ  0,ZRF+1
	CAIE  0,(SIXBIT /DMP/)
	CAIN  0,(SIXBIT /SAV/)
	JRST  MAINA4		;DONT COPY DMP OR SAV FILES ON DTA>
	TLO   FLAG,NEWFIL
	PUSHJ P,FILTYP
	TRNE  AUXFLG,ONEOUT
	JRST  PSCANA		;OUT HAS BEEN INITIALIZED
IFE WCH,<
	PUSHJ P,OKBLKS>
	ENTER OUT,DTON		;CREATE OUTPUT FILE
	JRST  ERR4		;DIR. FULL OR 0 FILE NAME
	JRST  PSCANA
MAINA5: TRZN  AUXFLG,REDFLG
	JRST  ERR3A		;NEVER READ A FILE
	JRST  MAIN1
PSCANA:	TRO   AUXFLG,REDFLG
	PUSHJ P,INP		;GO READ INPUT FILE
	TRZ   AUXFLG,READ1
	PUSHJ P,TTYZ		;CHECK IF INPUT IS TTY
	TRNE IOS,20000		;EOF FIRST DATA?
	JRST PSCANB
	SKIPN IBF+2
	JRST PSCANA
	JRST PSCAN		;GO CHECK FILE

PSCANB:	TDNE AUXFLG,[XWD MTAIN+CDRIN+TTYIN+PPTIN]	;ON NON-DIR DEVICE?
	SETZM CALFLG	;END OF THE ONE OR MANY FILES SPECIFIED
	TRON AUXFLG,ONEOUT	;HAS OUT JUST BEEN INIT?
	OUTPUT OUT,	;YES, AND FIRST FILE IS EOF ONLY, INIT OUT IN
			;CASE NO MORE SOURCE FILES
	JRST PSCAN5	;EMPTY FILE, CLOSE INPUT, RETURN FOR MORE

PSCAN:	TRO AUXFLG,ONEOUT
	MOVE 0,OPTRA	;PRESCAN A LINE, INITIALIZE LINE BUFFER PTR
	MOVEM 0,OPTR
	SETZM CDRCNT
	PUSHJ P,CLRBUF	;CLEAR LINE BUFFER
	TROA FLAG,STS	;START A FRESH LINE
PSCAN3:	PUSHJ P,PUT	;HERE FOR BINARY DATA
PSCAN2:	PUSHJ P,GET	;GET CHARACTER
	JRST PSCAN1	;END OF FILE RETURN
	TDNN FLAG,[XWD IFLG+IBFLG,BMOD]	;BIN. OR NO CHAR. PROCESSING
	TLNE AUXFLG,SBIN
	JRST PSCAN3	;YES
	MOVE T1,OPTR
	CAMN T1,OPTMAX	;CHECK LENGTH OF LINE
	JRST ERR10   	;LINE TOO LONG
	IDPB CHR,OPTR	;DEPOSIT CHAR. IN LINE BUFFER
	CAIG CHR,24
	CAIGE	CHR,20	;LINE PRINTERR CONTROL CHAR
	SKIPA		;NO
	JRST PSCAN4	;YES, TREAT AS END OF LINE
	CAIG CHR,14
	CAIGE CHR,12	;END OF LINE CHARACTER?
	JRST PSCAN2	;NO, SO CONTINUE
PSCAN4:	PUSHJ P,OUTLBF	;YES, SO DUMP THE LINE BUFFER
	JRST PSCAN	;SCAN THE NEXT LINE

PSCAN1:	PUSHJ P,OUTLBF	;DUMP THE REMAINING BUFFER
	TRNE FLAG,XFLG	;COPY MODE?
	JRST COPY2A	;YES, GO COPY THE NEXT FILE

PSCAN5: CLOSE IN,
	JRST MAINA4
MAIN1:	RELEAS DIR,	;RELEASE THE DIRECTORY DEVICE
	RELEAS IN,INHIB	;RELEASE THE INPUT DEVICE
	SKIPL T4,ESWTCH	;MORE COMMAND STRING TO PROCESS?
	JRST MAIN2	;YES
MAINB:	CLOSE OUT,	;CLOSE THE OUTPUT FILE
	TLNN AUXFLG,NSPROT	;NON-ST. PROT?
	JRST MAINB1	;NO
	TRNN AUXFLG,DSKOUT	;DISK OUT/
	JRST MAINB1	;NO
	PUSHJ P,OUTP1
	LDB 0,PRPTL
	DPB 0,PRPTD
	RENAME OUT,DTON	;SET UP RENAME REQUEST
	JRST DERR6

MAINB1:	PUSHJ P,OUTP1	;CHECK THE FINAL ERROR BITS
	RELEAS OUT,	;RELEASE THE OUTPUT DEVICE
	JRST PIP2	;PROCESS THE NEXT COMMAND

MAIN2:	PUSHJ P,DESCRP	;GET THE NEXT INPUT FILE TO PROCESS
	PUSHJ P,INLOOK
	PUSHJ P,M4
	HRRM T4,ININI1
	JRST MAINA3
ININIT:	MOVE T1,SVJBF1	;SUBR. TO INITIALIZE THE INPUT FILE
	MOVEM T1,JOBFF
ININI1:	INIT IN,0	;INITIALIZE NEW INPUT DEVICE
DEVICE:	0
	XWD 0,IBF
	JRST ERR1A	;NOT AVAILABLE ERROR
	INBUF IN,1	;TRY ONE INPUT BUFFER FOR SIZE
	EXCH T1,JOBFF	;HOW MANY INBUFFERS WILL FIT?
	SUB T1,SVJBF1
	HRRZ 0,JOBREL
	SUB 0,JOBFF
	IDIVM 0,T1
	INBUF IN,(T1)	;SET UP AS MANY BUFFS AS FIT
	MOVE 0,IBF+1	;SAVE ORIGINAL MODE
	MOVEM 0,SVIBF
CPOPJ:	POPJ P,
;THIS ROUTINE GETS AN INPUT UNIT DESCRIPTOR AND, FOR
;ADVANCE FILE AND BSPF ON MTA, ENSURES THE VALUE 1 IF NO
;NUMBER WAS GIVEN.

DESCRP:	SETZM AUX	;WILL GET ANY MTA REQ. GOING TO AUXFLG.
	MOVE 0,SYSFLG
	HLRZM 0,SYSFLG	;SET LAST DEV=SYS IF IT WAS
	SETZM AB
	SETZM PR	;PROTECTION
	SETZM PP	;PROJ-PROG NUMBER
	PUSHJ P,NAME	;GO SCAN INPUT SIDE OF COMMAND STRING
	MOVE T1,PR
	HLLZM T1,PR	;IGNORE PR FLAG IN RHS FOR INPUT
	TRZ AUXFLG,DTAIN+DSKIN+PPTIN+MTAIN+CDRIN+TTYIN
	PUSHJ P,CHECK1	;CHECK UNIT, AND FOR _
	MOVE 0,DEVICE
	TRNN AUXFLG,DSKIN
	JRST DESCR1
	PUSHJ P,PSYSP
	MOVE 0,SYSFLG	;IS THIS DEV. SYS?
	TLNE 0,1	;IF NOT, WAS LAST?
	JRST DESCR1
	TRNN 0,1	;IF YES, IS #P-P=0?
	JRST DESCR1
	MOVE T2,FNPPNS
	SKIPE PP	;IF YES, SET #P-P=FNPPNS
	JRST DESCR1
	MOVEM T2,PP
	MOVEM T2,FNPPN
DESCR1:	SKIPE XNAME	;NO OVERSHOOT ALLOWED
	JRST ERR6A
ABCHK:	MOVS	T2,AB
	XORM	T2,AB
	PUSHJ P,FNSET
	POPJ P,		;EXIT

;IF A NON-STANDARD OUTPUT PROTECTION IS REQUESTED, SAVE FOR RENAME.

PROTK:	MOVE T2,STPROT
	MOVE T1,PR
	TRNN T1,1
	JRST	PROTK1
	HLLZM T1,T2
	HLLZM T1,PROTS
	TLO AUXFLG,NSPROT
PROTK1:	MOVEM T2,PR
	POPJ P,
;TEST "DEVICE" TO SEE IF DESTINATION DEVICE IS DTA, DSK OR PTP.
;IF ANY IS TRUE, SET RELEVANT BIT IN AUXFLG.  "0" CONTAINS
;"DEVICE" ON ENTRY.

DEVTST:	CALLI 0,4
	TLNN 0,DSKBIT
	JUMPA .+6
	TRO AUXFLG,DSKOUT
	EXCH 0,DEVICE	;GET DEVICE NAME AND SAVE DEVCHR
	MOVEM 0,ADSK	;PUT NAME IN DSK INIT
	EXCH 0,DEVICE	;GET DEVCHR AND SAVE DEVICE NAME
	POPJ P,
	JUMPE 0,DEVER2	;NON-EXISTENT DEVICE
	TLNE 0,DTABIT
	TRO AUXFLG,DTAOUT
	TLNE 0,PTPBIT
	TRO AUXFLG,PPTOUT
	TLNE 0,LPTBIT
	TRO AUXFLG,LPTOUT
	TLNE 0,TTYBIT
	TRO AUXFLG,TTYOUT
	TLNE 0,MTABIT
	TRO AUXFLG,MTAOUT
	TRNN AUXFLG,DSKOUT
	POPJ P,

PSYSP:	HRLZI T1,(SIXBIT /SYS/)
	CAME 0,T1
	POPJ P,
	SKIPN T1,PP
IFNDEF SYSPP,<
	MOVE T1,[XWD 1,1]>
IFDEF SYSPP,<
	MOVE T1,SYSPP>
	MOVEM T1,PP
	HRLI 0,1
	HLLM 0,SYSFLG	;THIS DEV IS SYS
	POPJ P,

DEVER2:	MOVE T1,ODEV
	SKIPA
DEVER:	MOVE T1,DEVICE
	MOVEM T1,DEVER1
	JSP T1,PTEXT
	SIXBIT /?@DEV@/
DEVER1:	0
	SIXBIT /@DOES@NOT@EXIST@!/
INICN1:	MOVEI	P,PDL-1		;INITIALIZE PUSHDOWN POINTER
INICN2: MOVE	0,SVJBFF	;IS INITIALIZED AT PIP1
	MOVEM	0,JOBFF		;SET JOBFF TO BEGINNING OF BUFFER AREA
	HRRZ	0,JOBSA		;SETUP TO ALLOW RE-ENTER
	MOVEM	0,JOBREN
	PUSHJ	P,INICON	;INITIALIZE THE TTY
	INBUF	CON,1		;ONE INBUFFER
	OUTBUF	CON,1		;ONE OUTBUFFER
	MOVE	0,JOBFF
	HRRZM	0,DTJBFF
	OUTPUT	 CON,		;INITIALIZE BUFFER POINTERS
	JRST	(T5)

CLRBUF:	SETZM	LBUF		;SUBR. TO CLEAR LINE BUFFER
	MOVE	0,[XWD LBUF,LBUF+1]
	BLT	0,DBUF-1
	POPJ	P,

;COMMAND SCANNER ROUTINE

NAME:	SKIPL	SSWTCH		;RETURN NULL IF _ OR END-OF-LINE SEEN
	SKIPGE	ESWTCH
	JRST	NM13
	SETZM	NSWTCH
	SKIPE	T1,XNAME	;IF COMMAND SCAN OVERSHOOT PICKED UP A DEVICE NAME
				;USE IT NOW
	JRST	NM7
	SETZM	DEV
NM1:	SETZM	FILEX
NM2:	SETZM	FILNAM
	MOVE	T1,NM15
NM3:	PUSHJ	P,GETCOM	;GO GET 7 BIT ASCII CHAR. FROM COMMAND STRING
	CAIE	0,"*"		;TO ALLOW FN.EX = *.*
	CAIL	0,"A"		;ALPHABETIC CHARACTER?
	CAILE	0,"Z"
	JRST	NM4A		;NO
NM4:	SUBI	0,40		;CONVERT TO SIXBIT
	TLNE	T1,770000	;6 CHARS. YET?
	IDP1		;NO
	JRST	NM3		;GET NEXT CHAR.
NM4A:	CAIL	0,"0"		;NUMERIC?
	CAILE	0,"9"
	SKIPA			;NO
	JRST	NM4
NM5:	CAIG	0,15		;CARRIAGE RETURN
	CAIGE	0,12		;LINE FEED
	CAIN	0,175		;ALTMODE
	SOSA	ESWTCH
	CAIN	0,","
	JRST	NM6
	CAIN	0,"."
	JRST	NM10
	CAIN	0,":"
	JRST	NM9
	CAIE	0,137		;LEFT ARROW
	JRST	NM3
	SETOM	SSWTCH		;SET LEFT ARROW SWITCH
NM6:	SKIPN	T1,FILEX	;COMMA ROUTINE - FIGURE OUT WHAT WE HAVE
	JRST	NM11		;NO FILE NAME TEMPORARILY IN FILEX
	EXCH	T1,FILNAM	;PUT THE FILE NAME WHERE IT BELONGS
	HLLZM	T1,FILEX	;PUT THE EXTENSION WHERE IT BELONGS
	POPJ	P,
NM7:	SETZM	XNAME		;USE XNAME ONLY ONCE
	CAIN	T1,1		;1 FLAGS A NULL OVERSHOOT
	JRST	NM13		;RETURN NULL NAME
NM8:	MOVEM	T1,DEVICE	;NEW DEVICE
	SETOM	DEV
	JRST	NM1		;LOOK FOR A FILE NAME AND EXTENSION
NM9:	SKIPN	DEV		;COLON ROUTINE - IS DEVICE NAME IN YET?
	JRST	NM12		;NO
	SKIPN	T1,FILNAM	;SCAN OVERSHOOT - NULL OVERSHOOT?
	MOVEI	T1,1		;YES - FLAG NULL OVERSHOOT WITH A 1
	MOVEM	T1,XNAME	;XNAME = OVERSHOOT NAME
	JRST	NM14
NM10:	MOVE	0,FILNAM	;PERIOD ROUTINE - SAVE FILE NAME
	MOVEM	0,FILEX		;TEMPORARILY IN FILEX
	JRST	NM2		;LOOK FOR EXTENSION
NM11:	SKIPN	FILNAM		;WAS A FILE NAME SPECIFIED?
	SKIPE	DEV		;WAS ANYTHING SPECIFIED?
	POPJ	P,		;YES
NM12:	SKIPE	T1,FILNAM	;NULL NAME SPECIFIED?
	JRST	NM8		;NO - SO REMEMBER AND LOOK FOR FILE NAME
NM13:	SETOM	NSWTCH		;RETURN ANULLNAME
	SETZM	FILEX
NM14:	SETZM	FILNAM
	POPJ	P,
NM15:	POINT	6,FILNAM
;ROUTINE TO OUTPUT ONE LINE FROM LBUF

OUTLBF:	TRNE FLAG,LINE
	JRST OUTLBA	;OUTPUT LINE-BY-LINE
OUTCH1:	MOVE T2,OPTRA	;OUTPUT CHARACTER-BY-CHARACTER
OUTLB1:	CAMN T2,OPTR	;ARE ALL CHARACTERS OUT?
	POPJ P,		;YES
	ILDB CHR,T2	;NO
	PUSHJ P,PUT	;GO OUTPUT CHARACTER
	JRST OUTLB1
OUTLBA:	TLNE FLAG,CHKFLG;PAREN COUNTING?
	JRST OUTCHK	;YES, SO DO IT
	TRNE AUXFLG,TTYOUT+LPTOUT
	JRST OUTCH1	;IF OUTPUT TO TTY OR LPT DO CHR BY CHR	
	MOVEI T1,4	;CLEAR UNUSED PORTION OF LAST WORD USED IN LBUF
	MOVEI T2,0
	MOVE T3,OPTR
	IDPB T2,T3
	SOJG T1,.-1
	MOVEI T2,5
	HRRZ T1,OPTR	;COMPUTE NUMBER OF WORDS FILLED
	SUBI T1,LBUF-1
	JUMPE T1,OUTLB3	;DO NOTHING IF BUFFER EMPTY
	IMULM T1,T2	;COMPUTE CHARACTER COUNT=5 TIMES WORD CT
;THIS IS WHERE OLD FORTRAN MODE WAS TESTED.
	CAMG T2,OBF+2	;WILL LINE FIT IN THE OUTBUFFER?
	JRST OUTLB2	;YES
	PUSHJ P,OUTP	;NO, SO DUMP BUFFER AND CHECK ERROR BITS
	MOVEI T6 ,1
	TDNE T6,LBUF	;SEQUENCED?   
	TRNN AUXFLG,DTAOUT+DSKOUT	;YES, ON DTA OR DSK?
	SKIPA		;NO
	ADDI T2,40*5	;LEAVE EDITING ROOM
OUTLB2:	MOVNS T2
	ADDM T2,OBF+2	;UPDATE OUTBUFFER CHARACTER COUNT
	HRLI T2,LBUF
	HRR T2,OBF+1
	AOS T2
	ADDB T1,OBF+1	;UPDATE OUTBUFFER BYTE POINTER
	BLT T2,(T1)	;MOVE DATA TO OUTBUFFER
OUTLB3:	POPJ P,
PUT:	SOSG OBF+2	;SUBR. TO OUTPUT ONE CHARACTER IN AC CHR
	PUSHJ P,OUTP	;IF BUFFER FULL, DUMP AND CHECK ERR BITS
	IDPB CHR,OBF+1	;PUT CHARACTER IN BUFFER
	POPJ P,

OUTP:	OUTPUT OUT,	;SUBR. TO DUMP OUTBUFFER AND CHECK ERR BITS
OUTP1:	STATUS OUT,IOS	;HERE FOR BIT CHECKING ONLY
	PUSHJ P,OUTP4
	SETSTS OUT,(IOS)
	POPJ P,

OUTP4:	TRNN AUXFLG,MTAOUT
	JRST .+3
OUTP3:	TRNE IOS,2000
	JRST .+3
	TRNN IOS,740000	;ANY ERROR BITS ON?
	JRST IPOP
	PUSHJ P,COMERR
	MOVE T1,ODEV
	MOVEM T1,OUTP2
	JSP T5,INICN2
	PUSHJ P,QUEST
	JSP T1,PTEXT2
	SIXBIT /OUTPUT@DEVICE@/
OUTP2:	0
	SIXBIT /:@FILE@#/
	MOVEI T6,DTON
	PUSHJ P,FN.EX
	MOVE T2,AUXFLG
	ANDI T2,MTAOUT+DSKOUT+DTAOUT
IOERR:	MOVEI T1,TXTC
	TRNE IOS,2000
	JRST PTEXT2
	MOVEI T1,TXTD2
	TRNN T2,CDRIN
	MOVEI T1,TXTD
	TRNN T2,DSKIN+DSKOUT+DTAIN+DTAOUT+MTAIN+MTAOUT
	MOVEI T1,TXTD1
	TRNE IOS,400000
	JRST PTEXT2
	MOVEI T1,TXTA
	TRNE IOS,200000
	JRST PTEXT2
	MOVEI T1,TXTB
	TRNE IOS,100000
	JRST PTEXT2
	MOVEI T1,TXTC1
	TRNN T2,DTAIN+DTAOUT
	MOVEI T1,TXTC2
	JRST PTEXT2
;DEVICE ERROR COMMENTS

TXTD:	SIXBIT /WRITE@(LOCK)@ERROR#/
	JRST IOERRN
TXTD1:	SIXBIT /BINARY@DATA@INCOMPLETE#/
	JRST IOERRG
TXTD2:	SIXBIT /7-9@PUNCH@MISSING#/
	JRST IOERRG
TXTA:	SIXBIT /DEVICE@ERROR#/
	JRST IOERRG
TXTB:	SIXBIT /CHECKSUM@OR@PARITY@ERROR#/
	JRST IOERRG
TXTC:	SIXBIT /PHYSICAL@EOT#/
	JRST IOERRG
TXTC1:	SIXBIT /BLOCK@TOO@LARGE#/
IOERRN:	RELEAS TAPE,
	RELEAS DIR,
	RELEAS OUT,
	RELEAS IN,
IFN DISK30,<
	RELEAS BLKIN,>
	JRST PIP2
TXTC2:	SIXBIT /INPUT@BUFFER@OVERFLOW#/
IOERRG:	TLNN FLAG,GFLG		;PRINTED CURRENT MESSAGE
	JRST IOERRN		;NO RECOVERY
	MOVEI 0,15
	IDPB 0,TFO+1
	MOVEI 0,12
	IDPB 0,TFO+1
	RELEAS CON,
	TRNE AUXFLG,TTYOUT
	PUSHJ P,OMODE
	TRNE AUXFLG,TTYIN	;REINIT TTYIN,TTYOUT
	PUSHJ P,ININIT
	TRZ IOS,740000
	TRNE T2,MTAIN+MTAOUT
	TRZ IOS,2000
	JRST RESTAC		;IGNORE THESE ERRORS IF USER WANTS TO

COMERR:	PUSHJ P,SAVACS
	TRNE AUXFLG,TTYOUT	;RELEASE ANY TTYIO
	RELEAS OUT,
	TRNE AUXFLG,TTYIN
	RELEAS IN,
	POPJ P,
;PRINT FILE NAME AND EXTENSION FROM (T6), 1(T6).

FN.EX:	MOVE T3,T6
	MOVE T1,(T6)
	HLRZ T6,1(T6)
	CAMN T6,[SIXBIT ?   UFD?]
	SETZM T1	;UFD FILES ONLY ARE ASSUMED TO HAVE FILENAME
	MOVEM T1,DERR2	;OF NUMERIC FORM (#,# P-P NUMBER).
	JUMPE T6,DERR2A
	CAME T6,[SIXBIT ?   UFD?]
	JRST DERR2B
	HLRZ DOUT,(T3)
	MOVEI T2,PUTCON	;PRINT PROJ-PROG. NO.
	PUSHJ P,OUTOCT
	MOVEI CHR,","
	PUSHJ P,PUTCON
	HRRZ DOUT,(T3)
	PUSHJ P,OUTOCT

DERR2B:	TLO T6,16
DERR2A:	MOVEM T6,DERR2+1
	JSP T1,PTEXT2

DERR2:	0
	0
	SIXBIT /@#/
	POPJ P,

SAVACS:	MOVE 0,[XWD 1,SAVAC]	;SAVE ACS T1,T2,T3,T5,T6
	BLT 0,SAVAC+2
	MOVEM T5,SAVAC+3
	MOVEM T6,SAVAC+4
	POPJ P,

RESTAC:	MOVS 0,[XWD 1,SAVAC]
	BLT 0,3
	MOVE T5,SAVAC+3
	MOVE T6,SAVAC+4
	POPJ P,
;THIS ROUTINE GETS A 7 BIT ASCII CHARACTER FROM THE COMMAND STRING
;AND RETURNS IT TO THE COMMAND SCANNER ROUTINE (NAME) IN AC0

GETCOM:	PUSHJ P,GETTA
	CAIN 0,"/"	;SINGLE CHARACTER SWITCH
	JRST GETT6
	CAIN 0,"("	;LOOK FOR (MULTI-CHAR.) SWITCH
	JRST GETT3
	CAIN	0,"+"	; LOOK FOR SPECIAL CATALOG SWITCHES
	JRST	GETX5
	CAIN 0,"<"	;GO LOOK FOR PROTECTION
	JRST GETT9
	CAIE 0,"["
	POPJ P,

GETT10:	PUSHJ P,GETNUM	;LOOK FOR PROJECT-PROGRAMMER NUMBER
	CAILE T7,-1	;GREATER THAN HALF WORD?
	JRST ERR2A	;YES, ERROR
	CAIE 0,","	;SEPARATOR?
	JRST GETT11	;OR TERMINATOR (NON-NUMERIC)
	HRLZM T7,PP
	JRST GETT10

GETT11:	HRRM T7,PP
	CAIN 0,"]"	;FORCE CORRECT TERMINATOR
	JRST GETCOM
	JRST ERR2

GETT9:	PUSHJ P,GETNUM
	CAIN 0,">"	;TERMINATE ON RIGHT BRKT ONLY
	CAILE T7,777	;PR. IN RANGE?
	JRST ERR2A
	ROT T7,-11
	HLLOM T7,PR	;RHS=1'S MEANS <> SEEN (PR MAY BE 0)
	JRST GETCOM

GETNUM:	MOVEI T7,0	;TO PICK UP P-P NUMBER
GETN1:	PUSHJ P,GETTA	;AND PROTECTION
	CAIN 0," "	;IGNORE SPACES
	JRST GETN1
	CAIL 0,"0"
	CAILE 0,"7"
	POPJ P,		;GOT A NON-NUMERIC
	MOVE T5,0
	LSH T7,3
	ADDI T7,-60(T5)	;PROCESS TO BINARY
	JRST GETN1
GETT3:	PUSHJ P,GETT5	;PROCESS SWITCH CHARACTER
	CAIN 0,")"	;CLOSING PAREN?
	JRST GETCOM
	CAIN 0,"M"	;MTA FLAG?
	TRO FLAG, MTFLG	;SET MTA, LOOK FOR MULTI CHAR. SWITCH
	CAIE 0,"#"
	JRST GETT3
	TRNN FLAG,MTFLG	;ONLY LOOK AFTER # IF MTFLG IS ON.
	JRST ERR6A	;I.E. IF MT SWITCH IS IN PROGRESS.
	PUSHJ P,GETNUD	;GET A NUMBER
	CAIE 0,"D"
	CAIN 0,"A"	;TERMINATED BY A?
	JRST GETT3A	;YES, MARK AB UPPER
	CAIE 0,"P"	;ONLY A,D,P AND B CAN BE
	CAIN 0,"B"	;PRECEDED BY #.
	SKIPA	
	JRST ERR6A
	HRRM T7,AB
GETT3B:	PUSHJ P,GETT5A
	JRST GETT3

GETT3A:	HRLM T7,AB
	JRST GETT3B

GETT6:	PUSHJ P,GETT5	;PROCESS ONE SWITCH CHAR
	CAIE 0,"M"
	CAIN 0,")"	;THESE ARE ILLEGAL 1-SWITCH CHARS.
	JRST ERR6A
	JRST GETCOM

GETNUD:	MOVEI T7,0	;GET A DECIMAL NUMBER
GETN2:	PUSHJ P,GETTA
	CAIN 0," "
	JRST GETN2
	CAIL 0,"0"
	CAILE 0,"9"
	POPJ P,
	IMULI T7,^D10	;T7*10
	ANDI 0,17
	ADD T7,0	;+ LOW 4 BITS
	JRST GETN2
GETX5:	PUSHJ	P,GETTA		;GET THE SWITCH CHARACTER
	MOVE	T2,[XWD 350700,DISPTC]
	MOVEI	T6,AUXFLG	;	SET FLAG WORD TO SET
GETX6:	LDB	T3,T2		;GET A TABLE ENTRY
	CAIN	T3,3		;END OF TABLE
	JRST	ERR6A		;FATAL..
	CAME	T3,0		;FOUND AN EQUIVALENT VALUE?
	AOJA	T2,GETX6	;IF NOT TRY AGAIN
	MOVE	T5,(T2)	;GET THE FLAG SETTING
	LSH	T5,^D18		;WANT TO SET RIGHT HALF OF WORD
	ORM	T5,(T6)		;SET FLAG
	POPJ	P,		;RETURN

GETT5:	PUSHJ P,GETTA
GETT5A:	MOVE T2,[XWD 350700,DISPTB]	;GO GET SWITCH CHAR. AND PPROCESS
	MOVEI T6,MTAREQ
	TRNN FLAG,MTFLG	;SET UP TABLE TO SEARCH AND FLAG TO SET.
	HRRI T2,DISPTA
	TRNN FLAG,MTFLG	;IF MTFLG SET, START AT DISPTB AND STORE RESULT IN
	MOVEI T6,AUXFLG	;MTAREQ, ELSE START AT DISPTA AND STORE RESULT IN
			;AUXFLG OR FLAG
GETT7:	LDB T3,T2	;COMPARE WITH LEFT 7 BITS OF
	JUMPN T3,GETT8	;TABLE ENTRIES
	TRZ FLAG, MTFLG	;SEARCHED TABLE 1, DROP MTA FLAG
	MOVEI T6,AUXFLG
	TLNE AUXFLG,NOMORE	;AFTER FIRST INPUT DEVICE ONLY ACCEPT MTA FLAGS
	POPJ P,

GETT8:	CAIN T3,1
	MOVEI T6,FLAG	;SEARCH TABLE TWO, FROM NOW ON
	CAIN T3,2	;SET FLAG.
	JRST ERR6A	;SEARCHED TABLE 3, ERROR EXIT
	CAME T3,0	;MATCHING CHARACTER?
	AOJA T2,GETT7	;NO, TRY ANOTHER
	MOVE T5,(T2)	;YES, SET FLAG OR AUXFLG
	ORM T5,(T6)
	TRNE FLAG,MTFLG
	ORM T5,AUX
	POPJ P,		;EXIT

GETTA:
IFN CCLSW,<
	SKIPE COMFLG	;STORED COMMANDS?
	JRST GETSC	;YES>
	SOSLE TFI+2	;SUBR TO GET ONE TTY CHAR IN AC 0
	JRST GETT2	;BUFFER NOT EMPTY
	MOVE 0,TFI
	MOVE T5,TFO
	PUSHJ P,INICON	;BUFFER EMPTY SO RE-ATTACH TTY
	MOVEM 0,TFI
	MOVEM T5,TFO	;USE PREVIOUSLY ASSIGNED I/O BUF. FOR TTY
	OUTPUT CON,	;OUTPUT *
	MOVEI 0,"*"
	IDPB 0,TFO+1
	OUTPUT CON,
	INPUT CON,	;GET THE NEXT LINE
	MOVE T5,TFI+2	;SAVE CHAR COUNT
	RELEAS CON,	;LET GO OF TTY FOR USE AS IN-OUT DEVICE
	MOVEM T5,TFI+2	;RESTORE CHAR COUNT LOST DURING RELEASE
GETT2:	ILDB 0,TFI+1	;FETCH CHAR
	POPJ P,

INICON:	INIT CON,1	;SUBR TO INITIALIZE THE TTY
ITTY:	SIXBIT /TTY/
	XWD TFO,TFI
	JRST	SUDSTR	;IF TTY NOT AVAILABLE, FATAL ...JOB DET?
	POPJ P,
;GET 7 BIT ASCII CHARACTER - INPUT FROM CCL COMMAND FILE

IFN CCLSW,<
GETSC:	SOSLE	CFI+2		;ANY REMAINING?
	JRST	GETSC0		;YES
	INPUT	COM,
	STATZ	COM,740000	;ERRORS?
	JRST	CER3		;YES
	STATZ	COM,020000	;END-OF-FILE
	JRST	GETEND		;YES
GETSC0:	ILDB	0,CFI+1
	MOVE	DOUT1,@CFI+1	;GET PRESENT WORD
	TRNN	DOUT1,1		;IS IT A SEQUENCE NUMBER?
	JRST	GETSC1		;NO - CONTINUE
	AOS	CFI+1		;YES - ADD 1 TO BYTE POINTER
	MOVNI	DOUT1,5
	ADDM	DOUT1,CFI+2	;SUBTRACT 5 FROM COUNT
	JRST	GETSC		;CONTINUE
GETSC1:	JUMPE	0,GETSC		;FILTER OUT NULL CHARACTERS
	POPJ	P,
CER3:	JSP	T1,PTEXT
	SIXBIT	/READ@ERROR@-@CCL@COMMAND@FILE#/
GETEND:	CLOSE	COM,
	SETZB	0,1
	SETZB	2,3
	RENAME	COM,0
	JFCL	17,.+1
	JRST	SUDSTR		;EXIT TO SUDS
;TABLE OF RECOGNIZED COMMAND LETTERS AND CORRESPONDING FLAG BITS

DEFINE DISP (A,B)
<	XWD <"A">*4000,B>

DISPTB:	DISP A,MTAFLG
	DISP B,MTBFLG
	DISP T,MTTFLG
	DISP W,MTWFLG
	DISP 8,MT8FLG
	DISP 5,MT5FLG
	DISP 2,MT2FLG
	DISP E,MTEFLG
	DISP U,MTUFLG
	DISP F,MTFFLG
	DISP D,MTDFLG
	DISP P,MTPFLG
	DISP #,0
			OCT 000000000000

DISPTA:			XWD <"Q">*4000+QFLG,0
			XWD <"E">*4000+CDRFLG,0
	DISP F,FFLG
			OCT 004000000000

	DISP A,LINE
	DISP B,BMOD
	DISP C,TBMOD
	DISP D,DFLG
	DISP L,LFLG
	DISP M,0
	DISP ),0
	DISP N,NSMOD
	DISP O,SQMOD+NSMOD+STS+OSFLG
			XWD <"P">*4000+PFLG+PCONV,0
	DISP R,RFLG
	DISP S,SQMOD+NSMOD+STS
	DISP T,SPMOD
			XWD <"V">*4000+CHKFLG,LINE
	DISP X,XFLG
	DISP Z,ZFLG
			XWD <"U">*4000+OFLG,0
			XWD <"Y">*4000+IBFLG+RIMFLG,0
			XWD <"I">*4000+IFLG,0
			XWD <"H">*4000+IBFLG,0
			XWD <"G">*4000+GFLG,0
			OCT 010000000000

DISPTC:	DISP D,DTFLG
	DISP T,TIFLG
	DISP B,SIFLG
	DISP P,PRFLG
	OCT 014000000000	;END OF TABLE 3

;SUBR TO GET NEXT CHAR INTO AC CHR
;NO SKIP RETURN IS END OF FILE, SINGLE SKIP IS NORMAL RETURN

GET:	TLNN FLAG,NEWFIL	;NEW FILE?
	TLZN FLAG,PCONV+NEWFIL	;NO,CONVERT THIS CHAR?
	JRST GETPC1	;YES
	LDB CHR,IBF+1	;GET CHAR
	CAIN CHR," "	;SPACE?
	JRST GETPC2	;YES, CONVERT TO LINE FEED
	CAIG CHR,"3"	;IS THE CHAR A PROPER FORMAT CONTROL CHAR?
	CAIGE CHR,"*"
	JRST GETPC3	;NO, SO OUTPUT LINE FEED FOLLOWED BY BAD CHAR
	CAIG CHR,"."	;USE LEFT HALF OF TABLE?
	SKIPA CHR,PCHTAB-<"*">(CHR)
	MOVS CHR,PCHTAB-<"/">(CHR)
GETPC4:	DPB CHR,IBF+1	;CLOBBER OLD CHAR, USUALLY BECOMES NULL
	LSH CHR,-7	;BUT OTHERWISE BECOMES ANOTHER FORMAT CHAR
	ANDI CHR,377	;EXTRACT THE CHAR TO BE OUTPUT
	TRZE CHR,200	;=1 FOR GENERATING MULTIPLE LINE FEEDS
	TLO FLAG,PCONV	;CONTINUE TO CONVERT
	JUMPN CHR,RETSKP;OUTPUT THE GENERATED CHAR UNLESS NULL
	POP	P,(P)
	JRST	PSCAN4
GETPC1:	TRNN FLAG,SUS	;SUPPLYING SEQ. NUM. NOW?
	JRST GET2	;NO
	ILDB CHR,PTRPT	;YES, SO GET CHAR OF SEQ NUM
	JUMPN CHR,RETSKP;0 MARKS LAST CHAR
	LDB T1,IBF+1	;GET FIRST CIAR OF THIS LINE
	TRZ FLAG,ESQ
	MOVEI CHR,15
	CAIG T1,15	;PREPARE TO OUTPUT A CHAR. RET.
	CAIGE T1,12	;IS FIRST CHAR OF LINE AN END OF LINE CHAR?
	MOVEI	CHR,40		;BLANK INSTEAD OF TAB
	CAIN T1,"	"	;IS IT A TAB
	MOVEI CHR,11	;YES SO PUT A TAB
	TRZ FLAG,SUS	;TURN OFF SUS SUPPLY
	JRST	GETA5
GET5:	JFCL;	AOS IBF+1	;HERE IF A SEQ NUM FOUND IN INBUFFER
JFCL;	SUBI T1,5	;IGNORE SEQ NUM, TAB AND DECREMENT CHAR COUNT
JFCL;	MOVEM T1,IBF+2
	TRNE FLAG,NSMOD	;REMOVE SEQ NUMS MODE?
	JRST GET21	;YES, SO GET NEXT CHAR
	MOVEM T2,SQNUM	;SEQ NUM FROM BUFFER BECOMES NEW SEQ NUM
	PUSHJ P,OUTLBF	;DUMP THE LINE BUFFER (IF REQUIRED)
	TRON FLAG,STS+SNI	;TURN ON START OF LINE
			;AND NO-INCREMENT SEQ NUM FLAG
	PUSHJ P,CLRBUF	;CLEAR LBUF IF IN THE MIDDLE OF A LINE

GET2:	TRZE FLAG,ESQ	;REPROCESS LAST CHAR?
	JRST GET1	;YES
	SOSL T1,IBF+2	;CHARS REMAINING IN INBUFFER?
	JRST GET4	;YES
	PUSHJ P,INP	;NO, SO REFILL AND CHECK ERR BITS
	TRNE IOS,20000	;END OF FILE? IOS HAS STATUS BITS
	POPJ P,		;YES
	JRST GET2	;NO, SO PROCESS INBUFFER

GET21:	IBP IBF+1
	SUBI T1,1
	MOVEM T1,IBF+2
	JRST GET2
GETPC3:	TRO FLAG,ESQ	;REPROCESS BAD CHAR
	TROA CHR,12*200	;PRECEED BAD CHAR WITH LINE FEED
GETPC2:	MOVEI CHR,12*200;CHANGE SPACE TO LINE FEED
	JRST GETPC4

PCHTAB:	XWD 24*200,23*200	;/ *
	XWD 212*200+" ",0	;0 +
	XWD 14*200,21*200	;1 ,
	XWD 20*200,212*200+"0"	;2 -
	XWD 13*200,22*200	;3 .

GET4:	ILDB CHR,IBF+1	;FETCH CHAR FROM INBUFFER
	TDNN FLAG,[XWD IFLG+IBFLG,BMOD]	;BIN, IB, I OR SBIN MODE?
	TLNE AUXFLG,SBIN
	JRST RETSKP	;YES, SO NO PROCESSING REQUIRED
GET1:	LDB CHR,IBF+1	;AFTER SEQ NUM, HERE FOR 1ST CHAR
	JUMPE CHR,GET2	;IGNORE NULL CHARS
	CAIN CHR,12	;IGNORE LINE FEED IN FORTRAN OUTPUT
	TLNN FLAG,PFLG
	SKIPA		;NOT FORTRAN LINE FEED
	TLOA FLAG,PCONV	;CONVERT THE NEXT LIVE CHAR
	CAIN CHR,S2	;IGNORE INCOMING 32S
	JRST GET2	;GET NEXT CHAR
	MOVE T2,@IBF+1	;BIT 35 OF BUFFER SET?
	TRZE T2,1
	JRST GET5	;YES, THIS IS A SEQ NUM
	TRZE FLAG,STS	;START SEQ (NEW LINE) FLAG ON?
	TRNN FLAG,SQMOD+SNI	;YES, SEQ MODE OR SEQ COPY?
	JRST GET7	;NO, SO PROCESS CHAR
	MOVE T2,SQNUM	;NO, SO ADD 10. TO SEQ NUM
	MOVE T1,K1
	TRNE FLAG,OSFLG	;TEST FOR INCR. BY ONE
	MOVE T1,K4
	ADD T2,T1	;ASCII INCREMENT
	AND T2,K3	;MASK SIGNIFICANT DIGITS
	MOVE T1,T2
	AND T1,ZRO	;MASK CARRY BITS
	ASH T1,-3
	SUB T2,T1	;ADJUST CARRIES
	IOR T2,ZRO
	TRZN FLAG,SNI	;NON-INCREMENT SEQ NUM FLAG ON?
	MOVEM T2,SQNUM	;NO, SO SAVE THE RESULT
	TRO FLAG,LINE+SUS+ESQ	;TURN ON SUPPLY SEQ, REPROCESS
				;LAST CHAR, AND LINE-BY-LINE FLAGS
	AOS LBUF		;SET BIT 35 IN LBUF TO MARK SEQ NUM
	MOVE T1,[POINT 7,SQNUM]
	MOVEM T1,PTRPT	;INITIALIZE SEQ NUM PICK-UP POINTER
	JRST GET	;GO OUTPUT FIRST CHAR OF SEQ NUM
INP:	INPUT IN,	;INPUT DATA
INERR:	STATUS IN,IOS	;SUBR TO CHECK INPUT ERR BITS
	TRNN AUXFLG,MTAIN
	JRST .+3
	TRNE IOS,2000
	JRST .+3
	TRNN IOS,740000	;ANY ERROR BITS SET?
	POPJ P,		;NO
	PUSHJ P,COMERR
	MOVE T1,DEVICE	;YES, SO PRINT OUT COMPLETE FILE DESCRIPTOR
	MOVEM T1,INERR1
	JSP T5,INICN2
	PUSHJ P,QUEST
	JSP T1,PTEXT2	;GO PRINT FILE DESCRIPTOR
	SIXBIT /INPUT@DEVICE@/
INERR1:	0
	SIXBIT /:@FILE@#/
	MOVEI T6,ZRF
	PUSHJ P,FN.EX
	MOVE T2,AUXFLG
	ANDI T2,CDRIN+DTAIN+DSKIN+MTAIN
	PUSHJ P,IOERR	;GO PRINT ERROR DESCRIPTOR
	SETSTS IN,(IOS)
	POPJ P,

QUEST:	TLNN FLAG,GFLG
	JRST QUEST1
	TRNN IOS,40000
	JRST QUEST2
	TRNN AUXFLG,DTAIN+DTAOUT
	POPJ P,		;BLOCK TOO LARGE
QUEST1:	JSP T1,PTEXT2
	SIXBIT /?#/
	POPJ P,
QUEST2:	TRNN AUXFLG,DTAIN+DTAOUT+MTAIN+MTAOUT+DSKIN+DSKOUT
	POPJ P,
	TRNE IOS,400000
	JRST QUEST1
	POPJ P,		;WRITE (LOCK) FATAL

GET7:	TLNE FLAG,PCONV	;CONVERTING FORTRAN CARRAIGE CONTROL CHAR?
	JRST GET+1	;YES, GO DO IT
	AOS T1,CDRCNT
	TLNE AUXFLG,CDRFLG
	JRST GET7B
GET7C:	CAIN CHR,40	;SPACE?
	JRST GETA2	;YES
	CAIN CHR,15	;CAR. RET.?
	JRST GETA3	;YES
	TRZ FLAG,SPOK	;CHAR NOT A SPACE STOP COUNTING CONSEC. SPACES
	CAIN CHR,11	;TAB?
	JRST GETA5	;KEEP TRACK OF TAB STOPS
	CAIG CHR,137
	CAIGE CHR,40	;NON-SPACING CHARACTER?
	JRST RETSKP	;YES, SO RETURN IMMEDIATELY
	SOSG TABCT	;COUNT DOWN THE TAB STOP COUNTER
	JRST GETA5	;RESET THE COUNTER IF TAB STOP IS PASSED

RETSKP:	AOS (P)		;SKIP RETURN
	POPJ P,

GET7B:	CAIL T1,^D73
	CAILE T1,^D80
	SKIPA	;CANT BE A CARD SEQUENCE NUMBER
	MOVEI CHR,40	;REPLACE CARD SEQUENCE NOS. BY SPACE
	JRST GET7C

GETA3:	TRZE FLAG,SPOK	;CAR. RET. SEEN, ANY TRAILING SPACES?
	TRNN FLAG,SPMOD+TBMOD	;YES, ARE WE FLUSHING TRAILING SPACES
	JRST GETA5	;NO, RESET TAB COUNTER ONLY
	MOVE 0,SVPTR1
	MOVEM 0,OPTR	;CLOBBER THE OUTPUT POINTER TO LBUF
GETA5:	MOVEI 0,TABSP
	MOVEM 0,TABCT	;RESET THE TAB COUNTER
	JRST RETSKP
GETA2:	TROE FLAG,SPOK	;SPACE WAS SEEN, IS THIS ONE OF A SEQUENCE?
	JRST GETA7	;YES
	MOVE 0,OPTR	;THIS IS THE FIRST SPACE SEEN, SAVE LBUF
			;POINTER IN CASE THIS SPACE MUST BE FLUSHED
	MOVEM 0,SVPTR1	;THIS POINTER FOR FLUSHING FINAL SPACES
	MOVEM 0,SVPTR2	;THIS POINTER FOR CHANGING MULT. SPACES TO TABS
	SETZM SPCT	;INITIALIZE THE SPACE COUNTER
GETA7:	AOS T1,SPCT
	SOSLE TABCT	;ARE WE AT THE NEXT TAB STOP?
	JRST RETSKP	;NO
	CAIL T1,2	;DONT BOTHER CHANGING ONE SPACE TO A TAB
	TRNN FLAG,TBMOD	;TAB GENERATING MODE?
	JRST GETA5A	;NO, GO RESET TAB COUNTER
	MOVE 0,SVPTR2
	MOVEM 0,OPTR	;BACK UP THE OUTPUT POINTER OVER THE LAST
			;GROUP OF SPACES
	MOVEI CHR,11	;OUTPUT A TAB
	SETZM SPCT	;RESET THE SPACE COUNTER
GETA5A:	IBP SVPTR2	;UPDATE THE CHANGE-SPACES-TO-TABS POINTER
	JRST GETA5	;RESET THE TAB COUNTER
;ERROR ROUTINES

IFE WCH,<
ERR8A:	MOVEI	T4,ERR382
	SKIPA
ERR3B:	MOVEI	T4,ERR381>
E10B:	JSP	T1,PTEXT
	SIXBIT	/?FILE@#/
	MOVEI T6,ZRF
	PUSHJ P,FN.EX
	JRST	(T4)
IFE WCH,<
ERR381:	JSP	T1,PTEXT2
	SIXBIT	/ILLEGAL@EXTENSION!/

ERR382:	JSP	T1,PTEXT2
	SIXBIT	/ILLEGAL@FORMAT!/

ERR5B:	JSP	T1,PTEXT
	SIXBIT /?@DTA@TO@PTP@ONLY!/>

ERR9:	JSP T1,PTEXT
	SIXBIT /?#/
	MOVEI T6,DTON
	PUSHJ P,FN.EX
	MOVEI T1,ERR4B
	JRST PTEXT
ERR1:	SKIPA T2,ODEV	;OUTPUT UNAVAILABLE
ERR1A:	MOVE T2,DEVICE	;INPUT UNAVAILABLE
ERR1B:	MOVEM T2,TEX1A
	JSP T1,PTEXT	;PRINT NAME OF UNAVAILBLE DEVICE
	SIXBIT /?DEVICE@/
TEX1A:	0
	SIXBIT /@NOT@AVAILABLE!/
ERR3:	TRNE AUXFLG,DSKIN
	JRST DERR5	;ERR ON DSK
ERR3A:	MOVE 0,FILNAM	;FILE NAME NOT FOUND ERROR
	MOVEM 0,TEX3A
	HLRZ 0,FILEX
	SKIPE 0
	TLO 0,16		;PRECEED EXT WITH . IF EXT NOT NULL
	MOVEM 0,TEX3A+1
	JSP T1,PTEXT	;PRINT NAME OF FILE THAT CANNOT BE FOUND
	SIXBIT /FILE@NOT@FOUND--/
TEX3A:	0
	0
	SIXBIT /!/

ERR4:	SKIPN DTON
	JRST ERR4A
	TRNE AUXFLG,DSKOUT	;ERR ON DSK
	JRST DERR6
	JSP T1,PTEXT	;DIRECTORY FULL ERROR
	SIXBIT /?DIRECTORY@FULL!/
ERR4A:	TRNE AUXFLG,DSKOUT
	JRST ERR4C
	JSP T1,PTEXT
ERR4B:	SIXBIT /?ILLEGAL@FILE@NAME@!/
ERR4C:	JSP T1,PTEXT
	SIXBIT /?(0)@ILLEGAL@FILE@NAME!/
ERR6:	JUMPE T5,.+3	;BAD COMMAND ERROR
	SKIPE ESWTCH
	JRST MAINA1	;IGNORE EXTRA CAR RETS
ERR6A:	JSP T1,PTEXT
	SIXBIT /SYSTEM@ERROR!/
ERR10:	MOVEI T4,E10A
	JRST  E10B
E10A:	JSP T1,PTEXT2
	SIXBIT /@LINE@TOO@LONG!/
ERR5A:	JSP T1,PTEXT
	SIXBIT /?TOO@MANY@INPUT@DEVICES@!/
;FILE MANIPULATION COMMANDS TO N0N-DIRECTORY DEVICES COME HERE

ERR5:	JSP T1,PTEXT
	SIXBIT /?DISK@OR@DECTAPE@INPUT@REQUIRED!/
ERR2:	JSP T1,PTEXT
	SIXBIT /?INCORRECT@PROJECT-PROGRAMMER@NUMBER!/
ERR2A:	JSP T1,PTEXT
	SIXBIT /?ILLEGAL@PROTECTION!/
IFE BLOC0,<
ERR7A:	JSP T1,PTEXT
	SIXBIT Z?DECTAPE@I/O@ONLY@!Z>

CHECK1:	MOVE 0,DEVICE
	JUMPE 0,CHECK	;IGNORE IF NO INPUT
	CALLI 0,4	;SET AUXFLG TO SHOW INPUT TYPE
	TLNN 0,DSKBIT
	JUMPA .+6
	TRO AUXFLG,DSKIN
	EXCH  0,DEVICE
	MOVEM 0,ADSK
	EXCH  0,DEVICE
	JRST CHECK
	JUMPE 0,DEVER	;NON-EX. DEVICE
	TLNE 0,PTRBIT
	TRO AUXFLG,PPTIN
	TLNE 0,DTABIT
	TRO AUXFLG,DTAIN
	TLNE 0,MTABIT
	TRO AUXFLG, MTAIN
	TLNE CDRBIT
	TRO AUXFLG,CDRIN
	TLNE 0,TTYBIT
	TRO AUXFLG,TTYIN
CHECK:	SKIPE SSWTCH    ;_FLAG STILL ON?
	JRST ERR6A      ; YES ,COMMAND ERROR
	POPJ P,		; NO, RETURN 
;SUBR TO PRINT ERROR MESSAGES
;! MARKS THE END OF MESSAGE
;@ TURNS INTO SPACE
;SPACES (0 IN SIXBIT CODE) ARE IGNORED
;# IS A FLAG TO RETURN TO THE NEXT LOCATION

PTEXT:	RELEAS DIR,	;RELEASE DIRECTORY

	RELEAS TAPE,
	RELEAS OUT,	;LET GO OF BOTH OUTPUT AND
	RELEAS IN,	;INPUT DEVICES
	JSP T5,INICN1	;INITIALIZE THE TTY
PTEXT2:	HRLI T1,440600	;GET SET TO SCAN 6-BIT DATA
PTEXT1:	ILDB 0,T1	;GET CHAR OF ERR MESSAGE
	JUMPE 0,PTEXT1	;IGNORE 0
	CAIE 0,40	;CHANGE @ TO SPACE
	ADDI 0,40	;CONVERT TO 7-BIT
	CAIN 0,"!"	;!?
	JRST PIP2	;YES, END OF MESSAGE, APPEND CAR.RET., LF
	CAIN 0,"#"	;#?
	JRST 1(T1)	;YES, RETURN TO CALLING PROGRAM
	IDPB 0,TFO+1	;DEPOSIT CHAR IN OUTBUFFER
	JRST PTEXT1	;GET NEXT CHAR
PUTCON:	SOSG TFO+2
	OUTPUT CON,
	IDPB CHR,TFO+1
	POPJ P,

DTCLR:	TRNN AUXFLG,DSKOUT	;CLEAR DSK OR DTA DIR.
	JRST .+2
	JRST DSKZRO
	TRNN AUXFLG,DTAOUT	;MUST BE DTA
	JRST ERR5
	CALLI OUT,13
	POPJ P,
PRECOP:	PUSHJ	P,ININIT
	TRNN	AUXFLG,DTAIN
	JRST	.+3
	PUSHJ	P,DTCH2
DTCOPY:	PUSHJ	P,DTADI1
	TRNN	AUXFLG,DSKIN
	JRST	COPY1A
	PUSHJ	P,DSKDIR
COPY1A:	SETZM	ZCNT
	MOVEI	T2,6		;FILL 0 CHARS. IN DEST-FILE
	MOVE	T1,[POINT 6,DTON]	;NAME WITH X'S. THIS IS
XSS:	ILDB	0,T1		;THEN THE BASE FOR GENERATED
	SKIPN	0		;DESTINATION FILES FROM
	MOVEI	0,70		;NON-DIR. DEVICES IN /X
	DPB	0,T1
	SOSLE	T2		;DON'T YET KNOW IF ONE
	JRST	XSS		;OF THE INPUT DEV. WILL
	MOVE	0,DTON		;BE NON-DIR
	MOVEM	0,DTONSV
	MOVE	0,DTON+1
	MOVEM	0,DTONSV+1
COPY1:	PUSHJ   P,SR2		;SET INIT. COPYING MODE
	PUSHJ	P,LOOK		;GET A FILE TO COPY
	JRST	CAL6		;NO MORE
	PUSHJ	P,XDDSK		;GOT ONE, CHECK (XD) FROM DSK
	JRST	COPY1		;IN LIST, DON'T COPY
	TDNN	AUXFLG,[XWD MTAIN+PPTIN+CDRIN+TTYIN]	;OK, COPY FILE
	JRST	COPY6A
	PUSHJ	P,MTPTCR	;SET UP A DEST. FN.
	JRST	COPY6
COPY6A:	LOOKUP	IN,ZRF
	JRST	CAL5
COPY6:	PUSHJ	P,FILTYP
IFN WCH,<
	TRNN    AUXFLG,DTAIN+DTAOUT
	JRST    .+5
	HLRZ    0,ZRF+1
	CAIE    0,(SIXBIT /DMP/)
	CAIN    0,(SIXBIT /SAV/)
	JRST    COPY1>
	PUSHJ	P,COPY3
COPY6B:	MOVE	0,ZRF
	MOVEM	0,DTON
	HLLZ	0,ZRF+1
	HLLZM	0,DTON+1

;THIS CODE OPERATES AS FOLLOWS - FOR E+2, SET = 0
;TO START (ASSUMING /X)
;DSK TO DSK IF EDIT SWITCHES PUT E+2 = 0 IF NO EDITS TRANSFER
;	DATE, TIME, BITS 13-35
;DSK TO DTA FOR EDITS E+2 = 0, NO EDITS TRANSFER 24-35 FOR
;DATE, FOR"SAV" FILES TRANSLATE NO.  1K BLOCKS
;DTA TO DSK FOR NO EDITS XFER BITS 24-35, ELSE E+2 = 0
;DTA TO DTA ALWAYS XFER 18-23, NO EDITS XFER 24-35(DATE)

	SETZM	DTON+2
	LDB	0,DATE		;GET DSK/DTA DATE
	TDNN	FLAG,[XWD PFLG,LINE+TBMOD+NSMOD+SQMOD+SPMOD]
	TLNE	AUXFLG,CDRFLG
	JRST	COPY6C
	DPB	0,DATED		;DEPOSIT IF NO EDITS
	LDB	0,TIME
	TRC	AUXFLG,DSKIN+DSKOUT
	TRCN	AUXFLG,DSKIN+DSKOUT
	DPB	0,TIMED		;DSK TO DSK TIME
COPY6C: IFE WCH,<
	PUSHJ   P,OKBLKS	;SETUP 1K BLOCKS>
	ENTER	OUT,DTON	;GOT DATA, CREATE NEW FILE
	JRST	ERR4
	MOVE	0,ZRO
	MOVEM	0,SQNUM		;RESET SEQUENCE NO.
	TLO     FLAG,NEWFIL
	SETZM	TOTBRK		;CLEAR PAREN COUNTER
	TLNN	AUXFLG,CDRFLG+SBIN	;SPECIAL PROCESSING?
	TDNE	FLAG,[XWD PFLG+IFLG+IBFLG,LINE+BMOD+TBMOD+NSMOD+SQMOD+SPMOD]	
	JRST	PSCAN		;YES, DO IT
COPY5:	SOSGE	IBF+2		;INPUT BUFFER EMPTY?
	JRST	COPY4		;YES
	ILDB	CHR,IBF+1	;GET NEXT WORD AND
	PUSHJ	P,PUT		;OUTPUT IT
	JRST	COPY5
COPY4:	PUSHJ	P,COPY3		;GET NEXT FULL SOURCE BLOCK
	PUSHJ   P,OUTP		;OUTPUT PREV. BLOCK-DONT ALTER DATA
	AOS	OBF+2		;MAKE PUT HAPPY BECAUSE OF
	JRST	COPY5		;OUTPUT HERE.
COPY2:	POP	P,0
COPY2A:	CLOSE	IN,
	CLOSE	OUT,
	TLNN    AUXFLG,NSPROT
	JRST    COPY2B
	TRNN    AUXFLG,DSKOUT	;RENAME ALL OUTPUT FILES IF
	JRST    COPY2B		;NON-STANDARD PROTECTION
	MOVE    0,PROTS
	MOVEM   0,DTON+2
	RENAME  OUT,DTON
	JRST    DERR6
COPY2B:	PUSHJ	P,OUTP1
	JRST	COPY1		;GO GET NEXT FILE
CAL5:	AOS	ZCNT		;INPUT FILE READ PROT.
	JRST	COPY1
CAL6:	TLZ     AUXFLG,NSPROT
	SKIPN	ZCNT
	JRST	MAIN1
	MOVEI	0,70
	JRST	DSKZ5
COPY3:	PUSHJ   P,INP		;READ NEXT BLOCK
	TRZE    AUXFLG,READ1
	PUSHJ   P,TTYZ
	TRNE    IOS,20000	;END OF FILE? IOS HAS STATUS BITS
	JRST    COPY3A		;YES, CLOSE THINGS
	SKIPN   IBF+2		;EMPTY BLOCK?
	JRST    COPY3		;YES, SO READ ANOTHER BLOCK
	POPJ    P,
COPY3A:	TDNN    AUXFLG,[XWD MTAIN+CDRIN+TTYIN+PPTIN]
	JRST    COPY2
	HRRZ    0,(P)		;END ONLY IF EOF IS FIRST DATA IN FILE
	MOVEI   T1,COPY6B
	CAME    T1,0
	JRST    COPY2
	SETZM   CALFLG		;END OF INFO ON NON-DIR. DEVICE
	JRST    COPY1
;CREATE DESTINATION FILE NAME. RANGE IS ...001 TO ...999

MTPTCR:	AOS T1,NO.
	CAILE T1,^D999
	JRST MPC2
	SETZ T2
	IDIVI T1,12
	MOVEM T2,0	;0=LOW ORDER NO.
	SETZM T2
	IDIVI T1,12	;T2=MIDDLE NO., T1=TOP
	MOVE T4,[POINT 6,DTONSV,17]
	ADDI 0,20
	ADDI T1,20
	ADDI T2,20
	IDPB T1,T4
	IDPB T2,T4
	IDPB 0,T4
	MOVE 0,DTONSV	;FILNAM=DTON IS ONLY WAY TO IDENTIFY
	MOVEM 0,ZRF	;INPUT FILE
	MOVE 0,DTONSV+1
	MOVEM 0,ZRF+1
	POPJ P,
MPC2:	JSP T1,PTEXT
	SIXBIT Z?TERMINATE@/X.@@MAX.@OF@999@FILES@PROCESSED@!Z
SR2:	MOVE 0,SVIBF
	HLLM 0,IBF+1
	MOVE 0,SVOBF
	HLLM 0,OBF+1
	POPJ P,
TTYZ:	TRNN AUXFLG,TTYIN	;SEE IF FIRST CHAR. IS ^Z
	POPJ P,
	HRRZ T1,IBF+1		;ON TTY
	HLRZ 0,1(T1)
	CAIN 0,150000
	TRO IOS,20000
	POPJ P,
IFE	WCH,<
;DTA TO DTA MAINTAIN BITS 18-23 OF E+2 IF SET
;DSK TO DSK NO TRANSLATION (E+2)
;DSK TO DTA TRANSLATE E+3 (LHS) INTO E+2 (18-23)
;DTA TO DSK NO TRANSLATION (E+2)
;THIS ROUTINE ENSURES "SAVE" FILES MAINTAIN
;CORRECT DATA FOR LOADING.  FOR DSK INPUT
;A "SAVE" FILE IS ONE WITH THE EXTENSION
;"SAV". E+3 = (-[(200XN)+NO. WDS IN LAST BLOCK]
;IN LHS TRANSLATE TO NO. 1K BLOCKS NEEDED
;TO LOAD FILE - BEFORE IT IS EXPANDED IN CORE.

OKBLKS:	TRC	AUXFLG,DSKIN+DSKOUT	;DSK I/O
	TRCN	AUXFLG,DSKIN+DSKOUT
	POPJ	P,			;YES, EXIT
	TRC	AUXFLG,DTAIN+DTAOUT
	TRCE	AUXFLG,DTAIN+DTAOUT
	JRST	OKBLK1
	LDB	0,OKB			;DTA I/O - 1K BLKS
	DPB	0,OKBD			;DEPOSIT IN DTON
	POPJ	P,
OKBLK1:	TRC	AUXFLG,DTAIN+DSKOUT	;DTA TO DSK
	TRCN	AUXFLG,DTAIN+DSKOUT
	POPJ	P,
	TRC	AUXFLG,DSKIN+DTAOUT
	TRCE	AUXFLG,DSKIN+DTAOUT
	POPJ	P,
	HLRZ	0,ZRF+1			;DS TO DTA
	CAIE	0,(SIXBIT /SAV/)
	POPJ	P,
	HLRO	T1,ZRF+3
	MOVNS	T1			;WORD COUNT
	SETZM	T2
	IDIVI	T1,2000			;DIVIDE BY 1K CORE(OCTAL LOCS.)
	SKIPE	T2
	AOS	T1			;NO 1K BLKS
	SOS	T1			;N-1
	DPB	T1,OKBD
	POPJ    P,>
;ARE WE DOING (XD) FROM DSK? IF NOT, EXIT.
;SEE IF CURRENT FILE SELECTED IN ZRF IS IN THE
;LIST OF FILES NOT TO BE COPIED. (POPJ IF IT IS)

XDDSK:	TRC	FLAG,XFLG+DFLG
	TRCE	FLAG,XFLG+DFLG
	JRST	IPOP			;NOT (XD) SO COPY FILE
	TRNN	AUXFLG,DSKIN
	JRST	IPOP			;NOT DSKIN SO COPY FILE
	HRROI	T1,-12
XDDSK2:	MOVE	T2,ZRF			;GET FILE NAME
	SKIPN	T3,NAMTAB+12(T1)	;END OF TABLE ENTRIES?
	JRST	IPOP			;YES, EXIT
	CAME	T2,T3			;FN IS * OR MATCH?
	CAMN	T3,STAR
	SKIPA				;YES
	JRST	XDDSK1			;NO MATCH
	HLLZ	T2,ZRF+1
	SKIPN	T3,NAMTAB+24(T1)	;NO EXT MATCH WANTED
	POPJ	P,			;EXIT THEN
	CAME	T2,T3
	CAMN	T3,STAR
	POPJ	P,			;FN EX MATCH, NO COPY
XDDSK1:	AOJL	T1,XDDSK2		;TRY ANOTHER FOR MATCH
	JRST	IPOP			;SEARCHED TABLE, NO MATCH
;ROUTINE TO DELETE OR RENAME FILES ON DTA OR DSK

DTDELE:	MOVE	0,ODEV
	TRNE	FLAG,XFLG
	JRST    DELE1
	MOVEM	0,DEVICE
	MOVEM   0,DEVA
DELE1:	TRZ	AUXFLG,DTAIN+CDRIN+TTYIN+PPTIN+MTAIN+DSKIN
	PUSHJ	P,CHECK1	;RESET INPUT DEVICE DESCRP
	MOVEI   0,NAMTAB	;FOR /R
	HRLI    0,DTON
	BLT     0,NAMTAB+3
	TRNN    AUXFLG,DTAIN+DSKIN
	JRST    ERR5
	PUSHJ   P,FNSET		;SET UP CALFLG CORRECTLY
	TRNN	AUXFLG,DSKOUT
	JRST	DTD1		;OUTPUT NON-DSK
	TRNE	FLAG,XFLG
	JRST	DTD1		;(XD) TO DSK
	JRST	DSKDR
DTD1:	TRNN	FLAG,XFLG
	JRST	DELE4
	TRNN	AUXFLG,DSKIN	;(XD) FROM DSK?
	JRST	DELE4
	SETZM	NAMTAB		;COLLECT NAMES FOR DX, DSK SOURCE
	MOVE	T1,[XWD NAMTAB,NAMTAB+1]
	BLT	T1,NAMTAB+23
	MOVEI	T1,NAMTAB
	MOVEM	T1,LOCNAM
DTD4:	MOVE	0,FILNAM
	JUMPE	0,ERR3A		;FN=0 ILLEGAL
	MOVEM	0,(T1)
	MOVE	0,FILEX
	MOVEM	0,12(T1)
	MOVEI	T2,NAMTAB+11
	CAMN	T2,T1
	SOS	ESWTCH
	SKIPE	ESWTCH
	JRST	DTD2		;END OF NAME PROCESSING
	PUSHJ	P,DESCRP
	MOVE	T2,CALFLG
	TRNE	T2,NEWPP+NEWDEV
	JRST	ERR5A		;ERROR, NEW DEV OR# PP
	AOS	T1,LOCNAM
	JRST	DTD4
DTD2:	PUSHJ   P,ININIT
	MOVEI   T1,1
	JRST    DTD5
;ROUTINE TO DELETE OR RENAME FILES ON DTA

DELE4:	PUSHJ	P,DTCHECK	;GO GET DTA DIRECTORY
	PUSHJ	P,INFO
DELE3:	PUSHJ	P,LOOK		;GET FILE TO DELETE OR RENAME
	JRST	DELE5		;NO MORE FILES
	PUSHJ	P,INFO3
	MOVE	T1,DIRST	;GOT A MATCH - PROCESS IT
	TRNE	FLAG,RFLG	;AND IT IS AT (T5) IN (DTA) DIR
	JRST	DTRNAM
IFN WCH,<
	SKIPA	T2,T1
	ADDI	T2,4
	SKIPE	4(T2)
	JRST	.-2
	HRLS	T1
	ADDI	T1,4		;GET TO END OF NAMES
	MOVSS	T1		;BLOCK UP DIR
	BLT	T1,-1(T2)	;ZERO OUT LAST 4 WORDS
	SETZM	(T2)
	SETZM	1(T2)
	SETZM	2(T2)
	SETZM	3(T2)
	MOVE    T1,DIRST1
	MOVEM   T1,DIRST
	JRST	DELE3>
IFE WCH,<
	SETZM   (T1)		;DELETE FN
	SETZM   26(T1)		;EXT
	SUB     T1,DIRST1	;GET FILE "NUMBER"
	MOVEI   T3,1102
	MOVE    T2,[POINT 5,0]
	MOVE    0,DIRST1	;TO CALCULATE ADDRESS OF FIRST WORD
	SUBI    0,122		;OF BLOCK TABLE IN DIRECTORY
	ADD	T2,0
DELE2:	SOJLE   T3,DELE3	;LOOK AT 1101 BLOCKS
	ILDB    0,T2
	CAME    0,T1
	JRST    DELE2
	SETZM   0		;FREE THE BLOCKS OF THIS FILE
	DPB     0,T2
	JRST    DELE2>
DELE5:	MOVE	T1,IBF
	TRNE	FLAG,XFLG
	JRST	DTD6		;/X
IFN WCH,<
	USETO	OUT,1>
IFE WCH,<
	USETO	OUT,144>
	OUTPUT	OUT,(T1)	;OUTPUT DTA DIRECTORY
	RELEAS	CON,		;OUTPUT DELETE OR RENAME INFO TO TTY
	JRST	MAINB
DTRNAM:	PUSHJ   P,RENAME
	SETZM   DTON+2
	SETZM   DTON+3
	LOOKUP  OUT,DTON
	SKIPA			;NO FILE ALREADY OF DESTINATION NAME
	JRST    ERR9
	MOVE	0,DTON		;RENAME
	MOVEM	0,(T1)
	MOVE	0,DTON+1
IFE WCH,<
	HLLM    0,26(T1)>
IFN WCH,<
	HLLM	0,1(T1)>
	JRST	DELE3
DTD6:	MOVEI   T1,0
DTD5:	MOVE    0,STAR
	MOVEM	0,FILNAM	;FORCE COPY-ALL
	MOVEM	0,FILEX
	PUSHJ   P,FNSET
	TRNE    AUXFLG,DTAIN
	PUSHJ   P,DTCH1
	TLNE    FLAG,RIMFLG
	JRST    RIMTB
	JRST	DTCOPY(T1)

RENAME:	SKIPL	ESWTCH
	JRST	ERR6A		;ONLY 1 SOURCE FILE DESCRIPTOR ALLOWED
	HLRZ	0,NAMTAB+1
	CAIN	0,120000	;USE SPEC. EXTENSION, BUT IF
	HLRZ	0,ZRF+1		;EXT.=*, USE SOURCE EXTENSION
	HRLM	0,DTON+1
	MOVE	T2,NAMTAB	;USE SPEC. FN, BUT IF
	CAMN    T2,STAR		;FN=* OR 0, USE SOURCE FILENAME
	MOVE	T2,ZRF
	MOVEM	T2,DTON
	POPJ	P,
;NO-MORE-FN.EX-TO-HANDLE-EXIT IS POPJ
;PREPARE ZRF FOR A "LOOKUP" ON THE NEXT REQUESTED FILE.

LOOK9:	MOVEM   T4,CALFLG
LOOK:	MOVE	T3,CALFLG
	TRNE	T3,FNEX		;DOES FILNAM, FILEX CONTAIN
	JRST	LOOK6		;A FILE TO THINK ABOUT? YES
	PUSHJ	P,LOOKA		;GET ONE (NOTE: DEVICE MAY ALTER)
	POPJ	P,		;NONE
	MOVE    T3,CALFLG
LOOK6:	MOVE    T2,FILEX
	SKIPN   T1,FILNAM
	SKIPE   T2,FILEX
	SKIPA			;EITHER FN OR EX N.E.0
	JRST    LOOK7C		;FN.EX=0, ONE FILE COPY
	CAME    T1,STAR
	CAMN    T2,STAR
	JRST    LOOK7A		;FN OR EX=*, MANY FILES 
	TRNN    AUXFLG,DTAIN+DSKIN
	JRST    ERR3A		;FN.EX ON NON-DIR. DEV.
	JUMPE   T1,ERR3A	;HERE FOR 0.EX, FN.EX OR FN.0.  0.EX ILLEGAL
LOOK7B:	TRZ     T3,FNEX		;IF HERE, ONLY ONE FILE WAS ENTAILED IN REQUEST.
	MOVEM	T3,CALFLG	;CLEAR MATCH FLAGS
	TRNN	AUXFLG,DTAIN+DSKIN
	JRST	LOOK4		;GOT A FILE TO HANDLE
LOOK8:	PUSHJ	P,PICUP
	JRST	LOOK2		;WE GOT A FILE, DOES IT MATCH?
	MOVE	T4,CALFLG	;NO FILES LEFT, SHOULD THERE BE?
	TRZE	T4,FNEX		;SEE IF A PARTIC. FILE WAS REQUESTED?
	JRST	LOOK9		;NO
	TRC     FLAG,XFLG+DFLG	;(XD) (ON DTA INPUT) ... DON'T FAIL IF
	TRCN    FLAG,XFLG+DFLG	;A FN.EX IS!NOT AVAILABLE TO BE DELETED!
	JRST    LOOK
	JRST	ERR3A		;YES, ERROR
LOOK2:	MOVE	T4,CALFLG
	TRNN	T4,MATFN	;SHOULD FILENAMES MATCH
	JRST	LOOK3		;NO
	MOVE	T1,FILNAM	;YES
	CAME	T1,ZRF
	JRST	LOOK8		;NO MATCH
LOOK3:	TRNN	T4,MATEX	;SHOULD EXTENSIONS MATCH
	JRST    LOOK5		;NO
	MOVE	T1,FILEX	;YES
	CAME	T1,ZRF+1
	JRST	LOOK8		;NO MATCH
LOOK5:	TRNN	AUXFLG,DSKIN
	JRST	LOOK4
IFN DISK30,<
	LDB     T1,UFDIN+1	;PICKUP P-P# IN DIRECTORY
	HRRZM   T1,T2
	CAME    T2,MASK		;COMPARE WITH OWN P-P#
	JRST    LOOK8		;NO MATCH>
LOOK4:	TRO     AUXFLG,READ1	;READY FOR FIRST READ
	JRST	IPOP		;MATCH OR NO CARES
LOOK7A:	SKIPE   T2
	CAMN    T2,STAR
	CAME    T1,STAR
	SKIPA
	JRST    LOOK1		;*.* ALWAYS O.K. AND *
	TRNN    AUXFLG,DSKIN+DTAIN
	JRST    ERR3A		;*.A OR A.* ON NON-DIR. DEV.
	JRST    LOOK8
LOOK7C:	TRNE    AUXFLG,DSKIN+DTAIN
	JRST    ERR3A		;0.0 ON DIR. DEV.
	SETZM   ZRF
	SETZM   ZRF+1
	JRST    LOOK7B		;0.0 ON NON-DIR. DEV.
LOOK1:	TRNE    AUXFLG,DTAIN+DSKIN
	JRST    LOOK8
	SETZM   ZRF
	SETZM   ZRF+1
	JRST    LOOK4
;FILNAM, FILEX CONTAIN THE FILE NAME. EXT TO BE
;MATCHED WITH DIR. NAMES. PUT SUGGESTED FILE
;NAME EXT IN ZRF, ZRF+1 AND #P-P IN ZRF+3

PICUP:	TRNN	AUXFLG,DSKIN	;DSK ROUTINE
	JRST	PICUP2		;N0
	SOSLE	UFDIN+2		;YES
	JRST	.+3
PICUP1:	PUSHJ	P,UIN
	JRST	IPOP		;EOF ON DSK
	ILDB	0,UFDIN+1
	JUMPE	0,PICUP1
	MOVEM	0,ZRF
	MOVE    0,FNPPN
	MOVEM   0,ZRF+3		;SET DSK #P-P
	SOS	UFDIN+2
	ILDB	0,UFDIN+1
	HLLZM	0,ZRF+1
	IBP     UFDIN+1		;INCREMENT POINTER TO GET PROJ,PROG #
	IBP     UFDIN+1
	IBP    UFDIN+1
	POPJ    P,
PICUP2:				;DTA ROUTINE
IFN WCH,<
	MOVE    T5,DIRST	;DIRST=LOC 4 FIRST TIME THRU
	ADDI    T5,4		;CALCULATE FIRST/NEXT FILENAME
	MOVEM   T5,DIRST
	MOVE    0,(T5)
	JUMPE   0,IPOP		;NO MORE FILENAMES IN DIRECTORY
	MOVEM   0,ZRF
	MOVE    0,1(T5)>
IFE WCH,<
	MOVE    T3,DIRST1	;SETUP TO CHECK ALL FILENAME SLOTS
	ADDI    T3,26		;IN DIRECTORY
	MOVE    T5,DIRST
PICUP4:	ADDI    T5,1
	CAMLE   T5,T3
	JRST    IPOP		;END OF FILE NAMES
	MOVEM   T5,DIRST
	MOVE    0,(T5)
	JUMPE   0,PICUP4
	MOVEM   0,ZRF
	MOVE    0,26(T5)>
	HLLZM	0,ZRF+1
	POPJ	P,
;READ DTA DIR. AND PREPARE T5 TO PICK UP FIRST ENTRY.

DTADIR:	PUSHJ	P,DTCH2
DTADI1:	MOVEI	T3,DBUF
	HRL	T3,T5
IFN WCH,<
	MOVNS	T2
	BLT	T3,DBUF+176(T2)
	SETZM	DBUF+177(T2)
	MOVEI	T5,DBUF-4>
IFE WCH,<
	BLT	T3,DBUF+176
	MOVEI	T5,DBUF+123-1>
	MOVEM	T5,DIRST	;T5 POINTS TO FILNAME JUST HANDLED
	MOVEM   T5,DIRST1	;TO RESTORE DIRST
	POPJ	P,		;(IE NONE BUT NEXT WILL BE FIRST)

;ROUTINE TO OUTPUT FILENAMES THAT WERE DELETED OR RENAMED

INFO:	MOVE	T2,JOBFF	;SETUP TTY FOR OUTPUT
	MOVEI	T1,LBUF
	MOVEM	T1,JOBFF
	INIT	CON,1
	SIXBIT	/TTY/
	XWD	TFO,0
	JRST	4,.
	OUTBUF	CON,1
	MOVEM	T2,JOBFF
	OUTPUT	CON,
	TRNN	FLAG,DFLG
	JRST	INFO1
;	*******PATCH   SUDS PRINTS THIS INSTEAD****
;	JSP	T1,PTEXT2
;	SIXBIT	/PROGRAMS@UNSAVED#/
	JRST	INFO2
INFO1:	JSP	T1,PTEXT2
	SIXBIT	/FILES@RENAMED#/
INFO2:	MOVEI	CHR,15		;OUTPUT CR/LF
	PUSHJ	P,PUTCON
	MOVEI	CHR,12
	PUSHJ	P,PUTCON
	POPJ	P,
INFO3:	MOVE	0,ZRF
	PUSHJ	P,INFO5		;OUTPUT FILENAME
	MOVE	0,ZRF+1
	JUMPE	0,INFO4
	MOVEI	CHR,56
	PUSHJ	P,PUTCON	;OUTPUT PERIOD
	PUSHJ	P,INFO5		;OUTPUT EXTENSION
INFO4:	PUSHJ	P,INFO2
	POPJ	P,		;RETURN
INFO5:	MOVE	T2,[POINT 6,0]
	ILDB	CHR,T2
	JUMPE	CHR,INFO6
	ADDI	CHR,40
	PUSHJ	P,PUTCON
	TLNN	T2,770000
INFO6:	POPJ	P,
	JRST	INFO5+1
;/X OR /D. FIND OUT DETAILS OF FILE NAME AND
;EXTENSION (0 FN.EX=*.*) AND ANY CHANGE IN
;SOURCE DEV. SET BITS IN CALFLG.

FNSET:	MOVEI	T3,FNEX
	MOVE	0,STAR		;*
	CAME	0,FILNAM
	SKIPN	FILNAM
	SKIPA			;FILENAME = * OR 0
	TRO	T3,MATFN	;FILENAME MUST BE MATCHED
	SKIPN   FILEX
	TDNN    AUXFLG,[XWD MTAIN+CDRIN+PPTIN+TTYIN]
	CAMN    0,FILEX
	SKIPA
	TRO     T3,MATEX	;FILE EXTENSION MUST BE MATCHED
	TRNN    AUXFLG,DSKIN
	JRST    FNSET1
	SKIPN	T2,PP
	JRST    FNSET2		;IF #P-P=0 IT IS COUNTED AS UNCHANGED
	CAME	T2,FNPPN
	TRO	T3,NEWPP	;CHANGE IN # P-P
	JRST    FNSET1
FNSET2:	MOVE    T2,FNPPN	;IF P-P#=0, SET TO PREVIOUS VALUE
	MOVEM   T2,PP
FNSET1:	MOVE	T2,DEVICE
	CAME	T2,DEVA
	TRO	T3,NEWDEV	;CHANGE IN SOURCE DEV.
	MOVEM	T2,DEVA		;SET DEVA=DEVICE
	MOVEM	T3,CALFLG	;CALFLG SET
	POPJ	P,
;POPJ EXIT IF END OF COMMAND STRING, OTHERWISE RESET
;POINTER TO START OF DIRECTORY, READING IN NEW DIR.
;IF DEV OR #P-P CHANGED (EXIT IPOP)
;IF DIR. IS ON DSK RESET BY REINIT.

LOOKA:	SKIPE	T4,ESWTCH		;MORE C.S.?
	POPJ	P,			;NO
	PUSHJ	P,DESCRP		;YES, GET NEXT FN.EX
	PUSHJ	P,INLOOK		;CHECK FOR MTA REQUESTS, MODE
	PUSHJ   P,M4
	HRRM    T4,ININI1
	MOVE    T3,CALFLG
	RELEAS  DIR,
	TDNN    AUXFLG,[XWD MTAIN+CDRIN+PPTIN+TTYIN]	;NON-DIR DEVICE?
	JRST	LOOKF
	TRNE	T3,MATEX+MATFN		;YES, NO FN EX BUT *.* OR * ALLOWED
	JRST	ERR6A
LOOKF:	TRNN	FLAG,DFLG		;FOR DELETE, ONE SOURCE FILE
	JRST	LOOKB			;...
	TRNE	T3,NEWDEV+NEWPP		;ONLY IS PERMITTED
	JRST	ERR5A
LOOKB:	TRNN	T3,NEWDEV+NEWPP		;PREPARE TO LOOK FOR NEW FILE
	JRST	LOOKC			;NAME AT HEAD OF DIRECTORY
	PUSHJ   P,ININIT
	TRNE	AUXFLG,DTAIN+DSKIN
	JRST    LOOKE
	JRST    IPOP
LOOKE:	TRNN	AUXFLG,DTAIN
	JRST	LOOKD
	PUSHJ	P,DTADIR
LOOKC:	TRNE    AUXFLG,DSKIN
	JRST    LOOKD
	MOVE	T5,DIRST1
	MOVEM   T5,DIRST
	JRST	IPOP
LOOKD:	PUSHJ   P,DSKDIR
	SETZM	UFDIN+2			;DSK DIR BUF EMPTY
	JRST	IPOP
;ROUTINE TO LIST DTA OR DSK DIRECTORIES

DTPDIR:	ENTER   OUT,DTON
	JRST    ERR4
	TRNN    AUXFLG,FFLG
	JRST    PDIR1A			;PROCEED IF NOT "SHORT" LISTING
	SKIPE   DEVICE
	JRST    PDIR1A
	HRRZI   0,(SIXBIT /DSK/)	;ASSUME DSK IF NO DEVICE GIVEN
	HRLZM   0,DEVICE
	TRO     AUXFLG,DSKIN		;SET DSK INPUT
PDIR1A:	TRNN    AUXFLG,DSKIN
	JRST    .+2
	JRST    DSKLST			;YES, GO AND TRY
	TRNN    AUXFLG,DTAIN
	JRST    ERR5
	PUSHJ   P,DTCHECK		;CHECK FOR DTA INPUT-MUST BE DECTAPE
	PUSHJ   P,CRLF			;PRINT NO. OF FREE BLOCKS LEFT
IFN WCH,<
	MOVE    T1,IBF
	HLRZ    DOUT,1(T1)		;GET FREE BLOCK POINTER
	MOVNS   DOUT
	ADDI    DOUT,1101		;GET NO. OF FREE BLOCKS LESS FREE BLOCK NO.
	PUSHJ   P,OUTDEC		;PRINT RESULT>
IFE WCH,<
	SETZM   DOUT
	MOVEI   T4,1102
	MOVE    T1,[POINT 5,0]
	HRRZ    T5,IBF
	ADD     T1,T5
	ADDI    T1,1			;POINTER
PDIR8:	SOJLE   T4,PDIR1
	ILDB    T3,T1			;CALCULATE NO. OF FREE BLOCKS
	JUMPN   T3,PDIR8
	AOJA    DOUT,PDIR8		;COUNT NO. WITH ZERO IN
PDIR1:	PUSHJ   P,OUTDEC		;PRINT RESULT>
	MOVE    0,[POINT 6,PDIR7]
	MOVEI   T2,^D18
	PUSHJ   P,PDIR2			;PRINT "FREE BLOCKS LEFT" MESSAGE
	PUSHJ   P,CRLF
	PUSHJ   P,DTCH1			;FIX T5

PDIR4:
IFE WCH,<
	SKIPN   123(T5)		;NULL (=0) FILE NAME?
	JRST    PDIR6		;YES SO LOOK FOR ANOTHER>
IFN WCH,<
	SKIPN   (T5)		;NULL (=0) FILE NAME?
	JRST    MAIN1		;YES, SO END OF DIR.>
	MOVEI   T2,6		;TRANSMIT UP TO 6 CHARACTERS
	MOVSI   0,440600+T5	;SET UP SOURCE BYTE POINTER
IFE WCH,<
	HRRI    0,123>
	SETZM   T4
	PUSHJ   P,PDIR2		;OUTPUT 6-BIT DATA AND INCR DIRECTORY PTR
IFE WCH,<
	HLLZ    CHR,151(T5)>
IFN WCH,<
	HLLZ    CHR,(T5)>
	MOVSI   0,440600+T5	;SET BYTE POINTER
IFE WCH,<
	HRRI    0,151>
	MOVEI   T2,4		;PRINT UP TO 4 CHRS. (PERIOD+3*EXT)
	JUMPN	CHR,.+3	;EXTENSION NULL
	PUSHJ	P,PDIR2A+1
	JRST	.+3
	MOVEI   CHR,"."-240	;NO, SO PRINT A PERIOD
PDIR3:PUSHJ	P,PDIR2A	;OUTPT 6 BIT OR INCR T5
IFE WCH,<
	MOVEI	CHR,40		;OUTPUT 2 SPACES
	PUSHJ	P,PUT
	PUSHJ	P,PUT
	SETZM	DOUT		;CALCULATE NBR OF BLOCKS PER FILE
	MOVEI	T4,1101
	MOVE	0,[POINT 5,0]
	HRRZ	T2,IBF
	ADD	0,T2
	ADDI	0,1
	HRRZ	T7,T5
	SUBI	T7,(T2)
	ILDB	T6,0		;LOAD CONTENTS OF S.A.T. BLOCK
	CAMN	T6,T7		;COMPARE WITH FILE SLOT NBR
	ADDI	DOUT,1		;ADD 1 TO COUNT IF EQUAL
	SOJG	T4,.-3
	PUSHJ	P,OUTDEC	;OUTPUT NBR OF BLOCKS PER FILE
	MOVEI	CHR,11>
IFN WCH,<
	AOS     T5		;STEP DIR. POINTER
	MOVEI   CHR,11
	PUSHJ   P,PUT		;OUTPUT A TAB
	CAIG    T4,7>
	PUSHJ   P,PUT
IFE WCH,<
	MOVE    0,151(T5)	;GET ENTRY DATE>
IFN WCH,<
	MOVE    0,-1(T5)	;GET ENTRY DATE>
	ANDI    0,7777		;LEFT BITS ARE IRRELEVENT
	PUSHJ   P,DATOUT	;OUTPUT THE DATE
	PUSHJ   P,CRLF		;GIVE CAR. RET., LINE FEED
IFN WCH,<
	AOJA    T5,PDIR4	;PROCESS NEXT ENTRY>
IFE WCH,<
PDIR6:	HRRZ    T1,IBF		;PROCESS NEXT ENTRY
	SUBM    T5,T1
	CAIL    T1,26		;FILE "NUMBER" OK?
	JRST    MAIN1		;NO, END OF ENTRIES
	AOJA    T5,PDIR4>
CRLF:	MOVEI   CHR,215		;OUTPUT CAR. RET.
	PUSHJ   P,PUT
	MOVEI   CHR,212		;LINE FEED
	JRST    PUT
PDIR2:	ILDB    CHR,0		;ROUTINE TO OUTPUT 6-BIT DATA
	TRNN    0,-1		;PRINT SPACES WHEN PRINTING THE FREE BLOCKS
PDIR2A:	JUMPE   CHR,PDIR21	;TERMINATE ON SPACE
	ADDI    CHR,240		;CONVERT TO 7 BIT
	PUSHJ   P,PUT		;OUTPUT CHARACTER
	ADDI    T4,1
	SOJG    T2,PDIR2	;COUNT DOWN MAX-CHARS COUNTER
IFN WCH,<
PDIR21:	AOJA    T5,CPOPJ	;STEP AND CONTINUE>
IFE WCH,<
PDIR21:	POPJ    P,		;CONTINUE>
PDIR7:	SIXBIT /. FREE BLOCKS LEFT/
;OUTPUT THE DATE FOUND IN AC 0.

DATOUT:	MOVEI T2,PUT
	IDIVI 0,^D31
	MOVEI T3,1(1)
	IDIVI 0,^D12
	MOVE DOUT,T3		;DOUT=DAY
	PUSHJ P,OUTDC1		;PRINT DAY
	PUSHJ P,DATO2		;PRINT -MONTH-
	MOVE DOUT,0
	ADDI DOUT,^D64		;DOUT=YEAR
OUTDC1:	SKIPA DOUT+1,TWL	;RADIX 10
OUTOCT:	MOVEI DOUT+1,10
PRNUMA:	HRRZM DOUT+1,T4
	MOVEI CHR,"0"
	CAMGE DOUT,DOUT+1	;PRINT AT LEAST 2 DIGITS
	PUSHJ P,(T2)
PRN:	IDIVI DOUT,(T4)		;DIVIDE BY RADIX
	HRLM DOUT+1,(P)		;SAVE NO. FOR PRINT
	SKIPE DOUT		;ENUF DIGITS?
	PUSHJ P,PRN		;NO, GET MORE
	HLRZ CHR,(P)		;YES, GET LEFTMOST
	ADDI CHR,60		;CONVERT TO ASCII
	JRST (T2)

OUTDEC:	MOVEI T2,PUT
	JRST OUTDC1

DATO2:	MOVEI T4,5
	MOVE T6,MNPT
	ADDM 1,T6
	ILDB CHR,T6
	PUSHJ P,(T2)
	SOJG T4,.-2
	POPJ P,
;READ DTA DIRECTORY AND INITIALIZE DIRST AND DIRST1

DTCHECK:PUSHJ P,ININIT	;INITIALIZE INPUT DEVICE
DTCH2:
IFN WCH,<
	USETI IN,1	;GET DTA DIR>
IFE WCH,<
	USETI IN,144	;GET DTA DIR>
	PUSHJ P,INP
IFN WCH,<
DTCH1:	MOVE T5,IBF
	HRRZ T2,1(T5)
	ADDI T5,1(T2)	;GET ADD. OF FIRST ENTRY
	MOVE 0,T5
	SUBI 0,4>
IFE WCH,<
DTCH1:	HRRZ T5,IBF
	MOVE 0,T5
	ADDI 0,123
	ADDI T5,1	;COMPUTE ADD. OF DIR. START>
	MOVEM 0,DIRST
	MOVEM 0,DIRST1	;TO RESTORE DIRST
	POPJ P,

OUTCHK:	SETZB T3,TLBRKT	;COUNT <> ON THIS LINE, CLEAR THINGS
	MOVE T1,OPTRA	;BYTE POINTER FOR READING OUT THE LINE
OUTCH2:	CAMN T1,OPTR	;LINE DONE?
	JRST OUTCH3	;YES, SO DECIDE WHETHER TO PRINT
	ILDB T2,T1	;GET CHAR
	CAIN T2,"<"	;LEFT BRACKET?
	AOS TLBRKT	;YES, SO INCREMENT BRACKET COUNT
	CAIN T2,">"	;RIGHT BRACKET?
	SOSL TLBRKT	;YES, SUBTRACT BRACKET COUNT, GONE NEG?
	JRST OUTCH2	;NO, SO DO NEXT CHAR
	AOJA T3,OUTCH2	;YES, SO FLAG COUNT GONE NEG.

OUTCH3:	SKIPN T2,TLBRKT	;BRACKET COUNT OFF THIS LINE?
	JUMPE T3,CPOPJ	;NO, WENT NEG.?
	ADDM T2,TOTBRK	;YES, SO ADD INTO CUMULATIVE COUNT
	MOVEI CHR,"-"	;PRINT MINUS FOR NEG TOTAL
	SKIPGE TOTBRK
	PUSHJ P,PUT
	MOVM DOUT,TOTBRK;PRINT MAGNITUDE OF TOTAL
	PUSHJ P,OUTDEC
	MOVEI CHR,11	;FOLLOW WITH TAB
	PUSHJ P,PUT
	JRST OUTCH1	;AND PRINT THE LINE
FILTYP:	TDNE FLAG,[XWD IFLG+IBFLG,BMOD]
	POPJ P,
	TLZ AUXFLG,SBIN
	HLRZ 0,ZRF+1
	CAIE 0,(SIXBIT /DMP/)
	CAIN 0,(SIXBIT /SAV/)
	JRST FIL3
	CAIE 0,(SIXBIT /CHN/)
	CAIN 0,(SIXBIT /REL/)
	JRST FIL3
	TRNN FLAG,XFLG		;DO NORMAL PROCESSING ON ALL
	JRST FIL2		;BUT DMP ETC FILES IF NOT /X
	TLNN AUXFLG,CDRFLG
	TDNE FLAG,[XWD PFLG+IFLG+IBFLG,LINE+BMOD+TBMOD+NSMOD+SQMOD+SPMOD]
	POPJ P,			;NO SIGNIFICANT SWITCHES
FIL1:	HRLZI 0,004400		;FORCE 36-BIT.
	HLLM 0,IBF+1
	HLLM 0,OBF+1
	POPJ P,			;CHANGE TO FORCED BINARY
FIL3:	TLO AUXFLG,SBIN
	TRNE FLAG,XFLG
	JRST FIL1
	TLON AUXFLG,FRSTIN	;NOT /X TEST FURTHER
	JRST FIL4		;IS THIS FIRST SOURCE, YES
	TLOE AUXFLG,RSDCFL	;NOT FIRST, WAS PREVIOS FILE RSCD?
	JRST	FIL5		;YES, NO CHANGE UNLESS DEVICE HAS CHANGED
	OUTPUT OUT,		;NO CHANGE TO 36-BIT
	MOVE 0,OBF+2		;CURRENTLY 7-BIT I/O, MUST CHANGE TO 36-BIT
	SETZM T1		;OUTPUT CURRENT BUFFER
	IDIVI 0,5		;DIVIDE OBF+2 BY 5 (CHAR. COUNT)
	MOVEM 0,OBF+2
	JRST FIL1
FIL2:	TLON AUXFLG,FRSTIN	;NOT A RSCD FILE
	POPJ P,			;IS IT FIRST SOURCE, YES
	TLZN AUXFLG,RSDCFL	;NO, WAS PREV. FILE RSCD?
	POPJ P,			;NO, NO CHANGE
	OUTPUT OUT,		;YES, CHANGE 36-BIT TO 7-BIT
	MOVEI 0,5
	IMULM 0,OBF+2
	MOVE 0,SVIBF		;RESTORE 7-BIT
	HLLM 0,IBF+1
	MOVE 0,SVOBF
	HLLM 0,OBF+1
	POPJ P,
FIL4:	TLO AUXFLG,RSDCFL
	JRST FIL1
FIL5:	MOVE T1,CALFLG
	TRNN T1,NEWDEV		;SOURCE DEV. CHANGED?
	POPJ P,
	HRLZI 0,004400		;NEW DEVICE, SET 36-BIT INPUT
	HLLM 0,IBF+1
	POPJ P,			;OUTPUT ALREADY SET
IFE BLOC0,<
IFE WCH,<;THIS CODE COPIES BLOCK 0,1,2 ONLY. I/O MUST BE DECTAPE.>
IFN WCH,<;THIS CODE COPIES BLOCK 0 ONLY. I/O MUST BE DECTAPE.>
;MODE SELECTED MUST BE BIT 100, 20 AND NOT DUMP MODE (134).

BLOCK0:	TRC AUXFLG,DTAIN+DTAOUT
	TRCE AUXFLG,DTAIN+DTAOUT;FORCE DTA I/O
	JRST ERR7A
	MOVE 0,ODEV
	MOVEM 0,BLOUT		;SET UP OUTPUT
	MOVE 0,DEVICE
	MOVEM 0,BLIN		;SETUP INPUT
	INIT OUT,134
BLOUT:	0
	XWD OBF,0
	JRST ERR1		;UNAVAILABLE
	OUTBUF OUT,1
	OUTPUT OUT,
	INIT IN,134
BLIN:	0
	XWD 0,IBF
	JRST ERR1A
	INBUF IN,1
	SETZB T1,BL0CNT
BL4:	CAIL T1,3
	JRST BL3
	USETI IN,(T1)
	INPUT IN,		;READ
	STATUS IN,IOS
	TRNN IOS,740000		;ANY ERRORS
	JRST BL1		;NO
	MOVE T1,BLIN
	MOVEM T1,BL2
	JSP T5,INICN2
	PUSHJ P,QUEST
	JSP T1,PTEXT2
	SIXBIT /INPUT@DEVICE@/
BL2:	0
	SIXBIT /:@#/		;# IS RTEURN HERE REQUEST
	MOVE T2,AUXFLG		;DECTAPE FOR ERROR MESSAGE
	ANDI T2,DTAIN
	PUSHJ P,IOERR		;PRINT ERROR TYPE
BL1:	MOVE T1,BL0CNT
	HRLZ T5,IBF+1
	HRR T5,OBF+1
	HRRZ T4,OBF+1
	ADDI T4,177
	BLT T5,(T4)		;SHIFT DATA TO OUTPUT BUFFER
	USETO OUT,(T1)
	OUTPUT OUT,		;WRITE BLOCK
	PUSHJ P, OUTP1		;CHECK ERRORS
IFE WCH,<
	AOS T1,BL0CNT
	JRST BL4>
BL3:	RELEASE OUT,		;IF ANY, PDL IS RESET
	JRST PIP2>

IFN BLOC0,<
BLOCK0:	JSP T1,PTEXT
	SIXBIT /?NO@BLOCK@0@COPY!/>
;TEST TO SEE IF MORE THAN ONE OF THE LOWEST EIGHT MTA FLAGS
;HAVE BEEN SELECTED. IF SO ERROR. OTHERWISE, IMPLEMENT
;REQUEST.  T1, T3, T6 SET AT ENTRY.

MT1:	HRROI T4,-1
	MOVEI 0,8
	HRRZ T2,T1		;T1 CONTAINS REQUEST

MTTS:	ROT T2,-1
	JUMPGE T2,MTTS1
	AOJLE T4,MTTS1
	JRST MTR1

MTTS1:	SOJG 0,MTTS
	TRNN T1,MTAFLG+MTBFLG+MTWFLG+MTTFLG+MTFFLG+MTUFLG+MTDFLG+MTPFLG
	JRST MTC1
	PUSHJ P,(T6)		;THERE IS A  REQUEST
	TRNE T1,MTUFLG
	JRST UNLOAD
	TRNE T1,MTWFLG
	JRST REWIND
	TRNE T1,MTFFLG
	JRST MARKEF
	TRNE T1,MTTFLG
	JRST SLEOT
	TRNE T1,MTBFLG+MTPFLG	;MULTIPLE REQUEATS ALLOWED
	JRST BSPF
	TRNE T1,MTAFLG+MTDFLG	;MULTIPLE REQUESTS ALLOWED
	JRST ADVF

;T1=AUX,AUXOUT. T3=AB,ABOUT.  T6=INIMTA,INOMTA.

MTCONT:	RELEAS TAPE,
	CAIE T6,INOMTA		;OUTPUT TAPE?
	POPJ P,
	TRNN T1,MTUFLG		;UNLOAD?
	SKIPE NSWTCH	 	;IS THERE AN INPUT DEVICE?
	JRST	PIP2		;NO, END
	POPJ P,

MTC1:	MOVEI T4,1		;ASCII LINE STANDARD
	TRC T1,MT2FLG+MT8FLG
	TRCN T1,MT2FLG+MT8FLG
	JRST MTR1
	TRC T1,MT2FLG+MT5FLG
	TRCN T1,MT2FLG+MT5FLG
	JRST MTR1
	TRC T1,MT8FLG+MT5FLG
	TRCN T1,MT8FLG+MT5FLG
	JRST MTR1
	TRNE T1,MT2FLG
	TRO T4,DENS2
	TRNE T1,MT5FLG
	TRO T4,DENS5
	TRNE T1,MT8FLG
	TRO T4,DENS8
	TRNE T1,MTEFLG
	TRO T4,PARE		;EVEN PARITY
	POPJ P,

;REWIND AND UNLOAD

UNLOAD:	MTAPE TAPE,11
	MTAPE TAPE,0
	JRST MTCONT

;REWIND ONLY

REWIND: MTAPE TAPE,1
	MTAPE TAPE,0
	JRST MTCONT

;MARK END OF FILE

MARKEF:	MOVE T5,ODEV
	MOVE 0,MTANAM
	MOVEM 0,ODEV
	MTAPE TAPE,3
	STATUS TAPE,IOS
	PUSHJ P,OUTP3
	SETSTS TAPE,(IOS)
	MOVEM T5,ODEV
	JRST MTCONT

;SKIP TO LOGICAL END OF TAPE.

SLEOT:	MTAPE TAPE,10
	MTAPE TAPE,0
	JRST MTCONT
;BACKSPACE MTA 1 FILE, T3=AB OR ABOUT

BSPF:	HRRZ T3,T3	;T3=NO. OF BSPF OR BSPR
	ADDI	T3,1
BSPF2:	MTAPE TAPE,0	;WAIT
	STATUS TAPE,IOS
	TRNN IOS,LDP
	JRST BSPF3	;NO LDP
	JSP T1,PTEXT	;LOAD POINT ERROR
	SIXBIT /?LOAD@POINT@BEFORE@END@OF@(MB)@OR@(MP)@REQUEST!/
BSPF3:	MOVEI T5,7	;BSPR
	TRNN T1,MTPFLG
	MOVEI T5,17	;BSPF
	MTAPE TAPE,(T5)
	SOJG T3,BSPF2
	MTAPE TAPE,0
	STATUS TAPE,IOS
	TRNN T1,MTBFLG
	JRST MTCONT
	TRNN IOS,LDP	;IF AT LOAD POINT
	MTAPE TAPE,16	;(MOVE FWD. OVER EOF)
	JRST MTCONT	;DON'T SKIP A RECORD

;ADVANCE MTA 1 FILE, T3=AB OR ABOUT

ADVF:	HLRZ T3,T3	;T3=NO. FILES (OR REC) TO ADVANCE
	ADDI	T3,1
ADVF2:	MOVEI T5,6
	TRNN T1,MTDFLG	;ADVR OR
	MOVEI T5,16	;ADVF
	MTAPE TAPE,(T5)
	SOJG T3,ADVF2
	MTAPE TAPE,0	;WAIT...
	STATUS TAPE,IOS
	TRZE IOS,20000
	SETSTS TAPE,(IOS)
	JRST MTCONT

IPOP:	AOS (P)
	POPJ P,		;EXIT TO RETURN+1


INOMTA:	SKIPA T2,ODEV
INIMTA:	MOVE T2,DEVICE
	MOVEM T2,MTANAM
	MOVE 0,CALFLG
	TRNN 0,NEWDEV
	JRST INMTA
	PUSHJ P,MTC1
	HRRM T4,INMTA
INMTA:	INIT TAPE,0
MTANAM:	0
	0
	JRST ERR1B
	POPJ P,
	
MTR1:	MOVE T2,DEVICE
	CAIE T6,INIMTA
	MOVE T2,ODEV
	MOVEM T2,MTRNAM
	JSP T1,PTEXT
	SIXBIT /?@TOO@MANY@REQUESTS@FOR@/
MTRNAM:	0
	SIXBIT /@!/
;CONSTANTS

IFE WCH,<
OKBD:	POINT 6,DTON+2,23	;FOR NO. 1K BLOCKS
OKB:	POINT 6,ZRF+2,23>
DATE:	POINT 12,ZRF+2,35
ZRO:	ASCII /00000/
OPTMAX:	POINT 7,DBUF-2,34
OPTRA:	XWD 700,LBUF-1		;INITIAL POINTER TO LINE BUFFER
K1:	432150643240		;MAGIC ASCII INCREMENT BY 10
K3:	375767737576		;CHARACTER MASK 077
K4:	432150643216		;MAGIC ASCII INCREMENT BY 1
QPIP:	SIXBIT /QPIP/		;DATA FOR Q SWITCH
STAR:	XWD 120000,0		;LOOK FOR *.* FILNAM.EXT
TWL:	OCT 12
STPROT:	XWD 055000,0
PRPTL:	POINT 9,PROTS,8		;PROTECTION FOR RENAME
PRPTD:	POINT 9,DTON+2,8
PRNM:	POINT 9,ZRF+2,8		;PROT FOR /R
DATED:	POINT 12,DTON+2,35	;CREATION DATE /X
TIME:	POINT 11,ZRF+2,23	;CREATE TIME /X
TIMED:	POINT 11,DTON+2,23	;DEPOSIT CREATE TIME
IFE BLOC0,<
BL0CNT:	0			;COUNT>

LIT

;PROGRAM STORAGE AREA

IFN CCLSW,<
CFILE:	SIXBIT /###PIP/	;NAME OF STORED CCL COMMAND FILE
	SIXBIT /TMP/
	0
	0
COMFLG: 0		;-1 IF STORED COMMANDS,0 IF TTY>
SVIBF:	0		;SAVE INIT MODE (INPUT)
SVOBF:	0		;SAVE INIT MODE (OUTPUT)
IBF:	BLOCK 3		;INPUT BUFFER HEADER
OBF:	BLOCK 3		;OUTPUT BUFFER HEADER
OBI:	BLOCK 3		;OUTPUT BUFFER INPUT HEADER FOR DSK /Z
TFI:	BLOCK 3		;CONSOLE INPUT HEADER
TFO:	BLOCK 3		;CONSOLE OUTPUT HEADER
CFI:	BLOCK 3		;STORED COMMAND INPUT HEADER 
SAVAC:	BLOCK 5		;SAVE SOME ACS
NAMTAB:	BLOCK 24	;FOR (XD) ON DSK OR RENAME
LOCNAM:	0		;POINTER FOR NAMTAB
DIRST:	0		;LOC. OF LAST DIR. FILE NAME REFERENCED
DIRST1:	0		;SAVE INITIAL DIRST
CALFLG:	0		;DESCRIBES CURRENT FILE NAME, ETC
SQNUM:	0		;CURRENT SEQUENCE NUMBER
DTJBFF:	0		;VALUE OF JOBFF AFTER CONSOLE I/O BUFFERS
SVJBFF:	0		;INITIAL VALUE OF JOBFF
SVJBF1:	0		;VALUE OF JOBFF AFTER OUTBUF UUO
OPTR:	0		;CURRENT POINTER FOR LINE PRESCAN
DTONSV:	BLOCK 2
SVPTR1:	0		;POINTER TO LAST PRINTING CHARACTER
SVPTR2:	0		;POINTER TO LAST GENERATED TAB
TLBRKT:	0		;TOTAL PARENS ON THIS LINE
TOTBRK:	0		;TOTAL CUMULATIVE PARENS
TABCT:	0		;SPACES TO NEXT TAB STOP
SPCT:	0		;CONSECUTIVE SPACES COUNTER
ABOUT:	0		;AB FOR OUTPUT UNIT
AUXOUT:	0		;AUX FOR OUTPUT UNIT
PROTS:	0		;SAVE PROTECTION
ZCNT:	0		;COUNT FOR DSK ZRO REQ.
CDRCNT:	0		;COUNT CARD COLS.
PTRPT:	0		;STORE SEQ. NO. POINTER
DEV:	0		;DEVICE NAME INDICATOR

;THIS IS A BLOCK OF VARIABLE LOCATIONS, ZEROED AT THE START OF EACH
;PIP RUN, I.E EACH TIME PIP TYPES *.

FILNAM:	0		;FILE NAME FROM COMMAND SCANNER
FILEX:	0		;EXTENSION
PR:	0		;PROTECTION
PP:	0		;P-P NUMBER
DTON:	BLOCK 4		;OUTPUT DIR. ENTRY
DEVA:	0		;SAVE INPUT DEV. NAME
NO.:	0		;GENERATE FILE NAMES
ZRF:	BLOCK 4		;LOOKUP FILE NAMES
MTAREQ:	0		;STORE MTA REQUESTS
SYSFLG:	0		;LHS=1 MEANS INPUT DEV - RHS=1 MEANS LAST INPUT DEV SYS
AUX:	0		;COPT AUXFLG (MTA)
FNPPN:	0		;RESERVE #P-P
FNPPNS:	0		;COPY FNPPN FOR LATEST NON-SYS #P-P
NSWTCH:	0		;-1 INDICATES NULL NAME
SSWTCH:	0		;-1 INDICATES LEFT ARROW SEEN
ESWTCH:	0		;-1 INDICATES END OF LINE
XNAME:	0		;-1 INDICATES SCAN OVERSHOOT WITH A NULL NAME
			;0  INDICATES NO SCAN OVERSHOOT
			;CONTAINS OVERSHOOT NAME IF NOT NULL
AB:	0		;MTA VALUE SWITCHES
			;THIS IS THE END OF THE INIT. ZEROED BLOCK.
MONTH:	ASCII /-JAN-/
	ASCII /-FEB-/
	ASCII /-MAR-/
	ASCII /-APR-/
	ASCII /-MAY-/
	ASCII /-JUN-/
	ASCII /-JUL-/
	ASCII /-AUG-/
	ASCII /-SEP-/
	ASCII /-OCT-/
	ASCII /-NOV-/
	ASCII /-DEC-/

MNPT:	POINT 7,MONTH

PDL:   BLOCK 20		;PUSHDOWN LIST

LBUF:  BLOCK 34		;LINE BUFFER

DBUF:  BLOCK 204	;DIRECTORY BUFFER
IFE RIMSW,<
RIMTB:	JSP	T1,PTEXT
	SIXBIT	Z?@/Y@SWITCH@OPTION@NOT@AVAILABLE@THIS@ASSEMBLY!Z>
IFN RIMSW,<
LODAL=16			;LENGTH OF RIM LOADER
HLTBIT=200			;CHANGES JRST TO HALT
BLKSZ=17			;NORMAL BLOCK LENGTH IN RIM10B
CHKSM:	OCT	0		;CHECKSUM ACCUMULATED (RIM10B)
POINTA:	OCT	0		;SAVE POINTER FOR RIM10B BLOCK
LENGTH:	OCT	0		;CALC. LENGTH OF RIM10 FILE
ZERO:	OCT	0		;NO OF 0'S NEEDED TO FILL SPACES IN
COUNT:	BLOCK	1		;RIM10B COUNT WORDS OUT
XFERWD:	XWD	254000,0	;RIM-10-B XFER WD. ;FILE.

RIMTB:	TRNN	AUXFLG,DTAIN	;AND DTA IN
	JRST	ERR5B
	PUSHJ	P,ININIT
	OUTPUT	OUT,
	PUSHJ	P,DTADIR
	PUSHJ	P,FNSET
RIMTB0:	MOVEI	0,254000
	HRLM	0,XFERWD	;ASSUME JRST
	PUSHJ	P,LOOK		;GET FILE TO CONVERT
	JRST	MAIN1		;NONE LEFT
	LOOKUP	IN,ZRF
	JRST	ERR3
	HLRZ	0,ZRF+1
	CAIN	0,(SIXBIT ,RTB,)
	JRST	RIMTB1
	CAIE	0,(SIXBIT ,SAV,)
	CAIN	0,(SIXBIT ,RMT,)
	JRST	RIMTB2
	JRST	ERR3B		;NO LEGAL EXTENSION - SAVE JOBFF TOO
RIMTB1:	MOVE	T1,OBF+1	;PUNCH RIN10B LOADER
	HRLI	T1,RMLODA
	AOS	T2,T1		;XFER IT TO OUTPUT BUFFER
	BLT	T1,LODAL(T2)
	ADDI	T2,LODAL
	HRRM	T2,OBF+1	;FIX BUFFER POINTER
	MOVEI	T2,LODAL
	MOVNS	T2	
	ADDM	T2,OBF+2	;AND COUNTER
	CLOSE	OUT,
	PUSHJ	P,ININIT	;BLANK TAPE
RIMTB2:	PUSHJ	P,RINP		;GET FIRST BUFFER
	JRST	ERR8A		;FILE OF ZERO LENGTH
	SKIPL	CHR		;FIRST WORD MUST BE POINTER
	JRST	ERR8A
	HLRZ	0,ZRF+1
	CAIN	0,(SIXBIT ,SAV,)
	JRST	RIMTB4		;"SAV" FILE
	HRRZ	T2,CHR		;FIND VALUE OF JOBSA
	ADDI	T2,^D126	;IS IT IN 1ST BUFFER?
	MOVEI	T3,JOBDA
	SOS	T3
	CAMGE	T2,T3		;(JOBDA) IS FIRST LOC. OF USER PROF,
	JRST	ERR8A		;NO, ERROR
	MOVE	T1,IBF+1
	MOVEI	T3,JOBSA
	PUSHJ	P,RMS1
	HRRM	CHR,XFERWD	;SAVE TRANSFER WORD
	MOVEI	T3,JOBFF
	MOVE	T1,IBF+1
	PUSHJ	P,RMS1
	HRRZM	CHR,LENGTH	;SAVE (JOBFF)
	HLRZ	0,ZRF+1
	CAIN	0,(SIXBIT .RTB.);RIM 10B CONVERSION
	JRST	RIMTB4

;RIM10 1ST WD IS -N,X X IS 1ST WORD IN DATA BLOCK
;CONTAINING FIRST NON-ZERO WORD AFTER END
;OF JOBDATA AREA, FROM THERE TO JOBFF GIVES
;VALUE OF N. XFER ADD. COMES FROM JOBSA.

RMT1:	MOVEI	T1,JOBDA	;FIRST LOC. AVAILABLE TO USER
	LDB	CHR,IBF+1
	HRRZ	T2,CHR		;T2 = FIRST "X"
	AOS	T2		;T2 = LOC. FOR LOADING FIRST WORD
	SUB	T1,T2
	JUMPLE	T1,RMT2		;CURRENT "X" GT OR EQ JOBDA
	HLRO	T2,CHR
	MOVNS	T2		;GET "N"
	AOS	T1		;GET REL. LOC. OF JOBDA IN BLOCK
	CAMG	T1,T2
	JRST	RMT2
	AOS	T2		;NOT IN BLOCK, TRY NEXT
	ADDM	T2,IBF+1
	MOVNS	T2
	ADDM	T2,IBF+2	;READY TO GET NEXT POINTER
	JRST	RMT1
RMT2:	LDB	CHR,IBF+1	;POINTS TO FIRST USEFUL I/O WORD
	HRRZ	CHR,CHR		;CACULATE I/O WORD FOR FILE
	MOVE	T1,LENGTH	;FROM HERE TO JOBFF
	SUB	T1,CHR		;LENGTH +1 (I.E. INCLUDES XFER WORD)
	MOVEM	T1,LENGTH
	MOVNS	T1		; -N
	HRLM	T1,POINTA
	HRRM	CHR,POINTA	;(-N,X) IN POINTA
	SETZM	ZERO

;NOW OUTPUT RIM10 FILE.  IBF+1 POINTS TO FIRST I/O WORD.  POINTA HAS I/O
;WORD FOR FILE.  LENGTH = NO. WDS TO GO OUT INCLUDING XFER WD.
;COUNT COUNTS NO. WDS IN CURRENT LOGICAL BLOCK
;ZERO COUNTS ZERO FILL

	MOVE	CHR,POINTA
	PUSHJ	P,PUT		;PUNCH I/O WORD
RMT8:	LDB	CHR,IBF+1	;-N,X
	MOVEM	CHR,POINTA
	HLRO	T1,CHR
	MOVNM	T1,COUNT
RMT6:	SETZM	CHR		;PUNCH ZERO IF NECESSARY
	SOSL	ZERO
	JRST	RMT4		;DEPOSIT ZERO
	SOSGE	COUNT
	JRST	RMT5		;GET NEW LOGICAL BLOCK
	PUSHJ	P,RINP1
	JRST	ERR8A
RMT4:   SOSG	LENGTH
	JRST	RIMTB8
	PUSHJ	P,PUT
	JRST	RMT6
RMT5:   HRRZ	T1,POINTA
	HLRO	T2,POINTA
	MOVNS	T2
	ADD	T2,T1
	PUSHJ	P,RINP1
	JRST	RMT9
	SKIPL	CHR
	JRST	ERR8A
	HRRZ	CHR,CHR
	SUB	CHR,T2
	SKIPGE	CHR
	JRST	ERR8A
	MOVEM	CHR,ZERO
	JRST	RMT8
RMT9:   MOVE	CHR,LENGTH
	SOS	CHR
	MOVEM	CHR,ZERO
	SETZM	CHR
RMT10:  SOSGE	ZERO
	JRST	RIMTB8
	PUSHJ	P,PUT
	JRST	RMT10
;RIM10B: COMES FROM RTB AND SAV FILES. SAV=RTB EXCEPT IT HAS NO
;RIM LOADER AND NO TRANSFER WORD

RIMTB3:	PUSHJ	P,RINP1		;NONE, GET NEW POINTER
	JRST	RIMTB8		;EOF
	SKIPL	CHR		;POINTER L.T. 0?
	JRST	ERR8A
RIMTB4:	LDB	CHR,IBF+1
	HRRZM	CHR,POINTA	;LOAD WORDS HERE
	HLROM	CHR,COUNT
	MOVNS	COUNT		;NO. WDS IN THIS BLOCK
RIMTB7:	SKIPN	T1,COUNT	;ANY WORDS LEFT IN BLOCK?
	JRST	RIMTB3		;NONE
	SETZM	CHKSM		;INITIALIZE CHECKSUM
	CAIL	T1,BLKSZ
	MOVEI	T1,17
	MOVN	T2,T1		;T1 HAS NO. OF WDS TO GO OUT
	ADDM	T2,COUNT	;ADJUST COUNT
	HRL	CHR,T2
	HRR	CHR,POINTA	;I/O WD IN CHR
	ADDM	T1,POINTA	;SET POINTA FOR NEXT TIME
	ADDM	CHR,CHKSM	;ADD I/O WD TO CHECKSUM
RIMTB5:	PUSHJ	P,PUT		;PUTPUT I/O WORD
	SOJL	T1,RIMTB6		;FINISHED THIS BLOCK
	PUSHJ	P,RINP1		;GET DATA
	JRST	ERR8A		;EOF (ILLEGAL)
	ADDM	CHR,CHKSM	;CHECKSUM
	JRST	RIMTB5
RIMTB6: MOVE    CHR,CHKSM
	PUSHJ	P,PUT
	OUTPUT	OUT,
	JRST	RIMTB7
RIMTB8:	MOVE	CHR,XFERWD	;EOF HERE, XFERWD=JOBSA
	HRRZ	0,XFERWD
	SKIPN	0		;HALT REQUIRED
	TLO	CHR,HLTBIT
	HLRZ	0,ZRF+1
	CAIN	0,(SIXBIT .SAV.);NO XFER WD FOR "SAV" FILES
	JRST	RIMA
	PUSHJ	P,PUT
	SETZM	CHR
	PUSHJ	P,PUT		;TRAILING ZERO
	OUTPUT	OUT,
RIMA:	CLOSE	IN,
	TRNE	FLAG,XFLG
	CLOSE	OUT,
	JRST	RIMTB0

;THIS IS THE I/O SECTION

RINP:	PUSHJ	P,INP
	TRNE    IOS,20000	;EOF?
	POPJ	P,		;EOF EXIT
RINP1:	SOSGE	IBF+2
	JRST	RINP
	ILDB	CHR,IBF+1
	JRST	IPOP
RMS2:	SUB	T1,T4		;(IBF+1)+N
	AOS	T1
RMS1:	LDB	CHR,T1		;GET POINTER
	HRRZ	T2,CHR		;X
	HLRO	T4,CHR		;-N
	SUB	T2,T4		;X+N IN T2
	CAMGE	T2,T3
	JRST	RMS2
	HRRZ	T2,CHR		;T3 IN RANGE
	SUB	T3,T2		;HOW FAR FROM POINTER?
	ADD	T1,T3		;INCREMENT POINTER
	LDB	CHR,T1		;(JOBSA/FF)
	POPJ	P,

		;THIS IS THE RIM LOADER FOR THE PDP-10

RMLODA:	XWD	-16,0			;	XWD	-16,0
	XWD	710600,60		;ST:	CONO	PTR,60
	XWD	541400,4		;ST1:	HRRI	A,RD+1
	XWD	710740,10		;RD:	CONSO	PTR,10
	XWD	254000,3		;	JRST	.-1
	XWD	710470,7		;	DATAI	PTR,@TBL1-RD+1(A)
	XWD	256010,7		;	XCT	TBL1-RD+1(A)
	XWD	256010,12		;	XCT	TBL2-RD+1(A)
	XWD	364400,0		;A:	SOJA	A,
	XWD	312740,16		;TBL1:	CAME	CKSM,ADR
	XWD	270756,1		;	ADD	CKSM,1(ADR)
	XWD	331740,16		;	SKIPL	CKSM,ADR
	XWD	254200,1		;TBL2:	JRST	4,ST
	XWD	253700,3		;	AOBJN	ADR,RD
	XWD	254000,2		;ADR:	JRST	ST1>
;* * * ALL THE FOLLOWING ARE DISK ROUTINES * * *

;DISK DELETE AND RENAME ROUTINES

DSKDR:	PUSHJ   P,ININIT	;GET DSK AS "IN"
	PUSHJ   P,DSKDIR
	PUSHJ	P,INFO
	SETZM   ZCNT
DSKDR5:	PUSHJ   P,LOOK
	JRST    DSKDR1
	PUSHJ	P,INFO3
	LOOKUP	IN,ZRF		;IS SOURCE FILE THERE?
	JRST    DERR5		;ERROR
	CLOSE   IN,		;YES
	TRNN    FLAG,DFLG	;DELETE?
	JRST    DSKDR4
	SETZM   DTON		;YES
	MOVE    0,FNPPN		;SET DEST. DEVICE SAME AS SOURCE FOR DELETE,
	MOVEM   0,DTON+3	;I.E. PROJ-PROG NUMBER
	JRST    DSKDR7
DSKDR4:	PUSHJ   P,RENAME
	MOVEI   0,DTON+2
	HRLI    0,NAMTAB+2
	BLT     0,DTON+3
	LDB     0,PRNM		;IF NO PROT. SPECIFIED
	TLNN    AUXFLG,NSPROT	;USE THE CURRENT PROTECTION
	DPB     0,PRPTD		;OF THE FILE (ZRF)
DSKDR7:	RENAME  IN,DTON
	AOS     ZCNT		;RENAME (OR DELETE) FAILS
	JRST    DSKDR5
DSKDR1:	TLZ     AUXFLG,NSPROT	;NON-ST. PROT FIXED
	SKIPE   ZCNT
	JRST    DSKDR6		;ERROR
	SOS     ESWTCH		;ENSURE ESWTCH NEGATIVE
	RELEAS	CON,
	JRST    MAIN1
;ZERO DSK DIRECTORY OF ALL POSSIBLE FILES.  IF ANY ARE PROTECTED, GIVE
;A MESSAGE AND DO NOT PROCESS ANY OTHER SWITCHES.

DSKZRO:	PUSHJ   P,DIRSK1
	SETZM   ZCNT
	INBUF   OUT,1		;FOR LOOKUPS ON OUT
DSKZ1:	SOSLE   UFDIN+2
	JRST    .+3
DSKZ3:	PUSHJ   P,UIN
	JRST    DSKZ2
	ILDB    0,UFDIN+1
	JUMPE   0,DSKZ3
	MOVEM   0,ZRF
	SOS     UFDIN+2
	ILDB    0,UFDIN+1
	ANDCMI	0,-1
	MOVEM   0,ZRF+1		;EXTENSION
	MOVE    0,FNPPN
	MOVEM   0,ZRF+3
	LOOKUP  OUT,ZRF
	AOS     ZCNT		;COUTN REJECTS,TRY MORE FILES
	CLOSE   OUT,
	SETZM   ZRF
	MOVE    0,FNPPN
	MOVEM   0,ZRF+3
	RENAME  OUT,ZRF
	AOS     ZCNT
	JRST    DSKZ1		;REPEAT
DSKZ2:	SKIPN	ZCNT
	POPJ    P,
	MOVEI   0,72
	JRST    DSKZ5
DSKDR6:	MOVEI   0,44		;/D
	TRNN    FLAG,DFLG
	MOVEI   0,62		;/R
DSKZ5:	MOVE    T1,[POINT 6,DSKZ4,23]
	DPB     0,T1
	JSP     T1,PTEXT
	SIXBIT  KFAILURE(S)@DURINK
DSKZ4:	SIXBIT  KG@/ @REQUEST!K
;PREPARE TO LOOKUP FILES IN PARTICULAR DISK DIRECTORY

DIRSK1:	SKIPA   T1,DTON+3
DSKDIR:	MOVE    T1,PP
	SKIPN   T1
	CALLI   T1,24
IFE DISK30,<
	MOVEM   T1,UFD>
	MOVEM   T1,FNPPN
IFN DISK30,<
	HRRZM   T1,T2		;SAVE PROGRAMMER NBR.
	LSH     T1,-14		;SHIFT PROJECT NBR.
	IOR     T1,T2		;REPLACE PROGRAMMER NBR
	MOVEM   T1,MASK
	MOVE    0,[SIXBIT /*FD*/]
	MOVEM   0,UFD
	MOVSI   0,(SIXBIT /SYS/)
	MOVEM   0,UFD+1>
	HLRZ    0,SYSFLG
	SKIPN   0
	MOVEM   T1,FNPPNS	;SAVE LATEST NON-SYS #P-P
IFNDEF SYSPP,<
	MOVE    0,[XWD 1,1]>
IFDEF SYSPP,<
	MOVE    0,SYSPP>
	MOVEM   0,UFD+3
	PUSHJ   P,DSKDST
	LOOKUP  DIR,UFD
	JRST    DERR5A
	POPJ    P,

UFD:	0
	SIXBIT	/UFD/
	0
	0
;SETUP BUFFER TO READ 10/30 DISK BLOCKS

IFN DISK30,<
BLKSET:	MOVE	T2,JOBFF	;MAKE MONITOR USE BLKBUF
	MOVEI	T1,BLKBUF	;FOR 10/30 DISK BLOCKS
	MOVEM	T1,JOBFF
	INIT	BLKIN,14
	SIXBIT	/SYS/
	XWD	0,BLKHD
	JRST	ERR1A
	INBUF	BLKIN,1
	MOVEM	T2,JOBFF
	POPJ	P,

BLKBUF:	BLOCK 204		;10/30 DISK BLOCK BUFFER

;ROUTINE TO READ 10/30 DISK

BLKRD:	SETZM	FILNAM+2
	SETZB	BLKTMP
	INPUT	BLKIN,		;INPUT 10/30 DISK BLOCKS
	STATUS	BLKIN,IOS
	TRNN	IOS,760000
	JRST	BLKRD1
	TRZN	IOS,20000	;EOF
	JRST	BLKERR		;ERROR
	SETSTS	BLKIN,(IOS)
	MOVEM   0,BLKTMP
	ADDM    0,BLKSUM
	POPJ    P,
BLKRD1:	AOJA	0,BLKRD+2	;COUNT BLOCKS PER FILE
BLKERR:	PUSHJ	P,COMERR
	JSP	T5,INICN2
	TRNN	IOS,400000	;CHECK FOR WRITE LOCK
	JRST	.+3		;NO
	JSP	T1,PTEXT2	;YES
	SIXBIT	/?#/
	JSP	T1,PTEXT2
	SIXBIT	/INPUT@DEVICE@DSK@FILE@#/
	MOVEI	T6,FILNAM
	PUSHJ	P,FN.EX
	MOVE	T2,AUXFLG
	ANDI	T2,DSKIN
	PUSHJ	P,IOERR
	SETSTS	BLKIN,(IOS)
	POPJ	P,>
;ROUTINE TO LIST DISK DIRECTORY

DSKLST:	PUSHJ	P,ININIT	;ASSIGN "IN" FOR RETRIEVAL INFO
IFN DISK30,<
	TRNN    AUXFLG,FFLG	;SHORT LISTING
	PUSHJ   P,BLKSET	;NO>
	SETZM	LIN		;SET UP APPROPRIATE CONTROLS
	MOVE	T1,ODEV		;FOR THIS LISTING DEVICE
	SETZM	T2
	CAMN	T1,ITTY
	AOS	T2
	MOVEM	T2,LISTTY	;LISTTY=0 IF LIST. NOT T0 CONSOLE
	PUSHJ   P,DSKDIR
	PUSHJ	P,HEADER	;PUT OUT HEADER LINES
LSTU1:	SOSLE   UFDIN+2
	JRST    .+3
LSTU2:	PUSHJ   P,UIN		;GO READ DIRECTORY
	JRST    BLKLST		;(EOF) - OUTPUT BLOCKS USED
	ILDB	0,UFDIN+1
	JUMPE   0,LSTU2
	MOVEM	0,FILNAM	;PREPARE TO GET RETRIEVAL INFO
	MOVE	T1,FNPPN	;EACH LOOKUP DESTROYS P-P NO.
	MOVEM	T1,FILNAM+3	;RESTORE P-P NO.
	SKIPG	LIN
	PUSHJ	P,HEDR3		;YES, PUT OUT HEADER LINES
	SOS	UFDIN+2
	ILDB	DOUT,UFDIN+1	;PICK UP EXTENSION
	ANDCMI	DOUT,-1		;CLEAR RIGHT HALF
	MOVEM	DOUT,FILNAM+1	;KEEP FOR LOOKUP
IFE DISK30,<
	CAME	DOUT,[SIXBIT ?UFD   ?]	;IS FILE MFD
	JRST	LSTU3		;GO PRINT NAME HELD IN 0.
	HLRZ	DOUT,FILNAM	;HERE FOR MFD ONLY
	MOVEI   T2,PUT
	PUSHJ	P,OUTOCT	;PRINT #,#. PROJ. NO.
	MOVEI	CHR,","		;","
	PUSHJ	P,PUT		;...
	HRRZ	DOUT,FILNAM	;PROG. NO.
	PUSHJ	P,OUTOCT
	JRST	LSTU3A	;...>
IFN DISK30,<
	ILDB    0,UFDIN+1	;PICKUP THIRD AND FOURTH WORD
	MOVEM   0,FILNAM+2	;IN 10/30 DISK FILE DIRECTORY
	ILDB    0,UFDIN+1
	TDC     0,MASK
	TRNE    0,3777
	JRST    LSTU1>
LSTU3:	MOVEI	T4,6		;SETUP TO OUTPUT FILENAME
	MOVE	0,FILNAM
	PUSHJ	P,SIXOUT	;OUPUT FILENAME
	JUMPE	T4,.+2
	PUSHJ	P,SPACES
LSTU3A:	MOVEI	T4,4	;SET LOOP FOR OUTPT EXT
	MOVE	0,FILNAM+1
	JUMPE	0,LSTU4-1
	MOVEI	CHR,56		;OUTPUT "."
	SKIPN	LISTTY
	MOVEI	CHR,11		;OR TAB IF OUTPUT IS NOT TO TTY
	PUSHJ	P,PUT
	SOJ	T4,
	PUSHJ	P,SIXOUT	;OUTPUT EXTENSION
	JUMPE	T4,LSTU4
	PUSHJ	P,SPACES
LSTU4:	TRNN	AUXFLG,FFLG	;THIS THE SHORTEST LISTING?
	JRST	.+3
	PUSHJ	P,CLRF
        IBP UFDIN+1
        IBP UFDIN+1
        IBP UFDIN+1
	JRST	LSTU1
IFE DISK30,<
	LOOKUP	IN,FILNAM	;GET RETRIEVAL INFO.
	JRST	LSTU5		;NOT AVAILABLE>
IFN DISK30,<
	MOVE    DOUT,FILNAM+2	;SAVE
	LOOKUP  BLKIN,FILNAM
	JRST    LSTU5
	PUSHJ   P,BLKRD
	MOVEM   DOUT,FILNAM+2>
	PUSHJ   P,TABOUT
IFE DISK30,<
	TLNE	AUXFLG,740000	;SPECIAL CATALOG OPTIONS REQ'D
	JRST	SXCAT		;YES
	PUSHJ   P,BLKS>
IFN DISK30,<
	PUSHJ   P,BLKOUT>
	SKIPE	LISTTY
	JRST	LSTU7
	LDB	0,ADATE		;PRINT ACCESS DATE
	PUSHJ	P,DATOUT
	PUSHJ	P,TABOUT
	LDB	0,CTIME		;PRINT CREATION TIME
	PUSHJ	P,TIMOUT
	LDB	0,CDATE
	PUSHJ	P,DATOUT	;PRINT CREATION DATE
	PUSHJ	P,TABOUT
	LDB	0,PROT1		;PRINT OWNER PROTECTION
	PUSHJ	P,PROTO
	LDB	0,PROT2		;PRINT PROJECT PROTECTION
	PUSHJ	P,PROTO
	LDB	0,PROT3		;PRINT UNIVERSE PROTECTION
	PUSHJ	P,PROTO
	PUSHJ	P,TABOUT
	LDB	0,MODE		;PRINT MODE
	PUSHJ	P,OCTLST
	JRST	LSTU8
LSTU5:	PUSHJ	P,TABOUT	;THE FILE WAS PROTECTED
	HRRZ    T7,FILEX	;GET PARTICULAR ERROR
	TRZ     T7,777770
	MOVE    T1,TABLE(T7)
LSTU6:	ILDB    CHR,T1
	JUMPE   CHR,LSTU6	;PRINT
	CAIE    CHR,40
	ADDI    CHR,40		;7-BIT
	CAIE    CHR,"#"
	CAIN    CHR,"!"
	JRST	LSTU8
	PUSHJ   P,PUT
	JRST    LSTU6
;
;
;	SPECIAL OPTIONS CODE FOR CATALOG
;
SXCAT:	TLNE	AUXFLG,SIFLG	;BLOCK SIZES REQ'D
	PUSHJ	P,BLKS	;YES
	TLNE	AUXFLG,PRFLG	;PROTECTIONS REQ'D
	JRST	LSTU7X		;YES
	JRST	LSTU7Y		;CHECK ON DATES REQ'D
;
;
LSTU7:	TRNN	AUXFLG,FFLG
	JRST	LSTU7X
	PUSHJ	P,CLRF
        IBP UFDIN+1
        IBP UFDIN+1
        IBP UFDIN+1
	JRST	LSTU1
LSTU7X:	MOVEI	,0
	HRRM	,PROTO+1
	MOVEI	0,"*"		;REPLACE P WITH * IN PROTO
	HRRM	,PROTO+3
	MOVEI	,"L"		;REPLACE W WITH L FOR LOCKED IN PROTO
	HRRM	,PROTO+11
	LDB	0,PROT1
	PUSHJ	P,PROTO
	MOVEI	,		;PLACE A NULL IN PLACE OF P
	HRRM	,PROTO+3
	MOVEI	,"W"		;RETURN W IN PLACE
	HRRM	,PROTO+11
	LDB	0,PROT2
	PUSHJ	P,PROTO
	MOVEI	,"P"		;RESTORE P AGAIN
	HRRM	,PROTO+3
	MOVEI	," "
	HRRM	,PROTO+1
	TLNN	AUXFLG,760000	; IF NO SPECIAL CATALOG BITS SET TYPE DATE.
	JRST	LSTU7Y+2
LSTU7Y:	TLNN	AUXFLG,DTFLG	;DATES REQ'D ?
	JRST	LSTU7Z		;NO
	LDB     0,CDATE
	PUSHJ   P,DATOUT	;PRINT CREATION DATE ONLY FOR TTY
LSTU7Z:	TLNN	AUXFLG,TIFLG	;TIME REQ'D
	JRST	LSTU8		;NO
	TLNE	AUXFLG,DTFLG	;ONLY NEED THIS TAB IF DATE IS REQ'D
	PUSHJ	P,TABOUT
	LDB	0,CTIME		;PRINT CREATION TIME
	PUSHJ	P,TIMOUT
LSTU8:
IFE DISK30,<
	CLOSE	IN,>
	PUSHJ	P,CLRF
	JRST	LSTU1
SPACES:	MOVEI	CHR,40
	PUSHJ	P,PUT
	SOJG	T4,.-1
	POPJ	P,
SIXOUT:	MOVE	T2,[POINT 6,0]
	ILDB	CHR,T2
	JUMPE	CHR,SIXO1
	ADDI	CHR,40
	PUSHJ	P,PUT
	SOJ	T4,
	TLNN	T2,770000
SIXO1:	POPJ	P,
	JRST	SIXOUT+1
;DETERMINE NUMBER OF BLOCKS PER FILE AND TOAL NUMBER OF
;BLOCKS USED BY USERS PROJECT,PROGRAMMER NUMBER

BLKS:	SETZM   BLKTMP
	HLRE    0,PP		;GET WORD COUNT OF FILE
	MOVNS   0,		;MAKE POSITIVE
	JUMPLE  0,BLKOUT
	TRZE    0,177		;TAKE CARE OF PARTIAL BLOCKS
	ADDI    0,200
	IDIVI   0,200		;CALCULATE BLOCK COUNT
	ADDI 0,2	;ADD RIB SHIT
	IDIVI 0,5	;CHANG TO MOD 5
	CAIE 1,0
	ADDI 0,1
	IMULI 0,5
	ADDM    0,BLKSUM	;CALCULATE TOTAL NUMBER OF BLOCKS
	MOVEM   0,BLKTMP
BLKOUT:	MOVE    DOUT,BLKTMP
	PUSHJ   P,OUTDEC	;OUTPUT NUMBER OF BLOCKS IN DECIMAL
	;********PATCH  GC*******
	TRNN	AUXFLG,FFLG	;IF SHORT DIRECTORY NO TABOUT NECESSARY
;*******************************************
	PUSHJ	P,TABOUT	;OUTPUT TAB
	POPJ    P,
BLKLST:	SKIPN   BLKSUM		;ANY INFORMATION TO OUTPUT
	JRST    MAIN1		;NO - FINISHED
	PUSHJ   P,CRLF
	LSTLIN	TOTAL
	MOVE    DOUT,BLKSUM
	SETZM   BLKSUM
	PUSHJ   P,OUTDEC	;PRINT TOTALS
	JRST    MAIN1		;FINISHED

TOTAL:	ASCIZ	/TOTAL BLOCKS    /
;INPUT USERS FILE DIRECTORY

UIN:	INPUT	DIR,
	STATUS	DIR,IOS
	TRNN	IOS,760000
	JRST	IPOP
	TRZN	IOS,20000
	JRST	UIN2
	SETSTS	DIR,(IOS)
	POPJ	P,

DSKDST:	MOVE	T2,JOBFF
	MOVEI	T1,DBUF
	MOVEM	T1,JOBFF	;MAKE MONITOR USE DBUF FOR DISK DIR.
	INIT	DIR,14
ADSK:	SIXBIT /SYS/
	XWD	,UFDIN
	JRST	ERR1A
	INBUF	DIR,1
	MOVEM	T2,JOBFF
	POPJ	P,
;OUTPUT THE DIRECTORY LISTING HEADER

HEADER:	PUSHJ	P,CLRF
	PUSHJ	P,HEDR4
HEDR1:	LSTLIN	HEDL1
	SKIPE	LISTTY		;IF TTY OUTPUT NO PPN'S PRINTED
	JRST	NOPPN
	HLRZ	0,FNPPN
	PUSHJ	P,OCTLST	;PROJ, PROG
	MOVEI	CHR,","
	PUSHJ	P,PUT
	HRRZ	0,FNPPN
	PUSHJ	P,OCTLST
NOPPN:	PUSHJ	P,TABOUT
	PUSHJ	P,NOWOUT	;PRINT CURRENT TIME, DATE
	CALLI	0,14		;DATE REQ.
	PUSHJ	P,DATOUT
	PUSHJ	P,CLRF
	SKIPE	LISTTY
	JRST	HEDR2		;JUMP IF LISTING TO CONSOLE
	PUSHJ	P,CLRF
	LSTLIN	HEDLIN
HEDR2:	JRST	CLRF
HEDR3:	SKIPE	LISTTY
	POPJ	P,
	PUSHJ	P,HEDR4
	LSTLIN	HEDL2
	JRST	HEDR1
HEDLIN: ASCII /       FILE              ACCESS                CREATION/
	ASCII /                      PROTECTION
 NAME   EXT     BLKS      DATE          TIME             DATE/
	ASCII /          OWNER   PROJECT  OTHER          MODE
/
HEDL1:	ASCIZ	/  /
HEDL2:	ASCIZ	/CONTINUATION OF /
TABLE:	POINT 6,DERR8A	;LOOKUP ERROR 0
	POINT 6,DERR8B	;1
	POINT 6,DERR8C	;2
	POINT 6,DERR8D	;3
	POINT 6,DERR8E	;4 SHOULD NOT OCCUR
	POINT 6,DERR8F	;NOR 5
	POINT 6,DERR8G	;NOR 6
	POINT 6,DERR8H	;NOR 7

UIN2:	PUSHJ   P,SAVACS
	TRNE    AUXFLG,TTYOUT	;PRINT ERR OR MESSAGE, WANT TO BE ABLE TO
	RELEAS  OUT,		;RECOVER IF /G SELECTED.
	JSP     T5,INICN2
	JSP     T1,PTEXT2
	SIXBIT  /?DISK@DIRECTORY@READ@#/
	MOVEI   T6,UFD
	PUSHJ   P,FN.EX
	MOVE    T2,AUXFLG
	ANDI    T2,DSKIN
	PUSHJ   P,IOERR
	SETSTS  DIR,(IOS)
	JRST    IPOP

;FOLLOWING ARE ROUTINES TO OUTPUT DIRECTORY LISTING INFORMATION

CLRF:	SOS	LIN
	JRST	CRLF
TABOUT:	MOVEI	CHR,11
	JRST	PUT

	;OUTPUT THE TIME FOUND IN AC 0

NOWOUT:	CALLI	0,23		;CALL MILLISEC TIMER
	IDIVI	0,^D060000	;CONVERT TO MINUTES
TIMOUT:	IDIVI	0,^D60
;*****************GC PATCH 9/19/69**********
	CAILE	0,^D12
	PUSHJ	P,ADJUST		;TIME OF DAY IN STANDARD FORMAT
;*******************END OF PATCH************
	CAIE	0,^D12
	JRST	.+2
	SETOM	DAYFLG
	MOVE	DOUT,0
	PUSHJ	P,OUTDEC
	;***********GC PATCH******
	MOVEI	CHR,":"		;*PUT : BETWEEN TIME
	PUSHJ	P,PUT
	;*******           END OF PATCH		****
	MOVE	DOUT,1
	PUSHJ	P,OUTDEC
;******************GC PATCH  9/19/69********
	MOVE	0,DAYFLG
	JUMPL	0,PMPRNT		;IF AFTER 12 PRINT PM
	LSTLIN	AM
	JRST	TIMFIN
PMPRNT:	LSTLIN	PM
TIMFIN:	SETZM	DAYFLG
	SKIPN	LISTTY
	PUSHJ	P,TABOUT
	SKIPE	LISTTY
	JRST	TOUT
	POPJ	P,
TOUT:	MOVEI	T4,7
	PUSHJ	P,SPACES
	POPJ	P,
ADJUST:	SETOM	DAYFLG
	SUBI	0,^D12
	POPJ	P,
DAYFLG:	Z
AM:	ASCIZ	/ AM/
PM:	ASCIZ	/ PM/
;********************GC PATCH 9/19/69*****END OF PATCH*****
;SKIP TO HEAD OF FORM OR NEXT HALF PAGE, RESET COUNT

HEDR4:	SKIPE	LISTTY
	POPJ	P,		;EXIT IF TTY
	SKIPLE	LIN
	JRST	HEDR6		;ANYTHING ON THIS PAGE?
HEDR5:	MOVEI	CHR,14		;FORM FEED IF FULL OR
	MOVEI	T2,^D50
	MOVEM	T2,LIN		;ALMOST FULL
HEDR5A:	PUSHJ	P,PUT
	MOVEI	CHR,12
	PUSHJ	P,PUT
	PUSHJ	P,PUT
	JRST	PUT		;PRINT LINEFEEDS AND EXIT
HEDR6:	CAIGE	T2,^D25
	JRST	HEDR5
	MOVEI	CHR,HPAGE
	MOVEI	T2,^D16
	MOVEM	T2,LIN
	JRST	HEDR5A

;OUTPUT OCTAL WORD FOUND IN AC 0

OCTLST:	MOVE    T1,[POINT 3,0]
	ILDB	CHR,T1
	TLNE	T1,770000	;ALLOW UPTO 12 OCTAL NOS
	JUMPE	CHR,.-2		;GET MOST SIG. NUMBER
OCTL1:	ADDI	CHR,60		;CONVERT TO ASCII
	PUSHJ	P,PUT		;OUTPUT CHAR
	ILDB	CHR,T1		;GET SUCCEEDING CHARS
	TLNN	T1,400000	;WAIT TILL POINTING TO NEW
	JRST	OCTL1		;WORD, THEN EXIT. MEAN WHILE
	POPJ	P,		;PRINT OCTAL NUMBERS

;OUTPUT PROTECTION BITS FOUN IN AC 0

PROTO:	JUMPE	0,XXIT	;ALL ZERO
	MOVEI	CHR," "
	PUSHJ	P,PUT
	MOVEI	CHR,"P"		;P-BIT?
	TRNE	0,4
	PUSHJ	P,PUT		;YES
	MOVEI	CHR,"R"		;R-BIT?
	TRNE	0,2
	PUSHJ	P,PUT		;YES
	MOVEI	CHR,"W"		;W-BIT?
	TRNE	0,1
	PUSHJ	P,PUT		;YES
XIT:	HRRZ	CHR,PROTO+3
	CAIE	CHR,"*"		;IF USER PROTECTION OUTPUT NO TAB
	JRST	TABOUT		;EXIT
	POPJ	P,
XXIT:	SKIPG	LISTTY
	JRST	TABOUT
	JRST	XIT
;
;
;
SUDSTR: CALLI 1,12
;
;
;THIS IS THE DISK ERROR ROUTINE.  CALL DERR4 WITH T6=FIRST WORD ADDRESS
;OF LOOKUP OR ENTER. USE T7 FOR SAVING THE ERROR CODE.

DERR6:	MOVEI   T6,DTON
	SKIPA
DERR5:	MOVEI   T6,ZRF
DERR4:	HRRZ	T7,1(T6)
   	TRZ     T7,777770	;PICK UP LOWEST THREE BITS
	JSP     T1,PTEXT
	SIXBIT  /?@#/
	PUSHJ   P,FN.EX
	JRST    DERR3(T7)

DERR3:	JRST    DERR3A	;ERR 0
	JRST    DERR3B	;ERR 1
	JRST    DERR3C	;ERR 2
	JRST    DERR3D	;ERR 3
	JRST    DERR3E	;ERR 4
	JRST    DERR3F	;ERR 5
	JRST    DERR3G	;ERR 6
	JRST    DERR3H	;ERR 7

DERR5A:	MOVEI   T6,UFD
	JRST    DERR4
DERR3A:	JSP T1,PTEXT2
DERR8A:	SIXBIT /(0)@FILE@WAS@NOT@FOUND@!/

DERR3B:	JSP T1,PTEXT2
DERR8B:	SIXBIT /(1)@NO@SUCH@PROJECT-PROGRAMMER@NO.!/

DERR3C:	JSP T1,PTEXT2
DERR8C:	SIXBIT /(2)@PROTECTION@FAILURE@!/

DERR3D:	JSP T1,PTEXT2
DERR8D:	SIXBIT /(3)@FILE@WAS@BEING@MODIFIED!/

DERR3E:	JSP T1,PTEXT2
DERR8E:	SIXBIT /(4)@RENAME@FILE@NAME@ALREADY@EXISTS!/

DERR3F:	JSP T1,PTEXT2
DERR8F:	SIXBIT /(5)@RENAME@ERROR!/

DERR3G:	JSP T1,PTEXT2
DERR8G:	SIXBIT /(6)!/

DERR3H:	JSP T1,PTEXT2
DERR8H:	SIXBIT /(7)!/
LIN:	OCT 0			;COUNT FOR DSK DIR LIST
LISTTY:	OCT 0			;NON-ZERO IFF CONSOLE LIST
ADATE:	POINT 12,FILNAM+1,35	;ACCESS DATE
CTIME:	POINT 11,FILNAM+2,23	;CREATION TIME
CDATE:	POINT 12,FILNAM+2,35	;CREATION DATE
PROT1:	POINT 3,FILNAM+2,29	;OWNER PROT
PROT3:	POINT 3,FILNAM+2,35	;OTHER PEOPLE PROT
PROT2:	POINT 3,FILNAM+2,32	;PROJECT PROT
MODE:	POINT 4,FILNAM+2,12	;RECORDING MODE
UFDIN:	BLOCK 3			;HEADER FOR READING DISK DIRECTORY
IFN DISK30,<
BLKHD:	BLOCK 3			;HEADER FOR READING BLOCKS OFF 10/30 DISK
MASK:   OCT 0			;PROJ,PROG # 10/30 DISK>
BLKSUM:	OCT 0			;TOTAL NBR BLOCKS PER PROJ. PROG NBR
BLKTMP:	OCT 0			;TOTAL NBR BLOCKS PER FILE

END PIP1			;;

    	 {