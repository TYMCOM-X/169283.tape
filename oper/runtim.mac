TITLE	BASIC    G.C. REVISION	23-JAN-1970 NANCY AVNER
SUBTTL		PARAMETERS AND TABLES
;UDATED WITH VERSION RECEIVED FROM APPLIED LOGIC ON 11-FEB-69
;FILE  CAPABILITIES BY T.MCGETTIGAN 18-MAR-69
;EDITED BY N. PAPPAS (COURTESY OF CCC) 25-MAR-69
;CYPH "OLD" PATCH 28 MAR 69
;ALC FIXES OF 31-MAR-69 BY N. PAPPAS ON 3-APR-69
;ISI MODIFICATIONS 1 MAY 70/DOH

	JOBVER=137
	VERNUM=13
	GCREV==7	;GC REVISION NO.

	LOC JOBVER
	XWD	GCREV,VERNUM
	RELOC
	HISEG
;LOADING INSTRUCTIONS:  ASSEMBLE AND LOAD THIS FILE.
;IF LOADING WITH DDT, SYMBOLS SHOULD BE MOVED BELOW LH(JOBSA)

;CONDITIONAL ASSEMBLY PARAMETERS
;  THE VERSION OF BASIC SUPPLIED BY APPLIED LOGIC CORPORATION
;  IS ASSEMBLED WITH THE PARAMETERS BELOW SET TO -1.  APPLIED
;  LOGIC CORPORATION HAS NOT NECESSARILY TESTED VERSIONS OF
;  BASIC ASSEMBLED OTHERWISE AND DOES NOT GUARANTEE TO
;  MAINTAIN ANY SUCH VERSIONS.

FTRND=-1		;-1 IF RANDOM FACILITY, ELSE 0
FTMAT=-1		;-1 IF MATRIX FACILITY, ELSE 0
FTSTR=-1		;-1 IF STRING FACILITY, ELSE 0

	MLON
;AC DEFINITIONS
			;PRINCIPAL USES:
F=7			;FLAGS
T=1			;POINTER TO NXCH
T1=2
A=3			;SEARCH ARGUMENT
B=4			;POINTER AFTER SEARCH
C=5			;XWD CHARACTER-FLAGS,CHAR
D=6			;BUILD INSTS HERE
N=0			;RUNTIME ACCUMULATOR REGISTER
R=12			;POINTER TO ROLL BEING USED
LP=16
L=16
E=10
G=11
X1=13			;)
X2=14			;)TEMP REGS
X3=15			;)
P=17			;PUSHDOWN LIST

;OP CODE ROLL

	EXTERNAL NEWOL1,SPEC,CORN,CORNTO,NLN,STOR0,STOR1,TFLAG
	EXTERNAL CECAD,CECON,CEFCL,CEFOR,CEGSB,CENXT,CESCA,CEARA
	EXTERNAL	CEPTM,CESAD,CESEX,CESTM,CEVSP,FLARA
	EXTERNAL	FLCAD,FLCON,FLFCL,FLFOR,FLGSB,FLLIT,FLFCL
	EXTERNAL	FLNXT,FLPTM,FLSAD,FLSCA,FLSEX,FLSTM,FLVSP
	EXTERNAL	CELAD,FLLAD
	EXTERNAL	CECOD,FLCOD,CETMP,FLTMP,CEARG,FLARG,CESVR,FLSVR
	EXTERNAL CETXT,FLTXT,CELIN,FLLIN
	EXTERNAL	ARAROL ,ARATOP ,ARGROL ,C3 ,CADROL ,CEIL ,CMDROL ,CODROL 
	EXTERNAL	COMTOP ,CONROL ,CURDEV ,CUREXT ,CURNAM ,DATAFF ,DATLIN ,DECROL 
	EXTERNAL	DETER ,DRMBUF ,ELETOP ,ES2 ,FADROL ,FCLROL ,FCNLNK ,FCNROL 
	EXTERNAL	FILDIR ,FLOOR ,FMTPNT ,FORROL ,FRSTLN ,FUNAME ,FUNLOW ,FUNSTA 
	EXTERNAL	GSBROL ,HPOS ,IFNROL ,INPFLA ,JOBFF ,JOBOPC ,JOBREL ,JOBREN
	EXTERNAL	JOBSA ,LADROL ,LASTLN  ,LINROL ,LITROL 
	EXTERNAL	LOWEST ,LOWSTA ,LZ ,MINFLG ,MORFLA ,NUMFLA ,NUMRES ,NXTROL 
	EXTERNAL	OLDFLA ,ONCESW ,PAKFLA ,PINPUT ,PIVOT ,PLIST ,PREAD ,PSHPNT 
	EXTERNAL	PSHROL ,PTMROL ,REGPNT ,RELROL ,RENFLA ,ROLMSK ,ROLTOP ,RUNFLA 
	EXTERNAL	SADROL ,SB1M1 ,SB2M1 ,SCAROL ,SEQPNT ,SEXROL ,STAROL ,STMROL 
	EXTERNAL	STRFLA ,SVRBOT ,SVRROL ,SVRTOP ,SX ,TABVAL ,TEMP1 ,TEMP2 
	EXTERNAL	TEMP3 ,TMPLOW ,TMPPNT ,TMPROL ,TOPSTG ,TTYBUF ,TXTROL
	EXTERNAL	TYO ,VARBOT ,VARFRE ,VARROL ,VECT1 ,VECT2 ,VPAKFL ,VRANX 
	EXTERN	VSPROL,TYI,CONLIN,FLDSPC,FLDLEN,FMTFLG,CONCTR
	EXTERN	LETSW,PDP6SW,MTIME,DSKIFL,DSKOFL,IBDSK,MATFLG
	EXTERN	REFROL,PRJPRG,FILEXT,PRNTSW,SHRTFL,CONLOC,USEFLG,CONFLG
	EXTERN	VRANT,FLREF,CEREF,REFROL,EOFLOC


IFNDEF INTRSW,<INTRSW==0>	;SET ZERO FOR NO INTERUPT HANDLING CODE
;FLAGS IN LEFT HALF OF CTTAB+<LETTER> FOR <LETTER> BELOW 100,	
;FLAGS IN RIGHT HALF OF CTTAB+<LETTER-100> OTHERWISE.

DEFINE WWW (FL,VAL)<
	XLIST
FL=<	Z	0,(VAL)>
	LIST>

WWW F.APOS,1B0		;	'
WWW F.COMA,1B1		;	,
WWW F.CR,1B2		;	<RETURN, OR LF,VT,FFEED>
WWW F.DIG,1B3		;	<NUMERAL>
WWW F.DOLL,1B17
WWW F.EQAL,1B4		;	=
WWW F.ESC,1B5		;	<ESCAPE OR ALTMODE>
WWW F.LCAS,1B6		;	<LOWER CASE LETTER>
WWW F.LETT,1B7		;	<LOWER OR UPPER CASE LETTER>
WWW F.STR,1B8		;	(
WWW F.MINS,1B9		;	-
WWW F.PER,1B10		;	.
WWW F.PLUS,1B11		;	+
WWW F.QUOT,1B12		;	"
WWW F.RPRN,1B13		;	)
WWW F.SLSH,1B14		;	/
WWW F.STAR,1B15		;	*
WWW F.SPTB,1B16		;	<SPACE OR TAB>

F.NU=0			;ASCII CODES THAT ARE TREATED AS NULLS.
F.OTH=0			;OTHER CHARACTERS ANALYSED BY BASIC WITHOUT THE USE OF FLAGS.

F.TERM=F.CR+F.APOS	;EITHER TERMINATES THE ANALYZABLE PORTION OF A BASIC STATEMENT.

	EXTERNAL CCLFLG,CCRNFL,PASFLG,INTFLA,TMPLOC,CHRFLA,VFFLG
	EXTERNAL LNINS,PAT,JOBTPC,NOLNS,LINNUM
	EXTERN	DREL,CURLIN
	EXTERN INITI,INITO,FILD,ACTBL,LOK,LOKUP,LINB0,OUTDSK,STADSK
	EXTERN	OBDSK,ENT,OUTDSK,ENTDSK
	EXTERNAL NOSKIP
;BEGIN EXECUTION

	EXTERNAL JOBAPR
	INTERNAL DECCEI,DECFLO,STAFLO,CMDFLO,CMDCEI,IFNFLO,IFNCEI
	INTERNAL STACEI,RELCEI,RELFLO
EXECUT:	MOVE P,PLIST	;GET PDL GOING
	PUSHJ P,NOTEMP
	LOOKUP 0,T1
	JRST NOCUR
	INPUT 0,INLST
	SETZM NEWOL1+1
	OPEN SPEC
	JRST NODEV
	JRST CCLOLD
NOTEMP:	MOVEI 0,16
	MOVEM 0,SPEC
	SETZM NEWOL1+1
	CALLI N,30	;GET JOB NO
	MOVEI A,3	;CONVERT TO SIXBIT
	IDIVI N,^D10
	ADDI T,20
	LSHC T,-6
	SOJG A,.-3	;FORCE 3 DIGITS
	HRRI T1,(SIXBIT/BAS/)
	MOVSI A,(SIXBIT/TMP/)
	SETZ B,
	SETZ C,
	MOVSI N,(SIXBIT/DSK/)
	MOVEM N,NEWOL1
	OPEN SPEC
	JRST NODEV
	POPJ P,
NOCUR:	HRRZ 0,BASTMP+1
	JUMPE 0,NOGET
	PUSHJ P,TTYIN
	PUSHJ P,INLMES
ASCIZ/FILE IN USE OR PROTECTED
/
	JRST COMM1B
NOGET:	PUSHJ P,TTYIN
	PUSHJ P,INLMES
ASCIZ/FILE NOT SAVED
/
	JRST COMM1B

	EXTERNAL BASTMP,IOLST
CCLOLD:NEWOL0:	MOVSI 0,(SIXBIT/RUN/)
	MOVEM 0,BASTMP+1
	MOVE 0,BASTMP
	MOVEM 0,CURNAM
	LOOKUP BASTMP
	JRST NOCUR
	HLRE X3,BASTMP+3
	JUMPG X3,LARGE	;IF X3>0 THEN =NO OF BLOCKS
	MOVMS X3,X3
TRYAGI:	MOVE X1,JOBREL
	SUBI X1,FILD-1	;SUBTRACT TO FIND NO OF WORDS AVAILABLE
	CAMG X3,X1	;IFX3>=(X1) THEN NEED MORE CORE
	JRST .+3	;ENOUGH ROOM
	PUSHJ P,NOTENO	;NOT ENOUGH
	JRST TRYAGI
EXTERNAL JOBSYM,JOBDDT
	MOVEI N,FILD-1	;START TO SETUP INLST
	HRRZM N,IOLST
	MOVEI N,SX
	AOJ N,
	SUBI N,FILD
	MOVNS N,N
	HRLM N,IOLST
	INPUT 0,IOLST
	STATZ 0,740000	;ERROR(HORRORS!)
	CALL [SIXBIT/EXIT/]	;GET LOST
	MOVE N,FLTXT
	SOJ N,
	HRRM N,IOLST
	MOVE N,JOBREL
	AOJ N,
	SUB N,FLTXT
	MOVNS N,N
	HRLM N,IOLST
	INPUT 0,IOLST
	STATZ 0,740000
	CALL [SIXBIT/EXIT/]
	RELEAS 0, ;LOSE CHANEL 
	JRST EXE1	;CONTINUE ON

NOTENO:	MOVE X2,JOBREL
	ADDI X2,2000
	CALLI X2,11
	JRST PANIC1	;TOUGHIES 
	POPJ P,

LARGE:	IMULI X3,200	;GET THE NO OF WORDS
	JRST TRYAGI

;ROUTINE TO PICK UP FILE NAME AND SET UP FOR DSK ACTION

EXE1:	SETZM	FCNLNK		;INITIALIZE FCN CALLS
	MOVEI N,DECFLO
	MOVEM N,FLOOR+2
	MOVEI N,DECCEI
	MOVEM N,CEIL+2
	PUSHJ P,TTYIN
	PUSHJ	P,RESTOR	;SET TO START AT BEGINNING OF DATA
	MOVEI	R,0		;POINTER TO GOSUB RTRN
	PUSHJ	P,PCRLF		;<RETURNS> SIGNAL END OF COMPILATION.
	PUSHJ	P,PCRLF

;INITIALIZE SOME SWITCHES:
EXECU0:	SETZM	PRNTSW
	SETZM TMPLOC	;CLEAR FOR FORMATING
	SETZM	FMTFLG		;NO FORMATTED OUTPUT YET
	SETZM	INITDN		;LPT NOT INITTED YET.
	SETZM	INPFLA		;NO INPUT CURRENTLY BEING READ
	SETOM	CHRFLA		;BLANKS NOW DELIMIT INPUT TOM S.
	SETZM	PASFLG		;TOM S.
	MOVEI	X1,12
EXEC2:	SETZM	EOFLOC(X1)
	SETZM ACTBL-1(X1)
	SETZM NLN-1(X1)
	SETZM SKFLG(X1)
	SETOM LNINS-1(X1)
	SETZM LINNUM-1(X1)
	SETZM PINPNM-1(X1)
	SETZM	NUMFLA(X1)
	SETZM	TABVAL(X1)
	SETZM	FMTPNT(X1)		;CLOBBER FORMAT PNTR
	SOJG	X1,EXEC2
	SETZM LNINS+11
	SETOM	N,NUMRES		;NO MAT INPUT HAS OCCURRED YET
IFN FTRND,<
	PUSHJ	P,WRANB		;INITIALIZE THE "STANDARD" RANDOM NUMBERS.
>
	SETZ T,
	CALL T,[SIXBIT/RUNTIM/]
	MOVEM T,MTIME
	MOVEI X3,1
XFIL1:	CAILE X3,9
	JRST EXECU1
	MOVE A,FILD-1(X3)
	JUMPE A,EXECU1
	MOVEI	X2,@BA-1(X3)	;GET BUFFER ADDRESS

	MOVEM	X2,JOBFF	;
	XCT	INITI-1(X3)	;INIT ANOTHER CHANNEL
	JRST	NODEV
	DPB	X3, [POINT 4,IBDSK,12]
	XCT	IBDSK			;DO AN INBUF 1
	DPB	X3,[POINT 4,LOKUP,12]	;PREPARE FOR LOOKUP
	MOVEM	A,LOK		;INSERT FILE NAME
	SETZM	LOK+3		;ZERO PG-PG NO.
	XCT	LOKUP		;DO LOOKUP
	SKIPA X2,[OCT 2]	;FILE NOT THERE - NO READ ALLOWED
	MOVEI	X2,1		;ALLOW READING
	MOVEM	X2,ACTBL-1(X3)	;PUT KEY IN ACCESS TABLE
	AOJA X3,XFIL1
	JRST XFIL1
EXECU1:	MOVEI	X1,OVTRAP
	HRRM	X1,JOBAPR
	PUSHJ	P,LOCKOF		;EXECUTION MAY BE INTERRUPTED.
	SETZM	IFIFG
	SETZM	ODF
	MOVEI	T, TMPROL
	MOVEM	T, TOPSTG
	JRST	@FLCOD		;BYE...
	EXTERNAL INLST


CTTAB:
	XWD	F.NU,	F.STR	;NULL	, @
	XWD	F.STR,	F.LETT	;	, A
	XWD	F.STR,	F.LETT	;	, B
	XWD	F.STR,	F.LETT	;	, C
	XWD	F.STR,	F.LETT	;	, D
	XWD	F.STR,	F.LETT	;	, E
	XWD	F.STR,	F.LETT	;	, F
	XWD	F.STR,	F.LETT	;	, G
	XWD	F.STR,	F.LETT	;	, H
	XWD	F.SPTB,	F.LETT	;TAB	, I
	XWD	F.CR,	F.LETT	;LF	, J
	XWD	F.CR,	F.LETT	;VER.TAB, K
	XWD	F.CR,	F.LETT	;FFEED	, L
	XWD	F.CR,	F.LETT	;CR	, M
	XWD	F.STR,	F.LETT	;	, N
	XWD	F.STR,	F.LETT	;	, O
	XWD	F.STR,	F.LETT	;	, P
	XWD	F.STR,	F.LETT	;	, Q
	XWD	F.STR,	F.LETT	;	, R
	XWD	F.STR,	F.LETT	;	, S
	XWD	F.STR,	F.LETT	;	, T
	XWD	F.STR,	F.LETT	;	, U
	XWD	F.STR,	F.LETT	;	, V
	XWD	F.STR,	F.LETT	;	, W
	XWD	F.STR,	F.LETT	;	, X
	XWD	F.STR,	F.LETT	;	, Y
	XWD	F.STR,	F.LETT	;	, Z
	XWD	F.ESC,	F.STR	;ESC	, [
	XWD	F.STR,	F.STR	;	, \
	XWD	F.STR,	F.STR	;	, ]
	XWD	F.STR,	F.OTH	;	, ^
	XWD	F.STR,	F.OTH	;	, _

	XWD	F.SPTB,	F.STR		;SPACE	, <ACCENT GRAVE>
	XWD	F.STR,	F.LETT+F.LCAS	; !	, <LOWER CASE> A
	XWD	F.QUOT,	F.LETT+F.LCAS	; "	, <LOWER CASE> B
	XWD	F.STR,	F.LETT+F.LCAS	; #	, <LOWER CASE> C
	XWD	F.DOLL,	F.LETT+F.LCAS	; $	, <LOWER CASE> D
	XWD	F.STR,	F.LETT+F.LCAS	; %	, <LOWER CASE> E
	XWD	F.OTH,	F.LETT+F.LCAS	; &	, <LOWER CASE> F
	XWD	F.APOS,	F.LETT+F.LCAS	; '	, <LOWER CASE> G
	XWD	F.OTH,	F.LETT+F.LCAS	; (	, <LOWER CASE> H
	XWD	F.RPRN,	F.LETT+F.LCAS	; )	, <LOWER CASE> I
	XWD	F.STAR,	F.LETT+F.LCAS	; *	, <LOWER CASE> J
	XWD	F.PLUS,	F.LETT+F.LCAS	; +	, <LOWER CASE> K
	XWD	F.COMA,	F.LETT+F.LCAS	; , 	, <LOWER CASE> L
	XWD	F.MINS,	F.LETT+F.LCAS	; -	, <LOWER CASE> M
	XWD	F.PER,	F.LETT+F.LCAS	; .	, <LOWER CASE> N
	XWD	F.SLSH,	F.LETT+F.LCAS	; /	, <LOWER CASE> O
	XWD	F.DIG,	F.LETT+F.LCAS	; 0	, <LOWER CASE> P
	XWD	F.DIG,	F.LETT+F.LCAS	; 1	, <LOWER CASE> Q
	XWD	F.DIG,	F.LETT+F.LCAS	; 2	, <LOWER CASE> R
	XWD	F.DIG,	F.LETT+F.LCAS	; 3	, <LOWER CASE> S
	XWD	F.DIG,	F.LETT+F.LCAS	; 4	, <LOWER CASE> T
	XWD	F.DIG,	F.LETT+F.LCAS	; 5	, <LOWER CASE> U
	XWD	F.DIG,	F.LETT+F.LCAS	; 6	, <LOWER CASE> V
	XWD	F.DIG,	F.LETT+F.LCAS	; 7	, <LOWER CASE> W
	XWD	F.DIG,	F.LETT+F.LCAS	; 8	, <LOWER CASE> X
	XWD	F.DIG,	F.LETT+F.LCAS	; 9	, <LOWER CASE> Y
	XWD	F.OTH,	F.LETT+F.LCAS	; :	, <LOWER CASE> Z
	XWD	F.OTH,	F.STR		; ;	, <LEFT BRACE>
	XWD	F.OTH,	F.STR		; <	, <VERTICAL BAR>
	XWD	F.EQAL,	F.STR		; =	, <RIGHT BRACE>
	XWD	F.OTH,	F.STR		; >	, <TILDE>
	XWD	F.STR,	F.STR		; ?	, <RUBOUT>
DEFINE FAIL (A,AC)<
	XLIST
	XWD	001000+AC'00,[ASCIZ /A/]
	LIST
>

%OPD=0	;OPDEF UUO COUNTER
DEFINE OPCNT (A)<
%OPD=%OPD+1
IFG %OPD-37,<PRINTX <TOO MANY UUO'S>>
OPDEF A	[<%OPD>B8]>
	OPCNT	(PRNM)
	OPCNT	(PRTX)
	OPCNT	(GOSUB)
	OPCNT	(ARFET1)
	OPCNT	(ARFET2)
	OPCNT	(ARSTO1)
	OPCNT	(ARSTO2)
	OPCNT	(ARSTN1)
	OPCNT	(ARSTN2)
	OPCNT	(DATA)
	OPCNT	(ADATA1)
	OPCNT	(ADATA2)
	OPCNT	(SDIM)
IFN FTMAT,<
	OPCNT	(MATRD)
	OPCNT	(MATPR)
	OPCNT	(MATSCA)
	OPCNT	(MATCON)
	OPCNT	(MATIDN)
	OPCNT	(MATTRN)
	OPCNT	(MATINV)
	OPCNT	(MATADD)
	OPCNT	(MATSUB)
	OPCNT	(MATMPY)
	OPCNT	(MATZER)
>
	OPCNT	(PRNTB)
IFN FTSTR,<
	OPCNT	(STRUUO)
	OPCNT	(SVRADR)
	OPCNT	(PRSTR)
>
	OPCNT	(DONFOR)
	OPCNT	(MATINP)
	OPCNT	(FUNCT)

MAXUUO=%OPD
STAR=.
LOC	41
	JSR	UUOH
RELOC	STAR

	INTERN UUOHAN
	EXTERN	UUOH
UUOHAN:	PUSH	P,UUOH		;RETURN ADDRS ON PUSH-DOWN LIST
	LDB	X1,[POINT 9,40,8]
IFL MAXUUO-37, <
	CAILE	X1,MAXUUO
	JRST	INLSYS		;ILLEGAL UUO.
>
UUOTBL:	JRST	.(X1)
	JRST	PRNMER
	JRST	PRTXER
	JRST	GOSBER
	JRST	AFT1ER
	JRST	AFT2ER
	JRST	AST1ER
	JRST	AST2ER
	JRST	ASN1ER
	JRST	ASN2ER
	JRST	DSKRT
	JRST	ADT1ER
	JRST	ADT2ER
	JRST	SDIMER
IFN FTMAT,<
	JRST	MTRDER
	JRST	MTPRER
	JRST	MTSCER
	JRST	MTCNER
	JRST	MTIDER
	JRST	MTTNER
	JRST	MTIVER
	JRST	MTADER
	JRST	MTSBER
	JRST	MTMYER
	JRST	MTZRER
>
	JRST	PRNTBR		;EXECUTE THE TAB FUNCTION IN "PRINT"
IFN FTSTR,<
	JRST	SUUOEX
	JRST	SAD1ER
	JRST	PRSTRR
>
	JRST	FORCOM
	JRST	MATIN
	JRST FUNC1


DSKRT:	LDB	X1,[POINT	4,40,12]
	JRST	.+1(X1)
	JRST	DATAER
	JRST	INSET
	JRST	INCLR
	JRST	EOF
	JRST	XRES
	JRST	SCATH
	JRST	IPDSK
	JRST	CODSK
	JRST	LINSST
	JRST	PRINTR
	JRST	FRMCON
	JRST	UFRMAT
	JRST	SKIPR
IFN FTSTR,<
SUUOEX:	LDB	X1,[POINT 4,40,12]	;STRING UUOS USE THE AC FIELD
	CAILE	X1,MASUUO		;AS AN EXTENSION OF THE OPCODE.
	HALT	.

UUOSTR:	JRST	.(X1)
	JRST	GETSTR
	JRST	PUTSTR
	JRST	COMSTR
	JRST	INSTR
	JRST	GETVEC
	JRST	PUTVEC
MASUUO=.-UUOSTR-1

	OPDEF	STRFET	[STRUUO 1,]
	OPDEF	STRSTO	[STRUUO 2,]
	OPDEF	STRIF	[STRUUO 3,]
	OPDEF	STRIN	[STRUUO 4,]
	OPDEF	VECFET	[STRUUO 5,]
	OPDEF	VECPUT	[STRUUO 6,]
>;ASSEMBLE ABOVE IF INCLUDING STRING FACILITY
FUNC1:	HRRZ X1,40
	JRST .(X1)
	JRST ABSB
	JRST ATANB
	JRST CLKB
	JRST COSB
	JRST COTB
	JRST DATB
	JRST DETB
	JRST EXPB
	JRST AINTB
	JRST STRLNB
	JRST ALOGB
	JRST NUMB
	JRST FRANB
	JRST SGNB
	JRST SINB
	JRST SQRTB
	JRST TANB
	JRST TIMB
	JRST DOINPT
	JRST NOLINE
	JRST JSP
	JRST PCRLF
	JRST RANDER
	JRST DOREAD
	JRST RESTON
	JRST FRETRN
	JRST RETURN
	JRST UXIT

	JRST EXP3.0
	JRST RESTOR
	JRST CHANER
JSP:	POP P,X3
	JRST XCTON
FIXUP:	CALLI 12
UXIT:	EXTERNAL	PASFLG	;TOM S.
	DEFINE R(A)
<	IRP	A
<	RELEASE	^D<A>,	>>

        SETOM ODF
        MOVEI LP,^D9
UX:     MOVE A,ACTBL-1(LP)
        CAIE A,3
        JRST .+3
        SKIPE HPOS(LP)
        PUSHJ P,CRLF3
        SOJG LP,UX
        SETZM  ODF
	SKIPE	CONLOC		;POSSIBLE CONTINUE?
	JRST	UXIT3		;YES.  DON'T RELEASE THE CHANNELS YET!
        R<1,2,3,4,5,6,7,8,9>
	CLOSE	LPT,
	SKIPE PRNTSW
	PUSHJ P,LPTER
	JRST UXIT2
LPTER:	SETZM PRNTSW
	SETZ 7,
	MOVE N,[XWD 17,11]
	CALL N,[SIXBIT/GETTAB/]
	SETZ N,
	TLNE N,400	;SKIP IF LEVEL C
	TLO 7,1	;LEV D
	SETZM	PRNTSW
	MOVE	N, CURNAM
	MOVEM	N, FILDIR
	HLLZ	N, FILEXT
	HLLM	N, FILDIR+1
	CLEARM	FILDIR+3
	MOVSI	N, 455000
	TLNE 7,1
	MOVSI N,155000	;LEV D
	IORM	N, FILDIR+2	;PROTECT FILE FOR NOW.
	RENAME	LPT, FILDIR
	JFCL				;IF YOU CAN.
UXIT0:	CLOSE	LPT,
	TLNE 7,1
	PUSHJ P,LEVD
	SETSTS	LPT,16		;CHANGE TO DUMP MODE
	MOVE	N, [SIXBIT/PNT000/]
	MOVSI	T, (SIXBIT/TMP/)
	MOVEM	T, FILDIR+1
UXIT1:	MOVEM	N, FILDIR
	MOVE	T, STKPP
	MOVEM	T, FILDIR+3
	HLLZS FILDIR+1
	SETZM FILDIR+2
	LOOKUP	LPT, FILDIR
	JRST	.+2		;LOOKUP FAILED.  GOOD
UXIT1A:	AOJA	N, UXIT1
	MOVE	T, FILDIR+1
	TRNE	T, -1		;IF A LOOKUP FAILURE 0
	JRST	.-3
	MOVE	T, STKPP
	MOVEM	T, FILDIR+3
	HLLZS FILDIR+1
	SETZM FILDIR+2
	ENTER	LPT, FILDIR	;NOW TRY AN ENTER
	JRST UXIT1A
	TLNE 7,1
	JRST LEVD1
	CALLI	N, 24		;GET PPNR
	MOVEM	N, DO10
	MOVE	N, CURNAM
	MOVEM	N, DO10+1
	MOVE	N, FILEXT
	HRRI	N, 400055	;SET TO DELETE AFTER PRINTING
	MOVEM	N, DO10+2
	MOVE	N, [IOWD 3,DO10]
UXIT1B:	CLEAR	T,
	OUTPUT	LPT,N
	STATZ	LPT,740000
	JRST	INLSYS
	RELEAS	LPT,
	POPJ P,
UXIT2:	SETZM FMTFLG
	SKIPE	MTIME		;IS THERE SOME RUN TIME?
	PUSHJ	P,RTIME
UXIT3:	SETZM	RUNFLA	
	CALLI 12

LEVD:	MOVEI 0,16
	MOVEM 0,PAT 
	SETZM PAT+1
	MOVE 0,[XWD PAT+1,PAT+2]
	BLT 0,PAT+16
	MOVE 0,[XWD FILDIR,PAT+2]
	BLT 0,PAT+3
	HLLZS PAT+3
	LOOKUP LPT,PAT
	JFCL

LEVD2: MOVE 0,PAT+3
	HRRI 0,400155
	MOVEM 0,PAT+3
	MOVE 0,PAT+16
	MOVEM 0,PAT+4
	POPJ P,

LEVD1: MOVE 0,[IOWD 4,PAT+1]
	JRST UXIT1B

CHANER: R<1,2,3,4,5,6,7,8,9>
	CLOSE LPT,
	SKIPE PRNTSW
	PUSHJ P,LPTER
	SKIPE MTIME
	PUSHJ P,RTIME
	SETZM TMPLOC
	MOVE N,@(P)
	MOVEM N,PAT
	MOVSI N,(SIXBIT/RUN/)
	MOVEM N,PAT+1
	SETZM PAT+2
	SETZM PAT+3
	INIT 0,16
	SIXBIT/DSK/
	0
	HALT .-3
	LOOKUP 0,PAT
	JRST CHAN1
	SETOM TMPLOC
	JRST TEMPF
CHAN1:	MOVSI N,(SIXBIT/BAS/)
	MOVEM N,PAT+1
	SETZM PAT+2
	SETZM PAT+3
	LOOKUP 0,PAT
	JRST NOGET
TEMPF:	PUSHJ P,NOTEMP
	MOVE 0,[IOWD 5,BASTMP]
	MOVEM 0,INLST
	SETZM INLST+1
	MOVE 0,[XWD PAT,BASTMP]
	BLT 0,BASTMP+3
	SETZM BASTMP+4
	SETZM BASTMP+2
	SETZM BASTMP+3
	HLLZS BASTMP+1
	ENTER 0,T1
	JFCL
	OUTPUT 0,INLST
	CLOSE 0,
	MOVEI 0,SBAS
	SKIPE TMPLOC
	MOVEI 0,RUNTIM
	CALL 0,[SIXBIT/RUN/]
	HALT

SBAS:SIXBIT/SYS/
	SIXBIT/SBAS/
	0
	0
	0
	0
RUNTIM: SIXBIT/SYS/
	SIXBIT/RUNTIM/
	0
	0
	0
	0


STKPP:	XWD	3,3		;WHERE PRINTR CMD FILES LIVE
COMM1B:	OUTPUT
	RESET
	PUSHJ	P, TTYIN
	PUSHJ	P, INLMES
	ASCIZ/
/
	CALLI 12
NODEV:	PUSHJ	P,TTYIN
	PUSHJ	P,INLMES
	ASCIZ /NO SUCH DEVICE
/
	JRST	COMM1B
LASTCH:	PUSHJ P,BACK1
	LDB C,T
	HLL C,CTTAB(C)
	TRNE C,100
	HRL C,CTTAB-100(C)
	TLNE C,F.SPTB	;SPACE OR TAB?
	JRST LASTCH	;YES BACK UP ANOTHER
	POPJ P,
QSKIP:	PUSHJ	P,NXCH		;SKIP TO NEXT QUOTE CHAR.
	CAME	C, [XWD F.STR,"\"]
	JRST	.+6
	PUSHJ	P, NXCH
	TLNN	C, F.CR
	JRST	.+5
	PUSHJ	P, LASTCH	;PICK UP THE \ AGAIN
	JRST	CPOPJ1
	TLNE	C,F.CR		;TERMINAL QUOTE MISSING?
	JRST	CPOPJ1		;YES.  ALLOW
	TLNN	C,F.QUOT	;END OF STRING?
	JRST	QSKIP		;NO, GO ON.
	PUSHJ	P,NXCH		;YES. GET NEXT CHAR AND RETURN.
	JRST	CPOPJ1
TTYIN:	SETZM	TABFG		;FORMAT ON TABS
	MOVEI	T,TTYBUF	;SET UP TTY BUFFS
	MOVEM	T,JOBFF
	INIT	1
	SIXBIT	/TTY/
	XWD	TYO,TYI
	HALT	.-3
	INBUF	1
	OUTBUF	1
	POPJ	P,

	SUBTTL UTILITY SUBROUTINES
;SUBROUTINES FOR GENERAL ROLL MANIPULATION

OPEN2:	MOVE	X2,E		;IS THERE ROOM ABOVE THIS STODGY ROLL?
	ADD	X2,CEIL(R)	;THE NEW CEILING
	CAMLE	X2,FLOOR+1(R)
	JRST	OPENU0		;NO ROOM, PACK OTHER ROLLS UP
	ADDM	E,CEIL(R)	;THERE IS ROOM, INCREMENT CEILING
	POPJ	P,

OPENU0:	SUB	B,FLOOR(R)
	PUSHJ	P,PANIC
	ADD	B,FLOOR(R)

OPENUP:	CAMG	R,TOPSTG		;OPEN UP THE TOP STODGY ROLL?
	JRST	OPEN2		;YES. OPEN UPWARDS, NOT DOWN
	MOVN	X2,E
	MOVE	X3,TOPSTG	;DO NOT MOVE STODGY ROLLS
	ADD	X2,FLOOR+1(X3)
	CAMGE	X2,CEIL+0(X3)
	JRST	OPENU0		;NEED MORE ROOM
	HRL	X2,FLOOR+1(X3)	;CONSTRUCT BLT WORD
	SUB	B,E		;FIRST WORD OF GAP
	BLT	X2,-1(B)	;MOVE ROLLS DOWN

	MOVEI	X1,1(X3)		;ADJUST POINTERS FOR ROLLS JUST BLT'D.
	MOVN	X2,E
OPEN1:	ADDM	X2,FLOOR(X1)
	CAML	X1,R
	POPJ	P,
	ADDM	X2,CEIL(X1)
	AOJA	X1,OPEN1


;RPUSH - PUSH A ON TOP OF DESIGNATED ROLL

RPUSH:	MOVEI	E,1
	PUSHJ	P,BUMPRL	;MAKE ROOM
	MOVEM	A,(B)		;STORE WORD
	POPJ	P,

;ROUTINE TO ADD TO END OF ROLL
;E CONTAINS SIZE, R CONTAINS ROLL NUMBER

BUMPRL:	MOVE	B,CEIL(R)
	ADD	B,E
	CAIE	R,ROLTOP
	SKIPA	X1,FLOOR+1(R)
	HRRZ	X1,JOBREL
	CAMLE	B,X1
	JRST	BUMP1
	EXCH	B,CEIL(R)
	POPJ	P,

BUMP1:	MOVE	B,CEIL(R)
	CAIE	R,CODROL
	CAIN	R,SEXROL
	JRST	.+2
	JRST	OPENUP
	ADDI	E,^D10		;***EXTRA 10 LOCS
	PUSHJ	P,OPENUP
	MOVNI	X1,^D10	;TAKE BACK THE 10 LOCS
	ADDM	X1,CEIL(R)
	POPJ	P,


;BINARY SEARCH OF SORTED ROLL
;CALL WITH KEY IN A
;RETURN IN B ADDRS OF FIRST
;ENTRY NOT LESS THAN KEY
;SKIP RETURN IF LEFT SIDES EQUAL

SEARCH:	MOVE	B,FLOOR(R)
	SKIPA	X1,CEIL(R)
SEAR1:	MOVEI	B,1(X2)
	CAIGE	B,(X1)
	JRST	SEAR2
	CAML	B,CEIL(R)
	POPJ	P,
	JRST	SEAR3

SEAR2:	MOVEI	X2,@X1
	ADD	X2,B
	ASH	X2,-1
	CAMLE	A,(X2)
	JRST	SEAR1
	HRRI	X1,0(X2)
	CAIGE	B,(X1)
	JRST	SEAR2

SEAR3:	HLLZ	X3,(B)
	CAMN	X3,A
	AOS	(P	POPJ	P,
;ROUTINE TO QSA FOR "THEN" OR "GOTO" (USED IN "IF", "ON" STATEMENTS)
THENGO:	PUSHJ	P,QSA
	ASCIZ /THEN/
	CAIA
	POPJ	P,
	PUSHJ	P,QSA
	ASCIZ /GOTO/
	FAIL <ILLEGAL FORMAT>
	POPJ	P,

;COMMON SUBROUTINE RETURNS

CPOPJ1:	AOS	(P)
CPOPJ:	POPJ	P,

;ROUTINES TO ALLOW AND DELAY REENTRY.
;LOCKON TEMPORARILY PREVENTS REENTRY
;LOCKOF ALLOWS REENTRY AND REENTERS IF THERE IS A STANDING REQUEST
;REENTR MAKES A REENTRY OR MAKES A REQUEST AND CONTINUES
LOCKON:	SKIPGE	RENFLA
	SETZM	RENFLA		;TURN ON REENTER PROTECT
	POPJ	P,

LOCKOF:	SKIPLE	RENFLA
	JRST EXECUT
	SETOM	RENFLA		;ALLOW REENTER
	POPJ	P,

REENTR:	SETZM	PRNTSW		;CLEAR LINE PRINTER SWITCH
	SETZM	CONLOC		;AND THE "PROCEED" POINTER
	SKIPGE	RENFLA
	JRST EXECUT
	AOS	RENFLA		;MAKE REQUEST BY SETTING FLAG PLUS
	JRST	2,@JOBOPC


IFN INTRSW,<;******* CODE TO HANDLE INTERUPT TOM S. 18-AUG-70
INTRPT:	JUMPLE	L,INTRP1+1
	SKIPN	FLOFLG		;ADDITION TOM S. 11-NOV-70
	JRST	INTRP1
	PUSHJ	P,INLMS0
	ASCIZ	/AT- /
	PUSHJ	P,GOSR3
	OUTPUT		;END MOD TOM
INTRP1:	TTCALL	2, C		;DID HE SAY SOMETHING
	POPJ	P,		;NO GO AWAY
	CAIE	C, 7		;YES.	MIGHT IT BE BONG ?!
	POPJ	P,		;NOPE GO AWAY THEN
INTRP0:	POP	P,T1		;YES FAKE A JSP
	EXTERNAL	BELFLG
	SETOM	BELFLG	
	JRST	UPAUSE		;DO A PAUSE
	;******** END MOD T.S.>

;ROUTINE TO READ CHARACTER, SKIPPING BLANKS
;CALL:	MOVE	T,<POINTER TO CHAR BEFORE FIRST>
;	PUSHJ	P,NXCH
;	...	RETURN, C:= (<FLAGS>)CHARACTER

NXCHS:	ILDB	C,T		;DOESNT SKIP TAB OR BLANK
	CAIE	C," "
	CAIN	C,11
	POPJ	P,
	CAIA			;SKIP INTO NXCH

NXCH:	ILDB 	C,T		;FETCH NEXT CHARACTER
	HLL	C,CTTAB(C)	;GET FLAGS FROM CTTAB
	TRNE	C,100
	HRL	C,CTTAB-100(C)
	TLNE	C,F.SPTB	;SPACE OR TAB?
	SKIPE NOSKIP	;SEE IF WE SHOULD IGNORE
	POPJ P,	;NO USE SPACE OR TAB AS DELIMITER
	JRST	NXCH		;YES. IGNORE
NXCHD:	ILDB C,T
NXCHD2:	HLL C,CTTAB(C)
	TRNE C,100
	HRL C,CTTAB-100(C)
	POPJ P,


;GET NEXT CHAR, BUT CHECK FOR ILLEGAL CHARS (CHARS THAT COULD ONLY BE IN A STRING)

;QUOTE SCAN AND TEST
;CALL WITH PATTERN ADDRS IN X1
;SKIP IF EQUAL.	C,T UPDATED TO LAST CHAR SCANNED.
QST:	HRLI	X1,440700	;MAKE BYTE PNTR TO PATTERN
QST1:	ILDB	X2,X1		;GET PATTERN CHAR
	JUMPE	X2,CPOPJ1	;DONE ON NULL
	SUBI	X2,(C)
	JUMPE	X2,.+4		;DO CHARACTERS MATCH?
	TLNE	C,F.LCAS	;NO. LOWER CASE LETTER?
	CAME	X2,[ EXP -40]	;YES. SAME LETTER OF ALPHABET?
	JRST	QST2		;NO. MATCH FAILS
	PUSHJ	P,NXCH
	JRST	QST1
QST2:	ILDB	X2,X1		;ON FAIL
	JUMPN	X2,.-1		;SKIP TO NULL
	POPJ	P,


;QUOTE SCAN WITH ANSWER
;CALL WITH INLINE PATTERN
;SKIP ON SUCCESS		;ON FAIL, RETURN WITH C,T RESTORED

QSA:	POP	P,X1		;GET PATTERN ADDRESS
	PUSH	P,C		;SAVE C,T
	PUSH	P,T
	PUSHJ	P,QST		;SAVE STRING
	JRST 	.+2
	JRST	QSA1		;MATCH
	POP	P,T		;NO MATCH.  BACK UP
	POP	P,C
	JRST	1(X1)

QSA1:	POP	P,X2
	POP	P,X2
	JRST	2(X1)


	EXTERN	STODSK
;ROUTINE TO READ A LINE INTO LINB0
;CALL:	PUSHJ	P,INLINE

INLINE:	PUSH	P, X1
	SETZ	X1,
	SETO	T1,
	SKIPE	IFIFG
	SKIPA	T, LINPT(LP)
	MOVE	T, LINPT
	JRST	INLI1A
INLI1:	SKIPE	IFIFG
	JRST	INLA
	ILDB	C, TYI+1
	JRST	INLB
INLA:	SOSGE	@INCNT-1(LP)
	PUSHJ P,DSKIN
INLA2:	ILDB	C,@INPT-1(LP)
INLB:IFN INTRSW,<CAIN	C, 7		;INTERRUPT REQUEST?
	JRST	INTR		;YES.  GO>
	CAIE	C,15		;CR?
	CAIN	C, 0
	SOJA	T1, INLI1A
	CAIN	C,"_"		;DELETE?
	JRST	INLI3		;YES
	CAIE	C,30		;<CONTROL-X>?
	CAIN	C,175		;ALTMODE?
	JRST	INLI4		;YES.  IGNORE LINE
	CAIE	C, 176
	CAIN	C, 33		;SOME OTHER KIND OF ALTMODE?
	JRST	INLI4
	CAIE	C,21	;IGNORE XON,XOFF
	CAIN	C,23
	SOJA	T1,INLI1A
	CAIG	C,14		;LINE TERMINATOR?
	CAIGE	C,12
	CAIA
	JRST	INLI2		;YES.  GO FINISH UP
INLB2:	CAIGE	T1,^D94	;ROOM FOR CHAR+1 MORE? (5*23-1)
	IDPB	C,T		;STORE CHAR
INLI1A:	SKIPE	IFIFG
	AOJA	T1,INLI1
	SOSLE	TYI+2		;MORE INPUT?
	AOJA	T1,INLI1	;YES.  BUMP COUNT AND GO GET MORE
	INPUT
	STATZ	20000
	JRST	BASIC0
	STATO	740000
	AOJA	T1,INLI1
INLSYS:	PUSHJ	P,TTYIN
	PUSHJ	P,INLMES
	ASCIZ /SYSTEM ERROR/
	JRST	UXIT

INLI2:	MOVEI	C,15		;DONE.  PUT CR IN BFR.
	IDPB	C,T
	POP	P,X1
RESCAN:	SKIPN	IFIFG
	SKIPA	T,LINPT
	MOVE	T,LINPT(LP)
	SKIPE	IFIFG
	JRST	INLI8
	SETZM	HPOS		;CARRIAGE POSITION := LFT MRGN
	JRST	NXCH		;GET FIRST CHAR AND RETURN
INLI8:	SETZM	HPOS(LP)
	JRST	NXCH

INLI3:	JUMPLE	T1,INLI1B	;BACKARROW HANDLER.  IGNORE IF AT LEFT
	PUSHJ	P, BACK1	;BACK UP BYTE POINTER
	SUBI	T1,2
	JRST	INLI1A
INLI1B:	SETO	T1,
	JRST	INLI1A

INLI4:	MOVEI	T,DELMSG	;ACKNOWLEDGE ALTMODE
	CALL	T,[SIXBIT /DDTOUT/]

	POP	P,X1
	JRST	INLINE

DELMSG:	ASCIZ	/ DELETED
/




DSKIN:  DPB     LP,[POINT 4,INDSK,12] ;DISK INPUT
	XCT	INDSK
	DPB	LP,[POINT 4,STADSK,12]
	XCT	STADSK
	JRST	EOFFAL
	DPB	LP,[POINT 4,STODSK,12]
	XCT	STODSK
	POPJ P,
	POP P,	;ERROR
	JRST INLSYS

	EXTERN	INDSK

	EXTERN	THELIN


BASIC0:	SETZM	CCLFLG
	SETZM	CCRNFL
	PUSHJ	P, TTYIN	;GRAB A TTY
	JRST EXECUT

;ROUTINE TO BACK UP BYTE POINTER IN T ONE OR TWO BYTES:

BACK1:	PUSH	P, C
	MOVEI	C, 4
	IBP	T
	SOJG	C, .-1
	SUBI	T, 1
	POP	P, C
	POPJ	P,

;PRINTING SUBROUTINES

;PRINT TO QUOTE CHAR
;CALL:	MOVE	T,<ADDRS OF MSG>
;	MOVE	D,<QUOTE CHAR>
;	PUSHJ	P,PRINT

;ALTERNATE CALL: PRINT1, IF BYTE PNTR IN T.


PRINT:	HRLI	T,440700
PRINT1:	ILDB	C,T
	CAMN	C,D
	POPJ	P,
	CAIE	D, 42		;QUOTE STRING?
	JRST	.+12
	CAIE	C, "\"
	JRST	.+6
	ILDB	T1, T
	CAIN	T1, 15
	POPJ	P,
	PUSHJ	P, OUCH
	MOVE	C, T1
	CAIN	C, 15		;YES.  TERMINAL QUOTE MISSING?
	POPJ	P,		;YES.  ALLOW
	SKIPE	FMTFLG
	SOJL	A, PRINT1
	PUSHJ	P,OUCH		;OUTPUT THE CHAR
	JRST	PRINT1


OUCH:	SKIPE	ODF
	JRST	DSKOT
	SOSG	TYO+2
	OUTPUT
	IDPB	C,TYO+1
OUCH1:	SKIPN	ODF
	JRST	OUCH2
	CAIE	C,12
	AOSA	HPOS(LP)		;UPDATE LINE LOCATION COUNT
	SETZM	HPOS(LP)
	POPJ	P,
OUCH2:	CAIE	C,12
	AOSA	HPOS
	SETZM	HPOS
	POPJ	P,
DSKOT:	SOSG	@OUTCNT-1(LP)
	JRST	DOS
DSKOT2:	IDPB	C,@OUTPT-1(LP)
	JRST	OUCH1
DOS:	DPB	LP,[POINT 4,OUTDSK,12]
	XCT	OUTDSK
	JRST	DSKOT2

;ROUTINE TO PRINT SIXBIT CHARACTERS IN ACCUM "T".
;IGNORES BLANKS.


PRNSIX:	MOVE	T1,[POINT 6,T]
	ILDB	C,T1
	JUMPE	C,PRNS1		;SKIP A BLANK
	ADDI	C,40
	PUSHJ	P,OUCH
PRNS1:	TLNE	T1,770000		;ALL SIX PRINTED?
	JRST	PRNSIX+1
	POPJ	P,


;SPECIAL DECIMAL PRINT ROUTINE.  PRINTS X1,X2,X3 AS DECIMAL NUMBERS
;SEPARATED BY THE CHARACTER IN ACCUM "A".  IF X1 IS ZERO IT IS SKIPPED.
;IF X2 OR X3 ARE ZERO, THEY PRINT AS "00"

PRDECS:	JUMPE	X1,PRDE2
	MOVE	T,X1
	PUSHJ	P,PRDE1
	MOVE	C,A
	PUSHJ	P,OUCH
PRDE2:	MOVE	T,X2
	PUSHJ	P,PRDE1
	MOVE	C,A
PRDE2A:	PUSHJ	P,OUCH
	MOVE	T,X3
	MOVEI	A,177
PRDE1:	MOVEI	C,"0"		;A ONE DIGIT NUMBER?
	CAIG	T,^D9
	PUSHJ	P,OUCH			;YES. PUT OUT LEADING ZERO.
	JRST	PRTNUM

;SPECIAL RUNTIME PRINTER
RTIME:	SKIPN	PDP6SW	;PDP10?
	SKIPN	MTIME		;ANY TIME TO RECORD?
	POPJ	P,		;NO.
	PUSHJ	P,INLMES
	ASCIZ /

EXECUTION TIME:  /
	MOVEI	X2, 0
	CALL	X2,[SIXBIT /RUNTIM/]
	SUB	X2,MTIME	;GET DIFFERENCE
	IDIVI	X2,^D10
	IDIVI	X2,^D100	;GET SECS AND HUNDREDTHS
	MOVE	T,X2
	JUMPE	X2,.+2
	PUSHJ	P,PRTNUM
	MOVEI	C,"."
	PUSHJ	P,PRDE2A
	PUSHJ	P,INLMES
	ASCIZ	/ SECS.
/
	SETZM	MTIME
	OUTPUT
	POPJ	P,

;NUMBER PRINTER (PRINTS INTEGER IN T)


PRTNUX:	TDZA	X1,X1		;CHECK WHETHER ROOM FOR ZERO BEFORE PRINT.
	MOVE	X1,B		;CHECK ROOM FOR INT. OF THIS SIZE " "
	SKIPE	FMTFLG
	JRST	DOISPC		;FORMATTED I-SPEC #
	MOVEI	X1,5(X1)
	PUSHJ	P,CHROOM
	
PRTNX0:	PUSHJ	P,PSIGN

PRTNUM:	IDIVI	T,^D10
	JUMPE	T,PRTN1
	PUSH	P,T1
	PUSHJ	P,PRTNUM
	POP	P,T1
PRTN1:	MOVEI	C,60(T1)
	JRST	OUCH



DOISPC:	JUMPN	T, .+2
	SETZ	N,		;PREVENT "-0"
	PUSHJ	P, PRTNX0	;PRINT THIS NUMBER
	JRST	NXTSPC		;THEN GO INTERPRET THE NEXT FORMAT SPEC.


PSIGN:	SKIPN TMPLOC
	JRST .+3
	SETZM TMPLOC
	POPJ P,
	MOVEI	C," "		;PRINT "SIGN" (BLANK OR MINUS)
	JUMPGE	N,PSIGN1
	SKIPE FMTFLG	;IS FORMATTING IN EFFECT
	JRST PSIGN1-1	;YES
	MOVEI C," "	;NO GET A BLANK IN THERE
	PUSHJ P,OUCH
	MOVEI	C,"-"
PSIGN1:	JRST	OUCH
	

;MESSAGE PRINTER

INLMS0:	SETZM	ODF
	SETZM	FMTFLG
INLMES:	EXCH	T,(P)	;GET MSG ADR AND SAVE T.
	MOVEI	D,0		;END ON NULL
	PUSHJ	P,PRINT		;PRINT THE MESSAGE
	EXCH	T,(P)
	JRST	CPOPJ1	;RTN AFTER MSG.

	SUBTTL CORE COMPRESSION AND EXPANSION
;PANIC - ROUTINE TO COMPRESS CORE

PANIC:	PUSHJ	P,PRESS		;COMPRESS MEMORY
	MOVE	X3,TOPSTG	;IS THERE ROOM BETWEEN STODGY AND
	MOVE	X1,FLOOR+1(X3)	;MOVEABLE ONES?
	SUB	X1,CEIL(X3)
	CAML	X1,E		;ENOUGH ROOM?
	POPJ	P,

	MOVE	X1,JOBREL	;EXPAND BY 1K
	ADDI	X1,2000
	CALL	X1,[SIXBIT /CORE/]
	JRST	.+2		;CANT
	JRST	PANIC		;OK.  GO MOVE ROLLS

PANIC1:	PUSHJ	P,INLMS0
	ASCIZ	/OUT OF ROOM/
	JRST	UXIT


PRESS:	PUSH	P,G		;SAVE AC
	SKIPN	PAKFLA		;ARE LINES PACKED?
	JRST	PRESS5		;YES
	SETZM	PAKFLA

PRESS1:	MOVE	X1,FLTXT	;LOOK FOR EMPTY SPACE
PRESS2:	CAML	X1,CETXT		;TRHOUGH LOOKING?
	JRST	PRESS5
	SKIPE	(X1)		;A FREE WORD?
	AOJA	X1,PRESS2	;NO

	MOVEI	X2,1(X1)	;YES
PRESS3:	CAML	X2,CETXT
	JRST	PRESS4		;FREE TO END
	SKIPN	(X2)
	AOJA	X2,PRESS3	;LOOK FOR NON-FREE WORD

	SUB	X1,X2		;X1 :=-LNG OF MOVE
	MOVE	X3,FLLIN
PRES3A:	CAML	X3,CELIN	
	JRST	PRES3B
	HRRZ	G,(X3)
	CAML	G,X2
	ADDM	X1,(X3)
	AOJA	X3,PRES3A

PRES3B:	MOVE	G,CETXT
	ADD	G,X1
	MOVEM	G,CETXT
	ADD	X1,X2
	HRL	X2,X1
	MOVSS	X2
	BLT	X2,-1(G)
	JRST	PRESS2

PRESS4:	MOVE	X3,X1	;KLUDGE IF FREE TO END--MOVE IT ABOVE
	SUB	X3,X1
	ADDM	X3,CETXT
;ROUTINE TO MOVE ROLLS UP

PRESS5:	MOVEI	G,ROLTOP	;HIGHEST MOVABLE ROLL
	MOVE	X1,JOBREL	;X1 IS PREVIOUS FLOOR
				;NOTE: TOP WORD OF USR CORE IS LOST

PRESS6:	MOVE	X2,CEIL(G)	;GET OLD CEIL AND FLOOR
	MOVE	X3,FLOOR(G)
	SUBI	X2,1		;SET UP X2 FOR POP LOOP
	ORCMI	X2,777777
	MOVEM	X1,CEIL(G)	;NEW CEILING

PRESS7:	CAILE	X3,(X2)		;DONE?
	JRST	PRESS8
	POP	X2,-1(X1)	;MOVE ONE WORD
	SOJA	X1,PRESS7

PRESS8:	MOVEM	X1,FLOOR(G)	;NEW FLOOR
	SOS	G		;GO TO NEXT LOWER ROLL
	CAMLE	G,TOPSTG	;IS THIS ROLL MOVEABLE?
	JRST	PRESS6		;YES. GO PRESS IT.
PRESS9:	POP	P,G	;RESTORE G
	POPJ	P,	;RETURN

;SPACE CHECK, PANIC AND PRESS FOR VARIABLE SPACE, WHICH
;RANGES FROM (VARBOT) TO (JOBREL).  NEXT AVAILABLE WORD IS
;(VARFRE). THE MAXIMUM LENGTH ALLOWED FOR A LITERAL OR
;INPUT STRING IS

LITLEN=^D21

;IN WORDS.

VCHECK:	MOVEI	E,LITLEN	;CALCULATE WORD LENGTH. ASSUME LITLEN
	SKIPGE	G		;STRING LITERAL?
	PUSHJ	P,MCHPWD	;NO. CHANGE MINUS CHARS TO PLUS WORDS
VCHE1:	MOVE	X1,VARFRE	;IS THERE ROOM FOR A STRING OF WORD LENGTH (E)?
	ADD	X1,E
	CAMGE	X1,FLSTM
	POPJ	P,		;YES.

VPANIC:	SKIPE	VPAKFL	;CAN WE MAKE ROOM WITH A GARBAGE COLLECTION?
	JRST	.+5	;NO, ASK FOR CORE
	PUSH	P, C
	PUSHJ	P,VPRESS	;POSSIBLY.
	POP	P, C
	JRST	VCHE1	;TRY AGAIN

	MOVE	X1,JOBREL		;CALL FOR MORE CORE.
	ADDI	X1,2000
	CALL	X1,[SIXBIT /CORE/]
	JRST	PANIC1		;CANT GET CORE
	PUSH	P,E	;TOM SALEH 10-31-70
	PUSH	P,[.+3]	;T.S.
	PUSH	P, G
	JRST	PRESS5	;PRESS GOOD POINTERS UPWARDS
	POP	P,E	;TOM S. FOR UOT OF ROOM  FIX
	JRST	VCHE1	;T.S.

;THE ROLL VSPROL CONTAINS POINTERS INTO VARIABLE SPACE.  EACH ENTRY
;CONTAINS	0   [NO SPACE ASSIGNED]
;		XWD -(LENGTH IN CHARS),ADDRESS FIRST WORD

VPRESS:	PUSH	P,G
IFN FTSTR,<
	PUSH	P,E
	MOVE	G,VARBOT

VPR0:	HRRZI	X2,-1		;THE LOWEST ADDRESS WILL GO INTO X1
	MOVE	X3,FLVSP	;X3 POINTS TO EACH ENTRY ON THE ROLL.
	SETZI	X1,		;X1 WILL GET THE LOC OF NEXT LOWEST POINTER

VPR1:	CAML	X3,SVRTOP
	JRST	VPR2		;SEARCH FOR MINIMUM IS OVER.
	CAMN	X3,CEVSP	;STARTING TO SCAN VSPROL?
	MOVE	X3,SVRBOT	;YES. NOW SCAN STRING VECTOR SPACE.
	HRRZ	E,(X3)		;GET POINTER ADDRESS.
	JUMPE	E,VPR11		;NULL POINTER?
	CAML	E,G		;HAVE WE MOVED THIS STRING ALREADY?
	CAMG	X2,E		;NO, IS IT A LOWER STRING ADDRESS?
VPR11:	AOJA	X3,VPR1		;NO. LOOK AT NEXT STRING.

	MOVE	X1,X3		;WE HAVE FOUND A STRING WITH LOWER ADDRESS.
	MOVE	X2,E
	AOJA	X3,VPR1

VPR2:	JUMPE	X1,VPR3		;ANY MORE STRINGS TO MOVE?
	HLRE	E,(X1)		;CALCULATE WORD LENGTH..
	JUMPN	E,.+3		;IS THIS A NULL STRING?
	SETZM	(X1)		;YES. IGNORE IT.
	JRST	VPR0

	HRL	G,(X1)		;GET THE OLD ADDRESS OF THIS STRING
	MOVN	C,E		;GET WORD LENGTH
	CAIL	C,1000		;****PATCH FOR NULL STRINGS
	MOVEI	C,1		;****
	ADDI	C,4
	IDIVI	C,5
	MOVE	E,C
	ADDI	E,-1(G)
	HRRZ	X2,(X1)		;GET THE OLD STRING ADDRESS
	CAIN	X2,(F)		;IS THIS THE STRING WE ARE NOW MOVING?
	HRRM	G,F		;YES, UPDATE OUR CURRENT POINTER
	HRRM	G,(X1)		;STORE THE NEW ADDRESS
	BLT	G,(E)	;MOVE THE STRING DOWN
	AOS	G,E		;LOOK FOR A HIGHER ADDRESS NEXT TIME
	MOVEM	E,VARFRE
	JRST	VPR0

VPR3:	POP	P,E
>;ASSEMBLE IF INCLUDING STRING FACILITY
	SETOM	VPAKFL		;STRINGS ARE TIGHTLY PACKED.
	JRST	PRESS9		;POP G AND EXIT.
	
SUBTTL DECIMAL NUMBER EVALUATE/PRINT
;ROUTINE TO EVALUATE NUMBER
;T: PNTR TO FIRST CHAR, C: FIRST CHAR
;NON-SKIP IS FAIL RETURN
;RETURN NUMBER IN N

;N: ACCUM NBMR, B: SCA FAC, D: DIG CNT, USE FLGS IN LEFT OF F
;********** ROUTINE TO ACCEPT BLANK AS FILE DELIMETER TOM SALEH
NXCHB:	SKIPN	CHRFLA	;IS USER PROGRAM RUNNING
	JRST	NXCH	;NOPE GUESS WE DON'T WANT TO SEE BLANKS
	JRST	NXCHS	;LET IT SEE BLANKS
;********** THATS ALL 30-OCT-70

EVANUM:	SETZB	N,B		;CLEAR ACS
	MOVEI	D,8
	MOVEI	F,(F)		;CLEAR LH OF F

	TLNE	C,F.PLUS	;SKIP +
	JRST	EVAN1
	TLNN	C,F.MINS	;CHECK FOR -
	JRST	EVAN2		;NO
	TLO	F,F.MIN		;SET MINUS FLG
EVAN1:	PUSHJ	P,NXCHB		;SKIP TO NXT CHR  MOD TOM S.
EVAN2:	TLNN	C,F.DIG		;DIGIT?
	JRST	EVAN3		;NO

	TLO	F,F.NUM		;DIGIT SEEN FLAG
	JUMPE	N,EVAN2A	;DONT COUNT LEADING ZEROS
	SOJG	D,EVAN2A	;COUNT DIGIT,  GO ACCUM IF OK
;			REST OF DIGITS ARE INSIGNIFIGANT.
	AOJA	B,EVAN2B	;LEAD OR TRAIL 0, FUDGE SCA FAC

EVAN2A:	IMULI	N,^D10		;ACCUMULATE DIGIT
	ADDI	N,-60(C)
EVAN2B:	TLNE	F,F.DOT		;DECIMAL SEEN?
	SUBI	B,1		;YES.  COUNT DOWN SCALE FACT
	JRST	EVAN1		;GO TO NEXT CHAR

EVAN3:	TLNN	C,F.PER		;NOT DIGIT.  DEC PNT?
	JRST	EVAN4		;NO.
	TLOE	F,F.DOT		;YES, SET FLG & CHK ONLY ONE
	POPJ	P,		;2 DEC PNTS
	JRST	EVAN1

EVAN4:	TLNN	F,F.NUM		;DID WE SEE A DIGIT?
	POPJ	P,		;NO.  WHAT A LOUSY NUMBER
	MOVEI	X1,"E"
	CAIE	X1,(C)		;EXPLICIT SCALE FACTOR?
	JRST	EVAN8		;NO
	PUSHJ	P,NXCHB		;DO LOOK AHEAD  MOD TOM S.
	TLNE	C,F.PLUS	;SCALE FACTOR SIGN
	JRST	EVAN5
	TLNN	C,F.MINS
	JRST	EVAN6
	TLO	F,F.MXP
EVAN5:	PUSHJ	P,NXCHB		;GET FIRST DIG AFTER SIGN  MOD TOM S.
EVAN6:	TLNN	C,F.DIG		;CHK FOR DIGIT
	POPJ	P,
	MOVEI	A,-60(C)	;SAVE FIRST EXPON DIGIT
	PUSHJ	P,NXCHB		;MOD TOM S.
	TLNN	C,F.DIG		;IS THERE A SECOND DIGIT
	JRST	EVAN7		;NO
	IMULI	A,^D10		;YES.  ACCUMULATE IT
	ADDI	A,-60(C)
	PUSHJ	P,NXCHB		;DO LOOK AHEAD  MOD TOM S.

EVAN7:	TLNE	F,F.MXP		;NEG EXPON?
	MOVN	A,A		;YES.  NEGATE IT
	ADD	B,A		;ADD TO SCALE FACTOR
EVAN8:	JUMPE	N,CPOPJ1	;IGNORE SCALE IF NUMBER IS 0
EVAN8A:	MOVE	X1,N		;)
	IDIVI	X1,^D10		;)REMOVE ANY TRAILING ZEROS
	JUMPN	X2,EVAN8B	;)  IN MANTISSA.  (REASON:
	MOVE	N,X1		;)  SO THAT, E.G., .1,
	AOJA	B,EVAN8A	;)  .10, .100, ..., ARE THE SAME)
EVAN8B:	MOVM	A,B		;CHECK SCA FAC SIZE
	CAILE	A,MAXEXP
	POPJ	P,
	TLO	N,233000	;FLOAT N
	FAD	N,[0]
	JOV	.+1		;TURN OFF OVERFLOW
EVAN8C:	CAIGE	B,^D15		;SCALE UP IF .GE. 10^15
	JRST	EVAN8D
	SUBI	B,^D14		;SUBTRACT 14 FROM SCALE FACTOR
	FMPR	N,D1E14		;MULTIPLY BY 10^14
	JRST	EVAN8C		;GO LOOK AT SCALE AGAIN
EVAN8D:	CAML	B,[EXP -^D4]	;SCALE DOWN IF .LT. 10^-4
	JRST	EVAN8E
	ADDI	B,^D18		;ADD 18 TO SCALE
	FMPR	N,D1EM18	;MULTIPLY BY 10^-18
	JRST	EVAN8D		;GO LOOK AT SCALE AGAIN
EVAN8E:	FMPR	N,DECTAB(B)	;SCALE N
	TLNE	F,F.MIN		;MINUS?
	MOVN	N,N		;YES.  NEGATE IT
	JOV	CPOPJ		;OVERFLOW ON SIZE ERROR
	JRST	CPOPJ1		;SUCCESS RETURN, NUMBER IN N

;ROUTINE TO PRINT NUMBER

OUTNUM:	SETOM	NUMFLA		;A NUMBER IS BEING TYPED OUT
	MOVM	T,N
	SKIPN	FMTFLG		;UNLESS FORMATTED OUTPUT,
	JUMPE	T,PRTNUX	;PRINT 0 WITH INTEGER PRINTER
	PUSH	P,E		;DO NOT CLOBBER E (FOR MATRX)
	JUMPE	T, ITSZER	;FORMATTED ZERO IS SPECIAL
	MOVEI	E,0		;CHANGE IN EXPONENT
OUTN1A:	CAMG	T,D1E14		;SCALE IF .GT. 10^14
	JRST	OUTN1B
	ADDI	E,^D18		;ADD 18 TO SCALE
	FMPR	T,D1EM18	;AND MULTIPLY BY 10^-18
	JRST	OUTN1A
OUTN1B:	CAML	T,D1EM4		;SCALE IF .LT. 10^-4
	JRST	OUTN1C
	SUBI	E,^D14		;SUBTRACT 14 FROM SCALE
	FMPR	T,D1E14		;AND MULT BY 10^14
	JRST	OUTN1B		;GO SEE IF MORE SCALING
OUTN1C:	MOVE	A,T		;LOOK UP IN DEC ROLL
	MOVEI	R,DECROL
	PUSHJ	P,SEARCH
	JFCL			;DONT CARE IF FOUND
	CAME	A,(B)		;FUDGE BY 1 IF EXACT MATCH
	SUBI	B,1
	SUBI	B,DECTAB	;FIND DIST FROM MIDDLE
	MOVE	A, FLDSPC	;GET FIELD SPECIFICATION
	JUMPN	E,OUTN2		;(NOT INTEGER IF WE SCALED)
	CAIGE	B,^D8		;CHK 8 DIG INTEGER
	CAIGE	B,0
	JRST	OUTN2
	SKIPE	FMTFLG
	JRST	OUTN2		;FORMATTED OUTPUT!
	CAML	T,FIXCON	;IS THIS 2^26?
	JRST	OUTN1D		;YES, ITS 27 BIT INT.
	MOVE	X1,T
	FAD	X1,FIXCON	;INTEGER?
	FSB	X1,FIXCON
	CAME	X1,T
	JRST	OUTN2		;NOT SUCH (LOST FRACTIONAL PART)
FXDFMT:	FAD	T,FIXCON	;SUCH.  FIX NUMBER
	TLZ	T,377400
OUTN1D:	TLZ	T,377000	;(IN CASE 27-BIT INTEGER)
	POP	P,E		;RESTORE E
	JRST	PRTNUX+1

OUTN2:	SKIPE	FMTFLG		;FORMATTED?
	TLNN	A, F.FIXD		;YES.  FIXED?
	JRST	NOTFXD		;NO
	JUMPL	E, .+4
	JUMPG	E, RESCAL		;DID WE SCALE?
	CAML	B, [7]
	JRST	BIGINT		;KEEP TO SIX DIGIT ACCURACY
	MOVE	X1, T
	FAD	X1, FIXCON
	FSB	X1, FIXCON	;NEXT SMALLER INTEGER IN X1
	MOVE	X2, X1
	FADRI	X2, (1.0)	;NEXT LARGER INTEGER IN X2
	MOVE	X3,X2
	MOVE	A,X1
	FSBR	X2, T
	FSBRM	T, X1
	CAML	X1, X2		;WHICH IS CLOSER?
	SKIPA	T, X3		;THE BIG ONE
	MOVE	T, A		;THE LITTLE ONE
	MOVE	A, T
	MOVEI	R, DECROL	;CHECK BALLPARK AGAIN
	PUSHJ	P, SEARCH
	JFCL
	CAME	A, (B)
	SUBI	B, 1
	SUBI	B, DECTAB
	ADD	B, E		;ADD TWO PARTS OF SCALE TOGETHER
	JUMPGE	E, .+2
	SETZB	E,T		;NEG.EXP.  MAKE IT 0
FXDFM1:	MOVE	A, FLDLEN	;GET FIELD LENGTH
	CAML	B, [-1]
	JRST	FXDFM2
	SETZ	T,
	JRST	ITSZER	;HANDLE VERY SMALL NUMBERS AS ZERO IN INTEGER SPEC.
FXDFM2:	ADDI	B, 1
	JUMPG	B, .+2
	MOVEI	B, 1
	CAIL	B, (A)		;ANY ROOM LEFT FOR NUMBER?
	PUSHJ P, NOFIT
	SKIPN TMPLOC	;SEE IF WE CAN JUST FIT
	SOJ A,	;GET RID OF LEADING BLANK
	SUBI	A, (B)
	JUMPE	A, FXDFMT
	MOVEI	C, " "		;NEED SOME LEADING BLANKS
	PUSHJ	P, OUCH
	SOJG	A, .-1		;MORE?
	JRST	FXDFMT		;NO.  GO PUT OUT THE #


NOFIT:	SETOM TMPLOC	;SET FLAG 
	CAIN B,(A)	
	JRST NEG.	;SEE IF LESS THAN ZERO
	POP  P,TMPLOC	;FIX PDL
	JRST NOTFIT	;SORRY CHARLIE

NOFIT1:	SETOM TMPLOC
	CAIN E,(A)
	JRST NEG.
	POP P,TMPLOC
	JRST NOTFIT
NEG.:	CAIL N,0	;SEE IF LESS THAN ZERO
	POPJ P, 	;NO SO JUST ENOUGH ROOM
	JRST NOFIT+3	;GO GET YOUR STARS
;ROUTINE USED FOR BIG INTEGERS IN FORMATTED MODE:

RESCAL:	CAIL	B, 7
	JRST	BIGINT
	FMPRI	T, (10.0)
	SOJ	E,
	AOJA	B, RESCAL
BIGINT:	CAIGE	B, 7
	JRST	.+4
	FDVRI	T, (10.0)
	ADDI	E, 1
	SOJA	B, BIGINT
	ADD	B,E
	ADDI	B, 1
	MOVE	A, FLDLEN
	SOJ	A,
	CAILE	B, (A)
	JRST	NOTFIT
	SUBI	A, (B)
	JUMPE	A, .+4
	MOVEI	C, " "
	PUSHJ	P, OUCH
	SOJG	A, .-1
	SUBI	B, 7		;NR. OF TRAILING ZEROS TO OUTPUT
	FAD	T, FIXCON
	TLZ	T, 377400
	POP	P, E
	PUSHJ	P, PRTNX0
	JUMPLE	B, NXTSPC
	MOVEI	C, "0"
	PUSHJ	P, OUCH		;PUT OUT TRAILING ZEROS
	SOJG	B, .-1
	JRST	NXTSPC

NOTFXD:	FDVR	T,DECTAB(B)	;GET MANTISSA
	FMPR	T,DECTAB+5
	FADR	T, FIXCON
	TLZ	T, 377400
	CAMGE	T,[EXP ^D1000000]
	JRST	.+3
	IDIVI	T,^D10		;ROUNDING MADE 7 DIGITS
	ADDI	B,1		;MAKE IT 6 AGAIN
	CAIL	T,^D100000	;ROUNDING MADE 5 DIGITS?
	JRST	.+3
	IMULI	T,^D10		;YES.  MAKE 6 AGAIN
	SUBI	B,1
	ADDB	B,E		;ADD TOGETHER TWO PARTS OF SCALE
	SKIPE	FMTFLG
	JRST	E.OR.F
	AOJL	E, .+2
	CAILE	E, 6
	SKIPA	E,[EXP 1]		;NO. PRINT 1 DIG BEFORE POINT
	PUSHJ	P,CHKNEF	;PRINT WITHOUT EXP (CHK ROOM FOR ^8 SP)
	PUSHJ	P,CHKEF		;PRINT WITH EXP (CHK ROOM FOR ^14 SP)
	PUSHJ	P,PSIGN		;PRINT "SIGN"
	JUMPN	E,OUTN3		;SHOULD DEC. POINT PRECEDE NUMBER?
	MOVEI	C,"0"		;YES,SEND OUT LEADING ZERO.
	PUSHJ	P,OUCH
	PUSHJ	P,DNPRN2	;AND DECIMAL POINT.
OUTN3:	PUSHJ	P,DNPRNT	;GO PRINT NUMBER WITH DECIMAL


;HERE TO PRINT EXPONENT

OUTN4:	POP	P,E		;RESTORE E
	SKIPN	FMTFLG
	JUMPE	B,CPOPJ
	MOVEI	C, "E"
	PUSHJ	P, OUCH
	MOVEI	C,"+"
	JUMPGE	B,.+2		;SPIT OUT SIGN
	MOVEI	C,"-"
	PUSHJ	P,OUCH
	MOVM	T,B		;USE PRTNUM TO PRINT EXPON
	SKIPN	FMTFLG
	JRST	PRTNUM
	CAILE	T, ^D9		;FORMATTED OUTPUT.  FORCE TWO DIGITS
	JRST	.+3
	MOVEI	C, "0"
	PUSHJ	P, OUCH
	JUMPN	N, .+2		;IF NUMBER IS ZERO,
	SETZ	B,		;MAKE EXP. ZERO, TOO
	PUSHJ	P, PRTNUM
	JRST	NXTSPC


E.OR.F:	ADDI	E, 1
	TLNN	A, F.FLOT
	JRST	NOT.F		;NOT AN F-SPEC 
	HLRZ	A, FLDLEN	;GET LENGTH OF FIELD PRECEEDING DEC. PT.
	JUMPL	E, NEGEXP	;NEGATIVE EXP?
	CAIL	E, (A)		;NO.  WILL # FIT?
	PUSHJ P,NOFIT1
E.ORF0:	SUBI	A, (E)		;COMPUTE # OF LEADING BLANKS
	SKIPN TMPLOC	;SEE IF JUST FIT
	SOJ A,	;GET RID OF LEADING BLANK
	JUMPN	E, .+2
	SOJ	A,
	JUMPLE	A, .+4
	MOVEI	C, " "
	PUSHJ	P, OUCH
	SOJG	A, .-1
	HRRZ	A, FLDLEN	;# OF DIGITS AFTER DEC. PT
	MOVN	A,A
	CAMGE	B,A		;ALL TO BE ZEROS?
	TLZ	N, 400000	;YES.  PREVENT "-0.00"
	PUSHJ	P, PSIGN	;PUT OUT SIGN
	JUMPN	E, .+6
	MOVEI	C, "0"
	HLRZ	D, FLDLEN
	CAILE	D, 1		;WAS ROOM ALLOWED FOR LEADING ZERO?
	PUSHJ	P, OUCH		;YES.  PUT IT OUT
	PUSHJ	P, DNPRN2
	ADDI	B, 1
	JUMPGE	B, .+10
	MOVEI	C, "0"
	CAMG	E, A		;MORE ZEROS NEEDED?
	JRST	E.ORF1
	CAMG	E, B
	JRST	.+3
	PUSHJ	P, OUCH		;YES
	SOJA	E, .-5
	PUSHJ	P, DNPRNT	;PUT OUT THE NR.
	CAMLE	E, A		;TRAILING ZEROS REQUIRED?
	JRST	E.ORF3
E.ORF1:	POP	P, E		;NO.  RESTORE E
	JRST	NXTSPC		;AND GO INTERPRET THE NEXT FORMAT SPEC.
E.ORF2:	JUMPN	E, .+4
	MOVEI	C, "."		;GET OUT THAT DEC. PT.!
	PUSHJ	P, OUCH
E.ORF3:	MOVEI	C, "0"
	PUSHJ	P, OUCH		;YES.  PUT ONE OUT
	SOJ	E, 		;AND SEE IF MORE NEEDED.
	CAMG	E, A
	JRST	E.ORF1
	JRST	E.ORF2
NEGEXP:	MOVEI	E, 0		;NEG. EXP.  PLAN ON ONLY SIGN BEFORE DEC. PT.
	CAIN A,0
	SETOM TMPLOC
	JRST	E.ORF0


;SUBROUTINE USED BY OUTNUM TO PRINT DECIMAL NUMBER.  PRINTS
;SIX DIGITS (INTEGER IN T) WITH CONTENTS(E) DIGITS
;TO THE LEFT OF DECIMAL POINT

DNPRNT:	MOVEI	D,-1		;SIGNAL TRAILING ZERO UNLESS...
	SKIPN	FMTFLG
	JUMPE	B,.+2		;E-NOTATION AND NOT FORMATTED
	MOVEI	D,0
DNPRN0:	IDIVI	T,^D10		;GET LAST DIGIT
	JUMPE	T,DNPRN1	;IS IT FIRST?
	JUMPN	T1,.+2		;NON ZERO DIGIT?
	SKIPA	T1,D		;NO, STASH ZERO OR TRAILZERO
	MOVEI	D,0		;YES. TRAILER IS OVER.
	HRLM	T1,(P)		;NO.  STASH DIGIT
	PUSHJ	P,DNPRN0	;CALL DNPRNT RECURSIVELY
	HLRE	T1,(P)		;RESTORE DIGIT
	JUMPGE	T1,.+3		;ORDINARY DIGIT?
	JUMPLE	E,CPOPJ		;NO, TRAILZERO. AFTER DECIMAL POINT?
	MOVEI	T1,0		;NO, STASH A ZERO.


	EXTERN EXTFG
DNPRN1:	MOVEI	C,60(T1)	;PRINT DIGIT
	SKIPN	FMTFLG
	JRST	DNPRN3
	SOJ	E,
	CAME	E,A		;LAST PRINTING DIGIT?
	JRST	.+10
	HLRZ	T1, -1(P)	;YES
	CAIL	T1, ^D10	;ANY MORE AROUND?
	JRST	.+5
	CAIL	T1, 5	;BIG ONES?
	ADDI	C, 1		;YES.  ROUND UP
	CAILE	C, "9"		;BUT BE CAREFUL
	SUBI	C, 1
	AOJ	E,
	CAMLE	E, A		;ONLY IF NON-FORMATTED OR REQUESTED
DNPRN3:	PUSHJ	P,OUCH
	SOJN	E,CPOPJ		;COUNT DIGITS.  POINT NEXT?
DNPRN2:	MOVEI	C,"."		;YES.  PRINT POINT
	JRST	OUCH

;CHECK FOR ROOM ON A LINE FOR E-FORM NUMBER:
CHKEF:	MOVEI	X1,^D14		;NEED 14 SP TO PRINT THIS NUMBER.
	PUSH	P,B		;SAVE EXPONENT
	PUSHJ	P,CHROOM	;FIND ROOM OR DO CRLF
	POP	P,B
	POPJ	P,

;CHECK FOR ROOM FOR NON-EFORM DECIMAL NUMBER.
CHKNEF:	CAIL	E,0
	SETZM	EXTFG
	SKIPE	EXTFG
	SKIPA	X1,[EXP ^D15]
	MOVEI	X1,^D9		;ASSUME THIS NUMBER WILL TAKE 8
	PUSHJ	P,CHROOM
	MOVEI	B,0		;NO EXPONENT.
	JRST	CPOPJ1		;SKIP-RTN

CMDFLO:
CMDCEI:
IFNCEI:
IFNFLO:
RELCEI:
RELFLO:
STACEI:
STAFLO:
;THE ABOVE ARE PHONY BALONEY LOCATIONS
;POWER-OF-TEN TABLE.

D1EM18:	OCT	105447113564	;10^-18

DECFLO:
D1EM4:	OCT	163643334273	;10^-4
	OCT	167406111565
	OCT	172507534122
	OCT	175631463146
DECTAB:	DEC	1.0		;10^0
	DEC	1.0E1
	DEC	1.0E2
	DEC	1.0E3
	DEC	1.0E4
	DEC	1.0E5
	DEC	1.0E6
	DEC	1.0E7
	DEC	1.0E8
	DEC	1.0E9
	DEC	1.0E10
	DEC	1.0E11
	OCT	250721522451	;10^12
	OCT	254443023471
D1E14:	OCT	257553630410	;10^14
DECCEI:

MAXEXP=^D38
DECFIX:	EXP 225400000000
FIXCON:	EXP 233400000000

;FLAGS USED BY DECIMAL READER/PRINTER

F.NUM=200000	;DIGIT SEEN
F.MIN=100000	;MINUS SEEN
F.MXP=40000	;MINUS EXPONENT
F.DOT=20000	;DECIMAL POINT SEEN



;ROUTINE FOR FORMATTED E-SPECIFICATION #'S:

NOT.F:	TLNN	A, F.ESPC	;E-SPEC?
	JRST	NOTFIT		;NO.  DOESN'T FIT THEN.
	HLRZ	A, FLDLEN	;YES.  HOW MANY DIGITS BEFORE DEC. PT?
	MOVEI	E, (A)
	JUMPN	A, .+2
	SOJA	B, .+4
	SOJ	A,
	JUMPE	A, .+2	
	SOJA	B, .-2		;LESS LEADING DIGITS
	HRRZ	A, FLDLEN	;NOW TRAILING DIGITS
	SUBI	A, 4		;ROOM FOR EXPONENT
	MOVN	A,A
	PUSHJ	P, PSIGN
	JUMPN	E, .+6
	MOVEI	C, "0"
	HLRZ	D, FLDLEN
	CAILE	D, 1
	PUSHJ	P, OUCH
	PUSHJ	P, DNPRN2
	PUSHJ	P, DNPRNT
	MOVEI	C, "0"		;ENOUGH TRAILING ZEROS?
	CAMG	E, A
	JRST	OUTN4		;YES.  GO PRINT EXP.
	PUSHJ	P, OUCH		;NO.  PRINT ANOTHER ONE
	SOJA	E, .-3

;HERE IF FIELD SPECIFICATION TOO SMALL OR NO GOOD.

NOTFIT:	SETZM TMPLOC
	POP	P, E
NOTFT0:	HRRZ	A, FLDLEN
	HLRZ	B, FLDLEN
	ADDI	A, 1(B)		;TOTAL SIZE OF FIELD ALLOWED
	MOVE	C, FLDSPC
	TLNE	C, F.FIXD!F.ALFA
	SUBI	A, 1
	MOVEI	C, "*"
	PUSHJ	P, OUCH
	SOJG	A, .-1		;FILL WITH STARS
	JRST	NXTSPC		;AND GO ON TO NEXT FORMAT SPEC.

ITSZER:	SETZ	N,
	SETZB	B,E
	MOVE	A, FLDSPC
	TLNN	A, F.FIXD
	JRST	NOTFXD
	JRST	FXDFM1
	SUBTTL RUN-TIME ROUTINES
	EXTERN	IFIFG,ODF
	DEFINE R(A)
<	IRP	A
<	EXP	DO'A+1	>>
OUTPT:	R<1,2,3,4,5,6,7,8,9,10>
	DEFINE R(A)
<	IRP	A
<	EXP	DO'A+2
	EXTERN	DO'A	>>
OUTCNT:	R<1,2,3,4,5,6,7,8,9,10>
	DEFINE R(A)
<	IRP	A
<OPS'A:	OCT	1
	SIXBIT/DSK/
	XWD	DO'A,0
	INTERN	OPS'A	>>
	R<1,2,3,4,5,6,7,8,9>
	DEFINE R(A)
<	IRP	A
<IPS'A:	OCT	1
	SIXBIT/DSK/
	XWD	0,DI'A
	INTERN	IPS'A	>>
	R<1,2,3,4,5,6,7,8,9>

	DEFINE R(A)
<	IRP	A
<	EXP	DI'A+1
	EXTERN	DI'A	>>
INPT:	R<1,2,3,4,5,6,7,8,9>

	DEFINE	R(A)
<	IRP	A
<	EXP	DI'A+2	>>
INCNT:	R<1,2,3,4,5,6,7,8,9>

	DEFINE R(A)
<	IRP	A
<	EXP	DBUF'A
	EXTERN	DBUF'A,LINB'A	>>
BA:	R<1,2,3,4,5,6,7,8,9,10>

	DEFINE R(A)
<	IRP	A
<	POINT 7,LINB'A	>>
LINPT:	R<0,1,2,3,4,5,6,7,8,9,10>


INSET:	SETOM	IFIFG		;SET INPUT FROM DISK FLAG
	HRRZ	LP,40		;GET CHANNEL NUMBER
	SKIPE VFFLG	;IS THIS VAR FILE?
	PUSHJ P,VCHAN	;U BETCHA
INSET1:	MOVE	X1,ACTBL-1(LP)
	CAIN	X1,0		;GET CORRESPONDING ACCESS CODE
	JRST	FNR		;IF=0, FILE NEVER ACCESSED
	CAIE	X1,1		;IF NOT EQUAL TO 1, FILE NOT OK FOR READING
	JRST	ILRD		;ILLEGAL READ ERROR MESSAGE
	POPJ	P,

INCLR:	SETZM	IFIFG		;CLEAR INPUT FROM DISK FLAG
	POPJ	P,		;COME HERE BEFORE INPUT FROM TTY


EOF:	HRRZ	X1,40		;END OF FILE TEST
	SKIPE VFFLG
	PUSHJ P,VCHAN
	HRRZ	X2,@(P)		;AND PLACE TO GO
	MOVEM	X2,EOFLOC(X1)	;SAVE FOR LATER
	MOVE	X2,ACTBL-1(X1)	;GET ACCESS CODE
	CAIE	X2,1		;WE MUST BE READING ON CHANNEL BEING TESTED
	JRST	ILRD
	DPB	X1,[POINT 4,STADSK,12]	;DEPOSIT CHANNEL NUMBER FOR STATO
	SKIPN T,PINPNM-1(X1)
	JRST EOF2
	PUSHJ P,DELAWY
	TLNN C,F.CR
	JRST CPOPJ1
	SETZM PINPNM-1(X1)
EOF2:	MOVE	X2, @INCNT-1(X1)	;SEE IF ANY MORE CHARACTERS IN BUFFER
	MOVE T, @INPT-1(X1)
	SOSG	X2
	JRST	INPP		;NO - DO INPUT
EOF3:	PUSHJ	P,NXCH		;SEE IF ANY CHARACTERS LEFT
	CAIE	C,0		;LINE TERMINATORS DON'T COUNT
	TLNE	C,F.CR
	JRST	EOF2+2		;ZEROES DON'T COUNT
EOF4:	XCT	STADSK
	POPJ	P,
	JRST	CPOPJ1
INPP:	DPB	X1,[POINT 4,INDSK,12]	;DO ANOTHER INPUT
	XCT	INDSK		;THIS DOES INPUT
	MOVE	T,@INPT-1(X1)	;GET POINTER
	JRST	EOF4



V2:	EXCH X1,LP
	PUSHJ P,VCHAN
	EXCH X1,LP
	POPJ P,
XRES:	HRRZ	X1,40		;HERE FOR RESTORE UU0
	SKIPE VFFLG
	PUSHJ P,VCHAN
	MOVE	X2,ACTBL-1(X1)	;GET CHANNEL NUMBER
	CAIN	X2,0		;IF=0 NEVER REFERENCED IN "FILES" STATEMENT
	JRST	FNR
	DPB	X1,[POINT 4,DREL,12]	;DEPOSIT CHANNEL NUMBER FOR RELEASE
	XCT	DREL			;DO RELEASE
	SETZM PINPNM-1(X1)	;RESTORE LINE POINTER
	MOVEI	X2,@BA-1(X1)	;GET BUFFER ADDRESS
	MOVEM	X2,JOBFF
	XCT	INITI-1(X1)	;INIT THAT CHANNEL
	JRST	NODEV
	DPB	X1, [POINT 4,IBDSK,12]
	XCT	IBDSK		;DO AN INBUF 1
	MOVE	X2,FILD-1(X1)	;GET FILE NAME
	MOVEM	X2,LOK		;SET FOR LOOKUP
	SETZM	LOK+3		;ZERO PJ-PG
	DPB	X1,[POINT 4,LOKUP,12]	;SET CHANNEL FOR LOOKUP
	XCT	LOKUP		;DO LOOKUP
	JRST	LOKFAL
	MOVEI	X2,1		;FILE NOT THERE
	MOVEM	X2,ACTBL-1(X1)	;SET ACCESS TABLE FOR READ
	POPJ	P,


;SCRATCH UUO
SCATH:	HRRZ	X1,40		;GET CHANNEL NUMBER
	SKIPE VFFLG
	PUSHJ P,V2
	MOVE	X2,ACTBL-1(X1)	;GET ACCESS CODE
	CAIN	X2,0		;IF=0 NEVER REFERENCED IN "FILES" STATEMENT
	JRST	FNR
	MOVEI	X2,@BA-1(X1)	;GET BUFFER ADDRESS
	MOVEM	X2,JOBFF
	XCT	INITO-1(X1)	;DO INIT
	JRST	NODEV
	DPB	X1,[POINT 4,OBDSK,12]	;SET CHANNEL FOR OUTBUF
	XCT	OBDSK		;DO "OUTPUF"
	MOVE	X2,FILD-1(X1)	;GET FILE NAME
	MOVEM	X2,ENT		;SET FOR ENTER
	SETZM	ENT+3
	DPB	X1,[POINT 4,ENTDSK,12]	;SET CHANNEL FOR ENTER
	XCT	ENTDSK		;DO ENTER
	JRST	ENFAIL		;ENTER FAILED
	DPB	X1,[POINT 4,OUTDSK,12]	;SET FOR DUMMY OUTPUT
	XCT	OUTDSK		;DO DUMMY OUTPUT
	MOVEI	X2,3		;FILE OK FOR READING
	MOVEM	X2,ACTBL-1(X1)	;TELL ACCESS TABLE
	SETOM LNINS-1(X1)	;TURN LINE NO SWITCH
	SETZM	NLN-1(X1)	;TURN OFF NO LINE NOS SWITCH
	POPJ	P,



;RUNNTIME ROUTINES

;THIS IS FOR SKIPRECORD

	EXTERNAL SKFLG
SKIPR:	HRRZ LP,40
	SKIPN VFFLG	;VARIABLE FILE?
	JRST SKIPR2	;NO
	PUSHJ P,VCHAN	;YES SIR GET CHANNEL NO
SKIPR2:	JUMPE LP,SKDATA	;INTERNAL DATA IF LP=0
	PUSHJ P,INSET1	;CHECK STATUS OF FILE
	SETOM IFIFG
	SETOM SKFLG(LP)
	PUSHJ P,DOINPT
	SKIPN T,PINPNM-1(LP)	;WAS IT END OF LINE
	PUSHJ P,NXINPT	;GET TJHAT LINE
	PUSHJ P,SKFIL	;NOW DO THE SKIP RECORD
	POPJ P,
SKDATA:	SETOM SKFLG(LP)
	SETZM IFIFG
	PUSHJ P,DOREAD	;GET THE POINTER
	SKIPN T,(R)	;SEE IF WAS THE END OF LINE IN DATA STATEMENT
	PUSHJ P,NXREAD	;YES GET NEW DATA LINE
	PUSHJ P,SKDA	;NOW SKIP RECORD
	PUSHJ P,BACK1	;MOVE POINTER BACK 1 BYTE
	MOVEM T,(R)	;PUT THE POINTER BACK
	POPJ P,


;INPUT FROM DISK UUO
IPDSK:	HRRZ	LP,40		;GET CHANNEL NUMBER
	SKIPE VFFLG	;VARIABLE FILE?
	PUSHJ P,VCHAN	;YES SUH
	MOVE	X2,ACTBL-1(LP)	;GET ACCESS CODE
	CAIN	X2,0		;WAS FILE REFERENCED IN "FILES" STATEMENT?
	JRST	FNR		;NO
	CAIE	X2,3		;OPEN FOR WRITING?
	JRST	ILWRT		;NO
	SETOM	ODF		;SET INPUT FROM DISK FLAG
	POPJ	P,

;CLEAR INPUT FROM DISK, NOW INPUT FROM TTY
CODSK:	SETZ	LP,		;CLEAR CHANNEL SPECIFICATION
	SETZM	ODF		;CLEAR INPUT FROM DISK FLAG
	POPJ	P,


LINSST:	HRRZ	X1,40		;HERE ON LINE UUO
	MOVEM	X1,CURLIN	;SET CURRENT LINE NUMBER
	POPJ	P,



;RUN-TIME GOSUB ROUTINES

GOSBER:	MOVE	X1,@40
	SKIPN	PAT+11
	JRST	.+3
	HRRZ	X1, 40
	JRST	1(X1)
	MOVE	R,FCNLNK
	HRLM	R,@40		;SAVE PRECEDING CALL
	MOVE	R,40		;FETCH CURRENT CALL
	MOVEM	R,FCNLNK
	TRNN	X1,777777	;IF FCN, BEGINS AT CTRL WRD + 1
	HRRI	X1,1(R)
	SKIPN	SHRTFL		;UNLESS DIRECT MODE FUNCTION USE,
	TLNN	X1,777777	;CHECK RECURSIVE CALL
	JRST	(X1)

	PUSHJ	P,INLMES	;RECURSIVE CALL
	ASCIZ	/SUBROUTINE OR FUNCTION CALLS ITSELF IN /
GOSR2:	PUSH	P,[Z UXIT]	;PRINT LINE NUMBER AND END EXECUTION
GOSR3:	MOVE	T,L	;PRINT LINENUMBER AND CONTINUE EXECUTION.
	PUSHJ	P,PRTNUM
	PUSHJ	P,INLMS0
	ASCIZ	/
/
	POPJ	P,

FORCOM:	MOVEI	X1, 313
	SKIPGE	@40
	ADDI	X1,2
	DPB	X1,[POINT 9,@(P),8]
	POPJ	P,

XCTON:	JUMPLE	N,XCTON1	;IS ON ARGUMENT <=0?
	FAD	N,FIXCON
	HRRZ	T,N		;GET INTEGER PART
	JUMPE	T,XCTON1
	SKIPN	SHRTFL		;DIRECT MODE?
	JRST	XCTON0
	MOVE	N, CECOD
	SUBI	N, 1
	MOVEM	N, (X3)
	SETZM	SHRTFL
XCTON0:	ADDI	T,(X3)		;GET THE "GOTO" ADDRESS
	CAMGE	T,(X3)		;IS IT IN RANGE?
	JRST	@(T)		;YES, GOGO

XCTON1:	PUSHJ	P,INLMS0
	ASCIZ /ON EVALUATED OUT OF RANGE IN /
	JRST	GOSR2


EXTERN JOBCNI

;HERE ON OVFLOW ERROR
OVTRAP:	PUSH	P, X1		;SAVE THIS REG IN CASE FALSE ALARM.
	MOVEI	X1, 20010
	CALL	X1,[SIXBIT /APRENB/]	;REENABLE TRAP
	MOVE	X1,JOBCNI
	TRNE	X1, 20000		;ILLEGAL MEM TRAP?
	JRST	MORCOR			;YES.  TRY MORE CORE

	HRRZ	X1,JOBTPC		;GET TRAP ADDRESS.
	CAML	X1,FLCOD		;TRAP IN USER PROG?
	CAMLE	X1,CECOD
	JRST	OVFIGN		;NO. FALSE TRAP.(NOT BY USER)
	MOVE	X1,JOBTPC	;GET TRAP FLAGS.
	SKIPE	PDP6SW		;PDP6 COMPUTER?
	JRST	OVTR0		;YES.  ASSUME OVFLOW.
	TLNE	X1,(1B11)	;UNDERFLOW?
	JRST	UNTRAP		;YES
	TLNE	X1,(1B12)	;ZERO DIVIDE?
	JRST	DVTRAP		;YES.
	TLNN	X1,(1B3)
	JRST	OVFIGN		;NOT OVFLOW EITHER. IGNORE.
OVTR0:	PUSHJ	P, INLMS0
	ASCIZ	/OVERFLOW IN /
	SKIPL	N		;NEG OVFLOW?
OVTR2:	HRLOI	N,377777	;LRG NUMBER
	SKIPG	N
	MOVE	N,MIFI		;LRG NEG NUMBER
OVTR1:	PUSHJ	P,GOSR3
OVFIGN:	POP	P, X1
	JRST	@JOBTPC

TRAPS:	PUSH	P, X1
	MOVEI	X1, 20010
	CALL	X1, [SIXBIT/APRENB/]
	MOVE	X1, JOBCNI
	TRNN	X1, 20000	;MEM PROT. VIOL?
	JRST	OVFIGN		;NO.  FORGET THIS ONE.
MORCOR:	HRRZ	X1, JOBTPC
	MOVE	X1,JOBREL
	ADDI	X1, 2000
	CALLI	X1, 11		;TRY FOR SOME MORE CORE
	JRST	PANIC1
	JRST	OVFIGN

UNTRAP:	PUSHJ	P,INLMS0
	ASCIZ	/UNDERFLOW IN /
	SETZI	N,		;RESULT IS ZERO.
	JRST	OVTR1

DVTRAP:	PUSHJ	P,INLMS0
	ASCIZ	/DIVISION BY ZERO IN /
	JRST	OVTR2

RETURN:	SETZI	T,		;GOSUB RETURN, NOTHING ON PLIST.
FRETRN:POP P,NOLNS	;CLEAN UP PDL
	SKIPE	PAT+11
	JRST	.+7
	MOVE	R,FCNLNK
	JUMPE	R,BADRET	;CHECK RETURN TOO FAR
	MOVS	X1,(R)		;FETCH LINK BACK
	HRRZS	(R)		;MARK SUBR NOT IN USE
	MOVEI	R,(X1)
	MOVEM	R,FCNLNK
	POP	P,X2		;SAVE REAL RETURN LOCATION
	SUB	P,T		;POP ANY ARGUMENTS OFF THE PUSH LIST
	JRST	(X2)		;RETURN

BADRET:	PUSHJ	P,INLMS0
	ASCIZ	/RETURN BEFORE GOSUB IN /
	JRST	GOSR2

IFN FTRND,<
;RUN-TIME RANDOMIZER
RANDER:	CALL	N,[SIXBIT /MSTIME/]
	IMUL	N,N		;USE THE 31 LOW ORDER BITS OF MILLESECS IN DAY ^2
	TLZ	N,760000
	JRST	WRANB		;PRIME RANDOM FCN AND RETURN.
>;ASSEMBLE ABOVE IF INCLUDING RANDOM FACILITY


;RUNTIME ROUTINE FOR VARIABLE FILE NUMBER	;N.AVNER


VCHAN:	HRRZ X1,40	;GET ADR OF CHANNEL NO
	MOVE X1,@X1	;GET CONTENTS OR CHANNEL NO
IFIX:	MULI X1,400	;ROUTINE TO FIX A FLOAT NO
	TSC X1,X1
	EXCH X1,X2
	ASH X1,-243(X2)
	HRRM X1,LP	;THIS SHOULD BE CHANEEL NO
	SETZM VFFLG	;TURN OFF SWITCH
	POPJ P,	;GO HOME TO DO YOUR THING





;RUNTIME ROUTINE FOR PRINTER CMD.  WRITES DISK FILE, THEN SETS IT UP FOR PRINTR.

	LPT=12

PRINTR:	MOVEI	LP, LPT
	SETOM	ODF
	SKIPE	INITDN		;BEEN HERE BEFORE?
	POPJ	P,
	MOVEI	X1, DBUF10
	MOVEM	X1, JOBFF
	INIT	LPT,1		;INIT THE DISK FOR PRINTR
	SIXBIT	/DSK/
	XWD	DO10,0
	JRST	INLSYS
	CALLI	N, 30		;GET JOB #
	MOVEI	A, 2
	CLEAR	T1,
	IDIVI	N, ^D10
	ADDI	T, 20		;MAKE SIXBIT, TWO DIGITS
	LSHC	T, -6
	SOJG	A, .-3
	TLO	T1, 41		;TRY XXA AS AN EXT FIRST
	MOVE	N, CURNAM
	MOVEM	N, FILDIR
NXTEXT:	HLLZM	T1, FILDIR+1
	CLEARM	FILDIR+3
	LOOKUP	LPT,FILDIR
	JRST	.+3
	AOBJN	T1, NXTEXT
	JRST	NXTEXT
	MOVE	T, FILDIR+1
	TRNE	T, -1
	JRST	.-4
	HLLZM	T, FILEXT
	CLEARM	FILDIR+3
	ENTER	LPT,FILDIR	;SINCE NO FILE EXISTS WITH THIS NAME, TRY TO WRITE ONE
	JRST	.-10
	OUTBUF	LPT,1		;ONLY ONE BUFFER
	OUTPUT	LPT,		;DO DUMMY OUTPUT
	SETOM	INITDN
	SETOM	PRNTSW
	POPJ	P,

	EXTERN	INITDN



;FORMS CONTROL ROUTINE FOR LINE PRINTER

;	(1)=TOP OF FORM
;	(2)=SKIP TO NEXT 1/2 PAGE
;	(3)=SKIP TO NEXT 1/3 PAGE
;	(6)=SKIP TO NEXT 1/6 PAGE

FRMCON:	HRRZ	X1, 40
	CAILE	X1, 6
	POPJ	P,
	MOVE	C, CTRLCH(X1)
	JRST	OUCH

CTRLCH:	0
	14
	20
	13
	0
	0
	24

	
;RUN-TIME ROUTINES FOR READ AND INPUT

DOREAD:	MOVE	R,[XWD NXREAD,PREAD]
	SETZM	INPFLA		;READ, NOT INPUT
	POPJ	P,		;SET UP TO READ

	EXTERNAL PINPNM
DOINPT:	SETZM	MORFLA		;SIGNAL BEGINNING OF INPUT
	MOVE	R,[XWD NXINPT,PINPUT]
	SKIPN IFIFG
	PUSHJ P,INTTY
	POP	P,INPFLA	;SAVE ERROR RETURN
	JRST	@INPFLA

INTTY:	ADDI R,1
	SETZM 	PINPUT+1
	POPJ P,
NOLINE:SETZM LNINS-1(LP)
	SETOM NLN-1(LP)
	POPJ P,


;ROUTINE TO GET A DATA WORD

DATAER:	SKIPN IFIFG
	JRST DATAE1
	SKIPN T,PINPNM-1(LP)
	PUSHJ P,NXINPT
	PUSHJ P,SKFIL	;SEE IF SKIPREC FLG SET
	PUSHJ P,DELAWY
	JRST DATR0+1
DATAE1:		SKIPN	T,(R)		;MORE ON SAME LINE?
	JRST	DATR1		;NO
	PUSHJ	P,NXCH		;PUT FIRST CHAR OF NEXT NUMBER IN C
DATR0:	PUSHJ P,SKDA	;SEEIF SKIP REC FLG SET
	PUSHJ	P,EVANUM
	JRST INPERR	;IT WASN'T A NUMBER U LOOSE DUMMY
	MOVEM	N,@40		;STORE THE DATA WORD
	SKIPE IFIFG
	PUSHJ  P,DELAWY
	SKIPE INPFLA
	TLNN C,F.CR
	TLNE	C,F.TERM	;END OF LINE?
	SETZI	T,		;YES
	SKIPN IFIFG
	JRST DATAE2
	MOVEM T,PINPNM-1(LP)
	JRST DATR01
DATAE2:	MOVEM	T,(R)
DATR01:	POP	P,X1
	SKIPN	T		;END OF A LINE?
	SKIPN	INPFLA		;YES, IS THIS INPUT?
	JRST	(X1)		;NO, RETURN
	MOVEM	X1,INPFLA	;YES, RESTART NEXT ERROR FROM HERE.
	JRST	(X1)



DATR1:	SKIPE INPFLA
	JRST INT1
	PUSHJ P,NXREAD
	JRST DATR0
INT1:	PUSHJ P,NXINPT
	JRST DATAE1+2

;ROUTINE TO GET A DATA STRING

INSTR:
IFN FTSTR,<
SDATAE:	SKIPN IFIFG
	JRST SDATA1
	SKIPN T,PINPNM-1(LP)
	PUSHJ P,NXSINP
	PUSHJ P,SKFIL1	;SKIP RECORD FLG SET?
	PUSHJ P,DELAWY
	JRST SDATR0+1
SDATA1:	SKIPN	T,(R)		;MORE ON CURRENT STRING DATA LINE?
	JRST	SDATR1		;NO. HUNT FOR NEXT DATA LINE
	PUSHJ	P,NXCH		;GET FIRST CHAR
SDATR0:	PUSHJ P,SKDA1
	PUSHJ	P,REDSTR	;READ THE STRING AND STORE IT
	JRST IMP	;DON'T ASK HOW U GOT HERE - THAT STRING WAS A LOSER
	SKIPE IFIFG
	PUSHJ P,DELAWY
	SKIPE INPFLA
	TLNN C,F.CR
	TLNE	C,F.TERM	;END OF LINE?
	SETZI	T,		;YES
	SKIPN IFIFG
	JRST SDAT2
	MOVEM T,PINPNM-1(LP)
	JRST DATR01
SDAT2:	MOVEM	T,(R)		;SAVE STRING DATA POINTER
	JRST	DATR01

SDATR1:	SKIPE INPFLA
	JRST INT2
	PUSHJ P,NSRSTR
	JRST SDATR0

INT2:	PUSHJ P,NXSINP
	JRST SDATA1+2
>;ASSEMBLE ABOVE IF INCLUDING STRING FACILITY

SKDA:	SKIPE INPFLA
	POPJ P,
	SKIPE SKFLG
	PUSHJ P,NXREAD
	SETZM SKFLG
	POPJ P,
SKFIL:	SKIPE SKFLG(LP)
	PUSHJ P,NXINPT
	SETZM SKFLG(LP)
	POPJ P,

SKDA1:	SKIPE INPFLA
	POPJ P,
	SKIPE SKFLG
	PUSHJ P,NSRSTR
	SETZM SKFLG
	POPJ P,

SKFIL1:	SKIPE SKFLG(LP)
	PUSHJ P,NXSINP
	SETZM SKFLG(LP)
	POPJ P,

;GET AN ARRAY DATA WORD

ADT1ER:	PUSH	P,40		;DATAER NEEDS STORE LOC
	SETZM	40
	PUSHJ	P,DATAER
	POP	P,40
	JRST	AST1ER	;GO STORE THE WORD

ADT2ER:	PUSH	P,40
	SETZM	40
	PUSHJ	P,DATAER
	POP	P,40
	JRST	AST2ER

;GO TO NEXT LINE OF DATA

NXREAD:	TDZA	X3,X3		;GET NEXT DATA LINE FOR NUMBER ITEM
NSRSTR:	MOVEI	X3,1		;GET NEXT DATA LINE FOR STRING ITEM
	MOVE	T,DATLIN	;GET NXT DATA LINE NO
	AOBJP	T,NXRE2		;JUMP IF OUT OF DATA
	MOVEM	T,DATLIN
	HRRZ	T,(T)		;GET ADDRS OF SOURCE LINE
	HRLI	T,440700
	PUSHJ	P,NXCH
	PUSHJ	P,QSA		;LOOK FOR "DATA"
	ASCIZ	/DATA/
	JRST	NXREAD+2
	MOVEM T,(R)
	POPJ P,

;REQUEST NEXT LINE OF INPUT

NXVINP:	SETOI	X3,		;GET LINE AND RETURN TO "MATIN"
	JRST	NXSINP+1
NXINPT:	TDZA	X3,X3		;GET A LINE OF INPUT; NUMBER ITEM NEXT
NXSINP:	MOVEI	X3,1	;GET A LINE OF INPUT; STRING ITEM NEXT
	SKIPN	MORFLA		;START OF INPUT?
	JRST	NXIN1		;YES
	PUSHJ	P,INLMS0
	ASCIZ	/NOT ENOUGH INPUT--ADD MORE
/
NXIN1:	SKIPN	IFIFG
	SETZB	LP,ODF
	JUMPN	LP,NXIN5
	SETZM	FMTFLG
	PUSHJ	P, INLMES
	ASCIZ	/ ?/
	OUTPUT
NXIN5:	MOVE	T,LINPT(LP)
	PUSHJ	P,INLINE	;READ THE LINE AND GET FIRST CHAR.
	TLNN	C,F.CR		;NULL LINE?
	JRST	.+4
	JUMPL	X3,CPOPJ1	;YES. ALLOW THIS ON MAT INPUT
	SKIPE	IFIFG		;AND IGNORE ON DSK INPUT
	JRST	.-5
	MOVE	T,LINPT(LP)
	JUMPE	LP,NXIN6
	MOVEI	X1,5
	PUSHJ	P, NXCH
	JRST	.+2
NXIN8:	PUSHJ P,NXCH
	TLNE C,F.CR
	JRST NXIN5
	MOVEI A,4
	TLNN C,F.DIG
	JRST NAN2
	PUSHJ P,NXCHD
	TLNN C,F.DIG
	JRST .+3
	SOJGE A,.-3
	JRST IMP
	HRRZ A,C
	CAIE A,"D"
	CAIN A,"	"
	JRST NAN1
NAN2:	MOVE T,LINPT(LP)
	PUSHJ P,NXCH
	JRST NXIN6
NAN1:	MOVEI C,40
	DPB C,T
NXIN6:	SKIPN IFIFG
	JRST NXIN2
	MOVEM T,PINPNM-1(LP)
	JRST NXIN9
NXIN2:	MOVEM	T,(R)
NXIN9:		POPJ	P,



;THIS ROUTINE USED AT RUNTIME BY READ#
;IT SKIPS THROUGH DELIMITERS AND STOPS ON FIRST NON TAB,MON SPACE
;,NON COMMA

DELAWY:	LDB C,T
	PUSHJ P,NXCHD2
	TLNN C,F.COMA+F.SPTB
	POPJ P,
	PUSHJ P,NXCH
	JRST .-3

INPERP:	POP	P,X1		;GET RID OF CALL TO NXVINP!
INPERR:	SKIPE	IFIFG
	JRST	IMP
	SKIPN INPFLA
	JRST IMP
	PUSHJ	P,INLMES
	ASCIZ	/INPUT DATA NOT IN CORRECT FORM--RETYPE LINE
/
	SETZM	PINPUT+1
INPER1:	HRRZ	X1,INPFLA
	JRST	(X1)		;START LINE OVER.

;RESTORE DATA POINTER

RESTOR:	PUSHJ	P,RESTOS	;RESTORE BOTH NUMBERS AND STRINGS
RESTON:	TDZA	X1,X1		;RESTORE NUMERIC DATA
RESTOS:	MOVEI	X1,1		;RESTORE STRINGS
	MOVE	T,DATAFF
	ADD	T,FLLIN
	SUB	T,[XWD 1,1]
	MOVEM	T,DATLIN
	SETZM	PREAD		;CLEAR CURRENT LINE POINTER
	POPJ	P,


NXRE2:	PUSHJ	P,INLMS0	;OUT OF DATA
	ASCIZ	/OUT OF DATA IN /
	HRRZ	T,L
	PUSHJ	P,PRTNUM
	PUSHJ	P,INLMS0
	ASCIZ	/
/
	JRST	UXIT



IMP:	PUSHJ	P,INLMS0
	ASCIZ	/BAD DATA INTO LINE /
IMP1:	HRRZ	T,CURLIN
	PUSHJ	P,PRTNUM
	PUSHJ	P,INLMS0
	ASCIZ	/
/
	JRST	UXIT

FNR:	PUSHJ	P,INLMS0
	ASCIZ/ FILE NEVER ESTABLISHED - REFERENCED IN LINE /
	JRST	IMP1
ENFAIL:	PUSHJ	P,INLMS0
	ASCIZ	/FAILURE ON ENTER IN LINE /
	JRST	IMP1


ILWRT:	PUSHJ	P,INLMS0
	ASCIZ	/ILLEGAL DSK WRITE IN LINE /
	JRST	IMP1
ILRD:	PUSHJ	P,INLMS0
	ASCIZ	/ILLEGAL DSK READ IN LINE /
	JRST	IMP1

LOKFAL:	PUSHJ	P,INLMS0
	ASCIZ/FILE /
	MOVE	T,FILD-1(X1)
	PUSHJ	P,PRNSIX
	PUSHJ	P,INLMS0
	ASCIZ/ NOT FOUND BY RESTORE COMMAND IN LINE /
	JRST	IMP1

EOFFAL:	POP	P, X1
	SUB	P,[XWD 2,2] 	;T.S. FOR BUG IN GO SUB
	SETZM	IFIFG		;CLEAR INPUT FROM DISK FLAG
	SKIPN	X1, EOFLOC(LP)	;ANYPLACE TO GO ON EOF?
	JRST	EOFL1		;NO
	SETZM	EOFLOC(LP)	;YES
	JRST	(X1)		;GO THERE
EOFL1:	PUSHJ	P,INLMS0
	ASCIZ/EOF IN LINE /
	HRRZ	T,CURLIN
	PUSHJ	P,PRTNUM
	PUSHJ	P,INLMS0
	ASCIZ	/
/
	MOVSI	X3,(JRST X2,)
	HRR	X3,LINPT(LP)
	MOVEI	X2,^D25
	SETZM	@X3
	SOJG	X2,.-1
	JRST	UXIT


TMF:	PUSHJ	P,INLMS0
	ASCIZ/TOO MANY FILES
/
	JRST	UXIT
;RUNTIME MAT INPUT ROUTINE

MATIN:	PUSHJ	P,DOINPT		;SETUP INPUT LOOP
	HRRZ	X1,40		;GET VECTOR 2-WD BLOCK ADDRESS
	HRRZ	X2,(X1)		;GET ADDRESS OF FIRST ELEMENT
	MOVEM	X2,NUMRES	;SAVE THIS VALUE FOR COUNTING ELEMENTS LATER
	HLRZ	X1,(X1)		;GET MAXIMUM VECTOR SIZE
	ADD	X1,X2		;UPPER BOUND OF VECTOR
	MOVEM	X1,ELETOP	;SAVE FOR COMPARISON LATER
	HRRM	X2,40		;SET UP ELEMENT ADDRESS FOR DATA ROUTINES

MATIN1:	MOVEI	X1,MATIN4	;POINT "INPUT ERR" TO SPECIAL ROUTINE
	HRL	X1,40		;REMEMBER FIRST ELEMENT ON LINE
	MOVEM	X1,INPFLA
	PUSHJ	P,NXVINP	;INPUT THE LINE

MATIN5:	CAIA		;THERE IS ANOTHER ELEMENT.
	JRST	MATIN6	;NULL LINE. NO MORE ELEMENTS.
	HRRZ	X1,40		;MAY WE ACCEPT ANOTHER ELEMENT?
	CAML	X1,ELETOP
	JRST	MATIN3		;NO
	AOS	40		;POINT TO NEXT ELEMENT
	PUSH	P,[EXP MATIN2]	;YES. SETUP RETURN FROMDATA ROUTINE
IFN FTSTR,<
	CAML	X1,SVRBOT	;NUMBER OR STRING VECTOR?
	JRST	SDATAE		;STRING
>
	JRST	DATAER		;NUMBER

MATIN2:	SETOM	MORFLA		;AT LEAST ONE ELE HAS BEEN RECEIVED.
	TLNE	C,F.COMA	;MORE ON THIS LINE?
	JRST	MATIN5	;YES
	TLNE	C,F.TERM	;NO. END OF INPUT?
	JRST	MATIN6		;YES. SETUP "NUM" FUNCTION AND RETURN
	CAIN	C,"&"		;NO. MORE ON NEXT LINE?
	JRST	MATIN1		;YES
	JRST	INPERR		;SOME OTHER TERMINAL CHAR. VERY BAD.

MATIN3:	PUSHJ	P,INLMES
	ASCIZ /TOO MANY ELEMENTS -- RETYPE LINE
/
	JRST	INPER1

MATIN4:	HLRZ	X1,INPFLA	;AN ERROR HAS OCCURRED. START LINE OVER
	HRRM	X1,40		;WITH SAME ELEMENT
	JRST	MATIN1

MATIN6:	HRRZ	X1,40		;CALCULATE NUMBER OF ELEMENTS
	SUB	X1,NUMRES
	TLO	X1,233400	;FLOAT  RESULT
	FSB	X1,FIXCON
	MOVEM	X1,NUMRES
	POPJ	P,

IFN FTSTR,<
REDSTR:	SKIPE	INPFLA		;INPUT?
	JRST	.+3
	TLNN	C, F.LETT+F.QUOT+F.DIG	;NO.  CHECK DATA FIRST TIME ONLY
	POPJ	P,
	AOS	(P)		;THIS IS A LEGITIMATE STRING
	PUSH	P,G
	PUSH	P,E
	PUSHJ	P,GETSTR	;SETUP STRING
	PUSHJ	P,VCHECK	;MAKE SPACE
	MOVEI	X3,F.COMA+F.TERM	;ASSUME A STRING WITHOUT QUOTES
	TLNN	C,F.QUOT	;IS IT A QUOT STRING?
	JRST	REDS1		;NO
	MOVEI	X3,F.QUOT	;YES. TERMINAL CHAR IS QUOTE ONLY
	PUSHJ	P,NXCHS		;SKIP QUOTE
REDS1:	SETZI	X2,		;INITIALIZE COUNT
	SKIPE	(F)		;NEW STRING?
	SETZM	VPAKFL	;NO, GARBAGE NOW EXISTS
	HRR	F,VARFRE	;GET FREE LOCATION
	HRRM	F,@N		;STORE ADDRESS OF STRING
REDS2:	TLNE	C,(X3)		;END OF STRING?
	JRST	REDS3		;YES, FINISH IT UP
	TLNE	C, F.CR		;END OF LINE BEFORE QUOTE?
	JRST	REDS3		;YES.  QUIT ANYWAY.
	IDPB	C,F		;STORE A CHAR
	PUSHJ	P,NXCHS
	SOJA	X2,REDS2	;COUNT THE CHAR

REDS3:	TLNE	C,F.QUOT	;SKIP QUOTE CHAR
	PUSHJ	P,NXCH
	HRRZ	X1,F		;GET NEW FREE LOCATION
	POP	P,E
	POP	P,G
	JRST	PUTST2

SSKIP:	SKIPE	INPFLA		;IS THIS INPUT OR READ?
	JRST	SSKP1		;INPUT. CANT SKIP ANY FIELDS
	PUSHJ	P,SKIPDA	;SKIP OVER A DATA FIELD
	HALT	.	;IMPOSSIBLE ERROR
	POP	P,X1
	TLNE	C,F.TERM	;END OF DATA LINE?
	JRST	-4(X1)		;YES. FORCE DATA SEARCH
	JRST	-3(X1)		;RETURN TO DATAER OR SDATAE

SSKP1:	ADD	P,[XWD -2,-2]	;CLEAN UP PUSH LIST
	JRST	INPERR

;ROUTINE THAT SKIPS OVER ONE DATA FIELD
SKIPDA:	TLNE	C,F.QUOT	;QUOTE STRING?
	JRST	QSKIP		;YES, USE QSKIP ROUTINE
	TLNE	C,F.COMA+F.TERM	;FIELD TERMINATOR?
	JRST	CPOPJ1
	PUSHJ	P,NXCH	
	JRST	.-3
>;ASSEMBLE ABOVE IF INCLUDING STRING FACILITY

IFE FTSTR,<
SKIPDA:	POPJ	P,	;STRINGS NOT ALLOWED. DATA ERROR

SSKIP:	ADD	P,[XWD -2,-2]	;CLEAN UP PUSHLIST
	JRST	INPERR
>


;RUN-TIME ROUTINE FOR FORMATTED OUTPUT:

	EXTERN	FMTPTR

UFRMAT:	HRRZ	X1,40		;GET LINE # OF FORMAT STATEMENT
	JUMPE	X1, UFRMT1
	MOVE	A, FLLIN
	CAML	A, CELIN
	JRST	NOFRMT		;LINE NON-EXISTANT!
	HLRZ	X2,(A)
	CAIE	X1,(X2)
	AOJA	A, .-4
	MOVEM	A, CONLIN		;SAVE IN CASE LINE CONTINUED
	HRLZ	A,X2
	MOVEI	R, LINROL
	PUSHJ	P, SEARCH
	JRST	NOFRMT		;CAN'T FIND IT
	MOVE	T, (B)		;GET POSITION OF LINE
	HRLI	T, 440700	;BUILD BYTE POINTER
UFRMT0:	PUSHJ	P, NXCH
	TLNE	C, F.TERM
	JRST	NOFRMT		;NOT A FORMAT STATEMENT
	CAIE	C, ":"
	JRST	.-4
	MOVEM	T, FMTPTR	;SAVE POINTER TO FIRST FORMAT CHAR.
	PUSHJ	P, NXTSPC		;PRINT TO NEXT SPECIAL (FORMAT) CHAR.
	POPJ	P,

UFRMT1:	MOVE	T, [POINT 7, LINB0]
	JRST	UFRMT0

NOFRMT:	PUSHJ	P, INLERR
	ASCIZ/ILLEGAL LINE REFERENCE /
	HRRZ	T, 40
	PUSHJ	P, PRTNUM
	PUSHJ	P, INLMES
	ASCIZ/ IN PRINT STATEMENT
/
	JRST	UXIT

NXTSPC:	EXCH	T, FMTPTR
NXTSP0:	ILDB	C, T		;GET NEXT CHAR
NXTSP1:	CAIE	C, "%"
	CAIN	C, "#"
	JRST	DNENXT
	CAIN C,"."
	JRST DNENXT
DNE1:	CAIN	C, "\"
	JRST	CONFRM		;FORMAT CONTINUED ON NEXT LINE
	CAIN	C, 42
	JRST	DNENXT		;ALPHA STRING
	CAIE	C, ":"
	CAIN	C, 15
	JRST	ENDFMT		;END OF FORMAT LINE HERE,
	PUSHJ	P, OUCH		;NOT SPECIAL CHAR.  SEND IT
	JRST	NXTSP0		;AND GET ANOTHER
DNENXT:	PUSHJ	P, INTERP		;INTERPRET NEXT FORMAT
	PUSHJ	P, BACK1	;BACK UP THE BYTE POINTER
	EXCH	T, FMTPTR	;SAVE FOR LATER
	POPJ	P,		;AND RETURN

CONFRM:	ILDB	A,T	;LOOK AT NEXT CHAR
	CAIN	A, 15
	JRST	CNFRM0
	PUSHJ	P, OUCH	;NOT A CAR.RET., SO THE "\" MUST BE LEGITIMATE
	MOVEI	C, (A)
	JRST	NXTSP1
CNFRM0:	MOVEI	A, 1
	ADDB	A, CONLIN
	HLLZ	A, (A)		;GET NEXT LINE #
	MOVEI	R, LINROL
	PUSHJ	P, SEARCH
	JRST	NOCONT
	MOVE	T, (B)
	HRLI	T, 440700	;BUILD BYTE POINTER
	JRST	NXTSP0		;AND GET NEXT CHAR
NOCONT:	PUSHJ	P, INLERR
ASCIZ/ILLEGAL CONTINUATION OF FORMAT STATEMENT - LINE /
	MOVE	A, CONLIN
	HLRZ	T, -1(A)
	PUSHJ	P, PRTNUM
	JRST	UXIT

ENDFMT:	PUSHJ	P, BACK1
	EXCH	T, FMTPTR
	MOVE	X1, FMTPNT(LP)
	MOVEI	A, 2		;ONE OR TWO CHAR TO PRINT
	CAIE	X1, 1
	CAIN	X1, 5
	JRST	FINPN1
	LDB	X1, [POINT 4,40,12]
	CAIE	X1,1
	CAIN	X1,5		;UNLESS HE SPECIFIED CR ONLY,
	JRST	FINPN1
	MOVEI	X1, 1		;INSURE A CRLF PAIR
	JRST	FINPN1

;FLAGS USED IN INTERPRETING FIELD SPECIFICATIONS:

	F.ALFA=10000
	F.ESPC=4000
	F.FIXD=2000
	F.FLOT=1000

INTERP:	SETOM	FMTFLG
	SETZM	FLDLEN
	CAIN	C, "%"
	JRST	FIXFLT		;FIXED OR FLOATING POINT
	CAIN C,"."
	JRST FLO
	CAIN	C, "#"
	JRST	ESPEC		;E-SPECIFICATION
	CAIE	C, 42
	POPJ	P,		;UNKNOWN
	TLO	C, F.ALFA	;ALPHA FIELD
	MOVEI	A, 1
	ILDB	B, T
	CAIN	B, 42
	AOJA	A, .-2
COUNTR:	HRRM	A, FLDLEN	;SAVE LENGTH OF FIELD
	HLLZM	C, FLDSPC	;AND SPEC. FLAG
	POPJ	P,

FIXFLT:	MOVEI	A, 1
	ILDB	B, T
	CAIN	B, "%"
	AOJA	A, .-2
	CAIE	B, "."		;FLOATING POINT?
	JRST	FIXED
	TLO	C, F.FLOT	;YES.
	HRLM	A, FLDLEN
	SETZ	A,
FIXFL1:	ILDB	B, T
	CAIN	B, "%"
	AOJA	A, .-2
	JRST	COUNTR
FIXED:	TLO	C, F.FIXD
	JRST	COUNTR
ESPEC:	MOVEI	A, 1
	ILDB	B, T
	CAIN	B, "#"
	AOJA	A, .-2
	CAIN	B, "."
	JRST	ESPEC0		;DEC. POINT IS GOOD HERE
ILLSPC:	PUSHJ	P, INLERR
ASCIZ/

ILLEGAL E-FORMAT FIELD SPECIFICATION IN LINE /
	HLRZ	T, @CONLIN
	PUSHJ	P, PRTNUM
	JRST	UXIT


FLO:	SETZ A,
	HRLM A,FLDLEN
	SETZ A,
	ILDB B,T
	CAIN B,"%"
	JRST FLOT
	CAIN B,"#"
	JRST ES
	POP P,; CLEAN UP PDL
	PUSHJ P, BACK1	;BACK UP POITER
	JRST DNE1	;PRINT OUT "." AND THE REST OF JUNK

FLOT:	TLO C,F.FLOT	;SET FLOAT FLAG
	AOJ A,	;ADD TO COUNTER
	JRST FIXFL1	;CONTINUE 
ES:	TLO C,F.ESPC	;SET E FLAG
	AOJ A,;	ADD TO COUNTER
	JRST ESP1	;CONTINUE
ESPEC0:	TLO	C, F.ESPC
	HRLM	A, FLDLEN
	SETZ	A,
ESP1:	ILDB	B, T
	CAIN	B, "#"
	AOJA	A, .-2
	CAIL	A, 4
	JRST	COUNTR
	JRST	ILLSPC


INLERR:	PUSHJ	P, TTYIN
	SETZM	FMTFLG
	JRST	INLMS0
	SUBTTL RUN-TIME ROUTINES FOR PRINTING

PRTXER:	SKIPN	ODF
	SETZ	LP,
	JUMPE	LP,.+3
	SKIPE	LNINS-1(LP)
	PUSHJ	P,NUMINS
	SKIPN	FMTFLG		;UNLESS FORMATTED OUTPUT,
	PUSHJ	P,TABBER	;MOVE TO TAB STOP
	SETZM	NUMFLA(LP)		;THIS ITEM IS NOT A NUMBER
	MOVEI	D,42
	MOVE	T,@0(P)
	AOS	(P)
	SKIPN	FMTFLG
	JRST	.+5
	MOVE	A, FLDSPC	;FORMATTING IN EFFECT.  RIGHT SPEC.?
	TLNN	A, F.ALFA
	JRST	NOTFT0
	MOVE	A, FLDLEN	;YES.  WHAT SIZE FIELD?
	PUSHJ	P,PRINT1
	SKIPE	FMTFLG
	JRST	PRSTR2


FINPNT:	SKIPE	FMTFLG		;DON'T BOTHER HERE IF FORMATTED OUTPUT
	JRST	FINPT2
	MOVE	X1,FMTPNT(LP)	;FINISH WITH CR?
FINPN1:	CAIN	X1, 5
	JRST	ONLYCR
	CAIE	X1,1
	JRST	FINPT2		;NO
	SETZM	FMTPNT(LP)
DOCRLF:	PUSHJ	P,PCRLF
	POPJ	P,

CRLF3:  MOVEI C,15
        PUSHJ P,OUCH
        MOVEI C,12
        JRST OUCH
PCRLF:	SKIPN	ODF
	JRST	.+5
	SKIPE	NLN-1(LP)
	JRST	.+3
	SKIPE	FMTFLG
	MOVEI	A, 2
	PUSHJ	P,INLMES
	ASCIZ	/
/
	PUSH	P,LP
	SKIPN	ODF
	SETZ	LP,
	SKIPN	NLN-1(LP)
	SETOM	LNINS-1(LP)
	SETZM	NUMFLA(LP)		;DURING EXECUTION, SIGNAL THAT
	SETZM	TABVAL(LP)
	POP	P,LP
				;A NUMBER WAS NOT THE LAST ITEM PRINTED
FINPT2:	MOVE A,ODF
	JUMPN A,	FINCR	;IF NOT DSK CHECK LENGTH
	OUTPUT
	POPJ P,
FINCR:	SKIPE FMTFLG
	JRST .-3
	MOVE A,HPOS(LP)
	CAIN LP,12
	JRST LPT4
	CAIGE A,^D60
	POPJ P,
	PUSHJ P,PRNMDS	;NOT ENOUGH
	POPJ P,
	OUTPUT
	POPJ	P,
LPT4: CAIGE A,^D118
	POPJ P,
	PUSHJ P,PRNMDS
	POPJ P,
;RUN-TIME NUMBER PRINTER

PRNMER:	SKIPN	ODF
	SETZ	LP,
	JUMPE LP,PR1
	SKIPE LNINS-1(LP)
	PUSHJ P,NUMINS
PR1:	PUSHJ P,TABBR
	MOVE	N,@40		;GET THE NUMBER
	PUSHJ	P,OUTNUM
	JRST	FINPNT


PRNMDS:	PUSHJ P,NUMIN1
	SKIPN NLN-1(LP)
	SETOM LNINS-1(LP)
	SETZM TABVAL(LP)
	SETZM NUMFLA(LP)
	POPJ P,

;RUN-TIME TAB PRINTER


PRNTBR:	LDB	X1, [POINT 4,40,12]	;GET AC FIELD
	CAIN	X1, 5
	JRST	ONLYCR		;JUST A CAR. RET. FOR HIM.
	SETOM TABFG
	SKIPN	ODF
	SETZ	LP,
	JUMPE	LP,.+3
	SKIPE	LNINS-1(LP)
	PUSHJ	P,NUMINS
	PUSHJ	P,TABBR		;CALCULATE AMOUNT OF SPACING REQUESTED BY
					;LAST FORMAT CHAR.  ADD THAT TO "TABVAL(LP)"
					;BUT DO NOT PUT OUT THE SPACES.
	PUSH P,N	;SVAE N
	HRRZ N,40
	CAIN N,ONCESW	;SEE IF FIRST THING
	JRST FIRST	;YUP
	POP P,N
	JUMPLE N,FINPNT
	SKIPGE B,TABVAL(LP)
	JRST FINPNT
	FAD	N,FIXCON
	TLZ	N,377400		;NOW THE DESIRED COLUMN IS A FIXED NUMBER
	SUB	N,HPOS(LP)			;ARE WE ALREADY PAST THIS COLUMN, TAKING INTO ACCOUNT
	SUB	N,B			;FURTHER SPACING WHICH HAS ALREADY BEEN REQUESTED (SUBTRACTED HERE)
	JUMPLE	N,FINPNT		;YES,IGNORE REQUEST
	ADDM	N,TABVAL(LP)		;NO, ADD THE DIFFERENCE TO THE SPACING  REQUEST
	JRST	FINPNT




FIRST:	POP P,N
	JRST FINPNT
NUMIN1:	MOVEI C,15
	PUSHJ P,OUCH
	MOVEI C,12
	PUSHJ P,OUCH
	POPJ P,
NUMINS:	CAIN LP,12
	POPJ P,
	SETZM HPOS(LP)
	SKIPE NLN-1(LP)	;	TEST IF LINE NOS WANTED
	POPJ P,	;	NO LINE NOS WANTED
	SETZM FMTPNT(LP)
	MOVEI	X2,12
	ADDM	X2,LINNUM-1(LP)
	PUSH	P,T
	MOVE	T,LINNUM-1(LP)
	PUSHJ	P,PRTNUM
	POP	P,T
	MOVEI	C,"	"
	SETZM	LNINS-1(LP)
	JRST	OUCH

ONLYCR:	SETOM	HPOS(LP)
	SETZM	TABVAL(LP)
	SETZM	FMTPNT(LP)
	MOVEI	C, 15
	JRST	OUCH
;TAB CONTROL

;"TABBER" CALLS "TABBR" AND THEN THEN MOVES SPACES OR A CRLF TO THE TTYOUT BUFFER.
;"TABB2" CREATES THE ACTUAL SPACES, ACCORDING TO A COUNT THEN IN "B"
;"TABBR" ANALYSES THE LAST FORMAT CHARACTER USING "TABB1" AND
;"TABB3", WHICH HANDLE THE COMMA AND SEMICOLON, RESPECTIVELY.
;"NUMFLA" IS MINUS IF THE LAST ITEM TYPED OUT WAS A NUMBER
;"TABVAL" CONAINS THE NUMBER OF SPACES WAITING TO BE TYPED OUT
;(OR IS NEGATIVE IF A <RETURN> MUST FOLLOW.)


TABBER:	PUSHJ	P,TABBR		;PROCESS LAST FORMAT CHAR
	MOVEI	X1,0	;TABBER CALLS ALLOW A PRINT FIELD OF ANY SIZE
CHROOM:	MOVE	B,TABVAL(LP)
	ADD	X1,B		;TOTAL SPACE NEEDED FOR FIELD
	ADD	X1,HPOS(LP)
	SKIPE FMTFLG
	JRST LPT1
	CAIN LP,12
	JRST LPT1
;	SKIPE	ODF
;	JRST	.+3
	CAIL	X1,^D72
	JRST	DOCRLF		;NO ROOM, GO TO NEXT LINE.
	JRST	.+3
LPT1:	CAIL	X1, ^D130	;ALLOW 130 CHAR LINE ON DSK AND LPT
	JRST	DOCRLF
	JUMPL	B,DOCRLF
	JUMPE	B,CPOPJ		;NO SPACING TO DO.


TABB2:	MOVEI	C," "		;HERE TO PUT OUT SPACES
	PUSHJ	P,OUCH
	SOJG	B,TABB2
	SETZM	TABVAL(LP)
	POPJ	P,

TABBR:	LDB	X1,[POINT 4,40,12]
	EXCH	X1,FMTPNT(LP)		;GET OLD POSITION AND SAVE NEW FORMAT
	MOVE	A,TABVAL(LP)
	JUMPL	A,SETCR		;<RETURN> IS NEXT. IGNORE SPACING
	ADD	A,HPOS(LP)
	JRST	.+1(X1)
	POPJ	P,			;NO FMT CHAR
	POPJ	P,		;<CR> WAS TYPED WHEN FIRST SEEN.
	JRST	TABB3			;SEMICOLON
TABB1:	SKIPE FMTFLG
	JRST LPT2A
	CAIN LP,12
	JRST LPT2
;	SKIPN	ODF
;	JRST	.+3
	CAILE	A, ^D56;	CHANGE BACK TO 111 FOR LPT

	JRST	SETCR
	JRST	.+3
LPT2:	CAILE A,^D111
	JRST	SETCR
LPT2A:	SKIPE	TABFG
	JRST	TAB23	;TAB FUNCTION IN EFFECT-NO FORMATING
	IDIVI A,^D14
	JUMPE B,.+3
	SUBI B,^D14
	MOVNS	B
	ADDB	B,TABVAL(LP)
	POPJ	P,
TAB23:	SETZM	TABFG	;ZERO TAB FUNCTION FLAG
	POPJ	P,

TABB3:	SKIPE FMTFLG
	JRST LPT3
	CAIN LP,12
	JRST LPT3
;	SKIPE	ODF	;DSK WRITE?
;	JRST	.+3	;YES.  ALLOW LONGER LINES
	CAILE A,^D69   ;HERE ON SEMICOLON IF PRINTING
	JRST	SETCR
	JRST	.+3
LPT3:	CAILE	A, ^D125;	CHANGE BACK TO 125 FOR LPT
	JRST	SETCR
	AOS	NUMFLA(LP)
	POPJ	P,

SETCR:	SETOM	TABVAL(LP)		;FORCE <RETURN TO BE NEXT>
	SKIPN ODF
	POPJ P,
	PUSHJ P,PRNMDS
	PUSHJ P,NUMINS
	POPJ	P,

IFN FTSTR,<
	SUBTTL  RUN-TIME STRING MANIPULATION ROUTINES.


;GETSTR IS CALLED WITH THE ADDRESS OF A POINTER IN REG.
;THE ROUTINE SETS UP THE POINTER IN F, AND THE NEGATIVE COUNT OR
;(FOR LITERAL STRINGS) A POSITIVE QUANTITY IN G. (G=0 IF NULL STRING)

;GETSTR ALSO CHECKS FOR ADEQUATE SPACE TO MOVE STRING.

GETSTR:	PUSHJ	P,PNTADR	;GET ADDRESS OF STRING POINTER
	MOVE	F,@N		;GET STRING POINTER.
	HLRE	G,F		;PUT NEGATIVE CHAR LENGTH IN G, IF NOT LITERAL.
	JUMPG	G,CPOPJ	;IF ITS A LITERAL, ALL FINISHED.
	HRLI	F,440700	;NOT LITERAL, INITIALIZE POINTER.
	POPJ	P,

;ROUTINE TO SET UP A NUMBER VECTOR INSTEAD OF A STRING
GETVEC:	HRRZ	F,@40		;THE LEFT SIDE OF (F) IS ZERO, IMPLYING VECTOR ADR,
	MOVE	G,(F)		;GET VECTOR LENGTH
	JUMPL	G,GETVF		;NEGATIVE? 
	FAD	G,FIXCON	;FIX THE LENGTH
	TLZ	G,777400
	HLRZ	X1,@40		;DOES THE LENGTH EXCEED VECTOR BOUNDS?
	MOVNS	G
	ADD	X1,G
	JUMPLE	X1,.+2
	AOJA	F,CPOPJ		;NO. POINT TO FIRST "CHAR" AND RETURN

GETVF:	PUSHJ	P,INLMES
	ASCIZ /IMPOSSIBLE VECTOR LENGTH IN /
	JRST GOSR2

;GETCH GETS THE NEXT CHAR OF A STRING INTO (C), WHERE THE BYTE POINTER
;AND COUNT ARE IN (F) AND (G) AS SETUP ABOVE.  WHEN THE END OF THE
;STRING IS REACHED, (G) ::=0
;GETCH DOES A SKIP RETURN UNLESS THE END OF STRING HAS BEEN REACHED.
GETCHE:	SETZI	G,		;MARK END OF STRING
GETCH:	SETZI	C,		;ASSUME END OF STRING
	JUMPE	G,CPOPJ		;THIS IS END OF STRING
	ILDB	C,F		;NOT END OF STRING, GET NEXT CHAR
	JUMPG	G,.+2		;LITERAL STRING?
	AOJA	G,CPOPJ1		;NO, SHORTEN COUNT AND RETURN
	CAIE	C, 15		;CAR.RET., OR
	CAIN	C,42		;QUOTE CHAR?
	JRST	GETCHE		;YES, TERMINATE STRING
	CAIE	C, "\"		;CONTINUED LINE?
	JRST	CPOPJ1
	ILDB	C, F		;YES.  LOOK FOR MORE
	CAIG	C, 15
	JRST	.-2
	JRST	CPOPJ1

;ROUTINE TO GET NEXT VECTOR ELE AS A CHARACTER
GETEL:	AOJG	G,CPOPJ		;IS THERE ANOTHER ELEMENT?
	MOVE	C,(F)		;YES. GET IT
	JUMPL	C,GETELF		;TOO SMALL TO BE AN ASCII
	LDB	X3,[POINT 8,C,8]	;GET EXPONENT
	TLZ	C,777000		;TURN IT OFF
	LSH	C,-233(X3)		;SHIFT INTO INTEGER POSTION
	TRNN	C,777600		;STATISTICALLY ADEQUATE CHECK ON CHAR
	AOJA	F,CPOPJ1	;BUMP ELEMENT POINTER AND RETURN

GETELF:	PUSHJ	P,INLMES
	ASCIZ /NON-ASCII CHAR SEEN IN /
	JRST	GOSR2

CHLEN=5*LITLEN			;MAX CHAR LENGTH OF A LITERAL

;PUTSTR IS ENTERED WITH THE ADDRESS OF THE RESULT POINTER IN REG

PUTSTR:	PUSHJ	P,PNTADR	;GET ADDRESS OF BYTE POINTER
	PUSHJ	P,VCHECK	;MAKE SPACE
	SKIPE	@N		;WAS STRING PREVIOUSLY NULL?
	SETZM	VPAKFL		;NO. STRINGS WILL NOT BE TIGHTLY PACKED.
	MOVE	X1,VARFRE	;START STRING AT NEXT FREE LOCATION
	MOVEM	X1,@N
	HRLI	X1,440700	;INITIALIZE POINTER
	SETZI	X2,		;INITIALIZE COUNT OF LENGTH.

PUTST1:	PUSH	P,[EXP PUTST3]
	TLNN	F,-1		;IS (F) A STRING POINTER?
	JRST	GETEL		;NO. GET NEXT VECTOR ELEMENT
	JRST	GETCH		;YES. GET NEXT CHAR
PUTST3:	JRST	PUTST2		;END OF STRING, NO MORE CHARS
	HRRM	X1,VARFRE		;AND SAVE
	IDPB	C,X1		;STORE CHAR
	SOJA	X2,PUTST1	;COUNT CHAR

PUTST2:	HRLM	X2,@N		;SAVE IT IN POINTER.
	AOJ	X1,		;UPDATE FREE SPACE
	HRRM	X1,VARFRE	;SAVE NEW FREE LOCATION
	POPJ	P,

;ROUTINE TO MOVED CHANGED CHARS INTO A VECTOR
PUTVEC:	HRRZ	X1,@40		;GET VECTOR ADDRESS 
	MOVE	N,X1		;SAVE FIRST LOC ADDRESS FOR LENGTH STORE
	HLRZ	X2,@40		;GET SIZE

PUTV1:	PUSHJ	P,GETCH		;GET CHAR
	JRST	PUTV9		;NO MORE CHARS
	SOJL	X2,PUTVF	;ROOM FOR ANOTHER CHAR?
	TLO	C,233400	;YES. FLOAT IT
	FSB	C,FIXCON
	MOVEM	C,1(X1)
	AOBJP	X1,PUTV1	;COUNT CHARS IN LEFT HALF OF X1

PUTV9:	HLRZ	X1,X1		;GET SIZE
	HRLI	X1,233400	;FLOAT IT
	FSB	X1,FIXCON
	MOVEM	X1,@N		;FIRST ELEMENT GETS SIZE
	POPJ	P,

PUTVF:	PUSHJ	P,INLMES
	ASCIZ /NO ROOM FOR STRING IN /
	JRST	GOSR2

;COMSTR COMPARES TWO STRINGS. ONE HAS BEEN FETCHED. THE POINTER
;TO THE OTHER IS IN REG.  THE COMPARE RELATION IS IN (P)
;COMSTR GETS A PAIR OF CHARS, ONE FROM EACH STRING, USING "GETPCH".
;WHEN IT REACHES THE END OF ONE OR BOTH STRINGS, OR WHEN IT FINDS
;AN UNEQUAL CHAR PAIR, THE ROUTINE USES THIS PAIR OF CHACTERS
;WHILE EXECUTING THE RELATION (NOTE: FIRST, HOWEVER, A CHECK IS MADE
;FOR TRAILING BLANKS).

COMSTR:	PUSH	P,F
	PUSH	P,G		;SAVE THE "FETCHED" STRING
	PUSHJ	P,GETSTR	;FETCH THE OTHER STRING
	POP	P,T1
	POP	P,T		;NOW BOTH STRINGS ARE "FETCHED"

IFST1:	PUSHJ	P,GETPCH	;GET PAIR OF CHARS IN (A) AND (C)
	JUMPG	X3,IFST3	;HAVE BOTH STRINGS ENDED?
	JUMPE	X3,IFST2	;HAS ONE STRING ENDED?
	CAMN	C,A		;ARE THESE TWO CHARS THE SAME?
	JRST	IFST1		;YES. LOOK AT NEXT PAIR

IFST2:	SETOI	X3,		;CHECK BOTH STRINGS FOR TRAILING BLANKS
	CAIN	C," "		;IS THIS CHAR A BLANK?
	PUSHJ	P,IFST4		;YES, GO CHECK STRING
	PUSHJ	P,EXCH6		;LOOK AT OTHER STRING
IFST2A:	AOJLE	X3,IFST2+1

IFST3:	HLLZ	X1,@(P)	;GET RELATION
	AOS	(P)
	IOR	X1,[Z A,C]	;SETUP COMPARE
	XCT	X1
	POPJ	P,		;RETURN AND "GOTO"
	JRST	CPOPJ1		;RETURN AND STAY IN LINE

IFST4:	PUSHJ	P,GETCH		;IS BLANK REALLY A TRAILING BLANK?
	POPJ	P,
	CAIN	C," "		;IS NEXT CHAR A BLANK?
	JRST	.-3		;YES KEEP LOOKING
	MOVEI	C," "		;NO. USE BLANK FOR COMPARE
	POPJ	P,

;ROUTINE TO GET A PAIR OF CHARS
GETPCH:	SETOI	X3,	;COUNT TERMINATED STRINGS IN X3
	PUSHJ	P,GETCH
	AOJ	X3,		;NON-SKIP RETURN MEANS STRING ENDED
	PUSHJ	P,EXCH6		;LOOK AT OTHER STRING
	PUSHJ	P,GETCH
	AOJ	X3,

EXCH6:	EXCH	T,F		;MOVE OTHER STRING INFO TO (C),(F),(G)
	EXCH	T1,G
	EXCH	A,C
	POPJ	P,

;PRSTRR PRINTS A STRING WHOSE POINTER IS ADDRESSED IN (40)

PRSTRR:	PUSH	P,G		;SAVE G (FOR MAT READ AND PRINT)
	SKIPN	ODF
	SETZ	LP,
	JUMPE	LP,.+3
	SKIPE	LNINS-1(LP)
	PUSHJ	P,NUMINS
	PUSHJ	P,PNTADR	;GET ADR OF STRING POINTER
	PUSHJ	P,GETSTR	;SETUP STRING FETCH
	SKIPN	FMTFLG
	JRST	.+6	;FORMATTING NOT IN EFFECT
	MOVE	A, FLDSPC	;YES IT IS.  GET SPEC.
	TLNN	A, F.ALFA
	JRST	NOTFIT		;WRONG ONE.
	MOVE	A, FLDLEN	;O.K.  GET FIELD LENGTH
	JRST	.+3
	PUSHJ	P,TABBER	;MOVE TO TAB STOP
	MOVEI	A, ^D130	;FAKE LONG FIELD IF NOT FORMATTED
	SETZM	NUMFLA		;THIS ITEM IS NOT NUMERIC
	PUSHJ	P,GETCH		;GET NEXT CHAR
	JRST	PRSTR1		;FINISH UP PRINT ITEM
	JUMPLE	A, .-2
	PUSHJ	P,OUCH		;PRINT CHAR
	SOJA	A, .-4

PRSTR1:	POP	P,G
	SKIPN	FMTFLG
	JRST	FINPNT
PRSTR2:	MOVEI	C, " "
	JUMPLE	A, NXTSPC	;ANY SPACE REMAINING IN FIELD?
	PUSHJ	P, OUCH		;YES.  PUT OUT A BLANK
	SOJA	A, .-2

>;ASSEMBLE ABOVE FO STRINGS

MCHPWD:	MOVN	X1,G	;+WORDLEN IN E _ -CHARLEN IN G
	ADDI	X1,4
	IDIVI	X1,5
	MOVE	E,X1
	POPJ	P,

IFN FTSTR,<
;ROUTINE TO PUT ADRESS OF POINTER IN REG
PNTADR:	HRRZ	N,40	;GET UUO ADDRESS
	MOVE	X1,@N		;GET WORD IT ADDRESSES
	JUMPGE	X1,CPOPJ	;ALL DONE IF THIS IS A REAL POINTER
	TLNN	X1,377777	;ALL DONE IF THIS IS NEGATIVE COUNT
	HRRZ	N,X1		;(X1) IS REAL POINTER ADDRESS
	POPJ	P,
>;ASSEMBLE ABOVE IF INCLUDING STRING FACILITY

SUBTTL	SUBSCRIPTED VARIABLE FETCH/STORE ROUTINES

;MATRIX ELEMENT FETCH/STORE UUO ROUTINES


IFN	FTSTR, <
SAD1ER:	MOVE	D,[JRST SADEND]	;FETCH ADR OF ARRAY ELEMENT
	JRST	AFT1ER+1
>

ASN1ER:	MOVE	D,[MOVNM N,(A)] ;NEGATIVE ARRAY STORE
	JRST	.+3
AST1ER:	SKIPA	D,[MOVEM N,(A)]	;POSITIVE ARRAY STORE
AFT1ER:	MOVSI	D,A(MOVE N,)	;ARRAY FETCH
	MOVEI	A,0		;PSEUDO LEFT HALF
	MOVE	B,40		;ARRAY ADDRESS
	HRRZ	C,1(B)		;TRY RIGHT DIMENSION
	TRNN	C,777776	;ROW VECTOR?
	HLRZ	C,1(B)		;NO, MUST BE COLUMN VECTOR
	JRST	AFT2C		;FINISH UP WITH 2-DIM CODE

ASN2ER:	MOVE	D,[MOVNM N,(A)] ;NEGATIVE ARRAY STORE
	JRST	.+3
AST2ER:	SKIPA	D,[MOVEM N,(A)]	;POSITIVE ARRAY STORE
AFT2ER:	MOVSI	D,A(MOVE N,)	;ARRAY FETCH
	MOVE	B,40		;ARRAY ADDRESS
	HLRZ	C,1(B)		;LEFT DIMENSION
	PUSHJ	P,SUBSCR	;GET AND FIX SUBSCRIPT IN E
	HRRZ	A,1(B)
	IMUL	A,E		;LEFT SCRIPT TIMES RIGHT DIM!
	HRRZ	C,1(B)		;RIGHT DIMENSION
AFT2C:	PUSHJ	P,SUBSCR	;GET AND FIX SUBSCRIPT IN E
	ADD	A,E		;ADD TO LEFT DIM
	ADD	A,(B)		;ADD ARRAY ADDRS
	XCT	D               ;DO THE OPERATION
	POPJ	P,		;RETURN

IFN	FTSTR, <
SADEND:	HRRZI	N,(A)		;PUT STRING VECTOR POINTER ADDRESS IN N
	TLO	N,(1B0)		;MAKE IT LOOK LIKE AN ADDRESS, NOT A POINTER
	POPJ	P,
>

;ROUTINE TO FETCH AND CHECK SUBSCRIPT

;CALL:	MOVE	C,DIMENSION
;	PUSHJ	P,SUBSCR

SUBSCR:	MOVE	E,@-1(P)		;GET SUBSCRIPT
	AOS	-1(P)		;SKIP ARGUMENT
	MOVE	E,(E)
	FAD	E,FIXCON	;FIX SUBSCRIPT
	TLZ	E,777400
	CAMGE	E,C		;CHECK DIMENSION
	POPJ	P,
				;ON ERROR, FALL INTO DIMERR


;DIMENSION ERR ROUTINE

DIMERR:	PUSHJ	P,INLMS0
	ASCIZ	/DIMENSION ERROR IN /
	JRST	GOSR2

	SUBTTL	MATRIX OPERATION RUN-TIME ROUTINES

IFN FTMAT, <
;SET MATRIX DIMENSION -- SDIM UUO


SDIMER:	MOVSI	C,1		;DONT FAIL IN SUBSCR
	PUSHJ	P,SUBSCR	;FIRST DIM
	HRLZ	A,E		;SAVE IT
	PUSHJ	P,SUBSCR	;SECOND DIM
	HRR	A,E
	AOBJP	A,MS0CHK		;GO CHECK DIMS AND STORE THEM
>

IFN FTMAT, <
;MATRIX OPERATION SETUP ROUTINE
;USE ENTRY POINT MS2 IF 2 ARGS, MS1 IF 1 ARG, MS0 OR MS0CHK IF 0 ARGS.
;ALL ENTRIES EXPECT MS0 EXCEPT DIMENSION [XWD ROWS,COLS]
;  OF DESTINATION TO BE SET UP IN A AND CHECK FOR ROOM
;  AND SET DIMENSION OF DESTINATION.
;AT CALL, LOCATION 40 CONTAINS THE ADDRS OF DESTINATION DOPE VECTOR,
;  RIGHT SIDE OF T1 CONTAINS ADDRS OF DOPE VECTOR FOR ARG 1
;  RIGHT SIDE OF T CONTAINS ADDRS OF DOPE VECTOR FOR ARG 2
;RIGHT SIDES OF T1,T,B ARE REPLACED WITH ADDRESSES OF ELEMENTS 0,0
;  OF ARG 1, ARG 2, DEST, RESPECTIVELY, WITHOUT CHANGING LEFT SIDES,
;  AND THE RESULTS ARE STORED IN TEMP1, TEMP2, AND TEMP3, RESPECTIVELY.
;THE MAXIMUM ROW NUMBER OF DEST IS STORED IN SB1M1, THE MAXIMUM
;  COLUMN NUMBER OF DEST IS STORED IN SB2M1
;E, T1, AND G ARE SET TO FIRST ROW NUMBER, FIRST COL NUMBER,
;  AND RELATIVE LOCATION OF FIRST ELEMENT, RESPECTIVELY
;IT IS INTENDED THAT E, T1, G, TEMP1, TEMP2, TEMP3 BE SET UP FOR
;  IMMEDIATE CALL TO MLP, AND THAT ELEMENTS OF FIRST
;  ARGUMENT, SECOND ARGUMENT, AND DESTINATION BE ACCESSED
;  BY INDIRECT ADDRESSING THROUGH TEMP1, TEMP2, AND TEMP3, RESPECTIVELY.

MS2:	HRR	T,(T)		;ADDRS OF FIRST ARG
MS1:	HRR	T1,(T1)		;ADDRS OF SECOND OR ONLY ARG
MS0CHK:	HRR	B,40		;DOPE VECTOR OF DEST
	HLLZ	X1,A		;CHECK NEW DIMENSION
	IMULI	X1,(A)		;X1 := (TOTAL SIZE)0
	CAMLE	X1,0(B)		;IS THERE ROOM IN ARRAY?
	JRST	DIMERR		;NO.  DIMENSION ERROR
	MOVEM	A,1(B)		;STORE NEW DIMENSION
MS0:	HRR	B,40		;ENTER HERE FOR NO DIM CHECK
	MOVE	A,1(B)		;FETCH DIMENSIONS
	SUB	A,[XWD 1,1]	;E := (MAX ROW)MAX COL
	HLRZM	A,SB1M1		;FIRST DIMENSION -1
	HRRZM	A,SB2M1		;SECOND DIMENSION -1

	HRR	B,(B)		;ADDRS OF DEST (LEAVE IN B FOR MINV)
	MOVEM	T1,TEMP1	;STORE FIRST XCT INSTRUCTION
	MOVEM	T,TEMP2		;STORE SECOND XCT INSTRUCTION
	MOVEM	B,TEMP3		;STORE THIRD XCT INSTRUCTION

;NOW SETUP E, T1, AND G FOR "MLP"

	SKIPE	E,SB1M1		;MORE THAN 0'TH ROW?
	MOVEI	E,1		;YES.  USE FIRST
	SKIPE	T1,SB2M1		;MORE THAN 0'TH COL
	MOVEI	T1,1		;YES.  USE FIRST
	MOVE	G,SB2M1		;CALCULATE FIRST ELT OF RESLT
	ADDI	G,1
	IMULI	G,(E)
	ADDI	G,(T1)
	POPJ	P,
>

IFN FTMAT, <
;MATRIX OPERATION MAIN LOOP

;ON CALLING, T, T1, G ARE SET UP TO ROW NUMBER, COL NUMBER, AND
;  REL LOC OF CURRENT ELEMENT IN DESTINATION MATRIX.
;MLP EXECUTES THE CONTENT OF TEMP1, TEMP2, TEMP3 FOR EACH
;  ELEMENT OF CURRENT ROE.  AT END OF ROW, MLP RETURNS
;  WITHOUT SKIP TO ALLOW ONCE-PER-ROW OPERATIONS TO BE PERFORMED.
;  WHEN ALL ROWS HAVE BEEN PROCESSED, MLP RETURNS WITH SKIP.
;NOTE SPECIAL CODING SO THAT ROW AND COLUMN VECTORS ARE
;  HANDLED CORRECTLY.

	EXTERNAL MATR
MLP:	SKIPE MATR
	PUSHJ P,CHKA
	XCT	TEMP1
	XCT	TEMP2
	XCT	TEMP3

	ADDI	G,1
	CAMGE	T1,SB2M1
	AOJA	T1,MLP
	SKIPE	SB2M1		;MORE THAN A 0'TH COL?
	AOJA	G,.+2		;YES.  SKIP 0'TH COL
	TDZA	T1,T1		;NO.  SET TO USE 0'TH COL
	MOVEI	T1,1		;YES AGAIN.  SET TO USE COL 1.

	CAML	E,SB1M1		;ALL ROWS USED?
	AOS	(P)		;YES.  SET FOR SKIP RETURN
	SETZM MATR
	AOJA	E,CPOPJ		;BUMP ROW AND RETURN
>

CHKA:	SKIPN ODF
	POPJ P,
	CAME T1,SB2M1
	POPJ P,
	CAME E,SB1M1
	POPJ P,
	MOVEI X1,1
	DPB X1,[POINT 4,TEMP2,12]
	POPJ P,


IFN FTMAT, <
;MATRIX READ ROUTINE

;SET UP AND CALL MLP. FOR EACH ELEMENT, THE FOLLOWING
;ARE PERFORMED:
;	TEMP1:	PUSHJ	P,MTRELT
;	TEMP2:	...	;(SKIPPED)
;	TEMP3:	MOVEM	N,<DEST>(G)
;MTRELT READS A NUMBER INTO N

MTRDER:	MOVE	T1,[PUSHJ P,MTRELT]
	SKIPN	IFIFG		;INPUT FROM DISK?
	JRST	.+3		;NO
	PUSHJ	P, DOINPT	;YES.
	JRST	.+2
	PUSHJ	P,DOREAD
	HRRZ	X1,@40		;GET ADRESS OF ZEROTH ELEMENT
	CAML	X1,SVRBOT	;IS THIS A STRING VECTOR?
	JRST	MTRDS		;ELEMENTS WILL BE STRINGS.
	HRLI	B,G(MOVEM N,)
MTRD1:	PUSHJ	P,MS0		;SET UP FOR LOOP
	SETZM	40		;NOP THE STORE THAT DATAER USES
MTRD2:	PUSHJ	P,MLP		;EXECUTE LOOP
	JRST	.-1		;NO ACTION ON ROW
	POPJ	P,

;ROUTINE CALLED BY MTRDER TO PRINT AN ELEMENT

MTRELT:	PUSH	P, T1
	PUSHJ	P,DATAER
	POP	P, T1
	JRST	CPOPJ1		;SKIP SECOND XCT

MTRDS:	MOVSI	T1,(SKIPA)
	MOVSI	B,G(STRIN)
	JRST	MTRD1


;MATRIX PRINT ROUTINE

;SET UP AND CALL MLP:
;	TEMP1:	PUSH	P,T
;	TEMP2:	PRNM	<FORMAT CODE>,<DEST>(G)
;	TEMP3:	POP	P,T
MTPRER:	SKIPN	FMTFLG		;FORMATTED PRINT?
	JRST	.+6
	MOVE	T1, (P)		;YES.
	HLRZ	X1, -2(T1)
	CAIE	X1, (DATA 13,)	;FORMAT INSTR?
	SOJA	T1, .-2		;NOT YET.  KEEP LOOKING
	SKIPA	T1, -2(T1)	;YES
	MOVSI	T1, (JFCL)	;NO.  SET UP NO-OP
	MOVEM	T1, STOR0
	MOVE	T1,[PUSH P,T1]	;TO SAVE T1 AROUND PRNM
	PUSHJ	P,MS0		;SET UP FOR LOOP
	HLL	B,40		;PICK UP UUO AC FIELD
	TLZ	B,777000	;CONSTRUCT PRNM INSTR
	SKIPE	SB1M1		;VECTOR?
	SKIPN	SB2M1
	JFCL	;?	JRST	.+3		;YES. ALLOW <CR> FORMAT
	TLNN	B,(Z 16,)		;OH, NO.  TREAT <RET> FORMAT ==<COMA> FORMAT.
	HRLI	B,(Z 3,)		;IT WAS <RET>FORM. CHANGE TO <COMA>FORM.
	HRRZ	X1,@40
	CAMGE	X1,SVRBOT	;NUMBER ARRAY?
	TLO	B,G(PRNM)	;YES, SETUP NUMBER UUO
	CAML	X1,SVRBOT	;STRING ARRAY?
	TLO	B,G(PRSTR)	;YSE SEUP STRING PRINT UUO.$
	MOVEM	B,TEMP2		;SET UP TEMP2 AND TEMP3
	MOVE	X1,[POP P,T1]
	MOVEM	X1,TEMP3

MTP2D:	PUSHJ	P,.+5		;TWO BLANK LINES
MTP1D:	XCT	STOR0
	SETOM MATR
	PUSHJ	P,MLP		;PRINT A ROW
	JRST	MTPRE1		;NOW SEE WHETHER TO SPACE BETW ROWS
	PUSHJ	P,PCRLF
	PUSHJ	P,PCRLF
	POPJ	P,

MTPRE1:	SKIPE	SB1M1		;VECTOR OR ARRAY?
	SKIPN	SB2M1
	JRST	MTP1D		;ARRAY... SPACE BETW ROWS
	JRST	MTP2D		;VECTOR...DONT SPACE BETW ROWS
>

IFN FTMAT, <
;MATRIX ADD AND SUBTRACT ROUTINES

;SET UP AND CALL MLP:
;	TEMP1:	MOVE	N,<ARG 2>(G)	;OR MOVN
;	TEMP2:	FADR	N,<ARG 1>(G)
;	TEMP3:	MOVEM	N,<DEST>(G)
MTADER:	TLOA	T1,G(MOVE N,)		;MAKE ADD INSTR (T LOADED WITH MOVEI)
MTSBER:	HRLI	T1,G(MOVN N,)		;MAKE SUBTRACT INSTR
	HRLI	T,G(FADR N,)		;FETCH
	HRLI	B,G(MOVEM N,)
	MOVE	A,1(T)		;GET AND CHECK DIMENSIONS OF ARGS
	CAME	A,1(T1)
	JRST	DIMERR
	PUSHJ	P,MS2		;SET UP MATRIX LOOP
	JRST	MTRD2		;FINISH -- NO EACH ROW RTN


;MATRIX SCALE ROUTINE

;SET UP AND CALL MLP:
;	TEMP1:	MOVE	A,<ARG 1>(G)
;	TEMP2:	FMPR	A,N
;	TEMP3:	MOVEM	A,<DEST>(G)
MTSCER:	HRLI	T1,G(MOVE A,)
	MOVSI	T,(FMPR A,N)
MTSC1:	HRLI	B,G(MOVEM A,)
	MOVE	A,1(T1)
	PUSHJ	P,MS1
	JRST	MTRD2
>

IFN FTMAT, <
;MATRIX ZERO, IDENTITY, AND ONE ROUTINES

;SET UP AND CALL MLP:
;		..IDEN..	..ZERO..	..ONE..
;	TEMP1:	SETZM@TEMP3	SETZM @TEMP3	CAIA
;	TEMP2:	CAMN T,T1	CAIA		...
;	TEMP3:	MOVEM A,<DEST>(G)......................

MTIDER:	SKIPA	T,[CAMN E,T1]
MTZRER:	MOVSI	T,(CAIA)
	SKIPA	T1,[SETZM @TEMP3]
MTCNER:	MOVSI	T1,(CAIA)
MTCN1:	HRLI	B,G(MOVEM D,)
	MOVSI	D,(DEC 1.0)	;CONSTANT 1.0 TO STORE
	JRST	MTRD1		;GO FINISH WITH READ CODE


;MATRIX TRANSPOSE ROUTINE

;SET UP AND CALL MLP:
;A CONTAINS RELATIVE LOC OF CURRENT ELE IN SOURCE
;	TEMP1 :	FETCH SOURCE ELEMENT
;	TEMP2 :	UPDATE SOURCE INDEX
;	TEMP3 :	STORE DESTINATION ELEMENT


MTTNER:	MOVS	A,1(T1)		;FETCH DESTINATION DIMENSION
	HRLI	T1,A(MOVE N,)
	HLRZ	T,A		;E := ADDI A,<NBR ROWS>
	HRLI	T,(ADDI A,)
	HRLI	B,G(MOVEM N,)
	PUSHJ	P,MS1		;SET UP AND CHK DIMENSION

MTTN1:	MOVE	A,SB1M1		;A := <NBR ROWS>*COL + ROW
	ADDI	A,1
	IMUL	A,T1
	ADD	A,E

	PUSHJ	P,MLP		;MOVE A ROW
	JRST	MTTN1
	POPJ	P,
>



IFN FTMAT, <
;MATRIX MULTIPLY ROUTINE

;SET UP AND CALL MLP
;FOR EACH ELEMENT OF DESTINATION MATRIX, CALL SUBROUTINE
;	MYELT TO FORM THE DOT PRODUCT OF THE APPROPRIATE ROW AND COLUMN


MTMYER:	MOVE	A,1(T)		;CHECK DIMENSIONS
	HLRZ	D,1(T1)		;D := INNER DIMENSION
	CAIE	D,(A)		;SAME AS FIRST ARG?
	JRST	DIMERR		;NO
	HRR	A,1(T1)

	HRLI	T1,T1(MOVEI X2,)	;TO COMPUTE ADDRS OF 1ST ELT 2ND ARG
	HRLI	T,(MOVEI X1,)	;DITTO 1ST ARG
	HRLI	B,G(MOVEM N,)	;STORE INSTR
	PUSHJ	P,MS2		;SETUP NEW DIMENSIONS AND MLP ARGS
	MOVEI	X1,1(A)		;PREPARE TO SKIP ROW ZERO IF..
	CAIE	D,1		;INNER DIM=1?
	ADDM	X1,TEMP1
	MOVE	B,[PUSHJ P,MYELT]	;CALL TO ELT COMPUTATION
	EXCH	B,TEMP2

	CAIE	D,1		;INNER DIM 1?  (IE PROD OF VECTORS)
	ADDI	B,1		;NO.  SKIP 0'TH COL OF 1'ST ARG
	JUMPE	E,MTMY2		;DONT SKIP FIRST ROW IF ONLY 1

MTMY1:	ADDM	D,B		;NEXT ROW OF FIRST ARG
MTMY2:	PUSHJ	P,MLP
	JRST	MTMY1
	POPJ	P,

;SUBROUTINE TO COMPUTE ELEMENT OF PRODUCT
;X1 CONTAINS ADDRS OF 1ST ELT OF 1ST ARG FOR DOT PRODUCT,
;  AFTER FIRST XCT BELOW, X2 CONTAINS ADDRS OF SAME FOR 2ND ARG

MYELT:	XCT	B
	MOVEI	N,0		;TO ACCUMULATE DOT PRODUCT
	MOVEI	C,-1(D)	;NUMBER OF ADDS= REAL INNER DIMENSION

MYEL1:	MOVE	X3,(X1)		;PRODUCT OF 2 ELTS
	FMPR	X3,(X2)
	FADR	N,X3		;ADD INTO DOT PRODUCT
	ADDI	X2,1(A)		;NEXT ROW OF 2ND ARG
	SOJLE	C,CPOPJ		;DONE?
	AOJA	X1,MYEL1	;NO.  TO NEXT ELT
>

	SUBTTL	RUN-TIME MATRIX INVERTER

IFN FTMAT, <
;SUBROUTINE TO CALL MATRIX INVERTER

MTIVER:	MOVS	A,1(T1)		;MAKE SURE SQUARE MATRIX
	CAME	A,1(T1)
	JRST	DIMERR

	HRLI	T1,G(SKIPA A,)	;MOVE DESTINATION
	PUSHJ	P,MTSC1		;(USE MTCNER CODE)
	SKIPE	SB1M1	;GO INVERT UNLESS ONLY ELT IS (0,0)
	JRST	MINVB

	SUBI	B,3
	MOVEM	B,TEMP3		;ONLY ELEMENT IS (0,0)
	AOS	SB1M1		;FOOL MINV INTO THINKING ITS (1,1)
	JRST	MINVB

;THIS PORTION OF THE MAT INVERSE PROG RUNS IN ACS 0-7

JLOOP:
	PHASE	0

ZERO:	CAMN	JX,NT		;SKIP SAME COL
	JRST	JXIT
	MOVE	TAC,@TEMP1	;A(I,J)=A(I,J)+A(NT,J)*A(I,NT)
	FMPR	TAC,(KX)	;***
MOD2:   FADRM  TAC,0(JX)        ;ADDR MODIFIED BY OUTER LOOP
JXIT:	CAMGE	JX,SB1M1	;LOOP DONE?
	AOJA	JX,ZERO
	JRST	IXIT		;YES RETURN

	DEPHASE

;SOME AC DEFS FOR MINV

NT=10		;OUTERMOST LOOP INDEX
IX=11		;I SUBSCRIPT
JX=12		;J SUBSCRIPT
KX=13		;SCRATCH INDEX REG
LX=14		;    "     "    "
TAC=15		;WORK AC
TAC1=16		;   "   (MUST BE SAVE & RESTORED)
>

IFN FTMAT, <
;MAIN ROUTINE ENTERS HERE TO SET UP REGS
;ROUTINE EXPECTS	1) ARRAY ADDR IN TEMP3
;			2) ORDER OF ARRAY IN SB1M1
;ROUTINE USES	1) VECT1 & VECT2 AS SCRATCH
;		2) SB2M1 AS CNT OF ELEMENTS / ROW

MINVB:	HRRZS	TEMP3		;MAKE SURE ADDR ONLY
	MOVE	TAC,SB1M1	;GET ORDER
	ADDI	TAC,1		;ADD ONE FOR 0'TH ROW & COL
	MOVEM	TAC,SB2M1	;SAVE IN SB2
	PUSH	P,TAC1		;SAVE AC16?
	MOVSI	TAC,(1.0)	;INIT DETERM.
	MOVEM	TAC,DETER
	HRLZI	TAC,JX		;SET INDEX REG IN
	HLLZM	TAC,TEMP1	;TEMP1 FOR INDIRECT
	MOVE	TAC,[XWD JLOOP,ZERO]
	BLT	TAC,7		;PUT JLOOP INTO ACS

	MOVEI	NT,1		;INITIALIZE OUTER LOOP
MINVLP:	MOVE	TAC,NT
	IMUL	TAC,SB2M1	;CALC (NT,NT) SUBSCR
	ADD	TAC,NT
	ADD	TAC,TEMP3	;***
	MOVEM	TAC,TEMP2	;SAVE IT FOR LATER
	CAMN	NT,SB1M1	;LAST ITER?
	JRST	FOUND1		;SAVE SEARCH STUFF
	MOVM	TAC,(TAC)	;GET A(NT,NT)
	MOVE	IX,NT		;INITIALIZE SEARCH

LUPI:	MOVE	KX,SB2M1	;CALC I INDEX
	IMUL	KX,IX
	ADD	KX,TEMP3	;***
	MOVE	JX,NT		;INIT J INDEX
LUPJ:	MOVE	LX,KX
	ADD	LX,JX		;FINISH INDEX FOR ELEMENT
	MOVM	LX,(LX)		;GET IT
	CAMGE	LX,TAC		;IS IT LARGER THAN PRESENT
	JRST	LUPEND		;NO
	MOVE	TAC,LX		;YES SAVE IT
	MOVEM	IX,VECT1(NT)	;AND INDEXES
	MOVEM	JX,VECT2(NT)
LUPEND:	CAMGE	JX,SB1M1	;END OF J LOOP LOGIC
	AOJA	JX,LUPJ
	CAMGE	IX,SB1M1
	AOJA	IX,LUPI
>

IFN FTMAT, <
FOUND:	CAMN	NT,VECT1(NT)
	MOVNS	DETER
	CAMN	NT,VECT2(NT)
	MOVNS	DETER
        PUSHJ P,FSWAP
FOUND1:	MOVE	TAC,@TEMP2	;GET PIVOT ELEMENT
	JUMPE	TAC,SING	;TEST FOR SINGULARITY
	MOVEM	TAC,PIVOT	;SAVE IT
	FMPRM	TAC,DETER	;PERPETUATE DETERM
	MOVSI	TAC,(1.0)	;1./A(NT,NT)
	FDVRM	TAC,PIVOT	;***

	MOVEI	IX,1		;SET UP I
ILOOP:	CAMN	IX,NT		;SKIP SAME ROW
	JRST	IXIT		;AS PIVOT ROW
	MOVE	LX,SB2M1	;CALCULATE ALL ROW OFFSETS
	IMUL	LX,IX
	ADD	LX,TEMP3	;LX= IX*N+A
	MOVE	KX,LX
	ADD	KX,NT		;KX=LX+NT
	MOVN	TAC,PIVOT	;GET -PIVOT
	FMPRM	TAC,(KX)	;A(I,NT)=A(I,NT)/(-A(NT,NT))
	MOVEI	JX,1		;SET J LOOP START
	MOVE	TAC,SB2M1
	IMUL	TAC,NT
	ADD	TAC,TEMP3	;TAC=NT*N+A
	HRRM	TAC,TEMP1	;STORE FOR @TEMP1(JX)
        HRR     MOD2,LX         ;SET ADDR IN INNER LOOP
	JRST	ZERO		;GO

IXIT:	CAMGE	IX,SB1M1	;RETURN HERE FROM ACS
	AOJA	IX,ILOOP
	MOVEI	JX,1		;SET LOOP FOR LAST COL
	MOVE	TAC,PIVOT	;GET PIVOT
LCOL:	FMPRM	TAC,@TEMP1	;A(NT,J)=A(NT,J)/A(NT,NT)
	CAMGE	JX,SB1M1	;DONE
	AOJA	JX,LCOL
	MOVEM	TAC,@TEMP2	;A(NT,NT)=PIVOT
	CAMGE	NT,SB1M1	;INVERSE DONE?
	AOJA	NT,MINVLP	;NOPE, ITER AGAIN
>

IFN FTMAT, <
;HERE WHEN INVERSE DONE PUT MATRIX BACK TOGETHER

	MOVE	NT,SB1M1	;DO LOOP IN REVERSE ORDER
INVFIX:	SOJLE	NT,OUT		;FINISHED
	PUSHJ	P,BSWAP		;SWAP ROW - COL IN REV.
	JRST	INVFIX

BSWAP:	MOVE	KX,VECT2(NT)
	MOVE	LX,VECT1(NT)	;SET REGS
	JRST	SWAP
FSWAP:	MOVE	KX,VECT1(NT)
	MOVE	LX,VECT2(NT)
SWAP:	MOVE	TAC1,NT
	IMUL	TAC1,SB2M1
	IMUL	KX,SB2M1	;CALC BOTH ROW OFFSETS
	ADD	TAC1,TEMP3
	ADD	KX,TEMP3	;***
	MOVEI	JX,1
	HRLI	TAC1,JX
	HRLI	KX,JX
SWP1:	MOVE	TAC,@TAC1
	EXCH	TAC,@KX		;EXCHANGE ITEMS IN ROWS
	MOVEM	TAC,@TAC1
	CAMGE	JX,SB1M1
	AOJA	JX,SWP1
	MOVEI	IX,1
	MOVE	TAC1,NT
	MOVE	KX,SB2M1
	ADD	KX,TEMP3	;GET COL ADDR
	HRLI	TAC1,KX
	HRLI	LX,KX
SWP2:	MOVE	TAC,@LX
	EXCH	TAC,@TAC1
	MOVEM	TAC,@LX
	CAML	IX,SB1M1	;CHECK DONE
	POPJ	P,		;RETURN
	ADD	KX,SB2M1	;TO NEXT COL
	AOJA	IX,SWP2

;HERE TO RETURN OR MAKE SINGULAR

SING:	SETZB	ZERO,DETER
OUT:	POP	P,TAC1
DETB:	MOVE	ZERO,DETER
	POPJ	P,0


>

	SUBTTL	INTRINSIC FUNCTIONS (ADAPTED FROM LIB4 V.005)
;SINGLE PRECISION ABSOLUTE VALUE FUNCTION
;ABS AND IABS RETURN THE ABSOLUTE VALUE OF N SINGLE PRECISION
;ARGUMENT.

;THE ANSWER IS RETURNED IN ACCUMULATOR N

ABSB:	MOVMS	N		;GET MAGNITUDE OF ARGUMENT
	POPJ	P,		;EXIT

;FLOATING POINT SINGLE PRECISION ARCTANGENT FUNCTION
;ATAN(X) = X(B0+A1(Z+B1-A2(Z+B2-A3(Z+B3)**-1)**-1)**-1)
;WHERE Z=X^2, IF 0<X<=1

;IF X>1, THEN ATAN(X) = PI/2 - ATAN(1/X)
;IF X>1, THEN RH(A) =-1, AND LH(A) = -SGN(X)
;IF X<1, THEN RH(A) = 0, AND LH(A) =  SGN(X)

ATANB:				;ENTRY TO ARCTANGENT ROUTINE
	MOVM	T, N		;GET ABSF OF ARGUMENT
	CAMG	T, A1		;IF A<2^-33, THEN RETURN WITH...
	POPJ	P,		;ATAN(X)=X
	HLLO	B, N		;SAVE SIGN, SET RH(A) = -1
	CAML	T, A2		;IF A>2^33, THEN RETURN WITH
	JRST	AT4		;ATAN(X) = PI/2
	MOVSI	T1, (1.0)	;FORM 1.0 IN T1
	CAMG	T, T1		;IS ABSF(X)>1.0?
	TRZA	B, -1		;IF T .LE. 1.0, THEN RH(A) = 0
	FDVM	T1, T		;B IS REPLACED BY 1.0/B
	TLC	B, (B)		;XOR SIGN WITH .G. 1.0 INDICATOR
	MOVEM	T, C3		;SAVE THE ARGUMENT
	FMP	T, T		;GET B^2
	MOVE	T1, KB3		;PICK UP N CONSTANT
	FAD	T1, T		;ADD B^2
	MOVE	N, KA3		;ADD IN NEXT CONSTANT
	FDVM	N, T1		;FORM -A3/(B^2 + B3)
	FAD	T1, T		;ADD B^2 TO PARTIAL SUM
	FAD	T1, KB2		;ADD B2 TO PARTIAL SUM
	MOVE	N, KA2		;PICK UP -A2
	FDVM	N, T1		;DIVIDE PARTIAL SUM BY -A2
	FAD	T1, T		;ADD B^2 TO PARTIAL SUM
	FAD	T1, KB1		;ADD  B1 TO PARTIAL SUM
	MOVE	N, KA1		;PICK UP A1
	FDV	N, T1		;DIVIDE PARTIAL SUM BY A1
	FAD	N, KB0		;ADD B0
	FMP	N, C3		;MULTIPLY BY ORIGINAL ARGUMENT
	TRNE	B, -1		;CHECK .G. 1.0 INDICATOR
	FSB	N, PIOT		;ATAN(N) = -(ATAN(1/A)-PI/2)
	CAIA			;SKIP
AT4:	MOVE	N, PIOT		;GET PI/2 AS ANSWER
NEGANS:	SKIPGE	B		;LH(A)= -SGN(T) IF B>1.0
	MOVNS	N		;NEGATE ANSWER
	POPJ	P,		;EXIT

A1:	145000000000		;2**-33
A2:	233000000000		;2**33
KB0:	176545543401		;0.1746554388
KB1:	203660615617		;6.762139240
KB2:	202650373270		;3.316335425
KB3:	201562663021		;1.448631538
KA1:	202732621643		;3.709256262
KA2:	574071125540		;-7.106760045
KA3:	600360700773		;-0.2647686202
PIOT:	201622077325		;PI/2

;FLOATING POINT TRUNCATION FUNCTION
;TRUNCATES FRACTIONAL PART OF FLOATING POINT NUMBER
;AND RETURNS ANSWER AS N FLOATING POINT NUMBER. THE
;ALGORITHM MAKES USE OF THE NORMALIZING PROPERTIES OF FAD.
;ROUTINE EXITS WITH (T)=ZERO IF NUMBER WAS AN INTEGER.

AINTB:	MOVE	B,N		;SAVE ARGUMENT
	MOVMS	N		;GET ABSF(ARG)
	SKIPGE	B		;NEGATIVE?
	FAD	N,ALMST1	;YES. MAKE AINT[-2.3]=-3  ETC.
	CAML	N,MOD1		;IS ARGUMENT<=2**26?
	JRST	NEGANS		;YES; IT MUST BE AN INTEGER ALREADY
	FAD	N,MOD1
	FSB	N,MOD1		;NOW FRACTIONAL PART HAS BEEN LOST
	JRST	NEGANS		;CHECK SIGN AND EXIT.

MOD1:	XWD 233400,000000	; 2**26

ALMST1:	XWD 200777,777777	;1.0-<SMALLEST QUANTITY>

;FLOATING POINT SINGLE PRECISION LOGARITHM FUNCTION
;LOG(ABSF(X)) IS CALCULATED BY THE SUBROUTINE, AND AN
;ARGUMENT OF ZERO IS RETURNED AS MINUS INFINITY. THE ALGORITHM IS

;LOGE(X) = (I + LOG2(F))*LOGE(2)
;WHERE X = (F/2)*2^(I+1), AND LOG2(F) IS GIVEN BY
;LOG2(F) = C1*Z + C3*Z^3 + C5*Z^5 - 1/2
;AND Z = (F-SQRT(2))/(F+SQRT(2))

ALOGB:	JUMPL	N,ALOGB1	;TEST FOR LOG OF NEG NUMBER.
	MOVMS	N		;GET ABSF(X)
	JUMPE	N, LZERO	;CHECK FOR ZERO ARGUMENT
	CAMN	N, ONE		;CHECK FOR 1.0 ARGUMENT
	JRST	ZERANS		;IT IS 1.0 RETURN ZERO ANS.
	ASHC	N, -33		;SEPARATE FRACTION FROM EXPONENT
	ADDI	N, 211000	;FLOAT THE EXPONENT AND MULT. BY 2
	MOVSM	N, C3		;NUMBER NOW IN CORRECT FL. FORMAT
	MOVSI	N, 567377	;SET UP -401.0 IN N
	FADM	N, C3		;SUBTRACT 401 FROM EXP.*2
	ASH	T, -10		;SHIFT FRACTION FOR FLOATING
	TLC	T, 200000	;FLOAT THE FRACTION PART
	FAD	T, L1		;B = T-SQRT(2.0)/2.0
	MOVE	N, T		;PUT RESULTS IN N
	FAD	N, L2		;A = N+SQRT(2.0)
	FDV	T, N		;B = B/A
	MOVEM	T, LZ		;STORE NEW VARIABLE IN LZ
	FMP	T, T		;CALCULATE Z^2
	MOVE	N, L3		;PICK UP FIRST CONSTANT
	FMP	N, T		;MULTIPLY BY Z^2
	FAD	N, L4		;ADD IN NEXT CONSTANT
	FMP	N, T		;MULTIPLY BY Z^2
	FAD	N, L5		;ADD IN NEXT CONSTANT
	FMP	N, LZ		;MULTIPLY BY Z
	FAD	N, C3		;ADD IN EXPONENT TO FORM LOG2(X)
	FMP	N, L7		;MULTIPLY TO FORM LOGE(X)
	POPJ	P,		;EXIT

LZERO:	PUSHJ	P,INLMS0	
	ASCIZ /LOG OF ZERO IN /
	PUSHJ	P,GOSR3		;PRINT LINE NUMBER.
	MOVE	N, MIFI		;PICK UP MINUS INFINITY
	POPJ	P,		;EXIT

;COMMON EXITS:
ZERANS:	SETZI	N,		;MAKE ARG ZERO
	POPJ	P,		;EXIT

;CONSTANTS FOR ALOGB

ONE:	201400000000
L1:	577225754146		;-0.707106781187
L2:	201552023632		;1.414213562374
L3:	200462532521		;0.5989786496
L4:	200754213604		;0.9614706323
L5:	202561251002		;2.8853912903
ALOGB1:	PUSH	P,N		;SAVE ARGUMENT
	PUSHJ	P,INLMS0
	ASCIZ /LOG OF NEGATIVE NUMBER IN /
	PUSHJ	P,GOSR3		;PRINT LINE NUMBER
	POP	P,N		;GET ARG
	JRST	ALOGB+1		;USE ABS VALUE.

L7:	200542710300		;0.69314718056
MIFI:	XWD 400000,1		;LARGEST NEGATIVE NUMBER


;ROUTINE TO CALCULATE LENGTH OF STRING.  ("LEN(A$)" FUNCTION.)

STRLNB:	JUMPL	N, STRLN0
	TLNN	N, -1
	JRST	STRLN0	;PATCH FOR NULL STRINGS
	MOVE	T, N
	SETZ	N,
	PUSHJ	P, NXCHS
STRLN2:	TLNE	C, F.QUOT
	JRST	STRLN1
	CAMN	C, [XWD F.STR,"\"]
	JRST	STRLN3
	AOJA	N, .-5
STRLN0:	HLRE	N,N
	MOVM	N,N
STRLN1:	FSC	N, 233
	POPJ	P,


STRLN3:	ILDB	C, T
	CAIG	C, 15
	JRST	.-2
	JRST	STRLN2


;	THREETIME FUNCTIONS  	TIM(X)---RETURNS RUNNING OF PROGRAM IN N
;				CLK(X)--- RETURNS  TIME OF DAY AS DECIMAL HOURS SINCE MIDNIGHT
;				DAT(X)--- DATE AS YY MM DD
;	TOM SALEH 10-DEC-70


CLKB:	CALLI	N,23		;GET TIME  IN MILLISECONDS
TIM1:	JFFO	N,.+2		;FIND THE LEADING ONE
	POPJ	P,		;NONE
	FSC	N,233
	FDV	N,[3.6E6]
	POPJ	P,
DATB:	CALLI	N,14		;DATE
	IDIVI	N,37		;DAY-1 TO N+1
	MOVEI	T1,T(T)		;DAY TO T1
	IDIVI	N,14		;MONTH-1 TO T
	ADDI	N,100		;20-TH CENTURYNOGOOD AFTER 1999 
	IMULI	N,^D100		;SHIFT LEFT
	ADDI	N,1(T)		;ADD MONTH
	IMULI	N,^D100		;SHIFT AGAIN
	ADD	N,T1		;ADD ON DAY
	FSC N,233
	POPJ P,
TIMB:	SETZ	N,
	CALLI	N,27		;RUN TIME
	SUB	N,MTIME		;SUBTRACT STARTING TIME
	FSC N,233
	FMP N,[.001]
	POPJ P,


;	THATS ALL TOM S.




IFN FTMAT, <
;NUMB RETURNS THE NUMBER OF ELEMENTS IN THE LAST VECTOR THAT WAS INPUT
;BY "MAT INPUT"


NUMB:	MOVE	N,NUMRES
	POPJ	P,

>


;THE SIGNUM FUNCTION

SGNB:	JUMPE	N,ZERANS	;TEST FOR ZERO.
	MOVE	B,N		;SAVE SIGN
	MOVSI	N,(1.0)		;ANSWER IS 1.0 * ...
	JRST	NEGANS		;SIGN.


;FLOATING POINT SINGLE PRECISION SINE AND COSINE FUNCTION
;THE ARGUMENT IS IN RADIANS.
;ENTRY POINTS ARE SIN AND COS.
;COS CALLS SIN TO CALCULATE SIN(PI/2 + X)

;THE ROUTINE CALCULATES SINES AFTER REDUCING THE ARGUMENT TO
;THE FIRST QUADRANT AND CHECKING THE OVERFLOW BITS TO DETERMINE
;THE QUADRANT OF THE ORIGINAL ARGUMENT
;000 - 1ST QUADRANT
;001 - 2ND QUADRANT, X=-(X-PI)
;010 - 3RD QUADRANT, X=-(X-PI)
;011 - 4TH QUADRANT, X=X-3*PI/2-PI/2
;THE ALGORITHM USES N MODIFIED TAYLOR SERIES TO CALCULATE
;THE SINE OF THE NORMALIZED ARGUMENT.


COSB:				;ENTRY TO COSINE RADIANS ROUTINE
COSB:				;ENTRY TO COSINE RADIANS ROUTINE
	FADR	N,PIOT		;ADD PI/2
				;FALL INTO SINE ROUTINE

SINB:				;ENTRY TO SINE RADIANS ROUTINE
	MOVE	T, N		;PICK UP THE ARGUMENT IN T
	MOVEM	T, SX		;SAVE IT
	MOVMS	T		;GET ABSF OF ARGUMENT
	CAMG	T, SP2		;SINX = X IF X<2^-10
	POPJ	P,		;EXIT WITH ANS=ARG
	FDV	T, PIOT		;DIVIDE X BY PI/2
	CAMG	T, ONE		;IS X/(PI/2) < 1.0?
	JRST	S2		;YES, ARG IN 1ST QUADRANT ALREADY
	MULI	T, 400		;NO, SEPARATE FRACTION AND EXP.
	ASH	T1, -202(T)	;GET X MODULO 2PI
	MOVEI	T, 200		;PREPARE FLOATING FRACTION
	ROT	T1, 3		;SAVE 3 BITS TO DETERMINE QUADRANT
	LSHC	T, 33		;ARGUMENT NOW IN RANGE (-1,1)
	FAD	T, SP3		;NORMALIZE THE ARGUMENT
	JUMPE	T1, S2		;REDUCED TO FIRST QUAD IF BITS 00
	TLCE	T1, 1000		;SUBTRACT 1.0  FROM ARG IF BITS ARE
	FSB	T, ONE		;01 OR 11
	TLCE	T1, 3000		;CHECK FOR FIRST QUADRANT, 01
	TLNN	T1, 3000		;CHECK FOR THIRD QUADRANT, 10
	MOVNS	T		;01,10


S2:	SKIPGE	SX		;CHECK SIGN OF ORIGINAL ARG
	MOVNS	T		;SIN(-X) = -SIN(X)
	MOVEM	T, SX		;STORE REDUCED ARGUMENT
	FMPR	T, T		;CALCULATE X^2
	MOVE	N, SC9		;GET FIRST CONSTANT
	FMP	N, T		;MULTIPLY BY X^2
	FAD	N, SC7		;ADD IN NEXT CONSTANT
	FMP	N, T		;MULTIPLY BY X^2
	FAD	N, SC5		;ADD IN NEXT CONSTANT
	FMP	N, T		;MULTIPLY BY X^2
	FAD	N, SC3		;ADD IN NEXT CONSTANT
	FMP	N, T		;MULTIPLY BY X^2
	FAD	N, PIOT		;ADD IN LAST CONSTANT
S2B:	FMPR	N, SX		;MULTIPLY BY X
	POPJ	P,		;EXIT



SC3:	577265210372		;-0.64596371106
SC5:	175506321276		;0.07968967928
SC7:	606315546346		;0.00467376557
SC9:	164475536722		;0.00015148419

SP2:	170000000000		;2**-10
SP3:	0			;0
CD1:	90.0
SCD1:	206712273406


;FLOATING POINT SINGLE PRECISION SQUARE ROOT FUNCTION
;THE SQUARE ROOT OF THE ABSOLUTE VALUE OF THE ARGUMENT IS
;CALCULATED. THE ARGUMENT IS WRITTEN IN THE FORM
;	X=	F*(2**2B)	WHERE 0<F<1
;SQRT(X) IS THEN CALCULATED AS (SQRT(X))*(2**B)
;SQRT(F) IS CALCULATED BY N LINEAR APPROXIMATION, THE NATURE
;OF WHICH DEPENDS ON WHETHER 1/4 < F < 1/2 OR 1/2 < F < 1,
;FOLLOWED BY TWO ITERATIONS OF NEWTON'S METHOD.

	EXTERN TABFG
SQRTB:				;ENTRY TO SQUARE ROOT ROUTINE
	MOVE	T, N		;PICK UP THE ARGUMENT IN T
	JUMPL	T,SQRMIN	;SQRT OF NEGATIVE NUMBER?
SQRT1:	JUMPE	T, ZERANS	;CHECK FOR ARGUMENT OF ZERO
	ASHC	T, -33		;PUT EXPONENT IN T, FRACTION IN T1
	SUBI	T, 201		;SUBTRACT 201 FROM EXPONENT
	ROT	T, -1		;CUT EXP IN HALF, SAVE ODD BIT
	HRRM	T,EX1		;SAVE FOR FUTURE SCALING OF ANS
				;IN FSC N,. INSTRUCTION
	LSH	T, -43		;GET BIT SAVED BY PREVIOUS INST.
	ASH	T1, -10		;PUT FRACTION IN PROPER POSITION
	FSC	T1, 177(T)	;PUT EXPONENT OF FRACT TO -1 OR 0
	MOVEM	T1, N		;SAVE IT. 1/4 < F < 1
	FMP	T1, SQCON1(T)	;LINEAR FIRST APPROX,DEPENDS ON
	FAD	T1, SQCON2(T)	;WHETHER 1/4<F<1/2 OR 1/2<F<1.
	MOVE	T, N		;START NEWTONS METHOD WITH FRAC
	FDV	T, T1		;CALCULATE X(0)/X(1)
	FAD	T1, T		;X(1) + X(0)/X(1)
	FSC	T1, -1		;1/2(X(1) + X(0)/X(1))
	FDV	N, T1		;X(0)/X(2)
	FADR	N, T1		;X(2) + X(0)/X(2)
	XCT	EX1
	POPJ	P,		;EXIT

SQCON1:	0.8125			;CONSTANT, USED IF 1/4<FRAC<1/2
	0.578125		;CONSTANT, USED IF 1/2<FRAC<1
SQCON2:	0.302734		;CONSTANT, USED IF 1/4<FRAC<1/2
	0.421875		;CONSTANT, USED IF 1/2<FRAC<1

SQRMIN:	PUSH	P,T	;SAVE ARG
	PUSHJ	P,INLMS0
	ASCIZ /SQRT OF NEGATIVE NUMBER IN /
	PUSHJ	P,GOSR3		;PRINT LINE NUMBER
	POP	P,T		;GET ARG
	MOVMS	T
	JRST	SQRTB+1		;USE ABSOLUTE VALUE

;TANGENT/COTANGENT -- USE SIN AND COS
;SHALL WE GET N REAL TAN ROUTINE?

;TANGENT (X) = SIN(X)/COS(X)
;COTAN (X)=TAN(PI/2-X)

COTB:	MOVNS	N		;CALCULATE -X...
	FADR	N,PIOT		; PLUS PI/2
TANB:	MOVEM	N,C3		;SAVE IT
	PUSHJ	P,COSB		;CALCULATE COSINE
	JUMPE	N,TANB1		;IS COS=ZERO?
	EXCH	N,C3		;SAVE COS, GET ARGUMENT
	PUSHJ	P,SINB		;CALCULATE SINE
	FDVR	N,C3		;CALCULATE SIN/COS
	POPJ	P,		;EXIT

TANB1:	PUSHJ	P,INLMS0
	ASCIZ ?TAN OF PI/2 OR COTAN OF ZERO IN ?
	JRST	LRGANS-1	;PRINT LINE NUMBER AND EXIT WITH LARGE ASNWER.

;FLOATING POINT SINGLE PRECISION EXPONENTIAL FUNCTION
;THE ARGUMENT IS RESTRICTED TO THE FOLLOWING RANGE
;	-88.028<X<88.028
;IF X<-88.028, THE PROGRAM RETURNS ZERO AS THE ANSWER
;IF X<88.028, THE PROGRAM RETURNS X AS THE ANSWER
;THE RANGE OF THE ARGUMENT IS REDUCED AS FOLLOWS:
;EXP(X) = 2**(X*LOG(B)BASE2) = 2**(M+F)
;WHERE M IS AN INTEGER AND F IS N FRACTION
;2**M IS CALCULATED BY ALGEBRAICALLY ADDING M TO THE EXPONENT
;OF THE RESULT OF 2**F. 2**F IS CALCULATED AS

;2**F = 2(0.5+F(A+B*F^2 - F-C(F^2 + D)**-1)**-1

;THE ROUTINE HAS THE FOLLOWING CALLING SEQUENCE:
;	PUSHJ	P, EXP
;
;THE ARGUMENT IS IN N
;THE ANSWER IS RETURNED IN ACCUMULATOR N


	EXTERN	EX1

EXPB:				;ENTRY TO EXPONENTIAL ROUTINE
	MOVE	T, N		;PICK UP THE ARGUMENT IN T
	MOVM	N, T		;GET ABSF(X)
	CAMLE	N, E7		;IS ARGUMENT IN PROPER RANGE?
	JRST	EXTOLG		;EXP TOO LARGE.;##MSG +CON OR STOP?

EXP1:	SETZM	ES2		;INITIALIZE ES2
	MULI	T, 400		;SEPARATE FRACTION AND EXPONENT
	TSC	T, T		;GET N POSITIVE EXPONENT
	MUL	T1, E5		;FIXED POINT MULTIPLY BY LOG2(B)
	ASHC	T1, -242(T)	;SEPARATE FRACTION AND INTEGER
	AOSG	T1		;ALGORITHM CALLS FOR MULT. BY 2
	AOS	T1		;ADJUST IF FRACTION WAS NEGATIVE
	HRRM	T1, EX1		;SAVE FOR FUTURE SCALING
	ASH	A, -10		;MAKE ROOM FOR EXPONENT
	TLC	A, 200000	;PUT 200 IN EXPONENT BITS
	FADB	A, ES2		;NORMALIZE, RESULTS TO A AND ES2
	FMP	A, A		;FORM X^2
	MOVE	N, E2		;GET FIRST CONSTANT
	FMP	N, A		;E2*X^2 IN N
	FAD	A, E4		;ADD E4 TO RESULTS IN A
	MOVE	T, E3		;PICK UP E3
	FDV	T, A		;CALCULATE E3/(F^2 + E4)
	FSB	N, T		;E2*F^2-E3(F^2 + E4)**-1
	MOVE	T1, ES2		;GET F AGAIN
	FSB	N, T1		;SUBTRACT FROM PARTIAL SUM
	FAD	N, E1		;ADD IN E1
	FDVM	T1, N		;DIVIDE BY F
	FAD	N, E6		;ADD 0.5
	XCT	EX1	;SCALE THE RESULTS
	POPJ	P,		;EXIT

E1:	204476430062		;9.95459578
E2:	174433723400		;0.03465735903
E3:	212464770715		;617.97226953
E4:	207535527022		;87.417497202
E5:	270524354513		;LOG(B), BASE 2
E6:	0.5
E7:	207540071260		;88.028
EXTOLG:	PUSHJ	P,INLMS0
	ASCIZ /EXP TOO LARGE IN /
	PUSHJ	P,GOSR3		;PRINT LINE NUMBER
	JRST	LRGANS		;GET LARGEST ANSWER AND RETURN.

;SINGLE PRECISION EXP.2 FUNCTIONS
;THIS ROUTINE CALCULATES N FLOATING POINT NUMBER TO N FIXED
;POINT POWER. THE CALCULATION IS A**B, WHERE T IS OF THE FORM

;	T=Q(0) + Q(1)*2 + Q(2)*4 + ...WHERE Q(I)=0 OR 1

;THERE ARE NO RESTRICTIONS ON THE BASE OR EXPONENT

;THE CALLING SEQUENCE IS AS FOLLOWS:
;	PUSHJ	P, EXP2.0
;THE BASE IS IN ACCUMULATOR N
;AND THE EXPONENT IS IN ACCUMULATOR (N+1) WHEN THE ROUTINE IS
;CALLED. THE ANSWER IS RETURNED IN ACCUMULATOR N.



EXP2.0:	JUMPE	N, FEXP5	;IS BASE ZERO?
	MOVSI	T1, 201400	;GET 1.0 IN ACCUMULATOR T1
	JUMPGE	T, FEXP2	;IS EXPONENT POSITIVE?
	MOVMS	T		;NO, MAKE IT POSITIVE
	PUSHJ	P, FEXP2	;CALL MAIN PART OF PROGRAM
	MOVSI	T, 201400	;GET 1.0 IN T
	FDVM	T, N		;FORM 1/(A**B) FOR NEG. EXPONENT
	POPJ	P,		;EXIT
FEXP1:	FMP	N, N		;FORM A**N, FLOATING POINT
	LSH	T, -1		;SHIFT EXPONENT FOR NEXT BIT
FEXP2:	TRZE	T, 1		;IS THE BIT ON?
	FMP	T1, N		;YES, MULTIPLY ANSWER BY A**N
	JUMPN	T, FEXP1	;UPDATE A**N UNLESS ALL THROUGH
	MOVE	N, T1		;PICK UP RESULT FROM T1
FEXP4:	POPJ	P,		;EXIT

FEXP5:	SKIPN	T		;ARE BASE AND EXP BOTH ZERO?
	MOVSI	N,(1.0)	;YES. 0**0=1.0
	POPJ	P,

;SINGLE PRECISION FORTRAN IV EXP.3 FUNCTIONS
;THIS ROUTINE CALCULATES N FLOATING POINT NUMBER RAISED TO N
;FLOATING POINT POWER. THE CALCULATION IS
;	A**B= EXP(B*LOG(N))

;IF THE EXPONENT IS AN INTEGER THE 
;RESULT WILL BE COMPUTED USING "EXP2.0" .
;SINCE NEGATIVE NUMBERS RAISED TO NON-INTEGER POWERS YIELD
;COMPLEX ANSWERS, THE ALGORITHM CALCULATES
;	EXP(B*LOG(ABSF(N)))

;THE CALLING SEQUENCE FOR THE ROUTINE IS AS FOLLOWS:
;	PUSHJ	P, EXP3.0
;WHERE N IS EITHER 0,2,4, OR 6. THE BASE IS IN ACCUMULATOR N
;AND THE EXPONENT IS IN ACCUMULATOR (N+1) WHEN THE ROUTINE
;IS CALLED. THE RESULT IS RETURNED IN ACCUMULATOR N.




EXP3.0:	JUMPE	T,EXP3A		;IS EXPONENT ZERO?
	JUMPE	N,EXPB30	;IS BASE ZERO?
EXP3A0:	MOVM	A,T		;SET UP ABS VAL OF EXPON FOR SHIFTING
	JUMPL	N,EXP3C		;IS BASE NEGATIVE?
EXP3A1:	MOVEI	T1,0		;CLEAR AC T1 TO ZERO
	LSHC	T1,11		;SHIFT 9 PLACES LEFT
	SUBI	T1,200		;TO OBTAIN SHIFTING FACTOR
	JUMPLE	T1,EXP3GO	;IS T1 > 0
	HRR	B,T1		;SET UP B AS AN INDEX REG.
	MOVEI	T1,0		;CLEAR OUT AC T1
	LSHC	T1,(B)		;SHIFT LFT BY CONTENTS OF B
	JUMPN	A,EXP3GO	;IS EXPONENT AN INTEGER ?
	SKIPGE	T		;YES, WAS  IT NEG. ?
	MOVNS	T1		;YES, NEGATE IT
	MOVE	T,T1		;MOVE INTEGER INTO T

	JRST	EXP2.0		;OBTAIN RESULT USING EXP2.0
EXP3GO:	PUSH	P,T		;SAVE EXPONENT
	PUSHJ	P,ALOGB		;CALCULATE LOG OF N
	FMPR	N,(P)		;CALCULATE B*LOG(N)
	PUSHJ	P, EXPB		;CALCULATE EXP(B*LOG(N))
	POP	P,T		;GET EXPONENT BACK
	POPJ	P,		;RETURN


EXP3A:	MOVSI	N,(1.0)		;YES. ANSWER IS 1.0
	POPJ	P,

EXPB30:	JUMPGE	T,ZERANS	;ZERO TO NONNEGATIVE POWER?
EXPB3:	PUSHJ	P,INLMS0
	ASCIZ /ZERO TO A NEGATIVE POWER IN /
	PUSHJ	P,GOSR3
LRGANS:	HRLOI	N,377777	;LARGEST ANSWER.
	POPJ	P,

EXP3C:	MOVE	X1,A
	FAD	X1,FIXCON
	FSB	X1,FIXCON
	CAMN	A,X1
	JRST	EXP3A1		;NEGATIVE BASE, INTEGRAL POWER
	PUSH	P,N		;SAVE ARGUMENTS
	PUSH	P,T
	PUSHJ	P,INLMS0
	ASCIZ /ABSOLUTE VALUE RAISED TO POWER IN /
	PUSHJ	P,GOSR3
	POP	P,T
	POP	P,N
EXP3C0:	MOVMS	N
	JRST	EXP3A0
	SUBTTL	RUN-TIME RANDOM NUMBER ROUTINES

IFN FTRND, <
;;WRANB -- PSEUDO-RANDOM RESET/WARMUP
; PUSHJ	P,WRANB
;
;THE ARG IS IN ACCUMULATOR A
;
; 1.	USES STANDARD BASIC "PUSHJ" CALLING SEQUENCE.
; 2.	W IS A BIT VECTOR (BITS 05-35 SIGNIFICANT).
; 3.	RETURNS NO USEFUL VALUE IN AC Z.
; 4.	CREATES A BASIS OF "NNN" VECTORS AT VRANT IN VRAN,
;	BASED ON THE WARMUP ARGUMENT W. (STANDARD VALUE
;	IS W=0.) RESETS VRAN'S OWN INDEX. USES VRAN LOCATIONS
	;		VRANR	; VRAN OWN INDEX RESET VALUE.
	;		VRANW	; VRAN'S WARMUP CONSTANT.
	;		VRANT	; VRAN'S VECTOR-TABLE.
	;		VRANN	; NEGATIVE TABLE LENGTH.
; 5.	FORTRAN AC ASSIGNMENTS ARE
;	N=00	; FUNCTION-VALUE RETURN AC.
;	T=1	; SCRATCH AC.
;	P=17	; PUSHDOWN LIST
;	T1=2	; INDEX AC.
;	A=3	; INDEX AC.
; 6.	WRAN MAY BE USED FREELY TO REPEAT A PREVIOUSLY GENERATED
;	SEQUENCE (BY CALLING WRAN WITH THE PREVIOUSLY USED VALUE
;	FOR W), OR TO CAUSE THE GENERATION OF A COMPLETELY NEW
;	SEQUENCE (BY CALLING WRAN WITH A NEW VALUE FOR W).


	...=0	; ELLIPSIS (FOR CONVENIENCE).
>



IFN FTRND, <
WRANB:	XOR	N,VRANW		;   ADJUST,
	TLZ	N,(37B4)	;   IGNORE BITS 00-04,
	JUMPE	N,WRANB		;   REJECT 0.
	MOVSI	T1,VRANN		; ESTABLISH OUTER LOOP.
WRAN2:	MOVNI	A,6	; ESTABLISH INNER LOOP.
WRAN3:	MOVE	T,N		; COPY ARGUMENT,
	ROT	T,13		;   POSITION BITS 05-10 FOR
	XOR	T,N		;   MOD 2 SUM WITH BITS 30-35.
	ROT	T,-6		; USE RESULT AS NEW
	LSHC	N,6		;   ARGUMENT BITS 30-35.
	AOJN	A,WRAN3		; SIX BYTES DONE? NO, BACK.
	MOVEM	N,VRANT(T1)	; YES, ARGUMENT IS BASIS VECTOR.
	AOBJN	T1,WRAN2		; "NNN" VECTORS DONE? NO, BACK.
	MOVE	N,VRANR		; RESET VRAN OWN INDEX.
	MOVEM	N,VRANX		; (AFTER RESTORING AC'S!)
	POPJ	P,			; RETURN (OVER "ARG").


;FRANB -- FLOATING-POINT PSEUDO-RANDOM GENERATOR.

; PUSHJ	P,FRANB
;
; 1.	USES STANDARD BASIC "PUSHJ" CALLING SEQUENCE.
; 3.	RETURNS IN AC N A FLOATING-POINT NUMBER AS AN
;	INSTANCE OF A REAL RANDOM VARIABLE UNIFORMLY
;	DISTRIBUTED ON THE OPEN INTERVAL (0,1).
; 4.	REQUIRES THE VECTOR GENERATOR FUNCTION VRAN.
;VRAN
; 5.	FORTRAN AC ASSIGNMENTS ARE
FRANB:
FRAN1:	PUSHJ	P,VRANB		; GET RANDOM VECTOR,
	LSH	N,-9		;   SCALE TO MANTISSA,
	JUMPE	N,FRAN1		;   REJECT ZERO.
	TLO	N,(1B1)		; FORCE EXPONENT OF 2^0,
	FAD	N,[1B1]		;   NORMALIZE.
	POPJ	P,		; RETURN (IGNORE "ARG").
>

IFN FTRND, <
;VRAN7B -- 36-BIT PSEUDO-RANDOM GENERATOR.

;; NAME SHOULD ALWAYS BE
;; "VRANXX", WHERE "XX" IS THE ASSEMBLED VALUE OF
;; THE PARAMETER "NNN". (SEE 6. BELOW.) USE ONLY THE
;; STATISTICALLY BEST "EEE" VALUE FOR EACH "NNN" VALUE.

; PUSHJ	S,VRANB
;
; 1.	USES STANDARD BASIC "PUSHJ" CALLING SEQUENCE.
; 3.	RETURNS IN AC N A 36-BIT PSEUDO-RANDOM VECTOR.
;		VRANX	; AC STORAGE, OWN INDEX.
;		VRANR	; OWN INDEX RESET VALUE.
;		VRANW	; WARMUP CONSTANT.
;		VRANT	; VECTOR-TABLE.
;		VRANN	; NEGATIVE TABLE LENGTH.
; 6.	VRAN HAS THREE ASSEMBLY PARAMETERS:
	RADIX 10
	NNN=7	; VECTOR-TABLE SIZE.
	EEE=3	; VECTOR-TABLE OFFSET.
	RADIX 8
	W=013702175435	; VECTOR-TABLE GENERATOR.
;	WHICH ARE USED TO ESTABLISH AN INITIAL TABLE OF
;	"NNN" BASIS VECTORS <V[J] : 0 .LE. J .LT. NNN>, AND TO
;	GENERATE SUCCESSIVE VECTORS ACCORDING TO THE RULE:
;	V[NNN+J] = (V[0+J] + V[EEE+J]) MODULO (2^36) : 0 .LE. J.
;	(SEE RANPAK.TXT FOR ADMISSABLE VALUES FOR <NNN,EEE,W>,
;	AND A DISCUSSION OF THE ALGORITHM.)

	VRANN=-NNN	; NEGATIVE TABLE LENGTH (FOR WRAN).
>

IFN FTRND, <
VRANB:	MOVE	T1,VRANX		; SET UP OWN INDEX.
	MOVE	N,VRANT+NNN(T1)	; ADDEND V[E+J] IF J .LT. N-E.
	TRNN	T1,(1B0)		; [J.LT.N-E]=[RH(T1).LT.0]?
	MOVE	N,VRANT+0(T1)	; ADDEND V[E+J] IF J .GE. N-E.
	ADDB	N,VRANT+NNN-EEE(T1)	; AUGEND V[0+J] AND RESULT V[N+J].
	AOBJN	T1,VRAN1		; STEP J; J.GT.N? NO,OVER.
	MOVE	T1,VRANR		; YES, RESET J.
VRAN1:	MOVEM	T1,VRANX		; SAVE OWN INDEX.
	POPJ	P,		;EXIT

VRANR:	XWD	-<NNN+1>,-<NNN-EEE>	; OWN INDEX RESET VALUE.

VRANW:	EXP	W		; WARMUP CONSTANT (FOR WRAN).
>
	XLIST	;THE LITERALS
	LIT
	LIST
	END 	EXECUT


 y@	n