
;	COMPAR
;
;	VERSION 002
;	24 FEB 1970
;	CWRU
;
;COPYRIGHT 1970, DIGITAL EQUIPMENT CORP., MAYNARD, MASS.
;
	EXTERN GLTBL
	EXTERN	OLDNUM,OLDPNT,MRGOUT
	ENTRY	CBGET
	EXTERNAL	SAVE16,BASDDB
	EXTERN	CRPERR
	EXTERN	LBUFP1,SAVFFX,SAVAC2




	HISEG	




	EXTERNAL	JOBFF,JOBREL,JOBSYM,JOBDDT	
	EXTERN	DIASW
	ENTRY	BIN,UIN

	EXTERN	OUTDEV,PPSET,ERRCNT,TOP,TOP1,TOP2,LBUFP
	EXTERN	LBUFP2,P1,P2,SAVEXS,TEMP,RTNTMP,WCADR,HIGH
	EXTERN	ROOM,GETCNT,GETFIL,NUMTMP,TEMPF1,TEMPF2
	EXTERN	LINEND,LSTCH,SAVEC,SAVNO2,LINCNT,SAVNO,LINEN0
	EXTERN	BUFF1,BUFF2,ENDP,NUMLIN




	TITLE	COMPAR	




	SUBTTL SOURCE FILE COMPARE - BSW MODIFIED FOR SOUP	



BACHAN=5
USCHAN=6

W1=1
W2=2
W3=3
FIL=4		; FILE # (0 IS FILE 1; 1 IS FILE 2)
F1=5		; LINE POINTER FILE 1 (CONTAINS INTEGER)
F2=F1+1		; DITTO FILE 2
FR=7		; FLAG REGISTER (LH) AND FILE #(0 OR 1)(RH)
C=10		; CONTAINS 1 CHAR FOR PROCESSING
T=11		; TEMPORARY AC
TT=12		; TEMP AC
PP=17		; PUSH DOWN POINTER
LPDL==20	; LENGTH OF PUSH DOWN LIST

TAB==11
LF==12
FF==14
CR==15
VT==13		; VERTICAL TAB

SSWBIT==100	; /S SWITCH - IGNORE SPACING
CSWBIT==200	; /C SWITCH - IGNORE COMMENTS
ALLSW==400	; /B SWITCH (ALLOWS COMPARING BLANK LINES)
EOF1SW==1000	; EOF SEEN ON FILE 1
EOF2SW==2000	; EOF SEEN ON FILE 2




EOFTBL:	EOF1SW	
	EOF2SW




NUMSW=10000	; DO THEY WANT NUMBERED LINES?

	MATCH==3

COMPAR:	MOVE	PP,[IOWD 20,PPSET]	; SET UP COMPAR PDP
	MOVE	[XWD PPSET,PPSET+1]	; ZERO LOCAL STORAGE
	SETZM	PPSET		; HERE IS FIRST ZERO
	MOVE	JOBFF		; ALSO SAVE JOBFF
	MOVEM	SAVFFX
	BLT	ENDP-1		; EVERYTHING GONE NOW
	MOVEI	BUFF1		; RESTORE HIGHEST BUFFER ADDR
	MOVEM	LBUFP1		; IN APPROPRIATE POINTERS
	MOVEI	BUFF2
	MOVEM	LBUFP2
	MOVEI	ENDP-1
	MOVEM	@GLTBL+1	; AND IN PROPER TABLES
	MOVEI	FR,0		; SPECIAL COMPAR FEATURES DON'T WORK
	SETZM	LSTCH		; TEMP SWITCH
	HRLOI	377777		; LARGEST POSSIBLE LINE NUMBER
	MOVEM	OLDNUM		; TO FORCE SETONE TO COMPUTE
	MOVEM	OLDNUM+1	; LINE POINTERS AT OUTSET
	SETZM	LINEND		; SET END OF LINE FLAG TO FALSE
	SETZM	LINEN0
	SOS	LINEN0
	SOS	LINEN0		; START LINEN0 OUT AT -2

	SETOB	F1,TOP1		; INITIALIZE TOP OF EACH FILE
	SETOB	F2,TOP2		; THE TOP IS THE HIGHEST LINE THAT WE HAVE EXAMINED
	PUSHJ	PP,GETTWO
	JFCL			; ONE FILE HAS NO LINES
	JRST	MAINST		; START COMPARE WITH 1ST LINES




; THE FOLLOWING CODE IS THE GUTS OF THE PROGRAM.
; WHEN THE LOOP AROUND MAIN DETECTS THAT TWO LINES ARE NOT A MATCH
; CONTROL GOES OFF TO DETERMINE THE EXTENT OF THESE DIFFERENCES.
; THE TOTAL DIFFERENCES ARE DETERMINED AS FOLLOWS.  FIRST GET TWO 
; MORE LINES. DOES THE ORIGINAL LINE IN FILE 1 WHICH DID NOT MATCH
; MATCH THE NEW LINE FROM FILE TWO. IF SO THEN THE ORIGINAL LINE
; IN FILE 2 WAS AN INSERTION. (OR A DELETION).  IF NO MATCH THIS 
; WAY TRY IT THE OTHER WAY. IF STILL NO MATCH GET TWO MORE LINES
; TAKE THE NEW LINE FROM FILE 1 AND TRY TO MATCH IT AGAINST ALL THE
; LINES WE HAVE BEEN EXAMINING IN FILE TWO; THEN DO IT THE OTHER
; WAY AROUND. EOF'S ARE DETECTED BY "GETTWO"  WITH NO RETURN SKIP

MAIN:	TRZ	FR,-1		; THIS FOR FILE ONE
	PUSHJ	PP,MOVEUP	; MOVE UP THE BOTTOM, BECAUSE WE ARE FINISHED
				; WITH TWO LINES
	TRO	FR,1		; NOW FOR FILE TWO
	PUSHJ	PP,MOVEUP	; UP GOES THE BOTTOM POINTER
MAINST:	SETOB	F1,F2		; INITIALIZE LINE POINTERS
	PUSHJ	PP,GETTWO	; GET TWO LINES
	JRST	MAIN15		; ONE FILE SHORT
	PUSHJ	PP,COMPL	; COMPARE THESE TWO LINES
	JRST	MAIN		; THEY MATCH--LOOK AT NEXT TWO



; WHEN WE GET HERE WE HAVE DETECTED A DIFFERENCE	
; NOW THE PROGRAM WILL LOOK AHEAD TO TRY AND FIND THE NEXT TWO
; MATCHING LINES




MAIN10:	
	PUSHJ	PP,GETTWO
	JRST	MAIN15		; ONE FILE SHORT
	SETZ	F1,		; RESET POINTER FOR FIRST FILE TO
				; THE LINE IN WHICH THE DIFFERENCE WAS FOUND


MAIN12:	PUSHJ	PP,COMPL	; NOW SEE IF WE CAN MATCH THAT LINE
	JSP	W1,MULTI	; FOUND 1 LINE MATCH- LOOK FOR MULTIPLE
	CAME	F1,F2		; HAVE WE LOOKED FROM THE MISMATCHED LINE
				; TO THE CURRENT LINE?
	AOJA	F1,MAIN12	; NO--UP LINE POINTER AND TRY AGAIN
	SETZ	F2,		; HAVEN'T FOUND A MATCH THIS TIME
				; NOW TRY IT THE OTHER WAY

MAIN14:	PUSHJ	PP,COMPL
	JSP	W1,MULTI	; LOOK FOR MULTI LINE MATCH
	CAME	F2,F1
	AOJA	F2,MAIN14
	JRST	MAIN10		; HAVEN'T BEEN ABLE TO MATCH ANYTHING
				; YET GET TWO MORE LINES AND TRY AGAIN

; THE MAIN15 CODE HANDLES THE CASE OF EITHER (OR BOTH) FILES
; HAVING NO LINES TO COMPARE. IF BOTH FILES HAVE NO LINES, "FINISH"
; PRINTS OUT ALL LINES IN BOTH FILES (IF ANY) AS DIFFERENCES.
; IF EITHER FILE HAS A NEW LINE, THE SHORTER FILE IS
; SEARCHED FOR A MATCH FOR THAT LINE. THIS CONTINUES (READING A NEW LINE
; FROM THE LONGER FILE) UNTIL NEITHER FILE HAS ANY LINES OR UNTIL A
; MATCH IS FOUND.



MAIN15:	SKIPGE	W1,GETFIL	; DOES EITHER FILE HAVE A LINE?	
	JRST	FINISH		; NO
	HRRZM	W1,FIL		; SAVE FILE # THAT HAS LINES
	HRR	FR,W1		; SETUP FR FOR MAIN18
	JUMPL	F1,MAIN18	; TRA IF FILE 1 HAS NO LINES
	JUMPL	F2,MAIN18	; DITTO FILE 2
	TRC	FIL,1		; CHANGE 1 TO 0 (OR VICE VERSA)
	SETOM	F1(FIL)		; LOOK THRU SHORT FILE FOR MATCH
MAIN17:	MOVE	W1,F1(FIL)
	CAML	W1,TOP1(FIL)	; SEARCHED THRU SHORT FILE?
	JRST	MAIN10		; YES, AND NO MATCH
	AOS	F1(FIL)		; INDEX LINE
	PUSHJ	PP,COMPL	; LOOK FOR A MATCHING LINE
	JSP	W1,MULTI	; FOUND A MATCH, NOW LOOK FOR MULTIPLE MATCH
	JRST	MAIN17		; NO MULTI LINE MATCH

MAIN18:	AOS	CRPERR
	JRST	MAIN10

; AT THIS POINT NEITHER FILE HAS ANY MORE LINES TO BE READ.
; PRINT AS DIFFERENCES ANY LINES REMAINING FOR EITHER FILE.

FINISH:	JUMPGE	F1,FIN1		; PRINT DIFFERENCES IF EITHER BUFFER
	JUMPL	F2,FIN2		;  HAS ANY LINES IN IT
FIN1:	PUSHJ	PP,SLIPO	; GO PREPARE LAST CORRETION FOR OUTPUT
FIN2:	HRREI	13,-1		; HERE GAME IS OVER. GIVE BACK
	MOVE	SAVFFX		; -1 AS EOF AND RESTORE JOBFF
	MOVEM	JOBFF
	SETZM	STATE.		; RESET CBGET STATE
	MOVEI	5
	MOVEM	CRPERR		; RESET TO 5 CORR./REDUNDANCY CHECK
	MOVEI	ENDP-1
	MOVEM	@GLTBL+1	; RESET ALL IMPORTANT TABLE
	HRLZI	17,SAVAC2	; GET USER'S REGS
	BLT	17,16		; AND PUT THEM BACK
	MOVE	17,SAVAC2+17	; GET REG 17
	SETOM   COMPOP		; SET OPTION TO DONE
	HRREI	13,-1		; EOSF
	JRST	CBRTN		; AND RETURN





MULTI:	SKIPG	NUMLIN	
	JRST	MULT8
	HRRZM	W1,RTNTMP
	SETZM	NUMTMP		; INIT MULTI-LINE COUNTER
	MOVEM	F1,TEMPF1	; SAVE CURRENT POINTERS
	MOVEM	F2,TEMPF2
MULT2:	PUSHJ	PP,GETTWO	; GET NEXT TWO LINES
	 JRST MULT4		; ONE FILE DOESN'T HAVE A LINE
	PUSHJ	PP,COMPL	; COMPARE THEM
	JRST	MULT6		; MATCH, TEST MULTI COUNTER 
MULT4:	MOVE	F1,TEMPF1	; NO MATCH, RESET REGS
	MOVE	F2,TEMPF2
	JRST	@RTNTMP		; RETURN TO WHERE WE GOT TO MULTI FROM

MULT6:	AOS	W1,NUMTMP
	CAMGE	W1,NUMLIN	; TEST FOR END
	JRST	MULT2		; TEST NEXT TWO
	SUB	F1,W1		; RESET TO 1ST COMPARISON
	SUB	F2,W1
MULT8:	PUSHJ	PP,SLIPO	; OUTPUT A CORRECTION

	ADD	F1,NUMLIN	; CAUSE MOVEUP TO FLUSH ALL THE
	ADD	F2,NUMLIN	;  LINES THAT WERE JUST MATCHED
	JRST	MAIN		; DIFFERENCES PRINTED- LOOK FOR MORE



; THIS ROUTINE SETS UP THE POINTERS TO THE TEXT

; MEMORY STORAGE AREA LOOKS LIKE THIS:
; 1) BUFFER SPACE FOR FILE # 0 (POINTED TO BY LBUFP1)
	; 	A) XWD (PAGE #),(WORD COUNT FOR LINE (INCLUDING THIS WORD))
; 	   TEXT FOR LINE 0
; 	    MORE TEXT FOR LINE 0
; 	     & MORE, ENDED WITH A NULL
; 	B) MORE LINES (EACH WITH PAGE #,WORD COUNT, AND TEXT
; 2) BUFFER SPACE FOR FILE 1 (POINTED TO BY LBUFP2)
; 	A) AS ABOVE




SETP:	HRRI	FR,1		; SET UP POINTER FILE 1
	PUSHJ	PP,SETONE
	HRRI	FR,0		; DITTO FILE 0

SETONE:	MOVE	W3,F1(FR)	; GET LINE #
SETON1:	MOVE	TT,OLDNUM(FR)	; GET LINE #
	MOVEM	W3,OLDNUM(FR)	; SAVE # WE ARE COMPUTING
	CAML	W3,TT		; HOW DO THEY COMPAR
	SKIPA	T,OLDPNT(FR)	; GTR IS THERE A POINTER STORED?
	SKIPA	T,LBUFP1(FR)	; LESS, GET LOWEST BUFF ADDR
	SUB	W3,TT		; HOW FAR DO WE GO FROM WHERE WE ARE?
	MOVSI	TT,(ADD T,(T))	; (SET UP IN AC)
	MOVE	TT+2,[JRST SETON2]	; SET UP AC
	MOVE	TT+1,.+1	; SET UP AC
	SOJGE	W3,TT
		; TT/	ADD T,(T)	;ADD IN WORD COUNT FOR LINE
		; TT+1/	SOJGE W3,.-1	;MORE LINES LEFT?
		; TT+2/	JRST SETON2	;NO

SETON2:	HRRZM	T,OLDPNT(FR)	; SAVE THIS POINTER
	HRLI	T,(POINT 7,0,35); NO, CHANGE TO BYTE POINTER
	MOVEM	T,W1(FR)
	POPJ	PP,

; MOVE UP THE POINTERS WHICH POINT TO THE LINES FROM WHICH WE
; ARE EXAMINING.  THIS IS DONE EVERYTIME A MATCH IS FOUND

MOVEUP:	MOVE	W3,F1(FR)	; GET LINE # FOR THIS FILE
	CAML	W3,TOP(FR)	; GETTING RID OF ALL LINES?
	JRST	MOVEX		; YES, DON'T MOVE MEMORY
	AOS	W3,F1(FR)	; GET LINE # OF LINE TO SAVE
	PUSHJ	PP,SETON1	; GET ADR OF 1ST LINE TO SAVE
	HRL	T,LBUFP1(FR)	; SET UP BLT AC (REVERSED)
	PUSH	PP,T		; SAVE
	AOS	W3,TOP(FR)	; GET 1ST NON-EXISTANT LINE #
	PUSHJ	PP,SETON1	; GET CORRESPONDING 1ST ADR
	POP	PP,W1
	SUB	T,W1		; CALCULATE WORD COUNT OF TRANSFER
	ADD	T,LBUFP1(FR)	; CALCULATE "E" OF BLT AC,E
	MOVSS	W1		; SWITCH AC TO XWD FROM,TO
	BLT	W1,(T)		; AND AWAY WE GO

MOVEX:	SETCM	W2,F1(FR)	; W2_-<(F1)+1>
	ADDM	W2,TOP(FR)	; CHANGE TOP TO ACCOUNT FOR DEAR DEPARTED LINES
	HRLOI	0,377777	; FORCE COMPUTATION OF
	MOVEM	0,OLDNUM(FR)	; NEXT LINE POINTERS
	POPJ	PP,




; CODE FOR GETTING TWO LINES	
; CALLING SEQUENCE IS:
;	PUSHJ PP,GETTWO
; 	   RETURN 1 IF EITHER FILE HAS NO MORE LINES
; 	   RETURN 2 IF ONE LINE READ FROM EACH FILE
; C(GETFIL)=THE # OF FILE FOR WHICH A LINE WAS READ (OR -1 IF NONE)





GETTWO:	SETOM	GETCNT		; INIT # LINESOBTAINED	
	SETOM	GETFIL		; INIT FILE # LINE CAME FROM
	TRZ	FR,-1		; ZERO RIGHT HALF OF "FR"--SET FOR FIRST FILE
	PUSHJ	PP,GLINE	; GET A LINE FROM FIRST FILE
	HRRI	FR,1		; NOW DO FOR SECOND FILE
	PUSHJ	PP,GLINE
	SKIPLE	GETCNT		; GETCNT .G. 0 IF TWO LINES WERE GOT
	AOS	(PP)		; SKIP IF 2 LINES WERE AVAILABLE
	POPJ	PP,
GLINE:	AOS	W1,F1(FR)	; BUMP THE LINE POINTERS
	CAMG	W1,TOP(FR)	; HAVE WE GONE OVER THE TOP
	JRST	GLEXIT		; NO, LINE WAS AVAILABLE
	SOS	F1(FR)		; NOT CLEAR YET THAT A NEW LINE EXISTS
GLINE1:	SETZM	LINEND		; CLEAR END OF LINE FLAG
	JSP	TT,GCHAR	; GET A CHAR
	TLNE	FR,@EOFTBL(FR)	; END OF FILE?
	POPJ	PP,		; YES, NO LINE
	AOS	W1,F1(FR)	; THERE ARE CHARS FOR A NEW LINE
	MOVEM	W1,TOP(FR)	; THIS LINE IS THE TOP LINE
	PUSHJ	PP,SETONE	; CALCULATE BYTE POINTER
	MOVE	W1,W1(FR)	; GET BYTE POINTER IN W1
	MOVEM	W1,WCADR	; SAVE ADR OF LINE WORD COUNT
	CAIN	C,"-"		; IS FIRS CHAR (SHUDDER) A -?
	JRST	FDGMIN		; OUCH! FUDGE PROPER EDIT COMMAND
	JRST	GLINE3		; PHEW! CONTINUE UNFLUSTEREDLY

MLON; MULTI LINE LITERAL

GLINE2:	JSP	TT,GCHAR	; GET A CHAR
GLINE3:	TLNN	W1,760000	; WILL NEXT IDPB GO INTO NEXT WORD?
	JRST	[HRRZ W3,@GLTBL(FR); YES,GET HIGHEST ADR FOR THIS BUFFER
	CAIG	W3,3(W1)	; CHECK ADR. (LEAVE 1 WORD FOR WORD
				; COUNT FOR NEXT LINE PLUS 1 WORD
				; SLOP TO BE SAFE
		JRST	NOROOM	; NO ROOM IN THE INN
	SETZM	1(W1)
	JRST .+1]	; GO INTO MAIN LOOP
	IDPB	C,W1
	SKIPL	LINEND		; IF GCHAR SAYS END OF LINE,
	JUMPN	C,GLINE2	; OR GIVES US A NULL
	MOVEI	C,0		; BY GOLLY, WE GOT A LINE
	TLNN	W1,760000
	JRST	[HRRZ W3,@GLTBL(FR)
	CAIG	W3,3(W1)
	JRST	NOROOM
	SETZM	1(W1)
		JRST	.+1]
	IDPB	C,W1		; NOW MAKE THE LINE ASCIZ
	SETZM	LINEND		; RESET EOL FLAG
	MOVE	W3,WCADR	; GET BACK ADR OF WORD COUNT
	SUBI	W1,-1(W3)	; CALCULATE WORD COUNT
	HRRM	W1,(W3)		; SAVE WORD COUNT IN BUFFER
GLEXIT:	AOS	GETCNT		; INDEX # LINES FOUND
	HRRZM	FR,GETFIL	; SAVE # OF THIS FILE
	POPJ	PP,
FDGMIN:	TLNN	W1,760000
	JRST	[HRRZ	W3,@GLTBL(FR)
	CAIG	W3,3(W1)
	JRST	NOROOM
	SETZM	1(W1)
	JRST	.+1]
	IDPB	C,W1		; - IS ALREADY IN C, BUT 2 ARE NEEDED!!
	JRST	GLINE3		; NOW ADD THE ORIGINAL - AGAIN



NOROOM:	PUSH	PP,W1		; SAVE BYTE POINTER 
	TRC	FR,1		; CHANGE 1 TO 0 (OR VICE VERSA)
	MOVE	W3,TOP(FR)		; GET TOP LINE # FOR "OTHER" FILE
	ADDI	W3,1		; FIND 1ST ADR OF THE NEXT LINE ABOVE TOP
	PUSHJ	PP,SETON1	; GET ADR
	HRRZM	T,HIGH		; SAVE 1ST FREE ADR OF NON-FULL FILE
	HRRZ	T,@GLTBL(FR)	; GET HIGHEST ADR AVAILABLE TO NON-FULL FILE
	SUB	T,HIGH		; GET SPACE AVAILABLE
	SUBI	T,2		; LEAVE 1 WRD FOR NEXT LINE WORD COUNT
				; PLUS 1 WORD SLOP TO BE SAFE
	TRC	FR,1		; CHANGE FILE # BACK TO THE WAY IT WAS
	MOVEM	T,ROOM		; SAVE ROOM AVAILABLE
	CAIL	T,4		; LESS THAN 4 WORDS LEFT?
	JRST	NOR2		; PLENTY ROOM AVAILABLE- DON'T GET MORE CORE
	SETOM	DIASW		; SET SW TO PREVENT DIALOGUE
	MOVE	SAVFFX		; NOPLACE TO GO NOW
	MOVEM	JOBFF		; SO RESTORE JOBFF
	PUSHJ	16,IOERR	; PRINT ERROR MESSAGE
	XWD	[ASCIZ/?COMPAR BUFFER OVERFLOW/],BASDDB
	HRLZI	17,SAVAC2	; RESTORE USER'S REGS
	BLT	17,16
	MOVE	17,SAVAC2+17	; GET REG 17
	JSP	14,MRGOUT	; MAKE ERROR MSG APPEAR
	[30]			; IN CORRECTION FILE
	[ASCIZ/-"BUFFER OVERFLOW!!!!"
/]
	MOVEI	13,0		; GIVE BACK PROPER ERROR CODE
	SETZM	STATE.		; RESET STATE OF CBGET
	JRST	CBRTN		; AND TRUDGE HOME




NOR2:	ASH	T,-1		; DIVIDE AVAILABLE SPACE BETWEEN FILES	
NOR4:	MOVEM	T,ROOM		; FILE #1 GETS MOVED THIS AMOUNT
	TRNN	FR,1		; WHICH FILE NEEDED ROOOM?
	JRST	NOR5		; FILE #0. MOVE #1 TOWARD 777777
				; FILE #1. MOVE #1 TOWARD 0
NOR6:	MOVNS	T,ROOM		; FILE IS MOVING IN NEGATIVE DIRECTION
	ADDM	T,WCADR		; WORD COUNT ADR FOR FILE# 1 IS MOVED DOWN
	ADDM	T,(PP)		; SAME WITH BYTE POINTER
	MOVE	W1,(PP)		; GET LAST ADR TO MOVE FROM BYTE POINTER
	ADD	T,LBUFP2	; GET "TO" ADR. [(LBUFP2)-D OF M]
	HRL	T,LBUFP2	; GET "FROM" ADR
	BLT	T,(W1)		; BLT T,"E" (T/  XWD "FROM","TO")
	JRST	NOR90

NOR5:	MOVE	W1,T		; GET D OF M
	HRLI W1,(POP T,(T))	; SETUP- POP T,<D OF M>(T) INTO W1
	MOVE W2,HIGH		; GET HIGH(+1) ADR OF FILE #1
	SUB W2,LBUFP2		; GET LENGTH OF FILE #1
	SOS T,HIGH		; GET LAST ADR IN FILE #1
	HRLI T,400000(W2)	; PUT WORD COUNT(+400000) IN LEFT HALF
				; 400000 AVOIDS PDL OVERFLOW PROBLEM IN AC LOOP
	MOVE W3,[JRST NOR90]
	MOVE W2,.+1
	JUMPL T,W1		; W1/	POP T,<DISTANCE OF MOVE>(T)
				; W2/	JUMPL T,W1
				; W3/	JRST NOR90
; THE ABOVE INSTRUCTIONS ARE A REVERSE BLT AND ARE IN THE AC'S FOR SPEED

NOR90:	MOVE	T,ROOM		; GET DISTANCE FILE #1 WAS MOVED
	ADDM	T,LBUFP2	; MODIFY STARTING ADR OF FILE #1
	HRLOI	377777
	MOVEM	OLDNUM+1	; FORCE COMPUTATION O F LINE POINTERS
NOR98:	POP	PP,W1
NOR99:	JRST	GLINE3		; CHECK COMPUTATIONS ON RETURNING

	; THIS PAGE CONTAINS ROUTINE FOR COMPARING TWO LINES
	; IT HAS TWO RETURNS--CALLING ADR.+1 IF LINES MATCH OR
	; CALLING ADR+2 IF NO MATCH

COMPL:	PUSHJ	PP,SETP		; CALCULATE POINTERS TO TEXT
	MOVEM	W1,P1		; P1=TEMP POINTER TO TEXT FOR FIRST FILE
	MOVEM	W2,P2		; P2 FOR SECOND FILE

	MOVEI	W3,1

COMPL1:	ILDB	W1,P1		; GET A CHARACTER FROM LINE FROM FIRST FILE
COMPL2:	ILDB	W2,P2		; AND ONE FROM SECOND FILE
COMPL0:	CAME	W1,W2		; THIS IS THE BIG TEST--ARE THEY EQUAL
	JRST	COMPL4		; NO
COMPL7:	CAIN	W1,";"		; YES, COMMENT?
	TLNN	FR,CSWBIT	; YES, SUPPRESS COMMENTS?
	JUMPN	W1,COMPL1	; NO,NO. TEST FOR END OF LINE
	POPJ	PP,		; LINES MATCH, RETURN

COMPL3:	ILDB	W1,P1		; GET NEW CHAR FOR FILE 1
COMPL4:	CAIE	W1,40		; SPACE?
	CAIN	W1,TAB		; OR TAB?
	TLNN	FR,SSWBIT	; AND IS SPACING BEING IGNORED?
	SKIPA			; NO
	JRST	COMPL3		; FLUSH SPACE OR TAB FOR FILE 1

	CAIE	W2,40		; SPACE?
	CAIN	W2,TAB		; OR TAB?
	TLNN	FR,SSWBIT	; AND IS SPACING BEING IGNORED?
	SKIPA			; NO
	JRST	COMPL2		; YES, FLUSH A SPACE OR TAB FOR FILE 2

	CAMN	W1,W2		; ARE THE CHARACTERS NOW THE SAME?
	JRST	COMPL7		; YES, TEST FOR END OF LINES

	CAIE	W1,";"		; COMMENT IN FILE 1?
	CAIN	W2,";"		; OR IN FILE 2?
	TLNN	FR,CSWBIT	; AND ARE COMMENTS BEING IGNORED?
	JRST	CPOPJ1		; NO, FILES DON'T MATCH, SKIP RETURN
	JUMPE	W1,CPOPJ	; YES, OTHER CHAR MUST BE NULL OR ELSE ONE
	JUMPE	W2,CPOPJ	;  LINE IS LONGER THAN OTHER AND FILES DIFFER
CPOPJ1:	AOS	(PP)
CPOPJ:	POPJ	PP,



; ROUTINE TO GET A LEGIMATE CHARACTER

GCHAR:	TLNE	FR,@EOFTBL(FR)	; EOF SEEN?
	JRST	NULL		; YES, RETURN NULL
	JSP	11,@[EXP BIN,UIN](FR); LOAD ONE FROM PROPER PLACE
	CAIL	C,37		; COULD IT BE A FEED?
	JRST	(TT)		; NOPE
	CAIN	C,CR		; WAS IT A CR?
	JRST	(TT)		; YUP, AND THAT IS NOT A FEED
	CAIN	C,LF		; HOW  BOUT AN LF
	JRST	LINDON		; YES, AND LINE IS NOW DONE
	CAIN	C,VT		; SAME STORY FOR VT
	JRST	LINDON
	CAIN	C,FF		; AND FORM FEED
	JRST	LINDON
	JRST	(TT)		; ANYTHING ELSE IS JUST RUBBISH
LINDON:	AOS	LINEN0(FR)	; NOW LINE IS DONE, INCREMENT COUNT
	SETOM	LINEND		; SET END OF LINE FLAG TO TRUE
	JRST	(TT)		; GO BACK
NULL:	MOVEI	C,0		; HERE IS A NULL
	SETOM	LINEND		; ALSO END OF NON EXTANT LINE
	JRST	(TT)		; RETURN




NCON:	SETZB	C,C+2	
	DIVI	C,12
	ADDI	C+1,60
	ROTC	C+1,-7
	MOVE	C+1,C
	MOVEI	C,0
	JUMPN	C+1,.-5
	JRST	0(15)




	; HERE IS THE ROUTINE THAT EXTRACTS INFORMATION FROM THE
	; FORMER SRCCOM TYPE OUTPUT TO PRODUCE THE CORRECTION
	; COMMANDS.  THIS ROUTINE USES THE FOLLOWING BUFFERS
	; AND WORRIES ABOUT THE FOLLOWING THINGS:


	;	BUFFER		LIKELY CONTENTS
	;


	;	NUMBUF		ASCIZ/-<NUMBER><A COMMA IF:
	;						1. A SECOND #
	;						   FOLLOWS

	;						2. THERE IS AN ID>
	;						<THEN THE 2ND NUMBER>/

	;	NUMBF2		ASCIZ/-<NUMBER>:/ FOR REDUNDANCY
	;			CHECK.

	;		
	;	ID.		ID.-1 CONTAINS 5 TABS, AND ID. CONTAINS
			;	A TAB, THE THREE CHAR ID. SPECIFIED
			;	AND A NULL TO MAKE IT ASCIZ.  SLIPO, BY
			;	BY KEEPING TRACK OF THE NUMBER OF CHARACTERS
			; 	ON THE CORRECTION LINE, KNOWS WHETHER 5 OR
			;	SIX TABS ARE NEED TO SPACE OUT THE ID. OK.

	; CHARACTERS OTHERWISE ARE TAKEN OUT OF THE COMPAR BUFFERS
	; ACCORDING TO HOW MANY LINES OF DISCREPANCY EXIST, ETC.

SLIPO:	MOVE	C+4,[POINT 7,NUMBUF-1,35]	
	MOVEM	PP,SAVEPP	; SAVE COMPAR'S PDP
	HRRZI	PP,SAVEXS	; AND ITS REGS
	BLT 	PP,SAVEXS+16
	MOVEI	C,"-"		; SINCE THERE IS A CORRECTION A - IS NEEDED
	MOVEI	C+3,0		; C+3 HOLDS CHARACTERS IN NUMBUF
	SETZM	NUMBUF
	SETZM	NUMBUF+1
	SETZM	NUMBUF+2	; ENSURE ASCIZ
	IDPB	C,C+4		; PUT IN THE -
	AOJ	C+3,		; AND ACCOUNT FOR IT
	MOVE	C+1,LINEN0	; GET LINE # FOR COMPUTATION
	JUMPLE 	F1,HM1		; NO LINES IN BASE BUFF MEANS INSERTION
	SUB	C+1,TOP1	;  INSERTION DELETION TO BE FORMULATED
	ADDI	C+1,2		; 1ST # IS ALWAYS LINE #-TOP1+2
	JSP	15,NCON		; MAKE THE INTEGER ASCII
	MOVE	C+1,[POINT 7,C+1,35]
	ILDB	C,C+1		; DRAG THE CHARS OUT OF REG C+2
	JUMPE	C,NXNO.		; SUPPRESS NULLS
	AOJ	C+3,		; ACCOUNT FOR EACH CHAR
	IDPB	C,C+4		; AND PUT IN BUFFER
	JRST	.-4		; UNTIL DONE
NXNO.:	MOVEI	C,","		; INSERTION DELETION NEEDS A ,
	IDPB	C,C+4		; SO PUT IT IN
	AOJ	C+3,		; AND ACCOUNT FOR IT
	JUMPGE	W1,NOTMT	; IF W1 IS GTR 0, BOTH FILES NOT AT EOF
	MOVE	C+1,LINEN0	; IF THEY ARE AT EOF,
	MOVEM	C+1,SAVNO	; SAVE CURRENT LINEN O
	ADDI	C+1,2		; THE SECOND # MUST BE LINE #+2
	JRST	CONV		; MAKE IT APPEAR IN THE BUFFER
NOTMT:	MOVE	C+1,LINEN0	; GET THBER


	; IF THE LINE # HAS NOT CHANGED SINCE THE LAST CORRECTION,
	; NO NEW LINES HAVE BEEN READ IN.  THIS IMPLIES THAT
	; THE CONTENTS OF THE BUFFERS HAVE SEVERAL MATCHING LINES
	; AND THE COMPARISON ALGORITHM IS CRUNCHING THROUGH AND
	; FINDING THEM.  WHEN THIS OCCURS, IT IS NECESSARY TO USE
	; A DIFFERENT FORMULA TO COMPUTE LINENO'S (IT TOOK A LONG
	; TIME TO DEDUCE THE DIFFERENT FORMULA) TO PRODUCE CORRECT
	; CORRECTIONS.

	CAMN	C+1,SAVNO	; HAVE ANY NEW LINES BEEN INPUT?
	JRST	CO		; NO, GO USE OTHER FORMULA
	MOVE	TT,TOP2		; YES


	; IF THERE ARE ACTUALLY MORE LINES IN ONE BUFFER THAN IN
	; THE OTHER, MORE FOOLING AROUND IS NECESSARY

	CAML	TT,TOP1		; MORE LINES IN USER BUFF THAN IN BASE BUFF?
	JRST	CO		; YES, GO USE THE OTHER FORMULA
	JRST	OKOK		; OTHERWISE USE USUAL FORMULA
OKOK:	MOVEM	C+1,SAVNO	; SAVE THIS # IN CASE IT APPEARS ENCORE
	SOJ	C+1,		; PROPER FORMULA IS CURRENT #-1
	JRST	CONV		; MAKE IT APPEAR IN NUMBUF
CO:	MOVEM	C+1,SAVNO	; START OF OTHER FORMULA
	SUB	C+1,TOP1
	ADD	C+1,F1
	AOJA	C+1,CONV	; WHICH IS #-TOP1+F1+1 (I DON'T KNOW WHY EITHER)
LASNUM:
CONV:	MOVEM	C+1,SAVNO2
	AOS	SAVNO2		; FOR RED. CHECK, USE COMPUTED #+1
	JSP	15,NCON
	MOVE	C+1,[POINT 7,C+1,35]
	ILDB	C,C+1
	JUMPE	C,NUMFI
	AOJ	C+3,
	IDPB	C,C+4		; PUT THE ASCII IN THE BUFFER
	JRST	.-4
NUMFI:	SETZM	LINCNT		; NOW DETERMINE HOW MANY TEXT LINES
	MOVEI	C,","		; ASSUME THERE IS AN ID
	SKIPE	ID.		; ID. IS NON ZERO IF THERE IS ONE
	IDPB	C,C+4		; PUT IN ANOTHER ,
	CAIL	C+3,8		; ALREADY MORE THAN 8 CHARS ON LINE?
	IBP	PTRS.+1		; YES, SO ALLOW ONLY 5 TABS
	HRRZ	C,LBUFP2
	JUMPG	W1,.+2		; SKIPE IF EOF NOT TRUE
	AOS	LINCNT
	ADDM	F2,LINCNT	; NUMBER OF TEXT LINES IS F2
	HRLI	C,(POINT 7,0,35)
	MOVEM	C,PTRS.+3	; MAKE POINTER POINT TO FIRST LINE
	MOVE	C+4,[POINT 7,NUMBF2-1,35]
	SETZM	NUMBF2
	SETZM	NUMBF2+1
	MOVEI	C,"-"		; NOW INSERT REDUNDANCY INFO
	IDPB	C,C+4		; INTO NUMBF2
	MOVE	C+1,SAVNO2
	JSP	15,NCON
	MOVE	C+1,[POINT 7,C+1,35]
	ILDB	C,C+1
	JUMPE	C,RDON
	IDPB	C,C+4
	JRST	.-3
RDON:	MOVEI	C,":"
	IDPB	C,C+4
	JRST	COMRE		; GO TO CBGET
HM1:	MOVEM	C+1,SAVNO
	JUMPL	W1,FIXUP
	SUB	C+1,TOP1	; FOR INSERTION ONLY
	AOJA	C+1,LASNUM
FIXUP:	ADDI	C+1,2
	SKIPGE	TOP1		; ANY LINES IN BASE BUFFER?
	JRST	LASNUM		; THEN THIS CAN'T BE A DELETE!
	JSP	15,NCON
	AOS	CRPERR		; IF EOF AND INSERTION, NO RED. AFTER
	MOVE	C+1,[POINT 7,C+1,35]
	ILDB	C,C+1
	JUMPE	C,NUMFI1
	AOJ	C+3,0
	IDPB	C,C+4
	JRST	.-4
NUMFI1:	MOVEI	C,","
	IDPB	C,C+4
	AOJ	C+3,
	MOVE	C+1,LINEN0
	ADDI	C+1,2		; MAKE SURE THIS SPECIAL CASE IS TREATED
	JRST	LASNUM		; PROPERLY



	EXTERN	BSPEC,USPEC,BADDB,USDDB,NOTFND,NOTAV.,IOERR
	EXTERN	SAVACS,USEIPT,BASIPT
	EXTERN	STATE.,COMPOP,SAVAC2,NUMBUF,ID.,ID.CNT,LINCNT
	EXTERN	SAVEPP,PTRS.,SAVEXS,NUMBF2,CRLFBF
FR=7
PP=17
C=10




	; UIN AND BIN GET CHARS FROM USER AND BASE FILES
	; RESPECTIVELY.  THEY WORK THE SAME AS UCIN AND
	; MCIN EXCEPT AT EOF, THE SET BITS IN FR TO SO
	; INDICATE. THEIR DDB'S ARE FILLED BY CAMCTL WHEN
	; FULLY AUTOMATED PROCESSING IS DESIRED. PROGRAM
	; FLOW IS AS FOLLOWS:

	; HUMANS CALL CAM
	; CAM CALLS COMERG OR CBGET
	; COMERG CALLS CBGET
	; CBGET CALLS COMPAR
	; COMPAR RETURNS TO CBGET
	; AND CBGET RETURNS TO USER, AND UNWINDING PROCEEDS
	; FROM THERE.

UIN:	SKIPL	USDDB+6	
	JRST	OPENUS
USX:	SOSG	USEIPT+2
	JRST	FILLUS
USXX:	ILDB	C,USEIPT+1
	JUMPE	C,USX
	JRST	(11)
FILLUS:	IN	USCHAN,
	JRST	USXX
	GETSTS	USCHAN,C
	TRNE	C,20000
	JRST	NULLUS
	PUSHJ	16,IOERR
	XWD	[ASCIZ/?USERS FILE READ/],USDDB
	JRST	FILLUS
NULLUS:	MOVEI	C,0
	TLO	FR,@EOFTBL(FR)
	JRST	(11)
OPENUS:	SKIPE	USDDB+6
	JRST 	NEWUS
	MOVE	C,USDDB
INITUS:	MOVEM	C,USPEC+1
	OPEN	USCHAN,USPEC
	JRST 	USERR1
	AOS	USDDB+6
NEWUS:	HRRZI	C,SAVACS
	BLT	C,SAVACS+3
	HRLZI	C,USDDB+2
	BLT	C,3
	LOOKUP 	USCHAN,0
	JRST	USERR2
	HRLZI	C,SAVACS
	BLT	C,3
	SETOM	USDDB+6
	INPUT	USCHAN,
	JRST	USXX
USERR1:	PUSHJ	16,NOTAV.
	XWD	[ASCIZ/?USERS FILE/],USDDB
	JRST	INITUS-1
USERR2:	PUSHJ	16,NOTFND
	XWD	[ASCIZ/?CANNOT FIND USERS FILE FILE /],USDDB
	JRST	NEWUS
BIN:	SKIPL	BADDB+6
	JRST	OPENBA
BAX:	SOSG	BASIPT+2
	JRST	FILLBA
BAXX:	ILDB	C,BASIPT+1
	JUMPE	C,BAX
	JRST	(11)
FILLBA:	IN	BACHAN,
	JRST	BAXX
	GETSTS	BACHAN,C
	TRNE	C,20000
	JRST	NULLBA
	PUSHJ	16,IOERR
	XWD	[ASCIZ/?BASE READ/],BADDB
	JRST	FILLBA
NULLBA:	MOVEI	C,0
	TLO	FR,@EOFTBL(FR)
	JRST	(11)
OPENBA:	SKIPE	BADDB+6
	JRST 	NEWBA
	MOVE	C,BADDB
INITBA:	MOVEM	C,BSPEC+1
	OPEN	BACHAN,BSPEC
	JRST 	BAERR1
	AOS	BADDB+6
NEWBA:	HRRZI	C,SAVACS
	BLT	C,SAVACS+3
	HRLZI	C,BADDB+2
	BLT	C,3
	LOOKUP 	BACHAN,0
	JRST	BAERR2
	HRLZI	C,SAVACS
	BLT	C,3
	SETOM	BADDB+6
	INPUT	BACHAN,
	JRST	BAXX
BAERR1:	PUSHJ	16,NOTAV.
	XWD	[ASCIZ/?BASE/],BADDB
	JRST	INITBA-1
BAERR2:	PUSHJ	16,NOTFND
	XWD	[ASCIZ/?CANNOT FIND BASE FILE /],BADDB
	JRST	NEWBA
C=13




	; CBGET IS A MASTER ROUTINE CALLED ELSEWHERE.  IT IS 
	; CALLED BY A PUSHJ 16,CBGET AND IT RETURNS
	; WITH ONE OF THREE THINGS IN REGISTER 13.  ONE, IT
	; CAN HAVE THE FIRST CHARACTER OF A CORRECTION COMMAND,
	; OR SINGLE CHARACTERS FROM SUCH A COMMAND.  TWO, 13
	; CAN CONTAIN -1 IF NO MORE CORRECTIONS CAN BE SQUEZZED
	; FROM THE INPUT FILES.  THREE, IT WILL CONTAIN 0 IF
	; COMPAR RAN OUT OF ROOM AND SMOTHERED IN TEXT.

	; THE VARIABLE STATE. POINTS TO THE CURRENT ACTIVITY
	; WHICH CBGET IS TRYING TO PUMP CHARACTERS FROM. THE
	; VALUE OF STATE IS USED AS AN INDEX INTO CBACT TO TELL
	; IT WHAT TO DO.  ESSENTIALLY, IT GETS CHARACTERS FROM
	; ASCIZ STRINGS POINTED TO BY ENTRIES IN THE
	; POINTER TABLE. WHEN IT HEARS A NULL, IT ADVANCES THE
	; STATE. ONE TO EXTRACT THE NEXT THING. WHEN THERE ARE
	; NO MORE ACTIONS LEFT TO PERFORM, IT CALLS COMPAR TO GET
	; MORE STRINGS AND SETS STATE. TO ONE, WHEREUPON IT RECYCLES.




CBGET:	MOVE	C,STATE.	; PICK UP THE STATE.
	MOVEM	16,SAVE16	; SAVE PDP THAT GOT US HERE
	JRST	@CBACT(C)	; NOW GET THE CHARACTER
STCOMP:	SETZM	STATE.		; STATE 0 MEANS START COMPAR
	AOS	COMPOP
	AOS	STATE.
	MOVEM	SAVAC2
	MOVE	[XWD	1,SAVAC2+1]
	BLT	SAVAC2+17	; SAVE USER'S REGS
	JRST	COMPAR		; AND DO WORK
NUMGT:	ILDB	C,PTRS.		; STATE 1, GET # ON CORR.LINE
	JUMPN	C,CBRTN
	MOVE	C,[POINT 7,NUMBUF-1,35]
	MOVEM	C,PTRS.		; IF A NULL HEARD,RESET POINTER
	AOS	C,STATE.	; INCREMENT THE STATE
IDGET:	SKIPE	ID.		; IS THERE AN ID (STATE 2)
	JRST	ID.IS		; YES, NEX T CHAR COMES FROM THERE
	AOS	C,STATE.	; OTHERWISE CHANGE GEARS
	JRST	CRLFF		; AND OUTPUT A CR-LF
ID.IS:	ILDB	C,PTRS.+1
	JUMPN	C,CBRTN
	MOVE	C,[POINT 7,ID.-2,35]
	MOVEM	C,PTRS.+1	; RESET POINTER TO ID
	AOS	C,STATE.
CRLFF:	ILDB	C,PTRS.+2	; FEED CALLER CR-LF NOW TO END LINE
	JUMPN	C,CBRTN
	MOVE	C,[POINT 7,CRLFBF-1,35]
	MOVEM	C,PTRS.+2	; RESET POINTER
	AOS	C,STATE.
TXTGET:	SOSGE	LINCNT		; ANY LINES OF TEXT TO GO?
	JRST	REDNCK		; NO, HOW ABOUT A REDUNDANCY  CHECK?
	AOS	C,STATE.	; THERE IS TEXT
TXT2:	ILDB	C,PTRS.+3	; GET THE TEXT
	JUMPN	C,CBRTN
	HRLI	C,(POINT 7,0,35)
	HRR	C,PTRS.+3	; NULL IS END OF ONE LINE;
	AOJ	C,		; MAKE POINTER POINT TO NEXT LINE
	MOVEM	C,PTRS.+3
	SOS	STATE.		; THEN MAKE STATE CHECK IF ENOUGH LINES OUTPUTT
	JRST	TXTGET		; AND ACTUALLY BOOKKEEP
REDNCK:	SOSG	CRPERR		; TIME FOR A CHECK LINE?
	JRST	REDNFX		; YUP
	SETZM	STATE.		; DUKE SAYS NOPE
	AOS	STATE.
	MOVEM	SAVAC2
	MOVE	[XWD 1,SAVAC2+1]
	BLT	SAVAC2+17	; SAVE USER'S REGS
	HRLZI	17,SAVEXS	; RESTORE COMPARS REGS
	BLT	17,16
	MOVE	PP,SAVEPP
	POPJ	PP,		; AND POP BACK TO COMPAR
REDNFX:	AOS	C,STATE.	; FIX UP STATE.
	AOS	C,STATE.
	MOVEI	C,5
	MOVEM	C,CRPERR	; AND RESTORE MODULUS COUNTER
REDNF:	ILDB	C,PTRS.+4	; GET -NUMBER:
	JUMPN	C,CBRTN
	MOVE	C,[POINT 7,NUMBF2-1,35]
	MOVEM	C,PTRS.+4
	AOS	C,STATE.
REDTXT:	ILDB	C,PTRS.+3	; NOW GET TEXT FROM COMPAR BUFF
	CAIL	C,37
	JUMPN	C,CBRTN
	CAIN	C,CR		; DON'T OUTPUT FEEDS
	JRST	CBRTN
	CAIN	C,LF
	JRST	NXT8
	CAIN	C,FF
	JRST	NXT8
	CAIN	C,VT
	JRST	NXT8
	JUMPN	C,CBRTN
NXT8:	AOS	STATE.
RDCRLF:	ILDB	C,PTRS.+2	; NOW A CRLF
	JUMPN	C,CBRTN
	MOVE	C,[POINT 7,CRLFBF-1,35]
	MOVEM	C,PTRS.+2
	SETZM	STATE.
	AOS	STATE.
	MOVEM	SAVAC2
	MOVE	[XWD 1,SAVAC2+1]
	BLT	SAVAC2+17
	HRLZI	17,SAVEXS
	BLT	17,16
	MOVE	17,SAVEPP
	POPJ	17,		; ALL OVER!! GO BACK TO COMPAR FOR MORE
COMRE:
	HRLZI	17,SAVAC2
	BLT	17,15+1
	MOVE	17,SAVAC2+17	; INCLUDING HIS 17
	JRST	NUMGT		; RETURN FROM COMPAR: GET USER'S REGS BACKK



CBACT:	STCOMP
	NUMGT
	IDGET
	CRLFF
	TXTGET
	TXT2
	REDNF
	REDTXT
	RDCRLF
CBRTN:	MOVE	16,SAVE16	; GO BACK TO CALLER
	POPJ	16,		; VIA A POPJ
	END	;   THAT'S ALL FOLKS
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        m@me