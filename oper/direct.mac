	TITLE	DIRECT -- DIRECTORY LISTING CUSP  -- %3(152)
	SUBTTL	P.CONKLIN/PFC		29-OCT-72


;***COPYRIGHT 1970, 1971, 1972  DIGITAL EQUIPMENT CORP., MAYNARD, MASS.***


CUSTVR==0		;CUSTOMER VERSION
DECVER==3		;DEC VERSION
DECMVR==0		;DEC MINOR VERSION
DECEVR==152		;DEC EDIT VERSION


;ASSEMBLY INSTRUCTIONS:
;
;ASSUMING SOME PARAMETERS ARE TO BE CHANGED, DEFINE THEM IN A FILE
;NAMED "PARAM.MAC".  THEN LOAD AND SAVE AS FOLLOWS:
;
;	.LOAD  C+PARAM+SCNMAC+DIRECT,SCAN,HELPER,WILD
;	.SSAVE DIRECT

	IF1,<..==%%C+%%SCNM>
	IFNDEF	..,<
	PRINTX	?	.COMPILE  C+SCNMAC+DIRECT,SCAN,HELPER,WILD
	PASS2
	END>
	IF2,<PURGE ..>
;ASSEMBLY PARAMETERS

ND LN.PDL,50		;LENGTH OF PUSH-DOWN LIST
ND LN.LPP,^D50		;LINES PER PAGE OF DATA
ND LN.RIB,41		;LENGTH OF DIRECTORY LOOKUP BLOCK
ND PURESW,1		;1=REENTRANT VERSION 
ND NDSKBF,^D10		;NUMBER OF DISK BUFFERS FOR INPUT
ND FTDIAL,0		;1=DIALOGUE MODE AVAILABLE
ND LN.DRB,6		;LENGTH OF SFD NESTING
ND FTSFD,-1		;SFD FEATURES

IFLE LN.DRB-1,<FTSFD==0
		LN.DRB==1>

	RADIX	10
DM ACC,100000,0,5
DM FIL,100000,0,1
DM WID,200,0,64
	RADIX	8


IFL LN.RIB-41,<PRINTX ? RIB BLOCK TOO SMALL FOR FAILSAFE>
	SUBTTL	REVISION HISTORY

;%1 -- 6/71 WITH 5.03 MONITOR

;A)  REARRANGE TO USE SCAN.MAC AND ELIMINATE THE
;	BUILT IN SCANNER.  THIS GIVES INDIRECT FILES AND ALL
;	THE SCAN IMPROVEMENTS OVER SCANER.
;B)  EXPAND TOTAL LINE TO INCLUDE NUMBER OF LOOKUP FAILURES
;C)  FIX BUG ASSOCIATED WITH SYS: AND + UNDER 5.03
;D)  EXPAND TO HANDLE SUB-FILE DIRECTORIES.
;E)  REARRANGE TO USE REVAMPED LOKWLD (WILD)
;F)  IN /SORT, GIVE DATES AS " YYYYMMDD"
;G)  IN /SORT, LIST DIRECTORY IF AND ONLY IF THE REQUEST HAS
;	WILD CARDS IN THE DIRECTORY
;H)  IN /WIDTH, LIST STR OR DIRECTORY AS A SEPARATE LINE
;I)  IN /SORT, LIST STR IF AND ONLY IF DSK OR WILDCARDS
;J)  CHANGE DTA TO USE 300 MODE
;K)  ADD SWITCH /WORDS TO PRINT DISK LENGTHS IN WORDS NOT BLOCKS
;L)  IF MAG TAPE, INTERPRET FAILSAFE TAPE AS DISK DIRECTORY
;M)  OUTPUT VERSION IN FRONT OF STRUCTURE AND DIRECTORY
;N)  OUTPUT SPOOLED NAME (IF NON-ZERO) AT RIGHT END
;O)  /F/SUM WILL GIVE FAST LIST PLUS A SUMMARY
;P)  ADD FREE SPACE TO TMP: DIRECTORY
;Q)  /DETAIL WILL GIVE A LISTING LIKE LOOKFL DID (IE, ALL INTERESTING
;	ITEMS FROM THE EXTENDED LOOKUP
;R)  SUPPORT /DENSITY, /PROTECT, /PARITY SWITCHES FROM SCAN
;S)  DETECT ANSI-LIKE LABELS AND BACKUP TAPES
;T)  CORRECT A BUG WHICH GAVE EXTRA NON-EX. MESSAGES
;U)  ADD SUBTOTALS FOR EACH DIRECTORY AND STRUCTURE
;V)  INCLUDE CHECKSUM IN TOTALS
;W)  SUPPORT /BEFORE AND /SINCE
;X)  ADD /MARKS
;Y)  HANDLE + ON MTA, DTA, TMPCOR
;Z)  USE VERSION FROM RIB IF PRESENT.  IN /DETAIL, GIVE BOTH IF
;	DIFFERENT.
;AA)  REMOVE 'UFD' IN REGULAR LISTING SO COLUMNS LINE UP.
;AB)  USE 317 MODE ON DECTAPES.
;AC)  EXPAND ALL TABS IN /SORT MODE
;AD)  FIX TYPE/LIST LOGIC TO NOT TYPE TITLES, OR DOUBLE TYPE SUMMARIES.
;AE)  FIX BUG TO CORRECTLY SUPPRESS TRAILING TABS.
;%2(125) -- 5/72 WITH SCAN AND WILD

;126	(7613) LIST DIRECTORIES IF WILD AND /SORT
;127	MOVE SWITCHES AIMED AT F TO WORD FLAGS FOR SCAN %3
;	ALSO MOVE S.LODV AND S.TITL TO S.MIN AREA.
;130	CALL .OSCAN TO IMPLEMENT USER OPTIONS
;	ALSO ADD /NORMAL TO OVERRIDE /FAST IN OPTIONS FILE
;131	(8314) SUMMARY OF LOOKUP ERRORS WAS PREMATURE
;132	(8280) DIRECTORY CHECKSUMS WERE INCORRECT IN SUMMARY
;133	(QAR 149) NEEDED 3 EOFS TO END MAG TAPE
;134	(7635) CORRECT MAG TAPE SUB-TOTALS TO COME AT RIGHT TIME
;135	HANDLE FILE NOT MATCHING ON MAG TAPE
;136	OUTPUT RIB INTERNAL FORMAT CREATION TIME IN HUMAN TERMS
;137	(7613) IF /SORT, LIST DIRECTORIES AS 2*6 DIGITS
;140	CORRECT FORMATTING ERROR IN FIXED FORMAT OCTAL 7.
;141	ADD /NOREWIND, /NOEOT, /FILES:N  (QAR 177)
;142	FIX /MARKS TO INDICATE LAST EOF AS WELL (IE, EOT)
;143	CORRECT NULL DEVICE BUG INTRODUCED BY 127.
;144	CORRECT INF.0 BUG INTRODUCED BY 140.
;145	RESTORE .JBFF EACH OPEN. ALSO USE 10. BUFFER RING ON DISK INPUT
;146	ADD /NOSUMMARY, /NODETAIL, AND /NOUNITS.
;147	IF /DETAIL/SUMMARY, DO BOTH. IF /NOSUM NEVER GIVE ONE. IF
;	/NOUNITS, ALWAYS GIVE STR.
;150	IF /SORT, ALLOCATE 15 COLUMNS FOR VERSION
;151	/SORT OF MTA FAILED TO INCLUDE STRUCTURE
;152	IF /SUM, ALWAYS INCLUDE SUMMARIES
SUBTTL	STANDARD MNEMONICS--REGISTERS, BITS, UUOS

;AC NAMES

F=0		;FLAGS (LH=PERMANENT, RH=TEMPORARY)
T1=1		;TEMPORARIES
T2=2
T3=3
T4=4

P1=5		;PRESERVED
P2=6
P3=7
P4=10

I=11		;GENERAL INDEX REGISTERS
J=12

C=14		;TEMP DEFS FOR LISTING ROUTINES
N=15
M=16
P=17		;PUSH-DOWN POINTER

;I/O CHANNELS

DC==1		;READ DATA FILE
LC==2		;OUTPUT (DIRECTORY LISTING)
;FLAGS (LH)

L.SVST==(1B0)	;SAVE SET FLAG FOR MT UNTANGLING
L.FKEF==(1B1)	;FAKE EOF TO TRICK DISK CODE
L.BKSS==(1B2)	;BACKUP STYLE SAVE SET
L.SVDW==(1B3)	;SAVED WORD IN INPUT AREA
L.LEVD==(1B4)	;THIS DATA CAME FROM LEVEL-D OR MORE
L.ILEN==(1B5)	;INCORRECT LENGTH
L.IMLB==(1B6)	;IMBEDDED LABEL

;FLAGS (RH)

R.MARK==1B29	;SET IF /MARK SWITCH (IE, LIST TAPE MARKS)
R.LTAB==1B28	;SET IF TAB TO BE LISTED NEXT
R.LPTB==1B27	;LPT BUSY--WAITING
R.OUTO==1B26	;OUTPUT DEVICE OPEN AND IT IS OUR TTY:
R.FAST==1B25	;FAST FORMAT  --THIS ORDER REQUIRED
R.SLOW==1B24	;SLOW FORMAT  --DO NOT MOVE OR INTERCHANGE
R.OUTL==1B23	;FORCE OUTPUT AFTER EACH LINE
R.OUTD==1B22	;OUTPUT DEVICE INITTED
R.LSOM==1B21	;SOME OUTPUT SENT
R.ACCS==1B20	;FORCE A FILE ACCESS
R.TYPE==1B19	;FORCE TYPEOUT AS WELL AS LISTING
R.WORD==1B18	;QUANTITIES ARE IN WORDS NOT BLOCKS
;DEFINE LOCAL NAME OF LOCATIONS WITHIN THE RIB

.RBXTR==36	;DUMMY LENGTH FOR EXCESS RIB WORDS

IF2,<		;ONLY PASS 2 SINCE LOCATION OF LOOKUP BLOCK DEFINED AT END

	DEFINE DR(A,B),<
IFL .RB'B-LN.RIB,<A=LBLOCK+.RB'B>
>
	DEFINE DQ(A),<DR (F'A,A)>

DR RIBLEN,CNT;	BLOCK LENGTH
DR UFDPPN,PPN;	PROJECT-PROGRAMMER NUMBER OR POINTER TO DIRECTORY
DQ NAM;	FILE NAME
DQ EXT;	FILE EXTENSION
DR FCRE,PRV;	PROTECTION, CREATION, ETC.
DR FLEN,SIZ;	FILE LENGTH
DQ VER;	VERSION
DQ SPL;	SPOOLED NAME
DQ EST;	ESTIMATED LENGTH
DQ ALC;	ALLOCATED LENGTH
DQ POS;	POSITION ALLOCATED
DQ FT1;	DEC NON-PRIV FUTURE
DQ NCA;	CUSTOMER NON-PRIV
DQ MTA;	BACKUP TAPE
DQ DEV;	LOGICAL UNIT
DQ STS;	FILE STATUS BITS
DQ ELB;	ERROR LOGICAL BLOCK
DQ EUN;	ERROR UNIT AND LENGTH
DQ QTF;	FCFS QUOTA
DQ QTO;	LOGGED OUT QUOTA
DQ QTR;	RESERVED QUOTA
DQ USD;	BLOCK IN USE
DQ AUT;	AUTHOR
DQ NXT;	CONTINUED STR
DQ PRD;	PREVIOUS STR
DQ PCA;	PRIV CUSTOMER ARG
DQ UFD;	POINTER BACK TO UFD
DQ FLR; RELATIVE BLOCK IN FILE COVERED BY THIS RIB
DQ XRA; POINTER TO NEXT RIB IN CHAIN
DQ TIM; CREATION DATE,,TIME IN INTERNAL FORMAT
DQ XTR;	EXTRA RIB WORDS START HERE

>	;END IF2
;N.FAIL <FOO> SENDS FOO AS A FATAL ERROR

DEFINE	N.FAIL (A),<
	PJSP	T1,[PUSHJ P,.TERRP##
	JRST	LFERX]
	XLIST
	ASCIZ	\A\
	LIST
>

;N.FAIN <FOO> SENDS FOO AS A FATAL ERROR WITH N IN SIXBIT

DEFINE	N.FAIN (A),<
	PJSP	T1,[PUSHJ P,.TERRP##
	MOVE	T1,P3
	PUSHJ	P,.TSIXN##
	JRST	LFERX]
	XLIST
	ASCIZ	\A\
	LIST
>

;N.FAID <FOO> SENDS FOO AS A FATAL ERROR WITH N IN DECIMAL

DEFINE	N.FAID (A) <
	PJSP	T1,[PUSHJ P,.TERRP##
	MOVE	T1,P3
	PUSHJ	P,.TDECW##
	JRST	LFERX]
	XLIST
	ASCIZ	\A\
	LIST	
>

;N.FAIO <FOO> SENDS FOO AS A FATAL ERROR WITH N IN OCTAL

DEFINE	N.FAIO (A),<
	PJSP	T1,[PUSHJ P,.TERRP##
	MOVE	T1,P3
	PUSHJ	P,.TOCTW##
	JRST	LFERX]
	XLIST
	ASCIZ	\A\
	LIST
>
;COMMUNICATION WITH SCAN

	EXTERN	.ISCAN,.TSCAN
	EXTERN	.TCHAR,.TCRLF,.TDECW,.TOCTW,.TSIXN,.TSTRG
	EXTERN	.POPJ,.POPJ1,.SWDEC


;COMMUNICATION WITH WILD

	INTERN	.TNEWL
	EXTERN	.LKWLD,.NXDTW,E.DFO,.LKERR,.WLDFL

;JOB DATA LOCATIONS OF INTEREST

	LOC	137
.JBVER:	BYTE	(3)CUSTVR(9)DECVER(6)DECMVR(18)DECEVR
	RELOC




	IFN	PURESW,<TWOSEG
			RELOC	400000>
SUBTTL	INITIALIZE

;HERE AFTER START OR RUN OR DIRECTORY COMMAND OR RUN UUO

DIRECT:	TDZA	T1,T1		;CLEAR OFFSET
	MOVEI	T1,1		;SET OFFSET
	MOVEM	T1,OFFSET	;STORE IT

	RESET			;RESET ANY EXTERNAL I/O
	SETZM	ZCOR		;CLEAR CORE
	MOVE	T1,[ZCOR,,ZCOR+1]
	BLT	T1,EZCOR
	MOVE	P,[IOWD LN.PDL,PDLST]	;ESTABLISH PUSH-DOWN LIST

	GETPPN	T1,		;DETERMINE THIS JOB'S PPN
	  JFCL			;(IN CASE OF JACCT)
	MOVEM	T1,MYPPN	;SAVE FOR THE FUTURE

	MOVE	T1,[ 3,,[IOWD  1,['DIRECT']
			OFFSET,,'DIR'
			0,,TCHR]]
	PUSHJ	P,.ISCAN	;INITIALIZE COMMAND SCANNER

	MOVE	T1,.JBFF##	;SAVE ORIGINAL VALUE
	MOVEM	T1,ORGFF	; OF .JBFF
SUBTTL	MAIN LOOP FOR COMMAND SCANNING

MAINLP:	MOVE	P,[IOWD LN.PDL,PDLST]
	MOVE	T1,[ 6,,[IOWD DRSWTL,DRSWTN
			DRSWTD,,DRSWTM
			0,,DRSWTP
			-1
			CLANS,,0
			AIN,,AOUT]]
	PUSHJ	P,.TSCAN	;GET THE COMMAND
	MOVE	T1,[ 4,,[IOWD DRSWTL,DRSWTN
			DRSWTD,,DRSWTM
			0,,DRSWTP
			-1]]
	PUSHJ	P,.OSCAN##	;SCAN USER OPTIONS
	MOVE	F,FLAGS		;GET INITIAL FLAGS
	JRST	DEFAUL		;GO FILL IN DEFAULTS


;SUBROUTINE TO CLEAR ANSWER AREA

CLANS:	SETZM	S.ZER		;ZERO OUT COMMAND ACCUMULATORS
	MOVE	T1,[S.ZER,,S.ZER+1]
	BLT	T1,S.EZER
	SETOM	S.MIN		;PRESET SWITCH PARAMETERS
	MOVE	T1,[S.MIN,,S.MIN+1]
	BLT	T1,S.EMIN
	MOVEI	T1,I.ZER	;PRESET START OF PARAMS
	MOVEM	T1,I.INZR	; FOR LOKWLD
	SETZM	I.NXZR		; AND FOR SCANING
	CLOSE	LC,CL.ACS!CL.DAT  ;TERMINATE LISTING IF OPEN
	RELEAS	LC,		;  IN CASE OF ERROR RESTART
	SETZM	B.LC+1		;SET FLAG FOR LISTING CLOSED
	TRZ	F,-1		;CLEAR ALL LOCAL FLAGS
	MOVE	T1,ORGFF	;RESTORE ORIGINAL VALUE
	MOVEM	T1,.JBFF##	; OF .JBFF
	POPJ	P,		;RETURN
;SUBROUTINE TO ALLOCATE OUTPUT FILE AREA

AOUT:	MOVEI	T1,O.ZER	;POINT TO IT
	MOVEI	T2,O.LZER	;AND LENGTH
	POPJ	P,		;AND RETURN

;SUBROUTINE TO ALLOCATE INPUT FILE AREA

AIN:	MOVEI	T1,I.LZER	;ADVANCE ALLOCATION
	SKIPN	I.NXZR		;SEE IF STARTED YET
	MOVE	T1,I.INZR	;NO--START AT BEGINNING
	ADDB	T1,I.NXZR	;AND STORE NEW VALUE
	CAIL	T1,I.EZER	;SEE IF TOO BIG
	JRST	E.TMI		;YES--ERROR
	MOVEI	T2,I.LZER	;SET LENGTH
	POPJ	P,		;RETURN
SUBTTL	FILL IN DEFAULTS AFTER COMMAND SCANNING

;HERE AT END OF COMMAND -- SUPPLY ABSENT FILE DEFAULTS

DEFAUL:	MOVSI	T1,'TTY'	;DEFAULT OUTPUT DEVICE
	SKIPLE	S.DODV		;SEE IF /L SWITCH
	MOVSI	T1,'LPT'	;YES--CHANGE DEFAULT
	SKIPN	O.DEV
	MOVEM	T1,O.DEV
	HRLOI	T1,'DIR'	;DEFAULT OUTPUT EXTENSION
	SKIPN	O.EXT
	MOVEM	T1,O.EXT

	SKIPN	O.NAM
	SETOM	O.NAMM
	MOVX	T1,FX.DIR	;SEE IF DIRECTORY
	TDNN	T1,O.PROT	; SPECIFIED
	SETOM	O.DIRM
	TDNN	T1,O.PROT	;CHECK AGAIN
	JRST	DEFAU1		;ABSENT--LEAVE ALONE
	MOVE	T1,O.DIR	;PRESENT--CHECK DEFAULTS
	MOVE	T2,MYPPN	;NO--GET DEFAULT UFD
	TLNN	T1,-1		;IF NULL PROJECT,
	HLLM	T2,O.DIR	;  FILL IN SELF
	TLNN	T1,-1		;  ..
	HRROS	O.DIRM		;  AND CLEAR WILD-CARD
	TRNN	T1,-1		;IF NULL PROGRAMMER,
	HRRM	T2,O.DIR	;  FILL IN SELF
	TRNN	T1,-1		;  ..
	HLLOS	O.DIRM		;  AND CLEAR WILD-CARD

DEFAU1:	MOVE	T2,O.DEV
	MOVE	T1,O.PROT	;GET PHYSICAL FLAG
	TXNN	T1,FX.PHY	;SEE IF /PHY
	DEVCHR	T2,
	TXNE	T1,FX.PHY	;SEE IF /PHY
	DEVCHR	T2,UU.PHY	;YES
	MOVX	T1,FX.PAR!FX.DEN
	TXNE	T2,DV.MTA	;SEE IF MAG TAPE
	ANDCAM	T1,O.PROT	;NO--CLEAR DENSITY AND PARITY
	TXNN	T2,DV.LPT	;SEE IF TYPE LPT
	JRST	DEFAU2		;NO--PROCEED
	TRNN	F,R.FAST!R.SLOW	;SEE IF ANY SPEED SWITCH
	TRO	F,R.SLOW	;NONE--SET TO SLOW MODE
	MOVEI	T1,1		;  (PRESET VALUE)
	SKIPGE	S.TITL		;  AND NO TITLE SWITCH
	MOVEM	T1,S.TITL	;YES--SET DEFAULT TITLE ON
DEFAU2:	SKIPN	O.NAM
	TXNN	T2,DV.DIR	;SEE IF FILE NAME NEEDED
	JRST	OUDEF2		;NO--GO ON
	MSTIME	T1,		;YES--MANUFACTURE NAME HHMMSS
	IDIVI	T1,^D1000	;GET SECONDS
	MOVE	T4,[POINT 6,O.NAM]	;SETUP BYTE POINTER
	MOVSI	T3,-6		;INITIALIZE LOOP COUNTER
OUDEF1:	IDIV	T1,[^D36000
		    ^D3600
		    ^D600
		    ^D60
		    ^D10
		    ^D1](T3)	;GET NEXT DIGIT
	ADDI	T1,'0'		;CONVERT TO SIXBIT DIGIT
	IDPB	T1,T4		;STORE INTO NAME
	MOVE	T1,T2		;RESTORE REMAINDER
	AOBJN	T3,OUDEF1	;LOOP
	MOVEI	T1,[ASCIZ /Directory listing on file /]
	PUSHJ	P,.TSTRG
	MOVE	T1,O.NAM	;GET NAME
	PUSHJ	P,.TSIXN
	PUSHJ	P,.TCRLF

OUDEF2:	SETOM	T1		;DON'T ALLOW WILDCARD OUTPUT FILE/DIRECTORY
	CAME	T1,O.NAMM
	JRST	E.WCO
	CAME	T1,O.DIRM
	JRST	E.WDO
	XOR	T1,O.EXT
	TRNE	T1,-1
	JRST	E.WXO
	SKIPN	O.DIR+2		;SEE IF LONG PATH
	SKIPE	O.DIRM+2	;  SPECIFIED BY USER
	JRST	E.PTO		;YES--ABORT
;HERE TO SUPPLY INPUT SIDE DEFAULTS

INDEF:	MOVE	T4,I.INZR	;INITIALIZE BLOCK POINTER

INDEF1:	MOVSI	T1,'DSK'	;FORCE DEFAULT DEVICE
	SKIPN	I.DEV(T4)	;SEE IF NEED IT
	MOVEM	T1,I.DEV(T4)	;YES--DO IT
	SKIPE	I.NAM(T4)	;SEE IF FILE NAME
	JRST	INDEF2		;YES--NO DEFAULT
	MOVSI	T1,'*  '	;NO--SET WILD DEFAULT
	CAME	T4,I.INZR	; FOR FIRST ONE
	MOVE	T1,I.NAM-I.LZER(T4)	;PREVIOUS FOR REST
	MOVEM	T1,I.NAM(T4)	;STORE IN ARRAY
	MOVEI	T1,0		;SET WILD MASK
	CAME	T4,I.INZR	; FOR FIRST ONE
	MOVE	T1,I.NAMM-I.LZER(T4)	;PREVIOUS FOR REST
	MOVEM	T1,I.NAMM(T4)	;STORE IN ARRAY
INDEF2:	MOVSI	T1,'*  '	;PRESET WILD EXTENSION
	SKIPN	I.EXT(T4)
	MOVEM	T1,I.EXT(T4)
	MOVX	T1,FX.STR	;SET MULTIPLE STR CODE
	TDNN	T1,I.MODM(T4)	;UNLESS USER HAS DEFEATED IT
	IORM	T1,I.MOD(T4)	;AND INCLUDE

	ADDI	T4,I.LZER	;ADVANCE POINTER
	CAMG	T4,I.NXZR	;SEE IF DONE YET
	JRST	INDEF1		;NO--LOOP BACK
;HERE TO SUPPLY DEFAULTS FOR GLOBAL SWITCHES

	SKIPLE	S.DTL		;SEE IF /DETAIL
	TRZ	F,R.FAST!R.SLOW  ;YES--CLEAR /FAST/SLOW
	SKIPGE	S.SORT		;IS SORT MODE SPECIFIED
	SETZM	S.SORT		;NO--CLEAR FLAG
	MOVEI	T1,AD.WID	;GET ABSENT WIDTH DEFAULT
	SKIPGE	S.WDTH		;SEE IF NEEDED
	MOVEM	T1,S.WDTH	;YES--SUPPLY IT
	MOVEI	T1,1
	SKIPGE	S.REWS		;SEE IF /NOREW
	MOVEM	T1,S.REWS	;NO--SET /REW
	SKIPGE	S.EOT		;SEE IF /NOEOT
	MOVEM	T1,S.EOT	;NO--SET /EOT


;HERE TO RUN OVER THE INPUTS, AND DO THE WORK

	SETZM	H.ZER		;CLEAR OUT SUMMARY AREA FOR OUTPUT
	MOVE	T1,[H.ZER,,H.ZER+1]
	BLT	T1,H.EZER
	SETOM	LNPP		;PRESET TO FORCE PAGE EJECT

	MOVE	T1,O.DEV	;GET OUTPUT DEVICE NAME
	DEVCHR	T1,		;GET ITS CHARACTERISTICS
	TRO	F,R.OUTD	;FLAG THAT OUTPUT IS ACTIVE
	TXNE	T1,DV.TTA	;SEE IF IT IS A CONSOLE
	TRO	F,R.OUTO	;YES--SET FLAG FOR TTY OUT ROUTINES

	TXNE	T1,<DV.LPT!DV.TTY>  ;SEE IF LINE MODE DEVICE
	TRO	F,R.OUTL	;YES--SET FLAG

	MOVE	T1,I.INZR	;INITIALIZE POINTER
	MOVEM	T1,I.NXRD	;  TO INTERP. COMMANDS
	PUSHJ	P,LCRLF		;SET DIRECTORIES OFF FROM COMMANDS
	MOVE	T1,.JBFF##	;SAVE INPUT 
	MOVEM	T1,SVJBFF	; .JBFF

ISLOOP:	PUSHJ	P,DIR		;GO DO A DIRECTORY
	MOVEI	T1,I.LZER	;ADVANCE TO NEXT REQUEST
	ADDB	T1,I.NXRD
	CAMG	T1,I.NXZR
	JRST	ISLOOP		;LOOP BACK

	CLOSE	LC,		;CLOSE OFF LISTING FILE
	STATZ	LC,IO.ERR	;SEE IF ANY ERROR
	  PUSHJ	P,LCHRWR	;YES--REPORT IT
	RELEAS	LC,		;AND RELEASE DEVICE
	SETZM	B.LC+1		;CLEAR INITED FLAG
	JRST	MAINLP		;ALL DONE
;FILE SCANNING ERRORS

E.TMI:	M.FAIL	<Too many input files>
E.WCO:	MOVE	P3,O.NAM
	M.FAIN	<Wildcard illegal in output name>
E.WDO:	M.FAIL	<Wildcard illegal in output directory>
E.WXO:	HLLZ	P3,O.EXT
	M.FAIN	<Wildcard illegal in output extension>
E.PTO:	M.FAIL	<Path specification illegal in output directory>
SUBTTL	PERFORM ONE DISK DIRECTORY LISTING

;DIR -- PERFORM A DIRECTORY LISTING
;CALL:	PUSHJ	P,DIR
;	RETURN WHEN DONE
;OUTPUT FILE ALREADY OPENED; INPUT POINTED TO BY I.NXRD

DIR:	TLZ	F,L.LEVD	;CLEAR LEVEL-D FLAG
	MOVX	T1,%CNSTS	;GET SYSTEM STATES
	GETTAB	T1,		;FROM MONITOR
	  MOVEI	T1,0		;(ASSUME LEV C)
	TXNE	T1,ST%DSK	;SEE IF LEVEL D
	TLO	F,L.LEVD	;YES--SET FLAG

	SETZM	H.ZER1		;CLEAR OUT COUNTERS
	MOVE	T1,[H.ZER1,,H.ZER1+1]
	BLT	T1,H.EZER
	MOVEI	I,0		;FLAG LOKWLD TO START
	TRZ	F,R.WORD	;CLEAR WORD MODE
	TLZ	F,L.SVST!L.FKEF!L.BKSS  ;CLEAR FAILSAFE MODE FLAGS
	SKIPLE	S.WORD		;SEE IF /WORD
	TRO	F,R.WORD	;YES--SET WORD MODE

;HERE TO SEE IF IT IS A DISK
;USE LOKWLD TO PROCESS ALL CONSECUTIVE DISK REQUESTS AS ONE

DSKLOP:	PUSH	P,FSTR		;SAVE OLD DEVICE
	PUSH	P,OPENBL	;  AND OLD /PHYSICAL
	MOVE	T1,[4,,[I.NXRD,,I.NXZR
			OPENBL,,LBLOCK
			I.LZER,,LN.RIB+1
			DC,,I]]
	PUSHJ	P,.LKWLD	;GET NEXT FILE
	  JRST	DIRED		;ALL DONE--OUTPUT TOTALS
	PUSHJ	P,CHKNXF	;CHECK FOR NON-EXISTENT PREVIOUS FILE
	POP	P,T2		;RESTORE OLD PHYSICAL
	XOR	T2,OPENBL	;COMPARE /PHYS
	POP	P,T1		;RESTORE OLD STRUCTURE
	JUMPL	T2,DOOPEN	;IF /PHYS DIFFERENT, DO OPEN
	CAMN	T1,FSTR		;SEE IF DIFFERENT
	JRST	DOLOOK		;NO--PROCEED
DOOPEN:	MOVEI	T1,14		;SET BINARY MODE
	HRRM	T1,OPENBL	;  FOR THE OPEN
	MOVE	T1,SVJBFF	;RESTORE INPUT
	MOVEM	T1,.JBFF##	; .JBFF
	OPEN	DC,OPENBL	;OPEN DATA CHANNEL
	  JRST	[PUSHJ P,E.DFO
		 JRST  DSKLOP]
	INBUF	DC,NDSKBF	;INITIALIZE BUFFER RING
;HERE TO LOOKUP FILE

DOLOOK:	TRZ	F,R.ACCS	;CLEAR ACCESS NEEDED FLAG
	TRNE	F,R.FAST	;SEE IF SUPER-SPEEDY MODE
	SKIPLE	S.SUM		;AND NOT /SUM
	JRST	DOLOK1		;NO--DO LOOKUP
	SKIPL	.WLDFL		;YES--SEE IF WILD CARD
	JRST	DOLOK1		;NO--NEED A LOOKUP
	SKIPG	.FXBFR(I)	;SEE IF /BEFORE
	SKIPLE	.FXSNC(I)	; OR /SINCE
	JRST	DOLOK1		;YES--NEED A LOOKUP
	JRST	GOANAL		;ELSE--SKIP THE LOOK-UP

;HERE WHEN WE CAN NOT SKIP THE LOOKUP
DOLOK1:	MOVEI	T1,0		;PRESET FOR LEVEL D
	TLNN	F,L.LEVD	;SEE IF C
	MOVEI	T1,2		;YES--CHANGE POINTER
	PUSH	P,UFDPPN	;SAVE ARGUMENT DIRECTORY
	LOOKUP	DC,LBLOCK(T1)	;LOOKUP FILE TO GET ITS DATA
	  JRST	[POP   P,UFDPPN
		 PUSHJ P,E.DFLL
		 JRST  DSKLOP]
	AOS	NXFCNT		;COUNT AS A SUCCESSFUL FILE
	POP	P,T1		;RESTORE ARGUMENT DIRECTORY
	SKIPN	UFDPPN		;SEE IF CLOBBERED BY MONITOR
	MOVEM	T1,UFDPPN	;YES--RESTORE ARGUMENT
IFN FTSFD,<
	JUMPN	T1,GOANAL	;IF NOT 0 ARG, THEN LOKWLD DID ITS JOB
	MOVEI	T1,DC		;  IT DIDN'T--ASK MONITOR
	MOVEM	T1,THSPTH	;SET FOR CHANNEL STYLE CALL
	MOVE	T1,[3+LN.DRB,,THSPTH]
	PATH.	T1,		;ASK MONITOR
	  JRST	GOANAL		;GIVE UP IF MONITOR IS UPITY
	MOVEI	T1,THSPTH	;OK--SET POINTER
	MOVEM	T1,UFDPPN	;FOR REST OF PROGRAM
>

GOANAL:	PUSHJ	P,ANALYZ	;GO ANALYZE AND PRINT RESULTS
	  SOS	NXFCNT		;DIDN'T MATCH AFTER ALL
	JRST	DSKLOP		;AND LOOP BACK FOR MORE
;HERE AT END OF DISK DIRECTORY

DIRED:	POP	P,(P)		;CLEAN UP STACK
	EXCH	T1,(P)		;SAVE NEXT DEVCHR
	MOVEM	I,I.NXRD	;STORE PROGRESS
	JUMPE	T1,DIRDON	;IF NO DISKS PENDING, GO WRAP UP
	PUSHJ	P,CHKNXF	;CHECK FOR NON-EX. FILE LEFT OVER
	PUSHJ	P,DIRET		;GO OUTPUT TOTALS LINE

;HERE WHEN DONE WITH DISKS--SEE IF NEXT DEVICE IS
;REASONABLE AND GO DISPATCH

DIRDON:	MOVE	T1,SVJBFF	;RESTORE INPUT
	MOVEM	T1,.JBFF##	; .JBFF
	TRZ	F,R.WORD	;CLEAR WORD SWITCH
	SETZM	H.ZER1		;CLEAR ACCUMULATION AREA
	MOVE	T2,[H.ZER1,,H.ZER1+1]  ; ..
	BLT	T2,H.EZER	; ..
	POP	P,T1		;RESTORE DEVCHR OF NEXT DEVICE
	CAMN	T1,[-1]		;SEE IF ALL DONE
	POPJ	P,		;YES--RETURN
	JUMPN	T1,NOTDON	;JUMP IF REAL DEVICE
	HLRZ	T1,I.DEV(I)	;NONE--SEE
	CAIN	T1,'TMP'	;  IF TMP???:
	JRST	TMPDIR		;YES--OUTPUT TEMP CORE
	JRST	E.NSD		;NO--NO SUCH DEVICE

NOTDON:	TLZ	F,L.LEVD	;CLEAR LEVEL D 
	TXNE	T1,DV.DTA	;SEE IF DECTAPE
	JRST	DTDIR		;YES--GO OUTPUT IT
	TXNE	T1,DV.MTA	;SEE IF MAG TAPE
	JRST	MTDIR		;YES--GO OUTPUT IT
	TXNN	T1,DV.DIR	;UNKNOWN--SEE IF DIRECTORY TYPE
	JRST	E.NDD		;NO--ISSUE MESSAGE
	JRST	E.UDV		;YES--ISSUE MESSAGE
	SUBTTL	PERFORM MAG TAPE DIRECTORY LISTING

;HERE WHEN MAG TAPE IS DISCOVERED

MTDIR:	MOVX	T1,FX.DIR	;SEE IF DIRECTORY SPECIFIED
	TDNE	T1,I.MOD(I)	; BY THE USER
	JRST	MTDIR3		;YES--GO USE IT
	MOVNI	T1,2		;SET FOR WILD
	MOVEM	T1,.WLDFL##	; FILE AND STRUCTURE
	MOVE	T1,.WIFIR##	;NO--RESET TO FULL WILDCARD ON TAPE
MTDIR1:	MOVSI	T2,-LN.DRB	;SET LENGTH OF BLOCK
	HRR	T2,T1		;START AT THIS AREA
MTDIR2:	SETOM	I.DIR(T2)	;SET WILD CARD IN MATCH
	SETZM	I.DIRM(T2)	;SET TO MATCH ALL
	AOS	T2		;ADVANCE BY 2
	AOBJN	T2,MTDIR2	;LOOP FOR WHOLE AREA
	ADDI	T1,I.LZER	;ADVANCE TO NEXT AREA
	CAMG	T1,.WILAS##	;SEE IF DONE
	JRST	MTDIR1		;NO--LOOP

MTDIR3:	SKIPN	T1,.WLDFL	;SEE IF NO WILD FILE OR STR
	AOS	T1,.WLDFL	;YES--MAKE WILD STR ONLY
	CAMN	T1,[-1]		;SEE IF WILD FILE ONLY
	SOS	.WLDFL		;YES--MAKE WILD FILE AND STR
	SKIPLE	S.WORD		;SEE IF /WORD
	TRO	F,R.WORD	;YES--SET FLAG
	MOVE	T1,.JBFF	;SAVE .JBFF TO AVOID
	MOVEM	T1,MTSVFF	;  CORE GROWTH ON REOPENS
	PUSHJ	P,MTOPEN	;OPEN MAG TAPE
	  PJRST	E.DFO		;GIVE UP IF NOT POSSIBLE
	MOVE	T1,S.FILE	;SET /FILE
	MOVEM	T1,MTFLCT	;INTO FILE COUNTER
	SKIPE	S.REWS		;UNLESS /NOREW
	MTREW.	DC,		;REWIND TAPE TO START

	MOVEI	T2,DC		;GET TAPE DENSITY
	MTCHR.	T2,		; FROM MONITOR
	  JRST	[GETSTS DC,T2	;NO--FROM INIT
		 ANDI	T2,IO.DEN  ;JUST GET DENSITY
		 JUMPE	T2,MTNODN  ;JUMP IF UNKNOWN
		 LSH	T2,^D33-^L<IO.DEN>  ;POSITION
		 JRST	.+1]	;PROCEED
	MOVEI	T1,[ASCIZ /    Density = /]
	PUSHJ	P,.TSTRG	;LIST LABEL
	ANDI	T2,3		;MASK TO DENSITY
	MOVE	T2,[ASCIZ /???/
		    ASCIZ /200/
		    ASCIZ /556/
		    ASCIZ /800/](T2)
	MOVEI	T1,T2		;SET MESSAGE
	PUSHJ	P,.TSTRG	;LIST IT
MTNODN:	MOVEI	T1,[ASCIZ /    Parity = /]
	PUSHJ	P,.TSTRG	;LABEL
	MOVEI	T1,[ASCIZ /Odd/]
	STATZ	DC,IO.PAR
	  MOVEI	T1,[ASCIZ /Even/]
	PUSHJ	P,.TSTRG	;LIST PARITY
	PUSHJ	P,NEXDTW	;FORCE SOME I/O
	  TLO	F,L.FKEF	;SET EOF FLAG
	PUSH	P,T1		;SAVE WORD
	MOVEI	P1,DC		;NOW GET DEVICE STATUS
	DEVSTS	P1,		;(HARDWARE STATUS SINCE SOFTWARE LOOSES)
	  JRST	MTNODS		;GIVE UP IF WE CAN'T
	MOVEI	T1,[ASCIZ /    7-Track/]
	TRNN	P1,1B33		;CHECK NUMBER OF TRACKS
	MOVEI	T1,[ASCIZ /    9-Track/]
	PUSHJ	P,.TSTRG	;LIST THAT
	MOVEI	T1,[ASCIZ /    Read only/]
	TRNN	P1,1B32		;CHECK WRITE LOCK
	MOVEI	T1,[ASCIZ /    Write enabled/]
	PUSHJ	P,.TSTRG	;LIST THAT

MTNODS:	PUSHJ	P,.TCRLF	;END LINE
	POP	P,T1		;RESTORE DATA READ
	TLZN	F,L.FKEF	;CHECK IF EOF
	JRST	MTEXAM		;NO--GO HANDLE DATA
	MOVEI	T1,[ASCIZ /% Tape starts with tape mark
/]
MTSTEF:	PUSHJ	P,.TSTRG	;LIST WARNING
	PUSHJ	P,MTOPEN	;REOPEN TO CLEAR EOF
	  JRST	E.DFO		;GIVE UP IF IT WENT AWAY
	JUMPE	T1,MTDONX	;EXIT IF /FILE COUNTED OUT
	PUSHJ	P,NEXDTW	;AGAIN, TRY TO READ A WORD
	  JRST	.+2		;ANOTHER EOF
	JRST	MTEXAM		;NO--GO EXAMINE TAPE
	MOVEI	T1,[ASCIZ /%      and another tape mark
/]
	JRST	MTSTEF		;LOOP UNTIL WE GET SOME DATA
;HERE WHEN DEVICE IS OPEN AND TIME TO LOOK AT NEXT FILE TO SEE IF
;IT IS A FAILSAFE SAVE SET

MTFIND:	PUSHJ	P,NEXDTW	;GET NEXT WORD
	  JRST	MTEOF		;END OF FILE--GO HANDLE THAT CASE
MTEXAM:	MOVEM	T1,CHKSUM	;SETUP CHECKSUM IN CASE THAT'S IMPORTANT
	MOVEI	T2,1		;SET WORD COUNTER
	TLNN	T1,7777		;SEE IF BACKUP SAVE SET
	JRST	MTBKSS		;YES--GO PROCESS
	JUMPG	T1,MTSVST	;JUMP IF LOOKS LIKE SAVE SET
	MOVE	T3,T1		;GET COPY OF WORD
	TRZ	T3,77777	;REDUCE TO FIRST THREE ASCII CHARS
	MOVSI	T4,-LNLBLT	;POINT TO LABEL TYPES TABLE
	CAME	T3,LABTYP(T4)	;SEE IF LABEL
	AOBJN	T4,.-1		;LOOP TO MATCH
	JUMPL	T4,MTLABL	;YES--GO READ LABEL
	JRST	MTIOW		;ELSE, GO READ AS SAVE OR HRI FILE

LABTYP:	ASCII	/VOL/		;BEGINNING OF VOLUME
	ASCII	/UVL/		;USER VOLUME
	ASCII	/EOV/		;END OF VOLUME
	ASCII	/UTL/		;USER TRAILER
	ASCII	/HDR/		;BEGINNING OF FILE
	ASCII	/UHL/		;USER HEADER
	ASCII	/EOF/		;END OF FILE
LNLBLT==.-LABTYP
;HERE WHEN THE FILE IS AN IOWD (IE, SAVE OR HRI FORMAT)

MTIOW:	SETOM	P1		;SET FLAG FOR FIRST IOWD
	SETZM	FVER		;CLEAR VERSION NUMBER
MTIOWD:	MOVE	T3,T1		;GET COUNT OF IOWD
	JUMPE	T1,MTIOHR	;IF ZERO, JUNK OR HRI FORMAT
	AOS	P1		;ADVANCE IOWD COUNTER
	JUMPG	T1,MTIOJK	;JUMP IF JUNK FORMAT
MTIODT:	PUSHJ	P,NEXDTW	;GET DATA WORD
	  JRST	MTIOJF		;JUMP IF EOF
	AOS	T2		;COUNT WORD READ
	MOVEI	T4,1(T3)	;GET LOCATION OF DATA
	CAIN	T4,.JBVER	;SEE IF VERSION NUMBER
	MOVEM	T1,FVER		;YES--SAVE FOR LATER
	MOVE	T4,T1		;SAVE DATA WORD IN CASE OF HRI FORMAT
	AOBJN	T3,MTIODT	;COUNT OFF WORDS IN IOWD
	PUSHJ	P,NEXDTW	;GET NEXT IOWD OR JRST
	  JRST	MTIOHE		;SEE IF HRI FORMAT
	AOS	T2		;COUNT WORD READ
	JUMPLE	T1,MTIOWD	;LOOP IF ANOTHER IOWD
	MOVE	T4,T1		;NO--SAVE DATA WORD (MAYBE JRST WORD)

MTIODN:	PUSHJ	P,NEXDTW	;GET ANY MORE OF RECORD
	  JRST	.+2		;JUMP TO OUTPUT
	AOJA	T2,MTIODN	;LOOP UNTIL DONE
	MOVEI	P1,[ASCIZ /  Save format:    length = /]
	JRST	MTIOJM		;GO CHECK FOR JRST WORD

;HERE IF LOOKS LIKE HRI FORMAT

MTIOHR:	PUSHJ	P,NEXDTW	;IF ONLY ZEROS TO EOF
	  JRST	MTIOHE		;  THEN MUST BE OK
	JUMPN	T1,MTIOJK	;NO--JUNK
	AOJA	T2,MTIOHR	;LOOP TO EOF

MTIOHE:	JUMPN	P1,MTIOJK	;JUNK IF NOT FIRST IOWD
	MOVE	T1,T4		;RESTORE LAST DATA WORD
	MOVEI	P1,[ASCIZ /  HRI format:     length = /]
	SETZM	FVER		;CLEAR VERSION NUMBER
;HERE WHEN DONE WITH HRI OR SAVE FORMAT READ

MTIOJM:	HLRZ	T3,T4		;SEE IF START
	TRZ	T3,(<HALT>-<JRST>)  ;CLEAR HALT BITS
	CAIE	T3,(JRST)	;TEST FOR JUMP
	JRST	MTIOJK		;NO--JUNK
	MOVE	M,P1		;FETCH CORRECT MESSAGE
	PUSHJ	P,LSTR		;TYPE LABEL
	MOVE	T1,T2		;GET LENGTH IN WORDS
	PUSHJ	P,LDEC		;LIST DECIMAL
	MOVEI	M,[ASCIZ /, start = /]
	PUSHJ	P,LSTR		;LIST LABEL
	HRRZ	T1,T4		;GET START ADDRESS
	PUSHJ	P,LOCT		;LIST OCTAL
	MOVEI	M,[ASCIZ /, checksum = /]
	PUSHJ	P,LSTR		;LIST LABEL
	PUSHJ	P,LCHECK	;LIST CHECKSUM
	MOVEI	M,[ASCIZ /, version = /]
	SKIPE	T4,FVER		;SEE IF VERSION
	PUSHJ	P,LSTR		;YES--PREFIX IT
	PUSHJ	P,LVER		;AND LIST IT
	PUSHJ	P,LCRLF		;END LINE
	JRST	MTEF		;JUMP TO END OF FILE PROCESSING
;HERE IF JUNK BUT NOT YET EOF

MTIOJK:	PUSHJ	P,NEXDTW	;GET NEXT WORD
	  JRST	MTIOJF		;JUMP WHEN DONE
	AOJA	T2,MTIOJK	;LOOP COUNTING WORDS

;HERE IF JUNK AT EOF

MTIOJF:	MOVEI	M,[ASCIZ /  Unknown format: length =/]
	PUSHJ	P,LSTR		;LIST LABEL
	MOVE	T1,T2		;GET LENGTH
	PUSHJ	P,LDEC		;LIST DECIMAL
	MOVEI	M,[ASCIZ /, checksum = /]
	PUSHJ	P,LSTR		;LIST LABEL
	PUSHJ	P,LCHECK	;LIST CHECKSUM
	PUSHJ	P,LCRLF		;END LINE

;HERE AT EOF AFTER JUNK OR IOWD FILE

MTEF:	MOVEI	M,[ASCIZ /<Tape mark>
/]
MTEFM:	TRNE	F,R.MARK	;SEE IF /MARK
	PUSHJ	P,LSTR		;YES--TELL USER
MTEFX:	REPEAT	0,<		;NEED THIS ONLY IF TAPE ENDS WITH 3 EOFS
	PUSHJ	P,MTOPEN	;REOPEN MAG TAPE TO CLEAR EOF BIT
	  PJRST	E.DFO		;GACK!
	JUMPE	T1,MTDONX	;EXIT IF /FILE COUNTED OUT
	JRST	MTFIND		;NEW FILE--GO PROCESS IT
>
	JRST	MTEOFH		;HANDLE EOF


;HERE AFTER NEW FILE FOUND EOF

MTEOF:	MOVEI	M,[ASCIZ /<Tape mark>
/]
	TRNE	F,R.MARK	;SEE IF /MARK
	PUSHJ	P,LSTR		;YES--LIST COMMENT
MTEOFH:	PUSHJ	P,MTOPEN	;REOPEN MAG TAPE TO CLEAR EOF BIT
	  PJRST	E.DFO		;GACK!!
	JUMPE	T1,MTDONX	;JUMP IF DONE WITH /FILES
	PUSHJ	P,NEXDTW	;READ WORD TO SEE IF DOUBLE EOF
	  JRST	.+2		;YES--CLEAN UP
	JRST	MTEXAM		;NO--START OVER
	MOVEI	M,[ASCIZ /<Second tape mark in succession>
/]
	TRNE	F,R.MARK	;SEE IF /MARK
	PUSHJ	P,LSTR		;YES--LIST COMMENT
	JRST	MTDONE		;AND GO FINISH UP
;HERE WHEN ANSI-LIKE TAPE LABEL SEEN

MTLABL:	MOVEI	M,[ASCIZ /	 Label "/]
MTLABR:	MOVE	T4,B.DC+2	;GET LENGTH
MTLABS:	PUSHJ	P,LSTR		;LIST PREFIX
	MOVEI	T2,1		;PRESET WORD COUNT
	CAIE	T4,^D80/5-1	;SEE IF STANDARD LABEL LENGTH
	TLO	F,L.ILEN	;NO--SET FLAG
	MOVEI	P1,1(T4)	;SET END TO LENGTH
	CAILE	P1,^D80/5	;BUT NOT BEYOND
	MOVEI	P1,^D80/5	;  STANDARD LENGTH
MTLAB1:	MOVE	T4,T1		;MOVE WORD TO PAIR
	MOVEI	T1,5		;SET TO COUNT CHARS

;HERE FOR EACH CHARACTER IN LABEL

MTLAB2:	MOVEI	T3,0		;CLEAR RESULT
	LSHC	T3,7		;GET CHAR
	CAILE	T3,37		;SEE IF CONTROL CHAR (OR NULL)
	JRST	MTLAB3		;NO--PROCEED
	MOVEI	C,"^"		;YES--LIST FLAG
	PUSHJ	P,LCHR		; FOR USER
	ADDI	T3,100		;CONVERT TO ALPHA
MTLAB3:	CAIGE	T3,140		;SEE IF LOWER CASE
	JRST	MTLAB4		;NO--PROCEED
	MOVEI	C,"'"		;YES--LIST FLAG
	PUSHJ	P,LCHR		; FOR USER
	SUBI	T3,40		;CONVERT TO UPPER CASE
MTLAB4:	MOVE	C,T3		;GET CHAR
	PUSHJ	P,LCHR		;LIST
	SOJG	T1,MTLAB2	;LOOP FOR THIS WORD

	PUSHJ	P,NEXDTW	;GO GET NEXT WORD
	  JRST	MTLABX		;AT EOF
	CAIE	T2,(P1)		;DON'T GO TOO FAR
	AOJA	T2,MTLAB1	;LOOP DOWN LABEL

	TLO	F,L.FKEF	;TOO FAR, SET FAKE EOF FLAG
	MOVE	P1,T1		;SAVE WORD FOR LATER
;HERE AT END OF LABEL

MTLABX:	MOVEI	C,""""		;END OF QUOTE
	PUSHJ	P,LCHR		;LIST END
	PUSHJ	P,LCRLF		;END LINE
	TLNN	F,L.ILEN!L.FKEF	;SEE IF BAD LENGTH
	JRST	MTEF		;NO--GO CLEAR EOF AND PROCEED
	MOVEI	T1,[ASCIZ /% Incorrect length for label
/]
	TLZE	F,L.ILEN	;TEST INCORRECT LENGTH
	PUSHJ	P,.TSTRG
	TLZN	F,L.FKEF	;CLEAR FAKE EOF
	JRST	MTEF		;NOT SET--PROCEED
	TLZE	F,L.IMLB	;SEE IF IMBEDDED LABEL
	JRST	MTBKSR		;YES--RETURN TO THAT LOOP

	MOVE	T3,P1		;GET NEXT WORD
	TRZ	T3,77777	;REDUCE TO FIRST THREE ASCII CHARS
	MOVSI	T4,-LNLBLT	;POINT TO LABEL TYPES TABLE
	CAME	T3,LABTYP(T4)	;SEE IF LABEL
	AOBJN	T4,.-1		;LOOP TO MATCH
	JUMPL	T4,MTLBCN	;CONSECUTIVE LABELS
	MOVEI	T1,[ASCIZ /% Missing tape mark after label
/]
	PUSHJ	P,.TSTRG
	MOVE	T1,P1		;RESTORE WORD
	JRST	MTEXAM		;AND GO EXAMINE DATA

MTLBCN:	MOVEI	M,[ASCIZ / Grouped label "/]
	MOVE	T1,P1		;RESTORE WORD
	JRST	MTLABR		;GO DO NEXT LABEL
;HERE WHEN BACKUP SAVE SET ENCOUNTERED

MTBKSR:	PUSHJ	P,NEXDTW	;GET NEXT CONTROL WORD
	  JRST	MTBKJF		;UNEXPECTED EOF
MTBKSS:	TLO	F,L.LEVD	;SET LEVEL-D DATA
	MOVEM	T1,MTSVVR	;SAVE HEADER WORD
	HLRZ	T2,T1		;GET CONTROL WORD
	CAIE	T2,100000	;SEE IF FILE HEADER
	CAIN	T2,200000	;SEE IF DIRECTORY HEADER
	JRST	MTBKLK		;YES--GO READ LOOKUP BLOCK
	CAIN	T2,40000	;SEE IF IMBEDDED LABEL
	JRST	MTBKIL		;YES--GO HANDLE IT

;HERE WHEN JUNK IN BACKUP SET

MTBKJK:	MOVEI	T1,[ASCIZ /% Junk during BACKUP save set
/]
	PUSHJ	P,.TSTRG
MTBKJL:	TLO	F,L.BKSS	;SET FLAG FOR SAVE SET
	PUSHJ	P,NEXDTW	;READ ON
	  JRST	MTBKJM		;AT END OF DATA
	MOVE	T1,B.DC+2	;GET DATA LEFT IN BLOCK
	SOJG	T1,MTBKJL	;SOME--LOOP THRU DATA
MTBKJM:	TLZ	F,L.BKSS!L.FKEF	;CLEAR FLAGS
	PUSHJ	P,NEXDTW	;LOOK AT RESULTS
	  JRST	MTBKJG		;EOF--GO HANDLE
	HLRZ	T2,T1		;GET HEADER TYPE
	CAIE	T2,100000	;SEE IF DIRECTORY
	CAIN	T2,200000	; OR FILE HEADER
	JRST	MTBKSS		;YES--GO PROCESS IT
	CAIN	T2,40000	;SEE IF LABEL
	JRST	MTBKIL		;YES--GO HANDLE
	JRST	MTBKJL		;NO--LOOP ONWARDS
;HERE AT UNEXPECTED EOF

MTBKJF:	MOVEI	T1,[ASCIZ /% Tape mark during BACKUP save set
/]
	PUSHJ	P,.TSTRG
MTBKJG:	JRST	MTEFX		;GO ISSUE MESSAGE

;HERE AT IMBEDDED LABEL

MTBKIL:	ANDI	T1,777		;GET LABEL LENGTH
	SOSG	T4,T1		;MOVE TO LOC. FOR LABEL PRINTER
	JRST	MTBKJK		;NO--JUNK
	TLO	F,L.IMLB	;YES--SET FLAG
	PUSHJ	P,NEXDTW	;SKIP CHECKSUM
	  JRST	MTBKJF		;GIVE UP
	PUSHJ	P,NEXDTW	;GET START OF LABEL
	  JRST	MTBKIF		;GO HANDLE EOF
	MOVEI	M,[ASCIZ / Blocked label "/]
	JRST	MTLABS		;GO DO LABEL

;HERE WHEN IMBEDDED LABEL IS SEPARATE FILE

MTBKIF:	MOVEI	M,[ASCIZ /<Tape mark preceeded by label flag>
/]
	JRST	MTEFM		;GO ISSUE MESSAGE
;HERE WHEN LOOKUP BLOCK COMING

MTBKLK:	MOVEI	T2,(T1)		;GET LOOKUP WORDS
	ANDI	T2,777		;CLEAR JUNK
	CAILE	T2,LN.RIB	;PROTECT LOOKUP AREA
	JRST	MTBKJK		;BAD--GIVE UP
	MOVEI	T3,0		;SET TO START OF LOOKUP BLOCK
	PUSHJ	P,NEXDTW	;GET NEXT WORD
	  JRST	MTBKJF		;BAD TO EOF HERE
				;THROW AWAY WORD
MTBKLL:	PUSHJ	P,NEXDTW	;GET NEXT LOOKUP WORD
	  JRST	MTBKJF		;BAD TO EOF IN MIDDLE
	MOVEM	T1,LBLOCK(T3)	;SAVE IN STANDARD AREA
	AOS	T3		;ADVANCE BLOCK
	SOJG	T2,MTBKLL	;LOOP UNTIL DONE
	HRRZ	T2,MTSVVR	;GET LENGTH AGAIN
	SOS	T2		;SUBTRACT ONE
	ANDI	T2,777		;MASK TO FORWARD LENGTH
	CAME	T2,RIBLEN	;COMPARE TO LOOKUP LENGTH
	JRST	MTBKJK		;BAD--GIVE UP
	TRNE	F,R.MARK	;SEE IF /MARKS
	JRST	MTBKLM		;YES--TYPE UFD
	HLRZ	T2,MTSVVR	;REFETCH HEADER
	CAIE	T2,100000	;SEE IF FILE HEADER
	JRST	MTBKNW		;NO--SKIP TO NEXT HEADER
;HERE WHEN FILE HEADER IS IN LOOKUP AREA

MTBKLM:	MOVE	T1,FMTA		;GET MAG TAPE WORD
	MOVEM	T1,FSTR		;STORE AS STUCTURE
	SETZM	FMTA		;CLEAR OUT TAPE WORD
	TLO	F,L.BKSS	;SET SAVE SET FLAG
	PUSHJ	P,MTDOFL	;GO DO MAG TAPE FILE

	TLZ	F,L.BKSS!L.FKEF	;CLEAR SCREWBALL FLAGS
	HLRZ	T2,MTSVVR	;SEE WHAT KIND OF FILE
	CAIE	T2,100000	;CHECK FILE
	JRST	MTBKNW		;NO--SKIP BELOW
	PUSHJ	P,NEXDTW	;GET NEXT CONTROL
	  JRST	MTBKJF		;NEED END OF DATA FILE
	HLRZ	T2,T1		;GET TYPE
	CAIE	T2,20000	;SEE IF END OF FILE
	JRST	MTBKJK		;NO--JUNK
	PUSHJ	P,NEXDTW	;YES--GET CHECKSUM
	  JRST	MTBKJF		;ERROR IF ABSENT
MTBKNW:	PUSHJ	P,NEXDTW	;GET NEXT HEADER WORD
	  JRST	MTEF		;GO TO EOF PROCESSING
	TLNN	T1,7777		;SEE IF BACKUP HEADER
	JRST	MTBKSS		;GO HANDLE HEADER
	PUSH	P,T1		;SAVE NEXT WORD
	MOVEI	T1,[ASCIZ /% Missing tape mark after BACKUP save set
/]
	PUSHJ	P,.TSTRG
	POP	P,T1		;RESTORE NEXT WORD
	JRST	MTEXAM		;GO EXAMINE THE DATA
;HERE WHEN FAILSAFE SAVE SET ENCOUNTERED

MTSVST:	TLO	F,L.LEVD	;SET LEVEL-D FORMAT DATA
	MOVEM	T1,MTSVVR	;SAVE HEADER
	HRRZ	T1,T1		;VERIFY CODE
	CAIE	T1,4		; IS FOR FAILSA
	JRST	MTIOJK		;NO--JUNK RECORD
	PUSHJ	P,NEXDTW	;GET CODE WORD
	  JRST	MTIOJF		;JUNK
	AOS	T2		;COUNT WORD
	CAME	T1,[SIXBIT /*FAILS/]
	JRST	MTIOJK		;NOT FAILSAFE TAPE
	PUSHJ	P,NEXDTW	;GET TAPE NUMBER
	  JRST	MTIOJF		;DEATH
	AOS	T2		;COUNT STILL
	HRRM	T1,MTSVVR	;SAVE TAPE NUMBER
	TRZ	T1,377777	;CLEAR TAPE NUMBER
	CAME	T1,[SIXBIT /AFE/]
	JRST	MTIOJK		;JUNK
	PUSHJ	P,NEXDTW	;GET DATE, ETC.
	  JRST	MTIOJF		;NOT ENOUGH
	AOS	T2		;COUNT RECORD
	MOVE	P2,T1		;SAVE TAPE AND DATE
	PUSHJ	P,NEXDTW	;LAST WORD
	  JRST	MTIOJF		;SORRY
	AOS	T2		;COUNT WORD IN RECORD
	CAME	T1,[1,,2]	;CHECK THAT TOO
	JRST	MTIOJK		;NO--GIVE UP
	PUSHJ	P,NEXDTW	;READ THE EOF
	  JRST	.+2		;GOOD
	AOJA	T2,MTIOJK	;NO--JUNK

	MOVEI	M,[ASCIZ /  FAILSAFE save set by version /]
	PUSHJ	P,LSTR		;LIST LABEL
	HLRZ	T1,MTSVVR	;GET VERSION OF FAILSA
	PUSHJ	P,LOCT		;LIST OCTAL
	PUSHJ	P,MTLTDT	;LIST TAPE'S DATE AND TIME
	MOVEI	M,[ASCIZ /  tape /]
	PUSHJ	P,LSTR		;LIST LABEL
	HRRZ	T1,MTSVVR	;GET TAPE NUMBER
	PUSHJ	P,LDEC		;LIST IT
	PUSHJ	P,LCRLF		;END LINE
;HERE AFTER SAVE SET HEADER IS OUTPUT AND
;BACK HERE AFTER EACH FILE TO LOOK FOR NEXT USER/STR

MTUSER:	MOVEI	M,[ASCIZ /<Tape mark>
/]
	TRNE	F,R.MARK	;SEE IF /MARK
	PUSHJ	P,LSTR		;YES--TELL USER
	STATZ	DC,IO.EOT	;SEE IF EOT
	  JRST	MTSVET		;YES--GO WRAP UP
	PUSHJ	P,MTOPEN	;OPEN TO CLEAR EOF
	  JRST	E.DFO		;GRUMBLE
	JUMPE	T1,MTDONX	;JUMP IF DONE WITH /FILE
	PUSHJ	P,NEXDTW	;READ NEXT HEADER
	  JRST	[MOVEI T1,[ASCIZ /% Double tape mark
/]
		 PUSHJ P,.TSTRG	;GIVE WARNING
		 JRST  MTUSER]	;AND TRY AGAIN

;BACK HERE TO PROCESS NEXT FILE

MTLOOK:	JUMPGE	T1,MTRAIL	;MUST BE AT TRAILER
	TLC	T1,-1		;FLIP FLAG
	TLNN	T1,-1		;MAKE SURE IT WAS -1
	CAIGE	T1,42		;MAKE SURE FULL BLOCK THERE
	JRST	MTSVJK		;NO--JUNK IN SAVE SET
	PUSHJ	P,NEXDTW	;GET STR NAME
	  JRST	MTSVJF		;ERROR
	MOVEM	T1,FSTR		;SAVE FOR TYPEOUT
	MOVSI	P1,-41		;PRESET LOOKUP COPY LOOP
MTLOK1:	PUSHJ	P,NEXDTW	;GET WORD
	  JRST	MTSVJF		;ERROR
	MOVEM	T1,LBLOCK(P1)	;SAVE WORD
	AOBJN	P1,MTLOK1	;LOOP UNTIL DONE
	MOVE	T1,RIBLEN	;GET COUNT FROM TAPE
	CAIE	T1,40		;MUST BE 40
	JRST	MTSVJK		;NO--JUNK
	TLO	F,L.SVST	;FLAG SAVE SET READ TO SKIP OVER
				;  THE RECORD PREFIXES

;HERE WHEN FILE FOUND ON TAPE

	PUSHJ	P,MTDOFL	;GO HANDLE FILE

	TLZ	F,L.SVST	;CLEAR FUNNY MODE
	TLZN	F,L.FKEF	;SEE IF REAL OR FAKE EOF
	JRST	MTUSER		;REAL--GO TO NEXT STR OR PPN OR TRAILER
	MOVE	T1,MTSVHD	;FAKE--GET NEXT HEADER
	JRST	MTLOOK		;GO PROCESS NEXT FILE
;MTDOFL -- ROUTINE TO ANALYZE FILE IF USER WANTS IT AND SKIP OVER DATA
;USES T1-4

MTDOFL:	PUSHJ	P,ISMATC	;GO SEE IF IT MATCHES
	  JRST	MTSKIP		;NO--SKIP FILE
	SOS	NOFILF		;DECREMENT FILE COUNT (ANALYZE DOES SUB COUNT)

;HERE WHEN FILE IS FOUND TO OUTPUT

	PUSHJ	P,ANALYZ	;GO LIST IN APPROPRIATE FORMAT
	  SOS	NXFCNT		;DIDN'T MATCH AFTER ALL

MTSKIP:	PUSHJ	P,NEXDTW	;READ REST OF DATA FILE
	  POPJ	P,		;GOOD--WE'RE DONE
	JRST	MTSKIP		;LOOP TO FILE'S END
;HERE WHEN TRAILER SEEN ON TAPE

MTRAIL:	HLLZ	T2,MTSVVR	;GET VERSION FROM HEADER
	HRRI	T2,4		;SET FIXED LENGTH
	CAME	T1,T2		;SEE IF MATCHES
	JRST	MTSVJK		;NO--JUNK
	PUSHJ	P,NEXDTW	;GET CHECK WORD
	  JRST	MTSVJF		;ERROR
	CAME	T1,[SIXBIT /*FAILS/]
	JRST	MTSVJK		;JUNK
	PUSHJ	P,NEXDTW	;AND COUNT
	  JRST	MTSVJF		;ERROR
	HRRZ	T2,MTSVVR	;GET SAVED TAPE NUMBER
	ADD	T1,T2		;MATCH AGAINST TRAILER'S
	CAME	T1,[<SIXBIT /AFE/>+1B17]
	JRST	MTSVJK		;ERROR
	PUSHJ	P,NEXDTW	;GET DATE, ETC.
	  JRST	MTSVJF		;ERROR
	MOVE	P2,T1		;SAVE FOR OUTPUT ROUTINE
	PUSHJ	P,NEXDTW	;GET FINAL CHECK
	  JRST	MTSVJF		;ERROR
	CAME	T1,[1,,2]	;CHECK CODE
	JRST	MTSVJK		;ERROR
	PUSHJ	P,NEXDTW	;READ EOF
	  JRST	.+2		;GOOD
	JRST	MTSVJK		;ERROR

;HERE AFTER READING THE TRAILER FILE

	PUSHJ	P,DIRE		;GIVE TOTAL LINE
	MOVEI	M,[ASCIZ /  End of save set/]
	PUSHJ	P,LSTR		;TYPE INDICATOR
	PUSHJ	P,MTLTDT	;LIST TIME AND DATE
	PUSHJ	P,LCRLF		;AND END LINE
	PUSHJ	P,LCRLF		;AND ADD A BLANK LINE
	SETZM	H.MZER		;CLEAR TOTALS
	MOVE	T1,[H.MZER,,H.MZER+1]
	BLT	T1,H.EMZR
	JRST	MTFIND		;GO BACK TO START
;HERE WHEN JUNK IN SAVE SET

MTSVJK:	PUSHJ	P,NEXDTW	;READ ON TO EOF
	  JRST	MTSVJF		;GOT IT
	JRST	MTSVJK		;NO--LOOP

;HERE WHEN EOF JUNK

MTSVJF:	MOVEI	T1,[ASCIZ /% Junk in save set
/]
	PUSHJ	P,.TSTRG	;TELL USER
	JRST	MTUSER		;GO START OVER

;HERE ON PREMATURE EOT

MTSVET:	MOVEI	T1,[ASCIZ /% Premature end of tape in save set
/]
	PUSHJ	P,.TSTRG	;TELL USER

;HERE AT EOT ON MAG TAPE

MTDONE:	SKIPE	S.EOT		;SEE IF /NOEOT
	JRST	MTDONX		;NO--GO FINISH UP
	PUSHJ	P,MTOPEN	;YES--REOPEN FROM TAPE MARK
	  PJRST	E.DFO		;OOOPS
	JUMPN	T1,MTFIND	;START OVER UNLESS /FILE COUNTED OUT

;HERE WHEN TRULY TIME TO STOP

MTDONX:	SKIPE	S.REWS		;SEE IF /NOREW
	MTREW.	DC,		;REWIND TAPE AT END
	RELEAS	DC,		;RELEASE THE DATA CHANNEL
	TRZ	F,R.WORD	;CLEAR WORD MODE
	POPJ	P,		;RETURN
;MTLTDT -- ROUTINE TO LIST TIME AND DATE FROM FAILSAFE TAPE
;CALL:	MOVE	P2,WORD FROM HEADER
;	PUSHJ	P,MTLTDT
;LISTS " AT HH:MM:SS ON DATE"

MTLTDT:	PUSHJ	P,.SAVE1	;SAVE P1
	MOVEI	M,[ASCIZ / at /]
	PUSHJ	P,LSTR		;LIST LABEL
	HLRZ	T1,MTSVVR	;GET VERSION NUMBER
	CAIG	T1,27		;IF SINCE V.27 OK
	JRST	[LDB	T4,[POINT 11,P2,23]
		 PUSHJ	P,LTIME
		 JRST	MTSVDT]
	LDB	T4,[POINT 17,P2,23]
	IDIVI	T4,^D60		;GET HH:MM
	PUSH	P,P1		;SAVE SECONDS
	PUSHJ	P,LTIME		;LIST TIME
	POP	P,T1		;GET SECONDS
	PUSHJ	P,LTIMES	;LIST :SS
MTSVDT:	MOVEI	M,[ASCIZ / on /]
	PUSHJ	P,LSTR		;LIST LABEL
	MOVE	T4,P2		;GET DATE
	ANDI	T4,7777		;MASK OUT JUNK
	PJRST	LDATE		;LIST IT AND RETURN
;SUBROUTINE TO OPEN MAG TAPE
;CALL:	PUSHJ	P,MTOPEN
;RETURNS T1=0 IF FILE COUNT DONE (/FILE SWITCH)

MTOPEN:	MOVE	T1,MTSVFF	;RESTORE JOBFF
	MOVEM	T1,.JBFF	;  TO AVOID GROWTH
	LDB	T1,[POINTR (I.MOD(I),<FX.PAR!FX.DEN>)]
	LSH	T1,^D35-POS(IO.DEN)
	MOVE	T2,I.MOD(I)	;GET PHYSICAL BIT
	TXNE	T2,FX.PHY	;TEST IT
	TXO	T1,UU.PHS	;YES--SET FOR OPEN
	IORI	T1,.IOBIN	;SET BINARY MODE
	MOVE	T2,I.DEV(I)	;GET DEVICE NAME
	MOVEI	T3,B.DC##	;GET INPUT BUFFER HEADERS
	OPEN	DC,T1		;OPEN CHANNEL
	  POPJ	P,		;RETURN WITH ERROR

;HERE WHEN TAPE IS OPENED--SETUP BUFFERS

	MOVEI	T4,T1		;GET SYSTEM BUFFERING
	DEVSIZ	T4,		;FROM MONITOR
	  MOVSI	T4,2		;(ASSUME 2)
	HRRZ	T1,T4		;GET BUFFER SIZE
	CAIGE	T1,1003		;SEE IF FAILSA OR BIGGER SIZE
	MOVEI	T1,1003		;NO--FORCE UP
	HLL	T1,T4		;GET NUMBER OF BUFFERS
	MOVEI	T2,B.DC		;POINT TO HEADER
	PUSHJ	P,MAKBUF	;MAKE A BUFFER RING
	SOS	T1,MTFLCT	;COUNT DOWN FILE COUNTER
	JRST	.POPJ1		;WIN RETURN
;MAKBUF -- ROUTINE TO MAKE A BUFFER RING
;CALL:	HRLI	T1,NUMBER OF BUFFERS
;	HRRI	T1,SIZE OF EACH (INCLUDING HEADERS)
;	MOVEI	T2,LOCATION OF BUFFER HEADER
;	PUSHJ	P,MAKBUF
;RETURNS UNLESS NOT ENOUGH CORE

MAKBUF:	PUSHJ	P,.SAVE2##	;SAVE P1 AND P2
	HLRZ	P1,T1		;GET BUFFER COUNT
	MOVEI	T3,(T1)		;GET BUFFER SIZE
	TLZ	T1,-1		;CLEAR JUNK
	IMUL	T1,P1		;GET TOTAL SPACE
	PUSHJ	P,GETCOR	;GET CORE AT .JBFF
	MOVE	P2,T1		;SAVE OLD .JBFF
	AOS	T1		;POINT TO LINK WORD
	MOVE	T4,T1		;AND MAKE A COPY
	HRL	T4,T3		;PUT SIZE IN POINTERS

MAKBF1:	ADD	T4,T3		;ADVANCE TO NEXT BUFFER
	MOVEM	T4,(T1)		;STORE POINTER IN PREVIOUS BUFFER
	MOVE	T1,T4		;STEP TO NEXT BUFFER
	SOJG	P1,MAKBF1	;LOOP UNTIL DONE
	SUB	T1,T3		;BACKUP TO LAST POINTER
	HRRI	T4,1(P2)	;GET FIRST BUFFER LINK WORD ADDRESS
	MOVEM	T4,(T1)		;STORE POINTER TO FIRST BUFFER
	HRLI	T4,(1B0)	;SET USE BIT
	MOVEM	T4,(T2)		;STORE IN HEADER
	POPJ	P,		;RETURN
;GETCOR -- ROUTINE TO GET SOME CORE AT .JBFF
;WILL EXPAND LOW SEG IF NECESSARY
;CALL:	MOVEI	T1,AMOUNT NEEDED
;	PUSHJ	P,GETCOR
;RETURN WITH T1=START OF AREA (OLD .JBFF)

GETCOR:	PUSH	P,T2		;SAVE TEMP
	MOVE	T2,T1		;GET ARG
	MOVE	T1,.JBFF	;SAVE OLD .JBFF
	ADDM	T2,.JBFF	;ADVANCE .JBFF

GTCOR1:	MOVE	T2,.JBFF	;GET AMOUNT NEEDED
	CAMG	T2,.JBREL	;SEE IF MORE THAN WE HAVE
	JRST	GTCOR2		;NO--OK TO RETURN
	CORE	T2,		;TELL MONITOR
	  JRST	E.NECX		;ERROR--TELL USER
	JRST	GTCOR1		;LOOP TO VERIFY IT'S OK

GTCOR2:	POP	P,T2		;RESTORE TEMP
	POPJ	P,		;RETURN

E.NECX:	MOVE	P3,.JBFF	;GET VALUE NEEDED
	N.FAID	<Not enough core--need>
	SUBTTL	ROUTINE FOR DISK AND MAGTAPE DIRECTORY LINE

;SUBROUTINE TO ANALYZE AND PRINT FROM AN EXTENDED LOOKUP
;BLOCK AND READ THE FILE IF NECESSARY
;	SKIPS IF MATCHES, NON-SKIP IF TOO OLD OR TOO YOUNG

ANALYZ:	PUSHJ	P,.CHKTA##	;CHECK /BEFORE AND /SINCE
	  POPJ	P,		;FAIL--GIVE NO MATCH RETURN
	PUSHJ	P,.SAVE1	;SAVE P1
	MOVEI	P1,0		;NO SPECIAL OFFSET
	PUSHJ	P,SSTRDR	;SET STATUS AND TYPE SUMMARY
	AOS	(P)		;WIN--GIVE OK RETURN
	AOS	SNFILF		;COUNT FILE FOUND
	SETZM	CHKSUM		;CLEAR CHECKSUM ACCUMULATOR
	SKIPG	S.UNIT		;SEE IF USER REQUESTED UNITS
	SKIPN	.WLDFL		;NO--SEE IF ABSENCE OF WILD CARDS
	SKIPN	T1,FDEV		;YES--SEE IF FILSER TOLD US
	JRST	GOTSTR		;NO--DON'T CHANGE
	SKIPN	S.UNIT		;YES--SEE IF /NOUNITS
	SKIPE	.WLDFL		;AND NO STR WILDCARD
	JRST	NEWSTR		;NO--OK
	MOVEM	T1,DCHBLK	;YES--SETUP FOR DSKCHR
	SETZM	DCHBLK+.DCSNM	;CLEAR ANSWER
	MOVE	T1,[.DCSNM+1,,DCHBLK] ;POINT TO BLOCK
	DSKCHR	T1,		;ASK MONITOR STR NAME
	  JRST	GOTSTR		;NICE TRY
	SKIPE	T1,DCHBLK+.DCSNM  ;GET STR NAME
NEWSTR:	MOVEM	T1,FSTR		;YES--UPDATE INFO TO PRINT
GOTSTR:	SKIPG	S.SUM		;SEE IF /SUM
	TRNN	F,R.FAST	;NO SEE IF /F
	JRST	.+2		;NO--ANALYZE
	JRST	FILEND		;YES--NO ANALYSIS
	MOVE	T1,FLEN		;GET LENGTH
	TLNE	F,L.LEVD	;SEE IF LEVEL D
	JRST	DLEN		;YES--USE LENGTH
	HLRE	T1,T1		;GET LENGTH FOR ACCESS TEST
	JUMPGE	T1,[ASH T1,7	;SEE IF ALREADY IN BLOCKS
		   JRST DLEN]	;CONVERT TO WORDS
	MOVNS	T1		;NO--CONVERT
DLEN:	TRNE	F,R.WORD	;SEE IF WORDS DESIRED
	JRST	CHKLEN		;YES--LEAVE ALONE
	ADDI	T1,177		;NO--CONVERT TO BLOCKS
	ASH	T1,-7		; ..
CHKLEN:	SKIPE	FALC		;SEE IF FILE ALLOCATED
	SKIPG	S.ALC		;YES--SEE IF USER PREFERS THAT
	JRST	NOTALC		;NO--USE COMPUTED LENGTH
	MOVE	T1,FALC		;YES--PICK UP ALLOCATED LENGTH
	TRNE	F,R.WORD	;SEE IF WORDS NEEDED
	ASH	T1,7		;YES--CONVERT
NOTALC:	SKIPG	S.DTL		;IF /DETAIL, DON'T CLOBBER INFO
	MOVEM	T1,FLEN		;STORE AWAY FOR PRINTING
	ADDM	T1,SNBLKS	;ACCUMULATE TOTALS
	CAMG	T1,S.ACCS	;SEE IF SHORT ENOUGH TO ACCESS
	TRO	F,R.ACCS	;YES--SET FLAG
	SETZM	FRVER		;CLEAR RIB VERSION FOR /DET
	SKIPE	T1,FVER		;SEE IF FILE HAS A VERSION ALREADY
	SKIPLE	S.DTL		;YES--SEE IF /DETAIL
	JRST	.+2		;NO VERSION OR /DET
	JRST	VERNON		;YES--SKIP READING
	MOVEM	T1,FRVER	;SAVE RIB VERSION FOR /DETAIL
	HLRZ	T1,FEXT		;SEE IF VERSION SEARCH USEFUL
	CAIE	T1,(SIXBIT /HGH/)
	CAIN	T1,(SIXBIT /SHR/)
	JRST	VERHGH		;YES--HIGH SEGMENT VARIETY
	CAIE	T1,(SIXBIT /SAV/)
	CAIN	T1,(SIXBIT /LOW/)
	JRST	VERLOW		;YES--LOW SEGMENT VARIETY
	CAIE	T1,(SIXBIT /SVE/)
	JRST	VERNON		;NO--FORGET THE IDEA

VERLOW:	PUSHJ	P,NEXDTW	;GET NEXT IOWD POINTER
	  JRST	VERNOF		;GIVE UP IF EOF
	JUMPE	T1,VERNOF	;GIVE UP IF JUNK
	SKIPA	T2,T1		;SAVE IT
VERLO1:	AOBJP	T2,VERLOW	;IF ALL USED UP, LOOP BACK FOR ANOTHER
	PUSHJ	P,NEXDTW	;GET A DATA WORD
	  JRST	VERNOF		;GIVE UP IF EOF
	HRRZ	T3,T2		;LOOK AT CURRENT ADDRESS
	CAIGE	T3,.JBVER-1	;  (NOTE-T3 IS ADDR-1)
	JRST	VERLO1		;NOT THERE YET SO LOOP BACK FOR MORE
	CAIN	T3,.JBVER-1	;MAKE SURE NOT TOO FAR
	JRST	VERGOT		;A WINNER--GO SAVE IT
	JRST	VERNON		;AND PROCEED
VERHGH:	MOVEI	T2,.JBHVR	;GUESS HOW FAR TO READ
VERHG1:	PUSHJ	P,NEXDTW	;GET NEXT WORD
	  JRST	VERNOF		;GIVE UP IF EOF
	SOJGE	T2,VERHG1	;COUNT AND LOOP UNTIL THERE
VERGOT:	SKIPE	T1		;SEE IF WE GOT SOMETHING
	MOVEM	T1,FVER		;GOT IT! SO SAVE IT
VERNON:
	TRNN	F,R.ACCS	;SEE IF ACCESS NEEDED
	SKIPLE	S.CHK		; OR IF CHECKSUM NEEDED
	JRST	.+2		;YES--READ
	JRST	VERNOF		;NO--DON'T FORCE IT
VERCHK:	PUSHJ	P,NEXDTW	;YES--READ ONE WORD
	  JRST	VERNOF		;DONE IF EOF
	SKIPLE	S.CHK		;SEE IF CHECKSUM NEEDED
	JRST	VERCHK		;YES--KEEP GOING TO EOF
VERNOF:	TLNE	F,L.SVST!L.BKSS  ;SEE IF MAG TAPE
	JRST	FILEND		;YES--SKIP THE CLOSES
	TRZN	F,R.ACCS	;SEE IF ACCESS NEEDED
	JRST	FILNOA		;NO--CLOSE WITHOUT IT
	CLOSE	DC,CL.DAT	;CLOSE AND INDICATE ACCESSED
	JRST	.+2		;AND CONTINUE BELOW
FILNOA:	CLOSE	DC,CL.ACS!CL.DAT  ;DON'T UPDATE ACCESS DATES
FILEND:
;HERE WHEN IT IS TIME TO OUTPUT ONE LINE OF THE DIRECTORY

	SKIPLE	S.DTL		;SEE IF /DETAIL
	JRST	DLIST		;YES--GO ISSUE LISTING
	SKIPLE	S.SUM		;SEE IF SUMMARY MODE
	TRNE	F,R.FAST	;YES--CHECK /F
	JRST	.+2		;YES--GIVE OUTPUT
	POPJ	P,		;NO--SKIP LISTING
	PUSHJ	P,LSTFNM	;LIST FILE NAME
FLEXT:	HLLZ	T2,FEXT		;OUTPUT EXTENSION
	TRNN	F,R.FAST	;SEE IF /F MODE
	JRST	FLEXT3		;NO--GO DO SLOW FORMAT
	PUSHJ	P,LSIXN		;YES--OUTPUT EXT.
	JRST	FLSDIR		;AND END LINE
FLEXT3:	CAMN	T2,['UFD   ']	;SEE IF .UFD
	SKIPGE	FNAM		;AND NUMERIC
	JRST	FLEXT4		;NO--PROCEED
	MOVE	T1,FLEN		;YES--SKIP EXT
	PUSHJ	P,LDEC		;LIST LENGTH
	JRST	FLEXT5		;AND PROCEED
FLEXT4:	MOVEI	T3,3		;AS THREE CHARACTERS
	PUSHJ	P,LSIXC
	PUSHJ	P,LSPC2		;NO--POSITION FOR LENGTH
	MOVE	T1,FLEN		;GET FILE LENGTH
	PUSHJ	P,LDEC4

FLEXT5:	MOVEI	M,[ASCIZ /  </]
	PUSHJ	P,LSTR
	LDB	T1,[POINT 9,FCRE,8]
	PUSHJ	P,LOCT3Z
	MOVEI	M,[ASCIZ />   /]
	PUSHJ	P,LSTR
	SKIPG	S.CHK		;SEE IF CHECKSUM
	JRST	FCHKN		;NO--SKIP OUTPUT
	PUSHJ	P,LCHECK	;LIST CHECKSUM
	PUSHJ	P,LSPC2		;AND SPACE OVER
FCHKN:	TRNN	F,R.SLOW	;SEE IF IN SLOW MODE
	JRST	FCRED		;NO--SKIP ACCESS DATE
	LDB	T4,[POINT 12,FEXT,35]
	PUSHJ	P,LDATE		;OUTPUT ACCESS DATE
	PUSHJ	P,LTAB
	LDB	T4,[POINT 11,FCRE,23]
	PUSHJ	P,LTIMEB	;OUTPUT CREATION TIME
	PUSHJ	P,LTAB
FCRED:	LDB	T4,[POINT 12,FCRE,35]
	PUSHJ	P,LDATE		;OUTPUT CREATION DATE
	TRNN	F,R.SLOW	;SEE IF IN SLOW MODE
	JRST	FLSEND		;NO--SKIP FILE MODE
	PUSHJ	P,LSPC2
	LDB	T1,[POINT 4,FCRE,12]
	PUSHJ	P,LOCT2		;OUTPUT FILE MODE
FLSEND:	MOVE	T4,FVER		;OUTPUT FILE VERSION
	SKIPN	S.SORT		;SEE IF /SORT
	JUMPE	T4,FNVER	;UNLESS 0
	PUSHJ	P,LTAB
	MOVE	P1,NOCHRS	;GET POSITION
	ADDI	P1,7		;ALLOW FOR DELAYED TABBING
	TRZ	P1,7		;TAB OVER
	MOVNS	P1		;PREPARE TO SUBTRACT
	PUSHJ	P,LVER
	ADD	P1,NOCHRS	;GET DISTANCE MOVED BY VERSION
	SKIPLE	S.SORT		;IF /SORT
	CAILE	P1,7		;AND LESS THAN ONE TAB
	JRST	.+2		;NO--OK
	PUSHJ	P,LTAB		;YES--MOVE ANOTHER TAB
FNVER:
FLSDIR:	SKIPN	S.WDTH		;SEE IF /W
	PUSHJ	P,LSTRDR	;NO--OUTPUT STR AND DIRECT.
	TRNN	F,R.FAST	;SEE IF /F
	SKIPN	T2,FSPL		;NO--SEE IF SPOOLED NAME
	JRST	FNSPL		;NO--SKIP OUTPUT
	PUSHJ	P,LTAB		;YES--SPACE OVER
	PUSHJ	P,LSIXN		;AND TYPE SPOOLED NAME
FNSPL:	MOVE	T1,NOCHRS	;SEE IF DONE WITH THIS LINE
	ADDI	T1,^D16		;ROUND UP SOMEWHAT
	CAMG	T1,S.WDTH	;SEE IF OVER REQUEST
	PJRST	LTAB		;NO--GO ISSUE TAB
	PJRST	LCRLF
;HERE TO OUTPUT A DETAILED DIRECTORY LISTING

DLIST:	SKIPE	T2,FDEV		;GET UNIT
	SKIPN	S.UNIT		;IF /NOUNITS
	MOVE	T2,FSTR		;  OR IF UNIT NOT AVAILABLE, USE STR
	PUSHJ	P,LSIX		;LIST IN SIXBIT
	MOVEI	C,":"		;AND PUNCTUATE
	PUSHJ	P,LCHR		; IT
	HLRZ	T1,FEXT		;GET EXTENSION
	CAIN	T1,'UFD'	;SEE IF UFD
	SKIPGE	T4,FNAM		;AND NOT ALPHA
	JRST	DLNAME		;NO--LIST AS ALPHA
	PUSHJ	P,LXWD		;LIST AS XWD
	JRST	DLEXT		;GO HANDLE EXTENSION
DLNAME:	MOVE	T2,FNAM		;GET NAME
	PUSHJ	P,LSIXN		;LIST IN SIXBIT
DLEXT:	MOVEI	C,"."		;LIST
	PUSHJ	P,LCHR		;PUNCTUATION
	HLLZ	T2,FEXT		;GET EXTENSION
	PUSHJ	P,LSIXN		;LIST IT
	MOVEI	P1,0		;CLEAR OFFSET POINTER
	PUSHJ	P,FLBDIR	;LIST DIRECTORY WITH []

	DEFINE	MSG(A),<
	MOVEI	M,[ASCIZ /
A: /]
	PUSHJ	P,LSTR
	>

	HRRZ	T4,FEXT		;GET ACCESS DATE
	JUMPE	T4,DLCREA
	MSG	<Access date>
	PUSHJ	P,LDATE
DLCREA:	MOVE	T4,FCRE		;GET CREATION
	TLZ	T4,777740	; TIME AND DATE
	JUMPE	T4,DLPROT
	MSG	<Creation time, date>
	LSH	T4,-^D12	;POSITION TIME
	PUSHJ	P,LTIME
	PUSHJ	P,LSPC		;MAKE SOME ROOM
	HRRZ	T4,FCRE		;GET DATE
	ANDI	T4,7777
	PUSHJ	P,LDATE
DLPROT:	MSG	<Access protection>
	LDB	T1,[POINT 9,FCRE,8]
	PUSHJ	P,LOCT3Z
	MSG	<Mode>
	LDB	T1,[POINT 4,FCRE,12]
	PUSHJ	P,LOCT
	MOVE	T1,FLEN		;GET FILE LENGTH
	SKIPE	RIBLEN		;SEE IF EXTENDED LOOKUP
	JRST	DLSIZE		;YES--GO LIST LENGTH
	HLRE	T1,T1		;NO--GET LEVEL-C STYLE
	SKIPLE	T1		;SEE IF IN BLOCKS
	ASH	T1,7		;YES--MAKE INTO WORDS
	MOVM	T1,T1		;GET NUMBER OF WORDS
DLSIZE:	JUMPE	T1,DLVERS
	MSG	<Words written>
	PUSHJ	P,LDECP

DLVERS:	SKIPN	T4,FVER		;GET VERSION
	JRST	DLVERR
	MSG	<Version>
	PUSHJ	P,LVER
DLVERR:	SKIPE	T4,FRVER	;SEE IF RIB VERSION DIFFERENT
	CAMN	T4,FVER		; FROM FILE VERSION
	JRST	DLCHEK		;NO--PROCEED
	MSG	<RIB version>
	PUSHJ	P,LVER		;OUTPUT RIB VERSION NUMBER
DLCHEK:	SKIPG	S.CHK		;SEE IF /CHECKSUM
	JRST	DLSPOL		;NO--SKIP ON
	MSG	<Computed checksum>
	PUSHJ	P,LCHECK

DLSPOL:	SKIPN	T2,FSPL		;GET SPOOLED FILE NAME
	JRST	DLESTL
	MSG	<Spooled name in ENTER>
	PUSHJ	P,LSIXN
DLESTL:	SKIPN	T1,FEST		;GET ESTIMATED LENGTH
	JRST	DLALLB
	MSG	<Estimated length>
	PUSHJ	P,LDECP
DLALLB:	SKIPN	T1,FALC		;GET ALLOCATED LENGTH
	JRST	DLALLP
	MSG	<Blocks allocated>
	PUSHJ	P,LDECP
DLALLP:	SKIPN	T1,FPOS		;GET POSITION ALLOCATED
	JRST	DLFUT1
	MSG	<Position of last allocation>
	PUSHJ	P,LDECP
DLFUT1:	SKIPN	T1,FFT1		;GET DEC FUTURE
	JRST	DLNCAR
	MSG	<Future DEC argument>
	PUSHJ	P,LOCT
DLNCAR:	SKIPN	T1,FNCA		;GET CUST ARG
	JRST	DLMTAP
	MSG	<Nonprivileged customer arg>
	PUSHJ	P,LOCT
DLMTAP:	SKIPN	T2,FMTA		;GET BACKUP TAPE
	JRST	DLSTAT
	MSG	<Backup tape>
	PUSHJ	P,LSIXN

DLSTAT:	MOVE	T1,FSTS		;GET STATUS BITS
	HLRZ	T2,FEXT		;SEE WHAT KIND OF FILE
	CAIE	T2,'UFD'	;IF KNOWN DIRECTORY,
	CAIN	T2,'SFD'	; ..
	TXC	T1,<RP.LOG!RP.DIR!RP.ABC>  ;CORRECT STANDARD SETTINGS
	JUMPE	T1,DLERRB
	MOVE	T1,FSTS		;GET BACK STATUS
	MSG	<Status bits>
	PUSHJ	P,LOCT
DLERRB:	MOVE	T1,FELB		;GET ERROR BLOCK
	IOR	T1,FEUN		;INCLUDE ERROR UNIT AND COUNT
	JUMPE	T1,DLQUTF
	MSG	<Error logical block>
	MOVE	T1,FELB		;GET ERROR BLOCK
	PUSHJ	P,LDECP
	MSG	<Error unit>
	HLRZ	T1,FEUN		;GET ERROR UNIT
	PUSHJ	P,LDECP
	MSG	<Number of bad blocks>
	HRRZ	T1,FEUN		;GET ERROR LENGTH IN BLOCKS
	PUSHJ	P,LDECP
DLQUTF:	MOVE	T1,FQTF		;GET QUOTAS
	IOR	T1,FQTO
	IOR	T1,FQTR
	IOR	T1,FUSD		;AND BLOCKS USED
	HLRZ	T2,FEXT		;AND EXTENSION
	CAIE	T2,'UFD'	;IF NOT UFD
	JUMPE	T1,DLAUTH	;AND ZERO, SKIP ON
	MSG	<Logged in quota>
	MOVE	T1,FQTF		;GET FCFS QUOTA
	PUSHJ	P,LDECP
	MSG	<Logged out quota>
	MOVE	T1,FQTO		;GET LOGGED OUT QUOTA
	PUSHJ	P,LDECP
	SKIPN	T1,FQTR		;GET RESERVED BLOCKS
	JRST	DLUSED
	MSG	<Reserved quota>
	PUSHJ	P,LDECP
DLUSED:	MSG	<Blocks used>
	MOVE	T1,FUSD
	PUSHJ	P,LDECP

DLAUTH:	HLRZ	T1,FEXT		;SEE IF
	CAIE	T1,'UFD'	; DIRECTORY
	JRST	DLAUTF		;NO--PROCEED
	MOVE	T1,FNAM		;YES--AUTHOR IS NORMALLY UFD NAME
	JRST	DLAUTC		;SO GO DO IT
DLAUTF:	SKIPN	T1,UFDPPN	;GET OWNER OF FILE
	MOVE	T1,MYPPN	;IF NONE, USE SELF
	TLNN	T1,-1		;SEE IF SFD POINTER
	MOVE	T1,2(T1)	;YES--GET UFD
DLAUTC:	SKIPE	T4,FAUT		;GET AUTHOR
	CAMN	T4,T1		;SEE IF SAME AS OWNER
	JRST	DLNXTS		;YES--PROCEED BELOW
	MSG	<Author>
	JUMPL	T4,DLAUAL	;IF ALPHA, GO BELOW
	PUSHJ	P,LXWD
	JRST	DLNXTS
DLAUAL:	MOVE	T2,T4
	PUSHJ	P,LSIXN
DLNXTS:	SKIPN	T2,FNXT		;GET NEXT STR
	JRST	DLPRVS
	MSG	<Next str>
	PUSHJ	P,LSIXN
DLPRVS:	SKIPN	T2,FPRD		;GET PREVIOUS STR
	JRST	DLPCAR
	MSG	<Previous str>
	PUSHJ	P,LSIXN
DLPCAR:	SKIPN	T1,FPCA		;GET PRIV CUST ARG
	JRST	DLUFDB
	MSG	<Privileged customer arg>
	PUSHJ	P,LOCT
DLUFDB:	SKIPN	T1,FUFD		;GET DIRECTORY POINTER
	JRST	DLFLR
	MSG	<Data block in directory>
	PUSHJ	P,LDECP

DLFLR:	SKIPN	T1,FFLR		;GET RELATIVE BLOCK IN FILE
	JRST	DLXRA		;NONE--SKIP ON
	MSG	<Relative block in file>
	PUSHJ	P,LDECP
DLXRA:	SKIPN	T1,FXRA		;GET POINTER TO NEXT RIB
	JRST	DLTIM		;NONE--DO REST
	MSG	<Pointer to next RIB>
	PUSHJ	P,LOCT		;LIST IN OCTAL
DLTIM:	SKIPN	T1,FTIM		;GET INTERNAL CREATION TIME
	JRST	DLXTRA		;NONE--PROCEED
	MSG	<Internal creation date,time>
	PUSHJ	P,.CNTDT##	;CONVERT TO EASY FORMAT
	PUSH	P,T1		;SAVE TIME
	MOVE	T4,T2		;POSITION DATE
	PUSHJ	P,LDATE		;LIST DATE
	PUSHJ	P,LSPC		;SPACE OVER
	POP	P,T4		;RESTORE TIME
	IDIVI	T4,^D60000	;GET MINS
	PUSHJ	P,LTIME		;LIST HH:MM
	MOVE	T1,P1		;GET MILLI-SECS
	IDIVI	T1,^D1000	;CONVERT TO SECS
	PUSHJ	P,LTIMES	;LIST :SS

;HERE WHEN ALL DONE, PRINT IN OCTAL ANY MORE THAT EXIST

DLXTRA:	MOVEI	P1,.RBXTR	;POINT TO FIRST UNDEFINED AREA
	HRLI	P1,.RBXTR-LN.RIB  ;AND COUNT OF ARGS
DLXTRL:	SKIPN	LBLOCK(P1)	;GET NEXT WORD
	JRST	DLXTRC
	MOVEI	M,[ASCIZ /
Unknown arg #/]
	PUSHJ	P,LSTR
	MOVEI	T1,(P1)		;GET POSITION
	PUSHJ	P,LOCT
	MOVEI	M,[ASCIZ /: /]
	PUSHJ	P,LSTR
	MOVE	T1,LBLOCK(P1)
	PUSHJ	P,LOCT
DLXTRC:	AOBJN	P1,DLXTRL	;LOOP UNTIL DONE

	PUSHJ	P,LCRLF		;END LINE
	PJRST	LCRLF		;ISSUE BLANK LINE AND RETURN
;NEXDTW -- READ ONE WORD COMPUTING CHECKSUM
;CALL:	PUSHJ	P,NEXDTW
;RETURN CPOPJ IF END OF FILE
;SKIP RETURN WITH DATUM IN T1
;USES M, C

NEXDTW:	TLNE	F,L.FKEF	;SEE IF FAKE EOF SET
	POPJ	P,		;YES--GIVE IT AGAIN
	TLZE	F,L.SVDW	;SEE IF SAVED WORD
	JRST	[MOVE	T1,MTSVWD
		 JRST	NEXDT3]
	TLNE	F,L.BKSS	;SEE IF BACKUP SAVE SET
	JRST	NEXDT1		;YES--GO HANDLE IT
	SKIPN	B.DC+2		;NO--SEE IF READY TO READ NEXT RECORD
	TLNN	F,L.SVST	;AND IS FAILSAFE SAVE SET MODE
	JRST	NEXDT2		;NO--JUST PROCEED
	PUSHJ	P,.NXDTW	;YES--READ THE NEXT WORD
	  POPJ	P,		;EOF--ALL DONE
	TLNN	T1,-1		;SEE IF MORE DATA
	JRST	NEXDT2		;YES--GO READ DATA WORD
	MOVEM	T1,MTSVHD	;NO--SAVE HEADER
	TLO	F,L.FKEF	;AND SET FAKE EOF
	POPJ	P,		;RETURN EOF

;HERE FOR BACKUP SAVE SETS

NEXDT1:	SOSLE	MTSVCT		;DECREMENT COUNT
	JRST	NEXDT2		;STILL IN THIS HEADER
	PUSHJ	P,.NXDTW	;GET NEXT HEADER
	  POPJ	P,		;RETURN IF EOF
	MOVEM	T1,MTSVWD	;SAVE WORD IN CASE
	TRZ	T1,777000	;CLEAR BACK POINTER
	HRRZM	T1,MTSVCT	;SET COUNT
	HLRZS	T1		;GET CONTROL HEADER
	CAIE	T1,400000	;IS IT DATA?
	JRST	[TLO F,L.FKEF!L.SVDW  ;SET FLAGS
		 JRST NEXDT4]	;GIVE EOF RETURN
	PUSHJ	P,.NXDTW	;THROW AWAY CHECKSUM
	  POPJ	P,		;EOF
	JRST	NEXDT2		;GO DO NORMAL READ NOW
NEXDT2:	PUSHJ	P,.NXDTW	;READ FILE
	  JRST	NEXDT4		;RETURN IF EOF
NEXDT3:	EXCH	T1,CHKSUM	;GET CHECKSUM SO FAR
	ROT	T1,1		;ROTATE
	ADD	T1,CHKSUM	;ADD THIS WORD
	EXCH	T1,CHKSUM	;STORE AWAY
	EXCH	T1,SCHKSM	;GET CHECKSUM SO FAR
	ROT	T1,1		;ROTATE
	ADD	T1,SCHKSM	;ADD THIS WORD
	EXCH	T1,SCHKSM	;STORE AWAY
	EXCH	T1,TCHKSM	;GET CHECKSUM SO FAR
	ROT	T1,1		;ROTATE
	ADD	T1,TCHKSM	;ADD THIS WORD
	EXCH	T1,TCHKSM	;STORE AWAY
	JRST	.POPJ1		;AND SKIP RETURN

NEXDT4:	SETZM	MTSVCT		;CLEAR COUNTER
	POPJ	P,		;RETURN
;CHKNXF -- CHECK FOR PREVIOUS SPEC. WAS NON-EXISTENT EVERY PLACE
;PRESERVES T1-4

CHKNXF:	CAMN	I,LASI		;SEE IF STILL SAME REQUEST
	POPJ	P,		;YES--DON'T WORRY YET
	MOVEM	I,LASI		;SAVE LAST REQUEST
	SKIPN	NXFCNT		;SEE IF ANY FILE FOUND
	SKIPN	NXFI		;NO--SEE IF ERROR FOUND
	JRST	CHKNXY		;NO--JUST CLEAN UP AND RETURN
	PUSH	P,T1		;PRESERVE T1-4
	PUSH	P,T2	
	PUSH	P,T3
	PUSH	P,T4
	EXCH	I,NXFI		;GET OLD I
	MOVEI	T1,H.ZERX-H.ZER1  ;POINT TO OLD COPY AREA
	MOVE	T2,I.DEV(I)	;GET ORIGINAL DEVICE REQUESTED
	MOVEM	T2,FSTR(T1)	;SAVE AWAY FOR LATER
	HLLZS	FEXT(T1)	;CLEAR ERROR CODE
	SKIPN	NXUCNT		;SEE IF UFD FOUND
	JRST	[MOVEI T2,1	;NO--SET UFD NOT FOUND
		 SKIPE NXSCNT	;SEE IF SFD MISSING
		 MOVEI T2,23	;YES--SET THAT CODE
		 HRRM  T2,FEXT(T1)  ;AND STORE THE
		 JRST  .+1]	;  CODE AWAY
	PUSHJ	P,E.DFLS	;ISSUE ERROR
	MOVE	I,NXFI		;RESTORE I
	POP	P,T4		;RESTORE T1-4
	POP	P,T3
	POP	P,T2
	POP	P,T1

CHKNXY:	SETZM	NXFI		;CLEAR ERROR FLAG
	SETZM	NXFCNT		;CLEAR FOUND COUNT
	SETZM	NXSCNT		;CLEAR NX SFD COUNT
	POPJ	P,		;RETURN
;SUBROUTINE IF LOOKUP ERROR

E.DFLL:	HRRZ	T1,FEXT		;GET ERROR CODE
	CAIE	T1,23		;SEE IF NX SFD
	CAIG	T1,1		;NO--SEE IF NX FILE OR NX UFD
	SKIPG	.WLDFL		;YES--SEE IF STR WILDCARDING
	JRST	E.DFLC		;NO--ISSUE MESSAGE NOW ANYWAY
	SKIPN	T1		;SEE IF UFD PRESENT
	AOS	NXUCNT		;NON-X FILE
	CAIN	T1,23		;SEE IF SFD
	AOS	NXSCNT		;YES--COUNT IT
	MOVEM	I,NXFI		;YES--SAVE I AS FLAG FOR LATER
				;THIS IS NEEDED BECAUSE WE WISH TO
				; GIVE NX FILE MESSAGE ONLY IF IT DOES
				; NOT EXIST ON ANY STR IN THE LIST
	MOVE	T1,[H.ZER1,,H.ZERX]
	BLT	T1,H.ZERY-1	;COPY TO BACKUP AREA
IFN FTSFD,<
	SKIPE	T1,UFDPPN	;SEE IF SFD TO COPY
	TLNE	T1,-1		;  ..
	POPJ	P,		;NO--RETURN
	HRLZ	T1,T1		;YES--COPY TO BACKUP
	HRRI	T1,H.ZERY	;  AREA
	BLT	T1,H.ZERY+2+LN.DRB  ; ..
>
	POPJ	P,		;GO AROUND THE LOOP

E.DFLC:	MOVEI	T1,0		;POINT TO REGULAR AREA
	PUSHJ	P,E.DFLS	;ISSUE ERROR MESSAGE
	AOS	SNFILR		;COUNT LOOKUP ERROR
	AOS	NXFCNT		;COUNT FILE FOUND
	POPJ	P,		;AND GO AROUND LOOP
;E.DFLS -- SUBROUTINE TO PRINT ERROR IN FILE LINE
;T1 MUST BE SET TO 0 FOR REGULAR AREA
;USES T1, T2, T3, T4, M, C

E.DFLS:	PUSHJ	P,.SAVE1##	;SAVE P1
	MOVE	P1,T1		;SAVE POINTER THERE
	PUSHJ	P,.TNEWL	;FORCE BEGINNING OF LINE
	TRO	F,R.TYPE	;FLAG FOR DUPLICATE ON TTY
	PUSHJ	P,SSTRDR
	PUSHJ	P,LSTFNX	;LIST FILE NAME
	HLLZ	T2,FEXT(P1)	;GET EXTENSION
	PUSHJ	P,LSIXT		;LIST IT
	MOVEI	T1,.CHTAB	;PICK UP TAB
	PUSHJ	P,.TTCHR	; AND TYPE IT
	HRRZ	T1,FEXT(P1)	;GET ERROR CODE
	MOVE	T3,FCRE(P1)	;GET LOOKUP ANSWER (PROT. CODE)
	TRZ	F,R.TYPE	;CLEAR FLAG
	PUSHJ	P,.LKERR	;LIST ERROR CODE
	TRO	F,R.TYPE	;RESET FLAG
	SKIPN	S.WDTH		;SEE IF /WIDTH
	PUSHJ	P,LSTRDX	;LIST STR/DIR
	TRZ	F,R.TYPE	;CLEAR FLAG
	PJRST	.TCRLF		;END LINE
;LSTFNM -- LIST FILE NAME IN APPROPRIATE MODE
;USES T1, T2, T3, T4

LSTFNM:	PUSHJ	P,.SAVE1	;SAVE P1
	MOVEI	P1,0		;SET TO NO OFFSET
LSTFNX:	HLRZ	T1,FEXT(P1)	;LOOK AT EXTENSION
	CAIN	T1,'UFD'	;TO SEE IF IT IS A UFD
	SKIPGE	FNAM(P1)	;YES--SEE IF ALPHA
	JRST	.+2		;YES--USE SIXBIT ANYWAY
	JRST	FLUFD		;NO--SPECIAL PRINT
	MOVE	T2,FNAM(P1)	;OUTPUT FILE NAME
	PUSHJ	P,LSIXT
	POPJ	P,		;AND RETURN

FLUFD:	HLRZ	T1,FNAM(P1)	;GET PROJECT
	PUSHJ	P,LOCT6B	;ISSUE RIGHT ADJUSTED
	MOVEI	C,","		;ISSUE COMMA
	PUSHJ	P,LCHR		; ..
	HRRZ	T1,FNAM(P1)	;GET PROGRAMMER
	PUSHJ	P,LOCT		;ISSUE LEFT ADJUSTED
	PJRST	LTAB		;FOLOWED BY TAB
;SSTRDR -- SET FLAGS TO LIST STR AND OR DIRECTORY
;CALL:	PUSHJ	P,SSTRDR
;	WITH I AND P1 SETUP
;USES T1-4

SSTRDR:	MOVE	T1,FSTR(P1)	;SEE IF SAME FILE STRUCTURE
	CAMN	T1,[SIXBIT /DSK/]
	SKIPE	LASSTR		;IS IT THE FIRST ONE?
	JRST	.+2		;NO--PRINT IT
	MOVEI	T1,0		;IF FIRST DSK, NEVER PRINT
	MOVEM	T1,LSTSTR	;SAVE FOR PRINTING
	EXCH	T1,LASSTR	;UPDATE MEMORY
	CAMN	T1,LASSTR	;SEE IF DIFFERENT
	SETZM	LSTSTR		;SAME--FLAG TO NOT PRINT

	MOVEI	T3,(I)		;POINT TO DIRECTORIES
	HRLI	T3,-LN.DRB	;SET COUNT
SSTRD1:	SKIPN	I.DIR-I.DEV(T3)	;SEE IF NULL DIRECTORY
	SKIPE	T2,I.DIRM-I.DEV(T3)  ;YES--USE WILDCARD STRAIGHT
	SETCM	T2,I.DIRM-I.DEV(T3)
IFN FTSFD,<
	JUMPN	T2,SSTRD2	;IF WILD--PROCEED
	AOS	T3		;ADVANCE EXTRA SHOT
	SKIPN	I.DIRM-I.DEV-2(T3)  ;SEE IF AT END
	SKIPE	I.DIRM-I.DEV-1(T3)  ; ..
	AOBJN	T3,SSTRD1	;LOOP UNTIL DONE
	MOVEI	T2,0		;FLAG NOT WILD DIRECTORY
SSTRD2:
>

;HERE WITH T2=0 IF WILD DIRECTORY, .NE. 0 IF NOT
;COPY THIS DIRECTORY TO OLD ONE WATCHING FOR CHANGES

	MOVE	T1,UFDPPN(P1)	;SEE IF SAME DIRECTORY
	MOVEM	T1,LSTDIR	;SAVE FOR LISTING
	EXCH	T1,LASDIR	;UPDATE MEMORY
IFN FTSFD,<PUSH P,T2
	MOVE	T2,T1		;SETUP POINTER TO OLD AREA
	MOVE	T3,UFDPPN(P1)	;  AND TO NEW AREA
	TLNN	T2,-1		;SEE IF PATHS
	TLNE	T3,-1		;  ..
	JRST	SSTRD4		;NO--PROCEED
	MOVEI	T2,LASPTH	;POINT TO LAST PATH
	HRLI	T3,-LN.DRB	;SET LOOP COUNTER
SSTRD3:	MOVE	T4,2(T3)	;GET NEW DIRECTORY
	CAME	T4,2(T2)	;SEE IF SAME AS OLD ONE
	SETOM	T1		;NO--SET DIFFERENT FLAG
	MOVEM	T4,2(T2)	;STORE FOR OLD MEMORY
	AOS	T2		;ADVANCE OLD POINTER
	SKIPE	T4		;SEE IF END OF PATH YET
	AOBJN	T3,SSTRD3	;NO--LOOP UNTIL DONE
	CAME	T1,[-1]		;SEE IF DIFFERENT
	MOVE	T1,LASDIR	;SAME--FAKE OUT CHECK BELOW
SSTRD4:>

;HERE WITH T1=OLD DIRECTORY (OR -1 IF KNOWN DIFFERENT)
;AND WITH T2=0 IF NO DIRECTORY WILDCARD REQUESTED

	CAMN	T1,LASDIR	;NO--SEE IF CHANGED
	SETZM	LSTDIR		;NO--CLEAR LISTING FLAG

	TRNE	F,R.FAST	;SEE IF /F
	SKIPLE	S.SUM		;YES--SEE IF /SUM
	JRST	.+2		;/F/SUM OR NOT /F
	JRST	SSTRD6		;/F AND NOT /SUM--NO SUBTOTALS
	SKIPN	LSTSTR		;SEE IF SEVERAL STRS
	SKIPE	LSTDIR		;OR SEVERAL DIRS
	PUSHJ	P,SUBTOT	;YES--ISSUE SUBTOTALS
	MOVE	T1,LASSTR	;GET LAST STRUCTURE
	MOVEM	T1,SUBSTR	;SAVE FOR SUBTOTALS
IFE FTSFD,<
	MOVE	T1,LASDIR>
IFN FTSFD,<
	SKIPE	T1,LASDIR	;GET LAST DIRECTORY
	TLNE	T1,-1		;SEE IF PATH POINTER
	JRST	SSTRD5		;NO--JUST STORE WORD
	HRLZS	T1		;SET AS FROM POINTER
	HRRI	T1,SUBPTH	;SET TO POINTER
	BLT	T1,SUBEND	;COPY PATH
	MOVEI	T1,SUBPTH	;SET POINTER TO SUBTOTAL PATH
SSTRD5:>
	MOVEM	T1,SUBDIR	;SAVE SUBTOTAL DIRECTORY
SSTRD6:
IFN FTSFD,<
	POP	P,T2		;RESTORE WILD FLAG
>
	SKIPN	S.SORT		;SEE IF SORTING
	JRST	SSTRD7		;NO--PROCEED
	SETOM	LSTSTR		;YES--SET TO LIST
	SETOM	LSTDIR		;LIST DIRECTORY
	SKIPGE	T1,.WLDFL	;SEE IF WILD STR
	SETCM	T1,T1		;  OR WILD FILE AND STR
	CAIE	T1,1		; ..
	SETZM	LSTSTR		;NO--CLEAR LIST
	SKIPN	T2		;CHECK WILD DIRECT
	SETZM	LSTDIR		;NO--CLEAR LIST DIRECT
SSTRD7:	SKIPN	S.WDTH		;SEE IF /W SPECIFIED
	POPJ	P,		;NO--PROCEED
	SKIPN	LSTSTR		;YES--SEE IF CHANGE OF STR
	SKIPE	LSTDIR		; OR OF DIRECTORY
	JRST	.+2		;YES--PRINT THEM
	POPJ	P,		;NO--SKIP OUTPUT
	PUSHJ	P,.TNEWL	;FORCE NEW LINE
	PUSHJ	P,LSTRDX	;PRINT STR AND DIRECTORY
	PJRST	.TNEWL		;SPACE OVER AND RETURN
;LSTRDR -- LIST STRUCTURE AND DIRECTORY IF APPROPRIATE
;CALL:	PUSHJ	P,LSTRDR
;RETURNS
;USES T1, T2, T3, T4, C, M

LSTRDR:	PUSHJ	P,.SAVE1	;SAVE P1
	MOVEI	P1,0		;SET TO NO OFFSET
LSTRDX:	SKIPN	LSTSTR		;SEE IF APPROPRIATE TO LIST
	JRST	FNSTR		;NO--PROCEED
	SKIPE	NOCHRS		;SEE IF INTO LINE
	PUSHJ	P,LTAB		;YES--POSITION
	MOVE	T2,FSTR(P1)
	PUSHJ	P,LSIX		;DO SO IN SIXBIT
	MOVEI	C,":"		;ADD A COLON TO MINIMIZE CONFUSION
	PUSHJ	P,LCHR		;ON THE USER'S PART
FNSTR:	SKIPN	LSTDIR		;SEE IF TIME TO LIST
	POPJ	P,		;NO--PROCEED
FLDIR:	SKIPE	NOCHRS		;SEE IF INTO LINE
	PUSHJ	P,LTAB

;FLBDIR -- SUBROUTINE TO LIST DIRECTORY INSIDE []

FLBDIR:	MOVEI	C,"["
	PUSHJ	P,LCHR
	MOVE	T4,UFDPPN(P1)
	PUSHJ	P,LDIRB
	MOVEI	C,"]"
	PJRST	LCHR		;AND RETURN
SUBTTL	PERFORM DECTAPE DIRECTORY LISTING

;HERE WHEN DEVICE IS A DECTAPE

DTDIR:	MOVX	T1,FX.PHY	;SET /PHYSICAL BIT
	TDZE	T1,I.MOD(I)	;SEE IF /PHYS
	TLOA	T1,(UU.PHS)	;YES--SET UUOO FLAG
	MOVEI	T1,0		;NO--CLEAR FLAGS
	HRRI	T1,17		;OPEN DECTAPE IN STANDARD MODE
	MOVE	T2,I.DEV(I)	;GET DEVICE NAME
	MOVEI	T3,0		;NO BUFFERS
	OPEN	DC,T1		;OPEN
	  PJRST	E.DFO		;IF FAILED
	MOVE	T1,[IOWD 200,DIRB]
	MOVEI	T2,0
	MOVX	T3,%CNVER	;GET MONITOR
	GETTAB	T3,		; VERSION
	  MOVEI	T3,0		; (DEFAULT TO OLD)
	TLZ	T3,-1		;CLEAR CUSTOMER AREA
	CAIL	T3,50311	;SEE IF 504 YET
	JRST	DTDIRP		;YES--USE NEW MODE TO JUST POSITION
	USETI	DC,^D98		;POSITION AHEAD OF DIRECTORY
	INPUT	DC,T1		;READ BLOCK TO FORCE POSITIONING
DTDIRP:	SETSTS	DC,IO.SSD!IO.NSD!17  ;CHANGE TO SPECIAL MODE
	USETI	DC,^D100	;READ DIRECTORY BLOCK
	IN	DC,T1
	  JRST	.+2		;IF OK
	JRST	E.TFR		;IF ERROR READING
	RELEASE	DC,		;GIVE DEVICE BACK NOW

	SKIPE	T2,DIRB+177	;SEE IF TAPE IDENT FIELD
	CAMN	T2,[-1]		;IS 0 OR -1
	JRST	DTDIR1		;YES--DON'T PRINT
	MOVEI	M,[ASCIZ /Tape ID: /]
	PUSHJ	P,LSTR		;LIST NAME
	PUSHJ	P,LSIX		;LIST IDENTIFICATION
	PUSHJ	P,LCRLF		;END OF LINE

DTDIR1:	MOVEI	M,[ASCIZ /Free: /]
	PUSHJ	P,LSTR		;LIST LABEL FOR SPACE
	MOVSI	J,-27		;COUNT FREE BLOCKS
				;  ALSO PRESET J FOR LATER
	PUSHJ	P,DTCNT		;FREE IF IN FILE #0
	PUSHJ	P,LDEC3		;PRINT AS 3 DIGITS
	MOVEI	M,[ASCIZ / blks, /]
	PUSHJ	P,LSTR		;HEADER
	MOVEI	T1,0		;INITIALIZE FREE FILE COUNTER
	MOVEI	T2,26		;INITIALIZE FILE COUNTER
DTDIR2:	SKIPN	DIRB+122(T2)	;LOOK AT FILE NAME FIELD
	ADDI	T1,1		;IF =0, COUNT FREE
	SOJG	T2,DTDIR2	;LOOP FOR 22 FILES
	PUSHJ	P,LDEC2		;PRINT RESULT
	MOVEI	M,[ASCIZ / files/]
	PUSHJ	P,LSTR		;AND FINISH LABELING
	PUSHJ	P,LCRLF		;AND FINISH LINE

;HERE TO LOOP OVER FILES AND PRINT ONE LINE EACH

DTFIL1:	AOBJP	J,DIREND	;INCREMENT TO NEXT FILE
	SKIPN	T1,DIRB+122(J)	;SEE IF IN USE
	JRST	DTFIL1		;NO--LOOP BACK
	MOVEM	T1,FNAM		;SAVE FILE NAME
	HLLZ	T1,DIRB+150(J)	;GET EXTENSION
	MOVEM	T1,FEXT		;SAVE
	SETZM	UFDPPN		;CLEAR DIRECTORY WORD
	PUSHJ	P,ISMATC	;CHECK FOR MATCH
	  JRST	DTFIL1		;NO MATCH--LOOP FOR MORE
	MOVE	T2,FNAM		;GET FILE NAME
	MOVEI	T3,6		;USE 6 SPACES
	PUSHJ	P,LSIXC		;LIST IT
	MOVEI	C,"."		;USE . AS SEPARATOR
	PUSHJ	P,LCHR		;PRINT IT
	HLLZ	T2,FEXT		;GET EXTENSION
	MOVEI	T3,3		;USE 3 SPACES
	PUSHJ	P,LSIXC		;LIST IT
	TRNE	F,R.FAST	;SEE IF /FAST SWITCH
	JRST	DTFIL2		;YES--THAT'S ALL
	PUSHJ	P,LSPC		;NO--ADD A SPACE
	PUSHJ	P,DTCNT		;COUNT BLOCKS
	PUSHJ	P,LDEC3		;TYPE AS THREE DIGITS
	PUSHJ	P,LSPC2		;TYPE TWO SPACES
	LDB	T4,[POINT 12,DIRB+150(J),35]	;GET CREATION
	PUSHJ	P,LDATE		;LIST CREATION DATE
DTFIL2:	PUSHJ	P,LCRLF		;AND END LINE
	JRST	DTFIL1		;LOOP BACK FOR MORE

;DTCNT -- ROUTINE TO COUNT NUMBER OF BLOCKS IN A FILE
;CALL:	HRRI	J,FILE NUMBER (0-22)
;	PUSHJ	P,DTCNT
;	RETURN	WITH T1=NUMBER OF BLOCKS ALLOCATED
;USES T2, T3, T4

DTCNT:	MOVEI	T1,0		;PRESET COUNT
	MOVE	T2,[POINT 5,DIRB]	;PRESET POINTER TO ALLOCATION TABLE
	MOVEI	T3,1101		;PRESET COUNT OF NUMBER ON TAPE
DTCNT1:	ILDB	T4,T2		;PICK UP FILE OF NEXT BLOCK ON TAPE
	CAIN	T4,(J)		;COMPARE WITH REQUEST
	ADDI	T1,1		;MATCHES--COUNT
	SOJG	T3,DTCNT1	;LOOP OVER ENTIRE TAPE
	POPJ	P,		;RETURN


;ERRORS

E.TFR:	GETSTS	DC,P3		;GET STATUS
	N.FAIO	<Data error reading dectape directory, status>

E.NDD:	MOVE	P3,I.DEV(I)
	N.FAIN	<Input device not a directory device>
E.UDV:	MOVE	P3,I.DEV(I)
	N.FAIN	<Input device of unknown type>
E.NSD:	MOVE	P3,I.DEV(I)
	N.FAIN	<No such device>
SUBTTL	PERFORM TMPCOR DIRECTORY LISTING

;HERE WHEN DEVICE IS "TMP:" AND DOES NOT EXIST

TMPDIR:	TRO	F,R.WORD	;SET WORD MODE
	MOVE	T2,[.TCRRD,,[0
			     IOWD 200,DIRB]]
	TMPCOR	T2,		;GET DIRECTORY
	  JRST	E.NTD		;ERROR IF NOT IMPLEMENTED
	MOVEI	T1,[ASCIZ /
% More than 200 files in TMPCOR
/]
	CAILE	T2,200		;SEE IF DIRECTORY OVERFLOW
	PUSHJ	P,.TSTRG
	MOVE	J,[IOWD 200,DIRB]
	MOVEI	M,[ASCIZ /TMPCOR directory
Free: /]
	PUSHJ	P,LSTR		;OUTPUT HEADING
	MOVEI	T1,.TCRFS	;GET FREE COUNT
	TMPCOR	T1,		;FROM MONITOR
	  JRST	E.NTD		;IF POSSIBLE
	PUSHJ	P,LDEC		;AND TELL USER
	PUSHJ	P,LCRLF		;THEN END LINE

TMPDRL:	AOBJP	J,DIREND	;SEE IF DONE
	SKIPN	T2,(J)		;SEE IF ENTRY NEXT
	JRST	TMPDRL		;NO--LOOP BACK
	TRZ	T2,-1		;CLEAR JUNK
	MOVEM	T2,FNAM		;SAVE NAME
	SETZM	FEXT		;CLEAR EXTENSION
	SETZM	UFDPPN		;CLEAR DIRECTORY
	PUSHJ	P,ISMATC	;SEE IF IT MATCHES
	  JRST	TMPDRL		;NO--LOOP FOR MORE
	MOVE	T2,FNAM		;GET NAME
	MOVEI	T3,4		;OUTPUT 4 CHARS
	PUSHJ	P,LSIXC		; (3 FOR NAME AND ONE SPACE)
	HRRZ	T1,(J)		;GET FILE LENGTH
	ADDM	T1,NOBLKS	;COUNT IN TOTAL BLOCKS (REALLY WORDS)
	PUSHJ	P,LDEC2		;OUTPUT LENGTH
	PUSHJ	P,LCRLF		;END THE LINE
	JRST	TMPDRL		;AND LOOP BACK
;ERRORS

E.NTD:	N.FAIL	<TMPCOR not supported in this monitor>


;HERE AT END OF A NON-DISK DIRECTORY

DIREND:	PUSHJ	P,DIRE		;OUTPUT SUMMARY AND TOTAL LINE
	TRZ	F,R.WORD	;CLEAR WORD MODE
	MOVE	I,.WILAS	;GET END OF SET
	MOVEM	I,I.NXRD	;SET FOR MASTER LOOP
	POPJ	P,		;RETURN
	SUBTTL	MISC. DIRECTORY SUBROUTINES

;ISMATC -- ROUTINE TO SEE IF PROPOSED FILE MATCHES REQUEST
;CALL:	SETUP LOOKBL
;	PUSHJ	P,ISMATC
;	  BAD MATCH
;	WIN WITH I POINTING TO AREA
;USES T1-3

ISMATC:	AOS	NOFIL		;COUNT FILE DISCOVERED
	MOVE	I,.WIFIR	;SET TO START OF + SET
ISMATL:	MOVE	T1,FNAM		;GET NAME
	XOR	T1,I.NAM(I)	;CHECK
	HLLZ	T2,FEXT		;GET EXTENSION
	XOR	T2,I.EXT(I)	;CHECK, SET MASK IN RH(T2)
	TDNN	T1,I.NAMM(I)	;TEST NAME
	TLNE	T2,(T2)		;TEST EXTENSION
	JRST	ISMATF		;FAIL--GO LOOP
	SKIPN	T1,UFDPPN	;GET DIRECTORY
	JRST	ISMATW		;IF NONE, WE WIN
IFN FTSFD,<
	TLNE	T1,-1		;SEE IF SFD POINTER
	JRST	ISMATU		;NO--GO HANDLE UFD

;HERE WHEN FILE IS IN AN SFD
	MOVEI	T2,(I)		;POINT TO DIRECTORY
ISMATS:	MOVE	T3,2(T1)	;GET NEXT LEVEL DIRECTORY
	XOR	T3,I.DIR(T2)	;SEE IF MATCH
	TDNE	T3,I.DIRM(T2)	;TEST
	JRST	ISMATF		;FAIL--GO TRY A DIFFERENT ONE
	SKIPN	2(T1)		;SEE IF AT END OF LIST
	JRST	ISMATW		;YES--WINNER
	ADDI	T2,2		;ADVANCE TO NEXT TEST
	AOJA	T1,ISMATS	;LOOP OVER DIRECTORIES
>

;HERE IF FILE IS IN A UFD
ISMATU:	XOR	T1,I.DIR(I)	;TEST
IFN FTSFD,<
	SKIPE	I.DIR+2(I)	;MAKE SURE SFD IS WILD
	SKIPN	I.DIRM+2(I)	;OR 0
>
	TDNE	T1,I.DIRM(I)	;TEST MATCH
	JRST	ISMATF		;FAIL--LOOP
ISMATW:	AOS	NOFILF		;COUNT FILE FOUND
	JRST	.POPJ1		;WIN

;HERE IF FAIL--TRY NEXT REQUEST
ISMATF:	ADDI	I,I.LZER	;ADVANCE TO NEXT REQUEST
	CAMG	I,.WILAS	;SEE IF DONE
	JRST	ISMATL		;NO--TRY IT
	MOVE	I,.WIFIR	;RESET I FOR OTHERS
	POPJ	P,		;YES--GIVE UP
;SUBTOT -- ROUTINE TO ISSUE SUBTOTALS
;USES T1-4

SUBTOT:	AOS	NUMDIR		;COUNT DIRECTORY FOUND
	SKIPN	S.SUM		;SEE IF /NOSUM
	POPJ	P,		;YES--NEVER GIVE IT
	PUSHJ	P,.SAVE1	;SAVE P1
	SKIPE	NOCHRS		;SEE IF AT START OF LINE
	PUSHJ	P,LCRLF		;NO--END THIS LINE
	MOVEI	P1,SUBT-TOT	;POINT TO SUBTOTALS
	SKIPLE	S.SUM		;SEE IF /SUM
	JRST	[SKIPN SNFILF	;YES--SEE IF ANYTHING AT ALL
		 SKIPE SNFILR	; (EVEN IF JUST ERRORS)
		 JRST  SUBTDO	;YES--GO DO SUBTOTAL
		 JRST  SUBLOP]	;NO--NICE TRY
	MOVEI	T1,1		;SET ONE
	CAML	T1,SNFILF	;IF MORE THAN ONE FILE
	CAMGE	T1,SNFILR	;OR MORE THAN ONE ERROR
SUBTDO:	PUSHJ	P,TOTALS	;GO ISSUE SUBTOTALS

;HERE FROM END OF DISK TO MOVE SUBT. TO TOT.

SUBLOP:	PUSH	P,TCHKSM	;PRESERVE TOTAL CHECKSUM
	MOVSI	T1,-<SUBT-TOT>	;SET COUNT TO COPY
SUBTL:	MOVE	T2,SUBT(T1)	;GET SUBTOTAL
	ADDM	T2,TOT(T1)	;ADD INTO TOTAL
	SETZM	SUBT(T1)	;CLEAR SUBTOTAL
	AOBJN	T1,SUBTL	;LOOP UNTIL DONE
	POP	P,TCHKSM	;RESTORE TOTAL CHECKSUM
	POPJ	P,		;RETURN
;DIRE  -- OUTPUT EMPTY OR TOTAL LINE
;DIRET -- OUTPUT TOTAL LINE
;CALL:	PUSHJ	P,DIRE/DIRET
;USES T1-4

DIRE:	PUSHJ	P,.TNEWL	;FORCE BEGINNING OF LINE
	MOVEI	T1,[ASCIZ /Directory empty/]
	SKIPE	NOFIL
	MOVEI	T1,[ASCIZ /Directory has no such files/]
	SKIPN	NOFILF
	JRST	DIREL		;GO PRINT MESSAGE
DIRET:	SKIPLE	NUMSUB		;SEE IF ANY SUBTOTALS YET
	PUSHJ	P,SUBTOT	;YES--FINISH UP
	SKIPG	NUMSUB		;SEE IF ANY SUBTOTALS YET
	PUSHJ	P,SUBLOP	;NO--GO SHIFT SUBT. TO TOTALS
	PUSHJ	P,.TNEWL	;FORCE NEW LINE
	MOVE	T1,NOFILR	;GET NUMBER OF LOOKUP ERRORS
	CAIG	T1,1		;SEE IF MORE THAN ONE
	SKIPLE	S.SUM		;OR /SUM
	JRST	DIRETP		;YES--FORCE TOTAL LINE
	MOVE	T1,NOFILF	;SEE HOW MANY FILES FOUND
	CAILE	T1,1		;IF LE 1, NO SUMMARY NEEDED
	SKIPN	NOBLKS		;SEE IF BLOCKS ACCUMULATED
	PJRST	LCRLF		;NO--JUST PRINT BLANK LINE AND RETURN
DIRETP:	SKIPN	S.SUM		;SEE IF /NOSUM
	POPJ	P,		;YES--NEVER DO IT
	SOSG	NUMSUB		;SEE IF SUBTOTALS
	PUSHJ	P,LCRLF		;NO--SEPARATE SUMMARY BY BLANK LINE
	SKPINL			;DEFEAT ^O
	  JFCL			; ..
	PUSHJ	P,.SAVE1	;SAVE P1
	MOVEI	P1,0		;POINT TO TOTALS
	MOVEI	T1,[ASCIZ /  Grand total of /]
	SKIPGE	T2,NUMSUB	;GET NUMBER OF SUBTOTALS
	JRST	TOTALS		;IF NONE, DO TOTAL
	JUMPN	T2,TOTALO	;IF SEVERAL, DO GRAND TOTAL
	MOVE	T2,NUMDIR	;IF ONE, GET NUMBER OF DIRECTORIES
	CAIG	T2,1		;IF MORE THAN ONE, DO GRAND TOTAL

;TOTALS -- ROUTINE TO ISSUE EITHER SUB OR GRAND TOTALS
;CALL:	MOVEI	P1,0 FOR GRAND OR SUBT-TOT FOR SUBS
;USES T1-4

TOTALS:	MOVEI	T1,[ASCIZ /  Total of /]
TOTALO:	PUSHJ	P,.TSTRG	;PRINT HEADING
	AOS	NUMSUB		;COUNT SUBTOTAL
	SKIPN	NOFILF(P1)	;SEE IF ANY FILES
	JRST	[SKIPN NOFILR(P1)  ;NO--SEE IF ANY ERRORS
		 JRST  DIRETF	;NO--SAY 0 FILES
		 JRST  DIRETL]	;YES--TELL ALL
	MOVE	T1,NOBLKS(P1)	;GET NUMBER OF BLOCKS
	PUSHJ	P,.TDECW	;PRINT NUMBER OF BLOCKS
	MOVEI	T1,[ASCIZ / block/]
	TRNE	F,R.WORD	;SEE IF WORD MODE
	MOVEI	T1,[ASCIZ / word/]	;IF SO, CHANGE MESSAGE
	PUSHJ	P,.TSTRG
	MOVE	T2,NOBLKS(P1)	;GET NUMBER OF BLOCKS
	MOVEI	T1,"s"		;MAKE PLURAL IF NEEDED
	CAIE	T2,1		; ..
	PUSHJ	P,.TCHAR	;YES
	MOVEI	T1,[ASCIZ / in /]	;AND REST OF MESSAGE
	PUSHJ	P,.TSTRG	; ..
DIRETF:	MOVE	T1,NOFILF(P1)	;GET NUMBER OF FILES
	PUSHJ	P,.TDECW	;  FOUND AND PRINTED
	MOVEI	T1,[ASCIZ / file/]
	PUSHJ	P,.TSTRG	;OUTPUT LINE
	MOVE	T2,NOFILF(P1)	;GET NUMBER FOUND
	MOVEI	T1,"s"		;GET PLURAL
	CAIE	T2,1		;SEE IF NOT ONE
	PUSHJ	P,.TCHAR	;YES--TYPE PLURAL
	SKIPG	S.CHK		;SEE IF /CHECKSUM
	JRST	DIRETC		;NO--PROCEED
	MOVE	T1,TCHKSM(P1)	;GET AGGRAGATE CHECKSUM
	MOVEM	T1,CHKSUM	;SET FOR PRINTOUT
	SETZM	TCHKSM(P1)	;CLEAR FOR NEXT TIME
	MOVEI	M,[ASCIZ / Checksum = /]
	PUSHJ	P,LSTR
	PUSHJ	P,LCHECK	;LIST CHECKSUM
DIRETC:	SKIPN	NOFILR(P1)	;SEE IF ANY ERRORS
	JRST	DIRELE		;NO--THAT'S ALL
	MOVEI	T1,[ASCIZ / and /]
	PUSHJ	P,.TSTRG	;YES--ISSUE CONNECTIVE
DIRETL:	MOVE	T1,NOFILR(P1)	;GET NUMBER OF ERRORS
	PUSHJ	P,.TDECW	;TYPE THE COUNTER
	MOVEI	T1,[ASCIZ / LOOKUP error/]
	PUSHJ	P,.TSTRG	;TYPE LABEL
	MOVE	T2,NOFILR(P1)	;GET COUNT
	MOVEI	T1,"s"		;GET PLURAL
	CAIE	T2,1		;SEE IF NOT ONE
	PUSHJ	P,.TCHAR	;TYPE PLURAL
	JRST	DIRELE		;AND GO FINISH
DIREL:	PUSHJ	P,.TSTRG
DIRELE:	MOVE	T1,NUMDIR	;SEE HOW MANY DIRECTORIES
	CAILE	T1,1		;SEE IF MORE THAN ONE
	JUMPE	P1,DIRELF	;YES--JUMP IF GRAND TOTAL
	SKIPN	SUBSTR		;SEE IF DEVICE KNOWN
	JRST	DIRELF		;NO--SKIP THIS LINE
	MOVEI	T1,[ASCIZ / on /]
	PUSHJ	P,.TSTRG
	MOVE	T1,SUBSTR	;GET STRUCTURE
	PUSHJ	P,.TSIXN	;LIST IT
	MOVEI	T1,[ASCIZ /: /]
	PUSHJ	P,.TSTRG	;LIST SEPARATION
	MOVEI	T1,SUBDIR	;POINT TO DIRECTORY
	PUSHJ	P,.TDIRB##	;PRINT IT
DIRELF:	PUSHJ	P,.TCRLF
	PJRST	LCRLF
DEFINE	SWTCHS,<
SP ACCESS,S.ACCS,.SWDEC,ACC
SS ALLOCATED,S.ALC,1
SS BLOCKS,S.WORD,0
SS CHECKSUM,S.CHK,1
SS DETAIL,S.DTL,1
SS EOTS,S.EOT,1
SS *FAST,<POINTR (FLAGS,R.FAST!R.SLOW)>,R.FAST/R.FAST
SP FILES,S.FILE,.SWDEC,FIL
SS *LIST,S.DODV,1
SS MARKS,<POINTR (FLAGS,R.MARK)>,1
SS NOCHECKSUM,S.CHK,0
SS NODETAIL,S.DTL,0
SS NOEOTS,S.EOT,0
SS NOMARKS,<POINTR (FLAGS,R.MARK)>,0
SS NOREWINDS,S.REWS,0
SS *NORMAL,<POINTR (FLAGS,R.FAST!R.SLOW)>,0
SS NOSORT,S.SORT,0
SS NOSUMMARY,S.SUM,0
SS NOTITLES,S.TITL,0
SS NOUNITS,S.UNIT,0
SS REWINDS,S.REWS,1
SS *SLOW,<POINTR (FLAGS,R.FAST!R.SLOW)>,R.SLOW/R.FAST
SS SORT,S.SORT,1
SS SUMMARY,S.SUM,1
SS TITLES,S.TITL,1
SS UNITS,S.UNIT,1
SP *WIDTH,S.WDTH,.SWDEC,WID
SS WORDS,S.WORD,1
SS WRITTEN,S.ALC,0
>

	DOSCAN	(DRSWT)
SUBTTL	SUBROUTINES FOR LISTING OUTPUT


;LFERX -- ROUTINE TO CLEAN UP AFTER FATAL ERROR
;THE ROUTINES IN SCAN CANNOT BE USED AFTER ANOTHER PUSHJ

LFERX:	PUSHJ	P,.TCRLF	;ISSUE FINAL <CRLF>
	PUSHJ	P,.CLRBF##	;CLEAR TYPE AHEAD
	RELEAS	LC,		;BIND OFF LISTING
	RESET			;CLEAR I/O AND CORE ASSIGNMENTS
	JRST	MAINLP		;AND TRY AGAIN
;TITLER -- PLACE PAGE TITLE IF USER REQUESTED ONE
;CALLED AT START OF FIRST PAGE AND END OF EACH PAGE BUT LAST
;CALL:	PUSHJ	P,TITLER

TITLER:	PUSHJ	P,SAVTYP	;CLEAR R.TYPE AND SAVE OLD VALUE
	PUSH	P,M		;PRESERVE POINTER
	PUSH	P,C		;PRESERVE CHARACTER
	SKIPG	S.TITL		;SEE IF TITLES ON
	JRST	TITLEY		;NO--RETURN
	MOVEI	M,LN.LPP+2	;RESET LINES THIS PAGE COUNT
	MOVEM	M,LNPP		; ..
	TRON	F,R.LSOM	;SEE IF FIRST CALL
	JRST	TITLEH		;YES--SKIP BIND-OFF OF PREVIOUS PAGE
	MOVEI	C,.CHFFD	;EJECT TO NEW PAGE
	PUSHJ	P,LCHR		; ..

;HERE WHEN IT IS DESIRED TO OUTPUT A PAGE HEADER

TITLEH:	PUSH	P,T1		;SAVE T1-P1
	PUSH	P,T2
	PUSH	P,T3
	PUSH	P,T4
	PUSH	P,P1
	MOVEI	M,[ASCIZ /	Directory listing	/]
	PUSHJ	P,LSTR		;SEND START OF LINE 1
	DATE	T4,		;GET CURRENT DATE
	PUSHJ	P,LDATE		;PRINT IT
	PUSHJ	P,LTAB		;SPACE OVER
	MSTIME	T4,		;GET CURRENT TIME
	IDIVI	T4,^D60000	;CONVERT TO MINUTES
	PUSH	P,P1		;SAVE REMAINDER
	PUSHJ	P,LTIME		;PRINT TIME (HH:MM)
	POP	P,T1		;RESTORE REMAINDER
	IDIVI	T1,^D1000	;CONVERT TO SECONDS
	PUSHJ	P,LTIMES	;PRINT SECONDS (:SS)
	MOVEI	M,[ASCIZ /	Page /]
	PUSHJ	P,LSTR		;SPACE OVER TO PAGE NUMBER
	AOS	T1,PAGCNT	;GET NEXT PAGE NUMBER
	PUSHJ	P,LDEC2		;LIST IT
	PUSHJ	P,LCRLF		;END OF LINE
;HERE WHEN FIRST LINE HAS BEEN PRINTED, DO THE REST

	MOVEI	M,[ASCIZ /Name Extension/]
	PUSHJ	P,LSTR
	TRNE	F,R.FAST
	JRST	TITLEX
	MOVEI	M,[ASCIZ / Len  Prot  /]
	PUSHJ	P,LSTR
	MOVEI	M,[ASCIZ /Checksum/]
	SKIPLE	S.CHK
	PUSHJ	P,LSTR
	MOVEI	M,[ASCIZ /  Creation/]
	TRNE	F,R.SLOW
	MOVEI	M,[ASCIZ /   Access      ---Creation---   Mode/]
	PUSHJ	P,LSTR
	MOVEI	M,[ASCIZ / Version/]
	PUSHJ	P,LSTR

TITLEX:	POP	P,P1		;RESTORE THE ACS
	POP	P,T4
	POP	P,T3
	POP	P,T2
	POP	P,T1
	PUSHJ	P,LCRLF		;ISSUE END OF LINE
	PUSHJ	P,LCRLF		;AND A BLANK LINE

TITLEY:	POP	P,C		;RESTORE CHARACTER
	POP	P,M		;RESTORE POINTER
	POPJ	P,		;RETURN
;LDIRB -- LIST DIRECTORY IN SFD FORMAT
;CALL:	MOVE	T4,CONTENTS OF UFDPPN
;	PUSHJ	P,LDIRB
;USES T1, T2, T3, T4, C

IFN FTSFD,<
LDIRB:	JUMPE	T4,.POPJ	;GIVE UP IF BLANK
	JUMPL	T4,[MOVE  T2,T4  ;IF SIXBIT, TYPE IT
		    PJRST LSIXN]
	TLNE	T4,-1		;SEE IF SFD POINTER
	JRST	[PUSH P,[[0]-3]	;NO--JUST DO UFD
		 JRST LDIRBU]

	PUSH	P,T4		;SAVE ARGUMENT
	MOVE	T4,2(T4)	;GET UFD IN PATH LIST
LDIRBU:	JUMPL	T4,[MOVE  T2,T4  ;IF SIXBIT, TYPE IT
		    MOVEI T3,6	 ;SET FOR 6 CHARS
		    SKIPLE S.SORT
		    PUSHJ P,LSIXC ; IF /SORT, DO 6 CHARS
		    SKIPG S.SORT
		    PUSHJ P,LSIXN
		    JRST  LDIRBR]
	SKIPG	S.SORT		;IF NOT /SORT
	JRST	LDIRBN		; PROCEED BELOW
	HLRZ	T1,T4		;IF /SORT,
	PUSHJ	P,LOCT6Z	; DO FIXED FORMAT
	MOVEI	C,","		;SEPARATE HALVES
	PUSHJ	P,LCHR		; WITH A COMMA
	HRRZ	T1,T4		;THEN DO
	PUSHJ	P,LOCT6Z	; RIGHT HALF
	JRST	LDIRBR		;CONTINUE BELOW
LDIRBN:	PUSHJ	P,LXWD		;TYPE UFD
LDIRBR:	POP	P,T4		;RESTORE ARGUMENT
	HRLI	T4,-LN.DRB+1	;SET MAX LIST LENGTH
LDIRB1:	SKIPN	T2,3(T4)	;GET NEXT SFD IN PATH
	POPJ	P,		;IF NONE, RETURN
	MOVEI	C,","		;YES--TYPE COMMA
	PUSHJ	P,LCHR		; ..
	MOVEI	T3,6		;SET FIXED LENGTH
	SKIPLE	S.SORT		;IF /SORT
	PUSHJ	P,LSIXC		; DO FIXED
	SKIPG	S.SORT		;ELSE,
	PUSHJ	P,LSIXN		;  AND SFD
	AOBJN	T4,LDIRB1	;LOOP UNTIL DONE
	POPJ	P,		;RETURN
>
;LVER -- LIST WORD IN VERSION NUMBER FORMAT
;CALL:	MOVE	T4,WORD
;	PUSHJ	P,LVER
;USES T1, T2, T3, T4, C

LVER:	LDB	T1,[POINT 9,T4,11]  ;GET MAJOR VERSION
	SKIPE	T1		;IF NON-ZERO,
	PUSHJ	P,LOCT		;  PRINT IN OCTAL
	LDB	T1,[POINT 6,T4,17]  ;GET MINOR VERSION
	JUMPE	T1,LVER2	;IF NON-ZERO,
	IDIVI	T1,^D26		;  PRINT IN ALPHA
	JUMPE	T1,LVER1	;  ONE OR TWO
	MOVEI	C,"A"-1(T1)	;  CHARACTERS
	PUSHJ	P,LCHR		;  ..
LVER1:	MOVEI	C,"A"-1(T2)	;  ..
	PUSHJ	P,LCHR		;  ..
LVER2:	HRRZ	T1,T4		;GET EDIT NUMBER
	JUMPE	T1,LVER3	;IF NON-ZERO,
	MOVEI	C,"("		;  PRINT (
	PUSHJ	P,LCHR		;  ..
	PUSHJ	P,LOCT		;  IN OCTAL
	MOVEI	C,")"		;  AND )
	PUSHJ	P,LCHR		;  ..
LVER3:	LDB	T1,[POINT 3,T4,2]
	JUMPE	T1,.POPJ	;IF CUST. NUMBER NON-ZERO,
	MOVEI	C,"-"		;  PRINT -
	PUSHJ	P,LCHR		;  ..
	PJRST	LOCT		;  AND NUMBER


;LCHECK -- ROUTINE TO LIST THE ACCUMULATED CHECKSUM
;CALL:	PUSHJ	P,LCHECK
;USES T1, T2, T3, C

LCHECK:	HLRZ	T1,CHKSUM	;YES--COMBINE HALVES
	HRRZ	T2,CHKSUM	;GET RH
	ADD	T2,T1		;ADD
	HLRZ	T1,T2		;GET CARRY
	ADDI	T1,(T2)		;COMBINE
	PJRST	LOCT6Z		;LIST AS 6 DIGIT OCTAL AND RETURN
;LXWD -- LIST WORD IN XWD FORMAT (N,N)
;CALL:	MOVE	T4,WORD
;	PUSHJ	P,LXWD
;USES T1, T2, T3, C

IFE FTSFD,<LDIRB:>
LXWD:	HLRZ	T1,T4		;GET LEFT HALF
	JUMPE	T1,LXWD1	;SKIP FIRST PART IF 0
	PUSHJ	P,LOCT		;OUTPUT LH IN OCTAL
	MOVEI	C,","		;SEND SEPARATOR
	PUSHJ	P,LCHR
LXWD1:	HRRZ	T1,T4		;DO RIGHT HALF
	PJRST	LOCT		;IN OCTAL AND RETURN



;LOCT6Z -- LIST 6 OCTAL DIGITS WITH LEADING ZEROS
;LOCTZ -- LIST N OCTAL DIGITS WITH LEADING ZEROS
;CALL:	(MOVE	T2,MASK OF LARGEST NUMBER  IF LOCTZ)
;	MOVE	T1,NUMBER
;	PUSHJ	P,LOCT6Z/LOCTZ
;USES T1, T2, T3, C

LOCT6Z:	MOVEI	T2,-1		;PRESET FOR 6 DIGITS

LOCTZ:	LSH	T2,-3		;COUNT DOWN MASK
	SKIPE	T2		;SEE IF ALL DONE
	CAMLE	T1,T2		;SEE IF DONE YET
	PJRST	LOCT		;REST ARE NON-ZERO
	PUSHJ	P,LZER		;NO--TYPE A ZERO
	JRST	LOCTZ		;AND GO AROUND AGAIN


;LOCT6B -- SAME ONLY LEADING BLANKS
;LOCTB -- SAME ONLY BLANKS

LOCT6B:	MOVEI	T2,-1		;SET FOR 6 DIGITS

LOCTB:	LSH	T2,-3		;COUNT DOWN MASK
	SKIPE	T2		;SEE IF ALL DONE
	CAMLE	T1,T2		;SEE IF DONE YET
	PJRST	LOCT		;REST ARE NON-ZERO
	PUSHJ	P,LSPC		;NO--TYPE A SPACE
	JRST	LOCTB		;AND GO AROUND AGAIN
;LDATE -- OUTPUT DATE IN FORM DD-MMM-YY
;CALL:	MOVE	T4,DATE IN SYSTEM FORMAT
;	PUSHJ	P,LDATE
;USES T1, T2, T3, T4, M, C

LDATE:	PUSHJ	P,.SAVE1	;SAVE P1
	SKIPE	S.SORT		;SEE IF /SORT
	JRST	LDATEN		;YES--USE SORTABLE FORMAT
	JUMPE	T4,LDATEZ	;JUMP IF NO DATE
	IDIVI	T4,^D31		;GET DAY
	MOVEI	T1,1(P1)
	PUSHJ	P,LDEC2
	IDIVI	T4,^D12		;GET MONTH

	MOVE	T1,[ASCII /-Jan--Feb--Mar--Apr--May--Jun--Jul--Aug--Sep--Oct--Nov--Dec-/](P1)
	MOVEI	T2,0
	MOVEI	M,T1
	PUSHJ	P,LSTR
	MOVEI	T1,^D64(T4)	;GET YEAR
	PJRST	LDEC2Z		;OUTPUT YEAR AND RETURN

LDATEZ:	MOVEI	M,[ASCIZ /(undated)/]
	PJRST	LSTR

;HERE WHEN /SORT TO USE ANSI FORMAT:  YYYYMMDD

LDATEN:	PUSHJ	P,LSPC		;SPACE ONE TO USE SAME WIDTH
	IDIVI	T4,^D31		;GET DAYS
	MOVE	T2,P1		;SAVE FOR LATER
	IDIVI	T4,^D12		;GET MONTHS VS. YEARS
	MOVEI	T1,^D1964(T4)	;START WITH YEARS A.D.
	IMULI	T1,^D100	;MAKE ROOM FOR MONTHS
	ADDI	T1,1(P1)	;INCLUDE MONTHS (1=JAN)
	IMULI	T1,^D100	;MAKE ROOM FOR DAYS
	ADDI	T1,1(T2)	;INCLUDE DAYS
	PJRST	LDEC		;OUTPUT THIS MESS
;LOCT3Z -- LIST OCTAL 3 DIGITS (LEADING ZEROS)
;LOCT2Z -- DITTO 2 DIGITS
;CALL:	MOVEI	T1,NUMBER
;	PUSHJ	P,LOCT3Z/2Z
;USES T1, T2, T3, C

LOCT3Z:	CAIGE	T1,100		;TEST FOR FIRST ZERO
	PUSHJ	P,LZER		;YES--DO IT
LOCT2Z:	CAIGE	T1,10		;SEE IF NEXT
	PUSHJ	P,LZER		;YES--DO IT
	PJRST	LOCT		;THEN FINISH NUMBER


;LDECP -- LIST DECIMAL (POSSIBLY NEGATIVE) FOLLOWED BY .
;CALL:	MOVE	T1,NUMBER
;	PUSHJ	P,LDECP
;USES T1, T2, T3, C

LDECP:	JUMPGE	T1,LDECPP	;JUMP IF NOT NEGATIVE
	MOVEI	C,"-"		;TYPE MINUS
	PUSHJ	P,LCHR		; SIGN
	MOVMS	T1		;AND MAKE POSITIVE
LDECPP:	PUSHJ	P,LDEC		;LIST DECIMAL NUMBER
	MOVEI	C,"."		;LIST .
	PJRST	LCHR		;TO INDICATE DECIMAL NUMBER


;LOCT2 -- LIST OCTAL AT LEAST TWO DIGITS
;CALL:	MOVEI	T1,NUMBER
;	PUSHJ	P,LOCT2
;USES T1, T2, T3, C

LOCT2:	CAIGE	T1,10		;SEE IF LARGE ENOUGH
	PUSHJ	P,LSPC		;NO--SEND A SPACE
	PJRST	LOCT		;SEND IN OCTAL
;LTIME -- OUTPUT TIME IN FORM HH:MM
;LTIMEB-- OUTPUT TIME OR BLANKS IF 00:00
;LTIMES-- OUTPUT JUST ":DD" FOR SECONDS CALL
;CALL:	(MOVE	T4,TIME IN MINUTES    FOR LTIME)
;	(MOVE	T1,SECONDS            FOR LTIMES)
;	PUSHJ	P,LTIME
;USES T1, T2, T3, T4, C

LTIMEB:	JUMPE	T4,LSPC5	;IF 0, PRINT BLANKS

LTIME:	PUSHJ	P,.SAVE1	;SAVE P1
	IDIVI	T4,^D60		;GET HOURS
	MOVE	T1,T4
	PUSHJ	P,LDEC2		;LIST HOURS
	MOVE	T1,P1		;LIST MINUTES

LTIMES:	MOVEI	C,":"
	PUSHJ	P,LCHR
				;FALL INTO LDEC2Z

;LDEC2Z -- LIST DECIMAL AT LEAST 2 DIGITS WITH LEADING ZERO
;CALL:	MOVEI	T1,NUMBER
;	PUSHJ	P,LDEC2Z
;USES T1, T2, T3, C

LDEC2Z:	CAIGE	T1,^D10		;TEST TO SEE IF NEEDED
	PUSHJ	P,LZER		;YES--SEND ZERO
	PJRST	LDEC		;GO FINISH WORK
;LDEC4 -- LIST DECIMAL AT LEAST FOUR DIGITS
;LDEC3 -- LIST DECIMAL AT LEAST THREE DIGITS
;LDEC2 -- LIST DECIMAL AT LEAST TWO DIGITS
;CALL:	MOVEI	T1,NUMBER
;	PUSHJ	P,LDEC2
;USES T1, T2, T3, C

LDEC4:	CAIGE	T1,^D1000	;SEE IF NEEDED
	PUSHJ	P,LSPC
LDEC3:	CAIGE	T1,^D100
	PUSHJ	P,LSPC
LDEC2:	CAIGE	T1,^D10
	PUSHJ	P,LSPC		;YES
	PJRST	LDEC		;GO LIST IN DECIMAL

;LDEC -- LIST DECIMAL NUMBER
;LOCT -- LIST OCTAL NUMBER
;LRDX -- LIST VIA PRESET RADIX
;CALL:	MOVEI	T1,NUMBER
;      (MOVEI	T3,RADIX    LRDX ONLY)
;	PUSHJ	P,LDEC/LOCT/LRDX
;USES T1, T2, T3, C

LOCT:	JUMPGE	T1,LOCTC	;IF POS, EASY TO DO
	MOVE	T2,T1		;NO--USE OTHER WAY
	MOVEI	T3,^D12		;SET DIGIT COUNT
LOCTL:	MOVEI	T1,0		;CLEAR RESULT
	LSHC	T1,3		;GET NEXT DIGIT
	MOVEI	C,"0"(T1)	;CONVERT TO ASCII
	PUSHJ	P,LCHR		;OUTPUT IT
	SOJG	T3,LOCTL	;AND LOOP UNTIL DONE
	POPJ	P,		;RETURN

LDEC:	SKIPA	T3,[^D10]	;INITIALIZE FOR DECIMAL RADIX
LOCTC:	MOVEI	T3,10		;INITIALIZE FOR OCTAL RADIX

LRDX:	IDIV	T1,T3		;DIVIDE BY RADIX
	HRLM	T2,(P)		;SAVE REMAINDER
	SKIPE	T1		;SEE IF ANYTHING LEFT
	PUSHJ	P,LRDX		;YES--LOOP BACK WITH PD LIST
	HLRZ	C,(P)		;GET BACK A DIGIT
	ADDI	C,"0"		;CONVERT TO ASCII
	PJRST	LCHR		;GO LIST IT
;LCRLF - LIST END OF LINE
;CALL:	PUSHJ	P,LCRLF
;USES M, C

LCRLF:	MOVEI	M,[ASCIZ /
/]
				;FALL INTO LSTR

;LSTR - LIST ASCII STRING
;CALL:	MOVEI	M,STRING (END WITH 0 BYTE)
;	PUSHJ	P,LSTR
;USES M, C

LSTR:	TLOA	M,(POINT 7,)	;CONVERT TO BYTE POINTER
LSTR1:	PUSHJ	P,LCHR		;OUTPUT CHARACTER
	ILDB	C,M		;GET NEXT CHARACTER
	JUMPN	C,LSTR1		;LOOP UNLESS NULL
	POPJ	P,		;RETURN


;LSIXT -- LIST SIXBIT WORD FOLLOWED BY TAB
;CALL:	MOVE	T2,WORD
;	PUSHJ	P,LSIXT
;USES T1, T2, C

LSIXT:	PUSHJ	P,LSIX		;OUTPUT WORD
	PJRST	LTAB		;GO OUTPUT TAB AND RETURN
;LSIX  -- LIST SIXBIT WORD (AT LEAST ONE SPACE)
;LSIXN -- SAME EXCEPT 0 GIVES NO SPACES
;CALL:	MOVE	T2,WORD
;	PUSHJ	P,LSIX/LSIXN
;USES T1, T2, C

LSIX:	MOVEI	T1,0		;CLEAR NEXT CHARACTER
	LSHC	T1,6		;FETCH NEXT CHAR
	PUSHJ	P,LCHRS		;LIST IT IN SIXBIT

LSIXN:	JUMPN	T2,LSIX		;LOOP UNTIL ONLY BLANKS LEFT
	POPJ	P,		;RETURN


;LSIXC -- LIST SIXBIT WORD FIXED NUMBER OF CHARACTERS
;CALL:	MOVE	T2,WORD
;	MOVEI	T3,NUM CHARS TO PRINT
;	PUSHJ	P,LSIXC
;USES T1, T2, T3, C

LSIXC:	MOVEI	T1,0		;CLEAR NEXT CHAR
	LSHC	T1,6		;GET NEXT CHAR
	PUSHJ	P,LCHRS		;LIST IT IN SIXBIT
	SOJG	T3,LSIXC	;LOOP UNTIL DONE
	POPJ	P,		;RETURN


;LSPC2 -- LIST TWO SPACES
;LSPC4 -- LIST FOUR SPACES
;LSPC5 -- LIST FIVE SPACES
;CALL:	PUSHJ	P,LSPC2
;USES C

LSPC5:	PUSHJ	P,LSPC		;SPACE ONE
LSPC4:	PUSHJ	P,LSPC2		;SPACE TWO MORE
LSPC2:	PUSHJ	P,LSPC		;DO ONE
	PJRST	LSPC		;DO ANOTHER AND RETURN



;LZER -- LIST A ZERO
;CALL:	PUSHJ	P,LZER
;USES C

LZER:	MOVEI	C,"0"		;GET CHARACTER
	PJRST	LCHR1		;GO LIST IT
;LTAB -- LIST TAB
;LSPC -- LIST SPACE
;LCHR -- LIST CHARACTER
;LCHRS -- LIST CHARACTER IN SIXBIT
;CALL:	(MOVEI	C,CHARACTER    IF LCHR)
;	(MOVEI	T1,CHARACTER   IF LCHRS)
;	PUSHJ	P,LTAB/LSPC/LCHR
;USES C EXCEPT LCHR USES NO AC'S

LCHRS:	MOVEI	C," "-' '(T1)	;CONVERT TO ASCII AND MOVE TO C
LCHR:	CAIE	C,.CHTAB	;SEE IF A TAB
	JRST	LCHR1		;NO--GO SEND IT

LTAB:	TRON	F,R.LTAB	;SET/TEST TAB
	POPJ	P,		;RETURN IF NOT TWO IN A ROW

LTAB1:	SKIPA	C,[.CHTAB]	;GET THE TAB
LSPC:	MOVEI	C," "		;GET THE SPACE

LCHR1:	SKIPGE	LNPP		;SEE IF AT END OF PAGE
	PUSHJ	P,TITLER	;YES--GO ISSUE PAGE HEADER
	CAIN	C,.CHCRT	;SEE IF CARRIAGE RETURN
	TRZ	F,R.LTAB	;YES--CLEAR TAB MEMORY
	CAIN	C,.CHLFD	;SEE IF END OF LINE
	SOS	LNPP		;YES--DECREMENT LINES PER PAGE
	TRZE	F,R.LTAB	;CLEAR TAB MEMORY
	JRST	LCHR4		;IF SET, GO ISSUE ONE
	AOS	NOCHRS		;ADVANCE CHARACTER POSITION COUNTER
	CAIE	C,.CHTAB	;SEE IF TAB
	JRST	LCHR3		;NO--PROCEED BELOW
	PUSH	P,T1		;YES--SAVE AN AC
	MOVE	T1,NOCHRS	;GET CHARACTER COUNTER
	ADDI	T1,7		;ROUND UP
	TRZ	T1,7		;ROUND OFF
	SUB	T1,NOCHRS	;FIND EXCESS
	ADDM	T1,NOCHRS	;UPDATE CHARACTER COUNTER
	SKIPE	T1		;IF NO FILLING
	SKIPN	S.SORT		; OR NOT /SORT
	JRST	LCHR2		; DON'T FILL IN SPACES
	MOVEI	C," "		;GET A SPACE
	PUSHJ	P,LCHR3		;OUTPUT IT
	SOJG	T1,.-1		;LOOP FOR ENOUGH SPACE
	MOVEI	C,.CHTAB	;RESTORE THE TAB
LCHR2:	POP	P,T1		;RESTORE AC
LCHR3:	CAIL	C,.CHLFD	;SEE IF VERTICAL MOTION
	CAILE	C,.CHFFD	; ..
	JRST	.+2		;NO
	SETZM	NOCHRS		;YES--CLEAR POSITION
	SKIPN	B.LC+1		;SEE IF OPEN YET
	PUSHJ	P,OUTIN		;NO--OPEN IT
	SOSG	B.LC+2		;SEE IF ROOM IN THE BUFFER
	PUSHJ	P,LCHRW		;NO--GO WRITE THIS BUFFER
	IDPB	C,B.LC+1	;YES--SEND CHARACTER
	PUSH	P,T1		;PRESERVE TEMP
	MOVE	T1,C		;GET CHARACTER
	TRNE	F,R.TYPE	;SEE IF NEED TO DUPLICATE
	PUSHJ	P,.TTCHR	;YES--TYPE IT (IF NOT SAME)
	POP	P,T1		;RESTORE TEMP
	CAIGE	C,.CHFFD	;SEE IF END OF LINE
	PUSHJ	P,LCHRWL	;YES--OUTPUT BUFFER IF APPROPRIATE
	POPJ	P,		;RETURN
LCHR4:	PUSH	P,C		;SAVE REQUESTED CHARACTER
	PUSHJ	P,LTAB1		;SEND A TAB
	POP	P,C		;RESTORE CHARACTER
	JRST	LCHR1		;PROCEED


LCHRWL:	TRNE	F,R.OUTL	;SEE IF OUTPUT APPROPRIATE FOR EACH END OF LINE
LCHRW:	OUT	LC,		;OUTPUT BUFFER
	  POPJ	P,		;OK--RETURN
LCHRWR:	PUSH	P,T1		;ERROR--SAVE SOME ACS
	PUSH	P,T2		; ..
	PUSH	P,T3		; ..
	PUSH	P,F		;SAVE F
	TRZ	F,R.OUTO!R.OUTD	;CLEAR OUTPUT FLAGS
	MOVEI	T1,[ASCIZ /
% Listing device output error, status /]
	PUSHJ	P,.TSTRG	;OUTPUT STRING
	GETSTS	LC,T1		;GET ERROR STATUS
	MOVE	T2,T1		;PREPARE TO CLEAR
	ANDI	T2,-1-IO.ERR-IO.EOF  ;  BY PRESERVING JUST
	SETSTS	LC,(T2)		;  THE CONTROL BITS
	PUSHJ	P,.TOCTW	;TYPE VALUE IN OCTAL
	PUSHJ	P,.TCRLF	;AND END LINE
	POP	P,F		;RESTORE THE ACS
	POP	P,T3		; ..
	POP	P,T2		; ..
	POP	P,T1		; ..
	POPJ	P,		;RETURN
;OUTIN -- SUBROUTINE TO OPEN THE OUTPUT LISTING FILE
;PRESERVES ALL AC'S

OUTIN:	PUSH	P,T1		;SAVE ACS
	PUSH	P,T2		; ..
	PUSH	P,T3		; ..
	PUSH	P,T4		; ..
OUTIN1:	LDB	T1,[POINTR (O.PROT,<FX.PAR!FX.DEN>)]
	LSH	T1,^D35-POS<IO.DEN>
	MOVE	T2,O.PROT	;GET PHYSICAL
	TXNE	T2,FX.PHY	;TEST IT
	TXO	T1,UU.PHS	;SET FOR MONITOR
	MOVE	T2,O.DEV	;INIT THE LISTING DEVICE
	MOVSI	T3,B.LC
	OPEN	LC,T1
	  JRST	E.OPO
	MOVE	T1,O.NAM	;ENTER IF NEEDED
	JUMPE	T1,OUTIN2
	HLLZ	T2,O.EXT
	LDB	T3,[POINTR (O.PROT,FX.PRO)]
	LSH	T3,^D27		;POSITION PROTECTION
	MOVE	T4,O.DIR
	ENTER	LC,T1
	  JRST	E.OPE

OUTIN2:	MOVEI	T1,LC		;GET DEVICE TYPE
	DEVTYP	T1,		;FROM CHANNEL
	  MOVEI	T1,0		;(OLD MONITORS)
	TXNE	T1,TY.SPL	;SEE IF SPOOLED
	TRZ	F,R.OUTL	;CLEAR LINE MODE (REALLY DISK)
	POP	P,T4		;RESTORE ACS
	POP	P,T3		; ..
	POP	P,T2		; ..
	POP	P,T1		; ..
	POPJ	P,		;RETURN

E.OPO:	MOVE	T1,O.DEV	;SEE WHAT TYPE
	DEVCHR	T1,		;  OF DEVICE
	TXNN	T1,DV.LPT	;IS IT LINE PRINTER
	JRST	E.OPO1		;NO--FAIL
	TRON	F,R.LPTB	;YES--SECOND TIME?
	OUTSTR	[ASCIZ /LPT busy--waiting
/]
	MOVEI	T1,5		;SLEEP 5 SECONDS AND TRY AGAIN
	SLEEP	T1,		; ..
	JRST	OUTIN1		; ..
E.OPO1:	TRZ	F,R.OUTD!R.OUTO!R.OUTL  ;CLEAR LISTING FLAGS
	MOVE	P3,O.DEV
	N.FAIN	<Output open failed on device>
E.OPE:	TRZ	F,R.OUTD!R.OUTO!R.OUTL  ;CLEAR LISTING FLAGS
	MOVE	P3,O.NAM
	N.FAIN	<Output enter failed on file>
;.TNEWL -- FORCE LISTING OUTPUT TO START OF LINE
;CALL:	PUSHJ	P,.TNEWL
;RETURNS AT BEGINNING OF LINE
;PRESERVES ALL ACS

.TNEWL:	TRNE	F,R.OUTD	;SEE IF OUTPUT
	SKIPN	NOCHRS		;YES--SEE IF AT START OF LINE
	POPJ	P,		;YES--RETURN
	PJRST	LCRLF		;NO--OUTPUT END OF LINE


;TCHR -- TYPE CHARACTER ON TTY
;CALL:	MOVEI	T1,CHARACTER
;	PUSHJ	P,TCHR
;PRESERVES ALL ACS

TCHR:	PUSHJ	P,SAVTYP	;SAVE R.TYPE AND CLEAR IT
	MOVE	C,T1		;(TEMP)
	TRNE	F,R.OUTD	;SEE IF OUTPUT
	PUSHJ	P,LCHR		;YES--LIST CHARACTER
.TTCHR:	TRNN	F,R.OUTO	;SEE IF LISTING ON CONSOLE
	OUTCHR	T1		;NO--TYPE IT ALSO
	POPJ	P,		;RETURN


;SAVTYP -- ROUTINE TO SAVE R.TYPE ON THE STACK AND CLEAR IT
;	THIS AVOIDS TYPING TITLES AND DOUBLE LISTINGS
;CALL:	PUSHJ	P,SAVTYP
;RETURNS CPOPJ.  SETS STACK TO RESTORE R.TYPE WHEN CALLER
;	RETURNS (CPOPJ OR CPOPJ1)
;PRESERVES ALL ACS

SAVTYP:	EXCH	T1,(P)		;GET CALLING PC
	MOVEM	T1,1(P)		;STASH AWAY FOR THE NEXT CALL
	MOVE	T1,(P)		;RESTORE T1
	SETZM	(P)		;FLAG R.TYPE=0
	TRZE	F,R.TYPE	;CLEAR R.TYPE
	SETOM	(P)		;FLAG THAT IT WAS ON
	PUSHJ	P,@1(P)		;CALL BACK TO CALLER
	  JRST	.+2		;HANDLE NON-SKIP
	AOS	-1(P)		;HANDLE SKIP
	SKIPE	(P)		;TEST MEMORY OF FLAG
	TRO	F,R.TYPE	;RESTORE R.TYPE
	POP	P,(P)		;DISCARD MEMORY
	POPJ	P,		;RETURN TO CALLER'S CALLER
SUBTTL	STORAGE

	XLIST		;LITERALS
	LIT
	LIST

IFN PURESW,<RELOC>

OFFSET:	BLOCK	1		;STARTING ADDRESS OFFSET
ZCOR:!			;START OF AREA TO ZERO ON INITIAL LOAD

PDLST:	BLOCK	LN.PDL+1	;PUSH DOWN LIST
SAVCOR:	BLOCK	1		;LENGTH OF CORE ORIGINALLY
MYPPN:	BLOCK	1		;PROJECT-PROGRAMMER NUMBER OF THIS JOB
ORGFF:	BLOCK	1		;ORIGINAL .JBFF
H.ZER:!			;START OF AREA FOR OUTPUT PARAMETERS
B.LC:	BLOCK	3		;LISTING BUFFER HEADERS
LNPP:	BLOCK	1		;LINES LEFT TO GO ON PAGE
PAGCNT:	BLOCK	1		;PAGE COUNTER
SVJBFF:	BLOCK	1		;INPUT SIDE .JBFF


H.ZER1:!		;START OF AREA FOR ONE OUTPUT
DCHBLK:	BLOCK	.DCSNM+1	;DSKCHR BLOCK
OPENBL:	BLOCK	1		;OPEN BLOCK
FSTR:	BLOCK	1		;CURRENT FILE STRUCTURE NAME
	BLOCK	1		; ..

LBLOCK:	BLOCK	LN.RIB		;EXTENDED LOOKUP BLOCK
FRVER:	BLOCK	1		;RIB VERSION IF DIFF. FROM FILE
H.ZERX:	BLOCK	.-H.ZER1	;REGION FOR PREVIOUS FILE
H.ZERY:
IFN FTSFD,<
	BLOCK	3+LN.DRB	;  ..
>

MTSVFF:	BLOCK	1		;.JBFF AT FIRST MTOPEN

H.MZER:!		;START OF AREA FOR ONE MT SAVE SET
MTSVHD:	BLOCK	1		;LAST WORD READ FOR FAILSAFE MODE
MTSVVR:	BLOCK	1		;VERSION,,TAPE NUMBER
MTSVWD:	BLOCK	1		;SAVE HEADERS DURING BACKUP TAPES
MTSVCT:	BLOCK	1		;COUNTER FOR BACKUP DATA READS
LASI:	BLOCK	1		;LAST FILE FOUND
LASDIR:	BLOCK	1		;LAST DIRECTORY LISTED
LASSTR:	BLOCK	1		;LAST STRUCTURE LISTED
IFN FTSFD,<
LASPTH:	BLOCK	3+LN.DRB	;ROOM FOR PREVIOUS PATH
THSPTH:	BLOCK	3+LN.DRB	;ROOM FOR CURRENT PATH
>
SUBDIR:	BLOCK	1		;SUBTOTAL DIRECTORY
SUBSTR:	BLOCK	1		;SUBTOTAL STRUCTURE
IFN FTSFD,<
SUBPTH:	BLOCK	3+LN.DRB	;SUBTOTAL PATH
SUBEND==.-1
>
NOFIL:	BLOCK	1		;NUMBER OF FILES IN UFDS SCANNED
TOT:!			;GRAND TOTALS
NOFILF:	BLOCK	1		;NUMBER OF FILES ACTUALLY USED
NOFILR:	BLOCK	1		;NUMBER OF LOOKUP ERRORS
NOBLKS:	BLOCK	1		;NUMBER BLOCKS IN FILES PRINTED
TCHKSM:	BLOCK	1		;GRAND CHECKSUM
SUBT:!			;SUB TOTALS
SNFILF:	BLOCK	1		; (MUST PARALLEL AND IMMED. FOLLOW TOT)
SNFILR:	BLOCK	1
SNBLKS:	BLOCK	1
SCHKSM:	BLOCK	1

NUMDIR:	BLOCK	1		;NUMBER OF DIRECTORIES
NUMSUB:	BLOCK	1		;NUMBER OF SUBTOTALS
CHKSUM:	BLOCK	1		;CHECKSUM ACCUMULATOR
NOCHRS:	BLOCK	1		;CURRENT HORIZONTAL POSITION
LSTSTR:	BLOCK	1		;STR TO LIST IF NEEDED
LSTDIR:	BLOCK	1		;DIRECTORY TO LIST IF NEEDED
NXUCNT:	BLOCK	1		;COUNT OF UFDS FOUND
NXSCNT:	BLOCK	1		;COUNT OF SFDS MISSED
NXFCNT:	BLOCK	1		;COUNT OF FILES FOUND
NXFI:	BLOCK	1		;I OF LAST NON-EX FILE
H.EMZR==.-1
MTFLCT:	BLOCK	1		;COUNT DOWN ON MT FROM /FILE:N
H.EZER==.-1
S.MIN:!			;START OF AREA FOR COMMAND ACCUMULATION
S.ACCS:	BLOCK	1		;VALUE OF /ACCESS SWITCH
S.ALC:	BLOCK	1		;/ALLOCAT SWITCH
S.CHK:	BLOCK	1		;/CHECKSUM SWITCH
S.DODV:	BLOCK	1		;CODE FOR DEFAULT OUTPUT DEVICE
S.DTL:	BLOCK	1		;/DETAIL SWITCH
S.EOT:	BLOCK	1		;/EOT SWITCH
S.FILE:	BLOCK	1		;/FILES:N SWITCH
S.REWS:	BLOCK	1		;/REWINDS SWITCH
S.SORT:	BLOCK	1		;/SORT SWITCH
S.SUM:	BLOCK	1		;/SUMMARY SWITCH
S.TITL:	BLOCK	1		;-1,1=TITLE, 0=2=NO TITLE
S.UNIT:	BLOCK	1		;/UNITS SWITCH
S.WDTH:	BLOCK	1		;VALUE OF /WIDTH SWITCH
S.WORD:	BLOCK	1		;/WORD SWITCH
S.EMIN==.-1

S.ZER:!

O.ZER:!			;START OF OUTPUT SPEC STORAGE
O.DEV:	BLOCK	1		;DEVICE
O.NAM:	BLOCK	1		;NAME
O.NAMM:	BLOCK	1		;NAME MASK
O.EXT:	BLOCK	1		;EXT,,MASK
O.PROT:	BLOCK	2		;OUTPUT PROTECTION
O.DIR:	BLOCK	1		;DIRECTORY
O.DIRM:	BLOCK	2*LN.DRB-1	;DIRECTORY MASK
O.LZER==.-O.ZER

I.INZR:	BLOCK	1		;POINTER TO START OF INPUT SPEC
I.NXZR:	BLOCK	1		;POINTER TO NEXT INPUT SPEC STORAGE
I.NXRD:	BLOCK	1		;POINTER TO NEXT INPUT SPEC TO DO
FLAGS:	BLOCK	1		;COPY OF F DURING SCAN
FLAGSM:	BLOCK	1		;DITTO--MASKS
I.ZER:!			;START OF INPUT SPEC STORAGE AREA
	PHASE	0
I.DEV:!	BLOCK	1		;DEVICE
I.NAM:!	BLOCK	1		;NAME
I.NAMM:!BLOCK	1		;NAME MASK
I.EXT:!	BLOCK	1		;EXT,,MASK
I.MOD:!	BLOCK	1		;SWITCHES
I.MODM:!BLOCK	1		;SWITCH MASK (ON IF USER SUPPLIED)
I.DIR:!	BLOCK	1		;DIRECTORY
I.DIRM:!BLOCK	2*LN.DRB-1	;DIRECTORY MASK
I.BFR:!	BLOCK	1		;/BEFORE
I.SNC:!	BLOCK	1		;/SINCE
	DEPHASE
I.LZER==.-I.ZER
	BLOCK	<20-1>*I.LZER	;ROOM FOR MORE
I.EZER=.-1

DIRB:	BLOCK	200		;DIRECTORY BLOCK FOR DECTAPE

S.EZER=.-1
EZCOR==.-1		;END OF AREA TO ZERO

	END	DIRECT
Y{N