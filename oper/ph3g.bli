!COPYRIGHT 1972,1973, DIGITAL EQUIPMENT CORPORATION, MAYNARD MA**
!AUTHOR: NORMA ABEL

GLOBAL BIND PH3GV=127;	!VERSION 6/13/73

!
! MAIN ROUTINE NAMED CHANGED TO MRP3G FOR SINGLE SEGMENT
!
!THE MAIN ROUTINE IN THIS MODULE IS MRP3G WHICH IS CALLED FROM
!PHAZONTROL. IT IS THE ONLY GLOBAL ROUTINE IN THE MODULE. THE
!ROUTINE AUDITOR DOES ALL THE REAL WORK OF COMPUTING MERITS,
!SELECTING ALLOCATIONS AND SUBSTITUTING REGCONTENTS NODES FOR THE
!VARIABLES

BIND							!USED AS INDICES INTO THE MERIT TABLES
	LHSUSE=0,					!KAMERIT & KIMERIT
	DEXUSE=1,
	LCTLUSE=2,
	FUNUSE=3,
	PLAINUSE=4;
!FOR KAIO REGISTER ALLOCATION				!USE ON LHS
BIND KAMERIT=PLIT ( 6,					!USE ON LHS
		   6,					!USE AS INDEX
		    12,					!LOOP CONTROL
		   12,					!CALL OR FUNCTION REFERENCE
		    0);					!OTHERS
!FOR KI1O REGISTER ALLOCATION
BIND KIMERIT=PLIT ( 3,					!USE ON LHS
		    3,					!USE AS INDEX
		    6,					!LOOP CONTROL
		   6,					!CALL OR FUNCTION REFERENCE
		    0 );				!OTHERS


!THE MERIT ON A CALL OR FUNCTION IS ACTUALLY NEGATIVE.  THIS IS
!HANDLED IN AUDITOR BY SUBTRACTING THE CUMULATED VALUE OF THE NUMBER
!OF FUNCTION REFERENCES (FNREFNO) TIMES THE MERIT FROM THESE TABLES

!THE VECTOR CHOSEN IS USED TO HOLD INFORMATION ABOUT VARIABLES
!WITH GREATEST MERIT.  THE ROUTINE LOOKUP (ALSO USED IN
!DEFINITION POINT COMPUTATION) CAN BE USED FOR THE LINEAR
!SEARCH.
!
!FORMAT OF CHOSEN
!
!*************************
!            *           *
!    MERIT   *     PTR   *
!            *           *
!*************************
!
!PTR POINTS TO SYMBOL TABLE ENTRY
!
!WHILE THE RUNNING TALLY IS IN PROGRESS THE CELL MINWD
!CONTAINS THE MINIMUM MERIT ON THE LIST AND THE INDEX
!OF THAT ITEM ON THE LIST
!
!MINWD
!
!**********************************
!                 *               *
!    MIN MERIT    *      INDEX    *
!                 *               *
!**********************************
EXTERNAL DATPROC,PREV;
MAP BASE PREV;
EXTERNAL CORMAN,MAKPR1,LOOKUP,TOP,BOTTOM,FNREFNO,REGTOALC,GLOBREG,LENTRY;
EXTERNAL CHOSEN,SPECCASE,ITMCT,QQ;
OWN CLEANSLATE,THISTAT,LASTAT,PA,PB,PC,P,RAISE,HEAD,
PD,MINWD,MAXCOMPLEX[10],REGAVAIL,SAVHITCH;
MAP PEXPRNODE P:PA:PB:PC:PD:THISTAT:LASTAT;
OWN GOTEMDBL;	!ME GOT *EM DOUBLE WORD VARIABLE
OWN LIBFNREFNO;	!LIBRARY FUNCTION REFERENCE.
OWN NEDNEWDOEND;	!FLAG THAT SAYS RESTORES OF VARIBALE TO 
			!REGISTERS CAUSE CREATION OF A NEW DO TERMINATION
			!LABEL.
OWN INDUCONLY;	!FLAG THA SAYS ONLY THE DO LOOP INDEX IS
			!ALLOCATED A REGISTER
OWN PRELOADFLG;	!FLAG TO INDICATE CALL TO CALRESTORE IS FOR
			!LOADING REGISTERS IN FRONT OF A LOOP
OWN CALLREFNO;	!COUNT OF THE NUMBER OF CALL STATEMENTS IB THE
			!LOOP BEING ALLOCATED.


FORWARD CREDIT,AUDITOR,CHKMAXLST,RAYMERIT;
ROUTINE ASCRIBE(P)=
BEGIN
	MAP PEXPRNODE P;
	!BY STATEMENT TALLY MERIT
	LOCAL I;

	!SET MERIT TO PLAINUSE FIRST. CHANGE WHERER NECESSARY

	RAISE_(IF .KA10FLG THEN .KAMERIT[PLAINUSE]
		ELSE .KIMERIT[PLAINUSE]);

	!FIRST LOOK AT ANY LOCAL COMMON SUBS THAT MAY BE THERE
	IF .P[SRCOPT] NEQ 0 THEN
	BEGIN
		LOCAL BASE TMP;
		TMP_.P[SRCOPT];
		!LOOK AT THE LINKED LIST OF COMMON SUBS
		WHILE .TMP NEQ 0 DO
		BEGIN
			CREDIT(.TMP[ARG2PTR]);
			TMP_.TMP[SRCLINK];
		END;
	END;

	SELECT .P[SRCID] OF NSET
ASGNID:	BEGIN						!ASSIGNMENT STATEMENT
		PC_.P[LHEXP];				!LOOK AT LHS
		IF .PC[OPRCLS] EQL DATAOPR THEN		!IS IT A VARIABLE
		BEGIN
			RAISE_(IF .KA10FLG THEN .KAMERIT[LHSUSE]
			ELSE .KIMERIT[.LHSUSE]);
			CREDIT(.PC)
		END ELSE				!IT MUST BE AN ARRAYREF
		BEGIN
			RAYMERIT(.PC);
		END;
		!NOW THE RIGHT HAND SIDE
		!GIVE MORE CREDIT IF IT IS THERE ALL BY ITSELF
		IF .P[A2VALFLG] THEN
			!MORE CREDIT AS THE LHS GETS.
			RAISE_(IF .KA10FLG THEN .KAMERIT[LHSUSE] ELSE
				.KIMERIT[LHSUSE])
		ELSE
			RAISE_(IF .KA10FLG THEN .KAMERIT[PLAINUSE]
				ELSE .KIMERIT[PLAINUSE]);
		CREDIT(.P[RHEXP]);
	END;						!ASSIGNMENT STATEMENT
CALLID:	BEGIN						!SUBROUTINE CALL
		FNREFNO_.FNREFNO+1;			!INCREMENT COUNT OF FUNCTION REFS
		CALLREFNO_.CALLREFNO+1;			!TALLY NUMBER OF CALLS
	END;
IFAID:	BEGIN						!ARITHMETIC IF
		CREDIT(.P[AIFEXPR]);
	END;
IFLID:	BEGIN						!LOGICAL IF
		CREDIT(.P[LIFEXPR]);
		ASCRIBE(.P[LIFSTATE]);
	END;
ALWAYS:	BEGIN
	I_
	(IF .P[SRCCMPLX] GTR 10 THEN 10 ELSE .P[SRCCMPLX]);
	MAXCOMPLEX[.I]_.MAXCOMPLEX[.I]+1;
	END;
TESN;
END;							!ASCRIBE


ROUTINE CREDIT(CNODE)=
BEGIN
	!INCREMENT MERIT BY RAISE. WALK TREE THRU AUDITOR
	!CNODE POINTS TO AN EXPRESSION. RAISE IS GLOBAL TO CREDIT
	!AND IS SET BY AUDITOR
	MAP PEXPRNODE CNODE;
	CASE .CNODE[OPRCLS] OF SET
	!BOOLEAN
	BEGIN
		CREDIT(.CNODE[ARG1PTR]);
		CREDIT(.CNODE[ARG2PTR]);
	END;
	!DATAOPR
	BEGIN
		IF .CNODE[OPERSP] EQL VARIABLE OR
		.CNODE[OPERSP] EQL FORMLARRAY OR
		.CNODE[OPERSP] EQL FORMLVAR THEN
		BEGIN
			!FOR THE INITIAL RELEASE GLOBALS WILL BE HANDLED
			!AS COMMON. SOPHISTACATION CAN COME LATER.
			IF .CNODE[IDATTRIBUT(INEQV)] THEN RETURN;
			IF .CNODE[IDATTRIBUT(INCOM)] THEN RETURN;
			IF .CNODE[IDATTRIBUT(INASSI)] THEN RETURN;
			IF .CNODE[IDATTRIBUT(INNAM)] THEN RETURN;
			IF .CNODE[IDATTRIBUT(FENTRYNAME)] THEN RETURN;
			CNODE[MERIT]_.CNODE[MERIT]+.RAISE;!UPDATE MERIT
			!FOR A VARIABLE THAT IS DOUBLE WORD
			!SET THE FLAG AND DIVIDE THE MERIT
			!JUST ADDED BY 2
			IF .CNODE[DBLFLG] THEN
			BEGIN
				CNODE[MERIT]_.CNODE[MERIT]-.RAISE/2;
				GOTEMDBL_1;
			END;
			IF .CNODE[MERIT] NEQ 0 THEN
				CHKMAXLST(.CNODE);
		END;
	END;
	!RELATIONAL
	BEGIN
		CREDIT(.CNODE[ARG1PTR]);
		CREDIT(.CNODE[ARG2PTR]);
	END;
	!FNCALL
		IF .CNODE[OPERSP] NEQ LIBARY THEN
		FNREFNO_.FNREFNO+1
		ELSE
		BEGIN
			!LIBRARY FUNCTION. SET BIT IN SYMBOL
			!TABLE THAT SAYS THIS IS USED
			!AS LIB FUNCTION ARG. SUBTRACT IT AT END
			!AS WITH FNREFNO.

			LOCAL ARGUMENTLIST ARGNOD,P;
			MAP BASE P;
			LIBFNREFNO_.LIBFNREFNO+1;
			ARGNOD_.CNODE[ARG2PTR];	!PTR TO LIST
			INCR I FROM 1 TO .ARGNOD[ARGCOUNT] DO
			BEGIN
				!PICK UP POINTER TO ACTUAL ARG
				P_.ARGNOD[.I,ARGNPTR];
				IF .P[OPR1] EQL VARFL THEN
					P[LIBARGUSE]_1
				ELSE
					!MAKE SURE THAT LIBARG REFS
					!ARE COUNTED FOR CALLS TO LIB
					!THAT ARE FUNCTIONS OF OTHER CALLS TO
					!TO THE LIBRARY
					IF .P[OPRCLS] EQL FNCALL THEN
						CREDIT(.P);
			END;
		END;
	!ARITHMETIC
	BEGIN
		CREDIT(.CNODE[ARG1PTR]);
		CREDIT(.CNODE[ARG2PTR]);
	END;
	!TYPECNV
	BEGIN
		CREDIT(.CNODE[ARG2PTR]);
	END;
	!ARRAYREF
		RAYMERIT(.CNODE);
	!CMNSUB		!ILLEGAL
	BEGIN
	END;
	!NEGNOT
		CREDIT(.CNODE[ARG2PTR]);
	!SPECOP
		CREDIT(.CNODE[ARG1PTR]);
	!FIELDREF	!RELEASE GTR 1
	BEGIN
	END;
	!STORCLS
	BEGIN
	END;
	!REGCONTENTS
	BEGIN END;
	!STATEMENT
	BEGIN END;
	!IOLSCLS
	BEGIN
	END;
	!INLINFN
	BEGIN END
	TES;
END;							!CREDIT

ROUTINE RAYMERIT(PC)=
BEGIN
	!COMPUTE ARRAYREF MERIT
	OWN BASE ARGNOD,OLDPAY;
	MAP PEXPRNODE PC;

	!COMPUTE MERIT FOR AN ARRAY SUBSRCIPT.
	!FORMALS ARE NOT A SPECIAL CASE HERE AS
	!THEY HAVE THE PSEUDO CREATED NODE POINTED TO BY
	!THE ARADDRVAR FIELD OF THE SYMBOL TABLE. THIS PSEUDO
	!NODE IS IN THE TREE AND WILL GET MERIT.

	!TAKE CARE OF CONSTANT SUBSCRIPT (ARG2PTR = 0)
	IF .PC[ARG2PTR] EQL 0 THEN RETURN;

	OLDPAY_(IF .KA10FLG THEN .KAMERIT[PLAINUSE] ELSE
		.KIMERIT[PLAINUSE]);
	ARGNOD_.PC[ARG2PTR];				!SUBSCRIPT
	!ONLY GIVE CREDIT FOR INDEX
	!IF ITS BY ITSELF
	IF .ARGNOD[OPRCLS] EQL DATAOPR THEN
	BEGIN
		RAISE_(IF .KA10FLG THEN .KAMERIT[DEXUSE]
		ELSE .KIMERIT[DEXUSE]);
		CREDIT(.ARGNOD);
		RAISE_.OLDPAY;
	END ELSE
	BEGIN						!JUST PLAIN USE
		RAISE_(IF .KA10FLG THEN .KAMERIT[PLAINUSE]
		ELSE .KIMERIT[PLAINUSE]);
		CREDIT(.ARGNOD);
		RAISE_.OLDPAY;		!RESTORE  CONTEXT
	END;
END;

FORWARD MINCOMPUTE;
ROUTINE CHKMAXLST(VAR)=
BEGIN
	!LOOK AT LIST OF VARIABLES WHICH ARE CURRENTLY OF GREATEST MERIT.
	!THE LIST IS IN CHOSEN
	!VAR IS THE VARIABLE WHOSE MERIT IS UNDER EXAMINATION
	!
	LOCAL I;
	MAP PEXPRNODE VAR;
	I_LOOKUP(.VAR<RIGHT>);
	IF .I LSS 32 THEN
	CHOSEN[.I]<LEFT>_.VAR[MERIT]
	ELSE
	BEGIN						!VARIABLE IS NOT ON LIST
		!IF LIST IS NOT YET FULL (HEAD HAS COUNT) ADD TO THE LIST
		IF .HEAD LEQ 31 THEN		!HEAD CONTAINS COUNT
			(
			CHOSEN[.HEAD]<LEFT>_.VAR[MERIT];
			CHOSEN[.HEAD]<RIGHT>_.VAR;
			HEAD_.HEAD+1;)
			ELSE
			!IF THIS ONE HAS GREATER MERIT THAN THE
			!CURRENT MINIMUM ON THE LIST THEN REPLACE THE
			!OLD MINIMUM WITH THIS ONE AND RECOMPUTE THE MINIMUM
			BEGIN
				IF .MINWD EQL 0 THEN MINCOMPUTE();
				IF .VAR[MERIT] GTR .MINWD<LEFT> THEN
				BEGIN
				CHOSEN[.MINWD<RIGHT>]<LEFT>_.VAR[MERIT];
				CHOSEN[.MINWD<RIGHT>]<RIGHT>_.VAR;
				MINCOMPUTE();
				END;	!MIN REPLACEMENT AND RECOMPUTE
			END;
	END;
END;							!CHKMAXLST
ROUTINE MINCOMPUTE=
BEGIN
				!RECOMPUTE THE MINIMUM OF THE LIST
				MINWD<LEFT>_#100000;
				DECR K FROM 31 TO 0 DO
				BEGIN
					IF .CHOSEN[.K]<LEFT> LSS .MINWD<LEFT> THEN
					(MINWD<LEFT>_.CHOSEN[.K]<LEFT>;
					MINWD<RIGHT>_.K;);
				END;
END;


!
!*************************************************
!
ROUTINE MELDPLEX=
BEGIN
	!MELD IN CONSIDERATION OF THE COMPLEXITY OF THE
	!EXPRESSIONS INVOLVED AND ADJUST REGTOALC APPROPRIATELY
	!
	!THIS IS STRICTLY A HEURISTIC:
		!THE COMPLEXITY DISTRIBUTION IS EXAMINED.
		!THE NUMBER OF REGISTERS AVAILABLE IS DECREASED BY 1
			!FOR EACH STATEMENT OF COMPLEXITY GREATER
			!THAN THE 4 STANDARD COMPUTATION REGISTERS.
		!REGAVAIL ORIGINALLY CONTAINED THE NUMBER OF REGISTERS
		!IT WAS INTENDED TO ALLOCATE GLOBALLY.
		!REGTOALC CONTAINS THE ACTUALL NUMBER WE WILL ALLOCATE.
	!
	!THIS ROUTINE WILL ALSO DETERMINE THE TRUE VALUE OF
	!REGTOALC, THE NUMBER OF REGISTERS THAT **WILL** BE
	!GLOBALLY ALLOCATED. CHOSEN IS EXAMINED TO DETERMINE
	!IF THERE ARE ANY ENTRIES AT ALL.

	LABEL LOP1;

	LOP1:
	DECR I FROM 9 TO 4 DO
		IF .MAXCOMPLEX[.I] NEQ 0 THEN
		BEGIN
			REGAVAIL_.REGAVAIL-.I;
			LEAVE LOP1;
		END;
	REGTOALC_.REGAVAIL;

	!COUNT NON-ZERO ENTRIES IN CHOSEN
	!USE REGAVAIL AS A TEMP

	REGAVAIL_0;
	DECR I FROM 31 TO 0 DO
		IF .CHOSEN[.I] NEQ 0 THEN
			REGAVAIL_.REGAVAIL+1;
	!NOW SEE IF THIS IS LESS THEN REGTOALC DETERMINED
	!FROM THE COMPLEXITIES

	IF .REGAVAIL LSS .REGTOALC THEN REGTOALC_.REGAVAIL;
END;
ROUTINE CLEANUP=
BEGIN
	!GO THROUGH THE SYMBOL TABLE AND ZERO THE MERIT FIELD
	!AND THE LIBARGUSE BIT.
	MACRO REGSTUFF=0,2,LEFT$;

	INCR I FROM 0 TO SSIZ-1 DO
	BEGIN
		REGISTER BASE T;
		T_.SYMTBL[.I];
		WHILE .T NEQ 0 DO
		BEGIN
			T[REGSTUFF]_0;
			!IF THIS IS A FORMAL ARRAY WE HAVE TO ZERO THE
			!MERIT IN THE PSEUDO ENTRY TOO
			IF .T[OPERSP] EQL FORMLARRAY THEN
			BEGIN
				REGISTER BASE ET;
				ET_.T[IDDIM];
				ET_.ET[ARADDRVAR];
				ET[REGSTUFF]_0;
			END;
			T_.T[CLINK];
		END;
	END;
END;

FORWARD CALLSAVE;
FORWARD BLDREGCONTENTS,CALRESTORE,LEAFLOOKER,MATERIALIZE;
OWN T;
ROUTINE AUDITOR=
BEGIN
	EXTERNAL CSTMNT,CMSTMN,STBSYR,STRGCT,ALCSTMNT,GBSYREGS,INDVAR;
	MAP BASE INDVAR;
	EXTERNAL FTEMP,LSTLNK,GBSYCT,ALCDOSTMNT,EXITNO,PROGNAME;
	EXTERNAL DOVARSUBSTITUTE;

	LABEL MAKNODS;

	MAP BASE TOP:BOTTOM:CSTMNT;

	EXTERNAL CLOBBREGS,ISN,FRSTLNK;
	LOCAL NOFIT;
	!EXAMINE STATEMENTS IN A LOOP
	!DETERMINE VALUE OF RAISE WHICH DEPENDS ON
	!1. KA OR KI PROCESSOR
	!
	!2. USE OF THE VARIABLE
	!CALLS CREDIT TO WALK TREES ETC.
	HEAD_0;			!INITILIZE FOR EXTRIES INTO CHOSEN
	!MAKE ADJUSTMENTS FOR THE REGISTERS USED IN P2SKELETON FOR THE
	!DO INDUCTION INDEX

	!INITIALIZE PRELOADFLG
	PRELOADFLG_0;

		IF .TOP[SRCID] EQL DOID THEN
		BEGIN			!NOT THE MAIN PROGRAM
			!WE KNOW IT IS AN INNERDO LOOP BECAUSE
			!WE ALLOCATE NOTHING ELSE BUT.

			!SOME REGCONTENTS NODES WERE SUBSTITUTED BY 
			!P2SKELETON. SUB TRACT A REG FROM THIS 
			!ALGORITHM TO SAVE TO CONTINUE THE SUBSTITUTION

			CSTMNT_.TOP;
			ISN_.CSTMNT[SRCISN];
			STBSYR_.GBSYREGS;
			STRGCT_.GBSYCT;
			ALCDOSTMNT();
			REGAVAIL_.REGAVAIL-1;
		END;

	CLEANSLATE_.GBSYREGS;
	LIBFNREFNO_FNREFNO_CALLREFNO_0;

	!IF THIS IS AN ACTUAL DO LOOP GET THE COMPLEXITIES
	!OF THE STATEMENTS WITHIN IT. IF  THIS IS THE MAIN 
	!PROGRAM DONT BOTHER, CUZ ITS ALREADY BEEN DONE.

		!DO NOT GET THE COMPLEXITY OF THE DO LOOP TWICE
		!OR COUNT IT FOR REGISTER ALLOCATION, SINCE
		!THE NUMBER OF TIMES THROUGH THE LOOP IS COMPUTED
		!OUTSIDE THE LOOP.
		P_.TOP[SRCLINK];
		WHILE .P NEQ .BOTTOM[SRCLINK] DO
		BEGIN
			CSTMNT_.P;
			ISN_.CSTMNT[SRCISN];
			IF .DLOOPTREE NEQ 0 THEN
			CMSTMN();
			ASCRIBE(.P);
			P_.P[SRCLINK];
		END;

	!FOR THE MAIN PROGRAM CHECK THAT THERE WERE REALLY ANY
	!SUBPROGRAM CALLS

	IF .DLOOPTREE EQL 0 AND .FNREFNO EQL 1 THEN
		FNREFNO_0;
	!NOW SUBTRACT FNREFNO FROM ALL
	!IF ANY GO NEGATIVE DELETE FROM LIST
	!	ADJUST FNREFNO TO REFLECT THE ACTUAL COST OF THE NUMBER OF
		!FUNCTION REFERENCES AND CALLS
		FNREFNO_.FNREFNO*(IF .KA10FLG THEN .KAMERIT[FUNUSE]
					ELSE .KIMERIT[FUNUSE]);
	!ALSO ADJUST LIBFNREFNO
	LIBFNREFNO_.LIBFNREFNO*(IF .KA10FLG THEN .KAMERIT[FUNUSE]
				ELSE .KIMERIT[FUNUSE]);

	INCR K FROM 0 TO .HEAD-1 DO
	BEGIN
		IF .CHOSEN[.K]<LEFT> LSS .FNREFNO THEN	!ITS GOING NEGATIVE
		CHOSEN[.K]_0
		ELSE
		BEGIN
		CHOSEN[.K]<LEFT>_.CHOSEN[.K]<LEFT>-.FNREFNO;
		!IF WE ARE STILL IN THE GAME DEDUCT LIBFNREFNO TOO IF
		!IT APPLIES.

		P_.CHOSEN[.K]<RIGHT>;
		IF .P[LIBARGUSE] THEN
		BEGIN
			IF .CHOSEN[.K]<LEFT> LSS .LIBFNREFNO THEN
				CHOSEN[.K]_0
			ELSE
				CHOSEN[.K]<LEFT>_.CHOSEN[.K]<LEFT>-.LIBFNREFNO;
		END;
		END;

	END;
	!CONSIDER ACTUAL COMPLEXITY OF EXPRESSIONS INVOLVED
	!
	MELDPLEX();

	!LOOK FOR THE DO LOOP INDUCTION VARIABLE. ZERO IT IF FOUND
	IF .DLOOPTREE NEQ 0 THEN
	BEGIN
		P_LOOKUP(.INDVAR);
		IF .P LSS 32 THEN
			CHOSEN[.P]_0;
	END;

	INDUCONLY_0;		!RESET FLAG

	!DONT BOTHER WITH THE PROCESS, IF WE ARE NOT GOING TO ALLOCATE ANY
	!IN A MAIN PROGRAM. BUT MUST CONTINUE SUBSTITUTION OF
	!THE REGCONTENTS NODE FOR THE INDUCTION VARIABLE
	IF .REGTOALC LEQ 0 THEN
	BEGIN
		CLEANUP();
		P_.TOP;
		!DO THE LEAF SUBSTITUTION STUFF AND MATERIALIZATION
		!ONLY IF THERE ARE NOT FUNCTION REFS AND WE
		!HAVE AN INTEGER INDEX. OTHERWISE IT JUST
		!ISNT WORTH ANYTHING.
		IF .DLOOPTREE NEQ 0
		AND .FNREFNO EQL 0
		AND .INDVAR[VALTP1] EQL INTEG1
		AND ((.TOP[FLCWD] AND NOT .TOP[NOFLCWDREG])
		OR NOT .TOP[FLCWD])  THEN
		BEGIN
			!RESET THE NEDSMATRLZ FLAG IN THIS CASE
			TOP[NEDSMATRLZ]_0;
			PA_CHOSEN[0]_MAKPR1(0,REGCONTENTS,
					0,INDEX,0,.TOP[DOSYM]);
			PA[TARGTAC]_.TOP[DOIREG];
			PA[TARGADDR]_.TOP[DOIREG];
			PA[INREGFLG]_1;
			GLOBREG[0]_.INDVAR;
			REGTOALC_1;
			SPECCASE_1;
			ITMCT_0;
			!SET FLAG THAT SAYS ONLY INDUCTION VARIABLE IS IN REG
			INDUCONLY_1;	!SET FLAG
		END ELSE
		BEGIN
			 REGTOALC _ 0;
			TOP[NEDSMATRLZ]_1;
		END;

		IF .P[SRCID] EQL DOID THEN P_.P[SRCLINK];
		LASTAT_.TOP;
		WHILE .P NEQ .BOTTOM[SRCLINK] DO
		BEGIN
			THISTAT_CSTMNT_.P;
			ISN_.CSTMNT[SRCISN];
			FTEMP_.FRSTLNK;

			STBSYR_.GBSYREGS;
			STRGCT_.GBSYCT;

			!SAVE VALUE OF NEXT STATEMENT
			!IN CASE CALRESTORE IS CALLED TO INSERT
			!RESTORATION NODES.  SUCH MUST NOT
			!BE REPROCESSED BY LEAFLOOKER.
			SAVHITCH_.P[SRCLINK];

			IF .INDUCONLY THEN
				LEAFLOOKER(.P);
			UNTIL .P[SRCLINK] EQL .SAVHITCH DO
				P_.P[SRCLINK];
			!WE ARE NEVER SAVING OR RESTORING THE
			!INDUCTION VARIABLE.
			ALCSTMNT();
			LASTAT_.P;
			P_.P[SRCLINK];
		END;
	!UNFORTUNATELY WE HAVE TO MATERIALIZE IF THERE ARE
	!EXITS.

		!DONT TRY TO MATERIALIZE UNLESS THERE HAS BEEN A
		!SUBSTITUTION.
		IF .INDUCONLY THEN
		MATERIALIZE();
		RETURN;
	END;



	!NOW ACTAULLY MAKE UP ORDERED  LIST OF VARIABLES IN REGISTER
	HEAD_0;						!USE HEAD AS A COUNTER
	!BASICALLY A BUBBLE SORT WHICH STOPS AFTER THE FIRST REGTOALC
	!ARE IN ORDER (THIS IS ROUGHLY 10 OR LESS).
	!AT THE SAME TIME ITEMS ARE SWITCHED INTO THE LIST GLOBREG.
	!THE PROCESSING OCCURS *DOWN* CHOSEN WITH *BUBBLING* UP
	!GLOBREG. PA,PB,PC,HEAD AND T ARE USED AS TEMPORARIES,
	!MOSTLY FOR INDICES AND POINTERS.
	PD_0;			!PD IS POINTER INTO CHOSEN.ZERO ENTRIES ARE SKIPPED
	WHILE .HEAD LEQ .REGTOALC AND .PD LEQ 31 DO
	BEGIN
		IF .CHOSEN[.PD] NEQ 0 THEN		!FOR NON-0 ENTRIES
		BEGIN
			PA_.CHOSEN[.PD];
			NOFIT_1;
			T_.HEAD-1;
			!INSERT IN THE RIGHT PLACE IN GLOBREG
			!INA PSEUDO -BUBBLE WAY
			IF .HEAD EQL 0 THEN GLOBREG[.HEAD]_.PA;
			WHILE .NOFIT AND .T GEQ 0 DO
			BEGIN
				IF .PA GTR .GLOBREG[.T] THEN
				BEGIN
					GLOBREG[.T+1]_.GLOBREG[.T];
					T_.T-1;
					IF  .T EQL -1 THEN
						GLOBREG[0]_.PA;
				END ELSE
				BEGIN
					NOFIT_0;
					GLOBREG[.T+1]_.PA;
				END;
			END;		!WHILE
			HEAD_.HEAD+1;
		END;			!NON ZERO ENTRY
		!IN EITHER CASE AN ITEM OF CHOSEN IS PROCESSED
		PD_.PD+1;
	END;			!WHILE ON HEAD AND PD
	IF .HEAD LSS .REGTOALC THEN REGTOALC_.HEAD;
	!

	NOFIT_0;	!SET FLAG TO SAY INDUCTION VARAIBLE NOT
			!BEING SUBSTITUTED.

	!NOW REGTOALC HAS THE NUMBER OF VARIABLES THAT
	!WE WANT TO ALLOCATE. SOME MAY BE DOUBLE AND
	!SO ALL WILL NOT ACTUALLY GET ALLOCATED. MAKE
	!THOSE ADJUSTMENTS AND REGCONTENTS NODES FOR THOSE
	!THAT WILL ACTUALLY BE ALLOCATED.
	!MINWD WILL CONTAIN THE NUMBER OF THE REGISTER TO ALLOCATE
	!EACH TIME. HEAD WILL CONTAIN THE LIMIT NUMBER BEYONF WHICH
	!WE SHALL NOT GO. REGS INCLUDING HEAD MAY BE ALLOCATED.

	!IF ALLOCATING FROM 15 TO 2
	!GOING IN THE OPPOSITE DIRECTION IS A BIG BUMMER. THE NOT 
	!WILL FIX IT
	IF .BTTMSTFNFLG THEN
	BEGIN
		!IF THERE WERE DOUBLE WORD QUANTITIES IN THE LOOP
		!WE MUST MAKE SURE THAT THE LOCAL ALLOCATOR IS LEFT
		!AN EVEN-ODD PAIR.
		IF .GOTEMDBL AND .DLOOPTREE NEQ 0 THEN
			HEAD_6
		ELSE
			!NO DOUBLE WORDS TO WORRY ABOUT. IF THIS IS
			!A REAL PROGRAM LOOP
			IF .DLOOPTREE NEQ 0 THEN
				HEAD_.TOP[DOIREG]+3
			ELSE
				HEAD_5;
		MINWD_#15;
	END ELSE
	!ALLOCATING FROM 2 TO 15
	BEGIN
		MINWD_2;
		!IF WE HAVE DOUBLE WORDS LEAVE AN EVEN-ODD PAIR FOR
		!FOR THE LOCAL ALLOCATOR.
		IF .GOTEMDBL AND .DLOOPTREE NEQ 0 THEN
			HEAD_#11
		ELSE
			!NO DBL TO WORRY ABOUT. IF ITS A PROGRAM LOOP
			IF .DLOOPTREE NEQ 0 THEN
				HEAD_.TOP[DOIREG]-3
			ELSE
				HEAD_#12;
	END;

	!NOW WE KNOW WHERE TO START AND WHERE TO STOP.
	!START AT MINWD. STOP AT HEAD.

	MAKNODS:
	!ALLOCATING FROM 15 TO 2
	IF .BTTMSTFNFLG THEN
	BEGIN
		!FOR EACH QUANTITY TOCATE (REGTOALC AT THIS POINT)
		INCR I FROM 0 TO .REGTOALC-1 DO
		BEGIN
			GLOBREG[.I]<LEFT>_0;	!ZERO MERIT HALF OF WORD
			PA_.GLOBREG[.I];

			!IF IT A DBL THEN MAKE SURE ITS EVEN
			IF .PA[DBLFLG] THEN
			BEGIN
				IF .MINWD THEN
					MINWD_.MINWD-1
				ELSE
					MINWD_.MINWD-2;
			END;	!DBL ADJUSTMENTS
			!IF ITS STILL OK TO ALLOCATE
			IF .MINWD GEQ .HEAD THEN
			BEGIN
				CHOSEN[.I]_BLDREGCONTENTS(.PA);
				MINWD_.MINWD-1;
			END ELSE
			!WERE ALL OUT OF REGS
			BEGIN
				REGTOALC_.I;	!RESET  REGTOALC TO
				!THE NUMBER ACTUALLY TO BE ALLOCATED
				LEAVE MAKNODS;	!GET OUT
			END;
		END;	!INCR LOOP
	END ELSE
	!ALLOCATING FROM 2 TO 15
	BEGIN
		!FOR EACH QUANTITY
		INCR I FROM 0 TO .REGTOALC-1 DO
		BEGIN
			PD_0;	!SET FLAG
			GLOBREG[.I]<LEFT>_0;	!ZERO MERIT HALF OF WD
			PA_.GLOBREG[.I];
			!IF ITS A DOUBLE WORD MAKE SURE ITS
			!EVEN
			IF .PA[DBLFLG] THEN
			BEGIN
				IF .MINWD THEN
					MINWD_.MINWD+1;
				!IF ITS STILL LEGIT
				IF .MINWD+1 LEQ .HEAD THEN
					!SET FLAG
					PD_1;
			END ELSE	!NOT DBLWORD
				IF .MINWD LEQ .HEAD THEN PD_1;

			!PD NOW SAYS IFS IT OK TO ALLOCATE.
			!MINWD POINTS TO THE REGISTER NUMBER
			IF .PD THEN
			BEGIN
				CHOSEN[.I]_BLDREGCONTENTS(.PA);
				MINWD_.MINWD+1+.PA[DBLFLG];
			END ELSE
			!NOT LEGIT TO ALLOCATE
			BEGIN
				REGTOALC_.I;
				LEAVE MAKNODS;
			END;
		END;	!INCR LOOP
	END;	!ALLOCATING 2 TO 15

	!REGTOALC AT LAST CONTAINS THE NUMBER WE ARE (WILL BE AND
	!HAVE BEEN) ALLOCATING.


	!ADD THE INDUCTION VARIABLE TO THE LIST

	IF .DLOOPTREE NEQ 0
	AND ((.TOP[FLCWD] AND NOT .TOP[NOFLCWDREG])
	OR NOT .TOP[FLCWD])  THEN
	BEGIN
		!RESET NEDSMATRLZ ON TOP
		TOP[NEDSMATRLZ]_0;
		PA_
		CHOSEN[.REGTOALC]_MAKPR1(0,REGCONTENTS,0,.INDVAR[VALTYPE],0,
			.TOP[DOSYM]);
		NOFIT_1;
		GLOBREG[.REGTOALC]_.INDVAR;
		PA[TARGTAC]_.TOP[DOIREG];
		PA[TARGADDR]_.TOP[DOIREG];
		PA[INREGFLG]_1;
		!UNFORTUNATELY IF THERE ARE CALLS IN THIS LOOP
		!WE HAVE TO FORCE MATERIALIZED LOOP ENDING CODE TO
		!PREVENT THE LOOP CONTROL COUNT FROM A CLOBBERING.
		IF .CALLREFNO NEQ 0 THEN TOP[NEDSMATRLZ]_1;
		REGTOALC_.REGTOALC+1;
	END;


	!NOW WALK TREE AND PUT IN ALLOCATIONS
	SPECCASE_1;		!FLAG FOR LEAFSUBSTITUTE
	CLEANUP();
	ITMCT_.REGTOALC-1;
	P_.TOP;
	QQ_0;
	IF .P[SRCID] EQL DOID THEN
	BEGIN
		DOVARSUBSTITUTE(.P);
		P_.P[SRCLINK];
	END;
	!IF THIS IS A DO LOOP IT IS OBVIOUSLY CORRECT TO DO THIS.
	!IF THIS IS A MAIN SEGMENT OF CODE TOP SHOULD BE A CONTINUE
	!AND SO DOING THIS WILL CAUSE NO HARM. IT WILL BE CORRECTLY
	!UPDATED BEFORE USEAGE.
	LASTAT_.TOP;		!POINTER TO PREVIOUS STATEMENT
	THISTAT_.P;		!POINTER TO CURRENT STATEMENT
	WHILE .P NEQ .BOTTOM[SRCLINK] DO
	BEGIN
		CSTMNT_.P;
		ISN_.CSTMNT[SRCISN];
		!SEE EXPLANATION BELOW .
		SAVHITCH_.P[SRCLINK];
		STBSYR_.CLEANSLATE;
		STRGCT_ONESCOUNT(.CLEANSLATE);
		LEAFLOOKER(.P);

			!IF THE STATEMENT JUST PROCESSED  WAS AN
			!ASSIGNMENT STATEMENT WITH THE LHEXP AN
			!ALLOCATED VARIABLE AND THE RIGHT HAND SIDE
			!A USER DEFINED FUNCTION, LEAFLOOKER HAS
			!DONE THE SUBSTITUTION AND WE HAVE TO UNDO IT
			!HERE. IF IT IS NOT UNDONE THE RESTORE DONE IN
			!CALRESTORE WILL CLOBBER THE GOOD FUNCTION VALUE.
			!THIS IS ALSO TRUE IF THE RHS INVOLVED ONLY
			!OPERATIONS THAT COULD BE DONE IN REG 0.
			IF  .P[SRCID] EQL ASGNID AND .QQ EQL 1  THEN
				IF .P[A1VALFLG] AND NOT .P[A2VALFLG] THEN
				BEGIN
					PA_.P[RHEXP];
					IF (.PA[OPRCLS] EQL FNCALL AND
					.PA[OPERSP] NEQ LIBARY) OR
					.PA[ALCRETREGFLG]
					 THEN
						INCR I FROM 0 TO .REGTOALC-1 DO
							IF .CHOSEN[.I] EQL .P[LHEXP] THEN
								P[LHEXP]_.GLOBREG[.I];
				END;
		FTEMP_.FRSTLNK;
		ALCSTMNT();		!ALLOCATE REST OF STATEMENT
		!FOR NON LIBARY QQ=1 SAVING ALL

		IF .QQ EQL 1 THEN
		BEGIN
			CALLSAVE();
			CALRESTORE();
			QQ_0;
		END;
			!CALRESTORE MAY HAVE  INSERTED ASSIGNMENT NODES INTO
			!THE ENCODED SOURCE TO RELOAD THE REGISTERS
			!THESE MUST NOT BE PROCESSED AGAIN IN THIS
			!WHILE LOOP AS LEAFLOOKER WILL SUBSTITUTE
			!THE REGCONTENTS NODE FOR THE VARIABLE, CAUSING
			!THE *POOR* CODE MOVE R,R TO BE GENERATED.

			UNTIL .P[SRCLINK] EQL .SAVHITCH DO
				P_.P[SRCLINK];
		LASTAT_.P;
		P_.P[SRCLINK];
		THISTAT_.P;
	END;

	!LOAD THE REGISTERS OUTSIDE THE LOOP
	P_.LENTRY;
	!LOOK FOR THE STATEMENT IMMEDIATELY IN FRONT OF TOP
	!LENTRY EQL TOP IN A MAIN PROGRAM
	IF .LENTRY NEQ .TOP THEN
	WHILE .P[SRCLINK] NEQ .TOP DO
		P_.P[SRCLINK];
	!CATCH A SUBPROGRAM (TOP WILL BE IN FRONT OF THE ENTRY).
	IF .TOP[SRCID] NEQ DOID AND .PROGNAME NEQ SIXBIT'MAIN. ' THEN
		IF .PROGNAME NEQ SIXBIT'.BLOCK' THEN
		BEGIN
			WHILE .TOP[SRCID] NEQ ENTRID DO
				TOP_.TOP[SRCLINK];
			P_.TOP;
		END;


	THISTAT_.P;

	!ON THE MAIN PROGRAM DONT PRELOAD IF VARIBALE NOT IN A DATA
	!STATEMENT. SET SPECCASE TO 3 TO TRIGGER THIS CHECK IN CALRESTORE
	IF .PROGNAME EQL SIXBIT'MAIN. '
	AND .DLOOPTREE EQL 0  THEN SPECCASE_3
	ELSE
	BEGIN
		SPECCASE_0;
		!TAKE THE INDUCTION VARIABLE OUT OF THE LIST
		!	A. IF IT WAS ON THE LIST (NOFIT#0
		!	B. IF THERE IS NONE OTHER THAN NORMAL EXIT
		IF .NOFIT AND .EXITNO EQL 0  THEN
		REGTOALC_.REGTOALC-1;
	END;

	!MAKE SURE FLAG WHICH COMMUNICATES BETWEEN CALLSAVE AND CALRESTORE
	!IS RESET FOR THIS STANDALONE CALL TO CALRESTORE
	!ALSO SET FLAG TO SAY THAT ANY LABEL SHOULD BE
	!MOVED BACK TO THE LOADS.
	PRELOADFLG_1;
	NEDNEWDOEND_0;
	CALRESTORE();
	MATERIALIZE();		!MATERIALIZE VARIABLES IN REGS
	!WE STILL HAVE NOT PRELOADED IN FRONT OF ANY MULTIPLE ENTRIES
	!THAT MAY EXIST. WE WILL NOW LOOK FOR SAME AND DO THE PRELOADS.

	IF .TOP[SRCID] EQL ENTRID THEN
	BEGIN
		!THIS WAS A SUBPROGRAM WE WERE ALLOCATING TO BEGIN WITH
		P_.TOP[SRCLINK];
		WHILE .P NEQ .BOTTOM DO
		BEGIN
			WHILE .P[SRCID] NEQ ENTRID AND .P NEQ .BOTTOM DO
				P_.P[SRCLINK];
			!HERE P IS EITHER A POINTER TO AN ENTRY STATEMENT
			!OR BOTTOM
			IF .P[SRCID] EQL ENTRID THEN
			BEGIN
				THISTAT_.P;
				CALRESTORE();
			END;
			IF .P NEQ .BOTTOM THEN P_.P[SRCLINK];
		END;
	END;

END;


MAP PEXPRNODE QQ:P;
ROUTINE BLDREGCONTENTS(VAR)=
BEGIN
	EXTERNAL CLOBBREGS;
	LOCAL BASE T;
	MAP BASE VAR;
	!NEED TO COPY VALTYPE STUFF ETC. FROM SYMBOLTABLE
	QQ_MAKPR1(0,REGCONTENTS,0, .VAR[VALTYPE],0, .VAR);
	QQ[TARGTAC]_QQ[TARGADDR]_.MINWD;
	QQ[INREGFLG]_1;
	!FOR DOUBLE PRECISION AND COUNTING UPWARD
	!ADD THE ONE NOW

	!RESET BITS IN CLEASLATE IT SAY REGS ARE USED.
	!SET BITS IN CLOBBREGS TO SAY BITS ARE USED.

	CLEANSLATE_CLRBIT(.CLEANSLATE,INVASNREG(.MINWD));
	CLOBBREGS_SETBIT(.CLOBBREGS,INVASNREG(.MINWD));
	!IF DOUBLE PRECISION DO IT FOR MIN+1 ALSO
	IF .VAR[DBLFLG] THEN
	BEGIN
		CLEANSLATE_CLRBIT(.CLEANSLATE,INVASNREG(.MINWD+1));
		CLOBBREGS_SETBIT(.CLOBBREGS,INVASNREG(.MINWD+1));
	END;

	.QQ
END;


EXTERNAL LEAFSUBSTITUTE,IOSUBSTITUTE;

ROUTINE LEAFLOOKER(P)=
BEGIN
	!ROUTINE USED BY DEFINITION POINT ALGORITHM
	!		AND
	!REGISTER ALLOCATION TO LOOK AT LEAVES
	!P   - POINTS TO A STATEMENT
	EXTERNAL CSTMNT,MISCIO;
	LOCAL BASE TMP;
	MAP PEXPRNODE P:TOP;

		!LOOK FOR COMMON SUB-EXPRESSIONS THAT
		!MAY BE THERE FROM LOCAL ELIMINATION
		!ON STATEMENTS THAT  DO NOT POSTDOMINATE
		!THE ENTRY OF THEIR LOOP

		IF .P[SRCCOMNSUB] NEQ 0 THEN
		BEGIN
			TMP_.P[SRCCOMNSUB];
			DO
			BEGIN
				IF .TMP[A2VALFLG] THEN
				BEGIN
					DECR I FROM .ITMCT TO 0 DO
					BEGIN
						IF .TMP[ARG2PTR] EQL .GLOBREG[.I] THEN
						BEGIN
						TMP[ARG2PTR]_.CHOSEN[.I];
						!SET THE IMMED FLG IF IT IS
						!AN AOBJN GUY.
						IF .TOP[FLCWD] AND
						.GLOBREG[.I] EQL .TOP[DOSYM] THEN
							TMP[A2IMMEDFLG]_1;
						END;
					END;
				END ELSE
				LEAFSUBSTITUTE(.TMP[ARG2PTR]);
				TMP_.TMP[CLINK];
			END UNTIL .TMP EQL 0;
		END;

	SELECT .P[SRCID] OF NSET
	!*****
	ASGNID:						!ASSIGNMENT STATEMENT
	BEGIN
		LEAFSUBSTITUTE(.P[RHEXP]);
		LEAFSUBSTITUTE(.P[LHEXP]);

	END;
	!*****
	CALLID:						!CALL STATEMENT
	BEGIN
		!DO NOT SAVE AND RESTORE IF THE
		!INDUCTION VARIABLE IS THE ONLY REGISTER WE ARE
		!ALLOCATING
		IF NOT .INDUCONLY THEN
		CALLSAVE();
		IF .P[CALLIST] NEQ 0 THEN
		BEGIN
			LOCAL ARGUMENTLIST ARGL;
			ARGL_.P[CALLIST];
			INCR I FROM 1 TO .ARGL[ARGCOUNT] DO
			BEGIN
				TMP_.ARGL[.I,ARGNPTR];
				IF .TMP[OPRCLS] NEQ LABOP AND .TMP[OPRCLS] NEQ DATAOPR  THEN
				LEAFSUBSTITUTE(.ARGL[.I,ARGNPTR]);
			END;
		END;
		IF NOT .INDUCONLY THEN
		CALRESTORE();
	END;
	!*****
	AGOID:
	LEAFSUBSTITUTE(.P[AGOTOLBL]);
	!*****
	CGOID:						!COMPUTED GO TO
	LEAFSUBSTITUTE(.P[CGOTOLBL]);
	!*****
	IFAID:						!ARITHMETIC IF
	LEAFSUBSTITUTE(.P[AIFEXPR]);
	!*****
	IFLID:						!LOGICAL IF
	BEGIN
		LEAFSUBSTITUTE(.P[LIFEXPR]);
		!FUDGE CSTMNT TO POINT TO THE OTHER STATEMENT
		TMP_.CSTMNT;
		CSTMNT_.P[LIFSTATE];
		LEAFLOOKER(.P[LIFSTATE]);
		CSTMNT_.TMP;
	END;
	!*****
	READID:
	BEGIN
		MISCIO(.P);
		TMP_.P[IOLIST];
		WHILE .TMP NEQ 0 DO
		BEGIN
			IOSUBSTITUTE(.TMP);
			TMP_.TMP[SRCLINK];
		END;
	END;
	!*****
	WRITID:
	BEGIN
		MISCIO(.P);
		TMP_.P[IOLIST];
		WHILE .TMP NEQ 0 DO
		BEGIN
			IOSUBSTITUTE(.TMP);
			TMP_.TMP[SRCLINK];
		END;
	END;
	!*****
	ENCOID:
	BEGIN
		MISCIO(.P);
		TMP_.P[IOLIST];
		WHILE .TMP NEQ 0 DO
		BEGIN
			IOSUBSTITUTE(.TMP);
			TMP_.TMP[SRCLINK];
		END;
	END;
	!*****
	DECOID:
	BEGIN
		MISCIO(.P);
		TMP_.P[IOLIST];
		WHILE .TMP NEQ 0 DO
		BEGIN
			IOSUBSTITUTE(.TMP);
			TMP_.TMP[SRCLINK];
		END;
	END;
	!*****
	FINDID:
		MISCIO(.P);
	!*****
	TESN;
END;

GLOBAL ROUTINE CALLSAVE=
!MATERIALIZE EVERYTHING IN A REGISTER BEFORE A CALL OR FUNCTION REFERENCE
BEGIN
	EXTERNAL CSTMNT,DLOOPTREE;
	LOCAL BASE T;
	OWN PO;
	MAP PEXPRNODE THISTAT:LASTAT:PREV:PO:TOP;

	!RESET FLAG
	NEDNEWDOEND_0;
	PREV_0;			!TEMP LINK
	INCR I FROM 0 TO .REGTOALC-1 DO
	BEGIN
		!REGCONTENTS NODES ARE POINTED TO BY CHOSEN[.I]
		!WE ONLY NEED TO MAKE THE ASSIGNMENT NODES
		!THE DATA SPACE REQUIRED COULD BE SHORTENED IF A
		!SPECIAL NODE STATEMENT TYPE WERE CREATED.
		!IT IS QUICKER AND CHEAPER THIS WAY.
		NAME<LEFT>_ASGNSIZ+SRCSIZ;
		QQ_CORMAN();		!GET CORE
		IF .I EQL 0 THEN		!1ST TIME THRU
		BEGIN
			LASTAT[SRCLINK]_.QQ;		!HOOK UP
			!THEN FIX UP LABEL IF ANY
			!NEED TO MOVE LABEL BACK TO FIRST
			!MATERIALIZATION NODE
			IF .THISTAT[SRCLBL] NEQ 0 THEN
			BEGIN
				!FOR ANY GOTO (TRANSFER TO THIS
				!LABEL WE WANT TO MOVE IT BACK. FOR
				!DO LOOPS THAT END HERE WE NEED TO
				!MOVE IT FORWARD. WE *WILL* ACTUALLY
				!MOVE IT BACK AND SET A FLAG TO CAUSE
				!CALRESTORE TO CREATE A NEW DO LOOP ENDING LABEL
				IF (.THISTAT[SRCLBL] EQL .TOP[DOLBL])
				AND (.DLOOPTREE NEQ 0) THEN
					NEDNEWDOEND_1;
				QQ[SRCLBL]_.THISTAT[SRCLBL];
				PO_.QQ[SRCLBL];	!FIX LABEL TABLE TOO
				PO[SNHDR]_.QQ;
				THISTAT[SRCLBL]_0;
			END;
		END ELSE PREV[SRCLINK]_.QQ;
		QQ[LHEXP]_.GLOBREG[.I]<RIGHT>;
		QQ[RHEXP]_.CHOSEN[.I];
		QQ[OPRCLS]_STATEMENT;
		QQ[SRCID]_ASGNID;
		QQ[A1VALFLG]_1; QQ[A2VALFLG]_1;
		QQ[SRCCMPLX]_1;		!SET COMPLEXITY
		QQ[A2SAMEFLG]_1;		!AND FLAGS NEEDED BY CG
		T_.CHOSEN[.I];
		QQ[ASMNTREG]_.T[TARGTAC];

		PREV_.QQ;
	END;			!INCE LOOP
	QQ[SRCLINK]_.THISTAT;
END;			!CALLSAVE
ROUTINE CALRESTORE=
BEGIN
	EXTERNAL CSTMNT,MOVLAB,BOTTOM;
	LOCAL BASE T;
	MAP PEXPRNODE THISTAT:PREV:TOP;
	LABEL LOADEM;
!PUT VALUES BACK INTO REGISTERS AFTER A FUNCTION CALL OR REFERENCE
	PREV_.THISTAT;
	!SAVE THE LINK ON THIS ONE TO LINK UP THE END
	PD_.THISTAT[SRCLINK];

	INCR I FROM 0 TO .REGTOALC-1 DO
	LOADEM:
	BEGIN
		!IN THE MAIN PROGRAM, IF THE VARIABLE IS NOT IN
		!A DATA STATEMENT THEN DONT PUT IT IN A REG.
		!SPECCASE IS 3

		IF .SPECCASE EQL 3 THEN
		BEGIN
			QQ_.GLOBREG[.I];
			IF NOT .QQ[IDATTRIBUT(INDATA)]
			AND NOT .QQ[FORMLFLG]  THEN
				LEAVE LOADEM;
		END;
		NAME<LEFT>_ASGNSIZ+SRCSIZ;
		QQ_CORMAN();		!GET CORE
		PREV[SRCLINK]_.QQ;	!LINK UP

		!IF THIS CALL IS TO PRELOAD REGISTERS IN FRONT OF THE LOOP
		!WE NEED TO MOVE ANY LABEL ON TOP BACK TO THESE
		!PRELOADS. PRELOADFLG SAYS THE CALL IS FOR SAME.
		IF .PRELOADFLG AND .I EQL 0 THEN
		BEGIN
			!ALSO ONLY THE FIRST TIME THRU
			IF .TOP[SRCLBL] NEQ 0 THEN
			BEGIN
				!AND THERE IS A %&$%% LABEL
				T_QQ[SRCLBL]_.TOP[SRCLBL];
				TOP[SRCLBL]_0;
				!ZERO TOPS LABEL AND SET THE LABEL TABLE
				!ENTRY FIELD TOO
				T[SNHDR]_.QQ;
			END;
		END;

		QQ[RHEXP]_.GLOBREG[.I];
		QQ[OPRCLS]_STATEMENT;
		QQ[SRCID]_ASGNID;
		QQ[LHEXP]_.CHOSEN[.I];
		QQ[A1VALFLG]_1; QQ[A2VALFLG]_1;
		!SET FLAGS AND FIELDS NECESSRY FOR CG
		QQ[A1SAMEFLG]_1;
		QQ[SRCCMPLX]_1;
		T_.CHOSEN[.I];
		QQ[ASMNTREG]_.T[TARGTAC];
		PREV_.QQ;
	END;
	PREV[SRCLINK]_.PD;
	!QQ NOW POINTS TO THE LAST STATEMENT CREATED IN THIS
	!SEQUENCE. IF THE FLAG NEDNEWDOEND IS SET CALL THE
	!ROUTINE MOVLAB TO DO THE DIRTY WORK. THE PARMS ARE
	!THE LABEL, THE STATEMENT TO BE LABELED AND THE LOOP
	!OUTWARD FROM WHICH TO MOVE IT.
	IF .NEDNEWDOEND THEN
	BEGIN
		MOVLAB(.TOP[DOLBL],.QQ,.TOP);
		!ALSO ADJUST BOTTOM
		BOTTOM_.QQ;
	END;

END;
ROUTINE LABLLOK(STMT,LABLE,MATLAB)=

BEGIN
	!LOOK AT LABEL LISTS FOR LABEL.
	!REPLACE IN WITH MATLAB.

	MAP PEXPRNODE STMT;

	!IF THERE IS AN ASSIGNED GO TO WITHOUT ANY ASSIGNS
	!WE COULD STILL BE HERE.  SO WE HAVE TO CHECK FOR
	!THE ABSENCE OF A LIST.
	!A COMPUTES GO TO SHOULD NEVER HAVE GOTOLIST 0
	IF .STMT[GOTONUM] EQL 0 THEN
	BEGIN
		IF .STMT[GOTOLBL] EQL .LABLE THEN
		BEGIN
			STMT[GOTOLBL]_.MATLAB;
			!MAKE THE STATEMENT A STRAIGHT GO TO 
			STMT[SRCID]_GOTOID;
		END;
	END ELSE
	DECR I FROM .STMT[GOTONUM]-1 TO 0 DO

	IF @(.STMT[GOTOLIST]+.I) EQL .LABLE THEN
	BEGIN
		PC_.STMT[GOTOLIST]+.I;
		PC[CESLNK]_.MATLAB;
	END;
END;



FORWARD MATLOK,EXAMBR;
BIND LLLSIZ=30;
OWN LLLNO,LLL[LLLSIZ];
ROUTINE  MAKRETU=
BEGIN
	!PREV POINTS TO THE PLACE WE WILL BUILD A RETURN STATEMENT
	!AND LINK IT ON TO PREV

	MAP BASE PREV:P;

	NAME<LEFT>_SRCSIZ+RETUSIZ;
	P_CORMAN();
	P[OPRCLS]_STATEMENT;
	P[SRCID]_RETUID;

	PREV[SRCLINK]_.P;
	PREV_.P;
END;

ROUTINE MAKSTASH=
BEGIN
	!MAKE AND LINK ALL THE ASSIGNMENT STATEMENTS FOR
	!A MATERIALIZATION
	!HEAD AND PREV AND SET OUTSIDE THE ROUTINE. THE ROUTINE
	!UPDATES THEM AND SETS QQ TO POINT TO THE LABEL IT
	!HAS GENERATED ON THE FIRST ASSIGNMENT.

	LOCAL BASE TMP;
	EXTERNAL INDVAR,GENLAB,DLOOPTREE;
	MAP BASE P:PREV:QQ:TOP;
	DECR K FROM .REGTOALC-1 TO 0 DO
	BEGIN

		NAME<LEFT>_SRCSIZ+ASGNSIZ;
			P_CORMAN();
			P[OPRCLS]_STATEMENT;
			P[SRCID]_ASGNID;
			P[LHEXP]_.GLOBREG[.K];
			P[A1VALFLG]_1;			!SET VALFLG
			P[RHEXP]_.CHOSEN[.K];		!POINTER TO REGCONTENTS NODE
			P[A2VALFLG]_1;
			!WE ARE SURE HERE THAT TOP IS REALLY A DO LOOP
			IF .GLOBREG[.K] EQL .INDVAR THEN
				IF .TOP[FLCWD] THEN
					P[A2IMMEDFLG]_1;
			IF .DLOOPTREE EQL 0 THEN
			BEGIN
				!IF THIS IS A MAIN PIECE OF CODE
				!THESE ASSIGNMENTS WILL
				!NOT GET ALLOCATED SO WE MUST DO IT NOW
				P[A2SAMEFLG]_1;
				TMP_.CHOSEN[.K];
				P[ASMNTREG]_.TMP[TARGTAC];
			END;
			PREV[SRCLINK]_.P;		!HOOK UP
			PREV_.P;
							!THIS EFFECTIVELY ASSIGNS P TO PREV FOR NEXT
							!ITERATION ALSO
			IF .K EQL .REGTOALC-1 THEN	!FOR THE FIRST ONE
			(QQ_GENLAB();
			QQ[SNHDR]_.P;
			P[SRCLBL]_.QQ;)
	END;	!END OF DECR LOOP ON REGTOALC
END;

ROUTINE FIXUPEND=
BEGIN
	!IF OTHER LOOPS SHARE A TERMINAL LABEL WITH
	!THE INNER LOOP WE HAVE JUST ALLOCATED, WE WILL
	!MAKE A CONTINUE AND MOVE THEIR TERMINATIONS TO IT
	!IF WE DID NOT DO THIS ALL THE LOOP TERMINATIONS WOULD APPEAR
	!BEFORE THE MATERIALIZATIONS FOR THE INNER LOOP.

	EXTERNAL MOVLAB;
	MAP BASE P:PA:QQ:TOP;

	QQ_.TOP[DOLBL];
	IF .QQ[SNDOLVL] GTR 1 THEN
	BEGIN
		NAME<LEFT>_SRCSIZ+CONTSIZ;
		P_CORMAN();
		P[OPRCLS]_STATEMENT;
		P[SRCID]_CONTID;
		!LINK IT AT THE BOTTOM WHICH IS HEAD.
		!ALL PATHS ALSO HAVE LEFT PREV POINTING TO
		!THE PRIOR STATEMENT

		P[SRCLINK]_.HEAD;
		PREV[SRCLINK]_.P;
		!WE MOVE FROM THE ONE NEXT OUTER TO TOP
		!OUTWARD, BUT FIRST WE HAVE TO GET IT.

		PA_.QQ[SNDOLNK];	!FIRST ON LINKED LIST
		PA_.PA[RIGHTP];		!NEXT ON LINKED LIST
		MOVLAB(.QQ,.P,.PA[LEFTP]);
	END;
END;
ROUTINE GETLABINFO=
BEGIN
	!CALLED FROM THE MAIN CODE. FOR RELEASE 1 IF THERE
	!ARE EXITS AND WE CANNOT ACCOUNT FOR ALL REFERENCES TO A LABEL
	!LOCALLY, IT MUST BE AN ENTRANCE (LIKE FROMAN EXTENDED RANGE).
	!NO, *NO* GLOBAL ALLOCATION WILL BE DONE ON SUCH.
	EXTERNAL QQ,EXITLST,EXITNO;
	MAP BASE TOP:QQ;

	!BECAUSE IT COULD NOT BE SAVED ANYWHERE, RECREATE THE
	!LOCAL LABEL LIST (LLL) HERE.
	!LLL WILL CONTAIN ALL LABELS DEFINED IN THIS LOOP

	QQ_.TOP;
	EXITNO_0;
	!PRIME EXITLST
	EXITLST[0]_.TOP[DOLBL];
	LLLNO_1;
	DECR I FROM 19 TO 0 DO
	LLL[.I]_0;		!ZERO THEM FIRST

	LLL[0]_2^18+.TOP[DOLBL];
	QQ_.QQ[SRCLINK];

	DO
	BEGIN
		IF .QQ[SRCLBL] NEQ 0 AND .QQ[SRCLBL] NEQ .TOP[DOLBL] THEN
		BEGIN
			IF .LLLNO GTR LLLSIZ THEN RETURN(0);
			LLL[.LLLNO]_1^18+.QQ[SRCLBL];
			LLLNO_.LLLNO+1;
		END;
		!CHECK TO MAKE SURE THAT THIS IS NOT
		!A SINGLE STATEMENT LOOP.
		IF .QQ NEQ .BOTTOM THEN
			QQ_.QQ[SRCLINK];
	END UNTIL .QQ EQL .BOTTOM;

	!NOW MAKE THE EXIT LIST
	!EXAMBR WILL EXAMINE ALL BRANCH STATEMENTS IN THE PROGRAM

	!RESET FLAG
	MINWD_0;
	!MINWD IS USED AS A FLAG.
	!IF WE RUN OUT OF EXITLST SPACE, IT WILL BE SET TO ONE.
	!IF WE ENCOUNTER A RETURN IN A DO LOOP IT WILL BE SET TO 1
	EXAMBR();

	!IF WE RAN OUT OF SPACE
	IF .MINWD THEN
	BEGIN
		MINWD_0;
		!WE KNOW TOP IS A DO LOOP
		TOP[NEDSMATRLZ]_1;
		!HAVE TO FORCE MATERIALIZATION CUZ WE WONT BE
		!SUBSTITUTING THE REGCONTENTS NODES FOR THE INDEX
		RETURN(0);
	END;
	!IF THERE ARE NO EXITS WE ARE OK
	IF .EXITNO NEQ 0 THEN
	BEGIN
		!CHECK COUNTS
		INCR I FROM 1 TO .LLLNO DO
		BEGIN
			!LOOK AT THE LOCAL LABEL LIST.
			!IF COUNTS DONT MATCH THE NUMBER OF REFERENCES
			!COUNTED IN PHASE 1 THEN QUIT.
			!WE SKIP THE DO TERMINATION LABEL ITSELF
			!(LLL[0]).

			QQ_.LLL[.I]<RIGHT>;	!LABEL TABLE POINTER
			IF .QQ[SNREFNO] NEQ .LLL[.I]<LEFT> THEN
				RETURN(0);
		END;
		!WE HAVE NOT LOOKED AT THE DO TERMINATOR ITSELF.
		!IT IS, OF COURSE, A MORE COMPLEX MATTER AS WE WISH
		!NOT TO CONSIDER ANY OTHER LOOP
		!TERMINATORS AS EXITS.
		QQ_.LLL[0]<RIGHT>;
		IF .QQ[SNUMBER] LEQ 99999 THEN
		BEGIN
			!ITS A PROGRAM LABEL. WE DONT HAVE TO
			!WORRY ABOUT GENERATED LABELS. ALL FUDGING FOR THOSE
			!IS ALREADY DONE.
			IF .QQ[SNREFNO] NEQ (.LLL[0]<LEFT>-1+.QQ[SNDOLVL]) THEN
				RETURN 0;
		END;
	END;

	!MADE IT ALL THE WAY THROUGH

	RETURN(1);
END;
ROUTINE NAMESET=
BEGIN
	EXTERNAL NAMLPTR;
	MAP BASE QQ;
	!ONE SMALL CHORE. GO THROUGH ANY NAMELISTS AND SET THE
	!BIT IN THE SYMBOL FOR VARIBALES IN THE NAMELIST

	QQ_.NAMLPTR<LEFT>;
	WHILE .QQ NEQ 0 DO
	BEGIN
		INCR I FROM 0 TO .QQ[NAMCNT]-1 DO
		BEGIN
			REGISTER BASE T1;
			T1_@(.QQ[NAMLIST]+.I);
			T1[IDATTRIBUT(INNAM)]_1;
		END;
		QQ_.QQ[CLINK];
	END;
END;

ROUTINE STOWONRETURN=
BEGIN
	!LOOK FOR ALL RETURN STATEMENTS AND STORE ALLOCATED
	!VARIABLES AWAY.

	!MACRO TO TRANSFORM ITS PARAMETER INTO A GO TO STATEMENT.
	!PARAMETER MUST BE MAPPED TO BASE AND BE A RETURN. NOTE THAT
	!THIS WILL NOT WORK IF THE SIZE (RELATIVE) OF THE NODES
	!CHANGES.

	MACRO MAKAGO(NOD,LABLE)=
	BEGIN
		NOD[SRCID]_GOTOID;
		NOD[GOTOLBL]_.LABLE;
	END$;

	LABEL WHLPREV;
	OWN RFLG;
	OWN BASE RETSPOT;
	MAP BASE BOTTOM:PD:TOP;
	LOCAL BASE STMT;
	MAP BASE PREV:HEAD:PA:QQ;


	RFLG_0;		!SEEN ANY RETURNS YET;
	RETSPOT_0;	!NO RETURN STORES MADE.
	STMT_.TOP;
	WHILE .STMT NEQ .BOTTOM DO
	BEGIN
		HEAD_.STMT;
		PREV_.STMT;
		WHLPREV:
		WHILE 1 DO
		BEGIN
			!SPECIFICALLY QUIT IF A RETURN OR BOTTOM
			IF .PREV[SRCID] EQL RETUID THEN LEAVE WHLPREV;
			IF .PREV EQL .BOTTOM THEN LEAVE WHLPREV;
			!LOOKING FOR RETURNS OR THE END
			!THOSE LOGICAL IFS, ONCE AGAIN,
			!CAUSE A SPECIAL SIDE TRIP.
			IF .PREV[SRCID] EQL IFLID THEN
			BEGIN
				PA_.PREV[LIFSTATE];
				!LOOK TO SEE IF TRUE BRANCH IS A RETURN
				IF .PA[SRCID] EQL RETUID THEN
				BEGIN
					!IT IS. FIRST SET R FLG
					RFLG_1;
					!IF WE ALREADY HAVE A SET OF
					!RETURN MATERIALIZATIONS THEY ARE
					!LABELED BY RETSPOT (NON-ZERO)
					!IF THIS IS A RETURN(I) MAKE A
					!SEPARATE ONE TOO
					IF .RETSPOT NEQ 0 AND .PA[RETEXPR] EQL 0  THEN
						MAKAGO(PA,RETSPOT)
					ELSE
					BEGIN
						!MAKE A SET OF MATERIALIZATIONS
						!THROW THEM IN AT THE END
						!SAVE OUR PLACE
						PD_.PREV;
						PREV_.BOTTOM;
						MAKSTASH();
						!PREV POINTS TO LAST ONE
						!OF ASSIGNMENTS NOW
						!MAKE A RETURN HERE TOO
						MAKRETU();
						!PREV NOW POINTS TO TAHAT
						!RETURN.
						!SEE IF THIS A RETURN (I)
						IF .PA[RETEXPR] NEQ 0 THEN
						BEGIN
							PREV[RETEXPR]_.PA[RETEXPR];
							PA[RETEXPR]_0;
						END ELSE
						RETSPOT_.QQ;
						!NOTE THAT IN RELATION TO
						!REMARKS LATER IN THIS ROUTINE
						!THIS TRUE BRANCH ROUTINE
						!CAN NEVER BE LABELED
						!RESET PREV
						PREV_.PD;
						MAKAGO(PA,QQ);
					END;
				END;
			END;
			HEAD_.PREV;
			PREV_.PREV[SRCLINK];
		END;		!WHILE 1 DO

		!IF THIS IS THE END STATEMENT, JUST STASH THE REGS
		!AND QUIT THIS HASSLE
		IF .PREV EQL .BOTTOM THEN
		BEGIN
			IF .PREV[SRCID] EQL ENDID THEN
			BEGIN
				PREV_.HEAD;
				HEAD_.HEAD[SRCLINK];
				MAKSTASH();
				PREV[SRCLINK]_.HEAD;
				RETURN;
			END;
			RETURN;
		END;

		!IF THIS IS A RETURN SET RFLG
		IF .PREV[SRCID] EQL RETUID THEN RFLG_1;


		!HEAD NOW POINTS TO THE STATEMENT BEFORE
		!A RETURN AND PREV TO THE RETURN.
		!SET PA TO THE STATEMENT BEFORE THE RETURN
		PA_PREV_.HEAD;
		HEAD_.HEAD[SRCLINK];
		!PA AND PREV BOTH POINT TO THE STATEMENT BEFORE THE
		!RETURN, HEAD TO THE RETURN ITSELF
		!MAKSTASH EXPECTS PREV TO BE SET UP. IT SETS UP
		!QQ TO POINT OT THE GENERATED LABLE ON THE
		!FIRST OF THE MATERIALIZATIONS
		!ON THE OTHERHAND IF WE ALREADY HAVE A SET OF
		!STORES MADE UP, RETSPOT POINTS TO THE LABEL
		!AND WE CAN CHEAPLY MAKE THIS RETURN A GO TO THAT LABEL
		IF .RETSPOT NEQ 0 AND .HEAD[RETEXPR] EQL 0  THEN
		BEGIN
			MAKAGO(HEAD,RETSPOT)
		END ELSE
		BEGIN
			!DO IT ALL NOW
			MAKSTASH();
			!WE MAY HAVE TO WASTE THE GENERATED LABEL IF THE RETURN IS
			!ALREADY LABELED.
			IF .HEAD[SRCLBL] NEQ 0 THEN
			BEGIN
				!WASTE THE GENRATED LABEL AND MOVE THE
				!LABEL FROM HEAD BACK TO THE FIRST OF THE MATERI.
				!THIS IS NOW POINTED TO BY PA[SRCLINK]
				QQ_.HEAD[SRCLBL];
				HEAD[SRCLBL]_0;
				QQ[SNHDR]_.PA[SRCLINK];
				!DONT FORGET TO PUT THE LABEL ON A STATEMENT
				PA_.PA[SRCLINK];
				PA[SRCLBL]_.QQ;
			END;
			IF .HEAD[RETEXPR] EQL 0 THEN RETSPOT_.QQ;
		END;
		!FINAL LINK UP

		PREV[SRCLINK]_.HEAD;
		IF .HEAD NEQ .BOTTOM THEN
		STMT_.HEAD[SRCLINK]
		ELSE
		STMT_.HEAD;
	END;	!WHILE ON STMT
END;	!ROUTINE
ROUTINE MATERIALIZE=

BEGIN
	EXTERNAL EXITLST,EXITNO,GENLAB,DLOOPTREE,MOVLAB;
	EXTERNAL INDVAR,PROGNAME;

	MAP PHAZ2 TOP;

	EXTERNAL CHOSEN,REGTOALC,GLOBREG,SAVSPACE;

	MAP BASE BOTTOM:HEAD:PD;
	MAP PEXPRNODE QQ;
	 MAP PEXPRNODE PREV;
	!MATERIALIZE VARIABLES ASSIGNED TO REGISTERS

	!FOR THE MAIN PROGRAM NOTHING IS NECESSARY AT ALL
	IF .PROGNAME EQL SIXBIT'MAIN. ' AND .DLOOPTREE EQL 0  THEN
		RETURN;
	!IF THIS IS A SUBPROGRAM AND THERE ARE NO LOOPS
	!WE HAVE TO FIND ALL THE RETURNS AND MATERIALIZE BEFORE THEM

	IF .DLOOPTREE EQL 0 THEN
	BEGIN
		STOWONRETURN();
		RETURN;
	END;


	!NOW THE GLOBAL EXITLST CONTAINS THE LIST OF EXITS AND
	!EXITNO CONTAINS THE NUMBER OF EXITS. EXITNO IS ZERO
	!IF ONLY THE NORMAL LOOP FULFILLMENT EXIT EXSISTS.
	!SET UP TWO MODULE OWNS
	PREV_.BOTTOM;
	HEAD_.BOTTOM[SRCLINK];

	!ONE MORE THING TO FIX
	!IF THERE ARE OTHER DO LOOPS WHICH
	!SHARE THEIR TERMINAL STATEMENT WITH THIS ONE
	!MAKE A CONTINUE AND MOVE THEIR TERMINATIONS TO
	!IT, ELSE ALL THE NESTED LOOP ENDING CODE WILL
	!APPEAR BEFORE THE MATERIALIZATIONS.

	FIXUPEND();
	!BOTTOM[SRCLINK] MAY HAVE CHANGED BY LINKING IN THE NEW
	!STATEMENT. TO COMPENSATE FOR THIS BY
	!INITIALIZING HEAD AGAIN

	HEAD_.BOTTOM[SRCLINK];

	!IF WE ARE ONLY DOING THIS FOR THE INDUCTION VARIABLE
	! DONT MATERIALIZE IT
	IF NOT .INDUCONLY THEN
		MAKSTASH();

	!IF THE FULLFILLMENT EXIT IS THE ONLY ONE GET OUT NOW
	IF .EXITNO EQL 0 THEN
	BEGIN
		!CLOSE THE LINKING GAP
		PREV[SRCLINK]_.HEAD;
		RETURN;
	END;

	!NOW THE OTHER (EARLY EXITS) EXITS REMAIN TO BE
	!PROCESSED. AFTER THE MATERIALIZATIONS FROM THE
	!FULLFILLMENT EXIT MAKE A GOTO AROUND THE OTHER
	!MATERIALIZATIONS WE WILL GENERATE.

	!IF THERE ARE MORE EXITS THAN STANDARD THEN
	!	1. MAKE THE STATEMENT AFTER BOTTOM BE A GO TO
	!	   AROUND THE MATERIALIZATIONS
	!	2. CREATE A LABEL FOR THE ATATEMENT AFTER BOTTOM
	!	   IF NECESSARY.

		IF .HEAD[SRCLBL] NEQ 0 THEN
			PD_.HEAD[SRCLBL]
		ELSE
		BEGIN
			PD_GENLAB();
			HEAD[SRCLBL]_.PD;
			PD[SNHDR]_.HEAD;
		END;

		!MAKE THE GO TO
		NAME<LEFT>_GOTOSIZ+SRCSIZ;
		PA_CORMAN();
		PA[OPRCLS]_STATEMENT;
		PA[SRCID]_GOTOID;
		PA[GOTOLBL]_.PD;
		!ADJUST LINKS
		PA[SRCLINK]_.HEAD;
		PREV[SRCLINK]_.PA;
		PREV_.PA;


	!FOR EACH EXIT (IN EXITLST) MAKE A SET OF
	!ASSIGNMENTS AND A GO TO THE EXIT LABEL
	!THATS THE EASY PART

	DECR I FROM .EXITNO TO 1 DO
	BEGIN

		OWN BASE THSEXT;	!PTR TO CURRENT ITEM ON EXITLST
		!MAKSTASH EXPECTS PREV AND P TO BE SET UP.
		!IT ADVANCES BOTH AND SETS UP QQ TO
		!POINT TO THE LABEL TO WHICH THE TRANSFER IS TO
		!BE CHANGED.
		MAKSTASH();

		THSEXT_.EXITLST[.I]<RIGHT>;
		!MAKE THE GO TO STATEMENT NODE
		NAME<LEFT>_GOTOSIZ+SRCSIZ;
		PA_CORMAN();
		PA[OPRCLS]_STATEMENT;
		!DETERMINE IF IT IS AN ASSIGNED GO TO OR A REGULAR ONE
		!NOTE * NEVER * HERE WITH A COMPUTED GO TO
		IF .THSEXT[OPRCLS] EQL LABOP THEN
			PA[SRCID]_GOTOID
		ELSE
			PA[SRCID]_AGOID;
		PA[GOTOLBL]_.THSEXT;
		PREV[SRCLINK]_.PA;
		PA[SRCLINK]_.HEAD;
		PREV_.PA;
		!NOW THE TIME CONSUMING PART.
		!LOOK A THE ORIGINAL BRANCH STATEMENT.
		!CHANGE IT TO BRANCH TO QQ.
		P_.TOP[SRCLINK];
		WHILE .P NEQ .BOTTOM[SRCLINK] DO
		BEGIN
			MATLOK(.P,.I);
			P_.P[SRCLINK];
		END;
	END;			!FOR EACH EXIT
	!THATS ALL!!!!!
END;				!MATERIALIZE

!
!******************************************
!
FORWARD LOCLABLIST;
MACRO LOKIO=
		IF .P[IOEND] NEQ 0 THEN
			LOCLABLIST(.P[IOEND]);
		IF .P[IOERR] NEQ 0 THEN
			LOCLABLIST(.P[IOERR])$;
FORWARD LOKBRANCH;
ROUTINE EXAMBR=

BEGIN
	!EXAMINE ALL STATEMENTS IN THE LOOP FOR THE BRANCH PLACE, IF
	!ANY.

	MAP BASE BOTTOM;
	LOCAL BASE P;

	P_.TOP;
	WHILE .P NEQ .BOTTOM[SRCLINK] DO
	BEGIN
		LOKBRANCH(.P);
		P_.P[SRCLINK];
	END;
END;
ROUTINE LOKBRANCH(P)=
BEGIN

	MAP BASE P;
	EXTERNAL EXITNO;

	IF .P[SRCID] LSS 16  AND .P[SRCID] GEQ 7 THEN
	!THE DISPLACE MENT OF 7 BRINGS US TO THE BEGINNING OF THE
	!BRANCHING STATEMENTS, SKIPPING ASSIGNMENT, CALL, ETC.

	CASE .P[SRCID]-7 OF SET
	!GOTO
	LOCLABLIST(.P[GOTOLBL]);

	!ASSIGNED GOTO
	BEGIN
		IF .P[GOTOLIST] NEQ 0 THEN
		BEGIN
			LOCAL BASE T;
			INCR I FROM 0 TO .P[GOTONUM]-1 DO
			BEGIN
				T_@(.P[GOTOLIST]+.I);
				LOCLABLIST(.T);
			END;
		END;
	END;

	!COMPUTED GOTO
	BEGIN
		LOCAL BASE TLAB;
		INCR I FROM 0 TO .P[GOTONUM]-1 DO
		BEGIN
			TLAB_@(.P[GOTOLIST]+.I);
			LOCLABLIST(.TLAB);
		END;
	END;

	!ARITHMETIC IF
	BEGIN
		LOCLABLIST(.P[AIFLESS]);
		LOCLABLIST(.P[AIFEQL]);
		LOCLABLIST(.P[AIFGTR]);
	END;

	!LOGICAL IF
		LOKBRANCH(.P[LIFSTATE]);

	!RETURN
	BEGIN
		!MATERIALIZATION IS IMPOSSIBLE IF THE RETURN
		!IS THE ONLY EXIT OTHER THAN FULFILLMENT
		!SO JUST FORGET LOOPS WITH RETURNS.
		MINWD_1;
	END;

	!STOP
	BEGIN END;

	!READ
	BEGIN
		LOKIO;
	END;

	!WRITE
	BEGIN
		LOKIO;
	END;

	!NONE FROM HERE DOWN ARE MEANINGFUL
	TES;
END;
ROUTINE LOCLABLIST(LLABL)=
BEGIN
	BIND EXTLSIZ=20;
	EXTERNAL EXITNO,EXITLST;
	DECR I FROM .LLLNO-1 TO 0 DO
		IF .LLL[.I]<RIGHT> EQL .LLABL THEN
		BEGIN
			LLL[.I]<LEFT>_.LLL[.I]<LEFT>+1;
			RETURN;
		END;

		!IF HERE IT IS NOT ON THE LIST

		DECR I FROM .EXITNO TO 0 DO
			IF .EXITLST[.I] EQL .LLABL THEN
				RETURN;

		!ADD IT TO THE LIST

		EXITNO_.EXITNO+1;
		IF .EXITNO GEQ EXTLSIZ THEN
			MINWD_1
		ELSE
			EXITLST[.EXITNO]_.LLABL;
END;
!
ROUTINE MATLOK(PB,K)=
BEGIN
	!PB IS POINTER TO THE STATEMENT
	!K IS THE INDEX INTO EXITLST FOR THE LABEL 
	!THIS ROUTINE LOOKS AT ALL POSSIBLE BRANCHES AND SUBSTITUTES
	!QQ FOR AN LABEL REFERENCE THAT MATCHES EXITLST[K]

EXTERNAL EXITLST;

	!EXTRA LEVEL NEEDED FOR LOGOCAL IF STATEMENT

	!MACROS TO PROCESS I/O STATEMENT END AND ERR LABELS.
	!IT IS A MACRO IN THE HOPE THAT BLISS WILL CROSS JUMP
	!IT FOR US.

	MACRO IOMAT=
	BEGIN
		IF .PB[IOERR] EQL .EXITLST[.K] THEN PB[IOERR]_.QQ;
		IF .PB[IOEND] EQL .EXITLST[.K] THEN PB[IOEND]_.QQ;
	END$;

	MAP BASE PB;
	SELECT .PB[SRCID] OF NSET			!ALL BRANCHING STATEMENTS

GOTOID:	BEGIN						!GO TO

		IF .PB[GOTOLBL] EQL .EXITLST[.K] THEN
			PB[GOTOLBL]_.QQ;
	END;
CGOID:	BEGIN						!COMPUTED GO TO
		LABLLOK(.PB,.EXITLST[.K],.QQ);
							!CESLNK IS RIGHT HALF THROUGH THE
							!STRUCTURE
	END;

AGOID:	BEGIN						!ASSIGNED GO TO
							!OPTIONAL LIST IS PRESENT
	LABLLOK(.PB,.EXITLST[.K],.QQ);
	END;

IFLID:	BEGIN						!LOGICAL IF
		MATLOK(.PB[LIFSTATE],.K);
	END;

IFAID:	BEGIN						!ARITHMETIC IF
		IF .PB[AIFLESS] EQL .EXITLST[.K] THEN
		PB[AIFLESS]_.QQ;
		IF .PB[AIFEQL] EQL .EXITLST[.K] THEN
		PB[AIFEQL]_.QQ;
		IF .PB[AIFGTR] EQL .EXITLST[.K] THEN
		PB[AIFGTR]_.QQ;
	END;
CALLID:	BEGIN						!CALL
							!MAY HAVE LABEL AS PARAMETER
		IF .PB[CALLIST] NEQ 0 THEN
		BEGIN
			LOCAL ARGUMENTLIST ARGL;
			ARGL_.PB[CALLIST];
			INCR J FROM 1 TO .ARGL[ARGCOUNT] DO
			BEGIN
				PA_.ARGL[.J,ARGNPTR];
				IF .PA[OPRCLS] EQL .LABOP THEN
				BEGIN
					IF .PA EQL .EXITLST[.K] THEN
					ARGL[.J,ARGNPTR]_.QQ;
				END;
			END;
		END;
	END;

WRITID:	IOMAT;

READID:	IOMAT;

ENCOID:	IOMAT;

DECOID:	IOMAT;

	TESN;
END;			!MATLOK

!
!

ROUTINE INITEM=
BEGIN
	EXTERNAL GBSYREGS,GBSYCT;

	!REINITIALIZE SOME GLOBALS
	DECR I FROM 31 TO 0 DO
		CHOSEN[.I]_0;
	DECR I FROM 15 TO 0 DO
		GLOBREG[.I]_0;
	GOTEMDBL_0;
	!ALSO SET SOME OWNS
	MINWD_0;
	DECR I FROM 9 TO 0 DO
		MAXCOMPLEX[.I]_0;

	!ALSO INITIALIZE SOME GLOBALS

	GBSYREGS_#777700000000;
	GBSYCT_12;
	REGAVAIL_8;
END;

GLOBAL ROUTINE MRP3G=
BEGIN
	EXTERNAL ALCTEMP,ALCTMPS,ALCCON,HISEGBLK;
	EXTERNAL ALLOCATE,RELINIT;
	EXTERNAL STBSYR,STRGCT,ALCSTMNT,LENTRY;
	EXTERNAL GBSYREGS,GBSYCT;
	EXTERNAL LSTLNK,FTEMP,FRSTLNK;
	EXTERNAL FORMPTR,DMPFORMAT;

	!CONTROL GLOBAL REGISTER ALLOCATIO

	LOCAL BASE P;
	EXTERNAL CSTMNT,CMSTMN,INDVAR,ISN;
	MAP BASE TOP:P:CSTMNT:LENTRY;



	!INITIALIZE THE RELFILE IF ONE WAS REQUESTED

	IF .FLGREG<OBJECT> THEN
		RELINIT();

	!ALLOCATE ARRAYS AND SCALARS, COMMON AND EQUIVALENCE
	ALLOCATE();

	INITEM();
	NAMESET();		!SET INNAM BIT FOR VARIABLES IN NAMELISTS
	FRSTLNK_0;		!VARIABLE FOR LOCAL REGISTER TEMPS
	LSTLNK_0;		!VARIBALE FOR LOCAL REGISTER TEMPS
	!P IS THE CURRENT STATEMENT, LENTRY IS THE ONE PRIOR TO IT
	LENTRY_P_.SORCPTR<LEFT>;
	WHILE .P NEQ 0 DO
	BEGIN

		!CALL COMPLEXITY ROUTINE FOR EACH STATEMENT

		CSTMNT_.P;
		ISN_.CSTMNT[SRCISN];
		CMSTMN();

		IF .P[SRCID] EQL DOID AND
			.P[INNERDOFLG] THEN
			BEGIN
				!POTENTAIL FOR GLOBAL ALLOCATION
					TOP_.P;
					PA_.TOP[DOLBL];
					BOTTOM_.PA[SNHDR];
					!LENTRY WILL POINT TO THE LOOP ENTRY
					!THAT IS THE STATEMENT DIRECTLY 
					!IN FRONT OF TOP SINCE IT TRAILS P BY ONE
					INDVAR_.TOP[DOSYM];
					INITEM();
				!FIRST SEE IF THERE MAY BE AN EXTENDED RANGE
				IF GETLABINFO() THEN
				BEGIN
					AUDITOR();
					P_.BOTTOM;
					INITEM();
				END ELSE
				BEGIN
					!JUST LOCAL ALLOCATION
					IF .DLOOPTREE NEQ 0 THEN
					BEGIN
						!SEE COMMENT BELOW
						STBSYR_.GBSYREGS;
						STRGCT_.GBSYCT;
						FTEMP_.FRSTLNK;
						ALCSTMNT();
					END;
				END;
			END ELSE
			BEGIN
				!ALLOCATE LOCALLY THOSE THAT THE
				!GLOBAL ALLOCATOR WILL NOT LOOK AT
				IF .DLOOPTREE NEQ 0 THEN
				BEGIN
					STBSYR_.GBSYREGS;
					STRGCT_.GBSYCT;
					FTEMP_.FRSTLNK;
					ALCSTMNT();
				END;
			END;
		!UPDATE LENTRY
		LENTRY_.P;
		P_.P[SRCLINK];
	END;

	IF .DLOOPTREE EQL 0 THEN
	BEGIN
		TOP_.SORCPTR<LEFT>;
		BOTTOM_.SORCPTR<RIGHT>;
		LENTRY_.SORCPTR<LEFT>;
		INDVAR_0;
		INITEM();
		AUDITOR();
	END;

	!ALLOCATE TEMPS AND CONSTANTS ETC.

	ALCTEMP();

	IF .FLGREG<OBJECT> THEN
	BEGIN
		ALCTMPS();
		DATPROC();	!PROCESS DATA STATEMENTS BEFORE CONSTANTS
		ALCCON();
		HISEGBLK();	!GENERATE THE HISEG BLOCK IN REL FILE
				!TO TELL LOADER SIZE OF LOSEG
		!DUMP THE FORMAT STATEMENTS INTO THE REL FILE
		!IF THERE ARE SOME
		IF .FORMPTR NEQ 0 THEN DMPFORMAT();
	END;

END;


!****************************************************
	!THIS IS THE MAIN PROGRAM FOR THE GLOBAL
	!REGISTER ALLOCATION OVERLAY
!*******************************************************

	MACHOP POPJ=#263;

	!CALL THE CONTROL ROUTINE MRP3G

	MRP3G();

	!GO BACK TO THE PHASE CONTROL ROUTINE

	POPJ(#17,0)
   0 ~