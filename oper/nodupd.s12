DEF YES AS 1
DEF NO AS 0

! STRUCTURE OF THIS FILE IS
!  WORD 1 - NODE NUMBER
!  WORD 2,3 - NODE NAME IN 7-BIT ASCII (UP TO 9 CHARS AND E.O.LIT)
!  WORD 2 - NODE NUMBER OR -1 WHICH STOPPS IT.
! LASREC POINTS TO THE END OF THE LAST RECORD+1
!  1 -> NO RECORD
!  4 ON UP - > END OF RECORD
GLOBAL NODTAB(1:3*300) ! 300 ENTRIES.

TABLE CMDWRD(1:20) ['QUIT','VERSION','CHARGES','CREDITS',&
'CAPABILITIES','INSTRUCTIONS','ADD NODE','DELETE NODE','LIST NODES',&
'CHANGE NODE',&
'HELP','MODIFY NODE FILE']

LOCAL %INDEX, %STRCOMP, %DOCMD, %OUTNUM, %XCTCMD
LOCAL %NUMBER, %MAKEOPEN, %GETNODE, %FINDNODE, %GETNNODE, %FINDNNODE

FIND %DOCAP, %DOINS

GLOBAL BEGIN:, ESCAPE:
LOCAL IOFILE, CURCMD, LASREC

BEGIN: IOCS(5); ALTLOC_ESCAPE
        MSG('$NODUPD - VERSION 1$')

        CURCMD _ 1

CMD:    LOOP DO
        PUT(CAR.RET); OUTNUM(CURCMD,10); MSG(': ')
        IF DOCMD = YES THEN INC CURCMD
          END

ESCAPE: CLIBUF; CLOBUF; MSG("$$(ESC)$")
        GO CMD



! PROCEDURE: GETNNODE
! ARG:1 IS ADDR TO PUT NODE NUMBER INTO
%GETNNODE(@LOC)

LOCAL TMP.1

        LOOP DO
          MSG('$NODE NUMBER: '); TMP.1 _ GETLINE(TEL)
          LOC _ NUMBER(8,@TMP.1,CAR.RET)
          IF 1<= LOC <= OCT 7777 THEN RETURN YES

          MSG('$NODE NUMBER MUST BE FROM 1 TO 7777 OCT., INCLUSIVE$')

        END

END GETNNODE

! PROCEDURE: FINDNNODE
! ARG:1 IS NODE NUMBER
! @ ARG:2 IS WHERE LOCATOR
! YES IF FIND NODE, NO IF NOT
%FINDNNODE(PTRA,@WHERE)

LOCAL TMP.1

        WHERE _ 1
        IF LASREC = 1 THEN RETURN NO

        FOR TMP.1 _ 1 TO LASREC-3 BY 3 DO

          WHERE _ TMP.1

          IF NODTAB(TMP.1)=PTRA THEN RETURN YES
! PROCEDURE: FINDNODE

          END

        WHERE _ LASREC

        RETURN NO

END FINDNNODE

! ARG:1 IS STR.PTR TO NODE NAME
!@ARG:2 IS SEARCH RETURN ARG
! SEARCHES FOR A NODE
! RETURNS
!   YES - FOUND, ARG:2 IS SET TO LOC IT WAS FOUND AT
!   NO - NOT FOUND, ARG:2 IS LAST LOC SEARCHED
%FINDNODE(PTRA,@WHERE)

LOCAL TMP.1

        WHERE _ 1
        IF LASREC = 1 THEN RETURN NO
        FOR TMP.1 _ 1 TO LASREC-3 BY 3 DO
          WHERE _ TMP.1

          IF STRCOMP(PTRA,CHPT(@NODTAB(TMP.1)+1,-1))=YES THEN &
            RETURN YES
          END
          WHERE _ LASREC
          RETURN NO

END FINDNODE

! PROCEDURE: GETNODE
! GET'S A NODE NAME
! ARG:1 IS PLACE TO PUT NOD PTR
%GETNODE(@PTRA)

LOCAL TMP.1, TMP.2

       LOOP DO

        TMP.2 _ 0 ! INIT COUNT
        MSG('$NODE NAME: ')
        TMP.1 _ PTRA _ GETLINE(TEL)
        WHILE NCHV TMP.1 # CARRET THEN INC TMP.2
        IF (1<= TMP.2 <=9) THEN CHV TMP.1 _ E.O.LIT ELSE&
          MSG('$NODE MUST BE FROM 1 TO 9 CHARS., INCLUSIVE$')
        WHILE NOT (1<= TMP.2 <=9)

       END

        RETURN

END GETNODE

! PROCEDURE: MAKEOPEN
! CALLED TO MAKE SURE FILE OPENED
%MAKEOPEN

LOCAL OPNERR:, GOOPN:, TMP.1, BADIO:

        IF IOFILE # 0 THEN RETURN

GOOPN:  MSG('$NODE FILE NAME: ')
        TMP.1 _ GETLINE(TEL)
        IOFILE _ OPEN(IMAGE,DIRECT+WORD+UPDATE,OPNERR,5)
        PUT(CAR.RET); OUTNUM(SIZE(IOFILE)/3,10)
        MSG(' NODES DEFINED$')
        SETRWE(IOFILE,BADIO)
        IF SIZE(IOFILE)#0 THEN RB(IOFILE, SIZE(IOFILE), @NODTAB(1))
        LASREC _ SIZE(IOFILE) + 1 ! POINTS TO NEXT FREE SLOT IN NODTAB
        RETURN

BADIO:  MSG("$INPUT-OUTPUT ERROR RECEIVED FROM NODE FILE - RB/WB FAILURE$")
        CLOSE(IOFILE<==0)

OPNERR: MSG('$CAN NOT OPEN THAT FILE$')
        GO GOOPN

END MAKEOPEN

! PROCEDURE: NUMBER
! ARG1:=RADIX, ARG2:=STRING TO START EXTRACTING, ARG3:=SPC TERM CH
%NUMBER(ARG1,@ARG2,ARG3)

LOCAL VAL,CHAR,TMP1

        VAL_0
        LOOP DO

          EIF NOT $0<=CHAR_NCHV ARG2<=$0+ARG1 THEN DO
            IF CHAR=CARRET OR CHAR=LNFEED THEN DO
             PCHV ARG2_CHAR; RETURN VAL
             END
            IF CHAR=ARG3 THEN RETURN VAL
             MSG("$ERROR: BAD NUMBER BEFORE "); PUT(CHAR)
             MSG(" CHARACTER--RETYPE PAST THERE--"); ARG2_GETLINE(TEL); VAL_0
        END
        ELSE VAL_VAL*ARG1+(CHAR-$0)
        END

END NUMBER
! PROCEDURE: OUTNUM
! ARG1:NUMBER, ARG2:RADIX
! TYPES NUMBER ONTO TTY
%OUTNUM(ARG1,ARG2)

DEF MAX.DIG AS 11
LOCAL T(MAX.DIG),K,L

        K_ARG1
        LOOP DO
          FOR L_MAX.DIG BY -1
          [K;T(L)]_K DIVMOD ARG2
          WHILE K>0
          END

        FOR L_L TO MAX.DIG PUT(T(L)+$0)
        RETURN

END OUTNUM

%DOCMD

LOCAL TMP1, I, MATCH, PLACE

        MATCH _ PLACE _ 0
        I _ TMP1 _ GETLINE(TEL)
        IF NCHV I = CAR.RET OR CHV I = E.O.LIT THEN RETURN NO


        FOR I _ 1 TO 20 BY 1 DO
          IF CMDWRD(I)#0 AND  INDEX(CHPT(CMDWRD(I),-1),TMP1) = YES THEN DO
            INC MATCH; PLACE _ I
            END
          END
        IF MATCH = 1 THEN RETURN XCTCMD(PLACE)
        IF MATCH = 0 THEN MSG('UNKNOWN COMMAND - ASK FOR HELP$')
        IF MATCH > 1 THEN MSG('AMBIGUOUS COMMAND - TYPE MORE CHARACTERS$')

        RETURN NO

END DOCMD

%STRCOMP(STR1,STR2)

LOCAL TMP.1,TMP.2

        WHILE TMP.1 _ NCHV STR.1 = TMP.2 _ NCHV STR.2 # E.O.LIT THEN NULL
        IF TMP.1 = TMP.2 THEN RETURN YES ELSE RETURN NO

END STRCOMP


! PROCEDURE: INDEX
! INDEX YES IF ARG1: INDEXES ON ARG2: ELSE NO
%INDEX(ARG2,ARG1)

LOCAL A,B

        LOOP DO
          EIF A_NCHV ARG1=E.O.LIT OR A=CARRET THEN RETURN YES
          FIF B_NCHV ARG2=E.O.LIT THEN RETURN NO
          WHILE A=B
        END
        RETURN NO

END INDEX

! PROCEDURE: XCTCMD
! ARG:1 IS CMD NO. FROM CMDWRD
! RETURNS YES TO INC SFE # ELSE RETURNS NO
%XCTCMD(CMDNO)

LOCAL TMP.1, TMP.2, TMP.3
LOCAL I, NODPTR, NODLOC

        DO CMDNO OF 1:20

1:      MSG('$E.O.J.$'); CLOSE.ALL; EXIT; HALT

2:      MSG('VERSION 1$'); RETURN NO

3:      MSG('NO PREMIUM CHARGE$'); RETURN NO

4:      MSG('WRITTEN BY TYMSHARE$'); RETURN NO

5:      DOCAP; RETURN NO

6:      DOINS; RETURN NO

7:      MAKEOPEN; GETNNODE(@NODPTR)
        IF FINDNNODE(NODPTR,@NODLOC) = YES THEN DO
! NODE ALREADY THERE - CAN'T ADD
          MSG('$NODE ALREADY DEFINED AS '); PRINT(@NODTAB(NODLOC+1))
          PUT(CAR.RET)
          RETURN NO
          END
! OKAY TO GO - ADD THE NODE
        NODTAB(LASREC) _ NODPTR; GETNODE(@NODPTR)
! CHECK TO SEE IF ALREADY IN USE
        IF FINDNODE(NODPTR,@NODLOC) THEN DO
! ALREADY THERE
          MSG('$NAME ALREADY ASSIGNED TO NODE NUMBER '); OUTNUM(NODTAB(NODLOC),8)
          PUT(CAR.RET)
          RETURN NO
          END

        NODTAB(LASREC+1) _ NODTAB(LASREC+2) _ 0
        NODLOC _ CHPT(@NODTAB(LASREC+1),-1)
        LOOP WHILE NCHV NODLOC_NCHV NODPTR # E.O.LIT
        NCHV NODLOC _ E.O.LIT
        LASREC + _3; SETCP(IOFILE,0); WB(IOFILE, LASREC-1, @NODTAB(1))
        MSG('$ADDED$'); RETURN YES


8:      MAKEOPEN
        GETNNODE(@NODPTR); IF FINDNNODE(NODPTR,@NODLOC) = NO THEN DO
! NOT FOUND
          MSG('$NODE NOT DEFINED$'); RETURN NO
          END
        MSG('$NODE '); OUTNUM(NODPTR,8); MSG(' NAME ');PRINT(@NODTAB(NODLOC+1))
        MSG('  TYPE CR TO DELETE.')
! ON FAILURE, GIVE UP
        TMP.1 _ GETLINE(TEL); IF NCHV TMP.1 # CAR.RET THEN RETURN NO

! OKAY - DELETE IT..
          ERASE(IOFILE,0,SIZE(IOFILE)); SETCP(IOFILE,0)
          IF NODLOC#1 THEN WB(IOFILE, NODLOC-1, @NODTAB(1))
          IF LASREC#NODLOC THEN WB(IOFILE, LASREC-NODLOC-3, @NODTAB(NODLOC+3))
          LASREC _ SIZE(IOFILE)+1; SETCP(IOFILE,0)
          RB(IOFILE, SIZE(IOFILE), @NODTAB(1))
          MSG('$DELETED$')
          RETURN YES

9:      MAKEOPEN
        IF LASREC = 1 THEN RETURN NO ELSE PUT(CAR.RET)

! MAKE NODPTR= THE MAX NODE NUMBER FOR SORT PURPOSES.
        NODPTR _ 0
        FOR TMP.2 _ 1 TO LASREC - 3 BY 3 NODPTR _ NODPTR MAX NODTAB(TMP.2)

! LOOP SEARCHING
        FOR TMP.1 _ 1 TO NODPTR BY 1 DO
        FOR TMP.2 _ 1 TO LASREC - 3 BY 3 DO
          IF NODTAB(TMP.2)=TMP.1 THEN DO
            IF TMP.1 <= OCT 7777 THEN PUT($ )
            IF TMP.1 <= OCT 777 THEN PUT($ )
            IF TMP.1 <= OCT 77 THEN PUT($ )
            IF TMP.1 <= OCT 7 THEN PUT($ )
            OUTNUM(TMP.1,8); PUT($ ); PRINT(@NODTAB(TMP.2+1))
            PUT(CAR.RET)
            END
          END
        END

        RETURN YES

10:     MAKEOPEN; MSG('$OLD:$'); GETNNODE(@NODPTR)
        IF FINDNNODE(NODPTR,@NODLOC) = NO THEN DO
! NOT THERE
          MSG('$NODE NOT DEFINED$'); RETURN NO
          END
        MSG('$NODE '); OUTNUM(NODPTR,8); MSG(' NAME ')
        PRINT(@NODTAB(NODLOC+1)); MSG('$$NEW:$')
        GETNNODE(@TMP.1)
        IF TMP.1#NODPTR AND FINDNNODE(TMP.1,@TMP.2)=YES THEN DO
! ALREADY THERE
          MSG('$NODE ALREADY DEFINED AS '); PRINT(@NODTAB(TMP.2+1))
          PUT(CAR.RET); RETURN NO
          END
        GETNODE(@I); IF FINDNODE(I,@NODPTR)=YES AND NODPTR#NODLOC THEN DO
!0ALREADY THERE
          MSG('$NAME ALREADY ASSIGNED TO NODE '); OUTNUM(NODTAB(NODPTR),8)
          PUT(CAR.RET)
          RETURN NO
          END
! TMP.1 = THE NEW NODE NUMBER
! I=STR.PTR TO NEW NODE NAME
! NODLOC=PLACE TO PUT THIS DATA
        NODTAB(NODLOC+1) _ NODTAB(NODLOC+2) _ 0
        TMP.3 _ CHPT(@NODTAB(NODLOC+1),-1)
        LOOP WHILE NCHV TMP.3 _ NCHV I # E.O.LIT
        NCHV TMP.3 _ E.O.LIT
        NODTAB(NODLOC) _ TMP.1
        SETCP(IOFILE,0)
        WB(IOFILE, LASREC-1, @NODTAB(1))
        MSG('$CHANGED$')
        RETURN YES

11:     MSG('$VALID COMMANDS ARE:$$')
        FOR I _ 1 TO 20 DO
          IF CMDWRD(I) # 0 THEN [PRINT(CMDWRD(I)); PUT(CARRET)]
          END
        RETURN NO

12:     IF IOFILE # 0 THEN CLOSE(IOFILE<==0)
        MAKEOPEN; RETURN YES

        END

END XCTCMD

        \\->BEGIN
  