!THE STA2 MODULE MUST BE COMPILED IN THE ORDER: ST2HD,FIRST,TABLES,META72,STAMN2
!***COPYRIGHT 1972, DIGITAL EQUIPEMENT CORP., MAYNARD, MASS.***
!AUTHOR: T.E. OSTEN
GLOBAL BIND STA2V=31;	!31-MAY-73
	SWITCHES LIST;
!	EXTERNAL PROGNAME,OUTZ,SCAN;
!THIS FORWARD DECLARATION AND THE FOLLOWING ROUTINES
!WERE PRODUCED BY THE FORTRAN PROGRAM HASHGEN.F4.
!THE NUMBER IN COMMENT'S IS THE STATEMENTS LOCATION
!IN THE HASH TABLE .
FORWARD
% 16%	SUBRSTA,	!SUBROUTINE - P.35
% 17%	SUBSSTA,	!SUBSCRIPTINTEGER - P.27
% 19%	INTESTA,	!INTEGER - P.28
% 29%	LOGISTA,	!LOGICAL - P.30
% 51%	DIMESTA,	!DIMENSION - P.39
% 56%	DOUBSTA,	!DOUBLEPRECISION - P.31
% 64%	ENTRSTA,	!ENTRY - P.36
% 75%	BLOCSTA,	!BLOCKDATA - P.38
% 81%	FUNCSTA,	!FUNCTION - P.34
% 86%	REALSTA,	!REAL - P.29
% 93%	COMMSTA,	!COMMON - P.40
% 96%	COMPSTA,	!COMPLEX - P.32
%119%	BYTESTA,	!BYTE - P.33
%121%	PROGSTA;	!PROGRAM - P.37
ROUTINE  ASTER=	!SCAN FOR *DIGIT CONSTRUCTION AND RETURN DIGIT IF FOUND
BEGIN
	MACRO ERR50 = ( ERROUT(E50))$;
	IF SIGCHAR EQL "*"
	THEN (SIGCHAR; IF DIGIT(C) THEN RETURN .C ELSE RETURN ERR50)
	ELSE (QUEUE(); RETURN 0)
END;
GLOBAL ROUTINE TYPDECLARE(DGIT)=	!CALLED BY INTESTA,REALSTA,DOUBST
				!COMPST,BYTEST,LOGIST STATATEMENT ROUTINES
				!TO HANDLE THE CHECKING
				!THE DIFFERENCE BETWEEN A FUNCTIONDECLARATION AND A IMPLE TYPE DECLARATION
BEGIN
	MACRO ERR50=( ERROUT(50))$;
	EXTERNAL FUNCGEN,TYPEGEN,SAVSPACE,TYPE,STK;
	MAP BASE T1:T2;
	MACRO ELMNT=0,0,FULL$, ELMNT1=0,1,FULL$, ELMNT2=0,2,FULL$;
	TYPE _ 4;
	T1_ .STK[0];
	IF .DGIT NEQ 0
	  THEN	!*N CONSTRUCTION
		(IF (.IDTYPE EQL REAL) AND (.DGIT EQL "8")
			THEN IDTYPE _ DOUBLPREC
			ELSE IF .DGIT NEQ "4" THEN ERR50;
		);
	 IF .T1[ELMNT] EQL 1
		THEN FUNCGEN(@.T1[ELMNT1])
		ELSE TYPEGEN(.T1[ELMNT1]);
	SAVSPACE(.STK[0]<LEFT>,.STK[0])
END;	!OF TYPDECLARE
GLOBAL ROUTINE SUBSSTA=
BEGIN
	BIND SUBSPLIT= PLIT'SUBSCRIPTINTEGER';
	EXTERNAL STK,TYPEGEN %()%, FUNCGEN %()%,SAVSPACE %(SIZE,LOC)%,TYPE;
	MAP BASE T1;
	MACRO ELMNT=0,0,FULL$;
        IF SCAN(PLIT'CRIPTINTEGER') LSS 0 THEN (ENTRY[1]_SUBSPLIT;ERROUT(E12));
	IDTYPE_INDEX;
        IF SYNTAX(SUBSCRIPTINTEGER) LSS 0 THEN RETURN -1;
!SEMANTIC ANALYSIS BEGINS
	TYPDECLARE(0);	!CHECK FOR FUNCTION OR TYPE DECLARATION
	.VREG
END;
GLOBAL ROUTINE INTESTA=
BEGIN
	EXTERNAL STK,TYPEGEN %()%, FUNCGEN %()%,SAVSPACE %(SIZE,LOC)%,TYPE;
	LOCAL BASE IDIG;
	MACRO ELMNT=0,0,FULL$;
	BIND INTEPLIT= PLIT'INTEGER';
        IF SCAN(PLIT'GER') LSS 0 THEN (ENTRY[1]_INTEPLIT;ERROUT(E12));
	IDTYPE_INTEGER;
	IF (IDIG_ASTER()) LSS 0 THEN RETURN .VREG;
        IF SYNTAX(INTEGERSPEC) LSS 0 THEN RETURN -1;
!SEMANTIC ANALYSIS BEGINS
	TYPDECLARE(.IDIG);	!CHECK FOR FUNCTION OR TYPE DECLARATION
	.VREG
END;
GLOBAL ROUTINE REALSTA=
BEGIN
	EXTERNAL STK,TYPEGEN %()%, FUNCGEN %()%,SAVSPACE %(SIZE,LOC)%,TYPE;
	LOCAL BASE IDIG;
	MACRO ELMNT=0,0,FULL$;
	BIND REALPLIT= PLIT'REAL';
	IDTYPE_REAL;
	IF (IDIG_ASTER()) LSS 0 THEN RETURN .VREG;
        IF SYNTAX(REALSPEC) LSS 0 THEN RETURN -1;
!SEMANTIC ANALYSIS BEGINS
	TYPDECLARE(.IDIG);	!CHECK FOR FUNCTION OR TYPE DECLARATION
	.VREG
END;
GLOBAL ROUTINE LOGISTA=
BEGIN
	EXTERNAL STK,TYPEGEN %()%, FUNCGEN %()%,SAVSPACE %(SIZE,LOC)%,TYPE;
	LOCAL BASE IDIG;
	MACRO ELMNT=0,0,FULL$;
	BIND LOGIPLIT= PLIT'LOGICAL';
        IF SCAN(PLIT'CAL') LSS 0 THEN (ENTRY[1]_LOGIPLIT;ERROUT(E12));
	IDTYPE_LOGICAL;
	IF (IDIG_ASTER()) LSS 0 THEN RETURN .VREG;
        IF SYNTAX(LOGICALSPEC) LSS 0 THEN RETURN -1;
!SEMANTIC ANALYSIS BEGINS
	TYPDECLARE(.IDIG);	!CHECK FOR FUNCTION OR TYPE DECLARATION
	.VREG
END;
GLOBAL ROUTINE DOUBSTA=
BEGIN
	EXTERNAL STK,TYPEGEN %()%, FUNCGEN %()%,SAVSPACE %(SIZE,LOC)%,TYPE;
	LOCAL BASE IDIG;
	MACRO ELMNT=0,0,FULL$;
	BIND DOUBPLIT= PLIT'DOUBLEPRECISION';
        IF SCAN(PLIT'LEPRECISION') LSS 0 THEN (ENTRY[1]_DOUBPLIT;ERROUT(E12));
	IDTYPE_DOUBLPREC;
	IF (IDIG_ASTER()) LSS 0 THEN RETURN .VREG;
        IF SYNTAX(DOUBLEPRECISION) LSS 0 THEN RETURN -1;
!SEMANTIC ANALYSIS BEGINS
	TYPDECLARE(.IDIG);	!CHECK FOR FUNCTION OR TYPE DECLARATION
	.VREG
END;
GLOBAL ROUTINE COMPSTA=
BEGIN
	EXTERNAL STK,TYPEGEN %()%, FUNCGEN %()%,SAVSPACE %(SIZE,LOC)%,TYPE;
	LOCAL BASE IDIG;
	MACRO ELMNT=0,0,FULL$;
	BIND COMPPLIT= PLIT'COMPLEX';
        IF SCAN(PLIT'LEX') LSS 0 THEN (ENTRY[1]_COMPPLIT;ERROUT(E12));
	IDTYPE_COMPLEX;
	IF (IDIG_ASTER()) LSS 0 THEN RETURN .VREG;
        IF SYNTAX(COMPLEXSPEC) LSS 0 THEN RETURN -1;
!SEMANTIC ANALYSIS BEGINS
	TYPDECLARE(.IDIG);	!CHECK FOR FUNCTION OR TYPE DECLARATION
	.VREG

END;
GLOBAL ROUTINE BYTESTA=
BEGIN
	EXTERNAL STK,TYPEGEN %()%, FUNCGEN %()%,SAVSPACE %(SIZE,LOC)%,TYPE;
	LOCAL BASE IDIG;
	MACRO ELMNT=0,0,FULL$;
	BIND BYTEPLIT= PLIT'BYTE';
	ENTRY[1] _ BYTEPLIT; RETURN ERROUT(73); !NOT SUPPORTED YET
	IDTYPE_7^5+BYTE;
	IF (IDIG_ASTER()) LSS 0 THEN RETURN .VREG;
        IF SYNTAX(BYTESPEC) LSS 0 THEN RETURN -1;
!SEMANTIC ANALYSIS BEGINS
	TYPDECLARE(.IDIG);	!CHECK FOR FUNCTION OR TYPE DECLARATION
	.VREG
END;
GLOBAL ROUTINE FUNCSTA=
BEGIN
	EXTERNAL STK,FUNCGEN %()%,SAVSPACE %(SIZE,LOC)%,TYPE;
	MAP BASE T1;
	MACRO ELMNT=0,0,FULL$;
	BIND FUNCPLIT= PLIT'FUNCTION';
	IF NOT FIRSTSTATEMENT() THEN RETURN ERROUT(92);	!MISSING END STATEMENT
        IF SCAN(PLIT'TION') LSS 0 THEN (ENTRY[1]_FUNCPLIT;ERROUT(E12));
	IF SYNTAX(ENTRYSPEC) LSS 0 THEN RETURN -1;
!SEMANTIC ANALYSIS BEGINS
	T1_.STK[0];IDTYPE_-1;TYPE_4;
	FUNCGEN(.T1[ELMNT]);SAVSPACE(0,@STK[0]);
	.VREG
END;
GLOBAL ROUTINE SUBRSTA=
BEGIN
	EXTERNAL STK,FUNCGEN %()%,SAVSPACE %(SIZE,LOC)%,TYPE;
	MAP BASE T1;
	MACRO ELMNT=0,0,FULL$;
	BIND SUBRPLIT= PLIT'SUBROUTINE';
	IF NOT FIRSTSTATEMENT() THEN RETURN ERROUT(92);	!MISSING END STATEMENT
        IF SCAN(PLIT'OUTINE') LSS 0 THEN (ENTRY[1]_SUBRPLIT;ERROUT(E12));
        IF SYNTAX(SUBROUTINE) LSS 0 THEN RETURN -1;
!SEMANTIC ANALYSIS BEGINS
	T1_.STK[0];IDTYPE_-1;TYPE_0;
	FUNCGEN(.T1[ELMNT]);SAVSPACE(0,@STK[0]);
	.VREG
END;
GLOBAL ROUTINE ENTRSTA=
BEGIN
	EXTERNAL STK,FUNCGEN %()%,SAVSPACE %(SIZE,LOC)%,TYPE,LASDOLABEL ;
	MAP BASE T1;
	MACRO ELMNT=0,0,FULL$;
	BIND ENTRPLIT= PLIT'ENTRY';
        IF SCAN(PLIT'Y') LSS 0 THEN (ENTRY[1]_ENTRPLIT;ERROUT(E12));
	IF .LASDOLABEL NEQ 0 THEN ERROUT(75); !ENTRY ILLEGAL INSIDE A DO LOOP
        IF SYNTAX(ENTRYSPEC) LSS 0 THEN RETURN -1;
!SEMANTIC ANALYSIS BEGINS
	T1_.STK[0];IDTYPE_-1;TYPE_1;
	FUNCGEN(.T1[ELMNT]);SAVSPACE(0,@STK[0]);
	.VREG
END;
GLOBAL ROUTINE PROGSTA=
BEGIN
	BIND PROGPLIT= PLIT'PROGRAM';
	MACRO ERR0(X)=( ENTRY[2]_X)$;
	MACRO ERR12=(ENTRY[1]_PROGPLIT;ERROUT(E12))$;
	EXTERNAL NEWCARD,FIRSTSTATEMENT,PROGNAME;
	MACHOP MOVEI=#201,ROTC=#245,ROT=#241;
        IF SCAN(PLIT'RAM') LSS 0 THEN ERR12;
	LEXL_LEXEMEGEN();
	IF .LEXL<LEFT> EQL IDENT
	  THEN(LOCAL BASE PR1;
		PR1_ .LEXL<RIGHT>;
		PROGNAME_.PR1[IDSYMBOL];
		LEXL_LEXEMEGEN();
		);
	IF .LEXL<LEFT> NEQ LINEND THEN ERR0(PLIT'LINEND');
	.VREG
END;
GLOBAL ROUTINE BLOCSTA=
BEGIN
	EXTERNAL PROGNAME,STK;
	BIND BLOCPLIT= PLIT'BLOCKDATA';
	MACRO ELMNT=0,0,FULL$, ELMNT1=0,1,FULL$;
	MACRO ERR0(X)=( ENTRY[2]_X)$;
	MACRO ERR12=(ENTRY[1]_BLOCPLIT;ERROUT(E12))$;
	EXTERNAL NEWCARD,FIRSTSTATEMENT;
	MAP BASE T1;
        IF SCAN(PLIT'KDATA') LSS 0 THEN (ENTRY[1]_BLOCPLIT;ERROUT(E12));
	IF NOT FIRSTSTATEMENT() THEN RETURN ERROUT(92);
	LEXL_LEXEMEGEN();
	IF .LEXL<LEFT> EQL IDENT
	  THEN(LOCAL BASE PR1;
		PR1_ .LEXL<RIGHT>;
		PROGNAME_.PR1[IDSYMBOL];
		LEXL_LEXEMEGEN();
		)
	  ELSE PROGNAME _ SIXBIT'.BLOCK';
	FLGREG<BLKDATA> _ 1;
	IF .LEXL<LEFT> NEQ LINEND THEN ERR0(PLIT'LINEND');
	.VREG
END;
GLOBAL ROUTINE DIMESTA=
BEGIN
	EXTERNAL STK,BLDARRAY %(LIST OF ONEARRAY'S)%,SAVSPACE %(SIZE,LOC)%,TYPE;
	MAP BASE T1;
	BIND DIMEPLIT= PLIT'DIMENSION';
	MACRO ELMNT=0,0,FULL$;
        IF SCAN(PLIT'NSION') LSS 0 THEN (ENTRY[1]_DIMEPLIT;ERROUT(E12));
        IF SYNTAX(DIMENSION) LSS 0 THEN RETURN -1;
!SEMANTIC ANALYSIS BEGINS
	IDTYPE_-1;TYPE_0;T1_@STK[0];BLDARRAY(.T1[ELMNT]);
	SAVSPACE(0,@STK[0]);
	.VREG
END;
GLOBAL ROUTINE COMMSTA=
BEGIN
	EXTERNAL STK,BLDARRAY %(ONEARRAY LIST)%,SAVSPACE %(SIZE,LOC)%,TYPE,IDTYPE,BLKSRCH %(NAME)%;
	MAP BASE T1:T2; REGISTER BASE R1:R2;
	MACRO
	ELMNT=0,0,FULL$,ELMNT1=0,1,FULL$,ELMNT2=0,2,FULL$;
	BIND COMMPLIT= PLIT'COMMON';
        IF SCAN(PLIT'ON') LSS 0 THEN (ENTRY[1]_COMMPLIT;ERROUT(E12));
        IF SYNTAX(COMMON) LSS 0 THEN RETURN -1;
!SEMANTIC ANALYSIS BEGINS
!-----------------------------------------------------------------------------------
!THE FIRST LOCATION OF THE LEXEME STACK (STK[0])
!POINTS TO THE LIST OF COMMON GROUPS TO BE SCANNED.
!-----------------------------------------------------------------------------------
	R1_.STK[0];STK[1]_.R1[ELMNT];SAVSPACE(0,@R1);
	INCR CLST FROM @STK[1] TO @STK[1]+.STK[1]<LEFT> DO
	BEGIN
		MAP BASE CLST; R1_.CLST[ELMNT];
		IF .R1[ELMNT] EQL 0 THEN ! BLANK COMMON
		BEGIN
			R2_BLKSRCH(SIXBIT '.COMM.');
		END
		ELSE !SLASHS SEEN GET BLOCK NAME IF THERE
		BEGIN
			T1_.R1[ELMNT1];
			IF .T1[ELMNT1] EQL 0 THEN R2_BLKSRCH(SIXBIT '.COMM.')
			ELSE
			BEGIN
				T2_.T1[ELMNT2];SAVSPACE(.T1<LEFT>,@T1);
				IF .T2[IDSYMBOL] EQL .PROGNAME THEN
				  (ENTRY[1]_T2[IDSYMBOL]; RETURN ERROUT(65)); !ERROR NAME SAME AS SUBROUTINE OR FUNCTION
				T2[IDATTRIBUT(COMBL)] _ 1; !SET COMMONBLOCK NAME BIT
				R2_BLKSRCH(.T2[IDSYMBOL]);
			END;
			R1_.R1+1; !INCR PTR IF SLASHES FOR CALL TO BLDARRAY COMING UP
		END;
		IDTYPE_-1;TYPE_5;STK[2]<LEFT>_.R2[COMFIRST];
		STK[2]<RIGHT>_.R2[COMLAST];BLDARRAY(.R1[ELMNT1]);
		!---------------------------------------------------------------------------
		!STK[2] CONTAINS THE INFORMATION REQUIRED BY BLDARRAY TO
		!LINK ELEMENTS OF THE COMMON BLOCK.  IT IS UPDATED BY
		!BLDARRAY TO CONTAIN LINKS TO THE FIRST AND LAST ELEMENT IN
		!THE BLOCK.
		!--------------------------------------------------------------------------
		R2[COMFIRST]_.STK[2]<LEFT>;R2[COMLAST]_.STK[2]<RIGHT>;
		R1 _ .R2[COMFIRST]; !FIRST ITEM IN BLOCK
				DO
				   R1[IDCOMMON] _ .R2  !PUTTING PTR TO BLOCK IN EACH ITEM
				  WHILE (R1 _ .R1[IDCOLINK]) NEQ 0;
	END;T1_.STK[1];SAVSPACE(.T1<LEFT>,@T1);
	.VREG
END;
    