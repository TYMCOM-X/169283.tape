TITLE COPY	V004	30-JAN-69
;COPYRIGHT 1968, DIGITAL EQUIPMENT CORP., MAYNARD, MASS.
REPEAT 0,<


	COPY WILL RUN IN ANY AMOUNT OF CORE, HOWEVER, EFFICIENCY 
INCREASES WITH CORE SIZE.  SWITCHES ARE PRECEDED BY A SLASH OR
ENCLOSED IN PARENTHESES AND MAY APPEAR ANYWHERE IN THE COMMAND
STRING.  THE GENERAL COMMAND STRING FORMAT IS:
	(OUTPUT DECTAPE):_(INPUT DECTAPE):/C

	/C	COPY ALL BLOCKS FROM THE INPUT DECTAPE ONTO
		THE OUTPUT DECTAPE.
	/Z	ZERO ALL BLOCKS OF THE OUTPUT DECTAPE, CLEAR
		THE DIRECTORY.
	/V	PERFORM A WORD BY WORD COMPARISION BETWEEN
		EVERY WORD OF THE INPUT AND OUTPUT DECTAPES.
	/T	CAUSES ONE OF THE FOLLOWING MESSAGES TO BE TYPED:
		1. "TENDUMP IS NOT IN CORE."	RESTART COPY.
		IF IN CORE:
		2. "32K TENDUMP?..."	IF THE ANSWER IS:
		   "Y"=YES, WRITE 32K TENDUMP INTO BLOCKS 0 AND 1.
		   "N"=NO, CONTINUE COMMAND PROCESSING.
		   "OTHER", REASK THE QUESTION.
		3. "16K TENDUMP?..."	IF ANSWER IS:
		   "Y"=YES, WRITE 16K TENDUMP INTO BLOCKS 0 AND 1.
		   "N"=NO, CONTINUE COMMAND PROCESSING.
		   "OTHER", REASK THE QUESTION.
	/6	LOOK FOR A DIRECTORY IN BLOCK ONE, NOT BLOCK 144.
	/G	DON'T RESTART THE PROGRAM AFTER A PARITY ERROR
		(BIT20), OUTPUT AN ERROR MESSAGE AND CONTINUE.
    NO SW'S	SET C AND V SWITCHES (DEFAULT CONDITION).

    NOTE........AT COMPLETION THE OUTPUT DECTAPE SHOULD BE REASSIGNED
		TO ENSURE THAT THE DIRECTORY IN CORE IS UP TO DATE.



	THE FOLLOWING MESSAGES MAY BE OUTPUT TO THE USER'S TELETYPE.

	WRITE LOCK ERROR
	INPUT (OR OUTPUT) DEVICE ERROR
	INPUT (OR OUTPUT) CHECKSUM OR PARITY ERROR
	INPUT (OR OUTPUT) BLOCK TOO LARGE
	INPUT (OR OUTPUT) PREMATURE END OF FILE
	000000 VERIFICATION ERRORS
	COMMAND ERROR
	SWITCH ERROR
	DEVICE INIT FAILURE
	DEVICE MUST BE A DECTAPE
	TENDUMP IS NOT IN CORE
	32K TENDUMP?...
	16K TENDUMP?...



TO LOAD TENDUMP:



	1. RUN OR GET AND START COPY.
	2. IMMEDIATELY AFTER THE FIRST ASTERISK, TYPE ^C, REENTER.
	3. COPY IS NOW WAITING FOR TWO "RIM10" FILES FROM THE PAPER
	   TAPE READER. THE FIRST IS ASSUMED TO BE 32K TENDUMP,THE SECOND
	   16K TENDUMP. EACH FILE MUST BE LESS THAN 400 WORDS LONG AND
	   EITHER MAY BE A NULL FILE (EOF AND NO DATA).
	4. AFTER THE SECOND FILE HAS BEEN READ IN, COPY WILL TYPE
	   THE FOLLOWING MESSAGE AND EXIT.
	   "FILES JUST LOADED:"
	   "32K TENDUMP" AND/OR
	   "16K TENDUMP" OR
	   "NONE"
	5. THIS CORE IMAGE WITH TENDUMP LOADED MAY NOW BE SAVED IN
	   2K OF CORE. THE "LOAD TENDUMP" CODE IS OVERWRITTEN AND USED 
	   AS BUFFER SPACE.


THE FOLLOWING MESSAGES MAY BE OUTPUT TO THE USER'S TELETYPE:

	PTR INIT FAILURE
	PTR DATA ERROR
	FILE TOO LARGE (GT 400 WORDS)
	FILES JUST LOADED
	32K TENDUMP
	16K TENDUMP
	NONE
>

FLP=400000		;NOT SW MODE			**FLAGS ARE IN LH OF F**
FLC=200000		;COPY
FLZ=100000		;ZERO
FLV= 40000		;VERIFY
FLT= 20000		;TENDMP
FLG= 10000		;IGNORE PARITY ERRORS
FLL=  4000		;LIST DIR
FLK=  2000		;COLON
FLA=  1000		;LEFT ARROW
FLI=   400		;INPUT DEVICE
FL2=   200		;CHANEL TWO
K32=   100		;REQ FOR 32K TEN-DUMP
K16=    40		;REQ FOR 16K TEN-DUMP
L32=    20		;32K 10DMP IS LOADED
L16=    10		;16K 10DMP IS LOADED
LST=     4		;NULL FILE
FL6=     2		;6 FORMATTED
FPT=     1		;A PDP-10
ANYSW=FLC+FLZ+FLV+FLT	;ANYSW=0 IMPLIES FLC+FLV
JOBVER=137

V1=1	;VERIFY CMDLST
VZ1=2	;CMDLST TERMINATOR
V2=3	;VERIFY CMDLST
VZ2=4	;CMDLST TERM
BP=5	;BYTE POINTER
C=6	;CURRENT CHARACTER
LOC=7	;BLOCK NUMBER
T=10	;TEMP
U=T+1	;TEMP
F=12	;FLAGS
UNSD2=14	;UNUSED
UNSD3=15	;UNUSED
IOS=16	;IO STATUS
P=17	;PUSH DOWN LIST
	EXTERN	JOBFF,JOBREL,JOBSA
	LOC	JOBVER
	XWD	004	;;VERSION #
	RELOC
	JOBREN=124
	LOC JOBREN
	DATA
	RELOC

ST:	CALLI	0
	MOVE	P,[IOWD 10,TTYIN+23]	;PUSH DOWN LIST
	MOVE	0,ZROWRD		;= 32KDMP
	TLNN	F,L32+L16		;USE TENDMP BUFFERS
	MOVEM	0,JOBFF			;IF POSSIBLE
	INIT	17,1			;ASCII LINE
	SIXBIT	/TTY/
	XWD	TOUT,TIN
	HALT	.			;INIT ERROR
	PUSH	P,JOBFF
	MOVEI	T,TTYIN
	MOVEM	T,JOBFF
	INBUF	17,1			;SET THE BUFFER ADR TO TTYIN
	MOVEI	T,TTYOUT
	MOVEM	T,JOBFF
	OUTBUF	17,1			;SET THE BUFFER ADR TO TTYOUT
	OUTPUT	17,			;DUMMY
	SETZB	F,IDEV
	SETZB	T,ODEV

	POP	P,JOBFF
	MOVE	T,JOBREL
	SUB	T,JOBFF			;T=NO. OF FREE LOC
	CAIGE	T,400			;CHECK FOR INFINITE LOOP
	TRO	T,400			;CAUSE ADR CHECK
	MOVE	C,JOBFF		;
	SUBI	C,1		;IOWD FORMAT "ADR-1"
	ANDI	T,-200		;T=NO. OF FREE WORDS
	MOVNM	T,U		;IOWD FORMAT "-N"
	LSH	T,-7		;T=NO. OF BLOCKS PER COPY INPUT
	MOVEM	T,INC		;COPY INCREMENT
	LSH	T,-1		;T=NO. OF BLOCKS PER VERIFY INPUT
	MOVEM	T,INCV		;VERIFY INCREMENT
	HRLM	U,C		;ASSEMBLE
	MOVEM	C,LISTC		;COPY IOWD
	ASH	U,-1		;HALVE THE "-N" FOR VERIFY
	TRNE	U,100		;"-N" MUST AGREE WITH THE INCREMENT
	ADDI	U,100		;ADJUST
	HRL	C,U		;ASSEMBLE
	MOVEM	C,LISTV1	;VERIFY IOWD #1
	MOVMM	U,U		;
	ADD	C,U		;ASSEMBLE
	MOVEM	C,LISTV2	;VERIFY IOWD #2

	MOVEI	C,"*"
	PUSHJ	P,TYPC			;OUTPUT CHAR
	INPUT	17,
	SETZM	JOBREN			;TOO LATE NOW
	MOVE	F,FSAVE			;INITIAL FLAGS
	SKIPA	BP,[POINT 6,ODEV]	;ASSUME AN OUTPUT DEV
COIDEV:	MOVE	BP,[POINT 6,IDEV]	;INPUT IF LEFT-ARROW + COLON WERE SEEN	
COTGET:	PUSHJ	P,TYPGET		;RETURN A CHAR TO C
	CAIN	C,"/"
	JRST	COSLSH			;SLASH
	CAIN	C,"("
	JRST	COLPRN			;LEFT PAREN
	CAIN	C,":"
	JRST	COCOLN			;COLON
	CAIE	C,12
	CAIN	C,15
	JRST	COCRET			;CR OR LF
	CAIN	C,"_"
	JRST	COLARO			;LEFT ARROW
	CAIGE	C,"0"			;
	JRST	ERRCMD			;
	CAILE	C,"9"			;ILLEGAL CHAR?
	CAIL	C,"A"			;
	CAILE	C,"Z"			;
	JRST	ERRCMD			;
	SUBI	C,40			;6 BITIZE IT
	TLNE	BP,770000		;ACCEPY 6 CHARS ONLY
	IDPB	C,BP			;ASSEMBLE AN I/O DEV NAME
	JRST	COTGET			;

COLPRN:	TLZA	F,FLP			;ENTER PAREN MODE
COEXIT:	JUMPL	F,COTGET		;NORMAL EXIT
COSLSH:	PUSHJ	P,TYPGET		;SLASH - RETURN SW IN C
	MOVSI	U,-LEN			;U=-SWTAB LEN,0
COSWLP:	MOVE	T,SWTAB(U)		;T=FLAG,CHAR
	CAIN	C,(T)			;C=0,CHAR
	TDOA	F,T			;F=FLAGS,CHARS ANDED
	AOBJN	U,COSWLP		;MORE SW'S? LOOP
	JUMPL	U,COEXIT		;MATCH OR MORE SW? LOOP
	JRST	ERRSW			;NOT A SWITCH

COLARO:	TLZE	F,FLK			;CLEAR COLON FLAG
	TLOE	F,FLA			;SET LEFT ARROW FLAG
	JRST	ERRCMD			;TOO MANY ARROWS,NOT ENOUGH KOLONS
	JRST	COIDEV			;NEXT DEVICE MUST BE INPUT

COCOLN:	TLZ	BP,770000		;ACCEPT NO MORE CHARS.
	TLON	F,FLK			;SET KOLON FLAG
	JUMPGE	BP,COTGET		;NORMAL EXIT
	JRST	ERRCMD			;NULL NAME, TOO MANY COLONS

COCRET:	TLNE	F,FLA			;LEFT ARO ?
	JRST	COSTRT			;_,SO OK
	SKIPE	ODEV			;
	JRST	ERRCMD			;NO_,SOME ODEV
	TLNE	F,ANYSW			;
	JRST	ERRCMD			;NO_,NO ODEV, SOME SW
	JRST	ST			;NO_,NO ODEV,NO SW =*
COSTRT:	TLNN	F,ANYSW		;ANY SW=SKIP
	TLO	F,FLC+FLV	;DEFAULT=COPY+VERIFY
	TLNE	F,FLC		;IF COPY
	TLZ	F,FLZ		;DONT ZERO
	TLNE	F,FLZ		;IF ZERO
	TLZ	F,FLV		;DONT VERIFY
	SKIPN	T,IDEV
	TLNE	F,FLC+FLV
	JUMPE	T,ERRCMD	;AN INDEVICE IS REQUIRED
	TLNN	F,FLT		;IS 10DMP WANTED?
	JRST	CINIT		;NO, PROCEED

CTENDM:	TLNN	F,L32+L16	;IS 10DMP IN CORE
	JRST	ERRTNH		;NO, INFORM THE USER
	TLNN	F,L32		;IS 32K 10DMP IN CORE?
	JRST	ASK16K		;NO, TRY 16K
	MOVEI	BP,MES32K	;YES, ASK HIM IF 'E WANTS IT
	PUSHJ	P,TYPEIT	;MES32K-
	PUSHJ	P,TYPBUF	;TYPE THE BUFFER
	INPUT	17,		;WAIT FOR ANSWER
	PUSHJ	P,TYPGET	;GOT IT, WHAT IS IT?
	CAIN	C,"Y"		;YES?
	JRST	K32YES		;YES!
	CAIE	C,"N"		;NO?
	JRST	CTENDM		;NOT NO,NOT YES,ASK AGAIN!
ASK16K:	MOVEI	BP,MES16K	;HE DOESN'T WANT 32K OR IT'S NOT HERE
	PUSHJ	P,TYPEIT	;16K??
	PUSHJ	P,TYPBUF	;TYPE
	INPUT	17,		;WAIT
	PUSHJ	P,TYPGET	;ANS. IS...
	CAIN	C,"N"		;NO?
	JRST	CINIT		;NOT 16K + NOT 32K? PROCEED!!
	CAIE	C,"Y"		;YES?
	JRST	ASK16K		;NO NO, NO YES, TRY AGAIN
	TLOA	F,K16		;REQ 16K 10DMP
K32YES:	TLO	F,K32		;REQ 32K
CINIT:	MOVEI	T,134		;BUFRD MODE
	PUSHJ	P,INIT		;FIRST INIT
	TLNE	F,FLC!FLZ	;BEGIN HERE  ___******
	PUSHJ	P,COPZRO	;ZERO OR COPY
	TLNE	F,FLC!FLZ	;IF C OR Z-
	PUSHJ	P,LALA			;THEN REWIND
	TLNN	F,FLZ		;WASIT /Z ?
	JRST	CNOZRO		;NO
	SETSTS	2,16		;YES
	CALLI	2,13		;CLEAR DIR IN CORE
	RELEAS	2,		;AND ON TAPE
	MOVEI	T,14		;AND
	PUSHJ	P,INIT		;REINIT
CNOZRO:	TLNE	F,FLV		;VERIFY ?
	PUSHJ	P,VERZRO	;YES
	TLNE	F,FLV		;IF VERIFY-
	PUSHJ	P,LALA	;THEN REWIND
	TLNE	F,FLT		;TEN DUMP ?
	PUSHJ	P,TENINT	;YES
	JRST	ST		;GO AGAIN ******
LALA:	MTAPE	2,1		;
	SKIPE	C,IDEV		;
	MTAPE	1,1		;
	JFCL	1,.+1		;PROCESSOR TEST
	JRST	.+1		;
	JFCL	1,.+3		;6-JUMP
	TLO	F,FPT		;PDP-10 FLAG
	JRST	LSTEST		;10-JUMP
	JUMPE	C,LSTES0	;JUMP IF NO INPUT DEV
	USETI	1,1
	INPUT	1,REWIND	;IOWD 1,DATA
LSTES0:	USETI	2,1
	INPUT	2,REWIND
LSTEST:	TLZE	F,FLL		;LIST A DIR?
	JRST	DLST		;YES
	MOVEI	C,^D30		;SECONDS
GDNITE:	TLNE	F,FPT		;6-SKIP
	CALLI	C,31		;TO SLEEP
	POPJ	P,		;

SWTAB:	XWD	FLP,")"		;XIT
	XWD	FLC,"C"		;COPY
	XWD	FLZ,"Z"		;ZERO
	XWD	FLV,"V"		;VERIFY
	XWD	FLT,"T"		;TENDMP
	XWD	FLG,"G"		;IGNORE
	XWD	FL6,"6"		;PDP6 DIR
	LEN=.-SWTAB
DSAV:	TLON	F,FLL		;ENTER THIS CODE ONCE ONLY
	TLNE	F,FL6		;SKIP IF ITS NOT 6FMT
	JRST	COPSE1		;2ND PASS OR 6FMT-EXIT.
	MOVEM	LOC,1		;FIRST BLK OF NEXT OUTPUT
	SUBI	1,144		;FIND
	SUB	1,INC		;    A
	IMULI	1,-200		;     DIRECTORY,
	ADD	1,LISTC		;GRAB
	HRLI	1,1(1)		;    A
	HRRI	1,DIRECT	;     DIRECTORY.
	BLT	1,DIRECT+177	;SAVE IT.
	JRST	COPSE1		;RETURN

DLST:	TLNE	F,FL6		;6FMT?
	JRST	D6LST		;YES.
	HRLI	3,150000	;"DASH" TERMINATOR.
	HRLZI	1,-26		;ONLY 22 FILES
DBEG:	SKIPN	2,DNAM(1)	;NULL FILE?
	JRST	DTST		;YES, TEST END.
	MOVEI	BP,2		;(2) HAS FILENAME.
	PUSHJ	P,TYPEIT	;TO THE BUFFER
	HLLZ	2,DNAM+26(1)	;GET AN EXTENSION.
	SKIPN	2		;NULL EXTENSION
	JRST	DFIN		;APPEND A "CR-LF"
	MOVEI	C,"	"	;TAB
	PUSHJ	P,TYPC		;DUMP THE BUFFER
	HRRI	2,150000		;"-" TERMINATOR
	MOVEI	BP,2		;EXT TO THE BUFFER
	PUSHJ	P,TYPEIT	;DUMP THE BUFFER
DFIN:	PUSHJ	P,TYPCL		;"CR/LF"
DTST:	AOBJN	1,DBEG		;TEST FOR 26 FILES
DXIT:	MOVEI	C,^D22		;22 SECONDS
	JRST	GDNITE		;TO SLEEP.

D6LST:	MOVEI	0,36		;MAX NO. OF ENTRIES
	HRRZ	1,DIRECT	;LOC OF FIRST DIR BLK
D6BEG:	HRLI	3,150000	;"-" TERMINATOR
	MOVEI	BP,2		;
	SKIPN	2,DIRECT(1)	;IS THERE A FILENAME?
	JRST	DXIT		;NORMAL EXIT
	PUSHJ	P,TYPEIT	;FILENAME
	HLLZ	2,DIRECT+1(1)	;EXTENSION
	SKIPN	2		;IF NULL,
	JRST	D6FIN		;JUMP
	MOVEI	C,"	"	;OTHERWISE
	PUSHJ	P,TYPC		;TAB
	HRRI	2,150000	;"-"
	MOVEI	BP,2		;TERM.
	PUSHJ	P,TYPEIT	;
D6FIN:	PUSHJ	P,TYPCL		;CR-LF
	ADDI	1,4		;
	SOJG	0,D6BEG		;IN CASE
	JRST	DXIT		;DIR WAS FULL

TYPEIT:	HRLI	BP,440600		;BP=MESSAGE ADR
TYPLOP:	ILDB	C,BP			;
	CAIN	C,15			;DASH?
	POPJ	P,			;GET THE WHOLE MESSASE
	CAIN	C,3			;#?
	JRST	TYPCL			;APPEND CR LF AND TYPE
	ADDI	C,40			;ASCIZE IT
	IDPB	C,TOUT+1		;TO THE BUFFER
	JRST	TYPLOP			;+LOOP

TYPGET:	ILDB	C,TIN+1			;GET CHAR
	CAIE	C," "			;SPACE?
	CAIN	C,"	"		;TAB?
	JRST	TYPGET			;FORGET IT
	POPJ	P,

TYPCCL:	IDPB	C,TOUT+1		;TYPE CHAR,CRLF
TYPCL:	MOVEI	C,15			;TYPE CRLF
	IDPB	C,TOUT+1
	MOVEI	C,12
TYPC:	IDPB	C,TOUT+1		;TYPE CHAR
TYPBUF:	OUTPUT	17,			;DO IT
	POPJ	P,
ERRT1I:	TLOA	F,FLI			;INPUT ERROR
ERRT1O:	TLZ	F,FLI			;OUTPUT ERROR
	STATUS	1,IOS			;STATUS TO IOS
	TRNE	IOS,360000		;ALL THE ERRORS
	JRST	ERRCHK			;FOUND AN ERROR
	POPJ	P,

ERRT2I:	TLOA	F,FLI			;INPUT ERROR
ERRT2O:	TLZ	F,FLI			;OUTPUT ERROR
	STATUS	2,IOS			;FLAGS TO IOS
	TRNN	IOS,760000		;PLUS WRITE LOCK
	POPJ	P,			;NO ERRORS
	TLO	F,FL2			;IT'S A CHANNEL 2 ERROR

ERRCHK:	TRNE	IOS,400000
	PUSHJ	P,ERR400		;WRITE LOCK
	TRNE	IOS,200000
	PUSHJ	P,ERR200		;DEVICE ERROR
	TRNE	IOS,100000
	PUSHJ	P,ERR100		;CKSUM/PARITY
	TRNE	IOS,040000
	PUSHJ	P,ERR040		;BLOCK TOO LARGE
	TRNE	IOS,020000		;PREMATURE EOF,PDP9-DTA?
	PUSHJ	P,ERR020		;
	TRNN	IOS,640000		;THESE BITS IMPLY RESTART
	TLNN	F,FLG			;/G+PARITY ERR = CONTINUE
	JRST	ST			;RESTART
	TRZ	IOS,740000		;ZERO IN
	TLNN	F,FL2
	SETSTS	1,(IOS)			;TURN OFF
	TLZE	F,FL2
	SETSTS	2,(IOS)			;AND
	POPJ	P,			;POP OUT



ERR400:	MOVEI	BP,MES400
	JRST	TYPEIT
MES400:	SIXBIT	/WRITE LOCK ERROR#/
ERR200:	PUSHJ	P,ERRCOM
	MOVEI	BP,MES200
	JRST	TYPEIT
MES200:	SIXBIT	/ DEVICE ERROR#/
ERR100:	PUSHJ	P,ERRCOM
	MOVEI	BP,MES100
	JRST	TYPEIT
MES100:	SIXBIT	/ CHECKSUM OR PARITY ERROR#/
ERR040:	PUSHJ	P,ERRCOM
	MOVEI	BP,MES040
	JRST	TYPEIT
MES040:	SIXBIT	/ BLOCK TOO LARGE#/
ERR020:	PUSHJ	P,ERRCOM
	MOVEI	BP,MES020
	JRST	TYPEIT
MES020:	SIXBIT	/ PREMATURE END OF FILE#/
ERRCOM:	MOVEI	BP,SXBINP
	TLNN	F,FLI
	MOVEI	BP,SXBOUT
	JRST	TYPEIT
SXBINP:	SIXBIT	/INPUT-/
SXBOUT:	SIXBIT	/OUTPUT-/
ERRVER:	MOVE	T,[POINT 6,MESVER]
	MOVE	BP,[POINT 3,U,17]
ERRVE1:	ILDB	C,BP		;LOAD AN OCTAL NUMBER
	ADDI	C,20		;6BITIZE IT
	IDPB	C,T		;INSERT IN MESS
	TLNE	T,770000	;ONE WORD ONLY
	JRST	ERRVE1		;LOOP 6 TIMES
	MOVEI	BP,MESVER
	JRST	TYPEIT
MESVER:	SIXBIT	/000000 VERIFICATION ERRORS#/
ERRCMD:	MOVEI	BP,MESCMD
	PUSHJ	P,TYPEIT
	JRST	ST
MESCMD:	SIXBIT	/COMMAND ERROR#/
ERRSW:	MOVEI	BP,MESSW
	PUSHJ	P,TYPEIT
	JRST	ST
MESSW:	SIXBIT	/SWITCH ERROR#/
ERRIN1:	SKIPA	T,IDEV
ERRIN2:	MOVE	T,ODEV
	MOVEM	T,MESINI
	MOVEI	BP,MESINI
	PUSHJ	P,TYPEIT
	JRST	ST
MESINI:	SIXBIT	/       INIT FAILURE#/
ERRDT1:	SKIPA	T,IDEV
ERRDT2:	MOVE	T,ODEV
	MOVEM	T,MESDTA
	MOVEI	BP,MESDTA
	PUSHJ	P,TYPEIT
	JRST ST
MESDTA:	SIXBIT	/       MUST BE A DECTAPE#/
ERRTNH:	MOVEI	BP,MESTNH
	PUSHJ	P,TYPEIT
	JRST	ST
MESTNH:	SIXBIT	/TENDUMP IS NOT IN CORE.#/
MES32K:	SIXBIT	/32K TENDUMP?... -/
MES16K:	SIXBIT	/16K TENDUMP?... -/
TENINT:	TLNN	F,K32+K16	;IF NO REQUEST,
	POPJ	P,		;EXIT.
	PUSH	P,JOBFF
	SETSTS	2,134		;SO I CAN WRITE IN BLK 0
	USETO	2,0
	OUTBUF	2,1
	OUTPUT	2,		;DUMMY!
	HRLZI	BP,K32DMP	;BEG OF 32K TENDMP
	TLNN	F,K32		;DOES HE WANT 32K?
	HRLZI	BP,K16DMP	;NO
	TLNE	F,LST		;IF SET 16K IS
	HRLZI	BP,K32DMP	;IN 32K'S SLOT.
	HRR	BP,OUT2+1	;BLT PTR
	MOVEM	BP,C		;SAVE IT
	BLT	BP,177(C)	;ZAP 1
	OUTPUT	2,		;BLK 0
	ADD	C,[XWD 200,0]
	MOVEM	C,BP		;2ND PTR SAVED
	BLT	BP,177(C)	;ZAP 2
	USETO	2,1
	OUTPUT	2,		;BLK 1
	PUSHJ	P,ERRT2O	;ERRORS?
	POP	P,JOBFF
	POPJ	P,
COPZRO:	PUSH	P,JOBFF		;SAVE JOBFF
	SETSTS	1,134		;
	SETSTS	2,134		;
	OUTBUF	2,1		;WITH ONE BUFFER MODE-134
	USETO	2,0		;FOR BLOCK ZERO
	OUTPUT	2,		;DUMMY
	TLNN	F,FLC		;COPY
	JRST	COPBKZ		;NO, MUST BE ZERO
	INBUF	1,1		;ONE BUFFER MODE-134
	USETI	1,0		;BLOCK ZERO
	INPUT	1,		;GET IT
	PUSHJ	P,ERRT1I	;OK?
	MOVEI	T,177		;LOOP LENGTH
	LDB	C,IN1+1		;FIRST WORD
	DPB	C,OUT2+1	;TO THE BUFFER
COPLPZ:	ILDB	C,IN1+1		;OTHER WORDS
	IDPB	C,OUT2+1	;TO THE BUFFER
	SOJG	T,COPLPZ	;TO LOOP OR
COPBKZ:	OUTPUT	2,		;DUMP THE BUFFER
	POP	P,JOBFF		;FOR VERIFY?
	PUSHJ	P,ERRT2O		;OK?
	SETSTS	2,136		;DUMP MODE
	SETSTS	1,136		;IN-DEV
	USETI	1,1		;SIX DIR
	INPUT	1,DIRWRD		;GOT IT
	MOVE	U,JOBREL		;UPPER LIMIT
	MOVE	T,BLTWRD	;FROM,TO
	SETZM	@ZROWRD		;START
	BLT	T, (U)		;ZAP
	MOVEI	LOC,1		;START AT BLOCK ONE
COPSET:	CAILE	LOC,144		;DIR IN CORE?
	JRST	DSAV		;MAYBE...
COPSE1:	TLNE	F,FLC		;SKIP
	USETI	1,(LOC)		;IO 2 UNASGND CH
	USETO	2,(LOC)		;SET THE BLOCK NO.
	ADD	LOC,INC		;ADD THE INCREMENT
	CAILE	LOC,1102	;WILL IT FIT?
	JRST	COPFIN		;NO
	PUSHJ	P,COPYIT	;ONE BUFFER
	JRST	COPSET		;AND LOOP

COPFIN:	SUBI	LOC,1102	;N BLOCKS WON'T FIT
	IMULI	LOC,200		;N WORDS WON'T FIT
	MOVSS	LOC		;GET ORGANIZED
	ADDM	LOC,LISTC	;SUB N WORDS FROM LIST
	SKIPL	LISTC		;IF LH OF IOWD = 0,
	POPJ	P,		;EXIT
COPYIT:	TLNN	F,FLC		;COPY?
	JRST	COPOUT		;ZERO!
	INPUT	1,LISTC		;COPY!
	PUSHJ	P,ERRT1I	;OK?
COPOUT:	OUTPUT	2,LISTC		;COPY AND ZERO
	JRST	ERRT2O		;OK?
VERZRO:	PUSH	P,JOBFF
	SETZB	VZ1,VZ2		;CMDLST TERMINATOR
	SETSTS	1,134		;SET
	SETSTS	2,134		;IB MODE
	USETI	1,0		;AND
	USETI	2,0		;BLOCK 0
	INBUF	1,1		;WITH
	INBUF	2,1		;ONE BUFFER EA
	INPUT	1,		;GET A BLOCK
	PUSHJ	P,ERRT1I	;OK
	INPUT	2,		;GET ANOTHER
	PUSHJ	P,ERRT2I	;OK
	HRRZ	V1,IN1		;DUMMY
	HRRZ	V2,IN2		;IOWD
	HRLI	V1,-200		;FOR VERIFY LOOP
	POP	P,JOBFF		;RECLAIM BUFFERS
	PUSHJ	P,VERIFY		;VERIFY AND EXIT THIS PAGE
VERONE:	SETSTS	1,136		;SET
	SETSTS	2,136		;DUMP MODE
	MOVEI	LOC,1		;START AT BLOCK 1
VERSET:	MOVE	V1,LISTV1	;IOWDS
	MOVE	V2,LISTV2	;TO ACS
	USETI	1,(LOC)		;MASTER
	USETI	2,(LOC)		;AND COPY
	ADD	LOC,INCV	;ADD IN THE INCREMENT
	CAILE	LOC,1102	;AM I ASKING TOO MUCH?
	JRST	VERFIN		;YEP
	PUSHJ	P,VERIN		;COUPLE OF INPUTS AND VERIFY
	JRST	VERSET

VERFIN:	SUBI	LOC,1102	;HOW MUCH TOO MUCH?
	IMULI	LOC,200		;IN WORDS PLEASE
	MOVSS	LOC		;BACKWARDS
	ADD	V1,LOC		;SUB WORDS FROM LIST
	ADD	V2,LOC		;I.E. ASK FOR LESS
	SKIPL	V1		;IF LH OF IOWD = 0,
	POPJ	P,		;EXIT

VERIN:	INPUT	1,V1		;ONE FOR THE MASTER
	PUSHJ	P,ERRT1I	;OK?
	INPUT	2,V2		;ONE FOR THE COPY
	PUSHJ	P,ERRT2I	;OK?

VERIFY:	SETZ	U,		;CLR THE ERROR CNT
	MOVE	T,1(V1)		;MASTER WORD
	CAME	T,1(V2)		;SAME AS COPY WORD?
	AOS	U		;NO, COUNT THE ERRORS
	AOS	V2		;PLUS ONE
	AOBJN	V1,VERIFY+1	;BOTH HALVES AND LOOP
	JUMPN	U,ERRVER	;ERROR MESS IF APPROPIATE
	POPJ	P,		;UNLESS V1 IS POSITIVE
INIT:	INIT	2,(T)
ODEV:	Z
	XWD	OUT2,IN2
	JRST	ERRIN2
	MOVE	BP,ODEV		;MAKE SURE ITS A DTA.
	CALLI	BP,4
	TLNN	BP,100
	JRST	ERRDT2		;ERROR, ITS NOT A DTA
	SKIPN	IDEV		;IF NULL
	POPJ	P,		;NO INPUT DEV REQUIRED
	INIT	1,(T)
IDEV:	Z
	XWD	0,IN1
	JRST	ERRIN1
	MOVE	BP,IDEV		;MAKE SURE ITS A DTA
	CALLI	BP,4
	TLNN	BP,100
	JRST	ERRDT1		;ERROR
	POPJ	P,


BLTWRD:	XWD	K32DMP,K32DMP+1	;ZRO FROM,TO
ZROWRD:	EXP	K32DMP		;START
FSAVE:	XWD	FLP,0	;MODIFIED WHEN 10DMP IS LOADED
LISTC:	IOWD	0,DATA
	Z
LISTV1:	IOWD	0,DATA
LISTV2:	IOWD	0,DATA
INC:	BLOCK	1
INCV:	BLOCK	1
DIRECT:	BLOCK	123
DNAM:	BLOCK	55
DIRWRD:	IOWD	200,DIRECT
	Z
REWIND:	IOWD	1,PTRBUF
	Z
TTYIN:	BLOCK	23+10
TTYOUT:	BLOCK	23
IN1:	BLOCK	3
IN2:	BLOCK	3
OUT2:	BLOCK	3
TIN:	BLOCK	3
TOUT:	BLOCK	3
PTRBUF:	BLOCK	3
	LIT
	VAR
K32DMP:	BLOCK 400
K16DMP:	BLOCK 400
	;THE FOLLOWING ONCE ONLY CODE IS FOR LOADING 10DMP

DATA:	SETZB	IOS,.		;BURN YOUR BRIDGES
	HLRZ	0,JOBSA
	HRRZM	0,JOBFF		;SET THE BUFFERS RIGHT
	MOVE	F,FSAVE		;FLAGS TO F
	MOVE	1,XWD1		;ASSUME 32K
	INIT	16,13		;I.B.
	SIXBIT	/PTR/
	EXP	PTRBUF
	JRST	PTERR1		;PTR INIT FAILURE
	INBUF	16,1		;ONE BUFFER
PTRINP:	JUMPL	IOS,PTREOF	;END OF FILE YET?
	INPUT	16,		;GET 40 PTR WORDS
	STATZ	16,740000	;EVERYONE OK?
	JRST	PTERR2		;PTR DATA ERROR
	STATZ	16,20000	;EOF?
	TLO	IOS,400000	;N.B.
PTRNXT:	SOSGE	PTRBUF+2	;HOW'S THE BUFFER?
	JRST	PTRINP		;EMPTY?
	ILDB	C,PTRBUF+1	;WORD TO C
	AOBJP	1,PTERR3	;2 BLKS HOLD 400 WDS NO MORE
	MOVEM	C,0(1)		;C TO CORE
	JRST	PTRNXT		;LOOP

PTREOF:	CLOSE	16,		;CLEAR EOF
	TLC	IOS,-1		;1ST  400000  2ND -1
	JUMPE	IOS,EOF2	;1ST  377777  2ND  0
	SKIPL	K32DMP		;NULL FILE?
	JRST	NOFILE		;YES
	MOVE	1,XWD2		;SET FOR 16K
	TLO	F,L32		;NOTE 32K
	JRST	PTRINP		;LOOP
NOFILE:	MOVE	1,XWD1		;DON'T CHANGE BUFFERS
	TLO	F,LST		;THERE IS A NULL FILE
	JRST	P		;LOOP

EOF2:	TLNE	F,LST		;WAS THE FIRST FILE NULL?
	SKIPL	K32DMP		;YES,	2ND??
	SKIPGE	K16DMP		;NO,	YES,	2ND??
	TLOA	F,L16		;	NO	NO
	TLO	F,LST		;		YES
	MOVEM	F,FSAVE

	MOVEI	BP,PTERM	;FILES JUST LOADED:
	PUSHJ	P,TYPEIT
	TLNE	F,L32+L16
	JRST	PEXIT1
	MOVEI	BP,PTERM3	;NONE
	PUSHJ	P,TYPEIT
	JRST	PEXIT9
PEXIT1:	TLNN	F,L32
	JRST	PEXIT2
	MOVEI	BP,PTERM1	;32K TENDUMP#
	PUSHJ	P,TYPEIT
PEXIT2:	TLNN	F,L16
	JRST	PEXIT9
	MOVEI	BP,PTERM2	;16K TENDUMP#
	PUSHJ	P,TYPEIT
PEXIT9:	MOVEI	0,DATA		;ASSUME 2 FILES
	TLNE	F,LST
	SUBI	0,400		;AT LEAST ONE NULL FILE
	TLNN	F,L32+L16
	SUBI	0,400		;TWO NULL FILES
	HRLM	0,JOBSA
	HRL	0,0		;SO WE CAN ZERO 
	ADDI	0,1		;ALL FREE CORE
	MOVEM	0,BLTWRD
	HLRZM	0,ZROWRD
	CALLI	12		;EXIT
PTERR1:	MOVEI	BP,PTINIT
	PUSHJ	P,TYPEIT
	JRST	PEXIT9
PTERR2:	MOVEI	BP,PTDATA
	PUSHJ	P,TYPEIT
	JRST	PEXIT9
PTERR3:	MOVEI	BP,PTB2LG
	PUSHJ	P,TYPEIT
	JRST	PEXIT9

PTINIT:	SIXBIT	/PTR INIT FAILURE#/
PTDATA:	SIXBIT	/PTR DATA ERROR#/
PTB2LG:	SIXBIT	/FILE TOO LARGE  (GT 400 WORDS)#/

PTERM:	SIXBIT	/FILES JUST LOADED:#/
PTERM1:	SIXBIT	/32K TENDUMP#/
PTERM2:	SIXBIT	/16K TENDUMP#/
PTERM3:	SIXBIT	/NONE#/
XWD1:	XWD	-401,K32DMP-1
XWD2:	XWD	-401,K16DMP-1
	END	ST	;;30-JAN
                                                                                                                                                                                                                                             A@V{