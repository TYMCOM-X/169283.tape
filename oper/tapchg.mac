TITLE   TAP     05/19/73  **SPECIAL KLUDGE VERSION FOR CHANGED BITS
;*CHECK OUT THE ESCAPE ROUTINE
;*IMPROVE TAPE ERROR LOGIC TO READ WHOLE FILE
;*PUT SYSTEM NUMBER ON TAPE AND IN PRINTED DIRECTORY
;*DON'T ALWAYS CHECK FOR WRITE RING
;*PERHAPS HF LICENSE SHOULD BE RESTORED
;*CHECK TO BE SURE DEVICE IS A MAG TAPE OR USE PHYSICAL ONLY
;*REJECT "AFTER DATE" IF DATE AND TIME IS IN THE FUTURE
;*TOO MANY "EOF NOT FOUND AFTER HEADER" MESSAGES
;*REENTER AND CONTINUE MAY NOT WORK
;*PRINT NUMBER OF FILES STORED/RESTORED
;*SHORTEN RESTORE OLD FILE MESSAGE
;*ACCEPT TIME WITH NO COLON 0100
;*ACCEPT DASH BETWEEN TIME AND DATE
;*LICENSE RESTORE LOGIC IS NONEXISTENT
;*SKIP AT END OF TAPE SHOULD AT LEAST WARN THE GUY
;*ON RESTORE, TEX SHOULD NOT GO PAST LAST POSSIBLE FILE
;*IMPROVE EOT BACKUP LOGIC ON STORE
;*ACCESS REAL MTA AND NOT ASSIGNED UNIT
;*ERROR ROUTINE SHOULD MARK FILE AS BAD
;*TAPIN ERR SHOULD SAY WHAT KINDS OF ERRORS
;*DON'T RESTORE LICENSE TO FILES WITHOUT LICENSE
;*HAVE OPERS RECOVER BAD FILES
;*PRINT CHECKSUM IN DIRECTORY
;*ZERO DISC AND TAPE BUFFERS BEFORE INPUT
;*CHECK EACH TAPE TO BE SURE IT'S NOT THE ONE WE JUST DUMPED

VERLOC= 137
        LOC     VERLOC
        VERSION                         ;STORE VERSION NUMBER IN LOC 137
        RELOC

;ACCUMULATOR ASSIGNMENTS
F=      10      ;FLAG AC
U=      15      ;FIRST  WORD ON A READ OF MFD OR UFD
W=      16      ;SECOND WORD ON A READ OF MFD OR UFD
HA==    5       ;USED ONLY BY HASHER - REGISTER PRESERVED BY HASHER
HB==    HA+1    ;USED ONLY BY HASHER - REGISTER PRESERVED BY HASHER
HC==    HA+2    ;USED ONLY BY HASHER - REGISTER PRESERVED BY HASHER
HD==    HA+3    ;USED ONLY BY HASHER - REGISTER PRESERVED BY HASHER
HE==    HA+4    ;USED ONLY BY HASHER - REGISTER PRESERVED BY HASHER

;CHARACTERS
QCHR=   121
PRIME=  47
COMMA=  54
LBRACK= 133
RBRACK= 135

;PARAMETER ASSIGNMENTS
XLOOKN==40              ;NO. OF ARGS FOR EXTENDED LOOKUP/ENTER
UCHGBT==200000          ;CHANGED (DUMPED) BIT IN UFD (RH)
RCHGBT==20000           ;CHANGED (DUMPED) BIT IN RIB (LH)
FILCTD==100000          ;(LH) FILE CONTINUED ON NEXT TAPE BIT IN TRAILER
USRCTD==200000          ;(LH) USER CONTINUED ON NEXT TAPE BIT IN TRAILER
TAPCTD==400000          ;(LH) CONTINUATION TAPE(S) FOLLOW BIT IN TRAILER
MSKCTD==TAPCTD!USRCTD!FILCTD    ;MASK FOR CONTINUED BITS

;CALLI ADDRESSES
DEVCHR==4
RESET== 0
WAIT==  10
DATE==  14
MSTIME==23

;DEVICE ASSIGNMENTS
TAP==   3               ;MAGNETIC TAPE FOR READ OR WRITE
MFD==   4               ;DISK FOR MASTER FILE DIRECTORY
UFD==   5               ;DISK FOR USER FILE DIRECTORY (MUST BE MFD+1)
FIL==   6               ;DISC FOR USER FILE
CHK==   7               ;DISC FOR FILE DATE CHECK
LUD==   10              ;LUD
DUL==   11              ;DUL

;NUMBER OF BUFFERS/CHANNEL
TAPN==  2
MFDN==  2
UFDN==  2
FILN==  5
CHKN==  2
LUDN==  1
DULN==  1

;SIZE OF BUFFERS/DEVICE
TAPSIZ==1003
DSKSIZ==203

;I/O STATUS BIT ASSIGNMENTS
BUFBIN==14              ;BUFFERED BINARY MODE
NOCNT== 20              ;MONITOR IS NOT TO COMPUTE BUFFER WORD COUNT
SYNCIN==40              ;SYNCHRONOUS INPUT
IOEND== 20000           ;END OF FILE
BOTBIT==4000                    ;BEGINNING OF TAPE
IOTEND==2000                    ;END OF TAPE
IOBAD== 740000                  ;I/O ERROR
BTL==   40000                   ;BLOCK TOO LARGE FOR BUFFER
DNC==   10                      ;DO NOT CHG ACCESS DATE
RST==   40                      ;DISCARD THIS FILE AND KEEP OLD ONE

;EXTENDED LOOKUP FILE STATUS BITS
.RPNFS==40000           ;(RH) DO-NOT-SAVE BIT

;FLAG ASSIGNMENTS (LH OF AC F)
EOTFND==1                       ;EOT HAS BEEN READ
EOFFND==2                       ;END OF DISC FILE HAS BEEN READ
BOTFLG==4                       ;AT BEGINNING OF TAPE
FILFND==10                      ;A FILE WAS SAVED FOR THIS USER
CTDFLG==20                      ;TAPE CONTINUED AT EITHER END
UFDFLG==40                      ;ON IF PROG HAS LICENSE TO SET UP UFDS
LUDFLG==100                     ;ON IF LUD IS OPEN
DULFLG==200                     ;ON IF DUL IS OPEN
STOFLG==400                     ;ON FOR STORE.  OFF FOR RESTORE
DIRFLG==1000                    ;ON FOR DIRECTORY.
IGNFLG==2000                    ;IGNORE THIS FILE IF ON

SRTOT==:4                       ;STORE/RESTORE PRINT TOTALS
SRUSR==:2                       ;STORE/RESTORE PRINT USERS
SRFIL==:1                       ;STORE/RESTORE PRINT FILES
SRMSK== SRTOT+SRUSR+SRFIL       ;STORE/RESTORE MASK
OSNEW==:10                      ;OLD FILE/SYS RESTORE NEWEST FILE
OSTAP==:20                      ;OLD FILE/SYS RESTORE FILE FROM TAPE
OSDSK==:40                      ;OLD FILE/SYS IGNORE FILE FROM TAPE
OSCON==:100                     ;OLD FILE/SYS ASK FOR CONFIRMATION
OSMSK== OSNEW+OSTAP+OSDSK+OSCON ;OLD FILE/SYS MASK

START:  MOVE    P,STACK##       ;INITIALIZE THE STACK
        CALLI   RESET           ;CLEAR ALL I/O
        SETZ    F,              ;CLEAR ALL FLAGS
        ERO     [XWD [VERLOC],[ASCIZ "$TEX - VERSION _H$"]]
        PUSHJ   P,GETDUL        ;OPEN THE DUL BEFORE THROWING AWAY LIC
        HRROI   R1,-20          ;LOOK FOR OPERATOR LICENSE
        GETTAB  R1,             ;READ JOB AND PROCESS LICENSE
        MOVEI   R1,0            ;CANNOT READ LICENSE SO SET TO ZERO
        HRLZM   R1,JBLIC#       ;SAVE THE JOB'S LICENSE
        TRNN    R1,100000       ;SKIP IF OPER LICENSE SET
        HRLS    R1              ;THROW AWAY PROGRAM'S LICENSE
        TRNN    R1,100000       ;SKIP IF OPER LICENSE SET
        TYPE    [ASCIZ "OPERATOR LICENSE IS NOT SET.$"]
        TLO     F,UFDFLG        ;ASSUME WE HAVE LIC TO SET UP UFDS
        TLC     R1,5002         ;COMPLEMENT WF JL ST LICENSE BITS
        TLCE    R1,5002         ;PUT LIC BACK AND SKIP IF ENOUGH LIC
        TLZ     F,UFDFLG        ;NOT ENOUGH LICENSE TO SET UP UFDS
        SETLIC  R1,             ;SET APPROPRIATE LICENSE
        MOVSI   R1,TAPSIZ-2     ;DATA WORDS/BUFFER
        SETZM   TAPBUF          ;CLR STATUS OF 1ST BUFFER
        HRRI    R1,TAPBUF+1+TAPSIZ ;ADDR OF NEXT BUFFER
        MOVEM   R1,TAPBUF+1     ;STORE POINTER INTO THIS BUFFER
        SETZM   TAPBUF+TAPSIZ   ;CLR STATUS OF 2ND BUFFER
        HRRI    R1,TAPBUF+1     ;LAST BUFFER SHOULD POINT TO FIRST
        MOVEM   R1,TAPBUF+1+TAPSIZ
        MOVE    R1,[XWD -1,2]   ;NEED PPN FOR THIS JOB
        GETTAB  R1,             ;GET PPN FOR THIS JOB
        MOVEI   R1,0            ;SHOULD NEVER FAIL LIKE THIS
        MOVEM   R1,JBPPN#       ;SAVE PPN FOR THIS JOB
UNIROU: TYPE    [ASCIZ "UNIT: "]
        PUSHJ   P,RDDNUM        ;READ TAPE UNIT NUMBER
        CAIE    CT,TE##         ;SKIP IF IT'S A LINE TERMINATOR
        JRST    UNIERR          ;PRINT ERROR MESSAGE AND TRY AGAIN
        CAIG    R0,7            ;MUST BE 7 OR LESS
        SKIPGE  R0              ;MUST BE 0 OR GREATER
UNIERR: ERO     [XWD [UNIROU],[ASCIZ "_FTYPE 0 OR 1$_E"]]
        ADDI    R0,20           ;CONVERT NUMBER TO SIXBIT
        LSH     R0,14           ;LEFT SHIFT DIGIT TWO PLACES
        HRLI    R0,(SIXBIT /MTA/)
        MOVEM   R0,FS6BIT       ;SAVE THE UNIT NUMBER
        PUSHJ   P,SETIN         ;ASSIGN THE TAPE UNIT
        JRST    SCDISP##        ;START UP THE COMMAND DISPATCHER

STOROU::MOVEM   P,STOSTP#       ;SAVE STACK POINTER
        TLZ     F,DIRFLG+IGNFLG ;NOT DIR AND NOTHING IGNORED
        TLO     F,STOFLG        ;THIS IS A STORE AND NOT A RESTORE
        SKIPE   R1,STRPPN       ;SKIP IF NO STARTING PPN
        TYPE    [ASCIZ "REEL NUMBER: "]
        SETZM   TAPNUM          ;STARTING REEL IS ONE IF NO STARTING PPN
        JUMPE   R1,CONSTO       ;JUMP IF NO STARTING PPN
        PUSHJ   P,RDDNUM##      ;READ DECIMAL NUMBER
        CAIE    CT,TE           ;SKIP IF NUMBER TERMINATED BY A CR
        ERROR   [ASCIZ "INVALID REEL NUMBER"]
        SOJ     R0,             ;DECREMENT REEL NUMBER
        MOVEM   R0,TAPNUM#      ;INITIALIZE THE TAPE SEQ NUMBER
CONSTO: SETZM   RECTOT#         ;NO RECORDS ON THIS TAPE YET
        SETZM   USRPTR          ;MARK AS NOTHING IN SORT TABLE
        SETZM   USRGPT          ;INITIALIZE POINTER FOR GETTING ENTRIES
        PUSHJ   P,SETOUT        ;INIT TAPE AND SET UP HEADER AS VIRGIN
        OUTPUT  TAP,            ;DUMMY OUTPUT TO SET UP TAPHED
        PUSHJ   P,TAPOU3        ;SET UP BUFFER COUNTS
        TLNE    F,BOTFLG        ;SKIP IF NOT AT BEGINNING OF TAPE
        MTAPE   TAP,13          ;ERASE 3 INCHES TO GET OFF LOAD POINT
        MTAPE   TAP,0           ;WAIT FOR OPERATION TO COMPLETE
        AOS     R1,TAPNUM       ;INCREMENT AND LOAD TAPE SEQ NUMBER
        HRRM    R1,FIRBL2       ;PLACE IN HEADER
        CALLI   R1,MSTIME       ;FORM THE TAPE'S DATE AND TIME
        IDIVI   R1,^D60000      ;FLUSH JIFFIES AND SECONDS
        CALLI   R2,DATE         ;GET TODAY'S DATE
        ANDI    R1,3777
        LSH     R1,^D12         ;TIME IN BITS 13-23
        IOR     R1,R2           ;DATE IN 24-35
        MOVEM   R1,DAYTIM#      ;STASH AWAY FOR HEADER LABEL
        ERO     [XWD [TAPNUM
                DAYTIM],[ASCIZ "$$TAPE NUMBER _C FOR _L$"]]
        PUSHJ   P,LABBLT        ;WRITE OUT HEADER

MORE1:  PUSHJ   P,MFD2          ;GET ENTRY FROM MFD - SKIP IF NOT DONE
        JRST    CDISP##         ;DONE WITH STORE SO RET TO CMD DISP
MORE2:  PUSHJ   P,UFD2          ;GET ENTRY FROM UFD - SKIP IF NOT DONE
        JRST    MORE1           ;DONE WITH THIS UFD
        SETZM   RECCNT#         ;NO RECORDS FOR THIS FILE OUTPUT YET
        PUSHJ   P,DIRBLT        ;BLT DIRECTORY INTO TAPE BUFFER
MORE3:  PUSHJ   P,FILIN         ;INPUT A BUFFER - SKIP IF NOT END OF FILE
        JRST    MORE2           ;DONE WITH THIS FILE SO GET NEXT
        ERROR   [ASCIZ "SHOULD NEVER GET PAST MORE3."]

;                               ^OVERFLOW
;USRTAB:                Z
;USRPTR:
;               ^ USRSRS
;               ^ USRSRE
;USRGPT:
;USRTBE:                A

TMPUSR: BLOCK   2               ;USER NAME OF USER JUST READ FROM MFD
TMPPPN: BLOCK   1               ;PPN OF USER JUST READ FROM MFD

USRSC== 100                     ;NUMBER OF USERS TO SORT AT A TIME

USRGPT: 0                       ;POINTER USED TO GET ENTRIES FROM TABLE
USRPTR: 0                       ;POINTER TO VARIABLE END OF SORT TABLE
USRSRS: 0                       ;STARTING RANGE FOR PLACING NEW USER
USRSRE: 0                       ;ENDING RANGE FOR PLACING NEW USER

        BLOCK   3               ;EXTRA OVERFLOW ENTRY - THROWN AWAY
USROVF: BLOCK   3               ;FIRST USER OVERFLOWED FROM TABLE
                                ;USRTAB MUST FOLLOW USROVF
USRTAB: BLOCK   3*USRSC         ;USER SORT TABLE
USRTBE: BLOCK   3               ;END OF USER SORT TABLE

CMPLP:  MOVE    R1,USRGPT       ;POINTER TO NEXT ENTRY
        CAMLE   R1,USRPTR       ;SKIP IF NO ENTRIES LEFT
        JRST    CPOPJ1          ;SUCESS RETURN IF ENTRIES LEFT
        MOVE    R0,STRPPN       ;GET PPN OF STARTING USER
        SKIPE   USRPTR          ;SKIP IF FIRST TIME THROUGH CMPLP
        JUMPE   R0,CPOPJ        ;FAIL RETURN IF DONE
        MOVEI   R1,USRTBE       ;ADDR OF END OF TABLE
        MOVEM   R1,USRGPT       ;SAVE POINTER FOR GETTING ENTRIES
        MOVEM   R1,USRPTR       ;SAVE POINTER TO VARIABLE END OF TABLE
        SETZ    R1,             ;ZERO NAME IN CASE IT'S 0,0
        JUMPE   R0,CMPLP6       ;JUMP IF NO STARTING USER
        PUSHJ   P,PPNUSR        ;CONVERT PPN TO USER NAME
        ERO     [XWD [STRPPN
                CLDSP],[ASCIZ "CANNOT CONVERT STARTING PPN _K._E"]]
        PUSHJ   P,SHFTUN        ;FIX USER NAME FOR COMPARING WITH OTHERS
CMPLP6: MOVEM   R0,STRUSR       ;SAVE 1ST HALF OF USER NAME
        MOVEM   R1,STRUSR+1     ;SAVE 2ND HALF OF USER NAME
        SETZM   USROVF+2        ;SET DEFAULT PPN TO ZERO
        MOVE    R1,[XWD 377777,-1];LARGEST POSSIBLE NUMBER
        MOVEM   R1,USROVF       ;SET NAMES TO LARGEST POSSIBLE VALUE
        MOVEM   R1,USROVF+1     ;SET NAMES TO LARGEST POSSIBLE VALUE
        HRLZI   R1,USROVF       ;ADDR OF START OF SORT TABLE
        HRRI    R1,USROVF+3     ;SHIFT ALL WORDS BY THREE
        BLT     R1,USRTBE+2     ;ZERO THE SORT TABLE
        PUSHJ   P,OPNMFD        ;OPEN THE MFD
        JRST    CMPLP3          ;START SORTING
CMPLP2: MOVE    R1,USRPTR       ;ADDR OF VARIABLE END OF SEARCH TABLE
        HRLS    R1              ;ADDR IN BOTH HALVES FOR BLT
        SUBI    R1,3            ;SHIFT EVERYTHING BY THREE WORDS
        MOVE    R2,USRSRS       ;LAST ENTRY TO BE MOVED
        BLT     R1,-1(R2)       ;MAKE ROOM FOR NEW ENTRY
        HRLI    R1,TMPUSR       ;ADDRESS OF NEW ENTRY
        HRRI    R1,(R2)         ;ADDR OF SLOT FOR NEW ENTRY
        BLT     R1,2(R2)        ;PUT NEW ENTRY INTO THE TABLE
        MOVE    R1,USRPTR       ;ADDRESS OF VARIABLE END OF TABLE
        CAILE   R1,USROVF       ;SKIP IF TABLE IS FULL
        SUBI    R1,3            ;ADD ONE ENTRY TO TABLE
        MOVEM   R1,USRPTR       ;SAVE NEW END OF TABLE POINTER
CMPLP3: MOVE    R1,USRPTR       ;POINTER TO VARIABLE END OF SORT TABLE
        MOVEM   R1,USRSRS       ;STARTING RANGE FOR PLACING NEW USER
        MOVEI   R1,USRTBE       ;FIXED END OF SORT TABLE
        MOVEM   R1,USRSRE       ;ENDING RANGE FOR PLACING NEW USER
        PUSHJ   P,GMFD          ;GET NEXT ENTRY
        JRST    CMPLP4          ;RETURN FROM CMPLP IF STRPPN FOUND
        MOVEI   R1,TMPUSR       ;ADDR OF NAME JUST READ
        MOVEI   R2,USROVF       ;ADDR OF OVERFLOWED NAME
        PUSHJ   P,USRCMP        ;SKIP IF TMPUSR NOT GREATER
        JRST    CMPLP3          ;GET NEXT ENTRY CAUSE THIS WOULD OVERFLOW
CMPLP1: MOVE    R1,USRSRE       ;ENDING RANGE FOR PLACING NEW USER
        SUB     R1,USRSRS       ;FIND POSSIBLE RANGE FOR NEW USER
        JUMPE   R1,CMPLP2       ;JUMP IF PLACE HAS BEEN FOUND
        IDIVI   R1,6            ;3 WRDS/ENTRY AND 2 FOR BINARY SEARCH
        IMULI   R1,3            ;3 WORDS/ENTRY
        ADD     R1,USRSRS       ;STARTING RANGE FOR NEW USER
        SKIPA   R2,[TMPUSR]     ;ADDR OF USER NAME JUST READ
CMPLP5: ADDI    R1,3            ;BUMP R1 IF NO PROGRESS BEING MADE
        MOVEI   R3,USRSRE       ;ASSUME END RANGE MUST BE CHANGED
        PUSHJ   P,USRCMP        ;SKIP IF TMPUSR GREATER
        MOVEI   R3,USRSRS       ;MUST CHANGE STARTING RANGE
        CAIN    R3,USRSRE       ;SKIP IF NOT CHANGING END OF RANGE
        SUBI    R1,3            ;WE CAN MOVE IT UP BY ONE ENTRY
        CAMN    R1,(R3)         ;SKIP IF PROGRESS STILL BEING MADE
        JRST    CMPLP5          ;NO PROGRESS SO TRY ANOTHER ADDR
        MOVEM   R1,(R3)         ;SET NEW USRSRS OR USRSRE
        JRST    CMPLP1          ;NEXT ITERATION OF SEARCH
CMPLP4: MOVE    R1,USRTBE+2     ;GET FIRST PPN TO BE STORED
        SKIPN   STRPPN          ;SKIP IF LOOKING FOR A STARTING PPN
        SETZ    R1,             ;FORCE STARTING PPN'S TO BE EQUAL
        CAME    R1,STRPPN       ;SKIP IF STARTING PPN FOUND
        ERO     [XWD [STRPPN
                CLDSP],[ASCIZ "CANNOT FIND STARTING USER _A._E"]]
        MOVE    R1,USROVF+2     ;GET FIRST OVERFLOW FROM TABLE
        MOVEM   R1,STRPPN       ;SET NEW STARTING PPN
        MOVE    R1,USRPTR       ;POINTER TO END OF TABLE
        CAIG    R1,USRPTR       ;SKIP IF NO OVERFLOW
        MOVEI   R1,USRTAB       ;PUT IT BACK IN RANGE
        MOVEM   R1,USRPTR       ;PUT BACK THE END OF TABLE POINTER
        JRST    CPOPJ1          ;SKIP RETURN FROM CMPLP

USRCMP: MOVE    R0,(R1)         ;GET NAME FROM TABLE
        CAMN    R0,(R2)         ;SKIP IF NOT EQUAL TO NAME READ IN
        JRST    .+4             ;EQUAL SO COMPARE SECOND HALF
        CAMG    R0,(R2)         ;SKIP IF NAME IN TABLE GREATER
        AOS     (P)             ;SKIP RETURN
        POPJ    P,              ;RETURN
        MOVE    R0,1(R1)        ;GET 2ND HALF OF NAME FROM TABLE
        CAMG    R0,1(R2)        ;SKIP IF GREATER THAN NAME READ IN
        AOS     (P)             ;SKIP RETURN
        POPJ    P,              ;RETURN SKIPPING IF R1 .LE. R2

OPNMFD: MOVEI   R1,MFDHED
        MOVEM   R1,IOBUF
        OPEN    MFD,MFDSPK      ;WANT TO READ MFD FOR THIS STR
        ERROR   [ASCIZ "UNABLE TO INIT DEVICE DSK."]
        MOVEI   R1,MFDBUF       ;SET UP BUFFERS
        MOVEM   R1,JOBFF##      ;TELL SYSTEM WHERE TO PUT THE BUFFERS
        INBUF   MFD,MFDN
        MOVE    R1,SYSPP        ;LOOK FOR MFD
        MOVEM   R1,MFDDI3       ;IN THE MFD
        MOVEM   R1,MFDDIR
        MOVSI   R1,(SIXBIT /UFD/)
        MOVEM   R1,MFDDI1
        LOOKUP  MFD,MFDDIR      ;(OLD STYLE LOOKUP)
        ERROR   [ASCIZ "UNABLE TO DO LOOKUP ON MFD."]
        POPJ    P,              ;RETURN FROM OPNMFD

;READ MFD

GMFD:   PUSHJ   P,GETMFD        ;READ WORD 0 OF MFD ENTRY
        JUMPE   R1,GMFD         ;SKIP TO NEXT PAIR ON 0
        MOVE    U,R1            ;SAVE PPN IN REGISTER U
        PUSHJ   P,GETMFD        ;READ WORD 1 OF MFD ENTRY
        HLRZ    W,R1            ;EXTENSION IN RH FOR EASY COMPARE
        PUSHJ   P,GETMFD        ;READ WORD 2 OF MFD ENTRY
        PUSHJ   P,GETMFD        ;READ WORD 3 OF MFD ENTRY
        PUSHJ   P,GETMFD        ;READ WORD 4 OF MFD ENTRY
        CAIE    W,(SIXBIT /UFD/);SKIP IF THIS IS A UFD
        JRST    GMFD            ;LOOK FOR NEXT UFD
        MOVEM   U,TMPPPN        ;SAVE PPN
        MOVE    R0,TMPPPN       ;GET PPN FOR COVERSION TO USER NAME
        PUSHJ   P,PPNUSR        ;CONVERT PPN TO USER NAME AND SKIP IF OK
        JRST    GMFD            ;IGNORE STRAY UFD'S
        PUSHJ   P,SHFTUN        ;FIX USER NAME FOR COMPARING WITH OTHERS
        MOVEM   R0,TMPUSR       ;SAVE 1ST HALF OF USER NAME
        MOVEM   R1,TMPUSR+1     ;SAVE 2ND HALF OF USER NAME
        MOVEI   R1,STRUSR       ;ADDR OF NAME OF STARTING USER
        MOVEI   R2,TMPUSR       ;USER JUST READ
        SKIPN   STRPPN          ;SKIP IF LOOKING FOR STARTING PPN
        JRST    .+3             ;DON'T CHECK FOR PAST STARTING PPN
        PUSHJ   P,USRCMP        ;SKIP IF STARTING USER OR PAST IT
        JRST    GMFD            ;IGNORE THIS USER
        PUSHJ   P,CKNPPN        ;SKIP IF THIS USER SHOULD BE DUMPED
        JRST    GMFD            ;NOT THIS USER, TRY THE NEXT
        JR CPOPJ1          ;SKIP RETURN FROM GMFD

SHFTUN: SETZ    R2,             ;ASSUME SHIFT OF ZERO
        CAMN    R0,[SIXBIT /UFD/] ;SKIP IF NOT USER 1,1 (UFD)
        HRRZI   R2,-14          ;PUT (UFD) ON THE TAPE FIRST
        CAMN    R0,[SIXBIT /SYS/] ;SKIP IS NOT USER 1,4 (SYS)
        HRRZI   R2,-6           ;PUT (SYS) ON THE TAPE SECOND
        LSHC    R0,(R2)         ;SHIFT IF (UFD) OR (SYS)
        TLC     R0,400000       ;COMPLEMENT SIGN BIT FOR COMPARE
        TLC     R1,400000       ;COMPLEMENT SIGN BIT FOR COMPARE
        POPJ    P,              ;RETURN FROM SHFTUN

MFD2:   PUSHJ   P,CMPLP         ;GET NEXT BATCH OF ENTRIES
        JRST    STODON          ;DONE WITH THE STORE
        MOVE    R1,USRGPT       ;GET POINTER TO NEXT ENTRY
        MOVE    U,2(R1)         ;GET NEXT PPN
        SUBI    R1,3            ;POINT TO NEXT ENTRY
        MOVEM   R1,USRGPT       ;SAVE POINTER TO NEXT ENTRY
        HRRZI   W,(SIXBIT /UFD/);THE EXTENSION "UFD"
        INIT    UFD,BUFBIN      ;IS IT AVAILABLE
        SIXBIT  /DSK/
        XWD     0,UFDHED        ;INPUT ONLY
        ERROR   [ASCIZ "UNABLE TO INIT DSK"]
        MOVEI   R1,UFDBUF       ;SETUP BUFFERING
        MOVEM   R1,JOBFF
        INBUF   UFD,UFDN
        MOVE    R1,SYSPP        ;LOOK FOR UFD
        MOVEM   R1,UFDDI1       ;IN THE UFD
        MOVEI   R1,XLOOKN       ;EXT. LOOKUP
        MOVEM   R1,UFDDIR
        MOVEM   U,UFDDI2        ;PPN FOR THIS USER
        HRLZM   W,UFDDI3        ;THE EXTENSION "UFD"
        LOOKUP  UFD,UFDDIR      ;IS IT STILL THERE
        ERO     [XWD [UFDDI2
        MFD2],[ASCIZ "$UNABLE TO DO LOOKUP ON UFD FOR USER _A.  CONTINUING WITH NEXT USER.$_E"]]
        TLZ     F,FILFND        ;NO FILES FOUND YET FOR THIS USER
        JRST    CPOPJ1          ;WE READ SOMETHING SO SKIP RET FROM MFD2

GETMFD: SOSG    MFDHD2          ;SKIP IF MORE WORDS IN BUFFER
        PUSHJ   P,MFDIN         ;GET ANOTHER BUFFER
        ILDB    R1,MFDHD1       ;NEXT WORD INTO R1
        POPJ    P,

MFDIN:  IN      MFD,            ;READ ANOTHER BUFFER
        POPJ    P,              ;HAPPY, RETURN
        STATZ   MFD,IOBAD       ;SKIP IF NO ERROR (END OF BUFFER)
        ERROR   [ASCIZ "ERROR IN READING MFD"];*
        CLOSE   MFD,DNC
        RELEASE MFD,
        SUB     P,[XWD 2,2]     ;POP STACK TWICE
        POPJ    P,              ;FAIL RETURN FROM GMFD

STODON: SKIPE   STRPPN          ;SKIP IF NOT LOOKING FOR STARTING PPN
        ERROR   [ASCIZ "CANNOT FIND STARTING USER."]
        MTAPE   TAP,7           ;BACK SPACE OVER EOF
        MTAPE   TAP,0           ;WAIT FOR OPERATION TO COMPLETE
        PUSHJ   P,TRLOUT        ;WRITE TRAILER RECORD
        PUSHJ   P,PRTT          ;PRINT TOTALS FOR THIS TAPE
        TYPE    [ASCIZ "STORE COMPLETED$$"]
        POPJ    P,              ;FAIL RETURN FROM GMFD

;READ UFD

UFD2:   SETZM   BLKCNT#         ;SET BLOCK COUNT FOR FILE TO ZERO
        TLZ     F,EOFFND        ;END OF FILE NOT YET FOUND
        PUSHJ   P,GETUFD        ;READ WORD 0 OF UFD ENTRY
        JUMPE   R1,UFD2         ;SKIP TO NEXT ENTRY ON ZERO
        MOVE    U,R1            ;PLACE IN FIRST WORD REGISTER
        PUSHJ   P,GETUFD        ;READ WORD 1 OF UFD ENTRY
        HLRZ    W,R1            ;PUT EXTENSION IN RH FOR EASY COMPARE
        MOVEM   R1,UFDBTS#      ;SAVE TO CHECK FOR DUMPED BIT
        PUSHJ   P,GETUFD        ;READ WORD 2 OF UFD ENTRY
        MOVEM   R1,CRTION       ;SAVE CREATION DATE
        PUSHJ   P,GETUFD        ;READ WORD 3 OF UFD ENTRY
        PUSHJ   P,GETUFD        ;READ WORD 4 OF UFD ENTRY
        CAIN    W,(SIXBIT /TMP/);IGNORE TEMP FILES
        JRST    UFD2            ;GET NEXT ENTRY FROM UFD
        MOVE    R1,STRFIL       ;ZERO IF NOT LOOKING FOR STARTING FILE
        CAMN    W,STREXT        ;SKIP IF NOT STARTING EXTENSION
        CAME    U,STRFIL        ;SKIP IF THIS IS THE STARTING FILE
        JUMPN   R1,UFD2         ;JUMP IF STARTING FILE NOT YET FOUND
        SETZM   STRFIL          ;MARK STARTING FILE AS FOUND
        PUSHJ   P,CKNFIL        ;SKIP IF THIS FILE SHOULD BE STORED
        JRST    UFD2            ;NO - TRY ANOTHER
        PUSHJ   P,CKNCRE        ;SKIP IF CREATION DATE OK TO DUMP
        JRST    UFD2            ;NO - TRY ANOTHER
        PUSHJ   P,CKNCHG        ;SKIP IF CHANGED OR IF WE DON'T CARE
        JRST    UFD2            ;NOT CHANGED
        MOVEI   R1,XLOOKN       ;EXT. LOOKUP
        MOVEM   R1,FILDIR
        MOVEM   U,FILDI2        ;FILE NAME
        HRLZM   W,FILDI3        ;EXTENSION
        MOVE    R1,UFDDI2       ;PROJ-PROG NUMBER
        MOVEM   R1,FILDI1
        INIT    FIL,BUFBIN      ;SET TO GET FILE
        SIXBIT  /DSK/
        XWD     0,FILHED        ;INPUT ONLY
        ERROR   [ASCIZ "UNABLE TO INIT DSK."]
        MOVEI   R1,FILBUF       ;SETUP BUFFERS
        MOVEM   R1,JOBFF
        INBUF   FIL,FILN
        LOOKUP  FIL,FILDIR      ;IS IT THERE?
        ERO     [XWD [FILDI1
        UFD2],[ASCIZ "$UNABLE TO DO LOOKUP ON FILE _J. CONTINUING WITH NEXT FILE.$_E"]]
        MOVE    R1,FRBSTS       ;GET FILE STATUS
        TRNE    R1,.RPNFS       ;DO-NOT-SAVE BIT ON?
        JRST    UFD2            ;YES
        TLO     F,FILFND        ;INDICATE FILE FOUND
        PUSHJ   P,TRCL          ;TRANSFER CURPPN-FIL-EXT TO LST...
        HRLZM   W,CUREXT        ;SAVE NEW EXTENSION
        MOVEM   U,CURFIL        ;SAVE NEW FILE NAME
        MOVE    R1,UFDDI2       ;GET NEW PPN
        MOVEM   R1,CURPPN       ;SAVE NEW PPN
        JRST    CPOPJ1          ;SKIP RETURN FROM UFD2

GETUFD: SOSG    UFDHD2          ;ANY MORE WORDS IN BUFFER?
        PUSHJ   P,UFDIN         ;NO, GET SOME
        ILDB    R1,UFDHD1       ;NEXT WORD
        POPJ    P,

UFDIN:  IN      UFD,            ;READ ANOTHER BUFFER
        POPJ    P,              ;HAPPY, RETURN
        STATO   UFD,IOBAD       ;END OF FILE?
        JRST    ENDUFD          ;YES, GO DO WRAPUP
        STATZ   UFD,BTL         ;SKIP IF BLOCK NOT TOO LARGE
        TYPE    [ASCIZ "BLOCK TOO LARGE$"]
        TYPE    [ASCIZ "ERROR READING UFD$"]
        JRST    UFDFR           ;UFD2 FAIL RETURN
ENDUFD: MOVSS   STREXT          ;PUT EXTENSION IN LH TO PRINT IT
        SKIPE   STRFIL          ;SKIP IF NOT LOOKING FOR STARTING FILE
        ERO     [XWD [STRFIL
        CLDSP##],[ASCIZ "CANNOT FIND STARTING FILE _B._E"]]
        TLZN    F,FILFND        ;ANY FILES FOR THIS USER?
        JRST    NULUFD          ;NOPE
        PUSHJ   P,CLSUSR        ;WRITE EOFS ON TAPE
        PUSHJ   P,TRCL          ;FINISH UP THE LAST FILE
        PUSHJ   P,SPRTU         ;PRINT USER TOTALS IF WE SHOULD
        SKIPA   
NULUFD: PUSHJ   P,NULTAP        ;RESET BUFFER
        CLOSE   UFD,DNC
        RELEASE UFD,            ;GIVE UP UFD DDB
UFDFR:  SUB     P,[XWD 2,2]     ;POP STACK TWICE TO RETURN FROM UFD2
        POPJ    P,              ;FAIL RETURN FROM UFD2

;DISK FILE INPUT

FILIN:  HRLZI   R1,RCHGBT       ;GET THE RIB CHANGED BIT
        TDNE    R1,FRBNCA       ;SKIP IF NOT ALREADY MARKED AS DUMPED
        JRST    NOTDMP          ;DON'T BOTHER TO DO IT AGAIN
        ORM     R1,FRBNCA       ;MARK FILE AS DUMPED
        RENAME  FIL,FILDIR      ;DO A RENAME ON THE FILE TO MARK IT DUMPED
        ERO     [XWD [CURPPN],[ASCIZ "UNABLE TO MARK FILE _J AS DUMPED.$"]]
NOTDMP: SETZM   RECCNT          ;ZERO THE RECORD COUNT JUST IN CASE
        CLOSE   FIL,DNC
        RELEASE FIL,            ;GIVE UP USER FILE
        POPJ    P,              ;FAIL RETURN FROM FILIN

FSTWRD: PUSH    P,R1            ;SAVE R1 ON STACK
        PUSH    P,R2            ;SAVE R2 ON STACK
        ERO     [XWD [STRBLK
                CURPPN],[ASCIZ "STARTING WITH BLOCK _C OF FILE _J.$"]]
        MOVE    R1,STRBLK       ;GET THE STARTING WORD
        MOVEM   R1,OLDBLK#      ;SAVE IN CASE FILE IS SPLIT TWICE
        SETZM   STRBLK          ;SET STARTING BLOCK TO ZERO
        USETI   FIL,1(R1)       ;SET FILE AT STARTING BLOCK
        POP     P,R2            ;RESTORE R2 FROM STACK
        POP     P,R1            ;RESTORE R1 FROM STACK
        POPJ    P,              ;RETURN FROM FSTWRD

;MAG TAPE OUTPUT

TAPOUT: ERO     [XWD [CPOPJ],[ASCIZ "TAPE OUTPUT ATTEMPTED.$_E"]]
        ERROR   [ASCIZ "SHOULD NEVER GET HERE."]
        SUBB    R2,TAPHD2       ;COMPUTE WORDS USED
        JUMPE   R2,NULTAP       ;NONE USED, DONT OUTPUT
        HRRZ    R1,TAPHED       ;ADDR OF BUFFER CURRENTLY IN USE
        HRRM    R2,2(R1)        ;BUFFERED BINARY WORD COUNT FOR FAILSAFE
        AOS     R2
        HRRZM   R2,1(R1)        ;TOTAL DATA WORD COUNT FOR MONITOR
;       MOVEI   R1,0            ;NOT NECESSARY BECAUSE IT'S ALREADY +
TAPOU1: OUT     TAP,            ;WRITE ANOTHER RECORD
        SETOM   R1              ;MAKE R1 NEGATIVE FOR SUCCESSFUL OUTPUT
        AOS     RECCNT          ;COUNT RECORD WHETHER GOOD OR BAD
        AOS     RECTOT          ;ADD TO TOTAL RECORDS ON TAPE
        TLNE    F,EOTFND        ;SKIP IF END OF TAPE NOT PREVIOUSLY READ
        JRST    TAPOU4          ;SEE IF IT'S AN ERROR
        STATZ   TAP,IOTEND      ;SKIP IF END OF TAPE NOT JUST READ
        JRST    ENDTAP          ;*THIS SCREWS UP THE STACK
        JUMPL   R1,TAPOU3       ;JUMP IF ABOVE OUTPUT WAS SUCCESSFUL
        STATZ   TAP,400000      ;NO, WRITE-LOCKED TAPE?
        JRST    TAPNWR          ;NEED WRITE RING IN TAPE
        STATZ   TAP,200000      ;NO, PHYSICAL DEVICE ERROR?
        JRST    TAPPDE          ;PHYSICAL DEVICE ERROR
        TYPE    [ASCIZ "MAG TAPE WRITE ERROR--TRYING AGAIN$"]
        GETSTS  TAP,R2          ;CLEAR ERROR BITS FOR RETRY
        ANDCMI  R2,760000
        SETSTS  TAP,(R2)
        MTAPE   TAP,7           ;BACKSPACE RECORD
        MTAPE   TAP,13          ;WRITE 3 INCH BLANK TAPE
        MTAPE   TAP,0           ;WAIT FOR OPERATION TO TERMINATE
        SOS     RECCNT          ;DON'T COUNT THAT RECORD TWICE
        SOS     RECTOT          ;SUBTRACT FROM TOTAL ALSO
        JRST    TAPOU1          ;TRY AGAIN
TAPOU4: STATZ   TAP,740000      ;SKIP IF NO REAL ERROR
        ERROR   [ASCIZ "ERROR AFTER END OF TAPE."]
        JRST    TAPOU3          ;CONTINUE AS USUAL
TAPPDE: TYPE    [ASCIZ "PHYSICAL DEVICE ERROR."]
        JRST    TAPCON          ;ACCEPT CARRIAGE RETURN AND RETRY
TAPNWR: TYPE    [ASCIZ "TAPE NEEDS A WRITE RING."]
TAPCON: SOS     RECCNT          ;THAT RECORD DIDN'T GET WRITTEN
        SOS     RECTOT          ;SUBTRACT FROM TOTAL ALSO
        GETSTS  TAP,R2          ;CLEAR ERROR BITS FOR RETRY
        ANDCMI  R2,760000       ;CLEAR THE BITS
        SETSTS  TAP,(R2)        ;PUT STATUS BACK
        ERO     [XWD [TAPOU1
                CDISP],[ASCIZ "_FCONTINUE? _G$COMMAND ABORTED._E"]]

AGUFO:  SETZ    R2,             ;ALL
        HLRZ    R2,U            ;GANS
        HRRZ    R2,U            ;USERS
        HRRZ    R2,U            ;FILES

DEFINE  CNTF    (X) <
CNTF'X==:.-CNTTAB
        CNTF'X'R>

CNTFP==:(POINT 2,0,1)           ;POINTER USED TO GET THIS FIELD
CNTTAB: BLOCK   0               ;TABLE FOR CONTROL FIELD OF LIST
        CNTF    (C)             ;ITEM TERMINATED WITH A COMMA
        CNTF    (D)             ;ITEM TERMINATED WITH A DASH
        CNTF    (T)             ;ITEM TERMINATED WITH A CR
        CNTF    (N)             ;NOT

ALLLST::BYTE(2)CNTFT            ;DUMMY LIST FOR ALL FILES
CKNCHR: XOR     R2,[SIXBIT /#/] ;CHECK FOR POUND SIGN CHAR
        TLNN    R2,770000       ;SKIP IF IT'S NOT A POUND SIGN
        TLZ     R3,770000       ;THAT CHAR OF FILE MATCHES
        XOR     R2,[BYTE (6)34] ;EXCLUSIVE OR OF QUESTION AND POUND
        TLZN    R2,770000       ;SKIP IF IT'S NOT A QUESTION MARK
        TLZ     R3,770000       ;MAKE THAT CHAR OF FILE MATCH
        TLZE    R3,770000       ;SKIP IF CHARS MATCH
        POPJ    P,              ;FAIL RETURN
        LSHC    R2,6            ;SHIFT TO NEXT CHAR
        JUMPN   R3,CKNCHR       ;LOOP IF OTHER CHARS DON'T MATCH
        JRST    CPOPJ1          ;SUCCESS RETURN


CKNCRE: HRRZ    R1,CRTION       ;GET CREATION DATE
        ANDI    R1,7777         ;THROW AWAY NON-DATE BITS
        CAMLE   R1,CREDAT       ;SKIP IF DATE OF FILE NOT GREATER
        JRST    CPOPJ1          ;SKIP RETURN
        CAME    R1,CREDAT       ;SKIP IF DATES ARE EQUAL
        POPJ    P,              ;FAIL RETURN
        MOVE    R1,CRTION       ;GET CREATION DATE AND TIME
        AND     R1,[XWD 3777,770000] ;TURN OFF NON-TIME BITS
        CAML    R1,CRETIM       ;SKIP IF FILE TIME IS TOO OLD
        JRST    CPOPJ1          ;SKIP RETURN
        POPJ    P,              ;FAIL RETURN
CKNCHG: SKIPN   CHANGD          ;SKIP IF WE'RE CHECKING FOR CHANGED FILES
        JRST    CPOPJ1          ;SUCCESS RETURN FROM CKNCHG IF NOT CHECKING
        MOVE    R1,UFDBTS       ;GET STATUS BITS FROM UFD
        TRNN    R1,UCHGBT       ;SKIP IF FILE NOT CHANGED
        AOS     (P)             ;CHANGED SO SKIP RET AND DUMP IT
        POPJ    P,              ;RETURN FROM CKNCHG

CKNFIL: MOVEI   R1,2            ;SECOND PART OF COMMAND
        HLRZ    R2,CTABL2(R1)   ;GET STATE FOR SECOND PART OF COMMAND
        CAIE    R2,FF2##        ;SKIP IF CHECKING FOR INDIVIDUAL FILES
        JRST    CPOPJ1          ;SUCCESS RETURN - ALL FILES ARE OK
        HRRZ    R1,CTABL2(R1)   ;ADDRESS OF LIST
        LDB     R2,[XWD CNTFP+R1,0]
        CAIE    R2,CNTFT        ;SKIP IF THIS IS END OF USER NAME ETC
        AOJA    R1,.-2          ;LOOK AT THE NEXT ENTRY
CKNNX1: HRRZ    R2,2(R1)        ;GET THE EXTENSION
        MOVS    R3,1(R1)        ;GET FILE NAME BACKWARDS
        CAIN    R3,(SIXBIT /ALL/)
        JUMPE   R2,CPOPJ1       ;SUCCESS RETURN IF FILE "ALL"
        CAIN    R3,(SIXBIT /*/) ;SKIP IF NOT WILD CARD
        MOVS    R3,U            ;MAKE THE FILE NAMES MATCH
        MOVS    R3,R3           ;PUT THE FILE NAME BACK THE WAY IT SHOULD BE
        MOVE    R2,R3           ;ALSO PUT FILE NAME IN R2
        XOR     R3,U            ;EXCLUSIVE OR THE NAMES TO FIND DIFF
        PUSHJ   P,CKNCHR        ;SKIP IF NAMES MATCH
        AOJA    R1,CKNNXT       ;DON'T MATCH SO TRY THE NEXT
        HRRZ    R3,2(R1)        ;EXTENSION IN RH FOR EASY COMPARE
        CAIN    R3,(SIXBIT /*/) ;SKIP IF IT'S NOT A WILD CARD
        HRRZ    R3,W            ;MAKE THE EXTENSIONS MATCH
        MOVE    R2,R3           ;ALSO PUT EXTENSION IN R2
        XOR     R3,W            ;EXCLUSIVE OR THE EXTENSIONS TO FIND DIFF
        LSHC    R2,22           ;THIS ISN'T NECESSARY BUT SPEEDS UP CKNCHR
        PUSHJ   P,CKNCHR        ;SKIP IF NAMES MATCH
        AOJA    R1,CKNNXT       ;DON'T MATCH SO TRY THE NEXT
        JRST    CPOPJ1          ;SUCCESS RETURN FOR MATCH
CKNNXT: LDB     R2,[XWD CNTFP+R1,1]
        CAIN    R2,CNTFT        ;SKIP IF NOT THE LAST FILE IN LIST
        POPJ    P,              ;FAIL RETURN
        AOJA    R1,CKNNX1       ;CHECK THE NEXT FILE NAME

CKNPPN: SETOM   NOTWRD#         ;-1 FOR NORMAL, 0 FOR NOT
        MOVEI   R1,2            ;SECOND PART OF COMMAND
        MOVE    R1,CTABL2##(R1) ;GET PARAMETERS FOR COMMAND
        HLRZ    R3,R1           ;SAVE STATE IN R3
        JUMPE   R1,CPOPJ1       ;SUCCESS RET IF NOT SET UP
        LDB     R2,[XWD CNTFP+R1,0]
        HRRZ    R0,(R1)
        PUSHJ   P,@CNTTAB(R2)
        AOJA    R1,.-3          ;LOOP
        CAME    R2,[-1]         ;SKIP IF NO MATCH
        SETZ    R2,             ;ZERO FOR MATCH
        XOR     R2,NOTWRD       ;INVERT IF NORMAL, DO NOTHING IF NOT
        JRST    CPOPJ(R2)       ;ADD ONE FOR SUCCESS RETURN

CNTFNR: SETCMM  NOTWRD          ;INVERT THE OPERATION
        POPJ    P,
CNTFCR: XCT     AGUFO(R3)
        CAMN    R0,R2           ;SKIP IF NOT DONE
        AOS     (P)             ;DONE - DON'T LOOP ANYMORE
        POPJ    P,
CNTFDR: XCT     AGUFO(R3)
        AOJ     R1,
        CAMLE   R0,R2
        JRST    CNTFTT
        HRRZ    R0,(R1)
        CAML    R0,R2
        JRST    CPOPJ1 
CNTFTT: LDB     R2,[XWD CNTFP+R1,0]
        SETO    R0,
        CAIN    R2,CNTFT        ;SKIP IF NOT A TERMINATOR
        AOS     (P)             ;TERMINATOR, SO STOP LOOPING
        POPJ    P,
CNTFTR: XCT     AGUFO(R3)
        CAME    R0,R2           ;SKIP IF MATCH
        SETO    R2,             ;TERMINATE WITHOUT MATCH
        JRST    CPOPJ1          ;DONE LOOPING NO MATTER WHAT HAPPENED

;OUTPUT TRAILER BLOCK

TRLOUT: MOVN    R1,TAPNUM       ;NEGATE TAPE #
        HRRM    R1,FIRBL2       ;RESET TRAILER
                                ;FALL INTO LABBLT

;WRITE HEADER OR TRAILER ON TAPE

LABBLT: MOVE    R1,DAYTIM       ;GET DATE ETC
        TLZ     R1,MSKCTD       ;TURN OFF CONTINUED BITS
        SKIPE   STRPPN          ;SKIP IF NO STARTING PPN
        TLO     R1,TAPCTD       ;THIS IS A CONTINUATION TAPE
        SKIPE   STRFIL          ;SKIP IF NO STARTING FILE
        TLO     R1,USRCTD       ;USER IS CONTINUED FROM PREVIOUS TAPE
        SKIPE   STRBLK          ;SKIP IF NO STARTING BLOCK
        TLO     R1,FILCTD       ;FILE IS CONTINUED FROM PREVIOUS TAPE
        MOVEM   R1,FIRBL3       ;SAVE WORD IN TAPE HEADER
        MOVSI   R1,FIRBLK       ;ADDR OF HEADER
        HRR     R1,TAPHD1       ;GET BUFFER DATA ADDR FROM BYTE PTR
        MOVEI   R2,4(R1)        ;SET STOP AT 5TH DATA WORD
        BLT     R1,(R2)         ;BLT HEADER INTO BUFFER
        HRRM    R2,TAPHD1       ;RESET BYTE POINTER
        MOVNI   R1,3            ;RESET COUNT
        ADDM    R1,TAPHD2
        SOS     TAPHD2          ;ADJUST FOR NON-LOOP CALL
        PUSHJ   P,TAPOUT        ;WRITE ONE RECORD
CLSUSR: CLOSE   TAP,            ;ASK THE MONITOR TO CLOSE
        CALLI   TAP,WAIT        ;WAIT UNTIL OUTPUT FINISHED
NULTAP: MOVSI   R1,400000       ;TURN OFF VIRGIN BIT
        ANDCAB  R1,TAPHED
        AOS     R1              ;SET BYTE POINTER TO BEG OF BUFFER
        HRRM    R1,TAPHD1
TAPOU3: MOVEI   R1,TAPSIZ-4     ;DATA WORDS/BUFFER -1
        HRRZM   R1,TAPHD2       ;BUFFER COUNT
        IDPB    R1,TAPHD1       ;BUFFER COUNT TO 1ST DATA WORD
        POPJ    P,              ;RETURN

;BLT HEADERS INTO TAPE BUFFER

DIRBLT: MOVSI   R1,FILMRK       ;HEADER WORD FOR DIRECTORY
        HRR     R1,TAPHD1       ;GET BUFFER DATA ADDR FROM BYTE PTR
        MOVEI   R2,XLOOKN+2(R1) ;SET STOP AT LAST RETRIEVAL WORD
        BLT     R1,(R2)         ;BLT HEADER INTO BUFFER
        HRRM    R2,TAPHD1       ;RESET BYTE POINTER
        MOVNI   R1,XLOOKN+1     ;RESET COUNT
        ADDM    R1,TAPHD2
        POPJ    P,              ;RETURN

SETSTR: MOVE    R1,CURPPN       ;GET CURRENT PPN - ONLY RH COUNTS
        MOVEM   R1,STRPPN       ;MAKE IT THE STARTING PPN FOR NEXT TAPE
        MOVE    R1,CURFIL       ;GET CURRENT FILE NAME
        MOVEM   R1,STRFIL       ;MAKE IT THE STARTING FILE FOR NEXT TAPE
        MOVE    R1,CUREXT       ;GET CURRENT EXTENSION
        HLRZM   R1,STREXT       ;MAKE IT THE STARTING EXT FOR NEXT TAPE
        MOVE    R1,BLKCNT       ;GET REAL BLOCK COUNT IF ENOUGH TAPE USED
        ADD     R1,OLDBLK       ;ADD IN PREVIOUS STRT BLK IF ANY
        MOVEM   R1,STRBLK       ;SAVE STARTING BLOCK OF FILE
        SKIPE   STRBLK          ;SKIP IF FILE IS NOT SPLIT
        ERO     [XWD [CURPPN
                STRBLK],[ASCIZ "FILE _J WILL BE CONTINUED ON THE NEXT TAPE$STARTING WITH BLOCK _C.$"]]
        POPJ    P,              ;RETURN FROM SETSTR

ENDTAP: TLO     F,EOTFND        ;END OF TAPE HAS BEEN READ
        TLZE    F,EOFFND        ;SKIP IF EOF NOT YET FOUND
        PUSHJ   P,ETNF          ;FIND FIRST FILE FOR NEXT TAPE OR FINISH
        MOVE    R1,BLKCNT       ;GET BLOCK COUNT OF DISC FILE
        CAIG    R1,2000         ;SKIP IF ENOUGH DISC BLOCKS TO SPLIT FILE
        SETZM   BLKCNT          ;DON'T SPLIT THE FILE
        PUSHJ   P,SETSTR        ;SET UP STARTING FILE PARAMETERS
        PUSHJ   P,PRTT          ;PRINT TOTALS FOR THIS TAPE AND SAVE SET
        SKIPE   STRBLK          ;SKIP IF FILE IS NOT SPLIT
        JRST    ETBRET          ;FINISH UP THE TAPE
        ERO     [XWD [LSTPPN],[ASCIZ "THE LAST FILE ON THIS TAPE IS: _J$"]]
        ERO     [XWD [CURPPN],[ASCIZ "THE FIRST FILE ON THE NEXT TAPE WILL BE: _J$"]]
        PUSHJ   P,CLSUSR        ;CLOSE TAPE FILE AND RESET BUFFERS
        MTAPE   TAP,7           ;BACKSPACE OVER THE EOF JUST WRITTEN
        PUSHJ   P,SETINS        ;SET TAPE FOR SYNC INPUT
        TLO     F,EOTFND        ;THIS IS STILL AT END OF TAPE
        MOVE    R1,RECCNT       ;NUMBER RECORDS OUTPUT FOR CURRENT FILE
        MTAPE   TAP,7           ;BACK UP A RECORD
        SOJG    R1,.-1          ;JUMP IF WE'RE NOT TO START OF CURR FILE
        MTAPE   TAP,0           ;WAIT FOR COMPLETION
        IN      TAP,            ;INPUT A RECORD
        JRST    EOT1            ;INPUT WAS SUCCESSFUL
        STATZ   TAP,IOEND       ;SKIP IF END OF FILE NOT READ
        ERROR   [ASCIZ "FILE MARK READ IN WRONG PLACE"];*
        ERROR   [ASCIZ "TAPE ERROR WHILE TRYING TO END TAPE"];*

ETNF1:  PUSHJ   P,MFD2          ;GET NEXT USER
        JRST    CDISP           ;STORE COMPLETED SO RETURN TO CMD DISP
ETNF:   PUSHJ   P,UFD2          ;GET NEXT FILE FROM UFD
        JRST    ETNF1           ;DONE WITH USER SO GET NEXT
        POPJ    P,              ;RETURN FROM ETNF WITH NEXT FILE

EOT1:   PUSHJ   P,EOTWRD        ;READ A WORD FROM THE RECORD
        HLRE    R1,R1           ;ONLY WANT LH
        JUMPE   R1,[ERROR [ASCIZ "DATA RECORD IN WRONG PLACE"]];*
        JUMPG   R1,[ERROR [ASCIZ "TRAILER IN WRONG PLACE"]];*
        CAME    R1,[-1]         ;SKIP IF FILE HEADER
        ERROR   [ASCIZ "FILE HEADER NOT FOUND"];*
        PUSHJ   P,EOTWRD        ;READ STRUCTURE NAME
        PUSHJ   P,EOTWRD        ;READ SOMETHING OR OTHER
        PUSHJ   P,EOTWRD        ;READ PPN
        CAME    R1,CURPPN       ;SKIP IF IT'S THE RIGHT PPN
        ERROR   [ASCIZ "FOUND WRONG PPN AT EOT"];*
        PUSHJ   P,EOTWRD        ;READ THE FILE NAME
        CAME    R1,CURFIL       ;SKIP IF IT'S THE RIGHT NAME
        ERROR   [ASCIZ "FOUND WRONG FILE AT EOT"];*
        PUSHJ   P,EOTWRD        ;READ FILE EXTENSION
        HLLZS   R1              ;ZERO RH
        CAME    R1,CUREXT       ;SKIP IF IT'S THE RIGHT EXTENSION
        ERROR   [ASCIZ "FOUND WRONG EXTENSION AT EOT"];*
        MTAPE   TAP,7           ;BACK OVER DIRECTORY
        MTAPE   TAP,0           ;WAIT FOR OPERATION TO FINISH
        MOVE    R1,CURPPN       ;GET CURRENT USER
        CAME    R1,LSTPPN       ;IF SAME AS LAST WE DON'T WANT 2 EOFS
        MTAPE   TAP,7           ;BACK UP ONE RECORD
        MTAPE   TAP,0           ;WAIT FOR OPERATION TO FINISH
        PUSHJ   P,SETOUT        ;SET TAPE FOR OUTPUT
        TLO     F,EOTFND        ;THIS IS STILL AT END OF TAPE
        OUTPUT  TAP,            ;SET UP BUFFERS - TAPE NOT WRITTEN
ETBRET: PUSHJ   P,TAPOU3        ;SET UP TRAILER
        PUSHJ   P,TRLOUT        ;WRITE TRAILER
        PUSHJ   P,REWTAP        ;REWIND (NO  UNLOAD) WITHOUT WAIT
        CLOSE   MFD,DNC         ;CLOSE THE MFD
        RELEASE MFD,
        PUSHJ   P,NXTTAP        ;GET THE NEXT TAPE MOUNTED
        MOVE    P,STOSTP        ;FIX STACK FOR BRANCH OUT OF SUBROUTINE
        JRST    CONSTO          ;CONTINUE THE STORE
NXTTAP: ERO     [XWD [NXTTA1
                CDISP],[ASCIZ "_F$MOUNT NEXT TAPE.$CONTINUE? _G_E"]]
NXTTA1: PUSHJ   P,REWWAI        ;REWIND THE NEW TAPE AND WAIT
        POPJ    P,              ;RETURN
EOTWRD: ILDB    R1,TAPHD1       ;GET NEXT WORD OF RECORD
        SOS     TAPHD2          ;*REDUCE COUNT
        POPJ    P,              ;RETURN WITH WORD


;INITIALIZE MAGNETIC TAPE

SETINS: MOVEI   R1,SYNCIN       ;GET SYNC INPUT BIT
        IORM    R1,TAPOPN       ;TURN ON SYNC INPUT BIT FOR OPEN
SETIN:  HRRZI   R1,TAPHED       ;SET UP FOR INPUT
        SKIPA
SETOUT: HRLZI   R1,TAPHED       ;SET UP FOR OUTPUT
        MOVEM   R1,INOUT        ;SET HEADER
        OPEN    TAP,TAPOPN      ;OPEN UNIT 0 OR 1
        ERROR   [ASCIZ "UNABLE TO ACCESS TAPE UNIT."]
        MOVE    R1,[XWD 400000,TAPBUF+1] ;INIT 1ST WORD OF HEADER
        MOVEM   R1,TAPHED
        TLZ     F,EOTFND!BOTFLG ;CLEAR EOT AND BOT FLAGS
        GETSTS  TAP,R1          ;GET REAL TAPE STATUS
        TRNE    R1,BOTBIT       ;SKIP IF NOT BEGINNING OF TAPE
        TLO     F,BOTFLG        ;AT BEGINNING OF TAPE
        TRNE    R1,IOTEND       ;SKIP IF NOT AT END OF TAPE
        TLO     F,EOTFND        ;AT END OF TAPE
        POPJ    P,              ;RETURN

TAPOPN: EXP BUFBIN!NOCNT!1B0    ;*SIGN BIT DOESN'T WORK
FS6BIT: SIXBIT /MTAX/           ;STORED INTO BY START ROUTINE
INOUT:  XWD     0,0             ;STORED INTO BY SETIN/SETOUT

; TAPIN READS ONE RECORDS FROM TAPE AND RETURNS TO:
;  CALL+1 IF END OF FILE READ
;  CALL+2 IF DIRECTORY, HEADER, OR TRAILER IS READ
;  CALL+3 IF DATA RECORD READ
; IF IT RETURNS TO CALL+2, R1 TELLS WHAT WAS READ:
;  TRAILER=-1, HEADER=0, DIRECTORY=1

TAPIN:  SETOM   R0              ;INITIALIZE ERROR COUNT TO 0-1
TAPINE: IN      TAP,            ;READ ANOTHER BUFFER
        JRST    TAPIN2          ;READ OK
        STATO   TAP,IOEND       ;END OF FILE?
        JRST    ERRTIN          ;GO TO ERROR ROUTINE
        CLOSE   TAP,            ;CLEAR END BIT
        PUSHJ   P,TRCL          ;TRANSFER CURPPN-FIL-EXT TO LST...
        PUSHJ   P,RPRTU         ;PRINT END OF USER INFO
        POPJ    P,              ;RETURN CALL+1 (EOF)

TAPIN2: STATZ   TAP,IOTEND      ;SKIP IF NOT END OF TAPE FOUND
        TLO     F,EOTFND        ;MARK END OF TAPE FOUND
        ILDB    R2,TAPHD1       ;PICKUP WORD COUNT
        SOS     TAPHD2          ;ADJUST WD CT BELOW THIS WORD
        HLRZ    R2,R2           ;0 FOR DATA, -1 FOR DIR
        JUMPE   R2,CPOPJ2       ;JUMP IF IT'S A DATA RECORD
        PUSHJ   P,TRCL          ;TRANSFER CURPPN-FIL-EXT TO LST...
        MOVE    R1,TAPHED       ;GET ADDRESS OF CURRENT BUFFER
        CAIN    R2,-1           ;SKIP IF NOT A DIR RECORD
        JRST    TINDIR          ;DIRECTORY FOUND
        PUSHJ   P,RPRTU         ;PRINT END OF USER INFO
        MOVE    R1,TAPHED       ;RESTORE R1
        HRL     R1,4(R1)        ;GET THE TAPE NUMBER
        HLREM   R1,FIRBL2       ;SAVE THE TAPE NUMBER
        MOVMS   FIRBL2          ;WE WANT THE MAGNITUDE OF THE NUMBER
        MOVE    R1,5(R1)        ;GET FLAGS AND DATE
        MOVEM   R1,FIRBL3       ;SAVE FLAGS AND DATE
        MOVE    R1,TAPHED       ;GET ADDRESS OF CURRENT BUFFER
        HRL     R1,4(R1)        ;-=TRAILER, +=HEADER
        CAIN    R2,-6
        ERROR   [ASCIZ "FAILSAFE LEVEL C FORMAT TAPE"];*
        SKIPGE  R1              ;SKIP IF NOT TRAILER
        PUSHJ   P,PRTT          ;PRINT END OF SAVE SET INFO
        SKIPL   R1              ;SKIP IF TRAILER
        TLZ     F,CTDFLG        ;TURN OF CONTINUED FLAG IF HEADER
        SKIPGE  5(R1)           ;SKIP IF CONTINUED BIT OFF
        TLO     F,CTDFLG        ;SET CONTINUED FLAG
        HLLE    R1,R1           ;-=TRAILER, +=HEADER; 0 OR -1 IN ADDR
        JUMPG   R2,CPOPJ1       ;HEADER/TRAILER
        ERROR   [ASCIZ "ERROR IN TAPE DATA."];*

ERRTIN: GETSTS  TAP,R1          ;GET ERROR BITS
        TRZ     R1,760000       ;CLEAR ERROR BITS
        SETSTS  TAP,(R1)        ;SET NEW STATUS
        AOJG    R0,TAPINE       ;INC ERR CNT - JUMP IF NOT 1ST ERROR
        PUSHJ   P,TAPINE        ;NOTE THAT THIS IS CALLED RECURSIVELY
        JRST    ETIEOF          ;EOF - TELL OPERATOR AND RETURN
        JRST    ETIDIR          ;DIR - TELL OPERATOR AND RETURN
        JRST    .-3             ;DATA - READ UNTIL NEXT FILE
ETIDIR: SKIPA   R2,[1]          ;SKIP ONCE WHEN WE RET FROM ORIG TAPIN
ETIEOF: MOVEI   R2,0            ;DON'T SKIP WHEN WE RETURN FROM ORIG TAPIN
        ADDM    R2,(P)          ;INCREMENT 0 OR 1 FOR ORIG TAPIN RET
        AOS     R0              ;INCREMENT ERROR CNT BEFORE PRINTING
        MOVEM   R0,TAPERR#      ;SAVE ERROR COUNT FOR PRINTING
        ERO     [XWD [TAPERR
        LSTPPN],[ASCIZ "_C TAPE ERROR(S) READING USER FILE _J"]]
        JUMPG   R2,.+3          ;JUMP IF DIRECTORY JUST READ
        TYPE    [ASCIZ "$CONTINUING WITH THE NEXT USER.$"]
        POPJ    P,              ;RETURN FROM ORIG TAPIN CALL
        JUMPLE  R1,CPOPJ        ;PRINT NOTHING IF TRAILER OR HEADER READ
        ERO     [XWD [CURPPN],[ASCIZ "$CONTINUING WITH FILE _J$"]]
        POPJ    P,              ;RETURN FROM ORIGINAL TAPIN CALL

TINDIR: MOVSI   R2,5(R1)        ;ADDRESS OF NEW PPN-FIL-EXT
        HRRI    R2,CURPPN       ;ADDRESS OF CURRENT PPN
        BLT     R2,CUREXT       ;SET UP NEW CURRENT PPN-FIL-EXT
        MOVEI   R1,1            ;JUST READ A DIRECTORY
        JRST    CPOPJ1          ;SKIP RETURN FROM TAPIN

TRCL:   TLNE    F,IGNFLG        ;SKIP IF FILE BEING IGNORED
        POPJ    P,              ;RETURN FROM TRCL
        SKIPN   CURPPN          ;SKIP IF THERE IS A CURRENT FILE
        POPJ    P,              ;RETURN FROM TRCL DOING NOTHING
        MOVEI   R1,MSPTR##      ;ASSUME THIS IS A STORE COMMAND
        TLNN    F,STOFLG        ;SKIP IF STORE COMMAND
        MOVEI   R1,MRPTR##      ;GET POINTER FOR RESTORE MODE
        LDB     R1,(R1)         ;GET PROPER MODE
        TLNE    F,DIRFLG        ;SKIP IF DIRECTORY CMD
        SETZ    R1,             ;DON'T PRINT FILE NAMES FOR DIRECTORY
        TRNE    R1,1            ;SKIP IF FILE NAME SHOULD NOT BE PRINTED
        ERO     [XWD [CURPPN],[ASCIZ "_J$"]]
        AOS     FILCNT          ;INCREMENT THE FILE COUNT
        MOVE    R1,[XWD CURPPN,LSTPPN]
        BLT     R1,LSTEXT       ;MOVE CURPPN-FIL-EXT TO LSTPPN-FIL-EXT
        SETZM   CURPPN          ;MARK AS NO CURRENT FILE
        POPJ    P,              ;RETURN FROM TRCL

CPOPJ2: AOS     (P)             ;RETURN TWO SKIPS
CPOPJ1: AOS     (P)             ;RETURN +1
CPOPJ:: POPJ    P,              ;RETURN

DIRROU::PUSHJ   P,REWWAI        ;*REWIND THE TAPE - THIS MAY NOT BE RIGHT
        TLO     F,DIRFLG+IGNFLG ;DIR CMD - IGNORE FILES FOR A WHILE
        AOS     DIRSSC          ;WORKING ON FIRST SAVE SET
        PUSHJ   P,HEADIN        ;READ IN HEADER
DIR1:   PUSHJ   P,TAPIN         ;INPUT A RECORD FROM TAPE
        ERO     [XWD [DIR1],[ASCIZ "NO FILE HEADER FOUND.$_E"]]
        JRST    .+3(R1)         ;TRAILER=-1, HEADER=0, DIR=1
        ERO     [XWD [DIR1],[ASCIZ "NO FILE HEADER FOUND BEFORE DATA.$_E"]]
        JRST    DIR4            ;FOUND TRAILER SO WE'RE DONE
        ERO     [XWD [DIRNSS],[ASCIZ "HEADER FOUND IN MIDDLE OF TAPE.$_E"]]
DIR2A:  ERO     [XWD [CURPPN
                CURPPN],[ASCIZ "$DIRECTORY FOR _A  _K$"]]
        TLZ     F,IGNFLG        ;NO FILES IGNORED
DIR2:   ERO     [XWD [TAPHED],[ASCIZ "_M$"]]
DIR3:   PUSHJ   P,TAPIN         ;IGNORE DATA
        JRST    DIR1            ;EOF - DONE WITH THIS USER
        JRST    .+3(R1)         ;TRAILER=-1, HEADER=0, DIR=1
        JRST    DIR3            ;IGNORE DATA
        JRST    DIR4            ;FOUND TRAILER SO WE'RE DONE
        ERO     [XWD [DIRNSS],[ASCIZ "HEADER FOUND IN MIDDLE OF TAPE.$_E"]]
        JRST    DIR2            ;DIRECTORY - START NEXT FILE
DIR4:   TLO     F,IGNFLG        ;IGNORE FILES FOR A WHILE
        TLNE    F,EOTFND        ;SKIP IF END OF TAPE NOT FOUND
        JRST    DIREOT          ;*LOGICAL END OF TAPE
        PUSHJ   P,TAPIN         ;READ EOF AFTER TRAILER
        JRST    DIR4A           ;READ EOF
        JRST    .+3(R1)         ;TRAILER=-1, HEADER=0, DIR=1
        ERO     [XWD [DIR1],[ASCIZ "NO FILE HEADER FOUND BEFORE DATA.$_E"]]
        ERO     [XWD [DIR4],[ASCIZ "FOUND TWO TRAILER BLOCKS IN A ROW.$_E"]]
        JRST    DIRNSS          ;MISSED AN EOF BUT LET'S NOT WORRY
        ERO     [XWD [DIR2A],[ASCIZ "FILE HEADER FOUND WITHOUT TAPE HEADER.$_E"]]
DIR4A:  PUSHJ   P,TAPIN         ;READ THE NEXT RECORD
        JRST    DIREOT          ;LOGICAL END OF TAPE
        JRST    .+3(R1)         ;TRAILER=-1, HEADER=0, DIR=1
        ERO     [XWD [DIR1],[ASCIZ "NO FILE HEADER FOUND BEFORE DATA.$_E"]]
        ERO     [XWD [DIR4],[ASCIZ "FOUND TWO TRAILER BLOCKS IN A ROW.$_E"]]
        JRST    DIRNSS          ;PROCESS NEXT SAVE SET
        ERO     [XWD [DIR2A],[ASCIZ "FILE HEADER FOUND WITHOUT TAPE HEADER.$_E"]]
DIRNSS: AOS     R2,DIRSSC       ;INCREMENT THE SAVE SET COUNT
        ERO     [XWD [DIRSSC],[ASCIZ "$$$THIS IS SAVE SET NUMBER _C"]]
        CAIL    R2,12           ;DON'T PRINT DECIMAL IF LESS THAN TEN
        TYPE    [ASCIZ " (DECIMAL)"]
        PUSHJ   P,DIRHED        ;FINISH PROCESSING HEADER
        JRST    DIR1            ;PRINT THE SAVE SET
        JRST    DIR1+1          ;IN CASE DIRHED RETURNS SKIPPING
        JRST    DIR1+2          ;IN CASE DIRHED RETURNS SKIPPING
        JRST    DIR1+3          ;IN CASE DIRHED RETURNS SKIPPING
DIREOT: TLNE    F,CTDFLG        ;SKIP IF NOT CONTINUED AT EITHER END
        PUSHJ   P,EOTMSG        ;PRINT END OF TAPE MESSAGES
        TLNN    F,CTDFLG        ;SKIP IF CONTINUED AT EITHER END
        TYPE    [ASCIZ "NO SAVE SETS FOLLOW.$"]
        PUSHJ   P,REWTAP        ;REWIND THE TAPE
        JRST    CDISP           ;RETURN TO COMMAND DISPATCHER

SKITRM::MOVEM   R0,SKICNT#      ;SAVE THE SKIP COUNT
        TLO     F,IGNFLG        ;IGNORE ALL FILES
        PUSHJ   P,SETIN         ;SET TAPE FOR INPUT
SKITIN: PUSHJ   P,TAPIN         ;READ A RECORD
        JRST    SKITIN          ;IGNORE END OF FILE
        JRST    .+3(R1)         ;TRAILER=-1, HEADER=0, DIR=1
        JRST    SKITIN          ;IGNORE DATA
        JRST    SKITRL          ;TRAILER
        JRST    SKITIN          ;IGNORE HEADER
        JRST    SKITIN          ;IGNORE DIRECTORIES
SKITRL: PUSHJ   P,TAPIN         ;READ EOF FOLLOWING TRAILER
        JRST    .+3             ;EOF - CONTINUE
        JUMP                    ;TRAILER, HEADER, OR DIR - ERROR
        ERROR   [ASCIZ "END OF FILE NOT FOUND AFTER TRAILER"]
        SOSG    SKICNT          ;DECREMENT COUNT AND SKIP IF NOT DONE
        JRST    CDISP           ;RETURN TO COMMAND DISPATCHER
        PUSHJ   P,TAPIN         ;READ EOF OR HEADER AFTER LAST EOF
        JRST    SKIEOT          ;END OF TAPE
        JRST    SKITIN          ;PROBABLY HEADER SO CONTINUE LOOPING
        JRST    SKITIN          ;SHOULDN'T BE DATA HERE BUT IGNORE IT
SKIEOT: MTAPE   TAP,17          ;BACKSPACE OVER LAST EOF
        MTAPE   TAP,0           ;WAIT FOR OPERATION TO COMPLETE
        TYPE    [ASCIZ "NOW POSITIONED AT LOGICAL END OF TAPE."]
        JRST    CDISP           ;RETURN TO COMMAND DISPATCHER

QUIROU::CALLI   RESET           ;TERMINATE ALL I/O
        EXIT                    ;RETURN TO EXEC
RWNROU::PUSHJ   P,REWTAP        ;REWIND THE TAPE
        JRST    CDISP           ;RETURN TO COMMAND DISPATCHER
REWROU::PUSHJ   P,REWWAI        ;REWIND THE TAPE AND WAIT
        JRST    CDISP           ;RETURN TO COMMAND DISPATCHER

REWTAP: MTAPE   TAP,1           ;REWIND WITHOUT WAIT FOR COMPLETION
        TLZ     F,EOTFND        ;NOT AT END OF TAPE
        TLO     F,BOTFLG        ;AT BEGINNING OF TAPE
        SETZM   DIRSSC#         ;NO SAVE SETS FOUND YET
        POPJ    P,              ;RETURN FROM REWTAP
REWWAI: PUSHJ   P,REWTAP        ;REWIND THE TAPE
        MTAPE   TAP,0           ;WAIT FOR REWIND TO FINISH
        POPJ    P,              ;RETURN FROM REWWAI

HEADIN: PUSHJ   P,SETIN         ;INSURE BUFFERS
        PUSHJ   P,TAPIN         ;READ FIRST RECORD
NOHDRF: ERO     [XWD [CPOPJ],[ASCIZ "NO HEADER FOUND.$_E"]]
        JRST    .+3(R1)         ;TRAILER=-1, HEADER=0, DIR=1
        JRST    NOHDRF          ;DATA RECORD FOUND
        JRST    NOHDRF          ;TRAILER FOUND
        SKIPA                   ;HEADER
        JRST    CPOPJ2          ;DIR - FAKE RETURN NEXT INST
DIRHED: MOVE    R2,TAPHED       ;WHERE THE HEADER IS
        HLRE    R0,2(R2)        ;XWD HEADER FLAG,INTERNAL WORD COUNT
        JUMPLE  R0,NOHDRF       ;INSIST ON HEADER FLAG (VERSION #)
        ERO     [XWD [FIRBL2
                FIRBL3],[ASCIZ "$FAILSAFE TAPE _C RECORDED _L$"]]
        MOVE    R1,5(R2)        ;GET TAPE CONTINUE BIT
        MOVEI   R2,[ASCIZ ""]  ;NULL STRING
        TLNE    R1,TAPCTD       ;SKIP IF NOT A CONTINUATION TAPE
        MOVEI   R2,[ASCIZ "THIS IS A CONTINUATION TAPE.$"]
        TLNE    R1,USRCTD       ;SKIP IF USER NOT CONTINUED
        MOVEI   R2,[ASCIZ "USER CONTINUED FROM PRECEDING TAPE.$"]
        TLNE    R1,FILCTD       ;SKIP IF FILE NOT CONTINUED
        MOVEI   R2,[ASCIZ "FILE CONTINUED FROM PRECEDING TAPE.$"]
        TYPE    (R2)            ;TYPE THE MESSAGE SELECTED ABOVE
        PUSHJ   P,TAPIN         ;INPUT A RECORD
        POPJ    P,              ;EOF - RETURN FROM HEADIN OR DIRHED
        JRST    .+3(R1)         ;TRAILER=-1, HEADER=0, DIR=1
NOEOFF: ERO     [XWD [CPOPJ],[ASCIZ "EOF NOT FOUND AFTER HEADER._E"]]
        JRST    NOEOFF          ;TRAILER - NO EOF FOUND
        ERO     [XWD [DIRHED],[ASCIZ "TWO HEADERS READ._E"]]
        JRST    CPOPJ2          ;FAKE RETURN FROM INST BELOW HEADIN/DIRHED CALL
EOTMSG: ERO     [XWD [FIRBL2
                FIRBL3],[ASCIZ "$END OF FAILSAFE TAPE _C RECORDED _L$"]]
        MOVE    R2,FIRBL3       ;GET CONTINUATION BITS FROM TRAILER
        MOVEI   R1,[ASCIZ "NO CONTINUATION TAPES FOLLOW.$"]
        TLNE    R2,TAPCTD       ;SKIP IF NO CONTINUATION TAPES FOLLOW
        MOVEI   R1,[ASCIZ "CONTINUATION TAPES FOLLOW.$"]
        TLNE    R2,USRCTD       ;SKIP IF USER NOT CONTINUED
        MOVEI   R1,[ASCIZ "USER IS CONTINUED ON THE NEXT TAPE.$"]
        TLNE    R2,FILCTD       ;SKIP IF FILE NOT CONTINUED
        MOVEI   R1,[ASCIZ "FILE IS CONTINUED ON THE NEXT TAPE.$"]
        TYPE    (R1)            ;TYPE THE APPROPRIATE MESSAGE
        POPJ    P,              ;RETURN FROM EOTMSG

;*ADD APPENDIX E ERROR CODES FOR UUO ERRORS
GETROU::SKIPA   R1,[0]          ;GET ROUTINE
RESROU::HRREI   R1,-1           ;RESTORE ROUTINE
        MOVEM   R1,GETFLG#      ;FLAG TO DISTINGUISH BETWEEN GET AND RESTORE
        TLZ     F,STOFLG+DIRFLG ;THIS IS NOT A STORE OR A DIRECTORY
        TLO     F,IGNFLG        ;IGNORE FILES FOR A WHILE
CONRES: PUSHJ   P,HEADIN        ;READ IN HEADER AND PRINT INFO
UNSLU5: PUSHJ   P,TAPIN         ;GET 1ST RECORD OF NEXT FILE
        ERROR   [ASCIZ "NO TRAILER FOUND BEFORE LOGICAL END OF TAPE"]
        JRST    .+3(R1)         ;TRAILER=-1, HEADER=0, DIR=1
        ERROR   [ASCIZ "DATA RECORD FOUND WITH NO DIRECTORY"]
        JRST    TAPEND          ;TRAILER
HEDERR: ERROR   [ASCIZ "HEADER FOUND IN MIDDLE OF TAPE"]
;*      MOVE    R1,FILDI1       ;DIR
;*      MOVEM   R1,UFDDI2
UNSLU1: MOVE    R2,TAPHED       ;GET ADDRESS OF CURRENT BUFFER
        MOVE    U,5(R2)         ;GET PPN
        HLRZ    R1,7(R2)        ;GET THE EXTENSION
        CAMN    U,SYSPP         ;SKIP IF NOT USER 1,1 (UFD)
        CAIE    R1,(SIXBIT /UFD/)
        SKIPA                   ;NOT A UFD IN 1,1
        JRST    SETST1          ;MAKE SURE THE UFD IS SET UP
        PUSHJ   P,CKNPPN        ;SEE IF THIS PPN SHOULD BE RESTORED
        JRST    UNSLU3          ;IGNORE THIS USER
        MOVE    R2,TAPHED       ;GET ADDRESS OF CURRENT BUFFER
        MOVE    U,6(R2)         ;GET FILE NAME
        HLRZ    W,7(R2)         ;GET EXTENSION
        PUSHJ   P,CKNFIL        ;SKIP IF THIS FILE SHOULD BE RESTORED
        JRST    UNSLU3          ;IGNORE THIS FILE
        SKIPN   STRBLK          ;SKIP IF FILE IS SPLIT
        JRST    UNSLU4          ;JUST RESTORE FILE
        MOVE    R1,CURPPN       ;GET PPN FROM TAPE
        CAME    R1,STRPPN       ;SKIP IF PPN OF SPLIT FILE
UNSLU6: ERO     [XWD [STRPPN    ;*BACKWARDS EXTENSION
                CURPPN
                CLDSP],[ASCIZ "LOOKING FOR _J ON TAPE, BUT FOUND _J._E"]]
        MOVE    R1,CURFIL       ;GET FILE NAME FROM TAPE
        CAME    R1,STRFIL       ;SKIP IF NAME OF SPLIT FILE
        JRST    UNSLU6          ;ERROR
        HLRZ    R1,CUREXT       ;GET EXTENSION FROM TAPE
        CAME    R1,STREXT       ;SKIP IF EXTENSION OF SPLIT FILE
        JRST    UNSLU6          ;ERROR
        ERO     [XWD [STRBLK
                CURPPN],[ASCIZ "CONTINUING WITH BLOCK _C OF FILE _J.$"]]
        SETZM   STRPPN          ;ZERO STARTING PPN
        SETZM   STRFIL          ;ZERO STARTING FILE
        SETZM   STREXT          ;ZERO STARTING EXTENSION
UNSLU4: PUSHJ   P,XFER          ;MOVE A USER FILE FROM TAPE TO DISK
        JRST    UNSLU5          ;EOF - NEXT USER
        JRST    UNSLU1          ;GET NEXT FILE FOR THIS USER
        JRST    TAPEND          ;HANDLE END OF TAPE

UNSLU3: TLO     F,IGNFLG        ;IGNORE THIS FILE
        PUSHJ   P,TAPIN         ;INPUT A RECORD FROM TAPE
        JRST    UNSLU5          ;EOF - TRY NEXT USER
        JRST    .+3(R1)         ;TRAILER=-1, HEADER=0, DIR=1
        JRST    UNSLU3          ;DATA - IGNORE IT
        JRST    TAPEND          ;TRAILER - HANDLE END OF TAPE
        JRST    HEDERR          ;HEADER
        JRST    UNSLU1          ;DIR - TRY THIS FILE

SETST1: TLNN    F,UFDFLG        ;SKIP IF JL ST WF LIC SET
        JRST    UNSLU3          ;NOT ENOUGH LICENSE TO EXECUTE CODE
        MOVEM   U,UFDDI1        ;SAVE PPN FOR UFD LOOKUPS
        MOVE    U,6(R2)         ;GET PPN FOR THIS USER
        PUSHJ   P,CKNPPN        ;SKIP IF USER SHOULD BE SET UP
        JRST    UNSLU3          ;IGNORE THIS UFD
        INIT    UFD,BUFBIN
        SIXBIT  /DSK/
        XWD     0,UFDHED        ;LOOKUPS ONLY
        ERROR   [ASCIZ "CANNOT ACCESS THE DISC."]
        MOVEI   R1,UFDBUF       ;USE THE UFD BUFFERS
        MOVEM   R1,JOBFF        ;TELL MONITOR WHERE TO PUT THE BUFFERS
        INBUF   UFD,UFDN        ;SET UP THE BUFFERS
        MOVEI   R1,XLOOKN       ;SET SPECS FOR LOOKUP
        MOVEM   R1,UFDDIR
        MOVEM   U,UFDDI2        ;SAVE PPN AS NAME OF FILE (UFD)
        HRLZI   R1,(SIXBIT /UFD/);EXT=UFD
        MOVEM   R1,UFDDI3
        MOVEM   U,UFDBL2        ;SAVE THE PPN FOR INTERLOCK
        MOVE    R2,TAPHED       ;GET ADDR OF CURRENT BUFFER
        MOVE    R1,3(R2)        ;GET THE STRUCTURE
        SETZ    R2,             ;ZERO TO GET FIRST ENTRY ON SEARCH LIST
        SYSSTR  R2,             ;GET NEXT STRUCTURE ON LIST
        SETZ    R2,             ;ERROR RETURN SO FALL THROUGH BELOW
        CAME    R1,R2           ;SKIP IF THIS IS THE RIGHT STRUCTURE
        JUMPN   R3,.-2          ;LOOP IF NOT DONE WITH LIST
        JUMPN   R2,.+3          ;JUMP IF WE FOUND THE STRUCTURE
        SYSSTR  R2,             ;GET FIRST STRUCTURE ON THE LIST AS DEFAULT
        ERROR   [ASCIZ "CANNOT FIND A VALID FILE STRUCTURE."]
        MOVEM   R2,UFDBL1       ;SAVE STRUCTURE FOR INTERLOCK
        PUSHJ   P,SETJL         ;SET THE JL BIT
        ERROR   [ASCIZ "UNABLE TO SET JACCT-LOGIN BIT."]
        PUSHJ   P,SETINT        ;SET THE UFD INTERLOCK
        ERO     [XWD [UFDBL2
                SETST3],[ASCIZ "UNABLE TO SET UFD INTERLOCK FOR _A.$_E"]]
        LOOKUP  UFD,UFDDIR      ;DOES THIS UFD ALREADY EXIST?
        JRST    FIXUFD          ;NO, MAKE ONE LIKE THE ORIGINAL
SETST2: PUSHJ   P,RESINT        ;RESET THE UFD INTERLOCK
        ERO     [XWD [UFDBL2],[ASCIZ "UNABLE TO RESET UFD INTERLOCK FOR _A.  SOMETHING IS WRONG.$"]]
SETST3: PUSHJ   P,RESJL         ;RESET THE JACCT-LOGIN BIT
        ERROR   [ASCIZ "UNABLE TO RESET THE JACCT-LOGIN BIT."]
        JRST    UNSLU3          ;SKIP TO NEXT UFD OR FILE

;MAKE A UFD ON THIS STR WITH QUOTA FROM THE TAPE
;*PERHAPS THIS SHOULD NOT BE DONE

FIXUFD: MOVE    R2,TAPHED       ;GET ADDR OF CURRENT BUFFER
        MOVSI   R1,2(R2)        ;START OF SPECS IN TAPBUF
        HRRI    R1,UFDDIR       ;SPEC AREA
        BLT     R1,UFDDIR+XLOOKN
        SETZM   URBPOS          ;CLR SPECIAL ITEMS
        SETZM   URBNXT
        SETZM   URBPRD
        INIT    MFD,BUFBIN
        SIXBIT  /DSK/
        XWD     MFDHED,0
        ERROR   [ASCIZ "UNABLE TO ACCESS MFD"]
        MOVEI   R1,UFDDIR
        HRLI    R1,4(R2)
        BLT     R1,UFDDIR+XLOOKN;RESTORE SPECS AFTER LOOKUP
        SETZM   URBCSZ          ;ZERO CURRENT SIZE SINCE NO FILES
        ENTER   MFD,UFDDIR      ;CREATE THIS UFD
        ERROR   [ASCIZ "UNABLE TO OUTPUT TO MFD"]
        USETO   MFD,2           ;MAKE ALL UFDS AT LEAST ONE BLOCK LONG
        CLOSE   MFD,DNC         ;CLOSE THE MFD
        RELEAS  MFD,            ;RELEASE THE MFD
        CLOSE   UFD,DNC         ;CLOSE UFD
        JRST    SETST2          ;CLEAR JACCT AND UFD INTERLOCK & GET NEXT UFD

RESJL:  TDZA    R2,R2           ;SET TO ZERO AND ALWAYS SKIP
SETJL:  MOVSI   R2,1            ;SET THE JACCT-LOGIN BIT
        MOVSI   R1,-1           ;GET BITS FOR THIS JOB
        GETTAB  R1,             ;GET BITS SO WE DON'T DESTROY THEM
        ERROR   [ASCIZ "CANNOT DO A GETTAB FOR THIS JOB."]
        TLZ     R1,1            ;ASSUME WE'RE RESETING THE BIT
        TLNE    R2,1            ;SKIP IF BIT SHOULD BE RESET
        TLO     R1,1            ;SET THE BIT
        CALLI   R1,-21          ;FIX THE JAL BIT (SETJAL)
        POPJ    P,              ;NOT ENOUGH LICENSE - FAIL RETURN
        JUMPN   R2,CPOPJ1       ;SUCCESS RETURN FROM SETJL
        HRROI   R1,-24          ;GET TERMINAL BITS
        GETTAB  R1,             ;WE WANT TO KNOW IF PHONE WAS HUNG UP
        SETZ    R1,             ;DETACHED, SO PHONE WAS NOT HUNG
        TLNE    R1,200000       ;SKIP IF PHONE NOT HUNG UP
        EXIT                    ;GET OUT OF PROG AND MONITOR WILL LOGOUT
        JRST    CPOPJ1          ;SUCCESS RETURN FROM RESJL

RESINT: SKIPA   R1,[7]          ;RESET UFD INTERLOCK
SETINT: MOVEI   R1,6            ;  SET UFD INTERLOCK
        MOVEM   R1,UFDBLK       ;SAVE THE FUNCTION TO BE PERFORMED
        MOVEI   R2,550          ;NUMBER OF TIMES TO TRY
RTRINT: MOVE    R1,[XWD 3,UFDBLK];POINTER TO PARAMETER TABLE
        STRUUO  R1,             ;TEST AND SET/RESET UFD INTERLOCK
        SKIPA                   ;FAILED - TRY AGAIN IN ONE SECOND
        JRST    CPOPJ1          ;SUCCESS RETURN FROM SETINT/RESINT
        MOVEI   R1,1            ;NUMBER OF SECONDS TO SLEEP
        SLEEP   R1,             ;DISMISS FOR A SECOND
        SOJG    R2,RTRINT       ;RETRY THE INTERLOCK
        POPJ    P,              ;FAIL RETURN FROM SETINT/RESINT

TAPEND: CLOSE   FIL,DNC         ;DON'T CHANGE ACCESS OR DEALOCATE
        RELEASE FIL,
        CLOSE   UFD,DNC
        RELEASE UFD,
        PUSHJ   P,PRTT          ;PRINT TOTALS FOR THIS TAPE AND SAVE SET
        MOVE    R2,TAPHED       ;GET ADDRESS OF CURRENT BUFFER
        SKIPL   5(R2)           ;CONTINUED?
        ERO     [XWD [CDISP],[ASCIZ "$RESTORE COMPLETED._E"]]
        PUSHJ   P,EOTMSG        ;PRINT END OF TAPE MESSAGES
        TLNN    R2,FILCTD       ;SKIP IF FILE SPLIT
        SETZM   BLKCNT          ;NOT SPLIT SO ZERO BLOCK COUNT
        TLNN    R2,FILCTD       ;SKIP IF FILE SPLIT
        SETZM   OLDBLK          ;NOT SPLIT SO ZERO OLD BLOCK COUNT
        PUSHJ   P,SETSTR        ;SET UP STARTING PARAMETERS
        PUSHJ   P,REWTAP        ;REWIND OLD TAPE
        PUSHJ   P,NXTTAP        ;GET THE NEXT TAPE MOUNTED
        JRST    CONRES          ;START RESTORING NEXT TAPE

XFER:   MOVE    R2,TAPHED       ;WHERE TAPE BUFFER IS
        SETZM   BLKCNT          ;ZERO THE BLOCK COUNT
        SKIPN   GETFLG          ;SKIP IF NOT A GET COMMAND
        SETZM   5(R2)           ;ZERO PPN TO RESTORE TO THIS USER
XFER3:  MOVE    R2,TAPHED       ;GET ADDRESS OF CURRENT BUFFER
        MOVSI   R1,4(R2)        ;
        HRRI    R1,FILDIR
        BLT     R1,FILDIR+XLOOKN
        SETZM   FRBPOS          ;DON'T WORRY ABOUT TRACKS AND CYLINDERS
        SETZM   FRBNXT          ;RESERVED FOR FUTURE USE
        MOVE    R1,FRBALC       ;GET NUMBER OF ALLOCATED BLOCKS
        SETZM   FRBALC          ;DON'T NEED STORAGE IN ONE BIG BLOCK
        MOVEM   R1,FRBEST       ;GET THE STORAGE IN ANY WAY POSSIBLE
        MOVEI   R1,XLOOKN+2     ;REMOVE HEADER WORDS FROM BEGINNING OF FILE
        ADDM    R1,TAPHD1
        MOVNI   R1,XLOOKN+2
        ADDM    R1,TAPHD2
        INIT    FIL,BUFBIN
        SIXBIT  /DSK/
        XWD     FILHED,0
        ERROR   [ASCIZ "DISC NOT AVAILABLE"]
        MOVEI   R1,FILBUF
        MOVEM   R1,JOBFF
        OUTBUF  FIL,FILN
        PUSHJ   P,CKLIC
        SKIPE   STRBLK          ;SKIP IF FILE NOT SPLIT
        JRST    XFER4           ;OPEN FILE IN UPDATE MODE ETC
        HRLZI   R1,RCHGBT       ;GET THE RIB CHANGED BIT
        ANDCAM  R1,FRBNCA       ;MARK THE FILE AS NOT DUMPED
        ENTER   FIL,FILDIR
        ERO     [XWD [XFER3D],[ASCIZ "UNABLE TO ENTER FILE.$_E"]]
        MOVE    R1,FILDI3       ;GET OLD/NEW BIT FOR THIS FILE
        TRNE    R1,400000       ;SKIP IF NEW FILE
        JRST    XFER3A          ;SEE IF HE REALLY WANTS TO WRITE FILE
XFER3C: AOS     TAPHD2          ;ADJUST FOR SOSG ENTERED FROM ABOVE
XFER2:  TLZ     F,IGNFLG        ;DON'T IGNORE THIS FILE
        SOSLE   TAPHD2          ;GET A WORD FROM TAPE
        JRST    XFER2A          ;SOME THERE ALREADY
        PUSHJ   P,TAPIN
        JRST    XFER2C          ;EOF
        JRST    XFER2D+1(R1)    ;-1=TRAILER, 0=HEADER, 1=DIR
XFER2A: ILDB    R1,TAPHD1
        SOSLE   FILHD2          ;STASH INTO USER FILE
        JRST    XFER2B          ;DISC BUFFER NOT YET FULL
        OUT     FIL,            ;OUTPUT THE FILE
        AOSA    BLKCNT          ;SUCCESSFUL - INCREMENT COUNT OF BLOCKS
        ERO     [XWD [CURPPN],[ASCIZ "ERROR IN WRITING TO DISC FILE _J.  CONTINUING...$"]]
                                ;*MARK FILE AS BAD
XFER2B: IDPB    R1,FILHD1
        JRST    XFER2           ;TRY AGAIN

XFER2D: AOSA    (P)             ;SKIP TWICE TO TRAILER
        ERROR   [ASCIZ "$HEADER FOUND IN MIDDLE OF TAPE."]
        AOS     (P)             ;SKIP RETURN FOR DIRECTORY
XFER2C: CLOSE   FIL,DNC         ;CLOSE THE FILE
        POPJ    P,              ;RETURN FROM XFER
XFER3A: CLOSE   FIL,RST         ;CLOSE FILE AND KEEP IT OUT OF DIR
;*      MOVE    R1,COUT##       ;GET COMMAND FILE FLAG
;*      MOVEM   R1,XFCOUT#      ;SAVE IN TEMP CELL
;*      SETZM   COUT            ;TERMINAL OUTPUT
        MOVE    R1,FILDI1       ;GET PPN FOR THIS FILE
        LDB     R2,MOPTR##      ;GET MODE FOR DSK FILES
        CAMN    R1,[XWD 1,4]    ;SKIP IF NOT SYS FILE
        LDB     R2,MSYPTR##     ;GET MODE FOR SYS FILES
        CAIN    R2,MOMDIS##     ;DON'T SKIP IF WE SHOULD KEEP DISC FILE
        JRST    XFER3E          ;KEEP DISC FILE
        CAIN    R2,MOMTAP##     ;DON'T SKIP IF WE SHOULD KEEP TAPE FILE
        JRST    XFER3B          ;RESTORE FILE FROM TAPE
        CAIN    R2,MOMNEW##     ;DON'T SKIP IF WE SHOULD KEEP NEWEST FILE
        JRST    XFER3N          ;KEEP NEWEST FILE
        ERO     [XWD [CURPPN
        XFR3B1],[ASCIZ "_J ALREADY EXISTS. OK TO WRITE OVER IT? _F_G"]]
        SKIPA                   ;DON'T PRINT THE IGNORE MESSAGE
XFER3E: ERO     [XWD [CURPPN],[ASCIZ "NOT WRITING OVER FILE _J.$"]]
XFER3D: TLO     F,IGNFLG        ;IGNORE THIS FILE
        PUSHJ   P,TAPIN         ;SKIP TO NEXT FILE ON TAPE
        POPJ    P,              ;EOF - RETURN
        JRST    .+3(R1)         ;-1=TRAILER, 0=HEADER, 1=DIR
        JRST    .-3             ;IGNORE DATA
        AOSA    (P)             ;SKIP TWICE FOR TRAILER
        JRST    HEDERR          ;SHOULDN'T FIND HEADER HERE
        JRST    CPOPJ1          ;SKIP RETURN FOR DIR
XFER3B: ERO     [XWD [CURPPN],[ASCIZ "WRITING OVER FILE _J.$"]]
XFR3B1: ENTER   FIL,FILDIR      ;DO THE ENTER AGAIN
        ERO     [XWD [XFER3D],[ASCIZ "UNABLE TO ENTER FILE.$_E"]]
        JRST    XFER3C          ;CONTINUE AS USUAL
XFER4:  LOOKUP  FIL,FILDIR      ;OPEN FILE FOR INPUT
        ERO     [XWD [CURPPN
                CLDSP],[ASCIZ "CANNOT FIND _J ON DISC._E"]]
        MOVE    R1,FRBSIZ       ;GET SIZE OF FILE IN WORDS
        LSH     R1,-7           ;DIVIDE BY 128 FOR SIZE IN BLOCKS
        AOJ     R1,             ;ADD ONE FOR PARTIALLY FULL LAST BLK
        CAME    R1,STRBLK       ;SKIP IF BLOCK NUMBERS AGREE
        ERO     [XWD [CURPPN
                FRBSIZ
                STRBLK
                CLDSP],[ASCIZ "FILE _J IS THE WRONG SIZE.$IT CONTAINS _C WORDS.  IT SHOULD CONTAIN _C BLOCKS._E"]]
        ENTER   FIL,FILDIR      ;DO AN ENTER FOR UPDATE MODE
        ERO     [XWD [CURPPN
                CLDSP],[ASCIZ "CANNOT DO ENTER ON FILE _J._E"]]
        USETI   FIL,STRBLK      ;POSITION TO STARTING BLOCK
        MOVE    R1,STRBLK       ;GET STARTING BLOCK NUMBER
        MOVEM   R1,OLDBLK       ;SAVE OLD STARTING BLOCK NUMBER
        SETZM   STRBLK          ;ZERO THE STARTING BLOCK
        JRST    XFER3C          ;CONTINUE WITH FILE TRANSFER

XFER3N: MOVE    R1,FILDI4       ;GET CREATION DATE FROM TAPE FILE
        MOVEM   R1,CRTION       ;SAVE CREATION DATE
        LOOKUP  FIL,FILDIR      ;DO LOOKUP ON DISC FILE
        ERO     [XWD [CURPPN
                XFER3B],[ASCIZ "UNABLE TO LOOKUP FILE _J.$_E"]]
        CLOSE   FIL,DNC         ;CLOSE FILE AGAIN AND DON'T CHANGE ACCESS
        MOVE    R1,FILDI4       ;GET CREATION DATE OF DSK FILE
        MOVE    R2,CRTION       ;ET CREATION DATE OF TAP FILE
        ANDI    R1,7777         ;THROW AWAY ALL BUT DATE BITS
        ANDI    R2,7777         ;THROW AWAY ALL BUT DATE BITS
        CAMLE   R1,R2           ;DON'T SKIP IF DSK NEWER
        JRST    XFER3E          ;DON'T RESTORE FILE
        CAME    R1,R2           ;SKIP IF DATES EQUAL
        JRST    XFER3B          ;RESTORE THE FILE FROM TAPE
        MOVE    R1,FILDI4       ;GET CREATION DATE FROM DSK FILE
        MOVE    R2,CRTION       ;GET CREATION DATE FROM TAP FILE
        AND     R1,[XWD 37,770000] ;THROW AWAY ALL BUT TIME BITS
        AND     R2,[XWD 37,770000] ;THROW AWAY ALL BUT TIME BITS
        CAML    R1,R2           ;SKIP IF TAPE FILE NEWER
        JRST    XFER3E          ;DON'T RESTORE FILE
        JRST    XFER3B          ;RESTORE THE FILE FROM TAPE

SPRTU:  SKIPA   R1,[MSPTR]      ;GET POINTER FOR STORE MODE
RPRTU:  MOVEI   R1,MRPTR        ;GET POINTER FOR RESTORE MODE
        SKIPN   FILCNT          ;SKIP IF FILES TRANSFERED FOR USER
        POPJ    P,              ;RETURN FROM SPRTU/RPRTU
        LDB     R1,(R1)         ;GET BYTE FOR STORE OR RESTORE
        TLNN    F,DIRFLG        ;SKIP IF DIRECTORY CMD AND PRINT USER TOT
        TRNE    R1,2            ;SKIP IF USER NAMES SHOULD NOT BE PRINTED
        ERO     [XWD [LSTPPN
                FILCNT],[ASCIZ "_A  _C FILES.$$"]]
        MOVE    R1,FILCNT       ;GET NUMBER OF FILES FOR THIS USER
        SETZM   FILCNT          ;ZERO NUMBER OF FILES FOR NEXT USER
        ADDM    R1,TOTCNT       ;ADD TO TOTAL FOR THIS SAVE SET
        POPJ    P,              ;RETURN FROM SPRTU/RPRTU

PRTT:   SKIPN   TOTCNT          ;SKIP IF SOME FILES TRANSFERED
        POPJ    P,              ;RETURN FROM PRTT WITHOUT PRINTING
        ERO     [XWD [TOTCNT],[ASCIZ "TOTAL _C FILES.$$"]]
        SETZM   TOTCNT          ;ZERO THE TOTAL
        POPJ    P,              ;RETURN FROM PRTT

CKLIC:  HRRZ    R1,FRBNCA       ;GET LICENSE THE FILE HAD
        JUMPE   R1,CPOPJ        ;RETURN FROM CKLIC IF NO LICENSE
        MOVEM   R1,CKLICT       ;SAVE THE DESIRED LICENSE
        MOVE    R1,JBLIC        ;GET LICENSE OF CURRENT JOB
        MOVEM   R1,CKLICT+1     ;SAVE JOB'S LICENSE
        MOVE    R2,TAPHED       ;ADDR OF CURRENT BUFFER
        SKIPE   R1,5(R2)        ;SKIP IF FILE'S PPN IS ZERO (GET CMD)
        XOR     R1,JBPPN        ;EXCLUSIVE OR OF JOB AND FILE PPNS
        MOVEM   R1,CKLICT+2     ;SAVE XOR OF PPNS
        MOVEI   R1,CKLICT       ;ADDR OF TABLE
        HRLI    R1,3            ;BIT 17 FOR LIC FROM TAB/BIT 16 FOR FILE
        CALLI   R1,-31          ;CHKLIC - RETURN ALLOWABLE LICENSE
        CAMN    R1,CKLICT       ;SKIP IF NOT ALL LICENSE ALLOWABLE
        ERO     [XWD [CURPPN
                CKLICT
                CPOPJ],[ASCIZ "FILE _J GIVEN LICENSE _H.$_E"]]
        HLLZS   R1,FRBNCA       ;ZERO THE LICENSE
        ERO     [XWD [CURPPN
                CKLICT],[ASCIZ "FILE _J NOT GIVEN LICENSE _H.$"]]
        POPJ    P,              ;RETURN FROM CKLIC

;PPNUSR CONVERTS A PPN TO A USER NAME BY LOOKING IN THE DUL
;  CALL WITH PPN IN R0
;  NON-SKIP RETURN IF USER NAME NOT FOUND. R0 PRESERVED IN THIS CASE
;  SKIP RETURN IF USER NAME FOUND.  USER NAME RETURNED IN R0 & R1
;  ALL REGISTERS OTHER THAN R0 & R1 ARE PRESERVED.

PPNUSR::TLNN    F,DULFLG        ;SKIP IF THE DUL HAS BEEN OPENED
        PUSHJ   P,GETDUL        ;TRY TO OPEN THE DUL
        TLNN    F,DULFLG        ;SKIP IF THE DUL HAS BEEN OPENED
        POPJ    P,              ;FAIL RETURN FROM PPNUSR
        PUSH    P,R2            ;SAVE R2 IN STACK
        PUSH    P,R3            ;SAVE R3 IN STACK
        PUSHJ   P,FINPPN        ;FIND PPN IN THE DUL AND RET USR NAME
        SKIPA                   ;ERROR RETURN  USER NAME NOT FOUND
        AOS     -2(P)           ;SKIP RETURN WHEN WE RETURN
        POP     P,R3            ;RESTORE R3 FROM STACK
        POP     P,R2            ;RESTORE R2 FROM STACK
        POPJ    P,              ;RETURN USER NAME IN R0 AND R1

FINPPN: MOVE    R3,R0           ;SAVE PPN IN R3
        IDIVI   R0,^D101        ;DIVIDE BY 101 FOR BLOCK NUMBER
        ADDI    R1,1            ;REMAINDER PLUS ONE IS BLOCK NUMBER
PPN3:   USETI   DUL,@R1         ;SET FILE TO INPUT AT PROPER BLOCK
        INPUT   DUL,DULLST      ;INPUT THE BLOCK
        STATZ   DUL,760000      ;SKIP IF NO ERRORS
        ERROR   [ASCIZ "ERROR IN DUL.$"]
        SETZ    R2,             ;INITIALIZE INDEX TO ZERO
        MOVE    R0,R3           ;RESTORE PPN IN R0 IN CASE OF FAILURE
PPN1:   SKIPN   DULBLK(R2)
        POPJ    P,              ;FAIL RETURN FROM PPNUSR
        HRRZ    R1,DULBLK(R2)
        SKIPG   DULBLK(R2)
        JRST    PPN3
        MOVE    R0,DULBLK+1(R2) ;GET 1ST HALF OF NAME IN CASE WE'RE DONE
        MOVE    R1,DULBLK+2(R2) ;GET 2ND HALF OF NAME IN CASE WE'RE DONE
        CAMN    R3,DULBLK(R2)
        JRST    CPOPJ1          ;SUCCESS RETURN FROM PPNUSR
        MOVE    R0,R3           ;RESTORE PPN IN R0 IN CASE OF FAILURE
        ADDI    R2,3
        CAIGE   R2,200
        JRST    PPN1            ;LOOP
        POPJ    P,              ;FAIL RETURN FROM PPNUSR

;USRPPN CONVERTS A USER NAME TO A PPN
;  CALL WITH USER NAME IN R0 AND R1
;  SKIP RETURN WITH PPN IN R0 IF SUCCESSFUL
;  NON-SKIP RETURN IN UNSUCCESSFUL
;  R1, R2, AND R3 ARE NOT PRESERVED. R0 NOT PRESERVED ON FAILURE
USRPPN::TLNN    F,LUDFLG        ;SKIP IF THE LUD HAS BEEN OPENED
        PUSHJ   P,GETLUD        ;TRY TO OPEN THE LUD
        TLNN    F,LUDFLG        ;SKIP IF THE LUD HAS BEEN OPENED
        POPJ    P,              ;FAIL RETURN FROM USRPPN
        PUSHJ   P,HASHER        ;HASH THE USER NAME
        PUSHJ   P,FINNAM        ;FIND NAME IN LUD
        POPJ    P,              ;FAIL RETURN
        MOVE    R0,LUDBLK(R2)   ;GET PPN
        JRST    CPOPJ1          ;RETURN PPN IN R0

;RETURN IF NOT FOUND
;RETURN+1 IF NOT FOUND BUT USER WAS THERE(DELETED IN LUD)
;RETURN+2 IF FOUND
TYP1:   SKIPN   R1,LUDBLK(R2)
        POPJ    P,              ;FAIL RETURN FROM USRPPN
FINNAM: USETI   LUD,@R1
        INPUT   LUD,LUDLST
        STATZ   LUD,760000
        ERROR   [ASCIZ "ERROR IN LUD.$"]
        SETZ    R2,
TYP3:   JUMPLE  R1,TYP1
        CAMN    R0,LUDBLK+4(R2)
        JRST    CPOPJ1          ;SUCCESS RETURN FROM USRPPN
        LDB     R1,[POINT 7,LUDBLK+2(R2),35]
        ADD     R2,R1
        JRST    TYP3

HASHER: PUSH    P,HA
        PUSH    P,HB
        PUSH    P,HC
        PUSH    P,HD
        PUSH    P,HE
        MOVEI   HB,0
        MOVE    HC,[555555555555]
        MOVE    HD,[361275431652]
        MOVE    HE,[612754316523]
        PUSHJ   P,RND
        PUSHJ   P,RND
        PUSHJ   P,RND
        PUSHJ   P,RND
        XOR     HE,HD
        MOVE    R0,HE
        TLZ     R0,400000
        IDIVI   R0,^D887
        MOVE    R0,HE
        XOR     R0,HC
        ADDI    R1,1
        POP     P,HE
        POP     P,HD
        POP     P,HC
        POP     P,HB
        POP     P,HA
        POPJ    P,
RND:    ADD     HD,R0
        ROTC    R0,-22
        MOVEI   HA,5
RND1:   MOVE    R2,HC+1(HB)
        MUL     R2,[5*5*5*5*5*5*5*5*5*5*5*5*5*5*5]
        ADDM    R3,HD+1(HB)
        AOJE    HB,RND2
        MOVNI   HB,1
        TRNE    HD,1
        SKIPL   HE
        MOVEI   HB,0
        EXCH    HC,HE
RND2:   SOJG    HA,RND1
        POPJ    P,

GETLUD: OPEN    LUD,LUDTAB      ;INIT THE DEVICE SYS
        ERROR   [ASCIZ "CANNOT ACCESS SYS.$"]
        LOOKUP  LUD,LOKLUD      ;LOOKUP THE LUD
        POPJ    P,              ;FAIL RETURN FROM GETLUD
        TLO     F,LUDFLG        ;MARK LUD AS OPENED
        POPJ    P,              ;SUCCESS RETURN FROM GETLUD

LUDTAB: XWD     0,17            ;DUMP MODE
        SIXBIT  /SYS/           ;DEVICE SYS
        0                       ;NO BUFFERS

LOKLUD: SIXBIT  /LUD/           ;FILE NAME
        SIXBIT  /SYS/           ;EXTENSION
        0
        0

        0
LUDLST: IOWD    200,LUDBLK      ;BUFFER
        0
LUDBLK: BLOCK   200

GETDUL: OPEN    DUL,DULTAB      ;INIT THE DEVICE SYS
        ERROR   [ASCIZ "CANNOT ACCESS SYS.$"]
        LOOKUP  DUL,LOKDUL      ;LOOKUP THE DUL
        POPJ    P,              ;FAIL RETURN FROM GETDUL
        TLO     F,DULFLG        ;MARK DUL AS OPENED
        POPJ    P,              ;SUCCESS RETURN FROM GETDUL

DULTAB: XWD     0,17            ;DUMP MODE
        SIXBIT  /SYS/           ;DEVICE SYS
        0                       ;NO BUFFERS

LOKDUL: SIXBIT  /DUL/           ;FILE NAME
        SIXBIT  /SYS/           ;EXTENSION
        0
        0

        0
DULLST: IOWD    200,DULBLK      ;BUFFER
        0
DULBLK: BLOCK   200

;BUFFER HEADERS

TAPHED: BLOCK   3               ;MAGTAP INPUT OR OUTPUT BUFFER HEADER**2
TAPHD1= TAPHED+1
TAPHD2= TAPHED+2 

MFDHED: BLOCK   3               ;DISK MFD BUFFER HEADER**2
MFDHD1= MFDHED+1
MFDHD2= MFDHED+2

UFDHED: BLOCK   3               ;DISK UFD BUFFER HEADER**2
UFDHD1= UFDHED+1
UFDHD2= UFDHED+2

FILHED: BLOCK   3               ;DISK USER FILE BUFFER HEADER**2
FILHD1= FILHED+1
FILHD2= FILHED+2

COFHED::BLOCK   3               ;OUTPUT FILE
COFHD1=:COFHED+1
COFHD2=:COFHED+2

CHKHED: BLOCK   3               ;DATE CHECK FILE HEADER
LUDHED: BLOCK   3               ;LOCAL USER DIRECTORY HEADER
DULHED: BLOCK   3               ;INVERSE LUD HEADER

;MTA HEADER BLOCK
FIRBLK: XWD     VERSION,4       ;WD0=XWD HEADER FLAG,BLK WDCT
        SIXBIT  /*FAILS/        ;WD1
FIRBL2: SIXBIT  /AFE   /        ;WD2=XWD SIXBIT "AFE",TAPE SEQ#
                                ;NEGATIVE TAPE SEQ# MEANS TRAILER
FIRBL3: EXP     0               ;WD3=TAPCTD BIT (B0), USRCTD BIT (B1)
                                ;    CRTIME (B13-23), CRDATE (B24-35)
        XWD     1,2             ;WD4=FAILSAFE PROJ,PROG #

SYSPP:  XWD     1,1

STRPPN::0                       ;STARTING PPN
STRFIL::0                       ;STARTING FILE
STREXT::0                       ;STARTING EXTENSION
STRBLK::0                       ;STARTING BLOCK
STRUSR: BLOCK   2               ;STARTING USER NAME
CURPPN::0                       ;CURRENT PPN
CURFIL: 0                       ;CURRENT FILE NAME
CUREXT: 0                       ;CURRENT EXTENSION
LSTPPN: 0                       ;LAST PPN
LSTFIL: 0                       ;LAST FILE NAME
LSTEXT: 0                       ;LAST EXTENSION

UFDBLK: 0                       ;FUNCTION FOR UFD INTERLOCK
UFDBL1: 0                       ;STRUCTURE FOR UFD INTERLOCK
UFDBL2: 0                       ;PPN FOR UFD INTERLOCK

CREDAT::0                       ;CREATION DATE - DAYS SINCE 1964
CRETIM::0                       ;CREATION TIME - SECONDS LSH 12
CRTION: 0                       ;CREATION DATE AND TIME FROM UFD
CHANGD::0                       ;NON-ZERO IF CHECKING FOR CHANGED FILES
FILCNT::0                       ;NUMBER OF FILES TRANSFERED FOR THIS USER
TOTCNT::0                       ;NUMBER OF FILES TRANSFERED FOR THIS SAVE SET
CKLICT: BLOCK   3               ;TABLE FOR CHKLIC UUO

;LOOKUP & ENTER SPECS
                                ;EXT LOOKUP     -    OLD LOOKUP
MFDDIR: 0                       ;0,XLOOKN       -     FILNAM
MFDDI1: 0                       ;PPN            -     EXT.,ACC.DAT.
        0                       ;FILNAM         -     PROT,MODE,CREAT
MFDDI3: 0                       ;EXT.,ACC.DAT.   -    PPN
        0                       ;PROT,MODE,CREAT
        BLOCK   XLOOKN+MFDDIR-.

UFDDIR: 0                       ;0,XLOOKN       -     FILNAM
UFDDI1: 0                       ;PPN            -     EXT.,ACC.DAT.
UFDDI2: 0                       ;FILNAM         -     PROT,MODE,CREAT
UFDDI3: 0                       ;EXT.,ACC.DAT.   -    PPN
        0                       ;PROT,MODE,CREAT
        BLOCK   5               ;--NEVER TOUCH--
URBPOS: 0                       ;--CLR BEFORE RESTORE--
URBNXT: 0                       ;   "    "       "
URBPRD: 0                       ;   "    "       "
        BLOCK   10
URBCSZ: BLOCK   1               ;CURRENT SIZE
        BLOCK   XLOOKN+UFDDIR-. ;---NEVER TOUCH ON SAVE OR RESTORE--

FILMRK: XWD     -1,XLOOKN+2     ;FILE HEADER (MUST PRECEDE CURSTR)
FILDM1: SIXBIT  /DSK/   ;CURRENT FILE STRUCTURE (MUST PRECEDE FILDIR)
FILDIR: 0                       ;0,XLOOKN       -     FILNAM
FILDI1: 0                       ;PPN            -     EXT.,ACC.DAT.
FILDI2: 0                       ;FILNAM         -     PROT,MODE,CREAT
FILDI3: 0                       ;EXT.,ACC.DAT.   -    PPN
FILDI4: 0                       ;PROT,MODE,CREAT
FRBSIZ: 0                       ;FILE SIZE IN WORDS
        BLOCK   2               ;--NEVER TOUCH--
FRBEST: 0                       ;ESTIMATED SIZE OF FILE
FRBALC: 0                       ;# OF BLKS NEEDED
FRBPOS: 0                       ;--CLR BEFORE RESTORE--
FRBNXT: 0                       ;   "    "       "
FRBNCA: 0                       ;   "    "       " (DUMPED BIT)/LICENSE
        0                       ;
        0
FRBSTS: 0                       ;FILE STATUS WORD
        BLOCK   XLOOKN+FILDIR-.
;MISCELLANEOUS DATA

MFDSPK: BUFBIN
        SIXBIT  /DSK/           ;MUST BE MFDSPK+1
IOBUF:  0                       ;OBUF,IBUF FOR MFD - MUST BE MFDSPK+2

        VAR                     ;MISC. VARIABLES

;I/O BUFFERS

MFDBUF: BLOCK   MFDN*DSKSIZ     ;BUFFERS FOR MFD
UFDBUF: BLOCK   UFDN*DSKSIZ     ;BUFFERS FOR UFD
CHKBUF: BLOCK   CHKN*DSKSIZ     ;DATE CHECK FILE BUFFER
FILBUF: BLOCK   FILN*DSKSIZ     ;BUFFERS FOR USER FILE
TAPBUF: BLOCK   TAPN*TAPSIZ
LUDBUF: BLOCK   LUDN*DSKSIZ
DULBUF: BLOCK   DULN*DSKSIZ
        END     START
    i