FIND ERRET:, %GOSUB, STATUS, %CLRIN
GLOBAL %STGRAB, %GRAB, %ADDON, %UNGRAB, %SETSIZE, %NXTLOC
GLOBAL %UNWIND, %RBASE, %RSIZE, %GROOM, FLOATER(), %CHKSTA
GLOBAL %FMATCH,%AMBIG,%ERROR,%DCTERR,%OPEND, %TERROR
GLOBAL %GARB,%YESNO, %SHOVER, %TRANID, %NEW.DBLK, %COP.DBLK
GLOBAL %XPUTC,%XPUT,%XMSG,%EXTRAN,%EXTERR, %READID
GLOBAL %IXPUT, %IXPUTC, %PNUM, %SPACER, %RDLINE, %QSAVE
GLOBAL %IXMSG, ITELFN, OTELFN, QPTR, QBUFF(0:100), SAVPTR, LINPTR
GLOBAL FECHO, %MATERR, %RNUM, %FINDER, %FORMAT, %PRINTER
GLOBAL %ADDSUB, %RECFND, %READER, %SET.CORE.FILE, %SETREC
GLOBAL %EXOPEND, %WRT.REC
LOCAL %CHECK2

DEF TRUE AS 0
DEF FALSE AS -1

%FMATCH ( STAB(), STLEN, @SPTR, PFLAG, SFLAG, MFLAG )
!
! STAB - TABLE OF STRING. RIGHT HALF OF EACH ENTRY IS WORD
!        ADDRESS OF STRING TERMINATED WITH EOLIT.
! STLEN - NUMBER OF ENTRIES IN STAB.
! SPTR - STRING POINTER DEFINING INPUT TEST STRING.
! PFLAG - IF >= 0 THEN PRINT APPROPRIATE ERROR MESSAGES FOR
!         ERRORS.
! SFLAG - IF NEGATIVE THEN LFET HALF OF EACH ENTRY POINTS TO
!         STATUS WORD TO BE CHECKED AGAINST "STATUS".
! MFLAG - IF NEGATIVE, THEN MUST USE ALL OF LOGICAL LINE
!         MAKING MATCH.
LOCAL MX, CNT, SAVE, I, INPTR, TPTR, IPTR, LCNT, INLIN
FIND STATUS

MX_0
INLIN_SPTR
SAVE _ -2

FOR I_0 TO STLEN-1 DO
  INPTR_INLIN
  TPTR_CHPT(OCT 777777 BAND STAB(I),-1)
  CNT_0

  IF SFLAG >= 0 OR STATUS BAND ^BYT( STAB(I), 18, 18) # 0 THEN LOOP DO
    IPTR_INPTR

    LOOP WHILE NCHV IPTR=$ 
    WHILE CHV IPTR # EOLIT
    PCHV IPTR

    LOOP WHILE NCHV TPTR = $ 
    PCHV TPTR

    LCNT_0
    WHILE EOLIT # NCHV IPTR # $ AND NCHV TPTR = CHV IPTR THEN INC LCNT

    WHILE CHV IPTR = $ OR CHV IPTR = EOLIT
    PCHV IPTR
    INPTR_IPTR
    CNT+_LCNT

    LOOP WHILE EOLIT # NCHV TPTR # $ 
    PCHV TPTR
  END

  EIF CNT = MX > 0 THEN SAVE _ -1
  FIF CNT > MX THEN DO
    MX _ CNT; SPTR _ INPTR
    IF MFLAG < 0 AND CHV IPTR = $  THEN LOOP WHILE NCHV IPTR = $ 
    IF MFLAG >= 0 OR CHV IPTR = EOLIT THEN SAVE _ I ELSE SAVE _ -3
  END
END

IF SAVE >= 0 OR PFLAG < 0 THEN RETURN SAVE
MATERR(SAVE,INLIN,SPTR)
RETURN SAVE
END FMATCH

%MATERR (SAVE,INLIN,SPTR)
DO -SAVE OF 1:3
1: AMBIG(INLIN,SPTR)
2: GARB(INLIN)
3: EXTERR(SPTR,1)
END
RETURN
END MATERR


%GARB (SPTR)
LOOP WHILE NCHV SPTR = $ 
PCHV SPTR
SPACER(-1); IXMSG ("CANNOT RECOGNIZE ")
IXPUT($")
WHILE EOLIT # NCHV SPTR # $ THEN IXPUTC(CHV SPTR)
IXPUT($")
IXPUT(CARRET)
CLRIN
RETURN
END GARB


%AMBIG (SPTR,EPTR)
SPACER(-1); IXPUT($")
WHILE SPTR # EPTR THEN IXPUTC(NCHV SPTR)
IXPUT($")
IXMSG(" IS AMBIGOUS$")
CLRIN
RETURN
END AMBIG




%TERROR (MESS, FLAG)
IXMSG(MESS)
CLRIN
IF FLAG <= 0 THEN RETURN ELSE GO ^FLAG
END TERROR

%ERROR ( MESS )
TERROR (MESS, ERRET)
END ERROR

%IXMSG(MESS)
XMSG(MESS)
IF ITELFN = TEL AND OTELFN # TEL THEN MSG(MESS)
RETURN
END IXMSG




%STGRAB
DEF STL AS 10000
LOCAL BUFF(0:STL+1), UPPTR, DNPTR, TMP1, TMP2
LOCAL %CHECK1


UPPTR _ 0
DNPTR _ STL+1
BUFF(STL+1) _ 0
RETURN

%%GRAB (NWORDS)
IF NWORDS < 0 THEN ERROR ("NEGATIVE GRAB LENGTH$")
CHECK1(NWORDS)

FLOATER _ @BUFF(UPPTR)
BUFF(TMP1 _ DEC DNPTR) _ [18,18]*[UPPTR <== UPPTR + NWORDS, NWORDS]
RETURN [FLOATER; TMP1]


%%UNGRAB (ID)
ID _ CHECK2(ID)

IF ID # DNPTR THEN DO
  SETSIZE(ID,0)
  BUFF(ID) _ BUFF(ID) BOR OCT 777777
  RETURN
END

IF DNPTR > STL THEN ERROR("GRAB BUFF UNDERFLOW$")
LOOP DO
  INC DNPTR
  WHILE DNPTR < STL+1
  WHILE BYT( BUFF(DNPTR), 18, 0) = OCT 777777
END
[18,18]*[TMP1,TMP2] _ BUFF(DNPTR)
FLOATER _ @BUFF(TMP1)
UPPTR _ TMP1+TMP2
RETURN


%%UNWIND (ID)
ID _ CHECK2(ID)
[18,18]*[TMP1,TMP2] _ BUFF(ID)
FLOATER _ @BUFF(TMP1)
UPPTR _ TMP1+TMP2
DNPTR _ ID
RETURN [FLOATER; ID]


%%NXTLOC
RETURN (UPPTR)


%%RBASE (ID)
ID _ CHECK2(ID)
RETURN @BUFF( BYT( BUFF(ID), 18, 18) )


%SETSIZE (ID, NWORDS)
NWORDS _ NWORDS - RSIZE(ID)


%%ADDON (ID, NWORDS)
LOCAL NUMBER.OF.WORDS, SOURCE, DESTINATION
DEF I AS TMP1

ID _ CHECK2(ID)
IF NWORDS = 0 THEN RETURN RBASE(ID)+RSIZE(ID)

IF ID # DNPTR THEN DO
  CHECK1(NWORDS)

  [18,18]*[TMP1,TMP2] _ BUFF(ID)
  IF TMP2 + NWORDS < 0 THEN ERROR("CORE BLOCK LENGTH WENT NEGATIVE$")
  OFF.ALT

  IF NUMBER.OF.WORDS _ UPPTR - (TMP1+TMP2) # 0 THEN DO
    EIF NWORDS < 0 THEN DO
      SOURCE _ @BUFF(TMP1+TMP2)
      DESTINATION _ SOURCE + NWORDS
      MOVE NUMBER.OF.WORDS FROM SOURCE TO DESTINATION
     END

    ELSE DO
      SOURCE _ @BUFF(UPPTR)
      DESTINATION _ SOURCE + NWORDS
      REPEAT NUMBER.OF.WORDS  ^(DEC DESTINATION) _ ^(DEC SOURCE)
     END
  END

  UPPTR + _ NWORDS
  FOR I _ DNPTR TO ID-1  BYT(BUFF(I),18,18) _ BYT(BUFF(I),18,18)+NWORDS
  FLOATER _ @BUFF(BYT(BUFF(DNPTR),18,18))
  BUFF(ID) + _ NWORDS
  ON.ALT
  RETURN RBASE(ID)+RSIZE(ID)-NWORDS
END


CHECK1(NWORDS)

IF DNPTR > STL THEN ERROR ("ADDON WITH NO CORE BLOCKS DEFINED$")
[18,18]*[TMP1,TMP2] _ BUFF(DNPTR)
IF TMP2 + _ NWORDS < 0 THEN ERROR("CORE BLOCK LENGTH WENT NEGATIVE$")
BUFF(DNPTR) _ [18,18]*[TMP1, TMP2]
RETURN [@BUFF(UPPTR <== UPPTR + NWORDS); DNPTR]
END SETSIZE


%RSIZE (ID)
ID _ CHECK2(ID)
[18,18]*[TMP1,TMP2] _ BUFF(ID)
RETURN [TMP2;ID]
END RSIZE


%CHECK1 (NWORDS)
IF NWORDS > GROOM THEN ERROR ("GRAB BUFF OVERFLOW$")
RETURN
END CHECK1



%CHECK2 (ID)
IF ID <= 0 THEN ID _ DNPTR
IF ID > STL OR ID < DNPTR OR BYT( BUFF(ID), 18, 0) = OCT 777777 &
  THEN ERROR("ILLEGAL CORE BLOCK ID$")
RETURN ID
END CHECK2


%GROOM
RETURN DNPTR-UPPTR-2
END GROOM


END STGRAB


%YESNO ( MESS, HMESS )
TABLE YN(0:1)["YES","NO"]
RDLINE(MESS, HMESS,  2, 1)
LOOP DO
  DO FMATCH(YN,2,@LINPTR,-1,0,-1)+3 OF 0:4
  0: 1: 2: CLRIN
  RDLINE("PARDON? ",HMESS,2,1)
  3: RETURN 0
  4: RETURN -1
  END
END
END YESNO

%XPUTC (CHAR)
IF OTELFN = TEL THEN PUTC (CHAR) ELSE W(OTELFN,CHAR)
RETURN
END XPUTC

%XPUT (CHAR)
IF OTELFN = TEL THEN PUT(CHAR) ELSE W(OTELFN,CHAR)
RETURN
END XPUT

%IXPUT (CHAR)
XPUT(CHAR)
IF ITELFN = TEL AND OTELFN # TEL THEN PUT(CHAR)
RETURN
END IXPUT

%IXPUTC (CHAR)
XPUTC(CHAR)
IF ITELFN = TEL AND OTELFN # TEL THEN PUTC(CHAR)
RETURN
END IXPUTC

%XMSG (MESS)
LOCAL MPTR
IF OTELFN = TEL THEN [MSG(MESS); RETURN]
MPTR _ CHPT(MESS,-1)
WHILE NCHV MPTR # EOLIT THEN W(OTELFN,(IF CHV MPTR = $$ THEN CARRET &
  ELSE CHV MPTR))
RETURN
END XMSG

%EXTERR (TPTR,IFLAG)

IXMSG("$EXTRANEOUS INPUT: ")
IXPUT($")
WHILE NCHV TPTR # EOLIT THEN IXPUTC(CHV TPTR)
IF IFLAG = 2 THEN IF SAVPTR # 0  THEN &
  WHILE NCHV SAVPTR # CARRET THEN IXPUTC(CHV SAVPTR)
IXPUT($")
IXPUT(CARRET)
CLRIN
RETURN
END EXTERR

%EXTRAN
LOCAL CHAR

LOOP WHILE NCHV LINPTR = $ 
CHAR _ CHV LINPTR
PCHV LINPTR
IF CHAR = EOLIT THEN RETURN (IF SAVPTR = 0 THEN 2 ELSE 1) ELSE RETURN 0
END EXTRAN

%PNUM (NUMBER,XBASE)
LOCAL NSTG(0:5),NPTR,TPTR,DIGIT,RSTG(0:5)

TPTR _ CHPT(RSTG,-1)
NPTR _ CHPT(NSTG,-1)
NCHV NPTR _ EOLIT
IF NUMBER < 0 THEN [NCHV TPTR _ $-; NUMBER _ -NUMBER]
LOOP DO
  [NUMBER;DIGIT] _ NUMBER DIVMOD XBASE
  NCHV NPTR _ DIGIT + $0
  WHILE NUMBER # 0
END
LOOP DO
  NCHV TPTR _ CHV NPTR
  WHILE PCHV NPTR # EOLIT
END
RETURN RSTG
END PNUM

%SPACER( IFLAG )
FIND LAT.LEV
REPEAT LAT.LEV*2  IF IFLAG = 0 THEN XPUT($ ) ELSE IXPUT($ ) 
RETURN
END SPACER

%RDLINE (PMESS, HMESS, STRFLG, ENDFLG )
!
!  PMESS - ADDRESS OF INPUT REQUEST MESSAGE OR <= 0 IF NONE.
!  HMESS - ADDRESS OF HELP MESSAGE OR <= 0 IF NONE.
!  STRFLG - 2 = LINE MUST START ON REAL LINE BOUNDARY.
!           1 = LINE MUST START ON LOGICAL BOUNDARY.
!           0 = DON'T CARE.
!  ENDFLG - 1 = NO MULTIPLE LINES (NO SEMI-COLONS).
!           0 = DON'T CARE
!
! QBUFF IS PRINTED AS START OF INPUT REQUEST MESSAGE.
!
LOCAL VAL, RVAL, TPTR, LP:, %RLINE

NCHV QPTR _ EOLIT; QPTR _ CHPT(QBUFF,-1)

IF VAL _ EXTRAN # 2 THEN IF VAL >= STRFLG THEN GO LP ELSE &
  EXTERR(LINPTR,STRFLG)

LOOP DO
  SPACER(-1); IXMSG(QBUFF); IF PMESS > 0 THEN IXMSG(PMESS)
LP: TPTR _ RVAL _ RLINE
  EIF (HMESS <= 0 OR NCHV TPTR # $?) AND (ENDFLG = 0 OR SAVPTR = 0) &
    THEN RETURN RVAL
  ORIF (HMESS > 0 AND CHV TPTR = $?) THEN [IXMSG(HMESS); PUT(CARRET)]
  ELSE IXMSG("ILLEGAL SEMI-COLON$")
  CLRIN
END
%RLINE
GLOBAL RLC:, TB(0:103)
DEF PTR2 AS LINPTR
LOCAL PTR1, %XGETLIN

IF NCHV PTR2 # EOLIT THEN [PCHV PTR2; RETURN PTR2]

RLC: PTR1 _ (IF SAVPTR # 0 THEN SAVPTR ELSE XGETLIN )
SAVPTR _ PTR2 _ CHPT(TB,-1)

WHILE CARRET # NCHV PTR1 # $; THEN &
      NCHV PTR2 _ (IF CHV PTR1 = LNFEED THEN $  ELSE CHV PTR1)
NCHV PTR2 _ EOLIT
RETURN PTR2 _ SAVPTR <== (IF CHV PTR1 = $; THEN PTR1 ELSE 0)
%%SET.CORE.FILE (LINE() )
LOCAL OPTR, NPTR, %SKIP

EIF NCHV LINPTR = EOLIT THEN DO
  LINPTR _ CHPT( TB, -1)
  OPTR _ (IF SAVPTR = 0 THEN LINPTR ELSE SKIP(SAVPTR) )
END
ELSE [OPTR _ SKIP(LINPTR); PCHV LINPTR]

NPTR _ CHPT( LINE, -1)

LOOP DO
  NCHV OPTR _ NCHV NPTR
  WHILE CHV OPTR # EOLIT
  XPUT(CHV OPTR)
END

IF PCHV OPTR # CARRET THEN XPUT(CARRET)

RETURN


%XGETLIN (FN)
LOCAL GPTR, TPTR1, TPTR2
GLOBAL LINBUF(0:51)
TPTR1 _ GPTR _ GETLINE( ITELFN )
IF (OTELFN # TEL OR ITELFN # TEL) AND FECHO = 0 THEN &
  XMSG( BYT( GPTR, 18, 0 ) + 1 )
TPTR2 _ CHPT(LINBUF,-1)
LOOP WHILE NCHV TPTR2 _ NCHV TPTR1 # EOLIT
RETURN GPTR
END XGETLIN


%SKIP( PTR )
LOOP WHILE NCHV PTR # EOLIT
RETURN PCHV PTR
END SKIP

END RLINE

END RDLINE

%QSAVE (MESS)
LOCAL TPTR
TPTR _ CHPT(MESS,-1)
WHILE NCHV TPTR # EOLIT THEN NCHV QPTR _ CHV TPTR
RETURN
END QSAVE

%RNUM (XBASE)
LOCAL NUM, CHAR
NUM _ 0
LOOP WHILE NCHV LINPTR = $ 
PCHV LINPTR
LOOP DO
  WHILE $0 <= CHAR _ NCHV LINPTR <= $9
  NUM _ (NUM * XBASE) + (CHAR - $0)
END
PCHV LINPTR
RETURN NUM
END RNUM

%DCTERR
FIND FCNVL1, DCTER1(1), DCTER2(1), DCTER3(1)
EIF FCNVL1 > 0 THEN IXMSG(DCTER3(FCNVL1))
ORIF FCNVL1 > -100 THEN IXMSG(DCTER1(-FCNVL1))
ELSE IXMSG(DCTER2(-FCNVL1-100))
RETURN
END DCTERR

%OPEND (DNAME, IO, ON, WCNT)
!  IO - 0 = INPUT
!       1 = OUTPUT
!       2 = UPDATE
!  ON - 0 = OLD
!       1 = NEW
!       2 = DON'T CARE
TABLE IOT(0:2)[INPUT,OUTPUT,UPDATE]
TABLE IOT2(0:2)[1,-1,-1]
TABLE ONT(0:2)[OLD,NEW,0]
LOCAL FNUM, PBLK(), OPERR:, ERR:, EVAL, AFLG, BID, OFFSET
FIND %SETUP, %SLEEP, ERRNUM, STATUS, SYSTAT, PBLEN, FILERR(1)
FIND %CREATE

BID _ 0; AFLG _ 0

%%EXOPEND (DNAME, IO, ON, BID, AFLG, WCNT)
!  BID - CORE ID OF CORE BLOCK TO USE FOR PBLK
!  AFLG - 0 = ADDON, OTHERWISE, SETSIZE

LOOP DO
  LOOP DO
    REPEAT 10
    FNUM _ OPEN(DNAME, DIRECT+IOT(IO)+ONT(ON), OPERR)
    EIF AFLG = 0 THEN DO
      PBLK _ ADDON(BID, @PBLEN)
    END
    ELSE DO
      SETSIZE(BID, @PBLEN)
      PBLK _ RBASE(BID)
    END
    OFFSET _ PBLK - RBASE(BID)
    HW( @PBLK, 0) _ CHECK2(BID)
    EVAL _ ( IF IO = 1 THEN &
     CREATE(FNUM, ERR, ERR, FNUM, PBLK, IOT2(IO), @PBLEN, WCNT, OFFSET)&
     ELSE SETUP(FNUM, ERR, ERR, FNUM, PBLK, IOT2(IO), @PBLEN, OFFSET))
    IF EVAL # 0 AND STATUS BAND SYSTAT # 0 THEN DCTERR
    RETURN FNUM
    OPERR: WHILE ERRNUM = FBSERR
    SLEEP(5)
  END
  IXMSG("$ERROR OPENING FILE - ")
  IXMSG(DNAME)
  IXMSG(FILERR(ERRNUM))
  IF ERRNUM # FBSERR THEN GO ERRET
  CLRIN
  IF YESNO("TRY AGAIN? ","IF YOU WANT TO CONTINUE TRYING TO OPEN &
THE FILE, TYPE YES.$OTHERWISE, TYPE NO.") = -1 THEN GO ERRET
END

ERR: DCTERR; GO ERRET

END OPEND

%READID (MESS, HELPM, RCNT)
! THIS ROUTINE READS IN DICTIONARY NAME, RECORD NAME, AND
! FIELD NAME COMBINATIONS.
!
! RCNT IDENTIFIES HOW MANY OF THESE THINGS YOU NEED -
!  1 = DICTIONARY NAME
!  2 = DICTIONARY NAME, RECORD NAME
!  3 = DICTIONARY NAME, RECORD NAME, FIELD NAME.
!
! THE STRINGS FOR EACH OF THESE IS STORED INTO THE FLOATING ARRAY
! DBLOCK.
!
! THE STRINGS ARE ENTERED ON SEPARATE LOGICAL LINES (USING SEMI-COLONS).
! THE FIRST STRING MAY APPEAR ON THE COMMAND LINE (AS IN 
! "FETCH TRANSACTION").
!
! THE USER MAY OMIT STRINGS IF THEY ARE DEFINED IN DBLOCK.
! THAT IS TO SAY, IF THE APPROPRIATE ENTRY IN DBLOCK IS NOT ZERO.
! WHEN THE USER OMITS STRINGS, HIS STRINGS ARE ASSIGNED IN SUCH A
! WAY AS TO ALWAYS ASSIGN HIS LAST STRING TO THE LAST THING YOU
! REQUESTED. FOR EXAMPLE, IF YOU REQUESTED ALL THREE ITEMS AND
! THE USER ONLY ENTERED ONE THEN IT WOULD BE CONSIDERED TO BE
! A FIELD NAME.
!

LOCAL LCNT, SPTR, I, BUFF(0:51), CNT
FIND DBLOCK()

TABLE FNAME(1:3)["DICTIONARY NAME.$","RECORD ID.$","FIELD ID.$"]
DEF ST AS 1


! CHECK FOR QUESTION MARK FOR TRIGGERING HELP MESSAGE.
LOOP DO
  LOOP WHILE NCHV LINPTR = $ 
  WHILE CHV LINPTR = $?
  PCHV LINPTR
  RDLINE(MESS, HELPM, 0, 0)
END

! IF THERE IS STILL ANYTHING LEFT, COUNT IT AS ONE INPUT STRING.
LCNT _ (IF CHV LINPTR = EOLIT THEN 0 ELSE 1)
PCHV LINPTR

! COUNT THE OTHER LOGICAL LINES
IF SAVPTR # 0 THEN DO
  SPTR _ SAVPTR
  LOOP DO
    LOOP WHILE $; # NCHV SAVPTR # CARRET
    INC LCNT
    WHILE CHV SAVPTR # CARRET
  END
  IF LCNT > RCNT THEN ERROR("EXTRANEOUS INPUT$")
  SAVPTR _ SPTR
END

! CHECK TO SEE IF THE REQUESTED BUT UNSUPPLIED ITEMS ARE DEFINED.
FOR I _ 1 TO (RCNT-LCNT)  IF DBLOCK(LOCTAB(I)) = 0 THEN DO
  IXMSG("INSUFFICIENT IDENTIFICATION. MISSING ")
  IXMSG(FNAME(I))
  GO ERRET
END

! READ ALL THE STRINGS INTO THE APPROPRIATE PLACES.
FOR I _ (RCNT-LCNT+1) TO RCNT DO
  CNT _ 1
  RDLINE(0,0,0,0)
  SPTR _ CHPT(BUFF,-1)
  LOOP WHILE NCHV LINPTR = $ 
  PCHV LINPTR
  WHILE NCHV SPTR _ NCHV LINPTR # EOLIT THEN INC CNT
  PCHV LINPTR
  SHOVER(I, BUFF, 0, (CNT+4)/5, 0)
END
RETURN

%SHOVER (ITEM, SOURCE, DONT.ZERO, NWORDS, STABLE, OFFSET)
! ITEM NUMBERS -
!    1 - DICTIONARY NAME
!    2 - RECORD NAME
!    3 - FIELD NAME
!     4 - DICTIONARY FORMAT AND FILE NAME
!    5 - RECORD ID
!    6 - FIELD ID
!    7 - RECORD BLOCK
FIND DBLOCK()

DEF VERS AS 0
DEF CORE.ID AS 1
DEF CSTRT AS 10

TABLE DEFTAB(1:LEN)[OCT 0705040271, OCT  070571, OCT 0670, OCT 70, &
                 0, 0, OCT 70]

LOCAL TMP1, TMP2, CNT, I, CPTR, FRAY(), NW, WCNT

IF TMP2 _ (TMP1 _ DEFTAB(ITEM)) BAND OCT 77 = OCT 71 THEN &
   INC DBLOCK(VERS)

IF TMP2 = 0 THEN NWORDS _ 0

DBLOCK(LOCTAB(ITEM)) _ 0
IF DONT.ZERO = 0 THEN DO
  WHILE TMP2 _ (TMP1 _ TMP1 SHR 6) BAND OCT 77 # 0 THEN &
    DBLOCK(LOCTAB(TMP2)) _ 0
END

WCNT _ CSTRT+NWORDS
FOR I _ 1 TO LEN  IF DEFTAB(I) BAND OCT 77 # 0 THEN &
   WCNT + _ BYT(DBLOCK(LOCTAB(I)),18,18)

GRAB(WCNT)
FOR I _ 0 TO WCNT-1  FLOATER(I) _ 0

FLOATER(VERS) _ DBLOCK(VERS)
FLOATER(CORE.ID) _ DBLOCK(CORE.ID)

CPTR _ CSTRT
FOR I _ 1 TO LEN  IF I = ITEM OR DBLOCK(LOCTAB(I)) # 0 THEN DO

  EIF DEFTAB(I) BAND OCT 77 = 0 THEN FLOATER(LOCTAB(I)) _ &
    (IF I = ITEM THEN SOURCE ELSE DBLOCK(LOCTAB(I)))

  ELSE DO
    EIF I = ITEM THEN DO
      FRAY _ (IF STABLE = 0 THEN SOURCE ELSE RBASE(SOURCE)+OFFSET)
      NW _ NWORDS
     END
    ELSE DO
      [18,18]*[NW,TMP1] _ DBLOCK(LOCTAB(I))
      FRAY _ @DBLOCK(TMP1)
    END
    MOVE NW FROM FRAY TO @FLOATER(CPTR)
    FLOATER(LOCTAB(I)) _ [18,18]*[NW,CPTR]
    CPTR + _ NW
  END

END
OFF.ALT
SETSIZE(DBLOCK(CORE.ID),WCNT)
MOVE WCNT FROM FLOATER TO DBLOCK
ON.ALT
UNGRAB(-1)

RETURN

END SHOVER

%TRANID (RCNT)
DEF DGRAB AS DOUBLE GRAB

LOCAL ITEM, DUM, BID, TID, TRAY(), BP(0:1), ERR:, FNUM
FIND %FNDID, DNOFF, RDCT(1), FDCT(1), %CHREAD


IF DBLOCK(LOCTAB(DFORM)) = 0 THEN DO
  ITEM _ DNAM
  GRAB(0)
  FNUM _ OPEND(RDCT, 0, 0)
  FNDID(FNUM, ERR, ERR, FADD(DNAM), -1, BP)
  [TRAY; TID] _ DGRAB(BP(1))
  CHREAD(FNUM, ERR, ERR, 1, TRAY, BP(0), BP(1))
  SHOVER(DFORM, TID, 0, BP(1), -1, 0)
  CLOSE(FNUM)
  UNGRAB(-1)
  UNGRAB(-1)
END

IF RCNT >= RNAM AND &
      ( DBLOCK(LOCTAB(RID)) = 0 OR DBLOCK(LOCTAB(RECORD)) = 0 ) THEN DO
  ITEM _ RNAM
  GRAB(0)
  FNUM _ OPEND( FADD( DFORM) + @DNOFF, 0, 0)
  BID _ FNDID(FNUM, ERR, ERR, FADD(RNAM), -1, BP)
  [TRAY; TID] _ DGRAB(BP(1))
  CHREAD(FNUM, ERR, ERR, 1, TRAY, BP(0), BP(1))
  SHOVER(RID, BID, 0)
  SHOVER(RECORD, TID, 0, BP(1), -1, 0)
  CLOSE(FNUM)
  UNGRAB(-1)
  UNGRAB(-1)
END

IF RCNT >= FNAM AND DBLOCK(LOCTAB(FID)) = 0 THEN DO
  ITEM _ FNAM
  GRAB(0)
  FNUM _ OPEND(FDCT,0,0)
  BID _ FNDID(FNUM, ERR, ERR, FADD(FNAM), -1)
  SHOVER(FID, BID, 0)
  CLOSE(FNUM)
  UNGRAB(-1)
END

RETURN

ERR: IXMSG("ERROR TRANSLATING "); IXMSG(FNAME(ITEM)); DCTERR; GO ERRET

END TRANID

END READID

%FINDER (BID)
LOCAL TEMP, I
GLOBAL FLDFIL, FLDFLG
FIND %GBLK, %ODRBLK

GRAB(0)
FLDFLG _ 0
TEMP _ GBLK(BID, 0)
IF FLDFLG # 0 THEN CLOSE(FLDFIL)
UNGRAB(-1)
RETURN TEMP

%%FORMAT (FLDTAB() )
GRAB(0)
FLDFLG _ 0
FOR I _ FLDTAB(0) TO 1 BY -1  ODRBLK(BYT(FLDTAB(I),12,24))
TEMP _ BYT(FLDTAB(1),12,24)
LOOP DO
  FOR I _ 1 TO FLDTAB(0)
  WHILE GBLK(BYT(FLDTAB(I),12,24), TEMP) > 0
END
IF FLDFLG # 0 THEN CLOSE(FLDFIL)
UNGRAB(-1)

RETURN
END FINDER



%PRINTER (FLDID,BIT,OFF)
FIND PSTDSP, OUTDSP, OUTTB, EDPTR, EBUFF(1)
LOCAL TRAY(), TEMP

TRAY _ FINDER(FLDID)

TEMP _ TRAY(@OUTDSP) BAND OCT 777777

IF TRAY(@PSTDSP) BAND STATUS = 0 OR TEMP = 0 THEN RETURN -1

EDPTR _ CHPT(EBUFF,-1)
GOSUB (TEMP, @OUTTB, TRAY, BIT, OFF)
NCHV EDPTR _ EOLIT

RETURN 0

END PRINTER

!       ROUTINE TO CHECK STATUS ON AN INDIVIDUAL RECORD.
!       IF THE DICTIONARY FORMAT CONTAINS THE FIELD "RECSTA" AND
!       THE PARTICULAR RECORD HAS THE FIELD DEFINED THEN THE
!       VALUE OF THE FIELD IS USED TO MAKE NON-STANDARD STATUS CHECKS.
!       IF THE STATUS CHECK FAILS THEN A NON-ZERO VALUE IS RETURNED.
!       OTHERWISE, ZERO IS RETURNED.
!       THE ARGUMENTS ARE:
!         MODE - INDICATES EITHER DESIRE TO DISPLAY FIELDS FROM THE
!                RECORD OR DESIRE TO EDIT FIELDS.
%CHKSTA
FIND CODING
IF CODING = -1 THEN RETURN 0
ERROR("ROUTINE 'CHKSTA' NOT DEFINED.$")
END CHKSTA

%ADDSUB
LOCAL TRAY(), FRAY(), I, FLDID, BIT, OFF, FNUM, RSTART, RLEN
LOCAL  LRAY()
GLOBAL %FLGCHK
TABLE HELPM["ENTER THE NAME OF THE DATA BASE (DICTIONARY) TO WHICH &
YOU WISH$TO APPEND DATA.$"]

FIND ADDOFF, FLDOFF, DNOFF, SKPOFF, DEFOFF
FIND DBLOCK()

DEF NDX AS FLOATER(0)
DEF SAVE1 AS FLOATER(1)
DEF FLAGS(X) AS FLOATER(2+X)
DEF FMAX AS OCT 77
DEF T(X) AS DBLOCK( (DBLOCK(LOCTAB(RECORD)) BAND OCT 777777) + X)

READID("DATA BASE NAME: ",HELPM,1)
TRANID(1)
TRAY _ FADD(DFORM)


IF TRAY(@ADDOFF) BAND STATUS = 0 THEN &
  ERROR ("NOT ALLOWED TO APPEND TO THIS DICTIONARY$")

FORMAT(@TRAY(@FLDOFF))AB(FMAX+3)
SAVE1 _ TRAY

FOR I _ 0 TO FMAX FLAGS(I) _ 0

DBLOCK(LOCTAB(RECORD)) _ 0
RECFND(1)

NDX _ 0

LOOP DO
  WHILE INC NDX <= TRAY(@FLDOFF)
  [12,12,12]*[FLDID,BIT,OFF] _ TRAY(NDX+@FLDOFF)
  FRAY _ FINDER(FLDID)
  [T(0);T(1)] _ [T(0);T(1)] DSHL 1

  IF FLGCHK(FRAY(@SKPOFF)) # TRUE THEN DO
    T(1) BOR _ 1
    IF FLGCHK(FRAY(@DEFOFF)) = TRUE THEN PRINTER(FLDID,BIT,OFF,DISPOK) &
      ELSE READER(FLDID,BIT,OFF,ADD.OK)
  END
  TRAY _ FADD(DFORM)
END

[T(0);T(1)] _ [T(0);T(1)] DSHL (72-TRAY(@FLDOFF))

WRT.REC(0)

TRAY _ SAVE1
UNGRAB(0)
RETURN

%FLGCHK (VAL)
LOCAL MODE, INDEX, MASK

[3,6,27]*[MODE,INDEX,MASK] _ VAL

DO MODE OF 1:3

1: IF MASK BAND FLAGS(INDEX) = MASK THEN RETURN TRUE

2: IF MASK BAND FLAGS(INDEX) # 0 THEN RETURN TRUE

3: IF MASK BAND FLAGS(INDEX) = 0 THEN RETURN TRUE

END

RETURN FALSE

END FLGCHK

END ADDSUB

%SETREC (VAL)
LOCAL %SET.INT, %SETR, ID, RLEN, RSTART
FIND DBLOCK()

SET.INT
SETR
RETURN

%%RECFND (VAL)

SET.INT
IF RLEN <= VAL THEN SETR
RETURN

%SET.INT
[18,18]*[RLEN,RSTART] _ DBLOCK(LOCTAB(RECORD))
RETURN
END SET.INT

%SETR
LOCAL I
[;ID] _ DOUBLE GRAB(VAL+1)
MOVE RLEN FROM FADD(RECORD) TO FLOATER
IF VAL >= RLEN THEN FOR I _ RLEN TO VAL FLOATER(I) _ 0
SHOVER( RECORD, ID, 0, VAL+1, -1, 0)
UNGRAB(0)
RETURN
END SETR

END SET.REC

%READER (FLDID, BIT, OFF, MODE)
LOCAL TEMP, DUM, TRAY()
FIND INTB, INDSP, EDTDSP, DEFOFF, EBUFF(1)

TRAY _ FINDER(FLDID)

[18,18]*[TEMP,DUM] _ TRAY(@INDSP)

IF MODE = EDIT.OK THEN DO
  IF ( TEMP = 0 OR TRAY(@EDTDSP) BAND STATUS = 0&
   OR TRAY(@DEFOFF) # 0 OR PRINTER(FLDID,BIT,OFF) # 0 ) THEN &
   ERROR("MAY NOT EDIT THIS FIELD$")
  MOVE 52 FROM EBUFF TO IMAGE
END

IF TEMP = 0 THEN RETURN -1

GOSUB(TEMP, @INTB, TRAY, BIT, OFF, MODE)

RETURN 0

END READER


%NEW.DBLK
LOCAL TMP1, TMP2, ODB()
FIND DBLOCK()
ODB _ DBLOCK
[DBLOCK;TMP1] _ DOUBLE GRAB( TMP2 _ RSIZE(ODB(1)) )
MOVE TMP2 FROM ODB TO DBLOCK
DBLOCK(1) _ TMP1
RETURN
END NEW.DBLK


%COP.DBLK (NEW.ID)
FIND DBLOCK()
LOCAL TMP1, TMP2

SETSIZE( NEW.ID, TMP1 _ RSIZE( TMP2 _ DBLOCK(1) ) )
MOVE TMP1 FROM RBASE(TMP2) TO DBLOCK _ RBASE(NEW.ID)
DBLOCK(1) _ NEW.ID
RETURN

END COP.DBLK

%WRT.REC ( FLAG )
FIND %ADDID, %MODDAT, DBLOCK(), DNOFF
LOCAL FNUM, RLEN, RSTART, AERR:

FNUM _ OPEND( FADD(DFORM) + @DNOFF, 2, 0)

[18,18]*[RLEN,RSTART] _ DBLOCK(LOCTAB(RECORD))

EIF FLAG = 0 THEN DO
  ADDID(FNUM, AERR, AERR, FADD(RNAM), 0, @DBLOCK(RSTART), RLEN)
END
ELSE DO
  MODDAT(FNUM, AERR, AERR, DBLOCK( LOCTAB(RID) ), @DBLOCK(RSTART), RLEN)
END

CLOSE(FNUM)

RETURN

AERR: IXMSG("ERROR ADDING RECORD$"); DCTERR; GO ERRET

END WRT.REC
  i á