
!**COPYRIGHT 1972,1973, DIGITAL EQUIPMENT CORPORATION MAYNARD MA**
!AUTHOR NORMA ABEL

GLOBAL BIND DEFPV=84;		!VERSION: 7/13/73
!THE CONTROLLING ROUTINE IN THIS MODULE IS DEFDRIV. IT IS
!CALLED FROM PHA2. IT DIRECTS THE CALLING OF ALL THE OTHER
!(LOCAL) ROUTINES IN THIS MODULE. THE READER SHOULD START WITH
!THE ROUTINE DEFDRIV. IT APPEARS AT THE END OF THE MODULE
!(SAVE FOR INITDEF).


EXTERNAL LENTRY,QQ;
EXTERNAL ASSOCPT;
OWN PCE;
MAP BASE ASSOCPT;		!USED FOR LINKED LIST OF ASSOCIATE VARIABLES
MAP PEXPRNODE PCE;
OWN P,PA,PB,PC,HEAD,PAE;
OWN MOREFLG,LSTVAR,T;
EXTERNAL TOP,BOTTOM,CHOSEN,LOOPNO,LOOKUP;
MAP PHAZ2 P:QQ:PA:PB:PC:HEAD:PAE;
OWN MASK,CHNGLST;
OWN DISPIX;		!PLIT DISPATCH INDEX
FORWARD CHKNAML;

OWN GOTVAL;		!FLAG FOR ASSIGNED HERE
			!THAT IT GIT IT VALUE HERE

!DISPATCH TO USE FCNLOK TO BOTH SELECT ANS SET BITS.
!A SPACE ECONOMY AT A SLIGHT TRADE OFF IN TIME.

FORWARD SELECTIT,SETIT,SETGOTVAL;
BIND SETSEL = PLIT (
			SELECTIT,
			SETIT,
			SETGOTVAL);

!
!
!*****************************************************
!
!
ROUTINE SELECTIT(VAR)=
BEGIN
EXTERNAL CORMAN;
MAP PHAZ2 CHNGLST:TOP;
LOCAL THERE;
MAP PEXPRNODE VAR;
!SELECT VARIABLES TO PARTICIPATE IN THE DEFINITION POINT 
!THE FIELD IDCHOS (IN THE SYMBOL TABLE) IS SET TO THE
!LOOP NUMBER TO INDICATE THAT THIS VARIABLE WAS CONSIDERED IN THIS
!LOOP. IDDEF INDICATES THAT THE VARAIBLE HAS PARTICIPATED IN THE
!DEFINITION POINT COMPUTATION.
!32 VARIABLES ARE SELECTED. THERE ADDRESS ARE PUT INTO THE VECTOR CHOSEN.

!AS A VARIABLE IS CHOSEN IT IS ALSO ADDED TO THE LIST OF VARIABLES
!THAT ARE CHANGED IN THIS LOOP WHICH IS KEPT WITH THE DO LOOP
!AFTER PROCESSING AS IT GOES FORTH INTO THE OUTSIDE WORLD.

!THE VARIABLE LSTVAR IS USED TO HOLD THE PLACE OF THE ALGORITHM IN
!PROCESSING STATEMENTS IN CASE MORE THAN 32 EXIST.
!ALGORTHM
	VAR[IDCHOS]_.LOOPNO;
	IF .T LSS 32 AND NOT .VAR[IDDEF] THEN
	BEGIN
		THERE_0;
		!EQUIVALENCE LISTS ARE NOT HANDLED UNTIL REGISTER
		!ALLOCATION, THEREFOR, WE WILL IGNORE THEM HERE
		!AND GIVE THEM DEFPT OF THE CORRENT STATEMENT ELSEWHERE.
		IF .VAR[IDATTRIBUT(INEQV)] THEN RETURN;
		!VAR_EQVMESS(VAR);
		IF .VAR[IDATTRIBUT(INCOM)] THEN 
			PC_.VAR[IDCOMMON] ELSE
			PC_.VAR;
		INCR K FROM 0 TO 31 DO
			IF .CHOSEN[.K] EQL .PC THEN
			THERE_1;
		IF NOT .THERE THEN
		BEGIN
			CHOSEN[.T]_.PC;
			VAR[IDDEF]_1;
			T_.T+1;
			!ADD THIS VARIABLE TO THE LIST OF
			!CHANGED IN THIS LOOP
			PC_.CHNGLST;
			NAME<LEFT>_1;
			CHNGLST_CORMAN();
			IF .PC NEQ 0 THEN
				PC[RIGHTP]_.CHNGLST
			ELSE
				TOP[DOCHNGL]_.CHNGLST;
			CHNGLST[LEFTP]_.VAR;
			IF .T EQL 32 THEN LSTVAR_.P;
		END;
	END;
END;
!*****************************************************
FORWARD SELECRED;
ROUTINE THROINCOMMON=
BEGIN
	!PUT COMMON VARIABLES ON THE CHOOSEN LIST

	MAP BASE PCE;

		!DONT DO IT FOR HEARVALUED STUFF (DISPIX=2)
		IF .DISPIX EQL 2 THEN RETURN;

		INCR K FROM 0 TO SSIZ-1 DO
		BEGIN
			PCE_.SYMTBL[.K];
			WHILE .PCE NEQ 0 DO
			BEGIN
				IF .PCE[IDATTRIBUT(INCOM)] THEN
					(.SETSEL[.DISPIX])(.PCE);
				PCE_.PCE[CLINK];
			END;
		END;
END;
ROUTINE ANPARMS(ARGLSTPT)=
BEGIN
	!PUT THE PARAMETERS ON THE PARAMTER LIST (ARGLSTPT)
	!ON THE CHOSEN LIST

	MAP ARGUMENTLIST ARGLSTPT;

	MAP BASE PCE;
			INCR K FROM 1 TO .ARGLSTPT[ARGCOUNT] DO
			BEGIN
				PCE_.ARGLSTPT[.K,ARGNPTR];
				IF .PCE[OPRCLS] EQL DATAOPR
				AND (.PCE[OPERSP] EQL VARIABLE OR
				.PCE[OPERSP] EQL FORMLVAR) THEN
					(.SETSEL[.DISPIX])(.PCE);
			END;
END;
ROUTINE FCNLOK(EXPR)=
BEGIN
	!EXAMINE EXPRESSION EXPR FOR FUNCTION REFERENCES
	!IF ANY ARE FOUND PUT COMMON AND THE PARAMETERS ON THE
	!SELECTED LIST (THE VECTOR CHOSEN).

	MAP BASE EXPR;

	CASE .EXPR[OPRCLS] OF SET
	!BOOLEAN
	BEGIN
		FCNLOK(.EXPR[ARG1PTR]);
		FCNLOK(.EXPR[ARG2PTR]);
	END;
	!DATAOPR
		RETURN;
	!RELATIONAL
	BEGIN
		FCNLOK(.EXPR[ARG1PTR]);
		FCNLOK(.EXPR[ARG2PTR]);
	END;
	!FNCALL
	BEGIN
		LOCAL BASE T;
		T_.EXPR[ARG1PTR];
		IF .T[OPERSP] NEQ LIBARY THEN
		BEGIN
			THROINCOMMON();
			ANPARMS(.EXPR[ARG2PTR]);
		END;
	END;
	!ARITHMETIC
	BEGIN
		FCNLOK(.EXPR[ARG1PTR]);
		FCNLOK(.EXPR[ARG2PTR]);
	END;
	!TYPECNV
		FCNLOK(.EXPR[ARG2PTR]);
	!ARRAYREF
		IF .EXPR[ARG2PTR] NEQ 0 THEN
			FCNLOK(.EXPR[ARG2PTR]);
	!CMNSUB
		RETURN;
	!NEGNOT
		FCNLOK(.EXPR[ARG2PTR]);
	!SPECOP
		FCNLOK(.EXPR[ARG1PTR]);
	!FIELDREF
		RETURN;
	!STORECLS
		RETURN;
	!REGCONTENTS
		RETURN;
	!LABOP
		RETURN;
	!STATEMENT
		RETURN;
	!IOLSCLS
		RETURN;
	!INLINFIN
	BEGIN
		FCNLOK(.EXPR[ARG1PTR]);
		IF .EXPR[ARG2PTR] NEQ 0 THEN
		FCNLOK(.EXPR[ARG2PTR]);
	END
	TES;
END;

ROUTINE ASSOCIA=
BEGIN
	!LOOK AT LINKED LIS OF ASSOCIATE VARIABLES (FROM OPENS OR
	!DEFINE FILES AND SELECT, SET OF INDICATE SET HERE FOR
	!THESE VARIABLES. THE MODULE OWN DISPIX IS SET TO CALL THE
	!CORRECT ROUTINE BY THE CALLER OF THIS ROUITNE.

	REGISTER BASE LP;

	LP_.ASSOCPT;
	WHILE .LP NEQ 0 DO
	BEGIN
		(.SETSEL[.DISPIX])(.LP[LEFTP]);
		LP_.LP[RIGHTP];
	END;
END;

!MACRO TO TEST RANDOM ACCESS PROPERTY OF AN I/O STATEMENT
!POINTED TO BY P AND CALL THE CORRECT SETSEL ROUTINE

MACRO RANDIO(P)=
BEGIN
	IF .P[IORECORD] NEQ 0 THEN
	BEGIN
		ASSOCIA();
		THROINCOMMON();
	END;
END$;

ROUTINE DEF0 =

BEGIN
	!LOOK AT STATEMENTS THAT POTENTAILLY ASSIGN A VALUE TO A
	!VARIABLE. CALL THE ROUTINE SELECTIT TO SELECT THE
	!VARIABLE. FUNCTIONS WITH SIDE EFFECTS WILL PRODUCE
	!BAD RESULTS.

	EXTERNAL CSTMNT,ISN;
	MAP BASE CSTMNT;

	MAP BASE PCE;

	MAP PHAZ2 TOP;

	!SET DISPATCH INDEX TO EXECUTE SELECTIT
	DISPIX_0;
	LSTVAR_-1;		!INITIALIZE LSTVAR
	!ALSO INITIALIZE CHOSEN
	DECR I FROM 31 TO 0 DO
		CHOSEN[.I]_0;
	!MAKE SURE WE GET THE INDUCTION VARIABLE
	IF .TOP[SRCID] EQL DOID THEN
		SELECTIT(.TOP[DOSYM]);

	!PICK FIRST 32 UNIQUE LHS TO PROCESS
	DO
	BEGIN
		CSTMNT_.P;
		ISN_.CSTMNT[SRCISN];
		SELECT .P[SRCID] OF NSET
ASGNID:		BEGIN
			PB_.P[LHEXP];
			IF .PB[OPRCLS] EQL DATAOPR THEN SELECTIT(.PB);
			FCNLOK(.P[RHEXP]);
		END;
CALLID:	BEGIN
		!PUT COMMONIN THE LIST
		THROINCOMMON();
		!PUT PARAMETERS ON THE LIST
		IF .P[CALLIST] NEQ 0 THEN
			ANPARMS(.P[CALLIST]);
	END;

READID:
	BEGIN
		IF .P[IOLIST] NEQ 0 THEN
		BEGIN
			 SELECRED(.P[IOLIST]);
			RANDIO(P);
		END
		ELSE
		CHKNAML(.P[IONAME]);
	END;
WRITID:	BEGIN
	!YOU ARE SURPRISED TO FIND A WRITE HERE. IT IS RELEVANT ONLY
	!IF IT IS RANDOM ACCESS. IN THAT CASE ANY ASSOCIATE VAIABLES
	!MUST BE CONSIDERED. ALSO COMMON

	RANDIO(P);
	END;

FINDID:
	BEGIN
	!SEE COMMENT IN WRITE
	RANDIO(P);
	END;

DOID:	BEGIN
		FCNLOK(.P[DOLPCTL]);
		!THIS MUST BE INNER TO THE ONE CURRENTLY BEING
		!PROCESSED
		!MAKE SURE THAT WE NOTE THE VARIABLES CHANGED IN IT
		!IN THE ALGORITHM
		PB_.P[DOCHNGL];
		WHILE .PB NEQ 0 DO
		BEGIN
			SELECTIT(.PB[LEFTP]);
			PB_.PB[RIGHTP];
		END;
	END;

	!THIS NEXT GROUP IS HERE ONLY FOR LOOKING FOR POSSIBLE
	!FUNCTION REFERENCES IN THE EXPRESSIONS INVOLVED
AGOID:	FCNLOK(.P[AGOTOLBL]);
CGOID:	FCNLOK(.P[CGOTOLBL]);
IFAID:	FCNLOK(.P[AIFEXPR]);
IFLID:	FCNLOK(.P[LIFEXPR]);
RETUID:	IF .P[RETEXPR] NEQ 0 THEN FCNLOK(.P[RETEXPR]);

ENCOID:		BEGIN
		IF .P[IOVAR] NEQ 0 THEN
		BEGIN
			PB_.P[IOVAR];
			IF .PB[OPRCLS] EQL DATAOPR THEN
				SELECTIT(.P[IOVAR]);
		END;
		END;
DECOID:		IF .P[IOLIST] NEQ 0 THEN SELECRED(.P[IOLIST]);
REREDID:	IF .P[IOLIST] NEQ 0 THEN SELECRED(.P[IOLIST]);


ALWAYS:
	BEGIN
		!TEST FOR JUST HAVING FILLED UP THE 32
		!IF WE DONT TEST NOW BY THE TIME WE UPDATE
		!P WE WILL HAVE PASTED LSTVAR

		IF .P EQL .LSTVAR THEN
		BEGIN
			MOREFLG_1;
			RETURN;
		END;

		P_.P[BUSY];
	END;
		TESN;
	END UNTIL  .P EQL 0 OR .P EQL .LSTVAR;
	IF .P EQL 0 THEN MOREFLG_0;
END;

!*******************************************************
!

FORWARD SETREAD;
ROUTINE SETIT(VAR)=
BEGIN
	!SET THE BIT IN THE ACC FIELD OF THE MODULE-OWN,P,
	!TO INDICATE THAT THE VARIABLE VAR IS DEFINED AT
	!SOME PREDECESSOR OF P.

	MAP BASE VAR; MAP PHAZ2 P;

	LOCAL I;

	IF .VAR[IDDEF] THEN		!THIS VARIABLE IS ELIGIBLE FOR
					!CONSIDERATION
	BEGIN
		I_LOOKUP(.VAR);

		IF .I LSS 32 THEN
			P[ACC]_SETBIT(.P[ACC],.I);
	END;
END;

ROUTINE DEFCHANGE(STMT)=
BEGIN
	!EXAMINE STATEMENTS THAT CAUSE VALUES OF VARAIBLES TO CHANGE
	!AND CALL SETIT OR SETREAD TO SET BITS IN THE MASK FOR THAT
	!WORD. MASK EXPLAINED IN COMMENTS THAT GO WITH DEF1.
	!NOTE:
	!THE BIT WILL BE SET IN THE MASK ASSOCIATED WITH THE MODULE
	!OWN P WI;HICH POINTS TO A STATEMENT.
	MAP PHAZ2 STMT;
	IF .STMT[SRCID] GTR REREDID THEN RETURN;

	!NOTHING ABOVE REREAD IS OF CONCERN

		!SET MODULE OWN THAT IS INDEX TO DISPATCH
		DISPIX_1;

	SELECT .STMT[SRCID] OF NSET
ASGNID:
			!FOR AN ASSIGNMENT STATEMENT
			!SET BIT ASSOCIATED WITH THE LEFT-HAND SIDE.
			BEGIN
				IF .STMT[A1VALFLG] THEN
					SETIT(.STMT[LHEXP]);
				FCNLOK(.STMT[LHEXP]);
				FCNLOK(.STMT[RHEXP]);
			END;
CALLID:
			!FOR A CALL STATEMENT SET THE BITS ASSOCIATED
			!WITH ANY PARAMETER.
			BEGIN
				LOCAL ARGUMENTLIST ARGLSTPT;
				THROINCOMMON();
				IF .STMT[CALLIST] NEQ 0 THEN
				BEGIN
					!THERE ARE ARGUMENTS TO TH CALL
					ARGLSTPT_.STMT[CALLIST];
					INCR K FROM 1 TO .ARGLSTPT[ARGCOUNT] DO
					BEGIN
						PB_.ARGLSTPT[.K,ARGNPTR];
						IF .PB[OPR1] EQL VARFL THEN
							SETIT(.PB);
					END;
				END;	!CALLIST NEQ 0
			END;
DOID:	BEGIN
		REGISTER PHAZ2 T1;
		T1_.STMT[DOCHNGL];
		WHILE .T1 NEQ 0 DO
		BEGIN
			SETIT(.T1[LEFTP]);
			T1_.T1[RIGHTP];
		END;
	END;
CGOID:
		!COMPUTED GOTO COULD HAVE FUNCTION REFERENCE
		FCNLOK(.STMT[GOTOLBL]);
IFAID:
		!ARITHMETIC IF
		FCNLOK(.STMT[AIFEXPR]);

IFLID:
		!LOCIGAL IF
		!NOTE THAT THE STATEMENT IS ON THE BUSY LIST SO WE
		!DO NOT PROCESS IT NOW
		FCNLOK(.STMT[LIFEXPR]);

RETUID:
		!RETURN
		IF .STMT[RETEXPR] NEQ 0 THEN
			FCNLOK(.STMT[RETEXPR]);

READID:
			!FOR A READ SET THE BITS ASSOCAITED WITH
			!ITEMS READ.
			IF .STMT[IOLIST] NEQ 0 THEN
			BEGIN
				SETREAD(.STMT[IOLIST]);
				RANDIO(STMT);
			END
			ELSE
				CHKNAML(.STMT[IONAME]);

WRITID:	RANDIO(STMT);

FINDID:		RANDIO(STMT);

ENCOID:			SETIT(.STMT[IOVAR]);

DECOID:		SETREAD(.STMT[IOLIST]);

REREDID:		SETREAD(.STMT[IOLIST]);
		TESN;
END;


ROUTINE ZAPLEVEL(PRED)=
BEGIN
REGISTER PHAZ2 PREDLST;
OWN PHAZ2 THISPRED;
MAP PHAZ2 P:PRED:T:PA;
	!LOCAL ROUITNE TO TRY TO CUT THE RECURSION IN HALF BY DOING A
	!LOOK AHEAD OF ONE ON STRAIGHT LINE PATHS.

	ROUTINE NRZAPLVL=
	BEGIN
		MAP PHAZ2 T;
		THISPRED_.T[CESSOR];
		IF .THISPRED NEQ .P[PREDOM] AND .THISPRED[LEVEL] NEQ 0 THEN
		BEGIN
			THISPRED[LEVEL]_0;
			ZAPLEVEL(.THISPRED);
		END;
	END;


	!ZERO THE LEVEL FIELD OF THE OPTIMIZERS WORDS
	!FOR ALL NODES BETWEEN PRED AND P[PREDOM].

	PREDLST_.PRED[PREDPTR];
	WHILE .PREDLST[CESLNK] NEQ 0 DO
	BEGIN
		!EXAMINE EACH PREDECESSOR
		THISPRED_.PREDLST[CESSOR];
		!RECURSE ONLY IF THE LEVEL IS NON-ZERO AND WE ARE NOT
		!AT P[PREDOM].
		IF .THISPRED NEQ .P[PREDOM] AND .THISPRED[LEVEL] NEQ 0 THEN
		BEGIN

			!NOW ZERO AND RECURSE
			THISPRED[LEVEL]_0;
			!DONT RECURSE COMPLETELY FOR A STRAIGHT PATH
			T_.THISPRED[PREDPTR];
			PA_.T[CESLNK];
			!CHECK FOR ONE PREDECESSOR
			IF .PA[CESLNK] NEQ 0 THEN
				ZAPLEVEL(.THISPRED)
			ELSE
				NRZAPLVL();
		END;
		PREDLST_.PREDLST[CESLNK];
	END;
END;

ROUTINE SWAMP=
BEGIN
	!MAKE AND FOLLOW A MOORE FLOOD ORDERING OF NODES BETWEEN
	!P AND P[PREDOM] SETTING BITS IN THE MASK AT P FOR
	!VARIABLES CHANGED AT ANY OF THE NODES TRAVERSED.

	MAP PHAZ2 P:T;
	OWN PHAZ2 TAIL;

	TAIL_HEAD_.P;

	!WHILE CONDITION WILL STOP ON ZERO OR THE FIELD SET TO 1 (PROCESSED MARK).
	WHILE .HEAD GTR #1000 DO
	BEGIN
		!PROCESS THE PREDECESSORS OF HEAD
		T_.HEAD[PREDPTR];
		WHILE .T[CESLNK] NEQ 0 DO
		BEGIN
			PA_.T[CESSOR];
			!PA IS NOW A REAL SUCCESSOR
			!IF IT IS NOT ALREADY DONE OR THE PREDOMINAATOR OF P
			!PROCESS IT
			IF .PA NEQ .P[PREDOM] THEN
			BEGIN
				IF .PA[LEVEL] EQL 0 THEN
				BEGIN
					!NOTE PA PROCESSED BY SETTING LEVEL NON-ZERO
					PA[LEVEL]_1;
					!ADD IT TO THE END OF THE CHAIN
					TAIL[LEVEL]_.PA;
					!UPDATE THE TAIL OF THE CHAIN
					TAIL_.PA;
					!SET THE %&$#% BIT
					DEFCHANGE(.PA);
				END;
			END;
			T_.T[CESLNK];
		END;
		HEAD_.HEAD[LEVEL];
	END;		!WHILE ON HEAD;
END;

ROUTINE DEF1 =
BEGIN
	 MAP PHAZ2 T;
	!
	!INITIALIZE ACC FOR DEFINITION POINT CALCULATION
	!DETERMINE IF THERE IS AN INTERFERRING
	!ASSIGNMENT BETWEEN NODE AND IMMEDIATE
	!PREDOMINATOR

	!THE INITIALIZATION ALGORITHM IS:
	!1.	LOOK AT ALL IMMEDIATE PREDECESSORS OF A NODE
	!2.	IF THE PREDECESSOR IS NOT THE PREDOMINATOR THEN
	!	SET THE BIT IN THE MASK WHICH CORRESPOND TO ANY
	!	VARIABLE ASSIGNED A VALUE AT THAT PREDECESSOR.

	!A SPECIAL CASE IS THE FIRST STATEMENT AFTER THE DO LOOP
	!TO PREVENT COMPUTATIONS THAT ARE COMPOSED OF VARIABLES
	!ASSIGNED IN THE LOOP FROM ERRONEOUSLY MOVING OUTSIDE THE LOOP
	!THIS STATEMENT WILL HAVE THE BITS SET FOR ALL THE VARIABLES
	!ON THE DOCHNGL LIST TOO.

	MAP PHAZ2 TOP;
	EXTERNAL CSTMNT,ISN;
	LOCAL BASE ITM;
	MAP BASE CSTMNT;
	!
	P_.TOP;
	P[ACC]_0;
	P_.TOP[BUSY];
	!THE SPECIAL CASE

	IF .P EQL .TOP[SRCLINK] THEN
	BEGIN
		ITM_.TOP[DOCHNGL];
		WHILE .ITM NEQ 0 DO
		BEGIN
			!DOCHNGL IS A LINKED LIST
			!THE LEFT HALF OF THE WORD
			!POINTS TO THE VARIABLE, THE RIGHT
			!HALF TO THE NEXT LIST ITEM. IT IS
			!TERMINATED WITH A ZERO

			SETIT(.ITM[LEFTP]);
			ITM_.ITM[RIGHTP];
		END;
	IF .TOP[SRCID] EQL DOID THEN SETIT(.TOP[DOSYM]);
	END;

	!THE CAST OF CHARACTERS FOR THE NEXT WHILE LOOP IS
	!P THE STATEMENT ON WHICH MASK BITS ARE INITIALIZED
	!IF THE PREDECESSOR IS THE PREDOMINATOR SET NO BITS
	!IF  NOT ZERO THE LEVEL FIELD OF THE
	!OPTIMIZERS WORDS AND USE IT TO FLOOD AND SET BITS
	!FOR ALL VARIABLES ASSIGNED AT ALL NON_PREDOMINATING
	!PREDECESORS.
	!FOR ALL STATEMENTS
	DO
	BEGIN
		!FOR A DO LOOP THAT IS NOT TOP SET THE BITS ON THE
		!DO LOOP TOO INCASE SOMETHING BELOW THE TERMINATOR
		!IS NOT PREDOMINATED BY THE YERMINATOR

		IF .P NEQ .TOP AND .P[SRCID] EQL DOID THEN
		BEGIN
			ITM_.P[DOCHNGL];
			WHILE .ITM NEQ 0 DO
			BEGIN
				!DOCHNGL IS A LINKED LIST
				!THE LEFT HALF OF THE WORD
				!POINTS TO THE VARIABLE, THE RIGHT
				!HALF TO THE NEXT LIST ITEM. IT IS
				!TERMINATED WITH A ZERO
	
				SETIT(.ITM[LEFTP]);
				ITM_.ITM[RIGHTP];
			END;
		END;

		!TRY TO ELIMINATE SOME TIME AND EFFORT BY NOT
		!DOING THIS FOR A NODE IF IT HAS 1 PREDECESSOR
		!WHICH (BY DEFINITION) IS ITS PREDOMINATOR
		!SET THE LEVEL FIELD OF P[PREDOM] TO BE NON-ZERO
		T_.P[PREDOM];
		T[LEVEL]_1;
		!NOW START CHECKING ON PREDECESSORS
		T_.P[PREDPTR];
		!T IS A POINTER TO THE PREDECESSOR LIST
		PA_.T[CESLNK];
		!PA POINTS TO THE NEXT LINK
		T_.T[CESSOR];
		!T POINTS TO FIRST PREDECESSOR
		!MAKE SURE THERE ARE NONE OTHERS
		!PA POINTS TO NEXT LINK WORD. IF THERE IS ONLY ONE
		!PA IS A POINTER TO A WORD OF ZEROES.
		!THIS IS A DOUBLE SAFE CHECK. IF BLISS EVER DOES BETTER
		!ON BOOLEANS IT WILL ELIMINATE BUMMERS FAST.
		IF .T NEQ .P[PREDOM] OR .PA[CESLNK] NEQ 0  THEN
		BEGIN
			!TO INSURE AGAINST A FLUKE
			P[LEVEL]_0;
			ZAPLEVEL(.P);
			SWAMP();
		END
		!ON THE OTHERHAND IF THIS IS A SINGLE  PREDECESSOR
		!AND IT IS THE PREDOMINATOR AND IT IS A DO LOOP
		!WE WANT TO SET THE BITS FOR ALL VARIABLES IN THE LOOP
		ELSE
			IF .PA[CESLNK] EQL 0 AND .T[SRCID] EQL DOID THEN
				DEFCHANGE(.T);
		P_.P[BUSY];
	END UNTIL .P EQL 0;
END;


!*******************************************************
!
!*******************************************************
!
MAP PHAZ2 PB;
ROUTINE SETGOTVAL(VAR)=
BEGIN
	!THE GLOBAL TREEPTR POINTS TO S SYMBOL TABLES ENTRY.
	!IF  IT EQUALS VAR THEN SET GOTVAL TO 1
	EXTERNAL TREEPTR;

	IF .VAR EQL .TREEPTR THEN GOTVAL_1;
END;

ROUTINE SETGTRD(IOLSTT)=
BEGIN
	!EXAMINE THE IOLIST POINTED TO BY IOLSTT FOR
	!A SINGLE VARIABLE TREEPTR.

	EXTERNAL TREEPTR;

	MAP BASE IOLSTT;

	REGISTER TMP;

	WHILE .IOLSTT NEQ 0 DO
	BEGIN
		IF .IOLSTT[OPRCLS] NEQ STATEMENT THEN 
		BEGIN
			CASE .IOLSTT[OPERSP] OF SET
			!DATACALL
				IF .IOLSTT[DCALLELEM] EQL .TREEPTR THEN
					GOTVAL_1;

			!SLISTCALL
				IF .IOLSTT[SCALLELEM] EQL .TREEPTR THEN
						GOTVAL_1;

			!IOLSTCALL
				SETGTRD(.IOLSTT[IOLSTPTR]);

			!E1LIST
			BEGIN END;	!RELEASE >1

			!E2LIST
			BEGIN END;	!RELEASE >1

			TES;
		END;
		IOLSTT_.IOLSTT[CLINK];
	END;		!WHILE
END;	!SETGTRD


ROUTINE HEREVALUED(STMT, VAR)=
BEGIN
		!SEE IF THE VARIABLE VAR GETS A VALUE AT STATEMENT STMT.
		!IF SO RETURN 1 ELSE RETURN 0


	EXTERNAL TREEPTR;
	MAP BASE VAR:STMT;

	IF .STMT[SRCID] GTR REREDID THEN RETURN 0;

	!SET TREEPTR TO VAR FOR USE IN DEEPER ROUTINES
	TREEPTR_.VAR;
	!INITIALIZE GOTVAL TO 0
	GOTVAL_0;

	!SET DISPIX
	DISPIX_2;

	SELECT .STMT[SRCID] OF NSET

	ASGNID:
	BEGIN
		IF .STMT[LHEXP] EQL .VAR THEN GOTVAL_1;
		FCNLOK(.STMT[LHEXP]);
		FCNLOK(.STMT[RHEXP]);
	END;

	CALLID:
		IF .STMT[CALLIST] NEQ 0 THEN
			ANPARMS(.STMT[CALLIST]);
	CGOID:
		FCNLOK(.STMT[GOTOLBL]);

	IFAID:
		FCNLOK(.STMT[AIFEXPR]);

	IFLID:
		FCNLOK(.STMT[LIFEXPR]);

	RETUID:
		IF .STMT[RETEXPR] NEQ 0 THEN
			FCNLOK(.STMT[RETEXPR]);

	READID:
		IF .STMT[IOLIST] NEQ 0 THEN
		BEGIN
			SETGTRD(.STMT[IOLIST]);
			RANDIO(STMT);
		END
		ELSE
			CHKNAML(.STMT[IONAME]);

WRITID:	RANDIO(STMT);

FINDID:	RANDIO(STMT);

	ENCOID:
		IF .STMT[IOVAR] NEQ 0 THEN SETGOTVAL(.STMT[IOVAR]);

	DECOID:
		IF .STMT[IOLIST] NEQ 0 THEN SETGTRD(.STMT[IOLIST]);

	REREDID:
		IF .STMT[IOLIST] NEQ 0 THEN SETGTRD(.STMT[IOLIST]);

	TESN;

	.GOTVAL
END;

GLOBAL ROUTINE GETDEF(CNODE,CDEFPT,STMT)=
BEGIN
EXTERNAL INDVAR;	!THE DO INDUCTION VARIABLE
LOCAL PDE;		!A TEMPORARY
!COMPUTE ACTUAL DEFINITION POINT OF A LEAF NODE
!THIS ALGORITHM IS:
	!LOOK UP THE VARIABLE IN QUESTION (CNODE)
	!IF IT IS IN CHOSEN THEN CREATE A 36 BIT MASK WHICH HAS
	!THE BIT CORRESPONDING TO THE VARIABLE ON IN THE MASK.
	!STARTING WITH THE ACC OF THE CURRENT STATEMENT AND
	!THIS MASK WITH SUCCESSIVE ACC FIELDS ON THE PREDOMINATOR
	!CHAIN OF THE STATEMENT UNTIL THE MASK IS NOT ZERO. THIS
	!INDICATES AN INTERFERRING ASSIGNMENT IN THAT INTERVAL.
URN THE DEFINITION POINT AS THIS PLACE.

EXTERNAL PHAZ2 TOP;
MAP PHAZ2 CNODE;
!
	IF .CNODE[OPRCLS] EQL REGCONTENTS THEN RETURN(.TOP);
	IF .CNODE[OPRCLS] NEQ DATAOPR THEN RETURN(0)
	ELSE
	!IT SHOULD BE A VARIABLE, FORMAL VARIABLE OR A FUNCTION
	!NAME. IF THE LATTER IT SHOULD BE THE NAME OF
	!THE CURRENT FUNCTION.
	IF .CNODE[OPERSP] NEQ VARIABLE AND
	   .CNODE[OPERSP] NEQ FORMLVAR AND
	   .CNODE[OPERSP] NEQ FNNAME THEN RETURN(.LENTRY);

	IF .CNODE EQL .INDVAR THEN RETURN(.TOP);
	IF NOT .CNODE[IDDEF] THEN
	BEGIN
		IF NOT .MOREFLG THEN
		BEGIN
			IF .CNODE[OPR1] EQL VARFL THEN 
			BEGIN
				CNODE[IDUSED]_1;
				IF .CNODE[IDATTRIBUT(INCOM)] OR
				   .CNODE[IDATTRIBUT(INEQV)] THEN
				RETURN(.STMT)
				ELSE
				!IF THE DO STATEMENT IS LABELED
				!WE MIGHT BE INROUTBLE IF WE SAY LENTRY
				!ESPECIALLY IF LENTRY IS AN ASSIGNMENT OF THAT
				!VARIABLE TO A CONSTANT (I.E. IT WILL
				!GET PROPAGATED.
				RETURN(IF .TOP[SRCLBL] NEQ 0 THEN .TOP ELSE .LENTRY);
			END;
		END;
	END ELSE
	BEGIN
	!JUST TO MAKE SURE AVOID EQUIVALENCE LIKE THE PLAGUQ.
	!EQUIVALENCE LISTS ARE NOT PROCESSED UNTIL REGISTER
	!ALLOCATION
	IF .CNODE[IDATTRIBUT(INEQV)] THEN RETURN(.STMT);
	PDE_LOOKUP(.CNODE);
	IF .PDE GTR 32 THEN RETURN(.CDEFPT);
	MASK_0;
	MASK_SETBIT(.MASK,.PDE);
	PB_.STMT;			!PT TO STATEMENT
	WHILE 1 DO
	BEGIN
		IF (.PB[ACC] AND .MASK) NEQ 0 THEN RETURN(.PB);
		IF .PB EQL .TOP THEN RETURN(.LENTRY);
		IF HEREVALUED(.PB,.CNODE) THEN RETURN(.PB);
		PB_.PB[PREDOM];
	END;
	END;
	.CDEFPT		!JUST IN CASE
END;
!**********************************************************
!
ROUTINE VDEFPT(PNODE)=
BEGIN
!WALK AN EXPRESSION TREE COMPUTING DEFINITION POINTS OF LEAFS (VARIABLES)
REGISTER PHAZ2 P;
P_.PNODE;
		CASE .P[OPRCLS] OF SET

			!BOOLEAN
			BEGIN
			IF .P[A1VALFLG] THEN
				P[DEFPT1]_GETDEF(.P[ARG1PTR],.P[DEFPT1],.PAE)
			ELSE
			VDEFPT(.P[ARG1PTR]);
			IF .P[A2VALFLG] THEN
				P[DEFPT2]_GETDEF(.P[ARG2PTR],.P[DEFPT2],.PAE)
			ELSE
			VDEFPT(.P[ARG2PTR]);
			END;

			!DATAOPR
				RETURN;

			!RELATIONAL
			BEGIN
			IF .P[A1VALFLG] THEN
				P[DEFPT1]_GETDEF(.P[ARG1PTR],.P[DEFPT1],.PAE)
			ELSE
			VDEFPT(.P[ARG1PTR]);
			IF .P[A2VALFLG] THEN
				P[DEFPT2]_GETDEF(.P[ARG2PTR],.P[DEFPT2],.PAE)
			ELSE
			VDEFPT(.P[ARG2PTR]);
			END;

			!FNCALL
			BEGIN
				LOCAL ARGUMENTLIST AG;
				AG_.P[ARG2PTR];
				INCR I FROM 1 TO .AG[ARGCOUNT] DO
					VDEFPT(.AG[.I,ARGNPTR]);
			END;

			!ARITHMETIC
			BEGIN
			IF .P[A1VALFLG] THEN
				P[DEFPT1]_GETDEF(.P[ARG1PTR],.P[DEFPT1],.PAE)
			ELSE
			VDEFPT(.P[ARG1PTR]);
			IF .P[A2VALFLG] THEN
				P[DEFPT2]_GETDEF(.P[ARG2PTR],.P[DEFPT2],.PAE)
			ELSE
			VDEFPT(.P[ARG2PTR]);
			END;

			!TYPCNV
			IF .P[A2VALFLG] THEN
				P[DEFPT2]_GETDEF(.P[ARG2PTR],.P[DEFPT2],.PAE)
			ELSE
			VDEFPT(.P[ARG2PTR]);

			!ARRAYREF
			IF .P[A2VALFLG] THEN
				P[DEFPT2]_GETDEF(.P[ARG2PTR],.P[DEFPT2],.PAE)
			ELSE
			VDEFPT(.P[ARG2PTR]);

			!CMNSUB
			IF .P[A2VALFLG] THEN
				P[DEFPT2]_GETDEF(.P[ARG2PTR],.P[DEFPT2],.PAE)
			ELSE
			VDEFPT(.P[ARG2PTR]);

			!NEGNOT
			IF .P[A2VALFLG] THEN
				P[DEFPT2]_GETDEF(.P[ARG2PTR],.P[DEFPT2],.PAE)
			ELSE
			VDEFPT(.P[ARG2PTR]);

			!SPECOP
			IF .P[A1VALFLG] THEN
				P[DEFPT1]_GETDEF(.P[ARG1PTR],.P[DEFPT1],.PAE)
			ELSE
			VDEFPT(.P[ARG1PTR]);

			!FIELDREF
			BEGIN END;	!NOT RELEASE 1

			!STORECLS
			BEGIN END;

			!REGCONTENTS
			!IT MUST BE THE INDUCTION VARIABLE
			BEGIN END;	!SHOULDNT GET HERE

			!LABOP
			BEGIN END;

			!STATEMENT
			BEGIN END;

			!IOLSCLS
			BEGIN END;

			!INLINFN
			BEGIN
				IF .P[A1VALFLG] THEN
					P[DEFPT1]_GETDEF(.P[ARG1PTR],
							.P[DEFPT1],.PAE)
				ELSE
				VDEFPT(.P[ARG1PTR]);
				IF .P[ARG2PTR] NEQ 0 THEN
				BEGIN
					IF .P[A2VALFLG] THEN
					P[DEFPT2]_GETDEF(.P[ARG2PTR],
							.P[DEFPT2],.PAE)
					ELSE
					VDEFPT(.P[ARG2PTR]);
				END;
			END
			TES;
END;
!************************************************************
!

!TO MAKE CODE LOOK NEATER THIS MACRO IS USED 
MACRO DATAGET=
	IF .P[OPRCLS] EQL DATAOPR THEN RETURN
	ELSE VDEFPT(.P)$;
ROUTINE DEFPT(STMT)=
BEGIN
!AFTER INTERFERING ASSIGNMENT INFORMATION IS COLLECTED
!USE IT TO COMPUTE DEFINITION POINTS FOR LEAVES AND EXPRESIONS
!CONTROL AT THE STATEMENT LEVEL
!THIS IS THE STATEMENT LEVEL ROUTINE AS OPPOSED TO THE
!EXPRESSION LEVEL ROUTINE WHICH IS VDEFPT (VARIABLE DEFPT).

MAP BASE TOP;
MAP PHAZ2 STMT;
PAE_.STMT;		!PAE USED IN LOWER ROUTINES
IF .STMT[SRCID] EQL ASGNID THEN
BEGIN
	P_.STMT[LHEXP];
	IF .P[OPRCLS] EQL ARRAYREF THEN
		VDEFPT(.P);
	P_.STMT[RHEXP];
	IF .P[OPRCLS] EQL DATAOPR THEN STMT[OPDEF]_GETDEF(.P,0,.STMT)
	ELSE
	VDEFPT(.P);
END;
	IF .STMT[SRCID] EQL DOID THEN
	!SKIP IT IF THIS IS THE CURRENT DO WE ARE PROCESSING
	BEGIN
		IF NOT .STMT[FLCWD] AND .STMT[SRCOPT] NEQ 0 THEN
		BEGIN
			P_.STMT[DOLPCTL];
			IF .P[OPR1] EQL CONSTFL THEN
			STMT[DOPDEF]_.LENTRY
			ELSE
			IF .P[OPRCLS] EQL DATAOPR THEN
			STMT[DOPDEF]_GETDEF(.P,0,.STMT)
			ELSE
			VDEFPT(.P);
		END;
	END;
	IF .STMT[SRCID] EQL IFLID THEN
	BEGIN
		P_.STMT[LIFEXPR];
		DATAGET;
		DEFPT(.STMT[LIFSTATE]);
	END;
	IF .STMT[SRCID] EQL IFAID THEN
	BEGIN
		P_.STMT[AIFEXPR];
		DATAGET;
	END;
	IF .STMT[SRCID] EQL CALLID THEN
	BEGIN
		IF .STMT[CALLIST] NEQ 0 THEN
		BEGIN
			LOCAL ARGUMENTLIST AG;
			AG_.STMT[CALLIST];
			INCR K FROM 1 TO .AG[ARGCOUNT] DO
			BEGIN
				PB_.AG[.K,ARGNPTR];
				IF .PB[OPRCLS] NEQ DATAOPR THEN
				VDEFPT(.PB);
			END;
		END;
	END;
END;
!
!***************************************
!
FORWARD INITIDDEF;
GLOBAL ROUTINE DEFDRIV=
BEGIN

!CONTROLER FOR THE DEFINITION POINT ALGORITHM

	EXTERNAL CSTMNT,ISN;
	MAP PHAZ2 CSTMNT:TOP;

	CHNGLST_0;
	MOREFLG_1;
	P_.TOP[BUSY];
	WHILE .MOREFLG DO
	BEGIN
		T_0;
		!EACH ROUTINE IS A SEPARATE PASS OVER THE
		!ENCODED SOURCE FOR THE CURRENT LOOP
		DEF0();		!PICK 32 VARIALES
		!IF THERE WERE NO VARIABLES (WRITE STATEMENT ONLY,
		!FOR EXAMPLE, QUIT HERE

		IF .T EQL 0 THEN
			MOREFLG_0
		ELSE
		BEGIN
			DEF1();		!INITIALIZE THE MASK
		END;
		!NOW WE ARE READY TO ACRUALLY GET DEFINITION POINTS
		CSTMNT_.TOP[BUSY];		!SKIP CURRENT LOOP
		WHILE .CSTMNT NEQ 0 DO
		BEGIN
			ISN_.CSTMNT[SRCISN];
			DEFPT(.CSTMNT);
			CSTMNT_.CSTMNT[BUSY];
		END;
		P_.LSTVAR;
	END;
	INITIDDEF();		!REINITIALIZE FOR NEXT LOOP
END;
!
!*************************************************
!
ROUTINE INITIDDEF=
BEGIN
	MACRO IDFLGS=0,2,18,18$;
	!THIS IS BOTH FLAGS TOGETHER. SO BLISS WILL ONLY DO ONE LDB
	!DPB.

	!REINITIALIZE ALL IDDEF AND IDUSED FLAGS
	!IT SEEMS QUICKEST TO JUST RUN THROUGH THE SYMBOL TABLE
	!WITH NO TESTING AND SET THE FLAG TO ZERO EVERYWHERE.

	EXTERNAL SYMTBL;
	LOCAL BASE TMP;

	INCR I FROM 0 TO SSIZ-1 DO
	BEGIN
		TMP_.SYMTBL[.I];
		WHILE .TMP NEQ 0 DO
		BEGIN
			TMP[IDFLGS]_0;
			TMP_.TMP[CLINK];
		END;
	END;
END;
ROUTINE SELECRED(IOLSTT)=
BEGIN
	!EXAMINE AN I/O LIST AND CALL
	!SELECT TO CHOOSE VARIABLES FOR DEFINITION
	!POINT ALGORITHM
	MAP BASE IOLSTT;
	WHILE .IOLSTT NEQ 0 DO
	BEGIN
		IF .IOLSTT[OPRCLS] NEQ STATEMENT THEN
		!ONLY WHEN IT IS NOT A DO OR CONTINUE
		BEGIN
			CASE .IOLSTT[OPERSP] OF SET
			!DATACALL
			BEGIN
				PB_.IOLSTT[DCALLELEM];
				IF .PB[OPRCLS] EQL DATAOPR THEN
				SELECTIT(.PB)
				ELSE
				SELECTIT(.PB[ARG1PTR]);	!ITS AN ARRAYREF
			END;
			!
			!SLISTCALL
			!
			SELECTIT(.IOLSTT[SCALLELEM]);
			!
			!IOLSTCALL
			!
			SELECRED(.IOLSTT[IOLSTPTR]);
			!E1LIST
			BEGIN
				!NOT IN RELEASE 1
			END;
			!E2LIST
			!
			BEGIN
				!NOT IN RELEASE 1
			END;
		TES;
		END;		!IF ON IOLSTT NOT A STATEMENT
		IOLSTT_.IOLSTT[CLINK];
	END;						!WHILE STATEMENT
END;
ROUTINE SETREAD(IOLSTT)=
BEGIN
	!EXAMINE AN I/O LIST AND CALL
	!SETIT TO SET THE BIT IN THE ACC FIELD TO
	!INDICATE THE VARIABLE WAS ASSIGNED AT A PREDECESSOR
	MAP BASE IOLSTT;
	WHILE .IOLSTT NEQ 0 DO
	BEGIN
		IF .IOLSTT[OPRCLS] NEQ STATEMENT THEN
		!ONLY WHEN IT IS NOT A DO OR CONTINUE
		BEGIN
			CASE .IOLSTT[OPERSP] OF SET
			!DATACALL
			BEGIN
				PB_.IOLSTT[DCALLELEM];
				IF .PB[OPRCLS] EQL DATAOPR THEN
				SETIT(.PB)
				ELSE
				SETIT(.PB[ARG1PTR]);	!ITS AN ARRAYREF
			END;
			!
			!SLISTCALL
			!
			SETIT(.IOLSTT[SCALLELEM]);
			!
			!IOLSTCALL
			!
			SETREAD(.IOLSTT[IOLSTPTR]);
			!E1LIST
			BEGIN
				!NOT IN RELEASE 1
			END;
			!E2LIST
			!
			BEGIN
				!NOT IN RELEASE 1
			END;
		TES;
		END;		!IF ON IOLSTT NOT A STATEMENT
		IOLSTT_.IOLSTT[CLINK];
	END;						!WHILE STATEMENT
END;
ROUTINE CHKNAML(NLPTR)=
BEGIN
	!ROUTINE TO CHECK A NAME LIST.
	!IT:
	!	1. DETERMINES IF NLPTR POINTS TO A NAMELIST NAME
	!	   SYMBOL TABLE ENTRY
	!	2. IF SO, IT SEARCHS THE LINKED LIST OF NAMELIST
	!	  STATEMENTS FOR THE MATCHING NAMELIST
	!	3. IT THEN SETS THE BITS (SELECTIT,SETIT,SETGOTVAL)
	!	   USING THE DISPIX SET UP BY THE CALLER
	OWN BASE NPTR;
	LABEL NLLOK;
	MAP BASE NLPTR;

	EXTERNAL NAMLPTR;

	BIND M1RH=#000000777777;	!-1 IN RIGHT HALF WORD

	!FIRST SEE IF NLPTR POINTS TO A NAMELIST SYMBOL TABLE ENTRY

	IF .NLPTR NEQ 0 AND .NLPTR NEQ M1RH THEN
	BEGIN
		IF .NLPTR[IDATTRIBUT(NAMNAM)] THEN
		BEGIN
			NPTR_.NAMLPTR<LEFT>;
			!LOOK THRU LINKED LIST OF NAMELIST STATEMENT
			!FOR THIS NAME LIST
			NLLOK:
			WHILE .NPTR NEQ 0 DO
			BEGIN
				IF .NPTR[NAMLID] EQL .NLPTR THEN
					LEAVE NLLOK;
				NPTR_.NPTR[CLINK];
			END;

			!WE HAVE LOOKED AT LIST WE HAVE TO QUIT IF
			!NPTR IS ZERO
			IF .NPTR EQL 0 THEN RETURN;
			!NPTR POINTS TO THE NAME LIST STATEMENT ENTRY
			INCR I FROM 0 TO .NPTR[NAMCNT]-1 DO
				(.SETSEL[.DISPIX])(@(.NPTR[NAMLIST]+.I));
		END;
		!ITS NOT A NAME LIST NAME
	END;
END;
   #*S