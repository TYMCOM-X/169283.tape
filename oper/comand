      SUBROUTINE NEWLIX
C
C     THIS SUBROUTINE PULLS IN A NEW LINE OF INFORMATION
C
      INTEGER LISPOINT(51),ENTPOINT(301),MINTYP(300),ALLCOM(450)
      INTEGER IPAR(50),INLINE(80)
      COMMON /COMPKG/ IP,LISMAX,IPAR,INLINE,LISPOINT,ENTPOINT,MINTYP
      COMMON /COMPKG/ ALLCOM
C
      IF(INITIAL.EQ.1) GO TO 1
      INITIAL=1
      IPAR(2)=LOCF(INLINE)
      CALL INIT(IPAR)
C
C    TYPE PRE-LINE ACCEPTANCE CHARACTERS
      IF(IPAR(1).NE.5) GO TO 5
1     TYPE 3,IPAR(21)
3     FORMAT('+',A5,$)
C
5     CALL READ
C
C    SET LINE SCANNING POINTER TO 1
      IP=1
C
C    IGNORE EVERYTHING AFTER AN EXCLAMATION POINT(A COMMENT)
      IF(IPAR(3).EQ.0) GO TO 60
C
      DO 40 J=1,IPAR(3)
      IF(ICHAR(INLINE,J).EQ.IPAR(24)) GO TO 50
40    CONTINUE
C
      GO TO 60
50    IPAR(3)=J-1
C    TYPE POST LINE ACCEPTANCE CHARACTERS
60    IF(IPAR(1).NE.5) RETURN
      TYPE 3,IPAR(22)
C
      RETURN
C
      END
      SUBROUTINE NEWLINE
C
C     THIS SUBROUTINE PULLS IN A NEW LINE OF INFORMATION
C
      INTEGER LISPOINT(51),ENTPOINT(301),MINTYP(300),ALLCOM(450)
      INTEGER IPAR(50),INLINE(80)
      COMMON /COMPKG/ IP,LISMAX,IPAR,INLINE,LISPOINT,ENTPOINT,MINTYP
      COMMON /COMPKG/ ALLCOM
C
      INTEGER JNLINE(80)
      EQUIVALENCE (EOF,IPAR(6)),(LOL,IPAR(3))
      INTEGER SPACE
      DATA SPACE/32/
C
C    TYPE PRE-LINE ACCEPTANCE CHARACTERS
      IF(IPAR(1).NE.5) GO TO 5
      TYPE 3,IPAR(21)
3     FORMAT('+',A5,$)
C
5     READ(IPAR(1),10,END=EOF) (INLINE(I),I=1,80)
10    FORMAT(80A5)
C
C    SET LINE SCANNING POINTER TO 1
      IP=1
C
C    DETERMINE LENGTH OF LINE(IN 2 STEPS, FOR SPEED)
      DO 15 K=80,1,-1
      IF(INLINE(K).NE.'     ') GO TO 18
15    CONTINUE
      LOL=0
      GO TO 60
C
18    K=K*5
      DO 20 J=K,1,-1
      IF(ICHAR(INLINE,J).NE.SPACE) GO TO 30
20    CONTINUE
30    LOL=J
C    CHECK LAST CHARACTER IN LINE FOR CONTINUATION CHARACTER
      IF(ICHAR(INLINE,J).NE.IPAR(23)) GO TO 38
31    LOL=LOL-1
C    READ A NEW LINE OF DATA INTO ARRAY JNLINE
      READ(IPAR(1),10,END=EOF)(JNLINE(I),I=1,80)
C    FIND ITS SIZE IN WORDS
      DO 32 K=80,1,-1
      IF(JNLINE(K).NE.'     ') GO TO 33
32    CONTINUE
      GO TO 38
C
33    K=K*5
      DO 34 K1=K,1,-1
      IF(ICHAR(JNLINE,K1).NE.SPACE) GO TO 35
34    CONTINUE
C    SHOULDN'T EVER PASS THRU HERE
C    NOW TACK ON NEW LINE TO OLD, UNLESS LINE TOO LONG
C    (IGNORE CONTINUATION CHARACTER)
35    IF(LOL+K1.GT.400) GO TO IPAR(4)
      DO 36 L=1,K1
      IC=ICHAR(JNLINE,L)
      NPUT=LOL+L
36    CALL PUTCHR(INLINE,IC,NPUT)
      LOL=LOL+K1
C    IS THIS LINE CONTINUED?
      IF(ICHAR(INLINE,LOL).EQ.IPAR(23)) GO TO 31
C
C
C    IGNORE EVERYTHING AFTER AN EXCLAMATION POINT(A COMMENT)
C
38    DO 40 J=1,LOL
      IF(ICHAR(INLINE,J).EQ.IPAR(24)) GO TO 50
40    CONTINUE
C
      GO TO 60
50    LOL=J-1
C    TYPE POST-LINE ACCEPTANCE CHARACTERS
60    IF(IPAR(1).NE.5) RETURN
      TYPE 3,IPAR(22)
C
      RETURN
C
      END
      SUBROUTINE FILEOLD(FILNAM,USNAME,PROJ,PROG,RETURN)
C
C    This routine is used to scan for a legal filename.
C    In this version, FILNAM is single precision, & extensions illegal.
C    USNAME is a 3 word alpha array holding the username, which
C    optionally may precede the file name and be enclosed in
C    parentheses, in 940 style.  Alternatively, the project-programmer
C    numbers may appear appended to the name, enclosed in brackets,
C    in PDP-10 style.
C
C    RETURN is an integer returned by the subroutine, defined
C    as follows:
C
C     -N  An error was found at line location N.  Any partially
C         specified information is zeroed out.
C
C      0  Nothing more on input line
C
C      1  A simple filename was specified
C
C      2  A username was specified
C
C      3  A PPN was specified
C
C
      INTEGER LISPOINT(51),ENTPOINT(301),MINTYP(300),ALLCOM(450)
      INTEGER IPAR(50),INLINE(80)
      COMMON /COMPKG/ IP,LISMAX,IPAR,INLINE,LISPOINT,ENTPOINT,MINTYP
      COMMON /COMPKG/ ALLCOM
C
      INTEGER FILNAM,USNAME(3),PROJ,PROG,RETURN
      INTEGER RP,RB,DOT
      DATA LP,RP,LB,RB,DOT/40,41,91,93,46/
C
      INTEGER ZERO,NINE,A,Z,COMMA
      DATA ZERO,NINE,A,Z,COMMA/48,57,65,90,44/
C
C    INITIALIZATIONS
      RETURN=1
      DO 5 J=1,3
5     USNAME(J)=0
      FILNAM=0
      PROJ=0
      PROG=0
C
C    CHECK FOR END OF LINE CONDITION, CHOPPING OFF LEADING
C    DELIMITERS IN THE MEANTIME
10    IF(IP.GT.IPAR(3)) GO TO 170
      IF(.NOT.DELIMI(ICHAR(INLINE,IP))) GO TO 20
      IP=IP+1
      GO TO 10
C
20    IN=ICHAR(INLINE,IP)
      IPREL=IP
C    CHECK FOR LEFT PAREN - IF NOT, TRY FILE SCAN
      IF(IN.NE.LP) GO TO 60
C
C    IT IS, BEGIN GRABBING AND PACKING CHARACTERS, 12 MAX
      RETURN=2
      DO 30 J=1,13
      IPREL=IP+J
      K=(J-1)/5
      L=(J-1)-K*5
      ISHIFT=7*(4-L)+1
      IF(J.EQ.13) GO TO 160
      IF(IPREL.GT.IPAR(3)) GO TO 160
      IC=ICHAR(INLINE,IPREL)
C    DON'T THINK WE'LL ALLOW A RIGHT PAREN TO FOLLOW LEFT ONE
      IF(J.EQ.1 .AND. IC.EQ.RP) GO TO 160
C    DONE IF WE HAVE SOME CHARACTERS IN PARENS
      IF(IC.EQ.RP) GO TO 50
      USNAME(K+1)=USNAME(K+1)+LSH(IC,ISHIFT)
30    CONTINUE
C    SKIP OVER THE RIGHT PAREN
50    IPREL=IPREL+1
C
C    BEGIN NORMAL SCAN FOR SIMPLE FILENAME
60    IPRSAV=IPREL
      IF(IPREL.LE.IPAR(3)) GO TO 70
      IF(RETURN.EQ.2) GO TO 160
      GO TO 170
70    IC=ICHAR(INLINE,IPREL)
C    CHECK IF ALPHANUMERIC CHAR
      IF(.NOT.(IC.GE.ZERO.AND.IC.LE.NINE.OR.IC.GE.A.AND.IC.LE.Z))
     1GO TO 80
      JDF=IPREL-IPRSAV
C    CHECK IF TOO LONG A FILENAME
      IF(JDF.EQ.5) GO TO 160
      JSH=7*(4-JDF)+1
      FILNAM=FILNAM+LSH(IC,JSH)
      IPREL=IPREL+1
      IF(IPREL.GT.IPAR(3)) GO TO 150
      GO TO 70
C
C    FILE NAME STRING TERMINATED - CHECK THE TERMINATION CHAR
C    IF A DELIMITER, WE ARE DONE
80    IF(DELIM(IC)) GO TO 150
C    ONLY A LEFT BRACKET ALLOWED NOW
      IF(IC.NE.LB) GO TO 160
C    A USERNAME AND PROG-PROG NUMBER IS NOT ALLOWED
      IF(RETURN.EQ.2) GO TO 160
C
      RETURN=3
90    IPREL=IPREL+1
C    END OF LINE?
      IF(IPREL.GT.IPAR(3)) GO TO 160
      IC=ICHAR(INLINE,IPREL)
C    CHECK FOR A COMMA
      IF(IC.EQ.COMMA) GO TO 100
      IF(IC.LT.ZERO.OR.IC.GT.NINE) GO TO 160
      PROJ=PROJ*10+(IC-48)
      GO TO 90
C
100   IPREL=IPREL+1
      IF(IPREL.GT.IPAR(3)) GO TO 160
      IC=ICHAR(INLINE,IPREL)
C    CHECK FOR A RIGHT BRACKET
      IF(IC.EQ.RB) GO TO 110
      IF(IC.LT.0.OR. IC.GT.NINE) GO TO 160
      PROG=PROG*10+(IC-48)
      GO TO 100
C
C    DELIMITER OR END OF LINE MUST TERMINATE RIGHT BRACKET
110   IPREL=IPREL+1
      IF(IPREL.GT.IPAR(3)) GO TO 150
      IF(.NOT.DELIM(ICHAR(INLINE,IPREL))) GO TO 160
C
C    SUCCESSFUL TERMINATION
150   IP=IPREL
      RETURN
C
C    BAD TERMINATION
160   RETURN=-IPREL
C    ZERO OUT ALL POTENTIALLY INCORRECT INFO
      FILNAM=0
      USNAME(1)=0
      USNAME(2)=0
      USNAME(3)=0
      PROJ=0
      PROG=0
      CALL ERROR(RETURN)
      RETURN
C
C    END OF LINE TERMINATION - LEGAL
170   RETURN=0
      RETURN
      END
      SUBROUTINE FILE(FILNAM,RETURN)
C
C    This routine is used to scan for a full legal filename.
C    In this version, FILNAM is an array of five integer words.
C    A user name may precede the file name and be enclosed in
C    parentheses, in 940 style.  Alternatively, the project-programmer
C    numbers may appear appended to the name, enclosed in brackets,
C    in PDP-10 style.
C
C    RETURN is an integer returned by the subroutine, defined
C    as follows:
C
C     -N  An error was found at line location N.  Any partially
C         specified information is zeroed out.
C
C      0  Nothing more on input line
C
C      1  A simple filename was specified
C
C      2  A username was specified
C
C      3  A PPN was specified
C
C
      INTEGER LISPOINT(51),ENTPOINT(301),MINTYP(300),ALLCOM(450)
      INTEGER IPAR(50),INLINE(80)
      COMMON /COMPKG/ IP,LISMAX,IPAR,INLINE,LISPOINT,ENTPOINT,MINTYP
      COMMON /COMPKG/ ALLCOM
C
      INTEGER RETURN,FILNAM(5)
      INTEGER RP,RB,DOT
      DATA LP,RP,LB,RB,DOT/40,41,91,93,46/
C
      INTEGER ZERO,NINE,A,Z,COMMA
      DATA ZERO,NINE,A,Z,COMMA/48,57,65,90,44/
C
      LOGICAL B4DOT
C
C    INITIALIZATIONS
      RETURN=1
      DO 5 J=1,5
5     FILNAM(J)=0
      B4DOT=.TRUE.
      PROJ=0
      PROG=0
C
C    CHECK FOR END OF LINE CONDITION, CHOPPING OFF LEADING
C    DELIMITERS IN THE MEANTIME
10    IF(IP.GT.IPAR(3)) GO TO 170
      IF(.NOT.DELIMI(ICHAR(INLINE,IP))) GO TO 20
      IP=IP+1
      GO TO 10
C
20    IN=ICHAR(INLINE,IP)
      IPREL=1
      IPTRY=IP
C    CHECK FOR LEFT PAREN - IF NOT, TRY FILE SCAN
      IF(IN.NE.LP) GO TO 60
      CALL PUTCHR(FILNAM,IN,1)
C
C    IT IS, BEGIN GRABBING AND PACKING CHARACTERS, 12 MAX
      RETURN=2
30    IPREL=IPREL+1
      IPTRY=IPTRY+1
      IF(IPTRY.GT.IPAR(3)) GO TO 160
      IC=ICHAR(INLINE,IPTRY)
C    DON'T THINK WE'LL ALLOW A RIGHT PAREN TO FOLLOW LEFT ONE
      IF(IPREL.EQ.2 .AND. IC.EQ.RP) GO TO 160
C    DONE IF WE HAVE SOME CHARACTERS IN PARENS
      IF(IC.EQ.RP) GO TO 50
C    CHECK IF USERNAME TOO LONG
      IF(IPREL.EQ.14) GO TO 160
      CALL PUTCHR(FILNAM,IC,IPREL)
      GO TO 30
C    PROCESS RIGHT PAREN
50    CALL PUTCHR(FILNAM,IC,IPREL)
      IPREL=IPREL+1
      IPTRY=IPTRY+1
      IF(IPTRY.GT.IPAR(3)) GO TO 160
C
C    BEGIN NORMAL SCAN FOR SIMPLE FILENAME
60    IPREL1=IPREL
70    IC=ICHAR(INLINE,IPTRY)
C    CHECK FOR DOT (EXTENSION)
      IF(IC.EQ.DOT.AND.B4DOT) GO TO 75
C    CHECK IF ALPHANUMERIC CHAR
      IF(.NOT.(IC.GE.ZERO.AND.IC.LE.NINE.OR.IC.GE.A.AND.IC.LE.Z))
     1GO TO 80
74    JDF=IPREL-IPREL1+1
C    CHECK IF MORE THAN SIX CHARACTERS B4 DOT
      IF(B4DOT.AND.JDF.GT.6) GO TO 160
C    EXTENSION MUST BE 3 OR LESS CHARACTERS
      IF(.NOT.B4DOT.AND.(IPREL-IPREL2+1).GT.3) GO TO 160
C    TOTAL LENGTH MUST BE 10 OR LESS
      IF(JDF.GT.10) GO TO 160
C    ADD CHARACTER TO TOTAL FILENAME
      CALL PUTCHR(FILNAM,IC,IPREL)
78    IPREL=IPREL+1
      IPTRY=IPTRY+1
      IF(IPTRY.GT.IPAR(3)) GO TO 150
      GO TO 70
C
75    B4DOT=.FALSE.
      IPREL2=IPREL+1
      GO TO 74
C
C    FILE NAME STRING TERMINATED - CHECK THE TERMINATION CHAR
C    IF A DELIMITER, WE ARE DONE
80    IF(DELIM(IC)) GO TO 150
C    ONLY A LEFT BRACKET ALLOWED NOW
      IF(IC.NE.LB) GO TO 160
C    A USERNAME AND PROG-PROG NUMBER IS NOT ALLOWED
      IF(RETURN.EQ.2) GO TO 160
C
      RETURN=3
90    IPTRY=IPTRY+1
C    END OF LINE?
      IF(IPTRY.GT.IPAR(3)) GO TO 160
      IC=ICHAR(INLINE,IPTRY)
C    CHECK FOR A COMMA
      IF(IC.EQ.COMMA) GO TO 100
      IF(IC.LT.ZERO.OR.IC.GT.NINE) GO TO 160
      PROJ=PROJ*10+(IC-48)
      GO TO 90
C
100   IPTRY=IPTRY+1
      IF(IPTRY.GT.IPAR(3)) GO TO 160
      IC=ICHAR(INLINE,IPTRY)
C    CHECK FOR A RIGHT BRACKET
      IF(IC.EQ.RB) GO TO 110
      IF(IC.LT.0.OR. IC.GT.NINE) GO TO 160
      PROG=PROG*10+(IC-48)
      GO TO 100
C
C    DELIMITER OR END OF LINE MUST TERMINATE RIGHT BRACKET
110   IPTRY=IPTRY+1
      IF(IPTRY.GT.IPAR(3)) GO TO 150
      IF(.NOT.DELIM(ICHAR(INLINE,IPTRY))) GO TO 160
C
C    SUCCESSFUL TERMINATION
150   IP=IPTRY
      RETURN
C
C    BAD TERMINATION
160   RETURN=-IPTRY
C    ZERO OUT ALL POTENTIALLY INCORRECT INFO
      DO 165 J=1,5
165   FILNAM(J)=0
      CALL ERROR(RETURN)
      RETURN
C
C    END OF LINE TERMINATION - LEGAL
170   RETURN=0
      RETURN
      END
      SUBROUTINE FBREAK(TOTAL,USER,FILE,EXT)
C
C     THIS SUBROUTINE BREAKS UP AN ENTIRE FILE NAME INTO ITS COMPONENTS.
C     FOR EXAMPLE,
C
C     (DON)ABCDEF.DAT
C
C     MAY BE STORED IN THE ARRAY TOTAL (5 WORD INTEGER ARRAY).
C     UPON RETURN, USER (3 WORD INTEGER ARRAY) WILL HOLD DON,
C     FILE (2 WORD INTEGER ARRAY) WILL HOLD ABCDEF, AND EXT, AN
C     INTEGER, WILL HOLD DAT.
C
      INTEGER TOTAL(5),USER(3),FILE(2),EXT,LP,RP,DOT
      DATA LP,RP,DOT/40,41,46/
C
      IP=1
      IP1=0
      USER(1)=0
      USER(2)=0
      USER(3)=0
      FILE(1)=0
      FILE(2)=0
      EXT=0
C
      IC=ICHAR(TOTAL,IP)
      IF(IC.NE.LP) GO TO 30
10    IP=IP+1
      IC=ICHAR(TOTAL,IP)
      IF(IC.EQ.0) RETURN
      IF(IC.EQ.RP) GO TO 20
      IP1=IP-1
      CALL PUTCHR(USER,IC,IP1)
      GO TO 10
C
C    BEFORE THE DOT
20    IP1=0
25    IP=IP+1
      IC=ICHAR(TOTAL,IP)
30    IF(IC.EQ.0) RETURN
      IP1=IP1+1
      CALL PUTCHR(FILE,IC,IP1)
      IF(IC.EQ.DOT) GO TO 40
      GO TO 25
C
C    AFTER THE DOT
40    IP1=0
50    IP=IP+1
      IP1=IP1+1
      IC=ICHAR(TOTAL,IP)
      IF(IC.EQ.0) RETURN
      CALL PUTCHR(EXT,IC,IP1)
      GO TO 50
C
      RETURN
      END
      SUBROUTINE DFILE(FILNAM,USNAME,PROJ,PROG,RETURN)
C
C    This routine is used to scan for a full legal filename.
C    In this version, FILNAM is double precision, & extensions legal.
C    USNAME is a 3 word alpha array holding the username, which
C    optionally may precede the file name and be enclosed in
C    parentheses, in 940 style.  Alternatively, the project-programmer
C    numbers may appear appended to the name, enclosed in brackets,
C    in PDP-10 style.
C
C    RETURN is an integer returned by the subroutine, defined
C    as follows:
C
C     -N  An error was found at line location N.  Any partially
C         specified information is zeroed out.
C
C      0  Nothing more on input line
C
C      1  A simple filename was specified
C
C      2  A username was specified
C
C      3  A PPN was specified
C
C
      INTEGER LISPOINT(51),ENTPOINT(301),MINTYP(300),ALLCOM(450)
      INTEGER IPAR(50),INLINE(80)
      COMMON /COMPKG/ IP,LISMAX,IPAR,INLINE,LISPOINT,ENTPOINT,MINTYP
      COMMON /COMPKG/ ALLCOM
C
      DOUBLE PRECISION FILNAM,XXXX
      INTEGER FN(2),USNAME(3),PROJ,PROG,RETURN
      INTEGER RP,RB,DOT
      DATA LP,RP,LB,RB,DOT/40,41,91,93,46/
C
      INTEGER ZERO,NINE,A,Z,COMMA
      DATA ZERO,NINE,A,Z,COMMA/48,57,65,90,44/
C
      LOGICAL B4DOT
C
      EQUIVALENCE(XXXX,FN)
C
C    INITIALIZATIONS
      RETURN=1
      DO 5 J=1,3
5     USNAME(J)=0
      FN(1)=0
      FN(2)=0
      B4DOT=.TRUE.
      PROJ=0
      PROG=0
C
C    CHECK FOR END OF LINE CONDITION, CHOPPING OFF LEADING
C    DELIMITERS IN THE MEANTIME
10    IF(IP.GT.IPAR(3)) GO TO 170
      IF(.NOT.DELIMI(ICHAR(INLINE,IP))) GO TO 20
      IP=IP+1
      GO TO 10
C
20    IN=ICHAR(INLINE,IP)
      IPREL=IP
C    CHECK FOR LEFT PAREN - IF NOT, TRY FILE SCAN
      IF(IN.NE.LP) GO TO 60
C
C    IT IS, BEGIN GRABBING AND PACKING CHARACTERS, 12 MAX
      RETURN=2
      DO 30 J=1,13
      IPREL=IP+J
      K=(J-1)/5
      L=(J-1)-K*5
      ISHIFT=7*(4-L)+1
      IF(J.EQ.13) GO TO 160
      IF(IPREL.GT.IPAR(3)) GO TO 160
      IC=ICHAR(INLINE,IPREL)
C    DON'T THINK WE'LL ALLOW A RIGHT PAREN TO FOLLOW LEFT ONE
      IF(J.EQ.1 .AND. IC.EQ.RP) GO TO 160
C    DONE IF WE HAVE SOME CHARACTERS IN PARENS
      IF(IC.EQ.RP) GO TO 50
      USNAME(K+1)=USNAME(K+1)+LSH(IC,ISHIFT)
30    CONTINUE
C    SKIP OVER THE RIGHT PAREN
50    IPREL=IPREL+1
C
C    BEGIN NORMAL SCAN FOR SIMPLE FILENAME
60    IPRSAV=IPREL
      IF(IPREL.LE.IPAR(3)) GO TO 70
      IF(RETURN.EQ.2) GO TO 160
      GO TO 170
70    IC=ICHAR(INLINE,IPREL)
C    CHECK FOR DOT (EXTENSION)
      IF(IC.EQ.DOT.AND.B4DOT) GO TO 75
C    CHECK IF ALPHANUMERIC CHAR
      IF(.NOT.(IC.GE.ZERO.AND.IC.LE.NINE.OR.IC.GE.A.AND.IC.LE.Z))
     1GO TO 80
74    JDF=IPREL-IPRSAV
C    CHECK IF TOO LONG A FILENAME
      IF(JDF.EQ.10) GO TO 160
      IF(JDF.GE.5) GO TO 76
      JSH=7*(4-JDF)+1
      FN(1)=FN(1)+LSH(IC,JSH)
      GO TO 78
76    JSH=7*(9-JDF)+1
      FN(2)=FN(2)+LSH(IC,JSH)
78    IPREL=IPREL+1
      IF(IPREL.GT.IPAR(3)) GO TO 150
      GO TO 70
C
75    B4DOT=.FALSE.
      GO TO 74
C
C    FILE NAME STRING TERMINATED - CHECK THE TERMINATION CHAR
C    IF A DELIMITER, WE ARE DONE
80    IF(DELIM(IC)) GO TO 150
C    ONLY A LEFT BRACKET ALLOWED NOW
      IF(IC.NE.LB) GO TO 160
C    A USERNAME AND PROG-PROG NUMBER IS NOT ALLOWED
      IF(RETURN.EQ.2) GO TO 160
C
      RETURN=3
90    IPREL=IPREL+1
C    END OF LINE?
      IF(IPREL.GT.IPAR(3)) GO TO 160
      IC=ICHAR(INLINE,IPREL)
C    CHECK FOR A COMMA
      IF(IC.EQ.COMMA) GO TO 100
      IF(IC.LT.ZERO.OR.IC.GT.NINE) GO TO 160
      PROJ=PROJ*10+(IC-48)
      GO TO 90
C
100   IPREL=IPREL+1
      IF(IPREL.GT.IPAR(3)) GO TO 160
      IC=ICHAR(INLINE,IPREL)
C    CHECK FOR A RIGHT BRACKET
      IF(IC.EQ.RB) GO TO 110
      IF(IC.LT.0.OR. IC.GT.NINE) GO TO 160
      PROG=PROG*10+(IC-48)
      GO TO 100
C
C    DELIMITER OR END OF LINE MUST TERMINATE RIGHT BRACKET
110   IPREL=IPREL+1
      IF(IPREL.GT.IPAR(3)) GO TO 150
      IF(.NOT.DELIM(ICHAR(INLINE,IPREL))) GO TO 160
C
C    SUCCESSFUL TERMINATION
150   IP=IPREL
      FILNAM=XXXX
      RETURN
C
C    BAD TERMINATION
160   RETURN=-IPREL
C    ZERO OUT ALL POTENTIALLY INCORRECT INFO
      FILNAM=0
      USNAME(1)=0
      USNAME(2)=0
      USNAME(3)=0
      PROJ=0
      PROG=0
      CALL ERROR(RETURN)
      RETURN
C
C    END OF LINE TERMINATION - LEGAL
170   RETURN=0
      RETURN
      END
      SUBROUTINE NUMBER(VALUE,ISTAT)
C
C    THIS ROUTINE SCANS THE INPUT LINE FOR A LEGAL NUMBER IN
C    I, F, OR E FORMAT.
C
C    THE SUBROUTINE RETURNS +1 IN ISTAT IF A LEGAL NUMBER WAS SCANNED.
C    IVALUE RETURNS THE VALUE OF THE NUMBER.
C    ISTAT RETURNS ZERO IF NOTHING MORE IS ON THE LINE, AND
C    A NEGATIVE NUMBER IF THE STRING IS NOT A LEGAL NUMBER.  A
C    NUMBER IS DEFINED HERE AS ANY NUMBER ACCEPTABLE TO FORTRAN IN
C    A 'G' FORMAT SPECIFICATION.  LEADING BLANKS ARE IGNORED.  IF
C    ISTAT RETURNS A ZERO OR NEGATIVE NUMBER, ISTAT
C    IS SET TO ZERO.  IF ISTAT
C    RETURNS A NEGATIVE NUMBER, THE NEGATIVE OF ITS VALUE
C    INDICATES THE CHARACTER POSITION IN THE INPUT LINE THAT CAUSED
C    THE PROBLEM.  IN THIS CASE, THE SCANNING POINTER IS NOT ADVANCED
C    PAST THE FIRST NON-BLANK CHARACTER IN THE STRING WHICH IS TO BE
C    SCANNED FOR AN NUMBER.
C
      INTEGER LISPOINT(51),ENTPOINT(301),MINTYP(300),ALLCOM(450)
      INTEGER IPAR(50),INLINE(80)
      COMMON /COMPKG/ IP,LISMAX,IPAINE,LISPOINT,ENTPOINT,MINTYP
      COMMON /COMPKG/ ALLCOM
C
C    THE NEXT THREE LINES DEFINE THE ASCII CHARACTERS FOR THE PDP-10
      INTEGER PLUS,DOT,ZERO,NINE,E
      DATA PLUS,MINUS,DOT,ZERO,NINE,E/43,45,46,48,57,69/
      DATA MAXEXP/38/
C
      LOGICAL B4DOT,B4E
C
C    CHECK FOR THE END OF LINE CONDITION, CHOPPING OFF LEADING
C    DELIMITERS IN THE MEANTIME
   10 IF(IP.GT.IPAR(3)) GO TO 140
      IF(.NOT.DELIMI(ICHAR(INLINE,IP))) GO TO 20
      IP=IP+1
      GO TO 10
C
   20 ISIGN=1
      ISEXP=1
      IPREL=1
      VALUE=0.0
      P10=1.0
      IEXP=0
      JEXP=0
      B4DOT=.TRUE.
      B4E=.TRUE.
C
C    CHECK FOR AND PROCESS A LEADING PLUS OR MINUS SIGN
      IN=ICHAR(INLINE,IP)
      IF(IN.EQ.PLUS) GO TO 80
      IF(IN.EQ.MINUS) ISIGN=-1
      IF(IN.EQ.DOT) B4DOT=.FALSE.
      IF(ISIGN.EQ.-1 .OR. .NOT.B4DOT) GO TO 80
      GO TO 50
C
   30 IPTRY=IP+IPREL-1
C    HAVE WE GONE PAST THE END OF THE LINE?
      IF(IPTRY.GT.IPAR(3)) GO TO 130
   40 IN=ICHAR(INLINE,IPTRY)
   50 IF(DELIM(IN)) GO TO 130
C    IF WE HAVE ONE DOT, ANOTHER IS ILLEGAL
      IF(IN.EQ.DOT) GO TO 100
C    SO ALSO WITH 'E'
      IF(IN.EQ.E) GO TO 90
C    THERE MAY BE A '+' OR '-' AFTER 'E'
      IF(IN.EQ.PLUS .OR. IN.EQ.MINUS) GO TO 110
C
C    ASCII DIGIT MUST BE BETWEEN ASCII ZERO AND NINE, INCLUSIVELY
      IF(IN.LT.ZERO .OR. IN.GT.NINE) GO TO 120
C
      IF(.NOT.B4E) GO TO 70
      IF(.NOT.B4DOT) GO TO 60
      VALUE=10.*VALUE+FLOAT(IN-48)
      GO TO 80
   60 P10=P10*.1
      VALUE=VALUE+FLOAT(IN-48)*P10
      GO TO 80
C
C    PROCESS THE EXPONENT
   70 IEXP=IEXP*10+(IN-48)
C    SET EXPONENT PROCESSING FLAG
      JEXP=1
C    REJECT NUMBER IF EXPONENT EXCEEDS PDP-10 EXPONENT LIMITATION
      IF(IEXP.LE.MAXEXP) GO TO 80
C    BACK UP TO POINT TO FIRST DIGIT IN EXPONENT
      IPREL=IPREL-1
      GO TO 120
C
   80 IPREL=IPREL+1
      GO TO 30
C
C    PROCESS AN 'E'
   90 IF(.NOT.B4E) GO TO 120
      B4E=.FALSE.
      GO TO 80
C    PROCESS A '.'
  100 IF(.NOT.B4DOT) GO TO 120
      B4DOT=.FALSE.
      GO TO 80
C    PROCESS SIGN OF EXPONENT - IT MUST IMMEDIATELY FOLLOW IT
  110 IF(B4E) GO TO 120
C    CHECK EXPONENT SPECIFICATION FLAG
      IF(JEXP.EQ.1) GO TO 120
      IF(IN.EQ.MINUS) ISEXP=-1
      GO TO 80
C
C    TROUBLE (CAN'T USE IPTRY BELOW SINCE ITS UNDEFINED IF FIRST
C    CHARACTER IS ILLEGAL)
  120 ISTAT=-(IP+IPREL-1)
      VALUE=0.0
      CALL ERROR(ISTAT)
      RETURN
C
C    PROPER NUMBER - TERMINATION BY SPACE OR END OF LINE
  130 IP=IPTRY
      ISTAT=1
      VALUE=FLOAT(ISIGN)*VALUE*10.**(IEXP*ISEXP)
      RETURN
C
C    NOTHING MORE ON INPUT LINE
  140 ISTAT=0
      VALUE=0.0
      RETURN
C
      END
      SUBROUTINE INTEGER(INT,ISTAT)
C
C    THIS ROUTINE SCANS THE INPUT LINE FOR AN INTEGER.
C
C    ISTAT RETURNS +1 IF A LEGAL INTEGER WAS SCANNED, IN WHICH
C    CASE INT RETURNS THE VALUE OF THE INTEGER.
C    ISTAT RETURNS ZERO IF NOTHING MORE IS ON THE LINE, AND
C    A NEGATIVE NUMBER IF THE STRING IS NOT A LEGAL INTEGER.  AN
C    INTEGER IS DEFINED HERE AS A STRING OF DIGITS OPTIONALLY PRE-
C    CEDED BY A PLUS OR MINUS SIGN.  LEADING BLANKS ARE IGNORED.  IF
C    ISTAT RETURNS A ZERO OR NEGATIVE NUMBER, THE INTEGER
C    RETURNED IN INT IS SET TO ZERO.  IF ISTAT
C     RETURNS A NEGATIVE NUMBER, THE NEGATIVE OF ITS VALUE
C    INDICATES THE CHARACTER POSITION IN THE INPUT LINE THAT CAUSED
C    THE PROBLEM.  IN THIS CASE, THE SCANNING POINTER IS NOT ADVANCED
C    PAST THE FIRST NON-BLANK CHARACTER IN THE STRING WHICH IS TO BE
C    SCANNED FOR AN INTEGER.
C
      INTEGER LISPOINT(51),ENTPOINT(301),MINTYP(300),ALLCOM(450)
      INTEGER IPAR(50),INLINE(80)
      COMMON /COMPKG/ IP,LISMAX,IPAR,INLINE,LISPOINT,ENTPOINT,MINTYP
      COMMON /COMPKG/ ALLCOM
C
      INTEGER PLUS,ZERO,NINE
      DATA PLUS,MINUS,ZERO,NINE/43,45,48,57/
C
C    CHECK FOR THE END OF LINE CONDITION, CHOPPING OFF LEADING
C    DELIMITERS IN THE MEANTIME
   10 IF(IP.GT.IPAR(3)) GO TO 90
      IF(.NOT.DELIMI(ICHAR(INLINE,IP))) GO TO 20
      IP=IP+1
      GO TO 10
C
   20 ISIGN=1
      IPREL=1
      INT=0
C
C    CHECK FOR AND PROCESS A LEADING PLUS OR MINUS SIGN
      IN=ICHAR(INLINE,IP)
      IF(IN.EQ.PLUS) GO TO 60
      IF(IN.EQ.MINUS) ISIGN=-1
      IF(ISIGN.EQ.-1) GO TO 60
      GO TO 50
C
   30 IPTRY=IP+IPREL-1
C    HAVE WE GONE PAST THE END OF THE LINE?
      IF(IPTRY.GT.IPAR(3)) GO TO 80
   40 IN=ICHAR(INLINE,IPTRY)
   50 IF(DELIM(IN)) GO TO 80
C    ASCII DIGIT MUST BE BETWEEN ASCII ZERO AND NINE, INCLUSIVELY
      IF(IN.LT.ZERO .OR. IN.GT.NINE) GO TO 70
      INT=INT*10+(IN-48)
   60 IPREL=IPREL+1
      GO TO 30
C
C    TROUBLE (CAN'T USE IPTRY BELOW SINCE ITS UNDEFINED IF FIRST
C    CHARACTER IS ILLEGAL)
   70 ISTAT=-(IP+IPREL-1)
      INT=0
      CALL ERROR(ISTAT)
      RETURN
C
C    PROPER NUMBER - TERMINATION BY DELIMITER OR END OF LINE
   80 IP=IPTRY
      ISTAT=1
      INT=INT*ISIGN
      RETURN
C
C    NOTHING MORE ON INPUT LINE
   90 ISTAT=0
      INT=0
      RETURN
C
      END
      SUBROUTINE OCTAL(INT,ISTAT)
C
C    THIS ROUTINE SCANS THE INPUT LINE FOR AN INTEGER OCTAL NUMBER.
C
C    ISTAT RETURNS +1 IF A LEGAL INTEGER WAS SCANNED, IN WHICH
C    CASE INT RETURNS THE VALUE OF THE INTEGER.
C    ISTAT RETURNS ZERO IF NOTHING MORE IS ON THE LINE, AND
C    A NEGATIVE NUMBER IF THE STRING IS NOT A LEGAL INTEGER.  AN
C    INTEGER IS DEFINED HERE AS A STRING OF DIGITS OPTIONALLY PRE-
C    CEDED BY A PLUS OR MINUS SIGN.  LEADING BLANKS ARE IGNORED.  IF
C    ISTAT RETURNS A ZERO OR NEGATIVE NUMBER, THE INTEGER
C    RETURNED IN INT IS SET TO ZERO.  IF ISTAT
C     RETURNS A NEGATIVE NUMBER, THE NEGATIVE OF ITS VALUE
C    INDICATES THE CHARACTER POSITION IN THE INPUT LINE THAT CAUSED
C    THE PROBLEM.  IN THIS CASE, THE SCANNING POINTER IS NOT ADVANCED
C    PAST THE FIRST NON-BLANK CHARACTER IN THE STRING WHICH IS TO BE
C    SCANNED FOR AN INTEGER.
C
      INTEGER LISPOINT(51),ENTPOINT(301),MINTYP(300),ALLCOM(450)
      INTEGER IPAR(50),INLINE(80)
      COMMON /COMPKG/ IP,LISMAX,IPAR,INLINE,LISPOINT,ENTPOINT,MINTYP
      COMMON /COMPKG/ ALLCOM
C
      INTEGER PLUS,ZERO,SEVEN
      DATA PLUS,MINUS,ZERO,SEVEN/43,45,48,55/
C
C    CHECK FOR THE END OF LINE CONDITION, CHOPPING OFF LEADING
C    DELIMETERS IN THE MEANTIME
   10 IF(IP.GT.IPAR(3)) GO TO 90
      IF(.NOT.DELIMI(ICHAR(INLINE,IP))) GO TO 20
      IP=IP+1
      GO TO 10
C
   20 ISIGN=1
      IPREL=1
      INT=0
C
C    CHECK FOR AND PROCESS A LEADING PLUS OR MINUS SIGN
      IN=ICHAR(INLINE,IP)
      IF(IN.EQ.PLUS) GO TO 60
      IF(IN.EQ.MINUS) ISIGN=-1
      IF(ISIGN.EQ.-1) GO TO 60
      GO TO 50
C
   30 IPTRY=IP+IPREL-1
C    HAVE WE GONE PAST THE END OF THE LINE?
      IF(IPTRY.GT.IPAR(3)) GO TO 80
   40 IN=ICHAR(INLINE,IPTRY)
   50 IF(DELIM(IN)) GO TO 80
C    ASCII DIGIT MUST BE BETWEEN ASCII ZERO AND SEVEN, INCLUSIVELY
      IF(IN.LT.ZERO .OR. IN.GT.SEVEN) GO TO 70
      INT=INT*8+(IN-48)
   60 IPREL=IPREL+1
      GO TO 30
C
C    TROUBLE (CAN'T USE IPTRY BELOW SINCE ITS UNDEFINED IF FIRST
C    CHARACTER IS ILLEGAL)
   70 ISTAT=-(IP+IPREL-1)
      INT=0
      CALL ERROR(ISTAT)
      RETURN
C
C    PROPER NUMBER - TERMINATION BY DELIMETER OR END OF LINE
   80 IP=IPTRY
      ISTAT=1
      INT=INT*ISIGN
      RETURN
C
C    NOTHING MORE ON INPUT LINE
   90 ISTAT=0
      INT=0
      RETURN
C
      END
      SUBROUTINE LENTRY(LIST,ENTRY,FORM,UNIT,ERROR)
C
C    THIS ROUTINE IS USED TO LIST A COMMAND LIST ENTRY ON UNIT
C    'UNIT'.  'LIST' IS THE NUMBER OF THE LIST IN WHICH ENTRY NUMBER
C    'ENTRY' IS TO BE RETRIEVED.  IF EITHER 'LIST' OR 'ENTRY' IS
C    OUT OF BOUNDS, 'ERROR' IS SET TO 1 AND A RETURN IS MADE.
C    'ERROR' IS ZERO IF NO ERROR WAS ENCOUNTERED.
C
C    FORM, AN INTEGER AS ARE ALL THE OTHER ARGUMENTS, DEFINES
C    THE FORMAT OF THE PRINTOUT, AS FOLLOWS:
C
C     -K MEANS LIST ENTRY, APPENDING SPACES TO MAKE TOTAL FIELD
C        WIDTH EQUAL TO K
C
C      0 MEANS LIST ENTRY WITH NO TRAILING OR LEADING SPACES
C
C     +K MEANS LIST ENTRY, INSERTING SPACES IN FRONT TO MAKE TOTAL
C        WIDTH EQUAL TO K
C
C
      INTEGER LISPOINT(51),ENTPOINT(301),MINTYP(300),ALLCOM(450)
      INTEGER IPAR(50),INLINE(80)
      COMMON /COMPKG/ IP,LISMAX,IPAR,INLINE,LISPOINT,ENTPOINT,MINTYP
      COMMON /COMPKG/ ALLCOM
C
      INTEGER ENTRY,FORM,UNIT,ERROR
      INTEGER SPACE
      DATA SPACE/32/
C
      ERROR=0
C
C    CHECK FOR SPECIFICATION ERRORS
      IF(LIST.LE.0 .OR. LIST.GT.LISMAX) GO TO 100
      MX=LISPOINT(LIST+1)-LISPOINT(LIST)
      IF(ENTRY.LE.0 .OR. ENTRY.GT.MX) GO TO 100
C
C    COMPUTE LENGTH OF COMMAND ENTRY
      LENG=ENTPOINT(LISPOINT(LIST)+ENTRY)-ENTPOINT(LISPOINT(LIST)+ENTRY
     1-1)
C
C    COMPUTE DIFFERENCE
      IDIFF=0
      IF(FORM.NE.0) IDIFF=IABS(FORM)-LENG
      IF(IDIFF.LT.0) GO TO 100
      IF(FORM) 40,40,10
C
C    INSERT SPACES
10    IF(IDIFF.LT.1) GO TO 40
      DO 20 I=1,IDIFF
      IC=LSH(SPACE,29)
20    WRITE(UNIT,30) IC
30    FORMAT('+',A1,$)
C
C    NOW WRITE COMMAND
40    DO 50 I=1,LENG
      IC=LCH(LIST,ENTRY,I)
C    SHIFT TO PRINT IN A1 FORMAT
      JC=LSH(IC,29)
50    WRITE(UNIT,30) JC
      IF(FORM.GE.0) RETURN
C
C    APPEND SPACES
60    IF(IDIFF.EQ.0) RETURN
      DO 70 I=1,IDIFF
      IC=LSH(SPACE,29)
70    WRITE(UNIT,30) IC
      RETURN
C
C    ERROR OF SOME KIND
100   ERROR=1
      RETURN
C
      END
      FUNCTION NOWCHR(ISPACE)
C
C    THIS FUNCTION GETS THE NUMERIC VALUE OF THE CURRENT CHARACTER
C    UNDER ANALYSIS IN THE INPUT LINE.
C
C    IDUMMY IS A DUMMY INTEGER ARGUMENT
C
C    NOWCHR RETURNS -1 IF THE SCAN HAS MOVED PAST THE END OF THE LINE
C
      INTEGER LISPOINT(51),ENTPOINT(301),MINTYP(300),ALLCOM(450)
      INTEGER IPAR(50),INLINE(80)
      COMMON /COMPKG/ IP,LISMAX,IPAR,INLINE,LISPOINT,ENTPOINT,MINTYP
      COMMON /COMPKG/ ALLCOM
C
      IF(IP.GT.IPAR(3)) GO TO 10
5     NOWCHR=ICHAR(INLINE,IP)
      IF(ISPACE.NE.0 .OR. NOWCHR.NE.32) RETURN
      IP=IP+1
      GO TO 5
C
10    NOWCHR=-1
      RETURN
      END
C
C
      FUNCTION NEXTCHR(ISPACE)
C
C    THIS FUNCTION ADVANCES THE SCANNING LINE POINTER ONE POSITION
C    AND RETURNS THE VALUE OF THE NEW CHARACTER IT POINTS TO.
C
C    IF 'ISPACE' IS ZERO, BLANKS ARE IGNORED.  OTHERWISE,
C    THEY ARE TREATED AS ANY OTHER CHARACTER.
C
C    IF THE POINTER ADVANCES PAST THE END OF THE LOGICAL LINE, A
C    -1 IS RETURNED.
C
      INTEGER LISPOINT(51),ENTPOINT(301),MINTYP(300),ALLCOM(450)
      INTEGER IPAR(50),INLINE(80)
      COMMON /COMPKG/ IP,LISMAX,IPAR,INLINE,LISPOINT,ENTPOINT,MINTYP
      COMMON /COMPKG/ ALLCOM
C
      INTEGER SPACE
      DATA SPACE/32/
C
10    IP=IP+1
      IF(IP.GT.IPAR(3)) GO TO 20
      NEXTCHR=ICHAR(INLINE,IP)
      IF(ISPACE.NE.0) RETURN
      IF(NEXTCHR.EQ.SPACE) GO TO 10
      RETURN
C
20    NEXTCHR=-1
      RETURN
      END
      SUBROUTINE LINESAVE(IARRAY)
C
C    THIS ROUTINE SAVES THE INPUT LINE, IPAR ARRAY, IP, AND LISMAX
C    AND LISMAX IN A USER SUPPLIED ARRAY, WHICH MUST BE DIMENSIONED
C    TO AT LEAST 132.
C
      INTEGER LISPOINT(51),ENTPOINT(301),MINTYP(300),ALLCOM(450)
      INTEGER IPAR(50),INLINE(80)
      COMMON /COMPKG/ IP,LISMAX,IPAR,INLINE,LISPOINT,ENTPOINT,MINTYP
      COMMON /COMPKG/ ALLCOM
C
      INTEGER IARRAY(1),ISAV(132)
      EQUIVALENCE(ISAV(1),IP)
C
      DO 10 I=1,132
10    IARRAY(I)=ISAV(I)
C
      RETURN
      END
C
C
      SUBROUTINE LINERESTORE(IARRAY)
C
C    THIS ROUTINE IS THE COMPLEMENT OF ROUTINE LINESAVE, IN THAT
C    THE CONTENT OF USER SUPPLIED ARRAY 'IARRAY' IS INSERTED
C    INTO PART OF BLOCK COMMON.
C
      INTEGER LISPOINT(51),ENTPOINT(301),MINTYP(300),ALLCOM(450)
      INTEGER IPAR(50),INLINE(80)
      COMMON /COMPKG/ IP,LISMAX,IPAR,INLINE,LISPOINT,ENTPOINT,MINTYP
      COMMON /COMPKG/ ALLCOM
C
      INTEGER IARRAY(1),ISAV(132)
      EQUIVALENCE(ISAV(1),IP)
C
      DO 10 I=1,132
10    ISAV(I)=IARRAY(I)
C
      RETURN
      END
      FUNCTION KOM(LIST)
C
C    THIS FUNCTION IS SIMILAR IN OPERATION TO COMMAND.
C
C    LIST IS THE LIST IN WHICH TO SEARCH FOR THE COMMAND.  THE
C    FUNCTION RETURNS ISTAT (SEE COMMAND).  THE MATCHED COMMAND
C    (FIRST 5 CHARACTERS) IS STORED IN IPAR(28), AS IS USUAL WITH
C    COMMAND.
C
      CALL COMMAND(LIST,IW,ISTAT)
      KOM=ISTAT
      RETURN
      END
      SUBROUTINE COMMAND(LISTNO,IW,ISTAT)
C
C    THIS ROUTINE SCANS THE INPUT LINE FOR A MATCH ON ONE OF THE
C    COMMANDS(ENTRIES) IN THE SPECIFIED COMMAND LIST.  COMMANDS MAY BE
C    ABBREVIATED.  A COMMAND MAY BE TERMINATED BY EITHER ONE
C    OR MORE SPACES OR A CARRIAGE RETURN.
C
C    ISTAT RETURNS THE NUMERIC ORDER OF THE MATCHED COMMAND
C    RESIDING IN THE SPECIFIED LIST.
C
C    THE SECOND ARGUMENT, IW, RETURNS THE MATCHED COMMAND ITSELF, UP
C    TO A MAXIMUM OF 5 CHARACTERS.
C
C    IF NO MORE CHARACTERS ARE IN THE LINE, A ZERO IS RETURNED IN
C    ISTAT AND THE MATCHED COMMAND IS EMPTY.  LEADING SPACES ARE
C    ALWAYS IGNORED (SKIPPED OVER).
C
C    IF NO MATCH SHOULD OCCUR, THE NEGATIVE OF THE FURTHEST POSITION
C    ALONG THE INPUT LINE WHERE A MATCH FAILURE OCCURRED IS RETURNED.
C
C    IF LISTNO IS NEGATIVE, IT IMPLIES ONLY AN EXACT MATCH WITHIN
C    THAT LIST IS TO BE SOUGHT.
C
      INTEGER LISPOINT(51),ENTPOINT(301),MINTYP(300),ALLCOM(450)
      INTEGER IPAR(50),INLINE(80)
      COMMON /COMPKG/ IP,LISMAX,IPAR,INLINE,LISPOINT,ENTPOINT,MINTYP
      COMMON /COMPKG/ ALLCOM
C
      LOGICAL EXACT
C
      IF(LISTNO.EQ.0) RETURN
C
C    CHECK FOR EXACT MATCH SPEC
      EXACT=.FALSE.
      LIST=LISTNO
      IF(LISTNO.GT.0) GO TO 10
      LIST=-LISTNO
      EXACT=.TRUE.
C
C    CHECK FOR THE END OF LINE CONDITION, CHOPPING OFF LEADING
C    DELIMITERS IN THE MEANTIME
   10 IF(IP.GT.IPAR(3)) GO TO 110
      IF(.NOT.DELIMI(ICHAR(INLINE,IP))) GO TO 30
      IP=IP+1
      GO TO 10
C
C    MXPREL IS THE MAXIMUM RELATIVE POSITION OF A POTENTIALLY
C    SUCCESSFUL MATCH
   30 MXPREL=1
C
C    COMPUTE NUMBER OF ENTRIES IN LIST NUMBER 'LIST'
      NUMENT=LISPOINT(LIST+1)-LISPOINT(LIST)
C
C    SCAN EVERY ENTRY IN THE LIST, LOOKING FOR A MATCH
      DO 80 I=1,NUMENT
C    IPREL IS THE RELATIVE SCAN POINTER POSITION
      IPREL=1
C    COMPUTE MX, THE MAXIMUM NUMBER OF CHARACTERS IN ENTRY 'I'
      MX=ENTPOINT(LISPOINT(LIST)+I)-ENTPOINT(LISPOINT(LIST)+I-1)
C    COMPUTE IPTRY, THE CURRENT LINE POSITION UNDER EXAMINATION
   40 IPTRY=IP+IPREL-1
C    CHECK TO SEE IF WE ARE AT THE END OF THE LINE
      IF(IPTRY.GT.IPAR(3)) GO TO 60
C    'IN' IS THE CHARACTER UNDER CONSIDERATION IN THE INPUT LINE
      IN=ICHAR(INLINE,IPTRY)
C    IS IT A DELIMITER?
      IF(DELIM(IN)) GO TO 60
C    THIS CHARACTER IS NOT A DELIMITER - IF WE HAVE EXHAUSTED THE
C    COMMAND LIST ENTRY STRING, WE HAVE AN ERROR(IE, HELPS FOR HELP)
      IF(IPREL.GT.MX) GO TO 70
C    'IL' IS THE CHARACTER UNDER CONSIDERATION FROM THE COMMAND LIST
      IL=LCH(LIST,I,IPREL)
      IF(IN.NE.IL) GO TO 70
      IPREL=IPREL+1
      GO TO 40
C    COMMAND RECOGNIZED, MUST IT BE AN EXACT MATCH?
   60 IF(EXACT.AND.(IPREL-1).LT.MX) GO TO 70
C    NO, BUT IT MUST HAVE A MINIMUM LENGTH
      IF((IPREL-1).GE.MINTYP(LISPOINT(LIST)+I-1)) GO TO 90
C
C    MATCH FAILURE ON THIS ENTRY - SAVE MAX POSITION OF MATCH
   70 MXPREL=MAX0(MXPREL,IPREL)
   80 CONTINUE
C
C    NO MATCH
      ISTAT=-(IP+MXPREL-1)
      IW=0
      CALL ERROR(ISTAT)
      RETURN
C
C    SUCCESSFUL MATCH
   90 IP=IPTRY
      ISTAT=I
C
C    RETURN THE FIRST 5 CHARACTERS OF THE COMMAND MATCHED
      IW=0
      J=MIN0(MX,5)
      DO 100 K=1,J
      IL=LCH(LIST,I,K)
      ISHIFT=7*(5-K)+1
  100 IW=IW+LSH(IL,ISHIFT)
      IPAR(28)=IW
C
      RETURN
C
C    NOTHING MORE ON INPUT LINE
  110 ISTAT=0
      IW=0
      RETURN
C
      END
C
C
      FUNCTION LCH(LIST,ENTRY,POSITION)
C
C    THIS FUNCTION GETS THE VALUE OF A CHARACTER FROM LIST 'LIST',
C    ENTRY 'ENTRY', AND POSITION 'POSITION'.
C
      INTEGER LISPOINT(51),ENTPOINT(301),MINTYP(300),ALLCOM(450)
      INTEGER IPAR(50),INLINE(80)
      COMMON /COMPKG/ IP,LISMAX,IPAR,INLINE,LISPOINT,ENTPOINT,MINTYP
      COMMON /COMPKG/ ALLCOM
C
      INTEGER ENTRY,POSITION
C
C    FIRST COMPUTE THE ENTRY POINTER, J
   10 J=ENTPOINT(LISPOINT(LIST)+ENTRY-1)
C
C    ADD CHARACTER POSITION AND GET CHARACTER
      LCH=ICHAR(ALLCOM,J+POSITION-1)
C
      RETURN
      END
      SUBROUTINE ERROR(LOC)
C
C    THIS SUBROUTINE IS CALLED AFTER EVERY UNSUCCESSFUL SCAN ALONG
C    THE INPUT LINE.  (-LOC) IS THE CURSOR POSITION FROM WHICH THE UN-
C    SUCCESSFUL SCAN WAS ATTEMPTED.  IPAR(20) DETERMINES WHAT ACTION
C    IS TO BE TAKEN, AS DEFINED BELOW:
C
C    IPAR(20)           MEANING
C    --------   --------------------------------
C        0        NO ACTION TAKEN. ROUTINE SIMPLY RETURNS.
C
C       +K        OUTPUT AN UP-ARROW AT LOCATION (-LOC-1), BUT FIRST
C                 INSERT K-1 SPACES
C
C       -K        OUTPUT THE STRING (UP TO DELIMITER), ENCLOSED IN
C                 DOUBLE QUOTES, FOLLOWED BY A SPACE AND QUESTION
C                 MARK.  10 CHARACTERS IS THE MAXIMUM SIZE OF THE
C                 STRING PRINTED.  PRECEDE FIRST QUOTE WITH (-K-1)
C                 SPACES.
C
C    IF READING FROM A FILE, THE ENTIRE LINE WILL FIRST BE ECHOED.
C
C
      INTEGER LISPOINT(51),ENTPOINT(301),MINTYP(300),ALLCOM(450)
      INTEGER IPAR(50),INLINE(80)
      COMMON /COMPKG/ IP,LISMAX,IPAR,INLINE,LISPOINT,ENTPOINT,MINTYP
      COMMON /COMPKG/ ALLCOM
C
      INTEGER SPACE,ARROW,CR,BADSTR(2)
      DATA SPACE,ARROW,CR,LF/32,94,13,10/
C
C    RETURN IF NO ERROR INDICATION WANTED
      IF(IPAR(20).EQ.0) RETURN
C
C    IF READING FROM A FILE, PRINT THE BAD LINE FIRST
      IF(IPAR(1).EQ.5) GO TO 10
      CALL WRINLIN(5,1,IPAR(3))
10    NLOC=-LOC
      NLOC1=NLOC-1
      LEAD=IABS(IPAR(20))-1
      IF(LEAD.LT.1) GO TO 30
C    PRINT LEADING SPACES (UNLESS READING FROM A FILE)
      IF(IPAR(1).NE.5) GO TO 25
      DO 20 J=1,LEAD
20    CALL CPRINT(SPACE)
C
25    IF(IPAR(20).LT.0) GO TO 100
C    SPACE OUT TO JUST BEFORE ERROR
30    IF(NLOC1.LT.1) GO TO 50
      DO 40 J=1,NLOC1
40    CALL CPRINT(SPACE)
C    PRINT UP-ARROW, CARRIAGE RETURN, LINE FEED
50    CALL CPRINT(ARROW)
      CALL CPRINT(CR)
      CALL CPRINT(LF)
      RETURN
C
C    ERROR STRING IN QUOTES
100   CALL GETSTR(BADSTR,LENGTH,10)
      WRITE(5,110) BADSTR
110   FORMAT('+"',2A5,$)
      IF(LENGTH.EQ.10) WRITE(5,120)
120   FORMAT('+','...',$)
      WRITE(5,130)
130   FORMAT('+','" ?')
C
      RETURN
      END
      SUBROUTINE GETSTR(STRING,LENGTH,MAXLEN)
C
C    THIS ROUTINE GETS A STRING OF CHARACTERS FROM THE INPUT LINE.
C
C    THE STRING IS PACKED INTO INTEGER ARRAY STRING (5 CHARACTERS PER
C    WORD) AND LENGTH IS RETURNED AS THE NUMBER OF CHARACTERS
C    PACKED.  MAXLEN IS SPECIFIED AS THE MAXIMUM LENGTH OF THE STRING TO
C    BE PICKED UP, IN CHARACTERS.  IF MAXLEN IS POSITIVE, INITIAL
C    DELIMITERS ARE IGNORED.  IF MAXLEN IS NEGATIVE, STRING PICKUP BEGINS
C    AT THE CURRENT CHARACTER POSITION, THE ABSOLUTE VALUE OF MAXLEN
C    DETERMINING THE MAXIMUM LENGTH OF THE STRING TO BE PICKED UP.
C    STRING PICKUP TERMINATES AT EITHER AN END OF LINE, PACKING MAXLEN
C    CHARACTERS, OR HITTING A DELIMITER.
C
      INTEGER LISPOINT(51),ENTPOINT(301),MINTYP(300),ALLCOM(450)
      INTEGER IPAR(50),INLINE(80)
      COMMON /COMPKG/ IP,LISMAX,IPAR,INLINE,LISPOINT,ENTPOINT,MINTYP
      COMMON /COMPKG/ ALLCOM
C
      INTEGER STRING(1)
C
      LENGTH=0
      MAXL=MAXLEN
      IF(MAXLEN.LT.0) GO TO 20
C    SKIP INITIAL DELIMITERS
10    IF(.NOT.DELIMI(ICHAR(INLINE,IP))) GO TO 30
      IP=IP+1
      IF(IP.GT.IPAR(3)) RETURN
      GO TO 10
C
20    MAXL=-MAXLEN
C    ERASE STRING FIRST
30    DO 40 I=1,MAXL
40    CALL PUTCHR(STRING,0,I)
C
C    NOW GET THE STRING
50    IC=ICHAR(INLINE,IP)
      IF(DELIM(IC)) RETURN
      LENGTH=LENGTH+1
      CALL PUTCHR(STRING,IC,LENGTH)
      IP=IP+1
C    DONE IF HIT END OF LINE OR HAVE PACKED MAX NO. OF CHARACTERS
      IF(IP.GT.IPAR(3) .OR. LENGTH.EQ.MAXLEN) RETURN
      GO TO 50
      END
      SUBROUTINE ERRPNT(LEAD,LOC)
C
C    THIS SUBROUTINE MAY BE CALLED AFTER AN UNSUCCESSFUL SCAN FOR
C    AN ITEM ALONG THE INPUT LINE, AND CAUSES AN UP-ARROW TO POINT
C    TO THE CHARACTER CAUSING THE SCAN PROBLEM.
C
C    WHEN CALLED, 'LEAD' SPACES WILL BE OUTPUT FIRST.  THIS WILL SPACE
C    OVER ANY 'READY' SYMBOL.  THEN, (-LOC-1) SPACES FOLLOWED BY THE
C    ARROW WILL BE SENT TO THE TERMINAL.  IF 'LOC' IS POSITIVE, NO
C    ACTION WILL BE TAKEN.
C
C
      INTEGER LISPOINT(51),ENTPOINT(301),MINTYP(300),ALLCOM(450)
      INTEGER IPAR(50),INLINE(80)
      COMMON /COMPKG/ IP,LISMAX,IPAR,INLINE,LISPOINT,ENTPOINT,MINTYP
      COMMON /COMPKG/ ALLCOM
C
C
      INTEGER SPACE,ARROW,CR
      DATA SPACE,ARROW,CR/32,94,13/
C
      IF(LOC.GE.0) RETURN
C
C    IF READING FROM A FILE, PRINT THE BAD LINE FIRST
      IF(IPAR(1).EQ.5) GO TO 8
      CALL WRINLIN(5,1,IPAR(3))
C
8     NLOC=-LOC
      NLOC1=NLOC-1
C
      IF(LEAD.LT.1) GO TO 20
      DO 10 J=1,LEAD
10    CALL CPRINT(SPACE)
C
20    IF(NLOC.EQ.1) GO TO 40
      DO 30 J=1,NLOC1
30    CALL CPRINT(SPACE)
C
40    CALL CPRINT(ARROW)
      CALL CPRINT(CR)
      RETURN
      END
      SUBROUTINE WRINLIN(UNIT,BEGIN,END)
C
C    THIS ROUTINE WRITES ON UNIT 'UNIT', CHARACTERS FROM THE INPUT
C    LINE, FROM POSITION 'BEGIN' TO 'END'.
C
      INTEGER LISPOINT(51),ENTPOINT(301),MINTYP(300),ALLCOM(450)
      INTEGER IPAR(50),INLINE(80)
      COMMON /COMPKG/ IP,LISMAX,IPAR,INLINE,LISPOINT,ENTPOINT,MINTYP
      COMMON /COMPKG/ ALLCOM
C
      INTEGER SPACE,TERMINAL
      DATA SPACE,TERMINAL/32,5/
C
      INTEGER UNIT,BEGIN,END
C
      IDIF=END-BEGIN+1
      IF(IDIF.LT.1) RETURN
C
      DO 20 J=1,IDIF
      IPOS=BEGIN+J-1
      IC=ICHAR(INLINE,IPOS)
      IC=LSH(IC,29)
      IF(UNIT.NE.5) GO TO 15
      WRITE(UNIT,10) IC
10    FORMAT('+',A1,$)
      GO TO 20
15    WRITE(UNIT,16) IC
16    FORMAT(A1,$)
20    CONTINUE
C
      RETURN
      END
      LOGICAL FUNCTION DELIMI(K)
      DELIMI=DELIM(K)
      RETURN
      END
C
      LOGICAL FUNCTION DELIM(IC)
C    THIS FUNCTION TESTS CHARACTER IC TO SEE IF IT IS A DELIMITER.
C    IF IT IS, THE FUNCTION RETURNS TRUE.  IF NOT, FALSE IS RETURNED.
C
      INTEGER LISPOINT(51),ENTPOINT(301),MINTYP(300),ALLCOM(450)
      INTEGER IPAR(50),INLINE(80)
      COMMON /COMPKG/ IP,LISMAX,IPAR,INLINE,LISPOINT,ENTPOINT,MINTYP
      COMMON /COMPKG/ ALLCOM
C
      INTEGER SPACE,COMMA,ZERO,NINE,A,Z,DTYP
      EQUIVALENCE(IPAR(26),DTYP)
      DATA SPACE,COMMA,ZERO,NINE,A,Z/32,44,48,57,65,90/
C
      IF(DTYP.EQ.0) GO TO 100
      IF(DTYP.LT.0 .OR. DTYP.GT.5) TYPE 5,DTYP
5     FORMAT(' IPAR(26) INCORRECTLY SET TO:',I3)
C
      GO TO (10,20,30,40,50,60) DTYP
C
C    SPACE DELIMITER
10    IF(IC-SPACE) 120,130,120
C    COMMA DELIMITER
20    IF(IC-COMMA) 120,130,120
C    COMMA OR SPACE DELIMITER
30    IF(IC.EQ.SPACE .OR. IC.EQ.COMMA) GO TO 130
      GO TO 120
C    NON-ALPHA NUMERIC DELIMITER
40    IF(IC.GE.ZERO.AND.IC.LE.NINE.OR.IC.GE.A.AND.IC.LE.Z) GO TO 120
      GO TO 130
C    NON-ALPHA DELIMITER
50    IF(IC.GE.A .AND. IC.LE.Z) GO TO 120
      GO TO 130
C    NON-NUMERIC DELIMITER
60    IF(IC.GE.ZERO.AND.IC.LE.NINE) GO TO 120
      GO TO 130
C
C    STRING DEFINED DELIMITER(S)
100   DO 110 J=1,5
      IF(IC.EQ.ICHAR(IPAR(27),J)) GO TO 130
110   CONTINUE
C
120   DELIM=.FALSE.
      RETURN
C
130   DELIM=.TRUE.
      RETURN
      END
      SUBROUTINE PUTCHL(LIST,ENTRY,POSITION,NEWCHR)
C
      INTEGER LISPOINT(51),ENTPOINT(301),MINTYP(300),ALLCOM(450)
      INTEGER IPAR(50),INLINE(80)
      COMMON /COMPKG/ IP,LISMAX,IPAR,INLINE,LISPOINT,ENTPOINT,MINTYP
      COMMON /COMPKG/ ALLCOM
C
      INTEGER ENTRY,POSITION
C
      IF(LIST.GT.0 .AND.LIST.LE.LISMAX) GO TO 20
      TYPE 10,LIST
10    FORMAT(' BAD "LIST" ARGUMENT IN SUBROUTINE PUTCHL:',I3)
      RETURN
C
20    MAXENT=LISPOINT(LIST+1)-LISPOINT(LIST)
      JENT=LISPOINT(LIST)+ENTRY-1
      IF(ENTRY.GT.0 .AND. ENTRY.LE.MAXENT) GO TO 40
      TYPE 30,ENTRY
30    FORMAT(' BAD "ENTRY" ARGUMENT IN SUBROUTINE PUTCHL:',I3)
      RETURN
C
40    MAXPOS=ENTPOINT(JENT+1)-ENTPOINT(JENT)
      IF(POSITION.GT.0 .AND. POSITION.LE.MAXPOS) GO TO 60
      TYPE 50,POSITION
50    FORMAT(' BAD "POSITION" ARGUMENT IN SUBROUTINE PUTCHL:',I3)
      RETURN
C
60    IC=ENTPOINT(JENT)+POSITION-1
      CALL PUTCHR(ALLCOM,NEWCHR,IC)
      RETURN
      END
 > @X