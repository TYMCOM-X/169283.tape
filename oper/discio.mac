        PAGE
;**********************************************************
;
;       FILE - DISCIO.MAC
;       PACKAGE - DISC IO ROUTINES AND CREATE AND SETUP FUNCTIONS
;       CODED BY JOHN STALLINGS, 1/24/73
;
;**********************************************************
        PAGE
        TITLE   SYNDIC
SYNVER: XWD     1,1     ; VERSION NUMBER, COMPATIBILITY NUMBER
        INTERN  CREATE,SETUP,FCNVL1,FCNVL2,CHREAD,CHBASE
        INTERN  VERS,EOF1,EOF2,EOF3,LDATE1,LDATE2,MAXBID,MAXBLK
        INTERN  HLEN,HUSED,FLAGS,DCNT1,DCNT2,PBLEN,SYNVER,FDFREE
        INTERN  WRITFD,TRBASE
        EXTERN  SETCP,RB,WB,SETRWE
;
; ERROR MACRO
DEFINE ERROR (A)
<JSP 17,[MOVE 1,[^D'A]
JRST SYNERR]>
;
; RANDOM DEFINITIONS
BLEN=^D256      ; DATA BLOCK LENGTH
DWORDS=^D253    ; MAXIMUM NUMBER OF DATA WORDS IN BLOCK.
BUFF=15         ; REGISTER TO USE WITH BYTE POINTERS INTO DISC BUFFERS.
PBLOCK=16       ; REGISTER NUMBER FOR PARAMETER BLOCK ADDRESS
FDTYP=1         ; BLOCK TYPE FOR FILE DIRECTORY
MXTYP=2         ; BLOCK TYPE FOR MIX
IXTYP=3         ; BLOCK TYPE FOR IX
RDTYP=4         ; BLOCK TYPE FOR RAW DATA
STKLEN=20       ; PUSH DOWN STACK LENGTH
STACKP: XWD     -STKLEN,STACK-1 ; INITIAL STACK POINTER
;
; BYTE POINTERS FOR ACCESSING HEADER WORDS IN DISC BLOCK.
; ADDRESS OF DISC BLOCK MUST BE IN REGISTER BUFF.
BADDR1: POINT   36,1(BUFF),35
FN:     POINT   5,2(BUFF),4
BT:     POINT   5,2(BUFF),9
BADDR2: POINT   18,2(BUFF),35
;
; DEFINITIONS FOR ACCESSING DATA WITHIN PARAMETER BLOCK FOR A FILE.
; EACH BLOCK CONTAINS THE FD, 3 MIXS, 3 IXS AND SOME PARAMETERS DEFINING
; THE CURRENT STATE OF THE FILE.
DEFINE BUILD (A,B)
<X=0
IRP B
<B=A+X
X=X+1>>

; DEFINE FD AND IT'S LENGTH
FD=0
BUILD FD+3,<VERS,EOF1,EOF2,EOF3,LDATE1,LDATE2>
BUILD LDATE2+1,<MAXBID,MAXBLK,HLEN,HUSED,FLAGS,DCNT1,DCNT2,FDFREE>
FDLEN=FDFREE+5
; DEFINE THE MIXS
MIX1=FDLEN
IXADD1=MIX1+3
MIX2=MIX1+BLEN
IXADD2=MIX2+3
MIX3=MIX2+BLEN
IXADD3=MIX3+3
; DEFINE THE IXS
IX1=MIX3+BLEN
RAW1=IX1+3
IX2=IX1+BLEN
RAW2=IX2+3
IX3=IX2+BLEN
RAW3=IX3+3
; DEFINE WORDS CONTAINING IX NUMBERS, IOCS FILE NUMBER, IO FLAG.
BUILD IX3+BLEN,<IXN1,IXN2,IXN3,IFN,IO,PBLEN>
;
; POINTERS INTO PARAMETER BLOCK. REGISTER PBLOCK MUST CONTAIN
; ADDRESS OF CURRENT PARAMETER BLOCK.
; DESIGNED TO BE USED WITH INDEXING ON SUB-FILE NUMBER. FOR
; EXAMPLE, IF R1 CONTAINS THE SUB-FILE NUMBER THEN 
; "MOVE R2,@MXPTR-1(R1)" WOULD LOAD R2 WITH THE TRUE CORE ADDRESS
; OF THE MIX OF THE APPROPRIATE SUB-FILE.
IXNPTR: BYTE    (18)PBLOCK,IXN1,PBLOCK,IXN2,PBLOCK,IXN3
MXPTR:  BYTE    (18)PBLOCK,MIX1,PBLOCK,MIX2,PBLOCK,MIX3
MXDPTR: BYTE    (18)PBLOCK,IXADD1,PBLOCK,IXADD2,PBLOCK,IXADD3
IXPTR:  BYTE    (18)PBLOCK,IX1,PBLOCK,IX2,PBLOCK,IX3
IXDPTR: BYTE    (18)PBLOCK,RAW1,PBLOCK,RAW2,PBLOCK,RAW3
EOFPTR: BYTE    (18)PBLOCK,EOF1,PBLOCK,EOF2,PBLOCK,EOF3
;
;
; LOCAL VARIABLES AND TABLES
TRBASE: Z
DRET:   Z
FCNVL1: Z
FCNVL2: Z
SAVADR: Z
CDM:    Z
CFN:    Z
CADDR:  Z
MXFLG:  Z
FDFLG:  Z
IXFLG:  Z
SAVPT1: Z
SAVPT2: Z
SAVPT3: Z
ERRFLG: Z
CC1:    Z
CC2:    Z
TMP1:   Z
TMP2:   Z
TMP3:   Z
TMP4:   Z
TMP5:   Z
DSKBUF: BLOCK   BLEN
DBDATA=DSKBUF+BLEN-DWORDS
BLT1:   BLOCK   20
BLT2:   BLOCK   20
BLT3:   BLOCK   20
BLT4:   BLOCK   20
STACK:  BLOCK   STKLEN
NDICT=20
FTAB:   BLOCK   NDICT
DFTAB:  BLOCK   NDICT
DSAVE:  BLOCK   17
ERET1:  Z
ERET2:  Z
RET:    Z
DNUM:   Z
ERRCNT: Z
        PAGE
;** SUBROUTINE SETUP
; THIS SUBROUTINE SETS UP A DICT
; ARGUMENTS:
;       R1 = DNUM (DICT NUMBER, 0-15 DECIMAL)
;       R2 = ERR1 (FATAL ERROR RETURN LOCATION)
;       R3 = ERR2 (NON-FATAL ERROR RETURN LOCATION)
;       R4 = IFN (IOCS FILE NUMBER)
;       R5 = TAB (PARAMETER TABLE ADDRESS)
;       R6 = IO (POSITIVE FOR READ ONLY; NEGATIVE FOR READ/WRITE)
;       R7 = PARAMETER BLOCK LENGTH
SETUP:  CAIL    1,0
        CAILE   1,NDICT-1
        ERROR   -11
        SETZM   DFTAB(1)
        JSP     16,DINIT        ; INITIALIZE FUNCTION

        HRRZM   5,FTAB(1)       ; SAVE PARAMETER ADDRESS
        HLRZM   5,DFTAB(1)      ; SAVE PARAMETER BLOCK ID
        SKIPE   DFTAB(1)        ; IF WE HAVE AN ID, THEN WE HAVE OFFSET
        HRLM    10,DFTAB(1)

        MOVE    PBLOCK,5        ; SET UP REGISTER PBLOCK

        MOVEM   4,IFN(PBLOCK)   ; PUT IFN IN PARAMETER TABLE
        MOVEM   6,IO(PBLOCK)    ; PUT IO IN PARAMETER TABLE

        CAIGE   7,PBLEN         ; CHECK PARAM. BLOCK SIZE
        ERROR   -13

        MOVEM   PBLOCK,CC1      ; SET UP IOCS ERROR RETURN LOCATION
        MOVEM   17,CC2
        MOVE    1,4
        MOVEI   2,DSCERR
        JSP     17,SETRWE
        MOVE    PBLOCK,CC1
        MOVE    17,CC2

        MOVEI   1,FD(PBLOCK)    ; READ IN FD
        SETZ    2,
        PUSHJ   17,GREAD
        CAIE    4,FDTYP         ; CHECK BLOCK TYPE
        ERROR   -5
        HRRZ    1,VERS(PBLOCK)  ; CHECK VERSION DATE
        HRRZ    2,SYNVER
        CAME    1,2
        ERROR   -6

        MOVE    6,[XWD -3,1]    ; READ IN THREE MIXES
SETUP2: MOVEI   1,@MXPTR-1(6)
        HRRZ    2,6
        PUSHJ   17,GREAD
        CAME    3,2
        ERROR   -4
        CAIE    4,MXTYP
        ERROR   -5
        AOBJN   6,SETUP2

        SKIPL   IO(PBLOCK)      ; IS FILE OPENED FOR OUTPUT?
        JRST    SETUP3

        DATE    2,
        MOVEM   2,LDATE1(PBLOCK); SET UP DATES
        MSTIME  2,
        MOVEM   2,LDATE2(PBLOCK)

        MOVEI   1,FD(PBLOCK)    ; WRITE FD
        SETZ    2,
        MOVEI   4,FDTYP
        PUSHJ   17,GWRITE

SETUP3: SETOM   @IXNPTR         ; INDICATE NO IXES IN CORE
        SETOM   @IXNPTR+1
        SETOM   @IXNPTR+2
        SETOM   CFN             ; INDICATE NO RAW DATA IN CORE
        SETOM   CADDR

; CLEAN UP PHASE. CHECK FOR NON-FATAL ERRORS.
        MOVE    1,FLAGS(PBLOCK) ; CHECK FATAL ERROR FLAG
        TLNE    1,400000
        ERROR   -107

        PUSHJ   17,HCHECK       ; CHECK FOR HASH TABLE FULL
        JRST    .+2
        JRST    ADDID2
        MOVEI   1,2
RETURN: MOVEM   1,FCNVL1
        MOVEM   2,FCNVL2
        JRST    @RET

ADDID2: MOVE    2,HLEN(PBLOCK)  ; CHECK FOR HASH TABLE PRETTY FULL
        MULI    2,^D90
        DIVI    2,^D100
        CAMLE   2,HUSED(PBLOCK) ; IS IT 90% FULL?
        JRST    ADDID4
ADDID3: MOVEI   1,1
        JRST    RETURN

ADDID4: MOVE    2,EOF1(PBLOCK)  ; CAN WE DELETE 25% OF FILES 1 & 2 ?
        ADD     2,EOF2(PBLOCK)
        LSH     2,-2
        CAMG    2,DCNT1(PBLOCK)
        JRST    ADDID3

        MOVE    2,HLEN(PBLOCK)  ; CAN WE REDUCE SIZE OF HASH TABLE?
        MULI    2,9
        DIVI    2,16
        MOVE    3,HUSED(PBLOCK)
        ADD     3,DCNT2(PBLOCK)
        CAML    2,3
        JRST    ADDID3

        SETZ    1,              ; ALL OK, RETURN ZERO
        JRST    RETURN
        PAGE
;** SUBROUTINE CREATE
; THIS SUBROUTINE SETS UP A NEW SYN DICT
; ARGUMENTS:
;       R1 = DNUM (DICT NUMBER, 0-15 DECIMAL)
;       R2 = ERR1 (ERROR RETRN LOCATION FOR FATAL ERRORS)
;       R3 = ERR2 (ERROR RETURN FOR NON-FATAL ERRORS)
;       R4 = IFN (IOCS FILE NUMBER)
;       R5 = TAB (PARAMETER TABLE ADDRESS FOR THIS DICT)
;       R6 = IO (POSITIVE FOR READ ONLY; NEGATIVE FOR READ/WRITE)
;       R7 = TABL (PARAMETER TABLE LENGTH)
;       R8 = NENT (INITIAL NUMBER OF EXPECTED SYN IDS)
CREATE: CAIL    1,0
        CAILE   1,NDICT-1
        ERROR   -11
        SETZM   DFTAB(1)
        JSP     16,DINIT        ; INITIALIZE FUNCTION

        CAIGE   7,PBLEN         ; CHECK PARAM. BLOCK SIZE
        ERROR   -13

        HRRZM   5,FTAB(1)       ; PARAMETER BLOCK ADDRESS INTO TABLE
        HLRZM   5,DFTAB(1)      ; SAVE PARAMETER BLOCK ID
        SKIPE   DFTAB(1)        ; IF WE HAVE AN ID, THEN WE HAVE OFFSET
        HRLM    11,DFTAB(1)

        MOVE    PBLOCK,5        ; SET UP REGISTER PBLOCK

        HRLI    5,-PBLEN        ; ZERO PARAMETER BLOCK
        SETZM   0(5)
        AOBJN   5,.-1

        MOVEM   4,IFN(PBLOCK)   ; PUT IFN IN PARAMETER BLOCK
        MOVEM   6,IO(PBLOCK)    ; PUT IO IN PARAMETER BLOCK
        MOVEI   2,3
        MOVEM   2,MAXBLK(PBLOCK); SET UP PARAMETER MAXBLK
        MOVE    2,SYNVER
        MOVEM   2,VERS(PBLOCK)  ; SET UP PARAMETER VERS
        DATE    2,
        MOVEM   2,LDATE1(PBLOCK); SET UP PARAMETER LDATE1
        MSTIME  2,
        MOVEM   2,LDATE2(PBLOCK); SET UP PARAMETER LDATE2

        HRLZI   2,-HINTL        ; FIND PRIME FOR HASH TABLE LENGTH
        CAMG    10,HINT(2)
        JRST    .+3
        AOBJN   2,.-2
        MOVEI   2,HINTL-1
        MOVE    7,HINT(2)
        MOVEM   7,HLEN(PBLOCK)  ; SET UP HLEN PARAMETER

        SETOM   @IXNPTR         ; INDICATE NO IXES IN CORE
        SETOM   @IXNPTR+1
        SETOM   @IXNPTR+2
        SETOM   CFN             ; INDICATE NO RAW DATA IN CORE
        SETOM   CADDR

        MOVEM   PBLOCK,CC1      ; SET UP IOCS ERROR RETURN LOCATION
        MOVEM   17,CC2
        MOVE    1,4
        MOVEI   2,DSCERR
        JSP     17,SETRWE
        MOVE    PBLOCK,CC1
        MOVE    17,CC2

        MOVEI   1,FD(PBLOCK)    ; WRITE FD TO FILE
        SETZ    2,
        MOVEI   4,FDTYP
        PUSHJ   17,GWRITE

        MOVE    6,[XWD -3,1]    ; WRITE 3 MIXES TO FILE
CREAT2: MOVEI   1,@MXPTR-1(6)
        HRRZ    2,6
        MOVE    3,2
        MOVEI   4,MXTYP
        PUSHJ   17,GWRITE
        AOBJN   6,CREAT2

        SETZ    1,              ; RETURN ZERO
        JRST    RETURN
        RADIX   10
HINT:   EXP     83,131,199,293,449,673,1009,1511,2273,3413,5119,7687
        EXP     11527,17299,25943,38923,58379,87559,131363,197033
        EXP     295571,443363,665051,997573,1496359,2244533,3366821
        EXP     5050217,7575329,8097137
        RADIX   8
HINTL=.-HINT
        PAGE
CHBASE: CAIL    1,0
        CAILE   1,NDICT-1
        ERROR   -11
        MOVE    3,FTAB(1)
        SKIPLE  2
        MOVEM   2,FTAB(1)
        MOVE    1,3
        JRST    (17)
        PAGE
;** SUBROUTINE TO INITIALIZE A FUNCTION
DINIT:  MOVEM   16,DRET
        MOVEM   17,RET          ; SAVE RETURN LOCATION
        MOVEM   1,DNUM          ; SAVE DICTIONARY NUMBER
        MOVEM   2,ERET1         ; SAVE FATAL ERROR RETURN
        MOVEM   3,ERET2         ; SAVE NON-FATAL ERROR RETURN
        SETOM   ERRCNT          ; INITIALIZE ERROR FLAG
        MOVE    17,STACKP       ; SET UP PUSH DOWN STACK

        CAIL    1,0             ; CHECK DNUM
        CAILE   1,NDICT-1
        ERROR   -11
        SKIPN   DFTAB(1)        ; SEE IF PARAMETER BLOCK MAY MOVE
        JRST    DINIT2

; PARAMETER BLOCK IS RELOCATABLE. SAVE REGISTERS AND CALL
; OUTSIDE ROUTINE TO FIND PARAMETER BLOCK.
        MOVE    0,[XWD 1,DSAVE]
        BLT     0,DSAVE+16
        HRRZ    1,DFTAB(1)
        JSP     17,@TRBASE
        MOVE    2,DNUM
        MOVEM   1,FTAB(2)
        HLRZ    1,DFTAB(2)
        ADDM    1,FTAB(2)
        MOVE    0,[XWD DSAVE,1]
        BLT     0,17

DINIT2: MOVE    PBLOCK,FTAB(1)  ; SET UP REGISTER PBLOCK

        JRST    @DRET
        PAGE
;** SUBROUTINE WRITE
; THIS SUBROUTINE WRITES DATA TO A SUB-FILE.
; WARNING: IT IS CONNECTED TO SREAD AND GETIX VIA THE FOLLOWING
; VARIABLES -
;       SAVPT1 - INDEX INTO MIX
;       SAVPT2 - INDEX INTO IX
;       SAVPT3 - CORE ADDRESS OF IX
;       IXFLG - NEGATIVE IF IX NOT DEFINED
;       SAVADR - DISC ADDRESS OF IX
;       CFN - SUB-FILE NUMBER OF CURRENT DATA IN CORE
;       CADDR - BLOCK OF DATA CURRENTLY INCORE.
; ARGUMENTS:
;       R1 = SUB-FILE NUMBER
;       R2 = CORE ADDRESS TO WRITE FROM
;       R3 = DISC WORD ADDRESS TO BEGIN WRITING TO
;       R4 = NUMBER OF WORDS TO WRITE
WRITE:  MOVEM   0,BLT4          ; SAVE ALL REGISTERS
        MOVE    0,[XWD 1,BLT4+1]
        BLT     0,BLT4+17

        MOVEM   2,TMP2          ; CORE ADDRESS
        MOVEM   4,TMP3          ; WORD COUNT

        IDIVI   3,DWORDS
        MOVEM   3,TMP4          ; LOGICAL BLOCK NUMBER
        MOVEM   4,TMP5          ; WORD OFFSET

        SETZM   MXFLG           ; ZERO "WRITE MIX" FLAG
        SETZM   FDFLG           ; ZERO "WRITE FD" FLAG

WRITE2: MOVE    1,BLT4+1        ; READ IN NEXT LOGICAL BLOCK
        MOVE    2,TMP4
        PUSHJ   17,SREAD

        MOVEI   3,DWORDS        ; CALCULATE NUMBER OF WORDS TO MOVE
        SUB     3,TMP5
        CAMLE   3,TMP3
        MOVE    3,TMP3

        MOVN    4,3             ; DECREMENT REMAINING WORD COUNT
        ADDM    4,TMP3

        HRL     4,TMP2          ; SET UP DATA MOVE
        ADDM    3,TMP2          ; INCREMENT CORE ADDRESS
        HRRI    4,DBDATA
        ADD     4,TMP5
        ADDI    3,DBDATA
        ADD     3,TMP5
        SUBI    3,1
        BLT     4,0(3)          ; MOVE DATA

        SKIPL   IXFLG           ; DOES GETIX SAY IX WAS DEFINED?
        JRST    WRITE3

        MOVEI   3,@IXPTR-1(1)   ; ZERO OUT NEW IX
        MOVEM   3,SAVPT3        ; SAVE CORE ADDRESS OF IX
        HRLI    3,-BLEN
        SETZM   0(3)
        AOBJN   3,.-1

        IDIVI   2,DWORDS        ; INDICATE NEW IX IS IN CORE
        MOVEM   2,@IXNPTR-1(1)  ; BY SAVING IX NUMBER

        ADDI    3,@IXDPTR-1(1)  ; USE REMAINDER TO GET INDEX INTO IX
        MOVEM   3,SAVPT2

        AOS     4,MAXBLK(PBLOCK); GET NEW BLOCK NUMBER
        MOVEM   4,SAVADR        ; SAVE IT FOR WRITING IX
        MOVEM   4,@SAVPT1       ; PUT NEW ADDRESS IN MIX

        SETOM   MXFLG           ; INDICATE WE MUST WRITE MIX
        SETOM   FDFLG           ; INDICATE WE MUST WRITE FD
        JRST    WRIT31

WRITE3: SKIPLE  2,@SAVPT2       ; IS DATA BLOCK DEFINED?
        JRST    WRITE4          ; YES
        SETOM   FDFLG           ; GONNA HAVE TO WRITE OUT FD
WRIT31: AOS     2,MAXBLK(PBLOCK); GET NEW BLOCK NUMBER
        MOVEM   2,@SAVPT2       ; POINT IX TO NEW DATA BLOCK

        MOVE    3,1             ; WRITE OUT MODIFIED IX
        MOVE    1,SAVPT3
        MOVE    2,SAVADR
        MOVEI   4,IXTYP
        PUSHJ   17,GWRITE

        MOVE    1,BLT4+1        ; SUB-FILE NUMBER BACK INTO R1
        MOVE    2,MAXBLK(PBLOCK); NEW DISC ADDRESS INTO R2

WRITE4: MOVE    3,1             ; WRITE OUT DATA BLOCK
        MOVEI   1,DSKBUF
        MOVEI   4,RDTYP
        MOVE    5,TMP4
        PUSHJ   17,GWRITE

        AOS     TMP4            ; INCREMENT LOGICAL BLOCK NUMBER
        SETZM   TMP5            ; SET WORD OFFSET TO ZERO

        SKIPLE  TMP3            ; CHECK REMAINING WORD COUNT
        JRST    WRITE2          ; GO WRITE NEXT SEGMENT

        SKIPL   MXFLG           ; SHALL WE WRITE THE MIX?
        JRST    WRITE5
        MOVEI   1,@MXPTR-1(3)
        MOVE    2,3
        MOVEI   4,MXTYP
        PUSHJ   17,GWRITE

WRITE5: MOVE    1,BLT4+1        ; CHECK FOR NEW EOF
        MOVE    2,BLT4+3
        ADD     2,BLT4+4
        CAMG    2,@EOFPTR-1(1)
        JRST    WRIT51
        MOVEM   2,@EOFPTR-1(1)  ; SET UP EOF. WRITE FD
        JRST    WRIT52

WRIT51: SKIPL   FDFLG           ; SEE IF "WRITE FD" FLAG IS SET
        JRST    WRITE6
WRIT52: MOVEI   1,FD(PBLOCK)
        SETZ    2,
        MOVEI   4,FDTYP
        PUSHJ   17,GWRITE

WRITE6: MOVE    0,[XWD BLT4+1,1]; RESTORE ALL REGISTERS AND GO HOME.
        BLT     0,17
        MOVE    0,BLT4
        POPJ    17,
        PAGE
;** SUBROUTINE CHREAD
; DESIGNED TO ALLOW SIMPL CALLS DIRCTLY TO READ ROUTINE.
; ARGUMENTS:
;       R1 = DICT NUMBER
;       R2 = FATAL ERROR RETURN
;       R3 = NON-FATAL ERROR RETURN
;       R4 = SUB-FILE NUMBER
;       R5 = CORE ADDRESS TO READ INTO
;       R6 = DISC WORD ADDRESS TO READ FROM
;       R7 = NUMBER OF WORDS TO READ
CHREAD: JSP     16,DINIT
        MOVE    1,4
        MOVE    2,5
        MOVE    3,6
        MOVE    4,7
        PUSHJ   17,READ
        SETZ    1,
        JRST    RETURN
        PAGE
;** SUBROUTINE READ
; THIS SUBROUTINE READS DATA FROM A SUB-FILE.
; ARGUMENTS:
;       R1 = SUB-FILE NUMBER
;       R2 = CORE ADDRESS TO READ INTO
;       R3 = DISC WORD ADDRESS TO BEGIN READING FROM
;       R4 = NUMBER OF WORDS TO READ
READ:   PUSH    17,2            ; SAVE CRITICAL REGISTERS
        PUSH    17,3
        PUSH    17,4

        MOVEM   2,TMP2          ; SAVE CORE ADDRESS
        MOVEM   4,TMP3          ; WORD COUNT

        IDIVI   3,DWORDS
        MOVEM   3,TMP4          ; LOGICAL BLOCK NUMBER
        MOVEM   4,TMP5          ; WORD OFFSET IN BLOCK

READ2:  MOVE    2,TMP4          ; PICK UP LOGICAL BLOCK NUMBER
        AOS     TMP4            ; INCREMENT LOGICAL BLOCK NUMBER
        PUSHJ   17,SREAD        ; READ LOGICAL BLOCK

        MOVEI   3,DWORDS        ; CALCULATE NUMBER OF WORDS TO MOVE
        SUB     3,TMP5
        CAMLE   3,TMP3
        MOVE    3,TMP3

        MOVN    4,3             ; DECREMENT REMAINING WORD COUNT
        ADDM    4,TMP3

        MOVEI   2,DBDATA        ; SET UP DATA MOVE
        ADD     2,TMP5
        HRL     2,2
        HRR     2,TMP2
        ADDB    3,TMP2          ; INCREMENT WORD COUNT TOO. TRICKY.
        SUBI    3,1
        BLT     2,0(3)          ; MOVE DATA..

        SETZM   TMP5            ; SET WORD OFFSET TO ZERO

        SKIPLE  TMP3            ; CHECK REMAINING WORD COUNT
        JRST    READ2           ; GO READ NEXT BLOCK

        POP     17,4            ; RESTORE REGISTERS
        POP     17,3
        POP     17,2
        POPJ    17,
        PAGE
;** SUBROUTINE SREAD
; THIS SUBROUTINE READS ONE LOGICAL BLOCK FROM A SUB-FILE INTO THE
; BUFFER DSKBUF. THE LOGICAL BLOCK NUMBER IS RELATIVE TO THE
; SUB-FILE.
; ARGUMENTS:
;       R1 = SUB-FILE NUMBER
;       R2 = LOGICAL BLOCK NUMBER
SREAD:  MOVEM   0,BLT3
        MOVE    0,DNUM
        CAME    0,CDM
        JRST    SREAD2
        CAMN    1,CFN           ; SEE IF WE ALREADY HAVE BUFFER
        CAME    2,CADDR 
        JRST    SREAD2
        POPJ    17,             ; YES, SIMPLY RETURN

SREAD2: MOVEM   0,CDM           ; SAVE ALL REGISTERS
        MOVE    0,[XWD 1,BLT3+1]
        BLT     0,BLT3+17

        MOVEM   1,CFN           ; INDICATE WE HAVE READ BLOCK
        MOVEM   2,CADDR

        IDIVI   2,DWORDS        ; CALCULATE IX NUMBER
        PUSHJ   17,GETIX        ; GET PROPER IX INTO CORE
        JRST    SREAD4          ; T DEFINED. FAKE ZEROED BUFFER.

        ADDI    3,@IXDPTR-1(1)  ; CALCULATE POINTER INTO IX.
        MOVEM   3,SAVPT2        ; SAVE INDEX INTO IX
        SKIPG   2,@3            ; IS LOGICAL BLOCK DEFINED?
        JRST    SREAD4          ; NOPE. FAKE ZEROED BLOCK.

        MOVEI   1,DSKBUF        ; READ IN LOGICAL BLOCK
        PUSHJ   17,GREAD

        CAME    3,CFN           ; DO A LITTLE ERROR CHECKING
        ERROR   -4              ; WRONG FILE NUMBER
        CAIE    4,RDTYP
        ERROR   -5              ; WRONG BLOCK TYPE
        CAME    5,CADDR
        ERROR   -7              ; WRONG LOGICAL BLOCK NUMBER

        MOVE    1,CFN           ; SEE IF BLOCK CROSSES EOF
        MOVE    2,CADDR
        IMULI   2,DWORDS
        ADDI    2,DWORDS
        CAMG    2,@EOFPTR-1(1)
        JRST    SREAD3          ; NOPE

        SUB     2,@EOFPTR-1(1)  ; SET UP TO ZERO END OF BUFFER
        CAILE   2,DWORDS
        MOVEI   2,DWORDS
        MOVN    4,2
        HRL     4,4
        HRRI    4,DBDATA+DWORDS
        SUB     4,2

        SETZM   0(4)            ; ZERO END OF BUFFER
        AOBJN   4,.-1

SREAD3: MOVE    0,[XWD BLT3+1,1]; RESTORE ALL REGISTERS
        BLT     0,17
        MOVE    0,BLT3
        POPJ    17,             ; RETURN, ALL DONE

SREAD4: MOVE    3,[XWD -DWORDS,DBDATA]; ZERO BUFFER
        SETZM   0(3)
        AOBJN   3,.-1
        JRST    SREAD3
        PAGE
;** SUBROUTINE GETIX
; THIS SUBROUTINE GETS THE APPROPRIATE IX INTO CORE IF THE IX IS
; DEFINED, IN WHICH CASE THE ROUTINE RETURNS SKIPPING. OTHERWISE,
; IT RETURNS NOT SKIPPING...
; ARGUMENTS:
;       R1 = SUB-FILE NUMBER
;       R2 = IX NUMBER (0-252)
GETIX:  CAIL    2,0             ; CHECK FOR VALID IX NUMBER
        CAILE   2,DWORDS-1
        ERROR   -12

        CAME    2,@IXNPTR-1(1)  ; SEE IF WE ALREADY HAVE IX
        JRST    GETIX3
        PUSH    17,2
        ADDI    2,@MXDPTR-1(1)
        MOVEM   2,SAVPT1
        MOVE    2,0(2)
        MOVEM   2,SAVADR
        MOVEI   2,@IXPTR-1(1)
        MOVEM   2,SAVPT3
        POP     17,2
        JRST    GETIX2

GETIX3: MOVEM   0,BLT1          ; SAVE R0
        MOVE    0,2             ; SEE IF IX DEFINED
        ADDI    0,@MXDPTR-1(1)
        MOVEM   0,SAVPT1        ; SAVE INDEX INTO MIX
        SKIPLE  @0
        JRST    GETIX1
        MOVE    0,BLT1          ; RESTORE R0
        SETOM   IXFLG           ; INDICATE IX NOT DEFINED.
        POPJ    17,             ; RETURN NOT SKIPPING

GETIX1: MOVE    0,[XWD 1,BLT1+1]; SAVE OTHER REGISTERS
        BLT     0,BLT1+17

        MOVEM   2,@IXNPTR-1(1)  ; INDICATE WE HAVE NEW IX

        MOVE    2,@SAVPT1       ; PICK UP IX BLOCK ADDRESS
        MOVEM   2,SAVADR        ; SAVE DISC ADDRESS
        MOVEI   1,@IXPTR-1(1)   ; CALCULATE CORE ADDRESS FOR IX
        MOVEM   1,SAVPT3        ; SAVE CORE ADDRESS
        PUSHJ   17,GREAD        ; READ IX

        CAME    3,BLT1+1        ; DO ERROR CHECKING
        ERROR   -4              ; WRONG FILE NUMBER
        CAIE    4,IXTYP
        ERROR   -5              ; WRONG BLOCK TYPE

        MOVE    0,[XWD BLT1+1,1]; RESTORE ALL REGISTERS
        BLT     0,17
        MOVE    0,BLT1
GETIX2: AOS     0(17)           ; SET UP SKIP RETURN
        SETZM   IXFLG           ; SET FLAG SAYING IX DEFINED
        POPJ    17,
        PAGE
;** SUBROUTINE GREAD **
; THIS ROUTINE READS ONE BLOCK OF 256 WORDS FROM A FILE.
; ARGUMENTS:
;       R1 = CORE ADDRESS OF START OF BUFFER.
;       R2 = BLOCK NUMBER TO READ.
; RETURNS:
;       R3 = FN (FILE NUMBER, 1-3)
;       R4 = BT (BLOCK TYPE)
;       R5 = BADDR2 (LOGICAL BLOCK NUMBER RELATIVE TO A SUB-FILE)
GREAD:  SETZM   ERRFLG          ; DISC ERRORS ARE READ ERRORS
        MOVEM   0,BLT2          ; SAVE R0 SO WE CAN SET UP BLT
        MOVE    0,[XWD 1,BLT2+1]; SET UP BLT
        BLT     0,BLT2+17       ; SAVE ALL REGISTERS

        IMULI   2,BLEN          ; CALCULATE CURSOR POSITION IN WORDS.
        MOVE    1,IFN(PBLOCK)   ; PICK UP IOCS FILE NUMBER.
        MOVEM   1,TMP1          ; SAVE IOCS FILE NUMBER.
        JSP     17,SETCP        ; SET CURSOR..

        MOVE    1,TMP1          ; PICK UP IOCS FILE NUMBER AGAIN.
        MOVEI   2,BLEN          ; PICK UP BLOCK LENGTH.
        MOVE    3,BLT2+1        ; PICK UP CORE ADDRESS OF BUFFER.
        JSP     17,RB           ; READ FILE.

        MOVE    BUFF,BLT2+1     ; SET UP BUFF TO USE WITH BYTE INST.
        LDB     3,BADDR1        ; GET ADDRESS BLOCK THINKS IT IS.
        CAME    3,BLT2+2        ; SEE IF THAT IS WHAT WE WANTED.
        ERROR   -3

        SETZ    3,              ; SET UP TO CHECKSUM BLOCK
        HRLI    4,1-BLEN
        HRR     4,BLT2+1
        JOV     .+1

        ADD     3,1(4)          ; ADD IN NEXT WORD
        JOV     .+2             ; IF OVERFLOW, ADD IN ANOTHER ONE.
        JRST    .+2
        AOS     3
        AOBJN   4,.-4

        CAME    3,0(BUFF)       ; COMPARE CHECKSUMS
        ERROR   -2

        MOVE    0,[XWD BLT2+1,1]
        BLT     0,17
        MOVE    0,BLT2

        EXCH    BUFF,1          ; BUFFER ADDRESS BACK INTO BUFF.
        LDB     3,FN            ; PICK UP RETURN ARGUMENTS.
        LDB     4,BT
        LDB     5,BADDR2

        EXCH    BUFF,1          ; RESTORE R1 AND BUFF
        POPJ    17,             ; RETURN
        PAGE
;** SUBROUTINE TO WRITE FD
; NO REGISTERS PRESERVED

WRITFD: JSP     16,DINIT        ; EXTERNAL ENTRY POINT
        PUSHJ   17,FDWRIT
        SETZ    1,
        JRST    RETURN
FDWRIT: MOVEI   1,FD(PBLOCK)    ; INTERNAL ENTRY POINT
        SETZ    2,
        MOVEI   4,FDTYP
        PUSHJ   17,GWRITE
        POPJ    17,
        PAGE
;** SUBROUTINE GWRITE
; THIS SUBROUTINE WRITES ONE BLOCK OF 256 WORDS TO A FILE.
; ARGUMENTS:
;       R1 = CORE ADDRESS OF START OF BUFFER
;       R2 = BLOCK NUMBER TO WRITE TO
;       R3 = FN (SUB-FILE NUMBER)
;       R4 = BT (BLOCK TYPE)
;       R5 = BADDR2 (LOGICAL BLOCK NUMBER RELATIVE TO A SUB-FILE)
GWRITE: SETOM   ERRFLG          ; DISC ERRORS ARE WRITE ERRORS
        MOVEM   0,BLT2          ; SAVE R0 SO WE CAN SET UP BLT
        MOVE    0,[XWD 1,BLT2+1]; SET UP BLT
        BLT     0,BLT2+17       ; SAVE ALL REGISTERS

        SKIPL   IO(PBLOCK)      ; IS FILE READ/WRITE?
        ERROR   -100

        MOVE    BUFF,1          ; SET UP BUFF FOR BYTE INSTS.
        DPB     2,BADDR1        ; SET UP HEADER BLOCK
        DPB     3,FN
        DPB     4,BT
        DPB     5,BADDR2

        SETZ    3,              ; SET UP TO CHECKSUM BLOCK
        HRLI    4,1-BLEN
        HRR     4,1
        JOV     .+1

        ADD     3,1(4)          ; ADD IN NEXT WORD
        JOV     .+2
        JRST    .+2
        AOS     3               ; IF OVERFLOW, ADD IN EXTRA ONE
        AOBJN   4,.-4
        MOVEM   3,0(1)

        IMULI   2,BLEN          ; CALCULATE CURSOR POSITION IN WORDS
        MOVE    1,IFN(PBLOCK)   ; PICK UP IOCS FILE NUMBER
        MOVEM   1,TMP1          ; SAVE IOCS FILE NUMBER
        JSP     17,SETCP        ; SET CURSOR

        MOVE    1,TMP1          ; PICK UP IOCS FILE NUMBER AGAIN
        MOVEI   2,BLEN          ; PICK UP BLOCK LENGTH
        MOVE    3,BLT2+1        ; PICK UP BUFFER ADDRESS
        JSP     17,WB           ; WRITE BLOCK

        MOVE    0,[XWD BLT2+1,1]; RESTORE ALL REGISTERS
        BLT     0,17
        MOVE    0,BLT2
        POPJ    17,             ; RETURN
        PAGE
; ERROR RETURN FOR IOCS CALLS
DSCERR: MOVEI   1,-1            ; INDICATE READ ERROR OR WRITE ERROR
        SKIPE   ERRFLG
        MOVEI   1,^D-8
        JRST    SYNERR
;
; ERROR HANDLER
SYNERR: MOVEM   1,FCNVL1
        MOVEM   2,FCNVL2
        CAMGE   1,[^D-99]
        JRST    SOFT

        AOS     2,ERRCNT        ; INCREMENT FATAL ERROR COUNTER
        CAIE    2,0             ; HAVE WE BEEN HERE BEFORE?
        JRST    HARD            ; YES, SKIP TRYING TO WRITE FD

        MOVE    2,DNUM          ; GET DICT NUMBER
        CAIL    2,0             ; SEE IF IT IS VALID
        CAILE   2,NDICT-1
        JRST    HARD            ; NOPE. WE CAN'T WRITE FD

        MOVE    PBLOCK,FTAB(2)  ; SET UP REGISTER PBLOCK

        SKIPL   IO(PBLOCK)      ; IS FILE READ/WRITE?
        JRST    HARD            ; NOPE

        MOVE    2,[XWD 400000,0]; SET FATAL ERROR FLAG
        IORM    2,FLAGS(PBLOCK)

        MOVE    17,STACKP       ; SET UP PUSH DOWN STACK
        PUSH    17,1            ; AND SAVE ERROR CODE

        MOVEI   1,FD(PBLOCK)    ; WRITE FD
        SETZ    2,
        MOVEI   4,FDTYP
        PUSHJ   17,GWRITE

        POP     17,1            ; RESTORE ERROR CODE
HARD:   SKIPG   ERET1
        JRST    @RET
        JRST    @ERET1

SOFT:   SKIPG   ERET2
        JRST    @RET
        JRST    @ERET2
        END
   @.N