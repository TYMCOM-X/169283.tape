!THE STA1 MODULE MUST BE COMPILED IN THE ORDER: ST1HD,FIRST,TABLES,META72,STAMN1
!***COPYRIGHT 1972, DIGITAL EQUIPEMENT CORP., MAYNARD, MASS.***
!AUTHOR: T.E. OSTEN
GLOBAL BIND STA1V=43;	!2-MAY-73
	SWITCHES LIST;
!	EXTERNAL PROGNAME,OUTZ,SCAN;
!THIS FORWARD DECLARATION AND THE FOLLOWING ROUTINES
!WERE PRODUCED BY THE FORTRAN PROGRAM HASHGEN.F4.
!THE NUMBER IN COMMENT'S IS THE STATEMENTS LOCATION
!IN THE HASH TABLE .
FORWARD
%  3%	DATASTA,	!DATA - P.39
%  8%	PRINSTA,	!PRINT - P.28
% 10%	OUTPSTA,	!OUTPUT - P.27
% 18%	OPENSTA,	!OPEN - P.36
% 34%	FINDSTA,	!FIND - P.38
% 39%	REWISTA,	!REWIND - P.34
% 45%	RERESTA,	!REREAD - P.32
% 63%	BKSPST,	!BACKSPACE OR BACKFILE - P.33
% 67%	DECOSTA,	!DECODE - P.31
% 83%	CLOSSTA,	!CLOSE - P.37
% 84%	ENDFSTA,	!ENDFILE - P.35
% 95%	ENCOSTA,	!ENCODE - P.30
%113%	TYPESTA;	!TYPE - P.29
GLOBAL ROUTINE BLDUTILITY(NODEDATA)=
BEGIN
%
ROUTINE BUILDS A STATEMENT NODE FOR REWIND AND UNLOAD STATEMENTS 

STK[0] CONTAINS A PTR TO A PTR TO A BLOCK OF 2WORDS
	1. CHOICE 1(CONSTANT) OR 2(VARIABLE)
	2. PTR TO CONSTANT NODE OR SYNTAX OUTPUT FROM PARSE OF VARIABLESPEC

BLDVAR IS CALLED IF CHOICE 2 TO BUILD A VARIABLE REFERENCE NODE

%
EXTERNAL NAME,NEWENTRY,STK,SAVSPACE,BLDVAR;
MAP BASE T1:T2;
REGISTER BASE R2;
MACRO ERR55=(ERROUT(55))$;
MACRO ELMNT=0,0,FULL$, ELMNT1=0,1,FULL$, ELMNT2=0,2,FULL$;

	T1_@(.STK[0]+1);
	IF .T1[ELMNT] NEQ 1 THEN R2_ BLDVAR(.T1[ELMNT1]) ELSE R2 _ .T1[ELMNT1];
	IF .R2[VALTYPE] NEQ INTEGER THEN ERR55; !NON-INTEGER UNIT
	NAME _ IDOFSTATEMENT _ .NODEDATA; NAME<RIGHT> _ SORTAB;
	T1 _ NEWENTRY(); !MAKING SORCE NODE
	T1[IOUNIT] _ .R2;
	 SAVSPACE(.STK[0]<LEFT>,.STK[0]);
END;	!OF BLDUTILITY
GLOBAL ROUTINE BLDREPT(NODEDATA)=
BEGIN
%
ROUTINE BUILDS STATEMENT NODES FOR THE STATEMENTS ENDFILE,
BACKSPACE,BACKFILE,SKIPRECORD,SKIPFILE

NODEDATA CONTAINS THE STATEMENT ID

RHE ROUTINE EXPECTS STK[0] TO CONTAINA PTR TO A 3 WORD DATA NODE OF THE FORM
	0. CHOICE CODE FOR CONSTANT OR VARIABLESPEC
	1. PTR TO CONSTANT NODE OR OUTPUT FROM VARIABLESPEC PARSE
	2. 0 IF NOE REPEAT OPTION
	   PTR TO CONSTANT NODE OR OUTPUT FROM VARIABLESPEC PARSE

%
EXTERNAL STK,NEWENTRY,NAME,SAVSPACE,BLDVAR;
LOCAL U,REPT;
MACRO ELMNT=0,0,FULL$, ELMNT1=0,1,FULL$, ELMNT2=0,2,FULL$;
MACRO ERR55 = (ERROUT(55))$;
REGISTER R1,R2;
MAP BASE R1:R2;
	REPT _ 0;
	R2 _ @.STK[0];
	R1 _ .R2[ELMNT];   SAVSPACE(0,.R2);
	R2 _ .R1[ELMNT2];	!PTR TO CONSTANT OR VARIABLESPEC
	IF .R1[ELMNT1] NEQ 1 THEN R2 _ BLDVAR(.R2); !RETURNS PTR TO VARIABLE REFERENCE NODE
	IF .R2[VALTYPE] NEQ INTEGER THEN ERR55;
	U _ .R2; !PTR TO UNIT DESIGNATOR
	R2 _ .R1+4;	!SET NEW POINTER AROUND USELESS INFO
	IF .R2[ELMNT] NEQ 0
	THEN !OPTIONAL REPEAT SEEN
	  BEGIN
		R2 _ .R2[ELMNT1];	!POINT TO CONSTANT OR VARIABLE SPEC
		IF .R2[ELMNT] NEQ 1
		THEN REPT _ BLDVAR(.R2[ELMNT1])
		ELSE REPT _ .R2[ELMNT1];
		SAVSPACE(.R2<LEFT>,.R2);
	  END;
	SAVSPACE(.R1<LEFT>,.R1);
	NAME _ IDOFSTATEMENT _ .NODEDATA; NAME<RIGHT> _ SORTAB;
	R2 _ NEWENTRY();
	R2[IOUNIT] _ .U; R2[IOREPT] _ .REPT;
	SAVSPACE(0,.STK[0]);
	.VREG
END;	!OF ROUTINE BLDREPT
GLOBAL ROUTINE OUTPSTA=
BEGIN
	MAP BASE T1:T2;REGISTER BASE R1:R2;
	EXTERNAL STK,SAVSPACE %(SIZE,LOC)%,BLDVAR %(VPNT)%,DATALIST %(LPNT)%,
		 NEWENTRY %()%,CORMAN %()%,TYPE;
	MACRO
	ELMNT=0,0,FULL$,ELMNT1=0,1,FULL$,ELMNT2=0,2,FULL$,
	ERR15(X)=(ENTRY[1]_X;ENTRY[2]_PLIT'INTEGER';RETURN ERROUT(E15))$;
	BIND OUTPPLIT= PLIT'OUTPUT';
	ENTRY[1] _ OUTPPLIT;
	ERROUT(73); !NOT YET SUPPORTED
	UNTIL .C EQL EOL %EOL% DO CHAR(); !SCAN UNTIL EOL
	RETURN;
!        IF SCAN(PLIT'UT') LSS 0 THEN (ENTRY[1]_OUTPPLIT;ERROUT(E12));
!        IF SYNTAX(OUTPUT) LSS 0 THEN RETURN -1;
!!SEMANTIC ANALYSIS BEGINS
!	!----------------------------------------------------------------------------------------------------------
!	!THIS ROUTINE EXPECTS SYNTAX TO RETURN A POINTER IN STK[0] TO AN
!	!OPTIONAL UNIT NUMBER, WHICH MAY BE AN INTEGER CONSTANT OR VARIABLE,
!	!FOLLOWED BY AN IO BIT.  SEE EXPANSION OF THE METASYMBOL OUTPUT
!	!FOR DETAILS.
!	!----------------------------------------------------------------------------------------------------------
!	T1_.STK[0];TYPE_2; !INDICATE OUTPUT STATEMENT
!	IF .T1[ELMNT] NEQ 0 THEN !UNIT NUMBER
!	BEGIN
!		R1_.T1[ELMNT1];R2_.R1[ELMNT1]; !R2_LOC(CONSTANT OR VARIABLE)
!		IF .R1[ELMNT] EQL 1 THEN !CONSTANT
!		BEGIN
!			IF .R2[VALTYPE] NEQ INTEGER THEN ERR15(PLIT SIXBIT 'UNIT');
!		END
!		ELSE!VARIABLE
!		BEGIN
!			T1_.R2[ELMNT]; !T1_LOC(IDENTIFIER)
!			IF .T1[VALTYPE] NEQ INTEGER THEN ERR15(T1[IDSYMBOL]);
!			IF (R2_BLDVAR(@R2)) LSS 0 THEN RETURN .VREG
!		END;
!		SAVSPACE(.R1<LEFT>,@R1);
!	END ELSE R2_0;
!	R1_.STK[0];
!	IF (R1 _ DATALIST(.R1[ELMNT2])) LSS 0 THEN RETURN .VREG;
!	NAME_IDOFSTATEMENT_OUTPDATA;NAME<RIGHT>_SORTAB;T2_NEWENTRY();
!	T2[IOUNIT]_@R2;T2[IOFORM]_0;
!	T2[IORECORD]_0;T2[IOLIST]_.R1<LEFT>;
!	T2[IOERR]_T2[IOEND]_0;SAVSPACE(.STK[0]<LEFT>,.STK[0]);
	.VREG
END;
GLOBAL ROUTINE BLDIO1(NODEDATA)=	!BUILDS AN IO NODE FOR TYPE,PRINT,PUNCH,ACCEPT
BEGIN
	MAP BASE T1:T2;REGISTER BASE R1:R2;
	EXTERNAL STK,SAVSPACE %(SIZE, LOC)%,BLDFORMAT %(FPNT)%,DATALIST %(LPNT)%,
		NEWENTRY %()%,TYPE,IODOXPN;
	MACRO
	ELMNT=0,0,FULL$,ELMNT1=0,1,FULL$,ELMNT2=0,2,FULL$, ELMNT3=0,3,FULL$;
	LOCAL F;
	!----------------------------------------------------------------------------------------------------------
	!THIS ROUTINE EXPECTS SYNTAX TO RETURN A POINTER IN STK[0] TO A
	!FORMAT SPECIFICATION AND AN OPTIONAL IO LIST.  SEE EXPANSIONS OF
	!METASYMBOLS PRINT, FORMATID, AND DATAITEM FOR DETAILS.
	!----------------------------------------------------------------------------------------------------------
	R1_.STK[0];TYPE_IF .NODEDATA EQL READDATA THEN 3%READD% ELSE 4%WRITE%;
			!ABOVE FOR SETTING FLAG (STORD) IN LIST ITEMS SYMBOL TABLE ENTRIES
	FLAG _ -1;	!FLAG SAYS DON'T LOOK FOR END= IN BLDFORMAT
!	IF BLDFORMAT(.R1) LSS 0 THEN RETURN .VREG;
!	F_.STK[4];
	IF .R1 NEQ 0 THEN !I/O LIST
	BEGIN
		R2_.R1; !GET PTR TO I/O LIST PTRS
	!
	!GENERATE LINKED LIST OF I/O NODES
	!
		IF (R2 _ DATALIST(.R2[ELMNT])) LSS 0 THEN RETURN .VREG;
	END ELSE R2_0;
	SAVSPACE(.R1<LEFT>,.R1);
	NAME_IDOFSTATEMENT_.NODEDATA;NAME<RIGHT>_SORTAB;T1_NEWENTRY();
	T1[IOFORM]_0;
	T1[IORECORD]_0;T1[IOLIST]_.R2<LEFT>;
	IODOXPN(.T1);	!DO XPN FOR IOLISTS
	RETURN .T1
END;
GLOBAL ROUTINE PRINSTA=
BEGIN
	MAP BASE T1:T2;REGISTER BASE R1:R2;
	EXTERNAL STK,SAVSPACE %(SIZE, LOC)%,BLDFORMAT %(FPNT)%,DATALIST %(LPNT)%,
		NEWENTRY %()%,TYPE;
	MACRO
	ELMNT=0,0,FULL$,ELMNT1=0,1,FULL$,ELMNT2=0,2,FULL$;
	BIND PRINPLIT= PLIT'PRINT';
        IF SCAN(PLIT'T') LSS 0 THEN (ENTRY[1]_PRINPLIT;ERROUT(E12));
        IF SYNTAX(PRINT) LSS 0 THEN RETURN -1;
!SEMANTIC ANALYSIS BEGINS
	T1 _ BLDIO1(WRITDATA);	!BUILDS THE PRINT STAEMENT  IO NODE
	T1[IOUNIT]_MAKECNST(INTEGER,0,-3);	!PRINTID
	.VREG
END;
GLOBAL ROUTINE TYPESTA=
BEGIN
	MAP BASE T1:T2;REGISTER BASE R1:R2;
	EXTERNAL STK,SAVSPACE %(SIZE,LOC)%,BLDFORMAT %(FPNT)%,DATALIST %(LPNT)%,
		NEWENTRY %()%,TYPE;
	MACRO
	ELMNT=0,0,FULL$,ELMNT1=0,1,FULL$,ELMNT2=0,2,FULL$;
	BIND TYPEPLIT= PLIT'DISPLAY';
	IF SCAN(PLIT'LAY') LSS 0 THEN (ENTRY[1]_TYPEPLIT;ERROUT(E12));
        IF SYNTAX(TYPESPEC) LSS 0 THEN RETURN -1;
!SEMANTIC ANALYSIS BEGINS
	T1 _ BLDIO1(WRITDATA);
	T1[IOUNIT] _ MAKECNST(INTEGER,0,-1);	!TYPE ID
	.VREG
END;
GLOBAL ROUTINE BLDEDCODE(NODEDATA)=
BEGIN
	MAP BASE T1:T2;REGISTER BASE R1:R2;
	EXTERNAL STK,SAVSPACE %(SIZE,LOC)%, BLDFORMAT %(FPNT)%,BLDVAR %(VPNT)%,
		IODOXPN,DATALIST %(LPNT)%,TYPE,CORMAN %()%,NEWENTRY %()%;
	MACRO
	ELMNT=0,0,FULL$,ELMNT1=0,1,FULL$,ELMNT2=0,2,FULL$,ELMNT3=0,3,FULL$,ELMNT4=0,4,FULL$,
	ERR15(X)=(ENTRY[1]_X;ENTRY[2]_PLIT'INTEGER';RETURN ERROUT(E15))$;
	LOCAL CH,F,B,EN,ER;
	!----------------------------------------------------------------------------------------------------------
	!THIS ROUTINE EXPECTS SYNTAX TO RETURN A POINTER IN STK[0] TO AN
	!ENCODE/DECODE SPECIFICATION (CHARACTERS,FORMAT,BUFFER) FOLLOWED BY
	!AN I/O LIST.  SEE EXPANSIONS OF METASYMBOLS ENCODE, ENCODECODESPEC,
	!EXPRESSION, FORMATID, VARIABLESPEC AND DATAITEM FOR DETAILS.
	!----------------------------------------------------------------------------------------------------------
	T1_.STK[0];R1_.T1[ELMNT];SAVSPACE (0,.STK[0]);
	R2_.R1[ELMNT];
	IF .R2[VALTYPE] NEQ INTEGER THEN ERR15 (PLIT SIXBIT 'COUNT');
	CH_@R2;TYPE_0;
	!
	!BLDFORMAT RETURNS RESULTS IN STK[4],STK[5], AND STK[6]
	!
	STK[5]_STK[6] _ 0;	!IN CASE NO END= OR ERR=
	IF BLDFORMAT(R1[ELMNT1]) LSS 0 THEN RETURN .VREG; !NOTE NON-DOTTED PARAMETER
	F_.STK[4];
	IF (B_BLDVAR(.R1[ELMNT3])) LSS 0 THEN RETURN .VREG;
	EN _ .STK[5]; ER _ .STK[6];
	TYPE_1;
	IF (R2 _ DATALIST(.R1[ELMNT4])) LSS 0 THEN RETURN .VREG;
	NAME_IDOFSTATEMENT_.NODEDATA;NAME<RIGHT>_SORTAB;T1_NEWENTRY();
	T1[IOUNIT]_.B;T1[IOFORM]_.F;T1[IORECORD]_.CH;T1[IOLIST]_.R2<LEFT>;
	T1[IOERR]_.ER;T1[IOEND]_.EN;
	IODOXPN(.T1); !DO DOXPN FOR IOLIST
	SAVSPACE(.R1<LEFT>,@R1);
	.VREG
END;
GLOBAL ROUTINE ENCOSTA=
BEGIN
	MAP BASE T1:T2;
	EXTERNAL STK,SAVSPACE %(SIZE,LOC)%, BLDFORMAT %(FPNT)%,BLDVAR %(VPNT)%,
		DATALIST %(LPNT)%,TYPE,CORMAN %()%,NEWENTRY %()%;
	MACRO
	ELMNT=0,0,FULL$,ELMNT1=0,1,FULL$,ELMNT2=0,2,FULL$,ELMNT3=0,3,FULL$,
	ERR15(X)=(ENTRY[1]_X;ENTRY[2]_PLIT'INTEGER';RETURN ERROUT(E15))$;
	BIND ENCOPLIT= PLIT'ENCODE';
        IF SCAN(PLIT'DE') LSS 0 THEN (ENTRY[1]_ENCOPLIT;ERROUT(E12));
        IF SYNTAX(ENCODE) LSS 0 THEN RETURN -1;
!SEMANTIC ANALYSIS BEGINS
	BLDEDCODE(ENCODATA); !BUILD AN ENCODE STATEMENT NODE
	.VREG
END;
GLOBAL ROUTINE DECOSTA=
BEGIN
	MAP BASE T1:T2;
	EXTERNAL STK,SAVSPACE %(SIZE,LOC)%,BLDFORMAT%(FPNT)%,BLDVAR%(VPNT)%,
		DATALIST %(LPNT)%,TYPE,CORMAN%()%,NEWENTRY%()%;
	MACRO
	ELMNT=0,0,FULL$,ELMNT1=0,1,FULL$,ELMNT2=0,2,FULL$,ELMNT3=0,3,FULL$,
	ERR15(X)=(ENTRY[1];ENTRY[2]_PLIT'INTEGER';RETURN ERROUT(E15))$;
	BIND DECOPLIT= PLIT'DECODE';
        IF SCAN(PLIT'DE') LSS 0 THEN (ENTRY[1]_DECOPLIT;ERROUT(E12));
        IF SYNTAX(DECODE) LSS 0 THEN RETURN -1;
!SEMANTIC ANALYSIS BEGINS
	BLDEDCODE(DECODATA); !BUILD A DECODE STATEMENT NODE
	.VREG
END;
GLOBAL ROUTINE RERESTA=
BEGIN
	MAP BASE T1:T2; REGISTER BASE R1:R2;
	EXTERNAL STK,SAVSPACE %(SIZE,LOC)%,TYPE,BLDFORMAT %(FPNT)%,
		DATALIST %(LPNT)%,CORMAN %()%,NEWENTRY %()%;
	MACRO
	ELMNT=0,0,FULL$,ELMNT1=0,1,FULL$;
	BIND REREPLIT= PLIT'REREAD';
        IF SCAN(PLIT'AD') LSS 0 THEN (ENTRY[1]_REREPLIT;ERROUT(E12));
        IF SYNTAX(REREAD) LSS 0 THEN RETURN -1;
!SEMANTIC ANALYSIS BEGINS
!
	T1 _ BLDIO1(REREDATA);
	T1[IOUNIT] _ MAKECNST(INTEGER,0,-6); !RE READ ID
	.VREG
END;
GLOBAL ROUTINE BKSPST=	!BACKSPACE STATEMENT
BEGIN
	BIND	BACKPLIT= PLIT(PLIT( ASCIZ 'BACKSPACE?0'),PLIT( ASCIZ 'BACKFILE?0')),
		SCANPLIT= PLIT(PLIT( 'PACE'),PLIT( 'ILE'));
	MACRO SP=0$,FIL=1$;REGISTER R;
	SIGCHAR;	!MACRO GETS NEXT CHARACTER INTO C
	IF .C EQL "S" THEN R_SP ELSE R_FIL;
        IF SCAN(.SCANPLIT[.R]) LSS 0 THEN (ENTRY[1]_.BACKPLIT[.R];RETURN ERROUT(E12));
        IF SYNTAX(BACKSPEC) LSS 0 THEN RETURN -1;
!SEMANTIC ANALYSIS BEGINS
	BLDREPT(IF .R EQL SP THEN BACKDATA ELSE BKFILDATA); !BUILD A BACKSPACE OR BACKFILE NODE
	.VREG
END;
GLOBAL ROUTINE REWISTA=
BEGIN
	BIND REWIPLIT= PLIT'REWIND';
        IF SCAN(PLIT'ND') LSS 0 THEN (ENTRY[1]_REWIPLIT;ERROUT(E12));
        IF SYNTAX(REWIND) LSS 0 THEN RETURN -1;
!SEMANTIC ANALYSIS BEGINS
	BLDUTILITY(REWIDATA); !BUILD A REWIND STATEMENT NODE
	.VREG
END;
GLOBAL ROUTINE ENDFSTA=
BEGIN
	BIND ENDFPLIT= PLIT'ENDFILE';
        IF SCAN(PLIT'ILE') LSS 0 THEN (ENTRY[1]_ENDFPLIT;ERROUT(E12));
        IF SYNTAX(ENDFILESPEC) LSS 0 THEN RETURN -1;
!SEMANTIC ANALYSIS BEGINS
	BLDUTILITY(ENDFDATA); !BUILD AN ENDFILE STATEMENT NODE
	.VREG
END;
GLOBAL ROUTINE OPENSTA=
BEGIN
	MAP BASE T1:T2;REGISTER BASE R1:R2;
	EXTERNAL CNVNODE;
	EXTERNAL LEXEMEGEN %()%, LSAVE, LEXL, STK,SP,SYNTAX %(META)%,
		BLDVAR %(VPNT)%, CORMAN %()%, NEWENTRY %()%,STRSCAN;
	LABEL OPEN1,OPEN2;
	MACRO
		DIALOG = 1$,
		OPENACCESS = 0,0,0,18$,	!ACESSS MODE
		OPENARGID = 18,18$,	!TYPE OF ARGUMENT
		ELMNT=0,0,FULL$,
		ERR0(X)=(ENTRY[1]_.LEXNAME[.LEXL<LEFT>];ENTRY[2]_X;
		 RETURN ERROUT(E0))$,
	ERR15(X)=(ENTRY[1]_R1;ENTRY[2]_X; RETURN ERROUT(E15))$;
	MACHOP BLT=#251;LOCAL RQD,OPT1,OPT2,ERR;
! THE FOLLOWING PARAM LIST FORMAT IS : INPUTSYM,FORMATTYP,SPECTYP,OUTPUTSYM

	BIND PARAM = PLIT(
% 1%	PLIT(SIXBIT'INPUT ',0,#2,SIXBIT'SEQIN '),
% 2%	PLIT(SIXBIT'OUTPUT',0,#2,SIXBIT'SEQOUT'),
% 3%	PLIT(SIXBIT'RANDIN',3,#2,SIXBIT'RANDIN'),
% 4%	PLIT(SIXBIT'RANDOU',3,#2,SIXBIT'RANDOM'),
% 5%	PLIT(SIXBIT'RANDIO',3,#2,SIXBIT'RANDOM'),
% 6%	PLIT(SIXBIT'BINARY',0,#12,SIXBIT'BINARY'),
% 7%	PLIT(SIXBIT'SYMBOL',0,#12,SIXBIT'ASCII '),
% 8%	PLIT(SIXBIT'ERRNUM',1,#21,SIXBIT'ERROR '),
% 9%	PLIT(SIXBIT'BUFFER',2,#4,SIXBIT'BUFFCO'),
%10%	PLIT(SIXBIT'ERR',4,#0,SIXBIT'ERR')
	)-1;
	BIND OPENPLIT= PLIT'OPEN';
	LOCAL OARGID;	!OPENARG ID


ERR_0;
RQD _ 0;	!RESET RQUIRED ARG (UNIT)
OPT1_0;
OPT2_0;
STK[0]_0; SP_-1;
LEXL_LEXEMEGEN();
IF .LEXL NEQ LPAREN^18 THEN ERR0(PLIT'LPAREN');

WHILE 1 DO
BEGIN

	IF SYNTAX(EXPRESSION) LSS 0 THEN RETURN .VREG;
	RQD _ .STK[.SP];
	SP_.SP-1;

	IF .LEXL NEQ COMMA^18 THEN EXITLOOP;

	LEXL_LEXEMEGEN();
	IF .LEXL<LEFT> EQL IDENT THEN
	BEGIN
		R1_@LEXL;
		IF .R1[VALTYPE] NEQ STRING THEN
		BEGIN
			IF .R1[OPERSP] NEQ ARRAYNAME AND
				.R1[OPERSP] NEQ FORMLARRAY THEN ERR15(PLIT'ARRAY')
					ELSE STK[SP_.SP+1]_@R1;
				LEXL_LEXEMEGEN();
		END
		ELSE
		BEGIN
			IF SYNTAX(EXPRESSION) LSS 0 THEN RETURN .VREG;
		END
	END
	ELSE
	BEGIN
		IF .LEXL<LEFT> EQL LSTRING THEN STK[SP_.SP+1]_.LEXL<RIGHT>
			ELSE ERR0 (PLIT'LITERAL');
		LEXL_LEXEMEGEN();
	END;
	STK[.SP]<OPENARGID>_6;

    WHILE 1 DO
     BEGIN
	IF .LEXL NEQ COMMA^18 THEN EXITLOOP;

	LEXL_LEXEMEGEN();
	IF .LEXL<LEFT> NEQ IDENT THEN ERR0(PLIT'KEYWORD');
	R1_.LEXL<RIGHT>;
	R1_.R1+3;

	OPEN1: INCR I FROM 1 TO 10 DO
		BEGIN
			IF @@R1 EQL @@PARAM[.I] THEN
			BEGIN
				OARGID_@(@PARAM[.I]+2);
				R2_@(@PARAM[.I]+3);
				(@R1)<LEFT>_.(R2<LEFT>);
				(@R1)<RIGHT>_.(R2<RIGHT>);
				R1_@(@PARAM[.I]+1);
				LEAVE OPEN1;
			END;
		END;
	CASE .R1 OF SET
		BEGIN
			STK[SP_.SP+1]_.LEXL<RIGHT>;
			STK[.SP]<OPENARGID>_.OARGID;
			LEXL_LEXEMEGEN();
		END;

		BEGIN
			IF LEXEMEGEN() NEQ EQUAL^18 THEN ERR0(PLIT'=');
			LEXL_LEXEMEGEN();
			IF .LEXL<LEFT> NEQ IDENT THEN ERR0(PLIT'IDENTIFIER');
			IF SYNTAX(VARIABLESPEC) LSS 0 THEN RETURN .VREG;
			R1_.STK[.SP];
			IF (STK[.SP]_BLDVAR(@R1)) LSS 0 THEN RETURN .VREG;
			STK[.SP]<OPENARGID>_.OARGID;
		END;

		BEGIN
			IF LEXEMEGEN() NEQ EQUAL^18 THEN ERR0(PLIT'=');
			LEXL_LEXEMEGEN();
			IF SYNTAX(EXPRESSION) LSS 0 THEN RETURN .VREG;
			STK[.SP]<OPENARGID>_.OARGID;
			OPT2_.SP;
		END;

		BEGIN
			LEXL_LEXEMEGEN();
			IF .LEXL<LEFT> NEQ COMMA THEN
			BEGIN
				IF .LEXL<LEFT> NEQ LPAREN THEN ERR0(PLIT'LPAREN');
				IF SYNTAX(EXPRESSION) LSS 0 THEN RETURN .VREG;
				OPT1_.STK[.SP];
				SP_.SP-1;
			END;
		END;

	BEGIN
		IF LEXEMEGEN() NEQ EQUAL^18 THEN ERR0(PLIT'=');
		LEXL_LEXEMEGEN();
		R2_@LEXL;
		IF .R2[VALTYPE] NEQ INTEGER THEN (RETURN ERROUT(E17));
		IF .R2[CONST2] GTR 99999 THEN (RETURN ERROUT(E17));
		NAME_LABTAB; ENTRY[0]_.R2[CONST2]; ERR_TBLSEARCH();
	END;

	TES;

     END;
	EXITLOOP;
END;
	IF .LEXL NEQ RPAREN^18 THEN ERR0(PLIT'RPAREN');
	IF LEXEMEGEN() NEQ LINEND^18 THEN ERR0(PLIT'LINEND');
	IF .SP GEQ 0
	THEN(
		NAME<LEFT>_.SP+1;R1_CORMAN();
		T1<LEFT>_STK[0];T1<RIGHT>_.R1;T2_.R1+.SP;BLT(T1,0,T2);
	    )
	ELSE R1 _ 0;
	NAME_IDOFSTATEMENT_OPENDATA;NAME<RIGHT>_SORTAB;T1_NEWENTRY();
	T1[OPSIZ]_.SP+1;T1[OPLST]_.R1; T1[IOUNIT] _ .RQD;T1[IOFORM]_.OPT1;
	T1[IOERR]_.ERR;
	R2_.RQD;
	IF .R2[VALTYPE] NEQ INTEGER THEN CNVNODE(.T1[IOUNIT],INTEGER,T1[IOUNIT]);
	IF .OPT1 NEQ 0 THEN
	BEGIN
		R2_.OPT1;
		IF .R2[VALTYPE] NEQ INTEGER THEN 
			CNVNODE(.T1[IOFORM],INTEGER,T1[IOFORM]);
	END;
	IF .OPT2 NEQ 0 THEN
	BEGIN
		R2_.STK[.OPT2]<RIGHT>;
		IF .R2[VALTYPE] NEQ INTEGER THEN
			CNVNODE(.R1[.OPT2]<RIGHT>,INTEGER,R1[.OPT2]<RIGHT>);
	END;
	SP _ -1;
	.VREG
END;
GLOBAL ROUTINE CLOSSTA=
BEGIN
EXTERNAL SCAN,ERROUT,OPENCLOSE;
	BIND CLOSEPLIT='CLOSE'; 
	ENTRY[1]_CLOSEPLIT; ERROUT(73);
	UNTIL .C EQL ";" DO CHAR();
!	IF SCAN(PLIT'E') LSS 0 THEN ERROUT(12);
!	OPENCLOSE(CLOSDATA);
	.VREG
END;
GLOBAL ROUTINE FINDSTA=
BEGIN
	MAP BASE T1:T2; REGISTER BASE R1:R2;
	EXTERNAL STK,SAVSPACE %(SIZE,LOC)%,BLDVAR %(VPNT)%,NEWENTRY %()%;
	MACRO
	ELMNT=0,0,FULL$,ELMNT1=0,1,FULL$,ELMNT2=0,2,FULL$,
	ERR15(X)=(ENTRY[1]_X;ENTRY[2]_PLIT'INTEGER';RETURN ERROUT(E15))$;
	BIND FINDPLIT= PLIT'FIND';
        IF SYNTAX(FIND) LSS 0 THEN RETURN -1;
!SEMANTIC ANALYSIS BEGINS
	!----------------------------------------------------------------------------------------------------------
	!THIS ROUTINE EXPECTS SYNTAX TO RETURN A POINTER IN STK[0]
	!TO A UNIT NUMBER (INTEGER CONSTANT OR VARIABLE) FOLLOWED
	!BY A RECORD NUMBER.  SEE EXPANSIONS OF METASYMBOLS FIND,
	!VARIABLESPEC AND EXPRESSION FOR DETAILS.
	!----------------------------------------------------------------------------------------------------------
	R1_.STK[0];R2_.R1[ELMNT1];	!R2_LOC (CONSTANT OR VARIABLE)
	IF .R1[ELMNT]EQL 1 THEN		!CONSTANT
	BEGIN
		IF .R2[VALTYPE] NEQ INTEGER THEN ERR15(PLIT SIXBIT'UNIT');
	END
	ELSE	!VARIABLE
	BEGIN
		T1_.R2[ELMNT];	!T1_LOC (IDENTIFIER)
		IF .T1[VALTYPE] NEQ INTEGER THEN ERR15(T1[IDSYMBOL]);
		IF (R2_BLDVAR(@R2)) LSS 0 THEN RETURN .VREG;
	END;
	NAME_IDOFSTATEMENT_FINDDATA;NAME<RIGHT>_SORTAB;T1_NEWENTRY();
	T1[IOUNIT]_@R2;T1[IOFORM]_0;
	T1[IORECORD]_.R1[ELMNT2];T1[IOLIST]_0;
	T1[IOERR]_T1[IOEND]_0;
	SAVSPACE(.R1<LEFT>,@R1);
	.VREG
END;
ROUTINE CMPLXCONGEN=	!BUILDS A COMPLEX ONSTANT NODE FROM DATA LIST
				!SEMANTIC OUTPUT
BEGIN
MACRO ELMNT=0,0,FULL$, ELMNT1=0,1,FULL$, ELMNT2=0,2,FULL$,ELMNT3=0,3,FULL$;
LOCAL SIGNFLG;
LOCAL BASE REALPT :IMAGPT;
EXTERNAL CNSTCM,C1H,C1L,C2H,C2L,COPRIX,KDPRL,KDNEGB;
MACRO DNEG(X)=
BEGIN
	C1H _ X[CONST1];	!HIGH ORDER
	C1L _ X[CONST2];	!LOW ORDER
	COPRIX _ KDNEGB + .CKA10FLG;
	CNSTCM();	!CONVERT TO NEG
	MAKECNST(REAL,.C2H,.C2L)
END$;
MAP BASE T1:T2;
	   SIGNFLG _ 0;
	   IF .T1[ELMNT] NEQ 0 !IS IT SIGNED?
	     THEN 
		(IF .T1[ELMNT] EQL 2 THEN SIGNFLG _ -1
		 E SIGNFLG_ 0;
		T1_.T1+1;
	       );
	   REALPT_.T1[ELMNT1];
	    IF .REALPT[VALTYPE] EQL INTEGER
		THEN REALPT _  MAKECNST(REAL,.REALPT[CONST2],0);
	   IF .SIGNFLG THEN REALPT _ DNEG(.REALPT);
	!
	!CONVERT TO SINGLE PRECISION
	!
	IF .REALPT[VALTYPE] NEQ OCTAL
	THEN
	BEGIN
	 C1H _ .REALPT[CONST1]; C1L _ .REALPT[CONST2];
	 COPRIX _ KDPRL;
	 CNSTCM();
	 REALPT _ .C2H;
	END;
	   SIGNFLG _ 0;
	   T1_.T1+2; !SKIP TO IMAG PART
	   IF .T1[ELMNT] NEQ 0
	    THEN (IF .T1[ELMNT] EQL 2 THEN SIGNFLG_-1 ELSE SIGNFLG_ 0;
		  T1_.T1+1;
		);
	   IMAGPT _ .T1[ELMNT1];
		IF .IMAGPT[VALTYPE] EQL INTEGER
			THEN IMAGPT _  MAKECNST(REAL,.IMAGPT[CONST2],0);
	   IF .SIGNFLG THEN IMAGPT_ DNEG(.IMAGPT);
	!
	!CONVERT TO SINGLE PRECISION
	!
	IF .IMAGPT[VALTYPE] NEQ OCTAL
	THEN
	BEGIN
	 C1H _ .IMAGPT[CONST1]; C1L _ .IMAGPT[CONST2];
	 COPRIX _ KDPRL;
	 CNSTCM();
	 IMAGPT _ .C2H;
	END;
	   !NOW MAKE ACOMPLEX CONSTANT NODE
	T2_MAKECNST(COMPLEX,.REALPT,.IMAGPT);
END;	!OF ROUTINE CPLXCONGEN
GLOBAL ROUTINE DATAGEN(CONLIST)=
BEGIN
EXTERNAL CORMAN,NAME,SAVSPACE;
LOCAL REPEAT,COUNT,DATCSIZ,SIGNFLG;
LOCAL  BASE CONNODE :CONPTR;
LABEL DAT1;
MACRO ERR54 = ( ERROUT(54))$;
EXTERNAL CNSTCM,C1H,C1L,C2H,C2L,COPRIX,KDPRL,KDNEGB;
MACRO DNEG(X,Y)=
BEGIN
	C1H _ X[CONST1];	!HIGH ORDER
	C1L _ X[CONST2];	!LOW ORDER
	COPRIX _ KDNEGB + .CKA10FLG;
	CNSTCM();	!CONVERT TO NEG
	MAKECNST(Y,.C2H,.C2L)
END$;
MACRO DDATCONNODE =
	BEGIN
	NAME<LEFT> _ 2; CONNODE _ CORMAN();
	IF .CONPTR EQL 0
	THEN (CONPTR<LEFT> _ CONPTR<RIGHT> _ .CONNODE)
	ELSE (CONPTR[CLINK] _ .CONNODE;
		CONPTR<RIGHT> _.CONNODE;
	     );
	END$;
MACRO ELMNT=0,0,FULL$, ELMNT1=0,1,FULL$, ELMNT2=0,2,FULL$,ELMNT3=0,3,FULL$;
MAP BASE T1:T2:CONLIST;
%
ROUTINE BUILDS A LIST OF DATA CONSTANTS AND KEEPS COUNT FOR LATER USE
BY THE DATA LIST  PROCESSING ROUTINES
%
	CONPTR _ 0; COUNT _ 0;
	INCR CONITEM FROM .CONLIST TO .CONLIST+.CONLIST<LEFT> BY 2 DO
	BEGIN
	MAP BASE CONITEM;
	REPEAT _ 1;	!INITIALIZE
		!SEE IF CONSTANT IS LITERAL OR NUMBER
	DAT1: IF .CONITEM[ELMNT] EQL 1
	        THEN !NUMBER
		BEGIN
		  T1 _ .CONITEM[ELMNT1]; !PTR TO 2 OR 3 WORD SET CONST [* CONST]
		  IF .T1[ELMNT] NEQ 0
			THEN( !SIGHNED CONSTANT
				IF .T1[ELMNT] EQL 2  !MINUS
				THEN SIGNFLG_-1 ELSE SIGNFLG_0;
				T1 _ .T1+1;! TO GET PAST THE SIGN
			    )
			ELSE SIGNFLG _ 0;
		  T2 _ .T1[ELMNT1]; !PTR TO FIRST CONSTANT OR REPEAT COUNT
		  IF .T1[ELMNT2] NEQ 0
		   THEN (!REPEAT FACTOR T2 POINTS TO REPEAT CONST
			IF .T2[VALTYPE] NEQ INTEGER THEN (ERR54; REPEAT _ 0; LEAVE DAT1);
			REPEAT _ .T2[CONST2]; !REPEAT VALUE
			T1 _ .T1[ELMNT3]; !PTR TO REPEATED CONST OR LITERAL
			T2 _ .T1[ELMNT2]; !PTR TO ACTUAL CONSTANT OR LITSTRING NODE
			IF .T1[ELMNT1] EQL 1
			  THEN !NUMBER
				(
				IF .T2[ELMNT] NEQ 0
				  THEN (!SIGNED NUMBER
					IF .T2[ELMNT] EQL 2
					THEN SIGNFLG_-1 ELSE SIGNFLG_0;
					T2 _ .T2[ELMNT2]
				       )
				  ELSE T2 _ .T2[ELMNT1];
				DATCSIZ _ IF .T2[DBLFLG] THEN 2 ELSE 1
				)
			  ELSE IF .T1[ELMNT1] EQL 2
				   !LITERAL
				THEN DATCSIZ _ .T2[LITSIZ]
				ELSE !COMPLEX CONSTANT
					(
					  T1 _ .T2; !SET T1 TO POINT TO COMPLEX CONSTANT SEMANTIC OUTPUT
					 CMPLXCONGEN(); !GENERATE PTR TO COMPLEX CONSTANT NODE IN T2
					 DATCSIZ _ 2;
					);
			)
		   ELSE (
			 DATCSIZ _ IF .T2[DBLFLG] THEN 2 ELSE 1;
			);
		  COUNT _ .COUNT + .DATCSIZ  * .REPEAT;
		  IF .SIGNFLG NEQ 0
		   THEN IF .T2[VALTP1] EQL INTEG1
			THEN T2 _ MAKECNST(INTEGER,0,-.T2[CONST2])
			ELSE T2 _ DNEG(.T2,.T2[VALTYPE]);  !NEGATE THE NUMBER
		END
	        ELSE IF .CONITEM[ELMNT] EQL 2 THEN  !LITERAL
			BEGIN
			T2 _ .CONITEM[ELMNT1]; !PTR TO LITERAL STRING NODE
			COUNT _ .COUNT + .T2[LITSIZ];
			END
		ELSE !COMPLEX CONSTANT
			BEGIN
			   T1 _ .CONITEM[ELMNT1];
			    CMPLXCONGEN();	!GENERATE A COMPLEX CONSTANT NODE
			   !WILL RETURN CONSTANT NODE PTR IN T2
			   COUNT _ .COUNT+2;
			END;
	  DDATCONNODE; !BUILD AND LINK A DATA CONSTANT NODE
	  CONPTR[DATARPT] _ .REPEAT;
	  CONPTR[DCONST] _ .T2;
	END; !OF INCR LOOP
	RETURN .COUNT^18+ .CONPTR<LEFT>;
END;
GLOBAL ROUTINE DATASTA=
BEGIN
	BIND DATAPLIT= PLIT'DATA';
	MAP BASE T1:T2;
	REGISTER BASE R1:R2;
	MACRO ELMNT=0,0,FULL$, ELMNT1=0,1,FULL$, ELMNT2=0,2,FULL$;
	LOCAL ITEMLIST,CONLIST;
	EXTERNAL DATAGEN %(LOC,SIZE)%,SAVSPACE %(SIZE,LOC)%,STK,SP,DATALIST,TYPE,NEWENTRY;
        IF SYNTAX(DATA) LSS 0 THEN RETURN -1;
!SEMANTIC ANALYSIS BEGINS
	T1_@.STK[0];	!T1_LOC(DATASPEC OR LIST A,LINEND)
	INCR DAT FROM .T1 TO .T1+.T1<LEFT> DO
	BEGIN !PROCESS LIST OF DATA SPECIFICATIONS

		MAP BASE DAT;
		R1 _ .DAT[ELMNT]; !PTR TO 2 ITEM LIST - 1.DATALIST PTR
				   !			2.CONLIST PTR
		T1 _ .R1[ELMNT1]; !PROCESS CONLIST PTR FIRST FO COUNT NUMBER OF CONSTANTS
		!T1 POINTS TO 3 WORD LIST (SLASH,CONLISTPTR,SLASH)
		R2 _ .T1[ELMNT1]; !GET PTR TO LIST OF CONSTANT SPECS
		SAVSPACE (.T1<LEFT>,.T1); !GET BACK SPACE
		CONLIST _ DATAGEN(.R2);
		SAVSPACE(.R2<LEFT>,.R2);
	!
	!NOW PROCESS LIST OF DATA ITEM SPECIFICATIONS
	!USE THE SAME ROUTINE AS USED BY IO LISTS AND RETURN PTR
	!TO SAME KIND OF LIST STRUCTURE AS IO LISTS
	!
		TYPE _ 0; !SIGNAL DATA STATEMENT TO DATALIST ROUTINE
		SP _ 0; !RESET FOR USE IN DATALIST
		ITEMLIST _ DATALIST(.R1[ELMNT]); !USEING FIRST ITEM POINTED TO BY R1
		SAVSPACE(.R1<LEFT>,.R1); !RETRIEVE SOME SPACE
		!
		!NOW BUILD A DATA STATEMENT NODE AND LINK TO ANY PREVIOUS ONES
		!
		NAME _ DATATAB; !ID OF DATA TABLE FOR NEWENTRY
		R2 _ NEWENTRY();
		!FILL IN PTRS TO LISTS IN DATA NODE
		!
		R2[DATITEMS] _ .ITEMLIST<LEFT>;  R2[DATCONS] _ .CONLIST;
		R2[DATCOUNT] _ .CONLIST<LEFT>; !NUMBER OF CONSTANTS SPECIFIED
	END; !OF INCR LOOP
	T1 _ @.STK[0]; SAVSPACE(.T1<LEFT>,.T1); SAVSPACE(0,.STK[0]);
	.VREG
END; !OF DATASTA

+ 
³