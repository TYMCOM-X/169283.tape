TITLE	COBOLB	FOR COBOL 5(107)		
SUBTTL	ID AND ED CONTROL PROGRAM	W.NEELY/CAM

;COPYRIGHT 1970,1971,1972, DIGITAL EQUIPMENT CORP., MAYNARD, MA.

TWOSEG
RELOC	400000

ENTRY	COBOLB

COBOLB:	SETFAZ	B;		;INIT PHASE B
	MOVE	SAVPTR,ISVPTR	;INITIALIZE SAVE LIST POINTER
	MOVE	NODPTR,INDPTR	;INITIALIZE NODE POINTER
IFN DEBUG,<
	MOVE	TE,CORESW
	SWOFF	FNDTRC		;CLR TRACE REQUEST
	TRNE	TE,TRACEI	;TRACE ID NODES?
	SWON	FNDTRC		;YES, TURN ON TRACER
	>
	HRRZI	TA,62		;50 DECIMAL IS SEGLIM INITIAL VALUE
	MOVEM	TA,SEGLIM
	HRRZI	TA,ID0.		;AIM AT FIRST ID NODE
	PUSH	NODPTR,TA
	SETZM	CURFIL		;INIT FILE TABLE PTRS
	SETZM	LSTFIL
	PUSHJ	PP,SQURL.	;START SCAN
	TTCALL	3,[ASCIZ "COBOLB--LOST; TOO MANY POPJ'S
"]
	JRST	KILL

EXTERN	NAMLOC,CURDAT,FNDLNK,KILL,LITVAL
EXTERN	SAVETA,SAMSRT
EXTERN	PUTGEN,CTR,GETVAL
EXTERN	PNTR
EXTERN	TRYNAM,FINSKP,CPYBHO
EXTERN	CFLM,FI.SDL
EXTERN	LNKSET,CLRNAM
EXTERN	PROGID,CLRCPY
EXTERN	NAMWRD,NAMADR,BLDNAM,GETENT,PUTLNK,OBJSIZ
EXTERN	DOLLR.,STDATE,PUTCPY,GETITM
EXTERN	FILLOC,NDEV,TBLOCK,ESIZE,VALADR,CURNAM
EXTERN	LSIZE,MNETYP,GETKAR,SKPSRC
EXTERN	CURVAL
EXTERN	EX.USN,FI.LNC,FI.ERM,FI.LBL,FI.ACC
EXTERN	FI.RCT,FI.MLT
EXTERN	FI.IRM,FI.NXT,FI.OPT,FI.NDV,FI.VAL,FI.NBF,FI.ACK,FI.NFL
EXTERN	FI.SRA,FI.SBA,FI.RRC,FI.RER,FI.SAL,FI.POS
EXTERN	CURCPY,CPYLOC,CPYNXT,CPYW2
EXTERN	LIBNAM,SETLIB
EXTERN	FI.RM2,FI.RD,FI.RP
EXTERN	ISVPTR,INDPTR,CURFIL,LSTFIL
EXTERN	SQURL.,SEGLIM
EXTERN	KILL
EXTERN	CURHLD,HL.NAM,HL.COD,HL.LNC,HL.QAL,HL.LNK
EXTERN	HLDLOC,HLDNXT
IFN DEBUG,<
EXTERN	CORESW,TRACEI,TRACEE
	>
SUBTTL	ACTIONS FOR ID AND ED SYNTAX PROCESSING

;CHECK FOR PERIOD, THEN SKIP TO END OF PARAGRAPH
;MUST ALSO WATCH FOR THERE BEING NOTHING TO SKIP

	INTER.	IA0A.
IA0A.:	PUSHJ	PP,CKPERI	;CHECK FOR PERIOD
	TRNE	TYPE,2000	;A-MARGIN?
	POPJ	PP,		;YES, NEW PARAGRAPH.
	SKPNAM

;SKIP TO END OF PARAGRAPH, PASSING DATA TO LISTING FILE

	INTER.	IA0.
IA0.:	SWOFF	FNOCPY		;TURN OFF 'NO LISTING' FLAG
	PUSHJ	PP,SKPPGF	;SKIP TO END OF PARAGRAPH
	PUSHJ	PP,GETITM	;GET A SOURCE ITEM
	SKPNAM

;SET TO REGET LAST ITEM SEEN

	INTER.	IA0.R
IA0.R:	SWON	FREGWD		;SET REGET WORD BIT
	POPJ	PP,

;TURN OFF REGET WORD FLAG

	INTER.	IA0.A
IA0.A:	SWOFF	FREGWD;
	POPJ	PP,

;ADVANCE TO NEXT WORD

	INTER.	IA0.G
IA0.G:	SWOFF	FREGWD		;CLR REGET WORD FLAG
	PUSHJ	PP,GETITM	;GET NEXT ITEM
	POPJ	PP,
;FLAG MISSING IDENTIFICATION DIVISION, THEN TRY ITEM AGAIN

	INTER.	IA0E1.
IA0E1.:	EWARNW	BE1.		;NO IDENTIFICATION DIV.
	JRST	IA0.R		;SET TO REGET WORD

;FLAG ILLEGAL PARAGRAPH, THEN SKIP TO NEXT PARAGRAPH

	INTER.	IA0E7.
IA0E7.:	EWARNW	BE7.		;'ILLEGAL PARAGRAPH NAME'
	JRST	IA0.

;FLAG ILLEGAL SECTION, THEN SKIP TO NEXT PARAGRAPH

	INTER.	IA0E43
IA0E43:	EWARNW	BE43.		;'ILLEGAL SECTION NAME'
	JRST	IA0.

;FLAG MISSING 'DECSYSTEM-10', THEN TRY ITEM AGAIN

	INTER.	IA0E5.
IA0E5.:	EWARNW	BE5.		;'DECSYSTEM-10 ASSUMED'
	JRST	IA0.A		;CLR REGET WORD BIT

;STOP SOURCE FROM GOING TO LISTING

	INTER.	IA1.
IA1.:	SWON	FNOCPY		;SET NO LISTING BIT
	POPJ	PP,
;GET NEXT ITEM & VERIFY THAT IT IS A PERIOD
;IF NOT A PERIOD, FLAG IT

CKPERI:	PUSHJ	PP,GETITM	;READ FOR PERIOD
	LDB	TA,[POINT 10,TYPE,35]	;GET TYPE OF ITEM
	CAIE	TA,PRIOD.	;IS IT A PERIOD?
	JRST	BE125.		;NO, GIVE PERIOD ASSUMED MSG
	PUSHJ	PP,GETITM	;IF PERIOD THERE GET NEXT ITEM FOR CONSISTENCY
	JRST	IA0.R		;SET REGET WORD FLAG JUST LIKE BE125. DOES

;SKIP TO END TO PARAGRAPH
;THE TRICK IS TO FIND A CHARACTER IN THE A-FIELD THAT IS NOT
;EITHER A SPACE, TAB, OR HYPHEN
;(ASTERISKS ARE FILTERED OUT AT A MUCH EARLIER STAGE)

SKPPGF:	PUSHJ	PP,SKPSRC	;GET NEXT SOURCE CHAR.
	CAIN	CP,7		;ALREADY AT COLUMN 7?
	JRST	ENDB		;YES, WHAT KIND OF CHAR.?
	CAIGE	CP,^D12		;IN B-FIELD?
	JRST	ENDB.2		;NO, MUST BE IN A-FIELD
ENDPAR:	PUSHJ	PP,SKPSRC	;GET CHARACTER
ENDB:	TSWF	FEOF		;END-OF-FILE?
	JRST	END2		;EOF FOUND
	CAIE	CP,7		;COLUMN 7?
	JRST	ENDPAR		;NO, GET TO NEXT LINE
	CAIE	CH," "		;YES, SPACE?
	JRST	ENDPAR		;NO, MUST BE A HYPHEN
ENDB.1:	PUSHJ	PP,SKPSRC	;GET CHARACTER
	TSWF	FEOF		;END-OF-FILE?
	JRST	END2		;YES
	CAIL	CP,14		;INTO B-FIELD YET?
	JRST	ENDB		;YES, SKIP REST OF LINE
ENDB.2:	CAIN	CH," "		;IS IT A SPACE?
	JRST	ENDB.1		;YES
	CAIL	CH,"A"		;IS IT ALPHABETIC?
	CAILE	CH,"Z"
	JRST	ENDB		;NOT A LETTER
END2:	SWON	FREGCH		;SET TO REGET LAST CHARACTER
	TRZ	SW,FREGWD+FGTPER+FNEEDS	;CLR OTHER FLAGS
	POPJ	PP,
;GET PROGRAM TITLE
;IF NO NAME GIVEN, GIVE IT THE NAME 'MAIN'

	INTER.	IA2.
IA2.:	SKIPE	PROGID		;'PROGRAM-ID' SEEN ALREADY?
	EWARNJ	BE3.		;YES, DUPLICATE PARAGRAPH
	PUSHJ	PP,CKPERI	;GET THE PERIOD
	TRNN	TYPE,2000	;AT THE A-MARGIN?
	JRST	IA2.0		;NO
IA2.2:	MOVE	TD,[SIXBIT /MAIN/]	;YES, NO ID THERE
	MOVEM	TD,NAMWRD	;SO GIVE IT A DUMMY NAME
	TSWF	FDSKC		;CCL?
	TTCALL	3,[ASCIZ /MAIN/]
	JRST	IA2SUB

IA2.0:	PUSHJ	PP,GETITM	;REGET SOURCE ITEM AFTER THE PERIOD
	SKIPE	NAMWRD		;IS IT A USER-NAME?
	JRST	IA2.12		;YES
	SKIPE	LITVAL		;IS IT A LITERAL?
	JRST	.+3		;YES
	EWARNW	BE4.		;NEITHER A WORD NOR A LITERAL
	JRST	IA2.2		;USE "MAIN"
	MOVE	TD,[POINT 6,NAMWRD]	;SET PTRS TO MOVE THE
	MOVE	TE,[POINT 7,LITVAL]	;LITERAL INTO THE NAMWRD TABLE
	LDB	TB,GWVAL##	;GET # OF CHARS
	CAILE	TB,6		;IF LESS THAN OR = SIX, USE IT
	MOVEI	TB,6		;SET CTR FOR 1ST 6 CHARS
IA2.11:	ILDB	TA,TE		;GET LITERAL CHARACTER
	JUMPE	TA,IA2.12	;END OF LITERAL
	CAIL	TA,"0"		;LETTER OR DIGIT?
	CAILE	TA,"Z"
	JRST	IA2110		;NO
	CAILE	TA,"9"
	CAIL	TA,"A"
	SKIPA			;YES
IA2110:	HRRZI	TA,":"		;CHANGE NON-LETTER/DIGIT TO POINT (:)
	HRRZI	TA,-40(TA)	;CONVERT TO SIXBIT
	IDPB	TA,TD		;PUT IN NAMWRD
	SOJG	TB,IA2.11	;CONT. IN LOOP UNTIL 6 CHARS MOVED
IA2.12:	SETZ	TD,		;INIT AC FOR RESULT
	MOVEI	TB,6		;CTR FOR 6 CHARS
	MOVE	TA,[POINT 6,NAMWRD]
IA2.N2:	ILDB	TC,TA		;GET 6BIT CHAR
	CAIN	TC,32		;IS IT A COLON (WHICH AROSE FROM A HYPHEN, ETC)?
	MOVEI	TC,16		;YES, CHANGE IT TO A DOT
	LSH	TD,6		;SHIFT PREVIOUS RESULT LEFT 6
	OR	TD,TC		;MERGE IN NEW CHAR
	TSWT	FDSKC		;CCL OR COMMAND FILE?
	JRST	IA2.N3		;NO, DONT PRINT NAME
	ADDI	TC,40		;CONVERT 6BIT TO ASCII
	TTCALL	1,TC		;PRINT CHAR
IA2.N3:	SOJG	TB,IA2.N2	;CONT. THRU 6 CHARS.
	PUSHJ	PP,IA2SUB
	JRST	IA0.

IA2SUB:	MOVEM	TD,PROGID	;STORE RESULT
	TSWT	FDSKC		;CCL OR CMD FILE?
	JRST	IA2SU3		;NO
	TTCALL	3,[ASCIZ /  [/]	;PRINT "[FILNAM.EXT]"
	MOVEI	TA,'.'		;PUT A DOT WHERE THERE IS A SPACE
	DPB	TA,[POINT 6,SRCFIL+1,5]
	MOVE	TA,[POINT 6,SRCFIL##]
	MOVEI	TB,^D10
IA2SU2:	ILDB	TC,TA
	ADDI	TC,40		;CONVERT TO ASCII
	CAIE	TC,40		;SPACE?
	TTCALL	1,TC		;NO, PRINT IT
	SOJG	TB,IA2SU2
	SETZ	TA,		;CLR '.' AGAIN
	DPB	TA,[POINT 6,SRCFIL+1,5]
	TTCALL	3,[ASCIZ /]
/]
IA2SU3:	SETZM	NAMWRD+1
	MOVE	TA,[NAMWRD+1,,NAMWRD+2]
	BLT	TA,NAMWRD+5
	PUSHJ	PP,TRYNAM	;PROGRAM-ID A RESERVED WORD?
	JRST	.+3		;NO
	EWARNW	BE315.		;YES
	JRST	IA2.2		;TRY IT WITH "MAIN"
	PUSHJ	PP,BLDNAM	;MAKE NAMTAB ENTRY
	HLRS	TA
	DPB	TA,[POINT 15,W2,15]	;SAVE NAMTAB LINK
	MOVE	TA,[CD.EXT,,SZ.EXT]	;PUT PROGRAM-ID IN EXTAB
	PUSHJ	PP,GETENT
	HLRM	TA,PIDLNK##	;SAVE EXTAB LINK
	LDB	TB,[POINT 15,W2,15]
	IORI	TB,<CD.EXT>B20	;EXT FLAG + NAMTAB LINK
	MOVSM	TB,(TA)		;TO 1ST WORD OF ENTRY
	SETO	TC,		;SET PROG-ID FLAG
	DPB	TC,EX.PID##
	DPB	TC,EX.ENT##	;ALSO SET ENTRY FLAG
	HRRI	TA,(TB)		;LINK NAMTAB TO EXTAB
	PUSHJ	PP,PUTLNK
	POPJ	PP,
;INIT ITEMS MISSING FROM ENVIRONMENT DIVISION
;ALSO INIT PROGRAM-ID IF MISSING

	INTER.	IA3.
IA3.:	SKIPN	OBJSIZ		;MEMORY SIZE = 0?
	SETOM	OBJSIZ		;IF SO, SET TO -1
	MOVEI	TA,"$"		;DEFAULT DOLLAR SIGN IS "$"
	SKIPN	DOLLR.		;HAS HE SET ONE?
	MOVEM	TA,DOLLR.	;NO
	SKIPN	PROGID		;DID HE SET PROGRAM-ID?
	JRST	IA2.2		;NO, NAME IT "COBOL."
	POPJ	PP,		;YES

;REPLACE DATE-COMPILED COMMENTS WITH TODAY'S DATE

	INTER.	IA4.
IA4.:	PUSHJ	PP,IA5SUB	;PUT SPACE AFTER 'DATE-COMPILED.'
	MOVE	TA,[POINT 7,STDATE]
	MOVEM	TA,PNTR		;POINTER FOR DATE
	MOVEI	TB,11		;9 CHARACTERS
	MOVEM	TB,CTR
IA4.G:	ILDB	CH,PNTR		;GET CHARACTER
	PUSHJ	PP,PUTCPY	;PUT ON LISTING
	SOSLE	CTR
	JRST	IA4.G
IA4X.:	HRRZI	CH,"."		;PUT A PERIOD AFTER DATE
	PUSHJ	PP,PUTCPY
	HRRZI	CH," "		;FAKE FNOCPY SWITCH INTO SENDING THE "."
	PUSHJ	PP,PUTCPY	;BY SENDING A SPACE THAT WILL NEVER MAKE IT

;SKIP TO END OF PARAGRAPH WITHOUT PASSING DATA TO LISTING

	SWON	FNOCPY		;TURN ON 'NO LISTING' FLAG
	PUSHJ	PP,SKPPGF	;SKIP TO END OF PARAGRAPH
	SWOFF	FNOCPY		;CLR NO-COPY-TO-LISTING SWITCH
	TSWF	FSEQ		;/S JOB?
	PUSHJ	PP,PUTCPY	;NO, FORCE 1ST GOOD CHAR. TO LISTING
	PUSHJ	PP,GETITM	;GET A SOURCE ITEM
	JRST	IA0.R		;AND RETURN IT LATER
;SUBSTITUTE "DECSYSTEM-10" FOR COMMENTS IN SOURCE-COMPUTER
;PARAGRAPH.

	INTER.	IA5.
IA5.:	PUSHJ	PP,IA5SUB	;PUT SPACE AFTER 'SOURCE-COMPUTER.'
;	MOVE	TA,[POINT 7,PDP6]
;	JFCL	1,.+1		;CLEAR PC CHANGE OR FLOATING OVERFLOW
;	JRST	.+1		;SET PC CHANGE ON PDP-6
;	JFCL	1,.+2		;SKIP IF PDP-6
	MOVE	TA,[POINT 7,PDP10]
	MOVEM	TA,PNTR		;POINTER FOR SOURCE-COMPUTER NAME
IA5.G:	ILDB	CH,PNTR		;GET CHARACTER
	JUMPE	CH,IA4X.	;IF FINISHED, SKIP-DELETE COMMENTS & RETURN
	PUSHJ	PP,PUTCPY	;PUT ON LISTING
	JRST 	IA5.G

PDP10:	ASCIZ	/DECsystem-10/

;REENABLE LISTING, SEE IF LAST CHAR OUTPUT TO IT WAS "."
;IF SO, PUT A SPACE AFTER THE "."
;IF NOT, REPLACE WHATEVER IT WAS BY SPACE

IA5SUB:	SWOFF	FNOCPY		;ENABLE OUTPUT TO LISTING
	HRRZI	CH," "		;GET A SPACE
	LDB	TA,CPYBHO+1	;GET LAST CHAR PUT ON LISTING
	CAIN	TA,"."		;WAS IT A "."
	JRST	IA5S0		;YES
	DPB	CH,CPYBHO+1	;NO, REPLACE IT BY SPACE
	POPJ	PP,
IA5S0:	PUSHJ	PP,PUTCPY	;PUT SPACE AFTER "."
	POPJ	PP,
;PUT SAVED INTEGER INTO OBJECT-COMPUTER MEMORY SIZE WORD

	INTER.	IA8.
IA8.:	POP	SAVPTR,TB	;GET INTEGER FROM SAVE LIST
IA8.1:	CAMN	TB,OBJSIZ	;IF INTEGER=OBJSIZ, IGNORE IT
	POPJ	PP,
	SKIPN	OBJSIZ		;OBJSIZ=0?
	JRST	IA8.P		;YES
	EWARNJ	BE6.		;NO, 'MORE THAN 1 OBJ-COMPUTR PARA'
IA8.P:	MOVEM	TB,OBJSIZ	;PUT INTEGER IN OBJSIZ
	POPJ	PP,

;CONVERT #MODULES TO #WORDS & PUT INTO OBJSIZ

	INTER.	IA9.
IA9.:	POP	SAVPTR,TB	;GET SAVED INTEGER
	IMULI	TB,^D1024	;#MODULES * 1K WORDS EACH
	JRST	IA8.1

;CONVERT #CHARACTERS (SIXBIT) TO #WORDS & PUT INTO OBJSIZ

	INTER.	IA10.
IA10.:	POP	SAVPTR,TB	;GET SAVED INTEGER
	ADDI	TB,5		;FORCE ROUNDING UPWARD
	IDIVI	TB,6		;N CHARS = N+5/6 WORDS
	JRST	IA8.1

;TURN OFF 'FILE OPTIONAL' FLAG

	INTER.	IA12.
IA12.:	SWOFF	FOPT		;OFF
	POPJ	PP,

;TURN ON 'FILE OPTIONAL' FLAG

	INTER.	IA13.
IA13.:	SWON	FOPT		;ON
	POPJ	PP,
;PUT SELECTED FILE-NAME IN FILE TABLE

	INTER.	IA14.
IA14.:	TLO	W2,GWDEF	;PUT DEFINING REFERENCE ON CREF FILE
	PUSHJ	PP,PUTCRF##
	TLNE	W1,GWNOT	;IS NAME IN NAMTAB?
	JRST	IA14.B		;NO--PUT IN
	HLRZ	TA,W2		;YES, GET NAMTAB RELATIVE ADDR.
	LSH	TA,-2
	HRLZM	TA,NAMADR	;SAVE IT
	JRST	IA14.C		;NOT FOUND--CREATE
IA14.B:	PUSHJ	PP,BLDNAM	;ENTER NAME IN NAMTAB
	MOVEM	TA,NAMADR	;SAVE ADDRESS
IA14.C:	MOVE	TA,CURFIL	;CURRENT FILE ENTRY ADDRESS
	MOVEM	TA,LSTFIL	;SAVE IT
	MOVE	TA,[XWD CD.FIL,SZ.FIL]	;GET 15-WORD FILTAB ENTRY
	PUSHJ	PP,GETENT
	MOVEM	TA,CURFIL	;SAVE ADDRESS OF CURRENT FILTAB ENTRY
	HLLZ	TB,NAMADR	;NAMTAB ENTRY REL.ADDR.
	MOVEM	TB,(TA)		;TO WORD 1 OF FILTAB ENTRY
	DPB	W2,FI.LNC	;LINE NUMBER, CHARACTER POSITION
	HRRZI	TB,3		;INITIALIZE OPTIONS AS NOT YET DECLARED
	DPB	TB,FI.ERM	;EXT. RECORDING MODE
	DPB	TB,FI.LBL	;LABELS
	DPB	TB,FI.ACC	;ACCESS MODE
	DPB	TB,FI.IRM	;AND INT. RECORDING MODE
	TSWF	FOPT		;TEST WHETHER OPTIONAL FILE
	DPB	TB,FI.OPT	;SET FLAG IF IT IS
	HLRZ	TA,LSTFIL	;REL.ADDR.OF LAST FILTAB ENTRY
	JUMPE	TA,IA14.D	;NULL PREVIOUS ENTRY
	HRRZ	TB,FILLOC	;STARTING ADDRESS OF FILTAB
	ADD	TA,TB		;ABS.ADDR. OF LAST FILTAB ENTRY
	HLRZ	TB,CURFIL	;REL. ADDR. OF CURRENT FILTAB ENTRY
	DPB	TB,FI.NXT	;'NEXT ENTRY' LINK
IA14.D:	HLLZ	TA,CURFIL	;ENTRY REL. ADDR.
	HLR	TA,NAMADR	;NAMTAB ENTRY REL. ADDR.
	JRST	PUTLNK		;LINK FILTAB & NAMTAB

;GET VALUE OF INTEGER & PUT ON SAVLST

	INTER.	IA16.
IA16.:	PUSHJ	PP,IA16S.	;GET VALUE OF INTEGER
	HRRZI	TC,1		;ERROR -- ASSUME VALUE OF 1
IA16.A:	PUSH	SAVPTR,TC	;SAVE INTEGER VALUE ON SAVLST
	POPJ	PP,

;GET VALUE OF NUMERIC LITERAL
;CALL:	PUSHJ	PP,IA16S.
;	ERROR RETURN (MESSAGE BE25. GIVEN)
;	NORMAL RETURN (VALUE IN TC)

IA16S.:	HLRZ	TB,W1		;L.H. OF FIRST GETWRD PARAMETER
	TRNE	TB,GWNLIT	;IS THIS A NUMERIC LITERAL?
	TRNE	TB,GWDP		;YES, IS IT AN INTEGER?
	EWARNJ	BE25.		;NO, 'POSITIVE INTEGER REQUIRED' -- EXIT
	HRRZI	TA,LITVAL	;ADDRESS OF INTEGER (ASCII STRING FORM)
	ANDI	TB,000777	;LENGTH OF STRING
	MOVEM	TB,CTR
	PUSHJ	PP,GETVAL	;GET VALUE OF INTEGER
	AOS	(PP)		;SKIP RETURN
	POPJ	PP,
;GET DEVICE NAME

	INTER.	IA18.
IA18.:	TLNE	W1,GWHYF	;HYPHEN IN DEV-NAME?
	EWARNW	BE83.		;YES, 'IMPROPER DEVICE NAME'
	SETZM	NAMWRD+1	;DELETE ALL BUT 6 CHARS
	MOVE	TA,[POINT 6,NAMWRD]	;PTR TO SIXBIT NAME
	MOVE	TB,[POINT 7,TBLOCK,6]	;PTR TO ASCII NAME STORE
	MOVNI	TD,6		;6 CHAR CTR
IA18.L:	ILDB	TC,TA		;GET CHARACTER OF NAME
	JUMPE	TC,IA18.M	;END OF NAME
	ADDI	TC,40		;CONVERT SIxBIT TO ASCII
	IDPB	TC,TB		;SAVE CHARACTER
	AOJL	TD,IA18.L	;CONTINUE UNTIL 6 CHARS
IA18.M:	ADDI	TD,6		;GET # OF CHARS IN NAME
	DPB	TD,[POINT 7,TBLOCK,6]
	IDIVI	TD,5		;GET LENGTH OF VALTAB ENTRY (INCL CHAR CNT)
	ADDI	TD,1		;AT LEAST 1 WORD
	MOVEM	TD,ESIZE	;SAVE ENTRY SIZE
	HRLI	TD,CD.VAL	;VALTAB CODE
	MOVE	TA,TD
	PUSHJ	PP,GETENT	;FIND VALTAB ENTRY
	MOVEM	TA,VALADR	;SAVE ADDRESS
	MOVE	TD,TBLOCK	;MOVE WORD OF NAME
	MOVEM	TD,(TA)		;TO VALTAB
	MOVE	TD,TBLOCK+1	;POSSIBLE 2ND WORD OF NAME
	SOSLE	ESIZE		;1 OR 2 WORDS NEEDED?
	MOVEM	TD,1(TA)	;2, STORE 2ND WORD
	HRRZ	TA,CURFIL	;ABS. ADDR. OF FILTAB ENTRY
	LDB	TB,FI.NDV	;DEVICE COUNT FOR CURRENT FILE
	AOJ	TB,		;SET DEV COUNT UP BY 1
	DPB	TB,FI.NDV	;DEPOSIT NEW DEVICE COUNT
	LDB	TB,FI.VAL	;VALTAB LINK TO UNIT NAME
	JUMPN	TB,IA18.X	;EXIT IF ALREADY SET
	HLRZ	TB,VALADR	;VALTAB POINTER
	DPB	TB,FI.VAL	;PUT LINK IN ENTRY
IA18.X:	POPJ	PP,
;GET NUMBER OF ALTERNATE BUFFERS

	INTER.	IA19.
IA19.:	PUSHJ	PP,IA16S.	;GET VALUE OF INTEGER
	POPJ	PP,		;NOT AN INTEGER
	ADDI	TC,1		;ADD 1 TO INTEGER (PRIMARY BUFFER)
	HRRZ	TA,CURFIL	;FILTAB ENTRY ABSOLUTE ADDRESS
	LDB	TB,FI.NBF	;GET NUMBER OF BUFFERS FIELD
	JUMPE	TB,IA19.P	;RESERVE CLAUSE SEEN ALREADY?
	CAIE	TB,(TC)		;YES, IS THIS THE SAME VALUE?
JBE16.:	EWARNJ	BE16.		;NO, 'DUPLICATE CLAUSE' MSG
	POPJ	PP,
IA19.P:	DPB	TC,FI.NBF	;INSERT NO. OF BUFFERS IN FILTAB ENTRY
	POPJ	PP,

;FLAG MISSING INTEGER OR 'NO' AFTER 'RESERVE'
;AND ASSUME 'NO' SEEN

	INTER.	IA20E.
IA20E.:	EWARNW	BE18.		;'IMPROPER CLAUSE'
	SKPNAM

;INDICATE NO ALTERNATE BUFFERS

	INTER.	IA20.
IA20.:	HRRZ	TA,CURFIL	;FILTAB ENTRY ABS. ADDR.
	LDB	TB,FI.NBF	;GET NUMBER OF BUFFERS FIELD
	CAILE	TB,1		;0 OR 1?
	EWARNJ	BE16.		;NO, GIVE 'DUPLICATE CLAUSE' MSG
	HRRZI	TC,1		;SET TO 1 BUFR (NO ALTERNATES)
	JRST	IA19.P		;PUT INTO FILTAB ENTRY

;CHECK FOR MORE THAN 1 ACCESS MODE SETTING PER FILE

	INTER.	IA21.
IA21.:	HRRZ	TA,CURFIL	;AIM AT CURRENT FILTAB ENTRY
	LDB	TB,FI.ACC	;GET CURRENT SETTING OF ACCESS MODE BITS
	CAIN	TB,3		;IS IT AT INITIAL VALUE?
	POPJ	PP,		;YES
	HRRZI	TA,ED12.	;AFTER DOING BE16., GO TO SYNTAX NODE ED12.
	MOVEM	TA,(NODPTR)
	EWARNJ	BE16.		;'DUPLICATE CLAUSE'
;SAVE SYMBOLIC KEY CODE FOR HLDTAB

	INTER.	IA22.
IA22.:
IFN ISAM,<
	HRRZI	TB,%HL.SY	;GET CODE
	JRST	IA24X.
	>
IFE ISAM,<EWARNJ BE91.>		;?NOT IMPLEMENTED

;SAVE RECORD KEY CODE FOR HLDTAB

	INTER.	IA22R.
IA22R.:
IFN ISAM,<
	HRRZI	TB,%HL.RC	;GET CODE
	JRST	IA24X.
	>
IFE ISAM,<EWARNJ BE91.>		;?NOT IMPLEMENTED

;INITIALIZE FILE-LIMIT CLAUSE

	INTER.	IA23.
IA23.:	PUSHJ	PP,IA62.	;RE-INIT SAVLST
	HRRZ	TA,CURFIL	;FILTAB ENTRY ABS. ADDR.
	LDB	TB,FI.NFL	;GET NO. OF FILE-LIMIT CLAUSES
	JUMPN	TB,JBE16.	;ERROR IF NOT 0 (DUP. CLAUSE)
	POPJ	PP,

;SAVE ACTUAL KEY CODE FOR HLDTAB

	INTER.	IA24.
IA24.:	HRRZI	TB,%HL.AK	;GET CODE
IA24X.:	MOVEM	TB,CTR		;STORE CODE IN HLDTAB
	POPJ	PP,
;SET SEQUENTIAL ACCESS FLAG

	INTER.	IA25.
IA25.:	HRRZI	TB,%ACC.S	;ACCESS MODE SEQUENTIAL CODE
	JRST	IA27.X		;INSERT IN FILTAB ENTRY

;SET INDEXED-SEQUENTIAL ACCESS MODE

	INTER.	IA26.
IA26.:
IFN ISAM,<
	HRRZI	TB,%ACC.I	;ACCESS MODE IS ISAM CODE
	JRST	IA27.X		;INSERT IN FILTAB ENTRY
	>
IFE ISAM,<EWARNJ BE91.>		;?NOT IMPLEMENTED

;SET RANDOM ACCESS FLAG

	INTER.	IA27.
IA27.:	HRRZI	TB,%ACC.R	;ACCESS MODE RANDOM CODE
IA27.X:	HRRZ	TA,CURFIL	;ABS. ADDR. OF FILTAB ENTRY
	DPB	TB,FI.ACC	;DEPOSIT IN FILTAB ENTRY
	POPJ	PP,
;PUT KEY DATA-NAME IN HLDTAB

	INTER.	IA28.
IA28.:	PUSHJ	PP,IA59S.	;SAVE NAMTAB ADDR
	PUSHJ	PP,IA28S.	;SET UP HLDTAB ENTRY
	HRRZ	TB,CTR		;GET KEY CODE
	DPB	TB,HL.COD	;& PUT IT IN HLDTAB
	HLRZ	TB,CURFIL	;STORE FILTAB LINK IN HLDTAB
	DPB	TB,HL.LNK
	POPJ	PP,

;SET UP HLDTAB ENTRY

IA28S.:	MOVE	TA,[XWD CD.HLD,SZ.HLD]	;GET A HLDTAB ENTRY
	PUSHJ	PP,GETENT
	MOVEM	TA,CURHLD	;SAVE ADDR
	HLRZ	TB,CURNAM	;PUT LINK TO NAMTAB IN HLDTAB
	DPB	TB,HL.NAM
	DPB	W2,HL.LNC	;ALSO POSITION OF ITEM IN SOURCE
	SETZ	TB,		;CLR # OF QUALIFIERS
	DPB	TB,HL.QAL
	POPJ	PP,
;LITERAL FILE-LIMIT

	INTER.	IA29.
IA29.:	HLRZ	TB,W1		;GET SIZE OF LITERAL
	ANDI	TB,000777
	TLNE	W1,GWNLIT	;IS IT A NUMERIC LITERAL?
	TLNE	W1,GWDP		;DOES IT HAVE A DECIMAL POINT?
	EWARNJ	BE264.		;NOT AN INTEGER
	HRRZI	TB,1(TB)	;1 MORE FOR NUMBER OF CHARACTERS
	MOVEM	TB,LSIZE	;SAVE
	HRRZI	TB,4(TB)	;ROUND UPWARDS
	IDIVI	TB,5		;NO. OF WORDS REQUIRED
	HRRZI	TA,(TB)		;GET A VALTAB ENTRY OF THIS SIZE
	HRLI	TA,CD.VAL
	PUSHJ	PP,GETENT
	MOVEM	TA,CURVAL	;SAVE ADDRESS
	MOVE	TB,[POINT 7,(TA)]	;PTR TO VALTAB STORE
	MOVE	TC,[POINT 7,LITVAL]	;PTR TO LITERAL
	MOVE	TE,LSIZE	;CHAR COUNT FOR THE MOVE
	MOVEI	TD,-1(TE)	;1ST STORE THE TRUE CHAR COUNT
	JRST	IA29.L+1
IA29.L:	ILDB	TD,TC		;GET CHARACTER
	IDPB	TD,TB		;STASH IT
	SOJG	TE,IA29.L
	HLRZ	TA,CURVAL	;SAVE VALTAB PTR
	JRST	IA30.X

;PUT FILE-LIMIT DATA-NAME IN HLDTAB

	INTER.	IA30.
IA30.:	PUSHJ	PP,IA59S.	;SAVE NAMTAB ADDR
	PUSHJ	PP,IA28S.	;SET UP HLDTAB ENTRY
	HLRZ	TA,CURHLD	;PUT HLDTAB PTR ON SAVE LIST
IA30.X:	PUSH	SAVPTR,TA
	POPJ	PP,

;ERROR OF TYPE: "FILE-LIMITS 1 THRU 200, FOO."
;(OBJECT IS TO KEEP HLDTAB FROM GETTING MIXED UP)

	INTER.	IA30E
IA30E:	PUSHJ	PP,IA32.	;SET UP DUMMY LOW LIMIT
	PUSHJ	PP,IA34.	;MAKE FOO THE HIGH LIMIT
	EWARNJ	BE303.		;?'THRU' EXPECTED
;ITEM BEFORE 'THRU' BECOMES LOW FILE-LIMIT

	INTER.	IA31.
IA31.:	HRRZ	TA,CURFIL	;GET PTR TO CURRENT FILTAB ENTRY
	LDB	TC,FI.NFL	;INCREMENT NO. OF FILE-LIMITS CLAUSES
	ADDI	TC,1
	DPB	TC,FI.NFL	;PUT NEW VALUE IN FILTAB FIELD
	MOVE	TA CD.FIL,1]	;GET 1 WORD IN FILTAB FOR FILE-LIMITS
	PUSHJ	PP,GETENT
	MOVEM	TA,CFLM		;SAVE ADDRESS
	POP	SAVPTR,TD	;GET POINTER FROM SAVE LIST
	CAIL	TD,<CD.VAL>B20	;SAVING LOW-LIM ON VALTAB OR HLDTAB?
	HRLZM	TD,(TA)		;VALTAB, PUT PTR TO LOW-LIMIT IN FILTAB
	HRRZI	TB,%HL.LL	;SET LOW-LIMIT FLAG IN HLDTAB
IA31.X:	TRNE	TD,600000	;VALTAB OR HLDTAB ADDR?
	POPJ	PP,		;VALTAB
	HRRZ	TA,HLDLOC	;GET HLDTAB START ADDR.
	ADDI	TA,(TD)		;PLUS REL ADDR. OF CURRENT WORD
	DPB	TB,HL.COD
	HLRZ	TB,CFLM		;PUT FILTAB LINK IN HLDTAB
	DPB	TB,HL.LNK
	POPJ	PP,

;SINGLE-ITEM FILE-LIMIT SEEN -- ASSUME 1 AS LOW LIMIT

	INTER.	IA32.
IA32.:	MOVE	TA,[XWD CD.VAL,1]	;GET 1-WORD VALTAB ENTRY
	PUSHJ	PP,GETENT
	MOVSI	TB,5420		;PUT '1' IN VALTAB
	MOVEM	TB,(TA)
	HLRZ	TB,TA		;PUT VALTAB POINTER ON SAVE LIST
	PUSH	SAVPTR,TB
	JRST	IA31.		;PUT LOW LIMIT OF 1 IN FILTAB

;STORE HIGH LIMIT IN FILTAB FILE-LIMIT WORD

	INTER.	IA34.
IA34.:	HLRZ	TA,CFLM		;REL ADDR OF FILE-LIMIT WORD
	HRRZ	TB,FILLOC	;FILTAB ENTRY ADDR
	ADD	TA,TB		;ABS. ADDR. OF CURRENT FILE-LIMIT
	POP	SAVPTR,TD	;GET POINTER TO LAST ITEM
	CAIL	TD,<CD.VAL>B20	;SAVING HI-LIM ON VALTAB OR HLDTAB?
	HRRM	TD,(TA)		;VALTAB, STORE AS HIGH LIMIT
	HRRZI	TB,%HL.HL	;SET HI-LIM FLAG IN HLDTAB
	JRST	IA31.X
;GET VALUE OF INTEGER & PUT INTO SEGMENT LIMIT WORD

	INTER.	IA35.
IA35.:	PUSHJ	PP,IA16S.	;GET VALUE OF INTEGER
	POPJ	PP,		;ITEM NOT AN INTEGER
	JUMPLE	TC,JBE19.	;<=0 IS ILLEGAL
	CAILE	TC,^D49		;>=50 IS ILLEGAL
JBE19.:	EWARNJ	BE19.		;'IMPROPER SEGMENT LIMIT' -- EXIT
	MOVE	TA,SEGLIM	;GET PREVIOUS LIMIT
	CAIN	TA,^D50		;50 IS INITIAL VALUE
	JRST	IA35.A		;HAS NOT YET BEEN RESET
	CAMN	TC,TA		;RESETTING TO SAME VALUE?
	POPJ	PP,		;YES, IGNORE IT
	EWARNJ	BE16.		;NO, 'CLAUSE DUPLICATED'
IA35.A:	MOVEM	TC,SEGLIM	;STORE NEW SEGMENT LIMIT
	POPJ	PP,
;SAME RECORD AREA (ONLY) FOR FILES IN LIST

	INTER.	IA36.
IA36.:	SWON	FSAME		;SET FLAG
	POPJ	PP,

;SAME AREA (REC. AREA & BUFRS) FOR FILES IN LIST

	INTER.	IA37.
IA37.:	SWOFF	FSAME		;CLR SAME-REC-AREA FLAG
CPOPJ:	POPJ	PP,

;SAVE PTR TO FIRST FILE IN SAME-AREA CLAUSE

	INTER.	IA38.
IA38.:	SKIPE	SAMSRT		;IF 'SAME SORT' CLAUSE, DONT DO ANYTHING
	POPJ	PP,
	PUSHJ	PP,IA38S.	;GET PTR TO FILTAB ENTRY FOR THIS FILE
	HLRZ	TC,TB		;GET FILTAB ENTRY REL. ADDR.
	PUSH	SAVPTR,TC	;PUT ON SAVLST
	PUSH	SAVPTR,TC	;TWICE
	HRRZ	TA,TB		;GET FILTAB ENTRY ABS. ADDR.
	LDB	TB,FI.SAL	;EXAMINE SAME-AREA LINK
	TSWF	FSAME		;IS THIS A SAME-AREA OR A SAME-REC-AREA CLAUSE?
	LDB	TB,FI.SRA	;THE LATTER -- EXAMINE SAME-REC-AREA LINK
	JUMPE	TB,CPOPJ	;IF NOT ON, RETURN
	TSWF	FSAME		;'SAME REC. AREA'?
	EWARNW	BE173.		;YES, 'FILE ALREADY IN SAME RECORD AREA CLAUSE'
	TSWT	FSAME		;'SAME AREA'?
	EWARNW	BE174.		;YES, 'FILE ALREADY IN SAME AREA CLAUSE'
	HRRZI	NODE,ED135.	;NEXT SYNTAX NODE WILL BE ED135.
	MOVEM	NODE,0(NODPTR)
	JRST	IA62.		;RESET SAVE LIST POINTER

;GET PTR TO FILTAB ENTRY

IA38S.:	HLRZ	TA,W2		;GET NAMTAB REL. ADDR
	LSH	TA,-2
	HRRZI	TB,CD.FIL	;FIND FILTAB ENTRY FOR THIS NAME
	PUSHJ	PP,FNDLNK
	JRST	IA38.E		;NONE FOUND
	POPJ	PP,

IA38.E:	TTCALL	3,[ASCIZ /IA38S.--TYPE=FILE-NAME BUT NO FILTAB LINK FOUND.
/]
	JRST	KILL

;LINK THIS FILE TO PREVIOUS FILE IN SAME AREA CLAUSE
;AND SAVE PTR TO THIS FILE IN CASE THERE ARE MORE

	INTER.	IA38A.
IA38A.:	SKIPE	SAMSRT		;IF 'SAME SORT' CLAUSE, DONT DO ANYTHING
	POPJ	PP,
	PUSHJ	PP,IA38S.	;GET PTR TO FILTAB ENTRY FOR THIS FILE
	MOVE	TD,(SAVPTR)	;GET PTR TO PREVIOUS FILE
	HRRZ	TA,FILLOC
	ADD	TA,TD		;ABS. ADDR. OF THAT FILTAB ENTRY
	HLRS	TB		;GET LINK TO THIS FILE
	TSWT	FSAME		;SAME-AREA OR SAME-REC-AREA?
	JRST	IA38AA		;SAME-AREA
	LDB	TE,FI.SRA	;GET SAME-REC-AREA LINK
	JUMPN	TE,JBE173	;IF NOT 0, 'FILE ALREADY IN SAME-REC-AREA CLAUSE'
	DPB	TB,FI.SRA	;STORE LINK TO THIS FILE IN THAT FILE'S ENTRY
	JRST	IA38AB
IA38AA:	LDB	TE,FI.SAL	;GET SAME-AREA LINK
	JUMPN	TE,JBE174	;IF NOT 0, 'FILE ALREADY IN SAME-AREA CLAUSE'
	DPB	TB,FI.SAL	;STORE LINK TO THIS FILE IN THAT FILE'S ENTRY
IA38AB:	MOVEM	TB,(SAVPTR)	;SAVE POINTER TO THIS FILE
	POPJ	PP,

JBE173:	EWARNJ	BE173.
JBE174:	EWARNJ	BE174.

;LINK LAST FILE IN SAME-AREA CLAUSE TO THE FIRST

	INTER.	IA39.
IA39.:	SKIPE	SAMSRT		;IF 'SAME SORT' CLAUSE, DONT DO ANYTHING
	POPJ	PP,
	HRRZ	TA,0(SAVPTR)	;REL. ADDR. OF LAST FILE IN GROUP
	PUSHJ	PP,LNKSET	;GET ABS. ADDR.
	HRRZ	TB,-1(SAVPTR)	;REL. ADDR. OF FIRST FILE IN GROUP
	TSWF	FSAME		;SAME-REC AREA?
	DPB	TB,FI.SRA	;YES, STORE LINK
	TSWT	FSAME		;SAME-AREA?
	DPB	TB,FI.SAL	;YES, STORE LINK
	JRST	IA62.		;RESET SAVE LIST POINTER
;SAVE PTR TO FILE FOR SAME-DEVICE LINKAGE

	INTER.	IA40.
IA40.:	PUSHJ	PP,IA38S.	;GET PTR TO FILTAB ENTRY FOR THIS FILE
	HRRZI	TA,1		;SAVE POSITION 1 (DEFAULT POS.)
	PUSH	SAVPTR,TA
	PUSH	SAVPTR,TB	;SAVE FILTAB ENTRY ADDR
	MOVE	TA,TB		;GET NO. OF DEVICES FOR THIS FILE
	LDB	TB,FI.NDV
	CAIE	TB,1		;MUST BE 1
	EWARNJ	BE197.		;'ONLY ONE DEVICE ALLOWED'
	LDB	TC,FI.SDL	;GET SAME-DEVICE LINK
	JUMPN	TC,IA40.X	;IF ON, LEAVE IT ALONE
	HLRZ	TB,TA		;GET REL ADDR OF FILTAB ENTRY
	DPB	TB,FI.SDL	;MAKE FILE POINT TO ITSELF IF NOWHERE ELSE
IA40.X:	POPJ	PP,

;GET POSITION OF FILE ON TAPE & STORE IN FILTAB ENTRY

	INTER.	IA41.
IA41.:	PUSHJ	PP,IA16S.	;GET VALUE OF INTEGER
	POPJ	PP,		;NOT AN INTEGER
IA41.A:	MOVEM	TC,TBLOCK	;SAVE POSITION
	HLRZ	TA,(SAVPTR)	;GET FILTAB ENTRY REL. ADDR.
	PUSHJ	PP,LNKSET	;GET ABS. ADDR
	MOVE	TC,TBLOCK	;GET POSITION ON TAPE
	LDB	TB,FI.POS	;EXAMINE TAPE POSITION FIELD
	JUMPE	TB,IA41.P	;ON?
	CAIE	TB,(TC)		;YES, SAME AS NEW ONE?
	EWARNJ	BE16.		;NO, 'DUPLICATE CLAUSE'
	MOVEM	TC,-1(SAVPTR)	;YES, PUT ON SAVE LIST AS POSITION
	POPJ	PP,
IA41.P:	DPB	TC,FI.POS	;PUT INTEGER IN POSITION FIELD
	MOVEM	TC,-1(SAVPTR)	;AND ON SAVE LIST
	POPJ	PP,

;NO POSITION CLAUSE
;GET POSITION FROM SAVLST & STORE IN FILTAB ENTRY

	INTER.	IA42.
IA42.:	MOVE	TC,-1(SAVPTR)	;GET SAVED INTEGER
	JRST	IA41.A
;CHAIN SAME-DEVICE LINKS
;AND CHECK NEW FILE FOR SAME DEVICE AS PREVIOUS

	INTER.	IA43.
IA43.:	PUSHJ	PP,IA38S.	;GET PTR TO FILTAB ENTRY FOR THIS FILE
	MOVE	TA,TB		;FILTAB ENTRY ADDR.
	LDB	TB,FI.NDV	;NO. OF DEVICES FOR THIS FILE
	CAIE	TB,1		;MUST BE 1
	EWARNJ	BE197.		;'ONLY ONE DEVICE ALLOWED'
	MOVEM	TA,TBLOCK	;SAVE POINTER TO CURRENT FILTAB ENTRY
	LDB	TA,FI.VAL	;VALTAB LINK
	PUSHJ	PP,LNKSET	;GET ABS. ADDR.
	MOVEM	TA,SAVETA	;AND SAVE ADDR OF DEVICE NAME
	HRRZ	TA,(SAVPTR)	;GET SAVED FILE FILTAB ADDR
	LDB	TA,FI.VAL	;VALTAB LINK
	PUSHJ	PP,LNKSET	;GET ABS. ADDR. OF DEVICE NAME OF PREV. FILE
	HLRZ	TC,(TA)
	LSH	TC,-13		;LENGTH OF ENTRY IN CHARACTERS
	IDIVI	TC,5
	ADDI	TC,1		;AND IN WORDS, ROUNDED UP
	MOVE	TB,SAVETA	;CURRENT FILE VALTAB ADDRESS
IA43.L:	MOVE	TD,(TA)		;COMPARE WORD OF DEVICE NAMES
	CAME	TD,(TB)
	JRST	IA43.E		;DIFFERENT DEVICES
	ADDI	TA,1		;GO TO NEXT WORD
	ADDI	TB,1
	SOJG	TC,IA43.L	;ALL WORDS DONE?
	AOS	-1(SAVPTR)	;YES, DEFAULT TAPE POS. IS NEXT ON TAPE
	HRRZ	TA,(SAVPTR)	;FILTAB ADDR OF LAST FILE IN LIST
	LDB	TC,FI.SDL	;GET REL ADDR OF 1ST FILE IN LIST
	HRRZ	TA,TBLOCK	;STORE LINK TO 1ST FILE IN NEW FILE ENTRY
	DPB	TC,FI.SDL
	HLRZ	TC,TBLOCK	;REL. FILTAB ADDR OF NEW FILE
	HRRZ	TA,(SAVPTR)	;STORE LINK TO NEW FILE IN OLD FILE ENTRY
	DPB	TC,FI.SDL
	MOVE	TA,TBLOCK	;SAVE ADDR OF NEW FILE
	MOVEM	TA,(SAVPTR)
	POPJ	PP,

IA43.E:	HRRZI	TA,ED158.	;AFTER ERROR MSG, GO TO SYNTAX NODE ED158.
	MOVEM	TA,(NODPTR)
	EWARNJ	BE23.		;'NOT SAME DEV. AS PREV. FILE'
;GET MNEMONIC-NAME FOR CONSOLE

	INTER.	IA44.
IA44.:	HRLZI	TA,040000	;GET CONSOLE TYPE FLAG

;ENTER HERE TO STORE NAME IN MNETAB
;TA SHOULD CONTAIN APPROPRIATE TYPE FLAG

IA44.D:	MOVEM	TA,MNETYP	;STORE TYPE FLAG
	TLNN	W1,400000	;IS THIS NAME IN NAMTAB?
	JRST	IA44.A		;YES
	TLNE	W1,30000	;IS IT A LITERAL OR RESERVED WORD?
	EWARNJ	BE24.		;YES, 'ILLEGAL MNEMONIC-NAME'
	TLO	W2,GWDEF	;PUT DEFINING REFERENCE ON CREF FILE
	PUSHJ	PP,PUTCRF
	PUSHJ	PP,BLDNAM	;PUT IN NAMTAB
	MOVEM	TA,CURNAM	;SAVE NAMTAB PTR
IA44.B:	MOVE	TA,[XWD CD.MNE,SZ.MNE]	;GET MNETAB ENTRY
	PUSHJ	PP,GETENT
	HLRZ	TC,CURNAM	;GET NAMTAB POINTER
	ORI	TC,700000	;SET MNETAB FLAG
	MOVSM	TC,(TA)		;PUT NAMTAB LINK IN MNETAB
	MOVE	TC,MNETYP	;GET TYPE FLAG
	TLNE	TC,730000	;SKIP IF NOT SWITCH, CHANNEL, CODE, OR STATUS
	HRR	TC,(SAVPTR)	;GET SWITCH OR CHANNEL NUMBER
	MOVEM	TC,1(TA)	;TO WORD 2 OF ENTRY
	HLR	TA,CURNAM	;NAMTAB REL. ADDR.
	PUSHJ	PP,PUTLNK	;LINK NAMTAB TO MNETAB
	POPJ	PP,
IA44.A:	HLRZ	TA,W2		;GET NAMTAB PTR
	LSH	TA,-2
	HRRZI	TB,CD.MNE	;MNETAB FLAG
	HRLZM	TA,CURNAM	;SAVE NAMTAB REL. ADDR.
	PUSHJ	PP,FNDLNK	;FIND MNETAB LINK
	JRST	IA44.B		;NOT FOUND
	EWARNJ	BE28.		;'MNEMONIC-NAME ALREADY IN USE'
;GET MNEMONIC-NAME FOR LPT CHANNEL

	INTER.	IA46.
IA46.:	HRLZI	TA,020000	;GET CHANNEL TYPE FLAG
	JRST	IA44.D

;GET MNEMONIC-NAME FOR HARDWARE SWITCH

	INTER.	IA47.
IA47.:	HRLZI	TA,400000	;GET SWITCH TYPE FLAG
	JRST	IA44.D

;SET SWITCH-ON STATUS FLAG

	INTER.	IA48.
IA48.:	SWON	FSTAT		;ON
	POPJ	PP,

;SET SWITCH-OFF STATUS FLAG

	INTER.	IA49.
IA49.:	SWOFF	FSTAT		;OFF
	POPJ	PP,

;GET MNEMONIC-NAME FOR SWITCH STATUS

	INTER.	IA50.
IA50.:	TSWT	FSTAT;
	HRLZI	TA,100000	;'OFF STATUS'
	TSWF	FSTAT;	
	HRLZI	TA,200000	;'ON STATUS'
	JRST	IA44.D
;GET CHARACTER FOR CURRENCY SIGN

	INTER.	IA51.
IA51.:	TLNE	W1,200000	;IS ITEM A LITERAL?
	TLNE	W1,174000	;SIMPLE ALPHANUMERIC?
	EWARNJ	BE27.		;NO, 'MUST BE A 1 CHAR NON-NUMERIC LITERAL'
	TLNE	W1,000776	;IS ITS LENGTH 1?
	EWARNJ	BE27.		;NO
	LDB	TA,[POINT 7,LITVAL,6]	;YES, GET THAT CHARACTER
	SKIPN	DOLLR.		;CURR. SIGN ALREADY GIVEN?
	JRST	IA51.P		;NO
	CAMN	TA,DOLLR.	;YES, IS NEW ONE THE SAME?
	POPJ	PP,		;YES
	EWARNJ	BE16.		;NO, 'DUPLICATE CLAUSE'
IA51.P:	MOVEI	TB,-40(TA)	;CONVERT TO SIXBIT
	CAIL	TB,1		;IN SIXBIT RANGE & NOT SPACE?
	CAIL	TB,100
	EWARNJ	BE175.		;NO, INVALID CHARACTER
	MOVE	TD,[POINT 6,CSL]	;AIM AT LIST OF ILLEGAL CHARS
IA51.R:	ILDB	TC,TD		;GET A CHAR FROM LIST
	JUMPE	TC,IA51.Q	;END OF LIST -- ALL IS WELL
	CAIN	TB,(TC)		;IS THIS A MATCH?
	EWARNJ	BE175.		;YES, INVALID CHARACTER
	JRST	IA51.R		;NO, TRY NEXT
IA51.Q:	MOVEM	TA,DOLLR.	;STASH NEW CURRENCY SIGN
	POPJ	PP,

;ITEMS ILLEGAL AS CURRENCY SIGN
;(SPACE MARKS END OF LIST)

CSL:	SIXBIT	/0123456789*+-,.;()"ABCDPRSVXZ /
;SWITCH FUNCTIONS OF COMMA AND DECIMAL POINT

	INTER.	IA52.
IA52.:	MOVEI	TA,"."		;COMMA = .
	MOVEM	TA,COMA.##
	MOVEI	TA,","		;DEC.PT. = ,
	MOVEM	TA,DCPNT.##
	POPJ	PP,

;MISSING INTEGER -- WARN AND ASSUME 0

	INTER.	IA54E.
IA54E.:	EWARNW	BE25.		;'POSITIVE INTEGER REQUIRED'
	SKPNAM

;PUT A ZERO VALUE ON THE SAVLST

	INTER.	IA54.
IA54.:	SETZ	TC,		;PUT 0 ON SAVE LIST
	JRST	IA16.A

;SET RERUN FLAG & COUNT FOR FILE

	INTER.	IA55.
IA55.:	PUSHJ	PP,IA38S.	;GET PTR TO FILTAB ENTRY FOR THIS FILE
	HRRZ	TA,TB		;FILTAB ENTRY ABS. ADDR.
	POP	SAVPTR,TC	;GET SAVED INTEGER
	JUMPE	TC,IA55.A	;RERUN END-OF-REEL
	DPB	TC,FI.RCT	;RERUN COUNT
	HRRZI	TC,1
	DPB	TC,FI.RRC	;SET RERUN ON COUNT FLAG
	POPJ	PP,

IA55.A:	HRRZI	TC,1
	DPB	TC,FI.RER	;SET RERUN END-OF-REEL FLAG
	POPJ	PP,

;SET SPECIAL-NAMES PARAGRAPH FLAG

	INTER.	IA56.
IA56.:	TSWF	FSPNAM		;ALREADY SEEN A SPECL-NAMES PARA?
	EWARNJ	BE30.		;YES, 'DUPLICATE PARAGRAPH'
	SWON	FSPNAM		;NO, BUT NOW WE HAVE
	POPJ	PP,

;WIPE LAST ENTRY OFF SAVLST

	INTER.	IA57.
IA57.:	POP	SAVPTR,TA	;LOSE SAVE LIST ENTRY
	POPJ	PP,
;PUT DATA-NAME QUALIFIER IN NEXT WORD OF HLDTAB

	INTER.	IA59.
IA59.:	PUSHJ	PP,IA59S.	;SAVE NAMTAB ADDR
	MOVE	TA,CURHLD	;GET # OF QUALIFIERS BEFORE THIS
	LDB	TB,HL.QAL
	AOJ	TB,		;INCREMENT COUNT
	DPB	TB,HL.QAL	;& PUT BACK
	ROT	TB,-1		;DIV BY 2
	HLRZ	TC,CURNAM	;GET NAMTAB LINK
	JUMPL	TB,IA59.A	;IF BIT0 ON, USE ODD HALF-WORD
	ADDI	TA,1(TB)	;PTR TO EVEN HALF-WORD
	HRRM	TC,(TA)		;STORE IN EVEN HALF
	POPJ	PP,
IA59.A:	PUSH	PP,CURHLD	;SAVE PTR TO HLDTAB ENTRY
	MOVE	TA,[XWD CD.HLD,1]	;GET ONE MORE WORD FOR THE ENTRY
	PUSHJ	PP,GETENT
	HLRZ	TC,CURNAM	;GET NAMTAB LINK
	HRLZM	TC,(TA)		;STORE NAMTAB LINK IN ODD HALF
	POP	PP,CURHLD	;RESTORE HLDTAB PTR
	POPJ	PP,

;STORE NAMTAB RELATIVE ADDRESS FOR NEW NAME

IA59S.:	TLNN	W1,GWNOT	;NAME IN NAMTAB?
	JRST	IA59SA		;YES
	PUSHJ	PP,BLDNAM	;NO, BUILD NAMTAB ENTRY
	MOVEM	TA,CURNAM	;SAVE ADDR
	HLRZS	TA		;LEAVE LINK IN RIGHT HALF
	DPB	TA,[POINT 15,W2,15]	;& IN W2
	POPJ	PP,
IA59SA:	LDB	TA,[POINT 15,W2,15]	;GET NAMTAB REL ADDR
	HRLZM	TA,CURNAM	;& SAVE
	POPJ	PP,

;SET FILE-LIMIT FLAG FOR EXISTING DATA NAME

	INTER.	IA60.
IA60.:	PUSHJ	PP,IA59S.	;AIM AT 5TH WORD OF DATAB ENTRY
	TLO	TA,100		;SET 'FILE LIMIT' BIT
	MOVEM	TA,4(TB)
	HLRZ	TC,TB		;SAVE POINTER TO DATAB
	PUSH	SAVPTR,TC
	POPJ	PP,

;ILLEGAL DATA-NAME IN FILE-LIMIT CLAUSE

	INTER.	IA61.
IA61.:	HLRZ	TA,CFLM		;GET CURRENT FILE LIMIT POINTER
	PUSHJ	PP,LNKSET	;GET ABS. ADDR.
	HLRS	(TA)		;MAKE HIGH-LIMIT=LOW-LIMIT
	EWARNJ	BE17.		;'ILLEGAL DATA NAME'
;REFRESH SAVLST
;(SAVLST IS USED FOR TEMPORARY STORAGE)

	INTER.	IA62.
IA62.:	MOVE	SAVPTR,ISVPTR	;RESET SAVE LIST
	POPJ	PP,

;INIT MISSING ENVIRONMENT DIVISION, THEN GO TO COBOLC

	INTER.	IA63E.
IA63E.:	PUSHJ	PP,IA67.	;DO ENV. DIV. INITS
	SKPNAM

;CLEAN-UP AT END OF PHASE B, AND THEN CALL IN COBOLC

	INTER.	IA63.
IA63.:	PUSHJ	PP,CLRNAM	;CLEAN UP NAMTAB
	SWON	FREGWD		;REGET 'DATA' OR WHATEVER
	PUSHJ	PP,IA3.		;INIT MISSING ENVIRONMENT ITEMS
	ENDFAZ	B;		;CLOSE OUT PHASE B & GO TO COBOLC

;FLAG MISSING DATA DIVISION, THEN GO TO COBOLC

	INTER.	IA63F.
IA63F.:	EWARNW	BE31.		;'NO DATA DIVISION'
	JRST	IA63E.
;INITIALIZE ENVIRONMENT DIVISION

	INTER.	IA67.
IA67.:
IFN DEBUG,<
	MOVE	TE,CORESW
	SWOFF	FNDTRC		;CLR OLD TRACE REQUEST
	TRNE	TE,TRACEE	;TRACE ED NODES?
	SWON	FNDTRC		;YES, TURN ON TRACER
	>
	MOVE	TA,[XWD CD.DAT,SZ.DAT]	;MAKE A DUMMY DATAB ENTRY
	PUSHJ	PP,GETENT	;FOR DATA-DIV. BREAK
	HRRZI	TB,CD.DAT
	DPB	TB,[POINT 3,(TA),2]	;ENTER DATTAB CODE
	POPJ	PP,

;SET MULTIPLE REEL FLAG FOR FILE

	INTER.	IA68.
IA68.:	HRRZ	TA,CURFIL	;FILTAB ENTRY ADDR
	LDB	TB,FI.MLT	;GET MULTIPLE REEL BIT
	JUMPN	TB,JBE16.	;IF ON, GIVE 'DUPLICATE CLAUSE' MSG
	SETO	TB,		;OK, SET MULTIPLE REEL BIT
	DPB	TB,FI.MLT
	POPJ	PP,
;RECORDING MODE CLAUSE

;ASCII

	INTER.	IA69.
IA69.:	HRRZI	TB,%RM.7B	;ASCII RECORDING MODE BITS
IA69.X:	HRRZ	TA,CURFIL	;AIM AT FILE ENTRY
	LDB	TC,FI.RM2	;ENTERED ALREADY?
	JUMPN	TC,IA74.E	;YES, ERROR
	DPB	TB,FI.ERM	;NO, ENTER IT
	HRRZI	TB,%RM.DC	;SAY IT IS ENTERED
	DPB	TB,FI.RM2
	POPJ	PP,

;SIXBIT

	INTER.	IA70.
IA70.:	HRRZI	TB,%RM.6B	;SIXBIT RECORDING MODE BITS
	JRST	IA69.X

;BINARY

	INTER.	IA71.
IA71.:	HRRZI	TB,%RM.BN	;BINARY
	JRST	IA69.X

;EBCDIC

	INTERN	IA72.
IA72.:	HRRZI	TB,%RM.EB	;EBCDIC
	JRST	IA69.X
;RECORDING MODE CLAUSE

;DENSITY

	INTER.	IA73.
IA73.:	PUSHJ	PP,IA16S.	;GET THE INTEGER
	POPJ	PP,		;NOT AN INTEGER
	CAIE	TC,^D200	;200 BPI?
	JRST	.+3		;NO
	HRRZI	TC,%RD.2	;YES
	JRST	IA73.1
	CAIE	TC,^D556	;556 BPI?
	JRST	.+3		;NO
	HRRZI	TC,%RD.5	;YES
	JRST	IA73.1
	CAIE	TC,^D800	;800 BPI?
	EWARNJ	BE327.		;NO, INVALID DENSITY
	HRRZI	TC,%RD.8	;YES
IA73.1:	HRRZ	TA,CURFIL	;AIM AT FILE ENTRY
	LDB	TB,FI.RD	;DECLARED ALREADY?
	JUMPN	TB,IA74.E	;YES, ERROR
	DPB	TC,FI.RD	;NO, ENTER IT
	POPJ	PP,

;ODD PARITY

	INTER.	IA74.
IA74.:	HRRZI	TB,%RP.OD	;ODD PARITY BITS
IA74.X:	HRRZ	TA,CURFIL	;AIM AT FILE ENTRY
	LDB	TC,FI.RP	;DECLARED ALREADY?
	JUMPN	TC,IA74.E	;YES, ERROR
	DPB	TB,FI.RP	;NO, ENTER IT
	POPJ	PP,
IA74.E:	EWARNJ	BE16.		;DUPLICATE CLAUSE ERROR MSG

;EVEN PARITY

	INTER.	IA75.
IA75.:	HRRZI	TB,%RP.EV	;EVEN PARITY BITS
	JRST	IA74.X
;SET SAME SORT AREA CLAUSE FLAG

	INTER.	IA76.
IA76.:	SETOM	SAMSRT
	POPJ	PP,

;INIT SAME <RECORD, SORT> AREA CLAUSE

	INTER.	IA77.
IA77.:	SETZM	SAMSRT		;CLEAR SAME SORT AREA FLAG
	JRST	IA62.		;CLR SAVLST
IFN RPW,<

;STASH LITERAL FOR CODE UNTIL MNEMONIC SEEN

	INTER.	IA78.
IA78.:	HLRZ	TC,W1		;PUT SIZE IN THE SPECIAL PLACE
	ANDI	TC,177
	MOVEM	TC,(SAVPTR)
	IDIVI	TC,5		;CONVERT TO WORDS
	JUMPE	TB,.+2
	ADDI	TC,1
	MOVEM	TC,1(SAVPTR)
	MOVE	TA,[LITVAL,,TBLOCK]	;STORE LITERAL
	MOVEI	TB,TBLOCK-1(TC)
	BLT	TA,(TB)
	POPJ	PP,

;GET LITERAL FOR REPORT CODE

	INTER.	IA79.
IA79.:	HRLZI	TA,010000	;"CODE" FLAG
	PUSHJ	PP,IA44.D	;MAKE A CODE MNETAB ENTRY
	HRRZ	TA,1(SAVPTR)	;# WORDS IN LITERAL
	HRLI	TA,CD.MNE	;GET THAT MUCH SPACE IN MNETAB
	PUSHJ	PP,GETENT
	HRLI	TA,TBLOCK	;MOVE LITERAL TO MNETAB
	HRRZI	TB,-1(TA)
	ADD	TB,1(SAVPTR)
	BLT	TA,(TB)
	POPJ	PP,

	>

;DEFERRED OUTPUT ISAM

	INTER.	IA80.
IA80.:
IFN ISAM,<
	HRRZ	TA,CURFIL	;AIM AT FILTAB ENTRY
	MOVEI	TB,1		;SET DEFERRED BIT
	DPB	TB,FI.DFR##
	>
	POPJ	PP,
;COPY VERB SYNTAX PROCESSING

	INTER.	IA96.
IA96.:	SETZM	CURCPY		;RESET CPYTAB POINTERS
	MOVE	TA,CPYLOC
	MOVEM	TA,CPYNXT
	MOVEM	W2,CPYW2	;SAVE POSITION OF 'COPY' IN SOURCE
	PUSHJ	PP,GETITM	;GET LIBRARY-NAME
	TLNN	W1,GWLIT	;LITERAL?
	JRST	IA96.A		;NO, OK
	EWARNW	BE285.		;YES, ILLEGAL LIBRARY-NAME
	JRST	IA0.		;SKIP REST OF PARAGRAPH
IA96.A:	MOVE	TA,NAMWRD	;STORE 1ST 6 CHARS OF NAME
	MOVEM	TA,LIBNAM
	HLRZ	TA,NAMWRD+1	;STORE 7TH & 8TH CHARS
	ANDI	TA,777700
	HRLZM	TA,LIBNAM+1
	PUSHJ	PP,GETITM	;GET NEXT ITEM OF SOURCE
	CAIN	TYPE,PRIOD.	;PERIOD?
	JRST	SETLIB		;ENDED WITH PERIOD --- SET UP COPY & GO TO IT
	CAIN	TYPE,REPLA.	;NO, IS IT 'REPLACING'?
	JRST	IA97.	;YES
	EWARNW	BE286.		;NO, 'COPY STATMT MUST END WITH PERIOD'
	JRST	IA0.		;SKIP REST OF PARAGRAPH

;COPY REPLACING SYNTAX PROCESSING

	INTER.	IA97.
IA97.:	PUSHJ	PP,GETITM	;GET ITEM AFTER 'REPLACING'
IA97.1:	TLNN	W1,GWLIT	;LITERAL?
	TLNE	W1,GWRESV	;RESERVED WORD?
	JRST	IA97E1		;YES, NOT ALLOWED
	PUSHJ	PP,TRYNAM	;LOOKUP NAME
	PUSHJ	PP,BLDNAM	;NOT THERE, ENTER IT
	MOVEM	TA,CURNAM	;SAVE NAMTAB PTR
	PUSHJ	PP,GETITM	;WHAT'S NEXT
	CAIE	TYPE,BY.	;THE WORD 'BY'?
	JRST	IA97E2		;NOT THERE, TOO BAD
	PUSHJ	PP,GETITM	;NEXT ITEM
	TLNE	W1,GWLIT	;LITERAL?
	JRST	IA97.A		;YES
	TLNE	W1,GWRESV	;RESERVED WORD?
	JRST	IA97E3		;YES
	PUSHJ	PP,TRYNAM	;LOOKUP NAME
	PUSHJ	PP,BLDNAM	;NOT THERE, ENTER IT
	TLZ	W1,GWNOT	;IF NAME WASNT THERE ALREADY,
	HLRS	TA		;SNEAK NEW PTR INTO W2
	DPB	TA,[POINT 15,W2,15]
IA97.A:	MOVE	TA,[XWD CD.CPY,SZ.CPY]	;GET CPYTAB ENTRY
	PUSHJ	PP,GETENT
	MOVEM	TA,CURCPY	;SAVE PTR
	HLLZ	TB,CURNAM	;GET NAMTAB LINK TO ITEM TO BE REPLACED
	HRRI	TB,1		;PLUS FLAG IN RT.HF.
	MOVEM	TB,(TA)		;TO CPYTAB ENTRY, WD1
	HLLZM	W1,1(TA)	;LEFT HALVES OF W1 & W2 OF REPLACING ITEM
	HLRM	W2,1(TA)	;TO CPYTAB ENTRY, WD2
	HLRZ	TB,TA		;RELATIVE ADDR OF CPYTAB ENTRY
	HRRZ	TA,CURNAM	;GET NAMTAB PTR
	DPB	TB,[POINT 16,(TA),17]	;STORE CPYTAB LINK IN NAMTAB
	TLNN	W1,GWLIT	;REPLACING WITH A LITERAL?
	JRST	IA97.B		;NO
	LDB	TB,[POINT 9,W1,17]
	HRRZI	TB,4(TB)
	IDIVI	TB,5
	HRRZ	TA,CURCPY
	HRRM	TB,1(TA)
	HRRZI	TA,(TB)		;NO. WORDS IN LITERAL
	HRLI	TA,CD.CPY
	PUSHJ	PP,GETENT
	HRRZI	TB,(TA)
	HRRZ	TA,CURCPY
	HRRZ	TC,1(TA)	;NO. WORDS
	ADDI	TC,-1(TB)
	HRLI	TB,LITVAL
	BLT	TB,(TC)
IA97.B:	PUSHJ	PP,GETITM	;GET NEXT ITEM
	CAIE	TYPE,PRIOD.	;PERIOD?
	JRST	IA97.1		;NO, MUST BE ANOTHER REPLACING CLAUSE
	JRST	SETLIB		;YES, SET UP COPY & AND GET STARTED
IA97E1:	EWARNW	BE314.		;'LITERALS & RESERVD WORDS MAY NOT BE REPLACED'
CLROUT:	PUSHJ	PP,CLRCPY	;CLR CPYTAB AS IF COPY IS ALL FINISHED (IT IS)
	JRST	IA0.		;SKIP TO NEXT PARAGRAPH
IA97E2:	EWARNW	BE124.		;''BY' EXPECTED'
	JRST	CLROUT
IA97E3:	EWARNW	BE315.		;'A WORD MAY NOT BE REPLACED BY A RESERVD WORD'
	JRST	CLROUT
SUBTTL	IDENTIFICATION DIVISION SYNTAX TREE

;THIS TREE IS BUILT FROM THE NODE MACRO DEFINED IN PARAMS.MAC - THE FORM IS
;$ (NAME,ACTION,ITEM-TYPE,PUSHDOWN-FLAG,MARGIN-TYPE,<SON1,SON2,...>)
;THE ACTIONS ARE IA0., IA1., ETC.
;THE ERRORS ARE BE1., BE2., ETC.
;THE TREE IS TRACED BY SQUIRL.MAC
;SQUIRL PROCEEDS AS FOLLOWS:
;	(1) EXECUTE THE ACTION AT THE CURRENT NODE
;	(2) IF THERE IS ONLY 1 SON, MAKE IT THE CURRENT NODE & GO TO 1
;	(3) GET THE NEXT SOURCE ITEM
;	(4) AIM AT FIRST SON
;	(5) IF LAST SON, MAKE IT THE NEXT NODE & GO TO 1
;	(6) OTHERWISE COMPARE SOURCE-ITEM-TYPE WITH SON'S TYPE
;	(7) IF NO MATCH, AIM AT NEXT SON & GO TO 4
;	(8) IF MATCH, MAKE THIS SON THE NEXT NODE & GO TO 1
;IDENTIFICATION DIVISION.
$ ID0.,0,0,0,0,<ID1.,ID1E.,ID2.>		;ENTER SYNTAX TREE
$ ID1.,0,ID.,0,1,<ID4.,ID5.>			;IDENTIFICATION
$ ID1E.,BE341.,ID.,0,0,<ID4.,ID5.>		;IDENT: ?NOT AT A-MARG
$ ID2.,IA0E1.,0,0,0,ID7.			;NO ID..: FLAG & LOOK AT ITM AGAIN
$ ID4.,0,DIVIS.,0,0,<ID6.,ID6A.>		;DIVISION
$ ID5.,BE137.,0,0,0,<ID6.,ID6A.>		;NO DIVISION: FLAG IT BUT GO ON
$ ID6.,0,PRIOD.,0,0,ID7.			;PERIOD AFTER ID-DIV
$ ID6A.,BE125.,0,0,0,ID7.			;NO "." AFTER DIV..: FLAG & GO ON

;OPTIONAL ITEMS IN IDENTIFICATION DIVISION.
;WHEN ENVIRONMENT SEEN, GO TO ED TREE (ED0.)
$ ID7.,0,0,0,0,<ID8.,ID9.,ID10.,ID11.,ID12.,ID13.,ED0.,ID15.,ID16.,ID17.,ID18.,ID19.>
$ ID8.,IA2.,PGMID.,0,1,ID7.			;PROGRAM-ID: GET THE NAME
$ ID9.,IA0A.,AUTHR.,0,1,ID7.			;AUTHOR: PASS COMMENTS TO LISTING
$ ID10.,IA0A.,INSTA.,0,1,ID7.			;INSTALLATION
$ ID11.,IA0A.,DATEW.,0,1,ID7.			;DATE-WRITTEN
$ ID12.,IA0A.,SECUR.,0,1,ID7.			;SECURITY
$ ID13.,IA0A.,REMAR.,0,1,ID7.			;REMARKS
$ ID15.,IA63E.,DATA.,0,1,0			;DATA: NO ENVIRON & GOTO COBOLC
$ ID16.,IA63E.,PROC.,0,1,0			;PROCEDURE: DITTO
$ ID17.,IA63E.,ENDIT.,0,0,0			;END-OF-FILE: DITTO
$ ID18.,IA1.,DATEC.,0,1,<ID27.,ID28.>		;DATE-COMPILED: SUPPRESS LISTING
$ ID19.,IA0E7.,0,0,0,ID7.			;ILL. PAR. NAME: FLAG & SKIP PARA.

;DATE-COMPILED PARAGRAPH
$ ID27.,IA4.,PRIOD.,0,0,ID7.			;".": CLR D-C PARA. & PUT IN TODAY
$ ID28.,BE125.,0,0,0,ID27.			;NO "." AFTER DATE-C..
SUBTTL	ENVIRONMENT DIVISION SYNTAX TREE

;ENVIRONMENT DIVISION.
$ ED0.,IA67.,ENVIR.,0,1,<ED1.,ED2.>		;ENVIRONMENT: SET UP ED
$ ED1.,0,DIVIS.,0,0,<ED3.,ED4.>			;DIVISION
$ ED2.,BE137.,0,0,0,<ED3.,ED4.>			;NO DIV..: FLAG & GO ON
$ ED3.,0,PRIOD.,0,0,ED5.			;"." AFTER ED-DIV
$ ED4.,BE125.,0,0,0,ED5.			;NO "." AFTER DIV: FLAG & GO ON

;SECTION NAMES
$ ED5.,0,0,0,0,<ED256.,ED261.,ED16.,ED19.,ED20.,ED18.>
$ ED16.,IA63.,DATA.,0,1,0			;DATA: CLEAN UP B & GOTO C
$ ED19.,IA63F.,PROC.,0,0,0			;PROCEDURE: FLAG MISSING DATA DIV.
$ ED20.,IA63F.,ENDIT.,0,0,0			;END-OF-FILE: WORSE
$ ED18.,IA0E43,0,0,0,ED5.			;ILL. SECT. NAME: FLAG & SKIP PARA.

;CONFIGURATION SECTION.
$ ED256.,0,CONFG.,0,1,<ED257.,ED258.>		;CONFIGURATION
$ ED257.,0,SECT.,0,0,<ED259.,ED260.>		;SECTION
$ ED258.,BE140.,0,0,0,<ED259.,ED260.>		;NO SECTION: FLAG & GO ON
$ ED259.,0,PRIOD.,0,0,ED269.			;"."
$ ED260.,BE125.,0,0,0,ED269.			;NO ".": FLAG & GO ON

;OPTIONS IN CONFIGURATION SECTION
$ ED269.,0,0,0,0,<ED6.,ED10.,ED15.,ED256.,ED261.,ED16.,ED19.,ED20.,ED269A>
$ ED269A,IA0E7.,0,0,0,ED269.			;ILL PAR NAME: FLAG & SKIP PARA

;INPUT-OUTPUT SECTION.
$ ED261.,0,IO.,0,1,<ED262.,ED263.>		;INPUT-OUTPUT
$ ED262.,0,SECT.,0,0,<ED264.,ED265.>		;SECTION
$ ED263.,BE140.,0,0,0,<ED264.,ED265.>		;NO SECTION: FLAG & GO ON
$ ED264.,0,PRIOD.,0,0,ED270.			;"."
$ ED265.,BE125.,0,0,0,ED270.			;NO ".": FLAG & GO ON

;OPTIONS IN INPUT-OUTPUT SECTION
$ ED270.,0,0,0,0,<ED11.,ED14.,ED256.,ED261.,ED16.,ED19.,ED20.,ED270A>
$ ED270A,IA0E7.,0,0,0,ED270.			;ILL PAR NAME: FLAG & SKIP PARA
;SOURCE-COMPUTER.
$ ED6.,IA1.,SOURC.,0,1,<ED8.,ED7.>		;SRC-COMP: SUPPRESS LISTING
$ ED7.,BE125.,0,0,0,ED8.			;NO ".": FLAG & GO ON
$ ED8.,IA5.,PRIOD.,0,0,ED269.			;".": SUBSTITUTE PDP-10 FOR PARA.

;OBJECT-COMPUTER.
$ ED10.,0,OBJEC.,0,1,<ED23.,ED22.>		;OBJECT-COMPUTER
$ ED23.,0,PRIOD.,0,0,ED24.			;"."
$ ED22.,BE125.,0,0,0,ED24.			;NO ".": FLAG & GO ON

;OBJECT COMPUTER NAME
$ ED24.,0,0,0,0,<ED25.,ED27.,ED28.>
$ ED25.,0,PDP10.,0,0,<ED29.,ED31A.>		;PDP-10, DECSYSTEM-10
$ ED27.,IA96.,COPY.,0,0,ED24.			;COPY: GO GET OUTSIDE DATA
$ ED28.,IA0E5.,0,0,0,<ED29.,ED31A.>		;NO PDP: WARN & GO ON
$ ED29.,0,PRIOD.,0,0,ED31.			;"."

;OPTIONS IN OBJECT-COMPUTER PARAGRAPH
$ ED31.,0,0,0,0,<ED32.,ED127.,ED269.>
$ ED31A.,0,0,0,0,<ED32.,ED127.,ED31B.>
$ ED31B.,BE125.,0,0,0,ED269.

;MEMORY SIZE IS N <ITEM-TYPE>
$ ED32.,IA62.,MEMOR.,0,0,<ED33.,ED34.,ED35.,ED36.>  ;MEMORY: RESET SAVE LIST
$ ED33.,0,SIZE.,0,0,<ED34.,ED35.,ED36.>		;SIZE
$ ED34.,0,IS.,0,0,<ED35.,ED36.>			;IS
$ ED35.,IA16.,INTGR.,0,0,ED38.			;INTEGER: SAVE VALUE
$ ED36.,IA54E.,0,0,0,ED38.			;NO INTEGER: ASSUME 0

;CHARACTERS, WORDS, OR MODULES
$ ED38.,0,0,0,0,<ED39.,ED40.,ED41.,ED42.>
$ ED39.,IA8.,WORDS.,0,0,<ED29.,ED31.>		;WORDS: OBJSIZ=INTEGER OFF SAVLST
$ ED40.,IA9.,MODUL.,0,0,<ED29.,ED31.>		;MODULES: OBJSIZ=N*1K
$ ED41.,IA10.,CHARA.,0,0,<ED29.,ED31.>		;CHARACTERS: OBJSIZ=N/6
$ ED42.,IA10.,0,0,0,<ED29.,ED31.>		;ASSUME CHARACTERS

;SEGMENT-LIMIT IS N
$ ED127.,0,SEGME.,0,0,<ED145.,ED146.,ED147.>  	;SEG-LIM
$ ED145.,0,IS.,0,0,<ED146.,ED147.>		;IS
$ ED146.,IA35.,INTGR.,0,0,<ED29.,ED31.>		;INTEGER: VALUE TO SEGLIM
$ ED147.,BE25.,0,0,0,<ED29.,ED31.>		;POSITIVE INTEGER REQUIRED
;SPECIAL-NAMES.
$ ED15.,IA56.,SPECI.,0,1,<ED182.,ED183.>	;SPCL-NAMS: SET PARA SEEN FLAG
$ ED182.,0,PRIOD.,0,0,<ED183A,ED184.>		;"."
$ ED183.,BE125.,0,0,0,<ED183A,ED184.>		;NO "."
$ ED183A,IA96.,COPY.,0,0,ED184.			;COPY: GET OUTSIDE DATA

;OPTIONS IN SPECIAL NAMES PARAGRAPH
$ ED184.,0,0,0,0,<ED304.,ED185.,ED186.,ED187.,ED188.,ED189.,ED183A,ED191.>

;CONSOLE IS <MNEMONIC-NAME>
$ ED185.,0,CONSL.,0,0,<ED193.,ED196.,ED194.,ED195.>  ;CONSOLE
$ ED193.,0,IS.,0,0,<ED196.,ED194.,ED195.>	;IS
$ ED196.,IA44.,USERN.,0,0,<ED182.,ED184.>	;ACCEPTABLE MNEMONIC: GET IT
$ ED194.,BE28.,MNEMO.,0,0,ED197.		;MNEMONIC-NAME ALREADY IN USE
$ ED195.,BE24.,0,0,0,ED197.			;ILLEGAL MNEMONIC-NAME

;CHANNEL (N) IS <MNEMONIC-NAME>
$ ED186.,IA62.,CHANN.,0,0,<ED199.,ED186A>	;CHANNEL: CLR SAVLST
$ ED199.,0,LPREN.,0,0,<ED201.,ED200.>		;"("
$ ED186A,BE287.,0,0,0,<ED201.,ED200.>		;LEFT PARENTHESIS EXPECTED
$ ED201.,IA16.,INTGR.,0,0,<ED202.,ED203.>	;INTEGER: SAVE VALUE
$ ED200.,BE25.,0,0,0,ED197.			;POSITIVE INTEGER REQUIRED
$ ED202.,0,RPREN.,0,0,<ED204.,ED205.,ED208.,ED206.>  ;")"
$ ED203.,BE84.,0,0,0,<ED204.,ED205.,ED208.,ED206.>  ;RIGHT PARIN EXPECTED
$ ED204.,0,IS.,0,0,<ED205.,ED208.,ED206.>	;IS
$ ED208.,IA46.,USERN.,0,0,<ED182.,ED184.>	;ACCEPTABLE MNEMONIC: GET IT
$ ED205.,BE28.,MNEMO.,0,0,ED207.		;MNEMONIC-NAME ALREADY IN USE
$ ED206.,BE24.,0,0,0,ED207.			;ILLEGAL MNEMONIC-NAME
$ ED207.,IA57.,0,0,0,ED197.			;CLEAN UP SAVLST

;CURRENCY SIGN IS <LITERAL>
$ ED188.,0,CURR.,0,0,<ED212.,ED213.,ED214.,ED215.>  ;CURRENCY
$ ED212.,0,SIGN.,0,0,<ED213.,ED214.,ED215.>  	;SIGN
$ ED213.,0,IS.,0,0,<ED214.,ED215.>		;IS
$ ED214.,IA51.,LITER.,0,0,<ED182.,ED184.>	;LITERAL: GET THE CHARACTER
$ ED215.,BE27.,0,0,0,ED197.			;MUST BE A 1 CHAR LITERAL

;DECIMAL-POINT IS COMMA
$ ED189.,0,DECPN.,0,0,<ED209.,ED210.,ED211.>  	;DECIMAL-POINT
$ ED209.,0,IS.,0,0,<ED210.,ED211.>		;IS
$ ED210.,IA52.,COMMA,0,0,<ED182.,ED184.>	;COMMA: SWITCH "," & "."
$ ED211.,BE18.,0,0,0,ED197.			;IMPROPER CLAUSE
;REPORT CODES: "<LITERAL> IS <MNEMONIC-NAME>"
IFN RPW,<
$ ED304.,IA78.,LITER.,0,0,<ED305.,ED305.>
$ ED305.,0,IS.,0,0,<ED306.,ED194.,ED195.>
$ ED306.,IA79.,USERN.,0,0,<ED182.,ED184.>
>
IFE RPW,<
$ ED304.,BE18.,LITER.,0,0,ED191.
>

;SWITCH (N)
$ ED187.,IA62.,SWTCH.,0,0,<ED216.,ED187A>	;SWITCH
$ ED216.,0,LPREN.,0,0,<ED218.,ED217.>		;"("
$ ED187A,BE287.,0,0,0,<ED218.,ED217.>		;LEFT PARENTHESIS REQUIRED
$ ED218.,IA16.,INTGR.,0,0,<ED219.,ED220.>	;INTEGER: SAVE VALUE
$ ED217.,BE25.,0,0,0,ED197.			;POSITIVE INTEGER REQUIRED
$ ED219.,0,RPREN.,0,0,ED221.			;")"
$ ED220.,BE84.,0,0,0,ED221.			;RIGHT PARIN. REQUIRED

;OPTIONS AFTER SWITCH (N)
$ ED221.,0,0,0,0,<ED222.,ED223.,ED224.,ED232.,ED233.,ED234.>

;SWITCH (N) IS <MNEMONIC-NAME>
$ ED224.,0,IS.,0,0,<ED232.,ED233.,ED234.>	;IS
$ ED232.,IA47.,USERN.,0,0,<ED222.,ED223.,ED182.,ED184.>  ;OK MNEMONIC: GET IT
$ ED233.,BE28.,MNEMO.,0,0,<ED222.,ED223.,ED182.,ED184.>  ;MNEMONC ALREADY USED
$ ED234.,BE24.,0,0,0,<ED222.,ED223.,ED182.,ED184.>  ;ILLEGAL MNEMONIC

;ON/OFF STATUS IS <MNEMONIC-NAME>
$ ED222.,IA48.,ON.,0,0,<ED225.,ED226.,ED227.,ED229.,ED228.>  ;ON: SET FLAG
$ ED223.,IA49.,OFF.,0,0,<ED225.,ED226.,ED227.,ED229.,ED228.>  ;OFF: SET FLAG
$ ED225.,0,STATU.,0,0,<ED226.,ED227.,ED229.,ED228.>  ;STATUS
$ ED226.,0,IS.,0,0,<ED227.,ED229.,ED228.>	;IS
$ ED227.,IA50.,USERN.,0,0,<ED222.,ED223.,ED182.,ED184.>  ;OK MNEMONIC: GET IT
$ ED229.,BE85.,CONDI.,0,0,ED197.		;CONDITION-NAME ALREADY IN USE
$ ED228.,BE26.,0,0,0,ED197.			;ILLEGAL CONDITION-NAME

;SPECIAL-NAMES PARAGRAPH ERROR RECOVERY
$ ED191.,0,0,0,0,<ED6.,ED10.,ED15.,ED256.,ED16.,ED19.,ED20.,ED261.,ED192.>
$ ED192.,BE18.,0,0,0,ED197.			;IMPROPER CLAUSE
$ ED197.,0,0,0,0,<ED185.,ED186.,ED187.,ED188.,ED189.,ED183A,ED198.>
$ ED198.,0,0,0,0,<ED6.,ED10.,ED15.,ED256.,ED16.,ED19.,ED20.,ED261.,ED272.>
$ ED272.,IA0.G,0,0,0,ED197.			;ADVANCE TO NEXT WORD
;FILE-CONTROL.
$ ED11.,0,FILEC.,0,1,<ED12.,ED13.>		;FILE-CONTROL
$ ED12.,0,PRIOD.,0,0,<ED45.,ED46.,ED47.>	;"."
$ ED13.,BE125.,0,0,0,ED12.			;NO "."
$ ED46.,IA96.,COPY.,0,0,ED12.			;COPY: GET OUTSIDE DATA
$ ED47.,0,0,0,0,<ED11.,ED14.,ED256.,ED16.,ED19.,ED20.,ED261.,ED48.>
$ ED48.,BE18.,0,0,0,ED49.			;IMPROPER CLAUSE
$ ED49.,IA0.G,0,0,0,ED12.			;ADVANCE TO NEXT WORD

;SELECT [OPTIONAL] <FILE-NAME> ASSIGN TO <DEVICE-NAME>
$ ED45.,IA12.,SELEC.,0,0,<ED51.,ED53.,ED54.,ED52.>  ;SELECT: CLR OPTNL FLG
$ ED51.,IA13.,OPTIO.,0,0,<ED53.,ED54.,ED52.>  	;OPTIONAL: SET FLAG
$ ED54.,IA14.,USERN.,0,0,<ED55.,ED56.>		;OK FILE-NAME: GET IT
$ ED53.,BE9.,FILEN.,0,0,ED47.			;FILE-NAME ALREADY IN USE
$ ED52.,BE21.,0,0,0,ED47.			;ILLEGAL FILE-NAME
$ ED55.,0,ASSGN.,0,0,<ED57.,ED58.,ED60.>	;ASSIGN
$ ED56.,BE10.,0,0,0,ED47.			;ASSIGN CLAUSE REQUIRED
$ ED57.,0,TO.,0,0,<ED58.,ED60.>			;TO
$ ED58.,IA18.,USERN.,0,0,<ED58.,ED12.,ED271.>   ;DEVICE-NAME: GET IT
$ ED60.,BE83.,0,0,0,<ED58.,ED12.,ED271.>	;IMPROPER DEVICE-NAME

;OPTIONS AFTER SELECT-ASSIGN CLAUSE
$ ED271.,0,0,0,0,<ED12.,ED61.,ED62.,ED66.,ED67.,ED68.,ED68A.,ED70.,ED71.,ED72.,ED73.,ED289.,ED271E>
$ ED271E,BE18.,0,0,0,ED271F
$ ED271F,0,0,0,0,<ED45.,ED46.,ED11.,ED14.,ED256.,ED16.,ED19.,ED20.,ED261.,ED271G>
$ ED271G,IA0.G,0,0,0,ED271H			;ADVANCE TO NEXT WORD
$ ED271H,0,0,0,0,<ED12.,ED61.,ED62.,ED66.,ED67.,ED68.,ED68A.,ED70.,ED71.,ED72.,ED73.,ED289.,ED271F>

;ACCESS MODE IS <MODE>
$ ED66.,IA21.,ACCES.,0,0,<ED92.,ED93.,ED94.,ED96.,ED96X.,ED97.>  ;ACCESS: SEEN BEF?
$ ED92.,0,MODE.,0,0,<ED93.,ED94.,ED96.,ED96X.,ED97.>  ;MODE
$ ED93.,0,IS.,0,0,<ED94.,ED96.,ED96X.,ED97.>	;IS
$ ED94.,IA25.,SEQU.,0,0,ED271.			;SEQUENTIAL: SET FLAG
$ ED96.,IA27.,RAND.,0,0,ED271.			;RANDOM: SET FLAG
$ ED96X.,IA26.,INDXD.,0,0,<ED95.,ED271.>	;INDEXED: SET FLAG
$ ED95.,IA80.,DEFER.,0,0,<ED95A.,ED271.>	;DEFERRED
$ ED95A.,0,OUTPU.,0,0,ED271.			;OUTPUT
$ ED97.,BE15.,0,0,0,ED271.			;ILLEGAL ACCESS MODE

;PROCESSING MODE IS SEQUENTIAL
$ ED70.,0,PRCSS.,0,0,<ED88.,ED89.,ED90.,ED91.>  ;PROCESSING
$ ED88.,0,MODE.,0,0,<ED89.,ED90.,ED91.>		;MODE
$ ED89.,0,IS.,0,0,<ED90.,ED91.>			;IS
$ ED90.,0,SEQU.,0,0,ED271.			;SEQUENTIAL
$ ED91.,BE14.,0,0,0,ED271.			;PROCESSING MODE MUST BE SEQUENTIAL

;FOR MULTIPLE REEL/UNIT
$ ED72.,0,FOR.,0,0,<ED73.,ED76.>		;FOR
$ ED73.,0,MULTP.,0,0,<ED79.,ED76.>		;MULTIPLE
$ ED79.,IA68.,REEL.,0,0,ED271.			;REEL: SET MULTIREEL FLAG
$ ED76.,BE18.,0,0,0,ED271.			;IMPROPER CLAUSE
;SYMBOLIC KEY IS <DATA-NAME>
$ ED61.,IA22.,SYMBL.,0,0,<ED98.,ED99.,ED101.,ED102.>  ;SYMBOLIC: STORE HLDTAB CODE

;RECORD KEY IS <DATA-NAME>
$ ED62.,IA22R.,REC.,0,0,<ED98.,ED99.,ED101.,ED102.>  ;RECORD: STORE REC KEY CODE

;ACTUAL KEY IS <DATA-NAME>
$ ED67.,IA24.,ACTUA.,0,0,<ED98.,ED99.,ED101.,ED102.>  ;ACTUAL: STORE ACT KEY CODE
$ ED98.,0,KEY,0,0,<ED99.,ED101.,ED102.>  	;KEY
$ ED99.,0,IS.,0,0,<ED101.,ED102.>		;IS
$ ED101.,IA28.,USERN.,0,0,<ED100.,ED271.>	;DATA-NAME: SAVE ACT. KEY
$ ED100.,0,OF.,0,0,<ED100A,ED102.>		;OF
$ ED100A,IA59.,USERN.,0,0,<ED100.,ED271.>	;DATA-NAME: SAVE QUALIFIER
$ ED102.,BE17.,0,0,0,ED271.			;ILLEGAL DATA NAME

;RESERVE <INTEGER> ALTERNATE AREAS
$ ED71.,0,RESER.,0,0,<ED82.,ED83.,ED85.>	;RESERVE
$ ED82.,IA19.,INTGR.,0,0,<ED86.,ED87.,ED271.>   ;INTEGER: GET # ALT. BUFRS
$ ED83.,IA20.,NO.,0,0,<ED86.,ED87.,ED271.>	;NO: ZERO ALT BUFRS
$ ED85.,IA20E.,0,0,0,<ED86.,ED87.,ED271.>	;IMPROPER CLAUSE: 0 ALT. BUFRS
$ ED86.,0,ALTRN.,0,0,<ED87.,ED271.>		;ALTERNATE
$ ED87.,0,AREA.,0,0,ED271.			;AREAS

;RECORDING <MODE, DENSITY, PARITY>
$ ED289.,0,RECRDG,0,0,<ED290.,ED291.,ED293.,ED294.,ED295.,ED296.,ED297.,ED298.,ED299.,ED300.,ED301.,ED271.>
$ ED290.,0,MODE.,0,0,<ED291.,ED289.>		;MODE
$ ED291.,0,IS.,0,0,ED289.			;IS
$ ED293.,IA69.,ASCII.,0,0,ED289.		;ASCII: SET MODE
$ ED294.,IA70.,SIXBT.,0,0,ED289.		;SIXBIT: SET MODE
$ ED295.,IA71.,BINRY.,0,0,ED289.		;BINARY: SET MODE
$ ED296.,IA72.,EBCDC.,0,0,ED289.		;EBCDIC: SET MODE

;DENSITY IS <INTEGER>
$ ED297.,0,DENSIT,0,0,<ED297A,ED298.,ED303.>  	;DENSITY
$ ED297A,0,IS.,0,0,<ED298.,ED303.>		;IS
$ ED298.,IA73.,INTGR.,0,0,ED289.		;INTEGER: GET DENSITY
$ ED303.,BE25.,0,0,0,ED289.			;POSITIVE INTEGER REQUIRED

;PARITY IS ODD/EVEN
$ ED299.,0,PARIT.,0,0,<ED299A,ED300.,ED301.,ED302.>  ;PARITY
$ ED299A,0,IS.,0,0,<ED300.,ED301.,ED302.>	;IS
$ ED300.,IA74.,ODD.,0,0,ED289.			;ODD: SET PARITY FLAG
$ ED301.,IA75.,EVEN.,0,0,ED289.			;EVEN: SET PARITY FLAG
$ ED302.,BE328.,0,0,0,ED289.			;ODD OR EVEN REQUIRED
;FILE-LIMIT IS <ITEM>
$ ED68.,IA23.,FILEL.,0,0,<ED103.,ED104.,ED105.,ED106.,ED102.>  ;INIT F-L CLAUSE
$ ED68A.,0,FILE.,0,0,<ED68B.,ED271E>		;FILE<SPACE>LIMIT OK TOO
$ ED68B.,0,LIM.,0,0,ED68.
$ ED103.,0,IS.,0,0,<ED104.,ED105.,ED106.,ED102.>;IS

;FIRST LIMIT (COULD BE HIGH OR LOW)
$ ED105.,IA30.,USERN.,0,0,<ED109.,ED104.,ED110.>;DATA-NAME: SAVE HLDTAB PTR
$ ED104.,0,OF.,0,0,<ED104A,ED102.>		;OF
$ ED104A,IA59.,USERN.,0,0,<ED104.,ED109.,ED110.>;DATA-NAME: QUAL TO HLDTAB
$ ED106.,IA29.,INTGR.,0,0,<ED109.,ED110.>	;INTEGER: SAVE VALTAB PTR
$ ED110.,IA32.,0,0,0,ED111.			;SINGLE-ITEM LIMIT: LO-LIM=1

;... THRU <ITEM>
$ ED109.,IA31.,THRU.,0,0,<ED116.,ED117.,ED118.,ED120.>  ;THRU: SAVE LO-LIM

;HIGH LIMIT
$ ED117.,IA30.,USERN.,0,0,<ED116.,ED111.>;DATA-NAME: SAVE HLDTAB PTR
$ ED116.,0,OF.,0,0,<ED116A,ED120.>		;OF
$ ED116A,IA59.,USERN.,0,0,<ED116.,ED111.>;DATA-NAME: QUALIFYR TO HLDTAB
$ ED118.,IA29.,INTGR.,0,0,ED111.		;INTEGER: SAVE VALTAB PTR
$ ED120.,IA61.,0,0,0,<ED113.,ED114.,ED111.>  	;ILL DAT-NAM: HI-LIM=LO
$ ED111.,IA34.,0,0,0,<ED113.,ED114.,ED271.>  	;STORE HI-LIM

;ADDITIONAL LOW LIMITS
$ ED113.,IA30.,USERN.,0,0,<ED112.,ED109.,ED115.>;DATA-NAME: SAVE HLDTAB PTR
$ ED112.,0,OF.,0,0,<ED112A,ED102.>		;OF
$ ED112A,IA59.,USERN.,0,0,<ED112.,ED109.,ED115.>;DATA-NAME: QUAL TO HLDTAB
$ ED114.,IA29.,INTGR.,0,0,<ED109.,ED115.>	;INTEGER: SAVE VALTAB PTR
$ ED115.,IA30E,0,0,0,ED271.			;THRU EXPECTED
;I-O-CONTROL.
$ ED14.,0,IOCON.,0,1,<ED122.,ED123.>		;I-O-CONTROL
$ ED122.,0,PRIOD.,0,0,ED124.			;"."
$ ED123.,BE125.,0,0,0,ED124.			;NO ".": PERIOD ASSUMED

;OPTIONS IN I-O-CONTROL PARAGRAPH
$ ED124.,0,0,0,0,<ED125.,ED126.,ED128.,ED130.,ED129.>
$ ED130.,IA96.,COPY.,0,0,ED124.			;COPY: GET OUTSIDE DATA

;I-O-CONTROL PARAGRAPH ERROR RECOVERY
$ ED129.,0,0,0,0,<ED11.,ED14.,ED256.,ED16.,ED19.,ED20.,ED261.,ED131.>
$ ED131.,BE18.,0,0,0,ED139.
$ ED139.,0,0,0,0,<ED125.,ED126.,ED128.,ED130.,ED140.>
$ ED140.,0,0,0,0,<ED11.,ED14.,ED256.,ED16.,ED19.,ED20.,ED261.,ED255.>
$ ED255.,IA0.A,0,0,0,ED139.
$ ED288.,0,0,0,0,<ED122.,ED124.>

;SAME <RECORD/SORT> AREA FOR <FILE-NAME>
$ ED125.,IA77.,SAME.,0,0,<ED132.,ED132A,ED133.>	;SAME: INIT SAVLST
$ ED132.,IA36.,REC.,0,0,<ED134.,ED135.,ED136.,ED137.,ED138.>  ;REC: SET FLAG
$ ED132A,IA76.,SORT.,0,0,<ED134.,ED135.,ED136.,ED137.,ED138.>  ;SORT: IGNORE CLAUSE
$ ED133.,IA37.,0,0,0,<ED134.,ED135.,ED136.,ED137.,ED138.>  ;NO REC: CLR FLAG
$ ED134.,0,AREA.,0,0,<ED135.,ED136.,ED137.,ED138.>  ;AREA
$ ED135.,0,FOR.,0,0,<ED136.,ED137.,ED138.>	;FOR
$ ED136.,BE20.,USERN.,0,0,<ED136.,ED137.,ED138.>;FILE NOT SELECTED
$ ED137.,IA38.,FILEN.,0,0,<ED141.,ED142.,ED138.>;FILE: SAVE FILTAB PTR
$ ED138.,BE21.,0,0,0,ED139.			;ILLEGAL FILENAME
$ ED141.,BE20.,USERN.,0,0,<ED141.,ED142.,ED144.>;FILE NOT SELECTED
$ ED142.,IA38A.,FILEN.,0,0,<ED141.,ED142.,ED144.>  ;FILE: LNK PREV FIL TO THIS
$ ED144.,IA39.,0,0,0,<ED122.,ED124.>		;LINK LAST FILE TO FIRST
;MULTIPLE FILE TAPE CONTAINS <FILENAME>
$ ED126.,IA62.,MULTP.,0,0,<ED148.,ED149.,ED150.,ED151.,ED152.,ED153.>  ;INIT SVL
$ ED148.,0,FILE.,0,0,<ED149.,ED150.,ED151.,ED152.,ED153.>  ;FILE
$ ED149.,0,TAPE.,0,0,<ED150.,ED151.,ED152.,ED153.>  ;TAPE
$ ED150.,0,CONTA.,0,0,<ED151.,ED152.,ED153.>  	;CONTAINS
$ ED151.,IA40.,FILEN.,0,0,<ED157.,ED158.>	;FILE: SAVE FILTAB PTR
$ ED152.,BE20.,USERN.,0,0,<ED152.,ED154.,ED139.>;FILE NOT SELECTED
$ ED153.,BE21.,0,0,0,<ED152.,ED154.,ED139.>	;ILLEGAL FILENAME
$ ED154.,0,PSTN.,0,0,<ED155.,ED156.>		;POSITION
$ ED155.,0,INTGR.,0,0,<ED151.,ED152.,ED288.>  	;INTEGER
$ ED156.,BE18.,0,0,0,<ED151.,ED152.,ED288.>  	;IMPROPER CLAUSE

;... POSITION <INTEGER>
$ ED157.,0,PSTN.,0,0,<ED159.,ED160.>		;POSITION
$ ED159.,IA41.,INTGR.,0,0,<ED161.,ED163.,ED288.>  ;INTEGER: STORE POSITION
$ ED160.,BE18.,0,0,0,<ED161.,ED163.,ED139.>  	;IMPROPER CLAUSE

;ADDITIONAL FILENAMES
$ ED158.,IA42.,0,0,0,<ED161.,ED163.,ED288.>  	;NO POS: STOW VALUE ON SAVLST
$ ED161.,IA43.,FILEN.,0,0,<ED157.,ED158.>	;FILE: LINK TO PREV. FILE
$ ED163.,BE20.,USERN.,0,0,<ED163.,ED161.,ED164.,ED288.>  ;FILE NOT SELECTED
$ ED164.,0,PSTN.,0,0,<ED165.,ED166.>		;POSITION
$ ED165.,0,INTGR.,0,0,<ED161.,ED163.,ED288.>  	;INTEGER
$ ED166.,BE18.,0,0,0,<ED161.,ED163.,ED288.>  	;IMPROPER CLAUSE

;RERUN EVERY
$ ED128.,IA62.,RERUN.,0,0,<ED167.,ED168.,ED169.,ED173.,ED174.,ED131.>  ;INIT SVL
$ ED167.,0,EVERY.,0,0,<ED168.,ED169.,ED173.,ED174.,ED131.>  ;EVERY

;<INTEGER> RECORDS
$ ED168.,IA16.,INTGR.,0,0,<ED170.,ED171.>	;INTEGER: SAVE VALUE
$ ED170.,0,REC.,0,0,<ED176.,ED177.,ED178.,ED179.>  ;RECORDS
$ ED171.,BE18.,0,0,0,ED172.			;IMPROPER CLAUSE
$ ED172.,IA57.,0,0,0,ED139.			;REMOVE LAST ITEM FROM SAVLST

;END OF REEL/UNIT
$ ED169.,0,END.,0,0,<ED173.,ED174.,ED131.>	;END
$ ED173.,0,OF.,0,0,<ED174.,ED131.>		;OF
$ ED174.,IA54.,REEL.,0,0,<ED176.,ED177.,ED178.,ED179.>  ;REEL: SAVE 0

;OF <FILENAME>
$ ED176.,0,OF.,0,0,<ED177.,ED178.,ED179.>	;OF
$ ED177.,IA57.,USERN.,0,0,ED288.		;FUNNY NAME: CLEAN OFF SAVLST
$ ED178.,IA55.,FILEN.,0,0,ED288.		;FILE: SET RERUN COUNT
$ ED179.,BE21.,0,0,0,ED172.			;ILLEGAL FILENAME
	SUBTTL	ERRORS FOR PHASE B

	RADIX	10

	WERRS	B,0,110

;	INTER.	BE111.
;BE111.:	TLNE	W1,GWRESV
;	EWARNW	BE103.
;	EWARNW	BE104.

	WERRS	B,112,124

	EXTERN	BLNKLN,BLNKCP
	INTER.	BE125.
BE125.:	MOVE	LN,BLNKLN
	MOVE	CP,BLNKCP
	HRRZI	DW,125		;DIAGNOSTIC 125
	SWON	FREGWD		;READ THAT AGAIN LATER
	JRST	WARN##		;WARNING ONLY


	WERRS	B,126,400

	END
 !I v