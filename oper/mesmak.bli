MODULE MESMAK(STACK)=
BEGIN

%
THIS PROGRAM CREATES THE BLISS ERROR MESSAGE FILE.  THE PROGRAM TAKES
ITS INPUT FROM THE FILE BLISS.MSG, WHICH IS OF THE FORMAT

@NNN
MESSAGE
@NNN
MESSAGE
...

WHERE EACH NNN IS AN OCTAL ERROR MESSAGE NUMBER, AND THE TEXT FOLLOWING
NNN (MESSAGE) IS THE ACTUAL ERROR MESSAGE.  THIS TEXT MAY CONTAIN ANY
CHARACTER EXCEPT @ AND MAY BE ANY LENGTH.  THE OUTPUT OF THE PROGRAM IS
THE FILE BLISS.ERR, WHICH CONTAINS THE ERROR MESSAGE TEXTS FROM
BLISS.MSG AND A DIRECTORY FOR FAST ACCESS.  THE DIRECTORY OCCUPIES
BLOCKS 1 AND 2 OF THE FILE, AND LOOKS LIKE THIS:

WORD 0: PTR0,,PTR1
WORD 1: PTR2,,PTR3
. . .
WORD 377: PTR776,PTR777

WHERE EACH PTRNNN IS A MESSAGE POINTER INTO THE FILE FOR MESSAGE NNN AND
HAS THE FORMAT BYTE(8)BLOCK#(10)CHAR# WHERE BLOCK# IS THE BLOCK
NUMBER FOR A USETI AND CHAR# IS THE CHARACTER NUMBER WITHIN THAT BLOCK
AT WHICH THE MESSAGE BEGINS (THE BLOCK BEGINS WITH CHARACTER 0).  EACH
MESSAGE ENDS WITH A CHARACTER CONTAINING 0.
%

MACHOP TTCALL=#51, CALLI=#47, IN=#56, OUT=#57, STATZ=#63, SETSTS=#60,
  RELEAS=#71, OPEN=#50, LOOKUP=#76, ENTER=#77, OUTPUT=#67, USETO=#75;

BIND CR=#15, LF=#12, DIRSZ=#1000, TXTBLK=DIRSZ/#400+1;
BIND PTR=1, CNT=2, INCH=1, OUTCH=2;

OWN IBUF[3], OBUF[3], LINE, MESN, CHAR, MESPTR;

STRUCTURE HWT[I]=[I/2](.HWT+.I/2)<IF NOT .I THEN 18,18>;
OWN HWT DIR[DIRSZ];

MACRO CHARN=MESPTR<0,10>$, BLOCKN=MESPTR<10,8>$;

MACRO ERR(MSG)=ERROR(PLIT ASCIZ MSG)$;

MACRO SKIP(OP)=(REGISTER T; T_1; OP; T_0; .T)$;

LABEL LOOP;

FORWARD PNUM(1), READ(0);

ROUTINE ERROR(MSG)=
  BEGIN
    TTCALL(3,MSG,,1);
    TTCALL(3,PLIT ASCIZ ' IN LINE ');
    PNUM(.LINE);
    CALLI(1,#12); CALLI(0,#12)
  END;

ROUTINE PNUM(NUM)=
  BEGIN REGISTER REM;
    REM_.NUM MOD 10; NUM_.NUM/10;
    IF .NUM GTR 0 THEN PNUM(.NUM);
    REM_.REM+"0"; TTCALL(1,REM)
  END;

ROUTINE RDOCT=
  BEGIN REGISTER OCT,CHAR;
    OCT_0;
    WHILE (IF (CHAR_READ()) LSS 0 THEN RETURN -1; .CHAR NEQ LF) DO
      IF .CHAR NEQ "@" AND .CHAR NEQ CR THEN
        IF .CHAR LSS "0" OR .CHAR GTR "7" THEN ERR('BAD OCTAL NUMBER')
          ELSE OCT_.OCT^3+.CHAR-"0";
    .OCT
  END;

ROUTINE READ=
  BEGIN REGISTER CHAR;
    IF (IBUF[CNT]_.IBUF[CNT]-1) LEQ 0 THEN
      IF SKIP(IN(INCH)) THEN
        IF SKIP(STATZ(INCH,#740000)) THEN RETURN -1
          ELSE ERR('INPUT ERROR');
    CHAR_SCANI(IBUF[PTR]);
    IF .CHAR EQL LF THEN LINE_.LINE+1;
    .CHAR
  END;

ROUTINE WRITE(CHAR)=
  BEGIN
    REPLACEI(OBUF[PTR],.CHAR); CHARN_.CHARN+1;
    IF (OBUF[CNT]_.OBUF[CNT]-1) LEQ 0 THEN
      BEGIN
        IF SKIP(OUT(OUTCH)) THEN ERR('OUTPUT ERROR');
        CHARN_0; BLOCKN_.BLOCKN+1
      END
  END;

!FINALLY WE BEGIN

CALLI(0);

LINE_CHARN_0; BLOCKN_TXTBLK;

BEGIN REGISTER BLK[3];
  BLK[0]_0; BLK[1]_SIXBIT'DSK';
  BLK[2]<18,18>_OBUF<0,0>; BLK[2]<0,18>_IBUF<0,0>;
  IF NOT SKIP(OPEN(INCH,BLK)) OR NOT SKIP(OPEN(OUTCH,BLK)) THEN
    ERR('INIT FAILURE')
END;

BEGIN REGISTER LOOK[4];
  LOOK[0]_SIXBIT'BLISS'; LOOK[1]_SIXBIT'MSG'; LOOK[2]_LOOK[3]_0;
  IF NOT SKIP(LOOKUP(INCH,LOOK)) THEN ERR('LOOKUP FAILURE');
  LOOK[1]_SIXBIT'ERR'; LOOK[2]_LOOK[3]_0;
  IF NOT SKIP(ENTER(OUTCH,LOOK)) THEN ERR('ENTER FAILURE');
END;

USETO(OUTCH,TXTBLK); OUTPUT(OUTCH);

LINE_1; DECR I FROM DIRSZ-1 TO 0 DO DIR[.I]_0;

LOOP: WHILE 1 DO
  BEGIN
    IF (MESN_RDOCT()) LSS 0 THEN LEAVE LOOP;
    IF .MESN GEQ DIRSZ THEN ERR('BAD MESSAGE NUMBER');
    IF .DIR[.MESN] NEQ 0 THEN ERR('REPEATED MESSAGE NUMBER');
    DIR[.MESN]_.MESPTR;
    WHILE (IF (CHAR_READ()) LSS 0 THEN LEAVE LOOP; .CHAR NEQ "@") DO
      WRITE(.CHAR);
    WRITE(0)
  END;

OBUF[CNT]_0; WRITE(0);

USETO(OUTCH,1); SETSTS(OUTCH,#17);

BEGIN REGISTER LIST[2];
  LIST[0]<18,18>_-DIRSZ/2; LIST[0]<0,18>_DIR-1<0,0>; LIST[1]_0;
  IF SKIP(OUT(OUTCH,LIST)) THEN ERR('OUTPUT ERROR')
END

END ELUDOM
