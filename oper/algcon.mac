TITLE ALGCON - ALGOL COMPILER CONTROL MODULE
SUBTTL VERSION 2B(146)

; COPYRIGHT 1971,1972 DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.

; WRITTEN BY K. NIST, C.M.U./ EDITED BY R. M. DE MORGAN, SEP 1972

	SEARCH ALGPRM		; MAIN PARAMETER FILE

	LOC .JBVER
	EXP	VERNO		; VERSION NUMBER

	TWOSEG

	RELOC 400000

	MLON

	SALL
;	THE CAI, CAM, AND SKIP INSTRUCTIONS HAVE BEEN RENAMED.  THE NEW
;	NAMES READ AS FOLLOWS:
;
;
;				E  (EQUAL TO)
;				N  (NOT EQUAL TO)	   I (IMMEDIATE)
;	A (THE ACCUMULATOR IS)	NE (NOT EQUAL TO)
; I (IF)			G  (GREATER THAN)	   M (MEMORY)  ,THEN DONT SKIP
;	M (THE MEMORY LOC IS)	L  (LESS THAN)
;				GE (GTR THAN OR EQUAL TO)  Z (ZERO)
;				LE (LESS THAN OR EQUAL TO)
;
;
;	OF COURSE, NOT ALL COMBINATIONS OF THE ABOVE EXIST.
;
;
	OPDEF	L	[MOVE]
	OPDEF	ST	[MOVEM]
	OPDEF	LI	[MOVEI]
	OPDEF	ZERO	[SETZM]
	OPDEF	GOTO	[JRST]
	OPDEF	NOP	[JFCL]


	OPDEF	CORE	[CALLI 11]
	OPDEF	TMPCOR	[CALLI 44]
	OPDEF	RESET	[CALLI 0]
	OPDEF	PJOB	[CALLI 30]
	OPDEF	APRENB	[CALLI 16]
	OPDEF	EXIT	[CALLI 12]
	OPDEF	DEVCHR	[CALLI 4]
	OPDEF	DATE	[CALLI 14]
	OPDEF	MSTIME	[CALLI 23]
	OPDEF	RUN	[CALLI 35]


	DEFINE	MM (Z1,Z2,Z3)
	<
	OPDEF	Z1'L'Z2		[Z3'GE]
	OPDEF	Z1'LE'Z2	[Z3'G]
	OPDEF	Z1'G'Z2		[Z3'LE]
	OPDEF	Z1'GE'Z2	[Z3'L]
	OPDEF	Z1'E'Z2		[Z3'N]
	OPDEF	Z1'N'Z2		[Z3'E]
	OPDEF	Z1'NE'Z2	[Z3'E]
	>

	MM	IA,I,CAI
	MM	IA,M,CAM
	MM	IM,Z,SKIP
;	THE IMB- AND SMB- MACROS ARE INTENDED TO TAKE THE RIGHT/LEFT DEPENDENCY 
;	OUT OF THE "TEST" INSTRUCTIONS.  WHETHER THE IMB- AND SMB- MACROS
;	PRODUCE A TR- OR TL- DEPENDS UPON THE VALUE OF THE OPERAND.  THUS A
;	FLAG BIT ASSIGNMENT CAN BE CHANGED TO THE OTHER HALF OF THE WORD WITHOUT
;	EXTENSIVE RECODING.  THE MACRO NAMES ARE READ AS FOLLOWS:
;
;
;                  Z (ARE ALL ZEROES)   ((AFTERWARDS DO NOTHING))
; IMB (IF THE MASKED BITS)            O ((AFTERWARDS ONES THEM))   ,THEN DONT SKIP
;                  M (ARE MIXED)      Z ((AFTERWARDS ZERO THEM))
;				      C ((AFTERWARDS COMPLEMENT THEM))
;
;
;
;	                     Z (TO ZEROES)
;	 SMB (SET THE BITS)  O (TO ONES)
;	                     C (TO THEIR COMPLIMENT)


	DEFINE	V (Z8,Z9,Z10,Z11)
	<
	DEFINE	IMB'Z9'Z11 (Z6,Z7)
	<
	IFN  	Z7/1000000, < TL'Z10'Z8 Z6,Z7-1000000>
	IFE  	Z7/1000000, < TR'Z10'Z8 Z6,Z7>>>


	V	E,M,N
	V	N,Z,N
	V	E,M,C,C
	V	N,Z,C,C
	V	E,M,O,O
	V	N,Z,O,O
	V	E,M,Z,Z
	V	N,Z,Z,Z
	DEFINE	VV (V1)
<
	DEFINE	SMB'V1 (V2,V3)
<
	IFN	V3/1000000, < TL'V1 V2,V3-1000000>
	IFE	V3/1000000, < TR'V1 V2,V3>>>


	VV	O
	VV	OA
	VV	C
	VV	CA
	VV	Z
	VV	ZA
;   THIS MODULE CONTAINS THE FOLLOWING ROUTINES:
;
;
;   .RINIT	".RINIT" WILL INITIALIZE THE READ MODULE AND WRITE MODULE.
;		".RINIT" WILL SCAN THE COMMAND STRING AND OPEN FILES,
;		INITIALIZE VARIABLES, AND ACQUIRE AND ALLOCATE SPACE
;		FOR TABLES.
;
;   .PINIT	".PINIT" IS CALLED BEFORE EACH ENTRY PROCEDURE TO
;		REINITIALIZE VARIABLES AND REALLOCATE TABLES.  ".PINIT"
;		IS AUTOMATICALLY DONE AS PART OF ".RINIT".
;
;   .RUND	".RUND" PERFORM LEXICAL SCANNING.  ".RUND" WILL "READ UNTIL
;		NEXT DELIMITER" AND THEN SHIFT THE WINDOW.  ".RUND" WILL
;		COMPUTE "LEXEX" AND "COMPNAME".
;
;   .SEARCH	".SEARCH" WILL SEARCH THE SYMBOL TABLE FOR AN IDENTIFIER
;		AND, OPTIONALLY, IF NOT FOUND WILL ENTER THE IDENTIFIER
;		INTO THE TABLE.
;
;   .STADD	".STADD" WILL ADD TO THE SYMBOL TABLE AN ENTRY FOR AN
;		IDENTIFIER WHOSE NAME DUPLICATES THE NAME OF AN EXISTING
;		IDENTIFIER.
;
;   .EXTEND	".EXTEND" WILL MAKE THE LAST ENTRY IN THE SYMBOL TABLE AN
;		EXTENDED ENTRY.
;
;   .TOFIX	".TOFIX" WILL ENTER A TYPE-15 FIXUP INTO THE FIXUP TABLE.
;
;   .CON1	".CON1" WILL ENTER A 1-WORD CONSTANT INTO THE CONSTANTS
;		TABLE.
;
;   .CON2	".CON2" WILL ENTER A 2-WORD CONSTANT INTO THE CONSTANTS
;		TABLE.
;
;   .FAILED	".FAILED" WILL ENTER AN ERROR MESSAGE INTO THE MESSAGE TABLE
;		TO BE INCLUDED IN THE LISTING.
;   .BLK1	".BLK1" IS CALLED AT THE BEGINNING OF A BLOCK TO ENTER INTO
;		THE LISTING THE MESSAGE "START OF BLOCK N".
;
;   .BLK2	".BLK2" IS CALLED AT THE END OF A BLOCK TO ENTER INTO THE
;		LISTING THE MESSAGE "END BLOCK N, CONT M".
;
;   .SCRUND	".SCRUND" WILL COMPUTE "LEXEX" AND "COMPNAME".
;
;   GETCS	"GETCS" WILL READ AND INTERPRET A COMMAND STRING.
;
;   LMSGZ	"LMSGZ" IS CALLED AT THE END OF A COMPILATION TO PRINT
;		THE REMAINING CONTENTS OF THE MESSAGE TABLE.
;
;   .STOVER	".STOVER" WILL HANDLE STACK OVERFLOWS.
;
;   INS		"INS" AND "TCHECK" ARE USED TO INSERT MESSAGES INTO
;   TCHECK	THE LISTING.
;
;   GETSPC	"GETSPC" IS USED TO ACQUIRE SPACE IN THE SYMBOL TABLE.
;
;   HAL		"HAL" WILL COMPUTE THE HASH VALUE AND NAME LENGTH FOR A
;		SYMBOL TABLE ENTRY.
;   TABLE ALLOCATION:

;
; TEMP   SYMBOL            FIXUP CONSTANTS    STACK
; CODE   TABLE             TABLE TABLE
;!      !                       !            !                       !
;!  \   !           \     /     !     \      !                 \     !
;!--->  !------------>   <------!------>     !------------------>    !
;!  /   !           /     \     !     /      !                 /     !
;!      !                       !            !                       !
; T      ST           N N        FC     N     CS                    C
; C      YC           A A        IO     A     OT                    O
; B      MM           S F        XN     C     NA                    R
; A      BA           T T        UT     T     EC                    E
; S      OX           E E        PA     E     NK                    N
; E      L                        B           DB                    D
;
;
;
;
;	TEMPCODE IS A BUFFER THAT RECEIVES PARTIALLY GENERATED CODE FOR
;	EXPRESSIONS. TEMPCODE CAN OVERFLOW IF THE COMPILER ENCOUNTERS
;	A SUPER-LARGE EXPRESSION.  WHEN THIS HAPPENS THE COMPILATION
;	ABORTS.   THE DEFAULT LENGTH OF TEMPCODE IS "TEMPL".  THE ALGOL
;	USER CAN OVER-RIDE THIS WITH THE /T SWITCH.
;
		IFNDEF	TEMPL,<
		TEMPL=400>
;
;
;	THE SYMBOL TABLE HAS ENTRIES FOR ALL IDENTIFIERS ACTIVE IN THE
;	USER'S PROGRAM.  THE FIXUP TABLE CONTAINS THE ACCUMULATED TYPE-15
;	LOADER BLOCK FIX-UPS.  THE SYMBOL TABLE AND FIXUP TABLE GROW
;	TOWARD EACH OTHER. IF THEY SHOULD MEET, CORE WILL BE EXPANDED
;	BY AN AMOUNT "DELTA", THE FIXUP TABLE, CONSTANTS TABLE, AND STACK
;	WILL BE MOVED UPWARD IN CORE BY AN AMOUNT "DELTA", AND THE COMPILATION
;	WILL CONTINUE.  THE COMBINED INITIAL LENGTH OF THE SYMBOL TABLE
;	AND FIXUP TABLE IS "TABLES".
;
		IFNDEF	TABLES,<
		TABLES=400>
;	THE CONSTANTS TABLE CONTAINS WHATEVER SINGLE AND DOUBLE PRECISION
;	FIXED AND FLOATING POINT CONSTANTS THAT CANNOT BE EXPRESSED AS
;	IMMEDIATES, AND ALSO STRINGS.  IF THE CONSTANTS TABLE SHOULD
;	OVERFLOW, CORE WILL BE EXPANDED BY AN AMOUNT "DELTA", THE STACK
;	WILL BE MOVED UPWARD IN CORE BY AN AMOUNT "DELTA", AND THE
;	COMPILATION WILL CONTINUE.  THE INITIAL LENGTH OF THE CONSTANTS
;	TABLE IS "CONL".
;
		IFNDEF	CONL,<
		CONL=30>
;
;
;
;	THE STACK CONTAINS "PUSH" AND "PUSHJ" DATA, AND OTHER BLOCKS OF
;	DATA.  WHEN THE STACK OVERFLOWS, CORE IS EXPANDED BY AN AMOUNT
;	"DELTA".  THE INITIAL LENGTH OF THE STACK IS "STACKL".
;
		IFNDEF	STACKL,<
		STACKL=100>
;
;
;
;	THE UPPER BOUND OF THE STACK IS "COREND". PLEASE NOTE THAT NOTHING
;	CAN GO INTO THE LOW SEGMENT ABOVE "COREND".
;
;
		IFNDEF	DELTA,<
		DELTA=100>
;
;
;
;	ALL BUFFER RINGS ARE COMPOSED OF BUFFERS OF STANDARD SIZE
;	FOR THE PARTICULAR DEVICE.  THE ALGOL USER CAN SELECT THE NUMBER
;	OF BUFFERS IN EACH RING WITH THE /B SWITCH.  THE DEFAULT NUMBER
;	OF BUFFERS IN EACH BUFFER RING IS:
;
		IFNDEF	SBUF,<		; SOURCE
		SBUF==2>

		IFNDEF	LBUF,<		; LISTING
		LBUF==2>

		IFNDEF	OBUF,<		; OBJECT CODE
		OBUF==2>
;	IN THE EVENT OF A COMPILATION ERROR,  THE COMPILER CAN EITHER
;	PRINT A FULL MESSAGE OR SIMPLY A MESSAGE NUMBER.  THE MESSAGE
;	NUMBER VERSION OF THE COMPILER IS ABOUT 1K (DECIMAL) SMALLER
;	IN SIZE.  THE ASSEMBLY VARIABLE THAT CONTROLLS THIS IS "MTEXT".
;
		IFNDEF	MTEXT,<		; 1 = FULL MESSAGES
		MTEXT==1>		; 0 = MESSAGE NUMBERS ONLY
;
;
;
;	THERE IS AN EXPERIMENTAL VERSION OF THIS MODULE IN WHICH IT WILL
;	MAKE SEVERAL CHECKS ON ITSELF THAT SHOULD BE UNNECESSARY IF THE
;	COMPILER IS RUNNING CORRECTLY.
;
		IFNDEF	EXPER,<		; 0 = NORMAL VERSION
		EXPER==0>		; 1 = EXPERIMENTAL VERSION
; 	REGISTER ASSIGNMENTS:

	FL=0	; FLAGS REGISTER
;	A1=1	;
;	A2=2	;
;	A3=3	;
;	A4=4	;
;	A5=5	;
;	A6=6	;
;	A7=7	; SAFE OVER READ MODULE
;	A10=10	; SAFE OVER READ MODULE
;	A11=11	; SAFE OVER READ MODULE
;	A12=12	; SAFE OVER READ MODULE
;	A13=13	; SAFE OVER READ MODULE
	A14=14	; SAFE OVER READ MODULE
	DEL=15	;
	SYM=16	;
	S=17	; STACK POINTER (SAFE OVER READ MODULE)
	STOPS==7	;
	DBASE==10	;

	LEFT=1000000


; 	READ MODULE FLAGS -- BIT ASSIGNMENTS   (RFLAGS)

	EXISTS=400000+LEFT	; LISTING FILE EXISTS
	LTTY=200000+LEFT	; LISTING DEVICE IS A TTY
	CSDONE=100000+LEFT	; COMMAND STRING SCANNED, COMPILATION STARTED
	SPAREN=40000+LEFT	; PARENTHETICAL COMMAND STRING SWITCH
	TTY=20000+LEFT		; SOURCE DEVICE IS A TTY
	ESWIT=10000+LEFT	; LINE NUMBERS IN COLS 73-80
	NSWIT=4000+LEFT		; NO ERROR PRINTOUTS ON TTY
	COMPLETE=2000+LEFT	; 1 = LISTING COMPLETE AND CLOSED
	TMG=1000+LEFT		; TERMINATION MESSAGE GIVEN
	ELINE=400+LEFT		; EDITORS LINE NUMBER SCANNED
	BLANKL=200+LEFT		; BLANK LINE BEING SCANNED
	WITHIN==100+LEFT	; WITHIN NEWLINE ROUTINE
; 	ACCUMULATOR ZERO -- BIT ASSIGNMENTS

	LISTOO=20	; LISTON/LISTOFF SWITCH
	DECLAR=10	; DECLARATION MODE
	NOENTR=400	; 1 => MAKE NO NEW ENTRIES IN SYMBOL TABLE
	BPAIR==4	; SCANNING A BOUND PAIR



;	OTHER RANDOM BITS

	USE=400000+LEFT		; BUFFER USE BIT
	EXACT=400000+LEFT	; USE EXACT POINTER FOR ERROR MSG UP-ARROW
	DEVTTY=10+LEFT		; DEVCHR TTY BIT


	RWTRT==-1
	RWTLNK==0
	RWTLEN==0
	RWTLEX==1
	RWTNAM==2
	SYMBLK==0
	SYMLNK==0
	SYMTYP==1
	SYMNAM==2
	.FAILE=FAILED
	INTERN	.PINIT
	INTERN	.BLK1
	INTERN	.BLK2
	INTERN	.FAILE
	.LSCAN=LSCAN
	INTERN	.LSCAN
	.RINIT=RINIT
	INTERN	.RINIT
	.SEARCH=SEARCH
	INTERN	.SEARCH
	.STADD=STADD
	INTERN	.STADD
	.GETSPC=GETSPC
	INTERN	.GETSPC
	.RUND=RUND
	INTERN	.RUND
	.EXTEN=EXTEND
	INTERN	.EXTEN
	.HAL=HAL
	INTERN	.HAL
	.CON1=CON1
	INTERN	.CON1
	.CON2=CON2
	INTERN	.CON2
	INTERN	.SCRUND
	INTERN	.TOFIX
	INTERN	.STOVE
	INTERN	CORE
	INTERN	CHKSUM
	INTERN	CCLSW
	EXTERN	.JBERR
	EXTERN	.JBREL
	EXTERN	.FAIL
	EXTERN	.JBAPR
	EXTERN	.JBTPC
	EXTERN	.JBFF
	BLKLEV=BLOCKL
	..HARD==60+LEFT
	..SOFT==0+LEFT
	..FRIED==1040+LEFT
	..IUO==1140+LEFT
	..FATAL==200+LEFT
	..FVARY==400+LEFT
	..SYM==10+LEFT
	..DEL==4+LEFT
	..NSYM==2+LEFT
	..NDEL==1+LEFT
	..IMM==20000+LEFT
	..IUO2==100+LEFT
	SUSPCO=40+LEFT



	RELOC 0

	DEFINE	FAIL(NNN,ARG1,ARG2,TEXT)
	<
	PUSHJ	S,FAILX
	XWD	<<..'ARG1+..'ARG2>&<777777>>,^D'NNN
	>




FAILX:	PUSH	S,A1		; SAVE A1
	PUSH	S,A2		; SAVE A2
	L	A1,@-2(S)	; GET PARAM
	ST	A1,FAILX1	; SAVE IT
	PUSHJ	S,.FAIL		; CALL FAIL ROUTINE

FAILX1:	XWD	0,0		; PARAM WILL BE PUT HERE
	POP	S,A2		; RESTORE A2
	POP	S,A1		; RESTORE A1
	AOS	(S)		; SKIP RETURN
	POPJ	S,		; EXIT FAILX

	RELOC


	$IMM==1		; CONSTANT, SIMPLE
	$CT==3		; CONSTANT, REGULAR
	$ST==7		; VARIABLE, SIMPLE
	$SYMB=4+LEFT	; THIS BIT ON IMPLIES A SIMPLE VARIABLE
;    FORMAT OF A RESERVED WORD TABLE ENTRY
;
;	EACH ENTRY IN THIS TABLE IS LINKED INTO ONE OF 26 SUB-LISTS (ONE
;	FOR EACH LETTER OF THE ALPHABET) WHOSE HEADS CAN BE FOUND USING
;	THE "RESERVED WORD HASH TABLE".  WHICH SUB-LIST THAT AN ENTRY IS LOCATED
;	ON DEPENDS UPON THE FIRST LETTER OF THE NAME OF THE DELIMITER WORD.
;
;	ALL ENTRIES IN THE TABLE THAT ARE LOCATED BEFORE THE ADDRESS "FRW"
;	ARE CONSIDERED FLAGGED, AND THE WORD PRECEDING THESE ENTRIES MUST
;	CONTAIN THE ADDRESS OF A ROUTINE THAT WILL PERFORM THE SPECIAL PROCESSING
;	FOR THAT DELIMITER WORD.  OTHER THAN THIS, NEITHER THE POSITION OF
;	A DELIMITER WORD IN THE TABLE NOR ITS POSITION ON A SUB-LIST IS
;	CRITICAL,  ALTHOUGH DELIMITERS ON A SUB-LIST SHOULD BE ARRANGED IN
;	ORDER OF FREQUENCY OF USAGE.
;
;	THE RIGHT HALF OF THE FIRST WORD OF AN ENTRY CONTAINS THE SUB-LIST
;	LINK.  THE LEFT HALF CONTAINS EITHER A 0 OR A -1, DEPENDING ON WHETHER
;	THE DELIMITER NAME WILL TAKE UP 1 WORD OR 2, RESPECTIVELY.  THE SECOND
;	WORD OF THE ENTRY CONTAINS THE COMPLETE LEXEME FOR THE DELIMITER.
;	THE THIRD AND FOURTH WORDS OF THE ENTRY CONTAIN THE NAME OF THE DELIMITER.
;	THERE IS NO FOURTH WORD IF THE NAME IS ONLY 1 WORD LONG (5 CHARACTERS
;	OR LESS).



	DEFINE	N1(NAM,LN)
	<
					<373737373737>&<LN-1+SIXBIT/NAM/>
	>

	DEFINE	N2(NAM)
	<
					<373737373737>&<SIXBIT/NAM/>
	>
	DEFINE LEX(ROOT)
	<
	INTERN	Z'ROOT
	EXTERN	L$'ROOT,R$'ROOT
					Z'ROOT:	XWD	L$'ROOT,R$'ROOT>

;	***  RESERVED WORD TABLE  ***

	FBEGIN
FB:	FB1		; BEGIN
	LEX(BEGIN)
	N1(NIGEB,5)

	FEND
FE:	FE1		; END
	LEX(END)
	N1(DNE,3)

	FFALSE
FF1:	FF2		; FALSE
	0
	N1(ESLAF,5)

	FGO
FG1:	0		; GO
	LEX(GOTO)
	N1(OG,2)

	COMNT2
FC:	XWD	-1,FC1	; COMMENT
	0
	N1(EMMOC,7)
	N2(TN)

	FTRUE
FT1:	0		; TRUE
	0
	N1(EURT,4)
FRW:	;  ALL PRECEDING RESERVED WORDS ARE FLAGGED.

FA:
	.+3		; ARRAY
	LEX(ARRAY)
	N1(YARRA,5)

	0		; AND
	LEX(AND)
	N1(DNA,3)

FB1:
	XWD	-1,0	; BOOLEAN
	LEX(BOOLEAN)
	N1(ELOOB,7)
	N2(NA)


FC1:
	XWD	-1,.+4	; COMPLEX
	LEX(COMPLEX)
	N1(LPMOC,7)
	N2(XE)


	XWD	-1,.+4	; CHECKON
	LEX(CON)
	N1(KCEHC,7)
	N2(NO)

	XWD	-1,0	; CHECKOFF
	LEX(COFF)
	N1(KCEHC,8)
	N2(FFO)

FD:
	.+3		; DO
	LEX(DO)
	N1(OD,2)

	0		; DIV
	LEX(DIV)
	N1(VID,3)
FE1:
	.+3		; ELSE
	LEX(ELSE)
	N1(ESLE,4)

	XWD	-1,.+4	; EXTERNAL
	LEX(EXTERNAL)
	N1(RETXE,8)
	N2(LAN)

	0		; EQV
	LEX(EQV)
	N1(VQE,3)

FF:
	FF1		; FOR
	LEX(FOR)
	N1(ROF,3)

FF2:
	XWD	-1,0	; FORWARD
	LEX(FORWARD)
	N1(AWROF,7)
	N2(DR)

FG:
	FG1		; GOTO
	XWD	L$GOTO,R$GOTO
	N1(OTOG,4)

FI:
	.+3		; IF
	LEX(IF)
	N1(FI,2)

	XWD	-1,.+4	; INTEGER
	LEX(INTEGER)
	N1(GETNI,7)
	N2(RE)

	0		; IMP
	LEX(IMP)
	N1(PMI,3)
FLL:
	.+3		; LABEL
	LEX(LABEL)
	N1(LEBAL,5)

	.+3		; LONG
	LEX(LONG)
	N1(GNOL,4)


	XWD	-1,.+4	; LISTON
	LEX(LON)
	N1(OTSIL,6)
	N2(N)

	XWD	-1,.+4	; LISTOFF
	LEX(LOFF)
	N1(OTSIL,7)
	N2(FF)

	0		; LINE
	LEX(LINE)
	N1(ENIL,4)

FN:
	0		; NOT
	LEX(NOT)
	N1(TON,3)

FO:
	.+3		; OWN
	LEX(OWN)
	N1(NWO,3)

	0		; OR
	LEX(OR)
	N1(RO,2)

FP:
	XWD	-1,0	; PROCEDURE
	LEX(PROCEDURE)
	N1(ECORP,9)
	N2(ERUD)
FR:
	.+3		; REAL
	LEX(REAL)
	N1(LAER,4)

	0		; REM
	LEX(REM)
	N1(MER,3)


FS:
	.+3		; STEP
	LEX(STEP)
	N1(PETS,4)

	XWD	-1,.+4	; STRING
	LEX(STRING)
	N1(NIRTS,6)
	N2(G)

	XWD	-1,0	; SWITCH
	LEX(SWITCH)
	N1(CTIWS,6)
	N2(H)

FT:
	FT1		; THE
	LEX(THEN)
	N1(NEHT,4)

FU:
	0		; UNTIL
	LEX(UNTIL)
	N1(LITNU,5)

FV:
	0		; VALUE
	LEX(VALUE)
	N1(EULAV,5)

FW:
	0		; WHILE
	LEX(WHILE)
	N1(ELIHW,5)
;	** RESERVED WORD HASH TABLE **

RESWRD:	FA
	FB
	FC
	FD
	FE
	FF
	FG
	0
	FI
	0
	0
	FLL
	0
	FN
	FO
	FP
	0
	FR
	FS
	FT
	FU
	FV
	FW
	0
	0
	0
;   SPECIAL CHARACTERS


	.TAB=11
	.LF=12
	.VT=13
	.FF=14
	.CR=15
	.ALT1=33
	.CLEFT=37
	.CZ=32
	.SPACE=" "
	.EXCL="!"
	.DQUOT=""""
	.$="$"
	.%="%"
	.AMPER="&"
	.LPAREN="("
	.RPAREN=")"
	.STAR="*"
	.PLUS="+"
	.COMMA=","
	.MINUS="-"
	.DOT="."
	.SLASH="/"
	.N0="0"
	.N7="7"
	.N9="9"
	.COLON=":"
	.SEMI=";"
	.EQUAL="="
	.QUESTION="?"
	.AAAAA="@"
	.A="A"
	.B="B"
	.E="E"
	.O="O"
	.T="T"
	.Z="Z"
	.LBRAC="["
	.RBRAC="]"
	.LEFT="_"
	.ALT2=175
	.ALT3=176
	.LST=SIXBIT/   LST/
	.REL=SIXBIT/   REL/
	.ALG=SIXBIT/   ALG/
	.DSK=SIXBIT/   DSK/
	.TMP=SIXBIT/   TMP/
SUBTTL ** RINIT **

;	READ MODULE INITIALIZATION ROUTINE

RINIT:	ST	1,LINK		; SAVE RETURN LINK
	CLOSE	3,0		; CLOSE SOURCE FILE, IF OPEN
	CLOSE	4,0		; CLOSE DUMP FILE, IF OPEN
	CLOSE 	5,0		; CLOSE COMMAND STRING FILE, IF OPEN
	L	S,[		; LOAD A STACK POINTER
	XWD	-46,TMPBUF]	; TEMPORARILY USE TMPBUF AS A STACK

; IF THIS IS NOT THE 1ST CALL TO ".RINIT" THEN THE LISTING FROM
; THE PREVIOUS COMPILATION MIGHT NOT YET BE COMPLETE, AND ALSO
; THE REL-FILE MIGHT NOT YET BE CLOSED NOR DELETED IF IT IS TO
; BE DELETED.

	L	A7,RFLAGS	; GET OLD READ MODULE FLAGS
	L	A4,CORE		; GET OLD VALUE OF CORE
	XORI	A4,RANDOM	; CODE IT
	IANM	A4,CHKSUM	; IF VALUE OF CORE NOT VALID
	GOTO	START1		; THEN SKIP THIS PART
	IMGEZ	WFLAG		; UNLESS REL-FILE IS TO BE DELETED
	GOTO	START0		; SKIP OVER THIS PART

	; DELETE REL-FILE

	IMEZ	OFILE		; IF THERE IS NO REL FILE
	GOTO	.+4		; THEN SKIP THIS
	ZERO	OFILE		; ZERO THE FILE NAME
	RENAME	1,OFILE		; MARK FILE FOR DELETION
	NOP			; IGNORE ANY ERRORS
	ZERO	WFLAG		; CLEAR THE WRITE MODULE FLAG

	; COMPLETE THE LISTING

START0:	IMBM	A7,COMPLETE	; IF PREVIOUS RUN'S LISTING IS COMPLETE
	GOTO	START		; THEN SKIP THIS PART
	IMEZ	A1,.JBERR	; IF THERE ARE NO ERRORS
	GOTO	.+4		; THEN SKIP THIS
	LI	A1,QUERY
	PUSHJ	S,INS		; OUTPUT "?"
	L	A1,.JBERR
	PUSHJ	S,LPRINT	; CONVERT TO DECIMAL ASCII
	PUSHJ	S,DONE1		; INCLUDE IT IN LISTING
	LI	A1,ERRORM	; " ERRORS"
	PUSHJ	S,DONE1		; INCLUDE IN LISTING
	LI	A1,LINES3	; PUT 3 BLANK LINES
	PUSHJ	S,INSERT	; IN LISTING
	PUSHJ	S,WRITEL	; WRITE OUT THIS BUFFER
	GOTO	START		; CONTINUE
	; 1ST CALL TO THIS CORE IMAGE OF ALGOL

START1:	RESET			; RESET IO
	L	A4,.JBFF	; ADD ADDRESS OF FREE CORE
	XORI	A4,RANDOM	; HASH IT
	ST	A4,CHKSUM	; SET CHECK SUM
	SETOM	CSCOMP		; COMMAND STRING MUST YET BE READ
	HRRZ	A5,.JBFF	; GET START OF FREE CORE
	ST	A5,CORE		; SET BASE OF CORE

	; ***  BEGIN THE CURRENT COMPILATION  ***

START:	CLOSE	1,0		; CLOSE REL-FILE
	CLOSE	2,0		; CLOSE LISTING
	SETZB	FL,SQSW		; INITIALIZE GLOBAL BOOLEANS
				; AND SWITCH OFF QUOTED RESERVED WORDS
	L	A7,IFLAGS	; GET A NEW SET OF FLAGS
	ZERO	DYNOWN		; CLEAR HEAP SIZE
	LI	A4,TEMPL	; DEFAULT LENGTH OF TEMPCODE
	ST	A4,LTCODE	; SET LENGTH OF TEMPCODE
	LI	A1,RLIST	; READ MODULE INIT LIST
	PUSHJ	S,BMOVE		; INITIALIZE READ MODULE FROM HIGH SEG
	LI	A4,600000	; SET PROCESSOR TO TRAP ON
	APRENB	A4,		; A PUSHDOWN OVERFLOW
	L	A4,[		; SET THE RESERVED WORD TABLE POINTER
	XWD	A1,RESWRD-.A]	; TO THE ACTUAL RESERVED WORD TABLE
	ST	A4,RWS		; SET IT

	; PROCESS COMMAND STRING

START2:	LI	A4,OBUF		; DEFAULT NUMBER OF OBJECT BUFFERS
	ST	A4,OLIST+7	; SET IT
	LI	A4,LBUF		; DEFAULT NUMBER OF LISTUFFERS
	ST	A4,LLIST+7	; SET IT
	LI	A4,SBUF		; DEFAULT NUMBER OF SOURCE BUFFERS
	ST	A4,SLIST+7	; SET IT
	IMEZ	CSCOMP		; IF PREVIOUS COMMAND STRING NOT EMPTY
	GOTO	.+4		; THEN DONT READ ANOTHER
	IMLZ	CCLSW		; IF CCLSW = -1
	GOTO	QUIT		; THEN NOTHING MORE TO COMPILE
	PUSHJ	S,GETCS		; READ IN THE COMMAND STRING
	; SCAN OBJECT CODE FILE NAME

	LI	A4,.REL		; EXTENSION NAME DEFAULT
	MOVSM	A4,OFILE+1	; SET DEFAULT
	LI	A1,OLIST	; OBJECT CODE PARAM LIST
	PUSHJ	S,SCAN2		; SCAN NAME
	PUSHJ	S,SWITCH	; PROCESS ANY SWITCHES

	; SCAN LISTING FILE NAME

	LI	A4,.DSK		; LISTING DEVICE DEFAULT
	MOVSM	A4,LLIST+1	; SET IT
	IANI	A6,.LEFT	; _?
	IAEI	A6,.EQUAL	; OR =?
	GOTO	CS1		; -YES, NEXT SCAN SOURCE FILES
	IANI	A6,.COMMA	; IF TERMINATING CHAR NOT A COMMA
	GOTO	CSER		; THEN COMMAND STRING ERROR
	LI	A4,.LST		; EXTENSION NAME DEFAULT
	MOVSM	A4,LFILE+1	; SET DEFAULT VALUE
	LI	A1,LLIST	; LISTING PARAM LIST
	PUSHJ	S,SCAN2		; SCAN NAME
	PUSHJ	S,SWITCH	; PROCESS ANY SWITCHES
	IAEI	A6,.LEFT	; _?
	GOTO	CS1		; YES
	IANI	A6,.EQUAL	; =?
	GOTO	CSER		; NO - COMMAND STRING ERROR

	; SCAN SOURCE FILE NAME

CS1:	SMBO	FL,LISTOO	; TURN LISTING ON
	PUSHJ	S,SCAN3		; SCAN 1ST SOURCE FILE AND OPEN IT	
	GOTO	CS5		; CONTINUE
	; SCAN SOURCE FILE NAME AND OPEN IT. DEV:FILE.EXT[123,456]/A/B

SCAN3:	LI	A4,.ALG		; EXTENSION NAME DEFAULT
	MOVSM	A4,SFILE+1	; SET DEFAULT
	LI	A1,SLIST	; SOURCE PARAM LIST
	PUSHJ	S,SCAN2		; SCAN NAME
	PUSHJ	S,SWITCH	; PROCESS ANY SWITCHES
	IANI	A6,.COMMA	; IF THE LAST CHAR IS NOT A COMMA
	GOTO	CS12		; THEN SKIP THIS PART
	AOS	CSCOMP		; MARK: LINE NOT COMPLETELY SCANNED
	GOTO	CS14		; CONTINUE

CS12:	IANI	A6,.CR		; IF IT IS NOT A CR
	GOTO	CS13		; THEN SKIP THIS PART
	IBP	CSP		; STEP OVER THE LINE-FEED
	PUSHJ	S,SCANCH	; READ THE NEXT CHAR
	GOTO	CS12		; TRY AGAIN


CS13:	IALEI	A6,0		; IF IT IS A NULL OR OTHER TERMINATOR
	SETOM	CSCOMP		; THEN MARK: END OF COMMAND STRING
	HRLZI	A4,070000	; BYTE POINTER BACK-UP CONSTANT
	ADDM	A4,CSP		; BACK UP THE COMMAND STRING POINTER

CS14:	SMBZ	A7,TTY		; CLEAR TTY FLAG
	L	A5,SLIST+1	; GET SOURCE DEVICE NAME
	DEVCHR	A5,		; WHAT IS DEVICE?
	IMBM	A5,DEVTTY	; IS IT A TTY?
	SMBO	A7,TTY		; YES - SET FLAG BIT

	; OPEN SOURCE DEVICE

	OPEN	3,SLIST		; OPEN SOURCE DEVICE
	GOTO	DSERR1		; -SOMETHING WRONG
	IMBM	A7,CSDONE	; UNLESS THIS IS THE 2ND SOURCE FILE IN
	GOTO	CS11		; THE COMMAND STRING, SKIP THIS PART
	; ESTABLISH SOURCE BUFFER RING

	L	A5,SLIST+7	; GET NUMBER OF BUFFERS
	LI	A1,(A5)		; COPY TO A1
	IMULI	A1,204		; EACH BUFFER TAKES UP 204 WORDS
	PUSHJ	S,ALLOCATE	; GET SPACE FOR THESE BUFFERS
	ADD	A1,[		; SET REGISTER A1 TO LOOK LIKE
	XWD	202,1]		; A BUFFER LINK WORD
	HRRZM	A1,OLDSBR	; SAVE ADDRESS OF SOURCE BUFFER RING
	GOTO	.+3		; JUMP INTO LOOP

	ST	A1,204(A1)	; SET NEXT BUFFER TO POINT TO THIS BUFFER
	ADDI	A1,204		; STEP TO NEXT BUFFER
	SOJG	A5,.-2		; LOOP
	ST	A1,@OLDSBR	; SET LINK WORD OF 1ST BUFFER


CS11:	L	A4,OLDSBR	; GET OLD SOURCE BUFFER RING
	HRLI	A4,400000	; TURN ON USE BIT
	ST	A4,BHEAD3	; USE FOR THE CURRENT FILE ALSO
	HRLI	A4,000700	; S-P BITS
	ST	A4,BHEAD3+1	; SET UP BYTE POINTER

	; FIND SOURCE FILE

CS9:	LOOKUP	3,SFILE		; SELECT SOURCE FILE
	GOTO	DSERR2		; FILE DOESNT EXIST
	IMBZ	A7,TTY		; IS SOURCE DEVICE A TTY?
	POPJ	S,		; -NO, DONE
	LI	A6,BHEADT	; YES
	HRLM	A6,SLIST+2	; REMEMBER OUTPUT SIDE
	L	A6,[		; -YES, LOAD A POINTER TO
	XWD	400000,BUF0+1]	; THE INITIAL BUFFER
	ST	A6,BHEADT	; PUT IN BUFFER HEADER
	L	A6,[		; LOAD A POINTER FOR
	POINT	7,0,35]		; WRITING THE LINE NUMBER
	ST	A6,TTYLIN	; PUT IN BUFFER HEADER
	OUTPUT	3,0		; GET 1ST OUTPUT BUFFER
	POPJ	S,		; EXIT SCAN3
SUBTTL	**  COMMAND STRING ROUTINES  **

	; SCAN A FILE NAME ELEMENT (DEV, FILE, OR EXT)

SCAN1:	L	A2,[		; OUTPUT POINTER
	POINT	6,A3]		; TO ACC A3
	SETZ	A3,		; CLEAR A3
	GOTO	CS8		; JUMP INTO LOOP

CS3:	IAGI	A6,.Z		; ABOVE "Z"?
	POPJ	S,		; -YES, EXIT

CS4:	SUBI	A6,40		; CONV TO SIXBIT
	IMBZ	A2,1770000	; MORE THAN 6 CHARS?
	GOTO	CS6		; -YES, ERROR
	IDPB	A6,A2		; DEPOSIT CHAR

CS8:	PUSHJ	S,SCANCH	; GET NEXT CHAR
	IAGEI	A6,.A		; ABOVE "A"?
	GOTO	CS3		; -YES, CONTINUE
	IAGEI	A6,.N0
	IAGI	A6,.N9		; IN RANGE "0" - "9"?
	POPJ	S,		; NO - EXIT
	GOTO	CS4		; YES - CONTINUE



CS6:	PUSHJ	S,SCANCH	; READ ANOTHER CHARACTER
	IALEI	A6,.Z		; IF IT IS ABOVE Z
	IALI	A6,.A		; OR BELOW A
	GOTO	.+2		; THEN SKIP
	GOTO	CS6		; IGNORE ANOTHER LETTER
	IALEI	A6,.N9		; IF IT IS ABOVE 9
	IALI	A6,.N0		; OR BELOW 0
	POPJ	S,		; THEN STOP, EXIT SCAN1
	GOTO	CS6		; ELSE IGNORE ANOTHER CHARACTER
	; SCAN A FILE NAME OF THE FORM  DEV:FILE.EXT[123,456]/A/B

SCAN2:	LI	A4,.DSK		; "DSK"
	MOVSM	A4,1(A1)	; SET DEFAULT VALUE
	ZERO	5(A1)		; CLEAR TIME/DATE
	ZERO	6(A1)		; CLEAR PPN
	PUSHJ	S,SCAN1		; SCAN 1ST STRING
	IANI	A6,.COLON	; ENDS IN COLON?
	GOTO	CS2		; -NO, MUST BE A FILE NAME
	ST	A3,1(A1)	; SET DEVICE NAME
	PUSHJ	S,SCAN1		; SCAN NEXT STRING

CS2:	ST	A3,3(A1)	; SET FILENAME
	IANI	A6,.DOT		; ENDS IN DOT?
	GOTO	CS10		; -NO
	PUSHJ	S,SCAN1		; -YES, SCAN EXTENSION NAME
	HLLZM	A3,4(A1)	; SAVE EXTENSION NAME

CS10:	IAEI	A6,.EXCL	; IF EXCLAMATION MARK FOUND
	GOTO	RUNUUO		; THEN TRANSFER TO NEXT CUSP
	IANI	A6,.LBRAC	; IF IT IS NOT A "["
	POPJ	S,		; THEN EXIT SCAN2

	; SCAN PROJECT/PROGRAMMER NUMBERS

	PUSHJ	S,SCAN4		; SCAN 1ST NUMBER
	IANI	A6,.COMMA	; IT IS AN ERROR IF THIS
	GOTO	CSER		; CHAR IS NOT A COMMA
	HRLZM	A5,6(A1)	; SAVE PROJECT NUMBER
	PUSHJ	S,SCAN4		; SCAN 2ND NUMBER
	IANI	A6,.RBRAC	; IT IS AN ERROR IF THIS
	GOTO	CSER		; CHAR IS NOT A RIGHT BRACKET
	HRRM	A5,6(A1)	; SAVE PROGRAMMER NUMBER
	GOTO	SCANCH		; READ NEXT CHAR, EXIT SCAN2




	; SUBROUTINE TO SCAN PROJECT NUMBER OR PROGRAMMER NUMBER

SCAN4:	LI	A5,0		; CLEAR A5
	PUSHJ	S,SCANCH	; GET NEXT CHAR
	IAGEI	A6,.N0		; IF IT IS BELOW "0"
	IAGI	A6,.N7		; OR ABOVE "7"
	POPJ	S,		; THEN EXIT SCAN4
	LSH	A5,3		; MULTIPLY BY 8
	ADDI	A5,-.N0(A6)	; AND ADD IN CURRENT DIGIT
	GOTO	SCAN4+1		; LOOP
	; CHECK FOR A COMMAND STRING SWITCH

SWITCH:	SMBZ	A7,SPAREN	; CLEAR FLAG
	IAEI	A6,.SLASH	; ARE THERE ANY SWITCHES??
	GOTO	SW1		; -YES, SCAN ONE
	IANI	A6,.LPAREN	; IF NO PARENTHECISED SWITCH
	POPJ	S,		; THEN EXIT SWITCH
	SMBO	A7,SPAREN	; SET FLAG

SW1:	LI	A4,0		; ZERO A4
	PUSHJ	S,SCANCH	; GET THE NEXT CHAR

SW2:	IALEI	A6,.Z		; IF IT IS ABOVE "Z"
	IALI	A6,.A		; OR BELOW "A"
	GOTO	SW3		; THEN MAYBE IT IS A DIGIT
	XCT	STABLE-.A(A6)	; EXECUTE THE PARTICULAR SWITCH ROUTINE
	PUSHJ	S,SCANCH	; GET ANOTHER CHAR
	IMBZ	A7,SPAREN	; IF NO RIGHT PAREN THEN
	GOTO	SWITCH		; SEE IF IT IS ANOTHER SWITCH
	IANI	A6,.RPAREN	; IF THIS IS NOT A RIGHT PAREN
	GOTO	SW2		; THEN IT IS ANNTHER SWITCH
	SMBZ	A7,SPAREN	; MARK: RIGHT PAREN FOUND
	PUSHJ	S,SCANCH	; GET NEXT CHAR
	GOTO	SWITCH		; SEE IF THERE IS ANOTHER SWITCH

	; SCAN NUMERICAL SWITCH VALUE

SW3:	IALEI	A6,.N9		; IF IT IS ABOVE 9
	IALI	A6,.N0		; OR BELOW 0
	GOTO	SE		; THEN IT IS AN ERROR

SW4:	ADDI	A4,-.N0(A6)	; ADD IN CURRENT DIGIT
	PUSHJ	S,SCANCH	; GET ANOTHER CHARACTER
	IALEI	A6,.N9		; IF IT IS ABOVE 9
	IALI	A6,.N0		; OR BELOW 0
	GOTO	SW2		; THEN READ THE SWITCH CHARACTER
	IMULI	A4,^D10		; OTHERWISE MULTIPLY PREVIOUS RESULT BY 10
	GOTO	SW4		; AND READ THE NEXT DIGIT
	; SWITCH FORMAT ERROR

SE:	TTCALL	3,SWERR		; ISSUE MESSAGE
	GOTO	CSER+1		; DECIDE WHAT TO DO NEXT

SWERR:	ASCIZ	/?SWITCH ERROR
/

	; /Q SWITCH:  QUOTED RESERVED WORDS

QQQQ:	SETOM	SQSW		; SET QUOTED RESERVED WORD SWITCH ON
	LI	A6,ALTRWT-.A	; SET RESERVED WORD TABLE POINTER
	HRRM	A6,RWS		; TO THE ALTERNATE RESERVED WORD TABLE
	POPJ	S,		; EXIT QQQQ
	; INPUT THE COMMAND STRING

GETCS:	ZERO	CSFILE		; CLEAR COMMAND STRING FILE NAME
	ZERO	CSFILE+1	; CLEAR COMMAND STRING EXTENSION NAME
	ZERO	CSFILE+3	; CLEAR PROJECT/PROGRAMMER NUMBER
	IMEZ	CCLSW		; IF ENTRY WAS NOT FROM CCL
	GOTO	GETCS2		; THEN SKIP THIS PART

	; READ CCL COMMAND STRING WITH TMPCOR UUO

	SETOM	CCLSW		; MARK: CCL COMMAND STRING HAS BEEN READ
	L	A4,[		; GET TMPCOR PARAMETER
	XWD	2,TEMPC1]	; READ JUST FOR LENGTH OF FILE
	TMPCOR	A4,		; READ TEMPORARY CORE FILE
	GOTO	GETCS1		; READ ERROR, SEE IF THERE IS A DISK FILE
	GOTO	GETCS3		; CONTINUE

	; READ CCL COMMAND STRING FROM DISK

GETCS1:	L	A3,[		; GET A BYTE POINTER
	XWD	440600,A1]	; TO REGISTER A1
	PJOB	A4,		; GET JOB NUMBER
	IDIVI	A4,^D100	; GET 1ST DIGIT
	ADDI	A4,20		; CONVERT TO SIXBIT
	IDPB	A4,A3		; PUT IN A1
	IDIVI	A5,^D10		; GET 2ND AND 3RD DIGITS
	ADDI	A5,20		; CONVERT 2ND DIGIT TO SIXBIT
	IDPB	A5,A3		; PUT IN A1
	ADDI	A6,20		; CONVERT THIRD DIGITI TO SIXBIT
	IDPB	A6,A3		; PUT IT IN A1
	HRRI	A1,.ALG		; A1 NOW CONTAINS XXXALG
	ST	A1,CSFILE	; SET FILE NAME
	LI	A1,.TMP		; THE EXTENSION NAME IS TMP
	MOVSM	A1,CSFILE+1	; SET EXTENSION NAME
	LI	A1,.DSK		; DEVICE IS DSK
	MOVSM	A1,CSLIST+1	; SET DEVICE NAME
	; OPEN COMMAND STRING FILE, WRITE A "*"

GETCS2:	OPEN	5,CSLIST	; OPEN COM STRING DEVICE
	GOTO	TERMIN		; CANT OPEN, QUIT
	LOOKUP	5,CSFILE	; FIND THE FILE IF THERE IS ONE
	GOTO	TERMIN		; FILE CANNOT BE READ
	IMNZ	CCLSW		; IF CALLED FROM CCL
	GOTO	GETCS4		; THEN DONT PRINT COMMAND STRING STAR
	OUTBUF	5,1		; GET A BUFFER RING
	OUTPUT	5,0		; GET AN OUTPUT BUFFER
	LI	A4,.STAR	; "*"
	IDPB	A4,STHEAD+1	; PUT IN OUTPUT BUFFER
	OUTPUT	5,0		; WRITE IT TO THE TTY

	; READ IN COMMAND STRING

GETCS4:	INBUF	5,1		; GET AN INPUT BUFFER RING
	INPUT	5,0		; READ THE COMMAND STRING
	L	A4,CSHEAD	; BUFFER ADDRESS
	HRLZI	A4,2(A4)	; WHERE COMMAND STRING SITS NOW
	HRRI	A4,CSTRIN	; WHERE TO MOVE IT TO
	BLT	A4,CSTRIN+CSLEN-1 ; SAVE THE COMMAND STRING
	ZERO	CSFILE		; CLEAR FILE NAME
	RENAME	5,CSFILE	; DELETE THE TEMPORARY FILE
	NOP			; IGNORE ANY ERRORS
	CLOSE	5,0		; CLOSE DEVICE

GETCS3:	L	A6,[		; GET A POINTER TO THE
	XWD	440700,CSTRIN]	; COMMAND STRING
	ST	A6,CSP		; SAVE IT
	ILDB	A6,A6		; GET 1ST CHAR
	PUSHJ	S,SCANCH+1
	IAEI	A6,.CR		; IF THE 1ST CHARACTER IS A CR
	GOTO	GETCS		; THEN READ ANOTHER COMMAND STRING
	JUMPL	A6,GETCS	; DITTO FOR OTHER TERMINATOR
	ZERO	CSCOMP		; MARK: COMMAND STRING YET TO BE SCANNED
	POPJ	S,		; RETURN

SCANCH:	ILDB	A6,CSP		; FETCH NEXT CHARACTER
	IALEI	A6,172
	IALI	A6,141		; LOWER CASE?
	GOTO	SCANC1
	SUBI	A6,40		; CONVERT IT TO UPPER CASE
	POPJ	S,
SCANC1:	IANI	A6,.SPACE
	IAEI	A6,.TAB
	GOTO	SCANCH		; IGNORE SPACES AND TABS
	IANI	A6,.LF		; CONVERT
	IAEI	A6,.VT		; ALL
	GOTO	SCANC2
	IANI	A6,.FF		; TERMINATORS
	IAEI	A6,.ALT1	; TO
	GOTO	SCANC2
	IANI	A6,.ALT2	; PSEUDO-
	IAEI	A6,.ALT3	; ALTMODE

SCANC2:	MOVNI	A6,1		; (VALUE -1)
	POPJ	S,
	RELOC

;----------------------------------------------------------
OLIST:	14			; "B" DATA MODE
	0			; SIXBIT DEVICE
	XWD	BHEAD1,0	; BUFFER HEADER
OFILE:	0			; SIXBIT FILENAME
	0			; SIXBIT EXTENSION
	0			; TIME/DATE
	0			; PROJECT/PROGRAMMER
	0			; NUMBER OF RING BUFFERS

BHEAD1:	0			; OBJECT BUFFER HEADER BLOCK
	0			; WRITE POINTER
	0			; COUNT

;----------------------------------------------------------
LLIST:	0			; "A" DATA MODE
	0			; SIXBIT DEVICE
	XWD	BHEAD2,0	; BUFFER HEADER
LFILE:	0			; SIXBIT FILENAME
	0			; SIXBIT EXTENSION
	0			; TIME/DATE
	0			; PROJECT/PROGRAMMER 
	0			; NUMBER OF BUFFERS

BHEAD2:	0			; LISTING BUFFER HEADER BLOCK
W:	0			; LISTING POINTER
	0			; COUNT

;----------------------------------------------------------
SLIST:	0			; "A" DATA MODE
	0			; SIXBIT DEVICE
	XWD	0,BHEAD3	; BUFFER HEADER
SFILE:	0			; SIXBIT FILENAME
	0			; SIXBIT EXTENSION
	0			; TIME/DATE
	0			; PROJECT/PROGRAMMER
	0			; NUMBER OF BUFFERS

BHEAD3:	0			; SOURCE BUFFER HEADER BLOCK
P:	0			; READ POINTER
	0			; COUNT

BHEADT:	0			; SOURCE LINE NUMBER HEADER BLOCK
TTYLIN:	0			; LINE NUMBER POINTER
	0			; COUNT
;----------------------------------------------------------
CSLIST:	1			; "AL" DATA MODE
	SIXBIT	/TTY/		; DEVICE
	XWD	STHEAD,CSHEAD	; BUFFER HEADS

CSFILE:	0			; SIXBIT FILE NAME
	0			; SIXBIT EXTENSION
	0			; TIME/DATE
	0			; PROJECT/PROGRAMMER NUMBER

CSHEAD:	0			; BUFFER
CSP:	0			; POINTER
	0			; COUNT

;--------------------------------------------------------
STHEAD:	BLOCK	3		; BUFFER HEADER FOR COMMAND STRING STAR

	CSLEN==20		; LENGTH OF COMMAND STRING BUFFER

CSTRIN:	BLOCK	CSLEN		; COMMAND STRING BUFFER

CCLSW:	0			; CCL SWITCH. 1=ENTERED FROM CCL
RFLAGS:	0			; READ-MODULE FLAGS
BLOCK1:	0			; BEGINNING OF SYMBOL TABLE BLOCK 1
STACKB:	0			; BEGINNING OF STACK
CORE:	0			; BEGINNING OF CORE ACQUIRED WITH CORE UUO
COREND:	0			; END OF LOW SEGMENT
LTCODE:	0			; LENGTH OF TEMPCODE
CSCOMP:	0			; -1 = COMMAND STRING COMPLETELY SCANNED
				; 0 = COMMAND STRING CONTAINS YET ANOTHER COMP.
				; 1 = CURRENT LINE OF COM.STRING NOT COMPLETELY SCAND.
CHKSUM:	0			; CHECK SUM
PNBUF:	BLOCK	2		; PREPARED NAME BUFFER

	RELOC

TEMPC1:	XWD	.ALG,0		; TMPCOR READ BLOCK
	IOWD	CSLEN,CSTRIN
SUBTTL	** A RANDOM COLLECTION OF RANDOM ROUTINES **

	; TERMINATE COMPILATION DUE TO ABNORMAL CONDITION

TERMIN:	TTCALL	3,TERMSG	; WRITE TERMINATE MSG
QUIT:	CLOSE	1,0		; CLOSE OBJECT FILE
	CLOSE	2,0		; CLOSE LISTING FILE
	CLOSE	3,0		; CLOSE SOURCE FILE
	L	A4,CORE		; GET ORIGINAL VALUE OF JOBFF
	HRRZM	A4,.JBFF	; RETURN CORE USED DURING COMPILATION
	ZERO	CORE		; MARK: RETURNED
	EXIT			; RETURN TO MONITOR



	; COMMAND STRING ERROR

CSER:	TTCALL	3,CSERM		; WRITE MSG
	SETOM	CSCOMP		; MARK: COMMAND STRING FULLY SCANNED
	IMEZ	CCLSW		; TERMINATE IF CALLED FROM CCL
	IMBM	A7,CSDONE	; IF COMMAND STRING ONLY PART SCANNED
	GOTO	TERMIN		; THEN TERMINATE
	GOTO	START2		; ELSE GET ANOTHER COMMAND STRING



	; WRITE TO LISTING, GET NEXT OUTPUT BUFFER

WRITEL:	HLLZ	A3,W		; GET S-P BITS
	ROT	A3,4		; PUT 1ST 4 BITS IN RIGHT HALF
	SETCM	A3,MSKTBL(A3)	; GET A MASK FORM TABLE
	ANDM	A3,@W		; DELETE TRAILING EXTRA CHARS
	OUT	2,0		; GET NEXT OUTPUT BUFFER
	GOTO	.+3		; -OK, SKIP
	TTCALL	3,LISTER	; -OUTPUT ERROR
	GOTO	TERMIN		; TERMINATE COMP

	; WRITTEN OK, MARK END OF NEW BUFFER

	L	A6,BHEAD2	; ADDR OF CURRENT BUFFER
	HLRZ	A3,(A6)		; LENGTH OF BUFFER
	SMBZ	A6,USE		; ZERO USE BIT
	ADDI	A6,(A3)		; ADD LENGTH TO ADDRESS
	ST	A6,OBEND	; SAVE ADDR OF END OF BUFFER DATA
	POPJ	S,		; EXIT
	; ALLOCATE BUFFER SPACE

ALLOCATE: PUSH	S,.JBFF		; SAVE ADDRESS OF BUFFER
	ADDB	A1,.JBFF	; SET NEW VALUE OF FREE SPACE POINTER
	IALM	A1,.JBREL	; IF NOT BEYOND END OF LOW SEGMENT
	GOTO	.+3		; THEN SKIP THIS
	CORE	A1,		; MOVE UP THE TOP OF THE LOW SEG
	GOTO	TERMIN		; -CANNOT ACQUIRE MORE CORE
	POP	S,A1		; GET ADDRESS OF BUFFER
	POPJ	S,		; EXIT ALLOCATE



	; CANNOT OPEN SOURCE DEVICE

DSERR1:	SKIPA	A1,[		; INCLUDE DEVICE IN MSG
	POINT	6,SLIST+1]	; POINTER TO DEVICE NAME

	; CANNOT OPEN LISTING FILE

DSERR3:	L	A4,[
	POINT	6,LLIST+1]	; LOAD POINTER TO LISTING DEVICE NAME

DSERR0:	LI	A6,6		; 6 CHARS LONG
	PUSHJ	S,PRENAM	; WRITE TO TTY
	TTCALL	3,ILLDEV	; WRITE REST OF MSG
	GOTO	CSER+1		; TERMINATE COMP



	; WRITE DEVICE NAME ON TTY

PRENAM:	L	A5,[		; POINTER TO WHERE
	POINT	7,PNBUF]	; PREPARED NAME WILL GO
	LI	A3,.QUESTION
	IDPB	A3,A5		; OUTPUT A "?"

PNL:	ILDB	A3,A4		; GET A CHAR
	LI	A3,40(A3)	; CONV TO ASCII
	IDPB	A3,A5		; PUT IN BUFFER
	SOJG	A6,PNL		; LOOP
	IDPB	A6,A5		; END BUFFER WITH A NULL
	TTCALL	3,PNBUF		; WRITE BUFFER TO TTY
	POPJ	S,		; EXIT
	; CANNOT READ FROM INDICATED SOURCE FILE

DSERR2:	HLRZ	A4,SFILE+1	; IF EXTENSION NAME IS NULL
	JUMPE	A4,.+3		; THEN THE ERROR IS REAL
	ZERO	SFILE+1		; OTHERWISE CHANGE FROM .ALG TO .
	GOTO	CS9		; AND TRY AGAIN
	L	A4,[		; PUT FILENAME IN MSG
	POINT	6,SFILE]	; POINTER TO FILENAME
	LI	A6,6		; 6 CHARS LONG
	PUSHJ	S,PRENAM	; WRITE FILENAME TO TTY
	TTCALL	3,..DOT		; WRITE DOT TO TTY
	LI	A6,3		; 3 CHAR EXTENSION LENGTH
	L	A5,[
	POINT	7,PNBUF]
	PUSHJ	S,PNL		; WRITE FILENAME EXT TO TTY
	LDB	A6,[		; GET LOOKUP RETURN CODE
	POINT	3,SFILE+1,35]	; POINTER TO 3 BIT FIELD
	IAEI	A6,2		; IF RC=2,
	GOTO	READPR		; THEN FILE READ PROTECTED
	TTCALL	3,NOFILE	; ELSE FILE DOESNT EXIST
	GOTO	CSER+1		; TERMINATE COMP

READPR:	TTCALL	3,READPM	; WRITE MSG
	GOTO	CSER+1		; TERMINATE COMP



..DOT:	ASCIZ	/./		; DOT

IFLAGS:	XWD	WITHIN+COMPLETE&777777,NORMAL ; INITIAL READ MODULE FLAGS

	; UNABLE TO CREATE LISTING FILE

DSERR4:	TTCALL	3,UNLIST	; UNABLE TO CREATE LISTING
	GOTO	CSER+1		; TERMINATE COMP
	; DELETE OLD LISTING FILE

ERSOLD:	L	A4,LFILE	; SAVE FILENAME
	ZERO	LFILE		; ZERO FOR DELETE
	RENAME	2,LFILE		; DELETE OLD LISTING
	JFCL			; IGNORE ERRORS
	ST	A4,LFILE	; RESTORE FILENAME
	ST	A5,LFILE+2	; RESET CREATION DATE
	GOTO	LST2		; CONTINUE



	; PUT 2-DIGIT DECIMAL NUMBER IN LISTING

DEC2:	IDIVI	A4,^D10		; A4=TENS, A5=ONES
	LI	A4,60(A4)	; CONV TO ASCII
	IDPB	A4,A3		; MOVE TO LISTING
	LI	A5,60(A5)	; CONV TO ASCII
	IDPB	A5,A3		; MOVE TO LISTING
	IDPB	A14,A3		; MOVE : OR - TO LISTING
	POPJ	S,		; EXIT



	; STACK UNDERFLOW ERROR

	IFN EXPER, <
UNDER:	TTCALL	3,UNDERF	; WRITE UNDERFLOW MSG
	GOTO	TERMIN		; QUIT COMPILATION>


	; RUN THE NEXT CUSP

RUNUUO:	LI	A1,RUNLST	; INIT LIST
	PUSHJ	S,BMOVE		; INITIALIZE LB AS THE 6-WORD BLOCK
	L	A3,OFILE	; GET NAME OF PROGRAM TO BE CALLED
	ST	A3,LB+1		; PUT IN PARAMETER BLOCK
	HRLZI	A4,1		; ENTER IT AT ITS CCL ENTRY POINT
	HRRI	A4,LB		; ADDRESS OF PARAMETER BLOCK
	RUN	A4,		; LOAD AND RUN NEXT CUSP
	GOTO	TERMIN		; CUSP NOT FOUND, STOP

RUNLST:	XWD	LB,6
	SIXBIT	/SYS/
	0
	0
	0
	0
	0
	0
	; WRITE MSG AT END OF LISTING  AND TO TTY DEPENDING UPON "ERRORS"

DONE1:	IMNZ	.JBERR		; IF THERE ARE ANY ERRORS
	GOTO	INS		; SEND MESSAGE ALSO TO TTY
	GOTO	INSERT		; SEND MESSAGE TO LISTING

	; PUT CURRENT DATE AND TIME IN LISTING

DATIME:	L	A3,LBP		; GET BUFFER POINTER
	DATE	A4,		; GET DATE
	IDIVI	A4,^D372	; DIVIDE BY 372 DAYS/YEAR
	IDIVI	A5,^D31		; DIVIDE BY 31 DAYS PER MONTH
	L	A1,A5		; SAVE ACC A5
	L	A2,A4		; SAVE ACC A4
	LI	A14,.MINUS	; -
	LI	A4,1(A6)	; DAY
	PUSHJ	S,DEC2		; WRITE 2 DIGITS
	ROT	A1,-1
	LI	A4,[
	SIXBIT /JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC/](A1)
	HRLI	A4,(POINT 6,0,17)
	JUMPL	A1,.+2
	HRLI	A4,(POINT 6,0,)	; GET MONTH
	LI	A5,3
	ILDB	A6,A4
	ADDI	A6,40
	IDPB	A6,A3
	SOJG	A5,.-3		; AND WRITE IT
	IDPB	A14,A3
	LI	A4,100(A2)	; YEAR
	PUSHJ	S,DEC2		; WRITE 2 DIGITS
	LI	A1,.SPACE	; BLANK
	DPB	A1,A3		; INCLUDE
	LI	A5,3		;    FOUR
	IDPB	A1,A3		;       BLANKS.
	SOJG	A5,.-1		; PUT A BLANK IN LISTING
	MSTIME	A4,		; GET TIME OF DAY
	IDIVI	A4,^D1000	; CONVERT TO SECONDS
	IDIVI	A4,^D3600	; DIVIDE BY 3600 SEC/HOUR
	IDIVI	A5,^D60		; DIVIDE BY 60 SEC/MIN
	L	A2,A5		; SAVE ACC A5
	LI	A14,.COLON	; :
	PUSHJ	S,DEC2		; WRITE HOUR AS 2 DIGITS
	L	A4,A2		; MINUTE
	PUSHJ	S,DEC2		; WRITE 2 DIGITS
	L	A4,A6		; SECOND
	PUSHJ	S,DEC2		; WRITE 2 DIGITS
	LI	A1,0		; ASCII NULL
	DPB	A1,A3		; PUT NULL AT END OF MESSAGE
	LI	A1,LB		; ADDR OF BUFFER
	PUSHJ	S,INSERT	; INSERT LINE IN LISTING
	LI	A1,LINES3	; 3 BLANK LINES
	PUSHJ	S,INSERT	; INSERT IN LISTING
	GOTO	ICHECK		; ALIGN TO A FULLWORD, EXIT DATIME
	IFN	EXPER,<
X5:	TTCALL	3,RGCLOB	; WRITE MESSAGE
	POPJ	S,		; CONTINUE



RGCLOB:	ASCIZ	/?REGISTER CLOBBER
/
>

	RELOC

LINK:	0			; RETURN LINK
LINK1:	0			; RETURN LINK .PINIT
OLDSBR:	0			; OLD SOURCE BUFFER RING

	RELOC


;	"DEC" WILL CONVERT THE NUMBER IN A4 TO DECIMAL ASCII CHARACTERS,
;	AND PLACE THE RESULT DIRECTLY INTO THE LISTING.  "DEC" WILL PRINT
;	THE NUMBER RIGHT-JUSTIFIED IN A FIELD WHOSE SIZE IS SPECIFIED IN
;	A3.  "DEC" WILL PRECEDE THE FIRST PRINTABLE CHARACTER OF THE NUMBER
;	WITH THE CHARACTER THAT IS SPECIFIEDD IN A2.


DEC:	L	A1,A3		; COPY NUMBER OF CHARS
	IDIVI	A4,^D10		; DIVIDE BY 10
	LSHC	A5,-4		; MOVE REMAINDER TO ACC A3
	SOJG	A1,.-2		; LOOP TILL END OF NUMBER

DEC1:	LI	A1,.SPACE	; PUT BLANK IN ACC A1
	LSHC	A5,4		; GET NEXT CHAR FROM A6
	JUMPN	A5,DEC3		; JUMP IF NON ZERO
	IDPB	A1,W		; INCLUDE A LEADING BLANK
	SOJG	A3,DEC1+1	; LOOP TILL END OF NUMBER

DEC3:	DPB	A2,W		; INCLUDE SPECIAL CHARACTER
	LI	A5,.N0(A5)	; CONVERT TO ASCII
	IDPB	A5,W		; PUT NUMBER IN LISTING
	LI	A5,0		; CLEAR A5
	LSHC	A5,4		; GET NEXT CHAR FROM A6
	SOJG	A3,DEC3+1	; LOOP TILL END OF NUMBER
	POPJ	S,		; EXIT DEC

	; DETERMINE WHETHER NL CHAR IS FOR END OF LINE OR END OF BUFFER

NCHECK:	L	A1,P		; GET READ POINTER
	IAEM	A1,IBEND	; IF AT END OF BUFFER
	GOTO	INEND1		; THEN GET ANOTHER BUFFER
	AOS	(S)		; ELSE SKIP RETURN
	POPJ	S,		; EXIT NCHECK
	; COMPUTE LENGTH OF TAB

TAB:	L	A2,CC		; GET CHAR COUNT
	SUB	A2,LP1		; COMPUTE POSITION ON CURRENT LINE
	ADDI	A2,^D8		; TAB TO THE NEW POSITION
	TRZ	A2,7		; BACK UP TO 8-CHAR MULTIPLE
	SUBI	A2,1		; BACK UP 1 MORE CHAR
	ADD	A2,LP1		; COMPUTE NEW CHARACTER COUNT
	ST	A2,CC		; SE IT
	L	A2,CTABLE(A1)	; RELOAD THE TABLE ENTRY VALUE
	POPJ	S,		; EXIT TAB
	IFN EXPER, <
UNDERF:	ASCIZ	/STACK UNDERFLOW
/>
CSERM:	ASCIZ	/?INVALID COMMAND STRING
/
TERMSG:	ASCIZ	/?COMPILATION TERMINATED
/
LISTER:	ASCIZ	/?OUTPUT ERROR ON LISTING
/
ILLDEV:	ASCIZ	/ DEVICE NOT AVAILABLE
/
NOFILE:	ASCIZ	/ FILE DOES NOT EXIST
/
HEADIN:	ASCIZ	/DECSYSTEM 10 ALGOL-60, V. 2B(146):
/
READPM:	ASCIZ	/ FILE READ PROTECTED
/
UNLIST:	ASCIZ	/?CANNOT CREATE LISTING FILE
/
LINES3:	ASCIZ	/


/
FORM:	XWD	060000,0

ERRORM:	ASCIZ	/ ERRORS
/
QUERY:	ASCIZ	/?/
ALGOL:	ASCIZ	/ALGOL: /
SUBTTL	**  RINIT  **

	; CREATE OBJECT FILE

CS5:	IMNZ	OFILE		; IF FILE NAME NOT NULL
	GOTO	NOOBJ-1		; THEN CREATE THE OBJECT FILE
	MOVS	A5,OLIST+1	; GET DEVICE NAME
	IAEI	A5,.DSK		; IF DEVICE NAME IS DSK
	GOTO	NOOBJ		; THEN DEVICE WAS DEFAULTED
	PUSHJ	S,WRITE1	; CREATE OBJECT FILE

	; WRITE "ALGOL: NAME "

NOOBJ:	PUSHJ	S,WRITE0	; ELSE CALL WRITE0
	SMBO	A7,CSDONE	; 1ST PART OF CS DONE
	IMEZ	CCLSW		; IF THIS IS NOT A CCL RUN
	GOTO	LST1		; THEN SKIP THIS
	TTCALL	3,ALGOL		; WRITE "ALGOL: "
	LI	A4,6		; WRITE 6 CHARACTERS OF FILE NAME
	L	A5,[		; LOAD A POINTER TO
	XWD	440600,SFILE]	; THE NAME OF THE SOURCE FILE

	ILDB	A6,A5		; GET NEXT SIXBIT CHARACTER
	ADDI	A6,40		; CONVERT IT TO ASCII
	TTCALL	1,A6		; WRITE IT TO TERMINAL
	SOJG	A4,.-3		; LOOP
	TTCALL	3,NLCHRS	; WRITE A CR/LF

	; CREATE LISTING

LST1:	ZERO	W		; ZERO W
	IMNZ	LFILE		; IS THERE A LISTING?
	GOTO	LST		; -YES
	MOVS	A5,LLIST+1	; -MAYBE, CHECK DEVICE
	IAEI	A5,.DSK		; DSK?
	GOTO	NOLST		; -YES, NO LISTING
	
LST:	L	A5,LLIST+1	; GET DEVICE NAME
	DEVCHR	A5,		; GET DEVICE CHARACTERISTICS WITH DEVCHR
	IMBM	A5,DEVTTY	; IF LISTING DEVICE IS A TTY
	SMBO	A7,LTTY!NSWIT	; THEN SET INDICATOR
	OPEN	2,LLIST		; OPEN LISTING
	GOTO	DSERR3		; -SOMETHING WRONG
	OUTBUF	2,@LLIST+7	; GET A BUFFER RING
	L	A5,LFILE+2	; SAVE CREATION DATE IN A5
	LOOKUP	2,LFILE		; DOES FILE ALREADY EXIST?
	GOTO	.+2		; -NO, OK
	GOTO	ERSOLD		; YES, ERASE IT
LST2:	ENTER	2,LFILE		; CREATE FILE
	GOTO	DSERR4		; -CANNOT CREATE
	SMBO	A7,EXISTS	; SET FLAG: FILE EXISTS
	ZERO	FIVEC		; INIT FIVE CHAR COUNT

	; PUT HEADING IN LISTING

	PUSHJ	S,WRITEL	; GET THE 1ST LISTING BUFFER
	LI	A1,FORM		; ADDRESS OF A FORM FEED
	IMBM	A7,LTTY		; IF LISTING IS SENT TO TTY
	PUSHJ	S,INSERT	; THEN SEND A FORM-FEED THERE
	LI	A1,HEADIN	; ADDR OF HEADING
	PUSHJ	S,INSERT	; PUT IN LISTING
	PUSHJ	S,DATIME	; PUT DATE AND TIME IN LISTING
	GOTO	NOLST1		; CONTINUE


NOLST:	HRRI	A7,NLIST1	; SET FLAGS ADDR
	; INITIALIZE VARIBLES AND TABLES

NOLST1:	ZERO	CC		; INIT CHARACTER COUNT
	ZERO	OLDNO		; INIT OLD LINE NUMBER
	ZERO	LINE5		; INIT 5-CHAR LINE NUMBER
	ZERO	LSBUFP		; INIT NAME BUF LIST POINTER
	ZERO	BNUM		; INIT BEGIN NUMBER
	ZERO	LBNUM		; INIT LAST BEGIN NUMBER
	ZERO	ENUM		; INIT END NUMBER
	ZERO	LENUM		; INIT LAST END NUMBER
	ZERO	NSYM		; INIT NSYM
	ZERO	PLIST+4		; INIT PLIST+4
	ZERO	NDEL		; INIT NDEL
	ZERO	DOUBLE		; INIT DOUBLE
	ZERO	BLEX		; INIT BUFFERED LEXEME
	ZERO	.JBERR		; INIT ERROR COUNT
	ZERO	TBLEN		; INIT TMPBUF DATA LENGTH WORD
	ZERO	SSTART		; INIT SEGMENT START
	ZERO	LINENO		; INIT LINENO
	ZERO	STCFL		; INIT STRING CHARACTERS FLAG
	LI	A4,50		; SET THE BEGIN TABLE INDEX
	ST	A4,BTI		; TO 50
	LI	A4,MTABLE	; ADDRESS OF MTABLE
	ST	A4,NAMTE	; INIT MESSAGE TABLE POINTER
	LI	A4,PLIST+3	; ADDR OF POINTER TABLE
	ST	A4,PLIST	; INIT UP-ARROW LIST
	ST	A7,RFLAGS	; SAVE THE FLAGS
	HRRZ	A4,.JBFF	; GET ADDRESS OF FREE SPACE
	ST	A4,TCBASE	; USE AS BASE FOR ALLOCATION
	JSP	1,.PINIT	; ALLOCATE TABLES
	ST	A7,A7SAV	; SAVE A7
	L	A7,RFLAGS	; GET FLAGS AGAIN
	PUSHJ	S,READ		; READ IN FIRST LINE OF SOURCE

EMPTY:	SMBZ	A7,WITHIN	; MARK: WITHIN NEWLINE
	L	A2,P		; GET READ POINTER
	ST	A2,LSTART	; SAVE POINTER TO LINE START
	PUSHJ	S,NL11		; CHECK FOR LINE NUMBERS, ETC
	HALT	.		; CANT POSSIBLY RETURN HERE

EMPTY1:	SETOM	NDEL		; MAKE IT LOOK LIKE SOMTHING IS IN NDEL
	PUSHJ	S,RUND		; DO AN INITIAL RUND
	SETZ	DEL,		; CLEAR FROM DEL WHAT WE JUST PUT IN NDEL
	GOTO	@LINK		; EXIT .RINIT
SUBTTL	**  PINIT  **

.PINIT:	ST	1,LINK1		; SAVE RETURN LINK

	; INITIALIZE VARIABLES

	ZERO	TOFIXI		; INIT FIXUP TABLE HALFWORD INDEX
	ZERO	RA		; INIT PROGRAM COUNTER
	ZERO	FNLEVEL		; INIT FUNCTION LEVEL
	ZERO	BLOCKL		; INIT BLOCK LEVEL
	ZERO	LEXBLOCK	; INIT LEXICAL BLOCK LEVEL
	ZERO	CURBLOCK	; INIT CURRENT BLOCK LEVEL
	ZERO	THUNK		; INIT THUNK
	SETOM	CAX		; INIT CAX
	SETOM	PROSKIP		; INIT PROCEDURE SKIP
	HRLZI	DBASE,400000	; INIT DISPLAY POINTER
	HRLZI	DBASE+1,400000	; INIT DISPLAY POINTER
	LI	A4,14		; INIT
	ST	A4,LAC		; LAC
	HRLZI	STOPS,160000	; INIT STOPS

	; ACQUIRE SPACE FOR TABLES

	L	A5,TCBASE	; BASE OF AVAILABLE CORE
	ADD	A5,LTCODE	; THE LENGTH OF TEMPCODE
	ADDI	A5,TABLES+CONL+STACKL+1
				; PLUS THE LENGTH OF SYMBOL AND FIXUP TABLES
				; PLUS LENGTH OF CONSTANT TABLE
				; PLUS LENGTH OF STACK
	IFN EXPER, <
	ADDI	A5,10		; PLUS TRAPS IF EXPERIMENTAL>
	ST	A5,COREND	; SAVE THE CALLI PARAMETER
	HRRZM	A5,.JBFF	; SET NEW VALUE OF JOBFF
	CORE	A5,		; GET CORE FOR ALL OF THAT
	GOTO	TERMIN		; CORE NOT AVAILABLE, TERMINATE
	; ALLOCATE TABLES

	L	S,TCBASE	; BASE OF TEMPCODE
	ST	S,INDEX		; SET THE TEMPCODE INDEX
	ADD	S,LTCODE	; ADD LENGTH OF TEMPCODE
	ST	S,TCMAX		; SET END OF TEMPCODE
	ADDI	S,1		; LEAVE 1 WORD BETWEEN SYMBOL TABLE AND TEMPCODE
	ST	S,BLOCK1	; WHICH IS ALSO THE START OF THE SYMBOL TABLE
	ST	S,STBB		; START OF CURRENT BLOCK IN SYMBOL TABLE
	ST	S,NASTE		; 1ST AVAILABLE ENTRY IN SYMBOL TABLE
	ADDI	S,TABLES	; ADD LENGTH OF TABLES
	ST	S,CONTAB	; SET BASE OF CONSTANT TABLE
	ST	S,FIXUP		; WHICH IS ALSO THE BASE OF THE FIXUP TABLE
	ST	S,LASTST	; END OF STRING CHAIN
	LI	A5,1(S)		; STEP OVER 1ST WORD OF CONSTANTS TABLE
	ST	A5,NACTE	; SET NEXT AVAILABLE CONSTANT TABLE ENTRY
	LI	A5,-1(S)	; BACK UP 1
	ST	A5,NAFTE	; SET NEXT AVAILABLE FIX-UP TABLE ENTRY
	ST	A5,LASTC1	; SET CONSTANT TABLE POINTER
	LI	A5,-2(S)	; BACK UP 1 MORE
	ST	A5,LASTC2	; SET CONSTANT TABLE POINTER
	ADDI	S,CONL		; ADD LENGTH OF CONSTANT TABLE
	ST	S,CONEND	; SET END OF CONSTANT TABBLE
	IFN EXPER, <
	LI	A5,10		; PUT 8 "GOTO UNDER"S
	L	A6,[		; IN TOP OF STACK
	GOTO	UNDER]		; TO UNDERFLOW ROUTINE
	LI	S,1(S)		; STEP TO NEXT WORD
	ST	A6,(S)		; PUT A "GOTO" THERE
	SOJG	A5,.-2		; LOOP 8 TIMES>
	ST	S,STACKB	; SAVE BEGINNING ADDR OF STACK
	HRLI	S,-STACKL	; SET UP STACK POINTER
	L	A4,INDEX	; TEMPCODE POINTER
	HRLI	A4,770000	; INIT
	ST	A4,HANDLE	;  HANDLE
	HRREI	A4,-1		; THE 1ST ENTRY IN THE CONSTANTS TABLE MUST
	PUSHJ	S,CON1		; BE A CONSTANT OF -1
	LI	A1,B0LIST	; INIT LIST
	PUSHJ	S,BMOVE		; INITIALIZE BLOCK-0 FROM HIGH SEGMENT
	GOTO	@LINK1		; EXIT .PINIT
SUBTTL	**  TABLE OVERFLOW ROUTINES  **

	; SYMBOL TABLE OR FIXUP TABLE OVERFLOW

OVFL1:	PUSHJ	S,OVFLS		; SAVE SOME REGISTERS
	L	A4,NAFTE	; BASE OF CORE TO MOVE
	PUSHJ	S,OVFL		; MOVE IT
	ADDM	A4,CONTAB	; UPDATE BASE OF CONSTANT TABLE
	ADDM	A4,FIXUP	; UPDATE BASE OF FIXUP TABLE
	ADDM	A4,LASTST	; UPDATE STRING CHAIN
	ADDM	A4,NACTE	; UPDATE CONSTANT TABLE POINTER
	ADDM	A4,NAFTE	; UPDATE FIXUP TABLE POINTER
	ADDM	A4,LASTC1	; UPDATE 1-WORD CONSTANT CHAIN
	ADDM	A4,LASTC2	; UPDATE 2-WORD CONSTANT CHAIN

OVFL3:	ADDM	A4,CONEND	; UPDATE POINTER TO END OF CONSTANT TABLE
	ADDM	A4,STACKB	; UPDATE BASE OF STACK
	L	A4,OVA		; RESTORE A4
	L	A5,OVB		; RESTORE A5
	L	A6,OVC		; RESTORE A6
	L	A3,OVD		; RESTORE A3
	POPJ	S,		; EXIT OVFL1 OR OVFL2


	; CONSTANTS TABLE OVERFLOW

OVFL2:	PUSHJ	S,OVFLS		; SAVE SOME REGISTERS
	L	A4,CONEND	; BASE OF CORE TO MOVE
	PUSHJ	S,OVFL		; MOVE IT
	GOTO	OVFL3		; CONTINUE


OVFL:	LI	A5,DELTA	; LENGTH OF CORE TO ACQUIRE
	ADDB	A5,COREND	; NEW END OF LOW SEGMENT
	HRRZM	A5,.JBFF	; SET JOBFF
	CORE	A5,		; GET SOME MORE CORE
	GOTO	OVFLX		; -CANT GET IT

	L	A5,COREND	; GET NEW END OF CORE
	ADDI	A5,1-DELTA	; BLT "TO" ADDRESS
	HRLI	A5,-DELTA(A5)	; BLT "FROM" ADDRESS
	GOTO	OVFLL1		; JUMP INTO MOVE LOOP
OVFLL:	L	A3,A5		; COPY BLT PARAM TO A3
	BLT	A3,DELTA-1(A5)	; MOVE A DELTA OF CORE
	SUB	A5,[		; COMPUTE THE NEXT BLT CONSTANT
	XWD	DELTA,DELTA]	; BACK UP TO NEXT DELTA

OVFLL1:	HLRZ	A6,A5		; GET THE "FROM" ADDRESS
	IAGI	A6,(A4)		; IF ABOVE THE BASE OF CORE TO MOVE
	GOTO	OVFLL		; THEN CONTINUE LOOPING

	HRL	A4,A4		; FORM A NEW BLT POINTER FOR
	ADDI	A4,DELTA	; CORE OF SIZE LESS THAN DELTA
	L	A3,A4		; COPY BLT CONSTANT TO A3
	BLT	A3,DELTA-1(A5)	; MOVE THE LESS THAN DELTA CORE
	L	A4,[		; CORRECTION FACTOR FOR DISPLAY POINTERS
	XWD	DELTA,DELTA]	; VALUE
	LI	A5,DBASE	; HEAD OF CHAIN
	ADDM	A4,(A5)		; UPDATE THE POINTER
	HLRE	A5,(A5)		; LOCATE NEXT DISPLAY POINTER IN CHAIN
	JUMPG	A5,.-2		; LOOP UNLESS END OF LIST
	LI	A5,DBASE+1	; HEAD OF CHAIN
	ADDM	A4,(A5)		; UPDATE THE POINTER
	HLRE	A5,(A5)		; LOCATE NEXT DISPLAY POINTER IN CHAIN
	JUMPG	A5,.-2		; LOOP UNLESS END OF LIST

	IFN	EXPER,<
	ST	DBASE+1,REG2+2
	ST	DBASE,REG2+5
>
	LI	A4,DELTA	; UPDATE FACTOR
	ADD	S,A4		; SET POINTER TO NEW LOCATION OF STACK
	POPJ	S,		; EXIT OVFL


OVFLX:	TTCALL	3,OVFLXM	; SEND MSG TO TTY
	GOTO	TERMIN		; TERMINATE COMPILATION

OVFLXM:	ASCIZ	/?MORE CORE REQUIRED
/
OVFLS:	ST	A4,OVA		; SAVE A4
	ST	A5,OVB		; SAVE A5
	ST	A6,OVC		; SAVE A6
	ST	A3,OVD		; SAVE A3
	POPJ	S,		; EXIT OVFLS



	; STACK OVERFLOW BY PUSH OR PUSHJ

OVFL5:	ST	A4,OVA		; SAVE ACC A4
	L	A4,.STOVE	; GET RETURN LINK
	ST	A4,.JBTPC	; SAVE IN JOBTPC
	GOTO	.+2		; SKIP


	; STACK OVERFLOW ALLOCATING STACK LOCALS

OVFL4:	ST	A4,OVA		; SAVE IN ACC A4
	LI	A4,DELTA	; CORE INCREMENT
	ADDB	A4,COREND	; NEW END OF LOW SEGMENT
	HRRZM	A4,.JBFF	; SET JOBFF
	CORE	A4,		; GET MORE CORE
	GOTO	OVFLX		; -NOT AVAILABLE, TERMINATE
	HRLZI	A4,-DELTA	; CORRECTION CONSTANT
	ADD	S,A4		; FIX UP STACK POINTER
	L	A4,OVA		; RESTORE ACC A4
	JRST	2,@.JBTPC	; RETURN TO COMPILATION



	RELOC

OVA:	0
OVB:	0
OVC:	0
OVD:	0
.STOVE:	0			; RETURN LINK
	GOTO	OVFL5		; JUMP INTO HIGH SEGMANT

	RELOC
SUBTTL  ** NEW-LINE **

;	*** NEW-LINE ROUTINE ***
;
;	THIS ROUTINE IS CALLED WHENEVER A CARRIAGE-RETURN, LINE-FEED,
;	OR OTHER SUCH CHARACTER IS SCANNED.  NEWLINE PERFORMS ALL I/O
; 	PROCESSING ASSOCIATED WITH THE SOURCE AND LISTING FILES.
;	NEWLINE RETURNS IN REGISTER A1 THE 1ST CHAR OF THE NEXT
;	LINE.  REGISTERS A1 - A6 ARE NOT SAFE OVER NEWLINE.
;
;
;	THROUGHOUT THE COMPILER, CHARACTERS ARE SCANNED WHERE THEY SIT
;	IN THE SOURCE BUFFER RING.  CHARACTERS ARE READ WITH AN "ILDB".
;	THE LISTING IS FORMED BY TRANSFERING CHARACTERS FROM THE SOURCE
;	BUFFER RING TO THE LISTING BUFFER RING WITH A "BLT" INSTRUCTION.
;	A "BLT" IS 20 TIMES FASTER PER CHARACTER THAN AN "IDPB", ALTHOUGH
;	THERE IS A GREATER OVERHEAD INVOLVED AT THE BEGINNING OF EACH LINE.
;
;	IF I HAD KNOWN HOW MUCH TROUBLE I WAS GOING TO CAUSE MYSELF BY DOING
;	IT THIS WAY I PROBABLY WOULD HAVE USED THE IDPB'S ANYWAY.  I DONT
;	RECOMMEND THAT YOU MAKE ANY SIGNIFICANT CHANGES TO "NEWLINE" UNLESS
;	YOU HAVE A LOT OF TIME ON YOUR HANDS.  "NEWLINE" IS DECEPTIVELY
;	DIFFICULT TO DEBUG.
;
;	THE FOLLOWING ARE SOME OF THE CHARACTERISTICS OF THE "NEWLINE" ROUTINE:
;
;	1.)  THE POSITIONS OF THE CHARACTERS IN THE WORDS MUST BE THE SAME
;	IN THE SOURCE AND LISTING BUFFERS.  THEREFORE, ANYTHING ELSE THAT APPEARS
;	IN THE LISTING MUST BE ARRANGED IN STRINGS THAT ARE A MULTIPLE OF
;	5 CHARACTERS AND WHICH ARE MOVED TO THE LISTING WITH IDPB'S.
;	THIS INCLUDES THE LINE PREFIX (ON THE FRONT OF EACH LINE OF ALGOL
;	TEXT IN THE LISTING), WHICH ALSO MUST BE A MULTIPLE OF 8 PRINTABLE
;	CHARACTERS SO THAT TABS ALIGN CORRECTLY.
;
;	2.)  THE LINE IS MOVED FROM THE SOURCE BUFFER RING TO THE LISTING BUFFER
;	RING AFTER THE LINE HAS BEEN SCANNED, SINCE UNTIL THEN THE EXTENT
;	OF THE LINE IS NOT KNOWN.  WHENEVER A NEW SOURCE BUFFER IS OBTAINED
;	FROM THE SOURCE DEVICE, A WORD CONTAINING A CR/LF IS INSERTED AFTER
;	THE DATA IN THE BUFFER TO MARK ITS END.  THUS, WHENEVER A CR IS SCANNED
;	A CHECK MUST BE MADE TO SEE IF  IT IS THE END OF THE BUFFER.
;	3.)  A CONSIDERABLE AMOUNT OF CODE IS DEDICATED TO HANDLING THE
;	FOLLOWING EXCEPTIONAL CASES:  WHEN THE LINE WONT FIT IN WHAT IS LEFT
;	OF THE OUTPUT BUFFER ("SHOB1" AND "SHOB2"),  AND WHEN THE SOURCE
;	LINE IS SPLIT OVER TWO INPUT BUFFERS ("INEND" AND "SHIB").
;	WHEN THE INPUT LINE IS SPLIT OVER TWO INPUT BUFFERS, THE 1ST PART
;	MUST BE SAVED (IN "TMPBUF") WHILE THE 2ND PART IS BEING SCANNED,
;	SINCE ONCE THE NEW INPUT BUFFER IS OBTAINED, THE OLD INPUT BUFFER IS
;	NO LONGER RELIABLE.
				; THE RIGHT HALF OF RFLAGS CONTAINS
				; THE ADDRESS OF ONE OF THE FOLLOWING:
				;    NORMAL:
				;    NOLIST:
				;    NLIST1:
				;    ENDPRG:

NEWLINE: ST	A7,A7SAV	; SAVE A7
	L	A7,RFLAGS	; GET READ MODULE FLAGS
	GOTO	(A7)		; GO TO APPROPRIATE ROUTINE


	; LISTING EXISTS AND WAS ON

NORMAL:	IMBZ	FL,LISTOO	; DID HE TURN LISTING OFF?
	GOTO	TURNOF		; -YES

	; LISTING EXISTS AND IS ON

TURNON:	L	A2,P		; PUT READ POINTER IN A2
	IMBM	A7,ESWIT	; IF LINE NUMBERS IN 73-80
	L	A2,LINEND	; THEN GET TRUE READ POINTER
	ST	A2,P		; SAVE TRUE READ POINTER
	IAEM	A2,IBEND	; AT END OF INPUT BUFFER?
	GOTO	INEND		; -YES, GET ANOTHER
	SMBO	A7,WITHIN	; WE ARE WITHIN THE NEWLINE ROUTINE

	; PRINT THE 1ST BATCH OF MESSAGES

	LI	A5,MTABLE	; ADDR OF MESSAGE TABLE
	IAGEM	A5,NAMTE	; IF END OF TABLE
	GOTO	NL2		; THEN NO MESSAGES TO PRINT
	ZERO	LMSGS		; SET LMSG SWITCH TO "1ST PASS"
	PUSHJ	S,LMSG		; PRINT 1ST GROUP OF MESSAGES

NL2:	IMGZ	FFCNT2		; IF THERE ARE FORM-FEEDS THAT HAVE NOT
	PUSHJ	S,INSFF		; YET BEEN PUT IN LISTING, PUT THEM THERE

	; MAKE SURE THAT THERE IS ROOM IN OUTPUT BUFFER FOR 1ST PART OF LINE

	LI	A1,.SPACE	; PUT A BLANK IN ACC A1
	L	A4,W		; GET WRITE POINTER
	IMBM	A7,LTTY		; IF THE LISTING HS TO THE TTY
	GOTO	NL15		; THEN PRODUCE A DIFFERENT LISTING
	LI	A4,5(A4)	; GO AHEAD 5 WORDS
	IAGEM	A4,OBEND	; AT END OF BUFFER?
	PUSHJ	S,SHOB1		; -YES, GET ANOTHER
	; PRINT PROGRAM COUNTER

	ZERO	(A4)		; CLEAR 1ST CHARS OF TEXT
	IMBM	A7,TMG		; IF NO REL FILE
	GOTO	NL18		; THEN DONT PRINT PC
	L	A4,[		; LOAD A POINTER TO
	POINT	3,RA,17]	; PROGRAM COUNTER
	LI	A5,6		; PRINT 6 CHARS

NL1:	ILDB	A6,A4		; GET 3 BITS
	LI	A6,60(A6)	; CONV TO ASCII
	IDPB	A6,W		; PUT IN LISTING
	SOJG	A5,NL1		; LOOP

NL19:	IDPB	A5,W		; INCLUDE A NULL

	; PRINT BEGIN NUMBER

	L	A4,BNUM		; LOAD BEGIN NUMBER
	IAEM	A4,LBNUM	; COMPARE TO LAST BEGIN NUMBER
	JSP	A3,NL3		; -SAME, PRINT SOME BLANKS
	ST	A4,LBNUM	; SAVE AS LAST BEGIN NUMBER
	LI	A2,.B		; WRITE A "B"
	LI	A3,5		; WRITE 5 CHARS
	PUSHJ	S,DEC		; WRITE IT

	; PRINT END NUMBER

	L	A4,ENUM		; LOAD END NUMBER
	IAEM	A4,LENUM	; COMPARE TO LST END NUMBER
	JSP	A3,NL3		; -SAME, PRINT SOME BLANKS
	ST	A4,LENUM	; SAVE AS LAST END NUMBER
	LI	A2,.E		; WRITE AN "E"
	LI	A3,5		; WRITE 5 CHARS
	PUSHJ	S,DEC		; CONVERT TO DECIMAL
	GOTO	NL6		; CONTINUE


	; SUBROUTINE FOR PUTTING 5 BLANKS IN LISTING INSTEAD OF BEGIN/END NUMBER

NL3:	LI	A5,5		; WRITE 5 BLANKS
	IDPB	A1,W		; INCLUDE A BLANK
	SOJG	A5,.-1		; LOOP
	GOTO	4(A3)		; EXIT
	; PUT 6 BLANKS IN LISTING INSTEAD OF PC

NL18:	LI	A5,6		; 6 BLANKS
	IDPB	A1,W		; PUT BLANK IN LISTING
	SOJG	A5,.-1		; LOOP 5 MORE TIMES
	GOTO	NL19		; CONTINUE



	; PUT LINE NUMBER IN LISTING

NL6:	IMBMZ	A7,ELINE	; IF TEXT HAS A LINE NUMBER
	GOTO	NL5		; THEN DONT GENERATE ONE
	IMBM	A7,ESWIT	; IF NUMBERS IN 73-80
	GOTO	NL5		; THEN DONT GENERATE A LINE NUMBER
	L	A4,LINENO	; GET LINE NUMBER
	LI	A2,.SPACE	; ACC A2 = BLANK
	LI	A3,7		; PRINT 7 CHARS LONG
	PUSHJ	S,DEC		; CONVERT TO DECIMAL
	GOTO	NL7		; CONTINUE

NL5:	LI	A3,0		; PUT AN ASCII NULL INTO
	IDPB	A3,W		; THE LINE
	IDPB	A1,W		; INCLUDE ANOTHER SPACE
	IMBZ	A7,ESWIT	; IF NOT NUMBERS IN 73-80
	GOTO	NL7		; THEN SKIP THIS PART
	L	A2,CHAR		; GET THE SAVED CHARACTER
	DPB	A2,CHARP	; REINSERT IT INTO ITS PLACE IN THE LINE

	; READ THE LF THAT FOLLOWS THE CR

NL7:	IDPB	A1,W		; PUT BLANK IN LISTING
	L	A2,P		; LOAD READ POINTER
	PUSHJ	S,GETNL		; READ NEXT CHAR
	L	A3,CTABLE(A1)	; GET TABLE ENTRY
	IAEI	A3,4		; IF IT IS A LF
	ST	A1,CHAR2	; THEN SAVE THIS CHAR
	IANI	A3,4		; IS IT A LF?
	ADD	A2,[		; BACK UP POINTER
	XWD	070000,0]	; POINTER DECREMENT CONSTANT
	; PUT 1ST WORD OF LINE TEXT IN OUTPUT BUFFER

	L	A6,LSTART	; POINTER TO BEGINNING OF LAST LINE
	ST	A2,LSTART	; SET NEXT LINE START
	HLLZ	A4,W		; GET WRITE POINTER S-P BITS
	ROT	A4,4		; PUT 1ST 4 BITS IN RIGHT HALF
	L	A4,MSKTBL(A4)	; GET A MASK
	AND	A4,@A6		; MASK OFF EXTRANEOUS CHARS
	IORM	A4,@W		; PUT REMAINING CHARS IN LISTING

	; MOVE REMAINDER OF ALGOL TEXT TO OUTPUT BUFFER WITH A BLT

	AOS	A5,W		; STEP WRITE POINTER AND LOAD IT
	HRLI	A5,1(A6)	; STEP OLD READ POINTER
	IMNZ	TBLEN		; IS INPUT LINE SPLIT OVER 2 BUFFERS?
	GOTO	SHIB		; -YES, TREAT SEPARATELY
	LI	A4,(A2)		; CURRENT READ POINTER ADDRESS
	SUBI	A4,1(A6)	; CURRENT LINE LENGTH
	ADDI	A4,@W		; END OF LINE IN WRITE BUFFER

NL14:	IAGEM	A4,OBEND	; WILL LINE OVERFLOW OUTPUT BUFFER?
	GOTO	SHOB2		; -YES, HANDLE WITH CARE
	IAGEI	A4,(A5)		; NEGATIVE LENGTH?

NL13:	BLT	A5,(A4)		; MOVE THE LINE
	HLL	A4,A2		; FORM NEW WRITE POINTER
	ST	A4,W		; SAVE IT

	; PRINT 2ND BATCH OF MESSAGES

NL10:	PUSHJ	S,GETNL		; STEP TO NEXT CHAR
	LI	A5,MTABLE	; ADDR OF MESSAGE TABLE
	IAGEM	A5,NAMTE	; IF NO MESSAGES IN TABLE
	GOTO	NL9		; THEN SKIP THIS PART
	SETOM	LMSGS		; SET LMSG SWITCH TO 2ND PASS
	PUSHJ	S,LMSG		; PRINT REST OF MSGS
	LI	A1,MTABLE	; START OF MESSAGE TABLE
	ST	A1,NAMTE	; SET POINTER TO START OF TABLE

	; PROCESS ANY FORM FEEDS

NL9:	LDB	A1,A2		; GET THE NEXT CHAR
	JUMPN	A1,.+3		; SKIP THIS IF NOT A NULL
	PUSHJ	S,GETNL		; READ THE NEXT CHAR
	JUMPE	A1,.-1		; READ ANOTHER IF IT IS A NULL
	SMBZ	A7,WITHIN	; WE ARE ABOUT TO EXIT THE NEWLINE ROUTINE
	IANI	A1,.FF		; IF IT IS NOT A FORM-FEED
	GOTO	NL11+1		; THEN SKIP THIS PART
	PUSHJ	S,FFOUND	; PROCESS THE FORM-FEED
	GOTO	NL9+2		; LOOK FOR ANOTHER FORM-FEED
	; SKIP OVER ANY NULLS AT BEGINNING OF NEXT LINE

NL11:	PUSHJ	S,GETNL		; READ NEXT CHAR
	JUMPE	A1,.-1		; READ AGAIN IF A NULL

	; PROCESS LINE NUMBER IF ANY

	IMBM	A7,ESWIT	; IF NUMBERS IN 73-80
	GOTO	COL73		; THEN SCAN THE LINE NUMBER
	L	A4,LINENO	; GET OLD LINE NUMBER
	ADDI	A4,1		; STEP IT 1
	L	A5,(A2)		; PICK UP FIRST WORD
	IMBZ	A5,1		; IS IT A LINE NUMBER?
	GOTO	NL8		; -NO, SKIP
	IAEI	A1,.SPACE	; IF LINE NUMBER IS BLANK
	GOTO	BLN		; THEN JUMP
	LI	A5,4		; SCAN NEXT 4 CHARS
	LI	A4,-.N0(A1)	; CONVERT 1ST CHAT TO DECIMAL

	PUSHJ	S,GETNL		; GET NEXT CHAR
	IMULI	A4,^D10		; MULTIPLY PREVIOUS RESULT BY 10
	ADDI	A4,-.N0(A1)	; ADD IN CURRENT CHAR
	SOJG	A5,.-3		; LOOP

	PUSHJ	S,GETNL		; SKIP OVER TAB
	SOS	CC		; DONT COUNT THIS AS A POSITION
	IAEI	A1,.FF		; IF IT IS A FORM-FEED
	PUSHJ	S,FFOUND	; THEN PROCESS IT
	IANI	A1,.TAB		; IF IT IS NOT A TAB
	GOTO	NOTAB		; THEN TREAT SEPARATELY

NL16:	PUSHJ	S,GETNL		; GET NEXT CHAR
	IANI	A1,.FF		; IF IT IS NOT A FORM-FEED
	GOTO	.+3		; THEN SKIP THIS PART
	PUSHJ	S,FFOUND	; PROCESS IT
	GOTO	NL16		; READ ANOTHER CHAR
	SMBO	A7,ELINE	; MARK: EDITOR LINE NUMBER SCANNED
	; SAVE ALL LINE POINTERS

NL8:	L	A5,CC		; GET POSITION COUNT
	EXCH	A4,LINENO	; SET NEW LINE NUMBER
	EXCH	A5,LP1		; SET START OF CURRENT LINE
	IMBMZ	A7,BLANKL	; IF THIS WAS A BLANK LINE
	GOTO	.+3		; THEN SKIP
	ST	A4,OLDNO	; SET OLD LINE NUMBER
	ST	A5,LP2		; SET START OF PRECEDING LINE

	; CHECK FOR A BLANK LINE

	L	A5,CTABLE(A1)	; GET CHARS TABLE ENTRY
	IAEI	A5,4		; IF IT IS A NEW LINE CHAR
	SMBO	A7,BLANKL	; THEN MARK THIS A BLANK LINE

	; EXIT FROM NEWLINE

	ST	A2,P		; SAVE READ POINTER
	ST	A7,RFLAGS	; STORE READ-MODULE FLAGS
	L	A7,A7SAV	; RESTORE A7
	AOS	(S)		; SKIP RETURN
	POPJ	S,		; EXIT NEWLIN
SUBTTL	** SUBROUTINES OF NEWLINE  **

	; BRIEF FORM OF LISTING FOR WHEN SENT TO TTY

NL15:	IMBM	A7,ELINE	; IF THERE IS AN EDITOR'S LINE NUMBER
	GOTO	NL7+1		; THEN JUMP
	IMBM	A7,ESWIT	; IF NUMBERS IN 73 - 80
	GOTO	NL7+1		; THEN DONT GENERATE ANOTHER ONE
	ADDI	A4,2		; END OF WHERE LINE PREFIX WILL GO
	IAGEM	A4,OBEND	; IF PAST END OF BUFFER
	PUSHJ	S,SHOB1		; THEN GET ANOTHER OUTPUT BUFFER
	L	A4,LINENO	; GET THE CURRENT LINE NUMBER
	LI	A2,.SPACE	; PRECEDE WITH A SPACE
	LI	A3,7		; FIELD IS 7 CHARS WIDE
	PUSHJ	S,DEC		; PUT LINE NUMBER IN LISTING
	LI	A3,0		; ASCII NULL
	IDPB	A3,W		; PUT AN ASCII NULL IN LISTING
	IDPB	A3,W		; PUT IN ANOTHER ONE
	GOTO	NL7		; CONTINUE



	; LISTING EXISTS BUT WAS OFF

NOLIST:	IMBZ	FL,LISTOO	; IF SO, IS IT CURRENTLY ON?
	GOTO	.+3		; -NO, CONTINUE WITH NO LISTING
	HRRI	A7,NORMAL	; TIME TO TURN LISTING BACK ON
	GOTO	TURNON		; CONTINUE AS ON

	; LISTING IS OFF

NLIST1:	L	A2,P		; LOAD READ POINTER
	IMBM	A7,ESWIT	; IF NUMBERS IN 73-80
	L	A2,LINEND	; GET TRUE READ POINTER
	ST	A2,P		; SAVE TRUE VALUE
	IAEM	A2,IBEND	; AT END OF INPUT BUFFER?
	GOTO	INEND		; -YES, GET A NEW INPUT BUFFER
	SMBO	A7,WITHIN	; WE ARE WITHIN THE NEWLINE ROUTINE
	ST	A2,LSTART	; SAVE POINTER FOR LATER
	ZERO	SSTART		; CLEAR SEGMENT START MARKER
	ZERO	TBLEN		; EMPTY OUT TMPBUF

	; PRINT 1ST BATCH OF MESSAGES

	LI	A5,MTABLE	; ADDR OF MESSAGE TABLE
	IAGEM	A5,NAMTE	; IF NO MESSAGES IN TABLE
	GOTO	NLIST2		; THEN SKIP THIS PART
	ZERO	LMSGS		; SET LMSG SWITCH TO 1ST PASS
	PUSHJ	S,LMSG		; PRINT MESSAGES
	; READ THE LF THAT FOLLOWS THE CR

NLIST2:	PUSHJ	S,GETNL		; GET NEXT CHAR
	L	A4,CTABLE(A1)	; GET TABLE ENTRY
	IANI	A4,4		; IT IS NORMALLY A LF
	GOTO	NL10+1		; -NO, CONTINUE WITHOUT STEPPING READ POINTER
	ST	A2,LSTART	; SAVE READ POINTER
	ST	A1,CHAR2	; SAVE THIS CHAR
	GOTO	NL10		; CONTINUE


	; TURN LISTING OFF

TURNOF:	HRRI	A7,NOLIST	; TURN LISTING OFF
	GOTO	NLIST1		; CONTINUE AS IF OFF



;	"GETNL" WILL READ THE NEXT CHARACTER OF THE SOURCE TEXT.  "GETNL" 
;	MUST BE USED WHENEVER A CHARACTER IS TO BE READ WITHIN "NEWLINE".
;	"GETNL" WILL CALL "INEND" IF AN END OF BUFFER OCCURRS.


GETNL:	ILDB	A1,A2		; GET NEXT CHAR
	AOS	CC		; STEP POSITION COUNT
	IANM	A2,IBEND	; UNLESS AT END OF INPUT BUFFER
	POPJ	S,		; EXIT GETNL
	ST	A2,P		; INEND WANTS POINTER SET
	PUSHJ	S,INEND		; READ NEXT INPUT BUFFER
	L	A7,RFLAGS	; RELOAD READ MODULE FLAGS
	L	A2,P		; RELOAD READ POINTER
	GOTO	GETNL+2		; TEST AGAIN
;	"INEND" IS CALLED WHENEVER THE END OF AN INPUT BUFFER IS REACHED.
;	"INEND" WILL MOVE THE 1ST PART OF THE SPLIT INPUT LINE TO "TMPBUF"
;	AND THEN CALL "READ" TO OBTAIN THE NEXT INPUT BUFFER.

INEND1:	ST	A2,NLR+4	; SAVE A2
	L	A2,A1		; MOVE READ POINTER TO A2
	ST	A7,A7SAV	; SAVE A7
	L	A7,RFLAGS	; GET READ MODULE FLAGS

INEND:	ST	A4,NLR		; SAVE A4
	ST	A5,NLR+1	; SAVE A5
	ST	A6,NLR+2	; SAVE A6
	ST	A3,NLR+3	; SAVE A3
	HRRZ	A6,A2		; GET READ POINTER
	IMEZ	A5,SSTART	; UNLESS LINE ALREADY BROKEN ONCE
	L	A5,LSTART	; GET START OF LINE SEGMENT
	SUBI	A6,(A5)		; LENGTH OF DATA TO MOVE
	LI	A4,TMPBUF-1(A6)	; END OF LINE IN TEMPBUF
	HRLZI	A5,(A5)		; MOVE SEGMENT FROM RING BUFFER
	HRRI	A5,TMPBUF	; TO TEMP BUFFER
	HRRM	A5,LSTART	; SET NEW VALUE FOR LSTART
	ADD	A4,TBLEN	; ADD TO WHAT IS IN TMPBUF
	ADD	A5,TBLEN	; ADD TO WHAT IS IN TMPBUF
	ADDM	A6,TBLEN	; ADDITIONAL LENGTH OF TMPBUF
	BLT	A5,(A4)		; MOVE LINE
	PUSHJ	S,READ		; READ NEXT BUFFER

INEND5:	L	A5,P		; GET NEW POINTER
	LI	A5,1(A5)	; ADD 1
	ST	A5,SSTART	; SAVE THIS ADDR
	ILDB	A1,P		; READ 1ST CHAR
	IAEI	A1,.CZ		; IF THIS IS A CONTROL-Z
	GOTO	INEND4		; THEN READ AGAIN
	L	A2,CTABLE(A1)	; GET THE CHARS TABLE ENTRY
	ST	A7,RFLAGS	; SAVE READ-MODULE FLAGS
	L	A7,A7SAV	; RESTORE A7
	GOTO	NLREST		; RESTORE REGISTERS, EXIT NEWLIN

INEND4:	PUSHJ	S,READ1		; CALL INEND BUT DONT PRINT A LINE NUMBER ON TTY
	GOTO	INEND5		; CONTINUE
;	IF THE SOURCE DEVICE IS A TTY, "READ" WILL SEND THE NEXT LINE NUMBER
;	TO THE TTY.  THEN "READ" WILL OBTAIN THE NEXT BUFFER FROM THE SOURCE
;	DEVICE, AND MARK THE END OF DATA IN IT WITH A WORD CONTAINING A
;	CR/LF.

READ:	IMBZ	A7,TTY		; IS SOURCE DEVICE A TTY?
	GOTO	READ1		; -NO, SKIP WRITING A LINE NUMBER
	IMBZ	A7,WITHIN	; IF WITHIN THE NEWLINE ROUTINE
	GOTO	READ1		; THEN PRINT NUMBER ELSE SKIP THIS PART
	L	A5,LINENO	; GET CURRENT LINE NUMBER
	LI	A4,1(A5)	; ADD 1
	PUSHJ	S,DECPNT	; PRINT IT INTO TTY BUFFER
	LI	A4,.SPACE	; LOAD A BLANK
	IDPB	A4,TTYLIN	; PUT THE BLANK IN BUFFER
	OUT	3,0		; GET NEXT OUTPUT BUFFER
	GOTO	READ1		; OK
	GOTO	READ1+4		; -ERROR ON WRITING LINE NUMBER

READ1:	IN	3,0		; INPUT NEXT BUFFER
	GOTO	INOK		; -SUCCESSFUL READ
	STATO	3,710000	; WAS IT A READ ERROR?
	GOTO	EOF		; -NO, JUST END OF FILE
	TTCALL	3,INERRM	; WRITE ERROR MSG
	GOTO	TERMIN		; TERMINATE COMP


INERRM:	ASCIZ	/?INPUT ERROR
/


	; INPUT BUFFER READ SUCCESSFULLY

INOK:	L	A6,BHEAD3	; ADDR OF CURRENT BUFFER
	HRRZ	A5,1(A6)	; LENGTH OF BUFFER IN WORDS
	JUMPE	A5,READ		; IF EMPTY GET ANOTHER BUFFER
	ADD	A5,P		; ADDR OF END OF BUFFER
	IMEZ	(A5)		; BACKUP OVER NULLS
	SOJA	A5,.-1
	L	A4,NLCHRS	; LOAD A CR/LF
	ST	A4,1(A5)	; PUT IT AT END OF BUFFER
	ADD	A5,[		; HOW POINTER WILL LOOK AT
	XWD	350000,1]	; END OF BUFFER
	ST	A5,IBEND	; STORE FOR LATER COMPARISON
	POPJ	S,		; EXIT INEND
	; END-OF-FILE ENCOUNTERED

EOF:	L	A4,BHEAD3	; LOCATE CURRENT BUFFER RING
	ST	A4,OLDSBR	; SAVE ITS ADDRESS
	CLOSE	3,0		; CLOSE SOURCE FILE
	IMLEZ	CSCOMP		; IF NO MORE SOURCE FILES
	GOTO	ENDPRG		; THEN RETURN EOF LEXEME

	SMBZ	A7,ESWIT	; TURN OFF 73-80 INDICATOR
	ZERO	CSCOMP		; CLEAR SWITCH
	PUSHJ	S,SCAN3		; SCAN NEXT SOURCE FILE AND OPEN IT
	GOTO	READ		; READ 1ST BUFFER




	; END OF SOURCE DATA (NO MORE SOURCE FILES)

ENDPRG:	HRRI	A7,ENDPRG	; LSCAN WILL READ NO MORE
	ST	A7,RFLAGS	; SAVE READ-MODULE FLAGS
	L	A7,A7SAV	; RESTORE A7
	L	A4,[		; SET UP A POINTER TO
	POINT	7,NLCHRS]	; A NEW-LINE CHAR
	ST	A4,P		; PUT IN READ POINTER
	L	A3,ZEOF		; OUTPUT END-OF-FILE LEXEME
	L	A2,P		; LOAD POINTER (FOR ERR MSG UP-ARROW)

	; RETURN TO CALLER OF LSCAN

EOF5:	POP	S,A4		; GET RETURN LINK
	LI	A4,(A4)		; CLEAR LEFT HALF
	IAEI	A4,EMPTY
	GOTO	EMPTY1		; NULL FILE
	IANI	A4,RUND0
	IAEI	A4,RUND5	; IF IT IS ONE OF THESE
	GOTO	(A4)		; THEN GO THERE
	GOTO	EOF5		;  ELSE ASCEND ANOTHER LEVEL

NLCHRS:	ASCIZ	/
/

	LEX(EOF)

	; NO ROOM IN OUTPUT BUFFER FOR LINE PREFIX

SHOB1:	HLRZ	A5,W		; GET OLD S-P BITS
	PUSHJ	S,WRITEL	; GET NEXT BUFFER
	AOS	A4,W		; STEP WRITE POINTER, LOAD IT
	ZERO	(A4)		; ZERO 1ST WORD OF LINE IN BUFFER
	ZERO	5(A4)		; ZERO 5TH WORD OF LINE IN BUFFER
	HRLM	A5,W		; SET NEW WRITE POINTER
	POPJ	S,		; CONTINUE



	; NO ROOM IN OUTPUT BUFFER FOR THE ALGOL TEXT

SHOB2:	LI	A6,010700	; NEW S-P BITS FOR W
	HRLM	A6,W		; SET THEM
	SOS	W		; NEW ADDR FOR W
	SUBI	A4,-1(A5)	; A4=LENGTH OF FIRST PART
	PUSHJ	S,WRITEL	; GET NEXT OUTPUT BUFFER
	ADDI	A4,@W		; STOP ADDR FOR BLT
	AOS	W		; STEP WRITE POINTER
	HRR	A5,W		; LOAD THE ADDR PORTION OF W
	GOTO	NL13		; CONTINUE



	; INPUT LINE WAS SPLIT OVER 2 INPUT BUFFERS

SHIB:	SOS	A4,TBLEN	; A4=LENGTH OF FIRST PART
	ADDI	A4,@W		; STOP ADDR FOR BLT
	IALM	A4,OBEND	; WILL THIS OVERFLOW BUFFER?
	GOTO	SHIB1		; -NO, SKIP

	; 1ST PART OF INPUT LINE WILL NOT FIT IN OUTPUT BUFFER

	PUSH	S,A6		; SAVE ACC A6
	LI	A6,010700	; NEW S-P BITS FOR W
	HRLM	A6,W		; PUT THEM THERE
	SOS	W		; NEW ADDR FOR W
	PUSHJ	S,WRITEL	; GET NEXT OUTPUT BUFFER
	POP	S,A6		; RESTORE ACC A6
	AOS	A4,W		; GET NEW WRITE POINTER
	HRR	A5,A4		; SET NEW TO-ADDRESS
	ADD	A4,TBLEN	; STOP ADDR FOR BLT
	LI	A4,(A4)		; ZERO LEFT HALF
SHIB1:	IALEI	A4,(A5)		; SKIP BLT IF LENGTH NEGATIVE
	GOTO	.+3		; -YES, SKIP
	L	A3,A5		; MOVE TO ACC A3
	BLT	A3,-1(A4)	; MOVE 1ST PART OF LINE
	ST	A4,W		; SET W JUST IN CASE SHOB2 IS CALLED
	LI	A5,(A4)		; WHERE 2ND PART WILL START
	HRL	A5,SSTART	; WHERE 2ND PART NOW SITS
	ADDI	A4,(A2)		; ADD CURRENT POINTER ADDR
	SUB	A4,SSTART	; STOP ADDR FOR BLT
	ZERO	TBLEN		; ZERO TBLEN
	ZERO	SSTART		; CLEAR SSTART
	GOTO	NL14		; CONTINUE



	; WRITE INPUT LINE NUMBER TO TTY

DECPNT:	IDIVI	A4,12		; DIVIDE BY 10
	PUSH	S,A5		; PUSH REM ONTO SSACK
	IMNZ	A4		; SKIP IF NUMBER ZERO
	PUSHJ	S,DECPNT	; RECURSIVELY CALL DECPNT
	POP	S,A4		; FETCH 1 NUMBER FROM STACK
	LI	A4,60(A4)	; CONVERT TO ASCII
	IDPB	A4,TTYLIN	; PUT INTO OUTPUT BUFFER
	POPJ	S,		; RETURN



FFOUND:	LI	A1,0		; ASCII NULL
	DPB	A1,A2		; DELETE FORM FEED FROM INPUT BUFFER
	AOS	FFCNT		; STEP FORM FEED COUNNT
	AOS	FFCNT2		; STEP OTHER FORM FEED COUNT
	POPJ	S,		; EXIT FFOUND



	; PUT FORM-FEED IN FRONT OF LINE

INSFF:	LI	A1,FORM		; ADDRESS OF A FORM-FEED
	PUSHJ	S,INSERT	; PUT IT IN LISTING
	PUSHJ	S,IC2		; CALL ICHECK (BUT DONT WRITE A CR/LF)
	SOSLE	FFCNT2		; IF MORE FORM-FEEDS TO INSERT, THEN
	GOTO	INSFF		; LOOP
	POPJ	S,		; ELSE EXIT INSFF
	; LINE NUMBER NOT FOLLOWED BY A TAB

NOTAB:	IAEI	A1,.CR		; IF IT IS A CARRIAGE RETURN
	GOTO	.+4		; THEN SKIP THIS PART
	LI	A1,.TAB		; AN ASCII TAB CHARACTER
	DPB	A1,A2		; REPLACE THE CHARACTER WITH A TAB
	GOTO	NL16		; CONTINUE
	PUSHJ	S,GETNL		; READ THE NEXT CHARACTER
	IAEI	A1,.CR		; IF IT IS A CARRIAGE RETURN
	GOTO	NL8-1		; THEN IT IS PROBABLY THE SEQUENCE: CR CR LF
	LI	A1,.LF		; LINE-FEED
	DPB	A1,A2		; REPLACE THE CR WITH A LF
	AOS	FFCNT		; STEP FORM-FEED COUNT
	AOS	FFCNT2		; STEP FORM-FEED COUNT
	GOTO	NL8-1		; CONTINUE



	; BLANK LINE NUMBER ENCOUNTERED

BLN:	LI	A5,7		; SKIP OVER 7 CHARACTERS
	LI	A6,0		; ASCII NULL
	DPB	A6,A2		; REPLACE CHARACTER WITH A NULL
	PUSHJ	S,GETNL		; READ A CHARACTER
	SOJG	A5,.-2		; LOOP
	PUSHJ	S,FFOUND	; NULL OUT THE FORM-FEED
	GOTO	NL11		; CONTINUE



NLREST:	L	A4,NLR		; RESTORE A4
	L	A5,NLR+1	; RESTORE A5
	L	A6,NLR+2	; RESTORE A6
	L	A3,NLR+3	; RESTORE A3
	L	A2,NLR+4	; RESTORE A2
	POPJ	S,		; EXIT NLREST
	RELOC

IBEND:	0			; END OF INPUT BUFFER
OBEND:	0			; END OF OUTPUT BUFFER
BNUM:	0			; BEGIN NUMBER
LBNUM:	0			; LAST BEGIN NUMBER
ENUM:	0			; END NUMBER
LENUM:	0			; LAST END NUMBER
LINEND:	0			; READ POINTER AT END OF CURRENT LINE
LINE5:	0			; 5 -CHAR DATASET LINE NUMBER
LSTART:	0			; START OF CURRENT LINE
SSTART:	0			; START OF CURRENT LINE SEGMANT
CHAR:	0			; SAVE CHAR FROM 80-COLUMN LINE
CHARP:	0			; SAVED CHARACTER'S RESTORATION POINTER
TBLEN:	0			; LENGTH OF DATA IN TMPBUF
A7SAV:	0			; SAVE AREA FOR A7
NLR:	BLOCK	5		; SAVE AREA FOR REGISTERS OVER NEWLIN
TMPBUF:	BLOCK	50		; SAVED 1ST PART OF SPLIT SOURCE LINE

BUF0:	0
	XWD	5,BUF0+1
	BLOCK	5

	RELOC
;	THE "COL73" ROUTINE WAS CONTRIVED AFTER THE REST OF "NEWLINE" WAS
;	WRITTEN.  "NEWLINE" HAS THE CONVENTION THAT THE LINE NUMBER MUST BE
;	KNOWN BEFORE THE LINE IS SCANNED.  "COL73" WILL CAUSE THE WHOLE
;	LINE TO BE "UNOFFICIALLY" MOVED INTO "TMPBUF" BEFORE SCANNING ANY OF
;	IT SO THAT THE LINE NUMBER CAN FIRST BE SCANNED.  HOWEVER, IF PART
;	OF THE LINE WAS MOVED THERE BY "INEND", ONLY THE LAST PART OF THE LINE
;	IS "UNOFFICIAL".  BY "UNOFFICIAL" IT IS MEANT THAT THE TEXT IS
;	NOT REALLY THERE (NOT INCLUDED IN "TBLEN", WHICH IS THE COUNT
;	OF DATA WORDS IN "TMPBUF"), AND THE LISTING WILL BE TAKEN FROM
;	TEXT IN THE SOURCE BUFFER RATHER THAN FROM "TMPBUF".  HOWEVER
;	THE SOURCE BYTE POINTER WILL POINT INTO "TMPBUF".  THE 1ST CHARACTER
;	OF THE LINE NUMBER IS EXTRACTED AND REPLACED WITH A CR SO THAT
;	THE SCANNER WILL NOT RUN INTO THE LINE NUMBER.


	; FORM READ POINTER TO TMPBUF

COL73:	L	A3,A2		; COPY READ POINTER
	HRRI	A3,TMPBUF	; POINT IT TO TMPBUF
	ADD	A3,TBLEN	; IN CASE SOMETHING ALREADY IN TMPBUF
	LI	A5,^D16		; PUT NEXT 17 WORDS IN TMPBUF

COL73A:	ADDI	A5,(A2)		; END OF SOURCE IN RING BUFFER
	L	A6,IBEND	; END OF RING BUFFER
	IALI	A5,(A6)		; IF THE LINE IS ENTIRELY WITHIN RING BUFFER
	GOTO	COL73B		; THEN SKIP THIS PART

	; USE INEND TO PUT PART OF LINE IN TMPBUF

	L	A2,LSTART	; GET LINE START
	IMEZ	SSTART		; SKIP IF TMPBUF NOT EMPTY
	IMBM	A2,760000+LEFT	; IF BYTE POINTER NOT AT END OF WORD
	GOTO	.+2		; THEN SKIP THIS PART
	ADDI	A3,1		; THEN IGNORE 1ST WORD OF TMPBUF
	SUBI	A5,(A6)		; EXCESS LENGTH - 1
	ST	A6,P		; SET P
	L	A2,A6		; COPY TO A2
	PUSHJ	S,INEND		; GET NEXT INPUT BUFFER
	L	A7,RFLAGS	; RE-FETCH READ MODULE FLAGS
	L	A2,P		; RELOAD POINTER
	GOTO	COL73A		; MOVE REMAINDER TO TMPBUF
	; MOVE REMAINDER OF LINE TO TMPBUF "UNOFFICIALLY"

COL73B:	ST	A5,LINEND	; SAVE END OF TEXT IN RING BUFFER
	HRLZ	A6,A2		; "FROM" ADDRESS
	HRRI	A6,TMPBUF	; "TO" ADDRESS
	ADD	A6,TBLEN	; IN CASE TMPBUF NOT EMPTY
	SUBI	A5,(A2)		; LENGTH OF MOVE - 1
	JUMPL	A5,.+2		; SKIP IF NOTHING TO MOVE
	ADDI	A5,(A6)		; "STOP" ADDRESS
	BLT	A6,(A5)		; MOVE TEXT TO TMPBUF

	; REPLACE 1ST DIGIT OF LINE NUMBER WITH A CR

	L	A2,A3		; A2 = NEW READ POINTER
	IBP	A3		; STEP TO COLUMN 2
	IBP	A3		; STEP TO COLUMN 3
	ADDI	A3,^D14		; STEP TO COLUMN 73
	LDB	A4,A3		; GET THE CHARACTER THAT IS THERE
	ST	A4,CHAR		; SAVE IT FOR LATER
	LI	A6,.CR		; ASCII CARRIAGE RETURN CHARACTER
	DPB	A6,A3		; PUT IN PLACE OF OTHER CHARACTER
	ST	A3,CHARP	; SAVE POINTER TO THIS CHARACTER
	SUBI	A4,.N0		; CONVERT FROM ASCII TO BINARY
	LI	A6,7		; READ 7 MORE CHARACTERS

	; SCAN LINE NUMBER

COL73C:	ILDB	A5,A3		; READ NEXT CHAR
	IAEI	A5,.SPACE	; IF IT IS A BLANK
	GOTO	.+3		; THEN IGNORE IT
	IMULI	A4,^D10		; MULT PREVIOUS RESULT BY 10
	ADDI	A4,-.N0(A5)	; ADD IN CURRENT DIGIT
	SOJG	A6,COL73C	; LOOP
	; FROM TRUE LINE POINTER TO SOURCE BUFFER RING

	HRR	A3,LINEND	; GET POINTER TO TEXT IN RING BUFFER
	IMBZ	A3,760000+LEFT	; STEP POINTER, BUT NOT TO NEXT WORD
	SUBI	A3,1		; TRUE POINTER
	IBP	A3		; THE NEXT CHARACTER TO BE READ FROM THE RING BUFFER
	ST	A3,LINEND	; SAVE THIS POINTER
	LDB	A1,A2		; READ THE NEXT CHARACTER
	GOTO	NL8		; CONTINUE
SUBTTL	**  ERROR HANDLING ROUTINES  **

;   ERROR MESSAGES
;
;	ERROR MESSAGES ARE NOT PRINTED IMMEDIATELY AS THE ERRORS ARE
;	DETECTED.  IF THEY WERE THEN, SINCE THE ALGOL TEXT IS NOT MOVED TO
;	THE LISTING UNTIL AFTER THE LINE HAS BEEN SCANNED (FOR EFFICIENCY)
;	USUALLY THE ERROR CODE WOULD APPEAR BELOW THE ERROR MESSAGE, AND
;	OTHER TIMES THE ERROR CODE WOULD APPEAR ABOVE THE ERROR MESSAGE
;	BECAUSE THE SCANNER IS USUALLY PROCESSING AHEAD OF THE SYNTAX
;	ANALYZERS.  TO COMBAT THIS,  MESSAGES ARE BUFFERED IN A MESSAGE TABLE.
;	THEN, WHEN THE SCANNER REACHES THE END OF A LINE, "NEWLINE" WILL
;	1.) PRINT ALL MESSAGES THAT PERTAIN TO THE PRECEDING LINE OF
;	TEXT, 2.) PRINT THE CURRENT LINE OF TEXT, AND 3.) PRINT ALL MESSAGES
;	THAT PERTAIN TO THE CURRENT LINE OF TEXT.
;
;	EACH TIME THE SCANNER READ A CHARACTER WITH AN "ILDB" IT STEPS
;	"CC" WITH AN "AOS".  FOR EACH ITEM SCANNED "RUND" WILL STORE "CC"
;	IN THE CORRECT WORD OF "PLIST".  "PLIST" HAS 4 WORDS, ONE FOR EACH
;	PORT OF THE WINDOW.  "LP1" AND "LP2" CONTAIN THE CHARACTER NUMBERS
;	THAT BEGAN THE CURRENT AND PREVIOUS LINES OF TEXT, RESPECTIVELY.
;	USING ALL OF THE ABOVE, THE MESSAGE ROUTINE CAN TELL EXACTLY
;	WHERE TO PRINT THE UP-ARROW.
;
;	THE MESSAGE ROUTINE USUALLY PRINTS THE UP ARROW 1 POSITION
;	TO THE LEFT OF WHERE IT HAS CALCULATED THAT THE UP-ARROW SHOULD GO.
;	(THIS IS USUALLY A MORE CORRECT PLACE TO PUT IT.)  BUT THIS CAN
;	BE PREVENTED BY STORING THE CHARACTER COUNT WORD WITH BIT ZERO
;	SET TO ONE.
;	".FAILED" IS CALLED BY THE ".FAIL" ROUTINE WITH A1 CONTAINING
;	THE FOLLOWING PARAMETER:
;
;
;
;   +----------------------------------------------------------------+
;   !      ! !    !                 !                                !
;   !      !F!    !      FLAGS      !        MESSAGE NUMBER          !
;   !      ! !    !                 !                                !
;   +----------------------------------------------------------------+
;           4      8              17 18                            35
;
;   BIT 4:	UP-ARROW GOES UNDER READ BYTE POINTER, DONT SHIFT LEFT 1
;   BITS 8-9:	(OF NO CONCERN TO THIS MODULE)
;   BIT 10:	FATAL ERROR. HALT IMMEDIATELY
;   BIT 11:	"ILLEGAL USE OF" TYPE MESSAGE
;   BIT 12:	DELETE REL-FILE
;   BIT 13:	(OF NO CONCERN TO THIS MODULE)
;   BIT 14:	UP-ARROW GOES UNDER SYM
;   BIT 15:	UP-ARROW GOES UNDER DEL
;   BIT 16:	UP-ARROW GOES UNDER NSYM
;   BIT 17:	UP-ARROW GOES UNDER NDEL
;   BITS 18-35:	MESSAGE NUMBER
;	FROM THE ABOVE PARAMETER ".FAILED" WILL COMPUTE A MESSAGE TABLE
;	ENTRY AND INSERT IT INTO THE MESSAGE TABLE.  THE FORMAT OF A MESSAGE
;	TABLE ENTRY IS:
;
;
;
;   +-----------------------------------------------------------------+
;   !               !      !         !                                !
;   !  BYTE COUNT   !FLAGS !KIND/TYPE!       MESSAGE NUMBER           !
;   !               !      !         !                                !
;   +-----------------------------------------------------------------+
;    0             7 8   11 12     17 18                            35
;
;   BITS 0-7:	POSITION OF ARROW ON PRINT PAGE
;   BIT 8:	ERROR ON THE PRECEDING LINE
;   BIT 9:	ERROR ON SOME PREVIOUS LINE
;   BIT 10:	"ILLEGAL USE OF" TYPE MESSAGE
;   BIT 11:	DELETE REL-FILE
;   BITS 12-17:	KIND AND TYPE EXTRACTED FROM LEXEME IN SYM
;   BITS 18-35:	MESSAGE NUMBER
;	THE MESSAGES "START OF BLOCK N" AND "END BLOCK N, CONT M" ARE
;	ALSO BUFFERED IN THE MESSAGE TABLE.  ENTRIES FOR THESE HAVE THE
;	FOLLOWING FORMAT, WHICH IS DISTINGUISHED FROM THE OTHERS BY HAVING
;	A POSITION COUNT OF 377.
;
;
;
;   +-----------------------------------------------------------------+
;   !               !   !                      !                      !
;   !      377      !   !       VALUE 1        !       VALUE 2        !
;   !               !   !                      !                      !
;   +-----------------------------------------------------------------+
;    0             7 8 9 10                  22 23                  35
;
;
;   BITS 0-7:	377
;   BIT 8:	MESSAGE ON THE PRECEDING OR SOME PREVIOUS LINE
;   BIT 9:	MUST BE ZERO
;   BITS 10-22:	VALUE 1
;   BITS 23-35:	VALUE 2
;
;	IF VALUE2 = 0 THEN PRINT "START OF BLOCK (VALUE1)"
;	ELSE PRINT "END BLOCK (VALUE2), CONT (VALUE1)";
	..PREC=1000+LEFT	; ERROR ON PRECEDING LINE
	..PREV=400+LEFT		; ERROR ON SOME PREVIOUS LINE
	..IUO1=200+LEFT		; "ILLEGAL USE OF" FORM
	..TERM=100+LEFT		; "REL FILE DELETED"



;	".FAIL", ".BLK1", AND ".BLK2" PUT ENTRIES IN THE MESSAGE TABLE,
;	"LMSG" TAKES THEM OUT AND PRINTS THEM.


LMSG1:	AOJA	A5,.+2		; STEP TO NEXT TABLE ENTRY

LMSG:	PUSH	S,A2		; SAVE A2
	IAGEM	A5,NAMTE	; END OF MESSAGES?
	GOTO	LMSGE		; -YES, DONE
	L	A2,(A5)		; GET ENTRY CONTENTS
	L	A4,LMSGS	; LOAD THE SWITCH
	IMBZ	A2,..PREC+..PREV-LEFT; IF EITHER BIT IS SET
	SETCMM	A4		; THEN THIS MESSAGE SHOULD BE PRINTED
	JUMPN	A4,LMSG1	; ONLY ON THE 1ST PASS THROUGH LMSG

	; CHECK FOR "START BLOCK" ADN "END BLOCK" ENTRIES

	LSH	A2,-^D28	; COLUMN POINTER
	IAEI	A2,377		; IF BYTES=255 THEN IT IS
	GOTO	BLK1A		; A BLOCK BEGIN OR END LINE
	AOS	.JBERR		; ADD 1 TO ERROR TOTAL
	; WRITE: "******   ^"

	LI	A1,STAR3	; "*******"
	PUSHJ	S,INSERT	; SEND TO LISTING
	L	A2,(A5)		; GET MESSAGE TABLE ENTRY
	IMBM	A2,..PREV	; IF ERROR OCCURRED ON A PREVIOUS LINE
	GOTO	LMSG3		; THEN HANDLE SEPARATELY
	LSH	A2,-^D28	; GET ARROW POSITION
	JUMPE	A2,LMSG2	; NO ^ IF ZERO
	IMBZ	A7,LTTY		; UNLESS THE LISTING IS GOING TO THE TTY
	ADDI	A2,^D16		; PUT 16 MORE BLANKS AT START OF LINE
	L	A6,LBP		; LOAD BYTE POINTER TO BUFFER
	LI	A4,.SPACE	; SPACE CHARACTER
	IDPB	A4,A6		; PUT SPACE IN LINE
	SOJG	A2,.-1		; LOOP
	LI	A4,136		; "^"
	IDPB	A4,A6		; PUT ^ INTO LINE
	IDPB	A2,A6		; PUT NULL AT END OF LINE
	LI	A1,LB		; ADDR OF LINE

LMSG4:	PUSHJ	S,INSERT	; INSERT LINE IN LISTING

LMSG2:	PUSHJ	S,ICHECK	; INCLUDE CR/LF
	PUSHJ	S,NPRINT	; PUT ERROR LINE NUMBER IN LISTING

	IFN	MTEXT,<

	; WRITE ERROR MESSAGE TO LISTING

	JSP	A6,LMSG0	; GET ERROR MESSAGE
	HLL	A1,(A5)		; GET FLAGS
	IMBZ	A1,777777	; IF NO ENTRY THEN
	LI	A1,[		; USE A
	ASCIZ	//]		; LITERAL NULL STRING
	IMBM	A1,..IUO1	; IF "ILLEGAL USE OF"
	PUSHJ	S,IUO		; THEN HANDLE SEPARATELY
	PUSHJ	S,INSE		; PUT MESSAGE IN LISTING
>
	IFE	MTEXT,<

	; WRITE ERROR NUMBER TO LISTING

	LI	A1,STAR1	; "*** ERR "
	HRRZ	A3,(A5)		; GET THE MESSAGE NUMBER
	IAEI	A3,^D98		; IF IT IS MESSAGE 98
	LI	A1,STAR4	; THEN PRINT "** NOTE " INSTEAD
	PUSHJ	S,INSE		; WRITE TO LISTING AND TTY
	HRRZ	A1,(A5)		; GET ERROR NUMBER
	PUSHJ	S,LPRINT	; CONVERT NUMBER TO ASCII
	PUSHJ	S,INSE		; WRITE TO LISTING AND TTY
	LI	A1,STAR2	; "***"
	PUSHJ	S,INSERT	; WRITE ONLY TO LISTING
>
	PUSHJ	S,KCHECK	; PUT CR/LF IN MESSAGE

	; CHECK FOR FATAL ERROR

	L	A4,(A5)		; GET MESSAGE TABLE ENTRY
	IMBZ	A7,TMG		; IF TERM MSG NOT PREV GIVEN THEN
	IMBZ	A4,..TERM	; IF OBJECT CODE NOT TERMINATED
	GOTO	LMSG1		; THEN LOOP
	SETOM	WFLAG		; MARK REL FILE TO BE ERASED
	LI	A1,TERMC	; ADDR OF TERMINATION MESSAGE
	PUSHJ	S,INS		; "REL-FILE DELETED"
	PUSHJ	S,TCHECK	; CR/LF
	SMBO	A7,TMG		; MARK MESSAGE GIVEN
	GOTO	LMSG1		; LOOP


TERMC:	ASCIZ	/REL FILE DELETED/
STAR3:	ASCIZ	/*******/
SPACE2:	ASCIZ	/  /

	IFN EXPER, <
STAR1:	ASCIZ	/*** ERR /
STAR2:	ASCIZ	/ ***/
STAR4:	ASCIZ	/** NOTE />
	; "NPRINT" WILL PRINT THE LINE NUMBER OF THE ERROR

NPRINT:	L	A1,LINENO	; GET LINE NUMBER
	IMEZ	LMSGS		; IF MESSAGE FOR PREVIOUS LINE
	L	A1,OLDNO	; THEN GET OLD LINE NUMBER
	PUSHJ	S,LPRINT	; CONVERT IT TO ASCII
	PUSHJ	S,INSE		; WRITE LINE NUMBER TO LISTING AND TTY
	LI	A1,SPACE2	; WRITE 2 SPACES
	GOTO	INSE		; SEND TO LISTING AND TTY, EXIT NPRINT




	; ERROR IS NEITHER ON CURRENT NOR PRECEDING LINE

LMSG3:	LI	A1,Y19		; "ERROR ON A PREVIOUS LINE"
	GOTO	LMSG4		; CONTINUE

	; EXIT LMSG

LMSGE:	POP	S,A2		; RESTORE A2
	POPJ	S,		; EXIT LMSG


;	AN "IUO" MESSAGE IS A MESSAGE OF THE FORM "XXX YYY FOUND WHERE A 
;	ZZZ WAS EXPECTED".  THE ERROR MESSAGE NUMBER SPECIFIES ONLY THE
;	TEXT OF ZZZ.  XXX AND YYY ARE THE TYPE AND KIND OF WHAT WAS
;	FOUND, AND THE TEXT OF THESE MUST BE DETERMINED BY DECODING THE
;	LEXEME IN SYM.


	IFN	MTEXT,<
IUO:	LI	A1,Y1		; "ILLEGAL USE OF "
	PUSHJ	S,INS		; PUT IN LISTING
	LDB	A1,[		; GET "TYPE" OF ITEM
	POINT	3,(A5),14]	; POINTER TO TYPE FIELD IN ENTRY
	IAEI	A1,4		; IF IT IS A LABEL
	GOTO	IUOLAB		; THEN HANDLE SEPARATELY
	L	A1,IUOMT1(A1)	; GET NAME
	PUSHJ	S,INS		; PUT IN LISTING
	LDB	A1,[		; GET "KIND" OF ITEM
	POINT	3,(A5),17]	; POINTER TO KIND FIELD IN ENTRY
	L	A1,IUOMT2(A1)	; GET NAME
IUO1:	PUSHJ	S,INS		; PUT IN LISTING
	LI	A1,Y2		; " WHERE A "
	PUSHJ	S,INS		; PUT IN LISTING
	JSP	A6,LMSG0	; GET MESSAGE
	PUSHJ	S,INS		; PUT IN LISTING
	LI	A1,Y3		; " WAS EXPECTED"
	POPJ	S,		; EXIT IUO

IUOLAB:	LDB	A1,[		; GET "KIND" OF ITEM
	POINT	3,(A5),17]	; POINTER TO KIND FIELD
	L	A1,IUOMT3(A1)	; GET PROPER NAME
	GOTO	IUO1		; CONTINUE
>

LMSG0:	HRRZ	A1,(A5)		; GET MESSAGE #
	ROT	A1,-1
	JUMPL	A1,.+3
	HLRZ	A1,TTABLE(A1)
	GOTO	(A6)
	HRRZ	A1,TTABLE(A1)
	GOTO	(A6)
	; BLOCK START OR END

BLK1A:	IMBM	A7,LTTY		; IF LISTING IS ON TTY
	GOTO	LMSG1		; THEN DONT WRITE BLOCK BEGIN OR END MSG
	L	A4,(A5)		; RELOAD PARAM WORD
	IMBM	A4,17777	; IF RIGHT-MOST 13 BITS NOT ZERO
	GOTO	BLK2A		; THEN THIS IS AN END MESSAGE

	; "START OF BLOCK N"

	LI	A1,BLK1M	; "START OF BLOCK "

BLKC:	PUSHJ	S,INSERT	; PUT IN LISTING
	LDB	A1,[		; GET THE NUMBER STORED IN
	POINT	13,(A5),22]	; BITS 10-22
	PUSHJ	S,LPRINT	; CONVERT TO DECIMAL ASCII
	PUSHJ	S,INSERT	; PUT NUMBER IN LISTING
	PUSHJ	S,ICHECK	; CR/LF
	GOTO	LMSG1		; LOOP


	; "END OF BLOCK N, CONT M"

BLK2A:	LI	A1,BLK2M1	; "END BLOCK "
	PUSHJ	S,INSERT	; PUT IN LISTING
	LDB	A1,[		; GET THE NUMBER STORED IN
	POINT	13,(A5),35]	; BITS 23-35
	PUSHJ	S,LPRINT	; CONVERT TO DECIMAL ASCII
	PUSHJ	S,INSERT	; PUT NUMBER IN LISTING
	LI	A1,BLK2M2	; ", CONT "
	GOTO	BLKC		; CONTINUE

BLK1M:	ASCIZ	/START OF BLOCK /
BLK2M1:	ASCIZ	/END BLOCK /
BLK2M2:	ASCIZ	/, CONT /
;	"LMSGZ" IS CALLED AT THE END OF THE COMPILATION BY ".ZZEND".  "LMSGZ"
;	WILL PRINT ALL MESSAGES THAT REMAIN IN THE MESSAGE TABLE THAT
;	HAVE NOT YET BEEN PRINTED.

LMSGZ:	ST	A7,A7SAV	; SAVE A7
	L	A7,RFLAGS	; FETCH THE READ MODULE FLAGS
	PUSHJ	S,ICHECK	; PUT A BLANK LINE INTO LISTING
	LI	A5,MTABLE	; ADDR OF MESSAGE TABLE
	IAGEM	A5,NAMTE	; IF NO MESSAGES IN MESSAGE TABLE
	POPJ	S,		; THEN EXIT LMSGZ
	ZERO	LMSGS		; DUMP 1ST GROUP OF MESSAGES
	PUSHJ	S,LMSG		; PRINT MESSAGES
	LI	A5,MTABLE	; ADDR OF MESSAGE TABLE
	SETOM	LMSGS		; DUMP 2ND GROUP OF MESSSAGES
	PUSHJ	S,LMSG		; PUT THEM IN LISTING
	LI	A1,LINES3	; PUT 3 BLANK LINES
	PUSHJ	S,INSERT	; IN LISTING
	GOTO	ICHECK		; INSERT A CR/LF, EXIT LMSGZ



LBP:	XWD	440700,LB	; LISTING BUFFER POINTER

	RELOC

MTABLE:	BLOCK	50		; MESSAGE TABLE
NAMTE:	MTABLE			; NEXT AVAIL MESSAGE TABLE ENTRY
LMSGS:	0			; LMSG SWITCH
LB:	BLOCK	40		; LISTING BUFFER FOR MESSAGES
OLDNO:	0			; OLD LINE NUMBER
	RELOC

	IFN	MTEXT,<
Y1:	ASCIZ	//
Y2:	ASCIZ	/ FOUND WHERE A/
Y3:	ASCIZ	/ WAS EXPECTED/
Y4:	ASCIZ	/STRING/
Y5:	ASCIZ	/COMPLEX/
Y6:	ASCIZ	/TYPELESS/
Y7:	ASCIZ	/BOOLEAN/
Y8:	ASCIZ	/LONG REAL/
Y9:	ASCIZ	/REAL/
Y10:	ASCIZ	/INTEGER/
Y11:	ASCIZ	/ VARIABLE/
Y12:	ASCIZ	/ EXPRESSION/
Y13:	ASCIZ	/ ARRAY IDENTIFIER/
Y14:	ASCIZ	/ PROCEDURE/
Y15:	ASCIZ	/ CONSTANT/
Y16:	ASCIZ	/LABEL/
Y17:	ASCIZ	/DESIGNATIONAL EXPRESSION/
Y18:	ASCIZ	/SWITCH/
IUOMT1:	Y4
	Y5
	Y6
	Y7
	0
	Y8
	Y9
	Y10

IUOMT2:	Y11
	Y12
	Y13
	Y14
	Y15

IUOMT3:	Y16
	Y17
	0
	Y18
>


Y19:	ASCIZ	/ ERROR ON A PREVIOUS LINE:/
;	THE INSERT ROUTINES ("INSERT", "INS", AND "INSE") ARE USED TO INSERT
;	MESSAGES INTO THE LISTING.  THE CHECK ROUTINES ("ICHECK", "TCHECK",
;	AND "KCHECK") WILL INSERT A CR/LF INTO THE LISTING, AND THEN
;	INSERT NULLS INTO THE LISTING SO THAT THE TOTAL NUMBER OF CHARACTERS
;	INSERTED SINCE THE LAST CHECK ROUTINE WAS CALLED IS A MULTIPLE OF 5.
;	WHENEVER AN INSERT ROUTINE IS USED, A CHECK ROUTINE MUST BE CALLED
;	BEFORE THE NEXT CALL TO NEWLINE.
;
;	"INSERT" AND "ICHECK" WRITE MESSAGES IN THE LISTING.  "INS" AND
;	"TCHECK" ALSO WRITE THE MESSAGE TO THE TTY.  "INSE" AND "KCHECK"
;	ARE USED TO WRITE MESSAGES WHEN MESSAGE 98 MIGHT BE ENCOUNTERED.


INSE:	HRRZ	A3,(A5)		; GET MESSAGE NUMBER
	IAEI	A3,^D98		; IF THIS IS MESSAGE 98
	GOTO	INSERT		; THEN DONT WRITE TO TTY


	; INSERT LINE IN LISTING, AND ALSO WRITE IT TO TTY

INS:	IMBZ	A7,NSWIT	; IF NO N-SWITCH
	TTCALL	3,(A1)		; THEN WRITE IT TO TTY
	GOTO	INSERT		; INSERT LINE IN LISTING


	; PUT DECIMAL NUMBER IN LISTING

LPRINT:	L	A6,LBP		; GET BUFFER BYTE POINTER
	PUSHJ	S,LPR1		; CONVERT IT TO CHARACTERS
	LI	A1,0		; ASCII NULL
	IDPB	A1,A6		; END STRING WITH AN ASCII NULL
	LI	A1,LB		; OUTPUT ADDRESS OF BUFFER
	POPJ	S,		; EXIT LPRINT


	; CONVERT IT TO DECIMAL

LPR1:	IDIVI	A1,12		; DIVIDE BY TEN
	PUSH	S,A2		; PUT DIGIT ON STACK
	IMNZ	A1		; SKIP IF END OF NUMBER
	PUSHJ	S,LPR1		; RECURSIVE CALL TO LPR1
	POP	S,A1		; FETCH DIGITI FROM STACK
	ADDI	A1,60		; CONV TO ASCII
	IDPB	A1,A6		; PUT IN BUFFER
	POPJ	S,		; ASCEND FROM LPR1
	; INSERT A MESSAGE IN LISTING.  THE ADDRESS OF THE MESSAGE IN ASCIZ
	; FORMAT SHOULD BE IN A1.

INSERT:	IMBZ	A7,EXISTS	; IF LISTING DOES NOT EXIST

INS2:	POPJ	S,		; THEN DONT SEND MESSAGE THERE
	HRLI	A1,440700	; SET UP BYTE POINTER

	; CHARACTER TRANSFER LOOP

INS6:	ILDB	A2,A1		; GET A CHAR
	JUMPE	A2,INS2		; IF NULL, THE END
	SOSGE	FIVEC		; DECR NO OF REMAINING CHARS
	GOTO	INS3		; -END OF 5-CHAR GROUP

INS1:	IDPB	A2,W		; PUT CHAR IN LISTING
	GOTO	INS6		; LOOP

	; AT END OF WORD, CHECK FOR END OF LISTING BUFFER

INS3:	HRRZ	A6,W		; GET LISTING POINTER
	ADDI	A6,2		; STEP TO NEXT WORD
	IAGEM	A6,OBEND	; IF IT IS NOT WITHIN BUFFER
	GOTO	INS5		; THEN GET A NEW BUFFER

	; END OF BUFFER, GET ANOTHER

INS4:	LI	A6,4		; 4 CHARS LEFT AFTER THIS ONE
	ST	A6,FIVEC	; SET 5-CHAR GROUP COUNT
	GOTO	INS1		; CONTINUE

INS5:	HLRZ	A4,W		; SAVE S-P BITS OF LISTING POINTER
	PUSHJ	S,WRITEL	; GET A NEW BUFFER
	AOS	A6,W		; STEP LISTING POINTER
	ZERO	(A6)		; ZERO 1ST WORD OF BUFFER
	HRLM	A4,W		; SET S-P BITS
	GOTO	INS4		; CONTINUE



KCHECK:	HRRZ	A3,(A5)		; GET MESSAGE NUMBER
	IAEI	A3,^D98		; IF IT IS MESSAGE 98
	GOTO	ICHECK		; THEN DONT WRITE CR/LF TO TTY
TCHECK:	; WRITE CR/LF TO TTY, THEN CALL "ICHECK"
	LI	A1,NLCHRS	; PUT A CR/LF
	PUSHJ	S,INS		; INTO LISTING
	GOTO	IC2		; CONTINUE

	; "ICHECK MUST BE CALLED AFTER USING "INSERT" TO WRITE THE CR/LF TO

	; THE LISTING, AND TO MAKE SURE THAT THE TOTAL INSERTED MESSAGE
	; IS A MULTIPLE OF 5 CHARACTERS LONG.

ICHECK:	LI	A1,NLCHRS	; PUT A CR/LF
	PUSHJ	S,INSERT	; INTO LISTING

IC2:	IMBZ	A7,EXISTS	; IF LISTING DOESNT EXIST
	POPJ	S,		; THEN SKIP THIS
	LI	A1,0		; NULL CHARACTER

IC1:	SOSGE	FIVEC		; DECR NO OF REMAINING CHARS
	POPJ	S,		; EXIT ICHECK IF NONE LEFT
	IDPB	A1,W		; PUT NULL INTO LISTTIG
	GOTO	IC1		; LOOP


	RELOC

FIVEC:	0			; FIVE CHARACTER COUNT

	RELOC
	; PUT ENTRY IN MESSAGE TABLE

FAILED:	ST	6,REG3+5	; SAVE 6
	L	6,[		; LOAD BLT WORD
	XWD	1,REG3]		; BLT WORD
	BLT	6,REG3+4	; SAVE REGS

	; FIND THE BYTE POINTER TO THE ERROR

	SETOM	BYTES		; ZERO ^ POSITION
	SETZB	A4,FAILF	; CLEAR FLAGS
	IMBZ	A1,..IMM+17	; IF THERE IS TO BE NO ^
	GOTO	FAILA		; THEN SKIP THIS PART
	IMBZ	A1,..IMM	; IF NOT ^ WHERE POINTER IS NOW
	GOTO	.+3		; THEN SKIP
	AOS	BYTES		; USE EXACT POINTER
	L	A4,CC		; THEN USE CURRENT READ POINTER
	L	A5,PLIST	; GET POINTER  LIST POINTER
	XORI	A5,2		; FLIP IT
	IMBM	A1,..SYM	; IF ^ UNDER SYM
	L	A4,(A5)		; THEN GET SYM POINTER
	IMBM	A1,..DEL	; IF ^ UNDER DEL
	L	A4,1(A5)	; THEN GET DEL POINTER
	XORI	A5,2		; FLIP POINTER SWITCH
	IMBM	A1,..NSYM	; IF ^ UNDER NSYM
	L	A4,(A5)		; THEN GET NSYM POINTER
	IMBM	A1,..NDEL	; IF ^ UNDER NDEL
	L	A4,1(A5)	; THEN GET NDEL POINTER
	JUMPE	A4,FAILB	; IF POINTER ZERO, ERROR ON A PREVIOUS LINE
	IMBMZ	A4,EXACT	; IF FLAG BIT IS ON
	AOS	BYTES		; THEN USE EXACT POINTER

	; DETERMINE WHAT LINE THE ERROR IS ON

	IALM	A4,LP1		; IF ERROR NOT ON CURRENT LINE
	GOTO	FAILC		; THEN CHECK PRECEDING LINE
	SUB	A4,LP1		; COMPUTE POSITION ON LINE
	ADDM	A4,BYTES	; SAVE IT
	GOTO	FAILA		; CONTINUE

FAILC:	IALM	A4,LP2		; IF ERROR NOT ON PRECEDING LINE
	GOTO	FAILB		; THEN DONT PRINT AN ^
	SUB	A4,LP2		; COMPUTE POSITION ON LINE
	ADDM	A4,BYTES	; SAVE IT
	AOS	FAILF		; SET FLAG +
	GOTO	FAILA		; CONTINUE
FAILB:	SETOM	FAILF		; SET FLAG -

	; CREATE MESSAGE TABLE ENTRY

FAILA:	AOS	A4,BYTES	; GET UP ARROW POSITION
	LDB	A5,[		; GET TYPE FIELD OF SYM
	POINT	6,SYM,8]	; POINTER TO TYPE FIELD
	IAEI	A5,52		; IF TYPE = LABEL
	LI	A5,4		; THEN CHANGE TO 04
	ANDI	A5,7		; USE ONLY 3 BITS OF TYPE FIELD
	LSH	A4,7		; SHIFT 7
	ADD	A4,A5		; INCLUDE TYPE FIELD
	LSH	A4,3		; SHIFT 3
	LDB	A5,[		; GET KIND FIELD OF SYM
	POINT	2,SYM,2]	; POINTER TO KIND FIELD
	IMBZ	SYM,$SYMB	; IF SYM IS A CONSTANT
	LI	A5,4		; THEN USE AN 04
	ADD	A4,A5		; INCLUDE KIND
	MOVS	A4,A4		; MOVE IMFO TO FINAL POSITION
	L	A5,REG3		; GET PARAMETER TO "FAILED"
	HRR	A4,A5		; INCLUDE MESSAGE NUMBER
	IMBM	A5,..IUO2	; IF "IUO" MESSAGE
	SMBO	A4,..IUO1	; THEN SET IUO FLAG
	IMGZ	A6,FAILF	; IF ERROR ON PRECEDING LINE
	SMBO	A4,..PREC	; THEN SET FLAG
	IMLZ	A6		; IF ERROR ON SOME PREVIOUS LINE
	SMBO	A4,..PREV	; THEN SET FLAG
	IMBM	A5,SUSPCO	; IF TERMINATION BIT ON
	SMBO	A4,..TERM	; THEN TURN ON CORRESPONDING BIT

BLK0:	L	A6,NAMTE	; NEXT AVAINABLE MSG TABLE ENTRY SPACE
	IAGEI	A6,MTABLE+50	; IF PAST END OF TABLE
	GOTO	.+3		; THEN DONT PUT IN TABLE
	ST	A4,(A6)		; PUT ENTRY INTO TABLE
	AOS	NAMTE		; STEP TABLE INDEX
	IMBM	A5,..FATAL	; IF TERMINATION BIT ON
	GOTO	FAILT		; THEN STOP COMPILATION
	MOVS	A6,[		; GET POINTERS FOR
	XWD	A1,REG3]	; BLT
	BLT	A6,A6		; RESTORE REGISTERS
	POPJ	S,		; EXIT FAILED
	; FATAL ERROR. STOP COMPILATION IMMEDIATELY.

FAILT:	LDB	A1,P		; READ CHAR
	GOTO	.+2		; SKIP
	ILDB	A1,P		; READ NEXT CHAR
	L	A2,CTABLE(A1)	; GET ITS ENTRY
	IAEI	A2,4		; IF IT A NEW-LINE CHAR
	PUSHJ	S,NEWLINE	; THEN PRINT LINE AND MESSAGES
	GOTO	FAILT+2		; ELSE READ ANOTHER CHAR
	LI	A1,TERMSG	; TERMINATION MESSAGE
	PUSHJ	S,INS		; INSERT IT IN LISTING
	PUSHJ	S,TCHECK	; CR/LF
	GOTO	RINIT+1		; GET ANOTHER COMMAND STRING

	RELOC

REG3:	BLOCK	6		; REGISTER SAVE AREA
BYTES:	0			; BYTE COUNT FOR ^
FAILF:	0			; FLAG USED BY FAILED
LP1:	0			; POINTER TO START OF CURRENT LINE
LP2:	0			; POINTER TO START OF PRECEDING LINE
BLKF:	0			; .BLK1 .BLK2 FLAG

	RELOC
	; START OF BLOCK

.BLK1:	ZERO	BLKF		; ZERO THE FLAG
	GOTO	.+2		; SKIP

	; END OF BLOCK

.BLK2:	SETOM	BLKF		; SET FLAG NON-ZERO
	ST	6,REG3+5	; SAVE WORD
	L	6,[		; LOAD BLT WORD
	XWD	1,REG3]		; BLT WORD
	BLT	6,REG3+4	; SAVE ALL 6 REGS

	L	A2,CURBLOCK	; GET CURRENT BLOCK NUMBER
	IMEZ	BLKF		; IF .BLK1 THEN
	LSHC	A1,^D36		; MOVE TO A1, CLEAR 2ND PARAM
	LSH	A2,^D23		; COMBINE THE PARAM IN A1
	LSHC	A1,-^D23	; WITH THE PARAM IN A2
	L	A5,PLIST	; POINTER BUFFER
	XORI	A5,2		; FLIP IT TO SYM AND DEL
	L	A4,1(A5)	; GET POINTER TO DEL
	IMEZ	BLKF		; IF .BLK1 THEN
	L	A4,(A5)		; USE POINTER TO SYM INSTEAD
	IMBMZ	A4,EXACT	; IF FLAG BIT IS ON
	ADDI	A4,1		; THEN USE EXACT POINTER
	IALEM	A4,LP1		; DETERMINE WHICH LINE IT IS ON
	SMBO	A2,..PREC	; MARK: ON PRECEDING LINE
	SMBO	A2,776000+LEFT	; SET BYTES=255
	L	A4,A2		; MOVE TO A4
	LI	A5,0		; CLEAR A5
	GOTO	BLK0		; CONTINUE
SCDLT=.-43

	LEX(NE)		; "#"

	BLOCK	4

	LEX(LPAR)	; "("
	LEX(RPAR)	; ")"
	LEX(TIMES)	; "*"
	LEX(PLUS)	; "+"
	LEX(COM)	; ","
	LEX(MINUS)	; "-"
	0
	LEX(SLASH)	; "/"

TCDLT:	XWD	L$ASS,R$ASS	; ":="
	0
	LEX(LEQ)		; "<="
	0
	LEX(GTE)		; ">="
	0
	LEX(UPLUS)
	LEX(UMINUS)
	LEX(PHID)
	0
	LEX(COLON)	; ":"
	LEX(SC)		; ";"
	LEX(LSS)	; "<"
	LEX(EQ)		; "="
	LEX(GTR)	; ">"
; THE SWITCH TABLE IS PLACED HERE TO FILL IN THIS BIG HOLE:

;  ** SWITCH TABLE **

STABLE:	GOTO	SE		; A
	ST	A4,7(A1)	; B NUMBER OF BUFFERS IN BUFFER RING
	GOTO	SE		; C
	ST	A4,DYNOWN	; D DYNAMIC OWN AREA LENGTH
	SMBO	A7,ESWIT	; E LINE NUMBERS IN COLS 73-80
	GOTO	SE		; F
	GOTO	SE		; G
	GOTO	SE		; H
	GOTO	SE		; I
	GOTO	SE		; J
	GOTO	SE		; K
	SMBO	FL,LISTOO	; L REINSTATE LISTING
	GOTO	SE		; M
	SMBO	A7,NSWIT	; N NO ERROR PRINTOUTS ON TTY
	GOTO	SE		; O
	GOTO	SE		; P
	PUSHJ	S,QQQQ		; Q QUOTED RESERVED WORDS
	GOTO	SE		; R
	SMBZ	FL,LISTOO	; S SUPPRESS LISTING
	ST	A4,LTCODE	; T LENGTH OF TEMPCODE
	GOTO	SE		; U
	GOTO	SE		; V
	GOTO	SE		; W
	GOTO	SE		; X
	GOTO	SE		; Y
	GOTO	SE		; Z

	BLOCK	^D28+STABLE-.	; COMPLETE THE HOLE

	LEX(LBRA)	; "["
	0
	LEX(RBRA)	; "]"
	LEX(POW)	; "^"
	LEX(ASS)	; "_"
SUBTTL	** LSCAN **

; 	*****  L S C A N  *****
; 
; 		"LSCAN" READS ALGOL TEXT FROM A FILE AND
; 	CONVERTS IT TO AN INTERNAL CODE.  EACH CALL TO
; 	LSCAN PRODUCES THE NEXT ITEM FROM THE ALGOL
; 	PROGRAM.  ITEMS ARE OF THREE TYPES:
; 
; 		1.  IF THE ITEM IS A DELIMITER (EITHER
; 	SINGLE CHARACTER OR RESERVED WORD) LSCAN SETS
;	A3 EQUAL TO THE LEXEME OF THAT DELIMITER.
; 
; 		2.  IF THE ITEM IS A LITERAL CONSTANT
; 	LSCAN SETS A3 EQUAL THE LEXEME FOR THAT
; 	CONSTANT (PUTTING THE CONSTANT IN THE OBJECT
; 	MODULE'S CONSTANT TABLE IF NECESSARY), AND
; 	SKIP-RETURNS.
; 
; 		3.  IF THE ITEM IS AN IDENTIFIER NAME
; 	LSCAN PLACES IN A3 A POSITIVE NUMBER (A
; 	BUFFER ADDRESS), AND SKIP-RETURNS.  THIS NUMBER
; 	IS THE INPUT PARAMETER TO THE ROUTINE "SEARCH"
; 	WHICH IS USED TO PRODUCE THE LEXEME FOR THE
; 	IDENTIFIER.


LSCAN:	IMNZ	A3,BLEX		; IF THERE IS A BUFFERED LEXEME
	GOTO	BLEXR		; THEN TREAT SEPARATELY
	LDB	A1,P		; PICK UP 1ST CHAR
	IMNZ	A2,CTABLE(A1)	; LOAD TABLE ENTRY, SKIP IF DELIM
	GOTO	@TABLE1(A2)	; JUMP TO APPROPRIATE ROUTINE

	; SINGLE CHARACTER DELIMITER

DELIM:	L	A3,SCDLT(A1)	; GET THE LEXEME
	IBP	P		; STEP TO NEXT CHAR
	AOS	CC		; STEP POSITION COUNTER
	POPJ	S,		; EXIT READ MODULE
	NUMBER	; NUMBERS
	LETTER	; LETTERS
TABLE1:	DELIM	; DELIMITERS
	FLAGD	; DELIMITERS (FLAGGED)
	SPACE	; IGNORABLES
	SPACE	; SPACE & TAB
	NEW1	; NEW-LINE
	LOWER	; LOWER CASE
	OTHER	; OTHER CHARS
	SQUOTE	; SINGLE QUOTE


	; SPACE OR TAB

SPACE:	IAEI	A1,.TAB		; IF IT IS A TAB
	PUSHJ	S,TAB		; COMPUTE ITS LENGTH
	ILDB	A1,P		; GET ANOTHER CHAR
	AOS	CC		; STEP POSITION COUNT
	L	A2,CTABLE(A1)	; LOAD TABLE ENTRY
	GOTO	@TABLE1(A2)	; JUMP TO APPROPRIATE ROUTINE

	; END OF LINE

NEW1:	PUSHJ	S,NEWLINE	; PROCESS LISTING, GET NEXT CHAR
	NOP			; NO-OP
	L	A2,CTABLE(A1)	; LOAD TABLE ENTRY
	GOTO	@TABLE1(A2)	; JUMP TO APPROPRIATE ROUTINE

	; FLAGGED CHAR:   : < > !

FLAGD:	IAEI	A1,.EXCL	; IF CHAR IS A "!"
	GOTO	COMNT1		;  THEN PROCESS COMMENT
	L	A4,A1		; COPY CHARACTER TO A4
	JSP	A6,GETCHR	; READ THE NEXT CHARACTER
	IAEI	A1,.EQUAL	; IS IT AN "=" ??
	GOTO	FLAGD1		; -YES, ITS A 2-CHAR DELIM
	L	A3,SCDLT(A4)	; PICK UP LEXEME FOR DELIM
	POPJ	S,		; EXIT LSCAN
	; :=, <=, OR >=

FLAGD1:	L	A3,TCDLT-.COLON(A4); GET DELIMETER LEXEME
	IBP	P		; STEP TO NEXT CHAR
	AOS	CC		; STEP POSITION COUNTER
	POPJ	S,		; EXIT LSCAN



	; A SPECIAL CHARACTER WAS SCANNED

OTHER:	HLRZ	A2,CTABLE(A1)	; GET LEFT HALF OF CHARS TABLE ENTRY
	GOTO	@TABLE3(A2)	; JUMP THROUGH TABLE 3


TABLE3:	ILLEGAL	; ILLEGAL CHARACTER
	POWER	; @ &
	SCON	; " $ %
	DOT	; .


	; SPECIAL CONSTANT

SCON:	IAEI	A1,.%		; A "%" INDICATES
	GOTO	OCTAL		; AN OCTAL CONSTANT
	IAEI	A1,.$		; A "$" INDICATES
	GOTO	DOLLAR		; A SYMBOL CONSTANT
	GOTO	STRING		; OTHERWISE, MUST BE A STRING



	; A CONSTANTLESS EXPONENT

POWER:	SETZB	A4,MARKER	; MARK: NO DECIMAL POINT
	AOJA	A4,C11		; SET CONSTANT TO 1, JUMP INTO "NUMBER"
	; A DOT HAS BEEN SCANNED

DOT:	JSP	A6,GETCHR	; GET THE NEXT CHAR
	IAGEI	A1,.N0		; IF IT IS BELOW "0"
	IAGI	A1,.N9		; OR ABOVE "9"
	GOTO	DOT1		; THEN THE DOT IS A DELIMITER
	LI	A3,^D9		; SET LOOP INDEX
	ST	A3,MARKER	; SET DECIMAL POINT MARKER
	LI	A4,-.N0(A1)	; CONVERT 1ST CHAR TO BINARY
	SOJA	A3,LLOOP1	; JUMP INTO "NUMBER"


	; THE DOT IS A DELIMITER

DOT1:	L	A3,ZDOT		; LOAD ITS LEXEME
	POPJ	S,		; EXIT LSCAN

	LEX(DOT)



	; AN ILLEGAL CHAR HAS BEEN SCANNED


ILLEGAL: FAIL	(93,SOFT,IMM,ILLEGAL CHARACTER)
	LI	A4,.QUESTION	; A = QUESTION MARK

ILL1:	DPB	A4,P		; REPLACE CHARACTER WITH A QUESTION MARK
	ILDB	A1,P		; GET NEXT CHAR
	AOS	CC		; STEP POSITION COUNT
	L	A2,CTABLE(A1)	; GET ITS TABLE ENTRY
	IAEI	A2,6		; IF IT TOO IS AN ILLEGAL CHARACTER
	GOTO	ILL1		; THEN LOOP WITHOUT PRINTING ANOTHER MSG
	GOTO	@TABLE1(A2)	; OTHERWISE JUMP THROUGH TABLE 1

BLEXR:	ZERO	BLEX		; CLEAR INDICATOR
	POPJ	S,		; EXIT LSCAN

	IFN	EXPER,<
XXXX:	IANI	A1,112
	GOTO	SPACE
	L	A1,[XWD 20000,JJ]
	PUSHJ	S,FAILED
	GOTO	SPACE

JJ:	ASCIZ	/J/>
; 	**** CHARACTER TABLE ****
; 
; 	THIS TABLE IS USED TO CLASSIFY EACH OF
; 	THE ASCII CHARACTERS ACCORDING TO THE
; 	FOLLOWING TYPES:
; 
; 	-2	DIGIT
; 	-1	NUMBERS
; 	0	SINGLE-CHARACTER DELIMITERS
; 	1	FLAGGED DELIMITERS
; 	2	SHOULD BE IGNORED ON INPUT
; 	3	SPACE CHARS (SPACE & TAB)
; 	4	NEW-LINE CHARS (CR, LF, )
; 	5	LOWER CASE LETTERS
; 	6	OTHER CHARS.  
; 		   LEFT HALF:
; 			0 ILLEGAL CHAR
; 			1 @ &
; 			2 " $ %
; 			3 .
; 	7	SINGLE QUOTE
CTABLE:	2	;   0 NULL
	6	;   1 ^A
	6	;   2 ^B
	6	;   3 ^C
	6	;   4 ^D  (EOT)
	6	;   5 ^E  (WRU)
	6	;   6 ^F
	6	;   7 ^G  (BELL)
	6	;  10 ^H  (BACKSPACE)
	3	;  11 ^I  (TAB)
	4	;  12 ^J  (LINE FEED)
	6	;  13 ^K  (VERT TAB)
	3	;  14 ^L  (FORM)
	4	;  15 ^M  (RETURN)
	6	;  16 ^N
	6	;  17 ^O
	6	;  20 ^P
	2	;  21 ^Q  (XON)
	2	;  22 ^R  (TAPE)
	2	;  23 ^S  (XOFF)
	2	;  24 ^T  (NOTAPE)
	6	;  25 ^U
	6	;  26 ^V
	6	;  27 ^W
	6	;  30 ^X
	6	;  31 ^Y
	4	;  32 ^Z
	6	;  33 ^LBRAC  (ESC)
	6	;  34 ^\
	6	;  35 ^RBRAC
	6	;  36 ^^
	6	;  37 ^_
	3	;  40 SPACE
  XWD  1,1	;  41 !
  XWD  2,6	;  42 "
	0	;  43 #
  XWD  2,6	;  44 $
  XWD  2,6	;  45 %
  XWD  1,6	;  46 &
	7	;  47 '
	0	;  50 (
	0	;  51 )
	0	;  52 *
	0	;  53 +
	0	;  54 ,
	0	;  55 -
  XWD  3,6	;  56 .
	0	;  57 /
	-2	;  60 0
	-2	;  61 1
	-2	;  62 2
	-2	;  63 3
	-2	;  64 4
	-2	;  65 5
	-2	;  66 6
	-2	;  67 7
	-2	;  70 8
	-2	;  71 9
	1	;  72 :
	0	;  73 ; 
	1	;  74 LESS THAN
	0	;  75 =
	1	;  76 GRTR THAN
	6	;  77 ?
  XWD  1,6	; 100 @
	-1	; 101 A
	-1	; 102 B
	-1	; 103 C
	-1	; 104 D
	-1	; 105 E
	-1	; 106 F
	-1	; 107 G
	-1	; 110 H
	-1	; 111 I
	-1	; 112 J
	-1	; 113 K
	-1	; 114 L
	-1	; 115 M
	-1	; 116 N
	-1	; 117 O
	-1	; 120 P
	-1	; 121 Q
	-1	; 122 R
	-1	; 123 S
	-1	; 124 T
	-1	; 125 U
	-1	; 126 V
	-1	; 127 W
	-1	; 130 X
	-1	; 131 Y
	-1	; 132 Z
	0	; 133 LBRAC
	6	; 134 \
	0	; 135 RBRAC
	0	; 136 ^
	0	; 137 _
	6	; 140 LEFT SINGLE QUOTE
	5	; 141 LA
	5	; 142 LB
	5	; 143 LC
	5	; 144 LD
	5	; 145 LE
	5	; 146 LF
	5	; 147 LG
	5	; 150 LH
	5	; 151 LI
	5	; 152 LJ
	5	; 153 LK
	5	; 154 LL
	5	; 155 LM
	5	; 156 LN
	5	; 157 LO
	5	; 160 LP
	5	; 161 LQ
	5	; 162 LR
	5	; 163 LS
	5	; 164 LT
	5	; 165 LU
	5	; 166 LV
	5	; 167 LW
	5	; 170 LX
	5	; 171 LY
	5	; 172 LZ
	6	; 173 LEFT BRACE
	6	; 174 VERTICAL BAR
	3	; 175 RIGHT BRACE (ALTMODE)
	6	; 176 NOT
	2	; 177 DELETE
;	*****  L E T T E R  *****
;
;	"LETTER" SCANS IDENTIFIER NAMES AND RESERVED WORDS,
;	UNLESS RESERVED WORDS ARE QUOTED.  "LETTER" WILL OUTPUT 
;	THE LEXEME OF A RESERVED WORD OR THE BUFFER ADDRESS OF AN
;	IDENTIFIER.
;
;	"LETTER" READS CHARACTERS 6 AT A TIME.  THE 7-BIT 
;	CHARACTERS ARE READ INTO REGISTER A1 WITH AN ILDB AND
;	THEN 6 OF THESE BITS ARE SHIFTED INTO REGISTER A2 WITH
;	A "LSHC A1,-6" .  WHEN REGISTER A2 IS FULL IT IS DUMPED
;	INTO THE NEXT WORD OF A NAME BUFFER.  THUS THE NAME IS 
;	STORED IN A NAME BUFFER, 6 CHARACTERS PER WORD (NOT
;	THE SAME AS "SIXBIT" CHARACTERS), WITH THE CHARACTERS IN
;	REVERSE ORDER, AND WITH BLANKS ON THE RIGHT.  THE RIGHT-MOST
;	6 BITS OF THE 1ST WORD OF THE NAME IN THE NAME BUFFER 
;	CONTAIN THE LENGTH OF THE NAME IN CHARACTERS MINUS 1.  
;	THE WORD IMMEDIATELY PRECEDING THE NAME BUFFER CONTAINS
;	THE LENGTH OF THE NAME IN WORDS MINUS 1.  
;
;	UNLESS RESERVED WORDS ARE QUOTED, THE NAME IS THEN LOOKED
;	UP IN THE RESERVED WORD TABLE TO FIND OUT IF IT IS A RESERVED
;	WORD.  IF IT IS FOUND, THE LEXEME IS OUTPUT, AND THE NAME
;	BUFFER WILL BE USED AGAIN AT THE NEXT CALL TO "LETTER".
;	IF IT IS NOT FOUND, THE NAME BUFFER ADDRESS IS OUTPUT.  
;	THIS ADDRESS IS USED BY "SEARCH" TO LOCATE THE IDENTIFIER
;	IN THE SYMBOL TABLE.  THE NEXT CALL TO "LETTER" WILL NOT
;	USE THE SAME NAME BUFFER, THUS "SEARCH" DOES NOT HAVE TO
;	BE CALLED IMMEDIATELY.  "LETTER" CURRENTLY ROTATES BETWEEN
;	THREE NAME BUFFERS.
;


LOWER:	LI	A1,-40(A1)	; CONVERT TO UPPER CASE

LETTER:	L	A5,@RWS		; LOCATE RESERVED WORD SUBLIST
	ST	A5,RWSL		; SAVE IT FOR LATER
	AOSA	A3,LSBUFP	; GET LIST INDEX AND SKIP
	ZERO	LSBUFP		; ZERO INDEX
	IMEZ	A3,LSBUFT(A3)	; LOCATE A NAME BUFFER
	GOTO	.-2		; -RECYCLE
	SETZ	A2,		; CLEAR A2
	HRLZI	A5,-5		; SCAN 1ST 5 CHARS
	HRLZI	A6,-13		; BUT NO MORE THAN 65 CHARS
	; CHARACTER-READING LOOP

LET1:	LSHC	A1,-6		; MOVE CHAR TO ACC A1
	ILDB	A1,P		; GET NEXT CHAR
	AOS	CC		; STEP POSITION COUNT
	IMGEZ	A4,CTABLE(A1)	; CHECK IF LETTER OR NUMBER
	GOTO	@TABLE2(A4)	; -NO, GOTO A ROUTINE

LET2:	AOBJN	A5,LET1		; LOOP

	; END OF 6-CHAR GROUP

	ST	A2,@A3		; SAVE CHARS IN NAME BUFFER
	SETZ	A2, 		; CLEAR A2
	HRLI	A5,-6		; READ NEXT 6 CHARS
	AOBJN	A6,LET1		; BUT NOT PAST 65 CHARS


	; LINE EXCEEDS 64 CHARS

LET3:	LI	A6,-1(A6)	; BACK UP COUNTER
	FAIL	(91,SOFT,IMM,NAME EXCEEDS 64 CHARACTERS)
	PUSHJ	S,ATNAC		; ADVANCE TO NEXT ALPHAMERIC CHARACTER
	LI	A5,77		; MAKE NAME 63 CHARACTERS LONG
	LI	A6,12		; MAKE NAME 11 WORDS LONG
	GOTO	LET4+3		; CONTINUE


TABLE2:	LET4		; DELIMITERS
	LET4		; DELIMITERS (FLAGGED)
	LET1+1		; IGNORABLES
	LET12		; SPACE & TAB
	LET13		; NEW-LINE
	LET11		; LOWER CASE
	LET14		; OTHER
	LET4		; SINGLE QUOTE

LET12:	IMNZ	SQSW	; RESERVED WORD MODE?
	GOTO	LET1+1	; NO - IGNORE
	; END OF NAME, CHECK IF RESERVED WORD

LET4:	ST	A2,@A3		; SAVE LAST GROUP OF CHARS
	IMBM	A5,100		; IF NAME IS 65 CHARACTERS LONG
	GOTO	LET3		; THEN GIVE ERROR
	HRRZM	A6,-1(A3)	; PUT LENGTH-IN-WORDS IN BUFFER
	LI	A6,(A5)		; PUT LENGTH-IN-CHARS IN A6
	IORB	A6,(A3)		; PUT LENGTH IN BUFFER, PICK UP 1ST WORD

SQ3:	IMEZ	A5,RWSL		; IS THERE A SUBLIST?
	GOTO	LET9		; -NO, SKIP EVERY THING
	IANM	A6,RWTNAM(A5)	; DO 1ST WORDS MATCH?
	GOTO	LET8		; -NO, CONTINUE SEARCH

LET5:	IMLZ	A4,RWTLEN(A5)	; IS NAME 1 WORD LONG?
	GOTO	LET10		; -NO, 2 WORDS LONG

	; NAME FOUND IN RESERVED-WORD TABLE

LET6:	L	A3,RWTLEX(A5)	; LOAD LEXEME
	IMEZ	SQSW		; IF RESERVED WORD MODE
	SOS	LSBUFP		; RELEASE BUFFER
	IALI	A5,FRW		; IS RESERVED WORD FLAGGED?
	GOTO	@RWTRT(A5)	; -YES, GOTO ROUTINE
	POPJ	S,		; -NO, LSCAN



LET7:	IAEM	A6,RWTNAM(A5)	; DO 1ST WORDS MATCH?
	GOTO	LET5		; YES, CONTINUE

LET8:	HRRZ	A5,RWTLNK(A5)	; LOCATE ENTRY ON SUBLIST
	JUMPN	A5,LET7		; LOOP UNLESS LINK=0

	; NAME IS NOT A RESERVED WORD - IS AN IDENTIFIER

LET9:	POP	S,A4		; GET RETURN LINK
	GOTO	1(A4)		; SKIP RETURN



LET10:	L	A4,1(A3)	; LOAD 2ND WORD OF NAME BUFFER
	IAEM	A4,RWTNAM+1(A5)	; DO 2ND WORDS MATCH?
	GOTO	LET6		; -YES, CONTINUE
	GOTO	LET8		; -NO, CONTINUE
	; LOWER-CASE LETTER SCANNED

LET11:	LI	A1,-40(A1)	; CONVERT TO UPPER CASE
	GOTO	LET2		; CONTINUE



LET13:	PUSHJ	S,NCHECK	; INPUT NEXT LINE
	GOTO	LET1+3		; -END OF BUFFER IN MID LINE, CONTINUE
	GOTO	LET4		; END OF NAME


LET14:	IANI	A1,.DOT		; IF THIS IS A DOT
	GOTO	LET4		; ELSE END OF NAME
	PUSH	S,A6		; SAVE A6
	PUSH	S,A2		; SAVE A2
	JSP	A6,GETCHR	; READ NEXT CHARACTER
	POP	S,A2		; RESTORE A2
	POP	S,A6		; RESTORE A6
	IMLZ	CTABLE(A1)	; IF IT IS A LETTER OR A NUMBER
	GOTO	LET2		; THEN CONTINUE WITH IDENTIFIER NAME
	L	A4,ZDOT		; ELSE BUFFER THE LEXEME FOR
	ST	A4,BLEX		; THE DELIMITER "DOT"
	GOTO	LET4		; END OF IDENTIFIER NAME
	; THE FOLLOWING ROUTINES PROCESS THE FLAGGED RESERVED WORDS

FBEGIN:	SOSGE	A5,BTI		; DECREMENT BEGIN TABLE INDEX
	POPJ	S,		; EXIT LSCAN IF TABLE IS FULL
	AOS	A4,BNUM		; ADD 1 TO BEGIN NUMBER
	ST	A4,BTAB(A5)	; STORE NUMBER IN TABLE
	POPJ	S,		; EXIT LSCAN



FEND:	AOSG	A4,BTI		; STEP BEGIN TABLE INDEX
	POPJ	S,		; EXIT LSCAN IF TABLE STILL FULL
	IMNZ	A4,BTAB-1(A4)	; LOAD BEGIN NUMBER (DON'T PRINT E0)
	ST	A4,ENUM		; SAVE FOR PRINTING
	POPJ	S,		; EXIT LSCAN



	; A "GO" HAS BEEN SCANNED, NOW SEARCH FOR THE "TO"

FGO:	LDB	A1,P		; GET LAST CHAR
	L	A2,CTABLE(A1)	; GET ITS TABLE ENTRY

FGO1:	IANI	A2,3		; IF IT  IS NOT A SPACE OR A TAB
	GOTO	GOERR2		; THEN HE BLEW IT
	JSP	A6,GETCHR	; GET ANOTHER CHAR
	IANI	A1,.T		; IF IT IS NOT A "T"
	GOTO	FGO1		; THEN SEARCH NEXT CHAR
	JSP	A6,GETCHR	; GET ANOTHER CHAR
	IANI	A1,.O		; IF IT IS NOT A "O"
	GOTO	GOERR1		; THEN IT IS WRONG
	JSP	A6,GETCHR	; GET ANOTHER CHAR
	IANI	A2,-1		; THIS CHARACTER MUST NOT BE AN UPPER
	IAEI	A2,5		; OR LOWER CASE LETTER
	GOTO	GOERR1		; OR IT IS AN ERROR
	L	A3,ZGOTO	; LOAD LEXEME
	POPJ	S,		; EXIT LSCAN


GOERR1:	PUSHJ	S,ATNAC		; ADVANCE TO NON-ALPHAMERIC CHAR

GOERR2:	FAIL	(92,SOFT,IMM,ILLEGAL RESERVED WORD)
	L	A3,ZGOTO	; LOAD THE LEXEME ANYWAY
	POPJ	S,		; EXIT LSCAN
COMNT1:	JSP	A6,GETCHR	; GET NEXT CHAR

COMNT2:	LDB	A1,P		; GET THE CHARACTER
	L	A2,CTABLE(A1)	; GET ITS TABLE ENTRY
	IAEI	A2,4		; IF IT IS A NEW-LINE CHAR
	GOTO	NEW2		; THEN HANDLE SPECIALLY
	IANI	A1,.SEMI	; IF IT IS NOT A SEMI-COLON
	GOTO	COMNT1		; THEN LOOP
	IBP	P		; STEP TO NEXT CHAR
	AOS	CC
	IMNZ	SQSW		; IF QUOTED MODE
	POP	SP,A1		; LOSE LINK FROM SQUOTE
	GOTO	LSCAN		; RESTART AT BEGINNING OF LSCAN


NEW2:	PUSHJ	S,NEWLINE	; CALL "NEWLINE"
	NOP			; 
	GOTO	COMNT2		; CONTINUE


	RELOC

LSBUFP:	0		; NAME BUFFER POINTER
	0
LSBUF1:	BLOCK	14	; NAME BUFFER
LSBUF2:	BLOCK	14	; NAME BUFFER
LSBUF3:	BLOCK	14	; NAME BUFFER
RWSL:	0		; ADDR OF RESERVED WORD TABLE SUBLIST
BLEX:	0		; BUFFERED LEXEME
CC:	0		; POSITION COUNT
BTI:	0		; BEGIN-TABLE INDEX
BTAB:	BLOCK	50	; BEGIN-TABLE

	RELOC


LSBUFT:	XWD	A6,LSBUF1	; NAME BUFFER LIST
	XWD	A6,LSBUF2
	XWD	A6,LSBUF3
	0

MSKTBL:	0
	0
	000000000377
	000000077777
	0
	000017777777
	0
	003777777777
;	*****  N U M B E R  *****
;
;	"NUMBER" IS USED TO SCAN DECIMAL CONSTANTS.  "NUMBER"
;	WILL COMPUTE THE VALUE, PUT IT INTO THE CONSTANTS TABLE
;	IF NECESSARY, AND PRODUCE THE LEXEME.
;
;	"NUMBER" WORKS BY READING THE 1ST 10 DIGITS WITH A
;	QUICK 7-INSTRUCTION LOOP (LLOOP1) THAT ALWAYS PRODUCES AN INTEGER.
;	IF A DECIMAL POINT IS ENCOUNTERED, THE LOOP INDEX IS SAVED
;	IN "MARKER" AND USED LATER TO DETERMINE THE POWER OF TEN, 
;	THEN CONTROL RETURNS TO THE LOOP.  IF THERE ARE MORE THAN
;	TEN DIGITS, CONTROL PASSES TO A SECOND LOOP (LLOOP2) THAT
;	READS DIGITS UNTIL THE VALUE OVERFLOWS INTO BIT 0 OR
;	UNTIL A DECIMAL POINT OCCURRS.  AT THAT POINT THE VALUE
;	IS CONVERTED FROM INTEGER TO DOUBLE-PRECISION FLOATING
;	POINT FORMAT, AND CONTROL GOES TO A 13-INSTRUCTION
;	LOOP (LLOOP3) THAT READS THE REMAINING DIGITS.  FINALLY
;	THE CONSTANT IS CONVERTED TO THE INDICATED TYPE.
;	SINGLE-PRECISION FLOATING POINT IS FIRST CONVERTED TO
;	DOUBLE-PRECISION FLOATING POINT, THEN THE POWER OF TEN
;	IS INCLUDED, THEN THE RESULT IS ROUNDED TO SINGLE-
;	PRECISION.  THIS IS DONE SO THAT ALL 27 BITS OF THE
;	MANTISSA ARE ACCURATE.
;

NUMBER:
	; SET UP FOR READING DIGITS

	LI	A3,^D9		; READ 1ST 9 DIGITS OF NUMBER
	ZERO	MARKER		; CLEAR DECIMAL POINT MARKER
	LI	A4,-.N0(A1)	; CONVERT 1ST CHAR TO BINARY

	; MAIN LOOP FOR SCANNING NUMBER

LLOOP1:	ILDB	A1,P		; READ NEXT CHAR
	AOS	CC		; STEP POSITION COUNT

C1:	L	A2,CTABLE(A1)	; GET CHAR'S TABLE ENTRY
	GOTO	@TABLE4(A2)	; JUMP THROUGH TABLE 4

C2:	IMULI	A4,^D10		; MULT PREVIOUS RESULT BY TEN
	ADDI	A4,-.N0(A1)	; ADD IN NEW DIGIT
	SOJG	A3,LLOOP1	; LOOP

	; NUMBER IS LONGER THAN 10 CHARS

	LI	A3,30000	; SET A NEW INDEX
	IMNZ	MARKER		; IF A DECIMAL POINT HAS OCCURRED
	ADDM	A3,MARKER	; THEN ADD NEW INDEX TO MARKER
	; LOOP THAT READS UNTIL OVERFLOW

LLOOP2:	JSP	A6,GETCHR	; READ NEXT CHAR
	IAEI	A1,.DOT		; IF IT IS A DOT
	GOTO	C3		; THEN EXIT THIS LOOP
	IAGEI	A1,.N0		; IF CHAR IS BELOW 0
	IAGI	A1,.N9		; OR ABOVE 9
	GOTO	C1		; THEN JUMP THROUGH TABLE 4

	; MAKE A SPARE COPY OF NUMBER IN CASE OF OVERFLOW

	ST	A4,COPY		; SAVE NUMBER
	JFCL	17,.+1		; CLEAR ANY FLAGS THAT MIGHT BE SET
	IMULI	A4,^D10		; MULT BY TEN
	ADDI	A4,-.N0(A1)	; ADD IN NEW DIGIT
	JOV	C7		; STOP IF OVERFLOW
	SOJA	A3,LLOOP2	; LOOP

	; CONVERT THE PARTIAL RESULT TO DOUBLE PRECISION

C3:	ST	A3,MARKER	; SET DECIMAL POINT MARKER
	JSP	A6,CONVID	; CONVERT FROM INTEGER TO DOUBLE

	; MAIN LOOP FOR SCANNING DOUBLE PRECISION NUMBER

LLOOP3:	ILDB	A1,P		; GET ANOTHER CHAR
	AOS	CC		; STEP POSITION COUNT

C5:	L	A2,CTABLE(A1)	; GET CHAR'S TABLE ENTRY
	GOTO	@TABLE5(A2)	; JUMP THROUGH TABLE

C6:	IFE PROC-KA10, <
	FMPRI	A5,204500	; MULT RIGHT PART BY TEN
	L	A6,A5		; MOVE RIGHT PART TO A6
	FMPL	A4,[		; MULT LEFT PART BY TEN
	XWD	204500,0]	; FLOATING-POINT TEN
	UFA	A5,A6		; ADD LESS SIG. PART TO RIGHT PART
	FADL	A4,FTABLE-.N0(A1); ADD IN NEW DIGIT
	UFA	A5,A6		; ADD LESS SIG. PART TO RIGHT PART
	FADL	A4,A6		; ADD LEFT AND RIGHT PARTS TO NORMALIZE>
	IFE PROC-KI10, <
	DFMP	A4,[
	XWD	204500,000000
	XWD	000000,000000]	; MULTIPLY BY TEN
	MOVE	A1,FTABLE-.N0(A1)
	MOVEI	A2,0
	DFAD	A4,A1		; AND ADD IN DIGIT>
	SOJA	A3,LLOOP3	; LOOP
	; OVERFLOW OCCURRED, CONVERT TO DOUBLE PRECISION

C7:	L	A4,COPY		; FETCH THE COPY
	JSP	A6,CONVID	; CONVERT IT TO DOUBLE PRECISION
	GOTO	C6		; JUMP INTO LLOOP3


	C2	; NUMBER
	C20	; LETTER
TABLE4:	C8	; DELIMITER
	C8	; DELIMITER (FLAGGED)
	LLOOP1	; IGNORABLE CHARACTER
	C8	; SPACE & TAB
	C8B	; NEW-LINE
	C20	; LOWER CASE LETTER
	C10	; OTHER
	C8	; SINGLE QUOTE



C8B:	PUSHJ	S,NCHECK	; INPUT NEXT LINE
	GOTO	C1		; -END OF BUFFER IN MID LINE, CONTINUE

	; NORMAL END OF NUMBER

C8:	IMNZ	MARKER		; IF A DECIMAL POINT WAS EVER SCANNED
	GOTO	C18		; THEN THE NUMBER IS SINGLE-FLOATING

C8A:	IMBM	A4,777777+LEFT	; IF LEFT HALF OF VALUE IS NON ZERO
	GOTO	C9		; THEN NUMBER IS NOT INTEGER-IMMEDIATE

	; THE CONSTANT IS AN INTEGER-IMMEDIATE

	L	A3,A4		; MOVE CONSTANT TO A3 FOR OUTPUT
	HRLI	A3,$EXP+$I+$SIM+$DEC+$IMM; LEXEME TYPE FIELDS
	POP	S,A4		; GET RETURN LINK
	GOTO	1(A4)		; EXIT LSCAN



	; THE CONSTANT IS AN INTEGER FULLWORD

C9:	PUSHJ	S,CON1		; SEARCH CONSTANTS TABLE
	HRLI	A3,$EXP+$I+$SIM+$DEC+$CT; LEXEME LEFT HALF
	POP	S,A4		; GET RETURN LINK
	GOTO	1(A4)		; EXIT LSCAN
	; A SPECIAL CHARACTER WAS SCANNED

C10:	HLRZ	A2,CTABLE(A1)	; GET LEFT HALF OF CHAR'S TABLE ENTRY
	GOTO	@TABLE6(A2)	; JUMP THROUGH TABLE 6


TABLE6:	C19	; ILLEGAL CHARACTER
	C11	; @ &
	C20	; " $ %
	C16	; .

	; A @ OR & WAS SCANNED

C11:	JSP	A6,GETCHR	; GET NEXT CHAR
	IANI	A1,.AAAAA	; IF IT IS A @
	IAEI	A1,.AMPER	; OR A &
	GOTO	C23		; THEN CONVERT TO DOUBLE
	PUSHJ	S,EXPONT	; SCAN THE EXPONENT

C12:	JSP	A6,CONVID	; CONVERT TO DOUBLE PRECISION

C13:	PUSHJ	S,SCALE		; INCLUDE CORRECT POWER OF TEN
	IFE PROC-KA10, <
	FADR	A4,A5>
	IFE PROC-KI10, <
	IMBZ	A5,LEFT+200000
	GOTO	.+3
	ADDI	A4,1
	SMBO	A4,LEFT+000400>	; ROUND TO SINGLE PRECISION
	IMBM	A4,777777	; IF RIGHT HALF IS NON-ZERO
	GOTO	C15		; THEN CONSTANT NOT IMMEDIATE
	HLRZ	A3,A4		; MOVE TO A3, SWAPPED
	HRLI	A3,$EXP+$R+$SIM+$DEC+$IMM; LEXEME LEFT HALF
	POP	S,A4		; GET RETURN LINK
	GOTO	1(A4)		; EXIT LSCAN
	; THE CONSTANT IS A FLOATING POINT FULLWORD

C15:	PUSHJ	S,CON1		; PUT CONSTANT IN CONSTANT TABLE
	HRLI	A3,$EXP+$R+$SIM+$DEC+$CT; LEXEME LEFT HALF
	POP	S,A4		; GET RETURN LINK
	GOTO	1(A4)		; EXIT LSCAN



	; A DOT WAS SCANNED

C16:	IMNZ	MARKER		; IF MARKER NOT ZERO THEN THERE ARE
	GOTO	C17		; TWO DECIMAL POINTS IN THIS CONSTANT
	ST	A3,MARKER	; SET DECIMAL POINT MARKER
	GOTO	LLOOP1		; RETURN TO LOOP
	; CONSTANT CONTAINS TWO DECIMAL POINTS

C17:	PUSHJ	S,BADNAC	; PRINT ERROR MSG, USE ATNAC

	; CONVERT CONSTANT TO SINGLE-FLOATING

C18:	SUB	A3,MARKER	; FIX SCALING CONSTANT
	GOTO	C12		; CONTINUE



	; AN ILLEGAL CHARACTER WAS SCANNED

C19:	LI	A1,.QUESTION	; ASCII QUESTION MARK
	DPB	A1,P		; PUT QUESTION MARK IN INPUT BUFFER
	PUSHJ	S,BADNAC	; PRINT ERROR MESSAGE, USE ATNAC
	GOTO	C8		; CONTINUE

C20:	PUSHJ	S,BADCON	; PRINT ERROR MSG
	GOTO	C8		; CONTINUE



	C6	; NUMBER
	C30	; LETTER
TABLE5:	C28	; DELIMITER
	C28	; DELIMITER (FLAGGED)
	LLOOP3	; IGNORABLE
	C28	; SPACE & TAB
	C36	; NEW-LINE
	C30	; LOWER CASE LETTER
	C21	; OTHER
	C28	; SINGLE QUOTE
	; A SPECIAL CHAR WAS SCANNED

C21:	HLRZ	A2,CTABLE(A1)	; GET LEFT HALF OF CHAR'S TABLE ENTRY
	GOTO	@TABLE7(A2)	; JUMP THROUGH TABLE 7

TABLE7:	C27	; ILLEGAL CHARACTER
	C22	; @ &
	C30	; " $ %
	C25	; .



	; A @ OR & WAS SCANNED

C22:	JSP	A6,GETCHR	; GET NEXT CHAR
	IANI	A1,.AAAAA	; IF IT IS A @
	IAEI	A1,.AMPER	; OR A &
	GOTO	C24		; THEN CONSTANT IS DOUBLE PRECISION
	PUSHJ	S,EXPONT	; SCAN THE EXPONENT
	GOTO	C13		; CONTINUE AS IF SINGLE-PRECISION



	; CONVERT TO DOUBLE-PRECISION

C23:	JSP	A6,CONVID	; CONVERT FROM INTEGER TO DOUBLE

	; PRODUCE LEXEME FOR DOUBLE PRECISION CONSTANT

C24:	JSP	A6,GETCHR	; READ NEXT CHAR
	PUSHJ	S,EXPONT	; SCAN THE EXPONENT
	PUSHJ	S,SCALE		; INCLUDE CORRECT POWER OF TEN
	PUSHJ	S,CON2		; PUT CONSTANT IN CONSTANT TABLE
	HRLI	A3,$EXP+$LR+$SIM+$DEC+$CT; LEXEME LEFT HALF
	POP	S,A4		; GET RETURN LINK
	GOTO	1(A4)		; EXIT LSCAN



	; A DOT WAS SCANNED

C25:	IMNZ	MARKER		; IF MARKER NOT ZERO THEN THERE ARE
	GOTO	C26		; TWO DECIMAL POINTS IN THIS CONSTANT
	ST	A3,MARKER	; SET DECIAML POINT MARKER
	GOTO	LLOOP3		; RETURN TO LOOP
	; EITHER A LETTER OR TWO DECIMAL POINTS APPEARED IN CONSTANT

C26:	PUSHJ	S,BADNAC	; PRINT ERROR MSG, USE ATNAC
	JSP	A6,GETCHR	; GET NEXT CHAR
	IANM	A1,.AAAAA	; IF IT IS A @
	IAEM	A1,.AMPER	; OR A &
	GOTO	C22		; THEN CONTINUE AS DOUBLE-PRECISION
	GOTO	C28		; ELSE CONVERT TO SINGLE-PRECISION



	; A STRANGE CHAR APPEARED IN CONSTANT

C27:	LI	A1,.QUESTION	; ASCII QUESTION MARK
	DPB	A1,P		; REPLACE ILLEGAL CHARACTER WITH A "?"
	PUSHJ	S,BADNAC	; PRINT ERROR MSG, USE ATNAC
	GOTO	C28		; CONTINUE

C30:	PUSHJ	S,BADCON	; PRINT ERROR MESSAGE

C28:	IMNZ	MARKER		; IF A DECIMAL POINT WAS EVER SCANNED
	GOTO	C29		; THEN JUMP OVER THIS PART

	; INTEGER TOO LARGE FOR INTEGER

	L	A1,[		; LOAD PARAMETER FOR MESSAGE
	XWD	..IMM-LEFT,^D98]	; MSG 98
	PUSHJ	S,.FAILED	; "INTEGER CONST CONVERTED TO TYPE REAL"
	SOS	.JBERR		; DONT COUNT THIS AS AN ERROR
	LI	A3,0		; EXPONENT OF ZERO
	GOTO	C13		; CONTINUE AS IF SINGLE PRECISION

C29:	SUB	A3,MARKER	; CONV FROM DOUBLE TO SINGLE
	GOTO	C13		; CONTINUE AS SINGLE PRECISION
BADCON:	FAIL	(90,FRIED,IMM,INVALID CONSTANT)
	POPJ	S,		; EXIT BADCON

	; SUBROUTINE TO CONVERT FROM INTEGER TO DOUBLE PRECISION

CONVID:	LSHC	A4,-^D27	; SHIFT
	LSH	A5,-^D9		; SHIFT
	IOR	A4,[		; OR IN AN EXPONENT TO LEFT PART
	XWD	266000,0]	; 2^54
	IFE PROC-KA10, <
	IOR	A5,[		; OR IN AN EXPONENT TO RIGHT PART
	XWD	233000,0]	; 2^27
	FADL	A4,A5		; NORMALIZE THE NUMBER>
	IFE PROC-KI10, <
	DFAD	A4,[
	EXP	0,0]>
	GOTO	(A6)		; EXIT CONVID

	; SUBROUTINE TO SCAN POWER OF TEN

EXPONT:	IMNZ	MARKER		; IF A DECIMAL POINT HAS OCCURRED
	SUBM	A3,MARKER	; THEN SET CORRECT POWER OF TEN
	SETZB	A3,SIGN		; CLEAR EXPONENT AND SIGN
	IAEI	A1,.MINUS	; IF IT IS A MINUS SIGN
	GOTO	C34		; THEN SET INDICATOR
	IAEI	A1,.PLUS	; IF IT IS A PLUS SIGN
	GOTO	C35		; THEN READ NEXT CHAR

LLOOP4:	HRRZ	A2,CTABLE(A1)	; GET CHAR'S TABLE ENTRY
	IANI	A2,-2		; IS IT IS NOT A DIGIT
	GOTO	C31		; THEN JUMP OUT OF LOOP
	IMULI	A3,^D10		; MULT PREVIOUS RESULT BY TEN
	ADDI	A3,-.N0(A1)	; ADD IN CURRENT DIGIT
	IAGI	A3,^D300	; IF NUMBER IS EXCEEDINGLY LARGE
	GOTO	C33		; THEN STOP THIS NONSENSE
	JSP	A6,GETCHR	; GET NEXT CHAR
	GOTO	LLOOP4		; LOOP


C31:	IANI	A2,5		; IF IT IS A LOWER CASE LETTER
	IAEI	A2,-1		; OR AN UPPER CASE LETTER
	GOTO	C32		; THEN PRINT ERROR
	IAEI	A2,6		; IF IT IS AN ILLEGAL CHAR
	GOTO	C33		; THEN PRINT ERROR
	IMNZ	SIGN		; IF SIGN IS NEGATIVE
	MOVN	A3,A3		; THEN NEGATE EXPONENT
	ADD	A3,MARKER	; ADD IN DECIMAL POINT CORRECTION
	POPJ	S,		; EXIT EXPONT
C32:	PUSHJ	S,BADCON	; ADVANCE TO NON-ALPHAMERIC CHAR
	GOTO	.+2		; CONTINUE

C33:	PUSHJ	S,BADNAC	; PRINT MSG, USE ATNAC
	SETZ	A3,		; USE A ZERO EXPONENT
	POPJ	S,		; EXIT EXPONT


C34:	SETOM	SIGN		; SET SIGN MINUS

C35:	JSP	A6,GETCHR	; GET NEXT CHAR
	GOTO	LLOOP4		; RETURN TO LOOP



C36:	PUSHJ	S,NCHECK	; INPUT NEXT LINE
	GOTO	C5		; -END OF BUFFER IN MID LINE, CONTINUE
	GOTO	C28		; TRUE END OF LINE

	; SUBROUTINE TO COMBINE A FLOATING POINT CONSTANT WITH ITS EXPONENT

SCALE:	JUMPE	A4,SCALED	; FINISHED IF ZERO
	JFCL	17,.+1		; CLEAR ANY FLAGS
	JUMPE	A3,SCALED	; EXIT IF POWER IS ZERO
	JUMPG	A3,SCALE2	; JUMP IF POWER POSITIVE
	MOVN	A3,A3		; ABS VALUE OF NEGATIVE POWER

SCALE1:	IAGI	A3,^D38		; IF POWER LESS THAN -38
	PUSHJ	S,DFDV38	; THEN INCREASE IT BY 38
	PUSHJ	S,DFDV0		; ELSE DIVIDE BY POWER OF 10
	GOTO	SCALE1		; IF POWER WAS LESS THAN -38, LOOP
	JUMPN	A4,SCALE3	; EXIT SCALE IF NO UNDERFLOW
	FAIL	(94,SOFT,IMM,EXPONENT TOO SMALL)

SCALE3:	POPJ	S,		; EXIT SCALE


SCALE2:	IAGI	A3,^D38		; IF POWER GREATER THAN 38
	PUSHJ	S,DFMP38	; THEN REDUCE IT BY 38
	PUSHJ	S,DFMP0		; ELSE MULTIPLY BY POWER OF 10
	GOTO	SCALE2		; IF POWER WAS GREATER THAN 38, LOOP
	JOV	.+2		; IF NO FLAGS WERE SET
	POPJ	S,		; THEN EXIT SCALE
	FAIL	(95,SOFT,IMM,EXPONENT TOO LARGE)

SCALED:	POPJ	S,		; AND EXIT SCALE
	; DOUBLE PRECISION MULTIPLY

DFMP0:	SKIPA	A1,A3		; GET CORRECT EXPONENT AND SKIP

DFMP38:	LI	A1,^D38		; USE AN EXPONENT OF 38
	SUB	A3,A1		; A3= EXPONENT DIFFERENCE
	L	A6,A4		; COPY HIGH AC OPERAND TO A6
	IFE PROC-KA10, <
	FMPR	A6,LTEN(A1)	; ONE CROSS-PRODUCT TO A6
	JSP	A2,FPUS
	FMPR	A5,HTEN(A1)	; OTHER CROSS-PRODUCT TO A3
	JSP	A2,FPUS
	UFA	A5,A6		; ADD CROSS PRODUCTS INTO A6
	JSP	A2,FPU2
	FMPL	A4,HTEN(A1)	; HIGH PRODUCT TO A4-A5
	JSP	A2,FPU2
	UFA	A5,A6		; ADD LOW PART TO CROSS-PRODUCT SUM
	JSP	A2,FPU2
	FADL	A4,A6		; COMBINE HIGH PART WITH CROSS-PRODUCT
	JSP	A2,FPU2>
	IFE PROC-KI10, <
	PUSH	S,A7		; SAVE A7
	L	A6,HTEN(A1)
	L	A7,LTEN(A1)
	DFMP	A4,A6		; MULTIPLY
	JSP	A2,FPU2
	POP	S,A7		; RESTORE A7>
	AOS	(S)
	POPJ	S,		; SKIP RETURN
	; DOUBLE PRECISION DIVIDE

DFDV0:	SKIPA	A1,A3		; GET CORRECT EXPONENT AND SKIP

DFDV38:	LI	A1,^D38		; USE AN EXPONENT OF 38
	SUB	A3,A1		; A3 = EXPONENT DIFFERENCE
	IFE PROC-KA10, <
	FDVL	A4,HTEN(A1)	; GET HIGH PART OF QUOTIENT
	JSP	A2,FPU2
	MOVN	A6,A4		; COPY NEGATIVE OF QUOTIENT TO A6
	FMPR	A6,LTEN(A1)	; MULTIPLY BY LOW PART OF DIVISOR
	JSP	A2,FPUS
	UFA	A5,A6		; ADD REMAINDER
	JSP	A2,FPU2
	FDVR	A6,HTEN(A1)	; DIVIDE SUM BY HIGH PART OF DIVISOR
	JSP	A2,FPU1
	FADL	A4,A6		; ADD RESULT TO  ORIGINAL QUOTIENT
	JSP	A2,FPU2>
	IFE PROC-KI10, <
	PUSH	S,A7		; SAVE A7
	L	A6,HTEN(A1)
	L	A7,LTEN(A1)
	DFDV	A4,A6		; DIVIDE
	JSP	A2,FPU2
	POP	S,A7		; RESTORE A7>
	AOS	(S)
	POPJ	S,		; SKIP RETURN
; UNDERFLOW HANDLERS

FPU1:	IMBZ	A2,LEFT+000100	; IF NOT UNDERFLOW
	GOTO	(A2)		; THEN RETURN
	SMBZ	A2,LEFT+440100	; CLEAR FLAGS
	ST	A2,OVA
	LDB	A2,[
	POINT	4,-2(A2),12]	; GET RELEVANT ACC. NUMBER
	ZERO	(A2)		; AND ZERO IT
	GOTO	2,@OVA		; AND RETURN

FPU2:	IMBZ	A2,LEFT+000100	; IF NOT UNDERFLOW
	GOTO	(A2)		; THEN RETURN
	SMBZ	A2,LEFT+440100	; CLEAR FLAGS
	ST	A2,OVA
	LDB	A2,[
	POINT	4,-2(A2),12]	; GET RELEVANT ACC. NUMBER
	ZERO	(A2)		; AND ZERO IT
	ZERO	1(A2)		; ALSO ZERO NEXT ACC.
	GOTO	2,@OVA		; AND RETURN

FPUS:	IMBZ	A2,LEFT+000100	; IF NOT UNDERFLOW
	GOTO	(A2)		; THEN RETURN
	SMBZ	A2,LEFT+440100	; CLEAR FLAGS
	ST	A2,OVA
	LDB	A2,[
	POINT	4,-2(A2),12]	; GET RELEVANT ACC. NUMBER
	ST	A2,OVB		; AND SAVE IT
	ST	A3,OVC		; AND A3
	L	A2,(A2)		; GET VALUE OF ACC.
	HLRE	A3,A2		; GET EXPONENT, EXTENDING SIGN
	ASH	A3,-11
	TSCE	A3,A3		; IF NEGATIVE, COMPLEMENT EXPONENT
	TLOA	A2,777000	; NEGATIVE - SET ALL ONES
	SMBZ	A2,LEFT+777000	; POSITIVE - SET ALL ZEROS
	IALM	A3,[
	XWD	000346,000346]	; WILL ALL OF MANTISSA DISAPPEAR?
	TDZA	A2,A2		; YES - SAVE LONG SHIFT
	ASH	A2,400000(A3)	; DENORMALIZE MANTISSA TO SUIT EXPONENT
	ST	A2,@OVB		; RESTORE RELEVANT ACC.
	L	A3,OVC		; RESTORE A3
	GOTO	2,@OVA		; AND RETURN
FTABLE:	XWD	000000,0	; 0
	XWD	201400,0	; 1
	XWD	202400,0	; 2
	XWD	202600,0	; 3
	XWD	203400,0	; 4
	XWD	203500,0	; 5
	XWD	203600,0	; 6
	XWD	203700,0	; 7
	XWD	204400,0	; 8
	XWD	204440,0	; 9
	IFE	PROC-KA10,<

; KA10 HIGH ORDER WORDS

HTEN:	XWD	201400,000000	; 1.0
	XWD	204500,000000	; 1.0&&1
	XWD	207620,000000	; 1.0&&2
	XWD	212764,000000	; 1.0&&3
	XWD	216470,400000	; 1.0&&4
	XWD	221606,500000	; 1.0&&5
	XWD	224750,220000	; 1.0&&6
	XWD	230461,132000	; 1.0&&7
	XWD	233575,360400	; 1.0&&8
	XWD	236734,654500	; 1.0&&9
	XWD	242452,013710	; 1.0&&10
	XWD	245564,416672	; 1.0&&11
	XWD	250721,522450	; 1.0&&12
	XWD	254443,023471	; 1.0&&13
	XWD	257553,630407	; 1.0&&14
	XWD	262706,576511	; 1.0&&15
	XWD	266434,157115	; 1.0&&16
	XWD	271543,212741	; 1.0&&17
	XWD	274674,055531	; 1.0&&18
	XWD	300425,434430	; 1.0&&19
	XWD	303532,743536	; 1.0&&20
	XWD	306661,534465	; 1.0&&21
	XWD	312417,031701	; 1.0&&22
	XWD	315522,640261	; 1.0&&23
	XWD	320647,410336	; 1.0&&24
	XWD	324410,545213	; 1.0&&25
	XWD	327512,676455	; 1.0&&26
	XWD	332635,456171	; 1.0&&27
	XWD	336402,374713	; 1.0&&28
	XWD	341503,074076	; 1.0&&29
	XWD	344623,713116	; 1.0&&30
	XWD	347770,675742	; 1.0&&31
	XWD	353473,426555	; 1.0&&32
	XWD	356612,334310	; 1.0&&33
	XWD	361755,023372	; 1.0&&34
	XWD	365464,114134	; 1.0&&35
	XWD	370601,137163	; 1.0&&36
	XWD	373741,367020	; 1.0&&37
	XWD	377454,732312	; 1.0&&38
; KA10 LOW ORDER WORDS

LTEN:	XWD	000000,000000	; 1.0
	XWD	000000,000000	; 1.0&&1
	XWD	000000,000000	; 1.0&&2
	XWD	000000,000000	; 1.0&&3
	XWD	000000,000000	; 1.0&&4
	XWD	000000,000000	; 1.0&&5
	XWD	000000,000000	; 1.0&&6
	XWD	000000,000000	; 1.0&&7
	XWD	000000,000000	; 1.0&&8
	XWD	000000,000000	; 1.0&&9
	XWD	000000,000000	; 1.0&&10
	XWD	000000,000000	; 1.0&&11
	XWD	215400,000000	; 1.0&&12
	XWD	221240,000000	; 1.0&&13
	XWD	224510,000000	; 1.0&&14
	XWD	227432,000000	; 1.0&&15
	XWD	233760,200000	; 1.0&&16
	XWD	236354,240000	; 1.0&&17
	XWD	241647,310000	; 1.0&&18
	XWD	245110,475000	; 1.0&&19
	XWD	250132,614200	; 1.0&&20
	XWD	253561,357240	; 1.0&&21
	XWD	257446,725444	; 1.0&&22
	XWD	262760,512755	; 1.0&&23
	XWD	265354,635550	; 1.0&&24
	XWD	271024,002441	; 1.0&&25
	XWD	274631,003151	; 1.0&&26
	XWD	277177,204004	; 1.0&&27
	XWD	303617,422402	; 1.0&&28
	XWD	306563,327103	; 1.0&&29
	XWD	311320,214724	; 1.0&&30
	XWD	314004,260111	; 1.0&&31
	XWD	320202,556055	; 1.0&&32
	XWD	323443,311471	; 1.0&&33
	XWD	326554,174007	; 1.0&&34
	XWD	332543,515404	; 1.0&&35
	XWD	335674,440705	; 1.0&&36
	XWD	340653,551067	; 1.0&&37
	XWD	344413,241542	; 1.0&&38>
	IFE	PROC-KI10,<

; KI10 HIGH ORDER WORDS

HTEN:	XWD	201400,000000	; 1.0
	XWD	204500,000000	; 1.0&&1
	XWD	207620,000000	; 1.0&&2
	XWD	212764,000000	; 1.0&&3
	XWD	216470,400000	; 1.0&&4
	XWD	221606,500000	; 1.0&&5
	XWD	224750,220000	; 1.0&&6
	XWD	230461,132000	; 1.0&&7
	XWD	233575,360400	; 1.0&&8
	XWD	236734,654500	; 1.0&&9
	XWD	242452,013710	; 1.0&&10
	XWD	245564,416672	; 1.0&&11
	XWD	250721,522450	; 1.0&&12
	XWD	254443,023471	; 1.0&&13
	XWD	257553,630407	; 1.0&&14
	XWD	262706,576511	; 1.0&&15
	XWD	266434,157115	; 1.0&&16
	XWD	271543,212741	; 1.0&&17
	XWD	274674,055531	; 1.0&&18
	XWD	300425,434430	; 1.0&&19
	XWD	303532,743536	; 1.0&&20
	XWD	306661,534465	; 1.0&&21
	XWD	312417,031701	; 1.0&&22
	XWD	315522,640261	; 1.0&&23
	XWD	320647,410336	; 1.0&&24
	XWD	324410,545213	; 1.0&&25
	XWD	327512,676455	; 1.0&&26
	XWD	332635,456171	; 1.0&&27
	XWD	336402,374713	; 1.0&&28
	XWD	341503,074076	; 1.0&&29
	XWD	344623,713116	; 1.0&&30
	XWD	347770,675742	; 1.0&&31
	XWD	353473,426555	; 1.0&&32
	XWD	356612,334310	; 1.0&&33
	XWD	361755,023372	; 1.0&&34
	XWD	365464,114134	; 1.0&&35
	XWD	370601,137163	; 1.0&&36
	XWD	373741,367020	; 1.0&&37
	XWD	377454,732312	; 1.0&&38
; KI10 LOW ORDER WORDS

LTEN:	XWD	000000,000000	; 1.0
	XWD	000000,000000	; 1.0&&1
	XWD	000000,000000	; 1.0&&2
	XWD	000000,000000	; 1.0&&3
	XWD	000000,000000	; 1.0&&4
	XWD	000000,000000	; 1.0&&5
	XWD	000000,000000	; 1.0&&6
	XWD	000000,000000	; 1.0&&7
	XWD	000000,000000	; 1.0&&8
	XWD	000000,000000	; 1.0&&9
	XWD	000000,000000	; 1.0&&10
	XWD	000000,000000	; 1.0&&11
	XWD	200000,000000	; 1.0&&12
	XWD	120000,000000	; 1.0&&13
	XWD	244000,000000	; 1.0&&14
	XWD	215000,000000	; 1.0&&15
	XWD	370100,000000	; 1.0&&16
	XWD	166120,000000	; 1.0&&17
	XWD	323544,000000	; 1.0&&18
	XWD	044236,400000	; 1.0&&19
	XWD	055306,100000	; 1.0&&20
	XWD	270567,520000	; 1.0&&21
	XWD	223352,622000	; 1.0&&22
	XWD	370245,366400	; 1.0&&23
	XWD	166316,664100	; 1.0&&24
	XWD	012001,220450	; 1.0&&25
	XWD	314401,464562	; 1.0&&26
	XWD	077502,001717	; 1.0&&27
	XWD	307611,201141	; 1.0&&28
	XWD	271553,441371	; 1.0&&29
	XWD	150106,351670	; 1.0&&30
	XWD	002130,044246	; 1.0&&31
	XWD	101267,026547	; 1.0&&32
	XWD	221544,634301	; 1.0&&33
	XWD	266076,003362	; 1.0&&34
	XWD	261646,602127	; 1.0&&35
	XWD	336220,342555	; 1.0&&36
	XWD	325664,433310	; 1.0&&37
	XWD	205520,661075	; 1.0&&38>
;   CONSTANTS TABLE
;
;	THE SIZE OF THE CONSTANTS TABLE ALWAYS INCREASES DURING A COMPILATION.
;	NEW ENTRIES ARE PLACED AT THE END, AND ARE ALSO LINKED INTO ONE OF
;	THREE CHAINS ACCORDING TO WHETHER IT IS FOR A 1-WORD CONSTANT,
;	A 2-WORD CONSTANT, OR A STRING.  THEREFORE EACH ENTRY HAS A LINK.
;	THIS LINK IS ALWAYS IN THE RIGHT HALF OF THE 1ST WORD OF THE ENTRY.
;	THE VALUE OF THE LINK IS EQUAL TO A NUMBER WHICH IF SUBTRACTED
;	FROM THE ADDRESS OF THE ENTRY WILL YIELD THE ADDRESS OF THE NEXT
;	ENTRY OF THE CHAIN.  EACH CHAIN TERMINATES IN A FAKE ENTRY WHOSE
;	1ST DATA WORD IS THE 1ST WORD OF THE CONSTANTS TABLE.  BECAUSE
;	OF THIS, THE CONSTANTS TABLE CAN BE SEARCHED IN A 3-INSTRUCTION LOOP.
;	THE FORMATS OF THE DIFFERENT TYPES OF ENTRIES ARE:
;
;
;
;            1-WORD CONSTANTS        2-WORD CONSTANTS             STRINGS
;
;         !--------------------!  !--------------------!  !--------------------!
;         !                    !  !                    !  !                    !
; WORD-0  ! LEFT:  BACKCHAIN   !  ! LEFT:  BACKCHAIN 1 !  ! LEFT:  BACKCHAIN 1 !
;         ! RIGHT: LINK        !  ! RIGHT: LINK        !  ! RIGHT: LINK        !
;         !                    !  !                    !  !                    !
;         !--------------------!  !--------------------!  !--------------------!
;         !                    !  !                    !  !                    !
; WORD-1  !       VALUE        !  ! LEFT:  (NOT USED)  !  ! LEFT:  (NOT USED)  !
;         !                    !  ! RIGHT: BACKCHAIN 2 !  ! RIGHT: BACKCHAIN 2 !
;         !                    !  !                    !  !                    !
;         !--------------------!  !--------------------!  !--------------------!
;                                 !                    !  !                    !
; WORD-2                          ! 1ST WORD OF VALUE  !  ! LEFT:  (NOT USED)  !
;                                 !                    !  ! RIGHT: # OF BYTES  !
;                                 !                    !  !                    !
;                                 !--------------------!  !--------------------!
;                                 !                    !  !                    !
; WORD-3                          ! 2ND WORD OF VALUE  !  ! 1ST WORD OF STRING !
;                                 !                    !  !                    !
;                                 !                    !  !                    !
;                                 !--------------------!  !--------------------!
;                                                         !                    !
;
;                                                         !                    !
;                                                         !--------------------!
;                                                         !                    !
; WORD-N+2                                                ! NTH WORD OF STRING !
;                                                         !                    !
;                                                         !                    !
;                                                         !--------------------!
	; ENTER 1-WORD CONSTANT IN CONSTANTS TABLE

CON1:	ST	A4,@CONTAB	; SAVE VALUE IN BEGINNING OF CONSTANTS TABLE
	SKIPA	A3,LASTC1	; LOAD LAST 1-WORD CONSTANT, AND SKIP

CON1A:	SUB	A3,(A3)		; STEP BACK TO PREVIOUS ENTRY
	IANM	A4,1(A3)	; DO VALUES MATCH?
	GOTO	CON1A		; -NO, LOOP

	LI	A6,1(A3)	; ADDR OF NEXT WORD
	IANM	A6,CONTAB	; WAS WORD REALLY IN CONSTANTS TABLE?
	GOTO	CON1B		; YES, STOP SEARCH

	LI	A6,2		; NEW ENTRY IS 2 WORDS LONG
	PUSHJ	S,GETCTS	; GET SOME SPACE IN CONSTANTS TABLE
	LI	A6,(A3)		; COPY ADDR OF NEW ENTRY TO A6
	SUB	A6,LASTC1	; SUBTRACT FROM LAST 1-WORD ENTRY ADDR
	ST	A6,(A3)		; SAVE IN NEW ENTRY AS A LINK
	ST	A4,1(A3)	; PUT VALUE IN ENTRY
	ST	A3,LASTC1	; SET NEW LASTC1

CON1B:	SUB	A3,CONTAB	; CONV FROM ABS TO REL ADDRESS
	POPJ	S,		; EXIT CON1



	; GET SPACE IN CONSTANTS TABLE

GETCTS:	HRRZ	A3,NACTE	; ADDR OF NEW ENTRY
	ADDB	A6,NACTE	; ADD LENGTH OF NEW ENTRY
	IAGEM	A6,CONEND	; DOES IT OVERFLOW THE TABLE?
	GOTO	OVFL2		; -YES, MOVE THE TABLES, EXIT GETCTS
	POPJ	S,		; EXIT GETCTS

	; ENTER 2-WORD CONSTANT IN CONSTANTS TABLE

CON2:	ST	A4,@CONTAB	; SAVE VALUE IN BEGINNING OF CONSTANT TABLE
	SKIPA	A3,LASTC2	; LOAD ADDR OF LAST 2-WORD CONSTANT AND SKIP

CON2A:	SUB	A3,(A3)		; STEP BACK TO PREVIOUS ENTRY
	IANM	A4,2(A3)	; DO VALUES MATCH?
	GOTO	CON2A		; -NO, LOOP
	LI	A6,2(A3)	; STEP TO NEXT WORD
	IAEM	A6,CONTAB	; WAS WORD REALLY IN CONSTANTS TABLE?
	GOTO	CON2B		; -NO, ENTER IT
	IANM	A5,3(A3)	; DO 2ND WORDS MATCH?
	GOTO	CON2A		; -NO, LOOP
	SUB	A3,CONTAB	; SUBTRACT OFF BASE OF CONSTANT TABLE
	POPJ	S,		; EXIT CON2
CON2B:	LI	A6,4		; NEW ENTRY IS 4 WORDS LONG
	PUSHJ	S,GETCTS	; GET SPACE FOR IT
	LI	A6,(A3)		; COPY ADDR TO A6
	SUB	A6,LASTC2	; SUBTRACT FROM LAST 2-WORD ENTRY ADDR
	ST	A6,(A3)		; SAVE IN NEW ENTRY AS A LINK
	ST	A4,2(A3)	; PUT 1ST WORD IN ENTRY
	ST	A5,3(A3)	; PUT 2ND WORD IN ENTRY
	ZERO	1(A3)		; CLEAR BACK-CHAINS
	ST	A3,LASTC2	; SET NEW LASTC2
	SUB	A3,CONTAB	; CONVERT FROM ABS TO REL ADDRESS
	POPJ	S,		; EXIT CON2




	RELOC

MARKER:	0		; DECIMAL POINT MARKER
COPY:	0		; TEMPORARY COPY OF VALUE OF CONSTANT
SIGN:	0		; SIGN OF THE EXPONENT
LASTC1:	0		; LAST 1-WORD CONSTANT IN CONSTANT TABLE
LASTC2:	0		; LAST 2-WORD CONSTANT IN CONSTANT TABLE
CONEND:	0		; END OF CONSTANT TABLE
	RELOC
;	*****  A T N A C  *****
;
;	ADVANCE TO NEXT NON-ALPHAMERIC CHARACTER
;

BADNAC:	PUSHJ	S,BADCON	; BADCON/ATNAC
	GOTO	ATNAC

ATNAC2:	IANI	A1,.DOT		; IF IT IS NOT A DOT
	POPJ	S,		; THEN EXIT ATNAC

ATNAC:	ILDB	A1,P		; LOAD THE NEXT CHAR
	AOS	CC		; STEP POSITION COUNT
	L	A2,CTABLE(A1)	; GET ITS TABLE ENTRY
	GOTO	@TABLE9(A2)	; JUMP THROUGH TABLE 9


	ATNAC	; NUMBER
	ATNAC	; LETTER
TABLE9:	ATNAC1	; DELIMITER
	ATNAC1	; DELIMITER (FLAGGED)
	ATNAC	; IGNORABLE CHAR
	ATNAC1	; SPACE & TAB
	ATNAC3	; NEW-LINE CHAR
	ATNAC	; LOWER-CASE
	ATNAC2	; OTHER CHAR   @ % $ " & . ILLEGALS
	ATNAC	; SINGLE QUOTE


ATNAC3:	PUSHJ	S,NCHECK	; INPUT NEXT LINE
	GOTO	ATNAC+2		; -END OF BUFFER IN MID LINE, CONTINUE

ATNAC1:	POPJ	S,		; EXIT ATNAC
;	*****  OCTAL CONSTANTS  *****



OCTAL:	SETZB	A4,A5		; CLEAR A4,A5

	; CHARACTER READING LOOP

OCTALL:	ILDB	A1,P		; GET A CHAR
	AOS	CC		; STEP POSITION COUNT
	IAGEI	A1,.N0		; IF IT IS BELOW 0
	IAGI	A1,.N7		; OR ABOVE 7
	GOTO	OCTALD		; THEN CONSTANT IS FINISHED
	LSHC	A4,3		; MULTIPLY BY 8
	JUMPN	A4,OCTILL	; TEST FOR OVERFLOW
	IORI	A5,-.N0(A1)	; ADD IN CURRENT DIGIT
	GOTO	OCTALL		; LOOP


OCTALD:	L	A2,CTABLE(A1)	; GET CHARS TABLE ENTRY
	GOTO	@TABLE8(A2)	; JUMP THROUGH TABLE 8


	OCTILL	; NUMBER
	OCTIL1	; LETTER
TABLE8:	OCTOUT	; DELIM
	OCTOUT	; DELIM (FLAGGED)
	OCTALL	; IGNORABLE
	OCTOUT	; SPACE & TAB
	OCTNL	; NEW-LINE
	OCTIL1	; OTHER
	OCTOUT	; SINGLE QUOTE

	; NEW-LINE CHARACTER SCANNED

OCTNL:	PUSHJ	S,NCHECK	; INPUT NEXT LINE
	GOTO	OCTALL+2	; -END OF BUFFER IN MID LINE, CONTINUE

	; END OF OCTAL CONSTANT

OCTOUT:	IMBM	A5,777777+LEFT	; IF LEFT HALF NON-ZERO 
	GOTO	OCTFUL		; THEN THE CONSTANT IS A FULLWORD
	L	A3,A5		; MOVE THE CONSTANT TO A3

	; CONSTANT IS A HALFWORD

FALSE1:	HRLI	A3,$EXP+$B+$SIM+$DEC+$IMM; LEXEME
	POP	S,A4		; GET RETURN LINK
	GOTO	1(A4)		; EXIT LSCAN
	; "TRUE" SCANNED

FTRUE:	HRREI	A5,-1		; "TRUE" IS A WORD OF ALL ONES

	; CONSTANT IS A FULL WORD

OCTFUL:	L	A4,A5		; MOVE THE CONSTANT TO A4
	PUSHJ	S,CON1		; PUT IN CONSTANT TABLE
	HRLI	A3,$EXP+$B+$REG+$DEC+$CT; LEXEME
	POP	S,A4		; GET RETURN LINK
	GOTO	1(A4)		; EXIT LSCAN

	; INVALID FORMAT FOR OCTAL CONSTANT

OCTILL:	PUSHJ	S,BADNAC	; PRINT ERROR MSG, USE ATNAC
	GOTO	OCTOUT		; CONTINUE


OCTIL1:	PUSHJ	S,BADCON	; PRINT ERROR MESSAGE
	GOTO	OCTOUT		; CONTINUE

	; "FALSE" SCANNED

FFALSE:	LI	A3,0		; "FALSE" IS A ZERO WORD
	GOTO	FALSE1		; CONTINUE AS AN OCTAL (BOOLEAN) CONSTANT
;	*****  SYMBOL CONSTANTS  *****
;
;
;
DOLLAR:	JSP	A6,STCHAR	; GET NEXT CHAR
	L	A3,A1		; THIS WILL BE THE TERMINATING CHAR
	LI	A4,0		; CLEAR ACC A4
	LI	A5,6		; READ 6 CHARS

SCLOOP:	JSP	A6,STCHAR	; READ ANOTHER CHAR
	IAEI	A1,(A3)		; IF IT IS THE END CHAR
	GOTO	SCDONE		; THEN THE CONSTANT IS DONE
	LSH	A4,7		; SHIFT THE CONSTANT OVER 7
	IORI	A4,(A1)		; INCLUDE THE CURRENT CHAR
	SOJG	A5,SCLOOP	; LOOP
	PUSHJ	S,BADNAC	; PRINT ERROR MSG, USE ATNAC
	GOTO	C8A		; CONTINUE AS IF AN INTEGER

SCDONE:	IBP	P		; STEP TO NEXT CHAR
	GOTO	C8A		; CONTINUE AS AN INTEGER
;	*****  STRINGS  *****
;
;
;
	; SET UP

STRING:	LI	A6,3		; GET 3 WORDS FROM
	PUSHJ	S,GETCTS	; THE CONSTANTS TABLE
	L	A6,A3		; COPY 1ST WORD ADDRESS TO A6
	PUSH	S,LASTST	; SAVE ADDRESS OF STRING CHAIN
	SUB	A6,LASTST	; COMPUTE DISTANCE BACK TO LAST STRING
	ST	A3,LASTST	; SET NEW POINTER TO LAST STRING
	HRRZM	A6,(A3)		; USE AS THE LINK
	ZERO	1(A3)		; CLEAR THE BACK CHAIN POINTERS
	ADDI	A3,2		; STEP FORWARD 2 WORDS
	HRRZM	A3,CCOUNT	; SET POINTER TO CHAR COUNT WORD
	HRLI	A3,000700	; FORM BUFFER BYTE POINTER
	ST	A3,STRPNT	; SET POINTER
	SETZB	A5,BCOUNT	; CLEAR CHARACTER AND BRACKET COUNTS
	GOTO	STR6		; CONTINUE

	; CHARACTER READING LOOP

STR1:	JSP	A6,STCHAR	; READ A CHARACTER
	IANI	A1,.DQUOT	; IF IT IS A "
	IAEI	A1,.SEMI	; IF IT IS A SEMI-COLON
	GOTO	SPECIAL		; THEN IT IS ILLEGAL
	IAEI	A1,.CLEFT	; IF IT IS A ^_
	GOTO	CLEFT		; THEN SCAN FOR A LINE-FEED

STR2:	IDPB	A1,STRPNT	; PUT THE CHAR IN THE CONSTANTS TABLE
	ADDI	A5,1		; STEP THE CHARACTER COUNT
	SOJG	A4,STR1		; LOOP

	; END OF 20-CHARACTER GROUP

STR6:	LI	A6,4		; GET 4 MORE WORDS FROM THE 
	PUSHJ	S,GETCTS	; CONSTANTS TABLE
	SUB	A3,[		; SET UP FOR LOOP
	XWD	4,4]		; THE 4 WORDS THAT WERE JUST ACQUIRED
	ZERO	4(A3)		; MUST BE CLEARED TO ZERO
	AOBJN	A3,.-1		; ZERO THE NEXT WORD
	LI	A4,^D20		; READ THE NEXT 20 CHARACTERS
	GOTO	STR1		; LOOP
	; A " OR ; WAS SCANNED

SPECIAL: L	A3,A1		; SAVE THE CHAR
	JSP	A6,GETCHR	; GET THE NEXT CHARACTER
	IANI	A1,(A3)		; IF IT IS NOT A "
	GOTO	STEND		; THEN IT WAS THE END OF THE STRING
	GOTO	STR2		; AND CONTINUE

	; A ^_ WAS ENCOUNTERED

CLEFT:	LI	A1,.LEFT	; "_"
	DPB	A1,P		; PUT A _ IN LISTING
	JSP	A6,STCHAR	; GET THE NEXT CHARACTER
	IANI	A1,.LF		; IF IT IS A LINE-FEED
	IAEI	A1,.FF		; OR A FORM-FEED
	GOTO	STR1		; THEN READ NEXT CHAR FOR REAL
	IAEI	A1,.VT		; IF IT IS A VERTICAL TAB
	GOTO	STR1		; THEN READ THE NEXT CHAR FOR REAL
	GOTO	CLEFT+2		; LOOP



	; END OF STRING FOUND

STEND:	IAEI	A3,.SEMI	; IF CHAR IS A SEMICOLON THEN
	GOTO	STERR		; IT IS AN ERROR
	HRRZ	A4,STRPNT	; GET THE BUFFER STRING POINTER
	ADDI	A4,1		; STEP NO NEXT AVAILABLE WORD
	ST	A4,NACTE	; SAVE IT
	LI	A4,0		; LOAD A ZERO
	LI	A3,4		; SET COUNT
	IDPB	A4,STRPNT	; INCLUDE FOUR NULLS
	SOJG	A3,.-1
	L	A3,CCOUNT	; GET THE CHARACTER COUNT WORD POINTER
	ST	A5,@A3		; SAVE THE CHARACTER COUNT

	; SEARCH FOR A DUPLICATE STRING IN CONSTANTS TABLE

	SUBI	A3,2		; STEP BACK TO START OF ENTRY
	SUBI	A5,1		; SO THAT THE DIVISION WILL COME OUT RIGHT
	IDIVI	A5,5		; COMPUTE THE NUMBER OF WORDS
	MOVN	A5,A5		; NEGATIVE OF LENGTH
	HRLZI	A5,-2(A5)	; NEGATIVE LENGTH+1 TO LEFT HALF
	HRRI	A5,2		; INDEX TO BYTES WORD
	HRLI	A3,A2		; LEFT HALF = A2
	L	A1,A3		; COPY A3 TO A1
	GOTO	STR4		; JUMP INTO LOOP
	; COMPARE THE 2 STRING ENTRIES

STR3:	HRLI	A1,A2		; LEFT HALF = A2
	L	A2,A5		; SET COUNT REGISTER
	L	A4,@A3		; GET WORD OF ENTRY
	IANM	A4,@A1		; IF MISMATCH
	GOTO	STR4		; THEN QUIT THIS ENTRY
	AOBJN	A2,.-3		; LOOP FOR ALL OF STRING

	; DUPLICATE FOUND, USE IT INSTEAD

	HRRZM	A3,NACTE	; RETURN THE NEW ENTRY TO AVAILABLE SPACE
	POP	S,LASTST	; RESTORE THE OLD VALUE OF LASTST
	L	A3,A1		; -MATCH FOUND, USE IT
	GOTO	STR5		; CONTINUE


	; LOCATE NEXT STRING IN CONSTANTS TABLE

STR4:	SUB	A1,(A1)		; LOCATE NEXT ENTRY ON CHAIN
	LI	A1,(A1)		; ZERO LEFT HALF
	IAGM	A1,CONTAB	; IF NOT END OF CHAIN
	GOTO	STR3		; THEN COMPARE THESE ENTRIES
	POP	S,A1		; DISCARD SAVED VALUE OF LASTST

	; FORM LEXEME

STR5:	SUB	A3,CONTAB	; CONVERT TO RELATIVE ADDRESS
	HRLI	A3,$EXP+$S+$REG+$DEC+$CT; LEXEME
	POP	S,A4		; GET THE RETURN LINK
	GOTO	1(A4)		; SKIP RETURN

	; INVALID FORMAT FOR STRING CONSTANT

STERR:	PUSHJ	S,BADNAC	; PRINT "INVALID CONSTANT" MESSAGE, USE ATNAC
	GOTO	STEND+2		; COMPLETE CONSTANT AND CONTINUE



	RELOC

LASTST:	0			; LAST STRING IN CONSTANTS TABLE
CCOUNT:	0			; CHARACTER COUNT WORD POINTER
BCOUNT:	0			; BRACKET COUNT
STRPNT:	0			; BYTE POINTER INTO BUFFER

	RELOC
;	THERE ARE THREE ROUTINES THAT WILL READ THE NEXT CHARACTER FROM
;	THE SOURCE STREAM.  HOWEVER MOST OF THE TIME THE COMPILER DOES NOT
;	USE ANY OF THEM BUT INSTEAD HAS THE NECESSARY CODE IN-LINE.
;	THESE ROUTINES ARE DESCRIBED:
;
;	"GETCHR" IS THE MOST OFTEN USED.  "GETCHR" WILL PROCESS IGNORABLE
;	CHARACTERS, LOWER CASE LETTERS, TABS, AND CHARACTERS THAT SIGNIFY
;	THE END OF THE INPUT BUFFER.  "GETCHR" WILL PRESENT ALL OTHER CHARACTERS
;	UNCHANGED.
;
;	"STCHAR" IS USED TO READ CHARACTERS FOR STRINGS.  THE NEWLINE AND
;	TAB FUNCTIONS ARE PERFORMED, BUT NEWLINE CHARACTERS ARE ALSO PRESENTED
;	AS OUTPUT.  IGNORABLE CHARACTERS ARE NOT PRESENTED.  LOWER CASE
;	LETTERS ARE NOT CONVERTED TO UPPER CASE.
;
;	"GETNL" MUST BE USED TO READ CHARACTERS FROM WITHIN THE NEWLINE
;	ROUTINE.  "GETNL" WILL CHECK FOR END OF INPUT BUFFER, AND READ
;	ANOTHER BUFFER IF THIS OCCURRS.

;   ** GETCHR **

GETCHR:	ILDB	A1,P		; GET THE NEXT CHARACTER
	AOS	CC		; STEP CHARACTER COUNT
	L	A2,CTABLE(A1)	; GET THE CHARS TABLE ENTRY
	XCT	TABL11(A2)	; ANALYZE CHARACTER
	GOTO	(A6)		; CHAR OK, EXIT GETCHR
	JSP	A2,SAVE		; SAVE  SOME REGISTERS
	PUSHJ	S,NEWLINE	; CALL NEWLINE
	NOP			; WONT RETURN HERE
	JSP	A2,REST		; RESTORE THE REGISTERS
	GOTO	GETCHR+2	; CONTINUE WITH NEW CHARACTER


	GOTO	(A6)		; NUMBER
	GOTO	(A6)		; LETTER
TABL11:	GOTO	(A6)		; DELIMITER
	GOTO	(A6)		; FLAGGED DELIMITER
	GOTO	GETCHR		; IGNORABLE CHARACTER
	GOTO	GETTAB		; SPACE & TAB
	PUSHJ	S,NCHECK	; NEW LINE CHARACTER
	SUBI	A1,40		; LOWER CASE
	GOTO	(A6)		; OTHER CHARACTERS
	GOTO	(A6)		; SINGLE QUOTE



GETTAB:	IAEI	A1,.TAB		; IF IT IS A TAB
	PUSHJ	S,TAB		; THEN TAKE CARE OF IT
	GOTO	(A6)		; EXIT GETCHR
;   ** STCHAR **

STCHAR:	IMNZ	A2,STCFL	; IF THERE ARE ANY BUFFERED CHARACTERS
	GOTO	STCNL1		; THEN USE THEM

	; READ THE NEXT CHARACTER

STCHR1:	ILDB	A1,P		; GET NEXT CHAR
	AOS	CC		; STEP POSITION COUNT
	L	A2,CTABLE(A1)	; GET ITS TABLE ENTRY
	GOTO	@TABL10(A2)	; JUMP THROUGH TABLE

	STCOK	; NUMBER
	STCOK	; LETTER
TABL10:	STCOK	; DELIMITER
	STCOK	; DELIMITER (FLAGGED)
	STCHR1	; IGNORABLE
	STCTAB	; SPACE & TAB
	STCNL	; NEW-LINE CHARACTER
	STCOK	; LOWER CASE LETTER
	STCOK	; OTHER
	STCOK	; SINGLE QUOTE


	; CHECK FOR A TAB

STCTAB:	IAEI	A1,.TAB		; IF IT IS A TAB
	PUSHJ	S,TAB		; THEN FIND ITS LENGTH


	; NOT A SPECIAL CHARACTER

STCOK:	ZERO	STCFL		; CLEAR THE FLAG
	GOTO	(A6)		; EXIT STCHAR

	; A NEW-LINE CHARACTER HAS BEEN SCANNED

STCNL:	ST	A1,CHAR1	; SAVE THIS CHARACTER
	PUSHJ	S,NCHECK	; IF THIS IS ONLY THE END OF BUFFER
	GOTO	STCHR1+2	; THEN GET ANOTHER BUFFER AND CONTINUE
	AOS	STCFL		; SET THE FLAG +
	ZERO	CHAR2		; CLEAR 2ND CHAR
	ZERO	FFCNT		; ZERO FORM-FEED COUNT
	JSP	A2,SAVE		; SAVE THE REGISTERS
	PUSHJ	S,NEWLINE	; PRINT THE LAST LINE
	NOP			; CANT RETURN HERE
	JSP	A2,REST		; RESTORE THE REGISTERS
	EXCH	A1,CHAR1	; GET THE 1ST CHAR
	GOTO	(A6)		; EXIT STCHAR
	; 1ST CALL AFTER A NL CHAR: PRESENT 2ND BUFFERED CHAR

STCNL1:	JUMPL	A2,STCNL2	; JUMP IF FLAG NEGATIVE
	SETOM	STCFL		; SET FLAG NEGATIVE
	IMEZ	A1,CHAR2	; GET THE 2ND CHAR
	GOTO	STCHR1		; IF NONE, READ NEXT CHAR
	GOTO	(A6)		; EXIT STCHAR


	; 2ND CALL AFTER A NL CHAR: PRESENT ANY FORM-FEEDS

STCNL2:	SOSGE	FFCNT		; DECREMENT FORM-FEED COUNT
	GOTO	STCNL3		; JUMP IF NEG (NO MORE FORM FEEDS)
	LI	A1,.FF		; FORM FEED
	GOTO	(A6)		; EXIT STCHAR


	; A SUBSEQUENT CALL: PRESENT 3RD BUFFERED CHAR

STCNL3:	ZERO	STCFL		; ZERO FLAG
	L	A1,CHAR1	; GET THE 3RD CHARACTER
	GOTO	STCHR1+2	; READ NEXT CHAR



	; SAVE A4, A5, A6, AND A3 ON STACK

SAVE:	PUSH	S,A4		; SAVE A4
	PUSH	S,A5		; SAVE A5
	PUSH	S,A6		; SAVE A6
	PUSH	S,A3		; SAVE A3
	GOTO	(A2)		; EXIT SAVE


	; RESTORE THEM

REST:	POP	S,A3		; RESTORE A3
	POP	S,A6		; RESTORE A6
	POP	S,A5		; RESTORE A5
	POP	S,A4		; RESTORE A4
	GOTO	(A2)		; EXIT REST
	RELOC

CHAR1:	0			; 1ST NL CHAR
CHAR2:	0			; 2ND NL CHAR
FFCNT:	0			; FORM-FEED COUNT
FFCNT2:	0			; FLAG -- NUMBER OF NL CHARS
STCFL:	0			; FLAG -- NUMBER OF NL CHARS

	RELOC
;  *********  QUOTED DELIMITER WORDS  *********

	; SET UP

SQUOTE:	IMEZ	SQSW		; IF NO QUOTED RESERVED WORDS
	GOTO	ILLEGAL		; THEN THIS IS AN ERROR
	JSP	A6,GETCHR	; READ A CHARACTER
	IAEI	A2,3
	GOTO	GETCHR		; IGNORE SPACES AND TABS
	JUMPGE	A2,SQILL	; MUST BE A LETTER
	L	A5,RESWRD-.A(A1); GET THE RESERVED WORD TABLE SUBLIST
	ST	A5,RWSL		; SAVE IT FOR LATER
	SETZB	A2,SAVED	; ZERO A2 AND SAVED 1ST WORD OF NAME
	HRLZI	A5,-5		; READ 5 CHARS

	; CHARACTER-READING LOOP

SQ1:	LSHC	A1,-6		; SHIFT CHAR INTO A2
	ILDB	A1,P		; READ NEXT CHAR
	AOS	CC		; STEP CHAR COUNT
	IMGEZ	A4,CTABLE(A1)	; GET THE CHARS TABLE ENTRY
	GOTO	@TABLE0(A4)	; GOT ROUTINE IF NOT A LETTER

SQ2:	AOBJN	A5,SQ1		; LOOP

	; NAME LONGER THAN 1 WORD

	IMGZ	SAVED		; IF 2ND TIME HERE THEN
	GOTO	SQILL		; THIS IS AN ERROR
	ST	A2,SAVED	; SAVE THE 1ST 5 CHARS OF THE NAME
	SETZ	A2,		; CLEAR F
	HRLI	A5,-6		; READ 6 MORE CHARS
	GOTO	SQ1		; RETURN TO THE LOOP


TABLE0:	SQILL	; DELIMITERS
	SQILL	; FLAGGED DELIMITERS
	SQ1+1	; IGNORABLE CHARS
	SQ1+1	; SPACE & TAB
	SQNL	; NEW-LINE
	SQLOW	; LOWER CASE LETTER
	SQILL	; OTHER
	SQOK	; SINGLE QUOTE
; LOWER CASE LETTER SCANNED

SQLOW:	LI	A1,-40(A1)	; CONVERT TO UPPER CASE
	GOTO	SQ2		; RETURN TO LOOP


	; A NEW-LINE CHARACTER WAS SCANNED

SQNL:	PUSHJ	S,NCHECK	; CHECK IF END OF BUFFER
	GOTO	SQ1+2		; END OF BUFFER, CONTINUE AS IF NOTHING
	GOTO	SQILL		; END OF LINE, ERROR


	; SOMETHING IS WRONG WITH DELIMITER WORD

	JSP	A6,GETCHR	; READ THE NEXT CHAR
SQILL:	FAIL	(92,HARD,IMM,IMPROPER WORD DELIMITER)
	LI	A3,0		; RETURN THE NULL DELIMITER
	POPJ	S,		; EXIT LSCAN


	; MATCHING QUOTE FOUND, LOOK IT UP IN RESERVED WORD TABLE

SQOK:	IMNZ	A1,SAVED	; FETCH 1ST WORD, SKIP IF NONE
	EXCH	A1,A2		; A1=2ND WORD, A2=1ST WORD
	L	A6,A2		; MOVE 1ST WORD TO A6
	IORI	A6,(A5)		; INCLUDE THE CHAR COUNT
	LI	A3,A1-1		; LET A3 POINT TO THE 2ND WORD
	PUSHJ	S,SQ3		; SEARCH THE RESERVED WORD TABLE
	GOTO	.+2		; DELIMITER
	GOTO	SQOK1		; NOT FOUND

	; FOUND IN RESERVED WORD TABLE

	IBP	P		; READ THE NEXT CHAR
	AOS	CC		; STEP THE CHARACTER COUNT
	POPJ	S,		; EXIT LSCAN
	; PROBABLY "TRUE" OR "FALSE" SCANNED

SQOK1:	IMBM	A3,4+LEFT	; UNLESS IT IS 'TRUE' OR 'FALSE'
	GOTO	SQILL		; IT IS AN ERROR
	IBP	P		; READ THE NEXT CHAR
	AOS	CC		; STEP THE CHARACTER COUNT
	AOS	LSBUFP		; UNDO THE SOS DONE BY SQ3
	AOS	(S)		; SKIP RETURN
	POPJ	S,		; EXIT LSCAN



ALTRWT:	BLOCK	^D26		; ALTERNATE RESERVED WORD TABLE

	RELOC

SAVED:	0			; SAVED 1ST 5 CHARS OF NAME
SQSW:	0			; QUOTED RESERVED WORD SWITCH
RWS:	0			; RESERVED WORD TABLE POINTER

	RELOC
SUBTTL	**  SEARCH  **

;   SYMBOL TABLE ENTRY:
;
;          !-----------------!    WORD 1-LEFT  BIT  0:     DYNAMIC
;          !        !        !                 BITS 1-2:   KIND
;  WORD-0  ! BL/PL  !  LINK  !                 BITS 3-8:   TYPE
;          !        !        !                 BITS 9-11:  STATUS
;          !--------!--------!                 BIT  12:    1=DECLARED
;          !        !        !                 BITS 13-17: NUMBER OF ACTUALS
;  WORD-1  ! LEXEME !  VALUE ! 
;          !        !        !
;          !-----------------!    WORD 0-LEFT  BIT  0:     1=EXTENDED ENTRY
;          !                 !                 BIT  1:     1=MESSAGE GIVEN
;  WORD-2  !      NAME       !                 BIT  2:     (NOT USED)
;                                              BITS 3-11:  BLOCK LEVEL
;          !                 !                 BITS 12-17: PROCEDURE LEVEL
;          !                 !
;          !-----------------!
;          !                 !
;          ! EXTENSION WORD1 !
;          !                 !
;          !-----------------!    NOTE:  THE EXTENSION WORDS ARE OPTIONAL
;          !                 !
;          ! EXTENSION WORD2 !
;          !                 !
;          !-----------------!
;
;
;
;
;
;	*****  S E A R C H  *****
;
;	"SEARCH" IS USED TO LOOK UP AN IDENTIFIER IN THE SYMBOL 
;	TABLE. "SEARCH" USES AS INPUT THE BUFFER ADDRESS CONTAINED
;	IN NSYM AND OUTPUTS THE IDENTIFIER'S LEXEME INTO SYM.
;
;	IF THE IDENTIFIER IS NOT FOUND IN THE SYMBOL TABLE, "SEARCH"
;	WILL AUTOMATICLY PUT IT INTO THE TABLE UNLESS THE GLOBAL
;	BOOLEAN "NOENTRY" IS SET TO 1.
;
;	IF THE GLOBAL BOOLEAN "DECLAR" IS SET TO 1 THEN "SEARCH"
;	WILL SEARCH ONLY THE CURRENT BLOCK LEVEL PORTION OF THE
;	SYMBOL TABLE.  "DECLAR" INDICATES DECLARATION MODE.
SEARCH:	L	A3,NSYM		; GET NSYM
	L	A2,(A3)		; GET 1ST WORD OF NAME
	L	A4,A2		; COPY TO A4
	MULI	A4,RANDOM	; RANDOMIZE
	ANDI	A4,177		; USE 7 BITS FOR HASH INDEX
	IMEZ	A1,SYMHT(A4)	; LOCATE 1ST ENTRY IN SUBLIST
	GOTO	NEWSYM		; -NONE, MUST BE A NEW SYMBOL

SERCH1:	IMBZ	FL,DECLAR	; ARE WE IN DECLARATION MODE?
	GOTO	LOOP3+1		; -NO, GOTO 3-INST LOOP
	SKIPA	A5,STBB		; LOAD BLOCK POINTER, SKIP

	; 4-INST LOOP FOR DECLARATION MODE

LOOP4:	HRRZ	A1,SYMLNK(A1)	; LOCATE NEXT SUBLIST ENTRY
	IAGI	A5,(A1)		; WITHIN CURRENT BLOCK?
	GOTO	NEWSYM		; -NO, MUST BE NEW
	IANM	A2,SYMNAM(A1)	; 1ST WORDS SAME?
	GOTO	LOOP4		; -NO, LOOP
	GOTO	SERCH2		; -YES, CHECK REMAINDER


	; 3-INST LOOP FOR NORMAL MODE

LOOP3:	HRRZ	A1,SYMLNK(A1)	; LOCATE NEXT SUBLIST ENTRY
	IANM	A2,SYMNAM(A1)	; 1ST WORDS MATCH?
	GOTO	LOOP3		; -NO, LOOP

	IMBZ	A1,777777	; LINK TO ZERO?
	GOTO	NEWSYM		; -YES, MATCH NOT REALLY FOUND

	; MATCH FOUND ON 1ST WORDS

SERCH2:	IMEZ	A6,-1(A3)	; GET LENGTH OF NAME
	GOTO	SERCH3		; -IS 1 WORD LONG, DONE
	ADD	A1,[		; SET UP REGISTER FOR
	XWD	A6,SYMNAM]	;  INDIRECT ADDRESSING
	L	A5,@A3		; GET A WORD FROM BUFFER
	IANM	A5,@A1		; COMPARE TO WORD IN ENTRY
	GOTO	SERCH4		; -MISMATCH
	SOJG	A6,.-3		; -MATCH. LOOP
	LI	A1,-SYMNAM(A1)	; CORRECT ADDRESS
				; -END OF NAME, SEARCH COMPLETE
	; END OF NAME, SYMBOL FOUND

SERCH3:	HLL	A1,SYMTYP(A1)	; LOAD LEXEME
	L	SYM,A1		; MOVE LEXEME TO SYM
	SMBZ	SYM,37+LEFT	; ZERO THE 5 BITS
	SMBO	SYM,$ST+LEFT	; MARK LEXEME A VARIABLE, SIMPLE
	IMBZ	FL,BPAIR	; IF NOT SCANNING A BOUND PAIR, THEN
	POPJ	S,		; EXIT SEARCH
	LDB	A4,[		; GET THE ENTRY'S BLOCK LEVEL
	POINT	9,SYMBLK(SYM),11] ; POINTER TO BLOCK LEVEL FIELD
	IANM	A4,BLOCKL	; IF NOT THE SAME AS CURRENT BLOCK LEVEL
	POPJ	S,		; THEN OK, EXIT SEARCH
	FAIL	(84,HARD,NSYM,VARIABLE CANT BE USED HERE)
	POPJ	S,		; EXIT SEARCH


	; SYMBOL NOT IN SYMBOL TABLE

NEWSYM:	IMBM	FL,NOENTR	; SHOULD AN ENTRY BE MADE?
	GOTO	NONEW		; -NO, SKIP
	L	A6,-1(A3)	; GET NAME LENGTH
	PUSHJ	S,GETSYM	; GET SOME SPACE IN SYMBOL TABLE
	PUSHJ	S,LINKUP	; FILL THE ENTRY AND LINK IT UP
	HRLI	A1,$ST		; MARK LEXEME A VARIABLE, SIMPLE
	SKIPA	SYM,A1		; MOVE LEXEME TO SYM

NONEW:	LI	SYM,0		; RETURN A NULL SYMBOL
	POPJ	S, 		; EXIT SEARCH

SERCH4:	HRRZ	A1,SYMLNK-SYMNAM(A1); LOCATE NEXT ENTRY ON SUBLIST
	GOTO	SERCH1		; RETURN TO LOOP



GETSYM:	LI	A5,SYMNAM+1(A6)	; TOTAL LENGTH OF NEW ENTRY

	; ACQUIRE SOME SPACE IN SYMBOL TABLE

GETSPC:	HRRZ	A1,NASTE	; LOCATE NEXT AVAIL ENTRY
	ADDB	A5,NASTE	; COMPUTE NEW NEXT ENTRY
	IAGM	A5,NAFTE	; CHECK FOR TABLE OVERFLOW
	GOTO	OVFL1		; -OVERFLOW, MOVE THE TABLES, EXIT
	POPJ	S,		; EXIT
	; COMPUTE AN ENTRY'S HASH VALUE AND NAME LENGTH IN WORDS-1

HAL:	L	A4,SYMNAM(A3)	; GET 1ST WORD OF NAME
	MULI	A4,RANDOM	; RANDOMIZE
	ANDI	A4,177		; SAVE 7 BITS FOR HASH
	L	A5,SYMNAM(A3)	; GET 1ST WORD OF NAME
	LI	A5,1(A5)	; ADD 1
	ANDI	A5,77		; SAVE ONLY LENGTH BYTE
	IDIVI	A5,6		; DIVIDE BY 6 CHARS/WORD
	LI	A6,(A5)		; COPY IN A6
	POPJ	S,		; EXIT



	; LINK NEW ENTRY INTO SYMBOL TABLE

LINKUP:	L	A5,SYMHT(A4)	; PUT NEW ENTRY ON TOP OF
	ST	A1,SYMHT(A4)	; HASH TABLE SUBLIST
	L	A2,BLKLEV	; GET BLOCK LEVEL
	LSH	A2,6		; SHIFT IT 6
	IOR	A2,FNLEVE	; INCLUDE FUNCTION LEVEL
	HRL	A5,A2		; PUT WITH NEW LINK
	ST	A5,SYMLNK(A1)	; SET LINK FIELD
	ZERO	SYMTYP(A1)	; CLEAR TYPE & VALUE
	LI	A5,SYMNAM(A1)	; SET UP FOR
	HRLI	A5,A6		; INDIRECT ADDRESSING

LNKUP1:	L	A2,@A3		; GET WORD FROM SOURCE
	ST	A2,@A5		; PUT IN SYMBOL TABLE ENTRY
	SOJGE	A6,LNKUP1	; LOOP TILL DONE
	POPJ	S,		; DONE
SUBTTL	** STADD & EXTEND & TOFIX **

;	*****  S T A D D  *****
;	
;	"STADD" WILL MAKE A NEW ENTRY IN THE SYMBOL TABLE FOR A NEW
;	IDENTIFIER WHOSE NAME IS THE SAME AS THE IDENTIFIER NAMED
;	IN SYM.  SINCE "STADD" IS USED ONLY FOR LABELS, "STADD"
;	WILL AUTOMATICALLY EXTEND THIS ENTRY.  THE LEXEME FOR THIS
;	NEW ENTRY REPLACES THAT WHICH IS IN SYM.  THE VALUE FIELD OF THE
;	NEW ENTRY WILL POINT TO THE OLD ENTRY.
;
;
STADD:	IFN	EXPER,<
	PUSHJ	S,X14		; SAVE REGISTERS
>
	LI	A3,(SYM)	; GET ADDR OF OLD ENTRY
	PUSHJ	S,HAL		; GET HASH AND LENGTH OF ENTRY
	PUSHJ	S,GETSYM	; GET SOME SPACE IN SYMBOL TABLE
	LI	A3,SYMNAM(A3)	; ADDRES OF NAME FIELD
	HRLI	A3,A6		; SET UP FOR INDIRECT ADDRESSING
	PUSHJ	S,LINKUP	; LINK UP THE NEW ENTRY
	HRRM	SYM,1(A1)	; CHAIN NEW ENTRY TO OLD ENTRY
	HRRZI	SYM,(A1)	; MOVE ADDR TO SYM
	IFN	EXPER,<
	PUSHJ	S,X15		; CHECK REGISTERS FOR CLOBBERS
>

	RANDOM=647327


;	*****  E X T E N D  *****
;
;	THE ENTRY NAMED IN SYM IS EXTENDED BY 2 WORDS.
;
;
EXTEND:	IFN	EXPER,<
	PUSHJ	S,X14		; SAVE REGISTERS
	LI	A3,(SYM)	;;;;; TEMPORARY CHECK FOR LAST ENTRY ;;;;;
	PUSHJ	S,HAL
	ADDI	A6,SYMNAM+1(SYM)
	IANM	A6,NASTE
	GOTO	EXTERR
>
	LI	A5,2		; GET TWO MORE WORDS FROM
	PUSHJ	S,GETSPC	; THE SYMBOL TABLE
	ZERO	(A1)		; ZERO 1ST WORD OF EXTENSION
	ZERO	1(A1)		; ZERO 2ND WORD OF EXTENSION
	HRLZI	A5,400000	; SET EXTEND BIT ON
	IORM	A5,(SYM)	; PUT IN ENTRY
	IFN	EXPER,<
	PUSHJ	S,X15		; CHECK REGISTERS FOR CLOBBERS
>
	POPJ	S,		; EXIT EXTEND

	IFN EXPER, <
EXTERR:	TTCALL	3,EERR
	GOTO	TERMIN

EERR:	ASCIZ	/ATTEMPT TO EXTEND OTHER THAN LAST ENTRY
/>
;	*****  T O F I X  *****
;
;	PUT HALFWORD INTO FIX-UP TABLE
;
;
.TOFIX:	LI	A4,1		; LOAD A 1
	XORB	A4,TOFIXI	; DECIDE WHICH HALF
	IAEI	A4,1		; IF RIGHT HALF
	GOTO	TOFIX1		; THEN GET ANOTHER WORD IN TABLE
	L	A4,NAFTE	; LOCATE WORD -1
	HRLM	A2,1(A4)	; PUT HALFWORD INTO TABLE
	POPJ	S,		; EXIT TOFIX


TOFIX1:	SOS	A4,NAFTE	; STEP TO NEXT AVAIL WORD IN FIX-UP TABLE
	IAGEM	A4,NASTE	; IF SUFFICIENT SPACE IN FIXUP TABLE
	GOTO	.+3		; THEN SKIP THIS PART
	PUSHJ	S,OVFL1		; THEN MOVE THE TABLES
	ADDI	A4,DELTA	; USE CORRECT POINTER
	HRRZM	A2,1(A4)	; PUT HALFWORD INTO TABLE
	POPJ	S,		; EXIT TOFIX

	RELOC

TOFIXI:	0			; "TOFIX" HALFWORD POINTER

	RELOC
SUBTTL	** RUND **

;	*****  R U N D  *****
;
;	"RUND" ADVANCES THE WINDOW BY PUTTING NSYM INTO SYM, NDEL
;	INTO DEL, AND CALLING "LSCAN" TO OBTAIN NEW LEXEMES FOR 
;	NSYM AND NDEL.  IF NSYM CONTAINED AN IDENTIFIER BUFFER
;	ADDRESS, THE LEXEME IS OBTAINED BY CALLING "SEARCH".
;	"RUND" WILL INSERT NULL-SYMBOLS BETWEEN CONSECUTIVE 
;	DELIMITERS, AND WILL INSERT NULL DELIMITERS BETWEEN CONSECUTIVE
;	SYMBOLS.  "RUND" WILL COMPUTE "LEXEX" AND "COMPNAME", AND
;	WILL CORRECTLY BUFFER THE CHARACTER COUNTERS SO THAT THEY CAN
;	BE FOUND BY THE ROUTINES THAT PRINT THE UP-ARROWS IN
;	ERROR MESSAGES.
;
;
RUND:	IFN	EXPER,<
	PUSHJ	S,X14		; SAVE REGISTERS
>

	; SHIFT WINDOW

	L	SYM,NSYM	; MOVE NSYM TO SYM
	IMBM	SYM,$SYMB	; UNLESS THIS IS A CONSTANT
	PUSHJ	S,SEARCH	; GET LEXEME, PUT IN SYM
	L	DEL,NDEL	; THE LEFT
	JUMPE	DEL,RUND2	; -RUND PREVIOUSLY SCANNED 2 SYMS IN A ROW

	; SCAN NEXT ITEM

	PUSHJ	S,LSCAN		; SCAN NEXT ITEM
RUND0:	GOTO	RUND3		; -A DELIM WAS SCANNED (2ND IN A ROW)
	L	A2,CC		; LOAD POINTER FOR ERR MSG UP-ARROW

RUND1:	LI	A4,2
	XORB	A4,PLIST	; ALTERNATE BETWEEN TWO POINTER BUFFERS
	ST	A2,(A4)		; SAVE READ POINTER
	ST	A3,NSYM		; PUT LEXEME IN NSYM

	; SCAN ANOTHER ITEM

	PUSHJ	S,LSCAN		; SCAN ANOTHER ITEM

RUND5:	GOTO	RUND4		; -A DELIM WAS SCANNED
	; SCANNED 2 NON-DELIMITERS IN A ROW

	ST	A3,DOUBLE	; -ANOTHER SYM SCANNED, SAVE FOR NEXT RUND
	L	A2,CC		; LOAD POINTER FOR ERR MSG UP-ARROW
	ST	A2,DOUBLP	; SAVE THE POINTER FOR LATER TOO
	L	A4,PLIST	; POINTER BUFFER
	L	A2,(A4)		; GET POINTER TO SYM
	SMBO	A2,EXACT	; USE EXACT POINTER
	ST	A2,1(A4)	; USE THIS POINTER FOR NULLDELIMITER
	ZERO	NDEL		; PUT NULL-DELIM INTO NDEL
	GOTO	RUND7		; CONTINUE

	; FETCH THE SAVED 2ND SYMBOL

RUND2:	L	A3,DOUBLE	; RETRIEVE OLD DOUBLE SYM
	L	A2,DOUBLP	; RETRIEVE ITS POINTER TOO
	GOTO	RUND1		; CONTINUE ON


	; DELIMITER ONLY, NO SYMBOL

RUND3:	ST	A3,NDEL		; PUT LEXEME IN NDEL
	ZERO	NSYM		; PUT NULL SYMBOL IN NSYM
	L	A4,PLIST	; POINTER BUFFER
	L	A2,1(A4)	; GET POINTER TO SYM
	SMBO	A2,EXACT	; USE EXACT POINTER
	LI	A4,2		; HERE IT IS AGAIN
	XORB	A4,PLIST	; ALTERNATE BETWEEN TWO POINTER BUFFERS
	ST	A2,(A4)		; SAVE NULL-SYMBOL POINTER
	L	A2,CC		; LOAD POINTER FOR ERR MSG UP-ARROW
	ST	A2,1(A4)	; SAVE READ POINTER
	GOTO	RUND7		; CONTINUE


	; SCANNED A SYMBOL FOLLOWED BY A DELIMITER

RUND4:	ST	A3,NDEL		; PUT LEXEME IN NDEL
	L	A4,PLIST	; RELOAD ADDR OF CURRENT POINTER BUFFER
	L	A2,CC		; LOAD POINTER FOR ERR MSG UP-ARROW
	ST	A2,1(A4)	; SAVE READ POINTER
	; COMPUTE LEXEX AND COMPNAME

RUND7:	IMBZ	SYM,$SYMB	; IF CONSTANT OR NULL SYMBOL
	GOTO	RUND6		; THEN SKIP THIS
	LDB	A4,[		; PICK UP THE BLOCK LEVEL
	POINT	9,SYMBLK(SYM),11] ; POINTER TO BLOCK LEVEL FIELD
	SETCM	A5,SYM		; COMPLEMENT THE LEXEME
	IMBZ	A5,$FON+LEFT	; IF FORMAL-BY-NAME
	GOTO	IRREG		; THEN ONES COMP BL
	IMBM	A5,$PRO+LEFT	; IF IT IS NOT A PROCEDURE
	GOTO	REGUL		; THEN POSITIVE BL
	HRRZ	A5,SYM		; GET SYMBOL TABLE ADDRESS ALONE
	IALI	A5,B0END	; IF A LIBRARY PROCEDURE
	GOTO	REGUL		; THEN POSITIVE BL

	; IF FORMAL BY NAME OR NON-LIBRARY PROCEDURE, LEXEX=-BL-1

IRREG:	ADDI	A4,1		; PLUS 1
	LSH	A4,^D27		; SHIFT BL+1 TO POSITION
	MOVNM	A4,LEXEX	; NEGATE AND MOVE TO LEXEME EXTENSION
	ZERO	COMPNAME	; ZERO COMPNAME
	IFN	EXPER,<
	PUSHJ	S,X15		; CHECK REGISTERS FOR CLOBBERS
>
	POPJ	S,		; EXIT RUND


	; FOR ALL OTHERS, LEXEX=BL, COMPNAME=A RANDOM BIT ON

REGUL:	LSH	A4,^D27		; SHIFT BL INTO POSITION
	ST	A4,LEXEX	; STORE IN LEXEME EXTENSION
	L	A4,SYM		; GET SYMBOL TABLE ADDRESS
	ANDI	A4,37		; SAVE FIVE BITS
	LI	A5,1		; PUT A 1 IN ACCUMULATOR
	LSH	A5,(A4)		; SHIFT IT RANDOMLY
	ST	A5,COMPNAME	; STORE IT IN COMPNAME
	IFN	EXPER,<
	PUSHJ	S,X15		; CHECK REGISTERS FOR CLOBBERS
>
	POPJ	S,		; EXIT RUND


	; DONT COMPUTE LEXEX OR COMPNAME FOR A CONSTANT OR NULL SYMBOL

RUND6:	ZERO	LEXEX		; CLEAR LEXEME EXTENSION
	ZERO	COMPNAME	; CLEAR COMPOSIT NAME
	IFN	EXPER,<
	PUSHJ	S,X15		; CHECK REGISTERS FOR CLOBBERS
>
	POPJ	S,		; EXIT RUND
.SCRUND: IFN	EXPER,<
	PUSHJ	S,X14		; SAVE REGISTERS
>
	L	A4,PLIST	; ADDRESS OF SAVED POINTER
	L	A4,(A4)		; TO NSYM. GET IT
	LI	A5,2		; ADDRESS OF POINTER BUFFER FOR
	XOR	A5,PLIST	; SYM
	ST	A4,(A5)		; SET SYM POINTER
	ST	A4,1(A5)	; SET DEL POINTER
	GOTO	RUND7



	RELOC

DOUBLE:	0			; SAVE AREA FOR CASE OF DOUBLE -SYMBOL
DOUBLP:	0			; SAVE AREA FOR ITS POINTER

	RELOC

	IFN	EXPER,<
X15:	IANM	A7,REG2
	PUSHJ	S,X5
	L	A7,REG2
	IANM	A14,REG2+1
	PUSHJ	S,X5
	L	A14,REG2+1
	IANM	DBASE+1,REG2+2
	PUSHJ	S,X5
	L	DBASE+1,REG2+2
	IANM	A12,REG2+3
	PUSHJ	S,X5
	L	A12,REG2+3
	IANM	A13,REG2+4
	PUSHJ	S,X5
	L	A13,REG2+4
	IANM	DBASE,REG2+5
	PUSHJ	S,X5
	L	DBASE,REG2+5
	POPJ	S,
X14:	ST	A7,REG2
	ST	A14,REG2+1
	ST	DBASE+1,REG2+2
	ST	A12,REG2+3
	ST	A13,REG2+4
	ST	DBASE,REG2+5
	POPJ	S,

	RELOC

REG2:	BLOCK	6

	RELOC
>
SUBTTL	** ERROR MESSAGE TEXT TABLE **

	IFN	MTEXT,<
TTABLE:


[ASCIZ		/PROBABLY SEMICOLON OMITTED/],,
[ASCIZ		/UNDECLARED IDENTIFIER/]				; 1
[ASCIZ		/INCORRECT STATEMENT/],,
[ASCIZ		/INCORRECT EXPRESSION/]					; 3
[ASCIZ		/PROBABLY OPERATOR OMITTED/],,
[ASCIZ		/IDENTIFIER OR CONSTANT MISSING/]			; 5
[ASCIZ		/INCORRECT DESIGNATIONAL EXPRESSION/],,
[ASCIZ		/INCORRECT OR UNPARENTHESIZED ASSIGNMENT/]		; 7
[ASCIZ		/SYMBOL NOT PERMITTED HERE/],,
[ASCIZ		/AMBIGUOUS USE OF COLON/]				; 9
[ASCIZ		/SEMICOLON PROBABLY SUPERFLUOUS/],,
[ASCIZ		/ONLY LETTER STRING ALLOWED/]				; 11
[ASCIZ		/THIS DELIMITER IS NOT PERMITTED BEFORE DO/],,
[ASCIZ		/WHILE STATEMENT IS NOT ALLOWED BETWEEN THEN AND ELSE/]	; 13
[ASCIZ		/THEN MUST NOT BE FOLLOWED BY IF/],,
[ASCIZ		/THEN STATEMENT NOT FOUND/]				; 15
[ASCIZ		/DECLARATIONS MUST BE TERMINATED BY SEMICOLON/],,
[ASCIZ		/THIS IS NOT ALLOWED AFTER END/]			; 17
[ASCIZ		/CANNOT BE USED AS ARGUMENT/],,
[ASCIZ		/ARGUMENT TOO LARGE/]					; 19
[ASCIZ		/PROBABLY END OMITTED/],,
[ASCIZ		/COMPLEX ARITHMETIC NOT IMPLEMENTED/]			; 21
[ASCIZ		/DECLARATOR LONG MUST BE FOLLOWED BY REAL/],,
[ASCIZ		/NOT PERMITTED AS DECLARATOR/]				; 23
[ASCIZ		/NOT PERMITTED AS SPECIFIER/],,
[ASCIZ		/INCORRECT DECLARATION OR SPECIFICATION/]		; 25
[ASCIZ		/NO DECLARATION SHOULD FOLLOW PROCEDURE DECLARATION/],,
[ASCIZ		/IMPROPER ARRAY DELARATION OR SPECIFICATION/]		; 27
[ASCIZ		/DELIMITER MUST NOT BE DECLARED OR SPECIFIED/],,
[ASCIZ		/PROBABLY LIST ELEMENT MISSING/]			; 29
[ASCIZ		/IMPROPER DECLARATION/],,
[ASCIZ		/VALUE WAS ALREADY SPECIFIED/]				; 31
[ASCIZ		/IMPROPER TYPE OF FORMAL IN VALUELIST/],,
[ASCIZ		/NON-FORMALS MUST NOT BE SPECIFIED/]			; 33
[ASCIZ		/BOUND PAIR NOT FOUND/],,
[ASCIZ		/INCORRECT BOUND PAIR/]					; 35
[ASCIZ		/PROBABLY RIGHT BRACKET OMITTED/],,
[ASCIZ		/TYPE DOES NOT MATCH FORWARD DECLARATION/]		; 37
[ASCIZ		/:= MISSING IN SWITCH DECLARATION/],,
[ASCIZ		/PROCEDURE NESTING TOO DEEP/]				; 39
[ASCIZ		/NOT SIMPLE IDENTIFIER IN FORMAL LIST/],,
[ASCIZ		/FORMAL LIST NOT PROPERLY TERMINATED/]			; 41
[ASCIZ		/PROBABLY ; MISSING IN PROCEDURE HEADING/],,
[ASCIZ		/NOT ALL FORMALS HAVE BEEN SPECIFIED/]			; 43
[ASCIZ		/INCORRECT STRUCTURED FORMAL LIST/],,
[ASCIZ		/UNTIL EXPRESSION NOT FOUND/]				; 45
[ASCIZ		/BYTE SELECTOR NOT PERMITTED AS CONTROLLED VARIABLE/],,
[ASCIZ		/ASSIGNMENT DELIMITER NOT FOUND/]			; 47
[ASCIZ		/DELIMITER "DO" NOT FOUND/],,
[ASCIZ		/ASSIGNMENT HAS NON-MATCHING TYPES/]			; 49
[ASCIZ		/PROBABLY DELIMITER OMITTED/],,
[ASCIZ		/CANNOT BE USED AS UNARY OPERATOR/]			; 51
[ASCIZ		/CANNOT BE USED AS BINARY OPERATOR/],,
[ASCIZ		/THEN EXPRESSION NOT FOUND/]				; 53
[ASCIZ		/CONDITIONAL EXPRESSION MUST HAVE ELSE PART/],,
[ASCIZ		/CONDITIONAL EXPRESSION MUST BE PARENTESIZED/]		; 55
[ASCIZ		/IMPROPER SEQUENCE OF DELIMITERS/],,
[ASCIZ		/WRONG NUMBER OF DIMENSIONS/]				; 57
[ASCIZ		/TOO MANY PARAMETERS FOR STANDARD FUNCTION/],,
[ASCIZ		/NON-TYPE PROCEDURE AS EXPRESSION/]			; 59
[ASCIZ		/MATCHING CLOSE PARENTHESIS NOT FOUND/],,
[ASCIZ		/INCORRECT NUMBER OF ACTUAL PARAMETERS/]		; 61
[ASCIZ		/FORWARD HAS NO MATCHING DECLARATION IN SAME BLOCK/],,
[ASCIZ		/FORWARD DECLARATION NOT ALLOWED FOR THIS TYPE/]	; 63
[ASCIZ		/FORWARD DECLARATION WAS REQUIRED/],,
[ASCIZ		/TYPES DO NOT MATCH/]					; 65
[ASCIZ		/STACK ADDRESS OVERFLOW/],,
[ASCIZ		/NON-INTEGER OPERAND FOR DELIMITER REM OR DIV/]		; 67
[ASCIZ		/COMPLEX ARITHMETIC NOT IMPLEMENTED/],,
[ASCIZ		/NON-ARITHMETIC OPERAND FOR ARITHMETIC OPERATOR/]	; 69
[ASCIZ		/NON-ARITHMETIC OPERAND FOR RELATIONAL OPERATOR/],,
[ASCIZ		/NON-BOOLEAN OPERAND FOR BOOLEAN OPERATOR/]		; 71
[ASCIZ		/DELIMITER NOT REQUIRES BOOLEAN OPERAND/],,
[ASCIZ		/UNARY + AND - REQUIRE ARITHMETIC OPERAND/]		; 73
[ASCIZ		/OVERFLOW WHILE COMBINING CONSTANTS/],,
[ASCIZ		/OVERFLOW IN LONG REAL OPERATION ON CONSTANTS/]		; 75
[ASCIZ		/OVERFLOW OR UNDEFINED RESULT FOR "CONSTANT ^ CONSTANT"/],,
[ASCIZ		/PARAMETER FOR STANDARD FUNCTION MUST BE ARITHMETIC/]	; 77
[ASCIZ		/STANDARD FUNCTION "INT" REQUIRES BOOLEAN PARAMETER/],,
[ASCIZ		/STANDARD FUNCTION "BOOL" REQUIRES ARITHMETIC OPERAND/]	; 79
[ASCIZ		/PARAMETER MUST BE OF ARITHMETIC TYPE/],,
[ASCIZ		/FOR STATEMENT NOT ALLOWED BETWEEN THEN AND ELSE/]	; 81
[ASCIZ		/SWITCH IDENTIFIER NOT ALLOWED HERE/],,
[ASCIZ		/EXPRESSION TOO LONG/]					; 83
[ASCIZ		/IDENTIFIER DECLARED IN THIS BLOCK NOT PERMITTED HERE/],,
[ASCIZ		/INCORRECT FILE OR BLOCK STRUCTURE/]			; 85
[ASCIZ		/INCORRECT BLOCK STRUCTURE;TOO MANY ENDS/],,
[ASCIZ		/PROCEDURE INCORRECTLY TERMINATED/]			; 87
[ASCIZ		/INCORRECT FILE STRUCTURE/],,
[ASCIZ		/EMPTY SOURCE FILE/]					; 89
[ASCIZ		/INVALID CONSTANT/],,
[ASCIZ		/IDENTIFIER EXCEEDS 64 CHARACTERS/]			; 91
[ASCIZ		/IMPROPER WORD DELIMITER/],,
[ASCIZ		/CHARACTER NOT LEGAL IN ALGOL/]				; 93
[ASCIZ		/EXPONENT TOO SMALL/],,
[ASCIZ		/EXPONENT TOO LARGE/]					; 95
[ASCIZ		/DECLARATION FOLLOWS STATEMENT/],,
[ASCIZ		/IMPROPER USE OF PERIOD/]				; 97
[ASCIZ		/INTEGER CONSTANT CONVERTED TO TYPE REAL/],,
[0]									; 99
[ASCIZ		/N EXPRESSION/],,
[ASCIZ		/ STATEMENT/]						; 101
[ASCIZ		/ BOOLEAN EXPRESSION/],,
[ASCIZ		/ DESIGNATIONAL EXPRESSION/]				; 103
[ASCIZ		/ LABEL IDENTIFIER/],,
[ASCIZ		/ LABEL IDENTIFIER/]					; 105
[ASCIZ		/N UNDECLARED (UNSPECIFIED) IDENTIFIER/],,
[ASCIZ		/N ARITHMETIC EXPRESSION/]				; 107
[ASCIZ		/ NEW IDENTIFIER/],,
[ASCIZ		/N ARITHMETIC EXPRESSION/]				; 109
[ASCIZ		/N ARITHMETIC EXPRESSION/],,
[ASCIZ		/N ARITHMETIC EXPRESSION/]				; 111
[ASCIZ		/N ARITHMETIC VARIABLE/],,
[ASCIZ		/ VARIABLE/]						; 113
[ASCIZ		/ STRING EXPRESSION/],,
[ASCIZ		/ BOOLEAN OR ARITHMETIC EXPRESSION/]			; 115
[ASCIZ		/ BOOLEAN OR ARITHMETIC EXPRESSION/],,
[ASCIZ		/N ARRAY IDENTIFIER/]					; 117
[ASCIZ		/N ARITHMETIC EXPRESSION/],,
[ASCIZ		/ SWITCH IDENTIFIER/]					; 119
[ASCIZ		/N ACTUAL PARAMETER/],,
[ASCIZ		/ PROCEDURE IDENTIFIER/]				; 121
[ASCIZ		/N ARITHMETIC EXPRESSION/],,
[ASCIZ		/N ARITHMETIC EXPRESSION/]				; 123
[ASCIZ		/ STRING VARIABLE/],,
[ASCIZ		/ BOOLEAN OR ARITHMETIC EXPRESSION/]			; 125
>
;	"BMOVE" WITH "RLIST" AS ITS PARAMETER IS USED TO INITIALIZE
;	THE READ MODULE'S LOW-SEGMENT FROM THE HIGH-SEGMENT.

RLIST:
	XWD	FAILX,12
	PUSH	S,A1
	PUSH	S,A2
	L	A1,@-2(S)
	ST	A1,FAILX1
	PUSHJ	S,.FAIL
	0
	POP	S,A2
	POP	S,A1
	AOS	(S)
	POPJ	S,

	XWD	.STOVE+1,1
	GOTO	OVFL5

	XWD	.JBAPR,1
	GOTO	OVFL4

	XWD	OLIST,3
	14
	0
	XWD	BHEAD1,0

	XWD	LLIST,3
	0
	0
	XWD	BHEAD2,0

	XWD	SLIST,3
	0
	0
	XWD	0,BHEAD3

	XWD	CSLIST,3
	1
	SIXBIT	/TTY/
	XWD	STHEAD,CSHEAD

	XWD	BUF0,2
	0
	XWD	5,BUF0+1

	0
	0
SUBTTL OUTPUT MODULE

;   THIS MODULE CONTAINS THE FOLLOWING ROUTINES
;
;
;	.MABS	(MOVE ABSOLUTE)		WRITE OUT 1 WORD
;					A1=VALUE
;					NO RELOCATION
;
;	.MREL	(MOVE RELOCATED)	WRITE OUT 1 WORD
;					A1=VALUE
;					RELOCATE RIGHT HALF
;
;	.RAFIX	(REL ADDRESS FIXUP)	WRITE OUT 1 TYPE-10 FIXUP
;					A1=CHAIN
;					PROGRAM COUNTER=VALUE
;					RELOCATE BOTH HALVES
;
;	.ADRFIX (ADDRESS FIXUP)		WRITE OUT 1 TYPE-10 FIXUP
;					A1=CHAIN
;					A2=VALUE
;					RELOCATE BOTH HALVES
;
;	.ABSFIX	(ABSOLUTE FIXUP)	WRITE OUT 1 TYPE-10 FIXUP
;					A1=CHAIN
;					A2=VALUE
;					RELOCATE LEFT HALF (CHAIN)
;
;	.FIX50	(RADIX50 FIXUP)		WRITE OUT 1 TYPE-2 FIXUP
;					A1=LOCATION
;					A2=RADIX50 NAME
;					RELOCATE LOCATION
;
;	.EXTFIX (EXTERNAL FIXUP)	WRITE OUT ALL TYPE-2 FIXUPS FOR 1 EXTERNAL
;					PROCEDURE
;					A5=ADDRESS OF SYMBOL TABLE ENTRY
;
;	.ADDFIX	(ADDITIVE FIXUP)	WRITE OUT 1 TYPE-2 ADDITIVE FIXUP
;					A1=LOCATION (RELOCATE)
;					RADIX50 NAME IS ALWAYS %ALGDR
;
;	.TYPE0 (BLOCK TYPE-0 ENTRY)	WRITE OUT 1 TYPE-0 IDENTIFIER ENTRY
;	WRITE1		OPEN REL-FILE
;
;	WRITE0		CALLED IN PLACE OF WRITE1 WHEN THERE IS NO REL-FILE
;
;	.PROGD		PREPARE TO COMPILE A MAIN PROGRAM
;
;	.PROCD		PREPARE TO COMPILE AN EXTERNAL PROCEDURE
;
;	BMOVE		MOVE BLOCKS OF DATA ACCORDING TO A LIST
;			A1=LIST
;
;	.ZZEND		MOVE CONSTANTS TABLE TO REL-FILE,
;			MOVE FIXUP TABLE TO REL-FILE,
;			MOVE LIBRARY FIXUPS TO REL-FILE,
;			PUT AN END BLOCK IN REL-FILE,
;			CLOSE REL-FILE.
;
;	DUMP		REL-FILE DUMP PROGRAM
;
;	NAME		EXTRACT FROM SYMBOL TABLE ENTRY THE IDENTIFIER NAME
;			IN ASCIZ FORMAT
;	THE DEFAULT LENGTH OF THE HEAP IS "DELTA1".  THE USER
;	CAN OVERRIDE THIS VALUE WITH THE /D SWITCH AS LONG AS WHAT HE
;	SPECIFIES IS NOT LESS THAN "DELTA1".
;
		IFNDEF	DELTA1,<
		DELTA1==1000>
;
;	IF THE ASSEMBLY SWITCH "DUMPRN" IS NOT ZERO, THE REL-FILE DUMP
;	PROGRAM WILL BE LOADED WITH THE ALGOL COMPILER.
;
		IFNDEF	DUMPRN,<
		DUMPRN==0>

;	REGISTER ASSIGNMENTS

;	A4=4		; STATUS BLOCK
;	A7=7		; SAFE OVER WRITE MODULE
;	A10=10		; SAFE OVER WRITE MODULE
;	A11=11		; SAFE OVER WRITE MODULE
;	A12=12		; SAFE OVER WRITE MODULE
;	A13=13		; SAFE OVER WRITE MODULE
;	A14=14		; SAFE OVER WRITE MODULE
	A15=15		; SAFE OVER WRITE MODULE
	A16=16		; SAFE OVER WRITE MODULE
;	S=17		; STACK POINTER (SAFE OVER WRITE MODULE)
	INTERN	.PROGD
	INTERN	.PROCD
	INTERN	.RAFIX		; RELOCATABLE FIX-UP ROUTINE
	INTERN	.ADRFIX		; ADDRESS FIX-UP ROUTINE
	INTERN	.ABSFIX		; ABSOLUTE FIX-UP ROUTINE
	INTERN	.ADDFIX		; ADDITIVE FIX-UP ROUTINE
	INTERN	.EXTFIX		; EXTERNAL NAME FIX-UP ROUTINE
	INTERN	.FIX50		; EXTERNAL NAME FIX-UP ROUTINE (RADIX50 INPUT)
	INTERN	.MREL		; MOVE RELOCATABLE
	INTERN	.MABS		; MOVE ABSOLUTE
	INTERN	.ZZEND		; WRITE MODULE PROGRAM END ROUTINE
	INTERN	.TYPE0		; BLOCK TYPE-0 ENTRY
	EXTEN=400000	; EXTENDED ENTRY FLAG BIT
	EXISTS=400000	; 1 = LISTING FILE EXISTS
	COMPLETE=2000	; 1 = LISTING FILE COMPLETE AND CLOSED


	IND==0
	ADR==1
	PTR==2
	BLK==3
	EN==4
	TYP==5
;	INITIALIZE WRITE MODULE, CREATE REL-FILE, PREPARE TO RECEIVE OUTPUT.

WRITE1:	OPEN	1,OLIST		; OPEN THE OBJECT FILE
	GOTO	DSERR5		; CANNOT OPEN DEVICE
	OUTBUF	1,@OLIST+7	; GET A BUFFER RING
	L	A2,OFILE+2	; SAVE THE CREATION DATE IN A2
	LOOKUP	1,OFILE		; SEE IF FILE ALREADY EXISTS
	GOTO	.+2		; -NO, OK
	GOTO	DELOLD		; -YES, DELETE IT

W1:	ST	A2,OFILE+2	; RESTORE THE CREATION DATE
	ENTER	1,OFILE		; ENTER THE NEW FILE
	GOTO	DSERR6		; -CANNOT CREATE NEW FILE
	PUSHJ	S,WRITE		; INITIALIZE BUFFERS
	OUT	1,0		; GET 1ST OUTPUT BUFFER
	GOTO	.+2		; -OK
	GOTO	DSERR7		; ERROR
	LI	A1,1		; A 1 MEANS TO OUTPUT OBJECT CODE
	ST	A1,WFLAG	; SET WRITE MODULE FLAG
	AOS	(S)		; SKIP RETURN
	POPJ	S,		; EXIT WRITE1


;	INITIALIZE WRITE MODULE, DON'T CREATE REL-FILE, PREPARE TO
;	RECEIVE OUTPUT.

WRITE0:	LI	A1,203		; ALLOCATE A DUMMY BUFFER WHOSE LENGTH
	PUSHJ	S,ALLOCATE	; IS 203
	ADDI	A1,1		; STEP TO LINK WORD
	HRRZM	A1,BHEAD1	; SET BUFFER HEADER
	HRLI	A1,202		; BUFFER LENGTH
	ST	A1,(A1)		; PUT BUFFER RING LINK IN BUFFER
	PUSHJ	S,WRITE		; INITIALIZE BUFFERS
	ZERO	WFLAG		; MARK: NO REL FILE
	POPJ	S,		; EXIT WRITE0
;	"WRITE" IS CALLED BY "WRITE0" AND "WRITE1".  "WRITE" ALLOCATES
;	SPACE FOR THE ISOLATED BUFFERS,  AND SETS UP ALL OF THE STATUS BLOCKS.

	; SET STATUS BLOCKS FROM HIGH SEGMENT

WRITE:	HRLZI	A1,A3		; ADDRESS OF A3
	ST	A1,T0ADR	; INIT T0ADR
	ST	A1,T1ADR	; INIT T1ADR
	ST	A1,T2ADR	; INIT T2ADR
	ST	A1,T10ADR	; INIT T10ADR
	HRLZI	A1,440200	; LEFT HALF OF BYTE POINTERS
	ST	A1,T1PTR	; INIT T1PTR
	ST	A1,T10PTR	; INIT T10PTR
	HRLZI	A1,440400	; LEFT HALF OF TYPE-2 BYTE POINTER
	ST	A1,T2PTR	; INIT T2PTR
	LI	A1,2		; 2
	ST	A1,T2TYP	; INIT T2TYP
	LI	A1,1		; 1
	ST	A1,T1TYP	; INIT T1TYP
	ZERO	T0TYP		; INIT T0TYP
	L	A2,BHEAD1	; GET BUFFER ADDRESS
	HLRZ	A2,(A2)		; GET LENGTH OF BUFFER
	SUBI	A2,1		; TRUE USEABLE LENGTH
	ST	A2,BUFLEN	; SAVE THE OUTPUT BUFFER LENGTH
	; ACQUIRE SPACE FOR TYPE-2 BUFFER, INITIALIZE ITS STATUS BLOCK

	LI	A1,600		; BUFFERS MIGHT USE UP TO 600 WORDS
	PUSHJ	S,ALLOCATE	; GET SPACE FOR BUFFERS
	EXCH	A1,A2		; SWAP REGISTERS
	SUBI	A2,1		; BACK UP 1
	LI	A3,1(A2)	; BUFFER FOR TYPE-2 BLOCKS
	ADD	A2,A1		; STEP POINTER
	ST	A2,T2END	; MARK END OF TYPE-2 BUFFER
	LI	A4,TYPE2	; PARAM FOR INITB
	PUSHJ	S,INITB		; INITIALIZE TYPE-2 STATUS BLOCK

	; ACQUIRE SPACE FOR TYPE-10 BUFFER, INITIALIZE ITS STATUS BLOCK

	LI	A3,1(A2)	; BUFFER FOR TYPE-10 BLOCKS
	ADD	A2,A1		; STEP POINTER
	ST	A2,T10END	; MARK END OF TYPE-10 BUFFER
	LI	A4,TYPE10	; PARAM FOR INITB
	PUSHJ	S,INITB		; INITIALIZE TYPE-10 STATUS BLOCK

	; ACQUIRE SPACE FOR TYPE-0 BUFFER, INITIALIZE ITS STATUS BLOCK

	LI	A3,1(A2)	; BUFFER FOR TYPE-0 BLOCKS
	ADD	A2,A1		; STEP POINTER
	ST	A2,T0END	; MARK END OF TYPE-0 BUFFER
	LI	A4,TYPE0	; PARAM FOR INITB
	PUSHJ	S,INITB		; INITIALIZE TYPE-0 STATUS BLOCK
	ADDI	A2,1		; NEW BEGINNING OF FREE SPACE
	HRRM	A2,.JBFF	; SET JOBFF

	; INITIALIZE TYPE-1 STATUS BLOCK

	HRRZ	A3,BHEAD1	; GET ADDRESS OF PRIME BUFFER
	ADDI	A3,1		; STEP TO NEXT WORD
	HRRM	A3,T1ADR	; SET T1ADR
	ADD	A3,A1		; STEP TO END OF BUFFER
	ST	A3,T1END		; SET END OF BUFFER
	POPJ	S,		; EXIT WRITE



	; CANT OPEN OBJECT FILE DEVICE

DSERR5:	L	A1,[		; LOAD A POINTER TO
	POINT	6,OLIST+1]	; THE FILE NAME
	GOTO	DSERR0		; PRINT THE MESSAGE, TERMINATE
;	CANNOT CREATE REL-FILE

DSERR6:	TTCALL	3,UNOBJ		; PRINT MSG
	GOTO	TERMIN		; TERMINATE COMPILATION


UNOBJ:	ASCIZ	/?CANNOT CREATE OBJECT FILE
/
	; ERROR ON "OUT" UUO

DSERR7:	TTCALL	3,UNEXP		; PRINT ERROR MSG
	GOTO	TERMIN		; TERMINATE


UNEXP:	ASCIZ	/OUTPUT ERROR
/


	; DELETE THE OLD REL-FILE

DELOLD:	L	A1,OFILE	; SAVE FILE NAME
	ZERO	OFILE		; CLEAR FOR DELETE
	RENAME	1,OFILE		; DELETE OLD MODULE
	NOP			;
	ST	A1,OFILE	; RESTORE FILE NAME
	GOTO	W1		; CONTINUE
;	"BMOVE" WILL MOVE BLOCKS OF DATA AROUND IN CORE ACCORDING TO A
;	CONTROL LIST WHOSE ADDRESS IS IN A1.  THE FIRST WORD OF THE CONTROL
;	LIST IS A CONTROL WORD WHOSE LEFT HALF CONTAINS THE LOCATION
;	WHERE THE DATA WILL GO,  AND WHOSE RIGHT HALF CONTAINS THE LENGTH OF
;	THE BLOCK OF DATA IN WORDS.  THE CONTROL WORD IS FOLLOWED IMMEDIATELY
;	BY THE BLOCK OF DATA THAT IS TO BE MOVED.  THE BLOCK OF DATA IS
;	FOLLOWED IMMEDIATELY BY ANOTHER CONTROL WORD AND ANOTHER BLOCK TO
;	BE MOVED, ETC.  THE CONTROL LIST IS TERMINATED BY AN ALL ZERO
;	CONTROL WORD.


BMOVE:	IMEZ	A2,(A1)		; IF NO MORE BLOCKS THEN
	POPJ	S,		; EXIT BMOVE
	MOVS	A3,A2		; "TO" ADDRESS TO A3
	HRLI	A3,1(A1)	; "FROM" ADDRESS
	MOVS	A4,A2		; "TO" ADDRESS PLUS
	ADD	A4,(A1)		; LENGTH OF BLOCK
	ADDI	A1,1(A2)	; "END" ADDRESS PLUS 1
	BLT	A3,-1(A4)	; MOVE THE DATA
	GOTO	BMOVE		; PROCESS ANOTHER BLOCK

;------------------------------------------------
	XWD	LB,WRITE4-WRITE3+1
WRITE3:	XWD	0,WRITE4-WRITE3-1

	XWD	4,0		; TYPE-4 BLOCK OF LENGTH 0
	XWD	0,0		; RELOCATION BITS

	XWD	6,2		; TYPE-6 BLOCK OF LENGTH 2
	XWD	0,0		; RELOCATION BITS
PRNAME:	RADIX50	0,ALGOBJ	; PROGRAM NAME
	XWD	3,1		; ALGOL, 1 FLAGS MAIN PROGRAM

	XWD	2,10		; TYPE-2 BLOCK OF LENGTH 8
	XWD	040000,0	; RELOCATION BITS
	RADIX50	04,%BEGIN	; PROGRAM ENTRY POINT
	XWD	0,0		; VALUE
	RADIX50	60,%ALGDA	; %ALGDA
	XWD	0,0		; NO VALUE
	RADIX50	60,%ALGDR	; %ALGDR
	XWD	0,0		; NO USAGE
HEAP:	RADIX50 04,%HEAP	; %HEAP DEFINITION
	XWD	0,DELTA1	; VALUE

WRITE4:	0
	0
;------------------------------------------------
;	".PROGD" MOVES TO THE PRIME BUFFER THE TYPE-4,-6, AND -2 BLOCKS
;	THAT START EACH ALGOL MAIN PROGRAM.

.PROGD:	LI	A1,WRITE3-1	; PARAM FOR INIT
	PUSHJ	S,BMOVE		; MOVE CODE TO BUFFER

PD1:	HRRZ	A1,T1ADR	; BEGINNING OF AVAILABLE SPACE IN BUFFER
	ADDI	A1,1		; TRUE BEGINNING
	L	A5,A1		; SAVE FOR LATER IN A5
	HRLM	A1,LB		; SET DESTINATION  PART OF CONTROL WORD
	ADDI	A1,WRITE4-WRITE3-2	; END OF WHERE THIS BLOCK WILL BE
	IALEM	A1,T1END	; IF ENOUGH SPACE IN BUFFER
	GOTO	.+3		; THEN USE THIS BUFFER
	PUSHJ	S,GETBUF	; ELSE GET ANOTHER OUTPUT BUFFER
	GOTO	PD1		; AND TRY AGAIN
	HRRM	A1,T1ADR	; SET NEW T1ADR
	LI	A1,LB		; ADDRESS OF NEW BMOVE LIST
	PUSHJ	S,BMOVE		; MOVE INTO FINAL POSITION
	L	A2,DYNOWN	; LENGTH OF DYNAMIC OWN AREA
	IALI	A2,DELTA1	; MAKE SURE
	LI	A2,DELTA1	; AT LEAST MINIMAL SIZE
	MOVEM	A2,HEAP-WRITE3(A5)	; PUT INTO BUFFER
	IMEZ	A1,OFILE	; GET OBJECT FILE NAME
	SKIPA	A2,PRNAME	; NONE - USE DEFAULT
	PUSHJ	S,RADX50	; CONVERT TO RADIX50
	MOVEM	A2,PRNAME-WRITE3-1(A5)	; PUT IN BUFFER
	GOTO	WRITE2		; CONTINUE
;------------------------------------------------
	XWD	LB,WRITE6-WRITE5+1
WRITE5:	XWD	0,WRITE6-WRITE5-1

	XWD	4,1		; TYPE-4 BLOCK OF LENGTH 1
	XWD	0,0		; RELOCATION BITS
PNAME1:	XWD	0,0		; PROCEDURE NAME

	XWD	6,2		; TYPE-6 BLOCK OF LENGTH 2
	XWD	0,0		; RELOCATION BITS
PNAME2:	XWD	0,0		; PROCEDURE NAME
	XWD	3,0		; ALGOL

	XWD	2,2		; TYPE-2 BLOCK OF LENGTH 2
	XWD	040000,0	; RELOCATION BITS
PNAME3:	XWD	0,0		; PROCEDURE ENTRY POINT NAME
	XWD	0,1		; VALUE

WRITE6:	0
	0
;------------------------------------------------



;	".PROCD" MOVES TO THE PRIME BUFFER THE TYPE-4,-6, AND -2 BLOCKS
;	THAT START EACH ALGOL EXTERNAL PROCEDURE.

.PROCD:	LI	A1,WRITE5-1	; PARAM FOR INIT
	PUSHJ	S,BMOVE		; MOVE CODE TO BUFFER

PD2:	HRRZ	A1,T1ADR	; BEGINNING OF AVAILABLE SPACE IN BUFFER
	ADDI	A1,1		; TRUE BEGINNING
	PUSH	S,A1		; SAVE ON STACK FOR LATER
	HRLM	A1,LB		; SET DESTINATION PART OF CONTROL WORD
	ADDI	A1,WRITE6-WRITE5-2	; END OF WHERE THIS BLOCK WILL BE
	IALEM	A1,T1END	; IF THERE IS ENOUGH SPACE IN BUFFER
	GOTO	.+3		; THEN USE THIS BUFFER
	PUSHJ	S,GETBUF	; ELSE GET ANOTHER OUTPUT BUFFER
	GOTO	PD2		; AND TRY AGAIN
	HRRM	A1,T1ADR	; SET NEW T1ADR
	LI	A1,LB		; ADDRESS OF NEW BMOVE LIST
	PUSHJ	S,BMOVE		; MOVE INTO FINAL POSITION
	HRRZ	A5,NSYM		; GET ADDR OF BUFFER CONTAINING PROCEDURE NAME
	SUBI	A5,2		; MAKE LOOK LIKE SYMBOL TABLE ENTRY
	PUSHJ	S,PULL50	; CONVERT NAME IN ENTRY TO RADIX50
	POP	S,A3		; ADDRESS OF MOVED BLOCK
	ST	A2,PNAME1-WRITE5-1(A3)	; PUT NAME IN BUFFER
	ST	A2,PNAME2-WRITE5-1(A3)	; PUT NAME IN BUFFER
	IOR	A2,[		; INCLUDE CODE BITS
	XWD	040000,0]	; CODE 04
	ST	A2,PNAME3-WRITE5-1(A3)	; PUT NAME IN BUFFER
;	"WRITE2" IS CALLED BY ".PROGD" AND ".PROCD".  "WRITE2" WILL PUT
;	THE PROGRAM COUNTER (RA) INTO THE 1ST DATA WORD OF A NEW TYPE-1
;	LOADER BLOCK.

WRITE2:	PUSHJ	S,FIN1		; INITIALIZE PRIME BUFFER
	AOS	A3,T1IND	; GET INDEX
	ZERO	@T1ADR		; SET START ADDRESS
	LI	A3,1		; RELOCATE RIGHT HALF
	IDPB	A3,T1PTR	; SET RELOCATION BITS
	LI	A4,10		; THIS BUFFER IS FOR
	ST	A4,T10TYP	; TYPE-10 BLOCKS
	POPJ	S,		; EXIT .PROGD OR .PROCD



;	"PULL50" WILL EXTRACT THE RADIX50 NAME OF AN IDENTIFIER FROM THE
;	SYMBOL TABLE ENTRY.  A1 SHOULD CONTAIN THE ADDRESS OF THE SYMBOL TABLE
;	ENTRY.  THE OUTPUT IS IN A1.


PULL50:	LI	A1,0		; CLEAR A1
	L	A2,2(A5)	; GET 1ST WORD OF NAME
	LDB	A3,[		; GET THE LENGTH BYTE
	POINT	6,A2,35]	; POINTER TO LENGTH BYTE
	IALI	A3,5		; IF THERE ARE LESS THAN 6 CHARS
	GOTO	IDL		; THEN SKIP THIS PART
	LDB	A1,[		; GET THE 6TH CHAR
	POINT	6,3(A5),5]	; POINTER TO 6TH CHAR
	XORI	A1,40		; CONVERT TO PROPER SIXBIT
	SUBI	A3,1		; DECREMENT CHAR COUNT BY 1

IDL:	ROT	A1,-^D12	; MOVE LAST CHAR TO LEFT SIDE OF A1
	LSHC	A1,6		; MOVE NEXT CHAR INTO A1
	XORI	A1,40		; CONVERT TO PROPER SIXBIT
	SOJGE	A3,IDL		; LOOP TILL DONE

	LDB	A2,[		; GET CHAR COUNT
	POINT	6,2(A5),35]	; POINTER TO LENGTH BYTE
	IMULI	A2,6		; NUMBER OF BITS TO ROTATE
	ROT	A1,(A2)		; ROTATE RESULT
;	"RADX50" WILL CONVERT THE SIXBIT NAME IN A1 TO RADIX50, AND
;	OUTPUT THE RESULT IN A2.


RADX50:	LI	A2,0		; CLEAR A2
	LI	A3,6		; SCAN 6 CHARS
	L	A6,[		; LOAD A POINTER TO
	POINT	6,A1]		; A1

RADIXL:	IMULI	A2,50		; MULTIPLY CHAR BY 50
	ILDB	A4,A6		; GET NEXT CHAR
	JUMPE	A4,.+4		; SKIP IF A NULL CHAR
	IAGI	A4,40		; IF THIS IS A LETTER
	SUBI	A4,7		; THEN SUB 7
	SUBI	A4,17		; CONVERT TO SPECIAL SIXBIT
	ADDI	A2,(A4)		; ADD INTO PREVIOUS RESULT
	SOJG	A3,RADIXL	; LOOP
	POPJ	S, 		; EXIT RADX50




	RELOC

WFLAG:	0			; WRITE MODULE FLAG
A2SAV:	0			; SAVE AREA FOR A2
A4SAV:	0			; SAVE AREA FOR A4
A5SAV:	0			; SAVE AREA FOR A5
A6SAV:	0			; SAVE AREA FOR A6
DYNOWN:	^D512			; LENGTH OF DYNAMIC OWN AREA
BUFLEN:	0			; OUTPUT BUFFER LENGTH
WINDEX:	0			; WORD INDEX
;
;  TERMINOLOGY
;
;
;	LOADER SUB-BLOCK:	A WORD OF RELOCATION BITS FOLLOWED BY UP
;				TO 18 DATA WORDS.
;
;
;	LOADER BLOCK:		A DESCRIPTOR WORD FOLLOWED BY ANY NUMBER
;				OF LOADER SUB-BLOCKS.  ONLY THE LAST SUB-BLOCK
;				MAY CONTAIN LESS THAN 18 DATA WORDS.
;
;
;	DESCRIPTOR WORD:	LEFT HALF CONTAINS LOADER BLOCK TYPE.
;				RIGHT HALF CONTAINS THE NUMBER OF DATA WORDS
;				IN THE LOADER BLOCK.  NOTE THAT THIS NUMBER
;				DOES NOT INCLUDE THE DESCRIPTOR WORD OR ANY
;				RELOCATION BITS WORDS.
;
;
;	BUFFER:			A BLOCK OF 200 (OCTAL) WORDS THAT CAN RECIEVE
;				OUTPUT.
;
;
;	RING BUFFER:		A BUFFER, AS DEFINED ABOVE, THAT IS INCLUDED
;				IN AN OUTPUT BUFFER-RING ACCEPTABLE TO THE
;				OPERATING SYSTEM.
;
;
;	BUFFER-RING:		A RING OF RING BUFFERS.
;
;
;	ISOLATED BUFFER:	A BUFFER THAT IS NOT A RING BUFFER.  ANY OUTPUT
;				DATA THAT IS PLACED IN AN ISOLATED BUFFER
;				MUST EVENTUALLY BE MOVED TO A RING BUFFER.
;
;
;	PRIME BUFFER:	THROUGHOUT MOST OF THE COMPILATION, TYPE-1, TYPE-2,
;			TYPE-10, AND TYPE-0 DATA IS PRODUCED SIMULTANEOUSLY.
;			BUT DUE TO THE INGENIOUS DESIGN OF THE BUFFER-RING
;			CONCEPT IT IS ONLY POSSIBLE TO FILL ONE RING BUFFER
;			AT A TIME.  THEREFORE TYPE-1 DATA IS PLACED IN THE
;			AVAILABLE RING BUFFER, AND THE TYPE-2, TYPE-10, AND TYPE-0
;			DATA ARE PLACED IN THREE ISOLATED BUFFERS.  WE SHALL
;			CALL THE AVAILABLE RING BUFFER THE "PRIME BUFFER".
;	STATUS BLOCK		THIS MODULE CONTAINS GENERALIZED ROUTINES
;				THAT CAN OPERATE ON ANY BUFFER.  THE INPUT
;				PARAMETER TO THESE ROUTINES IS THE ADDRESS
;				OF A "STATUS BLOCK".  A STATUS BLOCK IS A BLOCK
;				OF WORDS THAT DESCRIBES THE CURRENT STATUS OF THE
;				BUFFER.  A STATUS BLOCK HAS THE FOLLOWING FORMAT:
;
;
;   STATUS BLOCK FORMAT:
;
;	WORD 0 (T#IND)		LOADER SUB-BLOCK INDEX.  THIS WORD NORMALLY
;	INDEX WORD		CYCLES FROM -18 TO 0.  WHEN IT BECOMES +1
;				IT IS TIME TO CALL THE ROUTINE "GET" WHICH
;				SETS UP THE BUFFER FOR ANOTHER SUB-BLOCK.
;				IF, FOR EXAMPLE, "GET" FINDS THAT THERE ARE
;				ONLY 7 UNUSED WORDS AT THE END OF THE BUFFER,
;				THEN IT WILL SET UP THIS WORD TO CYCLE FROM
;				-7 TO 0.
;
;
;	WORD 1 (T#ADR)		BUFFER POINTER.  THE RIGHT HALF OF THIS WORD
;	ADDRESS WORD		POINTS TO THE EVENTUAL LAST WORD OF THE SUB-BLOCK
;				THAT IS BEING FILLED.  THE LEFT HALF ALWAYS
;				CONTAINS A 3.  THEN A DATA WORD IS MOVED INTO
;				A SUB-BLOCK BY THE FOLLOWING SEQUENCE:
;
;		AOSLE	A3,T#IND	; STEP AND FETCH THE INDEX
;		PUSHJ	S,T#GET		; -NO ROOM IN SUB-BLOCK, CALL GET
;		MOVEM	A1,@T#ADR	; MOVE DATA WORD INTO SUB-BLOCK
;
;
;	WORD 2 (T#PTR)		RELOCATION BITS BYTE POINTER.  THE RELOCATION
;	POINTER WORD		BITS ARE INSERTED INTO THE RELOCATION WORD
;				USING AN IDPB WITH THIS BYTE POINTER.
;
;
;	WORD 3 (T#BLK)		THIS WORD POINTS TO THE DESCRIPTOR WORD OF
;	BLOCK START		OF THE LOADER BLOCK IN THE BUFFER.  AFTER
;				THE BUFFER IS FILLED THE DESCRIPTOR WORD IS
;				SET BY THE SEQUENCE:
;
;		(USED LENGTH OF BUFFER) := T#ADR+T#IND-T#BLK ;
;		@T#BLK := (USED LENGTH OF BUFFER)-(USED LENGTH OF BUFFER)/19 ;
;
;
;	WORD 4 (T#END)		THIS WORD POINTS TO THE LAST USEABLE WORD
;	BUFFER END		OF THE BUFFER.
;
;
;	WORD 5 (T#TYP)		THIS WORD CONTAINS THE LOADER BLOCK TYPE FOR
;	BLOCK TYPE		WHICH THIS BUFFER IS BEING USED.
;	IF AT ANY TIME "GET" DETECTS THAT ANY OF THESE BUFFERS IS FULL,
;	"GET" WILL CALL "FIN".  "FIN" WILL USE "MOVBLK" TO MOVE THE TYPE-2, TYPE-0
;	AND TYPE-10 LOADER BLOCKS FROM THE ISOLATED BUFFERS TO THE PRIME
;	BUFFER (AND IN THE PROCESS DO OUT UUO'S WHENEVER THE PRIME BUFFER
;	BECOMES FULL).  "FIN" WILL THEN USE "INITB" TO INITIALIZE EACH OF
;	THE BUFFERS FOR MORE OUTPUT.


; *********  STATUS BLOCKS  *********


TYPE1:
T1IND:	0			; INDEX
T1ADR:	(A3)			; ADDRESS POINTER
T1PTR:	XWD	440200,0	; POINTER TO RELOC ATION BITS
T1BLK:	0			; LOCATION OF LOADER BLOCK
T1END:	0			; END OF THAT BUFFER
T1TYP:	1			; TYPE 1

TYPE2:
T2IND:	-^D18			; INDEX
T2ADR:	(A3)			; ADDRES POINTER
T2PTR:	XWD	440400,0	; POINTER TO RELOCATION BITS
T2BLK:	0			; LOCATION OF LOADER BLOCK
T2END:	0			; END OF THAT BUFFER
T2TYP:	2			; TYPE 2


TYPE10:
T10IND:	-^D18			; INDEX
T10ADR:	(A3)			; ADDRESS POINTER
T10PTR:	XWD	440200,0	; POINTER TO RELOCATION BITS
T10BLK:	0			; LOCATION OF LOADER BLOCK
T10END:	0			; END OF THAT BUFFER
T10TYP:	10			; TYPE 10


TYPE0:
T0IND:	-^D18			; INDEX
T0ADR:	(A3)			; ADDRESS POINTER
T0PTR:	0			; POINTER TO RELOCATION BITS (UNUSED)
T0BLK:	0			; LOCATION OF LOADER BLOCK
T0END:	0			; END OF THAT BUFFER
T0TYP:	0			; TYPE 0

	RELOC
; *********  OUTPUT ROUTINES  *********




;--------------------------------------------------------------
.MABS:	AOSLE	A3,T1IND	; FETCH THE INDEX AND STEP IT
	PUSHJ	S,T1GET		; -AT END OF 18-WORD BLOCK
	ST	A1,@T1ADR	; STORE THE WORD IN THE BUFFER
	IBP	T1PTR		; RELOCATION BITS ARE ZERO
	AOS	RA		; STEP PROGRAM COUNTER
	POPJ	S,		; EXIT .MABS



;--------------------------------------------------------------
.MREL:	TRNN	A1,777777	; IF RIGHT HALF OF T IS ZERO
	GOTO	.MABS		; THEN DO A MABS
	AOSLE	A3,T1IND	; STEP AND FETCH WORD INDEX
	PUSHJ	S,T1GET		; -END OF SUB-BLOCK
	ST	A1,@T1ADR	; STORE THE WORD IN THE BUFFER
	LI	A3,1		; RELOCATE RIGHT HALF
	IDPB	A3,T1PTR	; SET RELOCATION BITS
	AOS	RA		; STEP PROGRAM COUNTER
	POPJ	S,		; EXIT .MREL



;--------------------------------------------------------------
.RAFIX:	TRNN	A1,777777	; IF RIGHT HALF ZERO
	POPJ	S,		; THEN DO NOTHING
	AOSLE	A3,T10IND	; STEP AND FETCH WORD INDEX
	PUSHJ	S,T10GET	; -END OF SUB-BLOCK
	HRL	A1,RA		; THE VALUE IS THE CURRENT PROGRAM COUNTER
	MOVSM	A1,@T10ADR	; STORE THE WORD IN THE BUFFER
	LI	A3,3		; RELOCATE BOTH HALVES
	IDPB	A3,T10PTR	; SET THE RELOCATION BITS
	POPJ	S,		; EXIT .RAFIX
;--------------------------------------------------------------
.ADRFIX: TRNN	A1,777777	; IF RIGHT HALF ZERO
	POPJ	S,		; THEN DO NOTHING
	AOSLE	A3,T10IND	; STEP AND FETCH WORD INDEX
	PUSHJ	S,T10GET	; -END OF SUB-BLOCK
	HRL	A1,A2		; PUT VALUE WITH BACK-CHAIN POINTER
	MOVSM	A1,@T10ADR	; STORE THE WORD IN THE BUFFER
	LI	A3,3		; RELOCATE BOTH HALVES
	IDPB	A3,T10PTR	; SET THE RELOCATION BITS
	POPJ	S,		; EXIT .ADRFIX



;--------------------------------------------------------------
.ABSFIX: TRNN	A1,777777	; IF RIGHT HALF ZERO
	POPJ	S,		; THEN DO NOTHING
	AOSLE	A3,T10IND	; STEP AND FETCH WORD INDEX
	PUSHJ	S,T10GET	; -END OF SUB-BLOCK
	HRL	A2,A1		; PUT VALUE WITH BACK-CHAIN POINTER
	ST	A2,@T10ADR	; PUT WORD INTO BUFFER
	LI	A3,2		; RELOCATE THE LEFT HALF
	IDPB	A3,T10PTR	; SET RELOCATION BITS
	POPJ	S,		; EXIT .ABSFIX



;--------------------------------------------------------------
.FIX50:	TRNN	A1,777777	; IF RIGHT HALF ZERO
	POPJ	S,		; THEN DO NOTHING
	ST	A5,A5SAV	; SAVE A5
	AOSLE	A3,T2IND	; STEP AND FETCH WORD INDEX
	PUSHJ	S,T2GET		; -END OF SUB-BLOCK
	TLO	A2,600000	; INCLUDE THE CODE 60 INDICATOR
	ST	A2,@T2ADR	; STORE THE WORD IN THE BUFFER
	AOSLE	A3,T2IND	; STEP AND FETCH THE WORD INDEX
	PUSHJ	S,T2GET		; -END OF SUB-BLOCK
	HRRZM	A1,@T2ADR	; STORE THE WORD IN THE BUFFER
	LI	A3,1		; RELOCATE RIGHT HALF OF 2ND WORD
	IDPB	A3,T2PTR	; SET THE RELOCATION BITS
	L	A5,A5SAV	; RESTORE A5
	POPJ	S,		; EXIT .FIX50
;--------------------------------------------------------------
.EXTFIX: ST	A5,A5SAV	; SAVE A5 BECAUSE PULL50 WILL CLOBBER IT
	PUSHJ	S,PULL50	; EXTRACT NAME AND CONVERT TO RADIX50
	L	A5,A5SAV	; RESTORE A5
	L	A1,1(A5)	; LOAD VALUE FIELD OF ENTRY
	PUSHJ	S,.FIX50	; WRITE OUT THIS BACK-CHAIN POINTER
	L	A3,(A5)		; GET 1ST WORD OF ENTRY
	TLNN	A3,EXTEN	; IF THIS IS NOT AN EXTENDED ENTRY
	POPJ	S,		; THEN EXIT .EXTFIX
	L	A3,2(A5)	; GET NAME WORD
	ADDI	A3,1		; ADD 1 TO BYTE COUNT
	ANDI	A3,77		; SAVE ONLY LENGTH BYTE
	IDIVI	A3,6		; CONVERT TO A WORD COUNT
	ADDI	A3,3(A5)	; STEP TO EXTENSION
	L	A1,(A3)		; GET 1ST WORD OF EXTENSION
	GOTO	.FIX50		; WRITE OUT THIS BACK-CHAIN POINTER, EXIT .EXTFIX



;--------------------------------------------------------------
.ADDFIX: AOSLE	A3,T2IND	; STEP AND FETCH WORD INDEX
	PUSHJ	S,T2GET		; -END OF SUB-BLOCK
	L	A2,[		; THE ADDITIVE FIX-UP IS FOR THE
	RADIX50	60,%ALGDR]	; EXTERNAL SYMBOL "%ALGDR"
	ST	A2,@T2ADR	; STORE THE WORD IN THE BUFFER
	AOSLE	A3,T2IND	; STEP AND FETCH THE WORD INDEX
	PUSHJ	S,T2GET		; -END OF SUB-BLOCK
	HRLI	A1,400000	; INDICATE AN ADDITIVE FIX-UP
	ST	A1,@T2ADR	; STORE THE WORD IN THE BUFFER
	LI	A3,1		; RELOCATE RIGHT HALF OF SECOND WORD
	IDPB	A3,T2PTR	; SET THE RELOCATION BITS
	POPJ	S,		; EXIT .ADDFIX
;--------------------------------------------------------------
.TYPE0:	L	A2,1(A1)	; GET VALUE WORD FROM SYMBOL TABLE ENTRY
	PUSHJ	S,MOVE0		; WRITE IT OUT
	PUSH	S,A6		; SAVE A6
	PUSHJ	S,NAME		; GET NAME FROM SYMBOL TABLE ENTRY
	POP	S,A6		; RESTORE A6
	PUSH	S,A1		; SAVE A1
	LI	A1,(A5)		; ADDRESS OF END OF NAME IN LB
	SUBI	A1,LB		; LENGTH OF NAME IN BUFFER
	L	A2,A1		; PUT LENGTH IN A2 FOR MOVE0
	PUSHJ	S,MOVE0		; WRITE IT OUT
	LI	A2,LB		; POINTER TO BEGINNING OF BUFFER
	ST	A2,WINDEX	; STORE

T0LOOP:	L	A2,@WINDEX	; GET WORD OF NAME
	PUSHJ	S,MOVE0		; WRITE IT OUT
	AOS	WINDEX		; STEP THE WORD POINTER
	SOJG	A1,T0LOOP	; LOOP

	POP	S,A1		; RESTORE A1
	POPJ	S,		; EXIT .TYPE0



MOVE0:	AOSLE	A3,T0IND	; GET INDEX
	PUSHJ	S,T0GET		; -END OF SUB-BLOCK
	ST	A2,@T0ADR	; STORE THE WORD IN THE BUFFER
	POPJ	S,		; EXIT MOVE0



;--------------------------------------------------------------
T1GET:	LI	A4,TYPE1	; ADDR OF STATUS BLOCK THAT DESCRIBES THE TYPE-1 BLOCK
	GOTO	GET		; CONTINUE



T2GET:	LI	A4,TYPE2	; ADDR OF STATUS BLOCK THAT DESCRIBES THE TYPE-2 BLOCK
	GOTO	GET		; CONTINUE



T10GET:	LI	A4,TYPE10	; ADDR OF STATUS BLOCK THAT DESCRIBES THE TYPE-10 BLOCK
	GOTO	GET		; CONTINUE


T0GET:	LI	A4,TYPE0	; ADDR OF STATUS BLOCK THAT DESCRIBES THE TYPE-0 BLOCK

;	"GET" IS CALLED WHEN A SUB-BLOCK IS FULL.  "GET" WILL SET UP THE
;	STATUS BLOCK FOR THE NEXT SUB-BLOCK.  IF THERE IS ROOM LEFT
;	IN THE BUFFER FOR MORE THAN 18 DATA WORDS, "GET" WILL SET THE INDEX
;	WORD TO CYCLE FROM -18 TO 0.  IF THERE IS BETWEEN 3 AND 18 WORDS
;	OF SPACE LEFT IN THE BUFFER, "GET" WILL SET THE INDEX WORD SO THAT
;	IT BECOMES ZERO WHEN THE BUFFER IS FULL.
;
;	IF THERE ARE LESS THAN 3 AVAILABLE WORDS LEFT IN THE BUFFER,
;	"GET" WILL NOT START ANOTHER SUB-BLOCK IN THAT BUFFER.  INSTEAD,
;	"GET" WILL CALL "FIN" TO MOVE THE LOADER BLOCKS TO THE PRIME BUFFER.
;	THEN "GET" WILL PUT THE PROGRAM COUNTER (RA) INTO THE 1ST DATA WORD
;	OF THE NEW TYPE-1 LOADER BLOCK.
;
GET:	L	A5,EN(A4)	; COMPUTE THE AMOUNT OF SPACE LEFT
	SUB	A5,ADR(A4)	; IN THE BUFFER.
	LI	A5,(A5)		; CLEAR LEFT HALF OF A5
	IALI	A5,3		; IF THERE ARE LESS THAN 3 WORDS LEFT
	GOTO	GET1		; THEN DONT START ANOTHER SUB-BLOCK.
	IAGI	A5,^D19		; IF THERE ARE MORE THAN 19 WORDS LEFT
	LI	A5,^D19		; THEN USE EXACTLY 19 WORDS FOR THIS SUB-BLOCK
	L	A3,ADR(A4)	; GET OLD ADDRESS POINTER
	ADDI	A3,1		; THE NEXT WORD IS THE NEW RELOCATION BITS WORD
	HRRM	A3,PTR(A4)	; SET POINTER'S ADDRESS FIELD
	ZERO	(A3)		; CLEAR THE RELOCATION BITS
	LI	A3,44		; REINITIALIZE THE P-FIELD OF
	DPB	A3,[		; THE RELOCATION BITS BYTE POINTER TO
	POINT	6,PTR(A4),5]	; THE 1ST BYTE.
	ADDM	A5,ADR(A4)	; ADD LENGTH OF NEW SUB-BLOCK TO OLD ADDR POINTER
	MOVN	A3,A5		; NEGATE LENGTH OF NEW SUB-BLOCK
	ADDI	A3,2		; BUT DONT COUNT THE RELOCATION WORD
	HRREM	A3,IND(A4)	; THIS WILL BE THE NEW INDEX WORD
	POPJ	S,		; EXIT GET


GET1:	ST	A2,A2SAV	; SAVE A2
	ST	A4,A4SAV	; SAVE A4
	SOS	IND(A4)		; CORRECT END OF DATA
	PUSHJ	S,FIN		; FINISH
	L	A2,T1TYP	; GET BLOCK TYPE
	IANI	A2,1		; IF THIS IS NOT TYPE-1
	GOTO	GET2		; THEN SKIP THIS PART
	AOS	A3,T1IND	; STEP AND FETCH THE INDEX
	L	A2,RA		; GET PROGRAM COUNTER
	HRRZM	A2,@T1ADR	; PUT PROGRAM COUNTER INTO SUB-BLOCK
	LI	A3,1		; 2ND HALF IS RELOCATABLE
	IDPB	A3,T1PTR	; OUTPTT RELOCATION BITS

GET2:	L	A2,A2SAV	; RESTORE A2
	L	A4,A4SAV	; RESTORE A4
	AOS	A3,IND(A4)	; STEP INDEX
	POPJ	S,		; EXIT T1GET, T2GET, OR T10GET
;	"COMPL" COMPUTES THE NUMBER OF DATA WORDS IN A LOADER BLOCK.
;	"COMPL" EXPECTS A4 TO CONTAIN THE ADDRESS OF THE STATUS BLOCK, AND THAT THE
;	STATUS BLOCK ADDRESS WORD (T#ADR) POINT TO THE LAST ACTUAL DATA WORD OF THE
;	LOADER BLOCK.  "COMPL" WILL INSERT THIS NUMBER INTO THE LOADER BLOCK'S
;	DESCRIPTOR WORD.


COMPL:	HRRZ	A2,ADR(A4)	; GET END OF LOADER BLOCK
	SUB	A2,BLK(A4)	; LENGTH OF USED BUFFER SPACE
	SOS	A5,A2		; COPY TO A5
	IDIVI	A2,^D19		; COMPUTE NUMBER OF RELOCATION WORDS
	SUB	A5,A2		; SUBTRACT TO FIND NUMBER OF DATA WORDS
	HRL	A5,TYP(A4)	; PICK UP LOADER BLOCK TYPE
	ST	A5,@BLK(A4)	; PUT TYPE AND LENGTH AT BEGINNING OF BLOCK
	POPJ	S,		; EXIT COMPL




;	"GETBUF" WILL GET A NEW PRIME BUFFER, AND THEN UPDATE THE PRIME
;	BUFFER STATUS BLOCK TO REFLECT THIS CHANGE.


GETBUF:	L	A2,T1ADR	; END OF DATA IN BUFFER
	HRRM	A2,BHEAD1+1	; MARK IN HEADER
	IMLEZ	WFLAG		; IF THERE IS NO OBJECT MODULE
	GOTO	.+4		; THEN SKIP THIS OUTPUT
	OUT	1,0		; GET ANOTHER BUFFER
	GOTO	.+2		; -OK
	GOTO	DSERR7		; -OUTPUT ERROR
	HRRZ	A2,BHEAD1	; ADDRESS OF NEW BUFFER
	ADDI	A2,1		; STEP OVER 1ST WORD
	HRRM	A2,T1ADR	; SET T1ADR
	ADD	A2,BUFLEN	; COMPUTE END OF BUFFER
	HRRZM	A2,T1END	; SAVE THIS ADDRESS
	POPJ	S,		; EXIT CHECK3
;	"FIN" WILL ADD THE INDEX WORD, T1IND, TO THE ADDRESS WORD, T1ADR,
;	AND EXPECT THE SUM TO POINT TO THE LAST DATA WORD IN THE PRIME BUFFER.
;	THEN "FIN" WILL COMPUTE THE NUMBER OF DATA WORDS IN THE LOADER BLOCK
;	THAT IS BEING FILLED IN THE PRIME BUFFER, AND INSERT THIS NUMBER
;	INTO THE LOADER BLOCK'S DESCRIPTOR WORD.  THEN "FIN" WILL USE "MOVBLK"
;	TO MOVE LOADER BLOCKS FROM THE ISOLATED BUFFERS TO THE PRIME BUFFER.
;	FINALLY, "FIN" WILL INITIALIZE THE PRIME BUFFER TO RECIEVE SUB-BLOCKS
;	OF A NEW LOADER BLOCK.


FIN:	HRRE	A4,T1IND	; GET INDEX
	ADDM	A4,T1ADR	; COMPUTE END OF DATA IN PRIME BUFFER
	LI	A4,TYPE1	; PARAM FOR COMPL
	PUSHJ	S,COMPL		; LENGTH OF CODE IN BUFFER, PUT IN BUFFER
	LI	A4,TYPE2	; PARAM FOR MOVBLK
	PUSHJ	S,MOVBLK	; MOVE TYPE-2 LOADER BLOCK TO PRIME BUFFER
	LI	A4,TYPE10	; PARAM FOR MOVBLK
	PUSHJ	S,MOVBLK	; MOVE TYPE-10 LOADER BLOCK TO PRIME BUFFER
	LI	A4,TYPE0	; PARAM FOR MOVBLK
	PUSHJ	S,MOVBLK	; MOVE TYPE-0 LOADER BLOCK TO PRIME BUFFER

FIN1:	L	A3,T1END	; END OF BUFFER
	SUB	A3,T1ADR	; COMPUTE REMAINING LENGTH OF BUFFER
	LI	A3,(A3)		; ZERO LEFT HALF
	IALI	A3,3		; IF THER ARE LESS THAN 3 WORDS LEFT
	PUSHJ	S,GETBUF	; THEN GET ANOTHER BUFFER
	AOS	A3,T1ADR	; NEXT AVAILABLE WORD IN PRIME BUFFER
	LI	A4,TYPE1	; PARAM FOR INITB
;	"INITB" INITIALIZES A BUFFER SO THAT IT CAN RECEIVE THE 1ST SUB-BLOCK
;	OF A NEW LOADER BLOCK.  "INITB" EXPECTS A3 TO CONTAIN THE ADDRESS
;	OF THE NEW LOADER BLOCK (ADDRESS OF THE DESCRIPTOR WORD), AND THAT
;	A4 CONTAIN THE ADDRESS OF THE STATUS BLOCK.


INITB:	HRRZM	A3,BLK(A4)	; SET POINTER TO DESCRIPTOR WORD
	LI	A3,1(A3)	; STEP TO RELOCATION BITS WORD
	ZERO	(A3)		; CLEAR RELOCATION BITS
	HRRM	A3,PTR(A4)	; SET ADDR FIELD OF RELOCATION BITS POINTER
	ADDI	A3,^D18		; STEP TO END OF SUB-BLOCK
	IAGEM	A3,EN(A4)	; IF PAST END OF BUFFER
	L	A3,EN(A4)	; THEN BUFFER END BECOMES SUB-BLOCK END
	HRRM	A3,ADR(A4)	; SET ADDRESS POINTER
	SUB	A3,PTR(A4)	; COMPUTE LENGTH OF SUB-BLOCK
	LI	A3,(A3)		; CLEAR LEFT HALF
	MOVNM	A3,IND(A4)	; SET INDEX WORD
	LI	A3,44		; BYTE 1
	DPB	A3,[		; SET P-FIELD OF RELOCATION
	POINT	6,PTR(A4),5]	; BITS BYTE POINTER
	POPJ	S,		; EXIT INITB




;	"MOVBLK" WILL MOVE A LOADER BLOCK FROM AN ISOLATED BUFFER TO THE
;	PRIME BUFFER.  "MOVBLK" EXPECTS A4 TO CONTAIN THE ADDRESS OF THE STATUS BLOCK,
;	AND THAT T1ADR POINT TO THE LAST ACTUAL DATA WORD IN THE PRIME BUFFER.
;	UPON COMPLETION, "MOVBLK" WILL SET T1ADR TO POINT TO THE NEW LAST
;	DATA WORD IN THE PRIME BUFFER.
;
;	IF THE LOADER BLOCK TO BE MOVED WILL NOT FIT IN THE AVAILABLE SPACE
;	IN THE PRIME BUFFER, "MOVBLK" WILL MOVE AS MUCH AS WILL FIT, AND
;	THEN PERFORM AN OUT UUO TO GET A NEW PRIME BUFFER, THEN MOVE THE
;	REMAINDER OF THE LOADER BLOCK TO THE NEW PRIME BUFFER.
MOVBLK:	HRRE	A5,IND(A4)	; GET INDEX
	ADDM	A5,ADR(A4)	; COMPUTE END OF LOADER BLOCK
	PUSHJ	S,COMPL		; COMPUTE LENGTH OF BLOCK, PUT IN BLOCK

	; COMPUTE LENGTH OF LOADER BLOCK TO MOVE

	HRRZ	A5,ADR(A4)	; GET END OF USED SPACE
	SUB	A5,BLK(A4)	; SUBTRACT BEGINNING OF LOADER BLOCK
	IAEI	A5,1		; IF NO DATA WORDS IN BUFFER
	GOTO	MBLK2		; THEN EXIT MOVBLK HAVING MOVED NOTHING
	ADDI	A5,1		; TRUE LENGTH OF BLOCK TO MOVE

	; COMPUTE REMAINING SPACE IN CURRENT OUTPUT BUFFER

	L	A3,T1END	; END OF OUTPUT BUFFER
	SUB	A3,T1ADR	; SUBTRACT POINTER
	LI	A3,(A3)		; ZERO LEFT HALF OF A3
				; A5=LENGTH OF LOADER BLOCK TO MOVE
				; A3=LENGTH OF AVAIL SPACE IN PRIME BUFFER
	JUMPE	A3,MBLK3	; JUMP IF NO SPACE LEFT
	IALI	A3,(A5)		; IF THERE IS NOT ENOUGH SPACE THEN
	GOTO	MBLK4		; CONTINUE

	; MOVE REMAINDER OF LOADER BLOCK TO OUTPUT BUFFER

	HRLZ	A3,BLK(A4)	; "FROM" ADDRESS
	L	A2,T1ADR	; END OF DATA IN PRIME BUFFER

MBLK1:	HRRI	A3,1(A2)	; "TO" ADDRESS
	ADDI	A2,(A5)		; "END" ADDRESS IN PRIME BUFFER
	HRRM	A2,T1ADR	; SAVE AS NEW ADDRESS POINER
	BLT	A3,(A2)		; MOVE IT

MBLK2:	L	A3,BLK(A4)	; LOCATE BEGINNING OF LOADER BLOCK
	GOTO	INITB		; INITIALIZE IT, EXIT MOVBLK
	; NO SPACE IN PRIME BUFFER

MBLK3:	HRL	A3,BLK(A4)	; "FROM" ADDRESS
	GOTO	MBLK5		; CONTINUE


	; INSUFFICIENT SPACE IN PRIME BUFFER

MBLK4:	SUB	A5,A3		; COMPUTE LENGTH OF 2ND PART
	ADD	A3,BLK(A4)	; COMPUTE "FROM" ADDRESS FOR 2ND PART
	HRLZI	A3,(A3)		; SAVE FOR LATER
	AOS	A2,T1ADR	; "TO" ADDRESS
	HRL	A2,BLK(A4)	; "FROM" ADDRESS
	BLT	A2,@T1END	; MOVE 1ST PART OF LOADER BLOCK


MBLK5:	L	A2,T1END	; END OF PRIME BUFFER
	HRRM	A2,T1ADR	; SET T1ADR TO IT
	PUSHJ	S,GETBUF	; GET ANOTHER PRIME BUFFER
	HRRZ	A2,T1ADR	; ADDR OF BEGINNING OF NEW BUFFER
	GOTO	MBLK1		; CONTINUE
.ZZEND:	ST	A6,A6SAV	; SAVE A6
	PUSHJ	S,LMSGZ		; PRINT ANY ERROR MESSAGES LEFT IN TABLE

;--------------------------------------------------------
;	SEARCH SYMBOL TABLE FOR UNDEFINED LABELS.
;--------------------------------------------------------

ZLAB:	L	A1,STBB		; WHERE AN UNDEFINED LABEL ENTRY MIGHT BE
	IAGEM	A1,NASTE	; IF NO UNDEFINED LABEL
	GOTO	ZC0		; THEN SKIP THIS PART
	PUSHJ	S,NAME		; EXTRACT FROM SYMBOL TABLE ENTRY THE ASCIZ NAME
	L	A2,(A1)		; GET 1ST WORD OF ENTRY
	TLNE	A2,EXTEN	; IF IT IS AN EXTENDED ENTRY
	ADDI	A6,2		; THEN ADD 2 TO POINTER
	ST	A6,STBB		; SAVE FOR LATER
	HRRZ	A1,-2(A6)	; GET THE CHAIN HEAD
	LI	A2,777777	; FIX IT UP TO JUMP TO -1
	PUSHJ	S,.ABSFIX	; WRITE OUT THE FIX-UP
	LI	A1,UNDLAB	; "UNDEFINED LABEL "
	PUSHJ	S,INS		; SEND TO LISTING AND TO TTY
	LI	A1,LB		; ADDRESS OF NAME OF LABEL
	PUSHJ	S,INS		; SEND TO LISTING AND TO TTY
	PUSHJ	S,TCHECK	; CR/LF
	AOS	.JBERR		; ADD 1 TO ACCUMULATED ERROR COUNT
	GOTO	ZLAB		; LOOK FOR ANOTHER UNDEFINED LABEL


UNDLAB:	ASCIZ	/UNDEFINED LABEL /
;--------------------------------------------------------
;	MOVE 1-WORD CONSTANTS TO REL-FILE
;--------------------------------------------------------

ZC0:	L	A2,LASTC1	; START OF 1-WORD-CONSTANTS CHAIN
	GOTO	ZC2		; JUMP INTO LOOP

ZC1:	HLRZ	A1,(A2)		; IF BACK-CHAIN IS ZERO
	JUMPE	A1,ZC2-2	; THEN DONT OUTPUT THIS CONSTANT
	L	A1,1(A2)	; GET CONSTANTS VALUE
	HLRZ	A6,(A2)		; GET THE BACK CHAIN
	PUSHJ	S,ZZZ		; OUTPUT THE WORD AND THE BACK CHAIN
	SUB	A2,(A2)		; LOCATE NEXT ENTRY ON CHAIN
	LI	A2,(A2)		; ZERO LEFT HALF

ZC2:	IAGM	A2,CONTAB	; UNLESS END OF CHAIN
	GOTO	ZC1		; LOOP
;--------------------------------------------------------
;	MOVE 2-WORD CONSTANTS TO REL-FILE
;--------------------------------------------------------

	L	A2,LASTC2	; START OF 2-WORD-CONSTANTS CHAIN
	GOTO	ZC4		; JUMP INTO LOOP

ZC3:	L	A1,2(A2)	; GET 1ST WORD OF VALUE
	HLRZ	A6,(A2)		; GET THE BACK CHAIN
	JUMPE	A6,ZC4-2	; IF NO BACK-CHAIN THEN SKIP THIS CONSTANT
	PUSHJ	S,ZZZ		; OUTPUT THE WORD AND ITS FIXUP
	L	A1,3(A2)	; GET 2ND WORD OF VALUE
	HRRZ	A6,1(A2)	; GET THE BACK CHAIN
	PUSHJ	S,ZZZ		; OUTPUT THE WORD AND ITS FIXUP
	SUB	A2,(A2)		; LOCATE NEXT ENTRY ON CHAIN
	LI	A2,(A2)		; ZERO LEFT HALF

ZC4:	IAGM	A2,CONTAB	; UNLESS END OF CHAIN, 
	GOTO	ZC3		; LOOP

;--------------------------------------------------------
;	MOVE STRINGS FROM CONSTANTS TABLE TO REL-FILE
;--------------------------------------------------------

	L	A2,LASTST	; ADDR OF LAST STRING
	GOTO	ZC8		; JUMP INTO LOOP

ZC5:	HLLZ	A1,(A2)		; GET 1ST BACK-CHAIN
	IOR	A1,1(A2)	; OR WITH OTHER BACK-CHAINS
	JUMPE	A1,ZC8-2	; IF ALL 3 ZERO THEN SKIP THIS STRING
	HRRZ	A1,RA		; GET ADDRESS OF EVENTUAL
	ADDI	A1,2		; STRING ADDRESS
	PUSHJ	S,.MREL		; WRITE 1ST WORD OF STRING HEADER
	HLRZ	A6,(A2)		; GET THE BACK CHAIN
	PUSHJ	S,ZZZ+1		; WRITE OUT THE FIXUP
	L	A1,2(A2)	; GET BYTE COUNT
	HRLI	A1,400700	; FILL IN LEFT HALF
	HRRZ	A6,1(A2)	; GET THE 2ND BACK CHAIN
	PUSHJ	S,ZZZ		; WRITE OUT THE WORD AND ITS FIXUP
	IMEZ	2(A2)		; IF STRING IS 0 CHARS LONG
	GOTO	ZC7		; THEN SKIP THIS PART
	PUSH	S,A1		; SAVE VALUE OF RA FOR LATER
	LI	A1,2(A2)	; START OF STRING -1
	ST	A1,TEMP		; PUT IN TEMP
ZC6:	AOS	A1,TEMP		; GET ADDR OF NEXT WORD OF STRING
	L	A1,(A1)		; GET NEXT WORD OF STRING
	PUSHJ	S,.MABS		; WRITE IT OUT
	HRREI	A1,-5		; DECREMENT CHARACTER COUNT
	ADDB	A1,2(A2)	; BY 5
	JUMPG	A1,ZC6		; LOOP IF STILL SOME LEFT

	POP	S,A1		; RETRIEVE OLD VALUE OF RA

ZC7:	PUSH	S,RA		; SAVE CURRENT VALUE OF RA
	ST	A1,RA		; SET RA TO OLD VALUE
	HLRZ	A1,1(A2)	; GET 3RD BACK-CHAIN POINTER
	PUSHJ	S,.RAFIX	; WRITE IT OUT
	POP	S,RA		; RESTORE CORRECT VALUE OF RA
	SUB	A2,(A2)		; STEP TO NEXT STRING
	LI	A2,(A2)		; ZERO LEFT HALF

ZC8:	IAGM	A2,CONTAB	; IF THERE IS ANOTHER STRING
	GOTO	ZC5		; THEN LOOP

;--------------------------------------------------------
;	MOVE CONTENTS OF FIXUP TABLE TO REL-FILE
;--------------------------------------------------------

	PUSHJ	S,FIN		; FINISH
	LI	A1,15		; THIS BUFFER IS FOR
	ST	A1,T10TYP	; TYPE-15 BLOCKS
	L	A1,FIXUP	; ADDR OF FIXUP TABLE
	SUB	A1,NAFTE	; USED LENGTH OF FIX-UP TABLE
	ADDI	A1,-1(A1)	; LENGTH OF STATIC OWN AREA
	HRL	A1,RA		; PROGRAM BREAK
	LI	A3,(A1)		; COPY TO A3
	ADDM	A3,RA		; COMPUTE PROGRAM BREAK
	AOSLE	A3,T10IND	; GET INDEX
	PUSHJ	S,T10GET	; -END OF SUB-BLOCK
	ST	A1,@T10ADR	; OUTPUT WORD
	LI	A3,2		; RELOCATE LEFT HALF
	IDPB	A3,T10PTR	; SET RELOCATION BITS
	L	A1,FIXUP	; ADDRESS OF FIX-UP TABLE
	ZERO	PTR15		; INITIALIZE STATIC OWN AREA POINTER

ZEXIT1:	SUBI	A1,1		; STEP TO NEXT WORD (TABLE GROWS DOWNWARD)
	IALEM	A1,NAFTE	; IF IT END OF TABLE
	GOTO	ZEXIT2		; THEN FINISHED PROCESSING TABLE
	L	A3,(A1)		; GET RIGHT HALF
	PUSHJ	S,MOV15		; PUT INTO TYPE-15 BLOCK
	HLRZ	A3,(A1)		; GET LEFT HALF
	PUSHJ	S,MOV15		; PUT INTO TYPE-15 BLOCK
	GOTO	ZEXIT1		; LOOP
;--------------------------------------------------------
;	SUBROUTINE FOR MOVING TYPE-15 FIXUPS
;--------------------------------------------------------

MOV15:	AOS	A2,PTR15	; GET A VALUE FOR IT
	HRL	A2,A3		; PUT VALUE WITH BACK CHAIN POINTER
	AOSLE	A3,T10IND	; GET INDEX
	PUSHJ	S,T10GET	; -END OF SUB-BLOCK
	ST	A2,@T10ADR	; PUT FIX-UP INTO BUFFER
	LI	A3,2		; BACK POINTER IS RELOCATABLE
	TLNN	A2,777777	; IF THERE IS NO BACK-CHAIN
	LI	A3,0		; THEN BACK POINTER IS NOT RELOCATABLE
	IDPB	A3,T10PTR	; OUTPUT RELOCATION BITS
	POPJ	S,		; EXIT MOV15


;	SUBROUTINE FOR MOVING CONSTANTS TO REL-FILE

ZZZ:	PUSHJ	S,.MABS		; WRITE OUT THE WORD
	L	A1,A6		; MOVE THE CHAIN TO A1
	SOS	RA		; TEMPORARILY BACK UP RA
	PUSHJ	S,.RAFIX	; WRITE OUT THE FIXUP
	AOS	RA		; CORRECT RA
	POPJ	S,		; EXIT ZZZ


;--------------------------------------------------------
;	MOVE TO REL-FILE THE TYPE-2 ENTRIES FOR THE LIBRARY PROCEDURES
;--------------------------------------------------------

ZEXIT2:	SETOM	ECOUNT		; INITIALIZE ALIAS COUNT
	LI	A5,BLOCK0	; 1ST ENTRY IN BLOCK 0

ZEXIT3:	AOS	A2,ECOUNT	; STEP ALIAS INDEX
	L	A2,ATABLE(A2)	; GET ALIAS NAME IN RADIX50
	L	A1,1(A5)	; VALUE FIELD CONTAINS BACK CHAIN
	PUSHJ	S,.FIX50	; WRITE OUT FIX-UP
	L	A1,(A5)		; GET 1ST WORD OF ENTRY
	L	A3,2(A5)	; 1ST WORD OF NAME
	ADDI	A3,1		; ADD 1 TO CHARACTER COUNT
	ANDI	A3,77		; SAVE ONLY CHAR COUNT
	IDIVI	A3,6		; CONVERT TO WORD COUNT MINUS 1
	ADDI	A5,3(A3)	; STEP TO PAST NAME
	TLNN	A1,EXTEN	; IF THIS IS NOT AN EXTENDED ENTRY 
	GOTO	ZEXIT4		; THEN SKIP THIS PART
	L	A1,(A5)		; LOAD 1ST WORD OF EXTENSION
	L	A2,ECOUNT	; GET THE ENTRY COUNT
	L	A2,AT2(A2)	; GET 2ND ALIAS NAME IN RADIX50
	PUSHJ	S,.FIX50	; WRITE OUT FIX-UP
	ADDI	A5,2		; SET PAST EXTENSION TO NEXT ENTRY
ZEXIT4:	IALI	A5,B0END	; IF STILL WITHIN BLOCK 0
	GOTO	ZEXIT3		; THEN LOOP

;--------------------------------------------------------
;	WRITE OUT THE TYPE-5 END BLOCK
;--------------------------------------------------------

	PUSHJ	S,FIN		; FINISH
	HRRE	A1,T1IND	; GET INDEX
	ADDB	A1,T1ADR	; COMPUTE END OF CODE IN BUFFER
	L	A2,[		; THIS IS A TYPE-5 BLOCK
	XWD	5,1]		; OF LENGTH 1
	ST	A2,-1(A1)	; PUT INTO BUFFER
	HRLZI	A2,200000	; RELOCATION BITS
	ST	A2,(A1)		; PUT INTO BUFFER
	L	A2,RA		; GET END OF PROGRAM PLUS 1
	HRRZM	A2,1(A1)	; PUT INTO BUFFER
	ADDI	A1,1		; END OF DATA
	HRRM	A1,T1ADR	; SET NEW T1ADR
	HRRM	A1,BHEAD1+1	; SET END OF DATA
	L	A6,A6SAV	; RESTORE A6
	TLNE	A7,EXISTS	; IF THE LISTING EXISTS
	TLZ	A7,COMPLETE	; THEN MARK IT COMPLETE
	ST	A7,RFLAGS	; SAVE READ MODULE FLAGS
	L	A7,A7SAV	; RESTORE A7
	POPJ	S,		; EXIT .ZZEND


	RELOC

TEMP:	0		; TEMP
PTR15:	0		; STATIC OWN AREA POINTER
ECOUNT:	0		; ENTRY COUNT

	RELOC
;	"NAME" WILL EXTRACT FROM A SYMBOL TABLE ENTRY THE NAME OF THE
;	IDENTIFIER IN ASCIZ FORMAT.  A1 SHOULD CONTAIN THE ADDRESS OF
;	THE SYMBOL TABLE ENTRY.  THE OUTPUT IS IN A BUFFER CALLED "LB"


NAME:	L	A5,LBP		; BYTE PINTER TO OUTPUT BUFFER
	LI	A6,2(A1)	; STEP TO 1ST NAME WORD OF ENTRY
	L	A3,(A6)		; LOAD 1ST NAME WORD
	LSHC	A3,-6		; PEEL OFF LENGTH COUNT
	LSH	A4,-36		; CHAR COUNT -1
	LI	A2,1(A4)	; A2 = CHAR COUNT

NAMEL:	LSHC	A3,-6		; GET NEXT CHAR
	LSH	A4,-36		; MOVE TO RIGHT OF REG
	JUMPE	A4,NAMEL	; IF A NULL THEN GET ANOTHER CHAR
	TRNN	A4,40		; IF IT IS A LETTER
	IORI	A4,100		; THEN CONVERT IT TO ASCII
	IDPB	A4,A5		; PUT IN BUFFER
	JUMPN	A3,.+3		; SKIP IF STILL MORE CHARS IN A3
	ADDI	A6,1		; STEP WORD INDEX
	L	A3,(A6)		; PICK UP NEXT WORD OF NAME
	SOJG	A2,NAMEL	; LOOP ONCE FOR EACH CHAR
	LI	A3,6		; 6
	IDPB	A2,A5		; PUT 6 NULLS AT END OF NAME
	SOJG	A3,.-1		; LOOP
	POPJ	S,		; EXIT NAME
;	*****  B D U M P  *****
;
;	OBJECT MODULE BINARY BLOCK DUMP ROUTINE
;
;
;
;	TO USE THIS ROUTINE:
;
;
;		.GET DSK ALGOL
;
;		.DDT
;
;		DUMP$G
;		*TTY:_PROG.REL
;		    (OR ANY OTHER COMMAND STRING)
;
;		*^C
;		.
;
;
;
;  KNOWN BUGS IN THIS ROUTINE:
;
;   1.)	IF THE LAST DATA WORD OF AN INPUT BUFFER IS THE DESCRIPTOR
;	WORD FOR A NEW LOADER BLOCK, THE ROUTINE WILL COMMENCE PRODUCING
;	GARBAGE.
;
	IFN	DUMPRN,<

BDUMP:	IMNZ	CONTI
	GOTO	BD11
	LI	A6,1(A1)
	L	A2,1(A1)
	ADDI	A2,2(A1)
	HRRZM	A2,BEND
	LI	A5,15
	LI	A15,12
	LI	A4,40
	LI	A7,A14
BD8:	LI	A6,1(A6)
	IAGEM	A6,BEND
	POPJ	S,
	HRRZ	A1,(A6)	
	ST	A1,BLEN
	IMEZ	(A6)
	POPJ	S,
	HLRZ	A2,(A6)	
	L	A11,A2
	IDIVI	A11,10
	ADDI	A11,60
	ADDI	A12,60
	DPB	A11,TYPEP1
	DPB	A12,TYPEP2
	LI	A11,TYPE
	PUSHJ	S,WWRITE
	LI	A16," "
	LI	A3,0
	ST	A3,PLOC
	HLRZ	A2,(A6)	
	IANI	A2,1
	GOTO	BD9
	L	FL,1(A6)
	LSH	FL,1
	IMLZ	FL
	LI	A16,"'"
	HRRZ	A2,2(A6)
	SUBI	A2,1
	ST	A2,PLOC
BD9:	IMNZ	BLEN
	GOTO	BD0
	LI	A6,1(A6)
	GOTO	BD8

BD0:	IMEZ	A13,BLEN
	GOTO	BD8
	LI	A6,1(A6)
	L	FL,(A6)	
	IAGI	A13,^D18
	GOTO	.+3
	ZERO	BLEN
	GOTO	BD1

	SUBI	A13,^D18
	HRRZM	A13,BLEN
	LI	A13,^D18
BD1:	L	A10,[
	XWD	440700,LB]
	HRLI	A7,220300
	L	A14,PLOC
	LI	A1,6

BD2:	ILDB	A12,A7
	ADDI	A12,60
	IDPB	A12,A10
	SOJG	A1,BD2
	IDPB	A16,A10
	L	A11,WPL

BD3:	IDPB	A4,A10
	IDPB	A4,A10
	LI	A3,4

BD4:	HRLI	A7,440300
	LI	A6,1(A6)
	IAGEM	A6,BEND
	GOTO	BD10
	L	A14,(A6)	
	IDPB	A4,A10
	LI	A2,2

BD5:	LI	A1,6

BD6:	ILDB	A12,A7
	ADDI	A12,60
	IDPB	A12,A10
	SOJG	A1,BD6
	LI	A12,"'"
	IMGEZ	FL
	LI	A12," "
	IDPB	A12,A10
	LSH	FL,1
	SOJG	A2,BD5
	AOS	PLOC
	SOJLE	A13,BD7
	SOJG	A3,BD4
	SOJG	A11,BD3

	IDPB	A5,A10
	IDPB	A15,A10
	IDPB	A3,A10
	LI	A11,LB
	PUSHJ	S,WWRITE
	GOTO	BD1
BD7:	IDPB	A5,A10
	IDPB	A15,A10
	IDPB	A13,A10
	LI	A11,LB
	PUSHJ	S,WWRITE
	GOTO	BD0



BD10:	SETOM	CONTI
	ST	A16,BR+16
	L	A16,[
	XWD	0,BR]
	BLT	A16,BR+15
	POPJ	S,


BD11:	ZERO	CONTI
	L	A2,1(A1)
	ADDI	A2,1(A1)
	HRRZM	A2,BEND
	LI	A6,1(A1)
	ST	A6,BR+6
	MOVS	A16,[
	XWD	0,BR]
	BLT	A16,A16
	GOTO	BD4



	RELOC

BEND:	0		; END OF BUFFER
CONTI:	0
BR:	BLOCK	20
BLEN:	0		; NUMBER OF WORDS REMAINING IN BLOCK
PLOC:	0		; NUMBER TO BE PRINTED AS THE ADDRESS
DUMPBF:	BLOCK	3
TYPEP1:	XWD	170700,TYPE+1
TYPEP2:	XWD	100700,TYPE+1
TYPE:	ASCIZ	/
TYPE XY
/

	RELOC
DUMP:	CLOSE	1,0
	RESET
	ZERO	CCLSW
	LI	FL,0
	L	S,[
	XWD	-20,TMPBUF-1]
	LI	A1,DINIT
	PUSHJ	S,BMOVE
	PUSHJ	S,GETCS
	IAEI	6,15
	GOTO	QUIT
	LI	A1,XLIST
	PUSHJ	S,SCAN2
	IANI	6,137
	GOTO	DSERR8
	LI	A1,OLIST
	PUSHJ	S,SCAN2
	OPEN	1,OLIST
	GOTO	DSERR8
	INBUF	1,@OLIST+7
	LOOKUP	1,OFILE
	GOTO	DSERR8
	LI	A1,1
	HLLZ	A2,XLIST+1
	IAEM	A2,[
	SIXBIT	/LPT/]
	LI	A1,2
	ST	A1,WPL
	CLOSE	4,0
	OPEN	4,XLIST
	GOTO	DSERR8
	OUTBUF	4,@XLIST+7
	ENTER	4,XFILE
	GOTO	DSERR8
	OUTPUT	4,0
	ZERO	CONTI

BDL:	IN	1,0
	GOTO	.+2
	GOTO	BDL1
	L	A1,BHEAD4
	PUSHJ	S,BDUMP
	GOTO	BDL
BDL1:	CLOSE	4,0
	GOTO	DUMP


DSERR8:	TTCALL	3,ERR8
	GOTO	QUIT

ERR8:	ASCIZ	/ERROR
/
	RELOC

WPL:	0
XLIST:	0
	0
	XWD	DUMPBF,0
XFILE:	0
	0
	0
	0
	0

	RELOC


WWRITE:	L	A2,DUMPBF+1
	SUB	A2,DUMPBF
	LI	A2,(A2)	
	IALEI	A2,140
	GOTO	.+6
	LI	A2,5
	IDPB	FL,DUMPBF+1
	SOJG	A2,.-1
	SOS	DUMPBF+1
	OUTPUT	4,0
	HRLI	A11,440700
	ILDB	A2,A11
	IDPB	A2,DUMPBF+1
	JUMPN	A2,.-2
	POPJ	S,



DINIT:	XWD	TYPE,3
	ASCIZ	/
TYPE XY
/

	0

	INTERN	DUMP
>
SUBTTL BLOCK0 MODULE

;	THIS MODULE CONTAINS BLOCK0, WHICH IS THE INITIAL SYMBOL TABLE,
;	AND WHICH CONTAINS THE ENTRIES FOR THE LIBRARY PROCEDURES.  BLOCK 0
;	IS IN A DIFFERENT PART OF THE LOW SEGMENT FROM THE REST OF THE
;	SYMBOL TABLE, BUT IS PROPERLY LINKED IN WITH THE OTHER SO THAT
;	ONE CANNOT REALLY TELL THE DIFFERENCE.
;
;	THE MACRO "LIB" HAS BEEN PROVIDED TO SIMPLIFY PLACING THE ENTRIES IN
;	BLOCK 0.  ITS PARAMETERS ARE:
;
;
;	PARAMETER 1: (ALIAS1)	THE ALIAS NUMBER OF THE ROUTINE (WITHOUT THE
;				%-SIGN).
;
;
;	PARAMETER 2: (ALIAS2)	THE ALIAS NUMBER OF THE 2ND ENTRY POINT IF
;				THERE IS ONE (ALSO WITHOUT THE %-SIGN).
;				WHEN THERE IS NO 2ND ENTRY POINT, THIS
;				PARAMETER MUST BE DEFAULTED.
;
;
;	PARAMETER 3: (TYPE)	THE PROCEDURE TYPE, SPECIFIED AS:
;				    I  - INTEGER
;				    R  - REAL
;				    L  - LONG REAL
;				    BO - BOOLEAN
;				    ST - STRING
;				    N  - NON-TYPE
;
;
;	PARAMETER 4: (ACT)	THE NUMBER OF ACTUAL PARAMETERS.  IF THERE
;				CAN BE A VARIABLE NUMBER OF ACTUALS, ENTER
;				A "V" FOR THIS PARAMETER.
;
;
;	PARAMETER 5: (N1)	1ST 5 CHARACTERS OF NAME.
;	PARAMETER 6: (N2)	NEXT 6 CHARACTERS OF NAME.
;	PARAMETER 7: (N3)	NEXT 6 CHARACTERS OF NAME.
;
;				ONLY LETTERS AND DIGITS ARE ALLOWED, NOT SPACES.
;				ANY OF THESE PARAMETERS SHOULD BE OMITTED
;				IF IT WOULD HAVE BEEN NULL.  ALL SPECIFIED
;				PARAMETERS *MUST* BE FOLLOWED IMMEDIATELY
;				BY A COMMA, INCLUDING THE LAST PARAMETER.
	INTERN	SYMHT		; SYMBOL TABLE HASH TABLE
	INTERN	ZBOOL		; ADDR OF ENTRY FOR BOOL
	INTERN	ZINT		; ADDR OF ENTRY FOR INT
	INTERN	ZABS		; ADDR OF ENTRY FOR ABS
	INTERN	ZSIGN		; ADDR OF ENTRY FOR SIGN
	INTERN	ZENTIE		; ADDR OF ENTRY FOR ENTIE
	INTERN	ZENTIL		; ADDR OF ENTRY FOR ZENTIEL
	INTERN	PRASE
	INTERN	PRLIB
	DEFINE	ENTR (IND)
	<
	LLINK=HT'IND
	HT'IND=CLOC-XB0+BLOCK0>


	DEFINE	ENTR1 (NAME,IND)
	<
	NAME'IND>


	DEFINE	ENTR2 (NAME,IND,VAL)
	<
	NAME'IND=VAL>






	DEFINE	INVERT (NX,NXVAL)
	<
	IFNB	<NX>,<
	NY=SIXBIT/NX/
	SHIFTS=0
	NYVAL=0
	INV INV INV INV INV INV
	NXVAL=<NYVAL>_<SHIFTS>> >



	DEFINE	INV
	<
	CCHAR=NY&77
	IFE	CCHAR, <
	SHIFTS=SHIFTS+6 >
	IFN	CCHAR, <
	CCHAR=<CCHAR+40>&77
	NYVAL=<<NYVAL>_<6>>!CCHAR
	CCC=CCC+1 >
	NY=<NY>_<-6> >
	HASH=-1
	REPEAT	200,
<
	HASH=HASH+1
	ENTR2	HT,\HASH,0
>

; THE WEIRD EXPRESSIONS IN LIB ARE TO GET ROUND A BUG IN MACRO-10!!!

	DEFINE	LIB (ALIAS1,ALIAS2,TYPE,ACT,N1,N2,N3)
<
	CCC=-1
	LLINK=0
	CLOC=.
	ENTR2	A1.,\AL1,<<RADIX50 00,%'ALIAS1>&037777777777!600000000000>
	AL1=AL1+1

	IFNB	<ALIAS2>,<
	ENTR2	A2.,\AL2,<<RADIX50 00,%'ALIAS2>&037777777777!600000000000>
	AL2=AL2+1>

	IINDEX=IINDEX+1
	INVERT	N1,N1VAL
	INVERT	N2,N2VAL
	INVERT	N3,N3VAL

	IFNB	<N1>,<
	A=<N1VAL+CCC>_<-11>
	B=N1VAL&777
	TTEMP=B*D/1000+A*D+B*C+A*C*1000
	HASH=<<TTEMP>_<-^D26>>&177
	ENTR \HASH>

								XWD	EXT,LLINK
								XWD	TYPE+ACT,0
	IFB	<N1>,<
								XWD	0,0>
	IFNB	<N1>,<
								N1VAL+CCC>
	IFNB	<N2>,<
								N2VAL>
	IFNB	<N3>,<
								N3VAL>
	IFN	EXT, <
								XWD	0,0
								XWD	0,0
>>
	AL1=0
	AL2=0
	V=-1
	C=647
	D=327
	IINDEX=0

B0LIST:	XWD	BLOCK0,XSYMHT+200-XB0


	I=$I+$EXT+$PRO+$DEC+1
	R=$R+$EXT+$PRO+$DEC+1
	L=$LR+$EXT+$PRO+$DEC+1
	BO=$B+$EXT+$PRO+$DEC+1
	ST=$S+$EXT+$PRO+$DEC+1
	N=$N+$EXT+$PRO+$DEC+1

	EXT=0
XB0:
;	GROUP 1:	BOOL, INT, ABS, SIGN, AND ENTIER.  THIS ORDER
;			CANNOT BE CHANGED.



	LIB	225,,BO,1,BOOL,			; BOOL
	LIB	226,,I,1,INT,			; INT
	LIB	222,,R,1,ABS,			; ABS
	LIB	223,,I,1,SIGN,			; SIGN
	LIB	224,,R,1,ENTIE,R,		; ENTIER
	EXT=400000

XPRASE:
;	GROUP 2:	STANDARD ALGOL LIBRARY PROCEDURES.  EACH MUST
;			HAVE TWO ENTRY POINTS.  THE ORDER IN WHICH PROCEDURES
;			ARE PLACED IN THIS GROUP IS NOT IMPORTANT.



	LIB	100,200,R,1,SIN,		; SIN
	LIB	101,201,R,1,COS,		; COS
	LIB	102,202,R,1,ARCTA,N,		; ARCTAN
	LIB	103,203,R,1,SQRT,		; SQRT
	LIB	104,204,R,1,EXP,		; EXP
	LIB	105,205,R,1,LN,			; LN
	LIB	106,206,R,1,TAN,		; TAN
	LIB	107,207,R,1,ARCSI,N,		; ARCSIN
	LIB	110,210,R,1,ARCCO,S,		; ARCCOS
	LIB	111,211,R,1,SINH,		; SINH
	LIB	112,212,R,1,COSH,		; COSH
	LIB	113,213,R,1,TANH,		; TANH
	LIB	114,214,L,1,LSIN,		; LSIN
	LIB	115,215,L,1,LCOS,		; LCOS
	LIB	116,216,L,1,LARCT,AN,		; LARCTAN
	LIB	117,217,L,1,LSQRT,		; LSQRT
	LIB	120,220,L,1,LEXP,		; LEXP
	LIB	121,221,L,1,LLN,		; LLN
	EXT=0

XPRLIB:
;	GROUP 3:	UNNAMED LIBRARY PROCEDURES.  THE ALGOL USER CANNOT
;			ACCESS THESE ENTRIES BY NAMING THEM IN HIS
;			PROGRAM.  THESE PROCEDURES ARE IN BLOCK 0 ONLY
;			FOR INTERNAL REASONS.  THE STRICT ORDERING OF THESE
;			ENTRIES IS IMPORTANT.


	LIB	1,,R,1,				; POWER1
	LIB	2,,R,1,				; POWER2
	LIB	3,,R,1,				; POWER3
	LIB	4,,R,1,				; POWER4
	LIB	5,,R,1,				; POWER5
	LIB	7,,R,1,				; IR
	LIB	10,,L,1,			; ILR
	LIB	12,,I,1,			; RI
	LIB	13,,L,1,			; RLR
	LIB	15,,I,1,			; LRI
	LIB	16,,R,1,			; LRR
XENTIL:	LIB	14,,L,1,			; ENTIEL
	LIB	17,,L,1,			; DFAD0
	LIB	20,,L,1,			; DFSB0
	LIB	21,,L,1,			; DFMP0
	LIB	22,,L,1,			; DFDV0
	LIB	23,,L,1,			; RDFSB0
	LIB	24,,L,1,			; RDFDV0
	LIB	25,,L,1,			; DFAD3
	LIB	26,,L,1,			; DFSB3
	LIB	27,,L,1,			; DFMP3
	LIB	30,,L,1,			; DFDV3
	LIB	31,,L,1,			; RDFSB3
	LIB	32,,L,1,			; RDFDV3
	LIB	33,,L,1,			; DFAD6
	LIB	34,,L,1,			; DFSB6
	LIB	35,,L,1,			; DFMP6
	LIB	36,,L,1,			; DFDV6
	LIB	37,,L,1,			; RDFSB6
	LIB	40,,L,1,			; RDFDV6
	LIB	41,,L,1,			; DFAD9
	LIB	42,,L,1,			; DFSB9
	LIB	43,,L,1,			; DFMP9
	LIB	44,,L,1,			; DFDV9
	LIB	45,,L,1,			; RDFSB9
	LIB	46,,L,1,			; RDFDV9
XPRAN:
;	GROUP 4:	ALL OTHER LIBRARY PROCEDURES.  THESE ROUTINES
;			MUST HAVE 1 ENTRY POINT.  THE ORDERING OF THESE
;			ENTRIES IS NOT IMPORTANT.


	LIB	300,,I,1,DIM,			; DIM
	LIB	301,,I,2,LB,			; LB
	LIB	302,,I,2,UB,			; UB
	LIB	303,,I,V,IMIN,			; IMIN
	LIB	304,,I,V,IMAX,			; IMAX
	LIB	305,,R,V,RMIN,			; RMIN
	LIB	306,,R,V,RMAX,			; RMAX
	LIB	307,,L,V,LMIN,			; LMIN
	LIB	310,,L,V,LMAX,			; LMAX
	LIB	311,,I,3,GFIEL,D,		; GFIELD
	LIB	312,,N,4,SFIEL,D,		; SFIELD
	LIB	313,,ST,2,TAIL,			; TAIL
	LIB	314,,ST,V,COPY,			; COPY
	LIB	315,,N,V,TRAP,			; TRAP
	LIB	316,,N,2,DUMPI,N,		; DUMPIN
	LIB	317,,N,2,DUMPO,UT,		; DUMPOUT
	LIB	320,,ST,2,NEWST,RING,		; NEWSTRING
	LIB	321,,I,1,LENGT,H,		; LENGTH
	LIB	322,,N,1,DELET,E,		; DELETE
	LIB	323,,N,V,LINK,			; LINK
	LIB	324,,N,V,LINKR,			; LINKR
	LIB	401,,N,1,INSYM,BOL,		; INSYMBOL
	LIB	402,,N,1,OUTSY,MBOL,		; OUTSYMBOL
	LIB	403,,N,1,NEXTS,YMBOL,		; NEXTSYMBOL
	LIB	404,,N,0,SKIPS,YMBOL,		; SKIPSYMBOL
	LIB	405,,N,0,BREAK,OUTPUT,		; BREAKOUTPUT
	LIB	406,,N,V,SPACE,			; SPACE
	LIB	407,,N,V,TAB,			; TAB
	LIB	410,,N,V,NEWLI,NE,		; NEWLINE
	LIB	411,,N,V,PAGE,			; PAGE
	LIB	412,,N,V,READ,			; READ
	LIB	413,,N,1,WRITE,			; WRITE
	LIB	414,,N,V,PRINT,			; PRINT
	LIB	415,,N,V,READO,CTAL,		; READOCTAL
	LIB	416,,N,1,PRINT,OCTAL,		; PRINTOCTAL
	LIB	417,,N,V,INPUT,			; INPUT
	LIB	420,,N,V,OUTPU,T,		; OUTPUT
	LIB	421,,N,1,SELEC,TINPUT,		; SELECTINPUT
	LIB	422,,N,1,SELEC,TOUTPU,T,	; SELECTOUTPUT
	LIB	423,,N,1,RELEA,SE,		; RELEASE
	LIB	424,,N,V,OPENF,ILE,		; OPENFILE
	LIB	425,,N,1,CLOSE,FILE,		; CLOSEFILE
	LIB	426,,N,0,TRANS,FILE,		; TRANSFILE
	LIB	427,,N,1,BACKS,PACE,		; BACKSPACE
	LIB	430,,N,1,ENDFI,LE,		; ENDFILE
	LIB	431,,N,1,REWIN,D,		; REWIND
	LIB	432,,BO,1,IOCHA,N,		; IOCHAN
	LIB	433,,N,0,FORTI,O,		; FORTIO
	LIB	434,,N,V,CALL,			; CALL
	LIB	435,,I,V,ICALL,			; ICALL
	LIB	436,,R,V,RCALL,			; RCALL
	LIB	437,,L,V,DCALL,			; DCALL
	LIB	440,,BO,V,LCALL,		; LCALL

XB0END:				; END OF BLOCK 0
XSYMHT:
	HASH=-1
	REPEAT	200,
<
	HASH=HASH+1
	ENTR1	HT,\HASH
>
	XWD	0,0

ATABLE:				; TABLE OF LIBRARY ROUTINE ALIAS NAMES

	ALC=-1
	REPEAT AL1,
<
	ALC=ALC+1
	ENTR1	A1.,\ALC
>
AT2=.-5				; TABLE OF 2-ENTRY LIBRARY ALIAS NAMES

	ALC=-1
	REPEAT AL2,
<
	ALC=ALC+1
	ENTR1	A2.,\ALC
>
	RELOC

BLOCK0:
ZBOOL:	BLOCK	3
ZINT:	BLOCK	3
ZABS:	BLOCK	3
ZSIGN:	BLOCK	3
ZENTIE:	BLOCK	4
PRASE:
	BLOCK	XPRLIB-XPRASE
PRLIB:
	BLOCK	XPRAN-XPRLIB
PRAN:
	BLOCK	XB0END-XPRAN
B0END:

SYMHT:	BLOCK	200

ZENTIL=XENTIL-XB0+BLOCK0
SUBTTL DATA MODULE

	IFNDEF $DEBUG,<$DEBUG=0> ; LOCALS IN STACK

	DEFINE MOD(N,ALOC)
	<INTERN B.'N
	INTERN Q.'N;
	Q.'N=ALOC
	B.'N: BLOCK ALOC
	>

;..STORAGE ALLOCATION FOR MODULES...LOCALS IN MEMORY

	IFN $DEBUG,<
	MOD(MDEC,21);
	MOD(MSTM,12);
	MOD(MEXP,41);
	MOD(MFOR,22);
	MOD(MUTL,5);
	MOD(MSER,16);
	MOD(MCOD,2);
	MOD(MFUN,1);
	>

;..STORAGE ALLOCATION FOR MODULES...LOCALS IN STACK

	IFE $DEBUG,<
	MOD(MDEC,0);
	MOD(MSTM,0);
	MOD(MEXP,0);
	MOD(MFOR,12);
	MOD(MUTL,2);
	MOD(MSER,16);
	MOD(MCOD,2);
	MOD(MFUN,1);
	>
SUBTTL GLOBAL VARIABLES (FULL WORDS)

	DEFINE GLOB(G)
	<INTERN G
	G: 0
	>

	GLOB DYNA.PROC;		;DYNAMIC TRACE ON/OFF FOR PROCEDURE CALLS 
	GLOB DYNA.IF;		;DYNAMIC TRACE ON/OFF FOR IF STATEMENTS
	GLOB DYNA.WHILE;	;DYNAMIC TRACE ON/OFF FOR WHILE STATEMENTS
	GLOB DYNA.LOOP;		;DYNAMIC TRACE ON/OFF FOR LOOP STATEMENS
	GLOB NSYM;		;NEXT SYMBOL
	GLOB NDEL;		;NEXT DELIMITER
	GLOB BLOCKLEVEL;	;CURRENT BLOCKLEVEL
	GLOB FNLEVEL;		;CURRENT FUNCTION LEVEL
	GLOB STBB;		;SYMBOL TABLE BASE FOR THIS BLOCK
	GLOB NASTE;		;NEXT AVAIL. SYMBOL TABLE ENTRY
	GLOB NACTE;		;NEXT AVAIL. CONSTANTS TABOL ENTRY
	GLOB NAFTE;		;NEXT AVAILABLE FIXUP TABLE ENTRY;
	GLOB FIXUP;		;BASE OF FIXUP TABLE;
	GLOB CONTAB;		;CONSTANT TABLE BASE;
	GLOB CAX;		;PROCEDURE LEVEL OF LAST ACCESSED NON-LOCAL
	GLOB RA;		;RELATIVE ADDRESS OF NEXT INSTRUCTION PLACED IN 
			;OBCODE
	GLOB LEXBLOCK;		;MONOTONICALLY INCREASING COUNT OF BLOCKS
	GLOB CURBLOCK;		;LEXBLOCK OF CURRENT BLOCK
	GLOB ARDEC;		;ARRAY DECLARED IN BLOCK => TRUE; ELSE FALSE
	GLOB PROSKIP;		;PROCEDURE FOUND SWITCH (-1 NONE FOUND) OR ADDR OF FIRST ONE
	GLOB LINENO;		;LINE NUMBER SPECIFIED BY LINE PSEUDO-STATEMENT
	GLOB INDEX;		;FIRST AVAILABLE FREE WORD IN TEMPCODE
	GLOB HANDLE;		;PORTION POINTER FOR CURRENTLY OPEN PORTION
	GLOB LEXEX;		;BLOCKLEVEL & HANDLE FOR SYM	* THESE
	GLOB COMPNAME;		;COMPOSIT NAME FOR SYM		* MUST
	GLOB LLEXEX;		;BLOCKLEVEL & HANDLE FOR LEFT OP* APPEAR
	GLOB LCOMPNAME;		;COMPOSIT NAME FOR LEFT OP	* TOGETHER
	GLOB LAC;		;LAST ALLOCATED ACCUMULATOR
	GLOB TCBASE;		;THE FIRST LOCATION OF TEMPCODE BUFFER.
	GLOB TCMAX;		;THE LAST LOCATION OF TEMPCODE BUFFER.
	GLOB THUNK;		;ADDRESS OF JRST OVER THUNKS (0 IF NONE YET.);
	GLOB OP;		;CONTAINS THE OPERATOR DURING CODE GENERATION;
	GLOB KA;		;COMMUNICATIONS CELL FOR GLOAD AND LOAD;
	GLOB FBSYMSAVE;		;SAVED STEP ELEMENT LEXEME
	GLOB FBLEXSAVE;
	GLOB FBCOMPSAVE;
	GLOB PREFACC;		;PREFERED REGISTER FOR CGINCR
;THIS IS LEXICAL SCANNER'S TABLE OF LINE POINTERS.

	GLOB PLIST;

	BLOCK 6;

	RELOC

END
4Y