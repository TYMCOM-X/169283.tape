BLISS  V. 1.0-2.12	13-JUN-73  13:50:37	OUTMO1	OUTMHD.BLI		PAGE 1-1

BC	 !***COPYRIGHT 1973,DIGITAL EQUIPMENT CORP., MAYNARD, MASS.
BMODULEOPMODRESERVSREGFREGVREGBREGMLISTDREGSTIMERGLOROUTIMERC	 MODULE OPMOD(RESERVE(0,1,2,3),SREG=#17,FREG=#16,VREG=#15,BREG=#14,MLIST,DREGS=4,TIMER,GLOROUTINES)=
BBEGINC	 BEGIN
BC	 !**COPYRIGHT 1972,1973, DIGITAL EQUIPMENT CORPORATION, MAYNARD, MA**
BC	 !EDITED SEPT 14,1972 - FI
BC	 !EDITED AUG 29,1972 - SRM
BC	 !EDITED AUG 27,1972 - SRM
BC	 !EDITED AUG 18,1972 - SRM
BC	 !EDITED 8/11/72 SRM
BC	 !LAST CHANGED 8/7/72 SRM.
BC	 !FIRST VERSION #40
BGLOBALDBBINDFIRSVC	 GLOBAL BIND FIRSV = #74;	!11-APRIL-73
BC	 
BC	 !FIRST MUST BE COMPILED IN THE ORDER ...,FIRST,TABLES,...
BC	 !TO SAVE SPACE AND INCREASE COMPILATION SPEED, ALL MACRO DEFINITIONS
BC	 !OF THE FORM "NAME = NUMBER$" HAVE BEEN CHANGED TO BIND'S.
BC	 
BBINDTBLMAXC	 BIND	TBLMAX=3,
BTBLSIZC	 	TBLSIZ=10;
BSTRUCTC	 STRUCTURE
BMATRIXMATRIXIIJIJMATRIXITBLSIZJC	 	MATRIX[I,J]=[I*J](.MATRIX+(.I-1)*TBLSIZ+.J);
BEXTERNMATRIXCHNLTBCHNLTBTBLMAXTBLSIZC	 EXTERNAL MATRIX CHNLTBL[TBLMAX,TBLSIZ];
BBINDBINC	 BIND	BIN=1,
BLSTC	 	LST=2,
BSRCC	 	SRC=3;
BMACROSTATUSIC	 MACRO	STATUS(I)=CHNLTBL[I,0]$,
BDEVICEIC	 	DEVICE(I)=CHNLTBL[I,1]$,
BBUFFERIC	 	BUFFERS(I)=CHNLTBL[I,2]$,
BBUFHDRIC	 	BUFHDR(I)=CHNLTBL[I,3]$,
BBUFPNTIC	 	BUFPNT(I)=CHNLTBL[I,4]$,
BBUFCNTIC	 	BUFCNT(I)=CHNLTBL[I,5]$,
BFILENAIC	 	FILENAME(I)=CHNLTBL[I,6]$,
BEXTENSIC	 		EXTENSION(I)=CHNLTBL[I,7]<18,18>$,
BDSKERRIC	 		DSKERR(I)=CHNLTBL[I,7]<0,18>$,
BPROTIC	 		PROT(I)=CHNLTBL[I,8]<27,9>$,
BDIRECTIC	 	DIRECTORY(I)=CHNLTBL[I,9]$;
BMACROFOUNDFFIRSTSC	 MACRO	FOUNDFLG=	35,1$,	FIRSTSTA=	17,1$,
BTTYDEVENDFILC	 	TTYDEV=	34,1$,	ENDFILE=	16,1$,
BNOWARNWILDLSC	 	NOWARNING=	33,1$,	WILDLSTFIL=	15,1$,
BBIT3INIOLIC	 	BIT3=	32,1$,	INIOLIST=	14,1$,
BBIT4OBJECTC	 	BIT4=	31,1$,	OBJECT=	13,1$,
BBIT5WILDOBC	 	BIT5=	30,1$,	WILDOBJFIL=	12,1$,
BBIT6KA10C	 	BIT6=	29,1$,	KA10=	11,1$,
BBIT7LISTINC	 	BIT7=	28,1$,	LISTING= 10,1$,
BBIT8TAPENDC	 	BIT8=	27,1$,	TAPEND=	9,1$,
BFATALEWINDC	 	FATALERR=	26,1$,	WIND=	8,1$,
BPEEPFLZEROC	 	PEEPFL=	25,1$,	ZERO=	7,1$,
BBTTMSTCROSSRC	 	BTTMSTFL=	24,1$,	CROSSREF=	6,1$,
BCKA10DEBUGC	 	CKA10=	23,1$,	DEBUG=	5,1$,
BSYNONLEXPANDC	 	SYNONLY=	22,1$,	EXPAND=	4,1$,
BERRSWINCLUDC	 	ERRSW=	21,1$,	INCLUDE=	3,1$,
BEOPMACROCC	 	EOP=	20,1$,	MACROCODE=	2,1$,
BSTATFLNOERROC	 	STATFLG=	19,1$,	NOERRORS=	1,1$,
BFELFLGOPTIMIC	 	FELFLG=	18,1$,	OPTIMIZE=	0,1$;
BREGISTCR2R1C	 	REGISTER C = 3, R2 = 2, R1 = 1;
BBINDCHRCFLGREGC	 	BIND CHR = C,FLGREG=0;	!NEEDED FOR BETTER CODE
BC	 !
BLISS  V. 1.0-2.12	13-JUN-73  13:50:40	OPMOD	FIRST.BLI		PAGE 1-2

BC	 
BC	 	%(***DEFINE THE FLAGS USED BY PHASE 2 SKEL AND PHASE 3***)%
BMACROBTTMSTC	 MACRO	BTTMSTFNFLG=FLGREG<BTTMSTFL>$,		!SET FOR BOTTOMOST ROUTINES
BCKA10FC	 	CKA10FLG=FLGREG<CKA10>$,		!SET FOR COMPILING ON KA10
BKA10FLC	 	KA10FLG=FLGREG<KA10>$,			!SET FOR COMPILING FOR KA10
BPEEPFLC	 	PEEPFLG=FLGREG<PEEPFL>$;		!SET FOR PEEPHOLE OPTIMIZER
BC	 						! SHOULD BE USED
BC	 		
BBINDDEGUGC	 	BIND DEGUG = 0;	!FOR DEBUG OPTIONS
BC	 !
BMACROXTRACC	 	MACRO XTRAC = IF DEGUG THEN IF .DTRACE NEQ 0 THEN XCALL()$;
BBINDOPTIMIC	 	BIND OPTIMIZER = 0;
BMACHOPJRSTJRSTLSHCADDC	 	MACHOP JRST = #254,LSHC = #246,ADD=#270;
BMACHOPTTCALLCALLIC	 	MACHOP TTCALL = #051, CALLI = #047;
BMACHOPASHCADDBTLZEAOSMOVEIMOVEIC	 	MACHOP ASHC = #244, ADDB = #273, TLZE = #623, AOS = #350,MOVEI = #201;
BC	 !
BMACROSIGCHAC	 	MACRO SIGCHAR = (DO CHAR() WHILE .C  LEQ " "; .C)$;
BMACROOUTCHRXC	 	MACRO OUTCHR(X) = TTCALL(1,X)$,
BINCHWLXC	 		INCHWL(X) = TTCALL(4,X)$,
BOUTSTRXC	 		OUTSTR(X) = TTCALL(3,X)$;
BC	 !THE MACROS BELOW IMPLEMENT THE FOLLOWING ALGORITHM WITH 2 INSTRUCTIONS
BC	 !
BC	 !	((VREG_(.C - START OF RANGE) MOD 1^18) MOD 1^36) LEQ (END OF RANGE - START OF RANGE)
BC	 !
BMACROC	 MACRO
BALPHAXC	 	ALPHA(X) = MOVEI(VREG,-"A",X) LEQ ("Z"-"A")$,
BDIGITXC	 	DIGIT(X) = MOVEI(VREG,-"0",X) LEQ 9$,
BLCALPHXC	 	LCALPHA(X) = MOVEI(VREG,-("A"+" "),X) LEQ ("Z"-"A")$;
BC	 !
BC	 !	THE MODULE GLOBL CONTAINS ALL THE ARRAY DECLARATIONS AND TABLE (PLIT)
BC	 !	DEFINITIONS THAT WILL BE USED BY SUBSEQUENT ROUTINES THAT ARE
BC	 !	IN SEPARATE FILES. THE PURPOSE OF THAT FILE IS TO PROVIDE ONE 
BC	 !	PLACE WHERE ALL DECLARATIONS THAT ARE GLOBAL TO THE SCOPE OF
BC	 !	THE ENTIRE COMPILER CAN BE FOUND EASILY.
BC	 !
BC	 !
BC	 !	THE FOLLOWING MACROS AND DECLARATIONS PERTAIN TO THE TABLE MANAGEMENT
BC	 !	ROUTINE TBLSEARCH() AND ALSO THE CORE MANAGEMENT ROUTINE CORMAN().
BC	 !
BC	 !	THE FOLLOWING MACROS ARE USED TO DEFINE THE PARAMETERS FOR THE
BC	 !	STRUCTURE DECLARATIONS USED TO DEFINE THE ACCESSING ALGOITHMS
BC	 !	FOR THE DYNAMIC TABLES USED BY THE FORTRAN COMPILER.
BC	 !	THESE MACROS DEFINE FIELDS AND SUB-FIELDS IN TABLE ENTRIES.
BC	 !	FIELDS MAY BE A FULL WORD OR HALF WORD OR LESS.
BC	 !
BMACROFULLC	 	MACRO   FULL = 0,36$;
BMACRORIGHTC	 	MACRO	RIGHT = 0,18$;
BMACROLEFTC	 	MACRO	LEFT = 18,18$;
BMACROC	 	MACRO
BCLINKC	 		CLINK = 0,0,RIGHT$,	%CURRENT LINK FIELD%
BNLINKC	 		NLINK = 1,0,RIGHT$,	%NEW (NEXT) LINK FIELD%
BCW0LC	 		CW0L =	0,0,LEFT$,	%LEFT HALF LINK WORD%
BCW0RC	 		CW0R = 0,0,RIGHT$,
BCW1LC	 		CW1L = 0,1,LEFT$,	%LEFT HALF WORD 1%
BCW1RC	 		CW1R = 0,1,RIGHT$,	%RIGHT HALF WORD1; 1%
BCW1C	 		CW1 =	0,1,FULL$,	%CURRENT FIRST WORD IN ENTRY%
BCW2C	 		CW2 = 0,2,FULL$,	%SECOND WORD%
BLISS  V. 1.0-2.12	13-JUN-73  13:50:44	OPMOD	FIRST.BLI		PAGE 1-3

BCW2RC	 		CW2R =  0,2,RIGHT$,	% "	SECOND WORD (RIGHT HALF)%
BCW2LC	 		CW2L =  0,2,LEFT$,	% "	SECOND WORD LEFT HALF%
BCW3C	 		CW3  =  0,3,FULL$,	% THIRD WORD%
BCW3LC	 		CW3L =	0,3,LEFT$,
BCW3RC	 		CW3R = 	0,3,RIGHT$,
BCW4C	 		CW4  =  0,4,FULL$,	%FOURTH WORD%
BCW4LC	 		CW4L = 	0,4,LEFT$,
BCW4RC	 		CW4R =  0,4,RIGHT$,
BCW5C	 		CW5 = 0,5,FULL$,
BCW5RC	 		CW5R =  0,5,RIGHT$,		!FIFTH WORD
BCW5LC	 		CW5L =  0,5,LEFT$,
BCW6LC	 		CW6L =  0,6,LEFT$,
BCW6RC	 		CW6R =  0,6,RIGHT$,
BCW7LC	 		CW7L =	0,7,LEFT$,
BCW7RC	 		CW7R =	0,7,RIGHT$;
BLISS  V. 1.0-2.12	13-JUN-73  13:50:53	OPMOD	FIRST.BLI		PAGE 2-1

BC	 !	THE FOLLOWING MACROS DEFINE THE IDATTRIBUTES OF AN IDENTIFIER
BC	 !	IDATTRIBUT(X). WHERE X IS ONE OF THE FOLLOWING:
BC	 !
BMACROALLOFTC	 	MACRO	ALLOFTHEM=	18,18$,
BDEFINDC	 		DEFIND	=	#576000$,! *        !101 111 110 000 000 000
BNOTFUNC	 		NOTFUNC	=	#437400$,!    @     !100 011 111 100 000 000
BNOTVARC	 		NOTVAR	=	#500000$,!       +  !101 000 000 000 000 000
BC	 
BNAMNAMC	 		NAMNAM  =	35,1$,	 ! *  @  +  !NAMELIST NAME
BCOMBLC	 		COMBL	=	34,1$,	 ! *  @  +  !COMMON BLOCK NAME
BSFNC	 		SFN	=	33,1$,	 ! *     +  !STATEMENT FUNCTION NAME
BINUSEC	 		INUSE	=	32,1$,	 ! *        !IN USE IN SUBPROGRAM
BSTORDC	 		STORD	=	31,1$,	 ! *  @     !VARIABLE IS STORED INTO
BINASSIC	 		INASSI	=	30,1$,	 ! *  @     !IN ASSIGN STATMENT
BINNAMC	 		INNAM	=	29,1$,	 ! *  @     !IN NAMELIST
BFENTRYC	 		FENTRYNAME 	=	28,1$,	 ! *  @     !NAME IS AN ENTRY INTO A FUNCTION OR SUBROUTINE
BINEQVC	 		INEQV	=	27,1$,	 !    @     !IN EQUIVALENCE
BINCOMC	 		INCOM	=	26,1$,	 !    @     !IN COMMON BLOCK
BINGLOBC	 		INGLOB  =	25,1$,	!INGLOBAL
BSFDUMMC	 		SFDUMMY	=	25,1$,	 !USED AS DUMMY IN STATEMENT FUNCTION
BINDATAC	 		INDATA	=	24,1$,	 !          !IN DATA STATEMENT
BINEXTEC	 		INEXTERN =	23,1$,	 !	    !IN EXTERNAL STATEMENT
BDUMMYC	 		DUMMY =		22,1$,	 !	    !DUMMY PARAMETER
BISPROTC	 		ISPROT = 	21,1$,	 !	    !ARRAY IS TO BE PROTECTED
BLIBRFUC	 		LIBRFUN = 	20,1$,	!	!IDENTIFIER IS A LIBRARY FUNCTION
BISDEFIBC	 		ISDEFIND(B)=(.B[IDATTRIBUT(ALLOFTHEM)] AND DEFIND) NEQ 0$,
BISNOTFBC	 		ISNOTFUNC(B)=(.B[IDATTRIBUT(ALLOFTHEM)] AND NOTFUNC) NEQ 0$,
BISNOTVBC	 		ISNOTVAR(B)=IF (.B[IDATTRIBUT(ALLOFTHEM)] AND NOTVAR) NEQ 0 THEN
BC	 				BEGIN
BC	 					ENTRY[0]_@ISN;
BC	 					IF .B[IDATTRIBUT(SFN)] THEN
BC	 						(ENTRY[1]_SFPLIT;ENTRY[2]_B[IDSYMBOL];ENTRY[3]_ARGPLIT;ERROUT(E4))
BC	 							ELSE (ENTRY[1]_B[IDSYMBOL];ERROUT(E6))
BC	 				END$;
BC	 !
BC	 !
BC	 !THE STRUCTURE ACCESS FOR A SYMBOL TABLE ENTRY
BC	 !
BMACROIDLINKC	 MACRO	IDLINK	 = CLINK$,
BIDOPTIC	 	IDOPTIM	= CW0L$,	!FOR OPTIMIZATION
BIDDIMC	 	IDDIM	= CW0L$,	!PTR TO DIMENSIONS
BIDOPERC	 	IDOPER	= CW1R$,	!OPERATOR FIELD
BIDCHOSC	 	IDCHOS	=0,2,20,5$,	!LOOP #  USED IN DEF PT CALCULATION
BIDUSEDC	 	IDUSED = 0,2,19,1$,	!FLAG USED IN DEF PT CALCULATION
BIDDEFC	 	IDDEF	=0,2,18,1$,
BIDATTRXC	 	IDATTRIBUT(X) = 0,1,X$,
BIDTARGC	 	IDTARGET = CW2$,	!TARGET FOR ADDRESSING IN CODE GEN
BIDADDRC	 	IDADDR  = CW2R$,	!FOR ADDRESSING
BIDSYMBC	 	IDSYMBOL  = CW3$,	!SYMBOL IN SIXBIT
BIDCOMMC	 	IDCOMMON  = CW4L$,	!PTR TO COMMON BLOCK NAME IF IN COMMON
BC	 				!ALSO PTR TO NAMELIST ARG BLK IF NAMELIST
BIDDATVC	 	IDDATVAL=CW4R$,		!FOR DATASTMNT PROCESSING: THIS WD IS USED TO HOLD THE
BC	 				! THE CURRENT *VALUE* OF THIS VARIABLE IF IT IS
BC	 				! A LOOP INDEX FOR A DATA STATEMNT 
BIDFNATC	 	IDFNATTRIB= CW4$,	!ATTRIBUTE-FIELD FOR A FUNCTION NAME (THIS
BC	 				! WORD IS USED FOR IDDATA,IDCOMMON FOR VARS)
BC	 				! THIS FIELD CONTINUES THE ATTRIBUTES OF A
BLISS  V. 1.0-2.12	13-JUN-73  13:50:56	OPMOD	FIRST.BLI		PAGE 2-2

BC	 				! LIBRARY FUNCTION
BC	 				!THE FOLLOWING ARE SUBFIELDS OF IDFNATTRIB FIELD:
BIDINLIC	 	IDINLINFLG=0,4,35,1$,	!FLAG FOR "THIS FN CAN BE EXPANDED IN LINE"
BIDINLIC	 	IDINLINOPR=CW4R$,	!OPERATOR TO BE USED FOR THE IN-LINE FN
BC	 				! NODE THAT CAN BE SUBSTITUTED FOR THIS FN (IF
BC	 				! THERE IS ONE)
BIDSFNLC	 	IDSFNLAB=CW5L$,		!LOCAL LABEL ASSIGNED TO A STATEMENT FUNCTION
BIDCOLIC	 	IDCOLINK = CW5R$;	!LINK TO NEXT SYMBOL IN COMMON BLOCK THAT
BC	 				!THIS SYMBOL IS IN
BC	 
BC	 
BC	 !
BC	 !THE STRUCTURE ACCESS FOR CONSTANT TABLE
BC	 !
BMACROCONLINC	 MACRO	CONLINK	 = CLINK$,
BCONOPEC	 	CONOPER  = CW1R$,	!OPERATOR FIELD
BCNTOBEC	 	CNTOBEALCFLG= 0,1,35,1$,	!FLAG FOR "THIS CONSTANT NEEDS TO BE IN CORE"
BCONADDC	 	CONADDR = CW2R$,	!HISEG ADDR OF THIS CONSTANT
BCONST1C	 	CONST1   = CW3$,	!HIGH ORDER VALUE(CONTAINS REAL PART OR HI ORDER OF DP OR SINGLE REAL )
BCONST2C	 	CONST2	 = CW4$;	!LOW ORDER VALUE (CONTAINS INTEGER VALUE)
BC	 !
BC	 !THE STRUCTURE FOR THE LITERAL TABLE
BC	 !
BMACROLITSIZC	 MACRO	LITSIZ	 = CW0L$,	!SIZ OF LITERAL IN WORDS
BLITLINC	 	LITLINK	 = CLINK$,	!LINK TO NEXT LITERAL
BLITOPEC	 	LITOPER	= CW1R$,	%OPER FIELD OF LITERAL%
BLITFLGC	 	LITFLGS = CW1L$,	!LITERAL FLAG FIELD
BLITEXWC	 	LITEXWDFLG=0,1,34,1$,	!FLAG INDICATING THAT THIS LITERAL HAS AN EXTRA
BC	 				! WD ON THE END CONTAINING ONLY  A NULL (THIS
BC	 				! IS NECESSARY IF THE NUMBER OF CHARS FITTED INTO AN
BC	 				! EXACT NUMBER OF WDS)
BLITADDC	 	LITADDR = CW2$,	!ADDR OF LIT STRING
BLIT1C	 	LIT1=CW3$,	!1ST WD OF THE LITERAL STRING (ASCII - LEFT JUSTIF)
BLIT2C	 	LIT2=CW4$,	!2ND WD OF THE LITERAL STRING (WILL BE FILLED WITH NULLS IF
BC	 			! STRING IS ONLY 1 WD
BC	 			!SUCCESSIVE WDS OF THE LITERAL WILL BE STORED IN WDS FOLLOWING
BLITWDIXC	 	LITWD(IX)=0,2+IX,FULL$,	!TO ACCESS THE NTH WORD OF  A LITERAL
BC	 					! (NOTE THAT THE 1ST WD IS WORD 1)
BFIRSTLC	 	FIRSTLIT = LITTBL[0]$;
BC	 
BC	 	%(***DEFINE A SPECIAL STRUCTURE TO ACCESS THE NTH WORD OF  A LITERAL***)%
BSTRUCTLITERALITERACTCTC	 	STRUCTURE LITERALENTRY[CT]=
BLITERACTC	 	(@.LITERALENTRY + 3 + .CT-1)<0,36>;
BC	 !
BC	 !THE STRUCTURE ACCESS FOR THE COMMON BLOCK NAME TABLE
BC	 !
BMACROCOMSIZC	 MACRO	COMSIZE	 = CW0L$,	!SIZ OF THIS COMMON BLOCK IN WORDS
BCOMLINC	 	COMLINK	 = CLINK$,	!LINK TO NEXT BLOCK
BCOMNAMC	 	COMNAME  = CW1$,	!BLOCK NAME IS SIXBIT
BCOMFIRC	 	COMFIRST  = CW2L$,	!FIRST ENTRY IN BLOCK PTR
BCOMLASC	 	COMLAST  = CW2R$,	!LAST ENTRY IN BLOCK PTR
BCOMADDC	 	COMADDR = CW3L$,	!THE RELATIVE LOCATION OF THIS BLOCK IN COMMON
BNEXCOMC	 	NEXCOMBLK  =CW3R$;	!PTR TO NEXT COMMON BLOCK IN SEQUENCE AS DEFINED
BC	 					!FOR ALLOCATION PURPOSES
BLISS  V. 1.0-2.12	13-JUN-73  13:51:01	OPMOD	FIRST.BLI		PAGE 3-1

BC	 !THE STRUCTURE ACCESS FOR THE EQIVALENCE GROUP TABLE ENTRY
BC	 !
BMACROEQVINCC	 MACRO	EQVINCOM  = 0,0,35,1$,	!IS GROUP IN COMMON BIT
BEQVAVAC	 	EQVAVAIL = 0,0,33,2$,	!AVAILABLE FOR SEARCHING BIT 0=AVAIL
BC	 				!1=OK FOR SEARCH, 2=NOT AVAIL
BEQVLINC	 	EQVLINK  = CLINK$,	!LINK TO NEXT GROUP
BEQVLIMC	 	EQVLIMIT = CW1R$,	!LIMIT VALUE OF EQUIV CLASS
BEQVLASC	 	EQVLAST = CW2R$,	!PTR TO LAST LIST ENTRY IN GROUP
BEQVHEAC	 	EQVHEAD  = CW1L$,	!PTR TO ACTUAL HEAD OF GROUP
BEQVFIRC	 	EQVFIRST = CW2L$,	!PTR TO FIRST ITEM IN GROUP
BEQVADDC	 	EQVADDR = CW3$;	!DISPLACEMEN OF CLASS 'HEAD' FROM 0
BC	 !
BC	 !THE STRUCTURE ACCES FOR THE EQUIVALENCE LIST ENTRY
BC	 !
BMACROEQLINDC	 MACRO	EQLINDIC  = 0,0,35,1$,	!INDICATES SYMBOL NOT DIMENSIONED YET
BEQLLINC	 	EQLLINK  = CLINK$,	!LINK TO NEXT SYMBOL
BEQLIDC	 	EQLID	 = CW1R$,	!PTR TO SYMBOLTABLE
BEQLDISC	 	EQLDISPL  = CW2$,	!DISPLACEMENT OF THIS SYMBOL FROM GROUP HEAD
BEQLLISC	 	EQLLIST = CW1L$;	!PTR TO LIST OF SUBSCRIPTS (CONSTANTS)
BC	 !
BC	 !THE STRUCTURE ACCESS FOR  ENCODED SOURCE (EXECUTABLE PROGRAM) TREE
BC	 !
BMACROSRCIDC	 MACRO	SRCID	 = 0,1,1,7$,	!ID CODE OF STATEMENT
BSRCLINC	 	SRCLINK	 = CLINK$,	!LINK PTR TO NEXT STATEMENT HEADER
BSRCISNC	 	SRCISN	 = CW0L$,	!INTERNAL SEQUENCE NUMBER OF STAEMENT
BSRCFLAC	 	SRCFLAGS = CW1L$,	!FLAGS FOR LABEL TABLE
BINNERDC	 	INNERDOFLG = 0,1,35,1$,	!FLAGS INNERMOST DO STATEMENTS
BSRCOPEC	 	SRCOPER  = CW1R$,	!OPER FIELD- OPERCLS = STATEMENT
BC	 				!OPERSPC = SRCID
BSRCLBLC	 	SRCLBL	 = CW3L$,	!LABEL TABLE POINTER (0 IF NO LABEL)
BSRCOPTC	 	SRCOPT	 = CW2R$,	!PTR TO OPTIMIZATION WORDS USED BY PHAZ 2
BSRCCOMC	 	SRCCOMNSUB = CW2R$,		!COMMON SUBEXPRESSION HERE
BSRCCMPC	 	SRCCMPLX=CW2L$,			!NUMBER OF REGS USED FOR THIS STMNT.
BC	 
BC	 
BC	 	%(***DEFINE A MACRO TO USE IN SPECIFYING OPERATOR FIELDS OF STATEMENT NODES-
BC	 		FOR A STMNT NODE THE OPRCLS FIELD IS IN BITS 23-27, THE SRCID IS
BC	 		IN BITS 28-34
BC	 	******)%
BSTOPEROPCLSOPSRCIC	 	STOPERC(OPCLS,OPSRCID)=
BC	 		(OPCLS^8 OR OPSRCID^1)$,
BC	 
BC	 
BC	 !
BC	 !THE FOLLOWING STRUCTURES ARE AN INTEGRAL PART OF THE STAEMENT HEADER
BC	 !FOR EACH KIND OF EXECUTABLE STATEMENT, ONLY THE ABOVE FIELDS
BC	 !CONTAIN INFORMATION COMMON FOR EACH STAEMENT NODE
BC	 !
BC	 !
BC	 !GO TO STATEMENT FIELDS
BC	 !
BGOTOLBC	 	GOTOLBL	 = CW3R$,	!PTR TO LABEL TABLE
BAGOTOLC	 	AGOTOLBL = CW3R$,	!ASSIGNED GO TO LABEL PTR
BCGOTOLC	 	CGOTOLBL = CW3R$,	!COMPUTED GO TO PTR TO PSEUDO EXPRESSION NODE
BGOTOLIC	 	GOTOLIST = CW4R$,	!PTR TO LIST OF LABELS (OR 0) IF NO LIST
BGOTONUC	 	GOTONUM = CW4L$,	!NUMBER OF LABELL INLIST
BC	 !
BLISS  V. 1.0-2.12	13-JUN-73  13:51:03	OPMOD	FIRST.BLI		PAGE 3-2

BC	 !IF STATEMENT FIELDS
BC	 !
BLIFEXPC	 	LIFEXPR  = CW3R$,	!PTR TO EXPR NODE FOR LOGICAL IF
BLIFSTAC	 	LIFSTATE = CW4R$,	!PTR TO STATEMENT NODE IF TRUE CONDITON
BAIFEXPC	 	AIFEXPR = LIFEXPR$,	!SAME  AS FOR LOGICAL IF
BAIFLESC	 	AIFLESS  = CW4R$,	!LABEL PTR IF LESS
BAIFEQLC	 	AIFEQL  = CW4L$,	!LABEL TO GO TO IF EQUAL
BAIFGTRC	 	AIFGTR  = CW5R$,	!LABEL TO GO TO IF GTR
BAIFREGC	 	AIFREG = 0,5,23,4$,	!REG TO HOLD THE VAL TO BE TESTED
BC	 	!BITS WITHIN THE FLAGS FIELD USED BY ARITHMETIC IF ONLY
BC	 	! (THESE BITS ARE ALL USED ELSEWHERE AS FLAGS DESCRIBING ARG2 OF AN EXPRESSION) 
BAIFLBEC	 	AIFLBEQV=0,EXOPWD,21,2$,	!VAL OF THIS FIELD INDICATES WHCH (IF ANY)
BC	 					! OF THE 3 LABELS ARE EQUAL TO EACHOTHER
BC	 					!(THESE BITS ARE USED IN EXPRS AS A2NEGFLG AND A2NOTFLG)
BAIFLBNC	 	AIFLBNXT=0,EXOPWD,19,2$,	!VAL OF THIS FIELD INDICATES WHICH (IF ANY)
BC	 					! OF THE LABELS INDICATES THE FOLLOWING STATEMENT
BAIFFLGC	 	AIFFLGS=0,EXOPWD,19,4$,		!THE CONCATENATION OF THE AIFLBEQV AND AIFLBNXT FIELDS
BC	 					!(THESE BITS ARE A2SAMEFLG AND A2IMMEDFLG IN EXPRS)
BC	 !
BC	 !ASSIGN STATEMENT FIELDS
BC	 !
BASILBLC	 	ASILBL  = CW3R$,	!PTR TO LABEL IN ASSIGN
BASISYMC	 	ASISYM  = CW4L$,	!PTR TO SYMBOL TABLE
BASILINC	 	ASILINK = CW4R$,	!LINKS ASSIGN STATEMENTS
BC	 !
BC	 !DO STATEMENT FIELDS
BC	 !
BDOPREDC	 	DOPRED	= CW6L$,	!PTR TO DO STATEMENT PREDECESSOR
BDOLBLC	 	DOLBL  = CW3R$,	!PTR TO DO LABEL TERMINUS ENTRY
BDOSYMC	 	DOSYM	 = CW4R$,	!POINTER TO DO INDEX VARIABLE
BDOM1C	 	DOM1	 = CW4L$,	!POINTER TO INITIAL VALUE
BDOM2C	 	DOM2	 = CW5L$,	!POINTER TO UPPER LIMIT
BDOM3C	 	DOM3	 = CW5R$,	!POINTER TO STEP SIZE
BDOSSIZC	 	DOSSIZE = DOM3$,	!ANOTHER NAME FOR STEP SIZE
BDOLPCTC	 	DOLPCTL = CW7R$,	!POINTER TO CONTROL EXPRESSION
BDOCTLVC	 	DOCTLVAR = CW7L$,	!POINTER TO CONTROL VARIABLE
BDOCREGC	 	DOCREG=0,6,0,4$,	!DO LOOP CONTROL REG
BDOIREGC	 	DOIREG=0,6,4,4$,	!DO LOOP INDUCTION VARIABLE REGISTER; 0 IS NONE
BC	 !
BC	 !THE STRUCTURE OF DO LOOP TREE NODES
BC	 !
BPARLVLC	 	PARLVL = CW0L$,	!PTR TO PARALLEL LEVEL DO LOOP
BNEXTDOC	 	NEXTDO = CW0R$,	!PTR TO NEXT DEEPER NESTED DO
BPREVDOC	 	PREVDO = CW1L$,	!PTR TO ENCLOSING DO LOOP
BLEVLC	 	LEVL   = CW1R$,	!NEST LEVEL OF LOOP 
BDOSRCC	 	DOSRC	= ,	!PTR TO SOURCE TREE OF THE DO
BDONODEC	 	DONODESIZ = 3$,
BC	 	!
BC	 !I/O STATEMENT FIELDS
BC	 !
BIOLINKC	 	IOLINK	= CW1L$,	!LINK I/O STMTS FOR GENERATION OF ARG BLOCKS
BIOARGLC	 	IOARGLBL = CW4L$,	!POINTER TO LABEL FOR STMT ARG BLOCK
BIODODPC	 	IODODPTH = CW4R$,	!DO DEPTH ANALYSIS TREE
BIOUNITC	 	IOUNIT	=  CW5L$,	!POINTER TO UNIT OR CODE FOR UNIT
BIORECOC	 	IORECORD = CW5R$,	!POINTER TO RECONRD FOR RANDOM ACCESS
BIOCNTC	 	IOCNT	= CW5R$,	!FOR ENCODE AND ECODE
BIOLISTC	 	IOLIST	= CW6L$,	!POINTER TO I/O LIST
BLISS  V. 1.0-2.12	13-JUN-73  13:51:12	OPMOD	FIRST.BLI		PAGE 3-3

BIOFORMC	 	IOFORM	= CW6R$,	!POINTER TO FORMAT OR 0 IF UNFORMATTED
BIONAMEC	 	IONAME	= CW6R$,	!POINTER TO NAME LIST FOR NAMELIST 
BIOERRC	 	IOERR	= CW7L$,	!ERR LABEL POINTER
BIOENDC	 	IOEND	= CW7R$,	!END LABEL POINTER
BIOVARC	 	IOVAR	= CW5L$,	!FOR ENCODE/ DECODE
BIOREPTC	 	IOREPT	= CW5R$,	!FOR REPEAT FACTOR ON BACKSPACE ETC.
BC	 !
BC	 !FORMAT STATEMENT FIELDS
BC	 !
BFORSIZC	 	FORSIZ  = CW4L$,	!SIZE OF STRING IN WORDS
BFORLINC	 	FORLINK = CLINK$,
BFOROPEC	 	FOROPER = CW1R$,
BFORADDC	 	FORADDR = CW4R$,	!ADDR OF STRING (IN LOW SEG)
BFMTLINC	 	FMTLINK	= CW5L$,	!LINK TO NEXT FORMAT STATEMENT
BFORSTRC	 	FORSTRING = CW5R$,	!PTR TO CHARACTER STRING
BC	 !
BC	 !DATA STATEMENT NODE
BC	 !
BDATALNC	 	DATALNK = CLINK$,	!LINKS NODES TOGETHER
BDATISNC	 	DATISN = CW0L$,
BDATCOUC	 	DATCOUNT = CW1$,		!NUMBER OF WORDS SPECIFIED FOR INITIALIZATION
BDATITEC	 	DATITEMS = CW2L$,	!PTR LINKED LIST OF DATAITEM NODES
BDATCONC	 	DATCONS = CW2R$,	!PTR TO LINKED LIST OF CONSTANT NODE PTRS
BC	 
BC	 	%(***DEFINE THE FIELDS IN THE LINKED LIST OF CONSTANTS UNDER A DATA STMNT***)%
BDCONSTC	 	DCONST=CW1R$,		!PTR TO CONSTANT TABLE ENTRY
BDATARPC	 	DATARPT=CW1L$,		!CT OF NUMBER OF TIMES THIS CONSTANT IS TO BE STORED
BC	 !
BC	 !
BC	 !NAMELIST NODE
BC	 !
BNAMLINC	 	NAMLINK	=CLINK$,	!LINK TO NEXT NODE
BNAMLIDC	 	NAMLID	=CW2L$,		!PTR TO NAMELIST NAME
BNAMADDC	 	NAMADDR	=CW2R$,		!ALLOCATED ADDRESS OF NAMELIST ARGLIST
BNAMCNTC	 	NAMCNT	=CW1L$,		!NUMBER OF ITEMS IN NAMLIST
BNAMLISC	 	NAMLIST =CW1R$,		!PTR TO LIST OF NAMELIST NAMES
BC	 !
BC	 !OPEN STATEMENT
BC	 !
BOPSIZC	 	OPSIZ=	IOCNT$,		!NUMBER OF OPEN PARAMETERS
BOPLSTC	 	OPLST=	IOLIST$,		!LOCATION OF PARAMETER LIST
BC	 !
BC	 !ASSIGNMENT STATEMENT
BC	 !
BLHEXPC	 	LHEXP	 = CW4R$,	!PTR TO LEFT SIDE EXPRESSION
BRHEXPC	 	RHEXP	 = CW3R$,	!PTR TO RIGHT SIDE EXPR
BASMNTRC	 	ASMNTREG = 0,4,23,4$,
BC	 !
BC	 !STATEMENT FUNCTION FIELDS
BC	 !
BSFNNAMC	 	SFNNAME	= CW3R$,
BSFNLISC	 	SFNLIST = CW4R$,
BSFNEXPC	 	SFNEXPR	= CW4L$,
BC	 !
BC	 !CALL STATEMENT FIELDS
BC	 !
BCALSYMC	 	CALSYM   = CW3R$,	!PTR TO SUBROUTINE NAME SYMBOL
BLISS  V. 1.0-2.12	13-JUN-73  13:51:13	OPMOD	FIRST.BLI		PAGE 3-4

BCALLISC	 	CALLIST	 = CW4R$,	!PTR TO LIST OF ARGS  OR 0
BCALNUMC	 	CALNUM	 = CW4L$,	!NUMBER OF ARGS IN CALL
BC	 !
BC	 !RETURN STATEMENT
BC	 !
BRETEXPC	 	RETEXPR	= CW3R$,		!PARAMETER NUMBER TO RETURN THRU
BC	 !
BC	 !STOP STATEMENT
BC	 !
BSTOPIDC	 	STOPIDENT = CW3R$,	!STOP LOCATION IDENTIFIER
BSTOPLBC	 	STOPLBL=CW4L$,		!LABEL ASSOCIATED WITH THE ARGLIST TO
BC	 				! FOROTS USED FOR THIS STMNT
BC	 !
BC	 !PAUSE STATEMENT
BC	 !
BPAUSIDC	 	PAUSIDENT = CW3R$,	!PAUSE LOCATION IDENTIFIER
BPAUSLBC	 	PAUSLBL=CW4L$,		!LABEL ASSOCIATED WITH THE ARGLIST FOR FOROTS USED
BC	 				! FOR THIS STMNT
BC	 !
BC	 !ENTRY STATEMENT FIELDS (ALSO GOOD FOR SUBROUTINE AND FUNCTION)
BC	 !
BENTSYMC	 	ENTSYM	 = CW3R$,	!PTR TO ENTRY NAME
BENTLISC	 	ENTLIST	 = CW4R$,	!PTR TO LIST OF ARGS OR 0
BENTNUMC	 	ENTNUM	 = CW4L$;	!NUM OF ARGS INLIST
BC	 !
BC	 !THE STRUCTURE ACCESS FOR STATEMENT NUMBER TABLE ENTRY
BC	 !
BMACROC	 MACRO	
BSNLINKC	 	SNLINK	 = CLINK$,	!LINK TO NEXT TABLE ENTRY
BSNNXTLC	 	SNNXTLAB = CW0L$,	!PTR TO INTERNAL LABEL WITH SAME ADDR FIELD
BSNOPERC	 	SNOPER	= CW1R$,	!OPER FIELD FOR STATEMENT NUMBER
BSNMADEC	 	SNMADELABL = CW1L$,	!FLAG FOR MADE LABEL
BSNFLAGC	 	SNFLAGS = CW1L$,	!NON-ZERO INDICATES A MADE LABEL
BSNEXTNC	 	SNEXTND = CW2L$,	!FOR EXTENDED DO CONSTRUCTION
BSNREFC	 	SNREF	= CW2$,		!WHOLE WORD USED FOR ADDING 0NE IN TESTENTRY
BSNREFNC	 	SNREFNO = CW2R$,	!NUMBER OF TIMES LABEL REFERENCED
BSNDEFIC	 	SNDEFINED = CW2L$,	!-1 IF DEFINED
BSNADDRC	 	SNADDR = CW2R$,		!THE ABSOLUTE ADDRESS OF THIS LABEL
BSNHDRC	 	SNHDR	 = CW3L$,	!PTR TO SOURCE STATEMENT TREE OF DEFINING STATEMENT
BSNUMBEC	 	SNUMBER	 = CW3R$,	!ACTUAL STATEMENT LABEL
BSNDOLVC	 	SNDOLVL	= CW4R$,	!COUNT OF NESTED DO'S REFERENCING THIS LABEL
BSNDOLNC	 	SNDOLNK	= CW4L$,	!PTR TO LIST OF 1 WORD POINTERS TO DO LOOPS
BSNCADDC	 	SNCADDRWD = CW5$,	!WD OF ENTRY USED BY PEEPHOLER
BSN1STLC	 	SN1STLAB = CW5R$,	!PTR TO 1ST LABEL THAT HAS SAME ADDR
BSNSTATC	 	SNSTATUS = CW5L$;	!STATUS OF THIS LABEL:
BC	 				! 0 - UNRESOLVED
BC	 				! 1 - IN PEEPHOLE BUFFER
BC	 				! 2 - OUT OF PEEPHOLE BUFFER
BC	 				!REFERENCING THIS LABEL
BC	 !
BC	 !
BC	 !
BMACRODOUBLEC	 MACRO	DOUBLE = .SYMTYPE GTR REAL$;	%FOR TESTING DOUBLE OR COMPLEX MODE%
BC	 !
BC	 !	THE FOLLOWING DEFINES THE TABLE NUMBERS AND ENTRY SIZES
BC	 !	FOR THE VARIOUS TABLES BUILT BY THE COMPILER
BC	 !	LEFT HALF IS ENTRY SIZE AND RIGHT HALF IS TABLE NUMBER THAT
BLISS  V. 1.0-2.12	13-JUN-73  13:51:14	OPMOD	FIRST.BLI		PAGE 3-5

BC	 !	IS USED TO IDENTIFY A SPECIFIC TABLE TO THE TABLE SEARCH ROUTINE
BC	 !
BBINDIDSIZC	 	BIND	IDSIZ	= 6,	%SYMBOL TABLE ENTRY LENGTH%
BPOOLSIC	 		POOLSIZ=#2000,	%SIZE OF BUFFER FOR CARD INPUT%
BC	 				%SAME DECLARATION AS IN GLOBAL.BLI%
BEXSIZC	 		EXSIZ	= 4,	%EXPRESSION TABLE ENTRY%
BSNSIZC	 		SNSIZ	= 6,	%STATEMENT NUMBER TABLE ENTRY%
BCONSIZC	 		CONSIZ	= 5,	!CONSTANT SIZ
BLTLSIZC	 		LTLSIZ	= 3,	!LITERAL SIZ
BCOMSIZC	 		COMSIZ	= 4,	!COMMON BLOCK NAME TABLE SIZ
BEQVSIZC	 		EQVSIZ	= 4,	!EQUIV GROUP SIZ
BEQLSIZC	 		EQLSIZ	= 3,	!EQUIV LIST SIZ
BDATSIZC	 		DATSIZ  = 3,	!DATANODE SIZE
BNAMSIZC	 		NAMSIZ	= 3,	!NAMELIST NODE SIZE
BSRCSIZC	 		SRCSIZ	= 4,	!SOURCE TREE HDR SIZ
BGOSIZC	 		GOSIZ	= 1,	!GO TO PART SIZ
BIFSIZC	 		IFSIZ	= 3,	!IF PART
BASISIZC	 		ASISIZ	= 1,	!ASSIGN PART
BDOSIZC	 		DOSIZ	= 4,	!DO PART
BFORMSIC	 		FORMSIZ = 2,	!FORMAT STATEMENT PART
BIOSIZC	 		IOSIZ	= 4,	!IO LIST PART
BASGNSIC	 		ASGNSIZ	= 1,	!ASSIGNMENT PART
BSFSIZC	 		SFSIZ	= 1,	!STATEMENT FUNCTION SIZ
BCALLSIC	 		CALLSIZ	= 1,	!CALL PART
BENTSIZC	 		ENTSIZ	= 1,	!ENTRY PART
BDIMSIZC	 		DIMSIZ	= 4,	!DIMENSION TABLE SIZ
BASSISIC	 		ASSISIZ = 1,
BBACKSIC	 		BACKSIZ = 4,
BCONTSIC	 		CONTSIZ = 0,
BDECOSIC	 		DECOSIZ	= 4,
BOPENSIC	 		OPENSIZ = 4,
BCLOSSIC	 		CLOSSIZ = 4,
BENCOSIC	 		ENCOSIZ = 4,
BENDFSIC	 		ENDFSIZ = 4,
BFINDSIC	 		FINDSIZ = 3,
BREADSIC	 		READSIZ = 4,
BWRITSIC	 		WRITSIZ = 4,
BGOTOSIC	 		GOTOSIZ = 1,
BAGOSIZC	 		AGOSIZ	= 1,
BCGOSIZC	 		CGOSIZ	= 1,
BIFASIZC	 		IFASIZ	= 2,
BIFLSIZC	 		IFLSIZ	= 2,
BINPUSIC	 		INPUSIZ = 4,
BOUTPSIC	 		OUTPSIZ = 4,
BRETUSIC	 		RETUSIZ = 1,
BSTOPSIC	 		STOPSIZ = 2,
BPAUSSIC	 		PAUSSIZ = 2;
BC	 !
BBINDIDTABIDSIZC	 	BIND	IDTAB	= IDSIZ^18 + 0,
BCONTABCONSIZC	 		CONTAB	= CONSIZ^18 + 1,
BCXPTABEXSIZC	 		CXPTAB	= EXSIZ^18 + 2,
BLABTABSNSIZC	 		LABTAB  = SNSIZ^18 +3,
BCOMTABCOMSIZC	 		COMTAB  = COMSIZ^18 + 4,
BSORTABSRCSIZC	 		SORTAB  = SRCSIZ^18 + 5,
BDIMTABDIMSIZC	 		DIMTAB  = DIMSIZ^18 +6,
BEXPTABEXSIZC	 		EXPTAB  = EXSIZ^18 + 7,
BIOLTABC	 		IOLTAB  = 2^18 + 8,
BLISS  V. 1.0-2.12	13-JUN-73  13:51:22	OPMOD	FIRST.BLI		PAGE 3-6

BLITTABC	 		LITTAB  =  9,	!# OF WDS PER ENTRY VARIES DEPENDING ON THE SIZE OF STRING
BC	 !
BC	 !THE FOLLOWING TABLES ARE STATIC AND ALLOCATED TO THE HISEG
BC	 !
BLFUTABC	 		LFUTAB	= 10,	%LIBRARY FUNCTION ID TABLE%
BEQVTABEQVSIZC	 		EQVTAB  = EQVSIZ^18 + 11,	%EQUIVALENCE GROUP TABLE%
BEQLTABEQLSIZC	 		EQLTAB  = EQLSIZ^18 +12,	%EQUIVALENCE LIST TABLE%
BDATATADATSIZC	 		DATATAB = DATSIZ^18 +13,	%DATA GROUP NODE%
BNAMTABNAMSIZC	 		NAMTAB	= NAMSIZ^18+14;	%NAMELIST GROUP TABLE%
BC	 !
BC	 !
BC	 !DEFINE THE ID OF DIFFERENT FORTRAN STATEMENTS
BC	 !
BC	 	!START OF FIRST GROUP (REGULAR)
BBINDASGNIDC	 BIND	ASGNID	= 000,	!ASSIGNMENT
BASSIIDC	 	ASSIID	= 001,	!
BCALLIDC	 	CALLID	= 002,	!
BCONTIDC	 	CONTID	= 003,	!
BDOIDC	 	DOID	= 004,	!
BENTRIDC	 	ENTRID	= 005,	!
BCOMNSUC	 	COMNSUB	= 006,	!
BC	 	!END OF FIRST GROUP
BC	 	!START OF REGULAR BRANCHING
BGOTOIDC	 	GOTOID	= 007,	!
BAGOIDC	 	AGOID	= 008,	!
BCGOIDC	 	CGOID	= 009,	!
BIFAIDC	 	IFAID	= 010,	!
BIFLIDC	 	IFLID	= 011,	!
BRETUIDC	 	RETUID	= 012,	!
BSTOPIDC	 	STOPID	= 013,	!
BC	 	!END OF SECOND GROUP
BC	 	!START OF I/O BRANCHING
BREADIDC	 	READID	= 014,	!
BWRITIDC	 	WRITID	= 015,	!
BDECOIDC	 	DECOID	= 016,	!
BENCOIDC	 	ENCOID	= 017,	!
BREREDIC	 	REREDID	= 018,	!
BFINDIDC	 	FINDID	= 019,	!
BCLOSIDC	 	CLOSID	= 020,
BINPUIDC	 	INPUID	= 021,	!
BOUTPIDC	 	OUTPID	= 022,	!
BC	 	!END OF THIRD GROUP
BC	 	!START OF I/O NON-BRANCHING
BBACKIDC	 	BACKID	= 023,
BBKFILIC	 	BKFILID	= 024,
BREWDIDC	 	REWDID	= 025,
BSKFILIC	 	SKFILID	= 026,
BSKRECIC	 	SKRECID	= 027,
BUNLODIC	 	UNLODID	= 028,
BRELSIDC	 	RELSID	= 029,
BENDFIDC	 	ENDFID	= 030,
BC	 	!END OF FOURTH GROUP
BC	 	!START OF MISC.
BENDIDC	 	ENDID	= 031,
BPAUSIDC	 	PAUSID	= 032,
BOPENIDC	 	OPENID	= 033,
BSFNIDC	 	SFNID	= 034,
BLISS  V. 1.0-2.12	13-JUN-73  13:51:24	OPMOD	FIRST.BLI		PAGE 3-7

BFORMIDC	 	FORMID	= 035,	!
BBLTIDC	 	BLTID	= 036,	!
BOVRLYIC	 	OVRLYID	= 037;	!
BC	 !
BC	 !DEFINE DATA FOR BUILDING SOURCE TREE ENTRIES FOR STATEMENTS
BC	 !	LEFT HALF IS NUMBER OF WORDS FOR EACH TYPE OF STATEMENT
BC	 !	RIGHT HALF IS ID OF STATEMENT
BC	 !
BBINDASGNDAASGNSISRCSIZASGNIDC	 BIND	ASGNDATA	= (ASGNSIZ+SRCSIZ)^18 + ASGNID,
BSFNDATSFSIZSRCSIZSFNIDC	 	SFNDATA		= (SFSIZ+SRCSIZ)^18 + SFNID,
BASSIDAASSISISRCSIZASSIIDC	 	ASSIDATA	= (ASSISIZ+SRCSIZ)^18 + ASSIID,
BBACKDABACKSISRCSIZBACKIDC	 	BACKDATA	= (BACKSIZ+SRCSIZ)^18 + BACKID,
BBKFILDIOSIZSRCSIZBKFILIC	 	BKFILDATA	= (IOSIZ+SRCSIZ)^18 + BKFILID,
BSKIPDAIOSIZSRCSIZSKRECIC	 	SKIPDATA	= ( IOSIZ+SRCSIZ)^18 + SKRECID,
BSKIPFDIOSIZSRCSIZSKFILIC	 	SKIPFDATA	= (IOSIZ+SRCSIZ)^18 + SKFILID,
BREWIDAIOSIZSRCSIZREWDIDC	 	REWIDATA	= (IOSIZ + SRCSIZ)^18 + REWDID,
BUNLODAIOSIZSRCSIZUNLODIC	 	UNLODATA	= (IOSIZ +SRCSIZ)^18 + UNLODID,
BREREDAIOSIZSRCSIZREREDIC	 	REREDATA	= (IOSIZ + SRCSIZ)^18 + REREDID,
BCALLDACALLSISRCSIZCALLIDC	 	CALLDATA	= (CALLSIZ+SRCSIZ)^18 + CALLID,
BCONTDACONTSISRCSIZCONTIDC	 	CONTDATA	= (CONTSIZ+SRCSIZ)^18 + CONTID,
BDECODADECOSISRCSIZDECOIDC	 	DECODATA	= (DECOSIZ+SRCSIZ)^18 + DECOID,
BOPENDAOPENSISRCSIZOPENIDC	 	OPENDATA	= (OPENSIZ+SRCSIZ)^18 + OPENID,
BCLOSDACLOSSISRCSIZCLOSIDC	 	CLOSDATA	= (CLOSSIZ+SRCSIZ)^18 + CLOSID,
BDODATADOSIZSRCSIZDOIDC	 	DODATA		= (DOSIZ+SRCSIZ)^18 + DOID,
BENCODAENCOSISRCSIZENCOIDC	 	ENCODATA	= (ENCOSIZ+SRCSIZ)^18 + ENCOID,
BENDFDAENDFSISRCSIZENDFIDC	 	ENDFDATA	= (ENDFSIZ+SRCSIZ)^18 + ENDFID,
BENTRDAENTSIZSRCSIZENTRIDC	 	ENTRDATA	= (ENTSIZ+SRCSIZ)^18 + ENTRID,
BFINDDAFINDSISRCSIZFINDIDC	 	FINDDATA	= (FINDSIZ+SRCSIZ)^18 + FINDID,
BREADDAREADSISRCSIZREADIDC	 	READDATA	= (READSIZ+SRCSIZ)^18 + READID,
BWRITDAWRITSISRCSIZWRITIDC	 	WRITDATA	= (WRITSIZ+SRCSIZ)^18 + WRITID,
BGOTODAGOTOSISRCSIZGOTOIDC	 	GOTODATA	= (GOTOSIZ+SRCSIZ)^18 + GOTOID,
BAGODATAGOSIZSRCSIZAGOIDC	 	AGODATA		= (AGOSIZ+SRCSIZ)^18 + AGOID,
BCGODATCGOSIZSRCSIZCGOIDC	 	CGODATA		= (CGOSIZ+SRCSIZ)^18 + CGOID,
BIFADATIFASIZSRCSIZIFAIDC	 	IFADATA		= (IFASIZ+SRCSIZ)^18 + IFAID,
BIFLDATIFLSIZSRCSIZIFLIDC	 	IFLDATA		= (IFLSIZ+SRCSIZ)^18 + IFLID,
BINPUDAINPUSISRCSIZINPUIDC	 	INPUDATA	= (INPUSIZ+SRCSIZ)^18 + INPUID,
BOUTPDAOUTPSISRCSIZOUTPIDC	 	OUTPDATA	= (OUTPSIZ+SRCSIZ)^18 + OUTPID,
BENDDATSRCSIZENDIDC	 	ENDDATA		= SRCSIZ^18+ENDID,
BRETUDARETUSISRCSIZRETUIDC	 	RETUDATA	= (RETUSIZ+SRCSIZ)^18 + RETUID,
BSTOPDASTOPSISRCSIZSTOPIDC	 	STOPDATA	= (STOPSIZ+SRCSIZ)^18 + STOPID,
BFORMDAFORMSISRCSIZFORMIDC	 	FORMDATA	= (FORMSIZ+SRCSIZ)^18 + FORMID,
BPAUSDAPAUSSISRCSIZPAUSIDC	 	PAUSDATA	= (PAUSSIZ+SRCSIZ)^18 + PAUSID;
BC	 
BC	 
BC	 !
BC	 !	BIND	ENTRSIZ = PLIT(IDTAB,CONTAB,EXPTAB,LABTAB,COMTAB,
BC	 !				SORTAB,DIMTAB,IOLTAB,LITTAB);
BC	 !
BC	 !	THE FOLLOWING MACROS MAY BE NEEDED FOR INDEFINITE SIZE ENTRIES
BC	 !	AND FOR INDEFINITE LEVEL OF INDIRECT REFERENCE
BC	 !
BMACROCWDLNC	 	MACRO	CWD(L,N) = L,N,FULL$;
BC	 !
BC	 !	L - MEANS LEVEL OF INDIRECTION
BC	 !	N - MEANS THE N-TH WORD IN THE ENTRY
BC	 !
BC	 !
BLISS  V. 1.0-2.12	13-JUN-73  13:51:27	OPMOD	FIRST.BLI		PAGE 3-8

BC	 !!	THE FOLLOWING STRUCTURE DECLARATION DEFINES THE HASH TABLES
BC	 !	FOR THE SYMBOL TABLE THE CONSTANT TABLE,EXPRESSION TABLE AND
BC	 !
BC	 !
BSTRUCTHTABLEHTABLEIIHTABLEIRIGHTC	 	STRUCTURE HTABLE[I] = (.HTABLE +.I)<RIGHT>;
BC	 
BC	 !	DEFINE THE TABLE SIZES
BBINDSSIZC	 	BIND	SSIZ =	79,	%SYMBOL HASH TABLE%
BCSIZC	 		CSIZ =	37,	%CONSTANTS HASH TBLE%
BESIZC	 		ESIZ =	79,	%EXPRESSION HASH%
BLASIZC	 		LASIZ = 37,	%STATMENT NUMBER HASH SIZE%
BNSIZC	 		NSIZ = 17,	%NAMELIST HASH SIZE%
BSOSIZC	 		SOSIZ = 1,	%NO HASH TABLE FOR ENCODED SOURCE%
BDISIZC	 		DISIZ = 1,	%NO HASH TABLE FOR DIMENSIONS%
BDASIZC	 		DASIZ = 1,	%NO HASH TABLE FOR DATA STATEMENT%
BLISIZC	 		LISIZ = 1;	%LITERAL TABLE IS NOT HASHED%
BC	 !
BEXTERNSYMTBLSSIZCONTBLCSIZEXPTBLLABTBLLASIZC	 	EXTERNAL SYMTBL[SSIZ],CONTBL[CSIZ],EXPTBL[1],LABTBL[LASIZ],
BLITTBLLISIZNAMTBLNSIZSRCTBLSOSIZC	 		LITTBL[LISIZ],NAMTBL[NSIZ],SRCTBL[SOSIZ],
BDIMTBLDISIZDATTBLDASIZC	 		DIMTBL[DISIZ],DATTBL[DASIZ];
BC	 !
BC	 !	BIND LISTX = PLIT(SYMTBL,CONTBL,EXPTBL,LABTBL,SRCTBL,
BC	 !			DIMTBL,DATTBL,NAMTBL,LITTBL);
BMAPHTABLESYMTBLSYMTBLCONTBLLABTBLNAMTBLC	 	MAP	HTABLE SYMTBL: CONTBL: LABTBL:  NAMTBL;
BC	 !
BC	 !
BC	 !	THE NEXT STRUCTURE DEFINES THE ACCESSING ALGORITHM FOR THE
BC	 !	LINKED LIST STRUCTURES THAT ARE THE ACTUAL TABLES CONTAINING
BC	 !	SYMBOL ENTRIES,CONSTANT ENTRIES,EXPRESSION ENTRIES ETC.
BC	 !
BSTRUCTBASEBASEIIJKLC	 	STRUCTURE BASE[I,J,K,L] =
BCASEIOFSETC	 			CASE .I OF SET
BBASEJKLC	 	%0%	 (@.BASE +.J)<.K,.L>;	%LEVEL 1 ENTRY POINTED TO BY BASE%
BBASEJKLC	 	%1%	(@@.BASE +.J)<.K,.L>	%LEVEL 2 ENTRY%
BTESC	 			TES;
BC	 !
BC	 !!	THE PARAMETERS ARE DEFINED AS FOLLOWS
BC	 !	I - THE LEVEL OF INDIRCTION
BC	 !		0 - MEANS CONTENTS OF BASE
BC	 !		1 - MEANS CONTENTS OF ENTRY POINTED TO BY BASE
BC	 !		2 - CONTENTS OF ENTRY POINTED TO BY RIGHT HALF OF
BC	 !			ADDRESS POINTED TO BY BASE
BC	 !
BC	 !	J - THE J-TH WORD IN THE TABLE ENTRY POINTED TO
BC	 !		CURRENT RANGE IS 0 TO 4
BC	 !		J=0 MEANS POINT TO CHAIN FIELD (RIGHT HALF OF FIRST WORD)
BC	 !
BC	 !	MAP THE POINTERS TO THE BASE
BC	 !
BEXTERNBASEBASEPTBASEPTC	 	EXTERNAL BASE BASEPTR;
BC	 !
BC	 !******
BC	 
BC	 !
BC	 !
BC	 !******
BC	 
BLISS  V. 1.0-2.12	13-JUN-73  13:51:29	OPMOD	FIRST.BLI		PAGE 3-9

BC	 !
BC	 !
BC	 !THE FOLLOWING GLOBALS ARE USED FOR SEMANTICS CHECKING
BC	 !THEY CONTAIN POINTERS TO TABLE ENTRIES FOR THE LAST COMMON BLOCK
BC	 !NAME, THE LAST LITERAL, THE LAST SYMBOL ENTERED ETC.
BC	 !
BEXTERNDTRACEJOBFFJOBRELXAREAXCALLXSTAKXALTXTYPTABC	 	EXTERNAL DTRACE,JOBFF,JOBREL,XAREA,XCALL,XSTAK,XALTX,TYPTAB;
BC	 !
BEXTERNC	 	EXTERNAL
BCOMBLKC	 		COMBLKPTR,	!POINTERS FOR LAST AND FIRST COMMMON BLOCKS
BLITPOIC	 		LITPOINTER,	!LAST AND FIRST LITERALS
BSYMPTRC	 		SYMPTR,	!LAST AND FIRST SYMBOLS
BSORCPTC	 		SORCPTR,	!LAST AND FIRST SOURCE ENTRIES
BLASTEXC	 		LASTEXP,	!LAST EXPRESSION ENTRY
BLASTDIC	 		LASTDIM,	!LAST DIMENSION ENTRY
BCONSPTC	 		CONSPTR,	!LAST AND FIRST CONSTANTS
BLABLPTC	 		LABLPTR,	!FIRSTAND LAST STATEMENT LABELS
BSPACEFC	 		SPACEFREE;	!AMOUNT OF FREE LOWSEG SPACE
BEXTERNC	 	EXTERNAL
BSRCHONC	 		SRCHONLY,	!FLAG FOR TBLSEARCH FOR SEARCH ONLY MODE
BISNC	 		ISN,		!INTERNAL SOURCE SEQUENCE NUMBER
BIDOFSTC	 		IDOFSTATEMENT,	!IDENTIFICATION OF EXECUTABLE STEMENT IN TREE
BLABLOFC	 		LABLOFSTATEMENT;!SOURCE STATEMENT NUMBER POINTER
BC	 				!IF CURRENT STATEMENT HAS ONE - OR 0
BEXTERNC	 	EXTERNAL
BDLOOPTC	 		DLOOPTREE,	!PTR TO DO LOOP NEST TREE
BLASLVLC	 		LASLVL0,	!PTR TO LAST LEVEL 0 NEST SEEN
BDELETPC	 		DELETPTR;	!PTR TO DELETED TABLE ENTRY FOR DELETE ROUTINE
BEXTERNC	 	EXTERNAL
BSYMTYPC	 		SYMTYPE,	!TYPE OF CRRENT SYMBOL
BPOINTEC	 		POINTER	,	!USEFUL POINTER
BLIBFUNC	 		LIBFUNTAB,	!DEFINES THE FUNCTION NAMES IN LIBRARY
BLIBATTC	 		LIBATTRIBUTES,	!DEFINES THE LIBRARY ATTRIBURES
BONEAFTC	 		ONEAFTERLIB,	!END OF THE LIB TABLE ADDRESS
BNAMEC	 		NAME,		!NAME OF THE TABLE FOR TBLSEARCH
BC	 				!AND SIZ OF ENTRY IN LEFT HALF
BEQVPTRC	 		EQVPTR,		!PTR TO FIRST AND LAST EQIV GROUPS
BFORMPTC	 		FORMPTR,	!PTR TO FIRST AND LAST FORMAT TABLE ENTRIES
BDATASPC	 		DATASPTR,	!PTR TO LINKED LIST OF DATA STATEMENT NODES
BIOLSPTC	 		IOLSPTR,	!PTR TO LINKED IO STATEMENTS
BENTRYC	 		ENTRY;		!THE GLOBAL PARAMETER VECTOR FOR TBLSEARCH
BC	 
BC	 !*****
BMACROFIRSTSC	 	MACRO	FIRSTSRC = SORCPTR<LEFT>$,
BLASTSRC	 		LASTSRC = SORCPTR<RIGHT>$,
BIOFIRSC	 		IOFIRST = IOLSPTR<LEFT>$,	!POINTS TO FIRST IO STATEMENT
BIOLASTC	 		IOLAST = IOLSPTR<RIGHT>$,	!POINTS TO LAST IO STATEMENT SEEN SO FAR
BDATFIRC	 		DATFIRST	= DATASPTR<LEFT>$,
BDATLASC	 		DATLAST	= DATASPTR<RIGHT>,
BC	 		FIREQVGROUP = EQVPTR<LEFT>$,
BLASEQVC	 		LASEQVGROUP = EQVPTR<RIGHT>$,
BLASCOMC	 		LASCOMBLK = COMBLKPTR<RIGHT>$,
BFIRCOMC	 		FIRCOMBLK = COMBLKPTR<LEFT>$,
BDELETFC	 		DELETFIELD = CW0L$,	!IF LEFT HALF OF FIRST WORD OF ENTRY IS -1 THEN ENTRY IS DELETED
BFOUNDC	 		FOUND = -1$,
BNOTFOUC	 		NOTFOUND = 0$,
BFLAGC	 		FLAG = FLGREG<FOUNDFLG>$,	!FLAG FOR TBLSEARCH FOUND(-1) OR NOTFOUND(0)
BLISS  V. 1.0-2.12	13-JUN-73  13:51:32	OPMOD	FIRST.BLI		PAGE 3-10

BSIZOFEC	 		SIZOFENTRY = NAME<LEFT>$,
BBASEPOC	 		BASEPOINT = BASEPTR$;
BC	 !
BBINDBPRBASEPTC	 	BIND	BPR = BASEPTR,	!FOR THE ENCLOSING ROUTINES
BXCONSTC	 		XCONSTANT = 12,
BXSYMBOC	 		XSYMBOL = 8,
BXLABLLC	 		XLABLL = 4,
BEXPRESC	 		EXPRES = 0;
BC	 !
BGLOBALBINDTABLVBLISS  V. 1.0-2.12	13-JUN-73  13:51:32	OPMOD	TABLES.BLI		PAGE 4-1

C	 GLOBAL BIND TABLV=105;		!VERSION DATE 20-APRIL-73
BC	 !EDITED 2-OCT-72 -FI
BC	 !EDITED AUG 30,1972 - SRM
BC	 !EDITED AUG 25,1972 - SRM
BC	 !EDITED AUG 24,1972 (22:45) - SRM
BC	 !EDITED AUG 24,1972 - SRM
BC	 !EDITED AUG 18, 1972 (21:15) - SRM
BC	 !EDITED AUG 14,1972 - SRM
BC	 !EDITED AUG 10, 1972 - SRM
BC	 !EDITED AUG 9,1972 - SRM
BC	 
BC	 
BC	 !COPYRIGHT 1972,1973, DIGITAL EQUIPMENT CORPORATION, MAYNARD MA**
BC	 !AUTHOR: S. MURPHY
BC	 !
BC	 
BBINDDEBUGFC	 BIND DEBUGFLG=1;			!COMPILE SWITCH TO LEAVE CONSISTENCY CHECKS IN
BLISS  V. 1.0-2.12	13-JUN-73  13:51:33	OPMOD	TABLES.BLI		PAGE 5-1

BC	 
BC	 %(****************************************
BC	 	TO OPTIMALLY TEST WHOLE-WD FLAGS FOR TRUE AND FALSE
BC	 ****************************************)%
BBINDTRUEC	 BIND	TRUE= -1,
BFALSEC	 	FALSE= 0;
BMACROTRUTHXC	 MACRO	TRUTH(X)= X NEQ 0$,
BFALSITXC	 	FALSITY(X)= X EQL 0$;
BC	 
BBINDAOBINCC	 BIND	AOBINCR=#1000001;			!INCREMENT FOR AOBJN
BC	 
BC	 
BC	 %(****************************************
BC	 	DEFINE BYTES FOR WHOLE, LEFT HALF, AND RIGHT HALF
BC	 ****************************************)%
BMACROWHOLEC	 MACRO 	WHOLE=0,36$ ;
BC	 
BLISS  V. 1.0-2.12	13-JUN-73  13:51:33	OPMOD	TABLES.BLI		PAGE 6-1

BC	 		
BC	 %(**********************************************************************
BC	 	STRUCTURE FOR AN EXPRESSION NODE
BC	 ************************************************************************)%
BC	 
BC	 
BC	 
BC	 %(************************************************************
BC	 	DEFINE THE FIELDS AND SUBFIELDS IN AN EXPRESSION NODE
BC	 ************************************************************)%
BC	 
BBINDEXOPWDC	 BIND EXOPWD=1;			!WORD IN WHICH THE OPERATOR FIELD
BC	 					! AND FLAGS FIELD
BC	 					! ARE CONTAINED (USE A MACRO ONLY BECAUSE
BC	 					! WHEN THIS NUMBER CHANGES A LARGE
BC	 					! NUMBER OF SUBFIELD DEFINITIONS
BC	 					! MUST BE CHANGED)
BC	 %(*****DEFINE MAIN FIELDS****************************)%
BMACROC	 MACRO
BFIRSTWC	 	FIRSTWORD=0,0,FULL$,
BPARENTC	 	PARENT=0,0,RIGHT$,		!PTR TO PARENT-NODE
BOPERATC	 	OPERATOR=0,EXOPWD,RIGHT$,		!OPERATOR FIELD
BEXPFLAC	 	EXPFLAGS=0,EXOPWD,LEFT$,	
BOPERWOC	 	OPERWORD=0,EXOPWD,WHOLE$,
BTARGETC	 	TARGET=0,2,WHOLE$,
BARGWDC	 	ARGWD=0,3,WHOLE$,			!WD HOLDING PTRS TO THE 2 ARGS
BARGWDOC	 	ARGWDOFFSET=3$,
BARG1PTC	 	ARG1PTR=0,3,LEFT$,
BARG2PTC	 	ARG2PTR=0,3,RIGHT$;
BMACROC	 MACRO
BCOMPLEC	 	COMPLEXITY=0,0,LEFT$;		!THIS FIELD IS USED ONLY DURING REGISTER ALLOCATION
BC	 
BC	 %(**********SUBFIELDS IN OPERATOR FIELD*************************)%
BMACROC	 MACRO
BVALTYPC	 	VALTYPE=0,EXOPWD,13,5$,		!TYPE FOR VALUE
BOPRCLSC	 	OPRCLS=0,EXOPWD,8,5$,		!CLASS OF OPERATOR
BOPERSPC	 	OPERSP=0,EXOPWD,5,3$,		!SPECIFIC OPERATOR WITHIN CLASS
BC	 
BC	 
BC	 	%(***NOTE THAT OF THE 3 FREE BITS AT THE RIGHT END OF THE OPERATOR FIELD,
BC	 		BIT 35 IS USED AS A SPECIAL FLAG BIT IN
BC	 		1. TYPE-CONVERSION NODES: FLAG FOR NO CONVERSION
BC	 	*******)%
BC	 
BC	 	%(***SUBFIELDS OF OPERSP FIELD*****)%
BOPRSP1C	 	OPRSP1=0,EXOPWD,6,2$,		!1ST 2 BITS OF OPERSP (THIS FIELD IS 00 FOR
BC	 					! ADD AND SUB, 01 FOR MUL AND DIV
BOPRSP2C	 	OPRSP2=0,EXOPWD,5,2$,		!LAST 2 BITS OF OPERSP FIELD -
BC	 					! USED TO DIFFERENTIATE ADD,SUB,MUL,DIV
BC	 					! ALSO USED IN TYPE CONVERSION NODES TO DIFFERENTIATE
BC	 					! FROMINT, FROMREL, FROMDBLPRC,
BC	 					! FROMCMPLX
BOPRSBIC	 	OPRSBIT0=0,EXOPWD,7,1$,		!1ST BIT OF OPERSP FIELD - FOR AN ARITH
BC	 					! NODE, THIS BIT IS SET ONLY FOR OPERSP EXPONEN
BC	 					! FOR A TYPE-CONVERSION NODE THIS BIT IS SET
BC	 					! FOR FROMINT,FROMREAL,FROMDBLPRC,FROMCMPLX
BC	 					!  AND NOT SET FOR FROMOCT,FROMCTL,FROMLIT,FROMDOCT
BLISS  V. 1.0-2.12	13-JUN-73  13:51:36	OPMOD	TABLES.BLI		PAGE 6-2

BOPRSBIC	 	OPRSBIT2=0,EXOPWD,5,1$,		!3RD BIT OF OPERSP FIELD - FOR AN ARITH
BC	 					! NODE, THIS BIT IS SET ONLY FOR SUB AND MUL
BOPR1C	 	OPR1=0,EXOPWD,5,8$,		!OPRCLS AND OPERSP FIELDS CONCATENATED
BOPR2C	 	OPR2=0,EXOPWD,6,7$;		!OPRCLS FIELD AND 1ST 2 BITS OF OPERSP FIELD
BC	 
BC	 	%(***SUBFIELDS OF THE ABOVE "MAIN" SUBFIELDS***)%
BMACROC	 MACRO
BVALTP1C	 	VALTP1=0,EXOPWD,15,2$,		!MIDDLE 2 BITS OF VALTYPE ARE
BC	 					! ALL THATS NEEDED FOR GETA1OPIX AND ARITHOPIX
BVALTP2C	 	VALTP2=0,EXOPWD,15,3$,		!FIRST 3 BITS OF VALTYPE ARE
BC	 					! IDENTICAL TO THE OPERSP FIELD FOR A TYPECNV
BC	 					! NODE TO CONVERT FROM THAT VALTYPE
BDBLFLGC	 	DBLFLG=0,EXOPWD,16,1$,		!THE 2ND BIT OF VALTYPE IS FLAG
BC	 					! FOR 2 WD VAL (DOUBLE PREC OR COMPLEX)
BSDBLFLC	 	SDBLFLG=0,EXOPWD,6,1$;		!THE 2ND BIT OF OPERSP FOR A
BC	 					!NODE OF OPRCLS "TYPECNV" IS FLAG FOR SOURCE
BC	 					!IS A 2 WD VAL
BC	 
BMACROC	 MACRO
BBOOLOPC	 	BOOLOPR=0,EXOPWD,5,2$,		!BOOLEAN OPERATOR IS SPECIFIED BY RIGHT
BC	 					! 2 BITS OF OPERSP FIELD
BBOOLCLC	 	BOOLCLS=0,EXOPWD,6,1$,		!BOOLEAN CLASS (AND/OR OR XOR/EQV) IS
BC	 					! SPECIFIED BY THE LEFTMOST OF THESE 2
BBOPRFLC	 	BOPRFLG=0,EXOPWD,5,1$;		!THE 2ND DIVIDES BOOLEANS INTO 2 OTHER
BC	 					! CLASSES - OR/XOR AND AND/EQV
BC	 
BMACROPARENLC	 MACRO	PARENLSTFLG=0,EXOPWD,7,1$;	!FLAG FOR NAME WHICH SHOULD HAVE
BC	 					! AN ARGLST FOLLOWING (THIS BIT IS
BC	 					! 1ST BIT OF OPERSP FIELD OF A DATA ITEM)
BMACROFORMLFC	 MACRO	FORMLFLG=0,EXOPWD,5,1$;	!IN OPERSP FIELD FOR A DATA ITEM, FLAG
BC	 					! FOR "FORMAL" (NOTE HOWEVER THAT THIS BIT
BC	 					! IS ALSO SET IN THE OPERSP FIELD OF A TEMPORARY)
BC	 
BC	 	%(****MACRO TO CONSTRUCT AN "OPR1" FIELD*****)%
BMACROC	 MACRO
BOPR1COPCLSOPSPC	 	OPR1C(OPCLS,OPSP)=(OPCLS^3 OR OPSP)$;
BMACROOPR2COPCLSOPSPC	 MACRO	OPR2C(OPCLS,OPSP)=(OPCLS^2 OR OPSP^(-1))$;
BC	 
BC	 	%(****TO CONSTRUCT AN OPERATOR FIELD****)%
BMACROOPERCVTYPOPCLSOPSPC	 MACRO OPERC(VTYP,OPCLS,OPSP)=(VTYP^13 OR OPCLS^8 OR OPSP^5)$;
BC	 
BC	 	%(***TO GET A VALTP1 FIELD FROM A VALTYPE****)%
BMACROVTP1VLTPC	 MACRO	VTP1(VLTP)=(VLTP^(-2) AND (#3))$;
BC	 
BC	 
BC	 	%(***TO GET A VALTP2 FIELD (FIRST 3 BITS) FROM A VALTYPE***)%
BMACROVTP2VLTPC	 MACRO	VTP2(VLTP)=(VLTP^(-2))$;
BC	 
BC	 
BC	 
BC	 
BLISS  V. 1.0-2.12	13-JUN-73  13:51:39	OPMOD	TABLES.BLI		PAGE 7-1

BC	 
BC	 
BC	 
BC	 %(*******FLAGS IN EXPFLAG FIELD (THESE ARE SET BY PHASE 2 SKEL AND USED BY PHASE 3*******)%
BMACROC	 MACRO
BPARENFC	 	PARENFLG=0,EXOPWD,35,1$,		!FLAG FOR PARENS AROUND THIS NODE (IN SOURCE)
BRVRSFLC	 	RVRSFLG=0,EXOPWD,33,1$,			!"VAL OF 2ND SON SHOULD BE
BC	 						! COMPUTED BEFORE 1ST SON
BSTOREFC	 	STOREFLG=0,EXOPWD,32,1$,		!RESULT MUST BE STORED AFTER IT IS COMPUTED
BRESRFFC	 	RESRFFLG=0,EXOPWD,31,1$,		!FLAG FOR "UNDER THIS NODE THERE IS A
BC	 						! REFERENCE TO THE VAR INTO WHICH THE RESULT
BC	 						! OF THE WHOLE EXPRESSION WILL BE STORED
BFNCALLC	 	FNCALLSFLG=0,EXOPWD,30,1$,		!FLAG FOR "FN CALLS OCCUR UNDER THIS
BC	 						! NODE
BALCRETC	 	ALCRETREGFLG=0,EXOPWD,29,1$,		!VAL OF THIS NODE IS TO BE COMPUTED
BC	 						! IN THE "FN RETURN REG" 
BA1VALFC	 	A1VALFLG=0,EXOPWD,28,1$,		!FIRST ARG IS A COMMON SUBEXPR THAT 
BC	 						! WAS ALREADY COMPUTED ELSEWHERE
BC	 						! OR A LEAF
BA1NOTFC	 	A1NOTFLG=0,EXOPWD,27,1$,		!APPLY 'NOT' TO 1ST ARG
BA1NEGFC	 	A1NEGFLG=0,EXOPWD,26,1$,		!NEGATE 1ST ARG
BA1SAMEC	 	A1SAMEFLG=0,EXOPWD,25,1$,		!LOC OF COMPUTATION FOR PARENT EQLS
BC	 						! LOC OF VALUE OF FIRST ARG
BA1IMMEC	 	A1IMMEDFLG=0,EXOPWD,24,1$,		!1ST ARG IS IMMED CONSTANT
BA2VALFC	 	A2VALFLG=0,EXOPWD,23,1$,		!2ND ARG IS A COMMON SUBEXPR THAT WAS ALREADY
BC	 						! COMPUTED ELSEWHERE
BC	 						! OR A LEAF
BA2NOTFC	 	A2NOTFLG=0,EXOPWD,22,1$,		! APPLY NOT TO 2ND ARG
BA2NEGFC	 	A2NEGFLG=0,EXOPWD,21,1$,		!NEGATE 2ND ARG
BA2SAMEC	 	A2SAMEFLG=0,EXOPWD,20,1$,		!LOC OF COMPUTATION FOR PARENT EQLS 
BC	 						! LOC OF VALUE OF 2ND ARG
BA2IMMEC	 	A2IMMEDFLG=0,EXOPWD,19,1$,		!2ND ARG IS AN IMMED CONSTANT
BMEMCMPC	 	MEMCMPFLG=0,EXOPWD,18,1$;		!VALUE COMPUTED TO MEMORY
BC	 
BMACROCSFULLC	 MACRO	CSFULLWDFLG=RVRSFLG$;		!IN A COMMON SUBEXPR NODEWHERE THE
BC	 					! COMMON-SUBEXPR IS A SINGLE VARIABLE (EG A
BC	 					! VAR USED IN RELATIONALS OR SUBSCRIPTS)
BC	 					! THIS FLAG IS SET IF THE WHOLE VARIABLE MUST BE LOADED
BC	 					! (EG IT IS USED IN A RELATIONAL), RATHER
BC	 					! THAN THE RIGHT-HALF BEING USABLE REGARDLESS OF
BC	 					! WHATS IN THE LEFT HALF (EG IT IS USED AS A SS ONLY)
BC	 
BC	 
BC	 	%(***DEFINE SUBFIELDS OF THE FLAGS FIELD***)%
BC	 
BC	 	%(*****FLAGS FOR EACH OF THE 2 ARGS***)%
BMACROC	 MACRO
BA1FLGSC	 	A1FLGS=0,EXOPWD,24,5$,
BA2FLGSC	 	A2FLGS=0,EXOPWD,19,5$;
BC	 
BC	 	%(****LAST 4 FLAGS - NEG, NOT, SAME, IMMED****)%
BMACROC	 	MACRO
BA1FLG1C	 		A1FLG1=0,EXOPWD,24,4$,
BA2FLG1C	 		A2FLG1=0,EXOPWD,19,4$;
BC	 	%(***A2IMMEDFLG CONCATENATED WITH MEMCMPFLG***)%
BMACROA2IMMEC	 	MACRO A2IMMEMCMPFLGS=0,EXOPWD,18,2$;
BC	 
BLISS  V. 1.0-2.12	13-JUN-73  13:51:42	OPMOD	TABLES.BLI		PAGE 7-2

BC	 	%(***NEG AND NOT FLAGS******************)%
BMACROC	 	MACRO
BA1NGNTC	 		A1NGNTFLGS=0,EXOPWD,26,2$,
BA2NGNTC	 		A2NGNTFLGS=0,EXOPWD,21,2$;
BC	 
BC	 	%(****TO CLEAR THE FLAGS FOR ARG1, OR FOR ARG2*****)%
BMACROCLRA1FANODEC	 	MACRO CLRA1FLGS(ANODE)=
BC	 		ANODE[EXPFLAGS]_.ANODE[EXPFLAGS] AND (NOT #003700)$;
BC	 
BMACROCLRA2FANODEC	 	MACRO CLRA2FLGS(ANODE)=
BC	 		ANODE[EXPFLAGS]_.ANODE[EXPFLAGS] AND (NOT  #000076)$;
BC	 
BC	 	%(******TO SWAP THE FLAGS FOR ARG1 AND ARG2 (WHEN ARE ALSO SWAPPIG THE 2 ARGS******)%
BC	 
BC	 	%(***VALUE FOR A1FLGS OR A2FLGS FIELD WHEN ONLY THE VAL FLG IS SET***)%
BBINDVLFLSEC	 BIND	VLFLSET=#20;
BC	 
BMACROC	 MACRO
BSWAPFLNODEC	 	SWAPFLGS(NODE) =
BC	 	BEGIN
BC	 		REGISTER T1;
BC	 		T1_.NODE[A1FLGS];
BC	 		NODE[A1FLGS]_.NODE[A2FLGS];
BC	 		NODE[A2FLGS]_.T1;
BC	 	END $;
BC	 
BC	 	%(****TO SET THE FLAGS FOR ARG1 TO THOSE FOR ARG2 AND CLEAR THOSE FOR ARG2 ****)% 
BMACROA2TOA1NODEC	 	MACRO A2TOA1FLGS(NODE)=
BC	 	BEGIN
BC	 		NODE[A1FLGS]_.NODE[A2FLGS];
BC	 		CLRA2FLGS(NODE);
BC	 	END$;
BC	 
BC	 	%(***TO MOVE FLAGS FOR A SON INTO THE FLAG FIELD OF ITS PARENT (WHEN
BC	 		LINKING THE SON DIRECTLY UP TO THE PARENT'S PARENT***)%
BMACROC	 MACRO
BRAISEFPARFLGSONFLGC	 	RAISEFLGS(PARFLGS,SONFLGS)=
BC	 	BEGIN
BC	 		REGISTER T1;
BC	 		T1_(PARFLGS XOR SONFLGS) AND NGNTFLGMSK;	!TAKE XOR OF NEGFLGS AND 
BC	 								! NOTFLGS OF PARENT AND SON
BC	 		.T1 OR (SONFLGS AND VLIMSMMSK)		!USE VALFLG, SAMEFLG 
BC	 								! AND IMMEDFLG FOR SON
BC	 	END$;
BC	 
BC	 	%(***MASK FOR NEG AND NOT FLAGS WITHIN A1FLGS/A2FLGS FIELDS***)%
BBINDNGNTFLC	 BIND	NGNTFLGMSK=#14;
BC	 
BC	 	%(***MASK FOR VALFLG,SAMEFLG, AND IMMEDFLG FIELDS WITHIN A1FLG/A2FLG FIELDS***)%
BBINDVLIMSMC	 BIND	VLIMSMMSK=#23;
BC	 
BC	 
BLISS  V. 1.0-2.12	13-JUN-73  13:51:43	OPMOD	TABLES.BLI		PAGE 8-1

BC	 
BC	 
BC	 %(*********SUBFIELDS OF TARGET FIELD***********)%
BMACROC	 MACRO
BINREGFC	 	INREGFLG=0,2,35,1$,		!FLAG FOR VAL LEFT IN A REG
BTARGTAC	 	TARGTAC=0,2,23,4$,		!AC TO BE COMPUTED IN
BTARGAUC	 	TARGAUX=0,2,27,4$,		!EXTRA AC TO COMPUTE IN, USED FOR
BC	 					! RELATIONALS (WHICH ARE "COMPUTED" IN A DIFFERENT
BC	 					! REG FROM THE ONE THAT HOLDS THE VALUE)
BTARGTMC	 	TARGTMEM=0,2,0,23$,		!MEMORY REF TO GET AT FINAL RESULT
BTARGADC	 	TARGADDR=0,2,0,18$,		!ADDRESS FIELD FOR RETRIEVING RESULT
BTARGXFC	 	TARGXF=0,2,18,4$,		!INDEX FIELD FOR RETRIEVING RESULT
BTARGIFC	 	TARGIF=0,2,22,1$;		!INDIRECT FIELD FOR RETRIEVING RESULT
BC	 %(***TO GET TARGTAC, TARGXF,  OR TARGAUX FIELD FROM A TARGET WD INTO THE AC BITS OF AN INSTR***)%
BC	 %(****OR TO GET TARGET-REG FOR AN ASSIGNMENT-STATEMENT NODE INTO THE AC BITS OF AN INSTR***)%
BMACROGETTACNODEC	 MACRO	GETTAC(NODE)=(.NODE[TARGET] AND #17^23)$,
BGETTXFNODEC	 	GETTXF(NODE)=((.NODE[TARGET] AND #17^18)^5)$,
BGETTAUNODEC	 	GETTAUX(NODE)= ((.NODE[TARGET] AND #17^27)^(-4))$,
BGETASMSTMNTNC	 	GETASMNREG(STMNTNODE)= (.STMNTNODE[CW4] AND #17^23)$,
BGETAIFAIFNODC	 	GETAIFREG(AIFNODE)=(.AIFNODE[CW5] AND #17^23)$;
BC	 
BC	 	%(***GET THE INDEX AND INDIRECT BITS OF A TARGET WD***)%
BMACROGETTXFNODEC	 MACRO GETTXFI(NODE)=(.NODE[TARGET] AND #37^18)$;
BC	 
BC	 
BMACROIXFLDREGC	 MACRO	IXFLD(REG)=REG^18$;
BC	 
BC	 
BC	 
BC	 %(************************************************************
BC	 	DEFINE THE STRUCTURE FOR AN EXPRESSION NODE
BC	 ************************************************************)%
BSTRUCTPEXPRNPEXPRNFTPFTPWDPOSSIZEC	 STRUCTURE PEXPRNODE[FTP,WD,POS,SIZE]=
BC	 
BC	 	%(***THE ARG "FTP" SELECTS THE ACCESSING ALGORITHM***)%
BCASEFTPOFSETC	 	CASE .FTP OF SET
BC	 
BC	 		%(****FOR MOST FIELDS****)%
BPEXPRNWDPOSSIZEC	 		(@.PEXPRNODE+.WD)<.POS,.SIZE>
BC	 
BC	 
BTESC	 		TES;
BC	 
BC	 
BC	 
BC	 
BC	 
BC	 %(********************************************************
BC	 	VALUES FOR SUBFIELDS OF OPERATOR FIELD
BC	 ************************************************************)%
BC	 
BC	 %(*******VALUES FOR VALTYPE FIELD*****)%
BBINDC	 BIND
BOCTALC	 	OCTAL=0,		!00000
BLOGICAC	 	LOGICAL=1,		!00001
BCONTROC	 	CONTROL=4,		!00100 - CONTROL-TYPE BOOLEAN
BDOUBLOC	 	DOUBLOCT=8,		!01000
BLISS  V. 1.0-2.12	13-JUN-73  13:51:53	OPMOD	TABLES.BLI		PAGE 8-2

BLITERAC	 	LITERAL=12,		!01100
BSTRINGC	         STRING=15,              !01111
BINTEGEC	 	INTEGER=16,		!10000
BBYTEC	 	BYTE=17,		!10001
BINDEXC	 	INDEX=18,		!10010
BREALC	 	REAL=20,		!10100
BDOUBLPC	 	DOUBLPREC=24,		!11000
BCOMPLEC	 	COMPLEX=28;		!11100 
BC	 
BC	 	%(**NOTE THAT IN THE ABOVE THE 2ND BIT IS A FLAG FOR
BC	 		DOUBLE WD***)%
BC	 	%(***NOTE ALSO THAT THE 2ND AND 3RD  BITS DETERMINE THE CODE TO BE
BC	 		GENERATED IN MANY CASES (WHERE INDEX,BYTE,LOG ARE 
BC	 		TREATED AS INTEGER); AND THAT THESE 2 BITS ARE
BC	 		REFERENCED AS THE FIELD "VALTP1" *******)%
BC	 	%(***NOTE ALSO THAT IF THE FIRST 3 BITS OF THE VALTYPES OF 2 NODES
BC	 		ARE IDENTICAL, NO TYPE-CONVERSION OPERATION IS  NECESSARY
BC	 		WHEN COMBINING THE 2 NODES ARITHMETICALLY 
BC	 	*****)%
BC	 	%(***NOTE ALSO THAT THE OPERSP FIELD FOR A TYPE CONVERSION NODE IS EQUAL
BC	 		TO THE FIRST 3 BITS OF THE ORIGINAL TYPE
BC	 	****)%
BC	 
BC	 
BC	 	%(***VALUES FOR VALTP1 FIELD (BITS 2 AND 3  OF VALTYPE)***)%
BBINDC	 BIND
BINTEG1VTP1INTEGEANDC	 	INTEG1=VTP1(INTEGER);	!00
BC	 
BC	 	%(***VALUES FOR VALTP2 FIELD (BITS 1,2,3 OF VALTYPE)***)%
BBINDC	 BIND
BLOGICALOGICAC	 	LOGICAL2=LOGICAL^(-2);
BC	 
BC	 	%(***TO TEST WHETHER A GIVEN VALTYPE IS DOUBLE-WD***)%
BMACRODBLFROVLTPC	 MACRO	DBLFROMVAL(VLTP)=
BC	 	(VLTP^(-3) AND 1)$;
BC	 
BC	 
BC	 
BC	 %(******VALUES FOR OPRCLS FIELD********)%
BBINDC	 BIND
BBOOLEAC	 	BOOLEAN=0,		!00000
BDATAOPC	 	DATAOPR=1,		!00001
BRELATIC	 	RELATIONAL=2,		!00010
BFNCALLC	 	FNCALL=3,		!00011
BARITHMC	 	ARITHMETIC=4,		!00100
BTYPECNC	 	TYPECNV=5,		!00101
BARRAYRC	 	ARRAYREF=6,		!00110
BCMNSUBC	 	CMNSUB=7,		!00111
BNEGNOTC	 	NEGNOT=8,		!01000
BSPECOPC	 	SPECOP=9,		!01001		;A SPECIAL CASE TO BE OPTIMIZED
BC	 						!(P2MUL,SQUARE,...)
BFIELDRC	 	FIELDREF=10,		!01010
BSTORECC	 	STORECLS=11,		!01011
BREGCONC	 	REGCONTENTS=12,		!01100
BLABOPC	 	LABOP=13,		!01101
BSTATEMC	 	STATEMENT=14,		!01110
BIOLSCLC	 	IOLSCLS=15,		!01111		;ELEMENT IN AN IOLIST
BLISS  V. 1.0-2.12	13-JUN-73  13:51:55	OPMOD	TABLES.BLI		PAGE 8-3

BINLINFC	         INLINFN=16,             !10000		;A FN TO BE GENERATED IN LINE
BSTRINGC	         STRINGEXP=17;           !10001          ;A STRING EXPRESSION
BC	 
BLISS  V. 1.0-2.12	13-JUN-73  13:51:55	OPMOD	TABLES.BLI		PAGE 9-1

BC	 
BC	 %(********VALUES FOR OPERSP FIELD**************)%
BC	 
BC	 	%(****FOR OPRCLS BOOLEAN****)%
BBINDC	 BIND
BANDOPC	 	ANDOP=0,		!000
BOROPC	 	OROP=1,		!001
BEQVOPC	 	EQVOP=2,		!010
BXOROPC	 	XOROP=3;		!011
BC	 
BC	 	%(***BIT 35 OF EXOPWD IS USED AS A FLAG IN A BOOLEAN NODE FOR "ARG2HAS VALTYPE
BC	 		CONTROL, ARG1 IS A MASK" ****)%
BC	 
BC	 
BC	 
BC	 	%(****FOR OPRCLS DATA ITEM****)%
BBINDC	 BIND
BCONSTAC	 	CONSTANT=0,		!000
BTEMPORC	 	TEMPORARY=1,		!001
BVARIABC	 	VARIABLE=2,		!010
BFORMLVC	 	FORMLVAR=3,		!011
BARRAYNC	 	ARRAYNAME=4,		!100
BFORMLAC	 	FORMLARRAY=5,		!101
BFNNAMEC	 	FNNAME=6,		!110
BFORMLFC	 	FORMLFN=7;		!111
BC	 
BC	 	%(***DEFINE SUBFIELD OF OPERSP FOR DATA-ITEMS THAT DIFFERENTIATES
BC	 		FN AND FORMAL FN FROM ARRAY AND FORML ARRAY FROM VAR AND FORML VAR***)%
BMACRODATOPSC	 	MACRO	DATOPS1=OPRSP1$;	!FIRST 2 BITS OF OPERSP
BC	 
BC	 	%(***DEFINE VALUES OF DATOPS1 FIELD***)%
BBINDVARIABC	 BIND	VARIABL1=1,
BARRAYNC	 	ARRAYNM1=2,
BFNNAMEC	 	FNNAME1=3;
BC	 
BC	 	%(***TO TEST FOR AN DATA ITEM AN ENTRY IN THE SYMBOL TABLE (AS OPPOSED TO A 
BC	 		CONSTANT OR TEMPORARY*****)%
BMACROSYMBOLNODEC	 MACRO	SYMBOL(NODE)=(.NODE[OPERSP] GEQ VARIABLE)$;
BC	 
BC	 	%(****FOR OPRCLS RELATIONAL****)%
BBINDC	 BIND
BLC	 	L=1,			!001
BEC	 	E=2,			!010
BLEC	 	LE=3,			!011
BGEC	 	GE=5,			!101
BNC	 	N=6,			!110
BGC	 	G=7;			!111
BC	 
BMACROC	 MACRO
BEQRELMODEC	 	EQREL(MODE) = (MODE AND #1) EQL 0$;		!E AND N  HAVE LAST BIT=0
BC	 
BMACROC	 MACRO
BREVRELMC	 	REVREL(M) = M XOR #6$;			!"REVERSE" RELATIONAL FROM M (EG FOR
BC	 						! REVREL(GE) GET LE )
BMACROC	 MACRO
BCMRELMC	 	CMREL(M)= M XOR 4$;			!TO GET "COMPLEMENT" OF A CONDITION
BC	 
BLISS  V. 1.0-2.12	13-JUN-73  13:51:56	OPMOD	TABLES.BLI		PAGE 9-2

BC	 	%(****FOR OPRCLS FNCALL****)%
BBINDC	 BIND
BNONLIBC	 	NONLIBARY=0,		!NOT A LIBRARY FUNCTION
BLIBARYC	 	LIBARY=1;		!A LIBARY FUNCTION
BC	 
BC	 	%(****FOR OPRCLS ARITHMETIC****)%
BBINDC	 BIND
BADDOPC	 	ADDOP=0,		!000
BSUBOPC	 	SUBOP=1,		!001
BMULOPC	 	MULOP=2,		!010
BDIVOPC	 	DIVOP=3,		!011
BEXPONOC	 	EXPONOP=4;		!100
BC	 
BC	 	%(***TO TRANSFORM ADD TO SUB, SUB TO ADD; MUL TO DIV, DIV TO MUL***)%
BMACROC	 MACRO
BCMPLSPNODEC	 	CMPLSP(NODE)=
BC	 		(NODE[OPERATOR]_.NODE[OPERATOR] XOR #40)$;	!CHANGE RIGHTMOST BIT OF OPERSP
BC	 								! (RIGHTMOST BIT OF OPERSP IS 
BC	 								! 5 BITS FROM RIGHT END OF
BC	 								! OPERATOR FIELD
BC	 
BC	 	%(***TEST FOR OPERATOR EITHER ADD OR SUB****)%
BMACROC	 MACRO
BADDORSNODEC	 	ADDORSUB(NODE) = .NODE[OPR2] EQL OPR2C(ARITHMETIC,ADDOP)$;
BC	 	%(***TEST FOR OPERATOR FIELD EITHER MUL OR DIV***)%
BMACROC	 MACRO
BMULORDNODEC	 	MULORDIV(NODE) = .NODE[OPR2] EQL OPR2C(ARITHMETIC,MULOP)$;
BC	 
BC	 	%(***TO TEST FOR OPERATOR (*KNOWN TO BE ARITH*) EQUAL TO EXPONENTIATION***)%
BMACROC	 MACRO
BEXPONENODEC	 	EXPONEN(NODE) = .NODE[OPRSBIT0]$;	!FIRST BIT OF OPERSP FIELD
BC	 
BC	 	%(***TO TEST FOR OPERATOR (*KNOWN TO BE ARITH*) EQUAL TO SUB OR DIV****)%
BMACROC	 MACRO
BSUBORDNODEC	 	SUBORDIV(NODE)= (.NODE[OPRSBIT2])$;	!3RD BIT OF OPERSP FIELD IS SET FOR
BC	 						! DIV AND SUB
BC	 
BC	 	%(***TO TEST FOR AN OPERATOR (OF UNKNOWN OPRCLS) EQUAL TO ADD OR MUL****)%
BMACROC	 MACRO 
BC	 	%(***OPRCLS MUST BE ARITHMETIC, OPERSP MUST HAVE ITS 1ST AND 3RD BITS 0****)%
BADDORMNODEC	 	ADDORMUL(NODE)=((.NODE[OPERWORD] AND (#37^8 OR #5^5)) EQL (ARITHMETIC^8))$;
BC	 
BC	 
BC	 	%(*****TO TEST FOR A NODE OF UNKNOWN OPRCLS TO BE COMMUTATIVE - 
BC	 		VAL IS TRUE FOR ALL BOOLEANS AND FOR ADD AND MUL*********)%
BMACROCOMMUTNODEC	 MACRO	COMMUTATIVE(NODE)=
BC	 	(.NODE[OPRCLS] EQL BOOLEAN OR ADDORMUL(NODE) )$;
BC	  
BLISS  V. 1.0-2.12	13-JUN-73  13:51:58	OPMOD	TABLES.BLI		PAGE 10-1

BC	 
BC	 
BC	 	%(****FOR OPRCLS TYPECNV****)%
BBINDC	 BIND
BFROMOCC	 	FROMOCT=0,		!000
BFROMCTC	 	FROMCTL=1,		!001
BFROMDOC	 	FROMDOCT=2,		!010
BFROMLIC	 	FROMLIT=3,		!011
BFROMINC	 	FROMINT=4,		!100
BFROMREC	 	FROMREAL=5,		!101
BFROMDBC	 	FROMDBLPRC=6,		!110
BFROMCMC	 	FROMCMPLX=7;		!111
BC	 
BC	 	%(***NOTE THAT THIS FIELD IS EQUAL TO THE FIRST 3 BITS OF THE VALTYPE
BC	 		FIELD FOR THE VALUE BEING CONVERTED FROM(THE VALTYPE FIELD 
BC	 		ON THIS NODE SPECIFIES THE TYPE TO CONVERT TO)****)%
BC	 
BC	 
BMACROC	 MACRO
BNOCNVFC	 	NOCNVFLG=0,EXOPWD,0,1$;		!BIT 35 OF EXOPWD IS USED AS A FLAG FOR "NO ACTUAL
BC	 					! CONVERSION TAKES PLACE"
BC	 
BC	 	%(***TEST WHETHER ANY CODE MUST BE GENERATED FOR A GIVEN TYPE-CONVERSION NODE***)%
BMACRONOCNVTPCNODC	 	MACRO NOCNV(TPCNODE)=
BC	 	BEGIN
BC	 		(
BC	 		(.TPCNODE[NOCNVFLG])		!IF FLAG WAS SET TO NOT ACTUALLY CONVERT
BC	 		OR
BC	 		(.TPCNODE[VALTP2] EQL .TPCNODE[OPERSP])
BC	 		OR
BC	 		(	(.TPCNODE[OPERSP] LSS FROMINT)	!CONVERTING FROM LOGICAL/OCTAL
BC	 							! OR DOUBLE-OCTAL OR CONTROL OR LITERAL
BC	 			AND
BC	 			( (NOT .TPCNODE[DBLFLG]) OR .TPCNODE[SDBLFLG])	!AND IF THE DESTIN IS
BC	 									!DBL WD, SO IS THE SRC
BC	 		)
BC	 		)
BC	 		AND (NOT .TPCNODE[A2IMMEDFLG])	!IF THE ARG UNDER THE TYPE-CNV
BC	 						! IS THE RIGHT HALF OF AN AOBJN VAR,
BC	 						! MUST LOAD IT
BC	 	END$;
BC	 
BC	 
BC	 
BC	 	%(***FOR OPRCLS NEGNOT***************************)%
BBINDC	 BIND
BNEGOPC	 	NEGOP=0,
BNOTOPC	 	NOTOP=1;
BC	 
BC	 	%(****FOR OPRCLS SPECOP (SPECIAL OPS INTRODUCED BY PHASE 2 SKEL)***)%
BBINDC	 BIND
BP2MULOC	 	P2MULOP=0,		!MULTIPLY BY A POWER OF 2
BP2DIVOC	 	P2DIVOP=1,		!DIVIDE BY A POWER OF 2
BP2PL1OC	 	P2PL1OP=2,		!MULTIPLY BY A POWER OF 2 PLUS 1
BSQROPC	 	SQROP=3,		!SQUARE (RAISE TO POWER OF 2)
BCUBOPC	 	CUBOP=4,		!CUBE (RAISE TO POWER OF 3)
BP4OPC	 	P4OP=5,			!RAISE TO POWER OF 4
BLISS  V. 1.0-2.12	13-JUN-73  13:52:00	OPMOD	TABLES.BLI		PAGE 10-2

BEXPCIOC	 	EXPCIOP=6;		!RAISE TO A  CONSTANT INTEGER POWER
BC	 				! (NOT HANDLED IN RELEASE 1)
BC	 
BC	 
BC	 	%(***FOR OPRCLS STORECLS****************************)%
BBINDC	 BIND
BSTARVAC	 	STARVAL=0,		!STORE CONTENTS OF AN ARRAY ELEM
BSTARADC	 	STARADDR=1;		!STORE PTR TO AN ARRAY ELEMENT
BC	 
BC	 
BC	 	%(***FOR OPRCLS IOLSCLS (FOR IOLIST ELEMENTS)***)%
BBINDC	 BIND
BDATACAC	 	DATACALL=0,
BSLISTCC	 	SLISTCALL=1,
BIOLSTCC	 	IOLSTCALL=2,
BS1LISTC	 	S1LISTCALL=3,			!AN SLISTCALL DETECTED IN PHASE 2 SKEL -
BC	 					! MAY HAVE MORE THAN ONE ARRAYREF
BC	 					! (NOT IN RELEASE 1)
BELISTCC	 	ELISTCALL=4;			! NOT IN RELEASE 1
BC	 
BC	 
BC	 	%(***FOR OPRCLS INLINFN (FNS TO BE GENERATED IN LINE)****)%
BBINDC	 BIND
BABSFNC	 	ABSFN=0,
BIABSFNC	 	IABSFN=1,
BSIGNFNC	 	SIGNFN=2,
BDIMFNC	 	DIMFN=3,
BMODFNC	 	MODFN=4,
BMAXFNC	 	MAXFN=5,
BMINFNC	 	MINFN=6;
BC	 
BC	 	%(***MACRO TO DETERMINE FOR A GIVEN IN-LINE-FN WHETHER THE ARG SHOULD BE PUT
BC	 		INTO THE REG-FOR-COMPUTATION BEFORE THE VAL IS COMPUTED (FOR ABS,IABS
BC	 		AND SIGN, DO NOT WANT TO LOAD THE ARG IN ADVANCE) ****)%
BMACROILFINROPSPC	 	MACRO ILFINRFC(OPSP)=(OPSP GEQ DIMFN)$;
BC	 
BC	 
BC	 
BC	 
BC	 	%(****VALS FOR OPR1 FIELD FOR SOME OF THE OPERATORS*****)%
BBINDC	 BIND
BADDOPFOPR1CARITHMORADDOPC	 	ADDOPF=OPR1C(ARITHMETIC,ADDOP),
BSUBOPFOPR1CARITHMORSUBOPC	 	SUBOPF=OPR1C(ARITHMETIC,SUBOP),
BMULOPFOPR1CARITHMORMULOPC	 	MULOPF=OPR1C(ARITHMETIC,MULOP),
BDIVOPFOPR1CARITHMORDIVOPC	 	DIVOPF=OPR1C(ARITHMETIC,DIVOP),
BEXPONOOPR1CARITHMOREXPONOC	 	EXPONOPF=OPR1C(ARITHMETIC,EXPONOP),
BCONSTFOPR1CDATAOPORCONSTAC	 	CONSTFL=OPR1C(DATAOPR,CONSTANT),
BVARFLOPR1CDATAOPORVARIABC	 	VARFL=OPR1C(DATAOPR,VARIABLE),
BNEGFLOPR1CNEGNOTORNEGOPC	 	NEGFL=OPR1C(NEGNOT,NEGOP),
BMODFNFOPR1CINLINFORMODFNC	 	MODFNFL=OPR1C(INLINFN,MODFN),
BSTARVLOPR1CSTORECORSTARADC	 	STARVLFL=OPR1C(STORECLS,STARADDR),
BSLISTCOPR1CIOLSCLORSLISTCC	 	SLISTCLFL=OPR1C(IOLSCLS,SLISTCALL);
BC	 
BC	 
BBINDC	 BIND
BP2MULOOPR1CSPECOPORP2MULOC	 	P2MULOPF=OPR1C(SPECOP,P2MULOP),
BP2DIVOOPR1CSPECOPORP2DIVOC	 	P2DIVOPF=OPR1C(SPECOP,P2DIVOP),
BLISS  V. 1.0-2.12	13-JUN-73  13:52:04	OPMOD	TABLES.BLI		PAGE 10-3

BP2PL1OOPR1CSPECOPORP2PL1OC	 	P2PL1OPF=OPR1C(SPECOP,P2PL1OP);
BBINDC	 BIND
BSQROPFOPR1CSPECOPORSQROPC	 	SQROPF=OPR1C(SPECOP,SQROP),
BCUBOPFOPR1CSPECOPORCUBOPC	 	CUBOPF=OPR1C(SPECOP,CUBOP),
BP4OPFOPR1CSPECOPORP4OPC	 	P4OPF=OPR1C(SPECOP,P4OP);
BBINDC	 BIND
BEXPCIFOPR1CSPECOPOREXPCIOC	 	EXPCIF=OPR1C(SPECOP,EXPCIOP);
BC	 
BC	 
BC	 	%(***VALUES OF OPERATOR FIELD FOR SOME OF THE OPERATORS***)%
BBINDREALCOOPERCREALORDATAOPORCONSTAC	 BIND	REALCONST=OPERC(REAL,DATAOPR,CONSTANT),
BINTCONOPERCINTEGEORDATAOPORCONSTAC	 	INTCONST=OPERC(INTEGER,DATAOPR,CONSTANT),
BDOUBLCOPERCDOUBLPORDATAOPORCONSTAC	 	DOUBLCONST=OPERC(DOUBLPREC,DATAOPR,CONSTANT),
BCPLXCOOPERCCOMPLEORDATAOPORCONSTAC	 	CPLXCONST=OPERC(COMPLEX,DATAOPR,CONSTANT),
BLITCONOPERCLITERAORDATAOPORCONSTAC	 	LITCONST=OPERC(LITERAL,DATAOPR,CONSTANT),
BINTVAROPERCINTEGEORDATAOPORVARIABC	 	INTVAR=OPERC(INTEGER,DATAOPR,VARIABLE),
BINDEXVOPERCINDEXORDATAOPORVARIABC	 	INDEXVAR=OPERC(INDEX,DATAOPR,VARIABLE);
BBINDINTDIVOPERCINTEGEORARITHMORDIVOPC	 BIND	INTDIVIDE=OPERC(INTEGER,ARITHMETIC,DIVOP);
BC	 
BBINDABSFNOOPERCREALORINLINFORABSFNC	 BIND	ABSFNOP=OPERC(REAL,INLINFN,ABSFN),
BIABSFNOPERCINTEGEORINLINFORIABSFNC	 	IABSFNOP=OPERC(INTEGER,INLINFN,IABSFN),
BSIGNFNOPERCREALORINLINFORSIGNFNC	 	SIGNFNOP=OPERC(REAL,INLINFN,SIGNFN),
BISIGNFOPERCINTEGEORINLINFORSIGNFNC	 	ISIGNFNOP=OPERC(INTEGER,INLINFN,SIGNFN),
BDIMFNOOPERCREALORINLINFORDIMFNC	 	DIMFNOP=OPERC(REAL,INLINFN,DIMFN),
BIDIMFNOPERCINTEGEORINLINFORDIMFNC	 	IDIMFNOP=OPERC(INTEGER,INLINFN,DIMFN),
BMODFNOOPERCINTEGEORINLINFORMODFNC	 	MODFNOP=OPERC(INTEGER,INLINFN,MODFN),
BMAXFNOOPERCINTEGEORINLINFORMAXFNC	 	MAXFNOP=OPERC(INTEGER,INLINFN,MAXFN),
BMINFNOOPERCINTEGEORINLINFORMINFNC	 	MINFNOP=OPERC(INTEGER,INLINFN,MINFN),
BAMAXFNOPERCREALORINLINFORMAXFNC	 	AMAXFNOP=OPERC(REAL,INLINFN,MAXFN),
BAMINFNOPERCREALORINLINFORMINFNC	 	AMINFNOP=OPERC(REAL,INLINFN,MINFN);
BC	 
BBINDCMPLXOOPERCCOMPLEORTYPECNORFROMREC	 BIND	CMPLXOP=OPERC(COMPLEX,TYPECNV,FROMREAL),
BDBLEOPOPERCDOUBLPORTYPECNORFROMREC	 	DBLEOP=OPERC(DOUBLPREC,TYPECNV,FROMREAL),
BDFLOATOPERCDOUBLPORTYPECNORFROMINC	 	DFLOATOP=OPERC(DOUBLPREC,TYPECNV,FROMINT),
BFLOATOOPERCREALORTYPECNORFROMINC	 	FLOATOP=OPERC(REAL,TYPECNV,FROMINT),
BIDINTOOPERCINTEGEORTYPECNORFROMDBC	 	IDINTOP=OPERC(INTEGER,TYPECNV,FROMDBLPRC),
BINTOPOPERCINTEGEORTYPECNORFROMREC	 	INTOP=OPERC(INTEGER,TYPECNV,FROMREAL),
BIFIXOPOPERCINTEGEORTYPECNORFROMREC	 	IFIXOP=OPERC(INTEGER,TYPECNV,FROMREAL),
BREALOPOPERCREALORTYPECNORFROMCMC	 	REALOP=OPERC(REAL,TYPECNV,FROMCMPLX),
BSNGLOPOPERCREALORTYPECNORFROMDBC	 	SNGLOP=OPERC(REAL,TYPECNV,FROMDBLPRC);
BC	 
BC	 
BBINDLTOPOPERCCONTROORRELATIORLC	 BIND	LTOP=OPERC(CONTROL,RELATIONAL,L),
BEQOPOPERCCONTROORRELATIOREC	 	EQOP=OPERC(CONTROL,RELATIONAL,E),
BLEOPOPERCCONTROORRELATIORLEC	 	LEOP=OPERC(CONTROL,RELATIONAL,LE),
BGEOPOPERCCONTROORRELATIORGEC	 	GEOP=OPERC(CONTROL,RELATIONAL,GE),
BNEOPOPERCCONTROORRELATIORNC	 	NEOP=OPERC(CONTROL,RELATIONAL,N),
BGTOPOPERCCONTROORRELATIORGC	 	GTOP=OPERC(CONTROL,RELATIONAL,G);
BC	 
BBINDFIXOPOPERCINTEGEORTYPECNORFROMREC	 BIND	FIXOP=OPERC(INTEGER,TYPECNV,FROMREAL);
BBINDIOLSTCOPERCORIOLSCLORIOLSTCC	 BIND	IOLSTCFL=OPERC(0,IOLSCLS,IOLSTCALL),
BDATACLOPERCORIOLSCLORDATACAC	 	DATACLFL=OPERC(0,IOLSCLS,DATACALL);
BC	 
BBINDDOSTATSTOPERSTATEMORDOIDC	 BIND	DOSTATEMENT=STOPERC(STATEMENT,DOID);
BBINDCONTSTSTOPERSTATEMORCONTIDC	 BIND	CONTSTATEMENT=STOPERC(STATEMENT,CONTID);
BC	 
BC	 	
BLISS  V. 1.0-2.12	13-JUN-73  13:52:36	OPMOD	TABLES.BLI		PAGE 10-4

BC	 
BC	 
BC	 %(********VALUES FOR SPECIAL OPERATOR SUBFIELDS***********)%
BC	 
BC	 	%(****USED FOR OPRCLS BOOLEAN*****)%
BBINDC	 BIND
BANDORCC	 	ANDORCLS=0,		!VALUE OF BOOLCLS FOR AND/OR NODES
BANDOPFC	 	ANDOPF=0,		!VALUE OF BOPRFLG FOR AND/EQV NODES
BXOROROC	 	XOROROPF=1;		!VALUE OF BOPRFLG FOR OR/XOR NODES
BC	 
BC	 
BC	 
BC	 %(****************************************
BC	 	TO CHECK FOR VALUES THAT FIT IN SINGLE WD
BC	 ****************************************)%
BMACROSINGLWNODEC	 MACRO	SINGLWD(NODE)= NOT (.NODE[DBLFLG])$;
BC	 
BC	 
BC	 %(***************************************************************************
BC	 	TO TEST A CONSTANT NODE FOR BEING AN IMMEDIATE-SIZE CONSTANT
BC	 ***************************************************************************)%
BC	 
BC	 
BMACROIMMEDCNODEC	 MACRO IMMEDCNST(NODE)=
BC	 BEGIN
BC	 	EXTERNAL KDPRL;		!THESE GLOBALS ARE USED IN CALLING THE MACRO MODULE
BC	 	EXTERNAL C1H,C1L,C2H,COPRIX;	! THAT ROUNDS REAL NUMBERS
BC	 	EXTERNAL CNSTCM;
BC	 
BC	 	CASE .NODE[VALTP1] OF SET
BC	 	%(***INTEGER CONSTANTS ARE IMMED SIZE IFF ABSOLUTE VAL IS LESS THAN 777777***)%
BC	 	(ABS(.NODE[CONST2]) LEQ #777777);
BC	 	%(***REAL CONSTANTS ARE IMMED SIZE IFF THE RIGHT HALF WD IS
BC	 		ALL 0'S*******)%
BC	 	BEGIN
BC	 		%(***BECAUSE WE KEEP 2 WDS OF PRECISION THRUOUT COMPILE TIME,
BC	 			WE MUST EXAMINE WHAT THE ROUNDED CONSTANT WILL BE***)%
BC	 		C1H_.NODE[CONST1]; C1L_.NODE[CONST2]; COPRIX_KDPRL;	!ROUND THE NUMBER IN C1H-C1L
BC	 		CNSTCM();						! LEAVING THE RESULT IN C2H
BC	 		(.C2H AND #777777) EQL 0
BC	 	END;
BC	 	%(***DOUBLE-PREC CONSTANTS CAN NOT BE TREATED IMMED MODE***)%
BC	 	FALSE;
BC	 	%(***COMPLEX CONSTANTS CAN BE TREATED IMMED MODE IFF THE REAL PART IS
BC	 		IMMED SIZE AND THE IMAGINARY PART IS 0***)%
BC	 	((.NODE[CONST1] AND #777777) EQL 0) AND (.NODE[CONST2] EQL 0)
BC	 	TES
BC	 END$;
BC	 
BC	 %(***TO TEST FOR A CONSTANT NEGATIVE***********)%
BMACRONEGATICNNODEC	 MACRO NEGATIVC(CNNODE)=
BC	 	BEGIN
BC	 		IF .CNNODE[VALTP1] EQL INTEG1
BC	 		THEN
BC	 		.CNNODE[CONST2] LSS 0
BC	 		ELSE
BC	 		.CNNODE[CONST1] LSS 0
BLISS  V. 1.0-2.12	13-JUN-73  13:52:38	OPMOD	TABLES.BLI		PAGE 10-5

BC	 	END$;
BC	 
BC	 
BC	 
BC	 
BC	 
BLISS  V. 1.0-2.12	13-JUN-73  13:52:38	OPMOD	TABLES.BLI		PAGE 11-1

BC	 
BC	 
BC	 %(*****************OPCODE FIELDS USED EXPLICITLY***************************)%
BBINDC	 BIND
BJRSTOCC	 	JRSTOC=#254^27,
BJUMPOCC	 	JUMPOC=#320^27,
BSKIPOCC	 	SKIPOC=#330^27,
BSKIPGEC	 	SKIPGEOC=#335^27;
BBINDC	 BIND
BINDBITC	 	INDBIT=1^22;		!INDIRECT BIT
BC	 
BBINDC	 BIND	
BADDBOCC	 	ADDBOCD=#273,
BADDIOCC	 	ADDIOCD=#271,
BADDMOCC	 	ADDMOCD=#272,
BAOJAOCC	 	AOJAOCD=#344,
BAOSOCDC	 	AOSOCD=#350,
BASHOCDC	 	ASHOCD=#240,
BCAIOCDC	 	CAIOCD=#300,
BCAMOCDC	 	CAMOCD=#310,
BDMOVEOC	 	DMOVEOCD=#120,
BDMOVEMC	 	DMOVEMOCD=#124,
BFADRBOC	 	FADRBOCD=#147,
BFADRMOC	 	FADRMOCD=#146,
BFDVRMOC	 	FDVRMOCD=#176,
BFIXOCDC	 	FIXOCD=#122,
BFLTROCC	 	FLTROCD=#127,
BFSCOCDC	 	FSCOCD=#132,
BHRLZIOC	 	HRLZIOCD=#515,
BIDIVMOC	 	IDIVMOCD=#232,
BIMULMOC	 	IMULMOCD=#222,
BJRSTOCC	 	JRSTOCD=#254,
BJUMPOCC	 	JUMPOCD=#320,
BJUMPGEC	 	JUMPGEOCD=#325,
BJUMPLOC	 	JUMPLOCD=#321,
BMOVEIOC	 	MOVEIOCD=#201,
BMOVEOCC	 	MOVEOCD=#200,
BMOVEMOC	 	MOVEMOCD=#202,
BMOVNIOC	 	MOVNIOCD=#211,
BMOVNMOC	 	MOVNMOCD=#212,
BMOVNSOC	 	MOVNSOCD=#213,
BMOVSIOC	 	MOVSIOCD=#205,
BSETCAMC	 	SETCAMOCD=#452,
BSETCMBC	 	SETCMBOCD=#463,
BSETZBOC	 	SETZBOCD=#403,
BSETOBOC	 	SETOBOCD=#477,
BSKIPOCC	 	SKIPOCD=#330,
BSOJAOCC	 	SOJAOCD=#364,
BSOSOCDC	 	SOSOCD=#370,
BSUBIOCC	 	SUBIOCD=#275,
BSUBMOCC	 	SUBMOCD=#276;
BLISS  V. 1.0-2.12	13-JUN-73  13:52:41	OPMOD	TABLES.BLI		PAGE 12-1

BC	 
BC	 %(***************************************************************************	
BC	 	DEFINE THE FIELDS OF THE NODES USED FOR IOLISTS (OPRCLS=IOLSCLS)
BC	 ***************************************************************************)%
BC	 
BC	 	%(***FIELDS IN ALL IOLSCLS NODES***)%
BMACROC	 MACRO
BIOLSTLC	 	IOLSTLBL=0,0,LEFT$;
BC	 	%(***FIELDS IN DATACALL NODES***)%
BMACROC	 MACRO
BDCALLEC	 	DCALLELEM=0,1,LEFT$;
BC	 
BC	 	%(***FIELDS IN SLISTCALL NODES***)%
BMACROC	 MACRO
BSCALLEC	 	SCALLELEM=0,1,LEFT$,
BSCALLCC	 	SCALLCT=0,2,RIGHT$;
BC	 
BC	 	%(****NOTE THAT FOR IOLSTCALL NODES, S1LISTCALL NODES, AND ELISTCALL NODES,
BC	 		THE 3RD WORD (0,2,LEFT AND 0,2,RIGHT) IS USED FOR SRCCMPLX AND
BC	 		SRCCOMNSUB *****)%
BC	 
BC	 
BC	 
BC	 	%(***FIELDS IN IOLSTCALL NODES***)%
BMACROC	 MACRO
BIOLSTPC	 	IOLSTPTR=0,1,LEFT$;
BC	 
BC	 	%(***FIELDS IN S1LISTCALL AND ELISTCALL NODES***)%
BMACROC	 MACRO
BECNTPTC	 	ECNTPTR=0,3,LEFT$,		!PTR TO EXPRESSION FOR NUMBER OF ELEMS
BC	 					! OF EACH ARRAY TO BE PROCESSED
BC	 
BELSTPTC	 	ELSTPTR=0,1,LEFT$;
BC	 
BC	 	%(***FIELDS IN S1LIST NODES***)%
BMACROC	 MACRO
BS1INCRC	 	S1INCR=0,3,RIGHT$;
BC	 
BC	 	%(***FIELDS OF THE ELEMENTS OF THE LINKED LIST UNDER AN E2LISTCALL***)%
BMACROC	 MACRO
BE2INCRC	 	E2INCR=0,1,LEFT$,		!PTR TO EXPRESSION FOR INCREMENT TO BE
BC	 					! USED FOR THIS ARRAY
BE2ARREC	 	E2ARREFPTR=0,1,RIGHT$;		!PTR TO ARRAYREF NODE
BC	 
BC	 
BC	 
BC	 
BLISS  V. 1.0-2.12	13-JUN-73  13:52:44	OPMOD	TABLES.BLI		PAGE 13-1

BC	 
BC	 %(***************************************************************************
BC	 	DEFINE AN OBJECT-CODE WORD AS A STRUCTURE.
BC	 	DEFINE THE FIELDS OF THAT WORD FOR FOROTS ARG BLOCKS.
BC	 ***************************************************************************)%
BC	 
BSTRUCTOBJECTOBJECTWDWDPOSSIZEC	 STRUCTURE OBJECTCODE[WD,POS,SIZE]=
BOBJECTWDPOSSIZEC	    (.OBJECTCODE+.WD)<.POS,.SIZE> ;
BC	 
BC	 
BC	 	%(***DEFINE THE FIELDS USED FOR FOROTS ARG BLOCKS***)%
BMACROC	 MACRO
BOTSWHOC	 	OTSWHOLE=0,0,36$,
BOTSCNTC	 	OTSCNT=0,27,9$,
BOTSTYPC	 	OTSTYPE=0,23,4$,		!VALUE-TYPE ALWAYS GOES IN BITS 9-12
BOTSINXC	 	OTSINX=0,18,4$,		!INDEX FIELD
BOTSINDC	 	OTSIND=0,22,1$,		!INDIRECT BIT
BOTSADDC	 	OTSADDR=0,0,18$,		!ADDRESS FIELD
BOTSUNIC	 	OTSUNIT=0,0,18$,		!UNIT NUMBER ALWAYS GOES INTO BITS 18-35
BOTSFORC	 	OTSFORM=0,0,18$,		!PTR TO FORMAT 
BOTSARRC	 	OTSARRFMTFLG=0,35,1$,		!FLAG FOR "FORMAT STMNT IS AN ARRAY"
BOTSFSIC	 	OTSFSIZ=0,18,17$,	!FORMAT SIZE
BOTSIDNC	 	OTSIDN=0,27,9$,		!FOR AN IOLIST ELEMENT - IDENTIFIES THE CLASS OF ELEM
BOTSMEMC	 	OTSMEMRF=0,0,23$;		!THE 23 BITS DESCRIBING MEMORY REFERENCE
BC	 
BC	 
BC	 	%(***DEFINE VALUES FOR IDN FIELD FOR IOLIST ELEMENTS***)%
BBINDC	 BIND
BOTSZERC	 	OTSZER=0,
BOTSDATC	 	OTSDATA=1,
BOTSSLIC	 	OTSSLIST=2,
BOTSFINC	 	OTSFIN=4,
BOTSELIC	 	OTSELIST=3;
BC	 
BC	 
BBINDC	 BIND
BOTSZEROTSZERC	 	OTSZERWD=OTSZER^27,
BOTSFINOTSFINC	 	OTSFINWD=OTSFIN^27;
BC	 
BC	 
BC	 	%(***DEFINE ARG TYPE CODES THAT ARE USED FOR FOROTS CALLS***)%
BBINDADDRTYC	 BIND	ADDRTYPE=#7,		!TYPE CODE FOR A LABEL
BIMMEDTC	 	IMMEDTYPE=0;		!TYPE CODE INDICATING TO PICK UP ARG IMMED MODE
BC	 
BLISS  V. 1.0-2.12	13-JUN-73  13:52:49	OPMOD	TABLES.BLI		PAGE 14-1

BC	 
BC	 %(***************************************************************************
BC	 	SPECIFIC VALUES FOR FIELDS IN AN ARITHMETIC-IF NODE
BC	 ***************************************************************************)%
BC	 
BC	 	%(***VALUES FOR AIFLBEQV FIELD****)%
BBINDC	 BIND
BNOLBEQC	 	NOLBEQV=0,
BLELBEQC	 	LELBEQV=1,		!LSS LABEL SAME AS EQL LABEL
BLGLBEQC	 	LGLBEQV=2,		!LSS LABEL SAME AS GTR LABEL
BGELBEQC	 	GELBEQV=3;		!GTR LABEL SAME AS EQL LABEL
BC	 
BC	 	%(***VALUES FOR AIFLBNXT FIELD*******)%
BBINDC	 BIND
BNOLBNXC	 	NOLBNXT=0,
BLLBNXTC	 	LLBNXT=1,		!LSS LABEL IS NEXT STMNT
BELBNXTC	 	ELBNXT=2,		!EQL LABEL IS NEXT STMNT
BGLBNXTC	 	GLBNXT=3;		!GTR LABEL IS NEXT STMNT
BC	 
BC	 
BC	 	%(***WHEN SWAP THE GTR AND LESS LABELS (BECAUSE MULTIPLY BY -1), USE THE
BC	 		FOLLOWING MACRO TO ADJUST THE "AIFLBNXT" AND "AIFLBEQV"  FIELDS***)%
BMACROSWPAIFSTMNTC	 	MACRO SWPAIFFLGS(STMNT)=
BC	 	BEGIN
BC	 		IF .STMNT[AIFLBNXT]		!IF LAST BIT OF AIFLBNXT IS ON
BC	 		THEN
BC	 		STMNT[AIFLBNXT]_.STMNT[AIFLBNXT] XOR #2;	!THEN COMPLEMENT 1ST BIT
BC	 		IF .STMNT[AIFLBEQV]				!IF LAST BIT OF AIFLBEQV ON
BC	 		THEN
BC	 		STMNT[AIFLBEQV]_.STMNT[AIFLBEQV] XOR #2;	!THEN COMPLEMENT 1ST BIT
BC	 	END$;
BLISS  V. 1.0-2.12	13-JUN-73  13:52:52	OPMOD	TABLES.BLI		PAGE 15-1

BC	 
BC	 
BC	 %(***************************************************************************
BC	 	DEFINE THE STRUCTURE OF AN ARGUMENT LIST.
BC	 	CERTAIN FIXED FIELDS ON THE LIST WILL BE REFERENCED SIMPLY BY NAME.
BC	 	FIELDS CORRESPONDING TO THE NTH ARG WILL BE REFERENCED BY [N,NAME]
BC	 	NOTE THAT THE FIRST ARG HAS N=1 (NOT!!!! 0)
BC	 	NOTE THAT THE COUNT FIELD OF THE LIST WILL BE POSITIVE AND EQUAL
BC	 	TO THE NUMBER OF ARGS.
BC	 ***************************************************************************)%
BC	 
BSTRUCTARGUMEARGUMEARGINDARGINDWDPOSSIZEC	 STRUCTURE ARGUMENTLIST[ARGINDEX,WD,POS,SIZE]=
BARGUMEARGINDWDPOSSIZEC	 	(@.ARGUMENTLIST+2+(.ARGINDEX-1)+.WD)<.POS,.SIZE>;
BC	 
BC	 
BC	 	%(***DEFINE THE FIXED FIELDS THAT OCCUR AT THE START OF EVERY ARGUMENT LIST - 
BC	 		DEFINE ALL THESE FIELDS IN TERMS OF A NEGATIVE NUMBER OF WDS FROM THE
BC	 		ENTRY FOR THE FIRST ARGUMENT (HENCE HAVE THE ARGINDEX FIELD=1) ***)%
BMACROC	 MACRO
BARGLABC	 	ARGLABEL=1,-2,LEFT$,
BARGLINC	 	ARGLINK=1,-2,RIGHT$,
BARGCOUC	 	ARGCOUNT=1,-1,RIGHT$;
BC	 
BC	 	%(***DEFINE THE FIELDS THAT ARE REPEATED FOR EACH ARGUMENT. 
BC	 		WILL ALWAYS REFERENCE THESE FIELDS BY A REF OF THE FORM:
BC	 			ALIST[N,FIELDNAME]
BC	 		WHERE N IS THE NUMBER OF THE ARGUMENT DESIRED
BC	 	*********)%
BMACROC	 MACRO
BARGNPTC	 	ARGNPTR=0,RIGHT$,		!PTR TO THE EXPRESSION NODE FOR THE ARG
BAFLGFLC	 	AFLGFLD=0,LEFT$,		!FLAGS
BAVALFLC	 	AVALFLG=0,35,1$;		!FLAG IS SET IF ARG IS A DATA ITEM OR
BC	 					! COMMON SUBEXPR
BC	 
BC	 
BC	 	%(***DEFINE THE FOLLOWING FIELD SO THAT PHASE 1 CAN REFERENCE THE AVALFLG
BC	 		BY USING A "BASE" STRUCTURE ON A GIVEN WORD*****)%
BMACROP1AVALC	 MACRO	P1AVALFLG=0,0,35,1$;
BC	 
BC	 
BC	 	%(***DEFINE MACRO THAT DESCRIBES NUMBER OF WDS NECESSARY IN AN ARGLIST THAT
BC	 		INCLUDES "ACT" NUMBER OF ARGS***)%
BMACROARGLSTACTC	 MACRO	ARGLSTSIZE(ACT)=(2+ACT)$;
BC	 
BC	 
BC	 
BLISS  V. 1.0-2.12	13-JUN-73  13:53:09	OPMOD	TABLES.BLI		PAGE 16-1

BC	 
BC	 
BC	 %(***************************************************************************
BC	 	DEFINE THE STRUCTURE THAT WILL BE MAPPED ON THE LIBRARY FN ATTRIBUTE
BC	 	TABLE.
BC	 	FOR EACH LIBRARY-FN WILL HAVE A "LIBRARY-FN-INDEX" THAT INDICATES ITS
BC	 	POSITION IN THIS TABLE. THE FIRST ENTRY HAS INDEX =0.
BC	 ***************************************************************************)%
BSTRUCTLIBATTLIBATTFNINDEFNINDEWDPOSSIZECODEARGTYPC	 STRUCTURE LIBATTSTR[FNINDEX,WD,POS,SIZE,CODE,ARGTYP1]=
BC	 	%(***FOR MOST FIELDS BOTH "CODE" AND "ARGTYP1" ARE 0***)%
BIFCODEEQLC	 	IF .CODE EQL 0
BTHENC	 	THEN
BLIBATTFNINDEWDPOSSIZEC	 	(.LIBATTSTR+2*.FNINDEX+.WD)<.POS,.SIZE>
BC	 
BC	 	%(***FOR GENERIC FUNCTIONS ONLY - TO PICK UP THE NAME OF THE ACTUAL
BC	 		FUNCTION TO USE FOR A GIVEN ARG-TYPE.
BC	 		HAVE "CODE" EQUAL TO 1, "ARGTYP1" EQUAL TO THE VALTP1
BC	 		FIELD OF THE ARGUMENT.
BC	 	**********)%
BELSEC	 	ELSE
BC	 	%(***GO INDIRECT THRU  THE "ATTGENPTR" FIELD - ADD "ARGTYP1" TO
BC	 		THE PTR IN THAT FIELD TO GET A PTR TO THE WD THAT
BC	 		INDICATES THE ACTUAL FN TO USE (THAT WD WILL ITSELF CONTAIN
BC	 		A PTR BACK TO A FUNCTION-TABLE ENTRY)
BC	 	*******)%
BLIBATTFNINDEWDPOSSIZEARGTYPC	 	(.(.LIBATTSTR+2*.FNINDEX+.WD)<.POS,.SIZE> + .ARGTYP1)<0,36>;
BC	 
BC	 	%(***DEFINE MACROS THAT DESCRIBE THE FIELDS FOR A GIVEN FUNCTION INDEX***)%
BMACROC	 MACRO
BATTFNAC	 	ATTFNATTRIB=0,0,36,0,0$,	!THE FIRST WORD OF THE ENTRY WILL BE
BC	 					! COPIED INTO THE SYMBOL TABLE ENTRY
BC	 					! FOR THE FUNCTION NAME (INTO THE IDFNATTRIB FIELD)
BATTINLC	 	ATTINLINFLG=0,35,1,0,0$,	!BIT 0 OF 1ST WD IS FLAG FOR IN-LINE-FN
BATTGENC	 	ATTGENERFLG=0,33,1,0,0$,	! GENERIC FN FLAG
BATTARGC	 	ATTARGTYP=0,28,5,0,0$,	! VALTYPE FOR EXPECTED ARG
BATTRESC	 	ATTRESTYPE=0,23,5,0,0$,	! VALTYPE OF RESULT
BATTARGC	 	ATTARGCT=0,18,5,0,0$,	! NUMBER OF ARGS EXPECTED
BATTNEWC	 	ATTNEWOPR=0,0,18,0,0$,	!OPERATOR TO BE SUBSTITUTED FOR FN CALL
BC	 				! IF THIS FN IS TO BE GENERATED IN LINE
BATTGENC	 	ATTGENPTR=1,0,18,0,0$,	!FOR GENERIC FNS ONLY - PTR TO SUBTABLE
BC	 				! DESCRIBING WHICH FNS TO USE FOR EACH ARG TYPE
BATTACTC	 	ATTACTFN=1,0,18,1$;	!FOR GENERIC FNS ONLY - TO GET A PTR TO
BC	 				! THE ACTUAL FN TO USE WILL GO INDIRECT THRU
BC	 				! THE "ATTGENPTR" FIELD AND THEN ADD ON THE TYPE OF THE ARG
BC	 
BC	 
BBINDILGARGC	 	BIND	ILGARGTYPE=-1;	!FOR GENERIC FNS - IF A GIVEN ARG TYPE IS ILLEGAL
BC	 				! THE "ATTACTFN" FIELD FOR THAT TYPE WILL CONTAIN THIS CODE
BBINDVARGCTC	 	BIND	VARGCTFLG=#37;	!FUNCTIONS THAT CAN TAKE AN ARBITRARY NUMBER OF
BC	 				! ARGS (EG MAX,MIN) HAVE THE "ATTARGCT" SET TO THIS VAL
BC	 
BLISS  V. 1.0-2.12	13-JUN-73  13:53:12	OPMOD	TABLES.BLI		PAGE 17-1

BC	 
BC	 
BC	 %(***************************************************************************
BC	 	DEFINE THE STRUCTURE TO BE MAPPED ON THE LIST OF ARG-CODES
BC	 	AND CORRESPONDING  VALUES THAT OCCURS UNDER AN OPEN STATEMENT
BC	 ***************************************************************************)%
BC	 
BSTRUCTOPENLIOPENLIARGINDARGINDWDPOSSIZEC	 STRUCTURE OPENLIST[ARGINDEX,WD,POS,SIZE]=
BOPENLIARGINDWDPOSSIZEC	 	(@.OPENLIST+.ARGINDEX+.WD)<.POS,.SIZE>;
BC	 
BC	 
BC	 	%(***DEFINE THE FIELDS USED FOR A GIVEN INDEX***)%
BMACROOPENLCC	 MACRO	OPENLCODE=0,LEFT$,	!CODE FOR FOROTS FOR THIS ARG
BOPENLPC	 	OPENLPTR=0,RIGHT$;	!PTR TO THE CONSTANT TABLE OR SYMBOLTABLE
BC	 				! ENTRY FOR THE VALUE FOR THIS ARG TO FOROTS
BC	 
BC	 	%(***DEFINE VALUES FOR OPENLCODE***)%
BBINDOPNCDIC	 BIND	OPNCDIALOG=01,		!DIALOG
BOPNCACC	 	OPNCACCESS=02,		!ACCESS
BOPNCDEC	 	OPNCDEVICE=03,		!DEVICE
BOPNCBUC	 	OPNCBUFCOUNT=04,	!BUFFER COUNT
BOPNCBLC	 	OPNCBLOCKSIZE=05,	!BLOCK SIZE
BOPNCFIC	 	OPNCFILENAME=06,	!FILE NAME
BOPNCPRC	 	OPNCPROTECTION=07,	!PROTECTION
BOPNCDIC	 	OPNCDIRECTORY=#10,	!DIRECTORY
BOPNCLIC	 	OPNCLIMIT=#11,		!LIMIT
BOPNCMOC	 	OPNCMODE=#12,		!MODE
BOPNCFIC	 	OPNCFILESIZE=#13,	!FILE SIZE
BOPNCREC	 	OPNCRECORDSIZE=#14,	!RECORD SIZE
BOPNCDIC	 	OPNCDISPOSE=#15,	!DISPOSE
BOPNCVEC	 	OPNCVERSION=#16,	!VERSION
BOPNCREC	 	OPNCREELS=#17,		!REELS
BOPNCMOC	 	OPNCMOUNT=#20,		!MOUNT
BOPNCERC	 	OPNCERROR=#21,		!ERROR
BOPNCASC	 	OPNCASSOCIATE=#22;	!ASSOCIATE
BLISS  V. 1.0-2.12	13-JUN-73  13:53:13	OPMOD	TABLES.BLI		PAGE 18-1

BC	 
BC	 %(***************************************************************************
BC	 	DEFINE THE STRUCTURE OF THE SYMBOL TABLE
BC	 ***************************************************************************)%
BSTRUCTSYMTABSYMTABDMYDMYWDPOSSIZEC	 STRUCTURE SYMTABENTRY[DMY,WD,POS,SIZE]=
BSYMTABWDPOSSIZEC	 	(@.SYMTABENTRY+.WD)<.POS,.SIZE>;
BC	 
BC	 
BC	 
BC	 
BLISS  V. 1.0-2.12	13-JUN-73  13:53:13	OPMOD	TABLES.BLI		PAGE 19-1

BC	 
BC	 %(***************************************************************************
BC	 	DEFINE THE STRUCTURE OF THE DIMENSION TABLE
BC	 ***************************************************************************)%
BSTRUCTDIMENTDIMENTDMYDMYWDPOSSIZEC	 STRUCTURE DIMENTRY[DMY,WD,POS,SIZE]=
BDIMENTWDPOSSIZEC	 	(@.DIMENTRY+.WD)<.POS,.SIZE>;
BMACRODIMNUMC	 MACRO DIMNUM=0,0,18,16$;			!NUMBER OF DIMENSIONS
BMACROADJDIMC	 MACRO	ADJDIMFLG=0,0,35,1$;			!FLAG FOR ADJUSTABLY DIMENSIONED
BMACROARASIZC	 MACRO 	ARASIZ=0,0,RIGHT$;			!NUMBER OF WDS IN THE ARRAY
BC	 						!PTR TO A CONSTANT TABLE ENTRY UNLESS
BC	 						! ARRAY IS ADJ DIMENSIONED,
BC	 						! IN WHICH CASE, HAVE PTR TO A TMP
BMACROARAOFFC	 MACRO	ARAOFFSET=0,1,LEFT$;			!VALUE OF OFFSET FOR THIS
BC	 						! ARRAY IF DIMENSIONS ARE
BC	 						! CONSTANT; POINTER TO LOC
BC	 						! IN WHICH THE OFFSET WILL
BC	 						! BE STORED IF DIMENSIONS
BC	 						! ARE VARIABLE
BMACROARADDRC	 MACRO	ARADDRVAR=0,1,RIGHT$;		!FOR FORMAL ARRAYS THAT ARE NOT ADJUSTABLY
BC	 						! DIMENSIONED, THIS FIELD POINTS 
BC	 						! TO A "PSEUDO" SYMBOL TABLE ENTRY
BC	 						! FOR THE ARRAY NAME WITH THE TYPE
BC	 						! FIELD SET TO INTEGER. IT IS THIS SYMBOL
BC	 						! THAT IS USED IN THE ADDRESS CALC
BMACRODIMENSXC	 MACRO	DIMENS(X)=0,2+2*X,FULL$,		!DIMENSIONS FOR THE XTH DIMENSION
BDIMENLXC	 	DIMENL(X)=0,2+2*X,LEFT$,		!LOWER BOUND OF DIMENSION X
BDIMENUXC	 	DIMENU(X)=0,2+2*X,RIGHT$,		!UPPER BOUND OF DIMENSION X
BDVARLBXC	 	DVARLBFLG(X)=0,3+2*X,34,1$,		!FLAG FOR LOWER BOUND A  VARIABLE
BDVARUBXC	 	DVARUBFLG(X)=0,3+2*X,33,1$,		! FOR UPPER BOUND A VARIABLE
BDVARFAXC	 	DVARFACTFLG(X)=0,3+2*X,35,1$,		! FOR FACTOR A VARIABLE
BDFACTOXC	 	DFACTOR(X)=0,3+2*X,RIGHT$;		!FACTOR THAT SS FOR THIS
BC	 						! DIMENSION IS MULTIPLIED BY
BC	 						! THIS IS A PTR TO A CONSTANT TABLE ENTRY
BC	 						! IF PRECEEDING DIMENSIONS WERE CONSTANT,
BC	 						! A PTR TO A SYMBOL TABLE ENTRY FOR A
BC	 						! VAR IN WHICH THE VAL IS STORED IF VARIABLE
BMACROFIRSTDC	 MACRO FIRSTDIM=0,2,WHOLE$;
BC	 
BC	 	%(***THE SUBENTRY FOR A GIVEN DIMENSION***)%
BSTRUCTDIMSUBDIMSUBWDWDPOSSIZEC	 STRUCTURE DIMSUBENTRY[WD,POS,SIZE]=
BDIMSUBWDPOSSIZEC	 	(@.DIMSUBENTRY+.WD)<.POS,.SIZE>;
BC	 
BMACROC	 MACRO
BDIMLBC	 	DIMLB=0,LEFT$,
BDIMUBC	 	DIMUB=0,RIGHT$,
BVARLBFC	 	VARLBFLG=1,34,1$,			!FLAG FOR "LOWER BOUND ON THIS DIMENSION
BC	 						! A VARIABLE
BVARUBFC	 	VARUBFLG=1,33,1$,			!UPPER BOUND A VARIABLE
BVARFACC	 	VARFACTFLG=1,35,1$;			!FACTOR FOR THIS DIMENSION A VARIABLE
BMACRODIMFACC	 MACRO	DIMFACTOR=1,RIGHT$;		!FACTOR TO MULTIPLY SS OF THIS DIMENSION
BC	 
BLISS  V. 1.0-2.12	13-JUN-73  13:53:19	OPMOD	TABLES.BLI		PAGE 20-1

BC	 
BC	 
BC	 
BC	 %(*********
BC	 	DEFINE VALUES OF LABEL TABLE FIELDS USED FOR PEEPHOLING
BC	 **********)%
BC	 
BC	 	%(***VALUES FOR SNSTATUS FIELD***)%
BBINDOUTPBUC	 BIND	OUTPBUFF=2,			!LABEL IS OUT OF THE PEEPHOLE BUFFER
BINPBUFC	 	INPBUFF=1,			!LABEL IS STILL IN THE PEEPHOLE BUFFER
BUNRESOC	 	UNRESOLVED=0;			!LABEL IS UNRESOLVED
BBINDLBTBENC	 BIND	LBTBENDMK=0;				!VALUE OF NXTLAB FIELD
BC	 						! FOR LAST LINK
BC	 
BC	 
BC	 
BLISS  V. 1.0-2.12	13-JUN-73  13:53:20	OPMOD	TABLES.BLI		PAGE 21-1

BC	 
BC	 %(**************
BC	 	DEFINE STRUCTURE FOR PEEPHOLE BUFFER
BC	 ****************)%
BC	 
BC	 	%(***SIZE OF PEEPHOLE BUFFER ENTRIES****)%
BBINDPBFENTC	 BIND PBFENTSIZE=3;			!NUMBER OF WORDS IN EACH PEEPHOLE BUFFER ENTRY
BBINDPBFSIZPBFENTC	 BIND PBFSIZE=25*PBFENTSIZE + 2;		!NUMBER OF WORDS IN THE PEEPHOLE BUFFER
BC	 					! (KEEP 1 WD AFTER THE LAST ENTRY TO HOLD
BC	 					! A POSSIBLE LABEL AND A POSSIBLE ISN)
BC	 
BC	 
BC	 	%(****STRUCTURE FOR LOOKING AT A PEEPHOLE*******)%
BC	 	%(*******THE ARG INST INDICATES WHICH INSTRUCTION OF THE PEEPHOLE***)%
BSTRUCTPEEPHOPEEPHOINSTINSTWDPOSSIZEC	 STRUCTURE	PEEPHOLE[INST,WD,POS,SIZE]=
BPEEPHOPBFENTINSTWDPOSSIZEC	 	(@.PEEPHOLE + PBFENTSIZE*.INST +.WD)<.POS,.SIZE>;
BC	 
BC	 
BC	 	%(****STRUCTURE FOR A PEEPHOLE BUFFER ENTRY***)%
BSTRUCTPEEPFRPEEPFRWDWDPOSSIZEC	 STRUCTURE PEEPFRAME[WD,POS,SIZE]=
BPEEPFRWDPOSSIZEC	 	(.PEEPFRAME+.WD)<.POS,.SIZE>;
BC	 
BC	 	%(***STRUCTURE FOR A PTR TO  A PEEPHOLE BUFFER ENTRY*****)%
BSTRUCTPPEEPFPPEEPFWDWDPOSSIZEC	 STRUCTURE PPEEPFRAME[WD,POS,SIZE]=
BPPEEPFWDPOSSIZEC	 	(@.PPEEPFRAME+.WD)<.POS,.SIZE>;
BC	 
BC	 
BC	 %(*****DEFINE FIELDS FOR PEEPHOLE BUFFER FRAME*****)%
BMACROPBFISNC	 MACRO	PBFISN=0,WHOLE$,		!ISN FOR STMNT BEGUN BY THIS INSTR
BC	 					! -1 FOR INSTRS THAT DO NOT START STMNTS
BPBFLABC	 	 PBFLABEL=1,LEFT$,			!PTR TO LABEL TABLE ENTRY FOR THE 1ST
BC	 						!  LABEL ASSOCIATED WITH THIS
BC	 						! LOC
BPBFSYMC	 	PBFSYMPTR=1,RIGHT$,			!0 IF ADDR FIELD IS A LABEL
BC	 						!1 IF ADDR FIELD HAS NO SYMBOLIC REPR
BC	 						!2 IF ADDR FIED IS A PTR TO THE SIXBIT
BC	 						! FOR AN IMPLICITLY CALLED FUNCTION
BC	 						!3 IF ADDR IS A PTR TO A SYMBOL TABLE ENTRY
BC	 						! FOR AN EXPLICITLY CALLED FN
BC	 						! OTHERWISE A PTR TO THE SYMBOL TABLE,CONSTANT
BC	 						! TABLE OR TEMP TABLE ENTRY FOR THIS ADDR FIELD
BPBFINSC	 	PBFINSTR=2,WHOLE$,
BPBFADDC	 	PBFADDR=2,RIGHT$,		!ADDRESS FIELD OF THE INSTR
BPBFOPCC	 	PBFOPCOD=2,27,9$,		! OP-CODE
BPBFOPKC	 	PBFOPKEY=2,27,5$,		! LAST 5 BITS OF OPCODE, USED AS
BC	 					! KEY IN PEEPHOLE OPTIMIZER
BPBFREGC	 	PBFREG=2,23,4$,			!REG FIELD
BPBFINDC	 	PBFINDEX=2,18,4$,		!INDEX AND INDIRECT FIELDS
BPBFMEMC	 	PBFMEMREF=2,0,23$;		!ADDRESS,INDIRECT, AND INDEX FIELDS
BBINDNOLABEC	 BIND	NOLABEL=0;				!FLAG FOR "NO LABEL YET ASSOCIATED
BC	 						! WITH THIS LOC"
BBINDNOISNC	 BIND	NOISN=-1;		!CODE FOR "NO ISN ASSOCIATED WITH THIS INSTR"
BC	 				! (IE THE INSTR IS IN THE MIDDLE OF A STMNT)
BC	 
BC	 %(*******SPECIAL VALS FOR PBFSYMPTR FIELD*******)%
BBINDC	 BIND
BPBFLABC	 	PBFLABREF=0,			!ADDRESS FIELD IS A LABEL, RH IS AN INSTRUCTION
BLISS  V. 1.0-2.12	13-JUN-73  13:53:47	OPMOD	TABLES.BLI		PAGE 21-2

BPBFNOSC	 	PBFNOSYM=1,			!ADDRESS FIELD IS AN OCTAL CONSTANT, RH IS AN INSTR
BPBFIMFC	 	PBFIMFN=2,			!ADDR FIELD IS A PTR TO AN IMPLICITLY CALLED FN
BPBFEXFC	 	PBFEXFN=3,			!ADDR FIELD IS A PTR TO AN EXPLICITLY CALLED FN
BPBF2LAC	 	PBF2LABREF=4,			!BOTH HALVES OF WD ARE PTRS TO LABEL TABLE
BC	 					! ENTRIES
BPBF2NOC	 	PBF2NOSYM=5,			!BOTH HALVES OF WD ARE OCTAL CONSTANTS WITH
BC	 					! NO SYMBOLIC REPRESENTATION
BPBFFORC	 	PBFFORMAT=6,			!RIGHT HALF WORD IS FORMAT ADDRESS
BPBFLLAC	 	PBFLLABREF=7,			!LEFT HALF IS A LABEL REFERENCE
BC	 					!USED PRIMARILY FOR ARGUMENT BLOCKS TO
BC	 					!FOROTS FOR THE END=,ERR= WORD
BPBFENTC	 	PBFENTRY=8;			!FOR A GLOBAL ENTRY (AS SUBROUTINE
BC	 					!OR ENTRY NAME).
BC	 
BC	 
BBINDPBFCODC	 BIND	PBFCODMAX=16;		!CAN NEVER USE ANY NUMBER GTR THAN 16 AS A SPECIAL
BC	 				! CODE VALUE FOR PSYMPTR, BECAUSE ANY NUMBER GTR
BC	 				! THAN 16 MIGHT BE THE ADDRESS OF A NODE
BLISS  V. 1.0-2.12	13-JUN-73  13:53:48	OPMOD	TABLES.BLI		PAGE 22-1

BC	 
BC	 
BC	 %(***************************************************************************
BC	 	TO GENERATE A JRST INSTRUCTION
BC	 ***************************************************************************)%
BMACROJRSTGEADDRC	 MACRO JRSTGEN(ADDR)=
BC	 BEGIN
BC	 	PBOPWD_JRSTOC OR ADDR;
BC	 	PSYMPTR_PBFLABREF;			!FLAG FOR "ADDRESS FIELD OF THIS INSTR IS
BC	 						! A LABEL"
BC	 	OBUFF();
BC	 END$;
BC	 
BC	 
BC	 	%(***TO GENERATE JRST INDIRECT***)%
BMACROJRSTIGADDRC	 MACRO JRSTIGEN(ADDR)=
BC	 BEGIN
BC	 	PBOPWD_JRSTOC OR INDBIT OR ADDR;
BC	 	PSYMPTR_PBFLABREF;
BC	 	OBUFF();
BC	 END$;
BLISS  V. 1.0-2.12	13-JUN-73  13:53:49	OPMOD	TABLES.BLI		PAGE 23-1

BC	 %(***************************************************************************
BC	 	DEFINE THE VARIOUS WAYS OF BUILDING INDICES INTO THE OPGENDISPATCH TABLE.
BC	 	EACH KIND OF INDEX IS COMPOSED OF SOME COMBINATION OF THE FLAG AND OPERATOR
BC	 	FIELDS OF THE NODES FOR WHICH CODE IS TO BE GENERATED.
BC	 ***************************************************************************)%
BC	 
BC	 
BC	 	%(****TO GET THE VAL OF AN ARGNODE INTO THE REG FOR COMPUTATION OF THE PARENT (WHEN
BC	 		THE VAL OF THE SON IS WITHIN REACH OF 1 INSTR.
BC	 		DEPENDS ON THE VALS OF NEGFLG,NOTFLG,SAMEFLG,IMMEDFLG
BC	 		FOR THE ARG INVOLVED, ALSO ON THE VALUE-TYPE OF THE ARG.
BC	 	*******)%
BMACROGETA1OPNODEANODEC	 MACRO	GETA1OPIX(PNODE,ANODE)=
BC	 	BEGIN
BC	 		(.PNODE[A1FLG1]^2 + .ANODE[VALTP1] +(IF .KA10FLG THEN OPGETA ELSE OPGETI))
BC	 	END$;
BC	 
BMACROGETA2OPNODEANODEC	 MACRO	GETA2OPIX(PNODE,ANODE)=
BC	 	BEGIN
BC	 		(.PNODE[A2FLG1]^2 + .ANODE[VALTP1] + (IF .KA10FLG THEN OPGETA ELSE OPGETI))
BC	 	END$;
BC	 
BC	 	%(***FOR DO-LOOPS - DONT ACTUALLY HAVE AN EXPRESSION NODE BUT WANT TO GET VAL
BC	 		HOW TO DO SO DEPENDS ON VAL OF IMMEDFLG, VALTYPE AND NEGATE FLAG***)%
BMACRODOGETAIMFLGVLTPNEGFLAC	 MACRO	DOGETAOPIX(IMFLG,VLTP,NEGFLAG)=
BC	 	(NEGFLAG^4+IMFLG^2 + VLTP + (IF .KA10FLG THEN OPGETA ELSE OPGETI))$;
BC	 
BC	 
BC	 
BC	 
BC	 
BC	 	%(****TO COMPUTE THE VALUE OF A NON-CONTROL BOOLEAN NODE. CODE TO BE GENERATED
BC	 		DEPENDS ON A2NOTFLG, A2IMMEDFLG, AND MEMCMPFLG AND THE OPERSP***)%
BMACROBOOLOPPNODEC	 MACRO	BOOLOPIX(PNODE)=
BC	 	(.PNODE[A2NOTFLG]^4 + .PNODE[A2IMMEMCMPFLGS]^2 + .PNODE[OPERSP] + OPGBOO)$;
BC	 
BC	 
BC	 	%(******TO SKIP THE NEXT INSTRUCTION WHEN A RELATIONAL HAS THE VAL INDICATED
BC	 		BY 'SKPCND'. CODE TO BE GENERATED DEPENDS ON WHETHER THE ARGS
BC	 		OF THE RELATIONAL ARE SINGLE OR DOUBLE WD AND WHETHER
BC	 		THE 2ND ARG IS IMMED*******)%
BC	 	%(*****(NOTE THAT IF THIS IS EVER CHANGED, THEN DPIMMRELOPIX DEFINED
BC	 		BELOW SHOULD ALSO BE CHANGED)***)%
BMACRORELOPIPNODEANODESKPCNDC	 	MACRO RELOPIX(PNODE,ANODE,SKPCND)=
BC	 	BEGIN
BC	 		REGISTER MODE;			!MODE ON WHICH TO SKIP
BC	 		MODE_.PNODE[OPERSP];		!MODE SPECIFIED IN RELATIONAL
BC	 		IF FALSITY(SKPCND)
BC	 		THEN MODE_CMREL(.MODE);		!IF WANT TO SKIP ON REL FALSE
BC	 
BC	 		.ANODE[DBLFLG]^4 + .PNODE[A2IMMEDFLG]^3 + .MODE + OPGREL
BC	 	END$;
BC	 
BC	 
BC	 	%(****FOR A RELATIONAL BETWEEN A DOUBLE-PREC AND ZERO. CAN USE SAME
BC	 		CODE AS USE TO COMPARE A REAL TO ZERO (SEE RELOPIX ABOVE)***)%
BMACRODPIMMRPNODESKPCNDC	 	MACRO	DPIMMRELOPIX(PNODE,SKPCND)=
BLISS  V. 1.0-2.12	13-JUN-73  13:53:53	OPMOD	TABLES.BLI		PAGE 23-2

BC	 	BEGIN
BC	 		REGISTER MODE;	!MODE ON WHICH TO SKIP
BC	 		MODE_.PNODE[OPERSP];
BC	 		IF FALSITY(SKPCND)
BC	 		THEN MODE_CMREL(.MODE);	!IF WANT TO SKIP ON RELATIONAL FALSE
BC	 
BC	 		1^3 + .MODE + OPGREL	!HAVE A2IMMEDFLG (SINCE COMPARE TO 0)
BC	 					! AND DO NOT HAVE DOUBLE-WD COMPARE)
BC	 	END$;
BC	 
BC	 
BLISS  V. 1.0-2.12	13-JUN-73  13:53:55	OPMOD	TABLES.BLI		PAGE 24-1

BC	 
BC	 	%(*****TO COMPUTE THE VAL OF AN ARITHMETIC NODE.
BC	 		DEPENDS ON THE VALS A2IMMEDFLG,MEMCMPFLG,VALTYPE, AND OPERSP OF THE PARENT
BC	 		NOTE THAT EXPONENTIATION NODES WERE CONVERTED TO FUNCTION-CALLS DURING
BC	 		THE COMPLEXITY WALK. HENCE NEVER HAVE TO GET OPGNTA INDEX FOR EXPONEN
BC	 	********)%
BMACROARITHOPNODEC	 MACRO	ARITHOPIX(PNODE)=
BC	 	BEGIN
BC	 		(.PNODE[A2IMMEMCMPFLGS]^4+.PNODE[OPRSP2]^2+.PNODE[VALTP1]+
BC	 			(IF .KA10FLG THEN OPGARA ELSE OPGARI))
BC	 	END$;
BC	 
BC	 
BC	 	%(*********FOR THE ADD TO MEMORY FOR A DO-LOOP********)%
BMACRODOARITVLTPMCPFLGIMFLGNEGFLAC	 MACRO	DOARITHOPIX(VLTP,MCPFLG,IMFLG,NEGFLAG)=
BC	 		%(***HAVE A2IMMEDFLG=IMFLG,  MEMCMPFLG=MCPFLG,
BC	 			OPERATOR IS ADD IF NEGFLAG IS 0, SUB IF NEGFLAG IS 1***)%
BC	 	(IMFLG^5 + MCPFLG^4 + (ADDOP+NEGFLAG)^2 + VLTP + (IF .KA10FLG THEN OPGARA ELSE OPGARI))$;
BC	 
BC	 
BC	 
BC	 	%(*****TO COMPUTE THE VAL OF A TYPE CONVERSION NODE.
BC	 		WILL BE GENERATING CODE ONLY WHEN  DESTIN  TYPE
BC	 		IS REAL,INTEGER,DOUBLEPREC,OR COMPLEX (IE NEVER HAVE
BC	 		TO DEAL WITH OCTAL,DOUBLE-OCTAL,LOGICAL,LITERAL,OR CONTROL)
BC	 		THUS ONLY NEED TO DIFFERENTIATE BETWEEN THESE 4 TYPES
BC	 		THE TYPE TO BE CONVERTED TO (SPECIFIED BY THE VALTYPE FIELD OF THE
BC	 		TYPE-CONVERION NODE).
BC	 		THE OPERSP FIELD OF THE TYPE CONVERSION NODE, INDICATES
BC	 		THE ORIGINAL TYPE BEING CONVERTED.
BC	 	*******)%
BMACROTPCNVIPNODEC	 	MACRO	TPCNVIX(PNODE)= (.PNODE[OPERSP]^2 + .PNODE[VALTP1] + 
BC	 			(IF .KA10FLG THEN OPGTCA ELSE OPGTCI))$;
BC	 
BC	 
BC	 
BC	 
BC	 	%(****TO COMPUTE THE VALUE OF A NEGNOT NODE.  WHEN PHASE 2 SKELETON IS PRESENT,
BC	 		THERE WILL BE FEW OF THESE. (EG FOR F(-X), NOT(-X))*********)%
BC	 
BC	 	%(***WHEN A2NEG,A2NOT, OR A2SAMEFLG IS SET, WILL USE GETA2OPIX TO GET THE ARG
BC	 		INTO A REG, AND THEN USE THE FOLLOWING INDEX*****)%
BMACRONEGNOTPNODEC	 MACRO	NEGNOT1IX(PNODE)=
BC	 	(.PNODE[MEMCMPFLG]^3 + .PNODE[OPERSP]^2 + .PNODE[VALTP1] + (IF .KA10FLG THEN OPGN1A ELSE OPGN1I))$;
BC	 
BC	 	%(***OTHERWISE, USE AN INDEX BASED ON A2IMMED, MEMCMP, OPERSP, VALTP1****)%
BMACRONEGNOTPNODEC	 MACRO	NEGNOT2IX(PNODE)=
BC	 	(.PNODE[A2IMMEMCMPFLGS]^3 + .PNODE[OPERSP]^2 + .PNODE[VALTP1] + (IF .KA10FLG THEN OPGN2A ELSE OPGN2I))$;
BC	 
BC	 	%(***TO COMPUTE THE VALUE OF A P2MUL OR P2PL1MUL  -
BC	 		CODE TO BE GENERATED DEPENDS ON VALTYPE OF THE NODE AND
BC	 		ON WHICH OP IS TO BE PERFORMED****)%
BMACROSPECOPPNODEC	 MACRO	SPECOPIX(PNODE)=
BC	 	BEGIN
BC	 		%(***IF ARG IS IMMEDIATE AND OPERATION IS P2PLUS1-MULTIPLY OR CUBE, HAVE A
BC	 			SPECIAL CASE***)%
BC	 		IF .PNODE[A1IMMEDFLG]
BLISS  V. 1.0-2.12	13-JUN-73  13:53:59	OPMOD	TABLES.BLI		PAGE 24-2

BC	 		THEN
BC	 		BEGIN
BC	 			IF .PNODE[OPERSP] EQL P2PL1OP
BC	 			THEN (.PNODE[A1NEGFLG]^2 + .PNODE[VALTP1] + OPP21I)
BC	 			ELSE
BC	 			IF .PNODE[OPERSP] EQL CUBOP
BC	 			THEN (.PNODE[A1NEGFLG]^2 + .PNODE[VALTP1] + OPCUBI)
BC	 			ELSE
BC	 			(.PNODE[OPERSP]^3 + .PNODE[A1NEGFLG]^2 +.PNODE[VALTP1]
BC	 				+(IF .KA10FLG THEN OPGSPA ELSE OPGSPI))
BC	 		END
BC	 		ELSE
BC	 		(.PNODE[OPERSP]^3 + .PNODE[A1NEGFLG]^2 +.PNODE[VALTP1]
BC	 			+(IF .PNODE[MEMCMPFLG] THEN OPGSPM		!FOR OPS DONE TO MEMORY DONT CARE
BC	 									! WHETHER ARE KA OR KI
BC	 				ELSE IF .KA10FLG THEN OPGSPA ELSE OPGSPI))
BC	 	END$;
BC	 
BC	 
BC	 
BC	 	%(***TO GENERATE CODE FOR AN IN-LINE FUNCTION WHEN ARG1 FOR THAT FN IS ALREADY IN REGFORC**)%
BMACROILFIXPNODEC	 MACRO	ILFIX(PNODE)=
BC	 	BEGIN
BC	 		IF .PNODE[A2IMMEDFLG]
BC	 		THEN
BC	 		.PNODE[OPERSP] + OPGILI
BC	 		ELSE
BC	 		.PNODE[OPERSP] + OPGILF
BC	 	END$;
BC	 
BC	 	%(***TO GENERATE CODE FOR AN IN-LINE FN WHEN ARG IS NOT IN REGFORCOMP (USED FOR
BC	 		ABS,IABS (NOT IN RELEASE 1), AND SIGN ***)%
BMACROILF1IXPNODEC	 MACRO	ILF1IX(PNODE)=
BC	 	(.PNODE[OPERSP] + OPGIL1) $;
BC	 
BC	 
BC	 	%(*****TO PERFORM THE ACTION SPECIFIED FOR A "STORECLS" NODE (WHICH IS USED
BC	 		WHEN EITHER A PTR TO AN ARRAY ENTRY OR THE CONTENTS OF THAT
BC	 		ENTRY MUST BE STORED IN A TEMPORARY************)%
BMACROSTCLSOPNODEC	 MACRO	STCLSOPIX(PNODE)=
BC	 	(.PNODE[OPERSP]^1 + .PNODE[A2SAMEFLG] + OPGSTC)$;
BC	 
BC	 
BC	 	%(*****TO STORE A VALUE THAT HAS BEEN COMPUTED****)%
BMACROSTOROPPNODEC	 MACRO	STOROPIX(PNODE)=
BC	 	BEGIN
BC	 		.PNODE[DBLFLG] + (IF .KA10FLG THEN OPGSTA ELSE OPGSTI)
BC	 	END$;
BC	 
BC	 	%(******TO STORE THE VALUE OF THE RHS OF AN ASSIGNMENT STMNT
BC	 		INTO THE LHS. CODE TO BE GENERATED DEPENDS ON WHETHER THE VAL MUST
BC	 		BE NEGATED OR COMPLEMENTED, AND ON THE VALTYPE*****)%
BMACROASNOPIPNODELHSNODC	 	MACRO ASNOPIX(PNODE,LHSNODE)=
BC	 	BEGIN
BC	 		%(***IF THIS STATEMENT HAS A2IMMEDFLG AND A2SAMEFLG BOTH SET, IT
BC	 			MUST BE THAT THE RHS IS A REGCONTENTS NODE FROM WHICH WE
BC	 			ONLY WANT TO USE THE RIGHT HALF (BECAUSE IT IS AN AOBJN WD).***)%
BLISS  V. 1.0-2.12	13-JUN-73  13:54:13	OPMOD	TABLES.BLI		PAGE 24-3

BC	 		IF .PNODE[A2IMMEDFLG] AND .PNODE[A2SAMEFLG]
BC	 		THEN
BC	 		OPGASR
BC	 
BC	 		ELSE
BC	 		.PNODE[A1NGNTFLGS]^2 + .LHSNODE[VALTP1] + (IF .KA10FLG THEN OPGASA ELSE OPGASI)
BC	 	END$;
BC	 
BC	 
BC	 	%(****TO GENERATE CODE FOR AN ARITHMETIC-IF STATEMENT**********)%
BC	 
BMACROC	 MACRO
BAIFIXSTMNODCNEXPRC	 	AIFIX(STMNODE,CNEXPR)=
BC	 		(.STMNODE[AIFFLGS]^1 +
BC	 			(IF .CNEXPR[OPRCLS] EQL DATAOPR
BC	 			THEN 0
BC	 			ELSE .CNEXPR[INREGFLG])
BC	 			+ OPGAIF)$;
BC	 
BC	 	%(***TO INIT A LOGICAL VALUE TO TRUE OR FALSE (-1 OR 0). CODE
BC	 		TO BE GENERATED DEPENDS ON WHETHER VAL IS TO BE LEFT IN A REG AND
BC	 		ON THE VAL TO BE STORED
BC	 		NOTE THAT "LOGVAL" IS EXPECTED TO BE 777777777777 FOR "TRUE"
BC	 	*****)%
BMACROSETLOGPNODELOGVALC	 MACRO	SETLOGIX(PNODE,LOGVAL)=
BC	 	((LOGVAL AND #2) + .PNODE[INREGFLG] + OPGSET)$;
BC	 
BC	 
BC	 	%(*****TO TRANSFER CONTROL WHEN A SPECIFIED VAR HAS THE SPECIFIED VAL TRUE OR FALSE.
BC	 		CODE TO BE GENERATED DEPENDS ON WHICH CONDITION TRANSFER IS DESIRED
BC	 		AND ON WHETHER THE VAL IS IN A REG
BC	 		NOTE THAT "JMPCND" IS EXPECTED TO BE 777777777777 FOR "TRUE"
BC	 ****)%
BMACROCNDVTRNODEJMPCNDC	 MACRO	CNDVTRIX(NODE,JMPCND)=
BC	 	BEGIN
BC	 		IF .NODE[OPRCLS] EQL DATAOPR
BC	 		THEN
BC	 		((JMPCND AND #2) + OPGVTS)
BC	 		ELSE
BC	 		((JMPCND AND #2) + .NODE[INREGFLG] + OPGVTS)
BC	 	END$;
BC	 
BC	 
BC	 	%(*******TO TRANSFER TO ONE LABEL IF A SPECIFIED VALUE IS TRUE
BC	 		AND TO ANOTHER IF THE VAL IS FALSE.
BC	 		CODE TO BE GENERATED DEPENDS ON WHETHER THE VAL TO BE GENERATED
BC	 		IS IN A REG.
BC	 	********)%
BMACROALTTRINODEC	 MACRO	ALTTRIX(NODE)=
BC	 	BEGIN
BC	 		IF .NODE[OPRCLS] EQL DATAOPR
BC	 		THEN
BC	 		OPGALT
BC	 		ELSE
BC	 		(.NODE[INREGFLG] + OPGALT)
BC	 	END$;
BC	 
BLISS  V. 1.0-2.12	13-JUN-73  13:54:15	OPMOD	TABLES.BLI		PAGE 24-4

BLISS  V. 1.0-2.12	13-JUN-73  13:54:15	OPMOD	TABLES.BLI		PAGE 25-1

BC	 
BC	 
BC	 %(**************************************************
BC	 	DEFINE STRUCTURE FOR OPGENTABLE ENTRY - 
BC	 	FOR A GIVEN TYPE OF NODE, WILL HAVE A SERIES OF SUCH ENTRIES, ONE
BC	 	FOR EACH INSTRUCTION TO BE GENERATED
BC	 ******************************************************)%
BC	 
BC	 
BSTRUCTOPGENTOPGENTWDWDPOSSIZEC	 STRUCTURE OPGENTRY[WD,POS,SIZE]=
BOPGENTWDPOSSIZEC	 	(@.OPGENTRY+.WD)<.POS,.SIZE>;
BC	 
BC	 %(**************FIELDS FOR AN OPGENTRY***********)%
BMACROC	 MACRO
BREGSPEC	 	REGSPEC=0,LEFT$,			!SPECIFIES WHERE TO GET
BC	 						! REG TO BE USED
BMEMSPEC	 	MEMSPEC=0,RIGHT$,			!SPECIFIES WHERE TO GET
BC	 						! MEMREF TO BE USED
BPATTERC	 	PATTERN=1,WHOLE$;		!PATTERN WORD FOR INSTR TO
BC	 						! BE GENERATED
BC	 
BC	 %(*********DEFINE VALUES FOR REGSPEC AND MEMSPEC FIELDS*********)%
BBINDC	 BIND
BFRPTNC	 	FRPTN=0,		!REG OR MEMREF FIELD USED AS IS IN WD 1 OF OPGENTABLE ENTRY
BFRRFCC	 	FRRFC=1,		!REG FIELD IN THE GLOBAL "REGFORCOMP" SHOULD BE
BC	 				! ADDED IN TO THE REG FIELD IN WD 1
BC	 				! (OR THE REG SPECIFIED BY "REGFORCOMP" 
BC	 				! SHOULD BE USED AS THE MEMREF FIELD
BIMFNC	 	IMFN=2,			!USE THE IMPLICIT FN NAME PTED TO BY TREEPTR
BWD1IMFC	 	WD1IMF=3,		!USE THE IMPLICIT-FN NAME POINTED TO BY THE RH OF THE PATTERN WD
BRGIMFNC	 	RGIMFN=4,		!USE THE IMPLICIT-FN NAME POINTED TO BY THE RH OF
BC	 				! THE PATTERN WD INDEXED BY THE "REGFORCOMP"
BA1CNSTC	 	A1CNST=5,		!ARG1 IS IMMED CNST
BA2CNSTC	 	A2CNST=6,		!ARG2 IS IMMED CNST
BA1CNNGC	 	A1CNNG=7,		!USE NEG OF THE IMMED CNST ARG1
BA2CNNGC	 	A2CNNG=10,		!USE NEG OF THE IMMED CNST ARG2
BPTRA2C	 	PTRA2=#11,		!USE THE ARG2PTR FIELD IN THE PARENT
BNGPTR2C	 	NGPTR2=#12,		!USE THE NEG OF THE ARG2PTR FIELD OF THE PARENT
BP2PTR2C	 	P2PTR2=#13,		!USE 2**(VAL OF ARG2PTR) MINUS 1
BC	 				! (THIS IS USED FOR P2DIV)
BA1LABC	 	A1LAB=#14,		!USE THE LABEL INDICATED BY A1LABEL
BA2LABC	 	A2LAB=#15,		!USE THE LABEL INDICATED BY A2LABEL
BA3LABC	 	A3LAB=#16,		!USE THE LABEL INDICATED BY A3LABEL
BFROMC1C	 	FROMC1H=#17,		!USE THE CONTENTS OF THE GLOBAL C1H,
BC	 				! THERE IS NO SYMBOL ASSOCIATED WITH THIS ADDR FIELD
BPARTMPC	 	PARTMP=#20,		!USE THE TMP POINTED TO BY THE ADDR PART
BC	 				! OF THE TARGET WD OF THE PARENT NODE (IE THE NODE
BC	 				! POINTED TO BY TREEPTR); IGNORE THE INDIRECT BIT
BC	 				! OF THE TARGET WD
BFROMA1C	 	FROMA1=#21,		!TARGET FIELD OF ARG1 IS MEMREF FIELD
BFROMA2C	 	FROMA2=#22,		!TARGET FIELD OF ARG2
BFROMPAC	 	FROMPAR=#23;		!TARGET FIELD OF PARENT (IE NODE PTED TO BY TREEPTR)
BC	 
BC	 
BLISS  V. 1.0-2.12	13-JUN-73  13:54:19	OPMOD	TABLES.BLI		PAGE 26-1

BC	 
BC	 
BC	 %(***********************************************************************
BC	 	TO GET REG OR MEMREF OR OPERATOR FIELD FROM EITHER A TARGET WD IN AN EXPRESSION
BC	 	NODE OR A PATTERN WORD IN AN OPGENTABLE ENTRY
BC	 *****************************************************************)%
BC	 
BMACROC	 MACRO
BOPFLDWORDC	 	OPFLD(WORD) = WORD AND #777^27$,
BREGFLDWORDC	 	REGFLD(WORD) = WORD AND #17^23$,
BC	 
BMEMFLDWORDC	 	MEMFLD(WORD) = WORD AND #37777777$;
BC	 
BLISS  V. 1.0-2.12	13-JUN-73  13:54:20	OPMOD	TABLES.BLI		PAGE 27-1

BC	 
BC	 	%(****DEFINES SPECIFIC REGS USED FOR COMPILED CODE*****)%
BBINDRETREGC	 BIND RETREG=0;			!REG IN WHICH THE VAL OF A FN IS RETURNED
BBINDSTKREGC	 BIND STKREG=17;		!STACK REG FOR FNS/SUBRS
BBINDARGREGC	 BIND ARGREG=16;			!CONTAINS PTR TO ARGLIST FOR FNS/SUBRS
BC	 
BC	 
BC	 
BLISS  V. 1.0-2.12	13-JUN-73  13:54:20	OPMOD	TABLES.BLI		PAGE 28-1

BC	 
BC	 
BC	 %(*********MACROS USED FOR REGISTER ALLOCATION***********************)%
BC	 
BC	 
BC	 
BC	 %(*****TO DETERMINE WHETHER A NODE IS EVALUATED BY MEANS OF A CALL TO A LIBRARY FN,
BC	 	(IF SO THEN IF THE 2ND ARG IS A CONSTANT WILL HAVE TO ALLOCATE CORE FOR IT)***)%
BMACROUSEFNCPNODEC	 MACRO USEFNCALL(PNODE)=
BC	 BEGIN
BC	 	%(***DOUBLE-PREC OPS ON THE KA10 ARE EVALUATED BY LIBRARY FNS***)%
BC	 	IF .PNODE[VALTYPE] EQL DOUBLPREC
BC	 	THEN
BC	 	.KA10FLG
BC	 	ELSE
BC	 	%(****EXPONENTIATION IS PERFORMED BY LIBRARY FNS***)%
BC	 	(.PNODE[OPR1] EQL EXPONOPF)
BC	 END$;
BC	 
BC	 
BC	 %(****FOR REGISTER ALLOCATION - GET THE REGISTER WHICH IS TO BE THE NTH ASSIGNED.
BC	 	FOR BOTTOMMOST ROUTINES THIS WILL BE REGISTER N+2 (FIRST ASSIGNED IS 2) 
BC	 	FOR NON-BOTTOMMOST ROUTINES THIS WILL BE REGISTER 15-N (FIRST ASSIGNED IS 15).
BC	 *********)%
BMACROASNREGN1C	 MACRO ASNREG(N1)=
BC	 BEGIN
BC	 	IF .BTTMSTFNFLG
BC	 	THEN N1+2
BC	 	ELSE #15-N1
BC	 END$;
BC	 
BC	 	%(***INVERSE OF ASNREG - TO GET THE INDEX FOR A GIVEN REG***)%
BMACROINVASNREGC	 MACRO INVASNREG(REG)=
BC	 BEGIN
BC	 	IF .BTTMSTFNFLG
BC	 	THEN REG-2
BC	 	ELSE #15-REG
BC	 END$;
BC	 
BC	 
BC	 %(****GET THE INDEX FOR THE REGISTER AFTER THE REGISTER INDICATED BY THE INDEX 'IX'****)%
BMACRONXREGIXC	 MACRO NXREG(IX)=
BC	 BEGIN
BC	 	IF .BTTMSTFNFLG
BC	 	THEN IX+1
BC	 	ELSE IX-1
BC	 END$;
BC	 
BC	 
BC	 %(***GIVEN A BIT PATTERN REPRESENTING A SET OF REGS (BIT 0 THE REG OF IX 0, BIT
BC	 	1 THE REG OF IX 1, ETC), RETURN THE PATTERN REPRESENTING THE REGS FOLLOWING THESE***)%
BMACRONXREGPBITPTNC	 MACRO	NXREGPATTERN(BITPTN)=
BC	 BEGIN
BC	 	%(***FOR BOTTOMOST FNS, BIT 0  IS REG 2, BIT 1 REG 3, ETC - 
BC	 		HENCE SHOULD SHIFT THE BITS TO THE RIGHT***)%
BC	 	IF .BTTMSTFNFLG
BC	 	THEN BITPTN^(-1)
BLISS  V. 1.0-2.12	13-JUN-73  13:54:26	OPMOD	TABLES.BLI		PAGE 28-2

BC	 	ELSE
BC	 	%(***FOR NON-BOTTOMOST FNS, BIT 0 IS REG 15, BIT 1 REG 14, ETC -
BC	 		HENCE SHOULD SHIFT THE BITS TO THE LEFT***)%
BC	 	BITPTN^1
BC	 END$;
BC	 
BC	 
BC	 %(***GIVEN A BIT PATTERN REPRESENTING A SET OF REGS, RETURN THE PATTERN REPRESENTING
BC	 	THE REGS PRECEEDING EACH OF THESE***)%
BMACROPREVREBITPTNC	 MACRO	PREVREGPATTERN(BITPTN)=
BC	 BEGIN
BC	 	%(***FOR BOTTOMMOST FNS, BIT 0 IS REG 2, BIT 1 REG 3 ETC - HENCE
BC	 		SHOULD SHIFT BITS TO THE LEFT TO GET BIT FOR PREVIOUS REG***)%
BC	 	IF .BTTMSTFNFLG
BC	 	THEN BITPTN^1
BC	 	ELSE
BC	 	%(***FOR NON-BOTTOMOST FNS BIT 0 IS REG 15,BIT 1 IS REG 14 ETC- HENCE SHIFT RIGHT***)%
BC	 	BITPTN^(-1)
BC	 END$;
BC	 
BC	 %(****TO DETERMINE WHETHER THE REGISTER AFTER THE REGISTER INDICATED Y THE INDEX 'IX' IS
BC	 	FREE. BITS 0-15 OF 'BSYRS' REPRESENT REGISTERS OF INDEX 0-15.
BC	 	THE BIT FOR A REGISTER IS SET IFF THAT REG IS FREE*******)%
BMACRONXREGFBSYRSIXC	 MACRO NXREGFREE(BSYRS,IX)=
BC	 BEGIN
BC	 	EXTERNAL CLRWDS;
BC	 	REGISTER NXTREG;
BC	 	%(***GET INDEX FOR REGISTER FOLLOWING THE REG WITH INDEX IX. FOR BOTTOMOST ROUTINES
BC	 		THIS WILL BE IX+1, FOR NON-BOTTOMOST ROUTINES IT WILL BE IX-1***)%
BC	 	NXTREG_IX;
BC	 	IF .BTTMSTFNFLG
BC	 	THEN NXTREG_.NXTREG+1
BC	 	ELSE NXTREG_.NXTREG-1;
BC	 
BC	 	IF .NXTREG LSS 0
BC	 	THEN FALSE
BC	 	ELSE
BC	 	%(***CHECK WHETHER THE BIT CORRESPONDING TO NXTREG IS SET IN BSYRS***)%
BC	 	(BSYRS AND NOT .CLRWDS[.NXTREG]) NEQ 0
BC	 END$;
BC	 
BC	 
BC	 %(****TO TEST WHETHER AN OPERATION 'CLOBBERS' THE REGISTER FOLLOWING THE ONE IN
BC	 	WHICH IS IS PERFORMED.
BC	 	THIS TEST DOES NOT INCLUDE DOUBLE-PREC (OR COMPLEX) OPERATIONS,
BC	 	WHICH THE REGISTER ALLOCATOR HANDLES BY SIMPLY NEVER 
BC	 	ASSIGNING ODD REGISTERS WHEN IN "DOUBLE-WD MODE"
BC	 ********)%
BMACROCLBNXRNODEC	 MACRO CLBNXREG(NODE)=
BC	 	((.NODE[OPERATOR] EQL INTDIVIDE) OR (.NODE[OPR1] EQL MODFNFL)
BC	 	OR (.KA10FLG AND ((.NODE[OPERATOR] EQL IFIXOP) OR (.NODE[OPERATOR] EQL FLOATOP))))$;
BC	 
BC	 
BC	 %(******MACROS FOR GOING BETWEEN "DOUBLE-WD MODE" REGISTER ALLOCATION AND
BC	 	"SINGLE-WD MODE" REGISTER ALLOCATION.
BC	 	FOR DOUBLE-WORD OPERATIONS, NEVER ASSIGN ODD REGISTERS TO
BC	 	ANY COMPUTATIONS.
BLISS  V. 1.0-2.12	13-JUN-73  13:54:32	OPMOD	TABLES.BLI		PAGE 28-3

BC	 	THE "SET OF BUSY REGS" MAY NEED TO HAVE THESE TRANSFORMATIONS PERFORMED ON IT
BC	 		1. ACROSS A TYPE CONVERSION NODE (WHEN CONVERTING BETWEEN DOUBLE-WD
BC	 			AND SINGLE-WD VALUES
BC	 		2. ACROSS A RELATIONAL NODE THAT COMPARES DOUBLE-WD VALUES (BUT
BC	 			HAS A SINGLE-WD RESULT)
BC	 		3. ACROSS AN ARRAY-REF NODE FOR A DOUBLE-PREC ARRAY (THE ADDRESS ARITHMETIC 
BC	 			IS SINGLE-WD)
BC	 		4. ACROSS A BOOLEAN  WHOSE ARGS ARE DOUBLE-WD (RESULT IS ALWAYS SINGLE-WD
BC	 *************)%
BC	 
BC	 	%(******WHEN GOING DOWN FROM SINGLE-WD CALCULATIONS TO DOUBLE-WD CALCULATIONS
BC	 		THE SET OF REGISTERS THAT CANNOT BE ASSIGNED MUST
BC	 		NOW INCLUDE
BC	 			1. ANY REGISTER THAT PRECEEDS A REGISTER HOLDING A VAL TO
BC	 				BE PRESERVED (SINCE A DOUBLE-WD COMPUTATION
BC	 				ON THE PRECEEDING REG CLOBBERS THE FOLLOWING ONE)
BC	 			2. ANY ODD REGISTER.
BC	 	***********)%
BC	 
BMACRODPBSYRSPBSYRC	 	MACRO DPBSYREGS(SPBSYRS)=
BC	 	BEGIN
BC	 		IF .BTTMSTFNFLG
BC	 		THEN
BC	 		%(***FOR BOTTOMMOST ROUTINES (FOR WHICH BIT 0 IN BUSY-WD REPRESENTS REG2,
BC	 			BIT 1 IS REG 3, BIT 2 REG 4, ....******)%
BC	 		(SPBSYRS AND SPBSYRS^1) AND #525252525252
BC	 
BC	 		ELSE
BC	 		%(***FOR NON-BOTTOMMOST ROUTINES (FOR WHICH BIT 0 REPRESENTS REG 15, BIT 1 REG 14,
BC	 			BIT 2 REG 15.....******)%
BC	 		(SPBSYRS AND SPBSYRS^(-1)) AND #252525252525
BC	 	END$;
BC	 
BC	 	%(*********WHEN GOING DOWN FROM DOUBLE-WD CALCULATION TO SINGLE-WD
BC	 		CALCULATIONS.
BC	 		THE SET OF REGISTERS AVAILABLE ONCE AGAIN CAN INCLUDE
BC	 		THEN ODD REGISTERS EXCEPT FOR THOSE REGISTERS CONTAINING THE RIGHT-HALF
BC	 		OF A DOUBLE-WD RESULT WHICH WAS BEING SAVED.
BC	 	************)%
BMACROSPBSYRDPBSYRC	 	MACRO SPBSYREGS(DPBSYRS)=
BC	 	BEGIN
BC	 		IF .BTTMSTFNFLG
BC	 		THEN
BC	 		%(***FOR BOTTOMOST ROUTINES (FOR WHICH BIT 0 REPRESENTS REG 2, BIT 1 REG 3, ETC***)%
BC	 		(DPBSYRS OR #252525252525) AND ((DPBSYRS OR #252525252525)^(-1) OR #400000000000)
BC	 		ELSE
BC	 		%(***FOR NON-BOTTOMMOST ROUTINES (BIT 0 REPRESENTS REG 15, BIT 1 REG 14,ETC***)%
BC	 		(DPBSYRS OR #525252525252) AND ((DPBSYRS OR #525252525252)^1)
BC	 	END$;
BC	 
BC	 
BC	 
BC	 %(*****WHEN COMING BACK UP FROM DOUBLE-WD OPS UP TO SINGLE-WD OPS, MUST MARK BITS
BC	 	IN "CLOBBREGS"(WD INDICATING WHICH REGS WERE CLOBBERED IN CALCULATING THE VAL
BC	 	OF AN EXPRESSION) FOR THE ODD REGS FOLLOWING EACH EVEN REG USED
BC	 *******)%
BMACROSETDPCC	 MACRO SETDPCLOBB=
BLISS  V. 1.0-2.12	13-JUN-73  13:54:37	OPMOD	TABLES.BLI		PAGE 28-4

BC	 	(CLOBBREGS_.CLOBBREGS OR .CLOBBREGS^(IF .BTTMSTFNFLG THEN (-1) ELSE 1))$;
BC	 
BLISS  V. 1.0-2.12	13-JUN-73  13:54:37	OPMOD	TABLES.BLI		PAGE 29-1

BC	 
BC	 
BC	 
BC	 
BC	 
BC	 %(****TO SWAP HALVES OF A WORD IN MEMORY****)%
BMACHOPMOVSSC	 MACHOP MOVSS=#207;
BMACHOPMOVEMOVEC	 MACHOP MOVE=#200;
BMACROSWAPHAPTROFFSTC	 MACRO SWAPHALVES(PTR,OFFST) =
BC	 BEGIN
BC	 	REGISTER T1;
BC	 	MOVE (T1,PTR);
BC	 	MOVSS (0,OFFST,T1)
BC	 END$;
BC	 
BC	 
BC	 %(*****TO SWAP THE 2 ARGS UNDER AN EXPRESSION NODE**************)%
BMACROC	 MACRO
BSWAPARNODEC	 	SWAPARGS(NODE)=
BC	 	BEGIN
BC	 		SWAPHALVES(NODE,ARGWDOFFSET);
BC	 		SWAPFLGS(NODE);
BC	 	END$;
BC	 
BC	 
BC	 
BC	 
BC	 %(****TO PERFORM A BLOCK TRANSFER *******)%
BMACHOPBLTBLTC	 MACHOP BLT=#251;
BC	 
BMACROBLOCKTSRCLOCDESTINBLLNTHC	 MACRO BLOCKTR(SRCLOC,DESTIN,BLLNTH)=
BC	 BEGIN
BC	 	REGISTER T1;
BC	 	T1<LEFT>_SRCLOC;
BC	 	T1<RIGHT>_DESTIN;
BC	 	BLT(T1,(DESTIN)<0,0>+BLLNTH-1);
BC	 END$;
BC	 
BC	 
BC	 %(****TO PICK UP A HALF-WD VAL WITH SIGN EXTENDED****)%
BMACHOPHRREIC	 MACHOP HRREI=#571;
BC	 
BMACROEXTSIGVALC	 MACRO	EXTSIGN(VAL)=
BC	 BEGIN
BC	 	REGISTER AA1;
BC	 	AA1_VAL;
BC	 	HRREI(AA1,0,AA1)
BC	 END$;
BC	 
BC	 
BC	 %(***TO DO AN ARITHMETIC SHIFT BY A COMPILE TIME CONSTANT***)%
BMACHOPASHC	 MACHOP ASH=#240;
BC	 
BMACROARITHSVALBITCTC	 MACRO ARITHSHIFT(VAL,BITCT)=
BC	 BEGIN
BC	 	REGISTER T1;
BC	 	T1_VAL;
BLISS  V. 1.0-2.12	13-JUN-73  13:54:47	OPMOD	TABLES.BLI		PAGE 29-2

BC	 	ASH(T1,(BITCT AND #777777))
BC	 END$;
BC	 
BC	 
BC	 
BC	 %(****TO COUNT THE NUMBER OF BITS THAT ARE ON IN A GIVEN WORD****)%
BMACROONESCOWDC	 MACRO ONESCOUNT(WD)=
BC	 BEGIN
BC	 	REGISTER COUNT;
BC	 	REGISTER T1;
BC	 	T1_WD;
BC	 	COUNT_0;
BC	 	UNTIL .T1 EQL 0
BC	 	DO
BC	 	BEGIN
BC	 		T1_.T1 AND (NOT(-.T1));
BC	 		COUNT_.COUNT+1;
BC	 	END;
BC	 	.COUNT
BC	 END$;
BC	 
BC	 %(*******TO CLEAR A GIVEN BIT IN A GIVEN WORD (THE ARG IX INDICATES THE BIT
BC	 	TO BE CLEARED, PTN1 IS THE WORD TO CLEAR IT FROM********)%
BMACROC	 MACRO
BCLRBITPTN1IXC	 	CLRBIT(PTN1,IX)=BEGIN
BC	 				EXTERNAL CLRWDS;
BC	 				 PTN1 AND .CLRWDS[IX]
BC	 			END $;
BC	 
BC	 %(*******TO SET A GIVEN BIT IN A GIVEN WD*******)%
BMACROC	 MACRO
BSETBITPTN1IXC	 	SETBIT(PTN1,IX) =BEGIN
BC	 				EXTERNAL CLRWDS;
BC	 				 PTN1 OR NOT(.CLRWDS[IX])
BC	 			END $;
BC	 
BC	 %(****TO TEST A GIVEN BIT OF A GIVEN WD***********)%
BMACROC	 MACRO
BBITSETPTN1IXC	 	BITSET(PTN1,IX)=BEGIN
BC	 				EXTERNAL CLRWDS;
BC	 				 ((IX GEQ 0) AND (PTN1 AND NOT(.CLRWDS[IX])) NEQ 0)
BC	 			END$;
BC	 
BC	 
BC	 
BC	 
BC	 
BC	 %(*****TO MAKE AN ENTRY IN THE CONSTANT TABLE - SET UP GLOBALS FOR
BC	 	TBLSEARCH AND CALL IT ****************)%
BC	 
BMACROMAKECNTYPECNHCNLC	 MACRO MAKECNST(TYPE,CNH,CNL) =
BC	 BEGIN
BC	 	EXTERNAL TBLSEARCH;
BC	 	NAME_CONTAB;
BC	 	ENTRY[0]_CNH;
BC	 	ENTRY[1]_CNL;
BC	 	SYMTYPE_TYPE;
BLISS  V. 1.0-2.12	13-JUN-73  13:54:50	OPMOD	TABLES.BLI		PAGE 29-3

BC	 	TBLSEARCH()
BC	 END$;
BC	 
BC	 %(**********TO MAKE A CONSTANT TABLE ENTRY FOR THE NEGATIVE OR THE
BC	 		COMPLEMENT("NOT") OF SOME OTHER CONSTANT TABLE ENTRY*****)%
BC	 
BMACRONEGCNSCNNODEC	 MACRO NEGCNST(CNNODE)=
BC	 	BEGIN
BC	 		IF .CNNODE[VALTYPE] EQL  DOUBLPREC OR .CNNODE[VALTYPE] EQL REAL
BC	 		THEN
BC	 		%(***FOR DOUBLE-PREC NEG - USE ASSEMBLY LANG ROUTINE**)%
BC	 		BEGIN
BC	 			EXTERNAL C1H,C1L,C2H,C2L,COPRIX,KDNEGB,CNSTCM;
BC	 			C1H_.CNNODE[CONST1];
BC	 			C1L_.CNNODE[CONST2];
BC	 			COPRIX_KDNEGB+.CKA10FLG;
BC	 			CNSTCM();
BC	 			MAKECNST(.CNNODE[VALTYPE],.C2H,.C2L)
BC	 		END
BC	 		ELSE
BC	 		 MAKECNST(.CNNODE[VALTYPE], -.CNNODE[CONST1], -.CNNODE[CONST2])
BC	 	END$;
BC	 
BMACRONOTCNSCNNODEC	 MACRO NOTCNST(CNNODE)= MAKECNST(.CNNODE[VALTYPE], NOT .CNNODE[CONST1], NOT .CNNODE[CONST2])$;
BC	 
BC	 %(****TO MAKE CONSTANT TABLE ENTRY FOR NOT(-X) - "NTNGCNST"
BC	 	OR -(NOT X) - "NGNTCNST"*********)%
BMACRONTNGCNCNNODEC	 MACRO NTNGCNST(CNNODE)=
BC	 	BEGIN
BC	 		IF .CNNODE[VALTYPE] EQL DOUBLPREC OR .CNNODE[VALTYPE] EQL REAL
BC	 		THEN
BC	 		%(***FOR DOUBLE-PREC USE ASSEMBLY LANG ROUTINE TO GET NEG**)%
BC	 		BEGIN
BC	 			%(***DNEGCNST GETS ITS ARG IN THE GLOBALS C1H,C1L***)%
BC	 			C1H_ .CNNODE[CONST1];
BC	 			C1L_.CNNODE[CONST2];
BC	 			COPRIX_KDNEGB+.CKA10FLG;
BC	 			CNSTCM();
BC	 			MAKECNST(.CNNODE[VALTYPE],NOT .C1H, NOT .C1L)
BC	 		END
BC	 		ELSE
BC	 		MAKECNST(.CNNODE[VALTYPE], NOT (-.CNNODE[CONST1]), NOT (-.CNNODE[CONST2]))
BC	 	END$;
BC	 
BMACRONGNTCNCNNODEC	 MACRO NGNTCNST(CNNODE)=
BC	 	BEGIN
BC	 		IF .CNNODE[VALTYPE] EQL DOUBLPREC OR .CNNODE[VALTYPE] EQL REAL
BC	 		THEN
BC	 		BEGIN
BC	 			%(***DNEGCNST GETS ITS ARG IN THE GLOBALS C1H,C1L***)%
BC	 			C1H_NOT .CNNODE[CONST1];
BC	 			C1L_NOT .CNNODE[CONST2];
BC	 			COPRIX_KDNEGB+.CKA10FLG;
BC	 			CNSTCM();
BC	 			MAKECNST(.CNNODE[VALTYPE],.C1H,.C1L)
BC	 		END
BC	 		ELSE
BLISS  V. 1.0-2.12	13-JUN-73  13:54:53	OPMOD	TABLES.BLI		PAGE 29-4

BC	 		MAKECNST(.CNNODE[VALTYPE],-(NOT .CNNODE[CONST1]), -(NOT .CNNODE[CONST2]))
BC	 	END$;
BC	 
BLISS  V. 1.0-2.12	13-JUN-73  13:54:53	OPMOD	TABLES.BLI		PAGE 30-1

BC	 
BC	 
BC	 %(******************************
BC	 	MACROES TO FORM INDICES  INTO THE TABLE FOR CONSTANT FOLDING
BC	 ********************************)%
BC	 
BC	 	%(***TO FOLD BOOLEAN OPERATIONS***)%
BMACROKBOOLOPNODEC	 MACRO	KBOOLOPIX(PNODE)=
BC	 	(.PNODE[OPERSP] + KBOOLBASE)$;
BC	 
BC	 	%(***TO FOLD ARITHMETIC OPERATIONS****)%
BMACROKARITHPNODEC	 MACRO	KARITHOPIX(PNODE)=
BC	 	(.PNODE[OPRSP2]^2 + .PNODE[VALTP1] + (IF .CKA10FLG THEN KARIAB  ELSE KARIIB) )$;
BC	 
BC	 	%(*******TO FOLD AN ARITH OP, WHEN NO EXPRESSION NODE WAS BUILT (VLTP IS THE VALTP1 FIELD)***)%
BMACROKKARITVLTPOPSPC	 MACRO	KKARITHOP(VLTP,OPSP)=
BC	 	(OPSP^2 + VLTP + (IF .CKA10FLG THEN KARIAB ELSE KARIIB))$;
BC	 
BC	 
BC	 	%(****TO CONVERT A CONSTANT OF ONE VALUE TYPE TO ANOTHER****)%
BMACROKTPCNVTPCNODC	 MACRO KTPCNVIX(TPCNODE)=
BC	 	(.TPCNODE[OPERSP]^3 + .TPCNODE[VALTP2] +KTYPCB)$;
BC	 
BC	 
BC	 	%(****TO CONVERT A CONSTANT FROM ONE VALTYPE TO ANOTHER WHEN NO EXPRESSION
BC	 		NODE WAS BUILT FOR THE TYPE CONVERSION. (VLTP IS THE VALTP2 FIELD)***)%
BMACROKKTPCNVLTPOPSPC	 MACRO	KKTPCNVIX(VLTP,OPSP)=
BC	 	(OPSP^3 + VLTP + KTYPCB)$;
BC	 
BC	 
BC	 	%(***TO FOLD SPECIAL OPERATORS (P2MUL,P2DIV)  - USED ONLY BY PHASE 2***)%
BMACROKSPECOPNODEC	 MACRO	KSPECOPIX(PNODE)=
BC	 	(.PNODE[OPERSP]^2 + .PNODE[VALTP1] + KSPECB)$;
BC	 
BC	 
BC	 	%(***TO FOLD IN-LINE FNS********)%
BMACROKILFOPPNODEC	 MACRO	KILFOPIX(PNODE)=
BC	 	(.PNODE[OPERSP] + (IF .PNODE[VALTP1] EQL INTEG1 THEN KILFBA ELSE KILFBR))$;
BLISS  V. 1.0-2.12	13-JUN-73  13:54:54	OPMOD	TABLES.BLI		PAGE 31-1

BC	 
BC	 	%(*****FOR CNODE ARITHMETIC OR BOOLEAN
BC	 		CHECK TO SEE IF A SKEWED TREE IS AN NARYNODE*****)%
BC	 
BMACRONARYNOCNODEAR1NODC	 	MACRO NARYNODE(CNODE,AR1NODE)=
BC	 	(.CNODE[OPR1] EQL .AR1NODE[OPR1]
BC	 	AND
BC	 	.CNODE[OPR1] LSS DIVOPF
BC	 	AND
BC	 	NOT .CNODE[A1NEGFLG] AND NOT .CNODE[A1NOTFLG]
BC	 	AND
BC	 	NOT .AR1NODE[PARENFLG])$;
BC	 
BC	 
BLISS  V. 1.0-2.12	13-JUN-73  13:54:56	OPMOD	TABLES.BLI		PAGE 32-1

BC	 
BC	 
BC	 %(***************************************************************************
BC	 	TO GET CORE TO BUILD A NODE OF A CERTAIN TYPE.
BC	 	AT PRESENT  CALL CORMAN WITH NAME<LEFT> EQUAL TO THE SIZE
BC	 	NEEDED (SRM - AUG 18,1972)
BC	 ***************************************************************************)%
BC	 
BMACROGETCORNDSIZNDTYPC	 MACRO	GETCORE(NDSIZ,NDTYP)=
BC	 BEGIN
BC	 	NAME<LEFT>_NDSIZ;
BC	 	CORMAN()
BC	 END$;
BC	 
BC	 	%(***NODE SIZES****)%
BBINDIOLCSIC	 BIND	IOLCSIZ=3;	!FOR AN IOLISTCALL NODE
BC	 
BC	 	%(***NODE TYPE CODES***)%
BBINDIOLCCDC	 BIND	IOLCCD=1;	!FOR AN IOLISTCALL NODE
BLISS  V. 1.0-2.12	13-JUN-73  13:54:56	OPMOD	TABLES.BLI		PAGE 33-1

BC	 
BC	 %(***************************************************************************
BC	 	MACROS USED FOR CONSISTENCY CHECKING - FOR DEBUGGING THE COMPILER
BC	 ***************************************************************************)%
BC	 
BC	 
BC	 %(***TO CHECK WHETHER ARE WALKING DOWN ONTO A LEGAL NODE***)%
BMACRODEBGNONODEC	 MACRO DEBGNODETST(NODE)=
BC	 BEGIN
BC	 	EXTERNAL NODERR;
BC	 	IF DEBUGFLG			!A COMPILE TIME CONSTANT 
BC	 	THEN
BC	 	BEGIN
BC	 		IF .NODE EQL 0
BC	 		THEN NODERR();
BC	 	END;
BC	 END$;
BC	 
BC	 
BLISS  V. 1.0-2.12	13-JUN-73  13:54:57	OPMOD	TABLES.BLI		PAGE 34-1

BC	 
BC	 
BC	 !MACROS FOR THE FLAGS ASSOCIATED WITH A DO LOOP
BC	 
BC	 
BC	 %******
BC	 	FLAGS ASSOCIATED WITH A DO LOOP FOR CODE GENERATION
BC	 	INNERDOFLG=0,1,35,1				!FLAG SET BY PHASE 1 ON INNER DO LOOP
BC	 *****%
BMACROC	 	MACRO
BFLCWDC	 		FLCWD=0,1,34,1$,			!FULL CONST WORD INITIAL VALUE AND
BC	 							!LOOP CONTROL
BC	 							!SET IN DOXPND OR BY THE OPTIMIZER
BSSIZONC	 		SSIZONE=0,1,33,1$,			!STEP SIZE ONE
BC	 							!SET IN DOXPND OR BY OPTIMIZER
BSSIZIMC	 		SSIZIMMED=0,1,32,1$,			!STEP SIZE IS AN IMMEDIATE CONSTANT (INTEGER)#1
BINITLIC	 		INITLIMMED=0,1,31,1$,			!INITIAL VALUE IS IMMEDIATE
BC	 							!SET IN DOXPN OR OPTIMIZER
BREALARC	 		REALARITH=0,1,30,1$,			!DO SYMBOL IS REAL SO ALL ARITHMETIC MUST BE
BC	 							!REAL
BINITLTC	 		INITLTMP=0,1,29,1$,			!INITL VALUE NEEDS COMPUTATION
BSSIZINC	 		SSIZINTMP=0,1,28,1$,			!STEP SIZE IN A TEMP
BIVARINC	 		IVARINREG=0,1,27,1$,			!DO INDUCTION VARIABLE IS IN A REGISTER
BC	 							!SET BY OPTIMIZER
BNEDSMAC	 		NEDSMATRLZ =0,1,26,1$,			!LOOPHAS EXIT
BCTLSAMC	 		CTLSAMEFLG=0,1,25,1$,			!CONTROL EXPR WAS COMPUTED INTO
BC	 							! THE REG IN WHICH IT WILL
BC	 							! BE USED
BNOFLCWC	 		NOFLCWDREG=0,1,23,1$,			!IF THE DO INDEX OF THIS LOOP
BC	 							! IS NOT MATERIALIZED, THEN
BC	 							! AOBJN SHOULD NOT BE USED FOR
BC	 							! THE LOOP
BSSIZNEC	 		SSIZNEGFLG=0,1,22,1$,			!STEP SIZE IS A NAGATIVE INTEGER IMMED
BC	 							! CONSTANT AND HENCE MUST BE NEGATED
BC	 							! WHEN IT IS PICKED UP (IE
BC	 							! AT LOOP END MUST DO SUBI RATHER
BC	 							! THAN ADDI)
BDOREMOC	 		DOREMOVED=0,1,21,1$,			!OPTIMIZER HAS DELETED DO LOOP
BCTLNEGC	 		CTLNEG=0,1,20,1$,			!CTL VAL MUST BE NEGATED WHEN IT IS
BC	 							! PICKED UP (THIS IS ALWAYS SET IF CTL
BC	 							! VAL IS A CONSTANT BUT NOT FLCWD
BCTLIMMC	 		CTLIMMED=0,1,19,1$,			!CTL VAL IS AN IMMED CONST
BINITLNC	 		INITLNEG=0,1,18,1$;			!INITL VALUE MUST BE NEGATED WHEN
BC	 							! IT IS PICKED UP
BC	 
BC	 %*****
BC	 	TO ACCESS RIGHT AND LEFT HALVES OF A WORD THROUGH A
BC	 	CASE,WD,POS,SIZ STRUCTURE.
BC	 	USED ON DOSP AND SNDOLNK LIST
BC	 *****%
BC	 
BMACROC	 MACRO
BRIGHTPC	 	RIGHTP = 0,0,RIGHT$,
BLEFTPC	 	LEFTP =0,0,LEFT$;
BC	 
BC	 %*****
BC	 	MACROS TO PICK UP COMBINATIONS OF THE FLAGS
BLISS  V. 1.0-2.12	13-JUN-73  13:55:04	OPMOD	TABLES.BLI		PAGE 34-2

BC	 *****%
BC	 
BMACROC	 MACRO
BDOFLGSC	 	DOFLGS = 0,1,28,7$,		!ALL INDEX USED FLAGS
BOTHDOFC	 	OTHDOFLGS=0,1,27,8$;		!ALL THE FLAGS EXCEPT INNERDO AND FLCWD
BC	 !******
BC	 !	FIELDS IN DOWDP USED TO DETERMINE
BC	 !	IF IT IS VALID TO KEEP THE DO INDEX VARIABLE IN A 
BC	 !	REGISTER THROUGHOUT THE LOOP
BC	 !*****
BC	 
BMACROC	 	MACRO
BDOISUBC	 		DOISUBS=0,35,1$,
BDONOAOC	 		DONOAOBJN=0,34,1$,	!FLAG FOR "DONT USE AOBJN FOR THIS LOOP
BC	 					! IF VAL OF INDEX IS NOT MATERIALIZED
BDOINDUC	 		DOINDUC=0,0,18$,
BDOREGPC	 		DOREGPTR=0,18,17$;
BC	 
BC	 !COPYRIGHT 1972,DIGITAL EQUIPMENT CORP., MAYNARD, MASS.
BC	 !AUTHOR: F. INFANTE
BGLOBALBINDOPMOVC	 GLOBAL BIND OPMOV=27;	!VERSION DATE:29-MAR-73
BEXTERNRDATWDLSTOUTERROUTRELDATRELBLOHILOCRELOCWRELOUTC	 EXTERNAL RDATWD,LSTOUT,ERROUT,RELDATA,RELBLOCK,HILOC,RELOCWD,RELOUT;
BFORWARALLFORPROCCOPROCEQRADIX5ZOUTBLC	 FORWARD ALLFORM,PROCCOM,PROCEQUIV,RADIX50,ZOUTBLOCK;
BEXTERNRELOCPC	 EXTERNAL RELOCPTR;
BC	 
BMACRORCODEC	 MACRO	RCODE = 1$,	!CODE AND DATA BLOCK
BRSYMBOC	 	RSYMBOL = 2$,	!SYMBOL BLOCK
BRGLOBDC	 		RGLOBDEF = 4^30$,	!GLOBAL DEF IN RSYMBOL
BRLOCDEC	 		RLOCDEF = #10^30$,	!LOCAL DEF IN RSYMBOL
BRLOCREC	 		RLOCREQ = #10^30$,	!LOCAL REQUEST IN RSYMBOL
BRGLOBRC	 		RGLOBREQ = #60^30$,	!GLOBAL REQUEST
BRGLOB0C	 		RGLOB0 = 0$,	!CHAINED GLOBAL REQUEST
BRGLOB4C	 		RGLOB4 = 400000$,	!ADDITIVE GLOBAL IN RSYMBOL
BRHISEGC	 	RHISEG = 3$,	!HISEG BLOCK
BRENTRYC	 	RENTRY = 4$,	!ENTRY BLOCK
BRENDC	 	REND =   5$,	!END BLOCK
BRNAMEC	 	RNAME  = 6$,	!NAME BLOCK
BRADDREC	 	RADDRESS = 7$,	!ADDRESS BLOCK
BRLOCALC	 	RLOCAL = #10$,	!LOCAL BLOCK
BRELNC	 	RELN =  0$,	!NO RELOCATION BITS
BRELRIC	 	RELRI = 1$,	!RELOCATE RIGHT
BRELLC	 	RELL = 2$,	!RELOCATE LEFT
BRELBC	 	RELB = 3$;	!RELOCATE BOTH HALVES
BMACRORBLOKTC	 MACRO RBLOKTYPE = RELBLOCK[0]<LEFT>$,
BRDATCOC	 	RDATCOUNT = RELBLOCK[0]<RIGHT>$,
BRRELOCC	 	RRELOC = RELBLOCK[1]$,
BRDATAIC	 	RDATA(I) = (RELBLOCK+2)[I]$,
BRBLKSIC	 	RBLKSIZ = #22$,	!SIZE OF REL DATA BLOCK
BZDATCNC	 	ZDATCNT = RELDATA<RIGHT>$,	!CURRENT COUNT OF DATA WORDS MAX IS 18
BCBLKC	 	CBLK = RELDATA<LEFT>$;	!CURRENT BLOCK TYPE
BC	 
BC	 
BC	 
BC	 %(*** SET UP THE TYMSHARE DEBUGGER LOADER TYPE INFORMATION.
BC	        THIS BLOCK TYPE, AND STRUCTURE DEFINITIONS ARE FOR
BC	         THE SUPER FORTRAN LOADER, AND DEBUGGER.
BC	 
BLISS  V. 1.0-2.12	13-JUN-73  13:55:09	OPMOD	OUTMO1.BLI		PAGE 34-3

BC	 WORD 0:         FLAGS   TYPE    LENGTH
BC	 WORD 1:         #DIMS   .....BASE.....
BC	 WORD 3:         .........NAME.........
BC	 ...........................................ARRAY INFO
BC	 WORD 4:         SIZE...........OFFSET
BC	 WORD 5:         M1............M2
BC	 WORD 6:         M3...........ETC.
BC	 WORD N:
BC	 
BC	 ***************************************************************)%
BC	 
BC	 
BMACRORDEBC	 MACRO           RDEB = #30$,            !DEBUGGER BLOCK TYPE 
BSTTYPEC	                 STTYPE  =  6,6$,        !VAR/ARRAY TYPE
BSTLNGHC	                 STLNGH  =  6,0$,       !LENGTH OF THIS ENTRY
BDIMSC	                 DIMS  =  18,18$,        ! # DIMS
BARBASEC	                 ARBASE  =  0,18$,       !BASE ADDRESS FOR ARRAY
BARSIZC	                 ARSIZ  =  18,18$,       !# WRDS IN ARRAY
BAROFFC	                 AROFF  =  0,18$,        ! ARRAY OFFSET
BC	 
BSTVARC	                 STVAR =  35,1$,         !VAR OR ARRAY DEFINITION
BC	                 
BSTCOMC	                 STCOM  =  34,1$,        !COMMON BLOCK INFO
BC	 
BC	 !       NOT USED        33,1$,
BC	 !       NOT USED        32,1$,
BC	 !       NOT USED        31,1$,
BC	 
BSTFUNC	                 STFUN  =  30,1$,        !FUNCTION DEF OR REF
BC	 
BSTSUBRC	                 STSUBR  =  29,1$,       !SUBROUTINE REFERENCE
BC	 
BSTSUBDC	                 STSUBD  =  28,1$,       !SUBROUTINE DEFINITION
BC	 
BC	 !       NOT USED        27,1$,
BC	 !       NOT USED        26,1$,
BC	 !       NOT USED        25,1$,
BC	 !       NOT USED        24,1$,
BC	 !       NOT USED        23,1$,
BC	 
BSTDUMC	                 STDUM  =  22,1$,        !SUBROUTINE DUMMY PARAMETER
BC	         
BSTADJC	                 STADJ  =  21,1$,        !DUMMY ARRAY HAS ADJ DIM
BC	         
BSTLIBC	                 STLIB  =  20,1$,      !REF IS TO A LIBRARY FUNCTION
BC	 
BSTARYC	                 STARY  =  19,1$,        !ARRAY DEFINITION
BC	 
BSTLONGC	                 STLONG  =  18,1$;      !NAME > 6 CHARACTERS
BC	 
BC	 %(*****************************************************************)%
BC	 
BC	 
BC	 
BROUTINCRLFBLISS  V. 1.0-2.12	13-JUN-73  13:55:37	OPMOD	OUTMO1.BLI		PAGE 35-1

C	 ROUTINE CRLF=	!OUTPUT CR/LF TO LISTING DEVICE
BBEGINC	 BEGIN
BEXTERNLSTOUTLSTOUTC	 	EXTERNAL LSTOUT;
BCHRLSTOUTCHRLSTOUTC	 	CHR_#15;LSTOUT();CHR_#12;LSTOUT()
BENDC	 END;
BROUTIND

  2870	0000		MOVEI	03,15
	0001		PUSHJ	$S,LSTOUT			;EXTERNAL
	0002		MOVEI	03,12
  2871	0003		PUSHJ	$S,LSTOUT			;EXTERNAL
  2872	0004		POPJ	$S,0


BDATAOUZBLKTYRELBITBLISS  V. 1.0-2.12	13-JUN-73  13:55:41	OPMOD	OUTMO1.BLI		PAGE 36-1

C	 ROUTINE DATAOUT(ZBLKTYPE,RELBITS)=
BBEGINC	 BEGIN
BC	 %
BC	 ROUTINE BUILDS RELOCATABLE BINARY BLOCKS FOR DATA INITIALIZATION
BC	 %
BEXTERNZDMPBLC	 EXTERNAL ZDMPBLK;
BIFZDATCNRELDATRIGHTEQLRBLKSITHENZDMPBLC	 	IF .ZDATCNT EQL RBLKSIZ-2 THEN ZDMPBLK();
BIFZBLKTYNEQCBLKRELDATLEFTTHENZDMPBLCBLKRELDATLEFTZBLKTYC	 	IF .ZBLKTYPE NEQ .CBLK THEN (ZDMPBLK(); CBLK _ .ZBLKTYPE;);
BREPLACRELOCPRELBITC	 	REPLACEI(RELOCPTR,.RELBITS);
BRDATARELBLOZDATCNRELDATRIGHTRDATWDC	 	RDATA(.ZDATCNT) _ .RDATWD;
BRELDATRELDATC	 	RELDATA _ .RELDATA + 1;
BENDC	 END;	!OF DATAOUT
BGLOBALD

	0000		JSP	07,.ENT.0			;EXTERNAL
  2878	0001		HRRZ	04,RELDATA			;EXTERNAL
	0002		CAIN	04,20
	0003		PUSHJ	$S,ZDMPBLK			;EXTERNAL
  2879	0004		HLRZ	06,RELDATA			;EXTERNAL
	0005		CAMN	06,-3($F)			;FORMAL
	0006		JRST	00,L32114
	0007		PUSHJ	$S,ZDMPBLK			;EXTERNAL
	0010		MOVE	04,-3($F)			;FORMAL
	0011		HRLM	04,RELDATA			;EXTERNAL
  2880	0012	L32114:	MOVE	04,-2($F)			;FORMAL
	0013		IDPB	04,RELOCPTR			;EXTERNAL
  2882	0014		HRRZ	05,RELDATA			;EXTERNAL
	0015		MOVE	06,RDATWD			;EXTERNAL
	0016		MOVEM	06,RELBLOCK+2(05)		;EXTERNAL
  2883	0017		AOS	07,RELDATA			;EXTERNAL
	0020		SETZ	$V,0
  2884	0021		JRST	00,.EXT.0			;EXTERNAL


BROUTINOUTDATSYMADDSYMVALSYMPTC	 GLOBAL ROUTINE OUTDATA(SYMADDR,SYMVALUE,SYMPT)=
BBEGINC	 BEGIN
BC	 %
BC	 ROUTINE INSTRUCTS LOADER ABOUT INITIALIZATION OF LOW SEG DATA AS SPECIFIED
BC	 IN DATA STATEMENTS.  SYMPT IS PTR TO SYMBOL BEING INITIALIZED.
BC	 SYMVALUE IS VALUE TO USE IN ITIALIZATION. SYMADDR IS THE ALLOCATED
BC	 ADDRESS OF THE SYMBOL
BC	 %
BEXTERNZDMPBLC	 EXTERNAL ZDMPBLK;
BMAPBASER2R2SYMPTC	 MAP BASE R2:SYMPT;
BBINDRDATBLC	 BIND RDATBLK = #21;	!LOADER BLOCK TYPE FOR DATA FIXUP
BIFSYMPTIDATTRINCOMC	 	IF .SYMPT[IDATTRIBUT(INCOM)]
BTHENBEGINC	 	THEN BEGIN	!DO SPECIAL BLOCK 1 FIXUP
BIFZDATCNRELDATRIGHTGTRRBLKSITHENZDMPBLC	 		IF .ZDATCNT GTR RBLKSIZ-5 THEN ZDMPBLK();	!NO ROOM LEFT IN BUFFER FOR NEXT 3 WORDS
BR2SYMPTIDCOMMCW4LLEFTC	 		R2 _ .SYMPT[IDCOMMON]; !PTR TO COMMON BLOCK NODE
BR2R2COMNAMCW1FULLC	 		R2 _ .R2[COMNAME];
BRDATWDRGLOBRRADIX5C	 		RDATWD _ RGLOBREQ + RADIX50();
BDATAOURDATBLRELNC	 		DATAOUT(RDATBLK,RELN);
BRDATWDSYMADDRIGHTC	 		RDATWD _ (1^18) + .SYMADDR<RIGHT>;
BDATAOURDATBLRELNC	 		DATAOUT(RDATBLK,RELN);
BRDATWDSYMVALC	 		RDATWD _ .SYMVALUE;
BDATAOURDATBLRELNC	 		DATAOUT(RDATBLK,RELN);
BENDC	 	     END
BLISS  V. 1.0-2.12	13-JUN-73  13:56:24	OPMOD	OUTMO1.BLI		PAGE 36-2

BELSEBEGINC	 	ELSE BEGIN
BIFZDATCNRELDATRIGHTGTRRBLKSITHENZDMPBLC	 		IF .ZDATCNT GTR RBLKSIZ-4 THEN ZDMPBLK(); !NO ROOM LEFT IN BUFFER FOR 2 WORDS
BRDATWDSYMADDRIGHTC	 		RDATWD _ (1^18)+.SYMADDR<RIGHT>;
BDATAOURDATBLRELRIC	 		DATAOUT(RDATBLK,RELRI);
BRDATWDSYMVALC	 		RDATWD _ .SYMVALUE;
BDATAOURDATBLRELNC	 		DATAOUT(RDATBLK,RELN);
BENDC	 	     END;
BENDC	 END;	!OF OUTDATA
BROUTIND

	0000		JSP	07,.ENT.0			;EXTERNAL
  2896	0001		MOVE	$V,-2($F)			;FORMAL
	0002		MOVE	04,1($V)
	0003		TLNN	04,400
	0004		JRST	00,L32544
  2897	0005		HRRZ	05,RELDATA			;EXTERNAL
	0006		CAILE	05,15
	0007		PUSHJ	$S,ZDMPBLK			;EXTERNAL
  2898	0010		MOVE	$V,-2($F)			;FORMAL
  2899	0011		HLRZ	02,4($V)
  2900	0012		MOVE	02,1(02)
	0013		PUSHJ	$S,RADIX50
  2901	0014		ADD	$V,[600000,,000000]
	0015		MOVEM	$V,RDATWD			;EXTERNAL
	0016		PUSH	$S,[21]
	0017		PUSH	$S,[0]
	0020		PUSHJ	$S,DATAOUT
	0021		SUB	$S,[000002,,000002]
  2902	0022		HRRZ	07,-4($F)			;FORMAL
	0023		ADD	07,[000001,,000000]
	0024		MOVEM	07,RDATWD			;EXTERNAL
	0025		PUSH	$S,[21]
	0026		PUSH	$S,[0]
	0027		JRST	00,L32656
  2906	0030	L32544:	HRRZ	05,RELDATA			;EXTERNAL
	0031		CAILE	05,16
	0032		PUSHJ	$S,ZDMPBLK			;EXTERNAL
  2910	0033		HRRZ	07,-4($F)			;FORMAL
	0034		ADD	07,[000001,,000000]
	0035		MOVEM	07,RDATWD			;EXTERNAL
	0036		PUSH	$S,[21]
	0037		PUSH	$S,[1]
	0040	L32656:	PUSHJ	$S,DATAOUT
	0041		SUB	$S,[000002,,000002]
  2911	0042		MOVE	04,-3($F)			;FORMAL
	0043		MOVEM	04,RDATWD			;EXTERNAL
	0044		PUSH	$S,[21]
	0045		PUSH	$S,[0]
	0046		PUSHJ	$S,DATAOUT
	0047		SUB	$S,[000002,,000002]
  2913	0050		SETZ	$V,0
  2915	0051		JRST	00,.EXT.0			;EXTERNAL


BROUIMFFUNCPTFUNAMEC	 ROUTINE ROUIMFUN(FUNCPTR,FUNAME)=	!OUTPUT FUNCTION REQUEST GLOBAL
BBEGINC	 BEGIN
BRDATWDFUNCPTLEFTZOUTBLRCODERELNC	 			RDATWD_.FUNCPTR<LEFT>^18; ZOUTBLOCK(RCODE,RELN);
BLISS  V. 1.0-2.12	13-JUN-73  13:56:31	OPMOD	OUTMO1.BLI		PAGE 36-3

BR2FUNAMEC	 			R2 _ .FUNAME; !SIXBIT SYMBOL NAME
BRDATWDRGLOBRRADIX5ZOUTBLRSYMBORELNC	 			RDATWD_(RGLOBREQ +RADIX50()); ZOUTBLOCK(RSYMBOL,RELN);
BRDATWDRGLOB0HILOCC	 			RDATWD_RGLOB0^18 + .HILOC;
BZOUTBLRSYMBORELRIC	 			ZOUTBLOCK(RSYMBOL,RELRI)
BENDC	 END;
BROUTIND

	0000		JSP	07,.ENT.0			;EXTERNAL
  2917	0001		HLRZ	04,-3($F)			;FORMAL
	0002		HRLZ	05,4
	0003		MOVEM	05,RDATWD			;EXTERNAL
	0004		PUSH	$S,[1]
	0005		PUSH	$S,[0]
	0006		PUSHJ	$S,ZOUTBLOCK
	0007		SUB	$S,[000002,,000002]
  2918	0010		MOVE	02,-2($F)			;FORMAL
	0011		PUSHJ	$S,RADIX50
	0012		ADD	$V,[600000,,000000]
	0013		MOVEM	$V,RDATWD			;EXTERNAL
	0014		PUSH	$S,[2]
	0015		PUSH	$S,[0]
	0016		PUSHJ	$S,ZOUTBLOCK
	0017		SUB	$S,[000002,,000002]
  2920	0020		MOVE	06,HILOC			;EXTERNAL
	0021		MOVEM	06,RDATWD			;EXTERNAL
	0022		PUSH	$S,[2]
  2922	0023		PUSH	$S,[1]
	0024		PUSHJ	$S,ZOUTBLOCK
	0025		SUB	$S,[000002,,000002]
  2923	0026		JRST	00,.EXT.0			;EXTERNAL


BZOUTSYC	 ROUTINE ZOUTSYM=
BC	 !R2 CONTAINS SYMBOL IN SIXBIT TO BE LISTED
BDECRIFROMTOIDOC	 DECR I FROM 5 TO 0 DO
BBEGINC	 BEGIN
BR1LSHCR1C	 	R1 _ 0; LSHC(R1,6);
BIFR1GTRC	 	IF .R1 GTR 0
BTHENCHRR1LSTOUTC	 	  THEN (CHR _ .R1+#40; LSTOUT())
BELSERETURNC	 	  ELSE RETURN
BENDC	 END;
BGLOBALD

	0000		JSP	07,.ENT.1			;EXTERNAL
	0001		MOVEI	13,5
  2926	0002	L32660:	SETZ	01,0
	0003		LSHC	01,6
  2928	0004		JUMPLE	01,L32146
	0005		MOVE	03,1
	0006		ADDI	03,40
	0007		PUSHJ	$S,LSTOUT			;EXTERNAL
  2930	0010		JRST	00,L32402
	0011	L32146:	SETZ	$V,0
	0012		JRST	00,L32516
  2932	0013	L32402:	SOJGE	13,L32660  ^^^
	0014		SETO	$V,0
	0015	L32516:	JRST	00,.EXT.1			;EXTERNAL
BLISS  V. 1.0-2.12	13-JUN-73  13:56:38	OPMOD	OUTMO1.BLI		PAGE 36-4



BROUTINZOUTMSPTRC	 GLOBAL ROUTINE ZOUTMSG(PTR)=
BBEGINC	 BEGIN
BPTRPTRC	 	PTR_(.PTR-1)<0,7>;
BUNTILCHRSCANIPTREQLDOLSTOUTC	 	UNTIL (CHR_SCANI(PTR)) EQL 0 DO LSTOUT();
BENDC	 END;
BROUTIND

	0000		JSP	07,.ENT.0			;EXTERNAL
  2935	0001		MOVE	04,-2($F)			;FORMAL
	0002		HRRZI	05,-1(04)
	0003		HRLI	05,700
	0004		MOVEM	05,-2($F)			;FORMAL
	0005	L32416:	ILDB	06,-2($F)			;FORMAL
	0006		MOVE	03,6
	0007		JUMPE	03,L32266
	0010		PUSHJ	$S,LSTOUT			;EXTERNAL
  2936	0011		JRST	00,L32416  ^^^
  2937	0012	L32266:	SETZ	$V,0
	0013		JRST	00,.EXT.0			;EXTERNAL


BZOUTOCC	 ROUTINE ZOUTOCT=	!LIST OCTAL HALF WORD OR FULL WORD
BC	 			!R2<LEFT> CONTAINS HALF WORD OCTAL VALUE
BBEGINC	 BEGIN
BREGISTIC	 	REGISTER I;
BR1IC	 	R1 _ 0; I _ 6;
BDOLSHCR1IIIFIEQLTHENEXITLOWHILER1EQLC	 	DO (LSHC(R1,3); I_ .I-1; IF .I EQL 0 THEN EXITLOOP;) WHILE .R1 EQL 0;
BDOCHRR1LSTOUTC	 	DO ( CHR_#60[.R1]<0,0>; LSTOUT();
BR1LSHCR1C	 		R1 _ 0; LSHC(R1,3);
BWHILEIIGEQC	 	   ) WHILE (I_.I-1) GEQ 0;
BVREGC	 	.VREG
BENDC	 END; !OF ZOUTOCT
BROUTIND

	0000		JSP	07,.ENT.1			;EXTERNAL
  2941	0001		SETZ	01,0
  2942	0002		MOVEI	13,6
	0003	L32154:	LSHC	01,3
	0004		SOJ	13,0
	0005		JUMPN	13,L33344
	0006		JRST	00,L32522
	0007	L33344:	JUMPE	01,L32154  ^^^
	0010	L32522:	HRRZI	06,60(01)
	0011		MOVE	03,6
	0012		PUSHJ	$S,LSTOUT			;EXTERNAL
  2944	0013		SETZ	01,0
	0014		LSHC	01,3
  2945	0015		SOJGE	13,L32522  ^^^
  2948	0016		JRST	00,.EXT.1			;EXTERNAL


BRADIX5C	 ROUTINE RADIX50=	!R2 CONTAINS THE SYMBOL IN SIXBIT LEFT JUSTIFIED
BC	 			!CONVERT IT TO RADIX 50
BBEGINC	 BEGIN
BREGISTR50C	 REGISTER R50;
BLISS  V. 1.0-2.12	13-JUN-73  13:57:16	OPMOD	OUTMO1.BLI		PAGE 36-5

BMACROSIXALPXC	 MACRO SIXALPHA(X) =MOVEI(VREG,-#40,X) LEQ ("Z"-#100)$, !SIXBIT ALPHA
BSIXDIGXC	 	SIXDIGIT(X) =MOVEI(VREG,-#20,X) LEQ 9$; !SIXBIT DIGIT
BR50C	 R50_0;
BDOC	 DO (
BR1LSHCR1C	 	R1 _ 0; LSHC(R1,6);
BIFSIXALPMOVEIVREGR1LEQTHENR1R1C	 	IF SIXALPHA(R1) THEN R1 _ .R1 -#26
BELSEIFSIXDIGMOVEIVREGR1LEQTHENR1R1C	 	  ELSE IF SIXDIGIT(R1) THEN R1 _ .R1 -#17
BELSER1C	 	    ELSE R1 _ #45;	!A . BY DEFAULT
BR50R50R50R50R1C	 	R50 _ .R50*#50; R50 _ .R50 + .R1;
BWHILER2NEQC	    ) WHILE .R2 NEQ 0;
BRETURNR50C	 RETURN .R50
BENDC	 END;
BROUTIND

	0000		JSP	07,.ENT.1			;EXTERNAL
  2952	0001		SETZ	13,0
  2956	0002	L32412:	SETZ	01,0
	0003		LSHC	01,6
  2957	0004		MOVEI	$V,-40(01)
	0005		CAILE	$V,32
	0006		JRST	00,L31722
  2958	0007		SUBI	01,26
	0010		JRST	00,L32042
	0011	L31722:	MOVEI	$V,-20(01)
	0012		CAILE	$V,11
	0013		JRST	00,L32644
  2959	0014		SUBI	01,17
	0015		JRST	00,L32042
  2960	0016	L32644:	MOVEI	01,45
	0017	L32042:	IMULI	13,50
  2961	0020		ADD	13,1
	0021		JUMPN	02,L32412  ^^^
	0022		MOVE	$V,13
  2964	0023		JRST	00,.EXT.1			;EXTERNAL


BZOUDECC	 ROUTINE ZOUDECIMAL=
BBEGINC	 BEGIN
BC	 !	DECIMAL OUTPUT VALUE IN R1
BLOCALZC	 LOCAL Z[6];
BINCRIFROMTOIDOC	 INCR I FROM 0 TO 5 DO
BZIR1MODC	 	(Z[.I] _ (.R1 MOD 10);
BR1R1C	 	 R1 _ .R1/10;
BIFR1EQLTHENC	 	 IF .R1 EQL 0 THEN
BDECRJFROMJITODOCHRZJLSTOUTC	 		(DECR J FROM .I TO 0 DO (CHR _  .Z[.J] +#60; LSTOUT());
BRETURNC	 		 RETURN
BC	 		);
BC	 	)
BENDC	 END;
BGLOBALD

	0000		JSP	07,.ENT.2			;EXTERNAL
  2966	0001		ADD	$S,[000006,,000006]
  2968	0002		SETZ	13,0
  2969	0003	L32376:	CAILE	13,5
	0004		JRST	00,L32012
  2970	0005		MOVE	04,1
BLISS  V. 1.0-2.12	13-JUN-73  13:57:43	OPMOD	OUTMO1.BLI		PAGE 36-6

	0006		IDIVI	04,12
	0007		MOVE	06,13
	0010		ADD	06,16
	0011		MOVEM	05,3(06)			;LOCAL
  2971	0012		MOVE	01,4
	0013		JUMPN	01,L30736
	0014		MOVE	12,13
	0015		JUMPL	12,L31754
	0016	L31702:	MOVE	06,12
	0017		ADD	06,16
	0020		MOVE	05,3(06)			;LOCAL
	0021		ADDI	05,60
	0022		MOVE	03,5
	0023		PUSHJ	$S,LSTOUT			;EXTERNAL
  2973	0024		SOJGE	12,L31702  ^^^
	0025	L31754:	SETZ	$V,0
	0026		JRST	00,L32350
  2975	0027	L30736:	AOJA	13,L32376  ^^^
	0030	L32012:	SETO	$V,0
	0031	L32350:	SUB	$S,[000006,,000006]
  2977	0032		JRST	00,.EXT.2			;EXTERNAL


BROUTINZOUOFFBLISS  V. 1.0-2.12	13-JUN-73  13:57:43	OPMOD	OUTMO1.BLI		PAGE 37-1

C	 GLOBAL ROUTINE ZOUOFFSET=
BBEGINC	 BEGIN
BLOCALZC	 LOCAL Z[6];
BC	 !LIST IN ASCII THE VALUE OF R1 A REGISTER
BIFR1LSSTHENCHRELSECHRC	 IF .R1 LSS 0 THEN CHR _ "-" ELSE CHR _ "+";
BLSTOUTC	 LSTOUT();
BR1ABSR1C	 R1 _ ABS(.R1);
BZOUDECC	 ZOUDECIMAL();	!DECIMAL OUTPUT VALUE IN R1
BENDC	 END;
BGLOBALD

	0000		JSP	07,.ENT.0			;EXTERNAL
  2979	0001		ADD	$S,[000006,,000006]
  2980	0002		JUMPGE	01,L32660
	0003		MOVEI	03,55
	0004		JRST	00,L31716
  2982	0005	L32660:	MOVEI	03,53
	0006	L31716:	PUSHJ	$S,LSTOUT			;EXTERNAL
  2983	0007		MOVM	05,1
  2984	0010		MOVE	01,5
	0011		PUSHJ	$S,ZOUDECIMAL
  2985	0012		SETZ	$V,0
	0013		SUB	$S,[000006,,000006]
  2986	0014		JRST	00,.EXT.0			;EXTERNAL


BROUTINZDMPBLC	 GLOBAL ROUTINE ZDMPBLK=
BBEGINC	 BEGIN
BC	 %OUTPUT THE RELBLOCK TO THE REL FILE%
BIFZDATCNRELDATRIGHTNEQC	 IF .ZDATCNT NEQ 0
BTHENC	 THEN
BBEGINC	   BEGIN
BRBLOKTRELBLOLEFTCBLKRELDATLEFTC	 	RBLOKTYPE _ .CBLK;
BRRELOCRELBLORELOCWC	 	RRELOC _ .RELOCWD; !RELOCATION BITS
BRDATCORELBLORIGHTZDATCNRELDATRIGHTC	 	RDATCOUNT _ .ZDATCNT;
BINCRIFROMTOIRDATCORELBLORIGHTDOC	 	INCR I FROM 0 TO .RDATCOUNT+1 DO
BCHRRELBLOIRELOUTC	 	  (CHR _ .RELBLOCK[.I]; RELOUT());
BZDATCNRELDATRIGHTRELOCWRELOCPRELOCWC	 	ZDATCNT _ 0; RELOCWD _ 0; RELOCPTR _ (RELOCWD-1)<0,2>; !REINITIALIZE
BENDC	   END;
BC	 
BVREGC	   .VREG
BENDC	 END;	!OF ROUTINE ZDMPBLK
BGLOBALD

	0000		JSP	07,.ENT.1			;EXTERNAL
	0001		ADD	$S,[000001,,000001]
  2988	0002		HRRZ	04,RELDATA			;EXTERNAL
	0003		JUMPE	04,L30734
  2993	0004		HLRZ	06,RELDATA			;EXTERNAL
	0005		HRLM	06,RELBLOCK			;EXTERNAL
  2994	0006		MOVE	07,RELOCWD			;EXTERNAL
	0007		MOVEM	07,RELBLOCK+1			;EXTERNAL
  2995	0010		HRRM	04,RELBLOCK			;EXTERNAL
	0011		SETZ	13,0
  2996	0012		AOJ	04,0
	0013		MOVEM	04,2($F)			;LOCAL
	0014	L31754:	CAMLE	13,2($F)			;LOCAL
BLISS  V. 1.0-2.12	13-JUN-73  13:57:45	OPMOD	OUTMO1.BLI		PAGE 37-2

	0015		JRST	00,L32514
	0016		MOVE	03,RELBLOCK(13)			;EXTERNAL
	0017		PUSHJ	$S,RELOUT			;EXTERNAL
  2997	0020		AOJA	13,L31754  ^^^
	0021	L32514:	HLLZS	00,RELDATA			;EXTERNAL
	0022		SETZM	00,RELOCWD			;EXTERNAL
  2998	0023		MOVE	05,[000200,,RELOCWD-1]
	0024		MOVEM	05,RELOCPTR			;EXTERNAL
  3002	0025	L30734:	SUB	$S,[000001,,000001]
	0026		JRST	00,.EXT.1			;EXTERNAL


BROUTINZOUTBLZBLKTYRELBITC	 GLOBAL ROUTINE ZOUTBLOCK(ZBLKTYPE,RELBITS)=
BBEGINC	 BEGIN
BEXTERNRELOUTRELOUTC	 EXTERNAL RELOUT;
BC	 %
BC	 ROUTINE OUTPUTS THE RELOCATABLE DATA IN RDATWD TO THE REL FILE
BC	 USES A 20 WORD BUFFER TO STORE DATA AS DEFINED BY THE LOADER
BC	 SPECIFICATIONS.
BC	 ZBLKTYPE IS THE BLOCK TYPE TO BE OUTPUT NOW
BC	 RELBITS IS THE RELOCATION INFORMATION ASSOCIATED WITH THE CURRENT WORD OF DATA
BC	 %
BC	 !
BC	 !
BC	 !BEGIN ZOUTBLOCK HERE
BC	 !
BIFZDATCNRELDATRIGHTEQLRBLKSITHENZDMPBLC	 IF .ZDATCNT EQL RBLKSIZ-2 THEN ZDMPBLK();
BIFZBLKTYNEQCBLKRELDATLEFTC	 IF .ZBLKTYPE NEQ .CBLK
BTHENC	 THEN
BZDMPBLCBLKRELDATLEFTZBLKTYC	   (ZDMPBLK(); CBLK _ .ZBLKTYPE); !DUMP OUT OLD BLOCK BEGIN A NEW TYPE
BIFCBLKRELDATLEFTEQLRCODEANDZDATCNRELDATRIGHTEQLC	 	IF (.CBLK EQL RCODE) AND (.ZDATCNT EQL 0)
BTHENC	 	THEN	( !PUT OUT ADDRESS WORD AS FIRST WORD OF CODE BLOCK
BREPLACRELOCPRELRIC	 		 REPLACEI(RELOCPTR,RELRI);
BRDATARELBLOHILOCC	 		 RDATA(0)_.HILOC;	!START ADDR FOR LOADING CODE OR DATA
BRELDATRELDATC	 		RELDATA _ .RELDATA+1; !INCREMENT ZDATCNT
BC	 		);
BREPLACRELOCPRELBITC	 REPLACEI(RELOCPTR,.RELBITS);
BRDATARELBLOZDATCNRELDATRIGHTRDATWDC	 RDATA(.ZDATCNT) _ .RDATWD;
BRELDATRELDATC	 RELDATA _ .RELDATA+1;	!INCREMENTING ZDATCNT
BENDC	 END;	!OF ROUTINE ZOUTBLOCK
BROUTIND

	0000		JSP	07,.ENT.0			;EXTERNAL
  3005	0001		HRRZ	04,RELDATA			;EXTERNAL
	0002		CAIN	04,20
	0003		PUSHJ	$S,ZDMPBLK
  3018	0004		HLRZ	06,RELDATA			;EXTERNAL
	0005		CAMN	06,-3($F)			;FORMAL
	0006		JRST	00,L31746
	0007		PUSHJ	$S,ZDMPBLK
	0010		MOVE	$V,-3($F)			;FORMAL
	0011		HRLM	$V,RELDATA			;EXTERNAL
  3020	0012	L31746:	HLRZ	04,RELDATA			;EXTERNAL
	0013		MOVEI	05,1
	0014		CAIE	04,1
	0015		SETZ	05,0
	0016		HRRZ	06,RELDATA			;EXTERNAL
BLISS  V. 1.0-2.12	13-JUN-73  13:57:50	OPMOD	OUTMO1.BLI		PAGE 37-3

	0017		MOVEI	07,1
	0020		CAIE	06,0
	0021		SETZ	07,0
	0022		AND	05,7
	0023		TRNN	05,1
	0024		JRST	00,L33334
  3022	0025		MOVEI	04,1
	0026		IDPB	04,RELOCPTR			;EXTERNAL
  3024	0027		MOVE	06,HILOC			;EXTERNAL
	0030		MOVEM	06,RELBLOCK+2			;EXTERNAL
  3025	0031		AOS	07,RELDATA			;EXTERNAL
  3026	0032	L33334:	MOVE	04,-2($F)			;FORMAL
	0033		IDPB	04,RELOCPTR			;EXTERNAL
  3028	0034		HRRZ	06,RELDATA			;EXTERNAL
	0035		MOVE	07,RDATWD			;EXTERNAL
	0036		MOVEM	07,RELBLOCK+2(06)		;EXTERNAL
  3029	0037		AOS	05,RELDATA			;EXTERNAL
	0040		SETZ	$V,0
  3030	0041		JRST	00,.EXT.0			;EXTERNAL


BLISTSYPTRBLISS  V. 1.0-2.12	13-JUN-73  13:57:53	OPMOD	OUTMO1.BLI		PAGE 38-1

C	 ROUTINE LISTSYM(PTR)=
BBEGINC	 BEGIN
BEXTERNLSTOUTLSTOUTZOUTSYZOUTSYZOUTOCZOUTOCZOUTMSZOUTMSPROGNAC	 EXTERNAL LSTOUT,ZOUTSYM,ZOUTOCT,ZOUTMSG,PROGNAME;
BMAPBASEPTRPTRC	 MAP BASE PTR;
BR2PTRIDSYMBCW3FULLZOUTSYC	 			     		R2 _ .PTR[IDSYMBOL]; ZOUTSYM();
BCHRLSTOUTC	 					CHR _ #11; LSTOUT(); !TAB
BR2LEFTPTRIDADDRCW2RRIGHTZOUTOCC	 					R2<LEFT> _ .PTR[IDADDR]; ZOUTOCT();
BCHRLSTOUTC	 					CHR_#11;LSTOUT();!TAB
BENDC	 END;
BROUTIND

	0000		JSP	07,.ENT.0			;EXTERNAL
  3033	0001		MOVE	$V,-2($F)			;FORMAL
	0002		MOVE	02,3($V)
	0003		PUSHJ	$S,ZOUTSYM			;EXTERNAL
  3035	0004		MOVEI	03,11
	0005		PUSHJ	$S,LSTOUT			;EXTERNAL
  3036	0006		MOVE	$V,-2($F)			;FORMAL
	0007		HRL	02,2($V)
	0010		PUSHJ	$S,ZOUTOCT			;EXTERNAL
  3037	0011		MOVEI	03,11
	0012		PUSHJ	$S,LSTOUT			;EXTERNAL
  3038	0013		SETZ	$V,0
  3039	0014		JRST	00,.EXT.0			;EXTERNAL


BALLSCAC	 ROUTINE ALLSCAA=	!ALLOCATES STORAGE TO LOCAL SCALARS AND 
BC	 				!ARRAYS (NOT IN COMMON AND NOT IN EQUIVALENCE LISTS)
BC	 				!SEARCHES SYMTBL
BC	 				!ASSUMES ALL FIXUPS AND ALLOCATION  FOR COMMON AND EQUIVALENCE
BC	 				!HAVE ALREADY BEEN DONE.
BBEGINC	 BEGIN
BOWNPTRSCNTC	 OWN PTR,SCNT;
BEXTERNLSTOUTLSTOUTLOWLOCZOUTSYZOUTSYZOUTOCZOUTOCZOUTMSZOUTMSPROGNAC	 EXTERNAL LSTOUT,LOWLOC,ZOUTSYM,ZOUTOCT,ZOUTMSG,PROGNAME;
BEXTERNRDATWDRDATWDZOUTBLZOUTBLHILOCHILOCC	 EXTERNAL RDATWD,ZOUTBLOCK,HILOC;
BLOCALARRAPTC	 LOCAL ARRAPT;
BLABELL1L2C	 LABEL L1,L2;
BMAPBASEPTRPTRC	 MAP BASE PTR;
BSCNTC	 	SCNT_0;
BIFFLGREGLISTINC	 	IF .FLGREG<LISTING>
BTHENC	 	THEN
BZOUTMSPLITC	 	ZOUTMSG(PLIT '?M?J?M?JSCALARS AND ARRAYS?M?J?M?J');
BDECRIFROMSSIZITODOC	 	DECR I FROM SSIZ-1 TO 0 DO
BBEGINC	 	BEGIN
BIFPTRSYMTBLINEQC	 	  IF (PTR _ .SYMTBL[.I]) NEQ 0
BTHENBEGINC	 	  THEN	BEGIN
BDOBEGINC	 		DO BEGIN
BL1IFNOTPTRIDATTRCOMBLC	 		L1: IF NOT .PTR[IDATTRIBUT(COMBL)]
BTHENIFNOTPTRIDATTRINCOMC	 		     THEN IF NOT  .PTR[IDATTRIBUT(INCOM)]
BTHENIFNOTPTRIDATTRNAMNAMC	 			THEN IF NOT .PTR[IDATTRIBUT(NAMNAM)]
BTHENIFNOTPTRIDATTRINEQVC	 			THEN(  IF NOT .PTR[IDATTRIBUT(INEQV)]
BTHENC	 			     THEN
BL2BEGINC	 			     L2:BEGIN
BIFNOTPTRIDATTRDUMMYORPTRVALTYPEXOPWDEQLSTRINGC	         IF (NOT .PTR[IDATTRIBUT(DUMMY)] OR (.PTR[VALTYPE] EQL STRING))
BTHENC	 				THEN
BIFPTROPRSP1EXOPWDEQLFNNAMEC	 				 IF .PTR[OPRSP1] EQL FNNAME1	!IF FUNCTION NAME
BTHENC	 				   THEN
BLISS  V. 1.0-2.12	13-JUN-73  13:58:07	OPMOD	OUTMO1.BLI		PAGE 38-2

BIFNOTPTRIDATTRFENTRYTHENLEAVEL1C	 				    IF NOT .PTR[IDATTRIBUT(FENTRYNAME)] THEN LEAVE L1;
BC	 			!
BC	 			!ALLOACATE AN ADDRESS ONLY IF ALL ABOVE TESTS PASSED
BC	 			!
BPTRIDADDRCW2RRIGHTLOWLOCC	 				PTR[IDADDR] _ .LOWLOC;
BC	 
BIFPTROPERSPEXOPWDEQLARRAYNC	 				IF .PTR[OPERSP] EQL ARRAYNAME !IS IT AN ARRAY?
BTHENIFNOTPTRIDATTRDUMMYC	 				 THEN IF NOT .PTR[IDATTRIBUT(DUMMY)]
BTHENMAPBASEARRAPTARRAPTC	 				       THEN (	MAP BASE ARRAPT;
BARRAPTPTRIDDIMCW0LLEFTC	 						ARRAPT _ .PTR[IDDIM];	!PTR TO DIMENSION NODE
BLOWLOCLOWLOCARRAPTARASIZRIGHTC	 						LOWLOC _ .LOWLOC+ .ARRAPT[ARASIZ];
BLEAVEL2C	 						LEAVE L2;
BC	 					       );
BC	 
BIFPTRVALTYPEXOPWDEQLSTRINGC	                                 IF .PTR[VALTYPE] EQL STRING
BTHENC	                                 THEN
BBEGINC	                                 BEGIN
BLOWLOCLOWLOCPTRCW2LLEFTC	                                 LOWLOC _ .LOWLOC + (.PTR[CW2L]/5 +1);
BLEAVEL2C	                                 LEAVE L2;
BENDC	                                 END;
BC	 
BIFPTRDBLFLGEXOPWDC	 				  IF .PTR[DBLFLG] !IS THE VARIABLE DOUBLE LENGTH?
BTHENLOWLOCLOWLOCC	 					THEN LOWLOC _ .LOWLOC + 2
BELSELOWLOCLOWLOCC	 					ELSE LOWLOC _ .LOWLOC + 1
BENDC	 			     END;
BIFFLGREGLISTINC	 			     IF .FLGREG<LISTING>
BTHENC	 				THEN
BBEGINC	 				BEGIN
BLISTSYPTRC	 					LISTSYM(.PTR);
BIFSCNTLSSTHENSCNTSCNTELSESCNTCRLFC	 					IF .SCNT LSS 5 THEN SCNT _ .SCNT+1 ELSE (SCNT _ 0; CRLF());
BENDC	 				END;
BC	 			);
BENDWHILEPTRPTRCLINKRIGHTNEQC	 		    END WHILE (PTR _ .PTR[CLINK]) NEQ 0
BENDC	 	   END
BENDC	 	END
BENDC	 END;
BC	 !THE ROUTINES IN THIS MODULE ARE FOR THE PURPOSE
BC	 !OF GENERATING THE FOLLOWING THINGS:
BC	 %	THE CORRECT ALLOCATION OF ADDRESSES TO THE VARIABLES,ARRAYS
BC	 	CONSTANTS,STRINGS ETC., IN THE SUBPROGRAM BEING COMPILED
BC	 	.THE STATISTICS LISTING OF THE SCALARS,ARRAYS ,COMMON,
BC	 	 CONSTANTS,TEMPORARIES ETC. THAT THE SUBPROGRAM DEFINES.
BC	 %
BC	 !
BROUTIND

	0000		JSP	07,.ENT.1			;EXTERNAL
	0001		PUSH	$S,10
  3045	0002		ADD	$S,[000001,,000001]
  3046	0003		SETZM	00,OPMO.O+1
	0004		MOVE	04,0
	0005		TRNN	04,2000
	0006		JRST	00,L32350
	0007		PUSH	$S,[004400,,OPMO.P+1]
	0010		PUSHJ	$S,ZOUTMSG			;EXTERNAL
	0011		SUB	$S,[000001,,000001]
  3055	0012	L32350:	MOVEI	13,116
BLISS  V. 1.0-2.12	13-JUN-73  13:58:38	OPMOD	OUTMO1.BLI		PAGE 38-3

  3056	0013	L32224:	HRRZ	05,SYMTBL(13)			;EXTERNAL
	0014		MOVEM	05,OPMO.O+0
	0015		JUMPE	05,L34254
  3060	0016	L32342:	MOVE	$V,OPMO.O+0
	0017		MOVE	07,1($V)
	0020		TLNE	07,200000
	0021		JRST	00,L32560
	0022		MOVE	04,1($V)
	0023		TLNE	04,400
	0024		JRST	00,L32560
	0025		MOVE	05,1($V)
	0026		TLNE	05,-400000
	0027		JRST	00,L32560
	0030		MOVE	06,1($V)
	0031		TLNE	06,1000
	0032		JRST	00,L32610
  3068	0033		LDB	07,[150515,,000001]
	0034		MOVEI	04,1
	0035		CAIE	07,17
	0036		SETZ	04,0
	0037		LDB	05,[260115,,000001]
	0040		ORCM	04,5
	0041		TRNN	04,1
	0042		JRST	00,L35014
  3069	0043		LDB	06,[060215,,000001]
	0044		CAIE	06,3
	0045		JRST	00,L35014
	0046		MOVE	05,1($V)
	0047		TLNN	05,2000
	0050		JRST	00,L32560
	0051	L35014:	MOVE	$V,OPMO.O+0
  3075	0052		MOVE	06,LOWLOC			;EXTERNAL
	0053		HRRM	06,2($V)
  3077	0054		LDB	07,[050315,,000001]
	0055		CAIE	07,4
	0056		JRST	00,L34772
	0057		MOVE	04,1($V)
	0060		TLNE	04,20
	0061		JRST	00,L34772
  3079	0062		HLRZ	06,0($V)
	0063		MOVEM	06,3($F)			;LOCAL
  3081	0064		HRRZ	07,0(06)
	0065		JRST	00,L35350
  3083	0066	L34772:	MOVE	$V,OPMO.O+0
  3085	0067		LDB	04,[150515,,000001]
	0070		CAIE	04,17
	0071		JRST	00,L32626
  3088	0072		HLRZ	07,2($V)
	0073		IDIVI	07,5
	0074		AOJ	07,0
	0075	L35350:	ADDB	07,LOWLOC			;EXTERNAL
	0076		JRST	00,L32610
  3090	0077	L32626:	MOVE	$V,OPMO.O+0
	0100		MOVE	07,1($V)
	0101		TRNN	07,200000
	0102		JRST	00,L35512
  3093	0103		MOVEI	$V,2
BLISS  V. 1.0-2.12	13-JUN-73  13:58:39	OPMOD	OUTMO1.BLI		PAGE 38-4

	0104		ADDB	$V,LOWLOC			;EXTERNAL
	0105		JRST	00,L32610
  3094	0106	L35512:	AOS	$V,LOWLOC			;EXTERNAL
  3095	0107	L32610:	MOVE	07,0
	0110		TRNN	07,2000
	0111		JRST	00,L32560
  3098	0112		PUSH	$S,OPMO.O+0
	0113		PUSHJ	$S,LISTSYM
	0114		SUB	$S,[000001,,000001]
  3099	0115		MOVE	04,OPMO.O+1
	0116		CAIL	04,5
	0117		JRST	00,L35216
	0120		AOS	$V,OPMO.O+1
	0121		JRST	00,L32560
	0122	L35216:	SETZM	00,OPMO.O+1
	0123		PUSHJ	$S,CRLF
  3100	0124	L32560:	MOVE	$V,OPMO.O+0
	0125		HRRZ	04,0($V)
	0126		MOVEM	04,OPMO.O+0
  3103	0127		JUMPN	04,L32342  ^^^
  3105	0130		JRST	00,L34254
	0131	L34254:	SOJGE	13,L32224  ^^^
	0132		SETO	$V,0
	0133		SUB	$S,[000001,,000001]
  3106	0134		POP	$S,10
	0135		JRST	00,.EXT.1			;EXTERNAL


BALLCOMC	 ROUTINE ALLCOM=
BBEGINC	 BEGIN
BC	 %ROUTINE ALLOCATES RELATIVE ADDRESSES TO ALL VARIABLES DECLARED IN COMMON.
BC	 THE ADDRESSES OF THE VARIABLES / ARRAYS IN A COMMON BLOCK ARE ARLATIVE TO THE 
BC	 BEGINNING OF THE BLOCK IN WHICH THEY ARE DECLARED. EACH BLOCK HAS AN ORIGIN
BC	 OF ZERO. AT LOAD TIME THE LOADER WILL ASSIGN ACTUAL LOCATIONS TO 
BC	 COMMON BLOCKS BASED ON THEIR SIZES AND ORDER OF
BC	 APPEARANCE TO LOADER. IN THE RLOACTABLE BINARY, REFERENCES TO
BC	 COMMON VARIABLES WILL USE ADDITIVE GLOBAL FIXUPS.
BC	 
BC	 THE CALL TO THIS ROUTINE OCCURS AFTER ANY EQUIVALENCE RELATIONS 
BC	 HAVE BEEN PROCESSED BY ROUTINE PROCEQUIV
BC	 %
BREGISTICNTC	 REGISTER ICNT;
BEXTERNCOMBLKCOMBLKEQVPTREQVPTRC	 EXTERNAL COMBLKPTR,EQVPTR;
BREGISTBASECSYMPTCSYMPTC	 REGISTER BASE CSYMPTR;
BLOCALBASECCOMPTCCOMPTC	 LOCAL BASE CCOMPTR;
BMACROCOMBLOC	 MACRO COMBLOK=#20$;
BC	 
BICNTC	 ICNT _ 0;
BIFFLGREGLISTINTHENZOUTMSPLITC	 IF .FLGREG<LISTING> THEN ZOUTMSG(PLIT'?M?J?M?JCOMMON BLOCKS?M?J');
BCCOMPTFIRCOMCOMBLKLEFTC	 CCOMPTR _ .FIRCOMBLK; !PTR TO FIRST COMMON BLOCK DECLARED
BWHILEDOC	 WHILE 1 DO  %1%
BBEGINC	 BEGIN
BC	 	!START BY OUTPUTTING NAME OF BLOCK
BIFFLGREGLISTINTHENC	 	IF .FLGREG<LISTING> THEN
BBEGINC	 	BEGIN
BCRLFCHRLSTOUTC	 	  CRLF(); CHR_"/";LSTOUT();
BR2CCOMPTCOMNAMCW1FULLZOUTSYC	 	R2 _ .CCOMPTR[COMNAME]; ZOUTSYM();
BLISS  V. 1.0-2.12	13-JUN-73  13:58:42	OPMOD	OUTMO1.BLI		PAGE 38-5

BCHRLSTOUTC	 	  CHR _ "/"; LSTOUT();
BCHRLSTOUTR1CCOMPTCOMSIZCW0LLEFTZOUOFFCHRLSTOUTC	 	  CHR _ "("; LSTOUT(); R1 _ .CCOMPTR[COMSIZE]; ZOUOFFSET(); CHR _ ")"; LSTOUT();
BENDC	 	END;
BC	 	!RELOCATABLE BINARY IF NECESSARY
BIFFLGREGOBJECTC	 	IF .FLGREG<OBJECT>
BTHENR2CCOMPTCOMNAMCW1FULLC	 	THEN (R2 _ .CCOMPTR[COMNAME]; !FOR RADIX 50 CONVERSION
BRDATWDRGLOBDRADIX5ZOUTBLCOMBLORELNC	 		RDATWD_RGLOBDEF+RADIX50(); ZOUTBLOCK(COMBLOK,RELN);
BRDATWDCCOMPTCOMSIZCW0LLEFTZOUTBLCOMBLORELNC	 		RDATWD_ .CCOMPTR[COMSIZE]; ZOUTBLOCK(COMBLOK,RELN);
BC	 	     );
BC	 	!NOW LIST THE SYMBOLS IN THE BLOCK
BC	 
BIFFLGREGLISTINTHENC	 		IF .FLGREG<LISTING> THEN
BBEGINC	 		BEGIN
BCSYMPTCCOMPTCOMFIRCW2LLEFTC	 			CSYMPTR _ .CCOMPTR[COMFIRST];
BCRLFC	 		CRLF();!CR/LF
BWHILEDOC	 		WHILE 1 DO %2%
BBEGINC	 		BEGIN
BR2CSYMPTIDSYMBCW3FULLZOUTSYC	 		R2 _ .CSYMPTR[IDSYMBOL]; ZOUTSYM();
BCHRLSTOUTC	 		CHR _ #11; LSTOUT();	!TAB
BR1CSYMPTIDADDRCW2RRIGHTZOUOFFC	 		R1 _ .CSYMPTR[IDADDR]; ZOUOFFSET();
BIFCSYMPTCSYMPTIDCOLICW5RRIGHTEQLTHENEXITLOC	 		IF (CSYMPTR _ .CSYMPTR[IDCOLINK]) EQL 0 THEN EXITLOOP;
BIFICNTICNTEQLC	 		IF (ICNT _ .ICNT +1) EQL 5
BTHENICNTCRLFELSECHRLSTOUTC	 		THEN (ICNT _ 0; CRLF()) ELSE (CHR _ #11; LSTOUT() %TAB% );
BENDC	 		END; !OF %2%
BENDC	 	END;
BC	 
BIFCCOMPTCCOMPTNEXCOMCW3RRIGHTEQLTHENRETURNC	 	IF (CCOMPTR _ .CCOMPTR[NEXCOMBLK]) EQL 0 THEN RETURN;
BENDC	 END
BENDC	 END;	!OF ALLCOM ROUTINE
BROUTIND

	0000		JSP	07,.ENT.2			;EXTERNAL
  3116	0001		ADD	$S,[000001,,000001]
  3128	0002		SETZ	13,0
	0003		MOVE	04,0
	0004		TRNN	04,2000
	0005		JRST	00,L35026
	0006		PUSH	$S,[004400,,OPMO.P+10]
	0007		PUSHJ	$S,ZOUTMSG
	0010		SUB	$S,[000001,,000001]
  3135	0011	L35026:	HLRZ	05,COMBLKPTR			;EXTERNAL
	0012		MOVEM	05,3($F)			;LOCAL
  3138	0013	L32324:	MOVE	06,0
	0014		TRNN	06,2000
	0015		JRST	00,L32224
  3141	0016		PUSHJ	$S,CRLF
	0017		MOVEI	03,57
	0020		PUSHJ	$S,LSTOUT			;EXTERNAL
  3142	0021		MOVE	$V,3($F)			;LOCAL
	0022		MOVE	02,1($V)
	0023		PUSHJ	$S,ZOUTSYM
  3143	0024		MOVEI	03,57
	0025		PUSHJ	$S,LSTOUT			;EXTERNAL
  3144	0026		MOVEI	03,50
	0027		PUSHJ	$S,LSTOUT			;EXTERNAL
	0030		MOVE	$V,3($F)			;LOCAL
	0031		HLRZ	01,0($V)
BLISS  V. 1.0-2.12	13-JUN-73  13:58:57	OPMOD	OUTMO1.BLI		PAGE 38-6

	0032		PUSHJ	$S,ZOUOFFSET
	0033		MOVEI	03,51
	0034		PUSHJ	$S,LSTOUT			;EXTERNAL
  3145	0035	L32224:	MOVE	07,0
	0036		TRNN	07,20000
	0037		JRST	00,L35340
	0040		MOVE	$V,3($F)			;LOCAL
  3149	0041		MOVE	02,1($V)
	0042		PUSHJ	$S,RADIX50
	0043		ADD	$V,[040000,,000000]
	0044		MOVEM	$V,RDATWD			;EXTERNAL
	0045		PUSH	$S,[20]
	0046		PUSH	$S,[0]
	0047		PUSHJ	$S,ZOUTBLOCK
	0050		SUB	$S,[000002,,000002]
  3150	0051		MOVE	$V,3($F)			;LOCAL
	0052		HLRZ	04,0($V)
	0053		MOVEM	04,RDATWD			;EXTERNAL
	0054		PUSH	$S,[20]
	0055		PUSH	$S,[0]
	0056		PUSHJ	$S,ZOUTBLOCK
	0057		SUB	$S,[000002,,000002]
  3151	0060	L35340:	MOVE	04,0
	0061		TRNN	04,2000
	0062		JRST	00,L33624
  3156	0063		MOVE	$V,3($F)			;LOCAL
  3157	0064		HLRZ	12,2($V)
	0065	L35452:	PUSHJ	$S,CRLF
  3158	0066	L33530:	MOVE	02,3(12)
	0067		PUSHJ	$S,ZOUTSYM
  3161	0070		MOVEI	03,11
	0071		PUSHJ	$S,LSTOUT			;EXTERNAL
  3162	0072		HRRZ	01,2(12)
	0073		PUSHJ	$S,ZOUOFFSET
  3163	0074		HRRZ	12,5(12)
	0075		JUMPN	12,L32052
	0076		JRST	00,L33624
  3165	0077	L32052:	AOJ	13,0
	0100		CAIE	13,5
	0101		JRST	00,L34726
	0102		SETZ	13,0
	0103		JRST	00,L35452  ^^^
	0104	L34726:	MOVEI	03,11
	0105		PUSHJ	$S,LSTOUT			;EXTERNAL
  3167	0106		JRST	00,L33530  ^^^
	0107	L33624:	MOVE	$V,3($F)			;LOCAL
	0110		HRRZ	05,3($V)
	0111		MOVEM	05,3($F)			;LOCAL
	0112		JUMPN	05,L35020
	0113		SETZ	$V,0
	0114		JRST	00,L35156
	0115	L35020:	JRST	00,L32324  ^^^
	0116	L35156:	SUB	$S,[000001,,000001]
  3172	0117		JRST	00,.EXT.2			;EXTERNAL


BALLOCABLISS  V. 1.0-2.12	13-JUN-73  13:59:01	OPMOD	OUTMO1.BLI		PAGE 39-1

C	 ROUTINE ALLOCAT=
BBEGINC	 BEGIN
BC	 %ALOCATES RELATIVE ADDRESSES TO ALL VARIABLES AND STORAGE
BC	  IN THE LOW SEGMENT,EXCEPT TEMPORARIES WHICH ARE ALLOCATED AFTER
BC	  CODE GENERATION.
BC	 THIS ROUTINE CONTROLS THE ALLOCATION BY CALLING THE ACTUAL ROUTINES
BC	 THAT DO THE ALLOCATION AND PROCESSING OF VARIABLES,COMMON BLOCKS,EQUIVALENCE
BC	  GROUPS ,DATA FIXUPS ETC.
BC	 %
BC	 
BEXTERNLSTOUTLSTOUTERROUTERROUTFORMPTFORMPTCOMBLKCOMBLKEQVPTREQVPTRC	 EXTERNAL LSTOUT,ERROUT,FORMPTR,COMBLKPTR,EQVPTR,
BLOWLOCC	 	LOWLOC,	!LOW SEG AVAILABLE ADDRESS
BCOMSIZCOMSIZC	 	COMSIZ;	!CURRENT TOTAL SIZE OF COMMON INCLUDING BLANK
BC	 
BCOMSIZC	 COMSIZ _ 0;
BIFCOMBLKNEQTHENCOMSIZPROCCOC	 IF .COMBLKPTR NEQ 0 THEN COMSIZ _ PROCCOM(); ! PROCESS COMMON BLOCKS
BIFEQVPTRNEQTHENPROCEQC	 IF .EQVPTR NEQ 0 THEN PROCEQUIV();	!PROCESS EQUIVALENCE GROUPS
BIFCOMBLKNEQTHENALLCOMC	 IF .COMBLKPTR NEQ 0 THEN ALLCOM(); !ALLOCATE COMMON NOW
BC	 !
BC	 !NOW ALLOCATE AND LIST ALL VARIABLES,ARRAYS ETC.
BC	 !
BALLSCAC	 ALLSCAA();	!ALLOCATE SCALARS AND ARRAYS
BC	 
BIFFORMPTNEQTHENALLFORC	 IF .FORMPTR NEQ 0 THEN ALLFORM();	!ALLOCATE FORMAT STRINGS
BC	 
BENDC	 END;
BROUTIND

  3183	0000		SETZM	00,COMSIZ			;EXTERNAL
	0001		SKIPN	04,COMBLKPTR			;EXTERNAL
	0002		JRST	00,L33762
	0003		PUSHJ	$S,PROCCOM
  3188	0004		MOVEM	$V,COMSIZ			;EXTERNAL
	0005	L33762:	SKIPE	06,EQVPTR			;EXTERNAL
	0006		PUSHJ	$S,PROCEQUIV
  3189	0007		SKIPE	04,COMBLKPTR			;EXTERNAL
	0010		PUSHJ	$S,ALLCOM
  3190	0011		PUSHJ	$S,ALLSCAA
  3194	0012		SKIPE	06,FORMPTR			;EXTERNAL
	0013		PUSHJ	$S,ALLFORM
  3196	0014		SETZ	$V,0
  3198	0015		POPJ	$S,0


BDMPFORBLISS  V. 1.0-2.12	13-JUN-73  13:59:08	OPMOD	OUTMO1.BLI		PAGE 40-1

C	 ROUTINE DMPFORMAT=
BBEGINC	 BEGIN
BC	 !
BC	 !DUMPS FORMAT STRING DEFINITIONS  TO REL FILE AFTER ALL LOWSEG
BC	 !ALLOCATION HAS BEEN DONE
BC	 !
BLOCALSAVHILC	 LOCAL SAVHILOC;
BREGISTBASEZFORPTZFORPTC	 REGISTER BASE ZFORPTR;
BEXTERNLOWLOCFORMPTFORMPTHILOCHILOCZDMPBLZDMPBLC	 EXTERNAL LOWLOC,FORMPTR,HILOC,ZDMPBLK;
BZFORPTFORMPTLEFTC	 ZFORPTR _ .FORMPTR<LEFT>;	!PTR TO FIRST FORMAT STRING
BSAVHILHILOCHILOCZFORPTFORADDCW4RRIGHTC	 SAVHILOC _ .HILOC; HILOC _ .ZFORPTR[FORADDR]; !TO PUT DATA BLOCK IN LOWSEG
BDOC	 DO
BBEGINC	 BEGIN
BINCRIFROMTOIZFORPTFORSIZCW4LLEFTDOC	 	INCR I FROM 0 TO .ZFORPTR[FORSIZ]-1 DO
BRDATWDZFORPTFORSTRCW5RRIGHTIFULLC	 	 (RDATWD _ .(.ZFORPTR[FORSTRING])[.I]<FULL>;
BZOUTBLRCODERELNC	 	  ZOUTBLOCK(RCODE,RELN);
BHILOCHILOCC	 	   HILOC _ .HILOC+1;	!INCREMENT FOR POSSIBLE USE IN ZOUTBLOCK
BC	 	 );
BENDWHILEZFORPTZFORPTFMTLINCW5LLEFTNEQC	 END WHILE (ZFORPTR _ .ZFORPTR[FMTLINK]) NEQ 0;
BZDMPBLC	 ZDMPBLK();	!DUMP OUT THE CODE BLOCK IMMEDIATELY
BHILOCSAVHILC	 HILOC _ .SAVHILOC;
BRETURNVREGC	 RETURN .VREG
BENDC	 END;
BROUTIND

	0000		JSP	07,.ENT.2			;EXTERNAL
  3200	0001		ADD	$S,[000002,,000002]
  3205	0002		HLRZ	13,FORMPTR			;EXTERNAL
	0003		MOVE	04,HILOC			;EXTERNAL
	0004		MOVEM	04,3($F)			;LOCAL
  3209	0005		HRRZ	05,4(13)
	0006		MOVEM	05,HILOC			;EXTERNAL
  3211	0007	L33526:	SETZ	12,0
  3212	0010		HLRZ	06,4(13)
	0011		SOJ	06,0
	0012		MOVEM	06,4($F)			;LOCAL
	0013	L34746:	CAMLE	12,4($F)			;LOCAL
	0014		JRST	00,L35256
  3213	0015		HRRZ	07,5(13)
	0016		ADD	07,12
	0017		MOVE	04,0(07)
	0020		MOVEM	04,RDATWD			;EXTERNAL
	0021		PUSH	$S,[1]
	0022		PUSH	$S,[0]
	0023		PUSHJ	$S,ZOUTBLOCK
	0024		SUB	$S,[000002,,000002]
  3214	0025		AOS	05,HILOC			;EXTERNAL
  3216	0026		AOJA	12,L34746  ^^^
  3217	0027	L35256:	HLRZ	13,5(13)
	0030		JUMPN	13,L33526  ^^^
	0031		PUSHJ	$S,ZDMPBLK			;EXTERNAL
  3219	0032		MOVE	07,3($F)			;LOCAL
	0033		MOVEM	07,HILOC			;EXTERNAL
  3220	0034		SUB	$S,[000002,,000002]
  3221	0035		JRST	00,.EXT.2			;EXTERNAL


BLISS  V. 1.0-2.12	13-JUN-73  13:59:20	OPMOD	OUTMO1.BLI		PAGE 40-2

BALLFORBLISS  V. 1.0-2.12	13-JUN-73  13:59:20	OPMOD	OUTMO1.BLI		PAGE 41-1

C	 ROUTINE ALLFORM=
BBEGINC	 BEGIN
BC	 %ALLOCATES LOW SEG STORAGE ADDRESS TO FORMAT STRINGS
BC	 BUT DOES NOT TELL THE LOADER YET
BC	 %
BREGISTBASEZFORPTZFORPTC	 REGISTER BASE ZFORPTR;
BEXTERNLOWLOCFORMPTFORMPTHILOCHILOCZDMPBLZDMPBLC	 EXTERNAL LOWLOC,FORMPTR,HILOC,ZDMPBLK;
BZFORPTFORMPTLEFTC	 ZFORPTR _ .FORMPTR<LEFT>;	!PTR TO FIRST FORMAT STRING
BWHILEDOC	 WHILE 1 DO
BBEGINC	 BEGIN
BZFORPTFORADDCW4RRIGHTLOWLOCC	 	ZFORPTR[FORADDR] _ .LOWLOC;
BLOWLOCLOWLOCZFORPTFORSIZCW4LLEFTC	 	LOWLOC _ .LOWLOC+.ZFORPTR[FORSIZ];
BIFZFORPTFMTLINCW5LLEFTEQLC	 	IF .ZFORPTR[FMTLINK] EQL 0
BTHENEXITLOC	 	THEN EXITLOOP
BELSEZFORPTZFORPTFMTLINCW5LLEFTC	 	ELSE ZFORPTR _ .ZFORPTR[FMTLINK]
BENDC	 END;
BRETURNVREGC	 RETURN .VREG
BENDC	 END;
BROUTIND

	0000		JSP	07,.ENT.1			;EXTERNAL
  3227	0001		HLRZ	13,FORMPTR			;EXTERNAL
  3231	0002	L34064:	MOVE	04,LOWLOC			;EXTERNAL
	0003		HRRM	04,4(13)
  3233	0004		HLRZ	05,4(13)
	0005		ADDB	05,LOWLOC			;EXTERNAL
  3234	0006		HLRZ	06,5(13)
	0007		JUMPN	06,L34714
	0010		JRST	00,L31702
	0011		JRST	00,L34064  ^^^
  3236	0012	L34714:	HLRZ	13,5(13)
  3237	0013		JRST	00,L34064  ^^^
  3239	0014	L31702:	JRST	00,.EXT.1			;EXTERNAL


BPROCCOBLISS  V. 1.0-2.12	13-JUN-73  13:59:23	OPMOD	OUTMO1.BLI		PAGE 42-1

C	 ROUTINE PROCCOM=
BBEGINC	 BEGIN
BC	 %ROUTINE MAKES A FAST PASS THRU THE LINKED LISTS OF COMMON BLOCKS
BC	 AND ASSOCIATED SYMBOL TABLE ENTRIES COMPUTING THE DECLARED SIZE OF EACH
BC	 BLOCK AND ASSIGNING A TEMPORARY ADDRESS TO THE VARIABLES IN EACH
BC	 BLOCK RELATIVE TO THE BEGINNING OF THE BLOCK
BC	 %
BEXTERNCOMBLKCOMBLKC	 EXTERNAL COMBLKPTR;
BMACROCBLKSIC	 MACRO CBLKSIZ = R1$,	!SIZE OF CURRENT BLOCK
BTCOMSIC	 	TCOMSIZ = R2$;
BREGISTBASECSYMPTCSYMPTC	 REGISTER BASE CSYMPTR;
BLOCALBASECCOMPTCCOMPTC	 LOCAL BASE CCOMPTR;
BC	 !
BXTRACIFDEGUGTHENIFDTRACENEQTHENXCALLC	 XTRAC;
BC	 !
BTCOMSIR2C	 TCOMSIZ _ 0;
BCCOMPTFIRCOMCOMBLKLEFTC	 CCOMPTR _ .FIRCOMBLK;	!PTR TO FIRST COMMON BLOCK
BC	 
BWHILEDOC	 WHILE 1 DO	%1% !LOOP ON LINKED LIST
BBEGINC	 BEGIN
BCSYMPTCCOMPTCOMFIRCW2LLEFTC	 	CSYMPTR _ .CCOMPTR[COMFIRST];	!PTR TO FIRST SYMBOL ENTRY IN BLOCK
BCBLKSIR1C	 	CBLKSIZ _ 0;
BWHILEDOC	 	WHILE 1 DO %2% !LOOP ON LINKEDLIST OF SYMBOLS IN BLOCK
BBEGINC	 	BEGIN
BCSYMPTIDADDRCW2RRIGHTCBLKSIR1C	 	  CSYMPTR[IDADDR] _.CBLKSIZ;
BIFCSYMPTIDDIMCW0LLEFTNEQC	 	  IF .CSYMPTR[IDDIM] NEQ 0
BTHENLOCALBASEDIMPTRDIMPTRC	 	  THEN (LOCAL BASE DIMPTR;
BDIMPTRCSYMPTIDDIMCW0LLEFTC	 		DIMPTR _ .CSYMPTR[IDDIM];
BCBLKSIR1CBLKSIR1DIMPTRARASIZRIGHTC	 		CBLKSIZ _ .CBLKSIZ + .DIMPTR[ARASIZ];
BC	 		)
BELSEIFCSYMPTVALTYPEXOPWDGTRREALC	 	  ELSE (IF .CSYMPTR[VALTYPE] GTR REAL
BTHENCBLKSIR1CBLKSIR1C	 		THEN CBLKSIZ _ .CBLKSIZ + 2
BELSECBLKSIR1CBLKSIR1C	 		ELSE CBLKSIZ _ .CBLKSIZ + 1
BC	 		);
BIFCSYMPTIDCOLICW5RRIGHTEQLTHENEXITLOC	 	  IF .CSYMPTR[IDCOLINK] EQL 0 THEN EXITLOOP
BELSECSYMPTCSYMPTIDCOLICW5RRIGHTC	 		ELSE CSYMPTR _ .CSYMPTR[IDCOLINK];
BENDC	 	END;! OF %2% LOOP
BC	   !NOW UPDATE TOTAL SIZE OF COMMON
BCCOMPTCOMSIZCW0LLEFTCBLKSIR1C	 	CCOMPTR[COMSIZE] _ .CBLKSIZ;
BTCOMSIR2TCOMSIR2CBLKSIR1C	 	TCOMSIZ _ .TCOMSIZ + .CBLKSIZ;
BIFCCOMPTNEXCOMCW3RRIGHTEQLC	 	IF .CCOMPTR[NEXCOMBLK] EQL 0
BTHENEXITLOC	 	  THEN EXITLOOP
BELSECCOMPTCCOMPTNEXCOMCW3RRIGHTC	 	  ELSE CCOMPTR _ .CCOMPTR[NEXCOMBLK];
BENDC	 END; !OF %1% LOOP
BRETURNTCOMSIR2C	 RETURN .TCOMSIZ
BENDC	 END; !OF ROUTINE
BROUTIND

	0000		JSP	07,.ENT.1			;EXTERNAL
  3241	0001		ADD	$S,[000001,,000001]
  3255	0002		SETZ	02,0
  3256	0003		HLRZ	04,COMBLKPTR			;EXTERNAL
	0004		MOVEM	04,2($F)			;LOCAL
  3259	0005	L33446:	MOVE	$V,2($F)			;LOCAL
  3260	0006		HLRZ	13,2($V)
  3261	0007		SETZ	01,0
  3263	0010	L34102:	HRRM	01,2(13)
BLISS  V. 1.0-2.12	13-JUN-73  13:59:58	OPMOD	OUTMO1.BLI		PAGE 42-2

  3265	0011		HLRZ	05,0(13)
	0012		JUMPE	05,L35072
	0013		ADD	$S,[000001,,000001]
  3266	0014		HLRZ	07,0(13)
	0015		MOVEM	07,3($F)			;LOCAL
  3268	0016		HRRZ	04,0(07)
	0017		ADD	01,4
	0020		SUB	$S,[000001,,000001]
	0021		JRST	00,L32416
  3270	0022	L35072:	LDB	07,[150513,,000001]
	0023		CAIG	07,24
	0024		JRST	00,L34452
  3271	0025		ADDI	01,2
	0026		JRST	00,L32416
  3272	0027	L34452:	AOJ	01,0
	0030	L32416:	HRRZ	07,5(13)
	0031		JUMPN	07,L35132
	0032		JRST	00,L33510
	0033		JRST	00,L34102  ^^^
  3275	0034	L35132:	HRRZ	13,5(13)
  3276	0035		JRST	00,L34102  ^^^
	0036	L33510:	MOVE	$V,2($F)			;LOCAL
  3278	0037		HRLM	01,0($V)
  3279	0040		ADD	02,1
  3280	0041		HRRZ	05,3($V)
	0042		JUMPN	05,L32000
	0043		JRST	00,L31742
	0044		JRST	00,L33446  ^^^
  3282	0045	L32000:	HRRZ	07,3($V)
	0046		MOVEM	07,2($F)			;LOCAL
  3283	0047		JRST	00,L33446  ^^^
	0050	L31742:	MOVE	$V,2
	0051		SUB	$S,[000001,,000001]
  3285	0052		JRST	00,.EXT.1			;EXTERNAL


BEQERRLGROUPBLISS  V. 1.0-2.12	13-JUN-73  13:59:59	OPMOD	OUTMO1.BLI		PAGE 43-1

C	 ROUTINE EQERRLIST(GROUP)=
BBEGINC	 BEGIN
BC	 !LIST THE GROUP OF EQUIVALENCE VARIABLES IN CONFLICT
BC	 !
BEXTERNLSTOUTLSTOUTZOUTMSZOUTMSC	 EXTERNAL LSTOUT,ZOUTMSG;
BMAPBASEGROUPGROUPR2C	 MAP BASE GROUP:R2;
BLOCALBASESYMPTRSYMPTRSYMPTRC	 LOCAL BASE SYMPTR;
BSYMPTRGROUPEQVFIRCW2LLEFTC	 	SYMPTR _ .GROUP[EQVFIRST];
BERROUTC	 	ERROUT(49);	!SAME MESSAGE AS BELOW
BZOUTMSPLITC	 	ZOUTMSG(PLIT '?M?JCONFLICTING EQUIVALENCE DECLARATION ( ?0');
BWHILEDOR2SYMPTREQLIDCW1RRIGHTC	 	WHILE 1 DO(	R2 _ .SYMPTR[EQLID];
BR2R2IDSYMBCW3FULLZOUTSYC	 			R2 _ .R2[IDSYMBOL]; ZOUTSYM();
BIFSYMPTRSYMPTREQLLINCLINKRIGHTEQLTHENEXITLOC	 			IF (SYMPTR _ .SYMPTR[EQLLINK]) EQL 0 THEN EXITLOOP
BELSECLSTOUTC	 				ELSE (C _ ","; LSTOUT());
BC	 		   );
BENDC	 END;	!OF EQERRLIST
BROUTIND

	0000		JSP	07,.ENT.0			;EXTERNAL
  3287	0001		ADD	$S,[000001,,000001]
  3290	0002		MOVE	$V,-2($F)			;FORMAL
  3293	0003		HLRZ	04,2($V)
	0004		MOVEM	04,1($F)			;LOCAL
	0005		PUSH	$S,[61]
	0006		PUSHJ	$S,ERROUT			;EXTERNAL
	0007		SUB	$S,[000001,,000001]
  3294	0010		PUSH	$S,[004400,,OPMO.P+15]
	0011		PUSHJ	$S,ZOUTMSG			;EXTERNAL
	0012		SUB	$S,[000001,,000001]
  3295	0013	L34730:	MOVE	$V,1($F)			;LOCAL
  3296	0014		HRRZ	02,1($V)
	0015		MOVE	02,3(02)
	0016		PUSHJ	$S,ZOUTSYM
  3297	0017		MOVE	$V,1($F)			;LOCAL
	0020		HRRZ	05,0($V)
	0021		MOVEM	05,1($F)			;LOCAL
	0022		JUMPN	05,L32656
	0023		JRST	00,L32260
	0024		JRST	00,L34730  ^^^
	0025	L32656:	MOVEI	03,54
	0026		PUSHJ	$S,LSTOUT			;EXTERNAL
  3300	0027		JRST	00,L34730  ^^^
	0030	L32260:	SETZ	$V,0
	0031		SUB	$S,[000001,,000001]
  3301	0032		JRST	00,.EXT.0			;EXTERNAL


BELISTSECLASSEGROUPBLISS  V. 1.0-2.12	13-JUN-73  14:00:21	OPMOD	OUTMO1.BLI		PAGE 44-1

C	 ROUTINE ELISTSRCH(ECLASS,EGROUP)=
BBEGINC	 BEGIN
BC	 %SEARCH EACH ITEM IN GROUP POINTED TO BY EGROUP AGAINST ALL ITEMS IN CLASS
BC	 POINTED TO BY ECLASS. WHEN MATCH IS FOUND IF AT ALL, THEN LINK
BC	 ITEMS IN EGROUP INTO ECLASS IF NEITHER EGROUP NOR ECLASS IS IN COMMON.
BC	  IF EITHER (BUT NOT BOTH)ARE IN COMMON THEN ADD NEW ITEMS
BC	 NOT IN COMMON INTO COMMON BLOCK OF WHICH ECLASS OR EGROUP ITEMS ARE MEMBERS.
BC	  ERRORS OCCUR IF BOTH ECLASS AND EGROUP ARE IN COMMON.
BC	 %
BLABELELIS1ELIS2C	 LABEL ELIS1,ELIS2;
BLOCALEGSYMC	 LOCAL	EGSYM,	!SYMBOL BEING SEARCHED IN GROUP
BEGSYMPC	 	EGSYMPTR,	!PTR TO SYMBOL TABLE OF SYMBOL BING SEARCHED
BEGITEMC	 	EGITEM,	!PTR TO CURRENT EQUIVLIST ITEM IN GROUP
BCITEMC	 	CITEM,	!PTR TO LIST ITEM IN CLASS ECLASS
BCSYMPTC	 	CSYMPTR;	!PTR TO SYMBOL TABLE OF ITEM IN ECLASS
BC	 
BMAPBASEECLASSECLASSEGROUPEGSYMPCITEMCSYMPTEGITEMC	 MAP BASE ECLASS :EGROUP :EGSYMPTR :CITEM :CSYMPTR :EGITEM;
BC	 !
BXTRACIFDEGUGTHENIFDTRACENEQTHENXCALLC	 XTRAC;	!FOR DEBUGGING TRACE
BC	 !
BEGITEMEGROUPEQVFIRCW2LLEFTC	 EGITEM _ .EGROUP[EQVFIRST];	!FIRST LIST ITEM IN EGROUP
BC	 
BIFC	 IF 
BELIS1WHILEDOC	 ELIS1: (WHILE 1 DO
BBEGINC	        BEGIN
BC	 	!SEARCH FOR MATCH OF ITEM IN ECLASS WITH ITEM IN EGROUP
BEGSYMPEGITEMEQLIDCW1RRIGHTEGSYMEGSYMPIDSYMBCW3FULLC	 	EGSYMPTR _ .EGITEM[EQLID]; EGSYM _ .EGSYMPTR[IDSYMBOL]; !GET THE SYMBOL
BCITEMECLASSEQVFIRCW2LLEFTC	 	CITEM _  .ECLASS[EQVFIRST]; !THE PTR TO FIRST LIST ITEM IN ECLASS
BELIS2WHILEDOC	  ELIS2: WHILE 1 DO %2%
BBEGINC	 	BEGIN
BCSYMPTCITEMEQLIDCW1RRIGHTC	 		CSYMPTR _ .CITEM[EQLID]; !SYMBOL TABLE PTR
BIFEGSYMEQLCSYMPTIDSYMBCW3FULLC	 		IF .EGSYM EQL .CSYMPTR [IDSYMBOL]
BTHENLEAVEELIS1WITHC	 		THEN LEAVE ELIS1 WITH (-1);
BIFCITEMEQLLINCLINKRIGHTEQLC	 		IF .CITEM[EQLLINK] EQL 0
BTHENLEAVEELIS2C	 		THEN LEAVE ELIS2
BELSECITEMCITEMEQLLINCLINKRIGHTC	 		ELSE CITEM _ .CITEM[EQLLINK];
BENDC	 	END; !OF %2%
BIFEGITEMEQLLINCLINKRIGHTEQLC	 	IF .EGITEM[EQLLINK] EQL 0
BTHENLEAVEELIS1WITHC	 	THEN LEAVE ELIS1 WITH  (0)
BELSEEGITEMEGITEMEQLLINCLINKRIGHTC	 	ELSE EGITEM _ .EGITEM[EQLLINK];
BENDC	        END !OF WHILE %1%
BEQLTHENRETURNC	   )  EQL 0 THEN RETURN 0; !RETURN 0 IF NO MATCH BETWEEN ECLASS AND EGROUP
BC	 !
BC	 !WE GET HERE IF AN ITEM IN EGROUP MATCHES AN ITEM IN ECLASS
BC	 !CITEM POINTS TO THE ITEM IN ECLASS AND EGITEM POINTS TO THE
BC	 !ITEM IN EGROUP. WE NOW CHECK FOR COMMON EQUIVALENCE INTERACTION
BC	 !AND DECIDE WHETHER TO LINK THE NEW ITEMS INTO ECLASS OR TO ADD NEW ITEMS TO
BC	 !THE COMMON BLOCK OF WHICH ECLASS OR EGROUP (BUT NOT BOTH) IS A PART
BC	 !
BBEGINLOCALEGDISPELIMECDISPC	 BEGIN LOCAL EGDISPL,ELIM,ECDISPL;
BIFCSYMPTIDATTRINCOMTHENECLASSEQVINCC	 	IF .CSYMPTR[IDATTRIBUT(INCOM)] THEN ECLASS[EQVINCOM] _ 1;  !SET CLASS IN COMMON
BC	 !
BC	 !CSYMPTR CONTAINS PTR TO MATCHED SYMBOL IN ECLASS
BC	 !EGSYMPTR CONTAINS PTR TO MATCHED SYMBOL IN EGROUP
BC	 !
BELIMECLASSEQVLIMCW1RRIGHTC	 ELIM _ .ECLASS[EQVLIMIT];	!LIMIT OF GROUP
BEGDISPEGITEMEQLDISCW2FULLC	 EGDISPL _ .EGITEM[EQLDISPL];
BLISS  V. 1.0-2.12	13-JUN-73  14:00:37	OPMOD	OUTMO1.BLI		PAGE 44-2

BECDISPCITEMEQLDISCW2FULLC	 ECDISPL _ .CITEM[EQLDISPL];
BEGITEMEGROUPEQVFIRCW2LLEFTC	 EGITEM _ .EGROUP[EQVFIRST];
BEGSYMPEGITEMEQLIDCW1RRIGHTC	 EGSYMPTR _ .EGITEM[EQLID]; !SET PTR TO FIRST ITEM IN GROUP 
BC	 
BC	 !
BC	 !TEST FOR GROUP OR CLASS IN COMMON
BC	 !
BIFECLASSEQVINCOREGROUPEQVINCC	 IF .ECLASS[EQVINCOM] OR .EGROUP[EQVINCOM]
BTHENC	   THEN
BBEGINC	    BEGIN
BC	 !	IF .ECLASS[EQVINCOM] AND .EGROUP[EQVINCOM]
BC	 !	THEN ( IF .ECLASS[EQVHEAD] NEQ .EGROUP[EQVHEAD]
BC	 !		 THEN (ERROUT(48); RETURN -1;); !TWO COMMON ITEMS EQUIVALENCED
BC	 !	     )
BC	 !	ELSE
BIFEGROUPEQVINCC	 	 IF .EGROUP[EQVINCOM]
BTHENC	 	  THEN( !ASSIGN COMMON ADDRESSES TO ECLASS
BELIMEGROUPEQVLIMCW1RRIGHTC	 		ELIM _ .EGROUP[EQVLIMIT];
BEGDISPCITEMEQLDISCW2FULLECDISPEGITEMEQLDISCW2FULLC	 		EGDISPL _ .CITEM[EQLDISPL]; ECDISPL _ .EGITEM[EQLDISPL];
BCSYMPTEGITEMEQLIDCW1RRIGHTC	 		CSYMPTR _ .EGITEM[EQLID];
BEGITEMECLASSEQVFIRCW2LLEFTEGSYMPEGITEMEQLIDCW1RRIGHTC	 		EGITEM _ .ECLASS[EQVFIRST]; EGSYMPTR _ .EGITEM[EQLID];
BC	 	      );
BWHILEDOC	 	WHILE 1 DO %1%
BBEGINC	 	BEGIN
BC	   !NOW CHECK NEW COMMON ADDRESS NOW AND LINK NEW ITEM INTO EXISTING COMMON BLOCK
BIFCSYMPTNEQEGSYMPC	 	IF .CSYMPTR NEQ .EGSYMPTR
BTHENC	 	THEN
BIFNOTECLASSEQVINCANDEGROUPEQVINCC	 	  IF NOT (.ECLASS[EQVINCOM] AND .EGROUP[EQVINCOM])
BTHENIFNOTEGSYMPIDATTRINCOMC	 	  THEN IF NOT .EGSYMPTR[IDATTRIBUT(INCOM)]
BTHENC	 	     THEN
BBEGINLOCALBASECLCOMPCLCOMPGPCOMPCOMSYMC	 	        BEGIN LOCAL BASE CLCOMPTR :GPCOMPTR :COMSYM;
BIFEGSYMPIDADDRCW2RRIGHTCSYMPTIDADDRCW2RRIGHTEGITEMEQLDISCW2FULLEGDISPLSSC	 		  IF (EGSYMPTR[IDADDR] _ .CSYMPTR[IDADDR] + .EGITEM[EQLDISPL] -.EGDISPL) LSS 0
BTHENMAPBASER1R1C	 			THEN (MAP BASE R1;
BR1CSYMPTIDCOMMCW4LLEFTENTRYR1COMNAMCW1FULLRETURNERROUTC	 				R1 _ .CSYMPTR[IDCOMMON];ENTRY[1] _ R1[COMNAME];RETURN ERROUT(33)
BC	 		     );
BC	 			 !ERROR EQUIVALENCE ITEM EXTENDS COMMON BACKWARD
BC	 	
BEGSYMPIDATTRINCOMC	 		  EGSYMPTR[IDATTRIBUT(INCOM)] _ 1; !MAKE SYMBOL IN COMMON
BCLCOMPCSYMPTIDCOMMCW4LLEFTC	 		  CLCOMPTR _ .CSYMPTR[IDCOMMON]; !PTR TO COMMON BLOCK HDR
BCOMSYMCLCOMPCOMLASCW2RRIGHTC	 		  COMSYM _ .CLCOMPTR[COMLAST];	!PTR TO LAST SYMBOL IN BLOCK
BCOMSYMIDCOLICW5RRIGHTEGSYMPC	 		  COMSYM[IDCOLINK] _ .EGSYMPTR; !LINK IN NEW SYMBOL
BCLCOMPCOMLASCW2RRIGHTEGSYMPC	 		  CLCOMPTR[COMLAST] _ .EGSYMPTR;
BEGSYMPIDCOLICW5RRIGHTC	 		  EGSYMPTR[IDCOLINK] _ 0; !NEW END OF LINK
BEGSYMPIDCOMMCW4LLEFTCLCOMPC	 		  EGSYMPTR[IDCOMMON] _ .CLCOMPTR; !SYMBOL TO POINT TO BLOCK
BC	 	!  COMPUTE NEW BLOCK SIZE
BC	 	!  
BIFCLCOMPCOMSIZCW0LLEFTLSSR1EGSYMPIDADDRCW2RRIGHTELIMEGITEMEQLDISCW2FULLC	 		  IF .CLCOMPTR[COMSIZE] LSS (R1 _ .EGSYMPTR[IDADDR] +.ELIM - .EGITEM[EQLDISPL])
BTHENCLCOMPCOMSIZCW0LLEFTR1C	 		   THEN CLCOMPTR[COMSIZE] _ .R1;
BENDC	 	       END
BELSEIFEGSYMPIDADDRCW2RRIGHTEGITEMEQLDISCW2FULLC	 	    ELSE IF (.EGSYMPTR[IDADDR]-.EGITEM[EQLDISPL])
BNEQCSYMPTIDADDRCW2RRIGHTEGDISPC	 			NEQ (.CSYMPTR[IDADDR]-.EGDISPL)
BTHENEQERRLEGROUPEGROUPEQVAVARETURNC	 			THEN (EQERRLIST(.EGROUP); EGROUP[EQVAVAIL] _ 3; RETURN -1);
BC	 !
BC	 !TESTING FOR END OF CHAIN OF GROUP GOING INTO COMMON
BIFEGITEMEQLLINCLINKRIGHTEQLC	 	  IF .EGITEM[EQLLINK] EQL 0
BTHENEGROUPEQVAVAEGROUPEQVINCRETURNC	 	   THEN (EGROUP[EQVAVAIL] _ 3; EGROUP[EQVINCOM]_1;RETURN 0)
BELSEEGITEMEGITEMEQLLINCLINKRIGHTEGSYMPEGITEMEQLIDCW1RRIGHTC	 	   ELSE (EGITEM _ .EGITEM[EQLLINK]; EGSYMPTR _ .EGITEM[EQLID]);
BLISS  V. 1.0-2.12	13-JUN-73  14:00:57	OPMOD	OUTMO1.BLI		PAGE 44-3

BENDC	 	END; !OF LOOP%1%
BENDC	    END; !END OF IF INCOMMON
BC	 !
BC	 !HERE IF NEITHER GROUP NOR CLASS IN COMMON
BC	 !LINK ITEMS IN EGROUP INTO ECLASS, MARK EACH GROUP UNAVAILABLE
BC	 !CHECK FOR ERRORS OF FORM
BC	 ! EQUIVALENCE (A(5),B(2)),(C(2),B(2)),(C(2),A(4))
BC	 !
BEGITEMEGROUPEQVFIRCW2LLEFTC	 EGITEM _ .EGROUP[EQVFIRST];
BWHILEDOC	 WHILE 1 DO
BBEGINLOCALENEXITNEWDISC	 BEGIN LOCAL ENEXITEM,NEWDISPL;
BENEXITEGITEMEQLLINCLINKRIGHTC	 	ENEXITEM _ .EGITEM[EQLLINK];  !PTR TO NEXT ITEM IN GROUP TO BE LINKED TO CLASS
BEGSYMPEGITEMEQLIDCW1RRIGHTC	 	EGSYMPTR _ .EGITEM[EQLID];
BEGSYMEGSYMPIDSYMBCW3FULLC	 	EGSYM _ .EGSYMPTR[IDSYMBOL];
BC	 
BC	 !NOW SEARCH FOR EGSYM IN ECLASS
BC	 !
BCITEMECLASSEQVFIRCW2LLEFTC	 	CITEM _ .ECLASS[EQVFIRST];	!PTR TO FIRST ITEM IN CLASS
BNEWDISECDISPEGITEMEQLDISCW2FULLEGDISPC	 	NEWDISPL _ .ECDISPL + .EGITEM[EQLDISPL] -.EGDISPL;
BIFWHILEDOC	 	IF WHILE 1 DO
BBEGINC	 	   BEGIN   %2%
BCSYMPTCITEMEQLIDCW1RRIGHTC	 		CSYMPTR _ .CITEM[EQLID];
BIFEGSYMEQLCSYMPTIDSYMBCW3FULLC	 		IF .EGSYM EQL .CSYMPTR[IDSYMBOL]
BTHENEXITLOC	 		  THEN EXITLOOP (-1);
BIFCITEMEQLLINCLINKRIGHTEQLC	 		IF .CITEM[EQLLINK] EQL 0
BTHENEXITLOC	 		  THEN EXITLOOP (0)
BELSECITEMCITEMEQLLINCLINKRIGHTC	 		  ELSE CITEM _ .CITEM[EQLLINK]
BENDC	 	   END  !OF %2%
BNEQC	 	NEQ 0
BTHENC	 	  THEN	!MAKE SURE DISPLACEMENTS OF MATCHING ITMES ARE OK
BIFNEWDISNEQCITEMEQLDISCW2FULLC	 	    (	IF .NEWDISPL NEQ .CITEM[EQLDISPL]
BTHENEQERRLEGROUPC	 		  THEN (EQERRLIST(.EGROUP); !INCONSISTENT OR CONFLICTING EQUIVALENCES
BEGROUPEQVAVARETURNC	 			EGROUP[EQVAVAIL] _ 3; RETURN -1
BC	 		       );
BC	 	    )
BELSECITEMEQLLINCLINKRIGHTEGITEMC	 	  ELSE	(CITEM[EQLLINK] _ .EGITEM;
BC	 		);
BEGITEMEQLLINCLINKRIGHTC	 	EGITEM[EQLLINK] _ 0;	!CLEAR LINK
BEGITEMEQLDISCW2FULLNEWDISC	 	EGITEM[EQLDISPL] _ .NEWDISPL;
BIFNEWDISLSSECLASSEQVADDCW3FULLC	 	IF .NEWDISPL LSS .ECLASS[EQVADDR]
BTHENECLASSEQVADDCW3FULLNEWDISC	 	  THEN ECLASS[EQVADDR] _ .NEWDISPL;
BC	 !
BC	 !NOW COMPUTE NEW EQVLIMIT
BC	 !
BBEGINLOCALBASEESYMESYMEQSIZC	 	BEGIN LOCAL BASE ESYM, EQSIZ;
BEQSIZIFEGSYMPIDDIMCW0LLEFTNEQC	 	  EQSIZ _ IF .EGSYMPTR[IDDIM] NEQ 0
BTHENESYMEGSYMPIDDIMCW0LLEFTESYMARASIZRIGHTC	 			THEN (ESYM _ .EGSYMPTR[IDDIM]; .ESYM[ARASIZ])
BELSEIFEGSYMPDBLFLGEXOPWDTHENELSEC	 			ELSE IF .EGSYMPTR[DBLFLG] THEN 2 ELSE 1;
BIFEGITEMEQLDISCW2FULLEQSIZGTRECLASSEQVLIMCW1RRIGHTC	 	  IF (.EGITEM[EQLDISPL] + .EQSIZ) GTR .ECLASS[EQVLIMIT]
BTHENECLASSEQVLIMCW1RRIGHTEGITEMEQLDISCW2FULLEQSIZC	 		THEN ECLASS[EQVLIMIT] _ (.EGITEM[EQLDISPL] + .EQSIZ);
BENDC	 	END;
BIFENEXITEQLTHENRETURNC	 	IF .ENEXITEM EQL 0 THEN RETURN 1  !GOOD RETURN (ALLITEMS IN EGROUP LINKED TO ECLASS)
BELSEEGITEMENEXITC	 		 ELSE EGITEM _ .ENEXITEM;
BENDC	 END; !OF %1%
BENDC	 END;
BENDC	 END;	!OF ROUTINE ELISTSRCH
BROUTIND
BLISS  V. 1.0-2.12	13-JUN-73  14:01:14	OPMOD	OUTMO1.BLI		PAGE 44-4


	0000		JSP	07,.ENT.0			;EXTERNAL
  3303	0001		ADD	$S,[000005,,000005]
	0002		MOVE	$V,-2($F)			;FORMAL
  3322	0003		HLRZ	04,2($V)
	0004		MOVEM	04,3($F)			;LOCAL
  3326	0005	L33512:	MOVE	$V,3($F)			;LOCAL
	0006		HRRZ	05,1($V)
	0007		MOVEM	05,2($F)			;LOCAL
  3328	0010		MOVE	06,3(05)
	0011		MOVEM	06,1($F)			;LOCAL
	0012		MOVE	$V,-3($F)			;FORMAL
  3329	0013		HLRZ	07,2($V)
	0014		MOVEM	07,4($F)			;LOCAL
  3331	0015	L30674:	MOVE	$V,4($F)			;LOCAL
  3332	0016		HRRZ	04,1($V)
	0017		MOVEM	04,5($F)			;LOCAL
  3333	0020		MOVE	05,3(04)
	0021		CAME	05,1($F)			;LOCAL
	0022		JRST	00,L34450
	0023		SETO	$V,0
	0024		JRST	00,L34452
	0025	L34450:	MOVE	$V,4($F)			;LOCAL
  3335	0026		HRRZ	07,0($V)
	0027		JUMPN	07,L32270
	0030		JRST	00,L36220
	0031		JRST	00,L30674  ^^^
  3337	0032	L32270:	HRRZ	05,0($V)
	0033		MOVEM	05,4($F)			;LOCAL
  3338	0034		JRST	00,L30674  ^^^
	0035	L36220:	MOVE	$V,3($F)			;LOCAL
  3339	0036		HRRZ	05,0($V)
	0037		JUMPN	05,L30600
	0040		SETZ	$V,0
	0041		JRST	00,L34452
  3341	0042	L30600:	HRRZ	07,0($V)
	0043		MOVEM	07,3($F)			;LOCAL
	0044		JRST	00,L33512  ^^^
	0045	L34452:	JUMPN	$V,L34454
	0046		JRST	00,L31672
	0047		JRST	00,L34726
	0050	L34454:	ADD	$S,[000003,,000003]
  3351	0051		MOVE	$V,5($F)			;LOCAL
	0052		MOVE	04,1($V)
	0053		TLNN	04,400
	0054		JRST	00,L32426
	0055		MOVE	$V,-3($F)			;FORMAL
  3352	0056		MOVEI	05,1
	0057		DPB	05,[430115,,000000]
	0060	L32426:	MOVE	$V,-3($F)			;FORMAL
  3357	0061		HRRZ	05,1($V)
	0062		MOVEM	05,7($F)			;LOCAL
	0063		MOVE	$V,3($F)			;LOCAL
  3358	0064		MOVE	06,2($V)
	0065		MOVEM	06,6($F)			;LOCAL
	0066		MOVE	$V,4($F)			;LOCAL
  3359	0067		MOVE	07,2($V)
BLISS  V. 1.0-2.12	13-JUN-73  14:01:14	OPMOD	OUTMO1.BLI		PAGE 44-5

	0070		MOVEM	07,10($F)			;LOCAL
	0071		MOVE	$V,-2($F)			;FORMAL
  3360	0072		HLRZ	04,2($V)
	0073		MOVEM	04,3($F)			;LOCAL
  3361	0074		HRRZ	05,1(04)
	0075		MOVEM	05,2($F)			;LOCAL
	0076		MOVE	$V,-3($F)			;FORMAL
  3366	0077		MOVE	06,-2($F)			;FORMAL
  3367	0100		LDB	07,[430115,,000000]
	0101		LDB	04,[430106,,000000]
	0102		IOR	07,4
	0103		TRNN	07,1
	0104		JRST	00,L32160
  3368	0105		MOVE	05,0(06)
	0106		TLNN	05,-400000
	0107		JRST	00,L36264
  3376	0110		HRRZ	04,1(06)
	0111		MOVEM	04,7($F)			;LOCAL
	0112		MOVE	$V,4($F)			;LOCAL
	0113		MOVE	07,2($V)
	0114		MOVEM	07,6($F)			;LOCAL
	0115		MOVE	$V,3($F)			;LOCAL
  3377	0116		MOVE	05,2($V)
	0117		MOVEM	05,10($F)			;LOCAL
  3378	0120		HRRZ	06,1($V)
	0121		MOVEM	06,5($F)			;LOCAL
	0122		MOVE	$V,-3($F)			;FORMAL
	0123		HLRZ	04,2($V)
	0124		MOVEM	04,3($F)			;LOCAL
  3379	0125		HRRZ	07,1(04)
	0126		MOVEM	07,2($F)			;LOCAL
  3380	0127	L36264:	MOVE	04,2($F)			;LOCAL
	0130		CAMN	04,5($F)			;LOCAL
	0131		JRST	00,L31730
	0132		MOVE	$V,-3($F)			;FORMAL
	0133		MOVE	06,-2($F)			;FORMAL
  3386	0134		LDB	05,[430115,,000000]
	0135		LDB	$V,[430106,,000000]
	0136		AND	05,15
	0137		TRNE	05,1
	0140		JRST	00,L31730
	0141		MOVE	07,1(04)
	0142		TLNE	07,400
	0143		JRST	00,L33706
	0144		ADD	$S,[000003,,000003]
  3389	0145		MOVE	$V,5($F)			;LOCAL
	0146		MOVE	06,3($F)			;LOCAL
	0147		HRRZ	05,2($V)
	0150		ADD	05,2(06)
	0151		SUB	05,6($F)			;LOCAL
	0152		HRRM	05,2(04)
  3390	0153		JUMPGE	05,L33730
  3391	0154		HLRZ	01,4($V)
	0155		HRRZI	06,1(01)
	0156		HRLI	06,4400
	0157		MOVEM	06,ENTRY+1			;EXTERNAL
  3392	0160		PUSH	$S,[41]
BLISS  V. 1.0-2.12	13-JUN-73  14:01:19	OPMOD	OUTMO1.BLI		PAGE 44-6

	0161		PUSHJ	$S,ERROUT			;EXTERNAL
	0162		SUB	$S,[000014,,000014]
	0163		JRST	00,L32544
  3393	0164	L33730:	MOVE	$V,2($F)			;LOCAL
  3396	0165		MOVEI	06,1
	0166		DPB	06,[320115,,000001]
	0167		MOVE	$V,5($F)			;LOCAL
  3397	0170		HLRZ	04,4($V)
	0171		MOVEM	04,11($F)			;LOCAL
  3398	0172		HRRZ	05,2(04)
	0173		MOVEM	05,13($F)			;LOCAL
  3399	0174		MOVE	07,2($F)			;LOCAL
	0175		HRRM	07,5(05)
  3400	0176		HRRM	07,2(04)
  3401	0177		HLLZS	00,5(07)
  3402	0200		HRLM	04,4(07)
	0201		MOVE	$V,3($F)			;LOCAL
  3405	0202		HRRZ	06,2(07)
	0203		ADD	06,7($F)			;LOCAL
	0204		SUB	06,2($V)
	0205		MOVE	01,6
	0206		HLRZ	05,0(04)
	0207		CAMLE	01,5
  3406	0210		HRLM	01,0(04)
	0211		SUB	$S,[000003,,000003]
	0212		JRST	00,L31730
	0213	L33706:	MOVE	$V,3($F)			;LOCAL
  3408	0214		HRRZ	06,2(04)
	0215		SUB	06,2($V)
	0216		MOVE	$V,5($F)			;LOCAL
  3409	0217		HRRZ	05,2($V)
	0220		SUB	05,6($F)			;LOCAL
	0221		CAMN	06,5
	0222		JRST	00,L31730
	0223		PUSH	$S,-2($F)			;FORMAL
	0224		PUSHJ	$S,EQERRLIST
	0225		SUB	$S,[000001,,000001]
	0226		MOVE	$V,-2($F)			;FORMAL
	0227		MOVEI	04,3
	0230		DPB	04,[410215,,000000]
	0231		SETO	$V,0
	0232		JRST	00,L32014
  3410	0233	L31730:	MOVE	$V,3($F)			;LOCAL
  3413	0234		HRRZ	06,0($V)
	0235		JUMPN	06,L32654
	0236		MOVE	$V,-2($F)			;FORMAL
	0237		MOVEI	04,3
	0240		DPB	04,[410215,,000000]
	0241		MOVEI	07,1
	0242		DPB	07,[430115,,000000]
	0243		SETZ	$V,0
	0244	L32014:	SUB	$S,[000010,,000010]
	0245		JRST	00,L32544
	0246	L32654:	HRRZ	04,0($V)
	0247		MOVEM	04,3($F)			;LOCAL
	0250		HRRZ	$V,1(04)
	0251		MOVEM	$V,2($F)			;LOCAL
BLISS  V. 1.0-2.12	13-JUN-73  14:01:21	OPMOD	OUTMO1.BLI		PAGE 44-7

  3416	0252		JRST	00,L36264  ^^^
	0253	L32160:	MOVE	$V,-2($F)			;FORMAL
  3424	0254		HLRZ	05,2($V)
	0255		MOVEM	05,3($F)			;LOCAL
	0256	L36306:	ADD	$S,[000002,,000002]
  3426	0257		MOVE	$V,3($F)			;LOCAL
  3427	0260		HRRZ	06,0($V)
	0261		MOVEM	06,11($F)			;LOCAL
  3428	0262		HRRZ	04,1($V)
	0263		MOVEM	04,2($F)			;LOCAL
  3429	0264		MOVE	07,3(04)
	0265		MOVEM	07,1($F)			;LOCAL
	0266		MOVE	$V,-3($F)			;FORMAL
  3433	0267		HLRZ	05,2($V)
	0270		MOVEM	05,4($F)			;LOCAL
	0271		MOVE	$V,3($F)			;LOCAL
  3434	0272		MOVE	06,2($V)
	0273		ADD	06,10($F)			;LOCAL
	0274		SUB	06,6($F)			;LOCAL
	0275		MOVEM	06,12($F)			;LOCAL
  3436	0276	L36360:	MOVE	$V,4($F)			;LOCAL
  3437	0277		HRRZ	04,1($V)
	0300		MOVEM	04,5($F)			;LOCAL
  3438	0301		MOVE	07,3(04)
	0302		CAME	07,1($F)			;LOCAL
	0303		JRST	00,L32552
	0304		SETO	$V,0
	0305		JRST	00,L34326
	0306	L32552:	MOVE	$V,4($F)			;LOCAL
  3440	0307		HRRZ	06,0($V)
	0310		JUMPN	06,L33302
	0311		SETZ	$V,0
	0312		JRST	00,L34326
  3442	0313	L33302:	HRRZ	07,0($V)
	0314		MOVEM	07,4($F)			;LOCAL
	0315		MOVE	$V,7
	0316		MOVEI	07,1
	0317		CAIN	$V,0
	0320		SETZ	07,0
	0321		JRST	00,L36360  ^^^
	0322	L34326:	TRNN	$V,1
	0323		JRST	00,L32576
  3446	0324		MOVE	$V,4($F)			;LOCAL
	0325		MOVE	05,2($V)
	0326		CAMN	05,12($F)			;LOCAL
	0327		JRST	00,L33364
	0330		PUSH	$S,-2($F)			;FORMAL
	0331		PUSHJ	$S,EQERRLIST
	0332		SUB	$S,[000001,,000001]
  3447	0333		MOVE	$V,-2($F)			;FORMAL
	0334		MOVEI	04,3
	0335		DPB	04,[410215,,000000]
	0336		SETO	$V,0
	0337		JRST	00,L34322
  3449	0340	L32576:	MOVE	$V,4($F)			;LOCAL
  3451	0341		MOVE	05,3($F)			;LOCAL
	0342		HRRM	05,0($V)
BLISS  V. 1.0-2.12	13-JUN-73  14:01:22	OPMOD	OUTMO1.BLI		PAGE 44-8

  3452	0343	L33364:	MOVE	$V,3($F)			;LOCAL
  3453	0344		HLLZS	00,0($V)
  3454	0345		MOVE	05,12($F)			;LOCAL
	0346		MOVEM	05,2($V)
  3455	0347		MOVE	$V,-3($F)			;FORMAL
	0350		CAMGE	05,3($V)
  3456	0351		MOVEM	05,3($V)
	0352		ADD	$S,[000002,,000002]
  3460	0353		MOVE	$V,2($F)			;LOCAL
  3461	0354		HLRZ	04,0($V)
	0355		JUMPE	04,L37024
	0356		HLRZ	05,0($V)
	0357		MOVEM	05,13($F)			;LOCAL
	0360		HRRZ	$V,0(05)
	0361		JRST	00,L36062
	0362	L37024:	MOVE	05,1($V)
	0363		TRNN	05,200000
	0364		JRST	00,L34566
	0365		MOVEI	$V,2
	0366		JRST	00,L36062
	0367	L34566:	MOVEI	$V,1
	0370	L36062:	MOVEM	$V,14($F)			;LOCAL
	0371		MOVE	$V,3($F)			;LOCAL
	0372		MOVE	05,14($F)			;LOCAL
	0373		ADD	05,2($V)
  3464	0374		MOVE	$V,-3($F)			;FORMAL
	0375		HRRZ	06,1($V)
	0376		CAMG	05,6
	0377		JRST	00,L34620
	0400		MOVE	07,3($F)			;LOCAL
	0401		MOVE	05,14($F)			;LOCAL
	0402		ADD	05,2(07)
  3465	0403		HRRM	05,1($V)
	0404	L34620:	SUB	$S,[000002,,000002]
  3466	0405		SKIPE	07,11($F)			;LOCAL
	0406		JRST	00,L33370
	0407		MOVEI	$V,1
	0410	L34322:	SUB	$S,[000012,,000012]
	0411		JRST	00,L32544
  3468	0412	L33370:	MOVEM	07,3($F)			;LOCAL
	0413		SUB	$S,[000002,,000002]
  3469	0414		JRST	00,L36306  ^^^
  3470	0415	L31672:	SETZ	$V,0
	0416	L34726:	SUB	$S,[000005,,000005]
  3471	0417	L32544:	JRST	00,.EXT.0			;EXTERNAL


BEQCALLECLASSBLISS  V. 1.0-2.12	13-JUN-73  14:01:24	OPMOD	OUTMO1.BLI		PAGE 45-1

C	 ROUTINE EQCALLOC(ECLASS)=
BBEGINC	 BEGIN
BC	 %
BC	 ALLOCATE RELOCATABLE ADDRESSES TO AN EQUIVALENCE CLASS (ECLASS)
BC	 %
BEXTERNLOWLOCC	 EXTERNAL LOWLOC;	!THE LOW SEG AVAILABLE LOCATION
BMAPBASEECLASSECLASSC	 MAP BASE ECLASS;
BLOCALBASECITEMCITEMCSYMPTC	 LOCAL BASE CITEM :CSYMPTR;
BLOCALTLOCC	 LOCAL TLOC;
BOWNCNTC	 OWN CNT;
BC	 %
BC	 THE ADDRESS OF ANITEM IN ECLASS IS COMPUTED AS FOLLOWS
BC	  ADDR _ .LOWLOC + (RELATIVE DISPLACEMENT OF ITEM IN ECLASS (CITEM[EQLDISPL] 
BC	 		- SMALLEST RELATIVE DISPLACEMENT IN ECLASS (ECLASS[EQVADDR])
BC	 %
BCNTC	 CNT _ 0;
BIFFLGREGLISTINTHENZOUTMSPLITC	 IF .FLGREG<LISTING> THEN ZOUTMSG(PLIT '?M?J( ?0');
BTLOCLOWLOCECLASSEQVADDCW3FULLC	 TLOC _ .LOWLOC - .ECLASS[EQVADDR];
BCITEMECLASSEQVFIRCW2LLEFTC	 CITEM _ .ECLASS[EQVFIRST];
BWHILEDOC	 WHILE 1 DO
BBEGINC	 BEGIN
BCSYMPTCITEMEQLIDCW1RRIGHTC	 	CSYMPTR _ .CITEM[EQLID];	!PTR TO SYMBOL
BCSYMPTIDADDRCW2RRIGHTCITEMEQLDISCW2FULLTLOCC	 	CSYMPTR[IDADDR] _ .CITEM[EQLDISPL] + .TLOC;
BIFFLGREGLISTINC	 	IF .FLGREG<LISTING>
BTHENLISTSYCSYMPTC	 	THEN(LISTSYM(.CSYMPTR);
BIFCNTLSSTHENCNTCNTC	 	     IF .CNT LSS 5 THEN CNT _ .CNT+1
BELSECNTCRLFC	 		ELSE (CNT _ 0; CRLF());
BC	 	    );
BIFCITEMEQLLINCLINKRIGHTEQLC	 	IF .CITEM[EQLLINK] EQL 0
BTHENEXITLOELSECITEMCITEMEQLLINCLINKRIGHTC	 	  THEN EXITLOOP ELSE CITEM _ .CITEM[EQLLINK];
BENDC	 END;
BLOWLOCLOWLOCECLASSEQVLIMCW1RRIGHTECLASSEQVADDCW3FULLC	 LOWLOC _ .LOWLOC + .ECLASS[EQVLIMIT] - .ECLASS[EQVADDR];
BC	 !
BC	 !LOWLOC + SPAN OF THE CLASS
BC	 !
BENDC	 END;	!OF EQCALOC
BROUTIND

	0000		JSP	07,.ENT.0			;EXTERNAL
  3473	0001		ADD	$S,[000003,,000003]
  3477	0002		SETZM	00,OPMO.O+2
	0003		MOVE	04,0
	0004		TRNN	04,2000
	0005		JRST	00,L32216
	0006		PUSH	$S,[004400,,OPMO.P+27]
	0007		PUSHJ	$S,ZOUTMSG
	0010		SUB	$S,[000001,,000001]
  3488	0011	L32216:	MOVE	$V,-2($F)			;FORMAL
  3489	0012		MOVE	05,LOWLOC			;EXTERNAL
	0013		SUB	05,3($V)
	0014		MOVEM	05,3($F)			;LOCAL
  3490	0015		HLRZ	06,2($V)
	0016		MOVEM	06,1($F)			;LOCAL
  3492	0017	L33762:	MOVE	$V,1($F)			;LOCAL
  3493	0020		HRRZ	07,1($V)
	0021		MOVEM	07,2($F)			;LOCAL
  3494	0022		MOVE	04,3($F)			;LOCAL
BLISS  V. 1.0-2.12	13-JUN-73  14:01:46	OPMOD	OUTMO1.BLI		PAGE 45-2

	0023		ADD	04,2($V)
	0024		HRRM	04,2(07)
	0025		MOVE	05,0
	0026		TRNN	05,2000
	0027		JRST	00,L34724
	0030		PUSH	$S,7
	0031		PUSHJ	$S,LISTSYM
	0032		SUB	$S,[000001,,000001]
  3496	0033		MOVE	06,OPMO.O+2
	0034		CAIL	06,5
	0035		JRST	00,L32530
  3497	0036		AOS	$V,OPMO.O+2
	0037		JRST	00,L34724
	0040	L32530:	SETZM	00,OPMO.O+2
	0041		PUSHJ	$S,CRLF
  3498	0042	L34724:	MOVE	$V,1($F)			;LOCAL
  3500	0043		HRRZ	06,0($V)
	0044		JUMPN	06,L34404
	0045		JRST	00,L33434
	0046		JRST	00,L33762  ^^^
  3501	0047	L34404:	HRRZ	04,0($V)
	0050		MOVEM	04,1($F)			;LOCAL
  3502	0051		JRST	00,L33762  ^^^
	0052	L33434:	MOVE	$V,-2($F)			;FORMAL
	0053		MOVE	04,-2($F)			;FORMAL
  3503	0054		HRRZ	05,1($V)
	0055		ADD	05,LOWLOC			;EXTERNAL
	0056		SUB	05,3(04)
	0057		MOVEM	05,LOWLOC			;EXTERNAL
	0060		SETZ	$V,0
	0061		SUB	$S,[000003,,000003]
  3507	0062		JRST	00,.EXT.0			;EXTERNAL


BPROCEQBLISS  V. 1.0-2.12	13-JUN-73  14:01:46	OPMOD	OUTMO1.BLI		PAGE 46-1

C	 ROUTINE PROCEQUIV=
BBEGINC	 BEGIN
BC	 %PROCESSES EQUIVALNCE GROUPS AS DECLARED IN THE SOURCE -N RESOLVING
BC	 IMPLICIT EQUIVALENCES AND EQUIVALENCES INTO COMMON. CHECKS FOR
BC	 ALLOCATION ERRORS DUE TO IMPROPER EQUIVALENCES. ASSIGNS TEMPORARY
BC	 ADDRESSES TO EQUIVALENCE VARIABLES AND NEW VARIABLES EQUIVALENCED INTO COMMON.
BC	 %
BEXTERNEQVPTREQVPTRC	 EXTERNAL EQVPTR,	!PTR TO FIRST AND LAST EQUIVALENCE GROUPS
BARRXPNC	 	ARRXPN,	!FOR EXPANDING ARRAY REFERENCES IN EQUIVALENCE ITEMS
BZOUTMSZOUTMSC	 	ZOUTMSG,	!MESSAGE OUTPUTTER
BELISTSELISTSC	 	ELISTSRCH,	!ROUTINE THAT SEARCHES FOR A MATCH OF ONE ITEM
BC	 			!IN A CLASS IN ANY AVAILABLE GROUP
BEQCALLEQCALLC	 	EQCALLOC;	!ALLOCATION OF EQUIVALENCE CLASSES
BLOCALBASEEQVCPTEQVCPTC	 LOCAL BASE EQVCPTR,	!PTR TO CURRENT EQUIV CLASS HEADER
BECOMMPC	 	ECOMMPTR,	!PTR COMMON ITEM IF GROUP IS IN COMMON
BECOMMHC	 	ECOMMHDR,	!PTR TO COMMON BLOCK HDR
BLCLHDC	 	LCLHD;	!PTR TO LOCAL HEAD OF A GROUP FOR ALLOCATION PURPOSES
BREGISTBASEEQLPTREQLPTRC	 REGISTER BASE EQLPTR;
BLABELCOMN1LOOP2C	 LABEL COMN1,LOOP2;
BC	 
BC	 !
BC	 !THE FIRST STEP IS TO COMPUTE RELATIVE DISPLACEMENTS OF EACH ITEM IN
BC	 !AND EQUIVALENCE GROUP. THIS IS SIMPLY 1 MINUS THE SUBSCRIPT
BC	 !VALUE OF EACH ITEM IN THE GROUP.
BC	 !I.E A(1) HAS DISPLACEMENT 0 AND A(4) HAS DISPLACEMENT -3
BC	 !
BIFFLGREGLISTINTHENZOUTMSPLITC	 IF .FLGREG<LISTING> THEN ZOUTMSG(PLIT'?M?JEQUIVALENCED VARIABLES?M?J?0');
BEQVCPTEQVPTRLEFTC	 EQVCPTR _ .EQVPTR<LEFT>;	!PTR TO FIRST GROUP
BWHILEDOC	 WHILE 1 DO	%1%
BBEGINC	 BEGIN
BECOMMPC	 	ECOMMPTR _ 0;	!INITIALIZING
BC	 	!IF GROUP IS IN COMMON THEN FIND THE ELEMENT IN COMMON
BCOMN1IFEQVCPTEQVINCC	     COMN1: IF .EQVCPTR[EQVINCOM]
BTHENLOCALBASECOMPTRCOMPTRC	 	THEN(	LOCAL BASE COMPTR;
BEQLPTREQVCPTEQVHEACW1LLEFTC	 			EQLPTR _ .EQVCPTR[EQVHEAD]; !PTR TO LIST ITEM THAT IS IN COMMON
BCOMPTREQLPTREQLIDCW1RRIGHTC	 			COMPTR_ .EQLPTR[EQLID];
BECOMMPEQLPTRC	 			ECOMMPTR _ .EQLPTR; !PTR TO COMMON ITEM EQL LIST ITEM
BECOMMHCOMPTRIDCOMMCW4LLEFTC	 			ECOMMHDR _ .COMPTR[IDCOMMON];
BLCLHDEQLPTREQLIDCW1RRIGHTC	 			LCLHD _ .EQLPTR[EQLID];
BC	 	     )
BELSELCLHDC	 	ELSE LCLHD _ 0;
BEQLPTREQVCPTEQVFIRCW2LLEFTC	     EQLPTR _ .EQVCPTR[EQVFIRST]; !PTR TO FIRST ITEM IN GROUP
BR2R1C	     R2 _ R1 _ 0;	!EQVLIMIT IN R2, SMALLEST DISPLACEMENT IN R1
BLOOP2WHILEDOC	     LOOP2: WHILE 1 DO %2%
BBEGINC	        BEGIN
BIFEQLPTREQLINDNEQC	 	IF .EQLPTR[EQLINDIC] NEQ 0
BTHENLOCALBASEPT1PT1C	 	THEN (LOCAL BASE PT1;
BEQLPTREQLINDC	 		EQLPTR[EQLINDIC] _ 0;
BPT1ARRXPNEQLPTREQLIDCW1RRIGHTEQLPTREQLLISCW1LLEFTC	 		 PT1 _ ARRXPN(.EQLPTR[EQLID],.EQLPTR[EQLLIST]);
BEQLPTREQLDISCW2FULLEXTSIGBEGINREGISTAA1AA1PT1TARGETWHOLEHRREIAA1AA1ENDC	 		EQLPTR[EQLDISPL] _ -(EXTSIGN(.PT1[TARGET])); !GET - DISPLACEMENT
BC	 	     );
BC	 !
BC	 !
BC	 !NOW CHECK FOR NEW EQVLIMIT (R2) FOR THIS GROUP
BBEGINLOCALBASEESYMESYMEQSIZC	 	BEGIN LOCAL BASE ESYM, EQSIZ;
BESYMEQLPTREQLIDCW1RRIGHTC	 	   ESYM _ .EQLPTR[EQLID]; !PTR TO SYMBOL TABLE
BC	 	!
BLISS  V. 1.0-2.12	13-JUN-73  14:01:55	OPMOD	OUTMO1.BLI		PAGE 46-2

BEQSIZIFESYMIDDIMCW0LLEFTNEQC	 	   EQSIZ _ IF .ESYM[IDDIM] NEQ 0
BTHENESYMESYMIDDIMCW0LLEFTESYMARASIZRIGHTC	 			THEN (ESYM _.ESYM[IDDIM]; .ESYM[ARASIZ])
BELSEIFESYMDBLFLGEXOPWDTHENELSEC	 			ELSE IF .ESYM[DBLFLG] THEN 2 ELSE 1;
BIFEQLPTREQLDISCW2FULLEQSIZGTRR2C	 	   IF (.EQLPTR[EQLDISPL] + .EQSIZ) GTR .R2 %EQVLIMIT%
BTHENR2EQLPTREQLDISCW2FULLEQSIZC	 		THEN R2 _ (.EQLPTR[EQLDISPL] +.EQSIZ);
BENDC	 	END;
BC	 !
BC	 !NOW CHECK FOR NEW MIN(R(I)) RELATIVE DISPLACEMENT
BC	 !
BIFEQLPTREQLDISCW2FULLLSSR1C	 	IF .EQLPTR[EQLDISPL] LSS .R1
BTHENR1EQLPTREQLDISCW2FULLLCLHDEQLPTREQLIDCW1RRIGHTC	 		THEN (R1 _ .EQLPTR[EQLDISPL]; LCLHD _ .EQLPTR[EQLID]);
BIFECOMMPNEQC	 	IF .ECOMMPTR NEQ 0
BTHENIFEQLPTRNEQECOMMPC	 	  THEN IF .EQLPTR NEQ .ECOMMPTR
BTHENLOCALBASELINKLINKCOMC	 		THEN(	LOCAL BASE LINK:COM;
BMAPBASEECOMMHECOMMHECOMMPC	 			MAP BASE ECOMMHDR :ECOMMPTR;
BLINKEQLPTREQLIDCW1RRIGHTC	 			LINK _ .EQLPTR[EQLID];
BCOMECOMMPEQLIDCW1RRIGHTC	 			COM _ .ECOMMPTR[EQLID];	!PTR TO ITEM IN CO MMON
BIFNOTLINKIDATTRINCOMC	 			IF NOT .LINK[IDATTRIBUT(INCOM)] 
BTHENC	 			THEN(
BLINKECOMMHCOMLASCW2RRIGHTC	 				LINK _ .ECOMMHDR[COMLAST];
BECOMMHCOMLASCW2RRIGHTEQLPTREQLIDCW1RRIGHTC	 				ECOMMHDR[COMLAST] _ .EQLPTR[EQLID];
BLINKLINKIDCOLICW5RRIGHTEQLPTREQLIDCW1RRIGHTC	 				LINK _ LINK[IDCOLINK] _ .EQLPTR[EQLID]; !PTR TO SYMBOL TABLES NODE
BLINKIDATTRINCOMC	 				LINK[IDATTRIBUT(INCOM)] _ 1; !SET IN COMMON
BLINKIDCOMMCW4LLEFTECOMMHC	 				LINK[IDCOMMON] _ .ECOMMHDR;
BLINKIDCOLICW5RRIGHTC	 				LINK[IDCOLINK] _ 0;
BIFLINKIDADDRCW2RRIGHTEQLPTREQLDISCW2FULLECOMMPEQLDISCW2FULLCOMIDADDRCW2RRIGHTLSSC	 				IF (LINK[IDADDR] _ (.EQLPTR[EQLDISPL] - .ECOMMPTR[EQLDISPL] + .COM[IDADDR]) ) LSS 0
BTHENENTRYECOMMHCOMNAMCW1FULLERROUTC	 				THEN (ENTRY[1] _ ECOMMHDR[COMNAME]; ERROUT(33);
BLEAVELOOP2C	 					LEAVE LOOP2;
BC	 				     );
BIFECOMMHCOMSIZCW0LLEFTLSSLINKIDADDRCW2RRIGHTR2EQLPTREQLDISCW2FULLC	 				IF .ECOMMHDR[COMSIZE] LSS (.LINK[IDADDR] +.R2 - .EQLPTR[EQLDISPL])
BTHENECOMMHCOMSIZCW0LLEFTLINKIDADDRCW2RRIGHTR2EQLPTREQLDISCW2FULLC	 				THEN ECOMMHDR[COMSIZE] _(.LINK[IDADDR] +.R2 - .EQLPTR[EQLDISPL]);
BC	 			)
BELSEIFCOMIDADDRCW2RRIGHTECOMMPEQLDISCW2FULLNEQLINKIDADDRCW2RRIGHTEQLPTREQLDISCW2FULLC	 		         ELSE IF (.COM[IDADDR]-.ECOMMPTR[EQLDISPL]) NEQ (.LINK[IDADDR]-.EQLPTR[EQLDISPL])
BTHENEQERRLEQVCPTEQVCPTEQVAVALEAVELOOP2C	 				THEN (EQERRLIST(.EQVCPTR); EQVCPTR[EQVAVAIL] _ 3;LEAVE LOOP2);
BC	 	!
BC	 	!CHECKING THE DECLARATIONS FOR VIOLATING BEGINNING OF COMMON BLOCK
BC	 	!
BC	 		    );
BC	 !
BC	 !CHECKING FOR END OF CHAIN OF ITEMS
BC	 !
BIFEQLPTREQLLINCLINKRIGHTEQLC	 	IF .EQLPTR[EQLLINK] EQL 0
BTHENEXITLOC	 	THEN EXITLOOP	!END OF CHAIN
BELSEEQLPTREQLPTREQLLINCLINKRIGHTC	 	ELSE EQLPTR _ .EQLPTR[EQLLINK]
BENDC	     END; !OF WHILE %2%
BC	 !
BEQVCPTEQVADDCW3FULLR1C	     EQVCPTR[EQVADDR] _ .R1;	!LOWEST RELATIVE DISPLACEMENT
BC	 
BC	 !    EQVCPTR[EQVHEAD] _ .LCLHD;	!PTR TO HED OF GROUP
BC	 
BEQVCPTEQVLIMCW1RRIGHTR2C	     EQVCPTR[EQVLIMIT] _ .R2;	!SPAN OF GROUP RELATIVE TO 0
BC	 !
BC	 !REAL SPAN (#OF WORDS OCCUPIED BY ALL ELEMNTS OF GROUP)
BC	 !IS EQVLIMIT - EQVADDR
BC	 !
BIFEQVCPTEQVLINCLINKRIGHTEQLC	     IF .EQVCPTR[EQVLINK] EQL 0
BTHENEXITLOC	     THEN EXITLOOP	!END OF CHAIN OF GROUPS
BLISS  V. 1.0-2.12	13-JUN-73  14:03:02	OPMOD	OUTMO1.BLI		PAGE 46-3

BELSEEQVCPTEQVCPTEQVLINCLINKRIGHTC	     ELSE EQVCPTR _ .EQVCPTR[EQVLINK]
BENDC	 END; !OF %1%
BC	 !
BC	 !NOW START TO MAKE EQUIVALENCE CLASSES BY COMBINING GROUPS IF POSSIBLE
BC	 !
BEQVCPTEQVPTRLEFTC	 EQVCPTR _ .EQVPTR<LEFT>;	!START WITH FIRST GROUP
BWHILEDOC	 WHILE 1 DO	%1%
BBEGINC	 BEGIN
BWHILEDOC	     WHILE 1 DO	%2% !GROUP(I) BECOMING A CLASS
BBEGINC	     BEGIN
BIFEQVCPTEQVAVAEQLC	 	IF .EQVCPTR[EQVAVAIL] EQL 0 !GROUP AVAILABLE FOR CLASS
BTHENMACROEQGPPTC	 	THEN ( MACRO EQGPPTR = EQLPTR$;
BEQVCPTEQVAVAC	 		EQVCPTR[EQVAVAIL] _ 2; !MAKE GROUP A CLASS
BEQGPPTEQLPTREQVCPTC	 		EQGPPTR _ .EQVCPTR; !BEGIN SRCH OF OTHER GROUPS ON CURRENT GROUP
BDOC	 		DO
BBEGINC	 		BEGIN
BIFEQGPPTEQLPTREQVAVAEQLC	 		  IF .EQGPPTR[EQVAVAIL] EQL 0
BTHENC	 		  THEN (
BIFELISTSEQVCPTEQGPPTEQLPTRGTRC	 			IF (ELISTSRCH(.EQVCPTR,.EQGPPTR)) GTR 0
BTHENEQGPPTEQLPTREQVAVAC	 			THEN EQGPPTR[EQVAVAIL] _ 2;
BC	 			!
BC	 			!IF ERROR OCCURRED IN ELSTSRCH THEN EQGPPTR[EQVAVAIL]
BC	 			!WILL BE SET TO 3 (ERROR)
BC	 			!
BC	 		       );
BENDC	 		END
BWHILEEQGPPTEQLPTREQGPPTEQLPTREQVLINCLINKRIGHTNEQC	 		    WHILE (EQGPPTR _ .EQGPPTR[EQVLINK]) NEQ 0;
BIFNOTEQVCPTEQVINCC	 		IF NOT .EQVCPTR[EQVINCOM]
BTHENIFEQVCPTEQVAVANEQC	 		  THEN IF .EQVCPTR[EQVAVAIL] NEQ 3
BTHENEQCALLEQVCPTC	 			THEN EQCALLOC(.EQVCPTR); !ALLOCATE CLASS POINTED TO BY EQVCPTR
BC	 	      ); !END OF IF AVAIL TEST
BIFEQVCPTEQVLINCLINKRIGHTEQLC	 	  IF .EQVCPTR[EQVLINK] EQL 0
BTHENEXITLOC	 		THEN EXITLOOP  !NO MORE GROUPS TO PROCESS INTO CLASS
BELSEEQVCPTEQVCPTEQVLINCLINKRIGHTC	 		ELSE EQVCPTR _ .EQVCPTR[EQVLINK]; !NEXT GROUP TO BE A CLASS
BENDC	 	END; !OF LOOP %2%
BIFEQVCPTEQVCPTEQVLINCLINKRIGHTEQLTHENRETURNC	 	IF (EQVCPTR _ .EQVCPTR[EQVLINK]) EQL 0 THEN RETURN;
BC	 !
BC	 !ALL GROUPS PROCESSED IF RETURN TAKEN
BC	 !
BENDC	 END; ! OF LOOP %1%
BENDC	 END; !OF ROUTINE PROCEQUIV
BC	 
BLISS  V. 1.0-2.12	13-JUN-73  14:03:26	OPMOD	OUTMO1.BLI		PAGE 47-1

BC	 
BC	 
BGLOBALD

	0000		JSP	07,.ENT.2			;EXTERNAL
  3509	0001		ADD	$S,[000004,,000004]
  3515	0002		MOVE	04,0
	0003		TRNN	04,2000
	0004		JRST	00,L32046
	0005		PUSH	$S,[004400,,OPMO.P+31]
	0006		PUSHJ	$S,ZOUTMSG			;EXTERNAL
	0007		SUB	$S,[000001,,000001]
  3534	0010	L32046:	HLRZ	05,EQVPTR			;EXTERNAL
	0011	L30662:	MOVEM	05,3($F)			;LOCAL
  3537	0012	L36360:	SETZM	00,4($F)			;LOCAL
  3540	0013		MOVE	$V,3($F)			;LOCAL
	0014		MOVE	06,0($V)
	0015		TLNN	06,-400000
	0016		JRST	00,L34330
	0017		ADD	$S,[000001,,000001]
  3541	0020		HLRZ	13,1($V)
  3543	0021		HRRZ	07,1(13)
	0022		MOVEM	07,7($F)			;LOCAL
  3544	0023		MOVEM	13,4($F)			;LOCAL
  3545	0024		HLRZ	04,4(07)
	0025		MOVEM	04,5($F)			;LOCAL
  3546	0026		HRRZ	05,1(13)
	0027		MOVEM	05,6($F)			;LOCAL
	0030		SUB	$S,[000001,,000001]
	0031		JRST	00,L34014
  3548	0032	L34330:	SETZM	00,6($F)			;LOCAL
	0033	L34014:	MOVE	$V,3($F)			;LOCAL
  3549	0034		HLRZ	13,2($V)
  3550	0035		SETZ	01,0
	0036		MOVE	02,1
  3552	0037	L32476:	LDB	07,[430113,,000000]
	0040		JUMPE	07,L32310
	0041		ADD	$S,[000001,,000001]
  3554	0042		SETZ	05,0
	0043		DPB	05,[430113,,000000]
	0044		HRRZ	06,1(13)
	0045		PUSH	$S,6
	0046		HLRZ	07,1(13)
	0047		PUSH	$S,7
	0050		PUSHJ	$S,ARRXPN			;EXTERNAL
	0051		SUB	$S,[000002,,000002]
  3556	0052		MOVEM	$V,7($F)			;LOCAL
	0053		MOVE	$V,7($F)			;LOCAL
	0054		MOVE	12,2($V)
	0055		HRREI	12,0(12)
	0056		MOVE	$V,12
  3557	0057		MOVNM	$V,2(13)
	0060		SUB	$S,[000001,,000001]
  3558	0061	L32310:	ADD	$S,[000002,,000002]
  3562	0062		HRRZ	05,1(13)
	0063		MOVEM	05,7($F)			;LOCAL
  3565	0064		HLRZ	06,0(05)
BLISS  V. 1.0-2.12	13-JUN-73  14:03:36	OPMOD	OUTMO1.BLI		PAGE 47-2

	0065		JUMPE	06,L30700
	0066		HLRZ	04,0(05)
	0067		MOVEM	04,7($F)			;LOCAL
	0070		HRRZ	$V,0(04)
	0071		JRST	00,L30752
	0072	L30700:	MOVE	04,1(05)
	0073		TRNN	04,200000
	0074		JRST	00,L36020
	0075		MOVEI	$V,2
	0076		JRST	00,L30752
	0077	L36020:	MOVEI	$V,1
	0100	L30752:	MOVEM	$V,10($F)			;LOCAL
  3568	0101		MOVE	04,10($F)			;LOCAL
	0102		ADD	04,2(13)
	0103		CAMLE	04,2
  3569	0104		MOVE	02,4
	0105		SUB	$S,[000002,,000002]
  3570	0106		CAMG	01,2(13)
	0107		JRST	00,L32426
	0110		MOVE	01,2(13)
	0111		HRRZ	$V,1(13)
	0112		MOVEM	$V,6($F)			;LOCAL
  3575	0113	L32426:	SKIPN	07,4($F)			;LOCAL
	0114		JRST	00,L36666
	0115		CAMN	07,13
	0116		JRST	00,L36666
	0117		ADD	$S,[000002,,000002]
  3578	0120		HRRZ	06,1(13)
	0121		MOVEM	06,7($F)			;LOCAL
  3581	0122		HRRZ	04,1(07)
	0123		MOVEM	04,10($F)			;LOCAL
	0124		MOVE	05,1(06)
	0125		TLNE	05,400
	0126		JRST	00,L35270
  3583	0127		MOVE	$V,5($F)			;LOCAL
  3584	0130		HRRZ	07,2($V)
	0131		MOVEM	07,7($F)			;LOCAL
  3585	0132		HRRZ	04,1(13)
	0133		HRRM	04,2($V)
  3586	0134		HRRZ	06,1(13)
	0135		HRRM	06,5(07)
	0136		MOVEM	06,7($F)			;LOCAL
  3587	0137		MOVEI	05,1
	0140		DPB	05,[320106,,000001]
  3588	0141		HRLM	$V,4(06)
  3589	0142		HLLZS	00,5(06)
	0143		MOVE	$V,4($F)			;LOCAL
	0144		MOVE	04,10($F)			;LOCAL
	0145		MOVE	07,2(13)
	0146		SUB	07,2($V)
	0147		HRRZ	$V,2(04)
	0150		ADD	07,15
	0151		HRRM	07,2(06)
  3590	0152		JUMPGE	07,L34640
	0153		MOVE	$V,5($F)			;LOCAL
	0154		HRRZI	04,1($V)
	0155		HRLI	04,4400
BLISS  V. 1.0-2.12	13-JUN-73  14:03:38	OPMOD	OUTMO1.BLI		PAGE 47-3

	0156		MOVEM	04,ENTRY+1			;EXTERNAL
	0157		PUSH	$S,[41]
	0160		PUSHJ	$S,ERROUT			;EXTERNAL
	0161		SUB	$S,[000003,,000003]
  3591	0162		JRST	00,L34746
  3593	0163	L34640:	MOVE	$V,5($F)			;LOCAL
	0164		MOVE	04,7($F)			;LOCAL
  3594	0165		HRRZ	06,2(04)
	0166		ADD	06,2
	0167		SUB	06,2(13)
	0170		HLRZ	07,0($V)
	0171		CAMG	06,7
	0172		JRST	00,L34500
  3595	0173		HRLM	06,0($V)
	0174		JRST	00,L34500
	0175	L35270:	HRRZ	05,2(04)
	0176		SUB	05,2(07)
	0177		HRRZ	04,2(06)
	0200		SUB	04,2(13)
	0201		CAMN	05,4
	0202		JRST	00,L34500
	0203		PUSH	$S,3($F)			;LOCAL
	0204		PUSHJ	$S,EQERRLIST
	0205		SUB	$S,[000001,,000001]
	0206		MOVE	$V,3($F)			;LOCAL
	0207		MOVEI	06,3
	0210		DPB	06,[410215,,000000]
	0211		SUB	$S,[000002,,000002]
	0212		JRST	00,L34746
  3598	0213	L34500:	SUB	$S,[000002,,000002]
  3602	0214	L36666:	HRRZ	05,0(13)
	0215		JUMPN	05,L32634
	0216		JRST	00,L34746
	0217		JRST	00,L32476  ^^^
  3608	0220	L32634:	HRRZ	13,0(13)
  3609	0221		JRST	00,L32476  ^^^
	0222	L34746:	MOVE	$V,3($F)			;LOCAL
  3611	0223		MOVEM	01,3($V)
  3615	0224		HRRM	02,1($V)
  3620	0225		HRRZ	07,0($V)
	0226		JUMPN	07,L32546
	0227		JRST	00,L32216
	0230		JRST	00,L36360  ^^^
  3622	0231	L32546:	HRRZ	05,0($V)
	0232		JRST	00,L30662  ^^^
  3623	0233	L32216:	HLRZ	05,EQVPTR			;EXTERNAL
	0234		MOVEM	05,3($F)			;LOCAL
  3631	0235	L34264:	MOVE	$V,3($F)			;LOCAL
  3632	0236		LDB	06,[410215,,000000]
	0237		JUMPN	06,L32626
  3633	0240		MOVEI	04,2
	0241		DPB	04,[410215,,000000]
  3635	0242		MOVE	13,15
  3637	0243	L34674:	LDB	05,[410213,,000000]
	0244		JUMPN	05,L34546
  3639	0245		PUSH	$S,3($F)			;LOCAL
	0246		PUSH	$S,13
BLISS  V. 1.0-2.12	13-JUN-73  14:03:38	OPMOD	OUTMO1.BLI		PAGE 47-4

	0247		PUSHJ	$S,ELISTSRCH			;EXTERNAL
	0250		SUB	$S,[000002,,000002]
  3640	0251		JUMPLE	$V,L34546
  3641	0252		MOVEI	04,2
	0253		DPB	04,[410213,,000000]
  3648	0254	L34546:	HRRZ	13,0(13)
	0255		JUMPN	13,L34674  ^^^
  3649	0256		MOVE	$V,3($F)			;LOCAL
	0257		MOVE	04,0($V)
	0260		TLNE	04,-400000
	0261		JRST	00,L32626
  3650	0262		LDB	05,[410215,,000000]
	0263		CAIN	05,3
	0264		JRST	00,L32626
	0265		PUSH	$S,15
	0266		PUSHJ	$S,EQCALLOC			;EXTERNAL
	0267		SUB	$S,[000001,,000001]
  3651	0270	L32626:	MOVE	$V,3($F)			;LOCAL
  3653	0271		HRRZ	04,0($V)
	0272		JUMPN	04,L34634
	0273		JRST	00,L32540
	0274		JRST	00,L34264  ^^^
  3655	0275	L34634:	HRRZ	06,0($V)
	0276		MOVEM	06,3($F)			;LOCAL
  3656	0277		JRST	00,L34264  ^^^
	0300	L32540:	MOVE	$V,3($F)			;LOCAL
	0301		HRRZ	06,0($V)
	0302		MOVEM	06,3($F)			;LOCAL
	0303		JUMPN	06,L30702
	0304		JRST	00,L34270
	0305		JRST	00,L30674
  3661	0306	L30702:	JRST	00,L34264  ^^^
	0307	L34270:	SETZ	$V,0
	0310	L30674:	SUB	$S,[000004,,000004]
  3662	0311		JRST	00,.EXT.2			;EXTERNAL


BROUTINKISNGLXYC	 GLOBAL ROUTINE  KISNGL(X,Y)=
BBEGINC	 BEGIN
BC	 	!X IS THE HIGH ORDER KI-10 CNSTANT, Y IS LOW ORDER WORD
BC	 !
BBINDHIR1LOWR2C	 	BIND HI=R1,LOW=R2;
BMACHOPADDITLZETLZETLOLSHDFNC	 	MACHOP ADDI=#271,TLZE=#623,TLO=#661,LSH=#242,DFN=#131;
BMACROEXPONC	 MACRO EXPON=27,8$;
BHIXLOWYC	 	HI _ .X; LOW _ .Y;
BIFHILSSC	 	IF .HI LSS 0
BTHENHIHILOWLOWC	 	THEN (HI _ -.HI; LOW _ -.LOW;
BIFLOWNEQTHENHIHIC	 		IF .LOW NEQ 0 THEN HI _ .HI-1;
BC	 	     );
BIFLOWC	 	IF .LOW<34,1>		!IS ROUNDING NECESSARY?
BTHENC	 	THEN(
BIFHINEQC	 		IF .HI NEQ #377777777777
BTHENHIHIC	 		THEN HI _ .HI+1;
BHIC	 		HI<26,1> _ 1;	!SET HIGHORDER BIT ON
BC	 	    );
BIFXLSSTHENHIHIC	 	IF .X LSS 0 THEN HI _ -.HI;	!RESTORING SIGN
BHIC	 	.HI		!IS RETURNED
BLISS  V. 1.0-2.12	13-JUN-73  14:03:48	OPMOD	OUTMO1.BLI		PAGE 47-5

BENDC	 END;
BGLOBALD

	0000		JSP	07,.ENT.0			;EXTERNAL
  3670	0001		MOVE	01,-3($F)			;FORMAL
  3673	0002		MOVE	02,-2($F)			;FORMAL
	0003		JUMPGE	01,L32620
	0004		MOVNS	05,1
  3675	0005		MOVNS	06,2
	0006		JUMPE	02,L32620
  3676	0007		SOJ	01,0
	0010	L32620:	TLNN	02,200000
	0011		JRST	00,L34364
  3679	0012		CAME	01,[377777,,777777]
  3681	0013		AOJ	01,0
  3682	0014		TLO	01,400
  3683	0015		JRST	00,L34364
	0016	L34364:	SKIPGE	05,-3($F)			;FORMAL
  3684	0017		MOVNS	07,1
	0020		MOVE	$V,1
  3686	0021		JRST	00,.EXT.0			;EXTERNAL


BROUTINKITOKAXYC	 GLOBAL ROUTINE KITOKA(X,Y)=
BBEGINC	 BEGIN
BEXTERNC2HC2LC	 	EXTERNAL C2H,C2L;	!GLOBALS TO RETURN CONVERTED  CP CONSTANTS
BBINDHIR1LOWR2C	 	BIND HI=R1,LOW=R2;
BMACHOPADDITLZETLZETLOLSHDFNC	 	MACHOP ADDI=#271,TLZE=#623,TLO=#661,LSH=#242,DFN=#131;
BMACROEXPONC	 MACRO EXPON=27,8$;
BHIXC	 	HI _ .X;	!GET THE VALUE INT REGISTERS 1 AND 2
BLOWYC	 	LOW _ .Y;
BIFXLSSC	 	IF .X LSS 0 
BTHENLOWLOWC	 	THEN( LOW _ -.LOW;
BHIHIC	 		HI _ -.HI;
BTLZELOWC	 		TLZE(LOW,#400000);
BHIHIC	 		HI _ .HI -1;	!SUBTRACT ONE FOR ONES COPLEMENT
BC	 	    );
BIFHIEXPONGEQC	 	IF .HI<EXPON> GEQ 27
BTHENLOWLOWC	 	THEN( LOW _ .LOW + #200;
BTLZELOWC	 		TLZE(LOW,#400000);
BADDIHIC	 		ADDI(HI,1);
BC	 	    )
BELSETLZELOWC	 	ELSE( TLZE(LOW,#200000);
BADDIHIC	 		ADDI(HI,1);
BLOWC	 		LOW _ 0;
BC	 	    );
BTLOHIC	 	TLO(HI,#400);	!SET THE HI ORDER BIT
BIFHILSSTHENHIC	 	IF .HI LSS 0 THEN (HI _ #377777777777;	!OVERFLOW OCCURRED
BLOWC	 				LOW _ #377777777777;
BC	 			);
BLSHLOWC	 	LSH(LOW,-8);	!SHIFT OUT EXPON BITS
BIFLOWNEQC	 	IF .LOW NEQ 0
BTHENLOWEXPONHIEXPONC	 		THEN	LOW<EXPON> _ .HI<EXPON> - 27;	!LOW ORDER EXPONENT
BIFXLSSTHENDFNHILOWC	 	IF .X LSS 0 THEN DFN(HI,LOW);
BC2HHIC	 	C2H _ .HI;	!RESTORING VALUES
BC2LLOWC	 	C2L _ .LOW;
BENDC	 END; !OF KITO KA
BLISS  V. 1.0-2.12	13-JUN-73  14:04:13	OPMOD	OUTMO1.BLI		PAGE 47-6

BGLOBALD

	0000		JSP	07,.ENT.0			;EXTERNAL
  3689	0001		MOVE	01,-3($F)			;FORMAL
  3694	0002		MOVE	02,-2($F)			;FORMAL
	0003		SKIPL	04,-3($F)			;FORMAL
	0004		JRST	00,L33612
  3696	0005		MOVNS	06,2
  3697	0006		MOVNS	07,1
	0007		TLZE	02,-400000
  3698	0010		SOJ	01,0
  3700	0011	L33612:	LDB	06,[331000,,000001]
	0012		CAIGE	06,33
	0013		JRST	00,L34370
  3702	0014		ADDI	02,200
	0015		TLZE	02,-400000
  3703	0016		ADDI	01,1
  3704	0017		JRST	00,L34006
	0020	L34370:	TLZE	02,200000
  3706	0021		ADDI	01,1
  3708	0022		SETZ	02,0
  3709	0023	L34006:	TLO	01,400
  3710	0024		JUMPGE	01,L33762
  3711	0025		HRLOI	01,377777
  3712	0026		HRLOI	02,377777
  3713	0027	L33762:	LSH	02,-10
  3714	0030		JUMPE	02,L32576
  3716	0031		LDB	06,[331000,,000001]
	0032		SUBI	06,33
	0033		DPB	06,[331000,,000002]
	0034	L32576:	SKIPGE	06,-3($F)			;FORMAL
	0035		DFN	01,2
  3718	0036		MOVEM	01,C2H				;EXTERNAL
  3719	0037		MOVEM	02,C2L				;EXTERNAL
	0040		SETZ	$V,0
  3720	0041		JRST	00,.EXT.0			;EXTERNAL


BROUTINALCCONBLISS  V. 1.0-2.12	13-JUN-73  14:04:15	OPMOD	OUTMO1.BLI		PAGE 48-1

C	 GLOBAL ROUTINE ALCCON=
BBEGINC	 BEGIN
BC	 	!ALLOCATE (USING HILOC) ALL THE CONSTANTS THAT HAVE
BC	 	!THE FLAG CNTOBEALCFLG SET.  THIS FLAG IS SET BY CALLS TO
BC	 	!ALOCONST.
BEXTERNHILOCHILOCRDATWDRDATWDZOUTBLZOUTBLC2HC2LC	 	EXTERNAL HILOC,RDATWD,ZOUTBLOCK,C2H,C2L;
BC	 
BEXTERNLITPOILITPOIC	 	EXTERNAL LITPOINTER;
BBINDHIR1LOWR2C	 	BIND HI=R1,LOW=R2;
BMACHOPADDITLZETLZETLOLSHDFNC	 	MACHOP ADDI=#271,TLZE=#623,TLO=#661,LSH=#242,DFN=#131;
BMACROEXPONC	 MACRO EXPON=27,8$;
BMACRORELCONCXPTRC	 MACRO RELCONST(CXPTR)=	 !DUMPS CONSTANTS ONTO REL FIE
BC	 BEGIN
BC	 MAP BASE CXPTR;
BC	 	IF .CXPTR[VALTP1] EQL INTEG1
BC	 	 THEN RDATWD _ .CXPTR[CONST2]
BC	 	 ELSE RDATWD _ .CXPTR[CONST1];	!HIGH ORDER FOR REAL OR DOUBLE
BC	 	ZOUTBLOCK(RCODE,RELN);
BC	 	HILOC_.HILOC+1;
BC	 	IF .CXPTR[DBLFLG]	!IF DOUBLE OR COMPLEX CONSTANT
BC	 	 THEN ( RDATWD _ .CXPTR[CONST2]; ZOUTBLOCK(RCODE,RELN);
BC	 			HILOC_ .HILOC+1;
BC	 		);
BC	 END$;
BLOCALBASECPTRCPTRC	 	LOCAL BASE CPTR;
BC	 
BINCRIFROMTOICSIZDOC	 	INCR I FROM 0 TO CSIZ-1 DO
BBEGINC	 	BEGIN
BIFCONTBLINEQTHENC	 	IF .CONTBL[.I] NEQ 0 THEN
BBEGINC	 	BEGIN
BCPTRCONTBLIC	 		CPTR_.CONTBL[.I];
BWHILECPTRNEQDOC	 		WHILE .CPTR NEQ 0 DO
BBEGINC	 		BEGIN
BC	 			!NOW CHECK FOR KA-10 DP CONSTANT O/P
BIFCPTRCONST1CW3FULLNEQC	 			IF .CPTR[CONST1] NEQ 0
BTHENC	 			THEN
BIFCPTRVALTYPEXOPWDEQLDOUBLPC	 				IF .CPTR[VALTYPE] EQL DOUBLPREC
BTHENC	 				THEN (
BIFFLGREGKA10C	 					IF .FLGREG<KA10>
BTHENKITOKACPTRCONST1CW3FULLCPTRCONST2CW4FULLC	 					 THEN (KITOKA(.CPTR[CONST1],.CPTR[CONST2]);	!DO THE CORRECT FIXUP
BCPTRCONST1CW3FULLC2HC	 						CPTR[CONST1] _ .C2H;
BCPTRCONST2CW4FULLC2LC	 						CPTR[CONST2] _ .C2L;
BC	 					     )
BC	 				     )
BELSEIFCPTRVALTYPEXOPWDEQLREALC	 				ELSE IF .CPTR[VALTYPE] EQL REAL
BTHENCPTRCONST1CW3FULLKISNGLCPTRCONST1CW3FULLCPTRCONST2CW4FULLC	 					THEN CPTR[CONST1] _ KISNGL(.CPTR[CONST1],.CPTR[CONST2]);
BIFCPTRCNTOBETHENC	 			IF .CPTR[CNTOBEALCFLG] THEN
BBEGINC	 			BEGIN
BCPTRIDADDRCW2RRIGHTHILOCC	 				CPTR[IDADDR]_.HILOC;
BC	 				%NOW PUT CONSTANT OUT IN REL FILE
BC	 				REMEMBER THAT THIS ROUTINE IS EXECUTED WITHIN
BC	 				A TEST FOR THE REL FILE GENERATION%
BC	 
BRELCONBEGINMAPBASECPTRCPTRIFCPTRVALTP1EXOPWDEQLINTEG1THENRDATWDCPTRCONST2CW4FULLELSERDATWDCPTRCONST1CW3FULLZOUTBLRCODERELNHILOCHILOCIFCPTRDBLFLGEXOPWDTHENRDATWDCPTRCONST2CW4FULLZOUTBLRCODERELNHILOCHILOCENDC	 				RELCONST(CPTR);		!IN MACRO ABOVE
BENDC	 			END;
BCPTRCPTRCLINKRIGHTC	 			CPTR_.CPTR[CLINK];
BENDC	 		END;
BLISS  V. 1.0-2.12	13-JUN-73  14:05:51	OPMOD	OUTMO1.BLI		PAGE 48-2

BENDC	 		END;
BENDC	 	END;
BIFCPTRLITPOILEFTNEQC	 	IF (CPTR _ .LITPOINTER<LEFT>) NEQ 0
BTHENC	         THEN
BDOC	         DO  (
BCPTRLITADDCW2FULLHILOCC	 			CPTR[LITADDR] _ .HILOC;
BIFCPTRVALTYPEXOPWDEQLSTRINGC	                         IF  .CPTR[VALTYPE]  EQL  STRING
BTHENC	                         THEN
BBEGINC	                         BEGIN
BRDATWDLEFTCPTRLITSIZCW0LLEFTC	                         RDATWD<LEFT>  _  .CPTR[LITSIZ];
BRDATWDRIGHTHILOCC	                         RDATWD<RIGHT>  _  .HILOC+1;
BZOUTBLRCODERELRIC	                         ZOUTBLOCK(RCODE,RELRI);
BHILOCHILOCC	                         HILOC  _  .HILOC + 1;
BENDC	                         END;
BC	 
BC	         %(******* WHAT WE HAVE JUST DONE IS TO SET UP THE STRING
BC	                POINTER WORD AND MADE THE NODE POINT
BC	                  TO THIS POINTER.  THE STRING FOLLOWS THE POINTER)%
BC	 
BINCRIFROMTOICPTRLITSIZCW0LLEFTDOC	 			INCR I FROM 0 TO .CPTR[LITSIZ]-1 DO
BRDATWDCPTRLIT1CW3FULLIC	 			  (RDATWD _ .(CPTR[LIT1]+.I);
BZOUTBLRCODERELNC	 			   ZOUTBLOCK(RCODE,RELN);
BHILOCHILOCC	 			   HILOC _ .HILOC+1;	!INCREMENTING FOR ZOUTBLOCK
BC	                         );
BWHILECPTRCPTRLITLINCLINKRIGHTNEQC	         ) WHILE (CPTR _ .CPTR[LITLINK]) NEQ 0;
BENDC	 END;
BGLOBALD

	0000		JSP	07,.ENT.1			;EXTERNAL
  3722	0001		ADD	$S,[000003,,000003]
  3726	0002		SETZ	13,0
  3747	0003	L36326:	CAILE	13,44
	0004		JRST	00,L35234
  3749	0005		HRRZ	04,CONTBL(13)			;EXTERNAL
	0006		JUMPE	04,L34014
  3751	0007		HRRZ	06,CONTBL(13)			;EXTERNAL
	0010		MOVEM	06,2($F)			;LOCAL
	0011	L30720:	SKIPN	07,2($F)			;LOCAL
	0012		JRST	00,L34014
  3753	0013		SKIPN	05,3(07)
	0014		JRST	00,L35006
  3757	0015		LDB	04,[150507,,000001]
	0016		CAIE	04,30
	0017		JRST	00,L33732
  3758	0020		MOVE	06,0
	0021		TRNN	06,4000
	0022		JRST	00,L35006
	0023		PUSH	$S,3(07)
	0024		PUSH	$S,4(07)
	0025		PUSHJ	$S,KITOKA
	0026		SUB	$S,[000002,,000002]
  3760	0027		MOVE	$V,2($F)			;LOCAL
  3761	0030		MOVE	04,C2H				;EXTERNAL
	0031		MOVEM	04,3($V)
  3762	0032		MOVE	05,C2L				;EXTERNAL
	0033		MOVEM	05,4($V)
  3764	0034		JRST	00,L35006
BLISS  V. 1.0-2.12	13-JUN-73  14:07:05	OPMOD	OUTMO1.BLI		PAGE 48-3

  3765	0035	L33732:	LDB	06,[150507,,000001]
	0036		CAIE	06,24
	0037		JRST	00,L35006
	0040		PUSH	$S,3(07)
	0041		MOVE	$V,2($F)			;LOCAL
	0042		PUSH	$S,4($V)
	0043		MOVEM	07,3($F)			;LOCAL
	0044		PUSHJ	$S,KISNGL
	0045		SUB	$S,[000002,,000002]
  3766	0046		MOVE	05,3($F)			;LOCAL
	0047		MOVEM	$V,3(05)
	0050	L35006:	MOVE	$V,2($F)			;LOCAL
  3767	0051		MOVE	04,1($V)
	0052		TLNN	04,-400000
	0053		JRST	00,L34526
  3769	0054		MOVE	05,HILOC			;EXTERNAL
	0055		HRRM	05,2($V)
	0056		LDB	07,[170215,,000001]
	0057		JUMPN	07,L37724
	0060		SKIPA	04,4($V)
	0061	L37724:	MOVE	04,3($V)
	0062		MOVEM	04,RDATWD			;EXTERNAL
	0063		PUSH	$S,[1]
	0064		PUSH	$S,[0]
	0065		PUSHJ	$S,ZOUTBLOCK			;EXTERNAL
	0066		SUB	$S,[000002,,000002]
	0067		AOS	04,HILOC			;EXTERNAL
	0070		MOVE	$V,2($F)			;LOCAL
	0071		MOVE	05,1($V)
	0072		TRNN	05,200000
	0073		JRST	00,L34526
	0074		MOVE	07,4($V)
	0075		MOVEM	07,RDATWD			;EXTERNAL
	0076		PUSH	$S,[1]
	0077		PUSH	$S,[0]
	0100		PUSHJ	$S,ZOUTBLOCK			;EXTERNAL
	0101		SUB	$S,[000002,,000002]
	0102		AOS	06,HILOC			;EXTERNAL
  3774	0103	L34526:	MOVE	$V,2($F)			;LOCAL
  3776	0104		HRRZ	05,0($V)
	0105		MOVEM	05,2($F)			;LOCAL
  3777	0106		JRST	00,L30720  ^^^
  3779	0107	L34014:	AOJA	13,L36326  ^^^
  3780	0110	L35234:	HLRZ	06,LITPOINTER			;EXTERNAL
	0111		MOVEM	06,2($F)			;LOCAL
	0112		JUMPE	06,L32430
  3782	0113	L32526:	MOVE	$V,2($F)			;LOCAL
  3783	0114		MOVE	04,HILOC			;EXTERNAL
	0115		MOVEM	04,2($V)
  3784	0116		LDB	05,[150515,,000001]
	0117		CAIE	05,17
	0120		JRST	00,L37470
  3787	0121		HLRZ	07,0($V)
	0122		HRLM	07,RDATWD			;EXTERNAL
  3788	0123		AOJ	04,0
	0124		HRRM	04,RDATWD			;EXTERNAL
	0125		PUSH	$S,[1]
BLISS  V. 1.0-2.12	13-JUN-73  14:07:07	OPMOD	OUTMO1.BLI		PAGE 48-4

	0126		PUSH	$S,[1]
	0127		PUSHJ	$S,ZOUTBLOCK			;EXTERNAL
	0130		SUB	$S,[000002,,000002]
  3789	0131		AOS	05,HILOC			;EXTERNAL
  3791	0132	L37470:	SETZ	13,0
	0133		MOVE	$V,2($F)			;LOCAL
  3797	0134		HLRZ	07,0($V)
	0135		SOJ	07,0
	0136		MOVEM	07,4($F)			;LOCAL
	0137	L32310:	CAMLE	13,4($F)			;LOCAL
	0140		JRST	00,L32432
	0141		MOVE	$V,2($F)			;LOCAL
	0142		MOVE	04,13
	0143		HRRZI	05,3($V)
	0144		HRLI	05,4400
	0145		ADD	04,5
  3798	0146		LDB	06,4
	0147		MOVEM	06,RDATWD			;EXTERNAL
	0150		PUSH	$S,[1]
	0151		PUSH	$S,[0]
	0152		PUSHJ	$S,ZOUTBLOCK			;EXTERNAL
	0153		SUB	$S,[000002,,000002]
  3799	0154		AOS	07,HILOC			;EXTERNAL
  3801	0155		AOJA	13,L32310  ^^^
	0156	L32432:	MOVE	$V,2($F)			;LOCAL
	0157		HRRZ	05,0($V)
	0160		MOVEM	05,2($F)			;LOCAL
  3802	0161		JUMPN	05,L32526  ^^^
	0162		JRST	00,L32430
	0163	L32430:	SETZ	$V,0
	0164		SUB	$S,[000003,,000003]
  3803	0165		JRST	00,.EXT.1			;EXTERNAL


BROUTINALCTMPC	 GLOBAL ROUTINE ALCTMPS=
BBEGINC	 BEGIN
BC	 	!ROUTINE CLEANS UP ALL THE ALLOCATION OF VARIABLES.
BC	 	!THIS IS A THREE STEP PROCESS.
BC	 	!	1. GO THROUGH THE SYMBOL TABLE AND ALLOCATE ALL
BC	 	!	  THOSE PREVIOUSLY UNALLOCATED. THIS IS PRIMARILY
BC	 	!	  THE TEMPS GENERATED FOR REGISTER SAVE/RESTORE
BC	 	!	  FOR A SUBROUTINE OR FUNCTION.
BC	         !       2. STRING ALLOCATION
BC	 	!	3. THE TEMPS GENERATED IN THE LOCAL REGISTER
BC	 	!	  ALLOCATION PROCESS.
BC	 
BEXTERNSYMTBLSYMTBLLOWLOCADJHEAFRSTLNPROGNAC	 	EXTERNAL SYMTBL,LOWLOC,ADJHEAD,FRSTLNK,PROGNAME;
BC	 
BEXTERNHISEGBZOUTBLZOUTBLRDATWDRDATWDHILOCHILOCEVALUC	         EXTERNAL        HISEGBLK,ZOUTBLOCK,RDATWD,HILOC,EVALU;
BC	 
BLABELL1L2C	         LABEL L1,L2;
BLOCALPTRC	         LOCAL PTR;
BC	 
BC	 
BLOCALCNTC	 	LOCAL CNT;
BC	 
BIFFLGREGLISTINTHENZOUTMSPLITC	 	IF .FLGREG<LISTING> THEN ZOUTMSG(PLIT'?M?J?M?JTEMPORARIES?M?J?M?J');
BLISS  V. 1.0-2.12	13-JUN-73  14:07:11	OPMOD	OUTMO1.BLI		PAGE 48-5

BC	 	!FIRST THE SYMBOL TABLE
BC	 
BCNTC	 		CNT _ 0;
BINCRKFROMTOKSSIZDOC	 		INCR K FROM 0 TO SSIZ-1 DO
BBEGINC	 		BEGIN
BREGISTBASETTC	 			REGISTER BASE T;
BTSYMTBLKC	 			T_.SYMTBL[.K];
BWHILETNEQDOC	 			WHILE .T NEQ 0 DO
BBEGINC	 			BEGIN
BIFTIDADDRCW2RRIGHTEQLC	 			     IF .T[IDADDR] EQL 0
BTHENIFNOTTIDATTRINCOMANDTOPRSP1EXOPWDNEQFNNAMEANDNOTTIDATTRCOMBLTHENC	 				THEN IF NOT .T[IDATTRIBUT(INCOM)]  AND .T[OPRSP1] NEQ FNNAME1 AND NOT .T[IDATTRIBUT(COMBL)] THEN
BBEGINC	 				BEGIN
BTIDADDRCW2RRIGHTLOWLOCC	 					T[IDADDR]_.LOWLOC;
BLOWLOCLOWLOCTDBLFLGEXOPWDC	 					LOWLOC_.LOWLOC+1+.T[DBLFLG];
BIFFLGREGLISTINTHENC	 					IF .FLGREG<LISTING> THEN 
BLISTSYTC	 					   (LISTSYM(.T);
BIFCNTCNTGTRTHENCNTCRLFC	 						IF (CNT _ .CNT+1) GTR 5 THEN (CNT_0; CRLF());
BC	 					   );
BENDC	 				END;
BTTCLINKRIGHTC	 				T_.T[CLINK];
BENDC	 			END;
BENDC	 		END;
BC	 
BC	 	!NOW (FOR EITHER SUBPROGRAM OR MAIN PROGRAM, THE TEMPS
BC	 	!GENERATED BY LOCAL REGISTER ALLOCATION
BC	 
BWHILEFRSTLNNEQDOC	 	WHILE .FRSTLNK NEQ 0 DO
BBEGINC	 	BEGIN
BMAPBASEFRSTLNFRSTLNC	 		MAP BASE FRSTLNK;
BFRSTLNIDADDRCW2RRIGHTLOWLOCC	 		FRSTLNK[IDADDR]_.LOWLOC;
BLOWLOCLOWLOCC	 		LOWLOC_.LOWLOC+1;
BIFFLGREGLISTINC	 		IF .FLGREG<LISTING>
BTHENLISTSYFRSTLNC	 		 THEN ( LISTSYM(.FRSTLNK);
BIFCNTCNTGTRTHENCNTCRLFC	 			IF (CNT _ .CNT+1) GTR 5 THEN (CNT_0; CRLF());
BC	 		      );
BC	 		!**NOTE**
BC	 		!THESE ARE ALSO SINGLE CELL. NXTTMP TAKES
BC	 		!CARE OF GETTING TWO FOR A DOUBLE WORD QUANTITY
BFRSTLNFRSTLNCLINKRIGHTC	 		FRSTLNK_.FRSTLNK[CLINK];
BENDC	         END;
BC	 
BC	 %(****************************************************************
BC	 
BC	 AT THIS POINT ALL THE LOWSEG CELLS HAVE BEEN ALLOCATED.
BC	 WE ARE NOW READY TO OUTPUT THE HISEG STRING POINTERS,
BC	 AND THE DEBUGGER BLOCK 30 SYMBOL TABLES FOR VARIABLES, AND ARRAYS.
BC	 BUT FIRST WE MUST OUTPUT THE LOADER BLOCK TYPE 3
BC	 
BC	 ***************************************************************)%
BC	 
BC	 
BHISEGBC	 HISEGBLK();
BC	 
BC	 
BC	 %(***********NOW BEGIN THE STRING POINTER ALLOCATION***********)%
BC	 
BC	 
BLISS  V. 1.0-2.12	13-JUN-73  14:07:36	OPMOD	OUTMO1.BLI		PAGE 48-6

BINCRKFROMTOKSSIZDOC	         INCR K FROM 0 TO SSIZ - 1  DO
BBEGINC	         BEGIN
BC	 
BREGISTBASETTC	                 REGISTER BASE T;
BTSYMTBLKC	                 T  _  .SYMTBL[.K];
BC	 
BWHILETNEQDOC	                 WHILE .T  NEQ  0  DO
BBEGINC	                 BEGIN
BC	 
BIFTVALTYPEXOPWDEQLSTRINGC	                         IF  .T[VALTYPE]  EQL  STRING
BC	 
BTHENC	                         THEN
BBEGINC	                         BEGIN
BRDATWDTCW2FULLC	                                 RDATWD  _  .T[CW2];
BZOUTBLRCODERELRIC	                                 ZOUTBLOCK(RCODE,RELRI);
BTCW2FULLHILOCC	                                 T[CW2]  _  .HILOC;
BHILOCHILOCC	                                 HILOC  _  .HILOC  +  1;
BENDC	                         END;
BC	 
BTTCLINKRIGHTC	                         T  _  .T[CLINK];
BENDC	                 END;
BENDC	         END;
BC	 
BC	 
BINCRKFROMTOKSSIZDOC	         INCR  K  FROM  0 TO  SSIZ  -  1  DO
BBEGINC	         BEGIN
BC	         
BREGISTBASETTC	                 REGISTER BASE T;
BTSYMTBLKC	                 T  _  .SYMTBL[.K];
BC	 
BWHILETNEQDOC	                 WHILE  .T  NEQ  0  DO
BBEGINC	                 BEGIN
BC	 
BL1C	                 L1:
BIFNOTTIDATTRCOMBLC	                         IF NOT .T[IDATTRIBUT(COMBL)]
BTHENC	                         THEN
BIFNOTTIDATTRINCOMC	                         IF NOT .T[IDATTRIBUT(INCOM)]
BTHENC	                         THEN
BIFNOTTIDATTRNAMNAMC	                         IF NOT .T[IDATTRIBUT(NAMNAM)]
BTHENC	                         THEN
BC	                         (
BIFNOTTIDATTRINEQVC	                            IF  NOT  .T[IDATTRIBUT(INEQV)]
BTHENC	                            THEN
BL2C	                                 L2:
BBEGINC	                                 BEGIN
BIFTOPRSP1EXOPWDEQLFNNAMEC	                                 IF  .T[OPRSP1]  EQL  FNNAME1
BTHENC	                                 THEN
BIFNOTTIDATTRFENTRYC	                                 IF NOT .T[IDATTRIBUT(FENTRYNAME)]
BTHENC	                                 THEN
BLEAVEL1C	                                 LEAVE  L1;
BC	 
BC	 
BC	         ! WE NOW HAVE ONLY VARIABLES, AND ARRAYS LEFT.
BC	 
BC	         ! SO FORMAT, AND OUTPUT THEM.
BC	 
BC	 
BLISS  V. 1.0-2.12	13-JUN-73  14:07:57	OPMOD	OUTMO1.BLI		PAGE 48-7

BC	                 !AM ONLY DOING VARIABLES, AND ARRAYS...NO FORMLVAR/ARY
BC	 
BIFTOPERSPEXOPWDEQLVARIABORFORMLVC	                 IF  .T[OPERSP]  EQL  VARIABLE  OR  FORMLVAR
BC	 
BTHENC	                 THEN
BBEGINC	                 BEGIN
BRDATWDC	                         RDATWD  _  0;
BRDATWDC	                         RDATWD<35,1>  _  1;     !SET THE VAR FLG
BIFTOPERSPEXOPWDEQLFORMLVC	                         IF .T[OPERSP] EQL FORMLVAR 
BTHENC	                         THEN
BRDATWDC	                         RDATWD<22,1>  _  1;     !SET S.DUM FLAG
BRDATWDEVALUTVALTYPEXOPWDC	                         RDATWD<6,6>  _  .EVALU[.T[VALTYPE]];
BRDATWDC	                         RDATWD<0,6>  _  3;            !LENGTH OF SYM ENT
BZOUTBLRDEBRELNC	                         ZOUTBLOCK(RDEB,RELN);
BC	 
BC	 
BC	                         !NOW OUTPUT WORD TWO
BC	 
BRDATWDTIDADDRCW2RRIGHTC	                         RDATWD  _  .T[IDADDR];
BZOUTBLRDEBRELRIC	                         ZOUTBLOCK(RDEB,RELRI);
BC	 
BC	                         !NOW OUTPUT WORD THREE
BC	 
BC	 
BC	 
BRDATWDTIDSYMBCW3FULLC	                         RDATWD  _  .T[IDSYMBOL];
BZOUTBLRDEBRELNC	                         ZOUTBLOCK(RDEB,RELN);
BC	 
BENDC	                 END;
BC	 
BIFTOPERSPEXOPWDEQLARRAYNC	                 IF  .T[OPERSP]  EQL ARRAYNAME
BC	 
BTHENC	                 THEN
BBEGINC	                 BEGIN
BC	                 
BC	 
BPTRTIDDIMCW0LLEFTC	                         PTR  _  .T[IDDIM];    !FETCH THE ARRAY INFO NODE
BCNTPTRC	                         CNT  _  .PTR  +  1;
BRDATWDC	                         RDATWD  _  0;
BRDATWDC	                         RDATWD<19,1>  _  1;
BRDATWDEVALUTVALTYPEXOPWDC	                         RDATWD<6,6>  _  .EVALU[.T[VALTYPE]];
BRDATWDPTRC	                         RDATWD<0,6>  _  .PTR<34,16>+4;  !ENT SIZ
BZOUTBLRDEBRELNC	                         ZOUTBLOCK(RDEB,RELN);
BC	 
BC	                         ! NOW OUTPUT WORD TWO
BC	 
BRDATWDLEFTPTRC	                         RDATWD<LEFT>  _  .PTR<34,16>;   !#DIMS
BRDATWDRIGHTCNTLEFTC	                         RDATWD<RIGHT> _  .CNT<LEFT>;     !ARAOFFSET
BZOUTBLRDEBRELRIC	                         ZOUTBLOCK(RDEB,RELRI);
BC	 
BC	                         ! NOW OUTPUT WORD THREE
BC	 
BRDATWDTIDSYMBCW3FULLC	                         RDATWD  _  .T[IDSYMBOL];
BZOUTBLRDEBRELNC	                         ZOUTBLOCK(RDEB,RELN);
BC	 
BC	                         ! NOW OUTPUT WORD 4
BC	 
BLISS  V. 1.0-2.12	13-JUN-73  14:08:02	OPMOD	OUTMO1.BLI		PAGE 48-8

BRDATWDLEFTPTRRIGHTC	                         RDATWD<LEFT>  _  .PTR<RIGHT>;   !# WRDS IN ARRAY
BRDATWDRIGHTCNTRIGHTC	                         RDATWD<RIGHT>  _  .CNT<RIGHT>;   !ARADDVAR
BZOUTBLRDEBRELNC	                         ZOUTBLOCK(RDEB,RELN);
BC	         
BC	 
BC	                         ! NOW OUTPUT WORD N OF (MULTIPLIERS)
BC	 
BC	 
BINCRIFROMTOIPTRLEFTBYC	                         INCR I FROM 1 TO .PTR<LEFT>-1 BY 1
BDOC	                         DO
BBEGINC	                         BEGIN
BIFIEQLC	                         IF .I  EQL  1
BTHENRDATWDLEFTCNTIRIGHTC	                         THEN  RDATWD<LEFT>  _  .CNT+2*I<RIGHT>
BELSERDATWDRIGHTCNTIRIGHTC	                         ELSE  RDATWD<RIGHT>  _  .CNT+2*I<RIGHT>;
BENDC	                         END;
BC	 
BENDC	                 END;
BENDC	              END;
BC	 
BC	             );
BTTCLINKRIGHTC	                 T  _  .T[CLINK];
BENDC	         END;    !THIS END THE LOOP LOGIC
BENDC	     END;        !THIS ENDS THE OUTER LOOP LOGIC
BRDATWDC	         RDATWD  _  0;   !FLAG FOR LOADER = END OF BLOCK 30
BZOUTBLRDEBRELNC	         ZOUTBLOCK(RDEB,RELN);
BC	 
BENDC	 END;
BC	 
BLISS  V. 1.0-2.12	13-JUN-73  14:08:04	OPMOD	OUTMO1.BLI		PAGE 49-1

BC	 
BC	 
BC	 
BGLOBALD

	0000		JSP	07,.ENT.3			;EXTERNAL
  3805	0001		ADD	$S,[000002,,000002]
  3816	0002		MOVE	04,0
	0003		TRNN	04,2000
	0004		JRST	00,L37464
	0005		PUSH	$S,[004400,,OPMO.P+40]
	0006		PUSHJ	$S,ZOUTMSG
	0007		SUB	$S,[000001,,000001]
  3826	0010	L37464:	SETZM	00,5($F)			;LOCAL
	0011		SETZ	13,0
  3830	0012	L32020:	CAILE	13,116
	0013		JRST	00,L34432
  3832	0014		MOVE	12,SYMTBL(13)			;EXTERNAL
	0015	L32436:	JUMPE	12,L32550
  3836	0016		HRRZ	06,2(12)
	0017		JUMPN	06,L36716
  3837	0020		LDB	04,[060212,,000001]
	0021		MOVEI	05,1
	0022		CAIN	04,3
	0023		SETZ	05,0
	0024		LDB	06,[320112,,000001]
	0025		ANDCM	05,6
	0026		LDB	07,[420112,,000001]
	0027		ANDCM	05,7
	0030		TRNN	05,1
	0031		JRST	00,L36716
  3839	0032		MOVE	04,LOWLOC			;EXTERNAL
	0033		HRRM	04,2(12)
  3840	0034		LDB	06,[200112,,000001]
	0035		ADD	04,6
	0036		AOJ	04,0
	0037		MOVEM	04,LOWLOC			;EXTERNAL
	0040		MOVE	07,0
	0041		TRNN	07,2000
	0042		JRST	00,L36716
	0043		PUSH	$S,12
	0044		PUSHJ	$S,LISTSYM
	0045		SUB	$S,[000001,,000001]
  3842	0046		AOS	05,5($F)			;LOCAL
	0047		CAIG	05,5
	0050		JRST	00,L36716
	0051		SETZM	00,5($F)			;LOCAL
	0052		PUSHJ	$S,CRLF
  3843	0053	L36716:	HRRZ	12,0(12)
  3847	0054		JRST	00,L32436  ^^^
  3848	0055	L32550:	AOJA	13,L32020  ^^^
	0056	L34432:	SKIPN	04,FRSTLNK			;EXTERNAL
	0057		JRST	00,L40062
  3855	0060		MOVE	06,LOWLOC			;EXTERNAL
	0061		HRRM	06,2(04)
  3857	0062		AOS	07,LOWLOC			;EXTERNAL
	0063		MOVE	05,0
BLISS  V. 1.0-2.12	13-JUN-73  14:08:05	OPMOD	OUTMO1.BLI		PAGE 49-2

	0064		TRNN	05,2000
	0065		JRST	00,L32104
	0066		PUSH	$S,4
	0067		PUSHJ	$S,LISTSYM
	0070		SUB	$S,[000001,,000001]
  3859	0071		AOS	06,5($F)			;LOCAL
	0072		CAIG	06,5
	0073		JRST	00,L32104
	0074		SETZM	00,5($F)			;LOCAL
	0075		PUSHJ	$S,CRLF
  3860	0076	L32104:	MOVE	$V,FRSTLNK			;EXTERNAL
  3865	0077		HRRZ	04,0($V)
	0100		MOVEM	04,FRSTLNK			;EXTERNAL
  3866	0101		JRST	00,L34432  ^^^
	0102	L40062:	PUSHJ	$S,HISEGBLK			;EXTERNAL
  3878	0103		SETZ	13,0
  3884	0104	L36010:	CAILE	13,116
	0105		JRST	00,L32254
  3887	0106		MOVE	12,SYMTBL(13)			;EXTERNAL
	0107	L32514:	JUMPE	12,L33552
  3893	0110		LDB	07,[150512,,000001]
	0111		CAIE	07,17
	0112		JRST	00,L33714
  3897	0113		MOVE	04,2(12)
	0114		MOVEM	04,RDATWD			;EXTERNAL
	0115		PUSH	$S,[1]
	0116		PUSH	$S,[1]
	0117		PUSHJ	$S,ZOUTBLOCK			;EXTERNAL
	0120		SUB	$S,[000002,,000002]
  3898	0121		MOVE	06,HILOC			;EXTERNAL
	0122		MOVEM	06,2(12)
  3900	0123		AOS	07,HILOC			;EXTERNAL
  3901	0124	L33714:	HRRZ	12,0(12)
  3904	0125		JRST	00,L32514  ^^^
  3905	0126	L33552:	AOJA	13,L36010  ^^^
	0127	L32254:	SETZ	13,0
  3908	0130	L34264:	CAILE	13,116
	0131		JRST	00,L34006
  3909	0132		ADD	$S,[000001,,000001]
  3911	0133		MOVE	12,SYMTBL(13)			;EXTERNAL
	0134	L33376:	JUMPE	12,L36526
  3917	0135		MOVE	06,1(12)
	0136		TLNE	06,200000
	0137		JRST	00,L35224
	0140		MOVE	07,1(12)
	0141		TLNE	07,400
	0142		JRST	00,L35224
	0143		MOVE	05,1(12)
	0144		TLNE	05,-400000
	0145		JRST	00,L35224
  3924	0146		MOVE	04,1(12)
	0147		TLNE	04,1000
	0150		JRST	00,L35224
  3929	0151		LDB	06,[060212,,000001]
	0152		CAIE	06,3
	0153		JRST	00,L35062
	0154		MOVE	05,1(12)
BLISS  V. 1.0-2.12	13-JUN-73  14:08:08	OPMOD	OUTMO1.BLI		PAGE 49-3

	0155		TLNN	05,2000
	0156		JRST	00,L35224
  3943	0157	L35062:	LDB	05,[050312,,000001]
	0160		MOVEI	04,1
	0161		CAIE	05,2
	0162		SETZ	04,0
	0163		IORI	04,3
	0164		TRNN	04,1
	0165		JRST	00,L34600
  3947	0166		SETZM	00,RDATWD			;EXTERNAL
  3948	0167		MOVEI	06,1
	0170		DPB	06,[430100,,RDATWD]
  3949	0171		LDB	07,[050312,,000001]
	0172		CAIE	07,3
	0173		JRST	00,L35036
  3951	0174		MOVEI	05,1
	0175		DPB	05,[260100,,RDATWD]
  3952	0176	L35036:	LDB	05,[150512,,000001]
	0177		MOVE	04,EVALU(05)			;EXTERNAL
	0200		DPB	04,[060600,,RDATWD]
  3953	0201		MOVEI	07,3
	0202		DPB	07,[000600,,RDATWD]
	0203		PUSH	$S,[30]
	0204		PUSH	$S,[0]
	0205		PUSHJ	$S,ZOUTBLOCK			;EXTERNAL
	0206		SUB	$S,[000002,,000002]
  3954	0207		HRRZ	06,2(12)
	0210		MOVEM	06,RDATWD			;EXTERNAL
	0211		PUSH	$S,[30]
	0212		PUSH	$S,[1]
	0213		PUSHJ	$S,ZOUTBLOCK			;EXTERNAL
	0214		SUB	$S,[000002,,000002]
  3960	0215		MOVE	05,3(12)
	0216		MOVEM	05,RDATWD			;EXTERNAL
	0217		PUSH	$S,[30]
	0220		PUSH	$S,[0]
	0221		PUSHJ	$S,ZOUTBLOCK			;EXTERNAL
	0222		SUB	$S,[000002,,000002]
  3967	0223	L34600:	LDB	06,[050312,,000001]
	0224		CAIE	06,4
	0225		JRST	00,L35224
  3977	0226		HLRZ	05,0(12)
	0227		MOVEM	05,4($F)			;LOCAL
  3978	0230		AOJ	05,0
	0231		MOVEM	05,5($F)			;LOCAL
  3979	0232		SETZM	00,RDATWD			;EXTERNAL
  3980	0233		MOVEI	04,1
	0234		DPB	04,[230100,,RDATWD]
  3981	0235		LDB	06,[150512,,000001]
	0236		MOVE	07,EVALU(06)			;EXTERNAL
	0237		DPB	07,[060600,,RDATWD]
  3982	0240		LDB	05,[422016,,4]
	0241		ADDI	05,4
	0242		DPB	05,[000600,,RDATWD]
	0243		PUSH	$S,[30]
	0244		PUSH	$S,[0]
	0245		PUSHJ	$S,ZOUTBLOCK			;EXTERNAL
BLISS  V. 1.0-2.12	13-JUN-73  14:08:09	OPMOD	OUTMO1.BLI		PAGE 49-4

	0246		SUB	$S,[000002,,000002]
  3983	0247		LDB	04,[422016,,4]
	0250		HRLM	04,RDATWD			;EXTERNAL
  3988	0251		HLRZ	06,5($F)			;LOCAL
	0252		HRRM	06,RDATWD			;EXTERNAL
	0253		PUSH	$S,[30]
	0254		PUSH	$S,[1]
	0255		PUSHJ	$S,ZOUTBLOCK			;EXTERNAL
	0256		SUB	$S,[000002,,000002]
  3989	0257		MOVE	07,3(12)
	0260		MOVEM	07,RDATWD			;EXTERNAL
	0261		PUSH	$S,[30]
	0262		PUSH	$S,[0]
	0263		PUSHJ	$S,ZOUTBLOCK			;EXTERNAL
	0264		SUB	$S,[000002,,000002]
  3994	0265		HRRZ	05,4($F)			;LOCAL
	0266		HRLM	05,RDATWD			;EXTERNAL
  3999	0267		HRRZ	04,5($F)			;LOCAL
	0270		HRRM	04,RDATWD			;EXTERNAL
	0271		PUSH	$S,[30]
	0272		PUSH	$S,[0]
	0273		PUSHJ	$S,ZOUTBLOCK			;EXTERNAL
	0274		SUB	$S,[000002,,000002]
  4000	0275		MOVEI	11,1
  4006	0276		HLRZ	06,4($F)			;LOCAL
	0277		SOJ	06,0
	0300		MOVEM	06,6($F)			;LOCAL
  4007	0301	L35506:	CAMLE	11,6($F)			;LOCAL
	0302		JRST	00,L35224
  4008	0303		CAIE	11,1
	0304		JRST	00,L35666
  4010	0305		MOVE	$V,5($F)			;LOCAL
	0306		ADD	$V,[004400,,000022]
	0307		HRLM	$V,RDATWD			;EXTERNAL
	0310		JRST	00,L35426
  4011	0311	L35666:	MOVE	05,5($F)			;LOCAL
	0312		ADD	05,[004400,,000022]
	0313		HRRM	05,RDATWD			;EXTERNAL
  4012	0314	L35426:	AOJA	11,L35506  ^^^
  4018	0315	L35224:	HRRZ	12,0(12)
  4019	0316		JRST	00,L33376  ^^^
	0317	L36526:	SUB	$S,[000001,,000001]
  4020	0320		AOJA	13,L34264  ^^^
  4021	0321	L34006:	SETZM	00,RDATWD			;EXTERNAL
	0322		PUSH	$S,[30]
	0323		PUSH	$S,[0]
	0324		PUSHJ	$S,ZOUTBLOCK			;EXTERNAL
	0325		SUB	$S,[000002,,000002]
  4022	0326		SETZ	$V,0
	0327		SUB	$S,[000002,,000002]
  4024	0330		JRST	00,.EXT.3			;EXTERNAL


BROUTINHISEGBBLISS  V. 1.0-2.12	13-JUN-73  14:08:10	OPMOD	OUTMO1.BLI		PAGE 50-1

C	 GLOBAL ROUTINE HISEGBLK=
BBEGINC	 BEGIN
BC	 !ROUTINE GENERATES A HISEG BLOCK IN THE THE REL FILE
BC	 !WORD 1 OF THE HISEG BLOCK IS THE TWOSEG PSEUDO OP ID
BC	 !WORD 2 IS THE SIZE OF THE LOWSEG IN WORDS IN THE LEFT HALF
BC	 !	AND ZERO IN THE RIGHT HALF
BC	 !WORD 2 IS ONLY USEFUL IF WE WISH TO LOAD EXECUTABLE CODE IN THE LOWSEG
BC	 !	INSTEAD OF THE HISEG
BC	 
BEXTERNRDATWDRDATWDZOUTBLZOUTBLLOWLOCC	 EXTERNAL RDATWD,ZOUTBLOCK,LOWLOC;
BRDATWDC	 	RDATWD _ #400000^18 + #400000;
BZOUTBLRHISEGRELRIC	 	ZOUTBLOCK(RHISEG,RELRI);
BRDATWDLOWLOCC	 	RDATWD _ .LOWLOC^18 + 0;
BZOUTBLRHISEGRELNC	 	ZOUTBLOCK(RHISEG,RELN);
BENDC	 END;	!OF HISEGBLK
BGLOBALD

  4038	0000		MOVE	04,[400000,,400000]
	0001		MOVEM	04,RDATWD			;EXTERNAL
	0002		PUSH	$S,[3]
	0003		PUSH	$S,[1]
	0004		PUSHJ	$S,ZOUTBLOCK			;EXTERNAL
	0005		SUB	$S,[000002,,000002]
  4040	0006		HRLZ	05,LOWLOC			;EXTERNAL
	0007		MOVEM	05,RDATWD			;EXTERNAL
	0010		PUSH	$S,[3]
	0011		PUSH	$S,[0]
	0012		PUSHJ	$S,ZOUTBLOCK			;EXTERNAL
	0013		SUB	$S,[000002,,000002]
  4042	0014		SETZ	$V,0
  4043	0015		POPJ	$S,0


BROUTINRELINIC	 GLOBAL ROUTINE RELINIT= !INITIALIZES REL FILE
BBEGINC	 BEGIN
BC	 %
BC	 GENERATES BLOCKS	4 - ENTRY
BC	 			6 - NAME
BC	 			3 - HISEG
BC	 %
BEXTERNRELDATRELDATRELOCWRELOCWPROGNAMULENTHILOCHILOCC	 EXTERNAL RELDATA,RELOCWD,PROGNAME,MULENTRY,HILOC;
BMAPBASEMULENTMULENTC	 MAP BASE MULENTRY;	!PTR TO CHAIN OF MULTIPLE ENTRIES OF THIS SUBPROGRAM
BC	 !
BC	 !INIT FIRST BLOCK
BC	 !
BRELOCPRELOCWC	 	RELOCPTR_(RELOCWD-1)<0,2>; !INIT RELOC BITS BYTE PTR
BRELDATLEFTRENTRYC	 	RELDATA<LEFT>_RENTRY;  !CURRENT BLOCK TYPE IS ENTRY
BRELOCWR2PROGNAC	 	RELOCWD _ 0; R2 _.PROGNAME;
BWHILEDOC	 	WHILE 1 DO
BC	 	(
BRDATWDRADIX5C	 		RDATWD _ RADIX50();
BZOUTBLRENTRYRELNC	 		ZOUTBLOCK(RENTRY,RELN);
BIFMULENTNEQC	 		IF .MULENTRY NEQ 0
BTHENR2MULENTENTSYMCW3RRIGHTMULENTMULENTCLINKRIGHTC	 		THEN (R2 _ .MULENTRY[ENTSYM]; MULENTRY _ .MULENTRY[CLINK])
BELSEEXITLOC	 		ELSE EXITLOOP;
BC	 	);
BRDATWDR2PROGNARADIX5C	 	RDATWD _ (R2 _ .PROGNAME; RADIX50());
BLISS  V. 1.0-2.12	13-JUN-73  14:08:29	OPMOD	OUTMO1.BLI		PAGE 50-2

BZOUTBLRNAMERELNC	 	ZOUTBLOCK(RNAME,RELN);  !NAME BLOCK
BRDATWDIFFLGREGKA10THENELSEC	 	RDATWD_ IF .FLGREG<KA10> THEN (#10)^18 ELSE (#20010)^18;
BZOUTBLRNAMERELNC	 	ZOUTBLOCK(RNAME,RELN);	!THE FORTRAN-IV IDENTIFER
BC	 !NOW FOR HISEG
BHILOCC	 	 HILOC _   #400000;
BVREGC	 	.VREG
BENDC	 END;
BENDD

  4051	0000		MOVE	04,[000200,,RELOCWD-1]
	0001		MOVEM	04,RELOCPTR			;EXTERNAL
  4057	0002		MOVEI	05,4
	0003		HRLM	05,RELDATA			;EXTERNAL
	0004		SETZM	00,RELOCWD			;EXTERNAL
  4058	0005		MOVE	02,PROGNAME			;EXTERNAL
  4060	0006	L40532:	PUSHJ	$S,RADIX50
  4061	0007		MOVEM	$V,RDATWD			;EXTERNAL
	0010		PUSH	$S,[4]
	0011		PUSH	$S,[0]
	0012		PUSHJ	$S,ZOUTBLOCK
	0013		SUB	$S,[000002,,000002]
  4062	0014		SKIPN	06,MULENTRY			;EXTERNAL
	0015		JRST	00,L35706
	0016		HRRZ	02,3(06)
  4064	0017		HRRZ	$V,0(06)
	0020		MOVEM	$V,MULENTRY			;EXTERNAL
	0021		JRST	00,L40532  ^^^
  4066	0022	L35706:	MOVE	02,PROGNAME			;EXTERNAL
	0023		PUSHJ	$S,RADIX50
  4067	0024		MOVEM	$V,RDATWD			;EXTERNAL
	0025		PUSH	$S,[6]
	0026		PUSH	$S,[0]
	0027		PUSHJ	$S,ZOUTBLOCK
	0030		SUB	$S,[000002,,000002]
  4068	0031		MOVE	04,0
	0032		TRNN	04,4000
	0033		JRST	00,L35244
	0034		HRLZI	$V,10
	0035		JRST	00,L40346
	0036	L35244:	HRLZI	$V,20010
	0037	L40346:	MOVEM	$V,RDATWD			;EXTERNAL
	0040		PUSH	$S,[6]
	0041		PUSH	$S,[0]
	0042		PUSHJ	$S,ZOUTBLOCK
	0043		SUB	$S,[000002,,000002]
  4070	0044		MOVEI	05,-400000
	0045		MOVEM	05,HILOC			;EXTERNAL
  4074	0046		POPJ	$S,0




     1	0000		SETZ	$V,0
	0001		CALLI	00,12


BBLISS  V. 1.0-2.12	13-JUN-73  14:08:29	OPMOD	OUTMO1.BLID
BLISS  V. 1.0-2.12	13-JUN-73  14:08:37	OPMOD	END.BLI		PAGE 50-3

MODULE LENGTH = 1527+100
                                                                                                                                                                                                                                                                                                                                                         ` R