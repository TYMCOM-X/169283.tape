ALWAYS__0
	XLIST
DEFINE CX ' (Y,Z) <
U'Y__IT
IT__IT+1
>
IT__0
	CX RESET,RESETUUO	;0 RESET IO
	CX DDTIN,DDTIN		;1 EXT-GET DDT CHAR.
	CX SETDDT,SETDDT	;2 SETDDT LOC IN PROTECTED JOB DATA
	CX DDTOUT,DDTOUT	;3 EXT:SEND DDT CHAR.
	CX DEVCHR,DVCHR		;4 DEVICE CHARACTISTICS
	CX DDTGT,CPOPJ		;5 GET DDT MODE
	CX GETCHR,DVCHR		;6 DEVICE CHAR.(DIFF. NAME)
	CX DDTRL,CPOPJ		;7 RELEASE DDT MODE
	CX WAIT,WAIT		;10 WAIT TILL DEVICE INACTIVE
	CX CORE,CORUUO		;11 CORE UUO
	CX EXIT,EXIT		;12 EXIT
	CX UTPCLR,UTPCLR	;13 CLEAR DEC TAPE DIRECTORY 
	CX DATE,DATE		;14 GET DATE
	CX LOGIN,LOGIN		;15 LOGIN
	CX APRENB,APRENB	;16 ENABLE APR FOR TRAPPING
	CX LOGOUT,LOGOUT	;17 LOGOUT
	CX SWITCH,SWITCH	;20 RETURN DATA SWITCHES
	CX REASSIGN,REASSIGN	;21 REASSIGN DEVICE TO ANOTHER JOB
	CX TIMER,TIMER		;22 RETURN JIFFY CLOCK TIME
	CX MSTIME,MSTIME	;23 RETURN TIME OF DAY IN MS
	CX GETPPN,GETPPN	;24 RETURN PROJECT-PROGRAMMER NUMBER
	CX TRPSET,UUOERR	;25 SET PI TRAP LOC, AND USER IO
	CX TRPJEN,UUOERR	;26 DISMISS INTERRUPT TO EXEC MODE
	CX RUNTIM,JOBTIM	;27 RETURN TOTAL JOB RUNNING TIME
	CX PJOB,JOBNO		;30 RETURN JOB NUMBER
	CX SLEEP,SLEEP		;31 SLEEP FOR N SECONDS, THEN RETURN TO USER
	CX SETPOV,SETPOV	;32 SET PUSH DOWN OVERFLOW TRAP
	CX PEEK,PEEK		;33 PEEK INTO SYSTEM CORE.		;JS
	CX GETLIN,GETLN		;34 GET NAME OF TTY
	CX RUN,UUOERR		;35 RUN COMMAND
	CX SETUWP,setuwp	;36 SET USER WRITE PROTECT
	CX REMAP,remap		;37 REDO CORE MAP
	CX GETSEG,UUOERR	;40 GET SEGMENT
	CX GETTAB,UUOERR	;41 GETTAB ILLEGAL AT STANFORD.
IT__400000
	CX SPCWAR,SPCWAR	;0 READ SWITCH REGISTER	;JS
	CX CTLV,CTLV		;1 PUT TTY IN NON-DUPLEX MODE. ;JS
	CX SETNAM,SETNAM	;2 SET JOB NAME FOR SYSTAT
	CX SPCWGO,SPCWGO	;3 ANOTHER SPACEWAR UUO
	CX SWAP,SYSRJB		;4 RUN A JOB
	CX EIOTM,EIOTM		;5 ENTER IOT USER MODE
	CX LIOTM,LIOTM		;6 LEAVE IOT USER MODE
	CX PNAME,PNAME		;7 GET A DEVICE'S PHYSICAL NAME
	CX UFBGET,UFBGET	;10 GET A FAST BAND
	CX UFBGIV,UFBGIV	;11 RELEASE A FAST BAND
	CX UFBCLR,FBFLUSH	;12 RELEASE ALL FAST BANDS
	CX JBTSTS,USTAT		;13 GET JOB STATUS WORD OF A JOB
	CX TTYIOS,TTYIOS	;14 GET A JOB'S TELETYPES STATUS WORD
	CX core2,core2		;15 Funny core UUO for high segments
	CX attseg,attseg	;16 Attach high segment
	CX detseg,detseg	;17 Detach high segment
	CX setpro,setpro	;20 Change protection of high segment
	CX segnum,segnum	;21 get number of high segment
	CX segsiz,segsiz	;22
	CX linkup,linkup	;23
	CX dismis,dismis	;24
	CX intnb,intnb		;25 enable interrupts
	CX intorm,intorm	;26
	CX intacm,intacm	;27
	CX intns,intns		;30
	CX intiip,intiip	;31
	CX intirq,intirq	;32
	CX intgen,intgen	;33 generate an interrupt
	CX uwait,uwait		;34
	CX debreak,debreak	;35
	CX setnm2,setnm2	;36 set name of upper, if any
	CX segnam,segnam	;37 get name of upper, if any
	CX IWAIT,IWAIT		;40
	CX uskip,uskip		;41 Skip if a UWAIT really has to wait.
	CX buflen,buflen	;42 Return buffer length for a device
	CX namein,namein	;43 See if this job name exists
	CX slevel,setlvl	;44 Set or get service level.
	CX ienbw,ienbw		;45 Enable interrupts and immediately go into wait state
	CX runmsk,runmsk	;46 Sets processor run mask
	CX ttymes,ttymes	;47 SEND A STRINGTO A TTY
	CX jobrd,jobrd		;50 Read a block from a guy's core image - 400050
	CX devuse,devuse	;51 To tell how many people are waiting for a device
	CX setpr2,setpr2	;52 Set second protect-relocate register!
	CX getpr2,pr2get	;53 Get last setpr2 value
	CX rlevel,rlevel	;54 Get current service level reservation
	CX ufbphy,fbphy		;55 get physical band number
	CX ufbskp,fbskp		;56 skip if no transfer in progress
	CX fbwait,fbwt		;57 Wait for transfer to finish
	CX ufberr,fberr		;60 Skip if no errors in last transfer.
	CX wakeme,wakeme	;61 set ALFRED. Time to initialize a job.
	CX getnam,getnam	;62 return jobname in ac
	CX sneakw,sneakw	;63 peek at next tty char. and wait for it
	CX sneaks,sneaks	;64  "   "   "    "   "    and skip if one there
	CX gdptim,gdptim	;65 Get time cells
	CX setprv,setprv	;66 reset jobtprv
	CX DDCHAN,DDCHAN	;67 GET/RELEASE DD CHANS ETC.
	CX VDSMAP,VDSMAP	;70 CHANGE VIDEO SWITCH MAPPING
EXTERNAL  JOBSA,JOBREN,JOBUUO
EXTERNAL JOBSYM,JOBFF,JOBREL,JOB41,JOBDDT,JOBCNI,JOBTPC,JOBUUO
EXTERNAL JOBAPR
SUBTTL	SAIL/GOGOL MACROS
DEFINE EXPO <IFN EXPORT, >	;code for export only
DEFINE NOEXPO <IFE EXPORT, >	;code for Stanford only
DEFINE GAG <IFN DCS, >		;SLS or WOM systems (experimental)
DEFINE NOGAG <IFE DCS, >	;not included in SLS or WOM systems
DEFINE WOM <IFGE DCS-1, >	;WOM system
DEFINE NOWOM <IFE DCS,>		;not included in WOM system
DEFINE SLS <IFE DCS-2, >	;SLS system
DEFINE NOSLS <IFN DCS-2, >	;etc.
DEFINE GLOB <IFN GLOBSW, >	;since global compiler (GLOBC) can service
DEFINE NOGLOB <IFE GLOBSW, >	; non-global code, GLOBC is different
DEFINE GLOC <IFN GLOBC, >	; from GLOB (global model)
DEFINE NOGLOC <IFE GLOBC, >
DEFINE UP <IFN UPPER,>		;upper segment code (only used in runtime)
DEFINE NOUP <IFE UPPER,>	;not
DEFINE LOW <IFN LOWER,>		;lower bootstrap for 2 seg thing (ditto)
DEFINE NOLOW <IFE LOWER,>	;not
DEFINE LEP <IFN LEAPSW,>	;this compiler understands LEAP
DEFINE NOLEP <IFE LEAPSW,>	;doesn't (applies to runtime too)
DEFINE REN <IFN RENSW,>		;Re-entrant output (comp), runtimes (runtim)
DEFINE NOREN <IFE RENSW,>
DEFINE DIS <IFN DISSW,>		;Display registeers -- very Stygian code
DEFINE NODIS <IFE DISSW,>	;not
DEFINE STSW (V,VL) <IFNDEF V,<V__VL>>
STSW (EXPORT,0);NOT USUALLY EXPORT VERSION
STSW (DCS,0);NOT USUALLY SLS OR WOM
STSW (HEDSYM,0)		;USUALLY NOT A USER-TABLE SYMBOL GENERATOR
STSW (DISSW,1)	;FOR DISPLAY REGISTERS & OTTER GOODIES
EXPO <
STSW (SIXSW,0)
>;EXPO
NOEXPO <
STSW (SIXSW,1)
>;NOEXPO
II__1
FOR @' JJ(HEAD,SAIL,PARSE,PDEFS,PRODS,SUBRS,SMTB,SYM,GEN,ARRAY) <
..'JJ__II
II__II1
>
FOR @' JJ(EXPRS,STATS,LEAP,TOTAL,COMSER,GOGOL,STRSER,IOSER,LEPRUN,MESPRO) <
..'JJ__II
II__II1
>
IFDEF SETLST,<SETLST>
IFNDEF ..LIST,<
..LIST__0
FOR @' JJ(HEAD,SAIL,PARSE,SYM,GEN,ARRAY,EXPRS,STATS,LEAP,TOTAL,COMSER) <
..LIST__..LIST!..'JJ
>
FOR @' JJ(GOGOL,STRSER,IOSER,LEPRUN,MESPRO) <
..LIST__..LIST!..'JJ
>>
IFDEF SETLS2,<
	SETLS2
>
DEFINE LSTON ' (JJ) <
	XLIST
IFN ..LIST & ..'JJ,<
	LIST>
>
	LSTON	(HEAD)
DEFINE DSCR <COMMENT  > ; FOR DIRECTORY MAKER
DEFINE GEN <IFE .NOGEN,<LALL>>
DEFINE NOGEN <XALL>
.NOGEN__1	;DON'T EXPAND MACROS AT ALL AFTER FIRST NOGEN
	NOGEN
DEFINE IFNB (X) <IFDIF <><X>,>
DEFINE IFB (X) <IFIDN <><X>,>
DEFINE HERE(X) <
UP <
	FQQQQ __ .
	USE DSPCH	;SO THAT THE LABELS HAVE THE SAME ADDRESS
^^ X :	JRST	FQQQQ
	USE
>;UP
NOUP <
^^ X :			;IF NOT MAKING AN UPPER SEGMENT, DOES NOT MATTER.
>;NOUP
>
DEFINE DATA (MSG) <
	USE	VBLS
	IFGE	.-DBASE-DSIZE,<#DATERR	;DATA AREA TOO SMALL
>>
DEFINE TABLEDATA (MSG) <
	ZERODATA ()
>
DEFINE TABCONDATA (MSG) <
	DATA ( )
>
DEFINE ZERODATA (MSG) <
	USE	ZVBLS
	IFGE	.-ZBASE-ZSIZE,<#DATERR	;ZEROED DATA AREA TOO SMALL
>>
DEFINE BITDATA (MSG) <	USE>
DEFINE BITDDATA (MSG) <	USE>
DEFINE BIT2DATA (MSG) <	USE>
DEFINE BITD2DATA (MSG) < USE>
DEFINE ACDATA (MSG) <	USE>
DEFINE AC2DATA (MSG) <	USE>
DEFINE ENDDATA <
IFDEF ZBASE, <
	DATA ()		;CHECK
	ZERODATA ()		;CHECK
	USE
>>
DEFINE SETCOR (SIZE,FIRST,LAST) <
	MOVE	C,SIZE
	PUSHJ	P,CORGET
	ERR	<CAN'T GET CORE FOR FIRST ALLOCATION>
	IFDIF <FIRST><>, <MOVEM	B,FIRST>
	IFDIF <LAST><>,<
		ADD	C,B
		MOVEM	C,LAST
>>
DEFINE LEVPOINT(AD)< POINT DLFLDL,AD,35-LLFLDL>
DEFINE MOVEWI (I,J) <
		MOVEI TEMP,J
		MOVEM TEMP,I
>
DEFINE MOVEW (I,J) <
		MOVE	TEMP,J
		MOVEM	TEMP,I
>
DEFINE MOVE6 (I,J) <
		MOVE	TEMP,[SIXBIT /J/]
		MOVEM	TEMP,I
>
DEFINE MOVEI7 (I,J) <
		MOVEI	TEMP,[ASCIZ /J/]
		MOVEM	TEMP,I
>
DEFINE LOAD6 (I,J) <
		MOVE	I,[SIXBIT /J/]
>
DEFINE LOADI7 (I,J) <
		MOVEI	I,[ASCIZ /J/]
>
EXPO <
DEFINE CALL6 (I,J) <
	IFDIF <><J>,<
		IFDIF <><I>,<CALL I,[SIXBIT /J/];>  CALL [SIXBIT /J/]
>
	IFIDN <><J>,<
		CALL	[SIXBIT /I/]
>>
>;EXPO
NOEXPO <
DEFINE CALL6 ' (I,J) <
	IFDIF <><J>,<
		IFDIF <><I>,<CALLI I,U'J;> CALLI U'J
>
	IFIDN <><J>,<
		CALLI U'I
>>
>;NOEXPO
NOEXPO <
DEFINE DPYPOS (LINE) <
		XWD 702100,LINE>
DEFINE DPYSIZ (NUMGLT,GLTSIZ) <
		702140B17+NUMGLT9+GLTSIZ>
DEFINE DPYSTO (LOC) <
		XWD LOC,64>
DEFINE DPYRST (LOC) <
		XWD LOC,74>
DEFINE AIVECT & (X,Y)   <
		X&B10+Y&B21+146>
DEFINE RIVECT & (X,Y) <
		X&B10+Y&B21+46>
DEFINE DPYJMP (ADDR) <
		XWD ADDR,20>
>;NOEXPO
DEFINE EXCHOP	<
	EXCH	PNT,PNT2
	EXCH	TBITS,TBITS2
	EXCH	SBITS,SBITS2	>
DEFINE MOVOPS	<
	MOVE	PNT2,PNT
	MOVE	TBITS2,TBITS
	MOVE	SBITS2,SBITS
>
DEFINE SAVACS (L) <
 FOR II L ,<
	PUSH	P,II
>>
DEFINE RESTACS (L) <
FOR II  L, <
	POP	P,II
>>
DEFINE OP1 &(OPR,MS,ACC)  <
	IFIDN <ACC><>, <II__0>
	IFDIF <ACC><>, <II__ACC>
	OPR&. II,[ASCIZ /MS/]
>
FOR OP  (ERR,IOERR) <
DEFINE OP (MSG,AC,ADDR) <
	IFIDN	<ADDR><>,<OP1 (OP,<MSG>,AC)>
	IFDIF <ADDR><>,<JRST	[OP1 (OP,<MSG>,AC)
			   JRST	ADDR ]>
>>
DEFINE PRINT (X) <
	TTCALL	3,[ASCIZ /X/]
>
DEFINE TERPRI (X) <
	TTCALL	3,[ASCIZ /X
/]>
DEFINE LODBLK (TYPE,TYP1,NAME,NAME1,COUNT,COUNT1,RELOC) <
IFNB (NAME1) <
^^NAME1:
IFNB (COUNT1) <
	XWD	COUNT1,NAME;>	XWD   COUNT+2,NAME
>
^^NAME: XWD	TYP1,COUNT
IFNB (RELOC) <
	RELOC;>			0
	BLOCK	COUNT
>;LODBLK
DEFINE CHKCHN (AA,ROUTIN) & <
		TRZE	AA,777760	;ZERO BITS AND TEST VALID
		ERR <ROUTIN&: INVALID CHANNEL NUMBER>
>
DEFINE TSTERR (CHAN) <
		STATZ CHAN,740000 ;ANY ERRORS?
>
DEFINE TSTEOF (CHAN,EOFADD) <
		STATZ CHAN,20000  ;END OF FILE?
		JRST EOFADD	  ; YES
>
DEFINE GETBLK ( X ) <
	PUSHJ	P,BLKGET
	IFDIF <X><>,<HRRM	LPSA,X>>
DEFINE FREBLK ( X ) <
	IFIDN <><X>,<PUSH P,LPSA;>  PUSH P,X
	PUSHJ	P,BLKFRE
	>
DEFINE RIGHT (X,Y,Z ) <
	IFDIF <X><>,<MOVE LPSA,X>
	HRRZ	LPSA,Y(LPSA)
	IFDIF <Z><>,<JUMPE	LPSA,Z>>
DEFINE LEFT (X,Y,Z) <
	IFDIF <><X>,<MOVE LPSA,X>
	HLRZ	LPSA,Y(LPSA)
	IFDIF <><Z>,<JUMPE LPSA,Z>>
DEFINE GETSEM (X) <
	MOVE	PNT,GENLEF+X
	PUSHJ	P,GETAD	>
DEFINE GETSM2 (X) <
	MOVE	PNT2,GENLEF+X
	PUSHJ	P,GETAD2 >
DEFINE	GENMOV (Z,X,Y) <
	IFDIF <X><>,<HRRI FF,X>
	IFDIF <Y><>,<HRRI B,Y>
	PUSHJ	P,Z>
NOGAG <
DEFINE	XCALL	' (X)	<
	MOVEI	A,LIBTAB+R'X	;FIXUP LOCATION.
	PUSHJ	P,XCALLQ
	>
>;NOGAG
GAG <
	DEFINE XCALL ' (X) <
	HRLI	C,X		;ADDRESS OF ROUTINE (OH, WOW!)
	PUSHJ	P,[
	MOVE	A,[PUSHJ RP,NOUSAC!USADDR]
	JRST	EMITER]
	>
>;GAG
DEFINE LPCALL ' (X,Y,Z) <
	MOVEI	A,L'X		;ROUTINE NAME.
	IFDIF <Y><>,<ADD A,Y>
	IFIDN <Z><>,<PUSHJ P,LEAPC1;> PUSHJ P,LEAPC2
	>
DEFINE XPREP	<
	PUSHJ	P,[
		HRRI	D,1
		JRST	STORZ]
	>
SLS <
DEFINE SALCAL (ROUT,PLIS,SLIS) <
	INDXNO__0
	SWITCH__0
	PUSHJ	P,SALSAV	;SAVE ALL NON-DEDICATED ACS
IFDIF <><PLIS>,<
FOR ARG(PLIS), <
	FOR JJ<ARG>,<
	   IFIDN <JJ><->,<
		SWITCH__-1>>
	IFGE SWITCH,<
	IFDIF <ARG><>,<
	PUSH	P,ARG(INDXNO)
>
	INDXNO__0;ELSE>INDXNO__-ARG
	SWITCH__0
>
>
	EXCH	SP,STPSAV	;STRING STACK FROM MOTHBALLS
	INDXNO__0
	SWITCH__0
IFDIF <><SLIS>,<
FOR ARG(SLIS), <
	FOR JJ<ARG>,<
	 IFIDN <-><JJ>,<
		SWITCH__-1>>
	IFGE SWITCH,<
	IFDIF <ARG><>,<
	PUSH	SP,ARG(INDXNO)
	PUSH	SP,ARG+1(INDXNO) ;STRING ARGUMENT
>
	INDXNO__0;ELSE>INDXNO__-ARG
	SWITCH__0
>
>
	EXTERNAL ROUT
	PUSHJ	P,ROUT		;CALL SAIL PROCEDURE
	EXCH	SP,STPSAV	;STOW THE STACK
	PUSHJ	P,SALRST	;GET AC VALUES BACK, SIL VOUS PLAIS.
>;SALCAL
>;SLS
DEFINE	EMIT	(INSTR) <
	MOVE	A,[INSTR]
	PUSHJ	P,EMITER	;CALL EMITER
>
DEFINE	QPUSH (X,Y)	<
	IFDIF <X><>,<MOVEI LPSA,X>
	IFDIF <Y><>,<MOVE A,Y>
	PUSHJ	P,BPUSH		>
DEFINE	QPOP (X)	<
	IFDIF <X><>,<MOVEI LPSA,X>
	PUSHJ 	P,BPOP		>
DEFINE  QLOOK (X)	<	
	HLRZ	A,X		>
DEFINE	QTAKE	(X)	<
	IFDIF <X><>,<MOVEI LPSA,X>
	PUSHJ	P,QTAK		>
DEFINE QBACK <
	PUSHJ	P,BBACK
>
DEFINE QFLUSH (X) <
IFDIF <><X> <
	MOVEI	LPSA,X
>
	PUSHJ	P,BFLUSH
>
DEFINE QBEGIN (X)<
IFDIF <><X> <
	MOVEI	LPSA,X
>
	PUSHJ	P,BBEG
>
DEFINE SETNIT <
	MOVE	TEMP,[JSR UUO0]	;MAKE SURE WE CAN DO UUOS
	MOVEM	TEMP,41
	MOVE	P,ALLPDP	;AND PUSHJ'S
>
DEFINE SETPOV (AC,STR) <
 IFIDN <STR><><MOVEI TEMP,0;>MOVEI TEMP,[ASCIZ ?STR?] ;GET VALUE
 II__(AC+17)&17			;BETWEEN 0 AND 17
 JJ__II-(2*(II/2))		;ODD OR EVEN
 IFE JJ,<HRLM TEMP,POVTAB+(II/2); EVEN-- LEFT> HRRM TEMP,POVTAB+(II/2)
>;SETPOV
DEFINE BIT(NAME,BITT) <IFDIF <NAME><SPARE>,<NAME__BITT>>
DEFINE DEFTBS <
	BIT	(RES,400000)	;RESERVED WORD
	BIT	(CNST,200000)	;CONSTANT ENTRY
	BIT	(SPARE,100000)	;****
	BIT	(INTRNL,40000)	;INTERNAL SYMBOL (SYMBOL EXPORTED)
	BIT	(EXTRNL,20000)	;EXTERNAL SYMBOL (STORAGE FOUND ELSEWHERE)
	BIT	(MPBIND,10000)	;MATCHING PROCEDURE OR BINDING ITEMVAR
	BIT	(VALUE,4000)	;FORMAL PARAMETER CALL BY VALUE
	BIT	(REFRNC,2000)	;FORMAL PARAMETER CALL BY REFERENCE
	BIT	(CONOK,1000)	;OK TO CALL INTRINSIC WITH CONST ARGS AT COMPTIME
	BIT	(SIMPLE,400)	;FOR DISPLAY SYSTEMS ONLY
	BIT	(MESSAGE,200)	;A MESSAGE PROCEDURE !!!!!(STANFORD ONLY).
	BIT	(OWN,100)	;OWN VARIABLE ?
	BIT	(ANYTYP,40)	;ANYTYPED VARIABLE (USED IN PROCEDURE CALLS)
	BIT	(SAFE,20)	;SAFE -- FOR ARRAYS AND SUCH.
	BIT	(DEFINE,10)	;DEFINED MACRO IDENTIFIER
	BIT	(RECURS,4)	;THIS ROUTINE IS REENTRANT
	BIT	(BILTIN,2)	;IF ON IN TBITS, DON'T SAVE AC'S ON CALL.
	BIT	(SBSCRP,1)	;SUBSCRIPED VARIABLE (ARRAY)
	BIT	(INPROG,400000)	;PROCEDURE BEING DEFINED, KEEP FIXUP CHAIN
	BIT	(GLOBL,200000)	;GLOBAL LEAP VARIABLE
	BIT	(FORTRAN,100000);FORTRAN PROCEDURE (EXTERNAL)
	BIT	(FORWRD,40000)	;FORWARD PROCEDURE OR LABEL
	BIT	(PROCED,20000)	;PROCEDURE
	BIT	(SHORT,10000)	;SHORT INTEGER OR SHORT REAL
	BIT	(ITMVAR,4000)	;LEAP ITEMVAR
	BIT	(PNTVAR,2000)	;POINTER VARIABLE ?? (NOT IMPLEMENTED YET)
	BIT	(BOOLEAN,1000)	;BOOLEAN VARIABLE ?? (SAME AS INTEGER FOR NOW
	BIT	(ITEM,400)	;LEAP ITEM
	BIT	(STRING,200)	;A FHQ STRING
	BIT	(LPARRAY,100)	;TYPE OF THIS ITEM IS ARRAY
	BIT	(SET,40)	;LEAP SET
	BIT	(LABEL,20)	;LABEL
	BIT	(LSTBIT,10)	; COMPLEX NUMBER ?? (NOT IMPLEMENTED)
	BIT	(DBLPRC,4)	; DOUBLE PRECISION NUMBER ?? (NOT IMPLEMENTED)
	BIT	(FLOTNG,2)	;REAL NUMBER
	BIT	(INTEGR,1)	;INTEGER NUMBER
>
DEFTBS		;DEFINE THE TBITS
PDLOF_1B8	OPDEF	PDLOF	[1B8]
FLOAT_2B8	OPDEF	FLOAT	[2B8]
NOEXPO <
PDPFIX_<FIX>	OPDEF	PDPFIX	[FIX]
>;NOEXPO
FIX_3B8		OPDEF	FIX	[3B8]
IOERR._4B8	OPDEF	IOERR.	[4B8]
ERR._5B8	OPDEF	ERR.	[5B8]
SIXPNT_6B8	OPDEF	SIXPNT	[6B8]
DECPNT_11B8	OPDEF	DECPNT	[11B8]
OCTPNT_12B8	OPDEF	OCTPNT	[12B8]
FLTPNT_13B8	OPDEF	FLTPNT	[13B8]
JFOV_<JFCL 1,0>	OPDEF	JFOV	[JFCL 1,0]
DPYOUT_703B8	OPDEF	DPYOUT	[703B8]
DPYCLR_701B8	OPDEF	DPYCLR	[701B8]
ARERR_7B8	OPDEF	ARERR	[7B8]
UINBF_704B8	OPDEF 	UINBF	[704B8]
NOEXPO <
SEGSIZUUO 	_ 400022	;GET SIZE OF SECOND SEGMENT.
CORE2UUO	_ 400015	;GET SOME MORE SECOND SEGMENT.
GLBAR		__ 1000		;CURRENT LENGTH OF GLOBAL MODEL AREA.
>;NOEXPO
SUBTTL	SAIL/GOGOL USER TABLE DESCRIPTION
DEFINE XX (SYMBOL,SIZE,BACKUP) <
	SYMBOL__LOCAT
IFN HEDSYM,<
	ENTRY	SYMBOL			;FOR HEAD.REL SYMBOL FILE
>;N HEDSYM
	LOCAT__LOCAT+1
	IFDIF<SIZE><>< LOCAT__LOCAT+SIZE-1>
	IFDIF<BACKUP><>< LOCAT__LOCAT-BACKUP>
>
LOCAT__0		;MAKES SYMBOLS ABSOLUTE
 XX CLER,,1
 XX UUO1	;TRADITIONAL LOC FOR GOGOL RETRN ADRS FOR ERROR MSGS.
 XX STRLNK
 XX SPLNK	;LINK END FOR SPACE ALLOCATION.
 XX SETLNK	;LINK END FOR SETS.
 XX SGROUT	;LINK UP STRING DSCRPTR GENERATOR ROUTINES HERE
 XX KNTLNK	;PROFILE COUNTER LINK END
 XX ST		;BOTTOM OF STRING SPACE
 XX STTOP	;TOP OF SAME
 XX TOPBYTE	;NEXT FREE BYTE
 XX REMCHR	;-REMAINING FREE CHARS
 XX SGLIGN	;ON IF MUST BE ALIGNED TO FW BDRY (COMPILER ONLY).
 XX CHANS,20
 XX DSPTBL,=19,,	;BREAK CHAR DISPOSITION TABLE
 XX LINTBL,=19,,	;LINE NUMBER     "       "
 XX BRKTBL,=128,,	;CHARACTER BREAK TABLES
 XX BRKDUM		;EXTRA TO HELP STDBRK ALONG WITH DUMP MODE
 XX PDL		;IOWD SIZE,BASE  FOR SYSTEM PDL
 XX SPDL	;XWD SIZE,BASE FOR STRING PDL
NOEXPO <
XX  ZAPBEG,,1	;BEGINNING OF SECOND SEGMENT COPY OF STUFF.
>;NOEXPO
NOEXPO <
 XX CURMES		;CURRENT MESSAGE.
>;NOEXPO
 XX MAXITM		;CURRENT TOP ITEM NUMBER.
 XX OLDITM		;LINKED LIST OF OLD ITEMS (DUMP HEAP).
 XX INFOTAB		;POINTER TO "GOOD POINTER" BLOCK OF CORE.
 XX DATAB		;POINTER TO DATUM AREA.
 XX HASTAB		;POINTER TO THE LEAP HASH TABLE.
 XX FP1			;FREE STORAGE -- 1 WORD.
 XX FP2			;FREE STORAGE -- 2 WORDS.
 XX HASMSK		;THE MASK FOR HASHING INTO OUR HASH SPACE.
 XX HASHP		;FOR PNAMES. XWD NEXT FREE ARRAY ENTRY,ARRAY BASE.
 XX MKBP		;MAKE BREAK-POINT
 XX ERBP		;ERASE BREAK-POINT
 XX PUBP		;PUT BREAK-POINT (NOT IMPLEMENTED)
 XX REBP		;REMOVE BREAK-POINT.(NOT IMPLEMENTED)
 XX ITMTOP		;MAXIMUM PERMISSIBLE ITEM NUMBER.
 XX LEABOT		;SEARCH CONTROL BLOCK FOR DERIVED SETS ERASE. 
 XX FRLOC		;CURRENT ACTIVE FOREACH CONTROL BLOCK POINTER
 XX SCBCHN		;CHAIN OF ABANDONED SCB'S
 XX FREITM	;NUMBER OF FREE ITEMS REMAINING
 XX ARYDIR	;FOR TELLING FOUR ARRAY ROUTINES WHICH END IS UP.
 XX ARYLS	;A LINKED LIST (LUCKILY) OF STRING ARRAYS IN LEAP, AND SO FORTH.
XX BLKTAB,3,3	;BASE OF BLOCK CONTROL TABLE
   XX LOWC	;LOW LIMIT OF ALLOCATABLE "BLOCK" CORE
   XX TOP	;UPPER LIMIT OF SAME
   XX FRELST	;POINTER TO BLOCK FREE STORAGE LIST
 XX XPAND	;PERMISSION TO EXPAND IN CORREL IF 0
 XX ATTOP	;REQUEST TO ALLOCATE OFF TOP OF CORE IF NON-0
 XX NOSHRK	;IF ON, CORREL NOT GIVEN PERMISSION TO SHRINK CORE
NOEXPO <
 XX USCOR2	;IF ON, CORGET WILL USE CORE2 ROUTINES.
>;NOEXPO
 XX BUFACS,10,,	;FOR BUFFER ALLOCATOR
NOEXPO <
XX ZAPEND,,1	;END OF SECOND SEGMENT AREA.
>;NOEXPO
 XX SGFRE	;[XWD -REMAINING-1,NEXT FREE LINK WORD-1] WHEN NON-ZERO
 XX STBUCK	;USED IN STRING GC TO KEEP TRACK OF BLOCKS
 XX INKY
 XX NUMCHR
 XX STMAX		;LENGTH OF STRING SPACE.
 XX SRELOC
 XX CODAC		;SAVE AC 1 OVER CALLS ON "CODE" RUNTIME ROUTINE
 XX WDTH		;GLOBAL WIDTH FOR STRING CONVERSION ROUTNES
 XX DIGS		; "" FOR # OF DECIMAL DIGITS
 XX SGCCNT		;NUMBER OF TIMES STRNGC HAS BEEN CALLED
 XX CDBLOC	;IF CHNL IS A CH #, @CDBLOC(USER) GETS ITS CDB ADDR
 XX FNAME	;ENTER-LOOKUP TABLE
 XX EXT
 XX WD3
 XX PRPN
 XX LONGWD	;LONG FORM LOOKUPS AND ENTERS POKE THIS
 XX LONG2	; AND THIS -- FILEINFO ROUTINE GIVES TO USER
 XX PROJ		;USED BY FILNAM ROUTINE
 XX RACS,13,,	;RE-ENTRANT ROUTINES SAVE HERE
 XX SGACS,14,,	;AVAILABLE ANY TIME IF YOU ARE NOT
 XX STACS,12,,	; LIKELY TO CALL STRNGC
 XX PGNNFL
 XX ENDREN	; END OF USER DATA TABLE
SUBTTL	Global AC Definitions, Indices, Bits
AC2DATA (GLOBAL AC ASSIGNMENTS)
P	_17
SP	_16
USER	_15
TEMP	_14
LPSA	_13
RF	__12			;THE ALMIGHTY F REGISTER
TAC1	__TEMP
TAC2	__LPSA
BITDATA (BITS FOR %ALLOC SPACE REQUEST BLOCRIES)
STDSPC __400000	;"INDIRECT" SPECIFICATION OF STANDARD AREA
WNTADR __200000	;ADDRESS OF AREA TO BE STORED AS SPECIFIED
WNTEND __100000	;ADDRESS OF NEXT AREA TO BE STORED AS SPECIFIED
WNTPDP __ 40000	;PDP TO AREA TO BE STORED " "
WNTPDL __ WNTPDP	;WNTPDP, WNTPDL -- WHAT'S THE DIFFERENCE?
USRTB  __ 20000	;RESULT ADDRESSES ARE IN THE USER TABLE
MINSZ  __ 10000	;THIS SIZE TO BE USED ONLY IF NO OTHERS GIVEN
BITDATA (INDICES OF STANDARDLY ALLOCATED AREAS (SEE %ALLOC))
SYSPD	__ 1		;SYSTEMPDL
SYSSPD	__ 2		;STRINGPDL
STRSP	__ 3		;STRINGSPACE
BITDATA (INDICES INTO THE FIXED PORTION OF EACH %ALLOC SPACE REQ. BLOCK)
$ITNO	__1		;MAX ITEM NUMBER DECLARED THIS COMPILATION
$NWITM __2		;REQUIRE n NEWITEMS PUTS n HERE
$GITNO	__3		;MAX (MIN?) GLOBAL ITEM NUMBER DECLARED
$MSLNK	__4		;POINTER TO MESSAGE PROCEDURE LIST PUT HERE
$PNMNO	__5		;REQUIRE n PNAMES PUTS n HERE
$VRNO	__6		;VERSION NUMBER
$SGNM	__7		;REQUIRED GLOBAL SEGMENT NAME (USUALLY EMPTY)
$SGD	__10		;REQUIRED GLOBAL SEGMENT FILE DEVICE
$SGF	__11		;" FILE NAME
$SGPP	__12		;" PPN
$TINIT __13
$PINIT __14
$SPREQ	__ 15		;OFFSET OF SPACE REQUEST ENTRIES WITHIN SPACE BLOCKS
ENDDATA
BITDATA (LINK NAMES)
%STLNK __ 1
%SPLNK __ 2
%SETLK __ 3
%SGROT __ 4
%KTLNK __ 5
%PDLNK __ 6
%INLNK __ 7
BITDATA (PROCEDURE DESCRIPTOR INDICES)
	DEFINE PDX(I),
		<I __ PD.XXX
		PD.XXX__PD.XXX+1
>
PD.XXX	__ 0
	PDX	PD.	;0
	PDX	PD.ID1	;1
	PDX	PD.ID2	;2
	PDX	PD.PDB	;3
	PDX	PD.NPW	;4
	PDX	PD.DSW	;5
	PDX	PD.LLW	;6
	PDX	PD.DLW	;7
	PDX	PD.PDA	;10
	PDX	PD.PPD	;11
	PDX	PD.PCW	;12
	PDX	PD.BDI	;13
PD.XXX__PD.XXX
BITDATA (TYPE CODES WITHIN RH OF INFOTAB ENTRY)
        BRKITM __ 2	;BRACKETED TRIPLE
	STTYPE __ 3	;STRING ITEM
	FLTYPE __ 4	;REAL ITEM
	INTYPE __ 5	;INTEGER ITEM
	LSTYPE __ 7	;LIST ITEM (TYPE SHOULD ALWAYS BE 1 MORE THN SETYPE
	SETYPE __ 6	;SET ITEM
	PITTYP __ 10	;PROCEDURE ITEM
	PRCTYP __ 11	;PROCESS ITEM
	INVTYP __ 25	;NON-VALID TYPE CODE
	ARRTYP __ 15	;ARRAYS ARE THIS PLUS SIMPLE TYPE CODE
ENDDATA
IFN HEDSYM, <		;MAKE AN HONEST ASSEMBLY OUT OF IT
	TITLE	HEAD
	END
>;IFN HEDSYM
SUBTTL	SAIL ASSEMBLY SPECIFICATIONS
DEFINE .VERSION <202000000051>
SUBTTL	Command File Descriptions
	LSTON	(GOGOL)
SUBTTL	Conditional Assembly Switches, Macros
STSW(UPPER,0)		;NOT UPPER OR LOWER IF NEITHER SET
STSW(LOWER,0)
STSW(GLOBSW,0)		;ONLY GLOBAL IF SOMEBODY ELSE SAID SO
STSW(SEGS,0)
STSW(RENSW,0)		;RE-ENTRANT LIBRARY (HISEG) IF ON
STSW(LEAPSW,1)		;ASSUME LEAP
DEFINE COMPIL ' (NAM,ENT,EXT,DSCRP,INT,HINHB) <
SUBTTL SAI'NAM -- DSCRP
IFE ALWAYS,<
	IFDIF <><ENT>,<ENTRY ENT>
	TITLE	SAI'NAM
REN <
	IFIDN <><HINHB>,<HISEG		;LOAD TO UPPER IF POSSIBLE>
>;REN
	IFDIF <><EXT>,<EXTERN EXT>
>
NOLOW <
	IFDIF <><INT>,<INTERN INT>
IFN ALWAYS,<
IFDIF <NAM><LOR>,<
IFDIF <><ENT>,<INTERNAL ENT>
>>
>;NOLOW
>
DEFINE ENDCOM (NAM) <
IFE ALWAYS,<
	END
>
>
IFNDEF ALWAYS,<ALWAYS__1>
IFN ALWAYS,<DEFINE ENTINT (X) <INTERNAL X>>
IFE ALWAYS,<DEFINE ENTINT (X) <ENTRY X>>
SUBTTL	Titles, Versions
IFN ALWAYS,<
LOW <
	TITLE LOWER
>;LOW
NOUP <
NOLOW <
	TITLE RUNTIM -- SAIL RUNTIME ROUTINES
>;NOLOW
JOBVER__137
	LOC	JOBVER
	.VERSION&777777000000	;CURRENT VERSION NUMBER (LH ONLY)
	RELOC
	LOC	124		;SET UP REENTER ADDRESS
	REENT
	RELOC
>;NOUP
>;ALWAYS0
EXTERNAL JOBHRL
SUBTTL	AC Definitions
FF__0
A_1						;TEMPS FOR ALLES
B_2						; (SOMETIMES SAVED)
C_3
D_4
		E_5		X_5		;MORE TEMPS
		Q1_6		Y_6
		Q2_7		Z_7
		Q3_10		Q_10
		T_11		CDB_11		;CHANNEL DATA BLOCK PTR
		T1_12		CHNL_12	;CHNL # FOR IOSER
LPSA_13					;TEMP, PARAM AC
TEMP_14					;TEMP ONLY
USER_15					;USER TABLE FOR RNTRNT ROUTS
SP_16						;STRING STACK
P_17						;SYSTEM STACK
SUBTTL	CDB, SIMIO Indices For IOSER, OTHER INDICES
DMODE	__ 0	    IOSTATUS __ 0	;DATA MODE		;RETURN STATUS
DNAME	__ 1	    IOIN     __ 1	;DEVICE			;BUFFERED INPUT
BFHED	__ 2	    IODIN    __ 2	;HEADER POINTERS	;DUMP INPUT
		     IOOUT    __ 3     			;BUFMODE OUT.
OBPNT	__ 3	    IODOUT   __ 4	;OUTPUT BUF. PTR	;DUMP OUTPUT
OBP	__ 4	    IOCLOSE  __ 5	;OUTPUT BYTE PTR	;CLOSE FILE
OCOWNT	__ 5	    IORELEASE__ 6	;OUTPUT BYTE CNT	;RELEASE FILE
ONAME	__ 6	    IOINBUF  __ 7	;OUTPUT FILE NAM	;INBUF
OBUF	__ 7	    IOOUTBUF __10	;OUTPUT BUFFER LOC.	;OUTBUF
		    IOSETI   __11				;USETI
IBPNT	__10	    IOSETO   __12	;SAME FOR INPUT		;USETO
IBP	__11	    						;  13 UNUSED
ICOWNT	__12	    IOOPEN   __14				;OPEN CHANNEL
INAME	__13	    IOLOOKUP __15				;LOOKUP FILE
IBUF	__14	    IOENTER  __16				;ENTER FILE
		    IORENAME __17				;RENAME FILE
ICOUNT	__15	;INPUT DATA COUNT LIMIT ADDRESS
BRCHAR	__16	;XWD TTYDEV FLAG, INPUT BREAK CHAR ADDR
TTYDEV  __16	;LH -1 IF DEVICE IS A TTY -- USED BY OUT
ENDFL	__17	;INPUT END OF FILE FLAG ADDR
ERRTST	__20	;USER ERROR BITS SPECIFICATION WORD
PGNNO	__20	;PAGE NUMBER FOR DISPLAY FEATURE (IF FEATURE NOT INCLUDED)
NOEXPO <
PGNNO	__21	;SAME THING IF IT IS INCLUDED
>;NOEXPO
^IOTLEN	__PGNNO+1	;LENGTH OF TABLE ENTRY
LUPDL_30			;LENGTH OF UUO PDL
MINPDS__=64			;SMALLEST ALLOWABLE SYSTEM PDL SIZE
DEFPDS__=192			;DEFAULT PDL SIZE
SUBTTL	Base (Low Segment) Data Descriptions -- Macros, Compil spec
NOUP <
DEFINE SGLK (ROUT) <
 XX	(,ROUT,)	;NAME OF STRING DSCRPTR GENERATING ROUTINE
 XX	(,0,)		;PLACE TO PUT A LINK
 LINK	4,.-1		;WHEREWITHAL TO GENERATE SAID LINK
>
>;NOUP
UP <
DEFINE SGLK (ROUT) <
 XX	(,ROUT,)
 XX	(,0,)
>
>;UP
DEFINE XX  (A,B,C,D) <
	IFDIF <A><>,< A :> B
	IFDIF <C><>,< C A >>>
UP <
III__140
	DEFINE XX (A,B,C,D) <
	IFDIF <A><>,< A _ III >
	III __ III + 1
	IFDIF <D><>,<III_III+D-1>
>
>;UP
                                                                                                                                                                                                                                                                                          F `