C       PLGFCN.FTF
        SUBROUTINE PUTPLUG
C
C       THIS ROUTINE WRITES THE PLUG DESCRIPTION OUT IF NECESSARY
C
        COMMON /PLUGS/ PLUGID(3),PLUGPNT,PLUGSIZ,NPLGPIN,PLGFLAG,THISPLG
        INTEGER PLUGPNT,PLUGSIZ,PLUGID,NPLGPIN,THISPLG
        LOGICAL PLGFLAG
C
        COMMON /FILES/NULL(7,6),FPLUGID(7)
        INTEGER FPLUGIDC
C
        IF (PLGFLAG) WRITE (FPLUGID(1)#THISPLG) PLUGID,PLUGPNT,PLUGSIZ,
     1  NPLGPIN
C
C       SET FLAG FALSE AND RETURN
        PLGFLAG = .FALSE.
        RETURN
        END
        SUBROUTINE GETPLUG(N)
C
C       THIS ROUTINE GETS PLUG ID BLOCK N, SAVING CURRENT VERSION IF 
C       NECESSARY
C
        COMMON /PLUGS/ PLUGID(3),PLUGPNT,PLUGSIZ,NPLGPIN,PLGFLAG,THISPLG
        INTEGER PLUGPNT,PLUGSIZ,PLUGID,NPLGPIN,THISPLG
        LOGICAL PLGFLAG
C
        COMMON /FILES/NULL(7,6),FPLUGID(7)
        INTEGER FPLUGIDC
C       TEST IF TO WRITE OUT
        IF (PLGFLAG) CALL PUTPLUG
C
C       NOW READ IN THE NEXT ONE
        READ (FPLUGID(1)#N) PLUGID,PLUGPNT,PLUGSIZ,NPLGPIN
        THISPLG = N
        RETURN
        END
        SUBROUTINE PUTPP
C
C       THIS ROUTINE WRITES OUT THE CURRENT PLUG-PIN DESCRIPTION IF
C       NECESSARY, TO DATA-BASE FILE
C
        COMMON /FILES/ FILES(7, 7), FPLUGDE(7)
        INTEGER FPLUGDE
C
        COMMON /PLUGPIN/ LIST(21), PPFLAG, THISPP
        INTEGER THISPP
        LOGICAL PPFLAG
C
C       WRITE OUT IF NECESSARY
        IF (PPFLAG) WRITE (FPLUGDE(1) # THISPP) LIST
        PPFLAG = .FALSE.
        RETURN
        END
        SUBROUTINE GETPP(N)
C
C       THIS ROUTINE GETS PLUG-PIN DESCRIPTION N, WRITING CURRENT IF
C       NECESSARY, TO DATA-BASE FILE
C
        COMMON /FILES/ FILES(7, 7), FPLUGDE(7)
        INTEGER FPLUGDE
C
        COMMON /PLUGPIN/ LIST(21), PPFLAG, THISPP
        INTEGER THISPP
        LOGICAL PPFLAG
C
C       TEST IF WE'VE ALREADY GOT IT
        IF (THISPP .EQ. N) RETURN
C
C       WRITE OUT OLD IF NECESSARY
        IF (PPFLAG) CALL PUTPP
C
C       NOW GET NEW PLUG-PIN IN
        READ (FPLUGDE(1) # N) LIST
        THISPP = N
        RETURN
        END
        SUBROUTINE GETLP
C
C       THIS ROUTINE GETS THE LIBRARY FILE PREAMBLE FOR file.
C       IT FIRST SETS UP THE LIBRARY FILE BLOCK, OPENS THE FILE,
C       VERIFIES IT, AND READS IT INTO THE LIBRARY PREAMBLE BLOCK.
C
        COMMON /CPGLOB/ KURSOR, LINSIZ, NATCH, INLINE(270), ISTTY,
     1  HUSH, UNCOLA, IPROMP, IDFILE(5)
        LOGICAL ISTTY, HUSH, UNCOLA
C
        COMMON /LIBFILE/ LFNO, LFSIZE, LFNREC, LFOPEN, LFID(5)
        LOGICAL LFOPEN
C
        COMMON /LIBPRE/ BLOKSIZ, INDXSIZ, NINDEX, INDEX1, PPBLOK1, FREE,
     1  KEYS(4)
        INTEGER BLOKSIZ, PPBLOK1, FREE
C
        INTEGER TEST(4)
        DATA TEST /'WIRRAP PLUG LIBRARY'/
C
C       FIRST TEST THE FILE
        CALL WCLOSE(LFNO)
        IDFILE(1) = LFID(1)
        IDFILE(2) = LFID(2)
        IDFILE(3) = LFID(3)
        IDFILE(4) = LFID(4)
        IDFILE(5) = LFID(5)
        I = LIBTEST(3)
C
C       NOW OPEN THE FILE
        CALL WOPEN(LFNO)
C
C       SKIP IF NEW FILE
        IF (I .NE. 2) GO TO 110
C
C       INPUT PREAMBLE
        READ (LFNO # 1) BLOKSIZ, INDXSIZ, NINDEX, INDEX1, PPBLOK1, FREE,
     1  KEYS
C
C       VERIFY THE FILE KEY
        DO 100 I = 1, 4
         IF (KEYS(I) .NE. TEST(I) ) GO TO 110
  100    CONTINUE
C
C       DONE..EXIT
        RETURN
C
C       HERE IF KEY DID NOT MATCH..GENERATE PREAMBLE AND WRITE OUT
  110   BLOKSIZ = 21
        INDXSIZ = 6
        NINDEX = 0
        INDEX1 = 2
        PPBLOK1 = 2
        FREE = 3
        DO 120 I = 1, 4
  120   KEYS(I) = TEST(I)
        CALL PUTLP
        RETURN
        END
        SUBROUTINE PUTLP
C
C       THIS ROUTINE WRITES OUT THE LIBRARY PREAMBLE IF THE FILE IS OPEN
C       TO THE CURRENT LIBRARY FILE.
C
C
        COMMON /LIBFILE/ LFNO, LFSIZE, LFNREC, LFOPEN, LFID(5)
        LOGICAL LFOPEN
C
        COMMON /LIBPRE/ BLOKSIZ, INDXSIZ, NINDEX, INDEX1, PPBLOK1, FREE,
     1  KEYS(4)
        INTEGER BLOKSIZ, PPBLOK1, FREE
C
C       IF OPEN, WRITE IT
        WRITE (LFNO # 1) BLOKSIZ, INDXSIZ, NINDEX, INDEX1, PPBLOK1,
     1  FREE, KEYS
        RETURN
        END
        SUBROUTINE PUTLPX
C
C       THIS ROUTINE WRITES THE CURRENT LIBRARY INDEX ENTRY TO
C       THE CURRENT LIBRARY FILE
C
        COMMON /LIBFILE/ LFNO, LFSIZE, LFNREC, LFOPEN, LFID(5)
        LOGICAL LFOPEN
C
C*********NOTE*******THIS ROUTINE ASSUMES THAT THERE IS ONLY ONE INDEX
C                    ENTRY PER BLOCK
        COMMON /LIBINXP/ LPXID(3), LPXSTAR, LPXSIZE, LPXNPIN, LPXFLAG,
     1  LPXTHIS
        LOGICAL LPXFLAG
C
C       IF FLAG IS SET, WRITE THE BLOCK OUT
        IF (LPXFLAG) WRITE (LFNO # LPXTHIS) LPXID, LPXSTAR, LPXSIZE,
     1  LPXNPIN
        LPXFLAG = .FALSE.
        RETURN
        END
        SUBROUTINE GETLPX(N)
C
C       THIS ROUTINE READS THE SPECIFIED LIBRARY INDEX N FROM THE
C       CURRENT LIBRARY FILE
C
        COMMON /LIBFILE/ LFNO, LFSIZE, LFNREC, LFOPEN, LFID(5)
        LOGICAL LFOPEN

C
C*********NOTE*******THIS ROUTINE ASSUMES THAT THERE IS ONLY ONE INDEX
C                    ENTRY PER BLOCK
        COMMON /LIBINXP/ LPXID(3), LPXSTAR, LPXSIZE, LPXNPIN, LPXFLAG,
     1  LPXTHIS
        LOGICAL LPXFLAG
C
C       IF WE'VE ALREADY GOT IT, EXIT
        IF (N .EQ. LPXTHIS) RETURN
C
C       DETERMINE IF TO WRITE OLD VERSION
        IF (LPXFLAG) CALL PUTLPX
C
C       NOW GET NEW ONE
        READ (LFNO # N) LPXID, LPXSTAR, LPXSIZE, LPXNPIN
        LPXTHIS = N
        RETURN
        END
        SUBROUTINE PUTLPP
C
C       THIS ROUTINE WRITES THE CURRENT LIBRARY PLUGPIN TO THE
C       CURRENT LIBRARY FILE.
C
        COMMON /LIBFILE/ LFNO, LFSIZE, LFNREC, LFOPEN, LFID(5)
        LOGICAL LFOPEN
C
        COMMON /PLUGPIN/ LISTPB(21), PPFLAG, THISPP
        INTEGER THISPP
        LOGICAL PPFLAG
C
C       IF FLAG IS SET, WRITE THE BLOCK OUT
        IF (PPFLAG) WRITE (LFNO # THISPP) LISTPB
        PPFLAG = .FALSE.
        RETURN
        END
        SUBROUTINE GETLPP(N)
C
C       THIS ROUTINE READS THE CURRENT LIBRARY PLUGPIN FROM THE
C       CURRENT LIBRARY FILE.
C
        COMMON /LIBFILE/ LFNO, LFSIZE, LFNREC, LFOPEN, LFID(5)
        LOGICAL LFOPEN
C
        COMMON /PLUGPIN/ LISTPB(21), PPFLAG, THISPP
        INTEGER THISPP
        LOGICAL PPFLAG
C
C       IF WE'VE ALREADY GOT IT, EXIT
        IF (N .EQ. THISPP) RETURN
C
C       DETERMINE IF TO WRITE OLD VERSION
        IF (PPFLAG) CALL PUTLPP
C
C       NOW GET NEW ONE
        READ (LFNO # N) LISTPB
        THISPP = N
        RETURN
        END
        LOGICAL FUNCTION LPXLOOK(ID)
C
C       THIS FUNCTION LOOKS THROUGH THE CURRENT LIBRARY INDICIES FOR A
C       MATCH WITH ID.  IF SUCCESS, RETURNS .TRUE., WITH INDEX IN
C       COMMON /LIBFILE/.  ELSE RETURNS .FALSE.
C
        COMMON /LIBPRE/ BLOKSIZ, INDXSIZ, NINDEX, INDEX1, PPBLOK1, FREE
        INTEGER BLOKSIZ, PPBLOK1, FREE
C
        COMMON /LIBINXP/ LPXID(3), LPXSTAR, LPXSIZE, LPXNPIN, LPXFLAG,
     1  LPXTHIS
C
        DIMENSION ID(3)
C
C       ASSUME FAILURE
        LPXLOOK = .FALSE.
        IF (NINDEX .LE. 0) RETURN
C
C       SEARCH FOR INDEX
        K = INDEX1
        DO 120 J = 1, NINDEX
        CALL GETLPX(K)
        K = K + 1
C
C       EXAMINE ENTRY FOR MATCH
        DO 110 I = 1, 3
        IF ( ID(I) .NE. LPXID(I) ) GO TO 120
C
  110   CONTINUE
C
C       GOT MATCH.. RETURN .TRUE.
        LPXLOOK = .TRUE.
        RETURN
C
C       THIS ENTRY DIDN'T MATCH
  120   CONTINUE
C
C       DIDN'T FIND IT..EXIT FALSE
        RETURN
        END
        LOGICAL FUNCTION LPXFIND(ID)
C
C       THIS FUNCTION SEARCHES THE LIBRARIES FOR A PLUG MATCHING ID.
C       IF FOUND, RETURNS .TRUE., WITH LIBPRE AND LIBINXP SET UP.
C       ELSE COMMENTS ON ERROR, RETURNS .FALSE.
C
        COMMON /LIBPRE/ BLOKSIZ, INDXSIZ, NINDEX, INDEX1, PPBLOK1, FREE
        INTEGER BLOKSIZ, PPBLOK1, FREE
C
        COMMON /LIBINXP/ LPXID(3), LPXSTAR, LPXSIZE, LPXNPIN, LPXFLAG,
     1  LPXTHIS
C
        COMMON /FILES/ FILES(7, 5), FPLUGL(7)
        INTEGER FPLUGL
C
        COMMON /LIBFILE/ LFNO, LFSIZE, LFNREC, LFOPEN, IDFILE(5)
C
        DIMENSION ID(3)
C
C       FIRST TEST THE FILE OF LIBRARY NAMES TO SEE IF ANY ARE DEFINED
        IF (FPLUGL(3) .GT. 0) GO TO 100
C
C       NO FILES DEFINED..COMMENT AND RETURN .FALSE.
        CALL ERROR('NO PLUG LIBRARIES DECLARED', 'NO LIBS')
        LPXFIND = .FALSE.
        RETURN
C
C       OPEN FILE IF NECESSARY
  100   CALL WOPEN(FPLUGL(1) )
        NLIB = FPLUGL(3)
C
C       GET THE SUCCESSIVE PLUG LIBRARY NAMES
        DO 110 LIBNO = 1, NLIB
         READ (FPLUGL(1) # LIBNO) IDFILE
C
C       GET AND VERIFY EACH LIBRARY FILE
         CALL GETLP
C
C       NOW LOOK UP ID IN THIS LIBRARY
         LPXFIND = LPXLOOK(ID)
         IF (LPXFIND) GO TO 120
        CALL WCLOSE(LFNO)
C
C       DONE WITH THIS LIBRARY..GET NEXT IF ANY
  110   CONTINUE
C
C       ID NOT FOUND IN ANY LIBRARIES..COMMENT AND RETURN
        CALL ERROR ('PLUG NOT DEFINED IN ANY DECLARED LIBRARIES',
     1          'CANNOT FIND PLUG')
  120   CALL WCLOSE(FPLUGL(1) )
        RETURN
        END
        LOGICAL FUNCTION PLGFIND(ID)
C
C       THIS FUNCTION FINDS THE SPECIFIED PLUG ENTRY AND INSURES IT IS
C       IN THE LIBRARY.  IT FIRST SEARCHES THE EXISTING PLUG DESCRIPTIONS,
C       AND IF NOT THERE, FINDS IT IN A LIBRARY IF POSSIBLE.  RETURNS
C       .FALSE. IF UNABLE TO FIND IT.  ELSE COPIES FROM LIBRARY TO
C       DATA-BASE TABLES PLUGS AND PLUGPIN.
C
        INTEGER ID(3)
C
        COMMON /FILES/ FILES(7, 6), FPLUGID(7), FPLUGDE(7)
        INTEGER FPLUGID, FPLUGDE
C
        COMMON /LIBFILE/ LFNO, LFSIZE, LFNREC, LFOPEN, LFID(5)
C
        COMMON /PLUGPIN/ LIST(21), PPFLAG, THISPP
        INTEGER THISPP
        LOGICAL PPFLAG
C
        COMMON /PLUGS/ PID(3), PLGPNT, PLGSIZ, NPLGPIN, PLGFLAG, THISPLG
        INTEGER PID, PLGPNT, PLGSIZ, NPLGPIN, THISPLG
        LOGICAL PLGFLAG
C
        COMMON /LIBINXP/ LPXID(3), LPXPNT, LPXSIZE, LPXNPIN, LPXFLAG,
     1  LPXTHIS
        LOGICAL LPXFLAG
C
C       DETERMINE IF ANY PLUGS DEFINED IN DATABASE
        IF (FPLUGID(3) .LE. 0) GO TO 120
C
C       READ SUCCESSIVE PLUG DESCRIPTIONS IN, TEST EACH
        DO 110 I = 1, FPLUGID(3)
         CALL GETPLUG(I)
         DO 100 J = 1, 3
          IF (ID(J) .NE. PID(J) ) GO TO 110
  100     CONTINUE
C
C       SUCCESS...SET FLAG AND RETURN
         PLGFIND = .TRUE.
         RETURN
C
C       SEARCH OVER ALL PLUGS
  110    CONTINUE
C
C       PLUG IS NOT IN DATA-BASE...SEARCH LIBRARIES
  120   PLGFIND = LPXFIND(ID)
        IF (.NOT. PLGFIND) RETURN
C
C       OPEN THE PLUG TABLES IF NECESSARY, SAVE THE CURRENT DISCR.
        CALL PUTPLUG
        CALL PUTPP
C
C       PLUG HAS BEEN FOUND..TRANSFER TO DATA-BASE TABLES
        DO 130 I = 1, 6
  130    PID(I) = LPXID(I)
        PLGFLAG = .TRUE.
        THISPLG = FPLUGID(3) + 1
        FPLUGID(3) = THISPLG
C
C       COMPUTE THE INCREASE IN SIZE OF THE PLUGPIN TABLE
        INCR = FPLUGDE(3)
        THISPP = INCR + 1
        PLGPNT = THISPP
        FPLUGDE(3) = INCR + LPXNPIN
        INDEX = LPXPNT
C
C       INPUT EACH PLUG-PIN FROM THE LIBRARY, RELOCATE IT, AND WRITE
C       IT OUT TO THE PLUG-PIN TABLE.
        DO 140 I = 1, LPXNPIN
         READ (LFNO # INDEX) LIST
         INDEX = INDEX + 1
         PPFLAG = .TRUE.
         LIST(19) = LIST(19) + INCR
         LIST(18) = LIST(18) + INCR
         LIST(17) = LIST(17) + INCR
         LIST(16) = LIST(16) + INCR
         IF (LIST(17) ) LIST(17) = THISPLG .OR. "400000000000
         CALL PUTPP
  140    THISPP = THISPP + 1
C
C       DONE..CLEAN UP AND EXIT
        THISPP = 0
        CALL WCLOSE(LFNO)
        CALL PUTPLUG
        RETURN
        END
        SUBROUTINE PUTPB
C
C       THIS ROUTINE WRITES OUT THE PLUGBUFFER ENTRY IF NECESSARY
C       ON THE TEMP FILE.
C
        COMMON /FILES/ FILES(7, 10), T3FILE(7)
        INTEGER T3FILE
C
        COMMON /PLUGBUF/ DATA(23), PBFLAG, THISPB
        INTEGER DATA, THISPB
        LOGICAL PBFLAG
C
C       DO IT
        IF (PBFLAG) WRITE(T3FILE(1) # THISPB) DATA
        PBFLAG = .FALSE.
        RETURN
        END
        SUBROUTINE GETPB(N)
C
C       THIS ROUTINE READS IN THE PLUGBUFFER ENTRY N
C       FROM THE TEMP FILE.
C
        COMMON /FILES/ FILES(7, 10), T3FILE(7)
        INTEGER T3FILE
C
        COMMON /PLUGBUF/ DATA(23), PBFLAG, THISPB
        INTEGER DATA, THISPB
        LOGICAL PBFLAG
C
C       DO IT
        IF (PBFLAG) CALL PUTPB
        READ (T3FILE(1) # N) DATA
        THISPB = N
        RETURN
        END
        SUBROUTINE PLGSAVE
C
C       THIS ROUTINE SAVES THE CURRENT PLUG DESCRIPTION (IN T3FILE)
C       ON THE CURRENT LIBRARY.
C
        COMMON /FILES/ FILE(7, 10), T3FILE(7)
        INTEGER T3FILE
C
        COMMON /LIBFILE/ LIBFILE(9)
        INTEGER LIBFILE
C
        COMMON /LIBPRE/ BLOKSIZ, INDXSIZ, NINDEX, INDEX1, PPBLOK, FREE,
     1  KEYS(4)
        INTEGER BLOKSIZ, PPBLOK, FREE
C
        COMMON /LIBINXP/ LPXID(3), LPXSTAR, LPXSIZE, LPXNPIN, LPXFLAG,
     1  LPXTHIS
        LOGICAL LPXFLAG
C
        COMMON /PLUGPIN/ PPLIST(21), PPFLAG, PPTHIS
        INTEGER PPLIST, PPTHIS
        LOGICAL PPFLAG
C
        COMMON /PLUGBUF/ PBLIST(21), FROMPB, TOPB, PBFLAG, THISPB,
     1  PLUGID(3), NPB, PB1, SAVEIT
        INTEGER PBLIST, FROMPB, TOPB, THISPB, PLUGID, PB1
        LOGICAL PBFLAG, SAVEIT
C
        INTEGER OLD, NEW
C
C       FIND THE STATE OF THE FILE
C
C       DETERMINE IF NEW ENTRY
        IF (.NOT. LPXLOOK(PLUGID(1) ) ) GO TO 140
C
C
C
C       OLD ENTRY...DELETE PREVIOUS LIST
        ITEM = LPXTHIS
        NEW = LPXSTAR
        OLD = NEW + LPXNPIN
        LPXSIZE = 0
        LPXFLAG = .TRUE.
C
C       DETERMINE IF LAST ELEMENT
  100   IF (OLD .NE. FREE) GO TO 110
C
C       DONE...SET UP
        FREE = NEW
        CALL GETLPX(ITEM)
        GO TO 200
C
C       MUST MOVE THE NEXT ELEMENT
  110   K = INDEX1
        DO 130 I = 1, NINDEX
        CALL GETLPX(K)
        K = K + 1
        IF (LPXSTAR .NE. OLD) GO TO 130
C
C       HERE WHEN GOTTEN ONE...SAVE AND MOVE IT
        LPXSTAR = NEW
        LPXFLAG = .TRUE.
        DO 120 I = 1, LPXNPIN
        CALL GETLPP(OLD)
        PPTHIS = NEW
        NEW = NEW + 1
        OLD = OLD + 1
  120   PPFLAG = .TRUE.
        GO TO 100
C
C       END OF LOOP OVER PLUG DESCRIPTION
  130   CONTINUE
        STOP
C
C
C
C       NEW DESCRIPTION...SET UP PARAMETERS
  140   NINDEX = NINDEX + 1
        IF (NINDEX .NE. 1) GO TO 150
C
C       FIRST DESCRIPTION IN LIBRARY...SET UP APPROPRIATELY
        PPBLOK = FREE
        ITEM = INDEX1
        GO TO 190
C
C       NOT FIRST DESCRIPTION...SET UP PARAMETERS
  150   NEW = FREE - 1
        FREE = FREE + 1
        ITEM = PPBLOK
C
C       MOVE ALL PINS UP IN FILE...KEEP GOING UNTIL DONE
  160   CALL GETLPP(NEW)
        PPTHIS = PPTHIS + 1
        PPFLAG = .TRUE.
        NEW = NEW - 1
        IF (NEW .GE. PPBLOK) GO TO 160
        CALL PUTLPP
C
C       NOW UPDATE ALL THE POINTERS
  170   K = INDEX1
        DO 180 I = 2, NINDEX
        CALL GETLPX(K)
        K = K + 1
        LPXSTAR = LPXSTAR+1
  180   LPXFLAG = .TRUE.
C
C       NOW DEFINE NEW ENTRY
        CALL PUTLPX
        PPBLOK = PPBLOK+1
        LPXTHIS = ITEM
C
C       MAKE A NEW ENTRY
  190   LPXID(1) = PLUGID(1)
        LPXID(2) = PLUGID(2)
        LPXID(3) = PLUGID(3)
        LPXTHIS = ITEM
  200   LPXNPIN = NPB
        LPXSIZE = 21*NPB
        LPXSTAR = FREE
        LPXFLAG = .TRUE.
C
C       NOW COPY THE NEW STUFF TO THE LIBRARY FILE
        CALL PUTLPX
        LPXTHIS = 0
        CALL PLINK
        ITEM = PB1
        DO 220 I = 1, NPB
        CALL GETPB(ITEM)
        ITEM = TOPB
        DO 210 J = 1, 21
  210   PPLIST(J) = PBLIST(J)
        PPTHIS = FREE
        PPFLAG = .TRUE.
        CALL PUTLPP
  220   FREE = FREE + 1
C       NOW CLEAN UP
        PPTHIS = 0
        CALL PUTLP
        RETURN
        END
        SUBROUTINE PLINK
C
C       THIS ROUTINE PERFORM THE PLUG/GROUP/SUBGROUP LINKAGE
C       (IN T3FILE) ON THE CURRENT LIBRARY.
C
        COMMON /FILES/ FILE(7,10), T3FILE(7)
        INTEGER T3FILE
C
        COMMON /PLUGBUF/ PBID, DEFAULT, GROUP, SUBGRP, ILT, OLT,
     1  GRPNO, SGRPNO, LOAD, DRIVE, WOCC, TCC, PBCORAL(2), GRPRING,
     2  SGRPRNG, PBX, PBY, LASTPB, NEXTPB, PBFLAG, THISPB, PLUGID(3),
     3  NPB, PB1, SAVEIT
        DOUBLE PRECISION DEFAULT, GROUP, SUBGRP
        REAL LOAD, DRIVE, PBX, PBY
        INTEGER PBID, ILT, OLT, GRPNO, SGRPNO, WOCC, TCC, PBCORAL,
     1  GRPRING, SGRPRNG, THISPB, PLUGID, PB1
        LOGICAL PBFLAG, SAVEIT
C
        DOUBLE PRECISION ID
        DATA MASK / "400000000000 /
C
C       SORT THROUGH, SET UP CORAL RING, CLEAR G/SG RINGS
        ITEM = PB1
        IT = 0
        DO 100 I = 1, NPB
        CALL GETPB(ITEM)
        ITEM = NEXTPB
        PBCORAL(1) = I+1
        PBCORAL(2) = 1
        GRPRING = 0
        SGRPRNG = 0
        IT = IT .XOR. MASK
        IF (IT) PBCORAL(2) = IT
  100   PBFLAG = .TRUE.
        PBCORAL(1) = 1
C
C       NOW SEARCH OVER GROUP RINGS
  110   ITEM = PB1
        ID = 0.0
        DO 130 I = 1, NPB
        CALL GETPB(ITEM)
        IF (GROUP .EQ. 0) GO TO 130
        IF (ID .NE. 0.0) GO TO 120
C
C       GOTTEN A GROUP...TEST IF NEW
        IF (GRPRING .NE. 0) GO TO 130
C
C       NEW GROUP...SET IT UP
        IT = I
        ID = GROUP
        J = ITEM
        K = GRPNO
        GO TO 130
C
C       WE'VE ALREADY GOTTEN A GROUP...DOES THIS BELONG?
  120   IF (GROUP .NE. ID) GO TO 130
        IF (K .NE. GRPNO) GO TO 130
C
C       LINK IT IN
        CALL GETPB(J)
        GRPRING = I
        PBFLAG = .TRUE.
        J = ITEM
        CALL GETPB(ITEM)
C
C       DONE WITH LOOP
  130   ITEM = NEXTPB
C
C       DETERMINE IF WE GOT ANYTHING THIS TIME
        IF (ID .EQ. 0.0) GO TO 140
        CALL GETPB(J)
        GRPRING = IT
        PBFLAG = .TRUE.
        GO TO 110
C
C       NOW SEARCH OVER SUBGROUP RINGS
  140   ITEM = PB1
        ID = 0.0
    O 160 I = 1, NPB
        CALL GETPB(ITEM)
        IF (SUBGRP .EQ. 0) GO TO 160
        IF (ID .NE. 0.0) GO TO 150
C
C       GOTTEN A SUBGROUP...TEST IF NEW
        IF (SGRPRNG .NE. 0) GO TO 160
C
C       NEW SUBGROUP...SET IT UP
        ID = SUBGRP
        IT = I
        J = ITEM
        K = SGRPNO
        GO TO 160
C
C       WE'VE ALREADY GOTTEN A SUBGROUP...DOES THIS BELONG?
  150   IF (SUBGRP .NE. ID) GO TO 160
        IF (K .NE. SGRPNO) GO TO 160
C
C       LINK IT IN
        CALL GETPB(J)
        SGRPRNG = I
        PBFLAG = .TRUE.
        J = ITEM
        CALL GETPB(ITEM)
C
C       DONE WITH LOOP
  160   ITEM = NEXTPB
C
C       DETERMINE IF WE GOT ANYTHING THIS TIME
        IF (ID .EQ. 0.0) GO TO 170
        CALL GETPB(J)
        SGRPRNG = IT
        PBFLAG = .TRUE.
        GO TO 140
C
C       ALL DONE...CLEAN UP
  170   CALL PUTPB
        RETURN
        END
    Kf,hž