TITLE	BOOT11 TO BOOTSTRAP/DUMP PDP-11 CONNECTED VIA DL10  %4(34)
SUBTTL	S.POLEVITSKY/PFC/TWE	1-OCT-72

;COPYRIGHT 1972  DIGITAL EQUIPMENT CORP., MAYNARD, MASS., USA

.EDTR==0	;DEC DEVELOPMENT
.MAJV==4;MAJOR VERSION
.MINV==0	;MINOR VERSION
.EDIT==34	;EDIT NUMBER

%%BT11==.EDTR*1B2+.MAJV*1B11+.MINV*1B17+.EDIT

;PROGRAM WHICH BOOTSTRAPS AND DUMPS PDP-11S CONNECTED VIA DL10.
;WHEN RUN, BOOT11 TYPES "FILE: " AND WAITS FOR A FILE SPEC AND
;ONE OR TWO SWITCHES.  /DUMP:M AND /END:N ASK FOR DUMP OF PDP-11
;ACS AND LOC. FROM M-N.
;/LOAD:N AND /START:N SPECIFY BOOTSTRAP FROM FILE AND SET START ADDRESS
;AT N.  IF N IS ODD, OR IF /LOAD, THEN THE 11 WILL HALT BEFORE STARTING.
;/CLEAR:N SPECIFIES TO CLEAR -11 CORE FROM 0 TO N-1.
;IF ALONE, PROGRAM WILL RESTART; IF WITH /L OR /S, WILL THEN LOAD.
;/IMAGE CAUSES LOAD TO READ IMAGE RATHER THAN PACKED FORMAT.
;/PORTNO:P HANDLES PORT NUMBER P (0-3 ARE -11S ON DL-10#0, 4-7 ON #1)

;LOAD INSTRUCTIONS:
;	.LOAD %H BOOT11.MAC, HELPER.REL[10,7]

IFNDEF V.CLR,<V.CLR==100000>	;END OF CLEAR AREA+1
IFNDEF V.DUMP,<V.DUMP==0>	;START OF DUMP
IFNDEF V.END,<V.END==100000>	;END OF DUMP+1
	SUBTTL	REVISION HISTORY

;%2(17)	DELIVERED WITH FIRST DC75 SOFTWARE

;THE FOLLOWING IMPROVEMENTS WERE THEN MADE:
;	HANDLE -11 NXM (BUS TRAP)
;	HANDLE ALL FORMS OF BINARY FORMAT (ABS)
;	HANDLE SFD
;	SUPPRESS 0 LINES FROM DUMP
;	CLEAN UP SOURCE FORMAT
;	RELOCATE THE -11 COMMUNICATIONS AREA TO RELAX THE LOAD
;		TIME REQUIREMENTS
;	PRESERVE THE DL-10 PI-CHANNEL ASSIGNMENT
;	CONVERT MESSAGES TO LOWER CASE
;	CHECK FOR JUNK IN INPUT FORMAT
;	MAKE SIZE OF WINDOW BETWEEN -10 AND -11 BE AUTOMATIC
;	ADD BOOT'S VERSION TO DUMP HEADER LINE
;(26)	ADD /PORTNO:P AND MAKE PORT NUMBER AN OPTION


;DEFICIENCIES:
;	THE AC'S ARE NOT PRESERVED DURING DUMPS. THUS REPEATED DUMPS
;		HAVE JUNK IN THE AC'S.
;	THE AC'S ARE NOT PRESET TO 0 AFTER /LOAD OR /START
;	THERE IS A SLIGHT RACE CONDITION IN THE PRESERVATION OF
;		THE PI-CHANNEL.  THEREFORE THE MONITOR SHOULD
;		ESTABLISH IT AS A CONSTANT AT ONCE TIME AND
;		VERIFY/RESTORE IT OCCASIONALLY (ONCE/SECOND?)
	SUBTTL	DEFINITIONS

	;DEVICE CODES
DLB==60		;FIRST DL-10
DLC==64
DLB2==160	;SECOND DL-10
DLC2==164

	;VARIOUS DL-10 BITS
GETPIC==7				;MASK FOR PI CHANNEL

	;DEFINE THE VARIOUS I/O OP CODES
	DEFINE	MAKE11(ARG),<IRP ARG,<
	DEFINE	ARG'11(USER),<XLIST
	IFB	<USER>,<XCT ARG'.>
	IFNB	<USER>,<MOVE T1,ARG'.
		      IOR  T1,[USER]
		      XCT  T1>
	LIST>	>>

	MAKE11	<GTPI,ENBL,DSAB,CLRA,CLRB,BASE,STRT,STOP,GSTS>

	DEFINE	WAITON	<
	XLIST
	PUSHJ	P,WAITIN
	LIST
	>
	DEFINE	TELLCR	(STRING)<
	XLIST
	PUSHJ	P,[OUTSTR	[ASCIZ	\" STRING
\]
		   RETURN]
	LIST	>

	DEFINE	WARNCR	(STRING)<
	XLIST
	PUSHJ	P,[OUTSTR	[ASCIZ	\% STRING
\]
		   RETURN]
	LIST	>

	DEFINE	ERROR	(STRING)<
	XLIST
	JRST	[OUTSTR	[ASCIZ \? STRING
\]
		JRST	EXITX]
	LIST>

	DEFINE	USEROR	(STRING)<
	XLIST
	JRST	[OUTSTR	[ASCIZ \? STRING
\]
		JRST	STARTE]
	LIST>

	DEFINE	RETURN <
	XLIST
	POPJ	P,
	LIST>
	LOC	137
	%%BT11
	RELOC



;PARAMETERS
	INDEV==1	;INPUT CHANNEL
	IIMODE==10	;IMAGE MODE INPUT FROM INDEV
	INMODE==14	;INPUT FROM INDEV
	OUTDEV==2	;OUTPUT FOR DUMP
	OUMODE==0	;OUTPUT FROM OUTDEV

	PDSIZ==20	;SIZE OF PUSH DOWN LIST

	ONES11==177777	;=ALL ONES AS FAR AS THE 11 CAN SEE


;DEVCHR BIT DEFINITIONS
	DEVPTR==200,,0	;PAPER TAPE READER

;AC'S

	T1=1		;SCRATCHED IN SUBROUTINES
	T2=T1+1
	T3=T2+1
	T4=T3+1
	P1=T4+1		;PRESERVED IN SUBROUTINES
	P2=P1+1
	P3=P2+1
	P4=P3+1

	BC=P4+1		;BYTE COUNT OF DATA IN GROUP
	BA=BC+1		;OUTPUT BYTE ADDRESS
	BYTE=BA+1	;LAST -11 BYTE READ FROM FILE
	FB=BYTE+1	;MOD 4 POSITION IN INPUT WORD
	RB=FB+1		;RELOCATION FOR -11 BUFFER

	P=17		;CALL STACK
	;DESCRIPTION OF OUTPUT FROM MACX11/P GENERATED ASSEMBLY
	;THAT IS, WHAT INPUT SHOULD LOOK LIKE
	;APPROXIMATELY

;-----------------------------------------------------------------------
;[(0-1)/8-BIT BYTE#2/8-BIT BYTE #1,,(18-19)/8-BIT BYTE #4/8-BIT BYTE #3]
;-----------------------------------------------------------------------

;THE ABOVE IS SO-CALLED PACKED MODE.  IN IMAGE MODE, THEY APPEAR
;ONE BYTE PER WORD IN ASCENDING BYTE ORDER.

;	THE BYTES IN -11 ORDERING (IE, AFTER ABOVE UNTANGLING) ARE:
;		ANY NUMBER OF 0 BYTES (DISCARD)
;		CONSTANT 1
;		CONSTANT 0
;		BCL
;		BCU
;		AL
;		AU
;		BC-6 BYTES OF DATA IN ORDER STARTING WITH THE BYTE FOR A
;		C
;			WHERE BC=BCU*400+BCL	THE BYTE COUNT
;			      A =AU *400+AL	THE FIRST BYTE ADDRESS
;			      C =          	THE CHECKSUM
;	THE ABOVE CAN BE REPEATED INDEFINITELY.
;	THE LAST SUCH GROUP HAS BC=6 AND THE STARTING ADDRESS IS A.

;THE CHECKSUM IS A SIMPLE ADD OF THE BYTES STARTING WITH CONSTANT 1 AND
;INCLUDING THE CHECKSUM--THE RESULT IS 0 IN 8 BITS.
	SUBTTL	LOAD PROGRAM

STARTE:	CLRBFI			;CLEAR TTY INPUT IF ERROR
START:	RESET
	SETZM	FWAZER		;CLEAR STORAGE
	MOVE	T1,[FWAZER,,FWAZER+1]
	BLT	T1,LWAZER
	SETOM	FWAONE		;PRESET SWITCH ANSWERS TO -1
	MOVE	T1,[FWAONE,,FWAONE+1]
	BLT	T1,LWAONE
START2:	MOVE	P,[IOWD	PDSIZ,PDLST]

	PUSHJ	P,GETCOM	;GO GET COMMAND

START6:	RESET			;RECLAIM SPACE IF RE-STARTING
	XCT	START2		;SET UP PUSH DOWN LIST
	PUSHJ	P,SETCOD	;SETUP I/O CODES

	SKIPGE	A.DUMP		;SEE IF /DUMP
	SKIPL	A.END		;OR IF /END
	JRST	DODUMP		;GO DO DUMP
	SKIPL	A.LOAD		;SEE IF /START
	SKIPGE	A.DUMP		;AND /LOAD
	JRST	.+2		;NO--OK
	USEROR	Can't do both /LOAD and /START

	SKIPL	A.CLR		;SEE IF /CLEAR
	JRST	[SKIPGE	A.LOAD	;YES--SEE IF /LOAD
		 SKIPL	A.STRT	; OR /START
		 JRST	.+1	;YES--DO BOTH
		 JRST	STRTLD]	;NO--GO START 11
	SKIPN	T2,DEV		;IS DEVICE NULL?
	MOVSI	T2,'DSK'	;YES, DEFAULT IS DSK
	DEVCHR	T2,		;GET INPUT DEVICE CHARACTERISTICS
	TLNE	T2,(DEVPTR)	;IS INPUT DEVICE PTR?
	SETZM	A.IMAG		;YES, THEN /IMAGE IS A DEFAULT SWITCH
	MOVEI	T1,INMODE	;SET INPUT MODE
	SKIPL	A.IMAG		;IS /IMAGE SWITCH SET?
	MOVEI	T1,IIMODE	;YES, THEN IMAGE MODE INPUT
	SKIPN	T2,DEV		;GET DEVICE
	MOVSI	T2,'DSK'	;DEFAULT TO DISK
	MOVEI	T3,INHDR	;POINT TO BUFFER HEADER
	OPEN	INDEV,T1	;OPEN FILE
	  USEROR	Can't OPEN the input device

	SKIPE	T1,NAME		;GET FILE NAME
	JRST	.+3
	MOVE	T1,['PDPXI0']	;DEFAULT
	ADD	T1,A.PORT	;MAKE DEFAULT NAME INCLUDE PORT#
	SKIPN	T2,EXT		;GET EXTENSION
	HRLZI	T2,'BIN'	;DEFAULT
	TRZ	T2,-1		;CLEAR NULL FLAG
RELOOK:	MOVEI	T3,0		;CLEAR WORD
	MOVE	T4,DIRECT	;GET DIRECTORY
	LOOKUP	INDEV,T1	;LOOKUP FILE
	  JRST	[SKIPE	EXT	;CHECK ARGUMENT
		 TLZ	T2,-1	;ALL DONE IF NON-ZERO
		 TLZE	T2,-1	;SEE IF DEFAULT EXT AND NO DOT
		 JUMPE	T2,RELOOK  ;YES--IF NOT FOUND TRY NULL EXT.
		 USEROR	LOOKUP failed
		]

	INBUF	INDEV,0		;SET UP SOME BUFFERS
STRTLD:	PUSHJ	P,STRTUP	;GO START UP -11

	SKIPL	A.CLR		;SEE IF /CLEAR
	JRST	[PUSHJ	P,CLEAR	;YES--GO DO IT
		 SKIPGE	A.LOAD	;SEE IF /LOAD
		 SKIPL	A.STRT	; OR IF /START
		 JRST	.+1	;YES--GO DO IT
		 PUSHJ	P,HALTIT  ;STOP -11 PORT
		 JRST	START]	;NO--GO ASK ABOUT FILE
	TELLCR	PDP-11 loading

	SETOM	FB		;PRESET FILE BYTE POSITION

;BACK HERE FOR EACH GROUP OF DATA
LDGRPL:	PUSHJ	P,GETBYT	;GET BYTE
	  ERROR	EOF at start of file group
	JUMPE	BYTE,LDGRPL	;LOOP THROUGH NULLS
	CAIN	BYTE,377	;DISCARD DELETES
	JRST	LDGRPL		; ..
	CAIE	BYTE,1		;VERIFY CONSTANT 1
	ERROR	File group has junk instead of constant 1
	MOVEM	BYTE,CHKSUM	;INITIALIZE CHECKSUM
	PUSHJ	P,GETBYT	;GET BYTE
	  ERROR	EOF after file constant 1
	SKIPE	BYTE		;VERIFY CONSTANT 0
	ERROR	file group has junk instead of constant 0
	PUSHJ	P,GETWRD	;GET WORD
	SKIPGE	A.IMAG		;SEE IF IMAGE MODE
	SKIPE	T1		;NO--SEE IF 0
	JRST	LDGRP2		;OK
	WARNCR	File zero byte count--trying again in /IMAGE mode
	PUSHJ	P,HALTIT	;STOP -11
	SETZM	A.IMAG		;SET /IMAGE SWITCH
	JRST	START6		;START AGAIN BUT NO COMMAND SCANNING

LDGRP2:	MOVEI	BC,-6(T1)	;GET DATA BYTE COUNT
	SKIPGE	BC		;SEE IF ACCEPTABLE
	ERROR	File group byte count less than 6
	PUSHJ	P,GETWRD	;GET WORD
	MOVEM	T1,ADDRES	;SAVE AS STARTING ADDRESS
	JUMPE	BC,THATAL	;JUMP IF THIS IS THE START BLOCK
;LOOP GETTING DATA AND TRANSFERRING IT TO THE -11

LDDATL:	MOVEI	P1,20		;DO 20 BYTES (10 WORDS)
	CAIGE	BC,20		;MAKE SURE FILE HAS THAT MANY
	MOVE	P1,BC		;NO--USE WHAT IS IN FILE
	MOVE	P2,P1		;SET COUNT FOR FETCH

	MOVE	T1,ADDRES	;GET STARTING ADDRESS
	MOVEM	T1,BLOADR(RB)	;TELL -11 PROGRAM
	MOVEM	P1,BLOCNT(RB)	;TELL -11 NUMBER OF BYTES
	MOVE	BA,[POINT 8,BLODAT(RB),35]	;POINT TO DATA AREA
	PUSHJ	P,CLRTRA	;CLEAR TRANSFER AREA

;LOOP FILLING BUFFER FOR ONE TRANSFER TO THE -11
LDDATM:	PUSHJ	P,GETBYT	;GET BYTE
	  ERROR	EOF during data in file group
	DPB	BYTE,BA		;STUFF INTO BUFFER
	TLCE	BA,(POINT 0,0,27)	;SWITCH BYTES
	AOS	BA		;ADVANCE WORD EVERY TWO
	SOJG	P2,LDDATM	;LOOP FILLING BUFFER

	MOVE	T1,ADDRES	;GET STARTING ADDRESS
	CAIL	T1,10		;SEE IF BELOW 4/6 AREA
	JRST	LDDOIT		;NO--OK TO PROCEED
	ADDI	T1,-4(P1)	;SEE IF END IS BELOW 4/6 AREA
	JUMPL	T1,LDDOIT	;JUMP IF YES

;HERE WHEN LOAD OVERLAPS 4/6 AREA--MUST PROTECT AND SAVE THIS
;AND CLEAN UP 4 AND 6 AT THE END
	MOVN	T1,T1		;COMPLEMENT OVERLAP
	ADDB	T1,BLOCNT(RB)	;COMPUTE OK LENGTH BELOW 4
	JUMPLE	T1,SAVE46	;NONE--GO SAVE 4/6
	WAITON			;YES--TRANSFER THAT MUCHSAVE46:	MOVE	BA,[POINT 8,BLODAT(RB),35]
	MOVE	T1,ADDRES	;GET ADDRESS OF FIRST BYTE IN AREA
	HRRZI	T2,(P1)		;GET COUNT OF BUFFER
SAVELP:	LDB	T3,BA		;GET THIS BYTE
	CAIN	T1,4		;SEE IF 4
	DPB	T3,[POINT 8,CORE.4,35]
	CAIN	T1,5		;SEE IF 5
	DPB	T3,[POINT 8,CORE.4,27]
	CAIN	T1,6		;SEE IF 6
	DPB	T3,[POINT 8,CORE.6,35]
	CAIN	T1,7		;SEE IF 7
	DPB	T3,[POINT 8,CORE.6,27]
	TLCE	BA,(POINT 0,0,27)	;SWITCH BYTES
	AOS	BA		;ADVANCE WORD EVERY TWO
	AOS	T1		;ADVANCE ADDRESS
	SOJG	T2,SAVELP	;LOOP UNTIL DONE
			;NOTE THAT 7 CAN BE CLOBERRED BY 0
			;SINCE LOAD LOOP HAS 0 THERE
	MOVEI	T1,10		;FIRST GOOD ADDRESS IS 10
	SUB	T1,ADDRES	;LENGTH OF PROBLEM
	LSH	T1,-1		;DITTO IN -10 WORDS
	MOVEI	T2,(P1)		;GET OLD BYTE COUNT
	SUB	T2,T1		;DECREASE
	SUB	T2,T1		; TO NEW VALUE
	JUMPLE	T2,LDIDIT	;JUMP IF NONE ABOVE 7
	MOVEM	T2,BLOCNT(RB)	;TELL -11 HOW FAR TO GO
	JUMPE	T1,LDNOBL	;IF STARTED AT 7, THEN NO BLT
	MOVEI	T2,BLODAT(RB)	;GET TARGET OF BLT
	ADD	T2,T1		;GET START
	MOVSS	T2		;SETUP BLT
	HRRI	T2,BLODAT(RB)	;SET TARGET
	BLT	T2,BLODAT+6(RB)	;TRANSFER DATA
LDNOBL:	MOVE	T2,ADDRES	;GET ORIGINAL ADDRESS
	ADD	T2,T1		;ADVANCE TO
	ADD	T2,T1		;  NEW ONE
	MOVEM	T2,BLOADR(RB)	;TELL -11
	MOVEI	T3,0		;GET A ZERO
	CAIN	T2,7		;IF STARTS AT 7,
	DPB	T3,[POINT 8,BLODAT(RB),27]  ; CLEAR OUT 7

LDDOIT:	WAITON			;HAVE -11 TRANSFER IT
	SKIPE	NXMADR(RB)	;SEE IF NXM IN -11
	ERROR	NXM in -11 memory

LDIDIT:	MOVEI	T1,20		;ADVANCE ADDRESS
	ADDM	T1,ADDRES	; ..
	SUBI	BC,20		;DECREMENT COUNT TO GO
	JUMPG	BC,LDDATL	;LOOP UNTIL DONE

	PUSHJ	P,GETCHK	;VERIFY CHECKSUM
	JRST	LDGRPL		;GO LOOK FOR NEXT GROUP
THATAL:	PUSHJ	P,GETCHK	;VERIFY CHECKSUM
	MOVEI	T1,^D10		;TAPE SHOULD HAVE AT LEAST 10 TRAILING NULLS
SKPEND:	SOJL	T1,LDDONE	;IF 10 NULLS THERE, TAPE END IS OK
	PUSHJ	P,GETBYT	;GET NEXT BYTE
	  JRST	LDDONE		;EOF IS OK
	JUMPE	BYTE,SKPEND	;SKIP TRAILING NULLS
	ERROR	Junk after start group

LDDONE:	MOVE	T1,CORE.4	;GET NEW CONTENTS OF 4
	MOVEM	T1,BLODAT(RB)	;GIVE TO -11
	MOVE	T1,CORE.6	;GET NEW CONTENTS OF 6
	MOVEM	T1,BLODAT+1(RB)	;GIVE TO -11
	MOVEI	T1,4		;GET CONSTANT
	MOVEM	T1,BLOADR(RB)	;SET START ADDRESS
	MOVEM	T1,BLOCNT(RB)	;SET DISTANCE
	WAITON

	SKIPGE	T2,A.STRT	;SEE IF /START
	MOVE	T2,A.LOAD	;NO--TRY /LOAD
	SKIPG	T2		;UNLESS NON-ZERO ARG
	MOVE	T2,ADDRES	; USE FILE ADDRESS
	GSTS11	T1		;GET MEMORY STATUS
	TDNE	T1,OK...	;SEE IF OK
	TRO	T2,1		;NO--SET TO HALT
	MOVEI	T1,137		;SET JUMP @(PC)+
	TRZN	T2,1		;MAKE IT EVEN
	SKIPL	A.LOAD		;SEE IF /LOAD
	MOVEI	T1,0		;OR IF WAS ODD, FORCE HALT
	MOVEM	T2,BLOADR(RB)	;STORE START ADDRESS
	MOVE	P1,T1		;SAVE FLAG
	PUSHJ	P,STOPIT	;GO STOP OR STARTUP -11 PROGRAM
	SKIPN	P1		;SEE IF HALT
	TELLCR	PDP-11 loaded
	SKIPE	P1		;OR IF JMP
	TELLCR	PDP-11 started
	CLOSE	INDEV,		;CLOSE INPUT FILE
	RELEAS	INDEV,		;RELEASE IT
	JRST	GOHOME		;GO BACK TO MONITOR
	SUBTTL	LOADER SUBROUTINES

;ROUTINE TO GET AND VERIFY CHECKSUM

GETCHK:	PUSHJ	P,GETBYT	;GET CHECKSUM
	  ERROR	EOF found when looking for checksum
	MOVE	T1,CHKSUM	;GET RESULT
	TRNN	T1,377		;SEE IF OK
	RETURN			;YES
	ERROR	Checksum failure

;ROUTINE TO GET ONE -11 WORD INTO T1

GETWRD:	PUSHJ	P,GETBYT	;GET RH BYTE
	  ERROR	EOF during first byte of a word
	PUSH	P,BYTE		;SAVE AWAY
	PUSHJ	P,GETBYT	;GET LH BYTE
	  ERROR	EOF during second byte of a word
	MOVE	T1,BYTE		;MOVE TO ANSWER
	LSH	T1,8		;POSITION LH BYTE
	IOR	T1,(P)		;INCLUDE RH BYTE
	POP	P,(P)		;DISCARD SAVED BYTE
	RETURN
;ROUTINE TO GET ONE -11 BYTE FROM FILE INTO BYTE

GETBYT:	SKIPL	A.IMAG		;SEE IF /IMAGE MODE
	JRST	GETBYW		;YES--GET NEXT WORD
	AOS	FB		;ADVANCE FILE BYTE
	ANDI	FB,3		; (MOD 4)
	JUMPN	FB,GETBYC	;IF NOT NEW WORD, JUST FETCH BYTE
GETBYW:	SOSL	INHDR+2		;COUNT DOWN WORDS
	JRST	GETBYA		;STILL SOME THERE SO PROCEED
	IN	INDEV,		;NO--GET NEXT BUFFER
	  JRST	GETBYW		;OK--GO TRY AGAIN
	STATZ	INDEV,740000	;SEE IF ERROR
	  ERROR	Input file read error
	RETURN

GETBYA:	AOS	INHDR+1		;ADVANCE TO NEXT WORD
	MOVE	BYTE,@INHDR+1	;GET WORD
	SKIPL	A.IMAG		;SEE IF /IMAGE
	JRST	GETBYI		;YES--GO GET IMAGE WORD
	TLNN	BYTE,(6B2)	;NO--TEST FOR NO JUNK
	TRNE	BYTE,6B20	; IN EITHER HALF
	ERROR	Junk bits in input file
GETBYC:	LDB	BYTE,PTRTAB(FB)	;GET BYTE
	JRST	GETBYR		;GO RETURN DATA
GETBYI:	TDNE	BYTE,[-1-377]	;SEE IF ANY JUNK
	ERROR	Junk in input file--may not be /IMAGE mode
GETBYR:	ADDM	BYTE,CHKSUM	;ACCUMULATE IN CHECKSUM
	AOS	(P)		;SKIP RETURN
RETRET:	RETURN

PTRTAB:	POINT	8,@INHDR+1,17
	POINT	8,@INHDR+1,9
	POINT	8,@INHDR+1,35
	POINT	8,@INHDR+1,27
	SUBTTL	DUMP ROUTINE

DODUMP:	SKIPGE	A.LOAD		;SEE IF /LOAD
	SKIPL	A.STRT		;OR IF /START
	USEROR	Can't /LOAD and /DUMP at the same time
	SKIPL	A.CLR		;SEE IF /CLEAR
	USEROR	Can't /CLEAR and /DUMP at the same time

	MOVEI	T1,OUMODE	;SET OUTPUT MODE
	SKIPN	T2,DEV		;GET DEVICE
	MOVSI	T2,'DSK'	;DEFAULT TO DISK
	MOVSI	T3,OUTHDR	;POINT TO BUFFER HEADER
	OPEN	OUTDEV,T1	;OPEN FILE
	  USEROR	Can't OPEN the output device

	SKIPE	T1,NAME		;GET FILE NAME
	JRST	.+3
	MOVE	T1,['PDPXI0']	;DEFAULT
	ADD	T1,A.PORT	;MAKE DEFAULT NAME INCLUDE PORT#
	SKIPN	T2,EXT		;GET EXTENSION
	HRLZI	T2,'LSD'	;DEFAULT
	TRZ	T2,-1		;CLEAR NULL FLAG
	MOVEI	T3,0		;CLEAR PROTECTION, ETC.
	MOVE	T4,DIRECT	;GET DIRECTORY
	ENTER	OUTDEV,T1	;ENTER FILE
	  USEROR	ENTER failed
	OUTBUF	OUTDEV,0	;SET DEFAULT BUFFERS
;ACCUMULATE HEADING DATA

STRTDM:	MOVE	T1,[POINT 7,HEADER]
	MOVEM	T1,HEDPNT		;INIT POINTER FOR HEADER MSG
	PUSHJ	P,HEDTXT
	 ASCIZ /PDP-11 #/
	MOVE	T1,A.PORT		;GET PORT NUMBER
	PUSHJ	P,HEDDIG		; AND PRINT
	PUSHJ	P,HEDTXT
	 ASCIZ / dump by BOOT11 /
	LDB	T1,[POINT 9,.JBVER##,11]
	PUSHJ	P,HEDOCT		;PRINT VERSION  NUMBER
	LDB	T1,[POINT 6,.JBVER,17]	;GET MINOR VERSION #
	JUMPE	T1,DMHDV1		;JUMP IF NONE
	SUBI	T1,1			;FAKE OUT DIVIDE
	IDIVI	T1,^D26			;GET LAST LETTER
	JUMPE	T1,DMHDV0		;JUMP IF ONLY 1 LETTER
	ADDI	T1,"A"-1		;CONVERT 1ST LETTER
	PUSHJ	P,HEDCHR
DMHDV0:	MOVEI	T1,"A"(T2)
	PUSHJ	P,HEDCHR		;OUTPUT LAST LETTER

DMHDV1:	HRRZ	T1,.JBVER		;GET EDIT NUMBER
	JUMPE	T1,DMHDV2		;JUMP IF ZERO
	MOVEI	T1,"("
	PUSHJ	P,HEDCHR
	HRRZ	T1,.JBVER
	PUSHJ	P,HEDOCT
	MOVEI	T1,")"
	PUSHJ	P,HEDCHR		;FINISH "(EDIT NUMBER)"

DMHDV2:	LDB	T1,[POINT 3,.JBVER,2]	;GET "WHO MADE EDIT"
	JUMPE	T1,DMHDV3		;JUMP IF DIGITAL DID
	MOVEI	T1,"-"
	PUSHJ	P,HEDCHR
	XCT	DMHDV2			;GET "WHO" BACK
	PUSHJ	P,HEDDIG		; AND PRINT

DMHDV3:	MOVEI	T1,11			;HORIZONTAL TAB
	PUSHJ	P,HEDCHR
	MSTIME	T1,		;GET TIME OF DAY (MILLESECONDS)
	IDIVI	T1,^D60000	;GET MINUTES
	IDIVI	T1,^D60		;GET HOURS
	PUSH	P,T2		;SAVE REMAINDER AS MINUTES
	PUSHJ	P,HEDDEC	;PRINT QUOTIENT AS HOURS
	MOVEI	T1,":"
	PUSHJ	P,HEDCHR	;PRINT COLON
	POP	P,T1		;GET MINUTES BACK
	PUSHJ	P,HEDDEC	; AND PRINT
	MOVEI	T1,11
	PUSHJ	P,HEDCHR	;PRINT TAB

	DATE	T1,
	IDIVI	T1,^D31*^D12	;YEAR GOES TO T1
	ADDI	T1,^D64		;ADD IN BASE YEAR
	IDIVI	T2,^D31		;T2 GETS MONTH, T3 GETS DAY
	PUSH	P,T1		;SAVE YEAR
	PUSH	P,[ASCII /JAN/
		ASCII /FEB/
		ASCII /MARCH/
		ASCII /APRIL/
		ASCII /MAY/
		ASCII /JUNE/
		ASCII /JULY/
		ASCII /AUG/
		ASCII /SEPT/
		ASCII /OCT/
		ASCII /NOV/
		ASCII /DEC/](T2)
	MOVEI	T1,1(T3)	;GET DAY
	PUSHJ	P,HEDDEC	; AND PRINT
	MOVEI	T1,"-"
	PUSHJ	P,HEDCHR
	POP	P,T1		;GET MONTH
	PUSHJ P,HED7	; AND PRINT
	MOVEI	T1,"-"
	PUSHJ	P,HEDCHR
	POP	P,T1
	PUSHJ	P,HEDDEC	;PRINT YEAR
	MOVE	T1,[20,,11]	;GET SYSTEM
	GETTAB	T1,		; SERIAL NUMBER
	  MOVEI	T1,0		;UNKNOWN
	SKIPLE	T1		;SEE IF OK
	CAILE	T1,^D999
	JRST	DMHDV5		;SYSTEM NUMBER BAD
	PUSH	P,T1		;SAVE NUMBER
	PUSHJ	P,HEDTXT
	 ASCIZ /	System /
	POP	P,T1
	PUSHJ	P,HEDDEC	;PRINT SYSTEM NUMBER

DMHDV5:	MOVSI	T1,(ASCII /  /)
	PUSHJ	P,HED7		;PRINT SPACES

	MOVSI	T4,-5		;SET HEADER COUNT
DMHDV6:	MOVEI	T1,11	;POINT TO TABLE
	HRL	T1,T4		;POINT TO ENTRY
	GETTAB	T1,		;GET SYSTEM HEADER LINE
	 MOVEI	T1,0		;UNKNOWN
	PUSHJ	P,HED7		;PRINT TEXT
	AOBJN	T4,DMHDV6	;LOOP UNTIL DONE

	MOVEI	T1,0
	PUSHJ	P,HEDCHR	;STUFF NULL IN AT END OF HEADER
	PUSHJ	P,LHEAD		;GO LIST HEADER
	PUSHJ	P,STRTUP	;GO START UP -11
	TELLCR	PDP-11 dumping

;DUMP AC'S 4 PER LINE
	MOVSI	P3,-7		;DUMP SEVEN AC'S
DMLPAC:	PUSHJ	P,LTAB		;SPACE OVER
	MOVEI	T1,"R"		;LABEL AS
	PUSHJ	P,LCHAR		; REGISTER
	MOVEI	T1,"0"(P3)	;NUMBER REGISTER
	PUSHJ	P,LCHAR		; IN LISTING
	MOVEI	T1,[ASCIZ /:  /]
	PUSHJ	P,LSTRG		;LIST PREFIX
	MOVEI	T1,BLODAT(RB)	;GET START OF TRANSFER AREA
	ADDI	T1,(P3)		;ADD AC NUMBER
	MOVE	T1,(T1)		;GET AC CONTENTS
	PUSHJ	P,L6OCT		;LIST IT
	MOVEI	T1,-3(P3)	;SEE IF DONE WITH FIRST 4
	JUMPN	T1,.+2		;NO--PROCEED
	PUSHJ	P,LCRLF2	;YES--NEW LINE
	AOBJN	P3,DMLPAC	;LOOP FOR ALL AC'S WHICH WORK

	PUSHJ	P,LCRLF2	;BLANK LINES
	PUSHJ	P,LCRLF2	;AND MORE

	MOVE	T1,BLOCNT(RB)	;GET CORE 4
	MOVEM	T1,CORE.4	;SAVE FOR LATER
	MOVE	T1,BLOADR(RB)	;GET CORE 6
	MOVEM	T1,CORE.6	;SAVE FOR LATER
;DUMP CORE 10-WORDS PER LINE
	SKIPGE	P1,A.DUMP	;GET STARTING ADDRESS
	MOVEI	P1,V.DUMP	;DEFAULT
	TRZ	P1,17		;ROUND DOWN TO EVEN 10-WORDS
	SKIPGE	P2,A.END	;GET ENDING ADDRESS
	MOVEI	P2,V.END	;DEFAULT
	SUBI	P2,1		;STOP BEFORE GETTING THERE
	TRO	P2,17		; BUT ROUND UP THE EVEN 10-WORDS

	MOVEI	P4,0		;SET INITIAL LINE POSITION

;BACK HERE FOR LOOP BY 10-WORD HUNKS
DMLOOP:	CAML	P1,P2		;SEE IF DONE YET
	JRSTNE		;YES--GO BIND OFF OUTPUT
	SKIPN	LASZER		;SKIP LINE COUNT IF 0 LINES
	AOS	P4		;ADVANCE LINE
	CAIG	P4,^D22		;SEE IF DONE WITH THIS PAGE
	JRST	DMNOHD		;NO NEED FOR HEADER
	MOVEI	T1,14		;ISSUE FORM FEED
	PUSHJ	P,LCHAR		; TO LISTING
	PUSHJ	P,LHEAD		;ISSUE HEADER
	MOVEI	P4,0		;CLEAR LINE COUNT
DMNOHD:	MOVNI	T1,20		;TRANSFER 20 BYTES (10 WORDS)
	MOVEM	T1,BLOCNT(RB)	;FROM THE -11 CORE
	MOVEM	P1,BLOADR(RB)	;STARTING AT START ADDRESS
	PUSHJ	P,CLRTRA	;CLEAR TRANSFER AREA
	WAITON			;WAIT FOR -11 TO READ ITS CORE
	SKIPE	NXMADR(RB)	;SEE IF END OF CORE
	JRST	DMNXM		;YES--GO HANDLE IT
	JUMPN	P1,DMSEEZ	;SEE IF FIRST GROUP
	MOVE	T1,CORE.4	;YES--GET REAL 4/5
	MOVEM	T1,BLODAT+2(RB)	;SET WHERE -11 WOULD HAVE
	MOVE	T1,CORE.6	;GET REAL 6/7
	MOVEM	T1,BLODAT+3(RB)	;SET WHERE -11 WOULD HAVE

DMSEEZ:	MOVSI	P3,-10		;SEE IF ALL 0
	HRR	P3,RB		;RELOCATE
	SKIPN	BLODAT(P3)	;CHECK DATA
	AOBJN	P3,.-1		;LOOP FOR AREA
	JUMPGE	P3,DMZERO	;JUMP IF ALL ZERO
	PUSHJ	P,DMZRLN	;NO--CLEAN OFF PREVIOUS ONE
	SETZM	LASZER		;CLEAR ZERO'S BEING SKIPPED
	MOVEI	T1,20(P1)	;GET START OF NEXT LINE
	MOVEM	T1,FIRZER	;SET AS FIRST POSSIBLE ZERO

	MOVE	T1,P1		;GET STARTING ADDRESS
	PUSHJ	P,L6OCT		;LIST IT
	MOVEI	T1,":"		;FLAG AS ADDRESS
	PUSHJ	P,LCHAR		;IN LISTING

	MOVSI	P3,-10		;SET FOR 10-WORDS
DMLP1:	PUSHJ	P,LTAB		;SPACE OVER
	MOVEI	T1,BLODAT(RB)	;GET LOCATION OF TRANSFER AREA
	ADDI	T1,(P3)		;POINT TO CORRECT WORD
	MOVE	T1,(T1)		;GET WORD
	PUSHJ	P,L6OCT		;LIST IT
	MOVEI	T1,-3(P3)	;SEE IF DONE WITH 4 WORDS YET
	JUMPN	T1,.+2		;NO--PROCEED
	PUSHJ	P,LTAB		;YES--ONE EXTRA TAB
	AOBJN	P3,DMLP1	;LOOP FOR THIS LINE
	PUSHJ	P,LCRLF2	;END 2 LINES
	JRST	DMGOLP		;GO AROUND LOOP

DMZERO:	MOVEI	T1,16(P1)	;SET POSSIBLE END OF ZERO BLOCK
	MOVEM	T1,LASZER	;FOR DUMP
DMGOLP:	ADDI	P1,20		;ADVANCE 20 BYTES (10 WORDS)
	JRST	DMLOOP		;LOOP UNTIL DONE
;HERE WHEN NXM IN -11 MEMORY
DMNXM:	PUSHJ	P,DMZRLN	;ISSUE FINAL ZERO LINE
	SETZM	LASZER		;CLEAR FINAL ZERO
	MOVEI	T1,[ASCIZ /			NXM at /]
	PUSHJ	P,LSTRG		;LIST HEADER
	SOS	T1,NXMADR(RB)	;GET BAD ADDRESS
	PUSHJ	P,L6OCT		;LIST IT
	PUSHJ	P,LCRLF2	;END LINE
DMDONE:	PUSHJ	P,DMZRLN	;CLEAR OUT FINAL ZEROS
	PUSHJ	P,HALTIT	;STOP -11
	TELLCR	PDP-11 dumped

	CLOSE	OUTDEV,		;CLOSE FILE
	RELEAS	OUTDEV,		;RELEASE IT
	JRST	GOHOME		;AND FINISH WORK
	SUBTTL	DUMP SUBROUTINES

;LIST ZERO LINE IF ANY
DMZRLN:	SKIPN	LASZER		;SEE IF ANYTHING
	RETURN			;NO--GIVE UP
	PUSHJ	P,LTAB		;YES--SPACE OVER
	PUSHJ	P,LTAB
	MOVE	T1,LASZER	;GET END
	SUB	T1,FIRZER	;GET LENGTH-2
	ADDI	T1,2		;GET LENGTH IN BYTES
	LSH	T1,-1		;CONVERT TO WORDS
	PUSHJ	P,L6OCT		;LIST THAT
	MOVEI	T1,[ASCIZ / words from /]
	PUSHJ	P,LSTRG		;LIST TITLE
	MOVE	T1,FIRZER	;GET START
	PUSHJ	P,L6OCT		;LIST
	MOVEI	T1,[ASCIZ / to /]
	PUSHJ	P,LSTRG		;LIST TITLE
	MOVE	T1,LASZER	;GET END POINT
	PUSHJ	P,L6OCT		;LIST
	MOVEI	T1,[ASCIZ / are all zero

/]
	JRST	LSTRG		;LIST AND RETURN
;LIST 6 DIGITS IN OCTAL
L6OCT:	LSHC	T1,-^D18	;POSITION NUMBER
	MOVEI	T3,6		;SET DIGIT COUNTER
L6OCTL:	MOVEI	T1,0		;CLEAR ACCUMULATOR
	LSHC	T1,3		;GET DIGIT
	ADDI	T1,"0"		;CONVERT TO ASCII
	PUSHJ	P,LCHAR		;LIST IT
	SOJG	T3,L6OCTL	;LOOP UNTIL DONE
	RETURN

;LIST HEADING
LHEAD:	MOVEI	T1,HEADER	;GET HEADER
	PUSHJ	P,LSTRG		;LIST IT
				;FALL INTO LCRLF2

;LIST END OF LINE AND A BLANK LINE
LCRLF2:	MOVEI	T1,[ASCIZ /

/]
				;FALL INTO LSTRG

;LIST ASCIZ STRING
LSTRG:	MOVE	T2,T1		;GET POINTER
	HRLI	T2,(POINT 7)	;SET ASCII POINTER
LSTRGL:	ILDB	T1,T2		;GET CHARACTER
	JUMPE	T1,RETRET	;RETURN IF DONE
	PUSHJ	P,LCHAR		;ELSE LIST IT
	JRST	LSTRGL		;LOOP UNTIL DONE

;LIST TAB
LTAB:	MOVEI	T1,11		;GET TAB
				;FALL INTO LCHAR

;LIST CHARACTER
LCHAR:	SOSG	OUTHDR+2	;COUNT CHARACTER IN BUFFER
	JRST	LCHARB		;NO ROOM--GO MAKE SOME
LCHARL:	IDPB	T1,OUTHDR+1	;OK--STORE CHARACTER
	RETURN

LCHARB:	OUT	OUTDEV,		;OUTPUT DATA BUFFER
	  JRST	LCHARL		;AND NOW GO DO CHARACTER
	ERROR	Output device error
	SUBTTL	-11 HANDLER SUBROUTINES

;ROUTINE TO COMPUTE I/O CODES AS FUNCTION OF /PORTNO:P
SETCOD:	MOVE	P2,A.PORT	;GET /PORTNO
	CAILE	P2,7		;KEEP IN RANGE
	USEROR	Port number must be 0-7
	IDIVI	P2,4		;SPLIT INTO -11 AND DL NUMBERS
	MOVE	P1,[CONO DLB,
		    CONO DLB2,](P2)
	MOVE	P2,[CONI DLC,
		    CONI DLC2,](P2)
	MOVE	P4,P3		;GET PORT
	IMULI	P4,3		;  *3

			;IN THIS ROUTINE:
			;	P1=I/O INSTR  ON DLB
			;	P2=I/O INSTR  ON DLC
			;	P3=-11 NUMBER
			;	P4=3*-11 NUMBER (FOR LSH)

	MOVEM	P2,GTPI.	;GET PI ASSIGNMENT

	SUB	P2,[<CONI>-<CONO>]	;SWITCH TO CONO

	MOVEI	T1,1B31		;ENABLE
	LSH	T1,(P4)		;SELECT -11
	IOR	T1,P2		;DLC
	MOVEM	T1,DSAB.	;DISABLE -11
	TRO	T1,1B20		;TURN ON
	MOVEM	T1,ENBL.	;ENABLE -11

	MOVEI	T1,7B32		;INTERRUPTS AND ENABLE
	LSH	T1,(P4)		;SELECT -11
	IOR	T1,P2		;DLC
	MOVEM	T1,CLRA.	;CLEAR CONO

	MOVEI	T1,<WINDOW/1K>B33(P3)  ;WINDOW SIZE AND WHICH -11
	IOR	T1,P1		;DLB
	MOVEM	T1,BASE.	;SET BASE ADDRESS
	SUB	P2,[<CONO>-<DATAO>]	;SWITCH TO DATAO

	MOVEI	T1,CLRB..	;POINT TO DATUM
	IOR	T1,P2		;DLC
	MOVEM	T1,CLRB.	;CLEAR DATAO
	MOVEI	T1,STRT..	;POINT TO DATUM
	IOR	T1,P2		;DLC
	MOVEM	T1,STRT.	;START -11
	MOVEI	T1,STOP..	;POINT TO DATUM
	IOR	T1,P2		;DLC
	MOVEM	T1,STOP.	;STOP -11

	MOVSI	T1,(7B14)	;CLEAR ERRORS
	LSH	T1,(P4)		;SELECT -11
	MOVEM	T1,OK...	;SAVE FOR TESTS
	TLO	T1,(1B0)	;ACTIVATE THE CLEAR
	MOVEM	T1,CLRB..	;SAVE DATUM
	MOVEI	T1,1B31		;START BIT
	LSH	T1,(P4)		;SELECT -11
	MOVEM	T1,RN...	;SAVE FOR TESTS
	MOVEM	T1,STRT..	;SAVE DATUM
	LSH	T1,1		;STOP BIT (SELECTED)
	MOVEM	T1,STOP..	;SAVE DATUM

	SUB	P2,[<DATAO>-<DATAI>]	;SWITCH TO DATAI
	MOVEM	P2,GSTS.	;SAVE AS GET STATUS

	MOVEI	T1,5B32		;EXIST AND POWER BITS
	LSH	T1,(P4)		;SELECT CORRECT -11
	MOVEM	T1,UP...	;SAVE FOR TESTS

	RETURN
;ROUTINE TO START -11
STRTUP:	HRRZ	RB,.JBFF##	;GET FREE CORE FOR -11 BUFFER
	ADDI	RB,WINDOW	;ROUND UP TO
	TRZ	RB,WINDOW	; MULT OF 512 IN CASE 8K OPTION IN -11
	MOVEI	T1,WINDOW(RB)	;GET END OF SMALLEST 8K AREA
	MOVEI	T4,1(T1)	;GET NEW .JBFF
	HRRM	T4,.JBFF	;STORE AWAY
	CORE	T1,		;GET SPACE FROM MONITOR
	  ERROR	Insufficient core
	HRLZ	T1,RB		;CLEAR AREA
	HRRI	T1,1(RB)	; TO PROTECT
	SETZM	(RB)		; AGAINST SICK
	BLT	T1,777(RB)	; -11. (0 IS IMMEDIATE)
	MOVSI	T1,BASEAD	;COPY CLEAN
	HRR	T1,RB		; -11 CODE
	BLT	T1,LEN11-1(RB)	; TO AREA

	MOVEI	T1,CCINT	;SET FOR
	HRRM	T1,.JBINT##	;  ^C TRAP
	SETZB	T4,CCINTP	;KEEP TIMESHARING ON
	TRPSET	T4,		; BUT GIVE SELF IOT
	  ERROR	TRPSET failed

	MOVEI	T4,1		;NOW LOCK THAT LOW SEGMENT
	LOCK	T4,
	  ERROR	LOCK failed

	LSH	T4,9
	MOVEI	T4,(T4)		;GET 9 BITS OF ADDRESS
	ADDI	T4,(RB)		;INCLUDE OFFSET IN THIS PROGRAM

	STOP11			;STOP THE PDP-11
	MOVEI	T3,^D100000	;SET DEFENSIVE LOOP
STPLP:	GSTS11	T2		;GET -11 STATUS
	TDNE	T2,RN...	;SEE IF STOPPED YET
	SOJGE	T3,STPLP	;NO--TRY AGAIN
	JUMPGE	T3,.+2		;SEE IF OK
	ERROR	PDP-11 won't stop
	GTPI11	T3		;GET PI-CHANNEL
	ANDI	T3,GETPIC	;MASK TO IT ALONE
	CLRA11	((T3))		;CLEAR CONO
	CLRB11			;CLEAR DATAO
	BASE11	((T4))		;SET BASE ADDRESS (INC. LOCKED LOCTN)
	GSTS11	T1		;GET DEVICE STATUS
	TDC	T1,UP...	;TEST FOR EXIST
	TDCE	T1,UP...	;  AND RUN
	ERROR	PDP-11 absent or power off
	GTPI11			;GET PI-CHANNEL
	ANDI	T3,GETPIC	;MASK TO IT ALONE
	ENBL11	((T3))		;ENABLE -11 PORT
	STRT11			;START -11

	MOVEI	T1,^D100000	;SET LOOP COUNT FOR PROTECTION
	SKIPE	WATFLG(RB)	;IF THE PDP-11 HAS WOKEN UP,
				;IT WILL HAVE RESET THIS SWITCH
				;OTHERWISE, WAIT FOR IT .... PRIMARILY
	SOJGE	T1,.-1		;LOOP UNTIL OK OR DEAD
	JUMPGE	T1,.+2		;OK
	ERROR	PDP-11 won't start--check HALT switch
	RETURN
;ROUTINE TO CLEAR 11 UP TO C(A.CLR)-1
CLEAR:	TELLCR	Clearing PDP-11
	PUSHJ	P,CLRTRA	;CLEAR TRANSFER AREA
	MOVEI	P1,20		;INITIALIZE STORE COUNTER
CLEARL:	CAML	P1,A.CLR	;SEE IF DONE YET
	JRST	CLEARD		;DONE--GO CLEAN UP
	MOVEM	P1,BLOADR(RB)	;TELL -11 WHAT TO CLEAR
	MOVE	T1,A.CLR	;GET END OF CLEAR
	SUB	T1,P1		;COMPUTE DISTANCE TO GO
	CAIL	T1,20		;SEE IF MORE THAN 10 WORDS
	MOVEI	T1,20		;YES--JUST DO 10
	ADD	P1,T1		;ADVANCE DISTANCE DONE
	MOVEM	T1,BLOCNT(RB)	;TELL -11 HOW MUCH
	WAITON			;WAIT TO COMPLETE
	SKIPN	NXMADR(RB)	;SEE IF OUT OF CORE YET
	JRST	CLEARL		;LOOP FOR NEXT ONE

CLEARD:	SETZM	BLOADR(RB)	;AT END GO DO 0-17
	MOVE	T1,A.CLR	;GET END POINT
	CAIL	T1,20		;SEE IF GT 17
	MOVEI	T1,20		;YES--SET TO 17
	MOVEM	T1,BLOCNT(RB)	;TELL -11
	WAITON			;DO IT
	RETURN

;CLEAR DATA AREA IN TRANSFER BLOCK
CLRTRA:	SETZM	BLODAT(RB)	;CLEAR FIRST WORD
	MOVSI	T1,BLODAT(RB)	;POINT TO IT
	HRRI	T1,BLODAT+1(RB)	; AND NEXT ONE
	BLT	T1,BLODAT+7(RB)	;GO TO END
	RETURN

;WAIT HERE FOR 11 TO ANSWER THAT IT HAS COMPLETED
WAITIN:	MOVEI	T1,ONES11
	MOVEM	T1,WATFLG(RB)
	MOVEI	T1,^D100000	;PROTECT AGAINST DEAD 11
	SKIPE	WATFLG(RB)
	SOJGE	T1,.-1		;LOOP UNTIL AWAKE
	JUMPGE	T1,.+2		;OK
	ERROR	PDP-11 took too long in transfer loop
	SETZM	BLOCNT(RB)	;CLEAR COUNTER
	SETZM	BLOADR(RB)	;CLEAR ADDRESS
	RETURN
;HERE WHEN ERROR AND TIME TO GIVE UP
EXITX:	JSP	T1,.+1		;GET PC BITS
	TLNE	T1,(1B6)	;SEE IF I/O MODE
	PUSHJ	P,HALTIT	;YES--STOP -11

;HERE TO RETURN TO MONITOR
GOHOME:	RESET			;GO RETURN TO MONITOR
	HLLZM	.JBINT##	;DEACTIVATE ^C INTERCEPT
	EXIT	1,
	EXIT

;ROUTINES TO STOP -11 AND CHECK FINAL STATUS
HALTIT:	MOVEI	T1,0		;SET FOR HALT
STOPIT:	MOVEM	T1,BLOCNT(RB)	;PLANT HALT OR JMP IN LOADER LISTEN LOOP
	AOS	WATFLG(RB)	;TELL -11 ABOUT STARTING
	ROT	T1,^D71		;WAIT ABOUT 20-30 US
	ROT	T1,^D71
	ROT	T1,^D71
	GTPI11	T2		;GET PI-CHANNEL
	ANDI	T2,GETPIC	;MASK TO IT ALONE
	DSAB11	((T2))		;DISABLE -11
	GSTS11	T1		;GET FINAL STATUS
	TDNE	T1,OK...	;SEE IF OK
	OUTSTR	[ASCIZ \? NXM or parity error in -10 memory
\]
	RETURN
	SUBTTL	COMMAND SCANNER

GETCOM:	OUTSTR	[ASCIZ /File: /]	;TELL USER WE ARE WAITING
COMLP:	PUSHJ	P,GETNAM	;GET A SIXBIT NAME
	JRST	.+2
COMFND:	MOVEI	T2,0		;CLEAR NAME
	MOVSI	T4,-BRKLEN	;LOOK FOR BREAK
	HLRZ	T3,BRKTAB(T4)	;TRY NEXT BREAK
	CAME	T1,T3		;SEE IF MATCH
	AOBJN	T4,.-2		;LOOP UNTIL MATCH
	HRRZ	T3,BRKTAB(T4)	;GET DISPATCH ADDRESS
	JRST	(T3)		;JUMP TO HANDLE BREAK

BRKTAB:	" ",,COMNOP		;SPACE IS A NO-OP
	".",,COMEXT		;DOT IS EXTENSION
	":",,COMDEV		;COLON IS DEVICE
	"[",,COMDIR		;BRAKET IS DIRECTORY
	"/",,COMSWT		;SLASH IS SWITCH
	12,,SAVNAM		;RETURN AT END OF LINE, AFTER SAVING FILE NAME
	32,,GOHOME		;IF ^Z
	3,,GOHOME		;IF ^C
BRKLEN==.-BRKTAB
	0,,COMERR		;ELSE, MUST BE ERROR

COMERR:	USEROR	Command error--type /H for help
COMNOP:	PUSHJ	P,SAVNAM	;STORE FILE NAME
	JRST	COMLP		;AND GO AROUND AGAIN

COMEXT:	PUSHJ	P,SAVNAM	;SAVE FILE NAME
	PUSHJ	P,GETNAM	;GET SIXBIT NAME
	HLLOM	T2,EXT		;SAVE EXT WITH FLAG FOR DOT
	JRST	COMFND		;AND GO AROUND AGAIN

COMDEV:	MOVEM	T2,DEV		;SAVE DEVICE
	JRST	COMLP		;GO AROUND AGAIN

COMDIR:	PUSHJ	P,SAVNAM	;SAVE FILE NAME
	PUSHJ	P,GETOCT	;GET OCTAL NOW
	CAIN	T1,"-"		;SEE IF DEFAULT
	JUMPE	T2,[PUSHJ P,GETCHR
		    JRST  COMDIX]
	HRLZ	T2,T2		;POSITION IT
	SKIPN	T2		;SKIP IF SOMETHING THERE
	GETPPN	T2,		;NO--GET FROM SYSTEM
	  JFCL
	HLLZM	T2,DIRECT	;SAVE FOR LATER
	CAIE	T1,","		;VERIFY COMMA
	JRST	COMERR		;NO--GIVE UP IN DISGUST
	PUSHJ	P,GETOCT	;GET PROGRAMMER
	SKIPN	T2		;SKIP IF SOMETHING THERE
	GETPPN	T2,		;ELSE ASK MONITOR
	  JFCL
	HRRM	T2,DIRECT	;STORE FOR LOOKUP
	CAIE	T1,","		;SEE IF SFD COMING
	JRST	COMDIX		;NO--GO FINISH UP
	MOVEI	T2,DIRPTH	;YES--SHIFT TO SFD
	EXCH	T2,DIRECT	; FORMAT
	MOVEM	T2,DIRPTH+2	; ..
	MOVSI	T4,-5		;MAX SFD COUNT
COMDIL:	PUSHJ	P,GETNAM	;GET SFD NAME
	JUMPE	T2,COMERR	;ERROR IF BLANK
	MOVEM	T2,DIRPTH+3(T4)	;STORE
	CAIN	T1,","		;SEE IF MORE
	AOBJN	T4,COMDIL	;YES--GO GET UNLESS TOO MANY
COMDIX:	CAIN	T1,"]"
	JRST	COMLP
	CAIN	T1,12
	JRST	COMFND
	JRST	COMERR

SAVNAM:	SKIPE	T2		;IF NAME,
	MOVEM	T2,NAME		; SAVE FOR LOOKUP
	POPJ	P,		;RETURN
;HERE WHEN SWITCH TO BE PROCESSED

COMSWT:	PUSHJ	P,SAVNAM	;SAVE FILE NAME
	PUSHJ	P,GETNAM	;GET SIXBIT WORD
	MOVEI	T3,0		;PRESET MASK
	MOVSI	T4,770000	;PRESET CHARACTER
	TDNE	T2,T4		;IF CHARACTER,
	IOR	T3,T4		; INCLUDE IN MASK
	LSH	T4,-6		;MOVE OVER ONE
	JUMPN	T4,.-3		;LOOP FOR WORD
	SETO	T4,		;PRESET SUCCESS COUNTER
	MOVSI	P1,-SWTLEN	;PRESET LOOP
SWTLOP:	CAMN	T2,SWTTAB(P1)	;SEE IF EXACT MATCH
	JRST	SWTWIN		;YES--WIN
	MOVE	P2,SWTTAB(P1)	;NO--GET WORD
	XOR	P2,T2		;COMPARE WITH INPUT
	TDNE	P2,T3		;LOOK THROUGH MASK
	JRST	.+3		;NO--KEEP TRYING
	AOS	T4		;COUNT MATCH
	MOVE	P3,P1		;SAVE POINTER
	AOBJN	P1,SWTLOP	;SEE IF DONE YET
	MOVE	P1,P3		;RESTORE WINNER
	JUMPE	T4,SWTWIN	;SEE IF JUST ONE MATCH
	SKIPGE	T4
	USEROR	Unknown switch--type /H for help
	USEROR	Ambiguous switch--type /H for help
SWTWIN:	HLRZ	T2,SWTVAL(P1)	;GET DEFAULT VALUE
	CAIN	T1,":"		;SEE IF VALUE TYPED IN
	PUSHJ	P,GETOCT	;YES--GET OCTAL NUMBER
	HRRZ	T3,SWTVAL(P1)	;GET ADDRESS OF SWITCH
	JUMPE	T3,HELP		;NONE--MUST BE /H
	MOVEM	T2,(T3)		;STORE ANSWER
	JRST	COMFND		;GO HANDLE BREAK
SWTTAB:	SIXBIT	/CLEAR/
	SIXBIT	/DUMP/
	SIXBIT	/END/
	SIXBIT	/HELP/
	SIXBIT	/IMAGE/
	SIXBIT	/LOAD/
	SIXBIT	/PORTNO/
	SIXBIT	/START/
SWTLEN==.-SWTTAB
SWTVAL:	V.CLR,,A.CLR		;DEFAULT,,LOCATION
	V.DUMP,,A.DUMP
	V.END,,A.END
	0
	0,,A.IMAG
	0,,A.LOAD
	0,,A.PORT
	0,,A.STRT


;HERE IF /HELP
HELP:	CAIN	T1,12		;SEE IF AT END OF LINE YET
	JRST	HELP1		;YES--GO DO THE HELP
	PUSHJ	P,GETCHR	;NO--GET ANOTHER CHAR
	JRST	HELP		;AND LOOP
HELP1:	MOVE	1,['BOOT11']
	PUSHJ	P,.HELPR##
	JRST	START
GETNAM:	MOVE	T3,[POINT 6,T2]
	MOVEI	T2,0		;CLEAR NAME
GETNM1:	PUSHJ	P,GETCHR	;GET NEXT CHAR
	CAIL	T1,"A"+40	;SEE IF LC
	CAILE	T1,"Z"+40
	JRST	.+2
	SUBI	T1,40		;YES--MAKE UC
	CAIL	T1,"0"		;SEE IF BREAK
	CAILE	T1,"Z"		; ..
	RETURN
	CAILE	T1,"9"		;OR OK
	CAIL	T1,"A"
	JRST	.+2
	RETURN
	SUBI	T1,40		;CONVERT TO SIXBIT
	TLNE	T3,770000	;SEE IF OVERFLOW
	IDPB	T1,T3		;STORE RESULT
	JRST	GETNM1		;LOOP FOR MORE

GETOCT:	MOVEI	T2,0		;CLEAR RESULT
GETOC1:	PUSHJ	P,GETCHR	;GET NEXT ODGIT
	CAIL	T1,"0"		;SEE IF
	CAILE	T1,"7"		; BREAK
	RETURN
	LSH	T2,3		;MULT BY 8
	ADDI	T2,-"0"(T1)	;INCLUDE ODGIT
	JRST	GETOC1		;LOOP

GETCHR:	INCHWL	T1		;GET NEXT CHARACTER
	JUMPE	T1,GETCHR	;LOOP IF NULL
	CAIE	T1,177		;IF RUB
	CAIN	T1,15		;OR CR
	JRST	GETCHR		;LOOP
	CAIL	T1,175		;IF ALTERNATE ALT MODE
	MOVEI	T1,33		; STANDARDIZE
	CAIN	T1,33		;IF ESCAPE
	MOVEI	T1,12		; MAKE INTO EOL
	CAIE	T1,13		;IF VTAB
	CAIN	T1,14		; OR FORM
	MOVEI	T1,12		; MAKE INTO LF
	CAIN	T1,11		;SEE IF TAB
	MOVEI	T1," "		;YES, CHANGE TO SPACE
	RETURN
SUBTTL	HEADER CONSTRUCTION SUBROUTINES

HEDTXT:	POP	P,T2		;PRINT STRING, CALLED WITH PUSHJ
	HRLI	T2,440700	;CHANGE PC TO BYTE POINTER
HEDTX2:	ILDB	T1,T2		;GET NEXT BYTE
	JUMPE	T1,1(T2)	;RETURN ON 0 CHARACTER
	PUSHJ	P,HEDCHR	;PRINT CHARACTER
	JRST	HEDTX2		;LOOP FOR MORE

HEDOCT:	TDZA	T3,T3		;PRINT OCTAL NUMBER, CALLED BY PUSHJ
HEDDEC:	MOVEI	T3,2		;PRINT DECIMAL NUM, CALLED BY PUSHJ
	MOVE	T4,T3		;FOR DECIMAL NUMS, FORCE 2 DIGITS
HEDNUM:	IDIVI	T1,10(T3)
	HRLM	T1+1,(P)
	SOSG	T4		;FORCE DIGITS
	SKIPE	T1
	PUSHJ	P,HEDNUM
	HLRZ	T1,(P)
HEDDIG:	ADDI	T1,"0"		;PRINT DIGIT
HEDCHR:	IDPB	T1,HEDPNT	;PRINT CHARACTER
	POPJ	P,

HED7:	MOVEI	T2,5		;PRINT 5 ASCII CHARS, CALLED BY PUSHJ
HED7A:	ROT	T1,7		;GET NEXT CHARACTER
	TRNE	T1,177		;SKIP IF NULL
	PUSHJ	P,HEDCHR
	SOJG	T2,HED7A	;LOOP UNTIL 5 PRINTED
	POPJ	P,
SUBTTL STORAGE
	XLIST	;LITERALS
	LIT
	LIST

HEDPNT:	BLOCK	1		;POINTER FOR CONSTRUCTING HEADER
HEADER:	BLOCK	^D20		;BLOCK FOR HEADER
HEDEND:

CCINT:	EXITX		;^C INTERCEPT BLOCK
	1B34
CCINTP:	Z
	Z


FWAZER:!		;START OF AREA TO CLEAR

PDLST:	BLOCK	PDSIZ+1
DEV:	BLOCK	1		;DEVICE
NAME:	BLOCK	1		;FILE NAME
EXT:	BLOCK	1		;FILE EXTENSION,,-1 IF . SEEN
DIRECT:	BLOCK	1		;DIRECTORY
DIRPTH:	BLOCK	9		;SFD PATH

INHDR:	BLOCK	3		;INPUT HEADER
OUTHDR:	BLOCK	3		;OUTPUT HEADER
ADDRES:	BLOCK	1
CHKSUM:	BLOCK	1		;RUNNING CHECKSUM
FIRZER:	BLOCK	1		;FIRST LOCATION OF ZEROS
LASZER:	BLOCK	1		;LAST ..
CORE.4:	BLOCK	1		;REAL CONTENTS OF 4/5
CORE.6:	BLOCK	1		;REAL CONTENTS OF 6/7

A.PORT:	BLOCK	1		;/PORTNO:P
GTPI.:	BLOCK	1		;READ PI CHANNEL
ENBL.:	BLOCK	1		;ENABLE PORT
DSAB.:	BLOCK	1		;DISABLE PORT
CLRA.:	BLOCK	1		;CLEAR -11
CLRB.:	BLOCK	1		;CLEAR -11
BASE.:	BLOCK	1		;SET BASE ADDRESS
STRT.:	BLOCK	1		;START -11
STOP.:	BLOCK	1		;STOP -11
GSTS.:	BLOCK	1		;GET STATUS
CLRB..:	BLOCK	1		;DATUM FOR CLEAR
STRT..:	BLOCK	1		;DATUM FOR START
STOP..:	BLOCK	1		;DATUM FOR STOP
UP...:	BLOCK	1		;EXIST AND POWER BITS
RN...:	BLOCK	1		;RUN BIT
OK...:	BLOCK	1		;ERROR BITS

LWAZER==.-1		;END OF AREA TO CLEAR

FWAONE:!		;START OF AREA TO PRESET TO -1
A.CLR:	BLOCK	1		;/CLEAR:N
A.DUMP:	BLOCK	1		;/DUMP:N
A.END:	BLOCK	1		;/END:N
A.IMAG:	BLOCK	1		;/IMAGE
A.LOAD:	BLOCK	1		;/LOAD:N
A.STRT:	BLOCK	1		;/START:N
LWAONE==.-1		;END OF AREA TO PRESET TO -1
BASEAD:	PHASE	0		;CLEAN COPY OF -11 CODE
	HALT			;HALT FOR THE KI10 TRAP IN THE DL10
			;THIS CODE MADE AS FOLLOWS:
			;  (1)  TAKE PAGE AFTER NEXT AS FILE "LOAD.P11"
			;  (2)  TAKE THREE PAGES AFTER THAT AS "HACK11.CBL"
			;  (3)  COMPILE WITH MACY11:
			;		.R MACY11
			;		*,LOAD=LOAD
			;		*^C
			;  (4)  REMOVE TABS FROM LOAD.LST
			;		.R PIP
			;		*LOAD.LNT/W=LOAD.LST
			;		*^C
			;  (5)  CONVERT TO MACRO-10:
			;		.EXECUTE HACK11
			;  (6)  REMOVE TRAILING SPACES:
			;		.R PIP
			;		*LOAD.MAT/C=LOAD.MAC
			;		*^C
			;  (7)  FILE "LOAD.MAT" IS THE NEXT PAGE.
        EXP 010067,000170       ;MOV     %0,BLODAT+0     ;SAVE AC'S IN CASE OF DUMP
        EXP 010167,000166       ;MOV     %1,BLODAT+2
        EXP 010267,000164       ;MOV     %2,BLODAT+4
        EXP 010367,000162       ;MOV     %3,BLODAT+6
        EXP 010467,000160       ;MOV     %4,BLODAT+10
        EXP 010567,000156       ;MOV     %5,BLODAT+12
        EXP 010667,000154       ;MOV     %6,BLODAT+14
        EXP 013767,000004,000126;MOV     @#4,BLOCNT      ;SAVE CORE 4 FOR BUS TRAP
        EXP 013767,000006,000122;MOV     @#6,BLOADR      ; ALSO CORE 6
        EXP 010704              ;MOV     %7,%4           ;GET THIS LOCATION
        EXP 062704,000076       ;ADD     #BUSS-THIS,%4   ;GET ABSOLUTE ADDRESS
        EXP 010437,000004       ;MOV     %4,@#4          ;STORE FOR BUSS TRAP
        EXP 005067,000076       ;CLR     WATFLG          ;TELL -10 WE ARE DONE
        EXP 005767,000072       ;TST     WATFLG          ;0 MEANS WAIT
        EXP 001775              ;BEQ     WAIT1           ;- MEANS DATA, + START
        EXP 003035              ;BGT     BLOCNT          ;GO EXECUTE JMP OR HALT
        EXP 016703,000070       ;MOV     BLOADR,%3       ;GET CORE ADDRESS
        EXP 010704              ;MOV     %7,%4           ;GET THIS LOCATION
        EXP 062704,000070       ;ADD     #BLODAT-HERE,%4 ;GET ABSOLUTE ADDRESS
        EXP 010406              ;MOV     %4,%6           ;SET STACK FOR BUS TRAP
        EXP 005037,000006       ;CLR     @#6             ;CLEAR NEW FLAGS
        EXP 016705,000046       ;MOV     BLOCNT,%5       ;GET BYTE COUNT
        EXP 003006              ;BGT     COPY            ;IF .GT., LOAD 11
        EXP 005405              ;NEG     %5              ;IF .LT., DUMP 11
        EXP 010403              ;MOV     %4,%3           ;INTERCHANGE SOURCE
        EXP 016704,000036       ;MOV     BLOADR,%4       ;  AND DEST ADRS
        EXP 005237,000006       ;INC     @#6             ;FLAG INTERCHAGE FOR BUS TRAP
        EXP 005305              ;DEC     %5              ;LOOP MOVING BYTES ONE
        EXP 002747              ;BLT     WAITX           ;  AT A TIME
        EXP 112423              ;MOVB    (%4)+,(%3)+     ;COPY ONE BYTE
        EXP 000774              ;BR      COPY            ;LOOP UNTIL DONE
        EXP 010367,000012       ;MOV     %3,NXMADR       ;SAVE ADDRESS IN ERROR
        EXP 103342              ;BCC     WAITX           ;TELL -10 WE ARE DONE
        EXP 010467,000004       ;MOV     %4,NXMADR       ;IF DUMP, SAVE ADDRESS
        EXP 000737              ;BR      WAITX           ;THEN TELL -10
 
WATFLG: EXP 177777              ;.WORD   177777          ;0=WAIT, -=XFER, +=START
NXMADR: BLOCK   01              ;.BLKW   1               ;ADDRESS OF ERROR IF ANY
BLOCNT: BLOCK   01              ;.BLKW   1               ;BYTE COUNT
BLOADR: BLOCK   01              ;.BLKW   1               ;11 STARTING ADDRESS
BLODAT: BLOCK   10              ;.BLKW   10              ;DATA .....
	DEPHASE		;END OF -11 AREA
LEN11==.-BASEAD
WINDOW==<<LEN11+77>/100>*1K-1		;ALLOW FOR BOTH 1K AND 8K OPTIONS

REPEAT	0,<	;FILE LOAD.P11
.TITLE LOAD
.ABS
.=2

				;**** START OF RESULTING CODE
BEGIN:	MOV	%0,BLODAT+0	;SAVE AC'S IN CASE OF DUMP
	MOV	%1,BLODAT+2
	MOV	%2,BLODAT+4
	MOV	%3,BLODAT+6
	MOV	%4,BLODAT+10
	MOV	%5,BLODAT+12
	MOV	%6,BLODAT+14
	MOV	@#4,BLOCNT	;SAVE CORE 4 FOR BUS TRAP
	MOV	@#6,BLOADR	; ALSO CORE 6
	MOV	%7,%4		;GET THIS LOCATION
THIS:	ADD	#BUSS-THIS,%4	;GET ABSOLUTE ADDRESS
	MOV	%4,@#4		;STORE FOR BUSS TRAP
WAITX:	CLR	WATFLG		;TELL -10 WE ARE DONE
WAIT1:	TST	WATFLG		;0 MEANS WAIT
	BEQ	WAIT1		;- MEANS DATA, + START
	BGT	BLOCNT		;GO EXECUTE JMP OR HALT
	MOV	BLOADR,%3	;GET CORE ADDRESS
	MOV	%7,%4		;GET THIS LOCATION
HERE:	ADD	#BLODAT-HERE,%4	;GET ABSOLUTE ADDRESS
	MOV	%4,%6		;SET STACK FOR BUS TRAP
	CLR	@#6		;CLEAR NEW FLAGS
	MOV	BLOCNT,%5	;GET BYTE COUNT
	BGT	COPY		;IF .GT., LOAD 11
	NEG	%5		;IF .LT., DUMP 11
	MOV	%4,%3		;INTERCHANGE SOURCE
	MOV	BLOADR,%4	;  AND DEST ADRS
	INC	@#6		;FLAG INTERCHAGE FOR BUS TRAP
COPY:	DEC	%5		;LOOP MOVING BYTES ONE
	BLT	WAITX		;  AT A TIME
	MOVB	(%4)+,(%3)+	;COPY ONE BYTE
	BR	COPY		;LOOP UNTIL DONE
BUSS:	MOV	%3,NXMADR	;SAVE ADDRESS IN ERROR
	BCC	WAITX		;TELL -10 WE ARE DONE
	MOV	%4,NXMADR	;IF DUMP, SAVE ADDRESS
	BR	WAITX		;THEN TELL -10

WATFLG:	.WORD	177777		;0=WAIT, -=XFER, +=START
NXMADR:	.BLKW	1		;ADDRESS OF ERROR IF ANY
BLOCNT:	.BLKW	1		;BYTE COUNT
BLOADR:	.BLKW	1		;11 STARTING ADDRESS
BLODAT:	.BLKW	10		;DATA .....
				;**** END OF RESULTING CODE

	.END	BEGIN
>		;END OF FILE LOAD.P11
	SUBTTL	FILE HACK11.CBL

REPEAT	0,<	;FILE HACK11.CBL
IDENTIFICATION DIVISION.
PROGRAM-ID.  HACK11 TO CONVERT MACY11 LISTING TO MACRO10 INPUT.
	ADDRESS MUST BE SIX CHARS TO APPEAR IN -10.
ENVIRONMENT DIVISION.
INPUT-OUTPUT SECTION.
FILE-CONTROL.
	SELECT IN-ELEVEN,	ASSIGN TO DSK, RECORDING MODE ASCII.
	SELECT OUT-TEN,		ASSIGN TO DSK, RECORDING MODE ASCII.
DATA DIVISION.
FILE SECTION.
FD IN-ELEVEN, VALUE IDENTIFICATION "LOAD  LNT".
01	DATA-IN.
	02  FILLER PIC X(16).
	02  DATA-1 PIC X(6).
	02  FILLER PIC XX.
	02  DATA-2 PIC X(6).
	02  FILLER PIC XX.
	02  DATA-3 PIC X(6).
	02  FILLER PIC XX.
	02  ADDR PIC X(6).
	02  TEN-ADDR-FLAG PIC X.
	02  FILLER PIC X.
	02  REST-OF-LINE PIC X(53).
	02  TEST-LINE REDEFINES REST-OF-LINE.
		03  OP-CODE PIC X(5).
		03  FILLER PIC X(3).
		03  WIDTH PIC X(8).
		03  REST-OF-FILL PIC X(37).
	02  OVERFLOW-AREA PIC X(20).
FD OUT-TEN, VALUE IDENTIFICATION "LOAD  MAC".
01	DATA-OUT.
	02  ADDR PIC X(6).
	02  FIL-1 PIC XX.
	02  FIL-2 PIC XXX.
	02  FILLER PIC X.
	02  DATA-1 PIC X(6).
	02  FIL-3 PIC X.
	02  DATA-2 PIC X(6).
	02  FIL-4 PIC X.
	02  DATA-3 PIC X(6).
	02  FIL-5 PIC X.
	02  REST-OF-LINE PIC X(53).

01	BLOCK-OUT.
	02  ADDR PIC X(6).
	02  FIL-D1 PIC XX.
	02  FIL-D2 PIC X(8).
	02  WIDTH-OUT PIC X(8).
	02  FILLER PIC X(8).
	02  FIL-5  PIC X.
	02  REST-OF-LINE PIC X(53).

WORKING-STORAGE SECTION.
01	SKIP-REC.
	02  FILLER PIC X(72).
	02  SKIP-FIELD PIC X(5).
	02  FILLER PIC X(44).
01	DATA-TO-FILL-WITH.
	02  FIL-2 PIC X(3) VALUE "EXP".
	02  FIL-5 PIC X VALUE ";".
PROCEDURE DIVISION.
START-RUN.
	OPEN INPUT IN-ELEVEN.  OPEN OUTPUT OUT-TEN.
FIND-DATA.
	READ IN-ELEVEN RECORD INTO SKIP-REC AT END GO TO NOT-FOUND.
	IF SKIP-FIELD NOT= ";****" GO TO FIND-DATA.
	IF OP-CODE = ".BLKW" GO TO BLOCK.
GOT-DATA.
	READ IN-ELEVEN RECORD INTO SKIP-REC AT END GO TO NOT-FOUND.
	IF SKIP-FIELD = ";****" GO TO ALL-DONE.
	IF OVERFLOW-AREA NOT = SPACES DISPLAY "% COMMENTS TRUNCATED: "
		OVERFLOW-AREA.
	IF OP-CODE = ".BLKW" GO TO BLOCK.
	MOVE SPACES TO DATA-OUT.
	IF OP-CODE = SPACES GO TO WRITE-DATA.
	MOVE CORRESPONDING DATA-TO-FILL-WITH TO DATA-OUT.
	MOVE CORRESPONDING DATA-IN TO DATA-OUT.
	IF TEN-ADDR-FLAG = ":" MOVE ": " TO FIL-1
		ELSE MOVE SPACES TO ADDR IN DATA-OUT.
	IF DATA-2 IN DATA-IN NOT= SPACES MOVE "," TO FIL-3.
	IF DATA-3 IN DATA-IN NOT= SPACES MOVE "," TO FIL-4.
WRITE-DATA.
	WRITE DATA-OUT.
	GO TO GOT-DATA.
BLOCK.
	MOVE SPACES TO BLOCK-OUT.
	MOVE CORRESPONDING DATA-TO-FILL-WITH TO DATA-OUT.
	MOVE CORRESPONDING DATA-IN TO DATA-OUT.
	MOVE "BLOCK" TO FIL-D2.
	IF ADDR IN DATA-IN NOT= SPACES MOVE ": " TO FIL-D1.
	WRITE BLOCK-OUT.
	GO TO GOT-DATA.
NOT-FOUND.
	DISPLAY "? Error--;**** not found".
	
ALL-DONE.
	CLOSE IN-ELEVEN.  CLOSE OUT-TEN.
	STOP RUN.
>		;END OF HACK11.CBL

	END	START
 ^
!'