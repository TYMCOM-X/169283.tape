!**COPYRIGHT 1972,1973,DIGITAL EQUIPMENT CORPORATION, MAYNARD MA 01754**
!AUTHORS: NORMA ABEL AND SARA MURPHY

GLOBAL BIND UTILV=60;	!VERSION DATE: 7/13/73


GLOBAL ROUTINE PROPNEG(CNODE)=
%(***************************************************************************
	PROPAGATE A NEGATIVE OVER THE NODE "CNODE" IF IT IS POSSIBLE TO DO SO.
	THIS ROUTINE ALLOWS FOR NEGFLAGS SET IN THE NODE CNODE.
	IT RETURNS TRUE IF IT WAS ABLE TO PROPAGATE THE NEG, FALSE IF NOT.
***************************************************************************)%
BEGIN
	REGISTER OPERIX;			!FOR ARITHMETIC OPERATORS, THE OPERSP
						! FIELD IS USED AS AN INDEX TO SPECIFY ACTION
						! TO BE TAKEN
	MAP PEXPRNODE CNODE;


	%(***THE FOLLOWING TABLES ARE USED IF CNODE IS AN ARITHMETIC OPERATION****)%

	%(*****TABLE OF WHETHER TO NEGATE ARG1*****)%
	BIND A1NEGTBL=PLIT (
		TRUE,		!FOR ADD, DO
		TRUE,		!FOR SUB, DO
		TRUE,		!FOR MUL, DO
		TRUE,		!FOR DIV, DO
		FALSE);		!FOR EXPONEN, DO NOT

	%(***TABLE OF WHETHER TO NEGATE ARG2***)%
	BIND A2NEGTBL=PLIT (
		TRUE,		!FOR ADD DO
		TRUE,		!FOR SUB DO
		FALSE,		!FOR MUL DO NOT
		FALSE,		!FOR DIV DO NOT
		FALSE );		!FOR EXPONEN, DO NOT

	%(***TABLE OF WHETHER  THE NEGATE WAS SUCCESSFULLY PROPAGATED***)%
	BIND PROPSUCCESS=PLIT (
		TRUE,		!CAN PROPAGATE FOR ADD
		TRUE,		!CAN FOR SUB
		TRUE,		!CAN FOR MUL
		TRUE,		!CAN FOR DIV
		FALSE );		!CAN NOT PROPAGATE NEG ACROSS EXPONEN




	%(***IF ANY "NOT" FLAGS ARE SET IN CNODE, DONT BOTHER***)%
	IF .CNODE[A1NOTFLG] OR .CNODE[A2NOTFLG]
	THEN RETURN FALSE;

	%(****IF CNODE IS AN ARITHMETIC EXPRESSION********)%

	IF .CNODE[OPRCLS] EQL ARITHMETIC
	THEN
	BEGIN
		%(***ALL DECISIONS WILL BE MADE ON THE BASIS OF THE SPECIFIC OPERATOR***)%
		OPERIX_.CNODE[OPERSP];

		%(***PROCESS 1ST ARG UNDER CNODE***)%
		IF .CNODE[A1NEGFLG]
		THEN
		CNODE[A1NEGFLG]_NOT .A1NEGTBL[.OPERIX]		!2 NEGS CANCEL
		ELSE
		IF .CNODE[A1VALFLG]
		THEN
		CNODE[A1NEGFLG]_.A1NEGTBL[.OPERIX]		!CANNOT PROP OVER A VAR
		ELSE
		IF .A1NEGTBL[.OPERIX]
		THEN
		BEGIN
			IF NOT PROPNEG(.CNODE[ARG1PTR])
			THEN
			CNODE[A1NEGFLG]_1;			!IF CANNOT PROP NEG OVER ARG1
		END;

		%(***PROCESS 2ND ARG UNDER CNODE***)%
		IF .CNODE[A2NEGFLG]
		THEN
		CNODE[A2NEGFLG]_NOT .A2NEGTBL[.OPERIX]		!2 NEGS CANCEL
		ELSE
		IF .CNODE[A2VALFLG]
		THEN
		CNODE[A2NEGFLG]_.A2NEGTBL[.OPERIX]		!CANNOT PROP OVER A VAR
		ELSE
		IF .A2NEGTBL[.OPERIX]
		THEN
		BEGIN
			IF NOT PROPNEG(.CNODE[ARG2PTR])
			THEN
			CNODE[A2NEGFLG]_1;			!IF CANNOT PROP NEG OVER ARG2
		END;

		%(***RETURN TRUE IF SUCESSFULLY PROPAGATED NEGATE ONTO CNODE***)%
		RETURN .PROPSUCCESS[.OPERIX];

	END


	ELSE
	%(*****IF CNODE IS A TYPE-CONVERSION NODE FOR WHICH CODE MUST BE GENERATED
		(TO BE DIFFERENTIATED FROM TYPE CONVERSION NODES THAT
		ARE PRESENT ONLY TO KEEP TRACK OF VALTYPES)***)%
	IF .CNODE[OPRCLS] EQL TYPECNV AND (NOT NOCNV(CNODE))
	THEN
	BEGIN
		%(***IF THE VAL TO BE CONVERTED ALREADY HAD A NEG, THE 2 CANCEL***)%
		IF .CNODE[A2NEGFLG]
		THEN
		CNODE[A2NEGFLG]_0
		ELSE
		%(***CANNOT PROPAGATE A NEG DOWN ANY FURTHER ONTO A VAR***)%
		IF .CNODE[A2VALFLG]
		THEN
		CNODE[A2NEGFLG]_1
		ELSE
		IF NOT PROPNEG(.CNODE[ARG2PTR])
		THEN
		%(***IF WERE UNABLE TO PROPAGATE THE NEG OVER THE SUBNODE UNDER CNODE***)%
		CNODE[A2NEGFLG]_1;

		%(***CAN ALWAYS SUCCESSFULLY PROPAGATE A NEG ONTO A TYPE-CONVERSION***)%
		RETURN TRUE;
	END

	%(***CANNOT SUCCESSFULLY PROPAGATE A NEG OVER ANYTHING OTHER THAN ARITH OR TYPECNV - 
		(NOTE THAT ANY NEGATE NODES WOULD HAVE BEEN REMOVED AT PHASE 2 SKEL)***)%
	ELSE
	RETURN FALSE
END;






GLOBAL ROUTINE NODERR=
BEGIN
	EXTERNAL SKERR;
	SKERR();
END;

GLOBAL ROUTINE ALOCONST(CNODE)=
%(***************************************************************************
	ROUTINE TO SET A FLAG INDICATING THAT THIS CONSTANT SHOULD HAVE CORE
	ALLOCATED FOR IT.
	THIS SHOULD PROBABLY BE MADE A MACRO AT SOME POINT.
***************************************************************************)%
BEGIN
	MAP BASE CNODE;

	CNODE[CNTOBEALCFLG]_1;
END;

GLOBAL ROUTINE SWAP2DOWN(PNODE,AR1NODE)=
BEGIN

%(*****************************************************
	SWAP ARG 2 OF AN N-ARY PARENT(PNODE) WITH THE
	SECOND ARG OF THE LEFT SON (AR1NODE).
	REMEMBER TO ADJUST THE VAL FLAGS AND THE PARENT.
*******************************************************)%

	LOCAL T1;
	MAP PEXPRNODE PNODE:AR1NODE:T1;


	T1_.PNODE[ARG2PTR];
	!SWAP ARGS
	PNODE[ARG2PTR]_.AR1NODE[ARG2PTR];
	AR1NODE[ARG2PTR]_.T1;

	!FIX PARENTS
	!NOTE THAT T1 (WHICH HAS BECOME AR1NODE) ARG2 SHOULD GET AR1NODE
	!AS PARENT IF IT IS NOT AN ORPHAN

	IF .T1[OPRCLS] NEQ DATAOPR THEN
		T1[PARENT]_.AR1NODE;

	!NOW USE T1 AGAIN AS A DIFFERENT VALUE

	T1_.PNODE[ARG2PTR];
	IF .T1[OPRCLS] NEQ DATAOPR THEN
		T1[PARENT]_.PNODE;

	!ADJUST FLAGS

	T1_.PNODE[A2FLGS];
	PNODE[A2FLGS]_.AR1NODE[A2FLGS];
	AR1NODE[A2FLGS]_.T1;

END;

GLOBAL ROUTINE SETPVAL(CNODE)=
%(****************************************************
	ROUTINE SETS VAL FLAGS IN THE PARENT OF CNODE.
	CNODE IS THE OLD NODE THAT HAS JUST BEEN
	*FOLDED*.
	IT IS CALLED ONLY WHEN IT IS KNOWN THAT
	CNODE IS A DATAOPR.
*****************************************************)%
BEGIN
	LOCAL ANODE; MAP PEXPRNODE ANODE;
	MAP PEXPRNODE CNODE;

	ANODE_.CNODE[PARENT];
	IF .ANODE[OPRCLS] EQL STATEMENT THEN
	!PARENT POINTS BACK AT THE STATEMENT
	BEGIN
		IF .ANODE[SRCID] EQL ASGNID THEN
		!ASSIGNMENT STATEMENT IS ONLY ONE WITH VAL FLGS
		BEGIN
			IF .CNODE EQL .ANODE[RHEXP] THEN
				ANODE[A2VALFLG]_1
			ELSE
				ANODE[A1VALFLG]_1;
		END ELSE
		IF .ANODE[SRCID] EQL IFAID THEN
			ANODE[A1VALFLG]_1
		ELSE
		IF .ANODE[SRCID] EQL IFLID THEN
			ANODE[A1VALFLG]_1;
	END ELSE
	!IT MUST BE AN EXPRESSION

	%(***IF PARENT IS A FN CALL NODE, MUST SET VAL FLAG IN THE ARG-LIST***)%
	IF .ANODE[OPRCLS] EQL FNCALL
	THEN
	BEGIN
		OWN ARGUMENTLIST ARGLST;
		ARGLST_.ANODE[ARG2PTR];
		INCR CT FROM 1 TO .ARGLST[ARGCOUNT]
		DO
		BEGIN
			IF .ARGLST[.CT,ARGNPTR] EQL .CNODE
			THEN ARGLST[.CT,AVALFLG]_1
		END;
	END

	ELSE
	IF .CNODE EQL .ANODE[ARG1PTR] THEN
		ANODE[A1VALFLG] _ 1
	ELSE
		ANODE[A2VALFLG] _ 1;
END;



GLOBAL ROUTINE SETPIMMED(CNODE)=
%(****************************************************
	ROUTINE SETS IMMED FLAGS IN THE PARENT OF CNODE.
	CNODE IS THE OLD NODE THAT HAS JUST BEEN
	*FOLDED*.
	IT IS CALLED ONLY WHEN IT IS KNOWN THAT
	CNODE IS A DATAOPR.
*****************************************************)%
BEGIN
	LOCAL ANODE; MAP PEXPRNODE ANODE;
	MAP PEXPRNODE CNODE;

	ANODE_.CNODE[PARENT];
	IF .ANODE[OPRCLS] EQL STATEMENT THEN
	!PARENT POINTS BACK AT THE STATEMENT
	BEGIN
		IF .ANODE[SRCID] EQL ASGNID THEN
		!ASSIGNMENT STATEMENT IS ONLY ONE WITH IMMED FLGS
		BEGIN
			IF .CNODE EQL .ANODE[RHEXP] THEN
				ANODE[A2IMMEDFLG]_1
			ELSE
				ANODE[A1IMMEDFLG]_1;
		END ELSE
		IF .ANODE[SRCID] EQL IFAID THEN
			ANODE[A1IMMEDFLG]_1
		ELSE
		IF .ANODE[SRCID] EQL IFLID THEN
			ANODE[A1IMMEDFLG]_1;
	END ELSE
	!IT MUST BE AN EXPRESSION

	%(***IF PARENT IS A FNCALL NODE, DO NOT SET IMMEDFLGS***)%
	IF .ANODE[OPERSP] EQL FNCALL
	THEN
	BEGIN
	END

	ELSE
	IF .CNODE EQL .ANODE[ARG1PTR] THEN
		ANODE[A1IMMEDFLG] _ 1
	ELSE
		ANODE[A2IMMEDFLG] _ 1;
END;


!

EXTERNAL LSTLNK;			!USED TO LINK ENTRIES TOGETHER
EXTERNAL FRSTLNK;		!POINTER TO HEAD OF LIST OF TEMPS
EXTERNAL FTEMP;			!FIRST TEMP AVAILABLE FOR USE BY
				!SKELETON REGISTER ALLOCATOR
				!ZERO IF NONE EXISTS.
EXTERNAL ANCHOR;		!ALWAYS POINTS TO START OF LIST
MAP PEXPRNODE LSTLNK;


!MACRO TO MAKE A TEMPORARY NAME FROMA NUMBER
!THE GLOBAL CONTAINING  THE NUMBER IS THE SAME AS
!THE OPTIMIZER USES FOR REDUCTION IN STRENGTH.

MACRO MAKNAME(NUMB)=
	(.NUMB<9,3>+16)^18 + (.NUMB<6,3>+16)^12
	+ (.NUMB<3,3>+16)^6 + (.NUMB<0,3>+16)$;


GLOBAL ROUTINE MAKTEMP =
BEGIN
!CREATE A SYMBLOL TABLES LIKE ENTRY FOR A TEMPORARY FOR
!PHASE 2 SKELETON AND PHASE 2
EXTERNAL CORMAN;
REGISTER T;
EXTERNAL RDCCT;
MAP PEXPRNODE T;
	NAME<LEFT> _ IDSIZ;		!ENTRY IS 5 WORDS LONG
	T_CORMAN();		!GET CORE FOR ENTRY
	IF .LSTLNK EQL 0 THEN
		(ANCHOR_FRSTLNK_.T)
	ELSE
		 LSTLNK[CLINK] _ .T;	!LINK INTO LIST
	LSTLNK _ .T;
	T[CLINK] _ 0;		!MARKER FOR LAST IN LIST
	T[OPRCLS] _ DATAOPR;		!DATA OPERATOR
	T[OPERSP] _ TEMPORARY;		!SPERIFIC OPERATOR TEMPORARY
	T[IDSYMBOL]_SIXBIT'.Q'+MAKNAME(RDCCT);
	RDCCT_.RDCCT+1;
	.T
END;
GLOBAL ROUTINE NXTTMP(DBLWDFLAG)=
BEGIN
!GET THE NEXT AVAILABLE TEMPORARY IN SEQUENCE
OWN PEXPRNODE VTMP:RTMP;
	IF .FTEMP EQL 0 THEN
		RTMP_MAKTEMP()
	ELSE
	BEGIN
		RTMP_VTMP_.FTEMP;
		FTEMP_.VTMP[CLINK];
	END;
	IF .DBLWDFLAG THEN
	BEGIN
		IF .FTEMP EQL 0 THEN MAKTEMP()
		ELSE
		BEGIN
			VTMP_.FTEMP;
			FTEMP_.VTMP[CLINK];
		END;
	END;
	.RTMP
END;



!ROUTINES TO PERFORM LEAF SUBSTITUTION
!USED IN THREE PLACES
!	1. FOR STATEMENT FUNCTIONS TO SUBSTITUTE THE NEW
!	  VARIABLES FOR THE FORMALS
!	2. IN GLOBAL REGISTER ALLOCATION TO SUBSTITUTE REGCONTENTS NODES
!	   FOR VARIABLES
!	3. IN DO LOOP OPTIMIZATION IN PHASE 2 SKELETON TO SUBSTITUTE
!	   REGCONTENTS NODES FOR THE INDUCTION VARIBALE WHRE POSSIBLE

!THE VARIBALE SPECCASE IS USED TO HANDLE THE MINOR GLITCHES IN UNIFYING
!THESE THREE USES. 
!SPECCASE=
!	1 FOR THE GLOBAL REGISTER ALLOCATION CASE
!	  TO MATERIALIZE IN FRONT OF A STATEMENT CONTAINING A FUNCTION CALL
!	2 FOR THE PHASE 2 SKELETON DO OPTIMIZATION CASE
!	  TO CAUSE THE CORRECT IMMEDIATE FLAG TO BE SET IN THE PARENT
!	0 FOR STATEMENT FUNCTIONS
!THE GLOBAL QQ IS ALSO USED AS A FLAG BOTH IN THE PHASE 2 SKELETON CASE
!AND THE GLOBAL OPTIMIZER . IN THE LATTER CASE IT PROMPTS RESTORING
!GLOBALLY ASSIGNED QUANTATIES TO REGISTERS. IN PHASE 2 SKELETON
!IT CAUSES THE SUBSTITUTION TO TERMINATE.

	EXTERNAL ITMCT;

	OWN LOWLIM;	!GLOBAL REGISTER ALLOCATOR COUNTS FROM
			!	ZERO TO ITMCT.
			!OTHER USES COUNT FROM 1 TO ITMCT

	FORWARD LEAFSUBSTITUTE;


	ROUTINE LOOKANYWAY(EXPR)=
	BEGIN
		!FOR THE GLOBAL REGISTER ALLOCATOR ONLY.
		!WE HAVE WALKED DOWN ONTO A DATA ITEM,
		!BECAUSE IT IS A PART OF A STATEMENT, NOT
		!AN EXPRESSION.

		EXTERNAL CHOSEN,GLOBREG,REPLACARG,CSTMNT;

		DECR I FROM .ITMCT TO .LOWLIM DO
			IF .EXPR EQL .GLOBREG[.I] THEN
				REPLACARG(.CSTMNT,.GLOBREG[.I],
						.CHOSEN[.I]);
	END;
	ROUTINE LOKA1(EXPR)=
	BEGIN
		EXTERNAL CHOSEN,GLOBREG,SPECCASE,TOP;
		MAP BASE TOP;
		MAP PEXPRNODE EXPR;
		IF .EXPR[A1VALFLG] THEN
		BEGIN
			DECR I FROM .ITMCT TO .LOWLIM DO
			BEGIN
				IF .EXPR[ARG1PTR] EQL .GLOBREG[.I] THEN
				BEGIN
					EXPR[ARG1PTR]_.CHOSEN[.I];
					!FOR DO LOOPS ONLY
					!PHASE 2 SKELETON WITH
					!AOBJN TYPE ENDER WORD
					IF .SPECCASE EQL 2 THEN
						EXPR[A1IMMEDFLG]_1
					ELSE
					!GLOBAL ALLOCATION CASE
					IF .SPECCASE EQL 1 THEN
						IF .GLOBREG[.I] EQL
						.TOP[DOSYM] AND
						.TOP[FLCWD] THEN
						EXPR[A1IMMEDFLG]_1;
					RETURN;
				END;
			END;
		END ELSE LEAFSUBSTITUTE(.EXPR[ARG1PTR]);
	END;


	ROUTINE LOKA2(EXPR)=
	BEGIN
		MAP PEXPRNODE EXPR;
		EXTERNAL CHOSEN,GLOBREG,SPECCASE,TOP;
		MAP BASE TOP;
		IF .EXPR[A2VALFLG] THEN
		BEGIN
			DECR I FROM .ITMCT TO .LOWLIM DO
			IF .EXPR[ARG2PTR] EQL .GLOBREG[.I] THEN
			BEGIN
				EXPR[ARG2PTR]_.CHOSEN[.I];
				!FOR DO LOOPS ONLY
				!PHASE 2 SKELETON WITH AOBJN DO
				!LOOP CONTROL WORD
				IF .SPECCASE EQL 2 THEN
					EXPR[A2IMMEDFLG]_1
				ELSE
				!GLOBAL ALLOCATION
				IF .SPECCASE EQL 1 THEN
					IF .TOP[DOSYM] EQL .GLOBREG[.I]
						AND .TOP[FLCWD] THEN
					EXPR[A2IMMEDFLG]_1;
				RETURN;
			END;
		END ELSE LEAFSUBSTITUTE(.EXPR[ARG2PTR]);
	END;

GLOBAL ROUTINE LEAFSUBSTITUTE(EXPR)=
BEGIN
	!PERFORM LEAF SUBSTITUTION OF ANY REFERENCES TO GLOBREG (A VECTOR LIST)
	!WITHIN EXPR. WITH THE CORRESPONDING ELEMENT IN THE VECTOR CHOSEN
	MAP PEXPRNODE EXPR;
	EXTERNAL CHOSEN,GLOBREG,LOKCALST,QQ;
	!CHOSEN & GLOBREG ARE USED BY OPTIMIZER ALGORITHMS. THEY ARE GLOBAL
	!AND ARE USED HERE (THOUGH INAPPROPRIATELY NAMED) AS A
	!SPACE SAVING DEVICE.
	!THIS ROUTINE IS ALSO USED TO SUBSTITUTE THE REGCONTENTS NODE
	!FOR THE DO INDUCTION VARIABLE ON INNER-MOST DO LOOPS.
	!QQ IS USED AS A FLAG IN THIS CONTEXT TO NOTE WHEN A FUNCTION
	!CALL HAS BEEN PROCESSED TO TERMINATE THE SUBSTITUTION.
	!NOTE THAT THE EXECUTION MAY DIFFER FROM THE OLD COMPILER
	!SINCE THE REMAINDER OF THE STATEMENT IN WHICH THE FUNCTION
	!REFERENCE EXISTS WILL STILL HAVE THE SUBSTITUTION. THIS
	!IS CONSISTENT WITH THE DEFINITION OF FORTRAN, HOWEVER.

	EXTERNAL SPECCASE;

IF .SPECCASE EQL 1 THEN		!GLOBAL REGISTER ALLOCATOR
	LOWLIM_0
ELSE
	LOWLIM_1;

CASE .EXPR[OPRCLS] OF SET
!BOOLEAN
BEGIN
	LOKA1(.EXPR);
	LOKA2(.EXPR);
END;

!DATAOPR
BEGIN
		LOOKANYWAY(.EXPR);
END;

!RELATIONAL
BEGIN
	LOKA1(.EXPR);
	LOKA2(.EXPR);
END;

!FNCALL
BEGIN
	LOCAL ARGUMENTLIST AG;
	IF .SPECCASE EQL 1 AND .EXPR[OPERSP] NEQ LIBARY THEN
	BEGIN
			QQ_1;
			RETURN;
	END;
	AG_.EXPR[ARG2PTR];
	INCR I FROM .LOWLIM TO .ITMCT DO

	LOKCALST(.AG,.AG[ARGCOUNT],.GLOBREG[.I],.CHOSEN[.I]);
	QQ_1;		!FLAG FOR USE WITH DO LOOP SUBSTITUTION
	!ALSO USED BY GLOBAL REGISTER ALLOCATOR TO SIGNAL LIB/NONLIB
	IF .EXPR[OPERSP] EQL LIBARY THEN QQ_3;
END;

!ARITHMETIC
BEGIN
	LOKA1(.EXPR);
	LOKA2(.EXPR);
END;

!TYPCNV
	LOKA2(.EXPR);

!ARRAYREF
	LOKA2(.EXPR);

!CMNSUB
LOKA2(.EXPR);

!NEGNOT
LOKA2(.EXPR);

!SPECOP
LOKA1(.EXPR);

!FIELDREF
	BEGIN END;	!RELEASE GTR 1
!STORECLS
	BEGIN END;	!SHOULD NEVER SEE
!REGCONTENTS
	BEGIN END;	!DO NOTHING
!LABOP
	BEGIN END;	!SHOULD NEVER SEE
!STATEMENT
	BEGIN END;	!SHOULD NEVER SEE
!IOLCLS
	BEGIN END;	!HANDLED BY IOSUBSTITUTE
!INLINFN
	BEGIN
		LOKA1(.EXPR);
		IF .EXPR[ARG2PTR] NEQ 0 THEN
		LOKA2(.EXPR);
	END
TES;
END;


GLOBAL ROUTINE MISCIO(STMT)=
BEGIN
	!STMT IS AN I/O STATEMENT.
	!THIS ROUTINE CHECKS IORECORD AND IOUNIT FIELDS FOR
	!REGISTERS TO SUBSTITUTE. THE USUAL SHEME APPLIES.
	!GLOBREG CONTIANS THE POINTER TO THE VARIABLE; CHOSEN
	!CONTAINS A POINTER TO THE REGCONTENTS NODE. ITMCT CONTAINS THE
	!NUMBER OF ITEMS IN THE LISTS GLOBREG AND CHOSEN.
	!SPECCASE IS A FLAG WHICH SAYS COUNT FROM 0 (GLOBAL ALLOCA)
	!OR COUNT FROM 1 (STATEMENT FUNCTIONS, LOCAL ALLOC).

	MAP BASE STMT;
	REGISTER BASE TMP;

	EXTERNAL GLOBREG,CHOSEN,ITMCT,SPECCASE;

	LOWLIM_(IF .SPECCASE EQL 1 THEN 0 ELSE 1);

	INCR I FROM .LOWLIM TO .ITMCT DO
	BEGIN
		!IT COULD BE AN EXPRESSION
		IF .STMT[IORECORD] NEQ 0 THEN
		BEGIN
			TMP_.STMT[IORECORD];
			IF .TMP[OPRCLS] EQL DATAOPR THEN
			BEGIN
				IF .STMT[IORECORD] EQL .GLOBREG[.I] THEN
					STMT[IORECORD]_.CHOSEN[.I];
			END ELSE
				LEAFSUBSTITUTE(.TMP);
		END;

		IF .STMT[IOUNIT] EQL .GLOBREG[.I] THEN
			STMT[IOUNIT]_.CHOSEN[.I];
	END;
END;

GLOBAL ROUTINE DOVARSUBSTITUTE(CLSTCALL)=
BEGIN
	!TO PERFORM REGISTER SUBSTITUTIONS ON ALL FIELDS OF
	!A DO STATEMENT. USED BY IOSUBSTITUTE AND THE GLOBAL
	!REGISTER ALLOCATOR

	MAP BASE CLSTCALL;
	EXTERNAL ITMCT,GLOBREG,CHOSEN,SPECCASE;
	LOCAL BASE P;
	LOWLIM_(IF .SPECCASE EQL 1 THEN 0 ELSE 1);

			P_.CLSTCALL[DOLPCTL];
			IF .P[OPRCLS] NEQ DATAOPR THEN
				LEAFSUBSTITUTE(.P)
			ELSE
			INCR I FROM .LOWLIM TO .ITMCT DO
				IF .P EQL .GLOBREG[.I] THEN
					CLSTCALL[DOLPCTL]_.CHOSEN[.I];
		!A REG COULD ALSO BE THE INITIAL VALUE
		!OR STEP SIZE.
		!INITIAL VALUE FIRST
		P_.CLSTCALL[DOM1];	!PTR TO INITIAL VALUE
		INCR I FROM .LOWLIM TO .ITMCT DO
			IF .P EQL .GLOBREG[.I] THEN
				CLSTCALL[DOM1]_.CHOSEN[.I];
		P_.CLSTCALL[DOSSIZE];
		INCR I FROM .LOWLIM TO .ITMCT DO
			IF .P EQL .GLOBREG[.I] THEN
				CLSTCALL[DOSSIZE]_.CHOSEN[.I];
END;

GLOBAL ROUTINE IOSUBSTITUTE(CLSTCALL)=
BEGIN
	!TO SUBSTITUTE A REGCONTENTS NODE INTO AN I/O STATEMENT

	MAP BASE CLSTCALL;
	EXTERNAL GLOBREG,CHOSEN,ITMCT,SPECCASE;
	EXTERNAL TOP,QQ,CDONODE;
	MAP BASE TOP:CDONODE;
	EXTERNAL DOWDP;
	MAP OBJECTCODE DOWDP;
	LOCAL BASE P;

	LOWLIM_(IF .SPECCASE EQL 1 THEN 0 ELSE 1);
	IF .CLSTCALL[OPRCLS] EQL STATEMENT THEN
	BEGIN
		!WE ARE INTERESTED ONLY IF IT IS A DO
		IF .CLSTCALL[SRCID] EQL DOID THEN
		BEGIN
			DOVARSUBSTITUTE(.CLSTCALL);
		END ELSE
		!ITS A CONTINUE STATEMENT
		RETURN
	END ELSE
	CASE .CLSTCALL[OPERSP] OF SET
	!DATACALL
	BEGIN
		P_.CLSTCALL[DCALLELEM];
		IF .P[OPRCLS] NEQ DATAOPR THEN
			LEAFSUBSTITUTE(.P)
		ELSE
		INCR I FROM .LOWLIM TO .ITMCT DO
		BEGIN
			IF .GLOBREG[.I] EQL .P THEN
				CLSTCALL[DCALLELEM]_.CHOSEN[.I];
		END;
	END;
	!SLISTCALL
	BEGIN END;
	!IOLSTCALL
	BEGIN
		LOCAL BASE TMP;
		!LOOK THROUGH THE COMMON SUB-EXPRESSIONS
		!THEY WILL ONLY BE THERE IN THE GLOBAL
		!REGISTER ALLOCATION CASE WITH LOCAL CMNSUBS
		!ON THE I/O LISTS
		TMP_.CLSTCALL[SRCCOMNSUB];
		WHILE .TMP NEQ 0 DO
		BEGIN
			!WE MUST LOOK FOR THE LOCAL SPECIAL
			!CASE (IN RELEASE 1 ALL COMMON SUB-EXPRESSIONS
			!ON I/O IS LOCAL) OF THE SINGLE VARIABLE AND
			!NOT CALL LEAFSUBSTITUTE.

			IF .TMP[A2VALFLG] THEN
			BEGIN
				!COMMON SUB NODE IS A SINGLE VARIABLE
				INCR I FROM .LOWLIM TO .ITMCT DO
					IF .TMP[ARG2PTR] EQL .GLOBREG[.I] THEN
						TMP[ARG2PTR]_.CHOSEN[.I];
			END ELSE
				LEAFSUBSTITUTE(.TMP);
			TMP_.TMP[CLINK];
		END;

		P_.CLSTCALL[IOLSTPTR];
		WHILE .P NEQ 0 DO
		BEGIN
			IOSUBSTITUTE(.P);
			P_.P[SRCLINK];
		END;
	END;
	!E1LISTCALL
	BEGIN END;	!RELEASE >1
	!E2LISTCALL
	BEGIN END;	!RELEASE >1
	TES;
END;



GLOBAL ROUTINE CONTVAR(CNODE,VAR)=
%(***************************************************************************
	ROUTINE TO CHECK WHETHER THE EXPRESSION NODE CNODE CONTAINS THE VARIABLE
	VAR ANYWHERE UNDER IT.
***************************************************************************)%
BEGIN
	EXTERNAL CGERR;
	LOCAL PEXPRNODE ARGNODE;
	MAP PEXPRNODE CNODE;
	LOCAL ARGUMENTLIST ARGLST;

	%(***DEFINE MACRO TO CHECK BINARY NODES*****)%
	MACRO BINARYCHK=
	(CONTVAR(.CNODE[ARG1PTR],.VAR) OR CONTVAR(.CNODE[ARG2PTR],.VAR))$;

	DEBGNODETST(CNODE);	!FOR DEBUGGING ONLY, CHECK THAT CNODE IS NOT 0


	CASE .CNODE[OPRCLS] OF SET

	%(***FOR CNODE A BOOLEAN***)%
	RETURN BINARYCHK;

	%(***FOR DATA ITEM********)%
	RETURN (.CNODE EQL .VAR);

	%(***FOR RELATIONAL***)%
	RETURN BINARYCHK;

	%(***FUNCTION CALL***)%
	BEGIN
		%(***SEARCH TH LIST***)%
		IF (ARGLST_.CNODE[ARG2PTR]) NEQ 0
		THEN
		BEGIN
			INCR CT FROM 1 TO .ARGLST[ARGCOUNT]
			DO 
			BEGIN
				IF CONTVAR(.ARGLST[.CT,ARGNPTR],.VAR) THEN RETURN TRUE;
			END;
			RETURN FALSE
		END
	END;

	%(***FOR AN ARITHMETIC****)%
	RETURN BINARYCHK;

	%(***FOR A TYPECNV***)%
	RETURN CONTVAR(.CNODE[ARG2PTR],.VAR);

	%(***FOR AN ARRAYREF***)%
	BEGIN
		IF .CNODE[ARG2PTR] EQL 0 THEN RETURN (.CNODE[ARG1PTR] EQL .VAR)
		ELSE RETURN BINARYCHK
	END;

	%(***FOR A CMNSUB******)%
	RETURN FALSE;

	%(***FOR NEG/NOT***)%
	RETURN CONTVAR(.CNODE[ARG2PTR],.VAR);

	%(***FOR SPECIAL OPERATORS***)%
	RETURN CONTVAR(.CNODE[ARG1PTR],.VAR);


	%(***FOR  FIELD-REF - NOT IN RELEASE 1***)%
	CGERR();

	%(***FOR STORECLS***)%
	RETURN CONTVAR(.CNODE[ARG2PTR],.VAR);

	%(***FOR REGCONTENTS - VAR MAY BE THIS REGCONTENTS NODE***)%
	RETURN (.CNODE EQL .VAR);

	%(***FOR LABEL***)%
	RETURN FALSE;

	%(***SHOULD NOT ENCOUNTER A STATEMENT***)%
	CGERR();

	%(***FOR AN IOLIST-CLASS NODE - SHOULD NOT ENCOUNTER ONE***)%
	CGERR();

	%(***FOR AN IN-LINE FN***)%
	BEGIN
		IF .CNODE[ARG2PTR] EQL 0
		THEN RETURN (CONTVAR(.CNODE[ARG1PTR],.VAR))
		ELSE RETURN BINARYCHK
	END;

	TES;
END;


GLOBAL ROUTINE CONTFN(CNODE)=
%(***************************************************************************
	ROUTINE TO CHECK WHETHER THE EXPRESSION NODE CNODE CONTAINS ANY FUNCTION
	CALLS.
	RETURNS TRUE IF IT DOES.
***************************************************************************)%
BEGIN
	MAP PEXPRNODE CNODE;

	%(***DEFINE MACRO TO CHECK FOR EITHER SUBNODE OF A BINARY NODE***)%
	MACRO	BINARYCHK=
	(CONTFN(.CNODE[ARG1PTR]) OR CONTFN(.CNODE[ARG2PTR]) )$;

	CASE .CNODE[OPRCLS] OF SET

	%(**FOR A BOOLEAN***)%
	RETURN BINARYCHK;

	%(***FOR A DATA ITEM***)%
	RETURN FALSE;

	%(***FOR A RELATIONAL***)%
	RETURN BINARYCHK;

	%(***FOR A FN CALL***)%
	RETURN TRUE;

	%(***FOR AN ARITHMETIC***)%
	RETURN BINARYCHK;

	%(***FOR A TYPE CNV***)%
	RETURN CONTFN(.CNODE[ARG2PTR]);

	%(***FOR AN ARRAYREF***)%
	RETURN CONTFN(.CNODE[ARG2PTR]);

	%(***FOR A CMNSUB***)%
	RETURN FALSE;

	%(***FOR A NEG/NOT***)%
	RETURN CONTFN(.CNODE[ARG2PTR]);

	%(***FOR A SPECOP (P2MUL OR P2DIV) ***)%
	RETURN CONTFN(.CNODE[ARG1PTR]);

	TES;
END;

GLOBAL ROUTINE LASTONE(WD)=
	BEGIN
		!EXAMINE CLOBBREGS TO DETERMINE WHICH REGS NEED TO
		!BE SAVED. FIND THE POSITION OF THE TRAILING ONE.
		!EXAMPLE:
		!	LET USE USE A SIX BIT VALUE OF WD OF 111011.
		!	BITCT INITIALLY BECOMES 3 (BITS NUMBER FROM
		!	LEFT TO RIGHT STARTING AT ZERO.
		!	IN THE UNTIL LOOP, THE FIRST VALUE OF
		!	T1 IS 100000. BITCT THEN BECOMES 4.
		!	THE LOOP TERMINATED SINCE WD^4 = 0. 4
		!	IS THE VALUE RETURNED.
		OWN T1,BITCT,OBIT;
		IF .WD EQL -1 THEN RETURN 13;
		!WD WILL REALLY NEVER BE -1 SINCE A MAX OF
		!13 BITS CAN BE SET IN IT FOR REGS 2-15.
		IF .WD EQL 0 THEN RETURN -1;
		BITCT_FIRSTONE(NOT .WD);
		UNTIL (T1_.WD^.BITCT) EQL 0 DO
		BEGIN
			OBIT_.BITCT;
			BITCT_FIRSTONE(NOT .T1) + .BITCT;
			IF .OBIT EQL .BITCT THEN
				BITCT_.BITCT+1;
		END;
		.BITCT-1
	END;



GLOBAL ROUTINE UNFLDO(DONODE)=
%(***************************************************************************
	ROUTINE TO CHANGE A DO-LOOP NODE FROM AN AOBJN LOOP TO A NON-AOBJN LOOP.
	THIS ROUTINE CAN ONLY BE CALLED AFTER THE DO-LOOP HAS BEEN EXPANDED BY
	THE SEMANTICS ROUTINE "DOXPN", AND BEFORE REGISTER ALLOCATION HAS BEEN
	PERFORMED FOR THE LOOP (BEFORE THE "COMPLEXITY" PASS.
	IT IS CALLED
		1. IN PHASE 1, WHEN THE LOOP INDEX IS FOUND TO BE REASSIGNED INSIDE THE LOOP
		2. IN PHASE 2 SKELETON, FOR AOBJN LOOPS IN WHICH THE CTL VAL
			IS TO LIVE IN A REGISTER, BUT IS THEN USED IN CONTEXTS THAT
			REQUIRE A WHOLE WORD VALUE (IOLISTS, COMPUTED GOTO)
***************************************************************************)%
BEGIN
	MAP PEXPRNODE DONODE;
	OWN PEXPRNODE CTLCONST;

	IF NOT .DONODE[FLCWD] THEN RETURN;	!IF THIS LOOP ISNT AOBJN, RETURN

	%(***THE CONTROL CONSTANT MUST BE SET TO THE LEFT HALF OF THE AOBJN CONST***)%
	CTLCONST_.DONODE[DOLPCTL];
	DONODE[DOLPCTL]_MAKECNST(INTEGER,0,
				-(ARITHSHIFT(.CTLCONST[CONST2],-18)) );
	DONODE[CTLNEG]_1;
	DONODE[CTLIMMED]_1;

	DONODE[FLCWD]_0;
END;
    '