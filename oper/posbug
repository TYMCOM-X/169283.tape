C * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C     THIS IS THE MAIN RESIDENT ROUTINE WHICH CALLS THE INITIALIZATION,
C     DATA HANDLER, INPUT, SIMULATOR, AND OUTPUT SUBROUTINES
C
C     SPECIFICATIONS
C
      INTEGER ADATE,DATA,EQNS,ERRORS,PAGE,PRIME,PRINT,READ,SCRTCH,SEGMTS
     1,SIZE,TAPE,TITLE,UNITS,WORDS,WORD01,WORD02,WORD03,WORD04,WORD05,WO
     2RD06,WORD07,WORD08,WORD09,WORD10,WORD11,WORD12
      LOGICAL NOZERO
      REAL MU
      DOUBLE PRECISION ALIGN
      DIMENSION ADATE(18),LOCATE(18),STORE(20000),TITLE(80,2),WORDS(12)
      COMMON ADATE,BREAK,CONST,CONTOL,CONVSN,DATA,EQNS,ERRORS,FACTOR,LIM
     1IT,LINE,LOCATE,MAXALL,MAXLIN,MU,NODES,NOZERO,PAGE,PATMOS,PRIME,PRI
     2NT,READ,RHO,SCRTCH,SEGMTS,SINTOL,SIZE,TAPE,TAVG,TITLE,UNITS,WORDS
      EQUIVALENCE (ALIGN,STORE),(LOCATE,LOC01),(LOCATE(2),LOC02),(LOCATE
     1(3),LOC03),(LOCATE(4),LOC04),(LOCATE(5),LOC05),(LOCATE(6),LOC06),(
     2LOCATE(7),LOC07),(LOCATE(8),LOC08),(LOCATE(9),LOC09),(LOCATE(10),L
     3OC10),(LOCATE(11),LOC11),(LOCATE(12),LOC12),(LOCATE(13),LOC13),(LO
     4CATE(14),LOC14),(LOCATE(15),LOC15),(LOCATE(16),LOC16),(LOCATE(17),
     5LOC17),(LOCATE(18),LOC18),(WORDS,WORD01),(WORDS(2),WORD02),(WORDS(
     63),WORD03),(WORDS(4),WORD04),(WORDS(5),WORD05),(WORDS(6),WORD06),(
     7WORDS(7),WORD07),(WORDS(8),WORD08),(WORDS(9),WORD09),(WORDS(10),WO
     8RD10),(WORDS(11),WORD11),(WORDS(12),WORD12)
C
C *** SET CORE LIMIT, 'LIMIT' (DIMENSION OF 'STORE')
C
      LIMIT=20000
C
C     CALL INITIALIZATION SUBROUTINE, 'INITAL'
C
      CALL INITAL
      IF(ERRORS.NE.0) GO TO 110
C
C     CALL DATA HANDLER SUBROUTINE, 'HANDLR'
C
  100 CALL HANDLR
      IF(ERRORS.NE.0) GO TO 110
C
C     CALL INPUT SUBROUTINE, 'INPUT'
C
      CALL INPUT(STORE,STORE,STORE,STORE,STORE(LOC01),STORE(LOC01),STORE
     1(LOC02),STORE(LOC02),STORE(LOC03),STORE(LOC04),STORE(LOC05),STORE(
     2LOC06),STORE(LOC06),STORE(LOC07),STORE(LOC08),STORE(LOC09),STORE(L
     3OC10),STORE(LOC11),STORE(LOC12),STORE(LOC13),STORE(LOC14),STORE(LO
     4C15),STORE(LOC16),STORE(LOC17),STORE(LOC18))
      IF(ERRORS.NE.0) GO TO 100
C
C     CALL SIMULATOR SUBROUTINE, 'SIMUL'
C
      CALL SIMUL(STORE,STORE(WORD01),STORE(WORD02),STORE(WORD03),STORE(W
     1ORD04),STORE(WORD05),STORE(WORD06),STORE(WORD07),STORE(WORD08),STO
     2RE(WORD09),STORE(WORD10),STORE(WORD11),STORE(WORD12))
C
C     CALL OUTPUT SUBROUTINE, 'RESULT'
C
      CALL RESULT(STORE,STORE(WORD01),STORE(WORD02),STORE(WORD03),STORE(
     1WORD06),STORE(WORD07),STORE(WORD08),STORE(WORD10),STORE(LOC11),STO
     2RE(LOC12),STORE(LOC13),STORE(LOC14),STORE(LOC16))
      GO TO 100
C
C     FINISHED
C
  110 CALL EXIT
      END
C * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
      SUBROUTINE INITAL
C
C     THIS SUBROUTINE INITIALIZES THE PROGRAM
C
C     SPECIFICATIONS
C
      INTEGER ADATE,BLANK,COMMA,DATA,DAY,DIGIT,EQNS,ERRORS,PAGE,POINT,PR
     1IME,PRINT,READ,SCRTCH,SEGMTS,SIZE,TAPE,TITLE,UNITS,WORDS,YEAR
      LOGICAL NOZERO
      REAL MU
      DIMENSION ADATE(18),DIGIT(10),LETTER(74),LOCATE(18),POINT(13),TITL
     1E(80,2),WORDS(12)
      COMMON ADATE,BREAK,CONST,CONTOL,CONVSN,DATA,EQNS,ERRORS,FACTOR,LIM
     1IT,LINE,LOCATE,MAXALL,MAXLIN,MU,NODES,NOZERO,PAGE,PATMOS,PRIME,PRI
     2NT,READ,RHO,SCRTCH,SEGMTS,SINTOL,SIZE,TAPE,TAVG,TITLE,UNITS,WORDS
      DATA BLANK,COMMA/' ',','/,DIGIT/'0','1','2','3','4','5','6','7','8
     1','9'/,LETTER/'J','A','N','U','A','R','Y','F','E','B','R','U','A',
     2'R','Y','M','A','R','C','H','A','P','R','I','L','M','A','Y','J','U
     3','N','E','J','U','L','Y','A','U','G','U','S','T','S','E','P','T',
     4'E','M','B','E','R','O','C','T','O','B','E','R','N','O','V','E','M
     5','B','E','R','D','E','C','E','M','B','E','R'/,POINT/1,8,16,21,26,
     629,33,37,43,52,59,67,75/
C
C
C
C     THE SECTION INITIALIZES THE PROGRAM PARAMETERS
C
C
C
C *** SET I/O UNIT ASSIGNMENTS (THIS SECTION IS MACHINE DEPENDENT)
C
      DATA=16
      PRINT=5
      READ=5
      SCRTCH=17
      TAPE=1
      CALL SIMTTY(5)
      OPEN(16,'DATA.TMP',OUTPUT)
      CLOSE(16)
      OPEN(16,'DATA.TMP',RANDIO)
      OPEN(17,'SCR.TMP',OUTPUT)
      CLOSE(17)
      OPEN(17,'SCR.TMP',RANDIO)
C
C *** SET LEADING ZERO INDICATOR (FOR DECIMAL FRACTIONS), 'NOZERO', FOR
C *** USE IN SUBROUTINE 'CONVRT'
C
      NOZERO=.TRUE.
C
C *** SET DESIRED MAXIMUM NUMBER OF LINES PER PAGE, 'MAXLIN'
C
      MAXLIN=56
C
C *** SET FLUID DENSITY BREAK-POINT, 'BREAK', (LB/CU.FT.) BETWEEN GASES
C *** (COMPRESSIBLE FLOW; 'RHO' .LE. 'BREAK') AND LIQUIDS (INCOMPRESS-
C *** IBLE FLOW; 'RHO' .GT. 'BREAK') @ 60 DEG. F @ 14.696 PSIA
C
      BREAK=1.0
C
C *** SET CONVERGENCE AND SINGULARITY TOLERANCES, 'CONTOL' @ 'SINTOL'
C
      CONTOL=1.0E-4
      SINTOL=1.0E-10
C
C     SET MAXIMUM ALLOWABLE NUMBER OF NODES (OR SEGMENTS), 'MAXALL'
C
      MAXALL=MIN0(999,MAX0(1,LIMIT/22))
C
C     CHECK 'MAXALL'
C
      ERRORS=1
      IF(22*MAXALL.GT.LIMIT) GO TO 170
      ERRORS=0
C
C     CALCULATE LARGEST PRIME NUMBER, OF THE FORM 4*N+3, IN 'MAXALL' FOR
C     USE IN SUBROUTINE 'INPUT'
C
      PRIME=4*((MAXALL+1)/4)+3
  100 PRIME=PRIME-4
      J=SQRT(PRIME+0.5)
      DO 110 I=2,J
      IF(MOD(PRIME,I).EQ.0) GO TO 100
  110 CONTINUE
C
C     INITIALIZE THE DATA FILE, 'DATA'
C
      POSITION(16,1)
C
C
C
C     THIS SECTION CALCULATES TEMPORARY STORAGE ADDRESSES
C
C
C
      LOCATE(1)=2*MAXALL+1
      LOCATE(2)=LOCATE(1)+2*MAXALL
      DO 120 I=3,18
  120 LOCATE(I)=LOCATE(I-1)+MAXALL
C
C
C
C     THIS SECTION GETS THE DATE AND CONVERTS IT INTO AN 18 CHARACTER
C     ALPHAMERIC STRING
C
C
C
C     BLANK DATE STRING, 'ADATE(I)'
C
      MONTH=0
      DO 130 I=1,18
  130 ADATE(I)=BLANK
C
C *** GET MONTH, DAY, AND YEAR (THIS CALL IS MACHINE DEPENDENT) -
C *** REMOVAL OF THIS STATEMENT AUTOMATICALLY RESULTS IN A BLANKED-OUT
C *** DATE
C
      CALL DATE(DAY,MONTH,YEAR)
C
C     CHECK MONTH, DAY, AND YEAR
C
      IF(MONTH.LT.1.OR.MONTH.GT.12.OR.DAY.LT.1.OR.DAY.GT.99.OR.YEAR.LT.1
     1000.OR.YEAR.GT.9999) GO TO 170
C
C     PUT MONTH INTO STRING
C
      J=POINT(MONTH)
      K=POINT(MONTH+1)-1
      L=0
      DO 140 I=J,K
      L=L+1
  140 ADATE(L)=LETTER(I)
C
C     PUT DAY INTO STRING
C
      L=L+1
      I=DAY/10
      IF(I.EQ.0) GO TO 150
      L=L+1
      ADATE(L)=DIGIT(I+1)
      DAY=DAY-10*I
  150 L=L+1
      ADATE(L)=DIGIT(DAY+1)
C
C     PUT COMMA INTO STRING
C
      L=L+1
      ADATE(L)=COMMA
C
C     PUT YEAR INTO STRING
C
      L=L+1
      J=10000
      DO 160 I=1,4
      J=J/10
      K=YEAR/J
      YEAR=YEAR-J*K
      L=L+1
  160 ADATE(L)=DIGIT(K+1)
C
C     FINISHED
C
  170 RETURN
      END
C * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
      SUBROUTINE CONVRT(NUMBER,RCVR,WIDE,DEC)
C
C     THIS SUBROUTINE WILL CONVERT AN INTEGER OR REAL NUMBER ('NUMBER')
C     INTO AN ALPHAMERIC STRING ('RCVR') OF SPECIFIED WIDTH ('WIDE'),
C     ONE CHARACTER PER WORD.  THE NUMBER OF DIGITS FOLLOWING THE
C     DECIMAL MAY BE SPECIFIED ('DEC').  IF 'DEC' IS < ZERO, NO DECIMAL
C     IS RETURNED AND THE NUMBER MUST BE INTEGER (THIS CAUSES LEADING
C     ZEROES TO BE INSERTED).  IF 'DEC' IS ZERO, NO DECIMAL IS RETURNED
C     AND THE NUMBER MUST BE INTEGER.  IF 'DEC' IS > ZERO, THE NUMBER
C     MUST BE REAL (SINGLE PRECISION).  THE CONTENTS OF THE NUMBER ARE
C     NOT ALTERED BY THIS ROUTINE.
C
C     SPECIFICATIONS
C
      INTEGER ADATE,ASTER,DATA,DEC,DECIML,DIGIT,EQNS,ERRORS,FRACTN,PAGE,
     1PRIME,PRINT,READ,RCVR,SCRTCH,SEGMTS,SIZE,START,STOP,TAPE,TITLE,UNI
     2TS,WIDE,WORDS,ZERO
      LOGICAL FIRST,NOZERO
      REAL MU,REALNO
      DIMENSION ADATE(18),DIGIT(10),LOCATE(18),RCVR(1),TITLE(80,2),WORDS
     1(12)
      COMMON ADATE,BREAK,CONST,CONTOL,CONVSN,DATA,EQNS,ERRORS,FACTOR,LIM
     1IT,LINE,LOCATE,MAXALL,MAXLIN,MU,NODES,NOZERO,PAGE,PATMOS,PRIME,PRI
     2NT,READ,RHO,SCRTCH,SEGMTS,SINTOL,SIZE,TAPE,TAVG,TITLE,UNITS,WORDS
      EQUIVALENCE (DIGIT,ZERO),(INTGNO,REALNO)
      DATA ASTER,DECIML,DIGIT,MINUS/'*','.','0','1','2','3','4','5','6',
     1'7','8','9','-'/
C
C     SEPARATE INTEGRAL AND FRACTIONAL PARTS OF NUMBER, 'INTEGR' @
C     'FRACTN'
C
      INTGNO=NUMBER
      IF(DEC.GT.0) GO TO 100
      INTEGR=IABS(INTGNO)
      FRACTN=0
      GO TO 110
  100 REALNO=ABS(REALNO)+0.5*0.1**DEC
      INTEGR=REALNO
      FRACTN=10**DEC*(REALNO-INTEGR)
C
C     SET LIMIT INDICATOR, 'STOP'
C
  110 IF(DEC.GT.0) GO TO 120
      STOP=WIDE
      GO TO 130
  120 STOP=WIDE-DEC-1
C
C     ADJUST LIMIT INDEX, 'START', FOR SIGN OF NUMBER
C
  130 IF(NUMBER.LT.0) GO TO 140
      START=1
      J=STOP
      GO TO 150
  140 START=2
      J=STOP-1
C
C     CHECK SIZE OF NUMBER
C
  150 J=10**J
      IF(INTEGR.LT.J) GO TO 170
C
C     NUMBER IS TOO LARGE FOR FIELD - FILL FIELD WITH ASTERISKS
C
      DO 160 I=1,WIDE
  160 RCVR(I)=ASTER
      GO TO 240
C
C     BEGIN CONVERTING INTEGRAL PART OF NUMBER, 'INTEGR'
C
  170 IF(INTEGR.EQ.0.AND.DEC.GE.0) GO TO 200
      INTGNO=INTEGR
      L=1
C
C     SET LEADING-ZERO INDICATOR, 'FIRST'
C
      FIRST=.TRUE.
      IF(DEC.LT.0) FIRST=.FALSE.
      DO 190 I=START,STOP
C
C     GET LEADING DIGIT, 'K'
C
      J=J/10
      K=INTGNO/J
      INTGNO=INTGNO-J*K
C
C     DELETE DIGIT IF IT IS AN UNDESIRED LEADING ZERO
C
      IF(K.EQ.0.AND.FIRST) GO TO 180
C
C     CONVERT DIGIT
C
      FIRST=.FALSE.
      RCVR(I)=DIGIT(K+1)
      GO TO 190
  180 L=I
  190 CONTINUE
      GO TO 210
C
C     INSERT ZERO
C
  200 L=STOP
      IF(NOZERO.AND.DEC.GT.0) GO TO 210
      L=L-1
      RCVR(STOP)=ZERO
C
C     CHECK SIGN OF NUMBER
C
  210 IF(NUMBER.LT.0.AND.(INTEGR.GT.0.OR.FRACTN.GT.0)) RCVR(L)=MINUS
C
C     BEGIN CONVERTING FRACTIONAL PART OF NUMBER, 'FRACTN'
C
      IF(DEC.LE.0) GO TO 240
C
C     INSERT DECIMAL POINT
C
      RCVR(STOP+1)=DECIML
C
C     CHECK IF NUMBER IS ZERO
C
      IF(NUMBER.EQ.0) GO TO 230
C
C     SET LIMIT INDICATORS, 'START' @ 'STOP', FOR FRACTIONAL PART OF
C     NUMBER
C
      START=STOP+2
      STOP=WIDE
      J=10**DEC
      DO 220 I=START,STOP
C
C     GET LEADING DIGIT, 'K'
C
      J=J/10
      K=FRACTN/J
      FRACTN=FRACTN-J*K
C
C     CONVERT DIGIT
C
  220 RCVR(I)=DIGIT(K+1)
      GO TO 240
C
C     INSERT ZERO
C
  230 RCVR(STOP+2)=ZERO
C
C     FINISHED
C
  240 RETURN
      END
C * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
      SUBROUTINE SIMUL(NODE,DIA,LENGTH,ELCHNG,ROUGH,LOSSES,DEVICE,RESIST
     1,EXCHNG,ADRESS,PRESS,RHS,MATRIX)
C
C     THIS SUBROUTINE SIMULATES THE FLUID NETWORK
C
C     SPECIFICATIONS
C
      INTEGER ADATE,ADRESS,DATA,DIA,EP1,ENDROW,EQNS,ERRORS,PAGE,PRIME,PR
     1INT,READ,SCRTCH,SEGMTS,SIZE,TAPE,TITLE,UNITS,WORDS
      LOGICAL DONE,NOZERO
      REAL LOSS,LOSSES,MU
      DOUBLE PRECISION ADMIT,COEFF,MATRIX,PRESS,RHS,SAVE,TEMP
      DIMENSION ADATE(18),ADRESS(1),DEVICE(1),DIA(1),ELCHNG(1),EXCHNG(1)
     1,LENGTH(1),LOCATE(18),LOSSES(1),MATRIX(1),NODE(1),PRESS(1),RESIST(
     11),RHS(1),ROUGH(1),TITLE(80,2),WORDS(12)
      COMMON ADATE,BREAK,CONST,CONTOL,CONVSN,DATA,EQNS,ERRORS,FACTOR,LIM
     1IT,LINE,LOCATE,MAXALL,MAXLIN,MU,NODES,NOZERO,PAGE,PATMOS,PRIME,PRI
     2NT,READ,RHO,SCRTCH,SEGMTS,SINTOL,SIZE,TAPE,TAVG,TITLE,UNITS,WORDS
C
C     INITIALIZE PARAMETERS AND CONSTANTS
C
      CONST=48.0*SQRT(14.696*TAVG/(32.174*519.69*RHO))/3.1415926
      CONST1=48.0/(3.1415926*MU)
      CONST2=8.0*1728.0/(9.8696044*32.174*RHO)
      CONST3=2.0*14.696*TAVG*CONST2/519.69
      CONST4=CONST3/6.0
      CONST5=4.0*3.1415926*MU/3.0
      DONE=.FALSE.
      EP1=EQNS+1
      NTRIAL=0
C
C     INITIALIZE PIPE RESISTANCE, 'RESIST(I)'
C
      FACTR=CONST2*CONST5
      DO 100 I=1,SEGMTS
  100 RESIST(I)=FACTR*(LENGTH(I)-1000000*(LENGTH(I)/1000000))/(1.0E-3*IA
     1BS(DIA(I)-100000*(DIA(I)/100000)))**4
C
C
C
C     THIS SECTION CONSTRUCTS THE MATRIX OF NETWORK NODE EQUATIONS
C
C
C
C     CHECK IF MATRIX SOLUTION IS NECESSARY
C
  110 ITERAT=0
  120 ITERAT=ITERAT+1
      IF(EQNS.EQ.0) GO TO 320
C
C     INITIALIZE MATRIX AND RIGHT-HAND-SIDE ELEMENTS, 'MATRIX(I)' @
C     'RHS(I)'
C
      DO 130 I=1,SIZE
  130 MATRIX(I)=0.0
      DO 140 I=1,EQNS
  140 RHS(I)=EXCHNG(I)
C
C     BEGIN MATRIX CONSTRUCTION
C
      DO 230 I=1,SEGMTS
C
C     GET INDICES
C
      K=IABS(NODE(I))
      L=K/1000000
      K=K-1000000*L
      J=K/1000
      K=K-1000*J
      M=IABS(DIA(I)/100000)
C
C     CONSTRUCT NETWORK NODE EQUATIONS
C
      IF(NODE(I).GT.0) GO TO 150
      IF(L.EQ.3) GO TO 230
      IF(J.LE.EQNS) RHS(J)=RHS(J)-DEVICE(L)
      IF(K.LE.EQNS) RHS(K)=RHS(K)+DEVICE(L)
      GO TO 230
  150 ADMIT=1.0D0/ABS(RESIST(I))
      IF(RHO.GT.BREAK) GO TO 160
      COEFF=ADMIT*(ELCHNG(M)*(PRESS(J)+PRESS(K)+ABS(DEVICE(L)))-DEVICE(L
     1))
      GO TO 170
  160 COEFF=ADMIT*(ELCHNG(M)-DEVICE(L))
  170 IF(L.GT.2) GO TO 180
      IF((L-1.5)*(ADMIT*(PRESS(J)-PRESS(K))-COEFF).LT.0.0) GO TO 230
  180 IF(J.GT.EQNS) GO TO 200
      L=ADRESS(J)+J
      MATRIX(L)=MATRIX(L)+ADMIT
      RHS(J)=RHS(J)+COEFF
      IF(K.GT.EQNS) GO TO 190
      IF(J.GT.K) GO TO 210
      L=ADRESS(J)+K
      MATRIX(L)=MATRIX(L)-ADMIT
      GO TO 210
  190 RHS(J)=RHS(J)+ADMIT*PRESS(K)
      GO TO 230
  200 IF(K.GT.EQNS) GO TO 230
  210 L=ADRESS(K)+K
      MATRIX(L)=MATRIX(L)+ADMIT
      RHS(K)=RHS(K)-COEFF
      IF(J.GT.EQNS) GO TO 220
      IF(K.GT.J) GO TO 230
      L=ADRESS(K)+J
      MATRIX(L)=MATRIX(L)-ADMIT
      GO TO 230
  220 RHS(K)=RHS(K)+ADMIT*PRESS(J)
  230 CONTINUE
C
C
C
C     THIS SECTION SOLVES THE SIMULTANEOUS NETWORK NODE EQUATIONS
C
C
C
C     BEGIN MATRIX REDUCTION
C
      DO 280 I=1,EQNS
C
C     SAVE LEADING ROW ELEMENTS
C
      IP1=I+1
      K=ADRESS(I)
      ENDROW=ADRESS(IP1)-K+I
      DO 240 J=I,ENDROW
  240 PRESS(J)=MATRIX(J+K)
C
C     CHECK DIAGONAL ELEMENT IN LEADING ROW, 'PRESS(I)'
C
      IF(DABS(PRESS(I)).LT.SINTOL) GO TO 310
C
C     REDUCE ALL FOLLOWING ROW ELEMENTS
C
      IF(IP1.GT.ENDROW) GO TO 280
      COEFF=1.0D0/PRESS(I)
      TEMP=RHS(I)
      DO 270 J=IP1,ENDROW
      SAVE=COEFF*PRESS(J)
      IF(SAVE) 250,270,250
  250 RHS(J)=RHS(J)-SAVE*TEMP
      L=ADRESS(J)
      DO 260 K=J,ENDROW
  260 MATRIX(K+L)=MATRIX(K+L)-SAVE*PRESS(K)
  270 CONTINUE
  280 CONTINUE
C
C     BEGIN BACK SUBSTITUTION TO SOLVE FOR NODE PRESSURES
C
      DO 300 I=1,EQNS
      L=EP1-I
      SAVE=RHS(L)
      K=L+1
      M=ADRESS(L)
      ENDROW=ADRESS(K)-M+L
      IF(K.GT.ENDROW) GO TO 300
      DO 290 J=K,ENDROW
  290 SAVE=SAVE-PRESS(J)*MATRIX(J+M)
  300 PRESS(L)=SAVE/PRESS(L)
      GO TO 320
C
C     MATRIX IS SINGULAR
C
  310 ERRORS=-ERRORS-1
      GO TO 560
C
C
C
C     THIS SECTION ADJUSTS THE PIPE RESISTANCE
C
C
C
C     CHECK IF CONVERGENCE HAS BEEN ACHIEVED
C
  320 IF(DONE) GO TO 430
      DONE=.TRUE.
      DO 420 I=1,SEGMTS
C
C     GET INDICES
C
      K=IABS(NODE(I))
      L=K/1000000
      K=K-1000000*L
      J=K/1000
      K=K-1000*J
      N=IABS(DIA(I))
      M=N/100000
      DIAM=1.0E-3*(N-100000*M)
      LEN=LENGTH(I)
      N=LEN/1000000
      LEN=LEN-1000000*N
      ABSRES=ABS(RESIST(I))
C
C     CHECK FLUID DENSITY, 'RHO'
C
      IF(RHO.GT.BREAK) GO TO 360
C
C     COMPRESSIBLE FLOW
C
C     CALCULATE INLINE DEVICE PRESSURE CHANGE, 'DELTAP', AND SEGMENT
C     FLOW RATE, 'FLOW'
C
      ELCHG=ELCHNG(M)
      IF(NODE(I).LT.0) GO TO 330
      DELTAP=DEVICE(L)
      FLOW=DABS(PRESS(J)-PRESS(K)-ELCHG*(PRESS(J)+PRESS(K)+ABS(DELTAP))+
     1DELTAP)/ABSRES
      GO TO 340
  330 FLOW=DEVICE(L)
      DELTAP=FLOW*ABSRES-PRESS(J)+PRESS(K)+ELCHG*(PRESS(J)+PRESS(K))
      DELTAP=DELTAP/(1.0-SIGN(ELCHG,DELTAP))
      FLOW=ABS(FLOW)
C
C     CALCULATE FLOW PARAMETERS
C
  340 FACTR=CONST*FLOW/DIAM**2
      PRESSJ=DMAX1(DBLE(FACTR),PRESS(J)+AMAX1(0.0,DELTAP))
      PRESSK=DMAX1(DBLE(FACTR),PRESS(K)-AMIN1(0.0,DELTAP))
      IF(PRESSK.GT.PRESSJ) ELCHG=-ELCHG
      TRIAL=AMIN1(PRESSJ,PRESSK)
      PRESSJ=AMAX1(PRESSJ,PRESSK)
      IF(PRESSJ.LE.0.0) GO TO 420
      PRESSK=TRIAL
      FACTR1=CONST3*LEN*AMAX1(CONST5,FLOW*FRICTN(CONST1*FLOW/DIAM,ROUGH(
     1N)/DIAM)/DIAM)/DIAM**4
      FACTR2=CONST4*FLOW/DIAM**4
C
C     CALCULATE NEW PIPE RESISTANCE, 'RNEW'
C
      TRIAL=ABSRES
  350 RNEW=(FACTR1+FACTR2*ALOG(PRESSJ/PRESSK))/(PRESSJ+PRESSK)
      IF(RNEW*SINTOL.GT.1.0E-2) GO TO 420
      IF(ABS(RNEW-TRIAL)/RNEW.LT.CONTOL.OR.ITERAT.GT.30) GO TO 390
      TRIAL=RNEW
      PRESSJ=AMAX1(FACTR,PRESSK+FLOW*RNEW+ELCHG*(PRESSJ+PRESSK))
      IF(PRESSJ) 390,390,350
C
C     INCOMPRESSIBLE FLOW
C
C     CALCULATE SEGMENT FLOW RATE, 'FLOW'
C
  360 IF(NODE(I).LT.0) GO TO 370
      FLOW=DABS(PRESS(J)-PRESS(K)-ELCHNG(M)+DEVICE(L))/ABSRES
      GO TO 380
  370 FLOW=ABS(DEVICE(L))
C
C     CALCULATE NEW PIPE RESISTANCE, 'RNEW'
C
  380 RNEW=CONST2*LEN*AMAX1(CONST5,FLOW*FRICTN(CONST1*FLOW/DIAM,ROUGH(N)
     1/DIAM)/DIAM)/DIAM**4
C
C     ADJUST PIPE RESISTANCE, 'RESIST(I)'
C
  390 IF(RESIST(I)*(RNEW-ABSRES).LT.0.0) GO TO 400
      RESIST(I)=SIGN(RNEW,RESIST(I))
      GO TO 410
  400 RESIST(I)=SIGN(0.625*RNEW+0.375*ABSRES,RNEW-ABSRES)
C
C     CHECK CONVERGENCE
C
  410 IF(ABS(RNEW-ABSRES)/RNEW.GT.CONTOL) DONE=.FALSE.
  420 CONTINUE
      GO TO 120
C
C
C
C     THIS SECTION SIZES PIPE SEGMENTS
C
C
C
  430 ERRORS=ERRORS+ITERAT-1
C
C     CHECK FOR CYCLING DURING PIPE SIZING
C
      NTRIAL=NTRIAL+1
      IF(NTRIAL.GT.20) GO TO 560
      NLOSS=0
      DO 550 I=1,SEGMTS
C
C     CHECK IF PIPE SEGMENT IS TO BE SIZED
C
      IF(DIA(I).GT.0) GO TO 550
C
C     GET INDICES
C
      K=IABS(NODE(I))
      L=K/1000000
      K=K-1000000*L
      J=K/1000
      K=K-1000*J
      II=IABS(DIA(I))
      M=II/100000
      II=II-100000*M
      DIAM=1.0E-3*II
      LEN=LENGTH(I)
      N=LEN/1000000
      LEN=LEN-1000000*N
      NLOSS=NLOSS+1
      ABSRES=ABS(RESIST(I))
C
C     CALCULATE PRESSURE CHANGE DUE TO FLOW LOSSES, 'LOSS'
C
      IF(NODE(I).LT.0) GO TO 460
      IF(RHO.GT.BREAK) GO TO 440
      LOSS=PRESS(J)-PRESS(K)-ELCHNG(M)*(PRESS(J)+PRESS(K)+ABS(DEVICE(L))
     1)+DEVICE(L    GO TO 450
  440 LOSS=PRESS(J)-PRESS(K)-ELCHNG(M)+DEVICE(L)
  450 IF(L.LT.3.AND.(L-1.5)*LOSS.LE.0.0) GO TO 550
      GO TO 470
  460 IF(L.EQ.3) GO TO 550
      LOSS=ABSRES*DEVICE(L)
  470 LOSS=ABS(LOSS)
C
C     CHECK PRESSURE LOSS
C
      IF(LOSS.LE.0.0.OR.ABS(LOSS-LOSSES(NLOSS))/LOSS.LT.1.0E-2.OR.II.EQ.
     11000.AND.LOSS.LT.LOSSES(NLOSS).OR.II.EQ.99990.AND.LOSS.GT.LOSSES(N
     2LOSS)) GO TO 550
      DONE=.FALSE.
C
C     CALCULATE SEGMENT FLOW RATE, 'FLOW'
C
      FLOW=LOSS/ABSRES
C
C     CHECK FLUID DENSITY, 'RHO'
C
      IF(RHO.GT.BREAK) GO TO 520
C
C     COMPRESSIBLE FLOW
C
C     CALCULATE INLINE DEVICE PRESSURE CHANGE, 'DELTAP'
C
      IF(NODE(I).LT.0) GO TO 480
      DELTAP=DEVICE(L)
      GO TO 490
  480 DELTAP=ABSRES*DEVICE(L)-PRESS(J)+PRESS(K)+ELCHNG(M)*(PRESS(J)+PRES
     1S(K))
      DELTAP=DELTAP/(1.0-SIGN(ELCHNG(M),DELTAP))
C
C     CALCULATE FLOW PARAMETERS
C
  490 PRESSJ=DMAX1(PRESS(J)+AMAX1(0.0,DELTAP),PRESS(K)-AMIN1(0.0,DELTAP)
     1)
      IF(PRESSJ.LE.0.0) GO TO 510
      PRESSK=PRESSJ-LOSSES(NLOSS)
      PAVG=PRESSJ+AMAX1(0.0,PRESSK)
      FACTR1=CONST3*LEN*FLOW**2/(PAVG*LOSSES(NLOSS))
      FACTR2=FACTR1/(6.0*LEN)
      FACTR3=CONST1*FLOW
      FACTR=CONST*FLOW
C
C     CALCULATE NEW PIPE DIAMETER AND RESISTANCE, 'DIAM' @ 'RNEW'
C
  500 TRIAL=DIAM
      DIAM=(FACTR1*FRICTN(FACTR3/TRIAL,ROUGH(N)/TRIAL)/TRIAL+FACTR2*ABS(
     1ALOG(AMAX1(FACTR/TRIAL**2,PRESSK)/PRESSJ)))**0.25
      IF(DIAM.GE.1.0.AND.DIAM.LE.99.99.AND.ABS(DIAM-TRIAL)/DIAM.GT.CONTO
     1L) GO TO 500
      DIAM=AMIN1(99.99,AMAX1(1.0,DIAM))
      RNEW=(CONST3*LEN*AMAX1(CONST5,FLOW*FRICTN(FACTR3/DIAM,ROUGH(N)/DIA
     1M)/DIAM)+CONST4*FLOW*ABS(ALOG(AMAX1(FACTR/DIAM**2,PRESSK)/PRESSJ))
     2)/(PAVG*DIAM**4)
      GO TO 540
  510 TRIAL=DIAM
      DIAM=AMIN1(99.99,AMAX1(1.0,TRIAL*(LOSS/LOSSES(NLOSS))**0.2))
      RNEW=ABSRES*(TRIAL/DIAM)**5
      GO TO 540
C
C     INCOMPRESSIBLE FLOW
C
C     CALCULATE FLOW PARAMETERS
C
  520 FACTR1=CONST2*LEN*FLOW**2/LOSSES(NLOSS)
      FACTR2=CONST1*FLOW
C
C     CALCULATE NEW PIPE DIAMETER AND RESISTANCE, 'DIAM' @ 'RNEW'
C
  530 TRIAL=DIAM
      DIAM=(FACTR1*FRICTN(FACTR2/TRIAL,ROUGH(N)/TRIAL))**0.2
      IF(DIAM.GE.1.0.AND.DIAM.LE.99.99.AND.ABS(DIAM-TRIAL)/DIAM.GT.CONTO
     1L) GO TO 530
      DIAM=AMIN1(99.99,AMAX1(1.0,DIAM))
      RNEW=CONST2*LEN*AMAX1(CONST5,FLOW*FRICTN(FACTR2/DIAM,ROUGH(N)/DIAM
     1)/DIAM)/DIAM**4
C
C     ADJUST PIPE DIAMETER AND RESISTANCE, 'DIA(I)' @ 'RESIST(I)'
C
  540 II=1.0E3*DIAM+0.5
      DIA(I)=-100000*M-MIN0(99990,MAX0(1000,II))
      RESIST(I)=SIGN(RNEW,RNEW-ABSRES)
  550 CONTINUE
C
C     CHECK IF ANY PIPE SEGMENTS REQUIRED ADJUSTMENT
C
      IF(.NOT.DONE) GO TO 110
C
C     FINISHED
C
  560 ERRORS=100*ERRORS+ISIGN(MAX0(0,NTRIAL-1),ERRORS)
      RETURN
      END
C * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
      FUNCTION FRICTN(REYNO,RELRUG)
C
C     THIS FUNCTION WILL CALCULATE THE PIPE FRICTION FACTOR GIVEN THE
C     AVERAGE PIPE REYNOLD'S NUMBER AND RELATIVE PIPE RUGOSITY (RUGOSITY
C     DIVIDED BY PIPE RADIUS).  THIS FUNCTION USES THE 'POISSEUILLE' AND
C     'COLEBROOK-WHITE' EQUATIONS WHICH WERE USED BY L. F. MOODY IN
C     PLOTTING HIS WELL KNOWN 'STANTON' DIAGRAM.  IN THE 'CRITICAL'
C     REGION (2000 < 'REYNO' < 4000), A WEIGHTED FRICTION FACTOR IS
C     CALCULATED.
C
C
C     CHECK WHICH EQUATION SHOULD BE USED
C
      IF(REYNO.GT.2000.0) GO TO 100
C
C     THE 'POISSEUILLE' EQUATION WILL BE USED
C
      FRICTN=64.0/AMAX1(1.0E-20,REYNO)
      GO TO 120
C
C     THE 'COLEBROOK-WHITE' EQUATION WILL BE USED
C
C     INITIALIZE PARAMETERS
C
  100 FACTOR=16.0/AMAX1(4000.0,REYNO)
      CALC=2.0/SQRT(0.0165*(1.0+(1.0E4*RELRUG+6.25E4*FACTOR)**0.333333))
C
C     SET NEW TRIAL PARAMETER VALUE
C
  110 TRIAL=CALC
C
C     CALCULATE IMPROVED PARAMETER VALUE
C
      CALC=2.0-ALOG(FACTOR*TRIAL+RELRUG)
C
C     CHECK FOR CONVERGENCE
C
      IF(ABS(TRIAL-CALC)/CALC.GT.1.0E-4) GO TO 110
C
C     CALCULATE THE FRICTION FACTOR FROM THE 'COLEBROOK-WHITE' EQUATION
C
      FRICTN=4.0/(3.0*CALC**2)
C
C     CHECK IF REYNOLD'S NUMBER IS IN 'CRITICAL' REGION
C
      IF(REYNO.LT.4000.0) FRICTN=0.032+5.0E-4*(FRICTN-0.032)*(REYNO-2000
     1.0)
C
C     FINISHED
C
  120 RETURN
      END
C * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
      SUBROUTINE HANDLR
C
C     THIS SUBROUTINE HANDLES THE INPUT DATA AND COMMANDS
C
C     SPECIFICATIONS
C
      INTEGER ADATE,BLANK,CARD,CMND,COMAND,COMND,CONTRL,DATA,DOLLAR,EQNS
     1,ERRORS,PAGE,PRIME,PRINT,READ,RECORD,SAVE,SCRTCH,SEGMTS,SIZE,TAPE,
     2TITLE,UNITS,WORDS
      LOGICAL LOADED,NOZERO,SECOND
      REAL MU
      DIMENSION ADATE(18),CARD(20),COMAND(7),IMAGE(20),LOCATE(18),NAME(2
     1,3),NAMES(2,2),NAME1(2),NAME2(2),SAVE(2),TEMP1(80),TEMP2(121),TITL
     2E(80,2),WORDS(12)
      COMMON ADATE,BREAK,CONST,CONTOL,CONVSN,DATA,EQNS,ERRORS,FACTOR,LIM
     1IT,LINE,LOCATE,MAXALL,MAXLIN,MU,NODES,NOZERO,PAGE,PATMOS,PRIME,PRI
     2NT,READ,RHO,SCRTCH,SEGMTS,SINTOL,SIZE,TAPE,TAVG,TITLE,UNITS,WORDS
      EQUIVALENCE (CARD,COMND),(NAMES,NAME1),(NAMES(1,2),NAME2)
      DATA BLANK,DOLLAR,MINUS/' ','$','-'/,COMAND/'$END','$CAR','$TAP','
     1$MOD','$CHA','$SAV','$SIM'/,NAME/'$TIT','LE1','$TIT','LE2','$PAR',
     2'AM'/
      DATA NO/'N'/
C
C     FORMATS
C
    1 FORMAT(20A4)
    3 FORMAT(' ** UNRECOGNIZABLE COMMAND',/)
    4 FORMAT(' ** SUPPRESSED',/)
    6 FORMAT(' ** INVALID IN CURRENT COMMAND MODE',/)
    7 FORMAT(' ** INVALID SEGMENT NAME',/)
    8 FORMAT(' ** IGNORED',/)
    9 FORMAT(' ** UNEXPECTED END-OF-FILE ENCOUNTERED ON INPUT - RUN ABOR
     1TED',/)
   10 FORMAT(' ** UNREADABLE INPUT - RE-ENTER DATA',/)
   11 FORMAT(' ** INVALID CONTROL CARD',/)
   12 FORMAT(20A4/121A1,T5,2A4)
   13 FORMAT(' ** INVALID SEQUENCE',/)
   14 FORMAT(' ** UNABLE TO FIND ''',2A4,'''',/)
   15 FORMAT(I5,' RECORDS INPUT',/)
   16 FORMAT(I5,' RECORDS OUTPUT',/)
   17 FORMAT(' ** UNREADABLE RECORD ENCOUNTERED - RUN ABORTED',/)
   18 FORMAT(' OK?',$)
   19 FORMAT(A1)
   20 FORMAT(' RE-ENTER INPUT RECORD',/)
   21 FORMAT(20A4/121A1)
   22 FORMAT(T5,2A4)
   23 FORMAT(' READY',//)
C
C
C
C     THIS SECTION READS THE COMMAND AND CONTROL CARDS
C
C
C
C     INITIALIZATION
C
      CMND=1
      ERRORS=0
      LINE=MAXLIN
      LOADED=.FALSE.
C
C     READ A CARD
C
  100 TYPE 23
      READ(READ,1,END=220,ERR=230) CARD
      REREAD 50,TEMP1
   50 FORMAT(80A1)
      REREAD 51,CONTRL
   51 FORMAT(A1)
      REREAD 52,NAMES
   52 FORMAT(2(2A4))
      REREAD 53,NAMCHK
   53 FORMAT(T5,A1)
C
C     REQUEST VERIFICATION OF CORRECTNESS OF INPUT RECORD
C
      WRITE(PRINT,18)
      READ(READ,19,END=220,ERR=230) I
      IF(I.NE.NO) GO TO 105
      WRITE(PRINT,20)
      GO TO 100
C
C     CHECK FOR COMMAND
C
  105 IF(CONTRL.NE.DOLLAR) GO TO 150
C
C     CHECK DISPOSITION OF LAST COMMAND
C
      IF(ERRORS.EQ.0) GO TO (110,680,110,670,670,110,110),CMND
C
C     CHECK COMMAND VALIDITY
C
  110 DO 120 CMND=1,7
      IF(COMND.EQ.COMAND(CMND)) GO TO 130
  120 CONTINUE
C
C     UNRECOGNIZABLE COMMAND
C
      CMND=1
      ERRORS=1
      WRITE(PRINT,3)
      GO TO 100
C
C     CHECK COMMAND ACCEPTANCE
C
  130 IF(ERRORS.EQ.0.OR.CMND.LT.4) GO TO 140
C
C     COMMAND SUPPRESSED
C
      WRITE(PRINT,4)
      GO TO 100
C
C     CHECK COMMAND DISPOSITION
C
  140 GO TO (810,240,260,280,280,730,760),CMND
C
C     CHECK CONTROL OR DATA CARD ACCEPTANCE
C
  150 IF(ERRORS.GT.0) GO TO 170
C
C     CHECK CARD DISPOSITION
C
      GO TO (170,160,170,300,300,170,170),CMND
  160 IF(CONTRL.NE.MINUS) GO TO 250
C
C     CARD IGNORED OR REJECTED
C
  170 IF(ERRORS.GT.0) GO TO 210
      ERRORS=1
      IF(NAMCHK.EQ.DOLLAR) GO TO 200
      WRITE(PRINT,6)
      GO TO 100
  200 WRITE(PRINT,7)
      GO TO 100
  210 WRITE(PRINT,8)
      GO TO 100
C
C     UNEXPECTED END-OF-FILE ENCOUNTERED - ABORT RUN
C
  220 WRITE(PRINT,9)
      GO TO 810
C
C     UNREADABLE INPUT RECORD ENCOUNTERED - RE-TRY INPUT ENTRY
C
  230 WRITE(PRINT,10)
      GO TO 100
C
C
C
C     THIS SECTION HANDLES THE '$CARD' COMMAND
C
C
C
C     INITIALIZATION
C
  240 ERRORS=0
      LOADED=.FALSE.
      NUMBER=0
      POSITION(16,1)
      POSITION(17,1)
      GO TO 100
C
C     TRANSFER INPUT DATA TO DATA AND SCRATCH FILES
C
  250 NUMBER=NUMBER+1
      IF(NUMBER-3) 251,252,253
  251 WRITE(DATA,12) CARD,TEMP1
      WRITE(SCRTCH,12) CARD,TEMP1
      GO TO 100
  252 CALL REFMTP(TEMP1,TEMP2,$100)
      WRITE(DATA,12) CARD,TEMP2
      WRITE(SCRTCH,12) CARD,TEMP2
      GO TO 100
  253 CALL REFMTD(TEMP1,TEMP2,NAMCHK,$100)
      IF(NAMCHK.EQ.DOLLAR) GO TO 170
      WRITE(DATA,12) CARD,TEMP2
      WRITE(SCRTCH,12) CARD,TEMP2
      GO TO 100
C
C
C
C     THIS SECTION HANDLES THE '$TAPE' COMMAND
C
C
C
C     INITIALIZATION
C
  260 ERRORS=0
      LOADED=.FALSE.
      NUMBER=0
      CLOSE(16)
      OPEN(16,'DATA.TMP',OUTPUT)
      CLOSE(16)
      OPEN(16,'DATA.TMP',RANDIO)
      POSITION(16,1)
      CLOSE(17)
      OPEN(17,'SCR.TMP',OUTPUT)
      CLOSE(17)
      OPEN(17,'SCR.TMP',RANDIO)
      POSITION(17,1)
      CLOSE(1)
      OPEN(1,'TAPE',RANDIO)
      POSITION(1,1)
C
C     READ A RECORD
C
  270 READ(TAPE,21,END=680,ERR=800) IMAGE,TEMP2
C
C     TRANSFER INPUT DATA TO DATA AND SCRATCH FILES
C
      NUMBER=NUMBER+1
      WRITE(DATA,21) IMAGE,TEMP2
      WRITE(SCRTCH,21) IMAGE,TEMP2
      GO TO 270
C
C
C
C     THIS SECTION HANDLES THE '$MODIFY' AND '$CHANGE' COMMANDS
C
C
C
C     INITIALIZATION
C
  280 LOADED=.FALSE.
      NIN = 0
      NUMBER=0
      RECORD=0
      DO 290 I=1,2
  290 SAVE(I)=0
      POSITION(16,1)
      POSITION(17,1)
      GO TO 100
C
C     CHECK FOR CONTROL CARD
C
  300 IF(CONTRL.EQ.MINUS) GO TO 330
C
C     TRANSFER INPUT DATA TO SCRATCH FILE
C
      NUMBER=NUMBER+1
      IF(NUMBER-3) 321,322,323
  321 WRITE(SCRTCH,21) CARD,TEMP1
      GO TO 100
  322 CALL REFMTP(TEMP1,TEMP2,$100)
      WRITE(SCRTCH,21) CARD,TEMP2
      GO TO 100
  323 CALL REFMTD(TEMP1,TEMP2,NAMCHK,$100)
      IF(NAMCHK.EQ.DOLLAR) GO TO 170
      WRITE(SCRTCH,21) CARD,TEMP2
      GO TO 100
C
C     CHECK FOR FIRST SEGMENT NAME
C
  330 CALL REFMTC(TEMP1,NAMES)
      DO 340 I=1,2
      IF(NAME1(I).NE.BLANK) GO TO 350
  340 CONTINUE
C
C     INVALID CONTROL CARD
C
      ERRORS=1
      WRITE(PRINT,11)
      GO TO 100
C
C     CHECK FOR SECOND SEGMENT NAME
C
  350 SECOND=.TRUE.
      DO 360 I=1,2
      IF(NAME2(I).NE.BLANK) GO TO 370
  360 CONTINUE
      SECOND=.FALSE.
C
C     CHECK IF FIRST NAME IS '$TITLE1', '$TITLE2', OR'$PARAM'
C
  370 N=1
      DO 390 J=1,3
      DO 380 I=1,2
      IF(NAME1(I).NE.NAME(I,J)) GO TO 390
  380 CONTINUE
      GO TO 470
  390 CONTINUE
C
C     FIRST NAME IS SEGMENT NAME
C
      IF(RECORD-3) 400,420,430
  400 I=RECORD+1
      DO 410 RECORD=I,3
      NIN=NIN+1
      READ(DATA,21,END=660,ERR=800) IMAGE,TEMP2
      WRITE(SCRTCH,21) IMAGE,TEMP2
  410 NUMBER=NUMBER+1
  420 RECORD=4
  430 NIN=NIN+1
      READ(DATA,21,END=660,ERR=800) IMAGE,TEMP2
      I = (205*NIN)-123
      POSITION(16,I)
      READ(DATA,22)SAVE
      DO 440 I=1,2
      IF(SAVE(I).NE.NAME1(I)) GO TO 450
  440 CONTINUE
      GO TO 460
  450 WRITE(SCRTCH,21) IMAGE,TEMP2
      NUMBER=NUMBER+1
      GO TO 430
  460 IF(SECOND) GO TO 530
      WRITE(SCRTCH,21) IMAGE,TEMP2
      NUMBER=NUMBER+1
      GO TO 100
C
C     FIRST NAME IS '$TITLE1', '$TITLE2', OR '$PARAM'
C
  470 IF(SECOND) GO TO 480
      IF(RECORD-J) 500,100,650
  480 IF(RECORD-J+1) 490,520,650
  490 J=J-1
  500 I=RECORD+1
      DO 510 RECORD=I,J
      NIN=NIN+1
      READ(DATA,21,END=660,ERR=800) IMAGE,TEMP2
      WRITE(SCRTCH,21) IMAGE,TEMP2
  510 NUMBER=NUMBER+1
      RECORD=J
      IF(.NOT.SECOND) GO TO 100
  520 RECORD=RECORD+1
      NIN=NIN+1
      READ(DATA,21,END=660,ERR=800) IMAGE,TEMP2
C
C     CHECK IF SECOND NAME IS '$TITLE1', '$TITLE2', OR '$PARAM'
C
  530 N=2
      DO 550 J=1,3
      DO 540 I=1,2
      IF(NAME2(I).NE.NAME(I,J)) GO TO 550
  540 CONTINUE
      GO TO 620
  550 CONTINUE
C
C     SECOND NAME IS SEGMENT NAME
C
      IF(RECORD-3) 560,580,600
  560 I=RECORD+1
      DO 570 RECORD=I,3
      NIN=NIN+1
  570 READ(DATA,21,END=660,ERR=800) IMAGE,TEMP2
  580 RECORD=4
  590 NIN=NIN+1
      READ(DATA,21,END=660,ERR=800) IMAGE,TEMP2
      I=(205*NIN)-123
      POSITION(16,I)
      READ(DATA,22)SAVE
  600 DO 610 I=1,2
      IF(SAVE(I).NE.NAME2(I)) GO TO 590
  610 CONTINUE
      GO TO 100
C
C     SECOND NAME IS '$TITLE1', '$TITLE2', OR '$PARAM'
C
  620 IF(RECORD-J) 630,100,650
  630 I=RECORD+1
      DO 640 RECORD=I,J
      NIN=NIN+1
  640 READ(DATA,21,END=660,ERR=660) IMAGE,TEMP2
      RECORD=J
      GO TO 100
C
C     INVALID SEQUENCE
C
  650 ERRORS=1
      WRITE(PRINT,13)
      GO TO 100
C
C     UNEXPECTED END-OF-FILE ENCOUNTERED
C
  660 ERRORS=1
      WRITE(PRINT,14) (NAMES(I,N),I=1,2)
      GO TO 100
C
C     FINISH READING DATA FILE
C
  670 NIN=NIN+1
      READ(DATA,21,END=680,ERR=800) IMAGE,TEMP2
      WRITE(SCRTCH,21) IMAGE,TEMP2
      GO TO 670
C
C     CLOSE DATA AND SCRATCH FILES
C
  680 CONTINUE
      IF(CMND-4) 710,720,690
  690 POSITION(16,1)
      POSITION(17,1)
  700 READ(SCRTCH,21,END=710,ERR=800) IMAGE,TEMP2
      WRITE(DATA,21) IMAGE,TEMP2
      GO TO 700
  710 CONTINUE
      IF(CMND.GT.3) GO TO 720
      WRITE(PRINT,15) NUMBER
  720 LOADED=.TRUE.
      IF(CMND-3) 110,100,110
C
C
C
C     THIS SECTION HANDLES THE '$SAVE' COMMAND
C
C
C
C     INITIALIZATION
C
  730 IF(.NOT.LOADED) GO TO 770
      NUMBER=0
      CLOSE(1)
      OPEN(1,'TAPE',OUTPUT)
      CLOSE(1)
      OPEN(1,'TAPE',RANDIO)
      POSITION(17,1)
      POSITION(1,1)
C
C     TRANSFER DATA FROM SCRATCH FILE TO TAPE FILE
C
  740 READ(SCRTCH,21,END=750,ERR=800) IMAGE,TEMP2
      NUMBER=NUMBER+1
      WRITE(TAPE,21) IMAGE,TEMP2
      GO TO 740
C
C     CLOSE TAPE FILE
C
  750 CONTINUE
      WRITE(PRINT,16) NUMBER
      GO TO 100
C
C
C
C     THIS SECTION HANDLES THE '$SIMULATE' COMMAND
C
C
C
C     INITIALIZATION
C
  760 IF(LOADED) GO TO 820
C
C     TRANSFER DATA FROM DATA FILE TO SCRATCH FILE
C
  770 POSITION(16,1)
      CLOSE(17)
      OPEN(17,'SCR.TMP',OUTPUT)
      CLOSE(17)
      OPEN(17,'SCR.TMP',RANDIO)
      POSITION(17,1)
  780 READ(DATA,21,END=790,ERR=800) IMAGE,TEMP2
      WRITE(SCRTCH,21) IMAGE,TEMP2
      GO TO 780
C
C     CLOSE SCRATCH FILE
C
  790 CONTINUE
      LOADED=.TRUE.
      GO TO 140
C
C     UNREADABLE RECORD ENCOUNTERED - ABORT RUN
C
  800 WRITE(PRINT,17)
C
C     FINISHED
C
  810 ERRORS=1
  820 RETURN
      END
C * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C
      SUBROUTINE REFMTC(IMAGE,NAMES)
C
C     THIS SUBROUTINE REFORMATS TELETYPE INPUT UPDATE-DIRECTIVE RECORDS
C     INTO COMPATIBLE 'PUNCHED-CARD IMAGE' RECORDS
C
C
C
C     SPECIFICATIONS
C
      IMPLICIT INTEGER (A-Z)
      LOGICAL FIRST
      DIMENSION IMAGE(80),NAMES(2,2),RECORD(80)
      DATA BLANK,COMMA,SCRTCH/' ',',',29/
C
C     FORMATS
C
    1 FORMAT(80A1)
    2 FORMAT(4A4)
C     OPEN SCRMTC.TMP FOR SCRATCH FILE USE IN THIS ROUTINE
      OPEN(18,'SCRMTC.TMP',RANDIO)
C
C     REFORMAT INPUT RECORD TO CONFORM TO 'PUNCHED-CARD' INPUT
C
      DO 100 I=1,80
  100 RECORD(I)=BLANK
      FIRST=.TRUE.
      J=0
      DO 120 I=2,80
      IF(IMAGE(I).NE.COMMA) GO TO 110
      IF(FIRST) J=8
      FIRST=.FALSE.
      GO TO 120
  110 IF(J.EQ.80) GO TO 130
      J=J+1
      RECORD(J)=IMAGE(I)
  120 CONTINUE
C
C     TRANSFER REFORMATTED RECORD
C
  130 POSITION(18,1)
      WRITE(18,1) RECORD
      POSITION(18,1)
      READ(18,2) NAMES
C
C     FINISHED
C
      RETURN
      END
C * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C
      SUBROUTINE REFMTP(IMAGE,RECORD,$)
C
C     THIS SUBROUTINE REFORMATS A TELETYPE INPUT PARAMETER-CARD RECORD
C     INTO A COMPATIBLE 'PUNCHED-CARD IMAGE' RECORD
C
C
C
C     SPECIFICATIONS
C
      IMPLICIT INTEGER (A-Z)
      DIMENSION IMAGE(80),POINT(6),RECORD(121)
      DATA BLANK,COMMA,PRINT/' ',',',5/
      DATA POINT/1,11,21,31,41,51/
C
C     FORMAT
C
    1 FORMAT(' ** DATA FIELD NUMBER',I2,' IS TOO LONG - RE-ENTER PARAMET
     1ER CARD')
C
C     SEPARATE CONSTITUENT DATA FIELDS
C
      DO 100 I=1,121
  100 RECORD(I)=BLANK
      J=1
      K=POINT(J)
      L=POINT(J+1)-1
      DO 120 I=1,80
      IF(IMAGE(I).NE.COMMA) GO TO 110
      IF(J.EQ.5) GO TO 130
      J=J+1
      K=POINT(J)
      L=POINT(J+1)-1
      GO TO 120
  110 IF(K.GT.L) GO TO 115
      RECORD(K)=IMAGE(I)
      K=K+1
      GO TO 120
  115 IF(IMAGE(I).NE.BLANK) GO TO 180
  120 CONTINUE
C
C     RIGHT-JUSTIFY DATA FIELDS
C
  130 DO 170 I=1,5
      K=POINT(I)
      L=POINT(I+1)-1
      M=L
      DO 140 J=K,L
      IF(RECORD(J).NE.BLANK) M=J
  140 CONTINUE
      IF(M.EQ.L) GO TO 170
      DO 150 J=K,M
  150 RECORD(K+L-J)=RECORD(K+M-J)
      M=K+L-M-1
      DO 160 J=K,M
  160 RECORD(J)=BLANK
  170 CONTINUE
C
C     FINISHED - NORMAL RETURN
C
      RETURN
C
C     DATA FIELD TOO LONG - RE-TRY INPUT RECORD ENTRY
C
  180 WRITE(PRINT,1) J
      RETURN 3
      END
C * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C
      SUBROUTINE REFMTD(IMAGE,RECORD,NAMCHK,$)
C
C     THIS SUBROUTINE REFORMATS TELETYPE INPUT SEGMENT-DATA RECORDS INTO
C     COMPATIBLE 'PUNCHED-CARD IMAGE' RECORDS
C
C
C
C     SPECIFICATIONS
C
      IMPLICIT INTEGER (A-Z)
      DIMENSION IMAGE(80),INDIC(15),RECORD(121),START(15),STOP(15)
      DATA BLANK,COMMA,PRINT/' ',',',5/
      DATA INDIC/0,0,0,1,0,0,1,0,1,1,1,1,1,1,0/
      DATA START/1,5,13,21,31,32,40,50,51,61,71,81,96,111,121/
      DATA STOP/4,12,20,29,31,39,48,50,58,70,79,90,105,119,121/
C
C     FORMAT
C
    1 FORMAT(' ** DATA FIELD NUMBER',I3,' IS TOO LONG - RE-ENTER DATA CA
     1RD')
C
C     SEPARATE THE DATA FIELDS
C
      DO 100 I=1,121
  100 RECORD(I)=BLANK
      J=1
      K=START(J)
      L=STOP(J)
      DO 120 I=1,80
      IF(IMAGE(I).NE.COMMA) GO TO 110
      IF(J.EQ.15) GO TO 130
      J=J+1
      K=START(J)
      L=STOP(J)
      GO TO 120
  110 IF(K.GT.L) GO TO 115
      RECORD(K)=IMAGE(I)
      K=K+1
      GO TO 120
  115 IF(IMAGE(I).NE.BLANK) GO TO 180
  120 CONTINUE
  130 NAMCHK=RECORD(5)
C
C     RIGHT-JUSTIFY NUMERIC FIELDS
C
      DO 170 I=1,15
      IF(INDIC(I).EQ.0) GO TO 170
      K=START(I)
      L=STOP(I)
      M=L
      DO 140 J=K,L
      IF(RECORD(J).NE.BLANK) M=J
  140 CONTINUE
      IF(M.EQ.L) GO TO 170
      DO 150 J=K,M
  150 RECORD(K+L-J)=RECORD(K+M-J)
      M=K+L-M-1
      DO 160 J=K,M
  160 RECORD(J)=BLANK
  170 CONTINUE
C
C     FINISHED - NORMAL RETURN
C
      RETURN
C
C     DATA FIELD TOO LONG - RE-TRY INPUT RECORD ENTRY
C
  180 WRITE(PRINT,1) J
      RETURN 4
      END
C * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
      SUBROUTINE INPUT(DSTORE,ISTORE,STORE,NAMES,SNAME,TABLE,NAME,NODEA,
     1NODEB,NUM,START,END,TYPES,DIA,LENGTH,ELCHNG,ROUGH,GRAD,DEVICE,FLAG
     2,EXCHNG,PRESS,NODENO,INDEX,NODE)
C
C     THIS SUBROUTINE READS, CHECKS, LISTS, AND CONVERTS THE INPUT DATA
C
C     SPECIFICATIONS
C
      INTEGER AB,ADATE,BLANK,CARD,DATA,END,EQNS,ERRORS,FLAG,FLAGS,HEADER
     1,PAGE,PLUS,PRIME,PRINT,READ,SCRTCH,SEGMTS,SEGNO,SIZE,SNAME,START,T
     2APE,TABLE,TEST,TEST01,TEST02,TEST03,TEST04,TEST05,TEST06,TEST07,TE
     3ST08,TEST09,TEST10,TEST11,TEST12,TEST13,TEST14,TEST15,TEST16,TITLE
     4,TYP,TYPE,TYPES,UNITS,WIDE,WIDTH,WORDS,WORD01,WORD02,WORD03,WORD04
     5,WORD05,WORD06,WORD07,WORD08,WORD09,WORD10,WORD11,WORD12,YES
      LOGICAL NOZERO
      REAL MU
      DOUBLE PRECISION DSTORE
      DIMENSION AB(2),ADATE(18),CARD(20),DEVICE(1),DIA(1),DSTORE(1),ELCH
     1NG(1),END(1),EXCHNG(1),FLAG(1),FLAGS(2),GRAD(1),HEADER(80),INDEX(1
     2),ISTORE(1),LENGTH(1),LOCATE(18),NAME(2,2,1),NAMES(2,1),NODE(2,1),
     3NODEA(1),NODEB(1),NODENO(1),NUM(1),PRESS(1),ROUGH(1),SNAME(2,1),ST
     4ART(1),STORE(1),TABLE(1),TEST(16),TITLE(80,2),TYPES(1),VALUE(2),WO
     5RDS(12)
      COMMON ADATE,BREAK,CONST,CONTOL,CONVSN,DATA,EQNS,ERRORS,FACTOR,LIM
     1IT,LINE,LOCATE,MAXALL,MAXLIN,MU,NODES,NOZERO,PAGE,PATMOS,PRIME,PRI
     2NT,READ,RHO,SCRTCH,SEGMTS,SINTOL,SIZE,TAPE,TAVG,TITLE,UNITS,WORDS
      EQUIVALENCE (CARD,HEADER),(TEST,TEST01),(TEST(2),TEST02),(TEST(3),
     1TEST03),(TEST(4),TEST04),(TEST(5),TEST05),(TEST(6),TEST06),(TEST(7
     2),TEST07),(TEST(8),TEST08),(TEST(9),TEST09),(TEST(10),TEST10),(TES
     3T(11),TEST11),(TEST(12),TEST12),(TEST(13),TEST13),(TEST(14),TEST14
     4),(TEST(15),TEST15),(TEST(16),TEST16),(WORDS,WORD01),(WORDS(2),WOR
     5D02),(WORDS(3),WORD03),(WORDS(4),WORD04),(WORDS(5),WORD05),(WORDS(
     66),WORD06),(WORDS(7),WORD07),(WORDS(8),WORD08),(WORDS(9),WORD09),(
     7WORDS(10),WORD10),(WORDS(11),WORD11),(WORDS(12),WORD12)
      DATA AB,BLANK,MINUS,PLUS,YES/'A','B',' ','-','+','Y'/
C
C     FORMATS
C
    1 FORMAT(80A1)
    2 FORMAT(' ** END-OF-FILE ENCOUNTERED IN READING TITLE CARD',/)
    3 FORMAT(20A4/5F10.0)
    4 FORMAT(' ** END-OF-FILE ENCOUNTERED IN READING PARAMETER CARD',/)
    5 FORMAT(' ** FORMAT ERROR ENCOUNTERED IN READING PARAMETER CARD'/)
    6 FORMAT(' ** INVALID ENTRY FOR FLOW RATE UNITS'' INDICATOR'/)
    7 FORMAT(' ** INVALID ENTRY FOR LOCAL ATMOSPHERIC PRESSURE'/)
    8 FORMAT(' ** INVALID ENTRY FOR AVERAGE FLUID TEMPERATURE'/)
    9 FORMAT(' ** INVALID ENTRY FOR FLUID DENSITY'/)
   10 FORMAT(' ** INVALID ENTRY FOR FLOW RATE UNITS'' INDICATOR FOR GAS'
     1/)
   11 FORMAT(' ** INVALID ENTRY FOR FLOW RATE UNITS'' INDICATOR FOR LIQU
     1ID'/)
   12 FORMAT(' ** INVALID ENTRY FOR FLUID VISCOSITY'/)
   13 FORMAT(////' ***** REFERENCE DATA *****'/' '/' LOCAL ATMOSPHERIC P
     1RESSURE',21('.'),F5.1,' PSIA'/' AVERAGE FLUID TEMPERATURE',20('.')
     2,F7.1,' DEG. F'/' FLUID DENSITY @ 60 DEG. F @ 14.696 PSIA',9('.'),
     31PE9.3,' LB/CU.FT.'/' FLUID VISCOSITY @ AVERAGE FLUID TEMPERATURE'
     4,5('.'),E9.3,' LB/FT-HR')
   14 FORMAT(////' ***** REFERENCE DATA *****'/' '/' LOCAL ATMOSPHERIC P
     1RESSURE',21('.'),F5.1,' PSIA'/' AVERAGE FLUID TEMPERATURE',20('.')
     2,F7.1,' DEG. F'/' FLUID DENSITY @ AVERAGE FLUID TEMPERATURE',7('.'
     3),1PE9.3,' LB/CU.FT.'/' FLUID VISCOSITY @ AVERAGE FLUID TEMPERATUR
     4E',5('.'),E9.3,' LB/FT-HR')
   15 FORMAT(20A4/3A4,2(2A4,F10.1,A1),F10.2,F10.0,F10.1,2F15.5,F10.1)
   42 FORMAT(12X,2(10X,2A4,1X),6X,A4,2(2X,2A4),2(7X,2A4),2X,2A4,A1)
   41 FORMAT(10X,2(2X,2A4))
   16 FORMAT(' ** FORMAT ERROR ENCOUNTERED ON FOLLOWING CARD'/1X,20A4)
   17 FORMAT(' ** MORE THAN',I4,' PIPE SEGMENTS'/)
   18 FORMAT(' ** MISSING NAME FOR NODE ''',A1,''''/)
   19 FORMAT(' ** MORE THAN',I4,' NODES'/)
   20 FORMAT(' ** INVALID ENTRY FOR PRESSURE AT NODE ''',A1,''''/)
   21 FORMAT(' ** PRESSURE @ EXCHANGE RATE AT NODE ''',A1,''' MAY NOT BO
     1TH BE SPECIFIED'/)
   22 FORMAT(' ** PRESSURE AT NODE ''',A1,''' DIFFERS FROM VALUE PREVIOU
     1SLY SPECIFIED'/)
   23 FORMAT(' ** EXCHANGE RATE AT NODE ''',A1,''' DIFFERS FROM VALUE PR
     1EVIOUSLY SPECIFIED'/)
   24 FORMAT(' ** NODE ''A'' SAME AS NODE ''B'''/)
   25 FORMAT(' ** INVALID ENTRY FOR PIPE DIAMETER')
   26 FORMAT(' ** INVALID ENTRY FOR PIPE LENGTH')
   27 FORMAT(' ** INVALID ENTRY FOR PIPE RUGOSITY')
   28 FORMAT(' ** INVALID ENTRY FOR DESIGN GRADIENT')
   29 FORMAT(' ',20A4)
   30 FORMAT(//' **',I5,' ERROR(S)')
   31 FORMAT(//' ** NO SEGMENT DATA FOUND IN INPUT')
   32 FORMAT(//' ** NO NODE PRESSURES WERE SPECIFIED')
   33 FORMAT(20A4)
   34 FORMAT(////' ** THE FOLLOWING NODES HAVE ELEVATION CONFLICTS'/' '/
     1(1X,2A4,1X,2A4,1X,2A4,1X,2A4,1X,2A4,1X,2A4,1X,2A4,1X,2A4,1X,2A4,1X
     2,2A4,1X,2A4,1X,2A4,1X,2A4,1X,2A4))
   35 FORMAT(////' ** THIS NETWORK IS DISCONNECTED'/' '/' SECTION ''A'':
     1  CONNECTED NODES'/(1X,2A4,1X,2A4,1X,2A4,1X,2A4,1X,2A4,1X,2A4,1X,2
     2A4,1X,2A4,1X,2A4,1X,2A4,1X,2A4,1X,2A4,1X,2A4,1X,2A4))
   36 FORMAT(//' SECTION ''B'':  DISCONNECTED NODES'/' '/(1X,2A4,1X,2A4,
     11X,2A4,1X,2A4,1X,2A4,1X,2A4,1X,2A4,1X,2A4,1X,2A4,1X,2A4,1X,2A4,1X,
     22A4,1X,2A4,1X,2A4))
   37 FORMAT(////' ** REQUIRED ALLOCATION EXCEEDS AVAILABLE CORE STORAGE
     1'/' ** OVERFLOW:',I8,' WORDS')
   38 FORMAT(' LIST INPUT DATA?',$)
   39 FORMAT(////' ***** INPUT DATA IMAGES *****'/' ')
   40 FORMAT(///(71A1))
C
C     CHECK IF USER WANTS LISTING OF INPUT DATA
C
      WRITE(PRINT,38)
      READ(READ,1) LIST
C
C
C
C     THIS SECTION READS THE TITLE CARDS
C
C
C
C     REWIND SCRATCH FILE, 'SCRTCH'
C
      POSITION(17,1)
C
C     READ TITLE CARD
C
      DO 110 I=1,2
      READ(SCRTCH,1,END=100) (TITLE(J,I),J=1,80),J
      GO TO 110
C
C     END-OF-FILE ENCOUNTERED
C
  100 WRITE(PRINT,2)
      GO TO 1180
  110 CONTINUE
      WRITE(PRINT,40) (BLANK,(TITLE(J,I),J=1,70),I=1,2)
C
C
C
C     THIS SECTION READS THE PARAMETER CARD AND CHECKS IT FOR ERRORS
C
C
C
C     READ PARAMETER CARD
C
      READ(SCRTCH,3,END=150,ERR=160) CARD,X,PATMOS,TBAR,RHO,VISCOS
      I = 493
      POSITION(17,I)
      READ(17,41,END=150,ERR=160)(TEST(I),I=1,4)
      UNITS=X+0.5
      GO TO 170
C
C     END-OF-FILE ENCOUNTERED
C
  150 WRITE(PRINT,4)
      GO TO 1180
C
C     FORMAT ERROR ENCOUNTERED
C
  160 WRITE(PRINT,5)
      GO TO 1180
C
C     INITIALIZE ERROR INDICATOR, 'ERRORS'
C
  170 ERRORS=0
C
C     SET AND CHECK FLOW RATE UNITS, 'UNITS'
C
      UNITS=UNITS+1
      IF(0.LT.UNITS.AND.UNITS.LT.6) GO TO 180
      ERRORS=1
      WRITE(PRINT,6)
C
C     SET AND CHECK LOCAL ATMOSPHERIC PRESSURE, 'PATMOS'
C
  180 IF(TEST01.EQ.BLANK.AND.TEST02.EQ.BLANK) PATMOS=14.696
      IF(PATMOS.GT.0.0) GO TO 190
      ERRORS=1
      WRITE(PRINT,7)
C
C     SET AND CHECK AVERAGE FLUID TEMPERATURE, 'TBAR'
C
  190 IF(TEST03.EQ.BLANK.AND.TEST04.EQ.BLANK) TBAR=60.0
      TAVG=TBAR+459.69
      IF(TAVG.GT.0.0) GO TO 200
      ERRORS=1
      WRITE(PRINT,8)
C
C     CHECK FLUID DENSITY, 'RHO'
C
  200 IF(RHO.GT.0.0) GO TO 210
      ERRORS=1
      WRITE(PRINT,9)
      GO TO 230
C
C     CHECK IF FLOW RATE UNITS ARE COMPATIBLE WITH FLUID DENSITY
C
  210 IF(RHO.GT.BREAK) GO TO 220
      IF(UNITS.NE.2.AND.UNITS.NE.3) GO TO 230
      ERRORS=1
      WRITE(PRINT,10)
      GO TO 230
  220 IF(UNITS.LT.4) GO TO 230
      ERRORS=1
      WRITE(PRINT,11)
C
C     CHECK FLUID VISCOSITY, 'VISCOS'
C
  230 MU=VISCOS/3600.0
      IF(VISCOS.GT.0.0) GO TO 240
      ERRORS=1
      WRITE(PRINT,12)
C
C     CHECK IF PARAMETER CARD ERRORS WERE ENCOUNTERED
C
  240 IF(ERRORS.EQ.0) GO TO 245
      WRITE(PRINT,29) CARD
      IF(ERRORS.NE.0) GO TO 1360
C
C
C
C     THIS SECTION LISTS THE REFERENCE DATA
C
C
C
  245 IF(RHO.GT.BREAK) GO TO 250
      WRITE(PRINT,13) PATMOS,TBAR,RHO,VISCOS
      GO TO 260
  250 WRITE(PRINT,14) PATMOS,TBAR,RHO,VISCOS
C
C
C
C     THIS SECTION READS THE SEGMENT DATA, CHECKS IT FOR ERRORS, AND
C     LISTS THE SEGMENT DATA
C
C
C
C     INITIALIZE COUNTERS AND VARIABLES
C
  260 IF(LIST.EQ.YES) WRITE(PRINT,39)
      AUTO1=0.0
      AUTO2=0.0
      EQNS=0
      NODES=0
      NODEV=3
      NOELEV=1
      NOGRAD=0
      NORUG=1
      SEGMTS=0
      TYP=BLANK
      DO 270 I=1,MAXALL
  270 NODENO(I)=0
C
C     INCREMENT AND SET SEGMENT COUNTERS, 'SEGMTS' @ 'SEGNO'
C
  280 SEGMTS=SEGMTS+1
      SEGNO=MIN0(SEGMTS,999)
C
C     READ A SEGMENT CARD
C
  290 READ(SCRTCH,15,END=770,ERR=300) CARD,TYPE,(SNAME(I,SEGNO),I=1,2),(
     1(NAME(J,I,SEGNO),J=1,2),VALUE(I),FLAGS(I),I=1,2),DIA(SEGNO),XLEN,E
     2LCHNG(SEGNO),ROUGH(SEGNO),GRAD(SEGNO),DEVICE(SEGNO)
      I = POSITION(17)-123
      POSITION(17,I)
      READ(17,42)TEST
      LENGTH(SEGNO)=XLEN+0.5
      ISAVE=ERRORS
      GO TO 310
C
C     FORMAT ERROR ENCOUNTERED
C
  300 ERRORS=ERRORS+1
      WRITE(PRINT,16) CARD
      READ(SCRTCH,33,END=770)CARD
      GO TO 290
C
C     CHECK FOR BLANK CARD
C
  310 DO 320 I=1,20
      IF(CARD(I).NE.BLANK) GO TO 330
  320 CONTINUE
      GO TO 290
C
C     CHECK SEGMENT COUNTER
C
  330 IF(SEGMTS.NE.MAXALL+1) GO TO 340
      ERRORS=ERRORS+1
      WRITE(PRINT,17) MAXALL
C
C     CHECK SEGMENT TYPE, 'TYPE'
C
  340 IF(TYPE.NE.BLANK) TYP=TYPE
      TYPES(SEGNO)=TYP
C
C     CHECK NODE DATA FOR ERRORS
C
      DO 590 I=1,2
C
C     CHECK NODE NAMES, 'NAME(J,I,SEGNO)'
C
      IF(NAME(1,I,SEGNO).NE.BLANK.OR.NAME(2,I,SEGNO).NE.BLANK) GO TO 410
      NO=0
      ERRORS=ERRORS+1
      WRITE(PRINT,18) AB(I)
      GO TO 490
C
C     GET NODE NUMBERS, 'NODE(I,SEGNO)'
C
  410 K=IABS(IABS(NAME(1,I,SEGNO))-IABS(NAME(2,I,SEGNO)))
      NO=MOD(K,PRIME)+1
      K=2*(MOD(K/PRIME,PRIME)+1)
      J=-(K*PRIME)/2
      DO 420 L=1,PRIME
      IF(MOD(NODENO(NO),1000).EQ.0) GO TO 460
      IF(NAME(1,I,SEGNO).EQ.NAMES(1,NO).AND.NAME(2,I,SEGNO).EQ.NAMES(2,N
     1O)) GO TO 450
      J=J+K
      NO=MOD(NO+IABS(J),PRIME)
      IF(NO.EQ.0) NO=PRIME
  420 CONTINUE
      IF(PRIME.EQ.MAXALL) GO TO 440
      J=PRIME+1
      DO 430 NO=J,MAXALL
      IF(MOD(NODENO(NO),1000).EQ.0) GO TO 460
      IF(NAME(1,I,SEGNO).EQ.NAMES(1,NO).AND.NAME(2,I,SEGNO).EQ.NAMES(2,N
     1O)) GO TO 450
  430 CONTINUE
  440 NODES=NODES+1
      NO=0
      IF(NODES.GT.MAXALL+1) GO TO 490
      ERRORS=ERRORS+1
      WRITE(PRINT,19) MAXALL
      GO TO 490
  450 NO=MOD(NODENO(NO),1000)
      GO TO 480
  460 NODES=NODES+1
      NODENO(NO)=NODENO(NO)+NODES
      NODENO(NODES)=NODENO(NODES)+1000*NO
      DO 470 J=1,2
  470 NAMES(J,NO)=NAME(J,I,SEGNO)
      NO=NODES
      EQNS=EQNS+1
      EXCHNG(NO)=0.0
      INDEX(NO)=0
      PRESS(NO)=0.0
  480 NODE(I,SEGNO)=NO
C
C     CHECK NODE PRESSURES/EXCHANGE RATES, 'VALUE(I)', ACCORDING TO
C     INDICATORS, 'FLAGS(I)'
C
  490 J=2*I-1
      IF(TEST(J).EQ.BLANK.AND.TEST(J+1).EQ.BLANK) GO TO 590
      IF(FLAGS(I).EQ.BLANK) GO TO 550
C
C     CHECK NODE PRESSURE ENTRY
C
      VALUE(I)=VALUE(I)+PATMOS
      IF(VALUE(I).GT.0.0) GO TO 500
      ERRORS=ERRORS+1
      WRITE(PRINT,20) AB(I)
      GO TO 590
  500 IF(NO.EQ.0) GO TO 590
      IF(INDEX(NO)) 530,510,520
  510 EQNS=EQNS-1
      INDEX(NO)=-1
      PRESS(NO)=VALUE(I)
      GO TO 590
  520 ERRORS=ERRORS+1
      WRITE(PRINT,21) AB(I)
      GO TO 590
  530 IF(PRESS(NO)-VALUE(I)) 540,590,540
  540 ERRORS=ERRORS+1
      WRITE(PRINT,22) AB(I)
      GO TO 590
C
C     CHECK EXCHANGE RATE ENTRY
C
  550 IF(NO.EQ.0) GO TO 590
      IF(INDEX(NO)) 520,560,570
  560 INDEX(NO)=1
      EXCHNG(NO)=VALUE(I)
      GO TO 590
  570 IF(EXCHNG(NO)-VALUE(I)) 580,590,580
  580 ERRORS=ERRORS+1
      WRITE(PRINT,23) AB(I)
      GO TO 590
  590 CONTINUE
C
C     CHECK NODE COMBINATION
C
      IF(NAME(1,1,SEGNO).NE.NAME(1,2,SEGNO).OR.NAME(2,1,SEGNO).NE.NAME(2
     1,2,SEGNO)) GO TO 600
      ERRORS=ERRORS+1
      WRITE(PRINT,24)
C
C     CHECK PIPE DIAMETER, 'DIA(SEGNO)'
C
  600 IF(TEST05.EQ.BLANK) DIA(SEGNO)=AUTO1
      IF(1.0.LE.DIA(SEGNO).AND.DIA(SEGNO).LE.99.99) GO TO 610
      ERRORS=ERRORS+1
      WRITE(PRINT,25)
      GO TO 620
  610 AUTO1=DIA(SEGNO)
C
C     CHECK PIPE LENGTH, 'LENGTH(SEGNO)'
C
  620 IF(0.LT.LENGTH(SEGNO).AND.LENGTH(SEGNO).LT.1000000) GO TO 630
      ERRORS=ERRORS+1
      WRITE(PRINT,26)
C
C     CHECK ELEVATION CHANGE, 'ELCHNG(SEGNO)'
C
  630 IF(ABS(ELCHNG(SEGNO)).GT.0.0) NOELEV=NOELEV+1
C
C     CHECK RUGOSITY, 'ROUGH(SEGNO)'
C
  640 IF(TEST10.EQ.BLANK.AND.TEST11.EQ.BLANK) GO TO 670
      IF(SEGNO.EQ.1) AUTO2=ROUGH(1)
      IF(0.0.LE.ROUGH(SEGNO).AND.ROUGH(SEGNO).LE.0.5) GO TO 650
      ERRORS=ERRORS+1
      WRITE(PRINT,27)
      GO TO 680
  650 IF(ROUGH(SEGNO)-AUTO2) 660,680,660
  660 NORUG=NORUG+1
      AUTO2=ROUGH(SEGNO)
      GO TO 680
  670 ROUGH(SEGNO)=AUTO2
C
C     CHECK DESIGN PRESSURE GRADIENT, 'GRAD(SEGNO)'
C
  680 IF(TEST12.EQ.BLANK.AND.TEST13.EQ.BLANK) GO TO 690
      NOGRAD=NOGRAD+1
      IF(1.0E-5.LE.GRAD(SEGNO).AND.GRAD(SEGNO).LT.1.0) GO TO 690
      ERRORS=ERRORS+1
      WRITE(PRINT,28)
C
C     SET INLINE DEVICE INDICATOR, 'FLAG(SEGNO)'
C
  690 J=1
      IF(TEST16.EQ.BLANK) GO TO 720
      IF(ABS(DEVICE(SEGNO)).GT.0.0) GO TO 710
      IF(TEST14.NE.BLANK.OR.TEST15.NE.BLANK) GO TO 750
      IF(TEST16.NE.PLUS) GO TO 700
      J=2
      GO TO 750
  700 IF(TEST16.NE.MINUS) GO TO 750
      J=3
      GO TO 750
  710 J=4
      GO TO 740
  720 IF(TEST14.EQ.BLANK.AND.TEST15.EQ.BLANK) GO TO 750
      IF(ABS(DEVICE(SEGNO)).GT.0.0) GO TO 730
      J=5
      GO TO 750
  730 J=6
  740 NODEV=NODEV+1
  750 FLAG(SEGNO)=J
C
C     LIST CARD IF SEGMENT ERRORS WERE FOUND OR IF REQUESTED
C
  760 IF(ISAVE.NE.ERRORS.OR.LIST.EQ.YES) WRITE(PRINT,29) CARD
      GO TO 280
C
C     FINISHED READING SEGMENT DATA - CHECK IF ERRORS WERE ENCOUNTERED
C
  770 IF(ERRORS.EQ.0) GO TO 780
      WRITE(PRINT,30) ERRORS
      GO TO 1360
C
C     ADJUST AND CHECK SEGMENT COUNTER
C
  780 SEGMTS=SEGMTS-1
      IF(SEGMTS.GT.0) GO TO 790
      WRITE(PRINT,31)
      GO TO 1180
C
C     CHECK THAT AT LEAST ONE NODE PRESSURE WAS SPECIFIED
C
  790 IF(NODES.GT.EQNS) GO TO 800
      WRITE(PRINT,32)
      GO TO 1180
C
C     SAVE SEGMENT TYPES, SEGMENT NAMES, AND NODE NAMES ON SCRATCH FILE
C
  800 POSITION(17,1)
      WRITE(SCRTCH,33) (TYPES(I),(SNAME(J,I),J=1,2),((NAME(K,J,I),K=1,2)
     1,J=1,2),I=1,SEGMTS)
C
C
C
C     THIS SECTION CHECKS FOR CONFLICTS IN SPECIFIED ELEVATION CHANGES
C     AND CHECKS FOR DISCONNECTED NETWORKS
C
C
C
C     ADJUST NODE INDICES
C
      J=EQNS
      DO 810 I=1,NODES
      IF(INDEX(I).GE.0) GO TO 810
      J=J+1
      INDEX(I)=J
  810 CONTINUE
C
C     INITIALIZE TABLE POINTERS
C
      DO 820 I=1,NODES
      START(I)=0
  820 END(I)=0
C
C     SET-UP INCIDENCE LOOK-UP TABLE AND TABLE POINTERS
C
      DO 830 I=1,SEGMTS
      DO 830 J=1,2
      K=NODE(J,I)
  830 START(K)=START(K)+1
      J=0
      DO 840 I=1,NODES
      K=START(I)
      START(I)=J+1
      END(I)=J
  840 J=J+K
      DO 850 I=1,SEGMTS
      J=NODE(1,I)
      K=NODE(2,I)
      END(J)=END(J)+1
      END(K)=END(K)+1
      L=END(J)
      M=END(K)
      TABLE(L)=1000*I+K
  850 TABLE(M)=-1000*I-J
C
C     BEGIN ELEVATION CONFLICT SEARCH
C
      DO 930 I=1,NODES
C
C     INITIALIZE ELEVATION INDICATOR ARRAY
C
      DO 860 J=1,NODES
  860 NUM(J)=0
C
C     INITIALIZE FIRST SEARCH NODE
C
      NOAS=1
      NOBS=0
      NODEA(1)=I
      NUM(I)=100000
      NUMBER=1
C
C     BEGIN SEARCH
C
  870 DO 890 J=1,NOAS
      K=NODEA(J)
      N=MOD(NUM(K),100000)
      N1=START(K)
      N2=END(K)
      DO 890 L=N1,N2
      NO=IABS(TABLE(L))
      M=NO/1000
      NO=NO-1000*M
C
C     CALCULATE NODE ELEVATION
C
      M=INT(10.0*ELCHNG(M)+SIGN(0.5,ELCHNG(M)))*ISIGN(1,TABLE(L))+N
C
C     CHECK IF NODE IS CURRENTLY ASSIGNED AN ELEVATION
C
      IF(NUM(NO).EQ.0) GO TO 880
C
C     CHECK FOR ELEVATION CONFLICT
C
      IF(M-MOD(NUM(NO),100000)) 920,890,920
C
C     SAVE NODE FOR FURTHER SEARCH AND ASSIGN ELEVATION TO NODE
C
  880 NOBS=NOBS+1
      NODEB(NOBS)=NO
      NUM(NO)=ISIGN(100000,M)+M
      NUMBER=NUMBER+1
  890 CONTINUE
C
C     CHECK IF SEARCH IS COMPLETE
C
      IF(NOBS.EQ.0) GO TO 910
C
C     RE-INITIALIZE NODE SEARCH ARRAY
C
      NOAS=NOBS
      NOBS=0
      DO 900 J=1,NOAS
  900 NODEA(J)=NODEB(J)
      GO TO 870
C
C     CHECK IF NETWORK IS DISCONNECTED
C
  910 IF(NUMBER-NODES) 950,980,950
C
C     ELEVATION CONFLICT ENCOUNTERED - CONTINUE SO THAT ALL NODES
C     INVOLVED MAY BE IDENTIFIED
C
  920 INDEX(K)=-1
      INDEX(NO)=-1
  930 CONTINUE
C
C     ELEVATION CONFLICTS ENCOUNTERED
C
      K=0
      DO 940 I=1,NODES
      IF(INDEX(I).GE.0) GO TO 940
      J=NODENO(I)/1000
      K=K+1
      NODE(1,K)=NAMES(1,J)
      NODE(2,K)=NAMES(2,J)
  940 CONTINUE
      WRITE(PRINT,34) ((NODE(J,I),J=1,2),I=1,K)
      GO TO 1180
C
C     NETWORK IS DISCONNECTED
C
  950 J=0
      K=0
      DO 970 I=1,NODES
      L=NODENO(I)/1000
      IF(NUM(I).EQ.0) GO TO 960
      J=J+1
      NODE(1,J)=NAMES(1,L)
      NODE(2,J)=NAMES(2,L)
      GO TO 970
  960 K=K+1
      NODEA(K)=NAMES(1,L)
      NODEB(K)=NAMES(2,L)
  970 CONTINUE
      WRITE(PRINT,35) ((NODE(L,I),L=1,2),I=1,J)
      WRITE(PRINT,36) (NODEA(I),NODEB(I),I=1,K)
      GO TO 1180
C
C
C
C     THIS SECTION ASSIGNS NEW NODE INDICES SUCH THAT THE REQUIRED
C     MATRIX ALLOCATION IS MINIMAL
C
C
C
C     CHECK IF RENUMBERING IS NECESSARY
C
  980 SIZE=0
      IF(EQNS.EQ.0) GO TO 1170
C
C     REMOVE DUPLICATE ENTRIES FROM TABLE AND ADJUST POINTERS
C
      DO 1010 I=1,NODES
      N=START(I)
      TABLE(N)=MOD(IABS(TABLE(N)),1000)
      IF(N.EQ.END(I)) GO TO 1010
      NUMBER=N
      N1=N+1
      N2=END(I)
      DO 1000 J=N1,N2
      L=J-1
      TABLE(J)=MOD(IABS(TABLE(J)),1000)
      M=TABLE(J)
      DO 990 K=N,L
      IF(TABLE(K).EQ.M) GO TO 1000
  990 CONTINUE
      NUMBER=NUMBER+1
      TABLE(NUMBER)=M
 1000 CONTINUE
      END(I)=NUMBER
 1010 CONTINUE
C
C     BEGIN 'BEST STARTING NODE' SEARCH
C
      WIDTH=100000
      DO 1120 I=1,NODES
C
C     INITIALIZE WIDTH INDICATOR
C
      WIDE=0
C
C     INITIALIZE RENUMBERING ARRAY
C
      DO 1020 J=1,NODES
      NUM(J)=INDEX(J)
      IF(NUM(J).LE.EQNS) NUM(J)=0
 1020 CONTINUE
C
C     INITIALIZE FIRST NODE SEARCH
C
      NOAS=1
      NOBS=0
      NODEA(1)=I
      IF(NUM(I).GT.0) GO TO 1030
      NUMBER=1
      NUM(I)=1
      GO TO 1040
 1030 NUMBER=0
      NUM(I)=-NUM(I)
C
C     BEGIN NODE SEARCH
C
 1040 DO 1080 J=1,NOAS
      K=NODEA(J)
      L=IABS(NUM(K))
      N1=START(K)
      N2=END(K)
      DO 1080 M=N1,N2
      N=TABLE(M)
C
C     CHECK IF NODE IS ELIGIBLE FOR RENUMBERING
C
      IF(NUM(N)) 1080,1050,1070
C
C     RENUMBER NODE AND SAVE FOR FURTHER SEARCH
C
 1050 NUMBER=NUMBER+1
      NUM(N)=NUMBER
      NOBS=NOBS+1
      NODEB(NOBS)=N
C
C     CHECK IF WIDTH IS ACCEPTABLE
C
 1060 IF(L.GT.EQNS) GO TO 1080
      WIDE=MAX0(WIDE,IABS(NUM(N)-L))
      IF(WIDE-WIDTH) 1080,1120,1120
 1070 IF(NUM(N).LE.EQNS) GO TO 1060
      NUM(N)=-NUM(N)
      NOBS=NOBS+1
      NODEB(NOBS)=N
 1080 CONTINUE
C
C     CHECK IF ALL ELIGIBLE NODES HAVE BEEN RENUMBERED
C
      IF(NUMBER.EQ.EQNS) GO TO 1100
C
C     RE-INITIALIZE NODE SEARCH ARRAY
C
      NOAS=NOBS
      NOBS=0
      DO 1090 J=1,NOAS
 1090 NODEA(J)=NODEB(J)
      GO TO 1040
C
C     NEW RENUMBERING IS BETTER THAN PREVIOUS RENUMBERING - SAVE
C
 1100 WIDTH=WIDE
      DO 1110 J=1,NODES
 1110 INDEX(J)=IABS(NUM(J))
 1120 CONTINUE
C
C
C
C     THIS SECTION ASSIGNS DYNAMIC STORAGE ALLOCATION ADDRESSES
C
C
C
C     CALCULATE REQUIRED MATRIX ALLOCATION AND ROW ADDRESSES
C
      WIDTH=0
      DO 1130 I=1,EQNS
 1130 NODENO(I)=I
      DO 1140 I=1,SEGMTS
      IF(FLAG(I).GT.4) GO TO 1140
      J=NODE(1,I)
      K=NODE(2,I)
      J=INDEX(J)
      K=INDEX(K)
      IF(J.GT.EQNS.OR.K.GT.EQNS) GO TO 1140
      WIDTH=MAX0(WIDTH,IABS(J-K))
      NODENO(J)=MAX0(NODENO(J),K)
      NODENO(K)=MAX0(NODENO(K),J)
 1140 CONTINUE
      DO 1160 I=1,EQNS
      NO=NODENO(I)
      NODENO(I)=SIZE-I+1
      SIZE=SIZE+NO-I+1
      J=I+1
      K=MIN0(EQNS,I+WIDTH)
      IF(J.GT.K) GO TO 1160
      DO 1150 L=J,K
 1150 NODENO(L)=MAX0(NODENO(L),NO)
 1160 CONTINUE
      NODENO(EQNS+1)=NODENO(EQNS)
C
C     CALCULATE ARRAY ADDRESSES
C
 1170 WORD01=SEGMTS+1
      WORD02=WORD01+SEGMTS
      WORD03=WORD02+SEGMTS
      WORD04=WORD03+NOELEV
      WORD05=WORD04+NORUG
      WORD06=WORD05+NOGRAD
      WORD07=WORD06+NODEV
      WORD08=WORD07+SEGMTS
      WORD09=WORD08+EQNS
      WORD10=2*((WORD09+EQNS+1)/2)+1
      WORD11=WORD10+2*NODES
      WORD12=WORD11+2*EQNS
C
C     CHECK TOTAL REQUIRED ALLOCATION
C
      IF(WORD12+2*SIZE-2.LE.LIMIT) GO TO 1190
C
C     REQUIRED ALLOCATION EXCEEDS CORE LIMIT
C
      I=WORD12+2*SIZE-LIMIT-2
      WRITE(PRINT,37) I
C
C     ERROR RETURN
C
 1180 ERRORS=1
      GO TO 1360
C
C
C
C     THIS SECTION PERFORMS THE FINAL DATA TRANSFERS
C
C
C
C     CALCULATE CONVERSION FACTORS, 'CONVSN' @ 'FACTOR'
C
 1190 CONVSN=RHO/144.0
      IF(RHO.LE.BREAK) CONVSN=519.69*CONVSN/(2.0*14.696*TAVG)
      GO TO (1200,1210,1220,1230,1240),UNITS
 1200 FACTOR=1000.0/3600.0
      GO TO 1250
 1210 FACTOR=RHO/(60.0*7.4805195)
      GO TO 1250
 1220 FACTOR=42.0*RHO/(24.0*3600.0*7.4805195)
      GO TO 1250
 1230 FACTOR=1000.0*RHO/(24.0*3600.0)
      GO TO 1250
 1240 FACTOR=1000000.0*RHO/(24.0*3600.0)
C
C     TRANSFER SEGMENT DATA
C
 1250 AUTO2=-1.0
      NODEV=2
      NOELEV=0
      NOGRAD=-1
      NORUG=0
      STORE(WORD03)=0.0
      STORE(WORD06)=0.0
      STORE(WORD06+1)=0.0
      STORE(WORD06+2)=0.0
      DO 1340 I=1,SEGMTS
      NO=I-1
C
C     TRANSFER NODE INDICES, 'INDEX(J)' @ 'INDEX(K)', AND INITIALIZE
C     INLINE DEVICE INDEX
C
      J=NODE(1,I)
      K=NODE(2,I)
      ISTORE(I)=3000000+1000*INDEX(J)+INDEX(K)
C
C     TRANSFER PIPE DIAMETER, 'DIA(I)', AND INITIALIZE ELEVATION CHANGE
C     INDEX
C
      ISTORE(WORD01+NO)=1.0E5+1.0E3*DIA(I)+0.5
C
C     TRANSFER PIPE LENGTH, 'LENGTH(I)'
C
      ISTORE(WORD02+NO)=LENGTH(I)
C
C     TRANSFER ELEVATION CHANGE INDEX, 'NOELEV', AND ELEVATION CHANGE,
C     'ELCHNG(I)'
C
      IF(ELCHNG(I)) 1260,1270,1260
 1260 NOELEV=NOELEV+1
      ISTORE(WORD01+NO)=ISTORE(WORD01+NO)+100000*NOELEV
      STORE(WORD03+NOELEV)=CONVSN*ELCHNG(I)
C
C     TRANSFER PIPE RUGOSITY, 'ROUGH(I)', AND ITS INDEX, 'NORUG'
C
 1270 IF(ROUGH(I)-AUTO2) 1280,1290,1280
 1280 AUTO2=ROUGH(I)
      STORE(WORD04+NORUG)=2.0*AUTO2
      NORUG=NORUG+1
 1290 ISTORE(WORD02+NO)=ISTORE(WORD02+NO)+1000000*NORUG
C
C     SET DESIGN GRADIENT INDICATOR, '-', AND TRANSFER DESIGN PRESSURE
C     CHANGE, 'LENGTH(I)*GRAD(I)'
C
      IF(GRAD(I).LE.0.0) GO TO 1300
      NOGRAD=NOGRAD+1
      ISTORE(WORD01+NO)=-ISTORE(WORD01+NO)
      STORE(WORD05+NOGRAD)=LENGTH(I)*GRAD(I)
C
C     TRANSFER INLINE DEVICE DATA
C
 1300 J=FLAG(I)
      GO TO (1340,1310,1310,1320,1330,1320),J
 1310 ISTORE(I)=ISTORE(I)+1000000*(1-J)
      GO TO 1340
 1320 ISTORE(I)=ISTORE(I)+1000000*(NODEV-1)
      NODEV=NODEV+1
      STORE(WORD06+NODEV)=DEVICE(I)
      IF(J.EQ.4) GO TO 1340
      STORE(WORD06+NODEV)=STORE(WORD06+NODEV)*FACTOR
 1330 ISTORE(I)=-ISTORE(I)
 1340 CONTINUE
C
C     TRANSFER NODE DATA
C
      K=WORD08-1
      L=WORD09-1
      M=(WORD10-1)/2
      N=EQNS+1
      DO 1350 I=1,NODES
      J=INDEX(I)
C
C     TRANSFER EXCHANGE RATE, 'EXCHNG(I)'
C
      IF(J.LE.EQNS) STORE(J+K)=FACTOR*EXCHNG(I)
C
C     TRANSFER MATRIX ROW ADDRESS, 'NODENO(J)'
C
      IF(J.LE.N) ISTORE(J+L)=NODENO(J)
C
C     TRANSFER PRESSURE, 'PRESS(I)'
C
 1350 DSTORE(J+M)=PRESS(I)
C
C     FINISHED
C
 1360 RETURN
      END
C * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
      SUBROUTINE RESULT(NODE,DIA,DELTAP,ELCHNG,DEVICE,RESIST,EXCHNG,PRES
     1S,EXCHG,SEGFLO,TYPES,SNAME,NAME)
C
C     THIS SUBROUTINE LISTS THE SIMULATION RESULTS
C
C     SPECIFICATIONS
C
      INTEGER ADATE,ASTER,BLANK,DATA,DIA,EQNS,ERRORS,OUTPUT,PAGE,PRIME,P
     1RINT,QUEST,READ,SCRTCH,SEGMTS,SIZE,TAPE,TITLE,TYPE,TYPES,UNIT,UNIT
     2S,WORDS
      LOGICAL FIRST,NOZERO
      REAL MU,NETEXC
      DOUBLE PRECISION PRESS
      DIMENSION ADATE(18),DELTAP(1),DEVICE(1),DIA(1),ELCHNG(1),EXCHG(1),
     2EXCHNG(1),LOCATE(18),NAME(2,2,1),NODE(1),OUTPUT(50),P(2),PRESS(1),
     3RESIST(1),SEGFLO(1),SNAME(2,1),TITLE(80,2),TYPES(1),UNIT(8,5),WORD
     4S(12)
      COMMON ADATE,BREAK,CONST,CONTOL,CONVSN,DATA,EQNS,ERRORS,FACTOR,LIM
     1IT,LINE,LOCATE,MAXALL,MAXLIN,MU,NODES,NOZERO,PAGE,PATMOS,PRIME,PRI
     2NT,READ,RHO,SCRTCH,SEGMTS,SINTOL,SIZE,TAPE,TAVG,TITLE,UNITS,WORDS
      EQUIVALENCE (MARK1,OUTPUT(35)),(MARK2,OUTPUT(12))
      DATA ASTER,BLANK,QUEST/'*',' ','?'/,UNIT/'(MLB','/HR)','(MLB','/HR
     1)','(MLB','/HR)','MLB','/HR','  (G','PM)','  (G','PM)',' (GP','M)'
     2,'GPM',' ',' (BB','L/D)',' (BB','L/D)','(BBL','/D)','BBL','/D',' (
     3SM','CFD)',' (SM','CFD)','(SMC','FD)','SMC','FD','(SMM','CFD)','(S
     4MM','CFD)','(SMM','CFD)','SMM','CFD'/
C
C     FORMATS
C
    1 FORMAT(//' ** SINGULAR SOLUTION MATRIX ENCOUNTERED')
    2 FORMAT(//' ** CYCLING ENCOUNTERED DURING PIPE SIZING')
    3 FORMAT(//' ** NETWORK INFEASIBILITY ENCOUNTERED')
    4 FORMAT(20A4)
    5 FORMAT(//  ' ***** SEGMENT TYPE:  ',A4/    ' '/ 10X,'***  N O D E
     1 '' A ''  *** ***  N O D E  '' B ''  ***  S E G M E N T'/9X,2(10X,
     2'STAG''N EXCHANGE'),'  FLOW    FLOW'/' SEGMENT',2(11X,'PRESS.   RA
     3TE',1X),'  LOSSES   RATE'/'  NAME   ',2(3X,'NAME   (PSIG) ',2A4),'
     4  (PSI) ',2A4/' ')
    6 FORMAT(1X,2A4,1X,2(2A4,1X,F6.1,10A1),6A1,1X,9A1)
    7 FORMAT(///' ***** NET FLUID EXCHANGE:',F10.1,1X,2A3)
    8 FORMAT(////41X,'DEVICE'/32X,'DESIGN  PRESSURE'/' SEGMENT   NODE ''
     1A''  NODE ''B''  DIAMETER  CHANGE'  /'  NAME ',2(6X,'NAME'),4X,'(I
     2NCHES)   (PSI)'/' ')
    9 FORMAT(3(1X,2A4,1X),2X,5A1,4X,7A1)
   10 FORMAT(/1X,8(3A1,'-'),4(5A1,'-'),4A1,'-',2A1/' '/' '/' ')
   11 FORMAT(////' *****  S I M U L A T I O N  R E S U L T S  *****'/' '
     1/(71A1))
C
C     CHECK ERROR INDICATOR, 'ERRORS'
C
      IF(ERRORS.GE.0) GO TO 100
C
C     SINGULAR SOLUTION MATRIX ENCOUNTERED
C
      ERRORS=IABS(ERRORS)-100
      WRITE(PRINT,1)
      GO TO 340
C
C     CYCLING ENCOUNTERED DURING PIPE SIZING
C
  100 IF(MOD(ERRORS,100).LT.20) GO TO 110
      WRITE(PRINT,2)
C
C
C
C     THIS SECTION INITIALIZES THE SIMULATION OUTPUT
C
C
C
C     INITIALIZE EXCHANGE RATE, 'EXCHG(I)'
C
  110 DO 120 I=1,NODES
  120 EXCHG(I)=0.0
C
C     INITIALIZE SIMULATION OUTPUT
C
      FIRST=.TRUE.
      DO 200 I=1,SEGMTS
C
C     GET INDICES
C
      K=IABS(NODE(I))
      L=K/1000000
      K=K-1000000*L
      J=K/1000
      K=K-1000*J
      M=IABS(DIA(I))/100000
      DIAM=1.0E-3*(IABS(DIA(I))-100000*M)
      RESIST(I)=ABS(RESIST(I))
C
C     CALCULATE SEGMENT FLOW RATE, 'SEGFLO(I)', AND INLINE DEVICE
C     PRESSURE CHANGE, 'DELTAP(I)'
C
      IF(NODE(I).LT.0) GO TO 150
      DELTAP(I)=DEVICE(L)
      IF(RHO.GT.BREAK) GO TO 130
      SEGFLO(I)=(PRESS(J)-PRESS(K)-ELCHNG(M)*(PRESS(J)+PRESS(K)+ABS(DELT
     1AP(I)))+DELTAP(I))/RESIST(I)
      GO TO 140
  130 SEGFLO(I)=(PRESS(J)-PRESS(K)-ELCHNG(M)+DELTAP(I))/RESIST(I)
  140 IF(L.GT.2.OR.(L-1.5)*SEGFLO(I).GE.0.0) GO TO 170
  150 SEGFLO(I)=DEVICE(L)
      IF(RHO.GT.BREAK) GO TO 160
      DELTAP(I)=SEGFLO(I)*RESIST(I)-PRESS(J)+PRESS(K)+ELCHNG(M)*(PRESS(J
     1)+PRESS(K))
      DELTAP(I)=DELTAP(I)/(1.0-SIGN(ELCHNG(M),DELTAP(I)))
      GO TO 170
  160 DELTAP(I)=SEGFLO(I)*RESIST(I)-PRESS(J)+PRESS(K)+ELCHNG(M)
C
C     CALCULATE EXCHANGE RATES, 'EXCHG(J)' @ 'EXCHG(K)'
C
  170 VALUE=SEGFLO(I)
      EXCHG(J)=EXCHG(J)+VALUE
      EXCHG(K)=EXCHG(K)-VALUE
C
C     CHECK NETWORK FEASIBILITY
C
      PMIN=DMIN1(PRESS(J),PRESS(K))
      IF(RHO.GT.BREAK) GO TO 180
      VALUE=CONST*ABS(VALUE)/DIAM**2
      IF(PMIN.GT.2.0*VALUE) GO TO 200
      RESIST(I)=-RESIST(I)
      IF(PMIN-VALUE) 190,190,200
  180 IF(PMIN.GT.0.0) GO TO 200
  190 IF(.NOT.FIRST) GO TO 200
      FIRST=.FALSE.
      WRITE(PRINT,3)
  200 CONTINUE
C
C
C
C     THIS SECTION LISTS THE SIMULATION RESULTS
C
C
C
C     CALCULATE CONVERSION FACTORS, 'CONVSN' @ 'FACTOR'
C
      CONVSN=8.0/(9.8696044*32.174*CONVSN)
      FACTOR=1.0/FACTOR
C
C     GET SEGMENT TYPES, SEGMENT NAMES, AND NODE NAMES FROM SCRATCH DATA
C     FILE, 'SCRTCH'
C
      POSITION(17,1)
      READ(SCRTCH,4) (TYPES(I),(SNAME(J,I),J=1,2),((NAME(K,J,I),K=1,2),J
     1=1,2),I=1,SEGMTS)
C
C     SELECT A SEGMENT TYPE TO BE LISTED
C
      WRITE(PRINT,11) (BLANK,(TITLE(J,I),J=1,70),I=1,2)
      DO 320 N=1,SEGMTS
      IF(TYPES(N).EQ.0) GO TO 320
      TYPE=TYPES(N)
      WRITE(PRINT,5) TYPE,(UNIT(J,UNITS),J=1,6)
      DO 310 I=N,SEGMTS
C
C     CHECK IF SEGMENT IS ELIGIBLE FOR LISTING
C
      IF(TYPE.NE.TYPES(I)) GO TO 310
C
C     BLANK OUTPUT LINE, 'OUTPUT'
C
      DO 210 J=1,35
  210 OUTPUT(J)=BLANK
C
C     CALCULATE NODE PRESSURES, 'P(J)', AND PUT NODE FLOW RATES,
C     'EXCHG(K)', INTO OUTPUT LINE
C
      L=IABS(NODE(I))
      M=L/1000000
      L=L-1000000*M
      K=L/1000
      DO 260 J=1,2
      IF(PRESS(K).LE.0.0) OUTPUT(10*J-9)=QUEST
      P(J)=PRESS(K)-PATMOS
      VALUE=FACTOR*EXCHG(K)
      IF(K.LE.EQNS) GO TO 220
      IF(ABS(VALUE)-5.0E-2) 260,260,250
  220 IF(ABS(EXCHNG(K)).GT.0.0) GO TO 230
      IF(ABS(VALUE)-5.0E-2) 260,260,240
  230 IF(ABS((EXCHNG(K)-EXCHG(K))/(EXCHNG(K)+EXCHG(K))).LT.CONTOL) GO TO
     1250
  240 OUTPUT(10*J)=QUEST
  250 CALL CONVRT(VALUE,OUTPUT(10*J-8),8,1)
  260 K=L-1000*K
C
C     PUT FRICTION LOSSES INTO OUTPUT LINE
C
      VALUE=SEGFLO(I)*ABS(RESIST(I))
      IF(ABS(VALUE).GT.5.0E-2) CALL CONVRT(VALUE,OUTPUT(21),6,1)
C
C     PUT SEGMENT FLOW RATE INTO OUTPUT LINE
C
      VALUE=FACTOR*SEGFLO(I)
      IF(ABS(VALUE).GT.5.0E-2) CALL CONVRT(VALUE,OUTPUT(27),8,1)
C
C     LIST OUTPUT LINE
C
  290 WRITE(PRINT,6) (SNAME(J,I),J=1,2),((NAME(K,J,I),K=1,2),P(J),(OUTPU
     1T(10*J+K-10),K=1,10),J=1,2),(OUTPUT(J),J=21,35)
      TYPES(I)=0
  310 CONTINUE
  320 CONTINUE
C
C
C
C     THIS SECTION LISTS DESIGN DIAMETERS AND INLINE DEVICE PRESSURE
C     CHANGES
C
C
C
      FIRST=.TRUE.
      DO 323 I=1,SEGMTS
      M=IABS(NODE(I))/1000000
C
C     CHECK IF SEGMENT IS ELIGIBLE TO BE LISTED
C
      IF(DIA(I).GT.0.AND.M.EQ.3.AND.NODE(I).GT.0) GO TO 323
C
C     SEGMENT IS TO BE LISTED
C
      IF(FIRST) WRITE(PRINT,8)
      FIRST=.FALSE.
C
C     BLANK OUTPUT LINE, 'OUTPUT'
C
      DO 321 J=1,12
  321 OUTPUT(J)=BLANK
C
C     PUT DESIGN DIAMETER INTO OUTPUT LINE
C
      IF(DIA(I).LT.0) CALL CONVRT((IABS(DIA(I)-100000*(DIA(I)/1000
     100))/1000),OUTPUT,5,2)
C
C     PUT INLINE DEVICE PRESSURE CHANGE INTO OUTPUT LINE
C
      IF(M.EQ.3.AND.NODE(I).GT.0) GO TO 322
      CALL CONVRT(DELTAP(I),OUTPUT(6),6,1)
      IF(M.LT.4.OR.DELTAP(I)*SEGFLO(I).LT.0.0) MARK2=ASTER
C
C     WRITE OUTPUT LINE
C
  322 WRITE(PRINT,9) (SNAME(J,I),J=1,2),((NAME(K,J,I),K=1,2),J=1,2),(OUT
     1PUT(J),J=1,12)
  323 CONTINUE
C
C     CALCULATE AND LIST NET NETWORK FLUID EXCHANGE, 'NETEXC'
C
      NETEXC=0.0
      DO 330 I=1,NODES
  330 NETEXC=NETEXC+ABS(EXCHG(I))
      NETEXC=0.5*FACTOR*NETEXC
      WRITE(PRINT,7) NETEXC,(UNIT(I,UNITS),I=7,8)
C
C     LIST 'PROBLEM CODE'
C
  340 CALL CONVRT(SEGMTS,OUTPUT,3,-1)
      CALL CONVRT(NODES,OUTPUT(4),3,-1)
      CALL CONVRT(SEGMTS-NODES+1,OUTPUT(7),3,-1)
      CALL CONVRT(EQNS,OUTPUT(10),3,-1)
      CALL CONVRT(WORDS(4)-WORDS(3)-1,OUTPUT(13),3,-1)
      CALL CONVRT(WORDS(5)-WORDS(4),OUTPUT(16),3,-1)
      CALL CONVRT(WORDS(6)-WORDS(5),OUTPUT(19),3,-1)
      CALL CONVRT(WORDS(7)-WORDS(6)-3,OUTPUT(22),3,-1)
      CALL CONVRT(WORDS(11)-EQNS-3,OUTPUT(25),5,-1)
      CALL CONVRT(3*EQNS+1,OUTPUT(30),5,-1)
      CALL CONVRT(2*SIZE,OUTPUT(35),5,-1)
      CALL CONVRT(LIMIT-WORDS(12)-2*SIZE+2,OUTPUT(40),5,-1)
      CALL CONVRT(ERRORS/100,OUTPUT(45),4,-1)
      CALL CONVRT(MOD(ERRORS,100),OUTPUT(49),2,-1)
      WRITE(PRINT,10) (OUTPUT(I),I=1,50)
C
C     FINISHED
C
      RETURN
      END
     B@