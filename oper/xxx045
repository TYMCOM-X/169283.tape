C	 BMDZ99
*	D E C K 1   OF	B M D Z 9 9
*
*	 THIS DECK CONTAINS SUBROUTINES NEEDED BY BMD02R,BMD07V,BMD08V,
*     BMDX69,BMDX72,BMDX85 AND BMDX90.
*
*    ASSEMBLE THIS DECK AS ONE MODULE AND INCLUDE IT WHEN LINKEDING
*     THE ABOVE PROGRAMS.
*
*
*
*
	 MACRO
+N	 INIT
	 LCLC  +L
+L	 SETC  'L'
	 USING *,15		  ESTABLISH ADDRESSABILITY TO HERE
+L+N	 EQU   *
+N	 STM   14,12,12(13)	  SAVE REGISTERS IN CALLING PROGRAM
	 L     12,BOOLADR	  ESTABLISH BASE ADDRESS
	 USING BOOL,12		  TO BOOL
	 DROP  15
	 MEND
	 MACRO
	 ARGS  +M
	 L     2,0(0,1) 	  POINT TO FIRST ARG
	 L     2,0(0,2) 	  PICK UP FIRST ARG
	 AIF  (+M EQ 1).OUT
	 L     3,4(0,1) 	  POINT TO SECOND ARG
.OUT	 ANOP
	 MEND
	 MACRO
+NAME	 REST
+NAME	 LR    0,2		  PROVIDE INTEGER FUNCTION RETURN
	 ST    2,TEMPBOOL
	 LE    0,TEMPBOOL	  PROVIDE REAL FUNCTION RETURN
	 B     BOOLRET
*
	 MEND
BMDASM	 CSECT
	 ENTRY TIMET,TIMER,COMPAR,BOOLEAN,LAND,AND,OR,COMPL,LOR
	 ENTRY LCOMPL,SHIFT,DSHIFT,LSHIFT,PUTCHR,GETCHR
TIMET	 STM   14,12,12(13)
	 BALR  12,0
	 USING *,12
BASADR	 ST    13,SAVEARE2+4
	 LA    10,SAVEARE2
	 ST    10,8(13)
	 LR    13,10
	 L     3,0(1)
	 TTIMER
	 S     0,BIG
	 LPR   0,0
	 BAL   14,CALC
	 BZ    SET
OUT	 L     13,SAVEARE2+4
	 LM    14,12,12(13)
	 BR    14
CALC	 ST    0,RETA+4
	 SDR   0,0
	 AD    0,RETA
	 ME    0,=E'.000026'
	 L     3,0(3)
	 LTR   3,3
	 BR    14
SET	 STIMER  TASK,TUINTVL=BIG
	 B     OUT
TIMER	 STM   14,12,12(13)
	 DROP  12
	 USING TIMER,15
	 L     12,=A(BASADR)
	 DROP  15
	 USING BASADR,12
	 ST    13,SAVEARE2+4
	 LA    10,SAVEARE2
	 ST    10,8(13)
	 LR    13,10
	 L     3,0(1)
	 TIME  TU
	 LR    2,0
	 S     0,LASTIME
	 BAL   14,CALC
	 BC    6,OUT
	 ST    2,LASTIME
	 B     OUT
	 DS    0D
RETA	 DC    X'4E00000000000000'
LASTIME  DS    F
BIG	 DC    X'7FFFFFFF'
SAVEARE2 DS    18F
	 LTORG
*
BOOLEAN  EQU   *
BOOL	 EQU   *		  ESTABLISH DATA ADDRESSABILITY TO HERE
AND	 INIT			  FUNCTION AND ( A , B )   LAND(I,J)
	 ARGS  0
	 N     2,0(0,3) 	  AND WITH SECOND ARG
	 B     FRETURN
OR	 INIT			  FUNCTION OR(A,B)   LOR(I,J)
	 ARGS  0
	 O     2,0(0,3) 	  OR WITH SECOND ARG
	 B     FRETURN
COMPL	 INIT			  FUNCTION COMPL(A)   LCOMPL(I)
	 ARGS  1
	 X     2,=X'FFFFFFFF'	  COMPLEMENT THE REGISTER
FRETURN  REST
	 USING *,15
DSHIFT	 EQU   *
	 STM   14,12,12(13)	  SAVE REGISTERS
	 L     12,BOOLADR
	 USING BOOL,12
	 DROP  15
	 L     2,0(0,1) 	  POINT TO FIRST ARG
	 LD    0,0(0,2) 	  LOAD DSHIFT ARGUMENT
	 STD   0,TEMPBOOL
	 LM    2,3,TEMPBOOL
	 B     BOOLGO
*
	 USING *,15
LSHIFT	 EQU   *
SHIFT	 STM   14,12,12(13)	  SAVE THE REGISTERS
	 L     12,BOOLADR
	 USING BOOL,12
	 DROP  15
	 SR    3,3		  ZERO THE LOWER 32 BITS OF THE R*8 WD
	 L     2,0(0,1) 	  POINT TO 1ST ARG
	 L     2,0(0,2) 	  GET 1ST ARG
BOOLGO	 L     4,4(0,1) 	  POINT TO 2ND ARG
	 L     4,0(0,4) 	  GET SECOND ARG
	 LTR   4,4		  TEST FOR RIGHT OR LEFT SHIFT
	 BM    RIGHT		  RIGHT SHIFT IF 2ND ARG NEGATIVE
	 SLDL  2,0(4)		  SHIFT LEFT BY '2ND ARG'
RET	 LR    0,2		  PROVIDE LSHIFT FUNCTION RETURN
	 STM   2,3,TEMPBOOL
	 LD    0,TEMPBOOL	  PROVIDE RETURN FOR SHIFT, DSHIFT
*
BOOLRET  LM    14,15,12(13)	  RESTORE 14 AND 15
	 OI    12(13),X'FF'	  MARK COMPLETION OF THE FUNCTION
	 LM    1,12,24(13)	  RESTORE 1 THROUGH 12
	 BR    14		  RETURN TO CALLING PROGRAM
*
RIGHT	 LPR   4,4		  SET SHIFT AMOUNT PLUS
	 SRDL  2,0(4)		  RIGHT SHIFT
	 B     RET
	 CNOP  0,4
BOOLADR  DC    A(BOOL)
	 CNOP  0,8
TEMPBOOL DS    DL8
	 LTORG
*		 CALL SEQUENCE IS  COMPAR(A,B,K)      WHERE
*		       A IS THE FIRST FIELD TO BE COMPARED
*		       B IS THE SECOND FIELD TO BE COMPARED
*		       K IS THE MODE OF THE FIELDS AND THE TYPE
*			  AS FOLLOWS
*
*	 K     MEANING
*
*	 0     ALPHA
*	 1     FIXED POINT NON-SIGNED
*	 2     FIXED POINT SIGNED
*	 3     FLOATING POINT NON-SIGNED
*	 4     FLOATING POINT SIGNED BLANK EQUAL 0
*	 5     FLOATING POINT SIGNED BLANK LESS THAN 0
*
*	       A NEGATIVE K MEANS DESCENDING SEQUENCE
*	       A POSITIVE A MEANS ASCENDING SEQUENCE
*
*	 IF A  LT B  COMPAR = -1
*	 IF A  EQ B  COMPAR = 0
*	 IF A  GT B  COMPAR = +1
*
COMPAR	 STM   R14,R12,12(R13)
	 BALR  R12,0
	 USING *,R12
	 ST    R13,SAVEAREA+4
	 LA    R11,SAVEAREA
	 ST    R11,8(R13)
	 LR    R13,R11
	 L     R3,0(R1)
	 L     R4,4(R1)
	 L     R5,8(R1)
	 L     R5,0(R5)
	 LPR   R6,R5
	 SLL   R6,2
	 B     BRTBL(R6)
BRTBL	 B     ALPHA
	 B     FIXNS
	 B     FIXS
	 B     FLNS
	 B     FLS
	 B     FLS
	 ABEND 99
ALPHA	 L     R3,0(R3)
	 L     R4,0(R4)
	 CL    R3,SEVENS
	 BE    SEVENS2
	 CL    R4,SEVENS
	 BE    LO
	 CLR   R3,R4
	 BH    HI
	 BL    LO
	 B     EQ
SEVENS2  CL    R4,SEVENS
	 BE    EQ
	 B     HI
FIXS	 L     R3,0(R3)
	 L     R4,0(R4)
	 B     CMPRFIX
FIXNS	 L     R3,0(R3)
	 L     R4,0(R4)
	 LPR   R3,R3
	 LPR   R4,R4
CMPRFIX  CR    R3,R4
	 BH    HI
	 BL    LO
	 B     EQ
FLNS	 LE    FR0,0(R3)
	 LE    FR2,0(R4)
	 LPER  FR0,FR0
	 LPER  FR2,FR2
	 B     FLCMP
FLS	 LE    FR0,0(R3)
	 LE    FR2,0(R4)
FLCMP	 CER   FR0,FR2
	 BH    HI
	 BL    LO
	 CH    R6,=H'0020'
	 BNE   EQ
	 TM    0(R3),X'80'
	 BO    BLNK2
	 TM    0(R4),X'80'
	 BO    HI
	 B     EQ
BLNK2	 TM    0(R4),X'80'
	 BO    EQ
LO	 LE    FR0,=E'-1.0'
	 B     AORD
HI	 LE    FR0,=E'1.0'
	 B     AORD
EQ	 LE    FR0,=E'0.0'
	 B     RETB
AORD	 LTR   R5,R5
	 BP    RETB
	 BZ    RETB
	 LCER  FR0,FR0
RETB	 L     R13,SAVEAREA+4
	 LM    R14,R12,12(R13)
	 BR    R14
SEVENS	 DC    X'7FFFFFFF'
FR0	 EQU   0
FR2	 EQU   2
R1	 EQU   1
R3	 EQU   3
R4	 EQU   4
R5	 EQU   5
R6	 EQU   6
R11	 EQU   11
R12	 EQU   12
R13	 EQU   13
R14	 EQU   14
SAVEAREA DS    18F
	 LTORG
*  GETCHR PLACES THE N-TH CHARACTER OF A INTO CH
*  CALLING SEQUENCE - CALL GETCHR(A,N,CH)
*
	 USING GETCHR,15
GETCHR	   ST	  2,SAVER1	  SAVE THE REGISTER TO BE USED
	   L	  2,4(0,1)	  POINT TO N
	   L	  2,0(0,2)	  PICK UP N
	   S	  2,=F'1'	  CONVERT TO 0 - BASE INDEX
	   A	  2,0(0,1)	  POINT TO THE PROPER CHAR IN A
	   IC	  0,0(0,2)	  PICK UP THE INDICATED CHARACTER
	   L	  2,8(0,1)	  POINT TO CH
	   SLL	  0,24(0)	  SHIFT CHAR TO TOP OF REG
	   O	  0,=X'00404040'  PUT BLANKS IN REST OF REG
	   ST	  0,0(0,2)	  PLACE THE CHARACTER INTO CH
	   L	  2,SAVER1	  RESTORE THE REGISTER USED
	   BR	  14		  RETURN TO CALLING PROGRAM
SAVER1	   DC	  F'0'
	   LTORG
*
*  THE FORTRAN ROUTINES BELOW WERE REPLACED BY THIS ASSEMBLY ROUTINE.
*
*  NO GENERALITY IS LOST BECAUSE THE FORTRAN WAS DEPENDENT UPON THE
*  PARTICULAR MACHINE CONFIGURATION FOR REPRESENTING CHARACTERS.
*
*     SUBROUTINE GETCHR(A,N,C)
* THE 'N'-TH CHARACTER OF 'A' IS PLACED INTO THE FIRST CHARACTER POS'N
*     DIMENSION A(N)
*     LOGICAL*1 A,C1
*     LOGICAL C,B,CW
*     EQUIVALENCE (CW,C1)
*     DATA B/4H    /
*
*     CW=B
*     C1=A(N)
*     C=CW
*     RETURN
*     END
*  PUTCHR PLACES THE CHAR IN CH INTO THE N-TH CHARACTER OF A
*  CALLING SEQUENCE -  CALL PUTCHR ( A , N , CH )
*
	 USING PUTCHR,15
PUTCHR	   ST	  2,SAVER2	  SAVE THE REGISTER TO BE USED
	   L	  2,8(0,1)	  POINT TO CH
	   IC	  0,0(0,2)	  PICK UP THE CHARACTER IN CH
	   L	  2,4(0,1)	  POINT TO N
	   L	  2,0(0,2)	  PICK UP N
	   S	  2,=F'1'	  CONVERT TO 0 - BASED INDEX
	   A	  2,0(0,1)	  POINT TO THE PROPER CHAR IN A
	   STC	  0,0(0,2)	  PLACE THE CHARACTER INTO A
	   L	  2,SAVER2	  RESTORE THE REGISTER USED
	   BR	  14		  RETURN TO CALLING PROGRAM
*
SAVER2	   DC	  F'0'
	   LTORG
*
*  THE FORTRAN ROUTINES BELOW WERE REPLACED BY THIS ASSEMBLY ROUTINE.
*
*  NO GENERALITY IS LOST BECAUSE THE FORTRAN WAS DEPENDENT UPON THE
*  PARTICULAR MACHINE CONFIGURATION FOR REPRESENTING CHARACTERS.
*
*     SUBROUTINE PUTCHR(A,N,C)
* THE FIRST CHARACTER OF 'C' IS PLACED INTO THE 'N'-TH CHARACTER POS'N
*     DIMENSION A(N)
*     LOGICAL*1 A,C
*
*     A(N)=C
*     RETURN
*     END
	   END
*
*	 D E C K 2 OF B M D Z 9 9
*
*	     THIS DECK CONTAINS IHCFCVTH WHICH HAS BEEN
*     MODIFIED BY HSCF TO INCLUDE THE SIGN FUNCTION AND TO CONVERT
*     BLANKS TO A MINUS ZERO. THIS IS NEEDED BY BMD01D,BMD02D,BMD03D,
*     BMD07D,BMD09D,BMD09S,BMD04V,BMDX70,BMDX72,BMDX77,BMDX84,BMDX94.
*    ASSEMBLE THIS DECK AS ONE MODULE AND INCLUDE IT WHEN LINKEDING
*     THE ABOVE PROGRAMS.
*
*
*
*
	 TITLE	   'IHCFCVTH' - OPERATING SYSTEM 360   FORTRAN H
IHCFCVTH START	   0		       I/O DATA CONVERSIONS
*0723	 096400-096600						   6087
*	 184400-185000						   7447
*      145000-145400,242000,245600				  20211
	 ENTRY	   ADCON=
	 EXTRN	   IBCOM=
	 ENTRY INT6SWCH 					   4648
* THESE ENTRY POINTS ARE A TEMPORARY EXPEDIENT TO MAINTAIN
* COMPATIBILITY WITH FORTRAN E'S DUMP/PDUMP SUBROUTINE.
	 ENTRY FCVEOUTP
	 ENTRY FCVLOUTP
	 ENTRY FCVIOUTP
	 ENTRY FCVCOUTP
	 ENTRY FCVAOUTP
	 ENTRY FCVZOUTP
	 ENTRY SIGN
*
* STATUS - CHANGE LEVEL 02,11SEP68  RELEASE 17
*
* FUNCTION/OPERATION--IHCFCVTH, A MEMBER OF THE FORTRAN SYSTEM LIBRARY,
*    IS USED BY IHCFCOMH AND IHCNAMEL TO PERFORM VARIOUS TYPES OF
*    INPUT AND OUTPUT DATA CONVERSIONS.  IT IS ALSO USED BY IHCFDUMP
*    TO FORMAT THE CORE DUMP OUTPUT RECORDS.
*
* ENTRY POINTS--
*    ADCON= IS THE INITIAL LOCATION IN A TABLE OF ADDRESS
*    CONSTANTS FOR THE VARIOUS INPUT/OUTPUT CONVERSION ROUTINES.
*    THESE ROUTINES MAY BE REFERENCED AS FOLLOWS--
*	      LA   2,CORE	  LEFT-MOST BYTE OF ITEM IN CORE
*	      LA   3,BUFFER	  LEFT-MOST BYTE OF SPACE IN BUFFER
*	      L    1,=V(ADCON=)
*	      L    1,D(1)	  REGISTER 1 IS DESTROYED BY ROUTINE
*	      BALR 0,1
*	      DC   XL2'LLWW'	  FOR Z, A, L, I CONVERSIONS
*		 OR
*	      DC   XL4'LLWWDDSS'  FOR F, E, D, G, AND COMPLEX
*    WHERE 'LL' = LENGTH(IN BYTES) OF THE CORE ITEM
*	   'WW' = WIDTH (IN BYTES) OF THE BUFFER SPACE
*	   'DD' = NUMBER OF PLACES TO RIGHT OF DECIMAL POINT
*	   'SS' = SCALE FACTOR (EXTERNAL VALUE = INTERNAL * 10**SS)
*    AND 'D' VARIES ACCORDING TO THE ROUTINE DESIRED.
*
*	ROUTINE   'D'	 FUNCTION
*	.......   ...	..............................................
*	FCVFI	   0	 READS REAL DATA WITHOUT AN EXTERNAL EXPONENT
*	FCVFO	   4	 WRITES REAL DATA WITHOUT AN EXTERNAL EXPONENT
*	FCVEI	   8	 READS REAL DATA WITH AN EXTERNAL EXPONENT
*	FCVEO	  12	 WRITES REAL DATA WITH AN EXTERNAL EXPONENT
*	FCVLI	  24	 READS LOGICAL DATA
*	FCVLO	  28	 WRITES LOGICAL DATA
*	FCVII	  40	 READS INTEGER DATA
*	FCVIO	  44	 WRITES INTEGER DATA
*	FCVGI	  56	 READS REAL DATA
*	FCVGO	  60	 WRITES REAL DATA, USING F OR E OUTPUT
*	FCVCI	  72	 READS COMPLEX DATA
*	FCVCO	  76	 WRITES COMPLEX DATA
*	FCVAI	  80	 READS ALPHAMERIC DATA
*	FCVAO	  84	 WRITES ALPHAMERIC DATA
*	FCVZI	  88	 READS HEXADECIMAL DATA
*	FCVZO	  92	 WRITES HEXADECIMAL DATA
*
* INPUT--INPUT CONSISTS OF PARAMETERS PASSED BY THE CALLING ROUTINES,
*    AND DATA CONTAINED IN CORE OR BUFFERS.
*
* OUTPUT--OUTPUT CONSISTS OF CONVERTED DATA IN CORE OR BUFFERS.
*
* EXTERNAL ROUTINES--IHCFCOMH, TO HANDLE ERROR PROCESSING.
*
* EXITS--
*    NORMAL--RETURN IS TO THE CALLING ROUTINE VIA REGISTER 1,
*    USING THE ORIGINAL CONTENTS OF REGISTER 0.
*    ERROR--A CALL IS MADE TO IHCFCOMH TO WRITE AN ERROR MESSAGE
*    AND TERMINATE EXECUTION.
*
* TABLES/WORK AREAS--
*    'ETABHX' - POWERS OF 10 FROM 0 TO 9 IN SINGLE-PRECISION
*		FLOATING POINT (HEXADECIMAL REPRESENTATION).
*    'ETABHT' - TENS' POWERS OF 10 FROM 10 TO 70 IN DOUBLE-PRECISION
*		FLOATING POINT (HEXADECIMAL REPRESENTATION).
*    'SAVER' - REGISTER STORAGE AREA USED BY THE FORMAT CONVERSION
*	       PACKAGE.
*
* ATTRIBUTES--THIS MODULE IS NOT REENTRANT, BUT IS SERIALLY REUSABLE.
*
* NOTES--
*    1. ALL CALLING SEQUENCES TO IHCFCVTH ARE NON-STANDARD.
*    2. IHCFCVTH USES ITS OWN INTERNAL REGISTER SAVE AREAS,
*	RATHER THAN STORING REGISTERS IN THE CALLING PROGRAM.
*
	 EJECT
* REGISTER DEFINITIONS
R	 EQU	   14		       RETURN REGISTER
L	 EQU	   15		       LINKAGE REGISTER
GRX	 EQU	   2		       FIRST ARGUMENT
GRY	 EQU	   3		       SECOND ARGUMENT
INDEX	 EQU	   5		       PARAMETER LOCATOR
COUNT	 EQU	   4		       COUNT FOR MOVE
WIDTH	 EQU	   6		       BUFFER POSITIONS
CALLBY	 EQU	   4		       INTERNAL CALLS
DECCTR	 EQU	   7		       NUMBER OF DECIMALS
SPLCTR	 EQU	   8		       OVERFLOW COUNTER
CALLIN	 EQU	   9		       INTERNAL CALLS
DATUM1	 EQU	   10		       HIGH-ORDER BINARY NUMBER
DATUM2	 EQU	   11		       LOW-ORDER BINARY NUMBER
BASEC	 EQU	   12		       BASE REGISTER
RESULT	 EQU	   2		       FLOATED DATUM
SCALE	 EQU	   4		       SCALING CONSTANT
NUMBER	 EQU	   7		       BINARY INTEGER
FLOAT	 EQU	   6		       WORK REGISTER
FACTOR	 EQU	   2		       SCALING INDICATOR
CHRSAV	 EQU	   9		       POINTER TO CONVERT AREA
MAXIM	 EQU	   13		       MAXIMUM NUMBER OF DIGITS
ROUNDR	 EQU	   10		       ROUNDING POSITION
DIGRND	 EQU	   11		       ROUNDING REGISTER
MINIM	 EQU	   10		       MINIMUM SPACE REQUIRED
MOVER	 EQU	   11		       NUMBER OF DIGITS TO MOVE
HEXPTR	 EQU	   7		       POINTER TO TRANSLATE AREA
HEXCTR	 EQU	   8		       NUMBER OF HEX DIGITS IN BYTE
BASEH	 EQU	   8		       BASE FOR HALF COMPUTE
BASEG	 EQU	   4		       BASE FOR G-CONVERSION
	 SPACE	   3
* BRANCHING CONDITIONS
ALWAYS	 EQU	   15		       UNCONDITIONAL
HIGH	 EQU	   2		       HIGH
LOW	 EQU	   4		       LOW
EQUAL	 EQU	   8		       EQUAL
NOTEQ	 EQU	   7		       NOT EQUAL
HIEQ	 EQU	   10		       HIGH OR EQUAL
LOEQ	 EQU	   12		       LOW OR EQUAL
PLUS	 EQU	   2		       PLUS
MINUS	 EQU	   4		       MINUS
ZERO	 EQU	   8		       ZERO
NZERO	 EQU	   7		       NOT ZERO
ZPLUS	 EQU	   10		       ZERO OR PLUS
ZMINUS	 EQU	   12		       ZERO OR MINUS
ALL	 EQU	   1		       ALL BITS ON
NONE	 EQU	   8		       NO BITS ON
ANYALL	 EQU   5		      ANY OR ALL BITS ON	   6087
OVER	 EQU	   1		       OVERFLOW
UNDER	 EQU	   14		       NO OVERFLOW
	 SPACE	   3
* MISCELLANEOUS CODES
ON	 EQU	   X'FF'	       ON CONDITION
OFF	 EQU	   X'00'	       OFF CONDITION
DIGSW	 EQU	   X'80'	       DIGIT ENCOUNTERED
NEGDIG	 EQU	   X'40'	       NEGATIVE NUMBER
DECSW	 EQU	   X'20'	       DECIMAL POINT ENCOUNTERED
EXPSW	 EQU	   X'10'	       EXPONENT ENCOUNTERED
NODEC	 EQU	   X'DF'	       RESET FOR NO DECIMALS
NEGEXP	 EQU	   X'08'	       NEGATIVE EXPONENT
NEGSCL	 EQU	   X'04'	       NEGATIVE SCALING
NOEXP	 EQU	   X'02'	       CONVERSION WITHOUT EXPONENT
EDEXP	 EQU	   X'01'	       CONVERSION WITH EXPONENT
POSSCL	 EQU	   X'04'	       POSITIVE SCALING
DIGDEC	 EQU	   X'A0'	       BEGIN DIGITS WITH DECIMAL
THRTNUSR EQU   184		       OFFSETS INTO IBCOM FOR A) REG.
FRTNUSR  EQU   124		       13 IN IBCOM SAVE AREA B) REG 14
IBCSV	 EQU   X'C4'		       IN SAME PLACE. AND IBCOM 2ND S.A
	 EJECT
*
* CONVERSION ADCONS ACCORDING TO MODE / TYPE
*
ADCON=	 DS	   0F
	 DC	   AL4(FCVFI)	       0 - INPUT
	 DC	   AL4(FCVFO)	       0 - OUTPUT
	 DC	   AL4(FCVEI)	       1 - INPUT
	 DC	   AL4(FCVEO)	       1 - OUTPUT
	 DC	   AL4(FCVLI)	       2 - INPUT
	 DC	   AL4(FCVLO)	       2 - OUTPUT
	 DC	   AL4(FCVLI)	       3 - INPUT
	 DC	   AL4(FCVLO)	       3 - OUTPUT
	 DC	   AL4(FCVII)	       4 - INPUT
	 DC	   AL4(FCVIO)	       4 - OUTPUT
	 DC	   AL4(FCVII)	       5 - INPUT
	 DC	   AL4(FCVIO)	       5 - OUTPUT
	 DC	   AL4(FCVGI)	       6 - INPUT
	 DC	   AL4(FCVGO)	       6 - OUTPUT
	 DC	   AL4(FCVGI)	       7 - INPUT
	 DC	   AL4(FCVGO)	       7 - OUTPUT
	 DC	   AL4(FCVCI)	       8 - INPUT
	 DC	   AL4(FCVCO)	       8 - OUTPUT
	 DC	   AL4(FCVCI)	       9 - INPUT
	 DC	   AL4(FCVCO)	       9 - OUTPUT
	 DC	   AL4(FCVAI)	       10 - INPUT
	 DC	   AL4(FCVAO)	       10 - OUTPUT
	 DC	   AL4(FCVZI)	       11 - INPUT
	 DC	   AL4(FCVZO)	       11 - OUTPUT
*
	 EJECT
*
FCVAI	 DS	   0H
	 USING	   *,1
	 STM	   2,6,SAVER	       SAVE REGISTERS
	 LR	   INDEX,0	       GET ADDRESS OF PARAMETERS
	 SR	   COUNT,COUNT
	 SR	   WIDTH,WIDTH
	 IC	   COUNT,0(0,INDEX)    PICKUP ITEM LENGTH
	 IC	   WIDTH,1(0,INDEX)	  AND FORMAT WIDTH.
	 SR	   WIDTH,COUNT
	 BC	   MINUS,MOVER1        BRANCH IF LENGTH IS HIGH
	 AR	   GRY,WIDTH
MOVEAI	 BCTR	   COUNT,0
	 EX	   COUNT,MOVEY	       MOVE CHARACTERS TO ITEM
	 LTR	   WIDTH,WIDTH
	 BC	   ZPLUS,EXITA	       BRANCH IF LENGTH LOW OR EQUAL
	 LPR	   WIDTH,WIDTH
	 LA	   GRX,1(COUNT,GRX)
BLANK1	 MVI	   0(GRX),C' '	       BLANK EXCESS LENGTH
	 LA	   GRX,1(0,GRX)
	 BCT	   WIDTH,BLANK1
EXITA	 LM	   2,6,SAVER	       RESTORE REGISTERS
	 LR	   1,0
	 BC	   ALWAYS,2(0,1)       RETURN TO CALLER
MOVER1	 IC	   COUNT,1(0,INDEX)
	 BC	   ALWAYS,MOVEAI
*
	 SPACE	   3
*
FCVAO	 DS	   0H
	 USING	   *,1
	 STM	   2,6,SAVER	       SAVE REGISTERS
	 LR	   INDEX,0	       GET ADDRESS OF PARAMETERS
	 SR	   COUNT,COUNT
	 SR	   WIDTH,WIDTH
	 IC	   COUNT,0(0,INDEX)    PICKUP ITEM LENGTH
	 IC	   WIDTH,1(0,INDEX)	  AND FORMAT WIDTH.
	 SR	   WIDTH,COUNT
	 BC	   ZMINUS,MOVER2       BRANCH IF LENGTH HIGH OR EQUAL
BLANK2	 MVI	   0(GRY),C' '	       BLANK EXCESS WIDTH
	 LA	   GRY,1(0,GRY)
	 BCT	   WIDTH,BLANK2
MOVEAO	 BCTR	   COUNT,0
	 EX	   COUNT,MOVEX	       MOVE CHARACTERS TO BUFFER
	 LM	   2,6,SAVER	       RESTORE REGISTERS
	 LR	   1,0
	 BC	   ALWAYS,2(0,1)       RETURN TO CALLER
MOVER2	 IC	   COUNT,1(0,INDEX)
	 BC	   ALWAYS,MOVEAO
*
	 EJECT
*
FCVLI	 DS	   0H
	 USING	   *,1
	 STM	   2,6,SAVER	       SAVE REGISTERS
	 LR	   INDEX,0	       GET ADDRESS OF PARAMETERS
	 SR	   WIDTH,WIDTH
	 IC	   WIDTH,1(0,INDEX)    PICKUP FORMAT WIDTH
	 SR	   COUNT,COUNT	       INITIALIZE FOR FALSE
LOGSCN	 CLI	   0(GRY),C'T'
	 BC	   EQUAL,TRUEI	       CHARACTER IS T
	 CLI	   0(GRY),C'F'
	 BC	   EQUAL,FALSE	       CHARACTER IS F
	 LA	   GRY,1(0,GRY)        UPDATE BUFFER POSITION
	 BCT	   WIDTH,LOGSCN        TEST FORMAT WIDTH
FALSE	 TM	   0(INDEX),X'04'      CHECK LENGTH OF ITEM
	 BC	   NONE,PUTONE
	 MVI   INT6SW,X'FF'	       SET SWITCH ON TO ALLOW	   4648X
			     HANDLING OF ANY BOUNDARY MISALIGNMENT.
	 ST	   COUNT,0(0,GRX)      FOUR-BYTE LOGICAL
	 MVI   INT6SW,X'00'		 RESET SWITCH		   4648
EXITLI	 LM	   2,6,SAVER	       RESTORE REGISTERS
	 LR	   1,0
	 BC	   ALWAYS,2(0,1)       RETURN TO CALLER
PUTONE	 STC	   COUNT,0(0,GRX)      ONE-BYTE LOGICAL
	 BC	   ALWAYS,EXITLI
TRUEI	 LA	   COUNT,1	       RESET FOR TRUE
	 BC	   ALWAYS,FALSE
*
	 SPACE	   3
*
FCVLO	 DS	   0H
	 USING	   *,1
	 STM	   2,6,SAVER	       SAVE REGISTERS
	 LR	   INDEX,0	       GET ADDRESS OF PARAMETERS
	 SR	   WIDTH,WIDTH
	 IC	   WIDTH,1(0X)    PICKUP FORMAT WIDTH
BLANKL	 MVI	   0(GRY),C' '	       FILL FIELD WITH BLANKS
	 LA	   GRY,1(0,GRY)
	 BCT	   WIDTH,BLANKL
	 BCTR	   GRY,0	       BACKUP ONE IN BUFFER
	 TM	   0(INDEX),X'04'      CHECK LENGTH OF ITEM
	 BC	   NONE,GETONE
	 MVI   INT6SW,X'FF'	       SET SWITCH ON TO ALLOW	   4648X
			     HANDLING OF ANY BOUNDARY MISALIGNMENT.
	 L	   COUNT,0(0,GRX)      FOUR-BYTE LOGICAL
	 MVI   INT6SW,X'00'		 RESET SWITCH		   4648
LOGTST	 LTR	   COUNT,COUNT
	 BC	   NZERO,TRUEO	       BRANCH IF TRUE
	 MVI	   0(GRY),C'F'	       SET CHARACTER F IN BUFFER
EXITLO	 LM	   2,6,SAVER	       RESTORE REGISTERS
	 LR	   1,0
	 BC	   ALWAYS,2(0,1)       RETURN TO CALLER
GETONE	 SR	   COUNT,COUNT
	 IC	   COUNT,0(0,GRX)      ONE-BYTE LOGICAL
	 BC	   ALWAYS,LOGTST
TRUEO	 MVI	   0(GRY),C'T'	       SET CHARACTER T IN BUFFER
	 BC	   ALWAYS,EXITLO
*
	 EJECT
*
FCVZI	 DS	   0H
	 USING	   *,1
	 STM   2,9,SAVER	       SAVE REGISTERS
	 LR	   INDEX,0	       GET ADDRESS OF PARAMETERS
	 SR	   COUNT,COUNT
	 SR	   WIDTH,WIDTH
	 IC	   COUNT,0(0,INDEX)    PICKUP ITEM LENGTH
	 IC	   WIDTH,1(0,INDEX)	  AND FORMAT WIDTH.
	 AR	   GRX,COUNT	       POINT TO RIGHT END OF ITEM
	 AR	   GRY,WIDTH	       POINT TO RIGHT END OF BUFFERAREA
	 MVI	   SWITCH,OFF	       INITIALIZE SIGN SWITCH
GETTWO	 LA	   HEXPTR,TRANS+3      POINT TO TRANSLATE AREA
	 LA	   HEXCTR,2	       CONVERT TWO INPUT DIGITS
HEXSCN	 LTR	   WIDTH,WIDTH
	 BC	   ZMINUS,ZEROA        BRANCH IF WIDTH EXHAUSTED
	 BCTR	   GRY,0	       MOVE LEFT ONE BYTE IN BUFFER
CHKNUM	 EQU   *
	 CLI	   0(GRY),C'0'	       IS CHARACTER A NUMBER
	 BC	   LOW,NOTDEC
	 CLI	   0(GRY),C'9'
	 BC	   HIGH,NOTDEC
	 MVC	   0(1,HEXPTR),0(GRY)  YES, USE UNTRANSLATED.
HEXNUM	 BCTR	   WIDTH,0	       DECREMENT WIDTH
	 BCTR	   HEXPTR,0	       MOVE LEFT IN TRANSLATE AREA
	 BCT	   HEXCTR,HEXSCN       BRANCH IF ONE DIGIT REMAINS
	 PACK	   TRANS(2),TRANS+2(3) PACK THE TWO DIGITS IN ONE BYTE
	 BCTR	   GRX,0	       MOVE LEFT ONE BYTE IN ITEM
	 MVC	   0(1,GRX),TRANS      MOVE PACKED BYTE INTO ITEM
	 BCT	   COUNT,GETTWO
HEXOUT	 TM	   SWITCH,ON	       WAS DATUM NEGATIVE
	 BC	   NONE,EXITZI	       NO
	 OI	   0(GRX),X'80'        YES, SET SIGN.
EXITZI	 LM    2,9,SAVER	       RESTORE REGISTERS
	 LR	   1,0
	 BC	   ALWAYS,2(0,1)       RETURN TO CALLER
*
NOTDEC	 CLI	   0(GRY),C'A'
	 BC	   LOW,NOTHEX
	 CLI	   0(GRY),C'F'
	 BC	   HIGH,NOTHEX
	 MVC	   0(1,HEXPTR),0(GRY)  CHARACTER IS A,B,C,D,E,F
	 TR	   0(1,HEXPTR),ALPHA-193  TRANSLATE TO HEX
	 BC	   ALWAYS,HEXNUM
SAVER1	 DS    F	 SAVE FOR REGISTER 4 FOR ADDR PROBLEM  MISDAT
*
NOTHEX	 CLI	   0(GRY),C' '
	 BC	   EQUAL,HEXBLK        CHARACTER IS A BLANK
	 CLI	   0(GRY),C'+'
	 BC	   EQUAL,ZEROA	       CHARACTER IS PLUS
	 CLI	   0(GRY),X'50'
	 BC	   EQUAL,ZEROA	       CHARACTER IS A BCD PLUS
	 CLI	   0(GRY),C'-'
	 BC	   EQUAL,HEXNEG        CHARACTER IS MINUS
	 ST    4,SAVER1     SAVE REGISTER 4		       MISDAT
	 LA    4,MSG	  LOAD ADDRESS OF MSG		       MISDAT
	 MVI	8(4),C'2'   INDICATE MESSAGE IHC225	       MISDAT
	 MVC   30(11,4),HXDCML	 MOVE 'HEXADECIMAL' TO MSG     MISDAT
	 L     4,SAVER1      RESTORE REGISTER		       MISDAT
	 MVI   ERRORNO+3,225	       INDICATE IT IS ERROR 225
	 LA    CALLIN,CHKNUM	       SET RETURN POINT
	 STM   12,1,FPSAV3	       SAVE REGS
	 B     COMINTFC
*
HEXBLK	 MVI	   0(HEXPTR),C'0'      TREAT BLANK LIKE ZERO
	 BC	   ALWAYS,HEXNUM
HEXNEG	 MVI	   SWITCH,ON	       SET SWITCH FOR NEGATIVE
*
ZEROA	 BCT	   HEXCTR,ZEROB        BRANCH IF BYTE WAS PACKED
	 NI	   TRANS+3,X'0F'       CLEAR LEFTMOST DIGIT
	 BCTR	   GRX,0
	 MVC	   0(1,GRX),TRANS+3    MOVE THE BYTE INTO ITEM
	 BCT	   COUNT,ZEROB
	 BC	   ALWAYS,HEXOUT       BRANCH IF ITEM EXHAUSTED
ZEROB	 BCTR	   GRX,0
	 MVI	   0(GRX),X'00'        PAD ITEM WITH ZEROS
	 BCT	   COUNT,ZEROB
	 BC	   ALWAYS,HEXOUT       BRANCH IF ITEM EXHAUSTED
*
	 SPACE	   3
*
FCVZO	 DS	   0H
	 USING	   *,1
	 STM   2,6,SAVEC	       SAVE REGISTERS
*    IMPORTANT NOTE  THE Z OUTPUT ROUTINE CANNOT SAVE ITS REGISTERS
*		     IN THE SAME AREA AS Z INPUT OR I INPUT SINCE BOTH
*		     OF THESE ROUTINE CAN CALL THE ERROR MONITOR AND
*		     THE ERROR MONITOR USES THE Z OUTPUT ROUTINE
	 LR	   INDEX,0	       GET ADDRESS OF PARAMETERS
	 SR	   COUNT,COUNT
	 SR	   WIDTH,WIDTH
	 IC	   COUNT,0(0,INDEX)    PICKUP ITEM LENGTH
	 IC	   WIDTH,1(0,INDEX)	  AND FORMAT WIDTH.
	 AR	   GRX,COUNT	       POINT TO RIGHT END OF ITEM
	 AR	   GRY,WIDTH	       POINT TO RIGHT END OF BUFFERAREA
NEXT	 BCTR	   GRX,0	       MOVE LEFT ONE BYTE IN ITEM
	 BCTR	   GRY,0	       MOVE LEFT ONE BYTE IN BUFFER
	 UNPK	   TRANS+1(3),0(2,GRX) UNPACK ONE BYTE OF ITEM
	 TR	   TRANS+1(2),DECIM-240   TRANSLATE TWO HEX DIGITS
	 MVC	   0(1,GRY),TRANS+2    MOVE ONE DIGIT INTO BUFFER
	 BCT	   WIDTH,NEXTA
	 BC	   ALWAYS,EXITZO       FORMAT WIDTH EXHAUSTED
NEXTA	 BCTR	   GRY,0	       MOVE LEFT ONE BYTE IN BUFFER
	 MVC	   0(1,GRY),TRANS+1    MOVE ONE DIGIT INTO BUFFER
	 BCT	   WIDTH,NEXTB
	 BC	   ALWAYS,EXITZO       FORMAT WIDTH EXHAUSTED
NEXTB	 BCT	   COUNT,NEXT
BLANKR	 BCTR	   GRY,0	       ITEM EXHAUSTED,
	 MVI	   0(GRY),C' '		  FILL IN BLANKS TO
	 BCT	   WIDTH,BLANKR 	  START OF BUFFER AREA.
EXITZO	 LM    2,6,SAVEC	       RESTORE REGISTERS
	 LR	   1,0
	 BC	   ALWAYS,2(0,1)       RETURN TO CALLER
*
	 EJECT
*
FCVII	 DS	   0H
	 USING	   *,1
	 STM	   2,12,SAVER	       SAVE REGISTERS
	 BAL	   CALLBY,SCNCVB       SCAN AND CONVERT TO BINARY
	 TM	   SWITCH,NEGDIG       WAS DATUM NEGATIVE
	 BC	   NONE,CHECKI	       NO
	 LNR	   DATUM2,DATUM2       YES, SET SIGN.
CHECKI	 TM    0(INDEX),X'05'	       CHECK LENGTH OF ITEM	   4648
	 MVI   INT6SW,X'FF'	       SET SWITCH ON TO ALLOW	   4648X
			     HANDLING OF ANY BOUNDARY MISALIGNMENT.
	 BC	   NONE,STHALF
	 TM    0(INDEX),X'04'					   4648
	 BC    NONE,STCHAR					   4648
	 ST	   DATUM2,0(0,GRX)     FULL-WORD INTEGER
EXITII	 LM	   2,12,SAVER	       RESTORE REGISTERS
	 MVI   INT6SW,X'00'		 RESET SWITCH		   4648
	 LR	   1,0
	 BC	   ALWAYS,2(0,1)       RETURN TO CALLER
STHALF	 STH	   DATUM2,0(0,GRX)     HALF-WORD INTEGER
	 BC	   ALWAYS,EXITII
STCHAR	 STC   DATUM2,0(0,GRX)	       ONE-BYTE INTEGER (FOR	   4648X
			     CONVERSION OF 1-BYTE LOGICAL WITH I-FMT)
	 BC    ALWAYS,EXITII					   4648
*
SCNCVB	 BALR	   BASEC,0	       LOAD BASE REGISTER
	 USING	   *,BASEC
	 LR	   INDEX,0	       PREPARE TO ADDRESS PARAMETERS
	 SR	   WIDTH,WIDTH
	 SR	   DECCTR,DECCTR
	 STM	   WIDTH,DECCTR,DIGIT  CLEAR DIGIT AND EXPONENT
	 IC	   WIDTH,1(0,INDEX)    PICKUP WIDTH
	 IC	   DECCTR,2(0,INDEX)	  AND NUMBER OF DECIMALS.
	 SR	   SPLCTR,SPLCTR       INITIALIZE SPILL COUNTER
	 SR	   DATUM1,DATUM1
	 SR	   DATUM2,DATUM2
	 STM	   DATUM1,DATUM2,DATUM	  N = 0
	 MVI	   SWITCH,OFF	       INITIALIZE SCAN SWITCHES
	 MVI   BTEST,ON    INITIALIZE BLANK FIELD FLAG	       MISDAT
CNTSCN	 CLI	   0(GRY),C'0'	       IS CHARACTER A NUMBER
	 BC	   LOW,NOTNUM
	 CLI	   0(GRY),C'9'
	 BC	   HIGH,NOTNUM
	 MVI   BTEST,OFF   TURN OFF BLANK FIELD FLAG	       MISDAT
	 OI	   SWITCH,DIGSW        YES, SET DIGIT ENCOUNTERED.
	 MVN	   DIGIT+3(1),0(GRY)
GETNUM	 CL	   DATUM1,HIBYTE       WILL LEFT SHIFT CAUSE OVERFLOW
	 BC	   HIGH,SPILIT	       YES, BRANCH.
	 SLDL	   DATUM1,3	       N * 10
	 BAL	   CALLIN,FXDPAD
	 BAL	   CALLIN,FXDPAD
	 AL	   DATUM2,DIGIT        ADD NEW DIGIT TO N
	 BC    12,OKAY1 					   8137
	 AH	   DATUM1,CONONE       OVERFLOW, CARRY ONE.
OKAY1	 STM	   DATUM1,DATUM2,DATUM SAVE N
SETDEC	 TM	   SWITCH,DECSW        DECIMAL POINT ENCOUNTERED
	 BC	   NONE,SCNRET	       NO
	 MVI   BTEST,OFF   TURN OFF BLANK FIELD FLAG	       MISDAT
	 LA	   DECCTR,1(0,DECCTR)  YES, BUMP DECIMAL COUNTER.
SCNRET	 LA	   GRY,1(0,GRY)        UPDATE BUFFER POSITION
	 BCT	   WIDTH,CNTSCN        TEST FORMAT WIDTH
	 TM	   SWITCH,EXPSW        WAS EXPONENT ENCOUNTERED
	 BCR	   NONE,CALLBY	       NO
	 TM	   SWITCH,NEGEXP       WAS EXPONENT NEGATIVE
	 BC	   NONE,SETEXP	       NO
	 LNR	   DATUM2,DATUM2       YES, SET SIGN.
SETEXP	 ST	   DATUM2,EXPON        STASH EXPONENT
	 LM	   DATUM1,DATUM2,INTGER   RESTORE N
	 BCR	   ALWAYS,CALLBY
*
FXDPAD	 AL	   DATUM2,DATUM+4      LOW-ORDER ADD
	 BC    12,OKAY2 	       BRANCH IF NO CARRY	   8137
	 AH	   DATUM1,CONONE       OVERFLOW, CARRY ONE.
	 BC	   OVER,SPILIT	       DATUM GT 2**64 - 1
OKAY2	 A	   DATUM1,DATUM        HIGH-ORDER ADD
	 BCR	   UNDER,CALLIN
SPILIT	 LM	   DATUM1,DATUM2,DATUM PICKUP MAXIMUM NUMBER,
	 LA	   SPLCTR,1(0,SPLCTR)	  AND BUMP SPILL COUNTER.
	 BC	   ALWAYS,SETDEC
*
NOTNUM	 CLI	   0(GRY),C' '
	 BC	   EQUAL,BLANK	       CHARACTER IS A BLANK
	 CLI	   0(GRY),C'.'
	 BC	   EQUAL,DECPNT        CHARACTER IS DECIMAL POINT
	 CLI	   0(GRY),C'E'
	 BC	   EQUAL,ECHAR	       CHARACTER IS 'E'
	 CLI	   0(GRY),C'D'
	 BC	   EQUAL,ECHAR	       CHARACTER IS 'D'
	 CLI	   0(GRY),C'+'
	 BC	   EQUAL,PLUSS	       CHARACTER IS PLUS
	 CLI	   0(GRY),X'50'
	 BC	   EQUAL,PLUSS	       CHARACTER IS A BCD PLUS
	 CLI	   0(GRY),C'-'
	 BC	   EQUAL,MINUSS        CHARACTER IS MINUS
BADCHR	 EQU   *
	 MVI   MSG+8,C'1'	       INDICATE MESSAGE 215
	 MVC   MSG+30(11),DCML	       MOVE 'DECIMAL' TO MESSAGE
	 MVI   ERRORNO+3,215	       SET ERROR NUMBER TO 215
	 LA    CALLIN,CNTSCN	       SET RETURN POINT
	 STM   12,1,FPSAV3	       SAVE REGS
COMINTFC EQU   *
	 BALR  12,0		       SET UP ADDRESSABILITY
	 USING *,12
	 L     15,CIBCOM
	 L     13,THRTNUSR(0,15)       GET ADDR. OF USER'S SAVE AREA
	 MVC   12(16,13),FRTNUSR(15)	MOVE HIS REGS 14-1 TO HIS AREA
	 ST    13,IBCSV+4(0,15)        LINK HIS SAVE AREA TO IBCOM'S
	 LA    13,IBCSV(0,15)
	 LA    1,PRMS		       SET UP PARAMETER LIST ADDRESS
	 ST    GRY,12(0,1)	       PUT ADDRESS OF BAD CHARACTER IN
	 MVI   12(1),X'80'	       PARAMETER LIST(SET LAST IND.)
	 MVC   MSG+52(1),0(GRY)        MOVE BAD CHAR. TO MESSAGE
	 L     15,VIHCERRM	       CALL THE ERROR MONITOR
	 BALR  14,15
	 L     13,RETCD 	       DID USER FIX UP THE DATA%
	 LTR   13,13
	 LM    12,1,FPSAV3	       RESTORE REGS.
	 USING SCNCVB+2,12
	 BCR   7,CALLIN 	       YES, RETURN
	 MVI   0(GRY),C'0'	       NO, SET CHAR TO ZERO
	 BR    CALLIN		       RETURN
*
BLANK	 TM	   SWITCH,DIGSW        WAS DIGIT ENCOUNTERED
	 BC    1,BYPASS    YES				       MISDAT
	 MVI   BTEST,ON    (NO) TURN FLAG ON		       MISDAT
	 BC    ALWAYS,SCNRET				       MISDAT
BYPASS	 MVI   DIGIT+3,X'00'	YES, TREAT BLANK LIKE ZERO     MISDAT
	 BC	   ALWAYS,GETNUM
DECPNT	 TM    SWITCH,DECSW+EXPSW      ERROR IF DECIMAL POINT OR   6087
	 BC    ANYALL,BADCHR	       EXPONENT WAS ENCOUNTERED.   6087
	 OI	   SWITCH,DIGDEC       NO, SET SWITCH.
	 SR	   DECCTR,DECCTR       INITIALIZE DECIMAL COUNTER
	 BC	   ALWAYS,SCNRET
ECHAR	 TM	   SWITCH,EXPSW        WAS EXPONENT ENCOUNTERED
	 BC	   ALL,BADCHR	       YES
ESAME	 OI	   SWITCH,EXPSW        NO, SET SWITCH.
	 MVC	   INTGER(8),DATUM     SAVE N
	 SR	   DATUM1,DATUM1
	 SR	   DATUM2,DATUM2
	 STM	   DATUM1,DATUM2,DATUM INITIALIZE FOR EXPONENT
	 NI	   SWITCH,NODEC
	 BC	   ALWAYS,SCNRET
PLUSS	 TM	   SWITCH,DIGSW        WAS DIGIT ENCOUNTERED
	 BC	   NONE,SCNRET	       NO
SSAME	 TM	   SWITCH,EXPSW        WAS EXPONENT ENCOUNTERED
	 BC	   ALL,SCNRET	       YES
	 BC	   ALWAYS,ESAME        NO, TREAT AS 'E'.
MINUSS	 TM	   SWITCH,DIGSW        WAS DIGIT ENCOUNTERED
	 BC	   ALL,ESIGN	       YES
	 OI	   SWITCH,NEGDIG       NO, SET NUMBER NEGATIVE.
	 BC	   ALWAYS,SCNRET
ESIGN	 OI	   SWITCH,NEGEXP       SET EXPONENT NEGATIVE
	 BC	   ALWAYS,SSAME
	 DROP	   BASEC
*
	 EJECT
*
FCVFI	 DS	   0H
FCVEI	 DS	   0H
FCVDI	 DS	   0H
FCVGI	 DS	   0H
	 USING	   *,1
	 STM	   2,13,SAVER	       SAVE REGISTERS
	 STD	   2,FPSAV1
	 STD	   4,FPSAV2
	 LR	   13,15
	 L	   L,CIBCOM
	 EX	   0,114(0,L)	       SET SWITCH TO IGNORE INTERRUPTS
	 L	   CALLIN,ADSCAN
	 BALR	   CALLBY,CALLIN       SCAN AND CONVERT TO BINARY
	 LTR	   DATUM2,DATUM2       TEST LOW-ORDER INTEGER
	 BC	   NZERO,STASHI        BRANCH IF NON-ZERO
	 LTR	   DATUM1,DATUM1       TEST HIGH-ORDER INTEGER
	 BC	   NZERO,STASHI        BRANCH IF NON-ZERO
	 SDR	   RESULT,RESULT       SET RESULT = 0
	 BC	   ALWAYS,CHECKS
STASHI	 STM	   DATUM1,DATUM2,INTGER   STASH N IN WORK AREA
	 TM	   INTGER,X'FF'        ROOM FOR CHARACTERISTIC
	 BC	   NONE,SET4E	       YES
	 SRDL	   DATUM1,4	       NO, SHIFT OUT ONE HEX DIGIT.
	 STM	   DATUM1,DATUM2,INTGER
	 TM	   INTGER,X'0F'        ENOUGH ROOM NOW
	 BC	   NONE,SET4F	       YES
	 SRDL	   DATUM1,4	       NO, SHIFT OUT ONE MORE DIGIT.
	 STM	   DATUM1,DATUM2,INTGER
	 MVI	   INTGER,X'50'        SET CHARACTERISTIC OF 16
	 BC	   ALWAYS,FLOATR
SET4F	 MVI	   INTGER,X'4F'        SET CHARACTERISTIC OF 15
	 BC	   ALWAYS,FLOATR
SET4E	 MVI	   INTGER,X'4E'        SET CHARACTERISTIC OF 14
FLOATR	 LD	   RESULT,CONFLT       USING CONSTANT OF 0.0 * 16**14,
	 AD	   RESULT,INTGER	  FLOAT N.
	 SR	   SPLCTR,DECCTR       OVERFLOW COUNT - DECIMAL COUNT
	 A	   SPLCTR,EXPON 	  + INPUT EXPONENT.
	 TM	   SWITCH,EXPSW        WAS THERE AN EXPONENT FIELD
	 BC	   ALL,CHECKX	       YES, IGNORE SCALE FACTOR.
	 MVC	   DIGIT+3(1),3(INDEX)
	 TM	   DIGIT+3,X'80'       TEST SIGN OF SCALE FACTOR
	 BC	   NONE,SFPLUS	       BRANCH IF POSITIVE
	 NI	   DIGIT+3,X'7F'       NEGATIVE, CLEAR SIGN BIT.
	 A	   SPLCTR,DIGIT        INCREMENT EXPONENT
	 BC	   ALWAYS,CHECKX
SFPLUS	 S	   SPLCTR,DIGIT        DECREMENT EXPONENT
CHECKX	 LTR	   SPLCTR,SPLCTR       TEST SIGN OF EXPONENT
	 BC	   ZPLUS,POSEXP        BRANCH IF POSITIVE
	 OI	   SWITCH,NEGSCL       NEGATIVE, SET SWITCH.
POSEXP	 LPR	   DATUM2,SPLCTR       FORCE EXPONENT POSITIVE
	 CH	   DATUM2,EXPMAX       IS EXPONENT VALID
	 BC	   LOEQ,GETEXP	       YES
	 TM	   SWITCH,NEGSCL       CHECK SIGN OF EXPONENT
	 BC	   ALL,SCLMAX	       BRANCH IF NEGATIVE
NOSCAL	 SDR	   RESULT,RESULT       SET RESULT = 0
	 BC	   ALWAYS,CHECKS
SCLMAX	 SH	   DATUM2,DEC19        REDUCE EXPONENT BY 19
	 CH	   DATUM2,EXPMAX
	 BC	   HIGH,NOSCAL	       BRANCH IF STILL TOO HIGH
	 DD	   RESULT,TEN19        SCALE DOWN
GETEXP	 SR	   DATUM1,DATUM1
	 D	   DATUM1,CONTEN       SEPARATE TENS AND UNITS DIGITS
	 SLDA	   DATUM1,2
	 SLA	   DATUM2,1
	 SDR	   SCALE,SCALE
	 LE	   SCALE,ETABHX(DATUM1)   PICKUP 10 ** UNITS
	 LTR	   DATUM2,DATUM2
	 BC	   ZERO,SCALER
	 MD	   SCALE,ETABHT(DATUM2)   MULTIPLY BY 10 ** TENS
SCALER	 TM	   SWITCH,NEGSCL       CHECK SIGN OF EXPONENT
	 BC	   NONE,SCALUP
	 DDR	   RESULT,SCALE        NEGATIVE, SCALE DOWN.
	 BC	   ALWAYS,CHECKS
SCALUP	 MDR	   RESULT,SCALE        POSITIVE, SCALE UP.
CHECKS	 CLI   BTEST,ON    WAS THIS A BLANK FIELD	       MISDAT
	 BNE   CHECKS1	   NO,	 BRANCH 		       MISDAT
	 OI    SWITCH,NEGDIG YES, SET SWITCH FOR -0.0	       MISDAT
	 MVI   BTEST,OFF   RESET BLANK FIELD TEST	       MISDAT
CHECKS1  TM    SWITCH,NEGDIG   IS NUMBER NEGITIVE	       MISDAT
	 BC	   NONE,CHECKF	       NO
	 LNDR	   RESULT,RESULT       YES, SET SIGN.
CHECKF	 TM	   0(INDEX),X'04'      CHECK LENGTH OF ITEM
	 MVI   INT6SW,X'FF'	       SET SWITCH ON TO ALLOW	   4648X
			     HANDLING OF ANY BOUNDARY MISALIGNMENT.
	 BC	   NONE,STDBLE
	 STE	   RESULT,0(0,GRX)     SHORT-PRECISION REAL
EXITFI	 EX	   0,118(0,L)	       RESUME PROCESSING OF INTERRUPTS
	 MVI   INT6SW,X'00'		 RESET SWITCH		   4648
	 LR	   15,13
	 LD	   2,FPSAV1
	 LD	   4,FPSAV2
	 LM	   2,13,SAVER	       RESTORE REGISTERS
	 LR	   1,0
	 BC	   ALWAYS,4(0,1)       RETURN TO CALLER
STDBLE	 STD	   RESULT,0(0,GRX)     LONG-PRECISION REAL
	 BC	   ALWAYS,EXITFI
*
	 EJECT
*
FCVIO	 DS	   0H
	 USING	   *,1
	 STM	   2,7,SAVER	       SAVE REGISTERS
	 LR	   INDEX,0	       GET ADDRESS OF PARAMETERS
	 SR	   WIDTH,WIDTH
	 IC	   WIDTH,1(0,INDEX)    PICKUP FORMAT WIDTH
	 AR	   GRY,WIDTH	       POINT TO RIGHT END OF BUFFERAREA
	 MVI   INT6SW,X'FF'	       SET SWITCH ON TO ALLOW	   4648X
			     HANDLING OF ANY BOUNDARY MISALIGNMENT.
	 TM    0(INDEX),X'05'	       CHECK LENGTH OF ITEM	   4648
	 BC	   NONE,LDHALF
	 TM    0(INDEX),X'04'					   4648
	 BC    NONE,LDCHAR					   4648
	 L	   NUMBER,0(0,GRX)     FULL-WORD INTEGER
	 BC	   ALWAYS,GETSGN
LDHALF	 LH	   NUMBER,0(0,GRX)     HALF-WORD INTEGER
GETSGN	 MVI	   SWITCH,C' '	       ASSUME POSITIVE NUMBER
	 MVI   INT6SW,X'00'		 RESET SWITCH		   4648
	 LTR	   NUMBER,NUMBER
	 BC    ZERO,ZEROINT		INTEGER IS ZERO 	   4640
	 BC    PLUS,CVTDEC		INTEGER IS POSITIVE	   4640
	 MVI	   SWITCH,C'-'	       RESET FOR NEGATIVE NUMBER
CVTDEC	 CVD	   NUMBER,CVAREA       CONVERT TO DECIMAL,
	 UNPK	   CVAREA(15),CVAREA(8)   UNPACKED FORM.
	 OI	   CVAREA+14,X'F0'     SET PROPER ZONING
	 LA	   GRX,CVAREA+15       POINT TO RIGHT END OF NUMBER
	 LA	   INDEX,CVAREA
	 LA	   COUNT,15
ZEROCK	 CLI	   0(INDEX),C'0'       IGNORE LEADING ZEROS
	 BC	   NOTEQ,SIZCHK
	 LA	   INDEX,1(0,INDEX)
	 BCT	   COUNT,ZEROCK
ZEROINT  BCTR  GRY,0		 MOVE LEFT ONE BYTE IN BUFFER	   4640
	 MVI	   0(GRY),C'0'	       STASH A ZERO IN BUFFER
	 BCT	   WIDTH,SETSGN
EXITIO	 LM	   2,7,SAVER	       RESTORE REGISTERS
	 LR	   1,0
	 BC	   ALWAYS,2(0,1)       RETURN TO CALLER
LDCHAR	 SR    NUMBER,NUMBER	       ONE-BYTE INTEGER (FOR	   4648
	 IC    NUMBER,0(0,GRX)	     CONVERSION OF 1-BYTE LOGICAL  4648
	 BC    ALWAYS,GETSGN		 USING I-FORMAT)	   4648
SIZCHK	 CR	   WIDTH,COUNT	       IS FIELD WIDTH ADEQUATE
	 BC	   LOW,STARS1	       NO
	 BC    EQUAL,SIGNCHK		TEST IF NEGATIVE	   4640
SETCHR	 BCTR	   GRX,0	       MOVE LEFT ONE BYTE IN NUMBER
	 BCTR	   GRY,0	       MOVE LEFT ONE BYTE IN BUFFER
	 MVC	   0(1,GRY),0(GRX)     MOVE ONE DIGIT TO BUFFER
	 BCT	   WIDTH,TESTC	       DECREMENT WIDTH
	 BC	   ALWAYS,EXITIO       BRANCH IF EXHAUSTED
TESTC	 BCT	   COUNT,SETCHR        DECREMENT SIGNIFICANT DIGITS
SETSGN	 BCTR	   GRY,0	       MOVE LEFT ONE BYTE IN BUFFER
	 MVC	   0(1,GRY),SWITCH     SET SIGN OF NUMBER
TESTW	 BCT	   WIDTH,STBLNK        DECREMENT WIDTH
	 BC	   ALWAYS,EXITIO       BRANCH IF EXHAUSTED
STBLNK	 BCTR	   GRY,0	       MOVE LEFT ONE BYTE IN BUFFER
	 MVI	   0(GRY),C' '	       STASH LEADING BLANKS
	 BC	   ALWAYS,TESTW
*
SIGNCHK  CLI   SWITCH,C'-'		IS INTEGER NEGATIVE	   4640
	 BC    NOTEQ,SETCHR		NO- FIELD ADEQUATE	   4640
STARS1	 L	   GRY,SAVER+4
STARS2	 MVI	   0(GRY),C'*'	       IF WIDTH WILL NOT ACCOMMODATE
	 LA	   GRY,1(0,GRY) 	  ALL SIGNIFICANT DIGITS,
	 BCT	   WIDTH,STARS2 	  FILL FIELD WITH ASTERISKS.
	 BC	   ALWAYS,EXITIO
*
	 EJECT
*
FCVFO	 DS	   0H
	 USING	   *,1
	 STM	   2,13,SAVER	       SAVE REGISTERS
	 STD	   6,FPSAV3
	 MVI	   SWITCH,NOEXP        SET FOR NO EXPONENT FIELD
	 BAL	   CALLBY,FIXCVD       FIX AND CONVERT TO BCD
	 LD	   6,FPSAV3
	 LM	   2,13,SAVER	       RESTORE REGISTERS
	 LR	   1,0
	 BC	   ALWAYS,4(0,1)       RETURN TO CALLER
*
FIXCVD	 BALR	   BASEC,0	       LOAD BASE REGISTER
	 USING	   *,BASEC
	 LR	   INDEX,0	       PREPARE TO ADDRESS PARAMETERS
	 SR	   WIDTH,WIDTH	       INITIALIZE REGISTERS
	 SR	   DECCTR,DECCTR
	 SR	   SPLCTR,SPLCTR
	 MVI   INT6SW,X'FF'	       SET SWITCH ON TO ALLOW	   4648X
			     HANDLING OF ANY BOUNDARY MISALIGNMENT.
	 TM	   0(INDEX),X'04'      CHECK LENGTH OF ITEM
	 BC	   NONE,LDDBLE
	 SDR	   FLOAT,FLOAT
	 LE	   FLOAT,0(0,GRX)      SHORT-PRECISION REAL
	 BC	   ALWAYS,STASHD
LDDBLE	 LD	   FLOAT,0(0,GRX)      LONG-PRECISION REAL
STASHD	 STD	   FLOAT,DATUM
	 MVI   INT6SW,X'00'		 RESET SWITCH		   4648
	 TM	   DATUM,X'80'	       IS DATUM NEGATIVE
	 MVI   BTEST,X'00'     CLEAR BLANK FIELD FLAG	       MISDAT
	 BC	   NONE,ZERTST	       NO
	 OI    BTEST,NEGDIG	 NO. IS NEGITIVE 1 OF 2        MISDAT
	 OI	   SWITCH,NEGDIG       YES, SET SWITCH
	 NI	   DATUM,X'7F'		  AND CLEAR SIGN BIT.
	 LD	   FLOAT,DATUM	       RELOAD DATUM
ZERTST	 LTDR	   FLOAT,FLOAT
	 BC	   ZERO,ZERDAT	       BRANCH IF DATUM ZERO
	 LR	   9,15
	 L	   L,CIBCOM
	 EX	   0,114(0,L)	       SET SWITCH TO IGNORE INTERRUPTS
*
	 IC    WIDTH,DATUM	       PLACE EXPONENT IN REGISTER
	 N     WIDTH,MASK	       SET EXPONENT IN REGISTER
	 TM    DATUM,X'08'	       CHECK SECOND DIGIT OF EXPONENT
	 BC    NONE,SECTAB		  LESS THAN EIGHT - NO ADJUST.
	 LA    WIDTH,8(WIDTH)		  GREATER - ADJUST TABLE INDEX
SECTAB	 LA    DATUM1,CVTAB(WIDTH)   SET ADDRESS OF SCALING FACTOR
	 MD    FLOAT,0(0,DATUM1)
	 SRA   WIDTH,2		       ADJUST FOR EXPONENT CALCULATION
	 LA    DATUM1,EXPTAX(WIDTH)    LOAD ADDRESS OF EXPONENT TABLE
	 AH    SPLCTR,0(DATUM1)        ADD EXPONENT FROM TABLE
	 STE   FLOAT,DATUM	       STORE AND TEST FOR SPECIAL CASE
UNITSC	 CLI   DATUM,X'48'	       IS DATA NOW LESS THAN 10 ** +9
	 BC    HIEQ,MULNIN		    IT IS GREATER - BRANCH
	 CLI   DATUM,X'39'	       IS DATA NOW LESS THAN 10 ** -9
	 BC    LOEQ,MUMNIN		    IF LESS THEN BRANCH
	 CLI   DATUM,X'3C'
	 BC    EQUAL,MM65
	 CLI   DATUM,X'45'
	 BC    EQUAL,M56
	 IC    WIDTH,DATUM	       NOT A SPECIAL CASE - INSERT
	 N     WIDTH,MASK1		   EXPONENT AND MASK
	 SLL   WIDTH,3		       SHIFT TO SET UP TABLE ADDRESS
MUL	 LA    DATUM1,CVTAB1(WIDTH)    POINT TO PROPER SCALING FACTOR
	 MD    FLOAT,0(0,DATUM1)
	 SRA   WIDTH,2		       ADJUST FOR EXPONENT CALCULATION
	 LA    DATUM1,EXPTAY(WIDTH)    LOAD EXPONENT TABLE ADDRESS
	 AH    SPLCTR,0(DATUM1)        ADD EXPONENT VALUE FROM TABLE
CNDIG	 STE   FLOAT,DATUM
	 CLI   DATUM,X'40'	       CHECK THAT SCALING IS IN BOUNDS
	 BC    NOTEQ,UNITSC		   OUT-OF-BOUNDS - BRANCH
	 CH    SPLCTR,EXPMAX	       IS EXPONENT LARGER THAN MAX
	 BH    DEVELOP	     DONT ROUND FOR EXP GREATER THAN 75   20211
	 AD    FLOAT,ROUNDER	ROUND TO 16 PLACES		  20211
	 CD    FLOAT,CVTAB1    CHECK FOR RIPPLE CARRY		  20211
	 BL    DEVELOP	     BRANCH IF NO RIPPLE		  20211
	 MD    FLOAT,TENTH   YES A RIPPLE ADJUST MANT BY 10	  20211
	 AH    SPLCTR,ONE     AND EXPOMENT BY ONE		  20211
*      FINISHED WITH SCALLING BEGIN TO DEVELOP EBCDIC DIGITS	  20211
DEVELOP  MD    FLOAT,S7      PICK OFF 7 DECIMAL DIGITS		  20211
DBLCVT	 LA    WIDTH,24 	       INITIALIZE POINTER TO CV AREA
	 AW    FLOAT,S0 	       FIX FLOATING VARIABLE
	 STE   FLOAT,DATUM	       STORE FLOATING INTEGER
	 MVI   DATUM,X'00'	       MAKE INTO TRUE INTEGER
	 L     DATUM1,DATUM	       LOAD INTEGER FOR CONVERSION
	 CVD   DATUM1,INTCER(WIDTH)    CONVERT INTO PROPER WORD
	 SH    WIDTH,EIG	       ADJUST POINTER TO NEXT DBL WORD
	 BC    ZERO,UNPK	       EXIT IF DONE
	 LA    DATUM2,INTCER(WIDTH)    DEVELOP ADDRESS OF CV AREA
	 NI    15(DATUM2),X'0F'        ERASE LAST DIGIT
	 CVB   DATUM1,INTCER+8(WIDTH)  DETERMINE CORRECTION VALUE
	 ST    DATUM1,INTCER(WIDTH)    PLACE INTEGER IN SINGLE WORD
	 ST    DECCTR,INTCER+4(WIDTH)  STORE ZEROES TO MAKE DBL WORD
	 MVI   0(DATUM2),X'46'	       MAKE WORD A FLOATING VARIABLE
	 SD    FLOAT,INTCER(WIDTH)     ADJUST WORD BEING CONVERTED
	 MD    FLOAT,S5 	       SCALE HEX DECIMAL TO INTEGER
	 BC    ALWAYS,DBLCVT+4	       REPEAT FOR A TOTAL OF THREE
*
MULNIN	 LA    WIDTH,64 	       SET POINTER TO 10 ** +9
	 BC    ALWAYS,MUL
MUMNIN	 LA    WIDTH,72 	       SET POINTER TO 10 ** -9
	 BC    ALWAYS,MUL
M56	 TM    DATUM+1,X'80'
	 BC    NONE,M5
	 BC    ALWAYS,M6
MM65	 TM    DATUM+1,X'80'
	 BC    NONE,MM6
	 BC    ALWAYS,MM5
M5	 MD    FLOAT,S5M
	 AH    SPLCTR,FIV
	 BC    ALWAYS,CNDIG
M6	 MD    FLOAT,S6M
	 AH    SPLCTR,SIX
	 BC    ALWAYS,CNDIG
MM6	 MD    FLOAT,S6
	 SH    SPLCTR,SIX
	 BC    ALWAYS,CNDIG
MM5	 MD    FLOAT,S5
	 SH    SPLCTR,FIV
	 BC    ALWAYS,CNDIG
*
UNPK	 UNPK  CVAREA(7),INTCER+28(4)  MOVE LEFT PART TO OUTPUT BUILD
	 UNPK  CVAREA+6(6),INTCER+20(4)     OVERLAY ONE,MOVE FOUR
	 UNPK  CVAREA+11(6),INTCER+12(4)    OVERLAY ONE,MOVE FOUR
*
	 EX	   0,118(0,L)	       RESUME PROCESSING OF INTERRUPTS
	 LR	   15,9
	 LA	   CHRSAV,CVAREA       POINT TO START OF CONVERT AREA
	 LA	   MAXIM,16	       SIXTEEN DIGITS MAXIMUM OUTPUT
ZERCHK	 CLI	   0(CHRSAV),C'0'      WAS THERE A LEADING ZERO
	 BC	   NOTEQ,TSTSCL        NO
	 SH	   SPLCTR,CONONE       YES, DECREMENT EXPONENT.
	 LA	   CHRSAV,1(0,CHRSAV)  SKIP LEADING ZERO
	 BCTR	   MAXIM,0
	 BC	   ALWAYS,ZERCHK
TSTSCL	 SR	   FACTOR,FACTOR       INITIALIZE FOR SCALING
	 ST	   FACTOR,EXPON
	 TM	   3(INDEX),X'FF'      WAS THERE A SCALE FACTOR
	 BC	   NONE,NOFACT	       NO
	 MVC	   EXPON+3(1),3(INDEX) YES
	 TM	   EXPON+3,X'80'       TEST SIGN OF SCALE FACTOR
	 BC	   NONE,UPSCAL	       BRANCH IF POSITIVE
	 NI	   EXPON+3,X'7F'       NEGATIVE, CLEAR SIGN BIT.
	 S	   FACTOR,EXPON        DECREMENT EXPONENT
	 BC	   ALWAYS,ADJEXP
UPSCAL	 A	   FACTOR,EXPON        INCREMENT EXPONENT
ADJEXP	 ST	   FACTOR,EXPON
NOFACT	 TM	   SWITCH,EDEXP        WAS THIS F-CONVERSION
	 BC	   ALL,FEDOUT	       NO
	 AR	   FACTOR,SPLCTR       YES, SCALING INCLUDES EXPONENT.
*
FEDOUT	 IC	   WIDTH,1(0,INDEX)    PICKUP WIDTH
	 IC	   DECCTR,2(0,INDEX)	  AND NUMBER OF DECIMALS.
	 TM	   GFSWCH,ON
	 BC	   NONE,POSRND	       BRANCH IF NOT FLOATING DECIMAL
	 SR	   DECCTR,FACTOR
POSRND	 LR	   ROUNDR,FACTOR       COMPUTE POSITION OF ROUND
	 AR	   ROUNDR,DECCTR
	 LTR	   ROUNDR,ROUNDR
	 BC	   MINUS,ROUNDO        BRANCH IF ROUNDING IMPOSSIBLE
	 CH	   ROUNDR,RNDMAX
	 BC	   HIEQ,ROUNDO	       BRANCH IF PAST END OF DIGITS
	 AR	   ROUNDR,CHRSAV
	 CLI	   0(ROUNDR),C'5'
	 BC	   LOW,ROUNDO	       CHARACTER PAST END IS LT 5
CNTRND	 BCTR	   ROUNDR,0
	 CR	   ROUNDR,CHRSAV
	 BC	   LOW,SETONE	       BRANCH IF RIPPLE CARRY COMPLETE
	 CLI	   0(ROUNDR),C'9'
	 BC	   EQUAL,RIPPLE        CHARACTER TO ROUND IS A 9
	 SR	   DIGRND,DIGRND
	 IC	   DIGRND,0(0,ROUNDR)
	 LA	   DIGRND,1(0,DIGRND)  BUMP CHARACTER BY ONE
	 STC	   DIGRND,0(0,ROUNDR)
	 BC	   ALWAYS,ROUNDO
RIPPLE	 MVI	   0(ROUNDR),C'0'      CHARACTER 9 ROUNDS TO 0
	 BC	   ALWAYS,CNTRND
SETONE	 MVI	   0(ROUNDR),C'1'      SET 1 FROM RIPPLE CARRY
	 LR	   CHRSAV,ROUNDR       INCLUDE EXTRA CHARACTER
	 LA	   MAXIM,1(0,MAXIM)
	 AH	   SPLCTR,CONONE       INCREMENT EXPONENT
	 TM	   SWITCH,EDEXP
	 BC	   ALL,ROUNDO
	 AH	   FACTOR,CONONE       F-CONVERSION
	 TM	   GFSWCH,ON
	 BC	   NONE,ROUNDO	       BRANCH IF NOT FLOATING DECIMAL
	 SH	   DECCTR,CONONE
*
ROUNDO	 LA	   MINIM,1(0,DECCTR)   ALLOW FOR POINT AND D DECIMALS
	 LTR	   FACTOR,FACTOR
	 BC	   ZMINUS,EXPCHK       BRANCH IF NO INTEGER PORTION
	 AR	   MINIM,FACTOR        ALLOW FOR INTEGER DIGITS
EXPCHK	 TM	   SWITCH,NOEXP
	 BC	   ALL,MINCHK	       BRANCH IF F-CONVERSION
	 LA	   MINIM,4(0,MINIM)    ALLOW FOR EXPONENT FIELD
MINCHK	 SR	   WIDTH,MINIM	       IS FIELD WIDTH ADEQUATE
	 BC	   MINUS,STARS3        NO
	 BC    EQUAL,SIGNCHK1		CHECK IF MINUS SIGN NEEDED 4640
BUFADJ	 AR    GRY,WIDTH		YES, ADJUST BUFFER	   4640
	 ST	   GRY,BEGPOS
	 LTR	   FACTOR,FACTOR       TEST SCALING
	 BC	   ZERO,ZERFAC	       OUTPUT IS NORMALIZED
	 BC	   PLUS,POSFAC	       OUTPUT HAS INTEGER PORTION
	 LPR	   FACTOR,FACTOR       DECIMAL PORTION HAS LEADING 0'S
	 MVI	   0(GRY),C'.'	       SET DECIMAL POINT
	 LA	   GRY,1(0,GRY)
	 OI	   SWITCH,DECSW
	 LTR	   DECCTR,DECCTR
	 BC	   ZMINUS,LEADIN
NEGFAC	 MVI	   0(GRY),C'0'	       SET LEADING ZEROS
	 LA	   GRY,1(0,GRY)
	 BCT	   DECCTR,ZERMOV
	 BC	   ALWAYS,LEADIN       BRANCH IF DECIMALS EXHAUSTED
ZERMOV	 BCT	   FACTOR,NEGFAC
	 LR	   MOVER,DECCTR
	 BC	   ALWAYS,MAXCHK       MOVE IN SIGNIFICANT DECIMALS
POSFAC	 OI	   SWITCH,POSSCL       SET SWITCH FOR INTEGER
	 LR	   MOVER,FACTOR
	 BC	   ALWAYS,MAXCHK       MOVE IN INTEGER PORTION
ZERFAC	 MVI	   0(GRY),C'.'	       SET DECIMAL POINT
	 LA	   GRY,1(0,GRY)
	 OI	   SWITCH,DECSW
	 LTR	   DECCTR,DECCTR
	 BC	   ZMINUS,LEADIN       BRANCH IF NO DECIMALS
	 LR	   MOVER,DECCTR
*
MAXCHK	 LTR	   MAXIM,MAXIM
	 BC	   ZMINUS,ZERSET       BRANCH IF DIGITS EXHAUSTED
MOVDIG	 MVC	   0(1,GRY),0(CHRSAV)  FROM CONVERT AREA TO BUFFER
	 LA	   GRY,1(0,GRY)
	 LA	   CHRSAV,1(0,CHRSAV)
	 BCT	   MOVER,MOVCHK
	 BCTR	   MAXIM,0
	 BC	   ALWAYS,OUTCHK
MOVCHK	 BCT	   MAXIM,MOVDIG        ANY MORE SIGNIFICANT DIGITS
ZERSET	 MVI	   0(GRY),C'0'	       NO, FILL OUT FIELD WITH ZEROS.
	 LA	   GRY,1(0,GRY)
	 BCT	   MOVER,ZERSET
OUTCHK	 TM	   SWITCH,DECSW
	 BC	   NONE,ZERFAC	       BRANCH TO MOVE D DECIMALS
*
LEADIN	 LTR	   WIDTH,WIDTH
	 BCR	   ZERO,CALLBY	       BRANCH IF WIDTH EXHAUSTED
	 L	   GRY,BEGPOS
	 TM	   SWITCH,POSSCL
	 BC	   ALL,TSTSGN	       BRANCH IF INTEGER SET
	 BCTR	   GRY,0
	 TM    SWITCH,NEGDIG					   4640
	 BC    NONE,LDZERO		POSITIVE NUMBER 	   4640
	 CH    WIDTH,CONONE	 TEST REMAINING BUFFER POSITIONS   4640
	 BC    EQUAL,MINSGN	ONLY ONE LEFT-ENTER MINUS SIGN	   4640
LDZERO	 MVI   0(GRY),C'0'		SET ZERO AS INTEGER	   4640
	 BCT	   WIDTH,TSTSGN
	 BCR	   ALWAYS,CALLBY       BRANCH IF WIDTH EXHAUSTED
TSTSGN	 TM	   SWITCH,NEGDIG
	 BC	   NONE,FILLUP	       BRANCH IF DATUM POSITIVE
	 BCTR	   GRY,0
MINSGN	 MVI   0(GRY),C'-'		SET MINUS SIGN		   4640
	 BCT	   WIDTH,FILLUP
	 BCR	   ALWAYS,CALLBY       BRANCH IF WIDTH EXHAUSTED
FILLUP	 BCTR	   GRY,0
	 MVI	   0(GRY),C' '	       SET LEADING BLANKS
	 BCT	   WIDTH,FILLUP
	 BCR	   ALWAYS,CALLBY       BRANCH IF WIDTH EXHAUSTED
*
SIGNCHK1 TM    SWITCH,NEGDIG		IS NUMBER NEGATIVE	   4640
	 BC    NONE,BUFADJ		NO- FIELD ADEQUATE	   4640
STARS3	 AR	   WIDTH,MINIM	       RESTORE WIDTH
	 TM    GFSWCH,ON	       IF THIS IS NOT G-FORMAT	   2720
	 BC    NONE,STARS4	       TREATED AS F-FORMAT, BRANCH 2720
	 AH    WIDTH,CONFOR	       RESTORE G-FORMAT WIDTH	   2720
STARS4	 MVI	   0(GRY),C'*'	       IF WIDTH WILL NOT ACCOMMODATE
	 LA	   GRY,1(0,GRY) 	  ALL SIGNIFICANT DIGITS,
	 BCT	   WIDTH,STARS4 	  FILL FIELD WITH ASTERISKS.
XITSKP	 LD	   6,FPSAV3
	 LM	   2,13,SAVER	       RESTORE REGISTERS
	 LR	   1,0
	 BC	   ALWAYS,4(0,1)       RETURN TO CALLER
*
ZERDAT	 IC	   WIDTH,1(0,INDEX)    PICKUP WIDTH
	 IC	   DECCTR,2(0,INDEX)	  AND NUMBER OF DECIMALS.
CLEAR	 MVI	   0(GRY),C' '	       FILL FIELD WITH BLANKS
	 LA	   GRY,1(0,GRY)
	 BCT	   WIDTH,CLEAR
CHKEXP	 LA    MAXIM,3		       ASSUME AT LEAST 1 DEC PLACE.1748
	 LTR   DECCTR,DECCTR	       IS DECIMAL WIDTH ZERO.	   1748
	 BNZ   *+8		       IF NOT, BRANCH.		   1748
	 LA    MAXIM,2		       REDUCE MOVE COUNT BY 1.	   1748
	 LA    MINIM,3(0,DECCTR)				   7907
	 TM	   SWITCH,EDEXP
	 BC	   NONE,CHKSIZ	       BRANCH IF F-CONVERSION
	 LA	   MINIM,4(0,MINIM)    ALLOW FOR EXPONENT FIELD
CHKSIZ	 LA    CHRSAV,ZERPNT	       SET POINTER FOR MOVE.	   1748
	 CLI   BTEST,NEGDIG    WAS FIELD A -0.0 	       MISDAT
	 BNE   BYPASS1	 IF SO, THEN THIS DATA FIELD WAS A BLANK MISDAT
	 LA    CHRSAV,ZERPNTNG	   SET POINTER TO -0.0 FOR MOVE  MISDAT
BYPASS1  SR    GRY,MINIM				       MISDAT
COMPAR	 C	   GRY,SAVER+4	       IS FIELD WIDTH ADEQUATE
	 BC	   HIEQ,SETZER	       BRANCH IF YES
	 LA	   GRY,1(0,GRY)
	 LA	   CHRSAV,1(0,CHRSAV)
	 BCT	   MAXIM,COMPAR        TRY TO FIT WIDTH
	 IC    WIDTH,1(0,INDEX)        INADEQUATE FIELD WIDTH.	   1748
	 L     GRY,SAVER+4	       NEEDED FOR WDTH LT DEC WDTH.1748
	 BC    ALWAYS,STARS4	       GO TO FILL WITH ASTERISKS.  1748
SETZER	 EX	   MAXIM,CHRMOV        MOVE IN SIGN AND 0.0
	 BC	   ALWAYS,XITSKP
	 DROP	   BASEC
*
	 EJECT
*
FCVEO	 DS	   0H
FCVDO	 DS	   0H
	 USING	   *,1
	 STM	   2,13,SAVER	       SAVE REGISTERS
	 STD	   6,FPSAV3
	 MVI	   SWITCH,EDEXP        SET FOR E OR D EXPONENT FIELD
	 L	   CALLIN,ADFIXR
	 BALR	   CALLBY,CALLIN       FIX AND CONVERT TO BCD
	 L	   GRY,BEGPOS
	 AR	   GRY,MINIM	       COMPUTE POSITION
	 SH	   GRY,CONFOR		  OF EXPONENT FIELD.
	 TM	   0(INDEX),X'04'      CHECK LENGTH OF ITEM
	 BC	   NONE,MOVED
	 MVI	   0(GRY),C'E'	       FOUR BYTES, SET E-CHARACTER.
	 BC	   ALWAYS,EXPSGN
MOVED	 MVI	   0(GRY),C'D'	       EIGHT BYTES, SET D-CHARACTER.
EXPSGN	 S	   SPLCTR,EXPON        ADJUST EXPONENT BY SCALE FACTOR,
	 LTR	   SPLCTR,SPLCTR	  AND TEST SIGN.
	 BC	   MINUS,SETNEG
	 MVI	   1(GRY),C' '	       POSITIVE, SET BLANK SIGN.
	 BC	   ALWAYS,EXPCVT
SETNEG	 MVI	   1(GRY),C'-'	       NEGATIVE, SET MINUS SIGN.
	 LPR	   SPLCTR,SPLCTR
EXPCVT	 CVD	   SPLCTR,CVAREA       CONVERT TO DECIMAL,
	 UNPK	   CVAREA(2),CVAREA+6(2)  UNPACKED FORM.
	 OI	   CVAREA+1,X'F0'      SET PROPER ZONING,
	 MVC	   2(2,GRY),CVAREA	  AND MOVE IN TWO DIGITS.
	 LD	   6,FPSAV3
	 LM	   2,13,SAVER	       RESTORE REGISTERS
	 LR	   1,0
	 BC	   ALWAYS,4(0,1)       RETURN TO CALLER
*
	  EJECT
*
FCVGO	 DS	   0H
	 USING	   *,1
	 STM	   0,7,SAVEG	       SAVE REGISTERS
	 STD	   4,FPSAV4
	 STD	   6,FPSAV5
	 BALR	   BASEG,0	       LOAD BASE REGISTER
	 USING	   *,BASEG
	 LR	   INDEX,0	       PREPARE TO ADDRESS PARAMETERS
	 MVI   INT6SW,X'FF'	       SET SWITCH ON TO ALLOW	   4648X
			     HANDLING OF ANY BOUNDARY MISALIGNMENT.
	 TM	   0(INDEX),X'04'      CHECK LENGTH OF ITEM
	 BC	   NONE,GETDBL
	 SDR	   FLOAT,FLOAT
	 LE	   FLOAT,0(0,GRX)      SHORT-PRECISION REAL
	 BC	   ALWAYS,CHKDBL
GETDBL	 LD	   FLOAT,0(0,GRX)      LONG-PRECISION REAL
CHKDBL	 LPDR	   FLOAT,FLOAT
	 CD	   FLOAT,TENTH
	 MVI   INT6SW,X'00'		 RESET SWITCH		   4648
	 BC	   LOW,USECVE	       BRANCH IF ITEM LT 0.1
	 SR	   DECCTR,DECCTR
	 IC	   DECCTR,2(0,INDEX)   PICKUP NUMBER OF DECIMALS
	 SR	   WIDTH,WIDTH
	 D	   WIDTH,CONTEN        SEPARATE TENS AND UNITS DIGITS
	 SLDA	   WIDTH,2
	 SLA	   DECCTR,1
	 SDR	   SCALE,SCALE
	 LE	   SCALE,ETABHX(WIDTH)	  PICKUP 10 ** UNITS
	 LTR	   DECCTR,DECCTR
	 BC	   ZERO,EXPDEC
	 MD	   SCALE,ETABHT(DECCTR)   MULTIPLY BY 10 ** TENS
EXPDEC	 CDR	   FLOAT,SCALE
	 BC	   HIGH,USECVE	       BRANCH IF ITEM GT 10**D
	 MVC	   GPARS1(3),0(INDEX)  IGNORE SCALE FACTOR
	 MVI	   GFSWCH,ON	       SET FOR FLOATING DECIMAL
	 TM	   CGSWCH,ON
	 BC	   ALL,USECVF	       BRANCH IF COMPLEX CALL
	 SR	   WIDTH,WIDTH
	 IC	   WIDTH,GPARS1+1
	 SH	   WIDTH,CONFOR        REDUCE WIDTH BY FOUR
	 BC    PLUS,PASSWDTH	       FALL THROUGH IF WIDTH LT 5. 2720
	 AH    WIDTH,CONFOR	       RESTORE WIDTH.		   2720
STARS5	 MVI   0(GRY),C'*'	       WIDTH WILL NOT ACCOMMODATE  2720
	 LA    GRY,1(0,GRY)	       ANY SIGNIFICANT DIGITS.	   2720
	 BCT   WIDTH,STARS5	       FILL FIELD WITH ASTERISKS.  2720
	 BC    ALWAYS,FEXIT	       BYPASS GOING TO F-CONVERT.  2720
PASSWDTH STC   WIDTH,GPARS1+1	       PLACE WIDTH-4 FOR F-CNVRT.  2720
	 AR	   WIDTH,GRY
	 MVC	   0(4,WIDTH),CONBLK   INSERT 4 BLANKS AT RIGHT
USECVF	 L	   1,ADFOUT
	 BALR	   0,1		       USE F-CONVERSION
GPARS1	 DC	   AL4(0)
FEXIT	 MVI   GFSWCH,OFF	       SET OFF SWITCH FOR G-FORMAT 2720C
				       TREATED AS F-FORMAT.	   2720
	 BC	   ALWAYS,EXITGO
USECVE	 MVC	   GPARS2(4),0(INDEX)  INCLUDE SCALE FACTOR
	 L	   1,ADEOUT
	 BALR	   0,1		       USE E-CONVERSION
GPARS2	 DC	   AL4(0)
EXITGO	 LD	   4,FPSAV4
	 LD	   6,FPSAV5
	 LM	   0,7,SAVEG	       RESTORE REGISTERS
	 LR	   1,0
	 BC	   ALWAYS,4(0,1)       RETURN TO CALLER
	 DROP	   BASEG
*
	 EJECT
*
FCVCI	 DS	   0H
	 USING	   *,1
	 STM	   2,9,SAVEC	       SAVE REGISTERS
	 LR	   INDEX,0	       PREPARE TO ADDRESS PARAMETERS
	 SR	   COUNT,COUNT
	 SR	   WIDTH,WIDTH
	 IC	   COUNT,0(0,INDEX)    PICKUP ITEM LENGTH
	 IC	   WIDTH,1(0,INDEX)	  AND FORMAT WIDTH.
	 SRA	   COUNT,1
	 STC	   COUNT,PARINP        SET HALF OF ITEM LENGTH,
	 MVC	   PARINP+2(2),2(INDEX)   PLUS DECIMALS AND SCALEFACTOR
LPAREN	 CLI	   0(GRY),C'('
	 BC	   EQUAL,CMPLXN        BRANCH ON LEFT PARENTHESIS
	 CLI	   0(GRY),X'6C'
	 BC	   EQUAL,CMPLXN        BRANCH IF BCD LEFT PAREN
	 LA	   GRY,1(0,GRY)
	 BCT	   WIDTH,LPAREN
	 BC	   ALWAYS,ZERO1        BRANCH IF WIDTH EXHAUSTED
CMPLXN	 LA	   GRY,1(0,GRY)
	 ST	   GRY,CMPLXA	       SAVE START OF NUMBER,
	 SR	   NUMBER,NUMBER	  AND INITIALIZE COUNT.
	 BC	   ALWAYS,SUBCOM
COMMA	 CLI	   0(GRY),C','
	 BC	   EQUAL,HALF1	       BRANCH ON COMMA
	 LA	   NUMBER,1(0,NUMBER)  INCREMENT COUNT
	 LA	   GRY,1(0,GRY)
SUBCOM	 BCT	   WIDTH,COMMA
	 BC	   ALWAYS,ZERO1        BRANCH IF WIDTH EXHAUSTED
HALF1	 BAL	   CALLIN,CVTINP       CONVERT FIRST HALF
	 LA	   GRY,1(0,GRY)
	 ST	   GRY,CMPLXA	       SAVE START OF NUMBER,
	 SR	   NUMBER,NUMBER	  AND INITIALIZE COUNT.
	 AR	   GRX,COUNT	       POINT TO LAST HALF OF ITEM
	 BC	   ALWAYS,SUBPAR
RPAREN	 CLI	   0(GRY),C')'
	 BC	   EQUAL,HALF2	       BRANCH ON RIGHT PARENTHESIS
	 CLI	   0(GRY),X'4C'
	 BC	   EQUAL,HALF2	       BRANCH IF BCD RIGHT PAREN
	 LA	   NUMBER,1(0,NUMBER)  INCREMENT COUNT
	 LA	   GRY,1(0,GRY)
SUBPAR	 BCT	   WIDTH,RPAREN
	 BC	   ALWAYS,ZERO1        BRANCH IF WIDTH EXHAUSTED
HALF2	 BAL	   CALLIN,CVTINP       CONVERT SECOND HALF
	 BC	   ALWAYS,EXITCI
*
CVTINP	 STC	   NUMBER,PARINP+1     SET DIGIT COUNT AS WIDTH
	 STM	   0,3,TEMPX	       TEMPORARY SAVE
	 BALR	   BASEH,0	       LOAD BASE REGISTER
	 USING	   *,BASEH
	 L	   GRY,CMPLXA	       POINT TO START OF DIGITS
	 L	   1,ADGINP
	 BALR	   0,1		       CALL G-INPUT CONVERSION
PARINP	 DC	   AL4(0)
	 LM	   0,3,TEMPX	       RESTORE
	 DROP	   BASEH
	 BCR	   ALWAYS,CALLIN       RETURN
*
ZERO1	 L	   GRX,SAVEC
	 IC	   COUNT,0(0,INDEX)
ZERO2	 MVI	   0(GRX),X'00'        ZERO INPUT ITEM
	 LA	   GRX,1(0,GRX)
	 BCT	   COUNT,ZERO2
EXITCI	 LM	   2,9,SAVEC	       RESTORE REGISTERS
	 LR	   1,0
	 BC	   ALWAYS,4(0,1)       RETURN TO CALLER
*
	 SPACE	   3
*
FCVCO	 DS	   0H
	 USING	   *,1
	 STM	   2,9,SAVEC	       SAVE REGISTERS
	 MVI	   CGSWCH,ON	       SET G-OUTPUT SWITCH ON
	 LR	   INDEX,0	       PREPARE TO ADDRESS PARAMETERS
	 SR	   COUNT,COUNT
	 SR	   WIDTH,WIDTH
	 IC	   COUNT,0(0,INDEX)    PICKUP ITEM LENGTH
	 IC	   WIDTH,1(0,INDEX)	  AND FORMAT WIDTH.
	 SRA	   COUNT,1
	 STC	   COUNT,PAROUT        SET HALF OF ITEM LENGTH,
	 MVC	   PAROUT+2(2),2(INDEX)   PLUS DECIMALS AND SCALEFACTOR
	 AR	   GRX,COUNT	       POINT TO LAST HALF OF ITEM
	 AR	   GRY,WIDTH	       POINT TO RIGHT END OF BUFFERAREA
	 BCTR	   GRY,0
	 MVI	   0(GRY),C')'	       SET RIGHT PARENTHESIS
	 BAL	   CALLIN,CVTOUT       CONVERT SECOND HALF
	 SR	   GRX,COUNT	       POINT TO FIRST HALF OF ITEM
	 BCTR	   GRY,0
	 MVI	   0(GRY),C','	       SET COMMA
	 BAL	   CALLIN,CVTOUT       CONVERT FIRST HALF
	 BCTR	   GRY,0
	 MVI	   0(GRY),C'('	       SET LEFT PARENTHESIS
EXITCO	 MVI	   CGSWCH,OFF	       SET G-OUTPUT SWITCH OFF
	 LM	   2,9,SAVEC	       RESTORE REGISTERS
	 LR	   1,0
	 BC	   ALWAYS,4(0,1)       RETURN TO CALLER
*
CVTOUT	 SH	   WIDTH,CONONE
	 BC	   ZMINUS,EXITCO       EXIT IF WIDTH EXHAUSTED
	 STC	   WIDTH,PAROUT+1      SET REMAINING SPACE AS WIDTH
	 SR	   GRY,WIDTH	       POINT TO START OF SPACE
	 STM	   0,1,TEMPX	       TEMPORARY SAVE
	 BALR	   BASEH,0	       LOAD BASE REGISTER
	 USING	   *,BASEH
	 L	   1,ADGOUT
	 BALR	   0,1		       CALL G-OUTPUT CONVERSION
PAROUT	 DC	   AL4(0)
	 LM	   0,1,TEMPX	       RESTORE
	 DROP	   BASEH
	 SR	   WIDTH,WIDTH	       INITIALIZE COUNT
BLKCHK	 CLI	   0(GRY),C' '
	 BC	   NOTEQ,CWIDTH        BRANCH IF NON-BLANK
	 LA	   WIDTH,1(0,WIDTH)    INCREMENT COUNT
	 LA	   GRY,1(0,GRY)
	 BC	   ALWAYS,BLKCHK
CWIDTH	 LTR	   WIDTH,WIDTH
	 BC	   ZMINUS,EXITCO       EXIT IF WIDTH EXHAUSTED
	 BCR	   ALWAYS,CALLIN
*
	 EJECT
*
* TABLE OF POWERS OF TEN IN HEXADECIMAL FLOATING POINT
*
ETABHX	 DS	   0F
	 DC	   X'41100000'	       10**0
	 DC	   X'41A00000'	       10**1
	 DC	   X'42640000'	       10**2
	 DC	   X'433E8000'	       10**3
	 DC	   X'44271000'	       10**4
	 DC	   X'45186A00'	       10**5
	 DC	   X'45F42400'	       10**6
	 DC	   X'46989680'	       10**7
	 DC	   X'475F5E10'	       10**8
	 DC	   X'483B9ACA'	       10**9
ETABHT	 DS	   0D
TEN19	 DC	   X'508AC7230489E800' FILL
	 DC	   X'492540BE40000000' 10**10
	 DC	   X'5156BC75E2D63100' 10**20
	 DC	   X'59C9F2C9CD04674F' 10**30
	 DC	   X'621D6329F1C35CA5' 10**40
	 DC	   X'6A446C3B15F99267' 10**50
	 DC	   X'729F4F2726179A23' 10**60
	 DC	   X'7B172EBAD6DDC73C' 10**70
CONFLT	 DC	   X'4E00000000000000'
*
	 SPACE	   3
	 EJECT
*
* DATA AND STORAGE, NEW DECIMAL OUTPUT
*
INTCER	 DS    4D
CVTAB	 DS    0D
	 DC	   X'7B172EBAD6DDC73C' 10**70
	 DC	   X'729F4F2726179A23' 10**60
	 DC	   X'6A446C3B15F99267' 10**50
	 DC	   X'621D6329F1C35CA5' 10**40
	 DC	   X'621D6329F1C35CA5' 10**40
	 DC	   X'59C9F2C9CD04674F' 10**30
	 DC	   X'5156BC75E2D63100' 10**20
	 DC	   X'492540BE40000000' 10**10
	 DC    X'4110000000000000'
	 DC    X'3944B82FA09B5A52'     10 ** -9
	 DC    X'302F394219248446'  10 ** -20
	 DC    X'2814484BFEEBC2A1'  10 ** -30
	 DC    X'1F8B61313BBABCF9'  10 ** -40
	 DC    X'173BDCF495A97046'  10 ** -50
	 DC    X'0F19B604AAACA62B'  10 ** -60
	 DC    X'06B0AF48EC79AD21'  10 ** -70
CVTAB1	 DS    0D
	 DC    X'4110000000000000'     10 **  0
TENTH	 DC    X'401999999999999A'	   10**-1		  20211
	 DC    X'3F28F5C28F5C28F6'     10 ** -2
	 DC    X'3E4189374BC6A7F0'     10 ** -3
	 DC    X'3D68DB8BAC710CB2'  10 ** -4
S6M	 DC    X'3C10C6F7A0B5ED8D'  10 ** -6
	 DC    X'3B1AD7F29ABCAF48'  10 ** -7
	 DC    X'3A2AF31DC4611873'  10 ** -8
	 DC    X'3944B82FA09B5A52'  10 ** -9
	 DC	   X'483B9ACA00000000' 10**9
	 DC	   X'475F5E1000000000' 10**8
S7	 DC	   X'4698968000000000' 10**7
S5	 DC	   X'45186A0000000000' 10**5
	 DC	   X'4427100000000000' 10**4
	 DC	   X'433E800000000000' 10**3
	 DC	   X'4264000000000000' 10**2
S5M	 DC    X'3CA7C5AC471B4784'  10 ** -5
S6	 DC	   X'45F4240000000000' 10**6
S0     DC      X'4600000000000000'     NORMALIZING FACTOR	   4660
ROUNDER  DC    X'4000000000000004'	ROUNDING FACTOR 	  20211
*    ROUNDING FACTOR IS .5551 10**-16 THIS IS OBTAINED FROM	  20211
*	ROUNDING .5 10**-16 WHICH IS 3339A5652FB11378		  20211
*	     FACTOR IS UNNORMALIZED TO SAVE TIME DURING EXECUTION 20211
TEN1	 DC    D'10.0'						  20211
MASK	 DC    X'000000F0'
MASK1	 DC    X'0000000F'
EXPTAX	 DC    X'FFBA'	     -70
	 DC    X'FFC4'	     -60
	 DC    X'FFCE'	     -50
	 DC    X'FFD8'	     -40
	 DC    X'FFD8'	     -40
	 DC    X'FFE2'	     -30
	 DC    X'FFEC'	     -20
	 DC    X'FFF6'	     -10
	 DC    X'0000'	     0
	 DC    X'0009'		       +9
TWT	 DC    X'0014'
THT	 DC    X'001E'
FRT	 DC    X'0028'
FFT	 DC    X'0032'
SXT	 DC    X'003C'
SVT	 DC    X'0046'
EXPTAY	 DC    X'0000'		       ZERO
ONE	 DC    X'0001'
TWO	 DC    X'0002'
THR	 DC    X'0003'
FOU	 DC    X'0004'
FIV	 DC    X'0005'
SEV	 DC    X'0007'
EIG	 DC    X'0008'
NIN	 DC    X'0009'
	 DC    X'FFF7'	     -9
	 DC    X'FFF8'	     -8
	 DC    X'FFF9'	     -7
	 DC    X'FFFA'	     -6
	 DC    X'FFFC'	     -4
	 DC    X'FFFD'	     -3
	 DC    X'FFFE'	     -2
SIX	 DC    X'0006'
	 DC    X'FFFB'	     -5
*
	 EJECT
*
* DATA AND STORAGE AREAS
*
MOVEY	 MVC	   0(1,GRX),0(GRY)     BUFFER TO ITEM
MOVEX	 MVC	   0(1,GRY),0(GRX)     ITEM TO BUFFER
VIHCERRM DC    V(IHCERRM)	       ADDRESS OF ERROR MONITOR
CIBCOM	 DC    A(IBCOM=)					   1748
SAVER	 DS    12F		       REGISTER STORAGE 	   1748
TRANS	 DC    AL4(0)		       TRANSLATION		   1748
SWITCH	 DC    AL1(0)		       SCAN SWITCHES		   1748
BTEST	 DC    AL1(0)	   BLANK FIELD TEST		       MISDAT
ALPHA	 DC    X'FAFBFCFDFEFF'	       INPUT TRANSLATION TABLE	   1748
INT6SW	 DC    X'00'		  BOUNDARY MISALIGNMENT SW	   4648
INT6SWCH EQU   INT6SW
FCVEOUTP EQU   FCVEO
FCVLOUTP EQU   FCVLO
FCVIOUTP EQU   FCVIO
FCVCOUTP EQU   FCVCO
FCVAOUTP EQU   FCVAO
FCVZOUTP EQU   FCVZO
ADSCAN	 DC    A(SCNCVB)					   1748
ADFIXR	 DC    A(FIXCVD)					   1748
ADGINP	 DC    A(FCVGI) 					   1748
ADGOUT	 DC    A(FCVGO) 					   1748
ADFOUT	 DC    A(FCVFO) 					   1748
ADEOUT	 DC    A(FCVEO) 					   1748
*
SAVEG	 DS	   8F		       REGISTER STORAGE
SAVEC	 DS	   8F		       REGISTER STORAGE
TEMPX	 DS	   4F		       TEMPORARY STORAGE
FPSAV1	 DS	   1D
FPSAV2	 DS	   1D
FPSAV3	 DS	   1D
FPSAV4	 DS	   1D
FPSAV5	 DS	   1D
*
DATUM	 DS	   1D		       INTEGER STORAGE
INTGER	 DS	   1D		       TEMPORARY
DIGIT	 DS	   1F		       DIGIT STORAGE
EXPON	 DS	   1F		       EXPONENT STORAGE
EXPMAX	 DC	   AL2(75)
DEC19	 DC	   AL2(19)
RNDMAX	 DC	   AL2(16)
CVAREA	 DS	   2D		       DECIMAL CONVERT AREA
BEGPOS	 DS	   1F		       START OF SIGNIFICANT DIGITS
CMPLXA	 DS	   1F		       START OF COMPLEX NUMBER
HIBYTE	 DC	   X'0FFFFFFF'
CONTEN	 DC	   AL4(10)
CONBLK	 DC	   CL4' '
CHRMOV	 MVC	   0(1,GRY),0(CHRSAV)  MOVE FROM CONVERT AREA
CONONE	 EQU	   ONE
CONFOR	 EQU	   FOU
GFSWCH	 DC    AL1(0)		       G-FORMAT TREATED AS F- SW   2720
CGSWCH	 DC    AL1(0)		       COMPLEX DATA G-OUTPUT SW    2720
DECIM	 DC	   C'0123456789ABCDEF' OUTPUT TRANSLATION TABLE
ZERPNT	 DC	   C' 0.0'
ZERPNTNG DC    C'-0.0'	   BLANK FIELD INSERT		       MISDAT
*
PRMS	 DC    A(MSG)		       ADDRESS OF MESSAGE
	 DC    A(RETCD) 	       ADDRESS OF RETURN CODE FIELD
	 DC    A(ERRORNO)	       ADDRESS OF ERROR NUMBER
	 DC    A(0)		       ADDRESS OF BAD CHARACTER
ERRORNO  DC    F'0'
RETCD	 DC    F'0'
	 EJECT
*
*
*	 MESSAGES
DCML	 DC    C'  DECIMAL  '
HXDCML	 DC    C'HEXADECIMAL'
MSG	 DC    F'49'
	 DC    C'IHC2 5I CONVERT - ILLEGAL	       CHARACTER  '
	 SPACE	   3
*
******** SIGN ROUTINE FOR MINUS ZERO--HANDLES FLOATING POINT *********
	 USING	   SIGN,15
SIGN	 ST	   2,SAVE	       SAVE REGISTER 2
	 L	   2,0(1)	       GET PARAM LIST ADDRESS
	 LE	   0,0(2)	       LOAD FIRST OPERAND
	 LPER	   0,0		       TAKE ABSOLUTE VALUE
	 L	   2,4(1)
	 TM	   0(2),X'80'	       TEST SIGN
	  BC	   14,*+6
	 LNER	   0,0
	 L	   2,SAVE
	 BR	   14
SAVE	 DC	   F'0'
	 LTORG
	 END
  }y1;