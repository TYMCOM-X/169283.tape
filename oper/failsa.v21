TITLE   FAILSA  05/24/72
VERSION==XWD 21,27

;COPYRIGHT 1969,1970, DIGITAL EQUIPMENT CORP., MAYNARD, MASS.

        JOBVER==137
        LOC JOBVER
        VERSION
        RELOC

;ASSEMBLY PARAMETERS
IFNDEF  REWIND,<REWIND==0>      ;0=NO AUTOMATIC REWINDS

;ACCUMULATOR ASSIGNMENTS
        TMP=0
        Q=1     ;R-1
        R=2     ;COMMAND INPUT COUNT
        S=3     ;R+1    ;COMMAND BYTE POINTER
        PAKNAM=4        ;DEVNAM FOR DSKCHR UUO
        WASTE=5         ;USED BY DSKCHR UUO
        PAKFRE=6        ;# OF FREE BLKS RETURNED BY DSKCHR UUO
        T=7     ;WORD BEING TRANSFERRED
        F=10    ;FLAG AC
        A=11    ;SCRATCH ;JSP ON ME TO PRINT ROUTINES
        B=12    ;A+1 ;SCRATCH ;BYTE PTR IN PRINT ROUTINES
        CH=13   ;B+1    ;CHAR
        D=14    ;NUMBER FOR SWITCHES
        U=15    ;FIRST WORD ON A READ
        W=16    ;SECOND WORD ON A READ
        P=17    ;PUSHDOWN POINTER

;PARAMETER ASSIGNMENTS
        PDSIZ==200      ;PUSHDOWN LIST SIZE
        SLPMIN==^D60    ;MINUTES BETWEEN CONSECUTIVE SAVES WITH /M
        XLOOKN==40      ;NO. OF ARGS FOR EXTENDED LOOKUP/ENTER
        XLICN==14               ;NUMBER TO 0 SO NO RESTORE LIC

;CALLI ADDRESSES
        RESET==0
        DEVCHR==4
        WAIT==10
        EXIT==12
        DATE==14
        MSTIME==23
        GETPPN==24
        SLEEP==31
        DSKCHR==45
        SYSSTR==46

EXTERN  JOBFF,JOBDDT,JOBREN
;I/O PARAMETERS

;DEVICE ASSIGNMENTS
        TTY==1  ;TTY AND LISTING DEVICE OUTPUT
        TTI==2  ;TTY INPUT
        TAP==3  ;MAGNETIC TAPE FOR READ OR WRITE
        MFD==4  ;DISK FOR MASTER FILE DIRECTORY
        UFD==5  ;DISK FOR USER FILE DIRECTORY
        FIL==6  ;DISK FOR USER FILE
        CHK==7  ;DISK FOR FILE DATE CHECK

;NUMBER OF BUFFERS/CHANNEL
        TTYN==2
        TAPN==2
        MFDN==2
        UFDN==2
        CHKN==2
        FILN==5

;SIZE OF BUFFERS/DEVICE
        TTYSIZ==23
        TAPSIZ==1003
        DSKSIZ==203
        WATSIZ==1+5+1   ;SIZE OF FILE OUTPUT WATCHING BLOCK

;I/O STATUS BIT ASSIGNMENTS
        AL==1           ;ASCII LINE MODE
        BUFBIN==14      ;BUFFERED BINARY MODE
        NOCNT==20       ;MONITOR IS NOT TO COMPUTE BUFFER WORD COUNT
        IOEND==20000    ;END OF FILE
        IOTEND==2000    ;END OF TAPE
        IOBAD==740000   ;I/O ERROR
        BTL==40000      ;BLOCK TOO LARGE FOR BUFFER
        DNC==10         ;DO NOT CHG ACCESS DATE

;EXTENDED LOOKUP FILE STATUS BITS
        .RPDIR==400000  ;(RH) UFD BIT
        .RPNFS==40000   ;(RH) DO-NOT-SAVE BIT
        .RPBFA==10      ;(BOTH HALVES OF UFD - RH FOR OTHER) BAD FILE ACC. BIT
        URBLGI==400000  ;(LH) LOGGED IN BIT
;FLAG ASSIGNMENTS (LH OF AC F)
;       NAME & DEF      MEANING IF == 1

        SWITCH==400000  ;SWITCH MODE
        SLASH==200000   ;SWITCH MODE ENTERED W/ SLASH
        CSSW==100000    ;CHAR SEEN AND STASHED INTO IDENT
        NAMESW==40000   ;DO NOT COMPARE NAME OF FILE
        EXTSW==20000    ;DO NOT COMPARE EXT OF FILE
        FIRSW==10000    ;FIRST TAPE 
        PERSW==4000     ;PERIOD SEEN
        PPFSW==2000     ;PROJ-PROG AREA FOUND ON TAPE
        PAS1SW==1000    ;FIRST PASS COMPLETED
        ETWASW==400     ;SOMETHING SEEN ON THIS LINE
        ALLFSW==200     ;ALL FILES CHAR SEEN
        MFDDNE==100     ;SET WHEN THRU WITH MFD
        FILFND==40      ;A FILE WAS SAVED FOR THIS USER
        COMF==20        ;MORE ITEMS IN LIST
        TENDF==10       ;END OF TAPE FOUND
        ACCESS==4       ;RESET ACCES DATE WORD
        NEWRSW==4       ;DON'T CHECK DISK FILE DATES ON RESTORE
        USRDNE==2       ;ON MULTIPLE SAVE, TAPE ENDS BY ENDING A USER AREA
        KILLSW==1       ;ON /S OR /U ZONK ALL FILES FROM DISK WHICH ARE SAVED ON TAPE
                        ;ONLY SAVE THOSE FILES WHOSE ACCESS DATES ARE LESS THAN
                        ;ACCDAT. DON'T SAVE FILES BELONGING TO 1,1

;POSITIONING FLAGS (MARKING POSITION PROGRAM FOR REENTER) RH OF F

        SLRESW==1       ;PROGRAM IS SELECTIVELY RESTORING
        RESTSW==2       ;PROGRAM IS IN RESTORING PROCESS (/R ISSUED)
        LISTSW==4       ;PROGRAM IS LISTING (/L ISSUED)
        SAVSW==10       ;PROGRAM IS IN SAVING PROCESS (/S ISSUED)
                        ;ABOVE ARE USED AS A MAGIC OCTAL #.
                        ; DO NOT CHANGE.
        CONTSW==20      ;CONTINUING ON NEW TAPE
        PRNTSW==40      ;PRINT TAPE DIRECTORY ON DEVICE TTY
        USRSW==100      ;SINGLE USER ONLY SAVE
        UUOERR==200     ;UUO ERROR FLAG
        DOINGJ==400     ;SET WHEN /J IN PROGRESS SO TAPIN CAN IGNORE
                        ;MISC. MINUS VALUES THAT MIGHT BE AT START OF
                        ;A BOOTSTRAP FILE
        MFDI==1000      ;MFD INPUT IN PROGRESS
        UFDI==2000      ;UFD INPUT IN PROGRESS
        FILI==4000      ;FILE INPUT IN PROGRESS (ALL FROM DSK)
        TAPO==10000     ;TAPE OUTPUT IN PROGRESS
        TAPI==20000     ;TAPE INPUT IN PROGRESS
        UFDO==40000     ;UFD OUTPUT IN PROGRESS
        FILO==100000    ;USER FILE OUTPUT IN PROG. (TO DSK)
;MACRO DEFINITIONS

DEFINE  PRLIN1(B)
<       XLIST
        JSP     A,PRLIN
        SIXBIT  +B+
        LIST
>
DEFINE  PR1(B)
<       XLIST
        JSP     A,PR
        SIXBIT  +B+
        LIST
>
DEFINE  EMTAPE(B)
<       XLIST
        MTAPE   TAP,B
        MTAPE   TAP,0
        LIST
>
DEFINE  PRCHAR(B)
<       XLIST
        MOVEI   CH,"B"
        PUSHJ   P,TYPEA
        LIST
>
;INITIALIZATION

START:  SETZM   ACCDAT#         ;CLEAR ACCESS DATE WORD ON START ONLY
        SETZM   CRDATE#         ;CLEAR DATE WORD ON START ONLY
BEG:    CALLI   RESET           ;RESET I/O BUFFERING
        MOVE    P,[IOWD PDSIZ,PDL]
        MOVEI   A,RENTER        ;REENTER ADDRESS
        MOVEM   A,JOBREN
        MOVE    A,JOBVER        ;VER# TO HDR BLK
        HRLM    A,FIRBLK
        CALLI   A,GETPPN        ;GET USER'S PROJ-PROG #
        MOVEM   A,USRPPN#
        MOVEM A,OUTPPN#
        MOVEI   F,0             ;ALL FLAGS OFF
        PUSHJ   P,TTYINI        ;INIT THE TTY

;SET UP MAGNETIC TAPE BUFFERS
        MOVSI   A,TAPSIZ-2      ;DATA WORDS/BUFFER
        SETZM   TAPBUF          ;CLR STATUS OF 1ST BUFFER
        HRRI    A,TAPBUF+1+TAPSIZ       ;ADDR OF NEXT BUFFER
        MOVEM   A,TAPBUF+1      ;STORE POINTER INTO THIS BUFFER
        SETZM   TAPBUF+TAPSIZ   ;CLR STATUS OF 2ND BUFFER
        HRRI    A,TAPBUF+1      ;LAST BUFFER SHOULD POINT TO FIRST
        MOVEM   A,TAPBUF+1+TAPSIZ

;SET UP WATCHER BLOCK RING
;THESE ARE USED AT EOT TO BACK UP TO A CLEAN BREAK
        MOVSI   A,WATBUF+WATSIZ*TAPN    ;LINK BLOCKS FORWARD & BACKWARD
        HRRI    A,WATBUF+WATSIZ         ;LINKAGE IS SHOWN BELOW:
        MOVEM   A,WATBUF
        MOVSI   A,WATBUF                ;WB0:  WB2,WB1
        HRRI    A,WATBUF+WATSIZ*TAPN
        MOVEM   A,WATBUF+WATSIZ         ;WB1:  WB0,WB2
        MOVSI   A,WATBUF+WATSIZ
        HRRI    A,WATBUF                ;WB2:  WB1,WB0
        MOVEM   A,WATBUF+WATSIZ*TAPN
        HRRZM   A,WATPNT#               ;SET PTR TO CURRENT WATCH BLOCK
;BEGIN OPERATIONS
;ALSO VARIOUS REENTRY POINTS

FS1:
;       IFE     REWIND,<PRLIN1<REWIND NOT AUTOMATIC#>>
        PRLIN1  <FOR HELP, TYPE "/H"@>
FS1.2:  TLZ     F,PPFSW         ;PREVIOUS TAPE POSITION IGNORED
FS1AA:  MOVE    P,[IOWD PDSIZ,PDL]      ;RESET PDL IN CASE OF REENTRY
FS1A:   SETZM   TTYI+2          ;FLUSH PREVIOUS INPUT
        RELEAS  TAP,
        PUSHJ   P,ASTRSK        ;TYPE "*"
FS1B:   TRZ     F,-1            ;NO IO IN PROGRESS
        TLZ     F,SWITCH!SLASH!ETWASW!ALLFSW!FILFND!NEWRSW!MFDDNE!PPFSW ;ST NORML MOD
FS1.5:  TLZ     F,CSSW!PERSW!PAS1SW!TENDF!KILLSW!USRDNE!COMF    ;RDY FOR NXT IDNTIFIR
        MOVNI   R,6             ;INIT NEXT IDENTIFIER SCAN
FS1.7:  MOVE    S,[POINT 6,IDENT#]
        SETZM   IDENT

;INPUT CHARACTER DISPATCH

FS2:    PUSHJ   P,TYI           ;GET A COMMAND CHARACTER
        MOVE    A,CH            ;DISPATCH ON COPY
        IDIVI   A,11            ;ARRANGE ENTRY INTO MATRIX
        LDB     A,FS3(A+1)      ;GET CLASSIFICATION CODE
        JUMPE   A,ILCH          ;ZERO IS AN ILLEGAL CHAR
        CAIGE   A,4             ;SHIFT CODES GREATER THAN 4
        TLNN    F,SWITCH        ;TO ALLOW SPACE FOR SWITCH MODE
        ADDI    A,3
        HRRZ    B,FS5-1(A)      ;GET RH DISPATCH
        CAIL    A,10            ;DO WE WANT LH?
        HLRZ    B,FS5-10(A)     ;YES, GET IT
        JRST    @B              ;DISPATCH
;INPUT CHARACTER DISPATCH MATRIX

FS3:    POINT   4,FS4(A),3      ;BYTE POINTERS TO CLASSIFICATION TABLE
        POINT   4,FS4(A),7
        POINT   4,FS4(A),11
        POINT   4,FS4(A),15
        POINT   4,FS4(A),19
        POINT   4,FS4(A),23
        POINT   4,FS4(A),27
        POINT   4,FS4(A),31
        POINT   4,FS4(A),35



;       CLASSIFICATION TABLE FOR INPUT CHARACTERS
;       ADD 3 TO CODE IF NOT IN SWITCH MODE
;       SECOND ALPHABET SET REPRESENTS LOWER CASE CHARACTER CODES

;       NUL SOH STX ETX EOT ENQ ACK BEL BS
;       HT  LF  VT  FF  CR  SO  SI  DLE DC1
;       DC2 DC3 DC4 NAK SYN ETB CAN EM  SUB
;       ESC FS  GS  RS  US  SP  !   "   #
;       $   %   &   '   (   )   *   +   ,
;       -   .   /   0   1   2   3   4   5
;       6   7   8   9   :   ;   <   =   >
;       ?   @   A   B   C   D   E   F   G
;       H   I   J   K   L   M   N   O   P
;       Q   R   S   T   U   V   W   X   Y
;       Z   [   \   ]   ^   _   '   A   B
;       C   D   E   F   G   H   I   J   K
;       L   M   N   O   P   Q   R   S   T
;       U   V   W   X   Y   Z   173 174 175   
;       176 DEL

FS4:    BYTE    (4)4,0,0,0,0,0,0,0,0
        BYTE    (4)4,13,4,4,13,0,0,0,0
        EXP     0
        BYTE    (4)13,0,0,0,0,4,0,4,0
        BYTE    (4)0,0,0,0,5,3,6,0,11
        BYTE    (4)0,7,12,2,2,2,2,2,2
        BYTE    (4)2,2,2,2,0,0,0,10,0
        BYTE    (4)0,0,1,1,1,1,1,1,1
        BYTE    (4)1,1,1,1,1,1,1,1,1
        BYTE    (4)1,1,1,1,1,1,1,1,1
        BYTE    (4)1,0,0,0,0,10,0,0,0
        EXP     0
        EXP     0
        BYTE    (4)0,0,0,0,0,0,0,0,13
        BYTE    (4)13,4

;       BYTE    DISP    CLASSIFICATION

;       00      00      ILLEGAL CHARACTER

;       01      01      LETTER, SWITCH MODE
;       02      02      NUMBER, SWITCH MODE
;       03      03      ESCAPE CHAR, SWITCH MODE

;       01      04      LETTER, NORMAL MODE
;       02      05      NUMBER, NORMAL MODE
;       03      06      ESCAPE CHAR, NORMAL MODE

;       04      07      IGNORED CHAR
;       05      10      ENTER SWITCH MODE CHAR
;       06      11      ALL FILES CHAR
;       07      12      FILE EXTENSION DELIMITER
;       10      13      OUTPUT SPEC DELIMITER(=,_)
;       11      14      FILE DELIMITER
;       12      15      NEXT CHAR A SWITCH CHAR
;       13      16      LINE TERMINATION

FS5:    XWD     SENTER,SLETTR   ;10,1
        XWD     ALLFIL,SDIGIT   ;11,2
        XWD     EXTDLM,SLEAVE   ;12,3
        XWD     NOTYET,NLETTR   ;13,4
        XWD     COMMA,NLETTR    ;14,5
        XWD     SLENTR,ILCH     ;15,6
        XWD     LINTER,FS2      ;16,7
;SWITCH MODE DISPATCHING

SDIGIT: MOVEI   CH,133-60(CH)   ;OFFSET NUMERIC VALUE PAST Z FOR SWITAB
SLETTR: XCT     SWITAB-"A"(CH)  ;PERFORM THE SWITCH FUNCTION
SLENTR: TLOA    F,SLASH         ;ENTER SLASH MODE
        TLZN    F,SLASH         ;STAY IN SWITCH MODE?
SENTER: TLOA    F,SWITCH        ;ENTER SWITCH MODE
SLEAVE: TLZ     F,SWITCH        ;LEAVE SWITCH MODE
        MOVEI   D,0             ;COUNTER OR MTAPE REGISTER
        JRST    FS2             ;LOOK AT NEXT CHAR

SWITAB: PUSHJ   P,SWSKIP        ;A - ADVANCE THE MAGTAPE ONE FILE
        PUSHJ   P,SWBAKF        ;B - BACKSPACE THE MAGTAPE ONE FILE
        PUSHJ   P,CONTIN        ;C - CONTINUE
        PUSHJ   P,CALDDT        ;D - GO TO DDT (IF EXTANT)
        PUSHJ   P,SETCRE        ;E - SET CREATION DATE CHECK TIME AND DATE
        PUSHJ   P,SETACC        ;F - SET ACCESS DATE CHECK DATE
        PUSHJ   P,AREA          ;G - GET PROJECT-PROGRAMMER NUMBER
        PUSHJ   P,HELP          ;H - HELP MESSAGE
        PUSHJ   P,DINSTD        ;I - DENSITY = INSTALLATION STANDARD
IFE     REWIND,<
        PUSHJ   P,JMPSAV>       ;J - JUMP TO NEXT SAVE SET OR EOT
IFN     REWIND,<
        JRST    ILSW>           ;J - ILLEGAL
        TLOA    F,KILLSW        ;K - KILL ALL OLD DISK FILES SAVED ON TAPE
        PUSHJ   P,LIST          ;L - LIST USERS FILES FROM TAPE
        JRST    MNYSAV          ;M - MULTIPLE SAVES EVERY SLPMIN MINUTES
        TLOA    F,NEWRSW        ;N - INHIBIT DISK FILE DATE CHECK ON RESTORE
        JRST SETOPN             ;O - SET OUTPUT DIR
        PUSHJ   P,PRINT         ;P - PRINT DIRECTORY OF ALL FILES ON DEVICE LPT
        JRST    ILSW            ;Q - ILLEGAL
        PUSHJ   P,UNSAVE        ;R - RESTORE THE DISK FROM MAGTAPE
        PUSHJ   P,SAVE          ;S - SAVE THE DISK ON MAGTAPE
        PUSHJ   P,TREEL         ;T - TAPE REEL NUMBER
        PUSHJ   P,USAVE         ;U - SAVE A USERS AREA
        JRST    ILSW            ;V - ILLEGAL
        PUSHJ   P,SWREW         ;W - REWIND THE MAGTAPE
        JRST    ILSW            ;X - ILLEGAL
        PUSHJ   P,SLASHY        ;Y - SET UP FILE NAME FOR RESTART
        PUSHJ   P,SLASHZ        ;Z - SET UP PPN FOR RESTART OF /S
        JRST    NILSW           ;0 - ILLEGAL
        JRST    NILSW           ;1 - ILLEGAL
        PUSHJ   P,D200          ;2 - DENSITY = 200 BPI
        JRST    NILSW           ;3 - ILLEGAL
        JRST    NILSW           ;4 - ILLEGAL
        PUSHJ   P,D556          ;5 - DENSITY = 556 BPI
        JRST    NILSW           ;6 - ILLEGAL
        JRST    NILSW           ;7 - ILLEGAL
        PUSHJ   P,D800          ;8 - DENSITY = 800 BPI
        JRST    NILSW           ;9 - ILLEGAL
;MAGTAPE OPERATIONS

SWBAKF: AOS     D               ;BACKSPACE FILE (MTAPE 17)
SWSKIP: ADDI    D,15            ;SKIP FILE (MTAPE 16)
SWREW:  ADD     D,[MTAPE TAP,1] ;REWIND (MTAPE 1)
        PUSHJ   P,SETIN         ;INIT TAPE
        XCT     D               ;PERFORM MTAPE
        MTAPE   TAP,0           ;WAIT TILL DONE
        TLZ     F,PPFSW         ;MOVED TO NEW PLACE ON TAPE
IFE     REWIND,<SETZM   JFLAG>  ;CLR /J CTR
        JRST    CPOPJ1          ;RETURN AT SLETTR+2

;ROUTINES TO SET MAGTAPE DENSITY

D800:   AOS     D               ;DENSITY BITS = 11
D556:   AOS     D               ;DENSITY BITS = 10
D200:   AOS     D               ;DENSITY BITS = 01
DINSTD: MOVE    T,[POINT 2,INIT1,28]
        DPB     D,T
        JRST    CPOPJ1          ;RETURN AT SLETTR+2

;ENTER DDT

CALDDT: SKIPE   A,JOBDDT        ;DOES DDT EXIST
        JRST    (A)             ;YES,GO TO IT
        PRLIN1  <NO DDT@>
        JRST    CPOPJ1          ;RETURN AT SLETTR+2

;DO A /S AT TIMES 00:00 + N*SLPMIN

MNYSAV: PUSHJ   P,SAVE          ;SAVE ENTIRE DISK
        JFCL                    ;RETURNS TO NEXT INSTRUCTION
        CALLI   A,MSTIME        ;GET TIME IN MILLISECS
        IDIVI   A,^D1000*^D60   ;GET TIME IN MINUTES
        IDIVI   A,SLPMIN        ;GET MINUTES TO NEXT SAVE INTO B
SLP1:   MOVEI   A,^D60          ;SLEEP ONE MINUTE
        CALLI   A,SLEEP
        SOJG    B,SLP1          ;CONTINUE SLEEPING UNTIL B RUNS OUT
        JRST    MNYSAV          ;WAKE UP & SAVE AGAIN
;/J
;JUMP TO THE BEGINNING OF THE NEXT SAVE SET
;OR TO EOT (BETWEEN EOF'S) IF NOW ON LAST SAVE SET

IFE     REWIND,<
JMPSAV: MOVEI   A,40            ;SYNC INPUT BIT
        MOVEM   A,SYNCIN#       ;SET TO REQUEST AT SETIN
        TRO     F,DOINGJ        ;SET /J IN PROGRESS
        PUSHJ   P,SETIN         ;INIT TAPE
JMP0:   EMTAPE  16              ;SKIP PAST NEXT EOF
JMP1:   PUSHJ   P,TAPIN         ;READ A RECORD
        JRST    JMP3            ;2ND EOF = LOGICAL EOT
        JRST    JMP2            ;DIRECTORY --- WHAT KIND?
        JRST    JMP0            ;DATA??? --- IGNORE IT
JMP2:   MOVE    B,TAPHED        ;BUFR ADDR
        HLRE    A,2(B)          ;GET RECORD FLAG
        JUMPL   A,JMP0          ;IGNORE FILES
        MTAPE   TAP,17          ;SAVE HEADER! --- BACK OVER EOF
        EMTAPE  16              ;THEN FORWARD TO START OF HEADER
        JRST    JMP4            ;RETURN FOR NEXT COMMAND

JMP3:   EMTAPE  7               ;BACK OVER 2ND EOF
JMP4:   SETZM   SYNCIN          ;CLR SYNC INPUT REQUEST
        CLOSE   TAP,
        TRZ     F,DOINGJ        ;CLR /J IN PROGRESS FLAG
        AOS     JFLAG#          ;UP /J CTR
        JRST    CPOPJ1          ;RETURN
>
;COMMAND INTERPRETER FOR /Y COMMAND - SET UP FILE NAME FOR RESTART

SLASHY: SETZM   YNAME#          ;CLEAR THE FILE NAME
        SETZM   YEXT#           ;CLEAR THE EXTENSION
        MOVE    S,[POINT 6,YNAME] ;SET UP BYTE POINTER
        MOVNI   R,6             ;IGNORE CHARACTERS AFTER THE SIXTH
YCHAR:  PUSHJ   P,TYI           ;GET A CHARACTER
        MOVE    A,CH            ;PUT CHAR IN A FOR PROCESSING
        IDIVI   A,^D9           ;SET UP FOR DISPATCH
        LDB     A,FS3(A+1)      ;GET CHARACTER CODE
        HRRZ    B,YDSP(A)       ;GET ADDRESS
        CAIL    A,6             ;SKIP IF IT'S THE RIGHT ADDRESS
        HLRZ    B,YDSP-6(A)     ;GET THE LEFT ADDRESS
        JRST    @B              ;BRANCH TO PROPER ROUTINE
YDSP:   XWD     ILCH,ILCH       ;6,0
        XWD     YDOT,YAN        ;7,1
        XWD     ILCH,YAN        ;10,2
        XWD     ILCH,ILCH       ;11,3
        XWD     ILCH,YCHAR      ;12,4
        XWD     FS1AA,ILCH      ;13,5

YAN:    AOJG    R,YCHAR         ;IGNORE CHARACTER AFTER 6TH OR 3RD
        MOVEI   CH,-40(CH)      ;CONVERT TO SIXBIT
        IDPB    CH,S           ;STORE CHARACTER IN NAME
        JRST    YCHAR           ;GET NEXT CHARACTER

YDOT:   MOVNI   R,3             ;IGNORE CHARACTERS IN EXT AFTER 3RD
        MOVE    S,[POINT 6,YEXT] ;SET UP POINTER TO EXTENSION
        JRST    YCHAR           ;GET NEXT CHARACTER
;COMMAND INTERPRETER FOR /Z - SET UP PPN FOR RESTART OF /S

SLASHZ: PUSHJ   P,AREA1         ;READ PPN
        MOVE    D,FAKPPN        ;GET PPN JUST READ
        MOVEM   D,STPPN#        ;SAVE AS STARTING PPN FOR /S
        JRST    FS1AA           ;GET NEXT COMMAND

TREEL:  PUSHJ   P,RNUM          ;REABER FROM TERMINAL
        MOVEM   D,RTNUM#        ;SAVE IN RESTART TAPE NUMBER
        SOS     RTNUM           ;DECREMENT TAPE NUMBER
        JRST    FS1AA           ;GO TO COMMAND DISPATCHER

RNUM:   SETZ    D,              ;CLEAR THE ACCUMULATOR
RDIGIT: PUSHJ   P,TYI           ;READ A CHARACTER
        MOVE    A,CH            ;DISPATCH CHARACTER FROM A
        IDIVI   A,11            ;GET INDEX INTO CHARACTER TABLE
        LDB     A,FS3(A+1)      ;GET CHARACTER TYPE FROM TABLE
        HRRZ    B,RNTAB(A)      ;GET ADDRESS OF ROUTINE IF RH
        CAIL    A,6             ;SKIP IF WE GOT THE RIGHT ADDRESS
        HLRZ    B,RNTAB-6(A)    ;GET THE LH ADDRESS
        JRST    @B              ;BRANCH TO PROPER ROUTINE

RNTAB:  XWD     ILCH,ILCH       ;6,0
        XWD     ILCH,ILCH       ;7,1
        XWD     ILCH,RNDIG      ;10,2
        XWD     ILCH,ILCH       ;11,3
        XWD     ILCH,RDIGIT     ;12,4
        XWD     RNTERM,ILCH     ;12,5

RNDIG:  IMUL    D,12            ;MULTIPLY ACCUMULATOR BY TEN
        ADDI    D,-60(CH)       ;ADD IN NEW DIGIT
        JRST    RDIGIT          ;GET NEXT DIGIT

RNTERM: POPJ    P,              ;RETURN WITH NUMBER

RPPNER: PRLIN1  <UNABLE TO FIND RESTART PPN: #>
        MOVE    TMP,STPPN       ;RESTART PPN
        PUSHJ   P,PRPPN         ;PRINT THE PPN
        SETZM   STPPN           ;CLEAR THE PPN
        JRST    FS1AA           ;GO BACK TO THE COMMAND DISPATCHER
RNERR:  PRLIN1  <UNABLE TO FIND RESTART FILE: #>
        MOVE    B,YNAME         ;NAME OF FILE
        PUSHJ   P,PRFNAM        ;PRINT FILE NAME
        MOVE    B,YEXT          ;FILE EXTENSION
        PUSHJ   P,PREXT         ;PRINT THE EXTENSION
        PUSHJ   P,CRLF          ;PRINT A CARRIAGE RETURN AND LINE FEED
        SETZM   YNAME           ;CLEAR THE NAME
        SETZM   YEXT            ;CLEAR THE EXTENSION
        JRST    FS1AA           ;GO BACK TO THE COMMAND DISPATCHER
;SAVE OR RESTORE ONLY THOSE FILES CREATED ON OR LATER THAN
;DATE SPECIFIED IN /E COMMAND
;SAVE OR RESTORE ONLY THOSE FILES ACCESSED ON OR LATER THAN
;DATE SPECIFIED IN /F COMMAND

;IF /K IS USED WITH /S OR /U, TRANSFER ONLY THOSE FILES WHOSE ACCESS
;DATES ARE LESS THAN THAT SPECIFIED BY /F COMMAND.
;AND DELETE SUCH FILES FROM DISK.
;DON'T DO ANYTHING TO FILES BELONGING TO 1,1.
;COMMAND FORMAT IS

;/EMM/DD/YY,TTTT<CARRIAGE RETURN>

;WHERE MM = NUMERICAL MONTH (MAY BE SINGLE DIGIT)
;WHERE DD = NUMERICAL DAY (MAY BE SINGLE DIGIT)
;WHERE YY = TWO DIGIT YEAR
;WHERE TTTT = FOUR DIGIT MILITARY TIME

;IF COMMA IS TYPED,
;NULL DATE FIELD IMPLIES TODAY'S DATE
;NULL TIME FIELD IMPLIES 0000

;/E<CARRIAGE RETURN>  SETS TIME TO 1/1/64,0000

;D CONTAINS DECIMAL NUMBERS
;T CONTAINS TEMPORARY DATUM UNTIL COMMAND IS PROCESSED

;ON A /F COMMAND START AT SETACC AND SET A WORD WHICH IS COMPARED
;TO THE ACCESS DATE IN A LOOKUP BLOCK
;A NULL ARGUMENT WITHOUT COMMA SETS ACCESS DATE WORD TO 1/1/64
;A NULL ARGUMENT WITH COMMA SETS ACCESS DATE WORD TO TODAY'S DATE
;SET DATE AND TIME

;INITIALIZE /E OR /F
; ENTER AT SETACC ON /F
; ENTER AT SETCRE ON /E

SETACC: TLO     F,ACCESS        ;SET ACCESS DATE WORD ON /F
SETCRE: SETZB   D,JAHR#         ;CLEAR ALL TEMP STORAGE
        SETZB   T,MONAT#
        SETZM   TAG#
        SETZM   HOUR#
        SETZM   MINUTE#
                                ; FALL INTO GCHAR
;COMMAND INTERPRETER FOR /E OR /F COMMAND

GCHAR:  PUSHJ   P,TYI           ;GET A CHAR
        MOVE    A,CH            ;PROCESS IT IN A
        IDIVI   A,^D9           ;SET UP FOR DISPATCH
        LDB     A,FS3(A+1)      ;GET CHAR CODE
        HRRZ    B,CHRDSP(A)     ;DISPATCH CODE
        CAIL    A,6             ;DO WE WANT LEFT HAND DISPATCH?
        HLRZ    B,CHRDSP-6(A)   ;YES, GET IT
        JRST    @B              ;NO, DISPATCH

;CHARACTER DISPATCH TABLE FOR /E OR /F COMMAND

CHRDSP: XWD     ILCH,ILCH       ;6,0
        XWD     ILCH,ILCH       ;7,1
        XWD     ILCH,DIGIT      ;10,2
        XWD     ACOMMA,ILCH     ;11,3
        XWD     SLA,GCHAR       ;12,4
        XWD     TERM,ILCH       ;13,5

;COMPILE DECIMAL NUMBERS

DIGIT:  IMULI   D,^D10          ;MUL LAST DIGIT BY 10
        ADDI    D,-60(CH)       ;ADD DECIMAL VALUE OF NEW DIGIT
        JRST    GCHAR           ;GET NEXT CHARACTER

;GET MONTH OR DAY PRECEDING SLASH

SLA:    SKIPE   MONAT           ;DO WE HAVE MONTH YET?
        JRST    SLADAY          ;YES, GO CHECK DAY
        JUMPE   D,COMERR        ;NO, D = 0 IMPLIES COMMAND ERROR
        CAILE   D,^D12          ;MONTH IN RANGE?
        JRST    NUMOUT          ;NO, ERROR
        MOVEM   D,MONAT         ;YES, SAVE VALUE
        SETZM   D               ;CLEAR D
        JRST    GCHAR           ;GET NEXT CHAR

SLADAY: SKIPE   TAG             ;DO WE HAVE DAY YET?
        JRST    COMERR          ;YES, COMMAND ERROR
        JUMPE   D,COMERR        ;NO, VALUE = 0 IMPLES COMMAND ERROR
        CAILE   D,^D31          ;DAY IN RANGE?
        JRST    NUMOUT          ;NO, ERROR
        MOVEM   D,TAG           ;SAVE VALUE
        SETZM   D               ;CLEAR NUMBER REGISTER
        JRST    GCHAR           ;GET NEXT CHAR
;PROCESS /E OR /F FIELD TERMINATORS

;COMMA SEPARATES DATE FROM TIME

ACOMMA: PUSHJ   P,GETDAT        ;COMPILE DATE
        TLNN    F,ACCESS        ;/F OR /E?
        JRST    GCHAR           ;/E, GO LOOK FOR TIME
ACOMM3: MOVEM   T,ACCDAT        ;/F, SAVE ACCESS DATE
        JRST    FS1AA           ;GET NEXT COMMAND

;CARRIAGE RETURN TERMINATES /E OR /F

TERM:   SKIPN   T               ;IF WE HAVE DATE ALREADY, GET TIME
        PUSHJ   P,GETDAT        ;COMPILE DATE
        IDIVI   D,^D100         ;GET HOURS IN D, MINUTES IN U
        IMULI   D,^D60          ;CONVERT HOURS TO MINUTES
        ADD     D,U             ;TOTAL MINUTES
        CAIL    D,^D24*^D60     ;LESS THAN ONE DAY?
        JRST    NUMOUT          ;NO, OUT OF RANGE
        LSH     D,^D12          ;MOVE TO TIME FIELD
        ADD     T,D             ;COMBINE TIME WITH DATE
        TLNE    F,ACCESS        ;/F OR /E?
        JRST    ACOMM3          ;/F
        MOVEM   T,CRDATE        ;/E
        JRST    FS1AA           ;RETURN FOR NEXT COMMAND

;COMPILE DATE

GETDAT: SKIPE   TAG             ;DAY SPECIFIED?
        JRST    GETDA1          ;YES, COMBINE MONTH & YEAR
        SKIPN   MONAT           ;NO, HAS MONTH BEEN SPECIFIED?
        SKIPE   D               ; OR YEAR?
        JRST    COMERR          ;PARTIAL DATE
        CAIN    CH,","          ;IF TERM. CHAR. WAS CR, LEAVE T=0
        CALLI   T,DATE          ;NULL DATE WITH COMMA IMPLIES TODAY
        POPJ    P,
GETDA1: SKIPE   MONAT           ;MONTH SPECIFIED?
        SKIPN   D               ; OR YEAR?
        JRST    COMERR          ;PARTIAL DATE
        SUBI    D,^D64          ;SUBTRACT BASE YEAR (1964)
        JUMPL   D,NUMOUT        ;YEAR OUT OF RANGE
        IMULI   D,^D12          ;CALCULATE DATE: YEAR*12
        SOS     MONAT           ;MONTH-1
        ADD     D,MONAT
        IMULI   D,^D31          ;((Y-64)*12+M-1)*31
        SOS     TAG             ;DAY-1
        ADD     D,TAG
        MOVE    T,D             ;STASH
        SETZ    D,              ;CLEAR NUMBER REGISTER
        POPJ    P,
;/G - GET PROJECT-PROGRAMMER NUMBER
;TO ALLOW /U OR /L OR SELECTIVE RESTORE
;ON AN AREA DIFFERENT FROM HIS OWN

AREA:   PUSHJ P,AREA1
        MOVE D,FAKPPN
        MOVEM D,USRPPN
        JRST FS1AA

AREA1:  SETZB D,FAKPPN#
AREA0:  PUSHJ   P,TYI           ;GET CHAR FOLLOWING /G
        MOVE    A,CH            ;(JUST LIKE GCHAR)
        IDIVI   A,11
        LDB     A,FS3(A+1)
        HRRZ    B,ARADSP(A)
        CAIL    A,6
        HLRZ    B,ARADSP-6(A)
        JRST    @B

;CHARACTER DISPATCH TABLE FOR /G

ARADSP: XWD     ILCH,ILCH       ;6,0
        XWD     ILCH,ILCH       ;7,1
        XWD     ILCH,ADIGIT     ;10,2
        XWD     ARACOM,ILCH     ;11,3
        XWD     ILCH,AREA0      ;12,4
        XWD     ATERM,ILCH      ;13,5

;COMPILE NUMBRS FOR /G

ADIGIT: IMULI   D,10            ;PREVIOUS * 8
        ADDI    D,-60(CH)       ;+ NEW
        JRST    AREA0

;STORE PROJECT # WHEN COMMA SEEN

ARACOM: HRLZM   D,FAKPPN
        SETZ    D,
        JRST    AREA0

;STORE PROGRAMMER # WHEN CR SEEN

ATERM:  HRRM    D,FAKPPN
        POPJ P,         ;RETURN

SETOPN: PUSHJ P,AREA1
        MOVE D,FAKPPN
        MOVEM D,OUTPPN
        JRST FS1AA
;SAVE COMMAND EXECUTION

USAVE:  TRO     F,USRSW         ;SINGLE USER SAVE
        JRST    SAVE1           ;SKIP 1,2 CHECK
SAVE:   PUSHJ   P,CKOPER        ;RETURN ONLY IF OPER LICENSE
SAVE1:  TRO     F,SAVSW         ;/S IN PROGRESS
        TRZ     F,RESTSW        ;TURN OFF IN CASE OF /C
IFE     REWIND,<SETZM   JFLAG>  ;CLR /J CTR
        MOVE    A,RTNUM         ;GET RESTART TAPE NUMBER -1
        MOVEM   A,TAPNUM#       ;SAVE IT AS CURRENT TAPE NUMBER -1
        SETZM   RTNUM           ;CLEAR RESTART TAPE NUMBER
        SETZM   DSKNAM          ;CLR DSKNAM BLK
        MOVE    A,[XWD DSKNAM,DSKNAM+1]
        BLT     A,DSKNME-1
        MOVE    A,[POINT 6,DSKNAM]      ;SET SEMI-DYNAMIC POINTER
        MOVEM   A,DSKNPT#
        MOVNI   Q,20            ;NAME STORE CTR

;DISPATCH ROUTINE FOR READING FILE STRUCTURE NAMES AFTER /S,/U

SAVLST: MOVNI   R,6             ;NAME CHAR CTR
        MOVE    S,DSKNPT        ;NAME STORE PTR
SAVLS0: PUSHJ   P,TYI           ;JUST LIKE GCHAR
        MOVE    A,CH
        IDIVI   A,11
        LDB     A,FS3(A+1)
        HRRZ    B,STRDSP(A)
        CAIL    A,6
        HLRZ    B,STRDSP-6(A)
        JRST    @B

STRDSP: XWD     ILCH,ILCH       ;6,0
        XWD     ILCH,SCHAR      ;7,1
        XWD     ILCH,SCHAR      ;10,2
        XWD     SCOMMA,ILCH     ;11,3
        XWD     ILCH,SSPACE     ;12,4
        XWD     STERM,ILCH      ;13,5
;IGNORE SPACE OR TAB AFTER /S,/U

SSPACE: CAIE    CH,11           ;TAB?
        CAIN    CH,40           ;SPACE?
        JRST    SAVLS0          ;YES
        JRST    ILCH            ;OTHERWISE, BAD CHAR

;STORE CHARACTER OF FILE STRUCTURE NAME

SCHAR:  AOJG    R,SAVLS0        ;IGNORE AFTER 6TH
        MOVEI   CH,-40(CH)      ;MAKE 6-BIT
        IDPB    CH,S            ;STORE IN DSKNAM
        JRST    SAVLS0

;FILE STRUCTURE DELIMITER

SCOMMA: AOS     DSKNPT          ;MOVE PTR TO NEXT WORD
        AOJL    Q,SAVLST        ;GET NEXT
        JRST    TOOMNY

;FILE STRUCTURE LIST TERMINATOR

STERM:  SKIPE   DSKNAM          ;DSK STR NAMES EXPLICITLY GIVEN?
        JRST    BEGSAV          ;YES
        MOVSI   R,-20           ;NO, GET ALL NAMES WITH SYSSTR UUO
        HRRI    R,DSKNAM
        MOVSI   A,(SIXBIT /DSK/)        ;DEFAULT = "DSK"
        MOVEM   A,DSKNAM
        SETZ    CH,
STRLUP: CALLI   CH,SYSSTR       ;GET NEXT STRUCTURE NAME
        JRST    BEGSAV          ;ILLEGAL ARGUMENT???
        JUMPE   CH,BEGSAV       ;NO MORE MFD'S
        MOVE    PAKNAM,CH       ;INIT DSKCHR UUO
        MOVE    A,[XWD 1,PAKNAM]
        CALLI   A,DSKCHR        ;GET DISK CHARACTERISTICS
        JFCL                    ;WE KNOW IT'S THERE
        TLNE    A,4000          ;PRIVATE PACK?
        JRST    BEGSAV          ;YES, SAVE NO MORE
        MOVEM   CH,(R)          ;PUT NAME ON LIST
        AOBJN   R,STRLUP
BEGSAV: SETZM   STRNDX#         ;INIT INDEX TO DSKNAM BLK
        TLO     F,FIRSW         ;INDICATE FIRST TAPE
        MOVEM   P,SAVMFD#       ;SAVE PDP FOR ENDTAP

        ;FALL INTO SAVE2
;START A NEW TAPE

SAVE2:  PUSHJ   P,SETOUT        ;INIT TAPE AND SET UP HEADER AS VIRGIN
IFN     REWIND,<EMTAPE  1>      ;REWIND THE MAGTAPE
        OUTPUT  TAP,            ;DUMMY OUTPUT TO SET UP TAPHED
        PUSHJ   P,TAPOU3        ;SET UP BUFFER COUNTS
        PUSHJ   P,CRLFLF        ;START MESSAGE
        PRLIN1  <FAILSAFE TAPE#>
        AOS     A,TAPNUM        ;INCREMENT TAPE NUMBER
        HRRM    A,FIRBLK+2      ;PLACE IN HEADER
        PUSHJ   P,PRNUM         ;AND PUBLISH
        PR1     < FOR#>
        CALLI   A,MSTIME        ;FORM THE TAPE'S DATE AND TIME
        IDIVI   A,^D60000       ;FLUSH JIFFIES AND SECONDS
        CALLI   B,DATE          ;GET TODAY'S DATE
        ANDI    A,3777
        LSH     A,^D12          ;TIME IN BITS 13-23
        IOR     A,B             ;DATE IN 24-35
        SKIPGE  FIRBLK+3        ;CONTINUE TAPE BIT SET IN LAST TRAILER?
        TLO     A,400000        ;YES, KEEP IT IN THIS HEADER
        MOVEM   A,FIRBLK+3      ;STASH AWAY IN HEADER LABEL
        PUSHJ   P,DATIME        ;PRINT THEM OUT
        PUSHJ   P,CRLF          ;LEAVE SPACE
        TLNN    F,FIRSW         ;IS IT FIRST TAPE?
        JRST    LABBLT          ;NO, WRITE OUT HEADER & RETURN
        PUSHJ   P,LABBLT        ;WRITE OUT HEADER

;LOOP TO SAVE EACH FILE STRUCTURE ON LIST

SAVE0:  MOVE    A,STRNDX        ;GET NEXT NAME
        MOVE    A,DSKNAM(A)
        MOVEM   A,CURSTR        ;SAVE NAME
        JUMPE   A,ENDMF0        ;NO MORE MFD'S TO GO
        MOVEM   A,ACTSTR        ;ACTIVE FILE STRUCTURE
        MOVEI   A,MFDHED
        MOVEM   A,MFDSPK+2
        OPEN    MFD,MFDSPK      ;WANT TO READ MFD FOR THIS STR
        JRST    NOMFD           ;HAVE TO SKIP THIS ONE
        MOVEI   A,MFDBUF        ;SET UP BUFFERS
        MOVEM   A,JOBFF
        INBUF   MFD,MFDN
        MOVE    A,SYSPP         ;LOOK FOR MFD
        MOVEM   A,MFDDIR+3      ;IN THE MFD
        MOVEM   A,MFDDIR
        MOVSI   A,(SIXBIT /UFD/)
        MOVEM   A,MFDDIR+1
        LOOKUP  MFD,MFDDIR      ;(OLD STYLE LOOKUP)
        JRST    NOMFD           ;NOT THERE
        MOVEM   P,SAVUFD#       ;SAVE PDP FOR ENDUFD
MORE1: PUSHJ   P,MFD2          ;GET TWO WORDS FROM MFD
        HLRZS   W               ;SECOND WORD
        CAIE    W,(SIXBIT /UFD/)        ;IS HE A UFD?
        JRST    MORE1           ;NO, TRY AGAIN
        TRNE    F,USRSW         ;SKIP IF NOT A SINGLE USER SAVE
        JRST    MORE62          ;SINGLE USER SAVE
        SKIPE   STPPN           ;SKIP IF THIS IS NOT A RESTART
        CAMN    U,STPPN         ;SKIP IF NOT THE RESTART PPN
        JRST    MORE6           ;CONTINUE PROCESSING THIS UFD
        JRST    MORE1           ;GET ANOTHER UFD
MORE62: SKIPN   YNAME           ;SKIP IF IT'S A RESTART
        SKIPE   YEXT            ;SKIP IF IT'S NOT A RESTART
        JRST    MORE63          ;DON'T ALLOW 1,1 FOR RESTART /U
        CAMN    U,SYSPP         ;1,1.UFD?
        JRST    MORE6
MORE63: CAME    U,USRPPN        ;USER UFD?
        JRST    MORE1           ;NO
MORE6:  MOVEM   U,UFDDIR+2      ;YES, LETS HAVE A LOOKUP AT IT
        SETZM   STPPN           ;THIS IS NO LONGER A RESTART
        MOVE    A,ACTSTR        ;GET ACTIVE STRUCTURE FOR INIT
        MOVEM   A,MORE61
        INIT    UFD,BUFBIN      ;IS IT AVAILABLE
MORE61: SIXBIT  /DSK/
        XWD     0,UFDHED        ;INPUT ONLY
        PUSHJ   P,LOOKER        ;DISP. CORRECTLY AFTER ERROR MSG.
        MOVEI   A,UFDBUF        ;SETUP BUFFERING
        MOVEM   A,JOBFF
        INBUF   UFD,UFDN
        MOVE    A,SYSPP         ;LOOK FOR UFD
        MOVEM   A,UFDDIR+1      ;IN THE UFD
        MOVEI   A,XLOOKN        ;EXT. LOOKUP
        MOVEM   A,UFDDIR
        MOVSI   A,(SIXBIT /UFD/)
        MOVEM   A,UFDDIR+3
        TRO     F,UFDI          ;UFD INPUT MODE FOR REENTER
        LOOKUP  UFD,UFDDIR      ;IS IT STILL THERE
        PUSHJ   P,LOOKER        ;ERROR RECOVERY ROUTINE
        TRZ     F,UFDI          ;OUT OF UFD INPUT STATE
        TLZ     F,FILFND        ;NO FILES FOUND YET FOR THIS USER
        MOVEM   P,SAVFIL#       ;REMEMBER PDP FOR ENDFIL
MORE2:  PUSHJ   P,UFD2          ;GET TWO WORDS FROM UFD
        HLRZS   W               ;SECOND WORD LH
        CAIN    W,(SIXBIT /TMP/)        ;TEMPORARY?
        JRST    MORE2           ;YES, DONT DUMP
        SKIPN   YNAME           ;SKIP IF RESTART FILE NAME NOT NULL
        SKIPE   YEXT            ;SKIP IF RESTART EXTENSION NAME NOT NULL
        SKIPA                   ;SKIP SO WE CAN TEST FILE NAME
        JRST    MORE5           ;NOT RESTART
        HRLZ    A,W             ;PUT EXTENSION IN LH TO COMPARE
        CAMN    U,YNAME         ;SKIP IF THIS IS NOT THE NAME
        CAME    A,YEXT          ;SKIP IF THIS IS THE EXTENSION
        JRST    MORE2           ;THIS IS NOT THE FILE - TRY ANOTHER
        SETZM   YNAME           ;THIS IS NO LONGER A RESTART
        SETZM   YEXT            ;THIS IS NO LONGER A RESTART
MORE5: MOVEI   A,XLOOKN        ;EXT. LOOKUP
        MOVEM   A,FILDIR
        MOVEM   U,FILDIR+2      ;FIND THE FILE
        HRLZM   W,FILDIR+3
        MOVEM   F,SAVF#         ;TO RESTORE IN CASE...
        MOVEM   P,SAVP#         ;WE RUN OUT OF TAPE
        MOVE    A,UFDDIR+2      ;PROJ-PROG NUMBER
        MOVEM   A,FILDIR+1
        TRNE    F,USRSW         ;SINGLE USER SAVE?
        CAME    A,SYSPP         ;1,1?
        JRST    MORE7
        CAIN    W,(SIXBIT /UFD/)
        CAME    U,USRPPN        ;USER UFD?
        JRST    MORE2           ;NO, DONT SAVE
MORE7:  MOVE    R,CRDATE        ;CREATION DATE TYPED BY OPERATOR
        MOVE    U,UFDW2         ;CREATION DATE FROM UFD WORD 2
        PUSHJ   P,CKCREU        ;CHECK CREATION DATE FROM UFD
        JRST    MORE2           ;DON'T SAVE THIS FILE
        JFCL                    ;NOP BECAUSE CKCREU MIGHT SKIP TWICE
        MOVE    A,ACTSTR        ;DO THE INIT ON THE RIGHT STR
        MOVEM   A,MORE71
        INIT    FIL,BUFBIN      ;SET TO GET FILE
MORE71: SIXBIT  /DSK/
        XWD     0,FILHED        ;INPUT ONLY
        PUSHJ   P,LOOKER        ;DISK NOT THERE
        MOVEI   A,FILBUF        ;SETUP BUFFERS
        MOVEM   A,JOBFF
        INBUF   FIL,FILN
        TRO     F,FILI          ;ENTER FILE INPUT STATE
        LOOKUP  FIL,FILDIR      ;IS IT THERE?
        PUSHJ   P,LOOKER        ;GO TO SEE WHY LOOKUP FAILED(RTN TO MORE2)
        TRZ     F,FILI          ;EXIT FROM FILE INPUT STATE
        MOVE    A,FRBSTS        ;GET FILE STATUS
        TRNE    A,.RPNFS        ;DO-NOT-SAVE BIT ON?
        JRST    MORE2           ;YES
        HRRZ    A,FILDIR+3      ;GET ACCESS DATE OF FILE
        TRZ     A,770000        ;MASK OUT NON DATE BITS
        SUB     A,ACCDAT        ;COMPARE TWO DATES
        TLNN    F,KILLSW        ;ARE WE IN KILL MODE?
        JRST    MORE10          ;NO
        MOVE    B,UFDDIR+2      ;YES, CHECK FOR 1,1'S FILE
        CAME    B,SYSPP         ;IS IT 1,1'S FILE
        CAMN    B,CUSPP         ;ALSO IS IT 1,4'S
        JRST    MORE2           ;YES, SKIP IT
        SETCA   A,              ;NO, COMPLEMENT COMPARISON
MORE10: JUMPL   A,MORE2         ;A EARLIER SKIPS, A LATER ON /K SKIPS
        TLO     F,FILFND        ;YES, INDICATE FILE FOUND
        SETZM   RECCNT#         ;NO RECORDS FOR THIS FILE OUTPUT YET
        PUSHJ   P,DIRBLT        ;BLT DIRECTORY INTO TAPE BUFFER
        PUSHJ   P,WATBLT        ;BLT DIRECTORY INTO WATCHER BLOCK
        HLRZ    W,FILDIR+3
        CAIN    W,(SIXBIT /UFD/)        ;UFD FILE?
        JRST    ENDFIL          ;YES, SAVE ONLY LOOKUP INFO

MORE3:  SOSG    FILHED+2        ;GET A WORD FROM USER FILE
        PUSHJ   P,FILIN         ;MAY NOT RETURN HERE
        ILDB    T,FILHED+1
        SOSG    TAPHED+2        ;STASH IT AWAY ON TAPE
        PUSHJ   P,TAPOUT
        IDPB    T,TAPHED+1
        JRST    MORE3           ;CONTINUE FILLING BUFFER
;READ MFD

MFD2:   PUSHJ   P,GETMFD        ;GET THE FIRST WORD
        JUMPE   W,MFD2          ;SKIP TO NEXT PAIR ON 0
        MOVE    U,W             ;PLACE IN FIRST WORD REGISTER
        PUSHJ P,GETMFD
        PUSH P,W
        REPEAT 3,<PUSHJ P,GETMFD>
        POP P,W
        POPJ P,
GETMFD: TRO     F,MFDI
        SOSG    MFDHED+2        ;ANY MORE WORDS IN BUFFER
        PUSHJ   P,MFDIN         ;NO, GET ANOTHER BUFFER
        ILDB    W,MFDHED+1      ;NEXT WORD INTO W
        TRZ     F,MFDI
        POPJ    P,

MFDIN:  IN      MFD,            ;READ ANOTHER BUFFER
        POPJ    P,              ;HAPPY, RETURN
        STATO   MFD,IOBAD       ;END OF BUFFER?
        JRST    ENDMFD          ;GO DO WRAPUP
        STATO   MFD,BTL         ;IS BLOCK TOO LARGE
        JRST    RMFDIN          ;PRINT ERROR MESSAGE
        PRLIN1  <BLOCK TOO LARGE#>
RMFDIN: PRLIN1  <ERROR READING MFD@>
        JRST    FS1AA           ;ASK WHAT NEXT

;READ UFD

UFD2:   PUSHJ   P,GETUFD        ;GET THE FIRST WORD
        JUMPE   W,UFD2
        MOVE    U,W             ;PLACE IN FIRST WORD REGISTER
        PUSHJ P,GETUFD
        PUSH P,W
        PUSHJ   P,GETUFD        ;READ WORD 2 OF UFD ENTRY
        MOVEM   W,UFDW2#        ;SAVE WORD 2 OF UFD ENTRY
        PUSHJ   P,GETUFD        ;READ WORD 3 OF UFD ENTRY
        MOVEM   W,UFDW3#        ;SAVE WORD 3 OF UFD ENTRY
        PUSHJ   P,GETUFD        ;READ WORD 4 OF UFD ENTRY
        MOVEM   W,UFDW4#        ;SAVE WORD 4 OF UFD ENTRY
        POP P,W
        POPJ P,
GETUFD: TRO     F,UFDI
        SOSG    UFDHED+2        ;ANY MORE WORDS IN BUFFER?
        PUSHJ   P,UFDIN         ;NO, GET SOME
        ILDB    W,UFDHED+1      ;NEXT WORD
        TRZ     F,UFDI
        POPJ    P,

UFDIN:  IN      UFD,            ;READ ANOTHER BUFFER
        POPJ    P,              ;HAPPY, RETURN
        STATO   UFD,IOBAD       ;END OF FILE?
        JRST    ENDUFD          ;YES, GO DO WRAPUP
        STATO   UFD,BTL         ;BLOCK TOO LARGE?
        JRST    RUFDIN          ;NO
        PRLIN1  <BLOCK TOO LARGE#>
RUFDIN: PRLIN1  <ERROR READING UFD@>
        PUSHJ   P,PRPP          ;PRINT UFD NUMBER
        MOVE    P,SAVUFD        ;BACK-UP PUSH-DOWN LIST
        JRST    MORE1           ;GO TO NEXT USER'S UFD
;DISK FILE INPUT

FILIN:  TRO     F,FILI
        IN      FIL,            ;GET NEXT BUFFER
        JRST    FILIN2          ;HAPPY, RETURN
        TRZ     F,FILI
        STATO   FIL,IOBAD       ;END OF FILE?
        JRST    ENDFIL          ;YES, DO WRAPUP
RFILIN: PUSHJ   P,UFLERR        ;PRINT ERROR MESSAGE & FILE NAME
        JRST    ENDFIL

FILIN2: TRZ     F,FILI          ;SUCCESSFUL INPUTS
        POPJ    P,

;MAG TAPE OUTPUT

TAPOUT: TRO     F,TAPO
        MOVEI   B,TAPSIZ-4      ;DATA WORDS/BUFFER
        SUBB    B,TAPHED+2      ;COMPUTE WORDS USED
        JUMPE   B,NULTAP        ;NONE USED, DONT OUTPUT
        HRRZ    A,TAPHED        ;ADDR OF BUFFER CURRENTLY IN USE
        HRRM    B,2(A)          ;BUFFERED BINARY WORD COUNT FOR FAILSAFE
        AOS     B
        HRRZM   B,1(A)          ;TOTAL DATA WORD COUNT FOR MONITOR
TAPOU1: OUT     TAP,            ;WRITE ANOTHER RECORD
        JRST    TAPO33          ;SUCCESS, CHECK FOR EOT
        AOS     RECCNT          ;COUNT BAD RECORDS TOO
        STATZ   TAP,IOTEND      ;END OF TAPE?
        JRST    ENDTAP          ;YES, DO WRAPUP
        STATZ   TAP,400000      ;NO, WRITE-LOCKED TAPE?
        JRST    WRLOK           ;YES, PRINT MESSAGE & START OVER
        STATZ   TAP,200000      ;NO, PHYSICAL DEVICE ERROR?
        JRST    DEVERR          ;YES, TELL OPERATOR
RTAPOU: PRLIN1  <MAG TAPE WRITE ERROR--TRYING AGAIN@>
        GETSTS  TAP,B           ;CLEAR ERROR BITS FOR RETRY
        ANDCMI  B,760000
        SETSTS  TAP,(B)
        MTAPE   TAP,7           ;BACKSPACE RECORD
        EMTAPE  13              ;WRITE 3 INCH BLANK TAPE
        JRST    TAPOU1          ;TRY AGAIN

TAPO33: AOS     RECCNT          ;ANOTHER RECORD OUTPUT FOR THIS FILE
        STATZ   TAP,IOTEND      ;END OF TAPE?
        JRST    ENDTAP          ;YES, DO WRAPUP
        JRST    TAPOU3          ;NO, RESET BUFFER WORD COUNT

;WRITE HEADER OR TRAILER ON TAPE

LABBLT: MOVSI   A,FIRBLK        ;ADDR OF HEADER
        HRR     A,TAPHED+1      ;GET BUFFER DATA ADDR FROM BYTE PTR
        MOVEI   B,4(A)          ;SET STOP AT 5TH DATA WORD
        BLT     A,(B)           ;BLT HEADER INTO BUFFER
        HRRM    B,TAPHED+1      ;RESET BYTE POINTER
        MOVNI   A,3             ;RESET COUNT
        ADDM    A,TAPHED+2
        SOS     TAPHED+2        ;ADJUST FOR NON-LOOP CALL
        PUSHJ   P,TAPOUT        ;WRITE ONE RECORD
CLSUSR: CLOSE   TAP,            ;ASK THE MONITOR TO CLOSE
        CALLI   TAP,WAIT        ;WAIT UNTIL OUTPUT FINISHED
NULTAP: MOVSI   A,400000        ;TURN OFF VIRGIN BIT
        ANDCAB  A,TAPHED
        AOS     A               ;SET BYTE POINTER TO BEG OF BUFFER
        HRRM    A,TAPHED+1
TAPOU3: MOVEI   A,TAPSIZ-4      ;DATA WORDS/BUFFER -1
        HRRZM   A,TAPHED+2      ;BUFFER COUNT
        IDPB    A,TAPHED+1      ;BUFFER COUNT TO 1ST DATA WORD
        TRZ     F,TAPO
        POPJ    P,              ;RETURN

;BLT HEADERS INTO TAPE BUFFER

DIRBLT: MOVSI   A,FILMRK        ;HEADER WORD FOR DIRECTORY
        HRR     A,TAPHED+1      ;GET BUFFER DATA ADDR FROM BYTE PTR
        MOVEI   B,XLOOKN+2(A)   ;SET STOP AT LAST RETRIEVAL WORD
        BLT     A,(B)           ;BLT HEADER INTO BUFFER
        HRRM    B,TAPHED+1      ;RESET BYTE POINTER
        MOVNI   A,XLOOKN+1      ;RESET COUNT
        ADDM    A,TAPHED+2
        POPJ    P,              ;RETURN

;BLT DIRECTORY INTO WATCHER BLOCK
;(SAVES WORDS CURSTR THRU FILDIR+3)

WATBLT: MOVE    T,WATPNT        ;GET POINTER
        MOVSI   A,FILDIR-1      ;GET START OF DIR (CURSTR)
        HRRI    A,1(T)          ;GET START OF WATCH BLOCK
        MOVEI   B,4(A)          ;GET END OF BLT
        BLT     A,(B)           ;TRANSFER
        POPJ    P,              ;RETURN
ENDFIL:        MOVE    B,TAPHED+2      ;CHECK FOR EMPTY BUFFER
        CAIE    B,777           ;SKIP IF NOT EMPTY
        SOS     TAPHED+2        ;DECREMENT TO ADJUST COUNT
        PUSHJ   P,TAPOUT        ;OUTPUT LAST BUFFER
        MOVE    S,WATPNT        ;GET CURRENT BLOCK
        HRR     T,RECCNT        ;GET RECCNT
        HRRZM   T,WATSIZ-1(S)   ;STICK IT IN WATCH BLOCK
        HRRZ    S,(S)           ;POINT TO NEXT BLOCK
        MOVEM   S,WATPNT        ;SAVE NEXT BLOCK ADDRESS
        CAIN    W,(SIXBIT /UFD/)        ;SKIP KILL IF UFD
        JRST    ENDFI1
        TLNN    F,KILLSW        ;DO WE KILL DISK FILES SAVED ON TAPE?
        JRST    ENDFI1          ;NO
        CLOSE   FIL,DNC         ;CLOSE FOR RENAME
        MOVE    A,[XWD FILDIR,FILDIR+1] ;ZERO TO KILL FILE
        BLT     A,FILDIR+XLOOKN
        RENAME  FIL,FILDIR      ;KILL FILE
        PUSHJ   P,ENTERR        ;WE FAILED SOMEHOW
ENDFI1: CLOSE   FIL,DNC
        RELEASE FIL,            ;GIVE UP USER FILE
        TRNE    F,CONTSW        ;ARE WE IN CONTINUATION PROCESS?
        JRST    APOPJ           ;YES, RETURN TO RESAVE
        MOVE    P,SAVFIL        ;RESET PDP
        JRST    MORE2           ;GO READ NEXT USER FILE

ENDUFD: SKIPN   YNAME           ;SKIP IF RESTART NAME NOT ZERO
        SKIPE   YEXT            ;SKIP IF RESTART EXT ZERO
        JRST    RNERR           ;RESTART FILE NAME NOT FOUND
        TRZ     F,UFDI
        TLZN    F,FILFND        ;ANY FILES FOR THIS USER?
        JRST    NULUFD          ;NOPE
ENUFD1: PUSHJ   P,CLSUSR        ;WRITE EOFS ON TAPE
        MOVEM   F,NULF#         ;SAVE FLAGS IN CASE OF EOT
        STATZ   TAP,IOTEND      ;EOT?
        JRST    ENDTP1          ;YES, GO TAKE CARE
        MOVE    U,UFDDIR+2
        TRNE    F,USRSW
        CAME    U,SYSPP
        PUSHJ   P,PRPP          ;PRINT PROJ-PROG #
        SKIPA   
NULUFD: PUSHJ   P,NULTAP        ;RESET BUFFER
        CLOSE   UFD,DNC
        RELEASE UFD,            ;GIVE UP UFD DDB
        TRNE    F,CONTSW        ;WE IN CONTINUATION PROCESS?
        POPJ    P,              ;YES, RETURN
        MOVE    P,SAVUFD        ;RESET PDP
        JRST    MORE1           ;GO READ NEXT UFD
ENDMFD:        AOS     STRNDX          ;INCREMENT DSKNAM BLK INDEX
        JRST    SAVE0           ;SEE IF THERE ARE MORE MFD'S
ENDMF0: TRZ     F,MFDI          ;FREE UP MFD
        SKIPE   STPPN           ;SKIP IF NO PROBLEMS ON RESTART
        JRST    RPPNER          ;ERROR IN FINDING PPN FOR RESTART
        CLOSE   MFD,DNC
        RELEASE MFD,
        TLO     F,MFDDNE        ;INDICATE FINISHED WITH MFD
        MOVSI   A,777740        ;0 INDICATES LAST TAPE
        ANDCAM  A,FIRBLK+3
        MOVN    A,TAPNUM        ;NEGATE TAPE #
        HRRM    A,FIRBLK+2
        EMTAPE  7               ;BAKSP OVER EOF
        PUSHJ   P,LABBLT        ;WRITE TRAILER RECORD
ENDMF2: IFN     REWIND,<EMTAPE  1>      ;REWIND IT
        PRLIN1  <SAVE COMPLETED@>
        MOVE    P,SAVMFD        ;RETURN
        AOS     (P)
        JRST    CRLFLF
;ROUTINE TO CONTINUE A SINGLE USER SAVE OR 
;ENTIRE DISK SAVE WHEN EOT IS REACHED

;IF WE BELIEVE WE HAVE JUST FINISHED OUTPUTTING A
;USER AREA, ENTER AT ENDTP1
;IF WE REACH EOT IN THE PROCESS OF FILE OUTPUT
;WE ENTER AT ENDTAP

ENDTP1: TLO     F,USRDNE        ;SET USER AREA (UFD) DONE SWITCH

ENDTAP: TLOE    F,TENDF         ;IF WE HAVE JUST OUTPUT TRAILER,
        JRST    ENDTP2          ;FINISH UP
        TLZE    F,MFDDNE        ;OTHERWISE PREPARE TO SWITCH TO NEW TAPE
        JRST    ENDMF2          ;WE WERE WRITING LAST TRAILER - MERELY FINISH

        PUSHJ   P,CORFIL        ;FIND FILE WE ARE SURE IS AT LEAST PARTLY ON TAPE
        PUSHJ   P,TAPFIL        ;FIND FILE ON TAPE AND POSITION FOR TRAILER OUTPUT
        PUSHJ   P,TRLOUT        ;SET UP TRAILER AND
ENDTP2: PUSHJ   P,MESOUT        ;OUTPUT MESSAGES AND REWIND
        PUSHJ   P,CWAIT         ;WAIT FOR /C TO CONTINUE
        JRST    RESAVE          ;RESAVE WATCH RING FILES AND CONTINUE

;ROUTINE TO POINT B TO WATCH BLOCK OF FILE WHICH
;WILL BEGIN NEXT TAPE

CORFIL: MOVE    B,WATPNT        ;LOOK IN CURRENT FILE
        TLNE    F,USRDNE        ;POINT B TO LAST FILE OUT
        HLRZ    B,(B)           ;IF USRDNE ON
        MOVEM   B,SAVWAT#       ;SAVE WATCH RING POINTER (WATPNT CHANGES AFTER /C)
        MOVEM   B,SAVB#         ;SAVE VALUE OF B
        MOVE    T,RECCNT        ;GET RECCNT FOR CURRENT FILE

CORFL1: CAILE   T,TAPN          ;ARE WE SURE SOME OF THIS FILE ON TAPE?
        POPJ    P,              ;YES, RETURN
        HLRZ    B,(B)           ;NO, LOOP BACK TO PREVIOUS BLOCK
        MOVEM   B,SAVB
        ADD     T,6(B)          ;ADD RECORDS FOR THIS FILE
        JRST    CORFL1          ;CHECK AGAIN
;ROUTINE TO FIND FILE ON TAPE AND POSITION
;TAPE FOR TRAILER OUTPUT
;WE WANT TO BACKSPACE T + 1 RECORDS TO BE IN FRONT OF FILE TO START SEARCH

TAPFIL: CLOSE   TAP,            ;CLOSE TAPE FILE
        MTAPE   TAP,7           ;BACKSPACE OVER CLOSE EOF
        CLOSE   FIL,DNC         ;CLOSE DISK FILE
TAPFL2: EMTAPE  7               ;BACKSPACE ANOTHER RECORD
        SOJGE   T,TAPFL2        ;JUMP TO PLACE READER BEFORE START OF FILE
        PUSHJ   P,SETIN         ;SET UP TAPE FOR INPUT
        GETSTS  TAP,A           ;GET STATUS
        TRO     A,40            ;SET TO SYNCHRONOUS INPUT
        SETSTS  TAP,(A)         ;RESET STATUS
        TLZ     F,TENDF         ;TURN OFF TAPE END BIT
TAPFL3: PUSHJ   P,FTAPIN        ;LOOK FOR DIRECTORY OR EOF
        JRST    .-1             ;EOF, LOOK AGAIN
        MOVE    B,SAVB          ;RESTORE WATCH BLOCK POINTER
        MOVE    T,B             ;SAVE POINTER
TAPFL4: AOS     B               ;POINT TO FIRST DATA WORD
        ILDB    S,TAPHED+1      ;GET DATA WORD
        CAME    S,(B)           ;ARE DATA WORDS =?
        JRST    TAPFL3          ;NO, LOOK AT NEXT TAPE FILE
        CAIGE   B,5(T)          ;ALL WORDS COMPARED?
        JRST    TAPFL4          ;NOT FINISHED, COMPARE NEXT
        MTAPE   TAP,7           ;YES, BACKSPACE OVER THIS RECORD
        MOVE    B,-2(B)         ;GET THIS PROJ,PROG #
        CAME    B,3(T)          ;SAME PROJ-PROG?
        MTAPE   TAP,7           ;NO, BACKSPACE OVER EOF
        MOVEM   B,UFDDIR+2      ;YES
        PUSHJ   P,CRLF          ;EXTRA LINE TO SET OFF END OF TAPE
        MOVE    B,4(T)          ;FIRST FILE NAME ON NEXT TAPE
        PUSHJ   P,PRFNAM        ;PRINT THE FILE NAME
        MOVE    B,5(T)          ;EXTENSION OF FIRST FILE ON NEXT TAPE
        PUSHJ   P,PREXT         ;PRINT THE EXTENSION
        PUSHJ   P,PRPP1         ;PRINT PROJ-PROG #
        PR1     < AND THOSE FOLLOWING ARE CONTINUED ON THE NEXT TAPE.#>
        TRO     F,CONTSW        ;SET CONTINUATION FLAG
        TLO     F,TENDF
        PUSHJ   P,INIT1         ;REINIT TAPE AND SET VIRGIN HEADER
        OUTPUT  TAP,            ;DUMMY
        JRST    TAPOU3          ;SETS UP HEADER AND RETURNS
;OUTPUT TRAILER BLOCK

TRLOUT: MOVE    A,FIRBLK+3      ;SET TAPE CONTINUATION BIT IF
        TRNE    F,CONTSW        ; CONTINUATION FLAG IS ON
        TLO     A,400000
        MOVEM   A,FIRBLK+3
        MOVN    A,TAPNUM        ;NEGATE TAPE #
        HRRM    A,FIRBLK+2      ;RESET TRAILER
        JRST    LABBLT          ;WRITE TRAILER, OFS, RETURN

;OUTPUT MESSAGES AND REWIND TAPE

MESOUT: TLZ     F,TENDF         ;CLEAR EOT BIT
        MTAPE   TAP,1           ;START REWIND
        PRLIN1  <END OF FAILSAFE TAPE#>
        MOVE    A,TAPNUM        ;GET TAPE #
        PUSHJ   P,PRNUM         ;PRINT IT
        PRLIN1  <TO CONTINUE, MOUNT A NEW TAPE ON THE SAME DRIVE,@>
        PR1     <THEN TYPE "/C"@>
        JRST    ASTRSK          ;TYPE "*" THEN POPJ

;CHECK FOR SPECIAL /C
;IF NON, PROCESS AS USUAL

CWAIT:  INPUT   TTI,            ;GET COMMAND
        PUSH    P,TTYI+1        ;SAVE JUST IN CASE
        ILDB    CH,TTYI+1       ;GET FIRST CHAR
        CAIE    CH,"/"          ;IS IT A SLASH?
        JRST    PJRST           ;NO, PROCESS AS USUAL
        ILDB    CH,TTYI+1       ;YES
        CAIE    CH,"C"          ;IS IT A C?
        JRST    PJRST           ;NO, PROCESS AS USUAL
        JRST    APOPJ           ;RETURN
PJRST:  POP     P,TTYI+1
        JRST    FS1B            ;GO PROCESS USUAL COMMAND
;RESAVE FILES WE THOUGHT WE HAD SAVED

RESAVE: MOVE    P,SAVMFD        ;RESTORE PDP
        TLZ     F,FIRSW         ;NOT FIRST TAPE ANYMORE
        PUSHJ   P,SAVE2         ;WRITE OUT NEW HEADER

RESAV1: MOVE    B,SAVB
        HLRZ    A,(B)           ;GET BLOCK BEFORE START
        MOVEM   A,WATPNT        ;POINT WATPNT TO PREVENT IT FROM CLOBBERING
                                ;OLD BLOCKS TOO SOON
        HRLI    S,1(B)          ;NO, SET UP LOOKUP HEADER
        HRRI    S,FILDIR-1      ;SET UP START OF DESTINATION
        MOVEI   T,XLOOKN+1(S)   ;SET END
        BLT     S,(T)           ;HEADER IS SET
        CAMN    B,SAVWAT        ;ARE WE AT LAST FILE?
        JRST    RESAV2          ;YES
        PUSHJ   P,MORE7         ;NO
        MOVE    B,SAVB
        HRRZ    B,(B)           ;LOOK AT NEXT BLOCK
        MOVEM   B,SAVB
        MOVE    A,3(B)          ;GET PROJ-PROG #
        CAME    A,FILDIR+1      ;SAME?
        PUSHJ   P,ENUFD1        ;NO, END USER AREA
        JRST    RESAV1          ;CHECK THIS FILE
RESAV2: TLZE    F,USRDNE        ;WERE WE BETWEEN USERS?
        JRST    RESAV3          ;YES
        PUSHJ   P,MORE7         ;NO, OUTPUT THIS GUY
        TRZ     F,CONTSW        ;TURN OFF CONTSW
        JRST    MORE2           ;LOOK FOR NEXT FILE
RESAV3: TRZ     F,CONTSW        ;TURN OFF CONTSW
        JRST    ENUFD1          ;GO ON
;RESTORE COMMAND EXECUTION

UNSAVE: PUSHJ   P,CKOPER        ;RETURN ONLY IF OPER LICENSE
        TRO     F,RESTSW        ;/R IN PROGRESS
        TRZ     F,SAVSW         ;TURN OFF IN CASE OF /C
UNSAV2: PUSHJ   P,SETIN         ;INSURE BUFFERS
        TRZ     F,CONTSW        ;CLR CONTINUATION TAPE FLAG
IFE     REWIND,<SETZM   JFLAG>  ;CLR /J CTR
IFN     REWIND,<EMTAPE  1>      ;BEGINNING OF TAPE
        PUSHJ   P,ITAPIN        ;READ FIRST RECORD
        JRST    ILLFMT          ;EOF FIRST - ERROR
        PRLIN1  <FAILSAFE TAPE#>
        MOVE    D,TAPHED        ;WHERE THE HEADER IS
        HLRE    A,2(D)          ;XWD HEADER FLAG,INTERNAL WORD COUNT
        JUMPLE  A,ILLFMT        ;INSIST ON HEADER FLAG (VERSION #)
        MOVE    A,6(D)          ;IS PP NUMBER CORRECT?
        CAME    A,FSPP
        JRST    ILLFMT          ;NOPE
        HRRES   A,4(D)          ;GET TAPE NUMBER
        MOVMS   A               ;MAGNITUDE ONLY
        PUSHJ   P,PRNUM         ;PUBLISH IT
        PR1     < RECORDED#>
        MOVE    A,5(D)          ;DATE AND TIME
        PUSHJ   P,DATIME        ;PUBLISH SAME
        TRNE    F,PRNTSW        ;PRINTING?
        POPJ    P,              ;YES, RETURN
        SKIPGE  5(D)            ;A CONTINUATION TAPE?
        TRO     F,CONTSW        ;YES, SET FLAG
        PRLIN1  <IF YOU WISH TO CONTINUE WITH THIS TAPE, TYPE "/C"@>
        SETZM   TTYI+2          ;CLEAR ALL PREVIOUS INPUTS
        PUSHJ   P,ASTRSK
        JRST    FS2             ;GET NEXT COMMAND
;CONTINUE RECEIVED

CONTIN: TRNN    F,RESTSW        ;RESTORE?
        JRST    FS1.2           ;NO, RESTART
        PUSHJ   P,CRLF          ;YES,CONTINUE ENTIRE DISK RESTORE - FORMAT OUTPUT
        TRZE    F,CONTSW        ;A CONTINUATION TAPE?
        JRST    UNSLPJ          ;YES
        PUSHJ   P,ITAPIN        ;READ THE HEADER RECORD EOF
        JRST    SETSTR          ;READ FIRST STRUCTURE 1,1 FILES
        JRST    ILLFMT          ;ANY OTHER RECORDS AN ERROR

;SET UP NEXT STRUCTURE

SETSTR: TRO     F,TAPI
        PUSHJ   P,ITAP          ;GET FIRST RECORD
SETST1: TRZ     F,TAPI
        MOVE    A,5(D)          ;MAKE SURE WE'RE AT 1,1
        CAME    A,SYSPP
        JRST    ILLFMT          ;NO
        MOVEM   A,UFDDIR+1      ;SAVE PP# FOR UFD LOOKUPS
        MOVE    A,3(D)          ;GET STRUCTURE NAME
        MOVEM   A,CURSTR
        MOVEM   A,READPP
        INIT    UFD,BUFBIN
READPP: 0                       ;SIXBIT /STRNAM/
        XWD     0,UFDHED        ;LOOKUPS ONLY
        JRST    GETSTR          ;THIS STR NOT AROUND ANYMORE
        PUSHJ   P,MKUFBF        ;GET BUFS
        MOVEI   A,XLOOKN        ;SET SPECS FOR LOOKUP
        MOVEM   A,UFDDIR
        MOVE    A,6(D)          ;UFD NAME
        MOVEM   A,UFDDIR+2
        HLLZ    A,7(D)          ;EXT="UFD"
        MOVEM   A,UFDDIR+3
        LOOKUP  UFD,UFDDIR      ;IS THIS UFD ON THIS STRUCTURE?
        JRST    FIXUFD          ;NO, MAKE ONE LIKE THE ORIGINAL

;MOVE TO NEXT UFD

SETST2: PUSHJ   P,FTAPIN        ;IGNORE DATA RECORDS
        JRST    UNSLU2          ;EOF - START RESTORING
        PUSHJ   P,ITAP2         ;CK FOR TRAILER
        CLOSE   UFD,DNC
        JRST    SETST1          ;NO, PROCESS NEXT UFD
;MAKE A UFD ON THIS STR WITH QUOTA FROM THE TAPE

FIXUFD: PUSHJ   P,UFDSPK
        MOVE    A,READPP
        MOVEM   A,FIX2
        INIT    MFD,BUFBIN
FIX2:   0                       ;SIXBIT/STRNAM/
        XWD     MFDHED,0
        JRST    GETSTR          ;TRY ELSEWHERE
        MOVEI   A,UFDDIR
        HRLI    A,4(D)
        BLT     A,UFDDIR+XLOOKN ;RESTORE SPECS AFTER LOOKUP
        SETZM   UFDDIR+25               ;ZERO CURRENT SIZE SINCE NO FILES
        ENTER   MFD,UFDDIR      ;CREATE THIS UFD
        JRST    GETSTR          ;CANT
        PUSHJ   P,MAKU2         ;RELEASE MFD
        JRST    SETST2

;SET UP SPECS TO CREATE A UFD

UFDSPK: MOVSI   A,2(D)          ;START OF SPECS IN TAPBUF
        HRRI    A,UFDDIR        ;SPEC AREA
        BLT     A,UFDDIR+XLOOKN
        SETZM   URBPOS          ;CLR SPECIAL ITEMS
        SETZM   URBNXT
        SETZM   URBPRD
        SETZM   URBUFD
        SETZM   URBELB
        SETZM   URBEUN
        POPJ    P,

;CREATE A UFD ON SOME OTHER STRUCTURE IF POSSIBLE

GETSTR: INIT    UFD,BUFBIN      ;LOOK FOR UFD ANYWHERE
        SIXBIT  /DSK/
        XWD     0,UFDHED
        JRST    DNTAVL          ;NO DISK
        PUSHJ   P,UFDSPK        ;GET SPECS
        PUSHJ   P,MKUFBF        ;GET BUFRS
        LOOKUP  UFD,UFDDIR
        PUSHJ   P,MAKUFD        ;NOT AROUND - HAVE TO MAKE ONE
        JRST    SETST2          ;FOUND ONE

;GET UFD BUFFERS

MKUFBF: MOVEI   A,UFDBUF        ;ALLOW THE LOOKUP SOME BUFFERS
        MOVEM   A,JOBFF
        INBUF   UFD,UFDN
        POPJ    P,
UNSLU2:        TRO     F,TAPI          ;INPUT FLAG
        PUSHJ   P,ITAP          ;GET 1ST RECORD OF NEXT FILE
        TRZ     F,TAPI          ;CLEAR AFTER XFER
        JRST    UNSLU3
UNSLU5: TRO     F,TAPI          ;INPUT FLAG
        PUSHJ   P,ITAP          ;GET 1ST RECORD OF NEXT FILE
        TRZ     F,TAPI          ;CLEAR AFTER XFER
        MOVE    B,FILDIR+1
        MOVEM   B,UFDDIR+2
        PUSHJ   P,PRPP          ;PRINT LAST USER RESTORED
UNSLU3: MOVE    A,5(D)          ;GET PP#
        CAMN    A,SYSPP         ;1,1?
        JRST    SETST1          ;YES
        MOVEM A,OUTPPN          ;SAVE FOR OUTPUT (XFER NEED IT)
        TRO     F,TAPI          ;SET FOR RENTER
UNSLU1: PUSHJ   P,XFER          ;MOVE A USER FILE FROM TAPE TO DISK
        JRST    UNSLU5          ;EOF - NEXT USER
        TRZ     F,TAPI          ;CLEAR AFTER XFER
        JRST    UNSLU1          ;EXCELSIOR

UNSL33: POP     P,A             ;RESTORE PDPOINTER TO CORRECT LEVEL
        HRRZ    A,(P)           ;IF THIS IS 2ND, 3RD, ETC ERROR IN
        CAIN    A,UNSLPJ+1      ; A ROW, HAVE TO POP OFF UNSLPJ+1 TOO
        POP     P,A
UNSLPJ: PUSHJ   P,FTAPIN        ;MOVE TAPE FORWARD
        JRST    UNSLU5          ;EOF-NEXT USER
        JRST    UNSLU1          ;DIRECTORY-NEXT FILE

;MAKE A UFD WITH INFINITE QUOTA

MAKUFD: PUSHJ   P,GETPAK        ;INIT MFD FOR NEW UFD'S
        PUSHJ   P,UFDSPK
        MOVE    A,[-1_-1]       ;ENORMOUS # OF BLKS
        MOVEM   A,URBQTO        ;TO LOGGED-OUT QUOTA WORD
        MOVEM   A,URBQTI        ;& LOGGED-IN QUOTA
        HRLZI   A,URBLGI        ;SET LOGGED-IN BIT
        HRRI    A,.RPDIR        ;PLUS UFD BIT
        MOVEM   A,URBSTS
MAKU1:  TRO     F,UFDO
        MOVEI   A,MFDBUF        ;ROOM FOR ENTER
        MOVEM   A,JOBFF
        OUTBUF  MFD,MFDN
        ENTER   MFD,UFDDIR      ;CREATE A UFD
        PUSHJ   P,NOUFD         ;CANT
MAKU2:  OUTPUT  MFD,
        CLOSE   MFD,DNC
        RELEAS  MFD,            ;WRITE IT OUT
        TRZ     F,UFDO
        POPJ    P,
TAPEND:        CLOSE   TAP,            ;CLEAR UP TAPE BUFFERS
IFN     REWIND,<EMTAPE  1>      ;REWIND
        PRLIN1  <END OF FAILSAFE TAPE#>
        HRRE    A,4(D)          ;GET TAPE NUMBER
        MOVMS   A               ;MAGNITUDE
        PUSHJ   P,PRNUM         ;PRINT IT
        PR1     < FOR#>
        MOVM    A,5(D)          ;GET DATE AND TIME
        PUSHJ   P,DATIME        ;PRINT THEM
        SKIPL   5(D)            ;CONTINUED?
        JRST    FINTAP          ;NO
IFE     REWIND,<MTAPE   TAP,1>  ;REWIND
        PRLIN1  <TO CONTINUE RESTORING THE DISK, MOUNT#>
        PR1     <THE NEXT FAILSAFE TAPE ON THE SAME DRIVE@>
        PR1     <AFTER IT HAS BEEN MOUNTED, TYPE "/R"@>
        JRST    FS1AA           ;* AND WAIT FOR NEXT COMMAND
FINTAP: CLOSE   FIL,DNC
        RELEASE FIL,
        CLOSE   UFD,DNC
        RELEASE UFD,
        PRLIN1  <THIS IS THE FINAL TAPE.@>
        PUSHJ   P,CRLFLF
        JRST    FS1AA

UFDFA2: POP     P,A             ;SET TO PROPER LEVEL
        PRLIN1  <CANNOT WRITE UFD:#>
        PUSHJ   P,PRPP
UNSLU4: PUSHJ   P,FTAPIN        ;MOVE TAPE FORWARD(NO INPUT)
        JRST    UNSLU5          ;PROCESS NEXT USER
        JRST    UNSLU4          ;IGNOR INDIVIDUAL USERS' FILES

XFER:  MOVE    B,TAPHED        ;WHERE TAPE BUFFER IS
        MOVE    U,10(B)         ;GET TIME & DATE OF TAPE FILE
        MOVE    R,CRDATE        ;GET SET DATE
        SKIPLE  5(B)            ;IS TAPES PPN ANY GOOD?
        PUSHJ   P,CHKCRE        ;TAPE FILE OLDER?
        JRST    FTAPIN          ;YES, GET NEXT FILE
        JFCL                    ;=
        HRRZ    A,7(B)          ;CHECK ACCESS DATE ON TAPE
        TRZ     A,770000        ;MASK OUT NON DATE BITS
        CAMGE   A,ACCDAT        ;PRIOR TO SET DATE?
        JRST    FTAPIN          ;YES, DON'T RESTORE THIS FILE
        MOVSI   U,3(B)          ;NO, SET UP LOOKUP HEADER
        HRRI    U,FILDIR-1
        BLT     U,FILDIR+XLOOKN
        MOVE U,OUTPPN
        MOVEM U,FILDIR+1        ;SET OUTPUT PPN (OUTPPN SET ON /R)
        SKIPN   FILDIR+2        ;NAME NON-ZERO?
        JRST    FTAPIN          ;ZERO. IGNORE.
        TLNE    F,NEWRSW        ;IS N SWITCH ON
        JRST    XFER1           ;YES, DON'T CHECK DISK FILE DATE
        INIT    CHK,14          ;INIT FOR DISK FILE DATE CHECK
        SIXBIT  /DSK/
        XWD     0,CHKHED        ;=UFDHED
        JRST    NODSK           ;CAN'T INIT
        MOVEI   U,CHKBUF        ;SET UP BUFFERS
        MOVEM   U,JOBFF
        INBUF   CHK,CHKN
        LOOKUP  CHK,FILDIR      ;CHECK CURRENT DISK FILE
        JRST    XFER3           ;RESTORE FILE IF LOOKUP FAILS
        MOVE    R,FILDIR+4      ;GET DISK DAT
        MOVE    U,10(B)         ;GET TAPE DAT
        PUSHJ   P,CHKCRE        ;TAPE FILE OLDER?
        JRST    FTPIN1          ;YES, CLOSE CHK AND GET NEXT FILE
        JRST    FTPIN1          ;=
        CLOSE   CHK,DNC         ;NO, CLOSE DISK FILE
XFER3:  PUSHJ   P,RSTHDR        ;RESTORE LOOKUP HEADER
XFER1:  MOVEI   A,XLOOKN+2      ;REMOVE HEADER WORDS FROM BEGINNING OF FILE
        ADDM    A,TAPHED+1
        MOVNI   A,XLOOKN+2
        ADDM    A,TAPHED+2
        MOVE    A,CURSTR        ;INIT STR IT CAME FROM
        MOVEM   A,XFSTR
        INIT    FIL,BUFBIN
XFSTR:  0                       ;SIXBIT /STRNAM/
        XWD     FILHED,0
        JRST    XXFER           ;HAVE TO PUT IT ELSEWHERE
        TRO     F,FILO
        PUSHJ   P,GETFBF        ;GET BUFFERS FOR FILE
        PUSHJ P,CKLIC
        HLLZS FILDIR+XLICN      ;DON'T ENTER LICENSE
        ENTER   FIL,FILDIR
        JRST    XXFER           ;NOT AVAIL. - PUT FILE ELSEWHERE
        JRST    XFER0           ;BEGIN RESTORE
XXFER:  CLOSE FIL,40    ;MAKE SURE IT DOES NOT GET IN DIR
        PUSHJ   P,RSTHDR        ;RESTORE FILE HEADER INFO FOR ENTER
        INIT    FIL,BUFBIN      ;TRY TO PUT IT ANYWHERE
        SIXBIT  /DSK/
        XWD     FILHED,0
        JRST    DNTAVL          ;NO DISK
        PUSHJ   P,GETFBF        ;GET BUFFERS
        HLLZS FILDIR+XLICN
        ENTER   FIL,FILDIR
        PUSHJ   P,ENTERR        ;FAILURE - CONTINUE WITH NEXT FILE

;THE FOLLOWING SECTION OF CODE TRANSFERS A SINGLE DISK-ORIENTED FILE
;FROM TAPE TO THE DISK.

XFER0:  TRZ     F,FILO
        AOS     TAPHED+2        ;ADJUST FOR SOSG ENTERED FROM ABOVE
XFER2:  SOSLE   TAPHED+2        ;GET A WORD FROM TAPE
        JRST    XFER2A          ;SOME THERE ALREADY
        PUSHJ   P,TAPIN
        POPJ    P,              ;EOF RETURN
        JRST    CPOPJ1          ;NEXT FILE ENCOUNTERED
XFER2A: ILDB    T,TAPHED+1
        SOSG    FILHED+2        ;STASH INTO USER FILE
        PUSHJ   P,FILOUT
        IDPB    T,FILHED+1
        JRST    XFER2           ;TRY AGAIN

CKLIC:  HRRZ A,FILDIR+XLICN
        JUMPE A,CPOPJ
        MOVE A,[XWD FILDIR+1,FILPP]
        BLT A,PROT
        PUSHJ P,TFLWF
        PRLIN1 <NEEDS LICENSE#>
        HRRZ A,FILDIR+XLICN
        PUSHJ P,PRNUM8
        JRST CRLF
ITAPIN:        PUSHJ   P,TAPIN         ;DIRECTORY OR EOF MUST BE NEXT
        POPJ    P,              ;EOF
        JRST    CPOPJ1          ;DIRECTORY
        JRST    ILLFMT          ;IF DATA, GO TO ERROR ROUTINE

FTPIN1: CLOSE   CHK,DNC
FTAPIN: PUSHJ   P,TAPIN         ;IGNORE DATA PORTIONS
        POPJ    P,              ;EOF
        JRST    CPOPJ1          ;DIRECTORY
        JRST    FTAPIN          ;IGNORE DATA BLOCKS

;GET FIRST RECORD OF A FILE

ITAP:   PUSHJ   P,ITAPIN        ;1ST REC. MUST BE DIRECTORY
        JRST    ILLFMT          ;EOF
ITAP2:  MOVE    D,TAPHED        ;WHERE DATA IS
        HLRE    A,2(D)          ;IS THIS THE TRAILER?
        JUMPLE  A,CPOPJ         ;NO, RETURN
        POP     P,A             ;YES
        JRST    TAPEND

;CLR KEY ARGS IN EXTENDED LOOKUP/ENTER SPECS

FILSPK: SETZM   FRBPOS
        SETZM   FRBNXT
        SETZM   FRBUFD
        SETZM   FRBELB
        SETZM   FRBEUN
        POPJ    P,

;RESTORE LOOKUP/ENTER FILE SPECS

RSTHDR: MOVSI   U,4(B)          ;RESTORE LOOKUP HEADER
        HRRI    U,FILDIR
        BLT     U,FILDIR+XLOOKN
        MOVE U,OUTPPN
        MOVEM U,FILDIR+1
        PUSHJ   P,FILSPK
        POPJ    P,

;SETUP BUFFERS FOR FILE ENTER

GETFBF: MOVEI   A,FILBUF        ;SETUP BUFFERS FOR USER FILE
        MOVEM   A,JOBFF
        OUTBUF  FIL,FILN
        POPJ    P,
;      TAPIN USUALLY RETURNS TO CALL +3
;       IT HAS TWO EXCEPTIONAL RETURNS WHICH SKIP ZERO OR ONE
;       AND THEN RETURN: END OF FILE
;                        DIRECTORY RECORD
;                        DATA RECORD

TAPIN:  TLZE    F,TENDF         ;HAVE WE ALREADY REACHED TRAILER?
        JRST    CPOPJ1          ;YES, SIMULATE DIRECTORY RECORD READ(CALL+2)
        TRO     F,TAPI
        IN      TAP,            ;READ ANOTHER BUFFER
        JRST    TAPIN2          ;READ OK
        STATZ   TAP,IOEND       ;END OF FILE?
        JRST    TAPIN4          ;YES, END USER FILE
RTAPIN: TRO     F,TAPI          ;SET FOR RETURN FROM FORMAT ERROR BELOW
        PUSHJ   P,TFRERR        ;NO, PRINT ERROR MESSAGE & FILE NAME
        GETSTS  TAP,A           ;GET ERROR BITS
        TRZ     A,760000        ;CLEAR ERROR BITS
        SETSTS  TAP,(A)         ;SET NEW STATUS
        CLOSE   TAP,            ;RESET FOR NEXT INPUT
        JRST    RENINT          ;GO FIND WHERE YOU WERE

TAPIN4: TRZ     F,TAPI
        CLOSE   TAP,            ;CLEAR END BIT
        CLOSE   FIL,DNC         ;FINISH FIL
        POPJ    P,              ;RETURN CALL+1 (EOF)

TAPIN2: TRZ     F,TAPI
        ILDB    A,TAPHED+1      ;PICKUP WORD COUNT
        SOS     TAPHED+2        ;ADJUST WD CT BELOW THIS WORD
        HLRE    A,A
        JUMPE   A,CPOPJ2        ;JUMP IF DATA RECORD
        CLOSE   FIL,DNC
        JUMPG   A,TAPIN6        ;HEADER/TRAILER
        TRNE    F,DOINGJ        ;TAKE DIR RETURN IF /J IN PROGRESS
        JRST    CPOPJ1          ;(MAY BE A BOOTSTRAP FILE)
        TLZ     A,777777
        CAIN    A,-6
        JRST    FAILSC          ;OLD STYLE TAPE
        CAIE    A,-1            ;IF NOT DIR HEADER
        JRST    RTAPIN          ;IS AN ERROR
        JRST    CPOPJ1          ;DIRECTORY
CPOPJ2: AOS     0(P)            ;RETURN TWO SKIPS
CPOPJ1: AOSA    0(P)            ;RETURN +1
APOPJ:  POP     P,A             ;RETURN ONE LEVEL UP
CPOPJ:  POPJ    P,              ;RETURN
FILOUT:        TRO     F,FILO
        OUT     FIL,            ;OUTPUT THE FILE
        JRST    FILOU3          ;WRITTEN OK
RFILOU: PRLIN1  <ERROR WHILE WRITING USER FILE@>
        PUSHJ   P,PRUFL         ;PRINT USER'S FILE NAME
        JRST    RENINT          ;DELETE FILE AND RETURN

FILOU3: TRZ     F,FILO
        POPJ    P,

;FOUND A TRAILER

TAPIN6: MOVE    B,TAPHED        ;GET TAPE NUMBER
        HRRE    A,4(B)          ;IF HEADER, RETURN
        JUMPG   A,CPOPJ1        ;YES, IS A HEADER
                                ; RETURN AS IF DIRECTORY
        TLO     F,TENDF         ;LOGICAL EOT FOUND
        CALLI   TAP,WAIT        ;WAIT FOR TAPE TO PASS ONE EOF
        POPJ    P,              ;YES, SIMULATE EOF READ
;SELECTIVE RESTORE COMMAND

;ACCEPT LETTER OR DIGIT, AND BUILD IDENTIFIER

NLETTR: AOJG    R,FS2           ;IGNORE CHARACTERS AFTER SIXTH
        MOVEI   CH,-40(CH)      ;CONVERT TO SIXBIT
        IDPB    CH,S            ;STASH INTO IDENT
        TLO     F,CSSW!ETWASW   ;INDICATE CHAR SEEN
        JRST    FS2             ;GET ANOTHER CHARACTER

;FILE DELIMITER

EXTDLM: TLOE    F,PERSW         ;PERIOD SEEN?
        JRST    FILDL1          ;YES, THAT MAKES TWO
        TLZN    F,CSSW          ;ANYTHING SEEN?
        JRST    EXDLM1          ;BLANK FILENAME
        MOVE    A,IDENT         ;YES, STORE IDENT AS FILNAME
        MOVEM   A,NAME
EXDLM1: TLZ     F,CSSW+PAS1SW   ;START WITH A CLEAN SLATE
        MOVNI   R,3             ;BUT ONLY GET 3 LETTERS NEXT TIME
        JRST    FS1.7           ;GET EXTENSION (OR DELIMITER)

;ALL FILES CHARACTER

ALLFIL: TLZE    F,CSSW          ;PART OF A NAME?
        JRST    ALLFI1          ;YES, * IN NAME ILLEGAL
        TLZ     F,PPFSW         ;START AT THE BEG OF USR AREA
        TLNE    F,PERSW         ;PERIOD SEEN?
        TLOA    F,EXTSW!ALLFSW!ETWASW   ;INDICATE EXT WILD
        TLO     F,NAMESW!ALLFSW!ETWASW  ;INDICATE NAME WILD
        JRST    EXDLM1

;OUTPUT SPEC DELIMITER

COMMA:  TLO     F,COMF          ;MORE ITEMS IN LIST
        PUSHJ   P,DO            ;PROCESS FILE
        JRST    FS1.5           ;GET NEXT IDENT

;LINE TERMINATOR

LINTER: PUSHJ   P,DO            ;PROCESS LAST FILE
        JRST    FS1A            ;GET NEXT COMMAND
;SELECTIVE RESTORE ROUTINE
;PROCESSES ONE FILE SPECIFICATION

DO:     TRO     F,SLRESW        ;SELECTIVE RESTORE IN PROGRESS
        TLZN    F,ETWASW        ;ANYTHING ON THIS LINE SO FAR?
        POPJ    P,              ;NO
        MOVE    A,IDENT#        ;STASH IDENTIFIER AWAY
        TLNN    F,PERSW         ;HAS A PERIOD BEEN TYPED?
        MOVEM   A,NAME          ;NO, IDENT WAS NAME
        MOVEM   A,EXT           ;(YES) STORE AS EXTENSION
        TLZN    F,PERSW         ;DO WE HAVE AN EXTENSION?
        SETZM   EXT             ;NO, MAKE NULL EXTENSION
        TLNE    F,ALLFSW        ;ANY * TYPED?
        JRST    DOALL1          ;YES, PROCESS THEM
        TLNE    F,PPFSW         ;ARE WE POSITIONED?
        JRST    DO1             ;YES
        PUSHJ   P,SETIN         ;INSURE BUFFERS, INIT MTA, CLEAR BUFFER BITS
IFN     REWIND,<EMTAPE  1>      ;REWIND
        SETZM   DOCTR2#         ;CTR OF USER'S AREAS PROCESSED
DO2:    SETZM   DOCTR1#         ;CTR OF ALL USER'S AREAS ON TAPE
DO22:   TLO     F,PAS1SW        ;SET FOR 1ST PASS THRU AREA
        PUSHJ   P,FINDPP        ;MOVE TO NEXT AREA FOR THIS USER
        JRST    DO10            ;HIT EOT
        AOS     DOCTR2          ;AREA FOUND, COUNT IT
        AOS     DOCTR1
DO1:    PUSHJ   P,THSFIL        ;SHOULD WE COPY THIS FILE?
        JRST    NOTME           ;NOT ME
        PUSHJ   P,USRUFD        ;GET A UFD IF HE NEEDS IT
        TLO     F,PPFSW         ;SET POSITION SW FOR A STOP HERE
        MOVEI   A,1             ;RESET SUBCTR
        MOVEM   A,DOCTR2
        TLZ     F,PAS1SW        ;INDICATE FIL FOUND
        TRO     F,TAPI          ;SET FOR RENTER
        PUSHJ   P,XFER          ;COPY IT
        JRST    BKFIL           ;EOF, BACKSPACE AND CLOSE TAPE
        TRZ     F,TAPI          ;CLEAR AFTER XFER
        POPJ    P,              ;RETURN

NOTME:  PUSHJ   P,FTAPIN        ;FLUSH DATA UNTIL EOF OR DIRECT
        JRST    NOTME1          ;EOF
        JRST    DO1             ;DIRECTORY, LOOK AT IT

NOTME1: TLNN    F,PPFSW         ;DID WE START IN THIS AREA?
        JRST    NOTME2          ;NO, GO ON TO NEXT AREA
        TLOE    F,PAS1SW        ;LOOKED THRU ALL OF THIS FILE?
        JRST    NOTME2          ;YES
        PUSHJ   P,DO4           ;GO BACK TO BEGINNING OF FILE
        PUSHJ   P,ITAPIN        ;INSIST UPON DIRECTORY
        JRST    NOTME2          ;EOF NOT SUFFICIENT
        JRST    DO1             ;GO LOOKUP NAME

DO10:   IFN     REWIND,<EMTAPE  1>      ;REWIND
        MOVN    A,DOCTR1        ;COMPARE CTRS
        ADDM    A,DOCTR2        ;CTR2=CTR2-CTR1
        SKIPN   DOCTR2          ;BEEN THRU ALL AREAS?
        JRST    NOTME3          ;YES
IFE     REWIND,<PUSHJ   P,REWJMP>       ;NO, REWIND
        TLZ     F,PPFSW
        MTAPE   TAP,6           ;FIX FOR NEXT FINDPP
        JRST    DO2             ;TRY FIRST ON TAPE
NOTME3: PUSHJ   P,BKFIL         ;BACK TO BEGINNING OF USER
        PRLIN1  <CANNOT FIND FILE#>
        MOVE    B,NAME          ;PUBLISH NAME OF FILE
        PUSHJ   P,PRNAME
        MOVE    B,EXT
        PUSHJ   P,PREXT
        PUSHJ   P,CRLF          ;OUTPUT MESSAGE
        POPJ    P,              ;ASK WHAT NEXT

NOTME2: SKIPN   DOCTR2          ;BEEN THRU ALL AREAS?
        JRST    NOTME3          ;YES
        TLZ     F,PPFSW         ;NO
        MTAPE   TAP,6           ;FIX FOR NEXT FINDPP
        JRST    DO22            ;TRY NEXT ON TAPE

;REWIND TAPE & THEN /J BACK TO SAVE SET WE WERE ON

IFE     REWIND,<
REWJMP: EMTAPE  1               ;REWIND
        MOVE    A,JFLAG         ;GET OLD /J COUNT
        MOVEM   A,JCTR#
        SETZM   JFLAG           ;REFRESH /J CTR
REW1:   SOSGE   JCTR            ;LOOP TO DO AUTO /J'S
        POPJ    P,              ;RETURN
        PUSHJ   P,JMPSAV        ;MOVE TO NEXT SAVE SET
        JFCL                    ;ALWAYS SKIPS
        JRST    REW1            ;ANY MORE?
>
;SELECTIVE RESTORE
;PROCESSES FILE SPECIFICATIONS WITH *'S

DOALL1: IFN     REWIND,<EMTAPE 1>       ;REWIND
        PUSHJ   P,SETIN
DOALL4: PUSHJ   P,FINDPP        ;MOVE TO NEXT AREA FOR THIS USER
        JRST    DOALL3          ;HIT EOT
DOALL5: PUSHJ   P,THSFIL        ;LOOK FOR OTHER HALF OF SPEC
        JRST    DOALL2          ;NOT THIS FIL
        PUSHJ   P,USRUFD        ;GET A UFD IF NEED BE
        TRO     F,TAPI          ;SET FOR RENTER
        MOVEI   B,.+3           ;SAVE RET ADDR IN CASE OF ERROR
        MOVEM   B,DOALLE#       ;TO HELP CLEAN UP PDL
        PUSHJ   P,XFER          ;FOUND, COPY IF DATE OK
        JRST    DOALL7          ;EOF, TRY NEXT AREA
        TRZ     F,TAPI          ;CLEAR AFTER XFER
        JRST    DOALL5          ;TRY THIS FIL

DOALL2: MOVEI   B,.+3           ;SAVE RET ADDR IN CASE OF ERROR
        MOVEM   B,DOALLE
        PUSHJ   P,FTAPIN        ;IGNORE THIS FILE
        JRST    DOALL7          ;EOF ENCOUNTERED
        JRST    DOALL5          ;DIRECTORY, TRY IT
DOALL7: MTAPE   TAP,6           ;ADV BEFORE NEXT FINDPP
        JRST    DOALL4

DOALL3: TRZ     F,TAPI          ;CLEAR AFTER XFER
        CLOSE   FIL,DNC         ;FINISH LAST FIL
        TLZ     F,NAMESW!EXTSW!ALLFSW   ;TURN OFF SWITCHES SET BY *
DOALL6: IFE     REWIND,<TLZE    F,COMF  ;SKIP REWIND IF NO MORE TO RESTORE
        PUSHJ   P,REWJMP>       ;REPOSITION IF MORE IN LIST
IFN     REWIND,<EMTAPE  1>      ;REPOSITION TAPE FOR THIS PP #
        POPJ    P,              ;RETURN FOR NEXT SPEC

;MISCELLANEOUS MOVEMENTS

BKFIL:  PUSHJ   P,BKSP
        EMTAPE  16              ;SKIP TO START OF USER
        TRZ     F,TAPI
        POPJ    P,

BKSP:   TRZ     F,TAPI          ;CLEAR AFTER XFER
        MTAPE   TAP,7           ;BACK ONE RECORD
        EMTAPE  17              ;ONE OTHERWISE
        CLOSE   TAP,            ;CLEAR BUFFERS
        POPJ    P,              ;RETURN

ADVNCE: MTAPE   TAP,7           ;BACK ONE RECORD
        EMTAPE  16              ;SKIP
        CLOSE   TAP,            ;CLEAR BUFFERS
        POPJ    P,              ;RETURN

DO4:    MTAPE   TAP,17          ;BACKSPACE PAST EOF
        MTAPE   TAP,17          ;BACKSPACE PAST FILE
        EMTAPE  16              ;READ PAST EOF
        POPJ    P,              ;RETURN
;POSITION TAPE FOR USER
;CALL:  PUSHJ P,FINDPP
;       EOT RETURN
;       FOUND AREA RETURN

FINDPP: IFE REWIND,<SKIPN JFLAG>        ;SKIP BKSP IF /J JUST DONE
        PUSHJ   P,BKSP          ;BACKSPACE FILE
        EMTAPE  16              ;ADVANCE FILE
        MOVEI   A,0
        MOVE    A,USRPPN        ;GET USER'S PROJ-PROG NUMBER
        MOVEM   A,UFDDIR+1      ;STASH
FINDP1: PUSHJ   P,FTAPIN        ;IGNORE DATA
        POPJ    P,              ;HAVE REACHED LOGICAL EOT
        MOVE    B,TAPHED        ;WHERE THE DATA IS
        HLRE    A,2(B)          ;TRAILER OR HEADER?
        JUMPG   A,CPOPJ         ;YES
        MOVE    A,5(B)          ;NO, GET DIRECTORY PP
        CAMN    A,UFDDIR+1      ;SAME AS USER'S?
        JRST    CPOPJ1          ;YES, GO HOME
        PUSHJ   P,ADVNCE        ;ADVANCE TO BEGINNING OF NEXT USER
        JRST    FINDP1          ;CHECK THIS USER AREA

;COMPARE SPECIFIED NAME WITH NAME ON TAPE
;CALL:  PUSHJ P,THSFIL
;       UNSUCCESSFUL RETURN
;       SUCCESSFUL RETURN

THSFIL: MOVE    B,TAPHED        ;FIND BEG OF BUFFER
        TLNE    F,NAMESW        ;LOOK AT NAME?
        JRST    THSFI2          ;IGNORE
        MOVE    A,NAME          ;CHECK EQUALITY
        CAME    A,6(B)
        POPJ    P,              ;UNSUCCESSFUL RETURN
THSFI2: TLNE    F,EXTSW         ;LOOK AT EXTENSION?
        JRST    CPOPJ1          ;NO - SUCCESSFUL
        HLLZ    A,7(B)
        HLLZS   EXT             ;CLR RT HLF IN CASE OF ERROR 17
        CAMN    A,EXT
        JRST    CPOPJ1          ;SUCCESSFUL RETURN
        POPJ    P,              ;UNSUCCESSFUL
;CREATE AN INFINITE UFD FOR THE USER IF HE NEEDS IT

USRUFD: MOVE    D,TAPHED        ;WHERE DATA IS
        MOVE    A,3(D)          ;STR
        MOVEM   A,CURSTR
        MOVEM   A,USRPP
        MOVEM   A,FIXU2
        INIT    UFD,BUFBIN      ;LOOKUP ONLY
USRPP:  0
        XWD     0,UFDHED
        JRST    GETUSR          ;TRY ELSEWHERE
        PUSHJ   P,MKUFBF
        MOVEI   A,XLOOKN
        MOVEM   A,UFDDIR
        MOVE    A,SYSPP
        MOVEM   A,UFDDIR+1
        MOVE    A,5(D)
        MOVEM   A,UFDDIR+2
        MOVSI   A,(SIXBIT /UFD/)
        MOVEM   A,UFDDIR+3
        LOOKUP  UFD,UFDDIR
        JRST    FIXUSR          ;NO UFD -  HAVE TO MAKE ONE
UFCL:   CLOSE   UFD,DNC
        RELEAS  UFD,
        POPJ    P,

FIXUSR: INIT    MFD,BUFBIN      ;CREATE UFD ON DESIRED STR
FIXU2:  0
        XWD     MFDHED,0
        JRST    GETUSR
        PUSHJ   P,DOUFD         ;SET UP SPECS
        OUTBUF  MFD,MFDN
        ENTER   MFD,UFDDIR
        JRST    GETUSR          ;TRY ELSEWHERE
        JRST    MAKU2           ;CLOSE MFD & RET

GETUSR: INIT    UFD,BUFBIN      ;UFD ANYWHERE?
        SIXBIT  /DSK/
        XWD     0,UFDHED
        JRST    DNTAVL          ;BAD NEWS
        MOVSI   A,(SIXBIT /DSK/)
        MOVEM   A,CURSTR
        PUSHJ   P,DOUFD         ;SET SPECS
        PUSHJ   P,MKUFBF
        LOOKUP  UFD,UFDDIR
        JRST    UFCL            ;FOUND
        PUSHJ   P,GETPAK        ;NO UFD - MAKE ONE ANYWHERE
        PUSHJ   P,DOUFD
        JRST    MAKU1           ;ENTER & RET

DOUFD:  MOVE    A,[XWD UFDDIR+3,UFDDIR+4]
        SETZM   UFDDIR+3
        BLT     A,UFDDIR+XLOOKN
        MOVSI   A,(SIXBIT /UFD/)
        MOVEM   A,UFDDIR+3
        MOVE    A,[-1_-1]
        MOVEM   A,URBQTI
        MOVEM   A,URBQTO
        HRLZI   A,URBLGI        ;LOGGED-IN BIT
        HRRI    A,.RPDIR        ;PLUS UFD BIT
        MOVEM   A,URBSTS
        POPJ    P,
;DATE CHECK
;CALL:  PUSHJ   P,CHKCRE
;RETURNS:       R>U
;               R=U
;               R<U

CHKCRE: HRRZ    S,R             ;GET DATE
        TRZ     S,770000        ;MASK OFF NON-DATE BITS
        HRRZ    W,U             ;GET DATE
        TRZ     W,770000        ;MASK
        SUB     S,W             ;COMPARE
        JUMPG   S,CPOPJ         ;NO, DON'T SKIP SINCE R>U
        JUMPL   S,CPOPJ2        ;YES, SKIP SINCE R<U
        TLZ     R,777740        ;MUST CHECK TIME
        TLZ     U,777740        ;MASK OFF NON DATE OR TIME
        TRZ     R,7777          ;MASK OFF TIME
        TRZ     U,7777          ;MASK OFF TIME
        CAMLE   R,U             ;R < OR = U?
        POPJ    P,              ;NO
        CAML    R,U             ;=?
        JRST    CPOPJ1          ;YES, SKIP
        JRST    CPOPJ2          ;<, SKIP 2
CKCREU: HRRZ    S,R             ;GET DATE
        TRZ     S,770000        ;MASK OFF NON-DATE BITS
        HRRZ    W,U             ;GET DATE
        TRZ     W,770000        ;MASK OFF NON-DATE BITS
        SUB     S,W             ;COMPARE DATES
        JUMPG   S,CPOPJ         ;DON'T SKIP SINCE R>U
        JUMPL   S,CPOPJ2        ;SKIP ONCE SINCE R<U
        TLZ     R,777740        ;MASK OFF NON-TIME BITS
        TRZ     R,7777          ;MASK OFF NON-TIME BITS
        IMULI   R,74            ;CONVERT MINUTES TO SECONDS
        TLZ     U,774000        ;MASK OFF NON-TIME BITS FROM UFD
        TRZ     U,7777          ;MASK OFF NON-TIME BITS
        CAMLE   R,U             ;SKIP  IF UFD TIME GREATER THAN OR EQUAL
        POPJ    P,              ;UFD TIME IS LESS SO RETURN WITH NO SKIP
        CAML    R,U             ;SKIP IF TIMES ARE NOT EQUAL
        JRST    CPOPJ1          ;EQUAL, SO SKIP ONCE
        JRST    CPOPJ2          ;UFD TIME IS GREATER SO SKIP TWICE
;INITIALIZE MAGNETIC TAPE

SETOUT: HRLZI   A,TAPHED        ;SET UP FOR OUTPUT
        SKIPA
SETIN:  HRRZI   A,TAPHED        ;SET UP FOR INPUT
        MOVEM   A,INOUT         ;SET HEADER
IFE     REWIND,<MOVE    A,INIT1 ;GET INIT FCTN
        TRZ     A,40            ;CLR SYNC INPUT BIT
        XOR     A,SYNCIN        ;GET CURRENT SYNC INPUT REQUEST
        MOVEM   A,INIT1>        ;RESET
        MOVE    A,FS6BIT        ;DOES LOGICAL DEVICE FAILSA EXIST
        CALLI   A,DEVCHR
        TLNE    A,20            ;IS DEVICE A MAGTAPE?
        TLNN    A,40            ;IS IT AVAILABLE?
        JRST    NOTAP           ;NO TO EITHER: COMPLAIN
INIT1:  INIT    TAP,BUFBIN!NOCNT        ;ALLOW PRIVATELY-BUFFERED MTAPES
FS6BIT: SIXBIT  /FAILSA/
INOUT:  XWD     TAPHED,TAPHED   ;BUFR HDR FOR INPUT OR OUTPUT (SET BY ABOVE)
        JRST    NOTAP           ;UNLIKELY
        MOVE    A,[XWD 400000,TAPBUF+1] ;INIT 1ST WORD OF HEADER
        MOVEM   A,TAPHED
        POPJ    P,              ;RETURN

;INIT THE DISK STRUCTURE WITH THE MOST ROOM LEFT ON IT
;IN ORDER TO CREATE A UFD FOR THIS PROJ-PROG #

GETPAK: MOVSI   PAKNAM,(SIXBIT /DSK/)
        MOVEM   PAKNAM,DEVICE
        SETZ    PAKNAM,         ;INIT SYSSTR UUO LOOP
        SETZ    PAKFRE,
        PUSH    P,PAKFRE        ;MAKE ROOM ON THE PDL
GETP1:  CALLI   PAKNAM,SYSSTR   ;GET NEXT STRUCTURE
        JRST    GETP2
        JUMPE   PAKNAM,GETP2    ;END OF LIST
        MOVE    A,[XWD 3,PAKNAM]        ;WANT 1ST THREE ARGS RETURNED
        CALLI   A,DSKCHR
        JRST    GETP2
        CAMLE   PAKFRE,(P)      ;MORE ROOM HERE THAN ON LAST?
        TLNE    A,367000        ;YES, THIS DRIVE USABLE?
        JRST    GETP1           ;NO, LOOK AT NEXT PACK
        MOVEM   PAKNAM,DEVICE   ;YES, SAVE BEST SO FAR
        MOVEM   PAKFRE,(P)
        JRST    GETP1           ;CONSIDER NEXT PACK
GETP2:  INIT    MFD,BUFBIN      ;INIT SELECTED DEVICE MFD
DEVICE: SIXBIT  /DSK/           ;SIXBIT /STRNAM/
        XWD     MFDHED,0
        JRST    DNTAVL          ;NOT AVAILABLE
        JRST    APOPJ           ;RETURN
;PRINT A DIRECTORY OF AN ENTIRE FAILSAFE TAPE ON LOGICAL DEVICE LST

PRINT:  IFN     REWIND,<EMTAPE 1>
        TRO     F,PRNTSW!LISTSW
IFE     REWIND,<SETZM   JFLAG>  ;CLR /J CTR
        INIT    TTY,AL          ;INIT A LISTING DEVICE
        SIXBIT  /LST/           ;LOGICAL NAME LST
        XWD     TTYO,0
        JRST    NOLIST
        MOVEI   A,FILBUF        ;USE DSK BUFFERS
        MOVEM   A,JOBFF
        OUTBUF  TTY,TTYN
        MOVE    A,FS6BIT        ;ENTER A FILE NAME FOR LIST
        MOVEM   A,LSTDIR
        MOVSI   A,(SIXBIT /DIR/)
        MOVEM   A,LSTDIR+1
        SETZM   LSTDIR+3
        ENTER   TTY,LSTDIR
        JRST    NOLIST          ;CANT ENTER FILE NAME
        OUTPUT  TTY,
        PUSHJ   P,UNSAV2        ;PRINT HEADER
        PUSHJ   P,FTAPIN
        JRST    PRINT2          ;FIRST EOF
        JRST    BADFMT
PRINT2: PUSHJ   P,FTAPIN
        JRST    BADFMT          ;EOF. LOGICAL EOT
        MOVE    Q,TAPHED        ;DIR RECORD
        HLRZ    B,2(Q)          ;GET NUMBER CODE
        CAIE    B,-1            ;TRAILER?
        JRST    PRINT3          ;YES, DONE
        PUSHJ   P,LIST3         ;PRINT USER DIRECTORY
        JRST    PRINT2          ;GO DO NEXT USER
PRINT3: PUSHJ   P,TTYINI        ;GO FIX TTY
IFN     REWIND,<EMTAPE  1>      ;REWIND
        JRST    FS1AA           ;GO RESTART
;LIST FILES ON TAPE UNDER USER PROJ-PROG # ON TTY

LIST:   IFN     REWIND,<EMTAPE  1>
        TRO     F,LISTSW
        TLZ     F,PPFSW         ;WE HAVE MOVED TO A NEW PLACE
        PUSHJ   P,SETIN         ;INSURE BUFFERS
LIST4:  PUSHJ   P,FINDPP        ;GET PPN
        JRST    DOALL6          ;EOT
LIST3:  PRLIN1  <DIRECTORY FOR#>
        MOVE    Q,TAPHED        ;WHERE THE DIRECTORY IS
        MOVE    B,3(Q)          ;GET STRUCTURE NAME
        MOVEM   B,CURSTR
        MOVE    B,5(Q)          ;PROJ-PROG NUMBER
        MOVEM   B,UFDDIR+2
        PUSHJ   P,PRPP          ;GIVE NUMBER OF USER
LIST1:  PUSHJ   P,PRFIL         ;PRINT NAME OF FILE
        PUSHJ   P,FTAPIN        ;IGNORE DATA
        JRST    LIST2           ;END OF FILE
        JRST    LIST1           ;PRINTOUT

LIST2:  PUSHJ   P,CRLF          ;FINISH OUTPUT ON TTY
        TRNE    F,PRNTSW        ;PRINTING?
        POPJ    P,              ;YES
        MTAPE   TAP,6
        JRST    LIST4           ;MAYBE THERE IS ANOTHER AREA

;PRINT "FILNAM.EXT      HR:MN DA MON YR"

PRFIL:  MOVE    Q,TAPHED        ;SET PTR TO DATA EVERY TIME
        SKIPN   B,6(Q)          ;FILENAME
        POPJ    P,              ;BLANK. SKIP EOF FLAGS.
        MOVSI   A,(SIXBIT /UFD/)        ;FILENAME=PP#?
        HLLZS   7(Q)
        CAMN    A,7(Q)
        JRST    PRUFD           ;YES
        PUSHJ   P,PRNAME        ;PUBLISH IT
PRFIL2: SKIPE   B,7(Q)          ;(DONT PUBLISH IF NULL)
        PUSHJ   P,PREXT
        MOVEI   CH,11           ;TAB
        SKIPN   7(Q)            ;IF NO EXTENSION, EXTRA TAB
        PUSHJ   P,TYPEA
        PUSHJ   P,TYPEA
        MOVE    A,10(Q)         ;DATE
        JRST    DATIME          ;PUBLISH AND RETURN

PRUFD:  HLRZ    A,6(Q)          ;PRINT NAME AS PP#
        PUSHJ   P,PRNUM8
        PRCHAR  <,>
        HRRZ    A,6(Q)
        PUSHJ   P,PRNUM8
        MOVEI   CH,11
        PUSHJ   P,TYPEA
        JRST    PRFIL2
;PRINT INSTRUCTIONS FOR RUNNING FAILSAFE

HELP:   BLOCK   0
 PRLIN1 </Z, /Y, AND /T HAVE BEEN ADDED TO RESTART AN INTERRUPTED /S.@>
 PR1 </Z SETS THE BEGINNING PPN FOR THE NEXT /S.@>
 PR1 </Y SETS THE BEGINNING FILE NAME, AND /T SETS THE TAPE REEL NUMBER.@>
 PR1 <AT THE END OF EACH TAPE THE NEXT FILE NAME IS NOW PRINTED IN@>
 PR1 <ADDITION TO THE CURRENT PPN.@>
        IFE     REWIND,<        PRLIN1  <REWINDS ARE NO LONGER AUTOMATIC.@>
        PR1     <MORE THAN ONE SAVE SET MAY NOW BE PUT ON A TAPE.@>
        PR1     </W REWINDS TAPE@>
        PR1     </J JUMPS OVER THE CURRENT SAVE SET.@>>
 PRLIN1 </S SAVES THE ENTIRE DISK. YOU MUST HAVE OPERATOR LICENSE.@>
 PRLIN1 </U SAVES THE ENTIRE DISK AREA THE USER IS LOGGED IN UNDER.@>
        PRLIN1  <BOTH /S & /U MAY OPTIONALLY BE FOLLOWED BY A LIST@>
        PR1     <OF FILE STRUCTURES OR DISK DEVICES FROM WHICH FILES@>
        PR1     <ARE TO BE SAVED. IF NO STRUCTURES ARE LISTED,@>
        PR1     <THE SAVE WILL COVER ALL STRUCTURES.@>
        PR1     <EXAMPLE: /UDSKA,DPA3 (16 ARGS MAX)@>
        PRLIN1  </R RESTORES THE ENTIRE DISK. ALSO REQUIRES 1,2@>
        PRLIN1  <NAME1.EXT1,NAME2.EXT2,*.EXT3 ETC RESTORES PARTICULAR FILES@>
        PR1     <FOR ANY USER.@>
        PRLIN1  </P LISTS DIRECTORY OF ENTIRE TAPE ON DEVICE "LST".@>
        PR1     <FILE NAME "FAILSA.DIR" IS USED IF LST=DSK OR DTA.@>
        PRLIN1  </L LISTS DIRECTORY OF ALL THE USER'S FILES ON THE@>
        PR1     <TAPE ON DEVICE TTY.@>
        PRLIN1  <AFTER ANY I/O ERROR WHICH RETURNS TO MONITOR LEVEL@>
        PR1     <TYPE "REENTER"@>
        PRLIN1  </M INITIATES A SAVE AT TIMES 00:00 PLUS N*SLPMIN@>
        PR1     <MINUTES WHERE N IS AN INTEGER AND SLPMIN IS@>
        PR1     <AN ASSEMBLY PARAMETER INITIALLY SET TO 60 DECIMAL@>
        PRLIN1  <MULTIPLE MAGTAPE SAVE IS NOW COMPLETELY IMPLEMENTED.@>
        PRLIN1  </GMMM,NNN(C.R.) SETS THE PROJECT-PROGRAMMER AREA NUMBER @>
        PR1     <SO THAT THE USER MAY RUN /U, /L, AND SELECTIVE RESTORE@>
        PR1     <COMMANDS ON AN AREA OTHER THAN HIS OWN.@>
        PRLIN1  </EMM/DD/YY,TTTT SETS A DATE AND TIME WORD SUCH THAT ON ANY SAVE@>
        PR1     <OR RESTORE ONLY FILES CREATED ON OR AFTER THE SPECIFIED DATE AND@>
        PR1     <TIME WILL BE TRANSFERRED.@>
        PR1     </E(CARRIAGE RETURN) OR THE MONITOR START COMMAND SETS TIME TO@>
        PR1     <MIDNITE OF 1/1/64@>
        PR1     <WHEN A COMMA IS PRESENT IN A /E COMMAND, A NULL DATE FIELD@>
        PR1     <IMPLIES TODAY'S DATE, A NULL TIME FIELD IMPLIES 0000 OR MIDNITE.@>
        PRLIN1  </FMM/DD/YY SETS AN ACCESS DATE WORD SO THAT ON ANY@>
        PR1     <SAVE OR RESTORE ONLY FILES WHICH HAVE BEEN ACCESSED@>
        PR1     <ON OR AFTER THE SPECIFIED DATE ARE TRANSFERRED.@>
        PR1     </F, SETS ACCESS DATE WORD TO TODAY.@>
        PR1     </F WITH NO ARGUMENT AND NO COMMA SETS ACCESS DATE@>
        PR1     <TO 1/1/64 (WHICH IS THE DEFAULT DATE).@>
        PRLIN1  </K/S OR /K/U SAVES ONLY THOSE FILES WHOSE ACCESS@>
        PR1     <DATES ARE PRIOR TO THAT SET BY THE LAST /F COMMAND,@>
        PR1     <AND THEN DELETES FROM TH DISK ALL THOSE FILES WHICH HAVE@>
        PR1     <BEEN SAVED. WHEN /K IS USED 1,1 AND 1,4 FILES ARE@>
        PR1     <NEITHER SAVED NOR DELETED.@>
        PRLIN1  </N/R OR /N(SELECTIVE RESTORE STRING) CAUSES ALL FILES@>
        PR1     <ON THE TAPE TO BE RESTORED REGARDLESS OF THE CREATION@>
        PR1     <DATES OF EXISTING DISK FILES.@>
        PRLIN1  </I,/2,/5,/8 SET MAGTAPE DENSITY TO INSTALLATION STANDARD,@>
       PR1     <200 BPI, 556 BPI, AND 800 BPI RESPECTIVELY.  DENSITY REMAINS@>
        PR1     <SET UNTIL RESET BY ANOTHER SWITCH.@>
        PRLIN1  <FOR MORE DETAILS SEE THE DEC LIBRARY WRITEUP@>
        PR1     <FAILSAFE - DISK SAVE AND RESTORE PROGRAM  DEC-10-YPDA-D@>
        PUSHJ   P,CRLF
        JRST    CPOPJ1
;PRINT INFORMATION ON A GIVEN FILE IN CASE OF UUO FAILURE

PRNMEX: PUSH    P,A             ;PRINTS NAME & EXTENSION OF FILE
        HLLZ    B,EXT           ;GET EXTENSION
        HLLZS   UFDDIR+3        ;CLEAR POSSIBLE GARBAGE FROM SIXBIT "UFD"
        CAMN    B,UFDDIR+3      ;IS THIS "UFD"?
        JRST    NAMPP           ;YES, NAME IS A BINARY PROJ-PROG NR.
        MOVE    B,NAME          ;NO, NAME IS IN SIXBIT
        PUSHJ   P,PRNAME        ;PRINT IT
EXTPP:  MOVE    B,EXT           ;GET EXTENSION
        TLNE    B,-1            ;IF EXTENSION IS NULL, DON'T PRINT IT
        PUSHJ   P,PREXT         ;PRINT EXT.
        JRST    APOPJ           ;POP P,A + POPJ P,
NAMPP:  PUSHJ   P,PRPP          ;PRINT PP-NR. IN UFDDIR
        JRST    EXTPP

;PRINT [PROJ#,PROG#] BY WHICH FILE WAS REFERENCED

PRFLPP: PUSH    P,A
        MOVE    TMP,FILPP       ;GET PP#
        PUSHJ   P,PRPPN         ;PRINT
        JRST    APOPJ           ;GET BACK A, THEN RETURN

;PRINT [PROJ#,PROG#] IN UFDDIR

PRPP:   MOVE    B,CURSTR        ;PRINT CURRENT FILE STRUCTURE
        PUSHJ   P,PRNAME
        MOVEI   CH,11           ;TAB
        PUSHJ   P,TYPEA
PRPP1:  MOVE    TMP,UFDDIR+2    ;GET PP#
        ;FALL INTO PRPPN

;PRINT [PROJ#,PROG#]
; CALL: MOVE    TMP,ADDR OF PP#
;       PUSHJ   P,PRPPN

PRPPN:  PRCHAR  <[>
        HLRZ    A,TMP           ;PROJECT #
        PUSHJ   P,PRNUM8
        PRCHAR  <,>
        HRRZ    A,TMP           ;PROGRAMMER #
        PUSHJ   P,PRNUM8
        PRCHAR  <]>
        JRST    CRLF
;PRINT THE DATE AND TIME FROM AC A
;DATE = ((Y-1964)*12+M-1)*31+D-1 IN BITS 24-35
;TIME IN MINUTES SINCE MIDNITE IN BITS 13-23
;CALL:  PUSHJ   P,DATIME

DATIME: TLZ     A,777740        ;CLEAR ALL NON TIME AND DATE BITS
        LDB     Q,[POINT 12,A,35]       ;PICKUP DATE
        LSH     A,-^D12         ;OUTPUT TIME FIRST
        IDIVI   A,^D60          ;DIVIDE INTO HOURS AND MINS
        MOVE    R,A+1           ;SAVE MINUTES
        PUSHJ   P,PRNUM         ;PUBLISH HOURS
        PRCHAR  <:>
        MOVE    A,R             ;PUBLISH MINUTES
        PUSHJ   P,PRNUM
        PUSHJ   P,SPACE
        IDIVI   Q,^D31*^D12     ;GET YEARS
        IDIVI   R,^D31          ;GET MONTH AND DAY
        AOS     A,S             ;PUBLISH DAY OF MONTH
        PUSHJ   P,PRNUM
        IDIVI   R,6             ;INDEX TO MONTH BYTE PTR
        LDB     A,MONPT(R)      ;NAME OF MONTH
        DPB     A,[POINT 18,MONDPB,23]  ;STASH INTO TEXT
        JSP     A,PR            ;PUBLISH MONTH
MONDPB: SIXBIT  / FOO#/
        MOVEI   A,^D64(Q)       ;PUBLISH YEAR
        PUSHJ   P,PRNUM
        JRST    CRLF            ;RETURN

MONPT:  POINT   18,MONTAB(S),35 ;RH OF TABLE
        POINT   18,MONTAB(S),17 ;LH OF TABLE

MONTAB: SIXBIT  /JULJAN/        ;TABLE OF MONTH NAMES
        SIXBIT  /AUGFEB/
        SIXBIT  /SEPMAR/
        SIXBIT  /OCTAPR/
        SIXBIT  /NOVMAY/
        SIXBIT  /DECJUN/
;THE PRINT ROUTINES ARE CALLED BY
;       JSP     A,PRLIN         ;BEGINS WITH CRLF
;       SIXBIT  /MESSAGE OF ANY LENGTH/
;OR
;       JSP     A,PR            ;BEGINS IMMEDIATELY
;       SIXBIT  /MESSAGE OF ANY LENGTH/

;WITH EITHER CALL, CONTROL RETURNS TO THE LOCATION IMMEDIATELY
;FOLLOWING THE END OF THE MESSAGE
;
;EACH MESSAGE MUST END WITH ONE OF THE FOLLOWING CHARACTERS:
;       @ AT THE END OF THE MESSAGE GIVES A CRLF
;       # AT THE END OF THE MESSAGE GIVES A SPACE

PRLIN:  PUSHJ   P,CRLF
PR:     SKIPA   B,[POINT 6,0(A)]        ;GET INITIAL POINTER
PRLUP:  PUSHJ   P,TYPE          ;TYPE IT OUT
        ILDB    CH,B            ;PICKUP NEXT CHAR
        CAIN    CH,40           ;SIXBIT @
        JRST    PR6             ;FINISH LINE
        CAIE    CH,3            ;SIXBIT #
        JRST    PRLUP           ;GET NEXT CHAR TO TYPE
        PUSHJ   P,SPACE         ;OUTPUT FINAL SPACE
        JRST    PRRET           ;RETURN
PR6:    PUSHJ   P,CRLF          ;OUTPUT CRLF
PRRET:  AOS     B               ;RETURN TO END OF SIXBIT+1
        JRST    @B

;PRINT AN ASTERISK IMMEDIATELY
ASTRSK: PRCHAR  <*>
        OUTPUT  TTY,            ;FORCE IT OUT NOW
        POPJ    P,

;PRINT A SPACE
SPACE:  MOVEI   CH,40           ;ASCII SPACE
        JRST    TYPEA           ;TYPE IT OUT

;PRINT ONE OR TWO CRLF'S
CRLFLF: PUSHJ   P,CRLF          ;TWO CRLF'S
CRLF:   MOVEI   CH,15           ;ASCII CR
        PUSHJ   P,TYPEA         ;TYPE IT OUT
        MOVEI   CH,12-40        ;ASCII LF IN PSEUDO-SIXBIT

;PRINT ONE SIXBIT CHARACTER
TYPE:   MOVEI   CH,40(CH)       ;CONVERT SIXBIT TO ASCII

;PRINT ONE ASCII CHARACTER
TYPEA:  SOSG    TTYO+2          ;OUTPUT THE CHARACTER IN CH
        OUTPUT  TTY,
        IDPB    CH,TTYO+1
        CAIN    CH,12           ;END OF LINE?
        OUTPUT  TTY,            ;YES, FORCE OUTPUT NOW
        POPJ    P,              ;RETURN
;PRINT A CHARACTER - WITH UPARROW IF A CONTROL CHARACTER

PRCH:   MOVEM   CH,PRCH1#       ;STASH CHAR AWAY SAFELY
        PUSHJ   P,CRLF          ;START A LINE OF TEXT
        MOVE    CH,PRCH1        ;UNSTASH THE CHAR
        CAIL    CH,40           ;NORMALLY PRINTING?
        JRST    TYPEA           ;YES, PRINT AND POPJ
        PRCHAR  <^>
        MOVE    CH,PRCH1        ;REGET CHAR
        ADDI    CH,100          ;CONVERT TO CONTROL MUMBLE
        JRST    TYPEA           ;PRINT AND POPJ

;PUBLISH THE OCTAL NUMBER IN AC A
; CALL: PUSHJ   P,PRNUM8
PRNUM8: MOVEI   A+1,10          ;RADIX 8.
        JRST    PRNUMA          ;COMMON ROUTINE

;PUBLISH THE DECIMAL NUMBER IN AC A
;       ALWAYS PUBLISH AT LEAST TWO DIGITS
; CALL: PUSHJ   P,PRNUM
PRNUM:  MOVEI   A+1,12          ;RADIX 10.
PRNUMA: MOVEI   CH,"0"          ;INSURE AT LEAST TWO DIGITS
        CAMGE   A,A+1           ;IS NUMBER BIGGER THAN RADIX?
        PUSHJ   P,TYPEA         ;NO, PUBLISH A LEADING ZERO
        HRRM    A+1,PRN         ;SET UP DIVISION BY RADIX
PRN:    IDIVI   A,0             ;REMAINDER IS LOW ORDER DIGIT
        HRLM    A+1,(P)         ;STASH IN LEFT OF CURRENT PDL WORD
        SKIPE   A               ;ANY MORE DIGITS?
        PUSHJ   P,PRN           ;YES, PUT NEXT DIGIT IN NEXT PDL WORD
        HLRZ    CH,(P)          ;UNSTASH DIGIT
        ADDI    CH,60           ;CONVERT TO ASCII
        JRST    TYPEA           ;OUTPUT IT & POPJ TO .-2 FOR NXT DIGIT, OR RETURN

;PRINT A PERIOD FOLLOWED BY THE LEFTMOST THREE SIXBIT
;       CHARACTERS IN AC B
PREXT:  PRCHAR  <.>
        SKIPA   A,[-3]          ;SET CHARACTER COUNT

;PRINT THE SIX SIXBIT CHARACTERS IN AC B
PRNAME: MOVNI   A,6             ;SET CHARACTER COUNT

;PRINT THE N SIXBIT CHARS IN AC B
;       ENTER WITH -N IN AC A
PRNAM1: MOVEI   CH,0            ;CLEAR CH(=B+1)
        ROTC    B,6             ;ROTATE HIGH ORDER CHAR INTO CH
        PUSHJ   P,TYPE          ;PUBLISH
        AOJL    A,PRNAM1        ;GET NEXT CHAR
        POPJ    P,              ;RETURN
PRFNAM: MOVEI   CH,0            ;CLEAR CH (=B+1)
        JUMPE   B,CPOPJ         ;RETURN IF NOTHING LEFT IN B TO PRINT
        ROTC    B,6             ;ROTATE HIGH ORDER CHAR INTO CH
        PUSHJ   P,TYPE          ;TYPE THE CHARACTER
        JRST    PRFNAM          ;LOOP
;MISC TTY SUBRS

TTYINI: INIT    TTI,AL          ;INITIALIZE TTY INPUT
        SIXBIT  /TTY/
        XWD     0,TTYI
        CALLI   EXIT            ;NO TTY IS FATAL
        MOVEI   A,TTYBFI        ;SETUP TTY BUFFERS FOR INPUT
        MOVEM   A,JOBFF
        INBUF   TTI,TTYN
        INIT    TTY,AL          ;INITIALIZE TTY OUTPUT
        SIXBIT  /TTY/
        XWD     TTYO,0
        CALLI   EXIT
        MOVEI   A,TTYBFO
        MOVEM   A,JOBFF
        OUTBUF  TTY,TTYN
        POPJ    P,              ;YES, RETURN

;TELETYPE INPUT
TYI:    SOSLE   TTYI+2
        JRST    TYIOK           ;CHARS AVAILABLE
        INPUT   TTI,            ;GET A BUFFER
        STATO   TTI,760000      ;EOF OR ERR?
        JRST    TYIOK           ;NO, OK.
        PUSHJ   P,TTYINI        ;ASSUME EOF, GET TTY AGAIN
        TDZA    CH,CH
TYIOK:  ILDB    CH,TTYI+1       ;GET A CHAR
        JUMPE   CH,TYI          ;JUNK NULLS
        POPJ    P,
;MISCELLANEOUS ERROR MESSAGES

;COMPLAIN ABOUT AN ILLEGAL DIGIT
NILSW:  MOVEI   CH,60-133(CH)   ;RESTORE ASCII CODE FOR NUMBER
ILSW:
;COMPLAIN ABOUT AN ILLEGAL CHAR
ILCH:   PUSHJ   P,PRCH          ;PRINT OFFENDING CHAR
        PR1     < IS ILLEGAL@>
        JRST    FS1             ;ASK WHAT NEXT

;FILE NAME ERROR
FILDL1: PRLIN1  <TWO PERIODS#>
        JRST    ALLFI2
ALLFI1: PRLIN1  <ASTERISK#>
ALLFI2: PR1     <IN NAME@>
        JRST    FS1.2

;COMMAND ERROR - RESTART
COMERR: PRLIN1  <COMMAND ERROR@>
        JRST    BEG             ;BACK TO BEGINNING

;COMMAND NOT YET IMPLEMENTED
NOTYET: PUSHJ   P,PRCH          ;PRINT FRUSTRATING CHAR
        PR1     < ISNT YET IMPLEMENTED@>
        JRST    FS1

;NUMBER OUT OF RANGE - RESTART
NUMOUT: PRLIN1  <NUMBER OUT OF RANGE@>
        JRST    BEG             ;BACK TO BEGINNING

NOLIST: PUSHJ   P,TTYINI        ;GO FIX UP TTY
        PRLIN1  <ASSIGN LPT OR TTY THE LOGICAL NAME "LST"#>
        JRST    REINFO

BADFMT: PUSHJ   P,TTYINI        ;REINIT TTY
ILLFMT: PRLIN1  <ILL FORMAT ON TAPE@>
        JRST    FS1.2           ;ASK WHAT NEXT

NOTAP:  PR1     <TYPE "ASSIGN MTA(NO.) FAILSAFE"#>
REINFO: PR1     <THEN START@>
        CALLI   EXIT

NOMFD:  PRLIN1  <CANNOT READ MFD FOR#>
        MOVE    B,CURSTR        ;PRINT STRUCTURE NAME
        PUSHJ   P,PRNAME
        PUSHJ   P,CRLF
        PUSHJ   P,CKOPER        ;OPER LICENSE SET?
        JRST    ENDMFD          ;YES
CKOPER:        HRROI   A,-20           ;LOOK FOR OPERATOR LICENSE
        GETTAB  A,              ;...
        JRST    NOTFS           ;NO LICENSE AVAILABLE
        TRNE    A,100000        ;DOES HE HAVE OPER. LICENSE?
        POPJ    P,              ;YES, TRA 1,4
NOTFS:  PRLIN1  <YOU HAVE NOT SHOWN YOUR OPERATOR LICENSE@>
        CALLI   EXIT

NOUFD:  PRLIN1  <CANNOT RESTORE UFD#>
        PUSHJ   P,PRPP          ;PRINT UFD#
        POPJ    P,

NODSK:  PRLIN1  <CAN'T INIT DISK FOR DATE CHECK@>
        PR1     <TRY AGAIN@>
        JRST    BEG

TFRERR: PRLIN1  <TAPE#>
        JRST    UFLER2
UFLERR: PRLIN1  <DISK#>
UFLER2: PR1     <ERROR READING USER FILE#>
PRUFL:  MOVE    B,[XWD FILDIR+1,FILPP]
        BLT     B,PROT
        PUSHJ   P,PRNMEX        ;PRINT NAME & EXT OF FILE
        JRST    CRLF            ;DO OUTPUT UUO

DNTAVL: PRLIN1  <DISK NOT AVAILABLE@>
        MOVEI   A,0
        PUSHJ   P,CKOPER        ;RETURN ONLY IF OPERATOR LICENSE
        JRST    FS1A

TFLWF:  PR1     <THE FOLLOWING FILE:@>
        PUSHJ   P,PRNMEX        ;PRINT NAME & EXTENSION OF FILE
        PUSHJ   P,PRFLPP        ;PRINT PROJ-PROG NR. SPECIFIED IN FILE
        POPJ    P,

WRLOK:  PRLIN1  <MAG TAPE WRITE-LOCKED@>
        JRST FS1.2

DEVERR: PRLIN1 <MAG TAPE PHYSICAL DEVICE ERROR@>
        JRST    FS1.2


TOOMNY: PRLIN1  <TOO MANY ARGS@>
        JRST    FS1

FAILSC: PRLIN1  <OLD FORMAT TAPE. USE ".R FAILCD"@>
        CALLI   EXIT
;UUO ERROR CHECK ROUTINE(ENTER,LOOKUP, RENAME)
;CALL:  UUO     DSK,E
;       PUSHJ   P,UUOERR
;RETURN DEPENDS UPON UUO
;E OF THE UUO IS USED TO FIND FILENAME

LOOKER:
ENTERR: MOVEI   A,RENTER        ;RETURN IF ENTER OR RENAME ERROR
        EXCH    A,(P)           ;GET CALL ADDRESS+1
        TRO     F,UUOERR        ;SET UUO ERROR FLAG
        MOVEI   A,-2(A)         ;GET ADDR OF UUO SPECS
        MOVEI   B,FILPP-1       ;WHERE TO PUT DIRECTORY-1
        HRL     B,(A)           ;WHERE TO GET DIRECTORY-1
        AOBJN   B,.+1
        BLT     B,PROT
        HRRZ    B,EXT           ;GET RH OF E+1
        TRZ B,400000    ;GET RID OF NEW-OLD FILE BIT
        CAIN    B,17            ;FRAGMENTATION ERROR?
        JRST    E17             ;YES
        CAIL    B,ERRTMX        ;IS IT A KNOWN TYPE OF ERROR?
        MOVEI   B,-1            ;NO
        JRST    @ERRTAB(B)      ;DISPATCH TO ERROR PRINT ROUTINE

        EXP     MISCER          ;UNKNOWN ERROR
ERRTAB: EXP     FNF             ;FILE NOT FOUND
        EXP     NSUCH           ;NO SUCH UFD
        EXP     PROTF           ;PROTECTION FAILURE
        EXP     FBMOD           ;FILE BEING MODIFIED
        EXP     EXNAM           ;TRIED RENAME TO EXISTING NAME
ERRTMX==.-ERRTAB

;FRAGMENT ERROR

E17:    SETZM   FRBALC          ;OK FRAGMENT
        CLOSE FIL,40            ;DO A RESET TO KEEP FILE OUT OF DIR
        POP     P,B
        JRST    (A)             ;NOW TRY THE ENTER

;INDIVIDUAL ERROR PRINT-OUT ROUTINES

FNF:    TRNE    F,UFDI          ;LOOKUP ON UFD?
        JRST    UFDNF           ;YES, SAY SO
        PUSHJ   P,TFLWF         ;IDENTIFY FILE
        PRLIN1  <WAS NOT FOUND ON LOOKUP OR RENAME@>
        POPJ    P,

NSUCH:  PUSHJ   P,TFLWF
        PRLIN1  <REFERENCES NON-EXISTANT USER AREA@>
        POPJ    P,

PROTF:  PRLIN1  <PROTECTION FAILURE ON#>
MISCE1: PUSHJ   P,TFLWF
        POPJ    P,

FBMOD:  PUSHJ   P,TFLWF
        PRLIN1  <IS BEING MODIFIED@>
        POPJ    P,

EXNAM:  PRLIN1  <ATTEMPTED TO RENAME#>
        PUSHJ   P,TFLWF
        PRLIN1  <TO AN EXISTING NAME@>
        POPJ    P,

UFDNF:  PRLIN1  <CANNOT FIND UFD FOR#>
        JRST    PRPP            ;WRITE OUT USER AND RETURN

MISCER: PRLIN1 <UNDEFINED LOOKUP/ENTER FAILURE#>
        MOVEI   CH,"("          ;PRINT (ERR CODE)
        PUSHJ   P,TYPEA
        HRRZ    A,EXT
        TRZ     A,777700        ;SELECT LOW 6 BITS
        MOVEI   A+1,10          ;OCTAL RADIX
        PUSHJ   P,PRNUMA
        MOVEI   CH,")"          ;FINISH THE LINE
        PUSHJ   P,TYPEA
        PR1     < ON#>
        JRST    MISCE1
;REENTER CODE
;START AT RENTER WHEN USER HAS TYPED "REENTER" TO MONITOR

RENTER: TRNE    F,PRNTSW        ;FIX UP TTY IF PRINT WAS IN PROGRESS
        PUSHJ   P,TTYINI
        TRNN    F,-1            ;ANY OPERATIONS IN PROGRESS?
        JRST    BEG             ;NO

        TRZE    F,UUOERR        ;UUO ERROR?
        JRST    RENINT          ;YES, SKIP I/O ERROR CHECKS
        TRNE    F,TAPI          ;TAPE INPUT ERROR?
        JRST    RTAPIN          ;YES, TELL USER
        TRNE    F,FILO          ;FILE OUTPUT IN PROGRESS?
        JRST    RFILOU          ;LET USER KNOW

RENINT: TRNE    F,PRNTSW        ;FIX UP TTY
        PUSHJ   P,TTYINI
        MOVEI   B,17            ;INTERNAL REENTER POINT
        AND     B,F             ;GET ONLY MAJOR OPERATION BITS
        JUMPE   B,FS1A          ;NO /S, /R, /L, OR SELECT. REST. IN PROGRESS
        LSH     B,-1            ;REDUCE BITS TO QUANTITIES FOR INDEXING
        SETZ    T,
        TRZN    B,4             ;WAS /S IN PROGRESS?
        MOVEI   T,3             ;NO
        ADDI    T,3             ;WHERE TO START FROM BOTTOM OF RENTAB
RENDSP: HLRZ    A,RENTAB(T)     ;PICK UP BITS
        TRZ     A,37            ;MASK OUT IND AND XR FIELD
        TRZE    F,(A)           ;MATCH?
        JRST    @RENTAB(T)      ;YES, DISPATCH
        SOJGE   T,RENDSP        ;NO, TRY AGAIN
NOREEN: PRLIN1  <NOT AN I/O FAILURE - CANNOT DETERMINE REENTRY POINT@>
        JRST    FS1.2

;REENTRY PROCESS DISPATCH

RENTAB: XWD     TAPO,RTAPOU
        XWD     FILI,RFILIN
        XWD     UFDI,RUFDIN
        XWD     MFDI,RMFDIN
        XWD     FILO+B,RFILO
        XWD     TAPI+B,RTAPI
        XWD     UFDO+B,RUFDOU

RUFDOU: JRST    UFDFA1          ;SELECTIVE RESTORE IN PROGRESS
        JRST    UFDFA2          ;/R IN PROGRESS
        JRST    FS1A            ;/L IN PROGRESS

RFILO:  JRST    SELRES          ;SEL. REST. FILE OUTPUT TO DSK
        JRST    UNSL33          ;/R OUTPUT FILE TO DSK
        JRST    NOREEN          ;/L OUTPT TO DSK SHOULDN'T HAPPEN

RTAPI:  JRST    SELRES          ;TAPE INPUT SEL. RESTORE
        JRST    UNSL33          ;/R TAPE INPUT
        TRO     F,TAPI          ;READ ERROR ON LISTING
                                ;SET FLAG IN CASE OF ANOTHER ERROR
        JRST    FTAPIN

SELRES: TLNE    F,ALLFSW        ;SEEN *?
        JRST    SELRE1          ;YES
        MOVE    P,[IOWD PDSIZ,PDL]
        SKIPG   TTYI+2          ;MORE COMMANDS IN BUFFER?
        JRST    FS1A            ;NO, PRINT STAR TO GET MORE
        JRST    FS1.5           ;YES, GO AND INTERPRET THEM
SELRE1: POP     P,A
        HRRZ    A,A             ;CLEAN UP THE PDL
        CAME    A,DOALLE        ;BACK TO THE PUSHJ IN DOALL
        JRST    SELRE1          ;THAT GOT US INTO THIS MESS
        EMTAPE  7               ;BACK 1 RECORD IN CASE ALREADY AT EOF
        JRST    DOALL2          ;NOW GO ON TO THE NEXT FILE

UFDFA1: PRLIN1  <CANNOT WRITE UFD#>
        PUSHJ   P,PRPP
        JRST    FS1AA           ;REINITIALIZE




;BUFFER HEADERS

TTYI:   BLOCK   3               ;TTY INPUT BUFFER HEADER**2
TTYO:   BLOCK   3               ;TTY OUTPUT BUFFER HEADER**2
TAPHED: BLOCK   3               ;MAGTAP INPUT OR OUTPUT BUFFER HEADER**2
MFDHED: BLOCK   3               ;DISK MFD BUFFER HEADER**2
UFDHED: BLOCK   3               ;DISK UFD BUFFER HEADER**2
CHKHED: BLOCK   3               ;DATE CHECK FILE HEADER
FILHED: BLOCK   3               ;DISK USER FILE BUFFER HEADER**2

;MTA HEADER BLOCK
FIRBLK: XWD     VERSION,4       ;WD0=XWD HEADER FLAG,BLK WDCT
        SIXBIT  /*FAILS/        ;WD1
        SIXBIT  /AFE   /        ;WD2=XWD SIXBIT "AFE",TAPE SEQ#
                                ;NEGATIVE TAPE SEQ# MEANS TRAILER
        EXP     0               ;WD3=TAPCTD BIT (B0), USRCTD BIT (B1)
                                ;    CRTIME (B13-23), CRDATE (B24-35)
FSPP:   XWD     1,2             ;WD4=FAILSAFE PROJ,PROG #

LSTDIR: BLOCK   4               ;ENTER BLOCK FOR LISTING

SYSPP:  XWD     1,1
CUSPP:  XWD     1,4
;LOOKUP & ENTER SPECS
                                ;EXT LOOKUP     -    OLD LOOKUP
MFDDIR: 0                       ;0,XLOOKN       -     FILNAM
        0                       ;PPN            -     EXT.,ACC.DAT.
        0                       ;FILNAM         -     PROT,MODE,CREAT
        0                       ;EXT.,ACC.DAT.   -    PPN
        0                       ;PROT,MODE,CREAT
        BLOCK   5               ;--NEVER TOUCH--
MRBPOS: 0                       ;--CLR BEFORE RESTORE--
MRBNXT: 0                       ;   "    "       "
MRBPRD: 0                       ;   "    "       "
        BLOCK   1               ;--NEVER TOUCH--
MRBUFD: 0                       ;--CLR BEFORE RESTORE--
MRBSTS: 0                       ;FILE STATUS WORD
MRBELB: 0                       ;--CLR BEFORE RESTORE--
MRBEUN: 0                       ;   "    "       "
        BLOCK   XLOOKN-21       ;---NEVER TOUCH ON SAVE OR RESTORE--

UFDDIR: 0                       ;0,XLOOKN       -     FILNAM
        0                       ;PPN            -     EXT.,ACC.DAT.
        0                       ;FILNAM         -     PROT,MODE,CREAT
        0                       ;EXT.,ACC.DAT.   -    PPN
        0                       ;PROT,MODE,CREAT
        BLOCK   5               ;--NEVER TOUCH--
URBPOS: 0                       ;--CLR BEFORE RESTORE--
URBNXT: 0                       ;   "    "       "
URBPRD: 0                       ;   "    "       "
        BLOCK   1               ;--NEVER TOUCH--
URBUFD: 0                       ;--CLR BEFORE RESTORE--
URBSTS: 0                       ;FILE STATUS WORD
URBELB: 0                       ;--CLR BEFORE RESTORE--
URBEUN: 0                       ;   "    "       "
        BLOCK   XLOOKN-21       ;---NEVER TOUCH ON SAVE OR RESTORE--
URBQTO=URBEUN+2                 ;LOGGED OUT QUOTA
URBQTI=URBQTO-1

FILMRK: XWD     -1,XLOOKN+2     ;FILE HEADER (MUST PRECEDE CURSTR)
CURSTR: 0                       ;CURRENT FILE STRUCTURE (MUST PRECEDE FILDIR)
FILDIR: 0                       ;0,XLOOKN       -     FILNAM
        0                       ;PPN            -     EXT.,ACC.DAT.
        0                       ;FILNAM         -     PROT,MODE,CREAT
        0                       ;EXT.,ACC.DAT.   -    PPN
        0                       ;PROT,MODE,CREAT
        BLOCK   4               ;--NEVER TOUCH--
FRBALC: 0                       ;# OF BLKS NEEDED
FRBPOS: 0                       ;--CLR BEFORE RESTORE--
FRBNXT: 0                       ;   "    "       "
FRBPRD: 0                       ;   "    "       "
        BLOCK   1               ;--NEVER TOUCH--
FRBUFD: 0                       ;--CLR BEFORE RESTORE--
FRBSTS: 0                       ;FILE STATUS WORD
FRBELB: 0                       ;--CLR BEFORE RESTORE--
FRBEUN: 0                       ;   "    "       "
        BLOCK   XLOOKN-21       ;---NEVER TOUCH ON SAVE OR RESTORE--
;MISCELLANEOUS DATA

FILPP:  0                       ;E+3
NAME:   0                       ;E FOR UUO ERRORS
EXT:    0                       ;E+1
PROT:   0                       ;E+2
DSKNAM: BLOCK   20              ;FILE STRUCTURE LIST FOR /S,/U
DSKNME: 0                       ;END OF LIST MARKER - ALWAYS 0
MFDSPK: BUFBIN
ACTSTR: 0                       ;SIXBIT /STRNAM/
        0                       ;OBUF,IBUF FOR MFD

PDL:    BLOCK   PDSIZ

        VAR                     ;MISC. VARIABLES
        LIT                     ;LITERAL TABLE
PATCH:  BLOCK   100

;I/O BUFFERS

TTYBFI: BLOCK   TTYN*TTYSIZ     ;BUFFERS FOR TTY INPUT
TTYBFO: BLOCK   TTYN*TTYSIZ     ;BUFFERS FOR TTY OUTPUT
MFDBUF: BLOCK   MFDN*DSKSIZ     ;BUFFERS FOR MFD
UFDBUF: BLOCK   UFDN*DSKSIZ     ;BUFFERS FOR UFD
CHKBUF: BLOCK   CHKN*DSKSIZ     ;DATE CHECK FILE BUFFER
FILBUF: BLOCK   FILN*DSKSIZ     ;BUFFERS FOR USER FILE
TAPBUF: BLOCK   TAPN*TAPSIZ
WATBUF: BLOCK   TAPN*WATSIZ+WATSIZ

TECOSTOP: END   START

 x}p<