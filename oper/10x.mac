
;16 FEB 72, 1644:
;PARAMETERS FOR SYSTEM B

DEFINE SYSTXT
<	FOO <BBN-TENEX 1.29, SYSTEM-B>>
SVNM==^D129

NJOBS==^D10		;NUMBER OF JOBS ON SYSTEM
NLINES=^D22		;NUMBER OF TTY LINES INCLUDING CTY AND PTY'S
			;CHANGE INIDVT IN DIRECT.FAI IF NLINES CHANGED
NTTYS==^D17		;NUMBER OF TTY LINES EXCLUDING PTY'S
NTTBF==^D50		;NUMBER OF TTY BUFFERS
TTSIZ==20		;SIZE OF INDIVIDUAL TTY BUFFER (POWER OF 2)
SSPT==2400		;SIZE OF SPT (H'WARE MAX IS 20000)
NDST==^D<47*50>		;47 TRACKS OF 50 PAGES EACH
TMZONE==5	;LOCAL TIME ZONE, NUMBER OF HRS LAGS GMT, SEE DATIME

;IF PI CHANNEL FOR DEVICE IS NOT DEFINED, CODE FOR THAT DEVICE
;IS NOT ASSEMBLED

;MTDCHN==1		;MAG TAPE DATA CHANNEL
;MTACHN==4		;MAG TAPE FLAGS CHANNEL
DTDCHN==2		;DECTAPE DATA
DTACHN==4		;DECTAPE CONTROL
DSKCHN==4		;DISK
;DRMCHN==4		;DRUM
DLSCHN==5		;DLS AND TTY PI CHANNEL
 BBNDLS==1		;FOR BBN-MODIFIED SCANNER
PTRCHN==5		;PAPER TAPE READER
IMPCHN==5		;IMP (NETWORK)
PTPCHN==6		;PAPER TAPE PUNCH
;PLTCHN==6		;PLOTTER
;LPTCHN==6		;LINE PRINTER PI CHANNEL
;DSPCHN==6		; DISPLAY CHANNEL
; DSPBIT==1B<DSPCHN+^D28> ; BIT FOR CONTROLLING PI ON DSP CHN

;STORAGE BOUNDARIES, JUGGLED TO USE SPACE BETWEEN CST0 AND SPT

MAXCOR=1000
SPT=20000		;SPT (FIXED BY PAGER HARDWARE)

DST=5000
RESLOC=DST+NDST		;11704 - 17XXX, RESIDENT STORAGE
SPTH=SPT+SSPT		;22400
CST2=SPTH+SSPT		;25000
CST3=CST2+MAXCOR	;26000
TTBUFS=CST3+MAXCOR	;27000
 TTBUFF==1		;FLAGS TTBUFS AS DEFINED HERE
RESMON=TTBUFS+<NTTBF+1>*TTSIZ ;30460

;MAX END OF SYMBOL TABLE, USED BY POSTLD

MAXSYM==102000

;SWAPPABLE STORAGE AND CODE BOUNDARIES

NRESBG=200000		;BEGINNING OF SWAPPABLE VARIABLE STORAGE
NRPLBG=410000		; " " SWAPPABLE PAGE STORAGE
;SWMP0 IS DEFINED IN FPARAMS - FIRST PAGE OF SWAPPABLE CODE
SWPMPC=261000		;START OF SWAPPABLE CODE IN SWPMON

;PARAMETERS FOR BUG STRING STORAGE

MONBGP==5000	;BUG STRING POINTERS FOR MON
SWPBGP==5200	; " FOR SWPMON
MONBGS==6000	;BUG STRINGS FOR MON
SWPBGS==7000	; " FOR SWPMON


;18 FEB 72, 1116:

;GENERAL PARAMETERS AND MACROS

EOL=37			;END OF LINE CHARACTER

UMODF==10000		;USER MODE FLAG IN PC WORD
UIOF==4000		;USER I/O MODE IN PC WORD
NUPDL==100		;PDL FOR MONITOR CALLS

NFKS==3*NJOBS		;NUMBER OF FORKS
NSAC==16		;HIGHEST AC SAVED BY MENTR
NTERMI==^D36		;NUMBER OF TERMINAL INTERRUPTS
NPILEV==3		;NUMBER OF PSEUDO-INTERRUPT LEVELS
NPIPDL==40		;SIZE OF PSI LOCAL PDL
NTSK==50		;SIZE OF PAGE TRAP PDL
NUFKS==30		;MAX NUMBER FORKS/JOB
NLFKS==20		;NUMBER OF LOCAL FORKS

APRCHN==3		;APR PI CHANNEL
SCDCHN==7		;SCHEDULER PI CHANNEL

;PAGER BITS

READB==1B20		;READ ALLOW
WRITEB==1B21		;WRITE ALLOW
XCTB==1B22		;EXECUTE ALLOW
TRAPUB==1B26		;TRAP TO USER BIT
ACCESB==1B30		;ACCESS ALLOW
COPYB==1B27		;COPY ON WRITE
RWXB==READB+WRITEB+XCTB+ACCESB	;ALL ACCESS
RWX==RWXB-ACCESB

;ENABLE MULTI-LINE LITERALS

	MLON

;FIXED REAL CORE LOCATIONS

CST1=2000		;CST ASSIGNMENTS VALID FOR MAXCOR .LE. 1000
MMAP=3000		;RESIDENT MAP (RES MON, PPR MON, SWP MON)
CST0=4000		;CORE STATUS TABLE, PART 0 (AGE AND PROCESS BITS)

;MONITOR MAP BOUNDARIES

IF2,<IFDEF SCDV1,<INTERN PJMPG,PJMA,PPMPG,PPMA,PSB,JSB
	INTERN FREJPA,FREJP,JFNPC0,RJFN>>

PPRMPG==140		;PER PROCESSOR REGION
PPRMA==<PPRMPG>B26

SWPMPG==200		;SWAPPABLE REGION
SWPMA==<SWPMPG>B26

PJMPG==600		;PER JOB REGION
PJMA==<PJMPG>B26

PPMPG==740		;PER PROCESS REGION
PPMA==<PPMPG>B26

;SWAPPER PAGES RESERVED IN PROCESSOR-PRIVATE AREA

CSWPG==PPRMPG		;SWAPPER TEMP PAGE
CSWPGA=<CSWPG>B26

FITPG==PPRMPG+1		;FORK INIT TEMP PAGE
FITPGA=<FITPG>B26

NRSPG==2		;NUMBER OF PAGES RESERVED AT BOTTOM OF SWP MON

;JOB-COMMON AREA

JSBPG==PJMPG		;JSB IS FIRST PAGE IN JOB-COMMON AREA
JSB=<JSBPG>B26

FREJP==PJMPG+4		;4 PAGES RESERVED FOR JSB EXPANSION
FREJPA=<FREJP>B26

;JFN STORAGE PARAMETERS

JFNPC0=JSB+440			;MUST BE ADJUSTED IF JSB STORAGE GROWS
NJFNW=20			; = 2^SJFN, DEFINED IN FILE.FAI
RJFN=<<FREJPA-JFNPC0+NJFNW-1>/NJFNW>*NJFNW ;ACTUAL SPACE USED BY JFNS

;PROCESS-PRIVATE AREA

PSB=777000		;PSB IS TOP PAGE OF MAP
PSBPG==<PSB>B44

UPTA=PSB-1000		;USER PAGE TABLE
UPTPG==<UPTA>B44

UACPG==PSBPG-2		;VIRTUAL PAGE FOR AC SAVE BLOCKS

DEFINE ASNPPG (P,N)
<P==PPGCT
PPGCT=PPGCT+N
P'A=<P>B26 >

PPGCT=PPMPG		;VARIOUS PROCESS RESERVED PAGES

ASNPPG CXBPG,1		;SWAPPER, MAP TEMP
ASNPPG CPTPG,1		; ..
ASNPPG CPYPG,1		; ..
ASNPPG DDPG1,1		;DDMP
ASNPPG DDPG2,1		; ..
ASNPPG PSIPG,1		;PSI IN PROGRESS STORAGE
ASNPPG FTPG1,1		;FORK
ASNPPG FPBPG,1		;FORK, HOLDS OBJECT PSB

FPG2==DDPG1		;USED BY SSAVE
FPG2A=DDPG1A
FPG3==DDPG2
FPG3A=DDPG2A

ALRMAX==0		;NUMBER OF PAGES RESERVED FOR ALR
ALRVAL==10-<ALRMAX>B40	;3-BIT QUANTITY FOR PAGER ALR

;AC DEFINITIONS

P=17		;UNIVERSAL STACK

OPDEF CALL [PUSHJ P,0]
OPDEF RET [POPJ P,0]
OPDEF XCTUU [XCT 7,0]
OPDEF XCTMU [XCT 1,0]
OPDEF XCTUM [XCT 4,0]

IF2,<IFNDEF MENTR,<EXTERN MENTR,MRETN,MRETNE,UJSYS>>

;LOCAL STORAGE ALLOCATION MACRO

DEFINE LS (T,N)
<	IFB <N>,<ASSIGN T,RESVLC,1>
	IFNB <N>,<ASSIGN T,RESVLC,N>>

;GLOBAL STORAGE

DEFINE GS (T,N)
<	IFB <N>,<ASSIGN T,RESVLC,1>
	IFNB <N>,<ASSIGN T,RESVLC,N>
>

;SWAPPABLE STORAGE

DEFINE NGS (T,N)
<	IFB <N>,<ASSIGN T,NRESLC,1>
	IFNB <N>,<ASSIGN T,NRESLC,N>
>

;SWAPPABLE STORAGE ASSIGNED PAGE-AT-A-TIME

DEFINE NGSP(T,N)
<	IFB <N>,<ASSIGN T,NRPLOC,1000>
	IFNB <N>,<ASSIGN T,NRPLOC,N*1000>
>

;SWAPPABLE, RESIDENT CODE

DEFINE SWAPCD
<	IFG .-200000,<PRINTX BAD USE OF SWAPCD>
	LOC SWPPC>

DEFINE RESCD
<	IFLE .-200000,<PRINTX BAD USE OF RESCD>
	SWPPC=.
	RELOC>

;SWPPC MUST BE DEFINED IN EACH ASSEMBLY

OPDEF PIOFF [CONO PI,1B27]
OPDEF PION [CONO PI,1B28]

DEFINE CHNOFF (CHN)
<	CONO PI,1B26+1B<28+CHN>>

DEFINE CHNON (CHN)
<	CONO PI,1B25+1B<28+CHN>>

DEFINE ISB (CHN)
<	CONO PI,4000+1B<28+CHN>>

DEFINE UNBRK (DEV)
<	EXTERN DEV'CHR
	JRST DEV'CHR>

;INSTRUCTION TRAP ERROR

DEFINE ITERR (ERN)
<IFNB <ERN>,<
	EXTERN ERN
	JRST [	MOVEI 1,ERN
		JRST ITRAP1]
>
IFB <ERN>,<
	JRST ITRAP
>>
DEFINE RETERR (ERN)
<IFNB <ERN>,<
	EXTERN ERN
	JRST [	MOVEI 1,ERN
		JRST MRETNE]
>
IFB <ERN>,<
	JRST MRETN
>>

;MACROS FOR DEFINING BUGHLT AND BUGCHK STRINGS

;THIS IS THE MACRO THAT APPEARS IN THE CODE.  ITS FIRST ARG IS
;CHK OR HLT, AND CAUSES ASSEMBLY OF JSR BUGCHK OR JSR BUGHLT
;RESPECTIVELY.  ITS SECOND ARGUMENT IS A STRING DEFINING THE
;PROBLEM REPRESENTED BY THE CHECK.

DEFINE BUG (TYP,STR,%TAG,%NAM)
<%TAG:	JSR BUG'TYP
   DEFINE %NAM
<	XWD %TAG,[ASCIZ /STR/]
	IF2, <PURGE %TAG> >
	BUGREM <%NAM>
>

;THIS IS A SET OF REMOTE MACROS

DEFINE BUGREM (..XXX)
<	BUGRM2 <..XXX>,
>

DEFINE BUGRM2 (..NEW,..OLD)
<	DEFINE BUGREM (..XXX)
	<	BUGRM2 <..XXX>,<..OLD
		..NEW
>>>

;THIS APPEARS ONCE IN EACH ASSEMBLY AT THE END

DEFINE BGHERE (PC1,PC2)
<	LIT			;ALL REGULAR LITERALS IN ASSEMBLY
	LOC PC1			;ADDRESS OF TAGS AND POINTERS
	DEFINE BUGRM2 (..NEW,..OLD)
	<..OLD>
	BUGREM ()		;PUTS DOWN ALL POINTERS
	LOC PC2			;ADDRESS OF STRINGS
	LIT			;ALL BUG STRINGS FOR THIS ASSBY
	IFL PC2+1000-.,<PRINTX BUGSTRINGS OVERFLOW ONE PAGE>
>

;SCHEDULING CONTROL MACROS

IF2,<IFNDEF ISKED,<EXTERN ISKED,NSKED,RSKED>>

DEFINE NOSWAP
<	AOS NSWAP>

DEFINE OKSWAP
<	SOSG NSWAP
	AOS ISKED>

DEFINE RESKED
<	AOS ISKED
	ISB SCDCHN>

DEFINE NOSKED
<	AOS NSKED>

DEFINE OKSKED
<	SOSG NSKED
	XCT RSKED>

;NOSKED AND OKSKED FOR CODE POSSIBLY BEING RUN UNDER SCHEDULER

DEFINE NOSKD1
<	SKIPN INSKED
	AOS NSKED>

DEFINE OKSKD1
<	SKIPN INSKED
	SOSLE NSKED
	CAIA
	XCT RSKED>

IF2,<IFNDEF BUGHLT,<EXTERN BUGHLT,BUGCHK>>

DEFINE SETACB (A)
<	DPB A,[POINT 5,PGR71,22]
	CONO PGR,10>

;PSI CONTROL

DEFINE NOINT
<	AOS INTDF>

DEFINE OKINT
<	XCT INTDFF>

DEFINE TSTINT
<	SKIPE PSIBW>

;TS BLOCK ASSIGNMENTS

DEFINE TS (T,N)
<	IF2,<
	IFNDEF SCDV1,<EXTERN T>
	IFDEF SCDV1,<
	IFB <N>,<ASSIGN T,TSBLOC,1>
	IFNB <N>,<ASSIGN T,TSBLOC,N>
>>>

UACB=PSB+420		;ADDRESS OF FIRST BLOCK FOR AC STORAGE
EUACB==PSB+560		;END OF AC BLOCKS IN PSB

ACBAS=PSB+570		;LOCATION OF AC'S FOR FORCED USER REFS
TRAPS0=PSB+571		;PAGER TRAP STATUS WORD
TRAPWD=PSB+572		;PAGER TRAP WRITE DATA
TRAPPC=PSB+573		;PAGER TRAP PC
TRAPAP=PSB+574		;PAGER TRAP AC-P
TRAPSW=PSB+575		;TRAP OLD STATUS WORD
UTRSW=PSB+576		;SAVED TRAPSW FOR USER
UTRWD=PSB+577		;SAVED TRAPWD FOR USER

TS JOBNO,1		;JOB NUMBER TO WHICH THIS FORK BELONGS
TS JOBBIT,1		;SCHEDULER CONTROL BITS
TS JOBCK0,1		;VARIABLES FOR SCHEDULER TIME QUARANTEE
TS JOBCK1,1		; ..

TS FKTAB,NLFKS/2	;LOCAL FORK HANDLE TO JOB HANDLE TABLE

TS FORKN,1		;JOB FORK NUMBER OF TOP FORK,,THIS FORK
TS FKRT,1		;FORK RUN TIME
TS ENTVEC,1		;ENTRY VECTOR POINTER
TS PATADR,1		;10/50 COMPATABILITY ENTRY VECTOR
TS PATU40,1		;WHERE TO STORE C(40), SETUP AS UMOVEM 1,XX
TS PATUPC,1		;WHERE TO STORE PC, SETUP AS UMOVEM 1,YY

TS MPP,1		;MONITOR SAVED STACK POINTER AT LAST MENTR
TS UPP,1		;MON ROUTINES STACK POINTER
TS SLOWF,1		;SLOW MON ROUTINE FLAG
TS XMENTR,1		;MENTR-MRETN TEMP
TS XMENT1,1		;MENTR TEMP
TS INTDF,1		;DEFER INTERRUPTS IF .GE. 0
TS INTDFF,1		;SOS INTDF  OR JSYS PSISV1
TS MJRSTF,1		;JRSTF @FPC  OR  JRST PSISV0
TS ACBAS1,1		;ACBAS FOR FIRST MON CALL

TS TW1,1		;MON ROUTINE TEMPS
TS TW2,1
TS ITFPC,1		;FPC AT LAST ITRAP (FOR MON DEBUGGING)

TS PAC,20		;PROCESS AC'S
TS PPC,1		;PROCESS PC
TS PSB40,1		;PROCESS LOCATION 40

TS ENSKR,1		;SCHEDULER TEMP (RETURN)
TS SKDPC,1		;SCHEDULER TEMP (RETURN)
TS NSKED,1		;NO-SCHEDULE WORD
TS RSKED,1		;NO-SCHEDULE TRAP
TS NSWAP,1		;NO-SWAP FLAG

TS TRAPSK,NTSK		;STACK USED DURING PAGER TRAPS
TS PGTIM,1		;TIME SINCE LAST PAGE FAULT
TS TRAPC,1		;PAGER TRAP RECURSION COUNT
TS UTRPCT,1		;COUNT OF PAGER TRAPS FOR THIS PROCESS
TS USWPCT,1		;COUNT OF SWPINW CALLS FOR THIS PROCESS
TS PTTIM,1		;TIME SPENT IN PAGER TRAPS

TS MONBK,1		;INTERRUPT TO MONITOR IF NON-0
TS PIPC,1		;SAVED PC DURING INITIAL PI SERVICE
TS PIMSK,1		;PSI REQUEST WORD BEING PASSED TO PSI SERVICE
TS PIPDB,NPIPDL		;PSI ROUTINES STACK
TS PIAC,17		;SAVED USER AC'S DURING BREAK START
TS PIAC17,1		;SAVED USER AC17 .. ..

TS PSICHA,NTERMI/6	;CHANNEL ASSIGNED TO TERM CODE
TS PSIBW,1		;BREAK WAITING WORD
TS FORCTC,1		;CHANNEL WHICH CAUSED FORCED FORK TERMINATION
TS PSICHM,1		;CHANNEL ENABLED WORD
TS SUPCHN,1		;CHANNELS RESERVED BY SUPERIOR
TS PSIBIP,1		;BREAK IN PROGRESS WORD (LEVELS)
TS PSIPT,1		;PSI STORAGE LIST POINTER
TS PIOLDS,1		;FKSTAT PRIOR TO PSI IF WAS WAITING
TS LEVCHN,1		;LEVEL TABLE,,CHANNEL TABLE  ADDRESSES
TS PSISYS,1		;NON-0 IF PSI SYSTEM OFF
TS MONCHN,1		;CHANNELS RESERVED BY MONITOR
TS MONINT,1		;FOR DDT BREAKPOINTS
TS OVFLG,1		;NON-0 => INITIATE INTERRUPTS ON MONITOR OV'S

TS UPDL,NUPDL		;PDL FOR MONITOR CALLS

TS FPC,1		;MENTR-MRETN JSYS PC

;JOB STORAGE BLOCK ASSIGNMENTS

DEFINE JS (T,N)
<	IF2,<
	IFNDEF SCDV1,<EXTERN T>
	IFDEF SCDV1,<
	IFB <N>,<ASSIGN T,JSBLOC,1>
	IFNB <N>,<ASSIGN T,JSBLOC,N>
>>>

JS JOBMAP,PPMPG-PJMPG	;OBJECT MAP FOR JOB-COMMON AREA

JS SYSFK,NUFKS		;JOB FORK INDEX TO SYSTEM FORK INDEX
JS FKPTRS,NUFKS		;FORK POINTERS (STRUCTURE)
JS FKPSIE,NUFKS		;TERM INTERRUPT ENABLED WORD
JS FREJFK,1		;FREE JOB FORK SLOT LIST

JS CTRLTT,1		;LINE NUMBER OF CONTROLLING TTY
JS TTSPSI,1		;CODE ENABLED ANYWHERE IN THIS JOB
JS TTJTIW,1		;TERMINAL INTERRUPT ENABLE MASK
JS JOBPMF,1		;JFN OF PRIV MEM FILE
JS CONSTO,1		;CONSOLE TIME ON
JS ACCTPT,1		;ACCOUNT NUMBER+5B2 OR ACCOUNT STRING PTR
JS LOGBUF,5		;LOGIN-OUT EFACT DATA, MUST PRECEDE ACCTSR
JS ACCTSR,11		;ACCOUNT STRING

;JSYS DISPATCH TABLE, INITIALIZED TO ALL ILLEGAL

IFDEF LDINIT,<
	EXTERN ITRAP
JSYSLC==0
>
;JSYS DEFINITIONS

DEFINE JD (N,A)
<	OPDEF N [JSYS A]
IFDEF LDINIT,<
	LOC 1000+JSYSLC
	IFL A-JSYSLC,<PRINTX JSYS'S MUST BE DEFINED IN ORDER>
	REPEAT A-JSYSLC,<XWD FPC,UJSYS>
	EXTERN .'N
	XWD FPC,.'N
JSYSLC==.-1000
	RELOC
>>

JD LOGIN,1
JD CRJOB,2
JD LGOUT,3
JD CACCT,4
JD EFACT,5
JD SMON,6
JD TMON,7
JD GETAB,10
JD ERSTR,11
JD GETER,12
JD GJINF,13
JD TIME,14
JD RUNTM,15
JD SYSGT,16
JD GNJFN,17
JD GTJFN,20
JD OPENF,21
JD CLOSF,22
JD RLJFN,23
JD GTSTS,24
JD STSTS,25
JD DELF,26
JD SFPTR,27
JD JFNS,30
JD FFFFP,31
JD RDDIR,32
REPEAT 0,<JD CPRTF,33>
JD CLZFF,34
JD RNAMF,35
JD SIZEF,36
JD GACTF,37

JD STDIR,40
JD DIRST,41
JD BKJFN,42
JD RFPTR,43
JD CNDIR,44
JD RFBSZ,45
JD SFBSZ,46
JD SWJFN,47
JD BIN,50
JD BOUT,51
JD SIN,52
JD SOUT,53
JD RIN,54
JD ROUT,55
JD PMAP,56
JD RPACS,57
JD SPACS,60
JD RMAP,61
JD SACTF,62
JD GTFDB,63
JD CHFDB,64
JD DUMPI,65
JD DUMPO,66
JD DELDF,67
JD ASND,70
JD RELD,71
JD CSYNO,72
JD PBIN,73
JD PBOUT,74
JD PSIN,75
JD PSOUT,76
JD MTOPR,77

JD CFIBF,100
JD CFOBF,101
JD SIBE,102
JD SOBE,103
JD DOBE,104
JD GTABS,105
JD STABS,106
JD RFMOD,107
JD SFMOD,110
JD RFPOS,111
JD RFCOC,112
JD SFCOC,113
JD STI,114
JD DTACH,115
JD ATACH,116
JD DVCHR,117
JD STDEV,120
JD DEVST,121
JD MOUNT,122
JD DSMNT,123
JD INIDR,124
JD SIR,125
JD EIR,126
JD SKPIR,127
JD DIR,130
JD AIC,131
JD IIC,132
JD DIC,133
JD RCM,134
JD RWM,135
JD DEBRK,136
JD ATI,137
JD DTI,140
JD CIS,141
JD SIRCM,142
JD RIRCM,143
JD RIR,144
JD GDSTS,145
JD SDSTS,146
JD RESET,147

JD RPCAP,150
JD EPCAP,151
JD CFORK,152
JD KFORK,153
JD FFORK,154
JD RFORK,155
JD RFSTS,156
JD SFORK,157
JD SFACS,160
JD RFACS,161
JD HFORK,162
JD WFORK,163
REPEAT 0,<JD GFRKH,164
JD RFRKH,165
JD GFRKS,166>
JD DISMS,167
JD HALTF,170
JD GTRPW,171
JD GTRPI,172
JD RTIW,173
JD STIW,174
JD SOBF,175
REPEAT 0,<JD RWSET,176>
JD GETNM,177

JD GET,200
JD SFRKV,201
JD SAVE,202
JD SSAVE,203
JD SEVEC,204
JD GEVEC,205
JD GPJFN,206
JD SPJFN,207
JD SETNM,210
JD FFUFP,211
JD DIBE,212
JD FDFRE,213
JD GDSKC,214
JD LITES,215
JD TLINK,216
JD STPAR,217

JD ODTIM,220
JD IDTIM,221
JD ODCNV,222
JD IDCNV,223
JD NOUT,224
JD NIN,225
JD STAD,226
JD GTAD,227
JD ODTNC,230
JD IDTNC,231
JD FLIN,232
JD FLOUT,233
JD DFIN,234
JD DFOUT,235

JD CRDIR,240
JD GTDIR,241
JD DSKOP,242
JD SPRIW,243
JD DSKAS,244
JD SJPRI,245

IFDEF DSPCHN,<
JD ASNDP,260		; E&S JSYS'S
JD RELDP,261
JD ASNDC,262
JD RELDC,263
JD STRDP,264
JD STPDP,265
JD STSDP,266
JD RDSDP,267
JD WATDP,270
>

IFDEF IMPCHN,<
JD ATPTY,274
JD CVSKT,275
JD CVHST,276
JD FLHST,277
>

JD GCVEC,300
JD SCVEC,301
JD STTYP,302
JD GTTYP,303

;TEMPORARY DEF'S
JD MRPAC,772
JD TTMSG,775
JD EXEC,777


;18 FEB 72, 1202:

;TENEX PAGE MANAGEMENT MODULE - D. MURPHY

	INTERN ASOFN,RELOFN,SETMPG,READB,MRPACS,MSPACS,MRMAP,NOFN
	INTERN MLKPG,MULKPG,FPTA,MRPT,SETPT,DISKP,DRUMP,RWX,SWPCOR
	INTERN DDMP,DELOFN,MONCOR,COPYB,SPT,SPTH,CORWB,SPC1,SWPZPG
	INTERN MULKCR,MULKMP,CST0,CST1,CST2,CST3
	INTERN .MRPAC
	INTERN SWPINT
	INTERN SWPDON

	EXTERN GDSTX,DRMASN,DSKASN,DASDRM,DEDSK,DRMFRE
	EXTERN SWPERR,JFNOFN,OFNJFN,JFNDCR,OPNX16,OPNX9,OPNX10
	EXTERN CVDSK,UDSKIO
	EXTERN DRMIO,DSKIO,DWRBIT

;PARAMETERS

DISKP:	1		;DISK ON SYSTEM
DRUMP:	IFDEF DRMCHN,<1>	;1 = DRUM AVAIL,
	IFNDEF DRMCHN,<0>	;0 = USE DISK, -1 = USE NOTHING
NOFN==400		;NUMBER OF OFN SLOTS
SPTM==17777		;MASK FOR SPT INDICES
THAWB==1B20		;THAW BIT
FILWB==1B19		;FILE WRITE BIT
SPTLKB==1B22		;LH OF SPTH(OFN), XB IN USE BY DDMP
NEWFB==1B33		;NEW FILE (OR FILE PAGE) BIT
DRPERM==1B23		;PERMANENT ON DRUM PAGE
BWRBIT==1B31		;WRITTEN (CHANGED) FROM HOME COPY
CORWB==1B27		;CHANGED IN CORE, SET BY PAGER
PLKV==1B27		;FOR LOCK VALUE IN CST1
BP1==^D10		;BIT POSITION OF PROCESS 0 IN CST0
DSKSWB==1B20		;SWAP TO DISK REQUESTED

;BITS IN MAP WORD

SHRBIT==1B19		;SHARE POINTER
INDBIT==1B18		;INDIRECT POINTER

PGR==24
PGR71=71		;PAGER RELOAD REG (PT.PSB)
PGR72=72		;PAGER RELOAD REG (AGE.PROCESS BIT)

DEFINE MONCLR
<	CONO PGR,1>

LS SPTC,1		;COUNT OF SPT (EXCLUDING OFN) ENTRIES IN SPT
LS NOF,1		;COUNT OF ENTRIES IN OFN PART OF SPT
LS FRESPT,1		;FREE SPT LIST
LS MAXSPL,1		;MAX NUMBER OF PROBES TO SPTH
LS MMSPTN,1		;OFN OF MONITOR MAP
GS LOKPGS,1		;COUNT OF LOCKED PAGES, VIA MLKPG
GS LOKSUM,1		;NET NUMBER OF LOCKS, MLKPG-MULKPG
GS MAXLOK,1		;MAX NUMBER OF PAGES TO BE LOCKED
GS NXTDMP,1		;FLAG TO CAUSE DDMP ACTION
GS DDTIME,1		;TIME NEXT DDMP DUE
LS IOIP,1		;SWAP WRITES IN PROGRESS
GS DRMIN0,1		;MIN DRUM SPACE

SPC0:	EXP <SSPT-NOFN>*5/6
SPC1:	EXP SSPT-NOFN-40

;INITIALIZATION, SPT, CST, ETC.

PGRINI:	SETZM SPTC
	SETZM NOF
	SETZM MAXSPL
	MOVEI 1,SPT+NOFN
	MOVEI 2,SSPT-NOFN
	CALL ILIST		;MAKE LIST OF FREE SPT ENTRIES
	MOVEM 1,FRESPT
	SETZM SPTH
	MOVE 1,[XWD SPTH,SPTH+1]
	BLT 1,SPTH+NOFN-1	;ZERO OUT SPTH
	CALL ASSPT		;ASSIGN SPT SLOT FOR MMAP
	MOVE 2,[XWD 1B31,MMAP/1000]
	MOVEM 2,SPT(1)
	MOVEM 1,MMSPTN
	MOVSI 2,0(1)
	SETZ 1,			;START WITH CORE PAGE 0
	MOVSI 3,400000
	MOVSI 4,RWXB
PGRI1:	MOVEM 1,MMAP(2)		;MAKE MAPPED MON EQUIVALENT TO UNMAPPED
	HLLM 4,MMAP(2)		;PRIVATE POINTER, ALL ACCESS
	MOVEM 3,CST0(1)		;LEGAL AGE WORD
	MOVEM 1,CST1(1)		;BACKUP ADDRESS IS SELF
	MOVEM 2,CST2(1)		;OFN.PN
	ADDI 1,1
	CAMGE 1,SWPCOR		;FILL TO END OF RES MON
	AOJA 2,PGRI1
	MOVSI 4,WRITEB
	ANDCAM 4,MMAP+1		;PROTECT JSYS TABLE
	MOVEI 3,P2+777
	LSH 3,-^D9		;FIRST PAGE OF RES MON
PGRI5:	CAIGE 3,100		;DON'T PROTECT PAGES ALWAYS MAPPED
	ANDCAM 4,MMAP(3)	;WRITE PROTECT RES MON
	ADDI 3,2
	CAMGE 3,MONCOR		;MON WILL BE WRITE PROTECTED IF
	SOJA 3,PGRI5		;MAPRESMON FLOP MANUALLY TURNED ON

	ADDI 2,MMAP+2
	HRLI 2,-1(2)
	SETZM -1(2)
	BLT 2,MMAP+PJMPG-1	;ZERO REMAINDER OF MON MAP
	SETZM TOTRC
	SETZM NRPLQ
	CONO APR,1B23		;MAKE SURE NXM OFF
	MOVE 1,SWPCOR
	MOVE 2,[XWD RPLQ,RPLQ]
	MOVEM 2,RPLQ		;REPLACEMENT QUEUE EMPTY
PGRI2:	SETZM CST1(1)		;CLEAR CST ENTRIES
	SETZM CST2(1)
	SETZM CST3(1)
	MOVEI 2,0(1)		;CHECK FOR MEMORY EXISTANT
	LSH 2,^D9
	MOVE 0(2)		;MAY GET NXM
	CONSZ APR,1B23		;NXM?
	JRST PGRI3		;YES
	SETZM CST0(1)		;NO, PAGE EXISTS
	JSP 4,ONRQ		;PUT PAGE ON REPLACABLE QUEUE
	PIOFF
	AOS TOTRC		;COUNT PAGES OF CORE FOUND
PGRI4:	CAIGE 1,MAXCOR-1		;CHECK 256K
	AOJA 1,PGRI2
	MOVE 1,TOTRC
	SUBI 1,3
	MOVEM 1,MAXNR		;MAX VALUE OF SUMNR
	SUBI 1,6
	MOVEM 1,NPMAX
	ASH 1,-1
	MOVEM 1,TOTRC2
	ASH 1,-1		;1/4 REAL CORE
	CAIGE 1,10		;OR 10, WHICHEVER IS LARGER
	MOVEI 1,10
	MOVEM 1,MAXLOK		;IS MAX NUMBER PAGES TO LOCK
	MOVE 1,NPMAX
	SUBI 1,40		;LOWER MAX FOR FORK WILL BE NPMAX-40
	CAIL 1,40		;UNLESS THATS LESS THAN 40, IN WHICH
	 1,TOTRC2		;CASE IT WILL BE NPMAX/2
	MOVEI 1,10
	MOVEM 1,NRPMIN		;MAINTAIN NRPLQ AT THIS LEVEL
	MOVE 1,TOTRC
	LSH 1,-3
	CAIL 1,NBP
	MOVEI 1,NBP-1
	MOVEM 1,MAXBP
	MOVEI 1,NDST		;NUMBER OF PAGES ON DRUM
	IDIVI 1,10
	MOVEM 1,DRMIN0		;TAKE SPECIAL ACTION IF DRUM .GE. 7/8
	SETZM PGR71
	MOVSI 1,400000
	MOVEM 1,PGR72
PGRRST:	CONO PGR,6
	CONO PGR,0		;TURN ON PAGER
	DATAO APR,[XWD 776776,0]	;RELOC AND PROTECT STILL WORKS
	RET

PGRI3:	CONO APR,1B23		;TURN OFF NXM FLAG
	MOVSI 2,010000
	MOVEM 2,CST0(1)
	JRST PGRI4

;BOUNDARIES SET BY POSTLD

MONCOR:	0			;NUMBER PAGES OF RES MON
SWPCOR:	0			;FIRST PAGE OF REAL CORE FOR SWAPPING

;RESTART SWAPPER - REINITIATE IO OPERATIONS IN PROGRESS AT TIME OF CRASH

SWPRST:	SETZM IOIP
	MOVE 6,SWPCOR		;SCAN CST AND CHECK STATE OF PAGES
SWPRS1:	LDB 1,[POINT 6,CST0(6),5] ;GET STATE CODE
	CAIN 1,06		;READ IN PROGRESS?
	JRST SWPRSR		;YES, GO RESTART IT
	CAIN 1,04		;WRITE?
	JRST SWPRSW		;YES
SWPRS2:	CAIGE 6,MAXCOR-1	;LOOKED AT ALL PAGES?
	AOJA 6,SWPRS1		;NO
	RET

SWPRSW:	MOVSI 1,DWRBIT		;WRITE OPERATION
	AOSA IOIP		;COUNT WRITES IN PROGRESS
SWPRSR:	SETZ 1,			;READ OPERATION
	HRRI 1,0(6)
	MOVE 2,CST1(6)		;BACKUP ADDRESS
	TLNE 2,10		;DISK?
	JRST SWPRS3		;YES
	TLNN 2,16		;DRUM?
	BUG(HLT,<ILLEGAL ADDRESS IN CST1 ENTRY, CAN'T RESTART>)
	CALL DRMIO
	JRST SWPRS2

SWPRS3:	CALL DSKIO
	JRST SWPRS2

;PERIODIC ROUTINE TO TRICKLE PAGES TO DISK

DDMP:	MOVE 1,TODCLK
	CAMGE 1,DDTIME		;TIME YET?
	RET			;NO
	SKIPE DISKP		;DISK ON SYSTEM, AND
	SKIPE NXTDMP		;DUMP REQUESTED?
	RET			;NO
	ADDI 1,^D30000		;NEXT ONE DUE IN 30 SEC.
	MOVEM 1,DDTIME
	SETZ 0,			;CLEAR FLAGS
	MOVE 1,DRMFRE
	CAMGE 1,DRMIN0		;ENOUGH DRUM SPACE?
	TLO 1,(1B0)		;NO, TAKE SPECIAL ACTION
	AOS NXTDMP		;TO DETECT REQUESTS DURING ROUTINE
	MOVE 11,FORKX		;CONSTRUCT HANDLE FOR DDPG2
	HRLZ 11,FKPGS(11)
	HRRI 11,DDPG2		;WILL BE USED LATER
	MOVSI 10,-NOFN		;PREPARE TO SCAN ALL OFN'S
	AOBJN 10,.+1		;0 NOT USED
DDMP9:	NOSKED
	MOVE 1,SPTH(10)		;GET HASH WORD FOR THIS OFN
	JUMPLE 1,DDMP1S		;NOT IN USE
	MOVE 1,SPT(10)		;IN USE, GET CURRENT ADR
	TLNE 1,10		;XB ON DISK?
	JRST DDMP1E		;FORGET IT
	MOVSI 2,SPTLKB
	IORM 2,SPTH(10)		;LOCK OFN AGAINST RELEASE
	MOVEI 1,0(10)		;MAP THE XB
	MOVE 2,[XWD RWX,DDPG1A]
	CALL SETMPG
	SETZ 6,
	CALL DDMPXA		;GET XB DISK ADDRESS
	PUSH P,6		;SAVE WRITE FLAG FOR XB
	CAIGE 7,DST+NDST	;IN DST?
	CAIGE 7,DST
	JRST .+3		;NO
	MOVSI 3,BWRBIT		;YES, CLEAR BACKUP WRITE BIT
	ANDCAM 3,0(7)
	OKSKED
	MOVE 2,[XWD DDPG2A,DDPG2A+1]
	SETZM DDPG2A		;ZERO A PAGE TO GET THE BACKUP XB
	BLT 2,DDPG2A+777
	MOVSI 7,-1000		;SCAN ALL WORDS OF XB
DDMP8:	MOVE 1,DDPG1A(7)	;WORD FROM XB
	JUMPE 1,DDMP61		;QUICK CHECK FOR NULL
	NOSKED
DDMP81:	MOVE 1,DDPG1A(7)	;WORD FROM XB
	JUMPE 1,DDMP6		;NOT IN USE
	TLNN 1,SHRBIT		;SHARE POINTER?
	JRST DDMP4		;NO, PRIVATE
	LSH 1,-^D9		;GET SPT NUMBER
	ANDI 1,SPTM
	MOVE 1,SPT(1)
	TLZ 1,-1B31		;FLUSH SHARE COUNT
	TLNN 1,16		;CHECK FOR UNASSIGNED
	TLNN 1,1
	JRST DDMP4
	JRST DDBAD

DDMP6:	OKSKED
	JRST DDMP61

DDMP1E:	TLNE 1,-1B31		;SHARE COUNT 0?
	JRST DDMP1S		;NO
	SETOM SPTH(10)		;YES, RELEASE OFN
	SOS NOF
DDMP1S:	OKSKED
	JRST DDMP1

DDMPXA:	MOVE 1,SPT(10)		;SET ABOUT FINDING DISK ADDRESS
	TLNE 1,17
	JRST DDMPX1		;IN DST
	MOVE 7,CST2(1)
	CAIE 7,0(10)		;ALL CONSISTENT?
	JRST DDBAD1		;NO
	MOVE 7,CST0(1)		;GET CORE WRITE BIT
	TLNE 7,CORWB		;WRITTEN IN CORE?
	SETO 6,			;YES
	MOVEI 7,CST1(1)		;IF IN CST, REMEMBER WHERE
DDMPX2:	MOVE 1,0(7)
	TLNE 1,10		;DISK?
	RET			;YES, DONE
DDMPX1:	MOVE 2,1
	CALL GDSTX
	MOVE 7,DST(2)		;GET DRUM WRITE BIT
	TLNE 7,BWRBIT		;WRITTEN ON DRUM?
	SETO 6,			;YES
	MOVEI 7,DST(2)		;REMEMBER WHERE DISK ADDRESS IS
	JRST DDMPX2

DDMP4:	TLNE 1,617700		;ANY STRANGE BITS?
	JRST DDBAD		;YES, SKIP IT
	TLNN 1,10		;PAGE NOW ON DISK?
	JRST DDMP5		;NO
	JRST DDMP3A		;YES, ALL SET

DDMP3:	TLNE 1,NEWFB		;NEW ADDRESS?
	MOVES DDPG1A(7)		;YES, CAUSE XB TO BE WRITTEN AGAIN
DDMP3A:	OKSKED
	TLNN 1,10		;JUST MAKE SURE WE HAVE DISK ADR
	JRST DDBAD
	MOVEM 1,DDPG2A(7)	;STORE DISK ADDRESS IS XB COPY
	LDB 1,[POINT 12,DDPG1A(7),13]	;GET ACCESS BITS FROM ORIG PTR
	DPB 1,[POINT 14,DDPG2A(7),13]	;STORE THEM IN XB COPY
DDMP61:	AOBJN 7,DDMP8		;SCAN OVER WORDS IN XB
DDMPXB:	NOSKED
	POP P,1			;GET XB WRITE FLAG
	JUMPE 1,DDMPX3		;DON'T WRITE XB IF NOT CHANGED
	MOVE 1,11		;GET ID OF COPY PAGE
	CALL MLKPG		;LOCK THE PAGE
	PUSH P,1		;SAVE CORE PAGE NUMBER
	CALL DDMPXA		;GET XB DISK ADDRESS
	MOVE 2,[1B14+1000]	;DISK IO CONTROL WORD, WRITE+1000 WORDS
	TLNN 1,NEWFB		;NEW FILE BIT?
	TLO 2,(1B15)		;NO, DO COMPARE CLASS
	TLZE 1,NEWFB		;CLEAR NEW FILE BIT
	MOVEM 1,0(7)
	OKSKED
	PUSH P,2
	CALL CVDSK		;CONVERT TO HARDWARE FORMAT
	POP P,2
	LDB 3,[POINT 9,SPTH(10),13]	;GET CLASS
	DPB 3,[POINT 9,2,24]	;IN CONTROL WORD
	POP P,3			;CORE PAGE NUMBER
	LSH 3,^D9
	CALL UDSKIO		;OPERATE DISK
	AOS DSKWR		;COUNT OPERATIONS
	MOVE 6,1		;SAVE ERROR BITS
	MOVE 1,11
	CALL MULKPG		;UNLOCK PAGE
	JUMPN 6,.+1		;NON-ZERO MEANS ERRORS
	NOSKED
DDMPX3:	MOVE 1,DDPG1A		;MAKE SURE XB IN CORE BEFORE UNMAPPING
	SETZ 1,
	MOVEI 2,DDPG1A
	CALL SETMPG		;UNMAP XB
	MOVSI 2,SPTLKB
	ANDCAM 2,SPTH(10)	;UNLOCK OFN
	OKSKED
DDMP1:	AOBJN 10,DDMP9		;COUNT OFN'S
	MOVNS NXTDMP		;RESET IF NO INTERVENING REQUESTS
	MOVSI 1,1
	ADDM 1,CGFLG		;INSIST ON GC
	RET

DDMP5:	TLNN 1,17		;IN CORE?
	JRST DDMP52		;YES
	MOVE 2,1		;ON DRUM, GET DST WORD
	CALL GDSTX
	MOVE 1,DST(2)
	TLNN 1,BWRBIT		;CHANGED FROM BACKUP?
	JUMPGE 0,DDMP3		;NO, IGNORE IF NOT LOW ON DRUM SPACE
	MOVE 1,DDPG1A(7)	;GET PAGE SWAPPED IN
	TLNE 1,SHRBIT
	JRST DDMP51		;SHARE POINTER, GET SPTN
	MOVSI 1,0(10)		;CONSTRUCT OFN.PN
	HRRI 1,0(7)
DDMP53:	PUSH P,7
	CALL SWPINW		;SWAP IN PAGE AND WAIT
	POP P,7
	JRST DDMP81		;NOW PAGE IS IN CORE

DDMP51:	LSH 1,-^D9		;GET SPTN
	ANDI 1,SPTM
	JRST DDMP53

DDMP52:	TRNE 1,-MAXCOR		;LIKELY PAGE?
	JRST DDBAD		;NO
	MOVSI 6,400000		;FLAG TO NOTE IF WRITING NEEDED
	AND 6,0			;INIT TO DRUM SPACE FLAG
	MOVE 2,CST0(1)
	TLNE 2,CORWB		;PAGE WRITTEN WHILE IN CORE?
	SETO 6,			;YES
	MOVE 2,CST1(1)		;GET BACKUP ADR
	TLNE 2,10		;DISK?
	JRST DDMP54		;YES
	CALL GDSTX
	MOVE 2,DST(2)		;GET NEXT BACKUP ADR
	TLNE 2,BWRBIT		;CHANGED ON DRUM?
	SETO 6,			;YES
DDMP54:	JUMPE 6,DDMP55		;DISK ADR NOW IN 2, WRITING NEEDED?
	PUSH P,7
	MOVE 3,CST0(1)
	TLNN 3,700000		;IF AGE OK, LEAVE IT ALONE
	CALL AGESET		;YES
	POP P,7
	MOVSI 3,DSKSWB
	IORB 3,CST3(1)		;REQUEST DISK SWAP AT NEXT SWAP TIME
	HLRZ 3,3		;GET PROCESS ASSMT
	ANDI 3,7777
	CAME 3,FORKX		;ASSIGNED HERE?
	JRST DDMP55		;NO
	MOVSI 6,7777
	IORM 6,CST3(1)		;DEASSIGN
	SOS FKWSP(3)
	AOS CGFLG		;NOTE GARBAGE
DDMP55:	MOVE 1,2
	JRST DDMP3

;LOSSAGE PRINTOUT

DDBAD1:	POP P,1
DDBAD:	POP P,1			;FLUSH JUNK
	SETZM NSKED
	HRROI 1,[ASCIZ /
*****BAD INDEX BLOCK, OFN /]
	PSOUT
	MOVEI 1,101
	MOVEI 2,0(10)
	MOVEI 3,^D8
	NOUT
	JFCL
	MOVEI 1,EOL
	PBOUT
	JRST DDMP1

;ASSIGN OFN
; AC1/ 14-35 INDEX BLOCK FILE ADDRESS (DISK, DRUM OR CORE)
;       5-13 CLASS FIELD (IF DISK)
;          1 WRITE BIT
;          2 THAWED BIT
;	   3 NEW FILE BIT
;RETURN SKIP WITH OFN IN AC1 IF PROPER OPENING
;RETURN NO-SKIP IF ILLEGAL SHARED OPENING (ILLEGAL CONFIGURATION
;      OF THAWED AND WRITE BITS)

ASOFN:	TLNN 1,10		;DISK?
	JRST [	SKIPE DISKP	;NO, DISK ON SYSTEM?
		RET		;YES, MUST BE DISK ADDRESS
		JRST .+1]	;NO, ACCEPT OTHER ADDRESSES
	NOSKED
	PUSH P,1
	TLZ 1,-1B31		;FLUSH CLASS AND BITS
	MOVE 6,1
	MOVE 4,MAXSPL		;MAX NUMBER OF PROBES INTO SPTH
	SETO 5,
	SETZ 1,			;START SEARCH WITH 0

ASOF1:	ADDI 1,1		;LOOK LINEARLY
	MOVEI 3,0(1)

REPEAT 0,<			;THIS IS HASH LOOKUP NOT CURRENTLY USED
	IMUL 1,[5654123]	;HASH INDEX BLOCK ADDRESS
	HLRZS 3,1		;USE LEFT HALF
	ANDI 3,NOFN-1		;MAX NUMBER OPEN FILES
	JUMPE 3,ASOF1		;DON'T USE SLOT 0
>
	MOVE 2,SPTH(3)		;GET ENTRY
	JUMPLE 2,ASOF2		;0 IS FREE, -1 IS DELETED
	TLZ 2,-1B31		;FLUSH BITS
	CAMN 2,6		;COMPARE ADDRESSES
	JRST ASOF3		;FOUND
ASOF7:	SOJG 4,ASOF1		;COUNT TRYS AND PROBE AGAIN
	JUMPGE 5,ASOF6		;NOT FOUND. DELETED ENTRY ENCOUNTERED?
	AOS MAXSPL		;NO, INCREASE MAX LOOK COUNT
	JRST ASOF1		;KEEP LOOKING FOR USABLE SLOT

ASOF2:	JUMPE 2,ASOF4		;FREE => NOT FOUND
	JUMPGE 5,ASOF7		;FIRST DELETED ENCOUNTERED?
	MOVE 5,3		;YES, SAVE IT
	JRST ASOF7

;ASOFN (CONT.)

ASOF4:	JUMPL 5,.+2		;DELETED ENCOUNTERED?
ASOF6:	MOVE 3,5		;YES, USE IT
	POP P,1			;RECOVER CLASS AND BITS
	TLZE 1,1B21		;NEWLY ASSIGNED XB?
	TLNN 1,10		;AND DISK ADDRESS?
	JRST .+2		;NO
	TLO 6,NEWFB		;YES, INDICATE IN DISK ADDRESS
	MOVEM 1,SPTH(3)
	MOVEM 6,SPT(3)		;PUT ADDRESS IN SPT
	AOS NOF			;COUNT OPEN FILES
	SKIPE DISKP		;NO DISK ON SYSTEM, OR
	TLNE 6,NEWFB		;NEW FILE?
	JRST ASOF5		;YES
	MOVSI 1,1B31
	ADDM 1,SPT(3)		;BUMP SHARE COUNT
	PUSH P,3		;SAVE OFN
	CALL SETXB1		;MAP XB
	POP P,3
	MOVE 1,CXBPGA		;GET XB IN CORE
	MOVE 1,SPT(3)		;CORE ADDRESS
	MOVSI 2,SWPERR
	TDNE 2,CST3(1)		;DISK ERROR IN XB?
	JRST ASCHK3		;YES, DON'T OPEN
	MOVSI 1,-1000		;SETUP TO SCAN XB
ASCHK1:	MOVE 2,CXBPGA(1)	;GET WORD FROM XB
	JUMPE 2,ASCHK2		;NOT IN USE
	TLC 2,ACCESB+10		;MUST HAVE ACCESS AND DISK BITS ON,
	TLNE 2,777770-RWX	;RWX AND OTHER ADDRESS BITS DONT CARE,
	JRST ASCHK3		;OTHERS ALL OFF, OTHERWISE DONT OPEN
ASCHK2:	AOBJN 1,ASCHK1
	CALL RELCXB		;OK, RELEASE XB
	JRST ASOF9

ASCHK3:	CALL RELCXB		;FILE NO GOOD, RELEASE XB
	MOVE 1,SPT(3)		;CLEAR OFN AND CORE PAGE
	SETOM SPTH(3)
	SOS NOF
	CALL DECOR
	SETZM CST2(1)
	JSP 4,ONRQ
	MOVEI 1,OPNX16		;ERROR NUMBER FOR BAD XB
	JRST SKORET		;RETURN BAD

;SHARED OPEN, CHECK WRITE AND THAWED BITS FOR LEGAL COMBINATION

ASOF3N:	NOSKED
ASOF3:	MOVSI 2,SPTLKB
	TDNE 2,SPTH(3)		;LOCKED BY DDMP?
	JRST [	OKSKED		;YES
		CAIA
		JRST ASOF3N
		JSYS BLOCK1]	;THIS RETURNS CALLER -1
	POP P,2			;RECOVER CLASS AND BITS
	MOVSI 1,-1B31
	TDNN 1,SPT(3)		;SHARE COUNT 0?
	JRST ASOF8		;YES (FILE EFFECTIVELY NOT OPEN)
	MOVE 1,SPTH(3)		;GET EXISTING BITS
	XOR 1,2			;XOR PRODUCES 0 IF BITS THE SAME
	TLNE 1,THAWB		;THAWED BITS EQUAL?
	JRST ASOFB		;NO, ILLEGAL OPEN
	MOVE 1,SPTH(3)
	IOR 1,2
	TLNN 1,FILWB		;BOTH WRITE BITS 0?
	JRST ASOF5		;YES, LEGAL OPENING, NO CHANGE TO WB
	TLNN 1,THAWB		;THAWED BITS 1?
	JRST ASOFB		;NO, ILLEGAL TO HAVE SHARED WRITING
	AND 2,[XWD FILWB,0]	;LEGAL OPENING, THAWED BITS BOTH 1
	IORM 2,SPTH(3)		;IOR WRITE BITS
ASOF5:	MOVSI 1,1B31		;INCREMENT SHARE COUNT
	ADDM 1,SPT(3)
ASOF9:	OKSKED
	MOVEI 1,0(3)		;RETURN OFN (SPT INDEX)
	JRST RSKP

ASOF8:	MOVE 1,SPT(3)
	TLNE 1,17		;NOW IN CORE?
	JRST ASOF81		;NO
	MOVSI 4,DWRBIT		;YES, WAIT FOR ANY WRITE TO COMPLETE
	TDNE 4,CST3(1)
	JRST .-1
ASOF81:	XOR 2,SPTH(3)		;SET THAW AND WRITE BITS TO GIVEN
	AND 2,[XWD FILWB+THAWB,0]
	XORM 2,SPTH(3)
	JRST ASOF5		;RETURN OK

ASOFB:	MOVEI 1,OPNX9		;ERROR NUMBER FOR FILE BUSY
	JRST SKORET

;RELEASE OPEN FILE NUMBER, OFN IN AC1

RELOFN:	MOVSI 2,SPTLKB
RELOF4:	NOSKED
	TDNE 2,SPTH(1)		;LOCKED BY DDMP?
	JRST [	OKSKED		;YES
		CAIA		;WAIT A LITTLE, THEN TRY AGAIN
		JRST RELOF4
		JSYS BLOCK1]	;THIS RETURNS CALLER -1
	MOVEI 3,0(1)
	CALL SETXB1		;MAP INDEX BLOCK
	LDB 2,[POINT 14,SPT(1),13] ;GET SHARE COUNT
	SETO 4,			;RETURN -1 IF NOT COMPLETELY CLOSED
	SKIPE DISKP		;NO DISK, OR
	CAIE 2,1		;IS THIS FINAL CLOSE?
	JRST RELOF1		;NO
	MOVSI 3,-1000		;SCAN XB
	SETZ 4,			;INIT COUNT OF IN-USE PAGES
RELOF3:	MOVE 2,CXBPGA(3)	;GET XB WORD
	JUMPE 2,RELOF2		;EMPTY
	TLNN 2,10		;ADDRESS OK IF ON DISK OR IN CORE
	TLNN 2,17
	TLNE 2,SHRBIT+INDBIT	;POINTER TYPE OK IF PRIVATE
	JRST RELBAD
	TLNN 2,NEWFB		;UNUSED PAGE?
	AOJA 4,RELOF2		;NO, COUNT IN-USE PAGE
	PUSH P,1		;PAGE NEVER REFERENCED, RELEASE IT
	PUSH P,3
	PUSH P,4
	MOVE 1,2
	CALL DEDSK
	POP P,4
	POP P,3
	POP P,1
	SETZM CXBPGA(3)
RELOF2:	AOBJN 3,RELOF3
RELOF1:	MOVSI 2,-1B31		;REDUCE SHARE COUNT OF XB ONCE MORE
	ADDM 2,SPT(1)		;FOR CLOSING
	MOVE 1,4
SETMPX:	CALL RELCXB		;RELEASE TEMP MAPPING
	OKSKED
	RET

RELBAD:	BUG(CHK,<BAD POINTER TYPE IN INDEX BLOCK>)
	MOVE 2,SPT(1)
	MOVSI 3,SWPERR
	IORM 3,CST3(2)		;INDICATE ERROR IN PAGE SO IT WON'T
	JRST RELOF1		;BE WRITTEN ON DISK

;ASSIGN PSB FOR NEW PROCESS

ASPSB:	NOSKED
	CALL ASSPT
	JRST SKORET

ASSPT:	SKIPG 1,FRESPT		;ANY FREE CELLS?
	BUG(HLT,<SPT COMPLETELY FULL>)
	MOVE 1,0(1)
	EXCH 1,FRESPT
	SUBI 1,SPT
	AOS SPTC		;ASSIGN SPT SLOT
	MOVSI 2,1B31+1
	MOVEM 2,SPT(1)		;SHARE COUNT OF 1, NO ADDRESS
	SETZM SPTH(1)
	RET

;DEASSIGN SPT AND RELEASE STORAGE

DESPTN:	NOSKED
	CALL DESPT
	JRST SKORET

DESPT:	MOVSI 2,-1B31
	ADDB 2,SPT(1)		;REDUCE SHARE COUNT
	TLNE 2,-1B31		;NOW ZERO?
	BUG(HLT,<TRIED TO RELEASE SPT SLOT BUT SHARE COUNT NOT 0>)
	MOVE 3,2
	PUSH P,1
	CALL REMFP1		;RELEASE CORE AND/OR DRUM
	POP P,1
	ADDI 1,SPT
	EXCH 1,FRESPT		;PUT ON FREE LIST
	EXCH 1,@FRESPT
	SOS SPTC
	RET

;DELETE XB ASSOCIATED WITH OFN
;LAST STAGE OF DELETE FILE

DELOFN:	CALL WTSPT		;WAIT FOR SPT TO BE UNSHARED
	NOSKED
	JSP 4,WTSPTT		;SHARE COUNT NOW 1?
	JRST DELO1		;NO, GO WAIT SOME MORE
	MOVSI 2,-1B31		;SHARE COUNT SHOULD NOW BE 1
	ADDB 2,SPT(1)		;FOR LAST OPENING
	TLNE 2,-1B31		;NOW 0?
	BUG(HLT,<TRIED TO DELETE INDEX BLOCK BUT SHARE COUNT NOT 0>)
	MOVE 3,2
	SETOM SPTH(1)
	PUSH P,1
	CALL REMFP1		;DELETE ALL STORAGE
	POP P,1
	SOS NOF
	OKSKED
	RET

DELO1:	OKSKED
	JRST DELOFN

;READ MAP GIVEN VIRTUAL ADDRESS

MRMAP:	CALL FPTA		;GET PAGE TABLE ADDRESS

;GENERAL MAP READ
;ENTER HAVING PTN.PN IN 1
; RETURN +1 IF PTN.PN
; RETURN +2 IF OFN.PN

MRPT:	CALL SETCPT
	MOVE 2,CPTPGA(1)	;GET MAP WORD
	JUMPE 2,RDMQ5		;EMPTY
	PUSH P,1		;SAVE ORIG IDENT
	PUSH P,2
	TLNN 2,SHRBIT+INDBIT	;PRIVATE?
	JRST MRMP		;YES
	TLNN 2,SHRBIT		;SHARED OR INDIRECT
	JRST MRMI		;INDIRECT
	LSH 2,-^D9		;GET SPT NUMBER
	ANDI 2,SPTM
	CAIL 2,NOFN		;INDEX BLOCK?
	MOVE 2,SPTH(2)		;NO, GET OFN.PN
MRM1:	MOVE 1,2
	HLRZ 2,1
	CAIL 2,NOFN		;OWNED BY OFN?
	JRST MRMQ		;NO
	AOS -2(P)		;YES, SKIP RETURN
MRMQ1:	POP P,2			;ORIGINAL POINTER
	POP P,3			;FLUSH ORIG IDENT
	AND 2,[XWD RWX+TRAPUB+COPYB,0]
	TLO 2,1B23		;EXISTS BIT
	JRST RELCPT

MRMI:	LSHC 2,-^D9		;RE-FORMAT INTO OFN.PN OR PTN.PN
	ANDI 2,SPTM
	LSH 3,-^D9
	LSHC 2,^D18
	JRST MRM1

RDMQ5:	SETZB 1,2		;RETURN 0
	JRST RELCPT

MRMQ:	CAME 1,-1(P)		;OWNED BY ORIG IDENT?
	JRST MRMQ1		;NO
MRMP:	PUSH P,1
	HLRZ 2,1
	CAMN 2,MMSPTN		;SWP MON MAP?
	JRST MRMP1		;YES, DON'T PUT IN PMF
	CALL RELCPT
	MOVE 1,JOBPMF		;ASSIGN NEW PAGE FROM PMF
	FFFFP
	CALL JFNOFN
	BUG(HLT,<FAILED TO CONVERT JFN FROM FFFFP TO OFN>)
	MOVSI 3,RWX		;PUT PAGE IN PMF WITH ALL ACCESS
	MOVE 2,1
	EXCH 1,0(P)
	CALL SETPT		;PUT PAGE IN PMF
MRMP1:	POP P,2			;OFN.PN OF NEW PAGE
	JRST MRM1

;READ PAGE ACCESSIBILITY

MRPACS:	PUSH P,[0]
	PUSH P,[XWD RWXB+TRAPUB+COPYB,0]
MRP4:	HLRZ 3,1		;SOURCE PTN
	CAIG 3,0
	BUG(HLT,<ILLEGAL LH OF 1 ARG TO MRPACS>)
	CALL SETXB1		;MAP PT
	MOVE 3,CXBPGA(1)	;GET MAP WORD
MRP6:	SKIPN -1(P)		;FIRST MAP WORD?
	HLRZM 3,-1(P)		;YES, SAVE FIRST PT ACCESS
	TLC 3,TRAPUB+COPYB	;FOR THESE BITS, WE'RE AND'ING 0'S
	ANDM 3,0(P)		;COMPUTE AND OF ALL MAP WORDS
	TLNN 3,INDBIT		;INDIRECT?
	JRST MRP2		;NO, SHARED OR PRIVATE
	CALL RELCXB
	ROTC 2,-^D9		;REFORMAT INTO PTN.PN
	ANDI 3,SPTM
	LSH 3,^D9
	ROTC 2,^D9
	MOVE 1,3
	JRST MRP4

MRP2:	POP P,1			;AND OF ALL MAP WORDS
	POP P,2			;FIRST POINTER ACCESS
	TLC 1,TRAPUB+COPYB	;BITS FOR WHICH AND'ING 0'S
	JUMPE 2,RELCXB		;RETURN 0 IF FIRST POINTER WAS 0
	TLNN 3,SHRBIT+INDBIT	;FINAL PTR PRIVATE?
	TLO 1,(1B10)		;YES, SO INDICATE
	TLZE 1,ACCESB		;ANY ACCESS?
	TLO 1,(1B5)		;YES, SET BIT IN RESULT
	TRNE 2,INDBIT		;FIRST POINTER INDIRECT?
	TLO 1,(1B6)		;YES, NOTE
	ANDI 2,RWX+TRAPUB+COPYB	;BITS OF ORIG PTR TO GIVE TO USER
	HRRI 1,1B23(2)		;ORIG PTR ACCESS WITH EXISTS BIT TO RH
	JRST RELCXB		;RELEASE PT AND RETURN

;SET PAGE ACCESSIBILITY

MSPACS:	PUSH P,2
	CALL SETCPT		;MAP PT
	POP P,2
	SKIPN CPTPGA(1)		;PAGE EXISTS?
	JRST RELCPT		;NO, IGNORE CALL
	HLRZ 3,1
	CAIGE 3,NOFN		;FILE?
	TLZ 2,TRAPUB+COPYB	;YES, DISALLOW BITS
	XOR 2,CPTPGA(1)		;SET BITS 2-4
	AND 2,[XWD RWX+TRAPUB+COPYB,0]
	XORB 2,CPTPGA(1)
	JRST RELCPT

;MRPAC - JSYS FOR MONITOR DDT
;DOESN'T WORK CORRECTLY FOR RES MON ADDRESSES WHEN MAPRESMON IS ON

.MRPAC:	JSYS MENTR
	MOVE 2,0(P)		;RETURN PC
	TLNE 2,UMODF		;FROM MONITOR?
	JRST ITRAP		;NO, ILLEGAL FROM USER
	TLNE 1,400000		;USER?
	JRST [	CALL FPTA	;YES, GET PTN.PN
		JRST MRPC3]
	MOVEI 2,0(1)		;MONITOR, GET ADDRESS
	CAIGE 2,100000		;RESIDENT MON?
	JRST [	MOVSI 1,RWX+1B28 ;YES, MEANS PRIVATE AND ALL ACCESS
		JRST MRPC2]
	CAIGE 2,PPRMA		;NON-RES MON?
	JRST [	LSH 2,-^D9	;NO, IS RESIDENT MAPPED MON
		SKIPE 1,MMAP(2)	;REQUESTED PAGE EXISTS?
		TLO 1,1B28	;YES
		JRST MRPC2]	;RETURN CONTENTS OF MMAP
	CAIL 2,CXBPGA		;CHECK SPECIAL PAGES
	CAILE 2,CPYPGA		;SETPT, ETC. PAGES?
	CAIGE 2,PPRMA+NRSPG*1000 ;SWAPPER PAGES?
	JRST MRPC1		;YES, RETURN NO-ACCESS
	CALL FPTA
MRPC3:	CALL MRPACS
MRPC2:	UMOVEM 1,2		;RETURN RESULT IN 2 LIKE RPACS
	JRST MRETN

MRPC1:	MOVSI 1,(1B10)		;NO-ACCESS
	JRST MRPC2

;SET PAGE IN MONITOR OR USER MAP (INTERNAL MONITOR CALL)
; AC1/ OFN,,PN   (OFN IS SPT POINTER, PN IS 0-777)
; AC2/ 18-35 VIRTUAL ADDRESS OF PAGE (NOT PAGE NUMBER)
;       0    1 => USER MAP, 0 => MONITOR MAP
;       2-4, 8, 9  READ, WRITE, XCT ALLOW BITS (SAME AS PAGER MAP WORD)
;      15-17 DISPOSAL INFO FOR OLD PAGE, 0 => NO SPECIAL ACTION,
;             PAGE TO BE HANDLED AS USUAL. 1 => NO FURTHER USE FOR
;             PAGE, SHOULD BE MOVED TO HOME ADDRESS.

SETMPG:	PUSH P,7		;SAVE AC'S
	MOVEI 7,1(P)
	ADD P,BHC+7
	JUMPGE P,MSTKOV		;STACK OVERFLOW?
	BLT 7,0(P)
	HLLZ 3,2		;GET ACCESS AND DISPOSAL
	PUSH P,3
	EXCH 1,2
	CALL FPTA		;CONVERT ADDRESS TO PTN.PN
	JRST SETP8

;SET PAGE TABLE (FOR PROCESS OR FILE)
; AC1/ SOURCE IDENTIFIER
; AC2/ DESTINATION IDENTIFIER
; AC3/ 2-4, 8, 9 ACCESS PERMISSION, 15-17 DISPOSAL

;IDENT IS OFN.PN (PAGE IN FILE), 0.OFN (INDEX BLOCK),
; PTN.PN (PAGE IN PROCESS), OR 0.PTN (PROCESS PT)

SETPT:	PUSH P,7		;SAVE AC'S
	MOVEI 7,1(P)
	ADD P,BHC+7
	JUMPGE P,MSTKOV		;STACK OVERFLOW?
	BLT 7,0(P)
	PUSH P,3		;SAVE ACCESS
	EXCH 1,2
SETP8:	CALL RELMPG		;RELEASE EXISTING PAGE
	NOSKED
	JUMPE 2,SETPT1		;NO NEW PAGE TO SET
SETP5A:	CAMN 1,2		;DON'T ALLOW MAP TO SELF
	JRST SETPF1
	HLRZ 3,2		;GET OFN
	JUMPE 3,SETMXB		;OFN=0 MEANS SPTN IN RH
	TDNE 2,[XWD -SPTM-1,777000] ;LEGAL PTN AND PN?
	BUG(HLT,<ILLEGAL SOURCE IDENTIFIER GIVEN TO SETPT>)
	CALL SETXB1		;MAP INDEX BLOCK
SETP72:	MOVE 3,CXBPGA(2)	;GET WORD FROM XB
	HLRZ 4,1		;GET DESTINATION PTN
	CAIGE 4,NOFN		;FILE?
	JRST SETP7		;YES
	HLRZ 4,2		;GET SOURCE PTN
	CAIL 4,NOFN		;PROCESS?
	JRST SETP5		;YES, GO SETUP INDIRECT POINTER
	TLNE 3,SHRBIT+INDBIT	;PRIVATE?
	JRST SETMP3		;NO
	TLNN 3,ACCESB		;PAGE EXISTS?
	JRST SETP3		;NO, GO CREATE IT
SETP4:	MOVE 4,SPTC		;YES
	CAMGE 4,SPC0		;ROOM IN SPT? (SPT < C FULL)
	JRST SETMP6		;YES
	SETCM 4,3		;GET ACCESS OF SOURCE
	TLNE 4,RWX		;ALL POSSIBLE?
	SKIPG FRESPT		;NO, SHOULDN'T USE IND PTR
	JRST SETP5		;USE IND PTR
	JRST SETMP6		;USE SHR PTR

SETP5:	SKIPGE INDFLG		;ALLOWING USE OF INDIRECT POINTERS?
	JRST SETPF2		;NO, GO TRY ALTERNATIVES
	TLNE 3,INDBIT		;SOURCE CONTAINS IND PTR?
	JRST [	CALL RELCXB	;YES, TRACE DOWN
		ROTC 2,-^D9	;CONSTRUCT IDENT OF PAGE POINTED
		ANDI 3,SPTM	;TO BY IND PTR
		LSH 2,-^D9
		ROTC 2,-^D18
		JRST SETP5A]	;AND USE THAT AS SOURCE
	LSHC 2,-^D9		;CONSTRUCT INDIRECT POINTER
	LSH 2,-^D9
	LSHC 2,^D9
	TLO 2,ACCESB+INDBIT
SETMP4:	LDB 3,[POINT 13,2,26]	;GET OFN OF INDEX BLOCK
SETMP5:	MOVSI 4,1B31
	CAIE 3,0		;IF NO OWNING PT
	ADDM 4,SPT(3)		;INCREMENT SHARE COUNT OF INDEX BLOCK
	POP P,3
	XOR 2,3			;PUT ACCESS BITS IN PTR
	TLZ 2,RWX+TRAPUB+COPYB	;USER ALLOWED TO SPECIFY THESE
	XOR 2,3
	MOVEM 2,CPTPGA(1)	;PUT MAP WORD IN MAP
SETPT2:	CALL RELCPT		;RELEASE PT MAPPING
	SUB P,BHC+7
	MOVSI 7,1(P)
	BLT 7,6
	POP P,7			;RESTORE AC'S
	JRST SETMPX

SETPT1:	POP P,3			;FLUSH JUNK
	JRST SETPT2

SETP3:	MOVSI 3,RWXB+1
	SKIPN DISKP		;DISK ON SYSTEM?
	JRST SETP3A		;NO, USE UNASSIGNED ADDRESS INDICATOR
	PUSH P,1
	PUSH P,2
	HLRZ 2,2		;GET DISK ADDRESS OF XB
	MOVE 1,SPTH(2)
	CALL DSKASN		;ASSIGN DISK ADDRESS
	JRST SETP3B		;DISK FULL
	TLO 1,RWXB+NEWFB	;ACCESS AND INDICATE NEW ASSIGNMENT
	MOVE 3,1
SETP3H:	POP P,2
	POP P,1
SETP3A:	MOVEM 3,CXBPGA(2)	;PUT IN XB
	JRST SETP4

SETP3B:	MOVEI 1,OPNX10		;LEAVE ERROR NUMBER
	MOVEM 1,LSTERR
	MOVEI 1,^D11
	CALL PSIRQ0		;SEND FILE ERROR INTERRUPT
	SUB P,BHC+3		;CLEAR STACK
	JRST SETPT2		;RETURN HAVING DONE NOTHING

;SETMPG (CONT.)

SETPF2:	TLNE 3,SHRBIT+INDBIT	;SHARED NOW?
	JRST SETMP3		;YES, USE SAME POINTER
	JUMPE 3,[MOVSI 3,RWXB+1	;IF SOURCE CURRENTLY EMPTY,
		JRST SETP3A]	;USE UNASSIGNED ADDRESS INDICATION
	SKIPLE FRESPT		;ANY SPT SPACE AT ALL?
	JRST SETMP6		;YES, GO ASSIGN A SLOT
	MOVEI 1,		;GIVE ERROR INDICATION
	JRST SETPTE

SETMP3:	MOVE 2,3		;ALREADY SHARED, USE SAME POINTER
	TLNE 2,INDBIT		;INDIRECT?
	JRST SETMP4		;YES
SETMP7:	LDB 3,[POINT 13,2,26]
	MOVSI 4,1B31		;SHARED,
	ADDM 4,SPT(3)		;INCREMENT SHARE COUNT IN SPT
	HLRZ 3,SPTH(3)		;GET OFN FOR THIS PAGE
	JRST SETMP5		;GO INCREMENT SHARE COUNT OF XB

SETMP6:	SKIPG 4,FRESPT		;ASSIGN NEW SPT SLOT
	BUG(HLT,<SPT COMPLETELY FULL>)
	MOVE 4,0(4)		;GET CDR
	EXCH 4,FRESPT		;LIST OF FREE SLOTS
	SUBI 4,SPT		;MAKE RELATIVE
	AOS SPTC		;COUNT OF USED SPT ENTRIES
	TLNE 3,17		;IN CORE?
	JRST SETP2
	CAME 2,CST2(3)		;CHECK OLD OWNERSHIP
	BUG(HLT,<PAGE TABLE CORE POINTER AND CST2 FAIL TO CORRESPOND>)
	MOVEM 4,CST2(3)		;RECORD NEW LOCATION OF CORE ADDRESS
	HLRZ 6,2		;YES, UPDATE LOCK COUNT FOR
	MOVE 6,SPT(6)		;OWNING PT
	MOVSI 5,-PLKV		;REDUCE IT, BECAUSE IT WILL HAVE
	ADDM 5,CST1(6)		;ONE LESS CORE ADDRESS IN IT
SETP2:	TLZ 3,-1B31		;FLUSH BITS IN ORIGINAL POINTER
	MOVEM 3,SPT(4)		;PUT IT IN SPT
	MOVEM 2,SPTH(4)		;PUT OFN.PN IN SPTH
	HLRZ 3,2		;SAVE OFN
	LSH 4,^D9		;CONSTRUCT SHARE POINTER
	TLO 4,SHRBIT
	XOR 4,CXBPGA(2)		;WITH PROTECTION BITS FROM PT
	TLZ 4,RWXB
	XORB 4,CXBPGA(2)	;PUT CONSTRUCTED SHARE POINTER IN PT
	MOVE 2,4		;AS WELL AS PROCESS MAP
	MOVSI 4,1B31		;BUMP SHARE COUNT FOR POINTER PUT
	ADDM 4,SPT(3)		;IN XB
	JRST SETMP7		;GO INCREMENT SHARE COUNTS, ETC.

SETMXB:	CAIL 2,SSPT		;LEGAL NUMBER?
	BUG(HLT,<ILLEGAL SPT INDEX GIVEN TO SETMXB>)
	HLRZ 3,1		;GET DESTINATION PTN
	CAIGE 3,NOFN		;FILE?
	BUG(HLT,<ILLEGAL DESTINATION IDENTIFIER TO SETMPG OR SETPT>)
	MOVEI 3,0(2)		;REQUEST WAS FOR INDEX BLOCK
	LSH 2,^D9		;MAKE IT INTO SHARE POINTER
	TLO 2,SHRBIT+RWXB
	JRST SETMP5

;DESTINATION IS FILE

SETP7:	HLRZ 4,2		;GET SOURCE PTN
	CAIGE 4,NOFN		;IS FILE?
	JRST SETPF1		;YES, ERROR
	TLNE 3,SHRBIT+INDBIT	;NOT PRIVATE?
	JRST SETPF		;YES
	JUMPE 3,SETP7K		;PAGE NEVER REFERENCED
	TLNE 3,10		;NOW ON DISK?
	JRST SETP71		;YES
	TLNE 3,16		;NOW ON DRUM?
	JRST SETP7D		;YES, GO ADJUST DRUM BACKUP ADR
	PUSH P,1		;IN CORE,
	MOVEI 1,0(3)
	CALL AGESET		;FIX PAGE
	POP P,1
	MOVSI 4,PLKV		;IN CORE,
	ADDB 4,CST1(3)		;GET BACKUP ADR AND LOCK PAGE
	TLNE 4,10		;DISK?
	JRST SETP7C		;YES
	TLNE 4,16		;DRUM?
	JRST SETP7E		;YES
	MOVEI 4,CST1(3)		;NOT ASSIGNED, PUT BACKUP ADR IN CST1
	CALL SETP7A		;ASSIGN BACKUP ADR AND STORE IT
SETP7C:	PUSH P,3
	MOVEM 1,CST2(3)		;IN CORE, ADJUST CST
	MOVSI 4,-PLKV
	ADDM 4,CST1(3)		;UNLOCK PAGE
	HLRZ 4,2		;SOURCE PTN
	MOVE 4,SPT(4)
	MOVSI 3,-PLKV
	ADDM 3,CST1(4)		;REDUCE LOCK COUNT OF PT
	HLRZ 4,1
	MOVE 4,SPT(4)
	MOVSI 3,PLKV
	ADDM 3,CST1(4)		;INCREASE LOCK COUNT OF XB
	POP P,3
SETP71:	SETZM CXBPGA(2)		;PUT SOURCE PTR IN DEST MAP
	HLRZ 4,0(P)		;GET USER SPECIFIED ACCESS
	ANDI 4,RWX
	TLZ 3,-1B31
	TLO 3,ACCESB(4)		;PUT ACCESS AND ACCESS BIT IN PTR
	MOVEM 3,CPTPGA(1)
	EXCH 1,2		;EXCHANGE SOURCE AND DESTINATION PT'S
	MOVE 3,PSB+CPTPG
	EXCH 3,PSB+CXBPG
	MOVEM 3,PSB+CPTPG
	MONCLR			;CLEAR MONITOR AR'S
	JRST SETP72		;NOW AS IF PAGE WAS IN FILE

SETP7K:	MOVSI 3,RWXB		;NEW PAGE, SETUP POINTER
	MOVEI 4,3		;WHERE TO STORE ADDRESS
	JRST SETP73

SETP7D:	MOVE 4,3
SETP7E:	PUSH P,2
	PUSH P,3
	MOVE 2,4		;DRUM ADDRESS
	CALL GDSTX		;GET DST INDEX
	MOVEI 4,DST(2)		;WHERE TO STORE ADDRESS
	POP P,3
	POP P,2
	MOVE 5,0(4)		;PRESENT BACKUP
	TLNN 5,10		;DISK?
SETP73:	CALL SETP7A		;NO, ASSIGN DISK ADDRESS AND STORE IT
	TLNN 3,17
	JRST SETP7C
	JRST SETP71

SETP7A:	HLRZ 5,1		;GET OFN OF DESTINATION FILE
	PUSH P,1		;SAVE STUFF
	PUSH P,2
	PUSH P,3
	PUSH P,4
	SKIPN DISKP		;DISK ON SYSTEM?
	JRST [	MOVSI 1,1	;USE DEFAULT ADDRESS
		JRST SETP7Y]
	MOVE 1,SPTH(5)		;GET XB ADRESS AND CLASS
	CALL DSKASN		;ASSIGN DISK ADDRESS FOR PAGE
	JRST SETP7X		;DISK FULL
	TLO 1,NEWFB		;INDICATE NEW ASSIGNMENT
SETP7Y:	MOVE 5,1
	POP P,4
	POP P,3
	POP P,2
	POP P,1
	DPB 5,[POINT 22,0(4),35]	;STORE ADDRESS WHERE GIVEN
	RET

SETP7X:	SUB P,BHC+4+1		;FLUSH 4 TEMPS AND 1 RETURN
	JRST SETP3B		;GO DO NO-ROOM ERROR AND RETURN

;POINTER NOW IN SPT OWNED BY FORK. MOVE IT TO FILE

SETPF:	LDB 4,[POINT 13,3,26]	;GET SPTN
	CAMN 2,SPTH(4)		;IS OWNED BY SOURCE?
	TLNE 3,INDBIT		;AND NOT INDIRECT?
	JRST SETPF1		;SORRY, CAN'T GIVE AWAY UNOWNED PAGES
	MOVEM 1,SPTH(4)		;SET NEW OWNERSHIP
	MOVSI 5,-1B31
	AND 5,SPT(4)		;GET CURRENT SHARE COUNT
	HLRZ 4,1
	ADDM 5,SPT(4)		;TRANSFER SHARE COUNT TO NEW OWNING PT
	MOVN 5,5
	HLRZ 4,2
	ADDM 5,SPT(4)		;AWAY FROM OLD PT
	JRST SETMP3		;NOW SETUP SHARE POINTER IN DEST

SETPF1:	MOVEI 1,		;ILLEGAL PAGE TO FILE ATTEMPTED
SETPTE:	MOVEM 1,LSTERR
	MOVEI 1,^D11		;IO ERROR CHANNEL
	CALL PSIRQ0
	JRST SETPT1		;CLEAN UP AND EXIT

;PUT INDEX BLOCK IN FIXED PAGE (CXBPG) OF PP MAP FOR TEMP USE

SETXB1:	CALL RELCXB		;RELEASE CURRENT ONE
	NOINT			;NO INTERRUPTS WHILE XB MAPPED
	LSH 3,^D9
	TLO 3,RWXB-XCTB+SHRBIT	;MAKE INTO SHARE POINTER, NO XCT
	MOVEM 3,PSB+CXBPG	;PUT INTO CURRENT X BLOCK PAGE
	RET

;RELEASE INDEX BLOCK NOW IN FIXED PAGE

RELCXB:	SKIPN PSB+CXBPG
	RET			;NONE THERE NOW
	SETZM PSB+CXBPG		;CLEAR MAP
	MONCLR			;CLEAR MONITOR AR'S
	OKINT
	RET

POP1:	POP P,1
	RET

;MAP CURRENT PAGE TABLE FOR TEMP USE

SETCPT:	CALL RELCPT		;RELEASE CURRENT ONE
	NOINT
	HLRZ 2,1		;MAKE SHARE POINTER
	LSH 2,^D9
	TLO 2,RWXB-XCTB+SHRBIT
	MOVEM 2,PSB+CPTPG
	RET

;RELEASE CURRENT PT MAPPING

RELCPT:	SKIPN PSB+CPTPG		;ANYTHING THERE?
	RET			;NO
	SETZM PSB+CPTPG		;CLEAR MAP
	MONCLR			;CLEAR AR'S
	OKINT
	RET

;RELEASE PAGE FROM MAP
; AC1/ OFN.PN OF PAGE

RELMPG:	PUSH P,3
	PUSH P,2
	CALL SETCPT
	PUSH P,1
	NOSKED
	MOVE 2,CPTPGA(1)	;GET MAP WORD
	JUMPE 2,RELMPR		;EMPTY
	CONO PGR,0		;CLEAR AR'S
	TLNN 2,SHRBIT+INDBIT	;PRIVATE POINTER?
	JRST RELP3
RELMP1:	HLRZ 3,1		;GET PTN
	TLNE 2,INDBIT		;INDIRECT POINTER
	JRST RELMP3		;THAT'S OK
	CAIGE 3,NOFN		;OWNED BY FILE?
	JRST RELMP4		;CAN'T DELETE FILE PAGE STILL SHARED
	LDB 3,[POINT 13,2,26]	;GET SPTN
	CAMN 1,SPTH(3)		;OWNER TRYING TO DELETE?
	JRST RELMP4		;MUST WAIT TILL UNSHARED
RELMP3:	SETZM CPTPGA(1)		;CLEAR MAP WORD
	MOVE 3,2		;SAVE POINTER
	LSH 2,-^D9
	ANDI 2,SPTM		;GET SPT INDEX
	MOVSI 1,-1B31
	TLNN 3,INDBIT		;INDIRECT POINTER, OR
	CAIGE 2,NOFN		;OFN?
	JRST RELP1		;YES
	HLRZ 3,SPTH(2)		;IS SHARE POINTER, GET OFN
	JUMPE 3,RELP1		;IF UNOWNED SPTN
	ADDM 1,SPT(3)		;REDUCE SHARE COUNT OF OFN
	ADDB 1,SPT(2)		;REDUCE SHARE COUNT OF PAGE OR XB
	TLNE 1,-1B31		;COUNT NOW 0?
	JRST RELMPR		;NO
	TLNE 1,17		;CORE?
	JRST RELMP2		;NO
	CALL AGESET		;IN CORE, SET AGE
	MOVSI 4,PLKV
	ADDM 4,CST1(1)		;AND LOCK WHILE ADJUSTING

RELMP2:	MOVSI 4,-1B31
	ADDM 4,SPT(3)		;REDUCE SHARE COUNT OF XB
	CALL SETXB1		;MAP OWNING XB
	MOVE 4,SPTH(2)		;GET OWNING PTN.PN
	XOR 1,CXBPGA(4)		;PUT ADDRESS BACK IN XB WITH ORIGINAL
	TLZ 1,-1B31-SHRBIT-INDBIT
	XORB 1,CXBPGA(4)	;ACCESS BITS
	CALL RELCXB		;RELEASE XB
	MOVE 3,2
	ADDI 2,SPT
	EXCH 2,FRESPT		;RETURN SPT SLOT TO FREE LIST
	MOVEM 2,@FRESPT
	SOS SPTC
	TLNE 1,17		;PAGE IN CORE?
	JRST RELP4		;NO
	CAME 3,CST2(1)		;CONFIRM OLD OWNERSHIP
	BUG(HLT,<PAGE TABLE CORE POINTER AND CST2 FAIL TO CORRESPOND>)
	MOVEM 4,CST2(1)		;YES, CHANGE RECORD OF OWNING PT
	HLRZ 4,4		;PTN OF OWNING PT
	MOVE 4,SPT(4)		;CORE ADDRESS OF IT
	MOVSI 2,PLKV
	ADDM 2,CST1(4)		;INCREMENT LOCK COUNT
	MOVSI 4,-PLKV
	ADDM 4,CST1(1)		;UNLOCK PAGE
	JRST RELP2

RELP4:	TLNN 1,10		;ON DISK? OR
	TLNN 1,16		;NOT ASSIGNED?
	JRST RELMPR		;YES
	MOVE 1,4
	CALL SWPINP		;GET IT OFF DRUM
RELP2:	CALL AGESET		;MAKE PAGE IN USE
	CALL DECOR		;DEASSIGN
RELMPR:	POP P,1
	POP P,2
	POP P,3
SKORET:	OKSKED			;RE-ENABLE SCHEDULING
	RET

RELP3:	CALL REMFPG		;RELEASE ALL STORAGE
	JRST RELMPR

RELP1:	ADDM 1,SPT(2)
	JRST RELMPR

RELMP4:	SUB P,BHC+3		;FLUSH TEMPS
	MOVEI 1,		;ILLEG UNMAPPING
	MOVEM 1,LSTERR
	MOVEI 1,^D11
	CALL PSIRQ0		;GENERATE ITRAP
	SETZB 1,2
	JRST SKORET

;REMOVE PAGE FROM SYSTEM (DELETE PERMANENT AND TEMPORARY ADDRESSES)

REMFPG:	MOVE 3,CPTPGA(1)	;GET MAP WORD
	SETZM CPTPGA(1)		;CLEAR MAP WORD
REMFP1:	TLNE 3,10		;DISK?
	JRST REMFF		;YES
	TLNE 3,16		;DRUM?
	JRST REMFD		;YES
	TLNE 3,17		;CORE?
	RET			;DONE
	MOVEI 1,0(3)
	CAIGE 1,MAXCOR		;LEGAL PAGE?
	CAMGE 1,SWPCOR
	BUG(HLT,<ILLEGAL CORE PAGE NUMBER TO REMFPG>)
	CALL AGESET
	CALL DECOR
	HLRZ 2,CST2(1)		;GET PTN OF OWNING PT
	JUMPE 2,REMFP2		;NONE, SPT
	MOVE 3,SPT(2)		;GET ADR OF OWNING PT
	MOVSI 4,-PLKV
	ADDM 4,CST1(3)		;DECREMENT LOCK COUNT
REMFP2:	MOVE 2,TODCLK		;SETUP OVERDUE TIME
	ADDI 2,^D2000		;AS 2 SEC FROM NOW
REMFP4:	MOVSI 3,(77B5)
	MOVSI 4,-PLKV
	PIOFF
	SETZM CST2(1)		;FLUSH SOURCE
	TDNE 3,CST0(1)		;PAGE NOW ON RPLQ?
	TDNE 4,CST1(1)		;LOCKED?
	JRST REMF21		;YES, IS OR WILL BE PUT ON RPLQ
	MOVSI 3,DWRBIT
	TDNE 3,CST3(1)		;BEING WRITTEN?
	JRST REMFP3		;YES, MUST WAIT
	PION
REMFP5:	JSP 4,ONRQ		;PUT PAGE ON RPLQ
REMF22:	MOVSI 3,-PLKV
	AND 3,CST1(1)		;FLUSH BACKUP ADDRESS, LEAVE LK CNT
	EXCH 3,CST1(1)		;GET BACKUP ADDRESS
	JRST REMFP1

REMFP3:	PION
	CAML 2,TODCLK		;WAITED LONG ENOUGH?
	JRST REMFP4		;NO, KEEP WAITING
	BUG(CHK,<SWAP WRITE FAILED TO COMPLETE IN 2 SEC>)
	ANDCAM 3,CST3(1)	;FORCE COMPLETION
	JRST REMFP5

REMF21:	PION
	JRST REMF22

REMFD:	MOVE 1,3
	PUSH P,1
	CALL DASDRM		;DEASSIGN DRUM ADDRESS
	POP P,2
	CALL GDSTX
	MOVE 3,DST(2)		;GET BACKUP ADDRESS
	SETOM DST(2)		;MAKE DST SLOT EMPTY
	JRST REMFP1

REMFF:	MOVE 1,3
	CALL DEDSK		;DEASSIGN DISK ADDRESS
	RET

;CONSTRUCT PTN.PN FOR
;ADDRESS GIVEN IN 18-35 OF AC1
;BIT 0 OF AC1 SAYS USER (IF 1) OR MONITOR (IF 0) ADDRESS
;RETURN WITH PTN.PN IN AC1

FPTA:	PUSH P,1
	MOVEI 1,0(1)		;CLEAR LH
	LSH 1,-^D9		;GET PAGE NUMBER
	EXCH 1,0(P)		;GET ARG, SAVE PN
	JUMPL 1,FPTAU		;USER MODE IF BIT 0 IS 1
	MOVE 1,0(P)
	CAIL 1,PPMPG		;WHICH PART OF MONITOR?
	JRST FPTA1		;PRIVATE PER PROCESS
	CAIL 1,PJMPG
	JRST FPTA2		;PRIVATE PER JOB
	CAIL 1,PPRMPG
	JRST FPTA3		;PRIVATE PER PROCESSOR AND SWAPPABLE
	BUG(HLT,<FPTA - ARG POINTS TO RESIDENT MONITOR>)

FPTA1:	CAIGE 1,DDPG1		;DISALLOW SPECIAL PAGES
	BUG(HLT,<FPTA - ILLEGAL PAGE IN PROCESS AREA>)
FPTA5:	MOVE 1,FORKX		;GET SPTN OF PSB
	JRST FPTA4

FPTAU:	MOVE 1,FORKX		;GET SPTN OF UPT OR IF NONE, PSB
	HLL 1,FKPGS(1)
	TLNN 1,-1
FPTA4:	HRLZ 1,FKPGS(1)
FPTAR:	HLLM 1,0(P)		;COMBINE WITH PAGE NUMBER
	JRST POP1		;POP TO 1 AND RETURN

FPTA2:	CAIG 1,JSBPG
	JRST FPTA5		;JSB, NOT INDIRECT PTR
	LDB 1,[POINT 13,PSB+JSBPG,26]	;SPTN OF JSB
	HRLM 1,0(P)
	HRREI 1,-PJMPG+JOBMAP-JSB ;FIRST JOB PAGE MAPPED BY JOBMAP+0
	ADDM 1,0(P)
	JRST POP1

FPTA3:	HRL 1,MMSPTN		;PERMANENT SPTN OF MON MAP
	JRST FPTAR

;LOCK, UNLOCK PAGE ON REQUEST (FOR DTA IO, ETC.)

MLKPG:	PUSH P,1
	CALL GETONT		;GET PTN.PN OR OWNING PT
	TLNN 2,17		;PAGE NOW IN CORE?
	JRST MLKPG1		;YES
	CALL SWPINP		;INITIATE SWAP AND WAIT FOR COMPL.
	POP P,1
	OKSKED
	JRST MLKPG		;TRY AGAIN

MLKPG1:	POP P,1
	MOVE 1,CST1(2)
	TLNE 1,-PLKV		;PAGE LOCKED NOW?
	JRST .+3		;YES
	AOS LOKPGS		;NO, COUNT IT
	SOS MAXNR		;REDUCE MAX AVAILABLE FOR SWAPPING
	MOVSI 1,PLKV
	ADDM 1,CST1(2)		;INCREMENT LOCK COUNT
	AOS LOKSUM
	MOVEI 1,0(2)
	CALL AGESET		;SET AGE
	JRST SKORET		;OKSKED AND RETURN

MULKPG:	PUSH P,2
	CALL GETONT		;GET OWNING PT
	TLNE 2,17		;PAGE NOW IN CORE?
	BUG(HLT,<MULKPG - TRIED TO UNLOCK PAGE NOT LOCKED>)
	CALL MULK1
	POP P,2
	JRST SKORET

MULK1:	MOVSI 1,-PLKV
	TDNN 1,CST1(2)		;LOCK COUNT NON-ZERO?
	BUG(HLT,<TRIED TO UNLOCK PAGE NOT LOCKED>)
	ADDB 1,CST1(2)		;DECREMENT LOCK COUNT
	TLNE 1,-PLKV		;NOW UNLOCKED?
	JRST MULK2		;NO
	SOS LOKPGS
	AOS MAXNR		;RESTORE PAGE TO SWAPPING POOL
	SKIPE CST2(2)		;STILL EXISTS?
	JRST MULK2		;YES
	PUSH P,4		;NO, HAS BEEN DELETED
	MOVEI 1,0(2)
	JSP 4,ONRQ		;PUT ON REPLACABLE QUEUE
	POP P,4
MULK2:	SOS LOKSUM
	RET

;UNLOCK PAGE GIVEN MONITOR ADDRESS
;ASSUMED NOSKED OR INSKED

MULKMP:	MOVEI 1,0(1)
	LSH 1,-^D9
	CAIL 1,PPRMPG+NRSPG
	CAIL 1,PPMPG
	BUG(HLT,<MULKMP - ILLEGAL MONITOR ADDRESS>)
	MOVE 1,MMAP(1)		;GET CORE ADDRESS
	TLZ 1,-1B31		;FLUSH POINTER BITS
	JRST MULKCR

;UNLOCK PAGE GIVEN CORE PAGE NUMBER IN 1

MULKCR:	CAML 1,SWPCOR		;LEGAL?
	CAIL 1,MAXCOR
	BUG(HLT,<MULKCR - ILLEGAL CORE PAGE NUMBER>)
	PUSH P,2
	MOVEI 2,0(1)
	CALL MULK1
	POP P,2
	RET

;GET OWNING PAGE TABLE
;GIVEN PTN.PN, LOCATE PT CURRENTLY HAVING ADDRESS OF PAGE

GETONT:	CALL SETCPT		;MAP GIVEN PAGE TABLE
	NOSKED
	MOVE 2,CPTPGA(1)	;GET MAP WORD
	TLNN 2,SHRBIT+INDBIT	;PRIVATE POINTER?
	JRST RELCPT		;YES, RELEASE CPT AND RETURN
	TLNN 2,INDBIT		;INDIRECT POINTER?
	JRST GETON1		;NO, SHARE POINTER.
	OKSKED
	LSHC 2,-^D9		;REFORMAT INTO PTN.PN
	ANDI 2,SPTM
	LSH 2,^D9
	LSHC 2,^D9
	CALL RELCPT		;RELEASE CPT
	MOVE 1,2
	JRST GETONT		;TRY AGAIN

GETON1:	LDB 1,[POINT 13,2,26]	;FOR SHARE POINTER, RETURN SPTN
	MOVE 2,SPT(1)		;AND CURRENT ADDRESS
	JRST RELCPT		;RELEASE CPT AND RETURN

;SETUP PAGER FOR PROCESS

SETPPG:	HRRZ 10,FKPT(7)		;GET PROCESS NUMBER
	HRRZ 1,FKPGS(7)		;GET PSB
	MOVE 1,SPT(1)
	TLNE 1,17		;MUST BE IN CORE
	BUG(HLT,<SETPPG - PSB NOT IN CORE>)
	CALL AGESET
	HRRZM 1,PGR71		;LEAVE CORE PAGE NUMBER FOR PAGER
	HRRZ 1,FKPGS(7)
	LSH 1,^D9
	TLO 1,RWXB+SHRBIT	;MAKE SHARE POINTER TO PSB
	MOVEM 1,MMAP+FITPG	;PUT IN PPR MAP
	MOVEM 1,FITPGA+PSBPG	;IN PSB
	HLRZ 1,FKPGS(7)		;GET PT
	MOVE 1,SPT(1)
	TLNE 1,17		;MUST BE IN CORE
	BUG(HLT,<SETPPG - PT NOT IN CORE>)
	CALL AGESET
SETPG1:	HRLM 1,PGR71		;LEAVE FOR PAGER
	HRRZ 1,FKCNO(7)
	MOVE 2,BITS-^D9(1)	;PROCESS USE BIT
	HLRZ 1,FKNR(7)		;GET PROCESS AGE
	ROTC 1,-^D9
	MOVEM 2,PGR72
	CONO PGR,0		;LOAD PAGER FROM 71,72
	MOVE 1,ACBAS		;SET AC BASE REGISTER
	SETACB 1
	RET

;DEASSIGN CORE

DECOR:	PUSH P,3		;MUST BE TRANSPARENT TO AC'S
	PUSH P,2
	PUSH P,1
	TLNE 1,17		;GIVEN MAP WORD, NOW IN CORE?
	JRST DECRR		;NO, NOTHING TO DO
	MOVE 3,CST0(1)
	TLNN 3,(70B5)		;PAGE IN USE?
	JRST DECRR		;NO
	HLRZ 2,CST3(1)		;GET PROCESS ASSIGNMENT
	ANDI 2,7777
	CAIL 2,NFKS		;ASSIGNED?
	JRST DECRR		;NO, NOTHING ELSE TO DO
	PUSH P,1
	CALL SOSWSP		;REDUCE N FOR THIS PROCESS
	POP P,1
	MOVSI 2,7777
	IORM 2,CST3(1)		;MAKE PAGE UNASSIGNED
	AOS CGFLG		;PAGE IS NOW GARBAGE
DECRR:	POP P,1
	POP P,2
	POP P,3
	RET

;GARBAGE COLLECT CORE, REMOVE PAGES OF PROCESSES NOT IN BAL SET

GCCOR:	MOVE 1,CGFLG
	MOVE 10,NRPLQ
	ADD 10,IOIP		;WRITES NOW IN PROGRESS
	CAML 10,NRPMIN		;REPLACABLE QUEUE BELOW MINIMUM?
	TLNE 1,-1		;OR ESSENTIAL GC REQUESTED?
	JRST GCCOR1		;YES
	SETZM CGFLG		;NO, IGNORE REQUEST
	RET

GCCOR1:	JSP 4,STIME		;TIME GCCOR ACTIVITY
	MOVN 1,BALSHC		;RESET COUNT OF PAGES RETAINED IN
	ADDM 1,SUMNR		;BALSET BECAUSE OF SHARING
	SETZB 11,BALSHC		;INIT WORD TO HOLD USE BITS OF BALSET
	MOVEI 5,BALSET		;PROCESSES
GCCOR3:	CAML 5,FBALS		;LOOKED AT ALL BALSET PROCESSES?
	JRST GCCOR2		;YES
	MOVE 1,0(5)
	TLNE 1,(1B2+1B3)	;VALID PROCESS NUMBER?
	AOJA 5,GCCOR3		;NO
	HRRZ 1,FKCNO(1)
	IOR 11,BITS(1)		;PROCESS IN BALSET
	AOJA 5,GCCOR3

GCCQ1:	AOS EXNR		;COUNT UNCOLLECTABLE PAGES
GCCQ:	HLRZ 2,CST3(6)		;GET FORK ASSIGNMENT
	ANDI 2,7777
	CAIGE 2,NFKS		;NONE?
	SKIPL FKPT(2)		;OR CURRENTLY EXISTENT FORK?
	JRST GCC1		;YES
	CALL SOSWSP
	MOVSI 1,7777		;PAGE ASSIGNED TO DELETED FORK
	IORM 1,CST3(6)		;REMOVE ASSIGNMENT
	JRST GCC1

;DECREMENT WSP AND RELEASE CORE NUMBER IF WSP 0

SOSWSP:	SOS 1,FKWSP(2)
	TRNE 1,777777		;WSP NOW 0?
	RET			;NO
	HLRZ 1,FKPT(2)
	CAIE 1,GOLST		;PROCESS STILL ACTIVE?
	CAIGE 1,NBP
	RET			;YES, DON'T RELEASE NUMBER
	HRRZ 1,FKCNO(2)
	JUMPE 1,R		;NO NUMBER (?)
	HLLZS FKCNO(2)
	MOVE 1,BITS(1)
	IORM 1,FRECB
	RET

GCCOR2:	ANDCAM 11,PUBCL		;FOR PROCESSES WHICH CAME BACK IN BALSET
	SETZM EXNR		;INIT COUNT OF UNCOLLECTABLE PAGES
	MOVE 6,SWPCOR		;START AFTER RES MON
	SETZ 5,			;BITS FOR PROCESSES
GCC2:	MOVE 1,CST0(6)		;GET STATUS
	TLNN 1,700000		;IN USE?
	JRST GCC1		;NO
	JUMPE 10,GCCS		;GET AT LEAST 1 PAGE IF NONE NOW AVAIL
	HLRZ 2,CST3(6)		;GET PROCESS ASSIGNMENT
	ANDI 2,7777
	CAIL 2,NFKS		;PAGE NOW ASSIGNED?
	JRST GCCS		;NO, COLLECT IT
	MOVE 1,PUBCL		;PROCESS BITS TO BE CLEARED
	ANDCAB 1,CST0(6)
	SKIPGE 3,FKPT(2)	;FORK HAS BEEN DELETED?
	JRST GCCS		;YES, COLLECT
	HLRZ 3,3		;CURRENT LOCATON
	CAIE 3,WTLST		;ON WAIT LIST, OR
	TDNN 1,11		;NO USERS IN BALSET?
	JRST GCCS		;YES, COLLECT
	CAIL 3,NBP		;OWNER IN BALSET?
	JRST GCCOR4		;NO
	HRRZ 3,FKPT(2)
	MOVSI 1,(1B3)
	TDNE 1,BALSET(3)	;OWNER LEAVING BALSET?
GCCOR4:	AOS BALSHC		;YES, COUNT PAGE AS ONE IN BALSET BUT
	JRST GCC1		;NOT ASSIGNED TO BALSET PROCESS

GCCS:	MOVE 2,CST1(6)		;BACKUP ADDRESS
	SKIPGE DRUMP		;DRUM ON SYSTEM?
	TLNE 2,16		;NO, IS NO BACKUP ADR, OR
	TLNE 2,-PLKV		;PAGE LOCKED?
	JRST GCCQ1		;YES, LEAVE IT
	MOVSI 2,DWRBIT
	TDNE 2,CST3(6)		;PAGE BEING WRITTEN?
	JRST GCCQ		;YES, LEAVE IT
	HLRZ 2,CST3(6)		;GET PROCESS ASSIGNMENT
	ANDI 2,7777
	CAIGE 2,NFKS		;ASSIGNED?
	CALL SOSWSP
	MOVEI 1,0(6)		;SWAPOUT
	PUSH P,5
	CALL SWPOUT
	AOJ 10,			;COUNT PAGES COLLECTED
	POP P,5
GCC1:	CAIGE 6,MAXCOR-1
	AOJA 6,GCC2
	MOVE 1,BALSHC
	ADDM 1,SUMNR		;UPDATE TOTAL RESERVE FOR SHARED PAGES
	SETZM PUBCL
	SETZM CGFLG
	JSP 4,ETIME		;END TIMING OF GCCOR
	ADDM 1,SKDTM2		;CLOCK FOR GCCOR TIME
	RET

;INITIATE SWAP OF PAGE
;CALLED IN SCHEDULER FROM GCCOR

SWPOUT:	SKIPN 2,CST2(1)		;GET BACKUP
	JRST BKUPN		;PAGE HAS NO BACKUP, FLUSH IT
	TLNE 2,-1		;SPT?
	JRST SWPU1		;NO
	MOVE 3,SPT(2)
	TLNN 3,-1B31		;SHARE COUNT 0?
	JRST BKUPD		;YES, SWAP TO DISK
	CAIL 2,NOFN		;OFN?
	JRST BKUPS		;NO, SHARED PAGE. GO CHECK REQUEST BIT
BKUP0:	MOVE 2,CST1(1)		;CORE PAGE NUMBER IN 1, GET BACKUP ADR
	TLNE 2,16
	TLNE 2,10		;DISK OR NOTHING?
	JRST SWPO4		;YES
	MOVE 3,CST0(1)		;NO, DRUM.
	TLNE 3,CORWB		;PAGE WRITTEN INTO?
	JRST SWPO1		;YES
SWPOQ:	TLNE 3,77B23		;PAGE NOW ON REPLACABLE QUEUE?
	JSP 4,ONRQ		;NO, PUT IT THERE
SWPO3:	RET

SWPU1:	HLRZ 2,2		;GET PTN
	CAIGE 2,NOFN		;FILE?
	JRST BKUPD		;YES, SWAP TO DISK
BKUPS:	MOVE 2,CST3(1)
	TLNE 2,DSKSWB		;SWAP TO DISK REQUESTED?
	JRST BKUPDR		;YES
	JRST BKUP0		;PROCESS, SWAP TO DRUM

SWPO1:	CALL GDSTX
SWPO5:	MOVSI 3,BWRBIT		;SET BACKUP WRITTEN BIT
	IORM 3,DST(2)
SWPO2:	MOVSI 3,CORWB
	ANDCAM 3,CST0(1)	;CLEAR WRITTEN BIT
	MOVEI 3,4
	DPB 3,[POINT 6,CST0(1),5]	;SET TRAP CODE TO WRITE IN PROG.
	AOS IOIP		;NOTE WRITE IN PROGRESS
	HRLI 1,DWRBIT		;WRITE REQUEST BIT
	CALL DRMIO		;INITIATE DRUM WRITE
	AOS DRMWR		;COUNT DRUM WRITES FOR STATISTICS
	JRST SWPO3

SWPO4:	MOVSI 3,SWPERR
	TDNE 3,CST3(1)		;ERROR READING FROM DISK?
	JRST BKUPN		;YES, DON'T WRITE IT
	MOVE 3,DRMFRE
	CAMGE 3,DRMIN0		;DRUM NEARLY FULL?
	TLNN 2,10		;YES, SEND TO DISK IF HAVE DISK ADDRESS
	SKIPGE DRUMP		;SWAPPING POSSIBLE?
	JRST BKUPD		;NO, SEND PAGE TO DISK
	PUSH P,1
	SETZ 1,
	CALL DRMASN		;ASSIGN DRUM ADDRESS
	BUG(HLT,<DRUM COMPLETELY FULL>)
	MOVE 2,1
	POP P,1
	MOVE 4,CST1(1)		;GET PREVIOUS BACKUP ADDRESS
	MOVEM 2,CST1(1)		;SET DRUM AS NEW BACKUP ADDRESS
	CALL GDSTX
	MOVEM 4,DST(2)		;PREVIOUS BACKUP ADDRESS TO DST
	MOVE 3,CST0(1)
	TLNE 3,1B27		;PAGE WRITTEN WHILE IN CORE?
	JRST SWPO5		;YES, SET BACKUP WRITTEN BIT ALSO
	JRST SWPO2		;NO

;SWAP PAGE TO DISK

BKUPD:	MOVSI 2,DSKSWB
	ANDCAM 2,CST3(1)	;FLUSH REQUEST BIT IF ANY
BKUPDR:	MOVE 2,CST1(1)		;GET BACKUP ADDRESS
	TLNN 2,16		;NONE?
	JRST BKUP7		;YES
	TLNE 2,10		;DISK?
	JRST BKUP3		;YES
	SKIPN DISKP		;DISK ON SYSTEM?
	JRST BKUP0		;NO, SEND PAGE TO DRUM
	CALL GDSTX		;DRUM
	MOVE 3,DST(2)		;GET NEXT LEVEL BACKUP ADDRESS
	MOVSI 4,CORWB
	TLZE 3,BWRBIT		;WRITTEN SINCE BACKUP?
	IORM 4,CST0(1)		;YES, SET CORE WRITTEN BIT
	SETOM DST(2)		;RELEASE DST SLOT
	EXCH 3,CST1(1)
	PUSH P,1
	MOVE 1,3
	CALL DASDRM		;DEASSIGN DRUM ADDRESS
	POP P,1
	JRST BKUPDR

BKUP7:	SKIPG DISKP		;DISK ON SYSTEM?
	JRST BKUP0		;NO, SEND TO DRUM
	BUG(HLT,<BKUPD - BAD CST1 ENTRY OR INCONSISTENT CST>)

BKUP3:	MOVSI 3,CORWB		;CLEAR CHANGED IN CORE BIT
	MOVSI 2,SWPERR
	TDNN 2,CST3(1)		;DON'T WRITE IF ERROR FROM READ
	TDNN 3,CST0(1)		;CHANGED?
	JRST BKUPN		;NO, DON'T HAVE TO WRITE
	ANDCAM 3,CST0(1)
	HRLI 1,DWRBIT		;REQUEST WRITE
	AOS DSKWR		;COUNT IT FOR STATISTICS
	AOS IOIP		;NOTE WRITE IN PROGRESS
	MOVEI 3,4		;OTHERWISE INDICATE WRITE IN PROGRESS
	DPB 3,[POINT 6,CST0(1),5]
	CALL DSKIO
	JRST SWPO3

BKUPN:	MOVE 3,CST0(1)
	JRST SWPOQ		;GO PUT PAGE IN QUEUE

;PAGER TRAP

PGRTRP:	XWD TRAPPC,.+1
	SKIPN INSKED
	CONSZ PI,177B27		;FROM PI ROUTINE?
	BUG(HLT,<PAGER TRAP FROM SCHEDULER OR WHILE PI IN PROGRESS>)
	AOSLE NSKED
	AOSGE INTDF
	BUG(HLT,<PAGER TRAP WITH BAD NSKED OR INTDF>)
	AOSE TRAPC		;FIRST TRAP?
	JRST PGRT4		;NO, GO CHECK RECURSIVE OR ITERATIVE
	MOVEM P,TRAPAP		;SAVE AC-P
	MOVE P,TRAPSP		;SETUP TRAP STACK
	AOS UTRPCT		;COUNT TRAPS (BUT NOT RECURSIVE ONES)
	PUSH P,7		;SAVE AC'S 1-7
PGRT2:	MOVEI 7,1(P)		;ON STACK
	HRLI 7,1		;START WITH AC1
	ADD P,BHC+6
	JUMPGE P,MSTKOV		;STACK OVERFLOW?
	BLT 7,0(P)
	MOVE 1,TRAPPC		;RETURN
	PUSH P,1		;SAVE IT
	TLNE 1,UMODF		;FROM USER?
	MOVEM 1,UPDL		;YES, LEAVE IT WHERE IT CAN BE FOUND
PGRT3:	SKIPE TRAPC		;IF RECURSIVE TRAP,
	PUSH P,TRAPSW		;OLD STATUS WORD
	PUSH P,TRAPWD		;WRITE DATA
	MOVE 1,TRAPS0		;FROM WHERE PAGER STORED IT
	TLNE 1,(1B10+1B12)	;PI CYC OR NXM?
	BUG(HLT,<PAGER TRAP ON PI CYCLE OR NXM>)
	MOVEM 1,TRAPSW		;TO SAFE PLACE
	SKIPE TRAPC
	JRST .+3		;NESTED TRAP, DON'T COUNT TIME TWICE
	JSP 3,UCLOCK		;INIT CLOCK TO TIME TRAP CODE
	PUSH P,FKRT
	SETZM TRAPPC		;INDICATE TRAP STARTED
PGRTD:	HLLZ 1,TRAPSW		;GET TRAP STATUS
	TLNE 1,(1B9)		;PARITY ERROR?
	JRST PGRME		;YES
	SETZ 2,
	ROTC 1,2		;GET TOP 2 BITS
	MOVE 3,TABA(2)		;APPROPRIATE DISPATCH TABLE
	JFFO 1,.+2		;FIND TRAP-CAUSING BIT
	BUG(HLT,<PAGER TRAP WITH BAD OR MISSING TRAP STATUS WORD>)
	MOVE 7,FORKX		;GET FORK AND PROCESS NUMBER
	JRST 0(3)

PGRT4:	PUSH P,7		;TRAPSK ALREADY EXISTS
	HRRZ 7,TRAPPC		;CHECK TRAP PC FOR EITHER OF THE
	CAIE 7,PGMV1+1		;WRITE INSTRUCTIONS DONE TO
	CAIN 7,PGMV2+1		;FINISH UP A WRITE TRAP
	SOSA TRAPC		;TRAP IS ITERATIVE NOT RECURSIVE
	JRST PGRT2		;TRUE RECURSIVE TRAP
	SOS NSKED		;UNDO EFFECTS OF ENTERING TRAP CODE
	SOS INTDF
	POP P,7			;ADJUST VARIABLES AND REPROCESS TRAP
	JRST PGRT3

PGRME:	MOVE 2,[SIXBIT /PAGER/]
	MOVEM 2,DEVMPE		;REQUEST CORE SCAN
	ISB APRCHN
	BUG(CHK,<PARITY ERROR DETECTED BY PAGER>)
	JRST PGUNTP		;TRY AGAIN

;DISPATCH PROCEDURE FOR TRAP STATUS BITS

TABA:	EXP TRP0,TRP1,TRP2,TRP3

TRP1:	CAIL 2,7
	BUG(HLT,<PAGER TRAP WITH BAD TRAP STATUS WORD>)
	XCT TAB1(2)

TAB1:	BUG(HLT,<PAGER TRAP WITH BAD TRAP STATUS WORD>)
	JRST NIC		;SHARED NOT IN CORE
	JRST NIC		;PAGE TABLE NOT IN CORE
	JRST NIC		;2ND INDIRECT PRIV NOT IN CORE
	JRST NIC		;INDIRECT SHARED NOT IN CORE
	JRST NIC		;IND PT NIC
	JRST ILIND		;EXCESSIVE IND.

TRP2:
TRP3:	CAIL 2,7		;INDIRECT OR ORIGINAL PT EQUIVALENT
	BUG(HLT,<PAGER TRAP WITH BAD TRAP STATUS WORD>)
	XCT TAB2(2)

TAB2:	JRST NIC		;PRIVATE NOT IN CORE
	JRST WCPY		;WRITE COPY TRAP
	JRST UTRP		;USER TRAP
	JRST NPG		;ACCESS (OR BIT 10-11 = 3)
	JRST ILRD		;ILLEGAL READ OR XCT
	JRST ILWR		;ILLEGAL WRITE
	BUG(HLT,<PAGER TRAP ON ALR VIOLATION OR ILLEGAL FORMAT>)

;TRAP CODE 0, CST WORD BITS 0-2 = 0

TRP0:	CALL GETTPD		;DECODE EFFECTIVE ADDRESS
	TLNE 2,17		;PAGE MUST BE IN CORE
	BUG(HLT,<CST LESS THAN 100 PAGER TRAP BUT PAGE NOT IN CORE>)
	HLRZ 1,CST0(2)		;GET AGE CODE
	LSH 1,-^D12
	CAIL 1,10
	BUG(HLT,<CST LESS THAN 100 PAGER TRAP, CST0 INCONSISTENT>)
	CAIE 1,6		;READ IN PROGRESS OR READY?
	CAIN 1,2
	JRST TRP0R		;YES, SPECIAL RESHEDULE
	PUSH P,[PGUNTP]		;RETURN TO DE-TRAP ROUTINE
	PUSH P,2
	JRST AGESX

TRAPSP:	IOWD NTSK,TRAPSK	;POINTER TO LOCAL STACK

;ASSIGN PAGE AND SET AGE

AGESET:	MOVE 7,FORKX
AGESN:	PUSH P,2
	MOVEI 2,0(1)
AGES1:	HLRZ 1,CST0(2)
	LSH 1,-^D12
	CAIL 1,10		;NOW ASSIGNED?
	JRST [	HLRZ 1,CST3(2)	;YES, FIND OUT WHERE
		ANDI 1,7777
		CAML 2,SWPCOR	;NOT SWAPPABLE PAGE? OR
		CAIN 1,0(7)	;THIS PROCESS?
		JRST AGES2	;YES, OK
		CAIL 1,NFKS	;ANY PROCESS?
		JRST ATP1	;NO
		PUSH P,2
		MOVEI 2,0(1)
		CALL SOSWSP	;REDUCE WSP
		POP P,2
		JRST ATP1]	;GO ASSIGN TO THIS PROCESS
AGESX:	XCT TRP0T(1)
AGES2:	MOVEI 1,0(2)
	POP P,2
	RET

TRP0T:	JRST ATP0		;AVAILABLE AND ON REPLACABLE QUEUE
	JRST ATP1R		;AVAILABLE, NOT ON REPLACABLE QUEUE
	JRST ATP2		;READ COMPLETED
	BUG(HLT,<BAD AGE FIELD IN CST0>)
	JRST ATP4		;WRITE IN PROGRESS
	BUG(HLT,<BAD AGE FIELD IN CST0>)
	JRST ATP2		;READ IN PROGRESS
	BUG(HLT,<BAD AGE FIELD IN CST0>)

TRP0R:	MOVSI 1,0(2)
	HRRI 1,SWPRT
	JSYS SCHEDR
	NOSKED
	JRST NIC2

ATP1R:	MOVSI 1,SWPERR		;CHECK FOR ERROR ON READ
	TDNN 1,CST3(2)
	JRST ATP1		;NO ERROR
	PUSH P,2
	MOVEI 1,^D11		;FILE DATA ERROR PSI CHANNEL
	MOVEI 2,0(7)		;GET FORK NUMBER
	CALL PSIRQ		;INTERRUPT THE FORK
	RESKED
	POP P,2
	JRST ATP1

ATP2:	MOVSI 1,0(2)
	HRRI 1,SWPRT		;READ NOW IN PROGRESS OR COMPLETED
	JSYS SCHEDP		;RESCHEDULE UNTIL AVAILABLE
	JRST AGES1		;CHECK AGE AGAIN

ATP4:	MOVSI 1,(1B5)		;WRITE IN PROGRESS, CHANGE CODE SO AS TO
	EXCH 1,CST0(2)		;PREVENT COMPLETION ACTION
	TLNE 1,4B23		;IF WRITE STILL NOT COMPLETED,
	JRST [	SOS IOIP	;REDUCE WRITE IN PROGRESS COUNT
		JRST ATP1]	;GO ASSIGN PAGE
ATP0:	SOS NRPLQ		;ONE LESS PAGE ON REPLACABLE
	PIOFF
	MOVE 1,CST3(2)		;UNQUEUE PAGE FROM REPLACABLE
	HLLM 1,0(1)
	MOVS 1,1
	HLRM 1,0(1)
	PION
	SETZM CST3(2)
ATP1:	AOS 1,FKWSP(7)		;INCREASE OWNERSHIP COUNT
	PUSH P,2
	MOVEI 1,0(1)
	PUSH P,1
	HRRZ 2,FKPT(7)		;GET PROCESS NUMBER
	MOVSI 1,1B21
	TDNE 1,BALSET(2)	;HALF REMOVED PROCESS?
	JRST ATP1A		;YES
	MOVSI 1,1
	ADD 1,FKNR(7)		;INCREASE AGE
	TLNE 1,1000		;ABOVE MAX?
	HRLI 1,100		;YES, WRAPAROUND
	MOVEM 1,FKNR(7)
	MOVEI 1,0(1)		;GET CURRENT RESERVE VALUE
	CAML 1,0(P)		;LESS THAN CURRENT SIZE?
	JRST ATP1A		;NO, OK
	SUB 1,0(P)		;YES, CALCULATE DIFFERENCE
	MOVN 1,1
	ADDM 1,FKNR(7)		;INCREASE RESERVE
	ADDM 1,SUMNR
ATP1A:	SUB P,BHC+1		;FLUSH GARBAGE
	HLRZ 1,FKNR(7)		;GET UPDATED AGE
	POP P,2			;RESTORE PAGE NUMBER
	DPB 1,[POINT 9,CST0(2),8]	;NEW AGE OF PAGE
	DPB 1,[POINT 9,PGR72,8]	;FOR PAGER
	DPB 7,[POINT 12,CST3(2),17]	;ASSIGN PAGE TO PROCESS
	JRST AGES2

;ILLEGAL REFERENCE TRAPS

ILRD:	MOVEI 1,^D16		;MR TRAP CHANNEL
	MOVE 2,TRAPSW
	TLNE 1,2		;EXECUTE REFERENCE?
	MOVEI 1,^D18		;YES, MX
ILRF:	CALL PSIRQ0		;REQUEST INTERRUPT, THIS FORK
	RESKED
	MOVE 1,TRAPSW
	MOVEM 1,UTRSW		;IN CASE USER WANTS TRAP STATUS
	MOVE 2,-1(P)		;WRITE DATA (ASSUMING TOP-LEVEL TRAP)
	MOVEM 2,UTRWD
	MOVE 2,-2(P)		;PC
	TLNN 2,UMODF		;USER?
	SKIPGE INTDF		;OR INTERRUPTABLE?
	JRST .+3		;YES
	TLNE 1,12		;MUST DEFER INTERRUPT, READ REF?
	AOS -2(P)		;YES, DONOT RESTART INSTRUCTION
	TLO 1,12		;SET BITS TO PREVENT WRITE-COMPLETION
	MOVEM 1,TRAPSW		;ACTION ON UNTRAP
	JRST PGUNTP

ILWR:	MOVE 1,TRAPSW
	TLNE 1,1		;MON REF BELOW 400000?
	TRNE 1,400000
	SKIPA 1,[^D17]		;NO, INITIATE MW INTERRUPT
	BUG(HLT,<ATTEMPTED MODIFY REFERENCE TO PROTECTED MONITOR>)
	JRST ILRF

ILIND:	MOVE 1,TRAPSW		;SEE IF READ OR WRITE
	TLNE 1,12
	JRST ILRD		;GIVE READ TRAP INTERRUPT
	JRST ILWR		;OR WRITE TRAP INTERRUPT

UTRP:	MOVEI 3,TRAPUB
	CALL GETTD1		;FIND PAGE WITH TRAPUB SET
	HLRZ 6,1
	CAIGE 6,NOFN		;COULDN'T BE IN FILE XB
	BUG(HLT,<TRAP-TO-USER IN FILE INDEX BLOCK>)
	CALL SETSPG		;MAP PT HOLDING PTR
	MOVSI 2,TRAPUB
	ANDCAM 2,CSWPGA(1)	;CLEAR THE BIT
	CALL RELSPG
	MOVEI 1,^D21
	CALL PSIRQ0		;INTERRUPT ON CHN 21
	RESKED
	MOVE 1,TRAPSW
	MOVEM 1,UTRSW		;SAVE TRAP STATUS WORD ONLY
	JRST PGUNTP		;FINISH UP WRITE IF ANY AND UNTRAP

;PAGE NOT IN EXISTANCE TRAPS

NPG:	MOVE 1,TRAPSW
	TLNE 1,1		;MONITOR?
	JRST [	MOVEI 1,0(1)	;YES, LEGAL PAGE?
		CAIL 1,JSB
		CAIL 1,JSB+1000
		CAIA
		JRST MILRF1
		CAIL 1,PPMA
		CAIL 1,DDPG1A
		JRST NPG1	;YES
		JRST MILRF1]	;MONITOR MALFUNCTION
NPG1:	CALL GETTPD		;NEW PAGE NEEDED
	HLRZ 6,1		;GET PT NUMBER
	CAIGE 6,NOFN		;MUST BE PT, NOT OFN
	JRST NPG2
	CALL SETSPG		;MAP IT
	SKIPE 2,CSWPGA(1)	;BE SURE PT SLOT NOW EMPTY
	JRST NPGBAD		;IT'S NOT, PROBABLY SPURIOUS TRAP
	MOVSI 2,RWXB+1
	MOVEM 2,CSWPGA(1)	;SETUP NULL POINTER
	CALL RELSPG		;RELEASE MAP
	MOVE 1,PSICHM
	MOVE 2,TRAPSW
	TLNN 2,1		;USER MAP, AND
	TRNN 1,1B22		;CHANNEL 22 ON?
	JRST NIC		;NO
	MOVEI 1,^D22		;YES, REQUEST INTERRUPT
	CALL PSIRQ0
	RESKED
	MOVE 1,TRAPSW
	MOVEM 1,UTRSW
	JRST NIC

MILRF1:	BUG(HLT,<ILLEGAL ADDRESS REFERENCE IN MONITOR>)

NPGBAD:	TLNN 2,ACCESB		;ACCESS BIT ON?
	BUG(HLT,<BAD POINTER IN PAGE TABLE>)
	BUG(CHK,<PROBABLE SPURIOUS PAGER TRAP>)
	CALL RELSPG		;CLEAN UP
	JRST PGUNTP		;GO UNTRAP AND TRY AGAIN

;THIS COULD CONCEIVABLY HAPPEN ON AN IND PTR TO A FILE FROM WHICH
;THE PAGE WAS REMOVED

NPG2:	JRST ILIND		;CAN ONLY GIVE TRAP TO USER

;COPY-ON-WRITE TRAP

WCPY:	MOVE 1,TRAPSW
	TLNE 1,(1B4+1B6)	;OTHER TRAPS ALSO?
	JRST [	TLZ 1,(1B3)	;YES, CLEAR WRITE COPY
		MOVEM 1,TRAPSW	;FROM TRAP CAUSE
		JRST PGRTD]	;AND GO HANDLE THE OTHER CAUSE
	MOVEI 3,COPYB
	CALL GETTD1		;WILL STOP ON FIRST POINTER WITH COPYB
	HLRZ 6,1		;PTN
	CAIG 6,NOFN
	BUG(HLT,<COPY-WRITE POINTER IN INDEX BLOCK>)
	CALL SETSPG		;MAP THE PT
	MOVSI 2,RWX
	AND 2,CSWPGA(1)		;GET ACCESS OF SOURCE PAGE
	IOR 2,[XWD WRITEB+ACCESB+1,1] ;MAKE PRIV PTR WITH UNASS ADR
	EXCH 2,CSWPGA(1)	;EXCH IT WITH THE WC POINTER
	TLNN 2,SHRBIT+INDBIT	;IT SHOULD BE SHARED OR INDIRECT
	JRST WCPY4		;BUT IT'S NOT
	TLO 2,READB		;MAKE SURE WE CAN READ FROM THE PAGE
	MOVEM 2,PSB+CPYPG	;PUT THE ORIG POINTER IN MON MAP
	CALL RELSPG
	PUSH P,1		;SAVE ORIG PTN.PN
WCPY2:	MOVEI 1,CPYPG		;CONSTRUCT IDENT FOR COPY SOURCE PAGE
	HRL 1,FKPGS(7)
	CALL GETPGD		;TRACK IT DOWN
	TLNE 2,17		;IN CORE?
	JRST [	CALL SWPINP	;NO, SWAP IT IN
		JRST WCPY2]	;THEN LOOK AGAIN
	MOVEI 1,0(2)
	CALL AGESET		;FIX THE PAGE
	MOVSI 3,PLKV
	ADDM 3,CST1(1)		;AND LOCK IT DURING NEXT SWAPIN
	EXCH 1,0(P)		;SAVE CORE PN, GET ORIG PTN.PN
	CALL SWPINP		;THIS WILL COPY FROM CPYPG TO A NEW PAGE
	POP P,1
	MOVSI 3,-PLKV
	ADDM 3,CST1(1)		;UNLOCK THE SOURCE PAGE
	MOVEI 1,CPYPG
	HRL 1,FKPGS(7)
	CALL MRPT		;GET IDENT OF SHARE PAGE BEING RELEASED
	SETZ 1,			;INDIRECT TO FORK
	PUSH P,1
	MOVEI 1,CPYPG
	HRL 1,FKPGS(7)
	CALL RELMPG		;RELEASE THE ORIG PAGE FROM MON MAP
	CALL RELCPT		;CLEANUP FROM RELMPG
	OKSKED
	POP P,1
	JUMPE 1,WCPY3		;IGNORE INDIRECT TO FORK PTR
	MOVE 5,0
	MOVE 6,11		;SAVE AC'S USED BY OFNJFN
	CALL JFNDCR		;DECREMENT MAP COUNT FOR JFN
	MOVE 0,5
	MOVE 11,6		;RESTORE AC'S
WCPY3:	NOSKED
	JRST NIC		;UPDATE STATS AND CONTINUE

WCPY4:	TLZ 2,COPYB		;MAKE IT LOOK LIKE WE COPIED IT
	TLO 2,WRITEB
	MOVEM 2,CSWPGA(1)
	CALL RELSPG
	JRST NIC2

;NOT IN CORE TRAP

NIC:	JSP 3,UCLOCK		;UPDATE CLOCKS
	HLRZ 1,FKWSP(7)		;CURRENT TAV OF PROCESS
	HRRZ 3,FKWSP(7)		;CURRENT N OF PROCESS
	IMULI 1,0(3)		;COMPUTE (TAV*(N-1) + T)/N
	ADD 1,PGTIM
	SETZM PGTIM
	IDIVI 1,1(3)
	HRLM 1,FKWSP(7)		;BECOMES NEW TAV
	CAMLE 1,PTAV		;IF PROCESS'S TAV IS .G. THE PARAMETER,
	JRST NIC3		;IMPLIES CURRENT W.S. EST TOO LARGE
NIC3A:	HRRZ 1,FKNR(7)		;CURRENT RESERVE
	HRRZ 3,FKWSP(7)		;PAGES NOW ASSIGNED
	CAIG 1,0(3)		;RESERVE SUFFICIENT FOR NEW PAGE?
	JRST NIC3C		;NO, ADJUST
	HLRZ 2,FKSTAT(7)	;CURRENT QUEUE
	CAIL 2,2		;ON HIGHER QUEUES? OR
	CAMGE 1,TOTRC2		;RESERVE NOW 'SMALL'?
	JRST NIC92		;YES, ALLOW NEW PAGE
	SKIPE NGOJOB		;FORKS WAITING FOR BAL SET?
	JRST NIC3		;YES, COLLECT
	MOVE 3,NBPROC
	CAIG 3,1		;OTHER FORKS IN BALSET NOW?
	JRST NIC92		;NO, PERMIT NEW PAGE
	ADD 3,SUMNR
	CAMGE 3,MAXNR		;BAL SET HAS ROOM FOR ANOTHER PAGE?
NIC92:	CAML 1,NPMAX		;WITHIN MAX SIZE FOR FORK?
	JRST NIC3		;NO, COLLECT
NIC2:	CALL GETTPD		;DECODE TRAP ADDRESS
	TLNE 2,17		;PAGE IN CORE?
	JRST NIC6		;NO
	MOVEI 1,0(2)		;YES
	CALL AGESET		;SET AGE
	JRST PGUNTP		;RESUME PROCESS

NIC6:	MOVE 3,NRPLQ
	CAMG 3,MINNRC		;PAGE AVAILABLE?
	JRST NIC7		;NO
NIC8:	CALL SWPINW		;SWAP IN THE PAGE
	JRST NIC2

PTAV:	EXP ^D66		;IDEAL TAV BETWEEN PAGE FAULTS

NIC7:	MOVE 3,NSKED
	CAILE 3,1		;RESHEDULABLE PROCESS?
	JRST NIC8		;NO, START SWAP
	OKSKED
	AOS CGFLG		;REQUEST GC
	MOVEI 1,NIC7T
	JSYS SCHEDP		;WAIT FOR ROOM
	NOSKED
	JRST NIC2		;TRY AGAIN

NIC7T:	HRRZ 2,FKPT(7)		;BALSET NUMBER
	MOVSI 1,1B21
	TDNE 1,BALSET(2)	;PROCESS TO BE REMOVED?
	JRST 1(4)		;YES,LET IT HAPPED
	MOVE 1,NRPLQ
	CAMG 1,MINNRC		;ROOM NOW?
	JRST 0(4)		;NO
	JRST 1(4)

NIC3:	HRRZS 3,FKWSP(7)	;SET TAV TO 0
	HRRZ 1,FKNR(7)		;RESERVE
	CAIE 3,-1(1)		;USED ALL OF RESERVE?
	JRST NIC3C		;NO, ADJUST FIRST
	MOVEI 1,0(3)		;COMPUTE CUTOFF DIFFERENCE AS
	ASH 1,-3		;1/8 CURRENT SIZE
	PUSH P,3		;SAVE SIZE NOW
	CALL XGC		;COLLECT PAGES
	POP P,3			;SIZE BEFORE COLLECTION
	HRRZ 1,FKWSP(7)		;SIZE NOW
	CAIL 1,0(3)		;LESS THAN BEFORE?
	JRST [	SETZ 1,		;NO, SET CUTOFF DIFFERENCE TO 0
		CALL XGC	;AND COLLECT AGAIN. SHOULD GET ALL
		JRST NIC3B]	;PAGES
NIC3B:	HRRZ 1,FKWSP(7)		;COMPUTE 1.25 (5/4) CURRENT SIZE
	IMULI 1,5
	ASH 1,-2
	HRRZ 3,FKNR(7)		;ADJUST RESERVE
	SUB 1,3
	ADDM 1,SUMNR
	ADDM 1,FKNR(7)
	JRST NIC3A

NIC3C:	SUBI 3,-1(1)		;SET RESERVE TO BE CURRENT SIZE +1
	ADDM 3,SUMNR
	ADDM 3,FKNR(7)
	JRST NIC3A

;COLLECT OLD PAGES FOR THIS PROCESS, CALLED WITH CUTOFF DIFFERENCE IN 1
;THE PAGES ASSIGNED TO THIS PROCESS ARE ASSUMED TO HAVE AGES RANGING
;FROM M1 TO M2.  M2 IS THE CURRENT AGE, LH OF FKNR. WE WISH TO
;FLUSH ALL PAGES OLDER THAN M, WHERE M1<M<M2.  IF EACH PAGE     >>
;HAS BEN REFERENCED ONLY ONCE, THE AGES WOULD BE EVENLY DISTRIBUTED
;BETWEEN M1 AND M2.  HOWEVER, PAGES ACTIVELY BEING USED SHOULD
;HAVE AGES CLOSER TO M2.  THEREFORE, WE PICK A CUTOFF AGE BY
;SUBTRACTING A SMALL NUMBER FROM M2.  TO PREVENT EXCESSIVE COLLECTION
;WHERE ALL PAGES HAVE BEEN REFERENCED RECENTLY, WE SET A LIMIT
;ON THE TOTAL NUMBER OF PAGES WHICH CAN BE FLUSHED, AND STOP
;IF WE HIT THIS LIMIT. ALSO, SINCE AGES CAN WRAP AROUND THE 9-BIT
;FIELD, AGES GREATER THAN M2 ARE ASSUMED TO BE LEFT FROM THE PREVIOUS
;WRAP AROUND AND ARE ADJUSTED ACCORDINGLY.

XGC:	HRRZ 4,FKCNO(7)
	PUSH P,BITS(4)		;PROCESS USE BIT FOR THIS PROCESS
	MOVE 6,SWPCOR		;FIRST SWAPPING PAGE
	HRRZ 4,FKWSP(7)		;NUMBER PAGES NOW IN CORE
	ASH 4,-1		;COMPUTE 1/2 CURRENT SIZE
	PUSH P,4		;MAX NUMBER OF PAGES TO COLLECT
	HLRZ 3,FKNR(7)		;CURRENT AGE CLOCK
	PUSH P,3
	SUBI 3,0(1)		;CUTOFF AGE, 'OLD'=NOW-DIFFERENCE
	PUSH P,3
XGC2:	HLRZ 1,CST0(6)
	TRNN 1,700000		;PAGE IN USE?
	JRST XGC1		;NO
	HLRZ 2,CST3(6)
	ANDI 2,7777
	CAIE 2,0(7)		;ASSIGNED TO THIS PROCESS?
	JRST XGC1		;NO
	LSH 1,-^D9		;YES, GET AGE FIELD
	MOVE 2,-3(P)		;PROCESS USE BIT
	ANDCA 2,CST0(6)		;LOOK AT OTHER PROCESS USE BITS
	TDNE 2,[377777777]	;IF ANY ON, MEANS REFERENCES BY OTHER
	HLRZ 1,FKNR(7)		;PROCESSES, AGE INVALID SO USE CURRENT
	CAMLE 1,-1(P)		;IF .G. NOW, MUST NOT HAVE WRAPPED
	SUBI 1,1000-100		;SO WRAP IT
	CAMLE 1,0(P)		;.G. OLD?
	JRST XGC1		;YES, SAVE IT
	MOVE 2,CST1(6)
	SKIPGE DRUMP		;DON'T SWAP PAGE IF NO DRUM AND
	TLNE 2,16		;NO BACKUP ADDRESS FOR PAGE
	TLNE 2,-PLKV		;DON'T SWAP PAGE IF LOCKED
	JRST XGC1
	MOVSI 2,DWRBIT
	TDNE 2,CST3(6)		;DON'T SWAP PAGE IF NOW BEING WRITTEN
	JRST XGC1
	SOS FKWSP(7)		;DEASSIGN PAGE FROM THIS PROCESS
	MOVEI 1,0(6)
	CALL SWPOUT		;SWAP IT OUT
	SOSG -2(P)		;COLLECTED ENOUGH PAGES?
	JRST XGC3		;YES
	OKSKED			;DON'T HOG MACHINE FOR TOO LONG
	NOSKED
XGC1:	CAIGE 6,MAXCOR-1	;LOOKED AT ALL CORE?
	AOJA 6,XGC2		;NO, LOOK AT NEXT PAGE
XGC3:	SUB P,BHC+4		;FLUSH STACK
	CONO PGR,0		;CLEAR AR'S
	RET

;RESUME PROCESS AFTER PAGER TRAP

PGUNTP:	SKIPE TRAPC		;OUTER LEVEL TRAP?
	JRST PGU4		;NO
	JSP 3,UCLOCK		;COMPLETE TIMING OF TRAP CODE
	POP P,1			;FKRT AT TIME OF ENTRY
	MOVE 2,FKRT
	SUB 2,1			;TIME OF TRAP CODE
	ADDM 2,PTTIM		;PAGE TRAP TIME FOR THIS FORK
	ADDM 2,SPTTIM		;PAGE TRAP TIME FOR SYSTEM
PGU4:	CONO PGR,0		;LOAD WITH NEW AGE
	POP P,2			;RECOVER WRITE DATA
	MOVE 3,TRAPSW		;GET TRAP BITS
	SKIPE TRAPC		;IF RECURSIVE TRAP,
	POP P,TRAPSW		;RESTORE OLD STATUS WORD
	TLNE 3,12		;READ OR XCT?
	JRST PGU1		;YES, RESTART INSTRUCTION
	TLNE 3,1		;USER OR MONITOR?
	JRST PGU2		;MONITOR
PGMV1:	UMOVEM 2,0(3)		;USER
PGU1:	POP P,1			;GET RETURN
	TLNN 1,UMODF		;TO USER?
	JRST PGU3		;NO, MONITOR
	MOVEM 1,FPC		;USER, CAN PUT RETURN IN FPC
	MOVSI 7,-5(P)		;RESTORE AC'S
	HRRI 7,1
	BLT 7,6
	MOVE 7,-6(P)
	MOVE P,TRAPAP		;USER MODE, SO MUST BE TOP LEVEL TRAP
	SETOM TRAPC
	SETOM INTDF		;FOR USER, MUST BE -1
	OKSKED
	XCT MJRSTF		;RETURN, WILL GET DEFERRED INTERRUPT TOO

PGMV2:
PGU2:	MOVEM 2,0(3)		;STORE MONITOR WRITE DATA
	JRST PGU1

PGU3:	AOS INSKED		;ENTER SCHEDULER FLAG
	SOS NSKED		;LIKE OKSKED
	MOVEM 1,PPC		;SETUP TO RETURN THROUGH SCHEDULER
	MOVSI 7,-5(P)		;RESTORE AC'S
	HRRI 7,1
	BLT 7,6
	SUB P,BHC+6
	POP P,7
	SOSGE TRAPC		;TOP LEVEL TRAP?
	MOVE P,TRAPAP		;RESTORE AC-P
	SOS INTDF		;REDUCE NO-PSI COUNT
	JRST RSKD1		;EXIT THROUGH SCHEDULER

;GET PAGE DATA
;TRACES PTN.PN IN 1 TO NOT IN CORE OR CORE PAGE NUMBER OR WRITE COPY
;RETURN AS GETTPD

GETPGD:	HLRZ 2,1		;PTN TO 2
	MOVEI 1,0(1)		;PN TO 1
	SETZ 3,			;NO SPECIAL BITS TO STOP ON
	JRST GETPD1		;FOLLOW LIKE IND POINTER

;GET TRAP DATA
;RETURNS OFN.PN OR 0.SPTN IN 1
; MAP WORD IN 2

GETTPD:	SETZ 3,			;NO SPECIAL BITS TO STOP ON
GETTD1:	HRRZ 1,TRAPSW		;TRAP EFFECTIVE ADDRESS
	LSH 1,-^D9		;PAGE NUMBER
	HLRZ 2,TRAPSW		;TRAP BITS
	TRNE 2,1		;USER OR MONITOR?
	JRST NIC4		;MONITOR
	HLL 1,FKPGS(7)		;USER, GET PAGE TABLE SPTN
	MOVE 2,UPTA(1)
NICI2:	TLNE 2,0(3)		;REQUESTED BIT ON?
	RET			;YES, STOP HERE
	TLNE 2,INDBIT		;INDIRECT POINTER?
	JRST NICI		;YES
	TLNN 2,SHRBIT		;SHARE POINTER?
	RET			;NO, PRIVATE
	LSH 2,-^D9		;YES, SHIFT TO B35
	ANDI 2,SPTM		;FLUSH BITS
NICI1:	MOVEI 1,0(2)
	MOVE 2,SPT(1)
	RET

NICI:	SETZ 1,			;INDIRECT POINTER.
	ROTC 1,-^D9		;GET OFN TO 2, PN TO 1
	ROT 1,^D9
	ANDI 2,SPTM
GETPD1:	MOVE 6,SPT(2)		;GET PAGE TABLE ADDRESS
	TLNE 6,17		;IN CORE?
	JRST NICI1		;NO, THAT'S THE TROUBLE.
	HRLI 1,0(2)		;YES, PUT OFN IN 1
	MOVEI 6,0(2)
	CALL SETSPG		;MAP PT
	MOVE 2,CSWPGA(1)	;GET MAP WORD
	CALL RELSPG		;CLEAR TEMPORARY MAP WORD
	JRST NICI2		;GO ANALYZE THIS POINTER

NIC4:	CAIL 1,PJMPG		;MONITOR MAP, WHICH ONE?
	JRST NIC4A		;IN PSB
	CAIL 1,PPRMPG+NRSPG
	JRST NIC4B		;IN RES MON
	BUG(HLT,<PAGE FAULT ON RESIDENT MONITOR ADDRESS>)

NIC4A:	HRL 1,FKPGS(7)		;PSB
	MOVE 2,PSB(1)
	JRST NICI2

NIC4B:	HRL 1,MMSPTN		;PERMANENT SWP MON OFN
	MOVE 2,MMAP(1)
	JRST NICI2

;SWAP IN PAGE TABLE OR PSB
;CALLED FROM SCHED

SWPIN0:	TLNE 1,-1		;SPTN?
	JRST SWP01		;NO
	MOVE 3,SPT(1)		;YES, GET CURRENT ADDRESS
	TLNE 3,17		;OUT OF CORE?
	JRST SWP01		;YES
	LDB 2,[POINT 6,CST0(3),5] ;AGE CODE
	CAIE 2,2		;BEING READ OR COMPLETED?
	CAIN 2,6
	JRST SWP03		;YES
	MOVEI 1,0(3)
	CALL AGESN		;GRAB PAGE OFF RPLQ
SWP03:	MOVSI 1,0(3)		;ALREADY IN CORE
	JRST SWP02

SWP01:	CALL SWPIN
	HLRZ 3,1
SWP02:	MOVSI 2,PLKV
	ADDM 2,CST1(3)		;LOCK PAGE
	RET

;SWAPIN AND WAIT AND STAY NOSKED

SWPINP:	NOSKED
	CALL SWPINW
	OKSKED
	RET

;SWAP IN AND WAIT FOR COMPLETION

SWPINW:	MOVE 7,FORKX
	MOVE 2,JOBNO
	HRRZ 2,JOBNAM(2)	;GET SUBSYSTEM INDEX
	AOS SPFLTS(2)		;COUNT SUBSYSTEM PAGE FAULTS
	AOS USWPCT		;COUNT SWAPS
	TLNE 1,-1		;PT?
	JRST SWPIW2		;YES
	CALL SWPIN		;SWAPIN AND WAIT FOR COMPLETION
SWPIW1:	HRRZ 4,FKWSP(7)
	CAILE 4,^D20
	MOVEI 4,^D20
	MOVN 4,4		;CHARGE SOMETHING FOR PAGE FAULT
	ADDM 4,RJQNT
	HRRI 1,SWPRT
	JSYS SCHEDR
	HLRZ 1,1		;RESTORE PAGE NO TO R.H.
	NOSKED
	RET

SWPIW2:	PUSH P,1		;SAVE ORIG REQUEST
	HLRZ 1,1		;GET PT
	MOVE 3,SPT(1)
	TLNE 3,17		;CORE?
	JRST SWPIW3		;NO
	MOVEI 1,0(3)
	CALL AGESET		;FIX PAGE
	MOVSI 3,PLKV
	ADDM 3,CST1(1)		;SO IT DOESN'T SNEAK AWAY
SWPIW4:	EXCH 1,0(P)		;SAVE CORE PAGE NUMBER, GET ORIG OFN.PN
	CALL SWPIN		;SWAP THE ORIG PAGE
	EXCH 1,0(P)		;GET PT CORE PAGE NUMBER
	MOVSI 3,-PLKV
	ADDM 3,CST1(1)		;UNLOCK IT
	POP P,1
	JRST SWPIW1

SWPIW3:	NOSKED
	CALL SWPIN		;SWAP IN THE PT
	OKSKED
	HLRZ 2,1
	MOVSI 3,PLKV
	ADDM 3,CST1(2)		;LOCK IT
	HRRI 1,SWPRT
	JSYS SCHEDP		;WAIT TO FINISH
	HLRZ 1,1
	CALL AGESET
	JRST SWPIW4		;NOW GO GET THE PAGE

;SWAP IN PAGE
;AC1/ OFN.PN OR 0.SPTN
;RETURNS AC1/ CORE PAGE NO IN LH

SWPIN:	MOVE 3,NRPLQ		;NUMBER OF REPLACABLE PAGES
	CAIGE 3,6		;RUNNING LOW?
	AOS CGFLG		;YES, REQUEST GC
	JUMPE 3,SWPQT		;GO WAIT IF NONE
SWPIL1:	SOS NRPLQ
	HRRZ 3,RPLQ		;YES, REMOVE FROM QUEUE
	SUBI 3,CST3
	PIOFF
	MOVE 4,CST3(3)
	HLLM 4,0(4)
	MOVS 4,4
	HLRM 4,0(4)
	PION
	SETZM CST3(3)
	CALL DEPG		;RESET PREVIOUS OWNERSHIP
	TLNE 1,-1		;NEW PAGE FROM PT OR SPT?
	JRST SWPI3		;PT
	MOVE 4,SPT(1)		;SPT, GET ADDRESS
	TLNN 4,17
	BUG(HLT,<SWPIN - SPT PAGE ALREADY IN CORE>)
	DPB 3,[POINT 22,SPT(1),35]	;STORE NEW (CORE) ADDRESS
SWPI4:	TLZ 4,-1B31		;FLUSH BITS
	MOVEM 4,CST1(3)		;STORE BACKUP ADDRESS
	MOVEM 1,CST2(3)		;STORE LOCATION OF OWNING PT
	TLNE 4,16		;BACKUP ADDRESS ASSIGNED?
	JRST SWPI5		;YES, GO READ IN PAGE
	MOVSI 1,400000		;SET LEGAL AGE SO PAGER DOESN'T TRAP
	MOVEM 1,CST0(3)
	TLO 3,RWXB		;NO, ZERO OUT PAGE
	MOVEM 3,MMAP+CSWPG
	SETZM CSWPGA
	MOVEI 1,CSWPGA+1
	HRLI 1,-1(1)
	TRNE 4,1		;SPECIAL UNASSIGNED POINTER?
	MOVE 1,[XWD CPYPGA,CSWPGA] ;YES, COPY FROM CPYPG
	BLT 1,CSWPGA+777
	CALL RELSPG
	MOVSI 1,2B23		;SET STATUS OF PAGE TO READ COMPLETED
	MOVEM 1,CST0(3)
	MOVSI 1,0(3)		;RETURN PAGE NUMBER
	RET

SWPI3:	HLRZ 6,1		;GET OWNING PT OFN
	CALL SETSPG		;MAP PT
	MOVSI 4,PLKV
	ADDM 4,CST1(6)		;INCREMENT LOCK COUNT
	MOVE 4,CSWPGA(1)
	TLNN 4,17
	BUG(HLT,<SWPIN - PT PAGE ALREADY IN CORE>)
	DPB 3,[POINT 22,CSWPGA(1),35]	;STORE NEW (CORE) ADDRESS
	CALL RELSPG
	JRST SWPI4

SWPQT:	PUSH P,1		;SAVE REQUESTED PAGE IDENT
	AOS CGFLG		;BE SURE TO GC
	MOVEI 1,SWPWTT		;RESCHEDULE UNTIL NRPLQ NON-0
	JSYS SCHEDP
	POP P,1
	JRST SWPIN

SWPWTT:	SKIPLE NRPLQ
	JRST 1(4)
	JRST 0(4)

SWPI5:	MOVEI 1,0(3)
	MOVE 2,CST2(1)		;FIGURE OUT IF PAGE IS MAYBE A PT
	TLNE 2,-1		;IN SPT?
	JRST SWPI6		;NO, COULDN'T BE PAGE TABLE
	CAIL 2,NOFN		;PAGE IS PAGE TABLE IF IT IS FILE XB,
	SKIPN SPTH(2)		;OR IF IT IS SHARED BUT DOES NOT
	JRST .+2		;BELONG TO ANY PT OR XB
	JRST SWPI6
	MOVEI 2,0(1)		;BEFORE INITIATING SWAP OF PT,
	TLO 2,RWXB		;FILL THE ENTIRE CORE PAGE WITH
	MOVEM 2,MMAP+CSWPG	;PTRS WHICH WILL CAUSE THE PAGER TO
	MOVSI 2,400000		;TRAP IN A SAFE WAY SHOULD IT HAPPEN
	MOVEM 2,CST0(1)		;TO INTERPRET AN INDIRECT PTR WHICH
	MOVE 2,[XWD CSWPGA,CSWPGA+1] ;GOES THROUGH THIS PT BEFORE
	MOVSI 3,RWXB+1		;THE READ IS COMPLETED. THIS IS DONE
	MOVEM 3,-1(2)		;BECAUSE THE PAGER DOES NOT CHECK
	BLT 2,CSWPGA+777	;CST0 WHEN READING A PTR FROM AN IND
	CALL RELSPG		;PT AND SO DOESN'T NOTICE IF THE PAGE
SWPI6:	MOVSI 2,6B23		;IS BEING SWAPPED IN.
	MOVEM 2,CST0(1)		;PUT READ-IN-PROGRESS CODE IN CST0
	TLNE 4,10		;DISK?
	JRST SWPIK		;YES
	TLNE 4,14		;DRUM?
	BUG(HLT,<SWPIN - ILLEGAL SWAP ADDRESS>)
	CALL DRMIO		;YES, INITIATE READ
	AOS DRMRD		;COUNT DRUM READS FOR STATISTICS
SWPIR:	MOVSI 1,0(1)
	RET

SWPIK:	CALL DSKIO		;INITIATE DISK READ
	AOS DSKRD		;COUNT DISK READS FOR STATISTICS
	JRST SWPIR

DEPG:	MOVE 4,CST2(3)		;GET LOCATION OF PT OWNING OLD CONTENTS
	JUMPE 4,R		;0 => WAS NONE
	MOVE 5,CST1(3)		;GET BACKUP ADDRESS
	TLNE 4,-1		;PT OR SPT
	JRST SWPI1		;PT
	DPB 5,[POINT 22,SPT(4),35]	;SPT, RESTORE BACKUP ADDRESS
	MOVSI 6,-1B31
	CAIGE 4,NOFN		;FILE XB?
	TDNE 6,SPT(4)		;WITH SHARE COUNT NOW 0?
	RET			;NO
	SETOM SPTH(4)		;DELETE OFN
	SOS NOF
	RET

SWPI1:	HLRZ 6,4
	CALL SETSPG		;MAP PT
	MOVSI 2,-PLKV
	ADDB 2,CST1(6)		;DECREMENT LOCK COUNT
	TLNN 2,-PLKV		;COUNT NOW 0?
	AOS CGFLG		;YES, INDICATE POSSIBLE GARBAGE
	DPB 5,[POINT 22,CSWPGA(4),35]	;STORE BACKUP ADDRESS
	CALL RELSPG		;RELEASE TEMPORARY MAP WORD
	RET

SETSPG:	PUSH P,1
	MOVE 1,SPT(6)		;GET ADDRESS
	TDNE 1,[XWD 17,-MAXCOR]
	BUG(HLT,<SWPIN - PAGE TABLE NOT IN CORE>)
	CALL AGESN		;SET AGE
	LSH 6,^D9		;MAKE SHARE POINTER FROM OFN IN 6
	TLO 6,RWXB-XCTB+SHRBIT
	MOVEM 6,MMAP+CSWPG	;PUT IN PAGE RESERVED FOR SWAPPER
	MOVEI 6,0(1)		;RETURN CORE ADR
	POP P,1
	RET

RELSPG:	SETZM MMAP+CSWPG	;CLEAR MAP WORD
	MONCLR			;CLEAR MON AR'S
	RET

;ZERO CORE PAGE GIVEN IN 1

SWPZPG:	MOVEI 2,0(1)
	TLO 2,RWXB		;CONSTRUCT PRIVATE POINTER TO PAGE
	MOVEM 2,MMAP+CSWPG	;PUT IN MON MAP
	MOVSI 3,400000		;GET LEGAL AGE
	EXCH 3,CST0(1)		;SAVE OLD AGE
	MOVE 2,[XWD CSWPGA,CSWPGA+1]
	SETZM -1(2)
	BLT 2,CSWPGA+777	;ZERO THE PAGE
	TLO 3,CORWB		;NOTE PAGE WRITTEN INTO
	MOVEM 3,CST0(1)		;RESTORE AGE
	JRST RELSPG		;CLEAR PAGE FROM MMAP AND RETURN

;SCHEDULER TEST FOR PSB AND PT READ COMPLETED

SWPINT:	MOVE 3,4		;SAVE RETURN
	HRRZ 1,FKPGS(7)		;PSB
	MOVE 1,SPT(1)		;ASSIGNED PAGE
	JSP 4,SWPRT		;DONE?
	JRST 0(3)		;NO, RETURN NOT RUNNABLE
	SKIPN INDFLG		;LOCKING PSB'S?
	JRST SWPIT1		;NO
	HRRZ 1,FKJOB(7)		;YES, GET SPT
	MOVE 1,SPT(1)		;CORE ADDRESS
	JSP 4,SWPRT		;CHECK IT
	JRST 0(3)		;NOT READY
SWPIT1:	HLRZ 1,FKPGS(7)		;PT
	MOVE 1,SPT(1)
	JSP 4,SWPRT		;PT READY?
	JRST 0(3)		;NO
	SOS NEBAL		;ALL PAGES READY, PROCESS NOW ENTERED
	JRST 1(3)

;SCHEDULER TEST FOR READ COMPLETED

SWPRT:	MOVE 2,CST0(1)		;GET TRAP CODE
	TLNE 2,70B23		;PAGED GRABBED BY OTHER PROCESS?
	JRST 1(4)		;YES, OK TO RUN
SWPT1:	TLNN 2,2B23		;NO, READ OPERATION?
	JRST 1(4)		;NO, OK
	TLNE 2,4B23		;I/O STILL IN PROGRESS?
	JRST 0(4)		;YES, FAIL
	MOVSI 2,3B23		;YES, CHANGE CODE TO READY
	XORM 2,CST0(1)
	CALL AGESN		;ASSIGN PAGE
	JRST 1(4)		;RETURN OK

;WAIT FOR WRITE TO COMPLETE

SWPWT:	MOVE 2,CST0(1)		;JUST LIKE SWPRT, EXCEPT
	TLNE 2,70B23
	JRST 1(4)
	TLNE 2,4B23		;TEST I/O BIT FIRST
	JRST 0(4)
	JRST SWPT1

;SWAP COMPLETION ROUTINE, CALLED FROM DRUM AND DISK INTERRUPT CODE

SWPDON:	MOVSI 2,DWRBIT		;WRITE BIT
	TDNE 2,CST3(1)		;WAS WRITE?
	JRST SWPD1		;YES
	AOS PSKED		;INDICATE READ COMPLETED
	ISB SCDCHN
	MOVSI 2,4B23
SWPD2:	ANDCAM 2,CST0(1)	;CLEAR I/O IN PROGRESS
	JRST 0(4)

SWPD1:	ANDCAM 2,CST3(1)	;CLEAR WRITE BIT
	LDB 2,[POINT 6,CST0(1),5]	;GET TRAP CODE
	CAIE 2,4		;STILL SAYS WRITE?
	JRST [	SKIPE CST2(1)	;NO, PAGE USED AGAIN.  STILL EXISTS?
		JRST 0(4)	;YES
		JRST ONRQ]	;IT WAS DELETED, PUT ON RPLQ
	SOS IOIP		;WRITE NO LONGER IN PROGRESS
ONRQ:	MOVEI 2,CST3(1)		;YES, PUT ON REPLACABLE QUEUE
	PIOFF
	HLRZ 3,RPLQ
	HRL 3,0(3)
	HRRM 2,0(3)
	MOVSM 3,0(2)
	HRLM 2,RPLQ
	PION
	AOS NRPLQ
	MOVSI 2,77B23
	JRST SWPD2


;18 FEB 72, 1118:

	TITLE MON

;TENEX SCHEDULER - D. MURPHY

	EXTERN TTCH7,TTPSI,TADSEC,LSTERR,FACTSW,FLOGO
	EXTERN DIRLCK,DIRUSE,TCITST,TCOTST,TTEMES,FRZWT,CAPMSK,CAPENB
	EXTERN KSELF,LOGTOT,LOGDES
	EXTERN TTFORK,EXEC0
	EXTERN BHC,BITS,CH6TAB

	INTERN ITRAP,BLOCK1,DISGE,DISGET,DISL,RSKP,R,JRET,JSKP,NJOBS
	INTERN ASSFK,WTFPGS,WTSPT,SUSFKR,SUSWT,UCLOCK,ITRAP1
	INTERN STIME,ETIME,NSTAT,SETOVF,MAXQ,DISG,DISGT,BLOCKW
	INTERN SUPERP,PARALP,INFERP,PSILOB,TMZONE
	INTERN NNAMES
	INTERN FFF,P1,P2,INDFLG
	INTERN SCDIN
	INTERN ILIST
	INTERN .HALTF,EDISMS,HALTF1
	INTERN SCHEDP
	INTERN .DISMS
	INTERN SCHED0
	INTERN SCDRQ7
	INTERN JOBSRT
	INTERN HLTJB,HLTFK1,CLRM0,FRZB1,FRZB2,FRZBB
	INTERN PSIRQ0,PSIRQF,PSIRQB,CHNSON,PSIR4,FORCTM,PSIRQ
	INTERN TTPSRQ
	INTERN PSIT1A
	INTERN GETCHA
	INTERN .DEBRK

OAP=20			;DEVICE NUMBER FOR 'OTHER PROCESSOR' REALLY 1MS CLOCK

NBP==^D25		;MAX NUMBER PROCESSES IN BAL SET
MINPG==6		;MIN FREE PAGES TO CONSIDER ADDING PROCESS

NSKDP==40		;LOCAL PUSH LIST
NSCDRQ==20		;SIZE OF SCHEDULER REQUEST QUEUE

MAXQ==4			;HIGHEST QUEUE NUMBER

HQJOB==1B19		;IN JOBBIT - JOB SHOULD BE HI-Q ON DISMISS

MINNR==3		;MIN SIZE OF RPLQ FOR LOADING FORK


;STORAGE

LS SKDPDL,NSKDP		;SCHEDULER LOCAL PDL

LS MSCNT,1		;INDEX TO MSEC/TICK TABLE
LS APCLKC,1		;COMMUNICATION TO CH7 FROM CH1 CLOCK INTERRUPT
LS CLKAC2,1		;CLOCK ROUTINE TEMP
LS CLKAC1,1		;  "
LS SYNCC,1		;  "
LS OLDTCK,1		;  "
LS PISC7R,1
LS FKPT6M,1		;-FKPT(6)

GS FORKX,1		;INDEX OF CURRENTLY RUNNING FORK

GS FKPGS,NFKS		;PTB,,PSB   SPT NUMBERS
GS FKSTAT,NFKS		;FORK STATUS
GS FKWSP,NFKS		;WORKING SET PARAMETERS - TAV,,N
GS FKPGST,NFKS		;TEST WORD WHILE IN PAGE WAIT
GS FKOLDS,NFKS		;FORK STATUS PREVIOUS TO INTERRUPT
GS FKPT,NFKS		;LOCATION OF FORK,,FORK QUEUE POINTERS
GS FKINT,NFKS		;FORK INTERRUPT COMMUNICATION REG
GS FKINTB,NFKS		;INTERRUPT CHANNELS REQUEST
GS FKJOB,NFKS		;JOB NUMBER ,, JSB
GS FKNR,NFKS		;AGE,,BALANCE SET SIZE (RESERVE)
GS FKTIME,NFKS		;TIME AT WHICH FORK WAS PUT ON CURRENT QUEUE
GS FKCNO,NFKS		; -- ,, CORE NUMBER
LS FREFK,1		;LIST OF FREE FORKS
GS SYSIFG,1		;SYSTEM HAS BEEN INITIALIZED IF NOT 0
GS ENTFLG,1		;PERMIT NEW JOB ON ^C IF NON-0
GS PWRDWN,1		;POWER FAILURE DETECTED IF .G. 0, DONE IF .L. 0

GS JOBDIR,NJOBS		;ATTACHED DIRECTORY,,LOGIN DIRECTORY
GS JOBNAM,NJOBS		;JOB SUBSYSTEM NAME INDEX FOR SETNM
GS JOBRT,NJOBS		;JOB RUN TIME
GS JOBPT,NJOBS		;CONTROL TTY,,TOP FORK
LS FREJOB,1		;LIST OF FREE JOBS

LS WTLST,1		;WAITING FORK LIST
LS WTLSTL,1		; ... LAST

LS GOLST,1		;RUNNABLE FORK LIST
LS GOLSTL,1		; ... LAST

LS JB0FLG,1		;RUN JOB 0 REQUEST
LS FRECB,1		;FREE CORE NUMBER BITS

;BALANCE SET VARIABLES

LS BALSET,NBP		;BALANCE SET LIST **DO NOT REORDER BALSET, NBT**
LS NBT,NBP		;RUN TIME SINCE ENTERING BALSET
LS FBALS,1		;1 + HIGHEST BALSET SLOT IN USE
LS NBPROC,1		;NUMBER OF PROCESSES IN BAL SET
LS MAXBSQ,1		;Q OF WORST PROCESS IN BAL SET
LS MAXBP,1		;MAX NUMBER OF JOBS IN BAL SET

GS TOTRC,1		;TOTAL NUMBER REAL CORE PAGES
GS TOTRC2,1		;MAX SIZE OF PROCESS FOR SEVERAL JOBS RUNNABLE
GS SUMNR,1		;SUM OF RESERVE PAGES, ALL PROCESSES
GS BALSHC,1		;COUNT OF PAGES IN BALSET BECAUSE OF SHARING
GS PUBCL,1		;PROCESS USE BITS TO BE CLEARED AT GCCOR
LS EXNR,1		;UNCOLLECTABLE PAGES
GS MAXNR,1		;MAX VALUE OF SUMNR
LS MINNRC,1		;MIN SIZE OF RPLQ FOR ALLOWING SWAPIN OF PAGE
GS CGFLG,1		;DEASSIGNED PAGES MAY EXIST IF >0
LS NEBAL,1		;NUMBER OF PROCESSES NOW ENTERING BALSET
LS RUNT1,1		;RUNTIME SINCE FORK BEGAN EXECUTION

GS NRPMIN,1		;MIN VALUE OF NRPLQ FOR GCCOR
GS NRPLQ,1		;NUMBER OF PAGES ON REPLACABLE QUEUE
GS RPLQ,1		;REPLACABLE QUEUE    END,,BGN

GS NPMAX,1		;MAX NUMBER OF PAGES IN CORE FOR ONE PROCESS

;SCHEDULER VARIABLES

LS SKEDF1,1		;START PROCESS VIA CH7 BREAK IN 1
LS SKEDF2,1		;PROCESS BECAME RUNNABLE
LS INSKED,1		;IN SCHEDULER IF NON-ZERO
LS SSKED,1		;LAST JOB RUNNING WAS NOSKED

GS PSKED,1		;PAGE TRANSFER COMPLETED
GS ISKED,1		;SCHEDULE REQUEST FLAG

LS NGOJOB,1		;NUMBER OF RUNNABLE JOBS

LS BSCTIM,1		;TIME AT LAST CHANGE TO NBPROC
LS RJTTIM,1		;TIME AT LAST UPDATE TO RJTSUM
LS RJATIM,1		;TIME OF NEXT RJAV UPDATE
LS RJAVS1,1		;RJTSUM AT LAST RJAV UPDATE

;TABLES FOR SETNM

NNAMES==^D40		;NUMBER OF NAMES ALLOWED

GS SNAMES,NNAMES	;SIXBIT NAME OF SUBSYSTEM
GS STIMES,NNAMES	;ACCUMULATED RUNTIME OF SUBSYSTEM
GS SPFLTS,NNAMES	;ACCUMULATED PAGE FAULTS OF SUBSYSTEM
GS SWAKES,NNAMES	;WAKEUPS 0-14, SIZE INTEGRAL 15-35
GS SBLKTM,NNAMES	; BLOCKED FOR TTY TIME

;MONITOR STATISTICS

GS SKDTM0,1		;TIME SPENT IN SKED WITH NO RUNNABLE JOBS
GS SKDTM1,1		;TIME SPENT IN SKED WITH 1 OR MORE RUNNABLE JOBS
GS SKDTM2,1		;TIME SPENT IN GCCOR
GS SPTTIM,1		;TIME SPENT IN PAGER TRAP CODE

GS DRMRD,1		;NUMBER OF DRUM READS
GS DRMWR,1		;NUMBER OF DRUM WRITES
GS DSKRD,1		;NUMBER OF DISK READS
GS DSKWR,1		;NUMBER OF DISK WRITES

GS TTYBKS,1		;NUMBER OF TTY WAKEUPS
GS TTINTS,1		;NUMBER OF TERMINAL INTERRUPTS
GS BSTSUM,1		;INTEGRAL OF NBPROC DT
GS RJTSUM,1		;INTEGRAL OF NBPROC+NGOJOB DT

NRJAVS==3		;NUMBER OF EXPONENTIAL AVERAGES MAINTAINED
GS RJAV,NRJAVS		;EXPONENTIAL AVERAGE OF NUMBER RUNNABLE FORKS

NSTAT==14+NRJAVS		;NUMBER OF STATISTICS WORDS

GS QSUM,MAXQ+1		;ACCUMULATED TIME OF JOBS OF RESPECTIVE Q'S

;CLOCKS COUNTED DOWN AND TESTED, PARALLEL TO PCLKT, DON'T REORDER

LS RJQNT,1		;RUNNING JOB REMAINING QUANTUM
GS TTBTIM,1		;TIME TO NEXT TTY BIG BUFFER SERVICE
GS TIM2,1		;SECOND CLOCK, 100 MS

LS JOBRTT,1		;JOB RUNTIME SINCE LAST UPDATE

LS SCDRQI,1		;SCHEDULER REQUEST QUEUE
LS SCDRQO,1
LS SCDRQB,NSCDRQ

GS TODCLK,1		;MILLISECOND CLOCK, MONOTONICALLY INCREASING
GS CHKTIM,1		;ONE MINUTE PAST LAST JOB 0 CHECK

LS SCDRN1,1			;RUN ONLY FORK N IF N > -1

;PATCH SPACE FOR RES MON

SCDV1==1		;IF DEFINED MEANS ASSEMBLING MON
SCDVE==.-1		;UPPER LIMIT FOR CORE CLEAR ON STARTUP

FFF:
P1:
P2:	REPEAT 300,<0>

INDFLG:	0			; .NE. 0 MEANS LOCK JSB
				; .L. 0 MEANS USE NO INDIRECT PTRS

;SCHEDULER INITIALIZATION

SCDIN:	SETZM SYSIFG
	SETZM PWRDWN
	SETZM ENTFLG
	MOVE 1,[JRST SCDRQ0]
	MOVEM 1,SCDRQ+1		;DISPATCH FOR JSR-CALLED ROUTINE
	MOVEI 1,GOLST
	MOVEM 1,GOLSTL
	MOVEI 1,WTLST
	MOVEM 1,WTLSTL
	MOVNI 1,FKPT		;BECAUSE MACRO DOESN'T HAVE NEG RELOC'N
	HRLI 1,6
	MOVEM 1,FKPT6M		;-FKPT(6)
	MOVEI 1,SCDRQB
	MOVEM 1,SCDRQI
	MOVEM 1,SCDRQO
	MOVEI 1,FKPT
	MOVEI 2,NFKS
	CALL ILIST		;INIT FREE FORK LIST
	MOVEM 1,FREFK
	MOVEI 1,JOBPT
	MOVEI 2,NJOBS
	CALL ILIST
	MOVEM 1,FREJOB		;INIT FREE JOB LIST
	SETOM JOBRT
	MOVE 1,[XWD JOBRT,JOBRT+1]
	BLT 1,JOBRT+NJOBS-1
	SETZM 20
	SETOM SCDRN1
	SETOM FORKX
	SETOM TADSEC
	SETOM SSKED
	MOVE 1,[XWD 000377,777777] ;BITS IN PROCESS USE REG.
	MOVEM 1,FRECB
	MOVEI 1,BALSET
	MOVEM 1,FBALS
	MOVEM 1,INSKED
	SETOM FACTSW
	MOVSI 1,(1B1)
	MOVEM 1,CHKTIM		;PREVENT JOB 0 ALARM UNTIL INITIALIZED
	RET

ILIST:	ADDI 1,-1(2)
	SETZM 0(1)		;INIT FREE LIST, BLOCK ADR IN AC1,
	SOJLE 2,ILIST1		;  SIZE OF BLOCK IN 2
	MOVEM 1,-1(1)
	SUBI 1,1
	SOJG 2,.-2
ILIST1:	RET

;CHANNEL 7 INTERRUPT
;CLOCK, POSSIBLE RESCHEDULING, OR START PROCESS FROM SCHEDULER

PISC7:	XWD PISC7R,.+1

	SKIPG ISKED		;SCHEDULER REQUEST, OR
	SKIPE APCLKC		;CLOCK TICK?
	JRST APCLK		;SERVICE IT
APCLKX:	SKIPE SKEDF1		;INITIATED BY SCHEDULER?
	JRST SCDR		;YES, GO START PROCESS
	SKIPG INSKED		;IN SCHEDULER NOW, OR
	SKIPG ISKED		;NO SCHEDULING REQUESTS?
	JEN @PISC7R		;IGNORE INTERRUPT
	SKIPN TRAPPC		;PAGER TRAP STARTING?
	SKIPE NSKED		;OK TO RESCHEDULE?
	JRST SCDW		;NO, GO SET TRAPS
	MOVEM 17,PAC+17		;YES, SAVE PROCESS AC'S
	MOVEI 17,PAC
	BLT 17,PAC+16
	MOVE 1,40
	MOVEM 1,PSB40
	MOVE 1,PISC7R
	MOVEM 1,PPC
	AOS INSKED
	JEN @[SCHED0]

SCDW:	MOVEM 1,RSKED		;SAVE AC1
	MOVE 1,RSKEDT		;GET TRAP INSTRUCTION
	EXCH 1,RSKED		;LEAVE IT TO GET EXECUTED
	JEN @PISC7R

RSKEDN:	JFCL 0			;NO-TRAP CONTENTS OF RSKED
RSKEDT:	JSYS RSKD0		;TRAP CONTENTS OF RSKED

;SETUP AND RESUME PROCESS

SCDR:	SETZM SKEDF1		;CLEAR LOCAL FLAG
	SKIPE ISKED		;ANY REQUESTS LATELY?
	JEN @[SCHED0]		;YES, RESCHEDULE AGAIN
	SETZM INSKED		;NO LONGER IN SCHEDULER
	SETOM SSKED
	MOVE 1,PSB40
	MOVEM 1,40
	MOVSI 17,PAC		;RESTORE PROCESS AC'S
	BLT 17,17
	JEN @PPC		;RUN PROCESS

;VARIOUS WAYS OF ENTERING SCHEDULER

;JSYS HALTF - DISMISS FORK UNTIL INTERRUPT OR EXTERNALLY RESTARTED

.HALTF:	JSYS MENTR
HALTF1:	CALL FKTMI		;FORK TERM INTERRUPT
HALTX:	MOVEI 1,JRET
	JSYS EDISMS
	JRST MRETN		;IF CONTINUED

;EXEC DISMISS - AC1 CONTAINS  XWD DATA,TEST ROUTINE ADR

EDISMS:	XWD FPC,EDMSQ
EDMSQ:	JSYS ENSKED		;ENTER SCHEDULER
DISMS1:	MOVE 2,FPC		;USE JSYS RETURN AS PPC
	MOVEM 2,PPC
DISMSE:	SKIPN NSKED		;CHECK FOR BUGGY DISMISS
	TRNE 1,600000		;CHECK FOR NON-RES TEST
	BUG(HLT,<DISMISS WHILE NOSKED OR WITH NON-RES TEST ADDRESS>)
	PUSH P,1
	CALL SAVRT
	SETZM JOBCK0		;INIT MEASURING INTERVAL
	POP P,1
	EXCH 1,FKSTAT(7)	;SET NEW STATUS, GET OLD
	MOVE 2,JOBBIT
	TLNE 2,HQJOB		;HI-Q THIS JOB ON DISMISS?
	MOVE 1,QBASE+1		;YES
	MOVEM 1,FKOLDS(7)	;SAVE QUEUE VALUE
	CALL REMBSJ		;REMOVE JOB FROM BAL SET
	CALL WTCONC		;PUT ON WAIT LIST
	HRRZ 1,FKCNO(7)		;CORE NUMBER
	MOVE 1,BITS(1)		;PROCESS USE BIT
	IORM 1,PUBCL		;CLEAR BIT AT NEXT GC
	SETOB 7,FORKX
	JRST SCHED0

;RESCHEDULE ON PAGE WAIT

SCHEDP:	XWD SKDPC,.+1
	SKIPE INSKED
	BUG(HLT,<CALL TO SCHEDULER WHEN ALREADY IN SCHEDULER>)
	JSYS ENSKED
SCHP1:	PUSH P,1
	CALL SAVRT
	POP P,1
	MOVEM 1,FKPGST(7)
	MOVE 1,SKDPC
	MOVEM 1,PPC
	MOVSI 1,400000
	CALL SCHP2
	JRST SCHED0

SCHP2:	SKIPE NSKED
	MOVEM 7,SSKED		;REMEMBER FORK NUMBER OF NOSKED FORK
	HRRZ 10,FKPT(7)		;PROCESS NUMBER
	SKIPN NSWAP		;NON-SWAPPABLE?
	SKIPE NSKED		;NON-RESCHEDULABLE?
	TLO 1,200000		;YES
	HLLM 1,BALSET(10)	;WAITING FLAG
	HRRZS FKPT(7)
	SETOB 7,FORKX
	RET

;DO OKSKED AND RESCHEDULE

SCHEDR:	XWD SKDPC,.+1
	SKIPE INSKED
	BUG(HLT,<CALL TO SCHEDULER WHEN ALREADY IN SCHEDULER>)
	JSYS ENSKED
	SOSGE NSKED
	BUG(HLT,<OKSKED WHEN NOT NOSKED>)
	JRST SCHP1

;DEFERRED SCHEDULING REQUEST TRAP

RSKD0:	XWD SKDPC,.+1
	JSYS ENSKED		;ENTER SCHEDULER
	MOVE 1,SKDPC
RSKD2:	MOVEM 1,PPC
RSKD3:	MOVE 1,RSKEDN
	MOVEM 1,RSKED
	JRST SCHED0

RSKD1:	JSYS ENSKED		;FROM PGUNTP
	HRRZ 1,MJRSTF
	CAIN 1,FPC		;DEFERRED INTERRUPT WAITING?
	JRST RSKD3		;NO
	MOVEI 1,PSISV2		;YES
	EXCH 1,PPC		;SET TO CHECK IT NEXT RUNNING
	MOVEM 1,PIPC
	JRST RSKD3

;COMMON SCHEDULER ENTER ROUTINE, SAVE AC'S AND SET INSKED FLAG

ENSKED:	XWD ENSKR,.+1
	AOS INSKED		;PREVENT ACTION BY CH7 BREAK
	MOVEM 17,PAC+17		;SAVE PROCESS AC'S
	MOVEI 17,PAC
	BLT 17,PAC+16
	MOVE 7,40
	MOVEM 7,PSB40
	MOVE 7,FORKX		;GET INDEX OF CURRENT FORK
	MOVE P,PI7P		;GET PDL POINTER
	JRST @ENSKR

;INSTRUCTION TRAP - TRAP PC IN FPC, ASSUMED TO BE I +1

ITRAP1:	MOVEM 1,LSTERR		;SAVE ERROR CODE GIVEN IN 1
ITRAP:	SKIPE INSKED
	BUG(HLT,<INSTRUCTION TRAP WHILE IN SCHEDULER>)
	SKIPL FORKX		;NO FORK RUNNING, OR
	CONSZ PI,177B27		;PI IN PROGRESS?
	BUG(HLT,<INSTRUCTION TRAP WHILE PI IN PROGRESS OR IN SCHEDULER>)
	SKIPGE SLOWF		;NOW IN SLOW CODE?
	JSYS MENTR		;NO, ENTER
ITR3:	MOVE 1,MPP		;STACK PTR ON ENTERING THIS CONTEXT
	MOVE 2,0(1)		;RETURN PC
	TLNN 2,UMODF		;PREVIOUS CONTEXT INTERRUPTABLE?
	SKIPGE -2(1)		;I.E. USER MODE, OR INTDF .L. 0
	JRST ITR2		;YES, OK
	BUG(CHK,<INSTRUCTION TRAP AND PREVIOUS CONTEXT WAS NOINT>)
ITR2:	SETZM NSKED
	SETOM TRAPC		;CLEAR FLAGS AND COUNTERS
	SETZM INTDF		;SET TO 1 LEVEL NOINTERRUPT
	MOVEI 1,^D15		;INITIATE CHANNEL 15 INTERRUPT
	CALL PSIRQ0
	RESKED			;GET THE INTERRUPT "SEEN"
	OKINT			;INTERRUPT SHOULD TAKE HERE
	MOVE P,UPP		;RETURN TO USER IF CONTINUED
	ADD P,BHC+2
	JRST MRETN

;BLOCK UNTIL CONDITION SATISFIED

BLOCK1:	XWD SKDPC,.+1
	JSYS ENSKED
	MOVNI 1,^D100
	ADDM 1,RJQNT		;CHARGE Q TO PREVENT HOGGING
	MOVNI 1,2
	ADDM 1,SKDPC		;MAKE RETURN TO INSTRUCTION BEFORE CALL
	MOVE 1,TODCLK
	ANDI 1,377777
	ADDI 1,^D100		;ADD 100 MILLISECS
	MOVSI 1,0(1)
	HRRI 1,BLOCKW
	JRST SCHP1		;DISMISS, KEEP IN BAL SET

BLOCKW:	MOVE 2,TODCLK		;SCHEDULER TEST, GET TIME
	ANDI 2,377777
	SUB 1,2			;DESIRED - NOW = WAIT LEFT
BLK2:	JUMPLE 1,1(4)		;NO WAIT TIME LEFT
	CAIGE 1,200000		;BIG DIFFERENCE?
	JRST 0(4)		;NO, KEEP WAITING
	SUBI 1,400000		;YES, COMPENSATE FOR WRAPAROUND
	JRST BLK2

;DISMISS UNTIL WORD .GE. 0

DISGE:	PUSH P,1
	HRLI 1,DISGET		;GIVEN MON ADDRESS IN 1
DISXE:	MOVS 1,1
	JSYS EDISMS
	POP P,1
	RET

DISGET:	SKIPGE 0(1)
	JRST 0(4)
	JRST 1(4)

;DISMISS UNTIL WORD .L. 0

DISL:	PUSH P,1
	HRLI 1,DISLT
	JRST DISXE

DISLT:	SKIPL 0(1)
	JRST 0(4)
	JRST 1(4)

;DISMISS UNTIL WORD .G. 0

DISG:	PUSH P,1
	HRLI 1,DISGT
	JRST DISXE

DISGT:	SKIPG 0(1)
	JRST 0(4)
	JRST 1(4)

;DISMISS FOR SPECIFIED TIME JSYS

.DISMS:	JSYS MENTR
	JUMPLE 1,MRETN
	CAIL 1,100000		;LONG OR SHORT TIME?
	JRST TDIS1		;LONG
	MOVE 2,TODCLK
	ANDI 2,377777
	ADDI 2,0(1)		;COMPUTE TIME TO RESTART
	MOVSI 1,0(2)
	HRRI 1,BLOCKW
TDIS2:	JSYS EDISMS		;DISMISS WITH SPECIFIED TEST
	JRST MRETN

TDIS1:	CAML 1,[XWD 400,0]
	MOVSI 1,400		;APPROX 17 HRS IS MAX PERMITTED
	MOVE 2,TODCLK
	TLZ 2,777000
	ADD 2,1			;COMPUTE TIME TO RESTART
	LSH 2,-^D10		;DIVIDE BY 1024
	MOVSI 1,0(2)
	HRRI 1,BLOCKT
	JRST TDIS2		;GO COMPLETE DISMISSAL

;SCHEDULER WAIT TEST FOR LONG WAIT

BLOCKT:	LSH 1,^D10		;RESTORE WAKEUP TIME TO FULL SIZE
	MOVE 2,TODCLK		;GET TIME NOW
	TLZ 2,777000
	SUB 1,2			;DESIRED-NOW = TIME LEFT TO WAIT
BLKT1:	JUMPLE 1,1(4)		;WAKEUP IF NEGATIVE
	CAMG 1,[XWD 400,0]	;VERY LARGE DIFFERENCE?
	JRST 0(4)		;NO, KEEP WAITING
	SUB 1,[XWD 1000,0]	;COMPENSATE FOR WRAPAROUND
	JRST BLKT1		;CHECK AGAIN

;SCHEDULER

SCHED0:	SETZ 0,			;FOR PEOPLE WATCHING LIGHTS
SCH0:	CONSZ PI,177B27		;ANY PI IN PROGRESS?
	BUG(HLT,<ENTERED SCHEDULER WITH PI IN PROGRESS>)
	MOVE P,PI7P		;SETUP LOCAL PDL
	MOVE 1,NBPROC
	ADD 1,NGOJOB
	MOVE 2,TODCLK
	SUBM 2,RJTTIM		;REAL TIME SINCE LAST UPDATE TO RJTSUM
	EXCH 2,RJTTIM
	IMUL 2,1		;COMPUTE NBPROC+NGOJOB DT
	ADDM 2,RJTSUM
	MOVE 2,TODCLK
	CAML 2,RJATIM		;TIME FOR RJAV UPDATE?
	CALL DORJAV		;YES
	LSH 1,^D9
	ADD 1,NBPROC
	HRLI 0,0(1)		;DISPLAY NBPROC, NBPROC+NGOJOB IN LH 0
	MOVEM 0,22		;AND 22
	MOVSI 16,-NPCLKS	;SCAN PROCESS CLOCKS
	SKIPG RJQNT(16)		;EXHAUSTED? (RJQNT IS FIRST IN TABLE)
	XCT PCLKT(16)		;YES, SERVICE WHATEVER
	AOBJN 16,.-2
	MOVE 4,SCDRQO
	CAME 4,SCDRQI		;ANY REQUESTS?
	CALL SCDRQ1		;YES
	SKIPE ISKED		;POSSIBLE CHANGE OF STATE?
	CALL SCHED1		;YES, GO TEST WAITING JOBS
	SKIPN PSKED		;PAGE TRANSFER COMPLETE, OR
	SKIPE SKEDF2		;JOB CHANGED STATE?
	CALL DISMSJ		;YES, DISMISS CURRENT JOB
SCH1:	SKIPE PWRDWN		;POWER FAIL DETECTED?
	JRST SCHPRF		;YES
	SKIPE 1,20		;REQUEST FROM SWITCHES?
	JSP 4,SWTST		;YES
	SKIPL 7,FORKX		;JOB TO CONTINUE?
	JRST SCHED3		;YES
	CALL SKDJOB		;NO, GO SCHEDULE ONE

SCHED3:	SETZM SKEDF2
	SKIPGE 1,FKINT(7)	;INTERRUPT REQUEST?
	TLNE 1,200000		;AND NOT ONE IN PROGRESS
	JRST SCHED4
	MOVSI 1,200000		;CLEAR WORD EXCEPT FOR PI IN PROG
	EXCH 1,FKINT(7)
	MOVEM 1,PIMSK		;PASS REQUEST WORD TO SERVICE ROUTINE
	MOVEI 1,PIRQ		;PSEUDO-INTERRUPT SERVICE
	EXCH 1,PPC
	MOVEM 1,PIPC		;SAVE OLD PC
SCHED4:	AOS SKEDF1		;SET FLAG FOR CH7 ROUTINE
	ISB SCDCHN		;LET IT START PROCESS

	DEFINE ECALL (D)
<IFDEF D'CHN,<EXTERN D'CHK
	CALL D'CHK
	GS D'TIM
>>

;TABLE OF SERVICE CALLS FOR PROCESS CLOCKS

PCLKT:	CALL QNTDMS		;RUNNING JOB QUANTUM OVERFLOW
BKGNDT:	CALL SKDLV8		;EVERY TICK STUFF ('LEVEL 8')
	CALL CLK2		;SECOND LEVEL CLOCK
NPCLKS==.-PCLKT
NBKR==.-BKGNDT		;THE (LAST) N OF THESE TO RUN ANYTIME

SKDLV8:	ECALL IMP		;NETWORK
	JRST TTCH7		;TTY BIG BUFFER

;SECOND PROCESS CLOCK, LESS PRECISE, UPDATES EVERY 100 MS

CLK2:	MOVSI 1,(1B1)
	SKIPL SCDRN1		;RUNNING SPECIFIC JOB?
	MOVEM 1,CHKTIM		;YES, DISABLE JOB 0 CHECK
	MOVE 1,TODCLK
	CAML 1,CHKTIM		;JOB 0 OVERDUE?
	BUG(HLT,<JOB 0 NOT RUN FOR TOO LONG, PROBABLE SWAPPING HANGUP>)
	MOVEI 15,^D100
	EXCH 15,TIM2		;SET NEW TIME, GET OLD
	SUBI 15,^D100		;COMPUTE ACTUAL TIME SINCE LAST UPDATE
	MOVSI 14,-N2CLKS	;SET TO SCAN SECOND LEVEL CLOCKS
CLK21:	ADDM 15,DSKTIM(14)	;UPDATE CLOCK
	SKIPG DSKTIM(14)	;COUNTED OUT?
	XCT CLK2CL(14)		;YES, DO WHATEVER
	AOBJN 14,CLK21
	AOS SKEDF2
	RET

;TABLE OF CALLS FOR SECOND LEVEL CLOCKS

CLK2CL:	ECALL DSK		;DISK RE-QUEUE CHECK
	ECALL MTA		;MAG TAPE
	ECALL PTP		;PAPER TAPE PUNCH
	ECALL PLT		;PLOTTER
	ECALL DTA		;DECTAPE
N2CLKS==.-CLK2CL

RSKP:	AOS 0(P)		;RETURN (VIA PDL) SKIPPING
R:	RET

PI7P:	IOWD NSKDP,SKDPDL

;UPDATE RUNNABLE JOB AVERAGES

DORJAV:	MOVEI 2,^D1000
	ADDM 2,RJATIM		;SET TIME OF NEXT UPDATE
	MOVE 4,RJTSUM		;CURRENT INTEGRAL OF NBPROC+NGOJOB
	SUBM 4,RJAVS1		;DIFFERENCE FROM LAST UPDATE
	EXCH 4,RJAVS1
	FSC 4,233		;FLOAT IT
	FDVRI 4,(1000.0)	;AVERAGE OVER LAST 1000 MS
	JOV .+1			;CLEAR OV FLAG
	MOVSI 2,-NRJAVS
SCHC1:	MOVE 3,EXPFF(2)
	FMPRM 3,RJAV(2)		;SUM*EXP(-T/C) -) SUM
	JOV [	SETZM RJAV(2)	;THAT MAY HAVE UNDERFLOWED,
		JRST .+1]	;IF SO, CLEAR IT TO 0
	MOVE 3,4
	FMPR 3,EXPGF(2)
	FADRM 3,RJAV(2)		;TERM*(1-EXP(-T/C)) + SUM -) SUM
	AOBJN 2,SCHC1
	RET

;TABLE OF EXP(-T/C) FOR T = 1 SEC.

EXPFF:	EXP 0.983471454		;C = 1 MIN
	EXP 0.996672216		;C = 5 MIN
	EXP 0.998889506		;C = 15 MIN

;TABLE OF 1-EXP(-T/C) FOR T = 1 SEC

EXPGF:	EXP 0.0165285462	;C = 1 MIN
	EXP 0.00332778395	;C = 5 MIN
	EXP 0.00111049406	;C = 15 MIN

;TEST WORD DEPOSITED BY SWITCHES IN 20

SWTST:	SETZM 20
	JFFO 1,.+1
	CAIGE 2,NSWTT
	XCT SWTT(2)
SWTST1:	JRST 0(4)		;RESUME SCHEDULER

SWTT:	JRST SWHLT		;HALT T.S.
	JRST SWRUN1		;RUN ONLY SPECIFIED JOB
	JRST SWCRSH		;INITIATE JOB0 FUNCTION
NSWTT==.-SWTT

SWHLT:	CALL DISMSJ		;DISMISS CURRENT JOB
	MOVNI 0,1
	JRST .

SWRUN1:	HRREI 1,0(1)		;-1 OR JOB NUMBER IN RH
	JUMPL 1,SWRUN2		;-1 MEANS RESTORE TO NORMAL
	CAIGE 1,NJOBS		;LEGAL JOB NUMBER?
	SKIPGE JOBRT(1)		;RIGHT HALF OF SWITCHES SPECIFIES JOB
	JRST SWTST1		;EXCEPT THAT JOB DOESN'T EXIST
SWRUN2:	MOVEM 1,SCDRN1		;ALLOW ONLY THAT JOB TO RUN
	CALL DISMSJ		;DISMISS CURRENT FORK
	JRST SWTST1

SWCRSH:	SETZM NXTDMP		;DO DDMP
	AOS JB0FLG		;DO JOB 0
	JRST SWTST1

;POWER FAIL DETECTED

SCHPRF:	CALL DISMSJ		;FLUSH CURRENT FORK
	MOVEI 1,^D2000
	SOJG 1,.		;WAIT FOR ABOUT 5 MS FOR IO, ETC.
	PIOFF 610000		;CLEAR WORLD
	CONO APR,1B19
	SETOM PWRDWN		;SAYS WE FINISHED PWR DWN SEQUENCE
	JRST 4,.		;SYSTEM SHOULD BE RESTARTABLE AT SYSRST

;SCHEDULER REQUEST PROCESSOR

;SCDRQ7 CALLED BY ROUTINES HAVING PDL POINTER IN P

SCDRQ7:	PIOFF
	JSR SCDRQ
	PION
	RET

;SCDRQ CALLED BY JSR AFTER HAVING TURNED OFF PI SYSTEM

LS SCDRQ,2

SCDRQ0:	MOVEM 1,@SCDRQI
	AOS 1,SCDRQI
	CAIE 1,SCDRQB+NSCDRQ
	JRST @SCDRQ
	MOVEI 1,SCDRQB
	MOVEM 1,SCDRQI
	JRST @SCDRQ

;PROCESS SCHEDULER REQUESTS

SCDRQ1:	CAMN 4,SCDRQI
	RET
	MOVE 2,0(4)		;WORD CONTAINS DATA,,DISPATCH ADR
	HLRZ 1,2
	CALL 0(2)
	AOS 4,SCDRQO
	CAIE 4,SCDRQB+NSCDRQ
	JRST SCDRQ1
	MOVEI 4,SCDRQB
	MOVEM 4,SCDRQO
	JRST SCDRQ1

;SCHEDULER REQUESTS

JOBSRT:	MOVE 2,SPTC		;CURRENT SPT COUNT
	CAIL 2,SSPT-NOFN-100	;NEARLY FULL?
	JRST JOBSR1		;YES, DON'T PERMIT LOGIN
	MOVE 2,DRMFRE
	CAMG 2,DRMIN0		;ENOUGH DRUM SPACE?
	JRST JOBSR1		;NO
	SKIPE FREJOB		;ROOM FOR NEW JOB
	SKIPN FREFK		;AND NEW FORK?
	JRST JOBSR1		;NO
	PUSH P,1		;START JOB (FROM TTY SRV)
	CALL ASSFK		;GET A FORK
	POP P,1
	HRLI 1,NEWJBF
	IORM 1,FKINT(7)		;LEAVE TTY NUMBER FOR STARTUP ROUTINE
	RET

JOBSR1:	MOVEI 2,0(1)		;LINE NUMBER
	MOVE 1,[POINT 7,[ASCIZ /FULL
/]]
	CALL TTEMES		;GIVE USER BAD NEWS
	SETOM TTFORK(2)		;CLEAR TTY
	RET

;ASSIGN FORK SLOT

ASSFK:	HRRZ 7,@FREFK
	EXCH 7,FREFK		;GET FORK, UPDATE LIST
	SUBI 7,FKPT
	MOVEI 1,JSKP
	MOVEM 1,FKSTAT(7)	;MAKE STATUS RUNNABLE AT NEXT TEST
	MOVE 1,QBASE+1
	MOVEM 1,FKOLDS(7)	;ESTABLISH QUEUE
	CALL WTCONC		;PUT ON WAIT QUEUE
	MOVSI 1,400000+NEWFKF
	MOVEM 1,FKINT(7)	;LEAVE INTERRUPT REQUEST
	SETZM FKINTB(7)
	SETZM FKPGS(7)		;CLEAR PT AND PSB WORD
	SETZM FKJOB(7)
	SETZM FKWSP(7)
	MOVE 1,[XWD 100,3]	;INIT AGE TO 100, W.S. TO 3
	MOVEM 1,FKNR(7)
	AOS ISKED
	RET

;PROCESSOR INTERRUPTS REFERRED FROM CHANNEL 1

P7OV:	MOVEI 2,6		;OVERFLOW, FLOATING OVERFLOW
	JRST P7PI1

P7FOV:	MOVEI 2,7		;FLOATING OVERFLOW CHANNEL
	JRST P7PI1

P7POV:	MOVEI 2,^D9		;PDL OVERFLOW
P7PI1:	EXCH 1,2		;FORK NUMBER LEFT BY APR ROUTINE
	CALL PSIRQ
	RET

MPEINT:	MOVEI 2,^D11		;GIVES IO ERROR INTERRUPT
	JRST P7PI1

;BALANCE SET SCHEDULER
;CALLED TO SELECT JOB TO RUN

SKDJOB:	SETZM 21		;CLEAR JOB-NOW-RUNNING DISPLAY

LDJB5:	MOVE 1,NRPLQ
	ADD 1,IOIP
	CAIL 1,MINNR		;NEED GC?
	SKIPLE CGFLG		;NEED GARBAGE COLLECTION?
	CALL GCCOR		;YES
	MOVE 1,MAXNR		;MAX PERMISSABLE CONTINUING SUMNR
	MOVE 2,NBPROC
	CAMG 2,MAXBP		;BAL SET FULL?
	CAMGE 1,SUMNR		;OVER RESERVED?
	JRST REMJOB		;YES, REMOVE A PROCESS
	SKIPN NEBAL		;PRESENTLY PROCESS ENTERING BALSET? OR
	SKIPL SSKED		;WAIT FOR NOSKED JOB?
	JRST SKDJ7		;YES, DONT CONSIDER ADDING TO BALSET
	SKIPE NGOJOB		;JOB WAITING TO ENTER BALSET?
	JRST LDJOB		;YES, GO LOOK AT IT

SKDJ7:	MOVEI 10,BALSET		;SETUP TO SELECT BEST JOB IN B.S.
	SETO 5,
	SETZM PSKED
	MOVEI 6,-1		;HIGHER THAN HIGHEST POSS Q VAL
SKDJ1:	CAML 10,FBALS		;ALL JOBS EXAMINED?
	JRST SKDJ2		;YES
	SKIPGE 7,0(10)		;THIS ONE RUNNABLE?
	JRST SKDJ3		;NO, GO TEST IT
SKDJ4:	TLNE 7,200000		;NO-SWAP FORK?
	JRST SKDHQ		;YES, GIVE PREFERENCE
SKDHQ1:	CALL CORFCT		;GET PRIORITY VALUE
	SKIPL SCDRN1		;RUN SPECIAL JOB?
	JRST [	HLRZ 1,FKJOB(7)	;YES, GET JOB NUMBER OF THIS FORK
		CAME 1,SCDRN1	;CORRECT ONE?
		JRST SKDJ5	;NO
		JRST .+1]	;YES
	CAIL 1,0(6)		;LESS THAN MIN SO FAR?
	JRST SKDJ5		;NO
	MOVEI 6,0(1)		;YES, SO IS PREFERABLE
SKDHQ2:	MOVEI 5,0(7)		;REMEMBER FORK NUMBER AND Q
SKDJ5:	AOJA 10,SKDJ1

;TEST WAITING BALSET FORK

SKDJ3:	TLNE 7,100000		;UNUSED ENTRY?
	JRST SKDJ5		;YES
	MOVE 2,FKPGST(7)	;GET TEST ROUTINE ADDRESS
	HLRZ 1,2		;AND HALF WORD DATA
	JSP 4,0(2)		;CALL TEST ROUTINE
	JRST SKDJ5		;STILL WAITING
	TLZ 7,400000
	MOVEM 7,0(10)
	TLNN 7,(1B3)		;THIS FORK DESIGNATED FOR REMOVAL?
	JRST SKDJ4		;NO
	SUBI 10,BALSET
	HRRZ 1,FKNR(7)		;BUMP RESERVE SO REMBSJ CAN REDUCE IT
	ADDM 1,SUMNR
	CALL REMBSJ		;REMOVE FROM BAL SET
	CALL GOCONC		;ADD TO READY LIST
	JRST SKDJ7		;START OVER

SKDJ2:	SKIPE PSKED		;PAGE TRANSFER FINISHED LATELY?
	JRST SKDJ7		;YES, RECHECK
	JUMPL 5,BKGND1		;-1 MEANS FOUND NO JOB TO RUN
	SKIPL SSKED		;CAN RUN ANY JOB?
	JRST SKDHQ3		;NO, ONLY NOSKED ONE
	SKIPL SCDRN1		;RUN SPECIAL JOB?
	JRST [	HLRZ 1,FKJOB(5)	;GET SELECTED FORKS JOB NO
		CAME 1,SCDRN1	;CORRECT ONE?
		JRST REMJOB	;NO, REMOVE FROM BAL SET
		JRST .+1]
SKDHQ4:	MOVEI 7,0(5)
SETRT:	AOS APCLKC
	ISB SCDCHN		;UPDATE RUN CLOCKS
	HRRZM 7,FORKX
	CALL SETPPG		;SETUP PAGER FOR THIS PROCESS
	HRRZ 10,FKPT(7)
	HRRZS BALSET(10)	;CLEAR ANY FLAGS
	HLRZ 2,FKSTAT(7)	;SETUP REMAINING TIME
	HRRZ 3,FKSTAT(7)
	SUB 3,QBASE(2)
	MOVEM 3,RJQNT
	SETZB 2,RUNT1
	EXCH 2,JOBRTT
	ADDM 2,SKDTM1		;CHARGE TIME TO SCHEDULER
	MOVEI 2,0
	HRLM 2,FKPT(7)		;PROCESSOR NUMBER
	HLRZ 1,FKSTAT(7)	;QUEUE LEVEL OF FORK
	HLRZ 2,FKJOB(7)		;JOB NUMBER OF FORK
	IOR 1,BITS(2)		;BIT POSITION DESIGNATES JOB NUMBER
	MOVEM 1,21		;FORK NUMBER AND STATUS FOR LIGHTS
SETOVF:	MOVEI 2,5B29+5B32	;CLEAR OV AND FOV FLAGS
	MOVE 1,PSICHM		;GET THIS FORKS CHANNEL MASK
	TLNE 1,(1B6)		;CHANNEL 6?
	TRC 2,6B32		;YES, ENABLE OVERFLOW
	TLNE 1,(1B7)		;CHANNEL 7?
	TRC 2,6B29		;YES, ENABLE FLOATING OVERFLOW
	CONO APR,APRCHN(2)	;SET APR ACCORDING TO FORGOING
	RET

SKDHQ:	MOVEI 7,0(7)		;FORK NUMBER
	CAME 7,SSKED		;THE NOSKED ONE?
	JRST SKDHQ1		;NO, USE ORDINARY ALGORITHM
	SETZ 6,			;MAKE SURE FORK GET SELECTED
	JRST SKDHQ2

;BACKGROUND ACTIVITIES, IF NO PROCESS TO RUN

SKDHQ3:	CAMN 5,SSKED		;THE NOSKED FORK?
	JRST SKDHQ4		;YES, RUN IT
BKGND1:	MOVSI 16,-NBKR		;PERFORM ANY PERIODIC ROUTINES
	XCT BKGNDT(16)		;WHICH CAN BE RUN MORE OFTEN THAN
	AOBJN 16,.-1		;WHEN THEIR CLOCK RUN OUT
	SKIPN PIAPRX		;RECENT CLOCK INTERRUPT?
	JRST BKGND2		;NO, NOTHING TO UPDATE
	AOS ISKED		;CHECK WAITING JOBS NEXT TIME
	SETZM PIAPRX		;SO AS TO NOTE WHEN APR INT HAPPENS
	AOS APCLKC
	ISB SCDCHN		;UPDATE RUN CLOCKS
	SETZ 1,
	EXCH 1,JOBRTT		;GET TIME SINCE LAST UPDATE
	SKIPE 2,NBPROC		;RUNNABLE JOBS IN EXISTENCE?
	ADDM 1,SKDTM1		;YES, CHARGE 'INEFFICIENCY' CLOCK
	CAIG 2,0
	ADDM 1,SKDTM0		;NO, CHARGE 'NULL' CLOCK
BKGND2:	AOJA 0,SCH0		;TRY AGAIN

;CORE OVER RESERVED, SELECT JOB TO REMOVE
;SELECT THE ONE WITH LARGEST Q VALUE

REMJOB:	MOVEI 10,BALSET
	SETZB 6,5
REMJ2:	CAML 10,FBALS
	JRST REMJ1
	HRRZ 7,0(10)		;GET FORK INDEX
	SKIPL SCDRN1		;RUNNING SPECIAL JOB?
	JRST [	HLRZ 1,FKJOB(7)	;YES, GET THIS FORKS JOB NO
		CAMN 1,SCDRN1	;THIS ONE?
		AOJA 10,REMJ2	;YES, DON'T REMOVE IT
		JRST .+1]
	HRRZ 1,FKPGST(7)	;GET WAITING STATUS
	SKIPGE 2,0(10)
	CAIE 1,SWPINT		;ENTERING BALSET?
	TLNE 2,240000		;RESCHEDULABLE AND NOT REMOVED?
	AOJA 10,REMJ2		;NO
	HRRZ 1,FKWSP(7)		;SIZE
	IMUL 1,BTFACT		;TIMES FACTOR
	CAMLE 1,NBP(10)		;(INDEX NBT) IN BALSET LONG ENOUGH?
	JRST [	HLRZ 1,FKSTAT(7) ;NO, MAKE FORK HIGH PRIORITY, USE Q
		JRST .+2]
	CALL CORFCT		;GET WEIGHTED FORK STATUS
	CAMGE 1,6		;MAX SO FAR?
	AOJA 10,REMJ2		;NO
	MOVEI 5,0(10)		;YES, SAVE PROC NUMBER AND VALUE
	MOVEI 6,0(1)
	AOJA 10,REMJ2

REMJ1:	JUMPE 5,REMJ5		;NO REMOVABLE JOB FOUND
	SUBI 5,BALSET
	SKIPGE 7,BALSET(5)	;FORK IN PAGE WAIT?
	JRST REMJ4		;YES
	CALL REMBSJ		;REMOVE JOB FROM BAL SET
	CALL GOCONC		;PUT ON READY LIST
	JRST LDJB5

REMJ4:	MOVSI 1,1B21		;INDICATE FORK DESIGNATED FOR REMOVAL
	IORM 1,BALSET(5)
	HRRZ 1,FKNR(7)		;GET RESERVE
	MOVN 1,1
	ADDM 1,SUMNR		;RELEASE IT
	JRST LDJB5

REMJ5:	JRST SKDJ7		;NOTHING ELSE TO DO

;MAINTAIN INTEGRAL NBPROC DT

BSMEAS:	MOVE 1,TODCLK
	SUBM 1,BSCTIM		;DT - TIME SINCE LAST UPDATE
	EXCH 1,BSCTIM
	IMUL 1,NBPROC		;NBPROC * DT
	ADDM 1,BSTSUM
	RET

;REMOVE JOB FROM BALANCE SET

REMBSJ:	HRRZ 10,FKPT(7)		;GET PROCESS POINTER
	HRRZ 2,FKNR(7)		;GET RESERVE
	MOVN 1,2
	ADDM 1,SUMNR		;REDUCE BALSET SIZE
	CAML 2,NPMAX		;BUT WITHIN SYSTEM MAX
	MOVE 2,NPMAX
	HRRM 2,FKNR(7)		;SET AS RESERVE FOR NEXT RUNNING
	AOS CGFLG		;MAY HAVE LEFT GARBAGE
	MOVSI 2,-PLKV
	SKIPN INDFLG		;LOCKING JSB'S?
	JRST REMB1		;NO
	HRRZ 1,FKJOB(7)		;GET JSB SPT INDEX
	MOVE 1,SPT(1)		;CORE ADR
	ADDM 2,CST1(1)		;DECREASE LOCK COUNT
REMB1:	HRRZ 1,FKPGS(7)
	MOVE 1,SPT(1)
	ADDM 2,CST1(1)		;UNLOCK PSB
	HLRZ 1,FKPGS(7)
	JUMPE 1,.+3
	MOVE 1,SPT(1)
	ADDM 2,CST1(1)		;UNLOCK PT
	MOVE 4,FBALS
	SETOM BALSET(10)	;SET PROCESS WORD TO EMPTY
	CALL BSMEAS		;UPDATE MEASUREMENTS
	SOSG NBPROC
	SETZM SUMNR		;BALSET EMPTY, BE SURE SUMNR NOW 0
	CAIN 4,BALSET+1(10)	;LAST WORD IN USE?
	JRST REMBS3		;YES, GO ADJUST LIMITS OF TABLE
REMBS2:	RET

REMBS3:	SETO 1,
REMBS1:	SOS 4,FBALS		;ADJUST END OF TABLE POINTER
	CAIN 4,BALSET		;TABLE EMPTY?
	JRST REMBS2		;YES
	CAME 1,-1(4)		;LAST ENTRY EMPTY?
	JRST REMBS2		;NO
	JRST REMBS1		;YES, KEEP CHECKING

SETRES:	HRRZ 3,FKPT(7)		;GET BALSET NUMBER
	HRRZ 2,FKNR(7)		;CURRENT RESERVE
	SUB 1,2			;DIFFERENCE
	ADDM 1,SUMNR
	ADDM 1,FKNR(7)		;ADJUST
	RET

;ADD JOB TO BALANCE SET IF POSSIBLE

LDJOB:	SETZM MINNRC		;0 UNLESS TRYING TO LOAD FORK
	CALL SCDRUN		;SELECT BEST RUNNABLE FORK
	JUMPL 7,SKDJ7		;WASN'T ONE
	SKIPG NBPROC		;BALSET NOW EMPTY?
	JRST LDJB6		;YES, LOAD RUNNABLE FORK
	CALL GETMBQ		;COMPUTE MAX FKSTAT OF BALSET FORKS
	CALL CORFCT		;GET WEIGHTED FKSTAT OF NEW PROCESS
	CAMGE 1,MAXBSQ		;BETTER THAN WORST NOW IN BAL SET?
	JRST LDJB6		;YES, LOAD IT
	MOVE 1,NBPROC
	CAML 1,MAXBP		;ROOM IN BALSET?
	JRST LDJB1		;NO, DON'T LOAD
	HRRZ 1,FKNR(7)		;GET RESERVE
	ADD 1,SUMNR		;INCREASE SUM OF RESERVES
	MOVE 2,MAXNR
	SUB 2,NBPROC		;TOTAL CORE LESS ONE PAGE/ACTIVE PROC
	CAIGE 2,0(1)		;ROOM FOR SELECTED JOB?
	JRST LDJB1		;NO
LDJB6:	MOVE 3,NRPLQ		;PAGES NOW ON REPLACABLE
	CAIGE 3,MINNR		;ENOUGH TO LOAD PSB AND UPT?
	JRST LDJB7		;NO
	MOVEI 10,BALSET		;SELECT PROCESS NUMBER
	SETO 1,
LDJB2:	CAML 10,FBALS
	JRST LDJB3
	CAME 1,0(10)		;DELETED ENTRY?
	AOJA 10,LDJB2		;NO

LDJB4:	SUBI 10,BALSET
	MOVEM 7,BALSET(10)	;YES, STORE FORK INDEX IN SLOT
	HRRZM 10,FKPT(7)	;REMEMBER PROCESS POINTER
	CALL BSMEAS
	AOS NBPROC		;COUNT NUMBER OF PROCESSES
	HRRZ 1,FKNR(7)		;GET WORKING SET SIZE
	ADDM 1,SUMNR		;UPDATE SUM OF NR
	HRRZS 1,FKWSP(7)	;START TAV AT 0
	IMUL 1,BTFACT		;INIT NBT ACCORDING TO NUMBER OF
	MOVEM 1,NBT(10)		;PAGES NOW IN CORE
	HRRZ 1,FKPGS(7)		;GET PSB INTO CORE
	JUMPN 1,.+3
	CALL ASSPT		;NO PSB, GO ASSIGN ONE
	HRRZM 1,FKPGS(7)
	CALL SWPIN0
	HLRZ 1,FKPGS(7)
	JUMPN 1,.+3
	CALL ASSPT		;NO UPT, ASSIGN ONE
	HRLM 1,FKPGS(7)
	CALL SWPIN0
	HRRZ 1,FKJOB(7)		;GET JSB SPTN
	JUMPN 1,.+3		;IS ONE?
	CALL ASSPT		;NO, ASSIGN FOR NEW JOB
	HRRM 1,FKJOB(7)
	SKIPE INDFLG		;LOCKING JSB'S?
	CALL SWPIN0		;SWAP IT IN AND LOCK IT
LDJB8:	MOVEI 1,SWPINT
	MOVEM 1,FKPGST(7)	;SET TEST TO WAIT FOR PSB AND PT
	MOVSI 1,400000
	HLLM 1,BALSET(10)
	AOS NEBAL		;ONE MORE JOB NOW ENTERING BALSET
	JRST LDJB5		;CONTINUE SCHEDULING

LDJB1:	CALL GOCONC		;PUT PROCESS BACK ON READY LIST
	JRST SKDJ7

LDJB3:	AOS FBALS		;INCREASE END OF TABLE POINTER
	JRST LDJB4

LDJB7:	CALL GOCONC		;PUT FORK BACK ON GOLST
	MOVEI 1,MINNR
	MOVEM 1,MINNRC		;SET RPLQ MINIMUM TO RESERVE SPACE
	ADD 3,IOIP		;ROOM TO LOAD PSB AND UPT WHEN CURRENT
	CAIL 3,MINNR		;WRITES COMPLETE?
	JRST SKDJ7		;YES, CONTINUE TO RUN WHILE WRITES COMPL
	JRST REMJOB		;NO, REMOVE A FORK FROM BALSET

;COMPUTE MAX Q OF PROCESSES NOW IN BALSET (I.E. LEAST PREFERABLE FORK)

GETMBQ:	PUSH P,7
	MOVEI 5,BALSET
	SETZ 6,
GMB1:	CAML 5,FBALS		;LOOKED AT ALL?
	JRST [	MOVEM 6,MAXBSQ	;YES, SAVE MAX
		POP P,7
		RET]
	HRRZ 7,0(5)		;GET FORK NUMBER
	CAIN 7,-1		;SLOT IN USE?
	AOJA 5,GMB1		;NO
	HRRZ 1,FKWSP(7)
	IMUL 1,BTFACT		;MIN TIME IN BALSET
	CAMLE 1,NBP(5)		;(INDEXES NBT) BEEN IN LONG ENOUGH?
	AOJA 5,GMB1		;NO, TREAT AS HIGHEST PRIORITY
	CALL CORFCT		;GET WEIGHTED FKSTAT
	CAIL 1,0(6)		;MAX?
	MOVEI 6,0(1)		;YES
	AOJA 5,GMB1

BTFACT:	EXP ^D20		;MS/PAGE MINIMUM FOR BALSET

;DISMISS JOB FOR RESCHEDULING

DISMSJ:	MOVE 7,FORKX
	JUMPL 7,R		;NO JOB
	CALL SAVRT		;UPDATE QUEUE AND QUANTUM
QNTDM1:	SETZ 1,
	EXCH 1,PGTIM		;TIME SINCE LAST PAGER TRAP
	HRRZ 2,FKWSP(7)		;CURRENT SIZE
	IDIVI 1,0(2)
	MOVSI 1,0(1)
	ADDM 1,FKWSP(7)		;UPDATE P-FAULT AVERAGE
	SETZ 1,
	JRST SCHP2

;DISMISS FORK ON QUANTUM OVERFLOW

QNTDMS:	MOVE 7,FORKX
	JUMPL 7,R
	CALL SAVRT		;UPDATE QUEUE VALUE
	HRRZ 1,FKWSP(7)
	CALL SETRES		;SET RESERVE TO CURRENT SIZE
	JRST QNTDM1

;TIMER ROUTINES

;	JSP 4,STIME	;STARTS TIMING
;	..		;PROGRAM
;	JSP 4,ETIME	;ENDS TIMING, RETURNS TIME IN 1
;	ADDM 1,CLOCK	;ADD TIME TO APPROPRIATE CLOCK

STIME:	AOS APCLKC
	ISB SCDCHN		;UPDATE CLOCKS
	SETZ 1,
	EXCH 1,JOBRTT		;GET AND RESET RUNTIME
	PUSH P,1
	JRST 0(4)

ETIME:	AOS APCLKC
	ISB SCDCHN
	POP P,1			;OLD RUNTIME
	EXCH 1,JOBRTT		;RESTORE OLD RUNTIME, GET RUNTIME OF
	JRST 0(4)		;TIMED CODE AND RETURN IT

;UPDATE QUEUE NUMBER AND TIME USED VALUE

SAVRT:	JSP 3,UCLOCK		;UPDATE CLOCKS
	HLRZ 2,FKSTAT(7)	;CURRENT QUEUE NUMBER
	HRLOI 1,377777		;LARGEST NUMBER
	EXCH 1,RJQNT		;GET REMAINING QUANTUM
	MOVE 3,RUNT1		;RUNTIME THIS RUNNING
	ADDM 3,QSUM(2)		;ACCUMULATE STATISTIC
	HRRZ 10,FKPT(7)		;BALSET INDEX
	ADDM 3,NBT(10)		;ACCUMULATE RUNTIME IN BALSET
	JUMPG 1,DISMJ1		;NOT EXHAUSTED
	MOVE 1,JOBNO
	SKIPE JOBCK0		;GUARANTEE WORDS INIT'ED?
	JRST SAVRT7		;YES, GO CHECK CURRENT PERFORMANCE
	MOVE 3,TODCLK		;INITIALIZE TIME QUARANTEE WORDS
	MOVEM 3,JOBCK0
	MOVE 3,JOBRT(1)
	MOVEM 3,JOBCK1
SAVRT7:	LDB 3,[POINT 7,JOBBIT,17] ;GET GUARANTEE PERCENTAGE
	JUMPE 3,SAVRT8		;NOT SPECIAL
	MOVE 4,JOBRT(1)		;COMPUTE RUNTIME DURING TEST INTERVAL
	SUB 4,JOBCK1
	MOVE 1,TODCLK		;COMPUTE REAL TIME OF TEST INTERVAL
	SUB 1,JOBCK0
	IMULI 4,^D100		;COMPUTE RUNTM*100%/PCT TO GET
	IDIV 4,3		;EXPECTED REAL TIME
	SUB 4,1			;EXCESS OR DEFICIT OF REAL TIME
	MOVEM 4,23		;FOR LIGHT WATCHERS
	HRLM 2,23		; ..
	JUMPGE 4,SAVRT5		;.G. 0 MEANS BETTER THAN GUARANTEE
	MOVEI 2,0		;KEEP ON QUEUE 0 TO GET EXCLUSIVE TIME
	JRST SAVRT9

SAVRT8:	SETZM FKTIME(7)
	LDB 3,[POINT 6,JOBBIT,35] ;GET MAX Q FOR THIS JOB
	CAIL 2,0(3)		;IF REACHED MAX Q, AND 
	JUMPN 3,[LDB 2,[POINT 6,JOBBIT,29] ;PRIORITY WORD NOT 0,
		MOVEM 7,23	;FOR DISPLAY
		JRST SAVRT9]	;SET NEW Q AS SPECIFIED
	CAIGE 2,MAXQ		;NOW ON MAX Q?
	AOJA 2,SAVRT9		;NO, GO TO NEXT ONE
SAVRT9:	MOVSM 2,FKSTAT(7)
	MOVE 3,TODCLK
	SKIPN FKTIME(7)		;TIME ON QUEUE ALREADY SET?
	MOVEM 3,FKTIME(7)	;NO, SET IT
	SKIPA 1,QBASE+1(2)	;NEXT QUEUE TIME
DISMJ1:	ADD 1,QBASE(2)		;INCREASE BY BASE TIME
	HRRM 1,FKSTAT(7)
	RET

;4 NOW CONTAINS TIME SUCH THAT AFTER THAT REAL-TIME INTERVAL,
;WITH NO RUNNING OF PROGRAM, ACTUAL PCT WILL EXACTLY EQUAL DESIRED PCT

SAVRT5:	CAIGE 4,LOWQT		;ACCUMULATED EXCESS .GE. LOW-Q QUANT?
	JRST [	CAIGE 2,MAXQ-1	;NO, STILL ON HIGHER QUEUES?
		JRST SAVRT8	;YES, FOLLOW NORMAL ALGORITHM
		MOVEI 2,MAXQ-1	;STAY ON SECOND LOWEST QUEUE
		SETZM FKTIME(7)
		JRST SAVRT9]
	CAIGE 4,2*LOWQT		;ACCUMULATED LARGE EXCESS?
	JRST SAVRT6		;NO
	SUBI 4,2*LOWQT		;YES, REMOVE EXCESS OVER 2*LOWQT
	MOVN 4,4
	ADDM 4,JOBCK0		;FROM CONSIDERATION
	MOVEI 4,2*LOWQT
SAVRT6:	ADD 4,TODCLK		;COMPUTE WHEN TO RUN AGAIN
	MOVEM 4,FKTIME(7)
	MOVEI 2,0		;AND RUN ON 0 AT THAT TIME
	JRST SAVRT9

;UPDATE USER CLOCKS ON REQUEST
;CALLED WITH  JSP 3,UCLOCK

UCLOCK:	AOS APCLKC
	ISB SCDCHN		;UPDATE SCHEDULER CLOCKS
	MOVE 2,JOBNO
	SETZ 1,
	EXCH 1,JOBRTT		;RUN TIME SINCE LAST UPDATE
	ADDM 1,JOBRT(2)		;ACCOUNT FOR JOB
	ADDM 1,FKRT		;ACCOUNT FOR FORK
	ADDM 1,PGTIM		;PAGE TRAPS
	ADDM 1,RUNT1		;LOCAL RUNTIME
	HRRZ 2,JOBNAM(2)	;GET SUBSYSTEM INDEX
	ADDM 1,STIMES(2)	;ACCUMULATE SUBSYSTEM TIME
	JRST 0(3)

WTCONC:	MOVE 1,TODCLK		;SAVE TIME FORK WAS PUT INTO WAITING
	MOVEM 1,FKPGST(7)
	HRRZ 1,FKWSP(7)
	JUMPN 1,WTCON1		;NO PAGES IN CORE?
	HRRZ 1,FKCNO(7)		;YES, HAS CORE NUMBER?
	JUMPE 1,WTCON1
	MOVE 1,BITS(1)		;YES, DEASSIGN IT
	IORM 1,FRECB
	HLLZS FKCNO(7)
WTCON1:	MOVEI 1,WTLST
	HRLZM 1,FKPT(7)		;REMEMBER WHERE FORK IS
	MOVEI 6,FKPT(7)		;PUT FORK ON WAIT LIST
	HRRM 6,@WTLSTL
	MOVEM 6,WTLSTL
	RET

;TEST ALL WAITING JOBS FOR READY (CONDITION SATISFIED)

SCHED1:	SETZM ISKED
	MOVEI 6,WTLST		;HEAD OF WAITING LIST
SCHEDA:	MOVEI 5,0(6)		;KEEP POINTER TO LAST ONE IN 5,
SCHEDB:	HRRZ 6,0(5)		;POINTER TO CURRENT ONE IN 6
	JUMPE 6,R		;DONE, LIST EMPTY
	MOVEI 7,@FKPT6M		;FORK INDEX
	MOVE 2,FKSTAT(7)	;FKSTAT/  TEST VALUE,,ADR OF TEST ROUTINE
	HLRZ 1,2
	JSP 4,0(2)		;CALL TEST ROUTINE
	JRST SCHEDI		;NO SKIP => STILL NOT RUNNABLE
	CALL NEWST		;ESTABLISH NEW QUEUE STATUS
SCHEDJ:	HRRZ 2,0(6)		;REMOVE FROM WAIT LIST
	HRRM 2,0(5)
	CAMN 6,WTLSTL
	MOVEM 5,WTLSTL
	CALL GOCONC		;PUT ON READY LIST
	AOS SKEDF2		;RESCHED SINCE THIS JOB MIGHT BE BETTER
	JRST SCHEDB

SCHEDI:	SKIPGE 1,FKINT(7)	;INTERRUPT WAITING?
	TLNE 1,200000		;AND ACCEPTABLE?
	JRST SCHEDA		;NO
	MOVSI 1,PSIWTF		;YES, REMEMBER WAS IN WAIT STATE
	IORM 1,FKINT(7)
	PUSH P,FKSTAT(7)	;INTERRUPT - SAVE WAIT TEST
	CALL NEWST		;COMPUTE NEW STATUS
	POP P,FKOLDS(7)		;REMEMBER WAIT TEST
	JRST SCHEDJ		;GO MAKE RUNNABLE

GOCONC:	MOVEI 2,GOLST		;REMEMBER WHERE FORK IS
	HRLZM 2,FKPT(7)
	MOVEI 6,FKPT(7)
	HRRM 6,@GOLSTL		;ADD TO READY LIST
	MOVEM 6,GOLSTL
	AOS NGOJOB		;KEEP COUNT OF READY JOBS
	HRRZ 2,FKCNO(7)
	JUMPN 2,R		;HAS CORE NUMBER ALREADY?
	PUSH P,3		;NO, ASSIGN ONE
	MOVE 2,FRECB
	JFFO 2,.+2
	MOVEI 3,^D35		;NONE AVAILABLE, USE 35
	MOVE 2,BITS(3)
	ANDCAM 2,FRECB		;MAKE IT NO LONGER FREE
	HRRM 3,FKCNO(7)
	POP P,3
	RET

JSKP:	JRST 1(4)
JRET:	JRST 0(4)

;COMPUTE PRIORITY NUMBER FOR FORK

CORFCT:	MOVE 1,FKTIME(7)	;TIME ON CURRENT QUEUE
	SUB 1,TODCLK		;NEGATIVE OF INTERVAL ON CURRENT QUEUE
	JUMPG 1,[ADDI 1,400000	;NOT YET TIME TO RUN, RETURN VERY LOW
		RET]		;PRIORITY NUMBER
	PUSH P,2
	HLRZ 2,FKSTAT(7)	;CURRENT QUEUE NUMBER
	ASH 1,@TFACTR(2)	;DIVIDE TIME AS FUNCTION OF QUEUE
	ADD 1,TBASE(2)
	CAIGE 1,0		;IN CASE WAITED VERY LONG
	SETZ 1,			;SET TO MAX PRIORITY
	POP P,2
	RET

;QUEUE PARAMETER TABLES

	RADIX 10

QBASE:	0
	100
	500
	2500
	4500
	14500

LOWQT=10000			;TIME QUANTUM OF LOWEST QUEUE

TBASE:	1000
	3000
	8000
	10500
	16750

TFACTR:	Z 0			;INDIRECTED TO BY ASH INSTRUCTION
	Z -1
	Z -2
	Z -3
	Z -4

	RADIX 8

;HEURISTIC FOR ADJUSTING QUEUE LEVEL AFTER I/O WAIT

NEWST:	MOVE 1,TODCLK		;CALCULATE ACTUAL WAITING TIME
	SUB 1,FKPGST(7)
	ADDM 1,FKTIME(7)	;DON'T COUNT WAIT TIME
	JFCL .+4		;JFCL THIS TO INCLUDE NJOB WEIGHTING
	MOVE 2,NGOJOB		;CALC NUMBER OF CURRENT CPU JOBS
	ADD 2,NBPROC
	IDIVI 1,1(2)		;PLUS 1 FOR SELF
	CAMGE 1,QBASE+1		;WAITED AT LEASE QUEUE 0 QUANTUM?
	JRST [	MOVE 2,FKOLDS(7) ;NO, GIVE NO CREDIT
		JRST NEWST2]	;KEEP OLD VALUES
	HRRZ 2,FKWSP(7)		;NUMBER OF PAGES NOW IN CORE
	CAIGE 2,MINNR
	MOVEI 2,MINNR		;BUT AT LEAST REQUIRED PAGES
	HRRM 2,FKNR(7)
	HRRZ 2,FKOLDS(7)	;OLD QUEUE VALUE
	SUB 2,1			;LESS ADJUSTED WAITING TIME
	CAMG 2,QBASE+2		;WAITED LONG ENOUGH FOR HIGH-QUEUE?
	JRST NEWST1		;YES
	HLRZ 1,FKOLDS(7)	;PREVIOUS QUEUE LEVEL
	SUBI 1,2		;BUMP UP AT LEAST ONE
	CAML 2,QBASE+1(1)	;LONGEST?
	MOVE 2,QBASE+1(1)	;YES, MAKE 2ND LONGEST
	CAMGE 2,QBASE(1)	;ABOVE BASE FOR THIS LEVEL?
	SOJG 1,.-1		;NO, GO A LEVEL DOWN
NEWST5:	MOVE 2,TBASE		;REQUEUE WITH PRIORITY EQUAL TO QUEUE 0
	SUB 2,TBASE(1)
	MOVN 3,TFACTR(1)
	ASH 2,0(3)
	ADD 2,TODCLK
	MOVEM 2,FKTIME(7)	;YES
	MOVE 2,QBASE(1)		;GIVE QUEUE 0 QUANTUM
	ADD 2,QBASE+1
	HRLI 2,0(1)		;CONSTRUCT FKSTAT WORD
NEWST2:	MOVEM 2,FKSTAT(7)
	RET

NEWST1:	MOVE 2,QBASE+1
	MOVE 1,TODCLK
	MOVEM 1,FKTIME(7)	;REMEMBER TIME ON CURRENT QUEUE
	JRST NEWST2

;SCHEDULE BEST JOB TO RUN NOW

SCDRUN:	MOVEI 6,GOLST		;LIST OF READY JOBS
	MOVEI 4,-1		;LOWEST NUMBER SO FAR
SCHEDC:	MOVEI 5,0(6)
	HRRZ 6,0(5)
	JUMPE 6,SCHEDD		;LIST EMPTY, NO MORE TO TEST
	MOVEI 7,@FKPT6M		;COMPUTE FORK INDEX
	CALL CORFCT		;GET PRIORITY VALUE
	CAIL 1,0(4)		;LOWEST YET?
	JRST SCHEDC		;NO
	SKIPL SCDRN1		;RUN ONLY SPECIFIED FORK
	JRST [	HLRZ 2,FKJOB(7)	;GET, THIS FORKS JOB NUMBER
		CAME 2,SCDRN1	;RUN THIS ONE?
		JRST SCHEDC	;NO, IGNORE
		JRST .+1]
	MOVEI 4,0(1)		;YES, REMEMBER NEW VALUE
	MOVEI 3,0(5)		;AND LOCATION
	JRST SCHEDC

SCHEDD:	MOVNI 7,1
	CAIN 4,-1		;ANY JOB FOUND?
	RET			;NO, RETURN NULL JOB
	HRRZ 6,0(3)		;REMOVE FROM READY LIST
	HRRZ 2,0(6)
	HRRM 2,0(3)
	CAMN 6,GOLSTL
	MOVEM 3,GOLSTL
	SOS NGOJOB
	MOVEI 7,@FKPT6M		;RETURN FORK INDEX
	RET

;CLOCK ROUTINES

;CALLED FROM APR INTERRUPT, 60 CY CLOCK INITIATES BREAK ON CH7
;FOR SERVICE

APCLK1:	CONO APR,1000+APRCHN	;TURN OFF FLAG
	AOS APCLKC		;FOR CH7 ROUTINE
	ISB 7
	SOSLE MSCNT		;THIRD TICK?
	JEN @PIAPRX
	MOVEM 1,MSCNT		;THIRD TICK (50 MS.), SYNC 1 MS. CLOCK
	SKIPE 1,SYNCC		;COUNTED 50 MS.?
	JRST [	ADDM 1,TODCLK	;NO, FINISH UP LAST TICKS
		JRST .+2]	;AND LEAVE IT RUNNING
	CONO OAP,1B29		;TURN CLOCK BACK ON
	MOVEI 1,^D50
	MOVEM 1,SYNCC		;SET TO SYNC AFTER 50 TICKS
	MOVEI 1,3		;AND 3 TICKS OF 60 HZ CLOCK
	EXCH 1,MSCNT
	JEN @PIAPRX

;SCHEDULER CLOCK UPDATE

APCLK:	SETZM APCLKC		;CLEAR REQUEST FLAG
	MOVEM 1,CLKAC1		;SAVE COUPLE AC'S
	MOVEM 2,CLKAC2
	MOVE 1,TODCLK		;CLOCK UPDATED BY 1MS INTERRUPT
	SUBM 1,OLDTCK		;COMPUT NUMBER MS. SINCE LAST UPDATE
	EXCH 1,OLDTCK		;SAVE 'NOW' IN OLDTCK
	ADDM 1,JOBRTT
	MOVN 1,1
	MOVSI 2,-NPCLKS		;UPDATE PROCESS CLOCKS
APCLK3:	ADDM 1,RJQNT(2)		;UPDATE (RJQNT IS FIRST OF TABLE)
	SKIPG RJQNT(2)		;TIMED OUT?
	AOS ISKED		;YES, NOTIFY SCHED
	AOBJN 2,APCLK3
	MOVE 2,CLKAC2		;RESTORE AC2
	MOVE 1,CLKAC1
	JRST APCLKX

;HALT JOB

HLTJB:	HRRE 6,CTRLTT
	JUMPL 6,HLTJB1		;IF JOB DETACHED
	SETZM TTPSI(6)		;CLEAR TTY WORDS
	SETOM TTFORK(6)
HLTJB1:	MOVE 5,JOBNO
	SETZM CTRLTT		;CLEAR CONTROL TTY WORDS
	HRRZS JOBPT(5)
	MOVEI 1,400000
	SETO 2,
	DIC			;DEACTIVATE ALL INTERRUPTS
	MOVNI 1,1
	CLOSF
	JFCL
	RELD			;RELEASE ALL DEVICES
	JFCL
	MOVEI 1,-4
	KFORK			;KILL ALL INFERIOR FORKS
	MOVE 7,FORKX		;THIS FORK.
	HLLZ 2,FKPGS(7)		;FORKS PT
	MOVSI 6,-1000
	CALL CLRM0		;CLEAR UPT
	MOVE 6,[XWD PJMPG-PPMPG,JOBMAP-JSB]
	HRLZ 2,FKJOB(7)		;GET SPTN OF JSB
	CALL CLRM0		;CLEAR ANY PAGES MAPPED IN JOB AREA
	SKIPGE JOBPMF
	JRST HLTJB4		;NO PMF
	SETO 1,
	HRLZ 2,JOBPMF
	MOVSI 6,-1000
	HRRI 2,0(6)
	PMAP			;DELETE CONTENTS OF PMF
	AOBJN 6,.-2
	HRRZ 1,JOBPMF
	SETOM JOBPMF		;ENABLE CLOSE OF PMF
	CLOSF			;CLOSE PMF - NO JSYS' AFTER HERE
	JFCL
HLTJB4:	SETZM PSB+UPTPG
	SETZM PSB+UACPG		;CURRENTLY CAN ONLY BE PSB
	MOVE 6,[XWD CPTPG+1-PSBPG,CPTPG+1]
	HRLZ 2,FKPGS(7)
	CALL CLRM0		;CLEAR PAGES IN PP AREA
	HRRZ 1,FKJOB(7)		;JSB
	CALL WTSPT		;WAIT FOR IT TO BE UNSHARED
	CALL WTFPGS		;WAIT FOR PSB AND UPT TO BE IN NO MAPS
	MOVE 1,JOBNO		;RELEASE JOB NUMBER
	SETZM JOBDIR(1)		;CLEAR DIRECTORY NUMBER
	SETOM JOBRT(1)		;INDICATE JOB NUMBER NOT IN USE

	ADDI 1,JOBPT
	EXCH 1,FREJOB		;PUT SLOT ON FREE LIST
	MOVEM 1,@FREJOB
HLTFK1:	JSYS ENSKED		;ENTER SCHEDULER
	CALL REMBSJ		;REMOVE FORK FROM BAL SET
	MOVEI 1,(1B0)
	HRLM 1,FKPT(7)		;NOTE FORK NOT IN BALSET
	MOVSI 1,1
	ADDM 1,CGFLG		;INSIST ON GCCOR
	HRRZ 1,FKJOB(7)		;JSB
	LDB 2,[POINT 14,SPT(1),13] ;SHARE COUNT NOW 1?
	CAIE 2,1		;LAST USE OF JSB?
	JRST [	MOVSI 2,-1B31	;NO, REDUCE SHARE COUNT
		ADDM 2,SPT(1)
		JRST .+2]
	CALL DESPT		;YES, DELETE IT (LOGOUT CASE)
	HLRZ 1,FKPGS(7)		;UPT
	CALL DESPT		;DELETE IT
	HRRZ 1,FKPGS(7)
	CALL DESPT		;DEASSIGN PSB
	SETOM FORKX
	PUSH P,7
	ADDI 7,FKPT
	EXCH 7,FREFK		;PUT FORK NUMBER ON FREE LIST
	TLO 7,400000
	MOVEM 7,@FREFK
	CALL GCCOR		;CLEAN UP PAGES
	POP P,7
	HRRZ 1,FKWSP(7)		;MAKE SURE FORK CLEANED UP
	HRRZ 2,FKCNO(7)
	CAIN 1,0
	CAIE 2,0
	BUG(CHK,<FORK NOT PROPERLY DELETED>)
	JRST SCHED0		;NOW THERE IS NOTHING LEFT OF JOB...

CLRM0:	SETZ 1,
CLRM1:	HRRI 2,0(6)		;PUT PAGE NUMBER WITH PTN
	CALL SETPT
	AOBJN 6,CLRM1
	RET

;WAIT FOR PSB AND UPT TO HAVE SHARE COUNT OF 1

WTFPGS:	HRRZ 1,FKPGS(7)		;PSB
	CALL WTSPT
	HLRZ 1,FKPGS(7)		;UPT
WTSPT:	PUSH P,4
WTSPT2:	JSP 4,WTSPTT		;TEST PAGE NOW
	JRST WTSPT1		;MUST WAIT
	POP P,4			;NOW OK
	RET

WTSPT1:	MOVSI 1,0(1)
	HRRI 1,WTSPTT
	JSYS EDISMS
	HLRZ 1,1
	JRST WTSPT2

WTSPTT:	LDB 2,[POINT 14,SPT(1),13]	;GET SHARE COUNT
	CAIE 2,1
	JRST 0(4)
	JRST 1(4)

;PRELIMINARY FORK INIT

FKSET:	MOVE 1,PSB+PSBPG	;SETUP USER MAP WORD
	MOVEM 1,PSB+UACPG	;SAME AS PSB UNTIL OVERFLOW
	MOVE 1,[IOWD NUPDL,UPDL]
	MOVEM 1,UPP		;MON ROUTINES PDL
	MOVE 1,[IOWD 1000,PSIPGA]
	MOVEM 1,PSIPT		;PSI STORAGE STACK
	MOVEI 1,<UACB>B39	;SETUP AC BASE
	MOVEM 1,ACBAS
	MOVEM 1,ACBAS1
	SETACB 1
	MOVE 1,INTDF0		;INTERRUPT SWITCHES
	MOVEM 1,INTDFF
	MOVE 1,MJRST0
	MOVEM 1,MJRSTF
	SETZM NSKED
	MOVE 1,RSKEDN
	MOVEM 1,RSKED
	MOVSI 1,<UMOVEM 1,0>B53
	MOVEM 1,PATU40		;SETUP INSTRUCTION PART FOR COMPAT
	MOVEM 1,PATUPC		;ENTRY PROCEDURE
	SETOM SLOWF
	SETOM INTDF
	SETOM TRAPC
	SETOM FKTAB
	MOVEI 1,FKTAB+1
	HRLI 1,-1(1)
	BLT 1,FKTAB+NLFKS/2-1
	MOVE 2,FORKX
	HLRZ 1,FKPGS(2)		;GET SPTN OF PAGE TABLE
	LSH 1,^D9		;CONSTRUCT SHARE POINTER
	TLO 1,RWXB-XCTB+SHRBIT
	MOVEM 1,PSB+UPTPG
	MOVE 6,FORKX
	TLNE 7,NEWJBF		;NEW JOB TOO?
	JRST FKSET1		;YES
	HRRZ 1,FKJOB(6)		;GET JSB
	MOVSI 2,1B31
	ADDM 2,SPT(1)		;BUMP SHARE COUNT
	LSH 1,^D9
	TLO 1,RWXB+SHRBIT	;CONSTRUCT SHARE POINTER
	MOVEM 1,PSB+JSBPG
	MOVEI 1,FKSET2
FKSET3:	MOVEM 1,PIPC
	SETZM PIOLDS
	MOVE 1,PSB+JSBPG	;GET JSB POINTER
	TLC 1,SHRBIT+INDBIT	;MAKE INTO INDIRECT POINTER
	ADDI 1,JOBMAP-JSB+1	;FIRST WORD OF JOB PT
	MOVEI 2,PJMPG+1		;STARTING AFTER JSB,
	MOVEM 1,PSB(2)		;FILL MON MAP WITH IND POINTERS
	ADDI 2,1
	CAIGE 2,PPMPG
	AOJA 1,.-3
	JRST PIRQR		;DEBREAK - RUN IN NORMAL MODE

;INIT NEW JOB

FKSET1:	MOVEI 2,0(7)		;GET NUMBER OF CONTROLLING TTY
	MOVE 1,@FREJOB		;ASSIGN JOB NUMBER
	EXCH 1,FREJOB
	SUBI 1,JOBPT
	MOVEM 1,JOBNO
	HRLM 1,FKJOB(6)		;JOB NUMBER TO FORK TABLE
	MOVSM 2,JOBPT(1)	;TTY ASSIGNED TO JOB
	HRLM 1,TTFORK(2)	;JOB CONTROLLED BY TTY
	MOVE 2,FORKX
	HRRM 2,JOBPT(1)		;TOP FORK OF JOB
	SETZM JOBRT(1)		;JOB RUNTIME
	HRRZ 1,FKJOB(6)		;JSB
	LSH 1,^D9
	TLO 1,RWXB+SHRBIT
	MOVEM 1,PSB+JSBPG	;SETUP JSB
	MOVE 1,JOBNO
	HLRZ 2,JOBPT(1)		;CONTROLLING TTY
	MOVEM 2,CTRLTT		;IN JSB
	MOVEI 1,EXEC0
	JRST FKSET3

FKSET2:	SETZ 0,			;START WITH 0 AC'S
	MOVEI 17,1
	BLT 17,16
	SETZ 17,
	JSYS ENSKED
	MOVSI 1,UMODF
	MOVEM 1,PPC
	MOVEI 1,JRET
	JRST DISMSE

INTDF0:	SOS INTDF		;NORMAL CONTENTS OF INTDFF
MJRST0:	JRSTF @FPC		;NORMAL CONTENTS OF MJRSTF
CHNSON:	EXP 1B9+1B11+1B15+1B16+1B17+1B18+1B20	;ALWAYS ON PSI CHANS

;PSEUDO-INTERRUPT SYSTEM

NEWFKF==1B20			;INITIATE NEW FORK - PI FLAG
NEWJBF==1B21			;INITIATE NEW JOB - PI FLAG
PSIIF==1B22			;CHANNEL INTERRUPT REQUESTED IN FKINTB
PSIT1F==1B23			;TERMINAL CODE INTERRUPT, PHASE 1
PSIT2F==1B24			;TERMINAL CODE INTERRUPT, PHASE 2
SUSFKR==1B25			;SUSPEND FORK REQUEST
PSIWTF==1B26			;JOB WAS IN WAIT STATUS
PSILOB==1B27			;LOGOUT JOB REQUEST
FRZB1==1B28			;DIRECT FREEZE HAS BEEN DONE
FRZB2==1B29			;INDIRECT FREEZE HAS BEEN DONE
FRZBB==FRZB1+FRZB2		;BOTH BITS FOR EXTERNAL REFS

;SCHEDULER CAUSES JOB TO BE STARTED HERE ON PI REQUEST
;SAVED PC IN PIPC
;PIMSK CONTAINS INTERRUPT REQUEST WORD

PIRQ:	MOVEM P,PIAC17
	MOVEI P,PIAC		;SAVE USER AC'S
	BLT P,PIAC+NSAC
	MOVE P,PIPDL		;SET UP LOCAL STACK
	MOVE 7,PIMSK		;INTERRUPT REQUEST WORD
	MOVE 6,FORKX
	SETZ 2,
	TLNE 7,PSIWTF		;WAS JOB IN WAIT STATUS?
	MOVE 2,FKOLDS(6)	;YES, GET OLD STATUS
	MOVEM 2,PIOLDS		;SAVE OLD STATUS, OR 0 IF WAS RUNNING
	TLNE 7,NEWFKF		;START NEW FORK?
	JRST FKSET		;YES
	TLNE 7,PSIT1F
	JRST PSIT1		;TERMINAL, PHASE 1
	TLNE 7,PSIT2F
	JRST PSIT2		;TERMINAL, PHASE 2
PSITR1:	TLNE 7,PSIIF+SUSFKR+PSILOB
	JRST PSII		;CHANNEL INTERRUPT SPEC. BY FKINTB
PIRQR:	CALL UNPIR		;LEAVE PI STATE
PSIDF1:	SKIPN 1,PIOLDS		;WAS RUNNING BEFORE PSI?
	JRST SCHED0		;YES
	JRST DISMSE		;NO, REPLACE ON WAIT LIST

UNPIR:	AOS INSKED		;ENTER SCHEDULER
	MOVE 1,[XWD PIAC,PAC]
	BLT 1,PAC+NSAC		;PUT AC'S BACK
	MOVE 1,PIAC17
	MOVEM 1,PAC+17
	MOVE 1,PIPC
	MOVEM 1,PPC
	MOVSI 1,200000
	MOVE 7,FORKX
	ANDCAM 1,FKINT(7)
	RET

PIPDL:	IOWD NPIPDL,PIPDB	;INTERRUPT ROUTINES LOCAL PDL

;REQUEST INTERRUPT
;AC1 CONTAINS INTERRUPT NUMBER
;AC2 CONTAINS FORK INDEX

PSIRQ0:	MOVE 2,FORKX		;REQUEST INTERRUPT IN CURRENT FORK
PSIRQF:	NOSKED			;REQUEST INTERRUPT, FORK IN AC2
	CALL PSIRQ
	OKSKED
	RET

;ENTERED FROM SCHEDULER REQUEST PROCESSOR

PSIRQ:	MOVE 1,BITS(1)
PSIRQB:	IORM 1,FKINTB(2)	;SET BIT IN INTERRUPT WAITING BUFFER
PSITQ:	MOVSI 1,400000+PSIIF	;REGULAR INTERRUPT FLAG
	IORM 1,FKINT(2)
	CAMN 2,FORKX		;FOR THIS FORK?
	RET			;YES
PSIR4:	HLRZ 1,FKPT(2)		;NO, GET STATUS OF FORK
	CAIL 1,NBP		;IN BAL SET, OR
	CAIN 1,GOLST		;ON GOLIST?
	JRST PSIR6		;YES
TTPS1:	AOS ISKED		;CAUSE CHECK OF WAITING FORKS
	RET

;SET NEW SCHED STATUS FOR PSI'D FORK

PSIR6:	PUSH P,7
	MOVEI 7,0(2)
	HLRZ 1,FKSTAT(7)	;CURRENT QUEUE
	CAIG 1,1		;HIGH ONES?
	JRST [	CALL NEWST1	;YES, REINIT
		JRST PSIR61]
	PUSH P,3
	PUSH P,4
	CALL NEWST5		;SET SHORT QUANTUM, HIGH PRIORITY
	POP P,4
	POP P,3
PSIR61:	MOVEI 2,0(7)
	POP P,7
	RET

;TERMINAL INTERRUPT
;PHASE ONE - CALLED FROM TERM SERVICE ROUTINES
; 2/ LINE NO.,   3/ INTERRUPT CODE
;SEND TO TOP FORK TO FIND PROPER DESTINATION

TTPSRQ:	HLRZ 2,TTFORK(2)	;GET JOB USING THIS TTY
	ANDCMI 2,600000		;FLUSH EXTRANEOUS BITS
	HRRZ 2,JOBPT(2)		;GET INDEX OF TOP FORK
	MOVSI 1,1B18+PSIT1F	;PHASE ONE REQUEST
	IORM 1,FKINT(2)
	HRRM 3,FKINT(2)		;INTERRUPT CODE
	JRST PSIR4		;SET NEW STATUS

;ROUTINES TO HANDLE INTERRUPT CONDITIONS AS SPECIFIED BY BITS
;IN LEFT HALF OF FKINT

;TERMINAL INTERRUPT, PHASE ONE
;THIS CODE RUN IN TOP FORK ONLY

PSIT1:	MOVE 6,BITS(7)
	HLRZ 1,FORKN		;START WITH TOP FORK
	SETO 5,
	TDNE 6,FKPSIE(1)	;TERM CODE ON IN FORK?
	MOVEI 5,0(1)		;YES, REMEMBER FORK
	CALL PSIT1A		;LOOK AT ALL INFERIORS
	JUMPL 5,[ANDCAM 6,TTSPSI ;NOT FOUND, SO TURN OFF CODE
		SKIPL 2,CTRLTT
		ANDCAM 6,TTPSI(2)
		JRST PSITR1]
	HRRZ 2,SYSFK(5)		;GET SYSTEM INDEX OF FORK TO GET INTERPT
	CAMN 2,FORKX		;THIS FORK?
	JRST PSIT2		;YES, GO DIRECTLY TO PHASE TWO
	NOSKED
	HRRM 7,FKINT(2)		;NO, SETUP TO INTERRUPT PROPER FORK
	MOVSI 1,PSIT2F+400000	;PHASE TWO REQUEST FLAG
	IORM 1,FKINT(2)
	CALL PSIR4
	OKSKED
	JRST PSITR1

;SEARCH FORK STRUCTURE FOR FORK TO INTERRUPT

PSIT1A:	ADD 1,INFERP		;LOOK AT INFERIOR LIST
PSIT1B:	LDB 1,1			;GET NEXT IN LIST
	JUMPE 1,R		;RETURN AT END OF LIST
	HRRZ 2,SYSFK(1)		;CHECK STATE OF FORK
	HLL 2,FKPT(2)
	HRR 2,FKSTAT(2)
	CAMN 2,[XWD WTLST,FRZWT] ;FROZEN?
	JRST PSIT1C		;YES, SKIP IT AND ITS INFERIORS
	TDNE 6,FKPSIE(1)	;FORK HAS CODE ENABLED?
	MOVEI 5,0(1)		;YES, REMEMBER IT
	HRLM 1,0(P)		;REMEMBER CURRENT FORK
	CALL PSIT1A		;CHECK INFERIORS
	HLRZ 1,0(P)		;RECOVER CURRENT
PSIT1C:	ADD 1,PARALP		;DO PARALLELS
	JRST PSIT1B

;FORK STRUCTURE POINTERS

SUPERP:	POINT 12,FKPTRS,11	;SUPERIOR
PARALP:	POINT 12,FKPTRS,23	;PARALLEL
INFERP:	POINT 12,FKPTRS,35

;TERMINAL INTERRUPT, PHASE TWO

PSIT2:	MOVEI 1,0(7)
	CALL GETCHA
	LDB 2,2
	MOVE 1,BITS(2)		;AND SET BIT IN INT. WAITING WORD
	AND 1,PSICHM		;BUT ONLY FOR ENABLED CHANNELS
	IORM 1,PSIBW
	JRST PSII		;THEN GO PROCESS IT

;SUSPEND FORK REQUEST

PIRSFK:	MOVE 1,PIPC
	CALL PITEST		;NOW INTERRUPTABLE?
	JRST PIRSF1		;NO
	MOVEI 3,SUSWT		;SUSPENDED FORK TEST
PIRSK1:	MOVE 2,FORKX
	MOVSI 1,SUSFKR
	ANDCAM 1,FKINT(2)
	CALL UNPIR		;LEAVE INTERRUPT STATE
	IORM 1,FKINT(7)		;KEEP INTERRUPT STARTING BIT
	MOVEI 1,0(3)		;SUSWT OR FRZWT
	HRL 1,PIOLDS		;WITH OLD STATUS
	JRST DISMSE		;DISMISS

PIRSF1:	MOVE 7,FORKX
	MOVSI 1,SUSFKR		;TURN REQUEST BIT BACK ON
	IORM 1,FKINT(7)
	JRST PSIDFR		;AND SET DEFERRED INTERRUPTS

SUSWT:	JRST 0(4)		;SCHEDULER TEST FOR SUSPENDED FORK

;LOGOUT REQUEST

PIRLGO:	MOVE 1,PIPC
	CALL PITEST		;OK TO INTERRUPT?
	JRST [	MOVE 7,FORKX	;NO, REMEMBER REQUEST
		MOVSI 1,PSILOB
		IORM 1,FKINT(7)
		JRST PSIDFR]
	SETZM PIOLDS		;MAKE FORK RUNNABLE
	MOVEI 1,FLOGO
	EXCH 1,PIPC
	SKIPGE SLOWF
	JRST [	MOVEM 1,FPC	;IN USER MODE, SIMULATE JSYS
		JRST PIRQR]
	MOVE 2,PIAC17		;IN MON MODE, SIMULATE PUSHJ
	PUSH 2,1
	MOVEM 2,PIAC17
	JRST PIRQR

;PROCESS INTERRUPT(S) FOR THIS FORK AS SPECIFIED BY FKINTB

PSII:	MOVE 1,MJRST0		;NORMALIZE ALL DEFER TRAPS
	MOVEM 1,MJRSTF
	MOVE 1,INTDF0
	MOVEM 1,INTDFF
	TLNE 7,SUSFKR		;FORK SUSPENSION REQUEST?
	JRST PIRSFK		;YES
	TLNE 7,PSILOB		;LOGOUT REQUEST?
	JRST PIRLGO
	MOVE 2,FORKX
	MOVEI 1,0
	EXCH 1,FKINTB(2)	;RESET FKINTB TO 0
	MOVE 2,PSICHM		;USERS ENABLED CHANNELS
	IOR 2,CHNSON		;WITH ALWAYS ON CHANNELS
	IOR 2,SUPCHN		;WITH SUPERIOR RESERVED CHANNELS
	AND 1,2			;FLUSH DISABLED CHANNELS
	IORB 1,PSIBW		;SET BITS IN BREAK WAITING WORD
	JUMPE 1,PIRQR		;RETURN IF NO BREAKS WAITING
	MOVE 1,PIPC		;PROCESS PC
	CALL PITEST		;CAN PROCESS BE INTERRUPTED NOW?
	JRST PSIDFR		;NO, GO SETUP DEFERRED INTERRUPT
PSIS:	MOVE 1,PSIBW
	TDNE 1,MONCHN		;MONITOR RESERVED CHANNEL?
	JRST PSIMB		;YES
	AND 1,SUPCHN		;LOOK AT SUPERIOR RESERVED CHANS
	JUMPN 1,PSIN1		;TERMINATE IF ANY
	MOVE 1,PSIBW
	AND 1,CHNSON		;LOOK AT SPECIAL CHANNELS
	SKIPE PSISYS		;IF THIS PROCESS NOT TAKING PSI'S,
	JUMPN 1,PSIN1		;TERMINATE IT IF ANY SPECIALS
	ANDCM 1,PSICHM		;AND'ING WITH USER'S 'OFF' CHANNELS
	JUMPN 1,PSIN1		;TERMINATE CAUSE CHANNEL NOT ACTIVE
	SKIPE PSISYS		;PSI SYSTEM ON?
	JRST PIRQR		;NO
	SKIPN LEVCHN		;THIS PROCESS TAKING INTERRUPTS?
	JRST PSIN1		;NO, GO TRANSMIT THE PSI
	MOVE 1,PSIBW		;FIND HIGHEST PRIORITY INTERRUPT
	MOVEI 2,0		;NOW WAITING
	MOVSI 3,1
PSIS1:	JUMPL 1,PSIS2		;THIS CHANNEL HAS WAITING BREAK?
PSIS4:	LSH 1,1			;NO, SHIFT TO NEXT CHANNEL
	ADDI 2,1		;COUNT CHANNEL NUMBER
	JUMPN 1,PSIS1		;KEEP LOOKING IF ANY BITS LEFT

;AC3 NOW CONTAINS LEVEL OF HIGHEST PRIORITY INTERRUPT FOUND
;AC5 CONTAINS CORRESPONDING CHANNEL NUMBER

	JUMPE 3,PSID1		;NO LEVEL ASSIGNED? GO XMIT INTERRUPT
	CAILE 3,NPILEV		;LEGAL LEVEL?
	JRST PSID2		;NO, SPECIAL ACTION
	MOVE 1,BITS(3)
	CAMG 1,PSIBIP		;OK TO BREAK ON THIS LEVEL?
	JRST PIRQR		;NO, EQUAL OR HIGHER LEVEL IN PROGRESS
	IORM 1,PSIBIP		;YES, REMEMBER  BREAK THIS LEVEL
	HRRZ 1,LEVCHN		;GET ADR OF USER'S CHANNEL TABLE
	ADDI 1,0(5)		;COMPUTE ADR OF USER'S CHANNEL WORD
	UMOVE 1,0(1)		;GET ADR OF USER'S INT ROUTINE
	HRLI 1,UMODF		;USER MODE ON, OTHER FLAGS OFF
	EXCH 1,PIPC		;SET TO START THERE, GET OLD PC
	TLNE 1,UMODF		;WAS IN USER MODE?
	JRST PSIS5		;YES

;SPECIAL ROUTINE TO SAVE STATE OF INTERRUPTED MONITOR
;ROUTINE

	MOVS 2,BITS(3)		;NO, REMEMBER MONITOR INTERRUPT
	IORM 2,PSIBIP		;IN RH OF BIP WORD
	MOVE 7,PSIPT		;STORAGE STACK POINTER
	HLRE 6,7		;SEE IF ENOUGH ROOM
	MOVN 6,6		;GET POSITIVE COUNT
	CAIGE 6,NUPDL+<EUACB-UACB>+30
	BUG(HLT,<PSI STORAGE STACK OVERFLOW>)
	MOVE 10,7		;SAVE POINTER
	PUSH 7,1
	PUSH 7,40
	PUSH 7,60
	PUSH 7,MPP
	PUSH 7,FPC
	PUSH 7,PIOLDS
	PUSH 7,XMENTR
	MOVSI 6,UPDL		;STORE ENTIRE MONITOR STACK
	HRRI 6,1(7)
	ADD 7,[XWD NUPDL,NUPDL]
	BLT 6,0(7)
	MOVSI 1,PIAC		;STORE CURRENT MONITOR AC'S
	HRRI 1,1(7)		;NOW LIVING IN PIAC
	ADD 7,[XWD 20,20]
	BLT 1,0(7)
	HRRZ 1,ACBAS		;STORE ALL AC BLOCKS IN USE
	HRRZ 2,ACBAS1
	SUBI 1,-1(2)		;COMPUTE NUMBER OF BLOCKS IN USE
	LSH 2,^D18+4
	MOVE 4,2
	HRRI 2,1(7)
	LSH 1,4
	HRLI 1,0(1)		;NUMBER OF WORDS BOTH HALFS
	ADD 7,1
	BLT 2,0(7)
	PUSH 7,1		;SAVE COUNT FOR DEBRK
	PUSH 7,ACBAS		;AND CURRENT ACBAS
	HRRI 4,PIAC		;RECOVER USER AC'S AT TIME OF MON CALL
	BLT 4,PIAC+17
	MOVE 1,UPDL		;USER PC AT MONITOR CALL
	PUSH 7,10		;PSI STACK BEFORE ALL THIS PUSHING
	PUSH 7,1
	MOVEM 7,PSIPT
	TLZ 1,UMODF		;SO HE CAN TELL IT WAS MON INTERRUPT
	SETOM SLOWF

PSIS5:	SETZM PIOLDS
	HLRZ 2,LEVCHN		;GET ADR OF USER'S LEVEL TABLE
	ADDI 2,-1(3)		;COMPUTE ADR OF USER'S LEVEL WORD
	UMOVE 2,0(2)		;GET ADR OF PC WORD FOR THIS LEVEL
	TRNN 2,777760		;ADDRESS IS AC?
	MOVEM 1,PIAC(2)		;YES, STRANGE BUT ALLOW IT
	TRNE 2,777760		;NORMALLY,
	UMOVEM 1,0(2)		;STORE BREAK PC IN USER'S MEMORY
PSID3:	MOVE 1,BITS(5)		;CLEAR WAITING BREAK BIT FOR THIS CHANNEL
	ANDCAM 1,PSIBW
	JRST PIRQR		;TO USER

PSIS2:	HRRZ 4,LEVCHN		;GET ADR OF USER'S CHANNEL TABLE
	ADDI 4,0(2)		;COMPUTE ADR OF USER'S CHANNEL WORD
	XCTUU [HLRZ 4,0(4)]	;GET LEVEL NUMBER FOR THIS CHANNEL
	CAIG 3,0(4)		;OLD LEVEL GREATER THAN CURRENT?
	JRST PSIS4		;NO
	MOVEI 3,0(4)		;YES, REMEMBER NEW LEVEL
	MOVEI 5,0(2)		;AND CHANNEL NUMBER
	JRST PSIS4		;RESUME SCAN

;SPECIAL ACTION (NOT LEVEL NUMBER) IN LH OF CHN+C

PSID2:	JRST PSID3		;IGNORE INTERRUPT

;MONITOR ROUTINE IS SHORTSTOPPING INTERRUPTS - SIMULATE  JSYS MONBK

PSIMB:	HRRZ 1,MONBK		;ROUTINE ADDRESS
	EXCH 1,PIPC		;GET OLD PC
	SETZM PIOLDS
	HLRZ 2,MONBK		;RET LOC
	MOVEM 1,0(2)		;STORE RETURN
	JRST PIRQR

;XMIT INTERRUPT TO SUPERIOR FORK

PSIT:	HRRZ 2,FORKN
	MOVE 2,FKPTRS(2)	;POINTERS RELATIVE TO FORK
	LSH 2,-^D24		;SUPERIOR FORK POINTER
	HRRZ 2,SYSFK(2)		;SYSTEM FORK INDEX
	JRST PSIRQF		;REQUEST INTERRUPT

;THIS FORK WON'T TAKE INTERRUPT, DISMISS IT AND RECORD WHY

PSID1:	MOVEI 2,0(5)		;CHANNEL WITH NO LEVEL ASSIGNED
	JRST PSIN2

PSIN1:	MOVE 1,PSIBW		;INTERRUPTS OFF OR NO LEVCHN
	JFFO 1,.+1		;CALCULATE CHANNEL NUMBER
PSIN2:	MOVEM 2,FORCTC		;SAVE CHANNEL NUMBER FOR STATUS
	MOVE 1,BITS(2)		;JUST ONE CHANNEL AT A TIME
	ANDCAM 1,PSIBW		;RESET WAITING BIT
	CALL FKTMI		;GIVE FORK TERM INTERRUPT
	MOVEI 3,FRZWT		;FORK FROZEN STATE TEST
	MOVE 1,CAPENB
	TLNE 1,(1B17)		;SUPERIOR WANTS FROZEN STEAD HALT?
	JRST PIRSK1		;YES, GO FREEZE
	CALL UNPIR		;LEAVE PI STATE, MOVE AC'S ETC.
	MOVE P,PI7P
	MOVEI 1,FORCTM
	JRST DISMSE		;THIS ONE IS BEING DISMISSED

FORCTM:	JRST 0(4)		;SCHEDULER TEST FOR FORCED TERM FORK

;INTERRUPT SUPERIOR FORK ON TERMINATION

FKTMI:	PUSH P,1
	HRRZ 1,FORKN
	SKIPN 1
	SKIPA 1,[^D35]		;TERMINATING TOP FORK, GIVE CH 35
	MOVEI 1,^D19		;19 IS FORK TERMINATED
	CALL PSIT		;TRANSMIT IT
	POP P,1
	RET

GETCHA:	MOVEI 2,0(1)
	IDIVI 2,6
	ADDI 2,PSICHA
	HLL 2,CH6TAB(3)
	RET

;DEFERRED INTERRUPT LOGIC
;SET TRAPS TO RECHECK INTERRUPTS WHEN STATE CHANGES

PSIDFR:	MOVE 1,MJRST1
	MOVEM 1,MJRSTF
	MOVE 1,INTDF1
	MOVEM 1,INTDFF
	CALL UNPIR		;LEAVE BREAK STARTING STATE
	IORM 1,FKINT(7)		;BUT LEAVE PENDING BIT
	JRST PSIDF1		;RESUME

MJRST1:	JRSTF @[PSISV0]
INTDF1:	JSYS PSISV1

PSISV1:	XWD PIPC,.+1
	SOS INTDF
	JRSTF @[PSISV2]

PSISV0:	MOVEM 1,PIPC		;SAVE AC1
	MOVE 1,FPC		;FPC NOW CONTAINS USER'S PC
	EXCH 1,PIPC
PSISV2:	MOVEM P,PIAC17		;SAVE USER'S AC17
	MOVEI P,PIAC		;AND AC'S 0-NSAC
	BLT P,PIAC+NSAC
	MOVE P,PIPDL		;RESTORE INTERRUPT STARTING STATE
	SETZM PIOLDS
PSISV3:	MOVE 2,FORKX
	MOVE 7,FKINT(2)
	JRST PSII		;ENTER MAIN SEQUENCE

;TEST FOR IMMEDIATE OR DEFERRED INTERRUPT
;SKIP => IMMEDIATE
;NOSKIP => DEFERRED
;CALLED WITH TEST USER PC IN AC1

PITEST:	TLNE 1,UMODF		;USER MODE?
	JRST RSKP		;YES, IMMEDIATE
	SKIPL SLOWF		;NO, SLOW CODE?
	SKIPL INTDF		;YES, INTERRUPTABLE
	RET			;NO, DEFER
	SKIPN NSKED		;IN CASE NOSKED W/O NOINT
	SKIPL TRAPC		;IN PAGER TRAP, OR
	RET			;YES, DEFER
	JRST RSKP		;IMMEDIATE

;DEBREAK

.DEBRK:	SKIPN PSIBIP		;ANY BREAKS IN PROGRESS?
	XCT MJRSTF		;NO, ACTS AS NOP
	MOVEM 1,TW1		;SAVE USER AC1,2
	MOVEM 2,TW2
	MOVE 2,FORKX
	MOVSI 1,200000
	IORM 1,FKINT(2)		;SET INTERRUPT STARTING BIT
	MOVE 2,TW2
	MOVE 1,TW1
	MOVEM P,PIAC17		;ENTER INTERRUPT STARTING STATE
	MOVEI P,PIAC
	BLT P,PIAC+NSAC
	MOVE P,PIPDL
	SETZM PIOLDS
PSIDBK:	MOVE 2,PSIBIP		;BREAKS NOW IN PROGRESS
	JFFO 2,.+2		;FIND HIGHEST ONE
	JRST 4,.		;IMPOSSIBLE
	HLRZ 1,LEVCHN		;COMPUTE ADDRESS OF RETURN PC
	ADDI 1,-1(3)
	UMOVE 1,0(1)
	TRNN 1,777760		;ADDRESS IS AC?
	SKIPA 1,PIAC(1)		;YES
	UMOVE 1,0(1)		;GET RETURN PC FROM USER MEMORY
	MOVS 2,BITS(3)
	TDNE 2,PSIBIP		;WAS THIS MONITOR INTERRUPT?
	JRST PSIS7		;YES, GO UNWIND
PSIS8:	TLZ 1,7637		;FLUSH TROUBLESOME BITS
	TLO 1,UMODF		;MAKE SURE USER MODE IS ON
	MOVEM 1,PIPC		;SET TO DEBREAK AT THAT ADDRESS
PSIS6:	MOVE 1,BITS(3)
	ANDCAM 1,PSIBIP		;CLEAR BIP THIS LEVEL
	JRST PSISV3		;GO CHECK FOR OTHER INTERRUPTS AND RETURN

PSIS7:	ANDCAM 2,PSIBIP		;CLEAR MON BREAK FLAG FOR THIS LEVEL
	MOVE 7,PSIPT
	POP 7,4			;PC GIVEN TO USER
	POP 7,PSIPT		;TOP OF THIS BLOCK OF PSI STORAGE
	TLON 1,UMODF		;IF IT WAS DIDDLED AT ALL,
	CAME 1,4
	JRST PSIS8		;DON'T RESUME MON ROUTINE
	POP 7,2
	MOVEM 2,ACBAS
	SETACB 2
	POP 7,4
	SUB 7,4
	HRRZ 5,ACBAS1
	LSH 5,4
	MOVE 2,5		;SAVE ACB ADDRESS
	HRLI 5,1(7)
	ADDI 4,0(5)
	BLT 5,-1(4)		;RESTORE AC BLOCKS
	MOVSI 5,PIAC		;PUT USER CURRENT AC'S INTO TOP BLOCK
	HRRI 5,0(2)
	BLT 5,17(2)
	SUB 7,[XWD 20,20]
	MOVEI 2,PIAC
	HRLI 2,1(7)
	BLT 2,PIAC+17		;RESTORE MONITOR AC'S
	SUB 7,[XWD NUPDL,NUPDL]
	MOVEI 2,UPDL
	HRLI 2,1(7)
	BLT 2,UPDL+NUPDL-1	;RESTORE STACK
	POP 7,XMENTR
	POP 7,PIOLDS
	POP 7,FPC
	POP 7,MPP
	POP 7,60
	POP 7,40
	POP 7,PIPC		;ACTUAL MON INTERRUPT PC
	SETZM SLOWF
	SETOM INTDF
	JRST PSIS6		;NOW DEBRK

 u@(