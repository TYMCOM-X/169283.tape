TITLE ALGOTS 2B(146) - ALGOL OBJECT TIME SYSTEM - R. M. DE MORGAN, SEP 1972
SUBTTL ASSEMBLY SWITCHES AND GLOBALS

; COPYRIGHT 1971,1972 DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.



;;; "SEQUI IL TUO CORSO, E LASCIA DIR LE GENTI" - MACCHIAVELLI.



	SEARCH ALGPRM,ALGSYS	; SEARCH PARAMETER FILES

	INTERNAL .JBOPS,.JBVER

	LOC	.JBVER
	EXP	VERNO		; VERSION NUMBER

	RELOC

	ENTRY %ALGDR

	IF2, <
	IFE PROC-KA10, <PRINTX KA10 VERSION>
	IFE PROC-KI10, <PRINTX KI10 VERSION>
	IFN DUMP, <PRINTX DUMP ROUTINE LOADED>
	IFE DUMP, <PRINTX DUMP ROUTINE NOT LOADED>>

	EXTERNAL .JBUUO,.JB41,.JBREL,.JBHRL,.JBSA
	EXTERNAL .JBFF,.JBAPR,.JBCNI,.JBTPC,.JBOPC

	MLON

	SALL
SUBTTL NORMAL TYPE CONVERSION MACROS

; CONVERTS ARGUMENT IN A0 OR A0,A1 INTO RESULT IN A0 OR A0,A1

; CALLING VERSIONS

	DEFINE CIR		; CONVERT INTEGER TO REAL
<	IFE PROC-KA10, <
	JSP	AX,IR>
	IFE PROC-KI10, <
	FLTR	A0,A0>
>

	DEFINE CILR		; CONVERT INTEGER TO LONG REAL
<	JSP	AX,ILR
>

	DEFINE CRI		; CONVERT REAL TO INTEGER
<	IFE PROC-KA10, <
	JSP	AX,RI>
	IFE PROC-KI10, <
	FIXR	A0,A0>
>

	DEFINE CLRI		; CONVERT LONG REAL TO INTEGER
<	JSP	AX,LRI
>

	DEFINE CLRR		; CONVERT LONG REAL TO REAL
<	IFE PROC-KA10, <
	FADR	A0,A1>
	IFE PROC-KI10, <
	JSP	AX,LRR>
>
; JUMP VERSIONS WITH REMOTE LINK

	DEFINE JCIR(A)
<	IFE PROC-KA10, <
	HRRI	AX,A
	JRST	IR>
	IFE PROC-KI10, <
	FLTR	A0,A0
	JRST	A>
>

	DEFINE JCILR(A)
<	HRRI	AX,A
	JRST	ILR
>

	DEFINE JCRI(A)
<	IFE PROC-KA10, <
	HRRI	AX,A
	JRST	RI>
	IFE PROC-KI10, <
	FIXR	A0,A0
	JRST	A>
>

	DEFINE JCLRI(A)
<	HRRI	AX,A
	JRST	LRI
>

	DEFINE JCLRR(A)
<	IFE PROC-KA10, <
	FADR	A0,A1
	JRST	A>
	IFE PROC-KI10, <
	HRRI	AX,A
	JRST	LRR>
>
SUBTTL SPECIAL TYPE CONVERSION ROUTINES

; CONVERTS ARGUMENT IN A0 OR A0,A1 INTO RESULT IN A3 OR A3,A4

	DEFINE SCIR
<	IFE PROC-KA10, <
	JSP	AX,SIR>
	IFE PROC-KI10, <
	FLTR	A3,A0>
>

	DEFINE SCILR
<	JSP	AX,SILR
>

	DEFINE SCRI
<	IFE PROC-KA10, <
	JSP	AX,SRI>
	IFE PROC-KI10, <
	FIXR	A3,A0>
>

	DEFINE SCLRI
<	JSP	AX,SLRI
>

	DEFINE SCLRR
<	JSP	AX,SLRR
>
SUBTTL ROUTINE DIRECTORY

	%ALGDR=.		; IF THIS LABEL IS NOT DEFINED
				; REFERENCES TO IT ARE GENERATED BY
				; MACRO EXPANSIONS ON PASS 1

	LALL
	ALGDIR			; CALL ALGDIR MACRO

	SALL
SUBTTL APR TRAP AND PC FLAGS

; APR TRAP FLAGS

	APRO=000010		; ARITHMETIC OVERFLOW
	APRFPO=000100		; FLOATING POINT OVERFLOW
	APRNXM=010000		; NONEXISTENT MEMORY
	APRMPV=020000		; MEMORY PROTECT VIOLATION
	APRPLO=200000		; PUSHDOWN LIST OVERFLOW
	APRLOK=400000		; TRAP LOCK

	APRFLG=APRO!APRFPO!APRNXM!APRMPV!APRPLO!APRLOK

; PC FLAGS

	PCNDIV=000040		; NO DIVIDE
	PCFPU=000100		; FLOATING POINT UNDERFLOW
	PCFPO=040000		; FLOATING POINT OVERFLOW
	PCO=400000		; ARITHMETIC OVERFLOW

	PCOVL=PCNDIV!PCFPO!PCO
SUBTTL MASTER CONTROL ROUTINE

; ENTERED FROM ALGOBJ (IN ALGLIB) WITH
; LH(A0): HEAP SIZE (%HEAP)
; RH(A0): OWN CHAIN (%OWN)
; LH(A1): 0
; RH(A1): ADDRESS OF %ALGDA
; LH(AX): BIT 0 = 0 FOR START
;	        = 1 FOR REENTER
; RH(AX) = ADDRESS OF %BEGIN

INITIA:	CALLI	RESET		; INITIALIZE IO
	HLRZ	A3,.JBSA	; HEAP ORIGIN
	HLRZ	A4,A0		; HEAP SIZE
	CAIGE	A4,^D521
	MOVEI	A4,521		; ENSURE MINIMUM
	MOVEI	DB,(A3)
	ADDI	DB,(A4)		; DATA BASE
	MOVEM	DB,.JBOPS	; SAVE COPY
	MOVEI	SP,%DBL-1(DB)	; STACK ORIGIN
	MOVEI	A2,2(SP)
	CAMG	A2,.JBREL	; WILL STACK FIT IN CORE?
	JRST	INIT1		; YES
	CALLI	A2,CORE		; NO - TRY TO EXPAND CORE
	JRST	[
	TTCALL	3,M201		; FAILED
	CALLI	1,EXIT
	JRST	.-5]		; TRY AGAIN IF "CONT"

INIT1:	HRLZI	A2,(A3)
	HRRI	A2,1(A3)
	SETZM	(A3)
	BLT	A2,@.JBREL	; CLEAR OUT DATA BASE AND STACK
	HRLZM	A4,(A3)		; FILL IN HEAP SIZE
	MOVEM	A3,%SYS2(DB)	; AND INITIALIZE HEAP CHAIN
	SETOM	%CHAN(DB)	; SELECT CHANNEL -1
	MOVEM	AX,%SYS0(DB)	; SAVE ENTRY POINT AND FLAGS
	HRL	A1,.JBREL	; SAVE INITIAL CORE SIZE
	MOVEM	A1,%SYS1(DB)	; AND LIBRARY ORIGIN
	MOVN	A1,.JBREL
	ADDI	A1,(SP)
	HRLI	SP,(A1)		; SET UP COUNT FOR PUSH DOWN OVERFLOW
	HRLZI	A1,IOTTC
	HRRI	A1,%TTY(DB)
	MOVEM	A1,%IODR-1(DB)	; INITIALIZE CHANNEL -1
INIT2:	HRRZ	A1,A0		; NEXT OWN AREA
	HLRZ	A2,(A1)		; GET ITS LENGTH
	SOJLE	A2,INIT3	; EMPTY?
	SETZM	1(A1)		; NO - ZERO FIRST FREE WORD
	SOJE	A2,INIT3	; ANY MORE
	HRLZI	A0,1(A1)	; YES
	HRRI	A0,2(A1)	; PREPARE FOR BLT
	ADDI	A2,1(A1)	; SET UP END ADDRESS
	BLT	A0,(A2)		; AND ZERO AREA

INIT3:	HRRZ	A0,(A1)
	JUMPN	A0,INIT2	; KEEP GOING IF MORE
	CALLI	A0,DATE
	MOVEM	A0,%SYS3(DB)	; SAVE DATE IN %SYS3
	CALLI	A0,MSTIME
	MOVEM	A0,%SYS4(DB)	; SAVE TIME OF DAY IN %SYS4
	MOVEI	A0,0
	CALLI	A0,RUNTIM
	MOVEM	A0,%SYS5(DB)	; SAVE RUNTIME IN %SYS5
	HRLZI	A0,%ES-%DBL
	HRRI	A0,%ES-1(DB)
	MOVEM	A0,%ESP(DB)	; SET UP EMERGENCY STACK POINTER
	MOVE	A0,[
	JRST	UUO]
	MOVEM	A0,%UUO+1(DB)
	HRLZI	A0,<JSR>B53
	HRRI	A0,%UUO(DB)
	MOVEM	A0,.JB41	; SET UP UUO TRAP
	MOVEI	A0,APRERR
	MOVEM	A0,.JBAPR	; SET APR TRAP ADDRESS
	MOVEI	A0,APRFLG
	CALLI	A0,APRENB	; AND ENABLE TRAPS
	MOVEI	A0,FM6
	MOVEM	A0,.JBREN	; SET REENTER ADDRESS
	JUMPL	AX,FM0		; REENTER?
INIT4:	MOVEI	DL,0		; SET UP FOR LOCAL STACK
	PUSHJ	SP,@%SYS0(DB)	; AND ENTER PROGRAM
	XWD	$PRO!$N!$SIM,1

; *************************	; PROGRAM EXECUTES (HOPEFULLY!)

INIT5:	MOVEI	A1,37

INIT6:	PUSHJ	SP,RELESE	; RELEASE IO CHANNELS
	JFCL	.+1
	SOJGE	A1,INIT6
	SETOM	%CHAN(DB)	; MAKE SURE WE ARE ON CHANNEL -1!!!
	PUSHJ	SP,BRKBYT	; BREAK OUTPUT ON CHANNEL -1
	JFCL	.+1

	MOVEI	A1,END1
	PUSHJ	SP,MONIT
	MOVE	A0,.JBREL
	LSH	A0,-12
	ADDI	A0,1		; CORE SIZE IN K WORDS
	PUSHJ	SP,IPRINT	; PRINT CORE SIZE
	MOVEI	A1,END2
	PUSHJ	SP,MONIT
	MOVEI	A0,0
	CALLI	A0,RUNTIM
	SUB	A0,%SYS5(DB)	; EXECUTION TIME IN MS
	PUSHJ	SP,PRTIME	; PRINT IT
	MOVEI	A1,END3
	PUSHJ	SP,MONIT
	CALLI	A0,MSTIME
	SUB	A0,%SYS4(DB)	; ELAPSED TIME IN MS
	CALLI	A1,DATE
	SUB	A1,%SYS3(DB)	; ELAPSED DAYS
	JUMPE	A1,.+3		; NONE
	IMUL	A1,[
	EXP	^D24*^D60*^D60*^D1000]
	ADD	A0,A1		; ALLOW FOR DAYS
	PUSHJ	SP,PRTIME	; PRINT ELAPSED TIME
	HLRZ	A0,%SYS1(DB)
	CALLI	A0,CORE		; REDUCE CORE
	HALT	.
	CALLI	1,EXIT		; AND FINISH

; *************************

	JRST	.-1
END1:	ASCIZ /

END OF EXECUTION -/

END2:	ASCIZ /K CORE

EXECUTION TIME:/

END3:	ASCIZ /
ELAPSED TIME:  /
SUBTTL PRTIME - PRINT TIME ROUTINE

PRTIME:	ADDI	A0,5
	IDIVI	A0,^D10		; TIME IN 1/100'THS SECS.
	IDIVI	A0,^D6000
	JUMPE	A0,PRTIM2	; ANY MINUTES?
	PUSH	SP,A1		; YES - SAVE SECONDS
	IDIVI	A0,^D60
	JUMPE	A0,PRTIM1	; ANY HOURS?
	PUSH	SP,A1		; YES - SAVE MINUTES
	PUSHJ	SP,IPRINT	; PRINT HOURS
	MOVEI	A1,PRTIM3
	PUSHJ	SP,MONIT
	POP	SP,A1		; RESTORE MINUTES

PRTIM1:	MOVE	A0,A1
	PUSHJ	SP,IPRINT	; PRINT MINUTES
	MOVEI	A1,PRTIM4
	PUSHJ	SP,MONIT
	POP	SP,A1		; RESTORE SECONDS

PRTIM2:	MOVE	A0,A1
	HRLI	A0,233000
	FDVRI	A0,207620
	MOVEI	A2,1
	MOVEI	A3,1
	MOVEI	A4,2
	PUSHJ	SP,PRINT	; PRINT SECONDS AND 1/100'THS
	MOVEI	A1,PRTIM5
	JRST	MONIT0

PRTIM3:	ASCIZ / HRS./

PRTIM4:	ASCIZ / MINS./

PRTIM5:	ASCIZ / SECS.
/
SUBTTL MONIT - MONITOR ROUTINE

; ENTERED WITH A1 = ADDRESS OF MESSAGE AT
; MONIT IF BREAK NOT REQUIRED
; MONIT0 IF BREAK REQUIRED

DCRLF:	PUSHJ	SP,CRLF		; DOUBLE CRLF

CRLF:	MOVEI	A1,MONIT4	; SPECIAL CR-LF ENTRY
	JRST	MONIT0

MONIT:	TDZA	A0,A0		; CLEAR BREAK FLAG
MONIT0:	MOVEI	A0,1		; SET BREAK FLAG
	MOVNI	A2,1
	EXCH	A2,%CHAN(DB)	; FAKE CHANNEL -1
	HRLI	A1,440700	; PREPARE BYTE POINTER

MONIT1:	ILDB	A13,A1		; GET NEXT BYTE
	JUMPE	A13,MONIT2	; NULL?
	PUSHJ	SP,OUBYTE	; NO - OUTPUT IT
	JFCL	.+1
	JRST	MONIT1

MONIT2:	JUMPE	A0,MONIT3	; BREAK REQUIRED?
	PUSHJ	SP,BRKBYT	; YES - BREAK OUTPUT
	JFCL	.+1

MONIT3:	MOVEM	A2,%CHAN(DB)	; RESTORE IO CHANNELS
	POPJ	SP,0

MONIT4:	ASCIZ /
/
SUBTTL FAULT MONITOR

; GET ANSWER FROM TTY ROUTINE

ANSWER:	MOVNI	A1,1		; GET ANSWER ROUTINE
	EXCH	A1,%CHAN(DB)	; FAKE CHANNEL -1 INPUT
	MOVEI	A0,0		; CLEAR ACCUMULATOR

ANSW1:	PUSHJ	SP,ANSW2	; GET SYMBOL
	CAIN	A13,LF
	JRST	ANSW1		; IGNORE ANY OLD LINEFEEDS
	CAIN	A13,CR
	JRST	ANSW4		; TERMINATE ON CARRIAGE RETURN
	LSH	A0,7		; SHIFT UP ACCUMULATOR
	ADDI	A0,(A13)	; AND ADD IN SYMBOL
	JRST	ANSW1		; RETURN FOR MORE

ANSW2:	PUSHJ	SP,INBYTE	; GET SYMBOL ROUTINE
	JRST	ANSW3		; EOF
	POPJ	SP,0

ANSW3:	MOVEI	A2,INEOF
	ANDCAM	A2,%IODR-1(DB)	; CLEAR EOF FLAG

ANSW4:	MOVEM	A1,%CHAN(DB)	; RESTORE PREVIOUS IO CHANNELS
	POPJ	SP,0
; GET YES/NO ANSWER ROUTINE

; DIRECT RETURN IF "YES" (OR "Y")
; SKIP RETURN IF "NO" (OR "N")

YESNO:	PUSHJ	SP,ANSWER	; GET REPLY
	CAIE	A0,"Y"
	CAMN	A0,["YES"]
	POPJ	SP,0		; DIRECT RETURN FOR "Y" OR "YES"
	AOS	(SP)		; INCREMENT LINK IN ANTICIPATION
	CAIE	A0,"N"
	CAIN	A0,"NO"
	POPJ	SP,0		; SKIP RETURN FOR "N" OR "NO"
	SOS	(SP)		; INVALID REPLY - RESET LINK
	MOVEI	A1,YESNO1
	PUSHJ	SP,MONIT0	; TELL USER
	JRST	YESNO		; AND AWAIT ANOTHER REPLY

YESNO1:	ASCIZ /
ANSWER YES (OR Y) OR NO (OR N) /
FM0:	MOVEI	A1,FM3		; INITIAL ENTRY ON REENTER
	PUSHJ	SP,MONIT

FM1:	MOVEI	A1,FM4
	PUSHJ	SP,MONIT0	; FACILITIES?
	PUSHJ	SP,ANSWER	; GET REPLY
	CAIN	A0,"D"
	JRST	FM2		; "D" FOR "DUMP"
	CAIN	A0,"E"
	JRST	EHEAP		; "E" FOR "EXTEND HEAP"
	CAIN	A0,"G"
	JRST	INIT4		; "G" FOR "GO"
	CAIN	A0,"I"
	JRST	INT0		; "I" FOR "INTERACTIVE OPERATION"
	MOVEI	A1,FM5
	PUSHJ	SP,MONIT	; ANYTHING ELSE IS "HELP"
	JRST	FM1

FM2:	DUMPR	0,0		; DUMP PROGRAM
	JRST	FM1

EHEAP:	PUSHJ	SP,CRLF		; EXTEND THE HEAP
	MOVEI	A1,EH1
	PUSHJ	SP,MONIT0	; SIZE?
	MOVEI	A2,0
	PUSHJ	SP,READ		; GET SIZE REQUIRED
	HLRZ	A1,@%SYS2(DB)	; GET CURRENT HEAP SIZE
	CAILE	A0,(A1)		; IF NEW SIZE NOT BIGGER
	CAILE	A0,777777	; OR IS EXCESSIVELY LARGE
	JRST	EHEAP		; THEN ASK AGAIN
	HRLZM	A0,@%SYS2(DB)	; SET UP NEW LENGTH
	SUBI	A0,(A1)		; GET DIFFERENCE
	MOVEI	A2,2(SP)
	ADD	SP,A0		; MOVE UP STACK ORIGIN
	MOVEI	A3,2(SP)
	CAMLE	A3,.JBREL	; WILL NEW STACK FIT IN CORE?
	CCORE	(A3)		; NO - TRY TO EXPAND
	MOVN	A3,.JBREL
	ADDI	A3,(SP)
	HRLI	SP,(A3)		; RESET LEFT HALF COUNT
	HRLI	A2,-1(A2)
	SETZM	-1(A2)
	BLT	A2,@.JBREL	; CLEAR OUT STACK
	JRST	FM1

EH1:	ASCIZ /SIZE (WORDS)? /
FM3:	ASCIZ /ALGOL DIAGNOSTIC SYSTEM
/

FM4:	ASCIZ /
FACILITIES (H FOR HELP)? /

FM5:	ASCIZ /
FACILITIES:

D	DUMP
E	EXTEND HEAP
G	START PROGRAM
H	HELP (THIS MESSAGE)
I	INTERACTIVE OPERATION
/
FM6:	MOVEM	A0,%ACCS+A0(DB)	; LATER REENTER ENTRY
	HRLZI	A0,A1
	HRRI	A0,%ACCS+A1(DB)
	BLT	A0,%ACCS+SP(DB)	; YES - SAVE ACCUMULATORS
	MOVEI	A1,FM3
	PUSHJ	SP,MONIT

FM7:	PUSHJ	SP,CRLF

FM7A:	MOVEI	A1,FM11
	PUSHJ	SP,MONIT0	; ACTION?

FM8:	PUSHJ	SP,ANSWER	; GET REPLY
	CAIN	A0,"A"
	JRST	AN0		; "A" FOR "ANALYSIS"
	CAIN	A0,"C"
	JRST	FM9		; "C" FOR "CONTINUE"
	CAIN	A0,"D"
	JRST	FM10		; "D" FOR "DUMP"
	CAIN	A0,"F"
	JRST	INIT5		; "F" FOR "FINISH"
	MOVEI	A1,FM12
	PUSHJ	SP,MONIT	; ANYTHING ELSE IS "HELP"
	JRST	FM7

FM9:	HRLZI	A0,%ACCS+A1(DB)	; CONTINUE
	HRRI	A0,A1
	BLT	A0,SP
	MOVE	A0,%ACCS+A0(DB)	; RESTORE ACCUMULATORS
	JRSTF	@.JBOPC		; AND RETURN TO PROGRAM

FM10:	HRLZI	A0,%ACCS+A1(DB)
	HRRI	A0,A1
	BLT	A0,SP
	MOVE	A0,%ACCS+A0(DB)	; RESTORE ACCUMULATORS
	DUMPR	0,0		; AND DUMP PROGRAM
	JRST	FM7
FM11:	ASCIZ /ACTION (H FOR HELP)? /

FM12:	ASCIZ /
ACTIONS:

A	ANALYSIS
C	CONTINUE
D	DUMP
F	FINISH (TERMINATES I-O)
H	HELP (THIS MESSAGE)
/
; INTERACTIVE OPERATION

INT0:	MOVEI	A1,INT1
	PUSHJ	SP,MONIT
	JRST	FM1

INT1:	ASCIZ /
INTERACTIVE OPERATION NOT YET AVAILABLE
/
; ANALYSIS

AN0:	MOVEI	A1,AN1
	PUSHJ	SP,MONIT
	JRST	FM7

AN1:	ASCIZ /
ANALYSIS NOT YET AVAILABLE
/
SUBTTL PARAM - PROCEDURE CALL PARAMETER HANDLER

; MAGIC PARAMETER TYPE MATCH TABLE

; LH: FORMAL PARAMETER ENTRY
; RH: ACTUAL PARAMETER ENTRY

TYPTAB:	XWD	421030,000000	; "WILD" VARIABLE
	XWD	421020,000000	; ARITHMETIC/BOOLEAN
	XWD	000000,000000
	XWD	400020,000000	; INTEGER/BOOLEAN
	XWD	021000,000000	; "WILD" FLOATING
	XWD	000000,000000
	XWD	000000,000000
	XWD	444000,700000	; INTEGER
	XWD	000000,000000
	XWD	000000,000000
	XWD	000000,000000
	XWD	000000,000000
	XWD	000000,000000
	XWD	000000,000000
	XWD	222000,070000	; REAL
	XWD	000000,000000
	XWD	000000,000000
	XWD	000000,000000
	XWD	000000,000000
	XWD	000000,000000
	XWD	000000,000000
	XWD	111000,007000	; LONG REAL
	XWD	000000,000000
	XWD	000000,000000
	XWD	000000,000000
	XWD	000500,000600	; COMPLEX
	XWD	000240,000140	; LONG COMPLEX
	XWD	000000,000000
	XWD	000000,000000
	XWD	000000,000000
	XWD	000000,000000
	XWD	000000,000000
	XWD	421000,000000	; "WILD" ARITHMETIC
	XWD	000000,000000
	XWD	000000,000000
	XWD	000020,000020	; BOOLEAN
	XWD	000000,000000
	XWD	000000,000000
	XWD	000000,000000
	XWD	000000,000000
	XWD	000000,000000
	XWD	000000,000000
	XWD	000004,000004	; LABEL
	XWD	000000,000000
	XWD	000000,000000
	XWD	000000,000000
	XWD	000000,000000
	XWD	000000,000000
	XWD	000000,000000
	XWD	000000,000000
	XWD	000002,000002	; NON-TYPE
	XWD	000000,000000
	XWD	000000,000000
	XWD	000000,000000
	XWD	000000,000000
	XWD	000000,000000
	XWD	000010,000010	; STRING
	XWD	000000,000000
	XWD	000000,000000
	XWD	000000,000000
	XWD	000000,000000
	XWD	000000,000000
	XWD	000000,000000
	XWD	000000,000000
; PROCEDURE CALLS ARE FORMATTED AS FOLLOWS:


;		PUSHJ	SP,PROC
;		XWD	ATYPE,N+1
;		XWD	AT1,AA1
;		XWD	AT2,AA2
;
;		...............
;
;		XWD	ATN,AAN


; WHERE	N = NUMBER OF ACTUAL PARAMETERS

;	ATYPE = TYPE OF PROCEDURE REQUIRED

;	ATI = TYPE OF I'TH ACTUAL PARAMETER

;	AAI = ADDRESS OR VALUE OF I'TH ACTUAL PARAMETER



; THE PROCEDURE HEAD IS FORMATTED AS FOLLOWS:


;		XWD	DL,NA		; IF PAR0 ENTRY
;	PROC:	JSP	AX,PARAM	; OR PAR0
;		XWD	PL,L
;		XWD	FTYPE,M+1
;		XWD	FT1,FA1
;		XWD	FT2,FA2
;
;		...............
;
;		XWD	FTM,FAM


; WHERE	M = NUMBER OF FORMAL PARAMETERS

;	PL = PROCEDURE LEVEL

;	L = LENGTH OF FIXED STACK REQUIRED (NOT INCLUDING DISPLAY)

;	FTYPE = TYPE OF PROCEDURE

;	FTI = TYPE OF I'TH FORMAL PARAMETER

;	FAI = ADDRESS OF I'TH FORMAL PARAMETER (RELATIVE TO DL)

;	NA = ADDRESS FOR NUMBER OF ACTUAL PARAMETERS (PAR0 ONLY)
; TYPE ABBREVIATIONS:

;	I	INTEGER
;	R	REAL
;	LR	LONG REAL
;	C	COMPLEX (NOT IMPLEMENTED)
;	LC	LONG COMPLEX (NOT IMPLEMENTED)
;	B	BOOLEAN
;	S	STRING
;	L	LABEL
;	N	NON-TYPE (PROCEDURES ONLY)
SUBTTL PARAM - PROCEDURE TYPE HANDLING

PARAM:	TDZA	A1,A1		; NORMAL ENTRY
PAR0:	MOVEI	A1,1		; VARIABLE NUMBER OF PARAMETERS ENTRY
	MOVE	A3,(SP)		; GET PROGRAM LINK
	HRRZ	A0,(A3)		; NUMBER OF AP'S + 1
	ADDM	A0,(SP)		; ADVANCE PROGRAM LINK OVER AP'S
	HRRZ	A2,1(AX)	; NUMBER OF FP'S + 1
	XCT	[
	CAIE	A0,(A2)
	CAILE	A0,(A2)](A1)	; CHECK ON NUMBER OF PARAMETERS
	SYSER1	10,0		; WRONG
	PUSH	SP,DL		; SAVE CONTEXT DL
	PUSH	SP,SP		; INITIALIZE BLOCK POINTER
	HLLZ	A5,(AX)		; SAVE PROCEDURE LEVEL
	PUSH	SP,A5		; AND INITIALIZE BLOCK LEVEL
	MOVEI	A4,1(SP)	; NEW DL
	EXCH	DL,A4		; EXCHANGE WITH OLD
	HLRZ	A5,A5		; PROCEDURE LEVEL

PAR1:	SOJL	A5,PAR2		; LEVELS EXHAUSTED?
	PUSH	SP,(A4)		; NO - COPY DISPLAY ELEMENT
	AOJA	A4,PAR1		; AND ADVANCE OLD DL

PAR2:	PUSH	SP,DL		; THEN ADD NEW DL
	HLRZ	A5,(A3)
	ANDI	A5,$TYPE
	LSH	A5,-11		; TYPE OF PROCEDURE REQUIRED
	HRLZ	A5,TYPTAB(A5)	; GET TABLE ENTRY FOR IT
	HLRZ	A6,1(AX)
	ANDI	A6,$TYPE
	LSH	A6,-11		; TYPE OF PROCEDURE
	JUMPN	A5,.+2		; ANY ACTUAL TYPE BITS?
	HRLZ	A5,TYPTAB(A6)	; NO - FIX FOR SPRO5!!!
	AND	A5,TYPTAB(A6)	; GATE TABLE ENTRIES
	JFFO	A5,PAR4		; AND SORT IT OUT!!!!!!!

PAR3:	SYSER1	7,0		; MISMATCH

PAR4:	SKIPN	A5,PAR8(A6)	; GET MATCH ENTRY
	JRST	PAR3		; NO GOOD
	PUSH	SP,A5		; YES - PLANT IN EXIT FORMAL
	HRRZ	A5,(AX)		; GET FIXED STACK LENGTH
	ADDI	SP,-1(A5)	; AND ADVANCE STACK
	MOVE	A5,.JBREL
	CAIG	A5,(SP)		; STACK STILL IN CORE
	CCORE	1(SP)		; NO - TRY TO EXPAND
SUBTTL PARAM - MAIN CONTROL LOOP OF PARAMETER HANDLER

	MOVEI	A5,(SP)
	SUB	A5,.JBREL
	HRLI	SP,(A5)		; SET UP LH NEGATIVE COUNT
	MOVN	A13,A0
	HRLZI	A13,(A13)
	HRRI	A13,1(AX)	; COUNTER/POINTER TO FP'S
	ADDI	A2,1(AX)
	MOVEM	SP,BLKPTR(DL)	; SET UP BLOCK POINTER
	HRL	DL,A2		; SAVE RETURN LINK
	JUMPE	A1,PAR6		; PAR0 ENTRY?
	MOVEM	A0,@-2(AX)	; YES - FILL IN NUMBER OF AP'S

PAR6:	AOBJP	A13,PAR9	; EXIT IF NO MORE PARAMETERS
	MOVE	A2,1(A3)	; GET AP WORD
	MOVE	A4,(A13)	; GET FP WORD
	ADDI	A4,(DL)		; AND RELOCATE IT
	HLLZ	A5,A2		; GET LEFT HALF OF AP WORD
	SETZB	A6,A10
	ROTC	A5,3		; SHIFT STATIC/DYNAMIC AND KIND TO A6
	EXCH	A6,A10		; AND THEN TO A10
	ROTC	A5,6		; SHIFT TYPE TO A6
	ROT	A5,3
	ANDI	A5,<$STAT>B41	; AND GET STATUS IN A5
	HLRZ	A7,A4
	HRRZ	A11,A7
	ANDI	A11,$KIND
	LSH	A11,-17		; GET KIND OF FP
	ANDI	A7,$TYPE
	LSH	A7,-11		; GET TYPE OF FP
	CAIN	A6,<$S>B44	; STRING?
	CAIE	A10,4		; YES - DYNAMIC VARIABLE?
	JRST	PAR10		; NO
	JUMPE	A5,PAR10	; SIMPLE AS WELL?
	MOVEI	A10,10		; YES - RECODE AS SPECIAL
	MOVEI	A6,<$I>B44	; - TYPE IS INTEGER

PAR10:	HRLZ	A6,TYPTAB(A6)	; GET ENTRY FOR AP TYPE
	AND	A6,TYPTAB(A7)	; GATE WITH ENTRY FOR FP TYPE
	JFFO	A6,@PAR7(A10)	; SORT IT OUT AND BRANCH!!!!!!!
	SYSER1	7,0		; MISMATCH

PAR7:	JRST	@SVAR(A11)	; STATIC, VARIABLE
	JRST	@SEXP(A11)	; STATIC, EXPRESSION
	JRST	@SARR(A11)	; STATIC, ARRAY
	JRST	@SPRO(A11)	; STATIC, PROCEDURE
	JRST	@DVAR(A11)	; DYNAMIC, VARIABLE
	JRST	@DEXP(A11)	; DYNAMIC, EXPRESSION
	JRST	PAR3		; DYNAMIC, ARRAY (IMPOSSIBLE)
	JRST	PAR3		; DYNAMIC, PROCEDURE (IMPOSSIBLE)
	JRST	@BVAR(A11)	; DYNAMIC SIMPLE VARIABLE STRING (BYTE)
SUBTTL PARAM - STATIC VARIABLE HANDLER

; LH ENTRY: BY VALUE
; RH ENTRY: BY NAME

SVARD:	XWD	SVAR32,SVAR2	; I -> I
	XWD	SVAR33,SVAR3	; I -> R
	XWD	SVAR34,SVAR7	; I -> LR
	XWD	SVAR35,SVAR11	; R -> I
	XWD	SVAR32,SVAR2	; R -> R
	XWD	SVAR36,SVAR15	; R -> LR
	XWD	SVAR37,SVAR19	; LR -> I
	XWD	SVAR38,SVAR23	; LR -> R
	XWD	SVAR39,SVAR28	; LR -> LR
	XWD	0,0		; C -> C
	XWD	0,0		; C -> LC
	XWD	0,0		; LC -> C
	XWD	0,0		; LC -> LC
	XWD	SVAR32,SVAR2	; B -> B
	XWD	SVAR40,SVAR28	; S -> S
	XWD	SVAR41,SVAR24	; L -> L
	XWD	0,0		; N -> N

SVAR:	XWD	0,SVAR0		; VARIABLE
	XWD	0,PAR3		; EXPRESSION
	XWD	0,PAR3		; ARRAY
	XWD	0,PAR3		; PROCEDURE

SVAR0:	CAIN	A5,<$FON>B41	; FORMAL VARIABLE?
	JRST	FSVR0		; YES - SPECIAL TREATMENT
	CAIE	A5,<$OWN>B41	; FIXED VARIABLE?
	CAIN	A7,17		; OR LABEL?
	JRST	SVAR1		; YES
	HLRZ	A6,A2
	ANDI	A6,$P		; GET VARIABLE LEVEL (P ADDRESS)
	ADD	A6,CONDL(DL)	; ADDRESS OF DISPLAY ENTRY
	ADD	A2,(A6)		; ADD TO Q ADDRESS

SVAR1:	SKIPN	A6,SVARD(A7)	; LOAD UP DISPATCH ENTRY
	JRST	PAR3		; ILLEGAL
	TLNE	A4,$VAL		; FORMAL BUE?
	MOVS	A6,A6		; YES - SWAP HALVES
	JRST	(A6)		; AND DISPATCH
; I -> I, R -> R, B -> B, BY NAME

SVAR2:	HRLI	A2,<MOVE	A0,0>B53
	MOVEM	A2,(A4)
	HRLI	A2,<MOVEM	A0,0>B53
	MOVEM	A2,1(A4)	; PLANT DIRECT CODE IN F[0],F[1]
	AOJA	A3,PAR6

; I -> R, BY NAME

	IFE PROC-KA10, <
SVAR3:	DMOVE	A5,SVAR4
	DMOVEM	A5,(A4)		; PLANT INDIRECT CODE IN F[0],F[1]
	HRRZM	A2,2(A4)	; AND ADDRESS IN F[2]
	AOJA	A3,PAR6

SVAR4:	PUSHJ	SP,SVAR5
	PUSHJ	SP,SVAR6

SVAR5:	HRRZ	A2,(SP)		; F[0] CODE
	MOVEI	A2,@-1(A2)
	MOVE	A0,@2(A2)
	CIR
	POPJ	SP,0>

SVAR6:
DVAR5:	SCRI			; F[1] CODE
	MOVEM	A3,(A2)
	POPJ	SP,0

	IFE PROC-KI10, <
SVAR3:	HRLI	A2,<FLTR	A0,0>B53
	MOVEM	A2,(A4)		; PLANT DIRECT CODE IN F[0]
	MOVE	A2,[
	PUSHJ	SP,SVAR6]
	MOVEM	A2,1(A4)	; PLANT INDIRECT CODE IN F[1]
	HRRZM	A2,2(A4)	; AND ADDRESS IN F[2]
	AOJA	A3,PAR6>
; I -> LR, BY NAME

SVAR7:	DMOVE	A5,SVAR8
	DMOVEM	A5,(A4)		; PLANT INDIRECT CODE IN F[0],F[1]
	HRRZM	A2,2(A4)	; AND ADDRESS IN F[2]
	AOJA	A3,PAR6

SVAR8:	PUSHJ	SP,SVAR9
	PUSHJ	SP,SVAR10

SVAR9:	HRRZ	A2,(SP)		; F[0] CODE
	MOVEI	A2,@-1(A2)
	MOVE	A0,@2(A2)
	CILR
	POPJ	SP,0

SVAR10:
DVAR8:	SCLRI			; F[1] CODE
	MOVEM	A3,(A2)
	POPJ	SP,0
; R -> I, BY NAME

	IFE PROC-KA10, <
SVAR11:	DMOVE	A5,SVAR12
	DMOVEM	A5,(A4)		; PLANT INDIRECT CODE IN F[0],F[1]
	HRRZM	A2,2(A4)	; AND ADDRESS IN F[2]
	AOJA	A3,PAR6

SVAR12:	PUSHJ	SP,SVAR13
	PUSHJ	SP,SVAR14

SVAR13:	HRRZ	A2,(SP)		; F[0] CODE
	MOVEI	A2,@-1(A2)
	MOVE	A0,@2(A2)
	CRI
	POPJ	SP,0>

SVAR14:
DVAR11:	SCIR			; F[1] CODE
	MOVEM	A3,(A2)
	POPJ	SP,0

	IFE PROC-KI10, <
SVAR11:	HRLI	A2,<FIXR	A0,0>B53
	MOVEM	A2,(A4)		; PLANT DIRECT CODE IN F[0]
	MOVE	A2,[
	PUSHJ	SP,SVAR14]
	MOVEM	A2,1(A4)	; PLANT INDIRECT CODE IN F[1]
	HRRZM	A2,2(A4)	; AND ADDRESS IN F[2]
	AOJA	A3,PAR6>
; R -> LR, BY NAME

SVAR15:	DMOVE	A5,SVAR16
	DMOVEM	A5,(A4)		; PLANT INDIRECT CODE IN F[0],F[1]
	HRRZM	A2,2(A4)	; AND ADDRESS IN F[2]
	AOJA	A3,PAR6

SVAR16:	PUSHJ	SP,SVAR17
	PUSHJ	SP,SVAR18

SVAR17:	HRRZ	A2,(SP)		; F[0] CODE
	MOVEI	A2,@-1(A2)
	MOVE	A0,@2(A2)
	MOVEI	A1,0
	POPJ	SP,0

SVAR18:
DVAR14:	SCLRR			; F[1] CODE
	MOVEM	A3,(A2)
	POPJ	SP,0

; LR -> I, BY NAME

SVAR19:	DMOVE	A5,SVAR20
	DMOVEM	A5,(A4)		; PLANT INDIRECT CODE IN F[0],F[1]
	HRRZM	A2,2(A4)	; AND ADDRESS IN F[2]
	AOJA	A3,PAR6

SVAR20:	PUSHJ	SP,SVAR21
	PUSHJ	SP,SVAR22

SVAR21:	HRRZ	A2,(SP)		; F[0] CODE
	MOVEI	A2,@-1(A2)
	MOVE	A2,2(A2)
	DMOVE	A0,(A2)
	CLRI
	POPJ	SP,0

SVAR22:
DVAR17:	SCILR			; F[1] CODE
	DMOVEM	A3,(A2)
	POPJ	SP,0
; LR -> R, BY NAME

SVAR23:	DMOVE	A5,SVAR25
	DMOVEM	A5,(A4)		; PLANT INDIRECT CODE IN F[0],F[1]
	HRRZM	A2,2(A4)	; AND ADDRESS IN F[2]
	AOJA	A3,PAR6

SVAR25:	PUSHJ	SP,SVAR26
	PUSHJ	SP,SVAR27

SVAR26:	HRRZ	A2,(SP)		; F[0] CODE
	MOVEI	A2,@-1(A2)
	MOVE	A2,2(A2)
	IFE PROC-KA10, <
	MOVE	A0,(A2)
	FADR	A0,1(A2)>
	IFE PROC-KI10, <
	DMOVE	A0,(A2)
	CLRR>
	POPJ	SP,0

SVAR27:
DVAR20:	MOVEM	A0,(A2)		; F[1] CODE
	SETZM	1(A2)
	POPJ	SP,0
; LR -> LR, S -> S, BY NAME

	IFE PROC-KA10, <
SVAR28:	DMOVE	A5,SVAR29
	DMOVEM	A5,(A4)		; PLANT INDIRECT CODE IN F[0],F[1]
	HRRZM	A2,2(A4)	; AND ADDRESS IN FK2]
	AOJA	A3,PAR6

SVAR29:	PUSHJ	SP,SVAR30
	PUSHJ	SP,SVAR31

SVAR30:	HRRZ	A2,(SP)		; F[0] CODE
	MOVEI	A2,@-1(A2)
	MOVE	A2,2(A2)
	DMOVE	A0,(A2)
	POPJ	SP,0

SVAR31:
DVAR23:	DMOVEM	A0,(A2)		; F[1] CODE
	POPJ	SP,0>

	IFE PROC-KI10, <
SVAR28:	HRLI	A2,<DMOVE	A0,0>B53
	MOVEM	A2,(A4)
	HRLI	A2,<DMOVEM	A0,0>B53
	MOVEM	A2,1(A4)
	AOJA	A3,PAR6>
; I -> I, R -> R, B -> B, BY VALUE

SVAR32:
DVAR25:	MOVE	A0,(A2)

DEXP18:	MOVEM	A0,(A4)		; PLANT VALUE IN F[0]
	AOJA	A3,PAR6

; I -> R, BY VALUE

SVAR33:
DVAR26:	MOVE	A0,(A2)

DEXP19:	CIR
	MOVEM	A0,(A4)		; PLANT VALUE IN F[0]
	AOJA	A3,PAR6

; I -> LR, BY VALUE

SVAR34:
DVAR27:	MOVE	A0,(A2)

DEXP20:	CILR
	DMOVEM	A0,(A4)		; PLANT VALUE IN F[0],F[1]
	AOJA	A3,PAR6

; R -> I, BY VALUE

SVAR35:
DVAR29:	MOVE	A0,(A2)

DEXP21:	CRI
	MOVEM	A0,(A4)		; PLANT VALUE IN F[0]
	AOJA	A3,PAR6

; R -> LR, BY VALUE

SVAR36:
DVAR30:	MOVE	A0,(A2)

DEXP22:	MOVEM	A0,(A4)
	SETZM	1(A4)		; PLANT VALUE IN F[0],F[1]
	AOJA	A3,PAR6
; LR -> I, BY VALUE

SVAR37:
SEXP26:
DVAR31:	DMOVE	A0,(A2)

DEXP23:	CLRI
	MOVEM	A0,(A4)		; PLANT VALUE IN F[0]
	AOJA	A3,PAR6

; LR -> R, BY VALUE

SVAR38:
SEXP27:	IFE PROC-KA10, <
	MOVE	A0,(A2)
	FADR	A0,1(A2)>
	IFE PROC-KI10, <
	DMOVE	A0,(A2)
	CLRR>
	MOVEM	A0,(A4)		; PLANT VALUE IN F[0]
	AOJA	A3,PAR6

; LR -> LR, BY VALUE

SVAR39:
DVAR28:
SEXP29:
SARR2:	DMOVE	A0,(A2)		; ARRAYS BY NAME

DEXP25:	DMOVEM	A0,(A4)		; PLANT VALUE IN F[0],F[1]
	AOJA	A3,PAR6
; S -> S, BY VALUE

SVAR40:
SEXP28:	DMOVE	A0,(A2)

DEXP26:	MOVEI	A2,%SYS12(DB)
	DMOVEM	A0,(A2)		; SET UP DUMP FOR VALUE
	JSP	AX,STREND	; AND FIND ITS LENGTH
	MOVEI	A7,1
	MOVE	A10,A0		; SET BOUNDS FOR COPY
	DMOVE	A0,%SYS12(DB)	; LOAD UP VALUE OF STRING
	MOVE	A2,A4		; ADDRESS OF FP STRING
	MOVEI	A4,1(SP)	; ADDRESS OF NEW BYTE STRING
	MOVEI	A11,0		; FLAG EXIT VIA ARRAY TO TIDY STACK
	JSP	AX,CPYSTR	; AND COPY STRING
	AOJA	A3,PAR6

; L -> L, BY NAME, BY VALUE

SVAR24:
SVAR41:
DEXP17:	MOVE	A5,[
	PUSHJ	SP,SVAR42]
	MOVEM	A5,(A4)		; PLANT CODE IN F[0]
	HRRZM	A2,1(A4)	; LABEL ADDRESS IN F[1]
	HRLZ	A5,CONDL(DL)	; AND CONTEXT DL
	MOVEM	A5,2(A4)	; IN LEFT HALF OF F[2]
	AOJA	A3,PAR6

SVAR42:	HRRZ	A2,(SP)
	MOVEI	AX,@-1(A2)	; GET ADDRESS OF FORMAL
	MOVE	A2,1(AX)	; AND GET F[1]
	TRNE	A2,-1		; SWITCH OUT OF RANGE?
	TLNE	A2,-1		; NO - FORMAL?
	POPJ	SP,0		; NO
	HRLZI	A2,(AX)		; YES - GET ADDRESS  OF F[0]
	HRRI	A2,FORLAB	; AND LET FORLAB WORK
	POPJ	SP,0		; IT IF REQUIRED
; FORMAL STATIC VARIABLES

; LH ENTRY: BY VALUE
; RH ENTRY: BY NAME

FSVARD:	XWD	DEXP18,FSVR2	; I -> I
	XWD	DEXP19,FSVR4	; I -> R
	XWD	DEXP20,FSVR7	; I -> LR
	XWD	DEXP21,FSVR10	; R -> I
	XWD	DEXP18,FSVR2	; R -> R
	XWD	DEXP22,FSVR13	; R -> LR
	XWD	DEXP23,FSVR16	; LR -> I
	XWD	DEXP24,FSVR19	; LR -> R
	XWD	DEXP25,FSVR2	; LR -> LR
	XWD	0,0		; C -> C
	XWD	0,0		; C -> LC
	XWD	0,0		; LC -> C
	XWD	0,0		; LC -> LC
	XWD	DEXP18,FSVR2	; B -> B
	XWD	DEXP26,FSVR2	; S -> S
	XWD	DEXP17,FSVR2	; L -> L
	XWD	0,0		; N -> N
FSVR0:	HLRZ	A1,A2
	ANDI	A1,$P		; VARIABLE LEVEL (P ADDRESS)
	ADD	A1,CONDL(DL)	; ADDRESS OF DISPLAY ENTRY
	ADD	A2,(A1)		; ADD TO Q ADDRESS
	SKIPN	A6,FSVARD(A7)	; LOAD UP DISPATCH TABLE ENTRY
	JRST	PAR3		; ILLEGAL
	TLNN	A4,$VAL		; FORMAL BY NAME?
	JRST	FSVR1		; YES
	SKIPA	A5,A2		; NO - GET ADDRESS IN A5

DEXP14:	MOVEI	A5,[
	PUSHJ	SP,(A2)]	; DYNAMIC EXPRESSION ENTRY
	MOVS	A6,A6		; TAKE LEFT HALF OF DISPATCH ENTRY
	PUSH	SP,A6		; AND SAVE IT
	PUSH	SP,A3
	PUSH	SP,A4
	PUSH	SP,A13		; SAVE VALUABLE ACCUMULATORS
	PUSH	SP,DL		; SAVE CURRENT DL
	MOVE	DL,CONDL(DL)	; SET UP CONTEXT DL
	XCT	(A5)		; EVALUATE FORMAL OR THUNK
	POP	SP,DL		; RESTORE DL
	POP	SP,A13
	POP	SP,A4
	POP	SP,A3		; RESTORE VALUABLE ACCUMULATORS
	POP	SP,A6		; AND DISPATCH ADDRESS
	JRST	(A6)		; DISPATCH

FSVR1:	HRL	A2,(A1)		; GET CORRECT DL

FSVR22:	MOVEM	A2,2(A4)	; AND PLANT IN F[2]
	DMOVE	A5,(A6)
	DMOVEM	A5,(A4)		; AND CODE IN F[0],F[1]
	AOJA	A3,PAR6
; ROUTINES FOR HANDLING ACTUALS THAT ARE ARE FORMALS

FSVRC0:	MOVE	A2,-1(SP)	; INDIRECT ENTRY ON F[0]
	MOVE	A0,-1(A2)	; GET XCT ORDER
	MOVEI	A2,@A0
	MOVE	AX,2(A2)	; GET CONTEXT DL AND ADDRESS
	PUSH	SP,DL		; SAVE CURRENT DL
	HLRZ	DL,AX		; AND ASSUME FORMAL'S DL
	TLNE	A0,$A		; XCTA?
	JRST	FSVRCA		; YES
	XCT	(AX)		; NO - GET VALUE OF FORMAL
	POP	SP,DL		; RESTORE CURRENT DL
	POPJ	SP,0

FSVRCA:	XCTA	(AX)		; GET ADDRESS OF FORMAL
	POP	SP,DL		; RESTORE CURRENT DL
	POP	SP,AX		; LOSE F[0]'S LINK
	POPJ	SP,0

; N.B. A2 IS SET UP FROM FSVRCA

FSVRD1:	SKIPA	A3,(SP)		; DIRECT ENTRY ON F[1]
FSVRC1:	MOVE	A3,-1(SP)	; INDIRECT ENTRY ON F[1]
	MOVEI	A3,@-1(A3)
	MOVE	AX,1(A3)	; GET CONTEXT DL AND ADDRESS
	PUSH	SP,DL		; SAVE CURRENT DL
	HLRZ	DL,AX		; AND ASSUME FORMAL'S DL
	XCT	1(AX)		; STORE RESULT IN FORMAL
	POP	SP,DL		; RESTORE CURRENT DL
	POPJ	SP,0
; I -> I, R -> R, LR -> LR, B -> B, S -> S, L -> L, BY NAME

FSVR2:	PUSHJ	SP,FSVR3
	PUSHJ	SP,FSVRD1	; DIRECT F[1] CODE

FSVR3:	PUSHJ	SP,FSVRC0	; INDIRECT F[0] CODE
	POPJ	SP,0

; I -> R, BY NAME

FSVR4:	PUSHJ	SP,FSVR5
	PUSHJ	SP,FSVR6

FSVR5:	PUSHJ	SP,FSVRC0	; INDIRECT F[0] CODE
	CIR
	POPJ	SP,0

FSVR6:	PUSH	SP,A0		; INDIRECT F[1] CODE
	CRI
	PUSHJ	SP,FSVRC1
	POP	SP,A0
	POPJ	SP,0

; I -> LR, BY NAME

FSVR7:	PUSHJ	SP,FSVR8
	PUSHJ	SP,FSVR9

FSVR8:	PUSHJ	SP,FSVRC0	; INDIRECT F[0] CODE
	CILR
	POPJ	SP,0

FSVR9:	PUSH	SP,A0		; INDIRECT F[1] CODE
	PUSH	SP,A1
	CLRI
	PUSHJ	SP,FSVRC1
	POP	SP,A1
	POP	SP,A0
	POPJ	SP,0
; R -> I, BY NAME

FSVR10:	PUSHJ	SP,FSVR11
	PUSHJ	SP,FSVR12

FSVR11:	PUSHJ	SP,FSVRC0	; INDIRECT F[0] CODE
	CRI
	POPJ	SP,0

FSVR12:	PUSH	SP,A0		; INDIRECT F[1] CODE
	CIR
	PUSHJ	SP,FSVRC1
	POP	SP,A0
	POPJ	SP,0

; R -> LR, BY NAME

FSVR13:	PUSHJ	SP,FSVR14
	PUSHJ	SP,FSVR15

FSVR14:	PUSHJ	SP,FSVRC0	; INDIRECT F[0] CODE
	MOVEI	A1,0
	POPJ	SP,0

FSVR15:	PUSH	SP,A0		; INDIRECT F[1] CODE
	PUSH	SP,A1
	CLRR
	PUSHJ	SP,FSVRC1
	POP	SP,A1
	POP	SP,A0
	POPJ	SP,0

; LR -> I, BY NAME

FSVR16:	PUSHJ	SP,FSVR17
	PUSHJ	SP,FSVR18

FSVR17:	PUSHJ	SP,FSVRC0	; INDIRECT F[0] CODE
	CLRI
	POPJ	SP,0

FSVR18:	PUSH	SP,A0		; INDIRECT F[1] CODE
	CILR
	PUSHJ	SP,FSVRC1
	POP	SP,A0
	POPJ	SP,0
; LR -> R, BY NAME

FSVR19:	PUSHJ	SP,FSVR20
	PUSHJ	SP,FSVR21

FSVR20:	PUSHJ	SP,FSVRC0	; INDIRECT F[0] CODE
	CLRR
	POPJ	SP,0

FSVR21:	PUSH	SP,0		; INDIRECT F[1] CODE
	MOVEI	A1,0
	PUSHJ	SP,FSVRC1
	POP	SP,A0
	POPJ	SP,0
SUBTTL PARAM - STATIC EXPRESSION HANDLER

; LH ENTRY: BY VALUE
; RH ENTRY: BY NAME

SEXPD:	XWD	SEXP21,SEXP1	; I -> I
	XWD	SEXP22,SEXP5	; I -> R
	XWD	SEXP23,SEXP6	; I -> LR
	XWD	SEXP24,SEXP13	; R -> I
	XWD	SEXP30,SEXP14	; R -> R
	XWD	SEXP25,SEXP15	; R -> LR
	XWD	SEXP26,SEXP16	; LR -> I
	XWD	SEXP27,SEXP17	; LR -> R
	XWD	SEXP29,SEXP18	; LR -> LR
	XWD	0,0		; C -> C
	XWD	0,0		; C -> LC
	XWD	0,0		; LC -> C
	XWD	0,0		; LC -> LC
	XWD	SEXP21,SEXP1	; B -> B
	XWD	SEXP28,SEXP18	; S -> S
	XWD	0,0		; L -> L
	XWD	0,0		; N -> N

SEXP:	XWD	0,SEXP0		; VARIABLE
	XWD	0,PAR3		; EXPRESSION
	XWD	0,PAR3		; ARRAY
	XWD	0,PAR3		; PROCEDURE

SEXP0:	SKIPN	A6,SEXPD(A7)	; LOAD UP DISPATCH ENTRY
	JRST	PAR3		; ILLEGAL
	TLNE	A4,$VAL		; FORMAL BY VALUE?
	MOVS	A6,A6		; YES - SWAP HALVES
	TRNE	A5,<$REG>B41	; REGULAR?
	JRST	(A6)		; YES - DISPATCH TO REGULAR ADDRESS
	JRST	1(A6)		; NO - DISPATCH TO SIMPLE ADDRESS
; I -> I, B -> B, BY NAME

SEXP1:	SKIPA	A1,(A2)		; REGULAR
	HRRZI	A1,(A2)		; SIMPLE
	MOVE	A0,A1

SEXP2:	MOVEM	A0,2(A4)	; PLANT VALUE IN F[2]
	DMOVE	A5,SEXP3	; PLANT INDIRECT CODE IN F[0]
	DMOVEM	A5,(A4)		; PLANT DIRECT CODE IN F[1]
	AOJA	A3,PAR6

SEXP3:	PUSHJ	SP,SEXP4
	SYSER1	11,0

SEXP4:	HRRZ	A2,(SP)		; F[0] CODE
	MOVE	A0,-1(A2)
	TLNE	A0,$A		; ADDRESS REQUIRED?
	SYSER1	11,0		; YES - YOU LOSE
	MOVEI	A2,@A0
	MOVE	A0,2(A2)	; VALUE
	POPJ	SP,0

; I -> R, BY NAME

SEXP5:	SKIPA	A1,(A2)		; REGULAR
	HRRZI	A1,(A2)		; SIMPLE
	MOVE	A0,A1
	JCIR	SEXP2
; I -> LR, BY NAME

SEXP6:	JRST	SEXP10		; REGULAR
	HRRZI	A0,(A2)		; SIMPLE
	FSC	A0,233

SEXP7:	MOVEM	A0,2(A4)	; PLANT VALUE IN F[2]
	DMOVE	A5,SEXP8	; PLANT INDIRECT CODE IN F[0]
	DMOVEM	A5,(A4)		; PLANT DIRECT CODE IN F[1]
	AOJA	A3,PAR6

SEXP8:	PUSHJ	SP,SEXP9
	SYSER1	11,0

SEXP9:	HRRZ	A2,(SP)		; F[0] CODE
	MOVE	A0,-1(A2)
	TLNE	A0,$A		; ADDRESS REQUIRED?
	SYSER1	11,0		; YES - YOU LOSE
	MOVEI	A2,@A0
	MOVE	A0,2(A2)	; VALUE
	MOVEI	A1,0
	POPJ	SP,0

SEXP10:	MOVE	A0,(A2)		; REGULAR CASE
	CILR
	JUMPE	A1,SEXP7	; EASY CASE IF NO LOW WORD
	MOVEM	A2,2(A4)	; PLANT ADDRESS IN F[2]
	DMOVE	A5,SEXP11	; PLANT INDIRECT CODE IN F[0]
	DMOVEM	A5,(A4)		; PLANT DIRECT CODE IN F[1]

SEXP11:	PUSHJ	SP,SEXP12
	SYSER1	11,0

SEXP12:	HRRZ	A2,(SP)		; F[0] CODE
	MOVE	A0,-1(SP)
	TLNE	A0,$A		; ADDRESS REQUIRED?
	SYSER1	11,0		; YES - YOU LOSE
	MOVEI	A2,@A0
	MOVE	A0,@2(A2)	; VALUE
	CILR
	POPJ	SP,0
; R -> I, BY NAME

SEXP13:	SKIPA	A1,(A2)		; REGULAR
	MOVSI	A1,(A2)		; SIMPLE
	MOVE	A0,A1
	JCRI	SEXP2

; R -> R, BY NAME

SEXP14:	SKIPA	A1,(A2)		; REGULAR
	MOVSI	A1,(A2)		; SIMPLE
	MOVE	A0,A1
	JRST	SEXP2

; R -> LR, BY NAME

SEXP15:	SKIPA	A1,(A2)		; REGULAR
	MOVSI	A1,(A2)		; SIMPLE
	MOVE	A0,A1
	JRST	SEXP7

; LR -> I, BY NAME

SEXP16:	DMOVE	A0,(A2)
	JCLRI	SEXP2

; LR -> R, BY NAME

SEXP17:	IFE PROC-KA10, <
	MOVE	A0,(A2)
	FADR	A0,1(A2)
	JRST	SEXP2>
	IFE PROC-KI10, <
	DMOVE	A0,(A2)
	JCLRR	SEXP2>
; LR -> LR, S -> S, BY NAME

SEXP18:	MOVEM	A2,2(A4)	; PLANT ADDRESS IN F[2]
	DMOVE	A5,SEXP19	; PLANT INDIRECT CODE IN F[0]
	DMOVEM	A5,(A4)		; PLANT DIRECT CODE IN F[1]
	AOJA	A3,PAR6

SEXP19:	PUSHJ	SP,SEXP20
	SYSER1	11,0

SEXP20:	HRRZ	A2,(SP)		; F[0] CODE
	MOVE	A0,-1(A2)
	TLNE	A0,$A		; ADDRESS REQUIRED?
	SYSER1	11,0		; YES - YOU LOSE
	MOVEI	A2,@A0
	HRRZ	A2,2(A2)
	DMOVE	A0,(A2)		; VALUE
	POPJ	SP,0
; I -> I, B -> B, BY VALUE

SEXP21:	SKIPA	A1,(A2)		; REGULAR
	HRRZI	A1,(A2)		; SIMPLE
	MOVEM	A1,(A4)		; PLANT VALUE IN F[0]
	AOJA	A3,PAR6

; I -> R, BY VALUE

SEXP22:	SKIPA	A1,(A2)		; REGULAR
	HRRZI	A1,(A2)		; SIMPLE
	MOVE	A0,A1
	CIR
	MOVEM	A0,(A4)		; PLANT VALUE IN F[0]
	AOJA	A3,PAR6

; I -> LR, BY VALUE

SEXP23:	SKIPA	A1,(A2)		; REGULAR
	HRRZI	A1,(A2)		; SIMPLE
	MOVE	A0,A1
	CILR
	DMOVEM	A0,(A4)		; PLANT VALUE IN F[0],F[1]
	AOJA	A3,PAR6

; R -> I, BY VALUE

SEXP24:	SKIPA	A1,(A2)		; REGULAR
	MOVSI	A1,(A2)		; SIMPLE
	MOVE	A0,A1
	CRI
	MOVEM	A0,(A4)		; PLANT VALUE IN F[0]
	AOJA	A3,PAR6

; R -> R, BY VALUE

SEXP30:	SKIPA	A1,(A2)		; REGULAR
	MOVSI	A1,(A2)		; SIMPLE
	MOVEM	A1,(A4)		; PLANT VALUE IN F[0]
	AOJA	A3,PAR6

; R -> LR, BY VALUE

SEXP25:	SKIPA	A1,(A2)		; REGULAR
	MOVSI	A1,(A2)		; SIMPLE
	MOVEM	A1,(A4)
	SETZM	1(A4)		; PLANT VALUE IN F[0],F[1]
	AOJA	A3,PAR6
SUBTTL PARAM - STATIC ARRAY HANDLER

; LH ENTRY: BY VALUE
; RH ENTRY: BY NAME

SARRD:	XWD	SARR3,SARR2	; I -> I
	XWD	SARR3,0		; I -> R
	XWD	SARR3,0		; I -> LR
	XWD	SARR3,0		; R -> I
	XWD	SARR3,SARR2	; R -> R
	XWD	SARR3,0		; R -> LR
	XWD	SARR3,0		; LR -> I
	XWD	SARR3,0		; LR -> R
	XWD	SARR3,SARR2	; LR -> LR
	XWD	0,0		; C -> C
	XWD	0,0		; C -> LC
	XWD	0,0		; LC -> C
	XWD	0,0		; LC -> LC
	XWD	SARR3,SARR2	; B -> B
	XWD	SARR3,SARR2	; S -> S
	XWD	0,0		; L -> L
	XWD	0,0		; N -> N

SARR:	XWD	0,PAR3		; VARIABLE
	XWD	0,PAR3		; EXPRESSION
	XWD	0,SARR0		; ARRAY
	XWD	0,PAR3		; PROCEDURE

SARR0:	CAIN	A5,<$OWN>B41	; FIXED VARIABLE?
	JRST	SARR1		; YES
	HLRZ	A6,A2
	ANDI	A6,$P		; GET VARIABLE LEVEL (P ADDRESS)
	ADD	A6,CONDL(DL)	; ADDRESS OF DISPLAY ENTRY
	ADD	A2,(A6)		; ADD TO Q ADDRESS

SARR1:	HRRZ	A6,SARRD(A7)	; LOAD UP NAME DISPATCH ENTRY
	TLNE	A4,$VAL		; FORMAL BY VALUE
	HLRZ	A6,SARRD(A7)	; YES - LOAD UP VALUE DISPATCH ENTRY
	JUMPN	A6,(A6)		; DISPATCH UNLESS
	JRST	PAR3		; ILLEGAL
; ALL VALID COMBINATIONS, BY VALUE

SARR3:	MOVE	A1,1(A2)	; GET SECOND WORD OF HEADER

SARR4:	PUSH	SP,(A1)		; AND COPY DOPE VECTOR TO THE STACK
	PUSH	SP,1(A1)
	ADDI	A1,1
	AOBJN	A1,SARR4
	DMOVEM	A2,%SYS11(DB)
	MOVEM	A13,%SYS13(DB)	; SAVE A2,A3 AND A13
	HLRZ	A1,A4		; GET FP TYPE
	MOVNI	A3,1		; ONE ARRAY
	EXCH	A2,A4		; ADDRESS OF NEW HEADER
	HLRZ	A4,1(A4)	; - NUMBER OF DIMENSIONS
	JSP	AX,ARRAY	; LAY OUT NEW ARRAY
	MOVE	A1,%SYS11(DB)	; RESTORE ADDRESS OF OLD ARRAY
	SUBI	A2,2		; RETARD NEW ARRAY WORD POINTER
	PUSHJ	SP,CPYARR	; AND COPY OLD TO NEW
	MOVE	A3,%SYS12(DB)
	MOVE	A13,%SYS13(DB)	; RESTORE A3,A13
	AOJA	A3,PAR6
SUBTTL PARAM - STATIC PROCEDURE HANDLER

SPRO:	XWD	0,SPRO0		; VARIABLE
	XWD	0,PAR3		; EXPRESSION
	XWD	0,PAR3		; ARRAY
	XWD	0,SPRO0		; PROCEDURE

SPRO0:	CAIE	A5,<$FON>B41	; IS THE ACTUAL A FORMAL?
	JRST	SPRO1		; NO
	HLRZ	A6,A2
	ANDI	A6,$P		; GET PROCEDURE LEVEL (P ADDRESS)
	HLRZ	A5,CONDL(DL)	; GET TRUE CONTEXT DL
	ADDI	A6,(A5)		; ADDRESS OF DISPLAY ENTRY
	ADD	A2,(A6)		; YES - ADD DISPLAY ELEMENT TO Q ADDRESS
	HRLI	A2,<XCT	0>B53	; AND PREPARE OPERATIONAL ORDER
	JRST	SPRO2

SPRO1:	HRLI	A2,<PUSHJ	SP,0>B53
				; IF NOT FORMAL, THIS IS THE ORDER

SPRO2:	JUMPE	A11,SPRO6	; FORMAL PARAMETER A VARIABLE?
	MOVEM	A2,1(A4)	; NO - PLANT OPERATION IN F[1]
	MOVE	A5,[
	PUSHJ	SP,SPRO3]
	MOVEM	A5,(A4)		; PLANT ENTRY IN F[0]
	MOVE	A5,CONDL(DL)
	MOVEM	A5,2(A4)	; AND CONDL IN F[2]
	AOJA	A3,PAR6

SPRO3:	HRRZ	A1,(SP)		; F[0] CODE: GET LINK
	MOVEI	A2,@-1(A1)	; GET ADDRESS OF F[0]
	HRRZ	A0,(A1)		; GET LENGTH OF AP LIST
	ADDM	A0,(SP)		; AND ADVANCE LINK OVER AP'S
	PUSH	SP,DL
	HRLZ	DL,DL		; SAVE TRUE CONTEXT DL
	HRR	DL,2(A2)	; BUT ASSUME CORRECT ONE FOR BODY
	PUSH	SP,[0]		; MARK STACK
	PUSH	SP,1(A2)	; STACK OPERATIONAL ORDER
	MOVEI	A3,(SP)		; AND MARK IT'S POSITION

SPRO4:	PUSH	SP,(A1)		; COPY AP LIST TO STACK
	ADDI	A1,1
	SOJG	A0,SPRO4
	PUSH	SP,[
	JRST	SPRO5]		; STACK RETURN JUMP
	JRST	(A3)		; ENTER CALL SEQUENCE INTERLUDE

SPRO5:	POP	SP,A2		; UNSTACK UNWANTED DATA
	JUMPN	A2,SPRO5
	POP	SP,DL		; RESTORE DL
	POPJ	SP,0		; EXIT
; CASE OF A PARAMETERLESS PROCEDURE ASSIGNED TO A VARIABLE

SPRO6:	TLNE	A4,$VAL		; FORMAL BY VALUE?
	JRST	SPRO9		; YES
	MOVEM	A2,1(A4)	; PLANT OPERATIONAL ORDER IN F[1]
	HLLZ	A6,A4
	TLZ	A6,$KIND!$STAT
	TLO	A6,$PRO!$SIM	; CONSTRUCT MATCHED TYPE DESCRIPTOR
	HRR	A6,CONDL(DL)	; AND CONDL
	MOVEM	A6,2(A4)	; PLANT IN F[2]
	MOVE	A5,[
	PUSHJ	SP,SPRO7]
	MOVEM	A5,(A4)		; PLANT ENTRY IN F[0]
	AOJA	A3,PAR6

SPRO7:	HRRZ	A2,(SP)		; F[0] CODE: GET LINK
	MOVE	A0,-1(A2)	; GET CALLING ORDER
	TLNE	A0,$A		; ADDRESS REQUIRED?
	SYSER1	11,0		; YES - YOU LOSE
	MOVEI	A2,@A0		; GET ADDRESS OF F[0]
	PUSH	SP,DL		; STACK DL
	PUSH	SP,1(A2)	; STACK OPERATIONAL ORDER
	MOVE	A0,2(A2)	; GET F[2]
	HRRZ	DL,A0		; SET UP CORRECT DL
	HRRI	A0,1		; SET UP FOR NO ACTUALS
	PUSH	SP,A0		; AND STACK TYPE DESCRIPTOR
	PUSH	SP,[
	JRST	SPRO8]		; STACK RETURN JUMP
	JRST	-2(SP)		; AND ENTER CALL SEQUENCE INTERLUDE

SPRO8:	SUB	SP,[
	XWD	3,3]		; GET RID OF UNWANTED STACK
	POP	SP,DL		; RESTORE DL
	POPJ	SP,0		; AND EXIT

SPRO9:	PUSH	SP,A3		; FORMAL BY VALUE
	PUSH	SP,A4
	PUSH	SP,A13		; SAVE VALUABLE ACCS.
	PUSH	SP,DL		; STACK DL
	MOVE	DL,CONDL(DL)	; SET UP CONTEXT DL	PUSH	SP,A2		; STACK OPERATIONAL ORDER
	TLZ	A4,$KIND!$STAT
	TLO	A4,$PRO!$SIM
	HRRI	A4,1		; MAKE TYPE DESCRIPTOR
	PUSH	SP,A4		; FROM FORMAL - AND STACK IT
	PUSH	SP,[
	JRST	SPRO10]		; STACK RETURN JUMP
	JRST	-2(SP)		; AND ENTER CALL SEQUENCE INTERLUDE
SPRO10:	SUB	SP,[
	XWD	3,3]		; GET RID OF UNWANTED STACK
	POP	SP,DL		; RESTORE DL
	POP	SP,A13
	POP	SP,A4
	POP	SP,A3		; AND VALUABLE ACCS.
	DMOVEM	A0,(A4)		; PLANT RESULT IN FORMAL
	AOJA	A3,PAR6
SUBTTL PARAM - DYNAMIC VARIABLE HANDLER

; LH ENTRY: BY VALUE
; RH ENTRY: BY NAME

DVARD:	XWD	DVAR25,DVAR1	; I -> I
	XWD	DVAR26,DVAR3	; I -> R
	XWD	DVAR27,DVAR6	; I -> LR
	XWD	DVAR29,DVAR9	; R -> I
	XWD	DVAR25,DVAR1	; R -> R
	XWD	DVAR30,DVAR12	; R -> LR
	XWD	DVAR31,DVAR15	; LR -> I
	XWD	DVAR32,DVAR18	; LR -> R
	XWD	DVAR28,DVAR21	; LR -> LR
	XWD	0,0		; C -> C
	XWD	0,0		; C -> LC
	XWD	0,0		; LC -> C
	XWD	0,0		; LC -> LC
	XWD	DVAR25,DVAR1	; B -> B
	XWD	SVAR40,DVAR21	; S -> S
	XWD	0,0		; L -> L
	XWD	0,0		; N -> N

DVAR:	XWD	0,DVAR0		; VARIABLE
	XWD	0,PAR3		; EXPRESSION
	XWD	0,PAR3		; ARRAY
	XWD	0,PAR3		; PROCEDURE

DVAR0:	SKIPN	A6,DVARD(A7)	; LOAD UP DISPATCH ENTRY
	JRST	PAR3		; ILLEGAL

DVAR33:	TLNE	A4,$VAL		; FORMAL BY VALUE?
	JRST	DVAR24		; YES
	HRL	A2,CONDL(DL)	; ADD CONTEXT DL TO THUNK ADDRESS
	JRST	FSVR22
; ROUTINE FOR EVALUATING DYNAMIC VARIABLE THUNKS

DVARC:	MOVE	A1,-1(SP)
	PUSH	SP,-1(A1)	; SAVE XCT(A) ORDER
	MOVEI	A1,@(SP)
	MOVE	A1,2(A1)	; GET THUNK'S DL AND ADDRESS
	PUSH	SP,DL		; SAVE CURRENT DL
	HLRZ	DL,A1		; AND ASSUME THUNK'S
	PUSHJ	SP,(A1)		; EVALUATE THUNK
	POP	SP,DL		; RESTORE CURRENT DL
	POP	SP,A1		; RESTORE XCT(A) ORDER
	TLNE	A1,$A		; XCTA?
	POP	SP,A1		; YES - LOSE F[0]'S LINK
	POPJ	SP,0
; I -> I, R -> R, B-> B, BY NAME

DVAR1:	PUSHJ	SP,DVAR2
	MOVEM	A0,(A2)		; DIRECT F[1] CODE

DVAR2:	PUSHJ	SP,DVARC	; INDIRECT F[0] CODE
	MOVE	A0,(A2)
	POPJ	SP,0

; I -> R, BY NAME

DVAR3:	PUSHJ	SP,DVAR4
	PUSHJ	SP,DVAR5

DVAR4:	PUSHJ	SP,DVARC	; F[0] CODE
	MOVE	A0,(A2)
	CIR
	POPJ	SP,0

; I -> LR, BY NAME

DVAR6:	PUSHJ	SP,DVAR7
	PUSHJ	SP,DVAR8

DVAR7:	PUSHJ	SP,DVARC	; F[0] CODE
	MOVE	A0,(A2)
	CILR
	POPJ	SP,0

; R -> I, BY NAME

DVAR9:	PUSHJ	SP,DVAR10
	PUSHJ	SP,DVAR11

DVAR10:	PUSHJ	SP,DVARC	; F[0] CODE
	MOVE	A0,(A2)
	CRI
	POPJ	SP,0

; R -> LR, BY NAME

DVAR12:	PUSHJ	SP,DVAR13
	PUSHJ	SP,DVAR14

DVAR13:	PUSHJ	SP,DVARC	; F[0] CODE
	MOVE	A0,(A2)
	MOVEI	A1,0
	POPJ	SP,0

; LR -> I, BY NAME

DVAR15:	PUSHJ	SP,DVAR16
	PUSHJ	SP,DVAR17

DVAR16:	PUSHJ	SP,DVARC	; F[0] CODE
	DMOVE	A0,(A2)
	CLRI
	POPJ	SP,0

; LR -> R, BY NAME

DVAR18:	PUSHJ	SP,DVAR19
	PUSHJ	SP,DVAR20

DVAR19:	PUSHJ	SP,DVARC	; F[0] CODE
	IFE PROC-KA10, <
	MOVE	A0,(A2)
	FADR	A0,1(A2)>
	IFE PROC-KI10, <
	DMOVE	A0,(A2)
	CLRR>
	POPJ	SP,0

; LR -> LR, S -> S, BY NAME

DVAR21:	PUSHJ	SP,DVAR22
	IFE PROC-KA10, <
	PUSHJ	SP,DVAR23>
	IFE PROC-KI10, <
	DMOVEM	A0,(A2)>

DVAR22:	PUSHJ	SP,DVARC	; F[0] CODE
	DMOVE	A0,(A2)
	POPJ	SP,0
; FORMAL BY VALUE

DVAR24:	MOVS	A6,A6		; TAKE LEFT HALF DISPATCH ENTRY
	PUSH	SP,A6		; AND SAVE IT
	PUSH	SP,A3
	PUSH	SP,A4
	PUSH	SP,A13		; SAVE VALUABLE ACCUMULATORS
	PUSH	SP,DL		; SAVE DL
	MOVE	DL,CONDL(DL)	; AND USE CONTEXT DL
	PUSHJ	SP,(A2)		; EVALUATE THUNK
	POP	SP,DL		; RESTORE OLD DL
	POP	SP,A13
	POP	SP,A4
	POP	SP,A3		; RESTORE VALUABLE ACCUMULATORD
	POP	SP,A6		; AND DISPATCH ADDRESS
	JRST	(A6)		; DISPATCH

; LR -> R, BY VALUE

DVAR32:	DMOVE	A0,(A2)

DEXP24:	CLRR
	MOVEM	A0,(A4)		; PLANT VALUE IN F[0]
	AOJA	A3,PAR6
SUBTTL PARAM - DYNAMIC EXPRESSION HANDLER

; LH ENTRY: BY VALUE
; RH ENTRY: BY NAME

DEXPD:	XWD	DEXP18,DEXP1	; I -> I
	XWD	DEXP19,DEXP2	; I -> R
	XWD	DEXP20,DEXP4	; I -> LR
	XWD	DEXP21,DEXP6	; R -> I
	XWD	DEXP18,DEXP1	; R -> R
	XWD	DEXP22,DEXP8	; R -> LR
	XWD	DEXP23,DEXP10	; LR -> I
	XWD	DEXP24,DEXP12	; LR -> R
	XWD	DEXP25,DEXP1	; LR -> LR
	XWD	0,0		; C -> C
	XWD	0,0		; C -> LC
	XWD	0,0		; LC -> C
	XWD	0,0		; LC -> LC
	XWD	DEXP18,DEXP1	; B -> B
	XWD	DEXP26,DEXP1	; S -> S
	XWD	DEXP17,DEXP15	; L -> L
	XWD	0,0		; N -> N

DEXP:	XWD	0,DEXP0		; VARIABLE
	XWD	0,PAR3		; EXPRESSION
	XWD	0,PAR3		; ARRAY
	XWD	0,PAR3		; PROCEDURE

DEXP0:	SKIPN	A6,DEXPD(A7)	; LOAD UP DISPATCH ENTRY
	JRST	PAR3		; ILLEGAL
	TLNE	A4,$VAL		; FORMAL BY VALUE?
	JRST	DEXP14		; YES
	HRL	A2,CONDL(DL)	; ADD CONTEXT DL TO THUNK ADDRESS
	MOVEM	A2,2(A4)	; AND PLANT IN F[2]
	MOVE	A5,[
	SYSER1	11,0]
	MOVEM	A5,1(A4)	; PLANT F[1] CODE
	MOVE	A5,(A6)
	MOVEM	A5,(A4)		; PLANT F[0] CODE
	AOJA	A3,PAR6
; ROUTINE FOR EVALUATING DYNAMIC EXPRESSION THUNKS

DEXPDR:	SKIPA	A2,(SP)		; DIRECT ENTRY
DEXPC:	MOVE	A2,-1(SP)	; INDIRECT ENTRY
	MOVE	A0,-1(A2)	; GET XCT ORDER
	TLNE	A0,$A		; ADDRESS REQUIRED?
	SYSER1	11,0		; YES - YOU LOSE
	MOVEI	A2,@A0
	MOVE	A2,2(A2)	; GET CONTEXT DL AND THUNK ADDRESS
	PUSH	SP,DL		; SAVE CURRENT DL
	HLRZ	DL,A2		; AND ASSUME THUNK'S DL
	PUSHJ	SP,(A2)		; EVALUATE THUNK
	POP	SP,DL		; RESTORE OLD DL
	POPJ	SP,0
; I -> I, R -> R, B -> B, LR -> LR, S -> S, BY NAME

DEXP1:	PUSHJ	SP,DEXPDR	; DIRECT F[0] CODE

; I -> R, BY NAME

DEXP2:	PUSHJ	SP,DEXP3

DEXP3:	PUSHJ	SP,DEXPC	; F[0] CODE
	CIR
	POPJ	SP,0

; I -> LR, BY NAME

DEXP4:	PUSHJ	SP,DEXP5

DEXP5:	PUSHJ	SP,DEXPC	; F[0] CODE
	CILR
	POPJ	SP,0

; R -> I, BY NAME

DEXP6:	PUSHJ	SP,DEXP7

DEXP7:	PUSHJ	SP,DEXPC	; F[0] CODE
	CRI
	POPJ	SP,0

; R -> LR, BY NAME

DEXP8:	PUSHJ	SP,DEXP9

DEXP9:	PUSHJ	SP,DEXPC	; F[0] CODE
	MOVEI	A1,0
	POPJ	SP,0

; LR -> I, BY NAME

DEXP10:	PUSHJ	SP,DEXP11

DEXP11:	PUSHJ	SP,DEXPC	; F[0] CODE
	CLRI
	POPJ	SP,0
; LR -> R, BY NAME

DEXP12:	PUSHJ	SP,DEXP13

DEXP13:	PUSHJ	SP,DEXPC	; F[0] CODE
	CLRR
	POPJ	SP,0

; L -> L, BY NAME

DEXP15:	PUSHJ	SP,DEXP16

DEXP16:	HRRZ	A2,(SP)
	MOVEI	AX,@-1(A2)	; GET ADDRESS OF FORMAL
	MOVE	AX,2(AX)	; GET THUNK'S DL AND ADDRESS
	PUSH	SP,DL		; SAVE CURRENT DL
	HLRZ	DL,AX		; ASSSUME DL FOR LABEL
	PUSHJ	SP,(AX)		; EXECUTE THUNK
	POP	SP,DL		; RESTORE DL
	HRRZ	AX,(SP)
	MOVEI	AX,@-1(AX)	; GET ADDRESS OF FORMAL AGAIN
	MOVEM	A2,1(AX)	; AND STORE LABEL ADDRESS IN F[1]
	TRNE	A2,-1		; SWITCH OUT OF RANGE?
	TLNE	A2,-1		; NO - FORMAL?
	POPJ	SP,0		; NO
	HRLZI	A2,(AX)		; YES - GET ADDRESS OF F[0]
	HRRI	A2,FORLAB	; AND LET FORLAB DO THE WORK
	POPJ	SP,0		; IF REQUIRED
; BYTE VARIABLE (DYNAMIC SIMPLE VARIABLE STRING)

BVARD:	XWD	BVAR10,BVAR1	; BYTE -> I
	XWD	BVAR11,BVAR4	; BYTE -> R
	XWD	BVAR12,BVAR7	; BYTE -> LR

BVAR:	XWD	0,BVAR0		; VARIABLE
	XWD	0,PAR3		; EXPRESSION
	XWD	0,PAR3		; ARRAY
	XWD	0,PAR3		; PROCEDURE

BVAR0:	MOVE	A6,BVARD(A7)	; LOAD UP DISPATCH ENTRY
	JRST	DVAR33

; BYTE -> I, BY NAME

BVAR1:	PUSHJ	SP,BVAR2
	PUSHJ	SP,BVAR3

BVAR2:	PUSHJ	SP,DVARC	; F[0] CODE
	LDB	A0,A2
	POPJ	SP,0

BVAR3:	TLNE	A2,SBPPRT	; F[1] CODE
	SYSER1	17,0
	DPB	A0,A2
	POPJ	SP,0
; BYTE -> R, BY NAME

BVAR4:	PUSHJ	SP,BVAR5
	PUSHJ	SP,BVAR6

BVAR5:	PUSHJ	SP,DVARC	; F[0] CODE
	LDB	A0,A2
	CIR
	POPJ	SP,0

BVAR6:	TLNE	A2,SBPPRT	; F[1] CODE
	SYSER1	17,0
	SCRI
	DPB	A3,A2
	POPJ	SP,0

; BYTE -> LR, BY NAME

BVAR7:	PUSHJ	SP,BVAR8
	PUSHJ	SP,BVAR9

BVAR8:	PUSHJ	SP,DVARC	; F[0] CODE
	LDB	A0,A2
	CILR
	POPJ	SP,0

BVAR9:	TLNE	A2,SBPPRT	; F[1] CODE
	SYSER1	17,0
	SCLRI
	DPB	A3,A2
	POPJ	SP,0

; BYTE -> I, BY VALUE

BVAR10:	LDB	A0,A2
	JRST	DEXP18

; BYTE -> R, BY VALUE

BVAR11:	LDB	A0,A2
	JRST	DEXP19

; BYTE -> LR, BY VALUE

BVAR12:	LDB	A0,A2
	JRST	DEXP20
; EXIT DESTINATION TABLE

PAR8:	JSP	AX,FII		; I -> I
	JSP	AX,FIR		; I -> R
	JSP	AX,FILR		; I -> LR
	JSP	AX,FRI		; R -> I
	JSP	AX,FRR		; R -> R
	JSP	AX,FRLR		; R -> LR
	JSP	AX,FLRI		; LR -> I
	JSP	AX,FLRR		; LR -> R
	JSP	AX,FLRLR	; LR -> LR
	0			; C -> C
	0			; C -> LC
	0			; LC -> C
	0			; LC -> LC
	JSP	AX,FBB		; B -> B
	JSP	AX,FSS		; S -> S
	0			; L -> L
	JRST	FNN		; N -> N

PAR9:	HLRZ	AX,DL		; EXIT FROM PARAM
	JRST	(AX)
; EXIT SEQUENCES

FLRLR:
FSS:	MOVE	A1,1(AX)	; GET SECOND RESULT WORD

FII:
FRR:
FBB:	MOVE	A0,(AX)		; GET FIRST RESULT WORD

FNN:	MOVEI	SP,PRGLNK(DL)	; RESET STACK POINTER
	MOVE	DL,CONDL(DL)	; RESTORE CONTEXT DL
	MOVEI	AX,(SP)
	SUB	AX,.JBREL
	HRLI	SP,(AX)
	POPJ	SP,0		; AND EXIT

FIR:	MOVE	A0,(AX)
	JCIR	FNN

FILR:	MOVE	A0,(AX)
	JCILR	FNN

FRI:	MOVE	A0,(AX)
	JCRI	FNN

FRLR:	MOVE	A0,(AX)
	MOVEI	A1,0
	JRST	FNN

FLRI:	DMOVE	A0,(AX)
	JCLRI	FNN

FLRR:	IFE PROC-KA10, <
	MOVE	A0,(AX)
	FADR	A0,1(AX)
	JRST	FNN>
	IFE PROC-KI10, <
	DMOVE	A0,(AX)
	JCLRR	FNN>
SUBTTL GOLAB - GENERAL GOTO LABEL ROUTINE

; CALLED FROM LABEL WITH LINK IN AX
; WORD FOLLOWING CALL IS FORMATTED AS FOLLOWS:

;	BITS 0 - 12:	LEVEL OF BLOCK CONTAINING LABEL
;			RELATIVE TO ENCLOSING PROCEDURE

;	BITS 13 - 17:	BITS FOR MODIFYING ADDRESS BY DL

;	BITS 18 - 35:	STATIC PROCEDURE LEVEL OF PROCEDURE
;			ENCLOSING LABEL

GOLAB:	MOVE	DL,@(AX)	; RESET DL FROM PROCEDURE DISPLAY!!!!!
	MOVE	SP,BLKPTR(DL)	; RESET STACK POINTER FROM BLOCK POINTER
	HLRZ	A0,(AX)
	LSH	A0,-5		; BLOCK LEVEL RELATIVE TO PROCEDURE
	HRRZ	A1,PLBLKL(DL)	; PICK UP CURRENT BLOCK LEVEL
	HRRM	A0,PLBLKL(DL)	; AND REPLACE BY BLOCK LEVEL OF LABEL
	SUBI	A0,(A1)		; CALCULATE DIFFERENCE
	JUMPE	A0,1(AX)	; QUICK EXIT IF ALREADY THERE

GOLAB1:	MOVE	SP,(SP)		; NO - LOAD STACK FOR PREVIOUS LEVEL
	AOJL	A0,GOLAB1	; THERE YET?
	MOVEM	SP,BLKPTR(DL)	; YES - SET UP BLOCK POINTER
	JRST	1(AX)		; AND JUMP TO LABEL

; PRELUDE FOR GOING TO FORMAL LABEL

FORLAB:	HLRZ	A2,A2		; GET ADDRESS OF FORMAL
	HLRZ	DL,2(A2)	; SET UP DL FOR LABEL
	JRST	@1(A2)		; GOTO LABEL
SUBTTL ARRAY - ARRAY LAYOUT ROUTINE

; AN ARRAY HEADER WORD PAIR IS FORMATTED AS FOLLOWS:

; FIRST WORD:	LH:	TYPE OF ARRAY
;		RH:	POINTER TO 0TH ELEMENT OF ARRAY IF VECTOR,
;			OTHERWISE 0TH ELEMENT OF PRIMARY ILIFFE VECTOR

; SECOND WORD:	LH:	- NUMBER OF DIMENSIONS
;		RH:	POINTER TO DOPE VECTOR

; THE I'TH ELEMENT OF THE J'TH LEVEL ILIFFE VECTOR (J = 1,2, ..... N-1)
; CONTAINS THE ADDRESS OF THE 0TH ELEMENT OF THE J+1'TH ILIFFE
; VECTOR (OR N'TH ROW IF J=N-1)

; THE DOPE VECTOR CONTAINS THE BOUND PAIRS

; ARRAY - NORMAL ENTRY
; OARRAY - OWN ARRAY ENTRY
; THE BOUND PAIRS ARE ON THE STACK (DOPE VECTOR)
; AND THE LINK IS IN AX
; A1 = ARRAY TYPE (T)
; A2 = ADDRESS OF FIRST HEADER WORD (A)
; A3 = - NO. OF ARRAYS (M)
; A4 = - NO. OF DIMENSIONS (N)
ARRAY:	TDZA	A11,A11		; NORMAL ENTRY
OARRAY:	MOVEI	A11,1		; OWN ARRAY ENTRY
	MOVN	A10,A3		; SAVE NO. OF ARRAYS
	HRLI	A2,(A3)		; -M,A
	HRLZI	A3,(A4)
	ASH	A4,1
	MOVN	A13,A4		; LENGTH OF DOPE VECTOR
	HRRI	A3,1(SP)
	SUBI	A3,(A13)	; -N,DV
	JUMPN	A11,ARR10	; OWN ARRAY?

ARR1:	HRLZ	A1,A1		; T,0
	MOVE	A4,A3		; DOPE VECTOR (DV) POINTER
	SETZB	A5,A6		; A5 = SPACE ACCUMULATOR
	MOVEI	A7,1		; A6,7 = MULTIPLIER ACCUMULATOR

ARR2:	MOVM	A0,(A4)		; ABS(LB(I))
	TLNE	A0,-1		; OK?
	SYSER1	4,(AX)		; NO
	MOVM	A0,1(A4)	; ABS(UB(I))
	TLNE	A0,-1		; OK?
	SYSER1	4,(AX)		; NO
	MOVE	A0,1(A4)
	SUB	A0,(A4)		; UB(I) - LB(I)
	AOJG	A0,.+2		; FORM D(I). OK?
	SYSER1	3,(AX)		; NO
	MOVE	A6,A7
	MUL	A6,A0		; ACCUMULATE PRODUCT
	JUMPN	A6,.+2
	TLNE	A7,-1
	SYSER1	4,(AX)		; TOO LARGE
	ADDI	A5,(A7)		; ACCUMULATE SUM OF PRODUCTS
	ADDI	A4,1
	AOBJN	A4,ARR2		; RETURN IF MORE SUBSCRIPTS
	TLNN	A1,$VAR2	; ALLOW FOR LONG REAL, ETC.
	ADDI	A5,(A7)
	TLNE	A5,-1		; TOO BIG FOR PDP-10?
	SYSER1	4,(AX)		; UNFORTUNATELY, YES
	JUMPN	A11,ARR12	; SPECIAL TREATMENT FOR OWN
	IMULI	A5,(A10)	; SIZE OF ALL ARRAYS
	ADDI	A5,1(SP)	; ADD SPACE REQUIRED TO SP
	TLNE	A5,-1		; TOO BIG NOW?
	SYSER1	2,(AX)		; ALAS, YES
	CAML	A5,.JBREL	; WILL IT FIT IN CORE?
	CCORE	(A5)		; NO - TRY TO EXPAND
	MOVEI	SP,1(SP)	; CORRECT STACK POINTER

ARR4:	MOVE	A5,A3		; START OF DOPE VECTOR
	MOVE	A4,1(A5)
	SUB	A4,(A5)
	ADDI	A4,1		; D(1)
	MOVE	A7,SP
	SUB	A7,(A5)		; ADDRESS OF 0TH ELEMENT
	HRR	A1,A7
	ADDI	A5,1		; MOVE UP DOPE VECTOR POINTER
	AOBJN	A5,ARR5		; AND JUMP UNLESS VECTOR
	TLNE	A1,$VAR2
	JRST	ARR8		; CHECK FOR LONG REAL, ETC.
	ASH	A4,1		; DOUBLE LAST SUBSCRIPT
	MOVE	A7,-2(A5)	; GET BACK LAST LB
	SUB	A1,A7		; RECALCULATE ADDRESS OF 0TH ELEMENT
	JRST	ARR8
ARR5:	MOVE	A10,SP		; NOT A VECTOR

ARR6:	ADDI	A10,(A4)	; NEXT ILIFFE VECTOR OR ARRAY
	MOVE	A6,1(A5)
	SUB	A6,(A5)
	ADDI	A6,1		; D(I)
	MOVE	A7,A10
	SUB	A7,(A5)		; ADDRESS OF 0TH ELEMENT
	ADDI	A5,1		; MOVE UP DOPE VECTOR POINTER
	AOBJN	A5,ARR7		; AND JUMP UNLESS LAST SUBSCRIPT
	TLNE	A1,$VAR2	; CHECK FOR LONG REAL, ETC.
	JRST	ARR7		; NO
	SUB	A7,-2(A5)	; ALLOW FOR DOUBLING OF SUBSCRIPT
	ASH	A6,1

ARR7:	MOVEM	A7,(SP)		; FILL IN ILIFFE VECTOR ELEMENT
	ADDI	A7,(A6)		; ADVANCE ENTRY
	ADDI	SP,1		; INCREMENT ILIFFE VECTOR
	CAIE	SP,(A10)	; COMPLETE?
	JRST	ARR7		; NO - KEEP GOING
	IMULI	A4,(A6)		; NEW PRODUCT
	TLNE	A5,-1		; ANY MORE DIMENSIONS?
	JRST	ARR6		; YES

ARR8:	ADDI	SP,(A4)		; MOVE SP OVER ARRAY
	MOVEM	A1,(A2)
	MOVEM	A3,1(A2)	; FILL IN HEADER WORDS
	ADDI	A2,1		; MORE ARRAYS?
	AOBJN	A2,ARR4		; YES
	JUMPN	A11,ARR14	; OWN ARRAY?
	SUBI	SP,1		; NO - RETARD STACK FOR NEXT PUSH

ARR9:	MOVEI	A4,(SP)		; EXIT SEQUENCE
	SUB	A4,.JBREL
	HRLI	SP,(A4)		; SET LH NEGATIVE COUNT
	JUMPN	A11,(AX)	; AND EXIT IF OWN ARRAYS
	MOVE	A4,BLKPTR(DL)	; OTHERWISE GET LAST BLOCK POINTER
	PUSH	SP,(A4)		; AND REPLACE IT
	MOVEM	SP,BLKPTR(DL)	; WITH NEW ONE
	JRST	(AX)		; AND EXIT
ARR10:	SKIPN	A4,1(A2)	; VIRGIN ARRAY?
	JRST	ARR1		; YES - RETURN TO MAIN SEQUENCE
	MOVE	A5,A3

ARR11:	MOVE	A0,(A5)		; COMPARE NEW DOPE VECTOR WITH OLD
	CAME	A0,(A4)		; LOWER BOUNDS THE SAME?
	JRST	ARR1		; NO
	MOVE	A0,1(A5)
	CAME	A0,1(A4)	; UPPER BOUNDS THE SAME?
	JRST	ARR1		; NO
	ADDI	A5,2
	ADDI	A4,1
	AOBJN	A4,ARR11	; MOVE TO NEXT SUBSCRIPT IF ANY
	SUBI	SP,(A13)	; SAME BOUNDS - LOSE NEW DOPE VECTOR
	JRST	ARR9		; AND EXIT

ARR12:	ADD	A5,A13		; TOTAL SPACE REQUIRED PER ARRAY
	MOVEM	A5,%SYS7(DB)	; SAVE IT
	MOVEM	A13,%SYS10(DB)	; DOPE VECTOR LENGTH
	DMOVEM	A1,%SYS11(DB)
	MOVEM	A3,%SYS13(DB)	; AND A1 - A3

ARR13:	MOVE	A0,%SYS7(DB)	; SPACE REQUIRED
	PUSHJ	SP,GETOWN	; TRY TO GET IT
	SYSER1	13,(AX)		; FAILED
	MOVE	A4,A1		; ADDRESS OF SPACE
	ADDI	A0,-2(A1)	; ADDRESS OF LAST WORD
	HRLI	A1,(A1)
	ADDI	A1,1		; SET UP BLT POINTER
	SETZM	-1(A1)
	BLT	A1,@A0		; AND ZERO THE ARRAY SPACE
	MOVE	A3,%SYS13(DB)	; RESTORE TEMPORARY DOPE VECTOR POINTER
	HRL	A4,A3		; BLT POINTER
	HRR	A3,A4		; POINTER TO NEW DOPE VECTOR
	MOVE	A13,%SYS10(DB)
	ADDI	A13,-1(A4)	; END OF NEW DOPE VECTOR
	BLT	A4,(A13)	; COPY TEMPORARY TO NEW DOPE VECTOR
	MOVE	A1,%SYS11(DB)	; RESTORE A1
	PUSH	SP,[0]
	PUSH	SP,[0]
	HRROI	A2,-1(SP)	; SET UP FOR NEW HEADER
	EXCH	SP,A13		; SAVE STACK POINTER
	AOJA	SP,ARR4		; AND LAY OUT ONE ARRAY
ARR14:	MOVE	SP,A13		; RESTORE STACK POINTER
	MOVE	A1,%SYS12(DB)	; GET ADDRESS OF OLD HEADER
	SKIPN	1(A1)		; VIRGIN ARRAY?
	JRST	ARR15		; YES
	MOVEI	A2,-1(SP)
	PUSHJ	SP,CPYARR	; NO - COPY RELEVANT PARTS OF OLD ARRAY
	MOVEI	A11,1		; RESET OWN FLAG
	MOVE	A1,%SYS12(DB)
	HRRZ	A1,1(A1)	; GET LOCATION OF OLD ARRAY
	MOVEI	A0,0
	PUSHJ	SP,GETOWN	; AND DELETE IT

ARR15:	MOVE	A2,%SYS12(DB)	; RESTORE ADDRESS OF HEADER
	POP	SP,1(A2)
	POP	SP,(A2)		; AND COPY NEW HEADER
	ADDI	A2,1
	AOBJP	A2,ARR16	; ANY MORE ARRAYS?
	MOVEM	A2,%SYS12(DB)	; YES - MOVE TO NEXT HEADER
	JRST	ARR13		; AND DEAL WITH THE NEXT ONE

ARR16:	MOVE	SP,%SYS13(DB)
	SOJA	SP,ARR9		; RESTORE SP TO BEFORE TEMPORARY DV
SUBTTL CHKARR - CHECK ARRAY SUBSCRIPTS ROUTINE

; ON ENTRY, THE SUBSCRIPTS ARE ON THE STACK
; A0 = NUMBER OF SUBSCRIPTS PRESENTED
; A2 = ADDRESS OF ARRAY HEADER
; THE LINK IS IN AX
; ON EXIT, THE ARRAY ELEMENT ADDRESS IS IN A2

CHKARR:	DMOVEM	A3,%SYS12(DB)	; SAVE A3,A4
	MOVE	A1,1(A2)	; GET DOPE VECTOR POINTER
	MOVE	A2,(A2)		; GET ARRAY TYPE AND ADDRESS OF 0TH WORD
	SUB	SP,A0
	MOVEI	A3,(SP)
	SUB	A3,.JBREL	; RESTORE STACK POINTER 
	HRLI	SP,(A3)		; TO POSITION BEFORE DUMPS
	MOVEI	A3,1(SP)	; POINTER TO SUBSCRIPTS

CHK1:	MOVE	A4,(A3)		; GET NEXT SUBSCRIPT
	CAML	A4,(A1)		; AND CHECK IF BETWEEN
	CAMLE	A4,1(A1)	; LOWER AND UPPER BOUNDS
	SYSER1	6,(AX)		; NO - COMPLAIN
	ADD	A2,A4		; OK - OFFSET ADDRESS BY SUBSCRIPT
	ADDI	A1,1		; ADVANCE DOPE VECTOR POINTER
	AOBJP	A1,CHK2		; ANY MORE ENTRIES IN DOPE VECTOR?
	SOJE	A0,CHK3		; YES - ANY SUBSCRIPTS LEFT?
	HRR	A2,(A2)		; YES - LOAD ILIFFE VECTOR ENTRY
	AOJA	A3,CHK1		; AND DEAL WITH NEXT SUBSCRIPT

CHK2:	SOJN	A0,CHK3		; END OF DOPE VECTOR - ANY MORE SUBSCRIPTS?
	TLNN	A2,$VAR2	; NO - TWO WORDS PER VARIABLE?
	ADD	A2,A4		; YES - DOUBLE LAST SUBSCRIPT
	DMOVE	A3,%SYS12(DB)	; RESTORE A3,A4
	JRST	(AX)		; AND RETURN WITH ADDRESS OF ELEMENT

CHK3:	SYSER1	5,(AX)		; WRONG NUMBER OF SUBSCRIPTS
SUBTTL COMPAR - COMPARE BYTE STRINGS ROUTINE

; STRING VARIABLES ARE FORMATTED AS FOLLOWS:

; FIRST WORD:	LH:	ADDRESS OF CONCATENATED STRINGS, IF ANY
;			(OTHERWISE ZERO)
;		RH:	ADRESS OF BYTE STRING

; SECOND WORD:	BIT 0:	WRITE PROTECT BIT (SET IN STRING CONSTANT
;			HEADERS)
;		BIT 1:	 DYNAMIC BIT (SET IN STRINGS CREATED
;			IN THE HEAP)
;		BITS 2-4:	SPARE
;		BIT 5:		SEARCH MARKER
;		BITS 6-11:	BYTE SIZE OF BYTE STRING
;		BITS 12-35:	NUMBER OF BYTES IN BYTE STRING

; ON ENTRY:
; A0,A1 CONTAIN THE VALUE OF THE FIRST STRING VARIABLE
; A2,A3 CONTAIN THE VALUE OF THE SECOND STRING VARIABLE
; THE LINK IS IN AX
; ON EXIT:
; A0 CONTAINS -1,0 OR +1 ACCORDING AS THE FIRST STRING IS LESS THAN,
; EQUAL TO OR GREATER THAN THE SECOND STRING
COMPAR:	DMOVEM	A4,%SYS7(DB)
	DMOVEM	A6,%SYS11(DB)
	MOVEM	A10,%SYS13(DB)	; SAVE A4 - A10
	MOVE	A4,A0		; TRANSFER A0 TO A4
	MOVEI	A0,0		; SET RESULT EQUAL
	PUSHJ	SP,COMP8	; CONSTRUCT BYTE POINTER/COUNT FOR FIRST STRING
	JUMPE	A1,COMP6	; EXPIRED?
	PUSHJ	SP,COMP10	; CONSTRUCT BYTE POINTER/COUNT FOR SECOND STRING
	JUMPE	A3,COMP4	; EXPIRED?

COMP1:	ILDB	A7,A4		; GET BYTE FROM FIRST STRING
	ILDB	A10,A2		; GET BYTE FROM SECOND STRING
	CAME	A7,A10		; BYTES IDENTICAL?
	JRST	COMP3		; NO
	SOJN	A3,COMP2	; YES - SECOND STRING EXPIRED?
	PUSHJ	SP,COMP11	; MAYBE
	JUMPE	A3,COMP7

COMP2:	SOJN	A1,COMP1	; NO - FIRST STRING EXPIRED?
	PUSHJ	SP,COMP9	; MAYBE
	JUMPN	A1,COMP1
	SOJA	A0,COMP5	; YES - SECOND STRING WINS

COMP3:	CAMG	A7,A10		; DIFFERENT BYTES - WHO WINS?
	SOJA	A0,COMP5	; SECOND STRING

COMP4:	ADDI	A0,1		; FIRST STRING

COMP5:	DMOVE	A4,%SYS7(DB)
	DMOVE	A6,%SYS11(DB)
	MOVE	A10,%SYS13(DB)	; RESTORE A4 - A10
	JRST	(AX)

COMP6:	PUSHJ	SP,COMP10	; FIRST STRING EXPIRED
	JUMPE	A3,COMP5	; SECOND ALSO?
	SOJA	A0,COMP5	; NO - SECOND STRING WINS

COMP7:	SOJN	A1,COMP4	; SECOND STRING EXPIRED
	PUSHJ	SP,COMP9
	JUMPE	A1,COMP5	; FIRST ALSO?
	AOJA	A0,COMP5	; NO - FIRST STRING WINS
COMP8:	HLRZ	A5,A4		; FIRST STRING CONCATENATION ADDRESS
	HLL	A4,A1
	TLZ	A4,STRBSC
	TLO	A4,440000	; BYTE POINTER FOR FIRST STRING
	TLZ	A1,STRBCC	; BYTE COUNT FOR FIRST STRING
	JUMPN	A1,COMP12	; ANY BYTES?

COMP9:	JUMPE	A5,COMP12	; NO - ANY CONCATENATIONS?
	MOVE	A4,STR1(A5)
	MOVE	A1,STR2(A5)	; YES - LOAD NEW STRING
	JRST	COMP8		; AND TRY AGAIN

COMP10:	HLRZ	A6,A2		; SECOND STRING CONCATENATION POINTER
	HLL	A2,A3
	TLZ	A2,STRBSC
	TLO	A2,440000	; BYTE POINTER FOR SECOND STRING
	TLZ	A3,STRBCC	; BYTE COUNT FOR SECOND STRING
	JUMPN	A3,COMP12	; ANY BYTES?

COMP11:	JUMPE	A6,COMP12	; NO - ANY CONCATENATIONS?
	DMOVE	A2,STR1(A6)	; YES - LOAD NEW STRING
	JRST	COMP10		; AND TRY AGAIN

COMP12:	POPJ	SP,0
SUBTTL PBYTE/EBYTE - BYTE POINTER/ERROR BYTE ROUTINES

; ON ENTRY:
; A1 = BYTE NUMBER
; A2 = ADDRESS OF STRING VARIABLE
; THE LINK IS IN AX
; ON EXIT, THE BYTE POINTER IS IN A2
; WITH BIT 12 SET IF THE STRING IS WRITE PROTECTED
; THE OBJECT PROGRAM CALLS EBYTE IF AN ATTEMPT
; IS MADE TO DEPOSIT A BYTE INTO A WRITE PROTECTED STRING

; E.G.
;
;	S.[I] := S.[J]
;
; COMPILES INTO
;
;	MOVE	A1,J
;	MOVEI	A2,S
;	JSP	AX,PBYTE
;	LDB	A13,A2		; A0 := S.[J]
;	MOVE	A1,I
;	MOVEI	A2,S
;	JSP	AX,PBYTE
;	TLNE	A2,SBPPRT	; WRITE PROTECTED?
;	JSP	AX,EBYTE	; YES - FAIL
;	DPB	A13,A2		; NO: S.[I] := A0

PBYTE:	DMOVEM	A4,%SYS11(DB)	; SAVE A4,A5
	SOJL	A1,PBYT2	; CHECK SENSIBLE BYTE NUMBER

PBYT1:	MOVE	A4,STR2(A2)
	TLZ	A4,STRBCC	; NUMBER OF BYTES IN STRING
	CAMGE	A1,A4		; ENOUGH?
	JRST	PBYT3		; YES
	SUB	A1,A4		; NO - SUBTRACT FROM REQUIRED BYTE NUMBER
	HLRZ	A2,STR1(A2)
	JUMPN	A2,PBYT1	; AND TRY AGAIN IF ANY CONCATENATIONS

PBYT2:	SYSER1	16,(AX)		; BYTE NUMBER OUT OF RANGE
PBYT3:	HLL	A2,STR2(A2)	; GET LEFT HALF OF SECOND STRING WORD
	HLRZ	A5,A2
	ANDI	A5,STRBS
	LSH	A5,-6		; AND EXTRACT BYTE SIZE
	MOVEI	A3,44
	IDIVI	A3,(A5)		; CALCULATE NUMBER OF BYTES PER WORD
	EXCH	A1,A2		; EXCHANGE BYTE NUMBER AND ADDRESS
	IDIVI	A2,(A3)		; CALCULATE WORD AND BYTE NUMBER
	HRR	A1,(A1)		; GET ADDRESS OF BYTE STRING
	ADDI	A2,(A1)		; AND GET ADDRESS OF WORD CONTAINING BYTE
	CAMG	A2,.JBREL	; GOOD ADDRESS IN LOW SEGMENT?
	JRST	PBYT4		; YES
	HRRZ	A4,.JBHRL
	CAILE	A2,(A4)		; NO - GOOD ADDRESS IN HIGH SEGMENT
	SYSER2	5,0		; NO - COMPLAIN

PBYT4:	DPB	A5,[
	POINT	6,A2,11]	; SET UP BYTE SIZE
	IMULI	A5,1(A3)
	MOVEI	A4,44
	SUBI	A4,(A5)		; POSITION OF LAST BIT IN BYTE
	DPB	A4,[
	POINT	6,A2,5]		; SET IT IN BYTE POINTER
	DMOVE	A4,%SYS11(DB)	; RESTORE A4,A5
	JUMPGE	A1,(AX)		; EXIT UNLESS WRITE PROTECTED
	TLO	A2,SBPPRT	; SET WRITE PROTECT BIT
	JRST	(AX)

EBYTE:	SYSER1	17,(AX)		; ERROR ENTRY
SUBTTL STREND - FIND END OF STRING ROUTINE

; ON ENTRY:
; A2 = ADDRESS OF STRING
; THE LINK IS IN AX
; ON EXIT:
; A0 = LENGTH OF STRING (BYTES)
; A1 = ADDRESS OF LAST STRING IN CHAIN

; A3,A4 AND A13 ARE SACRED AS THIS ROUTINE IS CALLED FROM PARAM

STREND:	MOVEI	A1,(A2)		; SET UP INITIAL POINTER
	MOVE	A0,STR2(A1)
	JUMPG	A0,STRE4	; STRING CONSTANT?
	TLZ	A0,STRBCC	; YES - GET BYTE COUNT
	JRST	(AX)

STRE4:	MOVSI	A6,STRSM	; SET UP SEARCH FLAG

STRE1:	IORM	A6,STR2(A1)	; MARK SEARCH IN STRING
	HLRZ	A7,STR1(A1)	; GET LINK ADDRESS
	JUMPE	A7,STRE2	; FALL OUT IF END
	MOVE	A5,STR2(A7)	; GET SECOND WORD OF NEXT STRING
	TLNE	A5,STRSM	; ALREADY MARKED IN SEARCH?
	JRST	STRE2		; YES - FALL OUT
	MOVEI	A1,(A7)		; NO - MOVE ON
	JRST	STRE1

STRE2:	MOVEI	A0,0		; INITIALIZE BYTE COUNT
	MOVEI	A7,(A2)		; SET POINTER BACK TO BEGINNING

STRE3:	MOVE	A5,STR2(A7)
	TLZ	A5,STRBCC	; GET LENGTH OF THIS STRING
	ADD	A0,A5		; AND ADD IT TO TOTAL
	ANDCAM	A6,STR2(A7)	; CLEAR SEARCH MARKER IN THIS STRING
	CAIN	A7,(A1)		; AT END?
	JRST	(AX)		; YES
	HLRZ	A7,STR1(A7)	; NO - CARRY ON
	JRST	STRE3
SUBTTL CPYSTR - COPY STRING ROUTINE

; ON ENTRY:
; A0,A1 CONTAIN THE VALUE OF THE OLD STRING VARIABLE
; A2 CONTAINS THE ADDRESS OF THE NEW STRING VARIABLE
; A4 CONTAINS THE ADDRESS OF THE NEW BYTE STRING
; A7 CONTAINS THE LOWEST BYTE NUMBER TO BE COPIED
; A10 CONTAINS THE NUMBER OF BYTES TO BE COPIED
; A11 IS THE ARRAY EXIT FLAG, TO TIDY STACK IF NEW STRING
; IS CREATED ON THE THE STACK
; THE LINK IS IN AX

; A3 AND A13 ARE SACRED, AS THIS ROUTINE IS CALLED FROM PARAM

CPYSTR:	XCT	[
	TLZ	A1,STRDYN
	TLO	A1,STRDYN](A11)	; SET/CLEAR DYNAMIC BIT AS REQUIRED
	TLZ	A1,STRPRT!STRSPB
				; AND CLEAR PROTECT AND SPARE BITS
	MOVEM	A1,STR2(A2)	; AND SET UP SECOND WORD OF STRING
	DPB	A10,[
	POINT	24,STR2(A2),35]	; AND PLANT BYTE COUNT
	JUMPE	A10,CPYS7	; SPECIAL TREATMENT IF NULL STRING
	MOVEM	A4,STR1(A2)	; SET UP FIRST WORD OF STRING
	HLL	A4,A1
	TLZ	A4,STRBSC
	TLO	A4,440000	; BYTE POINTER FOR NEW BYTE STRING
	HRRZ	A12,.JBREL	; GET ADDRESS OF TOP OF CORE

CPYS1:	HRRZ	A5,A0
	HLL	A5,A1
	TLZ	A5,STRBSC
	TLO	A5,440000	; BYTE POINTER FOR OLD STRING
	TLZ	A1,STRBCC	; GET BYTE COUNT
	JRST	CPYS4

CPYS2:	ILDB	A6,A5
	SOJG	A7,CPYS2	; IDLE UNTIL FIRST BYTE REQUIRED
	CAIG	A12,(A4)	; SAFE TO COPY?
	JRST	CPYS6		; NO

CPYS3:	IDPB	A6,A4		; YES COPY BYTE
	SOJE	A10,CPYS5	; COUNT DOWN COPY

CPYS4:	SOJGE	A1,CPYS2	; COUNT DOWN BYTES
	HLRZ	A1,A0		; EXHAUSTED
	JUMPE	A1,CPYS5	; ANY CONCATENATIONS?
	DMOVE	A0,STR1(A1)	; YES - LOAD VALUE OF NEXT STRING
	JRST	CPYS1		; AND CONTINUE
CPYS7:	SETZM	STR1(A2)	; CLEAR FIRST WORD OF NULL STRING

CPYS5:	JUMPN	A11,(AX)	; EXIT UNLESS
	MOVEI	SP,(A4)
	JRST	ARR9		; ARRAY EXIT FLAG SET

CPYS6:	ADDI	A12,2000	; OUT OF CORE
	CCORE	(A12)		; TRY FOR ANOTHER K
	JRST	CPYS3		; OK - CARRY ON
SUBTTL CPYARR - COPY ARRAY ROUTINE

; ON ENTRY:
; A1 = ADDRESS OF SOURCE ARRAY (MAY BE DESTROYED)
; A2 = ADDRESS OF DESTINATION ARRAY
; THAT PART OF THE ARRAY(A1) WHICH IS COMMON WITH
; ARRAY(A2) IS COPIED, WITH APPROPRIATE TYPE CONVERSION

CPYARR:	HRLZI	AX,(AX)		; SAVE OLD LINK IN LH OF AX
	MOVE	A3,1(A1)	; DV POINTER FOR SOURCE ARRAY
	MOVE	A4,1(A2)	; DV POINTER FOR DESTINATION ARRAY
	HLLZ	A5,A3
	HRRI	A5,1(SP)	; COMMON DV POINTER
	MOVE	A13,SP		; SAVE SP

CPYA1:	MOVE	A6,(A3)
	CAMGE	A6,(A4)
	MOVE	A6,(A4)		; LC = MAX(LB(A1),LB(A2))
	MOVE	A7,1(A3)
	CAML	A7,1(A4)
	MOVE	A7,1(A4)	; UC = MIN(UB(A1),UB(A2))
	CAMGE	A7,A6		; UC >= LC?
	JRST	CPYA3		; NO - ABORT COPY
	PUSH	SP,A6		; YES -
	PUSH	SP,A7		; SET LC, UC IN COMMON DV
	ADDI	A3,2		; MOVE ALONG DV POINTERS
	ADDI	A4,1
	AOBJN	A4,CPYA1	; AND CONTINUE IF MORE SUBSCRIPTS
	HLLZ	A6,A3
	HRRI	A6,1(SP)	; WORKING SUBSCRIPTS VECTOR
	MOVE	A7,A5

CPYA2:	PUSH	SP,(A7)		; INITIALIZE WORKING VECTOR
	ADDI	A7,1
	AOBJN	A7,CPYA2	; FROM COMMON DV
	MOVE	A3,(A1)		; GET TYPE AND IV ADDRESS OF SOURCE ARRAY
	MOVE	A4,(A2)		; GET TYPE AND IV ADDRESS OF DESTINATION ARRAY
	HLRZ	A7,A3
	ANDI	A7,$TYPE
	LSH	A7,-11
	HRLZ	A7,TYPTAB(A7)	; LOOK UP SOURCE ENTRY IN PARAM'S MAGIC TABLE
	HLRZ	A10,A4
	ANDI	A10,$TYPE
	LSH	A10,-11
	AND	A7,TYPTAB(A10)	; AND GATE WITH DESTINATION'S ENTRY
	JFFO	A7,CPYA4	; AND SORT IT ALL OUT!!!!!!!
				; (MISMATCHES FALL THROUGH HERE)
CPYA3:	HLRZ	AX,AX		; RESTORE OLD LINK
	MOVE	SP,A13		; RESTORE STACK POINTER
	POPJ	SP,0		; AND EXIT

CPYA4:	LSH	A10,-1		; SHIFT AROUND ODD BIT
	JUMPGE	A10,.+2		; ODD ENTRY?
	SKIPA	A10,CPYA8(A10)	; YES - LOAD IT
	MOVS	A10,CPYA8(A10)	; NO - LOAD EVEN ENTRY

CPYA5:	MOVE	A7,A6		; TAKE COPY OF WORKING VECTOR ADDRESS
	HRRZ	A11,A3		; GET 0TH ILIFFE VECTOR ENTRY FOR SOURCE
	HRRZ	A12,A4		; AND FOR DESTINATION

CPYA6:	ADD	A11,(A7)	; ADVANCE BY NEXT SUBSCRIPT
	ADD	A12,(A7)
	AOBJP	A7,(A10)	; ANY MORE SUBSCRIPTS?
	MOVE	A11,(A11)	; YES - MOVE THROUGH ILIFFE VECTOR ENTRY
	MOVE	A12,(A12)
	JRST	CPYA6

CPYA8:	XWD	CPYA9,CPYA11	; I -> I, I -> R
	XWD	CPYA12,CPYA13	; I -> LR, R -> I
	XWD	CPYA9,CPYA14	; R -> R, R -> LR
	XWD	CPYA15,CPYA16	; LR -> I, LR -> R
	XWD	CPYA17,CPYA3	; LR -> LR, C -> C
	XWD	CPYA3,CPYA3	; C -> LC, LC -> C
	XWD	CPYA3,CPYA9	; LC -> LC, B -> B
	XWD	CPYA17,CPYA3	; S -> S, L -> L
	XWD	CPYA3,0		; N -> N

CPYA9:	MOVE	A0,(A11)	; I -> I, R -> R, B -> B

CPYA10:	MOVEM	A0,(A12)	; GENERAL SINGLE WORD STORE
	JRST	CPYA19

CPYA11:	MOVE	A0,(A11)	; I -> R
	JCIR	CPYA10

CPYA12:	MOVE	A0,(A11)	; I -> LR
	JCILR	CPYA18
CPYA13:	MOVE	A0,(A11)	; R -> I
	JCRI	CPYA10

CPYA14:	MOVE	A0,(A11)	; R -> LR
	MOVEI	A1,0
	JRST	CPYA18

CPYA15:	ADD	A11,-1(A7)	; DOUBLE LAST SUBSCRIPT OF SOURCE
	DMOVE	A0,(A11)	; LR -> I
	JCLRI	CPYA10

CPYA16:	ADD	A11,-1(A7)	; DOUBLE LAST SUBSCRIPT OF SOURCE
				; LR -> R
	IFE PROC-KA10, <
	MOVE	A0,(A11)
	FADR	A0,1(A11)
	JRST	CPYA10>
	IFE PROC-KI10, <
	DMOVE	A0,(A11)
	JCLRR	CPYA10>

CPYA17:	ADD	A11,-1(A7)	; DOUBLE LAST SUBSCRIPT OF SOURCE
	DMOVE	A0,(A11)	; LR -> LR, S -> S

CPYA18:	ADD	A12,-1(A7)	; DOUBLE LAST SUBSCRIPT OF DESTINATION
	DMOVEM	A0,(A12)	; GENERAL DOUBLE WORD STORE


CPYA19:	MOVEI	A11,(A6)	; REVERSE POINTER TO COMMON DV

CPYA20:	AOS	A12,-1(A7)	; GET AND INCREMENT LAST SUBSCRIPT
	CAMG	A12,-1(A11)	; GONE TOO HIGH?
	JRST	CPYA5		; NO - GO BACK FOR NEXT ELEMENT
	MOVE	A12,-2(A11)	; YES - REPLACE
	MOVEM	A12,-1(A7)	; BY MINIMUM VALUE
	SUBI	A11,2		; MOVE DOWN COMMON DV
	CAIG	A11,2(A13)	; DOWN TO FIRST SUBSCRIPT?
	JRST	CPYA3		; YES
	SOJA	A7,CPYA20	; NO - KEEP GOING
SUBTTL GETOWN - GET OWN SPACE ROUTINE

; ON ENTRY,
; IF A0 < 0, A DEFRAGMENTATION IS PERFORMED, AND THE MAXIMUM
; CONTIGUOUS AREA RETURNED
; IF A0 = 0, A1 IS THE ADDRESS OF A SPACE, OR A CHAIN OF SPACES
; TO BE RETURNED TO THE INACTIVE HEAP CHAIN
; IF A0 > 0, A0 IS THE NUMBER OF WORDS OF SPACE REQUIRED
; NON SKIP EXIT FOR FAILURE ON GETTING, AND ALWAYS ON DELETING
; OK SKIP EXIT WITH A1 = ADDRESS OF SPACE OBTAINED

; THE INACTIVE HEAP CHAIN IS ADDRESSED BY %SYS2, AND CONSISTS
; OF A CHAIN OF SPACES WHOSE FIRST WORD IS FORMATTED AS FOLLOWS:

;	LH: NUMBER OF WORDS IN SPACE (INCLUDING THIS ONE)
;	RH: POINTER TO NEXT SPACE (ZERO IF NONE)

GETOWN:	JUMPE	A0,GET12	; JUMP IF SPACE TO BE RETURNED

GET0:	MOVEI	A10,0		; CLEAR DEFRAGMENTATION MARKER
	JUMPL	A0,GET17	; SUPER-GETOWN

GET1:	SKIPN	A1,%SYS2(DB)	; ANY HEAP LEFT?
	POPJ	SP,0		; NO - ERROR RETURN
	MOVEI	A2,%SYS2(DB)	; PREPARE FOR SEARCH

GET2:	HLRZ	A3,(A1)		; GET SIZE OF THIS SPACE
	JUMPE	A3,GET11	; DEFENSIVE!
	CAMLE	A3,A0		; BIG ENOUGH?
	AOJA	A0,GET9		; YES
	MOVE	A2,A1		; NO -
	HRRZ	A1,(A2)		; SELECT NEXT SPACE
	JUMPN	A1,GET2		; AND CONTINUE UNLESS NONE LEFT
	JUMPN	A10,GET8	; DEFRAGMENTATION ALREADY TRIED?

GET3:	MOVEI	A2,%SYS2(DB)	; NO - DEFRAGMENTATION SCAN
	MOVE	A1,%SYS2(DB)	; INITIALIZE LH POINTER

GET4:	MOVEI	A3,%SYS2(DB)
	MOVE	A4,%SYS2(DB)	; INITIALIZE RH POINTER
	HLRZ	A5,(A1)		; EXTRACT LENGTH OF LH SPACE
	ADDI	A5,(A1)		; AND ADD TO ORIGIN
GET5:	CAME	A1,A4		; SKIP ADJACENCY TEST IF SAME SPACES
	CAME	A5,A4		; ADJACENT SPACES?
	JRST	GET7		; NO
	MOVEI	A10,1		; YES - SET DEFRAGMENTATION MARKER
	HRRZ	A5,(A1)
	CAMN	A2,A4
	JRST	[
	HRRM	A5,(A3)
	JRST	GET6]
	HRRM	A5,(A2)		; REMOVE LH SPACE FROM CHAIN
	HRRZ	A6,(A4)
	CAMN	A1,A3
	JRST	[
	HRRM	A6,(A2)
	JRST	GET6]
	HRRM	A6,(A3)		; REMOVE RH SPACE FROM CHAIN

GET6:	HLRZ	A5,(A4)
	HLRZ	A6,(A1)
	ADDI	A5,(A6)		; TOTAL LENGTH OF SPACES
	HRLZM	A5,(A1)		; STORE IN AUGMENTED SPACE
	PUSHJ	SP,GET13	; DELETE AUGMENTED SPACE
	JRST	GET3		; AND RECOMMENCE DEFRAGMENTATION SCAN

GET7:	MOVE	A3,A4
	HRRZ	A4,(A3)		; MOVE RH POINTER TO NEXT SPACE
	JUMPN	A4,GET5		; AND CONTINUE TILL END
	MOVE	A2,A1		; IF SO -
	HRRZ	A1,(A2)		; MOVE LH POINTER TO NEXT SPACE
	JUMPN	A1,GET4		; AND CONTINUE TILL END
	JUMPN	A10,GET1	; TRY AGAIN IF DEFRAGMENTATION SUCCESSFULL

GET8:	POPJ	SP,0		; ERROR RETURN

GET9:	HRRZ	A4,(A1)		; SPACE FOUND
	HRRM	A4,(A2)		; REMOVE SPACE FROM CHAIN
	HRLZM	A0,(A1)		; AND FILL IN SIZE
	CAML	A0,A3		; EXACTLY RIGHT?
	JRST	GET10		; YES
	SUB	A3,A0		; NO - COMPUTE REMAINDER
	PUSH	SP,A1		; AND SAVE A1
	ADD	A1,A0		; GET ADDRESS OF FRAGMENT
	HRLZM	A3,(A1)		; AND FILL IN ITS LENGTH
	PUSHJ	SP,GET13	; DELETE IT
	POP	SP,A1		; RESTORE A1

GET10:	ADDI	A1,1		; AND INCREMENT IT FOR USER
	AOS	(SP)

GET11:	POPJ	SP,0		; OK SKIP EXIT
GET12:	SUBI	A1,1		; DECREMENT A1
GET13:	SKIPE	A2,%SYS2(DB)	; DELETE SPACE - CHAIN EMPTY?
	JRST	GET14		; NO
	HRRZM	A1,%SYS2(DB)	; YES - START IT UP
	POPJ	SP,0

GET14:	HLRZ	A3,(A1)		; GET LENGTH OF SPACE TO BE RETURNED
	JUMPE	A3,GET11	; DEFENSIVE!
	MOVEI	A4,%SYS2(DB)	; AND PREPARE FOR SEARCH

GET15:	HLRZ	A5,(A2)		; GET LENGTH OF THIS SPACE
	CAML	A5,A3		; BIGGER THAN ONE TO BE DELETED?
	JRST	GET16		; YES
	MOVE	A4,A2		; NO -
	HRRZ	A2,(A4)		; SELECT NEXT SPACE
	JUMPN	A2,GET15	; AND CONTINUE UNLESS NONE LEFT

GET16:	HRRM	A1,(A4)		; CHAIN FROM LEFT
	HRRZ	A4,(A1)		; EXTRACT RH FIRST
	HRRM	A2,(A1)		; CHAIN TO RIGHT
	JUMPE	A4,GET11	; EXIT IF IT WAS A SINGLE SPACE
	MOVE	A1,A4		; NO -
	JRST	GET13		; DELETE REMAINDER

GET17:	HRLZI	A0,000001	; SUPER-GETOWN
	PUSHJ	SP,GET3		; FORCE DEFRAGMENTATION
	HLRZ	A0,(A2)		; GET SIZE OF LAST AREA IN CHAIN
	SOJA	A0,GET0		; AND ASK FOR IT
SUBTTL RDOCT/PROCT - READ OCTAL WORD/PRINT OCTAL HALFWORD ROUTINES

; AN OCTAL WORD IS READ AND RETURNED IN A0

RDOCT:	SETZB	A0,A1		; CLEAR ACCUMULATOR AND DIGIT FLAG
	PUSHJ	SP,IGNICH	; IGNORE INVISIBLE  CHARACTERS
	CAIE	A13,"%"		; OCTAL MARKER?

RDOCT4:	IOERR	10,0		; NO

RDOCT1:	JSP	AX,INCHAR	; GET NEXT CHARACTER
	CAIL	A13,"0"
	CAIL	A13,"8"		; IN RANGE 0 - 7?
	JRST	RDOCT3		; NO
	TLNE	A0,700000	; YES - TOP OIT SET?

RDOCT2:	SYSER2	3,0		; YES - COMPLAIN ABOUT OVERFLOW
	LSH	A0,3		; NO - SHIFT UP
	ADDI	A0,-"0"(A13)	; AND ADD IN OIT
	JOV	RDOCT2		; AND CHECK FOR OVERFLOW
	AOJA	A1,RDOCT1	; COUNT DIGITS AND CONTINUE

RDOCT3:	JUMPE	A1,RDOCT4	; TERMINATOR - DIGIT SEEN?
	POPJ	SP,0		; YES - EXIT

; ON ENTRY, THE HALFWORD IS IN A1

SPROCT:	MOVNI	A0,1		; SPECAIL ENTRY FOR CHANNEL -1
	EXCH	A0,%CHAN(DB)
	PUSHJ	SP,PROCT
	MOVEM	A0,%CHAN(DB)	; RESTORE CHANNEL NUMBERS
	POPJ	SP,0

PROCT:	MOVE	A2,[
	POINT	3,A1,17]	; SET UP BYTE POINTER
	MOVEI	A3,6		; AND BYTE COUNT

PROCT1:	ILDB	A13,A2		; GET NEXT OIT
	ADDI	A13,"0"		; ADD ASCII OFFSET
	JSP	AX,OUCHAR	; AND PRINT IT
	SOJN	A3,PROCT1	; ANY MORE OITS?
	POPJ	SP,0		; NO - EXIT
SUBTTL IO CONTROL BITS

; INBYTE FLAG BITS (LH OF CHANNEL NUMBER)

	BYTLA=400000		; LOOK AHEAD REQUIRED (MUST BE BIT 0)

; OUBYTE FLAG BITS (LH OF CHANNEL NUMBER)

	OPTR=400000		; BREAK OUTPUT

; CHANNEL BITS (RH OF CHANNEL NUMBER)

	LOGCHN=000020		; LOGICAL CHANNEL

; CONTROL AREA OFFSETS

	STRPTR=0		; STRING POINTER
	BYTPTR=1		; BYTE POINTER
	BYTCNT=2		; BYTE COUNT
	BDDOFF=3		; BIDIRECTIONAL DEVICE OUTPUT AREA OFFSET
	DEVNAM=3		; DEVICE NAME
	FILNAM=4		; FILE NAME
	FILEXT=5		; FILE EXTENSION
	FILPRT=6		; FILE PROTECTION
	FILPP=7			; FILE PROJECT-PROGRAMMER NUMBER
	DEVCAL=4		; DEVICE CONTROL AREA LENGTH
	FILCAL=4		; FILE CONTROL AREA LENGTH
SUBTTL INBYTE - BYTE INPUT ROUTINE

; INBYTE - NORMAL ENTRY
; NXTBYT - LOOK AHEAD ENTRY
; NON-SKIP EXIT FOR END-OF-FILE
; OK SKIP EXIT WITH BYTE IN A13
; USES A10,A11,A12,A13

; READ BLOCK FROM PHYSICAL DEVICE ROUTINE

INBLK:	SUBI	A10,(DB)	; DE-RELOCATE CHANNEL NUMBER
	HRLZI	A12,<IN>B53
	DPB	A10,[
	POINT	4,A12,12]	; CONSTRUCT IN UUO
	XCT	A12		; AND READ BLOCK
	JRST	INBLK1		; OK
	MOVE	A12,[
	STATZ	0,740000]
	DPB	A10,[
	POINT	4,A12,12]	; CONSTRUCT STATZ UUO
	XCT	A12		; AND GET STATUS
	IOERR	7,0		; ERROR - REPORT IT
	AOS	(SP)		; EOF - SET UP SKIP RETURN

INBLK1:	ADDI	A10,(DB)	; RELOCATE CHANNEL NUMBER
	POPJ	SP,0

INBYTE:	TDZA	A10,A10		; NORMAL ENTRY
NXTBYT:	HRLZI	A10,BYTLA	; LOOK-AHEAD ENTRY
	HLR	A10,%CHAN(DB)	; GET CHANNEL NUMBER
	ADDI	A10,(DB)	; AND RELOCATE IN DATA BASE
	SKIPN	A11,%IODR(A10)	; CHANNEL DEFINED?
	IOERR	2,0		; NO - COMPLAIN
	TLNE	A11,INEOF	; END-OF-FILE?
	POPJ	SP,0		; YES - TAKE ERROR RETURN
	TLNE	A11,TTYDEV	; TTY DEVICE?
	JRST	INBT6		; YES
	JUMPG	A11,INBT14	; LOGICAL DEVICE?
	TLNE	A11,INOK	; NO - OK TO READ?
	JRST	INBT1		; YES
	TLNE	A11,DIRDEV	; NO - DIRECTORY DEVICE?
	TLNE	A11,INFIL	; YES - FILE OPEN FOR INPUT?
	TLNN	A11,ININT	; NO - INITED FOR INPUT?
	IOERR	2,0		; NO - FORBID INPUT
	PUSHJ	SP,INBLK	; READ FIRST BLOCK
	JRST	INBT16		; NOT EOF
	TLO	A11,INEOF
	MOVEM	A11,%IODR(A10)	; EOF - SET FLAG
	POPJ	SP,0		; AND TAKE ERROR RETURN
INBT16:	TLO	A11,INOK	; SET INOK FLAG
	MOVEM	A11,%IODR(A10)

INBT1:	JUMPG	A10,INBT4	; LOOK AHEAD?

INBT2:	MOVE	A13,BYTPTR(A11)	; YES - GET BYTE POINTER
	ILDB	A13,A13		; AND GET NEXT BYTE

INBT3:	AOS	(SP)		; OK SKIP RETURN
	POPJ	SP,0

INBT4:	ILDB	A13,BYTPTR(A11)	; NO - GET NEXT BYTE
	SOSN	BYTCNT(A11)	; ANY BYTES LEFT IN BUFFER
	JRST	INBT5		; NO
	TLNN	A11,ABMODE	; YES - ASCII MODE?
	JRST	INBT3		; NO - EXIT

INBT17:	MOVE	A12,BYTPTR(A11)
	ILDB	A12,A12		; YES - LOOK AT NEXT BYTE
	JUMPN	A12,INBT3	; EXIT UNLESS NULL
	IBP	BYTPTR(A11)	; IF SO
	SOSE	BYTCNT(A11)	; SEARCH FOR NON-NULL
	JRST	INBT17

INBT5:	PUSHJ	SP,INBLK	; READ NEXT BLOCK
	JRST	INBT3		; OK

INBT15:	TLO	A11,INEOF	; END-OF-FILE
	MOVEM	A11,%IODR(A10)
	JRST	INBT3		; SET EOF FLAG BUT EXIT OK

INBT6:	TLNE	A11,INOK	; TTY - OK TO READ?
	JRST	INBT12		; YES
	TLNE	A11,TTYTTC	; NO - ON TTCALL?
	JRST	INBT7		; YES
	PUSHJ	SP,INBLK	; NO - READ NEXT BLOCK
	JRST	INBT11		; OK
	MOVEI	A13,CONZ	; EOF - GIVE THE USER A CONTROL-Z
	JRST	INBT15
INBT7:	HRLZI	A12,440700	; READ FROM TTCALL TTY
	HRRI	A12,%IBUFF(DB)	; SET UP INITIAL BYTE POINTER
	MOVEM	A12,%TTY+BYTPTR(DB)
	MOVEI	A11,0		; INITIALIZE BYTE COUNT
	TTCALL	4,A13		; WAIT FOR FIRST BYTE
	JRST	INBT9

INBT8:	TTCALL	5,A13		; GET NEXT BYTE, IF ANY
	JRST	INBT10		; NONE LEFT

INBT9:	IDPB	A13,A12		; STORE BYTE IN BUFFER
	CAIGE	A11,121		; BUFFER FULL?
	AOJA	A11,INBT8	; NO - KEEP GOING

INBT10:	MOVEM	A11,%TTY+BYTCNT(DB)
				; STORE BYTE COUNT
	MOVE	A11,%IODR(A10)	; RESTORE CHANNEL FLAGS

INBT11:	TLO	A11,INOK	; SET OK TO READ
	MOVEM	A11,%IODR(A10)

INBT12:	JUMPL	A10,INBT2	; LOOK AHEAD?
	ILDB	A13,BYTPTR(A11)	; NO - GET BYTE
	SOSN	BYTCNT(A11)	; AND DECREMENT BYTE COUNT
	JRST	INBT13		; END OF BUFFER
	MOVE	A12,BYTPTR(A11)
	ILDB	A12,A12		; LOOK AT NEXT BYTE
	JUMPN	A12,INBT3	; AND EXIT UNLESS NULL

INBT13:	TLZ	A11,INOK
	MOVEM	A11,%IODR(A10)	; CLEAR INOK FLAG
	JRST	INBT3		; BUT EXIT OK

INBT14:	JUMPL	A10,INBT2	; LOGICAL DEVICE - LOOK AHEAD?
	ILDB	A13,BYTPTR(A11)	; NO - GET BYTE
	SOSE	BYTCNT(A11)	; ANY MORE?
	JRST	INBT3		; YES
	JRST	INBT15		; NO
SUBTTL OUBYTE - BYTE OUTPUT ROUTINE

; ENTRY WITH BYTE IN A13
; NON-SKIP EXIT FOR END-OF-FILE
; OK SKIP EXIT
; USES A10,A11,A12,A13

; WRITE BLOCK TO PHYSICAL DEVICE ROUTINE

OUTBLK:	SUBI	A10,(DB)	; DE-RELOCATE CHANNEL NUMBER
	HRLZI	A12,<OUT>B53
	DPB	A10,[
	POINT	4,A12,12]	; CONSTRUCT OUT UUO
	XCT	A12		; AND WRITE BLOCK
	JRST	OUBLK1		; OK
	MOVE	A12,[
	STATZ	0,700000]
	DPB	A10,[
	POINT	4,A12,12]	; CONSTRUCT STATZ UUO
	XCT	A12		; AND GET STATUS
	IOERR	7,0		; ERROR - REPORT IT
	AOS	(SP)		; EOF ETC. - SET UP SKIP RETURN

OUBLK1:	ADDI	A10,(DB)	; RELOCATE IO CHANNEL NUMBER
	POPJ	SP,0

OUBYTE:	TDZA	A10,A10		; NORMAL ENTRY
BRKBYT:	HRLZI	A10,OPTR	; BREAK OUTPUT ENTRY
	HRR	A10,%CHAN(DB)	; GET CHANNEL NUMBER
	ADDI	A10,(DB)	; AND RELOCATE IN DATA BASE
	SKIPN	A11,%IODR(A10)	; CHANNEL DEFINED?
	IOERR	2,0		; NO - COMPLAIN
	TLNE	A11,OUTEOF	; LOGICAL EOF?
	POPJ	SP,0		; YES - TAKE ERROR RETURN
	JUMPG	A11,OUBT6	; LOGICAL DEVICE?
	TLNE	A11,TTYDEV	; NO - TTY DEVICE?
	ADDI	A11,BDDOFF	; YES - OUTPUT OFFSET
	TLNE	A11,OUTOK	; OK TO WRITE?
	JRST	OUBT2		; YES
	TLNE	A11,DIRDEV	; NO - DIRECTORY DEVICE?
	TLNE	A11,OUTFIL	; YES - FILE OPEN FOR OUTPUT?
	TLNN	A11,OUTINT	; NO - INITED FOR OUTPUT?
	IOERR	2,0		; NO - FORBID OUTPUT
	TLNE	A11,TTYTTC	; TTY ON TTCALL?
	PUSHJ	SP,OUBT10	; YES - INITIALIZE (SKIP RETURN)
	PUSHJ	SP,OUTBLK	; DO FIRST OUT
	JRST	OUBT1		; OK
	TLO	A11,OUTEOF	; EOF
	MOVEM	A11,%IODR(A10)	; SET OUTEOF FLAG
	POPJ	SP,0		; AND GIVE ERROR RETURN
OUBT1:	TLO	A11,OUTOK	; SET OK TO WRITE
	HLLM	A11,%IODR(A10)

OUBT2:	JUMPL	A10,OUBT4	; BREAK OUTPUT?
	IDPB	A13,BYTPTR(A11)	; NO - PLANT BYTE
	SOSN	BYTCNT(A11)	; DECREMENT BYTE COUNT
	JRST	OUBT4		; EXPIRED

OUBT3:	AOS	(SP)		; OK - SKIP RETURN
	POPJ	SP,0

OUBT4:	TLNE	A11,TTYTTC	; TTY ON TTCALL?
	JRST	OUBT5		; YES
	PUSHJ	SP,OUTBLK	; NO - WRITE BLOCK
	JRST	OUBT3		; OK
	TLO	A11,OUTEOF
	HLLM	A11,%IODR(A10)	; SET OUTEOF FLAG
	JRST	OUBT3

OUBT5:	MOVEI	A13,0
	IDPB	A13,%TTY+BDDOFF+BYTPTR(DB)
				; PLANT NULL TERMINATING BYTE
	TTCALL	3,%OBUFF(DB)	; AND OUTPUT BUFFER

OUBT10:	HRLZI	A12,440700
	HRRI	A12,%OBUFF(DB)	; SET UP INITIAL BYTE POINTER
	MOVEM	A12,%TTY+BDDOFF+BYTPTR(DB)
	MOVEI	A12,122		; AND INITIAL BYTE COUNT
	MOVEM	A12,%TTY+BDDOFF+BYTCNT(DB)
	JRST	OUBT3

OUBT6:	JUMPL	A10,OUBT7	; BREAK OUTPUT?
	IDPB	A13,BYTPTR(A11)	; NO - PLANT BYTE
	SOSE	BYTCNT(A11)	; DECREMENT BYTE COUNT
	JRST	OUBT3		; STILL OK

OUBT9:	TLO	A11,OUTEOF
	MOVEM	A11,%IODR(A10)	; SET EOF FLAG
	JRST	OUBT3

OUBT7:	MOVEI	A13,0		; BREAK OUTPUT

OUBT8:	SOSGE	A13,BYTCNT(A11)
	JRST	OUBT9
	IDPB	A13,BYTPTR(A11)	; FILL UP WITH NULL BYTES
	JRST	OUBT8
SUBTTL READ - READ NUMBER ROUTINE

; ON ENTRY A2 = MODE REQUIRED:

;	0	INTEGER
;	1	REAL
;	2	LONG REAL
;	4	ANY (AS IT COMES)

; ON EXIT THE NUMBER IS IN

;	A0	INTEGER OR REAL
;	A0,A1	LONG REAL

; AND IF THE ENTRY WAS 'ANY', THE TYPE IS IN A2

; FLAGS (LH OF A2):

	DECPNT=400000		; DECIMAL POINT SEEN (MUST BE BIT 0)
	IGNDIG=200000		; IGNORE DIGITS
	MANDIG=100000		; DIGIT SEEN IN MANTISSA
	EXPDIG=040000		; DIGIT SEEN IN EXPONENT
	MANSGN=020000		; MANTISSA SIGN
	EXPSGN=010000		; EXPONENT SIGN
	EXPOVL=004000		; EXPONENT OVERFLOW

; TYPES (LH AND RH OF A2):

	SREAL=1			; REAL
	LREAL=2			; LONG REAL
	ANY=4			; ANY
; SERVICE ROUTINES FOR READ

; SUPPLIES ASCII BYTE IN A13
; LINK IS IN AX

INCHAR:	PUSHJ	SP,INBYTE	; GET NEXT BYTE
	IOERR	6,0		; END OF FILE
	JRST	(AX)

; IGNORE INVISIBLE CHARACTERS

IGNICH:	JSP	AX,INCHAR	; GET CHARACTER
IGN0:	CAIE	A13," "
	CAIN	A13,"	"
	JRST	IGNICH		; IGNORE SPACES AND TABS
	CAIL	A13,LF
	CAILE	A13,CR
	POPJ	SP,0
	JRST	IGNICH		; IGNORE CR, LF, VT AND FF
READ:	HLRZ	A1,%CHAN(DB)	; GET CURRENT INPUT CHANNEL NUMBER
	ADDI	A1,(DB)
	MOVE	A1,%IODR(A1)	; GET CHANNEL ENTRY
	TLNN	A1,ABMODE	; ASCII OR BINARY?
	JRST	READ37		; BINARY
	SETZB	A0,A1		; CLEAR ACCUMULATORS
	SETZB	A3,A4		; CLEAR DECIMAL PLACE COUNT
				; AND BINARY EXPONENT CORRECTION
	HRL	A2,A2		; COPY FLAGS TO LH OF A2
	TRZ	A2,ANY		; AND CLEAR ANY FLAG IN RH
	PUSHJ	SP,IGNICH	; IGNORE INVISIBLE CHARACTERS
	CAIN	A13,"+"		; LEADING "+"?
	JRST	READ1		; YES
	CAIE	A13,"-"		; LEADING "-"?
	JRST	READ2		; NO
	TLO	A2,MANSGN	; YES - FLAG MANTISSA NEGATIVE

READ1:	JSP	AX,INCHAR	; GET NEXT CHARACTER

READ2:	CAIL	A13,"0"
	CAIL	A13,"0"+^D10	; IN RANGE 0 - 9?
	JRST	READ10		; NO
	TLNE	A2,IGNDIG	; YES - IGNORE DIGIT?
	JRST	READ8		; YES
	TLO	A2,MANDIG	; NO - FLAG DIGIT SEEN
	HLRZ	AX,READ13(A2)
	JRST	(AX)		; USE APPROPRIATE SEQUENCE

; INTEGER NUMBER SEQUENCE

READ3:	MOVE	A0,A1
	IMULI	A1,^D10		; MULTIPLY BY TEN
	JOV	READ4		; OVERFLOW?
	ADDI	A1,-"0"(A13)	; NO - ADD IN DIGIT
	JOV	READ4		; OVERFLOW NOW?
	JRST	READ1		; NO - OK

READ4:	TRO	A2,LREAL	; CONVERT TO LONG REAL
	MOVE	A1,A0		; RESTORING OLD MANTISSA
	MOVEI	A0,0		; IN LONG FORM
; LONG REAL NUMBER SEQUENCE

READ5:	MOVE	A7,A0
	MOVE	A5,A1
	MULI	A5,^D10		; MULTIPLY LOW ORDER WORD BY TEN
	IMULI	A0,^D10		; MULTIPLY HIGH ORDER WORD BY TEN
	EXCH	A6,A1		; REPLACE OLD LOW ORDER WORD BY NEW ONE,
				; AND SAVE OLD ONE
	ADD	A0,A5		; ADD CARRY INTO HIGH ORDER WORD
	TLO	A1,400000	; FLAG LOW ORDER WORD
	ADDI	A1,-"0"(A13)	; AND ADD IN DIGIT
	TLZN	A1,400000	; AND IF CARRY OCCURED
	ADDI	A0,1		; INCREMENT HIGH ORDER WORD
	TLNE	A0,777000	; NUMBER TOO LARGE?
	JRST	READ7		; YES

READ6:	JUMPGE	A2,READ1	; NO - DECIMAL POINT SEEN?
	SOJA	A3,READ1	; YES - INCREMENT DECIMAL PLACE COUNT

READ7:	TLO	A2,IGNDIG	; SET IGNORE DIGIT FLAG
	MOVE	A0,A7
	MOVE	A1,A6		; AND RESTORE OLD MANTISSA
	CAIGE	A13,"5"		; DIGIT >= 5?
	JRST	READ8		; NO
	TLO	A1,400000	; YES - FLAG LOW ORDER WORD
	ADDI	A1,1		; AND INCREMENT IT
	TLZN	A1,400000	; AND IF CARRY OCCURED
	ADDI	A0,1		; INCREMENT HIGH ORDER WORD
	TLNN	A0,777000	; TOO BIG NOW?
	JRST	READ8		; NO
	ASHC	A0,-1		; YES - SHIFT IT DOWN
	ADDI	A4,1		; AND INCREMENT BINARY EXPONENT CORRECTION

READ8:	JUMPL	A2,READ1	; DECIMAL POINT SEEN?
	AOJA	A3,READ1	; NO - DECREMENT DECIMAL PLACE COUNT
; REAL NUMBER SEQUENCE

READ9:	MOVE	A0,A1
	IMULI	A1,^D10		; MULTIPLY BY TEN
	ADDI	A1,-"0"(A13)	; AND ADD IN DIGIT
	TLNN	A1,777000	; TOO LARGE?
	JRST	READ6		; NO
	TLO	A2,IGNDIG	; YES - SET IGNORE DIGIT FLAG
	MOVE	A1,A0		; AND RESTORE OLD MANTISSA
	CAIGE	A13,"5"		; DIGIT >= 5?
	JRST	READ8		; NO
	ADDI	A1,1		; YES - INCREMENT MANTISSA
	TLNN	A1,777000	; TOO BIG NOW?
	JRST	READ8		; NO
	ASH	A1,-1		; YES - SHIFT IT DOWN
	AOJA	A4,READ8	; AND INCREMENT BINARY EXPONENT CORRECTION

READ10:	CAIE	A13,"."		; DECIMAL POINT?
	JRST	READ12		; NO
	TLOE	A2,DECPNT	; ALREADY FOUND?
	JRST	READ21		; YES - GO AND COMPLAIN
	MOVEI	AX,READ1	; SET RETURN LINK

; SMALL SUBROUTINE FOR CONVERTING INTEGER TO REAL OR LONG REAL

READ11:	TRNE	A2,SREAL!LREAL	; INTEGER TYPE?
	JRST	(AX)		; NO - RETURN
	TLNN	A1,777000	; LONG MANTISSA?
	TROA	A2,SREAL	; NO - SET REAL TYPE
	IORI	A2,LREAL	; YES - SET LONG REAL TYPE
	MOVEI	A0,0		; CLEAR HIGH ORDER WORD
	JRST	(AX)		; AND EXIT

; END OF MANTISSA SEQUENCE

READ12:	CAIE	A13,"&"		; IS IT "&"
	CAIN	A13,"@"		; OR "@"?
	JRST	READ15		; YES
	CAIE	A13,"E"		; IS IT "E" (FOR FORTRAN'S SAKE)
	CAIN	A13,"D"		; OR "D"?
	JRST	READ16		; YES
	CAIE	A13,"+"		; CHECK FOR
	CAIN	A13,"-"		; ILLEGAL TERMINATORS
	JRST	READ21		; AND COMPLAIN IF FOUND
	TLNN	A2,MANDIG	; WAS THERE A MANTISSA?
	JRST	READ21		; NO - COMPLAIN
	MOVE	A5,A0
	MOVE	A6,A1		; TAKE COPY OF MANTISSA
	HRRZ	AX,READ13(A2)
	JRST	(AX)		; AND USE APPROPRIATE SEQUENCE
READ13:	XWD	READ3,READ14	; SEQUENCE DISPATCH TABLE
	XWD	READ9,READ23
	XWD	READ5,READ27

; INTEGER TERMINAL SEQUENCE

READ14:	MOVE	A0,A1
	TLNE	A2,MANSGN	; SHOULD IT BE NEGATIVE?
	MOVN	A0,A0		; YES - NEGATE
	JRST	READ35		; PROCEDE TO EXIT SEQUENCE

; EXPONENT SEQUENCE

READ15:	JSP	AX,INCHAR	; "&" OR "@" FOUND
	CAIE	A13,"&"
	CAIN	A13,"@"		; ANOTHER ONE?
	JRST	READ16		; YES
	PUSHJ	SP,IGN0		; IGNORE ANY INVISIBLES
	JRST	.+2

READ16:	PUSHJ	SP,IGNICH	; IGNORE INVISIBLES
	JSP	AX,READ11	; FIX MANTISSA UP
	TLNN	A2,MANDIG	; DOES MANTISSA HAVE DIGITS?
	MOVEI	A1,1		; NO - FORCE A ONE
	DMOVE	A5,A0		; SAVE MANTISSA
	SETZB	A0,A1		; CLEAR ACCUMULATORS
	CAIN	A13,"+"		; "+"?
	JRST	READ18		; YES
	CAIE	A13,"-"		; "-"?
	JRST	READ19		; NO
	TLOA	A2,EXPSGN	; YES - FLAG EXPONENT NEGATIVE (AND SKIP!)

READ17:	TLO	A2,EXPOVL	; FLAG EXPONENT OVERFLOW

READ18:	JSP	AX,INCHAR	; GET NEXT CHARACTER

READ19:	CAIL	A13,"0"
	CAIL	A13,"0"+^D10	; IN RANGE 0 - 9?
	JRST	READ20		; NO
	TLNE	A2,EXPOVL	; YES - EXPONENT OVERFLOW SET?
	JRST	INCHAR		; YES - IGNORE DIGIT
	TLO	A2,EXPDIG	; FLAG DIGIT SEEN
	MULI	A0,^D10		; MULTIPLY BY TEN
	JUMPN	A0,READ17	; OVERFLOWED?
	EXCH	A0,A1		; NO
	TLO	A0,400000	; FLAG EXPONENT
	ADDI	A0,-"0"(A13)	; AND ADD IN DIGIT
	TLZN	A0,400000	; DID IT OVERFLOW?
	JRST	READ17		; YES
	JRST	READ18		; NO - CARRY ON
READ20:	CAIE	A13,"+"		; END OF EXPONENT
	CAIN	A13,"-"		; TEST FOR ILLEGAL TERMINATORS
	JRST	READ21
	CAIE	A13,"&"
	CAIN	A13,"@"
	JRST	READ21
	CAIE	A13,"D"
	CAIN	A13,"E"
	JRST	READ21
	CAIE	A13,"."
	TLNN	A2,EXPDIG	; AND CHECK DIGITS SEEN

READ21:	IOERR	10,0		; COMPLAIN ABOUT BAD CHARACTERS
	TLNE	A2,EXPOVL	; EXPONENT OVERFLOW?

READ22:	IOERR	11,0		; YES - COMPLAIN
	TLNN	A2,EXPSGN	; SHOULD EXPONENT BE NEGATIVE?
	MOVN	A0,A0		; NO - FORM NEGATIVE EXPONENT
	SUB	A3,A0		; TRUE NEGATIVE EXPONENT
	CAILE	A3,^D38		; TOO LARGE?
	JRST	READ22		; YES - GIVE OVERFLOW
	TRNN	A2,LREAL	; LONG REAL TYPE

READ23:	TLNE	A2,LREAL	; OR LONG REAL RESULT REQUIRED?
	JRST	READ27		; YES

; REAL TERMINAL SEQUENCE

	MOVE	A0,A6		; NO - ONLY REAL
	JUMPE	A0,READ35	; ESCAPE FOR ZERO MANTISSA
	TLO	A0,233000
	FADRI	A0,000000	; STANDARDIZE MANTISSA
	FSC	A0,(A4)		; AND ALLOW FOR BINARY EXPONENT CORRECTION
	TLNE	A2,MANSGN	; SHOULD MANTISSA BE NEGATIVE?
	MOVN	A0,A0		; YES - NEGATE IT
	JUMPE	A3,READ35	; ANY EXPONENT?
	MOVM	A4,A3		; EXPONENT MAGNITUDE

READ24:	CAIG	A4,^D38		; EXPONENT VERY SMALL OR LARGE?
	JRST	READ25		; NO
	JUMPGE	A3,READ22	; IF LARGE - YOU LOSE!
	FDVR	A0,STEN38	; YES - DIVIDE BY 1.0&38
	JUMPE	A0,READ35	; AND EXIT IF UNDERFLOWED
	SUBI	A4,^D38		; OTHERWISE CUT DOWN EXPONENT
	JRST	READ24		; AND TRY AGAIN

READ25:	JUMPL	A3,READ26	; POSITIVE EXPONENT?
	FMPR	A0,STEN(A4)	; YES - MULTIPLY
	JFOV	READ22		; OVERFLOWED?
	JRST	READ35		; NO - EXIT

READ26:	FDVR	A0,STEN(A4)	; DIVIDE
	JRST	READ35		; AND EXIT
; LONG REAL TERMINAL SEQUENCE

READ27:	JUMPN	A5,READ28
				; HIGH ORDER WORD = 0?
	JUMPE	A6,READ34	; YES - LOW ORDER WORD = 0

READ28:	TLNE	A5,000400	; NO - BIT 9 SET?
	JRST	READ29		; YES - OK
	ASHC	A5,1		; NO - SHIFT UP
	SOJA	A4,READ28	; AND INCREMENT BINARY EXPONENT CORRECTION

READ29:	ADDI	A4,276		; CALCULATE CORRECT EXPONENT
	DPB	A4,[
	POINT	9,A5,8]		; AND FORM HIGH WORD
	IFE PROC-KA10, <
	LSH	A6,-10		; CLEAR SPACE FOR LOW ORDER EXPONENT
	JUMPE	A6,READ30	; LOW MANTISSA ZERO?
	SUBI	A4,33		; LOW WORD EXPONENT (KA10)
	JUMPGE	A4,.+2		; TOO LOW?
	TDZA	A6,A6		; YES - CLEAR LOW WORD
	DPB	A4,[
	POINT	9,A6,8]		; NO - FORM LOW WORD

READ30:	TLNE	A2,MANSGN	; SHOULD IT BE NEGATIVE?
	DFN	A5,A6		; YES - NEGATE IT>
	IFE PROC-KI10, <
	TLNE	A2,MANSGN	; SHOULD IT BE NEGATIVE (KI10)?
	DMOVN	A5,A5		; YES - NEGATE IT>
	JUMPE	A3,READ34	; ANY EXPONENT?
	MOVM	A4,A3		; EXPONENT MAGNITUDE

READ31:	CAIG	A4,^D38		; EXPONENT VERY SMALL OR LARGE
	JRST	READ32		; NO
	JUMPGE	A3,READ22	; IF LARGE - YOU LOSE!
	MOVEI	A10,^D38
	JSP	AX,DFDVR	; YES - DIVIDE BY 1.0&&38
	JUMPE	A5,READ34	; EXIT IF UNDERFLOWED
	SUBI	A4,^D38		; OTHERWISE CUT DOWN EXPONENT
	JRST	READ31		; AND TRY AGAIN

READ32:	MOVE	A10,A4
	JUMPL	A3,READ33	; POSITIVE EXPONENT?
	JSP	AX,DFMPR	; YES - MULTIPLY
	JRST	READ22		; OVERFLOW?
	JRST	READ34		; NO - EXIT

READ33:	JSP	AX,DFDVR	; DIVIDE
	JRST	READ34

READ34:	DMOVE	A0,A5
; EXIT SEQUENCE

READ35:	LDB	A3,[
	POINT	3,A2,17]
	ANDI	A2,-1		; DATA TYPE
	POP	SP,AX		; MOVE LINK TO AX
	XCT	READ36(A2)

READ36:	JRST	(AX)		; INTEGER NUMBER
	JUMPE	A3,RI		; REAL NUMBER
	JUMPE	A3,LRI		; LONG REAL NUMBER

; BINARY READ

READ37:	PUSHJ	SP,INBYTE	; READ NEXT WORD
	IOERR	6,0
	MOVE	A0,A13
	CAIE	A2,2		; LONG REAL?
	POPJ	SP,0		; NO
	PUSHJ	SP,INBYTE	; YES - READ SECOND WORD
	IOERR	6,0
	MOVE	A1,A13
	POPJ	SP,0
SUBTTL PRINT - PRINT NUMBER ROUTINE

; ON ENTRY THE NUMBER IS IN

;	A0	INTEGER, REAL
;	A0,A1	LONG REAL

; A2 = TYPE OF VARIABLE:

;	0	INTEGER
;	1	REAL
;	2	LONG REAL

; A3,A4 = MODE OF PRINTING REQUIRED:

;	A3	NUMBER OF DIGITS BEFORE POINT (M)
;	A4	NUMBER OF DIGITS AFTER POINT (N)

;	(M,0)	INTEGER MODE
;	(M,N)	FIXED POINT MODE
;	(0,N)	FLOATING POINT MODE
;	(0,0)	'STANDARD' MODE

; FLAGS (LH OF A2):

	NUMRNG=400000		; NUMBER RANGE (EXPONENT SIGN - MUST BE BIT 0)
	NUMSGN=200000		; SIGN FLAG
	INTOVL=100000		; INTEGER OVERFLOW
	LNGEXP=040000		; LONG EXPONENT
	LNGMAN=020000		; LONG MANTISSA
	DIGEXH=010000		; DIGITS EXHAUSTED

; MAXIMUM SIGNIFICANCE:

	INTDIG=^D11
	SRDIG=^D9
	IFE PROC-KA10, <
	LRDIG=^D17>
	IFE PROC-KI10, <
	LRDIG=^D20>
; SERVICE ROUTINES FOR PRINT

; PRINTS ASCII BYTE IN A13
; LINK IS IN AX

PRIN1:	SKIPA	A13,["."]	; SPECIAL ENTRY FOR DECIMAL POINT
PRIN2:	MOVEI	A13," "		; SPECIAL ENTRY FOR SPACE

OUCHAR:	PUSHJ	SP,OUBYTE	; OUTPUT BYTE
	IOERR	6,0		; END OF FILE
	JRST	(AX)

BRKCHR:	PUSHJ	SP,BRKBYT	; BREAKOUTPUT
	IOERR	6,0		; END OF FILE
	JRST	(AX)

; PRINT SIGN ROUTINE

; PRINTS SPACE OR "-" ACCORDING AS NUMSGN IN A2 IS UNSET OR SET
; LINK IS IN AX

PRIN3:	MOVEI	A13," "
	TLZE	A2,NUMSGN	; ALWAYS CLEAR THAT FLAG
	MOVEI	A13,"-"		; SELECT SIGN
	JRST	OUCHAR		; AND PRINT IT

; OUTPUT DIGIT ROUTINE

; GETS DIGIT FROM DIGIT STACK AND PRINTS IT
; LINK IS IN AX

PRIN4:	MOVEI	A13,"0"
	TLNE	A2,DIGEXH	; DIGITS EXHAUSTED?
	JRST	OUCHAR		; YES
	MOVE	A13,(A7)	; GET NEXT DIGIT
	ADDI	A13,"0"		; AND CONVERT TO ASCII
	SOJN	A6,.+2		; TOTAL COUNT EXPIRED?
	TLO	A2,DIGEXH	; YES - FLAG DIGITS EXHAUSTED
	AOJA	A7,OUCHAR	; MOVE POINTER AND PRINT DIGIT
PRINT:	HRRZ	A5,%CHAN(DB)	; GET OUTPUT CHANNEL NUMBER
	ADDI	A5,(DB)
	MOVE	A5,%IODR(A5)	; AND GET CHANNEL ENTRY
	TLNN	A5,ABMODE	; ASCII OR BINARY?
	JRST	PRIN54		; BINARY
	JUMPN	A3,PRIN13	; ANY DIGITS BEFORE POINT?
	JUMPN	A4,PRIN13	; OR AFTER IT?
	XCT	PRIN5(A2)	; NO - 'STANDARD' MODE
	JRST	PRIN13

PRIN5:	MOVEI	A3,INTDIG	; STANDARD INTEGER FORMAT
	MOVEI	A4,SRDIG-2	; STANDARD REAL FORMAT
	MOVEI	A4,LRDIG-2	; STANDARD LONG REAL FORMAT

; INTEGER PRINT ROUTINE

IPRINT:	MOVEI	A3,1		; SPECIAL INTEGER PRINT
	SETZB	A2,A4

PRIN6:	JUMPGE	A0,PRIN7	; NEGATIVE?
	TLO	A2,NUMSGN	; YES - SET SIGN FLAG
	MOVN	A0,A0		; AND NEGATE
	JOV	[
	TLO	A2,INTOVL	; OVERFLOWED - SET FLAG
	MOVE	A0,[
	^D24359738368]		; AND LOAD 2^35 - 10^10
	JRST	PRIN7]

PRIN7:	MOVEI	A5,1		; SET UP DIGIT COUNT

PRIN8:	IDIVI	A0,^D10		; AND GENERATE DIGITS IN REVERSE
	PUSH	SP,A1		; AND SAVE THEM ON THE STACK
	JUMPE	A0,PRIN9	; ANY LEFT?
	AOJA	A5,PRIN8	; YES - COUNT AND CARRY ON

PRIN9:	TLNE	A2,INTOVL	; DID OVERFLOW OCCUR?
	AOS	(SP)		; YES - PRODUCE 2^35!!!

PRIN10:	CAML	A5,A3		; ANY LEADING SPACES?
	JRST	PRIN11		; NO
	JSP	AX,PRIN2	; YES - PRINT ONE
	SOJA	A3,PRIN10	; AND DECREASE M UNTIL FINISHED

PRIN11:	JSP	AX,PRIN3	; PRINT SIGN
PRIN12:	POP	SP,A13		; POP UP DIGIT
	ADDI	A13,"0"		; ADD ASCII OFFSET
	JSP	AX,OUCHAR	; AND PRINT IT
	SOJN	A5,PRIN12	; REPEAT UNTIL FINISHED
	POPJ	SP,0		; EXIT FROM ROUTINE

PRIN13:	JUMPG	A2,PRIN17	; JUMP UNLESS INTEGER NUMBER
	JUMPE	A4,PRIN6	; USE PRIN6 IF INTEGER MODE
	JUMPE	A3,PRIN14	; JUMP IF FLOATING POINT MODE
	PUSHJ	SP,PRIN6	; FIXED POINT MODE - USE PRIN6
	JSP	AX,PRIN1	; PRINT DECIMAL POINT
	MOVEI	A13,"0"
	SOJGE	A4,OUCHAR	; AND N ZEROS
	POPJ	SP,0

PRIN14:	JUMPGE	A0,PRIN15	; FLOATING POINT MODE - NEGATIVE?
	TLO	A2,NUMSGN	; YES - SET SIGN FLAG
	MOVN	A0,A0		; AND NEGATE
	JOV	[
	MOVSI	A0,244400	; OVERFLOW - FORM 2^35
	JRST	PRIN18]

PRIN15:	CAML	A0,[
	^D100000000]		; 9 OR MORE DIGITS?
	JRST	PRIN16		; YES
	CIR			; NO - CONVERT TO REAL
	JRST	PRIN18

PRIN16:	CILR			; CONVERT TO LONG REAL
	TLO	A2,LNGMAN	; AND FLAG LONG MANTISSA
	JRST	PRIN28

PRIN17:	MOVEI	A13,0		; CLEAR EXPONENT
	SOJG	A2,PRIN26	; JUMP IF LONG REAL NUMBER
; REAL STANDARDIZATION SEQUENCE

	FADRI	A0,000000	; ENSURE STANDARDIZED
	JFOV	[
	MOVEI	A0,0		; BAD NUMBER - ZERO IT
	JRST	PRIN22]
	JUMPGE	A0,PRIN18	; NUMBER NEGATIVE?
	TLO	A2,NUMSGN	; YES - SET SIGN FLAG
	MOVN	A0,A0		; AND NEGATE IT

PRIN18:	JUMPE	A0,PRIN22	; ESCAPE IF ZERO
	MOVE	A5,A0
	CAML	A0,STEN		; NUMBER < 1.0?
	JRST	PRIN19		; NO
	TLO	A2,NUMRNG	; YES - SET RANGE FLAG
	CAML	A0,STENM1	; NUMBER < 0.1?
	JRST	PRIN25		; NO - IN RANGE
	CAMGE	A0,[
	XWD	002663,437347]	; VERY SMALL NUMBER?
	JRST	PRIN23		; YES - SAVE OVERFLOWS!
	MOVSI	A5,(1.0)
	FDVR	A5,A0		; TAKE RECIPROCAL

PRIN19:	HRLZI	A13,-^D38	; LOAD COUNTER

PRIN20:	CAML	A5,STEN1(A13)	; COMPARE WITH TABLE
	AOBJN	A13,PRIN20	; UNTIL LARGER ENTRY FOUND
	JUMPL	A13,PRIN21	; ENTRY FOUND?
	JUMPL	A2,PRIN24	; NO - LOW RANGE?
	FDVR	A0,STEN38	; NO
	FDVR	A0,STEN1	; - DIVIDE BY 1.0&39
	AOJA	A13,PRIN25

PRIN21:	ANDI	A13,-1		; ENTRY FOUND - CLEAR OUT COUNT
	JUMPL	A2,PRIN24	; LOW RANGE?
	FDVR	A0,STEN1(A13)	; NO - DIVIDE TO BRING INTO RANGE

PRIN22:	AOJA	A13,PRIN25	; AND CORRECT EXPONENT

PRIN23:	MOVEI	A13,^D38	; DEAL WITH OVERFLOW IN RECIPROCAL

PRIN24:	FMPR	A0,STEN(A13)	; LOW RANGE - MULTIPLY TO BRING INTO RANGE
	MOVN	A13,A13		; NEGATIVE EXPONENT
PRIN25:	MOVEI	A5,SRDIG	; SET MAXIMUM SINGLE PRECISION LENGTH
	JUMPE	A0,PRIN36	; SAVE TIME FOR ZERO
	LDB	A7,[
	POINT	9,A0,8]		; EXTRACT EXPONENT
	TLZ	A0,377000	; AND CLEAR IT OUT
	ASH	A0,-170(A7)	; AND CONVERT TO FRACTIONAL FORM
	JOV	[
	MOVE	A0,[
	XWD	031463,146315]
	AOJA	A13,PRIN36]	; CORRECT IF OVERFLOWED
	JRST	PRIN36
; LONG REAL STANDARDIZATION SEQUENCE

PRIN26:	IFE PROC-KA10, <
	FADL	A0,A1
	TDNN	A1,[
	XWD	000777,777777]	; LOW MANTISSA ZERO?
	MOVEI	A1,0		; YES - CLEAR LOW ORDER WORD>
	IFE PROC-KI10, <
	FADRI	A0,000000>	; ENSURE STANDARDIZED
	JUMPGE	A0,PRIN27	; LONG REAL - NUMBER NEGATIVE?
	TLO	A2,NUMSGN	; YES - SET SIGN FLAG
	IFE PROC-KA10, <
	DFN	A0,A1>
	IFE PROC-KI10, <
	DMOVN	A0,A0>		; AND NEGATE IT

PRIN27:	TLO	A2,LNGEXP	; FLAG LONG EXPONENT

PRIN28:	LDB	A5,[
	POINT	9,A0,8]
	CAIGE	A5,33		; IF SMALL HIGH WORD AND
	JUMPE	A1,PRIN18	; IF LOW ORDER WORD IS ZERO USE SINGLE PRECISION
	TLO	A2,LNGMAN	; FLAG LONG MANTISSA
	DMOVE	A5,A0
	CAMN	A0,HTEN
	CAMGE	A1,LTEN
	CAML	A0,HTEN		; NUMBER < 1.0?
	JRST	PRIN30		; NO
	TLO	A2,NUMRNG	; YES - SET RANGE FLAG
	CAMN	A0,HTENM1
	CAMGE	A1,LTENM1
	CAML	A0,HTENM1	; NUMBER < 0.1?
	JRST	PRIN35		; NO - IN RANGE
	CAMGE	A5,[
	XWD	002663,437347]	; VERY SMALL NUMBER?
	JRST	PRIN33		; YES - SAVE OVERFLOWS!
	MOVSI	A0,(1.0)
	FDVR	A0,A5		; TAKE SINGLE PRECISION RECIPROCAL

PRIN30:	HRLZI	A13,-^D38	; LOAD COUNTER
PRIN31:	CAML	A0,HTEN1(A13)	; COMPARE WITH TABLE
	AOBJN	A13,PRIN31	; UNTIL LARGER ENTRY FOUND
	JUMPL	A13,PRIN32	; ENTRY FOUND?
	JUMPL	A2,PRIN34	; NO - LOW RANGE?
	MOVEI	A10,^D38	; NO
	JSP	AX,DFDVR
	MOVEI	A10,^D1
	JSP	AX,DFDVR	; DIVIDE BY 1.0&&39
	AOJA	A13,PRIN35
PRIN32:	ANDI	A13,-1		; ENTRY FOUND - CLEAR OUT COUNT
	JUMPL	A2,PRIN34	; LOW RANGE?
	MOVEI	A10,1(A13)
	JSP	AX,DFDVR	; NO - DIVIDE TO BRING INTO RANGE
	AOJA	A13,PRIN35	; AND CORRECT EXPONENT

PRIN33:	MOVEI	A13,^D38	; DEAL WITH OVERFLOW IN RECIPROCAL

PRIN34:	MOVE	A10,A13		; LOW RANGE
	JSP	AX,DFMPR	; MULTIPLY TO BRING INTO RANGE
	HALT	.		; OVERFLOW CANNOT OCCUR!
	MOVN	A13,A13		; NEGATIVE EXPONENT

PRIN35:	DMOVE	A0,A5		; RESTORE RESULT TO A0,A1
	MOVEI	A5,LRDIG	; SET MAXIMUM DOUBLE PRECISION LENGTH
	IFE PROC-KA10, <
	LSH	A1,10		; IF KA10, LOSE LOW ORDER EXPONENT>
	LDB	A7,[
	POINT	9,A0,8]		; EXTRACT EXPONENT
	TLZ	A0,377000	; AND CLEAR IT OUT
	ASHC	A0,-170(A7)	; AND CONVERT TO FRACTIONAL FORM
	JOV	[
	MOVE	A0,[
	XWD	031463,146314]
	MOVE	A1,[
	XWD	314631,463146]
	AOJA	A13,PRIN36]	; CORRECT IF OVERFLOWED
; ROUNDING AND DIGIT GENERATION SEQUENCE

PRIN36:	MOVEI	A6,1(A4)	; NUMBER OF DIGITS TO BE PRINTED
	JUMPE	A3,PRIN37	; = N+1 IF FLOATING POINT FORMAT,
	ADD	A6,A13
	SOJGE	A6,PRIN37
	MOVEI	A6,0		; MAX (N+E, 0) IF FIXED POINT FORMAT

PRIN37:	CAILE	A6,(A5)		; BUT NEVER MORE THAN
	MOVEI	A6,(A5)		; MAXIMUM PERMITTED
	MOVE	A5,SP		; MARK BOTTOM OF DIGIT STACK
	PUSH	SP,LTEN		; AND ALLOW FOR POSSIBLE OVERFLOW
	MOVEI	A7,1(A6)	; NUMBER OF DIGITS TO BE PRODUCED
	TLNE	A2,LNGMAN	; LONG MANTISSA?
	JRST	PRIN39		; YES

PRIN38:	MULI	A0,^D10		; MULTIPLY BY 10
	PUSH	SP,A0		; STORE DIGIT ON DIGIT STACK
	MOVE	A0,A1		; AND SET UP NEW FRACTION
	SOJN	A7,PRIN38
	JRST	PRIN40

PRIN39:	MOVE	A10,A1
	MULI	A10,^D10	; MULTIPLY LOW ORDER WORD BY 10
	MOVE	A1,A11		; AND RESET LOW ORDER FRACTION
	MOVE	A11,A0
	MULI	A11,^D10	; MULTIPLY HIGH ORDER WORD BY 10
	TLO	A12,400000	; FLAG LOW ORDER SIGN BIT OF RESULT
	ADD	A12,A10		; AND ADD CARRY FROM LOW ORDER MULTIPLY
	TLZN	A12,400000	; AND IF IT OVERFLOWS
	ADDI	A11,1		; INCREMENT HIGH ORDER CARRY
	MOVE	A0,A12		; RESET HIGH ORDER FRACTION
	PUSH	SP,A11		; STORE DIGIT ON DIGIT STACK
	SOJN	A7,PRIN39

PRIN40:	MOVEI	A10,-1(SP)	; ADDRESS OF LAST DIGIT TO BE PRINTED
	MOVE	A12,1(A10)
	CAIGE	A12,5		; WOULD ROUNDING GENERATE CARRY?
	JRST	PRIN42		; NO

PRIN41:	AOS	A12,(A10)	; INCREMENT DIGIT
	CAIE	A12,^D10	; ANY CARRY?
	JRST	PRIN42		; NO
	SETZM	(A10)		; YES - REPLACE BY ZERO
	SOJA	A10,PRIN41	; KEEP GOING
PRIN42:	MOVEI	A7,1(A5)	; ADDRESS OF OVERFLOW DIGIT
	SKIPE	(A7)		; OVERFLOW OCCURRED?
	AOJA	A13,PRIN43	; YES - INCREMENT EXPONENT
	ADDI	A7,1		; NO - MOVE TO FIRST DIGIT

PRIN43:	MOVE	A0,A13		; TRANSFER EXPONENT TO SAFE PLACE
	JUMPE	A3,PRIN50	; JUMP IF FLOATING POINT MODE
; FIXED POINT PRINTING SEQUENCE

	JUMPG	A0,.+2
	JUMPL	A2,PRIN48	; JUMP IF NUMBER < 1.0
	MOVEI	AX,PRIN44

PRIN44:	CAMGE	A0,A3		; LEADING SPACES REQUIRED?
	SOJA	A3,PRIN2
	JSP	AX,PRIN3	; PRINT SIGN
	JSP	AX,PRIN4	; OUTPUT INTEGRAL DIGIT
	SOJN	A0,PRIN4	; RETURN IF MORE DIGITS
	JUMPE	A4,PRIN46	; ANY FRACTION?
	JSP	AX,PRIN1	; YES - PRINT DECIMAL POINT

PRIN45:	JSP	AX,PRIN4	; OUTPUT FRACTIONAL DIGIT
	SOJN	A4,PRIN4	; RETURN IF MORE DIGITS

PRIN46:	MOVE	SP,A5		; RESTORE STACK
	POPJ	SP,0		; EXIT

PRIN47:	JSP	AX,PRIN2	; PRINT LEADING SPACES

PRIN48:	SOJN	A3,PRIN47	; ANY LEFT?
	JSP	AX,PRIN3	; NO - PRINT SIGN
	MOVEI	A13,"0"
	JSP	AX,OUCHAR	; OUTPUT A ZERO
	JUMPE	A4,PRIN46	; FRACTION TO BE PRINTED?
	JSP	AX,PRIN1	; YES - OUTPUT DECIMAL POINT

PRIN49:	AOJG	A0,PRIN45	; OUTPUT ZEROS IF REQUIRED
	MOVEI	A13,"0"
	JSP	AX,OUCHAR
	SOJN	A4,PRIN49
	JRST	PRIN46		; NO DIGITS REQUIRED!
; FLOATING POINT PRINTING SEQUENCE

PRIN50:	JSP	AX,PRIN3	; FLOATING POINT MODE - OUTPUT SIGN
	JSP	AX,PRIN4	; OUTPUT FIRST DIGIT
	JSP	AX,PRIN1	; AND DECIMAL POINT
	JSP	AX,PRIN4	; OUTPUT FRACTIONAL DIGIT
	SOJN	A4,PRIN4	; RETURN IF MORE DIGITS
	SOJE	A0,PRIN52	; CALCULATE EXPONENT - ESCAPE IF ZERO

PRIN51:	MOVEI	A13,"&"
	JSP	AX,OUCHAR	; OUTPUT "&"
	TLZE	A2,LNGEXP
	JRST	PRIN51		; AND SECOND ONE IF LONG REAL NUMBER
	MOVEI	A3,2		; AND SET DIGIT COUNT
	MOVE	SP,A5		; RESTORE STACK POINTER
	JRST	PRIN6		; AND LET PRIN6 DO THE WORK

PRIN52:	MOVEI	A3,4		; SUPPRESS ZERO EXPONENT
	TLZE	A2,LNGEXP
	MOVEI	A3,5		; TAKING ACCOUNT OF LONG REAL
	MOVEI	AX,PRIN53

PRIN53:	SOJGE	A3,PRIN2	; AND OUTPUT SPACES
	JRST	PRIN46

; BINARY READ

PRIN54:	MOVE	A13,A0
	JSP	AX,OUCHAR	; OUTPUT FIRST WORD
	CAIE	A2,2		; LONG REAL?
	POPJ	SP,0		; NO
	MOVE	A13,A1
	JSP	AX,OUCHAR	; YES - OUTPUT SECOND WORD
	POPJ	SP,0
SUBTTL KA10/KI10 DOUBLE PRECISION MULTIPLY/DIVIDE

; ON ENTRY:
; THE LEFT HAND OPERAND IS IN A5,A6
; THE RIGHT HAND OPERAND IS IN HTEN AND LTEN, INDEXED BY A10
; THE LINK IS IN AX
; ON EXIT:
; THE RESULT IS IN A5,A6
; FOR MULTIPLY ONLY:
; ERROR RETURN IF OVERFLOW
; OK SKIP RETURN

	IFE PROC-KA10, <

DFMPR:	MOVE	A7,A5		; COPY HIGH WORD OF LH OPERAND
	FMPR	A7,LTEN(A10)	; FORM ONE CROSS PRODUCT IN A7
	JFOVO	(AX)		; SPECIAL UNDERFLOW HANDLING
	FMPR	A6,HTEN(A10)	; FORM OTHER CROSS PRODUCT IN A6
	JFOVO	(AX)		; SPECIAL UNDERFLOW HANDLING
	UFA	A6,A7		; ADD CROSS PRODUCTS IN A7
	FMPL	A5,HTEN(A10)	; FORM HIGH ORDER PRODUCT IN A5,A6
	JFOV	(AX)
	UFA	A6,A7		; ADD CROSS PRODUCTS SUM TO LOW PART
	FADL	A5,A7		; ADD TOGETHER LOW AND HIGH PARTS OF RESULT
	JRST	1(AX)

DFDVR:	FDVL	A5,HTEN(A10)	; GET HIGH PART OF QUOTIENT
	MOVN	A7,A5		; AND NEGATE IT
	FMPR	A7,LTEN(A10)	; MULTIPLY BY LOW PART OF DIVISOR
	JFOVO	.		; SPECIAL UNDERFLOW HANDLING
				; (OVERFLOW IMPOSSIBLE!)
	UFA	A6,A7		; ADD REMAINDER
	FDVR	A7,HTEN(A10)	; DIVIDE SUM BY HIGH PART OF DIVISOR
	FADL	A5,A7		; ADD RESULT TO ORIGINAL QUOTIENT
	JRST	(AX)>

	IFE PROC-KI10, <

DFMPR:	MOVE	A7,HTEN(A10)
	MOVE	A10,LTEN(A10)
	DFMP	A5,A7		; MULTIPLY
	JFOV	(AX)		; OVERFLOW?
	JRST	1(AX)		; NO

DFDVR:	MOVE	A7,HTEN(A10)
	MOVE	A10,LTEN(A10)
	DFDV	A5,A7		; DIVIDE
	JRST	(AX)>
SUBTTL SELIN/SELOUT - SELECT INPUT/OUTPUT ROUTINES

; ON ENTRY A1 = CHANNEL NUMBER TO BE SELECTED

SELIN:	JUMPL	A1,SEL1		; ALWAYS ALLOW CHANNEL -1
	MOVEI	A2,(A1)
	ADDI	A2,(DB)		; RELOCATE IO DIRECTORY
	SKIPE	A2,%IODR(A2)	; CHANNEL DEFINED?
	TLNN	A2,ININT	; YES - DEVICE INITED FOR INPUT?
	IOERR	2,0		; NO - COMPLAIN

SEL1:	HRLM	A1,%CHAN(DB)	; YES - SELECT IT
	POPJ	SP,0

SELOUT:	JUMPL	A1,SEL2		; ALWAYS ALLOW CHANNEL -1
	MOVEI	A2,(A1)
	ADDI	A2,(DB)		; RELOCATE IO DIRECTORY
	SKIPE	A2,%IODR(A2)	; CHANNEL DEFINED?
	TLNN	A2,OUTINT	; YES - DEVICE INITED FOR OUTPUT?
	IOERR	2,0		; NO - COMPLAIN

SEL2:	HRRM	A1,%CHAN(DB)	; YES - SELECT IT
	POPJ	SP,0
SUBTTL INPT/OUTPT - INPUT/OUTPUT DEVICE INITIALIZATION ROUTINE

; ON ENTRY:
; A0 = DEVICE NAME (IF PHYSICAL DEVICE), OR STRING ADDRESS (IF LOGICAL DEVICE)
; LH(A1) = NUMBER OF BUFFERS REQUIRED (PHYSICAL DEVICES ONLY)
; RH(A1) = CHANNEL NUMBER
; A2 = MODE (PHYSICAL DEVICES ONLY)

; DEVCHR FLAGS (LH):

	DEVDDS=400000		; DTA DIRECTORY IN STORE
	DEVDSK=200000		; DSK
	DEVCDR=100000		; CDR/CDP
	DEVLPT=040000		; LPT
	DEVTAJ=020000		; TTY ATTACHED TO JOB
	DEVTUC=010000		; TTY IN USE AS USER'S CONSOLE
	DEVTIO=004000		; TTY IN USE FOR IO
	DEVDSP=002000		; DISPLAY
	DEVLDT=001000		; LONG DISPATCH TABLE
	DEVPTP=000400		; PTP
	DEVPTR=000200		; PTR
	DEVDTA=000100		; DTA
	DEVAA=000040		; DEVICE AVAILABLE OR ASSIGNED TO THIS JOB
	DEVMTA=000020		; MTA
	DEVTTY=000010		; TTY
	DEVDIR=000004		; DIRECTORY DEVICE
	DEVIN=000002		; DEVICE CAN DO INPUT
	DEVOUT=000001		; DEVICE CAN DO OUTPUT

; DEVTYP FLAGS (LH):

	DEVSPL=000020		; DEVICE IS SPOOLED

; IO FLAGS (LH OF A2):

	INFLG=DEVIN		; INPUT FLAG
	OUTFLG=DEVOUT		; OUTPUT FLAG
; IO DIRECTORY SETUP FLAG COMBINATIONS:

	IODSKI=PLDEV!DIRDEV!INDEV!ININT!OUTDEV
	IOCDR=PLDEV!INDEV!ININT
	IOLPT=PLDEV!OUTDEV!OUTINT
	IODSKO=PLDEV!DIRDEV!INDEV!OUTDEV!OUTINT
	IOCDP=PLDEV!OUTDEV!OUTINT
	IOPTP=PLDEV!OUTDEV!OUTINT
	IOPTR=PLDEV!INDEV!ININT
	IODTAI=PLDEV!DIRDEV!INDEV!ININT!OUTDEV
	IOMTAI=PLDEV!SPOPRN!INDEV!ININT!OUTDEV
	IOTTY=PLDEV!TTYDEV!INDEV!ININT!OUTDEV!OUTINT
	IODTAO=PLDEV!DIRDEV!INDEV!OUTDEV!OUTINT
	IOMTAO=PLDEV!SPOPRN!INDEV!OUTDEV!OUTINT
	IOPLT=PLDEV!PLTDEV!OUTDEV!OUTINT
	IOLOGI=INDEV!ININT!INOK
	IOLOGO=OUTDEV!OUTINT!OUTOK
	IOTTC=PLDEV!TTYDEV!TTYTTC!ABMODE!INDEV!ININT!OUTDEV!OUTINT

; JFFO IGNORE FLAGS:

	JFFFLG=DEVDDS!DEVTAJ!DEVTUC!DEVTIO!DEVLDT!DEVAA!DEVDIR!DEVIN!DEVOUT

; BUFFER LENGTHS: (USED IF DEVSIZ NOT IMPLEMENTED)

	DSKBL=203		; DSK
	CDRBL=36		; CDR
	LPTBL=34		; LPT
	CDPBL=35		; CDP
	PTPBL=43		; PTP
	PTRBL=43		; PTR
	DTABL=203		; DTA
	MTABL=203		; MTA
	TTYBL=23		; TTY
	PLTBL=46		; PLT
; MAGIC TABLE OF DEVICE PROPERTIES:

; LH = IO DIRECTORY ENTRY BITS
; RH = BUFFER LENGTH (TOTAL)

	INOU1=.-1

	XWD	IODSKI,DSKBL	; DSK (INPUT)
	XWD	IOCDR,CDRBL	; CDR
	XWD	IOLPT,LPTBL	; LPT
	XWD	0,0		; SPARE
	XWD	IODSKO,DSKBL	; DSK (OUTPUT)
	XWD	IOCDP,CDPBL	; CDP
	XWD	0,0		; DISPLAY (NOT SUPPORTED)
	XWD	0,0		; SPARE
	XWD	IOPTP,PTPBL	; PTP
	XWD	IOPTR,PTRBL	; PTR
	XWD	IODTAI,DTABL	; DTA (INPUT)
	XWD	IOPLT,PLTBL	; PLT
	XWD	IOMTAI,MTABL	; MTA (INPUT)
	XWD	IOTTY,2*TTYBL	; TTY
	XWD	IODTAO,DTABL	; DTA (OUTPUT)
	XWD	0,0		; SPARE
	XWD	IOMTAO,MTABL	; MTA (OUTPUT)
INPT:	TLOA	A2,INFLG	; SET INPUT FLAG
OUTPT:	TLO	A2,OUTFLG	; SET OUTPUT FLAG
	PUSHJ	SP,RELESE	; ENSURE CHANNEL IS RELEASED
	JFCL	.+1		; ERROR RETURN IS OK
	TRNN	A1,LOGCHN	; LOGICAL CHANNEL?
	JRST	INOU2		; NO
	PUSH	SP,A0		; YES -
	PUSH	SP,A1
	PUSH	SP,A2		; SAVE A0-A2
	MOVEI	A0,3
	PUSHJ	SP,GETOWN	; AND ASK FOR 3 WORDS
	SYSER1	12,0		; FAILED
	POP	SP,A4		; RESTORE IO FLAG
	POP	SP,A2		; RESTORE CHANNEL NUMBER
	ADDI	A2,(DB)		; AND RELOCATE IT
	POP	SP,A3		; RESTORE STRING ADDRESS
	MOVEM	A3,STRPTR(A1)	; FILL IN ADDRESS OF STRING
	HLLZ	A0,STR2(A3)
	HRLI	A1,IOLOGI
	TLNE	A4,INFLG	; INPUT?
	JRST	INOU13		; YES
	TLNN	A0,STRDYN	; NO - DYNAMIC?
	SYSER1	17,0		; NO - COMPLAIN
	HRLI	A1,IOLOGO

INOU13:	TLZ	A0,STRBSC	; GET BYTE SIZE FROM STRING
	HLRZ	A4,A0
	LSH	A4,-6
	CAIE	A4,^D36		; IF NOT 36 BIT BYTES
	TLO	A1,ABMODE	; THEN SET ASCII MODE
	TLO	A0,440000	; AND SET INITIAL BYTE POSITION
	HRR	A0,STR1(A3)	; SET UP BYTE STRING ADDRESS
	MOVEM	A0,BYTPTR(A1)	; FILL IN BYTE POINTER
	MOVE	A0,STR2(A3)
	TLZ	A0,STRBCC	; GET BYTE COUNT FROM STRING
	MOVEM	A0,BYTCNT(A1)	; FILL IN BYTE COUNT
	JUMPG	A0,.+2
	TLO	A1,OUTEOF	; SET OUTEOF IF NO BYTES
	MOVEM	A1,%IODR(A2)	; SET UP IO DIRECTORY ENTRY
	POPJ	SP,0
INOU2:	MOVE	A3,A0		; PHYSICAL DEVICE
	CALLI	A3,DEVCHR	; GET ITS CHARACTERISTICS
	JUMPE	A3,INOU3	; CHECK IT EXISTS
	SETCM	A4,A3		; GET COMPLEMENTED CHARACTERISTICS
	AND	A4,A2		; AND MASK WITH IO REQUIREMENTS
	TLNE	A3,DEVAA	; DEVICE AVAILABLE?
	TLNE	A4,INFLG!OUTFLG	; AND OK FOR IO REQUIREMENTS?
	JRST	INOU3		; NO
	HRRZ	A4,A2		; YES - GET MODE REQUIRED
	CAIL	A4,15		; DUMP MODE REQUIRED?
	JRST	INOU4		; YES - CAN'T HANDLE IT
	MOVEI	A5,1
	LSH	A5,(A4)		; AND CONSTRUCT ONE BIT MASK
	AND	A5,A3		; WITH DEVICE CHARACTERISTICS
	JUMPE	A5,INOU4	; JUMP IF ILLEGAL MODE
	HLLZ	A5,A3		; GET LH OF CHARACTERISTICS
	TLZ	A5,JFFFLG	; AND CLEAR UNWANTED FLAGS
	JFFO	A5,INOU5	; SORT IT ALL OUT
	TLNN	A3,DEVOUT	; FUNNY DEVICE
	JRST	INOU3		; CAN IT DO OUTPUT?
	MOVEI	A6,14		; YES - MUST BE A PLOTTER
	JRST	INOU7

INOU3:	IOERR	0,0		; DEVICE NO GOOD
INOU4:	IOERR	1,0		; WRONG MODE

INOU5:	TLNN	A3,DEVCDR	; CDR/CDP?
	JRST	INOU6		; NO
	TLNE	A3,DEVOUT	; YES - CAN IT DO OUTPUT?
	ADDI	A6,4		; YES - OFFSET FOR CDP
	JRST	INOU7

INOU6:	TLNN	A3,DEVDSK!DEVDTA!DEVMTA
				; DSK, DTA OR MTA?
	JRST	INOU7		; NO
	TLNE	A2,OUTFLG	; YES - REQUIRED FOR OUTPUT?
	ADDI	A6,4		; YES - ADD OFFSET
INOU7:	SKIPN	A3,INOU1(A6)	; GET DEVICE PROPERTIES
	JRST	INOU3		; NO GOOD FOR ALGOL (DISPLAY, ETC.)
	CAIGE	A4,2		; ASCII MODE?
	TLO	A3,ABMODE	; YES - SET ASCII/BINARY FLAG
	MOVEM	A4,%SYS7(DB)	; SAVE DEVICE MODE
	MOVEM	A0,%SYS10(DB)	; SAVE DEVICE NAME
	CALLI	A0,DEVTYP	; FIND OUT MORE
	MOVEI	A0,0		; UUO NOT IMPLEMENTED
	TLNE	A0,DEVSPL	; SPOOLED DEVICE?
	TLO	A3,SPLDEV	; YES
	HLRZ	A0,A1		; GET NUMBER OF BUFFERS REQUIRED
	MOVEI	A5,%SYS7(DB)
	CALLI	A5,DEVSIZ	; GET BUFFER SIZE OF DEVICE
	JRST	INOU11		; UUO NOT IMPLEMENTED
	JUMPL	A5,[
	AOJE	A5,INOU3	; DEFENSIVE CODING
	JRST	INOU4]
	HRR	A3,A5		; GET BUFFER SIZE
	TLNE	A3,TTYDEV	; TTY TYPE DEVICE?
	ADDI	A3,(A5)		; YES - DOUBLE UP BUFFERS
	JUMPN	A0,INOU12	; ANY BUFFERS SPECIFIED?
	HLRZ	A0,A5		; NO - USE DEFAULT
	JRST	INOU12

INOU11:	JUMPN	A0,INOU12	; NO DEVSIZ - ANY BUFFERS SPECIFIED?
	MOVEI	A0,2		; NO - DEFAULT IS 2

INOU12:	MOVEM	A0,%SYS11(DB)	; SAVE NUMBER OF BUFFERS
	IMULI	A0,(A3)		; MULTIPLY BY BUFFER SIZE
	MOVN	A4,A0		; PREPARE TO CALCULATE BUFFER OFFSET
	ADDI	A0,DEVCAL	; ALLOW FOR CONTROL AREA AND DEVICE NAME
	TLNE	A3,TTYDEV	; TTY TYPE DEVICE?
	ADDI	A0,BDDOFF	; YES - ALLOW FOR SECOND CONTROL AREA
	TLNE	A3,DIRDEV!SPLDEV
				; DIRECTORY DEVICE?
	ADDI	A0,FILCAL	; YES - ALLOW FOR FILE CONTROL AREA
	ADD	A4,A0		; CALCULATE BUFFER OFFSET
	HRL	A1,A4		; AND STORE IN LH OF CHANNEL NUMBER
	MOVEM	A1,%SYS12(DB)	; SAVE CHANNEL NUMBER
	MOVEM	A3,%SYS13(DB)	; SAVE DEVICE PROPERTIES
	PUSHJ	SP,GETOWN	; GET SPACE FOR CONTROL AREAS AND BUFFERS
	SYSER1	12,0		; FAILED
	MOVE	A2,%SYS13(DB)	; DEVICE PROPERTIES
	HRR	A2,A1		; ADD CONTROL AREA ADDRESS
	MOVE	A3,%SYS12(DB)	; RESTORE CHANNEL NUMBER
	HLRZ	A4,A3		; AND BUFFER OFFSET
	HRRZ	A5,A1
	HRLI	A5,BDDOFF(A1)	; PREPARE CONTROL AREA POINTERS
	TLNE	A2,TTYDEV	; TTY TYPE DEVICE?
	JRST	INOU8		; YES - ALL SET UP
	TLNE	A2,ININT	; NO - JUST INPUT DEVICE?
	TLZA	A5,-1		; YES - KILL OUTPUT SECTION
	HRLZ	A5,A5		; NO - KILL INPUT SECTION
INOU8:	EXCH	A5,%SYS11(DB)	; INTERCHANGE WITH NUMBER OF BUFFERS
	HRLZI	A6,<OPEN>B53
	HRRI	A6,%SYS7(DB)
	DPB	A3,[
	POINT	4,A6,12]	; PREPARE OPEN CH,
	XCT	A6		; AND TRY TO OPEN DEVICE
	JRST	INOU3		; ALAS - FAILED
	MOVE	A0,%SYS10(DB)	; RECOVER DEVICE NAME
	ADD	A4,A1		; CALCULATE ADDRESS OF BUFFERS
	MOVEM	A4,.JBFF	; AND SET UP JOBFF
	HRRZ	A4,A2		; LOOK FOR PLACE FOR DEVICE NAME .....
	TLNN	A2,ININT	; INPUT REQUIRED?
	JRST	INOU9		; NO
	HRLI	A5,<INBUF>B53	; YES
	DPB	A3,[
	POINT	4,A5,12]	; PREPARE INBUF CH,
	XCT	A5		; AND SET UP BUFFERS
	ADDI	A4,BDDOFF	; .....

INOU9:	TLNN	A2,OUTINT	; OUTPUT REQUIRED?
	JRST	INOU10		; NO
	HRLI	A5,<OUTBUF>B53	; YES
	DPB	A3,[
	POINT	4,A5,12]	; PREPARE OUTBUF CH,
	XCT	A5		; AND SET UP BUFFERS
	ADDI	A4,BDDOFF	; .....

INOU10:	ADDI	A3,(DB)		; RELOCATE CHANNEL NUMBER
	MOVEM	A2,%IODR(A3)	; SET UP DIRECTORY ENTRY FOR CHANNEL
	MOVEM	A0,(A4)		; STORE DEVICE NAME
	SETOM	.JBFF		; FIX JOBFF
	POPJ	SP,0		; AND EXIT
SUBTTL RELESE - RELEASE IO CHANNEL ROUTINE

; ON ENTRY A1 = CHANNEL NUMBER TO BE RELEASED
; NON SKIP RETURN IF CHANNEL NOT DEFINED
; OK SKIP RETURN
; A0, A1 AND A2 ARE SAVED AS THIS ROUTINE IS CALLED
; FROM INPT/OUTPT

RELESE:	MOVEI	A4,(A1)
	ADDI	A4,(DB)		; RELOCATE CHANNEL NUMBER
	SKIPN	A3,%IODR(A4)	; CHANNEL DEFINED?
	POPJ	SP,0		; NO - ERROR RETURN
	TLNN	A3,OUTOK	; DEVICE DOING OUTPUT?
	JRST	REL1		; NO
	EXCH	A1,%CHAN(DB)	; YES - FAKE THIS CHANNEL
	PUSHJ	SP,BRKBYT	; AND BREAK OUTPUT
	JFCL	.+1
	EXCH	A1,%CHAN(DB)	; RESTORE IO CHANNELS

REL1:	PUSHJ	SP,CLFIL0	; CLOSE FILE IF ANY
	JFCL	.+1		; ERROR RETURN IS OK
	SETZM	%IODR(A4)	; CLEAR IO DIRECTORY ENTRY
	TLNN	A3,ININT	; INPUT DEVICE?
	JRST	REL2		; NO
	HLRZ	A4,%CHAN(DB)	; YES - GET CURRENT INPUT CHANNEL NUMBER
	CAIN	A4,(A1)		; THIS ONE?
	HRROS	%CHAN(DB)	; YES - DESELECT IT

REL2:	TLNN	A3,OUTINT	; OUTPUT DEVICE?
	JRST	REL3		; NO
	HRRZ	A4,%CHAN(DB)	; YES - GET CURRENT OUTPUT CHANNEL NUMBER
	CAIN	A4,(A1)		; THIS ONE?
	HLLOS	%CHAN(DB)	; YES - DESELECT IT
REL3:	DMOVEM	A0,%SYS11(DB)
	MOVEM	A2,%SYS13(DB)	; SAVE A0 - A2
	HRRZ	A1,A3
	MOVEI	A0,0
	PUSHJ	SP,GETOWN	; AND DELETE CONTROL AREAS AND BUFFERS
	DMOVE	A0,%SYS11(DB)
	MOVE	A2,%SYS13(DB)	; RESTORE A0 - A2
	AOS	(SP)		; SKIP LINK
	TLNN	A2,PLDEV	; LOGICAL DEVICE?
	POPJ	SP,0		; YES - EXIT
	TLNN	A2,SPOPRN	; SPECIAL OPERATIONS PERMITTED?
	JRST	REL4		; NO
	HRLZI	A4,<CLOSE>B53	; YES - IT'S A MAGNETIC TAPE
	DPB	A1,[
	POINT	4,A4,A2]	; PREPARE CLOSE CH,0
	XCT	A4		; AND EXECUTE IT

REL4:	HRLZI	A4,<RELEAS>B53
	DPB	A1,[
	POINT	4,A4,12]	; PREPARE RELEAS CH,
	XCT	A4		; AND RELEASE DEVICE
	POPJ	SP,0		; EXIT

SUBTTL OPFILE - OPEN FILE ROUTINE

; ON ENTRY:
; A1 = CHANNEL NUMBER
; A2 = FILE NAME
; A3 = FILE EXTENSION (LEFT HALF)
; A4 = PROTECTION (TOP 9 BITS)
; A5 = PROJECT-PROGRAMMER NUMBER

OPFILE:	MOVEI	A10,(A1)
	ADDI	A10,(DB)	; RELOCATE CHANNEL NUMBER
	SKIPN	A6,%IODR(A10)	; CHANNEL DEFINED?
	IOERR	2,0		; NO - COMPLAIN
	TLNN	A6,DIRDEV!SPLDEV
				; YES - DIRECTORY DEVICE OR SPOOLED?
	IOERR	4,0		; NO - COMPLAIN
	MOVEM	A2,FILNAM(A6)	; STORE FILE NAME,
	MOVEM	A3,FILEXT(A6)	; EXTENSION,
	MOVEM	A4,FILPRT(A6)	; PROTECTION,
	MOVEM	A5,FILPP(A6)	; AND PROJECT-PROGRAMMER NUMBER
	TLNE	A6,INFIL!OUTFIL	; FILE OPEN?
	JRST	OPFIL2		; YES
	HRLZI	A7,<LOOKUP>B53
	TLNE	A6,OUTINT	; INPUT?
	TLOA	A6,OUTFIL	; NO
	TLOA	A6,INFIL	; YES
	HRLZI	A7,<ENTER>B53	; NO

OPFIL1:	HRRI	A7,FILNAM(A6)	; AND GET ADDRESS
	DPB	A1,[
	POINT	4,A7,12]	; FILL IN CHANNEL NUMBER
	XCT	A7		; AND ATTEMPT TO OPEN FILE
	IOERR	5,0		; FAILED
	MOVEM	A6,%IODR(A10)	; AND UPDATE IO DIRECTORY ENTRY
	POPJ	SP,0

OPFIL2:	HRLZI	A7,<RENAME>B53	; PREPARE FOR RENAME
	JUMPN	A2,OPFIL1	; FILE NAME OK?
	TLZ	A6,INFIL!OUTFIL	; NO - REALLY A DELETE
	JRST	OPFIL1
SUBTTL CLFILE - CLOSE FILE ROUTINE

; ON ENTRY A1 = CHANNEL NUMBER
; A0,A1,A2,A3 ARE NOT USED AS THIS ROUTINE IS CALLED
; FROM RELESE (WHICH IS CALLED FROM INPT/OUTPT)

CLFILE:	MOVEI	A4,(A1)
	ADDI	A4,(DB)		; RELOCATE CHANNEL NUMBER

CLFIL0:	SKIPN	A6,%IODR(A4)	; CHANNEL DEFINED?
	IOERR	2,0		; NO - COMPLAIN

CLFIL3:	TLNN	A6,DIRDEV!SPLDEV
				; YES - DIRECTORY DEVICE OR SPOOLED?
	POPJ	SP,0		; NO

CLFIL4:	TLZN	A6,INFIL!OUTFIL	; FILE OPEN?
	JRST	CLFIL1		; NO - GIVE OK RETURN
	HRLZI	A7,<CLOSE>B53	
	DPB	A1,[
	POINT	4,A7,12]	; PREPARE CLOSE CH,0
	XCT	A7		; AND CLOSE FILE
	MOVE	A7,[
	STATZ	0,740000]
	DPB	A1,[
	POINT	4,A7,12]	; PREPARE STATZ CH,740000
	XCT	A7		; FILE CLOSED OK?
	IOERR	12,0		; NO - COMPLAIN
	TLZ	A6,INEOF!OUTEOF!INOK!OUTOK
				; CLEAR EOF AND OK FLAGS
	MOVEM	A6,%IODR(A4)	; RESTORE DIRECTORY ENTRY

CLFIL1:	AOS	(SP)
	POPJ	SP,0		; OK SKIP RETURN

CLFIL2:	MOVEI	A4,(A1)		; SPECIAL TRANSFILE CLOSE
	ADDI	A4,(DB)
	MOVE	A6,%IODR(A4)	; GET DEVICE FLAGS
	TLNN	A6,SPOPRN	; MAGNETIC TAPE?
	JRST	CLFIL3		; NO
	TLNN	A6,OUTDEV	; YES - DOING OUTPUT?
	JRST	CLFIL1		; NO
	JRST	CLFIL4		; YES
SUBTTL XFILE - TRANSFER FILE ROUTINE

; TRANSFERS FILE FROM CURRENT INPUT DEVICE
; TO CURRENT OUTPUT DEVICE, CLOSING FILES (IF ANY)
; AFTER THE OPERATION

XFILE:	PUSHJ	SP,INBYTE	; GET INPUT BYTE
	JRST	XFIL1		; END OF FILE ON INPUT
	PUSHJ	SP,OUBYTE	; OUTPUT BYTE
	JRST	XFIL1		; END OF FILE ON OUTPUT
	JRST	XFILE

XFIL1:	HLRZ	A1,%CHAN(DB)	; GET NUMBER OF CURRENT INPUT CHANNEL
	PUSHJ	SP,CLFIL2	; CLOSE INPUT FILE
	JFCL	.+1
	HRRZ	A1,%CHAN(DB)	; GET NUMBER OF CURRENT OUTPUT CHANNEL
	PUSHJ	SP,CLFIL2	; AND CLOSE OUTPUT FILE
	POPJ	SP,0		; ERROR RETURN IS OK
	POPJ	SP,0
SUBTTL MAGNETIC TAPE ROUTINES

; ON ENTRY, THE CHANNEL NUMBER IS IN A1

BSPACE:	TDZA	A2,A2		; BACKSPACE
ENFILE:	MOVEI	A2,1		; ENDFILE
	JRST	SO1
REWIND:	MOVEI	A2,2		; REWIND

SO1:	MOVEI	A3,(A1)
	ADDI	A3,(DB)		; RELOCATE CHANNEL NUMBER
	SKIPN	A3,%IODR(A3)	; CHANNEL DEFINED?
	IOERR	2,0		; NO - COMPLAIN
	TLNN	A3,SPOPRN	; YES - SPECIAL OPERATIONS PERMITTED
	IOERR	13,0		; NO - COMPLAIN
	JUMPN	A2,SO4		; BACKSPACE?
	TLNN	A3,ININT	; YES - OK ON INPUT?
	IOERR	13,0		; NO - COMPLAIN
	MOVEI	A4,17		; SET UP FOR MTAPE

SO2:	HRLI	A4,<MTAPE>B53

SO3:	DPB	A1,[
	POINT	4,A4,12]	; PREPARE RELEVANT MTAPE
	XCT	A4		; AND EXECUTE IT
	TRZE	A4,-1		; WAS THAT CLOSE?
	XCT	A4		; NO - WAIT
	POPJ	SP,0

SO4:	SOJN	A2,SO5		; ENDFILE?
	MOVEI	A4,16
	TLNE	A3,ININT	; INPUT?
	JRST	SO2		; YES
	HRLZI	A4,<CLOSE>B53	; NO
	JRST	SO3

SO5:	MOVEI	A4,1		; REWIND
	JRST	SO2
SUBTTL UUO HANDLER

UUO:	DMOVEM	A0,%SYS16(DB)	; SAVE A0,A1 IN TEMPORARY DUMP
	LDB	A1,[
	POINT	9,.JBUUO,8]	; AND GET FUNCTION CODE
	CAIL	A1,UUONUM	; IN ALGOL UUO RANGE?
	JRST	ERRUUO		; NO

UUOTAB:	JRST	@UUOTAB(A1)	; YES - USE TABLE
	IFN DUMP, <
	XWD	0,DUMP0>
	IFE DUMP, <
	XWD	0,ERRUUO>	; DUMP
	XWD	0,UUO2		; SYSER1
	XWD	0,UUO3		; SYSER2
	XWD	0,UUO4		; IOERR
	XWD	0,UUO5		; LIBERR
	XWD	0,CORE0		; CCORE

	UUONUM=.-UUOTAB

UUO2:
UUO3:
UUO4:
UUO5:	MOVE	A1,MUUO(A1)	; LOOK UP MASTER UUO TABLE
	LDB	A0,[
	POINT	4,.JBUUO,12]	; GET ACCUMULATOR NUMBER
	CAILE	A0,(A1)		; WITHIN RANGE?
	JRST	ERRUUO		; NO
	HLRZ	A1,A1		; GET INDIVIDUAL UUO TABLE
	ADD	A1,A0		; OFFSET BY ACCUMULATOR NUMBER
	SKIPA	A1,(A1)		; GET FLAGS AND MESSAGE ADDRESS

ERRUUO:	MOVE	A1,M2+0		; ILLEGAL UUO'S
ERRMON:	EXCH	A1,%SYS17(DB)	; SAVE FLAGS AND ERROR
	MOVE	A0,%SYS16(DB)	; RESTORE A0,A1
	MOVEM	A0,%ACCS+A0(DB)
	HRLZI	A0,A1
	HRRI	A0,%ACCS+A1(DB)
	BLT	A0,%ACCS+SP(DB)	; SAVE ACCUMULATORS
	MOVE	SP,%ESP(DB)	; SET UP EMERGENCY STACK
	MOVE	A1,%SYS17(DB)	; RESTORE FLAGS AND ERROR
	HLRZ	A2,A1
	ANDI	A2,TRAPNO	; GET TRAP NUMBER
	ADDI	A2,(DB)
	SKIPE	A2,%TRAPS(A2)	; TRAP SET UP?
	JFCL	.+1		; IGNORE FOR NOW
	PUSHJ	SP,CRLF
	SKIPL	A1,%SYS17(DB)	; FATAL ERROR?
	JRST	ERRM1		; NO
	MOVEI	A1,M000		; YES
	PUSHJ	SP,MONIT	; "FATAL "

ERRM1:	MOVEI	A1,M001
	PUSHJ	SP,MONIT	; "RUN-TIME ERROR AT ADDRESS "
	HRRZ	A1,.JBUUO	; GET ADDRESS IN UUO
	SOJG	A1,ERRM3	; ADDRESS SUPPLIED?
	HRRZ	A1,PRGLNK(DL)	; NO - GET LAST LINK
	SUBI	A1,2

ERRM2:	HLRZ	A0,(A1)		; MOVE BACK TO CALL
	ANDI	A0,777740
	CAIE	A0,<PUSHJ	SP,0>B53
	SOJG	A1,ERRM2

ERRM3:	PUSHJ	SP,SPROCT	; PRINT ADDRESS OF ERROR
	PUSHJ	SP,DCRLF
	HRRZ	A1,%SYS17(DB)
	PUSHJ	SP,MONIT	; PRINT ERROR MESSAGE
	PUSHJ	SP,DCRLF
	MOVEI	A1,[ASCIZ /?/]
	PUSHJ	SP,MONIT	; INSERT "?" BEFORE MESSAGE
	JRST	FM7A

CORE0:	HRRZ	A0,.JBUUO	; GET CORE SIZE REQUIRED
	CALLI	A0,CORE		; AND TRY TO GET IT
	JRST	CORE1		; FAILED
	DMOVE	A0,%SYS16(DB)	; OK - RESTORE A0,A1
	JRST	@%UUO(DB)

CORE1:	MOVE	A1,M2+2
	JRST	ERRMON		; GENERATE ERROR
; ERROR UUO FLAGS (LH OF M TABLES):

	FATAL=400000		; MUST BE BIT 0

	TRAPNO=000077
SUBTTL ERROR UUO MESSAGES

	MUUO=.-2
	XWD	M2,17
	XWD	M3,7
	XWD	M4,14
	XWD	M5,4

M2:	XWD	FATAL+0,M200	; SYSER1
	XWD	FATAL+1,M201
	XWD	FATAL+2,M202
	XWD	FATAL+3,M203
	XWD	FATAL+4,M204
	XWD	FATAL+5,M205
	XWD	FATAL+6,M206
	XWD	FATAL+7,M207
	XWD	FATAL+10,M210
	XWD	FATAL+11,M211
	XWD	FATAL+12,M212
	XWD	FATAL+13,M213
	XWD	FATAL+14,M214
	XWD	FATAL+15,M215
	XWD	FATAL+16,M216
	XWD	FATAL+17,M217

M3:	XWD	FATAL+20,M300	; SYSER2
	XWD	FATAL+21,M301
	XWD	22,M302
	XWD	23,M303
	XWD	FATAL+24,M304
	XWD	FATAL+25,M305
	XWD	FATAL+26,M306

M4:	XWD	40,M400		; IOERR
	XWD	41,M401
	XWD	42,M402
	XWD	43,M403
	XWD	44,M404
	XWD	45,M405
	XWD	46,M406
	XWD	47,M407
	XWD	50,M410
	XWD	52,M411
	XWD	53,M412
	XWD	53,M413
	XWD	54,M414

M5:	XWD	60,M500		; LIBERR
	XWD	61,M501
	XWD	62,M502
	XWD	63,M503
	XWD	64,M504
M000:	ASCIZ /FATAL /
M001:	ASCIZ /RUN-TIME ERROR AT ADDRESS /

M100:	ASCIZ /%DUMP COMPLETED/
M200:	ASCIZ /ILLEGAL UUO/
M201:	ASCIZ /MORE CORE REQUIRED TO START PROGRAM/
M202:	ASCIZ /MORE CORE REQUIRED FOR VARIABLE STORAGE/
M203:	ASCIZ /LOWER BOUND > UPPER BOUND IN ARRAY DECLARATION/
M204:	ASCIZ /ARRAY TOO LARGE FOR A PDP-10/
M205:	ASCIZ /WRONG NUMBER OF ARRAY SUBSCRIPTS/
M206:	ASCIZ /ARRAY SUBSCRIPT OUT OF RANGE/
M207:	ASCIZ /INVALID ACTUAL PARAMETER IN PROCEDURE CALL/
M210:	ASCIZ /WRONG NUMBER OF ACTUAL PARAMETERS IN PROCEDURE CALL/
M211:	ASCIZ /EXPRESSION-TYPE ACTUAL PARAMETER USED ON LHS OF ASSIGNMENT/
M212:	ASCIZ /MORE HEAP SPACE REQUIRED FOR I-O BUFFERS/
M213:	ASCIZ /MORE HEAP SPACE REQUIRED FOR OWN ARRAY OR BYTE STRING/
M214:	ASCIZ /BYTESIZE CONFLICTION IN STRING COMPARE/
M215:	ASCIZ /ILLEGAL BYTE SIZE/
M216:	ASCIZ /BYTE SUBSCRIPT OUT OF RANGE/
M217:	ASCIZ /ATTEMPT TO DEPOSIT BYTE IN WRITE-PROTECTED STRING/
M300:	ASCIZ /SOURCE LEVEL ERROR/
M301:	ASCIZ /JUMP TO NON-EXISTENT LABEL/
M302:	ASCIZ /FLOATING POINT OVERFLOW/
M303:	ASCIZ /FIXED POINT OVERFLOW/
M304:	ASCIZ /ILLEGAL INSTRUCTION/
M305:	ASCIZ /ILLEGAL MEMORY REFERENCE/
M306:	ASCIZ /UNTRAPPED CLOCK INTERRUPT/
M307:	ASCIZ /TRAP LABEL OUT OF SCOPE/
M400:	ASCIZ /INPUT OR OUTPUT DEVICE UNAVAILABLE/
M401:	ASCIZ /ILLEGAL MODE FOR INPUT OR OUTPUT DEVICE/
M402:	ASCIZ /INPUT OR OUTPUT ON UNDEFINED CHANNEL/
M403:	ASCIZ /ATTEMPT TO READ OR WRITE ON FILE DEVICE WITHOUT FILE OPEN/
M404:	ASCIZ /ATTEMPT TO OPEN OR CLOSE FILE ON NON-DIRECTORY DEVICE/
M405:	ASCIZ /FILE NOT AVAILABLE OR RENAME FAILURE/
M406:	ASCIZ /ATTEMPT TO READ OR WRITE OVER END-OF-FILE/
M407:	ASCIZ /ERROR CONDITION ON INPUT OR OUTPUT/
M410:	ASCIZ /ILLEGAL CHARACTER IN NUMERIC DATA/
M411:	ASCIZ /OVERFLOW IN NUMERIC DATA/
M412:	ASCIZ /ERROR CONDITION ON CLOSING FILE/
M413:	ASCIZ /ILLEGAL INPUT-OUTPUT OPERATION/
M414:	ASCIZ /I-O CHANNEL NUMBER OUT OF RANGE/
M500:	ASCIZ /SQRT ARGUMENT NEGATIVE/
M501:	ASCIZ /LN ARGUMENT ZERO OR NEGATIVE/
M502:	ASCIZ /EXP ARGUMENT TOO LARGE/
M503:	ASCIZ /INVERSE MATHS FUNCTION ARGUMENT OUT OF RANGE/
M504:	ASCIZ /TAN ARGUMENT TOO LARGE/
SUBTTL APR ERROR HANDLER

APRERR:	MOVEM	A1,%SYS17(DB)	; SAVE A1
	MOVE	A1,.JBTPC	; AND GET PC DUMP
	TLZN	A1,PCFPU	; FLOATING POINT UNDERFLOW?
	JRST	APR6		; NO
	TLZ	A1,PCOVL	; YES - CLEAR OVERFLOW FLAGS
	MOVEM	A1,.JBTPC
	DMOVEM	A2,%SYS15(DB)	; SAVE A2 AND A3
	MOVE	A2,-1(A1)	; GET MALICIOUS ORDER

APR1:	HLRZ	A3,A2
	LSH	A3,-11		; AND EXTRACT ORDER NO.
	CAIE	A3,<XCT>B62	; XCT?
	JRST	APR2		; NO
	MOVE	A1,%SYS17(DB)	; YES
	MOVE	A3,%SYS16(DB)	; RESTORE A1 AND A3
	MOVEM	A2,%SYS14(DB)	; SAVE ORDER
	MOVE	A2,%SYS15(DB)	; RESTORE A2
	MOVE	A2,@%SYS14(DB)	; AND EXTRACT ORDER XCT'D
	JRST	APR1

APR2:	HLRZ	A1,@.JBTPC
	LSH	A1,-5		; PICK UP NEXT ORDER
	CAIE	A1,<JFOVO>B58	; JFOVO?
	JRST	APR3		; NO
	AOS	.JBTPC		; YES - SKIP IT
	HLRZ	A1,A2
	LSH	A1,-5
	ANDI	A1,000017	; GET ACCUMULATOR NUMBER
	DMOVE	A2,%SYS15(DB)	; RESTORE A2 AND A3
	CAIN	A1,A1		; A1 INVOLVED?
	MOVEI	A1,%SYS17(DB)	; YES - REPLACE BY ITS DUMP
	MOVEM	A1,%SYS14(DB)	; AND SAVE ADDRESS OF ACCUMULATOR
	MOVE	A1,(A1)		; GET ITS VALUE
	HLRE	A2,A1		; GET EXPONENT, EXTENDING SIGN
	ASH	A2,-11
	TSCE	A2,A2		; IF NEGATIVE, COMPLEMENT EXPONENT
	TLOA	A1,777000	; NEGATIVE - SET EXPONENT ALL ONES
	TLZ	A1,777000	; POSITIVE - SET EXPONENT ALL ZEROS
	CAMGE	A2,[
	XWD	000346,000346]	; WILL ALL OF MANTISSA DISAPPEAR?
	TDZA	A1,A1		; YES - SAVE VERY LONG AND SLOW SHIFT!
	ASH	A1,400000(A2)	; DENORMALIZE FRACTION TO SUIT OLD EXPONENT!!!!!
	MOVE	A2,%SYS15(DB)	; RESTORE A2 AGAIN
	MOVEM	A1,@%SYS14(DB)	; AND RESET RELEVANT ACCUMULATOR
	MOVE	A1,%SYS17(DB)	; RESTORE A1
	JRSTF	@.JBTPC		; AND RETURN
APR3:	HLRZ	A1,A2
	LSH	A1,-5
	ANDI	A1,000017	; GET ACCUMULATOR NUMBER
	IFE PROC-KI10, <
	CAIG	A3,<DFDV>B62	; DFAD, DFSB, DFMP OR DFDV?
	MOVEI	A3,1		; YES - TREAT AS FADL ETC.>
	CAIN	A3,<FSC>B62	; FSC?
	TDZA	A3,A3		; YES - RECODE
	ANDI	A3,000007	; SELECT BOTTOM 3 BITS
	HLL	A1,APR5(A3)	; CONSTRUCT 1ST ORDER
	HRRE	A3,APR5(A3)
	JUMPGE	A3,APR4
	MOVE	A2,A1		; LONG ORDER
	ADDI	A2,1		; FORM ACC+1
	TRZA	A2,000020	; WITH WRAP-AROUND

APR4:	DPB	A3,[
	POINT	9,A2,8]		; CONSTRUCT 2ND ORDER
	EXCH	A1,%SYS17(DB)	; PLANT ORDERS 
	EXCH	A2,%SYS15(DB)	; RELOAD A1,A2
	MOVE	A3,%SYS16(DB)	; AND A3
	XCT	%SYS17(DB)
	XCT	%SYS15(DB)	; EXECUTE ORDERS
	JRSTF	@.JBTPC		; AND RETURN

APR5:	XWD	<SETZM>B53,<CAI>B62
	XWD	<SETZM>B53,400000
	XWD	<CAI>B53,<SETZM>B62
	XWD	<SETZM>B53,<SETZM>B62
	XWD	<SETZM>B53,<CAI>B62
	XWD	<SETZM>B53,<CAI>B62
	XWD	<CAI>B53,<SETZM>B62
	XWD	<SETZM>B53,<SETZM>B62

APR6:	TLNN	A1,PCFPO	; FLOATING POINT OVERFLOW?
	JRST	APR8		; NO
	MOVE	A1,(A1)		; PICK UP NEXT ORDER
	MOVEM	A1,%SYS16(DB)	; AND SAVE IT
	LSH	A1,-27
	ANDI	A1,017767
	CAIE	A1,<JFOV>B58	; IS IT JFOV OR JFOVO?
	JRST	APR7		; NO
	MOVE	A1,%SYS17(DB)	; YES - RESTORE A1
	JRST	@%SYS16(DB)	; AND OBEY JFOV

APR7:	MOVE	A1,%SYS17(DB)
	SYSER2	2,@.JBTPC	; YES
APR8:	TLNN	A1,PCO		; FIXED POINT OVERFLOW?
	JRST	APR10		; NO
	MOVE	A1,(A1)		; PICK UP NEXT ORDER
	MOVEM	A1,%SYS16(DB)	; AND SAVE IT
	LSH	A1,-27
	CAIE	A1,<JOV>B58	; IS IT JOV?
	JRST	APR9		; NO
	MOVE	A1,%SYS17(DB)	; YES - RESTORE A1
	JRST	@%SYS16(DB)	; AND OBEY JOV

APR9:	MOVE	A1,%SYS17(DB)
	SYSER2	3,@.JBTPC	; YES

APR10:	MOVE	A1,.JBCNI	; GET APR FLAGS
	TRNN	A1,APRNXM!APRMPV
				; MEMORY PROTECT VIOLATION?
	JRST	APR12		; NO
	SOS	A1,.JBTPC	; YES - LOAD DECREMENTED PC
	ANDI	A1,-1
	CAIN	A1,-1		; NON-EXISTENT LABEL?
	SYSER2	1,0		; YES
	CAMLE	A1,.JBREL	; NO - ADDRESS OK?
	JRST	APR11		; NO - LEAVE IT ALONE
	HLRZ	A1,(A1)		; YES - GET BAD ORDER
	ANDI	A1,777017	; AND SELECT OPCODE AND INDEX
	CAIE	A1,<MOVEM	0,(SP)>B53
				; STORE AHEAD ON STACK?
	JRST	APR11		; NO
	MOVE	A1,.JBREL	; YES
	JRST	APR15

APR11:	MOVE	A1,%SYS17(DB)	; NO
	SYSER2	5,@.JBTPC

APR12:	TRNE	A1,APRPLO	; PDL OVERFLOW?
	JRST	APR13		; YES
	MOVE	A1,%SYS17(DB)
	SYSER2	6,@.JBTPC	; NO - MUST BE CLOCK FLAG

APR13:	MOVE	A1,.JBREL	; PDL OVERFLOW OR BAD MOVEM ON STACK
	CAILE	A1,(SP)		; OUT OF CORE?
	JRST	APR14		; NO
APR15:	ADDI	A1,2000
	EXCH	A1,%SYS17(DB)	; RESTORE SAVED A1
	CCORE	@%SYS17(DB)	; TRY TO EXPAND

APR14:	MOVEI	A1,(SP)
	SUB	A1,.JBREL
	HRLI	SP,(A1)		; RESET LH NEGATIVE COUNT
	MOVE	A1,%SYS17(DB)	; RESTORE A1
	JRSTF	@.JBTPC		; AND RE-ENTER PROGRAM
SUBTTL DUMP ROUTINE

; CALLED BY DUMPR 0,N
; GIVES PRINT OF LOW CORE FROM WORD N
; ON DISK FILE JBTPRG (NAME OF PROGRAM).DNN USING CHANNEL 17
; WHERE NN IS THE DUMP NUMBER

	IFN DUMP, <

	ZERFLG=400000		; ZERO FLAG

	DSKOAL=2*DSKBL+FILPP+2	; DISK FAKE OWN AREA LENGTH
	DSKOAA=2000-DSKOAL	; DISK FAKE OWN AREA ADDRESS OFFSET
DUMP0:	MOVE	A0,%SYS16(DB)	; RESTORE A0 FROM TEMPORARY DUMP
	MOVEM	A0,%ACCS+A0(DB)
	MOVE	A1,%SYS17(DB)	; RESTORE A1 FROM TEMPORARY DUMP
	HRLZI	A0,A1
	HRRI	A0,%ACCS+A1(DB)
	BLT	A0,%ACCS+SP(DB)	; AND SAVE ACCUMULATORS IN %ACCS
	MOVE	SP,.JBREL	; SET UP NEW STACK
	MOVEI	A0,2000(SP)
	CALLI	A0,CORE		; TRY TO GET ANOTHER K OF STORE
	JRST	DUMP17		; FAILED
	HRRZ	A1,%CHAN(DB)	; GET CURRENT OUTPUT CHANNEL NUMBER
	CAIN	A1,17		; CHANNEL 17?
	PUSHJ	SP,RELESE	; YES - RELEASE IT
	JFCL	.+1
	PUSH	SP,%CHAN(DB)	; SAVE IO CHANNEL WORD
	MOVEI	A0,DSKOAL
	MOVEI	A1,DSKOAA(SP)	; SET UP FAKE ENTRY
	HRLZM	A0,(A1)		; FOR DYNAMIC OWN HEAP CHAIN
	EXCH	A1,%SYS2(DB)	; AND EXCHANGE FOR PRESENT ONE
	PUSH	SP,A1		; SAVE OLD ONE ON STACK
	MOVSI	A0,'DSK'
	MOVEI	A1,17
	MOVEI	A2,0
	PUSHJ	SP,OUTPT	; OPEN DISK ON CHANNEL 17
	MOVEI	A1,17
	HRROI	A2,JBTPRG
	CALLI	A2,GETTAB	; GET PROGRAM NAME
	SKIPA	A2,[
	SIXBIT /ALGOBJ/]
	JUMPE	A2,.-1
	AOS	A3,%SYS6(DB)	; INCREMENT DUMP NUMBER
	CAIL	A3,^D100	; TOO LARGE?
	MOVEI	A3,0		; YES - REPLACE BY ZERO
	IDIVI	A3,^D10
	LSH	A3,6
	ADDI	A3,'D00'(A4)
	MOVSI	A3,(A3)		; MAKE EXTENSION
	SETZB	A4,A5
	PUSHJ	SP,OPFILE	; AND OPEN FILE
	PUSHJ	SP,SELOUT	; SELECT OUTPUT CHANNEL 17
	HRRZ	A4,.JBUUO	; GET STARTING ADDRESS
	MOVEI	A5,-1(SP)	; AND SET UP TERMINATING ADDRESS AND FLAG
	JRST	DUMP3
DUMP1:	ANDI	A5,-1		; CLEAR ZERO FLAG
DUMP2:	MOVEI	A13,CR
	JSP	AX,OUCHAR
	MOVEI	A13,LF
	JSP	AX,OUCHAR	; CR-LF

DUMP3:	CAIL	A4,(A5)		; FINISHED?
	JRST	DUMP16		; YES
	MOVE	A6,(A4)		; NO - PICK UP NEXT WORD
	JUMPN	A6,DUMP4	; ZERO?
	TLON	A5,ZERFLG	; YES - ZERO FLAG SET?
	AOJA	A4,DUMP2	; NO - GO VIA CR-LF
	AOJA	A4,DUMP3	; YES - NO CR-LF

DUMP4:	HRRZ	A1,A4
	PUSHJ	SP,PROCT	; PRINT ADDRESS IN OCTAL
	PUSHJ	SP,DUMP9	; DOUBLE TAB
	HLRZ	A1,A6
	PUSHJ	SP,PROCT	; PRINT LH IN OCTAL
	PUSHJ	SP,DUMP10	; TAB
	HRRZ	A1,A6
	PUSHJ	SP,PROCT	; PRINT RH IN OCTAL
	PUSHJ	SP,DUMP9	; DOUBLE TAB
	MOVE	A1,A6
	PUSHJ	SP,DUMP11	; PRINT IN SIXBIT
	PUSHJ	SP,DUMP10	; TAB
	MOVE	A2,[
	POINT	7,A6,]		; SET UP BYTE POINTER
	MOVEI	A3,5		; AND BYTE COUNT

DUMP5:	ILDB	A13,A2		; GET ASCII BYTE
	CAIL	A13,40
	CAIL	A13,140
	MOVEI	A13," "		; REPLACE UNPRINTABLES BY SPACES
	JSP	AX,OUCHAR	; AND PRINT
	SOJN	A3,DUMP5	; ANY MORE?
	PUSHJ	SP,DUMP10	; NO - TAB
	LDB	A1,[
	POINT	9,A6,8]		; EXTRACT FUNCTION CODE
	CAIL	A1,700		; 700 GROUP?
	JRST	DUMP6		; YES
	MOVE	A1,DUMP18(A1)	; NO - GET SIXBIT VERSION
	PUSHJ	SP,DUMP11	; AND PRINT IT
	PUSHJ	SP,DUMP10	; TAB
	LDB	A1,[
	POINT	4,A6,12]	; GET ACCUMULATOR FIELD
	PUSHJ	SP,DUMP14	; AND PRINT IT
	JRST	DUMP7
DUMP6:	LDB	A1,[
	POINT	3,A6,12]	; GET IO FUNCTION CODE
	MOVE	A1,DUMP19(A1)	; AND GET SIXBIT VERSION
	PUSHJ	SP,DUMP11	; AND PRINT IT
	JSP	AX,PRIN2	; SPACE
	LDB	A1,[
	POINT	7,A6,9]		; GET IO DEVICE CODE
	PUSHJ	SP,DUMP13	; AND PRINT IT

DUMP7:	MOVEI	A13,","
	JSP	AX,OUCHAR	; COMMA
	MOVEI	A13," "		; PREPARE A SPACE
	TLNE	A6,000020	; INDIRECT BIT SET?
	MOVEI	A13,"@"		; YES - CHANGE IT TO A "@"
	JSP	AX,OUCHAR	; PRINT RELEVANT CHARACTER
	HRRZ	A1,A6
	PUSHJ	SP,PROCT	; PRINT ADDRESS
	LDB	A1,[
	POINT	4,A6,17]	; GET INDEX FIELD
	JUMPE	A1,DUMP8	; IGNORE IF ZERO
	MOVEI	A13,"("		; OTHERWISE
	JSP	AX,OUCHAR	; PRINT "("
	PUSHJ	SP,DUMP14	; PRINT INDEX FIELD
	MOVEI	A13,")"
	JSP	AX,OUCHAR	; PRINT ")"

DUMP8:	PUSHJ	SP,DUMP9	; DOUBLE TAB
	PUSH	SP,A5
	PUSH	SP,A4		; SAVE A4 AND A5
	MOVE	A0,A6
	MOVEI	A2,0
	SETZB	A3,A4
	PUSHJ	SP,PRINT	; PRINT IN INTEGER FORMAT
	PUSHJ	SP,DUMP10	; TAB
	MOVE	A0,@(SP)	; RESTORE DATA
	MOVEI	A2,1
	SETZB	A3,A4
	PUSHJ	SP,PRINT	; PRINT IN REAL FORMAT
	POP	SP,A4
	POP	SP,A5		; RESTORE A4,A5
	AOJA	A4,DUMP1	; PREPARE FOR NEXT WORD
DUMP9:	MOVEI	A13,"	"	; DOUBLE TAB ROUTINE
	JSP	AX,OUCHAR

DUMP10:	MOVEI	A13,"	"	; SINGLE TAB ROUTINE
	JSP	AX,OUCHAR
	POPJ	SP,0

DUMP11:	MOVE	A2,[
	POINT	6,A1,]		; PRINT SIXBIT ROUTINE - SET UP BYTE POINTER
	MOVEI	A3,6		; AND BYTE COUNT

DUMP12:	ILDB	A13,A2		; GET NEXT BYTE
	ADDI	A13,40		; ADD SIXBIT OFFSET
	JSP	AX,OUCHAR	; AND PRINT IT
	SOJN	A3,DUMP12	; ANY MORE?
	POPJ	SP,0		; NO

DUMP13:	MOVE	A2,[
	POINT	3,A1,26]	; PRINT IO DEVICE CODE ROUTINE
	MOVEI	A3,3		; SET UP BYTE POINTER AND COUNT
	JRST	DUMP15

DUMP14:	MOVE	A2,[
	POINT	3,A1,29]	; PRINT ACCUMULATOR ROUTINE
	MOVEI	A3,2		; SET UP BYTE POINTER AND COUNT

DUMP15:	ILDB	A13,A2		; GET NEXT OIT
	ADDI	A13,"0"		; ADD ASCII OFFSET
	JSP	AX,OUCHAR	; AND PRINT IT
	SOJN	A3,DUMP15	; ANY MORE?
	POPJ	SP,0		; NO

DUMP16:	MOVEI	A1,17		; FINISHED
	PUSHJ	SP,RELESE	; RELEASE CHANNEL 17
	JFCL	.+1
	POP	SP,%SYS2(DB)	; RESTORE OLD DYNAMIC HEAP CHAIN
	POP	SP,%CHAN(DB)	; AND RESTORE IO CHANNEL NUMBERS
	PUSHJ	SP,CRLF
	MOVEI	A1,M100
	PUSHJ	SP,MONIT0	; PRINT OUT MESSAGE
	PUSHJ	SP,DCRLF
	CALLI	SP,CORE		; AND REDUCE CORE TO ORIGINAL SIZE
	HALT	.		; CANNOT FAIL!
	HRLZI	A0,%ACCS+A1(DB)
	HRRI	A0,A1
	BLT	A0,SP
	MOVE	A0,%ACCS+A0(DB)	; RELOAD ACCUMULATORS FROM %ACCS
	JRST	@%UUO(DB)	; RETURN TO PROGRAM
DUMP17:	MOVE	SP,%ESP(DB)	; SET UP TEMPORARY STACK
	MOVEI	A1,M201
	PUSHJ	SP,MONIT0	; NOT ENOUGH CORE
	CALLI	1,EXIT
	POPJ	SP,0
; TABLE OF ORDER CODE MNEMONICS IN SIXBIT FORM

DUMP18:	SIXBIT /      DUMPR SYSER1SYSER2IOERR LIBERR            
                              RESET.IN.   OUT.  
DATA. FIN.  RTB.  WTB.  MTOP. SLIST.INF.  OUTF. 
RERED.NLI.  NLO.  DEC.  ENC.                    /
	SIXBIT /CALL  INIT                                CALLI 
OPEN  TTCALL                  RENAMEIN    OUT   
SETSTSSTATO GETSTSSTATZ INBUF OUTBUFINPUT OUTPUT
CLOSE RELEASMTAPE UGETF USETI USETO LOOKUPENTER /
	SIXBIT /UJEN                                            
DFAD  DFSB  DFMP  DFDV                          
DMOVE DMOVN FIX         DMOVEMDMOVNMFIXR  FLTR  
UFA   DFN   FSC   IBP   ILDB  LDB   IDPB  DPB   /
	SIXBIT /FAD   FADL  FADM  FADB  FADR  FADRI FADRM FADRB 
FSB   FSBL  FSBM  FSBB  FSBR  FSBRI FSBRM FSBRB 
FMP   FMPL  FMPM  FMPB  FMPR  FMRRI FMPRM FMPRB 
FDV   FDVL  FDVM  FDVB  FDVR  FDVRI FDVRM FDVRB /
	SIXBIT /MOVE  MOVEI MOVEM MOVES MOVS  MOVSI MOVSM MOVSS 
MOVN  MOVNI MOVNM MOVNS MOVM  MOVMI MOVMM MOVMS 
IMUL  IMULI IMULM IMULB MUL   MULI  MULM  MULB  
IDIV  IDIVI IDIVM IDIVB DIV   DIVI  DIVM  DIVB  /
	SIXBIT /ASH   ROT   LSH   JFFO  ASHC  ROTC  LSHC        
EXCH  BLT   AOBJP AOBJN JRST  JFCL  XCT         
PUSHJ PUSH  POP   POPJ  JSR   JSP   JSA   JRA   
ADD   ADDI  ADDM  ADDB  SUB   SUBI  SUBM  SUBB  /
	SIXBIT /CAI   CAIL  CAIE  CAILE CAIA  CAIGE CAIN  CAIG  
CAM   CAML  CAME  CAMLE CAMA  CAMGE CAMN  CAMG  
JUMP  JUMPL JUMPE JUMPLEJUMPA JUMPGEJUMPN JUMPG 
SKIP  SKIPL SKIPE SKIPLESKIPA SKIPGESKIPN SKIPG /
	SIXBIT /AOJ   AOJL  AOJE  AOJLE AOJA  AOJGE AOJN  AOJG  
AOS   AOSL  AOSE  AOSLE AOSA  AOSGE AOSN  AOSG  
SOJ   SOJL  SOJE  SOJLE SOJA  SOJGE SOJN  SOJG  
SOS   SOSL  SOSE  SOSLE SOSA  SOSGE SOSN  SOSG  /
	SIXBIT /SETZ  SETZI SETZM SETZB AND   ANDI  ANDM  ANDB  
ANDCA ANDCAIANDCAMANDCABSETM  SETMI SETMM SETMB 
ANDCM ANDCMIANDCMMANDCMBSETA  SETAI SETAM SETAB 
XOR   XORI  XORM  XORB  IOR   IORI  IORM  IORB  /
	SIXBIT /ANDCB ANDCBIANDCBMANDCBBEQV   EQVI  EQVM  EQVB  
SETCA SETCAISETCAMSETCABORCA  ORCAI ORCAM ORCAB 
SETCM SETCMISETCMMSETCMBORCM  ORCMI ORCMM ORCMB 
ORCB  ORCBI ORCBM ORCBB SETO  SETOI SETOM SETOB /
	SIXBIT /HLL   HLLI  HLLM  HLLS  HRL   HRLI  HRLM  HRLS  
HLLZ  HLLZI HLLZM HLLZS HRLZ  HRLZI HRLZM HRLZS 
HLLO  HLLOI HLLOM HLLOS HRLO  HRLOI HRLOM HRLOS 
HLLE  HLLEI HLLEM HLLES HRLE  HRLEI HRLEM HRLEB /
	SIXBIT /HRR   HRRI  HRRM  HRRS  HLR   HLRI  HLRM  HLRS  
HRRZ  HRRZI HRRZM HRRZS HLRZ  HLRZI HLRZM HLRZS 
HRRO  HRROI HRROM HRROS HLRE  HLREI HLREM HLRES 
HRRE  HRREI HRREM HRRES HLRE  HLREI HLREM HLRES /
	SIXBIT /TRN   TLN   TRNE  TLNE  TRNA  TLNA  TRNN  TLNN  
TDN   TSN   TDNE  TSNE  TDNA  TSNA  TDNN  TSNN  
TRZ   TLZ   TRZE  TLZE  TRZA  TLZA  TRZN  TLZN  
TDZ   TSZ   TDZE  TSZE  TDZA  TSZA  TDZN  TSZN  /
	SIXBIT /TRC   TLC   TRCE  TLCE  TRCA  TLCA  TRCN  TLCN  
TDC   TSC   TDCE  TSCE  TDCA  TSCA  TDCN  TSCN  
TRO   TLO   TROE  TLOE  TROA  TLOA  TRON  TLON  
TDO   TSO   TDOE  TSOE  TDOA  TSOA  TDON  TSON  /
DUMP19:	SIXBIT /BLKI  DATAI BLKO  DATAO CONO  CONI  CONSZ CONSO />
SUBTTL TYPE CONVERSION ROUTINES

; IR	INTEGER TO REAL
; ILR	INTEGER TO LONG REAL
; RI	REAL TO INTEGER
; LRI	LONG REAL TO INTEGER
; LRR	LONG REAL TO REAL

; ON ENTRY, THE ARGUMENT IS IN A0 OR A0,A1
; ON EXIT, THE RESULT IS IN A0 OR A0,A1

	IFE PROC-KA10, <
IR:	IDIVI	A0,400		; SEPARATE HIGH AND LOW HALVES
	JUMPE	A0,.+2		; ONLY 18 BITS?
	TLC	A0,243000	; NO - SET UP HIGH HALF EXPONENT
	TLC	A1,233000	; SET UP LOW HALF EXPONENT
	FADR	A0,A1		; AND ADD BITS TOGETHER
	JRST	(AX)>

ILR:	IDIVI	A0,400		; SEPARATE HIGH AND LOW HALVES
	JUMPE	A0,.+2		; ONLY 18 BITS?
	TLC	A0,243000	; NO - SET UP HIGH HALF EXPONENT
	TLC	A1,233000	; SET UP LOW HALF EXPONENT
	FADL	A0,A1		; AND ADD BITS TOGETHER
	IFE PROC-KI10, <
	TLZ	A1,777000	; IF KI10, WIPE OUT LOW WORD EXPONENT
	LSH	A1,10		; AND SHIFT UP MANTISSA>
	JRST	(AX)

	IFE PROC-KA10, <
RI:	FADRI	A0,200400	; RI - ADD 0.5
	MULI	A0,400		; SEPARATE EXPONENT AND MANTISSA
	EXCH	A0,A1
	TSC	A1,A1		; FIX UP EXPONENT
	ASH	A0,-243(A1)	; AND SHIFT MANTISSA TO FORM INTEGER>

	IFE PROC-KI10, <
RI:	FADRI	A0,200400	; ADD 0.5
	FIXR	A0,A0>
	JRST	(AX)
	IFE PROC-KA10, <
LRI:	MOVE	A2,A1		; LRI - ADD 0.5
	FADL	A0,[0.5]
	UFA	A1,A2
	FADL	A0,A2>

	IFE PROC-KI10, <
LRI:	DFAD	A0,[
	EXP	0.5,0.0]	; LRI - ADD 0.5>
	HLRZ	A2,A0
	LSH	A2,-11
	ANDI	A2,000377	; EXTRACT HIGH ORDER EXPONENT
	TLZ	A0,377000	; AND CLEAR IT OUT
	JUMPGE	A0,.+3		; NUMBER POSITIVE?
	TRC	A2,000377	; NO - COMPLEMENT EXTRACTED EXPONENT
	TLO	A0,377000	; AND SET ALL ONES
	IFE PROC-KA10, <
	LSH	A1,10		; IF KA10, SHIFT UP LOW ORDER MANTISSA>
	ASHC	A0,-233(A2)	; SHIFT MANTISSA TO INTEGER
	JRST	(AX)

	IFE PROC-KI10, <
LRR:	JUMPGE	A0,.+3		; ARGUMENT POSITIVE?
	DMOVN	A0,A0		; NO - NEGATE IT
	TLZA	A1,400000	; AND CLEAR BIT 0 FLAG
	TLO	A1,400000	; YES - SET BIT ZERO FLAG
	TLNN	A1,200000	; ROUNDING REQUIRED?
	JRST	LR1		; NO
	CAMN	A0,[
	XWD	377777,777777]	; YES - HIGH WORD TOO LARGE?
	SYSER2	2,0		; YES - REPORT OVERFLOW
	ADDI	A0,1		; NO
	TLO	A0,400		; CARRY

LR1:	JUMPL	A1,(AX)		; EXIT IF POSITIVE
	MOVN	A0,A0		; OTHERWISE NEGATE
	JRST	(AX)>
SUBTTL SPECIAL TYPE CONVERSION ROUTINES

; SIR	INTEGER TO REAL
; SILR	INTEGER TO LONG REAL
; SRI	REAL TO INTEGER
; SLRI	LONG REAL TO INTEGER
; SLRR	LONG REAL TO REAL

; ON ENTRY, THE ARGUMENT IS IN A0 OR A0,A1
; ON EXIT, THE RESULT IS IN A3 OR A3,A4

	IFE PROC-KA10, <
SIR:	MOVE	A3,A0		; COPY ARGUMENT TO A3
	IDIVI	A3,400000	; SEPARATE HIGH AND LOW HALVES
	JUMPE	A3,.+2		; ONLY 18 BITS?
	TLC	A3,254000	; NO - SET UP HIGH HALF EXPONENT
	TLC	A4,233000	; SET UP LOW HALF EXPONENT
	FADR	A3,A4		; AND ADD BITS TOGETHER
	JRST	(AX)>

SILR:	MOVE	A3,A0		; COPY ARGUMENT TO A3
	IDIVI	A3,400000	; SEPARATE HIGH AND LOW HALVES
	JUMPE	A3,.+2		; ONLY 18 BITS?
	TLC	A3,254000	; NO - SET UP HIGH HALF EXPONENT
	TLC	A4,233000	; SET UP LOW HALF EXPONENT
	FADL	A3,A4		; AND ADD BITS TOGETHER
	IFE PROC-KI10, <
	TLZ	A4,777000	; IF KI10, WIPE OUT LOW WORD EXPONENT
	LSH	A4,10		; AND SHIFT UP MANTISSA>
	JRST	(AX)

	IFE PROC-KA10, <
SRI:	MOVE	A3,A0		; COPY ARGUMENT TO A3
	FADRI	A3,200400	; RI - ADD 0.5
	MULI	A3,400		; SEPARATE EXPONENT AND MANTISSA
	EXCH	A3,A4
	TSC	A4,A4		; FIX UP EXPONENT
	ASH	A3,-243(A4)	; AND SHIFT MANTISSA TO FORM INTEGER
	JRST	(AX)>
	IFE PROC-KA10, <
SLRI:	DMOVE	A3,A0		; COPY ARGUMENT TO A3,A4
	MOVE	A5,A4		; LRI - ADD 0.5
	FADL	A3,[0.5]
	UFA	A4,A5
	FADL	A3,A5>

	IFE PROC-KI10, <
SLRI:	DMOVE	A3,A0		; COPY ARGUMENT TO A3,A4
	DFAD	A3,[
	EXP	0.5,0.0]	; LRI - ADD 0.5>
	HLRZ	A5,A3
	LSH	A5,-11
	ANDI	A5,000377	; EXTRACT HIGH ORDER EXPONENT
	TLZ	A3,377000	; AND CLEAR IT OUT
	JUMPGE	A3,.+3		; NUMBER POSITIVE?
	TRC	A5,000377	; NO - COMPLEMENT EXTRACTED EXPONENT
	TLO	A3,377000	; AND SET ALL ONES
	IFE PROC-KA10, <
	LSH	A4,10		; IF KA10, SHIFT UP LOW ORDER MANTISSA>
	ASHC	A3,-233(A5)	; SHIFT MANTISSA TO INTEGER
	JRST	(AX)

	IFE PROC-KA10, <
SLRR:	MOVE	A3,A0		; GET HIGH ORDER WORD
	FADR	A3,A1		; ADD LOW ORDER WORD>

	IFE PROC-KI10, <
SLRR:	DMOVE	A3,A0		; COPY ARGUMENT TO A3,A4
	JUMPGE	A3,.+3		; ARGUMENT POSITIVE?
	DMOVN	A3,A3		; NO - NEGATE IT
	TLZA	A4,400000	; AND CLEAR BIT ZERO FLAG
	TLO	A4,400000	; YES - SET BIT ZERO FLAG
	TLNN	A4,200000	; ROUNDING REQUIRED?
	JRST	SLRR1		; NO
	CAMN	A3,[
	XWD	377777,777777]	; YES - HIGH WORD TOO LARGE?
	SYSER2	2,0		; YES - REPORT OVERFLOW
	ADDI	A3,1		; NO
	TLO	A3,400		; CARRY

SLRR1:	JUMPL	A4,(AX)		; EXIT IF POSITIVE
	MOVN	A3,A3		; OTHERWISE NEGATE>
	JRST	(AX)
SUBTTL SINGLE PRECISION POWERS OF TEN

STENM1:	XWD	175631,463146	; 1.0&-1
STEN:	XWD	201400,000000	; 1.0
STEN1:	XWD	204500,000000	; 1.0&1
	XWD	207620,000000	; 1.0&2
	XWD	212764,000000	; 1.0&3
	XWD	216470,400000	; 1.0&4
	XWD	221606,500000	; 1.0&5
	XWD	224750,220000	; 1.0&6
	XWD	230461,132000	; 1.0&7
	XWD	233575,360400	; 1.0&8
	XWD	236734,654500	; 1.0&9
	XWD	242452,013710	; 1.0&10
	XWD	245564,416672	; 1.0&11
	XWD	250721,522451	; 1.0&12
	XWD	254443,023471	; 1.0&13
	XWD	257553,630410	; 1.0&14
	XWD	262706,576512	; 1.0&15
	XWD	266434,157116	; 1.0&16
	XWD	271543,212741	; 1.0&17
	XWD	274674,055532	; 1.0&18
	XWD	300425,434430	; 1.0&19
	XWD	303532,743536	; 1.0&20
	XWD	306661,534466	; 1.0&21
	XWD	312417,031702	; 1.0&22
	XWD	315522,640262	; 1.0&23
	XWD	320647,410336	; 1.0&24
	XWD	324410,545213	; 1.0&25
	XWD	327512,676456	; 1.0&26
	XWD	332635,456171	; 1.0&27
	XWD	336402,374714	; 1.0&28
	XWD	341503,074077	; 1.0&29
	XWD	344623,713116	; 1.0&30
	XWD	347770,675742	; 1.0&31
	XWD	353473,426555	; 1.0&32
	XWD	356612,334311	; 1.0&33
	XWD	361755,023373	; 1.0&34
	XWD	365464,114135	; 1.0&35
	XWD	370601,137164	; 1.0&36
	XWD	373741,367021	; 1.0&37
STEN38:	XWD	377454,732313	; 1.0&38
SUBTTL DOUBLE PRECISION POWERS OF TEN

	IFE PROC-KA10, <

; KA10 HIGH ORDER WORDS

HTENM1:	XWD	175631,463146	; 1.0&&-1
HTEN:	XWD	201400,000000	; 1.0
HTEN1:	XWD	204500,000000	; 1.0&&1
	XWD	207620,000000	; 1.0&&2
	XWD	212764,000000	; 1.0&&3
	XWD	216470,400000	; 1.0&&4
	XWD	221606,500000	; 1.0&&5
	XWD	224750,220000	; 1.0&&6
	XWD	230461,132000	; 1.0&&7
	XWD	233575,360400	; 1.0&&8
	XWD	236734,654500	; 1.0&&9
	XWD	242452,013710	; 1.0&&10
	XWD	245564,416672	; 1.0&&11
	XWD	250721,522450	; 1.0&&12
	XWD	254443,023471	; 1.0&&13
	XWD	257553,630407	; 1.0&&14
	XWD	262706,576511	; 1.0&&15
	XWD	266434,157115	; 1.0&&16
	XWD	271543,212741	; 1.0&&17
	XWD	274674,055531	; 1.0&&18
	XWD	300425,434430	; 1.0&&19
	XWD	303532,743536	; 1.0&&20
	XWD	306661,534465	; 1.0&&21
	XWD	312417,031701	; 1.0&&22
	XWD	315522,640261	; 1.0&&23
	XWD	320647,410336	; 1.0&&24
	XWD	324410,545213	; 1.0&&25
	XWD	327512,676455	; 1.0&&26
	XWD	332635,456171	; 1.0&&27
	XWD	336402,374713	; 1.0&&28
	XWD	341503,074076	; 1.0&&29
	XWD	344623,713116	; 1.0&&30
	XWD	347770,675742	; 1.0&&31
	XWD	353473,426555	; 1.0&&32
	XWD	356612,334310	; 1.0&&33
	XWD	361755,023372	; 1.0&&34
	XWD	365464,114134	; 1.0&&35
	XWD	370601,137163	; 1.0&&36
	XWD	373741,367020	; 1.0&&37
HTEN38:	XWD	377454,732312	; 1.0&&38
; KA10 LOW ORDER WORDS

LTENM1:	XWD	142314,631463	; 1.0&&-1
LTEN:	XWD	000000,000000	; 1.0
LTEN1:	XWD	000000,000000	; 1.0&&1
	XWD	000000,000000	; 1.0&&2
	XWD	000000,000000	; 1.0&&3
	XWD	000000,000000	; 1.0&&4
	XWD	000000,000000	; 1.0&&5
	XWD	000000,000000	; 1.0&&6
	XWD	000000,000000	; 1.0&&7
	XWD	000000,000000	; 1.0&&8
	XWD	000000,000000	; 1.0&&9
	XWD	000000,000000	; 1.0&&10
	XWD	000000,000000	; 1.0&&11
	XWD	215400,000000	; 1.0&&12
	XWD	221240,000000	; 1.0&&13
	XWD	224510,000000	; 1.0&&14
	XWD	227432,000000	; 1.0&&15
	XWD	233760,200000	; 1.0&&16
	XWD	236354,240000	; 1.0&&17
	XWD	241647,310000	; 1.0&&18
	XWD	245110,475000	; 1.0&&19
	XWD	250132,614200	; 1.0&&20
	XWD	253561,357240	; 1.0&&21
	XWD	257446,725444	; 1.0&&22
	XWD	262760,512755	; 1.0&&23
	XWD	265354,635550	; 1.0&&24
	XWD	271024,002441	; 1.0&&25
	XWD	274631,003151	; 1.0&&26
	XWD	277177,204004	; 1.0&&27
	XWD	303617,422402	; 1.0&&28
	XWD	306563,327103	; 1.0&&29
	XWD	311320,214724	; 1.0&&30
	XWD	314004,260111	; 1.0&&31
	XWD	320202,556055	; 1.0&&32
	XWD	323443,311471	; 1.0&&33
	XWD	326554,174007	; 1.0&&34
	XWD	332543,515404	; 1.0&&35
	XWD	335674,440705	; 1.0&&36
	XWD	340653,551067	; 1.0&&37
LTEN38:	XWD	344413,241542	; 1.0&&38>
	IFE PROC-KI10, <

; KI10 HIGH ORDER WORDS

HTENM1:	XWD	175631,463146	; 1.0&&-1
HTEN:	XWD	201400,000000	; 1.0
HTEN1:	XWD	204500,000000	; 1.0&&1
	XWD	207620,000000	; 1.0&&2
	XWD	212764,000000	; 1.0&&3
	XWD	216470,400000	; 1.0&&4
	XWD	221606,500000	; 1.0&&5
	XWD	224750,220000	; 1.0&&6
	XWD	230461,132000	; 1.0&&7
	XWD	233575,360400	; 1.0&&8
	XWD	236734,654500	; 1.0&&9
	XWD	242452,013710	; 1.0&&10
	XWD	245564,416672	; 1.0&&11
	XWD	250721,522450	; 1.0&&12
	XWD	254443,023471	; 1.0&&13
	XWD	257553,630407	; 1.0&&14
	XWD	262706,576511	; 1.0&&15
	XWD	266434,157115	; 1.0&&16
	XWD	271543,212741	; 1.0&&17
	XWD	274674,055531	; 1.0&&18
	XWD	300425,434430	; 1.0&&19
	XWD	303532,743536	; 1.0&&20
	XWD	306661,534465	; 1.0&&21
	XWD	312417,031701	; 1.0&&22
	XWD	315522,640261	; 1.0&&23
	XWD	320647,410336	; 1.0&&24
	XWD	324410,545213	; 1.0&&25
	XWD	327512,676455	; 1.0&&26
	XWD	332635,456171	; 1.0&&27
	XWD	336402,374713	; 1.0&&28
	XWD	341503,074076	; 1.0&&29
	XWD	344623,713116	; 1.0&&30
	XWD	347770,675742	; 1.0&&31
	XWD	353473,426555	; 1.0&&32
	XWD	356612,334310	; 1.0&&33
	XWD	361755,023372	; 1.0&&34
	XWD	365464,114134	; 1.0&&35
	XWD	370601,137163	; 1.0&&36
	XWD	373741,367020	; 1.0&&37
HTEN38:	XWD	377454,732312	; 1.0&&38
; KI10 LOW ORDER WORDS

LTENM1:	XWD	146314,631464	; 1.0&&-1
LTEN:	XWD	000000,000000	; 1.0
LTEN1:	XWD	000000,000000	; 1.0&&1
	XWD	000000,000000	; 1.0&&2
	XWD	000000,000000	; 1.0&&3
	XWD	000000,000000	; 1.0&&4
	XWD	000000,000000	; 1.0&&5
	XWD	000000,000000	; 1.0&&6
	XWD	000000,000000	; 1.0&&7
	XWD	000000,000000	; 1.0&&8
	XWD	000000,000000	; 1.0&&9
	XWD	000000,000000	; 1.0&&10
	XWD	000000,000000	; 1.0&&11
	XWD	200000,000000	; 1.0&&12
	XWD	120000,000000	; 1.0&&13
	XWD	244000,000000	; 1.0&&14
	XWD	215000,000000	; 1.0&&15
	XWD	370100,000000	; 1.0&&16
	XWD	166120,000000	; 1.0&&17
	XWD	323544,000000	; 1.0&&18
	XWD	044236,400000	; 1.0&&19
	XWD	055306,100000	; 1.0&&20
	XWD	270567,520000	; 1.0&&21
	XWD	223352,622000	; 1.0&&22
	XWD	370245,366400	; 1.0&&23
	XWD	166316,664100	; 1.0&&24
	XWD	012001,220450	; 1.0&&25
	XWD	314401,464562	; 1.0&&26
	XWD	077502,001717	; 1.0&&27
	XWD	307611,201141	; 1.0&&28
	XWD	271553,441371	; 1.0&&29
	XWD	150106,351670	; 1.0&&30
	XWD	002130,044246	; 1.0&&31
	XWD	101267,026547	; 1.0&&32
	XWD	221544,634301	; 1.0&&33
	XWD	266076,003362	; 1.0&&34
	XWD	261646,602127	; 1.0&&35
	XWD	336220,342555	; 1.0&&36
	XWD	325664,433310	; 1.0&&37
LTEN38:	XWD	205520,661075	; 1.0&&38>
	END
    a@7