;	COPYRIGHT C 1972 BY CORE & CODE, INC.
	ENTRY CR1ZZZ
CR1ZZZ:	Z
	TTCALL	14,0		;CHECK FOR LINE OF INPUT
	JUMPA	1,DUMMY		;JUMP TO RETURN
DUMMY:	JRA	16,(16)		;RETURN



	ENTRY UPKZZZ
	EXTERNAL C08ZZZ
UPKZZZ:	Z
	MOVEI	1,4			;SET UP COUNTER
L:	LDB	2,LOC(1)		;GET 5,4,3,2,1 CHARS FROM
					;ARGUMENT 'INWORD'
	DPB	2,[POINT 7,C08ZZZ(1),6]	;PUT CHAR IN IPAK(5,4,3,2,1)
					;IN COMMON
	SOJGE	1,L			;TEST FOR END
	JRA	16,1(16)
LOC:	POINT	7,@0(16),6
	POINT	7,@0(16),13
	POINT	7,@0(16),20
	POINT	7,@0(16),27
	POINT	7,@0(16),34



	ENTRY PKZZZ
	EXTERNAL C08ZZZ
PKZZZ:	Z
	MOVEI	1,4			;SET UP COUNTER
L2:	LDB	2,[POINT 7,C08ZZZ(1),6]	;GET CHARACTER
	DPB	2,LOC2(1)		;PUT IT IN 'IOUT'
	SOJGE	1,L2			;TEST FOR END
	JRA	16,1(16)		;RETURN
LOC2:	POINT	7,@0(16),6
	POINT	7,@0(16),13
	POINT	7,@0(16),20
	POINT	7,@0(16),27
	POINT	7,@0(16),34



	ENTRY C76ZZZ
C76ZZZ:	Z
	MOVEI	1,5		;SET UP COUNTER
LA:	LDB	2,LOCI(1)	;GET CHARS 1,2,3,4,5,6
	CAILE	2,137		;LOWER CASE?
	SUBI	2,40		;YES, CONVERT TO UPPER
	SUBI	2,40		;CONVERT TO SIXBIT
	DPB	2,LOCO(1)	;PUT BACK INTO NEW6
	SOJGE	1,LA		;CHECK IF DONE
	JRA	16,3(16)	;RETURN
LOCI:	POINT	7,@1(16),6
	POINT	7,@1(16),13
	POINT	7,@1(16),20
	POINT	7,@1(16),27
	POINT	7,@1(16),34
	POINT	7,@2(16),6
LOCO:	POINT	6,@0(16),5
	POINT	6,@0(16),11
	POINT	6,@0(16),17
	POINT	6,@0(16),23
	POINT	6,@0(16),29
	POINT	6,@0(16),35



	ENTRY FFXZZZ
FFXZZZ:	Z			;SET UP 4 CONSECUTIVE WORDS FOR ENTER
	MOVE	5,@2(16)	;GET OLD FILENAME
	HLLZ	6,@3(16)	;GET OLD EXTENSION
	MOVEI	7,0		;ALWAYS ZERO
	HRL	10,@^D9(16)	;OCTAL GROUP TO LH AC10
	HRR	10,@^D10(16)	;OCTAL USER TO RH AC10
	OPEN	0,SPEC1		;SET UP CHANNEL 0
	JRST	BAD
	LOOKUP	0,5		;LOOKUP CHANNEL 0 AND PUT RESULTS IN
				;ACC5 THRU 10 (OCTAL)
	JRST	GOON
GOON:	HRRZ	11,6		;PUT ERROR CODE INTO ACC11
	CAIG	11,20		;SEE IF ERROR CODE IS DATE(ACCESS)
	MOVNS	11,11		;NO, WAS AN ERROR CODE, MAKE NEGATIVE
	MOVEM	11,@^D11(16)	;PUT ERROR CODE OR +DATE INTO IOK
	MOVEI	12,0		;ZERO OUT 12
	LDB	12,[POINT  ^D11,7,^D23]	;GET TIME CREATED
	MOVEM	12,@7(16)	;PUT INTO ITIME
	MOVEI	12,0		;ZERO OUT 12
	LDB	12,[POINT  ^D12,7,^D35]	;GET DATE CREATED
	MOVEM	12,@^D8(16)	;PUT INTO IDATE
	ASH	10,-^D18	;SHIFT SIZE INTO POSITION
	JUMPLE	10,WORDS	;SEE IF CONTAINS # OF WORDS
	IMULI	10,^D128	;NO,IS IN BLOCKS, CONVERT TO WORDS
	JUMPA	10,WBLKS
WORDS:	MOVNS	10,10		;YES, MAKE # WORDS POSITIVE
WBLKS:	MOVEM	10,@6(16)	;PUT # OF WORDS INTO SIZE
	MOVEI	12,0		;ZERO OUT 12
	LDB	12,[POINT  ^D9,7,^D8]	;GET PROTCT CODE
	MOVEM	12,@5(16)	;PUT INTO IPRO
	MOVEI	13,0		;ZERO OUT 13
	LDB	13,[POINT  4,7,^D12]	;GET MODE
	MOVEM	13,@4(16)	;PUT INTO MODE
	MOVE	5,@0(16)	;GET NEW NAME
	HLLZ	6,@1(16)	;GET NEW EXTENSION
	HRL	10,@^D9(16)	;OCTAL GROUP TO LH AC10
	HRR	10,@^D10(16)	;OCTAL USER TO RH AC10
	MOVEI	14,1		;MOVE +1 TO AC14
	RENAME	0,5		;DO A RENAME
BAD:	MOVNI	14,1		;MOVE -1 TO AC14 ON ERROR
	MOVEM	14,@^D12(16)	;RETURN RENAME ERROR FLAG
	JRA	16,^D13(16)	;RETURN
SPEC1:	16
	SIXBIT	/DSK/
	0



	ENTRY RUPZZZ
; CALL IS:	CALL RUPZZZ(IDEV6,NAME6,NEXT6,PROJ,PROG,IENT)
; WHERE:	IDEV6=6 BIT DEVICE NAME (DSK OR SYS)
;		NAME6=6 BIT FILE NAME
;		NEXT6=6 BIT FILE EXTENSION
;		PROJ=PROJECT (GROUP) NUMBER IN OCTAL
;		PROG=PROGRAMMER (USER) NUMBER IN OCTAL
;		IENT=ENTRY POINT(0=NORMAL,1=JOBSA+1)
RUPZZZ:	Z
	MOVE	1,@0(16)	;MOVE DEVICE TO AC1
	MOVEM	1,PROID		;MOVE DEVICE TO ID BLOCK
	MOVE	1,@1(16)	;MOVE FILE NAME TO AC1
	MOVEM	1,PROID+1	;MOVE FILE NAME TO ID BLOCK
	MOVE	1,@2(16)	;MOVE FILE EXT TO AC1
	MOVEM	1,PROID+2	;MOVE FILE EXT TO ID BLOCK
	HRL	1,@3(16)	;MOVE RH PROJ TO LH AC1
	HRR	1,@4(16)	;MOVE RH PROG TO RH AC1
	MOVEM	1,PROID+4	;MOVE XWD PROJ/PROG TO ID BLOCK
	HRL	1,@5(16)	;MOVE ENTRY INC TO LH AC1
	HRRI	1,PROID		;MOVE ID BLOCK LOC TO RH AC1
	CALLI	1,35		;CALL TO RUN PROGRAM
	JRA	16,6(16)	;RETURN IF ERROR
PROID:	0			;LOGICAL DEVICE NAME
	0			;FILE NAME
	0			;FILE EXTENSION
	0			;ALWAYS ZERO
	0			;XWD PROJ/PROG
	0			;OPTIONAL CORE ASSIGNMENT



	ENTRY OPMZZZ
; CALL IS:	CALL OPMZZZ(IODIR,NAME6,NEXT6,IGROUP,IUSER,ICHAN,IOK)
; WHERE:	IODIR=I/O DIRECTION (1=INPUT,2=OUTPUT)
;		NAME6=6 BIT FILE NAME
;		NEXT6=6 BIT FILE EXTENSION
;		IGROUP=OCTAL GROUP (PROJECT) NUMBER
;		IUSER=OCTAL USER (PROGRAMMER) NUMBER
;		ICHAN=CHANNEL NUMBER
;		IOK=RETURNED ERROR FLAG (1=OK, -1=ERROR)
OPMZZZ:	Z
	MOVE	0,@5(16)		;MOVE CHAN TO AC0
	DPB	0,[POINT 4,OPM1,12]	;DEPOSIT CHAN INTO OPEN
OPM1:	OPEN	0,SPECM			;OPEN CHAN ACCORDING TO SPECM
	JRST	NOTAVL			;ERROR
	MOVE	1,@1(16)		;MOVE FILE NAME TO AC1
	MOVEM	1,FILNAM		;MOVE AC1 TO FILNAM
	MOVE	1,@2(16)		;MOVE FILE EXTENSION TO AC1
	HLLZM	1,FILNAM+1		;MOVE AC1 TO FILNAM
	SETZM	FILNAM+2		;ZERO FILNAM+2
	HRL	1,@3(16)		;MOVE GROUP TO LH AC1
	HRR	1,@4(16)		;MOVE USER TO RH AC1
	MOVEM	1,FILNAM+3		;MOVE XWD GROUP,USER TO FILNAM+3
	MOVE	1,@0(16)		;MOVE IODIR TO AC1
	SOJLE	1,INMAC			;CHECK & JUMP IF INPUT
OUTMAC:	DPB	0,[POINT 4,OPM2,12]	;DEPOSIT CHAN INTO ENTER
OPM2:	ENTER	0,FILNAM		;OUTPUT ENTER
	JRST	NOTAVL			;ERROR
	JRST	GOODF			;SUCCESS
INMAC:	DPB	0,[POINT 4,OPM3,12]	;DEPOSIT CHAN INTO LOOKUP
OPM3:	LOOKUP	0,FILNAM		;INPUT LOOKUP
	JRST	NOTAVL			;ERROR
	SETZM	2			;ZERO AC2
	SETZM	3			;ZERO AC3
	CALLI	1,24			;GET JOB PPN TO CHECK PROT
	JRST	ALWAYS			;TWO POSSIBLE RETURNS
ALWAYS:	SKIPE	@3(16)			;LEAVE AC2 = 0 IF PROJ .EQ. 0
	HLRZM	1,2			;MOVE PROJ TO AC2
	SKIPE	@4(16)			;LEAVE AC3 = 0 IF PROG .EQ. 0
	HRRZM	1,3			;MOVE PROG TO AC3
	CAME	2,@3(16)		;SKIP IF FILE PROJ .EQ. JOB PROJ
	JRST	ALLOTH			;ALL OTHER PROT CATEGORY
	CAME	3,@4(16)		;SKIP IF FILE PROG .EQ. JOB PROG
	JRST	SAMPRJ			;SAME PROJ PROT CATEGORY
SAMPRG:	LDB	1,[POINT 3,FILNAM+2,2]	;LOAD SAME PROG PROT BITS
	JRST	CHKPRT			;JUMP TO CHECK PROT BITS
SAMPRJ:	LDB	1,[POINT 3,FILNAM+2,5]	;LOAD SAME PROJ PROT BITS
	JRST	CHKPRT			;JUMP TO CHECK PROT BITS
ALLOTH:	LDB	1,[POINT 3,FILNAM+2,8]	;LOAD ALL OTHER PROT BITS
CHKPRT:	CAILE	1,5			;PROT OK IF .LE. 5
	JRST	NOTAVL			;PROT ERROR
GOODF:	MOVEI	1,1			;MOVE +1 TO AC1
	MOVEM	1,@6(16)		;MOVE AC1 TO IOK
	JRA	16,7(16)		;RETURN
NOTAVL:	MOVNI	1,1			;MOVE -1 TO AC1
	MOVEM	1,@6(16)		;MOVE AC1 TO IOK
	JRA	16,7(16)		;RETURN
SPECM:	16				;DUMP MODE
	SIXBIT	/DSK/			;DSK
	0				;NO BUFFERS
FILNAM:	0				;BLOCK FOR FILE NAME, ETC.
	0
	0
	0



	ENTRY GSIZZZ
; CALL IS:	CALL GSIZZZ(ISIZE)
; WHERE:	ISIZE=RETURNED SIZE (WORDS) OF LAST FILE OPENED
;		      VIA FILNAM LOOKUP BLOCK
GSIZZZ:	Z
	MOVE	10,FILNAM+3		;MOVE SIZE INTO AC10
	ASH	10,-^D18		;SHIFT SIZE INTO RH AC10
	JUMPLE	10,CSIWDS		;SEE IF CONTAINS # OF WORDS
	IMULI	10,^D128		;BLOCKS SO CONVERT TO WORDS
	JUMPA	10,CSIBLK		;JUMP TO CSIBLK
CSIWDS:	MOVNS	10,10			;WORDS SO MAKE POSITIVE
CSIBLK:	MOVEM	10,@0(16)		;RETURN NUMBER OF WORDS
	JRA	16,1(16)		;RETURN



	ENTRY CLMZZZ
CLMZZZ:	Z
	MOVE	0,@0(16)		;MOVE CHAN TO AC0
	DPB	0,[POINT 4,CLM1,12]	;DEPOSIT CHAN INTO CLOSE
CLM1:	CLOSE	0,			;CLOSE CHANNEL
	DPB	0,[POINT 4,CLM2,12]	;DEPOSIT CHAN INTO RELEASE
CLM2:	RELEAS	0,			;RELEASE DEVICE
	JRA	16,1(16)		;RETURN



	ENTRY MIOZZZ
; CALL IS:	CALL MIOZZZ(IARRAY,IWD1,IWD2,IDIR,ICHAN,IOK)
; WHERE:	IARRAY=ARRAY TO BE INPUT/OUTPUT
;		IWD1=1ST WORD TO BE TRANSFERRED
;		IWD2=LAST WORD TO BE TRANSFERRED
;		IDIR=I/O DIRECTION (1=INPUT,2=OUTPUT)
;		ICHAN=CHANNEL NUMBER
;		IOK=ERROR FLAG (+1=OK,-1=ERROR)
MIOZZZ:	Z
	HRRZ	1,0(16)			;MOVE ARRAY LOC TO AC1
	SUBI	1,1			;SUBT 1 = LOC BEFORE ARRAY
	MOVE	2,@1(16)		;MOVE IWD1 INTO AC2
	SUBI	2,1			;SUBT 1 = NO WDS TO START-1
	MOVE	3,@2(16)		;MOVE IWD2 TO AC3
	SUB	3,2			;SUBT IWD-(IWD1-1)=NO WRDS
	MOVNS	3,3			;MAKE WORDS NEGATIVE
	HRLM	3,IO2LST		;MOVE NEG. NO. WRDS TO IO2LST
	ADD	2,1			;ADD (ARRAY LOC-1)+(START-1)
	HRRM	2,IO2LST		;MOVE ARRAY START-1 TO IO2LST
	MOVE	4,@4(16)		;MOVE CHANNEL TO AC4
	MOVE	5,@3(16)		;MOVE IO DIR TO AC5
	SOJLE	5,MACIN			;IF IO DIR LE 1 JUMP TO INPUT
MACOUT:	DPB	4,[POINT 4,MACOUT+1,12]	;DEPOSIT CHAN INTO OUTPUT
	OUTPUT	0,IO2LST		;OUTPUT BY IO2LST
	JRST	IOSTAT			;JUMP TO IO STATUS CHECK
MACIN:	DPB	4,[POINT 4,MACIN+1,12]	;DEPOSIT CHAN INTO INPUT
	INPUT	0,IO2LST		;INPUT BY IO2LST
IOSTAT:	MOVEI	6,1			;MOVE +1 TO AC6
	DPB	4,[POINT 4,MACSTZ,12]	;DEPOSIT CHAN INTO STATZ
MACSTZ:	STATZ	0,760000		;STATUS CHECK (INCLUDES EOF)
	MOVNS	6,6			;ERROR SO SET IOK=-1
	MOVEM	6,@5(16)		;RETURN IOK FLAG
	JRA	16,6(16)		;RETURN
IO2LST:	IOWD	0,0			;DUMMY IOWD
	0				;END IO TRANSFER



	ENTRY TRDZZZ
; CALL IS:	CALL TRDZZZ(IARRAY,ISTART,ISTOP,ISIZE)
; WHERE:	IARRAY=ARRAY WHERE INPUT IS TO BE STORED
;		ISTART=FIRST WORD TO FILL IN IARRAY (1 CHR PER WD)
;		ISTOP=LAST WORD TO FILL IN IARRAY (1 CHR PER WD)
;		ISIZE=RETURNED AS NUMBER OF CHARS ACTUALLY READ
TRDZZZ:	Z
	HRRZ	1,0(16)			;MOVE ARRAY LOC TO AC1
	SUBI	1,1			;SET AC1 1 BEFORE ARRAY
	MOVEM	1,5			;SAVE ARRAY LOC-1 IN AC5
	MOVE	2,@2(16)		;MOVE ISTOP TO AC2
	ADD	2,1			;ADD ARRAY LOC-1=END LOC
	ADD	1,@1(16)		;ADD ISTART TO ARR LOC-1 =START
	SUBI	1,1			;SET AC1 1 BEFORE START
	MOVEM	1,6			;SAVE START-1 IN AC6
	MOVE	3,NULL			;MOVE NULL TO AC3
TTYCHR:	TTCALL	4,7			;LOAD 7 BIT CHAR INTO AC7
	DPB	7,[POINT 7,3,6]		;DEPOSIT 7 BIT FROM AC7 TO AC3
	MOVEI	4,6			;MOVE CHAR COUNTER TO AC4
CHKBRK:	CAMN	3,BREAK(4)		;SKIP IF AC3 NE BREAK CHR
	JRST	ENDLIN			;GO TO END OF LINE
	SOJLE	4,CHKBRK		;GO BACK & CHK NEXT BREAK CHR
	CAML	1,2			;NOT A BREAK--SKIP IF LT ENDLOC
	JRST	TTYCHR			;BYPASS MOVING CHAR & GET NEXT
	ADDI	1,1			;ADD 1 TO AC1 = LOC NEXT CHR
	MOVEM	3,@1			;MOVE CHAR TO ARRAY
	JRST	TTYCHR			;GO BACK FOR NEXT CHAR
ENDLIN:	MOVE	3,@1			;MOVE LAST ARRAY CHR BACK TO AC3
	CAMN	3,CR			;SKIP IF IT WAS NOT A CR
	CAMG	1,6			;SKIP IF LAST SPOT GT START-1
	JRST	BLKLIN			;NO NEED TO BLANK CR
	SUBI	1,1			;SET NEXT SPOT BACK ONE TO CR
BLKLIN:	MOVEM	1,4			;MOVE CURRENT SPOT TO AC4
	SUB	4,5			;SUBT ARRAY LOC-1 =NO CHRS
	MOVEM	4,@3(16)		;MOVE NO CHRS TO ISIZE
	MOVE	3,BLANK			;SET UP BLANK IN AC3
NEXBLK:	ADDI	1,1			;ADD 1 FOR NEXT BLANK-OUT SPOT
	CAMLE	1,2			;SKIP IF LE LAST SPOT
	JRA	16,4(16)		;RETURN
	MOVEM	3,@1			;MOVE BLANK TO ARRAY
	JRST	NEXBLK			;GO BACK FOR NEXT BLANK-OUT
NULL:	001004020100			;NULL
CR:	065004020100			;CARRIAGE RETURN
BLANK:	201004020100			;BLANK
BREAK:	035004020100			;^G (BELL)
	125004020100			;^U (DELETE LINE)
	151004020100			;^Z (TTY EOF)
	155004020100			;ALTMODE
	765004020100			;ALTMODE
	771004020100			;ALTMODE
	051004020100			;^J (LINE FEED)



	ENTRY TWTZZZ
;CALL IS:	CALL TWTZZZ(LSIZE,IARRAY)
;WHERE:		LSIZE=NO CHRS (1 PER WORD) TO WRITE
;		IARRAY=ARRAY WHERE OUTPUT IS STORED
TWTZZZ:	Z
	HRRZ	1,1(16)			;MOVE ARRAY LOC TO AC1
	SUBI	1,1			;SET AC1=1 BEFORE ARRAY
	MOVE	2,@0(16)		;MOVE SIZE TO AC2
	ADD	2,1			;ADD START TO SIZE=END LOC
	MOVEI	6,0			;ZERO BUFFER COUNTER
NEWWRD:	MOVEI	4,0			;ZERO CHAR COUNTER
	MOVEI	5,0			;ZERO PACKED WORD
MORCHR:	ADDI	1,1			;SET LOC OF NEXT INCOMING CHAR
	CAMLE	1,2			;SKIP IF NOT END OF ARRAY
	JRST	TWTEND			;GO TO OUTPUT AND RETURN
	LDB	3,[POINT 7,@1,6]	;LOAD IN INCOMING CHAR
	CAIG	3,0			;SKIP IF NOT NULL
	JRST	MORCHR			;BACK FOR NEXT CHAR IF NULL
	ADDI	4,1			;INCREMENT CHAR COUNTER
	DPB	3,TWTPAK(4)		;DEPOSIT CHAR IN PACKED WORD
	CAIGE	4,5			;SKIP IF CHAR COUNTER >= 5
	JRST	MORCHR			;BACK FOR NEXT CHAR IF < 5
	ADDI	6,1			;INCREMENT BUFFER COUNTER
	MOVEM	5,TWTBUF(6)		;MOVE PACKED WORD TO BUFFER
	JRST	NEWWRD			;BACK TO START NEW PACKED WORD
TWTEND:	ADDI	6,1			;INCREMENT BUFFER COUNTER
	MOVEM	5,TWTBUF(6)		;MOVE LAST PACKED WORD TO BUFFER
	ADDI	6,1			;INCREMENT BUFFER COUNTER
	SETZM	TWTBUF(6)		;MOVE NULL WORD TO BUFFER
	TTCALL	3,TWTOUT		;TTCALL FOR OUTPUT
TWTPAK:	JRA	16,2(16)		;RETURN
	POINT	7,5,6			;POINTERS TO PACK AC5
	POINT	7,5,13
	POINT	7,5,20
	POINT	7,5,27
TWTBUF:	POINT	7,5,34
TWTOUT:	BLOCK	^D28			;TTY OUTPUT BUFFER



	ENTRY IBTZZZ
;CALL IS:	I=IBTZZZ(ICHAR)
;WHERE: 	ICHAR=ASCII CHAR PADDED WITH 4 BLANKS
IBTZZZ: Z
	LDB	0,ONECHR		;LOAD IN CHAR
	ADDI	0,1			;ADD 1 = NASCII LOC
	CAIL	0,^D66			;SKIP IF .LT. "A"
	CAILE	0,^D91			;SKIP IF .LE. "Z"
	MOVNI	0,1			;MOVE IN ERROR FLAG
	JRA	16,1(16)		;RETURN
ONECHR: POINT	7,@0(16),6		;SINGLE LEFT JUSTIFIED CHAR



	ENTRY NBRZZZ
;CALL IS:	I=NBRZZZ(ICHAR)
;WHERE: 	ICHAR=ASCII CHAR PADDED WITH 4 BLANKS
NBRZZZ: Z
	LDB	0,ONECHR		;LOAD IN CHAR
CHKNBR: SUBI	0,^D48			;SUBT "0"
	CAIL	0,0			;SKIP IF .LT. "0"
	CAILE	0,^D9			;SKIP IF .LE. "9"
	MOVNI	0,1			;MOVE IN ERROR FLAG
	JRA	16,1(16)		;RETURN



	ENTRY IBNZZZ
;CALL IS:	I=IBNZZZ(ICHAR)
;WHERE: 	ICHAR=ASCII CHAR PADDED WITH 4 BLANKS
IBNZZZ:	Z
	LDB	0,ONECHR		;LOAD IN CHAR
	CAIL	0,^D65			;SKIP IF .LT. "A"
	CAILE	0,^D90			;SKIP IF .LE. "Z"
	JRST	CHKNBR			;CHECK FOR NUMBER
	ADDI	0,1			;ADD 1 = NASCII LOC
	JRA	16,1(16)		;RETURN



	ENTRY NRCZZZ
;CALL IS:	I=NRCZZZ(ICHAR)
;WHERE:		ICHAR=ASCII CHAR PADDED WITH 4 BLANKS
NRCZZZ:	Z
	LDB	0,ONECHR		;LOAD IN CHAR
	ADDI	0,1			;ADD 1 = NASCII LOC
	CAIL	0,^D49			;SKIP IF .LT. "0"
	CAILE	0,^D58			;SKIP IF .LE. "9"
	MOVNI	0,1			;MOVE IN ERROR FLAG
	JRA	16,1(16)		;RETURN



	ENTRY USTZZZ
; CALL IS:	CALL USTZZZ(ICHAN,IBLKNO,IDIR)
; WHERE:	ICHAN=CHANNEL NUMBER
;		IBLKNO=BLOCK NUMBER
;		IDIR=IO DIRECTION (1=INPUT,2=OUTPUT)
USTZZZ:	Z
	MOVE	0,@0(16)		;MOVE CHAN TO AC0
	MOVE	1,@1(16)		;MOVE BLOCK NO. TO AC1
	MOVE	2,@2(16)		;MOVE IO DIRECTION TO AC2
	SOJLE	2,SETI			;IF IO DIR LE 1 JUMP TO USETI
SETO:	DPB	0,[POINT 4,SETO+2,12]	;DEPOSIT CHAN INTO USETO
	HRRM	1,SETO+2		;DEPOSIT BLOCK NO INTO USETO
	USETO	0,0			;SET OUTPUT BLOCK POINTER
	JRA	16,3(16)		;RETURN
SETI:	DPB	0,[POINT 4,SETI+2,12]	;DEPOSIT CHAN INTO USETI
	HRRM	1,SETI+2		;DEPOSIT BLOCK NO INTO USETI
	USETI	0,0			;SET INPUT BLOCK POINTER
	JRA	16,3(16)		;RETURN



	EXTERNAL DEVTB.,DEVLS.
	ENTRY JJ1ZZZ
JJ1ZZZ:	Z
	PUSH	17,1		;SAVE AC1
	MOVE	1,@0(16)	;MOVE LOG UNIT TO AC1
	ADDI	1,DEVTB.	;ADD LOG UNIT TO DEV TABLE POS
	MOVSI	0,(SIXBIT/DSK/)	;MOVE 6-BIT "DSK" TO LH AC0
	CAILE	1,DEVTB.	;IF AC1 <= DEV TABLE POS = ERROR
	CAILE	1,DEVLS.	;IF AC1 > DEV TABLE LAST POS = ERROR
	JRST	.+3		;JUMP TO ERROR
	MOVEM	0,0(1)		;MOVE 6-BIT "DSK" TO DEV TABLE
	TDZA	0,0		;ZERO AC0 AND SKIP (GOOD RETURN)
	SETOI	0,		;SET AC0 TO -1 (ERROR RETURN)
	POP	17,1		;RESTORE VALUE TO AC1
	JRA	16,1(16)	;RETURN



	ENTRY TMPZZZ
TMPZZZ:	Z
	MOVEI	1,^D2		;MOVE CHR COUNTER TO AC1
	CALLI	2,30		;GET JOB NUMBER TO AC2
NTCHR:	IDIVI	2,^D10		;GET REMAINDER TO AC3
	ADDI	3,^D48		;ADJUST TO GET CHR
	DPB	3,TMPCHR(1)	;DEPOSIT CHR INTO NAME
	SOJGE	1,NTCHR		;GO BACK TO PRODUCE NEXT CHR
	JRA	16,1(16)	;RETURN
TMPCHR:	POINT	7,@0(16),6
	POINT	7,@0(16),13
	POINT	7,@0(16),20



	ENTRY SETZZZ
	EXTERNAL C15ZZZ
SETZZZ:	Z
	CALLI	1,23		;PUT MILLISEC TIME SINCE MIDNITE IN ACC1
	MOVE	2,@(16)		;GET ARG
	MOVEM	1,C15ZZZ(2)	;PUT INTO ICONN(ARG)
	MOVEI	3,0		;CLEAR AC3 TO SET CURRENT JOB
	CALLI	3,27		;GET MILLISEC COMPUTE TIME SINCE LOGIN
	ADDI	2,^D4		;MOVE ARG POINTER TO ICOMP
	MOVEM	3,C15ZZZ(2)	;PUT INTO ICOMP(ARG)
	JRA	16,1(16)	;RETURN



	ENTRY PEXZZZ
PEXZZZ:	Z
	EXIT
	END
