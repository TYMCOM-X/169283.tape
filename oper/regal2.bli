
!COPYRIGHT 1972, DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS
!AUTHOR: S.MURPHY
GLOBAL BIND REGAV=89;		!VERSION DATE: JULY 26, 1973



%(***************************************************************************
	LOCAL REGISTER ALLOCATION MODULE.
	INCLUDES 2 PASSES OVER AN EXPRESSION TREE.
	ON THE "COMPLEXITY WALK" (IE THE ROUTINE SETCOMPLEXITY AND ALL THE
	ROUTINES IT CALLS), THE NODES ARE REARRANGED TO REDUCE THE NUMBER
	OF REGISTERS NECESSARY TO COMPUTE THEM, AND THE MINIMUM NUMBER OF REGS NECESSARY
	IS SAVED IN EACH NODE.
	AT THIS TIME CONSTANTS THAT CAN BE USED "IMMED MODE" ARE RECOGNIZED
	AND SPACE IS ALLOCATED FOR ALL OTHERS.
	THE CONSTANT PART OF AN ARRAY ADDRESS CALC IS ALSO ADDED IN TO
	THE INSTRUCTION ADDRESS AT THIS TIME.
	THE 2ND WALK (THE ROUTINES "ALCINREG" AND "ALCINTMP") ALLOCATES
	REGISTERS(AND/OR TEMPORARIES) FOR EACH BINARY/UNARY OPERATION TO BE
	PERFORMED - TARGETING THE VALUE OF AN EXPRESSION TO A PARTICULAR
	REG/TMP
	THE GLOBAL "TREEPTR" IS USED IN BOTH THESE WALKS TO POINT TO
	THE NODE OF THE EXPRESSION TREE BEING PROCESSED.
***************************************************************************)%


MAP PEXPRNODE TREEPTR;


GLOBAL ROUTINE ALCINREG(RA,BSYREGS,FREGCT) =
%(***************************************************************************
	PERFORM REGISTER ALLOCATION FOR SUBNODES OF THE NODE POINTED TO BY
	THE GLOBAL "TREEPTR" SUCH THAT THE VALUE OF THAT NODE
	WILL BE LEFT IN THE REG "RA"
	THIS ROUTINE IS ONLY CALLED WHEN THE COMPLEXITY OF THE
	NODE TO BE PROCESSED IS KNOWN TO BE LESS THAN THE NUMBER
	OF REGISTERS AVAILABLE TO PROCESS IT
	THE ARG "BSYREGS" HAS BITS 0-15 REPRESENTING THE 16 ACS
	THE BIT FOR A GIVEN AC IS 1 IF THAT IS AVAILABLE FOR USE
***************************************************************************)%

BEGIN
	LOCAL PEXPRNODE CNODE;
	CASE .TREEPTR[OPRCLS] OF SET

	%(****FOR A BOOLEAN OPERATOR***************)%
	ALCVBOOL(.RA,.BSYREGS,.FREGCT);

	%(****FOR A DATA REFERENCE - SHOULD ONLY GET HERE IN CERTAIN RARE CASES*******)%
	BEGIN END;

	%(****FOR RELATIONALS***************************************)%
	ALCREL(.RA,.BSYREGS,.FREGCT);

	%(*****FOR FUNCTION CALLS********************************)%
	BEGIN
		CNODE_.TREEPTR;
		IF NOT .TREEPTR[ALCRETREGFLG]
		THEN
		%(***IF CANNOT LEAVE THE VALUE SITTING IN RETREG (BECAUSE IT WILL
			BE CLOBBERED BEFORE IT IS USED)***)%
		BEGIN
			TREEPTR[STOREFLG]_1;
			SETTARGINREG(.TREEPTR,.RA);
		END;
		%(***EVALUATE ALL ARGS INTO TMPS OR VARS***)%
		TREEPTR_.TREEPTR[ARG2PTR];
		ALCFNARGS(.BSYREGS,.FREGCT,.CNODE[DBLFLG]);
	END;

	%(*****FOR ARITHMETIC EXPRESSIONS************************)%
	ALCA(.RA,.BSYREGS,.FREGCT);

	%(*****FOR TYPE CONVERSION******************************)%
	ALCTPCNV(.RA,.BSYREGS,.FREGCT,FALSE);

	%(*****FOR ARRAY REFERENCE**********)%
	ALCARRAY(.RA,.BSYREGS,.FREGCT);

	%(*****FOR COMMON SUBEXPRESSION*****)%
	%(******SHOULD NOT WALK DOWN OVER THEM (ONLY GET HERE AT ALL IN RARE CASES)***)%
	BEGIN END;

	%(*****FOR NEG/NOT****************)%
	ALCNEGNOT(.RA,.BSYREGS,.FREGCT);

	%(*****FOR SPECIAL-CASE OPS INTRODUCED BY PHASE 2 SKELETON****)%
	ALCSPECOP(.RA,.BSYREGS,.FREGCT);


	CGERR();				!FIELD-REF, NOT IN RELEASE 1
	CGERR();				!STORECLS: SHOULD NOT EXIST PRIOR TO
						! THIS PASS OVER THE TREE
	BEGIN  END;				!REGCONTENTS: SHOULD RARELY WALK DOWN HERE
	CGERR();				!LABOP: SHOULD NEVER WALK DOWN ON ONE
	CGERR();				!STATEMENT: SHOULD NOT OCCUR UNDER
						! AN EXPRESSION
	CGERR();				!IOLSCLS: SHOULD NOT OCCUR


	%(****FOR AN IN-LINE-FN*****)%
	ALCILF(.RA,.BSYREGS,.FREGCT);

	TES;

END;
GLOBAL ROUTINE ALCREL(RA,BSYREGS,FREGCT) =
%(***************************************************************************
	PERFORM REGISTER ALLOCATION FOR RELATIONALS
***************************************************************************)%
BEGIN
	OWN PEXPRNODE ARGNODE;
	LOCAL ADJREGCT;


	ARGNODE_.TREEPTR[ARG1PTR];

	%(***IF THE ARGS OF THIS REL ARE DOUBLE-WD (AND HENCE WE ARE GOING DOWN
		FROM PROCESSING SINGLE-WD OPERATIONS TO PROCESSING DOUBLE-WD OPS)
		WE MUST ADJUST THE COUNT OF AVAILABLE REGS BEFORE DETERMINING WHETHER
		TO LEAVE THE VAL OF THE REL IN A REG***)%
	IF .ARGNODE[DBLFLG]
	THEN
	BEGIN
		OWN BSYRG1;
		BSYRG1_DPBSYREGS(.BSYREGS);
		ADJREGCT_ONESCOUNT(.BSYRG1);
	END
	ELSE ADJREGCT_.BSYREGS;


	IF .TREEPTR[COMPLEXITY] LEQ .ADJREGCT
	THEN
	BEGIN
		%(***COMPUTE THE VAL OF THE REL(TRUE OR FALSE) INTO THE REG RA***)%
		SETTARGINREG(.TREEPTR,.RA);

		%(***PERFORM REG ALLOCATION FOR THE COMPARISON***)%
		ALCRL1(CLRBIT(.BSYREGS,.RA),.FREGCT-1)
	END
	ELSE
	BEGIN
		%(***COMPUTE THE VAL OF THE REL INTO A TEMPORARY***)%
		TREEPTR[TARGTMEM]_NXTTMP(FALSE);
		%(***PERFORM REG ALLOCATION FOR THE COMPARISON***)%
		ALCRL1(.BSYREGS,.FREGCT)
	END;

END;


GLOBAL ROUTINE ALCRL1(BSYREGS,FREGCT)=
%(***************************************************************************
	PERFORM REGISTER ALLOCATION FOR THE COMPARISON OPERATION OF A RELATIONAL
	(BUT NOT FOR THE STORING OF THE VALUE OF THE RELATIONAL).
	THIS ROUTINE IS CALLED BOTH FOR RELATIONALS USED ONLY FOR
	CONTROL PURPOSES AND FOR RELATIONALS WHOSE VALUES ARE COMPUTED.
	CALLED WITH THE ARGS
		BSYREGS - HAS BIT SET FOR EACH REGISTER AVAILABLE FOR USE
			BITS 0-15 REPRESENT THE 16 REGS
		FREGCT - NUMBER OF REGISTERS AVAILABLE
	CALLED WITH THE GLOBAL TREEPTR POINTING TO THE RELATIONAL NODE TO
		BE ALLOCATED.
***************************************************************************)%
BEGIN
	LOCAL RGFORCM;
	LOCAL PEXPRNODE CNODE:ARG1NODE:ARG2NODE;
	EXTERNAL ALOCONST;

	CNODE_.TREEPTR;
	ARG1NODE_.CNODE[ARG1PTR];
	ARG2NODE_.CNODE[ARG2PTR];


	%(***IF THE ARGS UNDER THIS RELATIONAL ARE DOUBLE-WORD, MUST ADJUST THE
		SET OF AVAILABLE REGISTERS TO INCLUDE ONLY EVEN REGISTERS***)%
	IF .ARG1NODE[DBLFLG]
	THEN
	BEGIN
		BSYREGS_DPBSYREGS(.BSYREGS);
		FREGCT_ONESCOUNT(.BSYREGS);
		CNODE[COMPLEXITY]_.CNODE[COMPLEXITY]^(-1) + 1;	!CHANGE COMPLEXITY OF THE
								! RELAT TO BE IN TERMS OF PAIRS
	END;


	RGFORCM_FIRSTONE(.BSYREGS);

	%(****PERFORM REGISTER ALLOCATION FOR THE 2 ARGS, TO GET THE FIRST ONE
		INTO THE 'REGFORCM' ("REGISTER FOR COMPARISON") IF POSSIBLE.*****)%
	IF NOT (.CNODE[A1VALFLG] AND .CNODE[A2VALFLG])
	THEN
	ALCARGS(.RGFORCM,.BSYREGS,.FREGCT);

	%(****IF POSSIBLE, DO THE COMPARISON IN WHATEVER REGISTER ARG1 WAS COMPUTED
		INTO************)%
	IF NOT .CNODE[ALCRETREGFLG]
	THEN
	BEGIN
		IF (.ARG1NODE[OPRCLS] EQL DATAOPR) OR NOT .ARG1NODE[INREGFLG] OR .ARG1NODE[ALCRETREGFLG]
			OR .CNODE[A1IMMEDFLG] OR (.CNODE[A1VALFLG] AND .CNODE[A1NEGFLG])
		THEN
		%(***IF ARG1 WAS NOT COMPUTED INTO A REG THAT CAN BE USED FOR THE COMPAR***)%
		BEGIN
			%(***IF ARG2 IS IN A REG THAT CAN BE USED FOR THE COMPAR, SWAP
				THE 2 ARGS AND THEN USE THAT REG*****)%
			IF (.ARG2NODE[OPRCLS] NEQ DATAOPR) AND (.ARG2NODE[INREGFLG])
				AND (NOT .ARG2NODE[ALCRETREGFLG]) AND (NOT .CNODE[A2IMMEDFLG])
				AND NOT .CNODE[A1NEGFLG]	!CANT HAVE A NEG ON ARG2 OF A REL
			THEN
			BEGIN
				EXCHARGS(.CNODE);
				CNODE[RVRSFLG]_NOT .CNODE[RVRSFLG];
				CNODE[TARGAUX]_.ARG2NODE[TARGTAC];
				CNODE[A1SAMEFLG]_1;		!(ARG2NODE IS NOW ARG1)

				%(***IF HAVE NOW CAUSED ARG2 TO BE A REAL IMMED CONST,
					MUST ALLOCATE CORE FOR IT***)%
				IF (.ARG1NODE[OPERATOR] EQL REALCONST	!FORMER ARG1 IS NOW ARG2
					OR .ARG1NODE[OPERATOR] EQL CPLXCONST)
					AND .ARG1NODE[CONST1] NEQ 0	!CAN DO CAI FOR 0
				THEN
				BEGIN
					CNODE[A2IMMEDFLG]_0;
					ALOCONST(.ARG1NODE);
				END;
			END

			ELSE
			%(***IF NEITHER ARG IS IN A REG THAT CAN BE USED FOR THE COMPAR, USE
				SOME FREE REG****)%
			BEGIN
				RGFORCM_REGTOUSE(.CNODE,.ARG1NODE,.ARG2NODE,.RGFORCM,.BSYREGS);
				CNODE[TARGAUX]_ASNREG(.RGFORCM);
				CLOBBREGS_SETBIT(.CLOBBREGS,.RGFORCM);
			END;
		END
		ELSE
		%(****IF WILL USE THE REG CONTAINING ARG1 FOR THE COMPARISON***)%
		BEGIN
			CNODE[TARGAUX]_.ARG1NODE[TARGTAC];
			CNODE[A1SAMEFLG]_1;
		END;
	END;

	%(****IF THE COMPARISON WAS OF DOUBLE-WD VALUES, THEN WILL CLOBBER THE ODD
		REG FOLLOWING EACH EVEN REG CLOBBERED*******)%
	IF .ARG1NODE[DBLFLG]
	THEN SETDPCLOBB;

END;



GLOBAL ROUTINE ALCA(RA,BSYREGS,FREGCT) = 
%(***************************************************************************
	PERFORM REGISTER ALLOCATION FOR A BINARY NODE POINTED TO
	BY THE GLOBAL TREEPTR
	CALLED WITH THE ARGS
		RA - REGISTER INTO WHICH THE 1ST ARG TO BE "COMPUTED
			INTO THE RESULT" SHOULD BE MOVED
		BSYREGS - BITS 0-15 OF THIS WD REPRESENT THE 16 REGS,
			A BIT IS 1 IFF THE CORRESP REG IS AVAIL FOR USE
		FREGCT - NUMBER OF FREE REGISTERS AVAILABLE
***************************************************************************)%

BEGIN
	LOCAL PEXPRNODE CNODE;
	OWN PEXPRNODE ARG1NODE;
	OWN RB;					!REG IN WHICH VAL OF SON WAS LEFT

	CNODE_.TREEPTR;

	%(****IF THIS OPERATION CLOBBERS THE REGISTER FOLLOWING THE ONE ON
		WHICH IT IS PERFORMED, MUST BE SURE TO NOT
		PERFORM IT ON A REG PRECEEDING A REG WHOSE VAL MUST BE PRESERVED
	*******)%
	IF CLBNXREG(CNODE)
	THEN
	RA_GETRGPR(.RA,.BSYREGS);


	%(****IF THIS OPERATION IS ONE WHICH WILL BE PERFORMED BY A LIBRARY FN,
		AND THE 2 ARGS ARE IDENTICAL,  THEN THE 2ND ARG
		MUST BE COMPUTED INTO A MEMORY LOC.
		IF SO, GO PERFORM THE REGISTER ALLICATION FOR THE ARGS OF THIS NODE.
	******)%
	IF USEFNCALL(CNODE) AND (.CNODE[ARG1PTR] EQL .CNODE[ARG2PTR])
	THEN
	ALCLIBFN(.RA,.BSYREGS,.FREGCT)

	ELSE
	%(****UNLESS BOTH ARGS ARE VARIABLES OR COMMON SUBEXPRESSIONS, GO PERFORM REGISTER
		ALLOCATION FOR THEM, COMPUTING ARG1 INTO RA IF POSSIBLE****)%
	IF NOT ( .TREEPTR[A1VALFLG] AND .TREEPTR[A2VALFLG])
	THEN
	ALCARGS(.RA,.BSYREGS,.FREGCT);

	%(***IF HAVE ALREADY DETERMINED THAT CNODE SHOULD BE COMPUTED IN THE FN-RETURN REG, 
		ARE DONE WITH CNODE*****)%
	IF .CNODE[ALCRETREGFLG] THEN RETURN;

	ARG1NODE_.CNODE[ARG1PTR];

	%(***IF ARG1 WAS LEFT IN A REG THAT CAN BE USED FOR THE COMPUTATION OF CNODE,
		WE WANT TO USE THAT REG.
	*******)%

	IF (NOT .CNODE[A1VALFLG]) AND (.ARG1NODE[INREGFLG]) AND (NOT .ARG1NODE[ALCRETREGFLG])
	THEN
	BEGIN
		RB_INVASNREG(.ARG1NODE[TARGTAC]);
		%(***IF COMPUTATION OF CNODE CLOBBERS REG AFTER THE TARGET REG, THEN CAN
			ONLY USE RB IF THE REG FOLLOWING IT IS FREE.***)%
		IF CLBNXREG(CNODE) AND (NOT NXREGFREE(.BSYREGS,.RB))
		THEN RA_REGTOUSE(.CNODE,.ARG1NODE,.CNODE[ARG2PTR],.RA,.BSYREGS)
		ELSE
		BEGIN
			RA_.RB;
			CNODE[A1SAMEFLG]_1;
		END
	END

	ELSE
	RA_REGTOUSE(.CNODE,.ARG1NODE,.CNODE[ARG2PTR],.RA,.BSYREGS);




	%(****SET UP THE TARGET FIELD OF CNODE***)%
	SETTARGINREG(.CNODE,.RA);


END;

GLOBAL ROUTINE GETRGPR(RA,BSYREGS)=
%(***************************************************************************
	ROUTINE TO RETURN THE NEXT AVAILABLE REGISTER SUCH THAT THE REGISTER FOLLOWIN
	THAT REGISTER IS ALSO AVAILABLE.
	USED FOR REGISTER ALLOCATION FOR OPERATIONS SUCH AS INTEGER DIVIDE,
	FIX, AND FLOAT WHICH CLOBBER THE REGISTER FOLLOWING THE REGISTER IN WHICH
	THE OPERATION IS PERFORMED.
	CALLED WITH THE ARG "RA" SET TO THE REG TO TRY FIRST, THE ARG "BSYREGS"
	SET TO INDICATE WHICH REGS ARE FREE
***************************************************************************)%
BEGIN
	OWN BSYRG1;
	BSYRG1_.BSYREGS;
	UNTIL NXREGFREE(.BSYREGS,.RA) 
	DO
	BEGIN
		BSYRG1_CLRBIT(.BSYRG1,.RA);

		%(***IF COULD NOT FIND ANY FREE PAIR OF REGS, THERE IS AN ERROR IN
			THE REGISTER ALLOCATOR*******)%
		IF .BSYRG1 EQL 0
		THEN
		BEGIN
			CGERR();
			RA_0;
			EXITLOOP;
		END;

		RA_FIRSTONE(.BSYRG1)
	END;

	RETURN .RA;
END;

GLOBAL ROUTINE ALCLIBFN(RA,BSYREGS,FREGCT)=
%(****************************************************************************
	TO PERFORM REGISTER ALLOCATION FOR THE ARGS OF AN ARITHMETIC OPERATION THAT IS PERFORMED
	BY A LIBRARY FUNCTION. (THESE INCLUSE DOUBLE-PRECISION OPS ON THE
	KA10 AND EXPONENTIATION).
	FOR SUCH OPERATIONS THE SECOND ARGUMENT SHOULD NEVER BE LEFT IN A
	REGISTER.
	CALLED WITH THE GLOBAL TREEPTR POINTING TO THE ARITHMETIC NODE WHOSE ARGS
	ARE TO BE PROCESSED.
****************************************************************************)%
BEGIN
	LOCAL PEXPRNODE CNODE:ARG2NODE;
	CNODE_.TREEPTR;
	ARG2NODE_.CNODE[ARG2PTR];


	%(***IF ARG2 IS A COMMON SUBEXPRESSION THAT WAS LEFT IN A REGISTER,
		IT MUST BE STORED IN A TEMPORARY BEFORE CALLING THE FUNCTION.
	****)%
	IF .CNODE[A2VALFLG]
	THEN
	BEGIN
		IF .ARG2NODE[OPRCLS] EQL CMNSUB
		THEN
		BEGIN
			IF .ARG2NODE[INREGFLG] AND NOT .ARG2NODE[STOREFLG]
			THEN
			BEGIN
				ARG2NODE[STOREFLG]_1;
				ARG2NODE[TARGTMEM]_NXTTMP(.ARG2NODE[DBLFLG]);
			END
		END
	END


	%(***IF ARG2 IS AN EXPRESSION WHICH MUST BE EVALUATED, EVALUATE IT INTO A TEMPORARY.
		ALWAYS EVALUATE ARG2 BEFORE ARG1****)%
	ELSE
	BEGIN
		CNODE[RVRSFLG]_1;
		TREEPTR_.ARG2NODE;
		ALCINTMP(NXTTMP(.TREEPTR[DBLFLG]),.BSYREGS,.FREGCT);
	END;

	%(***PERFORM REGISTER ALLOCATION TO GET ARG1 INTO RA***)%
	IF NOT .CNODE[A1VALFLG]
	THEN
	BEGIN
		TREEPTR_.CNODE[ARG1PTR];
		ALCINREG(.RA,.BSYREGS,.FREGCT);
	END;
END;


GLOBAL ROUTINE ALCARGS(RA,BSYREGS,FREGCT)=
%(***************************************************************************
	PERFORM REGISTER ALLOCATION FOR THE 2 ARGS OF A BINARY NODE POINTED TO
	BY THE GLOBAL "TREEPTR".
	CALLED WITH THE ARGS
		RA - REGISTER INTO WHICH THE 1ST ARG TO BE "COMPUTED
			INTO THE RESULT" SHOULD BE MOVED
		BSYREGS - BITS 0-15 OF THIS WD REPRESENT THE 16 REGS,
			A BIT IS 1 IFF THE CORRESP REG IS AVAIL FOR USE
		FREGCT - NUMBER OF FREE REGISTERS AVAILABLE
***************************************************************************)%
BEGIN
	LOCAL CLOBBR1;
	OWN BSYRG1,FRGCT1;
	REGISTER PEXPRNODE CNODE:ARG1NODE:ARG2NODE;
	LOCAL RB;
	OWN RSV;		!REG THAT MUST BE PRESERVED BECAUSE IT HOLDS THE
				! VAL OF THE ARG THAT WAS COMPUTED FIRST


	CNODE_.TREEPTR;
	ARG1NODE_.CNODE[ARG1PTR];
	ARG2NODE_.CNODE[ARG2PTR];


	IF .CNODE[A2VALFLG]
	THEN
	%(***IF ARG2 NEEDS NO EVALUATION, SIMPLY EVAL ARG1 INTO RA***)%
	BEGIN
		TREEPTR_.ARG1NODE;
		ALCINREG(.RA,.BSYREGS,.FREGCT);
		RETURN;
	END;

	IF .CNODE[A1VALFLG]
	THEN
	%(***IF ARG1 NEEDS NO EVALUATION, EVALUATE ARG2 INTO ANY REG EXCEPT RA (OR INTO A TMP)***)%
	BEGIN
		TREEPTR_.ARG2NODE;
		IF .CNODE[COMPLEXITY] LEQ .FREGCT
		THEN ALCINREG(FIRSTONE(CLRBIT(.BSYREGS,.RA)),.BSYREGS,.FREGCT)
		ELSE ALCINTMP(NXTTMP(.TREEPTR[DBLFLG]),.BSYREGS,.FREGCT);
		RETURN;
	END;



	%(***IF ARG1 IS LEFT IN THE FN-RETURN REGISTER AND THE PARENT NODE IS NOT (PRESUMABLY
		BECAUSE THERE IS ANOTHER FN CALL THAT WOULD CLOBBER IT) THEN
		IF ARG2 IS NOT LEFT IN THE FN RETURN REG AND IT IS POSSIBLE TO
		EXCHANGE THE 2 ARGS, DO SO***)%
	IF .ARG1NODE[ALCRETREGFLG] AND (NOT .ARG2NODE[ALCRETREGFLG]) AND (NOT .CNODE[ALCRETREGFLG])
	THEN
	BEGIN
		IF EXCHARGS(.CNODE)
		THEN
		BEGIN
			%(***IF HAVE EXCHANGED THE ARGS, MUST COMPLEMENT THE BIT THAT
				INDICATES WHICH TO EVALUATE FIRST***)%
			CNODE[RVRSFLG]_NOT .CNODE[RVRSFLG];

			%(***MUST RESET THE LOCAL VARS ARG1NODE AND ARG2NODE***)%
			ARG1NODE_.CNODE[ARG1PTR];
			ARG2NODE_.CNODE[ARG2PTR];
		END
	END;


	%(****IF BOTH SUBNODES REQUIRE COMPUTATION, PERFORM REGISTER ALLOCATION FOR THE
		2 COMPUTATIONS.
		IF THE FIRST SUBNODE COMPUTED HAS ITS VAL (OR A PTR
		TO IT VAL)  LEFT IN A REGISTER, THEN THAT
		REGISTER CANNOT BE USED IN COMPUTATION OF THE OTHER SUBNODE.
		(NOTE THAT EVEN IF A SUBNODE HAS BEEN DESIGNATED AS COMPUTED INTO "FN
		RETURN REG", MUST STILL DO ALLOCATION FOR SOME OF ITS SUBNODES)
	*************)%

	IF .CNODE[COMPLEXITY] LEQ .FREGCT
	THEN
	%(*****IF VAL OF THIS NODE CAN BE COMPUTED ENTIRELY IN REGS****)%
	BEGIN
		IF .CNODE[RVRSFLG]
		THEN
		%(***IF 2ND ARG IS EVALUATED BEFORE 1ST***)%
		BEGIN
			%(***IN COMPUTING ARG2 - DO NOT WANT TO LEAVE THEVAL OF ARG2
				IN RA IF CAN AVOID IT, SINCE WILL WANT TO COMPUTE
				THE 1ST ARG INTO RA SO THAT CAN THEN COMPUTE THE
				PARENT THERE***)%
			BSYRG1_CLRBIT(.BSYREGS,.RA);

			%(***ALSO, IF ARG1 IS AN OPERATION THAT CLOBBERS THE REG
				FOLLOWING THE REG USED, THEN IF POSSIBLE DONT
				USE THE REG AFTER RA***)%
			IF CLBNXREG(ARG1NODE)
			THEN
			BEGIN
				IF .FREGCT GTR 2
				THEN BSYRG1_CLRBIT(.BSYRG1,NXREG(.RA));
			END;

			RB_FIRSTONE(.BSYRG1);

			%(***PERFORM REGISTER ALLOC FOR COMPUTATION OF ARG2- TO LEAVE
				THE RESULT IN RB (WHERE RB NEQ RA)***)%
			TREEPTR_.ARG2NODE;
			ALCINREG(.RB,.BSYREGS,.FREGCT);

			%(***IN THE COMPUTATION OF ARG1, CANNOT USE THE REG WHICH
				MUST BE PRESERVED TO PRESERVE THE VAL OF ARG2***)%
			RSV_RGTOSAVE(.ARG2NODE);
			IF .RSV NEQ -1
			THEN
			%(***IF SOME REG MUST BE PRESERVED TO PRESERVE THE VAL OF ARG2,
				TAKE THAT REG OUT OF THE SET OF AVAILABLE REGS***)%
			(BSYREGS_CLRBIT(.BSYREGS,.RSV); FREGCT_.FREGCT-1);

			IF .RA EQL .RSV THEN RA_FIRSTONE(.BSYREGS);

			%(***PERFORM REGISTER ALLOCATION FOR ARG1***)%
			TREEPTR_.ARG1NODE;
			ALCINREG(.RA,.BSYREGS,.FREGCT);
		END

		ELSE
		%(****IF 1ST ARG IS EVALUATED BEFORE 2ND****)%
		BEGIN
			TREEPTR_.ARG1NODE;
			ALCINREG(.RA,.BSYREGS,FREGCT);

			%(***DETERMINE WHICH (IF ANY) REG MUST BE SAVED WHILE COMPUTING
				ARG2 BECAUSE IT HOLDS EITHER THE VAL OR A PTR TO THE
				VAL OF ARG1****)%
			RSV_RGTOSAVE(.ARG1NODE);
			IF .RSV NEQ -1
			THEN
			BEGIN
				BSYRG1_CLRBIT(.BSYREGS,.RSV);
				FRGCT1_.FREGCT-1;
			END
			ELSE
			BEGIN
				BSYRG1_.BSYREGS;
				FRGCT1_.FREGCT;
			END;

			TREEPTR_.ARG2NODE;
			ALCINREG(FIRSTONE(CLRBIT(.BSYRG1,.RA)),.BSYRG1,.FRGCT1);
		END;
	END

	ELSE
	%(*****IF VAL OF THIS NODE CANNOT BE COMPUTED ENTIRELY IN REGS****)%
	BEGIN
		IF .CNODE[RVRSFLG]
		THEN
		%(***IF ARG2 IS EVALUATED BEFORE ARG1***)%
		BEGIN
			TREEPTR_.ARG2NODE;
			ALCINTMP(NXTTMP(.TREEPTR[DBLFLG]),.BSYREGS,.FREGCT);
			TREEPTR_.ARG1NODE;
			ALCINREG(.RA,.BSYREGS,.FREGCT);
		END

		ELSE
		%(***IF ARG1 IS EVALUATED BEFORE ARG2***)%
		BEGIN
			TREEPTR_.ARG1NODE;
			IF .ARG2NODE[COMPLEXITY] GTR (.FREGCT-1)
			THEN
			%(***IF WILL NEED TO USE RA IN COMPUTING ARG2***)%
			BEGIN
				ALCINTMP(NXTTMP(.TREEPTR[DBLFLG]),.BSYREGS,.FREGCT);
				TREEPTR_.ARG2NODE;
				IF .ARG2NODE[EXITY] EQL .FREGCT
				THEN
				ALCINREG(FIRSTONE(CLRBIT(.BSYREGS,.RA)),.BSYREGS,.FREGCT)
				ELSE
				ALCINTMP(NXTTMP(.TREEPTR[DBLFLG]),.BSYREGS,.FREGCT);
			END

			ELSE
			%(***IF CAN COMPUTE ARG2 WITHOUT CLOBBERRING RA***)%
			BEGIN
				ALCINREG(.RA,.BSYREGS,.FREGCT);

				%(***DETERMINE WHICH (IF ANY) REG MUST BE SAVED WHILE COMPUTING
					ARG2 BECAUSE IT HOLDS EITHER THE VAL OR A PTR TO THE
					VAL OF ARG1****)%
				RSV_RGTOSAVE(.ARG1NODE);
				IF .RSV NEQ -1
				THEN
				BEGIN
					BSYRG1_CLRBIT(.BSYREGS,.RSV);
					FRGCT1_.FREGCT-1;
				END
				ELSE
				BEGIN
					BSYRG1_.BSYREGS;
					FRGCT1_.FREGCT;
				END;

				TREEPTR_.ARG2NODE;
				ALCINREG(FIRSTONE(CLRBIT(.BSYRG1,.RA)),.BSYRG1,.FRGCT1);
			END;

		END;
	END;

END;
GLOBAL ROUTINE ALCVBOOL(RA,BSYREGS,FREGCT)=
%(***************************************************************************
	TO PERFORM REGISTER ALLOCATION TO COMPUTE THE VALUE OF A BOOLEAN.
***************************************************************************)%
BEGIN
	LOCAL PEXPRNODE CNODE:ARG1NODE;
	LOCAL RV;				!REG INTO WHICH THE VAL OF THE BOOLEAN
						! WILL BE CALCULATED.

	%(****EQV AND XOR ARE HANDLED LIKE ARITHMETICS***)%
	IF .TREEPTR[BOOLCLS] NEQ ANDORCLS THEN ALCA(.RA,.BSYREGS,.FREGCT)

	ELSE
	%(***IF THIS EXPRESSION HAS VALTYPE "CONTROL" (BOTH ARGS ARE RELATIONALS
		OR BOOLEANS OF TYPE CONTROL), WILL ONLY COMPUTE A VAL FOR THE
		TOP LEVEL BOOLEAN NODE*****)%
	IF .TREEPTR[VALTYPE] EQL CONTROL THEN ALCCNB(.RA,.BSYREGS,.FREGCT)


	ELSE
	%(***IF ONE OF THE ARGS UNDER THIS NODE HAS TYPE CONTROL AND THE OTHER DOES NOT,
		THEN ARG2 WILL BE THE CONTROL ARG (COMPLEXITY  HAS SET THIS UP)
		IF NEITHER ARG HAS TYPE CONTROL, WILL HANDLE LIKE ARITHMETIC*****)%
	IF (OWN PEXPRNODE ARG2NODE;  ARG2NODE_.TREEPTR[ARG2PTR]; .ARG2NODE[VALTYPE] NEQ CONTROL)
	THEN ALCA(.RA,.BSYREGS,.FREGCT)


	ELSE
	%(****IF ARG1 IS A MASK (IE A NON-CONTROL EXPRESSION) AND ARG2 IS A CONTROL EXPR*****)%

	%(***IF HAVE ALREADY DETERMINED THAT VAL IS TO BE COMPUTED TO FN-RET-REG, THEN
		SIMPLY ALLOCATE THE 2 ARGS****)%
	IF .TREEPTR[ALCRETREGFLG] THEN ALCARGS(.RA,.BSYREGS,.FREGCT)


	ELSE
	%(****IF CANNOT COMPUTE THE WHOLE EXPRESSION ENTIRELY IN REGS, COMPUTE THE VAL
		OF THE BOOLEAN IN A TEMPORARY****)%
	IF .TREEPTR[COMPLEXITY] GTR .FREGCT THEN ALCTVBOOL(NXTTMP(),.BSYREGS,.FREGCT)

	ELSE
	%(***FOR A BOOLEAN WHERE ARG2 IS OF TYPE CONTROL, ARG1 IS A MASK.
		WILL COMPUTE ARG1 FIRST AND THEN USE THE REG CONTAINING ARG1 AS
		THE REG FOR THE VAL OF THE BOOLEAN*****)%
	BEGIN
		CNODE_.TREEPTR;
		ARG1NODE_.TREEPTR[ARG1PTR];

		%(***IF ARG1 IS A LEAF OR A COMMON SUBEXPR, GET A REG FOR COMP
			OF PARENT****)%
		IF .CNODE[A1VALFLG] THEN RV_REGTOUSE(.CNODE,.ARG1NODE,.CNODE[ARG2PTR],.RA,.BSYREGS)

		%(***OTHERWISE, USE THE REG INTO WHICH ARG1 WAS COMPUTED***)%
		ELSE
		BEGIN
			TREEPTR_.ARG1NODE;
			ALCINREG(.RA,.BSYREGS,.FREGCT);
			IF .ARG1NODE[INREGFLG] AND NOT .ARG1NODE[ALCRETREGFLG]
			THEN
			BEGIN
				RV_INVASNREG(.ARG1NODE[TARGTAC]);
				CNODE[A1SAMEFLG]_1;
			END
			ELSE RV_REGTOUSE(.CNODE,.ARG1NODE,.CNODE[ARG2PTR],.RA,.BSYREGS);
		END;

		SETTARGINREG(.CNODE,.RV);

		%(***PERFORM ALLOCATION FOR THE CONTROL ARG
			DO NOT USE REG THAT HOLDS VAL OF PARENT IN COMP OF ARG***)%
		TREEPTR_.CNODE[ARG2PTR];
		ALCNARG(CLRBIT(.BSYREGS,.RV),.FREGCT-1);
	END;
END;



GLOBAL ROUTINE ALCCNB(RA,BSYREGS,FREGCT) =
%(***************************************************************************
	PERFORM REGISTER ALLOCATION FOR A CONTROL-TYPE BOOLEAN
***************************************************************************)%
BEGIN
	IF .TREEPTR[ALCRETREGFLG]
	THEN
	BEGIN
		ALCCNT(.BSYREGS,.FREGCT);
		RETURN;
	END;

	IF .TREEPTR[COMPLEXITY] LEQ .FREGCT
	THEN
	%(***IF VAL CAN BE COMPUTED IN A REG***)%
	BEGIN
		SETTARGINREG(.TREEPTR,.RA);
		ALCCNT(CLRBIT(.BSYREGS,.RA),.FREGCT-1)
	END

	ELSE
	%(***IF NUMBER OF REGS NECESSARY TO COMPUTE VAL OF THIS NODE IS GREATER THAN NO AVAILABLE*)%
	BEGIN
		TREEPTR[TARGTMEM]_NXTTMP(FALSE);
		ALCCNT(.BSYREGS,.FREGCT);
	END;

END;

GLOBAL ROUTINE ALCCNT(BSYREGS,FREGCT) =

%(***************************************************************************
	ROUTINE TO PERFORM REGISTER ALLOCATION FOR A CONTROL-TYPE
	BOOLEAN.
	THE VALUES OF SUBNODES OF SUCH A NODE ARE NEVER ACTUALLY COMPUTED.
	CALLED WITH THE GLOBAL "TREEPTR" POINTING TO THE NODE TO BE
	PROCESSED, WITH THE ARG "BSYREGS" INDICATING WHICH REGS ARE 
	AVAILABLE.
***************************************************************************)%

BEGIN
	LOCAL PEXPRNODE CNODE;

	CNODE_.TREEPTR;

	%(*********FOR THE 1ST ARG****************************)%

	TREEPTR_.CNODE[ARG1PTR];
	ALCNARG(.BSYREGS,.FREGCT);

	%(*********FOR THE 2ND ARG************************)%
	TREEPTR_.CNODE[ARG2PTR];
	ALCNARG(.BSYREGS,.FREGCT);

END;




GLOBAL ROUTINE RGTOSAVE(CNODE)=
%(***************************************************************************
	ROUTINE TO DETERMINE WHICH REGISTER MUST BE PRESERVED SO THAT THE
	VAL CORRESPONDING TO A GIVEN EXPRESSION NODE WILL BE PRESERVED.
	IF THE EXPRESSION NODE IS AN ARRAYREF, THEN NEED TO PRESERVE THE REG 
	HOLDING AN INDEX INTO THE ARRAY, OTHERWISE MAY NEED TO PRESERVE
	A REG HOLDING THE VALUE OF AN EXPRESSION.
	THIS ROUTINE RETURNS THE INDEX OF THE REGISTER (NOT!!! THE ACTUAL
	NUMBER OF THE REG) IN THE SET OF REGS BEING USED. IT RETURNS
	-1 IF NO REG NEEDS TO BE PRESERVED.
***************************************************************************)%
BEGIN
	MAP PEXPRNODE CNODE;
	OWN SVAC;

	IF .CNODE[OPRCLS] EQL DATAOPR OR .CNODE[OPRCLS] EQL CMNSUB
	THEN
	RETURN -1;

	%(***IF THE VAL WAS LEFT IN THE FN RETURN REG, THEN HAVE NO
		REGS FROM THE USUAL POOL TO PRESERVE***)%
	IF .CNODE[ALCRETREGFLG] THEN RETURN -1;


	IF .CNODE[OPRCLS] EQL ARRAYREF
	THEN
	BEGIN
		IF .CNODE[TARGXF] EQL 0
		THEN RETURN -1
		ELSE SVAC_.CNODE[TARGXF];
	END

	ELSE
	BEGIN
		IF NOT .CNODE[INREGFLG]
		THEN RETURN -1
		ELSE SVAC_.CNODE[TARGTAC];
	END;

	RETURN INVASNREG(.SVAC);
END;

GLOBAL ROUTINE ALCNARG(BSYREGS,FREGCT) =
%(***************************************************************************
	ROUTINE TO PERFORM REGISTER ALLOCATION FOR ONE OF THE ARGS OF
	A CONTROL-TYPE BOOLEAN.
	SUCH AN ARG CAN ONLY BE EITHER A RELATIONAL OR ANOTHER CONTROL-TYPE
	BOOLEAN (BY DEFINITION).
	THE VALUE OF SUCH AN ARG WILL NEVER BE EXPLICITLY COMPUTED, HENCE
	"LOC OF VALUE" FIELD WILL ALWAYS BE LEFT EMPTY
***************************************************************************)%
BEGIN

	OWN PEXPRNODE ARG1NODE;

	IF .TREEPTR[OPRCLS] EQL RELATIONAL
	THEN
	%(*****IF THIS ARG IS A RELATIONAL******************)%
	BEGIN
		ARG1NODE_.TREEPTR[ARG1PTR];


		%(***PERFORM REGISTER ALLOCATION FOR THE COMPARISON***)%
		ALCRL1(.BSYREGS,.FREGCT);
		RETURN
	END;

	IF .TREEPTR[OPRCLS] EQL BOOLEAN
	THEN
	%(*****IF THIS ARG IS A BOOLEAN************)%
	ALCCNT(.BSYREGS,.FREGCT)

	ELSE
	%(*****AN ARG OF A CONTROL-TYPE BOOLEAN CAN ONLY BE A RELATIONAL
		OR A CONTROL-TYPE BOOLEAN (BY DEFINITION) *****)%
	CGERR(6);

END;






GLOBAL ROUTINE ALCFNARGS(BSYREGS,FREGCT,PARDBLFLG)=
%(***************************************************************************
	PERFORM REGISTER/TEMPORARY ALLOCATION FOR ALL ARGUMENTS OF
	A FUNCTION CALL.
	"PARDBLFLG" IS TRUE IFF THE FUNCTION-CALL NODE HAD A DOUBLE-WD
	VALTYPE (IF THE PARENT WAS A SUBROUTINE, PARDBLFLG IS ALWAYS
	FALSE).
	ALL ARGS MUST BE MATERIALIZED BEFORE THE FN IS CALLED.
	CALLED WITH THE GLOBAL TREEPTR POINTING TO THE ARGUMENT LIST
***************************************************************************)%
BEGIN
	LOCAL ARGUMENTLIST ARGLST;
	LOCAL BSYRG1;

	%(***ARGLIST PTR IS 0 IF THERE ARE NO ARGS***)%
	IF .TREEPTR EQL 0 THEN RETURN;

	%(***GET A LOCAL PTR TO THE ARG LIST (TREEPTR WILL BE CLOBBERRED AS WALK DOWN)***)%
	ARGLST_.TREEPTR;

	%(***REPEAT THE FOLLOWING FOR EACH ARGUMENT***)%
	INCR CT FROM 1 TO .ARGLST[ARGCOUNT] BY 1
	DO
	BEGIN
		%(***GET PTR TO EXPRESSION NODE FOR THIS ARG***)%
		TREEPTR_.ARGLST[.CT,ARGNPTR];

		%(***FOR A COMMON SUBEXPR- THE VAL MUST BE STORED IN A TEMP***)%
		IF .TREEPTR[OPRCLS] EQL CMNSUB 
		THEN
		BEGIN
			IF .TREEPTR[INREGFLG] AND NOT .TREEPTR[STOREFLG]
			THEN
			BEGIN
				TREEPTR[STOREFLG]_1;
				TREEPTR[TARGTMEM]_NXTTMP(.TREEPTR[DBLFLG]);
			END
		END

		ELSE
		IF .ARGLST[.CT,AVALFLG]
		THEN
		BEGIN
		END

		%(***FOR AN ARRAYREF, MUST GET PTR TO ELEM INTO A TMP***)%
		ELSE
		IF .TREEPTR[OPRCLS] EQL ARRAYREF
		THEN
		BEGIN
			%(***IF SUBSCRIPTS ARE ALL CONSTANTS, CAN SIMPLY PUT PTR TO ELEM
				INTO ARGLIST***)%
			IF .TREEPTR[ARG2PTR] NEQ 0
			%(******IF NOT, INSERT A "STORE-ADDRESS" NODE UNDER THE ARG-PTR,
				ABOVE THE ARRAYREF***)%
			THEN ARGLST[.CT,ARGNPTR]_ ALCTARY(.BSYREGS,.FREGCT)
		END


		ELSE
		BEGIN
			%(***IF THIS ARG INVOLVES A DOUBLE-PREC OR COMPLEX COMPUTATION,
				AND ARE NOT ALREADY ALLOCATING IN "DOUBLE-WD MODE",
				MUST CONVERT SET OF AVAILABLE REGS***)%
			IF .TREEPTR[DBLFLG] AND NOT .PARDBLFLG
			THEN
			BSYRG1_DPBSYREGS(.BSYREGS)

			%(***IF ARE OPERATING IN "DOUBLE-WD MODE" AND THIS ARG
				IS SINGLE-WD, CONVERT SET OF AVAILABLE REGS***)%
			ELSE
			IF .PARDBLFLG AND NOT .TREEPTR[DBLFLG]
			THEN BSYRG1_SPBSYREGS(.BSYREGS)

			ELSE
			BSYRG1_.BSYREGS;

			%(***PERFORM REG/TMP ALLOCATION FOR THIS ARG - TO GET ITS VAL
				INTO A TEMPORARY****)%
			ALCINTMP(NXTTMP(.TREEPTR[DBLFLG]),.BSYRG1,ONESCOUNT(.BSYRG1));
		END;

	END;

END;




GLOBAL ROUTINE ALCARRAY(RA,BSYREGS,FREGCT)=
%(***************************************************************************
	PERFORM REGISTER ALLOCATION FOR AN ARRAY REFERENCE
	FOR A FORMAL PARAM, THE ADDRESS WILL BE COMPUTED ENTIRELY INTO SOME REG
	FOR OTHER ARRAYS, THE OFFSET WILL BE COMPUTED INTO SOME REG AND
	THE BASE WILL BE RETRIEVED FROM THE SYMBOL TABLE BY THE OUTPUT MODULE
	CALLED WITH THE GLOBAL TREEPTR POINTING TO THE EXPRESSION NODE
	FOR THE ARRAY REFFERENCE
	RA IS A REGISTER TO USE TO HALD THE OFFSET IF ONE IS NEEDED
***************************************************************************)%
BEGIN
	REGISTER PEXPRNODE CNODE:ADDRNODE;
	OWN FRGCT1,BSYRG1;

	CNODE_.TREEPTR;
	ADDRNODE_.CNODE[ARG2PTR];		!2ND ARG UNDER AN ARRAYREF NODE IS
						! A PTR TO THE ADDRESS CALC TO BE PERFORMED

	%(***IF THE SS CALC IS ENTIRELY A CONSTANT (WHICH HAS ALREADY BEEN FOLDED INTO THE
		TARGET WD) - SIMPLY RETURN****)%
	IF .ADDRNODE EQL 0 THEN RETURN;

	%(***IF THIS ARRAY HAS DOUBLE-WD ENTRIES, THEN TO PERFORM THE ADDRESS ARITHMETIC WILL
		GO DOWN FROM DOUBLE-WD COMPUTATIONS TO SINGLE-WD COMPUTATIONS****)%
	IF .TREEPTR[DBLFLG]
	THEN
	BEGIN
		%(***ADJUST SET OF AVAILABLE REGS TO ONCE AGAIN INCLUDE ODD REGS
			(EXCEPT FOR THOSE ODD REGS HOLDING THE 2ND HALF OF A DP VAL)***)%
		BSYRG1_SPBSYREGS(.BSYREGS);
		FRGCT1_ONESCOUNT(.BSYRG1);

		%(***SINCE RA IS THE REG INTO WHICH WE WILL ULTIMATELY WANT
			TO LOAD THE VALUE CONTAINED IN THE ARRAY-LOC, DONT USE
			RA FOR THE INDEX IF IT CAN BE AVOIDED (SINCE CANT
			LOAD A DOUBLE-WD VAL WITHOUT CLOBBERING THE INDEX BEFORE ARE DONE)***)%
		IF .BSYREGS NEQ 0 THEN RA_FIRSTONE(.BSYREGS);
	END
	ELSE
	BEGIN
		BSYRG1_.BSYREGS;
		FRGCT1_.FREGCT;
	END;



	%(***PERFORM REGISTER ALLOCATION FOR THE ADDRESS CALCULATION***)%
	IF NOT .CNODE[A2VALFLG] 
	THEN
	BEGIN
		TREEPTR_.CNODE[ARG2PTR];
		ALCINREG(.RA,.BSYRG1,.FRGCT1);

		%(***IF HAVE ALREADY DETERMINED THAT THE INDEX SHOULD BE LEFT IN THE FN-RET
			REG, (IF SOME REG OTHER THAN 0 IS USED FOR FN-RET) THEN DONT
			CHANGE IT***)%
		IF .CNODE[ALCRETREGFLG]
		THEN BEGIN END

		ELSE

		%(***IF THE VARIABLE PART OF THE ADDR WAS CALCULATED INTO A
			REG OTHER THAN 0 AND OTHER THAN THE FN-RET REG, USE THAT REG
			AS THE INDEX***)%
		IF .ADDRNODE[INREGFLG] AND (.ADDRNODE[TARGTAC] NEQ 0) AND ( NOT .ADDRNODE[ALCRETREGFLG])
		THEN
		BEGIN
			CNODE[TARGXF]_.ADDRNODE[TARGTAC];
			CNODE[A2SAMEFLG]_1;
			RETURN
		END
	END

	ELSE
	IF .ADDRNODE[OPRCLS] EQL CMNSUB
	THEN
	BEGIN
		IF .ADDRNODE[INREGFLG] AND .ADDRNODE[TARGTAC] NEQ 0
			AND (NOT .CNODE[A2NEGFLG]) AND (NOT .CNODE[A2NOTFLG])
		THEN
		BEGIN
			CNODE[TARGXF]_.ADDRNODE[TARGTAC];
			CNODE[A2SAMEFLG]_1;
			RETURN
		END
	END
	ELSE
	IF (.ADDRNODE[OPRCLS] EQL REGCONTENTS) AND (.ADDRNODE[TARGTAC] NEQ 0)
		AND (NOT .CNODE[A2NEGFLG]) AND (NOT .CNODE[A2NOTFLG])
	THEN
	BEGIN
		CNODE[TARGXF]_.ADDRNODE[TARGTAC];
		CNODE[A2SAMEFLG]_1;
		RETURN;
	END;

	RA_RGTOU1(.CNODE,.ADDRNODE,.RA,.BSYREGS);
	CNODE[TARGXF]_ASNREG(.RA);
	CLOBBREGS_SETBIT(.CLOBBREGS,.RA);
	RETURN
END;





GLOBAL ROUTINE ALCTPCNV(RT,BSYREGS,FREGCT,TMPFLG)=
%(***************************************************************************
	PERFORM REGISTER ALLOCATION FOR A TYPE CONVERSION NODE.

	THIS ROUTINE IS USED BOTH FOR ALLOCATING RESULT TO A REG AND FOR ALLOCATING
	IT TO A TEMPORARY.
	THE FLAG "TMPFLG" IS TRUE IF RESULT IS TO BE ALLOCATED TO A TEMP.
	THE ARG RT IS A REG IF ALLOCATING TOA REG, A TEMP IF ALLOCATING TO 
	A TEMP.

	IF ARE GOING FROM DOUBLE-WD COMPUTATIONS DOWN TO SINGLE WD
	COMPUTATIONS, ODD REGISTERS CAN NOW BE ASSIGNED (EXCEPT OF COURSE FOR
	THOSE WHOSE PRECEEDING EVEN REG WAS ASSIGNED TO SOME DOUBLE-WD
	RESULT.
	IF ARE GOING FROM SINGLE-WD COMPUTATIONS DOWN TO DOUBLE-WD COMPUTATIONS
	(ONLY OCCURS WHEN EXPLICITLY INVOKED BY PROGRAM), ODD REGISTERS
	CAN NO LONGER BE ASSIGNED, NOR CAN EVEN REGS WHICH ARE  FOLLOWED
	BY AN ODD REG THAT IS IN USE.

	IN THIS ROUTINE, WE USE THE LOCALS BSYRG1 AND FRGCT1 TO INDICATE WHICH
	REGISTERS ARE AVAILABLE FOR USE IN THE COMPUTATION OF THE ARG UNDER
	THE TYPE-CONVERSION NODE. THE ARGS BSYREGS AND FREGCT INDICATE WHICH REGS
	ARE AVAILABLE FOR THE COMPUTATION OF THIS TYPE-CONVERSION NODE ITSELF.

	THE LOCAL RA INDICATES THE REG TO BE USED FOR COMPUTATION OF THE TYPE-CONVERSION,
	CALLED WITH THE GLOBAL TREEPTR POINTING TO THE TYPE CONVERSION NODE.
***************************************************************************)%
BEGIN
	LOCAL RA;			!REG TO BE USED
	LOCAL ARGREG;		!REG IN WHICH THE ARG WAS COMPUTED
	LOCAL PEXPRNODE ARGNODE;
	REGISTER PEXPRNODE CNODE;
	LOCAL BSYRG1;
	LOCAL FRGCT1;
	LOCAL SAVECLOBB;		!SAVE VAL THAT THE GLOBAL "CLOBBREGS" HAD ON
					! ENTERING THIS ROUTINE

	CNODE_.TREEPTR;
	ARGNODE_.CNODE[ARG2PTR];



	%(***INIT THE GLOBAL USED TO KEEP TRACK OF REGISTERS CLOBBERED TO 0, SAVE ITS ORIGINAL VAL,
		DO THIS IN ORDER TO TO ADJUST SET OF REGS CLOBBEREED WHEN NODES BELOW
		THIS NODE ARE DOUBLE-PREC AND THIS NODE IS SINGLE-PREC
	**********)%
	SAVECLOBB_.CLOBBREGS;
	CLOBBREGS_0;

	%(***INIT SET OF AVAILABLE REGS TO THOSE THAT WERE AVAILABLE ABOVE THIS NODE***)%
	BSYRG1_.BSYREGS;

	%(***IF CONVERSION IS FROM DOUBLE-WD TO SINGLE-WD AND HENCE ARE GOING
		DOWN FROM SINGLE-WD COMPUTATIONS TO DOUBLE-WD COMPUTATIONS****)%
	IF .CNODE[SDBLFLG] AND NOT .CNODE[DBLFLG]
	THEN
	%(**ADJUST SET OF AVAILABLE REGISTERS TO INCLUDE ONLY EVEN REGS***)%
	BSYRG1_DPBSYREGS(.BSYRG1);


	%(***IF CONVERSION IS FROM SINGLE-WD TO DOUBLE-WD AND ARE HENCE
		GOING DOWN FROM DOUBLE-WD COMPUTATIONS TO SINGLE-WD COMPUTATIONS****)%
	IF NOT .CNODE[SDBLFLG] AND .CNODE[DBLFLG]
	THEN
	%(***ADJUST SET OF AVAILABLE REGS TO INCLUDE ODD REGS AGAIN (EXCEPT
		FOR THOSE ODD REGS CONTAININD THE 2ND HALF OF A DP VAL TO BE SAVED)***)%
	BSYRG1_SPBSYREGS(.BSYRG1);

	%(***DETERMINE NUMBER OF REGS NOW AVAILABLE FOR USE***)%
	FRGCT1_ONESCOUNT(.BSYRG1);

	%(***SET RA TO INDICATE THE REG IN WHICH THE COMPUTATION
		OF THE TYPE CONVERSION  WILL TAKE
		PLACE (IF ARE ALLOCATING TO A REG IT WILL BE THAT REG IF POSSIBLE) ***)%
	IF .TMPFLG
	THEN
	RA_FIRSTONE(.BSYREGS AND .BSYRG1)	!IF ARE ALLOCATING TO A TMP, USE THE
						! FIRST REG THAT IS LEGAL FOR BOTH THE
						! OLD AND NEW VALUE TYPES
	ELSE
	IF BITSET(.BSYRG1,.RT)		!IF THE SPECIFIED DESTIN REG FOR
						! THE PARENT IS ALSO LEGAL FOR THE OLD
						! VALUE-TYPE, THEN USE THAT REG
	THEN
	RA_.RT
	ELSE
	RA_FIRSTONE(.BSYREGS AND .BSYRG1);	!OTHERWISE USE THE 1ST REG 
						! THAT IS LEGAL FOR BOTH THE OLD AND NEW
						! VALTYPES





	%(****PERFORM REGISTER ALLOCATION FOR NODES BELOW THIS NODE***)%

	TREEPTR_.ARGNODE;

	%(****IF NO ACTUAL CODE NEEDS TO BE GENERATED FOR THIS TYPE-CONVERSION (IE THE
		TYPE-CONVERSION NODE IS PRESENT ONLY TO KEEP TRACK OF THE WAY IN WHICH
		THE VALUE CORRESPONDING TO THE NODES BELOW IS TO BE USED),
		THEN THE "CONVERTED" VALUE SHOULD BE ACCESSED IN THE SAME
		WAY AS THE UNCONVERTED VALUE
	********)%
	IF NOCNV(CNODE)
	THEN
	BEGIN
		IF .CNODE[A2VALFLG] 
		THEN
		BEGIN
			%(***IF SUBNODE IS A SCALAR VARIABLE, THE ADDRESS FOR THE "CONVERTED"
				VARIABLE IS IDENTICAL TO THE ADDRESS OF THE ORIGINAL VAR***)%
			IF .ARGNODE[OPRCLS] EQL DATAOPR
			THEN
			CNODE[TARGADDR]_.ARGNODE[IDADDR]

			%(***IF SUBNODE IS A COMMON SUBEXPR, THE "CONVERTED" VALUE IS ACCESSED
				IN THE SAME WAY AS THE ORIGINAL VALUE***)%
			ELSE
			CNODE[TARGET]_.ARGNODE[TARGET];
		END

		%(***IF THE VALUE OF THE ARG MUST BE COMPUTED,  PERFORM REGISTER ALLOCATION FOR
			THAT COMPUTATION. THE ADDRESS CORRESPONDING TO THE "CONVERTED"
			VALUE IS IDENTICAL TO THE ADDRESS CORRESPONDING TO THE UNCONVERTED ONE***)%
		ELSE
		BEGIN
			IF .TMPFLG
			THEN
			ALCINTMP(.RT,.BSYRG1,.FRGCT1)
			ELSE
			BEGIN
				%(***IF THE ARGNODE WAS ALLOCATED TO THE FN RETURN REG,
					AND WE THEN FOUND THAT THAT REG WOULD BE CLOBBERED
					BEFORE THE RESULT WAS USED (AND HENCE DEALLOCATED THE
					CONVERTED VAL FROM THE RETREG), DEALLOCATE
					THE ARGNODE FROM THE RETREG ALSO***)%
				IF NOT .CNODE[ALCRETREGFLG] AND .ARGNODE[ALCRETREGFLG]
				THEN
				BEGIN
					ARGNODE[A1SAMEFLG]_0;
					ARGNODE[ALCRETREGFLG]_0;
					ARGNODE[INREGFLG]_0;
				END;
				ALCINREG(.RA,.BSYRG1,.FRGCT1);
			END;
			CNODE[TARGET]_.ARGNODE[TARGET];
		END;
	END


	%(****IF CODE MUST BE GENERATED TO PERFORM THE CONVERSION, THEN THE "UNCONVERTED"
		VALUE WILL HAVE TO BE LOADED INTO A REG TO CONVERT IT****)%
	ELSE
	BEGIN

		%(***ON THE KA10, THE OPERATIONS "FIX" AND "FLOAT" REQUIRE 2 ADJACENT
			REGISTERS. IF THESE OPS ARE TO BE PERFORMED, ADJUST "RA" TO
			BE A REG SUCH THAT THE REG AFTER IT IS FREEE.
		********)%
		IF .KA10FLG
		THEN
		BEGIN
			IF NOT .CNODE[DBLFLG] AND NOT .CNODE[SDBLFLG]
			THEN
			RA_GETRGPR(.RA,.BSYRG1)
		END;



		%(***IF ARG REQUIRES COMPUTATION, COMPUTE IT INTO RA IF POSSIBLE****)%
		IF NOT .CNODE[A2VALFLG]
		THEN
		BEGIN
			ALCINREG(.RA,.BSYRG1,.FRGCT1);

			%(***IF POSSIBLE, USE THE REG IN WHICH ARG WAS LEFT AS THE
				REG FOR COMPUTATION OF THE TYPE-CONVERSION***)%
			IF (.ARGNODE[INREGFLG]) AND (NOT .ARGNODE[ALCRETREGFLG])
			THEN
			RA_INVASNREG(.ARGNODE[TARGTAC]);

		END;

		%(***IF HAVE PREVIOUSLY ALLOCATED THE TYPE-CONVERSION TO BE DONE IN
			THE FN-RETURN REG, ARE DONE******)%
		IF NOT .CNODE[ALCRETREGFLG]
		THEN
		BEGIN


			%(***SET REG FOR COMPUTATION OF THE TYPE-CONVERSION TO RA IF 
				RA IS LEGAL TO USE, OTHERWISE TO SOME OTHER LEGAL REG***)%
			RA_RGTOU1(.CNODE,.ARGNODE,.RA,(.BSYREGS AND .BSYRG1));
			SETTAC(.CNODE,.RA);

			%(***IF THE TYPE CONVERSION IS BEING COMPUTED IN THE SAME REG AS ITS ARG***)%
			IF (.CNODE[TARGTAC] EQL .ARGNODE[TARGTAC]) AND .ARGNODE[INREGFLG]
			THEN CNODE[A2SAMEFLG]_1;

			%(***IF ARE ALLOCATING TO A TEMPORARY, SET "STOREFLG" TO INDICATE
				THAT THE VAL COMPUTED MUST BE STORED; SET LOC FOR VAL TO THE TMP****)%
			IF .TMPFLG
			THEN
			BEGIN
				CNODE[TARGTMEM]_.RT;
				CNODE[STOREFLG]_1;
			END

			%(***IF ARE ALLOCATING TO A REG, SET MEMREF FIELD TO INDICATE THAT
				THAT IS THE LOC OF THE VAL****)%
			ELSE
			BEGIN
				CNODE[TARGADDR]_.CNODE[TARGTAC];
				CNODE[INREGFLG]_1;
			END;
		END;

	END;


	%(****IF NODES UNDER THIS NODE ARE DOUBLE-PREC, THEN THEIR CALCULATION WILL
		CLOBBER THE ODD REG FOLLOWING EACH EVEN REG CLOBBERED.
		SET THESE BITS IN CLOBBREGS
	********)%
	IF .CNODE[SDBLFLG]
	THEN SETDPCLOBB;

	CLOBBREGS_.CLOBBREGS OR .SAVECLOBB;

END;






GLOBAL ROUTINE ALCNEGNOT(RA,BSYREGS,FREGCT)=
%(***************************************************************************
	TO PERFORM REG ALLOC FOR A NEG/NOT NODE
***************************************************************************)%
BEGIN
	LOCAL PEXPRNODE CNODE:ARGNODE;

	CNODE_.TREEPTR;
	ARGNODE_.TREEPTR[ARG2PTR];


	IF .CNODE[A2VALFLG]
	THEN
	BEGIN
		RA_RGTOU1(.CNODE,.ARGNODE,.RA,.BSYREGS);
		SETTARGINREG(.CNODE,.RA);
	END
	ELSE
	BEGIN
		TREEPTR_.CNODE[ARG2PTR];
		ALCINREG(.RA,.BSYREGS,.FREGCT);

		%(***DECIDE WHAT REG TO COMPUTE THE NEG/NOT IN***)%

		IF .CNODE[ALCRETREGFLG]
		%(***IF HAVE ALREADY DECIDED TO COMPUTE THE NEG/NOT IN THE FN-RET REG
			DONT CHANGE IT***)%
		THEN BEGIN END

		ELSE
		%(***IF THE ARG WAS LEFT IN A REG OTHER THAN THE FN-RET REG, USE THAT REG***)%
		IF .ARGNODE[INREGFLG] AND NOT .ARGNODE[ALCRETREGFLG]
		THEN
		BEGIN
			CNODE[TARGET]_.ARGNODE[TARGET];
			CNODE[A2SAMEFLG]_1;
		END
		ELSE
		BEGIN
			RA_RGTOU1(.CNODE,.ARGNODE,.RA,.BSYREGS);
			SETTARGINREG(.CNODE,.RA)
		END
	END
END;


GLOBAL ROUTINE ALCSPECOP(RA,BSYREGS,FREGCT)=
%(***************************************************************************
	PERFORM REGISTER ALLOCATION FOR THE SPECIAL OPERATIONS INTRODUCED
	BY PHASE 2 SKELETON.
	FOR P2MUL (POWER OF 2 MULTIPLY),P2DIV,SQROP,P4OP (RAISE TO POWER OF 4)
	 ALLOCATE ARG TO BE COMPUTED INTO REG TO BE USED FOR FINAL RESULT.
	FOR CUBOP AND P2PL1MUL ("POWER OF 2 PLUS 1" MULTIPLY) ALLOCATE ARG TO BE COMPUTED INTO
	SOME OTHER REG.
	CALLED WITH THE ARGS
		RA - REG INTO WHICH SHOULD ATTEMPT TO COMPUTE RESULT
		BSYREGS - INDICATES WHICH REGS ARE AVAILABLE
		FREGCT - CT OF AVAILABLE REGS
	CALLED WITH THE GLOBAL TREEPTR POINTING TO THE EXPRESSION NODE
		FOR WHICH ALLOCATION IS TO BE PERFORMED
***************************************************************************)%
BEGIN
	LOCAL PEXPRNODE CNODE:ARGNODE;
	LOCAL RB;

	CNODE_.TREEPTR;
	ARGNODE_.CNODE[ARG1PTR];

	IF .CNODE[A1VALFLG]
	THEN
	%(***IF ARG REQUIRES NO COMPUTATION, THEN OPERATIONS WILL
		ALL BE PERFORMED IN RA*************)%
	SETTARGINREG(.CNODE,.RA)
	ELSE
	%(***IF ARG MUST BE CALCULATED, PERFORM REGISTER ALLOCATION FOR THAT CALCULATION***)%
	BEGIN
		TREEPTR_.ARGNODE;
		IF .CNODE[OPERSP] EQL P2PL1OP OR .CNODE[OPERSP] EQL CUBOP
		THEN
		%(***FOR MULTIPLICATION BY POWER OF 2 PLUS 1 OR TO RAISE A VAL TO POWER OF 3***)%
		BEGIN
			RB_FIRSTONE(CLRBIT(.BSYREGS,.RA));
			ALCINREG(.RB,.BSYREGS,.FREGCT);

			%(***PICK OUT A REG TO USE FOR COMP OF VAL OF PARENT***)%
			RA_RGTOU1(.CNODE,.ARGNODE,.RA,.BSYREGS);

			%(***CANNOT COMPUTE THE VAL OF PARENT IN SAME REG AS ARG WAS LEFT IN***)%
			IF .ARGNODE[TARGTAC] NEQ ASNREG(.RA)
			THEN
			SETTARGINREG(.CNODE,.RA)
			ELSE
			SETTARGINREG(.CNODE,.RB)
		END

		ELSE
		%(***FOR P2MUL,P2DIV,SQROP(TO SQUARE A VAL), OR P4OP(RAISE VAL TO POWER OF 4)****)%
		BEGIN
			ALCINREG(.RA,.BSYREGS,.FREGCT);

			%(***IF HAVE ALREADY DECIDED TO COMPUTE THE P2MUL IN THE FN-RET
				REG, DONT CHANGE IT***)%
			IF .CNODE[ALCRETREGFLG]
			THEN BEGIN END

			ELSE
			%(***WANT TO COMPUTE VAL OF PARENT IN SAME REG AS ARG WAS
				COMPUTED IN IF POSSIBLE***)%
			IF .ARGNODE[INREGFLG] AND NOT .ARGNODE[ALCRETREGFLG]
			THEN
			BEGIN
				CNODE[TARGET]_.ARGNODE[TARGET];
				CNODE[A1SAMEFLG]_1;
			END
			ELSE
			BEGIN
				RA_RGTOU1(.CNODE,.ARGNODE,.RA,.BSYREGS);
				SETTARGINREG(.CNODE,.RA)
			END;
		END
	END
END;



GLOBAL ROUTINE ALCILF(RA,BSYREGS,FREGCT)=
%(***************************************************************************
	TO PERFORM REGISTER FOR AN "IN-LINE-FN" NODE.
	FOR ALL EXCEPT ABS AND IABS, USE ALCA.
	RVRSFLG IS NEVER SET IN THIS NODE..
***************************************************************************)%
BEGIN
	LOCAL PEXPRNODE CNODE:ARG1NODE;

	IF (.TREEPTR[OPERSP] EQL ABSFN)
	THEN
	BEGIN
		CNODE_.TREEPTR;
		ARG1NODE_.CNODE[ARG1PTR];
		IF NOT .CNODE[A1VALFLG]
		THEN
		BEGIN
			TREEPTR_.ARG1NODE;
			ALCINREG(.RA,.BSYREGS,.FREGCT);


			%(***IF HAVE DETERMINED (IN COMPLEXITY PASS) THAT SHOULD LEAVE
				VALUE OF THIS NODE IN THE FN-RET REG, DONT CHANGE IT***)%
			IF .CNODE[ALCRETREGFLG]
			THEN BEGIN END

			ELSE
			%(***IF  ARG1 WAS LEFT IN A REG OTHER THAN FN-RET REG
				 COMPUTE CNODE IN THAT REG***)%
			IF .ARG1NODE[INREGFLG] AND NOT .ARG1NODE[ALCRETREGFLG]
			THEN
			BEGIN
				CNODE[TARGTAC]_.ARG1NODE[TARGTAC];
				CNODE[TARGADDR]_.ARG1NODE[TARGTAC];
				CNODE[INREGFLG]_1;
				CNODE[A1SAMEFLG]_1;
			END
			ELSE
			BEGIN
				RA_RGTOU1(.CNODE,.ARG1NODE,.RA,.BSYREGS);
				SETTARGINREG(.CNODE,.RA)
			END;
		END
		ELSE
		BEGIN
			RA_RGTOU1(.CNODE,.ARG1NODE,.RA,.BSYREGS);
			SETTARGINREG(.CNODE,.RA)
		END;
	END
	ELSE
	ALCA(.RA,.BSYREGS,.FREGCT);
END;


GLOBAL ROUTINE ALCINTMP(TA,BSYREGS,FREGCT) =
%(***************************************************************************
	PERFORM REGISTER/TEMPORARY ALLOCATION FOR SUBNODES OF THE NODE POINTED TO BY
	THE GLOBAL "TREEPTR" SUCH THAT THE VALUE OF THAT NODE
	WILL BE LEFT IN THE MOMORY LOCATION INDICATED BY THE MEMREF FIELD  "TA"
	THE OTHER ARGS FOR THIS ROUTINE ARE:
	 "BSYREGS" -  HAS BITS 0-15 REPRESENTING THE 16 ACS
		THE BIT FOR A GIVEN AC IS 1 IF THAT AC IS AVAILABLE FOR USE
	"FREGCT" - NUMBER OF REGS AVAILABLE FOR USE
***************************************************************************)%

BEGIN
	LOCAL RB;
	LOCAL PEXPRNODE CNODE:ARGNODE;


	CNODE_.TREEPTR;


	CASE .TREEPTR[OPRCLS] OF SET

	%(****FOR A BOOLEAN OPERATOR***************)%
	BEGIN
		%(***EQV AND XOR ARE TREATED LIKE ARITH***)%
		IF .TREEPTR[BOOLCLS] NEQ ANDORCLS
		THEN
		ALCTA(.TA,.BSYREGS,.FREGCT)

		ELSE
		%(***FOR CONTROL-TYPE BOOLEANS, ALLOCATE VAL TO TA. ALLOC
			THE CONTROL PART IN SAME WAY AS DO WHEN VAL GOES TO REG***)%
		IF .TREEPTR[VALTYPE] EQL CONTROL
		THEN
		BEGIN
			ALCCNT(.BSYREGS,.FREGCT);
			CNODE[TARGTMEM]_.TA;
		END

		ELSE
		BEGIN
			ARGNODE_.TREEPTR[ARG2PTR];

			%(***IF THE 2ND ARG IS NOT OF TYPE CONTROL, THEN NEITHER ARG IS.
				TREAT LIKE ARITHMETIC. ***)%
			IF .ARGNODE[VALTYPE] NEQ CONTROL
			THEN ALCTA(.TA,.BSYREGS,.FREGCT)

			%(***IF 1ST ARG IS A MASK, 2ND ARG OF TYPE CONTROL***)%
			ELSE ALCTVBOOL(.TA,.BSYREGS,.FREGCT);
		END;

	END;

	%(****FOR A DATA REFERENCE - SHOULD RARELY GET HERE*****)%
	BEGIN END;

	%(****FOR RELATIONALS***************************************)%
	BEGIN

		%(****PERFORM REGISTER ALLOCATION FOR THE COMPARISON****)%
		ALCRL1(.BSYREGS,.FREGCT);
		CNODE[TARGTMEM]_.TA;
	END;


	%(*****FOR FUNCTION CALLS********************************)%
	BEGIN
		TREEPTR[TARGTMEM]_.TA;
		CNODE_.TREEPTR;
		TREEPTR[STOREFLG]_1;
		TREEPTR[TARGTAC]_RETREG;
		TREEPTR[INREGFLG]_0;
		TREEPTR_.TREEPTR[ARG2PTR];
		ALCFNARGS(.BSYREGS,.FREGCT,.CNODE[DBLFLG]);
	END;


	%(*****FOR ARITHMETIC EXPRESSIONS************************)%
	ALCTA(.TA,.BSYREGS,.FREGCT);

	%(*****FOR TYPE CONVERSION******************************)%
	BEGIN
		CNODE_.TREEPTR;
		ALCTPCNV(.TA,.BSYREGS,.FREGCT,TRUE);

		%(***IF THE VAL COULD BE ALLOCATED DIRECTLY TO A TMP, STORE IT IN TA***)%
		IF .CNODE[INREGFLG]
		THEN
		BEGIN
			CNODE[INREGFLG]_0;
			CNODE[STOREFLG]_1;
			CNODE[TARGTMEM]_.TA;
		END;
	END;

	%(******FOR AN ARRAY REFERENCE*******************)%
	%(********MUST INSERT A "STORE" NODE ABOVE THE ARRYAREF NODE, TO HOLD THE
		ADDRESS TA - SINCE THE TARGTMEM FIELD OF THE ARRAYREF NODE MUST
		HOLD THE ARRAY OFFSET**********)%
	BEGIN
		OWN PEXPRNODE PARNODE:STORENODE;
		PARNODE_.TREEPTR[PARENT];
		STORENODE_MAKPR1(.PARNODE,STORECLS,STARVAL,.TREEPTR[VALTYPE],0,.TREEPTR);
		STORENODE[TARGTMEM]_.TA;
		(IF .PARNODE[ARG1PTR] EQL .TREEPTR THEN PARNODE[ARG1PTR]
			ELSE PARNODE[ARG2PTR]) _ .STORENODE;
		ALCARRAY(FIRSTONE(.BSYREGS),.BSYREGS,.FREGCT);
		SETTAC(.STORENODE,RGTOU1(.STORENODE,.STORENODE[ARG2PTR],FIRSTONE(.BSYREGS),.BSYREGS));
	END;

	%(*****FOR COMMON SUBEXPRS - DONT WALK DOWN ON THEM***)%
	BEGIN END;

	%(****FOR NEG/NOT***************************************)%
	BEGIN
		ARGNODE_.CNODE[ARG2PTR];

		RB_FIRSTONE(.BSYREGS);

		%(***IF ARG UNDER THIS NODE IS COMPUTED INTO A REG, USE THAT REG, 
			OTHERWISE USE RB******)%
		IF .CNODE[A2VALFLG]
		THEN
		%(***FOR ARG A VARIABLE OR COMMON-SUBEXPR***)%
		SETTAC(.CNODE,.RB)
		ELSE
		BEGIN
			TREEPTR_.ARGNODE;
			ALCINREG(.RB,.BSYREGS,.FREGCT);
			IF .ARGNODE[INREGFLG]
			THEN
			BEGIN
				CNODE[TARGTAC]_.ARGNODE[TARGTAC];
				CNODE[A2SAMEFLG]_1;
			END
			ELSE
			BEGIN
				RB_RGTOU1(.CNODE,.ARGNODE,.RB,.BSYREGS);
				SETTAC(.CNODE,.RB)
			END
		END;

		%(***STORE THE VALUE INTO THE TMP*************)%
		CNODE[INREGFLG]_0;
		CNODE[TARGTMEM]_.TA;
		CNODE[STOREFLG]_1;
	END;

	%(***FOR SPECIAL OPS -
		 P2MUL,P2DIV,SQUARE,CUBE,... -  COMPUTE THE VALUE IN A REG, THEN STORE***)%
	BEGIN
		ALCINREG(FIRSTONE(.BSYREGS),.BSYREGS,.FREGCT);
		CNODE[INREGFLG]_0;
		CNODE[TARGTMEM]_.TA;
		CNODE[STOREFLG]_1;
	END;


	CGERR();				!FIELD-REF, NOT IN RELEASE 1
	CGERR();				!STORECLS: SHOULD NOT EXIST PRIOR TO
						! THIS PASS OVER THE TREE
	BEGIN  END;				!REGCONTENTS: SHOULD RARELY WALK DOWN HERE
	CGERR();				!LABOP: SHOULD NEVER WALK DOWN ON ONE
	CGERR();				!STATEMENT: SHOULD NOT OCCUR UNDER
						! AN EXPRESSION
	CGERR();				!IOLSCLS: SHOULD NOT OCCUR


	%(****FOR AN IN-LINE-FN:  COMPUTE THE VAL IN A REG, THEN STORE*****)%
	BEGIN
		ALCILF(FIRSTONE(.BSYREGS),.BSYREGS,.FREGCT);
		CNODE[INREGFLG]_0;
		CNODE[TARGTMEM]_.TA;
		CNODE[STOREFLG]_1;
	END;

	TES;

END;



GLOBAL ROUTINE ALCTVBOOL(TA,BSYREGS,FREGCT)=
%(***************************************************************************
	ROUTINE TO PERFORM REGISTER ALOCATION FOR  AN "AND" OR "OR" NODE  WHOSE VALUE IS TO BE
	COMPUTED INTO THE MEMORY LOCATION "TA", AND WHICH IS KNOWN TO HAVE ARG2
	OF TYPE CONTROL, AND ARG1 NOT OF TYPE CONTROL.
	THE VALUE OF ARG1 WILL BE COMPUTED AND STORED INTO TA, THEN ARG2 WILL BE EVALUATED
	AND IN THE CASE OF "AND", 0 WILL BE STORED INTO TA IF ARG2 IS FALSE,
	IN THE CASE OF "OR", 1 WILL BE STORED IF ARG2 IS TRUE
	TREEPTR POINTS TO THE PARENT NODE.
***************************************************************************)%
BEGIN
	LOCAL PEXPRNODE CNODE:ARG1NODE;
	LOCAL RA;

	%(***DEFINE MACRO TO USE SOME LEGAL REGISTER***)%
MACRO	USESOMEREG=
BEGIN
	RA_RGTOU1(.CNODE,.ARG1NODE,FIRSTONE(.BSYREGS),.BSYREGS);
	SETTAC(.CNODE,.RA);
END$;


	%(***DEFINE MACRO TO USE THE REG INTO WHICH ARG1 WAS COMPUTED (AND THEN
		STORE VAL INTO TA)***)%
MACRO	USEA1REG=
BEGIN
	CNODE[TARGTAC]_.ARG1NODE[TARGTAC];
	CNODE[A1SAMEFLG]_1;
END$;

	CNODE_.TREEPTR;
	ARG1NODE_.TREEPTR[ARG1PTR];

	%(***PERFORM REG ALLOC FOR ARG1******)%
	IF .CNODE[A1VALFLG] 
	THEN
	BEGIN
		%(***IF ARG IS A COMMON SUBEXPR OR REGCONTENTS, WILL JUST STORE IT INTO TA)%
		IF .ARG1NODE[INREGFLG]
		THEN
		USEA1REG
		%(***IF ARG IS IN MEMORY, WILL LOAD IT AND STORE IT INTO TA***)%
		ELSE
		USESOMEREG
	END
	ELSE
	BEGIN
		TREEPTR_.ARG1NODE;
		ALCINTMP(.TA,.BSYREGS,.FREGCT);
		IF .ARG1NODE[TARGTMEM] EQL .TA
		%(***IF ARG1 WAS COMPUTED INTO TA, WILL NOT NEED TO LOAD IT***)%
		THEN CNODE[A1SAMEFLG]_1
		ELSE
		%(**IF ARG1 WAS LEFT IN A REG, WILL STORE IT IN TA; IF NOT LOAD
			IT INTO A REG AND STORE IT INTO TA***)%
		IF  .ARG1NODE[INREGFLG]
		THEN
		USEA1REG
		ELSE
		USESOMEREG
	END;

	CNODE[TARGTMEM]_.TA;

	%(***PERFORM ALLOCATION FOR THE CONTROL-TYPE ARG***)%
	TREEPTR_.CNODE[ARG2PTR];
	ALCNARG(.BSYREGS,.FREGCT);
END;


GLOBAL ROUTINE ALCTA(TA,BSYREGS,FREGCT) = 
%(***************************************************************************
	PERFORM REGISTER/TEMPORARY ALLOCATION FOR A BINARY NODE POINTED TO
	BY THE GLOBAL TREEPTR
	THE OPERATOR ON THIS NODE IS ARITHMETIC OR BOOLEAN AND IS ALWAYS
	ONE THAT CAN BE PERFORMED TO MEMORY, ***EXCEPT*** FOR KI10 DOUBLE-WD OPERATIONS
	CALLED WITH THE ARGS
		TA - TEMPORARY INTO WHICH THE RESULT SHOULD BE COMPUTED
		BSYREGS - BITS 0-15 OF THIS WD REPRESENT THE 16 REGS,
			A BIT IS 1 IFF THE CORRESP REG IS AVAIL FOR USE
***************************************************************************)%

BEGIN
	FORWARD USEARGREG;
	REGISTER PEXPRNODE CNODE;
	REGISTER PEXPRNODE ARG1NODE;
	LOCAL PEXPRNODE ARG2NODE;
	LOCAL RA;					!REGISTER TO BE USED IN THE
							!COMPUTATION OF THE VAL OF THIS NODE

	OWN CMPLX1,CMPLX2;				!NUMBER OF REGS NECESSARY TO
							! EVALUATE ARG1, ARG2




	ROUTINE USESOMEREG(BSYREGS)=
	%(******************************
		LOCAL ROUTINE TO USE SOME LEGAL REGISTER.
		DETERMINE REG TO USE AND THEN SET TARGET AC TO THAT REG AND
		SET THE BIT IN CLOBBREGS FOR THAT REG.
	********************************)%
	BEGIN
		OWN RA;

		%(***IF FN-RET REG WAS ALREADY ASSIGNED, DONT DO ANYTHING***)%
		IF .CNODE[ALCRETREGFLG]
		THEN BEGIN END
		ELSE
		BEGIN
			%(***GET A REG THAT CAN BE USED***)%
			RA_REGTOUSE(.CNODE,.ARG1NODE,.CNODE[ARG2PTR],FIRSTONE(.BSYREGS),.BSYREGS);

			%(***SET REG FOR COMP OF CNODE TO RA***)%
			SETTAC(.CNODE,.RA);
		END
	END;

	ROUTINE USEARGREG(RA,BSYREGS)=
	%(**********************************************************
		LOCAL ROUTINE TO SET THE REG FOR COMPUTATION OF CNODE
		TO THE REG INTO WHICH ARG1 WAS COMPUTED IF POSSIBLE.
	***********************************************************)%
	BEGIN
		%(***IF THIS NODE WAS ALREADY ALLOCATED TO FN RET REG, DO NOT CHANGE IT***)%
		IF .CNODE[ALCRETREGFLG]
		THEN RETURN;


		%(***IF CAN USE THE REG CONTAINING ARG1, DO SO***)%
		IF .ARG1NODE[INREGFLG] AND NOT .ARG1NODE[ALCRETREGFLG]
		THEN
		RA_INVASNREG(.ARG1NODE[TARGTAC]);

		%(***USE RA IF ITS LEGAL FOR THIS OPERATION, IF NOT USE SOME OTHER LEGAL REG***)%
		RA_REGTOUSE(.CNODE,.CNODE[ARG1PTR],.CNODE[ARG2PTR],.RA,.BSYREGS);
		SETTAC(.CNODE,.RA);

		%(***IF WERE ABLE TO USE THE REG IN WHICH ARG1 WAS LEFT, SET A1SAMEFLG***)%
		IF (.CNODE[TARGTAC] EQL .ARG1NODE[TARGTAC]) AND .ARG1NODE[INREGFLG]
		THEN CNODE[A1SAMEFLG]_1;

	END;



	CNODE_.TREEPTR;
	RA_FIRSTONE(.BSYREGS);
	IF .RA LSS 0 THEN CGERR(40);		!SHOULD NEVER GET HERE WITH NO FREE REGS




	%(****IF THE VALUE OF THIS NODE CAN BE COMPUTED IN THE NUMBER OF REGS AVAILABLE, DO
		SO AND THEN STORE THE VALUE INTO TA
		ALSO - FOR DOUBLE WD OPS ON THE KI10, COMPUTE AND THEN STORE****)%
	IF .CNODE[COMPLEXITY] LEQ .FREGCT
		OR (.CNODE[VALTYPE] EQL DOUBLPREC AND NOT .KA10FLG)
		OR (.CNODE[OPERSP] EQL EXPONOP)
	THEN
	BEGIN
		ALCA(.RA,.BSYREGS,.FREGCT);
		CNODE[INREGFLG]_0;
		CNODE[STOREFLG]_1;
		CNODE[TARGTMEM]_.TA;
		RETURN
	END;


	ARG1NODE_.CNODE[ARG1PTR];
	ARG2NODE_.CNODE[ARG2PTR];


	%(****WANT TO PERFORM THE OPERATION ON THIS NODE TO MEMORY - THEREFORE ARG2 SHOULD
		BE COMPUTED INTO TA, ARG1 INTO RA. *****)%



	%(***IF ARG2 NEEDS NO EVALUATION, SIMPLY EVAL ARG1 INTO RA***)%
	%(****THEN COMPUTE VAL OF PARENT IN RA AND STORE IN TA**********)%
	IF .CNODE[A2VALFLG]
	THEN
	BEGIN
		TREEPTR_.ARG1NODE;
		ALCINREG(.RA,.BSYREGS,.FREGCT);

		%(***SET REG FOR COMP OF CNODE TO REG WHERE VAL OF ARG1 WAS LEFT***)%
		USEARGREG(.RA,.BSYREGS);

		CNODE[STOREFLG]_1;
	END

	ELSE
	%(***IF ARG1 NEEDS NO EVALUATION, EVALUATE ARG2 INTO TA****)%
	IF .CNODE[A1VALFLG]
	THEN
	BEGIN
		TREEPTR_.ARG2NODE;
		ALCINTMP(.TA,.BSYREGS,.FREGCT);

		%(***GET A REG FOR COMP OF THIS NODE***)%
		USESOMEREG(.BSYREGS);
	END



	ELSE
	%(****IF BOTH SUBNODES REQUIRE COMPUTATION, PERFORM REGISTER ALLOCATION FOR THE
		2 COMPUTATIONS.
		IF THE FIRST SUBNODE COMPUTED HAS ITS VAL LEFT IN A REGISTER, THEN THAT
		REGISTER CANNOT BE USED IN COMPUTATION OF THE OTHER SUBNODE.
		(NOTE THAT EVEN IF A SUBNODE HAS BEEN DESIGNATED AS COMPUTED INTO "FN
		RETURN REG", MUST STILL DO ALLOCATION FOR SOME OF ITS SUBNODES)
	*************)%

	IF .CNODE[RVRSFLG]
	THEN
	%(****IF ARG2 IS COMPUTED BEFORE ARG1****)%
	BEGIN
		TREEPTR_.ARG2NODE;
		ALCINTMP(.TA,.BSYREGS,.FREGCT);
		TREEPTR_.ARG1NODE;
		ALCINREG(.RA,.BSYREGS,.FREGCT);

		%(***SET REG FOR COMP OF CNODE TO REG WHERE VAL OF ARG1 WAS LEFT (IF CAN)***)%
		USEARGREG(.RA,.BSYREGS);
	END

	ELSE
	%(***IF ARG1 IS EVALUATED BEFORE ARG2***)%
	BEGIN
		TREEPTR_.ARG1NODE;
		IF .ARG2NODE[COMPLEXITY] GTR (.FREGCT-1)
		THEN
		%(***IF WILL NEED TO USE RA IN COMPUTING ARG2***)%
		BEGIN
			ALCINTMP(NXTTMP(.TREEPTR[DBLFLG]),.BSYREGS,.FREGCT);
			TREEPTR_.ARG2NODE;
			IF .ARG2NODE[COMPLEXITY] EQL .FREGCT
			THEN
			BEGIN
				ALCINREG(FIRSTONE(CLRBIT(.BSYREGS,.RA)),.BSYREGS,.FREGCT);
				CNODE[STOREFLG]_1;
			END

			ELSE
			ALCINTMP(.TA,.BSYREGS,.FREGCT);

			USESOMEREG(.BSYREGS)
		END

		ELSE
		%(***IF CAN COMPUTE ARG2 WITHOUT CLOBBERRING RA***)%
		BEGIN
			LOCAL BSYRG1;
			ALCINREG(.RA,.BSYREGS,.FREGCT);

			%(***IF ARG1 WAS LEFT IN A REG, DO NOT USE THAT REG IN THE COMP OF ARG2**)%
			IF .ARG1NODE[INREGFLG]
			THEN
			BSYRG1_CLRBIT(.BSYREGS,INVASNREG(.ARG1NODE[TARGTAC]))
			ELSE
			BSYRG1_.BSYREGS;

			TREEPTR_.ARG2NODE;
			ALCINREG(FIRSTONE(.BSYRG1),.BSYRG1,ONESCOUNT(.BSYRG1));

			%(***SET REG FOR COMP OF CNODE TO REG WHERE VAL OF ARG1 WAS LEFT (IF CAN)***)%
			USEARGREG(.RA,.BSYREGS);
			CNODE[STOREFLG]_1;
		END;

	END;


	IF .ARG2NODE[TARGTMEM] EQL .TA
	THEN
	BEGIN
		CNODE[A2SAMEFLG]_1;
		CNODE[MEMCMPFLG]_1;
	END;

	CNODE[TARGTMEM]_.TA;
	RETURN;


END;


GLOBAL ROUTINE ALCTARY(BSYREGS,FREGCT)=
%(***************************************************************************
	ROUTINE TO ALLOCATE AN ARRAYREF NODE SO THAT THE ADDRESS WILL
	BE COMPUTED AND STORED IN A TEMPORARY (WHICH WILL LATER BE USED AS
	A PTR).
	THIS ROUTINE WILL INTRODUCE A "STARADDR" (OPRCLS=STORECLS, OPERSP=STARADDR)
	NODE INTO THE TREE ABOVE THE ARRAYREF NODE, HOWEVER IT WILL NOT ACTUALLY 
	LINK THE NEW NODE IN UNDER THE PARENT OF THE ARRAYREF. INSTEAD IT WILL
	RETURN A PTR TO THE NEW NODE AND THE LINKING MUST BE COMPLETED BY THE
	ROUTINE THAT CALLED IT. (THIS IS NECESSARY BECAUSE IN SOME CASES
	THE ARRAYREF WAS IN AN ARGUMENT LIST OR AN IOLIST).

	THE INDIRECT BIT WILL BE SET IN THE TARGET WORD OF THE STOREADDR
	NODE SO THAT REFERENCES TO THIS ELEMENT WILL BE MADE INDIRECT.
***************************************************************************)%
BEGIN
	LOCAL PEXPRNODE CNODE:STORENODE;
	LOCAL RA;		!REG TO USE IN GETTING THE ADDR


	CNODE_.TREEPTR;

	%(***PERFORM REGISTER ALLOCATION FOR THE ARRAYREF NODE***)%
	ALCARRAY(FIRSTONE(.BSYREGS),.BSYREGS,.FREGCT);

	%(***IF THE ADDRESS IS A COMPILE-TIME CONSTANT (AND HENCE REFERENCING IT DOES
		NOT DEPEND ON THE CONTENTS OF SOME REG BEING PRESERVED), NEED NOT DO ANYTHING SPECIAL***)%
	IF .CNODE[TARGXF] EQL 0
	THEN
	RETURN .CNODE;


	%(***PUT A "STARADDR" NODE ABOVE THE ARRAYREF NODE***)%
	STORENODE_MAKPR1(.CNODE[PARENT],STORECLS,STARADDR,.CNODE[VALTYPE],0,.CNODE);

	%(***DETERMINE WHAT REG TO USE TO LOAD THE ADDR - USE THE SAME REG THAT
		HOLDS THE PARTIAL ADDR (WITHOUT CONSTANT OFFSET) IF POSSIBLE***)%
	RA_INVASNREG(.CNODE[TARGXF]);
	IF NOT BITSET(.BSYREGS,.RA) THEN ( RA_FIRSTONE(.BSYREGS); CLOBBREGS_SETBIT(.CLOBBREGS,.RA));
	STORENODE[TARGTAC]_ASNREG(.RA);

	%(***IF THERE IS NO CONSTANT PORTION OF THE ADDRESS TO ADD IN TO THE
		VARIABLE PORTION, SET A2SAMEFLG ****)%
	IF (.CNODE[TARGADDR] EQL 0) AND (.CNODE[TARGXF] EQL .STORENODE[TARGTAC])
		AND (.CNODE[FORMLFLG])		!UNLESS THE ARRAY IS A FORMAL, WILL
						! HAVE TO  ADD IN THE BASE EVEN IF
						! ITS **REALTIVE** ADDRESS IS 0
	THEN
	STORENODE[A2SAMEFLG]_1;

	%(***SET UP TARGET WD OF THE STOREADDR NODE - WILL REFERENCE THIS
		ITEM INDIRECT THRU A TEMPORARY THAT HOLDS THE PTR***)%
	STORENODE[TARGADDR]_NXTTMP(FALSE);
	STORENODE[TARGIF]_1;

	RETURN .STORENODE;

END;


GLOBAL ROUTINE REGTOUSE(PNODE,ARG1NODE,ARG2NODE,RA,BSYREGS)=
%(***************************************************************************
	ROUTINE TO DECIDE WHICH REGISTER TO USE FOR COMPUTATION OF
	A BINARY NODE WHEN DO NOT HAVE THE 1ST ARG IN A REG THAT CAN BE USED.
	IF POSSIBLE WILL WANT TO USE THE REG RA (BECAUSE IT IS THE REG TO WHICH
	THE COMPUTATION WAS "TARGETED") - BUT CANNOT USE RA IF
		1.ARG2 WAS LEFT IN RA
		2.ARG1 IS A DOUBLE-PRECISION ARRAYREF AND THE INDEX WAS LEFT
			IN RA
		3.IF THE OPERATION CLOBBERS THE REGISTER AFTER THE ONE IN WHICH
			IT IS BEING PERFORMED AND THE REG AFTER RA CONTAINS
			A VALUE THAT NEEDS TO BE PRESERVED
***************************************************************************)%
BEGIN
	MAP PEXPRNODE PNODE:ARG1NODE:ARG2NODE;
	OWN BSYRG1;				!SET OF REGS THAT CAN BE
						! USED FOR PERFORMING THIS OPERATION
	OWN RB;

	%(***WHEN IN DEBUG MODE- CHECK THAT BSYREGS IS NON-ZERO***)%
	IF DEBUGFLG
	THEN
	(IF .BSYREGS EQL 0 THEN CGERR());


	BSYRG1_.BSYREGS;
	%(***IF ARG1 IS ACCESSED OFF OF AN INDEX REGISTER (IT COULD BE EITHER
		AN ARRAYREF NODE OR A TYPE-CONVERSION NODE THAT DOESNT DO ANYTHING)
		AND ARG1 IS DOUBLE-WORD, CANT USE THAT REGISTER***)%
	IF .ARG1NODE[DBLFLG] AND (.ARG1NODE[TARGXF] NEQ 0)
	THEN
	BSYRG1_CLRBIT(.BSYRG1,INVASNREG(.ARG1NODE[TARGXF]) );


	%(***IF NEED TO PRESERVE SOME REG TO ACCESS THE VAL OF ARG2, MUST NOT USE
		THAT REG***)%
	IF (RB_RGTOSAVE(.ARG2NODE)) NEQ -1
	THEN BSYRG1_CLRBIT(.BSYRG1,.RB);

	%(***IF RA IS NOW NOT IN THE SET OF REGS AVAILABLE FOR USE, GET A NEW REG
		TO USE***)%
	IF NOT BITSET(.BSYRG1,.RA) THEN (IF .BSYRG1 EQL 0 THEN CGERR();  RA_FIRSTONE(.BSYRG1));

	%(***IF THIS OPERATION CLOBBERS THE NEXT REG AFTER THE ONE USED, CHECK
		THAT THE REG AFTER RA IS FREE (NOTE HOWEVER THAT THE REG AFTER
		RA DOES NOT HAVE THE SAME RESTRICTIONS ON IT AS RA DOES -HENCE
		CAN COMPARE WITH "BSYREGS" RATHER THAN "BSYRG1"***)%
	IF CLBNXREG(PNODE) AND (NOT NXREGFREE(.BSYREGS,.RA))
	THEN RA_GETRGPR(.RA,.BSYRG1);

	RETURN .RA
END;

GLOBAL ROUTINE RGTOU1(PNODE,ARGNODE,RA,BSYREGS)=
%(***************************************************************************
	ROUTINE TO DECIDE WHICH REGISTER TO USE FOR A UNARY NODE WHEN THE
	ARG WAS NOT LEFT IN A REG THAT CAN BE USED FOR COMPUTATION OF THE
	PARENT. IF POSSIBLE WANT TO USE THE REG "RA".
***************************************************************************)%
BEGIN
	MAP PEXPRNODE PNODE:ARGNODE;
	OWN BSYRG1,RB;

	%(***WHEN IN DEBUG MODE- CHECK THAT BSYREGS IS NON-ZERO***)%
	IF DEBUGFLG
	THEN
	(IF .BSYREGS EQL 0 THEN CGERR());

	%(**FIRST, MUST CHECK THAT RA IS IN THE SET OF REGS INDICATED BY BSYREGS (ALCTPCNV
		COUNTS ON THIS BEING DONE HERE)***)%
	IF NOT BITSET (.BSYREGS,.RA) THEN RA_FIRSTONE(.BSYREGS);


	BSYRG1_.BSYREGS;



	%(***IF THE ARG IS ACCESSED BY USING AN INDEX REGISTER AND IT IS DOUBLE-WD
		THEN THAT INDEX REG CANNOT BE USED FOR COMPUTATION OF THE PARENT NODE***)%
	IF (.ARGNODE[DBLFLG]) AND (.ARGNODE[TARGXF] NEQ 0)
	THEN
	BEGIN
		BSYRG1_CLRBIT(.BSYRG1,(RB_INVASNREG(.ARGNODE[TARGXF])));
		IF .RA EQL .RB
		THEN
		BEGIN
			IF .BSYRG1 EQL 0 THEN CGERR();
			RA_FIRSTONE(.BSYRG1);
		END;
	END;

	%(***IF THIS OP CLOBBERS THE REG AFTER THE ONE ON WHICH IT IS PERFORMED***)%
	IF CLBNXREG(PNODE) AND NOT NXREGFREE(.BSYREGS,.RA) THEN RA_GETRGPR(.RA,.BSYRG1);

	RETURN .RA
END;



GLOBAL ROUTINE SETTARGINREG(CNODE,RA)=
%(***************************************************************************
	TO SET THE TARGET OF A NODE TO INDICATE THAT THE VALUE WILL
	LIVE IN THE REGISTER "RA"
***************************************************************************)%
BEGIN
	MAP PEXPRNODE CNODE;
	CNODE[TARGTAC]_ASNREG(.RA);
	CNODE[TARGADDR]_.CNODE[TARGTAC];
	CNODE[INREGFLG]_1;

	%(***SET BITS IN "CLOBBREGS" INDICATING REGISTERS CLOBBERED BY THIS OPERATION***)%
	CLOBBREGS_SETBIT(.CLOBBREGS,.RA);
	IF CLBNXREG(CNODE) THEN CLOBBREGS_SETBIT(.CLOBBREGS,NXREG(.RA));
END;


GLOBAL ROUTINE SETTAC(CNODE,RA)=
%(***************************************************************************
	TO SET THE TARGET AC FIELD OF A NODE TO THE REG RA (WHEN
	THE "TARGADDR" WILL BE SOME OTHER LOC)
***************************************************************************)%
BEGIN
	MAP PEXPRNODE CNODE;
	CNODE[TARGTAC]_ASNREG(.RA);

	%(***SET BITS IN "CLOBBREGS" INDICATING REGISTERS CLOBBERED BY THIS OPERATION***)%
	CLOBBREGS_SETBIT(.CLOBBREGS,.RA);
	IF CLBNXREG(CNODE) THEN CLOBBREGS_SETBIT(.CLOBBREGS,NXREG(.RA));
END;
    LuZ0