TITLE UMOUNT - USER HALF OF MOUNT, DISMOUNT, & FILE COMMAND V.21
;COPYRIGHT 1972, DIGITAL EQUIPMENT CORP., MAYNARD, MASS.
SUBTTL D BLACK 30-OCT-72
VUMOUN==XWD 2100,27


IFNDEF PURESW,<PURESW==1>	;NON-ZERO MAKES REENTRANT SHARABLE
IFNDEF MNTSW,<MNTSW==1>		;NON-ZERO INCLUDES MOUNT STUFF
IFNDEF VIDSW,<VIDSW==0>		;NON-ZERO REQUIRES /VID  SWITCH FOR MOUNTING
				;  NON-STRUCTURE DEVICES
IFNDEF WLSW,<WLSW==0>		;NON-ZERO MAKES WRITE LOCK DEFAULT CONDITION
				;  FOR ALL MOUNT REQUEST


IFNDEF DBUGSW,<DBUGSW==0>	;NON-ZERO FOR DEBUGGING
IFNDEF JACTSW,<JACTSW==1>	;NON-ZERO TO REQUIRE SENSITIVE PARTS TO
				;RUN UNDER JACCT (SHOULD=0 ONLY FOR DEBUGGING

EXTERN JOBFF,JOBREL,JOBSA,JOBDDT

MLON

JOBVER==137

LOC JOBVER
EXP VUMOUN

;-------STORAGE ZZCROS
IFN PURESW,<
TWOSEG
RELOC	0
RELOC	400000

DEFINE	UU(A,B)<
RELOC
A:	BLOCK	B
RELOC
>

> ;IFN PURESW

IFE PURESW,<
RELOC

DEFINE UU(A,B)<
A:	BLOCK	B
>

> ;IFE PURESW

DEFINE	U(A)<UU(A,1)>
;AC'S
F=0
A=1
B=2
C=3
D=4
E=5

NUM=7
IO=10
M=11
N=12
N1=13
BP=14
CH=15
WD=16
P=17

;I/O CHANNELS

CMD==1		;WRITE COMMAND FILE TO OPR
USR==2		;TEMP
CMU==3		;READ DIRECTORY OF COMMAND AREA
TTY==4		;USER'S TTY
US1==5		;TEMP

;SPECIAL CHARACTERS

CHRLIN=="-"	;FOR LINE CONTINUE

VIDMAX==^D25	;MAX # CHAR.S IN /VID SWITCH
VIDCH1=="'"	;OPENING DELIMITER FOR VID STRINGS
VIDCH2=="'"	;CLOSING ....
CMDSTX==SIXBIT/DSK/	;DEFAULT 3,3 AREA
CMDPPX==3,,3
STLSTX==SIXBIT/SYS/	;WHERE TO FIND STRLST?SYS
STLPPX==0

;SPECIAL NAMES

SYSFIL==SIXBIT/OPRFIL/	;PROG.NAME OF OMOUNT DOING FILE COMMANDS
SYSMOU==SIXBIT/OPRMNT/	;... DOING MOUNT/DISMOUNT COMMANDS
SYSOMO==SIXBIT/OPROMO/	;... DOING BOTH

;MISC VALUES AND BITS

FILSLP==^D15	;SEC'S TO SLEEP ON 'FILE W' (IF NO HIBER)
MOUSLP==^D15	;SEC'S TO SLEEP ON MOUNT/DISMOUNT (IF NO HIBER)
DTDNFI==^D22		;MAX NUMBER OF FILES ON A DECTAPE
CNTRLC==3		;ASCII FOR CONTROL C
ALTMO==33		;ASCII FOR ALTMODE
;CALLI ARGUMENTS

CI.RES==0		;RESET
CI.EXI==12		;EXIT
CI.CTM==22		;TIME OF DAY IN CLOCK TICKS
CI.PJO==30		;GET JOB NUMBER
CI.GTL==34		;GET PHYSICAL NAME OF USER'S TTY
	CNFTBL==11	;CONFIGURATION TABLE
	SEGPTR==15	;INDEX FOR SEGS, JOBS
	PRJPRG==2	;PRJPRG TABLE
	JBTPRG==3	;JBTPRG TABLE
	JBTSTS==0	;JBTSTS TABLE
	JACCT==1	;JACCT BIT
	STATAB==11	;GETTAB TABLE FOR STATES WORD
	STAIND==17	;INDEX IN TABLE FOR STATES WORD
	OPQPTB==16	;GETTAB TABLE FOR PPN FOR COMMANDS
	OPQPIN==4	;INDEX IN TABLE FOR PPN FOR COMMANDS
	OPQSTB==16	;GETTAB TABLE FOR STR FOR COMMANDS
	OPQSIN==15	;INDEX IN TABLE FOR STR FOR COMMANDS
	STAOMO==100	;0--ALL MOUNTS MUST GO TO OPR
			;1--UMOUNT MAY MOUNT IF POSSIBLE
STAOPR==400		;0--OPERATOR PRESENT
			;1--NO OPERATOR
STAVER==POINT 3,0,9	;VERSION BYTE
VER503==2		;...VALUE FOR 5.03 MONITORS

CI.DVP==55		;DEVPPN

	OPDEF	HIBER [CALLI 72]
HIBNOJ==4	;(LH) ONLY PRIV.JOBS CAN WAKE
HIBTTL==20	;(LH) WAKE ON TTY LINE
HIBSWP==400000	;(LH) SWAP IMMEDIATELY

	OPDEF	WAKE	[CALLI 73]


;FLAGS

L.TYO==1		;CHARACTERS IN TTY OUTPUT BUFFER NOT YET OUTPUT
L.ARGD==2		;DIALOGUE FOR ARGS
L.BRAK==10		;BRACKED ([) DETECTED
L.REGO==4		;REENTER TYPED
L.CMA==20		;COMMA DETECTED
L.DOT==40		;PERIOD DETECTED
L.WLD==100		;WILD * DETECTED
L.FRE2==400		;USED BY UFDSET AND UFDCLR
L.PEND==400
L.BRK==1000		;BREAK CHAR DETECTED
L.SPC==2000		;SPACE DETECTED
L.PWA==4000		;SET IF PAUSE BEFORE WAITING REQUESTED
L.SIN==10000		;SET IF FILE STRUCTURE REQUESTED SINGLE
L.REM==L.SIN		;SET IF USER REQUESTED REMOVE (DISMOUNT)
L.VID==200		;VID SWITCH
L.WRTL==20000		;SET IF USER REQUESTED WRITE-LOCK
L.FRE1==40000		;USED BY UFDSET AND UFDCLR
L.DIS==40000		;SET IF DISMOUNT INSTEAD OF ADDSTR
L.LVD==100000		;SET IF LEVEL D
L.EOL==200000		;SET IF END OF LINE SEEN
L.WEN==400000	;/WENABLE

R.NJAC==400000	;SET IF JACCT BIT NOT ON (NOT ENTERED BY COMMAND)
R.ASCO==100000	;DEV IS ASSIGNED BY CONSOLE
R.Z==200000	;USED ON FILE Z
R.VIDT==10000
;TTCALL FUNCTIONS

CLRINB==1		;CLEAR INPUT BUFFER
SKPINL==14		;SKIP IF A LINE WAS TYPED


;LOOKUP/ENTER/RENAME ERROR CODES

NUFERR==1		;NO UFD
FBMERR==3		;FILE BEING MODIFIED
NRMERR==14		;NO ROOM

	OPDEF	PJRST [JRST]
	OPDEF	PJUMPE [JUMPE]
	OPDEF	PJSP [JSP]

PHONLY==200000	;BIT TO FORCE UUOS TO CONSIDER ONLY PHYS. NAMES
;DEVCHR BITS

DC.FS==200000	;(LH)FILE STRUCT.
DC.DTA==100	;(LH)DECTAPE
DC.MTA==20	;(LH)MAGTAPE
DC.AVA==40	;(LH)AVAILABLE
DC.ASC==400000	;(RH)ASSIGN.BY CONSOL
DC.ASP==200000	;(RH)ASSIGN.BY PROG.

	OPDEF	DSKCHR [CALLI 45]
CI.DCH==45
CHRNAM==4	;ARGUMENT FOR STR NAME
CHRSAJ==13	;ARGUMENT FOR SINGLE ACCESS JOB NUMBER
CHRLEN==14	;NUMBER OF ARGS
.UPHWP==100000	;HARDWARE WRITE PROT.
.UPSWP==40000		;SOFTWARE WRITE PROT.
.UPNNA==200		;LOCKED BY OPER.
;DEVTYPE UUO PARAMETERS

	OPDEF	DEVTYP	[CALLI 53]

.TYAVL==40	;(LH)AVAILABLE
.TYJOB==POINT 9,0,26	;JOB #
.TYTYP==POINT 6,0,35	;DEVICE TYPE
  .TYDSK==0	;DISK


	OPDEF	JOBSTR [CALLI 47]	;RETURNS USER'S NEXT FILE STRUCTURE

	OPDEF	STRUUO [CALLI 50]
SRCFST==0
RDFFST==3
ULKSTR==6
UCLSTR==7

	OPDEF	SYSPHY [CALLI 51]

	OPDEF	DEVNAM [CALLI 64]
	OPDEF	GOBSTR [CALLI 66]
	DEFINE	ERRMES (TEX) <
	XLIST
	MOVEI	M,[ASCIZ \TEX\]
	JRST	ERRMSB
	LIST>


	DEFINE	TEXT (TEX)<
	XLIST
	MOVEI	M,[ASCIZ\TEX\]
	LIST>

	DEFINE	TYPE (TEX)<
	XLIST
	MOVEI	M,[ASCIZ\TEX\]
	PUSHJ	P,MSGTTY
	LIST>

	DEFINE	PTYPE (TEX)<
	XLIST
	MOVEI	M,[ASCIZ\TEX
\]
	PJRST	MSGTTY
	LIST>

	DEFINE	XTYPE (TEX)<
	XLIST
	MOVEI	M,[ASCIZ\TEX\]
	JRST	MSGRET
	LIST>

;-------CHANGE SOME DEFINITIONS IF DEBUGGING

IFN DBUGSW,<

CMDSTX==SIXBIT/QUEUE/	;USE SEPERATE 3,3 AREA
CMDPPX==0
STLSTX==SIXBIT/STRLST/	;ALLOW SPECIAL STRLST.SYS
STLPPX==0
SYSFIL==SIXBIT/XXXFIL/	;USE SEPERATE PROGRAM NAMES
SYSMOU==SIXBIT/XXXMNT/
SYSOMO==SIXBIT/XXXOMO/

> ;IFN DBUGSW
;VALUES FOR ARGUMENT TYPE RETURN FROM DSKCHR UUO

A.BYTE==POINT 3,0,17	;BYTE POINTER
A.DSK==0		;GENERIC DSK (DSK)
A.FS==2		;FILE STRUCTURE NAME (DSKA)
A.LUN==3	;LOGICAL UNIT OF A FILE STRUCTURE (DSKA0)
A.CCN==4	;CLASS OF CONTROLLERS (DP)
A.CON==5	;CONTROLLER NAME (DPA)
A.PUN==6	;PHYSICAL UNIT (DPA0)

;VALUES FOR CONTROLLER TYPE RETURN FROM DSKCHR UUO

KT.DR==0		;DRUM
KT.FH==1		;FIXED HEAD DEVICE (BURROUGHS DISK OR BRYANT DRUM)
KT.DP==2		;DISK PACK
KT.MF==3		;BRYANT MASS FILE

;VALUES FOR UNIT TYPE RETURN FROM DSKCHR UUO (ONLY FOR DISK PACKS)

UT.01==1		;MEMOREX RP01
UT.02==0		;MEMOREX RP02

;BITS SET IN AC RETURN FROM DSKCHR UUO

D.RDHM==400000		;MONITOR MUST REREAD HOME BLOCK BEFORE NEXT I/O
D.OFFL==200000		;DRIVE IS OFF-LINE
D.HWL==100000		;DRIVE IS HARDWARE WRITE PROTECTED
D.SWL==40000		;FILE STRUCTURE IS SOFTWARE WRITE PROTECTED
D.SIN==20000		;SINGLE ACCESS ONLY FOR THIS FILE STRUCTURE
D.MC==10000		;MOUNT COUNT = 0
D.PRV==4000		;FILE STRUCTURE IS A PRIVATE FILE STRUCTURE
D.INFS==2000		;IN A FILE STRUCTURE (IF 0)
D.DNBM==1000		;DOWN OR BEING MOUNTED
D.LOK==200		;NO FURTHER LOOKUPS, ENTERS, OR INITS ALLOWED
;BITS FOR STRUUO

S.SWL==400000
S.SIN==200000

;BITS FOR JOBSTR UUO

J.NOCR==200000
J.NOWR==400000

;ARGS FOR GOBSTR

GOBNAM==2		;INDEX FOR STR NAME IN ARG LIST
GOBJOB==0		;INDEX FOR JOB NUMBER
GOBPPN==1		;INDEX FOR PPN

MAXKON==8		;MAXIMUM NUMBER OF CONTROLLERS

HOMHID==1	;ENTRY IN HOME BLOCK WHICH IS PACK ID

	OPDEF	DEVLNM [CALLI 107]

;BYTE POINTERS

;FOR VALUES RETURNED FROM DSKCHR UUO

IFN MNTSW,<
D.KONT:	POINT	6,A,26	;CONTROLLER TYPE
D.KONN:	POINT	3,A,29	;KONTROLLER NUMBER
D.UNIT:	POINT	3,A,32	;UNIT TYPE (DEPENDS ON CONTROLLER TYPE)
D.UNIN:	POINT	3,A,35	;UNIT NUMBER
D.ARGT:	POINT	3,A,17	;ARGUMENT TYPE
D.UST:	POINT	2,A,8	;UNIT STATUS
   B.UST==3000	;THE BITS

CLSBYT:	POINT	3,PKCLAS(C),35	;CLASS OF THIS UNIT
UTPBYT:	POINT	3,PKCLAS(C),32	;TYPE OF THIS UNIT (RP01 OR RP02)
KTPBYT:	POINT	6,PKCLAS(C),26	;TYPE OF THIS CONTROLLER (FH, DP)

;CLASS VALUES

CL.U==0			;UNCERTIFIED (NO HOME BLOCK)
CL.C==1			;CERTIFIED
>	;END CONDITIONAL ON MNTSW
STRFOR==0		;FORMAT VERSION NUMBER FOR CURRENT FORMAT OF STRLST.SYS
QUOFOR==0		;FORMAT VERSION NUMBER FOR QUOTA.SYS

LEVDS==7B27		;7B9 IS BIT IN STATES WORD FOR LEVEL D (3 BITS LEFT HALF)

;ARGUMENTS FOR EXTENDED LOOKUP, ENTER, RENAME

EXLLEN==26	;LENGTH OF ARGUMENT LIST
EXLPPN==1	;DIRECTORY NAME
EXLNAM==2	;FILE NAME
EXLEXT==3	;EXT
EXLALC==11	;BLOCKS ALLOCATED FOR FILE
EXLDEV==16	;DEVICE ON WHICH FILE LOOKED UP IS
EXLSTS==17	;STATUS BITS
.RBSTS==17
  .RBNDL==1B19
  RIPLOG==400000	;LH BIT IS LOGGED IN BIT
  RIPDIR==400000	;RH BIT IS DIRECTORY BIT
EXLQTR==24	;RESERVED QUOTA
EXLQTF==22	;FIRST COME, FIRST SERVED QUOTA
EXLQTO==23	;LOGGED-OUT QUOTA
EXLUSD==25	;BLOCKS USED

HOMHID==1	;WORD IN HOME BLOCK CONTAINING UNIT ID
HOMLOG==7	;WORD IN HOME BLOCK CONTAINING SIXBIT LOG UNIT IN STR
;START OF PROGRAM

UMOUNT:	JFCL			;IN CASE OF CCL
	TDZA F,F			;NO FLAGS ON
REGO:	MOVSI F,L.REGO		;ONLY ONE FLAG ON. REENTER HERE
	MOVE P,PDP
	CALLI CI.RES		;CLEAR OUT EVERYTHING
	INIT TTY,0
	SIXBIT /TTY/
	XWD WH.TTY,RH.TTY
	  CALLI CI.EXI		;GIVE UP IF NO TTY
	MOVEI A,B.TTY
	MOVEM A,JOBFF
	INBUF TTY,1
	OUTBUF TTY,1
	MOVE	A,[XWD STAIND,STATAB]
	CALLI	A,CI.GTT
	  SETZ	A,
	MOVEM	A,STATES	;SAVE STATES WORD
	LDB	B,[STAVER+A]	;GET MONITOR VERSION
	MOVEM	B,MONVER
	SKIPE	B
	TLO	F,L.LVD		;LEVEL D OR LATER
	MOVE	B,SYSPPC	;LEVEL C DEFAULT SYS PPN
	TLNE	F,L.LVD
	MOVE	B,SYSPPD	;LEVEL D DEFAULT SYS PPN
	MOVSI	A,(SIXBIT .SYS.)
	CALLI	A,CI.DVP	;GET SYSTEM PPN
	  MOVE	A,B		;DEFAULT
	MOVEM	A,SYSPPN

IFE DBUGSW,<
	MOVE	A,[XWD OPQPIN,OPQPTB]
STR11:	CALLI	A,CI.GTT	;GETTAB TO GET PPN FOR COMMANDS TO OMOUNT
	  MOVE	A,[CMDPPX]
	MOVEM	A,CMDPPN
	MOVE	A,[XWD OPQSIN,OPQSTB]
STR12:	CALLI	A,CI.GTT	;GETTAB TO GET STR FOR COMMANDS
	  MOVE	A,[CMDSTX]
	MOVEM	A,CMDSTR
	TLNN	F,L.LVD		;SKIP IF LEVEL D - TEST STR NAME
	JRST	START1
	MOVEM	A,SRCBUF
	MOVE	B,[XWD CHRNAM+1,SRCBUF]
	CALLI	B,CI.DCH	;GET DSKCHR
	  JRST	NOLOGP		;NOT EVEN A DSK?
	CAME	A,SRCBUF+CHRNAM	;SKIP IF REAL STR NAME IS SAME AS GETTAB
	JRST	NOLOGP		;NO, MUST BE A LOGICAL NAME
	TLNE	B,.UPHWP!.UPSWP!.UPNNA ;PROTECTED OR LOCKED?
	JRST	NOWRTP		;YES
> ;IFE DBUGSW

IFN DBUGSW,<
	MOVE	A,[CMDPPX]
	MOVEM	A,CMDPPN
	MOVE	A,[CMDSTX]
	MOVEM	A,CMDSTR
> ;IFN DBUGSW
START1:	CALLI A,CI.PJO		;GET STUFF FOR ID
	MOVEM A,JOBNO		;JOB NUMBER
	CALLI A,CI.GTL
	MOVEM A,TTYLIN		;TTY NAME
;CK FOR JACCT BIT (ONLY VALID FOR 5.03 SINCE IT WAS MOVED IN 5.02)
	MOVE	A,MONVER
	CAIGE	A,VER503
	JRST	STAR12
	HRLZ	A,JOBNO	;GET JBTSTS WITH GETTAB
	GETTAB	A,
	  JRST	STAR12
	TLNN	A,JACCT		;IS JACCT ON?
	TRO	F,R.NJAC	;NOS-SET R.NJAC

STAR12:	HRROI A,2
	CALLI A,CI.GTT
	JFCL
	HLRZ B,A		;FORM IOR'D PROJ # WITH PROG #
	IORI B,(A)
	HRRZM B,IORPPN		;AND SAVE IT FOR LATER ID USE
	MOVEM A,USRPPN		;JOB'S PROJECT,PROGRAMMER NUMBER
	MOVEI IO,R.TTY
	MOVEI	A,10
	MOVE	B,CMDSTR	;STR FOR COMMAND QUEUE
	MOVEI	C,RH.CMU	;THIS CHANNEL WILL BE USED TO READ THE
	OPEN	CMU,A		; DIRECTORY OF THE COMMAND AREA
	  JSP	N,CMUERR
	MOVEI A,B.CMU
	MOVEM A,JOBFF
	INBUF CMU,1
	PUSHJ	P,REWCMU	;LOOKUP QUEUE UFD
	  JRST NOCMU		; IF NOT, OPR IS NOT RUNNING OPFILE

;SET STANDARD AND DEFAULT F.S.
	MOVSI	A,'DSK'	;USE DSK FOR DEFAULT & LEV.C STANDARD
	MOVEM	A,STDDEV
	MOVEM	A,DEFDEV
	TLNN	F,L.LVD		;LEVEL D?
	JRST	START2		;NO
	SETZM	STDDEV		;YES-START STANDARD DEVICE AT 0
	SETO	A,
	MOVE	D,[XWD 3,A]
NXTST:	JOBSTR	D,		;GET NEXT STR IN JOB'S SEARCH LIST
	  JRST	START2		;GIVE UP
	JUMPE	A,START2	;QUIT IF REACH FENCE
	AOJE	A,START2	;OR END OF SEARCH LIST
	SUBI	A,1		;KEEP LAST STR GIVEN
	MOVEM	A,STDDEV	;THIS STR WILL BE USED BY FILE FOR DIRECTORIES
	TLNE	C,J.NOCR!J.NOWR	;OK IF NO CREATE OR NO WRITE NOT ON
	JRST	NXTST		;TRY FOR ANOTHER IF IT IS

START2:	MOVEI	CH,33		;
	TTCALL 10,0		;BACK UP TO COMMAND
START6:	MOVE	E,[XWD -TYPL,TYPCOM]
	JRST	UDSWIT		;DISPATCH TO PROPER ROUTINE
;SUBROT. TO LOOKUP (REWIND) QUEUE UFD
REWCMU:	MOVE	A,CMDPPN	;QUEUE AREA
	MOVSI B,(SIXBIT /UFD/)
	MOVEI C,0
	MOVE D,MFDPPN
	LOOKUP CMU,A		;SEE IF UFD FOR COMMAND AREA EXISTS
	  POPJ	P,
	JRST	CPOPJ1

;DISPATCH TABLE FOR COMMANDS TYPED IN

IFE MNTSW,<EXP 	START4
	EXP 	START4>
IFN MNTSW,<EXP START7
	EXP	START7>
TYPCOM:	XWD	SIXBIT .   FIL.,START3
	XWD	SIXBIT .   MOU.,MOUNT
	XWD	SIXBIT .   DIS.,DISMNT
TYPL=.-TYPCOM

IFN MNTSW,<
START7:	PUSHJ	P,CLRLIN
	MOVEI	M,FMDM		;NO--TELL USER ONLY 'FILE' ALLOWED
	PUSHJ	P,MSGTTY	;ASK FOR PROPER COMMAND  
	JRST	START6>


NOLOGP:	MOVEI	B,NOLOGM	;TELL USER QUEUE F.S. CANT BE LOG.NAME
	JRST	NOQFS
NOWRTP:	MOVEI	B,NOWRTM	;TELL USER I CANT ACCESS QUEUE F.S.
NOQFS:	MOVEI	M,[ASCIZ/?CANT ACCESS QUEUE--/]
	PUSHJ	P,MSGTTY
	MOVE	M,CMDSTR
	PUSHJ	P,SIXMSG
	MOVE	M,B
	JRST	ERREXI
	;USER HALF OF DTA FILE-RECALL SYSTEM STARTS HERE

START3:	SETZM FILBLK		;CLEAR OUT FILE BLOCK
	MOVE A,[XWD FILBLK,FILBLK+1]
	BLT A,FILBKE
	TLNE F,L.BRK
	JRST START4		;IF BREAK CHAR NEED DIALOGUE
	PUSHJ P,GETARG		;GET CLASS OF COMMAND
	JUMPN	A,START5	;JUMP IF IT'S THERE
START4:	TLO F,L.ARGD	;NO. WILL NEED DIALOGUE
	PUSHJ P,CLRLIN		;IGNORE THE REST OF THIS LINE
	MOVEI M,CLSMSG
	TLNE F,L.ARGD			;NEED TO ASK FOR CLASS OF CMD?
	PUSHJ P,MSGTTY		;YES. DO
	PUSHJ P,GETARG		;GET ANSWER, CHECK FOR END OF CMD
	JUMPE A,HELPQ		;NO COMMAND CLASS?
START5:	ROT A,6
	ANDI A,77		;JUST FIRST CHAR
	ADDI A,40		;BACK TO ASCII
	MOVEM A,CMDCHR		;SAVE FOR LATER
DISPAT:	CAIN A,"C"
	JRST CCOM		;C FOR CHECK
	CAIN A,"R"
	JRST RCOM		;R FOR RECALL
	CAIN A,"F"
	JRST FCOM		;F FOR FILE
	CAIN A,"Z"
	JRST ZCOM		;Z FOR ZERO DIRECTORY AND FILE
	CAIN A,"D"
	JRST DCOM		;D FOR DELETING DECTAPE FILES
	CAIN A,"L"
	JRST LCOM		;L FOR DIRECTORY LISTING
	CAIN	A,"H"		;H FOR HELP
	JRST	HELPQ2
	CAIN	A,"W"
	JRST	WCOM
	JRST	START4		;NONE OF THE ABOVE -TRYAGAIN


HELPQ:	CAIE CH,"?"		;? - HE'S ASKING FOR THE STRAIGHT SCOOP
	JRST	START4
HELPQ2:	MOVEI M,HLPMSG
	PUSHJ P,MSGTTY		;SO CLUE HIM IN
	JRST REGO
;LIST DECTAPE DIRECTORY

LCOM:	PUSHJ P,GETTAP		;PUTS TAPE NUMBER IN TAPEID
	PUSHJ	P,COMSET	;SET DEVICE FOR DIRECTORY
	JRST	FILCOM		; AND OUTPUT COMMAND FILE

;DELETE FILES FROM DECTAPE

DCOM:

;RECALL FILES FROM TAPE

RCOM:	PUSHJ P,GETTAP		;GET TAPE NUMBER FROM USER
RCOM0:	MOVEI M,FILMSG
	TLNE F,L.ARGD
	PUSHJ P,MSGTTY
	PUSHJ	P,COMSET	;SET DEVICE FOR DIRECTORY AND SET UP D
RCOML:	PUSHJ P,GETFIL		;GET NEXT FILE NAME FROM USER
	JRST RCOMEQ		;NOT THERE
	PUSHJ	P,GETDEV	;GET F.S. FILE IS ON
	  JFCL			;   (IF ANY)
	TLNN F,L.CMA
	JRST RCOME		;ALL DONE IF NO COMMA FOLLOWING
	AOBJN D,RCOML
	JRST RFCOMX

RCOMEQ:	TRNN D,777776
	JRST	RCOM0		;'NO FILES NAMED'ERROR
	JRST RCOME
ZCOM:	TRO	F,R.Z	;Z TELLS OPFILE WHAT TO DO
			;ZERO DIRECTOR BEFORE FILE COMMAND

;PUT FILES ON TAPE

FCOM:	PUSHJ P,GETTAP
FCOM0:	PUSHJ	P,COMSET
	MOVEI M,FILMSG
	TLNN F,L.ARGD
	JRST	FCOML
	TRNE	F,R.Z
	JRST	FCOME
	PUSHJ P,MSGTTY
FCOML:	PUSHJ P,GETFIL		;GET NEXT FILE
	JRST FCOMEQ		;ALLDONE
	PUSHJ	P,GETDEV	;GET F.S. FILE IS ON
	  JRST	FCOMNO		;   & COMPLAIN IF NOT TANYWHERE
	TLNN F,L.CMA
	JRST FCOME		;DONE IF NO COMMA
	AOBJN D,FCOML
RFCOMX:	MOVEI M,MNYMSG
	PUSHJ P,MSGTTY
	MOVE M,FILBLK-1(D)
	PUSHJ P,SIXMSG
	PUSHJ P,DOT
	HLLZ M,FILBEX-1(D)
	PUSHJ P,SIXMSG
	PUSHJ P,CRLF
RCOME:	JRST FILCOM

FCOMNO:	MOVE D,SAVED		;TELL USER WE CAN'T DO BUSINESS WITH THAT FILE
	MOVEI M,MISMSG
	PUSHJ P,MSGTTY
	MOVE M,FILBLK(D)
	PUSHJ P,SIXMSG
	PUSHJ P,DOT
	HLLZ M,FILBEX(D)
	PUSHJ P,SIXMSG
	PUSHJ P,CRLF
	JRST MONRET
FCOMEQ:	TRNN D,777776		;MUST BE AT LEAST 1 FILE
	JRST	FCOM0		;NO?
FCOME:
FILCOM:	HRLI	NUM,(SIXBIT .F.)	;FILE TYPE COMMAND
	PUSHJ	P,COMBEG		;START IT UP
	PUSHJ	P,CRLF		;END WITH CRLF
	CLOSE	CMD,0		;IN THIS CASE THAT'S ALL
	MOVE	A,NAMFIL	;WAKE SOME OMOUNTS
	PUSHJ	P,WAKE1
	  JFCL			;NO OMOUNTS TO WAKE
	MOVEI	M,RQSMSG	;REQUEST STORED
	PUSHJ	P,MSGTTY

;COUNT NUM.COMMANDS IN QUEUE

	MOVEI	NUM,(SIXBIT/F/)	;INIT CMGET
	MOVE	A,NAMFIL
	PUSHJ	P,CMGET1
	  JRST	CCOM3
FILCO2:	PUSHJ	P,CMGET
	  JRST	CCOM3		;TYPE IT
	JRST	FILCO2


;HERE TO WAIT FOR ALL FILE REQUESTS TO GO AWAY

WCOM:	MOVEI	NUM,'F  '
	MOVE	A,NAMFIL
	PUSHJ	P,CMGET1
	  JRST	WCOM2		;NO PENDING COMMANDS
	PUSHJ	P,MSG111	;'WAITIN...'
WCOM0:	MOVEI	A,FILSLP	;HIBERNATE
	PUSHJ	P,WAIT0		;WONT RETURN IF ^C
	PUSHJ	P,CMGETI	;ANY MORE FILES?
	PUSHJ	P,CMGET
	  JRST	MONRET		;NO-RETURN TO USER
	JRST	WCOM0

WCOM2:	PUSHJ	P,MSG112
	JRST	MONRET
;HERE TO CHECK FOR PENDING REQUESTS
;NUM=SIXBIT CHAR FOR TYPE OF REQUEST TO CHECK FOR

CCOM:	MOVEI	NUM,(SIXBIT .F.) ;TYPE OF REQUEST CHECKING
	MOVE	A,NAMFIL
CCOMSB:			;HERE FROM MOUNT-DISMOUNT/C
	PUSHJ	P,CMGET1	;INIT CMGET
	  JRST	CCOME
	JRST	CCOM2
CCOM0:	PUSHJ	P,CMGET		;GET NEXT FILE REQUEST
	  JRST	CCOM3		;THATS ALL
CCOM2:	MOVEI IO,W.TTY
	MOVE N,COMCNT
	PUSHJ P,DECPRT		;PRINT INDEX IN QUEUE
	PUSHJ P,DOT
	PUSHJ P,SPACE
CCYESL:	PUSHJ P,R.CMD		;NOW READ THE COMMAND
	PUSHJ P,W.TTY		; AND TYPE IT
	CAIE CH,12		;AND LOOP FOR ONE LINE
	JRST CCYESL
	CLOSE CMD,0		;FINISHED
	JRST CCOM0

CCOME:	PUSHJ P,MSG112		;TELL USER NONE PENDING
CCOM3:				;HERE FROM FCOME
	MOVEI	IO,W.TTY
	MOVE	N,COMCNT	;PRINT NUM. OF COMMANDS IN QUEUE
	PUSHJ	P,DECPRT
	PUSHJ	P,DOT
	MOVEI	M,[ASCIZ/ COMMANDS IN QUEUE/]
	JRST	MSGRET
;SUBROUTINE TO SEE IF THERES AN OMOUNT AND INIT CMGET
;CALL	A=OMOUNT NAME TO WAKE
;	NUM=REQUEST TYPE (F,M,OR D)
;RET+1	IF NO PENDING FILES
;RET+2	WITH 1ST PENDING FILE OPENED ON CMD (SEE CMGETI)

CMGET1:	PUSHJ	P,WAKE0		;SEE IF THERES AN OMOUNT
	  PUSHJ	P,MSG113	;NO-TELL USER
	PUSHJ	P,CMGETI	;INIT CMGET
	PJRST	CMGET		;  AND LOOK FOR 1ST PENDING FILE


;SUBROUTINE TO INITILIZE CMGET
CMGETI:	PUSHJ	P,REWCMU	;REWIND UFD
	  JSP	N,NEVERR
	SETZB	A,COMCNT
	MOVE	B,CMDSTR
	MOVEI	C,RH.CMD
	OPEN	CMD,A
	  JSP	N,CMDERR
	MOVEI A,B.CMD
	MOVEM A,JOBFF
	INBUF CMD,1
	POPJ	P,
;SUBROUTINE TO LOOK FOR NEXT FILE REQ. FOR THIS USER IN QUEUE
;INIT	CALL CMGETI
;CALL	QUEUE UFD OPEN ON CMU
;	NUM=TYPE OF REQUEST (LETTER=F,M,D)
;RET+1	NO MORE
;RET+2	NEXT ONE OPENED ON CMD
CMGET:
CCOML:	PUSHJ P,R.CMU		;READ NAME OF NEXT FILE IN COMMAND AREA
	  POPJ	P,		;NO MORE FILES
	MOVE A,WD
	MOVEM A,CMDNAM		;SAVE IT
	PUSHJ P,R.CMU		;NOW EXTENSION
	  POPJ	P,		;?
	HLLZ B,WD
	MOVEI C,0
	MOVE D,CMDPPN
	HLRZ N,A
	HLRZ N1,B
	TRZ N,7777		;SAVE ONLY HIGH ORD CHAR ON RIGHT
	CAIE N1,(SIXBIT /CMD/)
	JRST CCOML
	CAME	N,NUM		;SKIP IF OUR TYPREQUEST
	JRST	CCOML		;NO, FORGET IT
	AOS COMCNT		;COUNT ACTUAL ENTRIES IN QUEUE
	HRRZ N1,A		;GET RIGHT 1/2 OF NAME
	CAME N1,IORPPN		;COULD BE FOR THIS PPN?
	JRST CCOML		;NO - TRY NEXT
	LOOKUP CMD,A
	  JRST CCOML		;SOMETHING WRONG WITH THIS FILE
	MOVEI IO,R.CMD		;OK, LET'S HAVE A LOOK AT THAT FILE
	MOVEI N,3		;LOOK FOR 4TH FIELD (3 SPACES)
CCOMF:	PUSHJ P,R.CMD		;READ CMD FILE
	CAIE CH," "		;IS IT A SPACE
	JRST CCOMF		;NO - TRY AGAIN
	SOJG N,CCOMF		;COUNT DOWN SPACES
	PUSHJ P,HPACK		;GET PROJ # AND PACK IT
	HRL WD,N		;SAVE IT
	PUSHJ P,HPACK		;GET PROG # AND PACK IT
	HRR WD,N		;SAVE IT
	CAME WD,USRPPN		;IS IT FOR THIS USER PPN?
	JRST CCOML		;NO
CCMYES:	MOVE A,CMDNAM		;YES!
	MOVSI B,(SIXBIT /CMD/)
	MOVEI C,0
	MOVE D,CMDPPN
	LOOKUP CMD,A		;GET IT AGAIN
	  JRST CCOML		;PROBABLY JUST HANDLED
	JRST	CPOPJ1
GETTAP:	MOVEI M,TAPMSG
	TLNE F,L.ARGD
	PUSHJ P,MSGTTY		;ASK FOR TAPE NUMBER IF DOING THAT SORT OF THING
	PUSHJ P,GETARG
	TLNE F,L.SPC+L.BRK+L.CMA  ;TAPE NUMBER ENDS WITH SPACE,BREAK, OR COMMA
	TLNE F,L.WLD+L.DOT		; AND NOT * OR PERIODS
	JRST COMERR
	MOVEM A,TAPEID
	POPJ P,0		;ALL RIGHT ALREADY!
COMSET:	MOVE	A,STDDEV	;STANDARD DEVICE FOR THIS USER
	MOVEM	A,FILDEV
	MOVEI	A,1		;MAKE 1ST FILE NAME NON-0
	MOVEM	A,FILBLK	;TO FORCE OUT DEVICE NAME IN COMMAND FILE
	MOVSI	D,-DTDNFI
	AOBJN	D,CPOPJ

;THIS ROUTINE READ A FILE NAME FROM TTY

GETFIL:	TLZ F,L.WLD
	PUSHJ P,GEFARG
	TLNE	F,L.BRAK	;[P,P] ?
	JRST	ILCERR		;YES-WE DONT SUPPORT IT - YET
	JUMPE A,CPOPJ
	CAIN	CH,":"
	JRST	GETFLD
	MOVEM A,FILBLK(D)
	MOVE	A,DEFDEV
	MOVEM	A,FILDEV(D)
	TLNN F,L.DOT
	JRST CPOPJ1		;EXIT IF NO PERIOD
	PUSHJ P,GEFARG		;GET EXTENSION
	TLNE	F,L.BRAK	;[P,P] ?
	JRST	ILCERR		;YES-WE DONT SUPPORT IT - YET
	TLNE F,L.DOT		;A PERIOD DELIMITER HERE IS
	JRST COMERR		;ERRONEOUS - GET OUT
	CAILE B,3		;AN EXTENTION LENGTH GREATER
	JRST COMERR		;THAN 3 IS ALSO ERRONEOUS
	HLLZM A,FILBEX(D)
	JRST CPOPJ1

GETFLD:	MOVEM	A,DEFDEV	;SET DEFAULT F.S. TO TYPEIN
	JRST	GETFIL


;SUBROUTINE TO FIND F.S. A FILE IS ON IN THE CASE OF 'DSK'
;RET+0	IF CANT FIND IT OR DIDNT PICK A DEFAULT
;RET+1	FILDEV(D) FILLED WITH F.S. NAME

GETDEV:	MOVEM D,SAVED		;SEE IF THE FILE EXISTS
	MOVEI	A,17
	MOVE	B,FILDEV(D)
	SETZ	C,
	OPEN	USR,A
	  JRST	ILDERR		;'ILLEGAL F.S.' ERROR
	TLNN	F,L.WLD		;* FOR FILE OR EXT?
	JRST	GETDE2	;NO
	TLNN	F,L.LVD		;YES-LEVEL-D?
	JRST	GETDE7		;NO
GETDE0:	MOVE	A,[XWD 1,B]	;YES-WAS FILE GENERIC 'DSK'?
	MOVE	B,FILDEV(D)
	DSKCHR	A,
	  JRST	ILDERR
	LDB	B,[POINT 3,A,17]
	CAILE	B,1
	JRST	GETDE7		;NO
GETDE1:	MOVE	B,STDDEV	;YES--USE STANDARD F.S.
	MOVEM	B,FILDEV(D)
	JRST	GETDE7

GETDE2:	TLNE	F,L.LVD
	JRST	LVDLUK
	MOVE A,FILBLK(D)		;FILE NAME
	HLLZ B,FILBEX(D)		;IT'S EXTENSION
	SETZB C,D
	LOOKUP USR,A
GETDE6:	SOS	(P)		;AH HA! NO SUCH FILE
GETDE7:	MOVE D,SAVED		;PROCEED
	JRST	CPOPJ1

LVDLUK:	MOVEI	A,EXLLEN-1
	MOVEM	A,SRCBUF
	MOVE	A,FILBLK(D)
	MOVEM	A,SRCBUF+EXLNAM
	HLLZ	A,FILBEX(D)
	MOVEM	A,SRCBUF+EXLEXT
	SETZM	SRCBUF+EXLPPN
	LOOKUP	USR,SRCBUF
	  JRST	GETDE8
	MOVE	A,SRCBUF+EXLDEV
	MOVEM	A,FILDEV(D)
	JRST	GETDE7

GETDE8:	SOS	(P)
	JRST	GETDE0
IFE MNTSW,<
DISMNT:	MOVEI	M,NODISM
	JRST	.+2

MOUNT:	MOVEI	M,NOMNTM
	PUSHJ	P,MSGTTY
	OUTPUT	TTY,
	EXIT	1
	EXIT			;IN CASE USER TYPES CONTINUE
>	;END CONDITIONAL ON MNTSW
IFE MNTSW,<XLIST>
IFN MNTSW,<

	;DISMOUNT CUSP STARTS HERE

DISMNT:	MOVEI	A,"D"
	MOVEM	A,CMDCHR
	TLNN	F,L.LVD		;NO DISMOUNT FOR LEVEL-C
	JRST	ERR100
	TLZ	F,L.VID!L.REM!L.PWA
	SETZM	PHYNAM
	PUSHJ	P,DISMN6	;LOOK FO SWITCHES
	PUSHJ	P,REDEV		;GET FILE STRUCTURE NAME
	JUMPE	A,NFSERR	;NO F/S NAME
	MOVEM	A,CMDFSN	;COMMAND'S FILE STR NAME
	DEVNAM	A,		;GET PHYSICAL NAME
	  MOVE	A,CMDFSN	;
	CAMN	A,[SIXBIT /DSK/];USE ORIGINAL FS NAME IF "DSK"
	MOVE	A,CMDFSN	;  WAS RETURNED
	MOVEM	A,DVVNAM
	PUSHJ	P,DISMN6	;SWITCHES AGAIN
	TLNN	F,L.EOL		;THAT SHOULD BE ALL
	JRST	COMERR		;  DONT UNDERSTAND IF ITS NOT

;WHAT KIND OF DEVICE IS IT?

	MOVE	A,DVVNAM	;DO A DEVCHR
	DEVCHR	A,
	JUMPE	A,ERR6		;ASSUME IT WAS A F.S. THAT WENT AWAY
	TLNE	A,DC.FS		;F.S.?
	JRST	DISMN3		;YES-NEEDS SPECIAL ATTENTION

;HERE IF NOT A F.S. -- MUST 5.03 OR LATER(FOR COMPAT. WITHE MOUNT SIDE)

	MOVE	B,MONVER	;CK. MONITOR VERSION
	CAIGE	B,VER503
	JRST	ERR503

	MOVE	A,DVVNAM	;IS IT ASSIGNED?
	DEVTYP	A,
	  JSP	N,NEVERR
	LDB	A,[.TYJOB+A]
	CAME	A,JOBNO
	JRST	DISMN1		;NO
	MOVE	B,STATES	;YES-CK STATES WORD FOR OPERATOR STATE
	TRNE	B,STAOPR	;IS THERE AN OPER.?
	JRST	DISMN2		;NO
	TRNE	B,STAOMO	;YES-DOES HE WANT TO SEE EVERYTHING?
	TLNE	F,L.VID!L.REM	;    OR DO SWITCHES NEED OPER. ATTENTION
	JRST	DISMN0		;YES-SEND IT TO OMOUNT
;HERE IF MUST/WANT TO DO OURSELF

DISMN2:	SETZM	A		;DEASIGN=REASSIGN TO JOB 0
	MOVE	B,DVVNAM
	REASSI	A,
	JUMPN	B,DISFIN
	JSP	N,NEVERR	;?

DISMN1:	PUSHJ	P,MSG105	;TELL USER NOT ASSIGNED
	JRST	DISFIN


;HERE IF WANT OPR TO DO IT

DISMN0:	MOVE	A,DVVNAM
	DEVNAM	A,
	  JSP	N,NEVERR
	MOVEM	A,PHYNAM
	PUSHJ	P,REMREQ
	JRST	DISMN2	;NOW DEASSIGN IT
;HERE IF WERE DEALING WITH A F.S.

DISMN3:
IFN JACTSW,<	;FONT WANT THIS FOR SOME DEBUGGING
	TRNE	F,R.NJAC	;MUST BE PRIVILEGED FOR F.S.S
	JRST	ERR103
>
	MOVE	B,FSNAME	;B=STR NAME
	MOVEI	A,B
	DSKCHR	A,
	  JRST	ERR6
	LDB	B,[A.BYTE+A]	;IS THIS A SINGLE F.S.?
	CAIE	B,A.FS
	JRST	ILFERR			;NO
	MOVEI	A,"D"
	MOVEM	A,CMDCHR
	MOVE	A,USRPPN	;GET QUOTA.SYS LOG.OUT
	MOVE	B,FSNAME
	PUSHJ	P,GETQUO
	  SETO	D,
	MOVE	A,USRPPN
	MOVE	B,JOBNO
	MOVE	N,SYSPPN
	MOVE	N1,MFDPPN
	MOVE	M,FSNAME
	MOVEI	IO,W.TTY
	PUSHJ	P,UFDCLR	;CLEAR UFD
	  JRST	DISFI1
	TLNN	F,L.REM		;REMOVE STR?
	JRST	DISFIN		;NO, ALL DONE
	PUSHJ	P,REMREQ
	JRST	DISFIN

;	HERE TO READ SWITCHES

DISMN6:	PUSHJ	P,SST		;INGORE SPACE TABS
	CAIE	CH,"/"
	POPJ	P,		;NO MORE SWITCHES
	MOVE	E,[XWD -DMSLEN,DMSLST]
	PUSHJ	P,UDSWIT
	JRST	DISMN6		;LOOP UNTIL NO MORE SWITCHES
DISFIN:	MOVEI	IO,W.TTY
	MOVE	M,CMDFSN
	PUSHJ	P,SIXMSG
	MOVEI	M,DISDON
	JRST	ALLFIN

DISFI1:	PUSHJ	P,QUEST		;? FSNAME DISMOUNT INCOMPLETE
	MOVEI	IO,W.TTY
	MOVE	M,CMDFSN
	PUSHJ	P,SIXMSG
	MOVEI	M,DINCOM
	JRST	ALLFIN

;SUBROUTINE TO QUEUE REQUEST TO OPR AND WAIT FOR IT
REMREQ:	SETZM	TAPEID
	SETZM	FILBLK
	HRLI	NUM,(SIXBIT .D.)
	PUSHJ	P,COMBEG
	MOVEI	M,[ASCIZ . DISMOUNT .]
	PUSHJ	P,MSG
	SKIPN	M,PHYNAM
	MOVE	M,FSNAME
	PUSHJ	P,SIXMSG
	MOVEI	M,[ASCIZ . /R.]
	TLNE	F,L.REM
	PUSHJ	P,MSG
	PUSHJ	P,VIDOUT	;CK FOR /VID
	PUSHJ	P,CRLF
	PUSHJ	P,MSG110
	PJRST	TMWAIT
	DEFINE SWTAB (A)<
	IRP A,<XWD SIXBIT \   A\,DMS'A>>

DMSPAU==UMSPAU
DMSVID==VIDIN

	SWERR2
	SWERR
DMSLST:	SWTAB <HEL,REM,PAU,CHE,VID>
DMSLEN=.-DMSLST

DMSHEL:	MOVEI	M,DIHELP
	PJRST	GOAWAY

DMSREM:	TLO	F,L.REM
	POPJ	P,

DMSCHE:	MOVEI	NUM,(SIXBIT .D.)
	MOVE	A,NAMMNT
	JRST	CCOMSB

;SUBROUTINE TO READ A /VID SWITCH
VIDIN:	TLO	F,L.VID	;SET A BIT
	SETZM	VIDK
	CAIE	CH,":"	;FOLLOWED BY TEXT?
	JRST	COMERR	; NO - SYNTAX ERROR
;	POPJ	P,	;NO-THATS ALL
	MOVNI	A,VIDMAX
	MOVE	B,[POINT 7,VID]
	TRZ	F,R.VIDT
	PUSHJ	P,(IO)
	CAIE	CH,VIDCH1
	JRST	VIDIN4
	TRO	F,R.VIDT
	JRST	VIDIN3
VIDIN2:	PUSHJ	P,(IO)
VIDIN4:	CAIL	CH,"0"	;DIGITS ARE LEGAL
	CAILE	CH,"9"
	CAIN	CH,"-"	;HYPHEN IS LEGAL
	JRST	VIDIN3
	CAIL	CH,"A"	;LETTERS ARE LEGAL
	CAILE	CH,"Z"
	CAIN	CH,"."	;PERIOD IS LEGAL
	JRST	VIDIN3
	CAILE	CH,15
	TRNN	F,R.VIDT
	JRST	VIDIN5
	CAIE	CH,VIDCH2
	JRST	VIDIN3
	AOSLE	A
	TDZA	A,A
	IBP	B
	DPB	CH,B
	PUSHJ	P,(IO)
VIDIN5:	ADDI	A,VIDMAX	;FINISHED-COUNT CHARACTERS
	MOVEM	A,VIDK
	POPJ	P,
VIDIN3:	JUMPGE	A,VIDIN2	;DONT OVERUN BUFFER
	IDPB	CH,B
	AOJA	A,VIDIN2

;SUBROUTINE TO OUTPUT /VID SWITCH
VIDOUT:	TLNN	F,L.VID	;WAS THERE ONE?
	POPJ	P,		;NO
	TEXT	< /V:>
	PUSHJ	P,MSG
	MOVE	A,VIDK
	MOVE	B,[POINT 7,VID]
VIDOU2:	SOJL	A,CPOPJ
	ILDB	CH,B
	PUSHJ	P,(IO)
	JRST	VIDOU2
;HERE ON MOUNT COMMANDS

MOUNT:	MOVEI	A,"M"
	MOVEM	A,CMDCHR
	MOVEI	A,3	;SET LOOP CATCHERS
	MOVEM	A,LOOPX1
	TLNN	F,L.LVD	;NOT LEGAL FOR LEVEL-C
	JRST	ERR100

;SCAN FOR DEVICE & LOGICAL NAMES

	SETZM	PHYNAM
	TLZ	F,L.SIN!L.WRTL!L.VID!L.PWA
IFN WLSW,<
	TLO	F,L.WRTL	;MAKE WRITE-LOCK DEFAULT
>
	PUSHJ	P,UMSPRC	;SWITCHES
	PUSHJ	P,REDEV
	JUMPE	A,ERR101	;MUST BE ONE
	MOVEM	A,CMDFSN	;
	MOVEM	A,DVVNAM
	PUSHJ	P,UMSPRC	;SWITCHES
	PUSHJ	P,REDEV		;GET 2ND NAME (OPTIONALL LOGICAL NAME)
	MOVEM	A,LOGNAM
	PUSHJ	P,UMSPRC

;IS THIS A DISK OR F.S.?

	MOVE	A,DVVNAM
	DEVCHR	A,
	JUMPE	A,MOFS2		;IF IT FAILS TRY STRLST.SYS
	MOVEM	A,DEVMOD	;SAVE DEVCHR BITS
	TLNE	A,DC.FS		;FILE STRUCTURE?
	JRST	MOFS		;YES--NEEDS SPECIAL ATTENTION
IFN VIDSW,<
	TLNE	F,L.VID		;/VID SPECIFIED?
	JRST	MOUNT0		;YES
	MOVEI	M,[ASCIZ #?REQUIRES "/VID" SWITCH#]
	JRST	ERREXI		;
MOUNT0:
>	;END CONDITIONAL ON VIDSW
;HERE IF NOT A F.S. - UUOS REQUIRE 5.03 MONITOR OR LATER

	MOVE	A,MONVER
	CAIGE	A,VER503
	JRST	ERR503

;GET A PHYSICAL NAME FOR DVVNAM (IN CASE ITS GENERIC OR LOGICAL)

MOUNT1:	TRZ	F,R.ASCO
	SOSGE	LOOPX1		;CK FOR PATHALOGICALOOP
	JSP	N,NEVERR
	MOVE	A,DVVNAM	;ASSUME ITS PHYSICAL ALREADY
	MOVEM	A,PHYNAM
	DEVNAM	A,PHONLY	;YES-AND ALSO PHYSICAL?
	  JRST	MOUN15		;NO
	JUMPE	A,MOUN15	;NO
	MOVE	A,DVVNAM	;YES-GENERIC?
	TRNE	A,-1
	JRST	MOUN16		;NO
	SKIPN	LOGNAM		;LOGICAL NAME SPECIFIED?
	JRST	ERR104		;  NO - SO REQUEST ONE

	HRRI	A,'0  '		;YES-FIND A FREE UNIT STARTING WITH DEV0
MOUN12:	MOVE	B,A
	DEVTYP	B,PHONLY
	  JRST	MONAV
	JUMPE	B,MONAV		;NO FREE ONE -- TELL USER
	LDB	C,[.TYJOB+B]	;ASSIGNED TO A JOB?
	JUMPE	C,MOUNT2	;NO--USE THIS ONE
	ADDI	A,10000		;YES-TRY NEXT ONE
	JRST	MOUN12

;HERE IF DVVNAM IS SPECIFIC (LOGICAL OR PHYSICAL)

MOUN15:	MOVE	A,DVVNAM	;HET PHYS. NAME
	DEVNAM	A,
	  JSP	N,NEVERR
	SKIPN	A
	JSP	N,NEVERR	;??DEVCHR WORKED??
	MOVEM	A,PHYNAM
MOUN16:	MOVE	B,A
	DEVTYP	B,PHONLY	;GET DEVTYP BITS
	  JSP	N,NEVERR
	TLNE	B,.TYAVL	;AVAILABLE?
	JRST	MOUNT2		;YES
	JRST	MONAV
;HERE IF POSSIBLE TO DO IT OURSELF
;   A=PHYS.NAME  B=DEVTYP BITS FOR IT

MOUNT2:	LDB	B,[.TYJOB+B]	;ASSIGNED TO THIS JOB?
	CAMN	B,JOBNO
	TRO	F,R.ASCO	;YES-REMEMBER THE FACT
	MOVE	C,STATES	;TEST FOR OPERATOR CONSTRAINTS
	TRNE	C,STAOPR	;IS THERE AN OPER.?
	JRST	MOUNT3		;NO-TRY TO DO IT HERE
	TRNE	C,STAOMO	;YES-DOES HE WANT TO DO IT ALL?
	TLNE	F,L.VID!L.WRTL!L.WEN ; OR DO SWITCHES NEED HIM?
	JRST	MOOP		;YES--SEND IT TO OMOUNT THEN

;HERE TO DO IT OURSELF A=PHYS.NAME

MOUNT3:	PUSHJ	P,ASLOG	;OPEN ON US1 AND ASSIG.LOG.NAME IF NECESSARY
	  JRST	MOUNT1	;TRY AGAIN INCASE SOMEONE JUST ASSIGNED IT
	TRNE	F,R.ASCO	;ALREADY ASSIGNED?
	JRST	MOOK	;YES
	MOVEI	B,US1		;NO-TRY TO ASSIGN DEVICE (REASSIGN TO MYSELF)
	MOVE	A,JOBNO
	REASSI	A,
	SKIPE	A		;SUCCESS?
	JUMPN	B,MOOK		;YES
	MOVE	B,DVVNAM	;NO-TELL USER
	PUSHJ	P,MSG104
	RELEAS	US1,
;HERE TO SEE HOW IT ALL CAME OUT

MOCK:	SKIPN	B,LOGNAM	;LOGICAL NAME?
	MOVE	B,DVVNAM	;NO--USE DVVNAM
	PUSHJ	P,MOPEN
	  JRST	ERR912		;CANT--TELL LOOSER USER

;HERE IF SUCCESSFUL  WITH DEVICE OPENED ON US1

MOOK:	MOVEI	A,US1		;CK THAT OPENED DEV. IS ASSIGNED TO ME
	DEVCHR	A,
	TRNN	A,400000	;  ASSIGNED?
	JRST	ERR912
	MOVEI	A,US1
	DEVTYP	A,
	  JRST	ERR912
	LDB	A,[POINT 9,A,26]	;  TO ME?
	CAME	A,JOBNO
	JRST	ERR912
	SKIPN	M,LOGNAM	;LOGICAL NAME?
	MOVE	M,DVVNAM	;NO-USE DVVNAME
	PUSHJ	P,SIXTTY
	SKIPN	LOGNAM		;IF WAS LOGICAL NAME
	JRST	MOOK2
	PUSHJ	P,LPAR		;TYPE PHYS.NAME IN PARENS
	MOVEI	M,US1
	DEVNAM	M,
	  SETZM	M
	PUSHJ	P,SIXTTY
	PUSHJ	P,RPAR

MOOK2:	XTYPE	< MOUNTED
>	;THATS ALL
;HERE IF DEVICE NOT AVAILABLE

MONAV:	MOVE	M,DVVNAM	;TELL USER NOT AVAILABLE
	PUSHJ	P,MSG100

;HERE IF NEED OPERATORS HELP (OMOUNT)

MOOP:	SKIPN	A,LOGNAM	;LOGICAL NAME?
	JRST	MOOP1		;NO
	DEVTYP	A,		;YES-ALREADY USED?
	  JRST	MOOP0
	LDB	A,[POINT 9,A,26]
	CAME	A,JOBNO
	JRST	MOOP1		;NO
	PUSHJ	P,MSG101	;YES-TELL USER
MOOP0:	SETZM	LOGNAM		;    AND IGNORE IT

MOOP1:	TRNN	F,R.ASCO	;ALREADY ASSIGNED?
	JRST	MOOP2		;NO
	MOVE	A,PHYNAM	;YES-ASSIGN LOG.NAME IF ANY
	PUSHJ	P,ASLOG
	  PUSHJ	P,MSG900
	RELEAS	US1,

MOOP2:	PUSHJ	P,MOQU		;QUEUE REQUEST TO OPERATOR
	JRST	MOCK		;GO SEE WHAT HAPPENED


;SUBROUTINE TO QUEUE REQUEST TO OMOUNT AND WAIT FOR IT

MOQU:	PUSHJ	P,QUEREQ
	PUSHJ	P,MSG110	;TELL USER OPERATOR NOTIFIED
	PJRST	TMWAIT		;RETURN WHEN PROCESSED


;SUBROUTINE TO ASSIGN LOGICAL NAME TO DEVICE
;CALL	A=NAME
;RET+1	CANT OPEN DEVICE
;RET+2	OPENED SUCCESSFULY-MAY OR MAYNOT HAVE ASSIGNED LOG.NAME

ASLOG:	MOVE	B,A	;OPEN ON US1
	PUSHJ	P,MOPEN
	  POPJ	P,	;CANT

	SKIPN	B,LOGNAM	;IS THER A LOG.NAME?
	JRST	CPOPJ1		;NO-RETURN
	MOVEI	A,US1		;YES-ASSIGN LOG.NAME
	DEVLNM	A,
	  AOSA	A
	JRST	CPOPJ1		;SUCCESSS
	AOJN	A,ASLOG2	;FAILURE--WHAT?
	PUSHJ	P,MSG101	;  NAME IN USE
	SKIPA
ASLO2:	PUSHJ	P,MSG900	;  ?SOMETHING ELSE
ASLOG2:	SETZM	LOGNAM		;IGNORE LOGNAME
	JRST	CPOPJ1
;SUBROUTINE TO OPEN DEVICE ON US1
;CALL	B=DEVICE NAME
;	DSKCHR BITS IN DEVMOD
;RET+1	ERROR (MSG TYPED) OR NO SUCH DEVICE
;RET+2	OK
;USES	A,B,C

MOPEN:	HRLZ	C,DEVMOD	;GET READY FOR JFFO
	TLZ	C,600000	;LEAVE ONLY MODE BITS IN LH.
	JFFO	C,MOPEN1	;CONVERT BIT POSIT. TO NUMBER
	PJSP	N,NEVMSG	;SHOULDNT HAPPEN
MOPEN1:	MOVEI	A,^D17
	SUB	A,C+1
	SETZM	C		;NO OPEN
	OPEN	US1,A
	  POPJ	P,		;CANT DO
	JRST	CPOPJ1		;GOOD RETURN
	;USER HALF OF MOUNT CUSP STARTS HERE

MOFS:
MOFS2:
IFN JACTSW,<	;DONT WANT THIS FOR SOME DEBUGGING
	TRNE	F,R.NJAC	;MUST BE PRIVILEGED
	JRST	ERR103
>
	MOVE	A,CMDFSN	;COMMAND'S FS NAME
	DEVNAM	A,		;GET PHYSISCAL NAME
	  MOVE	A,CMDFSN	;
	CAMN	A,[SIXBIT /DSK/];USE ORIGINAL FS NAME IF "DSK"
	MOVE	A,CMDFSN	;  WAS RETURNED
	MOVEM	A,FSNAME	;
	SETZM	UDREQ		;CLEAR USER UNIT REQUESTS FLAG
	SETZM	USRDRV
	MOVE	A,[XWD USRDRV,USRDRV+1]
	BLT	A,USRDRV+8*MAXKON-1	;CLEAR USER DRIVE REQUEST TABLE
	PUSHJ	P,UMSPRC	;SWITCHES AGAIN
	TLNE	F,L.EOL		;IF END OF LINE
	JRST	UMOUN5		;   START PROCESSING

	CAIE	CH,"("		;SKIP IF BEGINNING OF LIST OF UNITS
	JRST	COMERR		;DONT UNDERSTAND
	SETOM	UDREQ		;SET FLAG NOTING USER UNIT REQUESTS
	SETZM	D		;INDEX UNIT TABLES WITH D
UMOUN3:	PUSHJ	P,SSIXBR	;READ A UNIT NAME
	CAIGE	D,MAXKON*8	;DONT STORE IF REACHED MAX. NUM.
	MOVEM	A,USRDRV(D)
	PUSHJ	P,SST		;COMMA?
	CAIN	CH,","
	AOJA	D,UMOUN3	;YES-GET ANOTHER UNIT
	CAIE	CH,")"		;NO--BETTER BE )
	JRST	COMERR
	AOS	D
	MOVEM	D,NUMREQ	;REMEMBER NUM. OF UNITS TYPED
	MOVEI	CH," "		;SO UMSPRC WONT HANG ON ")
	PUSHJ	P,UMSPRC	;CK FOR SWITCHES A LAST TIME
	TLNE	F,L.EOL		;BETTER BE ALL
	JRST	UMOUN5
	JRST	COMERR		;NOT EXPECTING ANYTHING MORE


UMSPRC:	PUSHJ	P,SST		;SKIP SPACE TABS
	CAIE	CH,"/"		;PRECEEDING / ?
	POPJ	P,		;NO--NOT A SWITCH
	MOVE	E,[XWD -UMSLEN,UMSLST]
	PUSHJ	P,UDSWIT
	JRST	UMSPRC		;LOOP FOR MULTIPLE SWITCHES

	DEFINE	SWTAB(A),<
	IRP A,<XWD SIXBIT \   A\,UMS'A
>>

UMSVID==VIDIN
UMSMUL=CPOPJ

	SWERR2
	SWERR
UMSLST:	SWTAB <HEL,WEN,WLO,RON,MUL,SIN,CHE,PAU,VID>
UMSLEN==.-UMSLST	;LENGTH OF TABLE OF MOUNT SWITCHES

UMSHEL:	MOVEI	M,MOHELP
	PJRST	GOAWAY
UMSRON:
UMSWLO:	TLZ	F,L.WEN
	TLOA	F,L.WRTL
UMSSIN:	TLO	F,L.SIN
	POPJ	P,

UMSCHE:	MOVEI	NUM,(SIXBIT .M.)
	MOVE	A,NAMMNT
	JRST	CCOMSB

UMSWEN:	TLZ	F,L.WRTL
	TLOA	F,L.WEN
UMSPAU:	TLO	F,L.PWA
	POPJ	P,
SWERR:	MOVEI	M,SWERM1	;'NON-EXISTANT SWITCH'
	JRST	SWERR3
SWERR2:	MOVEI	M,SWERM2	;'NON-UNIQUE SWITCH'
SWERR3:	PUSHJ	P,MSGTTY
	MOVE	M,A		;M=SWITCH TYPED
	PUSHJ	P,SIXMSG	;TYPE IT
	JRST	MONRET		;THATS ALL


UMOUN5:	MOVE	A,[XWD CHRLEN,CHRBUF] ;DO A DSKCHR
	MOVE	B,FSNAME
	MOVEM	B,CHRBUF
	DSKCHR	A,
	  JRST	STRSRC		;NOT MOUNTED--CK STRLST.SYS
	LDB	B,[A.BYTE+A]	;SINGLE F.S.?
	CAIE	B,A.FS
	JRST	ILFERR		;NO
	TLNN	A,D.SIN		;IF ALREADY MOUNTED
	TLNE	F,L.SIN		;   AND NO SINGLE-ACCESS CONSIDERATIONS:
	JRST	STRSRC
	SETZ	NUM,		;CLEAR NUM, NORMALLY SETUP VIA STRSRC
	JRST	UMNT0		;   SKIP STRLST.SYS LOOKUP
;HERE WHEN COMMAND HAS BEEN SCANNED - FIND FILE STRUCTURE IN STRLST.SYS

STRSRC:	INIT	USR,14		;BINARY MODE
	STLSTX
	XWD	0,RH.USR
	  JRST	ERR26		;IF SYS DOES NOT EXIST, WE'RE IN TROUBLE
	MOVEI	A,B.USR
	MOVEM	A,JOBFF
	INBUF	USR,1		;SET UP 1 BUFFER
	MOVE	A,[SIXBIT .STRLST.]
	MOVSI	B,(SIXBIT .SYS.)
	SETZ	C,
	MOVE	D,[STLPPX]
	LOOKUP	USR,A
	  JRST	ERR1		;STRLST HAS A PROBLEM
	PUSHJ	P,R.USR		;READ FORMAT VERSION NUMBER
	  JRST	ERR2
	HLRZS	A		;LH=NUMBER
	CAIE	A,STRFOR
	JRST	ERR27
STR1:	PUSHJ	P,R.USR		;GET NEXT WORD IN A
	  JRST	ERR2A		;HERE IF INPUT ERROR (PROBABLY EOF)
	JUMPE	A,STR1		;IGNORE 0 LENGTH BLOCKS
	MOVEI	B,-1(A)		;B=NUMBER OF WORDS THAT FOLLOW
	PUSHJ	P,R.USR		;READ FILE STRUCTURE NAME
	  JRST	ERR17		;YOU GOT SOMETHING AGAINST READING?
	CAMN	A,FSNAME	;SEE IF THIS IS THE RIGHT ENTRY
	JRST	HAVSTR		;YES!
	PUSHJ	P,SKPSTR	;SKIP THE REST OF THIS ENTRY
	JRST	STR1

;HERE WHEN HAVE FOUND THE FILE STRUCTURE'S ENTRY IN STRLST.SYS

HAVSTR:	MOVEI	NUM,-3(B)
	LSH	NUM,-1		;NUM=NUMBER OF PACKS IN FILE STRUCTURE
	PUSHJ	P,R.USR		;GET PROJ,PROG OF OWNER
	  JRST	ERR17
	MOVEM	A,OWNPPN
	MOVEI	B,2
	PUSHJ	P,SKPSTR	;SKIP OWNER'S NAME
	PUSHJ	P,R.USR		;READ FIRST PACK ID
	  JRST	ERR17
	MOVEM	A,PACKID	;PUT FIRST PACK IN TABLEAPUSHJ	P,R.USR
	PUSHJ	P,R.USR
	  JRST	ERR17
	MOVEM	A,PKCLAS	;AND FIRST CLASS WORD

UMNT1A:	MOVNI	D,-1(NUM)
	JUMPGE	D,UMNT1C	;JUMP IF ONLY ONE PACK
	HRLZ	D,D
UMNT1B:	PUSHJ	P,R.USR		;GET NEXT PACK ID
	  JRST	ERR17
	MOVEM	A,PACKID+1(D)	;AND STORE IN TABLE
	PUSHJ	P,R.USR		;AND CLASS, ETC.
	  JRST	ERR17
	MOVEM	A,PKCLAS+1(D)
	AOBJN	D,UMNT1B	;LOOP FOR ALL PACKS
UMNT1C:	RELEASE	USR,		;GET RID OF SYS

	CAML	NUM,NUMREQ	;TELL USER IF TOO MANY DRIVE REQUESTED
	JRST	UMNT1
	MOVEI	IO,W.TTY	;SELECT OUTPUT ROUTINE
	MOVE	M,CMDFSN	;FILE STRUCTURE NAME
	PUSHJ	P,SIXMSG
	MOVEI	M,TMRM1
	PUSHJ	P,MSG
	MOVE	N,NUM		;ACTUAL NUMBER OF DRIVES
	PUSHJ	P,DECPRT
	MOVEI	M,TMRM2
	PUSHJ	P,MSG

;HERE TO CHECK CURRENT STATE OF THE FILE STRUCTURE (MOUNTED OR NOT)

UMNT1:	MOVE	A,[XWD CHRLEN,CHRBUF]
	MOVE	B,FSNAME
	MOVEM	B,CHRBUF
	DSKCHR	A,		;DSKCHR OF FILE STRUCTURE NAME
	  JRST	FNDPAK		;ERROR RETURN - F.S. UNKNOWN
UMNT0:	SKIPLE	B,CHRBUF+CHRSAJ	;GET SINGLE ACCESS JOB
	TLNE	A,D.MC		;IF MC=0 DONT CARE WHAT SINGLE ACCESS JOB WAS
	JRST	UMNT2		;NOT SINGLE ACCESS
	CAME	B,JOBNO		;SEE IF WE HAVE IT
	JRST	ERR29		;NO, CANT GET IT
UMNT2:	TLNE	A,D.LOK		;SKIP IF NOT LOCKED OUT
	JRST	ERR21		;CANT HAVE THE FILE STRUCTURE
	MOVEI	M,IMNTM
	PUSHJ	P,MSGTTY	;TELL USER STR IS ALREADY MOUNTED
	HRRZS	B
	TLNE	A,D.MC		;SKIP IF MOUNT COUNT NOT = 0
	JRST	MNTST2		;=0, ONWARD
	TLNE	F,L.SIN		;IF MOUNT COUNT GT 0, OBVIOUSLY WE CANNOT
	CAMN	B,JOBNO		; ALLOW SINGLE ACCESS, BUT OK IF WE HAVE IT
	JRST	MNTST2		;ALLOW SINGLE REQUESTS
	MOVEI	M,NSAM
	PUSHJ	P,MSGTTY	;TELL USER
	TLZ	F,L.SIN		;CANCEL SINGLE-ACCESS REQUEST

;CHECK /S CONDITIONS

MNTST2:	TLNN	F,L.SIN		;REQUESTED SINGLE ACCESS?
	JRST	MNTST3		;NO
	MOVE	A,USRPPN	;IF USER IS
	CAMN	A,[1,,2]	;    1,2
	JRST	MNTST3		;    ITS OK
	HLLZ	A,OWNPPN	;YES-OWNERS PROJ.=-1?
	JUMPL	A,MNTST3	;YES-ITS OK
	HLLZ	B,USRPPN	;NO- =JOB PROJ.?
	CAME	A,B		;YES-OK
	JRST	ERR5		;NO--CANT ALLOW
;HERE WHEN FILE STRUCTURE IS ALREADY MOUNTED - CHECK IF UNITS AS USER REQUESTED

MNTST3:	MOVE	BP,[XWD 440600,B]
	MOVE	B,FSNAME
	ILDB	E,BP
	JUMPN	E,.-1		;FIND END OF F.S. NAME AND CLEAR E
	ADD	BP,[XWD 060000,0]	;DECREMENT BYTE POINTER
	MOVEM	BP,TEMBP
	MOVN	D,NUM
	HRLZS	D
CHKUP:	PUSHJ	P,FILDPT	;COMPUTE SIXBIT LOGICAL UNIT IN STR
	MOVE	A,[XWD 1,B]
	DSKCHR	A,		;DSKCHR OF NEXT LOGICAL UNIT
	  JRST	CNTMT		;NOT MOUNTED
	PUSHJ	P,UNISET	;COMPUTE UNIT NAME IN B FROM DSKCHR RETURN
	MOVE	N,A		;N=AC RETURN FROM DSKCHR
	MOVE	A,USRDRV(D)	;A=USER REQUEST
	PUSHJ	P,GETMSK	;GET MASK IN C
	AND	C,B		;C=NUMBER OF CHARS IN NAME THAT USER REQUIRED
	CAMN	C,USRDRV(D)	;SKIP IF ACTUAL UNIT INCOMPATIBLE (MOUNTED ELSEWHERE)
	JRST	CHKUP1		;OK
	MOVEI	IO,W.TTY
	MOVE	M,PACKID(D)	;GET UNIT ID
	PUSHJ	P,SIXMSG	;TYPE IT
	MOVEI	M,ARMM
	PUSHJ	P,MSG
	MOVE	M,B		;UNIT IT'S MOUNTED ON
	PUSHJ	P,SIXMSG	;TYPE THAT
	PUSHJ	P,CRLF
	JRST	CHKUP1
CNTMT:	MOVEI	IO,W.TTY
CNTMT1:	MOVE	M,PACKID(D)
	PUSHJ	P,SIXMSG	;TYPE UNIT ID
	AOBJP	D,CNTMT2	;JUMP IF NO MORE UNITS FROM STRLST
	MOVEI	CH,","
	PUSHJ	P,W.TTY		;AT LEAST ONE MORE, TYPE COMMA
	JRST	CNTMT1
CNTMT2:	MOVEI	M,UNMM
	PUSHJ	P,MSG		;TELL USER THESE UNITS NOT MOUNTED
	JUMPE	E,PAKUP		;JUMP IF ALL MOUNTED UNITS READY
	JRST	RDYREQ		;NO, REQUEST OPR TO READY
CHKUP1:	TLNN	N,D.OFFL	;SKIP IF DRIVE IS OFF-LINE
	JRST	CHKUP2		;OK, GO READ HOME BLOCK, CHECK ID
	ADDI	E,1
	MOVEI	IO,W.TTY
	MOVE	M,B		;B=UNIT NOT READY
	PUSHJ	P,SIXMSG	;TYPE UNIT
	MOVEI	M,NRM
	PUSHJ	P,MSG		;TELL USER NOT READY

CHKUP2:	AOBJN	D,CHKUP		;LOOP FOR ALL UNITS IN STR
	JUMPE	E,PAKUP		;JUMP IF ALL UNITS READY

RDYREQ:	PUSHJ	P,QUEREQ
	MOVEI	M,OPRDY		;REQUEST OMOUNT TO SET UNITS ON-LINE
	PUSHJ	P,OPREQ2
	JRST	MNTFIN
;HERE IF ALL UNITS READY - FIRST READ QUOTA.SYS FOR QUOTAS

PAKUP:	MOVE	A,USRPPN	;GET QUOTAS FROM QUOTA.SYS
	MOVE	B,FSNAME
	PUSHJ	P,GETQUO
	  JRST	CANTM	;NO QUOTAS - NO UFD
	JUMPN	C,GETUFD	;FALL THROUGH IF LOGGED IN QUOTA = 0

CANTM:	PUSHJ	P,CRLF		;TELL POOR USER WE CANT MAKE A UFD
	SETO	D,		;NOTE NO UFD DESIRED

;HERE TO CALL UFDSET TO SET UP UFDS

GETUFD:	MOVE	A,USRPPN	;USER'S PPN
	MOVE	N1,MFDPPN	;MFD PPN
	MOVE	M,FSNAME	;NAME OF STR
	MOVEI	IO,W.TTY
	PUSHJ	P,UFDSET
	  JRST	MONRET		;GIVE UP
	JRST	MNTFIN		;FINISH UP
;HERE TO COMPILE A TABLE OF THE STATUS OF ALL DRIVES IN THE SYSTEM
;DRIVE=DRIVE MNEMONIC
;DRVSTT=0 IF DRIVE NOT AVAILABLE
;      NON-0 IF AVAILABLE, WITH RH=RH OF DSKCHR RETURN


FNDPAK:	SETZB	M,TEMBP
	SETZB	WD,DROFFL	;AND CLEAR THE FIRST IN CASE NOT SO
	MOVEI	IO,W.TTY	;SET IO FOR ERROR MESSAGES
FNDPK1:	SYSPHY	WD,		;RETURNS NEXT PHYSICAL DEVICE IN SYSTEM
	 JRST	ERR10		;THERE'S A PROBLEM HERE (NO SUCH DEVICE)
	JUMPE	WD,USRDR	;0 MEANS END OF DEVICES
	MOVEM	WD,CHRBUF
	MOVEM	WD,DRIVE(M)	;SAVE DRIVE IN CASE IT IS USEABLE
	MOVE	A,[XWD CHRNAM+1,CHRBUF]
	DSKCHR	A,		;FIND OUT WHAT WE HAVE
	  JRST	FNDPK1		;MUST NOT HAVE BEEN A DISK
	LDB	CH,D.ARGT	;GET TYPE OF ARGUMENT
	CAIE	CH,A.PUN	;SKIP IF WE HAVE A PHYSICAL UNIT
	JRST	FNDPK1		;NO
	LDB	CH,D.UST	;IS DRIVE AVAILABLE?
	CAIN	CH,2
	JRST	FNDPK5		;YES
	MOVEI	CH,2		;NO--CK FOR 'DORMANT' F/S
	TLNN	A,D.INFS	;SKIP IF NOT IN FILE STRUCTURE
	TLNE	A,D.MC		;SKIP IF MOUNT COUNT NOT = 0
	DPB	CH,D.UST	;ITS DORMANT SO MAKE IT AVAILABLE
FNDPK5:	MOVEM	A,DRVSTT(M)	;SAVE STATUS OF DRIVE
	AOJA	M,FNDPK1	;ALL DONE WITH THIS UNIT
;HERE TO LOOK FOR THE SPECIAL DRIVES THE USER REQUESTED


USRDR:	MOVN	M,M
	HRLZM	M,NUMDRV	;STORE NUMBER OF DRIVES IN SYSTEM
	SKIPN	NUMREQ		;SKIP IF USER ACTUALLY SPECIFIED SOMETHING
	JRST	ANYDRV		;ELSE FORGET THIS
	MOVNI	D,(NUM)
	HRLZ	C,D
USRDR1:	MOVE	A,USRDRV(C)	;GET NEXT DRIVE USER SPECIFIED
	TRNN	A,-1		;SKIP IF SPECIFIC DRIVE
	JRST	USRDR2		;NO, IGNORE THIS REQUEST
	PUSHJ	P,FNDDRV	;FIND THIS DRIVE IN THE DRIVE TABLE
	  JRST	ERR25		;WOULD YOU BELIEVE, NO SUCH DRIVE
	MOVE	A,DRVSTT(B)
	LDB	E,D.KONT	;E=CONTROLLER TYPE
	LDB	CH,KTPBYT	;CH=CONTROLLER TYPE NEEDED
				;(BYTE POINTER IS MODIFIED BY C)
	CAIN	CH,(E)		;SKIP IF WRONG KONTROLLER TYPE
	JRST	USRD1B		;OK
	MOVEI	M,WKTM
	PUSHJ	P,USPROB
	JRST	USRDR2
USRD1B:	LDB	E,D.UNIT	;E=UNIT TYPE
	LDB	CH,UTPBYT	;GET TYPE OF DRIVE REQUIRED
				;(BYTE POINTER IS MODIFIED BY C)
	CAIN	CH,(E)		;COMPARE WITH THIS DRIVE
	JRST	USRD1A		;OK
	MOVEI	M,WUTM		;WRONG UNIT TYPE
	PUSHJ	P,USPROB
	JRST	USRDR2

USRD1A:	LDB	CH,D.UST	;IS IT AVAILABLE?
	JRST	USRD1C		;UNIT IS AVAILABLE
	MOVEI	M,DNAM
	PUSHJ	P,USPROB
	JRST	USRDR2

USRD1C:	TLZ	A,B.UST		;MAKE IT UNAVAILABLE NOW
	MOVEM	A,DRVSTT(B)
USRDR2:	AOBJN	C,USRDR1
;HERE TO LOOK FOR DRIVES ON SPECIFIC CONTROLLERS THE USER REQUESTED

	HRLZ	C,D		;RESET NUMBER OF DRIVES REQUESTED
USRCON:	SKIPN	A,USRDRV(C)	;SKIP IF SOMETHING TO LOOK AT
	JRST	USRCN5
	TRNE	A,-1		;SKIP IF CONTROLLER ONLY REQUEST
	JRST	USRCN5		;SPECIFIC DRIVE - WE'VE ALREADY SEEN IT
	MOVE	B,[XWD 1,A]	;IS THIS A REAL CONTROLER?
	DSKCHR	B,
	  JRST	USRC1C		;NO
	LDB	N,UTPBYT	;YES-GET TYPE OF UNIT WE NEED
	PUSHJ	P,FNDCON	;LOOK FOR DRIVE ON THIS CONTROLLER
	  JRST	.+2		;NONE AT ALL?
	JRST	USRC1A		;OK
	MOVEI	M,KDNAM
	PUSHJ	P,USPROB
	JRST	USRCN5
USRC1A:	LDB	N1,D.KONT	;KONTROLLER TYPE
	LDB	N,KTPBYT	;TYPE NEEDED
	CAMN	N,N1		;SKIP IF WRONG KONTROLLER TYPE
	JRST	USRC1B		;OK
	MOVEI	M,WKTM
	PUSHJ	P,USPROB
	JRST	USRCN5
USRC1C:	MOVEI	M,IKON	;TELL USER 'NO SUCH CONT.
	PUSHJ	P,USPROB
	JRST	USRCN5

USRC1B:	TLZ	A,B.UST
	MOVEM	A,DRVSTT(B)	;SET THIS DRIVE UNAVAILABLE
USRCN5:	AOBJN	C,USRCON	;LOOP FOR ALL USER REQUESTS

;HERE TO FIND DRIVES FOR THE REST OF THE PACKS

ANYDRV:	HRLZ	C,D		;RESET NUMBER OF DRIVES REQUESTED
ANYDR1:	SKIPE	M,USRDRV(C)	;SKIP IF WE STILL NEED A DRIVE HERE
	JRST	ANYDR5		;NO, ALREADY TAKEN CARE OF
	LDB	N1,KTPBYT	;N1=KONTROLLER TYPE NEEDED
	LDB	N,UTPBYT	;GET TYPE OF UNIT NEEDED
	MOVE	B,NUMDRV
ANYDR2:	MOVE	A,DRVSTT(B)	;SKIP IF DRIVE AVAILABLE
	LDB	CH,D.UST
	CAIE	CH,2
	JRST	ANYDR3		;NO
	LDB	E,D.KONT		;E=KONTROLLER TYPE
	CAME	N1,E		;SKIP IF OK
	JRST	ANYDR3
	LDB	E,D.UNIT	;E=UNIT TYPE
	CAMN	N,E		;SKIP IF NO GOOD
	JRST	ANYDR4		;OK, GOT ONE
ANYDR3:	AOBJN	B,ANYDR2	;LOOP FOR THE DRIVES
	JRST	ERR14		;COULDN'T MAKE IT
ANYDR4:	TLZ	A,B.UST
	MOVEM	DRVSTT(B)	;SET THIS DRIVE UNAVAILABLE
ANYDR5:	AOBJN	C,ANYDR1
	JRST	OPREQ0
ERR14:	MOVEI	M,NEDAM
	PUSHJ	P,MSGTTY	;TELL USER NOT ENOUGH DRIVES AVAIL


OPREQ0:	PUSHJ	P,QUEREQ
	MOVEI	M,OPMNT
	PUSHJ	P,OPREQ2
	JRST	MNTFIN
;HERE TO REQUEST OPER TO MOUNT THE FILE STRUCTURE

QUEREQ:	SETZM	TAPEID
	SETZM	FILBLK
	HRLI	NUM,(SIXBIT .M.)
	PUSHJ	P,COMBEG	;SET UP THE COMMAND FILE
	TEXT	< MOUNT >
	PUSHJ	P,MSG
	SKIPN	M,PHYNAM
	MOVE	M,CMDFSN
	PUSHJ	P,SIXMSG
	SKIPN	LOGNAM
	JRST	OPRQ1A
	PUSHJ	P,SPACE
	MOVE	M,LOGNAM
	PUSHJ	P,SIXMSG
OPRQ1A:	PUSHJ	P,VIDOUT	;OUTPUT /VID IF ANY
	TEXT	< /S>
	TLNE	F,L.SIN
	PUSHJ	P,MSG
	TEXT	< /WL>
	TLNE	F,L.WRTL
	PUSHJ	P,MSG
	TEXT	< /WE>
	TLNE	F,L.WEN
	PUSHJ	P,MSG
	SKIPN	UDREQ		;SKIP IF USER REQUESTED SPECIFIIC UNITS
	JRST	OPRQ1C
	PUSHJ	P,LPAR
	MOVN	N,NUMREQ
	HRLZS	N
	SKIPA
OPRQ1D:	PUSHJ	P,COMMA
	MOVE	M,USRDRV(N)
	PUSHJ	P,SIXMSG
	AOBJN	N,OPRQ1D
	PUSHJ	P,RPAR
OPRQ1C:	PJRST	CRLF
MNTFIN:	MOVE	A,HLISTI	;BUILD IOWD LST IN LOW SEG.
	MOVEM	A,HLIST
	SETZM	HLIST+1
	MOVEI	A,17
	SETZ	C,
	MOVE	B,FSNAME
	OPEN	USR,A		;SEE HOW IT ALL CAME OUT
	  JRST	ERR6A
	MOVEI	IO,W.TTY
	MOVE	A,[SIXBIT .HOME.]
	MOVSI	B,(SIXBIT .SYS.)
	SETZB	C,LASTUN	;CLEAR LAST UNIT TYPED
	MOVE	D,SYSPPN
	LOOKUP	USR,A		;LOOKUP HOME.SYS[SYS] TO READ HOME BLOCKS
	  JRST	NOFNTY		;NO SUCH ANIMAL, CANT FIND OUT
NXUNTY:	INPUT	USR,HLIST	;READ NEXT BLOCK
	STATZ	USR,20000	;SKIP UNLESS EOF
	JRST	NOFNTY
	MOVS	A,B.USR	;FIRS WORD
	CAIE	A,(SIXBIT .HOM.);MUST BE .HOM. OR IS NOT A HOME BLOCK
	JRST	NXUNTY
	MOVE	M,B.USR+HOMLOG	;GET SIXBIT LOGICAL UNIT IN STR
	CAMN	M,LASTUN	;NO SKIP IF ALREADY TYPED
	JRST	NXUNTY		;UNITS HAVE TWO HOME BLOCKS
	MOVEI	A,M
	DSKCHR	A,		;GET PHYSICAL UNIT
	  JRST	NXUNTY		;DOESN'T EXIST?
	MOVEM	M,LASTUN	;SAVE UNIT WE ARE ABOUT TO TYPE
	MOVE	M,B.USR+HOMHID	;GET UNIT ID
	PUSHJ	P,SIXMSG	;TYPE IT
	MOVEI	M,[ASCIZ . ON .]
	PUSHJ	P,MSG
	PUSHJ	P,UNISET	;SET UP UNIT MNEMONIC IN B
	MOVE	M,B
	PUSHJ	P,SIXMSG
	PUSHJ	P,CRLF
	JRST	NXUNTY
NOFNTY:	PUSHJ	P,CRLF		;TYPE CR,LF
	MOVE	M,CMDFSN
	PUSHJ	P,SIXMSG	;AND FILE STRUCTURE NAME
	MOVEI	M,MNTD
	PUSHJ	P,MSG		;MOUNTED
;NOW CHECK FOR USERS UFD

	MOVEI	A,14		;OPEN USR ON F.S.
	MOVE	B,FSNAME
	MOVEI	C,RH.USR
	OPEN	USR,A
	  JRST	NOFNT2		;CANT OPEN
	MOVEI	A,B.USR		;DECLAIR 1 BUFFER
	MOVEM	A,JOBFF
	INBUF	USR,1
	MOVE	A,USRPPN	;LOOKUP UFD
	MOVSI	B,(SIXBIT/UFD/)
	SETZM	C
	MOVE	D,MFDPPN
	LOOKUP	USR,A		;IS IT THERE AND ACCESSIBLE?
	  SKIPA			;NO
	JRST	ALLOVR		;YES-THATS ALL
NOFNT2:	MOVEI	M,[ASCIZ/NO UFD CREATED
/]		;TELL USER NO UFD
	JRST	ALLFIN



OPREQ2:	PUSHJ	P,MSGTTY	;TELL USER ALL ABOUT IT
TMWAIT:	MOVE	A,NAMMNT
	PUSHJ	P,WAKE0
	  PUSHJ	P,MSG113	;TELL USER NO OPERATOR JOB
	TLNN	F,L.PWA		;SKIP IF USER REQUESTED PAUSE BEFORE WAITING
	JRST	DOWAIT		;NO, CLOSE OUT COMMAND AND WAIT
	MOVEI	M,PBWM
	PUSHJ	P,MSGTTY
	TTCALL	CLRINB,		;CLEAR INPUT BUFFER
	PUSHJ	P,GETARG
	PUSHJ	P,CCTYP1	;ONLY RETURN IN NOT ^C
	JRST	DOWAT1		;WAIT

DOWAIT:	MOVEI	A,1		;GIVE USER A CHANCE TO RESPOND
	SLEEP	A,
	PUSHJ	P,CCTYPE
DOWAT1:	PUSHJ	P,MSG111	;TELL USER WE ARE WAITING
	CLOSE	CMD,
MNTWAT:	MOVE	A,NAMMNT	;WAKE AN OMOUNT
	PUSHJ	P,WAKE1
	  JFCL
	MOVEI	A,MOUSLP	;AND HIBERNATE TILL WAKE OR ^C
	PUSHJ	P,WAIT0
	MOVE	A,CMDNAM	;NOW SEE IF OUR COMMAND STILL EXISTS
	MOVSI	B,(SIXBIT .CMD.)
	MOVEI	C,0
	MOVE	D,CMDPPN
	LOOKUP	CMD,A		;LOOK FOR THE FILE
	  POPJ	P,		;DONE! TELL USER
	JRST	MNTWAT		;STILL WAITING FOR SERVICE
;SUBROUT TO WAKE APPROPRIATE OMOUNTS
;ENTER	WAKE0 DONT WAKE, JUST CHK. FOR OMOUNTS
;	WAKE1 WAKE ALL APPROPRIATE OMOUNTS
;CALL:	A=OMOUNT JOB NAME OTHER THAN SYSOMO
;RET+1	IF NO APPROPRIATE OMOUNTS
;RET+2	IF WAS SOME OMOUNTS

WAKE0:	TDZA	B,B	;LH=0 FOR 'DONT WAKE'
WAKE1:	MOVSI	B,-1	;LH=-1 FOR 'WAKE'
	MOVEI	C,1	;COUNT JOB NUMS IN C
WAKE2:	MOVEI	D,JBTPRG	;GET THIS JOB NAME
	HRL	D,C
	GETTAB	D,
	  POPJ	P,
	CAMN	D,NAMOMO	;IS IT SYSOMO
	JRST	WAKE3
	CAME	D,A	;  OR SPECIFIC NAME?
	AOJA	C,WAKE2	;NO-CK NEXT JOB
WAKE3:
IFE DBUGSW,<	;IF DEBUGGING DONT REQUIRE [1,2] OMOUNT
	MOVEI	D,PRJPRG	;YES-PPN 1,2?
	HRL	D,C
	GETTAB	D,
	  POPJ	P,
	CAME	D,[XWD 1,2]
	AOJA	C,WAKE2		;NO-FORGET IT
> ;IFE DBUGSW
	HRLZ	D,C	;GET JBTSTS
	GETTAB	D,
	  POPJ	P,
	JUMPGE	D,WAKE4	;JUMP IF NOT RUNNING
	TRON	B,-1	;IS THIS 1ST ONE WEVE SEEN?
	AOS	(P)	;YES-REMEMBER TO SKIP RETURN
	JUMPGE	B,WAKE4	;DONT WAKE IF ENTERED WAKE0
	WAKE	C,		;YES-WAKE IT UP
	  POPJ	P,
WAKE4:	AOJA	C,WAKE2


;SUBROT TO WAIT FOR ^C OR WAKEUP FROM OMOUNT
;CALL:	A=NUM OF SECONDS TO SLEEP
;	EXITS IF ^C TYPED

WAIT0:	PUSHJ	P,CCTYPE	;CK FOR ^C
WAIT1:	MOVEI	B,^D60000
	HRLI	B,HIBNOJ!HIBTTL!HIBSWP
	HIBER	B,
	  SLEEP	A,		;INCASE OLD MONITOR
	PJRST	CCTYPE		;CK ^C AGAIN
;SUBROUTINE TO COMPUTE SIXBIT LOGICAL UNIT IN STR
;ARGS	TEMBP=BYTE POINTER SET FOR IDPB
;	D(RH)=BINARY LOG. UNIT NUM IN STR
;VALUES	B=SIXBIT LUN

FILDPT:	MOVE	B,FSNAME	;START WITH NAME OF STR
	MOVE	BP,TEMBP	;BYTE POINTER
	MOVEI	N,(D)		;N=LOGICAL UNIT NUM
	IDIVI	N,^D10
	JUMPE	N,FILDP1	;JUMP IF ONLY 1 DIGIT
	ADDI	N,(SIXBIT .  0.) ;MAKE SIXBIT
	IDPB	N,BP		;STORE IN NAME
FILDP1:	ADDI	N1,(SIXBIT .  0.) ;MAKE NEXT DIGIT SIXBIT
	TLNE	BP,770000	;SKIP IF NAME FULL
	IDPB	N1,BP		;STORE IN NAME
	POPJ	P,

;SUBROUTINE TO DETERMINE IF  ^C WAS TYPED
;IF YES, EXIT, ELSE RETURN

CCTYPE:	TTCALL	SKPINL,		;SKIP IF ANYTHING WAS TYPED
	  POPJ	P,		;NO, JUST RETURN
	PUSHJ	P,GETARG	;SEE WHAT IT WAS
CCTYP1:	CAIE	CH,CNTRLC	;SKIP IF ^C
	CAIN	CH,ALTMO	;OLD SCNSRF TURNS ^C TO ALTMODE
	JRST	.+2		;EITHER ONE WILL DO FOR AN EXIT
	POPJ	P,
	CLOSE	CMD,40		;ABORT COMMAND FILE IF NOT CLOSED YET
	EXIT	1,
	EXIT

;SUBROUTINE TO COMPUTE UNI NAME IN B FROM DSKCHR RETURN IN A
;ARGS	A=AC RETURN FROM DSKCHR
;VALUES	B=SIXBIT UNIT MNEMONIC

UNISET:	LDB	C,D.KONT	;GET CONTROLLER TYPE
	MOVE	B,KONSIX(C)	;SIXBIT MNEMONIC
	LDB	C,D.KONN	;GET CONTROLLER NUMBER
	ADDI	C,(SIXBIT .  A.) ;CONVERT TO LETTER A,B,C ETC
	TLO	B,(C)		;STORE LETTER IN NAME
	LDB	C,D.UNIN	;GET UNIT NUMBER
	ADDI	C,(SIXBIT .  0.) ;CONVERT TO SIXBIT
	DPB	C,[POINT 6,B,23]
	POPJ	P,
	;THIS ROUTINE SEARCHES THE DRIVE TABLE FOR A SPECIFIC DRIVE
	;ENTER A=SPECIFIC DRIVE (LEFT JUSTIFIED SIXBIT)
	;NON-SKIP RETURN IF NOT FOUND
	;SKIP RETURN IF FOUND, B=INDEX INTO TABLE

FNDDRV:	MOVE	B,NUMDRV
FNDRV1:	CAMN	A,DRIVE(B)	;LOOK FOR A MATCH
	JRST	CPOPJ1		;SKIP RETURN IF WE FOUND IT
	AOBJN	B,FNDRV1	;LOOP FOR ALL DRIVES
	POPJ	P,		;NON-SKIP RETURN IF NOT THERE



;THIS ROUTINE SEARCHES THE DRIVE TABLE FOR AN AVAILABLE DRIVE ON A SPECIFIC CONTROLLER.
;ARGS	A=CONTROLLER (LEFT JUSTIFIED SIXBIT)
;	N=UNIT TYPE NEEDED
	;ENTER AT FNDCON TO START AT THE BEGINNING OF THE TABLE
;ENTER AT FNDCN1 TO CONTINUE WHERE WE LEFT OFF LAST
;NON-SKIP RETURN IF NOT FOUND
;SKIP RETURN IF FOUND, B=INDEX INTO TABLE

FNDCON:	MOVE	B,NUMDRV	;START AT BEGINNING OF TABLE
	SKIPA	E,A		;SAVE CONTROLLER NEEDED IN E
FNDCN1:	AOBJP	B,CPOPJ		;TRY NEXT IN TABLE, EXIT IF LAST
	HLLZ	A,DRIVE(B)	;GET CONTROLLER PART OF NEXT DRIVE
	CAMN	A,E		;COMPARE WITH WHAT WE WANT
	MOVE	A,DRVSTT(B)	;OK, IS IT AVAILABLE?
	LDB	N1,D.UST
	CAIE	N1,2
	JRST	FNDCN1		;NO--NO GOOD TO US, TRY NEXT
	LDB	N1,D.UNIT	;YES-N1=UNIT TYPE
	CAIE	N,(N1)		;SKIP IF RIGHT TYPE OF UNIT
	JRST	FNDCN1		;ALAS
	JRST	CPOPJ1		;EVERYTHING OK, SKIP RETURN



;SUBROUTINE TO SKIP WORDS ON FILE OPEN ON CHANNEL USR
;	ARGS	B=NUMBER OF WORDS TO SKIP

SKPSTR:	PUSHJ	P,R.USR		;GET NEXT WORD FROM STRLST
	  JRST	ERR17
	SOJG	B,SKPSTR	;B CONTAINS THE NUMBER OF WORDS TO SKIP
	POPJ	P,		;RETURN

;THIS ROUTINE OUTPUTS A LIST OF SIXBIT ITEMS POINTED TO BY N.
;ENTER N=XWD -NUMBER OF WORDS, FIRST WORD ADDRESS OF THE TABLE

SNDLST:	MOVE	M,(N)
	PUSHJ	P,SIXMSG	;OUTPUT THE NEXT ITEM
	AOBJP	N,CRLF		;IF ALL DONE, OUTPUT CR,LF
	PUSHJ	P,COMMA		;ELSE PUT COMMAS BETWEEN
	JRST	SNDLST
ERR1:	ERRMES <?CANT FIND STRLST.SYS>
ERR2A:	STATO	USR,20000	;SKIP IF EOF
	JRST	ERR17		;NO, READ ERROR
ERR2:	ERRMES <?STRUCTURE NOT IN STRLST.SYS>
ERR17:	ERRMES <?CANT READ STRLST.SYS>
ERR4:	ERRMES <?UNCERTIFIED PACKS MAY NOT BE SHARED>
ERR5:	ERRMES <?MUST BE IN OWNERS PROJECT TO REQUEST SINGLE ACCESS>
ERR6:	MOVE	IO,FSNAME
	MOVEM	IO,UFDFSN
	MOVEI	IO,W.TTY
	PUSHJ	P,DISSTR
	ERRMES <STRUCTURE NOT MOUNTED>
ERR10:	ERRMES <?SYSTEM ERROR - SYSPHY UUO FAILED>
ERR21:	ERRMES <?FILE STRUCTURE LOCKED OUT BY OPERATOR>
ERR25:	MOVEI	CH,"?"
	MOVEI	IO,W.TTY	;SET UP IO FOR SIXMSG
	PUSHJ	P,W.TTY
	MOVE	M,A
	PUSHJ	P,SIXMSG	;M=DRIVE WHICH ISN'T A DRIVE
	ERRMES < ILLEGAL UNIT>
ERR26:	ERRMES <?NO SYS>
ERR27:	ERRMES <?SYSTEM ERROR - WRONG FORMAT VERSION NUMBER IN STRLST.SYS>
ERR29:	MOVEI	M,SABJM
	PUSHJ	P,MSGTTY
	MOVE	N,B
	PUSHJ	P,DECPRT
	PUSHJ	P,CRLF
ERR6A:	ERRMES <?MOUNT UNSUCCESSFUL>

ERRMSB:	PUSHJ	P,MSGTTY
	PUSHJ	P,CRLF
	EXIT	1
	EXIT

>	;END CONDITIONAL ON MNTSW

IFE MNTSW,<LIST>
;SUBROUTINE TO SEARCH A TABLE FOR A COMMAND THAT WAS TYPED AND DISPATCH APPROPRIATELY
;ARGS	E=AOBJN POINTER TO LEGAL COMMANDS
;	2ND LOCATION BEFORE TABLE IS'NON-UNIQUE SWITCH' ERROR ADDRESS
;	1ST LOCATION BEFORE TABLE IS 'NON-EXISTANT SWITCH' ERROR ADRESS

UDSWIT:
;	TLNE	F,L.BRK		;SKIP UNLESS BREAK CHAR DETECTED
;	JRST	COMERR
	PUSHJ	P,GETARG	;GET SWITCH
	HLLZS	A		;KEEP ONLY FIRST THREE CHARS
	JUMPE	A,@-1(E)	;ERROR RET. IF NO NAME
	SETO	C,		;FIRST TRY FOR EXACT MATCH
	MOVE	D,E		;SAVE PTR IN D
	PUSHJ	P,SWPROC	;TRY TO FIND SWITCHES
	  JRST	.+2
	JRST	(B)		;MADE IT, DISPATCH
	PUSHJ	P,GETMSK	;CREATE MASK IN C FOR CHARS TYPED
	TRO	C,-1		;SET RH TO KEEP DISPATCH ADDR IN XOR
	MOVE	E,D		;RESET PTR TO TABLE OF SWITCHES
	PUSHJ	P,SWPROC	;TRY AGAIN
	  JRST	@-1(D)		;NO SUCH SWITCH
	AOBJP	E,(B)		;FOUND ONE, DISPATCH IF LAST IN LIST
	HRR	A,B		;SAVE DISPATCH ADDR
	PUSHJ	P,SWPROC	;LOOK FOR DOUBLE MATCH (NOT UNIQUE)
	  JRST	(A)		;NONE, OK, SO DISPATCH
	JRST	@-2(D)

;SUBROUTINE TO SEARCH TABLE FOR MASKED MATCH
;ARGS	A=CHARS TYPED (LEFT HALF ONLY)
;	C=MASK
;	E=AOBJN POINTER TO TABLE OF LEGAL COMMANDS

SWPROC:	HLLZ	B,A		;B=CHARS TYPED
	XOR	B,(E)		;COMPARE WITH NEXT SWITCH IN LIST
	AND	B,C		;KEEP ONLY NUM CHARS TYPED
	TLNN	B,-1		;ZERO IF MATCH
	JRST	CPOPJ1		;OUR WORK IS OVER, RH B=DISPATCH ADDR
	AOBJN	E,SWPROC	;LOOP FOR ALL SWITCHES IN LIST LOOKING FOR MAT
	POPJ	P,		;SADLY NONE

;SUBROUTINE TO CREATE A MASK IN C FOR ACTUAL CHARACTERS IN A
;ARGS	A=SIXBIT CHARACTERS
;VALUES	C=MASK OF ALL ONES IN NON-ZERO CHARACTER POSITIONS

GETMSK:	SETZ	C,		;ASSUME NO CHARS
	JUMPE	A,CPOPJ		;JUMP IF ASSUMPTION PROVES VALIDATED
	TLO	C,770000	;NO, MUST BE AT LEAST ONE CHAR
	PUSH	P,A		;SAVE A
GETMS1:	LSH	A,6		;SHIFT OFF CHARACTER WE KNOW ABOUT
	JUMPE	A,APOPJ		;EXIT IF NO MORE
	ASH	C,-6		;AT LEAST ONE MORE, EXTEND MASK ONE CHAR
	JRST	GETMS1		;AND LOOP
APOPJ:	POP	P,A		;RESTORE A
	POPJ	P,
;SUBROUTINE TO SET UP AND WRITE FIRST LINE OF A QUEUE REQUEST
;ARGS	NUM=SIXBIT CHAR IDENTIFYING TYPE OF MESSAGE

COMBEG:	SETZ	A,		;COME BACK HERE TO WRITE OUT COMMAND
	MOVE	B,CMDSTR	;STR FOR COMMANDS
	HRLZI	C,WH.CMD
	OPEN	CMD,A
	  JSP	N,CMDERR

FILCL1:	HLLZ	WD,NUM		;NUM CONTAINS THE TYPE OF MESSAGE
	CALLI CH,CI.CTM		;CHAR 2&3 ARE 12 LOW ORD OF TIMER
	ANDI	CH,7777		;ONLY LOW 12 WANTED
	TLO	WD,(CH)		;PUT IN LH OF NAME
	IOR WD,IORPPN		;RH OF NAME IS IOR'D PPN
	CAMN WD,CMDNAM		;NEW NAME SAME AS LAST TRY?
	JRST	FILCL1		;YES - TRY AGAIN FOR A DIFFERENT ONE
	MOVEM WD,CMDNAM		;SAVE THIS NAME
	MOVE A,CMDNAM
	MOVSI B,(SIXBIT /CMD/)	;EXTENSION
	MOVEI C,0
	MOVE D,CMDPPN		;COMMAND AREA
	LOOKUP CMD,A		;DOES THIS FILE ALREADY EXIST?
	  TRNE B,-1		;MAYBE
	JRST FILCL1		;YES
	MOVSI B,(SIXBIT /CMD/)	;NO
	MOVEI C,0
	MOVE D,CMDPPN
	ENTER CMD,A		;IF THIS WORKS
	  JRST FILENF		;PITY
	MOVEI IO,B.CMD		;WE CAN USE IT
	MOVEM IO,JOBFF
	OUTBUF CMD,1
FILOUT:	MOVEI IO,W.CMD
	MOVE CH,CMDCHR
	PUSHJ P,0(IO)		;WRITE COMMAND CLASS
	MOVEI M,[ASCIZ / JOB/]
	PUSHJ P,MSG		;JOB
	MOVE N,JOBNO
	PUSHJ P,DECPRT		;JOB NUMBER
	PUSHJ P,SPACE		;SPACE
	SKIPN M,TTYLIN		;TTYN IF KNOWN
	MOVE M,[SIXBIT /TTYXXX/]
	PUSHJ P,SIXMSG
	PUSHJ P,SPACE		;SPACE
	HLRZ N,USRPPN
	PUSHJ P,OCTPRT		;USER'S PPN
	PUSHJ P,COMMA
	HRRZ N,USRPPN
	PUSHJ P,OCTPRT
	PUSHJ P,SPACE		;SPACE
	SKIPN M,TAPEID		;AND THE TAPE NUMBER
	MOVSI M,(SIXBIT /1/)
	PUSHJ P,SIXMSG
	SKIPN FILBLK		;NOW ANY FILES MENTIONED
	POPJ	P,		;NONE
FILOU1:	MOVEI D,0
	PUSHJ P,SPACE
FILOUL:	SKIPN FILBLK(D)
	POPJ	P,
	SKIPE D		;NO COMMA FIRST TIME
	PUSHJ P,COMMA
	SKIPN	M,FILDEV(D)
	MOVSI	M,(SIXBIT .DSK.)
	PUSHJ	P,SIXMSG
	MOVEI	CH,":"
	PUSHJ	P,(IO)
	MOVE M,FILBLK(D)
	PUSHJ P,SIXMSG		;FILE NAME(EVEN IF *, PASSED ON TO OPFILE)
	SKIPE M,FILBEX(D)
	PUSHJ P,DOT		;PERIOD IF EXT COMMING
	SKIPE M,FILBEX(D)
	PUSHJ P,SIXMSG		;EXT IF SPECIFIED
	AOJA D,FILOUL
FILENF:	HRRZS	B
	CAIN	B,NRMERR
	JRST	NOROOM
	CAIN	B,NUFERR
	JRST	NOCMU1
	CAIN	B,FBMERR
	JRST	FILCL1
FILLOS:	PUSHJ	P,MSG900
	JRST	NOCMU1

NOROOM:	MOVEI	M,NORMMS
	JRST	ERREXI

HPACK:	SETZ N,			;SUBR TO GET A WORD AND PACK OCTAL
HPACKL:	PUSHJ P,0(IO)		;READ A CHAR
	CAIE CH," "		;BLANK OR COMMA
	CAIN CH,","		;TERMINATES FIELD
	POPJ P,0		;EXIT IF TERMINATED
	ANDI CH,7		;SAVE ONLY OCTAL PART
	LSH N,3			;MAKE ROOM FOR A NEW DIGIT
	IOR N,CH		;PACK DIGIT INTO WORD
	JRST HPACKL		;BACK FOR NEXT DIGIT

;SUBROUTINE TO TYPE A USER'S REQUEST AND A MESSAGE FOLLOWING
;ARGS	M=ADDRESS OF ASCIZ MESSAGE

USPROB:	PUSH	P,M
	MOVE	M,USRDRV(C)
	PUSHJ	P,SIXMSG
	POP	P,M
	PUSHJ	P,MSG
	PJRST	CRLF

;THIS ROUTINE OUTPUTS ACCUMULATOR N AS A DECIMAL NUMBER

DECPR2:	MOVEI CH,60
	CAIG N,^D9
	PUSHJ P,0(IO)
	PJRST	DECPRT

;SUBROUTINE TO READ F.S. NAME & IGNORE TRAILING COLON

REDEV:	PUSHJ	P,SST
	PUSHJ	P,SIXBRD
	CAIE	CH,":"
	POPJ	P,
	PJRST	(IO)
;THIS ROUTINE SCANS TTY TO THE FIRST
;NON-ALPHANUMERIC CHAR, FIRST 6 CHARS TO A IN SIXBIT,
;CH IS TERMINATING CHAR

GETARG:	TLZ F,L.CMA+L.DOT+L.BRK+L.SPC
	MOVEI IO,R.TTY
	PUSHJ P,SSIXBR		;GET CHARS
GETAR2:		;HERE FROM GEFARG
	CAIN	CH,"["		;BRACKET?
	TLO	F,L.BRAK
	CAIN CH,","
	TLO F,L.CMA		;COMMA TERMINATOR
	CAIN CH,"."
	TLO F,L.DOT		;PERIOD TERMINATOR
	CAIE CH,11		;TAB
	CAIN CH,40
	TLO F,L.SPC		;OR SPACE TERMINATOR
	CAIE CH,33		;ALT MODE
	CAIGE CH,15
	TLO F,L.ARGD+L.BRK	;OR OTHER BREAK CHAR
	POPJ P,0

;LIKE GETARG EXCEPTS ALSO ACCEPTS * (& SETS L.WLD)

GEFARG:	PUSHJ	P,GETARG
	JUMPN	A,CPOPJ
	CAIE	CH,"*"
	POPJ	P,
	TLO	F,L.WLD
	MOVSI	A,'*  '
	PUSHJ	P,(IO)
	PJRST	GETAR2
;THIS ROUTINE SCANS THE INPUT DEVICE, SKIPS LEADING SPACES OR TABS
;AND STORES ALPHANUMBERIC CHARS WITH BYTE POINTER BP

SSIXBR:	PUSHJ P,SSST		;SKIP LEADING TABS OR SPACES
SIXBRD:	SETZB A,B		;RETURNS FIRST NON-SPACE IN CH
	MOVE BP,[XWD 440600,A]
SIXBRL:	CAIL CH,"A"
	CAILE CH,"Z"
	SKIPA		;NOT LETTER
	JRST SIXBR1
	CAIL CH,"0"
	CAILE CH,"9"
	JRST SIXBRX
SIXBR1:	SUBI CH,40		;CONVERT TO SIXBIT
	ADDI	B,1		;COUNT LENGTH OF STRING
	TLNE BP,770000
	IDPB CH,BP
	PUSHJ P,0(IO)		;GET NEXT CHAR IN CH
	JRST SIXBRL
SIXBRX:	POPJ P,0


;FLUSH THIS ITEM (IF ANY) AND FOLLOWING TABS & SPACES

SSSST:	CAIE	CH,33	;EOL?
	CAIG	CH,14
	JRST	SST3	;YES
	CAIE	CH,40	;NO--DELIMITER?
	CAIN	CH,11
	JRST	SSST	;YES-FIND BEG OF NEXT ITEM
	PUSHJ	P,(IO)	;NO--GET NEXT CHAR
	JRST	SSSST
;THIS ROUTINE IGNORES LEADING TABS OR SPACES ON INPUT

SSST:	PUSHJ P,0(IO)
SST:	CAIE CH,11
	CAIN CH,40
	JRST SSST
	CAIE	CH,CHRLIN	;LINE CONTINUATION?
	JRST	SST2
	PUSHJ	P,(IO)	;YES-IGNORE IT
	PUSHJ	P,SST2	;   AND GOBBLE BREAK CHAR IF ANY
	TLZN	F,L.EOL
	POPJ	P,
	JRST	SSST
SST2:	CAIE	CH,33	;SET BIT IF END OF LINE
	CAIG	CH,14
SST3:	TLO	F,L.EOL
	POPJ P,0
;SUBRS

DOT:	JSP M,MSG
	ASCIZ /./
COMMA:	JSP M,MSG
	ASCIZ /,/
SPACE:	JSP M,MSG
	ASCIZ / /
LPAR:	JSP	M,MSG
	ASCIZ/ (/
RPAR:	JSP	M,MSG
	ASCIZ/) /
QUEST:	JSP	M,MSG
	ASCIZ/? /

CLRLIN:	CAIE CH,33
	CAIG CH,14
	POPJ P,0
	PUSHJ P,R.TTY
	JRST CLRLIN

MSGTTY:	MOVEI IO,W.TTY
	PJRST	MSG

NOCMU:	TRNE B,-1
	JRST START1
NOCMU1:	MOVEI M,CMMMSG
	JRST ERREXI
;I/O SUBRS

R.TTY:	TLZE F,L.TYO
	OUTPUT TTY,0		;OUTPUT ANY CHARS LEFT HANGING AROUND
	SOSLE RH.TTY+2
	JRST R.TOK
	INPUT TTY,0
	STATZ TTY,760000
	  JSP	N,TTYERR
R.TOK:	ILDB CH,RH.TTY+1
	JUMPE CH,R.TTY
	CAIE CH,177		;IGNORE RUBOUT
	CAIN CH,15		;OR CR
	JRST R.TTY
	CAIL CH,175		;CHANGE 175,176 TO ALTMO
	MOVEI CH,ALTMO		;WHICH IS ALTMODE
	CAIL CH,140
	TRZ CH,40		;CHANGE LOWER CASE TO UPPER
	TLNN	F,L.LVD		;IF LEVEL C, SCNSRF MAKES ALT OUTOF ^C
	CAIE	CH,ALTMO
	CAIN	CH,3		;EXIT ON ^C
	EXIT
	TLZ	F,L.EOL	;CLEAR EOL BIT
	POPJ P,0

W.TTY:	SOSLE WH.TTY+2
	JRST W.TOK
	OUTPUT TTY,0
	STATZ TTY,760000
	  JSP	N,TTYERR
W.TOK:	IDPB CH,WH.TTY+1
	TLO F,L.TYO
	CAIG CH,14
	OUTPUT TTY,0
	POPJ P,0

W.CMD:	SOSLE WH.CMD+2
	JRST W.CDOK
	OUTPUT CMD,0
	STATZ CMD,760000
	  JSP	N,CMDERR
W.CDOK:	IDPB CH,WH.CMD+1
	POPJ P,0

R.CMD:	SOSLE RH.CMD+2
	JRST R.CDOK
	INPUT CMD,0
	STATZ CMD,760000
	SKIPA CH,[12]
R.CDOK:	ILDB CH,RH.CMD+1
	POPJ P,0

R.CMU:	SOSLE RH.CMU+2
	JRST R.CUOK
	INPUT CMU,0
	STATZ CMU,760000
	POPJ P,0
R.CUOK:	ILDB WD,RH.CMU+1
CPOPJ1:	AOS	(P)
CPOPJ:	POPJ	P,


USRERR:	GETSTS	USR,A	;IO ERROR ON USR CHAN
	JRST	IOERR
CMUERR:	GETSTS	CMU,A	;IO ERROR ON CMU CHAN
	JRST	IOERR
CMDERR:	GETSTS	CMD,A	;IO ERROR ON CMD CHAN
	JRST	IOERR
TTYERR:	GETSTS	TTY,A	;IO ERR ON TTY
IOERR:	MOVEI	M,IOMSG1	;'?SYSTEM IO ERROR'
	PUSHJ	P,MSGTTY
	PUSHJ	P,OCTPRT		;LOCATION
	MOVEI	M,IOMSG2		;'STATUS ='
	PUSHJ	P,MSGTTY
	MOVE	N,A			;STATUS
	PUSHJ	P,OCTPRT
	JRST	MONRET
NFSERR:	MOVEI	M,NFSMSG	;'?NO F/S NAME'
	JRST	GOAWAY

ILFERR:	PUSH	P,FSNAME
	MOVEI	M,[ASCIZ/?ILLEGAL NAME--/]
	JRST	ILDER2

ILCERR:	PUSH	P,CH
	MOVEI	M,[ASCIZ/?ILLEGAL CHARACTER--/]
	PUSHJ	P,MSGTTY
	POP	P,CH
	PUSHJ	P,W.TTY
	JRST	MONRET

ILDERR:	PUSH	P,B
	MOVEI	M,[ASCIZ/?ILLEGAL DEVICE--/]
ILDER2:	PUSHJ	P,MSGTTY
	POP	P,M
	PUSHJ	P,SIXMSG
	JRST	MONRET

COMERR:	MOVEI M,CERMSG
	JRST	ERREXI
;SUBROUTINE TO GET USERS QUOTAS FROM QUOTA.SYS
;CALL	B=F/S NAME
;	A=PPN
;RET+0	NO QUOTAS RETURNED
;RET+1	B=RESERVED QUOTA
;	C=FCFS QUOTA
;	D=LOGGED-OUT QUOTA

GETQUO:	MOVEM	A,QUOPPN
	HLLOM	A,QUODEF	;DEFAULT ENTRY (PROJ,-1)
	MOVEI	A,14
	MOVEI	C,RH.USR
	OPEN	USR,A		;TRY TO OPEN STR
	  PJRST	MSG262
	MOVEI	A,B.USR
	MOVEM	A,JOBFF
	INBUF	USR,1		;DECLARE OUR 1 BUFFER
	MOVE	A,[SIXBIT .QUOTA.]
	MOVSI	B,(SIXBIT .SYS.)
	MOVE	D,SYSPPN
	LOOKUP	USR,A		;SEE IF QUOTA.SYS EXISTS
	  JRST	GETAQ1		;NO -- SO TRY AUXACC.SYS
	PUSHJ	P,R.USR		;READ SIZE OF ENTRY
	  PJRST	MSG262
	HLRZ	B,A		;B=FORMAT VERSION NUMBER
	CAIE	B,QUOFOR
	PJRST	MSG263
	HRRZ	N,A
	SETOM	QUODFR		;USE QUODFR AS A SWITCH
	PUSHJ	P,R.USR		;GET 1ST ENTRY
	  JRST	GETQU3
	AOSE	A		;IS IT -1,-1?
	SOJA	A,GETQU5	;NO
	PUSHJ	P,GETQU		;YES-REMEMBER ITS QUOTAS FOR DEFAULTS
	  POPJ	P,
	MOVEM	B,QUODFR
	MOVEM	C,QUODFF
	MOVEM	D,QUODFO
	JRST	GETQU6

GETQU1:	PUSHJ	P,R.USR		;READ FIRST WORD OF ENTRY (PPN)
	  JRST	GETQU3
GETQU5:	CAMLE	A,QUODEF	;SKIP IF NOT YET PAST USER
	JRST	GETQU7		;HE AIN'T THERE
	CAME	A,QUODEF	;DEFAULT?
	CAMN	A,QUOPPN	;SKIP IF THIS IS NOT USER'S PPN
	JRST	GETQU4		;HE EXISTS, GO MAKE UFD
GETQU6:	MOVE	B,N		;SKIP REST OF THIS ENTRY
GETQU2:	SOJLE	B,GETQU1
	PUSHJ	P,R.USR
	  JRST	GETQU3
	JRST	GETQU2
GETQU3:	STATZ	USR,20000	;EOF?
	JRST	GETQU7		;YES-NO ENTRY IN QUOTA.SYS
	PJRST	MSG262		;NO--ERROR

GETQU4:	PUSHJ	P,GETQU		;READ ENTRY
	  POPJ	P,
	JRST	GETQU8		;  & RETURN

GETQU7:	SKIPGE	B,QUODFR	;WAS THERE A DEFAULT?
	JRST	GETAQ1		;NO -- SO TRY AUXACC.SYS
	MOVE	C,QUODFF	;YES-USE THEM
	MOVE	D,QUODFO
GETQU8:	RELEASE	USR,
	JRST	CPOPJ1

;SUBROUT TO READ READ QUOTAS INTO B,C,D

GETQU:	PUSHJ	P,R.USR		;READ RESERVED QUOTA
	  PJRST	MSG262
	MOVEM	A,B		;B=QTR
	PUSHJ	P,R.USR		;READ FIRST COME, FIRST SERVED QUOTA
	  PJRST	MSG262
	MOVEM	A,C		;C=QTF
	PUSHJ	P,R.USR		;AND LOGGED-OUT QUOTA
	  PJRST	MSG262
	MOVEM	A,D		;D=QTO
	JRST	CPOPJ1

MSG261:	MOVEI	M,NQFM
	JRST	NOQUO
MSG262:	MOVEI	M,CRQFM
	JRST	NOQUO
MSG263:	MOVEI	M,WFVNQM
	JRST	NOQUO
MSG264:	MOVEI	M,NEQFM
NOQUO:	PJRST	MSGTTY


	U(QUOPPN)
	U(QUODFR)
	U(QUODFF)
	U(QUODFO)
	U(QUODEF)
	;NO QUOTAS IN QUOTA.SYS SO TRY AUXACC.SYS
GETAQ1:	MOVEI	A,14
	HRLZI	B,(SIXBIT .SYS.)
	MOVEI	C,RH.USR
	OPEN	USR,A
	  PJRST	MSG262
	MOVEI	A,B.USR
	MOVEM	A,JOBFF
	INBUF	USR,1		;DECLARE OUR ONE BUFFER
	MOVE	A,[SIXBIT .AUXACC.]
	MOVSI	B,(SIXBIT .SYS.)
	MOVE	D,SYSPPN
	LOOKUP	USR,A		;AUXACC.SYS
	  PJRST	MSG261		;LOOKUP FAILED
	PUSHJ	P,R.USR		;PASSOVER THE NULL WORD
	  PJRST	GETAQ9		;SOMETHING IS WRONG HERE
GETAQ2:	PUSHJ	P,R.USR		;READ WORD 0  =  -1
	  PJRST	GETAQ9		;READ ERROR OR NO ENTRY
	AOJN	A,MSG264	;NO ENTRY
	PUSHJ	P,R.USR		;NUMBER OF WORDS REMAINING IN THIS ENTRY
	  JRST	GETAQ9		;
	MOVEI	D,-1(A)		;DONT COUNT THE "P,,P" WORD
	PUSHJ	P,R.USR		;READ THE "P,,P" WORD
	  JRST	GETAQ9		;
	CAML	A,QUOPPN	;COULD THIS BE THE ENTRY?
	JRST	GETAQ4		;YES
GETAQ3:	PUSHJ	P,R.USR		;NO -- SO PASS OVER THIS ENTRY
	  JRST	GETAQ9		;
	SOJG	D,GETAQ3	;
	JRST	GETAQ2		;AND TRY THE NEXT ONE

	;EITHER THIS IS IT OR ITS NOT HERE
GETAQ4:	CAME	A,QUOPPN	;EXACT MATCH
	CAMN	A,QUODEF	;OR DEFAULT PROG NUMBER
	JRST	GETAQ5		;YES
	PJRST	MSG264		;NO -- NOT HERE
GETAQ5:	PUSHJ	P,R.USR		;READ FILE-STR NAME
	  JRST	GETAQ9		;
GETAQ6:	CAMN	A,FSNAME	;IS THIS THE FILE-STR?
	JRST	GETQU4		;YES -- GET QUOTAS AND EXIT
	SUBI	D,5		;NO -- SKIP OVER THIS FILE-STR
	JUMPLE	D,MSG264	;ANY MORE FILE-STRS?  TOO BAD
	MOVEI	C,5		;YES
GETAQ7:	PUSHJ	P,R.USR		;SKIP OVER THE CURRENT ONE
	  JRST	GETAQ9		;
	SOJG	C,GETAQ7	;
	JRST	GETAQ6		;AND TRY THE NEXT ONE

GETAQ9:	STATZ	USR,20000	;EOF?
	PJRST	MSG264		;YES -- NO QUOTAS
	PJRST	MSG262		;READ ERRROR
IFE MNTSW,<XLIST>
IFN MNTSW,<

;SUBROUTINE TO SET UP A UFD FOR USE  V002
;ARGS	A=USER'S PPN
;	B=A+1=RESERVED QUOTA
;	C=B+1=FIRST COME FIRST SERVED QUOTA
;	D=C+1=LOGGED OUT QUOTA
;	N1=N+1=MFD PPN
;	M=NAME OF STR
;	IO=ADDRESS OF ROUTINE TO TYPE A CHAR
;	CH=ACCUMULATOR TO CONTAIN CHAR TO BE TYPED
;	F=FLAG REGISTER
;	  L.WRTL=BIT IN LH OF F = 1 IF USER REQUESTS WRITE LOCK
;	  L.NCR=BIT IN LH F = 1 IF USER REQUESTS NO CREATE SET
;	  L.SIN=BIT IN LH F = 1 IF SINGLE ACCESS REQUESTED
;	  L.FRE1=AVAILABLE BIT IN LH OF F
;	  L.FRE2=AVAILABLE BIT IN LH OF F
;	P=PUSH DOWN LIST POINTER
;
;IF D=-1 ASSUME NO UFD DESIRED - PERFORM OTHER OPERATIONS
;
;	USR=FREE I/O CHANNEL
;	US1=FREE I/O CHANNEL
;
;CALL	PUSHJ	P,UFDSET
;ERROR	DONT PROCEED (MESSAGE TYPED)
;OK	STR IS IN SEARCH LIST (WARNING MAY BE TYPED)
;
;ASSUMES SYMBOLS FOR AC'S ABOVE DEFINED, LOCATIONS CPOPJ, CPOPJ1 DEFINED
;
;USES U AND UU MACROS TO RESERVE STORAGE FOR EITHER HIGH OR LOW
;SEGMENT OPERATION.
;
;ROUTINES DEFINED HERE:
;
;MSG:	 TYPES STRING OF ASCII CHARS TO FIRST NULL
;SIXMSG:	 TYPES CONTENTS OF M AS SIXBIT CHARS
;CRLF:	 TYPES CARRIAGE RETURN LINE FEED
;OCTPRT: TYPES CONTENTS OF N AS OCTAL NUMBER
;MPOPJ:	 POP P,M FOLLWED BY POPJ P,
;R.USR:	 READS NEXT WORD FROM CHANNEL USR INTO A (BUFFER HEADER RH.USR, BUFFER B.USR)
;ADDSTR: ADD FILE STRUCTURE TO SEARCH LIST
;DISSTR: DELETE FILE STRUCTURE FROM SEARCH LIST

MNTSUB==1		;DECLARE IN CASE DISMOUNT SUBROUTINE ALSO APPEARS

UFDGIL==^D360		;TIMES TO TRY TO GET UFD INTERLOCK

RACEY==2	;VALUE OF LEVEL D FIELD IN STATES WORD FOR MONITOR
	;  WHICH INCLUDES RACE CONDITION STUFF
;ARGUMENTS FOR EXTENDED LOOKUP, ENTER, RENAME

EXLLEN==26	;LENGTH OF ARGUMENT LIST
EXLPPN==1	;DIRECTORY NAME
EXLNAM==2	;FILE NAME
EXLEXT==3	;EXT
EXLALC==11	;BLOCKS ALLOCATED FOR FILE
EXLDEV==16	;DEVICE ON WHICH FILE LOOKED UP IS
EXLSTS==17	;STATUS BITS
  RIPLOG==400000	;LH BIT IS LOGGED IN BIT
  RIPDIR==400000	;RH BIT IS DIRECTORY BIT
EXLQTR==24	;RESERVED QUOTA
EXLQTF==22	;FIRST COME, FIRST SERVED QUOTA
EXLQTO==23	;LOGGED-OUT QUOTA
EXLUSD==25	;BLOCKS USED

CHRUFB==1	;UFBTAL WORD
CHRLEN==14	;LENGTH OF DSKCHR BLOCK
  D.MC==10000	;BIT IN LH OF DSKCHR AC RETURN=1 IF MOUNT COUNT=0

  CNFTBL==11	;CONFIGURATION TABLE FOR GETTAB
  SEGPTR==15	;INDEX FOR SEGMENTS, JOBS

	OPDEF STRUUO [CALLI 50]

SRCDSL==1	;STRUUO FUNCTION TO SET NEW SEARCH LIST
  STRJMX==9	;MAXIMUM NUMBER OF STRS PER JOB
  SRWPS==3	;WORDS PER STR ENTRY IN SEARCH LIST
RDFFST==3	;STRUUO FUNCTION TO REDEFINE FILE STRUCTURE ***
  S.SWL==400000	;SOFTWARE WRITE LOCK FOR ALL JOBS
  S.SIN==200000	;SINGLE ACCESS
ULKSTR==6	;STRUUO FUNCTION TO TEST/SET UFD INTERLOCK
UCLSTR==7	;STRUUO FUNCTION TO CLEAR UFD INTERLOCK


	OPDEF GOBSTR [CALLI 66]

GOBJOB==0	;INDEX FOR JOB NUMBER IN ARG LIST
GOBPPN==1	;INDEX FOR PPN
GOBNAM==2	;INDEX FOR STR NAME

	OPDEF PJRST [JRST]

	DEFINE UFDSEM(TEXT)<
	XLIST
	MOVEI	N1,[ASCIZ \TEXT\]
	JRST	UFDSMP
	LIST
>
	EXTERN	JOBFF

UFDSET:	MOVEM	A,UFDUPN	;SAVE USER'S PPN
	MOVEM	N1,UFDMPN	;AND MFD PPN
	MOVEM	M,UFDFSN	;AND NAME OF STR
	MOVE	N,B		;N=RESERVED QUOTA
	MOVE	M,C		;M=FCFS QUOTA
	MOVE	CH,D		;CH=LOGGED OUT QUOTA
	MOVEI	N1,UFDGIL	;NUMBER OF TIMES TO TRY FOR UFD INTERLOCK
UFDSTA:	MOVEI	B,ULKSTR	;USER-MODE UFD INTERLOCK FUNCTION
	PUSHJ	P,STUFC1	;TEST/SET UFD INTERLOCK
	  JRST	STUFBS		;BUSY, SLEEP AND RETRY
	MOVE	B,UFDFSN
	MOVEI	A,14
	MOVEI	C,RH.USR
	OPEN	USR,A		;INIT THIS FILE STRUCTURE
	  JRST	UFDSE2		;HOW CAN THIS BE?
	AOJE	CH,UFDOK	;JUMP IF NO UFD OPERATIONS DESIRED
	SUBI	CH,1		;NO, RESTORE LOGGED OUT QUOTA
	MOVEI	A,B.USR
	MOVEM	A,JOBFF
	INBUF	USR,1		;DECLARE OUR 1 BUFFER
	PUSHJ	P,SETEXL	;SET UP SRCBUF FOR EXTENDED LOOKUP OF UFD
	SETZB	C,SRCBUF+4	;CLEAR REST OF LOOKUP BLOCK
	MOVE	A,[XWD SRCBUF+4,SRCBUF+5]
	BLT	A,SRCBUF+EXLLEN-1
	LOOKUP	USR,SRCBUF	;LOOKUP UFD
	  SKIPA	A,SRCBUF+EXLEXT	;GET ERROR CODE IN A
	JRST	UFDEX		;UFD EXISTS, LOOK AT IT
	TRNE	A,-1		;SKIP IF NO UFD
	JRST	UFDSE3		;THERE'S SOMETHING WRONG WITH THIS UFD

;HERE IF MUST CREATE A UFD

	MOVEM	N,SRCBUF+EXLQTR	;STORE RESERVED QUOTA
	MOVEM	M,SRCBUF+EXLQTF	;AND FCFS
	MOVEM	CH,SRCBUF+EXLQTO ;AND LOGGED OUT QUOTA
	PUSHJ	P,SETEXL	;SET UP FOR EXTENDED ENTER OF UFD
	MOVE	A,[XWD RIPLOG,RIPDIR]	;SET DIRECTORY BIT AND LOGGED IN BIT
	MOVEM	A,SRCBUF+EXLSTS
	ENTER	USR,SRCBUF	;TRY TO CREATE A UFD
	  JRST	UFDSE1		;IDENTIFY ENTER FAILURE
	SETSTS	USR,17		;CHANGE TO DUMP MODE SO CLOSE WONT DUMP BUFFERS
	USETO	USR,2
	CLOSE	USR,		;AN EMPTY UFD
	JRST	UFDOK		;ALL SET
;HERE IF UFD ALREADY EXISTS

UFDEX:	MOVE	A,SRCBUF+.RBSTS	;ALLOWED TO RENAME?
	TRNE	A,.RBNDL
	JRST	UFDOK		;NO-THATS ALL
	MOVEM	N,SRCBUF+EXLQTR	;STORE RESERVED QUOTA
	MOVEM	M,SRCBUF+EXLQTF	;AND FCFS
	MOVEM	CH,SRCBUF+EXLQTO ;AND LOGGED OUT QUOTA
	MOVSI	A,RIPLOG	;LOGGED IN BIT
	TDNN	A,SRCBUF+EXLSTS	;SKIP IF BIT ON IN UFD
	JRST	UFDEX2		;NO, CAN PROCEED
	MOVE	B,[XWD SEGPTR,CNFTBL]
	CALLI	B,CI.GTT	;GET NUMBER OF JOBS
	  MOVEI	B,100		;ASSUME 64
	MOVNI	B,-1(B)
	HRLZS	B		;LH B=-NUMBER OF REAL JOBS
UFDEX1:	MOVE	A,UFDFSN
	MOVEM	A,CHRBUF+GOBNAM	;NAME OF STR
	MOVE	A,UFDUPN
	MOVEM	A,CHRBUF+GOBPPN
	MOVEI	A,1(B)		;A=NEXT JOB NUMBER
	MOVEM	A,CHRBUF+GOBJOB
	MOVEI	A,CHRBUF
	GOBSTR	A,		;SEE IF STR IS IN THAT JOB'S SEARCH LIST
	  JRST	.+2		;NOT IN THIS JOBS LIST OR NOT OUR PPN
	JRST	UFDOK		;OK IS IN SOMEBODY ELSES SEARCH LIST SAME PPN
	AOBJN	B,UFDEX1	;LOOP FOR ALL JOBS

;HERE TO LOOKUP ALL FILES AND RECOMPUTE RIBUSD

	SETZB	A,C
	MOVE	B,UFDFSN
	MOVEM	B,CHRBUF	;SAVE FOR DSKCHR
	OPEN	US1,A		;OPEN FILE STRUCTURE
	  JRST	UFDSE2
	SETZM	SRCBUF+EXLUSD	;CLEAR USED WORD
	MOVE	A,[XWD CHRUFB+1,CHRBUF]
	DSKCHR	A,		;GET CURRENT UFBTAL
	  JRST	UFDS9A
ALLK1:	PUSHJ	P,R.USR		;READ NEXT WORD OF UFD
	  JRST	UFDRER		;READ ERROR (MAY BE EOF)
	MOVEM	A,SECBUF+EXLNAM ;FILE NAME
	PUSHJ	P,R.USR		;READ NEXT WORD OF UFD (EXT)
	  JRST	UFDRER		;READ ERROR
	SKIPN	SECBUF+EXLNAM	;SKIP IF REAL NAME
	JRST	ALLK1		;UFD'S DO HAVE ZEROS
	HLLZM	A,SECBUF+EXLEXT ;STORE EXT
	SETZM	SECBUF+EXLPPN	;CLEAR PPN WORD
	MOVEI	A,EXLALC
	MOVEM	A,SECBUF	;SET NUMBER OF ARGS TO GET ALC WORD
	LOOKUP	US1,SECBUF	;LOOKUP FILE
	  JRST	ALLK1		;SOMETHING WRONG, FORGET IT
	MOVE	A,SECBUF+EXLALC ;GET BLOCKS ALLOCATED FOR THIS FILE
	ADDM	A,SRCBUF+EXLUSD ;COUNT FOR ALL FILES
	JRST	ALLK1
;HERE IF READ ERROR (MAY BE EOF)

UFDRER:	CLOSE	US1,
	GETSTS	USR,A		;A=ERROR CODE
	MOVEI	M,[ASCIZ .UFD READ ERROR, STATUS = .]
	TRNN	A,20000		;SKIP IF ERROR, NOT EOF
	JRST	UFDSE4		;TELL USER ABOUT ERROR, NO UFD
	MOVE	B,CHRBUF+CHRUFB	;PREVIOUS UFBTAL
	CAMN	B,[XWD 400000,0]
	JRST	UFDEX3
	MOVE	A,[XWD CHRUFB+1,CHRBUF]
	DSKCHR	A,		;GET NEW UFBTAL
	  JRST	UFDS9A
	SUB	B,CHRBUF+CHRUFB	;OLD-NEW=-DIFFERENCE FREE
	ADDM	B,SRCBUF+EXLUSD	;=DIFFERENCE ALLOCATED
	JRST	UFDEX3		;ALL SET


UFDEX2:	IORM	A,SRCBUF+EXLSTS	;MAKE SURE LOGGED IN BIT ON
UFDEX5:	LDB	A,LVDBTS
	CAIL	A,RACEY
	SETOM	SRCBUF+EXLUSD	;USE MONITOR'S COPY OF UFBTAL TO COMPUTE RIBUSD
UFDEX3:	PUSHJ	P,SETEXL	;SET UP SRCBUF FOR EXTENDED RENAME
	RENAME	USR,SRCBUF
	  SKIPA	A,SRCBUF+EXLEXT
	JRST	UFDOK

	MOVEI	M,[ASCIZ .UFD RENAME FAILURE .]
	JRST	UFDSE4

UFDSE3:	MOVEI	M,[ASCIZ .UFD LOOKUP FAILURE .]
UFDSE4:	PUSHJ	P,MSG		;IDENTIFY FAILURE
	HRRZ	N,A		;N=ERROR CODE
	PUSHJ	P,OCTPRT
	PUSHJ	P,CRLF
	JRST	UFDOK

UFDSE1:	MOVEI	M,[ASCIZ .UFD ENTER FAILURE .]
	PUSHJ	P,MSG		;IDENTIFY FAILURE
	HRRZ	N,SRCBUF+EXLEXT
	PUSHJ	P,OCTPRT
UFDOK:	MOVEI	A,UFDFSN
	DSKCHR	A,		;NEED TO SEE IF MC=0
	  JRST	UFDSE2		;BAD LUCK
	TLNN	A,D.MC		;SKIP IF MOUNT COUNT=0
	JRST	UFDOK1		;NO
	SETZ	N,		;YES, REDEFINE STR
	TLNE	F,L.SIN		;IF SINGLE REQUEST, PASS ON TO MOUNT UUO
	TLO	N,S.SIN
	MOVEM	N,MNTFSN
	MOVE	B,UFDFSN	;AND FILE STRUCTURE NAME
	MOVEM	B,MNTTYP
	SETOM	UFDDMJ		;USE JOB'S JOB NUMBER
	SETOM	UFDDMP		;AND PPN
	MOVEI	A,RDFFST
	MOVEM	A,UFDMTP	;SET FUNCTION
	MOVEI	A,UFDMTP
	STRUUO	A,		;REDEFINE THE FILE STRUCTURE
	  JRST	UFDS7A		;NO, DONT
UFDOK1:	PUSHJ	P,ADDSTR	;ADD STR TO JOBS SEARCH LIST

;HERE TO CLEAR UFD INTERLOCK

	PUSHJ	P,STUFCL	;CLEAR UFD INTERLOCK
	  JRST	CPOPJ1		;WHAT?
	JRST	CPOPJ1		;ALL DONE
;HERE WHEN UFD INTERLOCK IS BUSY - SLEEP AND RETRY

STUFBS:	MOVEI	A,1
	SLEEP	A,	;SLEEP FOR 1 SECOND
	SOJG	N1,UFDSTA
	UFDSEM <UFD INTERLOCK BUSY>

UFDSE2:	PUSHJ	P,STUFCL
	  JFCL
	UFDSEM <CANT OPEN>


;SUBROUTINE TO TEST/SET OR CLEAR UFD INTERLOCK
;ENTER AT STUFCL TO CLEAR
;ENTER AT STUFC1 WITH B=FUNCTION
;RETURN POPJ IF FAILED
;RETURN CPOPJ1 IF OK

STUFCL:	MOVEI	B,UCLSTR
STUFC1:	LDB	A,LVDBTS
	CAIGE	A,RACEY
	JRST	CPOPJ1
	MOVE	A,[XWD 3,B]
	MOVE	C,UFDFSN
	MOVE	D,UFDUPN
IFE DBUGSW,<
	STRUUO	A,
	  POPJ	P,
> ;END IFE DBUGSW
	PJRST	CPOPJ1

;SUBROUTINE TO SET UP HEADER FOR EXTENDED LOOKUP/ENTER/RENAME OF UFD

SETEXL:	MOVEI	A,EXLLEN-1	;LENGTH OF ARG LIST
	MOVEM	A,SRCBUF
	MOVE	A,UFDUPN	;NAME IS USER'S PPN
	MOVEM	A,SRCBUF+EXLNAM
	MOVSI	A,(SIXBIT .UFD.)	;EXT IS UFD
	MOVEM	A,SRCBUF+EXLEXT
	MOVE	A,UFDMPN	;DIRECTORY IS MFD
	MOVEM	A,SRCBUF+EXLPPN
	POPJ	P,

R.USR:	SOSLE	RH.USR+2
	JRST	R.USOK
	INPUT	USR,
	STATZ	USR,760000
	POPJ	P,
R.USOK:	ILDB	A,RH.USR+1
	JRST	CPOPJ1

;THIS ROUTINE ADDS FILE STRUCTURE NAMED IN UFDFSN TO THE
;FILE STRUCTURE SEARCH LIST, OR DELETES THE FILE STRUCTURE FROM IT.
;ENTER AT ADDSTR TO ADD OR AT DISSTR TO DELETE.

L.DIS==L.FRE1
L.PEND==L.FRE2

DISSTR:	MOVEI	A,B
	MOVE	B,UFDFSN
	JOBSTR	A,
	  POPJ	P,		;NOT IN SEARCH LIST, OK
	TLOA	F,L.DIS		;SET FLAG NOTING DISMOUNT
ADDSTR:	TLZ	F,L.DIS		;CLEAR FLAG, NOTING ADD
	SETZB	E,UFDDMF	;SET FLAG TO REMEMBER
	TLNE	F,L.DIS		;SKIP IF ADDING AN STR
	AOS	UFDDMF		;SET FLAG TO DELETE
	MOVEI	A,SRCDSL
	MOVEM	A,UFDMTP	;SET FUNCTION TO DEFINE SEARCH LIST
	SETOB	B,UFDDMJ	;START JOBSTR WITH -1
	SETOM	UFDDMP		;CLEAR JOB AND PPN SO USES VALUES FOR THIS JOB
	TLZ	F,L.PEND	;BORROW THIS BIT TO MEAN FILE STRUCTURE THERE
MAKSRC:	MOVE	A,[XWD 3,B]
	JOBSTR	A,		;GET USER'S NEXT FILE STRUCTURE
	  JRST	UFDSE8		;SYSTEM PROBLEM
	TLNN	F,L.DIS		;SKIP IF DISMOUNT
	JUMPE	B,MAKSR2	;MOUNT STOPS AT FENCE
	AOJE	B,MAKSR2	;JUMP IF END OF LIST
	SOS	B
	MOVEM	B,MNTTYP+1(E)
	JUMPE	B,MAKSR1	;DONT DSKCHR THE FENCE
	MOVE	A,[XWD 1,B]
	DSKCHR	A,		;GET CURRENT STATUS OF THIS FILE STRUCTURE
	  JRST	UFDSE9		;CANT FAIL
	MOVE	B,MNTTYP+1(E)	;GET BACK FILE STRUCTURE NAME
	CAME	B,UFDFSN	;AND SEE IF WE ALREADY EXIST
	JRST	MAKSR1		;NO
	TLO	F,L.PEND
	TLNE	F,L.DIS		;SKIP IF ACTUALLY DELETING
	JRST	MAKSRC		;AND IGNORE THIS FILE STRUCTURE
MAKSR0:	MOVE	A,D
	LSH	A,-4		;ROTATE A TO MATCH UP D.SWL AND L.WRTL
	XOR	A,F		;COMPARE WRITE LOCK STATES
	TLNN	A,L.WRTL	;SKIP IF DIFFERENT
	JRST	CPOPJ		;NO CHANGE
	TLC	D,S.SWL
	SETZ	C,
MAKSR1:	MOVEM	C,MNTTYP+2(E)	;SAVE PROJECT,PROGRAMMER NUMBER
	MOVEM	D,MNTTYP+3(E)	;SAVE WRITE PROTECT REQUEST
	ADDI	E,3
	JRST	MAKSRC		;LOOP FOR ALL USER'S FILE STRUCTURES

UFDSE8:	UFDSEM <SYSTEM ERROR - JOBSTR UUO FAILED>
UFDS9A:	PUSHJ	P,STUFCL
	  JFCL
UFDSE9:	UFDSEM <SYSTEM ERROR - DSKCHR UUO FAILED>
MAKSR2:	TLZE	F,L.PEND
	JRST	MAKSR3		;DONT ADD FILE STRUCTURE 
MAKSRA:	SKIPN	MNTTYP+1(B)	;B STARTS AT 0 FROM ABOVE
	JRST	MAKSRB		;THE FENCE IS A 0
	ADDI	B,3
	CAIE	B,(E)		;IF END, NO FENCE
	JRST	MAKSRA
	JRST	MAKSR4		;OK TO PROCEED
MAKSRB:	MOVE	C,E		;IF FENCE, MUST MOVE EVERYTHING DOWN 1 ENTRY
MAKSRL:	CAIG	B,(C)		;SKIP IF MORE
	JRST	MAKSR4
	MOVE	A,MNTTYP(C)
	MOVEM	A,MNTTYP+3(C)
	SOJA	C,MAKSRL
MAKSR4:	MOVE	A,UFDFSN
	MOVEM	A,MNTTYP+1(B)	;ADD NEW FILE STRUCTURE
	SETZB	A,MNTTYP+2(B)
	TLNE	F,L.WRTL
	TLO	A,S.SWL		;A SET TO 0 ABOVE
	MOVEM	A,MNTTYP+3(B)
	ADDI	E,3
MAKSR3:	MOVEI	A,UFDMTP
	HRLI	A,4(E)		;LENGTH OF ARGUMENT LIST
	STRUUO	A,
	  JRST	UFDSE6
	POPJ	P,

UFDSE6:	TLNE	F,L.DIS
	JRST	UFDSE5
	MOVEI	N1,[ASCIZ .CANT ADD TO YOUR FILE STRUCTURE SEARCH LIST.]
	JRST	UFDSSE
UFDSE5:	MOVEI	N1,[ASCIZ .CANT REMOVE FILE STRUCTURE FROM SEARCH LIST.]
	JRST	UFDSSE
UFDS7A:	PUSHJ	P,STUFCL
	  JFCL
UFDSE7:	MOVEI	N1,[ASCIZ .CANT REDEFINE FILE STRUCTURE .]
UFDSSE:	MOVEI	CH,"?"
	PUSHJ	P,(IO)
	MOVE	M,UFDFSN
	PUSHJ	P,SIXMSG
	MOVEI	CH," "
	PUSHJ	P,(IO)
	MOVE	M,N1
	PUSHJ	P,MSG
	MOVE	N,A
	PUSHJ	P,OCTPRT
	PJRST	CRLF

UFDSMP:	MOVEI	CH,"?"
	PUSHJ	P,(IO)
	MOVE	M,UFDFSN
	PUSHJ	P,SIXMSG
	MOVEI	CH," "
	PUSHJ	P,(IO)
	MOVE	M,N1
	PUSHJ	P,MSG
	PJRST	CRLF
;SUBROUTINE TO OUTPUT ACCUMULATOR M AS SIXBIT CHARS

SIXTTY:	MOVEI	IO,W.TTY
SIXMSG:	PUSH	P,M
	MOVE	M,[POINT 6,(P)]	;M=BYTE POINTER
SIXMSL:	ILDB	CH,M
	JUMPE	CH,MPOPJ	;QUIT AT FIRST NULL BYTE
	ADDI	CH,40
	PUSHJ	P,0(IO)
	TLNE	M,770000	;OR END OF WORD
	JRST	SIXMSL
MPOPJ:	POP	P,M
	POPJ	P,

;THIS ROUTINE OUTPUTS ACCUMULATOR N AS AN OCTAL NUMBER

OCTPRT:	IDIVI N,10
	HRLM N1,0(P)		;SAVE EACH CHAR ON THE STACK
	SKIPE N
	PUSHJ P,OCTPRT		;RECURSE AS NECESSARY
	HLRZ CH,0(P)		;NOW RETRIEVE LAST CHAR
	ADDI CH,60		;MAKE ASCII
	JRST 0(IO)		;OUTPUT AND ASCEND A LEVEL- EXIT WHEN DONE

CRLF:	MOVEI	M,[ASCIZ .
.]
MSG:	HRLI M,440700
MSGL:	ILDB CH,M
	JUMPE CH,CPOPJ
	PUSHJ P,0(IO)
	JRST MSGL
LVDBTS:	POINT	3,STATES,9

UU(RH.USR,3)
UU(B.USR,205)
UU(CHRBUF,CHRLEN)
UU(SRCBUF,EXLLEN)
UU(SECBUF,EXLALC+1)
U(UFDMPN)
U(UFDUPN)
U(UFDFSN)
U(UFDMTP)
U(UFDDMJ)
U(UFDDMP)
U(UFDDMF)
MNTTYP=UFDDMF
U(MNTFSN)
U(MNTNUM)
UU(MNTBLK,SRWPS*STRJMX)

>	;END CONDITIONAL ON MNTSW

IFE MNTSW,<LIST>
IFE MNTSW,<XLIST>
IFN MNTSW,<

;SUBROUTINE TO CLEAR A FILE STRUCTURE FOR DISMOUNT  V002
;ARGS	A=USER'S PPN
;	B=A+1=JOB NUMBER
;	C=B+1
;	D=C+1=LOGGED OUT QUOTA (-1 TO IGNORE)
;	N1=N+1=MFD PPN
;	M=NAME OF FILE STRUCTURE
;	IO=ADDRESS OF ROUTINE TO TYPE A CHARACTER
;	CH=ACCUMULATOR TO CONTAIN CHAR TO BE TYPED
;	F=FLAG REGISTER
;	  L.FRE1=AVAILABLE BIT IN LH OF F
;	  L.FRE2=AVAILABLE BIT IN LH OF F
;	P=PUSH DOWN LIST POINTER
;
;	USR=FREE I/O CHANNEL
;
;CALL	PUSHJ	P,UFDCLR
;ERROR	DONT PROCEED A=CODE (0=CANT OPEN 1=QUOTA EXCEEDED) MESSAGE TYPED
;OK	FILE STRUCTURE REMOVED FROM JOBS SEARCH LIST (WARNING MAY BE TYPED)

UFDGIL==^D360		;TIMES TO TRY TO GET UFD INTERLOCK

RACEY==2	;VALUE IN LEV D FIELD IN STATES FOR MONITOR
		;WHICH CONTAIN RACE CONDIT. STUF
;SYMBOLS FROM COMMOD

EXLLEN==26		;LENGTH OF EXTENDED LOOKUP/ENTER/RENAME ARG LIST
EXLPPN==1		;DIRECTORY NAME
EXLNAM==2		;FILE NAME
EXLEXT==3		;EXT
EXLSIZ==5		;WORDS WRITTEN
EXLSTS==17		;STATUS BITS
  RIPLOG==400000	;LH BIT=LOGGED IN BIT
EXLQTF==22		;FIRST COME FIRST SERVED QUOTA
EXLQTR==24		;RESERVED QUOTA
EXLQTO==23		;LOGGED OUT QUOTA
EXLUSD==25		;BLOCKS ALLOCATED

	OPDEF STRUUO [CALLI 50]

SRCFST==0		;FUNCTION TO SET NEW SEARCH LIST
  STRJMX==9		;MAXIMUM NUMBER OF FILE STRUCTURES IN SEARCH LIST
  SRWPS==3		;NUMBER OF WORDS PER STR ENTRY
ULKSTR==6		;FUNCTION TO SET UFD INTERLOCK
UCLSTR==7		;FUNCTION TO CLEAR UFD INTERLOCK

	OPDEF GOBSTR [CALLI 66]

GOBJOB==0		;WORD IN GOBSTR ARG LIST CONTAINING JOB NUMBER
GOBPPN==1		;INDEX FOR PPN
GOBNAM==2		;INDEX FOR STR NAME

	OPDEF DSKCHR [CALLI 45]

CHRUFB==1		;WORD IN DSKCHR BLOCK CONTAING UFBTAL
CHRLEN==14

CI.SLP==31
CI.GTT==41
  CNFTBL==11
  SEGPTR==15

UFDQEE==1		;ERROR CODE FOR QUOTA EXHAUSTED

	DEFINE	UFDSEM(TEXT) <
	XLIST
	MOVEI	N1,[ASCIZ \TEXT\]
	JRST	UFDSMP
	LIST
>
	EXTERN	JOBFF

UFDCLR:	MOVEM	A,UFDUPN	;SAVE USER'S PPN
	MOVEM	B,UFDJBN	;AND JOB NUMBER
	MOVEM	D,UFBLOQ	;LOG-OUT QUOTA
	MOVEM	N1,UFDMPN	;MFD PPN
	MOVEM	M,UFDFSN	;STR NAME
	MOVEI	B,ULKSTR
	MOVEI	N1,UFDGIL	;TIMES TO TRY FOR UFD INTERLOCK
UFDCLA:	PUSHJ	P,STUFC1	;TEST/SET UFD INTERLOCK
	  JRST	UFDCAA		;BUSY, SLEEP AND RETRY
	MOVEI	A,14
	MOVE	B,M		;STR NAME
	MOVEI	C,RH.USR
	OPEN	USR,A		;OPEN FILE STRUCTURE
	  JRST	UFDCAB
	MOVEI	A,B.USR
	MOVEM	A,JOBFF
	INBUF	USR,1		;DECLARE OUR 1 BUFFER
	PUSHJ	P,SETEXL	;SET UP FOR EXTENDED LOOKUP
	LOOKUP	USR,SRCBUF
	  SKIPA	A,SRCBUF+EXLEXT	;GET ERROR CODE
	JRST	UFDCLC		;UFD EXISTS
	TRNN	A,-1		;SKIP IF UFD EXISTS, LOOKUP FAILED
	JRST	UFDCLJ		;NO UFD

;HERE IF UFD LOOKUP ERROR

	MOVEI	M,[ASCIZ .UFD LOOKUP FAILURE .]
	JRST	UFDCFA		;TYPE MESSAGE

UFDCLC:	MOVE	B,[XWD SEGPTR,CNFTBL]
	CALLI	B,CI.GTT	;GET NUMBER OF JOBS IN SYSTEM
	  MOVEI	B,100		;ASSUME 64
	MOVNI	B,-1(B)		;B=-NUMBER OF REAL JOBS (NOT NULL JOB)
	HRLZS	B
UFDCCA:	MOVE	A,UFDFSN	;NAME OF FILE STRUCTURE
	MOVEM	A,CHRBUF+GOBNAM	;STORE IN GOBSTR BLOCK
	MOVE	A,UFDUPN	;USER'S PPN
	MOVEM	A,CHRBUF+GOBPPN
	MOVEI	C,1(B)		;JOB NUMBER
	MOVEM	C,CHRBUF+GOBJOB
	MOVEI	A,CHRBUF
	GOBSTR	A,		;SEE IF IN THIS JOBS SEARCH LIST
	  JRST	UFDCCB		;NO
	CAME	C,UFDJBN	;YES, SEE IF THIS JOB
	JRST	UFDCLJ		;NO, SOMEBODY ELSE COMING
UFDCCB:	AOBJN	B,UFDCCA	;NOT IN THAT JOBS SEARCH LIST

	MOVE	A,UFDFSN
	MOVEM	A,CHRBUF
	MOVE	A,[XWD CHRUFB+1,CHRBUF]
	DSKCHR	A,		;GET CURRENT UFBTAL
	  JRST	UFDCLJ
	MOVE	B,SRCBUF+EXLQTO	;USE UFD QUOTA
	SKIPGE	UFBLOQ		; IF NONE IN QUOTA.SYS OR AUXACT.SYS
	MOVEM	B,UFBLOQ
	MOVE	B,CHRBUF+CHRUFB
	CAMN	B,[XWD 400000,0]
	JRST	UFDCCC		;IGNORE QUOTA TEST
	MOVE	A,SRCBUF+EXLQTF	;FCFS QUOTA

REPEAT 0,<ADD	A,SRCBUF+EXLQTR	;RESERVED QUOTA WHEM IMPLEMENTED>

	SUB	A,B	;QUOTA IN-FREE=USED
	SUB	A,UFBLOQ	;-QUOTA OUT=BLOCKS OVER QUOTA
	JUMPG	A,UFDCLM	;JUMP IF OVER QUOTA

;HERE TO SEE IF UFD EMPTY

UFDCCC:	MOVE	B,SRCBUF+.RBSTS	;ALLOWED TO RENAME/DELETE?
	TRNE	B,.RBNDL
	JRST	UFDCLJ		;NO-THATS ALL
	SKIPN	B,SRCBUF+EXLSIZ	;WORDS WRITTEN IN UFD
	JRST	UFDCLI		;NO WORDS WRITTEN - DELETE UFD
UFDCLD:	PUSHJ	P,R.USR		;READ NEXT WORD OF UFD
	  JRST	UFDCDA		;JUMP IF ERROR OR EOF
	JUMPN	A,UFDCLF	;JUMP IF NON-EMPTY ENTRY IN UFD
	SOJG	B,UFDCLD	;STILL EMPTY SO FAR, LOOP FOR WORDS WRITTEN

	JRST	UFDCLI		;NO NON-ZERO ENTRIES, DELETE UFD

UFDCDA:	GETSTS	USR,N
	TRNE	N,20000		;SKIP IF EOF
	JRST	UFDCLF		;EOF
	MOVEI	M,[ASCIZ .UFD READ ERROR, STATUS = .]
	PUSHJ	P,MSG
	PUSHJ	P,OCTPRT
	PUSHJ	P,CRLF
UFDCLF:	MOVSI	A,RIPLOG	;LOGGED IN BIT
	ANDCAM	A,SRCBUF+EXLSTS	;CLEAR IN RENAME ARG LIST
	LDB	A,LVDBTS
	CAIL	A,RACEY
	SETOM	SRCBUF+EXLUSD	;REQUEST MONITOR TO COMPUTE RIBUSD
	PUSHJ	P,SETEXL	;SET UP FOR EXTENDED RENAME
	RENAME	USR,SRCBUF	;EXTENDED RENAME
	  SKIPA	A,SRCBUF+EXLEXT	;GET ERROR CODE IN A
	JRST	UFDCLJ
	MOVEI	M,[ASCIZ .UFD RENAME FAILURE .]
UFDCFA:	PUSHJ	P,MSG
	HRRZ	N,A
	PUSHJ	P,OCTPRT	;PRINT ERROR CODE
	PUSHJ	P,CRLF
	JRST	UFDCLJ		;GIVE UP

UFDCLI:	SETZB	A,B
	SETZB	C,D
	RENAME	USR,A		;DELETE UFD
	  JFCL
UFDCLJ:	PUSHJ	P,DISSTR	;TAKE STR OUT OF JOB'S SEARCH LIST
	PUSHJ	P,STUFCL	;CLEAR UFD INTERLOCK
	  JRST	CPOPJ1
	JRST	CPOPJ1		;EVERYBODY HAPPY

UFDCLM:	MOVEI	M,[ASCIZ .EXCEED LOGGED OUT QUOTA .]
	PUSHJ	P,MSG
	MOVE	N,UFBLOQ
	PUSHJ	P,DECPRT
	MOVEI	M,[ASCIZ . BY .]
	PUSHJ	P,MSG
	MOVE	N,A
	PUSHJ	P,DECPRT
	PUSHJ	P,STUFCL
	  JFCL
	MOVEI	M,[ASCIZ . BLOCKS
.]
	MOVEI	A,UFDQEE
	PJRST	MSG

UFDCAA:	MOVEI	A,1
	CALLI	A,CI.SLP
	SOJG	N1,UFDCLA
	UFDSEM <UFD INTERLOCK BUSY>

UFDCAB:	PUSHJ	P,STUFCL
	  JFCL
	UFDSEM <CANT OPEN>
U(UFBLOQ)
IFDEF MNTSUB,<XLIST>
IFNDEF  MNTSUB,<

;SUBROUTINE TO TEST/SET OR CLEAR UFD INTERLOCK
;ENTER AT STUFCL TO CLEAR
;ENTER AT STUFC1 WITH B=FUNCTION
;RETURN POPJ IF FAILED
;RETURN CPOPJ1 IF OK

STUFCL:	MOVEI	B,UCLSTR
STUFC1:	MOVE	A,[XWD 3,B]
	MOVE	C,UFDFSN
	MOVE	D,UFDUPN
	STRUUO	A,
	  POPJ	P,
	PJRST	CPOPJ1

;SUBROUTINE TO SET UP HEADER FOR EXTENDED LOOKUP/ENTER/RENAME OF UFD

SETEXL:	MOVEI	A,EXLLEN-1	;LENGTH OF ARG LIST
	MOVEM	A,SRCBUF
	MOVE	A,UFDUPN	;NAME IS USER'S PPN
	MOVEM	A,SRCBUF+EXLNAM
	MOVSI	A,(SIXBIT .UFD.)	;EXT IS UFD
	MOVEM	A,SRCBUF+EXLEXT
	MOVE	A,UFDMPN	;DIRECTORY IS MFD
	MOVEM	A,SRCBUF+EXLPPN
	POPJ	P,

R.USR:	SOSLE	RH.USR+2
	JRST	R.USOK
	INPUT	USR,
	STATZ	USR,760000
	POPJ	P,
R.USOK:	ILDB	A,RH.USR+1
	JRST	CPOPJ1
;THIS ROUTINE ADDS FILE STRUCTURE NAMED IN UFDFSN TO THE
	;FILE STRUCTURE SEARCH LIST, OR DELETES THE FILE STRUCTURE FROM IT.
	;ENTER AT ADDSTR TO ADD OR AT DISSTR TO DELETE.

L.DIS==L.FRE1
L.PEND==L.FRE2

DISSTR:	MOVEI	A,B
	MOVE	B,UFDFSN
	JOBSTR	A,
	  POPJ	P,
	TLOA	F,L.DIS		;SET FLAG NOTING DISMOUNT
ADDSTR:	TLZ	F,L.DIS		;CLEAR FLAG, NOTING ADD
	SETZB	E,UFDDMF	;SET FLAG TO REMEMBER
	TLNE	F,L.DIS		;SKIP IF ADDING AN STR
	AOS	UFDDMF		;SET FLAG TO DELETE
	MOVEI	A,SRCDSL	;FUNCTION TO DEFINE SEARCH LIST
	MOVEM	A,UFDMTP
	SETOB	B,UFDDMJ	;START JOBSTR WITH -1
	SETOM	UFDDMP		;CLEAR JOB AND PPN TO USE VALUES FOR THIS JOB
	TLZ	F,L.PEND	;BORROW THIS BIT TO MEAN FILE STRUCTURE THERE
MAKSRC:	MOVE	A,[XWD 3,B]
	JOBSTR	A,		;GET USER'S NEXT FILE STRUCTURE
	  JRST	UFDSE8		;SYSTEM PROBLEM
	TLNN	F,L.DIS		;SKIP IF DISMOUNT
	JUMPE	B,MAKSR2	;MOUNT STOPS AT FENCE
	AOJE	B,MAKSR2	;JUMP IF END OF LIST
	SOS	B
	MOVEM	B,MNTTYP+1(E)
	JUMPE	B,MAKSR1	;DONT DSKCHR THE FENCE
	MOVE	A,[XWD 1,B]
	DSKCHR	A,		;GET CURRENT STATUS OF THIS FILE STRUCTURE
	  JRST	UFDSE9		;CANT FAIL
	MOVE	B,MNTTYP+1(E)	;GET BACK FILE STRUCTURE NAME
	CAME	B,UFDFSN	;AND SEE IF WE ALREADY EXIST
	JRST	MAKSR1		;NO
	TLNN	F,L.DIS		;SKIP IF ACTUALLY DELETING
	JRST	MAKSR0
	TLO	F,L.PEND	;SUPPRESS ADDING UFDFSN TO LIST
	JRST	MAKSRC		;AND IGNORE THIS FILE STRUCTURE
MAKSR0:	LSH	A,-1		;ROTATE A TO MATCH UP D.SWL AND L.WRTL
	XOR	A,F		;COMPARE WRITE LOCK STATES
	TLNN	A,L.WRTL	;SKIP IF DIFFERENT
	JRST	CPOPJ		;NO CHANGE
	TLC	D,S.SWL
	SETZ	C,
MAKSR1:	MOVEM	C,MNTTYP+2(E)	;SAVE PROJECT,PROGRAMMER NUMBER
	MOVEM	D,MNTTYP+3(E)	;SAVE WRITE PROTECT REQUEST
	ADDI	E,3
	JRST	MAKSRC		;LOOP FOR ALL USER'S FILE STRUCTURES

UFDSE8:	UFDSEM <SYSTEM ERROR - JOBSTR UUO FAILED>
UFDSE9:	UFDSEM <SYSTEM ERROR - DSKCHR UUO FAILED>
MAKSR2:	TLZE	F,L.PEND
	JRST	MAKSR3		;DONT ADD FILE STRUCTURE 
MAKSRA:	SKIPN	MNTTYP+1(B)	;B STARTS AT 0 FROM ABOVE
	JRST	MAKSRB		;THE FENCE IS A 0
	ADDI	B,3
	CAIE	B,(E)		;IF END, NO FENCE
	JRST	MAKSRA
	JRST	MAKSR4		;OK TO PROCEED
MAKSRB:	MOVE	C,E		;IF FENCE, MUST MOVE EVERYTHING DOWN 1 ENTRY
MAKSRL:	CAIG	B,(C)		;SKIP IF MORE
	JRST	MAKSR4
	MOVE	A,MNTTYP(C)
	MOVEM	A,MNTTYP+3(C)
	SOJA	C,MAKSRL
MAKSR4:	MOVE	A,UFDFSN
	MOVEM	A,MNTTYP+1(B)	;ADD NEW FILE STRUCTURE
	SETZB	A,MNTTYP+3(B)
	TLNE	F,L.WRTL
	TLO	A,S.SWL		;A SET TO 0 ABOVE
	MOVEM	A,MNTTYP+2(B)
	ADDI	E,3
MAKSR3:	MOVEI	A,UFDMTP
	HRLI	A,4(E)		;LENGTH OF ARGUMENT LIST
	STRUUO	A,
	  JRST	UFDSE6
	POPJ	P,

UFDSE6:	TLNE	F,L.DIS
	JRST	UFDSE5
	MOVEI	N1,[ASCIZ .CANT ADD TO YOUR FILE STRUCTURE SEARCH LIST.]
	JRST	UFDSSE
UFDSE5:	MOVEI	N1,[ASCIZ .CANT REMOVE FILE STRUCTURE FROM SEARCH LIST.]
	JRST	UFDSSE
UFDSE7:	MOVEI	N1,[ASCIZ .CANT REDEFINE FILE STRUCTURE .]
UFDSSE:	MOVEI	CH,"?"
	PUSHJ	P,(IO)
	MOVE	M,UFDFSN
	PUSHJ	P,SIXMSG
	MOVEI	CH," "
	PUSHJ	P,(IO)
	MOVE	M,N1
	PUSHJ	P,MSG
	MOVE	N,A
	PUSHJ	P,OCTPRT
	PJRST	CRLF

UFDSMP:	MOVEI	CH,"?"
	PUSHJ	P,(IO)
	MOVE	M,UFDFSN
	PUSHJ	P,SIXMSG
	MOVEI	CH," "
	PUSHJ	P,(IO)
	MOVE	M,N1
	PUSHJ	P,MSG
	PJRST	CRLF
;THIS ROUTINE OUTPUTS ACCUMULATOR N AS AN OCTAL NUMBER

OCTPRT:	IDIVI N,10
	HRLM N1,0(P)		;SAVE EACH CHAR ON THE STACK
	SKIPE N
	PUSHJ P,OCTPRT		;RECURSE AS NECESSARY
	HLRZ CH,0(P)		;NOW RETRIEVE LAST CHAR
	ADDI CH,60		;MAKE ASCII
	JRST 0(IO)		;OUTPUT AND ASCEND A LEVEL- EXIT WHEN DONE
CRLF:	MOVEI	M,[ASCIZ .
.]
MSG:	HRLI M,440700
MSGL:	ILDB CH,M
	JUMPE CH,CPOPJ
	PUSHJ P,0(IO)
	JRST MSGL

>	;END CONDITIONAL ON MNTSUB
IFDEF MNTSUB,<LIST>

DECPRT:	IDIVI N,12
	HRLM N1,0(P)		;SAVE EACH CHAR ON THE STACK
	SKIPE N
	PUSHJ P,DECPRT		;RECURSE AS NECESSARY
	HLRZ CH,0(P)		;NO RETRIEVE THE LAST CHAR
	ADDI CH,60
	JRST 0(IO)		;OUTPUT AND ASCEND A LEVEL OR EXIT
U(UFDJBN)

IFDEF MNTSUB,<XLIST>
IFNDEF MNTSUB,<
U(UFDUPN)
U(UFDMPN)
U(UFDFSN)
UU(RH.USR,3)
UU(B.USR,205)
UU(SRCBUF,EXLLEN)
UU(CHRBUF,CHRLEN)
U(UFDMTP)
U(UFDDMJ)
U(UFDDMP)
U(UFDDMF)
MNTTYP=UFDDMF
U(MNTFSN)
U(MNTNUM)
UU(MNTBLK,SRWPS*STRJMX)
>
IFDEF MNTSUB,<LIST>

>	;END CONDITIONAL ON MNTSW
;TEXT MESSAGES

DEFINE MT (ADR,TEXT) <
ADR:	XLIST
	ASCIZ \TEXT\
	LIST>

MT RQSMSG,<
REQUEST STORED
>
MT HLPMSG,<
COMMANDS ARE:

F = FILE (DISK TO DECTAPE)
Z = ZERO. CLEARS DECTAPE, THEN DOES "F"
R = RECALL (DECTAPE TO DISK)
L = DIRECTORY. WRITES DECTAPE'S DIRECTORY
    AS TAPEID.DIR IN YOUR AREA (TAPEID - SEE BELOW)
C = CHECK. LISTS PENDING REQUESTS
W = WAIT FOR ALL PENDING REQUESTS TO FINISH
D = DELETE.  DELETES FILES FROM DECTAPE.

ARGUMENTS ARE:

TAPE ID: THE NUMBER OF YOUR DECTAPE

FILES:   STRUCTURE:FILENAME.EXT,FILE2.EXT2, ETC. (END WITH RETURN)
	(STRUCTURE IS OPTIONAL. DEFAULT IS 'DSK' OR LAST ONE TYPED)
	(* IS A LEGAL NAME OR EXTENSION)

THE SHORT FORM OF THESE COMMANDS IS (FOR EXAMPLE):

.FILE F,TAPEID,FILE1.EXT,*.REL

>
MT CLSMSG,<F(ILE),Z(ERO),R(ECALL),D(ELETE),L(IST),C(HECK),W(AIT),H(ELP)
*>
MT TAPMSG,<TAPE ID:>
MT MNYMSG,<?TOO MANY FILES. LAST PROCESSED IS >
MT FILMSG,<FILES: >
MT MISMSG,<?CAN'T FIND FILE >
MT PNDMSG,<PENDING:
>
MT CERMSG,<?SYNTAX ERROR
>
MT CMMMSG,<
?HAVE OPERATOR START OMOUNT, THEN TRY AGAIN.
>
MT IOMSG1,<?SYSTEM IO ERROR AT >
MT IOMSG2,< STATUS = >
MT MOHELP,<
/HELP    TYPE THIS (*=DEFAULT)
/WENABL *WRITE ENABLE
/WLOCK   WRITE LOCK
/RONLY   READ ONLY = /WLOCK
/MULTI  *MULTI ACCESS
/SINGLE  SINGLE ACCESS
/VID:ID  VISUAL I.D.
/CHECK   CHECK PENDING REQUESTS
/PAUSE   PAUSE BEFORE  REQUEST
>

MT DIHELP,<
/HELP   TYPE THIS
/REMOVE REMOVE F/S & UNITS FROM SYSTEM
/CHECK  CHECK PENDING REQUESTS
/PAUSE  PAUSE BEFORE REQUEST
>
MT NORMMS,<?NO ROOM IN QUEUE, TRY AGAIN LATER>
MT STAR,<
*>
MT NOLOGM,< MUST NOT BE A LOGICAL NAME>
MT NOWRTM,< MUST NOT BE LOCKED OR WRITE PROT.>

IFN MNTSW,<

MT FMDM,<FILE, MOUNT OR DISMOUNT
*>
MT ARMM,< ALREADY MOUNTED ON >
MT UNMM,< NOT MOUNTED
>
MT NRM,< NOT READY
>
MT PBWM,<PAUSE...(^C TO QUIT, CR TO CONT.)
>
MT LEQM,<QUOTA.SYS LOOKUP FAILURE>
MT TMRM1,< HAS ONLY >
MT TMRM2,< UNIT(S)
>
MT NSAM,<OTHER USERS--CANNOT SINGLE-ACCESS
>
MT SABJM,<?SINGLE ACCESS BY JOB >
MT NQFM,<LOOKUP FAILURE FOR AUXACC.SYS
>
MT CRQFM,<QUOTA.SYS OR AUXACC.SYS READ ERROR
>
MT WFVNQM,<QUOTA.SYS WRONG FORMAT VERSION
>
MT NEQFM,<NO ENTRY IN AUXACC.SYS
>
MT SWERM1,<?UNDEFINED SWITCH />
SWERM2==SWERM1
MT NFSMSG,<?NO STRUCTURE NAME>
MT NEDAM,<NOT ENOUGH DRIVES AVAILABLE
>
MT IMNTM,<STRUCTURE ALREADY MOUNTED
>
MT OPREM,<OPERATOR REQUESTED TO REMOVE PACKS
>
MT OPRDY,<OPERATOR REQUESTED TO READY DRIVES
>
MT MNTD,< MOUNTED
>
MT OPMNT,<OPERATOR REQUESTED TO MOUNT UNITS
>
MT DISDON,< DISMOUNTED
>
MT DNAM,< NOT AVAILABLE>
MT WKTM,< WRONG CONTROLLER TYPE>
MT WUTM,< WRONG UNIT TYPE>
MT IKON,< ILLEGAL DRIVE NAME>
MT KDNAM,< NO DRIVE AVAILABLE ON THIS CONTROLLER>
MT DINCOM,< DISMOUNT INCOMPLETE>
MSG100:	PUSHJ	P,SIXTTY
	PTYPE	< NOT AVAILABLE>

MSG101:	MOVE	M,LOGNAM
	PUSHJ	P,SIXTTY
	PTYPE	< LOGICAL NAME IN USE (NAME IGNORED)>

MSG102:	TYPE	<CANT OPEN >
MSG103:	MOVE	M,B
	HRRZ	N,(P)
	PUSHJ	P,SIXTTY
	TYPE	< AT LOC >
	JRST	MSG902

MSG104:	TYPE	<CANT ASSIGN >
	JRST	MSG103

MSG105:	MOVE	M,DVVNAM
	PUSHJ	P,SIXTTY
	PTYPE	< NOT ASSIGNED>

MSG110:	PTYPE	<OPERATOR NOTIFIED>

MSG111:	PTYPE	<WAITING...>

MSG112:	PTYPE	<NONE PENDING>

MSG113:	PTYPE	<NO OPR. JOB FOR REQUESTS>

MSG900:	HRRZ	N,(P)
NEVMSG:		;'SHOULDNT GET HERE' ERRORS
MSG901:	TYPE	<SYSTEM ERROR AT LOC >
MSG902:	HRRZS	N
	PUSHJ	P,OCTPRT
	PJRST	CRLF


ERR100:	XTYPE	<?LEVEL-D ONLY
>

ERR101:	XTYPE	<?REQUIRES DEVICE NAME
>

ERR103:	XTYPE	<?USE COMMAND
>

ERR104:	XTYPE	<?REQUIRES LOGICAL NAME
>

ERR503:	XTYPE	<?MONITOR MUST BE 5.03 OR LATER
>

ERR900:	PUSHJ	P,MSG900
	JRST	ERR912
NEVERR:			;'NEVER GET HERE' ERRORS GET HERE
ERR901:	PUSHJ	P,MSG901
	JRST	ERR912

ERR912:	PUSHJ	P,QUEST
ERR913:	MOVE	M,DVVNAM
	PUSHJ	P,SIXTTY
	XTYPE	< MOUNT INCOMPLETE
>

>	;END CONDITIONAL ON MNTSW

IFE MNTSW,<
MT NODISM,<
DISMOUNT IS NOT A LEGAL COMMAND>
MT NOMNTM,<
MOUNT IS NOT A LEGAL COMMAND>
>	;END CONDITIONAL ON MNTSW

GOAWAY:
MSGRET:
ERREXI:
ALLFIN:
ERRRET:	PUSHJ	P,MSGTTY
ALLOVR:
MONRET:	OUTPUT	TTY,
	RELEASE
	EXIT	1,
	EXIT
;DATA

MFDPPN:	XWD 1,1
SYSPPC==MFDPPN		;SYS PPN FOR LEVEL C
SYSPPD:	XWD	1,4	;SYS PPN FOR LEVEL D

IFN MNTSW,<
HLISTI:	IOWD	200,B.USR
	0

KONSIX:	SIXBIT	.DR.
	SIXBIT	.FH.
	SIXBIT	.DP.
	SIXBIT	.MF.
>

NAMFIL:	SYSFIL	;OMOUNT PROG.NAMES TO LOOK FOR
NAMMNT:	SYSMOU
NAMOMO:	SYSOMO

PDP:	IOWD	20,PDLIST

;LITERALS

XLIST
LIT
LIST

HIEND:	;END OF HIGH SEG

;VARIABLES

UU(HLIST,2)
U(IORPPN)
U(CMDPPN)
U(CMDSTR)
U(SYSPPN)
U(CMDCHR)
U(CMDNAM)
U(COMCNT)
U(USRPPN)
U(JOBNO)
U(SAVED)
U(MONVER)
U(STATES)
U(STDDEV)
U(DEFDEV)	;DEFAULT F.S.
U(TAPEID)
U(TTYLIN)

UU(FILBLK,DTDNFI+2)
UU(FILDEV,DTDNFI+2)
UU(FILBEX,DTDNFI+2)
U(FILBKE)
IFNDEF SRCBUF,<
UU(SRCBUF,EXLLEN)>
UU(PDLIST,20)
;BUFFER AREAS

UU(WH.CMD,3)
UU(WH.TTY,3)
UU(RH.TTY,3)
UU(RH.CMU,3)
UU(RH.CMD,3)

UU(B.TTY,2*30)
UU(B.CMD,205)
UU(B.CMU,205)

IFN MNTSW,<

U(CMDFSN)
U(PHYNAM)
U(DVVNAM)
FSNAME==DVVNAM
U(DEVMOD)
VIDL==<VIDMAX+4>/5
UU(VID,VIDL)
U(VIDK)
U(LOGNAM)
U(LOOPX1)
U(ENTSIZ)
U(FSCLAS)
U(OWNPPN)
U(TEMBP)
LASTUN=TEMBP
U(NUMDRV)
U(NUMREQ)
U(SAVDRV)
U(UDREQ)
UU(USRDRV,8*MAXKON)
UU(PACKID,8*MAXKON)
UU(PKCLAS,8*MAXKON)
UU(DROFFL,8*MAXKON)
UU(DRIVE,8*MAXKON)
UU(DRVSTT,8*MAXKON)

>	;END CONDITIONAL ON MNTSW

RELOC
LOEND:	END	UMOUNT
 O 	e