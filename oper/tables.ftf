C       TABLES.FTF
        SUBROUTINE SETWRI
C
C       THIS ROUTINE SETS THE RE-WRITE FLAGS
C
        COMMON /TITLE/ TITLE(16), MODIFY(2), NEWMOD, MODFLG, WRITEIT,
     1  XMIN, XMAX, YMIN, YMAX, PICFRAM
        INTEGER TITLE
        LOGICAL MODFLG, NEWMOD, WRITEIT, PICFRAM
C
C       DO IT
        NEWMOD = MODFLG
        WRITEIT = .TRUE.
        RETURN
        END
        SUBROUTINE PUTSOC
C
C       THIS ROUTINE OUTPUTS THE SOCKET DESCRIPTION IF NECESSARY
C
        COMMON /SOCKET/ SOC(5), WRITEIT, CURRENT
        INTEGER CURRENT
        LOGICAL WRITEIT
C
        COMMON /FILES/ OTHER(7,2), FSOCKET(7)
        INTEGER FSOCKET
C
C       WRITE IT OUT, CLEAR FLAG
        IF (WRITE IT) CALL SETWRI
        IF (WRITE IT) WRITE (FSOCKET(1) # CURRENT ) SOC
        WRITE IT = .FALSE.
        RETURN
        END
        SUBROUTINE GETSOC(N)
C
C       THIS ROUTINE GETS SOCKET N INTO STORAGE, SAVING OLD DATA IF
C       NECESSARY
C
        COMMON /SOCKET/ SOC(5), WRITEIT, CURRENT
        INTEGER CURRENT
        LOGICAL WRITEIT
C
        COMMON /FILES/ OTHER(7,2), FSOCKET(7)
        INTEGER FSOCKET
C
C       TEST IF ALREADY THERE
        IF (N .EQ. CURRENT) RETURN
C
C       TEST IF TO SAVE PREVIOUS DATA
        IF (WRITE IT) CALL PUTSOC
C
C       GET BLOCK N, MAKE IT CURRENT
        READ (FSOCKET(1) # N) SOC
        CURRENT = N
        RETURN
        END
        SUBROUTINE PUTPIN
C
C       THIS ROUTINE OUTPUTS THE PIN DESCRIPTION IF NECESSARY
C
        COMMON /PINS/ PIN(15), WRITEIT, CURRENT
        INTEGER CURRENT
        LOGICAL WRITEIT
C
        COMMON /FILES/ OTHER(7,3), FPIN(7)
        INTEGER FPIN
C
C       WRITE IT OUT, CLEAR FLAG
        IF (WRITE IT) CALL SETWRI
        IF (WRITE IT) WRITE (FPIN(1) # CURRENT ) PIN
        WRITE IT = .FALSE.
        RETURN
        END
        SUBROUTINE GETPIN(N)
C
C       THIS ROUTINE GETS PIN N INTO STORAGE, SAVING OLD DATA IF
C       NECESSARY
C
        COMMON /PINS/ PIN(15), WRITEIT, CURRENT
        INTEGER CURRENT
        LOGICAL WRITEIT
C
        COMMON /FILES/ OTHER(7,3), FPIN(7)
        INTEGER FPIN
C
C       TEST IF ALREADY THERE
        IF (N .EQ. CURRENT) RETURN
C
C       TEST IF TO SAVE PREVIOUS DATA
        IF (WRITE IT) CALL PUTPIN
C
C       GET BLOCK N, MAKE IT CURRENT
        READ (FPIN(1) # N) PIN
        CURRENT = N
        RETURN
        END
        SUBROUTINE PUTSIG
C
C       THIS ROUTINE WRITES THE HASH BLOCK OUT TO THISSIG IF SIGWRIT
C       IS SET
C
        COMMON /FILES/ FILES(7, 4), FSIGNAL(7)
        INTEGER FSIGNAL
C
        COMMON /HASHCON/ NHASH, NBLOCK, THISSIG, SIGID(2), NEXT,
     1  NEXTPIN, SIGWRIT, DSHEAD(2), CDSN
        INTEGER THISSIG, SIGID, DSHEAD, CDSN
        LOGICAL SIGWRIT
C
C       WRITE IT IF NECESSARY
        IF (SIGWRIT) WRITE(FSIGNAL(1) # THISSIG) SIGID, NEXT, NEXTPIN
        SIGWRIT = .FALSE.
        RETURN
        END
        SUBROUTINE GETSIG(N)
C
C       THIS ROUTINE GETS SIGNAL N INTO THE HASH BLOCK
C
        COMMON /FILES/ FILES(7, 4), FSIGNAL(7)
        INTEGER FSIGNAL
C
        COMMON /HASHCON/ NHASH, NBLOCK, THISSIG, SIGID(2), NEXT,
     1  NEXTPIN, SIGWRIT, DSHEAD(2), CDSN
        INTEGER THISSIG, SIGID, DSHEAD, CDSN
        LOGICAL SIGWRIT
C
C       TEST IF WE ALREADY HAVE THE SIGNAL
        IF (THISSIG .EQ. N) RETURN
C
C       WRITE THE OLD SIGNAL IF NOT
        IF (SIGWRIT) CALL PUTSIG
C
C       GET THE NEW DATA
        READ (FSIGNAL(1) # N) SIGID, NEXT, NEXTPIN
        THISSIG = N
        RETURN
        END
        INTEGER FUNCTION HASH(ID)
C
C       HASH COMPUTES THE HASHCODE FOR ID
C
        COMMON /HASHCON/ NHASH, NBLOCK, THISSIG, SIGID(2), NEXT,
     1  NEXTPIN, SIGWRIT, DSHEAD(2), CDSN
        INTEGER THISSIG, SIGID, DSHEAD, CDSN
        LOGICAL SIGWRIT
C
        DIMENSION ID(2)
C
C       COMPUTE IT
        HASH = ID(1) .XOR. ID(2)
        HASH = HASH/2
        HASH = HASH .AND. "377777777777
        HASH = MOD(HASH, NHASH) + 1
        RETURN
        END
        LOGICAL FUNCTION SIGLOOK(ID)
C
C       SIGLOOK LOCATES THE SIGNAL BLOCK CORRESPONDING TO ID.  RETURN 
C       .TRUE. IF THERE.  ELSE RETURN .FALSE., IF NOT.  NID IS THE
C       BLOCK NUMBER OF THE APPROPRIATE BLOCK IF FOUND, THE LAST
C       BLOCK IF NOT.
C
        COMMON /HASHCON/ NHASH, NBLOCK, THISSIG, SIGID(2), NEXT,
     1  NEXTPIN, SIGWRIT, DSHEAD(2), CDSN
        INTEGER THISSIG, SIGID, DSHEAD, CDSN
        LOGICAL SIGWRIT
C
        DIMENSION ID(2)
        INTEGER HASH
C
C       DETERMINE IF THE SIGNAL IS ALREADY IN THE BLOCK
        IF (SIGID(1) .NE. ID(1) ) GO TO 100
        IF (SIGID(2) .EQ. ID(2) ) GO TO 120
C
C       COMPUTE THE HASH(ID)
  100   NID = HASH(ID)
C
C       EXAMINE THE NID-TH BLOCK FOR MATCH, ASSUME .FALSE. RETURN
        SIGLOOK = .FALSE.
  110   CALL GETSIG(NID)
        IF(SIGID(1) .NE. ID(1) ) GO TO 130
        IF (SIGID(2) .NE. ID(2) ) GO TO 130
C
C       FOUND MATCH..RETURN
  120   SIGLOOK = .TRUE.
        RETURN
C
C       SCAN FURTHER
  130   IF (NEXT .EQ. 0) RETURN
        NID = NEXT
        GO TO 110
        END
        SUBROUTINE SIGSET( ID )
C
C       THIS ROUTINE PUTS A BLOCK FOR SIGNAL ID INTO THE TABLE
C
        COMMON /HASHCON/ NHASH, NBLOCK, THISSIG, SIGID(2), NEXT,
     1  NEXTPIN, SIGWRIT, DSHEAD(2), CDSN
        INTEGER THISSIG, SIGID, DSHEAD, CDSN
        LOGICAL SIGWRIT
C
        DIMENSION ID(2)
C
C       SKIP IF BLOCK ID IS NULL
  100   IF(SIGID(1) .EQ. 0) GO TO 120
C
C       NOT NULL..LINK TO AND DEFINE A NEW ENTRY
        IF (NEXT .EQ. 0) GO TO 110
        CALL GETSIG(NEXT)
        GO TO 100
C
C       LAST IN CHAIN
  110   SIGWRIT = .TRUE.
        NEXT = NBLOCK + 1
        NBLOCK = NEXT
C
C       SAVE THIS BLOCK
        CALL PUTSIG
        THISSIG = NEXT
        NEXT = 0
C
C       FILL THE DATA INTO THE NEW BLOCK
  120   SIGID(1) = ID(1)
        SIGID(2) = ID(2)
        NEXTPIN = 0
        SIGWRIT = .TRUE.
        CALL PUTSIG
        RETURN
        END
        SUBROUTINE SIGFIND(ID)
C
C       SIGFIND RETURNS THE BLOCK INDEX OF THE SIGNAL BLOCK IN THISSIG
C       CORRESPONDING TO SIGNAL ID, CREATING A NEW BLOCK IF NECESSARY
C
        DIMENSION ID(2)
        LOGICAL SIGLOOK
C
C       DETERMINE IF THE SIGNAL IS ALREADY DEFINED
        IF (SIGLOOK(ID) ) RETURN
C
C       NOT THERE..DEFINE IT
        CALL SIGSET(ID)
        RETURN
        END
        LOGICAL FUNCTION SIGDID(N, ID)
C
C       SIGDID (SIGNAL.DEFINE.ID) GENERATES ID IN THE CURRENT FORM OF
C       OF DEFINED SIGNAL, WITH THE DEFINED SIGNAL NUMBER N.  RETURNS
C       .TRUE. IF N FITS WITHIN THE NUMERIC FIELD SPECIFIED, ELSE
C       RETURNS .FALSE., AND TRUNCATES NUMBER.
C
        DOUBLE PRECISION IDTEMP, ID
        INTEGER BLANK, ZERO, NINE
        DATA BLANK, ZERO, NINE / "40, "60, "71 /
C
        COMMON /HASHCON/ NHASH, NBLOCK, THISSIG, SIGID(2), NEXT,
     1  NEXTPIN, SIGWRIT, DSHEAD, CDSN
        DOUBLE PRECISION DSHEAD
        INTEGER THISSIG, SIGID, CDSN
C
    1   FORMAT(I10)
C
C       FIRST DEFINE THE SIGNAL BASE
        ID = DSHEAD
C
C       FIND LAST "9" IN ID
        DO 100 I = 10, 1, -1
         IF (MGETCH(I, ID) .EQ. NINE ) GO TO 110
  100   CONTINUE
C
C       NOW HAVE THE POSITION FOR THE LAST CHARACTER
  110   ENCODE (10, 1, IDTEMP) N
C
C       NOW MOVE THE CHARACTERS FROM IDTEMP TO ID
        J = 10
        DO 120 K = I, 1, -1
         IF (MGETCH(K, ID) .NE. NINE) GO TO 130
         L = MGETCH(J, IDTEMP)
         IF (L .NE. BLANK) J = J - 1
         IF (L .EQ. BLANK) L = ZERO
  120    CALL MPUTCH(L, K, ID)
C
C       DONE..DETERMINE IF OVERFLOW
  130   SIGDID = .TRUE.
        IF (MGETCH(J, IDTEMP) .EQ. BLANK) RETURN
        SIGDID = .FALSE.
        RETURN
        END
        SUBROUTINE SIGDNEW
C
C       SIGDNEW (SIGNAL.DEFINE.NEW) INCREMENTS THE CURRENTLY DEFINED
C       SIGNAL NUMBER, AND DEFINES A UNIQUE SIGNAL.  IF IT IS IMPOSSIBLE
C       TO DEFINE A NEW SIGNAL, AN ERROR MESSAGE IS OUTPUT AND A
C       NON-UNIQUE SIGNAL IS DEFINED.
C
        COMMON /HASHCON/ NHASH, NBLOCK, THISSIG, SIGID(2), NEXT,
     1  NEXTPIN, SIGWRIT, DSHEAD(2), CDSN
        INTEGER THISSIG, SIGID, DSHEAD, CDSN
C
        INTEGER ID(2)
        LOGICAL SIGDID
    1   FORMAT(' ***ERROR***DEFINED SIGNAL LIMIT REACHED, ',
     1          ' VERIFY USAGE'/)
C
C       INCREMENT SIGNAL NUMBER, DEFINE SIGNAL
  100   CDSN = CDSN + 1
        IF (.NOT. SIGDID(CDSN, ID) ) GO TO 110
        IF (SIGLOOK(ID) ) GO TO 100
C
C       HAVE A UNIQUE SIGNAL..DEFINE IT
        CALL SIGSET(ID)
        RETURN
C
C       RAN OUT..BITCH AND DEFINE ANYWAY
  110   TYPE 1
        CALL SIGFIND(ID)
        RETURN
        END
        INTEGER FUNCTION SIGDEF(NULL)
C
C       SIGDEF LOOKS AT THE LINE INPUT AND DETERMINES IF THERE IS A
C       SIGNAL REFERENCE OF THE FORM: *; **; OR **-nn.
C       RETURNS -1 IF NOT OF CORRECT TYPE; 0 IF EXPRESSION ERROR;
C       BLOCK NUMBER > 0 IF SUCCESS.
C
        COMMON /HASHCON/ NHASH, NBLOCK, THISSIG, SIGID(2), NEXT,
     1  NEXTPIN, SIGWRIT, DSHEAD(2), CDSN
        INTEGERTHISSIG, SIGID, DSHEAD, CDSN
        LOGICAL SIGWRIT
C
        DIMENSION ID(2)
        LOGICAL KANDO
C
C       ASSUME NOT "*", GET CHARACTER
        SIGDEF = -1
        I = NOWCH(4, KANDO)
        IF (.NOT. KANDO) RETURN
        IF (I .NE. '*') RETURN
C
C       GOT "*", DETERMINE IF "**"
        I = NEXTCH(8, KANDO)
        IF (.NOT. KANDO) GO TO 130
        IF (I .NE. '*') GO TO 130
C
C       GOT "**", SAVE VALUE
        NO = CDSN
        I = NEXTCH(4, KANDO)
        IF (.NOT. KANDO) GO TO 120
        IF (I .NE. '-') GO TO 120
C
C       GOT "**-", GET NUMBER
        SIGDEF = 0
        CALL NEXTCH(4, KANDO)
        IF (LOOKIN(J) .EQ. 2) GO TO 110
  100   RETURN
C
C       GOT VALID nn
  110   NO = NO - J
        IF (NO .LE. 0) GO TO 100
C
C       ALL OK..NOW LOOK IT UP
  120   CALL SIGDID(NO, ID)
        CALL SIGFIND(ID)
        SIGDEF = THISSIG
        RETURN
C
C       HERE IF WE GOT "*", FIND NEW SIGNAL
  130   CALL SIGDNEW
        SIGDEF = THISSIG
        RETURN
        END
        LOGICAL FUNCTION SIGREF(NULL)
C
C       THIS FUNCTION LOOKS AT THE INPUT LINE, EXTRACTS A VALID SIGNAL
C       NAME IF ONE EXISTS, AND RETURNS .TRUE.
C
        INTEGER ID(2), SIGDEF, SIGSTR
        LOGICAL ALPHANO, MATCH, PACK
C
C       ASSUME FAILURE
        SIGREF = .FALSE.
        I = NOWCH(4, KANDO)
        IF (.NOT. KANDO) RETURN
C
C       FIRST CHAR WAS VALID..GET ID
        I = SIGDEF(I)
        IF (I .EQ. 0) RETURN
        IF (I .LT. 0) GO TO 100
        SIGREF = .TRUE.
        RETURN
C
C       NOT OF FORM "*", "**"
  100   SIGREF = SIGSTR(ID(1) )
        IF (SIGREF) CALL SIGFIND(ID)
        RETURN
        END
        LOGICAL FUNCTION SIGSTR(ID)
C
C       SIGSTR DETERMINES IF THE INPUT LINE CONTAINS A VALID SIGNAL
C       NAME AS THE NEXT STRING.  RETURNS .FALSE. IF NOT;  ELSE
C       RETURN .TRUE., ID = STRING
C
        DIMENSION ID(2)
C
C       SET STRING, GET IT
        ID(1) = 0
        ID(2) = 0
        SIGSTR = PACK(ID(1), 10, '+-/\' )
        RETURN
        END
    