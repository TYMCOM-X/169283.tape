C**********************************************************************
C***			SIM4.F4					   ****
C***  	     I N T E L   M C S - 4   S I M U L A T O R		   ****
C***			01/10/73	(NSM4)			   ****
C***		COPYRIGHT 1972 INTEL CORP.			   ****
C**********************************************************************
C   INTEGER VARIABLES THAT HAVE DIRECT COUNTERPARTS IN THE MCS4.
	INTEGER AC,CY,RAM(16,4,16),RAMSTI(4,4,16),RAMPRT(16),
	1ROMPRT(16),ROM(1024),PC,R(16),STACK(4),H2B(20),ITA(4)
C   AUXILLARY INTEGER VARIABLES
	INTEGER PC1,PC2,PH,R0,R1,RR,D2,D1,DBX2,DBX3,RA,AB,D,TEMP,
	1AMCHIP,AMBANK,AMWD,OMCHIP,M,KBP(16),SPTR,T,
	2OPR,OPA,OPR1,OPA1,OPAONE,NJMS,NBBL,XSJMS,XSBBL,CDNO
	3,INM(20)
C   INTEGERS ASSOCIATED WITH CPU DUMP
	INTEGER CC,B1,B2,D2D1,REG(16),AMPNT(16),AMST(4),AMPRT(4)
	1,DC1,CP(3),STK(12),DC
C   VARIABLES ASSOC WITH RAM DUMP
	INTEGER DPRT,DSTAT(4,4),DRAM(16,4),IOUT(20),KCM(19)
C    VARIABLES ASSOCIATED WITH 4008 AND "WPM"
	INTEGER WPMON, WPMPRT, WPMNXT, WPMMAP (16), FL4008, FL408I,
	1  WPMTYP (3)
	DATA (WPMMAP (I), I = 1, 16) / 16 * -1 /
	DATA (WPMTYP (I), I = 1, 3) / 1HN, 1HM, 1HR /
	DATA WPMPRT, WPMNXT, WPMON, FL4008, FL408I / 0, 0, 0, 0, 0 /
C
	INTEGER LIN(4),LTD(4),LTR(4),MM1(16),MP1(8),MN1(16),MWR(4)
	INTEGER MRD(4),MB1(16)
	EQUIVALENCE(D2,OPR1),(D1,OPA1),(D,OPA),(OMCHIP,DBX2)
	LOGICAL C,C1,C2,C3,C4,TEST,C5
	DATA (H2B(I),I=1,17)/1H0,1H1,1H2,1H3,1H4,1H5,1H6,1H7,1H8
	1,1H9,1HA,1HB,1HC,1HD,1HE,1HF,1H-/
	DATA KBP(1),KBP(2),KBP(3),KBP(4),KBP(5),KBP(6),KBP(7),KBP(8),
	1 KBP(9),KBP(10),KBP(11),KBP(12),KBP(13),KBP(14),KBP(15)
	2,KBP(16)/   0,1,2,15,3,15,15,15,4,15,15,15,15,15,15,15/
	DATA IBLANK/4H    /
	DATA IBLK5/5H     /
	DATA NCOM/19/
	DATA (KCM(I),I=1,19)/1HJ,1HB,1HE,1HS,1HR,1HI,1HT,1HD,1HA,1HC
	1,1HL,1HW,1HX,1HH,1HF,1HM,1HO,1HU,1HP/
	DATA (MP1(I),I=1,8)/2HP0,2HP1,2HP2,2HP3,2HP4,2HP5,2HP6
	1,2HP7/
	DATA (MM1(I),I=1,16)/2HNC,2HT0,2HC1,2H03,2HAZ,2H05,2H06
	1,2H07,2HNJ,2HT1,2HC0,2H11,2HAN,2H13,2H14,2H15/
	DATA (MN1(I),I=1,16)/2H 0,2H 1,2H 2,2H 3,2H 4,2H 5,2H 6,
	12H 7,2H 8,2H 9,2H10,2H11,2H12,2H13,2H14,2H15/
	DATA (MWR(I),I=1,4)/3HWR0,3HWR1,3HWR2,3HWR3/
	DATA (MRD(I),I=1,4)/3HRD0,3HRD1,3HRD2,3HRD3/
	DATA (MB1(I),I=1,16)/2HB0,2HB1,2HB2,2HXX,2HB3,11*2HXX/
	DATA (ROM(I),I=1,1024)/1024*0/
	NRAMS=16
C
C  TYPE HEADER INFORMATION
C
	TYPE 90
 90	FORMAT(' INTEL MCS-4 SIMULATOR V2.2')
	TYPE 92
 92	FORMAT(1H )
	TYPE 93
 93	FORMAT(' FOR INSTRUCTION LIST, TYPE Q:',$)
	ACCEPT 94,IQ
 94	FORMAT(A1)
	IF(IQ/2-1HQ/2)100,95,100
C  TYPE INSTRUCTION LIST
 95	TYPE 96
 96	FORMAT(' ALL INSTRUCTIONS ARE OF THE FORM AN WHERE A IS A '
	1,'SINGLE LETTER'/' AND N IS A NUMERIC VALUE '
	2,'FROM 0 TO 99999'//' A=SET PROGRAM COUNTER TO N'/' B='
	3,'SET BREAK POINT AT N'/' C=CALL SUBROUTINE AT N, BRE'
	4,'AK AT EXIT'/' D=DUMP MEMORY'/' E=EXAMINE RAMWORD N'/
	5' F=IF N=1, PORT INPUTS FROM FILE.  OTHERWISE TTY'/
	6' H=PRINT HEADER FOR TRACE OUTPUTS'/
	7' I=INITIALIZE.  IF N>0, SET INSTR. COUNT LIMIT TO N'/
	8' J=JUMP TO N. (STOP AT BKPT)'/' L=TRACE N INSTRUCTIONS'
	9,' ON LPT'/' M=INPUT TO RAM WORD N')
	TYPE 97
 97	FORMAT(' O=IF N=1, SHORT FORM OUTPUT'/
	1,' P=IF N=1, "WPM" INSTRUCTION IS SIMULATED.'/' R=PRINT CPU REG'
	1,'ISTERS'/' S=PRINT STACK CONTENTS'/' T=TRACE NEXT N '
	2,'INSTRUCTIONS'/' U=BREAK AFTER N INSTRUCTIONS'/
	3' W=WRITE INTO ROM WORD N'
	4/' X=EXIT FROM PROGRAM'//' NOTE RAM WORD SEQUENCE IS MAIN '
	5,'HIGH TO MAIN LOW'/' FOLLOWED BY STATUS 0 TO 3'/
	6' INPUTS IN HEX(0-F) WITH "-" TO LEAVE LOCATION '
	7,'UNCHANGED')
	TYPE 92
	TYPE 98
 98	FORMAT(' RENAMED DATA FILES MAY BE OVERLAYED.  WHEN REQ'
	1,'UESTED, TYPE'/' FILE NAME (ONE PER REQUEST).  LAST '
	2,'DATA FILE MUST BE ROMAR.DAT.'/' THIS IS LOADED BY '
	3,'TYPING A CARRIAGE RETURN AT THE FILE NAME '/
	4' REQUEST.  EACH FILE OVERLAYS PREVIOUS DATA EXCEPT WHEN'
	5/' NEW FILE DATA IS 0(NOP)'/1H /1H )
C  READ ROM CONTENTS FROM DATA FILES AND ROMAR.DAT
 100	INFN=IBLK5
	TYPE 102
 102	FORMAT(' DATA FILE NAME=',$)
	ACCEPT 104,INFN
 104	FORMAT(A5)
	IF(INFN/2-IBLK5/2)105,110,105
 105	CALL IFILE(21,INFN)
	GO TO 120
 110	CALL IFILE(21,'ROMAR')
 120	NCF=-1
	NCL=-1
	DO 149 I=1,256
	READ(21,122)(LIN(IXN),IXN=1,4)
 122	FORMAT(4I)
	DO 144 J=1,4
	IAX=4*(I-1)+J
	CALL UNPK(LIN(J),LTD)
	CALL UNPK(ROM(IAX),LTR)
	DO 139 K=1,4
	IF(LTD(K))131,139,131
 131	IF(LTR(K))133,137,133
 133	IF(LTD(K)-LTR(K))135,139,135
 135	NCL=4*(IAX-1)+K-1
	IF(NCF)136,137,137
 136	NCF=NCL
 137	LTR(K)=LTD(K)
 139	CONTINUE
	CALL REPK(LTR,ROM(IAX))
 144	CONTINUE
 149	CONTINUE
	IF(NCF)155,150,150
 150	TYPE 151,NCF,NCL
 151	FORMAT(' OVL',1H','S FROM ',I4,' TO ',I4)
 155	IF(INFN/2-IBLK5/2)100,160,100
C
C  RESET PARAMETERS
 160	NA=0
	ITRL=10000
C
C  INITIALIZATION PROCEDURE--NOTE IF NA IS NOT ZERO,
C  SET THE CYCLE EXECUTION LIMIT TO NA.
 900	IF(NA)912,912,911
 911	ITRL=NA
 912	AC=0
	AMBANK=0
	AMCHIP=0
	DBX2=0
	DBX3=0
	FL4008=FL408I
	IBKP=0
	NJMS=0
	NBBL=0
	IOPT=0
	ISRT=-1
	ITRC=0
	ITMD=0
	PC=0
	CY=0
	SPTR=0
	TEST = .FALSE.
	T=0
	TYPE 311
	INC=0
	DO 902 I=1,4
	STACK(I)=0
 902	CONTINUE
	DO 904 I=1,16
	R(I)=0
	RAMPRT(I)=0
	ROMPRT(I)=0
	DO 904 J=1,4
	DO 903 K=1,4
  903 RAMSTI(K,J,I)=0
	DO 904 L=1,16
  904 RAM(L,J,I)=0
C
C  ACCEPT INPUT COMMAND STRING
 200	TYPE 201
 201	FORMAT(' *',$)
	ACCEPT 204,IK,NA
 204	FORMAT(A1,I)
C  SEARCH LIST OF INPUT COMMANDS
	DO 209 J=1,NCOM
	IF(IK/2-KCM(J)/2)209,215,209
 209	CONTINUE
 210	TYPE 211
 211	FORMAT(' ?ILLEGAL COMMAND')
	GO TO 200
C  GO TO PROCESS INPUT COMMAND
C  310=J, 320=B, 330=E, 340=S, 350=R, 900=I, 370=T, 380=D
C  390=A, 400=C, 410=L, 420=W, 450=X, 480=H, 490=F, 500=M
C  550=O, 560=U, 570=P
 215	GO TO(310,320,330,340,350,900,370,380,390,400,410,420,450,480
	1,490,500,550,560,570),J
C  J=JUMP TO ADDRESS NA
 310	PC=NA
	T=0
	TYPE 311
 311	FORMAT(' CY CTR RESET')
	NJMS=0
	NBBL=0
	ITRC=ITRL
	GO TO 1000
C  B=INSERT BREAKPOINT AT NA
 320	IBKP=NA
	GO TO 200
C  E=EXAMINE RAM WORD #NA
 330	IF(NA)210,331,331
 331	IF(NA-64)332,210,210
 332	KBNK=NA/16
	KCOB=MOD(NA/4,4)
	KWIC=MOD(NA,4)
	DO 333 I=1,16
	IOUT(I)=H2B(RAM(17-I,KWIC+1,KCOB+4*KBNK+1)+1)
 333	CONTINUE
	DO 334 I=1,4
	IOUT(I+16)=H2B(RAMSTI(I,KWIC+1,KCOB+4*KBNK+1)+1)
 334	CONTINUE
	TYPE 338,(IOUT(I),I=1,20)
 338	FORMAT(1H ,16A1,1H ,4A1)
	GO TO 200
C  S=DISPLAY STKPTR AND CONTENTS OF STACK
 340	TYPE 342,SPTR,(STACK(I),I=1,4)
 342	FORMAT(' SPTR=',I2,' STACK=',4I6)
	GO TO 200
C  R=DISPLAY CONTENTS OF CPU REGISTERS
 350	TYPE 352,(R(I),I=1,16)
 352	FORMAT(' R0-R15= ',15(I2,','),I2)
	GO TO 200
C  T=TRACE MODE FOR NEXT NA INSTRUCTIONS
 370	ITRC=NA
	ITMD=1
	GO TO 1000
C  D=DUMP ENTIRE CONTENTS OF RAM
 380	DO 385 J=1,64
	KBNK=(J-1)/16
	KCOB=MOD((J-1)/4,4)
	KWIC=MOD(J-1,4)
	DO 383 I=1,16
	IOUT(I)=H2B(RAM(17-I,KWIC+1,KCOB+4*KBNK+1)+1)
 383	CONTINUE
	DO 384 I=1,4
	IOUT(I+16)=H2B(RAMSTI(I,KWIC+1,KCOB+4*KBNK+1)+1)
 384	CONTINUE
	TYPE 338,(IOUT(I),I=1,20)
 385	CONTINUE
	GO TO 200
C  A=INITIALIZE PC TO VALUE NA
 390	PC=NA
	T=0
	TYPE 311
	NJMS=0
	NBBL=0
	GO TO 200
C  C=CALL SUBROUTINE AT ADDRESS NA.  BREAKPOINT WHEN RETURN AT THIS
C  LEVEL IS EXECUTED.
 400	ISRT=1
	ITRC=ITRL
	NJMS=1
	NBBL=0
	T=0
	TYPE 311
	PC=NA
	GO TO 1000
C  L=LIST OPTION ON LINE PRINTER
 410	ITRC=NA
	ITMD=-1
	GO TO 1000
C  W=WRITE TO ROM AT ADDRESS=NA
 420	TYPE 424
 424	FORMAT(1H ,'VALUE(DEC)=',$)
	ACCEPT 426,IRV
 426	FORMAT(I)
	IF(NA-4095)428,428,430
 428	IF(IRV-255)435,435,430
 430	TYPE 431
 431	FORMAT(1H ,'INPUT OUT OF RANGE')
	GO TO 200
 435	IWP=1+MOD(NA,4)
	IRA=1+NA/4
	ITM=ROM(IRA)
C  UNPACK ROMWORD IMAGE ITM
	DO 439 I=1,4
	ITY=ITM/256
	ITA(I)=ITM-256*ITY
	ITM=ITY
 439	CONTINUE
	ITA(IWP)=IRV
C  NOW REPACK ROMWORD AND STORE IN ROM ARRAY
	ITM=0
	DO 444 I=1,4
	IX=5-I
	ITM=256*ITM+ITA(IX)
 444	CONTINUE
	ROM(IRA)=ITM
	GO TO 200
C  X=EXIT FROM PROGRAM
 450	CALL EXIT
C  H=PRINT HEADER RECORD
 480	TYPE 481
	TYPE 482
	GO TO 200
 481	FORMAT('   P  OPR OP ADDR  C  A 0--REGISTERS---1  B  R  C TIME')
 482	FORMAT('   C      AR DATA  Y  C 0              5  K  G  H (CY)')
C
C  F=INPUT TO ROM PORTS TO BE TAKEN FROM A FILE IF NA=1, TTY IF NA=0
 490	IF(NA-1)491,492,491
 491	NDEV=5
	GO TO 200
 492	TYPE 493
 493	FORMAT(' INPUT FILE NAME=',$)
	ACCEPT 494,INFN
 494	FORMAT(A5)
	CALL IFILE(22,INFN)
	NDEV=22
	GO TO 200
C
C  M=INPUT TO RAM AT WORD NA
C
 500	IF(NA)210,501,501
 501	IF(NA-64)505,210,210
 505	KBNK=NA/16
	KCOB=MOD(NA/4,4)
	KWIC=MOD(NA,4)
	IF(IOPT)503,503,502
 502	TYPE 506
 506	FORMAT(' WD(20CH)=',$)
	GO TO 507
 503	TYPE 504
 504	FORMAT(' RAMWD(20 CH,0 TO F,-)=',$)
 507	ACCEPT 508,(INM(I),I=1,20)
 508	FORMAT(20A1)
	DO 525 I=1,20
	DO 510 J=1,17
	IF(INM(I)/2-H2B(J)/2)510,515,510
 510	CONTINUE
	GO TO 210
 515	IF(J-17)518,525,525
 518	IF(I-16)520,520,523
 520	RAM(17-I,KWIC+1,KCOB+4*KBNK+1)=J-1
	GO TO 525
 523	RAMSTI(I-16,KWIC+1,KCOB+4*KBNK+1)=J-1
 525	CONTINUE
	GO TO 200
C
C  O=COMPRESSED OUTPUT OPTION IF N=1
 550	IF(NA-1)552,555,552
 552	IOPT=0
	GO TO 200
 555	IOPT=1
	GO TO 200
C  U=UNPRINTING TRACE MODE
 560	ITRC=NA
	GO TO 1000
C  P=SETUP PROGRAMABLE MEMORY
 570	DO 5711 I = 1, 16
 5711	WPMMAP (I) = -1
	WPMON = 0
 5712	IF (NA - 1) 200, 5713, 200
 5713	NA = -1
	TYPE 5714
 5714	FORMAT (' PORT TYPE (N=NONE, M=RAM, R=ROM)'
	1, ' AND CHIP NUMBER (0-15)? ' $)
	ACCEPT 204, IK, WPMPRT
	IF (WPMPRT .LT. 0 .OR. WPMPRT .GT. 15) GO TO 5712
	IF (IK .NE. WPMTYP (1)) GO TO 5716
5715	WPMNXT = 1
	WPMMAP (1) = WPMPRT
	GO TO 200
5716	IF (IK .NE. WPMTYP (2)) GO TO 5718
	WPMON = -1
	GO TO 5720
5718	IF (IK .NE. WPMTYP (3)) GO TO 5712
	WPMON = 1
5720	TYPE 5721
5721	FORMAT (' ENTER PORT OUTPUT VALUE (0-15) AND',
	1  ' CORRESPONDING CHIP SELECTED (0-15).'/
	2  ' TERMINATE LIST WITH -1, -1'/)
 5722	ACCEPT 5723, I, J
 5723	FORMAT (2I)
	IF (I .LT. 0) GO TO 200
	IF (I .LT. 16 .AND. J .GE. 0 .AND. J .LT. 16) GO TO 5727
	TYPE 5726
 5726	FORMAT (' ILLEGAL VALUE -- TRY AGAIN'/)
	GO TO 5722
 5727	WPMMAP (I + 1) = J
	GO TO 5722
C
C
C  START NEXT INSTRUCTION
C   SAVE NON UPDATED PC FOR DUMP ROUTINES
 1000 CC=PC
	PC1=PC+1
	PC2=PC+2
	PH=MOD(PC/256,16)
C   ACCUMULATED TIME IN MILLI SEC
	TIME=FLOAT(T)*.0108
	IWP=MOD(PC,4)
C  UNPACK ROM WORD.  4 BYTES OF 8 BITS EACH ARE PACKED
C  INTO EACH ROM WORD, WITH 1ST WORD IN LOW-ORDER BIT
C  POSITION.
	IOP=MOD((ROM(1+PC/4))/(256**(IWP)),256)
	OPR=IOP/16
	OPA=MOD(IOP,16)
C   OPR1,OPA1 =OPR,OPA OF 2ND WD IN 2 WD INSTRUCTIONS
	IWP=MOD(PC+1,4)
	IOP=MOD((ROM(1+(PC+1)/4))/(256**(IWP)),256)
	OPR1=IOP/16
	OPA1=MOD(IOP,16)
	OPAONE=OPA+1
	RR=OPA+1
	R0=2*(OPA/2)+1
	R1=R0+1
CINSTRUCTION DECODE
	N=OPR+1
	LOP=3H   
	LM1=2H  
	LM2=4H    
	GO TO(1,2,3,4,5,6,7,8,9,10,11,12,13 ,14,1500,1600),N
C NOP
    1 IF(D.NE.0) GO TO 3000
	LOP=3HNOP
	GO TO 2001
C JCN
 2	LOP=3HJCN
	LM1=MM1(OPA+1)
	LM2=4HCONT
	C4=MOD(OPA   ,2).EQ.1
	C3=MOD(OPA/2 ,2).EQ.1
	C2=MOD(OPA/4 ,2).EQ.1
	C1=MOD(OPA/8 ,2).EQ.1
	IF(.NOT.C4)GO TO 2750
 2700	TYPE 2701,T
 2701	FORMAT(1H ,'AT T=',I5,' CY,TST(0,1)=',$)
	ACCEPT 2703,ITEST
 2703	FORMAT(I)
	TEST=ITEST.EQ.1
 2750	C5=(AC.EQ.0).AND.C2 .OR.(CY.EQ.1).AND.C3  .OR. .NOT.TEST.AND.C4
	C=.NOT.C1.AND.C5   .OR.   C1.AND. .NOT.C5
	IF(.NOT.C) GO TO 2002
   21 IF(MOD(PC,256).GT.253) PH=PH+1
	PC=PH*256+OPR1*16+OPA1
	ENCODE(4,2103,LM2),PC
 2103	FORMAT(I4)
	IDT=2
	GO TO 2000
C FIM IF EVEN SRC IF ODD
    3 IF(MOD(OPA,2).EQ.0) GO TO 31
C SRC
	DBX2=R(R0)
	DBX3=R(R1)
	LOP=3HSRC
	LM1=MP1(OPA/2+1)
	AMCHIP=4*AMBANK+DBX2/4
	AMWD=MOD(DBX2,4)
	GO TO 2001
C FIM
 31	R(R0)=D2
	R(R1)=D1
	LOP=3HFIM
	LM1=MP1(OPA/2+1)
	ITEM=16*OPR1+OPA1
	ENCODE(4,2103,LM2),ITEM
	GO TO 2002
C FIN IF EVEN JIN IF ODD
 4	IF(MOD(PC,256).GT.253) PH=PH+1
	IF(MOD(OPA,2).EQ.1)GO TO 41
C FIN    RA= ROM ADDRESS
	RA=256*PH+16*R(1)+R(2)
	IWP=MOD(RA,4)
	IOP=MOD((ROM(1+RA/4)/(256**IWP)),256)
	LOP=3HFIN
	LM1=MP1(OPA/2+1)
	ENCODE(4,2103,LM2),IOP
	R(R0)=IOP/16
	R(R1)=MOD(IOP,16)
	IDT=2
	INC=1
	GO TO 2003
C JIN
 41	PC=256*PH+16*R(R0)+R(R1)
	LOP=3HJIN
	LM1=MP1(OPA/2+1)
	ENCODE(4,2103,LM2),PC
	IDT=1
	GO TO 2000
C JUN
 5	LOP=3HJUN
 51	PC=256*OPA+16*OPR1+OPA1
	ENCODE(4,2103,LM2),PC
	IDT=2
	GO TO 2000
C JMS
 6	PC=PC+2
	LOP=3HJMS
	STACK(SPTR+1)=PC
	SPTR=MOD((SPTR+1),4)
	IF(ISRT)2007,2006,2006
 2006	ISRT=ISRT+1
 2007	NJMS=NJMS+1
	XSJMS=NJMS-NBBL
	IF(XSJMS.GT.3) TYPE 8106,XSJMS,CC
	GO TO 51
C INC
 7	R(RR)=MOD((R(RR)+1),16)
	LOP=3HINC
	LM1=MN1(RR)
	GO TO 2001
C ISZ JCN
 8	R(RR)=MOD((R(RR)+1),16)
	LOP=3HISZ
	LM1=MN1(RR)
	LM2=4HCONT
	IF(R(RR).NE.0) GO TO 21
	GO TO  2002
C ADD
 9	AC=AC+CY+R(RR)
	LOP=3HADD
	LM1=MN1(RR)
 91	CY=AC/16
	AC=MOD(AC,16)
	GO TO 2001
C SUB
 10	AC=AC+(15-R(RR))+(1-CY)
	LOP=3HSUB
	LM1=MN1(RR)
	GO TO 91
C LD
 11	AC=R(RR)
	LOP=3HLD 
	LM1=MN1(RR)
	GO TO 2001
C XCH
 12	TEMP=AC
	LOP=3HXCH
	LM1=MN1(RR)
	AC=R(RR)
	R(RR)=TEMP
	GO TO 2001
C BBL
C	NEED TO UPDATE STACK BEFORE CHANGING SPTR
 13	ISRT=ISRT-1
	LOP=3HBBL
	LM1=MN1(RR)
	IF(ISRT)1013,1023,1014
 1013	ISRT=-1
	GO TO 1014
 1023	TYPE 1024
 1024	FORMAT(' BBL EXIT:')
	ISRT=-1
	GO TO 2301
 1014	STACK(SPTR+1)=MOD((PC+1),4096)
	SPTR=SPTR-1
	IF(SPTR.LT.0)SPTR=SPTR+4
	PC=STACK(SPTR+1)
	AC=D
	NBBL=NBBL+1
	XSBBL=NBBL-NJMS
	IF(XSBBL.GT.0) TYPE 8113,XSBBL,CC
	IDT=1
	GO TO 2000
C LDM
 14	AC=D
	LOP=3HLDM
	LM1=MN1(RR)
	GO TO 2001
C
C
C	    INPUT OUTPUT
C
 1500	M=RAM(DBX3+1,AMWD+1,AMCHIP+1)
	GO TO (1501,1502,1503,1504,1505,1505,1505,1505,1509,1510,1511,
     +1512,1513,1513,1513,1513),OPAONE
C WRM
 1501	RAM(DBX3+1,AMWD+1,AMCHIP+1)=AC
	LOP=3HWRM
	GO TO 2001
C WMP
 1502	RAMPRT(AMCHIP+1)=AC
	LOP=3HWMP
	IF (WPMON) 15024, 15026, 15026
15024	IF (AMCHIP - WPMPRT) 15026, 15025, 15026
15025	WPMNXT = AC + 1
	GO TO 2001
15026	IF(IOPT)15020,15020,15022
15020	TYPE 15021,AMCHIP,AC,T
15021	FORMAT(' OUTPUT TO RAMPORT #',I4,'=',I4,' AT T=',I5,' CY')
	GO TO 2001
15022	TYPE 15023,AMCHIP,AC,T
15023	FORMAT(' RAMPT #',I3,'=',I3,' @',I5)
	GO TO 2001
C WRR
 1503	CONTINUE
	LOP=3HWRR
	IF (WPMON) 15036, 15036, 15034
15034	IF (OMCHIP - WPMPRT) 15036, 15035, 15036
15035	WPMNXT = AC + 1
	GO TO 2001
15036	IF(IOPT)15030,15030,15032
15030	TYPE 15031,OMCHIP,AC,T
15031	FORMAT(' OUTPUT TO ROMPORT #',I4,'=',I4,' AT T=',I5,' CY')
	GO TO 2001
15032	TYPE 15033,OMCHIP,AC,T
15033	FORMAT(' ROMPT #',I3,'=',I2,' @',I5)
	GO TO 2001
C WPM
1504	LOP = 3HWPM
	IF (WPMMAP (WPMNXT) .GE. 0) GO TO 15042
	TYPE 15041, CC
15041	FORMAT (' ATTEMPT TO ALTER ROM BY WPM AT', I6)
	GO TO 2001
15042	I = (WPMMAP (WPMNXT) * 256 + DBX2 * 16 + DBX3) / 4 + 1
	J = ROM (I)
	II = 16 ** (MOD (DBX3, 4) * 2 + FL4008)
	ROM (I) = J + (AC - MOD (J / II, 16)) * II
	FL4008 = MOD (FL4008 + 1, 2)
	GO TO 2001
C WR0-3
 1505	I=OPA-3
	LOP=MWR(I)
	RAMSTI(I,AMWD+1,AMCHIP+1)=AC
	GO TO 2001
C SBM
 1509	AC=AC+(15-M)+(1-CY)
	LOP=3HSBM
	GO TO 91
C RDM
 1510	AC=M
	LOP=3HRDM
	GO TO 2001
C RDR
 1511	LOP=3HRDR
	IF(NDEV-22)15100,15800,15100
15100	IF(IOPT)15110,15110,15900
15110	TYPE 15111,OMCHIP
15111	FORMAT(' INPUT REQUESTED FROM ROMPORT #',I2,' (IN DEC)')
	GO TO 15910
15900	TYPE 15901,OMCHIP
15901	FORMAT(' ROMPT IN #',I2,' ?')
15910	TYPE 201
	ACCEPT 15112,AC
15112	FORMAT(I)
	IF(ITMD)15113,2001,2001
15113	WRITE(3,15114)OMCHIP,AC
15114	FORMAT(' ROMPORT #',I3,' INPUT=',I3)
	GO TO 2001
15800	READ(22,15801),AC
15801	FORMAT(I)
	IF(IOPT)15805,15805,2001
15805	TYPE 15806,OMCHIP,AC,T
15806	FORMAT(' INP #',I2,'=',I2,' @',I5)
	GO TO 2001
C ADM
 1512	AC=AC+CY+M
	LOP=3HADM
	GO TO 91
C RD0-3
 1513	I=OPA-11
	LOP=MRD(I)
	AC=RAMSTI(I,AMWD+1,AMCHIP+1)
	GO TO 2001
C
C
C	  ACCUMULATOR GROUP INST
C
 1600 GO TO(1601,1602,1603,1604,1605,1606,1607,1608,1609,
     + 1610,1611,1612,1613,1614,3000,3000),OPAONE
C CLB
 1601	AC=0
	CY=0
	LOP=3HCLB
	GO TO 2001
C CLC
 1602	CY=0
	LOP=3HCLC
	GO TO 2001
C IAC
 1603	AC=AC+1
	LOP=3HIAC
	GO TO 91
C CMC
 1604	CY=1-CY
	LOP=3HCMC
	GO TO 2001
C CMA
 1605	AC=15-AC
	AC=MOD(AC,16)
	LOP=3HCMA
	GO TO 2001
C RAL
 1606	AC=2*AC+CY
	LOP=3HRAL
	GO TO 91
C RAR
 1607	AC=AC+16*CY
	CY=MOD(AC,2)
	AC=AC/2
	AC=MOD(AC,16)
	LOP=3HRAR
	GO TO 2001
C TCC
 1608	AC=CY
	CY=0
	LOP=3HTCC
	GO TO 2001
C DAC
 1609	AC=AC+15
	LOP=3HDAC
	GO TO 91
C TCS
 1610	AC=9
	LOP=3HTCS
	IF(CY.EQ.1)AC=10
	CY=0
	GO TO 2001
C STC
 1611	CY=1
	LOP=3HSTC
	GO TO 2001
C DAA
 1612	IF(CY.EQ.1 .OR. AC.GT.9)CY=1
	IF(CY.EQ.1)AC=AC+6
	AC=MOD(AC,16)
	LOP=3HDAA
	GO TO 2001
C KBP
 1613	AC=KBP(AC+1)
	LOP=3HKBP
	GO TO 2001
C DCL
 1614	I=MOD(AC,8)
	LOP=3HDCL
	LM1=MB1(I+1)
	IF(I.EQ.3 .OR.I.GT.4) GO TO 3003
	AMBANK=I
	AMCHIP=4*AMBANK+DBX2/4
	GO TO 2001
C
C   SET UP INC FOR BUMPING PROG CTR AT STATEMENT 2003
 2002	INC=2
	IDT=2
	GO TO 2003
 2001	INC=1
	IDT=1
	GO TO 2003
 2000	INC=0
 2003	PC=PC+INC
C   MAKE SURE PC CYCLES TO 0 NEXT CYCLE AFTER 4095
	PC=MOD(PC,4096)
	STACK(SPTR+1)=PC
	T=T+IDT
	ITRC=ITRC-1
	IF(ITRC)200,2005,2010
 2005	IF(ITMD)2400,2321,2100
 2321	TYPE 2106
 2106	FORMAT(' LIMIT EXIT:')
	TYPE 2101,CC,LOP,LM1,LM2,CY,AC,(H2B(1+R(I)),I=1,16)
	1,AMBANK,DBX2,DBX3,T
	GO TO 200
 2010	IF(ITMD)2400,2300,2100
 2100	TYPE 2101,CC,LOP,LM1,LM2,CY,AC,(H2B(1+R(I)),I=1,16)
	1,AMBANK,DBX2,DBX3,T
 2101	FORMAT(1H ,I4,1X,A3,1X,A2,1X,A4,2I3,1H ,16A1,3I3,I5)
 2110	IF(ITRC)2200,2200,2111
 2111	IF(CC-IBKP)1000,2112,1000
 2112	TYPE 2113
 2113	FORMAT(' BREAK EXIT:')
	GO TO 200
 2200	ITMD=0
	GO TO 200
 2300	IF(CC-IBKP)1000,2311,1000
 2311	TYPE 2113
 2301	TYPE 2101,CC,LOP,LM1,LM2,CY,AC,(H2B(1+R(I)),I=1,16)
	1,AMBANK,DBX2,DBX3,T
	GO TO 200
 2400	WRITE(3,2101)CC,LOP,LM1,LM2,CY,AC,(H2B(1+R(I)),I=1,16)
	1,AMBANK,DBX2,DBX3,T
	GO TO 2110
C   ERROR MESSAGES
 3000 TYPE 8000,OPR,OPA,CC
	GO TO 200
 3003 TEMP=H2B(AC)
	TYPE 8003,TEMP
	GO TO 200
C
C
C
 8000 FORMAT(10X'INVALID OPCODE OPR='I4,2X'OPA='I4,2X'PC='I5)
 8003 FORMAT(10X'INVALID DCL OPERAND  AC='A1)
 8106	FORMAT(' STACK OVERFLOW, X JMS=',I4,' PC=',I4)
 8113	FORMAT(' STACK UNDERFLOW, X BBL=',I4,' PC=',I4)
	END
	SUBROUTINE UNPK(IN,LOUT)
	DIMENSION LOUT(1)
	IX=IN
	DO 10 I=1,4
	INT=IX/256
	LOUT(I)=IX-256*INT
	IX=INT
 10	CONTINUE
	RETURN
	END
	SUBROUTINE REPK(LIN,KOUT)
	DIMENSION LIN(1)
	KOUT=0
	DO 20 I=1,4
	KOUT=256*KOUT+LIN(5-I)
 20	CONTINUE
	RETURN
	END
0x    