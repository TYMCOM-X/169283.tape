MODULE DOIT(DOLLAR,ENTRIES=($DMIN,$DTEST,$DCON,$DBOOL,$DFRCL,$DGLOGOPD),FSAVE,
        TIMING,TIMER=EXTERNAL(SIX12))=

BEGIN

REQUIRE DDEFS.BLI[7,107355];
REQUIRE DVDEFS.BLI[7,107355];
REQUIRE RDEFS.BLI[7,107355];
REQUIRE SDEFS.BLI[7,107355];
REQUIRE UDEFS.BLI[7,107355];
REQUIRE GDEFS.BLI[7,107355];

MAP G$ DGAM$;
MAP U$DYNARY DPOOL$;
MAP DR$ DREGS$;

MAP U$DYNARY DBASE$;
MAP DF$I DFLAG$;
MAP DL$ DLIST$;

UNDECLARE $DFRCL;
GLOBAL ROUTINE $DFRCL =
  BEGIN
   %$DFRCL IS USED TO FORCE THE LOGICAL AC INTO BEING FREE,
   WHICH, IF THE LOGICAL ACC IS NOT FREE, A TEMPORARY IS
   GENERATED, $DPCP IS INSTRUCTED TO STORE IT, AND WE
   MARK THE LOGICAL AC AS FREE

   THIS MAY BE GLOBAL SOME DAY..THEREFORE, THE "$" CONVENTION

   /JS......................5/18/74
   %

   IF .DXLOGCT$ EQL 0 THEN RETURN;
   %QUICK EXIT IF ALREADY FREE%

   $DMTMP(DDV$1WD);   %GET A ONE WORD TEMPORARY%
    DLIST$[DL$CGFP,.DXLSTCT$]_.DXLOGAC$; %GAMMA FILE POINTER%
    DLIST$[DL$UCNT,.DXLSTCT$]_.DXLOGCT$; %USE COUNT..USUALLY 1%

    %NOW FORCE THE STORE INTO THE TEMP%
   DREGS$[DR$BASE,0]_DBV$TEMPBASE;
   DREGS$[DR$OFFSET,0]_.DLIST$[DL$LOC,.DXLSTCT$];
   DREGS$[DR$DDTYPE,0]_DDV$1WD;
   DREGS$[DR$STP1,0]_0;

   $DPCP(DTPV$LSTO);  %LOGICAL STORE%

   DXLOGAC$_DXLOGCT$_0;
   
   END;

UNDECLARE $DGLOGOPD;
GLOBAL ROUTINE $DGLOGOPD(I,J) =
   BEGIN
   %THIS ROUTINE FETCHES EXACTLY ONE LOGICAL OPERAND TO A REGISTER
    .I = WHICH OPERAND IN GAMMA FILE
    .J = WHICH SYMBOLIC REGISTER TO FETCH TO

    NOTICE THAT WE VERY CAREFULLY MAKE SURE THAT IF THE LOGICAL
    AC IS IN USE, WE CHECK TO SEE IF THE LOGICAL AC IS THE
    OPERAND WE WNT, AND IF IT IS, WE ACT ACCORDINGLY

    /JS......................5/21/74
    %

    LOCAL P;
    MAP G$OPND P;

    P_.DGAM$+1;

    DFLAG$[DFV$AC,.J]_0;
    DFLAG$[DFV$OPND,.J]_0;

    IF (.DXLOGCT$ NEQ 0) AND (.P[.I,G$OPVAL] EQL .DXLOGAC$)     THEN
        BEGIN
        %IT WAS IN THE LOGICAL AC%
        $DSETAC(.J,3);
        DFLAG$[DFV$AC,.J]_1;
        DXLOGCT$_.DXLOGCT$-1;
        END

    ELSE IF (.P[.I,G$OPTYP] EQL GV$NP) THEN
        BEGIN
        $DGTMP(.P[.I,G$OPVAL],.J);
        DFLAG$[DFV$OPND,.J]_1;
        END;

    END;


UNDECLARE $DMIN;
GLOBAL ROUTINE $DMIN =
   BEGIN
   %EMIT ONE EACH UNARY MINUS SEQUENCE%

   $DGOPD(1,1);  %SET UP R1%
   $DFRCA();
   SELECT $DSIZE(.DGAM$[G$ICNT],.DGAM$[G$DCNT]) OF
        NSET

DDV$1WD:        $DPCP(DTPV$MIN1);

DDV$2WD:        $DPCP(DTPV$MIN2);

DDV$3WD:        0;

        TESN;

   $DMARKAC;  %MARK ARITH ACC AS BUSY%
   IF .DXACUCNT$ EQL 0 THEN DXACUCNT$_1; %QUICK FIX%
   END;


UNDECLARE $DTEST;

GLOBAL ROUTINE $DTEST =
        BEGIN
        END;


UNDECLARE $DCON;

GLOBAL ROUTINE $DCON =
   BEGIN
   %$DCON PROCESSES MIDAS RELATIONALS IN THE FOLLOWING
   FASHION:

        (1) IF THE LOGICAL ACC.(R3) IS BUSY, IT IS STORED
        VIA A CALL TO $DFRCL;

        (2)USING A SELECT ON G$TYPE, THE APPROPRIATE
        REGISTER SETUP IS PERFORMED USING $DGOPD--
        USUALLY, OPND1 GOES TO DREGS$[1] AND OPND2 TO
        DREGS$[2], BUT AN INTERCHANGE IS PERFORMED FOR "<"
        AND "<=" TO SAVE SPACE IN DTBL$(MILD OPTIMIZATION);

        (3)$DPCP IS CALLED TO GENERATE THE APPROPRIATE CODE;

        (4)THE LOGICAL AC IS MARKED AS BUSY AND WE RETURN.

   THE CODE IS OTHERWISE UNREMARKABLE.

    /JS......................5/16/74
    (REMEMBER...$DCON KILLS RATS)
    %
   LOCAL S1,S2; %HOLDING SIZES%
   LOCAL T1,T2,P,Q;
   MAP G$OPND P;
   MAP S$ Q;


   %PROCESS RANGE CHECK HERE, SINCE IT IS SORT OF LIKE A RELATIONAL%

   IF (.DGAM$[G$TYPE] EQL GV$RCHK) OR (.DGAM$[G$TYPE] EQL GV$DRCHK) THEN
        BEGIN
        $DFRCL();
        $DGOPD(1,2); %I JUST LIKE IT BETTER THIS WAY%
        $DGOPD(2,1);
        $DFRCA(); %DON'T FORGET HIM%
        IF (.DGAM$[G$TYPE] EQL GV$RCHK) THEN
           $DPCP(DTPV$RCHK)
        ELSE
           $DPCP(DTPV$DRCHK);
        DXLOGAC$_.DGAM$[G$ID];
        DXLOGCT$_.DGAM$[G$UCNT];
        RETURN;
        END;

   P_.DGAM$+1;
    
    $DFRCL();    % FORCE LOGICAL ACC HERE%
    $DGOPD(1,1); %GET FIRST OPERAND%
    $DGOPD(2,2); %GET SECOND OPERAND%

    $DFRCA(); %FORCE ARITH AC NOW..%

    IF (.DREGS$[DR$DDTYPE,1] EQL DDV$RIST) OR
        (.DREGS$[DR$DDTYPE,2] EQL DDV$RIST) THEN
        BEGIN
        %SOME THER THERE IS AN @TOP IN A RELATIONAL..%
        IF .DREGS$[DR$DDTYPE,1] NEQ DDV$RIST THEN
           $DGSAD(.DREGS$[DR$BASE,1],.DREGS$[DR$OFFSET],1);
        IF .DREGS$[DR$DDTYPE,2] NEQ DDV$RIST THEN
           $DGSAD(.DREGS$[DR$BASE,2],.DREGS$[DR$OFFSET,2],2);
        DFLAG$_0;

        %NOW PICK WHICH RELATIONAL%
        SELECT .DGAM$[G$TYPE] OF NSET
GV$EQ:     DFLAG$[0,1]_1;
GV$NE:     DFLAG$[0,2]_1;
GV$LT:     DFLAG$[0,3]_1;
GV$GT:     DFLAG$[0,4]_1;
GV$LE:     DFLAG$[0,5]_1;
GV$GE:     DFLAG$[0,6]_1;
           TESN;

        %SET REG 3 TO MAGIC BYTE POINTER LEFT SIDE VALUE%
        $DGSYL(#350700000000,3);
        $DSETAC(4,#14); %REG 4 = AC14%
        $DSETAC(5,#15); %REG 5 = AC15%

        %NOW .. DO IT%
        $DPCP(DTPV$BYTCP);

        %AND MARK THE RESULT%
        DXLOGAC$_.DGAM$[G$ID];
        DXLOGCT$_.DGAM$[G$UCNT];
        RETURN %AND RETURN VIA THE GARDEN STATE PARKWAY%
        END;

    T1_.DREGS$[DR$DDTYPE,1];
   
    T2_.DREGS$[DR$DDTYPE,2];
   S1 _ $DSIZEQP(.DREGS$[DR$QP,1]);
   S2 _ $DSIZEQP(.DREGS$[DR$QP,2]);
   IF ((.T1 EQL DDV$STEMP) OR (.T1 EQL DDV$STR)) AND
      ((.T2 EQL DDV$STEMP) OR (.T2 EQL DDV$STR)) THEN
        BEGIN
        %STRING COMPARE%

        $DGSAD(.DREGS$[DR$BASE,1],.DREGS$[DR$OFFSET,1],4);
        $DGSAD(.DREGS$[DR$BASE,2],.DREGS$[DR$OFFSET,2],6);

       IF .T1 EQL DDV$STR THEN
           BEGIN
           %GET DD ADDRESS%
           Q_$SGSTE(.P[1,G$OPVAL]);
           DREGS$[DR$BASE,3]_.Q[S$DDB];
           DREGS$[DR$OFFSET,3]_.Q[S$DDFO];
           DREGS$[DR$STP1,3]_.Q[S$STP1];
           DREGS$[DR$QP,3]_0;
           DREGS$[DR$DDTYPE,3]_DDV$1WD;
           $SFRNCH(.Q);
           END
        ELSE IF .T1 EQL DDV$STEMP THEN
           $DGSYL(.DREGS$[DR$QP,1],3);

        IF .T2 EQL DDV$STR THEN
           BEGIN
           Q_$SGSTE(.P[2,G$OPVAL]);
           DREGS$[DR$BASE  ,5]_.Q[S$DDB];
           DREGS$[DR$OFFSET,5]_.Q[S$DDFO];
           DREGS$[DR$STP1  ,5]_.Q[S$STP1];
           DREGS$[DR$QP    ,5]_0;
           DREGS$[DR$DDTYPE,5]_DDV$1WD;
           $SFRNCH(.Q);
           END
        ELSE IF .T2 EQL DDV$STEMP THEN
           $DGSYL(.DREGS$[DR$QP,2],5);



        $DRNCL(RTRV$VCOMP,4);

        DFLAG$_0;

        $DSETAC(3,0);
        $DSETAC(4,#17);
        $DSETLIT(1,1);
        $DSETLIT(2,0);

        DREGS$[DR$OFFSET,2]_
            SELECT .DGAM$[G$TYPE] OF NSET
GV$EQ:          2;
GV$NE:          5;
GV$LT:          1;
GV$GT:          4;
GV$LE:          3;
GV$GE:          6;
             TESN;

        $DPCP(DTPV$SCOND);

        END
    ELSE
    IF (.S1 EQL DDV$1WD) AND
        (.S2 EQL DDV$1WD) THEN

       BEGIN
%************************************
OLD COMPARE CODE..NOT PROPERLY INDENTED
**********************************************%



   $DSETLIT(3,1);
   $DSETLIT(4,0);

   IF (.T1 EQL DDV$SLIT) AND (.T2 EQL DDV$SLIT) THEN
        BEGIN
        S1_.DREGS$[DR$OFFSET,1];   %NEW CODE TO COLLAPSE SHORT LITS%
        S2_.DREGS$[DR$OFFSET,2];  %TODAY IS 2/8/75%
        SELECT .DGAM$[G$TYPE] OF NSET

GV$EQ:  IF .S1 EQL .S2 THEN $DPCP(DTPV$MTRUE) ELSE $DPCP(DTPV$MFALS);
GV$NE:  IF .S1 NEQ .S2 THEN $DPCP(DTPV$MTRUE) ELSE $DPCP(DTPV$MFALS);
GV$LT:  IF .S1 LSS .S2 THEN $DPCP(DTPV$MTRUE) ELSE $DPCP(DTPV$MFALS);
GV$GT:  IF .S1 GTR .S2 THEN $DPCP(DTPV$MTRUE) ELSE $DPCP(DTPV$MFALS);
GV$LE:  IF .S1 LEQ .S2 THEN $DPCP(DTPV$MTRUE) ELSE $DPCP(DTPV$MFALS);
GV$GE:  IF .S1 GEQ .S2 THEN $DPCP(DTPV$MTRUE) ELSE $DPCP(DTPV$MFALS);

        TESN;
        END
   ELSE
   SELECT .DGAM$[G$TYPE] OF 
        NSET

GV$EQ:  BEGIN
        $DPCP(DTPV$EQU1);
        END;

GV$NE:  BEGIN
        $DPCP(DTPV$NEQ1);
        END;

GV$LT:  BEGIN
        $DEXCH(1,2);
        $DPCP(DTPV$GTR1);
        END;

GV$GT:  BEGIN
        $DPCP(DTPV$GTR1);
        END;

GV$LE:  BEGIN
        $DEXCH(1,2);
        $DPCP(DTPV$GEQ1);
        END;

GV$GE:  BEGIN
        $DPCP(DTPV$GEQ1);
        END;

        TESN;
        END
%********************************
END OF OLD COMPARE(SINGLE VERSUS SINGLE)
***********************************%
        ELSE IF ((.S1 EQL DDV$1WD) OR (.S1 EQL DDV$2WD)) AND
                ((.S2 EQL DDV$1WD) OR (.S2 EQL DDV$2WD))
        THEN 
        BEGIN

        IF (.DREGS$[DR$DDTYPE,2] EQL DDV$AC) THEN
           BEGIN
           $DEXCH(1,2);  %FORCE IT FOR SUBTRACT%
           DGAM$[G$TYPE]_SELECT .DGAM$[G$TYPE] OF NSET

GV$EQ:  GV$EQ;
GV$NE:  GV$NE;
GV$LT:  GV$GE;
GV$GT:  GV$LE;
GV$LE:  GV$GT;
GV$GE:  GV$LT;
           TESN;
            END;

        $DPCP(DTPV$DSUB);

        %WATCH THIS CLOSELY..%
        $DPCP(SELECT .DGAM$[G$TYPE] OF NSET

GV$EQ:          DTPV$EQU2;
GV$NE:          DTPV$NEQ2;
GV$LT:          DTPV$LSS2;
GV$GT:          DTPV$GTR2;
GV$LE:          DTPV$LEQ2;
GV$GE:          DTPV$GEQ2;
           TESN);
        END;



   DXLOGAC$_.DGAM$[G$ID];
   DXLOGCT$_.DGAM$[G$UCNT];
   END;


UNDECLARE $DBOOL;

GLOBAL ROUTINE $DBOOL = 
   BEGIN
   %$DBOOL PROCESSES "AND"S AND "OR"S 

   FIRST, WE LOAD R1 AND R2 WITH APPROPIATE
   VALUES(EITHER THE LOGICAL AC OR A TEMP);

   THEN, WE FORCE THE LOGICAL AC , IF NECESSARY;

   THIRD, WE CALL OUR OLD FRIEND $DPCP AND HAVE HIM GENERATE
   EITHER AN "AND" OR AN "OR" SEQUENCE;

   LAST , WE MARK THE LOGICAL AC AS BUSY, AND WITH WHAT, AND HOW BUSY.


    /JS......................5/21/74
   %

   $DGLOGOPD(1,1);
   IF .DGAM$[G$TYPE] NEQ GV$NOT THEN
   $DGLOGOPD(2,2);

   $DFRCL();

   IF .DGAM$[G$TYPE] EQL GV$AND THEN
        $DPCP(DTPV$AND)
   ELSE IF .DGAM$[G$TYPE] EQL GV$NOT THEN
        $DPCP(DTPV$NOT)
   
   ELSE IF .DGAM$[G$TYPE] EQL GV$OR THEN
        $DPCP(DTPV$OR);

   DXLOGAC$_.DGAM$[G$ID];
   DXLOGCT$_.DGAM$[G$UCNT];

   END;

END ELUDOM
    