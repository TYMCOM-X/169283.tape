

%*********************************************************************
%*********************************************************************
%*********************************************************************
%*********************************************************************

%			R   E	D   U	C   E

%	    A	SYSTEM   FOR	ALGEBRAIC    MANIPULATION

%*********************************************************************
%*********************************************************************
%*********************************************************************
%********************************************************************;

%                                 BY

%                          ANTHONY C. HEARN

%                         UNIVERSITY OF UTAH

%*********************************************************************
%*********************************************************************

COMMENT
%	REDUCE   IS   A   PROGRAM   DESIGNED  FOR  GENERAL  ALGEBRAIC
COMPUTATIONS OF INTEREST TO MATHEMATICIANS, PHYSICISTS AND ENGINEERS.
IT  IS  DEFINED HERE IN ITS OWN LANGUAGE, WHICH IS GENERAL ENOUGH FOR
THE COMPLETE DEFINITION OF ANY LISP-LIKE CALCULATION.

	THIS PROGRAM AND DESCRIPTION IS DIVIDED INTO THREE PARTS.  IN
THE  FIRST,  THE  TRANSLATOR FROM REDUCE TO THE INTERMEDIATE LANGUAGE
LISP IS DEFINED. THIS  SECTION  IS  SELF-CONTAINED  AND  MAY  BE  RUN
INDEPENDENT  OF  THE  REMAINDER  OF  THE  PROGRAM. THE SECOND SECTION
DEFINES THE BASIC ALGEBRAIC EVALUATOR AND ITS  ASSOCIATED  FUNCTIONS.
THE  PROCEDURES IN THIS SECTION CALL EACH OTHER IN A NON-MODULAR WAY,
AND SHOULD THEREFORE BE RUN INTACT. FINALLY, IN  THE  THIRD  SECTION,
VARIOUS  MODULES WHICH SUPPLEMENT THE MAIN PROGRAM ARE DEFINED. THESE
MODULES MAY BE RUN INDEPENDENTLY OF EACH OTHER EXCEPT WHERE NOTED.

	THIS PROGRAM IS  PRECEDED  BY  A  SMALL  LISP  PROGRAM  WHICH
INITIATES  THE  BOOT-STRAPPING  OF  THE  TRANSLATOR. IN ADDITION, THE
SYSTEM EXPECTS A STANDARD LISP SYSTEM FOR SUPPORT PLUS A  FEW  REDUCE
FUNCTIONS  WHICH ARE SYSTEM DEPENDENT, SO THAT A PREPROCESSOR IS ALSO
NECESSARY.

	THE NUMBERS WHICH PRECEDE VARIOUS SUB-SECTION TITLES REFER TO
THE  SECTIONS  IN  THE  REDUCE  USER'S  MANUAL  WHERE THESE ITEMS ARE
DEFINED. FURTHER DESCRIPTIONS OF THE REDUCE SYSTEM MAY ALSO BE  FOUND
IN THE FOLLOWING PUBLICATIONS:


<TO BE ADDED>

;


%*********************************************************************
%*********************************************************************
%*********************************************************************

%                              SECTION 1

%                  THE    R E D U C E    TRANSLATOR

%*********************************************************************
%*********************************************************************
%********************************************************************;


LISP;  %THIS PROGRAM IS DEFINED IN SYMBOLIC MODE;


%*********************************************************************
%                GLOBAL VARIABLES USED IN TRANSLATOR
%********************************************************************;

%	 THERE ARE TWO CLASSES OF GLOBAL VARIABLES USED IN  THIS  PART
%OF  REDUCE.   THE  FIRST CLASS ARE THOSE WHICH MUST BE INITIALIZED AT
%THE TOP LEVEL OF THE PROGRAM. THESE ARE AS FOLLOWS;

BLOCKP!* := NIL;	%KEEPS TRACK OF WHICH BLOCK IS ACTIVE;
DEFL!* := '((**ARRAY . ARRAY));
			%LIST OF VARIABLE INDICATORS AND THEIR NAMES;
ERFG!* := NIL;		%INDICATES THAT AN INPUT ERROR HAS OCCURRED;
INITL!* := '(BLOCKP* ERFG* OUTL* VARS*);
			%LIST OF VARIABLES INITIALIZED IN BEGIN1;
MATP!*:=NIL;		%USED TO INDICATE THAT A MATRIX EXPRESSION HAS
			%BEEN READ;
PRECLIS!*:= '(OR AND NOT MEMBER EQUAL NEQ EQ GEQ GREATERP LEQ
	      LESSP PLUS DIFFERENCE TIMES QUOTIENT EXPT CONS);
			%PRECEDENCE LIST OF INFIX OPERATORS;
TYPE!* := NIL;		%PASSES PROCEDURAL TYPE IN PROCEDURE DEFINED BY
			%ASSIGNMENT STATEMENT;
VARS!* := NIL;	%LIST OF ALL CURRENT BOUND VARIABLES DURING PARSE;
!*DEFN:=NIL;		%INDICATES THAT LISP CODE SHOULD BE OUTPUT;
!*ECHO := NIL;		%INDICATES ECHOING OF INPUT;
LETL!* := NIL;		%USED IN ALGEBRAIC MODE FOR SPECIAL DELIMITERS;
!*MSG:=NIL;		%FLAG TO INDICATE WHETHER MESSAGES SHOULD BE
			%PRINTED;
!*NAT := NIL;		%USED IN ALGEBRAIC MODE TO DENOTE 'NATURAL'
			%OUTPUT. MUST BE ON IN SYMBOLIC MODE TO
			%ENSURE INPUT ECHOING;

%	 THE  SECOND  CLASS  ARE  THOSE  GLOBAL  VARIABLES  WHICH  ARE
%INITIALIZED WITHIN SOME FUNCTION, ALTHOUGH THEY DO NOT APPEAR IN THAT
%FUNCTION'S VARIABLE LIST.  THESE ARE;

% CRCHAR!*		NEXT CHARACTER IN INPUT LINE
% CURSYM!*		CURRENT SYMBOL (I. E. IDENTIFIER, PARENTHESIS,
%			DELIMITER, E.T.C,) IN INPUT LINE
% IFL!*			INPUT FILE NAME- SET IN BEGIN TO NIL
% IPL!*			INPUT FILE LIST- SET IN BEGIN TO NIL
% KEY!*			STORES FIRST WORD READ IN COMMAND - SET IN 
			%COMMAND
% KEY1!*		CURRENT KEY-WORD BEING ANALYZED - SET IN RLIS1;
% MCOND!*		THIS IS USED BY ALGEBRAIC MODE ONLY
% OFL!*			OUTPUT FILE NAME- SET IN BEGIN TO NIL
% OPL!*			OUTPUT FILE LIST- SET IN BEGIN TO NIL
% PROGRAM!*		CURRENT INPUT PROGRAM
% PROGRAML!*		STORES INPUT PROGRAM WHEN ERROR OCCURS FOR A 
%			LATER RESTART
% SEMIC!*		CURRENT DELIMITER CHARACTER (USED TO DECIDE
%			WHETHER TO PRINT RESULT OF CALCULATION)
% TMODE!*		HOLDS CURRENT MODE DURING TEMPORARY MODE CHANGE
% OUTL!*		STORAGE FOR OUTPUT OF INPUT LINE
% *ANS			USED IN ALGEBRAIC MODE TO STORE TOP LEVEL
%			VALUE
% *FORT			USED IN ALGEBRAIC MODE TO DENOTE FORTRAN
%			OUTPUT
% !*MODE		CURRENT MODE OF CALCULATION
% !*INT  		INDICATES INTERACTIVE SYSTEM USE;


%*********************************************************************
%                       2.10.4 GO TO STATEMENT
%********************************************************************;

%	 IT IS NECESSARY TO INTRODUCE THE  GO  TO  STATEMENT  AT  THIS
%POINT  AS  PART OF THE BOOT-STRAPPING PROCESS.  A GENERAL DESCRIPTION
%OF THE METHOD OF STATEMENT IMPLEMENTATION IS GIVEN LATER;

LISP PROCEDURE GOSTAT;
   BEGIN SCALAR VAR;
	VAR := (IF SCAN!*() EQ 'TO  THEN SCAN!*() ELSE CURSYM!*);
	SCAN!*();
	RETURN LIST('GO,VAR)
   END;

PUT('GO,'STAT,'GOSTAT);

PUT('GOTO,'STAT,'GOSTAT);


%*********************************************************************
%                2.5 INITIALIZATION OF INFIX OPERATORS
%********************************************************************;

%	 SEVERAL OPERATORS IN REDUCE ARE USED IN AN INFIX FORM  (E.G.,
%+,-   ).  THE  INTERNAL  ALPHANUMERIC  NAMES  ASSOCIATED  WITH  THESE
%OPERATORS ARE CONTAINED IN  THE  GLOBAL  VARIABLE  SWITCH*  WHICH  IS
%DEFINED  IN  THE  SYSTEM  DEPENDENT  SECTION  OF  THIS  PROGRAM. THIS
%ASSOCIATION, AND THE PRECEDENCE OF EACH INFIX  OPERATOR,  IS  SET  IN
%THIS SECTION.  WE  ALSO  ASSOCIATE  PRINTING  CHARACTERS  WITH  EACH
%INTERNAL ALPHAMERIC NAME AS WELL;

DEFLIST ('(
   (NOT NOT)
   (PLUS PLUS)
   (DIFFERENCE MINUS)
   (TIMES TIMES)
   (QUOTIENT RECIP)
 ), 'UNARY);

FLAG ('(AND OR PLUS TIMES EQUAL *COMMA*),'NARY);

FLAG ('(CONS SETQ),'RIGHT);

LISP PROCEDURE MKPREC;
   BEGIN SCALAR X,Y,Z;
	X := '*COMMA* . 'SETQ . PRECLIS!*;
	Y := 1;
    A:   IF NULL X THEN RETURN NIL;
	PUT(CAR X,'INFIX,Y);
	IF Z := GET(CAR X,'UNARY) THEN PUT(Z,'INFIX,Y);
	X := CDR X;
	Y := ADD1 Y;
	GO TO A
   END;

BEGIN SCALAR W,X,Y,Z;
	MKPREC();
	X := SWITCH!*;
  A:	IF NULL X THEN RETURN NIL;
	W := CDAR X;
	PUT(CAAR X,'SWITCH*,W);
	Y := LIST(CAAR X,CAAR X);
	PUT(CADR W,'PRTCH,Y);
	IF Z := GET(CADR W,'UNARY) THEN PUT(Z,'PRTCH,Y);
	IF CAR (Y := CDDR W)
	  THEN PROG2(Z := COMPRESS LIST(CAAR X,CAR W),
		     PUT(CAR Y,'PRTCH,LIST(Z,Z)));
	IF NULL CDR Y THEN GO TO B
	 ELSE IF CADR Y THEN RPLACA(GET(CADR W,'PRTCH),CADR Y);
	IF CDDR Y THEN RPLACA(GET(CAR Y,'PRTCH),CADDR Y);
  B:	X := CDR X;
	GO TO A
 END;


%*********************************************************************
%                          REDUCE SUPERVISOR
%********************************************************************;

%      THE TRUE REDUCE SUPERVISORY FUNCTION IS BEGIN, AGAIN DEFINED IN
%THE SYSTEM DEPENDENT PART OF THIS PROGRAM.  HOWEVER, MOST OF THE WORK
%IS  DONE  BY  BEGIN1,  WHICH  IS  CALLED  BY  BEGIN  FOR  EVERY  FILE
%ENCOUNTERED ON INPUT;

LISP PROCEDURE TERPRIX;
   BEGIN
	IF !*DEFN OR NULL ((!*ECHO AND !*NAT) OR ERFG!*) THEN GO TO A;
	MAPCAR(REVERSE OUTL!*,FUNCTION PRINC);
	TERPRI();
  A:	OUTL!*:=NIL
   END;

LISP PROCEDURE DELETE(U,V);
   IF NULL V THEN NIL
    ELSE IF U=CAR V THEN CDR V
    ELSE CAR V . DELETE(U,CDR V);

LISP PROCEDURE FLAGP!*!*(U,V);
   ATOM U AND NULL NUMBERP U AND FLAGP(U,V);

LISP PROCEDURE BEGIN1;
   BEGIN SCALAR RESULT;
	CURSYM!* := '*SEMICOL* ;
    A:	IF (!*ECHO AND !*NAT) OR (!*INT AND NULL IFL!*) THEN TERPRI();
	IF TMODE!* AND (!*MODE := TMODE!*) THEN TMODE!* := NIL;
	MAPCAR(INITL!*,FUNCTION SINITL);
	IF CURSYM!* EQ 'END THEN GO TO ND0;
	PROGRAM!* := ERRORSET('(COMMAND),T);
	IF ATOM PROGRAM!* OR CDR PROGRAM!* THEN GO TO ERR1;
	PROGRAM!* := CAR PROGRAM!*;
	IF EQCAR(PROGRAM!*,'*COMMA*) THEN GO TO ER
	 ELSE IF EQCAR(PROGRAM!*,'END) THEN GO TO ND1;
	PROGRAM!* := IF EQCAR(PROGRAM!*,'RETRY) THEN PROGRAML!*
		     ELSE MKEX PROGRAM!*;
	IF !*DEFN THEN GO TO D;
    B:  TERPRIX();
	RESULT := ERRORSET(GTS 'PROGRAM*,T);
	IF ATOM RESULT OR CDR RESULT OR ERFG!* THEN GO TO ERR2
	 ELSE IF !*DEFN THEN GO TO A;
	RESULT := CAR RESULT;
	IF EQS(SEMIC!*,";")
	  THEN IF !*MODE EQ 'SYMBOLIC THEN PROG2(PRINT RESULT,TERPRI())
	 ELSE IF RESULT THEN VARPRI(LIST PROGRAM!*,RESULT)
	 ELSE NIL;
	IF !*MODE NEQ 'SYMBOLIC AND RESULT THEN !*ANS := RESULT;
	GO TO A;
    D:	IF FLAGP!*!*(KEY!*,'IGNORE) OR EQCAR(PROGRAM!*,'QUOTE)
	  THEN GO TO B;
	DFPRINT PROGRAM!*;
	IF FLAGP!*!*(KEY!*,'EVAL) THEN GO TO B;
	GO TO A;
    ND0:COMM1 'END ;
    ND1:IF IFL!* THEN GO TO ND2;
	MAPCAR(APPEND(IPL!*,OPL!*),FUNCTION CLOSE);
	IPL!* := OPL!* := OFL!* :=  NIL;
	RETURN '*** ;
    ND2:CLOSE IFL!*;
	IPL!*:=DELETE(IFL!*,IPL!*);
	RDS(IFL!*:=IF IPL!* THEN CAR IPL!* ELSE NIL);
	RETURN LPRIM NIL;
    ERR1:
	IF PROGRAM!* EQ !*!*ESC AND LIST TOKEN() THEN GO TO A
	 ELSE IF NULL(PROGRAM!* EQ !*!*EOF) THEN GO TO ERR3;
	LPRIM LIST("MISSING END IN FILE",IFL!*);
	GO TO ND2;
    ER: LPRIE IF NULL ATOM CADR PROGRAM!*
		  THEN LIST(CAADR PROGRAM!*,"UNDEFINED")
		 ELSE "SYNTAX ERROR";
	GO TO ERR3;
    ERR2:
	PROGRAML!* := PROGRAM!*;
    ERR3:
	COMM1 T;
	IF NULL ERFG!* OR ERFG!* EQ 'HOLD
	 THEN LPRIE "ERROR TERMINATION *****";
	IF IFL!* AND !*INT THEN !*EVAL LIST 'PAUSE ;
	GO TO A
   END;

LISP PROCEDURE SINITL U;
   PTS(U,GET(U,'INITL));

FLAG ('(IN OUT ON OFF SHUT),'IGNORE);


%*********************************************************************
%              IDENTIFIER AND RESERVED CHARACTER READING
%********************************************************************;

%	 THE   FUNCTION  TOKEN  DEFINED  BELOW  IS  USED  FOR  READING
%IDENTIFIERS AND RESERVED CHARACTERS (SUCH AS  PARENTHESES  AND  INFIX
%OPERATORS).   IT  IS  CALLED  BY THE FUNCTION SCAN*, WHICH TRANSLATES
%RESERVED CHARACTERS INTO THEIR INTERNAL NAME, AND SETS UP THE  OUTPUT
%OF  THE  INPUT LINE. THE FOLLOWING DEFINITIONS OF TOKEN AND SCAN* ARE
%QUITE GENERAL, BUT ALSO INEFFICIENT.   THE READING PROCESS CAN  OFTEN
%BE  SPEEDED  UP  BY  A  FACTOR  OF AS MUCH AS FIVE IF THESE FUNCTIONS
%(ESPECIALLY TOKEN) ARE CODED IN ASSEMBLY LANGUAGE;

LISP PROCEDURE PRINCX U;
  OUTL!*:=U . OUTL!*;

LISP PROCEDURE TOKEN();
   BEGIN SCALAR X,Y,Z;
	X := CRCHAR!*;
    A:	IF SEPRP X THEN GO TO SEPR
	 ELSE IF DIGIT X THEN GO TO NUMBER
	 ELSE IF LITER X THEN GO TO LETTER
	 ELSE IF X EQ !*!*XMARK THEN GO TO ESCAPE
	 ELSE IF X EQ !*!*QMARK THEN GO TO QUOTE
	 ELSE IF X EQ !*!*SMARK THEN GO TO STRING
	 ELSE IF DELCP X THEN GO TO D;
	NXTSYM!* := X;
    A1:	CRCHAR!* := READCH();
	GO TO C;
    ESCAPE: 
	X := READCH();
    LETTER:
	Y := X . Y;
	IF DIGIT (X := READCH()) OR LITER X THEN GO TO LETTER
	 ELSE IF X EQ !*!*XMARK THEN GO TO ESCAPE;
    B:	NXTSYM!* := COMPRESS REVERSE Y;
	CRCHAR!* := X;
    C:	RETURN NXTSYM!*;
    NUMBER:	
	Y := X . Y;
	Z := X;
	IF DIGIT (X := READCH()) 
	   OR EQS(X,".") 
	   OR X EQ 'E
	   OR Z EQ 'E
	  THEN GO TO NUMBER
	 ELSE GO TO B;
    QUOTE:
	NXTSYM!* := MKQUOTE READ();
	GO TO A1;
    STRING:
	IF (X := READCH()) EQ !*!*SMARK THEN GO TO S1;
	Y := X . Y;
	GO TO STRING;
    S1:	NXTSYM!* := LIST('STRING,MKSTRING REVERSE Y);
	GO TO A1;
    SEPR:
	X := READCH();
	GO TO A;
    D:	NXTSYM!* := X;
	CRCHAR!* := !*!*BLANK;
	GO TO C
   END;

LISP PROCEDURE MKQUOTE U;
   LIST('QUOTE,U);



LISP PROCEDURE SCAN!*;
   BEGIN SCALAR X;
	IF NULL (CURSYM!* EQ '*SEMICOL*) THEN GO TO B;
    A:	TERPRIX();
	NXTSYM!* := TOKEN();
  B:	IF NULL ATOM NXTSYM!* THEN GO TO Q1
	 ELSE IF NXTSYM!* EQ 'ELSE THEN TERPRIX();
	PRINCX NXTSYM!*;
    C:	IF NUMBERP NXTSYM!* THEN GO TO L
	 ELSE IF (X:=GET(NXTSYM!*,'NEWNAM)) AND (NXTSYM!*:=X) 
	  THEN GO TO C
	 ELSE IF NXTSYM!* EQ 'COMMENT THEN GO TO COMM
	 ELSE IF NXTSYM!* EQ !*!*ESC THEN ERROR !*!*ESC
	 ELSE IF NXTSYM!* EQ !*!*QMARK THEN GO TO QUOTE
	 ELSE IF NULL (X:= GET(NXTSYM!*,'SWITCH*)) THEN GO TO L
	 ELSE IF CADR X EQ '*SEMICOL* THEN GO TO DELIM;
	NXTSYM!* := TOKEN();
	IF CAR X AND NXTSYM!* EQ CAR X THEN GO TO SW1
	 ELSE CURSYM!*:=CADR X;
	IF CURSYM!* EQ '*RPAR* THEN GO TO L2
	 ELSE RETURN CURSYM!*;
  SW1:  PRINCX NXTSYM!*;
	CURSYM!*:=CADDR X;
	NXTSYM!* := TOKEN();
	RETURN CURSYM!*;
  COMM:	PRINCX (X := READCH());
	IF NULL DELCP X THEN GO TO COMM;
	CRCHAR!* := !*!*BLANK;
	TERPRIX();
	GO TO A;
  DELIM:
	SEMIC!*:=NXTSYM!*;
	RETURN (CURSYM!*:='*SEMICOL*);
  QUOTE:
	NXTSYM!* := MKQUOTE READ();
    Q1:	IF CAR NXTSYM!* EQ 'STRING 
	  THEN PROG2(PRINCX " ",NXTSYM!* := 'QUOTE . CDR NXTSYM!*)
	 ELSE PRINCX " '";
	PRINCX CADR NXTSYM!*;
  L:	CURSYM!*:=NXTSYM!*;
  L1:	NXTSYM!* := TOKEN();
  L2:	IF NUMBERP NXTSYM!* 
	   OR (ATOM NXTSYM!* AND NULL GET(NXTSYM!*,'SWITCH*))
	  THEN PRINCX " ";
	RETURN CURSYM!*
   END;


%*********************************************************************
%                         EXPRESSION READING
%********************************************************************;

%	 THE CONVERSION OF A REDUCE EXPRESSION TO LISP PREFIX FORM  IS
%CARRIED  OUT  BY  THE  FUNCTION  XREAD.   THIS FUNCTION INITIATES THE
%SCANNING PROCESS, AND THEN CALLS THE  AUXILIARY  FUNCTION  XREAD1  TO
%PERFORM  THE  ACTUAL  PARSING. BOTH XREAD AND XREAD1 ARE USED BY MANY
%FUNCTIONS WHENEVER AN EXPRESSION MUST BE READ;

FLAG ('(END *COLON* *SEMICOL*),'DELIM);

LISP PROCEDURE EQCAR(U,V);
   NULL ATOM U AND CAR U EQ V;

LISP PROCEDURE MKFORM(U,V);
   BEGIN SCALAR X;
	RETURN IF ATOM U AND (X:= GET(U,'NEWFORM)) THEN !*APPLY(X,V)
	        ELSE U . V
 END;

LISP PROCEDURE REMCOMMA U;
   IF EQCAR(U,'*COMMA*) THEN CDR U ELSE LIST U;

LISP PROCEDURE XREAD1 U;
   BEGIN SCALAR V,W,X,Y,Z,Z1,Z2;
	% V: EXPRESSION BEING BUILT
	% W: PREFIX OPERATOR STACK
	% X: INFIX OPERATOR STACK
	% Y: INFIX VALUE OR STAT PROPERTY
	% Z: CURRENT SYMBOL
	% Z1: NEXT SYMBOL
	% Z2: TEMPORARY STORAGE;
  A:	Z:=CURSYM!*;
  A1:	IF NULL ATOM Z OR NUMBERP Z THEN Y:=NIL
	 ELSE IF FLAGP(Z,'DELIM) THEN GO TO DELIMIT
	 ELSE IF Z EQ '*LPAR* THEN GO TO LPAREN
	 ELSE IF Z EQ '*RPAR* THEN GO TO RPAREN
	 ELSE IF Y:=GET(Z,'INFIX) THEN GO TO INFX
	 ELSE IF Y:=GET(Z,'STAT) THEN GO TO STAT;
  A2:	IF W AND (NUMBERP CAR W OR (NULL ATOM CAR W AND
		   NULL(CAAR W EQ 'LAMBDA)))
	  THEN GO TO ERR5;
  A3:	W := Z . W;
  NEXT: Z:=SCAN!*();
	GO TO A1;
  N1:	Y := NIL;
	W := Z . W;
  N2:	Z := Z1;
	GO TO A1;
  LPAREN:
	Y:= NIL;
	IF SCAN!*() EQ '*RPAR* THEN GO TO LP1;
	Z:=XREAD1 IF EQCAR(W,'MAT) THEN MATP!*:='MAT ELSE 'PAREN ;
	IF U EQ 'MAT THEN Z:= REMCOMMA Z
	 ELSE IF EQCAR(Z,'*COMMA*) THEN GO TO LP2;
	GO TO A3;
  LP1:  IF W THEN W:= MKFORM(CAR W,NIL) . CDR W;
	GO TO NEXT;
  LP2:  IF NULL W THEN GO TO LP3
	 ELSE W := MKFORM(CAR W,CDR Z) . CDR W;
	GO TO NEXT;
  LP3:  IF U EQ 'LAMBDA THEN GO TO A3 ELSE GO TO ERR1;
  RPAREN:
	IF NULL U THEN GO TO ERR2 ELSE GO TO END1;
  INFX:	IF Z EQ '*COMMA* OR NULL ATOM (Z1 := SCAN!*())
		OR NUMBERP Z1 THEN GO TO IN1
	 ELSE IF Z1 EQ '*RPAR*	%INFIX OPERATOR USED AS VARIABLE;
		OR Z1 EQ '*COMMA*
		OR FLAGP(Z1,'DELIM)
	  THEN GO TO N1
	 ELSE IF Z1 EQ '*LPAR*	%INFIX OPERATOR IN PREFIX POSITION;
		    AND EQCAR(Z1 := XREAD 'PAREN,'*COMMA*)
		    AND (Z := Z . CDR Z1)
	  THEN GO TO A1;
  IN1:	IF W THEN GO TO UNWIND
	 ELSE IF NULL(Z := GET(Z,'UNARY)) THEN GO TO ERR4;
	V := '**UN** . V;
	GO TO PR1;
  UNWIND:
	Z2:=MKVAR(CAR W,Z);
  UN1:   W:= CDR W;
	IF NULL W THEN GO TO UN2 ELSE Z2 := MKFORM(CAR W,LIST Z2);
	GO TO UN1;
  UN2:  V:= Z2 . V;
  PRECED:
	IF NULL X THEN GO TO PR4
	 ELSE IF Y<CAAR X
	   OR (Y=CAAR X
	       AND ((Z EQ CDAR X AND NULL FLAGP(Z,'NARY)
				 AND NULL FLAGP(Z,'RIGHT))
			     OR GET(CDAR X,'ALT)))
	  THEN GO TO PR2;
  PR1:  X:= (Y . Z) . X;
	IF NULL(Z EQ '*COMMA*) THEN GO TO N2
	 ELSE IF CDR X OR NULL U OR U MEMBER '(LAMBDA MAT PAREN)
	  THEN GO TO NEXT
	 ELSE GO TO END2;
  PR2:  IF CDAR X EQ 'SETQ THEN GO TO ASSIGN
	 ELSE IF CADR V EQ '**UN** THEN GO TO UNARY;
  PR21:	V:=(IF EQCAR(CAR V,CDAR X) AND FLAGP(CDAR X,'NARY)
	      THEN CDAR X . (CADR V . CDAR V)
	     ELSE MKFORM(CDAR X,LIST(CADR V, CAR V))) . CDDR V;
  PR3:	X:= CDR X;
	GO TO PRECED;
  UNARY:
	IF CAR V EQ '**UN** THEN GO TO PR1
	 ELSE V := LIST(CDAR X,CAR V) . CDDR V;
	GO TO PR3;
  STAT:	IF NULL(U EQ 'PROC) AND (FLAGP(Y,'ENDSTAT) 
		OR (NULL DELCP NXTSYM!* AND NULL EQS(NXTSYM!*,",")))
	  THEN GO TO S1;
	Y := NIL;
	GO TO A2;
  S1:	W:= !*APPLY(Y,NIL) . W;
	Y:=NIL;
	GO TO A;
  ASSIGN:
	IF NUMBERP CADR V OR NULL CADR V THEN GO TO ERR1
	 ELSE IF NULL(!*MODE EQ 'SYMBOLIC) 
	  THEN V := (IF ATOM CADR V AND (U EQ 'FOR OR PROGVR CADR V)
		       THEN MKFORM('SETQ,LIST(CADR V,MKEX CAR V))
		      ELSE MKFORM('SETK,LIST(MKARG CADR V,MKEX CAR V)))
		    . CDDR V
	 ELSE IF ATOM CADR V THEN GO TO PR21
	 ELSE IF NULL ATOM CAADR V THEN GO TO ERR1
	 ELSE V :=(IF GET(CAADR V,'**ARRAY)
		     THEN MKFORM('SETEL,LIST(MKARG CADR V,CAR V))
		    ELSE IF TYPE!* THEN MKFORM('SETQ,LIST(CACAR V))
		     ELSE PROCSTAT1(CADR V,CAR V,'EXPR))
		     . CDDR V;
	GO TO PR3;
  DELIMIT:
	IF U MEMBER '(MAT PAREN) THEN GO TO ERR3;
  END1: IF Y THEN GO TO ERR1
	 ELSE IF NULL V AND NULL W AND NULL X THEN RETURN NIL;
	Y:=0;
	GO TO UNWIND;
  PR4:  IF NULL(Y=0) THEN GO TO PR1;
  END2: IF NULL CDR V THEN RETURN CAR V;
  ERR1: SYMERR("SYNTAX ERROR",NIL);
  ERR2: SYMERR("TOO MANY RIGHT PARENTHESES",NIL);
  ERR3: SYMERR("TOO FEW RIGHT PARENTHESES",NIL);
  ERR4: SYMERR("REDUNDANT OPERATOR",NIL);
  ERR5: SYMERR("MISSING OPERATOR",NIL)
   END;

FLAG ('(ENDSTAT MODESTAT RETSTAT TIMSTAT),'ENDSTAT);

LISP PROCEDURE XREAD U;
   PROG2(SCAN!*(),XREAD1 U);

LISP PROCEDURE COMMAND;
   BEGIN SCAN!*(); KEY!* := CURSYM!*; RETURN XREAD1 NIL END;


%*********************************************************************
%        FUNCTIONS FOR PRINTING DIAGNOSTIC AND ERROR MESSAGES
%********************************************************************;

LISP PROCEDURE LPRI U;
   BEGIN
    A:  IF NULL U THEN RETURN NIL;
	PRINC CAR U;
	PRINC " ";
	U := CDR U;
	GO TO A
   END;

LISP PROCEDURE LPRIW (U,V);
   BEGIN SCALAR X;
	TERPRIX();
	U := U . IF V AND (ATOM V OR STRINGP V) THEN LIST V ELSE V;
	IF OFL!* AND (!*FORT OR NOT !*NAT) THEN GO TO C;
    A:	LPRI U;
	TERPRI();
	IF NULL X THEN GO TO B;
	WRS X;
	RETURN NIL;
    B:  IF NULL OFL!* THEN RETURN NIL;
    C:  X := OFL!*;
	WRS NIL;
	GO TO A
   END;

LISP PROCEDURE LPRIM U;
   LPRIW("***",U);

LISP PROCEDURE LPRIE U;
   BEGIN ERFG!* := T; TERPRI(); LPRIW ("*****",U) END;

LISP PROCEDURE REDERR U;
   BEGIN LPRIE U; TERPRI(); ERROR NIL END;

LISP PROCEDURE SYMERR(U,V);
   BEGIN SCALAR X;
	ERFG!* := T;
	IF NUMBERP CURSYM!* OR NOT(X := GET(CURSYM!*,'PRTCH))
	  THEN X := CURSYM!*
	 ELSE X := CAR X;
	TERPRI();
	OUTL!*:=CAR OUTL!* . "$$$" . CDR OUTL!*;
	COMM1 T;
	IF NULL V THEN LPRIE U 
	 ELSE LPRIE(X . ('INVALID .
		     (IF U THEN LIST('IN,U,'STATEMENT) ELSE NIL)));
	ERROR NIL
   END;


%*********************************************************************
%                           2.10 STATEMENTS
%********************************************************************;

COMMENT
	WITH  THE  EXCEPTION  OF  ASSIGNMENT  STATEMENTS,  WHICH  ARE
HANDLED BY XREAD, STATEMENTS IN REDUCE ARE INTRODUCED BY A  KEY-WORD,
WHICH  INITIATES  A  READING  PROCESS PECULIAR TO THAT STATEMENT. THE
KEY-WORD IS RECOGNIZED (IN XREAD1)  BY  THE  INDICATOR  STAT  ON  ITS
PROPERTY LIST.	THE   CORRESPONDING  PROPERTY  IS  THE  NAME  OF  THE
FUNCTION (OF NO ARGUMENTS) WHICH CARRIES OUT THE READING SEQUENCE. WE
BEGIN  BY  INTRODUCING  SEVERAL  STATEMENTS  WHICH ARE NECESSARY IN A
BASIC SYSTEM. LATER ON, WE INTRODUCE STATEMENTS WHICH ARE PART OF THE
COMPLETE   SYSTEM,   BUT   MAY   BE   OMITTED  IF  THE  CORRESPONDING
CONSTRUCTIONS ARE NOT REQUIRED.

	SYSTEM USERS MAY ADD NEW STATEMENTS TO REDUCE BY PUTTING  THE
NAME  OF  THE  STATEMENT READING FUNCTION ON THE PROPERTY LIST OF THE
NEW KEY-WORD WITH THE INDICATOR STAT. THE READING FUNCTION  COULD  BE
DEFINED  AS  A  NEW  FUNCTION OR BE A FUNCTION ALREADY IN THE SYSTEM.
SEVERAL APPLICATIONS ONLY  REQUIRE  THAT  THE  ARGUMENTS  BE  GROUPED
TOGETHER  AND  QUOTED  (SUCH AS IN, OUT, ETC). TO HELP WITH THIS, THE
FOLLOWING TWO GENERAL STATEMENT READING FUNCTIONS ARE AVAILABLE. THEY
ARE USED IN THIS TRANSLATOR BY ARRAY DEFINED LATER. THE FUNCTION RLIS
READS A LIST OF ARGUMENTS, BUT RETURNS IT AS  ONE  ARGUMENT,  WHEREAS
NORLIS RETURNS A LIST OF ARGUMENTS;

LISP PROCEDURE PROGVR VAR;
   IF NOT ATOM VAR THEN NIL
    ELSE IF NUMBERP VAR THEN T
    ELSE BEGIN SCALAR X;
	      IF X := GET(VAR,'DATATYPE) THEN RETURN CAR X
	 END;

LISP PROCEDURE MKARG U;
   IF NULL U THEN NIL
    ELSE IF ATOM U THEN IF PROGVR U THEN U ELSE MKQUOTE U
    ELSE IF FLAGP!*!*(CAR U,'NOCHANGE) AND NOT FLAGP(KEY1!*,'QUOTE)
     THEN U
   ELSE IF CAR U EQ 'QUOTE THEN MKQUOTE U
    ELSE 'LIST . MAPCAR(U,FUNCTION MKARG);

LISP PROCEDURE RLIS1 U;
   BEGIN SCALAR X,Y;
	IF NOT(X := GET(CURSYM!*,'STATFN)) THEN X := CURSYM!*;
	IF FLAGP!*!*(SCAN!*(),'DELIM) THEN RETURN LIST X;
	Y := REMCOMMA XREAD1 NIL;
	IF U THEN Y := LIST Y;
	KEY1!* := X;
	RETURN IF U EQ 'FLAGOP
		THEN LIST('FLAG,'QUOTE . Y,MKQUOTE X)
		ELSE (X . MAPCAR(Y,FUNCTION MKARG))
   END;

LISP PROCEDURE RLIS;
   RLIS1 T;

LISP PROCEDURE NORLIS;
   RLIS1 NIL;

LISP PROCEDURE RLISF;
   RLIS1 'FLAGOP ;

LISP PROCEDURE FLAGOP U;
   BEGIN
    A:	IF NULL U THEN RETURN NIL;
	PUT(CAR U,'STAT,'RLISF);
	U := CDR U;
	GO TO A
   END;

PUT('FLAGOP,'STAT,'RLIS);

FLAG ('(COND QUOTE PROG SETQ),'NOCHANGE);


%*********************************************************************
%                            2.7 COMMENTS
%********************************************************************;

LISP PROCEDURE COMM1 U;
   BEGIN
	IF U EQ 'END THEN GO TO B;
  A:	IF CURSYM!* EQ '*SEMICOL*
	   OR (U EQ 'END
		 AND (CURSYM!* MEMBER '(END ELSE UNTIL *RPAR*)))
	  THEN RETURN NIL;
  B:	SCAN!*();
	GO TO A
   END;


%*********************************************************************
%                    2.10.2 CONDITIONAL STATEMENT
%********************************************************************;

LISP PROCEDURE ACONC(U,V);
   NCONC(U,LIST V);

LISP PROCEDURE MKEX U;
   IF !*MODE EQ 'SYMBOLIC THEN U ELSE APROC U;

LISP PROCEDURE IFSTAT;
   BEGIN SCALAR CONDX,CONDIT;
	 FLAG(LETL!*,'DELIM);
    A:   CONDX := XREAD T;
	 REMFLAG(LETL!*,'DELIM);
	 IF NOT (CURSYM!* EQ 'THEN) THEN GO TO C;
	 CONDIT := ACONC(CONDIT,LIST(MKEX CONDX,MKEX XREAD T));
	 IF NOT (CURSYM!* EQ 'ELSE) THEN GO TO B
	  ELSE IF SCAN!*() EQ 'IF  THEN GO TO A
	  ELSE CONDIT := ACONC(CONDIT,LIST(T,MKEX XREAD1 T));
    B:   RETURN ('COND . CONDIT);
    C:   IF NOT (CURSYM!* MEMBER LETL!*) THEN SYMERR('IF,T);
	 MCOND!* := MKEX CONDX;
	 RETURN FORALLFN GVARB CONDX
   END;

PUT('IF,'STAT,'IFSTAT);

FLAG ('(THEN ELSE),'DELIM);


%*********************************************************************
%                      2.10.5 COMPOUND STATEMENT
%********************************************************************;

LISP PROCEDURE FLAGTYPE(U,V);
   BEGIN SCALAR X,Y,Z;
	VARS!* := APPEND(U,VARS!*);
    A:   IF NULL U THEN RETURN REVERSE Z;
	 X := CAR U;
	Y := DEFP(X,NIL);
	IF Y AND Y NEQ 'SCALAR THEN REDERR LIST("TYPE CONFLICT FOR",X);
	 Y := GET(X,'DATATYPE);
	 PUT(X,'DATATYPE,V . Y);
	 Z := X . Z;
	U := CDR U;
	 GO TO A
   END;

LISP PROCEDURE DEFP(U,V);
   BEGIN SCALAR W;
	IF NOT ATOM U OR NUMBERP U THEN ERRPRI2(U,'HOLD);
	W := DEFL!*;
    A:	IF NULL W THEN RETURN NIL ELSE IF GET(U,CAAR W) THEN GO TO B;
	W := CDR W;
	GO TO A;
    B:	IF V THEN MESPRI(NIL,U,"ALREADY DEFINED AS",CDAR W);
	RETURN CDAR W
   END;

LISP PROCEDURE DECL U;
   BEGIN SCALAR V,W,VARLIS;
    A:   IF NOT FLAGP!*!*(CURSYM!*,'TYPE) THEN RETURN VARLIS;
	 W := CURSYM!*;
	 IF SCAN!*() EQ 'PROCEDURE THEN RETURN PROCSTAT();
	 V := FLAGTYPE(REMCOMMA XREAD1 NIL,W);
	 VARLIS := APPEND(V,VARLIS);
	 NOT (CURSYM!* EQ '*SEMICOL*) AND SYMERR(NIL,T);
	 U AND SCAN!*();
	 GO TO A
   END;

FLAG ('(REAL INTEGER SCALAR),'TYPE);

LISP PROCEDURE MKPROG(U,V);
   'PROG . (U . V);

LISP PROCEDURE SETDIFF(U,V);
   IF NULL V THEN U ELSE SETDIFF(DELETE(CAR V,U),CDR V);

LISP PROCEDURE REMTYPE VARLIS;
   BEGIN SCALAR X,Y;
	VARS!* := SETDIFF(VARS!*,VARLIS);
    A:   IF NULL VARLIS THEN RETURN NIL;
	 X := CAR VARLIS;
	 Y := CDR GET(X,'DATATYPE);
	 IF Y THEN PUT(X,'DATATYPE,Y)
	  ELSE REMPROP(X,'DATATYPE);
	 VARLIS := CDR VARLIS;
	 GO TO A
   END;

LISP PROCEDURE BLOCKSTAT;
   BEGIN SCALAR X,HOLD,VARLIS;
	BLOCKP!* := NIL . BLOCKP!*;
	 SCAN!*();
	 IF CURSYM!* MEMBER '(NIL *RPAR*) THEN ERROR !*!*ESC;
	 VARLIS := DECL T;
    A:   IF CURSYM!* EQ 'END THEN GO TO B;
	 X := XREAD1 NIL;
	 IF EQCAR(X,'END) THEN GO TO C
	  ELSE IF NOT(CURSYM!* EQ '*COLON*) THEN X := MKEX X;
	 NOT (CURSYM!* EQ 'END) AND SCAN!*();	 IF X THEN HOLD := ACONC(HOLD,X);
	 GO TO A;
    B:   COMM1 'END ;
    C:   REMTYPE VARLIS;
	BLOCKP!* := CDR BLOCKP!*;
	 RETURN MKPROG(VARLIS,HOLD)
   END;

LISP PROCEDURE DECSTAT;
   %THIS FUNCTIONS IS NEEDED ONLY FOR TOP LEVEL DECLARATIONS;
   BEGIN SCALAR Z;
	Z := DECL NIL;
	IF ATOM Z OR CAR Z EQ 'QUOTE THEN RETURN NIL;
	LPRIM "TOP LEVEL DECLARATIONS IGNORED";
	REMTYPE Z

   END;

DEFLIST ('((INTEGER DECSTAT) (REAL DECSTAT) (SCALAR DECSTAT)),'STAT);

PUT('BEGIN,'STAT,'BLOCKSTAT);


%*********************************************************************
%                       2.10.6 RETURN STATEMENT
%********************************************************************;

LISP PROCEDURE RETSTAT;
   LIST('RETURN,
	IF NOT BLOCKP!* THEN SYMERR(NIL,T)
	 ELSE IF FLAGP!*!*(SCAN!*(),'DELIM) THEN NIL 
	 ELSE MKEX XREAD1 T);

PUT('RETURN,'STAT,'RETSTAT);


%*********************************************************************
%                    6. EVALUATION MODE STATEMENT
%********************************************************************;

LISP PROCEDURE MODESTAT;
   BEGIN SCALAR X;
	X:= IF CURSYM!* EQ 'LISP THEN 'SYMBOLIC ELSE CURSYM!*;
	IF FLAGP!*!*(SCAN!*(),'DELIM) THEN RETURN NOT(!*MODE:=X);
	TMODE!* := !*MODE;
	!*MODE := X;
	RETURN XREAD1 NIL
   END;

%THE BOOT-STRAPPING PROCESS REQUIRES THAT  THE  STAT  PROPERTIES  FOR
%THE VARIOUS MODES BE ADDED AT THE END OF THE NEXT SUB-SECTION;


%*********************************************************************
%                      2.17 PROCEDURE STATEMENT
%********************************************************************;

LISP PROCEDURE PROCSTAT1(U,BODY,TYPE);
   BEGIN SCALAR NAME,VARLIS;
	NAME := CAR U;
	IF NULL NAME OR NOT ATOM NAME OR NUMBERP NAME
	    THEN REDERR LIST(NAME,"INVALID PROCEDURE NAME")
	 ELSE IF FLAGP(NAME,'LOSE) THEN RETURN NIL
	 ELSE IF NOT GETD NAME THEN FLAG(LIST NAME,'FNC);
	IF EQCAR(BODY,'PROG) THEN VARLIS := CADR BODY;
	IF VARLIS THEN RPLACA(CDR BODY,SETDIFF(VARLIS,CDR U));
	VARLIS := CDR U;
	IF FLAGP(NAME,'FNC) THEN GO TO A;
	LPRIM LIST(NAME,'REDEFINED);
  A:	IF !*DEFN THEN OUTDEF(NAME,VARLIS,BODY,TYPE)
	ELSE DEF!*(NAME,VARLIS,BODY,TYPE);
	REMFLAG(LIST NAME,'FNC);
	IF NOT(!*MODE EQ 'SYMBOLIC) THEN FLAG(LIST NAME,'OPFN);
	RETURN MKQUOTE NAME
   END;

LISP PROCEDURE PROCSTAT;
   BEGIN SCALAR X,Y,Z;
	TYPE!* := IF CURSYM!* EQ 'PROCEDURE THEN 'EXPR ELSE CURSYM!*;
	X := IF NOT(CURSYM!* EQ 'PROCEDURE OR SCAN!*() EQ 'PROCEDURE)
		THEN XREAD1 NIL
	      ELSE XREAD 'PROC ;
	IF ATOM X THEN X := LIST X ELSE IF CAR X EQ 'SETQ THEN GO TO B;
	Y := FLAGTYPE(CDR X,'SCALAR);
	Z := MKEX XREAD T;
	REMTYPE Y;
    A:	Z := PROCSTAT1(X,Z,TYPE!*);
	TYPE!* := NIL;
	RETURN Z;
    B:	IF NOT (!*MODE EQ 'SYMBOLIC) 
	 THEN PROG2(TYPE!* := NIL,SYMERR "SYNTAX ERROR");
	Z := CADDR X;
	X := CADR X;
	GO TO A
   END;


DEFLIST ('((PROCEDURE PROCSTAT) (FEXPR PROCSTAT) (MACRO PROCSTAT)),
	'STAT);


DEFLIST ('((ALGEBRAIC MODESTAT) (LISP MODESTAT) (SYMBOLIC MODESTAT)),
	 'STAT);


%*********************************************************************
%                         2.19 END STATEMENT
%********************************************************************;

LISP PROCEDURE ENDSTAT;
  %THIS PROCEDURE CAN ALSO BE USED FOR ANY KEY-WORDS  WHICH  TAKE  NO
  %ARGUMENTS;
   BEGIN SCALAR X;
	X := CURSYM!*;
	COMM1 'END ;
	RETURN LIST X
   END;

PUT('END,'STAT,'ENDSTAT);


%*********************************************************************
%                      SOME ARITHMETIC FUNCTIONS
%********************************************************************;

LISP PROCEDURE M**N;
   BEGIN INTEGER P; SCALAR Q;
	IF N=0 OR M=1 THEN RETURN 1;
	P := 1;
  A:	Q := DIVIDE(N,2);
	IF CDR Q = 0 THEN GO TO B;
	P := M*P;
	IF CAR Q = 0 THEN RETURN P;
  B:	N := CAR Q;
	M := M*M;
	GO TO A
   END;

LISP PROCEDURE U>=V;
   U=V OR U>V;

LISP PROCEDURE U<=V;
   U=V OR U<V;

LISP PROCEDURE U NEQ V;
   NOT (U=V);

DEFLIST ('((GREATEQ GEQ) (LESSEQ LEQ) (UNEQ NEQ)),'NEWNAM);




%*********************************************************************
%*********************************************************************
%                         MODULAR STATEMENTS
%*********************************************************************
%********************************************************************;

%	 THE  REMAINING  STATEMENTS  DEFINED IN THIS SECTION ARE TRULY
%MODULAR, AND ANY MAY BE OMITTED IF DESIRED.


%*********************************************************************
%          2.5 FUNCTIONS FOR INTRODUCING NEW INFIX OPERATORS
%********************************************************************;

LISP PROCEDURE INFSTAT;
   BEGIN SCALAR X;
	 X := REMCOMMA XREAD NIL;
	 IF !*MODE EQ 'ALGEBRAIC THEN MAPCAR(X,FUNCTION MKOP);
	 PRECLIS!* := APPEND(REVERSE X,PRECLIS!*);
	 MKPREC()
   END;

LISP PROCEDURE PRECSTAT;
   BEGIN SCALAR X;
	X := REMCOMMA XREAD NIL;
	RETURN PRECSET(CAR X,CADR X)
   END;

LISP PROCEDURE PRECSET(X,Y);
   BEGIN SCALAR W,Z;
	 PRECLIS!* := DELETE(X,PRECLIS!*);
	 W := PRECLIS!*;
    A:   IF NULL W THEN REDERR LIST (Y,"NOT FOUND")
	  ELSE IF Y EQ CAR W THEN GO TO B;
	 Z := CAR W . Z;
	 W := CDR W;
	 GO TO A;
    B:   PRECLIS!* := NCONC(REVERSE Z,CAR W . (X . CDR W));
	 MKPREC()
   END;

PUT('INFIX,'STAT,'INFSTAT);

PUT('PRECEDENCE,'STAT,'PRECSTAT);


%*********************************************************************
%                        2.10.3 FOR STATEMENT
%********************************************************************;

LISP PROCEDURE FLATTEN U;
   IF NULL U THEN NIL
    ELSE IF ATOM U THEN LIST U
    ELSE IF ATOM CAR U THEN CAR U . FLATTEN CDR U
    ELSE NCONC(FLATTEN CAR U,FLATTEN CDR U);

LISP PROCEDURE PROGCHK U;
   BEGIN SCALAR X;
	 IF NOT EQCAR(U,'PROG) OR CADR U THEN RETURN NIL;
	 U := CDR U;
    A:   U := CDR U;
	 IF NULL U THEN RETURN REVERSE X
	  ELSE IF ATOM CAR U THEN GO TO B
	  ELSE IF EQCAR(CAR U,'RETURN) THEN GO TO RET
	  ELSE IF EQCAR(CAR U,'PROG) THEN GO TO B
	  ELSE IF 'RETURN MEMBER FLATTEN CAR U THEN RETURN NIL;
    B:   X := CAR U . X;
	 GO TO A;
    RET: IF CDR U THEN RETURN NIL
	  ELSE IF NOT ATOM CADAR U THEN X := CADAR U . X;
	 GO TO A
   END;

LISP PROCEDURE ADFORM(U,V,W);
   IF NULL W THEN NIL
    ELSE IF V=CAR W
     THEN BEGIN SCALAR X;
		X := PROGCHK U;
		RETURN IF NULL X THEN U . CDR W ELSE APPEND(X,CDR W)
	    END 

    ELSE CAR W . ADFORM(U,V,CDR W);

LISP PROCEDURE FORLOOP;
   BEGIN SCALAR CURS,EXP,INCR,INDX,CONDLIST,BODY,FLG,FNC,LAB1,LAB2;
	 FNC := GENSYM();
	 EXP := XREAD1 'FOR ;
	 IF CAR EXP EQ '*COMMA*  AND EQCAR(CADR EXP,'SETQ)
	     THEN EXP := LIST(NIL,
			      CADADR EXP,
			      '*COMMA* . NCONC(CDDADR EXP,
						CDDR EXP))
	  ELSE IF NOT (CAR EXP MEMBER '(SETQ EQUAL)) THEN GO TO ERR;
	 EXP := CDR EXP;
	 IF NOT ATOM (INDX := CAR EXP) OR NUMBERP INDX THEN GO TO ERR;
	 INDX := CAR FLAGTYPE(LIST INDX,'INTEGER);
	EXP := REMCOMMA CADR EXP;
    A1:  IF NULL EXP THEN GO TO B2
	  ELSE IF CDR EXP THEN FLG := T
	  ELSE IF CURSYM!* EQ 'STEP THEN GO TO B1
	  ELSE IF CURSYM!* EQ '*COLON* THEN GO TO BB;
	 CONDLIST := NCONC(CONDLIST,
			   LIST(LIST('SETQ,INDX,CAR EXP),LIST FNC));
    B0:  EXP := CDR EXP;
	 GO TO A1;
    B1:  INCR := MKEX XREAD NIL;
	 IF NOT ((CURS := CURSYM!*) MEMBER '(UNTIL WHILE))
	  THEN GO TO ERR;
    AA:  LAB1 := GENSYM();
	 LAB2 := GENSYM();
	 CONDLIST := ACONC(CONDLIST,LIST('SETQ,INDX,CAR EXP));
	 EXP := REMCOMMA XREAD NIL;
	 BODY := MKEX CAR EXP;
	 CONDLIST :=
	    NCONC(CONDLIST,LIST(LAB1,LIST('COND,
	      LIST(IF CURS EQ 'UNTIL THEN IF NUMBERP INCR
		THEN LIST(IF MINUSP INCR THEN 'LESSP ELSE 'GREATERP,
			  INDX,
			  BODY)
	       ELSE LIST('MINUSP,LIST('TIMES,LIST('DIFFERENCE,
						  BODY,
				  		  INDX),
					INCR))
	      ELSE LIST('NOT,BODY),LIST('GO,LAB2))),
				LIST FNC,
				LIST('SETQ,
				     INDX,
				     LIST('PLUS,INDX,INCR)),
				LIST('GO,LAB1),
				LAB2));
	 CDR EXP AND (FLG := T);
	 GO TO B0;
    BB:  INCR := 1;
	 CURS := 'UNTIL ;
	 GO TO AA;
    B2:  IF NULL CONDLIST THEN GO TO ERR
	  ELSE IF CURS:=GET(CURSYM!*,'BIN) THEN GO TO C
	  ELSE IF NOT (CURSYM!* EQ 'DO) THEN GO TO ERR;
	 BODY := XREAD NIL;
    B:   IF FLG THEN DEF!*(FNC,NIL,BODY,'DEFINE)
	  ELSE CONDLIST := ADFORM(BODY,LIST FNC,CONDLIST);
	 REMTYPE LIST INDX;
	 RETURN MKPROG(INDX . EXP,
		       ACONC(CONDLIST,'(RETURN NIL)));
    C:   EXP := GENSYM();
	 BODY := LIST('SETQ,
		      EXP,
		      LIST(CAR CURS,
			   LIST('SIMP*,MKARG XREAD T),
			   EXP));
	 CONDLIST := LIST('SETQ,EXP,MKQUOTE CDR CURS) .
			       ACONC(CONDLIST,
					   LIST('RETURN,
						LIST('MK*SQ,
						     LIST('SUBS2,
							  EXP))));
	 EXP := LIST EXP;
	 GO TO B;
    ERR: SYMERR('FOR,T)
   END;

LISP PROCEDURE FORSTAT;
   IF SCAN!*() EQ 'ALL THEN FORALLFN!*() ELSE FORLOOP();

PUT('FOR,'STAT,'FORSTAT);

FLAG ('(STEP DO UNTIL WHILE),'DELIM);


%*********************************************************************
%                       2.11.2 ARRAY STATEMENT
%********************************************************************;

LISP PROCEDURE NUMLIS U;
   NULL U OR (NUMBERP CAR U AND NUMLIS CDR U);

LISP PROCEDURE ARRAYFN U;
   BEGIN SCALAR X,Y;
    A:	IF NULL U THEN RETURN NIL;
	X := CAR U;
	IF ATOM X THEN ERRPRI2(X,T)
	 ELSE IF DEFP(CAR X,NIL) THEN REDERR LIST(X,"ALREADY DEFINED");	Y := IF !*MODE EQ 'SYMBOLIC THEN CDR X ELSE REVLIS CDR X;
	IF NOT NUMLIS Y
	  THEN LPRIE LIST("INCORRECT ARRAY ARGUMENTS FOR",CAR X);
	PUT(CAR X,'**ARRAY,Y);
	!*ARRAY LIST (CAR X . MAPCAR(Y,FUNCTION ADD1));
	U := CDR U;
	GO TO A
   END;

PUT('ARRAY,'STAT,'RLIS);

PUT('ARRAY,'STATFN,'ARRAYFN);

FLAG ('(ARRAYFN),'EVAL);


%*********************************************************************
%                      2.11.3 ON/OFF STATEMENTS
%********************************************************************;

LISP PROCEDURE ON1 U;

   BEGIN SCALAR X,Y,Z;
	X := REMCOMMA XREAD NIL;
    A:	IF NULL X THEN RETURN MKPROG(NIL,Z)
	 ELSE IF NOT ATOM CAR X OR NUMBERP CAR X THEN GO TO C;
	Z := MKFORM('SETQ,
		  LIST(COMPRESS APPEND(EXPLODE "*",EXPLODE CAR X),
		       U)) . Z;
	IF Y := ASSOC(U,GET(CAR X,'SIMPFG))
	  THEN Z := APPEND(MAPCAR(CDR Y,FUNCTION (LAMBDA J;
				         MKFORM(CAR J,CDR J))),
			   Z);
    B:	X := CDR X;
	 GO TO A;
    C:	LPRIE LIST(CAR X,"INVALID ARGUMENT");
	GO TO B
   END;

LISP PROCEDURE ONSTAT;
   ON1 T;

LISP PROCEDURE OFFSTAT;
   ON1 NIL;

PUT('ON,'STAT,'ONSTAT);

PUT('OFF,'STAT,'OFFSTAT);


%*********************************************************************
%                        3.2.4 WRITE STATEMENT
%********************************************************************;

LISP PROCEDURE WRITSTAT;
   BEGIN SCALAR MODE,X,Y,Z;
	MODE := EQ(!*MODE,'SYMBOLIC);
	X := REMCOMMA XREAD NIL;
    A:  IF NULL X THEN RETURN
		IF MODE THEN MKPROG(NIL,MKFORM('TERPRI,NIL) . Y)
		  ELSE MKFORM('VARPRI,LIST ('LIST . Y,NIL));
	Z := IF MODE THEN MKFORM('PRINC,LIST CAR X)
	      ELSE MKQUOTE MKEX CAR X;
	IF MODE AND NULL CDR X THEN Z := LIST('RETURN,Z);
	Y := ACONC(Y,Z);
	X := CDR X;
	GO TO A 
   END;

PUT('WRITE,'STAT,'WRITSTAT);


%*********************************************************************
%                        6.6 LAMBDA STATEMENT
%********************************************************************;
LISP PROCEDURE LAMSTAT;
   BEGIN SCALAR X,Y;
	IF NOT (!*MODE EQ 'SYMBOLIC) THEN SYMERR("ALGEBRAIC",T);
	X:= XREAD 'LAMBDA ;
	FLAGTYPE(X := IF NULL X THEN NIL ELSE REMCOMMA X,'SCALAR);
	Y := LIST('LAMBDA,X,XREAD T);
	REMTYPE X;
	RETURN Y
   END;

PUT ('LAMBDA,'STAT,'LAMSTAT);


END;
                                                                                           @Cu