!TITLE: PAPER TAPE HACKAGE      VERSION 3.02
!SUBTTL: GARY GERE      DECEMBER, 1972
!

BASE 0          !EVERYTHING IS AT 0

!MISC. RAMBLINGS
!  THE FOLLOWING MACRO COMPUTES A GENERAL BYTE POINTER SO THAT NCHV ON
!  THE PDP-10 WILL DO ILDB'S FOR ANY BYTE SIZE.
DEF BYPT(Y,P,S) AS [6,6,6,18]*[IF P>=0 THEN 36-S*(P MOD(36/S)-1)&
        ELSE 36-S*(36/S-(-P)MOD(36/S)+1),S,0,&
        IF P>=0 THEN Y+P/(36/S) ELSE Y+(P+1)/(36/S)-1]
DEF NBYV AS NCHV
DEF BYV AS CHV

! THE FOLLOWING 'EXU' MACROS ARE COMPLETELY MACHINE DEPENDENT
! THE WORK ON THE FACT THAT THE PDP-10 SIMPL WILL PACK ARGUMENTS
! STARTING AT REGISTER 1 FOR ARGUMENT 1, 2 FOR 2 ETC.
! THEY CAUSE SIMPL TO GENERATE CODE WHICH POINTS TO A REGISTER
! FOR THE CODE'S ARGUMENT (IE- TTCALL 15,4   SLEEP 4,   ETC.)
!
DEF IONEOU(X) AS EXU(OCT 51,OCT 15,4,X) !TTCALL 15,4 OR  IONEOU 4
DEF SLEEP(X) AS EXU(OCT 47,4,OCT 31,X)  !SLEEP 4,
DEF MOUTSTR(X) AS EXU(OCT 51,OCT 3,X)    !TTCALL 3,M  OR  OUTSTR M

DEF ENDK AS OK; RETURN EMPTY
DEF ENDR AS RETURN EMPTY
DEF TOKEN AS TOKBUF(0)
DEF SETIN AS CSTRING(POINTX(TOKBUF),POINTX(IFILS))
DEF SETOU AS CSTRING(POINTX(TOKBUF),POINTX(OFILS))
DEF MORE AS CKEOL(STR)=FALSE
DEF POINT(X) AS CHPT(X,-1)
DEF POINTX(X) AS POINT(@X(0))
DEF CRLF AS PUT(CARRET) !C.R. AND L.F.

!MISC. NUMERIC RAMBLINGS
DEF NO.CMDF AS 10       !NUMBER OF COMMAND-FILES ALLOWED OPEN
DEF NO.CHAR AS 250      !MULT. OF 5 - NO OF CHARACTER IN READ BUFFER
DEF MINS(X) AS X*1      !NUMBER OF IOCS BUFFERS PER MINUTE [==1]
DEF NO.CRAPS AS MINS(5) !NUMBER OF MINUTES BETWEEN CRASH PROTECTION
DEF NO.IOCB AS 10       !NUMBER OF DIRECT MODE IOCS BUFFERS
DEF SR.SIZE AS OCT 250  !MAX CHARACTER FOR 'SPLICE' COMMAND BUFFER
DEF NO.SPLI AS OCT 50   !# CHARACTERS TO USER IN SPLICE COMMAND
DEF PE.MAX AS 20        !MAX. NO. PARITY ERRORS PER IMAGE LINE (<NOCHAR)
DEF MAX.CHR AS OCT 177  !MAX. CHARACTER THIS PROGRAM CAN HANDLE
DEF MAX.DIG AS 11       !MAX. NO. OF DIGITS
DEF TCHR AS OCT 175     !CHARACTER WHICH TERMINATES TITLE STRING
DEF TRUE AS 1		!TRUE STATEMENT
DEF FALSE AS 0		!FALSE STATEMENT
DEF EMPTY AS -1         !EMPTY EXPRESSION

!DATA TYPES
DEF FIRK AS -2          !A FIRKED UP EXPRESSION
DEF STRING AS 1		!STRING EXPRESSION
DEF NUMBER AS 2		!NUMERIC EXPRESSION
DEF RESWRD AS 3		!RESERVED WORD
DEF DELIMT AS 4         !TERMINATOR

!DEFS FOR DO
DEF OFF AS 7
DEF EVEN AS 8
DEF ODD AS 9
DEF DATA AS 10
DEF PACKD AS 49

! GETOKEN DEFS
DEF NUMIN AS OCT 1
DEF STRIN AS OCT 2
DEF RESIN AS OCT 4

!TABLE OF RESERVED WORDS. INDEX IS RESERVED WORD NUMBER
!
! TABLE "SWORDS"
! CONTAINS ASCII CHARACTER NAMES FOR SUBSTITUTE COMMAND
!
DEF C.SIZE AS 54                !# RESERVED WORDS
DEF S.SIZE AS 128               !# RESERVED WORDS
DEF S.BUFF AS 100               !SUBSTITUTE BUFFER WORD SIZE

FIND SWORDS(0:S.SIZE),HELPM(0),TWORDS(0:OCT 137),CWORDS(0:C.SIZE),ECNT(0)
FIND YESNO(0),COMNDS(0),PRITY(0),TTLE(0),SYMBIN(0),REPIT(0),ECHIT(0),NOTBL(0),SUBIT(0),USETB(0),EDITB(0)

FIND %SETTY,%RDTTY,%OPNPTP,%CLSPTP,%WRTPTP

FIND JOBFF,JOBVER,JOBREN,JOBAPR         !!!JOBDAT, RAH!!!

GLOBAL ALTMOD:,ESCAPE:,BEGIN:

GLOBAL %NCHR,%GETOKEN,%CTOKEN,%STOKEN,%SINC,%INSC,%STRCOMP,%INDEX,%OK
GLOBAL %CSTRING,%FIRKIT,%NCHAR,%TYPCHR,%OUTNUM,%GOCMD,%NXLIN,%ERR
GLOBAL %OUTSTR,%PRM,%FIGURE,%DOCMD,%FOO,%INIT,%HELP,%READ,%PUNCH,%SUBGET
GLOBAL %COPYST,%SUBPUT,%SUBOUT,%OUTTIT,%LEDTRL,%CONFMP,%MAKPAR,%SUBCR
GLOBAL %SUBINI,%SUBPRC,%LEV7,%MAKTMP,%LEV8,%WSTR,%OUCH,%OUCS,%NXCHR
GLOBAL %SUBRD,%PARERR,%SUBWT,%SUBCLN,%WINT,%PAROUT,%CNTER,%SWSTR,%SWOUT
GLOBAL %SUBRED,%CRASHP,%NEWCMD,%OLDCMD,%STRIP,%SEARCH,%SERRD,%CHECK.ARRAY
GLOBAL %OUTIMG,%HELPER,%CKEOL

GLOBAL CHAR,TOKBUF(0:50),TERMCH,TYPE,SLEEPY,TITBUF(0:50),TITLE
GLOBAL ECHAR,ELINE,LENGTH,PARITY,STR,SVPLAC,FCORE()
GLOBAL ISUBTAB(0:MAX.CHR),ESUBTAB(0:MAX.CHR)
GLOBAL LASLIN,LASINP,TELFIL,LASPRM,RUNFLG,ECHO,RPTYPE,SYMBN,IFILE,OFILE
GLOBAL SUBPTR,SUBUFF(0:S.BUFF),OFILS(0:10),IFILS(0:10),MTOKS(0:20)
GLOBAL PARNAM(0:5),TAPNAM(0:5),PARTY,CMDFLS(0:NO.CMDF),CURCMD,LINFLG(0:NO.CMDF)
GLOBAL USEFLG,ALWP8T,LASFMP

!**************************** MAIN PROGRAM ****************************!

BEGIN:  IOCS(NO.IOCB)           !GET IOCS MOVING
        MSG('YOUR JOB ID IS '); OUTNUM(EXU(OCT 47,OCT 1,OCT 30),8)
        CRLF
        INIT
ESCAPE: LOOP FOO                !KEEP ON LOOPING 
ALTMOD: CLOBUF; CLIBUF; CRLF; RUNFLG_0; OFILE_IFILE_TEL; NEWCMD(TEL)
        CLOSE.ALL; GO ESCAPE

!**************************** PROCEDURES ******************************!

! PROCEDURES
!

! PROCEDURE: OUTIMG
! IF GOING TO TELETYPE DO IONEOU(ARG1) ELSE DO WRTPTP(ARG1)
!
%OUTIMG(ARG1)

        IF USEFLG=FALSE THEN IONEOU(ARG1) ELSE WRTPTP(ARG1)

        RETURN

END OUTIMG

! PROCEDURE: NEWCMD
! TAKES ARGUMENT 1 AS A NEW COMMAND FILE NUMBER. STACKS UP OLD
! COMMAND FILE AND SETS LASLIN=0
! IF ARGUMENT IS 'TEL' THEN RESETS AND CLOSES ALL STACKED-UP
! COMMAND-FILES
!
%NEWCMD(ARG1)

        IF ARG1=TEL THEN DO
          CLOSE(TELFIL<==TEL)
          FOR ARG1_0 TO CURCMD BY 1 CLOSE(CMDFLS(ARG1))
          LASLIN_CURCMD_0
          RETURN
        END ELSE DO
          IF INC CURCMD>NO.CMDF THEN DO
          ERR('TOO MANY COMMAND FILES OPEN  I GIVE UP$')
          MSG('THE MAX # OF ALLOWABLE COMMAND FILES IS CURRENTLY ')
          OUTNUM(NO.CMDF,10)
          HALT          !!!GIVE UP THE SHIT!!!
          END
          LINFLG(CURCMD)_LASLIN<==0; CMDFLS(CURCMD)_TELFIL<==ARG1
          RETURN
          END

END NEWCMD

! PROCEDURE: OLDCMD
! CLOSES CURRENT COMMANDS-FROM FILE AND UNSTACKS DOWN TO NEXT
! STACKED UP COMMAND FILE.  IF NON STACKED UP, USES 'TEL'
!
%OLDCMD

        IF CURCMD=0 THEN [TELFIL_TEL; LASLIN_0; RETURN]
        LASLIN_LINFLG(CURCMD); CLOSE(TELFIL<==CMDFLS(CURCMD<==CURCMD-1))
        RETURN

END OLDCMD


! PROCEDURE: CTOKEN
! ONE ARGUMENT: STRING TO BE SCANNED
! USES RESERVED WORD TABLE "CWORDS" IN RESERVED WORD CHECK
!
%CTOKEN(@ARG1,ARG2(),ARG3)

        RETURN GETOKEN(@ARG1,CWORDS,C.SIZE,TRUE,ARG2,ARG3)

END CTOKEN
! PROCEDURE: STOKEN
! ONE ARGUMENT: STRING TO BE SCANNED
! USES RESERVED WORD TABLE "SWORDS" IN RESERVED WORD CHECK
!
%STOKEN(@ARG1,ARG2(),ARG3)

        RETURN GETOKEN(@ARG1,SWORDS,S.SIZE,FALSE,ARG2,ARG3)

END STOKEN

! PROCEDURE: GETOKEN
! FOUR ARGUMENTS: 1:BYTE POINTER, 2:RESERVED WORD TABLE, 3:LENGTH OF 2
! 4: TRUE IF LOWER TO UPPER, FALSE IF LOWER OK
! 5: ENTRY ARRAY FOR ARGUMENT(2), 6: SET UP AS FOLLOWS:
!    001 = NUMBER REQUIRED
!    010 = STRING REQUIRED
!    100 = RESERVED WORD REQUIRED
!
! SCANS ARGUMENT TO CALL AND SET UP AS FOLLOWS:
!
! RETURNS THE TYPE OF TOKEN RETURNED AS THE VALUE RETURNED
! TERMCH = CHARACTER TERMINATING THE TOKEN
! TOKBUF = THE TOKEN
!       : TOKEN= NUMBER IF TOKEN RETURNED IS NUMBER
!       : TOKEN= RESERVED WORD NUMBER IF RESERVED WORD
!       : TOKBUF = STRING RETURNED IF STRING TOKEN
!
%GETOKEN(@ARG,ARG2(),ARG3,ARG4,ARG5(),ARG6)

LOCAL PTR,CNTR,FOUND,PLACE,OPNERR:

        LOOP DO         !LOOP (SEE OPNERR:)
        WHILE TYPE_NXCHR(@ARG,ARG4)=DELIMT AND (CHAR=$  OR CHAR=LNFEED&
        OR CHAR BAND OCT 177=OCT 177) THEN NULL

! IF ? THEN TYPE VALID ARGUMENTS AND RETURN EMPTY
        EIF TYPE=DELIMT AND CHAR=$? AND ARG4=TRUE THEN DO
          MSG('$VALID ARGUMENTS ARE:$')
          IF ARG5#0 THEN DO
          FOR CNTR_0 TO ARG3 BY 1 &
          IF CHECK.ARRAY(CNTR,ARG5)=TRUE THEN [MSG(ARG2(CNTR));CRLF]
        END

          IF ARG6 BAND NUMIN = NUMIN THEN MSG('$NUMERIC INPUT')
          IF ARG6 BAND STRIN = STRIN THEN MSG('$QUOTED STRING')
!         IF ARG6 BAND RESIN = RESIN THEN MSG('$COMMAND WORD')
          CRLF; RETURN EMPTY
          END


!LOOP TO DECIPHER QUOTED STRING
        ORIF TYPE=DELIMT AND ($'=CHAR OR $"=CHAR) THEN DO
           PTR_POINTX(TOKBUF); CNTR_CHAR !SAVE END CHAR
             LOOP DO
              EIF TYPE_NCHR(@ARG)=DELIMT AND CHAR=CARRET THEN DO

                ERR('IMPROPER TERMINATION:'); PUT(CNTR)
                NCHV PTR_EOLIT; MSG(@TOKEN); CRLF; RETURN FIRK
                END
              FIF  CHAR#CNTR AND CHAR#LNFEED THEN NCHV PTR_CHAR
              WHILE CHAR#CNTR
              END
           TYPE_NCHR(@ARG); TERMCH_CHAR; NCHV PTR_EOLIT
           IF TYPE#DELIMT THEN DO               !LITERAL ENDS WITH DELIMT
            ERR('STRING ERROR:$')
            PUT(CNTR); MSG(@TOKEN); PUT(CNTR); PUT(CHAR)
            MSG('$STRING ARGUMENT CANNOT END WITH "'); PUT(CHAR)
            MSG('"$'); RETURN FIRK
            END
           RETURN STRING
           END

!LOOP TO DECIPHER NUMERIC VALUE
        ORIF TYPE=NUMBER THEN DO
           PTR_POINTX(TOKBUF); NCHV PTR_CHAR
             WHILE TYPE_NCHR(@ARG)=NUMBER THEN NCHV PTR_CHAR
             NCHV PTR_EOLIT; PTR_POINTX(TOKBUF)
             TERMCH_CHAR
             EIF CHAR=$B OR TYPE=DELIMT THEN TOKEN_SINC(@PTR,8)
             ORIF CHAR=$D THEN TOKEN_SINC(@PTR,10)
             ELSE DO
                ERR('INVALID CHARACTER "'); PUT(CHAR); MSG('" IN NUMBER:')
                MSG(@TOKEN); CRLF; RETURN FIRK
                END

           IF TERMCH=$B OR TERMCH=$D OR TYPE#DELIMT THEN [TYPE_NCHR(@ARG);TERMCH_CHAR]
           IF TOKEN>MAX.CHR THEN DO
                ERR('NUMBER MUST BE LESS THAN '); OUTNUM(MAX.CHR,8)
                MSG(' OCTAL:'); OUTNUM(TOKEN,8); CRLF
                RETURN FIRK
                END
           RETURN NUMBER
           END

!LOOP TO DECIPHER RESERVED WORD
        ORIF TYPE=STRING THEN DO
          FOR PTR_0 TO 20 MTOKS(PTR)_0
          PTR_POINTX(TOKBUF); NCHV PTR_CHAR
            WHILE TYPE_NXCHR(@ARG,ARG4)=STRING OR TYPE=NUMBER THEN NCHV PTR_CHAR
          TERMCH_CHAR; NCHV PTR_EOLIT; CNTR_ARG3+1; FOUND_0

            WHILE DEC CNTR>=0 THEN DO
              EIF CHECK.ARRAY(CNTR,ARG5)=FALSE THEN NULL
              ORIF STRCOMP(POINTX(TOKBUF),POINT(ARG2(CNTR)))=TRUE&
              THEN [TOKEN_CNTR;RETURN RESWRD]
              FIF INDEX(POINTX(TOKBUF),POINT(ARG2(CNTR)))=TRUE&
              THEN [MTOKS(INC FOUND)_PLACE_CNTR]
            END

            EIF FOUND=0 THEN [ERR('NOT RECOGNIZED:');&
                MSG(@TOKEN); CRLF; RETURN FIRK]
            ORIF FOUND=1 THEN [TOKEN_PLACE;RETURN RESWRD]
            ELSE DO
                ERR('AMBIGUOUS:"')
                MSG(@TOKEN); MSG('"$CHOICES ARE:'); FOUND_0
                WHILE MTOKS(INC FOUND)#0 THEN [MSG(ARG2(MTOKS(FOUND)));&
                MSG(' ')]
                CRLF; RETURN FIRK
                END
          END

! LOOP TO DECIPHER COMMANDS-FROM FILE
        ORIF TYPE=DELIMT AND CHAR=$@ THEN DO    !COMMAND-FILE
          CSTRING(ARG,POINTX(TOKBUF))          !COPY STRING TO WORD LIM
          NEWCMD(OPEN(@TOKEN,SEQUEN+INPUT+CHARACTER,OPNERR,1))
          ARG_NXLIN
          END

! UNKNOWN ENTITY - RETURN AS IS
        ELSE [TOKEN_TERMCH_CHAR;RETURN TYPE]

        END             !OF LOOP DO FOR THOSE WHO FALL THROUGH

! IOCS ERROR LABEL
OPNERR: ERR('$CANNOT OPEN COMMAND-FILE:'); MSG(@TOKEN); CRLF
          NEWCMD(TEL); GO ESCAPE        !RESTART


END GETOKEN

! PROCEDURE: CHECK.ARRAY
! GIVEN ARG1=INDEX INTO TABLE ARG2 WILL RETURN 'TRUE'
! IF INDEX IS VALID ELSE WILL RETURN FALSE
! WILL ALWAYS RETURN TRUE IF 'ARG2'=0
!
%CHECK.ARRAY(ARG1,ARG2())

LOCAL I

        IF ARG2=0 THEN RETURN TRUE
        I_-1
        WHILE ARG2(INC I)#-1 THEN DO
           IF ARG2(I)=ARG1 THEN RETURN TRUE
           END
        RETURN FALSE

END CHECK.ARRAY

! PROCEDURE: COPYST
! COPY STRING ARG1 TO STRING ARG2 CHANGING ARG2
! ALSO DOESNT WRITE E.O.LIT CHARACTER AT END OF COPY
!
%COPYST(ARG1,@ARG2)

        WHILE E.O.LIT#CHAR_NCHV ARG1 THEN NCHV ARG2_CHAR
        RETURN

END COPYST

! PROCEDURE: CSTRING
! WILL COPY FIRST ARGUMENT TO SECOND ARGUMENT
!
%CSTRING(ARG1,ARG2)

        WHILE NCHV ARG2_NCHV ARG1#EOLIT THEN NULL
        NCHV ARG2_EOLIT
        RETURN

END CSTRING

! PROCEDURE: STRCOMP
! COMPARES TWO STRING.  RETURNS "TRUE" IF MATCH OR "FALSE" IF
! NOT MATCH:  ARGUMENTS ARE POINTERS TO TWO STRING.
%STRCOMP(ARG1,ARG2)

LOCAL A,B

        WHILE A_NCHV(ARG1)=B_NCHV(ARG2)#EOLIT THEN NULL
        RETURN [A=B]

END STRCOMP

! PROCEDURE: INDEX
! COMPARES TWO STRINGS. RETURNS "TRUE" IF FIRST STRING IS A SUBSET
! OF THE SECOND STRING
%INDEX(ARG1,ARG2)

LOCAL A,B

        LOOP DO
           EIF A_NCHV(ARG1)=EOLIT OR CARRET=A THEN RETURN TRUE
           FIF B_NCHV(ARG2)=EOLIT THEN RETURN FALSE
           WHILE A=B
        END
        RETURN FALSE

END INDEX

! PROCEDURE: CKEOL
! ARGUMENT: BYTE STRING (TERMCH MUST = LAST TERMINATOR)
! IF THERE IS MORE ON INPUT LINE, RETURN FALSE AND PRINT
! MESSAGE ELSE RETURN TRUE IF END OF LINE
!
%CKEOL(ARG1)

        IF TERMCH=CAR.RET THEN RETURN TRUE
        ERR('"')
        WHILE CHAR_NCHV ARG1#E.O.LIT AND CHAR#CAR.RET THEN PUT(CHAR)
        PUT($"); PUT($?); CRLF
        RETURN FALSE

END CKEOL

! PROCEDURE: HELPER
! OPENS (SYS)TAPE.HLP AND TYPES HELP MESSAGE
! ARGUMENT IS BYTE POINTER OF STRING IN HELP TEXT
!
%HELPER(ARG1)

LOCAL TMP1,TMP2,TMP3,HLPERR:,HLPEF1:,HLPEF2:

        TMP1_OPEN("(SYS)TAPE.HLP",SEQUEN+INPUT+CHARACTER,HLPERR,2)
        TMP2_ARG1               !SAVE ARGUMENT
        SETRWE(TMP1,HLPEF1)
        LOOP DO
        WHILE TMP3_R(TMP1)#LN.FEED THEN NULL
        IF TMP3_R(TMP1)=$* THEN DO
          WHILE NCHV TMP2=TMP3_R(TMP1) THEN NULL
          IF TMP3=$* THEN DO
            SETRWE(TMP1,HLPEF2)
            R(TMP1 !RID OF CR!); R(TMP1 !RID OF LF!)
            LOOP DO
            PUTX(TMP3_R(TMP1))
            IF TMP3=LN.FEED  THEN IF TMP3_R(TMP1)=$* THEN [GO HLPEF2]&
            ELSE PUTX(TMP3)
            END
            END
          TMP2_ARG1
          END
          END


HLPEF1: ERR('SYSTEM ERROR: REQUIRED HELP MESSAGE NOT IN SYS:TAPE.HLP$')
        RETURN

HLPEF2: CLOSE(TMP1<==TEL)
        RETURN

HLPERR: ERR('SYSTEM ERROR: CANNOT OPEN SYS:TAPE.HLP HELP TEXT FILE$')
        RETURN

END HELPER
! PROCEDURE: FIRKIT
! ARGUMENT= TYPE THAT IS WRONG
! WILL TYPE OUT MESSAGE SAYING TO THE EFFECT WHAT IS WRONG
! AND WILL RETURN
!
%FIRKIT(ARG1)

        EIF NOT 1<=ARG1<=4 THEN RETURN
        FIF TYPE=DELIMT AND TERMCH=CARRET THEN RETURN
        DO ARG1 OF 1:4
1:      ERR('STRING ARGUMENT ILLEGAL HERE$'); RETURN
2:      ERR('NUMERIC ARGUMENT ILLEGAL HERE$'); RETURN
3:      ERR('"'); MSG(CWORDS(TOKEN)); MSG('" NOT LEGAL HERE$')
        RETURN
4:      ERR('UNRECOGNIZED DELIMETER: "'); PUT(TERMCH); MSG('" (')
        OUTNUM(TERMCH,8); MSG(')$')
        RETURN

        END

END FIRKIT

! PROCEDURE: DOCMD
! EXECUTES A COMMAND WHOSE COMMAND NUMBER IS THE ARGUMENT
!
%DOCMD(ARG1)


        TERMCH_CARRET
        LOOP DO
          TERMCH_CARRET
          WHILE TYPE_GOCMD(ARG1)=FIRK
        END

        RETURN

END DOCMD

! PROCEDURE: FIGURE
! TAKES A CHARACTER ARGUMENT AND DOES CORRESPONDING CARRIAGE CONTROL
!
! CHARACTERS ARE:
!       :  -  RETURN (DO NOTHING)
!       ;  -  DO A TAB
!       ,  -  TYPE RETURN
!
%FIGURE(ARG1)

        EIF ARG1=$; THEN PUT(9)         !TYPE TAB
        FIF ARG1=$, OR ARG1=CARRET THEN CRLF
        RETURN

END FIGURE

! PROCEDURE: TYPCHR
! GIVEN CHARACTER VALUE, PRINTS NAME OF CHARACTER AND IT'S
! CLOSES APPEARANCE
!
%TYPCHR(ARG1)

        EIF ARG1>S.SIZE THEN [OUTNUM(ARG1,8);RETURN]
        ORIF ARG1<0 THEN [MSG('(NOTHING)');RETURN]
        ELSE [MSG(SWORDS(ARG1));MSG(' (');OUTNUM(ARG1,8);MSG(')');RETURN]

END TYPCHR


! PROCEDURE: OUTNUM
! PRINT THE NUMBER ARGUMENT OUT IN RADIX ARGUMENT TWO
!
%OUTNUM(ARG1,ARG2)

LOCAL STPT(0:MAX.DIG),STR1

        STR1_POINTX(STPT); INSC(ARG1,@STR1,ARG2)
        MSG(@STPT(0))
        IF ARG2=10 THEN PUT(OCT 104)    !TYPE 'D' IF IN DECIMAL MODE
        RETURN

END OUTNUM

! PROCEDURE: INIT
! INITIALIZE ALL VARIABLES
!
%INIT

LOCAL I,A1,A2,A3


! SET UP TEMP FILES

        A1_POINTX(PARNAM); A2_POINTX(TAPNAM)
        I_EXU(OCT 47,OCT 1,OCT 30)      !GET JOB NO.!
        FOR A3_2 TO 0 BY -1 NCHV A1_NCHV A2_((I SHR (A3*3)) BAND OCT 7)+$0
        CSTRING(CHPT("PAR.TAP",-1),A1); CSTRING(CHPT("SAV.TAP",-1),A2)

        JOBREN_ESCAPE           !SET UP REENTER ADDRESS
        SUBPTR_POINTX(SUBUFF)   !INIT SUBSTITUTE STRING STORAGE

        ALTLOC_ALTMOD           !SET UP ESCAPE TRAPPING
        NEWCMD(TEL)                     !INIT COMMAND-FILE LOGIC
        IFILE_OFILE_TEL                 !INITIAL FILE NO.S IS 'TEL'
        FCORE_JOBFF              !ALLOCATE BUFFER SPACE

        FOR I_0 TO MAX.CHR ISUBTAB(I)_ESUBTAB(I)_0      !REINIT SUB TBL

        PARITY_7                !NO PARITY CURRENTLY ENABLED
        LENGTH_10               !LENGTH OF LEADER/TRAILER IN INCHES
        USEFLG_RPTYPE_ECHO_LASLIN_RUNFLG_SLEEPY_ECHAR_ELINE_TITLE_FALSE

        RETURN
END INIT

! PROCEDURE: OK
! TYPES 'OK' IF SLEEPY=0
%OK

        IF SLEEPY=FALSE AND RUNFLG=FALSE THEN PRM('OK$')
        RETURN

END OK

! PROCEDURE: NCHAR
! DOES AN NCHV WITHOUT RUINING PTR
!
%NCHAR(ARG1)

        RETURN NCHV ARG1

END NCHAR

! PROCEDURE: NXLIN
! READS NEXT LINE AND RETURN POINTER TO IT
!
%NXLIN

LOCAL NXERR:

        LOOP DO

        SETRWE(TELFIL,NXERR); INC LASLIN
        RETURN LASINP_STRIP(GETLINE(TELFIL))

NXERR:  OLDCMD
        IF TELFIL=TEL THEN [MSG('$COMMAND FILE EOF:$'); MSG(LASPRM)]
        END

END NXLIN

! PROCEDURE: SEARCH
! ARGUMENT IS FILE NUMBER, WILL READ CHARACTERS FROM TTY AND TRY AND
! MATCH THEM UP IN THE OUTPUT FILE. WILL THEN DO A SCP SO NEW
! INFORMATION WILL BE APPENDED AND RETURN
! TRUE = OK TO PROCEED
! FALSE = YOU BLEW IT
!
%SEARCH(ARG1)

LOCAL SRBUFF(0:SR.SIZE+1),SR.CNT,SR.PNT,S.ER1:,S.ER2:,S.ER3:

        SETTY(ESCAPE)                        ! SET UP 8-LEVEL TTY
        MSG('$READ IN ABOUT 10 INCHES OF TAPE$')
        IONEOU(OCT 21 !XON!)
        SR.CNT_0; SR.PNT_POINTX(SRBUFF)
        WHILE INC SR.CNT<SR.SIZE THEN DO
          NCHV SR.PNT_SERRD(S.ER1) BAND OCT 177
          IF ((SR.SIZE/2)-1)<SR.CNT<((SR.SIZE/2)+1) THEN IONEOU(OCT 23)
          END
        IONEOU(OCT 23 !XOFF!)
        LOOP SERRD(S.ER2)

! HERE WHEN BUFF GOT SOME CHARACTERS
S.ERONEOU(OCT 23 !XOFF!); NCHV SR.PNT _ E.O.LIT
        IF SR.CNT<10 THEN DO
          MSG('$YOU DIDNT READ IN ENOUGH OF THE TAPE!$')
          ENDR
          END ELSE DO
          SR.PNT_CHPT(@SRBUFF(0),0)
          SETCP(ARG1,1 MAX (SIZE(ARG1)-(SR.CNT*10)))

        SETRWE(ARG1,S.ER3)

          LOOP DO

          IF R(ARG1)=CHV SR.PNT THEN DO
          SR.CNT_CP(ARG1)
          WHILE R(ARG1)=NCHV SR.PNT AND CHV SR.PNT#E.O.LIT THEN NULL
          IF CHV SR.PNT=E.O.LIT THEN DO
            MSG('$FOUND MATCH$')
            ERASE(ARG1,CP(ARG1)-1,SIZE(ARG1)+1)
            RETURN TRUE
            END
          SETCP(ARG1,SR.CNT); SR.PNT_CHPT(@SRBUFF(0),0)
          END
          END
          END

! IOCS ERR LABELS
S.ER2:  MSG('$YOU READ IN MORE THAN 20 INCHES OF TAPE!$')
        ENDR

S.ER3:  MSG('$NO MATCH FOUND$'); ENDR

END SEARCH
! PROCEDURE: STRIP
! ARGUMENT IS BYTE POINTER TERMINATED BY E.O.LIT
! WILL REMOVE TRAILING BLANKS
!
%STRIP(ARG1)

LOCAL ARG2

        ARG2_ARG1

        WHILE NCHV ARG1#E.O.LIT THEN NULL
        IF PCHV ARG1#CARRET THEN RETURN ARG2
        WHILE PCHV ARG1=$  THEN NULL
        NCHV ARG1_CAR.RET; NCHV ARG1_E.O.LIT
        RETURN ARG2

END STRIP

! PROCEDURE: ERR
! WILL TYPE OUT LAST LINE AND LINE NO. IF NOT FROM TEL
!
%ERR(ARG1)

        IF TELFIL#TEL THEN DO

        MSG('$IN LINE '); OUTNUM(LASLIN,10); CRLF; OUTSTR(LASINP)
        CRLF; MSG(ARG1); RETURN
        END ELSE [MSG(ARG1);RETURN]

END ERR

! PROCEDURE: HELP
! ARGUMENT IS A HELP NUMBER AND IT WILL TYPE THE HELP 
! MESSAGE ASSOCIATED WITH THE NUMBER
!
%HELP(ARG1)

        MOUTSTR(HELPM(ARG1)); RETURN

END HELP

! PROCEDURE: PRM
! IF TELFIL=TEL (NOT COMMAND-FILE) THEN PRINT PROMPT
!
%PRM(ARG1)

        LASPRM_ARG1                     !SAVE LAST PROMPT LOCATION
        IF TELFIL=TEL THEN MSG(ARG1)
        RETURN

END PRM

! PROCEDURE: OUTSTR
! GIVEN BYTE POINTER, OUTPUT UNTIL AN EOLIT
!
%OUTSTR(ARG1)

        WHILE CHAR_NCHV ARG1 # E.O.LIT THEN TTY_CHAR
        RETURN

END OUTSTR

! PROCEDURE: WSTR
! WRITE STRING ARG1 ON FILE ARG2
!
%WSTR(X,Y)

        WHILE CHAR_NCHV X # E.O.LIT THEN W(Y,CHAR)

        RETURN
END WSTR

! PROCEDURE: NXCHR
! SAME AS 'NCHR' BUT IF ARGUMENT 2 = TRUE THEN
! CONVERTS UPPER TO LOWER CASE
!
%NXCHR(@ARG1,ARG2)

LOCAL I

        TYPE_NCHR(@ARG1)
        IF $A+OCT 40<=CHAR<=$Z+OCT 40 AND ARG2=TRUE THEN CHAR_CHAR-OCT 40
        RETURN TYPE

END NXCHR

! PROCEDURE: NCHR
! SCANS ARGUMENT AND RETURNS AS VALUE CHARACTER TYPE
! SETS CHAR_CHARACTER VALUE
!
%NCHR(@ARG)

        EIF CHAR_NCHV ARG=EOLIT THEN RETURN EMPTY
        ORIF $A<=CHAR<=$Z THEN RETURN STRING
        ORIF $0<=CHAR<=$9 THEN RETURN NUMBER
        ORIF $A+OCT 40<=CHAR<=$Z+OCT 40 THEN RETURN STRING
        ORIF $A-OCT 100<=CHAR<=$Z-OCT 100 THEN RETURN DELIMT
        ELSE RETURN DELIMT

END NCHR

! PROCEDURE: SINC
! STRING TO INTERNAL CONVERSION
! TWO ARGUMENTS: POINTER TO STRING AND RADIX
!
%SINC(@ARG1,ARG2)

LOCAL VAL

        VAL_0
        LOOP DO
          IF CHAR_NCHV ARG1=EOLIT THEN RETURN VAL       !SPEC.CHECK FOR EOLIT
          IF NOT $0<=CHAR<=ARG2+$0 THEN RETURN 0
          VAL_VAL*ARG2+(CHAR-$0)
          WHILE NOT (CHAR=EOLIT OR CHAR=$  OR CHAR=$, OR CHAR=CAR.RET)
          END
        RETURN VAL

END SINC

! PROCEDURE: INSC
! INTERNAL TO STRING CONVERSION
! THREE ARGUMENTS: 1:NUMBER, 2:STRING TO APPEND, 3:RADIX
!
%INSC(ARG1,@ARG2,ARG3)

LOCAL T(MAX.DIG),K,L

        K_ARG1
        LOOP DO
          FOR L_MAX.DIG BY -1
          [K;T(L)]_K DIVMOD ARG3
          WHILE K>0
          END

        FOR L_L TO MAX.DIG NCHV ARG2_T(L)+$0
        NCHV ARG2_EOLIT
        RETURN

END INSC


! PROCEDURE: READ
! ARGUMENT 1:INPUT FILE [NOT CURRENTLY USED], 2:OUTPUT FILE
!
! PARAMETERS FOR READ ARE THE SAME AS THOSE FOR PUNCHING EXCEPT THAT
! THEY ARE REVERSED.
!
! READ WILL CHECK FOR PARITY IF ENABLED AND WILL WRITE PARITY ERRORS
! OUT ONTO FILE DSK:PARITY.TMP
!
! **** CAUTION ****
! THIS ROUTINE AND ALL ASSOCIATED WITH IT DEPEND HIGHLY
! ON THE FACT THE THE OUTPUT FILE NUMBER IS STORED INTO
! THE CELL 'OFILE'
! IF IT IS NOT, YOUDE BETTER LOOK AT ALL THE SUBROUTINES!!!
!
%READ(ARG1,ARG2)

LOCAL ERD:

        IFILE_OPEN(@PARNAM(0),DIRECT+CHARACTER+OUTPUT,0,2)
        WSTR(POINT('PARITY ERRORS WHILE READING FILE '),IFILE)
        WSTR(POINTX(OFILS),IFILE)
        REPEAT 2 W(IFILE,CARRET)

        IF SYMBN=2 AND RPTYPE#FALSE THEN&
        [MSG('BINARY READ CANNOT HAVE SYMBOLIC REPRESENTATION$');&
        RETURN FIRK]

        SUBINI                  ! INIT SUBSTITUTE JUNK
        MAKTMP(0)                       ! MAKE TEMPORARY FILE
        SETTY(ESCAPE)                        ! SET UP 8-LEVEL TTY
        IF USEFLG=FALSE THEN MSG('$TURN ON READER$')
        IONEOU(OCT 21 !XON!)

        EIF SYMBN=1 THEN LOOP [SUBWT(CHAR_SUBRD(ERD) BAND OCT 177,OFILE)]

        ELSE LOOP DO

        CHAR_RDTTY(ERD)         ! READ A CHARACTER

        DO PARITY OF OFF:PACKD

ODD:    IF CHAR BAND OCT 200 # MAKPAR(CHAR,1) SHL 7 THEN PARERR(CHAR)
        CHAR BAND_ OCT 177
EVEN:   IF CHAR BAND OCT 200 # MAKPAR(CHAR,0) SHL 7 THEN PARERR(CHAR)
        CHAR BAND_ OCT 177
OFF:    CHAR BAND_ OCT 177

        END

        SUBWT(CHAR,OFILE)        ! WRITE OUT

        END

! END OF READING FILE
! LABEL DUE TO END-OF-FILE BRANCH
ERD:    SUBCLN(0,OFILE); CLOSE(OFILE<==TEL); IONEOU(OCT 23 !XOFF!)
        CLOSE(IFILE<==TEL)
        IF PARTY#0 THEN DO

          MSG('$THERE WERE '); OUTNUM(PARTY,10)
          MSG(' PARITY ERROR(S) WHILE READING YOUR TAPE')
          MSG('$PLEASE READ THE FILE ')
          MSG(@PARNAM(0)); MSG(' FOR DETAILS$')
        END ELSE DELETE(@PARNAM(0))
        DELETE(@TAPNAM(0))
        RETURN

END READ

! PROCEDURE: OUTTIT
! STRING ARGUMENT, PUNCHES TITLE
!
%OUTTIT(ARG1)

LOCAL VAL1

        WHILE CHAR_NCHV ARG1#E.O.LIT THEN DO
          VAL1_TWORDS(CHAR)
          WHILE CHAR_NCHV VAL1#TCHR THEN OUTIMG(CHAR)
          OUTIMG(0); OUTIMG(0)          !SPACE THE LETTERS
          END

        RETURN

END OUTTIT

! PROCEDURE: CONFMP
! WILL TYPE CONFIRMATION MESSAGE, WAIT FOR C.R., AND SLEEP FOR A WHILST
!
%CONFMP

        EIF SLEEPY=FALSE THEN DO
        MSG('$TYPE CARRIAGE RETURN OR LINE FEED, TURN PUNCH ON')
        MSG('$WHEN FINISHED, TURN PUNCH OFF, TYPE CARRIAGE RETURN$$')
        END
        ELSE [MSG('$$TURN PUNCH ON$$')]
        WHILE NOT (LASFMP_GET=LNFEED OR LASFMP=CARRET) THEN NULL
        CLIBUF
        SLEEP(2)
        RETURN

END CONFMP

! PROCEDURE: LEDTRL
! WILL PRINT (ARG1) INCHES OF BLANKS (NULLS) USING OUTIMG
!
%LEDTRL(ARG1)

        REPEAT ARG1*10 OUTIMG(0)

        RETURN

END LEDTRL

! PROCEDURE: PUNCH
! PUNCHES PAPER TAPE
!
! PARAMETERS FOR PUNCH ARE:
!  IF SYMBN=1 THEN SYMBOLIC PUNCH:
!    READ FROM FILE IS 7-BIT CHARACTER ORIENTED FILE
!    PARITY=DATA:  ALWAYS PUNCH 8TH BIT ON OUTPUT
!    PARITY=EVEN:  PUNCH EVEN PARITY
!    PARITY=ODD:   PUNCH ODD PARITY
!    PARITY=NONE:  PUNCH NO PARITY
!
!  IF SYMBN=2 THEN BINARY PUNCH:
!    PARITY=DATA:  EACH WORD CONTAINS ONE CHARACTER WHICH IS 8-BITS OF
!                  DATA WHICH WILL BE RIGHT-JUSTIFIED (AND OCT 177)
!    PARITY=EVEN:  EACH WORD CONTAINS SIX 6-BIT DATA ITEMS WHICH
!                  WILL BE PUNCHED WITH EVEN PARITY AND 7TH BIT OFF
!    PARITY=ODD:   SAME AS EVEN BUT ODD PARITY PUNCHED
!    PARITY=NONE:  SAME AS EVEN BUT NO PARITY PUNCHED (BITS 7 & 8 OFF)
!
%PUNCH(ARG1,ARG2)

LOCAL EPUN:

        IF SYMBN=2 AND PARITY=OFF THEN DO
          ALWP8T_-1
          LOOP DO
          MSG('$ALWAYS PUNCH 8-TH LEVEL? '); STR_NXLIN
          EIF TYPE_CTOKEN(@STR,YESNO,RESIN)#RESWRD THEN NULL
          ORIF TOKEN=12 THEN ALWP8T_FALSE
          ORIF TOKEN=11 THEN ALWP8T_TRUE
          ELSE MSG('$ANSWER YES OR NO:')
          WHILE ALWP8T=-1
          END
          END
        IF SYMBN=2 AND RPTYPE#FALSE THEN&
        [MSG('BINARY PUNCH CANNOT HAVE SYMBOLIC REPRESENTATION$');&
        RETURN FIRK]

        MAKTMP(1)               ! MAKE TEMPORARY FILE
        IF USEFLG=FALSE THEN CONFMP ELSE OPNPTP(ESCAPE)

! IF LASFMP=CARRET THEN GIVE LEADER SPEIL ELSE DONT
        IF LASFMP=CARRET THEN DO

        LEDTRL(4)
        OUTTIT(POINT(' File=')); OUTTIT(POINTX(IFILS))
        OUTTIT(POINT('  Type='))
        IF SYMBN=1 THEN OUTTIT(POINT('SYM'))&
        ELSE OUTTIT(POINT('BIN'))
        OUTTIT(POINT('  Parity=')); OUTTIT(POINT(CWORDS(PARITY)))

        END

! NOW OUTPUT TIEL (IF THERE) AND GO
        IF TITLE=TRUE THEN [LEDTRL(4);OUTTIT(POINTX(TITBUF))]
        LEDTRL(LENGTH)          !OUTPUT LEADER
        REPEAT 3 OUTIMG(OCT 377)        !OUTPUT THREE 'START-UP' RUBOUTS

! NOW PUNCH FILE

        SUBINI                  !INIT SUBSTITUTION STUFF
        SETRWE(ARG1,EPUN)              !IOCS END OF FILE

        EIF SYMBN=1 THEN LOOP [OUCH(CHAR_LEV7(ARG1) BAND OCT 177)]

        ELSE LOOP DO

        CHAR_LEV8(ARG1)         ! GET CHARACTER

        DO PARITY OF OFF:PACKD

DATA:PACKD: CHAR BAND_OCT 377           !FULL CHARACTER
ODD:    CHAR BOR_(MAKPAR(CHAR,1) SHL 7)
EVEN:   CHAR BOR_(MAKPAR(CHAR,0) SHL 7)
OFF:    CHAR BAND_OCT 177
        IF ALWP8T=TRUE THEN CHAR BOR_OCT 200    !SET SIGN BIT

        END
        OUTIMG(CHAR)
        END

! END OF PUNCHING FILE
! LABEL DUE TO IOCS END OF FILE BRANCH

EPUN:   REPEAT 3 OUTIMG(OCT 377)        !OUTPUT THREE 'CLOSING-UP' RUBOUTS
        LEDTRL(LENGTH)          !OUTOUT TRAILER
        IF USEFLG=FALSE THEN DO
        WHILE CHAR_GET#CARRET THEN NULL
        CLIBUF
        END ELSE CLSPTP
        CLOSE(IFILE<==TEL)
        CLOSE(OFILE<==TEL)
        DELETE(@TAPNAM(0),0)
        RETURN

END PUNCH

! PROCEDURE: MAKTMP
! MAKES TEMPORARY FILE CONTAINS USEFUL(???) INFORMATION
!
%MAKTMP(ARG1)

LOCAL TMP1

        TMP1_OPEN(@TAPNAM(0),OUTPUT+CHARACTER+SEQUEN,0,2)
        WSTR(POINT('EDITING '),TMP1)
        EIF ECHAR+ELINE=0 THEN [WSTR(POINT('NO'),TMP1)]
        ELSE DO
          IF ECHAR#0 THEN [WSTR(POINT(' CHARACTER="'),TMP1);&
          WX(TMP1,ECHAR); W(TMP1,$")]
          IF ELINE#0 THEN [WSTR(POINT(' LINE="'),TMP1);&
          WX(TMP1,ELINE); W(TMP1,$")]
        END
        W(TMP1,CARRET)
        IF ECHO=FALSE THEN [WSTR(POINT('ECHO OFF'),TMP1)]
        IF ECHO=TRUE THEN [WSTR(POINT('ECHO ON'),TMP1)]
        W(TMP1,CARRET)
        WSTR(POINT('PARITY '),TMP1); WSTR(POINT(CWORDS(PARITY)),TMP1)
        W(TMP1,CARRET); WSTR(POINT('REPRESENTATION '),TMP1)
        WSTR(POINT(IF RPTYPE=FALSE THEN 'OFF' ELSE CWORDS(RPTYPE)),TMP1)
        W(TMP1,CARRET)
        EIF ARG1=1 AND SYMBN=1 THEN WSTR(POINT('SYMPUNCH '),TMP1)
        ORIF ARG1=1 AND SYMBN=2 THEN WSTR(POINT('BINPUNCH '),TMP1)
        ORIF ARG1=0 AND SYMBN=1 THEN WSTR(POINT('SYMREAD '),TMP1)
        ELSE WSTR(POINT('BINREAD '),TMP1)
        IF ARG1=1 THEN WSTR(POINTX(IFILS),TMP1) ELSE WSTR(POINTX(OFILS),TMP1)
        W(TMP1,CARRET); CLOSE(TMP1)

        RETURN

END MAKTMP

! PROCEDURE: MAKPAR
! ARG1 = CHARACTER TO RETURN PARITY BIT ON
! ARG2 = 1 IF EVEN PARITY WANTED ELSE ARG2 = 0 FOR ODD PARITY
! RETURNS THE VALUE OF THE PARITY BIT (1 OR 0) RIGHT-JUSTIFIED
!
%MAKPAR(ARG1,ARG2)

LOCAL PARBIT

        ARG1 BAND_ OCT 177
        IF ARG2=1 THEN [PARBIT_0] ELSE [PARBIT_1]       !INIT PARITY SETTING

        WHILE ARG1#0 THEN [INC PARBIT;ARG1 BAND_(ARG1-1)]

        RETURN PARBIT BAND 1

END MAKPAR

! PROCEDURE: SUBPUT
! ARGUMENT IS THE BYTE POINTER TO STORE FROM
! WILL RETURN LOCATION IN SUBSTITUTE STORAGE OF THE
! NEW STRING
!
%SUBPUT(ARG1)

LOCAL STR1

        STR1_SUBPTR             !SAVE CURRENT POINTER
        WHILE NCHV SUBPTR_NCHV ARG1#E.O.LIT THEN NULL
        NCHV SUBPTR_E.O.LIT
        IF SUBPTR BAND OCT 777777 > @SUBUFF(0)+S.BUFF THEN&
        [MSG('$SUBSTITUTE STORAGE EXCEEDED$'); HALT]
        RETURN STR1

END SUBPUT


%SUBPRC

LOCAL SUBPT,SUBFG,SUBD,SUBGF,CNT,IMGSTR,IMGBUF(0:(NO.CHAR/CHARSPERWORD)+1)
LOCAL PEBUF(0:PE.MAX),PECNT,CRAP.CNT,DISLIN,DISCHR,SHCNT,ACHAR,CNTRA,CNTRB,SUBWPT

! PROCEDURE: SUBINI
! INITS SUBSTITUTE OUTPUT ROUTINE "SUBCR" AND "LEV8"
!
%SUBINI

        WINT                    ! INIT WRITE-OUT ROUTINE
        CRAP.CNT_NO.CRAPS               !INITIALIZE CRASH PROTECTION
        SUBGF_6
        SUBD_0
        SUBWPT_BYPT(@SUBD,-1,6)
        DISLIN_DISCHR_SUBFG_PARTY_SUBPT_FALSE       !RESET FLAGS
        RETURN

END SUBINI

! PROCEDURE: WINT
! INITIALIZE WRITE-OUT ROUTINE
!
%WINT

        IMGSTR_POINTX(IMGBUF); CNT_PECNT_0
        NCHV IMGSTR_E.O.LIT
        RETURN

END WINT

! PROCEDURE: SUBWT
! ARGUMENT 1 IS CHARACTER TO BE WRITTEN
! ARGUMENT 2 IF WILE TO BE USED BY 'WX'
! WILL WRITE CHARACTER OUT PROPERLY
!
%SUBWT(ARG1,ARG2)

        INC DISCHR              !DIS IS A CHARACTER

        IF SYMBN=1 THEN DO

          EIF ARG1=0 OR ARG1=OCT 177 OR ARG1=OCT 377 THEN NULL
          ORIF ARG1=ECHAR THEN DO
            DEC CNT
            IF PCHV IMGSTR=E.O.LIT THEN [NCHV IMGSTR_E.O.LIT; INC CNT]
            END
          ORIF ARG1=ELINE THEN WINT
          ELSE [NCHV IMGSTR_ARG1; INC CNT]
  
          IF ARG1=LNFEED OR ARG1=CARRET OR CNT>NO.CHAR THEN NCHV IMGSTR_E.O.LIT&
          ELSE RETURN
        INC DISLIN; DISCHR_0
          SWSTR(CHPT(@IMGBUF(0),0),OFILE)
          PAROUT(ARG2)
          WINT
          RETURN
        END

        DO PARITY OF OFF:PACKD

DATA:PACKD: WX(OFILE,ARG1 BAND OCT 377); CRASHP
OFF:EVEN:ODD: IF SUBGF=FALSE THEN DO

        WX(OFILE,SUBD); CRASHP
        SUBGF_6; SUBD_0; SUBWPT_BYPT(@SUBD,-1,6)
        END
        DEC SUBGF; RETURN NCHV SUBWPT_ARG1 BAND OCT 77
        END

        RETURN

END SUBWT

! PROCEDURE: SWSTR
! WRITE STRING ARG1 ONTO FILE ARG2
! SAME AS 'WSTR' BUT USES 'SWOUT' INSTEAD OF IOCS 'W'
!
%SWSTR(ARG1,ARG2)

        WHILE CHAR_NCHV ARG1 # E.O.LIT THEN SWOUT(CHAR,OFILE)

        RETURN

END SWSTR

! PROCEDURE: SWOUT
! ARG1: CHARACTER TO WRITE, ARG2: FILE NO. TO WRITE
! IF SYMBOLIC REP. INT OR BOTH WILL WRITE SYMBOLICALLY, ELSE
! WILL JUST WRITE THE CHARACTER OUT USING IOCS 'WX'
!
%SWOUT(ARG1,OFILE)

        IF SYMBN=1 AND (RPTYPE=3 OR RPTYPE=5) THEN DO
          STR_POINTX(TOKBUF); INSC(ARG1,@STR,8); STR_POINTX(TOKBUF)
          WHILE CHAR_NCHV STR#E.O.LIT THEN [W(OFILE,CHAR);CRASHP]
          W(OFILE,CARRET); CRASHP
          RETURN
        END ELSE DO
          WX(OFILE,ARG1); CRASHP
          RETURN
        END

END SWOUT

! PROCEDURE: SUBCLN
! CLEANS UP AFTER READING IS DONE
! ARGUMENT 2 IS OUTPUT FILE, 1 IS DUMMY
!
%SUBCLN(ARG1,ARG2)

        IF SYMBN=1 THEN DO
          IF CNT=0 THEN RETURN
          NCHV IMGSTR_E.O.LIT
          SWSTR(CHPT(@IMGBUF(0),0),ARG2)
          PAROUT(ARG2)
          RETURN
        END

        IF SYMBN=2 AND PARITY#10 AND SUBGF#6 THEN [WX(ARG2,SUBD);CRASHP]

        RETURN

END SUBCLN

! PROCEDURE: SUBRED
! ARGUMENT 1 IS END-OF-FILE BRANCH LOCATION
! WILL READ ONE CHARACTER VIA 'RDTTY' SUBROUTINE AND WILL
! EVEN DO SUBSTITUTION
! MUST BE PROCEDED INITIALLY BY 'SUBINI' CALL AND 'SETTY' CALL
!
%SUBRED(ERROR:)

        LOOP DO
        IF SUBFG=TRUE AND CHAR_NCHV SUBPT#E.O.LIT THEN RETURN CHAR
        SUBFG_FALSE; CHAR_RDTTY(ERROR)
        IF SUBPT_ESUBTAB(CHAR BAND OCT 177)=0 THEN DO

          DO PARITY OF OFF:PACKD

DATA:PACKD: IF CHAR BAND OCT 200 = 0 THEN PARERR(CHAR)
ODD:    IF CHAR BAND OCT 200 # MAKPAR(CHAR,1) SHL 7 THEN PARERR(CHAR)
EVEN:   IF CHAR BAND OCT 200 # MAKPAR(CHAR,0) SHL 7 THEN PARERR(CHAR)

        END
          RETURN CHAR BAND OCT 177
          END
        SUBFG_TRUE
        END

END SUBRED

! PROCEDURE: SUBRD
! RETURN CHARACTER VALUE
! HANDLES SYM. REPRESENTATION FROM TELETYPE
! ARG1: EOF BRANCH
!
%SUBRD(ERROR:)

        EIF SYMBN=1 AND (RPTYPE=4 OR RPTYPE=5) THEN DO
          STR_POINTX(TOKBUF)
          WHILE CHAR_SUBRED(ERROR)#CARRET THEN IF&
          (CHAR#LNFEED AND CHAR#0 AND CHAR#OCT 177) THEN NCHV STR_CHAR
          NCHV STR_CARRET; NCHV STR_E.O.LIT; STR_POINTX(TOKBUF)
          STOKEN(@STR,0,0)
          RETURN TOKEN BAND OCT 177
          END
        ELSE RETURN SUBRED(ERROR)

END SUBRD

! PROCEDURE: SERRD
! ARGUMENT IS ERROR LABEL..READS CHARACTER FROM FILE AND
! IGNOREDS NULL AND EOLIT CHARACTERS
!
%SERRD(ERROR:)

        WHILE CHAR_SUBRD(ERROR)=0 OR CHAR=OCT 177 OR CHAR=OCT 377 THEN NULL
        RETURN CHAR

END SERRD

! PROCEDURE: PAROUT
! WRITES BAD PAR INFO OUT
!
%PAROUT(ARG1)

        IF SYMBN=2 THEN RETURN
        IF PECNT=0 THEN RETURN
        WSTR(POINT('IN LINE '),IFILE)
        STR_POINTX(TOKBUF); INSC(DISLIN,@STR,10); STR_POINTX(TOKBUF)
        WHILE ACHAR_NCHV STR#E.O.LIT THEN W(IFILE,ACHAR)
        W(IFILE,CARRET)
        WSTR(CHPT(@IMGBUF(0),0),IFILE)
        W(IFILE,CARRET)
        FOR CNTRA_1 TO PEBUF(PECNT) BY 1 DO
          ACHAR_0
          FOR CNTRB_1 TO PECNT BY 1 [IF CNTRA=PEBUF(CNTRB)&
          AND PEBUF(CNTRB)#0 THEN ACHAR_1]
          IF ACHAR=0 THEN W(IFILE,$ ) ELSE W(IFILE,$^)
          END
        REPEAT 2 W(IFILE,CARRET)
        RETURN

END PAROUT

! PROCEDURE: PARERR
! WILL WRITE OUT ON TEMP FILE 'PARITY ERROR AT POSITION XXX LINE XXX',
! 'CHARACTER CAUSING BAD PARITY 'X' OCTAL XXX BINARY XXXXXX'
!
%PARERR(ARG1)

        IF NOT (OCT 177#CHAR BAND OCT 177#0) THEN RETURN ELSE INC PARTY

        IF SYMBN=2 THEN DO

          WSTR(POINT('PARERR: CHAR OCT '),IFILE)
          FOR SHCNT_2 TO 0 BY -1&
          W(IFILE,(ARG1 SHR (SHCNT*3) BAND OCT 7)+$0)
          WSTR(POINT(' BINARY '),IFILE)
          FOR SHCNT_7 TO 0 BY -1&
          W(IFILE,(ARG1 SHR SHCNT BAND OCT 1)+$0)
          WSTR(POINT('; CHAR/FRAME POS. '),IFILE)
          STR_POINTX(TOKBUF); INSC(DISCHR,@STR,10); STR_POINTX(TOKBUF)
          WHILE ACHAR_NCHV STR#E.O.LIT THEN W(IFILE,ACHAR)
          WSTR(POINT(' WORD '),IFILE)
          STR_POINTX(TOKBUF)
          IF SYMBN=10 THEN INSC(DISCHR,@STR,10) ELSE INSC(DISCHR/6,@STR,10)
          STR_POINTX(TOKBUF)
          WHILE ACHAR_NCHV STR#E.O.LIT THEN W(IFILE,ACHAR)
          W(IFILE,CARRET)
          RETURN
          END

        IF INC PECNT<=PE.MAX THEN PEBUF(PECNT)_CNT+1 ELSE DEC PECNT
        RETURN

END PARERR

! PROCEDURE: CRASHP
! DOES CRASH PROTECTION
! TAKES FILE NAME IN 'OFILS' AND WILL CLOSE AND OPEN IT AGAIN
! IF THE TENTH BUFFER IS WRITTEN OUT.
! MUST BE CALLED IMMEDIATELY AFTER A 'W' OR 'WX' CALL
!
%CRASHP

        IF ECNT(OFILE)#0 THEN RETURN
        IF DEC CRAP.CNT#0 THEN RETURN   !DECREMENT BUFFER COUNT
        CLOSE(OFILE)                     !CLOSE THE FILE
        IF SYMBN=1 THEN CHAR_CHARACTER ELSE CHAR_(IF PARITY=PACKD THEN PACK ELSE WORD)
        OFILE_OPEN(@OFILS(0),DIRECT+CHAR+UPDATE,0,2)
        SETCP(OFILE,SIZE(OFILE))
        CRAP.CNT_NO.CRAPS
        RETURN

END CRASHP

! PROCEDURE: SUBCR
! GIVEN FILE NO. IN 'A' WILL RETURN CHARACTERS TO BE PUNCHED
! EVEN DOES SUBSTITUTION !!!
!
%SUBCR(ARG1)

        LOOP DO
        IF SUBFG=TRUE AND CHAR_NCHV SUBPT#E.O.LIT THEN RETURN CHAR
        SUBFG_FALSE; CHAR_R(ARG1)
        IF SUBPT_ISUBTAB(CHAR BAND OCT 177)=0 THEN RETURN CHAR
        SUBFG_TRUE
        END

END SUBCR

! PROCEDURE: LEV7
! WILL READ A 7 LEVEL FILE AND DO THE APPROPRIATE 'SYMBOLIC' READING
! IF NECESSARY.
!
%LEV7(ARG1)

        EIF SYMBN=1 AND (RPTYPE=3 OR RPTYPE=5) THEN DO
          STR_POINTX(TOKBUF)            !SET LINE POINTERS
          WHILE CHAR_SUBCR(ARG1)#CARRET THEN IF CHAR#LNFEED&
          THEN NCHV STR_CHAR
          NCHV STR_CARRET; NCHV STR_E.O.LIT; STR_POINTX(TOKBUF)
          STOKEN(@STR,0,0)
          RETURN TOKEN BAND OCT 177
          END
        ELSE RETURN SUBCR(ARG1)

END LEV7

! PROCEDURE: OUCH
! WILL PUT EITHER CHARACTER OR NUMBER OUT DURING PUNCH IN 8-LEVEL
! FORMAT
!
%OUCH(ARG1)

        EIF SYMBN=1 AND (RPTYPE=4 OR RPTYPE=5) THEN DO
          STR_POINTX(TOKBUF); INSC(ARG1,@STR,8); STR_POINTX(TOKBUF)
          WHILE CHAR_NCHV STR#E.O.LIT THEN OUCS(CHAR)
          OUCS(CARRET); OUCS(LNFEED)
          RETURN
          END
        ELSE RETURN OUCS(ARG1)

END OUCH

! PROCEDURE: OUCS
! ARGUMENT IS CHARACTER WILL PUNCH SYMBOLICALLY
! ACCORDIND TO DEFINITION OF "PARITY"
!
%OUCS(ARG1)

        DO PARITY OF OFF:PACKD

DATA:PACKD: ARG1 BOR_OCT 200
ODD:    ARG1 BOR_(MAKPAR(ARG1,1) SHL 7)
EVEN:   ARG1 BOR_(MAKPAR(ARG1,0) SHL 7)

        END

        OUTIMG(ARG1)

        RETURN

END OUCS

! PROCEDURE: LEV8
! DEPENDING ON DEFINITION OF 'PARITY' WILL DECIDE TO RETURN
! SIX 6-BIT BYTES PER WORD READ OR ONE 8-BIT BYTE PER WORD READ
! WILL BE APPROPRIATELY BANDED FOR YOUR CONVINIENCE.
!
%LEV8(ARG1)

        DO PARITY OF OFF:PACKD

DATA:PACKD: RETURN R(ARG1) BAND OCT 377
OFF:EVEN:ODD: IF SUBFG=FALSE THEN [SUBFG_6;SUBD_R(ARG1);SUBPT_BYPT(@SUBD,-1,6)]
        DEC SUBFG; RETURN NBYV SUBPT BAND OCT 77        ! 6 BIT-BYTE

        END
        RETURN

END LEV8

END SUBPRC

! PROCEDURE: CNTER(ARG1)
! DECIDES ON SUBSTITUTE WRITE-OUT
! ARGUMENT 1 IS STRING TO LOOK AT
!
%CNTER(ARG1)

LOCAL I

        I_0

        WHILE NCHV ARG1 # E.O.LIT THEN INC I

        RETURN I

END CNTER

! PROCEDURE: SUBOUT
! ARGUMENTS: 1:STRING TO WRITE, 2:OUTPUT FILE NUMBER
! WRITES IT OUT THE BEST WAY IT KNOWS HOW
! RETURNS "0" IF ONE ARGUMENT OUTPUT,
! ELSE RETURNS "1" IF MUILT-ELEMENT ARGUMENT OUTPUT
!
%SUBOUT(ARG2,ARG1)

LOCAL QUOTFL,COMAFL,STPT(0:MAX.DIG),STR1

        QUOTFL_COMAFL_FALSE     !INIT FLAGS
        WHILE TYPE_NCHR(@ARG1)#EMPTY THEN DO
          EIF TYPE=DELIMT AND CHAR#$   THEN DO
           IF QUOTFL=TRUE THEN [W(ARG2,$");INC COMAFL;QUOTFL_FALSE]
           IF COMAFL#FALSE THEN [W(ARG2,$,)]
           EIF CHAR<S.SIZE THEN DO
            STR1_POINT(SWORDS(CHAR))
            WHILE CHAR_NCHV STR1#E.O.LIT THEN W(ARG2,CHAR)
            END
           ELSE DO
            STR1_POINTX(STPT); INSC(CHAR,@STR1,8); NCHV STR1_E.O.LIT
            STR1_POINTX(STPT)
            WHILE CHAR_NCHV STR1#E.O.LIT THEN W(ARG2,CHAR)
            W(ARG2,$B)
            END
        END
          ELSE DO
            IF QUOTFL=FALSE THEN DO
             IF COMAFL#FALSE THEN W(ARG2,$,)
             W(ARG2,$");QUOTFL_TRUE
            END
            W(ARG2,CHAR)
            END
        INC COMAFL
        END

        IF QUOTFL=TRUE THEN [W(ARG2,$")]        !TERMINATE QUOTE
        RETURN COMAFL

END SUBOUT
! PROCEDURE: SUBGET
! RETURNS ONE STRING VALUE FOR SUBSTITUTE COMMAND
! THE WORD "NOTHING" WILL CAUSE A 0 TO BE RETURNED
! TWO ARGUMENTS: 1:STRING TO GET FROM (UPDATES IT), 2:=1 IF FIRST
! CALL WHICH "ARG1,ARG2" IS VALID ALONE AS TWO STRINGS, ELSE =0
!
%SUBGET(@ARG1,ARG2)

LOCAL STR1,STR2,STPT1(0:15),STPT2(0:15),CNTR,AHOLD,BHOLD,CHOLD,DHOLD

        EIF ARG2=1 THEN STR1_STR2_POINTX(STPT1)
        ELSE STR1_STR2_POINTX(STPT2)
        CNTR_0

        LOOP DO

          AHOLD_ARG1; BHOLD_TERMCH; CHOLD_TYPE; DHOLD_TOKEN; TYPE_STOKEN(@ARG1,0,0); INC CNTR
          EIF TERMCH=CARRET AND CNTR=2 AND ARG2=1 THEN&
            [ARG1_AHOLD; TERMCH_BHOLD; TYPE_CHOLD; TOKEN_DHOLD; NCHV STR1_E.O.LIT; RETURN STR2]

          ORIF TYPE=STRING THEN COPYST(POINTX(TOKBUF),@STR1)
          ORIF TYPE=FIRK THEN RETURN FIRK
          ELSE NCHV STR1_TOKEN

        WHILE TERMCH=$, AND TYPE#EMPTY
        END

        NCHV STR1_E.O.LIT; RETURN STR2
END SUBGET

! PROCEDURE: FOO
! THIS IS THE MAIN PROCEDURE.. SCANS INPUT LINE AND PERFORMS ONE
! TASK AND EXITS.  THIS SHOULD BE CALLED BY AN INFINITE LOOP.
! ARGUMENTS: NONE
!
%FOO

        IF IFILE#TEL THEN CLOSE(IFILE<==TEL)
        IF OFILE#TEL THEN CLOSE(OFILE<==TEL)
        PRM('$:')
        STR_NXLIN

        EIF TYPE_CTOKEN(@STR,COMNDS,RESIN)=DELIMT AND (CHAR=CAR.RET OR CHAR=LN.FEED) THEN RETURN
        ORIF TYPE=FIRK OR TYPE=EMPTY THEN RETURN
        FIF TYPE#RESWRD THEN [ERR('COMMAND REQUIRED$');RETURN]

        GOCMD(TOKEN); RETURN

END FOO

! PROCEDURE: GOCMD
! TAKES AS ARGUMENT A COMMAND NUMBER TO BE EXECUTED
!
! IT EXPECTS THAT IT HAS JUST BEEN TAKEN BY THE 'CTOKEN' CALL
!
%GOCMD(ARG1)

GLOBAL TABLE TELSTR(0:0) ["TELETYPE"]

LOCAL VAL,SAVRET,OPNER1:,VAL1,VAL2,SAVSTR,S1,S2,S3,S4,COMAFL,E25:,E48:,ER46:

        DO ARG1 OF 0:C.SIZE

54:     HELPER(POINT("CAPABILITIES")); ENDR

53:     HELPER(POINT("INSTRUCTIONS")); ENDR


50:     IF TERMCH=CARRET THEN [PRM('$PDP10 OR TELETYPE: ');STR_NXLIN]
        IF TYPE_CTOKEN(@STR,USETB,RESIN)#RESWRD THEN GO UNXERR
        IF MORE THEN ENDR
        EIF TOKEN=51 THEN USEFLG_FALSE
        ORIF TOKEN=52 THEN USEFLG_TRUE
        ELSE GO UNXERR
        OK
        ENDR

48:     IF TERMCH=CARRET THEN&
        [PRM('$WHAT WAS YOUR JOB I.D. NUMBER? ');STR_NXLIN]
        IF TYPE_CTOKEN(@STR,0,NUMIN)#NUMBER THEN GO UNXERR
        STR_POINTX(OFILS)
        FOR S2_2 TO 0 BY -1 NCHV STR_((TOKEN SHR (S2*3)) BAND OCT 7)+$0
        CSTRING(CHPT("SAV.TAP",-1),STR); STR_POINTX(OFILS)
        NEWCMD(OPEN(@OFILS(0),DIRECT+CHARACTER+INPUT,E48,2))
        LASLIN_0
        ENDR

! ERROR DURING OPEN OF TEMPORARY FILE
E48:    MSG('CANNOT RECOVER CRASH PROTECTION FILE FOR THAT JOB ID$')
        RETURN FIRK

47:     MSG('CANNOT RECOVER FROM CRASH DURING A BINARY READ$')
        ENDR

46:     SYMBN_1
        CSTRING(STR,POINTX(TOKBUF))
        SETOU
        OLDCMD                  !CLOSE CUR.FILE AND OPEN OLD
        IFILE_TEL
        IF SYMBN=1 THEN CHAR_CHARACTER ELSE CHAR_(IF PARITY=PACKD THEN PACK ELSE WORD)
        OFILE_OPEN(@TOKEN,DIRECT+OLD+CHAR+UPDATE,OPNER1,2)

        IF SIZE(OFILE)<OCT 2000 THEN DO
          MSG('ONLY '); OUTNUM(SIZE(OFILE),8)
          IF SYMBN=1 THEN MSG(' CHARACTERS') ELSE MSG(' WORDS')
          MSG(' WERE READ INTO THE OUTPUT FILE$IT WOULD BE FASTER TO RE-READ THE TAPE$')
          ENDR
          END


! TYPE OUT SOME OF THE FILE
        SETRWE(OFILE,ER46)
        SETCP(OFILE,SIZE(OFILE)-NO.SPLI)
        MSG('$THE LAST '); OUTNUM(NO.SPLI,8)
        MSG(' CHARACTERS ON THE FILE ARE:$$"')
        LOOP TTY_R(OFILE)

ER46:   MSG('"$$')

! OK -- READ IN THE STUFF
        WHILE SEARCH(OFILE)#TRUE THEN LOOP DO
          MSG('$TRY AGAIN? '); STR_NXLIN
          IF TYPE_CTOKEN(@STR,YESNO,RESIN)=RESWRD AND TOKEN=12 THEN ENDR
          IF NOT (TYPE=RESWRD AND TOKEN=11) THEN &
          MSG('$ANSWER YES OR NO:')
          WHILE NOT (TYPE=RESWRD AND TOKEN=11)
          END
        READ(IFILE,OFILE)
        MSG('$SPLICE COMPLETED.$')
        ENDR

44:45:  MSG('CANNOT RECOVER FROM CRASH DURING PUNCH$')
        OLDCMD; ENDR

43:     MSG('$FOR COMPLETE LIST OF COMMANDS, TYPE "HELP"$')
        MSG('$COMMANDS ARE:$$')
        MSG('RUN$[B]PUNCH$[B]READ$HUSH/TALK$PARITY$EDITING$SUBSTITUTE$')
        MSG('SAVE/LOAD$RESET$LIST$TITLE$LENGTH$VERSION$QUIT$CREDITS$')
        MSG('CHARGES$HELP$ECHO$REPRESENTATION$SUMMARY$SPLICE$USE$')
        MSG('$TYPING A ? AS AN ARGUMENT TO A COMMAND WILL CAUSE A LIST')
        MSG('$OF VALID ARGUMENT TYPES TO BE GIVEN$')
        ENDR

42:     IF TERMCH=CARRET THEN [PRM('$SYMBOLIC REPRESENTATION? ');&
        STR_NXLIN]

        EIF TYPE_CTOKEN(@STR,REPIT,RESIN)#RESWRD THEN GO UNXERR
        ORIF MORE THEN ENDR
        FIF TOKEN<3 OR TOKEN>7 THEN GO UNXERR
        RPTYPE_(IF TOKEN>5 THEN FALSE ELSE TOKEN); OK; ENDR


41:     IF TERMCH=CARRET THEN [PRM('$ECHO: ');STR_NXLIN]
        EIF TYPE_CTOKEN(@STR,ECHIT,RESIN)#RESWRD THEN GO UNXERR
        ORIF MORE THEN ENDR
        ORIF TOKEN=0 OR TOKEN=11 THEN ECHO_TRUE
        ORIF TOKEN=7 OR TOKEN=12 THEN ECHO_FALSE
        ELSE GO UNXERR
        OK; ENDR

40:     WHILE EMPTY#TYPE_STOKEN(@STR,0,0)#FIRK THEN DO
          EIF TYPE=NUMBER THEN DO
            EIF TERMCH=$+ THEN [TYPCHR(TOKEN);FIGURE(TYPE_STOKEN(@STR,0,0))]
            ELSE [OUTNUM(TOKEN,10);FIGURE(TERMCH)]
            END
          ORIF TYPE=STRING THEN [MSG(@TOKEN);FIGURE(TERMCH)]
          ORIF TYPE=DELIMT THEN FIGURE(TERMCH)
          FIF TYPE=RESWRD THEN [TYPCHR(TOKEN);FIGURE(TERMCH)]
          END
        ENDR

39:     IF NOT MORE THEN HELPER(POINT("HELP"))   !GIVE HELP ERROR MESSAGE
        ENDR            !ALL DONE

38:     MSG('AND FOO TO YOU TO!$'); ENDR

37:     IF NOT MORE THEN HELPER(POINT("CHARGES"))
        ENDR

36:     IF NOT MORE THEN HELPER(POINT("CREDITS"))
        ENDR

35:     IF MORE THEN ENDR
        EXIT

34:     IF MORE THEN ENDR
        MSG('VERSION '); OUTNUM(JOBVER SHR 18 BAND OCT 177,8); MSG('.')
        IF JOBVER BAND OCT 777 <= OCT 7 THEN MSG('0')
        OUTNUM(JOBVER BAND OCT 777,8); MSG('  DECEMBER, 1972$')
        ENDR

32:     IF TERMCH=CARRET THEN [PRM('$LENGTH OF LEADER AND TRAILER: ');&
        STR_NXLIN]
        IF TYPE_CTOKEN(@STR,0,NUMIN)#NUMBER THEN GO UNXERR
        IF MORE THEN ENDR
        LENGTH_TOKEN; OK; ENDR

31:     IF TERMCH=CARRET THEN [PRM('$TITLE: ');STR_NXLIN]
        EIF TYPE_CTOKEN(@STR,TTLE,RESIN+STRIN)=RESWRD AND TOKEN=17 THEN DO
          IF TYPE_CTOKEN(@STR,0,STRIN)#STRING THEN GO UNXERR
          IF MORE THEN ENDR
          IF USEFLG=FALSE THEN CONFMP ELSE OPNPTP(ESCAPE)
          LEDTRL(7); OUTTIT(POINTX(TOKBUF)); LEDTRL(7)
          IF USEFLG=FALSE THEN DO
          WHILE CHAR_GET#CARRET THEN NULL
        CLIBUF
        END ELSE CLSPTP
          ENDR
          END
        ORIF MORE THEN ENDR
        ORIF TYPE=RESWRD AND (TOKEN=7 OR TOKEN=12)&
        THEN [TITLE_FALSE; OK; ENDR]
        ORIF TYPE#STRING THEN GO UNXERR
        ELSE [CSTRING(POINTX(TOKBUF),POINTX(TITBUF));&
        OK; TITLE_TRUE; ENDR]

30:     IF TERMCH=CARRET THEN [MSG('$TO FILE: ');STR_NXLIN]
        CSTRING(STR,POINTX(TOKBUF))     !MAKE SURE AT BEG OF BUF
        SETOU
        IFILE_TEL; SYMBN_1              !INPUT:TEL, MODE:SYMBOLIC
        OFILE_OPEN(@TOKEN,DIRECT+OUTMSG+CHARACTER,OPNER1,2)
        READ(IFILE,@OFILE)
        RETURN

29:     IF TERMCH=CARRET THEN [MSG('$TO FILE: ');STR_NXLIN]
        CSTRING(STR,POINTX(TOKBUF))     !MAKE SURE AT BEG OF BUF
        SETOU
        IFILE_TEL; SYMBN_2              !INPUT:TEL, MODE:BINARY
        CHAR_(IF PARITY=PACKD THEN PACK ELSE WORD)
        OFILE_OPEN(@TOKEN,DIRECT+OUTMSG+CHAR,OPNER1,2)
        READ(IFILE,@OFILE)
        RETURN

27:     EIF SLEEPY=FALSE THEN MSG('$TALK ON!')
        ELSE MSG('$HUSH ON')
        MSG('$USING:   ')
        MSG(IF USEFLG=TRUE THEN 'PDP10' ELSE 'TELETYPE')
        EIF ECHO=FALSE THEN MSG('$NO ECHO')
        ELSE MSG('$ECHOING')
        IF RPTYPE#FALSE THEN [MSG('$SYMBOLIC:');MSG(CWORDS(RPTYPE))]
        EIF TITLE=FALSE THEN MSG('$NO TITLE')
        ELSE [MSG('$TITLE:   ');MSG(@TITBUF(0))]
        EIF ECHAR+ELINE=0 THEN MSG('$NO EDITING')
        ELSE DO
          MSG('$EDITING:')
          IF ECHAR#0 THEN [MSG(' CHARACTER=');TYPCHR(ECHAR)]
          IF ELINE#0 THEN [MSG(' LINE=');TYPCHR(ELINE)]
          END
        EIF PARITY=7 OR PARITY=12 THEN MSG('$NO PARITY')
        ELSE [MSG('$PARITY:  ');MSG(CWORDS(PARITY))]
        MSG('$LENGTH:  '); OUTNUM(LENGTH,10); MSG(' INCHES')
        CRLF; ENDR

26:     IF MORE THEN ENDR
        INIT; OK; ENDR

25:     IF TERMCH=CARRET THEN [PRM('$FROM FILE: ');STR_NXLIN]
        CSTRING(STR,POINTX(TOKBUF)); SAVRET_RETURN
        SETIN
        IFILE_OPEN(@TOKEN,CHARACTER+INPUT+SEQUEN,OPNER1,2)
        SETRWE(IFILE,E25)               !ENF OF FILE BUSINESS
        OK; RUNFLG_TRUE
        LOOP [STR_GETLINE(IFILE);TERMCH_E.O.LIT;GOCMD(23)]

E25:    RETURN_SAVRET; RUNFLG_FALSE; ENDR

24:     IF TERMCH=CARRET THEN [PRM('$TO FILE: ');STR_NXLIN]
        CSTRING(STR,POINTX(TOKBUF))     !MAKE SURE STRING O
        SETOU
        OFILE_OPEN(@TOKEN,CHARACTER+OUTMSG+SEQUEN,OPNER1,2)

! NOW WRITE OUT THE STRING
        VAL_0
        WHILE INC VAL<=MAX.CHR THEN DO
          IF ISUBTAB(VAL)#0 THEN DO
            VAL1_ISUBTAB(VAL); VAL2_NCHAR(VAL1)
            IF COMAFL_SUBOUT(OFILE,VAL1_ISUBTAB(VAL))<2 AND &
            CNTER(ESUBTAB(VAL2))=TRUE THEN W(OFILE,$,) ELSE DO
             W(OFILE,$ );W(OFILE,$F);W(OFILE,$O);W(OFILE,$R);W(OFILE,$ )
            END
            SUBOUT(OFILE,VAL1_ESUBTAB(VAL2))
            W(OFILE,CARRET)
            END
        END
        OK; ENDR

23:     IF TERMCH=CARRET THEN [PRM('$SUBSTITUTE: ');STR_NXLIN]
        VAL1_SUBGET(@STR,1)             !GET FIRST SUBSTITUTE STRING

!VALID TERMINATION IS EITHER A COMMA OR A SPACE AND WORD "FOR"
        EIF VAL1=FIRK THEN RETURN FIRK
        ORIF TERMCH=$, THEN NULL
        ORIF TERMCH=$  THEN DO
          SAVSTR_STR
          IF NOT(TYPE_CTOKEN(@STR,SUBIT,RESIN)=RESWRD AND TOKEN=28) THEN&
          STR_SAVSTR
        END
        ORIF TYPE=RESWRD THEN [MSG('ILLEGAL WORD IN INPUT$');RETURN FIRK]
        ELSE GO UNXERR
        VAL2_SUBGET(@STR,0)             !GET SECOND SUBSTITUTE STRING
          EIF VAL2=FIRK THEN RETURN FIRK
          ORIF TYPE=RESWRD AND TERMCH#CARRET THEN&
          [MSG('ILLEGAL WORD IN INPUT');RETURN FIRK]
          FIF TERMCH#CARRET THEN GO UNXERR

        VAL1_SUBPUT(VAL1); VAL2_SUBPUT(VAL2)            !COPY TO SUB STORAGE
! NOW MAKE ENTRY INTO SUBSTITUTION TABLE
        S1_NCHAR(VAL1)          !GET VALUE OF GO-TO STRING
        IF S2_ESUBTAB(S1)#0 THEN [ERR('CONFLICT WITH LEFT PART. "');PUTC(S1);&
        MSG('" ALREADY SUBSTITUTES TO:$'); SUBOUT(TEL,S2); CRLF]&
        ELSE ESUBTAB(S1)_VAL2            !MAKE ENTRY
        S1_NCHAR(VAL2)
        IF S2_ISUBTAB(S1)#0 THEN [ERR('CONFLICT WITH RIGHT PART. "');PUTC(S1);&
        MSG('" ALREADY SUBSTITUTES FROM:$'); SUBOUT(TEL,S2); CRLF]&
        ELSE ISUBTAB(S1)_VAL1            !MAKE ENTRY

        OK
        RETURN FIRK

22:     IF TERMCH=CARRET THEN [PRM('$EDITING: ');STR_NXLIN]

        WHILE TYPE_CTOKEN(@STR,EDITB,RESIN)=RESWRD AND (TOKEN=13 OR TOKEN=14)&
        THEN DO
          IF TERMCH#OCT 75 THEN [TYPE_DELIMT;GO UNXERR]
          SVPLAC_TOKEN
          IF TYPE_STOKEN(@STR,0,0)=FIRK THEN RETURN FIRK
          VAL_(IF TYPE=STRING THEN&
          NCHAR(POINTX(TOKBUF)) ELSE TOKEN)
          IF SVPLAC=13 THEN ECHAR_VAL ELSE ELINE_VAL
          IF TERMCH=CARRET THEN [OK;RETURN FIRK]
          END
        ENDR

21:     IF TERMCH=CARRET THEN [PRM('$PARITY: ');STR_NXLIN]
        EIF TYPE_CTOKEN(@STR,PRITY,RESIN)#RESWRD THEN GO UNXERR
        ORIF MORE THEN ENDR
        FIF (TOKEN=39) THEN GO UNXERR
        PARITY_(IF TOKEN=12 THEN 7 ELSE TOKEN); OK; ENDR

20:     SLEEPY_FALSE; OK; ENDR

19:     SLEEPY_TRUE; OK; ENDR

16:     SAVRET_RETURN; RUNFLG_TRUE
        IF MORE THEN ENDR

        DOCMD(1)                !SET UP SYMBOLIC OR BINARY MODE
        DOCMD(21)               !SET UP PARITY JUNK

        RETURN_SAVRET           !RESET RETURN LOCATION
        MSG('$INPUT FROM:  '); STR_NXLIN
        CSTRING(POINTX(IMAGE),POINTX(IFILS))

        IF SYMBN=1 THEN CHAR_CHARACTER ELSE CHAR_(IF PARITY=PACKD THEN PACK ELSE WORD)
        IF INDEX(POINTX(IMAGE),CHPT(TELSTR(0),-1))=TRUE&
        THEN IFILE_TEL ELSE&
        [IFILE_OPEN(@IMAGE(0),DIRECT+INPUT+CHAR,OPNER1,2)]

        MSG('$OUTPUT TO:   '); STR_NXLIN
        CSTRING(POINTX(IMAGE),POINTX(OFILS))
        IF INDEX(POINTX(IMAGE),CHPT(TELSTR(0),-1))=TRUE&
        THEN OFILE_TEL ELSE&
        [OFILE_OPEN(@IMAGE(0),DIRECT+OUTMSG+CHAR,OPNER1,2)]
        IF IFILE=OFILE THEN [MSG('$BOTH SOURCES CANNOT BE SAME$'); ENDR]
        IF IFILE#TEL AND OFILE#TEL THEN&
        [MSG('$DISK TO DISK CONVERSION NOT IMPLEMENTED$');ENDR]
        IF SYMBN=1 THEN DOCMD(42)       !SET UP REPRESENTATION
!       IF IFILE=TEL THEN DOCMD(22)
        DOCMD(23)       !SET UP SUBSTITUTION
        IF OFILE=TEL THEN DOCMD(31)     !SET UP TITLE
        IF IFILE=TEL THEN DOCMD(41)     !SET UP ECHOING
        IF OFILE=TEL THEN DOCMD(32)     !SET UP LENGTH

        IF IFILE=TEL THEN READ(IFILE,@OFILE) ELSE PUNCH(IFILE,OFILE)
        RUNFLG_FALSE; RETURN_SAVRET; ENDR

18:     IF TERMCH=CARRET THEN [MSG('$FROM FILE: ');STR_NXLIN]
        CSTRING(STR,POINTX(TOKBUF))     !MAKE SURE AT BEG OF BUF
        OFILE_TEL; SYMBN_2              !OUTPUT:TEL, MODE:BINARY
        SETIN
        CHAR_(IF PARITY=PACKD THEN PACK ELSE WORD)
        IFILE_OPEN(@TOKEN,DIRECT+INPUT+CHAR,OPNER1,2)
        PUNCH(IFILE,OFILE)              !PUNCH IT !!
        RETURN

17:     IF TERMCH=CARRET THEN [MSG('$FROM FILE: ');STR_NXLIN]
        CSTRING(STR,POINTX(TOKBUF))     !MAKE SURE AT BEG OF BUF
        OFILE_TEL; SYMBN_1              !OUTPUT:TEL, MODE:SYMBOLIC
        SETIN
        IFILE_OPEN(@TOKEN,DIRECT+INPUT+CHARACTER,OPNER1,2)
        PUNCH(IFILE,OFILE)              !PUNCH IT !!
        RETURN

15:     ENDR

12:     IF TERMCH=CARRET THEN [MSG('$NO WHAT?? ');STR_NXLIN]
        IF TYPE_CTOKEN(@STR,NOTBL,RESIN)#RESWRD THEN GO UNXERR
        IF MORE THEN ENDR
        DO TOKEN OF 0:C.SIZE

42:     RPTYPE_FALSE; ENDK
41:     ECHO_FALSE; ENDK
39:     HELP(C.SIZE+1); ENDR
32:     LENGTH_10; ENDK
31:     TITLE_FALSE; ENDK
23:     FOR CHAR_0 TO MAX.CHR ISUBTAB(CHAR)_ESUBTAB(CHAR)_0; ENDK
22:     ECHAR_ELINE_FALSE; ENDK
21:     PARITY_7; ENDK
20:     IF MORE THEN ENDR
        SLEEPY_TRUE; ENDK
19:     IF MORE THEN ENDR
        SLEEPY_FALSE; ENDK

        END

        GO UNXERR

1:      IF TERMCH=CARRET THEN [MSG('$SYMBOLIC OR BINARY? ');STR_NXLIN]
        SYMBN_1        !INIT TO SYMBOLIC MODE INCASE C.R. [FOR SYMBOLIC]
        EIF TYPE_CTOKEN(@STR,SYMBIN,RESIN)=RESWRD AND 1<=TOKEN<=2 THEN&
        [SYMBN_TOKEN;ENDR]
        ELSE GO UNXERR

        END

! BRANCH HERE WHEN FED UP WITH THE WORLD
!
UNXERR: EIF TYPE=RESWRD AND TOKEN=39 THEN [HELP(ARG1);RETURN FIRK]
        ELSE FIRKIT(TYPE)
        EIF TERMCH=CARRET AND TYPE=DELIMT THEN RETURN EMPTY
        ELSE RETURN FIRK

! HERE ON OPEN FILE ERRORS
!
OPNER1: EIF ERRNUM<1 OR ERRNUM>13 THEN MSG('SYSTEM ERROR ON FILE:')
        ELSE DO ERRNUM OF 1:13
1:      MSG('TOO MANY FILES OPEN-SYSTEM ERROR, ON FILE:')
2:      MSG('BAD ARGUMENTS TO OPEN-SYSTEM ERROR, ON FILE:')
3:      MSG('ILLEGAL FILE NAME--FILE:')
4:      MSG('$NEW/OLD FILE MESSAGE NOT CONFIRMED--FILE:')
5:      MSG('FILE NOT FOUND:')
6:      MSG('INVALID USERNAME OR PPN--FILE:')
7:      MSG('PROTECTION FAILURE--FILE:')
8:      MSG('FILE BUSY$SOMEONE MUST HAVE THE FILE OPEN--FILE:')
9:      MSG('RENAME ERROR-SYSTEM ERROR, ON FILE:')
10:     MSG('END OF FILE-SYSTEM ERROR, ON FILE:')
11:     MSG('LINE TOO LONG ON FILE:')
12:     MSG('ILLEGAL OPERATION ON TEL-SYSTEM ERROR, ON FILE:')
13:     MSG('OUT OF CORE-SYSTEM ERROR, ON FILE:')

        END

        OUTSTR(STR); CRLF; RETURN FIRK


END GOCMD

        \\->BEGIN
   @ F