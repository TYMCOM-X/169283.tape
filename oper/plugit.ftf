C       PLUGIT.FTF
        SUBROUTINE PLUGIT
C
C       THIS SUBROUTINE PERFORMS THE NECESSARY OPERATIONS TO CONNECT
C       THE PLUG-PIN SPECIFIED BY /PLUGPIN/ TO THE SOCKET-PIN SPECIFIED
C       BY /PINS/.
C       NOTE...THE PIN PARAMETERS FROM, TO, AND PLGRING ARE NOT SET UP.
C
        COMMON /PLUGPIN/ PPID, DEFAULT, GROUP, SUBGRP, ILT, OLT,
     1  GRPNO, SGRPNO, LOAD, DRIVE, WOCC, TCC, PPCORAL(2), GRPRNG,
     2  SGRPRNG, PPX, PPY, PPFLAG, THISPP
        DOUBLE PRECISION DEFAULT, GROUP, SUBGRP
        REAL LOAD
        LOGICAL PPFLAG
        INTEGER PPID,GRPNO,SGRPNO,WOCC,TCC,PPCORAL,GRPRNG,SGRPRNG,
     1  THISPP
C
        COMMON /PINS/ PID, BPCORAL(2),XPINS, YPINS, BPSIG, FROM, TO,
     1  PLGPIN, PLGRING, CODES, DIST, NULL(2), PINFLAG, THISPIN
        DOUBLE PRECISION BPSIG
        INTEGER PID, BPCORAL, FROM, TO, PLGPIN, PLGRING, CODES,
     1  THISPIN
        LOGICAL PINFLAG
C
C       LINK PIN TO PLUG-PIN, SET FLAG FOR PLUG ATTACHED
        PINFLAG = .TRUE.
        PLGPIN = THISPP
        CODES = CODES .OR. "100000000000
C
C       SET DEFAULT SIGNAL, CODE IF APPROPRIATE
        IF (DEFAULT .EQ. 0) GO TO 100
        IF (BPSIG .NE. 0) GO TO 100
        BPSIG = DEFAULT
        CODES = CODES .OR. "040000000000
C
C       NOW LINK IN THE SIGNAL
        I = THISPIN
        CALL LINK1
        CALL GETPIN(I)
        PINFLAG = .TRUE.
C
C       SET ADDITIONAL CODE BITS
  100   IF (GROUP .NE. 0) CODES = CODES .OR. "020000000000
        IF (SUBGRP .NE. 0) CODES = CODES .OR. "010000000000
        IF (DRIVE .NE. 0) CODES = CODES .OR. "004000000000
        IF (WOCC .NE. 0) CODES = CODES .OR. "004000000000
        IF (OLT .NE. 0) CODES = CODES .OR. "004000000000
        CALL MPUTFD(WOCC, "320300000000, CODES)
        CALL MPUTFD(TCC, "270300000000, CODES)
        RETURN
        END
        LOGICAL FUNCTION PLUGSOC(BPNO, PLUGID)
C
C       THIS ROUTINE ATTEMPTS TO PLUG THE PLUG "PLUGID" INTO THE BOARD
C       AT BPNO.  RETURNS .TRUE. IF SUCCESS, THEN ALL PLUGGED.  ELSE
C       RETURNS .FALSE, SOCKET PINS NOT MODIFIED.
C
        COMMON /PLUGPIN/ PPID, DEFAULT(2), GROUP(2), SUBGRP(2), ILT,
     1  OLT, GRPNO, SGRPNO, LOAD, DRIVE, WOCC, TCC, PPCORAL(2), GRPRNG,
     2  SGRPRNG, PPX, PPY, PPFLAG, THISPP
        REAL LOAD
        LOGICAL PPFLAG
        INTEGER PPID, DEFAULT, GROUP,SUBGRP,GRPNO,SGRPNO,WOCC,TCC
        INTEGER PPCORAL, GRPRNG,SGRPRNG,THISPP
C
        COMMON /PINS/ PID, BPCORAL(2),XPINS, YPINS, BPSIG(2), FROM, TO,
     1  PLGPIN, PLGRING, CODES, DIST, NULL(2), PINFLAG, THISPIN
        INTEGER PID, BPCORAL, BPSIG, FROM, TO, PLGPIN, PLGRING, CODES,
     1  THISPIN
        LOGICAL PINFLAG

C
        COMMON /PLUGS/ PLGID(3), PLGPNT, PLGSIZE, NPLGPIN, PLGFLAG,
     1  THISPLG
        INTEGER PLGID, PLGPNT, PLGSIZ, THISPLG
        LOGICAL PLGFLAG
C
        DIMENSION ROT(2,2)
        INTEGER BPNO, PLUGID(3)
C
    1   FORMAT(' PLUG HAS NO COORDINATE INFORMATION.',
     1  '.PLEASE VERIFY USAGE'/)
C
C       FIRST OF ALL, LOOK UP THE PLUG
        PLUGSOC = PLGFIND(PLUGID)
        IF (.NOT. PLUGSOC) RETURN
C
C       WE'VE NOW GOT THE PLUG...COMPUTE FITTING PARAMETERS
        CALL GETPIN(BPNO)
        IF (PLGPIN .EQ. 0) GO TO 110
C
C       HERE IF FIND A PLUGPIN ALREADY ATTACHED TO SOCKET PIN
  100   CALL ERROR ('SOCKET ALREADY HAS PLUG', 'OVERLAP')
        PLUGSOC = .FALSE.
        RETURN
C
C       SAVE THE COORDINATES OF THE FIRST PIN
  110   X0 = XPINS
        Y0 = YPINS
        CALL GETPP(PLGPNT)
        PX0 = PPX
        PY0 = PPY
        N = PPCORAL(1)
        CALL GETPP(N)
        DPX = PPX - PX0
        DPY = PPY - PY0
        RPXY = SQRT(DPX*DPX + DPY*DPY)
        IF (RPXY .EQ. 0) GO TO 270
C
C       WE NOW KNOW THAT THE FIRST TWO PLUG-PINS HAVE COORDINATES SPECIFIED
C       FIND SEPERATION OF THE FIRST TWO SOCKET PINS
        N = PLGRING
        CALL GETPIN(N)
        IF(PLGPIN .NE. 0) GO TO 100
        DX = XPINS - X0
        DY = YPINS - Y0
        RXY = SQRT(DX*DX + DY*DY)
        IF ( ABS(RXY - RPXY) .LT. .005) GO TO 130
C
C       HERE IF DISCREPENCY BETWEEN PLUG AND BOARD COORDINATES
C       COMMENT AND ABORT
  120   CALL ERROR ('PLUG DOES NOT FIT IN BOARD', 'NO FIT')
        PLUGSOC = .FALSE.
        RETURN
C
C       THE FIRST TWO PINS ON PLUG AND SOCKET MATCH...COMPUTE ROTATION
  130   R = RPXY*RXY
        ROT(1,1) = (DX*DPX + DY*DPY)/R
        ROT(1,2) = (DX*DPY - DY*DPX)/R
        ROT(2,1) = - ROT(1, 2)
        ROT(2,2) = ROT(1,1)
C
C       NOW VERIFY THE REST OF THE PLUG
        IF (NPLGPIN .LE. 2) GO TO 160
        DO 150 I = 3, NPLGPIN
         N = PPCORAL(1)
         CALL GETPP(N)
         DPX = PPX - PX0
         DPY = PPY - PY0
         RPXY = SQRT(DPX*DPX + DPY*DPY)
         IF(RPXY .LT. .005) GO TO 270
C
C       SEARCH ALL SOCKET FOR NEXT MATCHING PIN
  140    N = PLGRING
         CALL GETPIN(N)
         IF (BPNO .EQ. THISPIN) GO TO 120
         DX = XPINS - X0
         DY = YPINS - Y0
         RXY = SQRT(DX*DX + DY*DY)
         IF (ABS(RXY - RPXY) .GT. .005) GO TO 140
         DX = (ROT(1,1)*DPX + ROT(1,2)*DPY) - DX
         DY = (ROT(2,1)*DPX + ROT(2,2)*DPY) - DY
         RXY = SQRT(DX*DX + DY*DY)
         IF (RXY .GE. .005) GO TO 140
C
C       WE'VE GOT AN ACCEPTABLE MATCH..VERIFY NO PLUG HERE
         IF (PLUGPIN .NE. 0) GO TO 100
  150    CONTINUE
C
C       WE'VE NOW MATCHED ALL THE PLUG-PINS WITH THE SOCKET PINS
  160   CALL GETPIN(BPNO)
        CALL GETPP(PLGPNT)
        CALL PLUGIT
        PLGRING = PLGRING .OR. "400000000000
        PINFLAG = .TRUE.
        DO 180 I = 2, NPLGPIN
         N = PPCORAL(1)
         CALL GETPP(N)
         DPX = PPX - PX0
         DPY = PPY - PY0
  170    N = PLGRING .AND. "377777777777
         CALL GETPIN(N)
         DX = XPINS - X0
         DY = YPINS - Y0
         DX = ROT(1,1)*DPX + ROT(1,2)*DPY - DX
         DY = ROT(2,1)*DPX + ROT(2,2)*DPY - DY
         IF (SQRT(DX*DX + DY*DY) .GT. .005) GO TO 170
          CALL PLUGIT
         PINFLAG = .TRUE.
  180    PLGRING = PLGRING .OR. "400000000000
C
C       NOW CRACK PLUG RING INTO PLUG, OUTSIDE
  200   CALL GETPIN(BPNO)
        IE = BPNO
        JS = 0
        JE = 0
        IS = PLGRING .AND. "377777777777
C
C       DETERMINE WHAT NEXT PIN GOES TO
  210   CALL GETPIN(IS)
        IT = PLGRING .AND. "377777777777
        IF(PLGRING) GO TO 230
        IF (JS .NE. 0) GO TO 220
C
C       HERE FOR FIRST FREE PIN
        JS = THISPIN
        JE = THISPIN
        GO TO 250
C
C       HERE FOR NEW FREE PIN
  220   CALL GETPIN(JE)
        JE = IS
        GO TO 240
C
C       HERE FOR PLUG
  230   CALL GETPIN(IE)
        IE = IS
C
C       LINK THE LAST PIN TO THIS
  240   PLGRING = IS
        PINFLAG = .TRUE.
C
C       END OF LOOP..TEST IF DONE
  250   IS = IT
        IF (IT .NE. BPNO) GO TO 210
C
C       LINK ALL ELSE
        CALL GETPIN(IE)
        PINFLAG = .TRUE.
        PLGRING = BPNO
        IF (JS .EQ. 0) GO TO 260
        CALL GETPIN(JE)
        PLGRING = JS
        PINFLAG = .TRUE.
C
C       DONE..CLEAN UP
  260   CALL PUTPIN
        RETURN
C
C
C       HERE FOR THE CASE WHERE THE PLUG DOES NOT CONTAIN DIMENSIONS
  270   CALL GETPIN(BPNO)
C
C       VERIFY THAT THE APPROPRIATE NUMBER OF PINS HAVE NO PLUGS
        DO 280 I = 2, NPLGPIN
         N = PLGRING
         CALL GETPIN(N)
         IF(PLGPIN .NE. 0) GO TO 100
         IF (BPNO .EQ. THISPIN) GO TO 120
  280    CONTINUE
C
C       OK..LINK THE PINS IN, BUT TELL THE USER
        TYPE 1
        IT = BPNO
        DO 290 I = 1, NPLGPIN
         CALL GETPIN(IT)
         IT = PLGRING
         CALL PLUGIT
  290    PLGRING = PLGRING .OR. "400000000000
C
C       NOW FOR NORMAL SEQUENCE
        GO TO 200
        END
        LOGICAL FUNCTION BPVFY(BITCH)
C
C       THIS ROUTINE VERIFIES THAT THE NEXT ELEMENT IN INLINE CONTAINS A
C       VALID BOARD-PIN ID.  IF SO. RETURN .TRUE., /SOCKET/, /PINS/ WITH
C       THE CORRECT ELEMENTS.  IF NOT, RETURN .FALSE. UNLESS .BITCH. IS
C       .TRUE., IN WHICH CASE AN ERROR MESSAGE IS OUTPUT AND THE NEW
C       LINE IS RESCANNED UNTIL A VALID BPID IS ENTERED.
C
        INTEGER B(2), P, TS
        LOGICAL BITCH
C
        COMMON /SOCKET/ SOCID(2), NSOCPIN, NWORDS, SPINPNT, SOCFLAG,
     1  THISSOC
        INTEGER SOCID, SPINPNT, THISSOC
        LOGICAL SOCFLAG
C
        COMMON /PINS/ PID, BPCORAL(2),XPINS, YPINS, BPSIG(2), FROM, TO,
     1  PLGPIN, PLGRING, CODES, DIST, NULL(2), PINFLAG, THISPIN
        INTEGER PID, BPCORAL, BPSIG, FROM, TO, PLGPIN, PLGRING, CODES,
     1  THISPIN
        LOGICAL PINFLAG
C
C       SAVE ENTRY VALUES
        IF (THISSOC .EQ. 0) CALL GETSOC(1)
        TS = THISSOC
C
C       GET THE LINE IN
  100   IF (.NOT. PACK(B(1), 10, 0) ) GO TO 110
        I = NOWCH(8, KANDO)
        IF (.NOT. KANDO) GO TO 140
        IF (I .NE. '-' ) GO TO 140
        CALL NEXTCH(8, KANDO)
        IF (.NOT. KANDO) GO TO 110
        IF (.NOT. PACK(P, 5, 0) ) GO TO 110
        IF (SOCFIND(B(1) ) ) GO TO 120
C
C       HERE IF ERROR CONDITION
  110   CALL GETSOC(TS)
        BPVFY = .FALSE.
        IF (.NOT. BITCH) RETURN
        CALL ERROR ('INVALID PIN DESCRIPTION', 'BAD ID')
        GO TO 100
C
C       SEARCH FOR VALID PIN
  120   IF (.NOT. PINFIND(P) ) GO TO 110
C
C       SUCCESS
  130   BPVFY = .TRUE.
        RETURN
C
C       HERE IF NO "-" INCLUDED IN LINE..SEARCH SOCKET
  140   IF (.NOT. SOCFIND(B(1) ) ) GO TO 160
        I = SPINPNT .AND. "377777777777
  150   CALL GETPIN(I)
        IF (PLGRING .NE. 0) GO TO 130
        I = BPCORAL(1)
        GO TO 150
C
C       NOT SOCKET..DETERMINE IF VALID PIN
  160   IF (B(2) .NE. 0) GO TO 110
        P = B(1)
        GO TO 120
        END
        LOGICAL FUNCTION PSPVFY(BITCH)
C
C       THIS ROUTINE (PARENTHESIZED SOCKET PIN) LOOKS AT THE INPUT LINE
C       IF IT DOES NOT INCLUDE "(**)", RETURN .TRUE.  ELSE DETERMINE IF
C       ** IS A VALID PIN DESCRIPTOR FOR THIS SOCKET, RETURN .FALSE. IF
C       NOT.  ELSE RETURN .TRUE. IF SO, THEN /PINS/ REFLECTS THE NEW
C       PIN.
C
        LOGICAL BITCH
C
C       DETERMINE IF THERE'S A "("
  100   PSPVFY = .TRUE.
        IF (LPARSE(48) .NE. 1) RETURN
        IF (.NOT. PACK(N, 5, 0) ) GO TO 110
        IF (NOWCH(8,I) .NE. ')' ) GO TO 110
        CALL NEXTCH(8, I)
        IF (PINFIND(N) ) RETURN
C
C       HERE IF ERROR
  110   PSPVFY = .FALSE.
        IF (.NOT. BITCH) RETURN
        CALL ERROR ('INVALID PIN DESCRIPTION', 'BAD PIN ID')
        GO TO 100
        END
        LOGICAL FUNCTION PPPVFY(BITCH)
C
C       THIS ROUTINE (PARENTHESIZED PLUG PIN) LOOKS AT THE INPUT LINE.
C       IF IT DOES NOT CONTAIN "(**)", RETURN .TRUE.  ELSE DETERMINE IF
C       ** IS A VALID PLUG-PIN DESCRIPTOR FOR THIS THIS PLUG.  RETURN
C       .FALSE. IF NOT.  ELSE RETURN .TRUE., THEN /PINS/ REFLECTS THE
C       NEW PIN
C
        LOGICAL BITCH
C
        COMMON /PLUGPIN/ PPID, DEFAULT, GROUP, SUBGRP, ILT, OLT,
     1  GRPNO, SGRPNO, LOAD, DRIVE, WOCC, TCC, PPCORAL(2), GRPRNG,
     2  SGRPRNG, PPX, PPY, PPFLAG, THISPP
        DOUBLE PRECISION DEFAULT, GROUP, SUBGRP
        REAL LOAD
        LOGICAL PPFLAG
        INTEGER PPID, GRPNO, SGRPNO, WOCC, TCC
        INTEGER PPCORAL, GRPRNG,SGRPRNG,THISPP
C
        COMMON /PINS/ PID, BPCORAL(2),XPINS, YPINS, BPSIG(2), FROM, TO,
     1  PLGPIN, PLGRING, CODES, DIST, NULL(2), PINFLAG, THISPIN
        INTEGER PID, BPCORAL, BPSIG, FROM, TO, PLGPIN, PLGRING, CODES,
     1  THISPIN
        LOGICAL PINFLAG
C
C       FIRST SAVE THIS PIN
        IT = THISPIN
  100   PPPVFY = .TRUE.
        IF (LPARSE(48) .NE. 1) RETURN
        IF (.NOT. PACK(N, 4, 0) ) GO TO 120
        IF (NOWCH(8, I) .NE. ')' ) GO TO 120
        CALL NEXTCH(8, I)
C
C       NOW MAKE '**' INTO '"**'
        N = ( (N/256) .AND. "003777777777) .OR. "210000000000
C
C       NOW SEARCH FOR THE PLUG-PIN CORRESPONDING TO N
        I = IT
  110   CALL GETPIN(I)
        I = PLGRING
        CALL GETPP(PLGPIN)
        IF (N .EQ. PPID) RETURN
        IF (I .NE. IT) GO TO 110
C
C       HERE IF ERROR...
  120   PPPVFY = .FALSE.
        CALL GETPIN(IT)
        CALL GETPP(PLGPIN)
        IF (.NOT. BITCH) RETURN
        CALL ERROR ('INVALID PLUG-PIN DESCRIPTION','BAD PLUGPIN ID')
        GO TO 100
        END
        SUBROUTINE UNWIRE
C
C       THIS ROUTINE REMOVES THE SIGNAL FROM THE CURRENT PIN, RELINKS
C       AROUND IT AS NECESSARY
C
        COMMON /PINS/ PINID, NEXT, PINPNT, XPIN, YPIN, SIGID,
     1  LASTSIG, NEXTSIG, PLUGPNT, NEXTRNG, ATTRIB, DIST, CHANGE,
     2  NULL, PINFLAG, THISPIN
        DOUBLE PRECISION SIGID
        INTEGER PINID, PINPNT, PLUGPNT, ATTRIB, CHANGE, NULL,
     1  THISPIN
        LOGICAL PINFLAG
C
        COMMON /HASHCON/ HASH, NBLOCK, THISSIG, SIGIDEN(2), NEXTB,
     1  SIGPNT, SIGFLAG
        INTEGER HASH, THISSIG, SIGIDEN, SIGPNT
        LOGICAL SIGFLAG
C
        DIMENSION XY1(2)
        INTEGER BIT
        DATA BIT, MASK / "400000000000, "377777777777 /
C
C       REMEMBER THE CURRENT PIN
        IT = THISPIN
        I = LASTSIG
        J = NEXTSIG
        IF (J .EQ. 0) GO TO 100
C
C       NEXT SIGNAL IS NOT NULL...CHANGE IT'S LINKAGE
        CALL GETPIN(J .AND. MASK )
        LASTSIG = (LASTSIG .AND. BIT) .OR. I
        PINFLAG = .TRUE.
        XY1(1) = XPIN
        XY1(2) = YPIN
C
C       DETERMINE LAST SIGNAL IN LIST ATTRIBUTES
  100   IF (I .EQ. 0) GO TO 110
C
C       LAST SIGNAL EXISTS...CHANGE IT
        CALL GETPIN(I .AND. MASK)
        DIST = 0.0
        IF (J .NE. 0) DIST = HOWFAR(XY1(1), XPIN)
        NEXTSIG = J
        PINFLAG = .TRUE.
        GO TO 120
C
C       HERE IF MUST DIDDLE HASH TABLE
  110   CALL SIGFIND(SIGID)
        SIGPNT = (SIGPNT .AND. BIT) .OR. J
        SIGFLAG = .TRUE.
        CALL PUTSIG
C
C       NOW CLEAN UP /IT/
  120   CALL GETPIN(IT)
        LASTSIG = 0
        NEXTSIG = 0
        SIGID = 0.0
        DIST = 0.0
        ATTRIB = ATTRIB .AND. "337777777777
        IF ( (ATTRIB .AND. "100000000000) .EQ. 0)
     1          ATTRIB = ATTRIB .AND. "773777777777
        PINFLAG = .TRUE.
        CALL PUTPIN
        CALL SETWRI
        RETURN
        END
        LOGICAL FUNCTION SFORMAT(NULL)
C
C       THIS ROUTINE INPUTS AND VERIFIES A SIGNAL FORMAT STRING
C       IF SUCCESS, RETURN .TRUE., NEW DEFINED SIGNAL IN HASHCON.
C       ELSE RETURN .FALSE., ERROR MESSAGE OUTPUT, NEW LINE IN BUFFER.
C
        DIMENSION ID(2)
C
        COMMON /HASHCON/ HASHCON, NBLOCK, THISSIG, SIGID(2), NEXTSIG,
     1  SIGPIN, SIGFLAG, DEFSIG(2), CDSN
        INTEGER HASHCON, THISSIG, SIGID, SIGPIN, DEFSIG, CDSN
        LOGICAL SIGFLAG
C
        COMMON /OWNPRM/ PRMPCP, UNPROMP, JPROM
        LOGICAL PRMPCP, UNPROMP
C
C       GET THE STRING INTO ID
        SFORMAT = .FALSE.
        IF (PACK(ID(1), 10, 0) ) GO TO 100
C
C       ERROR IN STRING, BITCH AND RETURN
        CALL ERROR ('INVALID SIGNAL FORMAT','BAD FORMAT')
        RETURN
C
C       VERIFY THE STRING
  100   DO 110 I = 1, 10
        IF (MGETCH(I, ID(1) ) .EQ. "71) GO TO 120
  110   CONTINUE
C
C       HERE IF FORMAT CONTAINS NO "9"
        CALL ERROR ('SIGNAL FORMAT HAS NO "9"','BAD FORMAT')
        RETURN
C
C       SCAN REST OF ID, VERIFY ONLY TRAILING "9"
  120   DO 130 J = I, 10
        I = MGETCH(J, ID(1) )
        IF (I .EQ. 0) GO TO 140
        IF (I .NE. "71) GO TO 150
  130   CONTINUE
C
C       HERE IF SUCCESS
  140   DEFSIG(1) = ID(1)
        DEFSIG(2) = ID(2)
        CDSN = 0
        SFORMAT = .TRUE.
        RETURN
C
C       HERE IF NOT ALL TRAILING "9"
  150   CALL ERROR('NOT ALL "9"S ARE TRAILING','BAD FORMAT')
        RETURN
        END
    