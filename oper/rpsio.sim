! RPS IO PACKAGE
GLOBAL %INDATA, %OUTDATA, %INIT.DEV, %CLOSE.DEV, %GETPHONE

FIND %R.RPS, %W.RPS, %NXLIN, %GETCHAN, %VALCHAN, %ZAP.RPS, %STROUT
FIND %GETAPR, %SINC, RMTCHAN

! PROCEDURE: INDATA
! ARG:1 IS THE UNIVERSAL FILE INDEX TO BE USED
! READS DATA FROM THE SOURCE SPECIFIED BY ARG:1
! RETURNS: THE CHARACTER READ
%INDATA(ARG.1)

 ! PROCESS IOCS TYPE FILE
        EIF OPENDEV(ARG.1)=F.IOCS THEN RETURN R(ARG.1)

 ! PROCESS REMOTE PERIPHERAL STATION INPUT
        FIF OPENDEV(ARG.1)=F.RPS THEN RETURN R.RPS(DEVCHAN(ARG.1))

 ! ERROR -- ABORT
        MSG('$FATAL ERROR IN %INDATA: ILLEGAL UNIVERSAL I/O INDEX$')
        RETURN FALSE

END INDATA

! PROCEDURE: OUTDATA
! ARG:1 IS THE UNIVERSAL FILE INDEX TO BE USED
! ARG:2 IS THE DATA TO BE TRANSMITTED
! TRANSMITTS ARG:2 TO THE DESTINATION ARG:1
%OUTDATA(ARG.1,ARG.2)

 ! PROCESS IOCS TYPE FILE
        EIF OPENDEV(ARG.1)=F.IOCS THEN DO
          W(ARG.1,ARG.2)
          RETURN TRUE
          END

 ! PROCESS REMOTE PERIPHERAL STATION
        FIF OPENDEV(ARG.1)=F.RPS THEN DO
          W.RPS(DEVCHAN(ARG.1),ARG.2)
          RETURN TRUE
          END

 ! ERROR - ABORT
        MSG('$FATAL ERROR IN %OUTDATA: ILLEGAL UNIVERSAL I/O INDEX$')
        RETURN FALSE

END OUTDATA

! PROCEDURE: INIT.DEV
! ARG:1 IS THE UFI
! ARG:2 IS THE INITIAL MODE OF TRAVEL
!  -1 IF INPUT
!   0 IF IDLE [ILLEGAL IF OPENDEV(ARG:1)=F.RPS]
!  +1 IF OUTPUT
! THIS PROCEDURE WILL SET UP DEVCHAN(ARG:1)=CHANNEL
! AND WILL SET UP DEVNAME(ARG:1)=NAME  OF DEVICE OPENED
%INIT.DEV(ARG.1,ARG.2)

LOCAL ERR.1:,ERR.2:
LOCAL TMP.1,TMP.2,TMP.3,TMP.4,TMCHK

 ! CHECK TO OPEN REMOTE PERIPHERAL STATION
        EIF OPENDEV(ARG.1)=F.RPS THEN DO

 ! *************** RMT CHANNEL OPEN

          IF ARG.2=0 THEN DO ! CANNOT IDL OUT
                MSG('$FATAL ERROR: ARG.2=0 IN INIT.DEV$')
                RETURN FALSE
                END

! CALL SUBROUTINE TO GET A RPS CHANNEL..........
! ONCE WE GET IT WE CAN THEN SET UP DEVNAME/DEVCHAN, AND
! DO ALL OF THAT GOOD STUFF

! FIRST SET UP FOR THE ZAPPER
        DEVNAME(ARG.1)_DEVCHAN(ARG.1)_-1 !0RESET CHAN NAME STAT

        IF ARG.2 = -1 THEN LOOP DO ! GET THE I.D.

          MSG('$ID? ')
          TMCHK_TMP.3 _ NXLIN
          IF NCHV TMCHK = CAR.RET THEN DO
! ERROR -- NULL ID NOT ALLOWED
            MSG('$NULL I.D. IS NOT ALLOWED$')
            END
          WHILE CHV TMCHK = CAR.RET
          END
! FIRST, WE MUST GET A TELEPHONE NUMBER FROM THE TELEPHONE
! NUMBER FILE (SYS)PHONE.SYS
! THE FORMAT OF THAT FILE IS ASCII AND IS:
!  RECORD 1: THE CPU SERIAL NUMBER IN ASCII AS: *533
!  RECORDS 2-9: PHONE NUMBERS
! RECORD 10: CPU SERIAL NUMBER ...
        TMP.1 _ OPEN("PHONE.SYS",INPUT+DIRECT+CHARACTER,ERR.1,0)

! GET AN RPS CHANNEL; VIA 'GETCHAN' ROUTINE
! GETCHAN: ARG1: DEVNAM; ARG2: DEVCHAN; ARG3: PASSWORD[MAYBE];
! ARG4: -1 IF INPUT, 1 IF OUTPUT

        IF GETCHAN(ARG.1,TMP.3,ARG.2)=FALSE THEN DO
          MSG('$THERE ARE NO FREE REMOTE PERIPHERAL STATION PORTS')
          MSG('$CURRENTLY AVAILABLE.  PLEASE TRY AGAIN LATER.$')
          CLOSE(TMP.1); RETURN FALSE
          END
! WE HAVE A PORT ASSIGNED, READ TELEPHONE NUMBER  [HOPE]
! WE READ IN IN BLOCKS, E.O.F. CAUSES END OF TRANSLATION

        SETRWE(TMP.1,ERR.2)
        TMP.4 _ GETPHONE(TMP.1,DEVCHAN(ARG.1) BAND OCT 7,DEVNUM(ARG.1))
        CLOSE(TMP.1)

! TYPE PHONE NUMBER OUT
        PUT(CAR.RET)
        WHILE CHAR_NCHV TMP.4 #E.O.LIT AND CHAR # CAR.RET THEN PUT(CHAR)
        MSG(' IS NOW AVILABLE$')


! IF FOR OUTPUT MODE, READ IN I.D. AND VALIDATE
        IF ARG.2 = 1 THEN LOOP DO
          MSG('$ID? ')
          TMCHK_TMP.3 _ NXLIN
          IF NCHV TMCHK = CAR.RET THEN DO
            MSG('$NULL I.D. IS NOT ALLOWED$')
            END
          WHILE CHV TMCHK = CAR.RET
          END

! FORCE VALIDATION OF THE CHANNEL
! THERE IS AN UNSAID RULE IN GETCHAN THAT SET'S DEVNAM UP = -1
! AND SETS DEVCHAN UP WITH THE CHANNEL.  VALCHAN WILL INSERT
! THE PROPER NAME IN DEVNAM WHEN CALLED, SO ON
! ESCAPE IF ANY DEVNAM = -1 THEN THAT PORT SHOULD BE
! ZAPPED.

        IF VALCHAN(ARG.1,TMP.3,ARG.2) = FALSE THEN DO
          MSG('$ID MISMATCH - NOT OPENED.$')
          RETURN FALSE
          END

! WE HAVE A VALID CHANNEL - RETURN
        MSG('$OPENED.$')
        RETURN TRUE

! ERROR POINTS

ERR.2:  MSG('$FATAL ERROR: CANNOT LOOKUP PHONE NUMBER!!$')
        RETURN FALSE

ERR.1:  MSG('$FATAL ERROR: CANNOT OPEN PHONE NUMBER FILE!!$')
        RETURN FALSE

        END

 ! *************** ERROR - BAD OPEN ARGS

        ELSE DO

        MSG('$FATAL ERROR: BAD ARGUMENT 1 TO %INIT.DEV$')
        RETURN FALSE
        END

END INIT.DEV

! PROCEDURE: CLOSE.DEV
! ARG:1 IS THE UFI
! WILL CLOSE ANY TYPE OF DEVICE [IOCS OR OTHERWISE]
! DOES POST-MORTEM PROCESSING ALSO [IF ANY]
%CLOSE.DEV(ARG.1)

        EIF OPENDEV(ARG.1)=F.IOCS THEN DO
          CLOSE(ARG.1)
          RETURN TRUE
          END

        ORIF OPENDEV(ARG.1)=F.RPS THEN DO
          ZAP.RPS(ARG.1)
          DEVNAME(ARG.1)_0
          DEVCHAN(ARG.1)_0
          DEVNUM(ARG.1)_0
          OPENDEV(ARG.1)_0
          IF ARG.1 = RMTCHAN THEN RMTCHAN _ 0
          RETURN TRUE
          END

        ELSE DO
          MSG('$FATAL ERROR: CLOSE.DEV GIVEN BAD UFI$')
          RETURN FALSE
          END

END CLOSE.DEV

! PROCEDURE: GETPHONE
! ARG:1 IS THE IOCS FILE NO.
! ARG:2 IS THE PORT NUMBER FROM GETCHAN
! ARG:3 IS THE APR SERIAL NUMBER
! WILL RETURN POINTER TO TELEPHONE NO. STRING
! IOCS E.O.F WILL BE THE ERROR RETURN
%GETPHONE(ARG.1,ARG.2,ARG.3)

LOCAL TMP.1,TMP.2

        LOOP DO
          WHILE R(ARG.1) # $* THEN NULL
          TMP2_GETLINE(ARG.1)
          IF SINC(@TMP.2,10)=ARG.3 THEN DO
          REPEAT ARG.2 TMP.1_GETLINE(ARG.1)
          RETURN TMP.1
          END
          END

END GETPHONE
