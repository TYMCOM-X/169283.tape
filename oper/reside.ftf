C       RESIDE.FTF
        SUBROUTINE GENERAL
C
C       THIS ROUTINE DOES ALL THE GENERAL PROCESSING FOR WIRRAP
C
        COMMON /TITLE/ TITLE(16), MODIFY(2), NEWMOD, MODFLG, WRITEIT,
     1  XMIN, XMAX, YMIN, YMAX, PICFRAM
        INTEGER TITLE
        LOGICAL MODFLG, NEWMOD, WRITEIT, PICFRAM
C
        COMMON /DTABASE/ DTABASE(9)
        INTEGER DTABASE
C
        COMMON /LIBFILE/ LIBFILE(9)
C
        COMMON /CPGLOB/ KURSOR, LINSIZ, NATCH, INLINE(270), ISTTY,
     1  HUSH, UNCOLA, IPROMP, IDFILE(5)
        LOGICAL ISTTY, HUSH, UNCOLA
C
        INTEGER DBTEST, LASTUN, NEXTUN, HELPLST(6), LOGIC(6, 6)
        LOGICAL FIRSTIM
        DATA LASTUN, HELPLST / 1, 1, 7, 8, 9, 10, 11 /
C
C       LASTUN\NEXTUN
        DATA LOGIC /
     1  0,      1,      2,      3,      3,      3,
     2  512,    1,      514,    515,    515,    515,
     3  512,    513,    514,    515,    515,    515,
     4  512,    -1,     -1,     512,    512,    512,
     5  512,    -1,     -1,     516,    512,    512,
     6  512,    -1,     -1,     516,    512,    512 /
C
C       THE LOGIC TABLE DETERMINES THE PROCESS AND LEGALITY OF THE NEXT
C       FUNCTIONAL UNIT INVOKED.  IT HAS THE INDICIES (NEXTUN, LASTUN),
C       WHERE LASTUN SPECIFIES THE LAST UNIT INVOKED, AND NEXTUN SPECIFIES
C       THE NEW UNIT INVOKED.  THESE CORRESPOND TO THE NUMBERS:
C
C       1       START(LASTUN)/QUIT(NEXTUN)
C       2       BOARD
C       3       PLUG
C       4       ENTER
C       5       DOCUMENT
C       6       CHANGE
C
C       THE PARAMETERS IN THE LOGIC TABLE HAVE THE SIGNIFIGANCE:
C
C       >500    CALL LASTUN TO VERIFY ALL CLEANUP
C       -1      ILLEGAL OPERATION
C       0       LEGAL, FILE ON COMMAND PROHIBITED
C       1       LEGAL, OPTIONAL COMMAND FILE ON COMMAND
C       2       LEGAL, LIBRARY FILE ON COMMAND REQUIRED
C       3       LEGAL, DATA-BASE FILE REQUIRED UNLESS ALREADY DEFINED, THEN
C               OPTIONAL, BUT IF SPECIFIED MUST AGREE WITH PREVIOUS FILE.
C       4       SAME AS 3, BUT AFTER GETTING FILE, MUST VERIFY THAT IT IS
C               NOT IN MODIFY MODE, AND THEN CHANGE UNIT IS ENTERED AFTER
C               OUTPUT OF AN APPROPRIATE ERRO MESSAGE.
C
    1   FORMAT(' DATA-BASE SPECIFIED LOADED, BUT "ENTER" IS ILLEGAL'/
     1  ' CONTROL IS TRANSFERED TO "CHANGE" COMMAND'/)
C
C
C
C       SET FIRST TIME FLAG = .TRUE.
        FIRSTIM = .TRUE.
C
C
C
C       LOOK UP GENERAL INSTRUCTIONS
  100   I = LPARSE(1)
        GO TO (170, 130, 140, 140, 140, 140, 140, 150, 160, 165,
     1  170) , I + 2
C
C       UNRECOGNIZED INSTRUCTION..BITCH OR RETURN
  110   IF (.NOT. FIRSTIM) RETURN
        FIRSTIM = .FALSE.
        CALL ERROR ('UNRECOGNIZED INSTRUCTION', '???')
        GO TO 100
C
C       SET FLAG THAT WE'VE SEEN AT LEAST ONE INSTRUCTION
  120   FIRSTIM = .FALSE.
C
C       LINE IS EMPTY...READ A NEW LINE
  130   CALL NEWLINE
        GO TO 100
C
C     "CAPABILITIES", "INSTRUCTIONS", "PREMIUM", "CREDIT", OR "VERSION"
  140   CALL CPINFO(I+1)
        GO TO 120
C
C       HERE IF "HUSH"
  150   HUSH = .TRUE.
        GO TO 120
C
C       HERE IF "NO HUSH"
  160   HUSH = .FALSE.
        GO TO 120
C
C       HERE IF "DO"
  165   CALL CPDO(0)
        GO TO 120
C
C
C
C       HERE IF NOT GENERAL INSTRUCTION...TRY FOR HELP
  170   I = LPARSE(2)
        GO TO (190, 120, 180, 190), I+2
C
C       GOT HELP...DO IT
  180   CALL HELP(HELPLST(LASTUN) )
        FIRSTIM = .FALSE.
        GO TO 100
C
C
C
C       TEST IF ONE OF OUR STANDARD FUNCTIONAL UNIT CALLOUTS
  190   NEXTUN = LPARSE(7)
        IF (NEXTUN) 110, 130, 200
C
C       PROCESS APPROPRIATE FUNCTIONAL UNIT
  200   IF (NEXTUN .GT. 6) GO TO 110
        FIRSTIM = .FALSE.
        JUMP = LOGIC(NEXTUN, LASTUN)
        IF(JUMP .GE. 0) GO TO 220
C
C       ILLEGAL COMMAND
  210   CALL ERROR('COMMAND ILLEGAL AT THIS TIME','ILLEGAL CMD.')
        GO TO 100
C
C       COMMAND IS NOT FLAT-OUT ILLEGAL, TEST IF CLEANUP IS REQUIRED
  220   IF (JUMP .LT. 500) GO TO 290
        I = NEXTUN - LASTUN
C
C       MUST VERIFY LAST OPERATION COMPLETED SUCCESSFULLY
        GO TO (280, 230, 240, 250, 260, 270), LASTUN
C
C       BOARD
  230   CALL BOARD(.TRUE., I)
        GO TO 280
C
C       PLUG
  240   CALL PLUG(.TRUE., I)
        GO TO 280
C
C       ENTER
  250   CALL ENTER(.TRUE., I)
        GO TO 280
C
C       DOCUMENT
  260   CALL DOCMENT(.TRUE., I)
        GO TO 280
C
C       CHANGE
  270   CALL CHANGE(.TRUE., I)
C
C       VERIFIED...REMOVE VERIFICATION TEST FROM JUMP
  280   JUMP = JUMP - 512
C
C       NOW DETERMINE WHAT FILE CHECKING TO DO
  290   I = LPARSE(8)
        IF (I .LT. 0) GO TO 300
        IF (I .GT. 1) GO TO 300

       IF (JUMP .EQ. 0) GO TO (410, 300), I+1
        GO TO (310, 320, 330, 330), JUMP
C
C       ERROR IN COMMAND
  300   CALL ERROR ('SYNTAX ERROR IN COMMAND', 'SYNTAX')
        GO TO 100
C
C       HERE IF OPTIONAL COMMAND FILE IS LEGAL
  310   IF (DTABASE(5) .NE. 0) GO TO 210
        IF (I .EQ. 1) CALL CPDO(0)
        GO TO 410
C
C       HERE IF REQUIRED LIBRARY FILE NAME
  320   GO TO (300, 340), I+1
C
C       HERE IF DATABASE FILE
  330   IF (I .NE. 0) GO TO 340
        IF (DTABASE(5) .EQ. 0) 300, 410
C
C       HERE FOR FILE EVALUATION
  340   IF (LOOKFN(I) ) GO TO 350
        CALL ERROR ('SYNTAX ERROR IN FILE NAME', 'FILE SYNTAX')
        GO TO 100
C
C       WE'VE GOT A FILE NAME, DECIDE HOW TO VERIFY IT
  350   GO TO (360, 380, 380), JUMP-1
C
C       HERE FOR LIBRARY FILE
  360   I = LIBTEST(1)
        GO TO (410, 120, 100), I
C
C       HERE FOR DATA-BASE FILE
  380   J = DBTEST(2)
        GO TO (390, 120, 100), J
C
C       NOW GET IN THE DATA-BASE
  390   IF (DBREAD(I) ) 400, 100
C
C       DETERMINE IF NEED TO VERIFY THE USAGE
  400   IF (JUMP .NE. 4) GO TO 410
        IF (.NOT. MODFLG) GO TO 410
        TYPE 1
        NEXTUN = 6
C
C       DONE...ENTER NEW FUNCTIONAL UNIT
  410   LASTUN = NEXTUN
        UNCOLA = .FALSE.
        GO TO (420, 430, 440, 450, 460, 470), NEXTUN
C
C       QUITING
  420   CALL QUIT
C
C       BOARD
  430   CALL BOARD(.FALSE., 0)
        GO TO 120
C
C       PLUG
  440   CALL PLUG(.FALSE., 0)
        GO TO 120
C
C       ENTER
  450   CALL ENTER(.FALSE., 0)
        GO TO 120
C
C       DOCUMENT
  460   CALL DOCMENT(.FALSE., 0)
        GO TO 120
C
C       ENTER
  470   CALL CHANGE(.FALSE., 0)
        GO TO 120
        END
        SUBROUTINE HELP(N)
C
C       THIS ROUTINE OUTPUTS THE N-TH HELP TEXT,
C       THEN KEEPS INPUTTING AND WRITING FIRST HELP TEXT,
C       UNTIL NO MORE HELPS ARE ENCOUNTERED.
C       RETURNS WITH NEW COMMAND IN INLINE.
C
        I = N
  100   CALL CPINFO(I)
        I = 1
C
C       PROMPT AND INPUT NEW LINE...IF "HELP" DO IT AGAIN
        CALL NEWLINE
        IF (LPARSE(2) .EQ. 1) GO TO 100
        RETURN
        END
        SUBROUTINE ERROR(TEXT, TEXT1)
C
C       THIS ROUTINE PRINTS THE SOURCE LINE IF NECESSARY, MARKS THE
C       ERROR, AND THEN OUTPUTS THE ERROR TEXT.  IT THEN PROMPTS AS
C       NECESSARY, AND THEN INPUTS A NEW LINE BEFORE RETURNING.
C
        INTEGER TEXT(1), TEXT1(1)
C
        COMMON /CPGLOB/ KURSOR, LINSIZ, NATCH, INLINE(270), ISTTY, HUSH,
     1  UNCOLA, IPROMP, IDFILE(5)
        LOGICAL ISTTY, HUSH, UNCOLA
C
        COMMON /OWNPRM/ PRMPCP, UNPROMP, JPROM
        LOGICAL PRMPCP, UNPROMP
C
    1   FORMAT (80A1)
C
C       DETERMINE IF SOURCE IS TO BE ECHO'ED
        I = 1H+
        IF (ISTTY) GO TO 100
C
C       MAYBE...NOT FROM TTY
        IF (.NOT.HUSH) GO TO 100
C
C       PRINT IT...FIRST DETERMINE IF MUST PROMPT
        CALL PROMPT
        CALL R TO A
        TYPE 1, I, (INLINE(I), I = 1, LINSIZ)
        I = 1H 
C
C       BLANK OUT THE LINE, MARK ERROR
  100   CALL BLANK
        INLINE(1) = I
        LINSIZ = KURSOR + NATCH + 1
        IF (.NOT. HUSH ) LINSIZ = LINSIZ + 6
        INLINE(LINSIZ) = 1H^
        TYPE 1, (INLINE(I), I = 1, LINSIZ)
C
C       NOW COPY THE ERROR MESSAGE AND OUTPUT IT
        CALL BLANK
        LINSIZ = 2
C
C       DETERMINE IF SHORT FORM ERROR MESSAGE
        IF (HUSH) GO TO 110
C
C       LONG FORM
        CALL BUFOUT('**ERROR**')
        CALL BUFOUT(TEXT(1) )
        CALL BUFOUT('...PLEASE REENTER')
        GO TO 120
C
C       HERE FOR SHORT FORM
  110   CALL BUFOUT(TEXT1(1) )
C
C       CLEAN UP
  120   CALL BUFOUT("050000000000)
        CALL TYPE
C
C       NOW INPUT A NEW LINE AND PROMPT AS NECESSARY
        CALL NEWLINE
        RETURN
        END
        SUBROUTINE WHY (TEXT)
C
C       THIS ROUTINE OUTPUTS TEXT IF CURRENT LINE IS "WHY"
C
        DIMENSION TEXT(1)
C
        IF (LPARSE(46) .NE. 1) RETURN
        CALL BLANK
        CALL BUFOUT("200000000000)
        CALL BUFOUT(TEXT(1) )
        CALL BUFOUT("050000000000)
        CALL TYPE
C
C       NOW INPUT A LINE TO RETURN
        CALL NEWLINE
        RETURN
        END
        FUNCTION IEDIT(ALL)
C
C       THIS ROUTINE OUTPUTS THE MESSAGE "OK ?" AND ANALIZES INPUT
C       IF .ALL. IS .TRUE., ACCEPT THE FOLLOWING:
C
C       INPUT   RETURN
C
C      *<C/R>   1
C      *YES     1
C      *NO      2
C       EDIT    2
C       INSERT  3
C       DELETE  4
C       REPLACE 5
C
C       IF .ALL. IS .FALSE., ONLY THOSE MARKED * ARE VALID
C
        LOGICAL ALL
C
    1   FORMAT('+' / ' OK? :' $ )
    2   FORMAT( ' ???: ' $ )
C
C       SET UP FOR NULL INPUT, TYPE AND GET RESPONSE
        IEDIT = 1
        TYPE 1
        IF (.NOT. FETCHL(I) ) RETURN
C
C       NOT BLANK...PARSE IT
  100   I = LPARSE(47)
        GO TO (160, 120, 110, 110, 130, 130, 130, 150, 160), I+2
C
C       VALID...RETURN INDEX
  110   IEDIT = I
  120   RETURN
C
C       MAY BE OK.. TEST .ALL.
  130   IF (ALL) GO TO 110
C
C       ELSE BITCH
  140   TYPE 2
        IF (.NOT. FETCHL(I) ) GO TO 120
        CALL WHY ('INPUTS ARE YES/NO')
        GO TO 100
C
C       "EDIT"...TEST
  150   I = 2
        IF (ALL) 110, 140
C
C       UNKNOWN
  160   IF (.NOT. ALL) GO TO 140
        TYPE 2
        IF (.NOT. FETCHL(I) ) GO TO 120
        CALL WHY ('INPUTS ARE YES/NO/EDIT/INSERT/DELETE/REPLACE')
        GO TO 100
        END
        SUBROUTINE TYPE
C
C       THIS ROUTINE TYPES OUT THE LINE IN INLINE, TRANSLATING IT FIRST
C
        COMMON /CPGLOB/ KURSOR, LINSIZ, NATCH, INLINE(270), ISTTY, HUSH,
     1  UNCOLA, IPROMP, IDFILE(5)
        LOGICAL ISTTY, HUSH, UNCOLA
C
    1   FORMAT (72A1/)
C
C       FIRST TRANSLATE THE LINE
        CALL R TO A
C
        TYPE 1, (INLINE(I), I = 1, LINSIZ)
        CALL BLANK
        RETURN
        END
        SUBROUTINE TCONCAT
C
C       THIS ROUTINE TYPES OUT THE LINE IN INLINE, TRANSLATING IT FIRST
C       THE LINE WILL BE PREFIXED WITH A "+" AND HAVE NO LINE-FEED
C
        COMMON /CPGLOB/ KURSOR, LINSIZ, NATCH, INLINE(270), ISTTY, HUSH,
     1  UNCOLA, IPROMP, IDFILE(5)
        LOGICAL ISTTY, HUSH, UNCOLA
C
        INTEGER FORM(3)
    1   FORMAT ('(1H+,',I3,'A1, $ )' )
C
C       FIRST TRANSLATE THE LINE
        CALL R TO A
C
C       BUILD THE FORMAT STATEMENT
        ENCODE (15, 1, FORM(1) ), LINSIZ
C
        TYPE FORM, (INLINE(I), I = 1, LINSIZ)
        CALL BLANK
        RETURN
        END
        SUBROUTINE R TO A
C
C       THIS ROUTINE TRANSLATE INLINE FROM R-FORMAT TO A-FORMAT
C
        COMMON /CPGLOB/ KURSOR, LINSIZ, NATCH, INLINE(270), ISTTY, HUSH,
     1  UNCOLA, IPROMP, IDFILE(5)
        LOGICAL ISTTY, HUSH, UNCOLA
C

        DO 100 I = 1, LINSIZ
  100   INLINE(I) = MCNGCH(INLINE(I), 0, 2)
        RETURN
        END
        LOGICAL FUNCTION GETREAL(X)
C
C       THIS FUNCTION GETS A REAL NUMBER FROM INLINE, VERIFIES IT
C       IF GOOD, SETS X = IT, RETURNS .TRUE.
C       IF BAD, BITCHES, RETURNS .FALSE., NEW LINE IN INLINE
C
C       GET THE NUMBER
        I = LOOKRL(Y)
        IF (I .EQ. 1) GO TO 100
        IF (I .EQ. 4) GO TO 100
C
C       GOOD
        X = Y
        GETREAL = .TRUE.
        RETURN
C
C       BAD
  100   CALL ERROR('INVALID REAL NUMBER','BAD NO.')
        GETREAL = .FALSE.
        RETURN
        END
        SUBROUTINE BUFOUT ( TEXT )
C
C       THIS ROUTINE COPIES TEXT INTO INLINE UNTIL ENCOUNTERS
C       A ZERO BYTE
C
        COMMON /CPGLOB/ KURSOR, LINSIZ, NATCH, INLINE(270), ISTTY, HUSH,
     1  UNCOLA, IPROMP, IDFILE(5)
        LOGICAL ISTTY, HUSH, UNCOLA
C
        INTEGER TEXT(1)
C
C       DO IT
        I = 0
C
C       GET A CHAR AND TEST
  100   I = I + 1
        J = MGETCH(I, TEXT(1) )
        IF ( J .EQ. 0 ) RETURN
C
C       NOT ZERO, SO PUT IT AWAY
        INLINE(LINSIZ) = J
        IF (LINSIZ .GE. 270) RETURN
        LINSIZ = LINSIZ + 1
        GO TO 100
        END
        SUBROUTINE BUFN(TEXT, N)
C
C       THIS ROUTINE COPIES N CHARS OF TEXT INTO INLINE UNLESS ENCOUNTERS
C       A ZERO BYTE
C
        COMMON /CPGLOB/ KURSOR, LINSIZ, NATCH, INLINE(270), ISTTY, HUSH,
     1  UNCOLA, IPROMP, IDFILE(5)
        LOGICAL ISTTY, HUSH, UNCOLA
C
        INTEGER TEXT(1)
C
C       GET A CHAR AND TEST
        DO 100 I = 1, N
        J = MGETCH(I, TEXT(1) )
        IF ( J .EQ. 0 ) RETURN
C
C       NOT ZERO, SO PUT IT AWAY
        INLINE(LINSIZ) = J
        IF (LINSIZ .GE. 270) RETURN
  100   LINSIZ = LINSIZ + 1
        RETURN
        END
        SUBROUTINE BLANK
C
C       THIS ROUTINE BLANKS OUT INLINE IN BOTH A AND R FORMAT
C
        COMMON /CPGLOB/ KURSOR, LINSIZ, NATCH, INLINE(270), ISTTY, HUSH,
     1  UNCOLA, IPROMP, IDFILE(5)
        LOGICAL ISTTY, HUSH, UNCOLA
C       DO IT
        DO 100 I = 1, 270
  100   INLINE(I) = "200000000040
        LINSIZ = 1
        RETURN
        END
        SUBROUTINE ANOTHER
C
C       THIS ROUTINE DETERMINES IF THE CURRENT LINE IS EMPTY,
C       AND READS IN ANOTHER LINE IF SO
C
        CALL NOWCH(1, KANDO)
        IF (KANDO) RETURN
C
C       LINE IS EMPTY...GET A NON-NULL LINE
        CALL NEWLINE
        RETURN
        END
        SUBROUTINE NEWLINE
C
C       THIS ROUTINE READS IN A NON-NULL LINE
C
C       GET A NON-NULL LINE
  100   CALL PROMPT
        IF (.NOT. FETCHL(KANDO) ) GO TO 100
        RETURN
        END
        SUBROUTINE PROMPT
C
C       THIS ROUTINE PUTS OUT THE PROGRAM PROMPT
C
        COMMON /CPGLOB/ KURSOR, LINSIZ, NATCH, INLINE(270), ISTTY, HUSH,
     1  UNCOLA, IPROMP, IDFILE(5)
        LOGICAL ISTTY, HUSH, UNCOLA
C
        COMMON /OWNPRM/ PRMPCP, UNPROMP, JPROM
        LOGICAL UNPROMP, PRMPCP
C
    1   FORMAT (1H+, I4, 2H!  $ )
C
C       TEST IF TO OUTPUT THE GENERAL PROMPT
        IF (PRMPCP) CALL CPPROM
        IF (PRMPCP) RETURN
C
C       OUTPUT OWN PROMPT
C
C       TEST IF TO UPDATE PROMPT NUMBER
        IF (.NOT. UNPROMP) JPROM = JPROM + 1
        UNPROMP = .TRUE.
C
C       OUTPUT PROMPT
        IF (.NOT. HUSH) TYPE 1, JPROM
        RETURN
        END
        SUBROUTINE SOPM
C
C       SET OWN PROMPT
C
        COMMON /OWNPRM/ PRMPCP, UNPROMP, JPROM
        LOGICAL UNPROMP, PRMPCP
C
C       CLEAR CP PROMPT FLAG, SET OUR OWN
        PRMPCP = .FALSE.
        UNPROMP = .FALSE.
        JPROM = 0
        RETURN
        END
        SUBROUTINE ROPM
C
C       RESET OWN PROMPT
C
        COMMON /OWNPRM/ PRMPCP, UNPROMP, JPROM
        LOGICAL UNPROMP, PRMPCP
C
C       CLEAR OUR OWN PROMPT FLAG, SET CP
        PRMPCP = .TRUE.
        RETURN
        END
        SUBROUTINE WCLOSE(FILE)
C
C       CLOSE THE FILE IF IT IS FLAGGED AS BEING OPEN
C
        INTEGER FILE(7)
C
C       TEST IF TO CLOSE IT
        IF (FILE(4) ) CLOSE(FILE(1) )
        FILE(4) = .FALSE.
        RETURN
        END
        SUBROUTINE WOPEN(FILE)
C
C       OPEN THE FILE IF IT IS NOT FLAGGED AS BEING OPEN
C
        INTEGER FILE(7)
C
C       EXIT IF OPEN
        IF (FILE(4) ) RETURN
C
C       THEN OPEN IT, AND RETURN
        CALL MOPEN(FILE(1) )
        FILE(4) = .TRUE.
        RETURN
        END
        LOGICAL FUNCTION PACK(BUFFER, NCHAR, SPAN)
C
C       THIS FUNCTION INPUTS UP TO NCHAR CHARACTERS FROM THE INPUT
C       BUFFER, AND PACKS THEM INTO BUFFER.  CHARACTERS INPUT INCLUDE
C       ALL ALPHA-NUMERIC, AS WELL AS ANY CHARACTERS IN THE STRING
C       SPAN.  TERMINATION OCCURS ON BLANK, OR END OF LINE.
C
        INTEGER BUFFER(1), SPAN(1)
        LOGICAL MATCH, KANDO, ALPHANO
C
C       COMPUTE HOWMANY WORDS IN BUFFER...CLEAR THEM
        I = (NCHAR + 4)/5
        DO 100 J = 1, I
  100   BUFFER(J) = 0
C
C       POINT AT FIRST CHARACTER, RETURN .FALSE. IF NOT POSSIBLE
        PACK = .FALSE.
        I = NOWCH(1, KANDO)
        IF ( .NOT. KANDO ) RETURN
C
C       COPY THE TEXT, UNTIL DONE
        DO 120 J = 1, NCHAR
        I = NOWCH(5, KANDO)
        IF ( .NOT. KANDO) RETURN
        IF ( I .EQ. "40 ) RETURN
        IF (ALPHANO(I) ) GO TO 110
        IF ( .NOT. MATCH(I, SPAN(1) ) ) RETURN
C
C       FOUND A VALID CHARACTER FOR STRING..PACK IT AND CONTINUE
  110   CALL MPUTCH(I, J, BUFFER(1) )
        I = NEXTCH(5, KANDO)
C
C       GOT ONE CHARACTER...SET TO RETURN .TRUE.
  120   PACK = .TRUE.
C
C       WE'VE GOTTEN ALL THE CHARACTERS REQUIRED..IS THE NEXT ONE A TERMINATOR
        I = NEXTCH(5, KANDO)
        IF ( .NOT. KANDO) RETURN
        IF ( I .EQ. "40 ) RETURN
        IF (ALPHANO(I) ) GO TO 130
        IF (.NOT. MATCH(I, SPAN(1) ) ) RETURN
C
C       NOT VALID TERMINATOR...ERROR EXIT
  130   PACK = .FALSE.
        RETURN
        END
        LOGICAL FUNCTION MATCH(CHAR, STRING)
C
C       MATCH TAKES CHAR ( IN R1 FORMAT ) AND COMPARES IT WITH THE LIST
C       SPECIFIED BY STRING.  STRING IS TERMINATED BY A 0 OR A BLANK.
C       MATCH RETURNS .TRUE. IF SUCCESSFUL MATCH, ELSE RETURNS .FALSE.
C
        INTEGER CHAR, STRING(1)
C
C       SET TO 0-TH CHAR, ASSUME FAILURE
        I = 0
        MATCH = .FALSE.
C
C       GET AND CHECK OUT NEXT CHARACTER IN STRING
  100   I = I + 1
        J = MGETCH(I, STRING(1) )
        IF (J .EQ. 0 ) RETURN
        IF (J .EQ. "40) RETURN
        IF ( J .NE. CHAR ) GO TO 100
C
C       HAVE FOUND MATCH WITH CHAR...RETURN .TRUE.
        MATCH = .TRUE.
        RETURN
        END
        SUBROUTINE BUFSTR(BUFFER, NCHAR, STRING)
C
C       THIS ROUTINE COPIES (APPENUCCESSIVE CHARACTERS FROM STRING
C       ONTO THE BUFFER, STARTING AT THE NCHAR POSITION, AND UPDATING
C       NCHAR AS NECESSARY.  IT QUITS WHEN A BLANK OR 0 CHARACTER IS 
C       IN STRING
C
        INTEGER BUFFER(1), STRING(1)
C
C       MOVE CHARACTERS AS NECESSARY
        I = 1
  100   J = MGETCH(I, STRING)
        IF ( J .EQ. 0 ) RETURN
        IF ( J .EQ. "40 ) RETURN
C
C       THIS CHARACTER IS VALID...PACK IT AND UPDATE POINTERS
        CALL MPUTCH (J, NCHAR, BUFFER)
        I = I + 1
        NCHAR = NCHAR + 1
        GO TO 100
        END
        SUBROUTINE STRBUF(BUFFER, NCHAR, STRING)
C
C       THIS ROUTINE COPIES (APPENDS) SUCCESSIVE CHARACTERS FROM STRING
C       ONTO THE BUFFER, STARTING AT THE NCHAR POSITION, AND UPDATING
C       NCHAR AS NECESSARY.  IT QUITS WHEN A BLANK OR 0 CHARACTER IS 
C       IN STRING.  ******NOTE******STRBUF STARTS AT CHAR **2** OF STRING.
C
        INTEGER BUFFER(1), STRING(1)
C
C       MOVE CHARACTERS AS NECESSARY
        I = 2
  100   J = MGETCH(I, STRING)
        IF ( J .EQ. 0 ) RETURN
        IF ( J .EQ. "40 ) RETURN
C
C       THIS CHARACTER IS VALID...PACK IT AND UPDATE POINTERS
        CALL MPUTCH (J, NCHAR, BUFFER)
        I = I + 1
        NCHAR = NCHAR + 1
        GO TO 100
        END
        SUBROUTINE BUMPIT(LIST)
C
C       THIS ROUTINE IS USED TO INCREMENT THE LAST CHARACTER IN LIST
C
        DIMENSION LIST(1)
C
C       FIND THE LAST CHARACTER
        I = 1
  100   J = MGETCH(I+1, LIST(1) )
        IF (J .EQ. 0) GO TO 110
        IF (J .EQ. "40) GO TO 110
        I = I + 1
        GO TO 100
C
C       FOUND LAST ONE..INCREMENT IT
  110   J = MGETCH(I, LIST(1) ) + 1
        CALL MPUTCH(J, I, LIST(1) )
        RETURN
        END
        SUBROUTINE RTRUNC (NCHAR, LIST)
C
C       LIST CONTAINS NCHARS IN A FLOATING-POINT REPRESENTATION
C       TRAILING ZEROS ARE DELETED (TO RIGHT OF "."), THEN LIST IS LEFT-
C       PACKED.
C
        INTEGER LIST(1)
C
C       SCAN FOR TRAILING ".", NON-ZERO DIGIT
        DO 100 I = NCHAR, 1, -1
         J = MGETCH(I, LIST(1) )
         IF (J .EQ. "56) GO TO 110
         IF (J .GT. "71) GO TO 100
         IF (J .GT. "60) GO TO 110
         IF (J .EQ. "60) CALL MPUTCH(0, I, LIST(1) )
  100    CONTINUE
C
C       NOW LEFT-PACK IT
  110   CALL DBLANK(NCHAR, LIST(1) )
        RETURN
        END
        SUBROUTINE DBLANK(NCHAR, LIST)
C
C       DELETE BLANKS FOR NCHAR OF LIST, PAD WITH TRAILING ZEROS
C
        DIMENSION LIST(1)
C
C       SET UP AND SCAN
        I = 1
        J = 1
  100   K = MGETCH(I, LIST(1) )
        IF (K .EQ. 0) GO TO 110
        IF (K .EQ. "40) GO TO 110
        CALL MPUTCH(K, J, LIST(1) )
        J = J + 1
  110   I = I + 1
        IF (I .LE. NCHAR) GO TO 100
C
C       FILL WITH ZEROS
  120   IF (J .GT. NCHAR) RETURN
        CALL MPUTCH(0, J, LIST(1) )
        J = J + 1
        GO TO 120
        END
        INTEGER FUNCTION DBTEST(NFOK)
C
C       THIS ROUTINE TESTS FOR VALID DATA-BASE FILES, DEPENDING ON NFOK.
C       NFOK HAS THE FOLLOWING VALUES...
C
C       1       NEW FILE OK (HENCE NAME)
C       2       FILE MUST EXIST (OLD FILE ONLY)
C       3       FILE NAMES MAY DIFFER FROM PREVIOUS DTABASE
C
C       THIS ROUTINE CALLS IOTEST, AND EVALUATES THE STATE OF THE FILE.
C       IT MAY ACCEPT THE FILE, REFUSE IT, OR ABORT.
C       IF ACCEPTED, DTABASE REFLECTS THE NEW FILE USAGE.
C
C       RETURNS THE VALUES...
C
C       1       ACCEPTED
C       2       REJECTED
C       3       ERROR OCCURED, NEW LINE IN BUFFER
C
        COMMON /CPGLOB/ KURSOR, LINSIZ, NATCH, INLINE(270), ISTTY,
     1  HUSH, UNCOLA, IPROMP, IDFILE(5)
C
        COMMON /DTABASE/ DTABASE(9)
        INTEGER DTABASE
C
    1   FORMAT(' NEW FILE...TYPE C/R TO ACCEPT: ' $ )
    2   FORMAT(' OLD FILE...TYPE C/R TO ACCEPT: ' $ )
    3   FORMAT(' ***ERROR***TOO MANY FILES IN USE...ABORTING')
    4   FORMAT(' ***ERROR***FILE BAD ON DISK...ABORTING')
    5   FORMAT(' ***ERROR***SYSTEM ERROR...ABORTING')
        IF (DTABASE(5) .EQ. 0) GO TO 130
        IF (NFOK .EQ. 3) GO TO 130
C
C       FILE NAMES MUST AGREE...VERIFY
        DO 100 I = 1, 5
         IF (DTABASE(I+4) .NE. IDFILE(I) ) GO TO 110
  100    CONTINUE
C
C       HERE IF SUCCESSFUL MATCH...RETURN ACCEPTED
        DBTEST = 1
        RETURN
C
C       MATCH FAILED...BITCH AND RETURN ERROR
  110   CALL ERROR('FILE CONFLICTS WITH EXISTING DATA-BASE',
     1          'NOT PRESENT DATA-BASE')
C
C       ERROR RETURN
  120   DBTEST = 3
        RETURN
C
C       FIND THE FILE STATUS
  130   I = IOTEST(I)
C
C       FAN OUT OVER CONDITION OF FILE
        GO TO (150, 140, 140, 140, 140, 170, 220, 250, 260, 230, 240), I
C
C       FILE PROTECTED
  140   CALL ERROR ('FILE PROTECTED', 'READ ONLY')
        GO TO 120
C
C       FILE DOES NOT NOW EXIST
  150   IF (NFOK .EQ. 2) GO TO 210
C
C       NEW FILE
        TYPE 1
        GO TO 180
C
C       OLD FILE
  170   IF (NFOK .EQ. 2) GO TO 190
        TYPE 2
C
C       DETERMINE IF ACCEPT OR REJECT
  180   IF (.NOT. FETCHL(I) ) GO TO 190
C
C       REJECTED
        DBTEST = 2
        RETURN
C
C       ACCEPTABLE...SET NEW FILE NAME
  190   DBTEST = 1
        DO 200 I = 1, 5
  200    DTABASE(I+4) = IDFILE(I)
        RETURN
C
C       NON-EXISTANT INPUT FILE
  210   CALL ERROR('FILE DOES NOT EXIST', 'NEW FILE')
        GO TO 120
C
C       MAX NUMBER OF FILES NOW OPEN
  220   TYPE 3
        CALL EXIT
C
C       FILE BAD ON DISK
  230   TYPE 4
        CALL EXIT
C
C       SYSTEM ERROR
  240   TYPE 5
        CALL EXIT
C
C       INVALID USER NAME
  250   CALL ERROR('INVALID USER NAME', 'BAD USER')
        GO TO 120
C
C       FILE BUSY
  260   CALL ERROR('FILE BUSY', 'FILE BUSY')
        GO TO 120
        END
        INTEGER FUNCTION OUTTEST(WIT, BCD)
C
C       THIS ROUTINE TESTS FOR VALID WITNESS FILES.
C
C       THIS ROUTINE CALLS IOTEST, AND EVALUATES THE STATE OF THE FILE.
C       IT MAY ACCEPT THE FILE, REFUSE IT, OR ABORT.
C       IF ACCEPTED, WITNESS(IF WIT .TRUE.) OR PRINTER (IF WIT .FALSE.)
C       REFLECTS THE NEW FILE USAGE.
C
C       IF BCD IS .TRUE. THE FILE IS OPENED AS A BCD OUTPUT FILE
C
C       RETURNS THE VALUES...
C
C       1       ACCEPTED
C       2       REJECTED
C       3       ERROR OCCURED, NEW LINE IN BUFFER
C
        LOGICAL WIT, BCD
C
        COMMON /CPGLOB/ KURSOR, LINSIZ, NATCH, INLINE(270), ISTTY,
     1  HUSH, UNCOLA, IPROMP, IDFILE(5)
C
        COMMON /PRINTER/ PRINTER(9)
        INTEGER PRINTER
C
        COMMON /WITNESS/ WITNESS(9)
        INTEGER WITNESS
C
    1   FORMAT(' NEW FILE...TYPE C/R TO ACCEPT: ' $ )
    2   FORMAT(' OLD FILE...TYPE C/R TO ACCEPT: ' $ )
    3   FORMAT(' ***ERROR***TOO MANY FILES IN USE...ABORTING')
    4   FORMAT(' ***ERROR***FILE BAD ON DISK...ABORTING')
    5   FORMAT(' ***ERROR***SYSTEM ERROR...ABORTING')
C
C       FIND THE FILE STATUS
        I = IOTEST(I)
C
C       FAN OUT OVER CONDITION OF FILE
        GO TO (120, 100, 100, 100, 100, 130, 170, 200, 210, 180, 190), I
C
C       FILE PROTECTED
  100   CALL ERROR ('FILE PROTECTED', 'READ ONLY')
C
C       SET ERROR CONDITION
  110   OUTTEST = 3
        RETURN
C
C       NEW FILE
  120   TYPE 1
        GO TO 140
C
C       OLD FILE
  130   TYPE 2
C
C       DETERMINE IF ACCEPT OR REJECT
  140   IF (.NOT. FETCHL(I) ) GO TO 150
C
C       REJECTED
        OUTTEST = 2
        RETURN
C
C       ACCEPTABLE...SET NEW FILE NAME
  150   OUTTEST = 1
        DO 160 I = 1, 5
         IF (WIT) WITNESS(I+4) = IDFILE(I)
         IF (.NOT. WIT) PRINTER(I+4) = IDFILE(I)
  160    CONTINUE
        IF (.NOT. BCD) RETURN
C
C       THIS IS A BCD FILE...OPEN IT
        IF (WIT) WITNESS(4) = .TRUE.
        IF (.NOT. WIT) PRINTER(4) = .TRUE.
        IF (WIT) OPEN (WITNESS(1), IDFILE, OUTPUT)
        IF (.NOT. WIT) OPEN (PRINTER(1), IDFILE, OUTPUT)
        RETURN
C
C       MAX NUMBER OF FILES NOW OPEN
  170   TYPE 3
        CALL EXIT
C
C       FILE BAD ON DISK
  180   TYPE 4
        CALL EXIT
C
C       SYSTEM ERROR
  190   TYPE 5
        CALL EXIT
C
C       INVALID USER NAME
  200   CALL ERROR('INVALID USER NAME', 'BAD USER')
        GO TO 110
C
C       FILE BUSY
  210   CALL ERROR('FILE BUSY', 'FILE BUSY')
        GO TO 110
        END
        FUNCTION LIBTEST(ICODE)
C
C       THIS ROUTINE TESTS FOR VALID LIBRARY FILES.
C
C       ICODE SPECIFIES THE TEST TO BE MADE
C
C       1       NEW FILE OK
C       2       MUST EXIST
C       3       MUST EXIST (DON'T COMMENT)
C
C       THIS ROUTINE CALLS IOTEST, AND EVALUATES THE STATE OF THE FILE.
C       IT MAY ACCEPT THE FILE, REFUSE IT, OR ABORT.
C       IF ACCEPTED, LIBFILE REFLECTS THE NEW FILE USAGE
C
C       RETURNS THE VALUES...
C
C       1       ACCEPTED  (NEW FILE;  ICODE = 3)
C       2       REJECTED  (OLD FILE;  ICODE = 3)
C       3       ERROR OCCURED, NEW LINE IN BUFFER
C
        COMMON /CPGLOB/ KURSOR, LINSIZ, NATCH, INLINE(270), ISTTY,
     1  HUSH, UNCOLA, IPROMP, IDFILE(5)
C
        COMMON /LIBFILE/ LIBFILE(9)
        INTEGER LIBFILE
C
    1   FORMAT(' NEW FILE...TYPE C/R TO ACCEPT: ' $ )
    2   FORMAT(' OLD FILE...TYPE C/R TO ACCEPT: ' $ )
    3   FORMAT(' ***ERROR***TOO MANY FILES IN USE...ABORTING')
    4   FORMAT(' ***ERROR***FILE BAD ON DISK...ABORTING')
    5   FORMAT(' ***ERROR***SYSTEM ERROR...ABORTING')
C
C       FIND THE FILE STATUS
        I = IOTEST(I)
C
C       FAN OUT OVER CONDITION OF FILE
        GO TO (120, 100, 100, 100, 100, 130, 180, 210, 220, 190, 200), I
C
C       FILE PROTECTED
  100   IF (ICODE .NE. 3) CALL ERROR ('FILE PROTECTED',
     1  'FILE PROTECTED')
C
C       SET ERROR CONDITION
  110   OUTTEST = 3
        RETURN
C
C       NEW FILE
  120   IF (ICODE .EQ. 3) LIBTEST = 1
        IF (ICODE .EQ. 3) GO TO 160
        IF (ICODE .EQ. 2) CALL ERROR ('NEW FILE...NOT ACCEPTABLE',
     1  'NEW FILE')
        IF (ICODE .EQ. 2) GO TO 110
        TYPE 1
        GO TO 140
C
C       OLD FILE
  130   IF (ICODE .EQ. 3) LIBTEST = 2
        IF (ICODE .EQ. 3) GO TO 160
        TYPE 2
C
C       DETERMINE IF ACCEPT OR REJECT
  140   IF (.NOT. FETCHL(I) ) GO TO 150
C
C       REJECTED
        OUTTEST = 2
        RETURN
C
C       ACCEPTABLE...SET NEW FILE NAME
  150   LIBTEST = 1
  160   DO 170 I = 1, 5
  170   LIBFILE(I+4) = IDFILE(I)
        RETURN
C
C       MAX NUMBER OF FILES NOW OPEN
  180   TYPE 3
        CALL EXIT
C
C       FILE BAD ON DISK
  190   TYPE 4
        CALL EXIT
C
C       SYSTEM ERROR
  200   TYPE 5
        CALL EXIT
C
C       INVALID USER NAME
  210   IF (ICODE .NE. 3) CALL ERROR('INVALID USER NAME',
     1  'BAD USER NAME')
        GO TO 110
C
C       FILE BUSY
  220   IF (ICODE .NE. 3) CALL ERROR('FILE BUSY', 'FILE BUSY')
        GO TO 110
        END
 $2lxä