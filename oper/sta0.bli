!***COPYRIGHT 1972,1973, DIGITAL EQUIPMENT CORP., MAYNARD, MASS.***
!AUTHOR: F.J. INFANTE/HPW

GLOBAL BIND STA0V=40;		!VERSION DATE: 23-JULY-1973

SWITCHES LIST;
!THIS FORWARD DECLARATION AND THE FOLLOWING ROUTINES
!WERE PRODUCED BY THE FORTRAN PROGRAM HASHGEN.F4.
!THE NUMBER IN COMMENT'S IS THE STATEMENTS LOCATION
!IN THE HASH TABLE .
FORWARD
	SCAN,		!P.27
%  1%	PUNCSTA,	!PUNCH - P.40
% 38%	CALLSTA,	!CALL - P.32
% 43%	INPUSTA,	!INPUT - P.37
% 49%	GOTOSTA,	!GOTO - P.31
% 53%	PAUSSTA,	!PAUSE - P.36
% 57%	RETUSTA,	!RETURN - P.33
% 58%	ENDSTA,		!END - P.28
% 59%	FORMSTA,	!FORMAT - P.29
% 73%	ACCESTA,	!ACCEPT - P.39
% 78%	READSTA,	!READ - P.38
% 90%	WRITSTA,	!WRITE - P.41
% 98%	CONTSTA,	!CONTINUE - P.34
%109%	ASSISTA,	!ASSIGN - P.30
%114%	STOPSTA;	!STOP - P.35
GLOBAL ROUTINE SCAN (PADDR) =
!----------------------------------------------------------------------------------------------------------
!	.PADDR= THE ADDRESS OF THE PLIT CONTAINING THE CHARACTERS TO BE SCANNED.
!----------------------------------------------------------------------------------------------------------
BEGIN
	REGISTER CX;
	PADDR_(.PADDR)<36,7>;	!THIS CODE NOT NEEDED IF PROPER POINTER IS PASSED TO SCAN
	INCR I FROM 1 TO @(@PADDR-1)*5 DO
	BEGIN
		IF (CX_SCANI(PADDR)) EQL 0 THEN RETURN VREG_0;
		IF .CX NEQ SIGCHAR THEN RETURN VREG_-1
	END;
	.VREG
END;
GLOBAL ROUTINE ENDSTA=
BEGIN
	BIND ENDPLIT= PLIT'END';
	EXTERNAL ERRLINK,LSTOUT %()%,SAVSPACE %(SIZE,LOC)%,NEWENTRY %()%;
	EXTERNAL LABLOFSTATEMENT;
	IF NOT .FLGREG<ENDFILE> THEN IF .C NEQ EOL THEN (ENTRY[1]_ENDPLIT;ERROUT(E12));
!SEMANTIC ANALYSIS BEGINS
	FLGREG<EOP>_1;
	!-----------------------------------------------------------------------------------------------------------
	!CREATE A DESTINATION FOR A BRANCH TO A LABELED END STATEMENT
	!-----------------------------------------------------------------------------------------------------------
	IF .LABLOFSTATEMENT NEQ 0 THEN RETURN ERROUT(85); !LABEL NOT PERMITTED ON END
	NAME_ IDOFSTATEMENT _ ENDDATA; NAME<RIGHT> _ SORTAB; NEWENTRY();
	.VREG
END;
GLOBAL ROUTINE FORMSTA=
BEGIN
	EXTERNAL FORMPTR,IDOFSTATMENT,NEWENTRY,CORMAN,POOL,PIN,POUT,FORMAREA;
	LOCAL NUM,LPIN,LPOUT,FORPTR,FSTPTR;
	MAP BASE T1:FORMPTR;
	BIND FORMPLIT= PLIT'FORMAT';
        IF SCAN(PLIT'AT') LSS 0 THEN (ENTRY[1]_FORMPLIT;ERROUT(E12));
	!.POOL[.POUT] CONTAINS FIRST CHARACTER OF FORMAT STRING '('
	!.PIN-(.POUT+1) IS NUM OF CHARACTERS

	SIGCHAR; QUEUE();	!POUT POINTS TO "T" OF "FORMAT"
				!ADVANCE POUT TO FIRST "(" OF FORMAT
	LPIN_.PIN; LPOUT_.POUT; !STORE PIN AND POUT OVER CALL TO FORMATSYN
        IF FORMATSYN(1) LSS 0 THEN RETURN;	!CHECK SYNTAX

!SEMANTIC ANALYSIS BEGINS

	WHILE .POOL[.LPIN] EQL #40 OR .POOL[.LPIN] EQL #11 OR .POOL[.LPIN] EQL EOL DO
	(LPIN_.LPIN-1);		!REMOVE TRAILING BLANKS AND TABS
	NUM_(.LPIN-.LPOUT)/5+1;	!COMPUTE SIZE IN WORDS
	NAME<LEFT> _ .NUM;	!SET UP CALL TO CORMAN
	FORPTR_CORMAN();	!GET CORE FOR STRING
	NAME _ IDOFSTATMENT _ FORMDATA;
	NAME<RIGHT>_SORTAB;
	T1 _ NEWENTRY();
	!
	!MAKE SURE STATEMENT IS LABELLED
	!
	IF .T1[SRCLBL] EQL 0 THEN ERROUT(70); !NOT LABELLED
	FSTPTR _ (.FORPTR-1)<0,7>; !BYTE PTR FOR FILLING IN STRING FROM POOL
	INCR I FROM .LPOUT TO .LPIN DO REPLACEI(FSTPTR,.POOL[.I]);
	T1[FORSIZ]_.NUM;
	FORMAREA _ .FORMAREA + .NUM<RIGHT>;	!ACCUMULATE TOTAL WORDS OCCUPIED BY FORMAT STRINGS
						!FOR LATER ALLOCATION USE
	T1[FORSTRING] _ .FORPTR;
	IF .FORMPTR EQL 0 THEN FORMPTR<LEFT>_FORMPTR<RIGHT>_.T1
		ELSE (FORMPTR[FMTLINK]_.T1; FORMPTR<RIGHT>_.T1);
	.VREG
END;
GLOBAL ROUTINE ASSISTA=
BEGIN
	EXTERNAL SAVSPACE %(SIZE,LOC)%,BLDVAR %(VPNT)%,NEWENTRY %()%, ASIPTR,TBLSEARCH %()%,STK,TYPE;
	MAP BASE ASIPTR;REGISTER BASE R1:R2;
	MACRO
	ELMNT=0,0,FULL$,ELMNT1=0,1,FULL$;
	BIND ASSIPLIT= PLIT'ASSIGN';
        IF SCAN(PLIT'GN') LSS 0 THEN (ENTRY[1]_ASSIPLIT;ERROUT(E12));
        IF SYNTAX(ASSIGN) LSS 0 THEN RETURN -1;
!SEMANTIC ANALYSIS BEGINS
	!--------------------------------------------------------------------------------
	!THE ABOVE CALL TO SYNTAX LEAVES A LIST POINTER ON THE STACK (STK[0]).
	!THE POINTER POINTS TO THE LIST:
	!
	!CONSTANT (21^18+LOC) - INTEGER CONSTANT REPRESENTING THE LABEL TO BE ASSIGNED
	!VARIABLESPEC - POINTER TO SCALAR OR ARRAY ELEMENT
	!--------------------------------------------------------------------------------
	R1_.STK[0];	!R1_LIST POINTER
	R2_.R1[ELMNT];	!R2_LOC (CONSTANT)
	IF .R2[VALTYPE] NEQ INTEGER THEN (RETURN ERROUT(E17))
		ELSE IF .R2[CONST2] GTR 99999 THEN (RETURN ERROUT(E19));
	ENTRY[0]_ .R2[CONST2]; !CONSTANT TO BE CONVERTED TO LABEL
	NAME_LABTAB; STK[1]_TBLSEARCH(); TYPE_1;
	IF(STK[2]_R2_BLDVAR(.R1[ELMNT1])) LSS 0 THEN RETURN .VREG;R2[IDATTRIBUT(INASSI)]_1;
	NAME_IDOFSTATEMENT_ASSIDATA;NAME<RIGHT>_SORTAB;R2_NEWENTRY();
	R2[ASILBL]_@STK[1];R2[ASISYM]_@STK[2];SAVSPACE(.R1<LEFT>,@R1);
	IF .ASIPTR<LEFT> EQL 0 THEN ASIPTR<LEFT>_ASIPTR<RIGHT>_@R2
		ELSE
		BEGIN
			ASIPTR[ASILINK]_@R2;ASIPTR<RIGHT>_@R2
		END;
	.VREG
END;
GLOBAL ROUTINE GOTOSTA=
BEGIN
	EXTERNAL SAVSPACE %(SIZE,LOC)%,TBLSEARCH %()%,NEWENTRY %()%,STK,BLDVAR %(VPNT)%;
	EXTERNAL EXPRTYPER,CNVNODE; !DOES TYPE CONVERSION IF NECESSARY
	MAP BASE T1:T2; REGISTER BASE R1:R2;
	MACRO
	ELMNT=0,0,FULL$,ELMNT1=0,1,FULL$,ELMNT2=0,2,FULL$;
	ROUTINE LABELLIST (LPNT)=
	BEGIN
		NAME_LABTAB;
		INCR LLST FROM @LPNT TO @LPNT+.LPNT<LEFT>DO
		BEGIN
			MAP BASE LLST;T1_.LLST[ELMNT];
			IF .T1[VALTYPE] NEQ INTEGER THEN (RETURN ERROUT(E17))
				ELSE IF .T1[CONST2] GTR 99999 THEN (RETURN ERROUT(E19));
			ENTRY[0]_.T1[CONST2];LLST[ELMNT]_TBLSEARCH();
		END;
	END;
	BIND GOTOPLIT= PLIT'GOTO';
        IF SYNTAX(GOTO) LSS 0 THEN RETURN -1;
!SEMANTIC ANALYSIS BEGINS
	!---------------------------------------------------------------------------------
	!THE SYNTAX ROUTINE RETURNS A POINTER IN STK[0] TO THE LIST:
	!
	!CHOICE 1 - SIMPLE GOTO
	!	CONSTANT (21^18+LOC) - VALUE OF CONSTANT IS LABEL NUMBER
	!CHOICE 2 - ASSIGNED OR COMPUTED GOTO
	!	CHOICE 1 - ASSIGNED GOTO
	!	COUNT^18+LOC - POINTER TO ASSIGNED VARIABLE AND LABEL LIST
	!	CHOICE 2 - COMPUTED GOTO
	!	COUNT^18+LOC - POINTER TO LABEL LIST AND CONTROL EXPRESSION
	!
	!SEE EXPANSION OF METASYMBOL GOTO FOR COMPLETE EXPANSION
	!---------------------------------------------------------------------------------
	R1_.STK[0];					!R1_LIST POINTER
	IF .R1[ELMNT] EQL  1 THEN			!CHOICE 1 - SIMPLE GOTO
	BEGIN
		R2_.R1[ELMNT1];				!R1_LOC (CONSTANT CONTAINING LABEL NUMBER)
		IF .R2[VALTYPE] NEQ INTEGER THEN (RETURN ERROUT(E17))
			ELSE IF .R2[CONST2] GTR 99999 THEN (RETURN ERROUT(E19));
		ENTRY[0]_.R2[CONST2];NAME_LABTAB;R2_TBLSEARCH();
		NAME_IDOFSTATEMENT_GOTODATA;NAME<RIGHT>_SORTAB;T1_NEWENTRY();
		T1[GOTOLBL]_@R2;T1[GOTONUM]_T1[GOTOLIST]_0;
		IF .T1[SRCLBL] NEQ 0
		THEN BEGIN LOCAL BASE LBL;
			LBL _ .T1[SRCLBL];
			IF .LBL[SNDOLNK] NEQ 0 THEN RETURN  ERROUT(67);
		     END;
		RETURN
	END;
	!------------------------------------------------------------------------------
	!AT THIS POINT WE HAVE EITHER A COMPUTED OR ASSIGNED GOTO.
	!R1[ELMNT1] TELLS US WHICH.  CHOICE 1 = ASSIGNED GOTO, 
	!CHOICE 2 = COMPUTED GOTO.
	!------------------------------------------------------------------------------
	R2_.R1[ELMNT2];					!R2_LOC (ASSIGNED OR COMPUTED GOTO COMPONENTS)
	IF .R1[ELMNT1] EQL 1 THEN			!ASSIGNED GOTO
	BEGIN
		IF (STK[1]_BLDVAR(.R2[ELMNT])) LSS 0 THEN RETURN .VREG;
		IF .R2[ELMNT1] NEQ 0 THEN		!ASSIGNED GOTO WITH LABEL LIST
		BEGIN
			T1_.R2[ELMNT2];STK[2]_.T1[ELMNT1];  !SKIP OPTIONAL COMMA
			IF LABELLIST(.STK[2]) LSS 0 THEN RETURN .VREG;SAVSPACE(.R2[ELMNT2]<LEFT>,.R2[ELMNT2]);
			STK[2]<LEFT> _ .STK[2]<LEFT>+1;  !INCREMENT COUNT OF LABELS
		END
		ELSE STK[2]_0;NAME_IDOFSTATEMENT_AGODATA;
	END
	ELSE
	BEGIN					!COMPUTED GOTO
		STK[2]_.R2[ELMNT];IF LABELLIST(.STK[2]) LSS 0 THEN RETURN .VREG;
		T2 _ STK[1] _.R2[ELMNT2];			!SKIP OPTIONAL COMMA
		STK[2]<LEFT> _ .STK[2]<LEFT>+1;  !INCREMENT COUNT OF LABELS
		IF .T2[VALTYPE] NEQ INTEGER THEN  STK[1] _ CNVNODE(.T2,INTEGER,0);
		NAME_IDOFSTATEMENT_CGODATA;
	END;
	SAVSPACE(.R1<LEFT>,@R1);
	NAME<RIGHT>_SORTAB;T1_NEWENTRY();
	!PTR TO LABEL		NUM OF LABELS INLIST	 PTR TO LIST
!
!SEE IF A GO TO ENDS A DO LOOP
!
	IF .T1[SRCLBL] NEQ 0
	THEN BEGIN LOCAL BASE LBL;
		LBL _ .T1[SRCLBL];
		IF .LBL[SNDOLNK] NEQ 0 THEN RETURN ERROUT(67);
	     END;
	T1[GOTOLBL]_.STK[1];T1[GOTONUM]_.STK[2]<LEFT>;T1[GOTOLIST]_.STK[2]<RIGHT>;
	T2_.T1[GOTOLBL]; IF .T2[OPRCLS] NEQ DATAOPR THEN T2[PARENT] _ .T1;
	.VREG
END;
GLOBAL ROUTINE CALLSTA=
BEGIN
	MAP BASE T1:T2;REGISTER BASE R1:R2;
	EXTERNAL STK,SAVSPACE %(SIZE,LOC)%,CORMAN %()%,NEWENTRY %()%,TBLSEARCH %()%;
	MACRO
	CARGPTR=0,0,RIGHT$,CAFLGFLD=0,0,LEFT$,
	ELMNT=0,0,FULL$,ELMNT1=0,1,FULL$,ELMNT2=0,2,FULL$,
	ERR15(X)=(ENTRY[1]_R2[IDSYMBOL];ENTRY[2]_X;RETURN ERROUT(E15))$;
	MACHOP BLT=#251;
	BIND CALLPLIT= PLIT'CALL';
	LOCAL BASE CALLNODE;
        IF SYNTAX(CALL) LSS 0 THEN RETURN -1;
!SEMANTIC ANALYSIS BEGINS
	!------------------------------------------------------------------------------------------------------------
	!THIS ROUTINE EXPECTS TO RETURN A POINTER IN STK[0] TO A SUBROUTINE NAME OPTIONALLY FOLLOWED BY AN
	!ARGUMENT LIST. SEE EXPANSION OF METASYMBOL CALL FOR DETAILS.
	!------------------------------------------------------------------------------------------------------------
	R1_.STK[0];
	R2_.R1[ELMNT];	!R2_LOC(SUBROUTINE NAME)
	IF ISNOTVAR(R2) LSS 0 THEN RETURN .VREG;
	IF .R2[OPERSP] EQL ARRAYNAME THEN ERR15(PLIT'A SUBROUTINE NAME')
		ELSE IF .R2[OPERSP] EQL FORMLARRAY THEN ERR15(PLIT'A SUBROUTINE NAME')
		ELSE IF .R2[IDATTRIBUT(COMBL)] THEN ERR15(PLIT'A SUBROUTINE NAME');
	R2[OPERSP] _ IF .R2[IDATTRIBUT(DUMMY)] THEN FORMLFN ELSE FNNAME;
	IF .R2[IDATTRIBUT(FENTRYNAME)] OR .R2[IDATTRIBUT(NOALLOC)]
	THEN RETURN (ENTRY[1] _ R2[IDSYMBOL];
			ERROUT(47)
		    );
	STK[1]_.R2;
!
!MAKE A CALL STATEMENT NODE
!
	NAME_IDOFSTATEMENT_CALLDATA;NAME<RIGHT>_SORTAB;CALLNODE _NEWENTRY();
	IF .R1[ELMNT1] NEQ 0 THEN	!ARGUMENT LIST
	BEGIN
		R2_STK[4]<0,0>;T1_@.R1[ELMNT2];
		INCR ARG FROM @T1 TO @T1+.T1<LEFT> BY 2  DO
		BEGIN
			MAP BASE ARG:R2;
			T2_.ARG[ELMNT1];
			R2[CAFLGFLD]_0;R2[CARGPTR]_.T2;
			IF .ARG[ELMNT] EQL 1 THEN	!EXPRESSION
			BEGIN
				IF .T2[OPRCLS] EQL DATAOPR 
				THEN (R2[P1AVALFLG]_1;
					   IF .T2[OPERSP] NEQ CONSTANT THEN T2[IDATTRIBUT(STORD)] _ 1
					) 
				 ELSE T2[PARENT] _ .CALLNODE;

			END
			ELSE	!STATEMENT NUMBER
			BEGIN
				IF .T2[VALTYPE] NEQ INTEGER THEN
						(RETURN ERROUT(E25));
				IF .T2[CONST2] GTR 99999 THEN (RETURN ERROUT(E19));
				NAME_LABTAB;ENTRY[0]_.T2[CONST2];R2[CARGPTR]_TBLSEARCH();R2[P1AVALFLG]_1;
			END;R2_.R2+1;
		END;T1_@.R1[ELMNT2];SAVSPACE(.T1<LEFT>,.T1); SAVSPACE(0,.R1[ELMNT2]);
		STK[3]_.R2-STK[4]; STK[3]<LEFT> _ 0;
		NAME<LEFT>_.STK[3]+2; R2_CORMAN();
		T1<LEFT>_STK[3];T1<RIGHT>_@R2+1;T2_@R2+1+.STK[3];BLT(T1,0,T2);
	END ELSE R2_0;
	CALLNODE[CALSYM]_.STK[1];CALLNODE[CALLIST]_.R2;
	FLGREG<BTTMSTFL>_0;
	SAVSPACE(.R1<LEFT>,@R1);
	.VREG
END;
GLOBAL ROUTINE RETUSTA=
BEGIN
	REGISTER BASE R1:R2;
	EXTERNAL STK,EXPRTYPER,SAVSPACE %(SIZE,LOC)%,NEWENTRY %()%;
	EXTERNAL LSAVE,LEXL,LEXNAME,EXPRES,CNVNODE;
	MACRO ERR0(X)= ( ENTRY[1]_.LEXNAME[.LEXL<LEFT>]; ENTRY[2]_X)$;
	MACRO
	ELMNT=0,0,FULL$,ELMNT1=0,1,FULL$;
	BIND RETUPLIT= PLIT'RETURN';
        IF SCAN(PLIT'RN') LSS 0 THEN (ENTRY[1]_RETUPLIT;ERROUT(E12));
	LEXL_LEXEMEGEN(); LSAVE _ -1;
	IF .LEXL<LEFT> NEQ LINEND THEN
	  (IF (STK[0] _ EXPRES()) LSS 0 THEN ERR0(PLIT'LINEND'))
		ELSE STK[0] _ 0;
!SEMANTIC ANALYSIS BEGINS
	!-----------------------------------------------------------------------------------------------------------
	!THIS ROUTINE EXPECTS SYNTAX TO RETURN IN STK[0] A POINTER TO AN OPTIONAL RETURN EXPRESSION.
	!SEE EXPANSION OF METASYMBOL RETURNSPEC FOR DETAILS.
	!-----------------------------------------------------------------------------------------------------------
	NAME_IDOFSTATEMENT_RETUDATA;NAME<RIGHT>_SORTAB;R2_NEWENTRY();
	BEGIN MAP BASE T1;
	R2[RETEXPR]_T1_.STK[0];
	IF .T1 NEQ 0
	  THEN (IF .T1[OPRCLS] NEQ DATAOPR THEN T1[PARENT] _ .R2;
		IF .T1[VALTYPE] NEQ INTEGER THEN R2[RETEXPR] _ CNVNODE(.T1,INTEGER,0);
		);
	END;
	IF .R2[SRCLBL] NEQ 0
	THEN BEGIN LOCAL BASE LBL;
		LBL _ .R2[SRCLBL];
		IF .LBL[SNDOLNK] NEQ 0 THEN RETURN ERROUT(67);
	     END;
	.VREG
END;
GLOBAL ROUTINE CONTSTA=
BEGIN
	EXTERNAL NEWENTRY;
	BIND CONTPLIT= PLIT'CONTINUE';
        IF SCAN(PLIT'INUE') LSS 0 THEN (ENTRY[1]_CONTPLIT;ERROUT(E12));
        IF LEXEMEGEN() NEQ LINEND^18 THEN
		(ENTRY[1]_.LEXNAME[.VREG<LEFT>];ENTRY[2]_PLIT'LINEND';RETURN ERROUT(E0));
	IF STACHK THEN (ENTRY[1]_CONTPLIT;RETURN ERROUT(E13));
!SEMANTIC ANALYSIS BEGINS
	NAME _ IDOFSTATEMENT _ CONTDATA; NAME<RIGHT>_SORTAB; NEWENTRY();
	.VREG
END;
GLOBAL ROUTINE LITOROCT=
BEGIN
!
!PARSES OPTIONAL [LITERAL OR CONSTANT ] AFTER STOP OR  PAUSE
!RETURNS LEXEME FOR EITHER
!
EXTERNAL OCTQ,LITQ;
LOCAL LITOCTLEX;
	LITOCTLEX _ 0;
	SIGCHAR;
	IF DIGIT(C) 
	THEN (QUEUE(); LITOCTLEX _  OCTQ(); SIGCHAR )	!OCTAL STRING
	ELSE IF .C EQL #047 %APOSTROPHE% THEN (LITOCTLEX _  LITQ(); SIGCHAR); 
	IF .C NEQ EOL THEN RETURN -1 ELSE RETURN .LITOCTLEX;
END;
GLOBAL ROUTINE STOPSTA=
BEGIN
	REGISTER BASE R1:R2;
	EXTERNAL STK,SAVSPACE %(SIZE,LOC)%,NEWENTRY %()%,LITOROCT;
	MACRO
	ELMNT=0,0,FULL$,ELMNT1=0,1,FULL$;
	BIND STOPPLIT= PLIT'STOP';
	IF (R2 _ LITOROCT()) LSS 0 THEN RETURN -1;
	NAME_IDOFSTATEMENT_STOPDATA;NAME<RIGHT>_SORTAB;R1_NEWENTRY();
	R1[STOPIDENT]_@R2;
	IF .R1[SRCLBL] NEQ 0
	THEN BEGIN LOCAL BASE LBL;
		LBL _ .R1[SRCLBL];
		IF .LBL[SNDOLNK] NEQ 0 THEN RETURN ERROUT(67);
	     END;
	.VREG
END;
GLOBAL ROUTINE PAUSSTA=
BEGIN
	REGISTER BASE R1:R2;
	EXTERNAL STK,SAVSPACE %(SIZE,LOC)%,NEWENTRY %()%,LITOROCT;
	MACRO
	ELMNT=0,0,FULL$,ELMNT1=0,1,FULL$;
	BIND PAUSPLIT= PLIT'PAUSE';
        IF SCAN(PLIT'E') LSS 0 THEN (ENTRY[1]_PAUSPLIT;ERROUT(E12));
	IF (R2 _ LITOROCT()) LSS 0 THEN RETURN -1;
	NAME_IDOFSTATEMENT_PAUSDATA;NAME<RIGHT>_SORTAB;R1_NEWENTRY();
	R1[PAUSIDENT]_.R2;
	IF .R1[SRCLBL] NEQ 0
	THEN BEGIN LOCAL BASE LBL;
		LBL _ .R1[SRCLBL];
		IF .LBL[SNDOLNK] NEQ 0 THEN RETURN ERROUT(67);
	     END;
	.VREG
END;
GLOBAL ROUTINE INPUSTA=
BEGIN
	MAP BASE T1:T2;REGISTER BASE R1:R2;
	EXTERNAL STK,SAVSPACE %(SIZE,LOC)%,BLDVAR %(VPNT)%,DATALIST %(LPNT)%,
	NEWENTRY %()%,CORMAN %()%,TYPE;
	MACRO
	ELMNT=0,0,FULL$,ELMNT1=0,1,FULL$,ELMNT2=0,2,FULL$,
	ERR15(X)=(ENTRY[1]_X;ENTRY[2]_PLIT'INTEGER';RETURN ERROUT(E15))$;
	BIND INPUPLIT= PLIT'INPUT';
	BIND READD=3;
	ENTRY[1]_INPUPLIT; ERROUT(73); !NOT YET SUPPORTED
	UNTIL .C EQL ";" %EOL% DO CHAR(); !IGNORING REST OF STATEMENT
!        IF SCAN(PLIT'T') LSS 0 THEN (ENTRY[1]_INPUPLIT;ERROUT(E12));
!        IF SYNTAX(INPUT) LSS 0 THEN RETURN -1;
!!SEMANTIC ANALYSIS BEGINS
!	!-----------------------------------------------------------------------------------------------------------
!	!THIS ROUTINE EXPECTS SYNTAX TO RETURN A POINTER IN STK[0] TO
!	!AN OPTIONAL UNIT NUMBER, WHICH MAY BE AN INTEGER CONSTANT OR VARIABLE,
!	!FOLLOWED BY A LIST OF DATAITEMS. SEE THE EXPANSION OF THE METASYMBOL
!	!INPUT FOR DETAILS.
!	!-----------------------------------------------------------------------------------------------------------
!	T1_.STK[0]; !R1_LOC(INPUT PARAMETER LIST)
!	IF .T1[ELMNT] NEQ 0 THEN !UNIT NUMBER
!	BEGIN
!		R1_.T1[ELMNT1];R2_.R1[ELMNT1]; !R2_LOC(CONSTANT OR VARIABLE)
!		IF .R1[ELMNT] EQL 1 THEN !CONSTANT
!		BEGIN
!			IF .R2[VALTYPE] NEQ INTEGER THEN ERR15(PLIT SIXBIT'UNIT');
!		END
!		ELSE !VARIABLE
!		BEGIN
!			T1_.R2[ELMNT];!T1_LOC(IDENTIFIER)
!			IF .T1[VALTYPE] NEQ INTEGER THEN ERR15(T1[IDSYMBOL]);
!			IF (R2_BLDVAR(@R2)) LSS 0 THEN RETURN .VREG;
!		END;
!		SAVSPACE(.R1<LEFT>,@R1);
!	END ELSE R2_0;
!	R1_.STK[0];TYPE_READD; !INDICATE READ MODE FOR DATALIST ROUTINE
!	IF R1 _ DATALIST(.R1[ELMNT2]) LSS 0 THEN RETURN .VREG;
!	NAME_IDOFSTATEMENT_INPUDATA;NAME<RIGHT>_SORTAB;
!	T2_NEWENTRY();
!	T2[IOUNIT]_@R2;T2[IOFORM]_0;
!	T2[IORECORD]_0;T2[IOLIST]_.R1<LEFT>;
!	T2[IOERR]_T2[IOEND]_0;SAVSPACE(.STK[0]<LEFT>,@STK[0]);
	.VREG
END;
GLOBAL ROUTINE RWBLD(NODEDATA)=
BEGIN
	MAP BASE T1:T2;REGISTER BASE R1:R2;
	EXTERNAL STK,SAVSPACE %(SIZE,LOC)%,BLDUNIT %(VPNT)%,BLDFORMAT %(FPNT)%,
		 IODOXPN,DATALIST %(LPNT)%,TYPE,CORMAN %()%,NEWENTRY %()%;
	MACRO
	ELMNT=0,0,FULL$,ELMNT1=0,1,FULL$,ELMNT2=0,2,FULL$,ELMNT3=0,3,FULL$;
	LOCAL U,R,F,ER,EN;
MAP BASE U;
%
	ROUTINE BUILDS A READ OR WRITE STATEMENT NODE 
	CALLED FROM READST OR WRITST WITH READ OR WRITE DATA
	DOESN'T RETURN ANYTHING SIGNIFICANT EXCEPT WHEN ERROR CONDITION
	THEN RETURNS -1
%
	!----------------------------------------------------------------------------------------------------------
	!THIS ROUTINE EXPECTS SYNTAX TO RETURN A POINTER IN STK[0] TO A
	!FULL UNIT SPECIFICATION (UNIT, RECORD NUMBER, FORMAT, END AND ERR) OR
	!A FORMAT SPECIFICATION (FORMAT, END AND ERR) FOLLOWED BY AN OPTIONAL
	!IO LIST.  SEE EXPANSIONS OF THE METASYMBOLS READSPEC, IOSPEC,
	!FORMAT ID AND DATAITEM FOR DETAILS.
	!----------------------------------------------------------------------------------------------------------
	R1_.STK[0];TYPE_IF .NODEDATA EQL READDATA THEN 3%READD% ELSE 4;  %WRITE%
			!SET TYPE ABOVE TO TELL DATALIST ROUTINE
			!IF LIST IS AN INPUT LIST
	IF .R1[ELMNT] EQL 1 THEN !FULL UNIT SPECIFICATION
	BEGIN
		IF BLDUNIT(.R1[ELMNT1]) LSS 0 THEN RETURN .VREG;
	END
	ELSE !FORMAT SPECIFICATION
	BEGIN
		STK[5]_STK[6]_0; !SET END,ERR TO ZERO
		R1 _.R1+1; !SET PTR TO POINT TO FORMATSPEC EXPECTED BY BLDFORMAT IN ACT1
		FLAG _ -1;	!SIGNAL BLDFORMAT NOT TO EXPECT AN END= OR ERR=
		IF BLDFORMAT (.R1) LSS 0 THEN RETURN .VREG;
		STK[2]_ IF .NODEDATA EQL READDATA THEN MAKECNST(INTEGER,0,-5) ELSE MAKECNST(INTEGER,0,-3); !READID OR PRINT ID
		 STK[3]_0;!CLEAR RECORD, INDICATE READ FROM STANDARD DEVICE
	END;
	IF .STK[3] NEQ 0 THEN R_@.STK[3] ELSE R _ 0;
	U_.STK[2];F_.STK[4];ER_.STK[5];EN_.STK[6];
	IF .R1[ELMNT2] NEQ 0 THEN	!IO LIST
	BEGIN
		R2_.R1[ELMNT3]; SAVSPACE(.R1[ELMNT3]<LEFT>,.R1[ELMNT3]);
		IF (R2 _ DATALIST(.R2[ELMNT1])) LSS 0 THEN RETURN .VREG;
	END ELSE R2_0;
	NAME _IDOFSTATEMENT_.NODEDATA;NAME<RIGHT>_SORTAB;T1_NEWENTRY();
	T1[IOUNIT]_.U;FORM]_.F;T1[IORECORD]_.R;T1[IOLIST]_.R2<LEFT>;
	T1[IOERR]_.ER;T1[IOEND]_.EN;
	IODOXPN(.T1);	!DO DOXPN FOR IOLIST
	IF .U[CONST2] LSS 0 THEN R1 _ .R1-1; !UNDO INCREMENT IF FORMAT WITHOUT A UNIT
	SAVSPACE(.R1<LEFT>,@R1);
	.VREG
END;
GLOBAL ROUTINE READSTA=
BEGIN
	MAP BASE T1:T2;REGISTER BASE R1:R2;
	EXTERNAL STK,SAVSPACE %(SIZE,LOC)%,BLDUNIT %(VPNT)%,BLDFORMAT %(FPNT)%,
		 DATALIST %(LPNT)%,TYPE,CORMAN %()%,NEWENTRY %()%;
	MACRO
	ELMNT=0,0,FULL$,ELMNT1=0,1,FULL$,ELMNT2=0,2,FULL$,ELMNT3=0,3,FULL$;
	LOCAL U,R,F,ER,EN;
	BIND READPLIT= PLIT'READ';
        IF SYNTAX(READSPEC) LSS 0 THEN RETURN -1;
!SEMANTIC ANALYSIS BEGINS
!
	RWBLD(READDATA);	!BUILD READ/WRITE NODE
	.VREG
END;
GLOBAL ROUTINE ACCESTA=
BEGIN
	REGISTER BASE R1:R2;MAP BASE T1:T2;
	EXTERNAL STK, SAVSPACE %(SIZE,LOC)%, TYPE, BLDFORMAT %(FPNT)%,DATALIST %(LPNT)%,
		 CORMAN %()%,NEWENTRY %()%,BLDIO1;
	MACRO
	ELMNT=0,0,FULL$,ELMNT1=0,1,FULL$,ELMNT2=0,2,FULL$;
	LOCAL F,EN,ER;
	BIND ACCEPLIT= PLIT'ACCEPT';
        IF SCAN(PLIT'PT') LSS 0 THEN (ENTRY[1]_ACCEPLIT;ERROUT(E12));
        IF SYNTAX(ACCEPT) LSS 0 THEN RETURN -1;
	T1 _ BLDIO1(READDATA);	!BUILD A READ NODE
	T1[IOUNIT] _ MAKECNST(INTEGER,0,-4);	!ACCEPT ID
	.VREG
END;
GLOBAL ROUTINE PUNCSTA=
BEGIN
	MAP BASE T1:T2;REGISTER BASE R1:R2;
	EXTERNAL STK,SAVSPACE %(SIZE,LOC)%,BLDFORMAT %(FPNT)%,DATALIST %(LPNT)%,
		 NEWENTRY %()%,TYPE;
	MACRO
	ELMNT=0,0,FULL$,ELMNT1=0,1,FULL$,ELMNT2=0,2,FULL$;
	LOCAL F,EN,ER;
	BIND PUNCPLIT= PLIT'PUNCH';
        IF SCAN(PLIT'H') LSS 0 THEN (ENTRY[1]_PUNCPLIT;ERROUT(E12));
        IF SYNTAX(PUNCH) LSS 0 THEN RETURN -1;
	T1 _ BLDIO1(WRITDATA);	!BUILD A WRITE (PUNCH) NODE
	T1[IOUNIT] _ MAKECNST(INTEGER,0,-2);	!PUNCH PAPER TAPE ID
	.VREG
END;
GLOBAL ROUTINE WRITSTA=
BEGIN
	MAP BASE T1:T2;REGISTER BASE R1:R2;
	EXTERNAL STK,SAVSPACE %(SIZE,LOC)%,BLDUNIT %(UPNT)%,BLDFORMAT %(FPNT)%,
		 DATALIST %(LPNT)%,CORMAN %()%,NEWENTRY %()%,TYPE;
	MACRO
	ELMNT=0,0,FULL$,ELMNT1=0,1,FULL$,ELMNT2=0,2,FULL$,ELMNT3=0,3,FULL$;
	LOCAL U,R,F,EN,ER;
	BIND WRITPLIT= PLIT'WRITE';
        IF SCAN(PLIT'E') LSS 0 THEN (ENTRY[1]_WRITPLIT;ERROUT(E12));
        IF SYNTAX(WRITESPEC) LSS 0 THEN RETURN -1;
!SEMANTIC ANALYSIS BEGINS
	RWBLD(WRITDATA);	!BUILD A WRITE IO STATEMENT NODE
	.VREG
END;
   gJ/P