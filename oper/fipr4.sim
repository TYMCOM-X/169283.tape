!21 MAR 73   FIPR4.SIM     *CW

GLOBAL.PROC(B.M.ACK,H.B.M.ACK)
GLOBAL.PROC(B.ACKP,H.B.ACKP)
GLOBAL.PROC(B.ECHO,H.B.ECHO)
GLOBAL.PROC(B.RECHO,H.B.RECHO)
GLOBAL.PROC(FILE.EXISTS,H.FILE.EXISTS)
GLOBAL.PROC(W.BLK,H.W.BLK)
GLOBAL.PROC(END.RECIP,H.END.RECIP)

FIND STORE(0)
FIND TCB.LIST
FIND LOCAL.NAME

FIND %AR.N
FIND %PUNT
FIND %BUF.LENGTH
FIND %FM.PTR
FIND %OUT.RKD
FIND %CLOSE.IT
FIND %DUP.BUF
FIND %D.AREA
FIND %R.ELMT
FIND %S.SP.AR
FIND %BLD.ARG
FIND %OUT.BUF
FIND %BLD.CMD
FIND %STR.BLD
FIND %R.P.L.DATA
FIND %L.P.L.DATA
FIND %OUT.MAP
FIND %GET.BUF.CHAR
FIND %GET.TCB
!
PROC(B.MACK,H.B.MACK,'B.MACK',(BUF, TRANS.NO, FILE.INFO))!BUILD MACK CMD
!INPUT: BUF PTR (OR E.O.L) TO APPEND NEW COMMAND TO
!       TRANS.NO TO BE USED BY DONOR
!       FIE INFO: STATUS OF FILE AND FILE.BAD IN RECIPIENT
!VALUE: BUF PTR TO COMMAND BLOCK BUILT

LOCAL CB

CB _ BLD.ARG(E.O.L, PRS.T.INT, TRANS.NO)
BLD.ARG(CB, PRS.T.INT, FILE.INFO)

BUF _ BLD.CMD(BUF, CB, MACK.CMND)

RETURN (BUF)

END.PROC(B.MACK,H.B.MACK)
!
PROC(B.ACKP,H.B.ACKP,'B.ACKP',(BUF, TRANS.NO, FIRST.BLK, LAST.BLK))
!                                       BUILD ACK.P COMMAND
!INPUT: BUF PTR (OR E.O.L) TO APPEND COMMAND TO
!       TRANSACTION NUMBER
!       FIRST BLOCK ACKNOWLEDGED
!       LAST  BLOCK ACKNOWLEDGED (MAY BE SAME AS FIRST BLK; ALSO, MAY BE
!                                   ZERO, IN THE CASE OF A DUMMY ACK.P)
!VALUE: BUF PTR TO COMMAND STRING

LOCAL CB

CB _ BLD.ARG(E.O.L, PRS.T.INT, TRANS.NO)
BLD.ARG(CB, PRS.T.INT, FIRST.BLK)
BLD.ARG(CB, PRS.T.INT, LAST.BLK)

BUF _ BLD.CMD(BUF, CB, ACKP.CMND)

RETURN (BUF)

END.PROC(B.ACKP,H.B.ACKP)
!
PROC(B.ECHO,H.B.ECHO,'B.ECHO',(BUF, INT1, INT2))!BUILD ECHO COMMAND
!INPUT: BUF (OR E.O.L) TO WHICH THE ECHO CMD WILL BE APPENDED
!       INTEGER
!       INTEGER
!VALUE: BUF PTR TO CMD STRING

LOCAL CB, ECHO

ECHO _ TRUE
GO COMMON


PROC(%B.RECHO,%H.B.RECHO,'B.RECHO',(BUF,INT1,INT2))!BUILD ECHOR COMMAND
!-------------------------

ECHO _ FALSE
COMMON: NULL

CB _ BLD.ARG(E.O.L, PRS.T.INT, INT1)
BLD.ARG(CB, PRS.T.INT, INT2)
BUF _ BLD.CMD(BUF, CB, IF ECHO THEN ECHO.CMND ELSE ECHOR.CMND)

RETURN (BUF)

END..PROC(B.ECHO,H.B.ECHO)
!
PROC(FILE.EXISTS,H.FILE.EXISTS,'FILE.EXISTS',(FNAME))
!INPUT: FILE NAME BUF PTR
!VALUE: TRUE IF FILE EXISTS; OTHERWISE, FALSE

LOCAL FN, NO.OPEN:

FN _ OPEN(STR.BLD(FNAME, 0), INPUT+CHARACTER+DIRECT, NO.OPEN)
CLOSE(FN)
RETURN (TRUE)

NO.OPEN: RETURN (FALSE)

END.PROC(FILE.EXISTS,H.FILE.EXISTS)
!
PROC(W.BLK,H.W.BLK,'W.BLK',(TCB, N, DATA, OFF))  !WRITE BLK OF DATA
!                                               ON FILE.BAD
!INPUT: TRANSACTION CONTROL BLOCK PTR
!       NUMBER OF BYTES OF DATA
!       BUF PTR TO DATA
!VALUE: NONE

LOCAL FN, I, LEN, CHAR, CPS

MSG('W.BLK$')

!SET UP FOR WRITE
FN _ R.FCB.FN(R.TCB.FCB.B(TCB)) !GET FILE NUMBER FOR WRITE

IF (LEN _ BUF.LENGTH(DATA)) # (N + OFF + 1 !1 FOR THE ';' E.O.C!) &
 THEN &
  PUNT(MED, 'DATA LENGTH ERR. IS,S.B.:', 2, 1, LEN, 1, N+OFF)

!MOVE DATA FROM BUF TO FILE.BAD IN 8-BIT BYTES
CPS _ SETCP(FN, R.TCB.CP(TCB))                !SET CURSOR POS (FOR INSURANCE)
MSG('SETCP TO ')
OUT.PTR(TEL,CPS)

WHILE (INC OFF) < LEN &
 THEN &
 DO
  W(FN, CHAR _ GET.BUF.CHAR(DATA, OFF))        !WRITE BLOCK TO FILE
MSG('CHAR: ')
OUT.PTR(TEL,CHAR)
 END

L.TCB.CP(TCB, CP(FN))           !SAVE CURSOR FOR NEXT TIME

RETURN 

END.PROC(W.BLK,H.W.BLK)
!
PROC(END.RECIP,H.END.RECIP,'END.RECIP',(TRANS.NO))
!INPUT: TRANSACTION NUMBER
!VALUE: FALSE IF RENAME FAILS, TRUE OTHERWISE

LOCAL BUF, JOB, TCB, FCB, FCB.B, BUF.NAME, B.BUF.NAME
LOCAL REN.ERR:, NAME(1:15), DUP.TO

TCB _ GET.TCB(TRANS.NO)

! 5. ALL DATA IS HERE, I.E., HD.CNT IS FULL, THEN CLEANUP
BUF _ B.MACK(E.O.L, TRANS.NO-1, 100)    !ACKNOWLEDGE REC'D ALL DATA
OUT.RKD(BUF, JOB _ R.TCB.JOB(TCB), LOCAL.NAME, TRUE, TRUE)!SEND TO DONOR
B.BUF.NAME _ R.FCB.NAME(FCB.B _ R.TCB.FCB.B(TCB))       !FILE.BAD NAME
CLOSE.IT(FCB.B)                                         !CLOSE FILE.BAD

IF R.TCB.INFO(TCB) > 1 &
 THEN &
 DO
  CLOSE.IT(FCB _ R.TCB.FCB(TCB))        !CLOSE EXTENSIONLESS FILE
  DELETE(STR.BLD(R.FCB.NAME(FCB), 0))   !DELETE EXTENSIONLESS FILE
  !********POSSIBLY DELETE FCB AND SYM TAB ENTRY HERE*********
 END

!RENAME FILE.BAD TO FILE
IF PDP10.P THEN DUP.TO _ '.' ELSE DUP.TO _ '/'
BUF.NAME _ DUP.BUF(E.O.L, B.BUF.NAME, DUP.TO)   !BLD EXTENSIONLESS NAME
MSG('CALLING RENAME$')
RENAME(STR.BLD(B.BUF.NAME, NAME), STR.BLD(BUF.NAME, 0), REN.ERR)

!SEND MACK(200) INDICATING COMPLETION OF FILE MOVE
BUF _ B.MACK(E.O.L, TRANS.NO-1, 200)    !BLD MACK COMMAND
OUT.RKD(BUF, JOB, LOCAL.NAME, TRUE, TRUE)       !SEND TO DONOR

!CLEANUP TCB AREA
D.AREA(AR.N(R.TCB.HD(TCB)))     !DELETE HDCNT TABLE
R.ELMT(TCB)                     !RETURN TRANS CONTROL BLOCK
S.SP.AR(1,TCB.LIST,0,TRANS.NO)  !RELEASE TCB ENTRY ON SPARSE ARRAY

RETURN (TRUE)

REN.ERR:  PUNT(MED, 'RENAME FILE.BAD FAILED', 0)
          RETURN (FALSE)

END.PROC(END.RECIP,H.END.RECIP)
