!  IOCS DEFS OF INTEREST TO USER

!  FILE DESCRIPTORS PASSED TO %OPEN

!MAINTAIN ORDER OF FILE TYPES (SEE %OPEN1)

DEF INPUT AS 0
DEF UPDATE AS 1
DEF OUTPUT AS 2
DEF OUTMSG AS 3

!FILE TYPE MODIFIERS

DEF NEW AS OCT 100
DEF OLD AS OCT 200

!FILE MODES

DEF SEQUEN AS 0
DEF DIRECT AS OCT 10

!FILE ORGANIZATIONS

DEF WORD AS 0
DEF CHARACTER AS OCT 20
DEF PACK AS OCT 40

!  FILE NUMBERS  (FNMIN IS MIN CHANNEL WHICH WILL BE USED)

DEF FNMIN AS 1            !MIN AND MAX FILE NUMBERS
DEF FNMAX AS 15           !AVAILABLE, EXCLUDING TEL
DEF TEL AS (FNMIN-1)        !FILE NO. INDICATING TERMINAL 

!  ERROR NUMBERS (ERRNUM VALUES)

DEF TMFERR AS 1     !TOO MANY FILES OPEN (OPEN)
DEF FMDERR AS 2     !BAD FILE MODE OR TYPE FOR ATTEMPTED OPERATION
                    !(OPEN SEQUEN UPDATE, SETCP OR ERASE SEQUEN,
                    !WRITE OR ERASE INPUT, READ SEQUEN OUTPUT)
DEF IFDERR AS 3     !ILLEGAL FILE IDENTIFIER (SETFID, OPEN, DELETE, RENAME)
DEF CNFERR AS 4     !NEW/OLD FILE MESSAGE NOT CONFIRMED (OPEN OUTMSG)
                    !OR TYPE MODIFIER CONFLICT - FILE NOT NEW/OLD (OPEN OUTPUT OR UPDATE)

!ORDER OF FOLLOWING 5 NOS. SHALL BE MAINTAINED. (ALL BUT LAST MAY
!OCCUR DURING OPEN, DELETE, OR RENAME)

DEF FNFERR AS 5     !FILE NOT FOUND
DEF IUSERR AS 6     !INVALID USER NAME (BAD PPN)
DEF PRTERR AS 7     !PROTECTION VIOLATION ATTEMPT
DEF FBSERR AS 8     !FILE BUSY
DEF AEFERR AS 9     !NEW NAME BELONGS TO ALREADY EXISTING FILE  (RENAME)

DEF EOFERR AS 10    !END OF FILE (R, RB, GETLINE)
DEF LNGERR AS 11    !LINE TOO LONG (GETLINE FROM FILE)
DEF TELERR AS 12    !ILLEGAL OPERATION ON TEL (OPEN, DELETE, RENAME,
                    !CP, SIZE)
DEF ARGERR AS 13    !BAD ARGUMENT VALUE - SUCH AS:
                    !NEGATIVE CURSOR POSITION (SETCP, ERASE),
                    !NEG. COUNT (RB, WB)
DEF CORERR AS 14    !OUT OF CORE (OPEN, BLOCK, RELEASE)

FIND CFN, %SETCFN, %EXU
FIND %IOCS,%OPEN,%SETFID,%WFID,%CLOSE,%BUF.DUMP
FIND %CLOSE.ALL, %PLNCHK, %PLNW, %SET.TAB
FIND %SET.TERM, %SET.PRMPT, %TAB.OFF, %R, %GETLINE
FIND %W, %WX, %ERASE, %SETCP, %CP, %SIZE
FIND %WB, %RB
FIND %BLOCK, %RELEASE
FIND %DELETE,%RENAME
FIND %CLIBUF, %CLOBUF, %TTYLEN, %GET, %PUT, %PUTX, %PUTC
FIND %PRINT, %PRINTC, %MSG, %SETRWE
FIND %OFFALT, %ONALT, %ONALT.C, ALTLOC, ERRNUM

FIND FIDP()
DEF LOCWPF AS 4
DEF MAXARG AS 27
DEF MINARG AS 5
DEF WPF AS (LOCWPF+1+MINARG)
DEF MAXWPF AS (LOCWPF+1+MAXARG)
! EXTENDED ARGUMENT BLOCK:
DEF ARGCNT(TBL) AS TBL(LOCWPF)
DEF PPNARG(TBL) AS TBL(LOCWPF+1)
DEF NAMARG(TBL) AS TBL(LOCWPF+2)
DEF EXTARG(TBL) AS TBL(LOCWPF+3)
DEF PRVARG(TBL) AS TBL(LOCWPF+4)
DEF FILSIZ(TBL) AS TBL(LOCWPF+5)
DEF EXTQ(TBL) AS TBL(0)
DEF USRNAM(TBL) AS TBL(1)
DEF DEVNAM(TBL) AS TBL(3)

!  GETLINE 

DEF LLEN AS 270                !MAX. LINE LENGTH
DEF GLBCMX AS (LLEN+1)         !MAX. CHAR CAPACITY
DEF CPW AS CHARS.PER.WORD
DEF GLBSZ AS (GLBCMX+CPW-1)/CPW   !SIZE IN WORDS
FIND FREE(0:GLBSZ-1)         !GETLINE INTERNAL BUFFER (AVAILABLE
                             !BETWEEN GETLINE CALLS)
FIND IMAGE(0:GLBSZ-1)        !GETLINE IMAGE LINE BUFFER
FIND GLCNT                   !GETLINE CHAR COUNT

        GLOBAL %FETCHL, %ERR, %LOOKFN, %INITSC, %SPACES
        GLOBAL %REGNUM, %COMNUM, %GETNEX, %BACKUP, %OUTRNM, %OUTCNM
        GLOBAL %HOLDPT, %REMPT, %CLRSTK, %GETPT, %LPARSE, %EXPON, %FRONT
        GLOBAL %STR.COMP, %ANYMORE, %FATAL, %OLDNEW, %YESNO
        GLOBAL %WS.A, %WS.P, %WS.A.LIT, %WS.P.LIT, %CFEOF, %CFOPEN

        FIND LIST(1), LSTIDX(-1:1)

        GLOBAL SZLIST, SZLIDX, STACK(10), STKPT

        GLOBAL INLINE(0:GLBSZ-1), INFPOS(12), ACTION, INFNAM(5)

        GLOBAL FILPNT, CFNAME(150), CFGRP(30), CFPOS(30), FILGRP

        GLOBAL ISTTY, HUSH, HINLIP, TOUTFN

        GLOBAL IMAGPT, INLIPT, IDFIPT

        DEF MAXINT AS 6871947673

        DEF TRUE AS 1
        DEF FALSE AS 0

        DEF ALPHA AS (N>=$A AND N<=$Z) OR (N>=$0 AND N<=$9)

        DEF SAVEPT AS HINLIP_INLIPT

        DEF RETBAD AS [INLIPT_HINLIP ; RETURN FALSE]

        DEF TERM AS N=$  OR N=$, OR N=EOLIT

        DEF STRIP AS IF NOT SPACES THEN RETBAD



        DEF GETBAD AS IF NOT GETNEX(@N) THEN RETBAD

        DEF GESTBD AS [STRIP ; GETBAD]


        DEF IFSYTM(LAB) AS IF NOT GETNEX(@N) OR TERM THEN GO LAB &
        ELSE IF ALPHA THEN NULL ELSE GO LAB

        DEF IFSYDT(LAB) AS IF NOT GETNEX(@N) OR TERM THEN GO LAB &
        ELSE IF ALPHA OR N=$. THEN NULL ELSE GO LAB

        DEF OPER AS (N=$+ OR N=$- OR N=$* OR N=$/ OR N=$^ &
        OR N=$# OR N=$= OR N=$< OR N=$> OR N=$( OR N=$) )


        TABLE TENS(11) [1,10,100,1000,10000,100000,1000000,10000000 &
        ,100000000,1000000000,10000000000]

!###############################

        %INITSC(K)

!###############################


!INITIALIZE SCANER


        LOCAL X, I, J, NUMBER, SCALE, IDFILE(0:4), EMESS:
        LOCAL EMESS2:, ABBR, FILENO, CFPT



!THIS ROUTINE READS IN THE COMMAND LANGUSE FROM THE SPECIFIED FILE.
!WHEN IT HAS READ THE GOODIES IT WILL EXIT SO THAT THE PROGRAMMER
!MAY DO A SAVE.
!THE COMMAND LANGUAGE IS COMPOSED OF TWO ARRAYS LIST AND LSTIDX
!LIST CONTAINS CHARACTER STRINGS AND NUMBERS AND LSTIDX JUST NUMBERS
!FOR FULL SPEC SEE DOCUMENTATION.

        IF X=TRUE THEN RETURN ELSE X_TRUE

!INITIALIZE IOCS

        IOCS(K)

        ISTTY_TRUE ; HUSH_TRUE ; TOUTFN_TEL
   REQ: WSA(TEL,"$KEYWORD DICTIONARY FILE: ")
        FILENO_TEL
        IF NOT FETCHL(@FILENO) THEN GO REQ
        IF LOOKFN(IDFILE)#TRUE THEN GO REQ
        FILENO_OPEN(IDFILE,DIRECT+INPUT+CHARACTER,EMESS)

!LIST -4 CONTAINS TELETYPE,TERMINAL=1
!LIST -3 CONTAINS YES=1 NO=2
!LIST -2 CONTAINS OLD=1 NEW=2
!LIST -1 CONTAINS ALL NOT SAME HELP=1


        SZLIDX_-5 ; SZLIST_0
   DOPE: IF NOT FETCHL(@FILENO) THEN GO BAD
        IF NOT REGNUM(@NUMBER,@SCALE) THEN GO BAD
        IF NUMBER<10000 THEN GO LIDX
        INC SZLIST
        LIST(SZLIST)_NUMBER
        IF NOT FETCHL(@FILENO) THEN GO BAD
        INC SZLIST

!PUT AWAY ACTUAL ENTRY BELOWW PUT AWAY DOPE WWORD ABOVE

        I_CHPT(LIST+SZLIST,-1)
        J_0
        WHILE NCHV(INLIPT)#EOLIT THEN [NCHV(I)_CHV(INLIPT) ; INC J]
        NCHV(I)_EOLIT
        SZLIST_SZLIST+((J-1)/5)
        GO DOPE

!INPUT LIST POSITIONS

   LIDX: INC SZLIDX
        LSTIDX(SZLIDX)_NUMBER
        IF  NOT FETCHL(@FILENO) THEN GO QFIN
        IF NOT REGNUM(@NUMBER,@SCALE) THEN GO BAD ELSE GO LIDX


   BAD2: WSA(TEL,"$BAD INFORMATION FILE$") ; GO XFIN
   BAD: WSA(TEL,"$BAD DICTIONARY FILE$") ; GO QFIN


   EMESS2: IF ERRNUM#EOFERR THEN [ERR(FILENO) ; GO REQ2]
   EMESS: IF ERRNUM#EOFERR THEN [ERR(FILENO) ; GO REQ]

   QFIN: FILPNT_0

!GET INFORMATION FILE AND STORED INFO POSITIONS IN INFPOS
!LP= 1 VERSION
!       2 CREDITS
!       3 CHARGES
!       4 CAPABILITIES
!       5 INSTRUCTIONS
!       6 HELP OR ?

        I_0
        REPEAT 12 [INC I; INFPOS(I)_0]

   REQ2: WSA(TEL,"$INFORMATION FILE NAME: ")
        FILENO_TEL
        IF NOT FETCHL(@FILENO) THEN GO XFIN
        IF LOOKFN(IDFILE)#TRUE THEN GO REQ2
        FILENO_OPEN(IDFILE,DIRECT+INPUT+CHARACTER,EMESS2)

   CYC: IF NOT FETCHL(@FILENO) THEN GO XFIN
        J_LPARSE(0,@ABBR)
        IF J=0 THEN GO XFIN
        IF J=-1 OR J>6 THEN GO BAD2
        IF NOT REGNUM(@NUMBER,@SCALE) THEN GO BAD2
        IF SCALE#0 THEN GO BAD2
        INFPOS(J)_NUMBER
        IF NOT REGNUM(@NUMBER,@SCALE) THEN GO BAD2
        IF SCALE#0 THEN GO BAD2
        INFPOS(J+6)_NUMBER
        GO CYC

   XFIN: ISTTY_TRUE ; HUSH_FALSE ; ACTION_0 ; I_0 
        REPEAT 5 [INC I ; INFNAM(I)_IDFILE(I-1)]
        FILPNT_FILGRP_0
        CLOSE.ALL ; EXIT

        END INITSC



!###############################

        %FETCHL(@FILENO)

!###############################


!TAKES CARE OF INPUT OF LINES FROM ANYWHERE.
!RETURNS TRUE IF LINE HAD SEMANTIC CONTENT OTHERWISE FALSE.

        LOCAL X, ERRCON:, CHAR


!SET FETCHL TO FALSE AND SET TO TRUE LATER IF ANY SEMANTIC CONTENT

   RDLINE: X_FALSE
        CLRSTK

!CALL IOCS GETLINE. FILENO IS THE CURRENT FILE NUMBER (0 FOR
!TEL).


        SETRWE(FILENO,ERRCON)

        IMAGPT_GETLINE(FILENO)

        INLIPT_CHPT(INLINE,-1)
        REPEAT LLEN NCHV(INLIPT)_EOLIT
        INLIPT_CHPT(INLINE,-1)

!IF SOMETHING WENT WRONG IOCS WOULD BRANCH TO THE LABEL ERRCON: 
!BELOW.

!IF THE LINE CAME FROM A FILE AND HUSH IS FALSE WE MUST ECHO IT TO TEL
!GLCNT IS THE NUMBER OF CHARS INPUT (FROM IOCS) EXCLUSIVE OF EOLIT.

        IF ISTTY=FALSE THEN WSALIT(TOUTFN,FREE)




!CHECK FOR ONLY A CARRET

        IF NCHV(IMAGPT)=CARRET THEN RETURN FALSE ELSE PCHV(IMAGPT)


   NX: CHAR_NCHV(IMAGPT)
        IF CHAR=EOLIT OR CHAR=CARRET THEN GO FX
        NCHV(INLIPT)_CHAR
        IF CHAR#$  THEN X_TRUE
        GO NX


   FX:  NCHV(INLIPT)_EOLIT
        INLIPT_CHPT(INLINE,-1)
        RETURN X


!NOW HANDLE FILE ERRORS. ALL EXCEPT END OF FILE GO THRU ERR
!EOF ERRORS HERE SIMPLY CLOSE THE CURRENT COMMAND FILE AND OPEN THE
!PEVIOUS ONE. FILE NAMES ARE STORED IN THE ARRAY FILDIC CURRENT 
!POSITIONS WITHIN THOSE FILES IN THE ARRAY CFPOS. FILPNT IS THE
!POINTER TO THE CURRENT FILE WITHIN THOSE ARRAYS.

   ERRCON:  IF ERRNUM#EOFERR THEN [ERR(FILENO) ; RETURN FALSE]

!EOF ON TTY IS ASSUMED TO BE &CARRET AND IS PRESUMABLY PICKED UP BY
!IOCS


        CFEOF(FILENO)
        FILENO_CFOPEN
        GO RDLINE
        END FETCHL

!###########################

        %ERR(FILENO)

!###########################

!TYPES OUT ERROR MESSAGES RESULTING FROM INPUT. THE ERROR VALUES ARE
!DEFINED IN IOCSU.

        LOCAL I

        WSA(TEL,"$")



   EMESS: EIF ERRNUM=FNFERR THEN WSA(TEL,"FILE NOT FOUND$")
       ORIF ERRNUM=PRTERR THEN WSA(TEL,"PROTECTION VIOLATION$")
       ORIF ERRNUM=IUSERR THEN WSA(TEL,"INVALID USER NAME$")
       ORIF ERRNUM=FBSERR THEN WSA(TEL,"FILE BUSY$")
       ORIF ERRNUM=LNGERR THEN WSA(TEL,"LINE TOO LONG$")
        ELSE WSA(TEL,"UNDIAGNOSED FILE ERROR$")

        CLOSE(FILENO)
        FATAL

        RETURN


        END ERR





!#######################################

        %LOOKFN(FILADD)

!#########################################


!LOOKS FOR LEGAL FILE NAME AS NEXT THING ON INLINE AND STORES
!IT IN FILADD. RETURNS TRUE(1) IF IT DID THAT ELSE RETURNS FALSE(0)
!ELSE RETURNS -1 IF TELETYPE OR TERMINAL WAS TYPED.

        LOCAL X, GOOD:, I, N, ABBR

        X_FALSE

!A LEGAL FILE NAME IS:
!AN UP TO 12 CHAR USER NAME ENCLOSED IN PARENS FOLLOWED BY
!UP TO 6 ALPHANUMERICS FOLLOWED BY AN OPTIONAL PERIOD FOLLOWED BY UP
!TO THREE ALPHANUMERICS AS AN OPTIONAL EXTENSION.
!TELETYPE, TERMINAL ARE SPECIAL FILE NAMES. ALL, SAME, NOT AND
!HELP MAY NOT BE USED AS FILE NAMES.
!
!FILENAMES ARE TERMINATED ON ANY NON-ALPHANUMERIC


        SAVEPT
        IDFIPT_CHPT(FILADD,-1)

!CHECK FOR TELETYP,TERMINAL (-4) OR ALL,SAME,NOT,HELP (-1)

        N_LPARSE(-4,@ABBR)
        IF N=1 THEN [NCHV(IDFIPT)_$T ; &
                     NCHV(IDFIPT)_$E ; &
                     NCHV(IDFIPT)_$L ; &
                     NCHV(IDFIPT)_EOLIT ; RETURN -1 ]
        N_LPARSE(-1,@ABBR)
        IF N=1 THEN RETBAD ELSE INLIPT_HINLIP

!GET USER NAME IF ANY

        GESTBD
        IF N#$( THEN GO FINAME
        I_0
        WHILE N#$) THEN [NCHV(IDFIPT)_N ; INC I ; GETBAD]
        IF I>13 THEN RETBAD
        NCHV(IDFIPT)_N

!GET LEFT HALF OF FILENAME

        GETBAD

   FINAME: I_0 
        WHILE ALPHA THEN DO
         NCHV(IDFIPT)_N
         INC I ; IF I>13 THEN RETBAD
         IF NOT GETNEX(@N) THEN GO GOOD
        END
        IF TERM THEN GO GOOD
        IF I>6 THEN RETBAD
        IF N#$. THEN GO GOOD
        NCHV(IDFIPT)_N

!GET UP TO 3 CHAR EXTENSION

        IF NOT GETNEX(@N) THEN GO GOOD
        I_0
        WHILE ALPHA THEN DO
         NCHV(IDFIPT)_N
         INC I ; IF I>3 THEN RETBAD
         IF NOT GETNEX(@N) THEN GO GOOD
        END


   GOOD: BACKUP(@N)
        NCHV(IDFIPT)_EOLIT
        RETURN TRUE


        END LOOKFN


!####################################

        %SPACES

!#################################3

!STRIPS LEADING BLANKS FROM INLINE.RETURNS TRUE IF ANYTHING LEFT ON
!THE LINE ELSE FALSE. (ALSO SKIPS LINE FEEDS, CARRIAGE RETURNS)

        LOCAL N

        SAVEPT
        GETBAD
        WHILE N=$  OR N=CARRET OR N=LNFEED THEN GETBAD
        BACKUP(@N)
        RETURN TRUE


        END SPACES



!################################

        %REGNUM(@NUMBER,@SCALE)

!################################


!RETURNS A NUMBER IN THE VARIABLE NUMBER AND AN ASSOCIATED EXPONENT
!IN THE VARIABLE SCALE.
!SCALE CONTAINS A POSITIVE OR NEGATIVE POWER OF 10 TO BE APPLIED TO
!NUMBER. FOR EXAMPLE:

!VALUE   NUMBER   SCALE
!1.234    1234      -3
! 1         1        0
!12300     123       2

!REGNUM WILL ACCEPT INTEGERS, REALS AND SCIENTIFIC NOTATION NUMBERS OF
!THE FORM *E+, WHERE * MAY BE INTEGER OR REAL BUT + MUST BE INTEGER.


!NORMAL NUMBERS MAY BE TERMINATED BY A SPACE,COMMA OR END OF LINE.
!COMMERCIAL NUMBERS MAY BE TERMINATED BY ONLY A SPACE OR EOL.


!RETURNS TRUE IF NUMBER WAS FOUND OTHERWISE FALSE AND RESETS THE POINTER.


        LOCAL LFIN:, FINE:, FINC:, FINC1:

        LOCAL MINUS, EMINUS, SCLDEC, SCLINC, BIG, LPAREN, FIRCON
        LOCAL HSCALE, TRI, I, N, X, KEEPN

        DEF FINMIN AS [&
        IF MINUS THEN NUMBER_-NUMBER ELSE NULL ; &
        X_TRUE ; &
        BACKUP(@N) ; RETURN X]

        DEF INCSCL AS IF SCLINC THEN INC SCALE ELSE NULL

        DEF DECSCL AS IF SCLDEC THEN DEC SCALE ELSE NULL

        DEF IFBIG AS &
        IF BIG &
         THEN [ IF SCLDEC THEN NULL ELSE INCSCL] &
         ELSE &
           IF NUMBER+(N-$0)>MAXINT &
            THEN &
            [&
             BIG_TRUE ; ROUND ; &
              IF SCLDEC &
               THEN SCLDEC_FALSE &
               ELSE [SCLINC_TRUE ; INCSCL] &
           ] &
            ELSE [DECSCL ; KEEPN_N ; NUMBER_NUMBER*10+(N-$0)]

        DEF ROUND AS IF N>$5 THEN NUMBER_NUMBER+1 &
                             ELSE IF N=$5 THEN &
        IF KEEPN=(KEEPN/2)*2 THEN NUMBER_NUMBER+1

        DEF INIT AS[MINUS_EMINUS_SCLDEC_SCLINC_BIG_LPAREN_FIRCON_X_FALSE ; HSCALE_SCALE_NUMBER_TRI_I_0]

        DEF INIT1 AS [SAVEPT ; GESTBD ; IFMINU ; IFPLUS]

        DEF IFNUM AS IF N<$0 OR N>$9  THEN RETBAD ELSE INC I

        DEF IFPLUS AS IF N=$+ THEN GESTBD

        DEF IFMINU AS IF N=$- THEN [MINUS_TRUE ; GESTBD]

        DEF TRIADS AS IF NOT SCLDEC THEN  IF TRI#0 AND TRI#3 THEN RETBAD

        INIT
        INIT1

   DOT: IF N=$. THEN IF SCLDEC THEN RETBAD ELSE [SCLDEC_TRUE ; GO COM1]
        IFNUM
        IFBIG
   COM1: IFSYDT(LFIN)
        IF OPER THEN GO LFIN
        IF N#$E THEN GO DOT

!WE NOW HAVE THE NUMBER AND ARE DOING AN 'E'

        I_0
        SCLINC_TRUE
        GESTBD
        IFPLUS
        IF N=$- THEN [EMINUS_TRUE ; GESTBD]
   MERGEX: IFNUM
        HSCALE_HSCALE*TENS(I)+(N-$0)
        IFSYTM(FINE)
        GO MERGEX

!CLEAN UP THE EXPONENT

   FINE: IF EMINUS THEN HSCALE_-HSCALE
        SCALE_SCALE+HSCALE

!CLEAN UP THE NUMBER

   LFIN: FINMIN


!####################################3

        %COMNUM(@NUMBER,@SCALE)

!#######################################


!COMNUM GETS COMMERCIAL TYPE NUMBERS WITH TRIADS SEPARATED
!BY COMMAS. FLOATING POINT NUMBERS ARE ALLOWED. COMMERCIAL NUMBERS 
!TERMINATE WITH A SPACE OR EOL. NEGATIVE NUMBERS IN COMMERCIAL
!FORM (SURROUNDED BY PARENS) AND NORMAL FORM ARE BOTH ACCEPTED.

        INIT
        INIT1
        IF N=$( OR N=$<THEN [LPAREN_MINUS_TRUE ; GESTBD]
   DOT1: IF N=$. THEN IF SCLDEC THEN RETBAD ELSE [SCLDEC_TRUE ; TRIADS ; GO COM] 
        IFNUM
        IF FIRCON THEN INC TRI 
        IFBIG

   COM: IF NOT GETNEX(@N) OR N=$  OR N=EOLIT THEN GO FINC
        IF N=$, THEN &
         IF FIRCON AND TRI#3 THEN RETBAD &
         ELSE [FIRCON_TRUE ; TRI_0 ; GO COM] 

        IF N#$) AND N#$> THEN IF OPER THEN GO FINC ELSE GO DOT1
        TRIADS
        IF LPAREN THEN [IFSYTM(FINC1) ; RETBAD] ELSE RETBAD

!NOW CLEAN UP THE NUMBER

   FINC: IF LPAREN THEN IF N=$) OR N=$> THEN NULL ELSE RETBAD
   FINC1: TRIADS
        FINMIN


        END COMNUM

       END REGNUM



!#################################3

        %GETNEX(@N)

!###################################3


!GETS NEXT CHARACTER OF THE INPUT LINE INLINE. RETRUNS CHAR IN N
!RETURNS TRUE IF THERE WAS A CHARACTER AND FALSE IF THE END OF THE LINE
!WAS REACHED.

        N_NCHV(INLIPT)
        IF N=EOLIT THEN RETURN FALSE
        RETURN TRUE

        END GETNEX


!###################################3

        %BACKUP(@N)

!###################################

!GETS PREVIOUS CHAR FROM LINE AND PUTS IT IN N. RETURNS TRUE IF
!IT GOT A CHAR AND FALSE IF WE TRIED TO BCK OVER THE INITIAL CHAR PTR.

        LOCAL BPT

        N_PCHV(INLIPT)
        BPT_CHPT(INLINE,-1)
        IF BPT>INLIPT THEN RETURN FALSE
        RETURN TRUE

        END BACKUP


!##########################################

        %LPARSE(LISTNO,@ABBR)

!#############################################

!LPARSE COMPARES WHATEVER IS NEXT ON THE INPUT LINE WITH THE ELEMENTS
!IN THE COMMAND LIST LISTNO.

!LPARSE RETURNS:
!A) THE TOKEN NUMBER IF A MATCH WAS FOUND. (ABBR=0)
!B) ZERO IF NOTHING ELSE ON THE LINE. (ABBR=0)
!C) -1 IF NO MATCH WAS FOUND. (ABBR=0)
!D) -1 AND ABBR=TO THE NUMBER OF CHARACTERS MATCHED IF A PARTIAL MATCH
!   WAS FOUND.
!E) THE TOKEN NUMBER IF A MATCH WAS FOUND AND ABBR=TO THE NUMBER OF
!CHARACTERS MATCHED IF THE TOKEN WAS TERMINATED BY A PRE-SPECIFIED
!CHARACTER.


        LOCAL X, BEGL, ENDL, N, C, TOKPT, DOPNUM, I
        LOCAL TXERM, SIZE, TOKNUM, MATCH
        LOCAL KABBR

        KABBR_0 ; X_-1 

!CHECK FOR LISTNO IN BOUNDS

        IF LISTNO<-4 OR LISTNO>SZLIDX THEN RETURN X

        IF NOT SPACES THEN RETURN 0


!GET BEGINING OF THIS LIST

        BEGL_LSTIDX(LISTNO)

!CHECK FOR NULL LIST

        IF BEGL=0 THEN RETURN X

        HOLDPT
        IF NOT GETNEX(@N) THEN [REMPT ; RETURN 0]
        GET
!GET END OF LIST

        C_LISTNO+1
        WHILE LSTIDX(C)=0 THEN [INC C ; &
        IF C>SZLIDX THEN LSTIDX(C)_SZLIST]
        ENDL_LSTIDX(C)-1 
        
        C_BEGL

!BEGIN COMPARE
!GET DOPENUMBER

   GETDOP: DOPNUM_LIST(C)
        TOKNUM_DOPNUM/10000000
        DOPNUM_DOPNUM-TOKNUM*10000000
        TXERM_DOPNUM/10000
        DOPNUM_DOPNUM-TXERM*10000
        SIZE_DOPNUM/100
        MATCH_DOPNUM-SIZE*100

!DOPNUMBER IS NOW SPLIT
!COMPARE INPUT STREAM WITH TOKEN

        INC C
        TOKPT_CHPT(LIST+C,-1)
        I_0
   COMCH: HOLDPT ; IF NOT GETNEX(@N) THEN GO EOL
        IF N=NCHV(TOKPT) THEN [REMPT ; INC I ; IF I=SIZE &
           THEN [HOLDPT ; GETNEX(@N) ; GO EOL] &
           ELSE GO COMCH] ELSE NULL

   EOL: IF I<MATCH THEN GO NOMATCH



!CHECK TERMINATION WAS CORRECT
!CODES FOR TERM ARE:
!0 - BLANKS ONLY
!1 - ALPHAS OR BLANKS
!2 - NON-ALPHAS OR BLANKS
!3 - ANY
!>3 - ASCII REPRESENTATION OF SPECIFIC TERMINATION CHARACTER OR BLANKS

!THESE CODES ARE CREATED IN SCCONV


        IF N=$  OR N=EOLIT OR TXERM=3 THEN GO OK
        IF TXERM=0 THEN GO NOMATCH
        IF TXERM=1 THEN IF ALPHA THEN GO OK ELSE GO NOMATCH
        IF TXERM=2 THEN IF ALPHA THEN GO NOMATCH ELSE GO OK
        IF N#TXERM THEN GO NOMATCH ELSE [ABBR_I ; GO OK1]
   OK: ABBR_0
   OK1: GETPT ;   REMPT ; REMPT ; RETURN TOKNUM


   NOMATCH: IF I>KABBR THEN KABBR_I
        C_C+(SIZE-1)/5+1
        REMPT
        GETPT
        IF C>ENDL THEN [ ABBR_KABBR ; RETURN X]
        GO GETDOP

        END LPARSE


!##################################################

        %HOLDPT

!##################################################

!STORE THE CURRNET VALUE OF THE INPUT LINE POINTER INLIPT AS THE
!TOP VALUE IN THE STACK.

        INC STKPT
        IF STKPT=11 THEN [WSA(TEL,"$POINTER STACK OVERFLOW$") ; EXIT]
        STACK(STKPT)_INLIPT
        RETURN
        END HOLDPT

!###################################################

        %GETPT

!####################################################

!SET INLIPT=THE TOP POINTER IN THE STACK

        IF STKPT=0 THEN RETURN
        INLIPT_STACK(STKPT)
        RETURN
        END GETPT

!###################################################

        %CLRSTK

!###################################################

!CLEARS THE ENTIRE STACK

        STKPT_0
        RETURN
        END CLRSTK

!#######################################################

        %REMPT

!###################################################

!REMOVES THE TOP POINTER FROM THE STACK

        IF STKPT=0 THEN RETURN
        DEC STKPT
        RETURN
        END REMPT

!########################################3

        %OUTRNM(NUMBER,SCALE,WIDTH,DECIM,OFILE)

!#########################################3

!OUTPUTS REGULAR NUMBERS

!WIDTH IS THE TOTAL WIDTH OF THE FILED TO BE PRINTED. IF WIDTH IS 0
!THE NUMBER WILL SIMPLY BE PRINTED
!DECIM IS THE NUMBER OF DECIMAL PLACES TO BE TYPED. IF 0 THE NUMBER
!WILL BE AN INTEGER. DECIM MAY BE NON ZERO WHEN WIDTH IS ZERO.
!OFILE IS THE IOCS OPENED OUTPUT FILE. - MUST BE SET=TEL IF
!OUTPUT IS TO GO TO THE TERMINAL.
!NUMBER AND SCALE ARE DEFINED IN  REGNUM ABOVE.

        LOCAL DXC, NDIGIT, KSIZE, NBLANK, KSCALE, KNUM, N, DSIZE, EC
        LOCAL JFILE

        DEF OUTN AS [N_KNUM/TENS(NDIGIT) ; W(JFILE,$0+N) &
        ; KNUM_KNUM-N*TENS(NDIGIT)]

        DEF OUTDEC BY
        EC_DECIM
        IF DECIM<=0 THEN GO RT
        W(JFILE,$.)
        IF DSIZE>0 THEN GO DIM
        DSIZE_-DSIZE
        IF DSIZE>=DECIM THEN [ EC_0 ; REPEAT DECIM W(JFILE,$0) ; GO DIM]
        EC_EC-DSIZE
        REPEAT DSIZE W(JFILE,$0)
   DIM: REPEAT EC DO
        IF NDIGIT<=0 THEN W(JFILE,$0) ELSE OUTN
        DEC NDIGIT
        END

   RT: NULL

        ENDM OUTDEC

        DEF SUBKZ AS KSCALE_SCALE ; KNUM_NUMBER

        DEF INICK BY
        IF NUMBER=0 THEN SCALE_0
        IF WIDTH<0 OR DECIM<0 THEN RETURN FALSE
        NDIGIT_EXPON(NUMBER)
        DSIZE_KSIZE_NDIGIT+SCALE
        IF KSIZE<0 THEN KSIZE_0
        IF DECIM=0 AND KSIZE=0 THEN KSIZE_1
        ENDM INICK


        DEF DECSIZ BY
        DXC_WIDTH-DECIM
        IF DECIM>0 THEN DXC_DXC-1
        IF NUMBER<0 THEN DXC_DXC-1
        IF DXC<0 THEN RETURN FALSE
        ENDM DECSIZ

!TAKE CARE OF TOUT

        IF OFILE=TEL THEN JFILE_TOUTFN ELSE JFILE_OFILE

!CHECK TO SEE IF NUMBER WILL FIT INTO WIDTH

        INICK

!KSIZE IS THEN NUMBER OF INTEGER PART DIGITS 

        IF WIDTH=0 THEN GO OUTNUM

!CALCULATE THE WIDTH LEFT FOR THE INTEGER PART

        DECSIZ

        IF NBLANK_DXC-KSIZE<0 THEN RETURN FALSE

!ITS BIG ENEOUGH - TYPE LEADING SPACES IF ANY

        REPEAT NBLANK W(JFILE,$ )

!PRINT THE NUMBER

   OUTNUM: SUBKZ
        IF NUMBER<0 THEN [ W(JFILE,$-) ; KNUM_-KNUM]

        WHILE KSIZE>0 THEN DO
        IF NDIGIT<=0 THEN W(JFILE,$0) ELSE OUTN
        DEC KSIZE
        DEC NDIGIT
        END

!PRINT DECIMAL PART IF ANY

        OUTDEC

        RETURN TRUE



!############################################3

        %OUTCNM(NUMBER,SCALE,WIDTH,DECIM,OFILE)

!##############################################3

!OUTPUTS COMMERCIAL NUMBERS WITH COMMAS SEPARATING THE TRIDS
!AND NEGATIVE NUMBERS SURROUNDED BY PARENS.


!TAKE CARE OF TOUT FILE

        IF OFILE=TEL THEN JFILE_TOUTFN ELSE JFILE_OFILE

        INICK
        IF WIDTH=0 THEN GO OUCNUM
        DECSIZ

!SUBTRACT AN EXTRA 1 FOR NEAGTIVES. IE PARENS AS OPPOSED TO -

        IF NUMBER<0 THEN DXC_DXC-1

!KSIZE MUST BE INCREASED BY THE NUMBER OF COMMAS TO BE TYPED

        IF NBLANK_DXC-(KSIZE+((KSIZE-1)/3))<0 THEN RETURN FALSE

!ITS BIG ENOUGH - TYPE LEADING SPACES IF ANY

        REPEAT NBLANK W(JFILE,$ )

!PRINT THE NUMBER

   OUCNUM: SUBKZ
        IF NUMBER<0 THEN [ W(JFILE,$() ; KNUM_-KNUM]


        WHILE KSIZE>0 THEN DO
        IF ABS KNUM # ABS NUMBER THEN IF (KSIZE/3)*3=KSIZE THEN W(JFILE,$,)
        IF NDIGIT<=0 THEN W(JFILE,$0) ELSE OUTN
        DEC KSIZE
        DEC NDIGIT
        END

!PRINT DECIMAL PART IF ANY

        OUTDEC

!PRINT RIGHT PAREN IF NEGATIVE

        IF NUMBER<0 THEN W(JFILE,$))
        RETURN TRUE

        END OUTCNM

        END OUTRNM

!############################################

        %EXPON(N)

!###########################################3

!DETERMINES THE NUMBER OF DIGITS IN A NUMBER AND RETURNS THAT NUMBER
!IN EXPON.

        LOCAL I

        I_1
        WHILE  ABS(N)>=TENS(I) THEN INC I
        RETURN I-1
        END EXPON
!#######################################

        %FRONT(LISTNO,@ABBR,@FILENO)

!########################################3


!FRONT TAKES CARE OF PRINTING THE PROMPT AND TAKING CARE OF
!STANDARD FRONT END COMMANDS (SEE ALSEO INITSC).  IN ADDITION FRONT
!WILL CHECK FOR COMMANDS FROM LISTNO AND RETURN IN THE SAME MANNER
!AS  LPARSE

! LP = 1 = VERSION
! LP = 2 = CREDITS
! LP = 3 = CHARGES
! LP = 4 = CAPABILITIES
! LP = 5 = INSTRUCTIONS
! LP = 6 = HELP OR ?
! LP = 7 = DO
! LP = 8 = HUSH
! LP = 9 = NO HUSH
! LP =10 = TYPE
! LP =11 = INCLUDE
! LP =12 = TOUT



        LOCAL IISTTY,I,J,LP,HHUSH,MESS:, IDFILE(0:4), N
        LOCAL %OPTOUT, %DOCMFL

        INC ACTION
   PROMPT: IF NOT HUSH THEN [ WSA(TOUTFN,"$") ; &
        OUTRNM(ACTION,0,0,0,TOUTFN) ; WSA(TOUTFN,":") ]

!GET A LINE

        IF NOT FETCHL(@FILENO) THEN GO PROMPT
        LP_LPARSE(0,@ABBR)
        IF LP=0 THEN GO PROMPT
        IF LP=-1 THEN GO CHK

!IT WAS A STANDARD FRONT END COMMAND

        IF LP=12 THEN [OPTOUT ; GO PROMPT]
        IF LP=11 THEN [FILENO_DOCMFL ; GO PROMPT]
        IF LP=10 THEN DO
        IF NOT SPACES THEN GO PROMPT
        IF NOT GETNEX(@N) THEN GO PROMPT
        WS.P(TOUTFN,INLIPT)
        GO PROMPT
        END

        IF LP=9 THEN [HUSH_FALSE ; GO PROMPT]
        IF LP=8 THEN [HUSH_ TRUE ; GO PROMPT]
        IF LP=7 THEN [FILENO_DOCMFL ; GO PROMPT]
        IF LP=6 THEN IF INFPOS(6)=0 THEN GO NOINF ELSE GO PR
        IF LP=5 THEN IF INFPOS(5)=0 THEN GO NOINF ELSE GO PR
        IF LP=4 THEN IF INFPOS(4)=0 THEN GO NOINF ELSE GO PR
        IF LP=3 THEN IF INFPOS(3)=0 THEN [WSA(TOUTFN,"$NO PREMIUM CHARGE$") &
        ; GO PROMPT] ELSE GO PR
        IF LP=2 THEN IF INFPOS(2)=0 THEN [WSA(TOUTFN,"$WRITTEN BY TYMSHARE INC.$") &
        ; GO PROMPT] ELSE GO PR
        IF LP=1 THEN IF INFPOS(1)=0 THEN [WSA(TOUTFN,"$000000 000000$") &
        ; GO PROMPT] 

!GET INFO FROM THE INFORMATION FILE

   PR: HHUSH_HUSH  ; IISTTY_ISTTY
        J_OPEN(INFNAM+1,DIRECT+INPUT+CHARACTER,MESS)
        I_(INFPOS(LP+6)-INFPOS(LP))+1
        HUSH_TRUE ; REPEAT (INFPOS(LP)-1) FETCHL(@J)
        HUSH_FALSE ; ISTTY_FALSE
        REPEAT I FETCHL(@J)
        HUSH_HHUSH ;CLOSE(J) ;ISTTY_IISTTY ;GO PROMPT

   NOINF: WSA(TOUTFN,"$NOT AVAILABLE$") ; GO PROMPT
   MESS: ERR(J) ; HUSH_HHUSH ; GO PROMPT

!NOW CHECK FOR A REAL COMMAND FROM THE SPECIFIED LIST (LISTNO)

   CHK: IF LISTNO=0 THEN RETURN -1
        LP_LPARSE(LISTNO,@ABBR)
        RETURN LP

!#####################################33

        %DOCMFL

!#####################################


!THIS PROCEDURE KEEPS THE COMMAND FILE STACKS STRAIGHT:

!CFNAME HOLDS UP TO 30 COMMAND FILE NAMES CFNAME(1-5) HOLDS THE FIRST
!ETC.
!CFPOS CONTAINS THE CURSOR POSTIONS OF THOSE FILES THAT MUST BE RETURNED
!TO.
!CFGRP CONTAINS A INTEGER WHICH IS THE SAME FOR ALL FILES TYPED IN IN A
!STATEMENT OF THE FORM DO X+Y+Z
!FILGRP IS A GLOBAL VARIABLE WHICH INCREASES WITH EACH DO OR INCLUDE
!STATEMENT.

!THE CURRENT COMMAND FILE IS ALWAYS AT THE TOP OF THE STACK

!IF THE STATEMENT DO (OR INCLUDE) X+Y+TEL+Z OCCURS THEN A -1 WILL APEAR
!IN CFNAME INSTEAD OF THE WORD TEL. THIS IS TO ENSURE THAT THE TEL
!IS NOT OPENED BY CFOPEN AS ADIRECT INPUT FILE.

!LP=7=DO
!LP=11=INCLUDE

        LOCAL N, P, L

        IF FILPNT=0 THEN GO INP
        IF LP=11 THEN [CFPOS(FILPNT)_CP(FILENO) ; GO CLF]

!THIS IS A DO SO WE MUST GET RID OF ALL FILES THAT WERE TYPED IN AT THE
!SAME TIME AS THIS ONE

        P_CFGRP(FILPNT)
        WHILE FILPNT#0 OR P=CFGRP(FILPNT) THEN DEC FILPNT

   CLF: CLOSE(FILENO)

!GET INPUT

   INP: N_1
   LOOP1: IF NOT ANYMORE THEN GO BAD
        LP_LOOKFN(CFNAME+((30-N)*5))
        IF LP=0 THEN GO BAD
        IF LP=-1 THEN CFNAME(((30-N)*5)+1)_-1
        INC N
        IF NOT ANYMORE THEN GO FEND

!FIND OUT IF ITS A PLUS

        IF NOT GETNEX(@P) THEN GO FEND
        IF P#$+ THEN GO BAD ELSE GO LOOP1

   BAD: WSA("$BAD COMMAND FILE STRING$")
   FAD: FATAL
        FILENO_TEL
        RETURN

   FEND: IF 30-N<FILPNT+1 THEN [WSA("$TOO MANY COMMAND FILES$") ; GO FAD]

        DEC N

!SINCE WEVE BEEN STACKING THE NAMES FROM THE VERY TOP OF THE STACK WE
!MUST NOW PUT THEM IN THEIR RIGHT PLACE.

        FOR L_N BY-1 TO 1 DO
        INC FILPNT
        FOR P_1 TO 5 CFNAME(((FILPNT-1)*5)+P)_CFNAME(((30-N)*5)+P)
        CFGRP(FILPNT)_FILGRP
        CFPOS(FILPNT)_0
        END

        INC FILGRP
        FILENO_CFOPEN

        RETURN
        END DOCMFL

!####################################

        %OPTOUT

!#####################################

!TAKES CARE OF THE OPENING OF TOUT FILES

        IF TOUTFN#TEL THEN CLOSE(TOUTFN)
        TOUTFN_TEL
        IF NOT ANYMORE THEN GO INP
   FN: LP_LOOKFN(IDFILE)
        IF LP=-1 THEN RETURN
        IF LP=0 THEN [FATAL ; WSA(TEL,"$BAD TOUT FILE NAME$") ; RETURN]
        TOUTFN_OLDNEW(FILENO,IDFILE)
        RETURN

   INP: IF NOT HUSH THEN WSA(TOUTFN,"$TOUT FILE NAME: ")
        IF NOT FETCHL(@FILENO) THEN [FATAL ; RETURN] ELSE GO FN

        END OPTOUT
        END FRONT
!#################3

        %STR.COMP(LOC1,LOC2)

!########################################3

!INPUT ADDRESSES OF TWO STRINGS TO BE EXACTLY COMPARED TO EOLIT
!RETURNS TRUE IF COMPARED OTHERWISE FALSE

        LOCAL I,CHAR
        I_0
        WHILE CHAR_CH(LOC1,I)=CH(LOC2,I) &
        THEN [INC I ; IF CHAR=EOLIT THEN RETURN TRUE]
        RETURN FALSE
        END STR.COMP

!###########################################3

        %ANYMORE

!############################################3

!RETURNS TRUE IF ANYTHING ELSE ON THE LINE OTHERWIZE FALSE

        LOCAL  N
        GESTBD
        BACKUP(@N)
        RETURN TRUE
        END ANYMORE


!########################################################

        %FATAL

!############################################3

!RESETS TOUT AND COMMAND FILE STATUS TO INITIALIZED STATE ON
!DECTECTION OF BAD ERROR

        HUSH_FALSE ; FILPNT_0 ; TOUTFN_TEL
        RETURN
        END FATAL

!########################################3

        %WS.A(FN,ADD)

!##################################################

!WRITES THE STRING STARTING AT ADD TO FILE FN.

!$ MEANS CARRIAGE RETURN
!\ MEANS NEXT CHAR IS A CONTROL CHAR.

        LOCAL PTR

        PTR_CHPT(ADD,-1)
        WS.P(FN,PTR)
        RETURN
        END WS.A

!##################################################

        %WS.P(FN,PTR)

!###################################################

!WRITES STRING AS SPECIFIED ABOVE BUT USES POINTER.

        LOCAL CHAR,CNTRL

        DEF WCNTRL AS [WX(FN,CHAR) ; CNTRL_FALSE]

        DEF WCHAR AS W(FN,IF CHAR=$$ THEN CARRET ELSE CHAR)

        CNTRL_FALSE

        WHILE CHAR_NCHV(PTR)#EOLIT THEN &
        [IF CNTRL THEN WCNTRL ELSE [IF CHAR=$\ THEN CNTRL_TRUE &
        ELSE WCHAR]]

        RETURN
        END WS.P

!##################################################

        %WS.A.LIT(FN,ADD)

!###################################################3

!WRITE OUT THE STRING BEGGING AT ADD LITERALLY TO FN

        LOCAL PTR

        PTR_CHPT(ADD,-1)
        WS.P.LIT(FN,PTR)
        RETURN
        END WS.A.LIT

!#####################################################3

        %WS.P.LIT(FN,PTR)

!########################################################

!WRITES OUT STRING TO FN LITERALLY FROM PTR

        LOCAL CHAR

        WHILE CHAR_NCHV(PTR)#EOLIT THEN W(FN,CHAR)
        RETURN
        END WS.P.LIT


!#####################################################

        %OLDNEW(@FILENO,IDFILE)

!######################################################

!THIS ROUTINE TAKES CARE OF OPENING OUTPUT FILE IDFILE WITH RESPECT
!TO THE STANDARD FRONT END OLD/NEW SPECS.

!OLDNEW RETURNS WITH THE NUMBER OF THE OPENED FILE


        LOCAL N,SPEC,STATUS,FN,ERRLAB:,Y,ABBR

        DEF OLD AS 1
        DEF NEW AS 0

!OPEN FILE IN UPDATE MODE TO DETERMINE ITS STATUS (OPEN IT ONLY AS
!OLD SINCE WE DON'T NECCASARILY WANT TO CREATE A FILE)

        FN_OPEN(IDFILE,UPDATE+OLD+DIRECT+CHARACTER,ERRLAB)
        STATUS_OLD
        CLOSE(FN)
        GO BEG

   ERRLAB: IF ERRNUM=CNFERR THEN [STATUS_NEW ; GO BEG] &
        ELSE [FATAL ; ERR(FN) ; RETURN TEL]

   BEG: IF NOT ANYMORE THEN GO ASK

!DETERMINE (SINCE THERE IS SOMETHING ELSE ON THE LINE) IF OLD
!OR NEW HAS BEEN SPECIFIED - IN WHICH CASE DO NOT ASK THE OLD/NEW FILE
!MESSAGE.

        IF NOT GETNEX(@N) THEN GO ASK
        Y_LPARSE(-2,@ABBR)
        IF Y=1 THEN [SPEC_OLD;GO GOOD]
        IF Y=2 THEN SPEC_NEW ELSE GO ASK

   GOOD: IF SPEC#STATUS THEN &
        [WSA(TEL,"FILE STATUS CONFLICT - NOT OPENED$") ; FATAL ; RETURN TEL] 

   OPFL: FN_OPEN(IDFILE,OUTPUT+CHARACTER,ERR)
        RETURN FN

   ASK: IF STATUS=OLD THEN [WSA(TOUTFN,"FILE ALREADY EXISTS, OK? ") ; GO Q] &
        ELSE WSA(TOUTFN,"NEW FILE, OK? ")

   Q: IF NOT FETCHL(@FILENO) THEN GO ASK
        IF NOT YESNO(@Y) THEN GO ASK
        IF NOT Y THEN RETURN TEL ELSE GO OPFL

        END OLDNEW

!#######################################

        %YESNO(@Y)

!#######################################

        LOCAL N ,LP ,ABBR

!THIS ROUTINE RETURNS TRUE IF YES OR NO WAS TYPED AND FALSE IF NOT. IF
!YES THEN Y WILL BE TRUE.
!KEYWORD LIST -3 CONTAINS TERMINAL AND TELETYPE BOTH OF WHICH RETURN
!TOKEN 1

        IF NOT ANYMORE THEN RETBAD
        SAVEPT
        LP_LPARSE(-3,@ABBR)
        IF LP<=0 THEN RETBAD
        IF LP=1 THEN Y_TRUE ELSE Y_FALSE
        RETURN TRUE
        END YESNO

!###################################################

        %CFEOF(FILENO)

!###################################################

!TAKES CARE OF END OF FILES FOR COMMAND FILES.

!TEL EOF

        IF FILPNT=0 THEN RETURN

!FILE EOF

        DEC FILPNT
        CLOSE(FILENO)
        RETURN
        END CFEOF

!####################################################

        %CFOPEN

!####################################################

!SEE ALSO DOCMFL FOR COMMAND FILE STACKING PROCEDURES

!OPENS THE COMMAND FILE WHOSE NAME IS STORED IN CFNAME(FILPNT*5)
!AND SPACES OUT THRU THE FILE TO THE POSITION STORED IN
!CFPOS(FILPNT)

        LOCAL FILENO, LAB:

!THE PROCEDURE RETURNS THE FILENUMBER OF THE NOW OPENED FILE OR THE TEL

        IF FILPNT=0 THEN RETURN TEL

!SINCE TEL CANNOT BE OPENED AS DIRECT - JUST RETURN

        IF CFNAME((FILPNT-1)*5)=-1 THEN RETURN TEL
        FILENO_OPEN(CFNAME+((FILPNT-1)*5),DIRECT+INPUT+CHARACTER,LAB)
        IF CFPOS(FILPNT)>0 THEN SETCP(FILENO,CFPOS(FILPNT))
        RETURN FILENO

   LAB: ERR(FILENO)
        RETURN TEL
        END CFOPEN
-PD