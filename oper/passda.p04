BASE 0

!PROCEDURES
GLOBAL %PASDAT
FIND %HASH, %BYPT, %INITTTY,%QUERY, %GETTOKEN
FIND %CHR.OUT,%NUMOUT,%SIXOUT,%MAKE.SIXBIT
FIND %DATOUT, %A.CIR.OP
LOCAL %CHK.IO.ERR, %COMPRS.NAME, %CIR.ERR
LOCAL %FIND.NXT.NAME, %SEND.ONE
LOCAL %DUL.LOOK,%DUL.OVERFLOW, %LUD.LOOK, %LUD.OVERFLOW
LOCAL %INITPASDAT, %M.DAT.OUT
DEF SIZE.LUD.ENT AS BYT(LUD(2),7,0)
DEF SIZE.BLK AS 128

GLOBAL TABLE COMPRS(0:44)[$ ,$A,$B,$C,$D,$E,$F,$G,$H,$I,$J,$K,$L,$M,&
   $N,$O,$P,$Q,$R,$S,$T,$U,$V,$W,$X,$Y,$Z,0,$-,$.,$/,$0,$1,$2,$3,$4,&
   $5,$6,$7,$8,$9,$:,$*,$',0]

!ID'S
FIND TOKEN(0)
LOCAL  THISPPN,THISACCT, THISNAM(2), THIS.LIC
GLOBAL NUMBER, P, CH.OUT, NAME.HASH, LOC.HASH
GLOBAL M.MO, M.DA, M.YR, USER(2), CUSER(4), TYPALT:
GLOBAL OP, A.CHAR, A.STR, A.CHAN

LOCAL CH.LUD, L.INDEX, L.BLK(SIZE.BLK)
LOCAL CH.DUL, D.INDEX, D.BLK(SIZE.BLK)
LOCAL CH.IN, FILE.FLG, MORE.FLG
LOCAL TEMP, COUNT

!MACRO'S
DEF ACT.SUP.BITS AS BYT(LUD(3),1,13)
DEF BLD AS -1
DEF BUILD.CIR AS [CALL.CIR.OP(BLD,0,'CUD:1;'); IF A.CHAN < 0 THEN CIR.ERR]
DEF CALL.CIR.OP(A,B,C) AS [OP_A;A.CHAR_B;A.STR_C;A.CIR.OP]
DEF CLEAN.UP AS [CALL.CIR.OP(A.RECIEVE.8,0,0);&
   WHILE A.CHAR # OCT 40 THEN CALL.CIR.OP(A.RECIEVE.8,0,0)]
DEF CODE AS 14
DEF CR AS CHR.OUT(CARRET)
DEF FIRSTOF24(A) AS BYT(A,1,23)
DEF FIXCP(A) AS (A-1)*SIZE.BLK	!COMPUTE CURSOR POS. FROM BLK. NO.
DEF DUL(A) AS D.BLK(D.INDEX+A)
DEF DUL.READ AS [RB(CH.DUL,SIZE.BLK,D.BLK); D.INDEX_0]
DEF LUD(A) AS L.BLK(L.INDEX+A)
DEF LUD.READ AS [RB(CH.LUD,SIZE.BLK,L.BLK); L.INDEX _ 0]
DEF GET.M.WD(A) AS [SET.UP.PTR(A); REPEAT 3 [CALL.CIR.OP(A.RECIEVE.8,&
	0,0); NCHV PTR _ ACHAR]]
DEF GETNAME AS [GETTOKEN(2);MAKE.SIXBIT(TOKEN,USER,12)]
DEF IFCR AS IF FILE.FLG = 0 THEN CR
DEF OPEN.DUL AS CH.DUL _ OPEN('(SYS)DUL.SYS',DIRECT+INPUT+WORD,&
	CHK.ERR)
DEF OPEN.LUD AS CH.LUD _ OPEN('(SYS)LUD.SYS',DIRECT+INPUT+WORD,&
	CHK.ERR)
DEF OV.BLK AS HW(@LUD(1),1)
DEF P.MSG AS MSG('$PASSWORD LAST CHANGED ON ')
DEF A.RECIEVE.8 AS 0
DEF SAMACCT AS THISACCT = HW(@LUD(0),0)
DEF SAMUSER AS THISNAM(0) = USER(0) AND THISNAM(1) = USER(1)
DEF PROT.FAILURE AS [IF FILE.FLG # 0 THEN [SIXOUT(USER,12); SP] ELSE CR;&
	MSG('NOT YOUR GLOBAL ACCOUNT$')]
DEF NOT.VALID AS [IF FILE.FLG # 0 THEN [SIXOUT(USER,12); SP] ELSE CR;&
	MSG('INVALID NAME$')]
DEF SET.UP.PTR(A) AS PTR _ BYPT(A,4,4) BAND SIZ.OUT + SIZ.IN
DEF SEND.WD(A) AS [SET.UP.PTR(A);&
	REPEAT 3 CALL.CIR.OP(A.SEND.8,NCHV PTR,0)]
DEF A.SEND.8 AS 3
DEF SIXBIT.TAB(A) AS COMPRS(A) - OCT 40
DEF SIZ.OUT AS OCT 770000777777
DEF SIZ.IN AS OCT 1000000000
DEF SP AS CHR.OUT($ )
DEF VERSION AS 4
DEF ZAP AS -2


!LABELS
LOCAL CHK.ERR:



%PASDAT
	!MAINLINE
START: IOCS(2); INITPASDAT
\\->START
	 CH.OUT _ OPEN('TEL',SEQUEN+OUTPUT+CHARACTER,CHK.ERR,2)
IF THIS.LIC = 0 OR QUERY('$YOURS ONLY') = 1 THEN DO
	IF SEND.ONE # 0 THEN [P.MSG; M.DAT.OUT]
	GO TYPALT
END
LOOP DO
 LOOP DO
   IF FILE.FLG = 0 THEN MSG('$USER NAME: ')
   WHILE FIND.NXT.NAME = 0
 END
   IF MORE.FLG = 0 THEN GO TYPALT
   IF SEND.ONE # 0 THEN DO
	IF FILE.FLG = 0 THEN P.MSG ELSE [SIXOUT(USER,12); SP]
	M.DAT.OUT
   END
   IF FILE.FLG = 0 THEN [IF QUERY('$ANOTHER') = 0 THEN GO TYPALT]
END
TYPALT: A.CHAN _ -1; CALL.CIR.OP(ZAP,0,0);  CLOSE.ALL; ONALT
	MSG('$$END OF JOB$'); EXIT

%DUL.LOOK(PPN)
	!LOOK UP PPN IN DUL
OPEN.DUL
SETCP(CH.DUL,FIXCP((PPN MOD 101)+1)); DUL.READ
WHILE DUL(0)#PPN THEN DO
	D.INDEX+_3
	IF DUL(0)=0 THEN RETURN 0
	IF DUL(0)<0 THEN DUL.OVERFLOW
	END
RETURN 1
END DUL.LOOK



%CIR.ERR
A.CHAN _ (A.CHAN SHL 1) SHL -1
MSG('$CIRCUIT NOT BUILT - ERROR ')
TEMP _ HW(@A.CHAN,0); NUMOUT(TEMP)
CR; DO TEMP OF 0:7
0: MSG('ERROR RESPONSE FROM SUPERVISOR - ERROR ')
   TEMP _ HW(@A.CHAN,1); NUMOUT(TEMP)
   CR; DO TEMP OF 1:4
	1: MSG('BAD NAME FORMAT')
	2: MSG('NAME NOT IN MUD')
	3: MSG('BAD MUD')
	4: MSG('SYSTEM UNAVAILABLE')
   END
1: MSG('TOO MANY CIRCUITS')
2: MSG('BAD USER NAME')
3: MSG('OUT OF CHANNELS FROM HOST')
4: MSG('NOT RESPONSE TO REQUEST')
5: MSG('NOT RESPONSE TO STRING')
6: MSG('NO CHANNEL SUPPLIED BY SUPERVISOR')
7: MSG('ERROR RESPONSE TO REQUEST - ERROR ')
   TEMP _ HW(@A.CHAN,1); NUMOUT(TEMP)
END
MSG('.$'); GO TYPALT
END CIR.ERR


%CHK.IO.ERR
	!TAKE CARE OF ALL I/O ERRORS FROM IOCS...
CHK.ERR: MSG('ERROR ON ');WFID(FIDP);MSG('...');CR
  DO ERRNUM OF TMFERR:CORERR
FNDERR: MSG('BAD FILE MODE OR TYPE')
IFDERR: MSG('ILLEGAL FILE IDENTIFIER')
FNFERR: MSG('FILE NOT FOUND')
IUSERR: MSG('INVALID USER NAME')
PRTERR: MSG('PROTECTION FAILURE')
EOFERR: MSG('END OF FILE')
 END
MSG('.$ERROR ');NUMOUT(ERRNUM);EXIT
END CHK.IO.ERR



%DUL.OVERFLOW
	!READ DUL OVERFLOW BLOCK
SETCP(CH.DUL,HW(DUL(0),1)*SIZE.BLK)
DUL.READ
RETURN
END DUL.OVERFLOW


%INITPASDAT
	!INIT PROGRAM
INITTTY(TYPALT)
MSG('$PASSWORD DATE - VERSION '); NUMOUT(VERSION)
	DATOUT
MOVE 72/CHARS.PER.WORD FROM ALL 0 TO TOKEN
THISPPN _ EXU(OCT 47,OCT 1,OCT 24)
THISACCT _ HW(@THISPPN,0)
IF DUL.LOOK(THISPPN) = 0 THEN [MSG(' THIS USER NAME NOT IN DUL');&
	EXIT]
USER(0) _ THISNAM(0) _ DUL(1); USER(1) _ THISNAM(1) _ DUL(2)
IF LUD.LOOK(@DUL(1)) = 0 THEN [MSG('$THIS USER NAME NOT IN DUL');&
	EXIT]
THIS.LIC _ ACT.SUP.BITS
FILE.FLG _ 0; MORE.FLG _ 1
ALTLOC _ TYPALT; OFFALT
CLOSE.ALL
BUILD.CIR
TRY: CALL.CIR.OP(A.RECIEVE.8,0,0); IF A.CHAR = 1 THEN DO
    CALL.CIR.OP(A.RECIEVE.8,0,0); IF A.CHAR = 1 THEN DO
	CALL.CIR.OP(A.RECIEVE.8,0,0); IF A.CHAR # OCT 40 THEN GO TRY
   END ELSE GO TRY
END ELSE GO TRY
CALL.CIR.OP(A.SEND.8,1,0); CALL.CIR.OP(A.SEND.8,1,0)
CALL.CIR.OP(A.SEND.8,OCT 40,0)
RETURN
END INITPASDAT

%COMPRS.NAME
	!COMPRESS USER NAME IN USER,USER+1 INTO CUSER,CUSER+1,CUSER+2
LOCAL P1,I,J,K,CHARS(4),TEMP
COUNT _ 7
P1 _ BYPT(USER,1,6)
FOR K _ 0 TO 2 DO
   FOR J _ 0 TO 3 DO
	TEMP _ NCHV P1; I _ -1
		!IF LOWER CASE, CONVERT TO UPPER
	IF TEMP > OCT 100 AND TEMP < OCT 133 THEN TEMP - _ OCT 40
	WHILE INC I < 44 AND TEMP # SIXBIT.TAB(I) THEN NULL
	CHARS(J) _ I
   END
CUSER(K) _ (((CHARS(0)*45)+CHARS(1))*45+CHARS(2))*45+CHARS(3)
END

EIF CUSER(1) = 0 THEN FIRSTOF24(CUSER(0)) _ 1
ORIF CUSER(2) = 0 THEN [COUNT+_3; FIRSTOF24(CUSER(1))_1]
ELSE COUNT+_6

RETURN
END COMPRS.NAME


%FIND.NXT.NAME
LOCAL IN.END:, TMP
LOOP DO
 IF FILE.FLG = 0 THEN DO
   P _ GETLINE(TEL)
   IF TMP _ NCHV P = $@ THEN DO
	MSG('$USER NAME    PASSWORD LAST CHANGED$')
	INC FILE.FLG
	GETTOKEN(0)
	CH.IN _ OPEN(TOKEN,SEQUEN+CHARACTER+INPUT,IN.END,2)
	P _ GETLINE(CH.IN)
   END ELSE PCHV P
 END ELSE P _ GETLINE(CH.IN)
   GETNAME
   IF LUD.LOOK(USER) # 0 THEN DO
	IF (THIS.LIC = 1 AND SAMACCT) OR SAMUSER THEN RETURN 1 &
	   ELSE [PROT.FAILURE; RETURN 0]
   END ELSE [NOT.VALID; RETURN 0]
END

IN.END: IF ERRNUM # EOFERR THEN CHK.IO.ERR
   FILE.FLG _ 0; MORE.FLG _ 0
   RETURN
END FIND.NXT.NAME


%SEND.ONE
LOCAL PTR, M.GAN, M.ERR, M.COUNT
COMPRS.NAME
FOR M.COUNT _ 1 TO 20 DO
   CALL.CIR.OP(A.SEND.8,COUNT,0); CALL.CIR.OP(A.SEND.8,CODE,0)
   TEMP _ 0; SEND.WD(@TEMP)
   FOR TEMP _ 1 TO (COUNT-4)/3 SEND.WD(CUSER+TEMP-1)
   CALL.CIR.OP(A.SEND.8,OCT 40,0)
   CALL.CIR.OP(A.RECIEVE.8,0,0)
   IF A.CHAR = 6 THEN DO
	CALL.CIR.OP(A.RECIEVE.8,0,0); M.MO _ A.CHAR
	CALL.CIR.OP(A.RECIEVE.8,0,0); M.DA _ A.CHAR
	CALL.CIR.OP(A.RECIEVE.8,0,0); M.YR _ A.CHAR
	GET.M.WD(@M.GAN)
	CLEAN.UP
	IF THISACCT # HW(@M.GAN,1) THEN [PROT.FAILURE; RETURN 0]
	RETURN 1
   END
   CALL.CIR.OP(A.RECIEVE.8,0,0); M.ERR _ A.CHAR
   CLEAN.UP
   IF M.ERR = 1 THEN [NOT.VALID; RETURN 0]
   IF M.ERR # 3 OR M.COUNT = 20 THEN DO
	MSG('$ERROR ON AUX. CIR. - ')
	IF M.ERR = 3 THEN MSG('MUD FILE BUSY$') &
	   ELSE [MSG('ERROR '); NUMOUT(M.ERR)]
	GO TYPALT
   END
END
END SEND.ONE

%M.DAT.OUT
IF M.MO=0 AND M.DA=0 AND M.YR=0 THEN [MSG(' NO PASSWORD DATE RECORDED.'); RETURN]
NUMOUT(M.MO); CHR.OUT($/)
NUMOUT(M.DA); MSG('/197')
NUMOUT(M.YR); CR
RETURN
END M.DAT.OUT

%LUD.LOOK(ADR)
OPEN.LUD
HASH(^ADR,^(ADR+1))
SETCP(CH.LUD,FIXCP(LOC.HASH));LUD.READ
WHILE NAME.HASH # LUD(4) THEN DO
   L.INDEX + _ SIZE.LUD.ENT
   IF LUD(0) = 0 THEN RETURN 0
   IF LUD(0) < 0 THEN LUD.OVERFLOW
   END
RETURN 1
END LUD.LOOK



%LUD.OVERFLOW
SETCP(CH.LUD,OV.BLK*SIZE.BLK)
LUD.READ
RETURN
END LUD.OVERFLOW

END PASDAT
  