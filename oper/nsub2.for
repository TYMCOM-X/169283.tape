      SUBROUTINE ERROR(IA)
C
C			     PUT ERROR INTO ERROR ARRAY
C
      COMMON NREF,ICH,NLNX,IMODE,LOCCNT,LOCNXT,ICORE,IRADIX,LABEL
     1,INDRCT,NLINE,IPAGE,NCER,NEREF,IOCLAS,ICARD,NWDS,IWTYPE,IRELO
     2,NRELO,IWDCT,IADL,INOLOD,ITITLE,RELASM,XREF,PASS1
     3,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG,ANYPCH,CODE,LOCALS
     4,CROSS(3,1000),LN(81),LNX(81)
     5,ISOUR(80),NEREFS(50),NCERS(10),IWORD(40),IBL(22),LOCS(3)
      COMMON /CDS/ INFILE,IOFILE,IPFILE,ISCR
     1,LETA,LETB,LETC,LETD,LETE,LETZ,INU0,INU9,IPRD,IPLUS,ISEMI,IEQLS
     2,ICOLN,IBLNK,IRAGL,ILAGL,IAT,INLOD,ICOMA,ICLAS(7)
      LOGICAL RELASM,XREF,PASS1,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG
     1	  ,ANYPCH,CODE,LOCALS
      COMMON /LIMITS/ NSYMX,NREFX,NLINEX,NCERX,NEREFX
      COMMON / SYMTB / SYNAME(1000),SYVALU(1000),SYTYPE(1000),NSYM
      INTEGER SYNAME,SYTYPE,SYVALU,CROSS
C
C
      ERRFLG=.TRUE.
C			     TOO MANY ERRORS
      IF( NCER .GE. 9 ) RETURN
      NCER=NCER+1
      NCERS(NCER) = IA
      RETURN
      END
      SUBROUTINE EVALN( IV, IR )
C
C			     EVALUATE NUMBER STRING IV IN BASE IR
C
C
C
      COMMON NREF,ICH,NLNX,IMODE,LOCCNT,LOCNXT,ICORE,IRADIX,LABEL
     1,INDRCT,NLINE,IPAGE,NCER,NEREF,IOCLAS,ICARD,NWDS,IWTYPE,IRELO
     2,NRELO,IWDCT,IADL,INOLOD,ITITLE,RELASM,XREF,PASS1
     3,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG,ANYPCH,CODE,LOCALS
     4,CROSS(3,1000),LN(81),LNX(81)
     5,ISOUR(80),NEREFS(50),NCERS(10),IWORD(40),IBL(22),LOCS(3)
      COMMON /CDS/ INFILE,IOFILE,IPFILE,ISCR
     1,LETA,LETB,LETC,LETD,LETE,LETZ,INU0,INU9,IPRD,IPLUS,ISEMI,IEQLS
     2,ICOLN,IBLNK,IRAGL,ILAGL,IAT,INLOD,ICOMA,ICLAS(7)
      LOGICAL RELASM,XREF,PASS1,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG
     1	  ,ANYPCH,CODE,LOCALS
      COMMON /LIMITS/ NSYMX,NREFX,NLINEX,NCERX,NEREFX
      COMMON / SYMTB / SYNAME(1000),SYVALU(1000),SYTYPE(1000),NSYM
      INTEGER SYNAME,SYTYPE,SYVALU,CROSS
C
C
      IV = 0
C
      IF( NLNX .LE. 0 ) RETURN
C
      DO  10 I=1,NLNX
      K = LNX(I) -28
      IF( K .GE. IR ) CALL ERROR( 1HN )
      IV = IV*IR + K
C
   10 CONTINUE
C
      RETURN
      END
      SUBROUTINE EXPRES( IVAL, ITYP, MODE)
C
C			     EVALUATE EXPRESSION
C
      COMMON NREF,ICH,NLNX,IMODE,LOCCNT,LOCNXT,ICORE,IRADIX,LABEL
     1,INDRCT,NLINE,IPAGE,NCER,NEREF,IOCLAS,ICARD,NWDS,IWTYPE,IRELO
     2,NRELO,IWDCT,IADL,INOLOD,ITITLE,RELASM,XREF,PASS1
     3,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG,ANYPCH,CODE,LOCALS
     4,CROSS(3,1000),LN(81),LNX(81)
     5,ISOUR(80),NEREFS(50),NCERS(10),IWORD(40),IBL(22),LOCS(3)
      COMMON /CDS/ INFILE,IOFILE,IPFILE,ISCR
     1,LETA,LETB,LETC,LETD,LETE,LETZ,INU0,INU9,IPRD,IPLUS,ISEMI,IEQLS
     2,ICOLN,IBLNK,IRAGL,ILAGL,IAT,INLOD,ICOMA,ICLAS(7)
      LOGICAL RELASM,XREF,PASS1,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG
     1	  ,ANYPCH,CODE,LOCALS
      COMMON /LIMITS/ NSYMX,NREFX,NLINEX,NCERX,NEREFX
      COMMON / SYMTB / SYNAME(1000),SYVALU(1000),SYTYPE(1000),NSYM
      INTEGER SYNAME,SYTYPE,SYVALU,CROSS
C
C
C			     MODE 1 SINGLE PRECISION  (0 END)
C				  2= D.P 3=F.P
C				  4,THRU 9  +,-,*,/,AND,OR  (OPERATOR)
      EQUIVALENCE (V,IV)
      LOGICAL FLIP,FRST
      DIMENSION IRES(3)
      EQUIVALENCE (IRES(1),IABX) , (IRES(2),NREL) , (IRES(3),ZREL)
      INTEGER NREL,ZREL
      IVAL = 0
      ITYP = 0
      LASTOP = 4
      NATOMS = 0
      NOPRND = 0
C
      IABX = 0
      NREL = 0
      ZREL = 0
C
      FLIP = .TRUE.
      FRST = .TRUE.
C
      MXMOD=0
      MXOPD=0
C
C
      IF( LN(ICH) .EQ. ICOMA ) ICH = ICH + 1
      CALL SKPBLK
   10 CONTINUE
C			     GET NEXT ATOM OF INPUT STRING
      CALL ATOM( IV, ITP, MODE)
C			     NO MORE
      IF( MODE.EQ.0 ) GO TO 100
      LMODE = MODE
      LTYPE = ITP
      NATOMS = NATOMS + 1
C			     IF( ELEMENT)
      IF( MODE.LT.4 ) GO TO 30
C			     OPERATOR
C			     IF( FIRST TIME ) ALLOW - SIGN ONLY
      IF( .NOT. FRST ) GO TO 20
C			     STARTING WITH OPERATOR - ONLY SET TO ALLOW
      IF( MODE .NE. 5 ) CALL ERROR( 1HQ )
      FLIP = .FALSE.
C
C			     CHECK OPER OPERAND SEQ.
      IF( FLIP ) CALL ERROR( 1HQ)
C			     REMEMBER OPER AND FLIP-FLOP OP-OP SEQ
   20 LASTOP = MODE
      FLIP = .NOT. FLIP
C			     DRIVE ON
      GO TO 10
C			     OPERAND
   30 CONTINUE
      NOPRND = NOPRND + 1
C			     CHECK OPER OPRND SEQ AND SET NOT FIRST
      IF( .NOT. FLIP ) CALL ERROR( 1HQ)
      FLIP = .NOT. FLIP
      FRST = .FALSE.
      MXMOD=MAX0(MXMOD,MODE)
      MXOPD=MAX0(MXOPD,ITP)
C			     CALCULATE AMOUNT OF RELOCATION
      JA = ITP / 2
C			     CALCULATE TYPE OF RELOCATION
      JT = ITP
      IF(JT.EQ.6) GO TO 70
      IF( ITP .GT. 3 ) JT = JT - 2
      IF( LASTOP/2 - 3 ) 40,50,60
C
C			     +,- OPERS
   40 CONTINUE
      IRES(JT) = IOPER( IRES(JT), JA, LASTOP )
      GO TO 70
C
C
C			     *,/ OPERS
   50 CONTINUE
C			     ADJ. REL OPERATORS
      IF(JT.GT.1) GO TO 57
      IIZ  = IOPER( ZREL, IV, LASTOP)
      IIN  = IOPER( NREL, IV, LASTOP)
      IF(LASTOP.NE.7) GO TO 56
      IF( NREL .NE. IIN*IV ) CALL ERROR(1HR)
      IF( ZREL .NE. IIZ*IV ) CALL ERROR(1HR)
   56 CONTINUE
      NREL=IIN
      ZREL=IIZ
      GO TO 70
   57 CONTINUE
      IF(NREL.NE.0.OR.ZREL.NE.0) GO TO 115
      IF(LASTOP.EQ.7) GO TO 115
      IRES(JT)=IOPER(IVAL    ,JA,LASTOP)
      GO TO 70
C
C
C			     AND, OR
   60 CONTINUE
      IF( JT.NE.1 .OR. NREL.NE.0 .OR.ZREL.NE.0 ) CALL ERROR(1HR)
C
C
   70 CONTINUE
C			     PROCESS EXPRESS AND CHECK FOR -F.P.
      IF(MODE.EQ.3) GO TO 75
      IVAL = IOPER( IVAL, IV, LASTOP )
      GO TO 10
   75 CONTINUE
C			     PROCESS -FLOATING PT.
      V = -V
      IVAL = IV
      GO TO 10
C
C			     CHECK RELOC ERROR SET = ABS IF ERROR
  100 CONTINUE
      IF( ERRFLG ) GO TO 125
      IF(MXOPD-6) 101,102,120
  101 CONTINUE
      IF(MXMOD .LE. 1 ) GO TO 103
C			     INCORECT MODE USED ?
      IF(NOPRND .GT. 1 ) GO TO 120
      ITYP=1
      MODE=MXMOD
      GO TO 500
  102 CONTINUE
      IF(NATOMS .GT. 1 ) GO TO 120
C			     EXT DISP USED  CORRECTLY
      MODE=1
      ITYP=6
      GO TO 500
  103 CONTINUE
      IF( NREL.NE.0 .AND. ZREL.NE.0 ) GO TO 120
C
      ITYP = 1
      IREL = NREL + ZREL
      IF( NREL .NE. 0 ) ITYP = 0
      ITYP = ITYP + IREL*2
      IF( ITYP.LT.1 .OR. ITYP.GT.5 ) GO TO 120
C			     EXPRESSION OK
C
      MODE = 1
  500 CONTINUE
      RETURN
C			     ERROR SET ABS VALUE=1  MODE = SINGLE
 115  CALL ERROR(1HQ)
      GO TO 125
  120 CONTINUE
      CALL ERROR( 1HR )
 125  CONTINUE
      IVAL = 0
      ITYP = 1
      MODE = 1
      RETURN
      END
      SUBROUTINE EXTRNL(IV,ITPX)
C
C			     .EXTN, .EXTD, .ENT
C
      COMMON NREF,ICH,NLNX,IMODE,LOCCNT,LOCNXT,ICORE,IRADIX,LABEL
     1,INDRCT,NLINE,IPAGE,NCER,NEREF,IOCLAS,ICARD,NWDS,IWTYPE,IRELO
     2,NRELO,IWDCT,IADL,INOLOD,ITITLE,RELASM,XREF,PASS1
     3,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG,ANYPCH,CODE,LOCALS
     4,CROSS(3,1000),LN(81),LNX(81)
     5,ISOUR(80),NEREFS(50),NCERS(10),IWORD(40),IBL(22),LOCS(3)
      COMMON /CDS/ INFILE,IOFILE,IPFILE,ISCR
     1,LETA,LETB,LETC,LETD,LETE,LETZ,INU0,INU9,IPRD,IPLUS,ISEMI,IEQLS
     2,ICOLN,IBLNK,IRAGL,ILAGL,IAT,INLOD,ICOMA,ICLAS(7)
      LOGICAL RELASM,XREF,PASS1,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG
     1	  ,ANYPCH,CODE,LOCALS
      COMMON /LIMITS/ NSYMX,NREFX,NLINEX,NCERX,NEREFX
      COMMON / SYMTB / SYNAME(1000),SYVALU(1000),SYTYPE(1000),NSYM
      INTEGER SYNAME,SYTYPE,SYVALU,CROSS
C
C
C
C
      COMMON /ADDON1/ NEXTD,ASMEND
      LOGICAL ASMEND
C			     PROCESS EXTERNALS AND ENTRY PSUEDOS
C
      NWDS = 0
      IWORD(1) = 0
      IWTYPE = 1
      IOCLAS = 4
      IF( SKPFLG ) RETURN
      RELASM = .TRUE.
      IF( CODE ) CALL ERROR(1HG)
C			     GET WHICH TYPE OF EXTERNAM
      J = IAND( IV, 7)
      GO TO ( 10,15,30) , J
C
   10 CONTINUE
C			     .EXTN
      CALL NEXTNM(NAME)
      IF( NAME .EQ. 0 ) RETURN
      CALL ADDSYM( NAME, 65535, 25)
      GO TO 10
C
   15 CONTINUE
C			     .EXTD
      IF( .NOT. PASS1 .AND. PTAPE) CALL STRBLK(4)
   20 CONTINUE
C			     LOOP OVER NAMES
      CALL NEXTNM( NAME )
      IF( NAME .EQ. 0 ) GO TO 25
      CALL ADDSYM( NAME, NEXTD, 6)
      NEXTD = NEXTD + 1
      IF( PASS1 .OR. .NOT. PTAPE ) GO TO 20
C			     ADD NAME TO UOTPUT BLOCK
      CALL ADSBLK( NAME,3,32767,0)
      GO TO 20
   25 CONTINUE
      IF( PTAPE .AND. .NOT.PASS1 ) CALL PUTBLK
      RETURN
   30 CONTINUE
C			     .ENT
      IF( PASS1 ) RETURN
C			     START DISP BLOCK
      IF( PTAPE ) CALL STRBLK( 3)
   35 CONTINUE
C			     LOOP OVER NAMES
      CALL NEXTNM( NAME )
      IF( NAME .EQ. 0 ) GO TO 40
      CALL LOOKUP (NAME, IVA, IT)
      IF( IT.LE.0 .OR. IT.GT.5 ) CALL ERROR(1HG)
      IF( PTAPE ) CALL ADSBLK( NAME,0, IVA,IT)
      GO TO 35
C
   40 CONTINUE
C			     OUTPUT REMAINDER
      IF( PTAPE ) CALL PUTBLK
      RETURN
      END
      SUBROUTINE FINASM
C
C			     ALL ASSEMBLIES COMPLETED STOP
      STOP 77
C
      END
      SUBROUTINE FIND(NAME,II)
      DIMENSION ID(11)
C	 RLASM,ABASM,LDOPS,NXREF,LOCLS,NTAPE,NLIST,SEQ,IN,OUT,LIST
      DATA ID /O221401231500, O010201231500, O140417202300,
     *O163022050600, O141703142300, O162401200500, O161411232400,
     *O230521000000,O111600000000, O172524000000, O141123240000 /
      DO 100 I=1,11
      II=I
      IF(NAME.EQ.ID(II)) GO TO 500
  100 CONTINUE
      II=0
  500 CONTINUE
      RETURN
      END
      SUBROUTINE FLUSH
C
C
      COMMON /PCHB/ J,IBUF(40)
      IF( J .GT. 0 ) GO TO 10
    5 J = 0
      RETURN
   10 DO 20 I=1,J
      IPCWRD=IBUF(I)
      CALL OUTBIN (IPCWRD)
   20 CONTINUE
      GO TO 5
      END
      SUBROUTINE FPFMT(VAL)
C			     CONVERT FLOATING POINT WORD TO NOVA FORMAT
      VAL = VAL
C
      RETURN
      END
      SUBROUTINE GETDEC( IVALUE)
C
C
      COMMON NREF,ICH,NLNX,IMODE,LOCCNT,LOCNXT,ICORE,IRADIX,LABEL
     1,INDRCT,NLINE,IPAGE,NCER,NEREF,IOCLAS,ICARD,NWDS,IWTYPE,IRELO
     2,NRELO,IWDCT,IADL,INOLOD,ITITLE,RELASM,XREF,PASS1
     3,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG,ANYPCH,CODE,LOCALS
     4,CROSS(3,1000),LN(81),LNX(81)
     5,ISOUR(80),NEREFS(50),NCERS(10),IWORD(40),IBL(22),LOCS(3)
      COMMON /CDS/ INFILE,IOFILE,IPFILE,ISCR
     1,LETA,LETB,LETC,LETD,LETE,LETZ,INU0,INU9,IPRD,IPLUS,ISEMI,IEQLS
     2,ICOLN,IBLNK,IRAGL,ILAGL,IAT,INLOD,ICOMA,ICLAS(7)
      LOGICAL RELASM,XREF,PASS1,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG
     1	  ,ANYPCH,CODE,LOCALS
      COMMON /LIMITS/ NSYMX,NREFX,NLINEX,NCERX,NEREFX
      COMMON / SYMTB / SYNAME(1000),SYVALU(1000),SYTYPE(1000),NSYM
      INTEGER SYNAME,SYTYPE,SYVALU,CROSS
C
C
      IVALUE = 0
      CALL GETNS
      IF( NLNX .LE. 0 ) CALL ERROR(1HN )
      CALL EVALN( IVALUE, 10 )
      RETURN
      END
      SUBROUTINE GETNS
C
C
      COMMON NREF,ICH,NLNX,IMODE,LOCCNT,LOCNXT,ICORE,IRADIX,LABEL
     1,INDRCT,NLINE,IPAGE,NCER,NEREF,IOCLAS,ICARD,NWDS,IWTYPE,IRELO
     2,NRELO,IWDCT,IADL,INOLOD,ITITLE,RELASM,XREF,PASS1
     3,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG,ANYPCH,CODE,LOCALS
     4,CROSS(3,1000),LN(81),LNX(81)
     5,ISOUR(80),NEREFS(50),NCERS(10),IWORD(40),IBL(22),LOCS(3)
      COMMON /CDS/ INFILE,IOFILE,IPFILE,ISCR
     1,LETA,LETB,LETC,LETD,LETE,LETZ,INU0,INU9,IPRD,IPLUS,ISEMI,IEQLS
     2,ICOLN,IBLNK,IRAGL,ILAGL,IAT,INLOD,ICOMA,ICLAS(7)
      LOGICAL RELASM,XREF,PASS1,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG
     1	  ,ANYPCH,CODE,LOCALS
      COMMON /LIMITS/ NSYMX,NREFX,NLINEX,NCERX,NEREFX
      COMMON / SYMTB / SYNAME(1000),SYVALU(1000),SYTYPE(1000),NSYM
      INTEGER SYNAME,SYTYPE,SYVALU,CROSS
C
C
      NLNX = 0
   10 CONTINUE
      CALL IATNOL
      IF( LN(ICH).LT.INU0 .OR. LN(ICH).GT.INU9 ) RETURN
      NLNX = NLNX+1
      LNX(NLNX) = LN(ICH)
      ICH = ICH+1
      GO TO 10
      END
      SUBROUTINE GETNUM( IVALU, ITYPE)
C
C
      COMMON NREF,ICH,NLNX,IMODE,LOCCNT,LOCNXT,ICORE,IRADIX,LABEL
     1,INDRCT,NLINE,IPAGE,NCER,NEREF,IOCLAS,ICARD,NWDS,IWTYPE,IRELO
     2,NRELO,IWDCT,IADL,INOLOD,ITITLE,RELASM,XREF,PASS1
     3,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG,ANYPCH,CODE,LOCALS
     4,CROSS(3,1000),LN(81),LNX(81)
     5,ISOUR(80),NEREFS(50),NCERS(10),IWORD(40),IBL(22),LOCS(3)
      COMMON /CDS/ INFILE,IOFILE,IPFILE,ISCR
     1,LETA,LETB,LETC,LETD,LETE,LETZ,INU0,INU9,IPRD,IPLUS,ISEMI,IEQLS
     2,ICOLN,IBLNK,IRAGL,ILAGL,IAT,INLOD,ICOMA,ICLAS(7)
      LOGICAL RELASM,XREF,PASS1,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG
     1	  ,ANYPCH,CODE,LOCALS
      COMMON /LIMITS/ NSYMX,NREFX,NLINEX,NCERX,NEREFX
      COMMON / SYMTB / SYNAME(1000),SYVALU(1000),SYTYPE(1000),NSYM
      INTEGER SYNAME,SYTYPE,SYVALU,CROSS
C
C
      EQUIVALENCE (IV,VALUE)
C
      IR = IRADIX
C			     MOVE A NUMBER STRING TO LNX
      CALL GETNS
C			     IF( NEXT CHAR IS NOT . )
      IF( LN(ICH) .NE. IPRD ) GO TO 50
C			     ITS A . SO  RADIX IS 10. NOW LOOK AT NEXT
      IR = 10
      ICH = ICH +1
      IF( LN(ICH).LT.INU0 .OR. LN(ICH).GT.INU9 ) GO TO 50
C			     IF( NOT A NO. THEN GO LOOK FOR E,D,ETC.
      CALL EVALN( IV, IR )
C			     ITS NO. OF FORM  N.N SO FLT. PT. EVALUATE
C			     INTEGER PART AND LOOK AT FRACT.
      J = ICH
      CALL GETNS
      CALL EVALN( IW, IR )
C			     CALCULATE VALUE OF FP NO.
      VALUE = FLOAT(IV) + FLOAT(IW)*10.0**(-NLNX)
C			     NOW LOOK FOR E FIELD
   20 CONTINUE
C			     SET TYPE TO FLOAT. PT.
      ITYPE = 3
C			     IF( NO E FIELD )
      IF( LN(ICH) .NE. LETE ) GO TO 30
C			     E FIELD SKIP E
      ICH = ICH +1
C			     LOOK FOR + -
      B = 1.0
      IF( LN(ICH).NE.IPLUS .AND. LN(ICH).NE.IPLUS+1 ) GO TO 25
C			     + OR - ADV CHAR AND SET EXP - IF -
      IF( LN(ICH) .NE. IPLUS ) B = -1.0
      ICH = ICH +1
C			     GET DECIMAL EXP FIELD
   25 CONTINUE
      CALL GETDEC( IEXP )
C			     NOTE NO CHECK ON EXP RANGE
      VALUE = VALUE*10.0**(B*FLOAT(IEXP))
   30 CONTINUE
      CALL FPFMT( VALUE )
   35 IVALU = IV
      RETURN
C
C
   50 CONTINUE
      IF( LN(ICH) .NE. LETE )  GO TO 60
      IR = 10
C
      CALL EVALN( IV, IR )
      VALUE = FLOAT( IV)
      GO TO 20
C
C
C
   60 CONTINUE
      IF( LN(ICH) .NE. LETD ) GO TO 70
      ICH = ICH +1
      ITYPE = 2
      CALL EVALN( IV, IR)
      CALL RANGE( IV, 2)
      GO TO 35
C
C
   70 CONTINUE
      ITYPE = 1
      IF( LN(ICH) .NE. LETB ) GO TO 80
      CALL EVALN( IV, IR )
      ICH = ICH+1
      CALL GETDEC( ISHFT )
      IV = ILEFT(IV, 15-ISHFT)
   75  CALL RANGE(IV, 1)
      GO TO 35
   80 CONTINUE
      CALL EVALN( IV,IR)
      GO TO 75
      END
      SUBROUTINE GETSTR
C
C
      COMMON NREF,ICH,NLNX,IMODE,LOCCNT,LOCNXT,ICORE,IRADIX,LABEL
     1,INDRCT,NLINE,IPAGE,NCER,NEREF,IOCLAS,ICARD,NWDS,IWTYPE,IRELO
     2,NRELO,IWDCT,IADL,INOLOD,ITITLE,RELASM,XREF,PASS1
     3,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG,ANYPCH,CODE,LOCALS
     4,CROSS(3,1000),LN(81),LNX(81)
     5,ISOUR(80),NEREFS(50),NCERS(10),IWORD(40),IBL(22),LOCS(3)
      COMMON /CDS/ INFILE,IOFILE,IPFILE,ISCR
     1,LETA,LETB,LETC,LETD,LETE,LETZ,INU0,INU9,IPRD,IPLUS,ISEMI,IEQLS
     2,ICOLN,IBLNK,IRAGL,ILAGL,IAT,INLOD,ICOMA,ICLAS(7)
      LOGICAL RELASM,XREF,PASS1,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG
     1	  ,ANYPCH,CODE,LOCALS
      COMMON /LIMITS/ NSYMX,NREFX,NLINEX,NCERX,NEREFX
      INTEGER SYNAME,SYTYPE,SYVALU,CROSS
      COMMON / SYMTB / SYNAME(1000),SYVALU(1000),SYTYPE(1000),NSYM
C
C
C
C
C			     GET CHAR STRING FROM LN AND PUT INTO LNX
C			     IGNORE LEADING BLANKS STOP AT FIRST SPECIAL
C			     AFTER STRING. BLANK IS SPCL IFF FIRST CHAR
C			     AFTER BLANKS IS NON-SPCL.	ICH POINTS TO
C			     TERMINATOR.  NLNX IS NO. CHARS IN LNX.
C
      NLNX = 0
C			     SKIP LEADING BLANKS
      CALL SKPBLK
C			    IF( CHAR IS NON(ALPHA-NUMERIC OR .))END STRG
 10   CONTINUE
      CALL IATNOL
      IF( LN(ICH) .GT. INU9) GO TO 20
C			     MOVE CHAR TO LNX ITS PART OF STRING
      NLNX = NLNX +1
      LNX(NLNX) = LN(ICH)
      ICH = ICH + 1
      GO TO 10
C
C
   20 CONTINUE
C			     IF( CHAR NON BLANK)CHAR IS TERM.
      IF( LN(ICH) .NE. IBLNK ) GO TO 30
C			     TERMINATOR IS A BLANK. LOOK FOR SPCL AFTER
C			     A BLANK STRING
      CALL SKPBLK
C			     IF( NEXT NOT SPCL) BLANK IS TERM.
       IF( LN(ICH) .LE. INU9) ICH = ICH - 1
   30 CONTINUE
C			     RESET ICH TO TERM. CHAR.
      RETURN
      END
      SUBROUTINE GETSYM( NAME)
C
C
      COMMON NREF,ICH,NLNX,IMODE,LOCCNT,LOCNXT,ICORE,IRADIX,LABEL
     1,INDRCT,NLINE,IPAGE,NCER,NEREF,IOCLAS,ICARD,NWDS,IWTYPE,IRELO
     2,NRELO,IWDCT,IADL,INOLOD,ITITLE,RELASM,XREF,PASS1
     3,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG,ANYPCH,CODE,LOCALS
     4,CROSS(3,1000),LN(81),LNX(81)
     5,ISOUR(80),NEREFS(50),NCERS(10),IWORD(40),IBL(22),LOCS(3)
      COMMON /CDS/ INFILE,IOFILE,IPFILE,ISCR
     1,LETA,LETB,LETC,LETD,LETE,LETZ,INU0,INU9,IPRD,IPLUS,ISEMI,IEQLS
     2,ICOLN,IBLNK,IRAGL,ILAGL,IAT,INLOD,ICOMA,ICLAS(7)
      LOGICAL RELASM,XREF,PASS1,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG
     1	  ,ANYPCH,CODE,LOCALS
      COMMON /LIMITS/ NSYMX,NREFX,NLINEX,NCERX,NEREFX
      INTEGER SYNAME,SYTYPE,SYVALU,CROSS
      COMMON / SYMTB / SYNAME(1000),SYVALU(1000),SYTYPE(1000),NSYM
C
C
C
      NAME =0
      J = ICH
      CALL GETSTR
C
      IF( LNX(1).LE.IPRD .AND. NLNX.GT.0 ) GO TO 10
C			     ITS NOT A SYMBOL SET NAME = 0
      ICH = J
      CALL SKPBLK
      RETURN
C
C			      IT IS A SYMBOL
   10 CONTINUE
      CALL CONSS( NAME)
      RETURN
      END
      SUBROUTINE HEADR
      COMMON NREF,ICH,NLNX,IMODE,LOCCNT,LOCNXT,ICORE,IRADIX,LABEL
     1,INDRCT,NLINE,IPAGE,NCER,NEREF,IOCLAS,ICARD,NWDS,IWTYPE,IRELO
     2,NRELO,IWDCT,IADL,INOLOD,ITITLE,RELASM,XREF,PASS1
     3,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG,ANYPCH,CODE,LOCALS
     4,CROSS(3,1000),LN(81),LNX(81)
     5,ISOUR(80),NEREFS(50),NCERS(10),IWORD(40),IBL(22),LOCS(3)
      COMMON /CDS/ INFILE,IOFILE,IPFILE,ISCR
     1,LETA,LETB,LETC,LETD,LETE,LETZ,INU0,INU9,IPRD,IPLUS,ISEMI,IEQLS
     2,ICOLN,IBLNK,IRAGL,ILAGL,IAT,INLOD,ICOMA,ICLAS(7)
      LOGICAL RELASM,XREF,PASS1,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG
     1	  ,ANYPCH,CODE,LOCALS
      COMMON /LIMITS/ NSYMX,NREFX,NLINEX,NCERX,NEREFX
      INTEGER SYNAME,SYTYPE,S,CROSS
      COMMON / SYMTB / SYNAME(1000),SYVALU(1000),SYTYPE(1000),NSYM
C
C
      DATA VERSIO /2.01/
      IPAGE=IPAGE+1
      WRITE (IOFILE,1000) VERSIO, IPAGE
 1000 FORMAT (1H1,10X33H NOVA/SUPERNOVA ASSEMBLER VERSION, F5.2,
     * 25X,4HPAGE I5/)
      NLINE=1
      RETURN
      END
      FUNCTION IASCII( K )
      DIMENSION ITXT(63)
      DATA ITXT /65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,
     1		  81,82,83,84,85,86,87,88,89,90,
     2		  46,48,49,50,51,52,53,54,55,56,57,
     3		  43,45,42,47,38,33,32,44,34,64,35,59,58,60,62,
     4            36,37,39,40,41,63,92,93,94,95,61 /
      L = IAND( K, 63 )
      IF (L.EQ.0) GO TO 5
      IASCII = ITXT(L)
      RETURN
    5 IASCII = 92
      RETURN
      END
 6