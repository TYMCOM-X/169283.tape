!26 FEB  73   NIPR1.SIM    *MH
!MISCELLANEOUS FUNCTIONS AND PROCEDURES

!FOR PDP-10
 DEF PDP.MOV(N,F,T) AS MOVE N FROM F TO T
!FOR XDS-940
!DEF PDP.MOV(N,F,T) AS
DEF XDS.940.P AS 1-BITS.PER.WORD/25

FIND N.AREA(0)
FIND BUFFERLETS
FIND C.B.AREA
FIND S.TBL.PTR
FIND CMD.STR()
FIND STORE(0)
FIND WORKSPACE(0)

FIND %G.ANCHOR      !********
FIND %ON.ALT.C
FIND %INIT.ANCHORS
FIND %R.P.L.DATA
FIND %L.P.L.DATA
FIND %INIT.LN
FIND %INIT.S.T
FIND %WORK.TO.BUF
FIND %GET.BUF.CHAR            !GET A CHARACTER OUT OF A BUFFERLET
FIND %C.AREA
FIND %INIT.BUF
FIND %INIT.MOD
FIND %INIT.SLA
FIND %INIT.LST
FIND %INIT.S.M
FIND %INIT.MASTER
FIND %C.ELMTS
FIND %G.ELMT

GLOBAL HACK.TEMP               !USED BY L.BYT
GLOBAL MASK(0:BITS.PER.WORD)
GLOBAL MASK.COMP(0:BITS.PER.WORD)
GLOBAL LINE.IMAGE(0:100)
GLOBAL CR.STRING
GLOBAL RADIX
GLOBAL CMND.BLK.AREA
GLOBAL CHAR.PROP(0:255)

GLOBAL %FM.FR.INT
GLOBAL %FM.INT
GLOBAL %INIT.NET                !INITIALIZE
GLOBAL %MV.N.F.T
GLOBAL %FM.STRING               !MAP A SIMPL STRING TO BUFFERLETS

GLOBAL %INIT.CHAR.PROP
LOCAL %INIT.MSK               !INITIALIZE MASK AND MASK.COMP ARRAYS
!
%FM.INT(STRING,NUMBER,FIELD)  !FORMAT AN INTEGER IN FIXED FIELD
!INPUT: STRING POINTER, A NUMBER, A FIELD SIZE
!VALUE: STRING POINTER

!FORMATS AN INTEGER AS ASCII-8 CHARACTERS ON END OF BUFFERLET STRING.
!INTEGER IN LOW-ORDER PORTION OF FIELD.
!SIGN: FORMATED NEXT TO THE INTEGER. SIGN IS SPACE IF NUMBER IS
!POSITIVE, "-" OTHERWISE.  LEADING ZEROS ARE SUPPRESSED. ZERO
!NUMBER YIELDS "0".  IF THE FIELD IS TOO SMALL FOR THE INTEGER,
!THEN IT IS FORMATTED AS A STRING OF "X"S.  IF THERE IS NO
!ROOM FOR A "-" SIGN, THEN THE FIELD IS FORMATTED AS A
!STRING OF "-"S.  IF FIELD SIZE IS <= 0 THEN ONE GETS A ZERO
!LENGTH FIELD.  RADIX 2 IS A SPECIAL CASE

LOCAL I, SIGN, OSIGN !ORIGINAL SIGN!, OFIELD !ORIGINAL FIELD!

IF FIELD <= 0 THEN RETURN(STRING)
WORK.SPACE(0) Z OFIELD Z FIELD

IF RADIX = 2 &
 THEN &
  DO
  IF NUMBER = 0 &
   THEN &
    DO          !BINARY ZERO CASE
    WORK.SPACE(FIELD) Z XZERO      !FORCE '0'
    REPEAT FIELD-1 WORKSPACE(DEC FIELD) Z XSP
    RETURN(WORK.TO.BUF(STRING))
    END
  WHILE FIELD > 0 &
   THEN &
    DO
    !           RADIX 2 CONVERSION
    WORKSPACE(1+DEC FIELD) Z (NUMBER BAND 1)+XZERO
    NUMBER Z NUMBER SHR 1
    END
  RETURN(WORK.TO.BUF(STRING))
  END


!SET SIGN
IF NUMBER >= 0 &
 THEN SIGN Z XSP &
 ELSE &
  DO
  SIGN Z XMINUS
  NUMBER Z -NUMBER
  END
OSIGN Z SIGN

!FORM CHARACTERS IN WORKSPACE
IF NUMBER =0 &
 THEN &
  DO             !ZERO CASE
  WORK.SPACE(FIELD) Z XZERO   !FORCE '0'
  REPEAT FIELD-1 WORKSPACE(DEC FIELD) Z XSP
  END &
 ELSE &
  DO             !ROUTINE CASE
  WHILE FIELD > 0 &
   THEN &
    DO
    IF NUMBER # 0 &
     THEN &
      DO 
     !WORK.SPACE(1+DEC FIELD) Z XZERO + (NUMBER MOD RADIX)
      LOCAL TEMP
      TEMP Z XZERO + (NUMBER MOD RADIX)
      WORK.SPACE(1+DEC FIELD) Z TEMP
      NUMBER Z NUMBER/RADIX
      END &
     ELSE &
      DO
      WORKSPACE(1+DEC FIELD) Z SIGN
      SIGN Z XSP     !SET TO PROVIDE LEADING SPACES
                     !AND NOTE '-' USED
      END
    END
  IF NUMBER # 0 &
   THEN &
    DO         !NUMBER TOO BIG FOR FIELD
    REPEAT OFIELD WORK.SPACE(1+DEC OFIELD) Z XX
    END &
   ELSE &
    DO
    IF SIGN = XMINUS &
     THEN &
      DO       !NOT ENOUGH ROOM FOR NEGATIVE SIGN, FLAG IT
      REPEAT OFIELD WORK.SPACE(1+DEC OFIELD) Z XMINUS
      END
    END
  END
RETURN(WORK.TO.BUF(STRING))
END FM.INT
!
%INIT.NET                      !INITIALIZATION
!INPUT: NONE
!VALUE: TRUE IF SUCCESSFUL, ELSE FALSE

TABLE NAMES(1:MAX.CMND) [ &
 'BCKT'&
,'CHAN'&
,'ECHO'&
,'ECHOR'&
,'NULL'&
,'PAUSE'&
,'QUIT'&
,'RTEXT'&
,'STEXT'&
,'SENDV'&
,'SETV'&
,'VAR'&
,'WSLAVE'&
,'ZCKT'&
,'DATA'&
,'ERR'&
,'OPEN'&
,'CLOSE'&
,'SBLKS'&
,'ERASE'&
,'CLOSEA'&
,'WRITE'&
,'RENAME'&
,'RBLKS'&
,'STEST'&
,'SENDFS'&
,'SETBS'&
,'SETFS'&
,'SETCP'&
,'SENDBS'&
,'BSDATA'&
,'SENDFCB'&
,'FCBDATA'&
,'SENDCP'&
,'CREATE'&
,'CHOKE'&
,'ACKP'&
,'ACKN'&
,'BCKSUM'&
,'BDATA'&
,'MACK'&
]
LOCAL P,A

RADIX Z 10
INIT.MSK                      !MASK AND MASK COMPLEMENT

!INIT CR.STRING
CH(@CR.STRING,0)  Z  CARRET
CH(@CR.STRING,1)  Z  E.O.LIT
CH(@CR.STRING,2)  Z  E.O.LIT

!INIT CMD.STR ARRAY WITH CMD NAME LITERALS
CMD.STR Z NAMES
IF NOT INIT.S.M THEN RETURN(FALSE)   !SPACE MANAGEMENT

!ZERO OUT LIST AREA ANCHORS SO FUSBUDGET DOESN'T GET CONFUSED
S.TBL.PTR Z 0
C.B.AREA Z 0
N.AREA(2) Z 0
N.AREA(3) Z 0
N.AREA(4) Z 0
BUFFERLETS Z 0
IF NOT INIT.LST THEN RETURN(FALSE)   !LISTS

IF NOT INIT.BUF THEN RETURN(FALSE)      !BUFFERLETS

IF NOT INIT.ANCHORS THEN RETURN(FALSE)     !ANCHORS

IF NOT INIT.MOD THEN RETURN(FALSE)   !MODEM

IF NOT INIT.SLA THEN RETURN(FALSE)   !SLAVE

                                !MASTER
                                !TEMPORARY   ****
FIND MAST.Q
FIND PREV.PTR
FIND STACK.Q
MAST.Q Z G.ANCHOR
PREV.PTR Z G.ANCHOR
STACK.Q Z G.ANCHOR

IF NOT INIT.MASTER THEN RETURN(FALSE)

IF NOT INIT.LN THEN RETURN(FALSE)    !LINES

IF NOT INIT.CHAR.PROP THEN RETURN(FALSE)

IF NOT INIT.S.T THEN RETURN(FALSE)     !SYMBOL TABLE

CMND.BLK.AREA Z C.ELMTS(ENCODED.CMND.SIZE,3)  !COMMAND BLOCK AREA

RETURN(TRUE)
END INIT.NET
!
%INIT.MSK                     !INITIALIZE MASK AND MASK.COMP ARRAYS
!INPUT: NONE
!VALUE: NONE

LOCAL  N, TWO.TO.THE.N

N Z 0
TWO.TO.THE.N Z 1
WHILE N < BITS.PER.WORD-1   &
 THEN &
  DO
  MASK.COMP(N) Z (MASK(N) Z TWO.TO.THE.N - 1) BXOR -1
  TWO.TO.THE.N Z TWO.TO.THE.N * 2
  INC N
  END

MASK.COMP(BITS.PER.WORD-1) Z     &
         (MASK(BITS.PER.WORD-1) Z TWO.TO.THE.N  SHL 1) BXOR -1

MASK(BITS.PER.WORD) Z -1
MASK.COMP(BITS.PER.WORD) Z 0
RETURN
END INIT.MSK
!
%FM.STRING(BUF,A.CHPT)         !FORMAT A STRING TO BUFFERLETS
!INPUT:BUFFERLET STRING POINTER, OR E.O.L; A CHPT VALUE TO A SIMPL STR
!VALUE: POINTER TO BUFFERLET STRING PRODUCED

LOCAL I,CHAR

ON.ALT.C
PCHV(A.CHPT)
I Z 0
!PEEL OFF THE CHARACTERS
WHILE CHAR Z NCHV(A.CHPT) # EOLIT &
 THEN &
  DO
  WORK.SPACE(INC I) Z CHAR.XFORM.TO.ASCII(CHAR)  !XFORM TO 8-BIT
  IF I >= MAX.WORK.SPACE &
   THEN &
    DO         !PACK AWAY A WORK SPACE FULL
    WORK.NUM.CHARS Z MAX.WORK.SPACE
    BUF Z WORK.TO.BUF(BUF)
    I Z 0
    END
  END

IF I # 0 &
 THEN &
  DO           !PACK LAST FEW AWAY
  WORK.NUM.CHARS Z I
  BUF Z WORK.TO.BUF(BUF)
  END

RETURN(BUF)
END FM.STRING
!
%INIT.CHAR.PROP         !INITIALIZE CHAR.PROP TABLE
!INPUT: NONE
!VALUE: TRUE

LOCAL I

DEF SET(F,T,FN) BY
 I Z OCT F - 1
 WHILE INC I <= OCT T THEN FN(I) Z TRUE
ENDM SET

!ZERO OUT CHAR.PROP ARRAY (: NO CHARS BELONG TO ANY CLASS)
I Z -1
REPEAT 256 CHAR.PROP(INC I) Z 0    !ALL FIELDS FALSE

!SET "OTHERS"
SET(0,200,C.P.OTHER)
SET(204,211,C.P.OTHER)
SET(213,214,C.P.OTHER)
SET(216,237,C.P.OTHER)
SET(241,253,C.P.OTHER)
SET(255,257,C.P.OTHER)
SET(272,272,C.P.OTHER)
SET(274,300,C.P.OTHER)
SET(333,340,C.P.OTHER)
SET(373,376,C.P.OTHER)

!SET ALPHAS
SET(301,332,C.P.ALPHA)
SET(301,332,C.P.ALPHA.NUMERIC)
SET(341,372,C.P.ALPHA)
SET(341,372,C.P.ALPHA.NUMERIC)

!SET NUMERICS
SET(260,271,C.P.NUMERIC)
SET(260,271,C.P.ALPHA.NUMERIC)

!SET EOC
SET(212,212,C.P.EOC)            !LINE FEED
SET(215,215,C.P.EOC)            !CARRIAGE RETURN
SET(273,273,C.P.EOC)            !SEMI-COLON

!SET SOH, ETC.
SET(201,203,C.P.SOH)

!SET TEXT TERMINATORS
SET(201,203,C.P.TEXT.TERM)      !SOH LIST
SET(212,212,C.P.TEXT.TERM)      !LINE FEED
SET(215,215,C.P.TEXT.TERM)      !CARRIAGE RETURN
SET(273,273,C.P.TEXT.TERM)      !SEMI-COLON

!SET MISC. ODDS AND ENDS
SET(240,240,C.P.SPACE)          !SPACE
SET(254,254,C.P.COMMA)          !COMMA
SET(377,377,C.P.DEL)            !DEL
RETURN(TRUE)
END INIT.CHAR.PROP
%MV.N.F.T(NUM,F(),T())   !MOVE N WORDS FROM F TO T
!INPUT:  1)  NUMBER OF WORDS TO BE MOVED
!        2)  ADDRESS OF "FROM" BLOCK
!        3)  ADDRESS OF "TO" BLOCK
!VALUE: TRUE

LOCAL I

!THREE CASES:  MOVE DOWN,, DON'T MOVE, MOVE UP

IF F = T THEN RETURN(TRUE)   !DON'T MOVE CASE

IF F > T &
 THEN &
  DO            !MOVE DOWN
  I Z -1
  WHILE INC I < NUM THEN T(I) Z F(I)
  END &
 ELSE &
  DO            !MOVE UP
  I Z NUM
  WHILE DEC I >= 0 THEN T(I) Z F(I)
  END

RETURN(TRUE)
END MV.N.F.T
!
%FM.FR.INT(STRING,NUMBER)           !FORMAT AN INTEGER IN A FREE FIELD
!INPUT: BUFFERLET STRING PTR, OR E.O.L; A NUMBER FOR CONVERSION
!VALUE: BUFFERLET STRING POINTER, OR E.O.L

!DOES THE OBVIOUS THING WITH AN INTEGER: SIGN IF NEGATIVE, THE DIGITS,
!NO SPACES ANYWHERE.  CONVERSION IS ACCORDING TO RADIX.

LOCAL M.SIGN.P,   I,   TEMP,   J

M.SIGN.P Z FALSE

IF NUMBER=0 &
 THEN &
  DO            !ZERO CASE
  WORKSPACE(0) Z 1
  WORKSPACE(1) Z XZERO
  RETURN(WORK.TO.BUF(STRING))
  END

IF NUMBER < 0 &
 THEN &
  DO
  M.SIGN.P Z TRUE
  NUMBER Z -NUMBER
  END

I Z 37
WHILE NUMBER # 0 &
 THEN &
  DO            !ROUTINE CASE
  TEMP Z XZERO + (NUMBER MOD RADIX)
  WORKSPACE(DEC I) Z TEMP
  NUMBER Z NUMBER/RADIX
  END

IF M.SIGN.P THEN WORKSPACE(DEC I) Z XMINUS

WORK.NUM.CHARS Z TEMP Z 37-I
J Z 0
WHILE INC J <= TEMP THEN WORKSPACE(J) Z WORKSPACE(INC I - 1)
RETURN(WORK.TO.BUF(STRING))
END FM.FR.INT
 