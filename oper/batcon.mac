IFNDEF	FTOPR,<FTOPR==1>	;FTOPR=0 BOTH,FTOPR=1 ONLY BATCON,FTOPR=-1 ONLY BATOPR

IFGE FTOPR,<	TITLE BATCON-- BATCH CONTROL----MPB>
IFL FTOPR,<	TITLE BATOPR-- BATCH OPERATOR SEGMENT-- MPB>

	SUBTTLE	R.DHAR/RD  AUG 08 72

;****COPYRIGHT 1970,1971,1972  DIGITAL EQUIPMENT CORP., MAYNARD, MASS.****

;BATCON IS ASSEMBLED AS A TWO SEGMENT PROGRAM OR A SINGLE SEGMENT PROGRAM
;WHEN FTOPR==0 AND IS  LOADED WITH QUEUER ,AND HELPER BEFORE SAVING IT.
;THE INSTRUCTION FOR LOADING ARE GIVEN BELOW

;R LOADER
;SYS:QUEUER,HELPER,DSK:BATCON$
;SSAV DSK: BATCON

;IF THE CONTROLLER IS ASSEMBLED AS A MULTISEGMENT PROGRAM I,E.,
;AS BATCON AND BATOPR. THESE TWO SEGMENT ARE ASSEMBLED WITH FTOPR=1(DEFAULT)
;AND FTOPR=-1 RESPECTIVELY. LOADING INSTRUCTIONS FOR THE TWO SEGMENTS ARE
;GIVEN BELOW
;
;
;LOADING INSTRUCTIONS FOR BATCON (INMULTISEGMENT MODE)
;
;R LOADER
;SYS:QUEUER,BATCON$
;SSAV DSK: BATCON
;
;
;LOADING INSTRUCTION FOR BATOPR(IN MULTISEGMENT MODE)
;
;
;R LOADER
;BATOPR,SYS:HELPER$
;D 0 0 133
;SSAV DSK: BATOPR
;THE ORDER OF LOADING MUST BE MAINTAINED AS INDICATED ABOVE
;
;
;THE FOLLOWING DEFAULT PARAMETERS ARE USED IN THE SCHEDULING
;ALGORITHM AND MUST MATCH THOSE USED IN THE QUEUE CUSP.THE WEIGHT
;CONSTANTS USED HOWEVER MAY BE SELECTED INDEPENDTLY. THE SCHEDULING
;ALGORITHM USED IS RATHER SIMPLE AND DESCRIBED
;BELOW IN THE FORM OF AN EQUATION. EACH INSTALLATION MAY LIKE
;TO VARY SOME OF THESE PARAMETERS TO FULFILL INDIVIDUAL
;REQUIREMENTS.




;JOB PRIORITY=1+AEXT*PREXT+(ATM*DEFTIM/TEXT)+(ACR*DEFCOR/CEXT)
;		+(APG*DEFPAG/PEXT)+(ACD*DEFCRD/CDEXT)
;		+(APP*DEFPTP/PPEXT)+(ADP*DEFDSP/DPEXT)
;		+(AGE*AGEFAC)


;WHERE
;	PREXT=EXTERNAL PRIORITY
;	TEXT =TIME SPECIFIED AT JOB SUBMITTAL
;	CEXT =CORE SPECIFIED AT JOB SUBMITTAL
;	PEXT =PAGES SPECIFIED AT JOB SUBMITTAL
;	CDEXT=NUMBER OF CARDS SPECIFIED AT JOB SUBMITTAL
;	PPEXT=PAPER TAPE SPECIFIED AT JOB SUBMITTAL IN FEET
;	DPEXT=DISPLAY TIME SPECIFIED AT JOB SUBMITTAL IN MINUTES
;	AGEFAC=AGE FACTOR COMPUTED AS FUNCTION OF AGE. IT IS LINEAR
;		UPTO DEFAGE AND A MAXIMUM BEYOND IT.

	IFNDEF	ATM,<
		ATM==8			;WEIGHT CONSTANT
		>

	IFNDEF	DEFTIM,<
		DEFTIM==^D60		;DEFAULT RUNTIME IN SECS
			>

		SCD1==ATM*DEFTIM
	IFNDEF	ACR,<
		ACR==8			;WEIGHT CONSTANT
		>
	IFNDEF	DEFCOR,<
		DEFCOR==^D25*^D1024	;DEFAULT CORE IN WORDS
			>
		SCD2==ACR*DEFCOR
	IFNDEF	APG,<
		APG==8			;WEIGHT CONSTANT
		>
	IFNDEF	DEFPAG,<
		DEFPAG==^D200		;DEFAULT PAGES
			>
		SCD3==APG*DEFPAG
	IFNDEF	ACD,<
		ACD==0			;WEIGHT CONSTANT
		>
	IFNDEF	DEFCRD,<
		DEFCRD==^D500		;DEFAULT CARD PUNCH CARDS
			>
		SCD4==ACD*DEFCRD
	IFNDEF	APP,<
		APP==8			;WEIGHT CONSTANT
		>
	IFNDEF	DEFPTP,<
		DEFPTP==^D10		;PAPER TAPE DEFAULT 10 FT
			>
		SCD5==APP*DEFPTP
	IFNDEF	ADP,<
		ADP==0			;WEIGHT CONSTANT
		>
	IFNDEF	DEFDSP,<
		DEFDSP==^D10		;DEFAULT DISPLAY TIME 10 MTS
			>
		SCD6==ADP*DEFPTP
	IFNDEF	AEXT,<
		AEXT==4			;WEIGHT CONSTANT 2*^AEXT
			>
	IFNDEF	AGE,<
		AGE==4			;WEIGHT CONSTANT 2*^AGE
		>
	IFNDEF	DEFAGE,<
		DEFAGE==^D60		;TIME CONSTANT IN MTS
			>
	IFNDEF	MORTIM,<MORTIM==^D10>	;%AGE OF EXTRA TIME GIVEN TO THE JOB

	IFNDEF	DEBUG,<DEBUG==1>	;DEBUG HACK

	IFNDEF	JOBMAX,<JOBMAX==16>	;NUMBER OF BATCH STREAMS

	IFNDEF	MXSLEP,<MXSLEP==^D68>	;DEFAULT SLEEP TIME

	IFNDEF	DEFREQ,<DEFREQ==^D10>	;DEFAULT REQUEUE TIME.10 MINUTES

	IFNDEF	REQMX,<REQMX==^D21600>	;15 DAYS MAXIMUM REQUEUE TIME

	IFNDEF	FTPLS,<FTPLS==1>	;PLEASE COMMAND TRAPPED.

	IFNDEF	PURE,<PURE==1>	;ASSUME REENTRANT

	IFNDEF	FTDFL,<FTDFL==1>	;LIST USER FILES DELETED AT LOGOUT

	IFNDEF	MODFY,<MODFY==^D20>	;#0F TIMES TO WAIT IF LOG FILE MODIFIED.

	IFNDEF	SKPLIN,<SKPLIN==^D25>	;#LINES TO SKIP IN SKIP MODE

	IFNDEF	LEVELC,<LEVELC==0>	;WHEN ZERO IT IS LEVEL D

	IFNDEF	LOOPCT,<LOOPCT==^D50>	;#OF TIMES YOU LISTEN TO A JOB

	IFNDEF	SCHINT,<SCHINT==^D10000>	;SCHEDULING INTERVAL 10 SEC DEFAULT

	IFNDEF	REMSW,<REMSW==1>	;SYSTEM CONFIGURED FOR REMOTE

	IFNDEF	OPRINT,<OPRINT==^D30000>	;OPERATOR INT WHEN SYS JOBS FULL


	VSPECB==0
	VBATCH==010
	VMUDTE==00
	VEDITN==000106

	IFGE	FTOPR,<
	EXTERN	.JBVER,.QUEER

	INTERN	QUEUEN,QUEUEM
	IFN	PURE,<QUEUEN==<SIXBIT/BATCON/>>
	IFE	PURE,<QUEUEN==0>
	QUEUEM==QUEUEN_<-^D18>


	IFG	<JOBMAX-16>,<
PRINTX DEFAULT JOBMAX EXCEEDS 14. DEFAULT OF 14 ASSUMED
	JOBMAX==16
	>
	>


	LOC	137
	VSPECB*100000+VBATCH*100+VMUDTE,,VEDITN


	RELOC
	;AC ASSIGNMENTS

	F=0			;FLAGS PER JOB STREAM.
	A=1			;GENERAL USE
	B=2			;SAVE JOB DATA SIZE
	C=3			;GENERAL USE
	D=4			;GENERAL USE
	E=5			;GENERAL USE
	G=6			;GENERAL USE
	BUF=7			;SAVE PC WORD
	STS=10			;STATUS WORD
	JB=11			;SUBJOB NUMBER
	CH=12			;CHARACTER ACCUMULATOR FOR I/O
	GF=13			;GLOBAL FLAGS
	F2=14			;ACCUMULATOR FOR SECOND FLAG WORD
	T1=15			;TEMPORARY STORAGE
	T2=16			;TEMPORARY STORAGE
	P=17			;PUSHDOWN STACK

	;CONSTANTS

	CH0==0			;CHANNEL 0

	CONTRLC==3		;^C
	BELL==7			;BELL
	HT==11			;TAB
	LF==12			;LINE FEED
	VT==13			;VERTICAL TAB
	FF==14			;FORM FEED
	CR==15			;CARRIAGE RETURN
	CONTRU==25		;CONTROL U(^U)
	QUEPPN==XWD 3,3		;SAVE QUE PPN
	PSIZ==100		;STACK SIZE
	RSCHD==307		;REQUEST TO SCHEDULE
	RCOM==310		;REQUEST COMPLETED
	RQUE==311		;REQUEUE THE JOB
	RCHKPT==313		;REQUEUE WITHOUT RELEASING IT
	DYMTS==^D1440		;NO. OF MINUTES IN A DAY.
	TELSIZ==^D20		;TELL COMMAND BUFFER
	FULPAT==11		;LENGTH OF FULL PATH DIRECTORY
	SFDDEP==5		;DEPTH OF SFD'S
	TTYTAB==10		;FOR GETTAB ARGUMENT
	MSIZ==^D20		;SIZE OF MESSAGE BUFFER
	MCHRC==<5*MSIZ-1>	;TOTAL CHARACTERS IN THE BUFFER
	SWAPED==2000		;JOB SWAPPED.
	JBTSTS==0		;JOBSTATUS
	PRJPRG==2		;PROJECT PROGRAM
	JBTPRG==3		;PROGRAM NAME
	JBTKCT==5		;KILO-CORE TICKS
	JBTRCT==17		;DISK BLOCKS READ
	JBTWCT==20		;DISK BLOCK WRITTEN
	STSTBL==25		;STATUS TABLE
	JBTLIM==40		;TIME LIMIT TABLE
	TTBUF==23		;SIZE OF TTY BUFFER
	BUFSIZ==TTBUF+1		;CONSTANT DEFINED FOR BUFFER RING
	SYSPRG==100		;BIT SET IF A SYSTEMS PROGRAM
	PHYSCL==400000		;SPECIFIES PHYSICAL DEVICE
	MFDPPN==0,,16		;GETTAB ARGUMENT
	SWPNOW==400000		;SET BIT TO SWAP NOW
	DUMP==17		;SPECIFIES DUMP MODE
	HIBR==160		;HIBERNATE CONDITIONS
	NOROOM==40000		;STATUS BIT WHEN DISK FULL
	;LOGIN ERROR CODES
	ERR.TA==1		;ERROR-TRY ANYWAY
	ERR.SF==2		;SEMIFATAL-REQUEUE JOB
	ERR.FA==3		;FATAL ERROR-RELEASE THE JOB
	ERR.NA==4		;SYSTEM NOT AVAILABLE
;GF FLAGS
	ASTRK==1		;WHEN ON BATCH TYPESOUT !
	TTYDDB==2		;SET IF NO TTY DDB'S AVAILABLE
	TTYIOW==4		;SET IF JOB IN TI WAIT
	FRESET==10		;SET TO STOP BATCH IF NO JOBS ACTIVE.
	NOSCH==20		;FLAG SET TO STOP BATCH SCHEDULING
	ALLF==40		;ALL SUBJOBS REQUESTED
	DSPLY==100		;TURN ON DISPLAY
	SLPINF==200		;SLEEP INFIFITE TIME
	SKIP==400		;SKIP INPUT ON LOG FILE
	TTYIN==1000		;JOB REQUESTING INPUT
	SCHRS==2000		;CONDITIONALLY RESTRICT JOB SCHEDULING
	UNIQF==4000		;SCHEDULING FLAG
	EXITB==10000		;SET EXIT FLAG
	MNTR==20000		;TYPEOUT MONITOR SUBJOB#
	MSGL==40000		;FLAG FOR SHORT WHAT COMMAND
	LGIN==100000		;WHEN SET SEND / TO LOGIN
	START==200000		;SET WHEN STARTED VIRGIN
	JOBNAV==400000		;JOB TABLE FULL


	PREVAL==NOSCH+TTYIN
	PRESET==PREVAL+FRESET
	INITIL==PREVAL+ALLF


;HERE RESOLVE TRADEOFF OF USABLE STREAMS


	FSTSTM==^D5		;MAXIMUM ALLOWABLE FAST STREAMS
	CHFACT==^D3		;CHANNEL FACTOR
	MAXCHL==^D15		;MAXIMUM ALLOWABLE CHANNELS
	FSTBUF==^D256		;BUFFER SPACE FOR CONTROL AND LOG FILE
	DSKBUF==^D128
	MAXCHR==5*FSTBUF/2	;MAXIMUM CHARACTERS IN A BLOCK.



	OPDEF	OUTCHR[TTCALL 1,]
	OPDEF	OUTSTR[TTCALL 3,]
	OPDEF	INCHWL[TTCALL 4,]
	OPDEF	CLRBFI [TTCALL 11,]
	OPDEF	SKPINL[TTCALL 14,]
	OPDEF	PJRST[JRST]
	OPDEF	JOBSTS[CALLI 61]
	OPDEF	WHERE[CALLI 63]
	OPDEF	HIBER[CALLI 72]
	OPDEF	WAKE[CALLI 73]
	OPDEF	CHKACC[CALLI 100]



	IFN	FTOPR,<

;HERE DEFINE CONSTANTS FOR CALL TO BATOPR SEGMENT

	L.HISG==1B1	;GET HISEGMENT POINTED BY A
	L.PDLN==1B2	;DONOT RELOCATE PDL.



	PSIZ==PSIZ+50	;REDEFINE THE PDL SIZE


		>
;RIGHT HALF OF FLAG REGISTER AND WORD FLAG (AC F)


	F.ACTV==1		;PTY AVAILABLE 
	F.ENTR==2		;WAS THERE A ENTER FAILURE
	F.LOG==4		;IS THERE A LOG FILE.
	F.KILL==10		;KILL COMMAND RECOGNIZED
	F.PRIV==20		;JOB HAS NO PRIVS TO WRITE
	F.IF==40		;IF COMMAND NOTICED
	F.ERR==100		;1 ERROR CONDITION,0 NOERROR CONDITION
	F.DO==200		;FLAG RESERVED FOR DO COMMAND
	F.GOTO==400		;GOTO COMMAND SEEN
	F.KERR==1000		;KILL COMMAND WITH USER ERROR PROCES.
	F.QSMK==2000		;SET WHEN ERROR ENCOUNTERED IN A JOB
	F.REQ==4000		;SET WHEN JOB CAN'T LOGIN
	F.CTL==10000		;NO CTL FILE
	F.FIN==20000		;JOB FINISHED FLAG.
	F.SETR==40000		;SET WHEN ENTER FAILURE IN LOG FILE
				; OR JOB REQUEUED WITH DEFAULT TIME
	F.NTIF==100000		;NOT IF COMMAND
	F.CTLN==200000		;WHEN ON PROCESS CTL FILE AT LINE N.
	F.END==400000		;KJOB WITH RIGHT SWITCH PROCESSED

;LEFT HALF OF FLAG REGISTER AND WORD FLAG (AC F)

	F.INTL==1		;FLAG ON WHEN LOGGING IN A JOB
	F.TTY==2		;WHEN SET TYPE EVERYTHING ON TTY
	F.SET==4		;FLAG SET AT SET TIME COMMAND TIME
	F.AROW==4			;SET WHEN TWO  UPARROWS ENCOUNTERED.
	F.LOGD==10		;SET IF JOB EVER GETS LOGGEDIN
	F.PLS==20		;PLEASE COMMAND NOTICED
	F.WOPR==40		;WAITING FOR OPERATOR RESPONSE
	F.SUPZ==100		;WHEN ON SEND /Z TO LOGOUT
	F.SYNT==200		;SYNTAX ERROR IN IF COMMAND
	F.LOUT==400		;FLAG SET WHEN LINE COMPLETE
	F.SCRF==1000		;SUPPRESS CRLF SET BY = SIGN
	F.BRK==2000		;IT IS A BREAK CHARACTER
	F.DSTP==4000		;DELAY STOP COMMAND
	F.TAB==10000		;SEND TWO TABS TO LOG FILE.
	F.CLOS==20000		;WHEN CLOSE SENT TO THE JOB
	F.SCNT==40000		;SUPPRESS CONTINUE WHEN PROCESSING GO
	F.LIN==100000		;FLAG SET WHEN LINE SET IN MSG TABLE.
	F.CTRC==200000		;JOB STOPPED BY ^C.
	F.LF==400000		;LINE FEED ENCOUNTERED.
	;JOB STATUS UUO BITS

	JSTAC==10000		;JACCT BIT SET
	JSTOUT==20000		;PTY WANTS OUTPUT
	JSTINP==40000		;PTY WANTS INPUT
	JSTMON==100000		;IN MONITOR MODE
	JSTLOG==200000		;JOB LOGGED IN(NOT STARTED LOGOUT)
	JSTJNA==400000		;JOB ASSIGNED
;MORE JOB FLAGS.THESE FLAGS ARE USED INFREQUENTLY AND ARE SAVED IN WORD FLAG2
;DEFINITION OF THE BITS IN WORD FLAG2

;RIGHT HALF OF THE WORD FLAG2 AND (AC F2)

	F2.ETM==1		;SET WHEN JOB CONTINUED AFTER TIME LIMIT EXCEEDES
	F2.RMN==2		;SET WHEN IN MONITOR MODE AT RELEASE TIME
	F2.CNF==4		;SET WHEN TIME COMMAND SENT TO JOB AGAIN
	F2.KBW==10		;KJOB SICK SEND KJOB/W/B
	F2.SIL==20		;SET TO SILENCE LOG FILE
	F2.ERL==40		;? LINE GETS IN LOG FILE ANYWAY
	F2.NER==100		;SET FLAG SO THAT NO ERROR PROCESSING
	F2.OPR==200		;FLAG FOR OPERATOR COMMAND(RESET FOR DEFAULT)
	F2.STP==400		;JOB WAITING FOR A LINE FROM OPERATOR.
	F2.BAK==1000		;PROCESS BACKTO COMMAND
	F2.QTS==2000		;IS IT OPERATOR ADVISORY MESSAGE
	F2.FST==4000		;MARK THIS AS A FAST STREAM
	F2.SEQ==10000		;IT IS SEQ# FILE
	;MACROS

;THIS MACRO TYPES ON THE CONTROLLING TTY AND IN LOG FILE

	DEFINE	TYPLOG(A),<
	XLIST
	MOVE	T2,[POINT 7,[ASCIZ A]]
	PUSHJ	P,TTLOG
	LIST
	>

;THIS MACRO TYPES ON THE CONTROLLING TTY AND IN DSKLOG

	DEFINE	TYPDSK(A),<
	XLIST
	MOVE	E,[POINT 7,[ASCIZ A]]
	PUSHJ	P,TTDSK
	LIST
	>

;THIS MACRO TYPES ON THE CONTROLLING TTY ONLY.

	DEFINE	TYPE(A),<
	XLIST
	OUTSTR	[ASCIZ A]
	LIST
	>



;THIS MACRO IS USED FOR SENDING DEFAULTS TO KJOB

	DEFINE	SWITCH(A),<
	XLIST
	JUMPE	C,.+7		;;IF ZERO GOTO NEXT ONE
	PUSHJ	P,FLUSH9	;;SEND /V TO THE JOB
	MOVEI	CH,"A"		;;GET THE SWITCH
	PUSHJ	P,SIXLO2	;;SEND IT TO THE JOB.
	MOVEI	CH,":"		;;GET COLON
	PUSHJ	P,SIXLO2	;;SEND IT TO THE JOB
	PUSHJ	P,SNDEC		;;SEND THE DECIMAL ARGUMENT
	LIST
	>


	DEFINE	JOBST(A1),<
	XLIST
	MOVEI	T2,1		;;FLAG FOR PTY CHANNEL
	PUSHJ	P,CHNSJB	;;GET THE CHANNEL# IN AC A
	HLRZ	A1,A		;;MOVE TO RIGHT
	LSH	A1,-^D5		;;SHIFT IT RIGHT
	JOBSTS	A1,		;;GET JOB STATUS FROM MONITOR
	HALT	.+1		;;FAILS
	IFN	DEBUG,<IFE A1-STS,<PUSHJ P,OUTSTS>>
	MOVEM	A1,JOBSB(B)	;;REMEMBER FOR CONDITIONAL SLEEP
	LIST
	>


	DEFINE	ALLJOB(A),<
	XLIST
	SKIPN	JBSACT		;;ARE ANY JOBS IN USE
	PJRST	DCURR1		;;NO.TYPE THE MESSAGE
	SETZB	F,B		;;CLEAR AC FOR FLAGS AND DATA SIZE
	MOVEI	JB,1		;;START WITH JOB 1
	MOVE	F2,FLAG2(B)	;;GET THE SECOND FLAG WORD
	MOVE	F,FLAGS(B)	;;GET THE FLAGS FOR THE JOB
	TRNE	F,F.ACTV	;;IS THE JOB IN USE?
	PUSHJ	P,A		;;GO SERVICE IT
	ADDI	B,SIZE		;;SETUP THE NEXT JOB
	CAMGE	JB,MAXSTM	;;HAVE WE GONE OVER ALL JOBS
	AOJA	JB,.-6		;;NO. GO TO NEXT JOB
	POPJ	P,		;;RETURN TO OPERATOR
	LIST
	>



	;MACRO TO MATCH A COMMAND

	DEFINE	MATCH(A1,A2),<
	XLIST
	SETZB	A,G		;;CLEAR AC A AND G
	SETZ	D,		;;CLEAR AC D
	MOVE	E,[SIXBIT/A1/]	;;SETUP THE COMMAND
	LSHC	D,6(A)		;;SHIFT A CHARACTER
	ROT	D,-6(G)		;;ROTATE A CHARACTER
	CAMN	D,COM		;;DOES IT MATCH?
	JRST	.+5		;;YES
	ADDI	A,6		;;ADD SIX TO A
	SUBI	G,6		;;SUBTRACT SIX FROM G
	JUMPN	E,.-8		;;NO. CHECK NEXT CASE
	JRST	A2		;;NO MATCH. RETURN TO A2
	LIST
	>
	IFN	PURE,<TWOSEG
	RELOC	400000>


	IFGE	FTOPR,<

	ENTRY	BATCON

	EXTERN	.JBREN

BATCON:	JFCL			;FOR CCL ENTRY POINT.
START2:	SKIPN	MAXSTM		;IS BATCH STREAMS ZERO?
	JRST	VIRSTA		;WHEN VIRGIN START.
	IFG	FTOPR,<
	TRNE	GF,ASTRK	;ONLY FOR !
	PUSHJ	P,EXCLAM	;TYPE IT
		>
	JRST	START1		;NO. PROCEED FROM HERE.
VIRSTA:	MOVEI	C,JOBMAX	;MAXIMUM EAMS CONFIG
	MOVEM	C,MAXSTM	;SAVE IT
	SETZ	GF,		;CLEAR GLOBAL FLAGS
	MSTIME	C,		;GET CURRENT TIME IN MSECS.
	MOVEM	C,TSTART	;SAVE IT IN TSTART
IFN LEVELC,<
	SETZB	C,D		;CLEAR AC C
CTY1:	MOVEI	C,(D)		;GET THE LINE#
	GETLCH	C		;GET THE LINE CHARACTERISTICS
	TLNN	C,(1B1)		;IS IT CTY?
	AOJA	D,CTY1		;NO.CONTINUE TILL YOU FIND IT
	HRRZM	C,TCONLN	;YES.IT IS CTY.
	MOVE	P,[IOWD PSIZ,PDL]
>
>
	IFGE	FTOPR,<
SUBTTLE INITIALIZING ROUTINE
START5:	MOVEI	C,START4	;GET REENTER ADDRESS
	MOVEM	C,.JBREN	;SAVE IN JOBREN
IFE LEVELC,<
	MOVE	A,[XWD 22,11]	;GET THE # OF PTY'S OF THE SYS.
	GETTAB	A,
	JRST	PTYERR		;ERROR RETURN
>
IFN LEVELC,<
	PUSHJ	P,LVCPTY	;FIND MAXIMUM PTY OF THE SYS.
>
	HRRZM	A,PTYMAX	;SAVE IT IN PTYMAX
	SKIPN	PTYMAX		;CHECK IF ANY PTY'S
	JRST	PTYERR		;NONE. CANNOT PROCEED.

;HERE SETUP DEFAULT VALUE FOR MCORE,MTIME ETC

START1:	TRZ	GF,EXITB	;RESET EXIT FLAG
	SETO	A,		;SET A TO ALL 1'S
	TLZ	A,400000	;RESET SIGN BIT
	MOVEM	A,JTIMX		;DEFAULT MAX TIME
	MOVEM	A,ATIMX		;DEFAULT MAX TIME
	MOVE	A,[XWD 34,12]	;HIGHEST PHYSICAL CORE IN WORDS
	GETTAB	A,
	JFCL
	LSH	A,-^D10		;PHYSICAL CORE IN  K'S
	MOVEM	A,JCORMX	;SAVE IT IN JCORMX
	MOVE	A,[XWD 1,15]	;GET SWAPPING CORE IN K
	GETTAB	A,
	JFCL			;ERROR RETURN
	MOVEM	A,AJCOR		;SAVE IT

	RESET			;RESET ALL I/O CHANN

	TYPE</
/>				;TYPEOUT <CR>

;HERE SETUP PDL,^C INTERCEPT ANE QUEUE TABLE

	MOVE	P,[IOWD PSIZ,PDL]	;INITIALIZE PUSHDOWN STACK
	SETZM	PTYTAB		;CLEAR TTYTAB 1ST LOCATION.
	HRLZI	A,PTYTAB	;SETUP BLT INSTRUCTION
	HRRI	A,PTYTAB+1	;INPUT OUTPUT POINTER.
	BLT	A,JBSACT	;CLEAR THE COMMON AREA.
	PUSHJ	P,WAKEM		;WAKE ME UP
	PUSHJ	P,SETINT	;SETUP FOR ^C INTERRUPT
	PUSHJ	P,QUEINT	;INITIALIZE QUEUE TABLE
	>
	IFGE	FTOPR,<
;HERE SET FLAGS FOR THE JOB STREAMS TO INDICATE
;WHETHER A FAST OR SLOW STREAMS. AC C HAS FAST STREAMS
;AND INITIALZE THE DATA AREA ACCORDINGLY


	SETZB	B,F2		;CLEAR AC B AND F2
	MOVEI	JB,1		;SET JB TO 1. SUBJOB 1
PINIT:	PUSHJ	P,INIT2		;INITIALIZE EACH JOB AREA
	ADDI	B,SIZE		;FOR THE NEXT JOB AREA
	CAMGE	JB,MAXSTM	;ARE WE AROUND ALL JOBS.
	AOJA	JB,PINIT	;COUNT ONE MORE AND GO BACK
	TRON	GF,START	;IS IT A VIRGIN START?
	TROA	GF,INITIL	;INITIALLY BATCH WAITS FOR THE START COMMAND
				; DEFAULT DSK LOG ON AND ALL JOBS FLAG ON.
	JRST	START4		;SKIP COPYING THE COMMAND TABLE
;CODE TO COPY MONITOR COMMAND TABLE FOR BATCH PROCESSING
;THIS TABLE IS FOLLOWING INCORE DEPENDING ON #STREAMS SPECIFIED.

	EXTERNAL .JBFF,.JBREL
	CMTAB==30		;ARGUMENT FOR COMMAND TABLE

MNRTAB:	HRRZ	A,.JBREL	;GET HIGHEST LOCATION IN LOW CORE
	HRRZ	D,.JBFF		;FIRST FREE LOCATION
	SUBI	A,-1(D)		;AVAILABLE FREE AREA
	JUMPLE	A,STAR11	;NONE. GO GET SOME CORE.
START9:	MOVNS	A		;NEGATIVE OF AVAILABE CORE
	HRLZS	A		;SETUP FOR THE POINTER
START6:	HRRZI	C,CMTAB		;MONITOR COMMAND TABLE
	HRL	C,A		;ITEM#
	HRRZ	D,.JBFF		;GET THE FREE LOCATION
	GETTAB	C,		;GET THE COMMAND
	JRST	START8		;ERROR RETURN
	ADDI	D,(A)		;UPDATE FREE LOCATION
	MOVEM	C,(D)		;SAVE IT
	AOBJN	A,START6	;
STAR11:	PUSHJ	P,START7	;GO GET MORE CORE
	JRST	START6		;CONTINUE INITIALIZATION

START8:	ADDI	D,(A)		;LOW CORE AREA
	MOVE	A,D		;SAVE THE RESULTS IN A
	HRLI	D,CTLCM1	;HI CORE AREA
	MOVE	C,.JBREL	;GET THE CORE LIMIT
	CAIGE	C,CTL3-1(A)	;IS IT OVER THE LIMIT?
	PUSHJ	P,START7	;YES. GRAB CORE.
STAR10:	BLT	D,CTL3-1(A)	;UPPER END
	MOVEI	D,CTL3(A)	;GET HI END.
	HRRZ	A,.JBFF		;FREE LOCATION
	HRRM	A,COMTB		;SAVE IT BEFORE UPDATING
	SUB	A,D		;FIND NEGATIVE LENGTH OF TABLE
	HRLM	A,COMTB		;SAVE IT
	MOVEM	D,.JBFF		;UPDATE JOBFF
	>
	IFGE	FTOPR,<
STAR12:	PUSHJ	P,PIKSRM	;PICK INCORE/SWAP STREAMS AND SET BUFTAB
	IFN	REMSW,<
	PUSHJ	P,REMAL1	;SETUP THE BIT TABLE
	>
START4:	TRNN	GF,ASTRK	;IS IT IN TI WAIT MODE?
	IFE	FTOPR,<
	PUSHJ	P,START3	;WAIT FOR OPERATOR RESPONSE
	>
	IFG	FTOPR,<
	PUSHJ	P,OPTR5		;GO CHECK WITH OPERATOR
	>
	IFE	FTOPR,<
	PUSHJ	P,EXCLAM	;TYPEOUT !
	>
	>

SUBTTLE MAIN LOOP--SCHEDULE--LISTEN--RELEASE--OPERATOR

	IFGE	FTOPR,<

;HERE CHECK IF ALL JOBS ARE ACTIVE, IF SO KEEP PROCESSING THEM,IF 
;NOT GO SEE IF JOBS CAN BE SCHEDULED.AFTER THE JOB IS SCHEDULED CHECK IF 
;OPERATOR NEEDS ATTEOTION. IF NO JOBS ARE ACTIVE THEN GO SLEEP.

	MOVE	P,[IOWD PSIZ,PDL]	;INITIALIZE PUSHDOWN STACK

ACTJBS:	TRNE	GF,FRESET	;IS RESET FLAG SET. THIS STOPS BATCH
	PUSHJ	P,RESET1	;YES STOP BATCH IF NOACTIVE JOBS.
	TRNE	GF,EXITB	;IS EXIT FLAG SET?
	PUSHJ	P,DEXIT1	;YES. EXIT IF NO JOBS ACTIVE.
	TRNE	GF,SCHRS	;DO WE NEED TO UPDATE STREAMS
		>

	IFG	FTOPR,<
	PUSHJ	P,OPTR5		;YES.
		>

	IFE	FTOPR,<
	PUSHJ	P,CHGSTM	;CHANGE STREAMS
		>
	IFGE	FTOPR,<
	MOVE	A,JBSACT	;CHECK TOTAL ACTIVE JOBS.
	CAME	A,MAXSTM	;ARE ALL JOBS ACTIVE
	PUSHJ	P,SCHED		;NO GO SCHEDULE A JOB.
	SKIPE	A,CTRCNT	;HOW MANY JOBS ARE IN STOP MODE?
	PUSHJ	P,SLEEP1	;BATCH TO SLEEP IF C(A)=14.
	PUSHJ	P,OPTR		;NONE IN STOP MODE. ATTEND THE OPERATOR.
	TRNE	GF,DSPLY	;SHOULD DISPLAY BE ON?
	PUSHJ	P,DISPLY	;YES. DISPLAY THS STATUS.
	TRNE	GF,NOSCH	;IS DONT SCHEDULE NEW JOBS FLAG ON?
	JRST	NOTSCH		;GO CHECK IF ANY JOBS ACTIVE.
ACTJB1:	TRZN	GF,TTYIOW	;SLEEP ONLY IF NONE IN TI WAIT
	PUSHJ	P,SLEEP2	;SLEEP UNLESS PTY ACTIVITY
	>
	IFGE	FTOPR,<
;HERE IS MAIN BATCH OL LOOP. CHECK THE FLAGS, IF JOB ACTIVE
;PROCESS IT. CHECK FOR EOF, MISSING VONTROL FILE, AND OTHER
;ERRORS. IF NO ERRORS AND JOB ACTIVE READ THE CONTROL FILE AND SEND 
;IT TO OBJECT JOB. COMMUNICATION WITH JOB IS DONE IN THE SECONDARY
;LOOP WITH ENTRY POINT STAG1:. IF EOF IS ENCOUNTERED JOB IS LOGGED OFF.
;CODE TO LOG OFF THE JOB STARTS AT ENTRY POINT REL:
	SETZ	B,		;CLEAR AC B
	MOVEI	JB,1		;START WITH SUBJOB# 1
LOOP:	MOVE	F2,FLAG2(B)	;GET SECOND FLAG WORD
	MOVE	F,FLAGS(B)	;GET JOB FLAGS.
	TRNE	F,F.ACTV	;IS THE JOB IN USE?
	TLNE	F,F.CTRC+F.WOPR	;YES IS IT STOPPED WITH ^C OR WAITING FOR OPER.?
	JRST	LOOP1		;NO. SKIP TO THE NEXT JOB.
	PUSHJ	P,JBSTAT	;GET THE JOB STATUS
	JRST	CHKACT		;CHECK JOB ACTIVITY.
LOOP2:	TRNN	F,F.FIN		;IS CTL EOF SEEN?
	PUSHJ	P,LOKCTL	;READ A CTL FILE BLOCK.
	TRZE	F,F.CTL		;IS CONTROL FILE AVAILABLE?
	JRST	LOOP7		;PROCESS THE MISSING CTL CASE
LOOP4:	TRNE	F,F.END		;ARE WE AT THE END OF JOB?
	JRST	LOOP5		;YES
LOOP6:	PUSHJ	P,LOGFL1	;LOOKUP LOG FILE.
	PUSHJ	P,@PCWORD(B)	;GO PROCESS THE JOB.
LOOP3:	PUSHJ	P,LOGFL2	;ENTER A BLOCK OF LOG FILE
LOOP5:	PUSHJ	P,FSTSLW	;IS IT IN CORE TYPR?
	SKIPA			;SKIP ALWAYS
	MOVEM	JB,INCORE	;SAVE CURRENT INCORE SUBJOB#
	TLNE	F,F.DSTP	;IS DELAY STOP COMMAND FLAG SET?
	PUSHJ	P,STOP1		;GO. PROCESS IT.
	TRNN	F,F.CTL		;IS IT MISSING CTL FILE?
	TRNE	F,F.ENTR	;IS IT ENTER FAILURE?
	PUSHJ	P,MISCTL	;YES. REQUE AND KILL JOB
	TRNE	F,F.FIN		;CTL HAS BLANKS NOW.
	PUSHJ	P,REL		;GO RELEASE THE CHANNEL
LOOP1:	TRZ	GF,SKIP		;RESET DKIP FLAG
	SKPINL			;IS LINE TYPEDIN?
	SKIPA			;YES SKIP ALWAYS
	PUSHJ	P,OPTR4		;GO ATTEND THE OPERATOR
	ADDI	B,SIZE		;SETUP FOR NEXT JOB
	CAMGE	JB,MAXSTM	;HAVE WE PROCESSED ALL JOBS.
	AOJA	JB,LOOP		;GO TO THE NEXT JOB
	JRST	ACTJBS		;WE HAVE GONE AROUND NOW.
OPTR4:	PUSH	P,B		;SAV E AC B
	PUSH	P,JB		;SAVE JOB NUMBER
	PUSHJ	P,OPTR5		;ATTEND THE OPERATOR
	POP	P,JB		;RESTORE JOB
	POP	P,B		;RESTORE B
	POPJ	P,		;RETURN
NOTSCH:	SKIPE	JBSACT		;ARE ALL JOBS IN USE?
	JRST	ACTJB1		;SOME INUSE.WAIT TILL NONE INUSE.
	JRST	ACTJBS		;NONE IN USE.
		>
	IFGE	FTOPR,<
;HERE CHECK IF ONLY ONE BATCH STREAM RUNNING. IF THAT IS THE CASE
;BOTH CONTROL FILE AS WELL AS THE LOG FILE STAYS IN CORE.

CHKACT:	TLNE	STS,JSTOUT+JSTINP	;IS JOB IN TI WAIT?
	JRST	ONEACT		;YES.
	TRNN	F,F.FIN		;NO. ARE WE AT EOF?
	JRST	LOOP1		;NO. GO TO NEXT JOB.
	JRST	LOOP5		;PROCESS THE EOF
ONEACT:	CAME	JB,INCORE	;WAS THIS ONE IN CORE?
	JRST	LOOP2		;NO. CONTINUE USUAL PROCESSING
	TRZE	F,F.CTL		;YES. HAS CTL FILE BEEN DELETED?
	JRST	LOOP7		;YES. ENTER LIKEWISE IN LOG FILE
	TRO	GF,SKIP		;SET FLAG TO SKIP INPUT ON LOG FILE
	JRST	LOOP4		;PROCESS THE JOB


PTYERR:	TYPE</
? System must have PTY'S/>
	EXIT


LOOP7:	PUSHJ	P,MISCTL	;PROCESS THE MISSING CTL FILE
	JRST	LOOP5		;RETURN



;HERE FOR THE CORE GARABBING ROUTINE

STAR13:	SLEEP	G,		;SLEEP FOR A SECOND
START7:	HRRZ	E,.JBREL	;GET THE HI ADDRESS
	ADDI	E,2000		;UP IT BY 1K
	MOVEI	G,1		;SETUP FOR SLEEP
	HRLI	A,-2000		;SETUP THE POINTER
	CORE	E,		;DO A CORE UUO
	JRST	STAR13		;GO SLEEP
	POPJ	P,		;RETURN

	>



	IFGE	FTOPR,<
SUBTTLE RELEASE JOB
;HERE GET READY TO ISSUE KJOB AND RELEASE OR REQUEUE THE JOB.
;IF EOF SEEN,RELEASE JOB AFTER SENDING KJOB COMMAND(SEE FLUSH2:).
;IF REQUEUE FLAG IS SET, REQUEUE THE JOB, IN EITHER CASE REINITIALIZE
;THE DATA AREA INCORE FLAGS. CLEAR PTYTAB ENTRY
REL:	TLNN	STS,JSTJNA	;IS JOB STILL ASSIGNED?
	PJRST	REL8		;NO. RELEASE THE JOB.
	TLNE	STS,JSTINP	;JOB WANTS TO OUTPUT
	PJRST	REL9		;YES GO DO IT
	TRNE	F,F.KILL	;HAVE WE NOTICED KJOB COMMAND?
	JRST	REL5		;YES. RETURN
	PUSHJ	P,LOGFL1	;OPEN THE LOG FILE
	MOVE	C,Q.IDEP(B)	;GET Q.IDEP WORD
	TLNE	C,40000		;SHOULD THIS BE ABORTED
	PJRST	BMSG		;YES. WRITE MESSAGE IN LOG FILE
	TRNN	F2,F2.RMN	;IS MONITOR FLAG SET
	PUSHJ	P,DEAS3		;NO. PROCESS IT AND RETURN
	TRZE	F,F.QSMK	;IS ?MARK FLAG ON?
	PUSHJ	P,CLOS		;SEND CLOSE COMMAND
	TLZE	F,F.CLOS	;WAS CLOSE COMMAND SENT TO THE JOB?
	PUSHJ	P,DUMPE		;YES. SEND A DUMP COMMAND TO THE JOB
	PJRST	BMSG4		;SEND KJOB COMMAND AND RETURN
REL5:	TLNN	STS,JSTJNA	;IS JOB STILL ASSIGNED?
	JRST	REL8		;NO. GO RELEASE THE JOB
	TRNN	F,F.END		;KJOB PROCESSED?
	PJRST	CONFRM		;RESPOND TO CONFRM:
	TLNE	STS,JSTOUT	;IS IT DEMANDING INPUT?
	PJRST	@PCWORD(B)	;YES. THERE IS SOMETHING WRONG.
	POPJ	P,		;RETURN
	>
	IFGE	FTOPR,<
REL8:	HRRZ	C,Q.ILIM(B)	;GET CURRENT TIME LIMIT
	MOVE	A,TOTIME	;GET TOTAL TIME
	SUB	A,C		;UPDATE TIME
	MOVEM	A,TOTIME	;SAVE IT
	HLRZ	C,Q.ILIM(B)	;GET CURRENT CORE IN WORDS
	LSH	C,-^D10		;CORE IN K
	MOVE	A,TOTCOR	;GET TOTAL CORE USED BY BATCH
	SUB	A,C		;UPDATE CORE
	MOVEM	A,TOTCOR	;SAVE IT TOTAL CORE
	SOS	JBSACT		;UPDATE ACTIVE JOB COUNT
	CAMN	JB,INCORE	;DID WE RELEASE INCORE JOB?
	SETZM	INCORE		;YES CLEAR INCORE JOB LOCATION?
	TRNE	F,F.SETR	;IS THERE AN ENTER FAILURE OR JOB REQUEUED?
	JRST	REL2		;YES.REQUEUE THE JOB
	TRNE	F,F.REQ		;IS REQUEUE FLAG ON?
	JRST	REL7		;YES REQUE THE JOB
	PUSHJ	P,DISPOS	;DO POST OUTPUT FILE DISPOSAL
REL4:	HRRZI	A,RCOM		;REQUEST COMPLETE
REL3:	PUSHJ	P,SCHR2		;SETUP DATA AREA
	PUSHJ	P,.QUEER	;GO TO QUEUER
	TRNE	F2,F2.FST	;IS IT IN CORE TYPE?
	PUSHJ	P,BMSG6+2	;GO RELEASE LOG CHANNEL.
	PUSHJ	P,INIT2		;GO REINITIALIZE THE JOB
	TRZ	GF,SKIP		;GET ANEW BLOCK IN CORE NEXT TIME
	>
	IFGE	FTOPR,<
REL1:	MOVEI	T2,1		;FLAG FOR PTY
	MOVE	A,[RELEASE]
	PUSHJ	P,IOUUO		;EXECUTE THE UUO
	SETZM	PTYTAB-1(JB)	;CLEAR PTY TAB
	PUSHJ	P,FSTSLW	;IS IT INCORE TYPE?
	PUSHJ	P,CLRCTL	;YES. CLEAR CTL,LOG CHANNELS.
	LDB	D,[POINT 4,QUETAB-1(JB),29]
	PUSHJ	P,CLRCHN	;CLEAR PTY CHANNEL
	HLLZS	QUETAB-1(JB)	;CLEAR RIGHT HALF
	POPJ	P,		;RETURN
REL2:	MOVEI	C,DEFREQ	;MINIMUM DEFAULT REQUEUE TIME
	SKIPA			;ALWAYS SKIP
REL7:	MOVE	C,JBREQ		;GET REQUEUE PARAMETERS IN MTS
	IDIVI	C,DYMTS		;IS IT OVER A DAY
	PUSH	P,C		;SAVE AC C
	HRLZ	C,D		;MULTIPLY BY 2^18
	IDIVI	C,DYMTS		;DIVIDE BY MTS IN A DAY
	POP	P,D		;RESTORE AC C
	HRL	C,D		;GET DAYS
	TLO	C,400000	;SET THE SIGN BIT
	MOVEM	C,Q.AFTR(B)	;SAVE IT IN AFTER WORD
	HRRZI	A,RQUE		;GO REQUEUE THE JOB
	JRST	REL3

REL9:	TRNE	F,F.END		;HAVE WE ISSUED KJOB COMMAND?
	PJRST	@PCWORD(B)	;YES. DO INPUT BUT DO NOT WRITE IN LOG 
REL10:	PUSHJ	P,LOGFL1	;OPEN LOG FILE
	PUSHJ	P,@PCWORD(B)	;WRITE IT IN LOG FILE
	PJRST	LOGFL2		;RETURN IT
		>


	IFGE	FTOPR,<
SUBTTLE POST JOB DISPOSITION
;HERE CHECK THE DISPOSITION OF THE CTL FILE
;
;CALL	PUSHJ P,DISPOS
;	RETURN
;
DISPOS:	LDB	A,[POINT 3,C.FMOD(B),29]
	CAIE	A,3		;IS FILE TO BE DELETED?
	JRST	DISPO1		;CHECK IF ARTIFICIALLY PROTECTED?
	PUSHJ	P,DELPRV	;DOES USER HAVE DELETE PRIVS?
	POPJ	P,		;NO. RETURN
	SETZB	C,E		;CLEAR FILENAME AND EXTENSION
	SETZ	D,		;CLEAR D
DISPO2:	SKIPE	C.FRNM(B)	;IS IT RENAMED NAME?
	SKIPA	G,[QUEPPN]	;YES. USE 3,3
	PUSHJ	P,CTLK1		;GET P,PN AND SFD
	MOVE	A,[RENAME ,C]
	XCT	A		;EXECUTE THE UUO
	JFCL
	PJRST	CLSP		;RELEASE CHANNEL AND RETURN

DISPO1:	SKIPE	C.FRNM(B)	;IS IT RENAMED NAME?
	PJRST	.+3		;SETUP TO DELETE
	SKIPL	C.FBIT(B)	;CHECK IF ARTIFICIALLY PROTECTED?
	POPJ	P,		;NO.RETURN
	PUSHJ	P,LOOKCT	;DO A LOOKUP ON CTL FILE.
	PJRST	CLSP		;RELEASE IF ERROR
	SKIPE	C.FRNM(B)	;WAS IT RENAMED?
	PJRST	DISPO2-2	;DELETE IT
	MOVE	C,C.FNAM(B)	;GET THE FILENAME
	HLLZ	D,C.FEXT(B)	;GET THE EXTENSION.
	MOVEI	G,0		;GET THE PROTECTION
	DPB	G,[POINT 3,E,2]	;SAVE IT IN THE BLOCK
	PJRST	DISPO2		;RENAME AND RETURN
	>

	IFGE	FTOPR,<
;HERE CHECK IF THE USER HAS PRIVILEDGES TO DELETE
;THE CONTROL FILE FROM THE AREA.

;	PUSHJ P,DELPRV
;	(NO PRIVS)
;	(HAS PRIVS)

DELPRV:	PUSHJ	P,LOOKCT	;DO LOOKUP ON CTL FILE
	PJRST	RELCH0		;RELEASE CHANNEL AND RETURN
	LDB	C,[POINT 9,E,8]
	HRLI	C,0		;SETUP ARGS FOR ACCESS UUO
	MOVE	D,C.FDIR(B)	;GET THE FILE P,PN
	MOVE	E,Q.PPN(B)	;GET USERS P,PN
	MOVEI	G,C		;GET THE ARG ADDRESS
	CHKACC	G,		;CHECK ACCESS
	PJRST	RELCH0		;IF NOT IMPLEMENTED LEAVE IT ALONE
	JUMPL	G,RELCH0	;NO ACCESS RETURN
	PJRST	CPOPJ1		;JOB HAS ACCESS RIGHTS . SKIP RETURN


LOOKCT:	HRLZI	C,PHYSCL	;ONLY IF PHYSICAL DEVICE
	HRRI	C,DUMP		;IN DUMP MODE
	MOVE	D,C.FSTR(B)	;GET FILE STRUCTURE
	MOVEI	E,0
	OPEN	CH0,C		;OPEN CHANNEL ZERO
	JRST	CPOPJ		;OPEN ERROR RETURN
	SKIPE	C,C.FRNM(B)	;GET RENAMED NAME
	JRST	[PUSHJ P,LOGK2	;SETUP THE LOOKUP BLOCK
		PJRST .+2	;RETURN
			]
	PUSHJ	P,CTLK		;SETUP THE HEADER.
	LOOKUP	CH0,C		;GET THE FILE
	PJRST	REDPR1		;RELEASE  CHANNEL AND RETURN
	JRST	CPOPJ1		;OK. SKIP RETURN
	>
	IFL	FTOPR,<
SUBTTLE BATOPR SEGMENT
BATOPR:	MOVE	GF,GLBFLG	;GET THE GLOBAL FLAGS
	TRNE	GF,SCHRS	;DO WE NEED TO CHANGE STREAMS?
	PUSHJ	P,CHGSTM	;YES. GO DO IT.
	SKIPE	FITJOB		;NEED INITIALIZING
	PJRST	START5-1	;YES. RETURN
	PUSHJ	P,BATOP1	;RESPOND TO OPERATOR
BATOP2:	SKPINL			;HAS HE TYPED A LINE
	PJRST	START5-1	;RETURN
	PJRST	.-5		;YES. SERVICE IT
BATOP1:	TRNN	GF,ASTRK	;IS IT WAITNIG FOR START
		>


	IFLE	FTOPR,<
START3:	PUSHJ	P,EXCAST	;TYPE * OR !
	PUSHJ	P,COM1		;CHECK SUBJOB # OR IS IT ALL?
	PUSHJ	P,GETCOM	;GET THE COMMAND
	PUSHJ	P,DISPCH	;GO SERVICE THE COMMAND
		>

	IFL	FTOPR,<
	SKIPE	FITJOB		;IS IT NONZERO
	PJRST	CPOPJ1		;SKIP RETURN
		>

	IFLE	FTOPR,<
	TRNE	GF,ASTRK	;DEMAND AN INPUT.
	POPJ	P,		;RETURN
	JRST	START3		;GET THE NEXT COMMAND
		>


	IFL	FTOPR,<
	MOVEM	GF,GLBFLG	;SAVE IT
START5:	POPJ	P,		;RETURN
	>
SUBTTLE MISSING CONTROL FILE
;HERE PROCESS MISSING CONTORL FILE, REQUEUE JOB
;IF JOB COULDNOT UPDATE LOG FILE
;IN EACH CASE MAKE AN ENTRY IN THE LOG FILE, REQUEUE
;THE JOB AS THE CASE MAY BE, AND KJOB THE OBJECT JOB.

MISCTL:	TRO	F,F.FIN		;SET EOF FLAG
	PUSHJ	P,LOGFL1	;OPEN THE LOG FILE
MISCT1:	PUSHJ	P,BMSG1		;WRITE BATCH AN TIME IN LOG FILE
	MOVSI	T2,440700	;SETUP POINTER FOR MESSAGE
	TRZE	F,F.ENTR	;WAS THERE LOG FILE ERROR
	PJRST	LOGERR		;YES
	TRNE	F,F.REQ		;IS REQUEUE FLAG ON.
	PJRST	JOBREQ		;YES. REQUEUE THE JOB
	IFGE	FTOPR,<
	HRRI	T2,ERMSG1	;IT IS MISSING CTL FILE
	PJRST	JOBER1		;WRITE MESSAGE IN LOG FILE
	>
BMSG1:	PUSHJ	P,CRLF1		;SEND <CR> TO THE JOB
BMSG5:	PUSHJ	P,TIMLOG	;SEND TIME TO THE LOG FILE
	MOVEI	T2,[SIXBIT/BATCH /]
	PJRST	BAOPR1		;SEND IT TO THE LOG FILE

	IFGE	FTOPR,<
BMSG:	PUSHJ	P,BMSG1		;WRITE TIME AND BATCH
	HRRI	T2,ERMSG6	;POINT TO THE MESSAGE
	PUSHJ	P,LOG1		;WRITE IT IN LOG FILE
	PUSHJ	P,CRLF1		;WRITE <CR> AND RETURN
BMSG4:	TLNN	STS,JSTMON	;IS THE JOB IN MON MODE?
	PJRST	DEAS1		;NO. MAKE SURE IT IS
	PUSHJ	P,FLUSH2	;LOGOUT THE JOB
	>
BMSG6:	TRNN	F2,F2.FST	;IS IT IN CORE TYPE?
	PJRST	LOGFL2
	PUSHJ	P,LOGFL8	;OUTPUT THIS BLOCK
	TRZ	F2,F2.FST	;RESET THE INCORE FLAG
	HRROI	T2,-1		;-1 MEANS LOG FILE
	MOVE	A,[RELEASE]
	PUSHJ	P,IOUUO		;EXECUTE IT
	LDB	D,[POINT 4,QUETAB-1(JB),25]
	PUSHJ	P,CLRCHN	;CLEAR THE LOG FILE CHANNEL
	SETZ	D,		;CLEAR AC D
	DPB	D,[POINT 4,QUETAB-1(JB),25]
	PJRST	STOP6+1		;SAVE F2 FLAGS

	IFGE	FTOPR,<
DEAS3:	TLNN	STS,JSTMON	;IS IT IN MONITOR MODE?
	PJRST	DEAS		;GET RESPONSE AND RETURN
	MOVEI	CH,CONTRU	;SET ^U TO CLEAR BUFFER
	PUSHJ	P,CTRC6		;SEND IT TO THE JOB
	PUSHJ	P,CRLF1		;WRITE <CR> IN LOG FILE
	PJRST	CTRC7		;GET THE RESPONSE AND RETURN
	>
SUBTTLE CLOSE-DUMP-AND OTHER RANDOM ROUTINES
LOGERR:	TRO	F,F.SETR	;SET ENTER FAILURE FLAG
	HRRI	T2,ERMSG3	;IT IS ENTER FAILURE
JOBER1:	PUSHJ	P,LOG		;WRITE IT IN LOG FILE
	PJRST	CRLFL		;WRITE <CR> AND CLOSE FILE


JOBREQ:	HRRI	T2,ERMSG5	;WRITE MESSAGE IN LOG FILE
	PJRST	JOBER1		; CLOSE LOG FILE

LOG1:	HRLI	T2,440700	;SETUP BYTE POINTER
LOG:	ILDB	CH,T2		;GET A CHARACTER
	JUMPE	CH,CPOPJ	;IS IT NULL?
	PUSHJ	P,LOGFL		;SAVE IT IN LOG FILE
	JRST	LOG		;GET ANOTHER CHARACTER

	IFGE	FTOPR,<
CLOS:	PUSHJ	P,CLOS5		;DO A CLOSE COMMAND
	PUSHJ	P,DUMPE3	;SET THE MONITOR FLAG
	PUSHJ	P,CTRC7		;GET THE RESPONSE
	TRZ	F,F.QSMK	;RESET ERROR FLAG
	PJRST	STOP6		;SAVE FLAGS AND RETURN

CLOS5:	PUSHJ	P,CLOS6		;CHECK IF IT IS SYS PROG
	POPJ	P,		;RETURN
	MOVE	D,Q.IDEP(B)	;GET THE Q.IDEP WORD
	TLNN	D,40000		;SHOULD IT BE ABORTED?
CLOS2:	TLOE	F,F.CLOS	;IS CLOSE COMMAND SENT ?
	POPJ	P,		;YES. RETURN
	MOVE	STS,JOBSB(B)	;GET THE JOB STATUS WORD
	TLNN	STS,JSTMON	;IS IT IN MONITOR MODE?
	PUSHJ	P,DEAS		;SEND ^C^C TO THE OBJECT JOB.
	MOVEI	T2,[SIXBIT/CLOSE/]
CLOS1:	PUSHJ	P,SIXLOG	;SEND SIXBIT WORD TO THE JOB
	PJRST	SETTM1		;SEND <CR> TO THE JOB AND RETURN

CLOS6:	HRLZ	C,JOBSB(B)	;GET THE JOB#
	HRRI	C,JBTLIM	;GET TIME LIMIT TABLE
	GETTAB	C,		;DO A GETTAB
	POPJ	P,		;ERROR RETURN
	TLNE	C,SYSPRG	;IS IT A SYSTEM PROGRAM?
	POPJ	P,		;SYSTEM PROGRAM NO DUMP
	HRLZ	C,JOBSB(B)	;GET THE JOB#
	HRRI	C,JBTPRG	;GETTAB FOR JOBNAME
	GETTAB	C,		;GET THE NAME
	POPJ	P,		;ERROR SKIP DUMP
	JUMPE	C,CPOPJ		;RU OR GET ERROR
	JRST	CPOPJ1		;SKIP RETURN USER PROGRAM
	>

	IFGE	FTOPR,<
DUMPE:	MOVE	T2,LABEL(B)	;WHAT LABEL DID WE SEARCH FOR?
	CAME	T2,[SIXBIT/%ERR/]	;WAS IT %ERR?
	PJRST	DUMPE1		;NO. RETURN WITHOUT A DUMP
DUMPE4:	PUSHJ	P,DUMPE2	;SEND DUMP COMMAND 
	TRZA	F,F.QSMK	;RESET ERROR FLAG
DUMPE1:	PUSHJ	P,CLOS6		;IS IT SYSTEM PROGRAM?
DUMPE3:	TROA	F2,F2.RMN	;SET THE FLAG
	PJRST	DUMPE4		;NO. GIVE A DUMP
	PJRST	STOP6		;SAVE FLAGS AND RETURN


DUMPE2:	MOVEI	T2,[SIXBIT/DUMP/]
	PUSHJ	P,CLOS1		;SEND CLOSE COMMAND
	PJRST	CTRC7		;GET RESPONSE AND RETURN
	>

SUBTTLE HIBERNATE---ERROR MESSAGES
	IFGE	FTOPR,<
;HERE SLEEP IF ALL JOBS ARE ACTIVE. WAIT FOR PTY ACTIVITY.

SCHED3:	TRZA	GF,TTYDDB+SLPINF	;RESET FLAGS
SLEEP1:	CAME	A,MAXSTM	;IS C(A) EQUAL TO MAXSTM?
	POPJ	P,		;NO RETURN
SLEEP3:	TRO	GF,TTYIOW	;SET FLAG FOR T/I WAIT
SLEEP2:	TRNE	GF,SLPINF	;IS INFINITE SLEEP FLAG SET
	SKIPA	C,[0]		;CLEAR AC C FOR HIBERNATE
	HRRZ	C,SLPTM		;ONLY RIGHT HALF
	IMULI	C,^D1000	;TIME IN MILLISE ONDS
	SKIPGE	SLPTM		;IS SLEEP TIME WORD NEGATIVE?
	TLOA	C,SWPNOW+HIBR	;SET HIBER ARGS AND BIT TO SWAP NOW
	TLO	C,HIBR		;DONOT SWAP BATCON
	MOVE	A,SLPTM		;SLEEP UUO ARGUMENTS
	HIBER	C,		;DO HIBERNATE UUO
	SLEEP	A,		;GO TO SLEEP IF NO ACTIVE JOBS
	POPJ	P,		;RETURN
ERMSG1:	ASCIZ/CTL file missing
/
ERMSG6:	ASCIZ/? Job aborted after a crash or a fatal error/
	>
ERMSG3:	ASCII/Enter failure,/
ERMSG5:	ASCIZ/Job requeued/
	IFGE	FTOPR,<
ERMSG2:	ASCIZ/No write privs. LOG in users area/
	>
	IFGE	FTOPR,<
SUBTTLE JOB SCHEDULING
;HERE DO THE JOB SCHEDULING. MAIN ROUTINE STARTS AT SCHED0
SCHED:	PUSHJ	P,SCHED0	;GO FIND A JOB TO RUN
	MOVEI	C,1		;SETUP FOR A MASK
	HRLZI	A,-JOBMAX	;SETUP THE INDEX WITH MAX JOBS
	ANDCAM	C,QUETAB(A)	;RESET BIT 35
	AOBJN	A,.-1		;ALL LOCATIONS
	POPJ	P,		;RETURN
;HERE START SCHEDULING JOBS. IF NONE ARE ACTIVE SCHEDULE AS
; MANY JOBS AS ARE ALLOWED BY MAXSTM. WHEN THE LIMIT IS REACHED
;OR NO MORE JOBS ARE IN THE INPUT QUEUE RETURN. IF NO SCHEDULING IS
;ALLOWED AND NONE OF THE JOBS ARE ACTIVE GO TO SLEEP.

SCHED0:	TRNE	GF,NOSCH	;IS NO NEW JOBS TO BE SCHED. FLAG ON?
	PJRST	[SKIPE JBSACT	;IF ALL JOBS INACTIVE GO SLEEP
		POPJ P,		;RETURN IF SOME JOBS ACTIVE
		PJRST SLEEP3	;GO SLEEP
		]
	MSTIME	C,		;GET CURRENT TIME
	MOVE	D,C		;SAVE IT TEMPORARILY
	SUB	C,LASTIM	;HOW LONG AGO?
	MOVMS	C		;JUST THE MAGNITUDE
	TRNE	GF,JOBNAV	;JOB TABLE FULL
	JRST	[  CAIGE C,OPRINT	;OVER THE INTERVAL
		POPJ P,		;NO.WAIT
		TRZ GF,JOBNAV	;RESET THE FLAG
		JRST .+3	;GO TRY AGAIN
			]
	CAIGE	C,SCHINT	;IS IT OVER THE INTERVAL?
	JUMPN	A,CPOPJ		;IGNORE THE INTERVAL IF NO ACTIVE JOBS
	MOVEM	D,LASTIM	;SAVE LAST TIME JOBS SCHEDULED


SCHED5:	SETZB	F,B		;CLEAR FLAG REGISTER AND AC B.
	MOVEI	JB,1		;START WITH SUBJOB 1.
SCHED1:	SETOM	COUNT		;BE SURE IT IS NOT ZERO
	PUSHJ	P,FSTSLW	;IS IT INCORE TYPE?
	SETZM	COUNT		;YES.SET COUNT TO ZERO

	MOVE	F,FLAGS(B)	;GET THE FLAG WORD
	MOVE	F2,FLAG2(B)	;GET OTHER FLAGS
	TRNN	F,F.ACTV	;IS IT IN USE?
	PUSHJ	P,SCHED2	;NO. GO SCHEDULE ALL JOBS
SCHED4:	ADDI	B,SIZE		;ACTIVE GET NEXT FLAG WORD
	CAMGE	JB,MAXSTM	;HAVE WE LOOKED AT ALL OF THEM
	AOJA	JB,SCHED1	;JB CONTAINS SUBJOB#.
	POPJ	P,
	>

	IFGE	FTOPR,<
;HERE SCHEDULE AJOB. FIRST GET A PSEUDO TTY IF AVAILABLE,
;SCHEDULE A JOB THEN. GET THE FIRST FREE BLOCK FOR LOG FILE.
;UPDATE JBSACT COUNT(# OF JOBS THAT ARE ACTIVE) AND RETURN.

SCHED2:	MOVE	A,QUETAB-1(JB)	;O.K. FOR THIS QUEUE
	TRNE	A,1		;IS THE FLAG ON?
	POPJ	P,		;CANT SCHEDULE
	MOVE	E,B		;SAVE CONTENTS OF B IN E.
	PUSH	P,B		;SAVE B
	PUSH	P,F		;SAVE F
	PUSHJ	P,JBSCH		;GET PTY FOR JB
	POP	P,F		;RESTORE F
	POP	P,B		;RESTORE B
	TRNE	GF,TTYDDB	;IS TTYDDB AVAILABLE?
	JRST	SCHED3		;GO RESET FLAG AND RETURN
	PUSHJ	P,SCHR		;GO SCHEDULE A JOB
	PJRST	REL1		;GO RELEASE THE PTY
	MOVE	C,C.FSTR(B)	;GET CONTROL FILE STRUCTURE NAME
	PUSHJ	P,DEVGET	;GET DEVICE CHARACTERISTICS
	PJRST	DEVGT1		;ERROR RETURN NOT A DISK
	MOVE	C,L.FSTR(B)	;GET LOG FILE STRUCTURE
	PUSHJ	P,DEVGET	;GET ITS CHARACTERISTICS
	PJRST	DEVGT2		;ERROR RETURN NOT A DISK
	MOVE	C,Q.PPN(B)	;GET USERS P,PN
	CAME	C,L.FDIR(B)	;IS IT SAME AS LOG FILE P,PN
	PUSHJ	P,ENTPRV	;NO. CHECK ENTER RIGHTS TO THIS DIR
	MOVE	C,Q.PPN(B)	;GET USERS P,PN
	CAME	C,C.FDIR(B)	;IS IT THE SAME AS CTL FILE
	PUSHJ	P,REDPRV	;NO. CHECK READ RIGHTS
	PUSHJ	P,LOGCTL	;CHECK IF LOG AND CTL FILES SAME
	PJRST	REL4		;YES. RELEASE JOB
	PUSHJ	P,FRBLK		;GET FIRST FREE BLOCK FOR LOG FILE.
	TRNE	F,F.FIN		;IS END OF FILE FLAG SET?
	PJRST	REL4		;YES. GO RELEASE THE JOB
	TRNE	F,F.ENTR	;IS THERE ENTER FAILURE?
	PJRST	REL2		;YES. GO REQUEUE THE JOB
	HRRZ	C,Q.ILIM(B)	;GET TIME
	ADDM	C,TOTIME	;UPDATE TOTAL BATCH TIME
	HLRZ	C,Q.ILIM(B)	;GET CORE
	LSH	C,-^D10		;CORE IN K
	ADDM	C,TOTCOR	;UPDATE TOTAL BATCH CORE
	AOS	JBSACT		;UPDATE JBSACT WORD
	TRO	F,F.ACTV	;SET USE BIT
	CAMN	B,TTYIND	;DOES INDEX ADDRESS MATCH?
	TLO	F,F.TTY		;YES. SET TTY OUT FLAG.
	MOVE	C,Q.IDEP(B)	;GET THE Q.IDEP WORD
	TLNN	C,40000		;NO. SHOUILD IT BE ABORTED?
	PJRST	HEADR		;WRITE VERSION# IN LOG FILE AND RETURN.
	TRO	F,F.KERR+F.QSMK	;SET ERROR IN JOB FLAG
	MOVE	C,[SIXBIT/%FIN/]
	MOVEM	C,LABEL(B)	;SEARCH FOR %FIN
	>
	IFGE	FTOPR,<
SUBTTLE LOG FILE HEADER
;HERE WRITE BATCH VERSION# AND TODAYS DATE IN THE JOB LOG FILE
;AND THEN LOG THE JOB AND RETURN

HEADR:	PUSHJ	P,FSTSLW	;IS IT INCORE TYPE?
	SKIPA			;YES CONTINUE
	SETZM	INCORE		;CLEAR JOB INCORE WORD
	PUSHJ	P,LOGFL1	;LOOKUP LOG FILE
	PUSHJ	P,CRLF1		;WRITE CRLF IN LOG FILE
	PUSHJ	P,TIMLOG	;WRITE TIME IN LOG FILE
	MOVEI	T2,[SIXBIT/BVERS /]
	PUSHJ	P,BAOPR1	;WRITE LABEL IN LOG FILE
	MOVEI	T2,[SIXBIT/BATCON/]
	PUSHJ	P,BAOPR1	;WRITE IT IN LOG FILE
	PUSH	P,[0]		;MARK BOTTOM OF STACK
	LDB	T1,[POINT 3,.JBVER,2]
	JUMPE	T1,GETE		;NOT SET IF ZERO
	ADDI	T1,"0"		;FORM NUMBER
	PUSH	P,T1		;STACK IT
	MOVEI	T1,"-"		;SEPARATE HYPHEN
	PUSH	P,T1		;STACK IT ALSO
GETE:	HRRZ	T1,.JBVER	;GET EDIT NUMBER
	JUMPE	T1,GETU		;SKIP ALL IF ZERO
	MOVEI	T2,")"		;ENCLOSE IN PARAEN
	PUSH	P,T2		;SAVE IT
GETED:	IDIVI	T1,8		;GET OCTAL DIGITS
	ADDI	T2,"0"		;MAKE ASCII
	PUSH	P,T2		;STACK IT
	JUMPN	T1,GETED	;LOOP TOLL DONE
	MOVEI	T1,"("		;OTHER PAREN
	PUSH	P,T1		;SAVE IT
GETU:	LDB	T1,[POINT 6,.JBVER,17]
	JUMPE	T1,GETV		;SKIP IF ZERO
	IDIVI	T1,8		;MIGHT BE TWO DIGITS
	ADDI	T2,"@"		;FORM ALPHA
	PUSH	P,T2		;SAVE IT
	JUMPN	T1,GETU+1	;LOOP IF NOT DONE
GETV:	LDB	T1,[POINT 9,.JBVER,11]
	IDIVI	T1,8		;GET DIGIT
	ADDI	T2,"0"		;TO ASCII
	PUSH	P,T2		;SAVE IT
	JUMPN	T1,GETV+1	;LOOP
	POP	P,CH		;GET FIRST
	PUSHJ	P,LOGFL		;IN THE LOG FILE
	JUMPN	CH,.-2		;LOOP AND GET REST
	PUSHJ	P,TIM7LG	;SEND A SPACE TO LOG FILE
	>
	IFGE	FTOPR,<


	HLLZ	BUF,QUETAB-1(JB);POINT TO THE QUEUE
	MOVEI	T2,BUF		;POINT TO THE QUEUE
	PUSHJ	P,LOG2		;WRITE IT IN LOG FILE
	PUSHJ	P,TIM5LG+1	;FOLLOW IT WITH COLON
	PUSHJ	P,TIM7LG	; AND A SPACE
	MOVEI	T2,[SIXBIT/SUBJOB/]
	PUSHJ	P,BAOPR1	;SRITE IT IN LOG FILE
	MOVE	C,JB		;GET SUBJOB#
	PUSHJ	P,TIM8LG	;WRITE IT IN LOG FILE
	MOVEI	T2,[SIXBIT/OF/]
	PUSHJ	P,LOGSPC	;WRITE IN LOG FILE AND SPACE
	MOVE	C,MAXSTM	;GET THE NO. OF STREAMS
	PUSHJ	P,TIM2LG	;WRITE IT IN LOG FILE
	TRNE	F,F.PRIV	;DOES IT HAVE WRITE PRIVS?
	PUSHJ	P,BMSG2		;NO. SAY IT IN THE LOG FILE
	PUSHJ	P,CRLF1		;SEND<CR> TO THE LOG FILE
	PUSHJ	P,TIMLOG	;SEND TIME OF DAY
	MOVEI	T2,[SIXBIT/BDATE /]
	PUSHJ	P,BAOPR1	;WRITE IT IN LOG FILE
	PUSHJ	P,TDATE		;WRITE TODAYS DATE
	PUSHJ	P,CRLF1		;WRITE <CR> IN LOG FILE
	PUSHJ	P,TIMLOG	;WRITE TIME IN LOG FILE
	MOVEI	T2,[SIXBIT/BASUM /]
	PUSHJ	P,BAOPR1	;WRITE IT IN LOG FILE
	>
	IFGE	FTOPR,<
	MOVEI	T2,Q.JOB(B)	;GET THE JOB NAME
	PUSHJ	P,LOG2		;WRITE IT IN LOG FILE
	MOVE	T2,C.FDIR(B)	;GET WHERE CONTROL FILE IS
	PUSHJ	P,CTLSFD	;WRITE IT IN LOG FILE
	MOVEI	T2,[SIXBIT/FOR/]
	PUSHJ	P,LOGSPC	;WRITE IT IN LOF AND SPACE
	MOVEI	CH,"*"		;GET AN ASTERISK
	PUSHJ	P,LOGFL		;WRITE IT IN LOG FILE
	SKIPN	Q.USER(B)	;DONOT SKIP IF NULL
	JRST	HEAD1		;TYPEOUT NEXT WORD
	MOVEI	T2,Q.USER(B)	;GET THE USERS NAME
	PUSHJ	P,BAOPR3	;WRITE IT IN LOG FILE
HEAD1:	SKIPN	Q.USER+1(B)	;CHECK THIS WORD
	JRST	HEAD2		;SKIP IF NONE
	MOVEI	T2,Q.USER+1(B)	;GET THE REST OF USERS NAME
	PUSHJ	P,BAOPR3	;WRITE IT IN LOG FILE
HEAD2:	MOVEI	CH,"*"		;GET THE CHARACTER "*"
	PUSHJ	P,LOGFL		;WRITE IT IN LOG FILE
	MOVE	T2,Q.PPN(B)	;GET THE USER P,PN
	MOVEI	T1,1		;SET A FLAG
	PUSHJ	P,PPNLOG	;WRITE IT IN LOG FILE
	MOVEI	T2,ERMS14
	PUSHJ	P,LOG1		;WRITE IT IN LOG FILE
	MOVE	T2,L.FDIR(B)	;GET LOG FILE P,PN
	PUSHJ	P,LOGSFD	;WRITE IT IN LOG FILE
	PUSHJ	P,CRNLFF	;WRITE IT IN LOG FILE
	MOVEI	T2,ERMSG9	;WRITE IT IN LOG FILE
	PUSHJ	P,LOG1		;
	PUSHJ	P,GETCRE	;GET CREATED TIME
	PUSHJ	P,CRNLFF	;
	MOVEI	T2,ERMS10	;POINT TO THE MESSAGE
	PUSHJ	P,LOG1		;WRITE IT IN LOG FILE
	MOVE	T2,[POINT 3,D]
	LDB	D,[POINT 2,Q.IDEP(B),2]
	PUSHJ	P,HEAD3		;WRITE IT IN LOG FILE
	MOVEI	T2,ERMS11	;POINT TO THE MESSAGE
	PUSHJ	P,LOG1		;WRITE IT IN LOG FILE
	MOVE	T2,[POINT 3,D]
	LDB	D,[POINT 1,Q.IDEP(B),0]
	TRC	D,1		;COMPLEMENT IT
	PUSHJ	P,HEAD3		;WRITE IT IN LOG FILE
	SKIPN	Q.DEAD(B)	;CHECK IF DEADLINE NONZERO
	SKIPE	Q.AFTR(B)	;CHECK IF AFTER NONZERO
	JRST	HEAD7		;AT LEAST ONE NONZERO
	JRST	HEAD5		;BOTH ZERO SUPPRESS TYPEOUT
	>
	IFGE	FTOPR,<
HEAD7:	PUSHJ	P,CRNLFF	;WRITE <CR> IN LOG FILE
	SKIPN	T1,Q.AFTR(B)	;GET THE AFTER WORD
	JRST	HEAD6		;ZERO CHECK THE DEADELINE WORD
	MOVEI	T2,ERMS12	;POINT TO THE MESSAGE
	PUSHJ	P,LOG1		;WRITE IT IN LOG FILE
	PUSHJ	P,AFTDED	;IN THE LOG FILE
HEAD6:	SKIPN	T1,Q.DEAD(B)	;GET THE DEADLINE WORD
	JRST	HEAD5		;ZERO GO LOGIN THE JOB
	MOVEI	T2,ERMS13	;POINT TO THE MESSAGE
	PUSHJ	P,LOG1		;
	PUSHJ	P,AFTDED	;WRITE IN LOG FILE
HEAD5:	PUSHJ	P,CRLF1		;SEND CRLF
	PJRST	CTRC1		;GO LOGIN THE JOB


ERMSG9:	ASCIZ/Request created at  /
ERMS10:	ASCIZ/Unique: /
ERMS11:	ASCIZ/ Restart: /
ERMS12:	ASCIZ/After: /
ERMS13:	ASCIZ/Deadline: /
ERMS14:	ASCIZ/Log file in /
	>


	IFGE	FTOPR,<
SUBTTLE LOG FILE HEADER--RANDOM ROUTINES
;HERE CHECK IF LOG AND CTL FILES ARE THE SAME WHICH IS AN ERROR

LOGCTL:	HRLZI	C,-FULPAT	;TOTAL LENGTH OF FULL PATH
	MOVE	D,L.FSTR(C)	;GET THE START
	CAME	D,C.FSTR(C)	;CHECK AGAINST CONTROL FILE
	JRST	CPOPJ1		;RETURN O.K.
	AOBJN	C,.-3		;CHECK REST OF IT
	POPJ	P,		;RETURN ILLEGAL 



HEAD3:	SKIPN	D		;IS IT ZERO
	PUSHJ	P,TYZERO	;TYPE ZERO
	PJRST	LEAZRO		;SKIP THE LEADING ZEROS
HEAD4:	MOVEI	CH,"."		;GET A PERIOD
	PJRST	LOGFL		;WRITE IT IN LOG FILE



	>


	IFGE	FTOPR,<
;HERE PRINT AFTER AND DEADLINE PARAMETERS

	;MOVE T1,DATAWORD
	;PUSHJ P,AFTDED
	;(NORMAL RETURN)

AFTDED:	MOVEI	CH,"+"		;INDICATE IT IS FROM NOW
	PUSH	P,T1		;SAVE T1
	PUSHJ	P,LOGFL		;WRITE IT IN LOG FILE
	POP	P,T1		;RESTORE T1
	SUB	T1,Q.CREA(B)	;DIFRRENCE IN T1
	HRRZ	C,T1		;FRACTION OF DAY
	IMULI	C,^D86400	;
	HLRZS	C		;TIME IN SECONDS
	HLRZS	T1		;GET #0F DAYS
	IMULI	T1,^D86400	;
	ADD	C,T1		;TLTAL IN SECONDS
	IMULI	C,^D1000	;TIME IN MILLISECONDS
	TLO	F,F.TAB		;SET TAB FLAG
	PJRST	TIM9LG		;WRITE IT IN LOG FILE


;HERE PRINT IN LOG FILE CREATION TIME AND DATE

GETCRE:	MOVE	T1,Q.TIME(B)	;GET THE TIME JOB SCHEDULED
	SUB	T1,Q.CREA(B)	;TIME SINCE JOB CREATED
	HRRZ	C,Q.CREA(B)	;GET FRACTION OF DAY
	IMULI	C,^D86400	;TIME IN SECONDS
	HLRZS	C		;TIME IN MILLISECONDS
	IMULI	C,^D1000	;TIME IN MILLISECONDS
	TLO	F,F.TAB		;SET TAB FLAG
	PUSH	P,T1		;SAVE T1
	PUSHJ	P,TIM9LG	;WRITE TIME STAMP
	POP	P,T1		;RESTORE T1
	HLRZS	T1		;GET DAYS
	DATE	C,		;GET TODAYS DATE
	TRNE	T1,-1		;IS IT SAME DAY
	SUB	C,T1		;NO.
	PJRST	TDATE1		;WRITE IT IN LOG FILE
	>

	IFGE	FTOPR,<
LEAZRO:	ILDB	C,T2		;GET THE FIRST CHARACTER
	TLNN	T2,770000	;ARE WE DONE?
	JUMPE	C,CPOPJ		;IF NONZERO SAVE IT
	JUMPE	C,LEAZRO	;SKIP THE LEADING ZEROS
	SKIPA			;SKIP LAWAYS
HEADR1:	ILDB	C,T2		;GET A CHARACTER
	PUSHJ	P,TIM4LG	;WRITE IT IN LOG FILE
	TLNE	T2,770000	;ARE WE DONE?
	JRST	HEADR1		;NO. GET NEXT CHARACTER
	POPJ	P,		;RETURN

LOG2:	HRLI	T2,440600	;SETUP THE BYTE POINTER
LOG3:	ILDB	CH,T2		;GET A CHARATER
	JUMPE	CH,CPOPJ	;RETURN IF NULL
	ADDI	CH," "		;CHANGE IT TO ASCII
	PUSHJ	P,LOGFL		;WRITE IN LOG FILE
	TLNE	T2,770000	;ARE WE DONE?
	JRST	LOG3		;NO. GET NEXT CHARACTER
	POPJ	P,		;RETURN

TYZERO:	MOVEI	CH,"0"
	PJRST	LOGFL		;WRITE IT IN LOG FILE

;HERE PRINT P,PN IN THE RIGHT FORMAT
CTLSFD:	SKIPA	T1,[-1]		;FLAG IT AS CTL FILE
LOGSFD:	SETZ	T1,		;FLAG IT AS LOG FILE
PPNLOG:	MOVEM	T2,TCOM1	;SAVE IT TEMPORARILY
	MOVEI	CH,"["		;WRITE LEFT SQUARE BARCKET
	PUSHJ	P,LOGFL		; IN THE LOG FILE
	HLRZ	D,TCOM1		;GET PROJ#
	MOVE	T2,[POINT 3,D]
	PUSHJ	P,LEAZRO	;WRITE IN LOG FILE
	MOVEI	CH,","		;GET COMMA
	PUSHJ	P,LOGFL		;WRITE IT IN LOG FILE
	HRRZ	D,TCOM1		;GET PROG#
	MOVE	T2,[POINT 3,D]
	PUSHJ	P,LEAZRO	;SKIP LEADING ZEROS
	SKIPG	T1		;SFD'S OR NOT
	PUSHJ	P,SFDNOW	;YES.
	MOVEI	CH,"]"		;GET THE RIGHT SQUARE BRACKETS
	PUSHJ	P,LOGFL		;WRITE IT IN LOG FILE
	PJRST	TIM7LG		;WRITE IN LOG AND A SPACE

LOGSPC:	PUSHJ	P,LOG2		;WRITE IN LOG
	PJRST	TIM7LG		;WRITE A SPACE AND RETURN

CRNLFF:	PUSHJ	P,CRLF1		;WRITE <CR> IN LOG FILE
	TLZ	F,F.LF		;RESET LF FLAG
	POPJ	P,		;RETURN
	>
	IFGE	FTOPR,<
SUBTTLE CHECK LOG-CTL FILE READ/WRITE PRIVS.
DEVGET:	DEVCHR	C,		;GET DEVICE CHARCTERISTICS
	JUMPE	C,CPOPJ		;DOES IT EXIST?
	TLNE	C,200000	;YES. IS IT DISK?
	JRST	CPOPJ1		;YES. SKIP RETURN
	POPJ	P,		;ERROR RETURN


ENTPR1:	POP	P,C		;RESTORE AC C
DEVGT2:	MOVE	T2,[POINT 6,L.FSTR(B)]
	SKIPA			;SKIP ALWAYS
DEVGT1:	MOVE	T2,[POINT 6,C.FSTR(B)]
	PUSHJ	P,LOGFL6	;WRITE FILE STRUCTURE NAME
	PJRST	REL4		;ABORT THE JOB


BMSG2:	PUSHJ	P,BMSG1		;WRITE TIME AND BATCH
	HRRI	T2,ERMSG2	;POINT TO THE MESSAGE
	PJRST	LOG1		;WRITE IT IN THE LOG FILE


;HERE TYPEOUT SFD'S FOR LOG FILE

SFDNOW:	HRLZI	C,-SFDDEP	;TOTAL# IN REQUEST
	HRRI	C,L.FDIR+1(B)	;TRY LOG FILE
	SKIPL	T1		;TO BE SURE
	SKIPA			;YES. LOG ILE
	HRRI	C,C.FDIR+1(B)	;NO. IT IS CONTROL FILE
SFDNO1:	SKIPN	(C)		;IS IS NULL?
	POPJ	P,		;YES. RETURN
	MOVEI	CH,","		;
	PUSHJ	P,LOGFL		;WRITE IT IN LOG FILE
	HRR	T2,C		;POINT TO THE SFD
	PUSHJ	P,LOG2		;WRITE IT IN LOG FILE
	AOBJN	C,SFDNO1	;CHECK FOR OTHERS
	POPJ	P,		;NO MORE
	>

	IFGE	FTOPR,<
;HERE CHECK THE USERS RIGHT TO WRITE IN THE UFD.
;IF SUCCESSFUL PROCEDD WITH JOB


ENTPRV:	SKIPE	L.FRNM(B)	;IS IT ALREADY  RENAMED?
	POPJ	P,		;YES.RETURN
	HRLZI	C,PHYSCL	;SET FOR PHYSICAL DEVICE ONLY
	HRRI	C,DUMP		;SET FOR DUMP MODE
	MOVE	D,L.FSTR(B)	;STRUCTURE NAME
	MOVEI	E,0		;NO BUFFERS
	OPEN	CH0,C		;DO OPEN ON THIS STRUCTURE
	JRST	ENTPR1		;ERROR RETURN
	MOVE	C,L.FDIR(B)	;GET P,PN
	MOVSI	D,(SIXBIT/UFD/)	;EXTENSION UFD
	MOVEI	E,0		;
	MOVE	G,[MFDPPN]
	GETTAB	G,		;GET IT FROM THE MONITOR
	MOVE	G,[XWD 1,1]	;FOR MFD
	LOOKUP	CH0,C		;DO A LOOKUP
	JRST	ENTPR2		;ERROR RETURN(NO UFD)
	LDB	C,[POINT 9,E,8]	;GET THE PROTECTION
	LSH	C,^D9		;SHIFT 9 PLACES
	HRLI	C,2		;SET ACCESS UUO ARGUMENTS
	MOVE	D,L.FDIR(B)	;P,PN OF THE DIRECTORY
	MOVE	E,Q.PPN(B)	;P,PN OF THE USER
	MOVEI	G,C		;SETUP THE ADDRESS WORD
	CHKACC	G,		;DO THE ACCESS UUO
	JRST	ENTPR2		;ERROR RETURN
	JUMPGE	G,RELCH0	;ZERO. ACCESS IS ALLOWED
ENTPR2:	MOVE	T2,[POINT 6,L.FSTR(B)]
	PUSHJ	P,JOBNM1	;WRITE ON TTY
	PUSHJ	P,PRJETC	;WRITE P,PN ON TTY
	TYPDSK</? No write privs. LOG file in users area
!/>
	TRO	F,F.PRIV	;SET NO PRIVILEDGE FLAG
	>
CLSP:	TRNN	F2,F2.FST	;IS IT IN CORE TYPE?
RELCH0:	RELEASE	CH0,		;RELEASE CHANNEL ZERO
STOP6:	MOVEM	F,FLAGS(B)	;SAVE FLAGS
	MOVEM	F2,FLAG2(B)	;SAVE FLAGS
	POPJ	P,		;RETURN

	IFGE	FTOPR,<
;HERE CHECK THE USERS RIGHT TO READ THE CONTROL FILE


REDPRV:	PUSHJ	P,LOOKCT	;DO LOOKUP ON CTL FILE
	PJRST	REDPR4		;ERROR RETURN
	LDB	C,[POINT 9,E,8]	;GET THE PROTECTION CODE
	HRLI	C,5		;SET ACCESS UUO ARGUMENTS
	MOVE	D,C.FDIR(B)	;GET DIRECTORY P,PN
	MOVE	E,Q.PPN(B)	;USER P,PN
	MOVEI	G,C		;SETUP ADDRESS WORD
	CHKACC	G,		;DO ACCESS UUO
	PJRST	REDPR2		;ERROR RETURN
	JUMPGE	G,RELCH0	;ZERO. ACCESS ALLOWED
REDPR2:	MOVE	T2,[POINT 6,C.FSTR(B)]
	PUSHJ	P,JOBNM1	;WRITE STRUCTURE
	PUSHJ	P,PRJETC	;WRITE P,PN
	TYPDSK</? No read privs. JOB aborted
!/>
REDPR1:	TRO	F,F.CTL		;SET NO CONTROL FILE FLAG
	PJRST	RELCH0		;RELEASE CHANNEL AND RETURN


REDPR4:	TRNE	F,F.CTL		;IS CTL FILE MISSING?
	PJRST	RELCH0		;YES RETURN
REDPR3:	POP	P,C		;ALIGN STACK
	PJRST	DEVGT1		;TYPEOUT MESSAGE AND ABORT JOB
	>
	IFGE	FTOPR,<
SUBTTLE DATE
;THIS ROUTINE SAVES TODAYS DATE IN LOG FILE

TDATE:	DATE	C,		;GET TODAYS DATE
TDATE1:	IDIVI	C,^D31		;DAY IS IN AC D
	PUSH	P,C		;SAVE AC C
	MOVEI	C,1(D)		;GET THE DAY
	PUSHJ	P,TIM2LG	;ENTER DAY IN LOG FILE
	POP	P,C		;RESTORE C
	IDIVI	C,^D12		;AC D CONTAINS MONTH
	PUSH	P,C		;SAVE AC C
	HRRI	T2,MONTH(D)	;GET MONTH
	PUSHJ	P,LOG1		;WRITE IT IN LOG FILE
	MOVEI	CH,"-"
	PUSHJ	P,LOGFL
	POP	P,C		;RESTORE AC C
	ADDI	C,^D64		;GET YEAR
	PJRST	TIM2LG		;WRITE IT IN LOG FILE

MONTH:	ASCIZ/-Jan/
	ASCIZ/-Feb/
	ASCIZ/-Mar/
	ASCIZ/-Apr/
	ASCIZ/-May/
	ASCIZ/-Jun/
	ASCIZ/-Jul/
	ASCIZ/-Aug/
	ASCIZ/-Sep/
	ASCIZ/-Oct/
	ASCIZ/-Nov/
	ASCIZ/-Dec/


	>

	IFGE	FTOPR,<
SUBTTLE CALL QMANGR-- CHECK JOB VALIDITY
;HERE SETUP THE DATA AREA FOR THE QUEUER ROUTINE. QUEUER SEARCHES
;THE INPUT QUEUE FOR AN ENTRY. IT RETURNS ALL INFORMATION ABOUT
;THE ENTRY IN THE DATA AREA QDAT

SCHR:	PUSHJ	P,SCHR1		;SETUP THE DATA AREA
	PUSHJ	P,.QUEER	;GO TO QUEUER
	HRRZS	NLINES		;CLEAR LEFT HALF
	SKIPN	Q.AFTR(B)	;ARE THERE ANY AFTER OR DEADLINE JOBS?
	TROA	GF,SLPINF	;NONE. SLEEP INFINITE
	TRZ	GF,SLPINF	;YES. GO BY ZZZ COMMAND
	SKIPN	Q.DEV(B)	;IS THERE AN ENTRY?
	PJRST	SCHR6		;CHECK IF OTHER QUEUES ARE EMTY AS WELL

;HERE CHECK IF THERE EXISTS A LOG FILE IN THE AREA THAT IS 
;ALREADY IN USE. THIS IS SO THE INCORE TYPE BATCH STREAMS DONOT
;GET ENTER ERROR IN LOG FILES. COUNT IN DATA BASE
; IF ZERO SAYS THE CURRENT JOB IS IN CORE TYPE

	SKIPE	COUNT		;CURRENT ONE INCORE TYPE?
	PJRST	CPOPJ1		;NO. SCHEDULE IT
	HLRZ	D,SLWSRM	;#OF NOT INCORE TYPES.
	JUMPE	D,SCHR3		;ALL IN CORE
	CAME	D,MAXSTM	;ARE ALL INCORE TYPES?
;HERE WHEN ALL STREAMS ARE INCORE TYPES.

SCHR3:	SKIPN	JBSACT		;ANY JOBS INUSE?
	PJRST	CPOPJ1		;NONE INUSE. OK SCHEDULE
	MOVE	G,MAXSTM	;UPPER LIMIT
	SUBI	G,(D)		;COUNT OF INCORE TYPES
	SETZ	A,		;CLEAR THE DATA BASE REFERENCE
	MOVEI	E,1		;FIRST SUBJOB
SCHR4:	SKIPE	PTYTAB-1(E)	;IS THIS JOB INUSE?
	CAMN	B,A		;IS IT DIFFERENT ONE?
	PJRST	SCHR5		;YES.GO TO NEXT ONE
	MOVEI	D,L.FSTR(B)	;GET THE STRUCTURE OF CURR JOB
	MOVEI	C,L.FSTR(A)	;GET THE ADDRESS OF THE OTHER STRUC
	HRLZI	T1,-FULPAT	;GET THE LENGTH OF FULL PATH
	MOVE	T2,@D		;CONTENTS FROM THE CURRENT JOB
	CAME	T2,@C		;CHECK AGAINST NEW JOB
	JRST	SCHR5		;O.K. PROCEED
	AOS	D		;NEXT LOCATION
	AOS	C		;NEXT LOCATION
	AOBJN	T1,.-5		;CHECK THE REST OF IT
	JRST	[  PUSHJ P,REL2	;REQUEUE THE JOB TO RUN LATER
		PJRST OUTCO1	;RETURN
			]
SCHR5:	ADDI	A,SIZE		;NEXT JOB
	CAMGE	E,G		;ARE WE THE RANGE?
	AOJA	E,SCHR4		; TO NEXT JOB
	JRST	CPOPJ1		;RETURN
	>
	IFGE	FTOPR,<
SUBTTLE SETUP PTY BUFFERS
;HERE TO GET A PTY FOR A SUBJOB IN AC JB
;AC E CONTAINS INDEX INFORMATION FOR PTY INPUT/OUTPUT
;BUFFER HEADERS.

JBSCH:	PUSHJ	P,NEWCHN	;GET A FREE CHANNEL
	PJRST	JBSCH3		;NONE AVAILABLE
	DPB	D,[POINT 4,QUETAB-1(JB),29]
	MOVEI	A,0		;CLEAR A. START WITH PTY0
JBSCH1:	PUSHJ	P,GETPTY	;GO GET A PTY FOR THE JOB
	JRST	JBSCH3		;ERROR RETURN
	PUSH	P,A		;SAVE A
	PUSHJ	P,SETSRM	;GO INITIALIZE POINTERS
	MOVEI	A,PTIBUF(E)	;GET BUFFER HEADER WORD.
	HRLI	A,PTOBUF(E)	;GET THE SECOND HEADER.
	MOVEM	A,JBSCH5
	MOVEM	C,JBSCH4
	MOVEI	T2,1		;FLAG FOR PTY FILE
	MOVE	A,[OPEN ,JBSCH0]
	PUSHJ	P,IOUUO		;EXECUTE THE UUO
	JRST	JBSCH2		;IF OPEN FAILS, ERROR RETURN
	MOVEM	C,PTYTAB-1(JB)	;NORMAL RETURN
	HRLZI	A,400000	;GET 400000 IN LEFT HALF OF A
	HRRI	A,OBUF1+1(E)	;GET ADDRESS
	MOVEM	A,PTOBUF(E)	;SAVE IT IN OUTPUT HEADER
	HRRI	A,IBUF1+1(E)	;GET THE ADDDRESS
	MOVEM	A,PTIBUF(E)	;SAVE IT IN INPUT HEADER
	HRLZI	A,440700	;SET BYTE SIZE
	MOVEM	A,PTOBUF+1(E)	;SAVE IT IN OUTPUT HEADER
	MOVEM	A,PTIBUF+1(E)	;SAVE IT IN INPUT HEADER
	HRLZI	A,BUFSIZ	;GET BUFFER SIZE CONSTANT
	HRRI	A,OBUF2+1(E)	;ADDRESS OF SECOND RING
	MOVEM	A,OBUF1+1(E)	;SAVE IT IN SECOND WORD OF IST RING
	HRRI	A,OBUF1+1(E)	;ADDRESS OF IST RING
	MOVEM	A,OBUF2+1(E)	;SEVE IT IN SECOND WORD OF 2ND RING
	HRRI	A,IBUF2+1(E)	;ADDRESS OF SECOND RING
	MOVEM	A,IBUF1+1(E)	;SAVE IT IN SECOND WORD OF IST RING
	HRRI	A,IBUF1+1(E)	;ADDRESS OF IST RING
	MOVEM	A,IBUF2+1(E)	;SAVE IT IN SECOND WORD
	>
TPOPJ:	POP	P,A		;RESTORE A.
	POPJ	P,		;RETURN TO CALLING PROGRAM
	IFGE	FTOPR,<

JBSCH3:	TRO	GF,TTYDDB	;NO PTY AVAILABLE
	POPJ	P,		;RETRUN

JBSCH2:	POP	P,A		;RESTORE A.
	AOJA	A,JBSCH1	;INCREMENT PTY COUNT AND TRY AGAIN
	>
	IFGE	FTOPR,<
;HERE INITIALIZE AND SETUP POINTERS FOR THE STREAM

SETSRM:	PUSHJ	P,FSTSLW	;IS IT INCORE OR SWAP STREAM?
	SKIPA	A,BUFTAB(JB)	;FOR INCORE TYPE
	SKIP	A,BUFTAB	;SWAP ONE
	AOS	A		;SWAP STREAMS
SETSR2:	HRLI	A,(POINT 7,0)	;
	MOVEM	A,CTLPTR(E)	;SAVE IT
	ADDI	A,FSTBUF/2	;BUMP THE COUNT
	MOVEM	A,LOGPTR(E)	;SAVE IT
	SETZM	BKCPTR(E)	;CLEAR BACKTO POINTER
	MOVEI	A,1		;INITIALIZE CTL BLOCK COUNT
	MOVEM	A,USICNT(E)	;SAVE IT 
	POPJ	P,		;RETURN
	>



FSTSLW:	HLRZ	A,SLWSRM	;GET TOTAL SWAP STREAMS
	SUB	A,MAXSTM	;TOTAL STREAMS
	MOVMS	A		;G HAS INCORE STREAMS
	CAMG	JB,A		;IS IT GREATER THAN?
	POPJ	P,		;RETURN. INCORE STREAMS
	JRST	CPOPJ1		;SWAP STREAMS
	IFGE	FTOPR,<
;HERE INITIALIZE THE QUEUE TABLE

QUEINT:	MOVSI	A,(SIXBIT/INP/)	;ALL ARE INPUT QUEUE
	MOVEM	A,QUETAB	;SAVE IT
	HRLI	A,QUETAB	;SETUP UP BLT
	HRRI	A,QUETAB+1	;..
	BLT	A,QUETAB+JOBMAX-1
	POPJ	P,		;RETURN

;HERE SETUP THE ARGUMENTS FOR CALL TO QMANGR

SCHR1:	HLLZ	A,QUETAB-1(JB)	;FIND WHAT QUEUE
	MOVEM	A,Q.DEV(B)	;SAVE IT IN QDAT AREA
	MOVEM	C,Q.PDEV(B)	;SAVE PTY#
	MOVSI	A,SCHJB		;GET ADDRESS OF THE SCHEDULER
	HRRI	A,RSCHD		;REQUEST TO SCHEDULE
SCHR2:	MOVEM	A,Q.OPR(B)	;SAVE IT IN QDAT AREA
	HRRZI	A,Q.MEM(B)
	HRLM	B,NLINES	;SAVE THE JOB STARTING AREA
	HRLI	A,QDSIZ
	POPJ	P,

;HERE CHECK IF JOBS FOR OTHER LEGAL QUEUES
SCHR6:	HLLZ	A,QUETAB-1(JB)	;GET THE CURRENT QUEUE
	MOVEI	G,1		;SETUP THE MASK
	MOVN	D,MAXSTM	;TOTAL JOB STREAMS
	HRLZS	D		;SETUP THE INDEX
	HLLZ	C,QUETAB(D)	;GET THE QUEUE NAME
	CAMN	A,C		;IS IT THE SAME?
	PUSHJ	P,SETBIT	;SET BIT TO STOP SCHEDULING
	AOBJN	D,.-3		;CHECK NEXT IN THIS QUEUE
	POPJ	P,		;RETURN


SETBIT:	CAIE	JB,(D)		;IT IS THE CURRENT ONE.
	SKIPN	PTYTAB(D)	;IS THE JOB INUSE?
	IORM	G,QUETAB(D)	;NO. SET A FLAG
	POPJ	P,		;YES. RETURN

	>
SUBTTLE GET FREE BLOCK FOR LOG FILE
;HERE FIND FIRST FREE BLOCK IN LOG FILE.UPDATE USOCNT(B)
;AND CLEAR LOG FILE AREA

FRBLK:	PUSHJ	P,LKLOG		;DO LOOKUP ON LOG FILE
	TRZE	F,F.LOG		;IS A LOG FILE ALREADY STARTED.
	JRST	[  MOVEI A,1	;FIRST BLOCK
		JRST BLKWD1	;SAVE AND RETURN
			]
	HLRE	E,G		;EXTEND THE SIGN
	JUMPGE	E,BLKWRD	;IF +VE IT IS BLOCKS
	MOVNS	E		;MOVE NEGATIVE OF NO. OF WORDS
	IDIVI	E,DSKBUF	;FIND NO. OF BLOCKS
	JUMPE	G,BLKWRD	;IS IT WHOLE BLOCK
	AOS	E		;NO.
BLKWRD:	MOVEI	A,1(E)		;YES WHOLE BLOCK
BLKWD1:	MOVEM	A,USOCNT(B)	;EOF. SAVE BLOCK#.
	PUSHJ	P,LOGK		;SETUP THE ENTER WORD
	SETOM	T2		;FLAG IT FOR LOG FILE
	MOVE	A,[ENTER ,C]	;
	PUSHJ	P,IOUUO		;EXECUTE THE UUO
	PUSHJ	P,ERNTER	;GO INVESTIGATE THE ERROR?
	PUSHJ	P,FSTSLW	;IS IT IN CORE TYPE?
	JRST	[  TROE F2,F2.FST	;SET FLAG
		PJRST FRBLK2+1	;CLEAR THE AREA AND RETURN
		PJRST FRBLK	;DO LOOKUP AND ENTER FOR UPDATE MODE
			]
	TRZ	F2,F2.FST	;RESET THE INCORE FLAG
	TRZ	GF,SKIP		;SET FLAG TO CLEAR
	PUSHJ	P,RELCH0	;RELEASE CHA 0


FRBLK2:	PUSHJ	P,FSTSLW	;IS IT FAST/SLOW STREAM?
	TROA	F2,F2.FST	;FAST SAY SO
	SKIPA	A,BUFTAB	;SLOW
	SKIP	A,BUFTAB(JB)	;FAST
	HLRZ	C,A		;GET LOG FILE ADDRESS-1
	SETZM	1(C)		;CLEAR FIRST WORD
	HRLZI	A,1(C)		;PTYLOG IN LEFT HALF
	HRRI	A,2(C)		;PTYLOG +1 IN RIGHT HALF
	BLT	A,FSTBUF/2(C)	;CLEAR IT
	PJRST	STOP6+1		;SAVE F2 FLAGS


	IFGE	FTOPR,<
SUBTTLE FIRST FREE PTY
;HERE GET A PTY FOR THE JOB. PTY# IN SIXBIT RETURNED IN AC C
;ROUTINE USES ACS A,B,C,D
;CALLING SEQUENCE
;		MOVEI A,N
;		PUSHJ P,GETPTY
;		ERROR RETURN
;		NORMAL RETURN
;N IS STARTING PTY#.NORMALLY N=0

GETPTY:	HRLZI	C,'PTY'		;LEFT HALF HAS SIXBIT PTY
GETPT1:	CAML	A,PTYMAX	;IS A WITHIN BOUNDS
	JRST	CPOPJ		;ERROR RETURN NO PTYS AVAILABLE.
	PUSH	P,A		;SAVE CONTENTS OF A
	PUSHJ	P,CONSIX	;CONVERT A INTO SIXBIT
	POP	P,A		;RESTORE CONTENTS OF A
	MOVN	B,MAXSTM	;GET NEGATIVE OF JOB STREAMS
	HRLZS	B		;SETUP INDEX FOR SEARCH OF PTYTAB
GETP2:	MOVE	D,PTYTAB(B)	;GET NEXT ENTRY IN PTYTAB
	JUMPE	D,GETP3		;IS IT BLANKS GO TO NEXT ENTRY
	CAMN	C,D		;COMPARE THE TABLE ENTRY
	AOJA	A,GETPT1	;MATCHES IT IS BEING USED
GETP3:	AOBJN	B,GETP2		;GO SEARCH OTHER ENTRIES
	>
CPOPJ1:	AOS	(P)		;C HAS THE PTY # IN SIXBIT THAT IS FREE
CPOPJ:	POPJ	P,		; GO INIT DEVICE NOW



	IFGE	FTOPR,<
;HERE CONVERT PTY# IN BINARY INTO SIXBIT USES ACS A,B,C,D

CONSIX:	MOVE	D,POINTR
CONS1:	IDIVI	A,^D8
	PUSH	P,B
	SKIPE	A
	PUSHJ	P,CONS1
	POP	P,A
	ADDI	A,20
	IDPB	A,D
	POPJ	P,

POINTR:	POINT	6,C,17
	>
	IFG	FTOPR,<
SUBTTLE CALL BATOPR
OPTR:	SKPINL			;SKIP IF LINE TYPEIN
DISPLY:	POPJ	P,		;RETURN
OPTR5:	MOVEM	GF,GLBFLG	;SAVE THE FLAGS
	HRRZI	A,LST		;POINTER TO HISEG NAME
	HRLI	A,(L.HISG!L.PDLN)	;SET BIT TO READ IT
	MOVE	C,[SIXBIT/BATOPR/]
	MOVEM	C,LST		;SAVE THE SEGMENT NAME
	PUSHJ	P,.QUEER	;CALL QUEUER,TO CALL BATOPR
	MOVE	GF,GLBFLG	;GET THE GLOBAL FLGS
	TRO	GF,TTYIOW	;SET TTY WAIT BIT
	SKIPE	A,FITJOB	;DO WE NEED TO CHANGE MJOB?
	PUSHJ	P,DMXJB6-3	;GO INITIALIZE
	PUSHJ	P,FLSHJB	;CHECK IF JOB TO BE K FLUSHED.
	TRNN	GF,ASTRK	;IS START COMMAND ON?
	JRST	OPTR5		;NO. WAIT FOR IT
OPTR3:	PUSHJ	P,EXCAST
	IFN	DEBUG,<

	EXTERN	.JBHSM,.JBSYM
	SKIPE	A,400000+.JBHSM	;GET THE POINTER IF SYMBOLS IN HI SEG
	MOVEM	A,.JBSYM	;SAVE IN LOW SEG LOC.

		>
	JRST	OPTR		;ANOTHER LINE?
	>

	IFE	FTOPR,<
SUBTTLE OPERATOR COMMAND PROCESSOR
;HERE WHEN OPERATOR INTERRUPTS THE PROGRAM.
;GO GET THE OPERATOR TYPEDIN COMMAND. CHECK IF IT IS A LEGAL COMMAND.
;ALSO CHECK IF SUBJOB# SPECIFIED IN THE COMMAND IS LEGAL. IF BOTH OK
;GO SERVICE THE COMMAND.

OPTR:	SKPINL			;SKIP IF LINE TYPEDIN
	POPJ	P,		;RETURN 
OPTR5:	TRO	GF,TTYIOW	;SET TI WAIT BIT
	PUSHJ	P,COM1		;CHECK SUBJOB# OR IS IT "ALL"
	PUSHJ	P,GETCOM	;GO GET THE COMMAND
	PUSHJ	P,DISPCH	;GO SERVICE THE COMMAND
OPTR3:	PUSHJ	P,EXCAST	;MUST TYPE EXCLAMATION OR ASTRISK
	JRST	OPTR		;GO CHECK WITH OPERATOR
	>
	IFLE	FTOPR,<


;THIS ROUTINE CHECKS THE OPERATOR COMMAND SYNTAX AS FAR AS THE SUBJOB#
	;AND ISTS DEFAULT VALUES ARE CONCERNED.


COM1:	MOVE	D,[POINT 6,COM]	;SETUP THE COMMAND POINTER
	SETZB	C,COM		;CLEAR COMMAND WORD.
	PUSHJ	P,SPPC		;GET CHARAC. IGNORE CR,NULLS,SPACES
	PUSHJ	P,CONCHR	;IS IT CONTROL CHARACTER?
	SKIPA			;NO. SKIP ALWAYS
	JRST	COMER2		;IT IS COMMAND ERROR
	CAIN	CH,";"		;IS IT SEMICOLON?
	JRST	COMER4		;YES. PROCESS IT
	CAIN	CH,"B"		;IS IT "B" IF SO IGNORE IT.
	PUSHJ	P,SPPC		;GET NEXT CHARACTER. IGNORE SPACES.
	CAIE	CH,"A"		;IS IT "A". LOOK FOR"ALL"
	PJRST	NUMBR2		;NO. LOOK FOR A NUMERAL.
	PUSHJ	P,CNVSIX	;CONVERT TO SIXBIT
COM3:	PUSHJ	P,INCHR		;GET NEXT CHARC. IGNOR CR, NULLS.
	CAIE	CH,"L"		;IS IT "L"
	JRST	COM4		;NO LOOK FOR "-".
	PUSHJ	P,CNVSIX	;CONVERT TO SIXBIT
	TLNE	D,770000	;TEST IF SIX CHARAC. READ
	JRST	COM3		;NO READ NEXT CHARACTER.
COM4:	PJRST	DISPCH		;GO DISPATCH. CH CONTAINS A CHRACTER.
	>

;HERE CHECK IF START COMMAND HAS BEEN ISSUED.

EXCAST:	TRNN	GF,ASTRK	;IS IT ASTRISK FLAG?
OUTAST:	SKIPA	CH,["*"]	;SETUP FOR *
EXCLAM:	MOVEI	CH,"!"		;SETUP FOR !
	OUTCHR	CH		;TYPE IT
	PJRST	DSKLOG		;SAVE IN DISK LOG
	IFLE	FTOPR,<


;HERE GET COMMAND FROM BATCH CONTROL TERMINAL.

GETCOM:	CAMLE	C,MAXSTM	;IS SUBJOB# GREATER THAN 14.?
	JRST	COMERR		;COMMAND ERROR.
	CAIE	CH,"-"		;IS IT A HYPHEN?
	SKIPA			;CONTINUE
GETC1:	PUSHJ	P,SPPC		;GET A CHARAC. IGNORE NULLS, CR, SPACES.
	CAIN	CH,33		;IS IT ALTMODE?
	JRST	CLFSP4		;YES
	CAIN	CH,32		;IS IT ^Z?
	JRST	[  PUSHJ P,DEXIT+1	;YES SETUP FOR EXIT
		PJRST CPOPJ1	;RETURN
			]
	PUSHJ	P,CONCHR	;IS LF,FF ETC?
	JRST	GETC4		;NO
	JRST	CPOPJ1		;YES. SKIP RETURN

GETC4:	MOVE	D,[POINT 6,COM]	;POINTER TO SAVE COMMAND.
	SETZM	COM		;CLEAR THE COMMAND WORD
	PUSHJ	P,CLFSP1	;IS IT LF OR SPACE?
	SKIPA			;SKIP ALWAYS
GETC2:	PUSHJ	P,CHLFSP	;CHECK IF LF OR SPACE
	PUSHJ	P,SPERTR	;IS IT ALPHABETIC?
	JRST	GETC5		;NO.
	PUSHJ	P,CNVSIX	;NO.CHANGE TO SIXBIT
	TLNE	D,770000	;HAVE WE READ SIX CHARACTERS.
	JRST	GETC2		;NO GET NEXT CHARACTER.
GETC3:	PUSHJ	P,CHLFSP	;CHARACTER LF OR SPACE.
	PUSHJ	P,SPERTR	;IS IT ALPHABETIC?
	JRST	GETC5		;NO.
	JRST	GETC3		;NO. WAIT TILL IT IS LF OR SPACE


GETC5:	CAIE	CH,";"		;IS IT SEMICOLON?
	JRST	COMERR		;COMMAND ERROR.
	POPJ	P,		;RETURN
	>


CNVSIX:	SUBI	CH,40		;CHANGE IT TO SIXBIT
	IDPB	CH,D		;SAVE IT 
	POPJ	P,		;RETURN



	IFLE	FTOPR,<
;ROUTINE GETS CHARACTER FROM TTY AND CHECKS FOR LF,SPACE OR HT.

CHLFSP:	PUSHJ	P,INCHR		;GET NEXT CHARACTER.
CLFSP1:	CAIG	CH,FF		;IS IT A CONTROL CHARACTER?
	CAIGE	CH,HT		;IS IT HT OR LF OR VT ?
	CAIN	CH,40		;IS IT SPACE?
	JRST	TPOPJ		;REMOVE ONE STACK LEVEL AND RETURN
	POPJ	P,		;RETURN


;THIS ROUTINE USED FOR PLEASE COMMAND TRAPPING

CLFSP4:	MATCH(KILL,CLFSP6)	;DOES IT MATCH KILL COMMAND
	JRST	GETC4		;YES CONTINUE
CLFSP6:	PUSH	P,CH		;SAVE CH
	PUSHJ	P,CRLF		;YES SEND <CR> TO THE TERMINAL
	POP	P,CH		;RESTORE CH
	PUSHJ	P,CHKSJB	;CHECK VALIDTY OF SUBJOB#
	PJRST	COMERR		;COMMAND ERROR.
	PUSHJ	P,ACTV1		;IS SUBJOB ACTIVE?
	JRST	JNACTV		;JOB NOT ACTIVE.
	TRNN	GF,ALLF		;IS ALL JOBS FLAG ON?
	JRST	CLFSP2		;RESET F.WOPR AND RETURN
	PUSHJ	P,CLFSP3	;YES. PROCESS ALL JOBS
	JRST	CPOPJ1		;SKIP RETURN

CLFSP3:	ALLJOB(CLFSP5)		;PROCESS AL JOBS
CLFSP5:	TLZ	F,F.WOPR	;RESET F.WOPR FLAG
	MOVEM	F,FLAGS(B)	;SAVE THE FLAGS
	POPJ	P,		;RETURN

CLFSP2:	TLZ	F,F.WOPR	;RESET F.WOPR FLAG
	MOVEM	F,FLAGS(B)	;SAVE FLAGS
	JRST	CPOPJ1		;RETURN

	>


	IFLE	FTOPR,<
;ROUTINE READS CHARACTERS FROM CONTROLLING TERMINAL,DOES PROPER
;CONVERSIONS.

INCHR:	INCHWL	CH		;GET A CHARACTER FROM TERMINAL.
	PUSHJ	P,DSKLOG	;SAVE IT IN DISK LOG.
	JUMPE	CH,INCHR	;IGNORE NULLS
	CAIE	CH,015		;IS IT CR
	CAIN	CH,177		;IGNORE RUBOUTS
	JRST	INCHR		;IGNOR CR
	PUSHJ	P,INCHR1	;CHECK FOR ALTMODES.
	>
INCHR2:	CAIL	CH,140		;CHANGE IT LOWER CASE TO UPPER CASE
	TRZ	CH,40		;
	POPJ	P,		;RETURN
INCHR1:	CAIE	CH,176		;CONSIDER ALL ALTMODES
	CAIN	CH,175		; ONE MORE ALTMODE
	MOVEI	CH,33		;REAL ALTMODE
	POPJ	P,		;RETURN
	IFLE	FTOPR,<
;GET CHARACTER IGNORE, SPACES AND HT,ETC.,
SPPC:	PUSHJ	P,INCHR		;GO GET A CHARACTER
	PUSHJ	P,SPCES		;IS IT SPACE TAB ETC?
	POPJ	P,		;NO.RETURN
	PJRST	SPPC		;YES. IGNORE IT

;HERE IF A COMMAND ERROR IS DETECTED.

	CAIN	CH,";"		;IS IT A COMMENT LINE?
	JRST	COMER4		;YES. READ REST OF THE LINE
COMERR:	PUSHJ	P,CONCHR	;IS IT LF,VT,OR FF?
	PUSHJ	P,RDCOM1	;READ REST OF THE COMMAND.
	TYPDSK</? Command error/>
	PUSHJ	P,CRLF		;CRLF
COMER2:  POP P,A		;REMOVE ONE LEVEL
	TRNE	GF,TTYIN	;DEMAND INPUT?
	JRST	START3		;GET A NEW COMMAND
	>
	IFL	FTOPR,<
	JRST	BATOP2		;TRY AGAIN WITH THE OPERATOR
	>
	IFE	FTOPR,<
	JRST	OPTR3		;GO TO OPERATOR
	>
	IFLE	FTOPR,<
COMER4:	PUSHJ	P,RDCOM1	;READ THE REST OF LINE
	JRST	COMER2		;RETURN
COMER6:	CAIN	CH,";"		;IS IT SEMICOLON/
	PJRST	RDCOM1		;READ LINE AND RETURN
	POP	P,A		;UPDATE PUSHDOWN STACK.
	PJRST	COMERR		;IT IS ERROR
	>

;ROUTINE CHECKS IF THE CHARACTER IS A LF,VT,OR A FF

CONCHR:	CAIG	CH,FF		;IS IT A CONTROL CHARACTER?
	CAIGE	CH,LF
	POPJ	P,		;NOT A CONTROL CHARACTER
	JRST	CPOPJ1		;CONTROL CHARACTER.
	IFLE	FTOPR,<
;THIS ROUTINE CHECKS THE OPERATOR COMMAND AND ALL ISTS ABBREVIATIONS
;FOR UNIQUENESS AND DISPATCHES TO THE PROPER ROUTINE FOR PROCESSING.

DISPCH:	PUSHJ	P,MASK		;CREATE A  MASK.
	HRLZI	G,-COMSIZ	;MOVE NEG OF COM TABLE LENGTH
OPTR1:	MOVE	D,COMTAB(G)	;GET NEXT ENTRY IN COMMAND TABLE.
	ANDCM	D,E		;STRIP THE COMMAND IN D
	CAMN	D,COM		;DOES IT MATCH INPUT COMMAND.
	PUSHJ	P,OPTR2		;YES
	AOBJN	G,OPTR1		;NO GO GET NEXT ENTRY
	PUSHJ	P,COMACH	;CHECK IF COMMAND UNIQUE.
	PJRST	COMERR		;NO COMMAND ERROR.
	JRST	@DISP(A)	;O.K. GO SERVICE THE COMMAND.

DISPC1:	PUSHJ	P,MASK		;CREATE A MASK IN D.
	HRLZI	G,-ARGSIZ	;GET LENGTH OF ARG TABLE
DISPC2:	MOVE	D,ARGTAB(G)	;GET THE NEXT ENTRY
	ANDCM	D,E		;STRIP ARGUMENT IN D
	CAMN	D,COM		;DOES IT MATCH.
	PUSHJ	P,OPTR2		;YES
	AOBJN	G,DISPC2	;NO GET NEXT ENTRY.
	PUSHJ	P,COMACH	;CHECK IF ARG UNIQUE
	PJRST	COMERR		;NO. COMMAND ERROR.
	JRST	@DISP1(A)	;YES. SERVICE COMMAND.
	>

MASK:	SETZ	A,		;CLEAR AC A
	MOVE	D,COM		;COPY COMMAND IN D
	MOVNI	E,1		;MOVE ALL 1'S IN E
MASK1:	LSH	E,-6		;MOVE ONE CHARACTER RIGHT
	LSH	D,6		;MOVE ONE CHARACTER LEFT
	JUMPN	D,MASK1		;GENERATE A MASK IN D
	POPJ	P,		;RETUTN

COMACH:	HRRZ	D,A		;GET RIGHT HALF OF A
	CAIE	D,1		;IS IT ONE?
	POPJ	P,		;NO. COMMAND ERROR
	HLRZ	A,A		;YES CLEAR LEFT HALF OF A
	JRST	CPOPJ1		;SKIP RETURN

OPTR2:	AOS	A		;ADD ONE TO AC A
	HRL	A,G		;SAVE INDEX IN A
	POPJ	P,		;RETURN


	IFLE	FTOPR,<

;THIS ROUTINE FLUSHES THE OPERATOR COMMAND IN CASE TYPEDIN ERROR.

RDCOM:	PUSHJ	P,INCHR		;READ CHARACTER
RDCOM1:	PUSHJ	P,CONCHR	;IS IT CONTROL CHARACTER?
	CAIN	CH,33		;IS IT ALTMODE?
	POPJ	P,		;RETURN
	JRST	RDCOM		;READ THE NEXT CHARACTER?
	>
	IFLE	FTOPR,<
	IFN	REMSW,<

DISPC3:	PUSHJ	P,MASK		;CREATE A MASK
	HRLZI	G,-REMSIZ	;GET LENGTH OF THE ARGUMENT TABLE
DISPC4:	MOVE	D,REMARG(G)	;GET THE NEXT ENTRY
	ANDCM	D,E		;STRIP ARGUMENT IN D
	CAMN	D,COM		;DOES IT MATCH.
	PUSHJ	P,OPTR2		;YES
	AOBJN	G,DISPC4	;NO GET NEXT ENTRY
	PUSHJ	P,COMACH	;CHECK IF ARGUMENT UNIQUE
	PJRST	COMERR		;NO. COMMAND ERROR
	JRST	@DISPC5(A)	;DISPATCH


		>
	>

	IFLE	FTOPR,<
;COMMAND TABLE

COMTAB:	SIXBIT/HELP/
	SIXBIT/WHAT/
	SIXBIT/TELL/
	SIXBIT/OPERAT/
	SIXBIT/EXAMIN/
	SIXBIT/REQUEU/
	SIXBIT/STOP/
	SIXBIT/GO/
	SIXBIT/MONJOB/
	SIXBIT/KILL/
	SIXBIT/DSON/
	SIXBIT/DSOFF/
	SIXBIT/ZZZZZZ/
	SIXBIT/RESET/
	SIXBIT/START/
	SIXBIT/PAUSE/
	SIXBIT/MJOB/
	SIXBIT/MCORE/
	SIXBIT/CORE/
	SIXBIT/MTIME/
	SIXBIT/TIME/
	SIXBIT/CURREN/
	SIXBIT/MSGLEV/
	SIXBIT/EXIT/
	SIXBIT/SILENC/
	SIXBIT/REVIVE/
	SIXBIT/SET/
	SIXBIT/FIT/
	SIXBIT/FORCE/
	SIXBIT/DEFINE/
	SIXBIT/ALL/
	IFN	REMSW,<
	SIXBIT/REMON/
	SIXBIT/REMOFF/
		>
COMSIZ==.-COMTAB
	>

	IFLE	FTOPR,<
;KILL COMMAND ARGUMENT TABLE

ARGTAB:	SIXBIT/FLUSH/
	SIXBIT/ERROR/
	SIXBIT/NERROR/
ARGSIZ==.-ARGTAB

	IFN	REMSW,<
;REMALL COMMAND ARGUMENT TABLE

REMARG:	SIXBIT/ALL/
	SIXBIT/NONE/
REMSIZ==.-REMARG
	>


;ARGUMENTS OF SET COMMAND

SETARG:	SIXBIT/SLASH/
	SIXBIT/COMMA/
	SIXBIT/NOSWAP/
	SIXBIT/SWAPOK/
SETSIZ==.-SETARG
	>
	IFLE	FTOPR,<
;DISPATCH TABLE FOR OPERATOR COMMANDS.

DISP:	EXP	DHELP
	EXP	DWHAT
	EXP	DTELL
	EXP	DOPER
	EXP	DEXAM
	EXP	DREQU
	EXP	DSTOP
	EXP	DGO
	EXP	DMONJB
	EXP	DKILL
	EXP	DDON
	EXP	DDOFF
	EXP	DZZZ
	EXP	DRESET
	EXP	DSTRT
	EXP	DPAUSE
	EXP	DMXJOB
	EXP	DMCORE
	EXP	DCORE
	EXP	DMTIME
	EXP	DTIME
	EXP	DCURRE
	EXP	DMSGL
	EXP	DEXIT
	EXP	DSIL
	EXP	DREV
	EXP	DSET
	EXP	DFIT
	EXP	DFORCE
	EXP	DDFINE
	EXP	DALL
	IFN	REMSW,<
	EXP	DREMON
	EXP	DRMOFF
		>
	>


	IFLE	FTOPR,<
;DISPATCH TABLE FOR THE KILL COMMAND

DISP1:	EXP	DFLUSH
	EXP	DERROR
	EXP	DNEROR


	IFN	REMSW,<
DISPC5:	EXP	REMALL
	EXP	REMNON
		>


DISPC6:	EXP	DSLASH
	EXP	DCOMMA
	EXP	DNOSWP
	EXP	DSWPOK
	>
	IFLE	FTOPR,<
SUBTTLE STOP COMMAND
;HERE PROCESS THE OPERATOR STOP COMMAND. CHECK IF THE SUBJOB IS AT
;MONITOR OR CUSP LEVEL. IF AT CUSP LEVEL SEND ^C^C TO THE OBJECT JOB
;AND INDICATE THAT STOP WAS ISSUED BY THE OPERATOR IN THE LOG FILE.
;IF JOB IS AT MONITOR LEVEL, REMEMBER THIS FACT AND RETURN.
;IF OBJECT JOB IS A PRIVILEGED PROGRAM,REMEMBER THIS S0
;THAT STOP IS ISSUED AT THE COMPLETION OF THE PROGRAM.


DSTOP:	JSP	T1,CHKJOB	;CHECK JOB IF IN USE
	SETZ	T1,		;T1 SET TO -1 WHEN MESSAGE FOLLOWS STOP
	PUSHJ	P,CONCHR	;IS IT LF,VT,OR FF?
	PUSHJ	P,CMSG		;GO GET THE MESSAGE.
	TRNE	GF,ALLF		;IS ALL JOBS FLAG ON?
	JRST	STOP2		;YES GO PROCESS ALL ACTIVE JOBS.
	>
STOP1:	MOVE	C,JOBSB(B)	;GET THE JOB STATUS
	TLNE	C,JSTMON+JSTINP	;IS IT MON MODE AND WANTS INPUT.
	PJRST	STOP3		;YES
	TLNN	C,JSTMON	;IS IT MON MODE?
	TLNE	C,JSTAC		;NO. IS JACCT BIT SET?
	JRST	STOP4		;MON MODE WANTS TO OUTPU OR JACCT IS SET
	TRNE	F,F.END		;IS KJOB COMMAND BEEN ISSUED?
	POPJ	P,		;YES. RETURN
	PUSHJ	P,CTRC2		;SEND ^C^C TO OBJECT JOB
STOP5:	TLZE	F,F.DSTP	;IS DELAY STOP COM FLAG SET?IF SO RESET IT
	PUSHJ	P,STOPC		;YES. WRITE STOP COMMAND IN LOG FILE.
	PUSHJ	P,BACOM		;WRITE BACOM IN LOG FILE
	SKIPE	T1		;IS MESSAGE FLAG ON?
	PUSHJ	P,WRT		;YES. GO WRITE IT IN LOG FILE.
	PUSHJ	P,CRLFL		;SEND CRLF TO THE LOG FILE.
	TLON	F,F.CTRC	;SET FLAG JOB STOPPED AND UPDATE ATRCNT
	AOS	CTRCNT		;UPDATE COUNT OF JOBS STOPPED
	PJRST	STOP6		;SAVE FLAGS AND RETURN

STOP3:	TLO	F,F.SCNT	;SET SUPPRESS CONT FLAG .
	PJRST	STOP5
STOP4:	TLO	F,F.DSTP	;SET FLAG TO DELAY STOP COMMAND.
	PJRST	STOP6

	IFLE	FTOPR,<
STOP2:	ALLJOB(STOP1)


	>
STOPC:	MOVE	C,[SIXBIT/STOP/]	;GET STOP FOR LOG FILE.
	MOVEM	C,COM		;SAVE IT IN COM WORD
	POPJ	P,		;RETURN

	IFN	REMSW,<
SUBTTLE REMOTE OPERATOR COMMAND
	IFLE	FTOPR,<

;HERE PROCESS THE REMOTE STATION COMMAND REMON. IT HAS THREE ARGUMENTS
;(I) ALL- MEANS CENTRAL AND REMOTES. (II) NUMERICAL ARGUMENT 0-63
;(III) NONE- TURNS ALL OFF EXCEPT WHERE BATCON IS RUNNING FROM

DREMON:	PUSHJ	P,DSJOB		;CHECK DEFAULT JOB?
	PUSHJ	P,CONCHR	;IS IT LF FF ETC?
	SKIPA			;NO.
	PJRST	DRNUM1		;ASSUME C=0
	PUSHJ	P,SPPC		;GET A CHARACTER
	PUSHJ	P,ALPNUM	;IS IT ALPANUMERIC?
	JRST	DRNUM2		;NO. IF LF C=0 OK
	PUSHJ	P,SPERTR	;YES. IS IT ALPHABETIC?
	JRST	DRNUM		;NO. MAY BE A NUMBER
	PUSHJ	P,GETC1+1	;YES.
	PJRST	DISPC3		;GO DISPATCH


DRNUM:	SETZ	C,		;HERE WHEN NTMERAL
	PUSHJ	P,NUMOC2	;GET THE REST OF WORD
	JSP	T1,CHEK1	;IS LF ETC?
	CAIG	C,^D63		;IS IT WITHIN RANGE?
	JRST	DRNUM1		;YES
DRNUM3:	TYPE</? Argument error
/>
	POPJ	P,		;RETURN

DRNUM2:	PUSHJ	P,CONCHR	;IS IT LF FF ETC?
	JRST	COMERR		;COMMAND
DRNUM1:	IDIVI	C,^D36		;IS IT MULTIPLE OF 36?
	MOVEI	E,1		;GET A BIT.
	SUBI	D,^D35		;
	MOVMS	D		;ALWAYS POSITIVE
	LSH	E,(D)		;SHIFT IT
	IORM	E,REMTAB(C)	;SAVE IT
	POPJ	P,		;RETURN


;*************************************************************

;*********CODE ON NEXT PAGE IS UNDER REMSW SWITCH*************

;*************************************************************
;HERE IF REMON ALL COMMAND

REMALL:	JSP	T1,CHEK1	;CHECK IF LF FF ETC?
	>
REMAL1:	SETOM	REMTAB		;SET ALL STATIONS
	HRROI	T1,777400	;
	MOVEM	T1,REMTAB+1	;NEXT WORD
	POPJ	P,		;RETURN
	IFLE	FTOPR,<
;HERE IF RELMON NONE COMMAND.

REMNON:	JSP	T1,CHEK1	;CHECK IF LF,FF ETC.?
	SETZM	REMTAB		;CLEAR THE THE TABLE
	SETZM	REMTAB+1	;CLEAR NEST ENTRY
	SETO	C,		;TRY FIN WHO CONTROLS ME?
	CTLJOB	C,		;WHAT JOB#
	JFCL			;ERROR
	JUMPL	C,REMNO1	;IF C.LE.0 NOT A PTY
	HRLZS	C		;GET JOB IN LH
	HRRI	C,TTYTAB	;TTY VS JOB# CORRESPONDENCE
	GETTAB	C,		;GET IT
	JFCL			;IGNORE IT
REMNO2:	WHERE	C,		;C HAS TTY NUMBER
	PJRST	REMNO3		;ERROR
	PJRST	DRNUM1		;
REMNO1:	GETLIN	C,		;GET MY LINE#
	PJRST	REMNO2		;CONTINUE

REMNO3:	TYPE</? Where UUO failed
/>
	POPJ	P,		;RETURN
	>
	>
	IFN	REMSW,<
	IFLE	FTOPR,<

;HERE PROCESS THE REMOTE STATION COMMAND REMOFF. THE COMMAND
;HAS ONLY A NUMERIC ARGUMENT BETWEEN 0 AND 63.
DRMOFF:	PUSHJ	P,DSJOB		;CHECK DEFAULT JOB
	PUSHJ	P,CONCHR	;IS LF FF ETC?
	SKIPA			;NO
	PJRST	COMERR		;YES. IT IS ERROR
	PUSHJ	P,SPPC		;GET A NONSPACE CHARACTER
	SETZ	C,		;CLEAR THE AC C
	PUSHJ	P,NUMOC2	;OCTAL NUMBER
	JSP	T1,CHEK1	;CHECK DEFAULT JOB?
	CAILE	C,^D63		;WHAT STATION , NOT OVER 63.
	PJRST	DRNUM3		;ARGUMENT ERROR
	IDIVI	C,^D36		;IS IT MULTIPLE OF 36?
	MOVEI	E,1		;GET A BIT
	SUBI	D,^D35		;
	MOVMS	D		;ALWAYS POSITIVE
	LSH	E,(D)		;SHIFT IT
	ANDCAB	E,REMTAB(C)	;
	POPJ	P,		;RETURN

		>
	>
	IFLE	FTOPR,<
SUBTTLE GO COMMAND
;HERE ISSUE CONTINUE COMMAND TO THE JOBS THAT WERE STOPPED
;BY THE OPERATOR AND WERE AT CUSP LEVEL. CANCEL THE STOP COMMAND
;FOR THE PRIVILEGED OBJECT PROGRAMS IF STOP WASNOT PROCESSED
;TILL NOW.

DGO:	JSP	T1,CHKJOB	;CHECK JOB IF IN USE
	SETZ	T1,		;T1 SET TO -1 WHEN MESSAGE FOLLOWS GO.
	PUSHJ	P,CONCHR	;IS KIT LF,VT, OR FF?
	PUSHJ	P,CMSG		;NO. GO GET THE MESSAGE.
	TRNE	GF,ALLF		;IS ALL JOBS FLAG SET
	JRST	GO3		;YES GO PROCESS ALL JOBS.
GO1:	TLZN	F,F.DSTP	;RESET STOP COMMAND
	TLZN	F,F.CTRC	;IS JOB STOPPED?
	PJRST	PRET1		;SAVE FLAGS AND RETURN
	PUSHJ	P,BACOM		;WRITE TIME AND LABEL IN LOG FILE
	SKIPE	T1		;IS MESSAGE FLAG ON?
	PUSHJ	P,WRT		;YES. GO WRITE IT IN LOG FILE.
	PUSHJ	P,CRLFL		;SEND CRLF TO LOG FILE
	TLZE	F,F.SCNT	;IS SUPPRESS CONTINUE FLAG ON?
	JRST	GO4		;YES
	PUSHJ	P,GO2		;SEND CONTINUE COMMAND TO THE JOB
GO4:	MOVEM	F,FLAGS(B)	;SAVE THE FLAG WORD.
	SOS	CTRCNT		;SUBTRACT STOP COUNT.
	PUSHJ	P,CTRC3		;DO AN OUTPUT
	>
GO5:	MOVEI	T2,1		;FLAG FOR PTY
	MOVE	A,[INPUT ]
	PJRST	IOUUO		;EXECUTE THE UUO AND RETURN

	IFLE	FTOPR,<
GO3:	ALLJOB(GO1)
	>


GO2:	MOVEI	T2,[SIXBIT/CONTIN/]
	PUSHJ	P,SNDSIX	;SEND IT TO THE JOB
	PJRST	SNDCLF		;SEND<CR> TO THE JOB

	IFLE	FTOPR,<
SUBTTLE OPERATOR COMMAND -- OPERATOR
;HERE READ AND SEND A LINE TO THE SUBJOB.

DOPER:	JSP	T1,CHKJOB	;IS JOB IN USE?
	PUSHJ	P,CONCHR	;IS IT LF ETC.,?
	JRST	DOPER1		;NO. GO GET THE MESSAGE
	MOVSI	C,064240	;SAVE CR,LF IN TELLBK
	MOVEM	C,TELLBK	;SAVE IT
DOPER2:	TRNN	GF,ALLF		;IS ALL JOBS FLAG SET.
	PJRST	LOKLIN		;NO. PROCESS THIAS JOB.
	ALLJOB(LOKLIN)		;PROCESS ALL JOBS



DOPER3:	INCHWL	CH		;GET NEXT CHARACTER.
DOPER1:	CAIE	CH," "		;IS IT A SPACE?
	CAIN	CH,HT		;OR A TAB
	JRST	DOPER3		;YES. IGNORE IT
	PUSHJ	P,CMSG1		;GO SAVE THE LINE
	JRST	DOPER2		;PROCESS THE COMMAND.




LOKLIN:	TRZN	F2,F2.STP	;RESET WAITING FOR OPERATOR LINE.
	POPJ	P,		;RETURN
	PUSHJ	P,LOGFL1	;LOOKUP THE LOG FILE
	PUSHJ	P,CRLF1		;SEND <CR> TO THE LOG FILE
	PUSHJ	P,TIMLOG	;WRITE TIME STAMP
	PUSHJ	P,BAOPR2	;WRITE LABEL
	MOVE	T2,[POINT 7,TELLBK]
LOKLI1:	ILDB	CH,T2		;GET THE FIRST CHARACTER
	PUSHJ	P,SNDPTY	;SEND IT TO THE JOB
	PUSHJ	P,LOGFL		;SAVE IT IN LOG FILE
	PUSHJ	P,CONCHR	;IS IT LF?
	JRST	LOKLI1		;NO. GET NEXT CHARACTER
	TLZ	F,F.WOPR	;RESET WAIT FOR OPERATOR FLAG
	PUSHJ	P,CTRC3		;DO AN OUTPUT.
	PUSHJ	P,LOGFL2	;CLOSE FILE
	PJRST	STOP6		;SAVE FLAGS AND RETURN
	>
	IFLE	FTOPR,<
SUBTTLE TELL COMMAND
;C CONTAINS SUBJOB#. IF C IS ZERO LOCATION SUBJOB IS NOT ZERO. IF
;C IS ZERO AND LOCATION SUBJOB IS ZERO IT IS AN ERROR UNLESS ALLF
;FLAG IS SET.

DTELL:	JSP	T1,CHKJOB	;IS THE JOB IN USE?
	PUSHJ	P,CMSG1		;GO SAVE THE MESSAGE
	TRNN	GF,ALLF		;IS ALL JOBS FLAG SET?
	PJRST	LKMSG		;DO A LOOKUP AND ENTER MESSAGE.
TELL1:	ALLJOB(LKMSG)
	>

CMSG:	SETO	T1,
CMSG1:	SETZM	TELLBK
	MOVE	T2,[XWD TELLBK,TELLBK+1]
	BLT	T2,TELLBK+TELSIZ-1
	MOVE	T2,[POINT 7,TELLBK]
	SKIPA			;SKIP ALWAYS
WR1:	INCHWL	CH
	IDPB	CH,T2
	PUSHJ	P,CONCHR
	JRST	WR1
	POPJ	P,

WRT:	PUSHJ	P,MSG		;WRITE THE MESSAGE IN LOG FILE
	JRST	CPOPJ1		;GIVE A SKIP RETURN


;HERE SEND<CR> TO OBJECT JOB

SNDCLF:	MOVEI	CH,CR		;SEND CR TO OBJECT JOB
	PUSHJ	P,SNDPTY	;SEND IT TO THE JOB
	MOVEI	CH,LF		;GET LF
	PUSHJ	P,SNDPTY	;SEND IT TO OBJECT JOB
	TLO	F,F.LF		;SET LF FLAG SEEN FLAG
	PJRST	STOP6		;SAVE FLAGS ANE RETURN



;THIS ROUTINE WRITES TIME AND A LABEL IN THE LOG FILE.

BACOM:	PUSHJ	P,LOGFL1	;LOOKUP LOG FILE
	PUSHJ	P,CRLF1		;WRITE CRLF IN LOG FILE
	PUSHJ	P,TIMLOG	;WRITE TIME LABEL IN LOG FILE.
	PUSHJ	P,BAOPR2	;WRITE BAOPR IN LOG FILE.
	MOVEI	T2,COM
	PJRST	BAOPR1		;WRITE COMMAND IN LOG FILE

;WRITE <CR> IN LOG FILE AND CLOSE THE FILE

CRLFL:	PUSHJ	P,CRLF1		;WRITE CRLF IN LOG FILE
	PJRST	LOGFL2		;CLOSE THE LOG FILE


;WRITE <CR> IN THE LOG FILE

CRLF1:	MOVEI	CH,CR		;WRITE CR
	PUSHJ	P,LOGFL		;WRITE IT IN LOG FILE
CRLF2:	MOVEI	CH,LF		;GET LF.
	TLO	F,F.LF		;LF SEEN FLAG.
	PJRST	LOGFL		;WRITE IT IN LOG FILE



	IFLE	FTOPR,<
SUBTTLE CURRET COMMAND
;HERE TYPEOUT CURRENT SUBJOB#,#OF STREAMS,#JOBS IN USE

DCURRE:	JSP	T1,CHKLFE	;CHECK LF ETC AND RETURN
	OUTSTR	[ASCIZ/Core:/]
	MOVE	JB,AJCOR	;GET TOTAL BATCH CORE IN K
	PUSHJ	P,JOBTY1	;TYPEOUT
	OUTSTR	[ASCIZ/;Mcore:/]
	MOVE	JB,JCORMX	;GET PER JOB CORE
	PUSHJ	P,JOBTY1	;TYPEOUT
	OUTSTR	[ASCIZ/;Time:/]
	MOVE	JB,ATIMX	;GET TOTAL BATCH TIME
	PUSHJ	P,LONGTM	;TYPEOUT
	OUTSTR	[ASCIZ/;Mtime:/]
	MOVE	JB,JTIMX	;TIME PER JOB
	PUSHJ	P,LONGTM	;TYPEOUT IT
	OUTSTR	[ASCIZ/;Zzz:/]
	HRRZ	JB,SLPTM	;GET THE SLEEP TIME
	PUSHJ	P,JOBTY1	;TYPEOUT
	SKIPGE	SLPTM		;IS SWPNOW BIT ON?
	OUTSTR	[ASCIZ/;Swpnow/]
	PUSHJ	P,CRLF		;START NEW LINE
	HRLZI	C,-QUESIZ	;GET THE LEGAL QUEUE LENGTH
CURRN5:	MOVE	E,LEGQUE(C)	;GET THE FIRST LEGAL QUEUE
	SETZ	T1,		;SET A FLAG
	MOVN	A,MAXSTM	;GET NEGATIVE OF TOTAL STREAMS
	HRLZS	A		;SETUP THE INDEX
	HLLZ	D,QUETAB(A)	;GET THE QUEUE NAME
	CAMN	E,D		;DOES IT MATCH?
	PUSHJ	P,CURRN3	;TYPEOUT THE LINE
	AOBJN	A,.-3		;CHECK NEXT STREAM
	AOBJN	C,CURRN5	;GET NEXT LEGAL STREAM
	PUSHJ	P,CRLF		;SEND NEXT LINE
	TRNE	GF,SCHRS	;ARE WE CHANGING JOB STREAMS?
	PUSHJ	P,CURRN6	;YES. SAY SO TO OPERATOR.
	TRNN	GF,ALLF		;IS ALL JOBS FLAG SET?
	PUSHJ	P,CURRN1	;NO.
	OUTSTR	[ASCIZ/All/]	;YES
	OUTSTR	[ASCIZ/ of /]	;TYPEOUT
	MOVE	JB,MAXSTM	;GET THE #OF STREAMS
	PUSHJ	P,JOBTY1	;GET THE #OF STREAMS
	MOVEI	CH,","		;GET COMMA
	OUTCHR	CH		;WRITE IT OUT
	SKIPE	JB,JBSACT	;GET THE #OF ACTIVE JOBS
	PUSHJ	P,CURRN2	;TYPEOUT
	>
DCURR1:	OUTSTR	[ASCIZ/No/]
	OUTSTR	[ASCIZ/ Streams in use/]
	PJRST	CRLF		;TERMINATE
	IFLE	FTOPR,<
CURRN1:	MOVE	JB,SUBJOB	;GET THE CURRENT SUBJOB#
CURRN2:	PUSHJ	P,JOBTY1	;TYPEOUT JOB#
	JRST	CPOPJ1		;SKIP RETURN

CURRN3:	SKIPE	T1		;IS IT THE FIRST TIME?
	JRST	CURRN4		;NO.
	MOVE	T2,[POINT 6,E]	;SETUP THE POINTER
	PUSHJ	P,TTY		;WRITE IT ON TTY
	MOVEI	CH,"="		;GET = SIGN
	OUTCHR	CH		;OUTPUT IT
	SETO	T1,		;SET THE FLAG
CURRN4:	MOVEI	JB,1(A)		;GET THE STREAM#
	PUSHJ	P,JOBTY1	;TYPEOUT STREAM#
	MOVEI	CH,","		;TYPEOUT COMMA
	OUTCHR	CH		;TYPE IT
	POPJ	P,		;RETURN



;HERE TYPEOUT TIME DEFAULTS OR INFINITE

LONGTM:	CAMN	JB,[377777,,777777]
	JRST	[  OUTSTR [ASCIZ/+Inf/]
		POPJ P,
			]
	PJRST	JOBTY1		;NO. TYPEOUT ACTUAL NUMBER


CURRN6:	OUTSTR	[ASCIZ/SYSTEM WILL CHANGE TO /]
	MOVE	JB,SJBLMT	;GET THE NEW LIMIT
	PUSHJ	P,JOBTY1	;TYPEOUT TO THE OPERATOR
	OUTSTR	[ASCIZ/ STREAMS/]
	PJRST	CRLF		;WRITE CRLF

	>
	IFLE	FTOPR,<
;HERE PROCESS THE MESSAGE LEVEL COMMAND. DEFAULT TYPES ALL.

DMSGL:	JSP	T1,CHEK		;CHECK SUBJOB# AND ARGUMENTS
	JUMPE	C,DMSG1		;ZERO IS O.K.,MEANS LITTLE OUTPUT
	CAIE	C,1		;IS IT EQUAL TO 1?
	PJRST	COMERR		;COMMAND ERROR
	TRZA	GF,MSGL		;TURN OFF TO DEFAULT
DMSG1:	TRO	GF,MSGL		;CUT THE WHAT COUTPUT
	POPJ	P,		;RETURN


LKMSG:	PUSHJ	P,LOGFL1	;GO LOOKUP THE LOG FILE.
	PUSHJ	P,CRLF1		;WRITE CRLF IN LOG FILE.
	PUSHJ	P,TIMLOG	;WRITE TIME FOLLOWED BY SPACE.
	PUSHJ	P,BAOPR2	;GO WRITE BAOPR MESSAGE
	>
MSG:	MOVE	T2,[POINT 7,TELLBK]
MSG1:	ILDB	CH,T2		;DEPOSIT THE CHARACTERS IN LOG FILE.
	PUSHJ	P,LOGFL
	PUSHJ	P,CONCHR	;IS IT LF ETC?
	JRST	MSG1		;GO GET NEXT CHARACTER.
	PJRST	LOGFL2		;ENTER LOG FILE AND RETURN


	IFLE	FTOPR,<
SUBTTLE CHECK SUBJOB VALIDITY
;HERE CHECK VALIDITY OF TYPEDIN SUBJOB IN AC C.RETURN WITH SUBJOB
;IN LOCATION SUBJOB.
;	PUSHJ P,CHKSJB
;	(ERROR RETURN)
;	(NORMAL RETURN)

CHKSJB:	JUMPE	C,CHKSJ1	;IS TYPEDIN SUBJOB ZERO?
	MOVEM	C,SUBJOB	;SAVE SUBJOB IN LOCATION SUBJOB.
	TRZ	GF,ALLF		;TURN OFF ALL JOBS FLAG
	JRST	CPOPJ1		;SKIP RETURN
CHKSJ1:	TRNE	GF,ALLF		;IS ALL JOBS FLAG ON?
	JRST	CPOPJ1		;YES. SKIP RETURN
	SKIPE	C,SUBJOB	;IS DEFAULT SUBJOB ZERO.?
	CAMLE	C,MAXSTM	;IS IT WITHIN MAX STREAMS?
	POPJ	P,		;NO. ERROR RETURN
	JRST	CPOPJ1		;SKIP RETURN
	>


	IFLE	FTOPR,<
;HERE CHECK IF THE GIVEN SUBJOB IS ACTIVE.
;	PUSHJ P,ACTV1
;	(ERROR RETURN)
;	(NORMAL RETURN)


ACTV1:	TRNE	GF,ALLF		;IS ALL JOBS FLAG SET?
	JRST	ACTV2		;YES. CLEAR INCORE JOB AND RETURN
	MOVE	JB,SUBJOB	;GET SUBJOB #
	MOVEI	B,-1(JB)	;COMPUTE INDEXING ADDRESS FOR SUBJOB.
	IMULI	B,SIZE		;MULTIPLY DATA SIZE
	MOVE	F2,FLAG2(B)	;GET SECOND FLAG WORD.
	MOVE	F,FLAGS(B)	;GET THE FLAGS FOR THE JOB.
	TRNN	F,F.ACTV	;IS THE JOB IN USE?
	POPJ	P,		;JOB NOT ACTIVE?
	CAME	JB,INCORE	;IS THE JOB IN CORE?
ACTV2:	SETZM	INCORE		;CLEAR INCORE JOB
	JRST	CPOPJ1		;SKIP RETUEN


JNACTV:	PUSHJ	P,CONCHR	;IS IT LF,VT OR FF?
	PUSHJ	P,RDCOM1	;READ REST OF THE COMMAND.
JNACT1:	TYPDSK</? Job not active
/>				;RETURN TO OPTR
	JRST	COMER2


	PUSHJ	P,CRLF1		;WRITE CRLF IN LOG FILE
	>
BAOPR2:	MOVEI	T2,[SIXBIT/BAOPR /]
BAOPR1:	PUSHJ	P,BAOPR3	;WRITE IT IN LOG FILE
	PJRST	TIM7LG		;WRITE A SPACE AND RETURN



BAOPR3:	HRLI	T2,440600	;SETUP BYTE POINTER
BAOPR:	ILDB	CH,T2		;GET A CHARACTER
	ADDI	CH,40		;CONVERT TO ASCII
	PUSHJ	P,LOGFL		;SAVE IT IN LOG FILE
	PUSHJ	P,DSKLOG	;SAVE IT IN DSK LOG.
	TLNE	T2,770000	;TEST IF ALL CHARACTERS READ.
	JRST	BAOPR		;NO. GET NEXT CHARACTER.
	POPJ	P,		;RETURN


SUBTTLE WRITE TIME STAMP IN LOG FILE
;HERE ENTER TIME OF DAY AND  PREFIX IN THE LOG FILE.


TIMLOG:	TLO	F,F.TAB		;FORCE A CONTROL CHARACTER SEEN FLAG.
	IFN	DEBUG,<
REPEAT 0,<
	MOVE	C,JB		;GET SUBJOB#
	PUSHJ	P,TIM2LG	;WRITE SPACE IN LOG FILE
	MOVEI	C,HT		;GET A TAB
	PUSHJ	P,TIM6LG	;SEND IT TO LOG FILE
	>
	>

	MSTIME	C,		;GET TIME OF DAY
TIM9LG:	IDIVI	C,^D60000	;C HAS MINUTES, D HAS SECONDS.
	PUSH	P,D		;SAVE MILLISECONDS
	IDIVI	C,^D60		;C HAS HOURS, D HAS MINUTES
	PUSH	P,D		;SAVE MINUTES
	PUSHJ	P,TIM5LG	;WRITE LOG FILE HRS FOLLOWED BY :
	POP	P,C		;GET MINUTES
	PUSHJ	P,TIM5LG	;WRITE LOG FILE MINUTES FOLLOWED BY :
	POP	P,C		;GET MILLISECONDS
	IDIVI	C,^D1000	;GET SECONDS
TIM8LG:	PUSHJ	P,TIM2LG	;WRITE LOG FILE SECONDS
TIM7LG:	MOVEI	C," "		;GET SPACE
	PJRST  TIM6LG		;WRITE SPACE AND RETURN


TIM5LG:	PUSHJ	P,TIM2LG	;WRITE THE LOG FILE
	MOVEI	C,":"		;WRITE A COLON
	PJRST	TIM6LG		;WRITE LOG FILE
TIM2LG:	CAIGE	C,^D10		;IS IT GREATER THAN 10?
	JRST	TIM3LG		;NO. ONLY ONE DIGIT.
	IDIVI	C,^D10		;YES. TWO DIGITS.
	PUSH	P,D		;SAVE TRAILING DIGIT.
	PUSHJ	P,TIM4LG	;WRITE LOG FILE.
	POP	P,C		;GET TRAILING DIGIT
	JRST	TIM4LG		;WRITE LOG FILE.
TIM3LG:	MOVEI	D,"0"		;SUPPLY LEADING ZERO.
	IDPB	D,LOGPTR(B)	;DEPOSIT IN LOG FILE
	PUSHJ	P,DSKLOG	;WRITE DSK LOG FILE
	PUSH	P,C		;SAVE AC C
	PUSHJ	P,LOGFL3	;UPDATE CHARACTER COUNT
	POP	P,C		;RESTORE C
TIM4LG:	ADDI	C,60		;CONVERT TO ASCII.
TIM6LG:	IDPB	C,LOGPTR(B)	;WRITE LOG FILE
	PUSHJ	P,DSKLOG	;WRITE DSK LOG
	PJRST	LOGFL3		;UPDATE CHARACTER COUNT AND RETURN.
	IFLE	FTOPR,<
SUBTTLE OTHER OPERATOR COMMANDS
DRESET:	JSP	T1,CHKLFE	;CHECK LF ETC AND RETURN
	TRO	GF,FRESET	;SET RESET FLAG. RESET STOPS BATCH
	>
RESET1:	SKIPN	JBSACT		;ARE THERE ANY ACTIVE JOBS?
	JRST	[  ANDI GF,START
		TRO GF,INITIL
		JRST START5	;GO TO BEGINNING
			]
	PJRST	RESET2		;STOP SCHEDULING

	IFLE	FTOPR,<
DPAUSE:	JSP	T1,CHEK1	;IS LF ETC?
	TRO	GF,PREVAL	;SETUP NO NEW JOBS TO BE SCHEDULED FLAG
	TRZ	GF,ASTRK	;TYPEOUT ASTRISK
	PUSHJ	P,DSJOB		;CHECK FOR DEFAULT SUBJOB# AND RETURN
	PJRST	START3		;GO DEMAND AN INPUT


DSTRT:	JSP	T1,CHEK1	;CHECK LF ETC?
	TRZ	GF,PRESET	;SCHDULE JOBS FOR BATCH
	TRO	GF,ASTRK	;TYPEOUT EXCALAMATION
	PJRST	DSJOB		;CHECK FOR SUBJOB# AND RETURN
	

DZZZ:	JSP	T1,CHEK		;CHECK DEFAULT SUBJOB# AND GET COM. ARG
	MOVEM	C,SLPTM		;SAVE SLEEP TIME
	POPJ	P,		;RETURN TO CONTINUE THE JOB.



DDON:	TROA	GF,DSPLY	;SET DISPLAY STATUS BIT ON.
DDOFF:	TRZ	GF,DSPLY	;TURN THE DISPLAY OFF
DSJOB:	PUSHJ	P,CHKSJB	;GO CHECK THE SUBJOB#
	JFCL
	POPJ	P,		;RETURN

CHKLFE:	PUSHJ	P,CONCHR	;IS IT LF,VT,OR FF?
	PUSHJ	P,COMER6	;NO.
	PUSHJ	P,DSJOB		;CHECK FOR DEFAULT SUBJOB#.
	JRST	@T1		;RETURN
	>
	IFLE	FTOPR,<
SUBTTLE SILENCE-REVIVE COMMNAD
;HERE SETUP THE TYPEOUT FOR ALL TTY ACTIVITY ON THE CONTROL
;TERMINAL. INITIALLY ALL IS QUITE. BL-REVIVE STARTS TYPINGOUT
;ALL THE ACTIVITY OF SUBJOB L AND SHUTS OFF ALL OTHERS. ONLY ONE
;JOB IS ALLOWED TO TYPEOUT AT ANYTIME.

DREV:	JSP	T1,CHKLFE	;CHECK LF FF ETC?
	PUSHJ	P,ACTV1		;IS THE JOB ACTIVE?
	JRST	DREV1		;NO. MARK IT ANYWAY
	TRNE	GF,ALLF		;IS ALL JOBS FLAG ON?
	PJRST	TTYERR		;YES.
	TLO	F,F.TTY		;SET OUTPUT ON TERMINAL FLAG.
	MOVEM	F,FLAGS(B)	;SAVE THE FLAG
DREV1:	MOVEM	B,TTYIND	;SAVE DATA INFORMATION
	POPJ	P,		;RETURN


TTYERR:	TYPE</? Subjob# must be specified
/>
	POPJ	P,



;HERE SET FLAG TO SILENCE ALL THE OUTPUT ON THE CONTROLLING
;TERMINAL RELATED TO THE SUBJOB L. AFTER THIS COMMAND NO OUTPUT FROM ANY
;SUBJOB APPEARS ON THE TERMINAL. TO START TYPEOUT AGAIN REVIVE
;COMMAND MUST BE ISSUED.


DSIL:	JSP	T1,CHKLFE	;IS IT LF FF ETC?
	SKIPGE	B,TTYIND	;IS IT A NEGATIVE NUMBER?
	POPJ	P,		;YES. SILENCE IS ALREADY SET.
	MOVE	F,FLAGS(B)	;GET FLAG WORD THAT NEEDS TO BE RESET
	TLZ	F,F.TTY		;RESET THE JOB FLAG
	SETOM	TTYIND		;SET SILENCE
	PJRST	STOP6		;SAVE FLAG AND RETURN


CHKJOB:	PUSHJ	P,CHKSJB	;CHECK THE VALIDITY OF THE JOB?
	PJRST	COMERR		;COMMAND ERROR.
	PUSHJ	P,ACTV1		;NO. IS THIS JOB IN USE?
	PJRST	JNACTV		;ERROR RETURN. JOB NOT INUSE.
	JRST	@T1		;RETURN
	>
	IFLE	FTOPR,<
SUBTTLE EXIT,MCORE,-- OTHER OPERATOR COMMANDS
DEXIT:	JSP	T1,CHKLFE	;IS IT LF FF ETC?
	TRO	GF,EXITB	;SET EXIT FLAG
	>
DEXIT1:	SKIPN	JBSACT		;ARE THERE ANY ACTIVE JOBS?
	TRZA	GF,NOSCH+EXITB	;RESET FLAGS AND EXIT.
RESET2:	TROA	GF,NOSCH	;NO. DO NOT LET NEW JOBS TO SCHEDUHE.
	EXIT	A,		;GO EXIT
	POPJ	P,		;RETURN


	IFLE	FTOPR,<
;HERE ACCEPT MAXIMUM COR LIMIT FOR EACH JOB

DMCORE:	JSP	T1,CHEK		;CHECK DEFAULT SUBJOB# AND GET ARG.
	JUMPE	C,COMERR	;ZERO ARGUMENT NOT ACCEPTABLE
	MOVEM	C,JCORMX	;SAVE IT IN JCORMAX
	POPJ	P,		;RETURN

;HERE ACCEPT MAXIMUM CORE LIMIT FOR ALL JOBS

DCORE:	JSP	T1,CHEK		;CHECK SUBJOB# AND GET ARG
	JUMPE	C,COMERR	;ZERO ARG NOT ACCEPTABLE
	MOVEM	C,AJCOR		;CORE FOR ALL JOBS
	POPJ	P,		;RETURN

;HERE ACCEPT MAXIMUM CP TIME FOR EACH JOB

DMTIME:	JSP	T1,CHEK		;CHECK SUBJOB# AND GET ARG
	JUMPE	C,COMERR	;ZERO NOT ACCEPTABLE
	MOVEM	C,JTIMX		;SAVE MAX ALL TIME FOR JOB
	POPJ	P,		;RETURN

;HERE ACCEPT THE MAXIMUM CP TIME FOR ALL JOBS.

DTIME:	JSP	T1,CHEK		;CHECK FOR DEFAULT AND GET ARG.
	JUMPE	C,COMERR	;ZERO UNACCETABLE
	MOVEM	C,ATIMX		;SAVE TOTAL TIME
	POPJ	P,		;RETURN

CHEK:	PUSHJ	P,DSJOB		;CHECK DEFAULT SUBJOB# 
	PUSHJ	P,CONCHR	;IS IT LF,VT,FF ETC.,?
	SKIPA			;NO. OK
	PJRST	COMERR		;YES. COMMAND ERROR
	PUSHJ	P,NUMBR		;GET COMMAND ARGUMENT.
CHEK1:	PUSHJ	P,CONCHR	;IS IT LF,VT,FF?
	PUSHJ	P,COMER6	;COMMAND ERROR
	JRSTF	@T1		;RETURN
	>

	IFLE	FTOPR,<
SUBTTLE MJOB COMMAND
DMXJOB:	PUSHJ	P,DSJOB		;CHECK FOR DEFAULT SUBJOB#
	PUSHJ	P,CONCHR	;IS IT LF,VT,FF?
	SKIPA			;NO. OK
	PJRST	COMERR		;YES. COMMAND ERROR
	PUSHJ	P,NUMBR		;GET COMMAND ARGUMENT
	JSP	T1,CHEK1	;CHECK IF LF FF ETC?
	JUMPE	C,COMERR	;ARGUMENT ZERO COMMAND ERROR
	CAIG	C,JOBMAX	;ARGUMENT MUST NOT BE GREATER THAN 14.
	PJRST	DMXJB1		;GO PROCESS THE COMMAND.
	TYPE</? Mjob exceeds />
	MOVEI	JB,JOBMAX	;GET THE CURRENT STREAM NUMBER
	PUSHJ	P,JOBTY1	;TYPE IT
	PJRST	CRLF		;SEND CRLF
	>


	IFLE	FTOPR,<
SUBTTLE CHECK MJOB COMMAND

CHGSTM:	MOVE	C,SJBLMT	;GET THE NEW LIMIT?
DMXJB1:	CAMG	C,MAXSTM	;IS HE INCREASING OR DECREASING LIMIT?
	JRST	DMXJB2		;DECREASING
	PUSHJ	P,INCSTM	;INCREASE #OF STREAMS
	EXCH	A,MAXSTM	;UPDATE MAXSTM,SAVE OLD LIMIT
	>
	IFL	FTOPR,<
	MOVEM	A,FITJOB	;SAVE IT
	POPJ	P,		;RETURN
	>
	IFGE	FTOPR,<
	MOVEI	B,(A)		;OLD LIMIT LESS ONE IN B
	IMULI	B,SIZE		;COMPUTE CORE SIZE
	MOVE	C,MAXSTM	;GET NEW MAX STREAMS
DMXJB6:	PUSH	P,A		;SAVE AC A
	PUSHJ	P,INIT2		;INITIALIZE NEW JOB
	POP	P,A		;RESTORE AC A
	ADDI	B,SIZE
	CAIGE	A,-1(C)		;HAVE WE INITIALIZED ALL JOBS?
	AOJA	A,DMXJB6
	PJRST	DMXJ1+1		;UPDATE BUFTAB


	>
	IFLE	FTOPR,<
SUBTTLE RELEASE CORE

DMXJB3:	SKIPA	G,.JBFF		;GET .JBFF
DMXJ10:	HRRM	G,.JBFF		;UPDATE JOBFF
TEMP:	CORE	G,		;GRAB MORE CORE
	JRST	[  MOVEI D,1	;SLEEP TILL CORE AVAILABLE
		SLEEP D,	;
		JRST DMXJB3	;GO TRY THE CORE AGAIN
			]
	MOVE	G,.JBFF		;UPDATE FREE CORE LOCATION
	JRST	@BUF


	>
	IFLE	FTOPR,<

	SUBTTLE	UPDATE POINTERS
;HERE UPDATE CTLPTR,LOGPTR,AND BKCPTR

CHKPTR:	HRRZ	D,SLWSRM	;START OF BUFFERS
CHKPT3:	MOVEI	A,(T2)		;
	IMULI	A,SIZE		;DATA REFERENCE
	HRLZI	C,-PTRCNT	;SETUP FOR AOBJN
	MOVEI	T1,CTLPTR(A)	;GET THE FIRST POINTER
CHKPT1:	HRRZ	BUF,(T1)	;
	JUMPE	BUF,CHKPT2	;
	SUB	BUF,D		;
	ADDI	BUF,(E)		;
	HRRM	BUF,(T1)	;
CHKPT2:	AOS	T1
	AOBJN	C,CHKPT1	;
	POPJ	P,		;


		>
	IFLE	FTOPR,<
SUBTTLE DECREASE MJOB STREAMS
DMXJB2:	CAML	C,MAXSTM	;IS JMAX BEING CHANGED AT ALL?
	JRST	DMXJ2		;NO. OK RETURN
	SETZM	INCORE		;RESET INCORE JOB WORD
	MOVEI	A,1(C)		;GET THE NEW STREAM COUNT.
DMXJB0:	SKIPE	PTYTAB-1(A)	;IS IT IN USE?
	JRST	DMXJB5		;YES. CHECK IF WE CAN USE THIS SLOT
	CAMGE	A,MAXSTM	;NO. CHECK THE REST
	AOJA	A,DMXJB0	;

	PUSH	P,C		;SAVE NEW STREAM COUNT.
	PUSH	P,MAXSTM	;SAVE THE OLD STREAMS
	MOVEM	C,MAXSTM	;SAVE NEW JOB STREAM COUNT.
	MOVE	T1,SLWSRM	;SAVE IT TEMPORARILY
	PUSHJ	P,SLWFST	;HOW MANY SWAP/INCORE TYPES?
	JFCL

	MOVEI	G,SIZE		;DATA AREA PER JOB
	IMUL	G,-1(P)		;TOTAL DTA AREA =NEW*SIZE
	ADDI	G,FIRDTA	;ABSOLUTE AREA=FIRDTA+NEW*SIZE
	MOVEM	G,D		;SAVE IT     D=
	HLRO	E,COMTB		;GET NEGATIVE LENGTH OF COMMAND TABLE
	MOVNS	E		;POSITIVE LENGTH
	ADDI	G,(E)		;END OF COMMAND TABLE G=FIRDTA+NEW*SIZE+COMTB
	MOVEM	G,E		;SAVE IT TEMPORARILY


	HLRZ	G,T1		;GET OLD SWAP STREAMS
	SUB	G,(P)		;NEGATIVE OF INCORE TYPES.
	MOVNS	G		;OLD INCORE TYPES.
	CAML	C,G		;FIND THE SMALLER OF THE INCORE TYPES
	SKIP	C,G		;SMALLER IN AC C
	PUSH	P,C		;SAVE AC C
	IMULI	C,FSTBUF	;SMALLER OF TWO STREAMS
	ADDI	C,(E)		;AC E=FIRDTA+NEW*SIZE+COMTB+BUFFERS
	MOVEI	G,SIZE		;GET THE SIZE OF JOB DATA AREA
	IMUL	G,-1(P)		;COMPUTE IT FOR OLD STREAMS
	HRLZI	G,FIRDTA(G)	;SETUP FOR BLT POINTER
	HRR	G,D		;WHERE TO TRANSFER
	BLT	G,(C)		;OK NOW TRANSFER
	HRRM	D,COMTB		;UPDATE START OF COMMAND TABLE

	POP	P,T2		;RESTORE AC C
	JUMPE	T2,A5		;SKIP IF ZERO
	MOVNS	T2		;SETUP AOBJN POINTER
	HRLZS	T2		;
	SKIPE	PTYTAB(T2)	;IS THE JOB INUSE?
	PUSHJ	P,CHKPTR	;YES. UPDATE VARIOUS POINTERS
	AOBJN	T2,.-2		;GOTO TO THE NEXT JOB
A5:	HRRM	E,SLWSRM	;


	PUSH	P,E		;SAVE AC E
	PUSHJ	P,SLWFST	;HOW MANY INCORE/SWAP TYPES.
	JFCL			;
	POP	P,E		;RESTORE AC E
	MOVEI	G,(C)		;GET THE CURRENT INCORE TYPES.
	IMULI	G,FSTBUF	;BUFFER SIZE
	ADDI	G,(E)		;TOP OF CORE
	JSP	BUF,DMXJ10	;GET CORE IF NEEDED


	MOVEI	JB,1		;START WITH FIRST JOB
	SETZ	B,		;DATA AREA
A1:	SKIPN	PTYTAB-1(JB)	;IS THE JOB INUSE?
	JRST	A2		;NO. TRY NEXT JOB
	MOVE	F,FLAGS(B)	;GET THE FLAGS
	MOVE	F2,FLAG2(B)	;...
	CAIG	JB,(C)		;IS IT INCORE TYPE?
	TRC	F2,F2.FST	;YES. DOES IT MATCH?
	TRNE	F2,F2.FST	;
	PUSHJ	P,A3		;GO UPDATE BUFFERS ETC
A2:	ADDI	B,SIZE		;
	CAMGE	JB,-1(P)	;OVER THE LIMIT
	AOJA	JB,A1		;..
	POP	P,MAXSTM	;
	POP	P,A		;
		>
DMXJ1:	MOVEM	A,MAXSTM		;UPDATE TOTAL STREAM COUNT
	PUSHJ	P,SLWFST	;COMPUTE TYPE OF STREAMS
	JFCL			;IGNORE NORMAL RETURN
	HRLM	A,SLWSRM	;SAVE IT
	TRZ	GF,SCHRS	;RESET RESTRICT SCHED FLAG
	IFG	FTOPR,<

	SETZM	FITJOB		;CLEAR THE INITIALIZING WORD

	>
	PJRST	PIKS11		;UPDATE BUFTAB AND RETURN

	IFLE	FTOPR,<

DMXJB5:	MOVEI	JB,1		;START AT THE BEGINNING
	SETZ	B,		;...
	MOVE	E,JBSACT	;GET JOBS IN USE
DMXJ11:	SKIPN	PTYTAB-1(JB)	;IS JOB INUSE?
	PUSHJ	P,CHKMOR	;GO CHECK SOME MORE
	ADDI	B,SIZE		;NEXT JOB AREA
	CAMGE	JB,MAXSTM	;OVER THE TOTAL
	AOJA	JB,DMXJ11	;NO.
;MORE ACTIVE JOBS THAN NEW JMAX LIMIT

DMXJB8:	MOVEM	C,SJBLMT	;RESTRICT ALL SUBJOBS ABOVE SJBLMT
	TROA	GF,SCHRS	;SETUP FLAG TO RESTRICT SCHEDULING
DMXJ2:	TRZ	GF,SCHRS	;RESET RESTRICT SCHEDULING FLAG
	POPJ	P,		;RETURN

CHKMOR:	MOVEI	G,1		;
	CAMLE	JB,C		;NEW SUBJOB OVER LIMIT?
	JRST	.+3		;CANNOT SCHEDULE
	AOS	E		;MARK IT INUSE
	CAMLE	E,C		;ARE WE OVER THE LIMIT?
	IORM	G,QUETAB-1(JB)	;MARK IT NOT TO BE USED.
	POPJ	P,		;RETURN

A3:	MOVEI	E,-1(JB)	;GET THE JOB#
	IMULI	E,FSTBUF	;SPACE FOR BUFFERS
	HRRZ	D,SLWSRM	;GET THE START OF BUFFERS
	ADDI	E,(D)		;SAVE IT
	HRRZI	D,PTYCTL	;REFERENCE FOR SWAP TYPE
	MOVE	A,B		;DATA REFERENCE
	PUSHJ	P,CHKPT1-2	;UPDATE POINTERS
	SOS	E		; FOR THE BUFTAB.
	HRRM	E,BUFTAB(JB)	;CONTROL FILE
	ADDI	E,FSTBUF/2	;
	HRLM	E,BUFTAB(JB)	;LOG FILE
	PUSHJ	P,LOKCTL+3	;GET THE CTL FILE IN CORE
	PJRST	FRBLK		;INITIALIZE CHANNEL AND RETURN


	>
	IFLE	FTOPR,<
SUBTTLE INCREASE MJOB

;HERE INCREASE THE TOTAL NUMBER OF STREAMS. THIS INVOLVES CHANGING
;INCORE TYPES INTO SWAP TYPES IF NEED BE. IF INCORE TYPE
;IS CHNAGED TO SWAP TYPE THEN OUTPUT THE LAST BLOCK INCORE AND
;CLEAR CTL,LOG CHANNELS IN QUETAB. CLEAR CORRESPONDING ENTRIES IN 
; BUFTAB AS WELL. 
;BESIDES MOVE COMMAND TABLE TO APPROPRIATE PLACE IN CORE AND
;UPDATE CTLPTR ETC.

;CALLING SEQUENCE
;	PUSHJ P,INCSTM
;	RETURN

INCSTM:	SETZM	INCORE		;RESET INCORE JOB WORD
	PUSH	P,C		;SAVE TOTAL STREAM COUNT
	PUSH	P,MAXSTM	;SAVE OLD STREAM COUNT
	MOVE	T1,SLWSRM	;SAVE IT TEMPORARILY
	MOVEM	C,MAXSTM	;SAVE THE COUNT TEMPORARILY
	PUSHJ	P,SLWFST	;COUNT INCORE/SWAP STREAMS
	JFCL			;NO INCORE TYPES
	HLRZ	B,T1		;CURRENT SWAP TYPES.
	SUB	B,(P)		;TOTAL # OF STREAMS
	MOVNS	B		;OLD INCORE ONES'S
	CAMG	B,C		;MORE OLD INCORE TYPES
	PJRST	NOSLW		;O.K. RETURN
	POP	P,MAXSTM	;GET OLD MAXIMUM STREAMS
	MOVEM	T1,SLWSRM	;OLD SWAP TYPES ETC
	MOVEI	JB,1(C)		;FIRST SUBJOB THAT NEEDS CHANGE
	MOVE	C,B		;GET THE UPPER LIMIT.
	MOVEI	B,SIZE		;MIXED INCORE/SWAP TYPES.
	IMULI	B,-1(JB)	;DATA AREA
	PUSH	P,C		;SAVE AC C
INCST1:	PUSHJ	P,INCSWP	;OUTPUT BLOCK ETC.
	ADDI	B,SIZE		;NEXT INCORE DATA AREA.
	CAMGE	JB,(P)		;IS IT THE END?
	AOJA	JB,INCST1	;NO. GO TO NEXT ONE.
	POP	P,C		;RESTORE AC C
	MOVE	T1,(P)		;GET NEW STREAM COUNT
	PUSH	P,MAXSTM	;SAVE OLD MAXIMU STREAM COUNT
	MOVEM	T1,MAXSTM	;SAVE IT TEMPORARILY
	MOVE	T1,SLWSRM	;OLD SWAP COUNT
NOSLW:	MOVEI	G,SIZE		;DATA AREA PER JOB
	IMUL	G,-1(P)		;TOTAL DATA AREA =NEW*SIZE
	ADDI	G,FIRDTA	;ABSOLUTE AREA =FIRDTA+NEW*SIZE
	MOVEM	G,D		;SAVE IT D=FIRDTA+NES*SIZE
	HLRO	E,COMTB		;GET NEGATIVE LENGTH OF COMMAND TABLE
	MOVNS	E		;POSITIVE LENGTH
	ADDI	G,(E)		;END OF COM TABLE G=FIRDTA+NEW*SIZE+COMTB
	PUSH	P,G		;SAVE IT FOR LATER
	PUSH	P,D		;SAVE AC D
	PUSHJ	P,SLWFST	;CHECK SWAP ANE INCORE STREAMS
	JFCL			; FOR THE NEW STREAMS
	POP	P,D		;RESOTORE AC D
	HRRM	D,COMTB		;SAVE START OF COMMAND TABLE
	MOVEI	A,FSTBUF	;AC A SWAP, AC C INCORE
	IMULI	A,(C)		;AC A=INCORE*2*128
	ADDI	G,(A)		;END OF BUFFER AREA.
	JSP	BUF,DMXJ10	;GET CORE IF NEED BE G=FIRDTA+NEW*SIZE +
				;COMTB+BUFFERS
	HLRZ	A,T1		;OLD SWAP STREAMS
	SUB	A,-1(P)		;TOTAL OLD INCORE ONES
	MOVNS	T2,A		;OLD INCORE#
	CAML	A,C		;GET SMALLER OF THE TWO
	SKIP	A,C		;
	IMULI	A,FSTBUF	;LENGTH OF BUFFERS
	POP	P,E		;RESTORE AC E
	ADDI	A,(E)		;END OF DATA AREA FOR NEW MJOB
	MOVEI	G,SIZE		;DATA AREA PER JOB
	IMUL	G,(P)		;OLD STREAM JOB AREA
	ADDI	G,FIRDTA	;ABSOLUTE AREA
	PUSH	P,E		;SAVE AC E
	PUSH	P,C		;SAVE AC C
	SUB	A,D		;LENGTH  IN A
	HRL	A,A		;AND IN LEFT HALF
	ADD	A,G		;UPPER LIMIT FROM ORIGINAL AREA
	MOVE	C,D		;
	SUB	C,G		;C HAS OFFSET
	TLO	A,(1B0)		;SET SIGN BIT TO PREVENT OVERFLOW
	HRLI	C,(POP A,0(A))
	MOVE	D,[JUMPL A,C]
	MOVSI	E,(POPJ P,)
	PUSHJ	P,C		;EXECUTE ROUTINE IN AC'S
	POP	P,C		;RESTORE AC C
	POP	P,E		;RESTORE AC E
	CAMGE	C,T2		;NEW COUNT G.R. THAN OLD COUNT
	PUSHJ	P,UPDPTR	;NEW COUNT L.E. THAN OLD COUNT
	PUSHJ	P,UPDATP	;UPDATE THE POINTERS
	HRRM	E,SLWSRM	;SAVE IT AS START OF BUFFERS
	POP	P,MAXSTM	;
	POP	P,A		;
	POPJ	P,		;RETURN


;HERE FIX THE SUBJOB CHANGEOVER INCORE TO SWAP TYPE.
;JB HAS JOB# AC B HAS DATA ADDRESS.
;
;CALLING SEQUENCE
;	PUSHJ	P,INCSWP
;	RETURN
;
INCSWP:	SKIPN	PTYTAB-1(JB)		;IS IT IN USE?
	POPJ	P,			;NO. RETURN
	MOVE	F,FLAGS(B)		;
	MOVE	F2,FLAG2(B)		;GET ALL JOB FLAGS
	PUSHJ	P,LOGFL8		;CLOSE THE FILE
	MOVE	A,[RELEASE]
	PUSHJ	P,IOUUO			;RELEASE THE CHANNEL
	PUSHJ	P,CLRLOG	;CLEAR QUETAB AND FRECHN
	SETZ	T1,			;..
	DPB	T1,[POINT 8,QUETAB-1(JB),25]
	MOVEI	T1,F2.FST		;GET THE INCORE TYPE FLAG.
	ANDCAM	T1,FLAG2(B)		;RESET IT 
	POPJ	P,



UPDATP:	JUMPE	T2,CPOPJ
	MOVNS	T2		;SETUP AOBJN POINTER
	HRLZS	T2		;
	SKIPE	PTYTAB(T2)	;
	PUSHJ	P,CHKPTR	;
	AOBJN	T2,.-2		;GO BACK
	POPJ	P,		;RETURN

UPDPTR:	MOVEI	T1,1(C)		;GET JOB# THAT IS CHANGED FROM INCORE
				; TO SWAP TYPE
	PUSH	P,E		;SAVE AC E
	MOVEI	E,PTYCTL	;START OF BUFFERS
	PUSH	P,C		;SAVE AC C
	SKIPE	PTYTAB-1(T1)	;IS THE JOB INUSE?
	JRST	[PUSH P,T1
		PUSH P,T2
		MOVEI T2,-1(T1)
		HRRZ D,BUFTAB(T1)
		AOS D
		PUSHJ P,CHKPT3
		POP P,T2
		POP P,T1
		JRST .+1
			]
	CAIGE	T1,(T2)		;IS IT OVER YET?
	AOJA	T1,.-3		;GO BACK
	POP	P,T2		;RESTORE AC T2
	POP	P,E		;RESTORE AC E
	POPJ	P,		;RETURN
	>


	IFLE	FTOPR,<
SUBTTLE FIT COMMAND
;HERE PROCESS THE OPERATOR COMMAND BL-DEFINE FOO WHERE
;FOO DEFINES THE BATCH STREAM TYPE. BATCON DEFAULTS ALL STREAMS TO 
;INP INITIALLY. INCLUDED HERE IS A TABLE OF ALL LEGAL QUEUES.


DDFINE:	PUSHJ	P,DSJOB		;CHECK IF JOB IN USE.
	PUSHJ	P,CONCHR	;IS LF FF ETC?
	SKIPA			;NO.
	PJRST	COMERR		;YES. IT IS AN ERROR
	SETZ	T1,		;INITIALIZE THE COUNTER
	PUSHJ	P,GETC1		;GET THE ARGUMENT
	HRLZI	A,-QUESIZ	;GET THE LEGAL QUEUE LENGTH
	MOVE	D,LEGQUE(A)	;
	CAME	D,COM		;DOES IT MATCH?
	AOBJN	A,.-2		;NO. CHECK NEXT ONE
	JUMPGE	A,DDFIN1	;ILLEGAL QUEUE
	TRNN	GF,ALLF		;IS ALL FLAG ON?
	SOSA	C		;SUBTRACT ONE AND SKIP
	HRLZI	C,-JOBMAX	;GET THE TOTAL STREAMS
	HLLM	D,QUETAB(C)	;SAVE STREAM TYPE
	AOBJN	C,.-1		;TO THE NEXT ONE
	POPJ	P,		;RETURN


DDFIN1:	TYPE	</? Illegal queue specified
/>
	POPJ	P,		;RETURN


;HERE IS A LIST OF ALL THE LEGAL INPUT BATCH QUEUES


LEGQUE:	SIXBIT/INP/
	SIXBIT/TEN/
QUESIZ==.-LEGQUE
	>
	IFLE	FTOPR,<
SUBTTLE FIT COMMAND
;HERE SIMULATE OLD STYLE JOB PROCESSING BY KEEPING INFORMATION 
;ABOUT ONE JOB IN CORE.
DFIT:	JSP	T1,CHEK		;CHECK SUBJOB LF FF ETC?
	SKIPE	JBSACT		;ARE ANY JOBS IN USE?
	PJRST	[TYPDSK</? Legal when no jobs in use
/>
	POPJ	P,		;RETURN
		]
	CAILE	C,JOBMAX	;IS IT WITHIN LIMITS
	PJRST	COMERR		;NO. RETURN 
	PUSH	P,C		;SAVE AC C
	MOVEI	C,JOBMAX	;GO TO THE TOP
	PUSHJ	P,DMXJB1	;EXPAND CORE
	POP	P,C		;RESTORE AC C
	CAIN	C,JOBMAX	;GOTO MAXIMUM
	POPJ	P,		;ALREADY DONE
	MOVEM	C,A		;SAVE AC C TEMPORARILY
	IMULI	C,SIZE		;DATA BASE SIZE
	ADDI	C,FIRDTA	;IN LOW CORE
	MOVE	G,C		;SAVE IT
	HLRO	E,COMTB		;COMPUTE LENGTH OF MONITOR COMM TABLE
	MOVNS	E		;ALWAYS POSITIVE
	ADD	G,E		;COMPUTE UPPER END
	HRLZ	D,COMTB		;
	HRRI	D,(C)		;
	BLT	D,(G)		;MOVE COMMAND TABLE
	HRRM	C,COMTB		;SAVE ADDRESS
	ADD	E,C		;
	HRRM	E,SLWSRM	;UPPER END
	JSP	BUF,DMXJ10	;EXPAND CORE
	MOVEM	A,MAXSTM	;UPDATE THE MAXIMUM SIZE
	HRLM	A,SLWSRM	;SAVE THE SIZE
	POPJ	P,		;RETURN
	>
	IFLE	FTOPR,<
SUBTTLE EXAMINE COMMAND
;HERE EXAMINE CONTENTS OF CTL FILE IN ADVANCE

DEXAM:	JSP	T1,CHKJOB	;IS THE JOB IN USE?
	PUSHJ	P,NUMBR		;YES. HOW LANY LINES IN ADVANCE?
	JSP	T1,CHEK1	;IS IT LF ETC?
	JUMPE	C,COMERR	;#OF LINES ZERO. COMMAND ERROR.
	HRRM	C,NLINES	;SAVE # OF LINES IN ADVANCE IN NLINES
	TRNE	GF,ALLF		;IS ALL JOBS FLAG UP?
	JRST	EXAM5		;YES
EXAM4:	PUSHJ	P,LOKCTL	;GET A BLOCK OF CTL FILE
	MOVE	T1,CTLPTR(B)	;GET CURRENT POINTER POSITION
	HRRZ	C,NLINES	;GET COUNT OF LINES
	MOVE	A,CTLCNT(B)	;GET TOTAL CHARACTERS
	PUSHJ	P,JOBTY		;TYPEOUT JOB# ON CONTROL TTY.
	PUSHJ	P,CRLF		;TYPEOUT <CR>
	TRNE	F,F.CTL		;IS IT CTL LOOKUP FAILURE
	JRST	EXAM6		;YES PRINT THE MESSAGE
EXAM2:	CAIL	A,MAXCHR	;ARE WE WITHIN TOTAL MAX CHARACTERS
	JRST	EXAM3		;IT IS END BUFFER
	ILDB	CH,T1		;GET A CHARACTER
	PUSHJ	P,DSKLOG	;SAVE IT IN DISK LOG
	AOS	A		;UPDATE CHARACTER COUNT.
	OUTCHR	CH		;TYPEOUT TO OPERATOR
	PUSHJ	P,CONCHR	;IS IT END LINE?
	JRST	EXAM2		;NO GET ANOTHER CHARACTER.
	SOJG	C,EXAM2		;DID WE READ ALL LINES
	POPJ	P,		;RETURN


EXAM5:	ALLJOB(EXAM4)

EXAM3:	TYPDSK</End of buffer
/>
	POPJ	P,		;RETURN
EXAM6:	TYPDSK</? CTL Lookup failure
/>
	POPJ	P,
	>

	IFLE	FTOPR,<
SUBTTLE READ DECIMAL/OCTAL FROM TTY ETC
NUMBR:	SETZ	C,		;CLEAR C
NUMBR1:	PUSHJ	P,SPPC		;GET CHARACTER IGNORE NULLS CR SPACES
NUMBR2:	CAIG	CH,"9"		;IS IT A NUMERAL?
	CAIGE	CH,"0"
	POPJ	P,		;NOT A NUMERAL
	SUBI	CH,60		;CHANGE TO BINARY
	IMULI	C,^D10		;SUBJOB IN DECIMAL
	ADD	C,CH		;SUBJOB IN C
	JRST	NUMBR1		;GET NEXT CHARACTER
	>

JOBTY:	TYPDSK</
SUBJOB#  />
JOBTY1:	PUSH	P,A		;SAVE A
	PUSH	P,B		;SAVE B
	PUSH	P,C		;SAVE C
	MOVE	A,JB
	PUSHJ	P,TYDEC
JOBTY2:	POP	P,C		;RESTORE C
	POP	P,B		;RESTORE B
	POP	P,A		;RESTORE A
	POPJ	P,		;RETURN
CRLF:	TYPDSK</
/>
	POPJ	P,


	IFLE	FTOPR,<
;HERE OCTAL NUMBER FROM TERMINAL

NUMOCT:	SETZ	C,		;CLEAR AC C
NUMOC1:	PUSHJ	P,SPPC		;GET A CHARACTER
NUMOC2:	CAIG	CH,"7"		;IS IT OCTAL?
	CAIGE	CH,"0"		;
	POPJ	P,		;NO.RETURN
	SUBI	CH,60		;
	IMULI	C,^D8		;CONVERT IT
	ADD	C,CH		;
	JRST	NUMOC1		;NEXT CHARACTER

	>

	IFLE	FTOPR,<
SUBTTLE KILL COMMAND
DKILL:	JSP	T1,CHKJOB	;CHECK IF JOB IN USE/
	SETZ	T1,		;CLEAR AC T1.
	MOVE	C,COM		;SAVE COMMAND
	PUSHJ	P,CONCHR	;IS LF FF ETC.?
	CAIN	CH,";"		;OR IS IT SEMICOLON?
	JRST	KILL6		;YES. IT IS DEFAULT CASE.
	PUSHJ	P,GETC1		;GET COMMAND ARGUMENT.
	PJRST	DISPC1		;DISPATCH COMMAND.

DFLUSH:	MOVEM	C,COM		;RESTORE COMMAND
	PUSHJ	P,CONCHR	;IS IT LF VT OR FF?
	PUSHJ	P,CMSG		;SPACE GO GET COMMENT.
	TRNE	GF,ALLF		;IS ALL FLAG SET?
	JRST	KILL3		;YES GO DISPATCH TO ALL JOBS.
FLUSH1:	TRNE	F,F.KILL	;IS KILL COMMAND BEEN ISSUED?
	POPJ	P,		;YES RETURN
	TLZE	F,F.CTRC	;IS IT IN ^C MODE?
	PUSHJ	P,STPCRC	;YES. RESET FLAG AND UPDATE COUNT
	TLO	F,F.SUPZ	;SET FLAG TO SEND /Z TO LOGOUT
	PUSHJ	P,BACOM		;PRINT TIME BAOPR ETC.
	MOVEI	T2,[SIXBIT/ FLUSH/]
	PUSHJ	P,BAOPR1	;PRINT FLUSH
	SKIPE	T1		;IS MESSAGE FLAG SET?
	PUSHJ	P,WRT		;WRITE MESSAGE.
	PUSHJ	P,CRLF1		;SEND CRLF TO LOG
	PUSHJ	P,DEAS		;SEND ^C AND GET STATUS
	TLNN	STS,JSTMON	;IS IT IN MONITOR MODE?
	PUSHJ	P,DEAS		;SEND ^C^C TO OBJECT JOB.
	PUSHJ	P,CRLF1		;WRITE <CR> AND CLOSE FILE
	PUSHJ	P,BMSG6		;CHECK IF INCORE TYPE
		>

	IFL	FTOPR,<
	PJRST	STOP6		;RETURN
	>
	IFGE	FTOPR,<
;HERE SEND KJOB COMMAND AND ALL THE SWITCHES NECESSARY FOR 
;KJOB PROCESSING. HERE ON SEND /B FOR BATCH TYPE LOGOUT
;/Z IF NO OUTPUT IS TO BE PROCESSED. IF /Z NO DEFAULT INFORM. SENT
;IF /B ONLY SENT ALL NONZERO DEFAULT FOR OUTPUT DEVICES IS SENT

FLUSH2:	TRZ	F2,F2.STP+F2.OPR	;RESET OPERATOR FLAG
	MOVEI	T2,[SIXBIT/KJOB/]	;SEND KILL COMMAND
	PUSHJ	P,SIXLOG	; TO OBJECT JOB.
	PUSHJ	P,SPACE
	MOVEI	T2,L.FSTR(B)	;GET THE STRUCTURE NAME
	PUSHJ	P,SIXLOG	;SEND IT TO THE JOB
	MOVEI	CH,":"		;TERMINATE STRUCTURE WITH COLON
	PUSHJ	P,SIXLO2	;SEND IT TO THE JOB
	SKIPN	C,L.FRNM(B)	;IS LOG FILE ALREADY RENAMED?
	MOVEI	T2,L.FNAM(B)	;GET LOG FILENAME
	SKIPE	C		;
	MOVEI	T2,L.FRNM(B)	;GET THE RENAMED NAME.
	PUSHJ	P,SIXLOG	;SEND IT TO THE JOB
	MOVEI	CH,"."		;GET PERIOD
	PUSHJ	P,SIXLO2	;SEND IT TO THE JOB
	SKIPN	C,L.FRNM(B)	;IS RENAMED?
	MOVEI	T2,L.FEXT(B)	;GET EXTENSION
	JUMPN	C,KILL4		;IF RENAED USE EXT QUD
KILL5:	PUSHJ	P,SIXLOG	;SEND IT TO THE JOB
	MOVEI	CH,"["		;SEND LEFT BRACKET
	PUSHJ	P,SIXLO2	; TO THE JOB
	SKIPN	D,L.FRNM(B)	;IF RENAMED USE 3,,3
	HLRZ	C,L.FDIR(B)	;ACTUAL P,PN
	SKIPE	D		;
	MOVEI	C,3		;USE PROJ 3
	TRNE	F,F.PRIV	;DOES HE HAVE PRIVS TO WRITE
	HLRZ	C,Q.PPN(B)	;GET USERS P,PN
	PUSHJ	P,SNOCT		;SEND OCTAL NUMBER TO THE JOB
	MOVEI	CH,","		;SEND A COMMA
	PUSHJ	P,SIXLO2	;SEND IT TO THE JOB
	SKIPN	D,L.FRNM(B)	;IS LOG FILE ALREADY RENAMED?
	HRRZ	C,L.FDIR(B)	;GET THE PROG NUMBER.
	SKIPE	D		;
	MOVEI	C,3		;USE PROG 3
	TRNE	F,F.PRIV	;DOES HE HAVE PRIVS TO WRITE?
	HRRZ	C,Q.PPN(B)	;GET PROGRAMMER#
	PUSHJ	P,SNOCT		;SEND OCTAL NUMBER TO THE JOB
	PUSHJ	P,SFDKJB	;WRITE SFD IN KJOB LINE
	MOVEI	CH,"]"		;SEND RIGHT BRACKET
	PUSHJ	P,SIXLO2	;TO THE JOB
	>
	IFGE	FTOPR,<
	MOVEI	CH,"="		;SEND = TO THE JOB
	PUSHJ	P,SIXLO2	;SEND IT TO THE JOB
	PUSHJ	P,FLUSH6	;SEND / TO THE JOB
	IFN	FTDFL,<
	MOVEI	CH,"W"		;GET THE CHARCTURE W
	PUSHJ	P,FLUSH7	;SEND W TO THE JOB
	>
	MOVEI	CH,"Z"		;GET THE CHARACTER Z
	TLNE	F,F.SUPZ	;IS SUPPRESS /Z ON?
	PUSHJ	P,FLUSH7	;NO. SEND Z TO THE JOB
	TLNN	F,F.SUPZ	;IS SUPRRESS /Z ON ?
	PUSHJ	P,FLUSH3	;YES. CHECK FOR /Z ARGUMENTS.
	MOVEI	CH,"B"		;YES. SEND ONLY B TO THE JOB
	PUSHJ	P,SIXLO2	;SEND IT TO THE JOB
	TLNN	F,F.SUPZ	;IS SUPRRESS OUTPUT FLAG SET?
	PUSHJ	P,DEFALT	;NO. SEND JOB ALL DEFAULT SWITCHES.
	PUSHJ	P,SETTM1	;SEND <CR> AND DO OUTPUT
	TRO	F,F.FIN+F.KILL+F.END;SET JOB FINISHED FLAG
	TLZ	F,F.WOPR+F.SUPZ	;RESET WAITING FOR OPERATOR FLAG.
	TRZ	F,F.QSMK	;RESET ERROR IN JOB FLAG.
	PJRST	STAG1		;SAVE FLAGS AND RETURN

	>
	IFLE	FTOPR,<
KILL3:	ALLJOB(FLUSH1)

KILL6:	MOVE	D,[SIXBIT/ERROR/]
	MOVEM	D,COM		;SAVE IT AS AN ARGUMENT
	PJRST	DISPC1		;GO DISPATCH
	>
	IFGE	FTOPR,<


KILL4:	MOVSI	C,(SIXBIT/QUD/)
	MOVEI	T2,C
	JRST	KILL5

FLUSH3:	LDB	C,[POINT 3,Q.IDEP(B),8]
	PUSHJ	P,SIXLO2	;SEND Z TO THE JOB
	JUMPE	C,FLUSH6	;SEND /Z IF ZERO
	MOVEI	CH,":"		;GET COLON
	PUSHJ	P,SIXLO2	;SEND IT TO THE JOB
	PUSHJ	P,SNDEC		;SEND ARGUMENT
	PJRST	FLUSH6		;SEND / TO THE JOB
	>
	IFGE	FTOPR,<
CONFRM:	TRZ	F,F.KILL	;RESET KILL COMMAND
	PUSHJ	P,CTRC4		;SEND ^C TO OBJECT JOB
	PJRST	STOP6		;SAVE FLAGS AND RETURN

FLUSH7:	PUSHJ	P,SIXLO2	;SEND IT TO OBJECT JOB
FLUSH6:	MOVEI	CH,"/"		;GET SLASH
	PJRST	SIXLO2		;SEND IT TO THE JOB AND RETURN
FLUSH9:	PUSHJ	P,FLUSH6	;SEND / TO THE JOB
	MOVEI	CH,"V"		;SEND V TO THE JOB
	PJRST	SIXLO2		;SEND V TO THE JOB
DEFALT:	LDB	C,[POINT 6,Q.PRI(B),35]
	SWITCH(R)		;SEND JOB PRIORITY
	MOVE	C,Q.SEQ(B)	;GET SEQUENCE#
	SWITCH(S)		;SEND IT TO KJOB
	HLRZ	C,Q.ILIM+1(B)	;GET THE PAGE LIMIT
	SWITCH(L)		;SEND LINE PRINTER LIMIT
	HRRZ	C,Q.ILIM+1(B)	;GET THE CARD LIMIT
	SWITCH(C)		;SEND CARD PUNCH LIMIT
	HLRZ	C,Q.ILIM+2(B)	;GET PAPER TAPE LIMIT
	SWITCH(T)		;SEND PAPER TAPE LIMIT TO THE JOB
	HRRZ	C,Q.ILIM+2(B)	;GET TIME LIMIT
	SWITCH(P)		;SEND PLOTTER TIME LIMIT
	LDB	C,[POINT 3,L.FMOD(B),29]
	JUMPE	C,CPOPJ		;WEIRD
	PUSHJ	P,FLUSH9	;SEND /V TO THE JOB
	MOVEI	CH,"D"		;SEND D TO THE JOB
	PUSHJ	P,SIXLO2	;SEND IT TO THE JOB
	MOVEI	CH,":"		;GET COLON :
	PUSHJ	P,SIXLO2	;SEND : TO THE JOB
	SETZ	CH,		;CLEAR THE CHARACTER REGISTER
	CAIGE	C,3		;IS IT 3 OR MORE?
	JRST	CHR-1(C)	;NO.
	MOVEI	CH,"D"		;SOMETHING IS WRONG. DELETE IT
	PJRST	SIXLO2		;SEND IT TO THE JOB

CHR:	TROA	CH,120		;ASCII "P"
	TRO	CH,122		;ASCII "R"
	PJRST	SIXLO2		;SEND IT TO KJOB

;HERE SEND SFD'S TO KJOB 

SFDKJB:	HRLZI	C,-SFDDEP	;MAXIMUM SFD'S
	HRRI	C,L.FDIR+1(B)	;GET THE FIRST ONE
SFDKJ1:	SKIPN	(C)		;IS IT NULL?
	POPJ	P,		;RETURN
	MOVEI	CH,","		;
	PUSHJ	P,SIXLO2	;SEND TO THE JOB AND LOG FILE
	HRR	T2,C		;POINT TO IT
	PUSHJ	P,SIXLOG	;WRITE IT IN LOG ANTO JOB
	AOBJN	C,SFDKJ1	;NEXT IN HEIRCHY
	POPJ	P,		;ALL DONE
	>
	IFLE	FTOPR,<
;HERE IF KILL COMMAND HAS ERROR ARGUMENT

DERROR:	MOVEM	C,COM		;RESTORE COMMAND
	PUSHJ	P,CONCHR	;IS IT LF,VT,FF/
	PUSHJ	P,CMSG		;SPACE, GO GET THE MESSAGE
	TRNE	GF,ALLF		;IS ALL JOBS FLAG SET?
	JRST	KERR2		;GO PROCESS ALL JOBS
KERR1:	TRNE	F,F.KILL	;HAS KJOB BEEN ISSUED?
	POPJ	P,		;YES. LET FINISH
	TLZE	F,F.CTRC	;IS IT IN ^C STOP MODE?
	PUSHJ	P,STPCRC	;YES. RESET DELAY FLAG AND UPDATE COUNT.
	PUSHJ	P,BACOM		;PRINT TIME,AND BAOPR
	MOVEI	T2,[SIXBIT/ ERROR/]
	PUSHJ	P,BAOPR1	;WRITE IT IN LOG FILE.
	SKIPE	T1		;IS MESSAGE FLAG SET?
	PUSHJ	P,WRT		;YES WRITE MESSAGE
	PUSHJ	P,CRLF1		;WRITE <CR> IN LOG FILE
	MOVE	C,[SIXBIT/%ERR/]	;GET THE LABEL TYPE
KERR3:	MOVEM	C,LABEL(B)	;SAVE IT
	TRO	F,F.QSMK+F.KERR	;SET PROPER FLAGS
	TLZ	F,F.WOPR	;RESET WAITING FOR OPERATOR BIT.
	TRZ	F2,F2.STP+F2.OPR	;RESET STOPPED FOR OPERATOR FLAG
	TRZE	F2,F2.BAK	;GET THE JOB STATUS WORD.
	PUSHJ	P,LABE16	;CHANGE CONTEXT
	MOVE	STS,JOBSB(B)	;GET THE JOB STATUS WORD
	TLNN	STS,JSTMON	;IS IT IN MONITOR MODE?
	PUSHJ	P,DEAS		;NO. SEND ^C^C TO THE JOB
	PJRST	LOKLI1+7	;CLOSE LOG FILE SAVE FLAGS

KERR2:	ALLJOB(KERR1)		;PROCESS ALL JOBS.
	>

	IFLE	FTOPR,<
;HERE IF KILL COMMAND HAS NERROR ARGUMENT.

DNEROR:	MOVEM	C,COM		;RESTORE COMMAND
	PUSHJ	P,CONCHR	;IS IT LF,VT,OR FF?
	PUSHJ	P,CMSG		;SPACE . GO GET MESSAGE
	TRNE	GF,ALLF		;IS ALL JOBS FLAG SET?
	JRST	KNERR1		;GO PROCESS ALL JOBS.
KNERR2:	TRNE	F,F.KILL	;IS KILL COMMAND ISSUED?
	POPJ	P,		;LET IT COMPLETE.
	TLZE	F,F.CTRC	;IS IT IN ^C STOP MODE?
	PUSHJ	P,STPCRC	;YES. RESET DELAY FLAG AND UPDATE COUNT.
	PUSHJ	P,BACOM		;WRITE TIME AND BAOPR IN LOG FILE
	MOVEI	T2,[SIXBIT/NERROR/]
	PUSHJ	P,BAOPR1	;WRITE NERROR
	SKIPE	T1		;IS MESSAGE FLAG ON?
	PUSHJ	P,WRT		;WRITE MESSAGE
	PUSHJ	P,CRLFL		;WRITE <CR> IN LOG FILE
	MOVE	C,[SIXBIT/%FIN/]
	PJRST	KERR3		;SET THE FLAGS AND RETURN

KNERR1:	ALLJOB(KNERR2)		;PROCESS ALL JOBS.
	>

STPCRC:	TLZ	F,F.DSTP	;RESET DELAY STOP COMMAND.
	SOS	CTRCNT		;UPDATE ^C CODE COUNT
	POPJ	P,		;RETURN



	IFG	FTOPR,<
;HERE CHECK IF KILL FLUSH WAS TYPED

FLSHJB:	SKIPN	JBSACT		;ANY JOBS IN USE?
	POPJ	P,		;RETURN
	SETZ	B,		;CLEAR AC B
	MOVEI	JB,1		;START WITH FIRST ONE.

	MOVE	F,FLAGS(B)	;GET THE FLAGS
	MOVE	F2,FLAG2(B)	;...
	TLNE	F,F.SUPZ	;IS KIL FLU TYPEDIN?
	PUSHJ	P,FLUSH2	;YES

	ADDI	B,SIZE		;NEXT AREA
	CAMGE	JB,MAXSTM	;ARE YOU TROUGH YET?
	AOJA	JB,FLSHJB+4	;GET NEXT WORD
	POPJ	P,		;RETURN
	>
;HERE SETUP THE DISPLAY FOR VT06
	IFE	FTOPR,<

DISPLY:	PJRST	WHAT2		;GO DO THE WHAT COMMAND
	>


	IFLE	FTOPR,<
SUBTTLE MONJOB COMMAND
;HERE FIND CORRESPONDENCE BETWEEN SUBJOB# AND MONITOR JOB#

DMONJB:	JSP	T1,CHKJOB	;IS JOB IN USE?
	JSP	T1,CHEK1	;IS LF FF ETC?
	TRNE	GF,ALLF		;IS ALL JOBS FALG ON?
	JRST	DMONJ2		;PROCESS ALL JOBS
DMONJ1:	TRO	GF,MNTR		;SET FLAG FOR SHORT PRINTOUT.
	PUSHJ	P,WHAT		;GO TYPEOUT
	TRZ	GF,MNTR		;RESET SHORT PRINTOUT FLAG
	POPJ	P,		;RETURN

DMONJ2:	ALLJOB(DMONJ1)		;PROCESS ALL JOBS


DMONJ3:	POP	P,JB		;RESTORE JB
	PJRST	CRLF		;SEND <CR> TO THE FILE

	>


	IFLE	FTOPR,<
SUBTTLE WHAT COMMAND

;SYSTEM STATUS COMMAND. HERE TYPEOUT THE STATUS OF THE REQUESTED
;SUBJOB OR ALL ACTIVE SUBJOBS.

DWHAT:	JSP	T1,CHKJOB	;IS JOB IN USE?
	JSP	T1,CHEK1	;IS LF FF ETC?
	TRNE	GF,ALLF		;IS ALL JOB FLAG SET?
	JRST	WHAT2		;GO PROCESS ALL JOBS
WHAT:	MOVE	A,JOBSB(B)	;GET THE JOB STATUS WORD.
	PUSHJ	P,JOBTY1	;TYPEOUT SUBJOB#
	PUSHJ	P,TABT		;TYPEOUT A TAB
	PUSH	P,JB		;SAVE SUBJOB#
	HRRZ	JB,JOBSB(B)	;GET REAL JOB#
	SKIPN	JB		;SKIP IF JOB ZERO
	PUSHJ	P,NJOBN		;TYPEOUT ASTRISK AND SKIP RETURN
	PUSHJ	P,JOBTY1	;WRITE REAL JOB#
	TRNE	GF,MNTR		;IS SHORT TYPEOUT FLAG ON
	PJRST	DMONJ3		;WRITE <CR> AND RETURN
	PUSHJ	P,TABT		;SEND A TAB
	POP	P,JB		;RESTORE SUBJOB#
	PUSHJ	P,JOBNAM	;TYPEOUT JOB NAME


	TLNE	F,F.WOPR	;IS IT WAITING FOR OPERATOR RESPONSE?
	JRST	WHAT4		;YES. SAY SO

	HRLZ	A,JOBSB(B)	;GET JOB#
	HRRI	A,JBTPRG	;SETUP GETTAB ARGUMENTS
	GETTAB	A,		;GET PROGRAM NAME
	JFCL			;ERROR RETURN
	MOVE	T2,[POINT 6,A]	;SETUP BYTE POINTER
	PUSHJ	P,TTY		;TYPEOUT PROGRAM NAME
	>
	IFLE	FTOPR,<
	PUSHJ	P,TABT		;SEND A TAB TO TTY
	HRLZ	E,JOBSB(B)	;GET JOB#
	HRRI	E,JBTSTS	;SETUP FOR JOB STATUS
	GETTAB	E,		;GET JOB STATUS
	JFCL			;ERROR RETURN
	MOVSI	C,(SIXBIT/^C/)	;INCASE JOB NOT RUNNING
	JUMPGE	E,GETST1	;IS PROGRAM RUNNING?
	LDB	C,[POINT 5,E,14]	;GET STAUS CODE
	IDIVI	C,3		;THREE TO A WORD
	MOVSI	A,(C)		;SETUP FOR GETTAB.
	HRRI	A,STSTBL	;SETUP FOR STATUS TABLE
	GETTAB	A,		;GET STATUS
	JFCL			;ERROR RETURN
	LDB	C,QPTR(D)	;GET STAUS
	LSH	C,^D24		;SHIFT LEFT 24 PLACES
GETST1:	MOVE	T2,[POINT 6,C]	;SETUP BYTE POINTER
	TLNE	E,SWAPED	;IS JOB SWAPPED
	IORI	C,'SW '
	PUSHJ	P,TTY
	>
	IFLE	FTOPR,<
WHAT1:	PUSHJ	P,TABT		;WRITE TAB OUT
	HRRZ	C,JOBSB(B)	;GET JOB#
	JUMPE	C,WHAT3		;TYPE TIME ZERO IF JOB NOT ASSIGNED
	RUNTIM	C,		;ACCUMULATED RUN TIME
	IDIVI	C,^D1000	;CONVERT IT TO SECONDS
WHAT3:	IDIVI	C,^D3600	;HRS IN C
	PUSHJ	P,OUTCOL	;WRITE HRS AND A COLON
	IDIVI	C,^D60		;MIN IN C
	PUSHJ	P,OUTCOL	;WRITE MTS AND COLOCN
	PUSHJ	P,OUTTY		;OUTPUT ON TTY
	PUSHJ	P,TABT		;SEND TAB OUT
	PUSHJ	P,PRJETC	;TYPEOUT PROJ,PROG#
WHAT5:	TRNE	GF,MSGL		;CHECK IF MSGL ON
	POPJ	P,		;RETURN
	PUSHJ	P,TABT		;SEND A TAB ACROSS
	MOVEI	T2,MSTBLO(B)	;GET ADDRESS OF LAST LINE
	PUSHJ	P,GETST2	;TYPEOUT LAST LINE IN
	PUSHJ	P,CRLF		;SEND <CR> OVER TTY
	PUSHJ	P,TABT		;SEND A TAB ACROSS
	MOVEI	T2,MSTBLI(B)	;GET ADDRESS OF LAST LINE
	PUSHJ	P,GETST2	;TYPEOUT LAST LINE OUT
	PJRST	CRLF		;SEND <CR>

WHAT2:	ALLJOB(WHAT)		;PROCESS ALL JOBS HERE


WHAT4:	OUTSTR	[ASCIZ/Waiting for operator response
/]
	JRST	WHAT5
	>

	IFLE	FTOPR,<
SUBTTLE SET COMMAND
;HERE PROCESS THE SET COMMAND


DSET1:	PUSHJ	P,MASK		;SETUP THE MASK
	HRLZI	G,-SETSIZ	;GET THE LENGTH OF THE TABLE
DSET2:	MOVE	D,SETARG(G)	;GET THE NEXT ENTRY
	ANDCM	D,E		;STRIP THE ARGUMENT
	CAMN	D,COM		;DOES IT MATCH?
	PUSHJ	P,OPTR2		;YES.
	AOBJN	G,DSET2		;NO GET NEXT ENTRY
	PUSHJ	P,COMACH	;CHECK IF ARGUMENT UNIQUE
	PJRST	COMERR		;COMMAND ERROR
	JRST	@DISPC6(A)	;GO SERVICE IT


DSET:	PUSHJ	P,DSJOB		;CHECK DEFAULTS
	PUSHJ	P,CONCHR	;IS LF ETC
	SKIPA 			;NO
	PJRST	COMERR		;YES. MISSING ARGUMENT
	PUSHJ	P,GETC1		;GET THE ARGUMENT
	PJRST	DSET1		;GO DISPATCH


DSLASH:	PUSHJ	P,CONCHR	;IS TERMINATED PROPERLY?
	PJRST	COMERR		;NO
	TRO	GF,LGIN		;SET SLASH FOR LOGIN
	POPJ	P,		;RETURN


DCOMMA:	PUSHJ	P,CONCHR	;IS IT TERMINATED PROPERLY?
	PJRST	COMERR		;NO
	TRZA	GF,LGIN		;RESET TO COMMA
DALL:	TRO	GF,ALLF		;SET ALL JOBS FLAG
	POPJ	P,		;RETURN


DNOSWP:	PUSHJ	P,CONCHR	;IS IT TERMINATED PROPERLY?
	PJRST	COMERR		;NO. ERROR
	HRRZS	SLPTM		;SET BIT
	POPJ	P,		;RETURN

DSWPOK:	PUSHJ	P,CONCHR	;IS IT TERMINATED PROPERLY?
	PJRST	COMERR		;NO
	MOVEI  C,SWPNOW		;
	HRLM	C,SLPTM		;
	POPJ	P,		;RETURN
	>
	IFLE	FTOPR,<
SUBTTLE REQUEUE COMMAND
;HERE PROCESS THE REQUEUE COMMAND

DREQU:	JSP	T1,CHKJOB	;IS JOB IN USE?
	SETZB	T1,BUF		;CLEAR AC T1AND REQUE WORD
	PUSHJ	P,CONCHR	;IS COMMAN TERMINATED?
	JRST	.+2		;NO. CONTINUE
	JRST	DREQ6		;YES. USE DEFAULT VALUE.
	PUSHJ	P,NUMBR		;YES. GET ARGUMENT
	PUSHJ	P,CONCHR	;IS IT LF,VT,OR FF?
	JRST	DREQ1		;NO. IS IT COLON?
DREQ6:	SKIPN	C		;YES. EITHER DEFAULT OR ONLY MTS ?
	MOVEI	C,DEFREQ	;GET DEFAULT REQUEUE TIME
DREQ8:	ADDB	C,BUF		;SAVE REQUEUE TIME IN MTS
	CAILE	C,REQMX		;SHOULD NOT EXCEED 15 DAYS
	PJRST	COMERR		;COMMAND ERROR.
	MOVEM	C,JBREQ		;SAVE REQUEUE TIME
	TRNE	GF,ALLF		;IS ALL JOBS FLAG ON?
	JRST	DREQ4		;GO PROCESS ALL JOBS.
	>
	IFLE	FTOPR,<

;HERE WITH REQUEUE COMMAND. ARGUMENTS FOR THE COMMAND ARE
;ARE HH:MM. THE ARGUMENTS ARE CONVERTED TO MINUTES AND SAVED IN JBREQ

DREQ3:	SKIPGE	Q.IDEP(B)	;CAN THIS JOB BE REQUEUED?
	JRST	REQERR		;NO. JOB NOT PERMITTED TOBE REQUEUED.
	TLZE	F,F.CTRC	;RESET ^C MODE FLAG.
	PUSHJ	P,STPCRC	;RESET DELAY FLAG AND UPFATE COUNT
	PUSHJ	P,BACOM		;SEND BAOPR TO LOG FILE.
	PUSHJ	P,TIM7LG	;WRITE A SPACE IN LOG FILE
	MOVE	C,JBREQ		;GET REQ COM ARGUMENTS.
	IDIVI	C,^D60		;C HAS HH AND HAS MM
	PUSH	P,D		;SAVE MM
	PUSHJ	P,TIM5LG	;WRITE HH IN LOG FILE
	POP	P,C		;RESTORE MM
	PUSHJ	P,TIM2LG	;WRITE MM IN LOG FILE
	PUSHJ	P,TIM7LG	;WRITE A SPACE IN LOG FILE
	SKIPE	T1		;IS MESSAGE FLAG ON?
	PUSHJ	P,WRT		;WRITE MESSAGE
	PUSHJ	P,CRLFL		;WRITE <CR> AND CLOSE FILE
	TRO	F,F.REQ		;SET REQUEUE JOB FLAG ON
	TLZ	F,F.WOPR	;RESET OPERATOR WAIT FLAG.
	PJRST	MISCTL		;REQUE JOB AFTER KILLING IT

DREQ1:	CAIE	CH,":"		;IS IT COLON?
	JRST	DREQ5		;CHECK IF MESSAGE FOLLOWS.
	IMULI	C,^D60		;CONVERT TO MINUTES
	MOVEM	C,BUF		;SAVE IT
	PUSHJ	P,NUMBR		;YES. GET REST OF ARG
	PUSHJ	P,CONCHR	;IS IT LF,VT,FF?
	JRST	DREQ7		;NO CHECK IF MESSAGE FOLLOWS?
	JRST	DREQ8		;GO PROCEED

DREQ7:	SKIPN	C		;IS ARGUMENT ZERO?
	JRST	DREQ9		;CHECK IF SPECIAL DEFAULT
DREQ5:	CAIN	CH,";"		;IS IT SEMICOLON?
	JRST	DREQ10		;IT IS A COMMENT LINE.
	PUSHJ	P,SPERTR	;IS IT ALPHABETIC?
	PJRST	COMERR		;NOT ALPHABETIC
DREQ10:	PUSHJ	P,CMSG		;GET THE MESSAGE
	JRST	DREQ6		;GO PROCEED
DREQ9:	SKIPN	C,BUF		;HRS?
	MOVEI	C,DEFREQ	;ZERO. USE DEFAULT
	JRST	DREQ5		;GET THE MESSAGE.

DREQ4:	ALLJOB(DREQ3)		;PROCESS ALL JOBS

REQERR:	PUSHJ	P,JOBTY		;TYPOUT SUBJOB#
	TYPE</
? Job cannot be requeued/>
	PJRST	CRLF		;WRITE <CR> AND RETURN
	>
SUBTTLE RANDOM LITTLE ROUTINES


TTY:	ILDB	CH,T2		;WRITE SIXBIT WORD ON TTY
	ADDI	CH,40
	OUTCHR	CH
	TLNE	T2,770000
	JRST	TTY
	JRST	CPOPJ


	IFLE	FTOPR,<
GETST2:	HRLI	T2,440700	;SET THE BYTE POINTER
GETST3:	ILDB	A,T2
	JUMPE	A,CPOPJ
	CAIN	A,CR		;IS IT CR?
	PUSHJ	P,GETST4	;YES. CHECK NEXT CHARACTER.
	PUSHJ	P,TYDC2
	JRST	GETST3
GETST4:	ILDB	A,T2		;GET NEXT CHARCTER
	CAIN	A,LF		;IS IT LF?
	JRST	CPOPJ1		;YES. SKIP RETURN
	PUSH	P,A		;SAVE THE CHARACTER
	MOVEI	A,CR		;GET CR
	OUTCHR	A		;TYPE IT OUT
	POP	P,A		;RESTORE THE CHARACTER
	JUMPE	A,TPOPJ		;RETURN IF NULL
	POPJ	P,		;RETURN


QPTR:	POINT	12,A,11
	POINT	12,A,23
	POINT	12,A,35

	>

	IFLE	FTOPR,<
OUTCOL:	PUSH	P,D		;SAVE REMAINDER
	PUSHJ	P,OUTTY		;OUTPUT ON TTY
	MOVEI	CH,":"		;GET A COLON
	OUTCHR	CH		;WRITE IT ON TTY
	>
OUTCO1:	POP	P,C		;RESTORE THE REMAINDER
	POPJ	P,


	IFLE	FTOPR,<
OUTTY:	IDIVI	C,^D10
	MOVEI	A,60(C)
	PUSHJ	P,TYDC2
	MOVEI	A,60(D)
	PJRST	TYDC2
NJOBN:	MOVEI	A,"*"		;SEND ASTRISK
	OUTCHR	A		;TYPEOUT ASTRISK
	JRST	CPOPJ1		;SKIP RETURN
	>

JOBNAM:	MOVE	T2,[POINT 6,C.FNAM(B)]
JOBNM1:	PUSHJ	P,TTY		;GET JOBNAME ANE TYPE IT
TABT:	MOVEI	A,HT		;GET A TAB
	PJRST	TYDC2		;TYPEOUT A TAB



	IFLE	FTOPR,<
SUBTTLE FORCE,HELP COMMANDS
;HERE GET SEQUENCE NUMBER FOR FORCING JOB NEXT

DFORCE:	JSP	T1,CHEK		;CHECK DUBJOB LF FF ETC?
	JUMPE	C,COMERR	;COMMAND ERROR
	MOVEM	C,FORCSQ	;SAVE IT
	POPJ	P,		;RETURN



	EXTERNAL .HELPR

DHELP:	PUSHJ	P,CONCHR	;IS IT TERMINATED BY LF?
	PUSHJ	P,COMER6	;NO. IS IT LF?
	PUSHJ	P,DSJOB		;GET DEFAULT JOB#
	MOVE	A,[SIXBIT/BATCON/]
	PJRST	.HELPR		;GO PUT OUT THE MESSAGE
	>

SUBTTLE JOB STREAM CONTROL

;HERE INITIALIZE AND TRADE STREAMS BETWEEN INCORE AND SWAP ONES
;AC A CONTAINS SWAP STREAMS, AC C CONTAINS THE INCORE STREAMS

	EXTERNAL .JBFF,.JBREL

PIKSRM:	SETZM	FRECHN		;BIT TABLE FOR FREE CHANNELS
	PUSHJ	P,SLWFST	;COUNT #OF SWAP AND INCORE STREAMS
	PJRST	PIKSR5		;NO INCORE STREAMS RETURN
PIKSR2:	HRRZ	A,.JBREL	;GET HIGHEST LOW CORE LOCATION
	HRRZ	D,.JBFF		;FIRST FREE LOCATION
	HRRM	D,SLWSRM	;START BUFFERS HERE
	SUBI	A,-1(D)		;AVAILABLE CORE
	MOVEI	D,FSTBUF	;BUFFERS PER INCORE STREAM
	IMUL	D,C		;TOTAL NEEDED
	CAMG	D,A		;IS IT AVAILABLE?
	JRST	PIKSR3		;YES
	MOVE	A,D		;SAVE IT TEMPORARILY
	ADD	D,.JBFF		;NO. GET HIGHEST ADDRESS
	MOVEI	E,1		;SET SLEEP TIME
	CORE	D,		;GET CORE
	JRST	[SLEEP E,
		JRST PIKSR2]
PIKSR3:	ADDM	A,.JBFF		;SAVE THE FIRST  FREE LOCATION
PIKS11:	HLRZ	E,SLWSRM	;GET #OF SWAP STREAMS
	MOVE	A,MAXSTM	;GET MAXIMUM STREAMS
	SUBI	A,(E)		;AC A HAS INCORE STREAMS
	MOVEI	C,1		;START WITH LOCATION BUFTAB
	JUMPE	E,PIKS10	;GOTO PIKS10 IF ALL INCORE STREAMS
	PUSHJ	P,PIKSR4	;SOME SWAP ONES
PIKS10:	HRRZ	D,SLWSRM	;ALLOCATE NEW BUFFERS
	HRLZI	D,-FSTBUF/2-1(D)	;SAVE FOR LATER
PIKSR9:	HLRZS	D		;NOW IN THE RIGHT HALF
	MOVEI	D,FSTBUF/2(D)	;SAVE THE LOG BUFFER
	CAMLE	C,A		;ARE WE DONE?
	PJRST	PIKS12		;RETURN
	PUSHJ	P,PIKSR8	;NO.
	PJRST	PIKSR9		;CHECK OTHERS

PIKSR8:	HRLI	D,FSTBUF/2(D)	;GET THE CONTROL FILE ADDRESS
	AOJA	C,PIKSR7	;INCREMENT C
PIKSR5:	MOVEI	C,1		;START OF TABLE
PIKSR4:	HRLI	D,PTYLOG-1	;GET LOG FILE ADDRESS
	HRRI	D,PTYCTL-1	;GET CTL FILE ADDRESSS
PIKSR7:	MOVEM	D,BUFTAB-1(C)	;SAVE IT IN THE TABLE
	POPJ	P,		;RETURN
;HERE CLEAR BUFTAB AND OTHER UNUSED BUFTAB LOCATIONS

PIKS12:	MOVE	C,MAXSTM	;GET TOTAL STREAMS
	SUBI	C,(E)		;NO. OF FAST ONES
	CAIL	C,FSTSTM	;IS IT LESS THAN 5?
	JRST	.+3		;GO CHECK IF SLOW STREAMS
	SETZM	BUFTAB+1(C)	;CLEAR THE TABLLE
	AOJA	C,.-3		;NEST ONE
	JUMPN	E,CPOPJ		;RETURN IF ALL FAST
	SETZM	BUFTAB(E)
	POPJ	P,		;RETURN

;HERE FIGUREOUT NUMBER OF FAST AND SLOW STREAMS

SLWFST:	MOVE	A,MAXSTM	;GET THE TOTAL STREAMS DESIRED
	MOVEI	C,FSTSTM	;MAXIMUM SLLOWABLE FAST STREAMS
PIKSR1:	MOVEI	D,CHFACT	;GET THE CHANNEL FACTOR
	IMULI	D,(C)		;MAX #OF CHANNELS USED.
	MOVNS	D		;NEGATE IT
	ADDI	D,MAXCHL(C)	;D HAS SLOW STREAMS
	CAMGE	D,MAXSTM	;IT BETTER MATCH
	SOJN	C,PIKSR1	;GET THE NEST POSSIBLE COMBINATION
	SUBI	A,(C)		;COMPUTE FAST STREAMS
	JUMPG	A,.+3		;
	MOVE	C,MAXSTM	;
	SETZB	A,E		;
	HRLM	A,SLWSRM	;SAVE THE #OF SLOW STREAMS
	JUMPE	C,CPOPJ		;NO FAST STREAMS
	JRST	CPOPJ1		;SKIP RETURN


	IFGE	FTOPR,<
SUBTTLE SUBJOB PROCESSING
INIT2:	SETZB	F,MSTBLI(B)	;CLEAR FLAG REGISTER AND FIRST WORD
	SETZ	F2,		;CLEAR THE SECOND FLAG WORD.
	HRLZI	A,MSTBLI(B)	;SETUP THE WORD FOR BLT
	HRRI	A,MSTBLI+1(B)	; TO CLEAR THE JOB AREA.
	BLT	A,MSTBLI+SIZE-1(B)

;B CONTAINS BASE ADDRESS TO ACCESS DATA FOR CURRENT SUBJOB
;JB	CONTAINS THE CURRENT SUBJOB#

STAG1:	JSP	BUF,PRET	;SAVE CURRENT POSITION
	MOVE	C,JBSACT	;FIND THE #OF STREAMS IN USE.
	CAIN	C,1		;IS IT MORE THAN 1?
	TDOA	C,[XWD 0,777]	;NO. UP THE COUNT.
	MOVEI	C,LOOPCT	;GET COMPUTE LOOP COUNT
	MOVEM	C,COUNT		;SAVE IT IN COUNT.
LEAD:	MOVE	F,FLAGS(B)	;GET FLAGS
	TRNN	F,F.ACTV	;IS JOB IN USE?
	JRST	STAG1		;NO. GO TO THE NEXT JOB.
	PUSHJ	P,JBSTAT	;GET THE JOB STATUS
	SOSGE	COUNT		;UPDATE THE COUNT
	JRST	STAG2		;RETURN
	TLNE	STS,JSTLOG	;IS JOB LOGGEDIN?
	TLO	F,F.LOGD	;YES SET A FLAG 
	TLNN	STS,JSTINP!JSTOUT	;PTY WANTS INPUT OR OUTPUT
	JRST	STAG1		;GO RETURN
	TLNE	STS,JSTINP	;IS IT INPUT FOR PTY?
	JRST	INP		;GO DO INPUT.


;HERE FALL INTO CODE TO READ CONTROL FILE FOR THE JOB.

	TRNE	F,F.FIN		;FLAG SET WHEN THRU WITH CONTROL FILE
				; OR A KILL COMMAND IS ISSUED.
	JRST	ERRAN3		;WARN THE OPERATOR
	TLNE	F,F.INTL	;IS INITIAL COMMAND FLAG ON?
	JRST	CTRCX		;GO SEND THE SET COMMAND
	TRNE	F2,F2.STP	;IS  OPERATOR STOP FLAG ON?
	JRST	OUTC10		;YES. GO WAIT FOR RESPONSE.
	TRNE	F,F.QSMK	;ERROR IN JOB?
	JRST	ERRANL		;ANALYSE THE ERROR
	TLZE	F,F.CLOS	;IS CLOSE COMMAND SENT TO THE JOB?
	JRST	LABE12		;YES. SEND THE DUMP COMMAND.
	TLNN	STS,JSTJNA	;IS JOB ASSIGNED?
	JRST	ERRAN4		;NO. SET EOF FLAG AND RETURN
	>



	IFGE	FTOPR,<
;HERE READ CONTROL FILE AND SEND INFORMATION OVER THE PTY
;HERE READ CONTROL FILE. SACN THE FILE FOR ANY FORBIDDEN MONITOR
;LEVEL COMMANDS. IF THE COMMANDS ARE LEGAL SEND IT OVER TO THE OBJECT
;JOB. IF WHILE SCANNING THE CONTROL FILE END OF BUFFER IS 
;ENCOUNTERED FO READ A NEW BLOCK AND PROCEED. WHILE READING CTL FILE
;IGNORE BLANKS AND CHECK FOR END OF FILE TO END THE PROCESSING.

OUTCTF:	TRNN	F,F.CTLN	;IS CTL FILE LINE FLAG ON?
	JSP	BUF,CLINE	;NO. GO CHECK LINE#
	PUSH	P,CTLPTR(B)	;SAVE CTL FILE POINTER
	PUSH	P,CTLCNT(B)	;SAVE CTL FILE CHARACTER COUNT
	PUSH	P,USICNT(B)	;SAVE BLOCK#
	MOVE	D,[POINT 6,COM]	;SETUP COMMAND POINTER
	SETZB	C,COM		;CLEAR COMMAND WORD
	PUSHJ	P,GETCTL	;IGNOR SPACE,HT AND GET 1ST CHARACTER.
	TLNE	F,F.BRK		;WAS LAST CHARACTER A BREAK CH?
	JRST	[PUSHJ P,SPERT1	;IS THIS ALPHABETIC?
		JRST NOTAL1	;NO.
		JRST OUTC13	;YES
		]
	CAIN	CH,":"		;IS IT SEMICOLON?
	JRST	OUTC12		;IGNORE IT
OUTC13:	CAIE	CH,"."		;IS IT A PERIOD?
	JRST	NOTPRD		;NOT A PERIOD
	PUSHJ	P,CTLOUT	;GO GET NEXT CHARACTER.
	JRST	OUTPT5		;IT IS CTL EOF. RETURN
	PUSHJ	P,SPERT1	;IS IT ALPHABETIC
	JRST	NOTALP		;NOT ALPHABETIC
	PUSHJ	P,COMCH1	;GO CHECK IF VALID COMMAND?
	JRST	BAERR		;BATCH COMMANDS
	TRNN	F2,F2.BAK	;IS IT BACKTO COMMAND?
	TRNE	F,F.IF+F.GOTO	;IS IT IF OR GOTO COMMAND?
	JRST	IFPRCS		;YES. PROCESS IF COMMAND
	TLNN	STS,JSTMON	;IS IT MON MODE?
	JRST	OUTCF6		;GO PROCESS THE PERIOD
OUTCF4:	JSP	BUF,RESTOR	;RESTORE USICNT,CTLCNT,AND CTLPTR
OUTCF5:	PUSHJ	P,OUT1		;SUPPRESS PERIOD SPACE OR TAB.
	PUSHJ	P,SPCES		;IS IT SPACE OR TAB?
	IFE	FTPLS,<
	JRST	OUTCTL		;NOT SPACE.
	>
	IFN	FTPLS,<
	JRST	OUTCTP		;NOT A SPACE
	>
	JRST	OUTCF5		;YES A SPACE. GET NEXT CHARACTER
OUTCF6:	JSP	BUF,RESTOR	;RESTORE POINTERS
	PUSHJ	P,CTRC4		;SEND ^C TO THE JOB
	JRST	OUTPT6		;GO BACK CHECK STATUS

	IFN	FTPLS,<
OUTCTP:	TLNE	F,F.PLS		;IS IT PLEASE COMMAND
	JRST	OUTCF7		;YES TYPEOUT AT THE OPERATOR
	>
	>
	IFGE	FTOPR,<
;FOR THE GIVEN SUBJOB. CONTROL FILE IS IN SUBJOB AREA.

OUTCTL:	PUSHJ	P,OUT1		;GET NEXT CHARAC. SAVE IT IN LOG FILE.
OUTCT2:	CAIN	CH,"^"		;IS IT UP ARROW?
	JRST	ARROW		;YES PROCESS UPARROW
	TLZN	F,F.AROW	;RESET ARROW SEEN FLAG
	JRST	OUTCT3		;IF OFF CONTINUE JOB
	CAIG	CH,"9"		;YES. IS IT A NUMBER?
	CAIGE	CH,"0"		;
	SKIPA			;NO. CONTINUE
	JRST	ARROW1		;YES. SEND EXTRA ^ TO THE JOB
OUTCT3:	PUSHJ	P,BRKCHR	;IS IT A BREAK CHARACTER.
	JRST	OUTPTY		;YES A BREAK CHAARACTER.
	PUSHJ	P,LFETC		;NOT BREAK CHARC. IS IT LF?
	JRST	NLFETC		;ANY CHARACTER NOT LF
LFTST:	TLZN	F,F.SCRF	;RESET FLAGS
	JRST	OUTCT1		;NO
	JRST	OUTPT3		;YES SUPPRESS THE CHARACTER

NLFETC:	CAIE	CH,CR		;IS IT CR?
	JRST	OUTCT1		;GO PROCESS THE CHARACTER
NLFET1:	TLNE	F,F.SCRF	;IS SUPPRESS CRLF SET
	JRST	OUTCTL		;YES SUPPRES THE CHARACTER
OUTCT1:	SKIPN	PTOBUF+2(B)	;NO CHECK THE OUT BUFFER
	JRST	OUTPTY		;BUFFER HEADER ZERO DO OUTPUT
	JRST	OUTPT1		;DEPOSIT CHARACTERS


STAG2:	TLNE	STS,JSTOUT+JSTINP	;DOES IT WANT INPUT?
	TRO	GF,TTYIOW	;SET A BIT TO INDICATE JOB IN TI WAIT
	JRST	STAG1		;RETURN

OUTC12:	JSP	BUF,RESTOR	;RESTORE THE DATA BASE
	PUSHJ	P,GETCTL	;IGNORE THE CHRACTER
	JRST	OUTCTF		;GO TO START
	>

	IFGE	FTOPR,<
ARROW:	TLNE	F,F.AROW	;IS ARROW FLAG SEEN SET?
	JRST	OUTPTY		;YES. CONTINUE
	PUSHJ	P,OUT1		;GET NEXT CHARAC. SAVE IT IN LOG FILE.
	CAIN	CH,"^"		;IS TWO UPARROWS SENT.
	JRST	ARROW2		;STRIP FIRST ARROW
	TLZ	F,F.AROW	;RESET ARROW SEEN FLAG.
	PUSHJ	P,SPERTR	;IS IT ALPHABETIC?
	JRST	ARROW1		;NO.
	XORI	CH,100		;MUST BE A CONTROL CHARC
	PUSHJ	P,BRKCHR	;IS IT A BREAK CHARACTER?
	SKIP			;NO. NOT A BREAK CHARACTER.

OUTPTY:	PUSHJ	P,SNDPTO	;OUTPUT TO THE PTY
OUTPT1:	SOS	PTOBUF+2(B)	;KEEP TRACK OF NO. OF CHARC.
	IDPB	CH,PTOBUF+1(B)	;DEPOSIT A CHARACTER
	PUSHJ	P,LASOUT	;SAVE LINE BUFFER
OUTPT2:	TLNN	F,F.LF+F.BRK	;IS LF OR BREAK CHARC  SEEN FLAG ON?
	JRST	OUTCTL		;GO GET NEXT CHARCTER.
OUTPT3:	PUSHJ	P,SNDPTO	;OUTPUT TO THE PTY
OUTPT6:	MOVEM	F,FLAGS(B)	;SAVE FLAGS
	JRST	LEAD		;RETURN TO THE LOOP
OUTPT4:	POP	P,C		;POP ONE LEVEL OF STACK
OUTPT5:	JSP	BUF,RESTOR	;RESTORE CTLPTR,CTLCNT,USICNT
	JRST	OUT5		;SAVE FLAGS AND RETURN

ARROW1:	PUSH	P,CH		;SAVE THIS CHRACTER
	MOVEI	CH,"^"		;GET UPARROW
	PUSHJ	P,SNDPTY	;SEND IT TO THE JOB
	POP	P,CH		;RESTORE CHARACTER
	JRST	OUTCT1



ARROW2:	TLO	F,F.AROW	;SET TWO ARROWS SEEN FLAG.
	JRST	OUTCT1		;SEND THE CHARACTER
	>
	IFGE	FTOPR,<
	IFN	FTPLS,<

OUTCF7:PUSHJ P,NAMSUB		;TYPE SUBJOB AND JOB#

OUTCF8:	PUSHJ	P,CTLOUT	;GET A CHARACTER
	JRST	OUTPT5		;END OF CTL FILE. RETURN
	PUSHJ	P,INCHR1	;CONVERT TO ALTMODE
	PUSH	P,CH		;SAVE THE CHARACTER
	CAIN	CH,33		;IS IT ALTMODE?
	MOVEI	CH,"$"		;YES. CONVER TO TO $
	OUTCHR	CH		;WRITE IT ON THE TERMINAL
	POP	P,CH		;RESTORE THE CHARACTER
	PUSHJ	P,BRKCHR	;IS IT BREAK CHARACTER?
	JRST	OUTCF1		;YES.
	PUSHJ	P,LFETC		;IS LF ETC.?
	JRST	OUTCF3		;NO.
	PUSHJ	P,OUTCF2	;YES. SAVE IT IN LOG FILE
	TLZ	F,F.PLS		;RESET PLEASE COMMAND FLAG.
	JRST	OUTCF9		;RETURN

OUTCF2:	PUSHJ	P,LOGFL		;SAVE IT IN LOG FILE
	PJRST	LASOUT		;SAVE LAST OUTPUT LINE

OUTCF1:	PUSHJ	P,OUTCF2	;SAVE IT IN LOG FILE
	PUSHJ	P,CRLF1		;WRITE <CR> IN LOG FILE
	PUSHJ	P,CRLF		;WRITE <CR> ON TERMINAL
	TLZ	F,F.PLS		;RESET THE PLEASE COMMAND FLAG
	TYPDSK(/!/)		;WRITE EXCLAMATION ON THE TERMINAL
	JRST	OUTPT6		;RETURN

OUTCF3:	PUSHJ	P,OUTCF2	;SAVE IT IN LOG FILE
	JRST	OUTCF8		;GET ANOTHER CHARACTER

	>

OUTC10:	OUTSTR	[ASCIZ/
OPR---RESPOND WITH BL-OPERATOR <LINE>
/]
	CAME	B,TTYIND	;IS SILENCE SET FOR THIS JOB
	TLZ	F,F.TTY		;YES RESET TYPEOUT FLAG
OUTCF9:	OUTSTR	[ASCIZ/Waiting....
!/]
OUTC11:	TLO	F,F.WOPR	;YES. WAIT FOR OPERATOR RESPONSE.
	JRST	STAG1		;RETURN
	>
	IFGE	FTOPR,<
SUBTTLE /START SWITCH PROCESSING
CLINE:	MOVEM	BUF,TCOM1	;SAVE BUF FOR LATER
	MOVEI	T1,1B35		;
	TDNE	T1,@CTLPTR(B)	;CHECK IF SEQUENCED FILE?
	TRO	F2,F2.SEQ	;SET FLAG
	MOVE	T1,C.FBIT(B)	;GET LINE# WORD.
	TLNE	T1,077777	;IS IT LINE# OR TAG
	JRST	CLINE5		;YES A LABEL
	TLZ	T1,400000	;RESET SIGN BIT
	SUBI	T1,1		;IS IT AT THE START?
	JUMPG	T1,CLINE1	;PROCEED IF NOT ZERO.
CLINE2:	TRO	F,F.CTLN	;SET THE LINE# FLAG
	JRSTF	@TCOM1		;RETURN

CLINE1:	PUSHJ	P,BMSG1		;WRITE TIME AND BATCH
	HRRI	T2,ERMSG7	;POINT TO THE MESSAGE
	PUSHJ	P,LOG1		;WRITE IT IN LOG FILE
	MOVEI	C,1(T1)		;
	PUSHJ	P,SNLOG		;SEND THE LINE NUMBER TO THE LOG FILE
	PUSHJ	P,CRNLFF	;WRITE <CR> INLOG FILE
	MOVE	T2,T1		;GET TOTAL LINE COUNT.
CLINE4:	PUSHJ	P,CHRLOG	;GET A CHARACTER AND SAVE IT IN LOG FILE
	CAIN	CH,LF		;IS IT LF?
	SOJE	T2,CLINE3	;SUBTRACT ONE LINE.
	JRST	CLINE4		;GET TO NEXT LINE.

CLINE3:	TLO	F,F.LF		;RESET LF FLAG
	JRST	CLINE2		;RETURN
	>


PRJETC:	MOVE	A,Q.PPN(B)	;GET PROJ PROG#
	PUSH	P,B		;SAVE AC B
	PUSH	P,A		;SAVE AC A
	HLRZS	A		;GET PROJ#
	PUSHJ	P,TYOCT		;TYPEOUT IN OCTAL
	MOVEI	CH,","		;WRITE ,
	OUTCHR	CH		;TYPEOUT , ON TTY
	POP	P,A		;GET PROGRAM#
	HRRZS	A		;PROGRAMMER#
	PUSHJ	P,TYOCT		;TYPEOUT PROGRAMMER#
	PUSHJ	P,CRLF		;SEND <CR>
	POP	P,B		;RESTORE AC B
	POPJ	P,		;RETURN


SNLOG:	IDIVI	C,^D10		;DIVIDE BY 10 FOR DECIMAL CASE
	PUSH	P,D
	SKIPE	C
	PUSHJ	P,SNLOG
	POP	P,CH
	ADDI	CH,"0"
	PJRST	LOGFL


	IFGE	FTOPR,<
ERMSG7:	ASCIZ/CTL processing at line #/
ERMSG8:	ASCIZ/CTL processing at label /
	>
	IFGE	FTOPR,<
;HERE PROCESS THE LABEL SEARCHING FOR

CLINE5:	LSH	T1,6		;SHIFT A CHARACTER
	PUSHJ	P,BMSG1		;WRITE TIME AND LABEL BATCH
	HRRI	T2,ERMSG8	;POINT TO THE MESSAGE
	PUSHJ	P,LOG1		;WRITE IT IN LOG FILE
	MOVEI	T2,T1		;POINT TO THE LABEL
	PUSHJ	P,BAOPR1	;WRITE IT OUT THE ACTUAL LABEL
	PUSHJ	P,CRLF1		;SEND <CR> TO THE LOG FILE
	MOVE	T2,T1		;GET THE DESIRED LABEL.
CLIN10:	TLZ	F,F.LF		;RESET THE LINE FEED SEEN FLAG
	SETZM	COM		;CLEAR THE COMMAND LEVEL
	MOVE	D,[POINT 6,COM]	;SETUP THE COMMAND POINTER
	PUSH	P,CTLPTR(B)
	PUSH	P,CTLCNT(B)
	PUSH	P,USICNT(B)
	PUSHJ	P,SKPLB1	;GO CHECK FOR THE LABEL
	JRST	CLINE9		;NOT A VALID LABEL
	CAMN	T2,COM		;YES. IS IT THE ONE WE WANT?
	JRST	[JSP BUF,RESTOR
		JRST CLINE3]
CLINE9:	JSP	BUF,RESTOR	;RESTORE POINTERS
CLIN11:	PUSHJ	P,CHRLOG	;GE A CHARACTER.
	PUSHJ	P,LFETC		;IS IT LF ETC.
	JRST	CLIN11		;NO. GO GET NEXT CHARACTER.
	JRST	CLIN10		;YES CHECK NEST LINE
	>
SUBTTLE TAB,BREAK CHRACTER,ALPHA ETC
HTAB:	CAILE	CH,HT		;IS IT LESS THAN 11?
	CAILE	CH,CR		;IS IT LESS THAN 15?
	SKIPA			;SKIP ALWAYS
	TLZA	F,F.TAB		;RESET SEEN CONTROL CHARACTER FLAG?
	TLOE	F,F.TAB		;SEND TABS IF FLAG SET
	POPJ	P,		;RETURN
	PUSH	P,CH		;SAVE THIS CHARACTER
	MOVEI	CH,HT		;GET TAB
	PUSHJ	P,LOGFL		;SEND TAB TO LOG FILE
	PUSHJ	P,LOGFL		;SEND TAB TO LOG FILE
	IFN	DEBUG,<
REPEAT 0,<
	PUSHJ	P,OUT2		;SEND ANOTHER TAB
	>
	>
	PJRST	POPJCH		;RESTORE CH AND RETURN

	IFGE	FTOPR,<
BRKCHR:	CAIG	CH,177		;IS IT RUBOUT?
	CAIGE	CH,175		;OR IT ONE OF THE ALTMODES
	CAIN	CH,32		;NO IS IT EOF.
	JRST	BRKCH1		;YES ROUBOUT OR ALTMODE
	CAIE	CH,3		;IS IT ^C?
	CAIN	CH,7		;OR IS IT ^G?
	JRST	BRKCH1		;YES EITHER ^C OR ^G.
	CAIN	CH,33		;IS IT ALTMODE?
	JRST	BRKCH1		;YES
	TLZ	F,F.BRK		;TURN OFF BREAK CHARACTER FLAG
	JRST	CPOPJ1		;NOT A BREAK CHARACTER.
BRKCH1:	TLO	F,F.BRK		;SET BRK CHARACTER SEEN FLAG.
	POPJ	P,		;BREAK CHARACTER
	>

SPERT1:	PUSHJ	P,INCHR2	;CHECK IF LOWER CASE
SPERTR:	CAIG	CH,"Z"		;CHECK FOR ALPHABET
	CAIGE	CH,"A"
	JRST	CPOPJ
	JRST	CPOPJ1		;IT IS ALPHABETIC

	IFGE	FTOPR,<
GETCTL:	PUSHJ	P,CTLOUT	;GO GET A CHARACTER
	JRST	OUTPT4		;IT CTL EOF. RETURN
	PUSHJ	P,SPCES		;IS IT SPACE TAB ETC?
	POPJ	P,		;NO.
	JRST	GETCTL		;YES. IGNORE IT

LFETC:	PUSHJ	P,CONCHR	;IS IT LF,VT OR FF?
	POPJ	P,		;NO. RETURN
	TLO	F,F.LF		;YES. SET THE FLAG
	JRST	CPOPJ1		;SKIP RETURN
	>
	IFGE	FTOPR,<
SUBTTLE GET CHARACTER ROUTINE
;GET A CHARACTER FROM CTL FILE. IF AT THE END OF BUFFER GET A
;NEW BLOCK. IGNORE BLANKS IN THE FILE.

CTLOUT:	SETO	C,		;SET THE INITIAL FLAG
	ILDB	CH,CTLPTR(B)	;GO GET NEXT CHARACTER
	AOS	A,CTLCNT(B)	;UPDATE INPUT CHARACTER COUNT.
	TRNN	F2,F2.SEQ	;IS IT SEQUENCED FILE?
	JRST	CTLOU1		;NO.
	HLRZ	A,CTLPTR(B)	;YES
	ANDI	A,770000	;JUST THE POSITION BITS
	CAIE	A,350000	;IS IT THE SEQUENCE WORD?
	JRST	CTLOU1		;NO.
	MOVE	A,@CTLPTR(B)	;YES.
	TRNN	A,1B35		;IS IT SEQUENCE FILE?
	JRST	CTLOU1		;NO.
	SETZ	C,		;RESET THE FLAG
	MOVEI	A,5		;UPDATE THE COUNT
	ADDB	A,CTLCNT(B)	;UPDATE THE COUNT
CTLOU1:	SKIP	A,CTLCNT(B)	;WHAT IS THE COUNT
	CAIGE	A,MAXCHR	;ARE WE AT THE END OF BUFFER?
	JRST	CTLOU2		;NO.
	AOS	USICNT(B)	;UPDATE BLOCK COUNT
	PUSHJ	P,RESTR1	;GO LOOKUP CTL FILE
	TRNE	F,F.FIN		;IS IT EOF FOR CTL FILE
	POPJ	P,		;YES RETUTN
	PUSHJ	P,OUT6		;REINITIALIZE JOB AREA
	TRNN	F2,F2.SEQ	;IS SEQUENCE FILE?
	JRST	CTLOU3		;NO.
CTLOU2:	JUMPN	C,CTLOU3	;YES. WAS SEQU#
	AOS	CTLPTR(B)	;YES
	ILDB	CH,CTLPTR(B)	;GET THE CHARACTER
	AOS	CTLCNT(B)	;UPDATE THE COUNT
CTLOU3:	JUMPE	CH,CTLOUT	;IGNORE BLANKS
	JRST	CPOPJ1		;RETURN
	>



	IFGE	FTOPR,<
SUBTTLE PROCESSES CTL TYPE COMMAND
BAERR:	TLNN	F,F.LF		;RESET LF LFAG TO SUPPRESS USRS MESS.
	PUSHJ	P,CRLF1		;SEND CRLF TO LOG FILE
	PUSHJ	P,TIMLOG	;PRINT TIME OF DAY
	PUSHJ	P,MACHCM	;GO MATCH THE COMMAND
	JRST	BAERR4		;YES.IT MATCHES
	MATCH(OPERAT,BAER12)
	JRST	BAERR6		;YES. PROCESS IT
BAER12:	MOVEI	T2,[SIXBIT/BAERR /]
BAERR5:	PUSHJ	P,BAOPR1
	SKIPA			;SKIP ALWAYS
BAERR2:	PUSHJ	P,BAERR3	;WRITE <CR> IN THE LOG FILE
	JSP	BUF,RESTOR	;RESTORE USICNT,CTLCNT,CTLPTR
	TLZ	F,F.LF		;RESET LF FLAG

BAERR1:	PUSHJ	P,OUT1		;GO GET A CHARACTER
	PUSHJ	P,LFETC		;IS IT A LF?
	JRST	BAERR1		;NO
	TRNN	F,F.REQ		;IS REQUEUE FLAG ON?
	JRST	OUTCTF		;YES GO TO START
	JRST	STAG1		;YES. RETURN TO RQUEUE THE JOB


BAERR3:	TLNN	F,F.LF		;IS LF FLAG SEEN?
	PUSHJ	P,CRLF1		;NO. SEND <CR> TO THE LOG FILE
	POPJ	P,		;RETURN

	>


	IFGE	FTOPR,<
BAERR4:	MOVEI	T2,[SIXBIT/BATCH /]
	JRST	BAERR5		;TYPE IT OUT

BAERR6:	PUSHJ	P,CTLOUT	;GET THE NEXT CHARACTER.
	JRST	OUTPT5		;IS IT CTL EOF. RETURN
	PUSHJ	P,SPERT1	;IS IT ALPHABETIC
	JRST	BAERR7		;NOT ALPHABETIC.
	JRST	BAERR6		;YES. GET NEXT CHARACTER.
BAERR7:	CAIG	CH,40		;IS IT CR,LF,FF ETC.,
	JRST	BAER11		;IS IR A LEGAL CHARACTER?
	CAIN	CH,";"		;IS SEMICOLON ;?
	JRST	BAERR8		;YES. USE DEFAULT.
BAERR9:	DPB	CH,[POINT 7,ERRCOD(B),35]
	JRST	BAERR4		;WRITE IN LOG FILE
BAER11:	PUSHJ	P,CONCHR	;IS LF FF ETC?
	JRST	BAER10		;NO
BAERR8:	MOVEI	CH,"$"		;GET DEFAULT
	JRST	BAERR9		;SAVE AND RETURN
BAER10:	PUSHJ	P,CTLOUT	;GET NEXT CHARACTER.
	JRST	OUTPT5		;EOF RETURN
	JRST	BAERR7		;CHECK FOR ARGUMENT.

	>

	IFGE	FTOPR,<
SUBTTLE BACKTO COMMAND
BAKCTL:	SETO	C,		;SET THE INITIAL FLAG
	ILDB	CH,BKCPTR(B)	;GET THE NEXT CHARACTER
	MOVE	A,BKICNT(B)	;GET THE BLOCK COUNT
	CAME	A,USICNT(B)	;COMPARE IT WITH FORWARD COUNT.
	JRST	BAKCT2		;NOT THE SAME CONTINUE
	MOVE	A,BKCPTR(B)	;GET THE POINTER
	CAME	A,CTLPTR(B)	;IS IT THE SAME?
	JRST	BAKCT2		;NO. CONTINUE PROCESSING
	AOS	A,BKCCNT(B)	;UPDATE CHARACTER COUNT
	CAMN	A,CTLCNT(B)	;COMPARE IT WITH OLD POSITION
	JRST	BAKERR		;IT IS AN ERRO
	SKIPA			;SKIP ALWAYS
BAKCT2:	AOS	A,BKCCNT(B)	;UPDATE THE CHARACTER COUNT
	TRNN	F2,F2.SEQ	;IS THIS A SEQUENCED FILE?
	JRST	BAKCT3		;NO.
	HLRZ	A,BKCPTR(B)	;YES.
	ANDI	A,770000	;OONLY THE POSITION BIT
	CAIE	A,350000	;IS THIS THE SEQUECE WORD?
	JRST	BAKCT3		;NO.
	MOVE	A,@BKCPTR(B)	;YES.
	TRNN	A,1B35		;IS IT SEQUENCE FILE?
	JRST	BAKCT3		;NO.
	SETZ	C,		;RESET THE FLAG.
	MOVEI	A,5		;UPDATE THE COUNT
	ADDB	A,BKCCNT(B)	;UPDATE THE COUNT
BAKCT3:	SKIP	A,BKCCNT(B)	;WHAT IS THE CHARACTER COUNT.
	CAIGE	A,MAXCHR	;IS BLOCK FULL
	JRST	BAKCT1		;NO.
	AOS	BKICNT(B)	;UPDATE BLOCK COUNT.
	PUSHJ	P,LABE17	;GET NEW BLOCK IN CORE
	TRNE	F,F.FIN		;IS IT END OF FILE?
	POPJ	P,		;YES. RETURN
	TRNN	F2,F2.SEQ	;IS IT SEQUENCE FILE?
	JRST	BAKCT4		;NO.
BAKCT1:	JUMPN	C,BAKCT4	;YES. WAS SEQUENCE#
	AOS	BKCPTR(B)	;UPDATE THE COUNT
	ILDB	CH,BKCPTR(B)	;GET NEXT CHARACTER
	AOS	BKICNT(B)	;UPDATE THE CHARCTER COUNT
BAKCT4:	JUMPE	CH,BAKCTL	;IGNORE NULL CHARACTERS
	JRST	CPOPJ1		;SKIP RETURN
BAKERR:	SUB	P,[XWD 2,2]
	TRZ	F2,F2.BAK	;RESET BACKTO COMMAND FLAG.
	PUSHJ	P,OUT7		;SAVE THE LAST CHARACTER
	PJRST	SYNER6		;IT IS AN ERROR. RETURN
	>
	IFGE	FTOPR,<
;CONTROL FILE COMMANDS TABLE

CTLCM1:	SIXBIT/IF/
	SIXBIT/GOTO/
	SIXBIT/BACKTO/

CTLCM2:	SIXBIT/SILENC/
	SIXBIT/REVIVE/
	SIXBIT/NOERRO/
	SIXBIT/ERROR/
	SIXBIT/NOOPER/
	SIXBIT/CHKPNT/
	SIXBIT/REQUEU/
CTL2==.-CTLCM2

	SIXBIT/OPERAT/
CTL3==.-CTLCM1


;CONTROL FILE COMMAND DISPATCH TABELE

COMDSP:	EXP	COMIF
	EXP	COMGTO
	EXP	COMBAC


	EXP	COMC2
	EXP	COMC3
	EXP	COMC4
	EXP	COMC5
	EXP	COMC6
	EXP	COMC9
	EXP	COMC10


	EXP	COMC7

CTLDSP==.-COMDSP
	>
	IFGE	FTOPR,<
SUBTTLE SPECIAL CHARACTER HANDLING
NOTPRD:	ADDI	C,-40(CH)	;SAVE THIS CHARACTER IN COM
	IDPB	C,D		;SAVE IT IN COM
	CAIN	CH,";"		;IS IT SEMICOLON
	JRST	BAERR2		;YES IT IS A COMMENT LINE
	CAIN	CH,"$"		;IS IT DOLLAR SIGN?
	JRST	DOLLAR		;YES PROCESS IT
	CAIN	CH,"%"		;IS IT A %SIGN?
	JRST	NOTAL5		;GO PROCESS IT.
	TLNE	STS,JSTMON	;IS IT IN MONITOR MODE?
	JRST	NOTPR3		;YES. IT DIDNOT START WITH A PERIOD
	CAIN	CH,"*"		;IS IT ASTRISK?
	JRST	OUTCF4		;YES
	CAIE	CH,"-"		;IS IT A HYPHEN?
	CAIN	CH,"+"		;OR A + SIGN?
	JRST	NOTPR1		;YES GO PROCESS + OR -
	CAIE	CH,"!"		;! AND \ AR E NOT LEGAL
	CAIN	CH,"\"		;\ IS ILLEGAL
	JRST	BAERR
	CAIE	CH,"="		;IS IT = SIGN?
	JRST	SKPLBX		;GO PROCESS THE WHOLE THING
	TLO	F,F.SCRF	;SET SUPPRESS CRLF FLAG
	JRST	OUTCF4		;NONE OF THE ABOVE SEND IT TO THE JOB

NOTPR1:	PUSHJ	P,CTLOUT	;GET NEXT CHARACTER
	JRST	OUTPT5		;EOF CTL FILE.RETURN
	CAIN	CH,"."		;IS IT .?
	JRST	NOTAL3		;NOT PERIOD. GO GET NEXT CHARACTER.
NOTAL2:	CAIG	CH,"9"		;IS IT A NUMBER?
	CAIGE	CH,"0"
	JRST	BAERR		;NO. IT IS AN ERROR?
NOTAL1:	JSP	BUF,RESTOR	;RESTORE CTL PARAMETERS
NOTAL4:	PUSHJ	P,OUT1		;GO GET A CHARACTER
	PUSHJ	P,SPCES		;IS IT A SPACE OR A TAB?
	JRST	OUTCT2		;NO.
	JRST	NOTAL4		;YES. IGNORE IT
NOTAL3:	PUSHJ	P,CTLOUT	;GO GET NEXT CHARACTER
	JRST	OUTPT5		;IT IS EOF
	JRST	NOTAL2		;PRCESS THE CHARACTER

NOTALP:	TLNE	STS,JSTMON	;IS IT IN MONITOR MODE?
	JRST	OUTCF4		;YES. SUPPRESS PERIOD AND CONTINUE
	CAIG	CH,"9"		;NO. IS IT NUMERIC
	CAIGE	CH,"0"
	JRST	OUTCF6		;NOT NUMERIC
	JRST	NOTAL1		;YES NUMERIC

	>
	IFGE	FTOPR,<
;HERE A LINE STARTS WITH % CHARACTER AND USER JOB NEEDS NO 
;ERROR PROCESSING. ONLY STATEMENTS FOLLOWING %FIN WILL BE 
;EXECUTED.

NOTAL5:	JSP	BUF,RESTOR	;RESTOR CTL PARAMETERS
	PUSHJ	P,CRNLFF	;WRITE <CR> IN LOG FILE, RESET LF FLAG
NOTAL7:	SETZM	COM		;CLEAR THE COMMAND WORD
	MOVE	T1,[POINT 6,COM]	;SETUP BYTE POINTER
	PUSHJ	P,CHRLOG	;GET A CHARACTER AND SAVE IT IN LOG FILE
	CAIE	CH,"%"		;IS IT A % SIGN?
	JRST	NOTA11		;NO CONTINUE PROCESSING
NOTA10:	CAIN	CH,":"		;IS IT COLON?
	JRST	NOTAL8		;YES. CHECK IF %FINR?
	SUBI	CH,40		;CHANGE IT TO ASCII
	IDPB	CH,T1		;SAVE IT IN COMMAND WORD COM
	TLNN	T1,770000	;HAVE WE LOOKED AT SIX CHARACTERS
	JRST	NOTA12		;YES. CHECK FOR :
	PUSHJ	P,CHRLOG	;GET A CHARACTER
	JRST	NOTA10		;CHECK IF :
NOTA12:	PUSHJ	P,CHRLOG	;GEP A CHARACTER
	CAIE	CH,":"		;IS IT COLON?
	JRST	NOTA11		;NOT COLON GET THE REST OF LINE
NOTAL8:	MOVE	D,COM		;GET THE LABEL
	CAMN	D,[SIXBIT/%FIN/]	;IS IT %FIN?
	JRST	LABE11		;YES. GO PROCESS THE REST OF FILE
NOTAL6:	PUSHJ	P,CHRLOG	;WRITE REST OF THE FILE IN LOG FILE
NOTA11:	PUSHJ	P,CONCHR	;IS IT LF FF ETC.?
	JRST	NOTAL6		;NO. GO GET THE CHARACTER
	JRST	NOTAL7		;YES A NEW LINE.


	>
	IFGE	FTOPR,<
SUBTTLE START CTL COMMAND LINE
RESTOR:	MOVE	A,USICNT(B)	;GET NEW BLOCK#
	POP	P,USICNT(B)	;RESTORE OLD BLOCK#
	POP	P,CTLCNT(B)	;RESTORE CTLFILE COUNT
	POP	P,CTLPTR(B)	;RESTORE CTL FILE POINTER
	CAME	A,USICNT(B)	;COMPARE BLOCK NUMBERS
	PUSHJ	P,RESTR1	;LOOKUP CTL FILE
	JRSTF	@BUF		;RESTORE FLAGS AND RETURN



RESTR1:	PUSH	P,T2		;SAVE AC T2
	TRNE	F2,F2.FST	;IS IT IN CORE TYPE?
	PJRST	[ PUSHJ P,USINP	;OUTPUT
		PJRST LOGFL4		;RESTORE T2 AND RETURN
			]
	PUSH	P,A		;SAVE AC A
	PUSH	P,C		;SAVE AC C
	PUSH	P,D		;SAVE AC D
	PUSHJ	P,LOGFL2	;CLOSE THE LOG FILE
	PUSHJ	P,LOKCTL	;LOOKUP THE CTL FILE
	PUSHJ	P,LOGFL1	;OPEN THE LOG FILE AGAIN
	POP	P,D		;RESTORE AC D
	POP	P,C		;RESTORE AC C
	POP	P,A		;RESTORE AC A
	PJRST	LOGFL4		;RESTORE T2 AND RETURN



IFN LEVELC,<
SUBTTLE LEVELC CODE
LVCPTY:	SETZ	A,
LVCPT1:	MOVSI	C,'PTY'		;GET PTY IN LEFT HALF
	PUSH	P,A		;SAVE AC A
	PUSHJ	P,CONSIX	;CONVERT TO SIXBIT
	POP	P,A		;RESTORE A
	DEVCHR	C,		;CHECK IF DEVICE EXISTS
	JUMPE	C,NOTFND	;IF ZERO DOESNOT EXIST
	AOJA	A,LVCPT1	;CHECK NEXT ONE


NOTFND:	JUMPG	A,CPOPJ		;ZERO MONIOTR HAS NO PTYS
NOPTYS:	TYPDSK</? Monitor must be configured for PTY'S
/>
	EXIT
>
	>
	IFGE	FTOPR,<
IFN LEVELC,<
	JOBJDA==75		;LOCATION OF CHANNEL INFORMATION

	DEVNAM==0		;DEVNAM WORD IN DDB
	DEVCHR==1		;DEVCHR WORD IN DDB
	DEVIOS==2		;DEVICE DATA BLOCK WORD
	TTYTAB==10		;GETTAB ARG
	IOPTW==4000		;DOES IT WANT TO OUTPUT
	IOPTRE==2000		;DOES IT WANT TO INPUT
	MONMOD==1000		;IS IT IN MONITOR MODE?


;HERE GET THE JOB STATUS FOR LEVELC

JBSLVC:	SETZ	STS,		;CLEAR THE STATUS REGISTER
LEVC0:	MOVE	D,JOBJDA(JB)	;GET DEVICE DTA BLOCK ADDRESS
	JUMPE	D,LEVC4		;NULL IT IS NOT IN USE
	MOVEI	E,DEVNAM(D)	;GET THE DDB ADDRESS
	PEEK	E,		;GET THE DEVICE NAME
	CAME	E,PTYTAB-1(JB)	;IS IT WHAT WE EXPECT?
	JRST	LEVC4		;ERROR
	MOVEI	E,DEVCHR(D)	;YES. GET DEVICE CH WORD.
	PEEK	E,		;GET IT FROM THE MONITOR
	HRRZS	E,		;CLEAR THE LEFT HALF
	LSH	E,-^D12		;GET THE UNIT#
	ADD	E,TCONLN	;GET THE LINE#
LEVC1:	HRLZ	G,E		;SAVE IT IN LEFT HALF
	HRRI	G,TTYTAB	;SETUP FOR GETTAB
	GETTAB	G,		;DO GETTAB
	JRST	LEVC4		;ERROR RETURN
	TLNN	G,600000	;IS IT WAITING FOR COMMAND?
	JRST	LEVC2		;GET TTYTAB WORD.
	MOVEI	A,1		;SET SLEEP ARGUMENT
	SLEEP	A,		;SLEEP FOR A WHILE
	JRST	LEVC1		;CHECK AGAIN


LEVC2:	MOVEI	A,DEVCHR(G)	;GET THE DDB OF TTY
	PEEK	A,		;DO A PEEK ON IT
	LSH	A,-^D30		;GET THE JOB#
	JUMPE	A,LEVC3		;SET MON MODE ETC.
	HRRZM	A,STS		;SAVE JOB#
	HRLZS	A		;GET THE JOB#
	HRRI	A,JBTSTS	;GET THE JOB STATUS
	GETTAB	A,		;DO A GETTAB
	JRST	LEVC3		;ERROR RETURN
	TLNE	A,40000		;IS JOB# ASSIGNED?
	TLO	STS,JSTJNA	;SET THE FLAG JOB ASSIGNED.
	TLNE	A,4		;IS JOB LOGGED?
	TLO	STS,JSTLOG	;SET THE JOB LOGGEDIN FLAG.
	TLNE	A,100000	;IS JACCT ON?
	TLO	STS,JSTAC	;SET FLAG THAT JACCT ON?
	MOVEI	G,DEVIOS(D)	;GET THE PTY STATUS
	PEEK	G,		;GET THE DEVICE STATUS
	TRNE	G,IOPTW		;DOES PTY WANT TO OUTPUT.
	TLO	STS,JSTOUT	;YES SET THE FLAG.
	TRNE	G,IOPTRE	;DOES PTY WANT INPUT?
	TLO	STS,JSTINP	;YES SET FLAG
	TRNE	G,MONMOD	;IS PTY IN MON MODE?
	TLO	STS,JSTMON	;YES. SAY SO.
	SKIPA			;SKIP ALWAYS
LEVC3:	TLO	STS,JSTOUT+JSTMON
LEVC4:	MOVEM	STS,JOBSB(B)	;SAVE THE STATUS
	POPJ	P,		;RETURN
>
	>
	IFGE	FTOPR,<
SUBTTLE HANDLE $ SPECIAL CHARACTER
DOLLAR:	PUSHJ	P,CTLOUT	;GET NEXT CHARACTER
	JRST	OUTPT5		;IT IS EOF CTL FILE. RETURN
	PUSHJ	P,SPERT1	;IS IT ALPHABETIC?
	JRST	DOLLR1		;NOT AN ALPHABETIC
	JRST	BAERR2		;COMMENT LINE
DOLLR1:	TLNE	STS,JSTMON	;IS IT IN MONITOR MODE?
	JRST	BAERR		;YES
	JRST	OUTCF4		;$SIGN FOLLOWED BY $OR NONALPHABETIC

;HERE IF COMMAND DOESNOT START WITH A PERIOD AND THE JOB IN MONITOR MODE

NOTPR3:	PUSHJ	P,SKPLBL	;CHECK FOR LABEL
	SKIPA			;NONE
	JRST	SKPLX1		;RESTORE BASE AND SKIP LABEL
NOTPR2:	JSP	BUF,RESTOR	;RESTORE THE DATA BASE
	PUSH	P,CTLPTR(B)	;SAVE CTL POINTER
	PUSH	P,CTLCNT(B)	;SAVE THE COUNT
	PUSH	P,USICNT(B)	;SAVE BLOCK#
	SETZB	D,COM		;RESET POINTER ETC
	MOVE	D,[POINT 6,COM]
	PUSHJ	P,COMCHK	;GO GET THE COMMAND
	JRST	BAERR		;BATCH ERROR
	JRST	NOTAL1		;READ THE STUFF AND SEND TO THE JOB

	>


	IFGE	FTOPR,<
SUBTTLE CHECK THE BATCH COMMANDS
;HERE CHECK THE VALIDITY OF THE COMMAND


;CALL	PUSHJ P,COMCHK
;	(FORBIDDEN COMMAND)
;	(MONITOR COMMAND)
COMCHK:	PUSHJ	P,CTLOUT	;GO GET A CHARACTER
	JRST	OUTPT4		;IT IS EOF CTL FILE. RETURN
COMCH1:	CAIN	CH,CR		;IS IT CR?
	JRST	COMCHK		;IGNORE CR
	JUMPE	CH,COMCHK	;IGNORE BLANKS
	PUSHJ	P,SPERT1	;IS IT ALPHABETIC
	JRST	COMCH2		;NO USE IT AS A TERMINATOR FOR COMMAND
	PUSHJ	P,CNVSIX	;CHANGE IT TO SIXBIT
	TLNE	D,770000	;HAVE WE READ SIX CHARAC
	JRST	COMCHK		;GO GET NEXT CHARACTER
COMCH2:	PUSHJ	P,COMMON	;IS IT MONITOR COMMAND?
	JRST	COMCH8		;NO. SEND IT TO THE MONITOR ANYWAY
	MOVE	D,.JBFF		;GET FIRST FREE LOCATION
	SUBI	D,CTL3		;LENGTH OF BATCH TABLE
	CAIG	D,(C)		;IS IT IN MONITOR COMM TABLE?
	JRST	COMCHX		;NO. IT IS BATCH COMMAND
	PUSHJ	P,MASK		;CREATE A MASK
	HRLZI	G,-MONSIZ	;MOVE NEG OF FORBIDDEN TABLE
COMCH3:	MOVE	D,MONTAB(G)	;GET NEXT ENTRY
	ANDCM	D,E		;STRIP COMMAND IN D
	CAMN	D,COM		;DOES IT MATCH?
	JRST	[CAME D,[SIXBIT/D/]
		JRST CPOPJ
		JRST CPOPJ1]
	AOBJN	G,COMCH3	;TRY NEXT ONE
	MATCH(KJOB,COMCH8)	;IS IT KJOB COMMAND
	PUSHJ	P,SPCES		;IS IT A SPACE OR TAB?
	JRST	COMCH7		;NO. GO CHECK IF LF.
COMCH6:	PUSHJ	P,CTLOUT	;GET NEXT CHARACTER
	JRST	OUTPT4		;IT IS EOF
	CAIE	CH,40		;IGNORE SPACE
	CAIN	CH,HT		;IGNORE TABS
	JRST	COMCH6		;GET NEXT CHARACTER.
COMCH7:	PUSHJ	P,CONCHR	;IS IT LF FF ETC.?
	JRST	.+2		;NO
	TRO	F,F.KILL	;YES
COMCH8:	IFN	FTPLS,<

	MATCH(PLEASE,COMCH0)
	JRST	COMC1		;YES IT IS PLEASE COMMAND
	>
	>
	IFGE	FTOPR,<
COMCH0:	MATCH(SET,CPOPJ1)
COMCH9:	PUSHJ	P,CTLOUT	;GET THE NEXT CHARACTER?
	JRST	OUTPT4		;IT IS EOF FILE. RETURN
	CAIE	CH,40		;IS IT SPACE
	CAIN	CH,HT		;IS IT A TAB?
	JRST	COMCH9		;IGNORE SPACE TAB ETC
	PUSHJ	P,SPERT1	;IS IT ALPHABETIC?
	JRST	CPOPJ1		;NO. RETURN
	CAIE	CH,"T"		;YES IS IT T?
	JRST	CPOPJ1		;NOT SET TIME COMMAND.
	JRST	CPOPJ		;BATCH ERROR
COMCHX:	PUSHJ	P,MASK		;SETUP THE MASK
	HRLZI	G,-CTL3		;GET TABLE LENGTH
	MOVE	D,CTLCM1(G)	;GET THE TABLE ENTRY
	ANDCM	D,E		;MASK IT
	CAMN	D,COM		;COMPARE
	JRST	@COMDSP(G)	;DISPATCH
	AOBJN	G,.-4		;GET NEXT ENTRY
	POPJ	P,		;ERROR RETURN


	IFN	FTPLS,<
COMC1:	TLO	F,F.PLS		;SET PLEASE COMMAND SEEN FLAG
	JRST	CPOPJ1		;SKIP RETURN
	>



;CHECK IF COMMAND MATCHES

;CALL	PUSHJ P,MACHCM
;	(IT MATCHES)
;	(IT DOESNOT MATCH)
;
;
MACHCM:	PUSHJ	P,MASK		;SETUP THE MASK
	HRLZI	G,-CTL2		;GET THE LENGTH
	MOVE	D,CTLCM2(G)	;GET THE FIRST ENTRY
	ANDCM	D,E		;MASK IT
	CAMN	D,COM		;COMPARE
	POPJ	P,		;NORMAL RETURN MATCHES
	AOBJN	G,.-4		;GET NEXT ENTRY
	PJRST	CPOPJ1		;SKIP RETURN DOESNOT MATCH

	>

	IFGE	FTOPR,<
COMBAC:	TRO	F2,F2.BAK	;IS IT BACKTO COMMAND?
	JRST	CPOPJ1		;SKIP RETURN.

COMIF:	TROA	F,F.IF		;SET IF COMMAND SEEN FLAG
COMGTO:	TRO	F,F.GOTO	;GOTO COMMAND SEEN
	JRST	CPOPJ1		;SKIP RETURN
COMC2:	TROA	F2,F2.SIL	;SET SILENCE FLAG
COMC3:	TRZ	F2,F2.SIL	;SET REVIVE FLAG
	POPJ	P,		;RETURN


COMC5:	PUSHJ	P,CONCHR	;IS IT LF ETC;?
	JRST	.+2		;NO. IT IS NOT
	JRST	.+4		;YES.PROCEED
	PUSHJ	P,CTLOUT	;GET A CHARACTER
	JRST	OUTPT4		;RETURN EOF
	PUSHJ	P,SPCES		;IS IT HT,SPACE ETC?
	TRZA	F2,F2.NER	;RESET TO DEFAULT
	JRST	.-4		;GO GET NEXT CHRACTER
	CAILE	CH,40		;IS IT CR OR LF?
	CAIN	CH,";"		;IS IT SEMICOLON?
COMC8:	MOVEI	CH,0		;YES USE DEFAULT CLEAR THE CHRACTER.
	DPB	CH,[POINT 7,ERRCOD(B),28]
	POPJ	P,		;RETURN


COMC4:	TRO	F2,F2.NER	;SET NOERROR PROCESSING FLAG.
	PJRST	COMC8		;DEPOSIT AND RETURN


COMC6:	TRZA	F2,F2.OPR	;RESET OPR FLAG
COMC7:	TRO	F2,F2.OPR	;SET OPERATOR COMMAND FLAG
	POPJ	P,		;RETURN
	>
	IFGE	FTOPR,<
COMC9:	SETZM	TCOM1		;CLEAR THE COM WORD
	MOVE	D,[POINT 6,TCOM1]	;SETUP THE POINTER
	PUSH	P,CTLPTR(B)	;SAVE CONTROL FILE POINTER
	PUSH	P,CTLCNT(B)	;
	PUSH	P,USICNT(B)	;
	PUSHJ	P,GETCTL	;IGNORE SPACE ETC
	PUSHJ	P,SKPLB2	;GET THE ARGUMENT
	JFCL			;IGNORE THE RETURN
	SKIPN	D,TCOM1		;WHAT LABE
	PJRST	COMRET		;IGNORE AND RETURN
	PUSHJ	P,STCHKP	;SETUP PARAMETERS FOR CHKPNT
	PUSHJ	P,LOGFL2	;CLOSE THE FILE
	HRRZI	A,RCHKPT	;DO A CHKPNT
	PUSHJ	P,SCHR2		;SET THE DATA AREA
	PUSHJ	P,.QUEER	;CALL QUEUE MANAGER AND RETURN
	PUSHJ	P,LOGFL1	;OPEN THE FILE
COMRET:	JSP	BUF,RESTOR	;RESTORE POINTER
	PJRST	STOP6		;SAVE FLAGS AND RETURN

COMC10:	SETZM	TCOM1		;CLEAR THE COMMAOD WORD
	MOVE	D,[POINT 6,TCOM1]	;SETUP THE POINTER
	PUSH	P,CTLPTR(B)	;
	PUSH	P,CTLCNT(B)	;
	PUSH	P,USICNT(B)	;
	PUSHJ	P,CTLOUT	;GET A CHARACTER
	PJRST	COMRET		;IF ERROR RETURN
	PUSHJ	P,GETCTL	;IGNORE SPACE ETC
	PUSHJ	P,SKPLB2	;GETPTHE ARGUMENT
	JFCL
	TRO	F,F.SETR+F.FIN+F.REQ;SET FLAG TO REQUEUE AND EOF
	SKIPE	D,TCOM1		;IS IT A LABEL?
	PUSHJ	P,STCHKP	;SETUP FOR CHKPNT
	PJRST	COMRET		;RETURN

;HERE SETUP THE PARAMETERS FOR CHKPNT
STCHKP:	LDB	C,[POINT 6,C.FBIT(B),5]
	LSHC	C,-6		;SHIFT A CHARACTER
	MOVEM	D,C.FBIT(B)	;SAVE IT
	HLRZ	C,Q.IDEP(B)	;
	TRZ	C,400000
	HRLM	C,Q.IDEP(B)	;
	POPJ	P,		;RETURN
	>


	IFGE	FTOPR,<
OUT1:	PUSHJ	P,CTLOUT	;GET A CHARACTER.
	JRST	OUT3		;EOF RETURN
	>
OUT7:	TLNE	STS,JSTMON	;IS IT IN MONITOR MODE?
	PUSHJ	P,MONTR		;YES
	PUSHJ	P,USRS		;NO
OUT2:	PJRST	LOGFL		;UPDATE THE LOG FILE.
	IFGE	FTOPR,<
OUT3:	POP	P,C		;POP ONE LEVEL
OUT5:	MOVEM	F,FLAGS(B)	;SAVE FLAGS
	JRST	STAG2		;GO TO NEXT JOB

OUT6:	SETZM	CTLCNT(B)	;RESET THE CHARACTER COUNT
	PUSHJ	P,UPDCTL	;UPDATE CTL POINTER
	MOVEM	A,CTLPTR(B)	;SAVE THE POINTER INTO THE DATA AREA
	POPJ	P,		;RETURN
	>

PRET:	MOVEM	BUF,PCWORD(B)	;SAVE PC IN PC WORD
PRET1:	PJRST	STOP6		;SAVE FLAGS AND RETURN

	IFGE	FTOPR,<

UPDCTL:	TRNN	F2,F2.FST	;IS IT IN CORE TYPE?
	SKIPA	A,BUFTAB	;NO.
	SKIP	A,BUFTAB(JB)	;YES
	HRLI	A,(POINT 7,0)
	AOS	A
	POPJ	P,		;RETURN



MONTAB:	SIXBIT/TALK/
	SIXBIT/ATTACH/
	SIXBIT/DETACH/
	SIXBIT/CCONTI/
	SIXBIT/CSTART/
	SIXBIT/SEND/
MONSIZ==.-MONTAB
	>
	IFGE	FTOPR,<
SUBTTLE BACKTO COMMAND
;HERE CHECK THE VALIDITY OF BACKTO COMMAND

BAKACT:	MOVE	D,[POINT 24,C,35]
	HRLZ	A,JOBSB(B)	;GET THE JOB#
	HRRI	A,JBTKCT	;KILO-CORE-TICKS
	GETTAB	A,		;
	JFCL			;
	HRLZ	C,JOBSB(B)	;GET THE JOB#
	HRRI	C,JBTRCT	;DISK READS
	GETTAB	C,		;DO A GETTAB
	JFCL			;
	LDB	C,D		;GET DISK WRITES
	ADD	A,C		;SAVE IT IN AC A
	HRLZ	C,JOBSB(B)	;GET THE JOB#
	HRRI	C,JBTWCT	;SETUP FOR GETTAB
	GETTAB	C,		;
	JFCL			;
	LDB	C,D		;GET DISK READS
	ADD	A,C		;UPDATE AC A
	CAMG	A,BAKCHK(B)	;HAS JOB DONE SOMETHING
	JRST	BAKAC1		;NO. ERROR RETURN
	MOVEM	A,BAKCHK(B)	;YES. NORMAL RETURN
	POPJ	P,		;RETURN
BAKAC1:	POP	P,C
	TRZ	F2,F2.BAK
	TLNN	F,F.LF		;CHECK IF LINE END.
	PUSHJ	P,CRLF1		;NO. SEND<CR>.
	TLZ	F,F.LF		;RESET LF FLAG.
	JRST	SYNER2		;WRITE ERROR MESSAGE AND RETURN
	>
	IFGE	FTOPR,<
SUBTTLE READ A PTY
;HERE READ PTY OUTPUT. SAVE IT IN LOG FILE. SAVE ALSO LAST OUTPUT 
;BUFFER

INP:	PUSHJ	P,INPT3		;READ THE OUTPUT FROM THE JOB
	JRST	OUTPT6		;RETURN TO MAIN PROGRAM
	>

INPT3:	PUSHJ	P,GO5		;DO AN INPUT ON THIS CHANNEL
INPT1:	PUSHJ	P,PTYINP	;GET A CHARACTER
	POPJ	P,		;RETURN
	JUMPE	CH,INPT1	;IGNORE BLANKS
	TRNE	F2,F2.OPR	;IS OPERATOR COMMAND FLAG ON?
	PUSHJ	P,OPERTR	;YES. PROCESS IT.
	CAIN	CH,""""		;IS IT QUOTES?
	PUSHJ	P,[TLNN F,F.LF	;IS IT QUOTES?
		POPJ P,			;RETURN
		TRO F2,F2.QTS		;SET THE QUOTES SEEN FLAG
		PJRST OPERT1		;TYPEOUT AND RETURN
				]
	PUSHJ	P,LASLIN	;SAVE LAST INPUT LINE
	LDB	A,[POINT 7,ERRCOD(B),28]
	CAME	CH,A		;CHECK IF THIS CHARACTER
	CAIN	CH,"?"		;IS IT ?
	PUSHJ	P,QUSMRK	;YES
	TRNN	F,F.END		;IS KJOB COMMAND ISSUED?
	PUSHJ	P,INPT2		;WRITE IT IN LOG FILE
	JRST	INPT1		;GO GET NEXT CHARACTER

SUBTTLE LOG FILE LABELS
USRS:	TLZN	F,F.LF		;RESET LF FLAG IF SET.
	POPJ	P,		;RETURN 
	PUSH	P,CH		;SAVE CH
	PUSHJ	P,TIMLOG	;WRITE TIME
	MOVEI	T2,[SIXBIT/USER  /]
	PUSHJ	P,BAOPR1
	PJRST	POPJCH		;RESTORE AC CH AND RETURN

MONTR:	TLZN	F,F.LF		;RESET LF FLAG IF SET.
	JRST	CPOPJ1		;NO RETURN
	PUSH	P,CH		;SAVE CH
	PUSHJ	P,TIMLOG	;WRITE TIME IN LOG FILE.
	MOVEI	T2,[SIXBIT/MONTR /]
	PUSHJ	P,BAOPR1	;WRITE MONTR LABEL
CPOPCH:	POP	P,CH		;RESTORE CH
	JRST	CPOPJ1		;RETURN


OPERTR:	LDB	A,[POINT 7,ERRCOD(B),35]
	TLNE	F,F.LF		;IS LF FLAG ON?
	CAME	CH,A		;IS IT OPER CHARACTER?
	POPJ	P,		;NO. RETURN
	TRO	F2,F2.STP	;WAIT FOR THE OPERATOR
OPERT1:	PUSH	P,CH		;SAVE THE CHARACTER
	PUSHJ	P,NAMSUB	;YES. TYPEOUT THE NAME ETC,
	TLO	F,F.TTY		;SET FLAG TO TYPE ON TTY
	PJRST	POPJCH		;RETURN

SUBTTLE PROCESS JOB ERRORS
QUSMRK:	TLNN	F,F.LF		;IS LF FLAG ON?
	POPJ	P,		;NO. RETURN
	HRRZS	ERRCOD(B)	;CLEAR ERROR CODE
	TLNE	STS,JSTJNA	;YES. IS JOB ASSIGNED?
	TLNN	STS,JSTLOG	;YES. IS JOB LOGGED IN?
	PJRST	QUSMK3		;NO.
QUSMK4:	CAIE	CH,"?"		;IS IT ?MARK?
	JRST	QUSM11		;NO. CHECK FOR ERROR COMMAND.
	TRNN	F2,F2.NER	;IS NO ERROR PROCESSING ON?
	JRST	QUSM10		;NO.
QUSMK9:	PUSHJ	P,QUSMK8	;CHECKOUT WHAT KIND OF ERROR IT IS?
QUSM11:	TRO	F,F.QSMK	;YES. SET ERROR FLAG AND RETURN
	TRNE	F2,F2.SIL	;IS SILENCE FLAG ON?
	TRO	F2,F2.ERL	;DONOT SUPPRESS ?LINE.
	POPJ	P,		;RETURN
QUSM10:	LDB	A,[POINT 7,ERRCOD(B),28]
	JUMPE	A,QUSM11	;STANDARD ERROR PROCESSING.
	CAME	CH,A		;IS ERROR COMMAND?
	PJRST	QUSMK9		;YES. CHECK TIME LIMIT AND RETURN
	PJRST	QUSM11		;SET ERROR FLAG AND RETURN
QUSMK3:	PUSHJ	P,ERCODE	;GET THE ERROR CODE.
	CAIE	A,ERR.TA	;IS IT ERROR CODE 1?
	PJRST	QUSM11		;NO. DO NORMAL PROCESSING.
	HRRZS	ERRCOD(B)	;CLEAR ERROR CODE
	POPJ	P,		;DISREGARD THE ERROR AND RETURN

INPT2:	TRNE	F2,F2.SIL	;IS SILENCE FLAG ON?
	JRST	INPT7		;YES. CHECK FURTHER
INPT6:	TLNE	STS,JSTMON	;IS IT IN MONITOR MODE?
	PUSHJ	P,MONTR		;YES. IT IS MONITOR MODE.
	PUSHJ	P,USRS		;NO. DATA OR CUSP MODE.
INPT4:	PUSHJ	P,CONCHR	;IS LF FF ETC?
	JRST	.+2		;NO
	PUSHJ	P,INPT5		;CHECK IF LF ETC?
	TRNN	F2,F2.SIL	;IS SILENCE FLAG ON?
	PJRST	LOGFL		;RETURN
	POPJ	P,		;RETURN

INPT7:	TRNN	F2,F2.ERL	;IS ? LINE ON?
	JRST	INPT4		;NO. SUPPRESS THE LINE
	TRZ	F2,F2.SIL	;SUPPRESS THE SILENCE FLAG
	JRST	INPT6		;YES. O.K TO TYPEOUT

INPT5:	TLO	F,F.LF		;SET LF FLAG
	TRZN	F2,F2.ERL	;RESET ERROR LINE FLAG
	POPJ	P,		;RETURN
	TRO	F2,F2.SIL	;SET SILENCE FLAG ON
	PJRST	CRLF2		;GO WRITE LF IN LOG FILE


PTYINP:	SOSGE	PTIBUF+2(B)	;UPDATE CHARACTER COUNT.
	POPJ	P,		;RETURN
	ILDB	CH,PTIBUF+1(B)	;GET A CHARACTER
	JRST	CPOPJ1		;SKIP RETURN

NXTCH1:	PUSHJ	P,GO5		;DO AN INPUT.
NXTCHR:	PUSHJ	P,PTYINP	;GET A CHARACTER
	JRST	NXTCH1		;NO MORE.
	JUMPE	CH,NXTCHR	;IGNORE NULLS
	POPJ	P,		;RETURN
SUBTTLE LOGIN ERRORS
;HERE GET THE ERROR CODE FROM LOGIN FOR PROPER ERROR PROCESSING.

ERCODE:	SETZB	BUF,TCOM1		;CLEAR A AND TCOM1
ERCOD1:	PUSHJ	P,INPT2		;WRITE IT IN LOG FILE
	PUSHJ	P,NXTCHR	;GET NEXT CHARACTER
	AOS	TCOM1		;UPDATE CURRENT CHARACTER COUNT.
	CAIN	CH,")"		;IS IT A RIGHT BRACKET?
	PJRST	ERCOD2		;YES. RETURN
	CAIG	CH,"9"		;CHECK IF A NUMBER.
	CAIGE	CH,"0"		;
	JRST	ERCOD3		;NOT A NUMBER
	SUBI	CH,"0"		;CHANGE IT TO BINARY
	SKIPA	BUF,CH		;SAVE IT IN AC A
ERCOD3:	CAIN	CH,"("		;IS IT LEFT BRACKET?
	JRST	ERCOD1		;YES.
ERCOD4:	HRRZS	ERRCOD(B)	;CLEAR THE ERROR CODE
	JRST	CPOPJ1		;RETURN SKIP
ERCOD2:	MOVE	C,TCOM1		;
	CAIE	C,3		;THREE CHARACTERS?
	JRST	ERCOD4		;NO. ERROR RETURN
	HRLM	BUF,ERRCOD(B)	;YES. OK RETURN
	POPJ	P,		;RETURN




QUSMK8:	PUSHJ	P,QUSMK7	;CHECK IF TIME LIMIT EXCEEDED?
	JUMPN	D,CPOPJ1	;NO. KEEP GOING
	POPJ	P,		;RETURN
	IFGE	FTOPR,<
;HERE WHEN ERROR IN JOB OCCURS SET F.QSMK FLAG.
;IF HOWEVER IT IS DUE TO TIME LIMIT EXCEEDED FOR THE JOB
;ALLOW THE USER A FIXED %AGE OF ORIGINAL REQUEST EXTRA
;AND CONTINUE WITH THE JOB.


QUSMK1:	TLNE	F,F.INTL	;IS INITIL SEQUENCE OVER?
	PJRST	SYNER4		;RETURN
	TRNE	F2,F2.CNF	;DID WE SEND SET TIME YET?
	JRST	QUSMK2		;YES. SEND THE CONTINUE COMMAND.
	PUSHJ	P,QUSMK7	;CHECK IF TIME LIMIT EXCEEDED?
	JUMPN	D,CPOPJ1	;NONE. GIVE IT EXTRA T[ME.
	TRNE	F2,F2.ETM	;DID IT GET EXTRA TIME?
	JRST	QUSMK5		;YES. KILL THE JOB
	PUSHJ	P,SRCHE6	;WHAT KIND OF ERROR?
	TLNN	STS,JSTMON	;IS IT IN MONITOR MODE?
	PJRST	DEAS1		;NO. MAKE SURE IT IS
	HRRZ	C,Q.ILIM(B)	;COMPUTE EXTRA TIME FOR THE JOB
	IMULI	C,MORTIM	;MULTIPLY BY ESTRA TIME.
	IDIVI	C,^D100		;GET THE EXTRA TIME
	TRO	F2,F2.CNF+F2.ETM	;EXTRA TIME ALLOCATED
	JUMPE	C,QUSMK5	;KILL THE JOB
	PJRST	SETTIM		;SEND SET TIME COMMAND.
QUSMK6:	TRZA	F,F.QSMK	;RESET ERROR FLAG
QUSMK2:	TRO	F,F.KERR	;SET LOOK FOR ERROR LABEL
	TRZ	F2,F2.CNF	;CONTINUE
	PJRST	STOP6		;SAVE FLAGS AND RETURN


QUSMK5:	TRO	F,F.FIN		;YES. SET END OF CTL FILE SEEN.
	TRNN	F,F.KILL+F.END	;IS IT IN KJOB ETC.,
	PJRST	QUSMK6		;CONTINUE THE JOB.
	MOVEI	T2,[SIXBIT/CONTIN/]
	PUSHJ	P,SIXLOG	;SEND IT TO THE JOB
	PUSHJ	P,SETTM1	;SEND <CR> TO THE JOB
	PJRST	QUSMK6		;RETURN
	>


QUSMK7:	HRLZ	C,JOBSB(B)	;YES. GET THE JOB#
	HRRI	C,JBTLIM	;SETUP GETTAB ARGS.
	GETTAB	C,
	JFCL			;IGNORE ERRORS.
	LDB	D,[POINT 24,C,35]	;HOW MUCH MORE TIME?
	POPJ	P,		;RETURN
	IFGE	FTOPR,<
SUBTTLE LOGIN AND SET COMMAND
;HERE SEND ^C^C ACROSS PTY
CTRC1:	PUSHJ	P,CTRC5		;NO. MAKE SURE IT IS.
	TLO	F,F.INTL	;SET INITIAL COMMAND FLAG.
	MOVEI	T2,[SIXBIT/LOGIN/]
	PUSHJ	P,SIXLOG	;LOGIN THE JOB
	PUSHJ	P,SPACE		;SEND ASPACE
	HLRZ	C,Q.PPN(B)	;GET PROJ#
	PUSHJ	P,SNOCT		;SENT OCTAL NUMBER TO THE JOB
	MOVEI	CH,"/"		;GET / FOR LOGIN
	TRNN	GF,LGIN		;IS , OR / FOR LOGIN?
	MOVEI	CH,","		;NO IT IS ,.
	PUSHJ	P,SIXLO2	;SEND IT TO THE JOB
	HRRZ	C,Q.PPN(B)	;GET PROG#
	PUSHJ	P,SNOCT		;SEND OCTAL NUMBER TO THE JOB
	PUSHJ	P,SETTM1	;SEND<CR> TO LOG FILE
	PJRST	LOGFL2		;CLOSE FILE AND RETURN

CTRCX:	TLNE	F,F.SET		;IS ARROW FLAGSET?
	JRST	CTRCX1		;SEND SPOOL COMMAND
	TRNE	F,F.QSMK	;IS ERROR FLAG ON?
	TRNE	F,F.KERR	;IS THIS ERROR FLAG ON?
	JRST	PLSTWO		;CONTINUE
	JRST	ERRANL		;YES. PROCESS LOGIN ERROR.
PLSTWO:	HRRZ	C,Q.ILIM(B)	;GET THE CPU TIME
	SKIPN	C		;IS TIME ARG ZERO?
	MOVEI	C,DEFTIM	;YES.USE DEFAULT TIME
	PUSHJ	P,SETTIM	;GO SEND TIME COMMAND
	TLO	F,F.SET		;SET FLAG THAT TIME COMMAND PROCESSED
	PJRST	OUTPT3		;GO OUTPUT AND RETURN

SETTIM:	MOVEI	T2,[SIXBIT/SET/]
	PUSHJ	P,SIXLOG	;SEND SET COMMAND TO THE JOB
	PUSHJ	P,SPACE		;SEND A SPACE
	MOVEI	T2,[SIXBIT/TIME/]	;SEND TIME ARGUMENT
	PUSHJ	P,SIXLOG	;SEND TIME ARGUMENT
	PUSHJ	P,SPACE		;SEND A SPACE
	PUSHJ	P,SNDEC		;SEND TIME IN DECIMAL
	>
SETTM1:	PUSHJ	P,SIXCLF	;SEND<CR> TO THE JOB
	PJRST	CTRC3		;DO AN OUTPUT AND RETURN

SNDEC:	IDIVI	C,^D10		;CONVERT TO DECIMAL
	PUSH	P,D		;SAVE D
	SKIPE	C		;IS IT ALL DONE?
	PUSHJ	P,SNDEC		;NO. 
SNDEC1:	POP	P,CH		;YES. RESTORE D IN CH
	ADDI	CH,"0"		;CONVERT TO ASCII
	PJRST	SIXLO2		;SEND IT TO THE JOB
CTRC5:	PUSHJ	P,CTRC4		;SEND ^C TO THE JOB
CTRC7:	PUSHJ	P,JBSTAT	;GET THE JOB STATUS
	TLNE	STS,JSTINP	;DOES JOB WANT TO OUTPUT.
	PUSHJ	P,INPT3		;YES. DO AN INPUT.
	TLNE	STS,JSTOUT	;DOES JOB WANT TO INPUT?
	PJRST	ERNTR4		;SET TI BIT AND RETURN
	PUSHJ	P,XZZZ		;SLEEP FOR A SECOND
	PJRST	CTRC7		;TRY IT ONCE MORE
	IFGE	FTOPR,<

CTRCX1:	MOVEI	T2,[SIXBIT/SET/]
	PUSHJ	P,SIXLOG	;SEND SET COMMAND
	PUSHJ	P,SPACE		;SEND A SPACE
	MOVEI	T2,[SIXBIT/SPOOL/]
	PUSHJ	P,SIXLOG	;SEND SPOOL COMMAND
	PUSHJ	P,SPACE		;SEND A SPACE
	MOVEI	T2,[SIXBIT/ALL/]
	PUSHJ	P,SIXLOG	;SEND IT TO THE JOB
	TLZ	F,F.SET+F.INTL	;RESET INITIAL FLAGS
	PUSHJ	P,SETTM1	;SEND <CRJ> TO THE JOB
	PUSHJ	P,CTRC7		;GETY THE STATUS
	IFN	REMSW,<
	PUSHJ	P,REMOTE	;CHECK IF FROM REMOTE SITE.
		>
	PJRST	OUTPT3		;SAVE FLAGS AND RETURN

	IFN	REMSW,<
;HERE FIGURE OUT IF JOB FROM REMOTE SITE.

REMOTE:	HRRZ	C,Q.DEV(B)	;GET THE STATION CODE.
	CAIG	C,77		;IS IT GREATER THAN 77?
	CAIG	C,0		;IS IT GREATER THAN 0?
	JRST	REMOT1		;MAKE IT AT CENTRAL SITE.
	MOVE	D,[SIXBIT/OPR0/]
	WHERE	D,		;DO WHERE UUO
	JRST	REMOT1		;AT CENTRAL SITE.
	CAMN	C,D		;IS IT CENTRAL SITE?
	JRST	REMOT1		;YES. RETURN
	MOVEI	T2,[SIXBIT/LOCATE/]
	PUSHJ	P,SIXLOG	;SEND IT TO THE JOB
	PUSHJ	P,SPACE		;SEND SPACE
	PUSHJ	P,SNOCT		;SEND STATION #
	PJRST	SIXCLF		;SEND <CR> AND RETURN



REMOT1:	POP	P,C		;REMOVE ONE FROM THE STACK
	JRST	OUTPT6		;USE CENTRAL SITE
		>
	>
SNDSIX:	HRLI	T2,440600
SNDSI1:	ILDB	CH,T2		;GET A CHARACTER
	JUMPE	CH,CPOPJ	;RETURN IF NULL
	ADDI	CH," "		;CHANGE IT TO ASCII
	PUSHJ	P,SNDPTY	;SEND IT TO THE JOB
	PUSHJ	P,DSKLOG	;SEND IT TO DISK LOG
	TLNE	T2,770000	;HAVE WE SENT ALL CHARACTERS
	JRST	SNDSI1		;NO GET NEXT CHARACTER
	POPJ	P,		;RETURN

SNOCT:	IDIVI	C,^D8		;OCTAL NUMBERS
	PUSH	P,D		;SAVE AC D
	SKIPE	C		;IS IT ZERO
	PUSHJ	P,SNOCT		;GET NEXT CHARAC
	PJRST	SNDEC1		;CHANGE IT TOASCII @ND RETURN



DEAS1:	TLNE	STS,JSTOUT	;IS JOB WANTING OUTPUT?
	PJRST	CTRC4		;YES. SEND ^C TO THE JOB.
CTRC2:	MOVEI	CH,CONTRLC	;GET CONTROL C
	PUSHJ	P,SNDPTY	;SEND OVER THE PTY
CTRC4:	MOVEI	CH,CONTRLC	;GET CONTROL C
CTRC6:	PUSHJ	P,SNDPTY	;SEND OVER THE PTY
CTRC3:	PJRST	SNDPTO		;OUTPUT TO PTY


DEAS:	PUSHJ	P,DEAS1		;SEND ^C TO THE OBJECT JOB
	PJRST	CTRC7		;DO AN INPUT AND RETURN


SUBTTLE SIXBIT OVER PTY
;ROUTINE WRITES IN LOG FILE AND SENDS A COMMAND TO THE JOB


SIXLOG:	HRLI	T2,440600	;SETUP THE BYTE POINTER
SIXLO1:	ILDB	CH,T2		;GET A CHARACTER
	JUMPE	CH,CPOPJ	;RETURN IF NULL
	ADDI	CH," "		;CHANGE IT TO ASCII
	PUSHJ	P,SIXLO2	;WRITE IT IN LOG, SEND TO JOB
	TLNE	T2,770000	;ARE WE DONE?
	JRST	SIXLO1		;NO. GET THE NEXT CHARACTER
	POPJ	P,		;RETURN


SPACE:	MOVEI	CH," "		;GET A SPACE
SIXLO2:	PUSHJ	P,SNDPTY	;SEND IT TO THE JOB
SIXLO3:	TLNE	F,F.SUPZ	;IS /Z MODE ON?
	POPJ	P,		;YES. RETURN
	PUSH	P,T2		;SAVE T2
	PUSH	P,C		;SAVE AC C
	PUSHJ	P,OUT7		;SAVE IT IN LOG FILE
	POP	P,C		;RESTORE C
	POP	P,T2		;RESTORE T2
	PJRST	DSKLOG		;WRITE IT IN DSK LOG


SIXCLF:	MOVEI	CH,CR		;GET CR
	PUSHJ	P,SIXLO2	;SEND IT TO LOG AND JOB
	MOVEI	CH,LF		;GET LF
	PUSHJ	P,SIXLO2	;SEND IT TO JOB AND LOG
SIXCL1:	TLO	F,F.LF		;SET LF FLAG
	TLZ	F,F.LOUT	;RESET THE OUTPUT LINE BUFFER
	PJRST	STOP6		;SAVE FLAGS AND RETURN
;ROUTINE SENDS CHARACTERS OVER THE PTY.
SNDPTY:	SOSG	PTOBUF+2(B)	;COUNT THE CHARACTERS
	JRST	SNDPTB
	IDPB	CH,PTOBUF+1(B)	;DEPOSIT A CHARACTER
	PJRST	LASOUT		;WRITE LINE BUFFER AND RETURN
SNDPTB:	PUSHJ	P,SNDPTO	;OUTPUT TO PTY
	JRST	SNDPTY

;HERE OUTPUT TO THE PTY


SNDPTO:	PUSH	P,T2		;SAVE AC T2
	MOVEI	T2,1		;FLAG TO SET PTY
	MOVE	A,[OUTPUT ]
	PUSHJ	P,IOUUO		;EXECUTE IT
	PJRST	LOGFL4		;RESTORE AC T2 AND RETURN


	;HERE TYPEOUT THE NUMBER ON TTY OCTAL OR DECIMAL AND DSKLOG
	;IT USES ACCUMULATORS A,B,C,D
TYOCT:	SKIPA	C,[^D8]		;OCTAL RADIX
TYDEC:	MOVEI	C,^D10		;DECIMAL RADIX
TYDC1:	IDIV	A,C		;DIVIDE BY PROPER RADIX
	PUSH	P,B		;SAVE REMAINDER
	SKIPE	A		;IS IT ZERO
	PUSHJ	P,TYDC1		;GO BACK AND WORK ON A.
	POP	P,A		;GET THE REMAINDER.
	ADDI	A,60		;CHANGE IT TO ASCII
TYDC2:	OUTCHR	A		;GET IT OUT TO TTY.
	PUSHJ	P,DSKLOG	;SAVE IT IN DISK LOG.
	POPJ	P,		;RETURN

	IFGE	FTOPR,<
SUBTTLE JOB ERROR PROCESSING
;HERE ANALYSE TYPE OF ERROR AND PROCESS ACCORDINGLY
ERRANL:	TLNE	F,F.SCRF	;IS SUPPRESS <CR> FLAG ON?
	JRST	OUTCTF		;YES, CONTINUE THE JOB THIS TIME
	TLNN	STS,JSTJNA	;IS JOB ASSIGNED?
	JRST	NJOBNA		;NO
	TLNE	STS,JSTLOG	;IS JOB LOGGED IN?
	JRST	ERRAN1		;SEND <CR> AND CHECK FOR IF COMMAND
	HLRZ	A,ERRCOD(B)	;CHECK THE ERROR CODE
	SKIPN	A		;IS IT ZER0?
	JRST	ERCDA2		;IT IS ZERO. NORMAL PROCESSING.
	CAIG	A,ERR.NA	;IS IT 4 OR OVER?
	JRST	ERCDA3		;NO. PROCESS THE CODE
ERCDA2:	PUSHJ	P,JOBNAM	;TYPEOUT JOBNAME
	PUSHJ	P,PRJETC	;WRITE PROJ PROG #
	TYPDSK</? Can't login, Job requeued
!/>
	PUSHJ	P,CTRC5		;SEND TWO CONTOL C'S
	JRST	NJOB1		;GO RESCHEDULE
NJOBNA:	TLNE	F,F.LOGD	;WAS THE JOB EVER LOGGED IN?
	JRST	ERRAN2		;YES
	HLRZ	A,ERRCOD(B)	;IS ERROR CODE ZERO?
	SKIPE	A		;IS IT ZERO?
ERCDA3:	CAIL	A,ERR.NA	;IS ERROR CODE OVER 3?
	JRST	ERCDA1		;YES
	CAIN	A,ERR.SF	;NO. IS IT 2?
	JRST	NJOB1		;YES. SEMIFATAL REQUEUE JOB.
ERRAN2:	TRO	F,F.FIN+F.KILL	;YES. RELEASE JOB FATAL ERROR.
	POP	P,C		;
	JRST	LOOP5		;RETURN
	>
	IFGE	FTOPR,<
ERCDA1:	TRO	GF,JOBNAV	;JOBS NOT AVAILABLE
	TRZ	GF,SLPINF	;DONOT HIBERNATE
NJOB1:	TRO	F,F.REQ		;SET JOB REQUEUED FLAG
	PUSHJ	P,MISCT1	;WRITE REQUEUED MESSAGE
	TRNN	F2,F2.FST	;RESET THE INCORE FLAG
	MOVEM	JB,INCORE	;UPDATE INCORE LOCATION
	TRO	F,F.SETR	;SET THE ENTER ERROR FLAG.
	PUSHJ	P,REL8		; AND CLOSE THE FILE
	POP	P,C		;UPDATE THE PDL REGISTER
	JRST	LOOP1		;CONTINUE TO PROCESS OTHER JOBS

ERRAN1:	PUSHJ	P,QUSMK1	;CHECK IF TIME LIMIT EXPIRED.
	JRST	STAG2		;YES. GIVE IT EXTRA TIME AND RETURN.
	PUSHJ	P,CRLF1		;SEND <CR> TO LOG FILE
ERRAN8:	TLZ	F,F.LF		;RESET LF FLAG
	JRST	IFPRC1		;PROCESS THE JOB


ERRAN3:	TRNE	F,F.END		;IS LOGOUT STARTED?
	TLNN	STS,JSTLOG	;IS JOB LOGGED IN?
	JRST	STAG2		;NO. RETURN
	TRNE	F,F.QSMK	;IS THERE AN ERROR?
	PUSHJ	P,ERRAN7	;GO CHECK IF TIME LIMIT EXCEEDED?
	TRNN	F2,F2.KBW	;IS KJOB O.K.?
	JRST	ERRAN6		;NO. IT IS SICK. HELP IT.
	PUSHJ	P,JOBTY		;SEND SUBJOB# ETC
	PUSHJ	P,TABT		;SEND A TAB TO THE JOB
	PUSHJ	P,JOBNAM	;TYPEOUT JOBNAME
	PUSHJ	P,PRJETC	;TYPEOUT P,PN
	TYPDSK</? BATCON unable to KJOB
OPR---Attach to kill job and then BL-$
Waiting...
!/>
	JRST	OUTC11		;SET FLAG FOR OPERATOR ACTION AND RETURN
	>


	IFGE	FTOPR,<
ERRAN6:	PUSHJ	P,LOGFL1	;OPEN THE LOG FILE
	TRZ	F,F.KILL+F.END	;RESET KILL JOB FLAGS
	TLNN	STS,JSTMON	;IS IT IN MONITOR MODE?
	PUSHJ	P,DEAS		;NO. MAKE SURE IT IS.
	MOVEI	T2,[SIXBIT/DEASSI/]
	PUSHJ	P,SIXLOG	;SEND IT TO THE JOB
	PUSHJ	P,SETTM1	;SEND <CR>
	PUSHJ	P,CTRC7		;GET THE RESPONSE

	REPEAT	0,<
	IFN	DEBUG,<

	MOVEI	T2,[SIXBIT/DCORE/]
	PUSHJ	P,SIXLOG	;********
	PUSHJ	P,SPACE		;***********
	MOVEI	T2,[SIXBIT/KJOB.B/]
	PUSHJ	P,SIXLOG	;*********
	MOVEI	T2,[SIXBIT/UG/]
	PUSHJ	P,SIXLOG	;*********
	PUSHJ	P,SETTM1	;********
	PUSHJ	P,CTRC7		;*********

		>
		>

	MOVEI	T2,[SIXBIT?KJ/W/B?]
	PUSHJ	P,SIXLOG	;SEND IT TO THE JOB
	PUSHJ	P,SETTM1	;SEND <CR> TO THE JOB
	TRO	F,F.END		;RESET THE KILL JOB FLAGS
	TRO	F2,F2.KBW	;SET KJOB SICK FLAG
	PUSHJ	P,LOGFL2	;CLOSE THE LOG FILE
ERRAN4:	TRO	F,F.FIN+F.KILL	;SET EOF FLAG
	JRST	STAG2		;RETURN


ERRAN7:	PUSHJ	P,QUSMK7	;IS TIME LIMIT EXCEEDED?
	JUMPN	D,CPOPJ		;NO. RETURN
	TLNN	STS,JSTMON	;IS IT MONITOR MODE?
	PUSHJ	P,DEAS		;NO. MAKE SURE IT IS
	PUSHJ	P,GO2		;SEND CONTINUE COMMAND
	PUSHJ	P,SETTM1	;WRITE <CR> IN LOG FILE AND OUTPUT
	JRST	OUT3		;RETURN
	>
	IFGE	FTOPR,<
SUBTTLE IF COMMAND PROCESSING
PLUS4:	TRO	F,F.NTIF	;NOT IF COMMAND
	JRST	SRCHER		;SEARCH FOR THE LABEL
IFPRCS:	JSP	BUF,RESTOR	;RESTORE POINTERS
	TRNN	F2,F2.BAK	;IS IT BACKTO COMMAND?
	TRNE	F,F.GOTO	;IF IT GOTO COMMAND?
	JRST	RGTBRK		;GO PROCESS IT
	JRST	ERRAN1		;SEND <CR> TO THE JOB.
IFPRC1:	JSP	T1,GETCT3	;GET NONSPACE CHARACTER
	TRNE	F,F.KERR	;IS IT KILL COMMAND WITH ERROR ARG.
	JRST	LABEL0		;YES. SEARCH FOR %ERR OR %FIN
	CAIE	CH,"."		;IS IT PERIOD?
	JRST	SRCCOM		;SEARCH FOR %ERR OR %CERR LABEL
	SETZB	C,COM		;YES. CLEAR COM AND AC C
	MOVE	D,[POINT 6,COM]	;SETUP BYTE POINTER
	JSP	T1,COM3CK	;CHECK THE COMMAND.
	PUSHJ	P,COMMON	;IS IT MONITOR COMMAND?
	JRST	IFPRC2		;NO.
	MOVE	D,.JBFF		;GET FIRST FREE LOCATION
	SUBI	D,CTL3		;LENGTH OF THE BATCH TABLE
	CAILE	D,(C)		;IS IT MONITOR COMMAND?
	JRST	IFPRC2		;YES.
	PUSHJ	P,MACHCM	;MATCH THE COMMAND
	JRST	SILREV		;IT MATCHES
IFPRC2:	PUSH	P,CH		;SAVE THE CHARACTER
	TRNE	F,F.IF		;IS IT IF COMMAND?
	PUSHJ	P,BMSG5		;YES. WRITE TIME AND LABEL.
	MOVEI	CH,"."		;PUT PERIOD IN LOG FILE
	PUSHJ	P,OUT7		;WRITE IT IN LOG FILE
	POP	P,CH		;RESTORE THE CHARACTER
	TLZ	F,F.PLS		;RESET PLEASE COMMAND SEEN FLAG
	TRZ	F2,F2.BAK	;RESET BACKTO SENN FLAG.
	TRZ	F,F.KILL	;RESET THE KILL COMMAND
	TRZE	F2,F2.OPR	;RESET F2.OPR SEEN FLAG
	JRST	PLUS4		;SEARCH FOR %ERR OR %CERR
	TLZE	F,F.SYNT	;IS IT FORBIDDEN COMMAND?
	JRST	SYNER5		;YES. SYNTAX ERROR
	TRZN	F,F.IF		;IS IT IF COMMAND?
	JRST	PLUS4		;NO
	PUSHJ	P,READCT	;WRITE COMMAND IN LOG FILE
	JFCL			;...
CKCHK:	CAIN	CH,"("		;IS IT LEFT BRACKET?
	JRST	IFPR0		;YES. PROCEED
	PUSHJ	P,SPCES		;NO. IS IT SPACE OR TAB?
	JRST	SYNLOG		;IT IS SYNTAX ERROR
	PUSHJ	P,LOGFL		;WRITE IT IN LOG FILE
	JSP	T1,GETCT3	;GET FIRST NONSPACE CHARACTER.
	JRST	CKCHK		;IS IT LEFT BRACKET?
	>
	IFGE	FTOPR,<
IFPR0:	PUSHJ	P,OUT7
	SETZB	C,TCOM1		;SETUP COMMAND BYTE POINTER
	MOVE	T2,[POINT 6,TCOM1]	;SETUP BYTE POINTER
IFPR1:	PUSHJ	P,CHRLOG	;GET CHARACTER
	CAIN	CH,")"		;IS IT RIGHT BRACKET?
	JRST	IFPR3		;YES.
	PUSHJ	P,LABEL7	;CONVERT TO SIXBIT
	TLNE	T2,770000	;ARE WE DONE?
	JRST	IFPR1		;NO.
MINTWO:	PUSHJ	P,CHRLOG	;YES
	CAIN	CH,"R"		;IS IT R?
	JRST	MINTWO		;YES. GET NEXT CHARACTER.
	CAIN	CH,")"		;IS RIGHT BRACKET?
IFPR3:	SKIPE	TCOM1		;IS IT ZERO?
	PUSHJ	P,IFARG		;CHECK THE CONDITIONS
	JRST	SYNERR		;SYNTAX ERROR



;HERE IF COMMAND WITH ERROR/NOERROR PROCESSING


ERRCHK:	TRZN	F,F.ERR		;IS ERROR ARGUMENT ON?
	TRC	F,F.QSMK	;NO.COMPLEMENT THIS BIT
	TRZN	F,F.QSMK	;YES. CHECK IF ERROR CONDITION?
	JRST	ERRCH1		;GO TO THE NEXT LINE
	PUSHJ	P,CRLF1		;SEND <CR>
	SKIPA			;SKIP ALWAYS
ERRCH1:	PUSHJ	P,RESLIN	;READ THE REST OF LINE
	TLZ	F,F.BRK+F.SCRF	;RESET THE FLAGS
	TLO	F,F.LF		;SET LF FLAG
	JRST	OUTCTF		;PROCEES THE LINE


;HERE PROCESS THE LINE
RESLIN:	PUSHJ	P,CTLOUT	;GET A CHRACTER
	JRST	OUTPT4		;IN CASE OF EOF
	PUSHJ	P,OUT7		;SAVE IT IN LOG FILE
RESLN1:	PUSHJ	P,CONCHR	;IS LF FF ETC?
	JRST	RESLIN		;NO GET NEXT CHARACTER
	POPJ	P,		;RETURN
	>
	IFGE	FTOPR,<
SUBTTLE GOTO COMMAND SEARCH LABEL
;HERE .IF (CONDITION) .GOTO LABEL

LABEL0:	PUSHJ	P,OUT7		;WRITE IT IN LOG FILE
LABEL1:	TRZ	F,F.IF+F.ERR+F.GOTO
	TRZ	F2,F2.STP+F2.OPR	;CLEAR OPERATOR COMMAND FLAGS
	TRNE	F2,F2.BAK	;IS IT BACTO COMMAND?
	PUSHJ	P,LABE15	;YES. PROCESS IT
LABE14:	HRROI	BUF,-SKPLIN	;GET NEGATIVE OF LINES TO SKIP
LABEL5:	SETZM	COM		;CLEAR WORD COM AND AC C
	MOVE	T2,[POINT 6,COM]	;SETUP BYTE POINTER
	TRZE	F,F.NTIF	;IT IS NOT .IF COMMAND.
	JRST	LABEL4		;READ REST OF THE LINE
	CAIN	CH,"%"		;IS IT %?
	PUSHJ	P,LABEL7	;YES SAVE IT
LABEL2:	PUSHJ	P,CHRLOG	;GET CHARACTER SAVE IT IN LOG FIL
	PUSHJ	P,ALPNUM	;IS IT ALPHANUMERIC?
	JRST	LABEL9		;NO
LABEL8:	PUSHJ	P,LABEL7	;CHANGE TO SIXBIT AND SAVE IT
	TLNE	T2,770000	;IS IT SIX CHARACTERS?
	JRST	LABEL2		;NO. GO GET NEW CHARACTER
	PUSHJ	P,CHRLOG	;GET NEW CHARACTER
	PUSHJ	P,ALPNUM	;IS IT ALPHANUMERIC?
	JRST	LABEL6		;NO
LABEL4:	PUSHJ	P,CHRLOG	;GET NEXT CHARCTER
LABE20:	PUSHJ	P,CONCHR	;IS IT LF FF ETC?
	JRST	LABEL4		;NO. GET NEXT CHARCTER
	AOJL	BUF,LABEL5	;SEARCH FOR NEXT LABEL
	TRO	GF,TTYIOW	;SET FLAG TO COME BACK
	JSP	BUF,PRET	;SAVE THIS POSITION AND RETURN
	TLZ	F,F.LF		;RESET LINE FEED FLAG
	JRST	LABE14		;GO CHECK FOR NEXT LABEL.
LABEL9:	CAIN	CH,"%"		;IS IT %?
	JRST	LABEL8		;YES. SAVE IT
LABEL6:	CAIN	CH,":"		;IS IT :?
	SKIPN	T2,COM		;IS IT EMPTY LABEL?
	JRST	LABE20		;YES. GO TO NEXT ONE
	CAME	T2,LABEL(B)	;CHECK AGAINST WHAT WE WANT.
	JRST	LABEL3		;READ REST OF THE LINE
LABE10:	SETZM	LABEL(B)	;CLEAR THE LABEL
	TRZ	F,F.QSMK+F.KERR	;RESET ERROR FLAG
	TLNE	STS,JSTMON	;IS THE JOB IN MONITOR MODE?
LABE11:	PUSHJ	P,CRLF1		;YES. SEND <CR> TO THE JOB
	TRZE	F2,F2.BAK	;IS IT BACKTO COMMAND?
	PUSHJ	P,LABE16	;YES.SET THE PARAMETERS
	JRST	OUTCTF		;YES IT MATCHES. RETURN
LABE15:	MOVEI	T2,1		;GET THE FIRST BLOCK
	MOVEM	T2,BKICNT(B)	;SAVE IT FOR BACKTO COMMAND
	CAME	T2,USICNT(B)	;IS IT DIFFERENT?
LABE17:	PUSHJ	P,RESTR1	;GET IT IN CORE
	PUSHJ	P,UPDCTL	;UPDATE CTL POINTER
	MOVEM	A,BKCPTR(B)	;SAVE IT
	SETZM	BKCCNT(B)	;CLEAR THE CHARACTER COUNT
	POPJ	P,		;RETURN
	>
	IFGE	FTOPR,<
LABEL7:	SUBI	CH,40		;CHANGE IT TO SIXBIT
	IDPB	CH,T2		;SAVE IT
	POPJ	P,		;RETURN

	>


LABE16:	MOVE	T2,BKCPTR(B)	;GET THE CONTROL FILE POINTER
	MOVEM	T2,CTLPTR(B)	;SAVE IT
	MOVE	T2,BKICNT(B)	;GET THE CONTROL FILE COUNT
	MOVEM	T2,USICNT(B)	;SAVE IT
	MOVE	T2,BKCCNT(B)	;GET THE CHRACTER COUNT
	MOVEM	T2,CTLCNT(B)	;SAVE IT
	POPJ	P,		;RETURN


ALPNUM:	CAIG	CH,"Z"		;IS IT BEYOND LETTER Z?
	CAIGE	CH,"0"		;IS IT BELOW 0?
	JRST	CPOPJ		;YES
	CAIGE	CH,"A"		;IS IT WITHIN LETTER RANGE?
	CAIG	CH,"9"		;IS IT WITHIN NUMBER RANGE?
	JRST	CPOPJ1		;YES
	JRST	CPOPJ		;NO


	IFGE	FTOPR,<

LABEL3:	CAME	T2,[SIXBIT/%FIN/]	;YES. IS IT %FIN,IT TAKES PRECEDENCE?
	JRST	LABEL4		;NO. KEEP SEARCHING
	>
	IFGE	FTOPR,<
;HERE WE WERE LOOKING FOR %CERR OR %ERR LABEL AND
;IN DOING SO CAME ACROSS %FIN LABEL. SINCE %FIN LABEL HAS
;PRECEDENCE OVER IN ANY OF THE OTHER % LABELS WE DO A CLOSE 
;AND A DUMP COMMAND IF THE LABEL SERCHED FOR WAS %ERR.


	MOVE	C,LABEL(B)	;GET THE LABEL SEARCED FOR
	CAME	C,[SIXBIT/%ERR/]	;
	JRST	LABE10		;NOT %ERR. CONTINUE
	PUSHJ	P,CRLF1		;SEND <CR> TO THE LOG FILE.
	PUSHJ	P,CLOS2		;YES. DO A CLOSE COMMAND.
	PUSHJ	P,CTRC7		;GET RESPONSE
LABE13:	SETZM	LABEL(B)	;CLEAR THE LABEL
	TRZ	F,F.QSMK+F.KERR	;RESET ERROR IN JOB FLAG
	JRST	OUTPT3		;SAVE FLAGS AND RETURN


LABE12:	PUSHJ	P,DUMPE2	;SEND DUMP COMMAND 
	JRST	LABE13		;RETURN


SILREV:	TLZ	F,F.SYNT	;RESET SYNTAX ERROR
	PUSHJ	P,BMSG5		;WRITE TIME STAMP AND LABEL
	PUSHJ	P,HEAD4		;WRITE A PERIOD IN LOG FILE.
	PUSHJ	P,SILRE2	;WRITE IT IN LOG FILE
SILRE3:	TRNE	F,F.FIN		;IS IT END OF CTL FILE?
	JRST	OUT5		;YES RETURN
	JRST	ERRAN8		;GO LOOK FOR THE .IF COMMAND


SILRE2:	PUSHJ	P,READCT	;READT COM WORD
	SKIPA			;SKIP ALWAYS
	PUSHJ	P,OUT7		;WRITE IN LOG FILE
SILRE1:	PUSHJ	P,OUT1		;GET REST OF THE LINE
	PUSHJ	P,LFETC		;IS IT LF?
	JRST	SILRE1		;NO. CONTINUE
	POPJ	P,		;RETURN


	>
	IFGE	FTOPR,<
;HERE PROCESS THE IF ERROR/NOERROR STATEMENT


RGTBRK:	PUSH	P,CTLPTR(B)	;SAVE THE POSITION
	PUSH	P,CTLCNT(B)	; IN THE CTL FILE
	PUSH	P,USICNT(B)	; BUFFER
	TRNE	F2,F2.BAK	;IS IT BACKTO COMMAND
	PUSHJ	P,BAKACT	;CHECK ITS VALIDITY
	TLNN	F,F.LF		;IS LF FLAG ON
	PUSHJ	P,CRLF1		;NO. SEND <CR> TO LOG FILE.
	PUSHJ	P,BMSG5		;WRITEOUT TIME AND LABEL IN LOG FILE
	TLZ	F,F.LF		;RESET LF SEEN FLAG
	PUSHJ	P,GCTLOG	;GET PERIOD
RGTBR1:	PUSHJ	P,CTLOUT	;GET A CHRACTER FROM CTL FILE
	JRST	OUTPT5		;IN CASE EOF
	PUSHJ	P,OUT7		;SAVE IT IN LOG FILE
	PUSHJ	P,SPERTR	;IS IT ALPHABETIC?
	SKIPA	T2,[POINT 6,LABEL(B)]
	JRST	RGTBR1		;YES. GET NEXT CHARACTER.
	SETZB	C,LABEL(B)	;CLEAR LABEL
RGTBR2:	PUSHJ	P,CTLOUT	;GET A CHRACTER FROM CTL FILE
	JRST	OUTPT5		;IN CASE EOF
	PUSHJ	P,OUT7		;SAVE IT IN LOG FILE
	PUSHJ	P,CONCHR	;IS IT LF FF ETC?
	SKIPA			;NO.
	JRST	RGTBR4		;YES. GO PROCESS IT
	PUSHJ	P,ALPNUM	;IS IT ALPHANUMERIC?
	JRST	RGTBR3		;NO.SKIP THE LINE
	PUSHJ	P,LABEL7	;YES. CHANGE IT  TO SIXBIT
	TLNE	T2,770000	;DID WE GET ALL 6 CHARACTERS?
	JRST	RGTBR2		;NO. GET NEXT ONE
RGTBR3:	PUSHJ	P,RESLIN	;GOBBLE THE REST OF LINE.
RGTBR4:	SUB	P,[XWD 3,3]
	SKIPN	LABEL(B)	;CHECK THE LABEL
	JRST	SYNERR		;NONE. IT IS ERROR
	JRST	LABEL1		;PROCESS THE LABEL
	>
	IFGE	FTOPR,<
SUBTTLE %FIN,%ERR,%CERR SEARCH
;HERE WE ENCOUNTERED AN ERROR IN THE JOB LOOKED FOR IF COMMAND
;TO BE ON THE NEXT LINE AND DIDNOT FIND IT. NOW WE ARE LOOKING FOR
;%ERR OR %CERR. IF THESE TWO LABELS ARE IN CONTROL FILE, TRANSFER CONTROL TO STATEMENT
;FOLLOWING THE LABEL, OR ELSE PROVIDE DUMP AND ABORT THE JOB.

SRCHER:	PUSHJ	P,READCT	;COPY COM IN LOG FILE
	JRST	SRCHE7		;GO PROCESS
SRCHE8:	PUSHJ	P,OUT7
SRCHE7:	PUSHJ	P,SRCHE6	;FIND WHAT KIND ERROR?
	JRST	LABEL1		;GO PROCESS THE STATEMENT


SRCHE6:	HRLZ	D,JOBSB(B)	;GET JOB #
	HRRI	D,JBTLIM	;GET THE JOB TIME LIMIT ARG
	GETTAB	D,		;DO A GET TAB
	JRST	SRCHE2		;ERROR RETURN
	TLNE	D,SYSPRG	;IS IT A SYSTEM PROGRAM
	JRST	SRCHE2		;NO. LOOK FOR %CERR
	MOVE	C,[SIXBIT/%ERR/]	;NOT A SYSTEM PROGRAM
SRCHE3:	MOVEM	C,LABEL(B)	;SAVE IT IN LABEL
	POPJ	P,		;RETURN
SRCHE2:	MOVE	C,[SIXBIT/%CERR/]	;HERE IF SYSTEM PROGRAM
	JRST	SRCHE3
	>

	IFGE	FTOPR,<
SRCCOM:	CAIE	CH,"$"		;IS IT A COMMENT LINE?
	CAIN	CH,";"
	JRST	SRCM1		;YES
	CAIN	CH,"%"		;IS IT %SIGN?
	JRST	SRCHE8		;YES. CHECK THE LABEL
	CAIN	CH,":"		;IS IT COLON?
	JRST	ERRAN8		;YES.DESREGARD IT AND PROCEED?
	PUSH	P,CH		;SAVE THIS CHARACTER.
	PUSH	P,CTLPTR(B)	;SAVE THE CTL POINTER
	PUSH	P,CTLCNT(B)	;SAVE HE COUNT
	PUSH	P,USICNT(B)	;SAVE THE BLOCK#
	SETZB	D,COM		;CLEAR COM WORD
	MOVE	D,[POINT 6,COM]	;SETUP THE POINTER
	PUSHJ	P,SKPLB2	;GO SKIP THE LABEL IF ANY
	 JRST SRCM2		;NONE.SEARCH FOR %ERR OR %CERR
	JSP	BUF,RESTOR	;RESTORE THE DATA BASE
	PUSHJ	P,CRNLFF	;SEND CRLF TO LOG FILE AND RESET LF
	POP	P,CH		;RESTORE THE FIRST CHARACTER
	PUSHJ	P,LOGFL		;WRITE IT IN LOG FILE
	PUSHJ	P,SKPTWO	;SKIP THE LABEL
	JRST	ERRAN8		;GO TO THE START
SRCM1:	PUSHJ	P,SRCM3		;WRITE CHARACTER AND FINISH LINE
	JRST	SILRE3		;CHECK THE ERROR AGAIN

SRCM2:	JSP	BUF,RESTOR	;RESTORE THE POINTERS
	POP	P,CH		;GET THE LAST CHARACTER
	PUSHJ	P,SRCM3		;WRITE CHARACTER AND FINISH THE LINE
	PJRST	ERRAN8		;CHECK THE NEXT LINE

SRCM3:	PUSHJ	P,OUT7		;SAVE THE CHARACTER IN LOG FILE
	PJRST	SILRE1		;FINISH THE LINE

	>
SUBTTLE TYPEOUT JOBNAME ON TTY
;HERE TYPEOUT BELLS, SUBJOB# AND MONITOR JOB#
NAMSUB:	MOVEI	CH,BELL		;GET BELL
	OUTCHR	CH		;TYPEOUT A BELL
	MOVEI	CH,BELL		;GET A BELL
	OUTCHR	CH		;TYPEOUT A BELL
	PUSHJ	P,JOBTY		;WRITE SUBJOB#
	MOVEI	CH,HT		;GET A TAB
	OUTCHR	CH		;TYPEOUT A TAB
	OUTSTR	[ASCIZ/JOB# /]
	PUSH	P,JB		;SAVE SUBJOB#
	HRRZ	JB,JOBSB(B)	;GET REAL JOB#
	PUSHJ	P,JOBTY1	;TYPEOUT JOB#
	POP	P,JB		;RESTORE SUBJOB#
	PJRST	CRLF		;WRITE <CR>


	IFGE	FTOPR,<
SUBTTLE SKIP LABEL TERMINATED WITH ::
;ROUTINE TO SKIP LABELS IN A CONTROL FILE


SKPLBL:	PUSHJ	P,ALPNUM	;IS IT ALPHANUMERIC?
	JRST	SKPLB3		;NO. CHECK IF A COLON.
SKPLB1:	PUSHJ	P,CTLOUT	;GET A CHARACTER.
	JRST	OUTPT4		;EOF RETURN
SKPLB2:	PUSHJ	P,ALPNUM	;IS IT ALPHANUM?
	JRST	SKPLB3		;NO.
	PUSHJ	P,CNVSIX	;YES,CHANGE TO SIXBIT
	TLNE	D,770000	;ARE WE DONE?
	JRST	SKPLB1		;NO. GO GET NEXT CHARACTER
	PUSHJ	P,CTLOUT	;GET A CHRACTER.
	JRST	OUTPT4		;EOF RETURN
SKPLB3:	CAIE	CH,":"		;IS IT COLON
	POPJ	P,		;RETURN
	PUSHJ	P,CTLOUT	;GET A CHARACTER
	JRST	OUTPT4		;EOF RETURN
	CAIN	CH,":"		;IS IT COLON?
	JRST	CPOPJ1		;IT IS A LABEL.
	POPJ	P,		;RETURN . NOT A LABEL

SKPLBX:	PUSHJ	P,SKPLBL	;CHECK IF ALABEL?
	JRST	NOTAL1		;NO. CONTINUE PROCESSING
SKPLX1:	JSP	BUF,RESTOR	;RESTORE THE DATA BASE
SKIPIT:	PUSHJ	P,CRNLFF	;WRITE CRLF IN LOG FILE ,RESET LF FLAG
SKPONE:	PUSHJ	P,OUT1		;GET A CHARACTER SAVE ITIN LOG FILE
SKPTWO:	CAIE	CH,":"		;IS IT COLON?
	JRST	SKPONE		;GET A CHARCTER
	PUSHJ	P,CTLOUT	;GET A CHRACTER
	JRST	OUTPT4		;EOF RETURN
	PUSHJ	P,CRLF1		;SEND A CRLF IN LOG FILE
	PJRST	STAG2		;GO TO THE START OF THE LINE.
	>
	IFGE	FTOPR,<
CHRLOG:	TRNE	F2,F2.BAK	;IS IT BACKTO COMMAND?
	JRST	CHRLG1		;PROCESS THE BACKTO COMMAND.
	PUSHJ	P,CTLOUT	;GO GET NEXT CHARACTER
	JRST	OUT3		;IT IS EOF
CHRLG2:	PUSHJ	P,OUT7		;SAVE IN LOG FILE AND RETURN
	PJRST	INCHR2		;RETURN
CHRLG1:	PUSHJ	P,BAKCTL	;CHECK THE COAND
	JRST	OUT3		;EOF
	JRST	CHRLG2		;RETURN
SYNLOG:	PUSHJ	P,OUT7		;SAVE IT IN LOG FILE
	SKIPA			;SKIP ALWAYS
SYNER2:	JSP	BUF,RESTOR	;RESTORE THE POINTERS
SYNERR:	PUSHJ	P,CHRLOG	;GET NEXT CHARACTER
SYNER6:	PUSHJ	P,LFETC		;IS IT LF?
	JRST	SYNERR		;NO
SYNER3:	PUSHJ	P,TIMLOG	;WRITE TIME OF DAY
	MOVEI	T2,[SIXBIT/BAERR /]
	PUSHJ	P,BAOPR1	;WRITE IT IN LOG FILE
	MOVEI	T2,ERMSG4
	PUSHJ	P,LOG1		;WRITE ERROR MESSAGE IN LOG FILE
SYNER4:	TRO	F,F.QSMK+F.KERR	;SET ?MARK FLAG.
	MOVE	C,[SIXBIT/%CERR/]
	MOVEM	C,LABEL(B)	;SAVE IT IN LABEL WORD
	JRST	STAG2
SYNER1:	JSP	BUF,RESTOR	;RESTORE THE POINTERS
	JRST	SYNER3		;WRITE MESSAGE IN LOG FILE
SYNER5:	PUSHJ	P,SILRE2	;WRITE THE COMMAND
	JRST	SYNER6		;PROCESS IT

ERMSG4:	ASCIZ/? Syntax error
/

	>
SPCES:	CAIE	CH," "		;IS IT SPACE?
	CAIN	CH,HT		;IS IT A TAB.
	JRST	CPOPJ1		;IT IS SPACE OR TAB
	JRST	CPOPJ		;NOT A SPACE OR TAB


	IFGE	FTOPR,<
GCTLOG:	PUSHJ	P,GETCTL	;GET NON SPACE OR TAB CHARACTER
	PJRST	OUT7		;WRITE IT IN LOG FILE


GETCT3:	ADD	P,[XWD 3,3]	;ADD THREE ENTRIES TO PDL
	PUSHJ	P,GETCTL	;GET NONSPACE CHARACTER
PDLSB3:	SUB	P,[XWD 3,3]	;REMOVE THREE ENTRIES FROM PDL
	JRSTF	@T1		;RETURN

COM3CK:	ADD	P,[XWD 3,3]	;ADD THREE ENTRIES TO PDL
	PUSHJ	P,COMCHK	;GO CHECK COMMAND
	TLO	F,F.SYNT	;SET SYNTAX ERROR FLAG
	JRST	PDLSB3		;REMOVE ENTRIES FROM PDL AND RETURN


;HERE READ SIX OR LESS NUMBER OF CHARACTERS IN SIXBIT IN COM
;AND PUT THEM IN LOG FILE. 
;
;CALL	PUSHJ P,READCT
;	(ALL SIX)
;	(LESS THAN SIX)

READCT:	PUSH	P,CH		;SAVE THE LAST CHARACTER
	MOVE	T2,[POINT 6,COM]	;SETUP POINTER TO PRINT COM
READC1:	ILDB	CH,T2		;GET FIRST CHARACTER
	JUMPE	CH,CPOPCH	;IGNORE BLANK
	ADDI	CH,40		;CHANGE IT TO ASCII
	PUSHJ	P,OUT7		;SAVE IT IN LOG FILE
	TLNE	T2,770000	;ARE WE DONE?
	JRST	READC1		;GET NEXT CHARACTER
	PJRST	POPJCH		;RESTORE CH AND RETURN
	>
	IFGE	FTOPR,<

SUBTTLE IF CONDITIONS PROCESSING

;HERE PROCESS THE CONDITION SPECIFIED IN IF STATEMENT

;CALL	PUSHJ P,IFARG
;	(NO MATCH)
;	(MATCHES)

IFARG:	HRLZI	C,-IFLEN	;GET THE LENGTH OF TABLE
	MOVE	T2,IFERRS(C)	;GET FIRST ENTRY
	CAMN	T2,TCOM1	;COMPARE
	JRST	@DISIFS(C)	;MATCHES PROCESS IT
	AOBJN	C,.-3		;GET NEXT ENTRY
	POPJ	P,		;RETURN. NO MATCH


IFERRS:	SIXBIT/ERROR/
	SIXBIT/NOERRO/
IFLEN==.-IFERRS


DISIFS:	EXP	DERR
	EXP	DNERR


DERR:	TROA	F,F.ERR
DNERR:	TRZ	F,F.ERR
	JRST	CPOPJ1		;SKIP RETURN
	>
SUBTTLE EXECUTE I/O FOR SUBJOB
;AC T2 HAS +1,0,-1 IN IT WHEN CHNSJB IS CALLED. IT T2 IS +1
;FIND A CHANNEL FOR PTY,IF  0 FIND A CHANNEL FOR CTL
;IF -1 FIND A CHANNEL FOR LOG FILE
;
;	CALLIN SEQUENCE
;	MOVEI T2,+1,0,-1
;	PUSHJ P,CHNSJB
;	(NORMAL RETURN)


CHNSJB:	PUSHJ	P,FSTSLW	;IS IT INCORE TYPE?
	JUMPLE	T2,CHNSJ1	;YES
	JUMPLE	T2,CHNSJ5	;IT IS SLOW.
	LDB	A,[POINT 4,QUETAB-1(JB),29]
	PJRST	CHNSJ4		;RETURN
CHNSJ1:	JUMPL	T2,CHNSJ3	;CTL OR LOG FILE
	LDB	A,[POINT 4,QUETAB-1(JB),21]
	PJRST	CHNSJ4
CHNSJ3:	LDB	A,[POINT 4,QUETAB-1(JB),25]
CHNSJ4:	HRLZS	A		;GET IT IN LEFT HALF
	LSH	A,5		;SHIFT IN AC POSITION
	POPJ	P,		;RETURN

CHNSJ5:	SETZ	A,		;CTL,LOG FILE
	POPJ	P,		;RETURN
SUBTTLE CTL,LOG FILE PROCESSING
LOKCTL:	TRNE	F,F.CTLN	;HAVE WE READ THE FILE AT ALL
	JRST	[ TRNE F2,F2.FST	;IS IT IN CORE TYPE?
		POPJ P,			;RETURN
		JRST .+1		;RETURN
			]
	TRNE	F2,F2.FST	;IS IT IN CORE TYPE?
	JRST	[LDB D,[POINT 4,QUETAB-1(JB),21]
		JUMPN D,.+3	;ALREADY ASSIGNED
		PUSHJ P,NEWCHN	;GET A FREE CHANNEL
		JFCL
		DPB D,[POINT 4,QUETAB-1(JB),21]
		JRST	.+3
			]
		;YES.
	TRNE	GF,SKIP		;DO WE HAVE CONTROL FILE IN CORE?
	POPJ	P,		;RETURN
	SKIPN	C,C.FSTR(B)	;GET FILE STRUCTURE NAME
	JRST	LOKCT1		;ERROR RETURN
	MOVEM	C,INCH0+1	;SAVE IT IN OPEN BLOCK
	MOVEI	T2,0		;FOR CONTOL FILE
	MOVE	A,[OPEN ,INCH0]
	PUSHJ	P,IOUUO		;EXECUTE IT
	JRST	LOKCT1		;ERROR RETURN
	SKIPE	C.FRNM(B)	;IS CTL FILE ALREADY RENAMED?
	JRST	[MOVE C,C.FRNM(B)	;YES
		PUSHJ P,LOGK2		;YES
		JRST LOKCT2]
	PUSHJ	P,CTLK		;SETUP THE HEADER
LOKCT2:	MOVE	A,[LOOKUP ,C]
	PUSHJ	P,IOUUO		;EXECUTE THE UUO
	JRST	LOKERR		;LOOKUP FAILURE



USINP:	SETZ	T2,		;SETUP FOR CONTROL FILE
	TRNE	F2,F2.BAK	;IS IT BACKTO COMMAND?
	PUSHJ	P,USINP1	;YES.
	MOVE	A,[USETI ,@USICNT(B)]
	PUSHJ	P,IOUUO		;EXECUTE THIS UUO
	PUSHJ	P,FSTSLW	;IS IT INCORE TYPE?
	SKIPA	A,BUFTAB(JB)	;YES
	SKIP	A,BUFTAB	;NO
	HRLI	A,-FSTBUF/2	;GET DATA BLOCK SIZE
	MOVEM	A,LST		;SAVE IT 
	PUSHJ	P,INPJBS	;DO AN INPUT ON CTL
	MOVE	A,[STATO ,20000]
	PUSHJ	P,IOUUO		;EXECUTE IT
	PJRST	CLSP		;CLOSE FILE AND RETURN
	TROA	F,F.FIN		;SET END FILE FLAG
LOKERR:	TRO	F,F.CTL+F.FIN
	PJRST	STOP6		;SAVE FLAGS AND RETURN
USINP1:	MOVE	A,[USETI ,@BKICNT(B)]
	JRST	CPOPJ1		;SKIP RETURN


LOKCT1:	MOVE	T2,[POINT 6,C.FSTR(B)]
	PUSHJ	P,LOGFL6	;WRITE STRUCTURE NAME AND P,PN
	PJRST	LOKERR		;SET ERROR FLAG AND RETURN

CTLK:	MOVE	C,C.FNAM(B)	;CONTROL FILE NAME
	HLLZ	D,C.FEXT(B)	;GET THE EXTENSION
	MOVEI	E,0		;
CTLK1:	SKIPE	C.FDIR+1(B)	;ARE SFD'S SPECIFIED?
	PJRST	SFDCTL		;YES. GO SETUP THE LOOKUP BLOCK?
	MOVE	G,C.FDIR(B)	;NO.
	POPJ	P,		;RETURN



;HERE SET UP THE SFD BLOCK FOR UUO'S.NOTICE OFFSET OF 30 LOCATION
;IN THE PUSHDOWN STACK

SFDCTL:	SETZM	31(P)		;CLEAR THE FIRST LOCATION
	MOVEI	A,1		;SET FOR SCAN
	MOVEM	A,32(P)		;SAVE IT
	HRLZI	A,C.FDIR(B)	;
	PJRST	SFDLG1		;BLT AND RETURN

;HERE INITIALIZE LOG FILE. DO A LOOKUP ON IT AND KEEP TRACK OF 
;NUMBER OF CHARACTERS DEPOSITED IN IT. WHEN FULL
;UPDATE THE USOCNT COUNT. THE LOG FILE IS ALREADY STARTED BY STACK\

LOGFL1:	TRNE	F2,F2.FST	;IS IT INCORE TYPE?
	POPJ	P,		;YES. RETURN
	PUSHJ	P,LKLOG		;DO LOOKUP ON THE LOG FILE.
	SKIPN	LOGCNT(B)	;DO NOT READ LOG FILE AT THE START.
	PJRST	FRBLK2		;CLEAR LOG BUFFER AREA.
	TRZE	GF,SKIP		;SKIP INPUT IF SKIP FLAG SET
	POPJ	P,		;RETURN
	TRNE	F,F.LOG		;WAS THERE A LOOKUP FAILURE/
	PJRST	FRBLK2		;YES. THEN CLEAR THE LOG FILE AREA
USOUT:	MOVE	A,[USETI ,@USOCNT(B)]
	PUSHJ	P,IOUUO		;EXECUTE IT
	PUSHJ	P,FSTSLW	;IS IN CORE TYPE?
	SKIPA	A,BUFTAB(JB)	;YES
	SKIP	A,BUFTAB	;NO
	HLRZS	A		;GET IT IN RIGHT HALF
	HRLI	A,-FSTBUF/2	;GET DATA SIZE
	MOVEM	A,LST		;SAVE THE POINTER
	PJRST	INPJB1		;GET LOG FILE BLOCK


LKLOG:	SKIPN	C,L.FSTR(B)	;GET STRUCTURE NAME
	JRST	LOGFL5		;ERRORR
	MOVEM	C,INCH0+1	;SAVE IT IN OPEN BLOCK
	PUSHJ	P,FSTSLW	;IS IT INCORE TYPE?
	JRST	[LDB D,[POINT 4,QUETAB-1(JB),25]
		JUMPN D,.+1	;ALREDY CHANNEL ALLOCATED.
		PUSHJ P,NEWCHN	;GET A CHANNEL
		JFCL
		DPB D,[POINT 4,QUETAB-1(JB),25]
		JRST .+1
			]
	HRROI	T2,-1		;-1 MEANS LOG FILE
	MOVE	A,[OPEN ,INCH0]
	PUSHJ	P,IOUUO		;EXECUTE IT
	JRST	LOGFL5		;ERROR RETURN
LKLOG2:	PUSHJ	P,LOGK		;SETUP LOOKUP FOUR WORDS
	MOVE	A,[LOOKUP ,C]
	PUSHJ	P,IOUUO		;EXECUTE IT
LKLOG1:	TRO	F,F.LOG		;ERROR RETURN SET FLAG.
	POPJ	P,

LOGFL5:	MOVE	T2,[POINT 6,L.FSTR(B)]
	PUSHJ	P,LOGFL6	;WRITE STRUCTURE AND P,PN
	SETOM	C		;SET -1 IN AC C
LOGFL9:	MOVEI	A,[XWD 3,C]
	JOBSTR	A,
	JFCL
	CAMN	C,L.FSTR(B)	;IS IT THE ONE IN QUEUE REQUEST?
	JRST	LOGFL9		;YES TO THE NEXT
	JUMPE	C,LOGFL9	;YES. IT IS FENCE
	AOJE	C,LOGF10	;END
	MOVEM	C,L.FSTR(B)	;SAVE IT IN DATA AREA
	SETOM	T2		;FLAG FOR LOG FILE
	MOVE	A,[OPEN ,INCH0]
	PUSHJ	P,IOUUO		;EXECUTE IT
	PJRST	LOGF10		;SET FLAG AND RETURN
	PJRST	LKLOG2		;CONTINUE ENTRY IN LOG FILE

LOGFL6:	PUSHJ	P,JOBNM1	;WRITE STRUCTURE AND A TAB
	PUSHJ	P,PRJETC	;WRITE P,PN AND <CR>
	TYPDSK<*? Open failed.Job aborted
!*>
	POPJ	P,		;RETURN


LOGF10:	PUSHJ	P,FSTSLW	;IS IT IN CORE TYPE?
	PJRST	[ SUB P,[XWD 2,2]
		IFGE FTOPR,<
		PJRST REL4	;RELEASE JOB
			>
		IFL FTOPR,<
		TRO F,F.FIN	;SET END OF JOB FLAG
		PJRST STOP6	;SAVE IT
			>
			]
	PJRST	LKLOG1		;SET FLAG AND RETURN
LOGFL:	PUSHJ	P,HTAB		;NO. SEND TWO TABS TO LOG FILE.
	IDPB	CH,LOGPTR(B)	;DEPOSIT THE NEXT CHARACTER
LOGFL3:	PUSH	P,T2		;SAVE AC T2
	AOS	A,LOGCNT(B)	;UPDATE LOG CHARACTER COUNT.
	MOVEM	F,FLAGS(B)	;SAVE THE FLAGS
	CAIE	A,MAXCHR	;HAVE WE FILLED THE BUFFER.
	PJRST	LOGFL4		;RESTORE T2 AND RETURN
	SETZM	LOGCNT(B)	;RESET THE CHARACTER COUNT
	MOVSI	A,(POINT 7,0)
	TRNE	F2,F2.FST	;IS IT IN CORE TYPE?
	JRST	LOGFL7		;YES
	HLR	A,BUFTAB	;FOR SLOW TYPE
	AOS	A		;ADD ONE
	MOVEM	A,LOGPTR(B)	;SAVE IT
	PUSHJ	P,LOGFL2	;SAVE THIS BLOCK OF LOG FILE
	PUSHJ	P,FRBLK		;FIND A NEW FREE BLOCK AND CLEAR IT
	PUSHJ	P,LOGFL1	;SO A LOOKUP
	PJRST	LOGFL4		;RESTORE T2 AND RETURN
LOGFL7:	HLR	A,BUFTAB(JB)	;GET THE LOG FILE ADD
	AOS	A		;ADD ONE
	MOVEM	A,LOGPTR(B)	;SAVE IT
	PUSHJ	P,LOGFL8	;GO DO OUPUT
	PUSHJ	P,FRBLK2	;CLEAR THE BUFFER AREA
	AOS	USOCNT(B)	;UPDATE LOG FILE BLOCK COUNT
LOGFL4:	POP	P,T2		;RESTORE AC T2
	POPJ	P,		;RETURN

LOGFL2:	TRNE	F2,F2.FST	;IS IT IN CORE TYPE?
	POPJ	P,		;RETURN
	PUSHJ	P,LOGK		;SETUP THE ENTER FOUR WORDS
	HRROI	T2,-1		;FOR LOG FILE
	MOVE	A,[ENTER ,C]
	PUSHJ	P,IOUUO		;EXECUTE IT
	PUSHJ	P,ERNTER	;PROCESS THE ERROR
LOGFL8:	HRROI	T2,-1		;-1 LOG FILE
	MOVE	A,[USETO ,@USOCNT(B)]
	PUSHJ	P,IOUUO		;EXECUTE THE UUO
	PUSHJ	P,FSTSLW	;IS IT INCORE TYPE
	SKIPA	A,BUFTAB(JB)	;YES INCORE
	SKIP	A,BUFTAB
	HLRZS	A		;IN THE RIGHT HALF
	HRLI	A,-FSTBUF/2		;GET THE SIZE
	MOVEM	A,LST		;SAVE POINTER
	MOVE	A,[OUTPUT ,LST]
	PUSHJ	P,IOUUO		;EXECUTE THE UUO
	MOVE	A,[GETSTS ,D]	;SET UP THE INSTRUCTION
	PUSHJ	P,IOUUO		;EXECUTE IT
	TRNN	D,NOROOM	;IS DISK FULL?
	PJRST	CLSP		;CLOSE AND RELEASE CHANNEL
	ADD	P,[XWD 1,1 ]	;
	SETOM	COUNT		;STOP LISTENING TO JOB
	PJRST	ERNTR1		;PRINT MESSAGE AND RETURN
JBSTAT:	IFE	LEVELC,<
	JOBST(STS)		;GET JOB STATUS
	POPJ	P,		;RETURN
	>

	IFN	LEVELC,<
	PJRST	JBSLVC		;JOB STATUS FOR LEVELC
	>
;HERE DO AN INPUT ON CTL OR LOG FILE


INPJBS:	SKIPA	T2,[0]		;FLAG FOR CTL FILE
INPJB1:	SETOM	T2		;FLAG FOR LOG FILE
	MOVE	A,[INPUT ,LST]



;ROUTINE TO EXECUTE VARIOUS I/O UUO'S.
;		CALLING SEQUENCE T2=+1,0,-1
;		MOVE A,[UUO]
;		PUSHJ P,IOUUO
;		(RETURN)		HERE ERROR,NONSKIP CASE
;		(RETURN)			SKIP CASE



IOUUO:	PUSH	P,A		;SAVE CONTENTS OF AC A
	PUSHJ	P,CHNSJB	;GET THE CHANNEL #
	XORM	A,(P)		;CONSTRUCT THE UUO
	POP	P,A		;RESTORE AC A
	XCT	A		;EXECUTE THE UUO
	POPJ	P,		;RETURN
	JRST	CPOPJ1		;SKIP RETURN



	IFGE	FTOPR,<
;MONITOR AND BATCH COMMAND CHECK ROUTINE
;HERE WHEN COMMAND IN THE WORD COM

COMMON:	HLLZ	G,COMTB		;GET THE NEGATIVE LENGTH OF TABLES
	HRRZ	C,COMTB		;GET THE STARTING ADDRESS
	MOVE	D,(C)		;GET THE FIRST ENTRY
	CAMN	D,COM		;DOES IT COMPARE?
	JRST	MASKC1		;YES. CHECK FURTHER
	AOS	C		;UPDATE TABLE POINTER
	AOBJN	G,.-4		;GET NEXT ENTRY
	HLLZ	G,COMTB		;GET THE COMMAND TABLE LENGTH
	HRRZ	C,COMTB		;GET THE STARTING ADDRESS
	PUSHJ	P,MASK		;SETUP THE MASK
MASKCK:	MOVE	D,(C)		;GET THE COMMAND FROM TABLE
	ANDCM	D,E		;EXTRACT THE COMMAND
	CAMN	D,COM		;DOES IT COMPARE?
	PUSHJ	P,OPTR2		;YES
	AOS	C		;UPDATE THE COMMAND POINTER
	AOBJN	G,MASKCK	;CHECK NEXT ONE
	HRRZ	C,COMTB		;GET THE START OF THE TABLE
	HLRZ	G,A		;GET THE LOCATION OF UNIQ COMMAND
	ADD	C,G		;SAVE IT IN AC C
	PJRST	COMACH		;NORMAL RETURN IS ERROR


MASKC1:	MOVE	C,.JBFF		;GET FIRST FREE LOCATION
	SUBI	C,CTL3+1	;LENGTH OF BATCH TABLE
	HRLZI	G,-CTL3		;SETUP THE INDEX REGISTER
MASKC2:	MOVE	D,CTLCM1(G)	;GET FIRST ENTRY
	CAMN	D,COM		;DOES IT MATCH?
	AOSA	C		;YES A BATCH COMMAND
	AOBJN	G,MASKC2	;NO. GET NEXT ENTRY
	JRST	CPOPJ1		;RETURN
	>
SUBTTLE ENTER ERROR PROCESSING
ERNTER:	MOVEI	T1,MODFY	;SET COUNT FOR MODIFY ERROR TRIES.
ERNTR3:	HRRZS	D		;CHECK THE ERROR CODE
	CAIE	D,3		;IS IT BEING MODIFIED?
	JRST	ERNTR1		;CHECK FURTHER
	PUSHJ	P,XZZZ		;SLEEP FOR A SECOND
	PUSHJ	P,LOGK		;SETUP THE FOUR ENTER HEADER
	SETOM	T2		;FLAG FOR LOG FILE
	MOVE	A,[ENTER ,C]
	PUSHJ	P,IOUUO		;EXECUTE UUO AND RETURN
	SOJG	T1,ERNTR3	;ERROR AGAIN
	JUMPE	T1,ERRAN5	;IF T1=0 ERROR CONDITION. REQUEUE IT
	PJRST	ERNTR4		;RETURN

ERNTR1:	PUSHJ	P,JOBNAM	;TYPEOUT JOBNAM
	PUSH	P,D		;SAVE AC D
	PUSHJ	P,PRJETC	;WRITE P,PN
	POP	P,D		;RESTORE AC D
	TYPDSK<*? Enter/output error#  *>
	PUSH	P,B		;SAVE B
	MOVE	A,D		;GET ERROR CODE
	PUSHJ	P,TYOCT		;WRITE IN OCTAL
	POP	P,B		;RESTORE B
  	TYPDSK</  Job aborted
!/>
	TRO	F,F.FIN		;SET END OF FILE ALG
	PUSHJ	P,DEAS1		;PUT THE JOB IN MONITOR MODE.
	JRST	ERNTR2		;SAVE FLAGS AND RETURN

ERRAN5:	PUSHJ	P,JOBNAM	;WRITE JOBNAME
	PUSHJ	P,PRJETC	;WRITE P,PN
	TYPDSK</? Enter error #3.Job requeued
!/>
	TRO	F,F.ENTR	;SET ENTER ERROR FLAG
ERNTR2:	POP	P,C		;ADJUST STACK
	MOVEM	F,FLAGS(B)	;SAVE FLAGS
	PUSHJ	P,CLSP		;RETURN
ERNTR4:	PUSHJ	P,WAKEM		;WAKE ME UP
	TRO	GF,TTYIOW	;SET BIT FOR TI WAIT
	POPJ	P,		;RETURN

XZZZ:	HRRZI	D,^D1000	;1 SECOND SLEEP TIME IN MSECS.
	SKIPGE	SLPTM		;IS SWPNOW BIT ON?
	TLOA	D,SWPNOW	;SET IT
	MOVEI	C,1		;YES. SLEEP FOR ONE SECOND.
	HIBER	D,		;GO SLEEP FOR A SECOND
	SLEEP	C,		;GO SLEEP
	POPJ	P,		;RETURN

WAKEM:	MOVNI	A,1		;WAKE ME UP.
	WAKE	A,		;WAKE ME UP
	JFCL			;IGNORE	ERRORS
	POPJ	P,		;RETURN
SUBTTLE FREE CHANNEL ROUTINE

;HERE FINDOUT A FREE CHANNEL FOR PTY,CTL OR LOG FILE
;
;
;CALLING SEUENCE
;
;	PUSHJ P,NEWCHN
;	(NO FREE CHANNEL)
;	(FREE CHANNEL IN AC D)
;
;ROUTINE USES AC'S A,D,G


NEWCHN:	HRLZI	G,1		;SETUP TO MARK CHANNEL INUSE
	MOVE	A,FRECHN	;GET CHANNEL USAGE WORD
	XOR	A,[-1]		;FIND THE ONES THAT ARE FREE
	HRLZI	D,-MAXCHL	;MAXIMUM AVAILABLE CHANNELS
	LSH	G,-1		;SHIFT TO RIGHT
	LSH	A,1		;SHIFT ONE
	TLNN	A,1		;CHECK IF IN USE
	AOBJN	D,.-3		;YES.
	JUMPGE	D,CPOPJ		;NO FREE CHANNELS
	MOVEI	D,1(D)		;
	XORM	G,FRECHN	;MARK IT INUSE.
	PJRST	CPOPJ1		;FREE CHANNEL IN AC D



;HERE CLEAR THE BIT AND FREE CHANNEL
;
;CALLING SEQUENCE
;
;	MOVE D,CH#
;	PUSHJ P,CLRCHN
;	RETURN
;
;ROUTINE USES AC A,D


CLRLOG:	LDB	D,[POINT 4,QUETAB-1(JB),25]
	PUSHJ	P,CLRCHN	;CLEAR THE BIT
CLRCTL:	LDB	D,[POINT 4,QUETAB-1(JB),21]
CLRCHN:	HRLZI	A,1		;SETUP THE BIT
	MOVNS	D		;GET -VE OF CHANNEL #
	LSH	A,(D)		;SHIFT RIGHT
	ANDCAM	A,FRECHN	;CLEAR BIT
	POPJ	P,		;RETURN

SUBTTLE RANDOM LITTLE ROUTINES
TTDSK:	ILDB	CH,E		;GET A CHARACTER
	JUMPE	CH,CPOPJ	;IS IT NULL?
	OUTCHR	CH		;NO. OUTPUT THE CHARACTER.
	PUSHJ	P,DSKLOG	;SAVE IT IN DSKLOG.
	JRST	TTDSK		;GO GET NEXT CHARACTER.


LOGK:	SKIPE	L.FRNM(B)	;IS LOG FILE ALREADY RENAMED?
	PJRST	LOGK1		;YES.
	MOVE	C,L.FNAM(B)
	HLLZ	D,L.FEXT(B)
	MOVEI	E,0
	TRNE	F,F.PRIV	;DOES THE JOB HAVE PRIVS?
	PJRST	[ SKIP G,Q.PPN(B);USE HIS OWN AREA
		POPJ P,		;RETURN
			]
	SKIPE	L.FDIR+1(B)	;ARE SFDS SPECIFIED?
	PJRST	SFDLOG		;YES
	MOVE	G,L.FDIR(B)	;NO.
	POPJ	P,
;HERE FIGURE OUT THE SFD BLOCK AND SETUP THE PROPER POINTER FOR UUO'S
;***CAUTION THE STACK HAS BEEN OFFSET BY 30 LOACTION FOR SCRATCH AREA***

SFDLOG:	SETZM	31(P)		;CLEAR THE FIRST LOCATION
	MOVEI	A,1		;
	MOVEM	A,32(P)		;SAVE IT
	HRLZI	A,L.FDIR(B)	;
SFDLG1:	HRRI	A,33(P)		;
	BLT	A,40(P)		;
	SETZM	41(P)		;CLEAR THE NEXT LOC
	MOVEI	G,31(P)		;POINTER TO THE BLOCK
	POPJ	P,		;RETURN


TTLOG:	ILDB	CH,T2		;GET A CHARCTER
	JUMPE	CH,CPOPJ	;IS IT NULL?
	OUTCHR	CH		;NO. OUTPUT THE CHARCTER.
	PUSHJ	P,LOGFL		;SAVE IT IN LOG FILE
	JRST	TTLOG		;GO GET ANOTHER CHARCTER


SUBTTLE SAVE LAST OUT/IN LINE FROM JOB
LASLIN:	TLON	F,F.LIN		;LINE IS BEING STORED
	PUSHJ	P,INLINE	;SET BUFFER POINTER
	PUSHJ	P,INCHR1	;IS IT ONE OF THE ALTMODE?
	CAIN	CH,33		;IF SO MAKE IT
	MOVEI	CH,"$"		;A DOLLAR SIGN
	IDPB	CH,LINPTR(B)
	PUSHJ	P,TTYOUT	;CECK IF I/O ON TTY
	SOSN	BLICHR(B)	;UPDATE CHARACTER COUNT
	PJRST	LASLI1		;ZERO SET FLAG AND RETURN
	PUSHJ	P,CONCHR	;IS IT LF FF ETC.?
	POPJ	P,		;RETURN
LASLI1:	TLZ	F,F.LIN		;RESET LINE BUFFER FLAG.
	TRZE	F2,F2.QTS	;RESET QUOTES FLAG
	TLZ	F,F.TTY		;RESET WRITE ON TTY FLAG
DSKLOG:	POPJ	P,

IFN DEBUG,<
OUTSTS:	POPJ	P,>		;UNIMPLEMENTED DEBUG TOOL


LOGK1:	MOVE	C,L.FRNM(B)	;GET THE RENAMED NAME
LOGK2:	MOVSI	D,(SIXBIT/QUD/)
	MOVEI	E,0
	MOVE	G,[QUEPPN]
	POPJ	P,


LASOUT:	JUMPE	CH,CPOPJ	;IGNORE NULLS
	TLON	F,F.LOUT	;SET FLAG OUTPUT LINE STARTED
	PUSHJ	P,OTLINE	;INITIALIZE LINE BUFFER
	CAIN	CH,CONTRLC	;IS IT ^C?
	PUSHJ	P,TCRLC		;YES. TYPE ^C
	PUSHJ	P,INCHR1	;IS IT ONE OF THE ALTMODES?
	CAIN	CH,33		;IS IT ALTMODE?
	MOVEI	CH,"$"		;TYPE $
	IDPB	CH,LOTPTR(B)	;GET A CHARACTER
	PUSHJ	P,TTYOUT	;CHECK IF I/O ON TTY
	SOSN	BLOCHR(B)	;UPDATE THE CHARACTER COUNT
	PJRST	LASOU1		;SET FLAG AND RETURN
	TLNE	F,F.BRK+F.LF	;IS IT BREAK CHARACTER?
LASOU2:	PUSHJ	P,CONCHR	;IS LF FF ETC.?
	POPJ	P,		;NO. RETURN
LASOU1:	TLZ	F,F.LOUT	;YES. RESET LINE FLAG.
	POPJ	P,		;RETURN


TCRLC:	MOVEI	CH,"^"		;GET UP ARROW
	PUSHJ	P,LASOUT	;WRITE IT IN LINE BUFFER ETC.,
	MOVEI	CH,"C"		;GET ALPHABETIC C
	PJRST	LASOU1		;SET FLAG AND RETURN

OTLINE:	MOVEI	A,MCHRC		;GET THE MAX ALLOWED CHARACTERS
	MOVEM	A,BLOCHR(B)	;SAVE IT IN JOB AREA
	SETZM	MSTBLO(B)	;INITIALIZE AND SET TO ZERO
	HRLZI	A,MSTBLO(B)	;GET THE ADDRESS
	HRRI	A,MSTBLO+1(B)	;GET ADDRESS
	BLT	A,MSTBLO+MSIZ-1(B)	;CLEAR BUFFER AREA
	MOVE	A,[POINT 7,MSTBLO(B)]
	MOVEM	A,LOTPTR(B)
	POPJ	P,		;RETURN

INLINE:	MOVEI	A,MCHRC		;GET THE MAX ALLOWED CHARACTERS
	MOVEM	A,BLICHR(B)	;SAVE IT IN JOB AREA
	SETZM	MSTBLI(B)	;INITIALIZE AND SET TO ZERO
	HRLZI	A,MSTBLI(B)	;GET THE ADDRESS
	HRRI	A,MSTBLI+1(B)	;GET THE ADDRESS
	BLT	A,MSTBLI+MSIZ-1(B)	;CLEAR BUFFER
	MOVE	A,[POINT 7,MSTBLI(B)]
	MOVEM	A,LINPTR(B)
	TRNE	F,F.END		;PROCESSING KJOB LINE
	PJRST	[PUSH P,CH	;SAVE THIS CHARACTER
		PUSHJ P,NAMSUB	;TYPEOUT TO THE OPERATOR
		PJRST POPJCH	;RESTORE CH AND RETURN
			]
	POPJ	P,


TTYOUT:	IFN	FTPLS,<
	TLNE	F,F.PLS		;IS PLEASE COMMAND BEING TYPEDOUT?
	POPJ	P,		;YES RETURN
	>
	TRNN	F,F.END		;IS KJOB COMMAND BEEN ISSUED?
	TLNE	F,F.TTY		;IS FLAG TO TYPE ON TTY ON?
	OUTCHR	CH		;YES
	POPJ	P,		;RETURN


	XLIST
	LIT
	VAR
	LIST
	IFN	PURE,<RELOC>	;START OF LOW SEGMENT

SCHJB:	PUSH	P,GF		;SAVE CONTEMTS OF GF
	PUSH	P,E		;SAVE CONTENTS OF E
	SETZB	E,GF		;CLEAR AC E AND GF

	IFN	REMSW,<
	HRRZ	C,3(A)		;GET THE STATION#
	IDIVI	C,^D36		;MULTIPLE OF 36
	MOVEI	E,1		;GET A BIT
	SUBI	D,^D35		;
	MOVMS	D
	LSH	E,(D)		;MOVE IT TO THE STATION POSITION
	TDNN	E,REMTAB(C)	;
	JRST	SCHJB2		;NO. DO NOT SCHEDULE
		>

	LDB	C,[POINT 1,20(A),3]	;GET NONRESTARTABLE REQUEUE BIT
	JUMPN	C,SCHJB3	;GO SCHEDULE THE JOB
	LDB	C,[POINT 2,20(A),2]	;GET UNIQUE FIELD
	CAILE	C,1		;IS IT LESS OR EQUAL TO 1?
	TRO	GF,UNIQF	;SET UNIQUE FLAG FOR SCHEDULING
UNIQE:	SKIPN	JBSACT		;#OF ACTIVE JOBS.
	JRST	SCHJB1		;NONE. GO SCHEDULE A JOB.
	MOVE	D,4(A)		;GET THE PPN
	SETZ	B,		;CLEAR ACCUMULATOR
	MOVEI	E,1		;FIRST JOB#
UNIQ1:	HLRZ	C,NLINES	;GET THE START OF THIS AREA
	CAMN	D,Q.PPN(B)	;IS PPN ALREADY IN USE?
	CAIN	C,(B)		;IS IT WHAT WE ARE LOOKING AT?
	JRST	UNIQ3		;YES.CHECK NEXT ONE
	JRST	UNIQ2		;YES.
UNIQ3:	ADDI	B,SIZE		;UPDATE INDEX INFORMATION
	CAMGE	E,MAXSTM	;HAVE WE CHECKED ALL JOBS
	AOJA	E,UNIQ1		;GO TO NEXT JOB
	SKIPE	E,FORCSQ	;GET THE NEXT SEQUENCE#
	CAME	E,6(A)		;IS IT WHAT WE WERE LOOKING FOR?
	SKIPA 			;SKIP IT
	JRST	SCHJB3		;SCHEDULE IT NOW
SCHJB1:	HLRZ	D,21(A)		;GET THE REQUIRED CORE IN WORDS
	LSH	D,-^D10		;CORE IN K
	CAMLE	D,JCORMX	;DOES CORE EXCEED CORE LIMIT?
	JRST	SCHJB2		;YES. DONOT SCHEDULE JOB.
	ADD	D,TOTCOR	;ADD CURRENT CORE SIZE IN K
	CAMLE	D,AJCOR		;DOES IT EXCEED TOTAL CORE.
	JRST	SCHJB2		;YES. DONOT SCHEDULE JOB.
	HRRZ	D,21(A)		;GET REQUIRED CPU TIME IN SECONDS
	CAMLE	D,JTIMX		;DOES IT EXCEED THE LIMIT?
	JRST	SCHJB2		;YES. DONOT SCHEDULE THE JOB?
	ADD	D,TOTIME	;ADD CURRENT JOBS REQUIREMENT
	CAMLE	D,ATIMX		;DOES IT EXCEED THE LIMIT?
	JRST	SCHJB2		;YES. DONOT SCHEDULE THE JOB.
	HLRZ	C,11(A)		;GET CURRENT TIME
	HLRZ	D,12(A)		;GET CREATION TIME
	SUB	C,D		;GET THE DIFFERENCE
	IMULI	C,DYMTS		;GET DIFFERENCE IN MINUTES.
	HRRZ	E,11(A)		;GET CURRENT TIME
	HRRZ	D,12(A)		;GET CREATED TIME
	SUB	E,D		;GET FRACTION OF DAY
	IMULI	E,DYMTS		;GET FRACTION IN MTS
	HLRZS	E		;DIVIDE BY 2**^18
	ADD	C,E		;TOTAL # OF MTS SINCE CREATION
	CAIL	C,DEFAGE	;IS IT LESS THAN DEFAULT AGE?
	MOVE	C,DEFAGE	;NO.
	LSH	C,AGE		;MULTIPLY BY WEIGHT CONSTANT
	IDIVI	C,DEFAGE	;GET CONTRIBUTION TO PRIORITY
	MOVEI	D,SCD1		;GET DEFAULT TIME IN SECONDS
	HRRZ	E,21(A)		;GET TIME IN SECONDS
	IDIV	D,E		;GET ITS CONTRIBUTION
	ADD	C,D		;UPDATE PRIORITY
	MOVEI	D,SCD2		;GET DEFAULT CORE IN WORDS
	HLRZ	E,21(A)		;GET CORE SIZE IN WORDS
	IDIV	D,E		;COMPUTE PRIORITY
	ADD	C,D		;UPDATE THE PRIORITY

	MOVEI	D,SCD3		;GET DEFAULT PAGE LIMIT
	HLRZ	E,22(A)		;GET PAGES ASKED FOR
	IDIV	D,E		;UPDATE PRIORITY
	ADD	C,D		;UPDATE PRIORITY

	MOVEI	D,SCD4		;GET DEFAULT CARD LIMIT
	HRRZ	E,22(A)		;GET #OF CARDS ASKED FOR
	IDIV	D,E		;COMPUTE PRIORITY
	ADD	C,D		;UPDATE PRIORITY

	MOVEI	D,SCD5		;GET DEFAULT PAPER TAPE LIMIT IN FT
	HLRZ	E,23(A)		;PAPER TAPE IN FT.
	IDIV	D,E		;COMPUTE PRIORITY
	ADD	C,D		;UPDATE PRIORITY

	MOVEI	D,SCD6		;GET DEFAULT DISPLAY TIME IN MINUTES
	HRRZ	E,23(A)		;GET PLOT TIME IN MINUTES
	IDIV	D,E		;COMPUTE PRIORITY
	ADD	C,D		;UPDATE PRIORITY

	LDB	D,[POINT 6,7(A),35]
	LSH	D,AEXT		;COMPUTE EXTERNAL PRIORITY
	ADD	C,D		;UPDATE PRIORITY

	AOSA	A,C		;ADD ONE TO PRIORITY
SCHJB2:	MOVEI	A,0		;CLEAR A
SCHJB4:	TRZ	GF,UNIQF	;RESET UNIQUE FLAG
	POP	P,E		;RESTORE AC E
	POP	P,GF		;RESTORE GF
	POPJ	P,		;RETURN


SCHJB3:	HRLOI	A,377777	;SET A TO MAX PRIORITY
	PJRST	SCHJB4		;RETURN

UNIQ2:	TRNE	GF,UNIQF	;IS IT LESS OR EQUAL TO 1?
	JRST	SCHJB2		;NO. DONOT SCHEDULE THE JOB.
	LDB	C,[POINT 2,Q.IDEP(B),2]
	CAILE	C,1		;IS IT LESS THAN OR EQUAL TO 1?
	JRST	SCHJB2		;NO. DONOT SCHEDULE THE JOB?
	JRST	UNIQ3		;GO CHECK OTHER JOBS


;HERE PROCESS THE CONTROL C INTERRUPT
;HERE WHEN ^C TYPED- MONITOR RETURNS CONTRO

CNTINT:	CLRBFI			;CLEAR THE INPUT BUFFER
	PUSH	P,INTBLK+2	;SAVE THE RETURN ADDRESS
	PUSH	P,CH		;SAVE AC CH
	PUSHJ	P,SETIN1	;CLEAR FOR FUTURE INTERRUPTS
	SKIPN	JBSACT		;ARE ANY JOBS IN USE?
	PJRST	CNTIN2		;NO.RETURN TO THE MONITOR
	OUTSTR	[ASCIZ/% SUBJOBS IN USE

TYPE M FOR MONITOR MODE

/]
	INCHWL	CH		;GET A CHARACTER
	CAIE	CH,"M"		;IS IT YES?
	JRST	[CAIE CH,"-"	;IS IT HYPUN?
		CAIN CH,"A"	;IS IT A?
		JRST .-2	;GET NEXT CHARACTER.
		CAIN CH,"B"	;IS IT B?
		JRST .-2
		JRST .+2
			]
CNTIN2:	EXIT	A,		;RETURN TO THE MONITOR
	CLRBFI			;CLEAR THE INPUT BUFFER.
CNTIN3:	MOVEI	CH,@-1(P)	;
	CAIG	CH,POPJCH+1		;
	CAIGE	CH,CNTINT	;
	JRST	POPJCH		;CONTINUE
	SUB	P,[XWD 2,2]
	JRST	CNTIN3		;TRY NEXT ONE
POPJCH:	POP	P,CH		;RESTORQ AC C
	POPJ	P,		;RETURN

;HERE TO SETUP THE .JBINT FOR ^C PROCESSING

	EXTERNAL .JBINT

SETINT:	MOVEI	C,INTBLK	;SETUP THE .JBINT WORD
	MOVEM	C,.JBINT	;SAVE IT
	MOVE	C,[XWD 4,CNTINT]
	MOVEM	C,INTBLK	;SAVE IT
	MOVEI	C,2		;GET THE ARGUMENT
	MOVEM	C,INTBLK+1	;SAVE IT
SETIN1:	SETZM	INTBLK+2	;CLEAR IT
	SETZM	INTBLK+3	;CLEAR IT
	POPJ	P,		;RETURN




	XLIST
	LIT
	VAR
	LIST
COUNT:	LOOPCT			;COUNT COMPUTE TIME LOOP
INCH0:	PHYSCL,,DUMP		;DUMP MODE
	SIXBIT/DSK/
	0
TTYIND:	-1			;SAVE -1
SLPTM:	MXSLEP			;DEFAULT SLEEP TIME
MAXSTM:	0			;DEFAULT JOB STREAM MAXIMUM
SJBLMT:	JOBMAX			;RESTRICT JOB SCHEDULING LIMIT
AJCOR:	0			;MAX TIME FOR ALL JOBS
JCORMX:	0			;DEFAULT FOR EACH JOB
JTIMX:	0			;TIME FOR EACH JOB
ATIMX:	0			;TIME LIMIT FOR ALL JOBS
TSTART:	0			;SAVE BATCH START TIME
COMTB:	0			;XWD -LENGTH,STARTING ADD MONITOR COMM
SLWSRM:	0			;LH #OF STREAMS SLOW,,RH START BUFFERS
PTYMAX:	0			;MAX NO. OF PTY'S IN THE SYSTEM.
	IFN LEVELC,<
TCONLN:	0			;SAVE TTY OFFSET
	>
	IFN REMSW,<
REMTAB:	EXP 0,0			;BIT TABLE FOR REMOTE STATIONS
		>

BUFTAB:	BLOCK	FSTSTM+1	;1ST WORDD FOR SLOW STREAMS

	IFN FTOPR,<
GLBFLG:	0			;SAVE THE GLOBAL FLAGS
FITJOB:	0			;FLAG TO COMMUNICATE ACROSS BATOPR
		>
PTYTAB:	BLOCK	JOBMAX		;PTY TABLE
QUETAB:	BLOCK	JOBMAX		;QUEUE NAME LH
				;18-21 CTL,22-25 LOG,26-29 PTY,35 FLAG
PTYCTL:	BLOCK	FSTBUF/2	;BUFFER FOR CTL FILE.
PTYLOG:	BLOCK	FSTBUF/2	;BUFFER FOR LOG FILE
INTBLK:	BLOCK	4		;BLOCK FOR ^C INTERRUPT
LST:	BLOCK	2		;SAVE DUMP MODE POINTER
JBSCH0:	BLOCK	1
JBSCH4:	BLOCK	1
JBSCH5:	BLOCK	1
SUBJOB:	BLOCK	1		;SAVE SUBJOB#
FORCSQ:	BLOCK	1		;SAVE SEQUENCE #
NLINES:	BLOCK	1		;LH JOB DATA START,,RH  EXAMINE ARGUMENT
CTRCNT:	BLOCK	1		;L.H BATOPR FLAGS,R.H JOBS STOPPED
TCOM1:	BLOCK	1		;SRATCH STORAGE
COM:	BLOCK	1		;SAVE COMMAND
DSKPTR:	BLOCK	1		;DISK LOG POINTER
FRECHN:	BLOCK 1			;18-32 BIT TABLE FOR CHANNEL USAGE
 
TELLBK:	BLOCK	TELSIZ		;BUFFER FOR TELL COMMAND
INCORE:	BLOCK	1		;LAST SUBJOB IN CORE
LASTIM:	BLOCK	1		;LAST TIME JOB SCHEDULED
JBREQ:	BLOCK	1		;SAVE THE JOB REQUEUE PARAMETER
TOTCOR:	BLOCK	1		;TOTAL CORE USED BY BATCH IN K
TOTIME:	BLOCK	1		;TOTAL TIME USED BY BATCH IN SECONDS.
JBSACT:	BLOCK	1		;SAVE ALL INITED CHANNELS


PDL:	BLOCK	PSIZ
FIRDTA:
MSTBLI:	BLOCK	MSIZ		;INPUT LINE BUFFER
BLICHR:	BLOCK	1		;INPUT LINE BUFFER CHRACTER COUNT
MSTBLO:	BLOCK	MSIZ		;OUTPUT LINE BUFFER
BLOCHR:	BLOCK	1		;OUTPUT LINE BUFFER CHRACTER COUNT
BKICNT:	BLOCK	1		;CTL BLOCK COUNT FOR BACKTO
JOBSB:	BLOCK	1		;SAVE JOB STATUS CHANGE
PCWORD:	BLOCK	1		;PCWORD TO REMEMBER WHERE WE ARE.
CTLPTR:	BLOCK	1		;CTL POINTER
LOGPTR:	BLOCK	1		;LOG POINTER
BKCPTR:	BLOCK	1		;CTL POINTER FOR BACKTO COMMAND

PTRCNT==.-CTLPTR		;LENGTH OF POINTER BLOCK

USICNT:	BLOCK	1		;USETI COUNT BLOCKS
USOCNT:	BLOCK	1		;USETO COUNT BLOCKS
PTOBUF:	BLOCK	3		;OUTPUT PTY BUFFER
OBUF1:	BLOCK	BUFSIZ+2	;FIRST BUFFER
OBUF2:	BLOCK	BUFSIZ+2	;SECOND BUFFER
FLAGS:	BLOCK	1		;FLAG FOR THE JOB
FLAG2:	BLOCK	1		;MORE JOB FLAGS
PTIBUF:	BLOCK	3		;INPUT PTY BUFFER
IBUF1:	BLOCK	BUFSIZ+2	;FIRST BUFFER
IBUF2:	BLOCK	BUFSIZ+2	;SECOND BUFFER

;START OF THE QUEUE PARAMETER AREA

QDAT:
Q.MEM:	BLOCK 1			;FIRST LOC OF QUEUE AREA
Q.OPR:	BLOCK 1			;OPERATION CODE
Q.LEN:	BLOCK 1			;PARAMETER AREA LENGTH
Q.DEV:	BLOCK 1		;DESTINATION DEVICE
Q.PPN:	BLOCK 1			;PPN ORIGINATING REQUEST
Q.JOB:	BLOCK 1			;JOB NAME
Q.SEQ:	BLOCK 1			;JOB SEQUENCE NUMBER
Q.PRI:	BLOCK 1			;EXTERNAL PRIORITY
Q.PDEV:	BLOCK 1			;PROCESSING DEVICE
Q.TIME:	BLOCK 1			;PROCESSING TIME OF DAY
Q.CREA:	BLOCK 1			;CREATION TIME
Q.AFTR:	BLOCK 1			;AFTER PARAMETER
Q.DEAD:	BLOCK 1			;DEADLINE PARAMETER
Q.CNO:	BLOCK 1			;CHARGE NUMBER
Q.USER:	BLOCK 2			;USERS NAME
Q.IDEP:	BLOCK 1			;DEPENDENCY WORD
Q.ILIM:	BLOCK 3			;JOB LIMITS
Q.IDDI:	BLOCK 6			;JOBS DIRECTORY

	QSIZ==.-Q.MEM

;START OF CONTROL FILE PARAMETER AREA

QCTL:
C.FSTR:	BLOCK 1			;FILE STRUCTURE NAME
C.FDIR:	BLOCK 6			;FULL PATH NAME
C.FNAM:	BLOCK 1			;ORIGINAL NAME
C.FEXT:	BLOCK 1			;ORIGINAL EXTENSION
C.FRNM:	BLOCK 1			;RENAMED NAME
C.FBIT:	BLOCK 1			;START WORD
C.FMOD:	BLOCK 1			;MODIFY WORD

	QDCTL==.-C.FSTR

;START OF LOG FILE PARAMETER AREA

QLOG:
L.FSTR:	BLOCK 1			;FILE STRUCTURE NAME
L.FDIR:	BLOCK 6			;FULL PATH NAME
L.FNAM:	BLOCK 1			;ORIGINAL NAME
L.FEXT:	BLOCK 1			;ORIGINAL EXTENSION
L.FRNM:	BLOCK 1			;RENAMED NAME
L.FBIT:	BLOCK 1			;START WORD
L.FMOD:	BLOCK 1			;MODIFY WORD


	QDLOG==.-L.FSTR

	QDSIZ==QSIZ+QDCTL+QDLOG
LABEL:	BLOCK	1		;SAVE LABEL USED WITH GOTO COMMAND
ERRCOD:	BLOCK	1		;SAVE LOGIN ERROR CODE
BAKCHK:	BLOCK	1		;SAVE DISK ACCESS,TIME ETC
CTLCNT:	BLOCK	1		;NUMBER OF CHARACTERS INPUTED
BKCCNT:	BLOCK	1		;CTL COUNT FOR CHARACTER
LOGCNT:	BLOCK	1		;NUMBER OF CHARACTERS OUTPUTED.
LINPTR:	BLOCK	1
LOTPTR:	BLOCK	1
SIZE==.-MSTBLI

SECDTA:	BLOCK	<JOBMAX-1>*SIZE	;CORE RESERVED FOR 13 OTHER JOB STREAMS.
	IFL	FTOPR,<
OPREND:	END
	>
	IFGE	FTOPR,<
BATEND:	END	BATCON
	>

   @c