!13 MAR 73   NIFMT.SIM   FORMATTING ROUTINES     *CW

!CAUTION ****** THIS IS A DUPLICATE OF A DEFINITION IN NILST  *****
DEF L.EL.SZ AS 0
DEF EL.SIZE(N) AS AR.CELL(N,L.EL.SZ)
DEF CR AS FM.CR(BUF)
!CAUTION ***** THIS A DUPLICATE DEFINITION *****
DEF HT(I) AS AR.CELL(AR.N(H.T.AREA),I)

FIND WORKSPACE(0)
FIND STACK.Q
FIND P.Q.AREA
FIND LINE.WORK.SIZE
FIND S.TBL.PTR
FIND RADIX
FIND STORE(0)
FIND H.T.SZ
FIND H.T.AREA
FIND CR.STRING

FIND %WORK.TO.BUF
FIND %AR.OFF
FIND %AR.N
FIND %R.P.CDR
FIND %R.C.B.HEAD
FIND %R.C.B.TEXT
FIND %R.C.B.ADDR
FIND %R.C.B.SEND
FIND %R.C.B.C.TIME
FIND %R.C.B.SEQ.NO
FIND %R.C.B.F.SW.P
FIND %R.C.B.F.TEXT.P
FIND %R.C.B.INCOMP.P
FIND %R.C.B.S.B
FIND %R.C.B.L.O.TIME
FIND %R.C.B.L.I.TIME
FIND %R.C.B.S.O
FIND %R.FAST.VALUE
FIND %R.FAST.TYPE
FIND %R.FAST.LINK
FIND %R.BUF.N.C
FIND %R.S.NAME
FIND %R.S.TYPE
FIND %R.S.V.TYPE
FIND %R.S.VALUE
FIND %R.S.LOCK.P
FIND %Q.PUSH
FIND %Q.POP
FIND %R.P.L.DATA
FIND %L.P.L.DATA
FIND %FM.FR.INT         !FORMAT INTEGER IN FREE FIELD
FIND %APPLY
FIND %P.R.LIST
FIND %OUT.BUF
FIND %FM.BUF.CHARS
FIND %FM.STRING
FIND %G.ELMT

GLOBAL.PROC(FM.INT,H.FM.INT)
GLOBAL.PROC(FM.CR,H.FM.CR)
GLOBAL.PROC(FM.R.C.B,H.FM.R.C.B)
GLOBAL.PROC(FM.ELMT,H.FM.ELMT)
GLOBAL.PROC(FM.LIST,H.FM.LIST)
GLOBAL.PROC(FM.PTR,H.FM.PTR)
GLOBAL.PROC(FM.TIME,H.FM.TIME)
GLOBAL.PROC(FM.QUEUE,H.FM.QUEUE)
GLOBAL.PROC(OUT.MAP,H.OUT.MAP)
GLOBAL.PROC(OUT.B.S,H.OUT.B.S)
GLOBAL.PROC(FM.SYMBOLS,H.FM.SBOLS)
GLOBAL.PROC(FM.SYM,H.FM.SYM)
GLOBAL.PROC(FM.SYM.LIST,H.FM.S.LIST)
GLOBAL.PROC(FM.HASH,H.FM.HASH)
GLOBAL.PROC(USE.RADIX,H.USE.RADIX)
!
PROC(FM.SYM,H.FM.SYM,'FM.SYM',(BUF,SYM))  !FORMAT A SYMBOL FOR OUTPUT
!INPUT: BUFFERLET STRING PTR, OR E.O.L; PTR TO SYM TBL ENTRY
!VALUE: BUFFERLET STRING PTR

LOCAL S.V.T,S.V
TABLE S.TYPES(0:4)['NIL','COMMAND','CHANNEL','VARIABLE','FILE']
TABLE S.V.TYPES(0:3)['NIL','INTEGER','LITERAL','POINTER']

!FOR DEBUGGING ***
!BUF _ FM.STRING(BUF,CHPT('SYMBOL: '))

!THE FOLLOWING CODE IS FOR DEBUGGING ***
!FM.STRING(BUF,CHPT('AT '))
!FM.PTR(BUF,SYM)
!FM.STRING(BUF,CHPT(' LINK: '))
!FM.PTR(BUF,R.P.CDR(SYM))
!CR
!BUF _ FM.STRING(BUF,CHPT(' NAME: '))

BUF _ APPLY(%FM.BUF.CHARS,BUF,R.S.NAME(SYM))
FM.STRING(BUF,CHPT(', TYPE: '))
FM.STRING(BUF,CHPT(S.TYPES(R.S.TYPE(SYM))))  !TYPE
FM.STRING(BUF,CHPT(','))
S.V.T _ R.S.V.TYPE(SYM)
S.V _ R.S.VALUE(SYM)
IF R.S.V.TYPE(SYM) = S.V.T.IND &
 THEN &
  DO
  FM.STRING(BUF,CHPT(' FAST('))        !FAST CASE
  FM.FR.INT(BUF,R.S.VALUE(SYM))
  FM.STRING(BUF,CHPT(')'))
  S.V.T _ R.FAST.TYPE(R.S.VALUE(SYM))
  S.V _ R.FAST.VALUE(R.S.VALUE(SYM))
  IF R.FAST.LINK(R.S.VALUE(SYM)) # SYM &
   THEN FM.STRING(BUF,CHPT(' BAD FAST LINK.'))
  END

FM.STRING(BUF,CHPT(' VALUE-TYPE: '))   !VALUE TYPE
FM.STRING(BUF,CHPT(S.V.TYPES(S.V.T)))
FM.STRING(BUF,CHPT(', VALUE: '))
DO S.V.T OF 0:S.V.T.MAX                !SYMBOL VALUES

S.V.T.NIL:  IF S.V = T.V.T.NIL &
             THEN FM.STRING(BUF,CHPT('NIL')) &
             ELSE FM.STRING(BUF,CHPT('NOT NIL'))

S.V.T.INT:  FM.FR.INT(BUF,S.V)

S.V.T.LIT:  BUF _ APPLY(%FM.BUF.CHARS,BUF,S.V)

S.V.T.PTR:  FM.PTR(BUF,S.V)
END
IF R.S.LOCK.P(SYM) THEN FM.STRING(BUF,CHPT(', LOCK'))   !LOCK
!CR
RETURN(BUF)
END.PROC(FM.SYM,H.FM.SYM)
!
PROC(FM.SYM.LIST,H.FM.S.LIST,'FM.SYM.LIST',(BUF,LIST))  !FORMAT A
                                                !SYMBOL LIST
!INPUT: BUFFERLET STRING PTR, OR E.O.L; SYMBOL LIST PTR
!VALUE: BUFFERLET STRING PTR, OR E.O.L

WHILE LIST # E.O.L &
 THEN &
  DO
  BUF _ FM.SYM(BUF,LIST)
  LIST _ R.P.CDR(LIST)
  END
RETURN(BUF)
END.PROC(FM.SYM.LIST,H.FM.S.LIST)
!
PROC(FM.HASH,H.FM.HASH,'FM.HASH',(BUF))  !FORMAT A HASH TBL FOR OUTPUT
!INPUT: BUFFERLET STRING PTR, OR E.O.L
!VALUE: BUFFERLET STRING PTR, OR E.O.L

LOCAL I,ENT,SAVE.RADIX

SAVE.RADIX _ RADIX <== 8

BUF _ FM.STRING(BUF,CHPT('SYMBOLS:'))
CR

I _ -1
WHILE INC I < H.T.SZ &
 THEN &
  DO
  IF (ENT _ H.T(I)) # 0 &
   THEN &
    DO
    BUF _ FM.STRING(BUF,CHPT('HASH '))
    FM.INT(BUF,I,6)
    FM.STRING(BUF,CHPT(' = '))
    IF  AR.N(ENT) # AR.N(S.TBL.PTR)  &
      THEN  FM.INT(BUF,ENT,13)  &
    ELSE DO
      FM.PTR(BUF,ENT)
      CR
      BUF _ FM.SYM.LIST(BUF,ENT)
    END
    OUT.B.S(TEL,BUF,%OUT.BUF)
    P.R.LIST(BUF)
    BUF _ E.O.L
    END
  END
RADIX _ SAVE.RADIX
RETURN(BUF)
END.PROC(FM.HASH,H.FM.HASH)
!
PROC(FM.SYMBOLS,H.FM.SBOLS,'FM.SYMBOLS',(BUF))  !FORMAT THE
                                                !SYMBOLS IN A TABLE
!INPUT: BUFFERLET STRING POINTER OR E.O.L
!VALUE: BUFFERLET STRING POINTER, OR E.O.L

LOCAL SAVE.RADIX,I,ENT

SAVE.RADIX _ RADIX <== 8

BUF _ FM.STRING(BUF,CHPT('SYMBOLS:'))
CR

I _ -1
WHILE INC I < H.T.SZ &
 THEN &
  DO
  IF (ENT _ H.T(I)) # 0 &
   THEN &
    DO
    BUF _ FM.SYM.LIST(BUF,ENT)
    OUT.B.S(TEL,BUF,%OUT.BUF)
    P.R.LIST(BUF)
    BUF _ E.O.L
    END
  END

RADIX _ SAVE.RADIX

RETURN(BUF)
END.PROC(FM.SYMBOLS,H.FM.SBOLS)
!
PROC(OUT.MAP,H.OUT.MAP,'OUT.MAP',(FILE.NUMBER,%FN1,%FN2,A1,A2))
!INPUT:  FILE NUMBER,
!        THE FUNCTION1 TO BE PASSED TO OUT.B.S (EITHER OUT.BUF OR
!                                                OR OUT.X.BUF)
!        THE FUNCTION2 TO BE CALLED TO DO THE SPECIFIC FORMATTING
!        ARGUMENT1 OF THE FUNCTION2 CALL, I.E., THE THING TO BE FORMATTED
!        ARGUMENT2 (IF ANY) OF THE FUNCTION2 CALL
!VALUE:  THE VALUE OF OUT.B.S   (NONE)


!MAP FUNCTION TO OUTPUT ROUTINE
!THIS ROUTINE IS INTENDED TO WORK WITH THE FM.* SERIES OF ROUTINES


LOCAL  BUF,VAL

BUF  _  FN2(E.O.L,A1,A2)
OUT.B.S(FILE.NUMBER,BUF,%FN1)
P.R.LIST(BUF)

RETURN

END.PROC(OUT.MAP,H.OUT.MAP)
!

PROC(OUT.B.S,H.OUT.B.S,'OUT.B.S',(FILE.NUMBER,BUF.LIST,%FN1))
!INPUT:  FILE.NUMBER DETERMINED BY THE IOCS OPEN (MAY BE TEL)
!        BUFFERLET STRING PTR TO BE OUTPUT
!        THE FLAVOR OF OUT.BUF ROUTINE TO USE(OUT.BUF OR OUT.X.BUF)
!VALUE:  FILE.NUMBER

!THE CHARACTERS IN THE BUFFERLET STRING ARE OUTPUT TO THE FN FILE


LOCAL PTR,FN

FN _ FILE.NUMBER

IF BITS.PER.WORD/25 # 1  &
  THEN  &
    IF FILE.NUMBER=0  THEN  FN _ 1

WHILE  BUF.LIST # E.O.L      &
    THEN      &
      DO
         FN1(FN,BUF.LIST)
         BUF.LIST  _  R.P.CDR(BUF.LIST)
     END
W(FN,CARRET)
LINE.WORK.SIZE  _  0

RETURN(FILE.NUMBER)

END.PROC(OUT.B.S,H.OUT.B.S)
!
PROC(FM.LIST,H.FM.LIST,'FM.LIST',(BUF,LIST))  !FORMAT A LIST FOR OUTPUT
!INPUT: BUFFERLET STRING POINTER, OR E.O.L; LIST POINTER
!VALUE: BUFFERLET STRING POINTER

!THE FORMAT IS LIKE:
!LIST: <PTR>
!<ELEMENT>
!    .
!    .
!    .
!<ELEMENT>

BUF _ FM.STRING(BUF,CHPT('LIST: '))
FM.PTR(BUF,LIST)
CR
WHILE LIST # E.O.L &
 THEN &
  DO
  BUF _ FM.ELMT(BUF,LIST)
  LIST _ R.P.CDR(LIST)
  END

RETURN(BUF)
END.PROC(FM.LIST,H.FM.LIST)
!
PROC(FM.PTR,H.FM.PTR,'FM.PTR',(BUF,PTR))  !FORMAT A POINTER FOR OUTPUT
!INPUT: A BUFFERLET STRING POINTER, OR E.O.L; A POINTER
!VALUE: A BUFFERLET STRING POINTER

!THE FORMATTED PTR WILL BE APPENDED TO THE BUFFERLET STRING.
!THE FORMAT OF THE OUTPUT IS <INT>*<INT> FOR THE AREA AND OFFSET,
!RESPECTIVELY.  CONVERSION IS DECIMAL. FIELD SIZE IS MACHINE
!DEPENDENT

LOCAL SAVE.RADIX
!            OFFSET FIELD: 6 CHARS
!FOR 949:    AREA FIELD:   2 CHARS
!FOR PDP-10: AREA FIELD:   6 CHARS

SAVE.RADIX _ RADIX <== 8         !ALWAYS OUTPUT PTR IN OCTAL
IF PTR # E.O.L &
 THEN &
  DO
  BUF _ FM.INT(BUF,AR.N(PTR),2+4*(BITS.PER.WORD/25))
  FM.STRING(BUF,CHPT('*'))
  FM.INT(BUF,AR.OFF(PTR),6)
  END &
 ELSE &
  DO
  !E.O.L CASE
  IF PDP.10.P &
   THEN BUF _ FM.STRING(BUF,CHPT('        E.O.L')) &
   ELSE BUF _ FM.STRING(BUF,CHPT('    E.O.L'))
  END
RADIX _ SAVE.RADIX
RETURN(BUF)
END.PROC(FM.PTR,H.FM.PTR)
!
PROC(FM.TIME,H.FM.TIME,'FM.TIME',(BUF,T))  !FORMAT TIME FOR OUTPUT
!INPUT: BUFFERLET STRING POINTER, OR E.O.L; TIME
!VALUE: BUFFERLET STRING POINTER

!TEMPORARY ROUTINE   **********

RETURN(FM.INT(BUF,T,8+3*(BITS.PER.WORD/25)))
END.PROC(FM.TIME,H.FM.TIME)
!
PROC(FM.QUEUE,H.FM.QUEUE,'FM.QUEUE',(BUF,Q))  !FORMAT A QUEUE FOR OUTPUT
!INPUT: BUFFERLET STRING POINTER, OR E.O.L; QUEUE POINTER
!VALUE: BUFFERLET STRING POINTER

WHILE Q # E.O.L &
 THEN &
  DO
  BUF _ FM.PTR(BUF,R.P.CDR(Q))
  FM.STRING(BUF,CHPT(' '))
  FM.PTR(BUF,R.P.L.DATA(Q,1))
  CR
  Q _ R.P.CDR(Q)
  END

RETURN(CR)
END.PROC(FM.QUEUE,H.FM.QUEUE)
!
PROC(FM.ELMT,H.FM.ELMT,'FM.ELMT',(BUF,EL))  !FORMAT AN ELEMENT
!INPUT: BUFFER STRING PTR, OR E.O.L; ELEMENT POINTER
!VALUE: BUFFER STRING POINTER

!AN ELEMENT IS FORMATTED FOR OUTPUT IN A BUFFERLET STRING.
!THE CDR OF THE ELEMENT IS FORMATTED AS A PTR.
!EACH DATA WORD OF THE ELEMENT IS FORMATTED BOTH AS AN OCTAL
!NUMBER, AND AS A PTR, ONE WORD PER LINE.

LOCAL I,SAVE.RADIX

!VALIDATE ELMT

IF EL = E.O.L THEN RETURN(BUF)
IF NOT 1<AR.N(EL)<=NUM.AREAS THEN RETURN(BUF)
IF NOT AR.OFF(EL)<AR.SIZE(AR.N(EL)) THEN RETURN(BUF)
BUF _ FM.STRING(BUF,CHPT(' AT '))
FM.PTR(BUF,EL)
CR

FM.PTR(BUF,R.P.CDR(EL))
CR

I _ 0
SAVE.RADIX _ RADIX <== 2
WHILE INC I < EL.SIZE(AR.N(EL)) &
 THEN &
  DO
! FM.INT(BUF,R.P.L.DATA(EL,I),8+4*(BITS.PER.WORD/25))
! FM.INT(BUF,R.P.L.DATA(EL,I),BITS.PER.WORD)
! FM.STRING(BUF,CHPT(' '))
  FM.PTR(BUF,R.P.L.DATA(EL,I))
  CR
  END
RADIX _ SAVE.RADIX

CR
OUT.B.S(TEL,BUF,%OUT.BUF)
P.R.LIST(BUF)
BUF _ E.O.L

RETURN(BUF)
END.PROC(FM.ELMT,H.FM.ELMT)
!
PROC(FM.R.C.B,H.FM.R.C.B,'FM.R.C.B',(BUF,C.B))  !FORMAT A R.C.B
!INPUT: BUFFERLET STRING POINTER, OR E.O.L; RECORD CONTROL BLK PTR
!VALUE: BUFFERLET STRING PTR

LOCAL %FM.R.C.B.ADDR
LOCAL P,  SAVE.RADIX

IF C.B = E.O.L  THEN  RETURN (BUF)

!1ST LINE
! TO, FROM, TIME,SEQ. NO.
BUF _ FM.STRING(BUF,CHPT(' TO '))
FM.R.C.B.ADDR(BUF,R.C.B.ADDR(C.B))
FM.STRING(BUF,CHPT(', FROM '))
FM.R.C.B.ADDR(BUF,R.C.B.SEND(C.B))
FM.STRING(BUF,CHPT(', TIME: '))
FM.FR.INT(BUF,R.C.B.C.TIME(C.B))
IF R.C.B.SEQ.NO(C.B) # 0 &
 THEN &
  DO
  FM.STRING(BUF,CHPT(', SEQ. NO.: '))
  SAVE.RADIX _ RADIX <== 8
  FM.FR.INT(BUF,R.C.B.SEQ.NO(C.B))
  RADIX _ SAVE.RADIX
  END
CR

!2ND LINE
P _ FALSE
!BEING FORWARD SWITCHED?
IF R.C.B.F.SW.P(C.B) &
 THEN &
  DO
  FM.STRING(BUF,CHPT('BEING FORWARD SWITCHED.  '))
  P _ TRUE
  END
!INCOMPLETE?
IF R.C.B.INCOMP.P(C.B) &
 THEN &
  DO
  FM.STRING(BUF,CHPT('INCOMPLETE.  '))
  P _ TRUE
  END
!FREE TEXT
IF R.C.B.F.TEXT.P(C.B) &
 THEN &
  DO
  FM.STRING(BUF,CHPT('FREE TEXT.'))
  P _ TRUE
  END
IF P THEN CR

!3RD LINE
P _ FALSE
!LAST TIME IN
IF R.C.B.INCOMP.P(C.B) &
 THEN &
  DO
  FM.STRING(BUF,CHPT('LAST TIME IN: '))
  FM.TIME(BUF,R.C.B.L.I.TIME(C.B))
  P _ TRUE
  END
!LAST TIME OUT
IF R.C.B.L.O.TIME(C.B) # 0 &
 THEN &
  DO
  FM.STRING(BUF,CHPT(' LAST OUT TIME: '))
  FM.TIME(BUF,R.C.B.L.O.TIME(C.B))
  P _ TRUE
  END
IF P THEN CR

!4TH LINE
!HEADER
IF R.C.B.HEAD(C.B) # E.O.L &
 THEN &
  DO
  FM.STRING(BUF,CHPT('HEADER: '))
  BUF _ APPLY(%FM.BUF.CHARS,BUF,R.C.B.HEAD(C.B))
  CR
  END

!5TH LINE
!TEXT
IF R.C.B.TEXT(C.B) # E.O.L &
 THEN &
  DO
  FM.STRING(BUF,CHPT('TEXT: '))
  BUF _ APPLY(%FM.BUF.CHARS,BUF,R.C.B.TEXT(C.B))
  CR
  END

!VARIABLES AND STUFF
!SCAN CONTROL INFORMATION
IF R.C.B.S.B(C.B) # E.O.L &
 THEN &
  DO
  IF R.C.B.S.B(C.B) # R.C.B.TEXT(C.B) AND R.C.B.S.O(C.B)#0 &
   THEN &
    DO
    FM.STRING(BUF,CHPT('SCAN BUFFERLET: '))
    FM.PTR(BUF,R.C.B.S.B(C.B))
    FM.STRING(BUF,CHPT('; SCAN OFFSET: '))
    FM.INT(BUF,R.C.B.S.O(C.B),3)
    FM.STRING(BUF,CHPT('; CHARS IN BUFFERLET: '))
    FM.FR.INT(BUF,R.BUF.N.C(R.C.B.S.B(C.B)))
   !FM.PTR(BUF,P.CDR(R.C.B.S.B(C.B)))
    LOCAL TEMP1                   !HACK
    TEMP1 _ R.C.B.S.B(C.B)     !HACK
    TEMP1 _ R.P.CDR(TEMP1)          !HACK
    FM.PTR(BUF,TEMP1)             !HACK
    CR
    FM.STRING(BUF,CHPT('BUFFERLET CHARS: '))
    BUF _ FM.BUF.CHARS(BUF,R.C.B.S.B(C.B))
    END
  END
RETURN(BUF)
!
%FM.R.C.B.ADDR(BUF,ADDR)        !FORMAT ADDRESS FOR OUTPUT
!INPUT: BUFFERLET STRING POINTER, OR E.O.L; A MODULE ADDR
!VALUE: BUFFERLET STRING POINTER

LOCAL P, SAVE.RADIX

SAVE.RADIX _ RADIX <== 8
P _ FALSE
IF ADDR >= 128 &
 THEN &
  DO
  P _ TRUE
  ADDR _ ADDR BAND OCT 177
  END
IF ADDR = 0 &
 THEN FM.STRING(BUF,CHPT('MASTER')) &
 ELSE FM.FR.INT(BUF,ADDR)
IF P THEN FM.STRING(BUF,CHPT(':M'))
RADIX _ SAVE.RADIX
RETURN(BUF)
END FM.R.C.B.ADDR
END.PROC(FM.R.C.B,H.FM.R.C.B)


PROC(FM.CR,H.FM.CR,'FM.CR',(BUF))
!#####

RETURN(FM.STRING(BUF,CHPT(@CR.STRING)))
END.PROC(FM.CR,H.FM.CR)
!
PROC(USE.RADIX,H.USE.RADIX,'USE.RADIX',(R,%FN,ARG1,ARG2,ARG3))
!FN(ARG1,ARG2,ARG3) WILL BE RETURNED, AND RADIX R WILL BE IN EFFECT
!DURING ITS EXECUTION

LOCAL VAL

Q.PUSH(STACK.Q,RADIX)
Q.PUSH(STACK.Q,RETURN)
RADIX _ R
VAL _ FN(ARG1,ARG2,ARG3)
RETURN _ Q.POP(STACK.Q)
RADIX  _ Q.POP(STACK.Q)

RETURN (VAL)

END.PROC(USE.RADIX,H.USE.RADIX)
!
PROC(FM.INT,H.FM.INT,'FM.INT',(STRING,NUMBER,FIELD)) !FORMAT AN
                                        !INTEGER IN A FIXED FIELD
!INPUT: STRING POINTER, A NUMBER, A FIELD SIZE
!VALUE: STRING POINTER

!FORMATS AN INTEGER AS ASCII-8 CHARACTERS ON END OF BUFFERLET STRING.
!INTEGER IN LOW-ORDER PORTION OF FIELD.
!SIGN: FORMATED NEXT TO THE INTEGER. SIGN IS SPACE IF NUMBER IS
!POSITIVE, "-" OTHERWISE.  LEADING ZEROS ARE SUPPRESSED. ZERO
!NUMBER YIELDS "0".  IF THE FIELD IS TOO SMALL FOR THE INTEGER,
!THEN IT IS FORMATTED AS A STRING OF "X"S.  IF THERE IS NO
!ROOM FOR A "-" SIGN, THEN THE FIELD IS FORMATTED AS A
!STRING OF "-"S.  IF FIELD SIZE IS <= 0 THEN ONE GETS A ZERO
!LENGTH FIELD.  RADIX 2 IS A SPECIAL CASE

LOCAL I, SIGN, OSIGN !ORIGINAL SIGN!, OFIELD !ORIGINAL FIELD!

IF FIELD <= 0 THEN RETURN(STRING)
WORK.SPACE(0) _ OFIELD _ FIELD

IF RADIX = 2 &
 THEN &
  DO
  IF NUMBER = 0 &
   THEN &
    DO          !BINARY ZERO CASE
    WORK.SPACE(FIELD) _ XZERO      !FORCE '0'
    REPEAT FIELD-1 WORKSPACE(DEC FIELD) _ XSP
    RETURN(WORK.TO.BUF(STRING))
    END
  WHILE FIELD > 0 &
   THEN &
    DO
    !           RADIX 2 CONVERSION
    WORKSPACE(1+DEC FIELD) _ (NUMBER BAND 1)+XZERO
    NUMBER _ NUMBER SHR 1
    END
  RETURN(WORK.TO.BUF(STRING))
  END


!SET SIGN
IF NUMBER >= 0 &
 THEN SIGN _ XSP &
 ELSE &
  DO
  SIGN _ XMINUS
  NUMBER _ -NUMBER
  END
OSIGN _ SIGN

!FORM CHARACTERS IN WORKSPACE
IF NUMBER =0 &
 THEN &
  DO             !ZERO CASE
  WORK.SPACE(FIELD) _ XZERO   !FORCE '0'
  REPEAT FIELD-1 WORKSPACE(DEC FIELD) _ XSP
  END &
 ELSE &
  DO             !ROUTINE CASE
  WHILE FIELD > 0 &
   THEN &
    DO
    IF NUMBER # 0 &
     THEN &
      DO 
     !WORK.SPACE(1+DEC FIELD) _ XZERO + (NUMBER MOD RADIX)
      LOCAL TEMP
      TEMP _ XZERO + (NUMBER MOD RADIX)
      WORK.SPACE(1+DEC FIELD) _ TEMP
      NUMBER _ NUMBER/RADIX
      END &
     ELSE &
      DO
      WORKSPACE(1+DEC FIELD) _ SIGN
      SIGN _ XSP     !SET TO PROVIDE LEADING SPACES
                     !AND NOTE '-' USED
      END
    END
  IF NUMBER # 0 &
   THEN &
    DO         !NUMBER TOO BIG FOR FIELD
    REPEAT OFIELD WORK.SPACE(1+DEC OFIELD) _ XX
    END &
   ELSE &
    DO
    IF SIGN = XMINUS &
     THEN &
      DO       !NOT ENOUGH ROOM FOR NEGATIVE SIGN, FLAG IT
      REPEAT OFIELD WORK.SPACE(1+DEC OFIELD) _ XMINUS
      END
    END
  END
RETURN(WORK.TO.BUF(STRING))
END.PROC(FM.INT,H.FM.INT)
 