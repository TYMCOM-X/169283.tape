	TITLE	MIMPT
	SUBTTL	VERSION 2 IN MACRO-10;SLH

	;721128

	VERS==2
	MOD==0

	JOBFF=121
	JOBREN=124
	JOBVER=137

	LOC	JOBVER
	XWD	MOD,VERS

	LOC	JOBREN
	PTREN			;RE-ENTRY ADDRESS

	RELOC			;RELOCATABLE


;AC'S

	F==0		;FLAGS
	T1==1		;TEMPORARY
	T2==2
	T3==3
	T4==4
	CHR==5		;CHARACTER AC
	ONUM==6		;OCTAL NUMBER AC
	PTR==7		;GET STRING POINTER
	P==17		;PUSHDOWN LIST POINTER


;FLAGS IN RIGHT-HALF OF FLAG AC

	QOUTP==1	;OUTPUT SIDE OF "_"
	QSCHR==2	;SWITCH FLAG
	QFFX==4		;FILEX FLAG
	QSUP==10	;ZERO SUPPRESS FLAG

;MISCELLANEOUS

	CR==15		;CARRIAGE RETURN VALUE
	LF==12		;LINE FEED
OPDEF	PJRST	[JRST]

DEFINE	GETCHR
	<AOS	CMDPTR
	MOVE	T1,@CMDPTR>


DEFINE	SWTAB (X)
	<IRPC	X
	<XWD	"X",X'SWCH>
	 0>


DEFINE	ERMSG (A)
	<MOVEI	PTR,[ASCIZ \A\]
	 JRST	TYPMES
	>
;HERE IS BEGINNING OF MIMPT

MIMPT:	CALLI	0		;RESET I/O
	SETZM	ODMODE		;SET DEFAULT VALUES
	SETOM	ODASCII		;OUTPUT DEFAULT IS ASCII

;RE-ENTRY POINT WHICH LEAVES DEFAULTS AS THEY WERE

PTREN:	INIT	0,1		;INITIALIZE COMMAND INPUT DEVICE
	SIXBIT	/TTY/		;ASSUMED FOR NOW TO BE TELETYPE
	TTYHDR
	CALLI	12		;TTY INIT FAILED, GIVE UP!!
	MOVEI	T1,TTYBFR	;TTY BUFFER AREA
	EXCH	T1,JOBFF
	INBUF	0,2		;TYPE-AHEAD ALLOWED
	MOVEM	T1,JOBFF	;RESTORE JOBFF

;NOW START THE REAL BUSINESS

MAINLP:	MOVE	P,[IOWD 20,PDLST]	;SET PUSHDOWN LIST POINTER
	MOVEI	T1,FXITBL+4	;SET FILEX FORMAT TABLE POINTERS
	MOVEM	T1,FXIPTR
	MOVEI	T1,FXOTBL+4
	MOVEM	T1,FXOPTR
	SETZ	F,		;CLEAR FLAGS
	PUSHJ	P,GETCMD	;GET THE COMMAND, SCAN AND SET THINGS

DEVINI:	SETZ	T1,		;OPEN DEVICES FOR INPUT AND OUTPUT
	SKIPL	IASCII		;ASCII MODE?
	MOVEI	T1,10		;NO IMAGE MODE.  IF ASCII, LEAVE MODE ZERO
	SKIPN	T2,IDEV		;GET INPUT DEVICE
	MOVSI	T2,(SIXBIT /DSK/)	;USE DEFAULT DEVICE
	MOVEI	T3,INHDR	;INPUT DEVICE HEADER
	OPEN	1,T1		;OPEN INPUT CHANNEL
	 JRST	OPNIER		;FAILED.  TELL USER AND EXIT
	MOVE	T1,IFIL		;NOW GET INPUT FILE NAME AND EXTENSION
	MOVE	T2,IEXT
	SETZ	T3,
	MOVE	T4,IPPN		;GET PPN
	LOOKUP	1,T1		;TRY TO FIND THE FILE
	 JRST	LKIERR		;PROBABLY DOESN'T EXIST.  TSK, TSK
	MOVEI	T1,INBUFR	;GET INPUT BUFFER ADDRESS
	EXCH	T1,JOBFF	;SET JOBFF TO FOOL MONITOR
	INBUF	1,2		;TWO BUFFERS FOR INPUT
	MOVEM	T1,JOBFF	;RESTORE JOBFF
	SETZ	T1,		;NOW DO SAME FOR OUTPUT DEVICE
	SKIPL	OASCII		;OUTPUT ASCII?
	MOVEI	T1,10		;NO, SET IMAGE MODE
	SKIPN	T2,ODEV		;GET OUTPUT DEVICE
	MOVSI	T2,(SIXBIT /DSK/)
	MOVSI	T3,OUTHDR	;AND OUTPUT HEADER
	OPEN	2,T1		;OPEN OUTPUT SIDE
	 JRST	OPNOER		;WON'T DO IT
	MOVE	T1,OFIL		;SET UP TO ENTER OUTPUT FILE
	MOVE	T2,OEXT
	SETZ	T3,
	MOVE	T4,OPPN
	ENTER	2,T1		;ENTER FILE FOR WRITING
	 JRST	ENTOER		;NO, GO
	MOVEI	T1,OUTBFR	;GET OUTPUT BUFFER ADDRESS
	EXCH	T1,JOBFF	;HACK
	OUTBUF	2,2		;TWO OUTPUT BUFFERS
	MOVEM	T1,JOBFF	;RESTORE JOBFF
;THIS PAGE IS THE GUTS OF MIMPT FOR WHICH ALL OF THE SURROUNDING
;CODE IS MERELY THE UNDERPINNING.
;THE TIP OF THE ICEBERG, SO TO SPEAK.

PACKL:	PUSHJ	P,GETBYT	;GET A BYTE. NEVER RETURNS IF EOF
	SKIPL	OASCII		;ASCII OUTPUT?
	JRST	OUTBIN		;NO, SOME KIND OF 8-BIT OUTPUT
	ANDI	CHR,177		;REDUCE CHARACTER TO 7 BITS
PCKLP1:	PUSHJ	P,PUTBYT	;OUTPUT BYTE
	JRST	PACKL		;DO NEXT CHARACTER

OUTBIN:	ANDI	CHR,377		;OUTPUT IS 8 BITS
	SKIPN	OMODE		;MODE NOT SPECIFIED?
	JRST	PCKLP1		;YES, SEND 8 BITS AS IS
	ANDI	CHR,177		;REDUCE TO 7 BITS AND ADD 8TH AS SPECIFIED
	SKIPG	OMODE		;MODE PARITY?
	JRST	DOPAR		;YES, CALCULATE SAME
	XORI	CHR,200		;CREATE 8TH BIT
	AND	CHR,OMODE	;AND MASK APPROPRIATELY
	JRST	PCKLP1		;AND OUTPUT BYTE

DOPAR:	MOVNI	T2,7		;COUNT IS 7
	MOVEI	T1,1		;SET LOW-ORDER BIT
	TRNE	CHR,(T1)	;BIT SET?
	XORI	CHR,200		;YES, SET/CLEAR 8TH BIT
	LSH	T1,1		;SHIFT BIT MASK
	AOJL	T2,.-3		;DO 7 TIMES
	XOR	CHR,OMODE	;ONCE MORE WITH MODE SPEC
	ANDI	CHR,377		;MAKE SURE 8 BITS ONLY
	JRST	PCKLP1		;AND DO OUTPUT

;SEE HOW SIMPLE THAT WAS??
;GET A BYTE

GETBYT:	SKIPLE	IASCII		;INPUT FILEX MODE?
	JRST	GETFX		;YES, SPECIAL HANDLING
GET2:	PUSHJ	P,GTBYT		;DO INPUT
	 JRST	CLNUP		;EOF, CLEAN UP WORLD
	SKIPL	IASCII		;ASCII MODE?
	POPJ	P,0		;NO, SIMPLY RETURN
	JUMPE	CHR,GET2	;IGNORE NULLS IN ASCII MODE
	POPJ	P,0		;RETURN

GETFX:	SKIPE	@FXIPTR		;END OF BYTE TABLE?
	JRST	GETFX1
	PUSHJ	P,GTBYT		;NO, GET ONE
	 JRST	CLNUP		;EOF SEEN, CLEAN UP
	MOVEM	CHR,FXIWRD	;SAVE NEW INPUT WORD
	MOVEI	T1,FXITBL	;RESET POINTER
	MOVEM	T1,FXIPTR
GETFX1:	LDB	CHR,@FXIPTR	;GET BYTE
	AOS	FXIPTR		;INCREMENT PTR
	POPJ	P,0		;DONE, RETURN

GTBYT:	SOSLE	INHDR+2		;EMPTY BUFFER?
	JRST	GTBYT1		;NO, GET CHAR
	INPUT	1,		;INPUT ANOTHER BUFFER
	STATZ	1,740000	;ERRORS?
	JRST	GTERR		;YES
	STATZ	1,20000		;EOF BIT SET?
	POPJ	P,0		;YES, JUST RETURN
GTBYT1:	ILDB	CHR,INHDR+1	;GET CHARACTER
	AOS	(P)		;INCREMENT RETURN ADDRESS
	POPJ	P,0

CLNUP:	SKIPG	OASCII		;OUTPUT IN FILEX MODE?
	JRST	.+3
	MOVE	CHR,FXOWRD	;YES, OUTPUT LAST WORD
	PUSHJ	P,PTBYT
	CLOSE	1,		;FOUND EOF, CLOSE ALL FILES
	CLOSE	2,
	RELEASE	1,
	RELEASE	2,
	JRST	MAINLP
;OUTPUT A BYTE

PUTBYT:	TRNE	F,QSUP		;SUPPRESS FLAG ON?
	JUMPE	CHR,PUT3	;YES--IF CHAR IS NULL, RETURN
	SKIPG	OASCII		;FILEX FORMAT?
	PJRST	PTBYT		;NO, OUTPUT CHAR AND RETURN
PUTFX:	SKIPN	@FXOPTR		;AT END OF PTR TABLE?
	 JRST	PUTF1		;YES TO BOTH, RESET THINGS
PUT2:	TRNN	F,QFFX		;FIRST CHARACTER MODE?
	JUMPE	CHR,PUT3	;YES, SKIP NULL CHARACTER
	IORI	F,QFFX		;SET FIRST CHARACTER SEEN
	DPB	CHR,@FXOPTR	;STORE CHARACTER
	AOS	FXOPTR		;INCREMENT TABLE POINTER
PUT3:	POPJ	P,0		;RETURN

PUTF1:	PUSH	P,CHR		;SAVE CHARACTER
	MOVE	CHR,FXOWRD	;GET OUTPUT WORD
	TRNE	F,QFFX		;DON'T OUTPUT IF NO DATA THERE
	PUSHJ	P,PTBYT		;NO, OUTPUT OLD WORD
	POP	P,CHR		;RESTORE NEW CHAR
	SETZM	FXOWRD		;CLEAR OUTPUT WORD
	MOVEI	T1,FXOTBL	;RESTORE TABLE POINTER
	MOVEM	T1,FXOPTR
	JRST	PUT2		;GO STORE THIS CHARACTER

PTBYT:	SOSLE	OUTHDR+2	;BUFFER FULL?
	JRST	PTBYT1		;NO, STILL MORE ROOM
	OUTPUT	2,		;OUTPUT THIS BUFFER
	STATZ	2,740000	;ERRORS?
	JRST	PTERR		;YES, OUTPUT MESSAGE
PTBYT1:	IDPB	CHR,OUTHDR+1	;STORE CHARACTER IN BUFFER
	POPJ	P,0		;RETURN
;FILEX TABLES

FXITBL:	POINT	8,FXIWRD,17
	POINT	8,FXIWRD,9
	POINT	8,FXIWRD,35
	POINT	8,FXIWRD,27
	0

FXOTBL:	POINT	8,FXOWRD,17
	POINT	8,FXOWRD,9
	POINT	8,FXOWRD,35
	POINT	8,FXOWRD,27
	0
;GET THE COMMAND STRING AND SCAN FOR VARIOUS SPECIFICATIONS
;CALLED BY PUSHJ FROM MAIN PROGRAM

GETCMD:	OUTSTR	[ASCIZ /*/]	;OUTPUT READY SIGNAL TO USER
	SETZM	CMDBUF		;ZERO COMMAND BUFFER
	MOVE	T1,[XWD CMDBUF,CMDBUF+1]
	BLT	T1,CMDBUF+^D73
	MOVEI	T2,CMDBUF	;SET CMDPTR TO BEGINNING OF CMDBUFFER
	MOVEM	T2,CMDPTR
	ADDI	T2,^D73		;POINT TO END OF BUFFER
GTLP:	PUSHJ	P,GTTYCR	;GET INPUT CHARACTER
	CAIGE	CHR,175		;BREAK CHARACTER?
	CAIGE	CHR,40
	JRST	BRKCHR		;YES, AUTOMATIC END OF LINE
	MOVEM	CHR,@CMDPTR	;STORE CHARACTER
	AOS	CMDPTR		;INCREMENT CHARACTER BUFFER POINTER
	CAMLE	T2,CMDPTR	;OVERRUN END OF BUFFER?
	JRST	GTLP		;NO, GET NEXT CHARACTER
BRKCHR:	CAIE	CHR,CR		;CURRENT CHAR A CR?
	JRST	BRK1		;NO
	PUSHJ	P,GTTYCR	;SCAN PAST LF
	JRST	BRK2
BRK1:	OUTCHR	[CR]		;OUTPUT CARRIAGE RETURN
	CAIE	CHR,LF		;AND LF UNLESS CHAR WAS LF
	OUTCHR	[LF]
BRK2:	MOVEI	CHR,CR		;STORE CR IN BUFFER
	MOVEM	CHR,@CMDPTR	;STORE END OF LINE AND SCAN
SCANER:	MOVEI	T1,CMDBUF-1
	MOVEM	T1,CMDPTR	;RESET COMMAND POINTER
	ANDCMI	F,QOUTP+QSCHR	;CLEAR BEGINNING FLAGS
	SETZM	OFIL		;CLEAR SPEC STUFF
	MOVE	T1,[XWD OFIL,OEXT]
	BLT	T1,FILDEV	;ZERO SWITCH AREAS
SCAN:	GETCHR			;GET A COMMAND CHARACTER
SCAN1:	CAIN	T1,CR		;CARRIAGE RETURN?
	JRST	EOLIN		;YES, END OF LINE
	CAIN	T1,"/"		;SLASH?
	JRST	GETSW		;YES, FIND SWITCH
	CAIN	T1,"_"		;BACK ARROW?
	JRST	GTAROW		;DO ARROW THING
	IORI	F,QSCHR		;SET FOUND DATA FLAG
	CAIN	T1,"["		;MAYBE PPN?
	JRST	GTPPN		;GET PPN
	SOS	CMDPTR		;SUBTRACT FROM POINTER
	PUSHJ	P,GETSTR	;GET A STRING
	SKIPN	T2,STRWD	;STRING NULL?
	JRST	SYNERR		;ALAS, YES
	CAIN	T1,":"		;TERMINATOR FOR DEVICE?
	JRST	DODEV		;YUP
	SKIPE	FILNAM		;ALREADY HAVE A FILE NAME?
	JRST	SYNERR		;YUP
	MOVEM	T2,FILNAM	;OTHERWISE A FILE NAME
	CAIE	T1,"."		;CURRENT CHAR A PERIOD?
	JRST	SCAN1		;NOPE, LOOK FOR MORE TERMINATORS
	PUSHJ	P,GETSTR	;GET EXTENSION
	MOVE	T2,STRWD	;STRING WORD INTO
	MOVEM	T2,FILEXT	;EXT WORD
	JRST	SCAN1		;GO LOOK AT CURRENT TERMINATOR
;ROUTINES FOR SCANNING OF COMMAND LINE

GETSW:	GETCHR			;GET A CHARACTER FOR SWITCH
	PUSHJ	P,MCHSW		;MATCH IT
	 JRST	SWERR		;NON-EXISTENT SWITCH
	JRST	SCAN		;ON TO NEXT PART OF STRING

DODEV:	SKIPE	FILDEV		;DEVICE ALREADY SPECIFIED?
	JRST	DEVERR		;YES, ERROR
	MOVEM	T1,FILDEV	;STORE DEVICE
	JRST	SCAN		;ON TO NEXT

;ASSEMBLE A SIXBIT STRING INTO STRWD

GETSTR:	SETZM	STRWD		;CLEAR STORAGE WORD
	MOVE	PTR,[POINT 6,STRWD]	;SET UP BYTE POINTER
GTSTR1:	GETCHR
	CAIL	T1,"A"		;IF NOT A-Z
	CAILE	T1,"Z"
	JRST	GTSTR3		;CHECK FOR 0-9
GTSTR2:	SUBI	T1,40		;REDUCE CHAR TO SIXBIT
	TLNE	PTR,770000	;MORE THAN SIX CHARS?
	IDPB	T1,PTR		;STORE CHAR IF NOT MORE THAN SIX
	JRST	GTSTR1		;GET ANOTHER CHARACTER
GTSTR3:	CAIG	T1,"9"		;CHECK FOR 0-9
	CAIGE	T1,"0"
	POPJ	P,0		;FOUND TERMINATOR, RETURN
	JRST	GTSTR2		;STORE NUMBER IN STRING

;PROCESS PPN SPECIFICATION

GTPPN:	PUSHJ	P,GETOCT	;GET OCTAL NUMBER
	CAIE	T1,","		;TERMINATOR A COMMA?
	JRST	PPNERR		;NO, BAD PPN
	HRLZM	ONUM,FILPPN	;LEFT HALF OF PPN
	PUSHJ	P,GETOCT	;GET RIGHT HALF OF PPN
	CAIE	T1,"]"		;RIGHT BRACKET SHOULD TERMINATE
	JRST	PPNERR
	HRRM	ONUM,FILPPN	;STORE LAST HALF OF PPN
	JRST	SCAN		;ON TO NEXT

GETOCT:	SETZ	ONUM,		;CLEAR NUMBER FOR OCTAL INPUT
GTOT1:	GETCHR
	CAIL	T1,"0"		;CHAR 0-7?
	CAILE	T1,"7"
	POPJ	P,0		;NOPE, RETURN
	ANDI	T1,7		;CLEAR EXTRANEOUS BITS
	ROT	ONUM,-6		;SHIFT CURRENT NUMBER TO LEFT
	IORI	ONUM,(T1)	;ADD IN NEW NUMBER
	JRST	GTOT1		;NEXT DIGIT, PLEASE
GTAROW:	TROE	F,QOUTP		;PREVIOUS "_" SEEN?
	JRST	SYNERR		;YES, ERROR
	MOVE	T1,[XWD FILNAM,OFIL]	;XFER SWITCHES FOUND
	BLT	T1,ODEV
	SETZM	FILNAM		;NOW CLEAR SPEC AREA AGAIN
	MOVE	T1,[XWD FILNAM,FILEXT]
	BLT	T1,FILDEV
	JRST	SCAN		;RETURN TO THE FRAY

;CR SEEN--END OF LINE.  CLEAN UP

EOLIN:	MOVEI	T1,CMDBUF	;CMDPTR AT FIRST CHARACTER?
	CAMN	T1,CMDPTR
	JRST	GETCMD		;YES, TRY AGAIN
	TRZN	F,QOUTP		;ARROW EVER SEEN?
	JRST	SWCHK		;NO, CHECK FOR DEFAULT SWITCHES
	TRNN	F,QSCHR		;PROCESS DEFAULT SWITCHES
	JRST	SWCH1		;IF NO FILE NAME, DEV FOUND
	MOVE	T1,[XWD FILNAM,IFIL]	;XFER INPUT SPECS
	BLT	T1,IDEV
	SKIPN	T1,IFIL		;INPUT FILE SPECIFIED?
	JRST	INFLER		;NO, ERROR
	SKIPE	OFIL		;OUTPUT FILE SPECIFIED?
	JRST	EOL1		;YES, CONTINUE
	MOVEM	T1,OFIL		;NO OUTPUT FILE, USE INPUT FILE NAME
	MOVE	T1,IEXT
	MOVEM	T1,OEXT
EOL1:	SKIPE	T1,PACK		;USER SET PACK/UNPACK SWITCH?
	POPJ	P,0		;NO, PROCESS USER
	MOVE	T1,IDASCI	;SET DEFAULT SWITCHES
	SKIPN	IASCII		;UNLESS ALREADY SET
	MOVEM	T1,IASCII
	SKIPE	OMODE		;IF BINARY MODE SET, RETURN
	POPJ	P,0
	SKIPE	OASCII		;DITTO WITH ASCII MODE
	POPJ	P,0
	MOVE	T1,ODMODE	;SET OUTPUT DEFAULTS
	MOVEM	T1,OMODE
	MOVE	T1,ODASCI
	MOVEM	T1,OASCII
	POPJ	P,0		;RETURN TO DO PROCESSING

SWCHK:	TRNE	F,QSCHR		;ANYTHING BUT SWITCHES SEEN?
	JRST	SYNERR		;YES, ERROR
SWCH1:	MOVE	T1,OASCII	;SET SWITCHES FOR NEW DEFAULTS
	MOVEM	T1,ODASCI
	MOVE	T1,OMODE
	MOVEM	T1,ODMODE
	MOVE	T1,IASCII
	MOVEM	T1,IDASCI
	JRST	GETCMD		;GET ANOTHER LINE
;SWITCH PROCESSING ROUTINES

MCHSW:	MOVEI	T2,SWTABL	;POINT TO SWITCH TABLE
MCH1:	SKIPN	T3,(T2)		;ENTRY ZERO?
	POPJ	P,0		;YES, NO MATCH
	HLRZ	T4,T3		;MOVE LEFT HALF INTO SEPARATE AC
	CAIE	T1,(T4)		;CHARACTER MATCH?
	AOJA	T2,MCH1		;NO, INCREMENT POINTER AND TRY AGAIN
	AOS	(P)		;SKIP RETURN FROM POP
	PJRST	(T3)		;PROCESS SWITCH AND RETURN

SWTABL:	SWTAB	AEFINOPSUZ

ASWCH:	TRNN	F,QOUTP		;OUTPUT SIDE?
	JRST	A1SWCH		;YES
	SETOM	IASCII		;SET FOR INPUT
	POPJ	P,
A1SWCH:	SETOM	OASCII		;SET OUTPUT SIDE
	SETZM	OMODE		;CLEAR OUTPUT BINARY MODE
	POPJ	P,0

ESWCH:	MOVSI	T1,400000	;SET MODE TO EVEN PARITY
ESW1:	TRNE	F,QOUTP		;OUTPUT SIDE?
	POPJ	P,0		;NO, INPUT SIDE, IGNORE
	MOVEM	T1,OMODE
	SKIPG	OASCII		;ASCII MODE SET?
	SETZM	OASCII		;YES, CLEAR IT
	POPJ	P,0

FSWCH:	MOVEI	T1,1		;SET FILEX SWITCH
	TRNE	F,QOUTP		;OUTPUT SIDE?
	MOVEM	T1,IASCII	;INPUT SIDE
	TRNN	F,QOUTP
	MOVEM	T1,OASCII	;OUTPUT SIDE
	POPJ	P,0

ISWCH:	TRNN	F,QOUTP		;OUTPUT OR INPUT?
	JRST	I1SWCH		;OUTPUT SIDE
	SETZM	IASCII		;CLEAR INPUT SWITCH
	POPJ	P,0		;RETURN
I1SWCH:	SETZM	OASCII		;CLEAR OUTPUT ASCII SWITCH
	MOVEI	T1,177		;SET DEFAULT OUTPUT MODE
	SKIPN	OMODE		;UNLESS ALREADY SET
	MOVEM	T1,OMODE
	POPJ	P,0		;RETURN

NSWCH:	MOVEI	T1,377		;SET MODE TO IOR 8TH BIT
	JRST	ESW1

OSWCH:	MOVE	T1,[XWD 400000,200]	;SET MODE TO ODD PARITY
	JRST	ESW1

PSWCH:	SETOM	PACK		;SET PACKING
	SKIPN	OASCII		;ASCII SWITCH ALREADY SET?
	SETOM	OASCII		;NO, SET ASCII
	SETZM	IASCII		;CLEAR INPUT ASCII
	POPJ	P,0

SSWCH:	TRO	F,QSUP		;SET SUPPRESS FLAG
	POPJ	P,0

USWCH:	MOVEI	T1,1		;UNPACKING
	MOVEM	T1,PACK
	SKIPN	IASCII		;INPUT ASCII ALREADY SET?
	SETOM	IASCII		;NO, INPUT ASCII
	MOVEI	T1,177
	SKIPN	OMODE		;OUTPUT MODE ALREADY SET?
	MOVEM	T1,OMODE	;NO, SET IT
	SETZM	OASCII		;CLEAR OUTPUT ASCII
	POPJ	P,0

ZSWCH:	MOVEI	T1,177		;SET MODE TO CLEAR 8TH BIT
	JRST	ESW1
;GET TTY CHARACTER ROUTINE

GTTYCR:	SOSLE	TTYHDR+2	;CHARACTERS LEFT IN BUFFER?
	JRST	GTTY1
	INPUT	0,		;GET A BUFFER
	STATZ	0,740000	;ERRORS?
	JRST	TYINER
GTTY1:	ILDB	CHR,TTYHDR+1	;GET CHARACTER
	JUMPE	CHR,GTTYCR	;IGNORE NULLS
	POPJ	P,0		;RETURN
;ERROR MESSAGES PAGE

TYPMES:	HRLI	PTR,440700	;CREATE LEFT HALF OF BYTE POINTER
	ILDB	CHR,PTR		;GET CHARACTER
	CAIL	CHR,"0"		;0-9?
	CAILE	CHR,"3"
	JRST	.+2		;NO, OUTPUT CHARACTER
	JRST	@TYPTBL-"0"(CHR)	;JUMP TO APPROPRIATE ROUTINE
	OUTCHR	CHR
	JRST	TYPMES+1	;TO NEXT CHAR

TYPTBL:	RSCAN			;"0"  OUTPUT * AND START AGAIN
	REDEV			;"1"  CLEAN UP DEVICES
	REDEV1			;"2"  CLEAN UP OUTPUT DEVICE ONLY
	REDEV0	;"3"  CLEAR TTY ONLY

RSCAN:	OUTSTR	[ASCIZ /
/]
	JRST	MAINLP

REDEV:	RELEASE	2,
REDEV1:	RELEASE	1,
REDEV0:	RELEASE	0,
	OUTSTR	[ASCIZ /
/]
	JRST	PTREN


GTERR:	ERMSG	<INPUT FILE ERROR1>
PTERR:	ERMSG	<OUTPUT FILE ERROR1>
SWERR:	ERMSG	<NO SUCH SWITCH0>
DEVERR:	ERMSG	<BAD DEVICE SPECIFICATION0>
PPNERR:	ERMSG	<BAD PPN SPEC0>
SYNERR:	ERMSG	<SYNTAX ERROR0>
OPNIER:	ERMSG	<CANNOT OPEN INPUT DEVICE3>
OPNOER:	ERMSG	<CANNOT OPEN OUTPUT DEVICE2>
LKIERR:	ERMSG	<LOOKUP FAILURE ON FILE0>
ENTOER:	ERMSG	<ENTER ERROR ON FILE1>
TYINER:	ERMSG	<TTY INPUT ERROR3>
INFLER:	ERMSG	<NO INPUT FILE?0>
;RANDOM STORAGE VALUES

PDLST:	BLOCK	20
FXOWRD:	BLOCK	1
FXIWRD:	BLOCK	1
FXOPTR:	BLOCK	1
FXIPTR:	BLOCK	1
TTYHDR:	BLOCK	3
TTYBFR:	BLOCK	406
INHDR:	BLOCK	3
INBUFR:	BLOCK	406
OUTHDR:	BLOCK	3
OUTBFR:	BLOCK	406
CMDPTR:	BLOCK	1
CMDBUF:	BLOCK	^D74
STRWD:	BLOCK	1
ODASCI:	BLOCK	1
ODMODE:	BLOCK	1
IDASCI:	BLOCK	1

OFIL:	BLOCK	1
OEXT:	BLOCK	1
OPPN:	BLOCK	1
ODEV:	BLOCK	1
OASCII:	BLOCK	1
OMODE:	BLOCK	1
IFIL:	BLOCK	1
IEXT:	BLOCK	1
IPPN:	BLOCK	1
IDEV:	BLOCK	1
IASCII:	BLOCK	1
PACK:	BLOCK	1
FILNAM:	BLOCK	1
FILEXT:	BLOCK	1
FILPPN:	BLOCK	1
FILDEV:	BLOCK	1

	END	MIMPT
  