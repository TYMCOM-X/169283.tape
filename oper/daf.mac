	TITLE	DAF	DIRECT ACCESS FILE SUBROUTINES
	SUBTTL	V30/04	02-FEB-72	USER NAME PATCH	/DLH


;DGROW ROUTINE BY R. SCOTT MAR 1,1971
	ENTRY DGROW
	ENTRY	DOPEN,DOPENB,DREAD,DWRITE,DCLOSE,DDEL
	EXTERN	NAMPPN
;FOLLOWING IS DISPLACEMENT DEFINITION BLOCK FOR ALL DIRECT
;ACCESS I/O
;IN TRUTH, THESE ARE DISPLACEMENTS FROM AC 'A'
FILE=0	;SIXBIT FILENAME
EXT=FILE+1	;SIXBIT EXTENSION, ERROR FLAG
PDT=EXT+1	;PROTECTION,DAY,TIME
USER=PDT+1	;USER NUMBER UNDER WHICH FILE IS TO BE FOUND
FLGLRL=USER+1	;FLAGS,LOGICAL RECORD LENGTH
MXNREC=FLGLRL+1	;MAX # RECORDS (SPECIFIED AT INITIALIZATION TIME)
CBN=MXNREC+1	;CURRENT RELATIVE PHYSICAL BLOCK NUMBER
PPLRP=CBN+1	;PUT PHYSICAL/LOGICAL RECORD POINTER
BLKL=PPLRP+1	;LENGTH OF USEABLE DATA AREA
XOPEN=BLKL+1	;XCT OPEN UUO
XLOOK=XOPEN+1	;XCT LOOKUP UUO
XENTER=XLOOK+1	;XCT ENTER UUO
XINPUT=XENTER+1	;XCT INPUT UUO
XINA=XINPUT+1	;ADDRESS WORD FOR INPUT ABOVE
XINB=XINA+1	;CHAIN STOPPER WORD FOR INPUT ABOVE
XOTPUT=XINB+1	;XCT OUTPUT UUO
XOUTA=XOTPUT+1	;ADDRESS WORD FOR OUTPUT ABOVE
XOUTB=XOUTA+1	;CHAIN STOPPER WORD FOR OUTPUT ABOVE
XUSETI=XOUTB+1	;XCT USETI UUO
XUSETO=XUSETI+1	;XCT USETO UUO
XGTSTS=XUSETO+1	;XCT GETSTS UUO
XCLOSE=XGTSTS+1	;XCT CLOSE UUO
XOPNCB=XCLOSE+1	;OPEN CONTROL BLOCK FOR XOPEN ABOVE
BUFL=XOPNCB+3	;BUFFER LENGTH WORD FOR MONITOR
BUFFER=BUFL+1	;DATA BUFFER
BLKEND=BUFFER+200	;LENGTH OF DATA SET SOFTWARE CONTROL BLOCK
;DATA SET REFERENCE NUMBER TABLE
;LH:
;BIT 0	0=UNOPENED
;	1=SUCCESSFULLY OPENED
;    1	0=NO WRITE IS PENDING
;	1=WRITE IS PENDING
;    2	0=CURRENT RECORD IS DEFINED
;	1=CURRENT RECORD IS UNDEFINED
DSRNTB:	REPEAT	20,<0>	;GENERATE ADDRESS TABLE OF
;DATA SET CONTROL BLOCKS

CHANTB:	REPEAT	20,<0>	;CHANNEL ALLOCATION TABLE



JOBFF=121	;NATURALLY
JOBREL=44	;DITTO

SAVE:	BLOCK	20	;AC SAVE AREA
STACK:	BLOCK	20	;PUSH/POP STACK

;ACCUMULUMULATOR EQUATES
Z=0	;GENERAL WORK, AND ONE WORD PASS REGISTER
A=1	;CONTAINS ADDRESS OF ACTUAL DATA SET CONTROL BLOCK
B=2	;CONTAINS DSRN (IS INDEX TO DSRNTB TO GET 'A')
C=3	;NO COMMENT
D=4
E=5
F=6
G=7
H=10
I=11	;HOLDS MODE DURING OPEN
J=12
K=13
L=14
M=15	;WILL CONTAIN NEXT RECORD NUMBER FOR USETI/USETO
P=16	;POINTS TO PARAMETER LIST FROM CALLER
S=17	;POINTS TO PUSH/POP STACK
T=8	;DELETE INDICATOR


	DEFINE	ERROR(N)
<	MOVEI	Z,^D'N
	JRST	ERSET>


	DEFINE	IMPER(N)
<	HRROI	Z,-^D'N
	JRST	ERSET>



PATCH:	REPEAT	10,<0>	;PATCH AREA
MODEL:	OPEN	0,XOPNCB(A)	;I AM THE MODEL BLT ED INTO
				;THE SOFTWARE DATA SET CONTROL BLOCK
	LOOKUP	0,FILE(A)
	ENTER	0,FILE(A)
	INPUT	0,XINA(A)
	0
	0
	OUTPUT	0,XOUTA(A)
	0
	0
	USETI	0,0(M)	;NEXT RECORD NUMBER IS IN 'M'
	USETO	0,0(M)	;DITTO
	GETSTS	0,F	;PLUNK STATUS INTO F
	CLOSE	0,
;END OF MODEL

;*************USER PATCH****02-FEB-72****V30/04************************
DPBFLG:	BLOCK	1
NAME:	BLOCK	3
JMPCON:	JUMP	5,0
IPPN:	BLOCK	1
IER:	BLOCK	1
;**********END OF USER PATCH********************************
XENTCB:	0,4		;***CONTROL BLOCK FOR EXTENDED ENTER
	0		;***USER NUMBER
	0		;***FILE NAME
	0		;***FILE EXT
	0		;***PROT,TIME,DATE
XEENTR:	ENTER	0,XENTCB	;***XCT INSTR FOR EXTENDED ENTER
SAVBUF:	0
	0
	0
	0

BPMODE:	POINT	2,FLGLRL(A),1	;MODE BYTE POINTER
BPCHAN:	POINT	4,FLGLRL(A),5	;CHANNEL
BPLRC1:	POINT	10,L,14	;POINTER FOR LRECL
BPLRC2:	POINT	10,-1(C),14	;DITTO
BPNRC1:	POINT	21,-1(C),35	;POINTER FOR RECORD NUMBER



;LOGICAL RECORD CONTROL WORD
;
;BIT 0	0=RECORD IS UNDEFINED
;	1=RECORD HAS BEEN WRITTEN
;  1-4	UNUSED
; 5-14	LRECL
;15-35	# WORDS / LOGICAL RECORD


;MODE SETTINGS ALLOWED:
;	00	INITIALIZATION
;	01	READ ONLY
;	10	WRITE ONLY	HIDDEN READ IS IMPLICIT
;	11	READ AND WRITE (UPDATE)


;CALL DGROW(DSRN,ERR,NEWSIZ,IARRAY)
;WHERE THE FILE IS OPEN,MODE 3, AND NEWSIZ IS THE NO. OF RECORDS
;IT IS DESIRED THAT THE FILE GROW TO.



GFLAG:	0

DGROW:	0
	MOVEM 17,SAVE+17
	MOVEI 17,SAVE
	BLT 17,SAVE+16
	MOVEI 17,STACK
	SETZ T,
	PUSHJ S,DSRNTS
	LDB I,BPMODE
	TRNN I,2
	JRST ERWRT
	TLNE A,200000
	PUSHJ S,WRITE
	SETZM CBN(A)
	MOVE H,@2(P)
	EXCH H,MXNREC(A)
	MOVEM H,@2(P)
	SETOM GFLAG
	PUSHJ S,NINITL
	MOVE H,MXNREC(A)
	MOVEM H,@2(P)
	MOVEI Z,1
	JRST RETURN-1



	
AGAIN:	MOVEI T,1	;DELETE SWITCH
	AOS H,@2(P)	;OLD MAX REC+1 IS NOW TREATED AS ASSOC VAR
			;FOR DELETE SEQUENCE
	PUSHJ S,DRED1	;GET THE DESIRED RECORD IN CORE
	PUSHJ S,DWRT5	;AND SET THE DELETE CODE IN AND WRITE IT
	TLZ A,100000
	MOVEM A,DSRNTB(B)
	CAMGE H,MXNREC(A)	;AND KEEP THIS UP UNTIL THE LAST
			;RECORD HAS HAD ITS DELETE CODE SET
	JRST AGAIN	;SET ANOTHER
	JRST DDEL1	;ALL DONE,EXIT

;*********USER PATCH****02-FEB-72****V30/04***************************
TWOWRD:	PUSH	S,P
	MOVE	C,4(16)		;GET ADDRESS OF USER NAME
	MOVE	Z,(C)		;PICK UP FIRST WORD OF NAME
	MOVEM	Z,NAME
	MOVE	Z,1(C)		;PICK UP SECOND WORD OF NAME
	MOVEM	Z,NAME+1
	SETZM	NAME+2
	HLL	Z,JMPCON	;SET UP LEFT HALF OF ARG
	HRRI	Z,NAME		;SET UP RIGHT HALF
	MOVEM	Z,PPNCAL+1
	JRST	PPNCAL		;RETURN

;CALL DOPENB (DSRN,ERR,ASSOC,'FILE.EXT',USER,MODE,NREC,RLEN)
DOPENB:	0	;FORTRAN NONREENTRANCY WORD
	SETOM	DPBFLG		;FLAG FOR 1-12 CHAR USER NAME
	JRST	DOPEN+1
DOPEN:	0
	SETZM	DPBFLG		;6-10 CHAR NAME (COMPATIBLE WITH OLD FORMAT
;**********END OF USER PATCH***************************************
	MOVEM	17,SAVE+17
	MOVEI	17,SAVE
	BLT	17,SAVE+16
	MOVEI	S,STACK
	MOVE	B,@0(P)	;PICK UP DSRN
	CAILE	B,0	;INSURE IT IS IN THE PROPER RANGE
	CAILE	B,17
	JRST	ERDSRN	;DSRN IS NOGOOD
	SKIPE	A,DSRNTB(B)	;ADDRESS OF CB
	JRST	DOPEN1	;ALREADY EXISTS
	MOVE	Z,JOBFF
	MOVEI	A,BLKEND	;GET A END OF REQUIRED CORE
	ADDB	A,Z	;TOGETHERNESS
	CAMG	A,JOBREL	;STILL WITHIN MY AREA
	JRST	.+4
	TRO	Z,1777	;ROUND UP TO NEXT 1K
	CALLI	Z,11	;CORE UUO
	JRST	ERCORE	;NONE TO BE HAD
	EXCH	A,JOBFF	;GOT IT, SET ADDRESS IN JOBFF
	MOVEM	A,DSRNTB(B)	;AND DATA SET REFERENCE TABLE
DOPEN1:	TLNE	A,400000	;SEE IF ALREADY OPEN
	JRST	EROPEN	;JRST IF YEP
	SETZM	,FILE(A)	;PREPARE TO CLEAR BLOCK
	HRLI	C,FILE(A)
	HRRI	C,FILE+1(A)
	MOVEI	D,BLKEND(A)
	BLT	C,@D	;ZAP
	HRRZ	C,3(P)	;SIXBITIZE FILE NAME
	SUBI	C,1	;SUB 1 FROM C TO ENABLE ILDB
	MOVE	D,[POINT 7,0(C),35]	;ASCII FILE NAME POINTER
	MOVE	E,[POINT 6,FILE(A),35]	;SIXBIT F N
	SUBI	A,1	;BACK UP A TO ENABLE ILDB BEOLW TO WORK
DOPEN4:	ILDB	Z,D	;GET AN ASCII CHARACTER
	TRZ	Z,40	;COMMENCE TO SIXBITIZE IT
	CAIL	Z,100
	SUBI	Z,40
	JUMPE	Z,DOPEN2	;JUMP TO FILE.EXT DONE
	CAIN	Z,16	;IS IT SIXBIT '.'
	JRST	DOPEN3	;JUMP TO FILE DONE, DO EXT YET
	IDPB	Z,E	;SAVE SIXBIT CHARACTER
	TLNE	E,770000	;HAVE SIX YET?
	JRST	DOPEN4	;LOOP BACK FOR NEXT CHARACTER
	ILDB	Z,D	;ALREADY HAVE SIX,PASS TILL . OR NULL
			;OR BLANK
	JUMPE	Z,DOPEN2	;JUMP TO FILE.EXT DONE
	CAIN	Z,40	;SKI@ IF NOT BLANK
	JRST	DOPEN2	;JUMP TO FILE.EXT DONE
	CAIE	Z,56	;IS IT ASCII "."
	JRST	.-5	;LOOP BACK TO PASS MORE
DOPEN3:	MOVE	E,[POINT 6,EXT(A),35]	;EXT BYTE POINTER
;NOTE: AC 'A' IS 1 LESS TO MAKE ILDB TO WORK
	ILDB	Z,D	;GET NEXT ASCII CHARACTER
	TRZ	Z,40
	CAIL	Z,100	;SIXBITIZING IT AGAIN
	SUBI	Z,40
	JUMPE	Z,DOPEN2	;ALL DONE
	IDPB	Z,E	;PUT IT INTO EXT SLOT
	JRST	DOPEN3+1
DOPEN2:	ADDI	A,1	;GET A BACK TO REAL ADDRESS
	HRRM	Z,EXT(A)	;INSURE SECOND HALF WORD IS ZERO
	MOVE	Z,@4(P)	;MOVE USER NUMBER INTO PLACE
	JUMPE	Z,DOPE2A	;*****PATCH FOR ASCII USER NUMBERS - 17-JAN-72
	SKIPN	DPBFLG		;WHICH FORM OF USER NAME?
	JRST	TWOWRD		;6-10 CHAR
	PUSH	S,P		;SAVE AC
	MOVE	C,4(P)
	MOVEM	C,PPNCAL+1	;PICK UP USER NAME ARG
PPNCAL:	JSA	P,NAMPPN	;COVERT NAME TO PPN
	0
	JUMP	4,IPPN
	JUMP	0,IER
	POP	S,P		;RESTORE AC
	MOVE	C,IER		;PICK UP ERROR INDICATOR
	JUMPE	C,DOPE2B	;SUCCESSFIL?
	CAIN	C,1		;NO
	JRST	NOCHAN
	JRST	NOPEN
DOPE2B:	MOVE	Z,IPPN
	JRST	.+3	;***** END OF PATCH***
DOPE2A:	CALLI	Z,24	;GET MY USER NUMBER
	JRST	.+1	;IN CASE IT DONT WORK
	MOVEM	Z,USER(A)
	MOVE	I,@5(P)	;MODE
	CAIL	I,0
	CAILE	I,3
	JRST	ERMODE	;MODE WAS NOT 0,1,2,3
	DPB	I,BPMODE	;STICK IT IN
	DPB	B,BPCHAN	;SAVE DSRN IN FLAG WORD
	JUMPN	I,.+10	;JUMP AROUND IF NOT INITIALIZATION PHASE
	MOVE	Z,@6(P)	;GET AND SAVE NREC
	MOVEM	Z,MXNREC(A)
	MOVE	Z,@7(P)	;AND LOGICAL RECORD LENGTH
	CAIL	Z,1	;TEST TO INSURE LRECL IS IN ACCEPTABLE RANGE
	CAILE	Z,^D1023
	JRST	ERLRCL	;NO IT ISNT
	HRRM	Z,FLGLRL(A)
;NOW LETS MOVE MODEL INTO POSITION
	HRLI	C,MODEL	;BUILD A BLT WORD
	HRRI	C,XOPEN(A)
	HRRZI	D,XCLOSE(A)	;ENDING ADDRESS
	BLT	C,@D	;ZAP MODEL INTO PLACE
	MOVEI	D,17	;COMPUTE NEXT FREE CHANNEL NUMBER
	SKIPE	C,CHANTB(D)	;PICK UP AND TEST CHANNEL ALLOC TABLE
	SOJG	D,.-1	;LOOP BACK IF NOT FREE
	JUMPE	D,NOCHAN	;NO CHANNEL IS AVAILABLE
	MOVE	Z,D
	MOVEM	B,CHANTB(D)	;MARK IT IN USE
	MOVE	C,[POINT 4,0(D),12]	;POINTER FOR CAHNNEL #
	HRRI	C,XOPEN(A)	;SET UP ALL THE CHANNEL NUMBERS
	MOVEI	D,XCLOSE-XOPEN	;NUMBER TO BE MOVED
	DPB	Z,C	;PUT CHANNEL NUMBER IN
	SOJGE	D,.-1	;LOOP TILL DONE
	DPB	Z,[POINT 4,XEENTR,12]	;***INSERT CHAN IN EXT. ENTER
	DPB	Z,BPCHAN	;POINT SOFT DSCB TO RIGHT CHANNEL
	SETZM	,XOUTB(A)	;CLEAR THE CHAIN STOPPER WORDS
	SETZM	,XINB(A)
	HRRZI	Z,200	;CONSTRUCT BUFFER LENGTH WORD
	MOVEM	Z,BUFL(A)
	MOVEM	Z,BLKL(A)	;SET UP BLOCK LENGTH
	HRLI	Z,-200	;BUILD FIRST IN AND OUT WORDS
	HRRI	Z,BUFFER-1(A)
	MOVEM	Z,XINA(A)
	MOVEM	Z,XOUTA(A)
	MOVEI	Z,17	;DUMP MODE
	MOVEM	Z,XOPNCB(A)	;INTO OPEN CONTROL BLOCK
	MOVSI	Z,(SIXBIT /DSK/)	;DEVICE IN
	MOVEM	Z,XOPNCB+1(A)
	HRLI	Z,FILE(A)
	HRRI	Z,SAVBUF
	BLT	Z,SAVBUF+3
	XCT	XOPEN(A)	;DO THE OPEN
	JRST	NOPEN	;IT DIDNT
	XCT	XLOOK(A)	;DO THE LOOKUP
	JRST	NLOOK1	;IT DIDNT
	JUMPE	I,ERINIT	;ATTEMPT TO INIT AN EXISTING FILE
	CAIN	I,1	;SKIP IF OUT OR IN/OUT
	JRST	RTG	;***IN, GO READ DSCB TO BUILD MXNREC,FLGLRL
ENTR1:	MOVE	Z,SAVBUF	;***GET FILE NAME
	MOVEM	Z,XENTCB+2	;***SAVE FOR EXTENDED ENTER
	MOVE	Z,SAVBUF+1	;***GET FILE EXT
	MOVEM	Z,XENTCB+3	;***
	MOVE	Z,SAVBUF+3	;***GET USER NUMBER
	MOVEM	Z,XENTCB+1	;***
	MOVE	Z,PDT(A)	;***GET PROTECTION
	CALLI	D,14		;***GET CURRENT DATE
	HRRM	D,Z		;***
	CALLI	D,22		;***GET CURRENT TIME
	IDIVI	D,^D3600	;***GET TIME IN MIN
	DPB	D,[POINT 11,Z,23]	;***MISH PROT,TIME,DATE
	MOVEM	Z,XENTCB+4	;***
	XCT	XEENTR		;***EXECUTE ENTER
	JRST	ERNAFL	;IT DIDNT WORK
RTG:	TLO	A,400000	;MARK IT OPEN
	MOVEM	A,DSRNTB(B)
	SKIPN	,I	;SKIP IF NOT INITIALIZATION PHASE
	PUSHJ	S,NINITL
NRDSCB:	PUSHJ	S,RDSCB	;READ DSCB AND BUILD MXNREC AND LRECL
	MOVEI	Z,1	;MARK SUCCESSFUL OPEN
	MOVEM	Z,@2(P)	;ASSOC VARIABLE
	MOVEM	Z,@1(P)	;ERROR CODE (NO ERROR)
RETURN:	MOVSI	17,SAVE
	BLT	17,17
	JRA	16,2(16)	;SHORTEST PARAM LIST HAS 2 ENTRIES
NLOOK1:	JUMPE	I,ENTR1	;IS A LEGITIMATE INITIALIZATION
	JRST	ERNOFL	;LOOKUP FAIL ON INPUT FILE



NINITL:	SKIPE	M,CBN(A)	;GET CBN AND HOPE ITS ZERO
	JRST	ERINIT	;NONZERO, ATTEMPT TO INIT OLD DATASET
	AOS	,CBN(A)	;MAKE IT A 1
	MOVE	K,MXNREC(A)	;GET # LOGICAL RECORDS
	HRRZ	Z,FLGLRL(A)	;CLEAR CARRY BITS AND PICK UP LRECL
	SETZ	L,
	DPB	Z,BPLRC1	;PUT LRECL IN
	TLO	L,400000	;INDICATE UNDEFINED RECORD
	MOVEI	J,1	;INIT LOGICAL RECORD NUMBER
	HRRZI	C,BUFFER(A)	;BUFFER POINTER
	HRRZI	D,BLKEND-1(A)	;END OF BUFFER POINTER
	MOVE	Z,[40000000002]	;2 WORDS OF DAF INFO
	MOVEM	Z,0(C)	;CREATE FIRST DATA RECORD
	MOVEM	K,1(C)	;MXNREC IN
	HRRZ	Z,FLGLRL(A)	;INIT LRECL WORD
	HRRZM	Z,2(C)	;LRECL IN
	ADDI	C,3	;UP POINTER PAST PRIMING WORDS
	SETZM	,0(C)	;CLEAR OUT NEXT WORD
	CAMGE	C,D	;CHECK FOR END OF BUFFER
	AOJA	C,.-2	;LOOP BACK IF NOT
INIT8:	HRRZ	G,FLGLRL(A)	;ESTABLISH LRECL WORD COUNTER
	DPB	G,BPLRC1	;PUT IT INTO LRECL AREA
	SKIPGE GFLAG
	JRST GRINIT
INIT5:	PUSHJ	S,WRITER	;OUTPUT THE RECORD
INIT9:	AOS	,CBN(A)	;UP RECORD POINTER
	MOVEI	C,BUFFER(A)	;RESET BUFFER ADDRESS
INIT1:	MOVEM	L,0(C)	;PUT THE CONTROL WORD IN
	IORM	J,0(C)	;AND THE RECORD NUMBER
	ADDI	C,1	;UP DATA POINTER
	CAMLE	C,D	;TEST FOR END OF BUFFER
	JRST	INIT4	;HAVE REACHED END
INIT3:	SETZM	,0(C)	;CLEAR NEXT WORD
	CAML	C,D	;TEST POSITION IN BUFFER AGAIN
	JRST	INIT6	;OUT OF ROOM
	ADDI	C,1	;STILL ROOM, UP POINTER
	SOJG	G,.-4	;MORE LRECL WORDS, YES=JUMP
	HRRZ	G,FLGLRL(A)	;SET LRECL AGAIN
	DPB	G,BPLRC1
	ADDI	J,1	;UP LRECL NUMBER
	SOJG	K,INIT1	;JUMP IF STILL MORE LRECLS TO DO
	SETOM	,0(C)	;CLEAR OUT THE REST OF THE BUFFER
	CAMGE	C,D	;SPIN TILL BUFFER HAS BEEN CLEARED
	AOJA	C,.-2
	PUSHJ	S,WRITER	;GO WRITE OUT THE RECORD
	PUSHJ	S,CLOSE	;DO A CLOSE
	PUSHJ	S,WIPOUT
	XCT	XOPEN(A)	;OPEN IT AGAIN
	JRST	IMP3	;THIS CANNOT HAPPEN
	XCT	XLOOK(A)	;DO THE LOOKUP
	JRST	IMP3	;IMPOSSIBLE
	PUSHJ	S,WIPOUT
	XCT	XENTER(A)	;DO THE ENTER
	JRST	IMP3
	MOVEI	Z,2	;SET MODE TO WRITE ONLY
	AOSE GFLAG
	DPB	Z,BPMODE
	POPJ	S,0	;GO BACK TO CALLER


INIT6:	SOJG	G,INIT4
	HRRZ	G,FLGLRL(A)	;RESET LRECL
	DPB	G,BPLRC1
	ADDI	J,1	;UP RECORD NUMBER
	JRST	INIT5	;CONTINUE
INIT4:	PUSHJ	S,WRITER	;WRITE IT OUT
	MOVEI	C,BUFFER(A)	;POINT IT AGAIN
	AOS	,CBN(A)	;UP RECORD BLOCK NUMBER
	JRST	INIT3
WIPOUT:	HRLI	Z,SAVBUF	;CLEAR WORDS FOR LOOKUP AND ENTER
	HRRI	Z,FILE(A)
	BLT	Z,USER(A)
	POPJ	S,


GRINIT:	MOVE K,MXNREC(A)
	SUB K,H
	MOVEI J,1(H)
	PUSHJ S,WRITE
	AOS @2(P)
	PUSHJ S,PRCMPT
	MOVEM M,CBN(A)
	CAIE D,0
	PUSHJ S,READ
	MOVEI C,BUFFER(A)
	ADD C,D
	MOVEI D,BLKEND-1(A)
	JRST INIT1



CLWRT:
WRITE:
WRITER:	SKIPN	M,CBN(A)	;BETTER SKIP
	JRST	ZERCBN
	XCT	XUSETO(A)	;SET AN OUTPUT RECORD NUMBER
	XCT	XOTPUT(A)	;OUTPUT A RECORD
	XCT	XGTSTS(A)	;GET RESULTANT STATUS
	TRNE	F,760000	;SKIP IF CLEAN
	JRST	EROUT
	MOVEI	C,BUFFER(A)	;PREPARE TO RESET BUFFER POINTER
	TLZ	A,200000	;CLEAR WRITE PENDING BIT
	POPJ	S,


DSRNTS:	MOVE	B,@0(P)	;PICK UP DSRN
	CAILE	B,0	;TEST FOR OK
	CAILE	B,17
	JRST	ERDSRN	;JRST	FI NO GOOD
	MOVE	A,DSRNTB(B)	;GET CONTROL BLOCK ADDRESS
	JUMPE	A,ERNODS
	TLNN	A,400000	;SEE IF IT WAS SUCESSFULLY OPENED
	JRST	ERNODS
	POPJ	S,	;GO BACK


PRCMPT:	SKIPN	C,@2(P)	;GET AND TEST ASSOC VARIABLE
	JRST	ERASOC	;BETTER NOT COME HERE
	CAMLE	C,MXNREC(A)	;SEE IF SMALL ENUF
	JRST	ERASOC	;NOPE
	SUBI	C,1
	HRRZ	E,FLGLRL(A)
	ADDI	E,1
	IMUL	C,E
	IDIV	C,BLKL(A)	;DIVIDE BY PHYSICAL SIZE
	MOVEI	M,2(C)	;AND ADD 2 FOR CONTROL INFO
;M CONTAINS BLOCK NUMBER FOR NEXT BLOCK
;D CONTAINS DISPLACEMENT INTO THE BLOCK FOR THE CONTROL WORD
	POPJ	S,0	;RETURN


; CBN=((ASSOC-1)*(RLEN+1)/BLKSIZ)+2

;CALL DREAD (DSRN,ERR,ASSOC,ARRAY)
DREAD:	0	;FORTRANS NONREENTRANT WORD
	MOVEM	17,SAVE+17
	MOVEI	17,SAVE
	BLT	17,SAVE+16
	MOVEI	S,STACK
	SETZ 	T,
	PUSHJ	S,DSRNTS	;GO DO DSRN TESTS
	LDB	I,BPMODE	;INSURE READ IS ALLOWED
	TRNN	I,1	;READ BIT
	JRST	ERRED	;NOPE, TAINT
DRED1:	PUSHJ	S,PRCMPT	;DSRN OK, GO TO COMPUTE RELATIVE BLOCK NUMMER
	HRRZ	K,FLGLRL(A)	;SET LRECL
	HRRZ	L,3(P)	;ARRAY ADDRESS
	CAMN	M,CBN(A)	;ARE WE ALREADY THERE?
	JRST	RDRD1+1	;DONT DO THE READ
RDRD2:	TLNN	A,200000	;TEST WRITE PENDING BIT
	JRST	RDRD1	;NO, NO WRITE IS NECESSARY
	PUSH	S,M	;SAVE THE LREC NUMBER
	PUSHJ	S,WRITE	;WRITE OUT THE CURRENT RECORD
	POP	S,M	;RETRIEVE THE NEXT RECORD NUMBER
RDRD1:	PUSHJ	S,READ	;DO THE READ
	MOVEI	C,BUFFER(A)	;SET UP POINTERS
	ADDI	C,1(D)	;TO ACTUAL DATA
RDHAVR:	MOVE	Z,-1(C)	;THIS IS THE RITE RECORD
	TRNE	T,000001  ; DELETING AT THIS POINT
	TLO	A,100000  ; MAKE UNDEFINED
	TLNE	Z,400000	;SEE IF RECORD WAS DEFINED
	TLO	A,100000	;TURN ON THE RECORD UNDEFINED BIT
	MOVEI	J,BLKEND(A)	;STOPPER
RDHAV2:	CAML	C,J	;SEE IF STILL WITHIN BUFFER
	JRST	RDSPAN
	MOVE	Z,0(C)	;PICK UP A DATA WORD
	MOVEM	Z,0(L)	;AND PUT IT INTO THE USERS ARRAY!
	ADDI	C,1	;UP THE TWO POINTERS
	ADDI	L,1
	SOJG	K,.-6	;LOOP AROUND TILL DONE
RDHAV1:	TRNE	T,000001 ;  DELETING NOW
	POPJ	S,0	 ; RETURN
	AOS	@2(P)	;UP L REC N
	MOVEI	Z,1
	MOVEM	Z,@1(P)	;ERROR CODE = NO ERROR
	TLZE	A,100000	;TEST THE RECORD UNDEFINED BIT
	JRST	ERRDUN	;JRST IF ON(RECORD WAS UNDEFINED, BUT MOVED
	JRST	RETURN

RDSPAN:	JUMPE	K,RDHAV1	;JUMP IF REALLY DONE
	SETZ	D,	;CLEAR DISPLACEMENT
	TLNN	A,200000	;IS A WRITE PENDING?
	JRST	.+4	;NOPE
	PUSH	S,M	;SAVE BLOCK NUMBER
	PUSHJ	S,WRITER	;WRITE OUT THE CURRENT RECORD
	POP	S,M	;RESTORE BLOCK NUMBER
	ADDI	M,1	;UP BLOCK NUMBER
	PUSHJ	S,READ	;GO READ THE NEXT RECORD
	MOVEI	C,BUFFER(A)	;POINT IT AGAIN
	JRST	RDHAV2+2	;CONTINUE

READ:	XCT	XUSETI(A)	;USETI SET FOR NEXT LOGICAL PHYSICAL RECORD
	JRST	.+1	;IN CASE OF ERROR
	XCT	XINPUT(A)	;INPUT A RECORD
	XCT	XGTSTS(A)	;PULL THE STATUS OF THE READ
	TRNE	F,740000	;SKIP IF CLEAN
	JRST	ERINP	;NG
	TRNE	F,20000	;EOF TEST
	JRST	INEOF	;EOF IS TRUE
	MOVEM	M,CBN(A)	;PUT NEW CURRENT BLOCK NUMBER IN
	POPJ	S,0	;YES, JUST RETURN


RDSCB:	MOVEI	M,1	;SET UP TO READ THE FILE DESCRIPTOR
	PUSHJ	S,READ
	MOVE	Z,BUFFER+1(A)	;PICK UP NREC
	MOVEM	Z,MXNREC(A)	;SAVE IT AWAY
	MOVEM	Z,@6(P)	;PUT MXNREC IN FOR CALLER
	HRRZ	Z,BUFFER+2(A)	;LRECL ALSO
	HRRM	Z,FLGLRL(A)
	MOVEM	Z,@7(P)	;PUT LRECL IN FOR CALLER
	POPJ	S,0	;GO BACK

;CALL DWRITE (DSRN,ERR,ASSOC,IARAY)
DWRITE:	0	;FORTRANS NONREENTRABILITY WORD
	MOVEM	17,SAVE+17
	MOVEI	17,SAVE
	BLT	17,SAVE+16
	MOVEI	17,STACK
	SETZ	T,
	PUSHJ	S,DSRNTS	;TEST DSRN
	LDB	I,BPMODE	;INSURE WRITE IS ALLOWED
	TRNN	I,2	;WRITE BIT
	JRST	ERWRT	;NOPE,TAINT
DWRT5:	PUSHJ	S,PRCMPT
;NOW HAVE COMPUTED ACTUAL RELATIVE BLOCK ADDRESS
	CAMN	M,CBN(A)	;ARE WE ALREADY THERE
	JRST	DWRT4	;YES, SCAN RECORD
	MOVE	F,CBN(A)	;TEST CBN FOR DSCB RECORD
	CAIN	F,1	;DONT REWRITE FIRST RECORD
	JRST	.+4
	PUSH	S,M	;NO, SAVE NEXT RECORD NUMBER
	PUSHJ	S,WRITE	;WRITE OUT THE CURRENT RECORD
	POP	S,M	;GET NEXT RECORD NUMBER BACK
	PUSHJ	S,DWRT2	;GET NEW LOGICAL RECORD
DWRT4:	MOVEI	C,BUFFER(A)
	ADDI	C,1(D)	;POINT IT TO DATA
	HRRZ	E,FLGLRL(A)
	HRRZ	L,3(P)	;NOW HAVE LENGTH AND ADDRESS
	MOVEI	J,BLKEND(A)
	MOVSI	Z,400000	;CLEAR UNWRITTEN BIT
	ANDCAM	Z,-1(C)
	TLO	A,200000	;MARK WRITE PENDING
	TRNN	T,000001	; TEST DELETE
	JRST	DWRT1	;GO REGULAR ROUTE
	MOVSI	Z,400000
	IORM	Z,-1(C)	;OR IT OFF
	POPJ	S,0	;GET OUT
DWRT1:	CAML	C,J	;SEE IF STILL WITHIN BUFFER
	PUSHJ	S,DWRT3
	MOVE	Z,0(L)	;GET NEXT WORD
	MOVEM	Z,0(C)	;PUTIT INTO NEXT POSITION
	ADDI	L,1	;UPDATE THE POINTERS
	ADDI	C,1
	SOJG	E,DWRT1	;LOOP BACK FOR MORE
	MOVEM	A,DSRNTB(B)	;PUT IOSTATUS BACK
	MOVEI	Z,1	;SET ERROR CODE
	MOVEM	Z,@1(P)
	AOS	,@2(P)	;UP ASSOC VARIABLE
	JRST	RETURN

DWRT3:	CAIN	E,0	;SEE IF THE LOGICAL RECORD IS REALLY FINISHED
	POPJ	S,0	;YES IT IS
	MOVEM	M,CBN(A)	;PUT RECORD NUMBER IN
	PUSHJ	S,WRITE	;DO A WRITE AND A READ FOR NEXT BLOCK
	SETO	D,
	AOS	,M	;UP CBN TO BE FETCHED
DWRT2:
	PUSHJ	S,READ	;DO THE READ
	TLO	A,200000	;MARK A WRITE IS PENDING
	MOVEI	C,BUFFER(A)
	ADDI	C,1(D)	;TO DATA
	POPJ	S,0	;RETURN
;CALL DC(DSRN,ERR)
DCLOSE:	0	;FORTRANS NONREENTRANT WORD
	MOVEM	17,SAVE+17
	MOVEI	17,SAVE
	BLT	17,SAVE+16
	MOVEI	S,STACK
	MOVE	B,@0(P)	;GET DSRN
	CAILE	B,0
	CAILE	B,17	;GET RANGE AND TEST IT
	JRST	ERDSRN	;NO GOOD
	MOVE	A,DSRNTB(B)	;GET ADDRESS OF DATASET CB
	JUMPE	A,ERNODS	;TAINT ONE
	TLNN	A,400000	;SEE IF IT WAS OPENED SUCCESSFULLY
	JRST	ERNODS	;NO
	TLZE	A,200000	;SEE IF RECORD IS TO BE WRITTEN
	PUSHJ	S,CLWRT	;HERE IF YES
	PUSHJ	S,CLOSE	;DO THE CLOSE
	MOVEI	Z,1		;SET ERROR=1 (NO ERROR)
	MOVEM	Z,@1(P)
	PUSHJ	S,CLEAR
	JRST	RETURN
CLEAR:	LDB	D,BPCHAN	;CLEAR CHANNEL IN USE FLAGE
	SETZM	,CHANTB(D)
	HRRZ	Z,A	;SEE IF BLOCK ENDS AT JOBFF
	ADDI	Z,BLKEND
	CAME	Z,JOBFF
	JRST	.+4	;JUMP IF NOT
	HRRM	A,JOBFF	;MAKE NEW JOBFF
	SETZM	,DSRNTB(B)	;MARK IT NONEXISTANT
	JRST	.+3
	MOVEI	Z,777777	;GET A MASK
	ANDM	Z,DSRNTB(B)	;MARK IT EXISTANT BUT VACANT
	POPJ	S,
CLOSE:	XCT	XCLOSE(A)	;DO THE CLOSE
	XCT	XGTSTS(A)	;PULL THE STATUS
	TRNE	F,740000	;SKIP IF CLEAN
	JRST	ERCLS	;CLOSE ERROR HAS OCCURRED
	POPJ	S,	;GET BACK
;ERROR EXIT ROUTINE ARE HERE
ERSET:	MOVEM	Z,@1(P)	;PUT ERROR CODE INTO ERROR WORD
	JRST	RETURN

ERDSRN:	ERROR	2	;DSRN OUTSIDE OF ALLOWED RANGE
ERCORE:	ERROR	3	;CORE NOT AVAILABLE
ERMODE:	ERROR	4	;MODE NOT COMPATIBLE WITH EXISTING FILES
ERNAFL:	MOVEI	Z,^D5	;FILE NOT ACCESSIBLE
	JRST	DOPERR
ERNOFL:	MOVEI	Z,^D6	;NO SUCH FILE EXISTS
	JRST	DOPERR
EROUT:	ERROR	7	;DEVICE OUTPUT ERROR
ERINP:	ERROR	8	;DEVICE INPUT ERROR
ERNODS:	ERROR	9	;I/O TO CLOSED DATA SET
INEOF:	ERROR	10	;READ EOF
NOPEN:	MOVEI	Z,^D11	;UNSUCCESSFUL OPEN
	JRST	DOPERR
ERINIT:	MOVEI	Z,^D12	;ATTEMPT TO INIT A FILE ALREADY IN USE
	JRST	DOPERR
ERCLS:	ERROR	13	;UNSUCCESSFUL CLOSE
ERASOC:	ERROR	14	;ASSOCIATED VARIABLE NO GOOD
ERRDUN:	ERROR	15	;ATTEMPT TO READ AN UNDEFINED RECORD
NOCHAN:	ERROR	16	;NO CHANNEL IS AVAILABLE
EROPEN:	ERROR	17	;ATTEMPT TO OPEN AN OPEN DATASET
ERWRT:	ERROR	18	;ATTEMPT TO WRITE A READ ONLY DATASET
ERRED:	ERROR	19	;ATTEMPT TO READ A WRITE ONLY DATASET
ERLRCL:	ERROR	20	;INVALID LOGICAL RECORD LENGTH
ERRDEL:	ERROR	21    ;INNVALID DELETE ATTEMPT
DOPERR:	MOVEM	Z,@1(P)	;SAVE ERROR CODE
	PUSHJ	S,CLEAR
	JRST	RETURN

;IMPOSSIBLE ERRORS
;***IMP1:	IMPER	1	;CBN NOT CORRESPOND W DATA THERE
ZERCBN:	IMPER	2	;CBN IS ZERO!
IMP3:	HRROI	Z,-^D3	;LOOKUP/ENTER FAIL IN INITIALIZATION ROUTINE
	JRST	DOPERR
;CALL DDEL (DSRN,ERR,ASSOC,IARAY)
DDEL:	0	;FORTRANS NON REENTRANT WORD
	MOVEM	17,SAVE+17
	MOVEI	17,SAVE
	BLT	17,SAVE+16
	MOVEI	S,STACK
	MOVEI	T,1	;SET DELETE SWITCH
	PUSHJ	S,DSRNTS ;DO DSRN TESTS
	LDB	I,BPMODE
	TRNN	I,2	;TEST ABILITY TO UPDSTE
	JRST	ERRDEL	;CANT UPDATE INDICATE SO
	PUSHJ	S,DRED1	;GO READ UNTIL HIT OCCURS
	PUSHJ	S,DWRT5	;SET UNDEFINED BIT AND REWRITE
DDEL1:	TLZ	A,100000
	MOVEM	A,DSRNTB(B)
	MOVEI	Z,1	;INDICATE SUCCESS
	MOVEM	Z,@1(P)	;LOCATE
	AOS	@2(P)	;
	JRST	RETURN	;GO BACK TO CALLER
	END	
 oYz