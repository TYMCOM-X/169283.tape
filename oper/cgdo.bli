
!***COPYRIGHT 1972,1973 BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MA 01754***
!AUTHOR NORMA ABEL
GLOBAL BIND CGDOV=100;		!VERSION DATE: 7/12/73

%*****
	CODE GENERATOR DRIVERS FOR DO LOOPS
*****%

GLOBAL ROUTINE CGDOLOOP=
BEGIN

	EXTERNAL TREEPTR,A1NODE,A2NODE,OPDSPIX,REGFORCOMP,CGOPGEN,CSTMNT,DEFLAB,GENLAB;
	EXTERNAL CGERR,DOSTI;
	EXTERNAL CGETVAL,OPGSTA,OPGETI,DOSP,OPGSTI,OPGETA,DOSTC;
MAP BASE DOSP:A1NODE:CSTMNT:TREEPTR;
	OWN PEXPRNODE DOCEXPR;		!PTR TO EXPRESSION FOR CONTROL WD

LOCAL CTLREG,	!CONTROL WORD REGISTER
	IVALREG;	!INITIAL VALUE REGISTER

	!SET UP LOCAL VALUES
	CTLREG_.CSTMNT[DOCREG]^23;
	IVALREG_.CSTMNT[DOIREG]^23;

	%(***GET THE VAL OF THE CONTROL EXPRESSION INTO THE LOOP CTL REG***)%
	DOCEXPR_.CSTMNT[DOLPCTL];
	A1NODE_.DOCEXPR;

	%(***IF THE CTL EXPR NEEDS TO BE EVALUATED AT RUN TIME, GENERATE
		CODE TO EVALUATE IT***)%
	IF .DOCEXPR[OPRCLS] NEQ DATAOPR
	THEN
	BEGIN
		TREEPTR_.DOCEXPR;
		CGETVAL();
	END;

	%(***GET THE VALUE OF THE CTL EXPRESSION INTO THE LOOP CTL REG***)%
	IF NOT .CSTMNT[CTLSAMEFLG]
	THEN
	BEGIN
		REGFORCOMP_.CTLREG;
		A1NODE_.DOCEXPR;

		IF .CSTMNT[FLCWD] THEN	!IF THE CTL IS IN AN AOBJN WD
			OPDSPIX_OPGETA
		ELSE
			OPDSPIX_DOGETAOPIX(.CSTMNT[CTLIMMED],
						.A1NODE[VALTP1],.CSTMNT[CTLNEG]);
		CGOPGEN();
	END;

!CONTROL WORD IS NOW IN A REGISTER
!GET THE INTIALIAL VALUE IN ONE IF NECESSARY

	IF NOT .CSTMNT[FLCWD] THEN
	BEGIN
		REGFORCOMP_.IVALREG;
		A1NODE_.CSTMNT[DOM1];	!INITIAL VALUE
		IF .CSTMNT[INITLIMMED] THEN
			OPDSPIX_DOGETAOPIX(1,.A1NODE[VALTP1],.CSTMNT[INITLNEG])
		ELSE
			OPDSPIX_DOGETAOPIX(0,.A1NODE[VALTP1],.CSTMNT[INITLNEG]);
		CGOPGEN();
	END;

	%(***IF THIS LOOP MUST HAVE ITS INDEX MATERIALIZED, GENERATE CODE TO
		STORE THE COUNT AND THE INDEX***)%
	IF .CSTMNT[NEDSMATRLZ]
	THEN
	BEGIN
		%(***GENERATE CODE TO STORE THE COUNT***)%

		A1NODE_.CSTMNT[DOCTLVAR];
		REGFORCOMP_.CTLREG;
		OPDSPIX_DOSTC + .CSTMNT[FLCWD];
		CGOPGEN();


		%(***GENERATE THE MATERIALIZATION LABEL***)%
		DOSP[LEFTP]_GENLAB();
		DEFLAB(.DOSP[LEFTP]);

		!NOW STORE INITIAL VALUE
		!USING OPGNTA TABLES TO GET DOUBLE PRECISION UNLESS ITS AN HRRM

		IF .CSTMNT[FLCWD] THEN
		BEGIN
			A1NODE_.CSTMNT[DOSYM];		!INDUCTION VARIABLE
			REGFORCOMP_.CTLREG;
			OPDSPIX_DOSTI;
			CGOPGEN();
		END ELSE
		BEGIN
			REGFORCOMP_.IVALREG;
			TREEPTR_.CSTMNT[DOSYM];
			OPDSPIX_STOROPIX(TREEPTR);
			CGOPGEN();
		END;
	END;


!NOW GENERATE NON-MATERIALIZATION LABELS

	DOSP[RIGHTP]_GENLAB();
	DEFLAB(.DOSP[RIGHTP]);
	DOSP_.DOSP+1;
END;
GLOBAL ROUTINE CGDOEND(TLAB)=
BEGIN
	LABEL DODOER;
	EXTERNAL CGERR;
	EXTERNAL CGOPGEN,OPDSPIX,REGFORCOMP,TREEPTR,A1LABEL,A2LABEL,
	A1NODE,A2NODE,DOSP,DOEND,OPGARA,OPGARI,OPGDOE;
	EXTERNAL OPGETA,OPGETI,OPGDOS;
MAP BASE TLAB;
	MAP BASE A1NODE:DOSP:A2NODE:TREEPTR;

!TLAB POINTS TO LABEL TABLE ENTRY FOT LABEL TERMINATING THE SCOPE OF
!ONE OR MORE DO STATEMENTS.
!SNDOLNK POINTS TO A LINKED LIST OF THE DO STATEMENTS TERMINATING
!HERE
LOCAL CURDO,		!THE CURRENT DO LOOP
	NXTWD,		!WORD CONTAINING LINK AND DO POINTER
	NXTLNK,		!WORD CONTAINING LINK TO NEXT WORD
	TMP1;
MAP BASE CURDO:TMP1:NXTWD:NXTLNK;

	IF .TLAB[SNDOLVL] EQL 0 THEN RETURN;	!NO DO'S END HERE

	NXTWD_.TLAB[SNDOLNK];		!POINT AT FIRST OF LIST
	DODOER:
	WHILE 1 DO
	BEGIN
		CURDO_.NXTWD[LEFTP];
		!IF THE LOOP IS STILL THERE
		IF NOT .CURDO[DOREMOVED] THEN
		BEGIN

			DOSP_.DOSP-1;
			!LOOK AT THE CORRECT STACK ENTRY
			!TEST NEDMATRLZ
			IF .CURDO[NEDSMATRLZ] THEN
			A1LABEL_.DOSP[LEFTP]
			ELSE
			A1LABEL_.DOSP[RIGHTP];

			IF .A1LABEL EQL 0 THEN CGERR();


			!WHETHER OR NOT THE VARIABLE (CONTROL WORD OR SSIZ)
			!IS RELOADED INTO A REGISTER IS GOVERNED BY
			!THE NEDSMATRLZ FLAG WHICH IS ADDED INTO THE BASIC INDEX



			%(***FOR THE AOBJN CASE - THE CONTROL WD AND THE LOOP INDEX ARE INCREMENTED
				TOGETHER***)%
			IF .CURDO[FLCWD] AND NOT .CURDO[NEDSMATRLZ]
			THEN
			BEGIN
				A1NODE_.CURDO[DOCTLVAR];	!TEMP FOR CONTOL WORD
				REGFORCOMP_.CURDO[DOCREG]^23;
				OPDSPIX_OPGDOE;
				!GENERATE AOBJN CREG,A1LABEL
			END ELSE


			%(***FOR CASES OTHER THAN AOBJN - MUST GENERATE CODE TO INCREMENT
				THE LOOP INDEX AND CODE TO INCREMENT AND TEST THE CONTROL-WORD***)%
			BEGIN
				%(***GENERATE CODE TO ADD THE STEP SIZE TO THE LOOP INDEX***)%
				REGFORCOMP_.CURDO[DOIREG]^23;

				!IF THE LOOP INDEX IS NOT MATERIALIZED, WILL SIMPLY GENERATE
				! AN ADD OF THE INCR TO THE REG HOLDING THE INDEX
				IF NOT .CURDO[NEDSMATRLZ]
				THEN
				BEGIN
					A2NODE_.CURDO[DOSSIZE];	!PTR TO INCR
					OPDSPIX_(IF (.CURDO[SSIZONE] OR .CURDO[SSIZIMMED])
						AND .A2NODE[VALTYPE] NEQ DOUBLPREC
						THEN DOARITHOPIX(.A2NODE[VALTP1],0,1,.CURDO[SSIZNEGFLG])
						ELSE DOARITHOPIX(.A2NODE[VALTP1],0,0,.CURDO[SSIZNEGFLG]) );
					CGOPGEN();
				END

				!IF THE LOOP INDEX IS MATERIALIZED AND THE INCREMENT IS
				! 1, GENERATE AOS
				ELSE
				IF (.CURDO[SSIZONE] AND NOT .CURDO[REALARITH])
					OR .CURDO[FLCWD]
				THEN
				BEGIN
					A1LABEL_.DOSP[RIGHTP];
					!NON-MATRLIZE LABEL
					OPDSPIX_OPGDOS;
					A1NODE_.CURDO[DOSYM];
					CGOPGEN();
				END

				!IF THE LOOP INDEX NEEDS TO BE MATERIALIZED, PICK UP THE
				! INCREMENT AND THEM ADD IT TO MEMORY IF VALTYPE IS NOT DOUBLE-PREC
				ELSE
				BEGIN
					!TO LOAD THE INCREMENT
					A1NODE_.CURDO[DOSSIZE];
					OPDSPIX_(IF (.CURDO[SSIZONE] OR .CURDO[SSIZIMMED])
					AND .A1NODE[VALTYPE] NEQ DOUBLPREC
						THEN DOGETAOPIX(1,.A1NODE[VALTP1],.CURDO[SSIZNEGFLG])
						ELSE DOGETAOPIX(0,.A1NODE[VALTP1],.CURDO[SSIZNEGFLG]) );
					CGOPGEN();

					!UNLESS THE INDEX IS DOUBLE-PREC WILL ADD THE
					! INCREMENT TO IT IN MEMORY, AND TRANSFER AT LOOP
					! END WILL BE TO THE MATERIALIZATION CODE
					A2NODE_.CURDO[DOSYM];
					IF .A2NODE[DBLFLG]
					THEN OPDSPIX_DOARITHOPIX(.A2NODE[VALTP1],0,0,0)
					ELSE
					BEGIN
						A1LABEL_.DOSP[RIGHTP];
						OPDSPIX_DOARITHOPIX(.A2NODE[VALTP1],1,0,0);
					END;
					CGOPGEN();
				END;


				!GENERATE CODE TO INCREMENT AND TEST THE CONTROL WORD
				!AOJL
				!OR
				!AOSGE
				!JRST
				!THE CONTROL REGISTER IS USED
				REGFORCOMP_.CURDO[DOCREG]^23;
				OPDSPIX_OPGDOE+2+.CURDO[NEDSMATRLZ];
				A1NODE_.CURDO[DOCTLVAR];
			END;
			CGOPGEN();
		END;			!DO LOOP REALLY THERE TEST
		NXTLNK_.NXTWD[RIGHTP];
		IF .NXTLNK EQL 0 THEN LEAVE DODOER
		ELSE
			NXTWD_.NXTLNK;
	END;		!WHILE 1 LOOP
END;		!CGDOEND;

!MACRO CREATES 3 SIXBIT CHARACTERS OF SUBROUTINE NAME TO
!BE USED IN FORMING TEMPORARY NAMES.  THE NAMES ARE PREFIXED WITH
!A . AND SUFFIXED WITH THE NUMBERS 2-17.
!2-16 ARE FOR REGISTER SAVES.
!17 IS FOR THE EPILOGUE ADDRESS IF THERE ARE MULTIPLE ENTRIES

MACRO GETXXX=
	(.PROGNAME<30,6>^24
	+(IF .PROGNAME<24,6> EQL 0 THEN 16
	  ELSE .PROGNAME<24,6>)^18
	+(IF .PROGNAME<18,6> EQL 0 THEN 16
	  ELSE .PROGNAME<18,6>)^12)$;

!ADD THE DOT AND NUMBER WITH THE MACRO TNAME

MACRO TNAME(INDX)=
	(SIXBIT'.' +.NAMER
	+((INDX AND #70)^(-3)+16)^6
	+((INDX AND #7)+16))$;



!GENERATE A MOVE 1,SRCE

MACRO MOV1GEN(SRCE)=
BEGIN
	EXTERNAL C1H;
	OPDSPIX_MOVRET;
	C1H_SRCE;
	CGOPGEN();
END$;

!GENERATE THE VALUE TO ADD TO THE VALUE OF THE PARAMETER LIST
!BASE FOR A RETURN I

MACRO DATAGEN(NUMB)=
BEGIN
	PSYMPTR_PBF2NOSYM;
	!THE WORD WILL HAVE 16 IN THE REGISTER FIELD
	PBOPWD_#16^18 OR NUMB;
	OBUFFA();
END$;



MACRO ENTLST=ENTLIST$;	!TO CORRECT TYPING ERROR

!OWN VARIABLE
OWN EPILAB,JUMPABOUT,JMPVECT,LABARGCT,JMPSFN;


EXTERNAL LASTONE;

GLOBAL ROUTINE CGPROEPI =
BEGIN
	OWN PEXPRNODE ENTNAME;
%(*********************************
	SUBROUTINE PROLOGUE
	AND EPILOGUE
*********************************)%
	!TEMPORARY NAMES ARE OF THE FORM
	!.XXXNN, WHERE:
	!	1.  XXX IS THE FIRST 3 LETTERS OF THE SUBROUTINE NAME
	!	2.  NN IS 2-16 (DECIMAL)
	LABEL FNLOK;
	LOCAL ARGLSTPT,NAMER,NEDTOSAV;
	EXTERNAL OPGADJ,A2LABEL;
	EXTERNAL OPGMVL;
	EXTERNAL A1LABEL,OPGPHR,OPGPPR,DVALU,OPINSA,OPINSI,CLOBBREGS;
	EXTERNAL OUTMOD,PBFPTR,PBUFF,PBOPWD,OBUFF,OBUFFA,PSYMPTR,C1H;
	EXTERNAL CSTMNT,NAME,TBLSEARCH,ENTRY,GENLAB,PROEPITYP,DEFLAB,POPRET,CRETN,PROGNAME;
	EXTERNAL CGOPGEN,OPDSPIX,REGFORCOMP,TREEPTR, A1NODE, OPGETA, OPGSTA, OPINDA, OPINDI,OPGETI,OPGSTI;
	EXTERNAL ARGLINKPT;
	MAP PEXPRNODE CSTMNT:A1NODE;
	MAP ARGUMENTLIST ARGLSTPT;
	MAP PEEPFRAME PBUFF;
	EXTERNAL OUTMDA,OPGIIN;


	JUMPABOUT_0;
	!IF AN ENTRY THEN JRST AROUND PROLOGUE
	!AND EPILOQUE


	NAMER_GETXXX;
	IF .CSTMNT[SRCID] EQL SFNID THEN
	BEGIN
		JMPSFN_GENLAB();
		JRSTGEN(.JMPSFN);
		!USE A1NODE AS A TEMP 
		!TO MAKE AND SAVE THE LABEL FOR THE SFN THAT
		!WILL BE USED IN THE PUSHJ AT REFERENCE TIME

		A1NODE_.CSTMNT[SFNNAME];
		A1NODE[IDSFNLAB]_GENLAB();
	END;

	IF .CSTMNT[ENTNUM] NEQ 0 AND .CSTMNT[SRCID] NEQ SFNID  THEN
	BEGIN
		JUMPABOUT_GENLAB();
		JRSTGEN(.JUMPABOUT);
	END;



	%(***OUTPUT ANY INSTRS REMAINING IN THE PEEPHOLE BUFFER (AND INITIALIZE
		THE PTR TO NEX AVAILABLE  WD IN BUFFER TO THE 1ST WD OF BUFFER)***)%
	IF .PBFPTR NEQ PBUFF
	THEN
	BEGIN
		OUTMOD(PBUFF,(.PBFPTR-PBUFF)/PBFENTSIZE);
		PBUFF[PBFLABEL]_NOLABEL;	!INIT LABEL FIELD OF 1ST INSTR

		PBFPTR_PBUFF;
	END;


	%(***OUTPUT SIXBIT FOR THE ENTRY NAME. USE THE OUTPUT ROUTINE "OBUFFA" TO
		BYPASS THE PEEPHOLE OPTIMIZER***)%
	ENTNAME_.CSTMNT[ENTSYM];
	PBOPWD_.ENTNAME[IDSYMBOL];
	PSYMPTR_PBF2NOSYM;
	OBUFFA();


	%(***MUST NOW CLEAR THE PEEPHOLE BUFFER AGAIN BEFORE START PEEPHOLING***)%
	IF .PBFPTR NEQ PBUFF
	THEN
	BEGIN
		OUTMDA(PBUFF,(.PBFPTR-PBUFF)/PBFENTSIZE);
		PBFPTR_PBUFF;
		PBUFF[PBFLABEL]_NOLABEL;
	END;


	!THERE SHOULD BE ONLY ONE SUBROUTINE OR FUNCTION PER
	!COMPILATION UNIT

	!SAVE THE EPILOGUE ADDRESS IF NECESSARY
	!MAKE THE ENTRY NAME A GLOBAL FOR THE LOADER
	IF .CSTMNT[SRCID] NEQ SFNID THEN
	BEGIN
		PBOPWD_.CSTMNT[ENTSYM];
		PSYMPTR_PBFENTRY;
		OBUFF();
	END
		ELSE
		BEGIN
			A1NODE_.CSTMNT[SFNNAME];
			DEFLAB(.A1NODE[IDSFNLAB]);
		END;

	!DEFINE THE EPILOGUE LABEL
	EPILAB_GENLAB();
	IF .PROEPITYP THEN				!LAST BIT ON = MULTIPLE ENTRY
	BEGIN
		REGFORCOMP_1^23;				!HOPE TO GENERATE
		A1LABEL_.EPILAB;			!MOVEM 1, XXX17
		OPDSPIX_OPGMVL;
		NAME_IDTAB;
		ENTRY_TNAME(#17);
		A1NODE_TBLSEARCH();
		CGOPGEN();
	END;
	!REGISTER SAVE
	!SAVE REGISTER 16 EXCEPT IF ITS A STATEMENT FUNCTION
	!USE PUSHES FOR SFN,S MOVEMS OTHERWISE
	IF .CSTMNT[SRCID] EQL SFNID THEN
		OPDSPIX_OPGPHR
	ELSE
	BEGIN
		OPDSPIX_OPGSTA;
		NAME_IDTAB;
		ENTRY_TNAME(#16);
		TREEPTR_TBLSEARCH();
		REGFORCOMP_#16^23;
		CGOPGEN();
	END;

	!NOW IF IT IS A FUNCTION

	FNLOK:
	IF .PROEPITYP<2,1> THEN		!BIT SET IN ALCSUB
	BEGIN
			NEDTOSAV_LASTONE(.CLOBBREGS);
			IF .NEDTOSAV LSS 0 THEN LEAVE FNLOK
			ELSE
			NEDTOSAV_ASNREG(.NEDTOSAV);

		IF .BTTMSTFNFLG THEN
		BEGIN
			DECR I FROM .NEDTOSAV TO 2 DO
			BEGIN
				IF .CSTMNT[SRCID] EQL ENTRID THEN
				BEGIN
					ENTRY_TNAME(.I);
					TREEPTR_TBLSEARCH();
				END;
				REGFORCOMP_.I^23;
				CGOPGEN();
			END;
		END ELSE
		BEGIN

			INCR I FROM .NEDTOSAV TO #15 DO
			BEGIN
				IF .CSTMNT[SRCID] EQL ENTRID THEN
				BEGIN
					ENTRY_TNAME(.I);
					TREEPTR_TBLSEARCH();
				END;
				REGFORCOMP_.I^23;
				CGOPGEN();
			END;
		END;
	END;
	!MOVE ARGS TO TEMPS
	!ADDRESS OF TEMP IS IN SYMBOL TABLE FOR ARGUMENT
	REGFORCOMP_0;
	IF .CSTMNT[ENTLST] NEQ 0 THEN
	BEGIN
		ARGLSTPT_.CSTMNT[ENTLST];
		INCR I FROM 1 TO .ARGLSTPT[ARGCOUNT] DO
		BEGIN
			TREEPTR_
			A1NODE_.ARGLSTPT[.I,ARGNPTR];
			IF .A1NODE EQL 0 THEN			!ZERO MEANS LABEL
			ELSE
			BEGIN
				IF .A1NODE[OPR1] EQL OPR1C(DATAOPR,FORMLVAR) THEN
					!MOVE VALUE OF SCALAR TO REGISTER
				BEGIN
					OPDSPIX_.A1NODE[VALTP1]+(IF .KA10FLG THEN
						OPINDA ELSE OPINDI);
					C1H_(IF (.A1NODE[DBLFLG] AND .KA10FLG) THEN 0
						ELSE INDBIT) OR (.I-1);
				END ELSE
					BEGIN
						OPDSPIX_OPGIIN;
						C1H_INDBIT OR (.I-1);
					END;
				CGOPGEN();		!VALUE NOW IN A REGISTER
				!NOW STORE VALUE OR POINTER IN TEMP
				IF .A1NODE[OPR1] EQL OPR1C(DATAOPR,FORMLVAR) THEN
					OPDSPIX_.A1NODE[DBLFLG]+(IF .KA10FLG THEN OPGSTA ELSE OPGSTI)
				ELSE
					OPDSPIX_OPGSTA;
				CGOPGEN();
			END;
		END;
	END;
	!NOW GENERATE JRST TO FIRST EXECUTABLE STATEMENT

	!*************************************************
	!*************************************************
	!THIS JRST IS SPECIAL
	!IF WE ARE GOING TO CREATE A JUMP VECTOR FOR MULTIPLE
	!RETURNS, WE MUST OUTPUT THE PEEPHOLE BUFFER BEFORE
	!GENERATING THE JRST. ELSE, IT WOULD BE A LABELED
	!JRST AND RECEIVE CROSS-JUMPING OPTIMIZATION. SINCE
	!THE PEEPHOLE OPTIMIZER ALWAYS LOOKS AT THE THIRD FROM LAST
	!INSTRUCTION, MAKING IT THE FIRST INSTRUCTION WILL
	!INHIBIT THE PEEPHOLE.
	!****************************************************
	!*********************************************************
	IF .JUMPABOUT EQL 0 THEN			!ALREADY HAVE LABEL IF
							!JUMPABOUT IS SET
		JUMPABOUT_GENLAB();
	IF .PROEPITYP<1,1> THEN				!LABELS AS PARMS
							!MAKE THIS JRST THE BASE OF THE JUMP VECTOR
	BEGIN						!SO WE DONT WASTE A SPACE
		!*************************
		!HERE IS THE SPECIAL OUTPUT OF THE BUFFER
		!****************************

		OUTMOD(PBUFF,(.PBFPTR-PBUFF)/PBFENTSIZE);
		PBFPTR_PBUFF;
		PBUFF[PBFLABEL]_NOLABEL;

		JMPVECT_GENLAB();
		DEFLAB(.JMPVECT);
	END;
	!NOW JRST TO FIRST EXECUTABLE
	JRSTGEN(.JUMPABOUT);
	!NOW THE REST OF THE JUMP VECTOR IF NEEDED
	LABARGCT_0;
	IF .PROEPITYP<1,1> THEN		!LABELS AS PARAMETERS
	BEGIN
		!FIRST OUTPUT THE JRST, IT MUST GO THRU
		!OUTMOD.

		OUTMOD(PBUFF,1);
		PBFPTR_PBUFF;
		PBUFF[PBFLABEL]_NOLABEL;

		IF .CSTMNT[ENTLST] NEQ 0 THEN
		BEGIN
			ARGLSTPT_.CSTMNT[ENTLST];
			INCR I FROM 1 TO .ARGLSTPT[ARGCOUNT] DO
			BEGIN
				IF .ARGLSTPT[.I,ARGNPTR] EQL 0 THEN	!ITS A LABEL
				BEGIN
					LABARGCT_.LABARGCT+1;
					DATAGEN(.I-1);
				END;
			END;
		END;
		!NOW OUTPUT THE JUMP VECTOR THROUGH OUTMDA

		OUTMDA(PBUFF,.LABARGCT);
		PBFPTR_PBUFF;

	END;

		!NOW, BREATHLESSLY, WE ARE UP TO THE EPILOGUE
		!RESTORE REGISTER 16
		!STATEMENT FUNCTIONS WONT RESTORE 16 AT ALL

		DEFLAB(.EPILAB);
		IF .CSTMNT[SRCID] EQL SFNID THEN
		ELSE
		BEGIN
			NAME_IDTAB;
			ENTRY_TNAME(#16);
			A1NODE_TBLSEARCH();
			OPDSPIX_OPGETA;
			REGFORCOMP_#16^23;
			CGOPGEN();
		END;

		!FOR LABELS AS PARAMETERS GENERATE THE COMPLEX RETURN
		IF .PROEPITYP<1,1> THEN
		BEGIN
			A2LABEL_.JMPVECT;
			A1LABEL_GENLAB();		!LABEL FOR OUT OF BOUNDS
			C1H_.LABARGCT;
			OPDSPIX_CRETN;
			CGOPGEN();
			DEFLAB(.A1LABEL);
		END;

		!NOW MOVE SCALARS BACK
		!NOT NECESSARY FOR  STATEMENT FUNCTIONS
		IF .CSTMNT[ENTLST] NEQ 0 AND .CSTMNT[SRCID] NEQ SFNID  THEN
		BEGIN
			REGFORCOMP_0;
			ARGLSTPT_.CSTMNT[ENTLST];
			INCR I FROM 1 TO .ARGLSTPT[ARGCOUNT] DO
			BEGIN
				A1NODE_.ARGLSTPT[.I,ARGNPTR];
				IF .A1NODE EQL 0 THEN
				ELSE
				!ONLY MOVE THEM BACK IF THEY WERE
				!STORED INTO, ELSE WE ARE IN TROUBLE
				!WITH GENERATING HISEG STORES

				IF .A1NODE[IDATTRIBUT(STORD)] THEN
				IF .A1NODE[OPR1] EQL OPR1C(DATAOPR,FORMLVAR) THEN
				BEGIN
					C1H_INDBIT OR (.I-1);
					OPDSPIX_.A1NODE[VALTP1]+
					(IF .KA10FLG THEN OPGETA
					ELSE OPGETI);
					CGOPGEN();
					IF .A1NODE[DBLFLG] AND .KA10FLG THEN
					BEGIN
						OPDSPIX_OPINSA;
						CGOPGEN();
						C1H_(.I-1);
					END;
					OPDSPIX_(.A1NODE[DBLFLG]+
						(IF .KA10FLG THEN OPINSA ELSE OPINSI));
					CGOPGEN();
				END;
			END;
		END;

		!RESTORE REGISTERS IF NEED BE
		IF .CSTMNT[SRCID] EQL SFNID THEN
			OPDSPIX_OPGPPR
		ELSE
			OPDSPIX_OPGETA;
		NAME_IDTAB;
		IF .PROEPITYP<2,1> THEN
		BEGIN
			!***********************************
			!NOTE:
			!SINCE STATEMENT FUNCTIONS PUSH AND POP
			!FOR REGISTER SVAE RESTORE THESE MUST
			!BE SYMETRICALLY REVERSE TO THE SAVE
			!CODE IN THE PROLOGUE
			!************************************

			IF .BTTMSTFNFLG THEN
			BEGIN
				INCR I FROM 2 TO .NEDTOSAV DO
				BEGIN
					IF .CSTMNT[SRCID] EQL ENTRID THEN
					BEGIN
						ENTRY_TNAME(.I);
						A1NODE_TBLSEARCH();
					END;
					REGFORCOMP_.I^23;
					CGOPGEN();
				END;
			END ELSE
			BEGIN
				IF .NEDTOSAV GEQ 0 THEN
				DECR I FROM #15 TO .NEDTOSAV DO
				BEGIN
					IF .CSTMNT[SRCID] EQL ENTRID THEN
					BEGIN
						ENTRY_TNAME(.I);
						A1NODE_TBLSEARCH();
					END;
					REGFORCOMP_.I^23;
					CGOPGEN();
				END;
			END;

		!PICK UP RETURN FUNCTION VALUE
			REGFORCOMP_0;
			A1NODE_.CSTMNT[ENTSYM];
			OPDSPIX_.A1NODE[VALTP1]+
				(IF .KA10FLG THEN OPGETA ELSE OPGETI);
			CGOPGEN();
		END;
		OPDSPIX_POPRET;
		CGOPGEN();
		!DEFINE FIRST EXECUTABLE
		DEFLAB(.JUMPABOUT);			!DEFINE LABEL OF FIRST EXECUTABLE
	!IF THERE ARE MULTIPLE ENTRIES (THE RETURN WILL BE AN
	!INDIRECT JRST) THEN MAKE EPILAB POINT TO THE TEMP
	!IN WHICH THE EPILOGUE ADDRESS IS STORED

	IF .PROEPITYP THEN
	BEGIN
		NAME_IDTAB;
		ENTRY_TNAME(#17);
		EPILAB_TBLSEARCH();
	END;
END;

	!MACRO TO GENERATE AN INDIRECT JRST THROUGH A VRIABLE
	!DIFFERS FROM JRSTIGEN IN THE SETTING OF PSYMPTR

	MACRO JRSTIVAR(ADDR)=
	BEGIN
		PBOPWD_JRSTOC OR INDBIT OR ADDR[IDADDR];
		PSYMPTR_ADDR;
		OBUFF();
	END$;

GLOBAL ROUTINE CGRETURN(EXPR)=
BEGIN
%(******************************************
		RETURN STATEMENT
		EXPR POINTS TO THE RETURN EXPRESSION
******************************************)%


!GENERATE SETZ 1 FOR PLAIN RETURN WHEN THERE ARE LABELS AS PARAMETERS

MACRO SET1ZGEN=
BEGIN
	REGFORCOMP_1^23;
	OPDSPIX_OPGSET+1;
	CGOPGEN();
END$;

	EXTERNAL PROEPITYP,MOVRET,CGETVAL;
	EXTERNAL PBOPWD,OPDSPIX,PSYMPTR,OBUFF,OPGSET,CGOPGEN,REGFORCOMP;
	EXTERNAL TREEPTR,A1NODE,CSTMNT,OPGETA,OPGETI,PROGNAME,CGEND;
	MAP PEXPRNODE TREEPTR:A1NODE:CSTMNT;
	MAP BASE EPILAB;
	MAP PEXPRNODE EXPR;
	!A RETURN THAT APPEARS IN A MAIN PROGRAM SHOULD BE
	!TREATED LIKE A CALL EXIT. THIS IS  ACCOMPLISHED BY CALLING CGEND

	IF .PROGNAME EQL SIXBIT'MAIN. ' THEN
		CGEND();


	CASE .PROEPITYP<0,2> OF SET
	!SINGLE ENTRY NO LABELS AS PARAMETERS
	BEGIN
		JRSTGEN(.EPILAB);
	END;
	!
	!MULTIPLE ENTRY NO LABELS AS PARAMETERS
		JRSTIVAR(.EPILAB);
	!
	!SINGLE ENTRY - LABELS AS PARAMETERS
	BEGIN
		IF .EXPR EQL 0 THEN		!PLAIN VANILLA  RETURN
		BEGIN					!RETURN THRUBEL
			SET1ZGEN;
		END ELSE
		BEGIN
			TREEPTR_.EXPR;
			IF .TREEPTR[OPRCLS] EQL DATAOPR THEN	!EXPRESSION IS DATAITEM
			BEGIN
				REGFORCOMP_1^23;
				A1NODE_.TREEPTR;
				OPDSPIX_.A1NODE[VALTP1]
					+(IF .KA10FLG THEN OPGETA ELSE OPGETI);
				CGOPGEN();
			END ELSE
			BEGIN
				CGETVAL();
				!IF THE REGISTER ALLOCATOR DIDNT PUT IT IN 1
				!WHICH IT NEVER WILL DO. THEN MOVE IT TO 1
				IF .EXPR[TARGTAC] NEQ 1 THEN MOV1GEN(.EXPR[TARGTAC]);
			END;
		END;
		JRSTGEN(.EPILAB);
	END;
	!
	!MULTIPLE ENTRY -  LABELS AS PARAMETERS
	BEGIN
		IF .EXPR EQL 0 THEN		!PLAIN VANILLA RETURN
		BEGIN
			SETZ1GEN;
		END ELSE
		BEGIN					!RETURN THRU A LABEL
			TREEPTR_.EXPR;
			IF .TREEPTR[OPRCLS] EQL DATAOPR THEN	!EXPRESSION IS DATAITEM
			BEGIN
				REGFORCOMP_1^23;
				A1NODE_.TREEPTR;
				OPDSPIX_.A1NODE[VALTP1]
					+(IF .KA10FLG THEN OPGETA ELSE OPGETI);
				CGOPGEN();
			END ELSE
			BEGIN
				CGETVAL();
				!IF IT SI NOT ALREADY IN AC1 MOVE IT THERE
				IF .EXPR[TARGTAC] NEQ 1 THEN MOV1GEN(.EXPR[TARGTAC]);
			END;
		END;
		JRSTIVAR(.EPILAB);
	END;
	TES;
END;



GLOBAL ROUTINE CGSFN=
BEGIN
	!CODE GENERATION FOR STATEMENT FUNCTION
	OWN OCSTMNT,OCLOBB,OPRGM,OPE,SFNSYM,OEPILB;
	EXTERNAL CSTMNT,CLOBBREGS,PROGNAME,PROEPITYP,CGASMNT;
	MAP BASE CSTMNT:SFNSYM;
	EXTERNAL CGPROEPI,CGRETURN,DEFLAB;
	MACRO SAVCLBRG=EXPFLAGS$;
	!SAVE AWAY PERTINENT GLOBALS

	OCLOBB_.CLOBBREGS;
	OPRGM_.PROGNAME;
	OPE_.PROEPITYP;
	OCSTMNT_.CSTMNT;
	OEPILB_.EPILAB;
	!PROEPITYP MUST INDICATE FUNCTION ONLY
	PROEPITYP_1^2;			!SET TO NEW VALUES FOR SFN
	CLOBBREGS<LEFT>_.CSTMNT[SAVCLBRG];
	SFNSYM_.CSTMNT[SFNNAME];
	PROGNAME_.SFNSYM[IDSYMBOL];
	CGPROEPI();				!GENERATE PROLOGUE & EPILOGUE
	CSTMNT_.CSTMNT[SFNEXPR];
	CGASMNT();				!GENERATE CODE FOR STATEMENT
	CGRETURN();				!GENERATE RETURN
	!PUT SAVED VALUES BACK
	CLOBBREGS_.OCLOBB;
	PROGNAME_.OPRGM;
	PROEPITYP_.OPE;
	CSTMNT_.OCSTMNT;
	EPILAB_.OEPILB;
	DEFLAB(.JMPSFN);
END;
GLOBAL ROUTINE CGSBPRGM(ARLISTT,NAMEP)=
BEGIN
	%(******************************
		PERFORM VITAL CODE GENERATION
		FOR CALLS, FUNCTION REFERENCES
		AND STATEMENT FUNCTION REFERENCES
		AND LIBRARY FUNCTION REFERENCES
	******************************)%
	EXTERNAL ARGLINKPT,GENLAB,CGOPGEN,OPDSPIX,A1LABEL,A2LABEL;
	EXTERNAL TREEPTR,CGETVAL,OPGSFN,ZERBLK;
	EXTERNAL A1NODE,CALLER,TBLSEARCH,REGFORCOMP,OPGSTA,OPGSTI;
	MAP BASE NAMEP;
	MAP ARGUMENTLIST ARLISTT;
	!ARLISTT IS A POINTER TO THE ARGUMENT LIST.
	!NAMEP IS A POINTER TO THE SYMBOL TABLE
	!	ENTRY FOR THE ROUTINE NAME.
	!LINK INTO ARGLIST

	!FIRST CHECK FOR THE PRESENCE OF ARGUMENTS
	IF .ARLISTT NEQ  0 THEN
	BEGIN
	IF .ARGLINKPT NEQ 0 THEN ARLISTT[ARGLINK]_.ARGLINKPT;
	ARGLINKPT_.ARLISTT;

	!GENERATE CODE TO EVALUATE ARGUMENTS, IF NEEDED
	INCR I FROM 1 TO .ARLISTT[ARGCOUNT] DO
	BEGIN
		REGISTER BASE T;
		T_.ARLISTT[.I,ARGNPTR];	!PICK UP ARG PTR
		IF NOT .ARLISTT[.I,AVALFLG]
		THEN
		BEGIN
			TREEPTR_.T;
			CGETVAL();
		END ELSE
		BEGIN
			!IF ITS A REGISTER AND A LIBRARY FUNCTION
			!STASH IT AWAY IN MEMORY. IF ITS A REGISTER
			!AND NOT A LIBRARY FUNCTION THEN YOU LOSE
			IF .T[OPRCLS] EQL REGCONTENTS THEN
				BEGIN
					MAP PEXPRNODE TREEPTR;
					TREEPTR_.T[ARG2PTR];
					REGFORCOMP_.T[TARGTAC]^23;
					OPDSPIX_STOROPIX(TREEPTR);
					CGOPGEN();
					!TAKE THE REGCONTENTS NODE OUT
					!SO THE ARG LIST WILL BE RIGHT
					ARLISTT[.I,ARGNPTR]_.T[ARG2PTR];
				END;
		END;
	END;
	!SHOULD TEST FOR THIS BEING A LIBRARY FUNCTION
	!TO GENERATE A DIFFERENT NAME. NOT IN RELEASE 1.
	!**********************************
	A1LABEL_ARLISTT[ARGLABEL]_GENLAB();
	END ELSE			!FOR ARGUMENTS ONLY
	!IN THE CASE OF NO ARGS REFERENCE A 2 WORD, DEFINED ONLY ONCE
	!ZERO ARG BLOCK
		A1LABEL_.ZERBLK;

	!FOR A FORMAL FUNCTION SET THE INDIRECT BIT IN TH SYMBOL TABLE
	IF .NAMEP[IDATTRIBUT(DUMMY)] THEN
		NAMEP[TARGET]_.NAMEP[TARGET] OR INDBIT;

	IF .NAMEP[IDATTRIBUT(SFN)] THEN
	BEGIN
		A2LABEL_.NAMEP[IDSFNLAB];
		OPDSPIX_OPGSFN;
	END ELSE
	BEGIN
		A1NODE_.NAMEP;
		OPDSPIX_CALLER;
	END;
	CGOPGEN();
END;

ROUTINE ARGGEN(PTR)=
BEGIN
	MAP PEXPRNODE PTR;
	EXTERNAL EVALU,OBUFFA,PSYMPTR,PBOPWD,CGERR;
	MAP OBJECTCODE PBOPWD;
	!FOR A FORMAL ARRAY TURN ON THE INDIRECT BIT
	IF .PTR[OPR1] EQL OPR1C(DATAOPR,FORMLARRAY) THEN
	BEGIN
		PSYMPTR_.PTR;
		PBOPWD_.EVALU[.PTR[VALTYPE]]^23+.PTR[IDADDR]+INDBIT;
	END ELSE
	IF .PTR[OPRCLS] EQL DATAOPR THEN
	BEGIN
		PBOPWD_.EVALU[.PTR[VALTYPE]]^23 + .PTR[TARGTMEM];
		PSYMPTR_.PTR;
	END ELSE
	IF .PTR[OPRCLS] EQL LABOP THEN
	BEGIN
		PBOPWD_.PTR;
		PSYMPTR_PBFLABREF;
	END ELSE
	IF .PTR[OPRCLS] EQL ARRAYREF
	THEN
	BEGIN
		%(***FOR AN ARRAYREF, THE TARGET FIELD OF THE EXPRESSION NODE CONTAINS
			THE RELATIVE ADDRESS. ARG1PTR POINTS TO THE SYMBOL
			TABLE ENTRY***)%
		PBOPWD_.EVALU[.PTR[VALTYPE]]^23 + .PTR[TARGADDR];
		PSYMPTR_.PTR[ARG1PTR];

		%(***AN ARRAYREF-NODE IS FOUND DIRECTLY UNDER AN EXPRESSION NODE
			ONLY IF THE ADDRESS CALCULATION IS ENTIRELY CONSTANT.
			(IF THERE IS A VARIABLE PART, WILL HAVE INSERTED A NODE
			TO STORE A PTR TO THE ELEMENT INTO A TEMPORARY)***)%
		IF .PTR[ARG2PTR] NEQ 0 THEN CGERR();

	END
	ELSE
	BEGIN
		REGISTER BASE T;	!A TEMP
		!PICK UP THE TEMP IN WHICH THE RESULT VALUE WILL
		!WILL BE STORED. THIS IS THE *REAL* ARG
		T_.PTR[TARGADDR];
		PSYMPTR_.T;
		PBOPWD_.EVALU[.PTR[VALTYPE]]^23+.T[IDADDR];
		PBOPWD[OTSIND]_.PTR[TARGIF];
	END;
	OBUFFA();
END;
GLOBAL ROUTINE CGARGS=
BEGIN
	%(******************************
		AT THE END OF A BLOCK
		GENERATE ARGUMENT LISTS AND
		CONSTANTS NOT ALREADY GENERATED
	******************************)%
	EXTERNAL CGOPGEN,DVALU,OPDSPIX,C1H;
	LABEL ARGBLK;
	EXTERNAL ARGLINKPT,DEFLAB,PBOPWD;
	LOCAL ARGLSTPT,ARGCT,ARGS;
	MAP BASE ARGLINKPT:ARGS;
	EXTERNAL PSYMPTR,OBUFFA;
	MAP ARGUMENTLIST ARGLSTPT;
	!INSERT TEST FOR REALLY END OF
	!PROGRAM AND OTHERWISE GENERATE A
	!JRST AROUND
	WHILE .ARGLINKPT NEQ 0 DO
	ARGBLK:
	BEGIN
		ARGLSTPT_.ARGLINKPT;
		!WATCH OUT FOR STATEMENTS THAT MAY HAVE
		!BEEN DELETED BY FOLDING. ARGLABEL IS 0 FOR
		!THESE STATEMENTS.
		IF .ARGLSTPT[ARGLABEL] NEQ 0 THEN
		BEGIN
			ARGCT_.ARGLSTPT[ARGCOUNT];
			PBOPWD_-.ARGCT^18;
			PSYMPTR_PBF2NOSYM;
			OBUFFA();
			PBOPWD_0;
			DEFLAB(.ARGLSTPT[ARGLABEL]);
			INCR I FROM 1 TO .ARGCT DO
			BEGIN
				ARGS_.ARGLSTPT[.I,ARGNPTR];
				ARGGEN(.ARGS);
				PBOPWD_0;
			END;
		END;
		ARGLINKPT_.ARGLINKPT[CLINK];	!WHEN DONE THIS WILL BE
						!REINITIALIZED TO 0
	END;
END;
H}r¡