	TITLE FOROTS %1.(113) - FORTRAN OBJECT TIME SYSTEM
	SUBTTL	D. TODD /DRT/     29-JAN-1973

; MODIFIED 14-MAR-73 BY FAR-CORNERED SPROUT TO RUN ON TYMSHARE SYSTEM
; !!!! DO NOT USE RANDOM FILES WITH THIS FOROTS AND TYMSHARE'S MONITOR !!!!

;***COPYRIGHT 1972,1973 DIGITAL EQUIPMENT CORP., MAYNARD, MASS.***

	MLON


	ENTRY	FOROT%	;ENTRY POINT TO FOROTS - MUST BE DEFINED BEFORE
.JBOPS=:135
.JBVER=137
			;			 SEARCH FORPRM
	EXTERNAL	FORER%	;DEFINE FORERR AS EXTERNAL


	SEARCH	FORPRM	;GLOBAL SYMBOL DEFINED IN FORPRM

VERNO==01		;MAJOR VERSION NUMBER
VEDIT==113		;MAJOR EDIT NUMBER
VMINOR==01		;MINOR EDIT NUMBER
VWHO==0			;WHO EDITED LAST

VEROTS==BYTE (3)VWHO(9)VERNO(6)VMINOR(18)VEDIT

;	DEFINE THE LOADING

	LOC	.JBOPS		;MUST DEFINE .JBOPS
	Z			;EQUAL TO ZERO TELLS FORINI THAT
				;FOROTS WAS LOADED FROM FORLIB
	LOC	.JBVER
	VEROTS

	SEGMEN
	SUBTTL FOROTS ENTRY POINTS DEFINED BY FORDIR IN (FORPRM)
FOROT%=.
	LALL
	FORDIR
	SALL
	SUBTTL RESET FOROTS INITIALIZATION ROUTINE

; CALLED BY FORINI IN THE LOW SEGMENT
; .JBFF POINTS TO THE BEGINNING OF THE DYNAMIC CORE AREA
; .JBOPS AND P4 CONTAIN THE BASE REGISTER TO THE STATIC LOW SEGMENT
; AC'S 0-16 ARE SAVE FY FORINI IN ACC.SV

	INTERNAL	INIT%
INIT%:				;THIS ROUTINE FINISHES THE JOB OF
				; INITIALIZATION STARTED BY FORINI
        HRRZ    P4,.JBOPS
        MOVE    L,ACC.SV+16(P4)

	MOVEI	T1,LOW.SZ(P4)	;GET THE END OF THE STATIC AREA
	HRRZM	T1,.JBFF	;UPDATE  JOB FIRST FREE
	CAMG	T1,.JBREL	;IN OUR ADDRESSING SPACE
	JRST	.+3		;YES, OK
	CORE	T1,		;NO, PUT IT IN OUT ADDRESSING SPACE
	  HALT			;NO, CORE AVAILABLE
	HRRI	T2,ACC.SV+21(P4);BUILD A BLT POINTER TO CLEAR THE LOW
	HRLI	T2,ACC.SV+20(P4); SEGMENT FROM THE SAVE AREA
	SETZM	ACC.SV+20(P4)	;CLEAR THE FIRST WORD
	BLT	T2,@.JBREL	; TOP OF THE DYNAMIC AREA
	MOVEI	T1,LOW.SZ(P4)	;GET THE LOCATION OF THE DYNAMIC CORE
	AOS	T2,.JBREL	;BUILD A NEW JOB FF
	HRRM	T2,.JBFF	;SAVE AS END OF DYNAMIC MEMORY
	SUBI	T2,(T1)		;COMPUTE LENGTH OF DYNAMIC CORE
	HRLZM	T2,(T1)		;SAVE AS A CONTROL WORD FOR GETOWN
	HRRZM	T1,FRE.DY(P4)	;START THE FREE CORE LIST

				; STRUCTURED DYNAMIC CORE
	HRRI	P,STK.SV-1(P4)	;BUILT THE FOROTS STACK POINTER
	HRLI	P,-STK.SZ	;PUT THE SIZE OF THE STACK IN THE LEFT


	MSTIME	T1,		;GET THE CURRENT TIME OF DAY
	MOVEM	T1,DAY.TM(P4)	;SAVE IN STATIC LOW CORE
	SETZ	T1,		;CLEAR AC FOR OUR JOB
	RUNTIM	T1,		;GET THE RUNTIME SO FAR (SINCE LOG IN)
	MOVEM	T1,RUN.TM(P4)	;SAVE IN STATIC LOW CORE
	MOVEI	T1,2		;SET UP THE MAX ERROR COUNT
	MOVEM	T1,ERRMX.(P4)	;STORE THE ERROR COUNTER

	MOVE	T1,[XWD 17,11]	;GET CNFTBL (CONFIGURATION TABLE)
	GETTAB	T1,		; FROM THE MONITOR
	SETZ	T1,		;MUST BE A 4 SERIES MONITOR
	MOVEM	T1,MON.SV(P4)

;DON'T CHECK FOR PROPER MONITOR.  THIS IS SORT OF DANGEROUS BUT WHAT
;CAN YOU DO?

	SETOM	JOB.SV(P4)	;SET FLAG TO GET OUR CHARASTICS
	GETLCH	JOB.SV(P4)	;GET OUR CHARASTICS


	MOVEI	T0,DDB.SZ	;GET A TTY DDB
	PUSHJ	P,GETOWN	;ALLOCATE THE MEMORY
	HRRI	P3,(T1)		;LOAD THE I/O REG
	HRLI	P3,IO.FMT!IO.CCC!IO.TTA!IO.TTY!IO.INT!	
		IO.OPN!IO.SIN!IO.SOU			;SET FLAGS
	MOVSI	T0,(SIXBIT /TTY/);GET THE TTY NAME
	MOVEM	T0,DD.DEV(P3)	;SAVE IN THE DD.BLK
	MOVSI	T0,DD.HRO(P3)	;GET THE OUTPUT RING HEADER
	HRRI	T0,DD.HRI(P3)	;GET THE INPUT RING HEADER
	MOVEM	T0,DD.RNG(P3)	;SAVE IN THE DD.BLK
	MOVE	G3,[XWD DV.TTA!DV.TTY!DV.AVL!DV.IN!DV.OUT,400403]
	MOVEM	G3,DD.STS(P3)	;SAVE THE DEVICE STATUS
	MOVE	G1,[XWD 2,23]	;GET THE BUF SIZE AND COUNT
	MOVSI	T1,(20B12)	;SET TTY ON PSEUDO CHANNEL 0
	HLLZM	T1,DD.UNT(P3)	;PUT THE CHANNEL ENTRY IN THE DD.BLK
	PUSHJ	P,OPEND6	;OPEN THE TTY

	PUSHJ	P,TRPIN.##	;INITIALIZE THE TRAP ROUTINE


	MOVEM	L,USR.PC(P4)	;SAVE THE USR'S PC
	HRLZI	L,ACC.SV(P4)	;LOAD THE USER'S AC SAVE AREA
	BLT	L,L		;RESTORE THE USERS AC'S
	JRST	1(L)		;RETURN TO THE USER
	SUBTTL SAVE. GENERAL AC SAVE ROUTINE

; SAVE. IS CALLED ON ALL ENTRIES INTO THE FOROTS SYSTEM
; ALL AC'S ARE SAVE IN THE STATIC CORE ACC.SV
; ACC.SV+P CONTAINS A PUSHDOWN POINTER WHOSE ADDRESS IS TWO (2)
; GREATER THAN THE STACK ADDRESS OF THE ROUTINE
; THAT CALLED FOROTS. (USED BY THE ERROR ROUTINE FOR TRACE)

SAVE.:	PUSH	P,P4		;SAVE P4 ON THE STACK
	HRRZ	P4,.JBOPS	;LOAD THE SAVE AREA POINTER
	POP	P,ACC.SV+P4(P4)	;SAVE P4 IN THE SAVE AREA
	DMOVEM	L,ACC.SV(P4)	;SAVE THE LINK AND STACK POINTER
	MOVEM	P3,ACC.SV+P3(P4);SAVE P3 IN THE SAVE AREA
	MOVEI	P3,ACC.SV(P4)	;SET UP A BLT TO SAVE THE USR'S ACS
	BLT	P3,ACC.SV+P2(P4);SAVE ALL AC'S T0-P2
	POP	P,T1		;RESTORE THE CALLER'S  ADDRESS
	POP	P,USR.PC(P4)	;SAVE THE USER'S PC AND FLAGS
	PUSHJ	P,(T1)		;RETURN TO SAVE CALLER
	MOVSI	L,ACC.SV+L(P4)	;SET UP A JRA RETURN AND RESTORE L
	HRR	L,USR.PC(P4)	;GET THE USER'S RETURN ADDRESS
	MOVSI	P4,ACC.SV(P4)	;FOROTS, RETURNS HERE LOAD SAVE AREA
	BLT	P4,P4		;RESTORE ALL AC'S BUT L
	JRA	L,(L)		;RETURN TO THE USER
	SUBTTL OPEN ROUTINE TO PROCESS THE OPEN STATEMENT

SETOPN:			;DEFAULT OPEN ROUTINE
	PUSH	P,L		;SAVE THE LINK REGISTER
	PUSH	P,P2		;SAVE THE FLAG REGISTER
	MOVEI	L,IOL.SV(P4)	;USE SAVE AREA AS ARG BLOK
	HRLI	G1,3000		;SET ARG BLOCK SIZE AND UNIT NUMBER
	MOVEM	G1,(L)		;PUT IN ARG BLOCK
	MOVE	T1,[XWD 12000,[ASCIZ /ASCII/]] ;ASSUME ASCII MODE
	TLNN	P2,IO.FMT	;CHECK MODE BIT
	HRRI	T1,[ASCIZ /BINARY/] ;SWITCH TO BINARY
	MOVEM	T1,1(L)		;SAVE THE MODE ARGUEMNT
	MOVE	T1,[XWD 2000,[ASCIZ/SEQIN/]] ;ASSUME INPUT
	TLNN	P2,IO.SIN	;SEQIN MODE
	HRRI	T1,[ASCIZ/SEQOUT/] ;NO SET OUTPUT
	TLC	P2,IO.SIN!IO.SOU;CHECK FOR
	TLCN	P2,IO.SIN!IO.SOU;SEQIN OUT MODE
	HRRI	T1,[ASCIZ /SEQINOUT/]
	TLNE	P2,IO.RAN	;UNLESS RANDOM ACCESS
	HRRI	T1,[ASCIZ /RANDOM/]
	MOVEM	T1,2(L)		;PUT IN ARG BLOCK
	PUSHJ	P,OPEN%%	;OPEN THE DEVICE
	POP	P,P2		;RESTORE THE FLAGS
	POP	P,L		;RESTORE THE LINK
	POPJ	P,		;RETURN TO DEFAULT CALLER


	SUBTTL OPEN% ROUTINE TO DEFINE THE DD.BLK

;AC USAGE
;	P=	THE PUSH DOWN POINTER
;	L=	THE POINTER TO THE ARGUMENT BLOCK
;	P4=	THE LOW SEG BASE POINTER
;	P3=	THE DIALOG DEVICE

;	P2=	THE POINTER TO THE DD.BLK BEING DEFINE
;	P1=	THE JSP POINTER
;	G4=	NOT USED
;	G3=	THE CURRENT DISPATCH ENTRY
;	G2=	GLOBAL SCRATCH
;	G1=	POINT TO THE INCORE ARGUMENT (SET BY EFCTIVL)
;	T5=	TYPE ARGUMENT TYPE CODE
;	T4=	SCRATCH
;	T3=	SCRATCH
;	T2=	FLAGS DEFINING WHAT STOPPED THE DIALOG SCAN
;	T1=	A VALUE RETURNED FROM SCNNER (SWITCH NAME OR VALUE)
;	T0=	USED TO ASSEMBLE THE CONTENTS OF T1

OPEN%:	PUSHJ	P,SAVE.		;SAVE ALL AC'S AND LOAD P4
OPEN%%:	JSP	P1,SRCFLU	;IS THE FLU ASSIGNED
	JRST	OPEN0		;NO, CONTINUE
	PUSHJ	P,RELE%%	;YES, RELEASE THE UNIT FIRST
OPEN0:	MOVEI	T0,DDB.SZ	;FOROTS ENTRY - LOAD THE DD BLOCK SIZE
	PUSHJ	P,GETOWN	;GET DYNAMIC MEMORY TO DD BLOCK
	MOVEI	P2,(T1)		;SET UP P2 POINTING TO THE DD BLOCK
	HRRZM	G1,DD.UNT(P2)	;PUT THE FLU IN THE DD.BLK
	JSP	P1,GETCHN	;GET A SOFTWARE CHANNEL
	ERROR	(OPN,10,10,)	;NO CHANNEL AVAILABLE
	LSH	T1,5		;PUT THE CHANNEL IN THE AC FIELD
	HRLM	T1,DD.UNT(P2)	;PUT THE CHANNEL IN THE DD.BLK
	SETZ	P3,		;CLEAR THE I/O REGISTER
	LDB	T1,[POINT 9,(L),8]  ;GET THE ARGUMENT COUNT
	MOVNS	T1		;NEGATE THE COUNT
	HRLI	L,(T1)		;MAKE A AOBJ POINTER
OPEN1:	AOBJP	L,OPEN3		;UPDATE POINTER AND QUIT IF END
	JSP	P1,EFCTVL	;GET THE EFFECTIVE ADDRESS
	SKIPGE	(L)		;CHECK FOR IMMEDIATE MODE
	JRST	OPEN2		;YES, USE THE ADDRESS
	TRNN	G1,-20		;IN THE AC SAVE AREA
	ADDI	G1,ACC.SV(P4)	;YES, RELOCATE
	SKIPA	T1,(G1)		;GET THE VALUE OF THE ARGUMENT
OPEN2:	HRRE	T1,G1		;IMMEDIATE MODE GET THE VALUE
	LDB	T5,[POINT 4,(L),12]	  ;GET THE USER SUPPLIED ARG TYPE
	LDB	G3,[POINT 8,(L),8] ;GET THE FUNCTION CODE
	LDB	G2,[POINT 3,OP.DSP(G3),8] ;GET THE ARGUMENT TYPE
	CAILE	G2,SCNSIX-SCNNER	;COMPARE THE ARGUMENT
	CAIN	T5,TP%LIT	;AGAINST THE USER'S SUPPLIED
	PUSHJ	P,SCNNER(G2)	;YES, CONVERT TO SIXBIT
	PUSHJ	P,@OP.DSP(G3)	;GO TO SWITCH ROUTINE
	JRST	OPEN1		;GET NEXT PARAMETER

OPEN3:	JUMPE	P3,OPEN4		;WAS THERE A DIALOG ARGUMENT
	TLO	P2,OP.OPN	;SET THE FILE SCAN SWITCH
	PUSHJ	P,SCNSWT	;GET THE ARGUMENT
	TLNN	P3,IO.TTA	;USER'S TTY
	PUSHJ	P,RELE%1	;NO, DELETE THE DIALOG BLOCK
	SETZ	P3,		;CLEAR THE DEVICE POINTER
OPEN4:	TLZN	P2,OP.ERR	;WAS THERE AN ERROR
	JRST	OPEN5		;NO, GO OPEN THE DEVICE
OPEN4A:	SKIPGE	JOB.SV(P4)	;BATCH JOB
	ERROR	(SYS,4,17,)	;EXIT THE SYSTEM
	MOVE	P3,CHN.TB+20(P4);YES, GET THE TTY CHANNEL
	TLZ	P3,IO.INO	;SET INPUT MODE
	TLO	P2,OP.OPN	;SET FILE SCANNING
OPEN4B:	SETZ	T2,		;CLEAR THE DELIMITER SWITCH
	OUTSTR	[ASCIZ /
Enter new file specs. End with a $
*/]
	PUSHJ	P,IBLOK2	;FLUSH THE INPUT BUFFER
	PUSHJ	P,SCNSWT	;PICK UP THE SWITCHES
	TLZE	P2,OP.ERR	;ANOTHER ERROR
	JRST	OPEN4B		;YES, TRY AGAIN
OPEN5:	MOVEI	P3,(P2)		;SET OP TO OPEN THE DEVICE
	PUSHJ	P,OPEND		;OPEND THE DEVICE
	POPJ	P,		;DEVICE IS OK
	MOVEI	P2,(P3)		;ERROR DURING OPEN
	JRST 	OPEN4A		;TRY AGAIN
	
	SUBTTL ROUTINES TO OPEN THE DEVICE AND ASSIGN BUFFERS
OPEND:
	SKIPN	T1,DD.DEV(P3)	;GET THE DEVICE NAME
	HRRZ	T1,DD.UNT(P3)	;NO DEVICE SPECIFIED, GET FLU
	PUSHJ	P,GETDV.	;GET THE DEVICE SPECS
	MOVEM	G1,DD.DEV(P3)	;STORE THE FAULTY DEVICE NAME
	JUMPN	G3,OPEND3	;DEVICE EXISTS
	ERROR	(OPN,6,7,OPENER);NO, SUCH DEVICE
OPEND3:	MOVEM	G3,DD.STS(P3)	;SAVE THE DEVCHR BITS (SAVES TIME)
	MOVEM	G2,DD.DEV(P3)	;SAVE THE PHYSICAL DEVICE NAME
	TLNN	G3,DV.AVL	;IS THE DEVICE AVAILABLE
	ERROR	(OPN,5,7,OPENER);NO,ERROR GO TO DIALOG 
	LDB	G4,[POINT 6,DD.BLK(P3),5] ;GET THE ACCESS INDEX
	HRLZ	G4,ACC.DP(G4)	;GET THE ACCESS BITS
	TLNN	G4,IO.SIN!IO.SOU;IS A I/O DIRECTION SPECIFIED
	ERROR	(OPN,3,7,OPENER);NO, FATAL ERROR
	TLNN	G4,IO.SIN	;IS INPUT REQUIESTED
	TLO	P3,IO.INO	;NO, SET OUTPUT MODE
	MOVSI	T1,7		;SET UP A MASK
	AND	T1,G4		;GET A COPY OF THE DEVICE CHARASTICS
	IOR	P3,T1		;SET THE ACCESS IN P3
	TDZ	T1,G3		;MATCH THE I/O REQUIREMENTS
	TLNE	G4,IO.RAN	;RANDOM ACCESS FILES REQUIRE A DISK
	TLNE	G3,DV.DSK	;YES, MUST BE A DISK TYPE DEVICE
	TLNE	T1,DV.IN!DV.OUT ;CAN THE DEVICE PREFORM THE NEEDED I/O
	ERROR	(OPN,2,7,OPENER)	;NO, DEVICE CAN NOT PREFORM I/O
	TRNN	G3,DV.ASP	;IS DEVICE ASSIGND BY PROGRAM
	JRST	OPEND2		;NO, CONTINUE
	MOVSI	T2,-20		;SET UP AN AOBJP T2,POINTER
	HRRI	T2,CHN.TB(P4)	;TO THE CHANNEL TABLE
	AOBJP	T2,OPEND2	;NOT IN THE TABLE
	SKIPE	T1,(T2)		;IS THE CHANNEL DEFINED
	CAME	G2,DD.DEV(T1)	;AND POINTED TO BY THIS DEVICE
	JRST	.-3		;NO, LOOK AT THE NEXT ENTRY
	PUSH	P,T1		;YES, SAVE THE DD POINTER
	PUSHJ	P,RELE%1	;RELEASE THIS BLOCK
	POP	P,P3		;SET UP P3 WITH THE DD.BLK POINTER
OPEND1:	HLRZ	T1,DD.UNT(P3)   ;GET THE PSEUDO CHANNEL
	LSH	T1,-5		;POSITION PSEUDO CHANNEL
	DPB	T1,FLU.BP(P4)	;POINT FLU TO THE CHANNEL TABLE
	POPJ	P,		;RETURN


OPEND2:	JSP	P1,OPENDM	;DEFINE THE MODE IN THEDD.BLK
	ERROR	(OPN,1,7,OPENER)	;ILLEGAL MODE FOR DEVICE

	TLNE	G3,DV.TTA	;IS THIS THE USER'S TTY
	JRST	[PUSHJ P,RELE%1	;YES DEALLOCATE THE DDB
		MOVE	P3,CHN.TB+20(P4) ;GET THE TTY CHANNEL
		JRST	OPEND1]	;SET UP THE CHANNEL TABLE
	MOVE	G2,DD.DEV(P3)	;GET THE DEVICE NAME
	DEVTYP	G2,		;GET THE DEVICE TYPE BITS
	SETZ	G2,		;UUO NOT IMPLEMENTED
	TLNE	G2,TY.INT	;IS DEVICE INTERACTIVE
	TLO	P3,IO.INT	;YES, SET INTERACTIVE BITS
	TLNE	G2,TY.SPL	;IS DEVICE BEING SPOOLED
	TLO	G3,DV.DSK	;YES, SET THE DISK BITS

	TLNE	G3,DV.IN	;INPUT MODE REQUESTED
	HRRI	T1,DD.HRI(P3)	;YES, SET POINTER TO INPUT RING
	TLNE	G3,DV.OUT	;OUTPUT MODE REQUESTED
	HRLI	T1,DD.HRO(P3)	;SET POINTER TO OUTPUT RING HEADER
	MOVEM	T1,DD.RNG(P3)	;PUT POINTER IN OPEN BLOCK

	HLL	T1,DD.UNT(P3)	;GET THE CHANNEL NUMBER
	TLO	T1,(OPEN)	;SET OPEN UUO IN T1
	HRRI	T1,DD.OPN(P3)	;SET POINTER TO OPEN ARGS
	XCT	T1		;OPEN THE UNIT
	ERROR	(OPN,5,7,OPENER);DEVICE NOT AVAILABLE
	TLNN	G3,DV.DIR	;DIRECTORY DEVICE
	JRST	OPEND5		;NO, IGNORE LOOKUP/ENTER
	PUSHJ	P,FILDFT	;CHECK ON FILE NAME
	TLNN	G3,DV.DTA	;IS THIS A DEC TAPE UNIT
	JRST	OPEND4		;MUST BE A DISK OF SOME SORT
	SKIPN	T1,DD.PPN(P3)	;WAS A PPN SPECIFIED
	JRST	.+4		;NO, DON'T WORRY ABOUT IT
	TLZN	T1,-1		;YES, CHECK FOR A SFD'S LIST
	PUSHJ	P,GET12		;YES, RETURN SFD LIST TO FREE CORE
	SETZM	DD.PPN(P3)	;CLEAR THE PPN POINTER FOR DECTAPE
OPEND4:	MOVEI	T1,DD.ALC-DD.CNT ;SET ARG BLOCK SIZE FOR LOOKUP/ENTER
	MOVEM	T1,DD.CNT(P3)	;PUT COUNT IN DD.BLK


;	ROUTINE TO DO ENTERS/LOOKUPS ON THE DSK TYPE DEVICE

FILOPN:	TLNN	G4,IO.RAN!IO.SIN;CHECK FOR SEQOUT MODE
	JRST	FILOP2		;YES, PROCESS SPEERATELY
	JSP	P1,LOOKU.	;DO A LOOKUP(SEQIN,SEQINOUT,RANDOM,APPEND)
	JRST	FILOP3		;FILE NOT FOUND,  CHECK IF FATAL
	TLNE	G4,IO.SOU	;CHECK FOR APPEND OR RANDOM ACCESS
	TLNN	G4,IO.RAN	;RANDOM ACCESS OF APPEND
	JRST	FILOP4		;NO, MUST BE SEQIN OR RANDIN ALL DONE
	JSP	P1,ENTER.	;DO AND ENTER (UPADTE MODE)
	ERROR	(OPN,0,7,OPENER)	;BAD (CAN DO LOOKUP BUT NO ENTER)
				;MUST BE READ ONLY FILE
	TLNE	G4,IO.SIN	;RANDOM MUST HAVE A RECORD LENGTH
	SKIPE	DD.LOG(P3)	;CHECK ON LOGICAL RECORD SIZE
	JRST	FILOP4		;IT IS THERE  ALL DONE 
	ERROR	(OPN,12,6,OPENER) ;TELL THE USER TO ENTER A LOG SIZE

FILOP3:	TLNN	G4,IO.SOU	;IS OUTPUT LEGAL
	ERROR	(OPN,0,6,OPENER);NO, FILE NOT FOUND
	JSP	P1,ENTER.	;RANDOM ACCES CREATE A FILE
	ERROR	(OPN,0,7,OPENER);CANT ENTER A FILE
	HLLZ	T1,DD.UNT(P3)	;GET THE CHANNEL NUMBER
	TLO	T1,(CLOSE)	;SET UP TO CLOSE THE DUMMY FILE
	XCT	T1		;CLOSE THE DUMMY FILE
	TLO	P3,IO.INO	;SET OUTPUT LAST FLAG
	JRST	FILOPN		;START OVER WITH A FILE

FILOP2:	JSP	P1,ENTER.	;SEGOUT MODE JUST DO ENTER
	ERROR	(OPN,0,7,OPENER);CANT ENTER A FILE
;	JRST	FILOP4		;FALL THROUGH
FILOP4:		;END OF LOOKUP/ENTER ROUNTINE

;;	ALOCATE BUFFERS FOR THE DEVICE INCREASE BUFF COUNT FOR
;;	FIXED LENGTH RECORDS IN REQUIRED

OPEND5:	MOVEI	T4,DD.OPN(P3)	;GET POINTER FOR DEVSIZ UUO
	DEVSIZ	T4,		;GET THE DEFAULT BUFFERCOUNT,,BUFFER SIZE
	ERROR	(SYS,3,17,)	;MUST HAVE THE DEVSIZ UUO (ALWAYS)
	MOVE	G1,DD.BUF(P3)	;GET THE USER'S COUNT,,SIZE
	TRNE	G1,-1		;BUFFER SIZE SPECIFIED?
	TLNN	G2,TY.VAR	;DOES DEVICE SUPPORT VARIABLE BUFFERS
	HRR	G1,T4		;NO, SET MONITOR DEFAULT
	TLNN	G1,-1		;USER SUPPLIED BUFFER COUNT
	HLL	G1,T4		;NO, USE MONITOR DEFAULT (2)
OPEND6:	MOVEM	G1,DD.BUF(P3)	;SAVE THE BUFCNT,,BUFSIZ
	PUSHJ	P,ALCBUF	;ALLOCATE THE BUFFER RING
	HRRI	T2,-2(T1)	;MAKE A CORE BLOCK POINTER
	HRRM	T2,-1(P3)	;LINK BUFFERS TO DD.BLK
	HRLI	T1,400000	;SET THE USE BIT ON (BUFFERS ALLOCATED)
	TLNE	G3,DV.IN	;CAN DEVICE DO INPUT
	MOVEM	T1,DD.HRI(P3)	;SET POINTER TO BUFFER RING (INPUT)
	TLNE	G3,DV.OUT	;CAN DEVICE DO OUTPUT
	MOVEM	T1,DD.HRO(P3)	;SET POINTER TO BUFFER RING (OUTPUT)
	TLNN	G3,DV.TTA!DV.TTY	;USER'S TTY
	JRST	OPEND8		;NO, SINGLE RINGS O/K
	EXCH	T1,(T1)		;REALLOCATE THE TWO BUFFERS
	MOVEM	T1,(T1)		;INTO TWO SINGLE BUFFER RINGS
	HRRM	T1,DD.HRO(P3)	;SET UP THE OUTPUT RING HEADER
	TLNN	G3,DV.TTA	;USER'S TTY
	JRST	OPEND8		;NO, SLAVE TTY
	HRLI	T1,(POINT 7)	;ASCII
	ADDI	T1,1		;POINT TO THE DATA AREA
	MOVEM	T1,DD.HRO+1(P3)	;PUT IN RING HEADER
	SETZM	DD.HRI+2(P3)	;CLEAR THE BYTE COUNTER
	MOVEM	P3,CHN.TB+20(P4)	;DEFINE THE TTY CHANNEL
	POPJ	P,		;RETURN
OPEND8:	TLC	G4,IO.RAN!IO.SOU	;CHECK FOR APPEND
	TLCE	G4,IO.RAN!IO.SIN!IO.SOU
	JRST	OPEND9		;NO, 
	MOVE	T1,DD.SIZ(P3)	;GET THE TOTAL SIZE OF THE FILE(WORDS)
	IDIVI	T1,200		;CONVERT TO BLOCKS AND WORD
	ADDM	T2,DD.HRO+1(P3)	;UPDATE THE BYTE POINTER TO NEXT AVAIL
	ADDI	T2,-200		;FIND THE NUMBER OF WORDS LEFT IN THE BUFFER
	IMULI	T2,-5		;CONVERT TO CHARACTERS
	HRRZM	T2,DD.HRO+2(P3)	;SAVE IN RING HEADER
	HLLO	T1,DD.UNT(P3)	;SET UP CHANNEL FOR USETO (LAST BLOCK)
	TLO	T1,(USETO)	;SET UUO IN T1
	XCT	T1		;EXECUTE THE USETO CHN,-1
OPEND9:	JUMPI	.+3		;JUMP ON INPUT
	TLNN	P3,IO.RAN	;RANDOM ACCESS
	PUSHJ	P,OBLOK.	;DO A DUMMY OUTPUT
	TLNE	G3,DV.TTY!DV.TTA!DV.LPT	;CHECK FOR FORM CONTROL
	TLO	P3,IO.CCC	;SET FORMS FLAG
	HLRZ	T1,DD.UNT(P3)	;GET THE CHANNEL NUMBER
	LSH	T1,-5		;POSITION THE CHANNEL NUMBER
	DPB	T1,FLU.BP(P4)	;PUT TH CHANNEL IN THE FLU TABLE
	ADDI	T1,CHN.TB(P4)	;RELOCATE TO THE CHANNEL TABLE
	TLO	P3,IO.OPN	;SET FILE OPEN
	MOVEM	P3,(T1)		;SAVE THE I/O REG IN THE CHANNEL TABLE
	TLNN	G3,DV.MTA	;IS THIS A MAG TAPE
	SKIPN	T1,DD.RLS(P3)	;CHECK FOR A REELS PARAMETER
	POPJ	P,		;RETURN
	PJRST	GET12		;YES, DELETE THE REELS ARRAY



OPENER:	HLLZ	T1,DD.UNT(P3)	;GET THE CHANNEL NUMBER
	TLO	T1,(RELEAS)	;GET A RELEASE UUO
	XCT	T1		;DELETE ALL MONITOR REFERENCES
	HRRZ	T1,-1(P3)	;GET THE BUFFER LINK POINTER
	JUMPE	T1,.+3		;ARE BUFFERS ASSIGNED
	HLLZS	-1(P3)		;CLEAR THE LINK POINTER
	PUSHJ	P,GET13		;DELETE THE BUFFERS
	AOS	(P)		;SKIP ON ERROR RETURN
	POPJ	P,		;TAKE THE ERROR RETURN
	SUBTTL ALCXXX GENERAL ROUTINES TO ACCESS AND DEFINE DD.BLK AREAS

ALCBUF:	PUSH	P,G2		;SAVE GLOBAL G2
	HLRZ	G2,G1		;LOAD THE BUFFER COUNT
	PUSH	P,G1		;SAVE THE CONTROL WORD
	HRLZI	G1,-2(G1)	;GET THE TRUE BUFFER SIZE
	HRRZ	T0,(P)		;GET THE SIZE OF THE CORE BLOCK
	PUSHJ	P,GETOWN	;ALLOCATE THE CORE BLOCK
	HRRI	G1,1(T1)	;SET G1 TO THE SECOND WORD OF THE RING HEADER
	PUSH	P,G1		;SAVE THE INITIAL POINTER TO THE RING
	SOJLE	G2,ALCBU2	;CHECK FOR SINGLE BUFFERING
ALCBU1:	HRRZ	T0,-1(P)	;GET THE CORE BLOCK SIZE
	PUSHJ	P,GETOWN	;GET ANOTHER CORE BLOCK
	MOVEM	G1,1(T1)	;SET THE SECOND WORD OF THE RING HEADER
	SUBI	T1,1		;POINT TO THE LINK WORD IN THE CORE LIST
	HRRM	T1,-2(G1)	;LINK THE CORE BLOCK TOGETHER
	HRRI	G1,2(T1)	;CREATE THE NEXT RING POINTER
	SOJG	G2,ALCBU1	;BACK FOR ANOTHER BUFFER
ALCBU2:	POP	P,T1		;GET THE INITIAL RING POINTER
	MOVEM	G1,(T1)		;LINK THE BUFFER IN A RING
	POP	P,G1		;RESTORE THE ARGUMENT WORD
	POP	P,G2		;RESTORE GLOBAL G2
	POPJ	P,0		;RETURN


;	GENERAL LOOKUP/ENTER ROUTINES FOR DECTAPE AND DSK

RENAM.:	MOVE	T1,[RENAME 0,DD.CNT(P3)]	;GET THE RENAME  UUO
	JRST	ENTER.+1
LOOKU.:	SKIPA	T1,[LOOKUP 0,DD.CNT(P3)]	;GET LOOKUP FOR DSK
ENTER.:	MOVE	T1,[ENTER 0,DD.CNT(P3)]	;GET ENTER FOR DSK
	HLLZS	DD.EXT(P3)	;CLEAR THE ERROR BITS
	HLLZ	T0,DD.UNT(P3)	;GET THE CHANNEL NUMBER (BITS 9-12)
	IOR	T1,T0		;PUT CHANNEL NUMBER IN UUO
	TLNN	G3,DV.DSK	;IS THIS A DSK(EXTENDED LOOKUP/ENTER)
	ADDI	T1,DD.NAM-DD.CNT;LEVEL C OR NOT DSK(USE STANDARD LOOKUP)
	XCT	T1		;DO THE UUO
	SKIPA	T1,DD.EXT(P3)	;GET THE ERROR CODE IN T1
	JRST	1(P1)		;OK RETURN
	TRNE	T1,-1		;CHECK FOR FILE NOT FOUND
	ERROR	(OPN,0,7,OPENER);SOMETHIN ELSE ERROR RETURN TO TRY AGAIN
	JRST	(P1)		;TAKE FILE NOT FOUND RETURN

;DEFINE THE MODE OF THE FILE

OPENDM:	LDB	T5,[POINT 6,DD.BLK(P3),11] ;GET THE MODE INDEX
	HLRZ	T4,MOD.DP(T5)	;GET THE OPEN MODE
	ANDI	T4,17		;MAKE IN 4 BITS WIDE
	MOVEI	T3,1		;MAKE A 1 BIT MASK
	LSH	T3,(T4)		;POSITION THE BIT FOR MODE CHECK
	TDNN	T3,DDP3)	;IS THE MODE LEGAL
	JRST	(P1)		;TAKE ERROR RETURN
	MOVEI	T3,17		;GET A 4 BIT MASK
	ANDCAM	T3,DD.OPN(P3)	;CLEAR THE MODE FIELD
	IORM	T4,DD.OPN(P3)	;YES, LEGAL MODE STORE FOR OPEN
	CAIGE	T5,MOD.FM	;IS THE MODE REQUESTE FORMATED
	TLO	P3,IO.FMT	;YES, SET FORMATED I/O MODE
	CAIE	T5,MOD.AS-MOD.DP;ASCII MODE
	CAIN	T5,MOD.BN-MOD.DP;OR BINARY
	TLZA	P3,IO.NON	;YES, CLEAR NON- STANDARD MODE
	TLO	P3,IO.NON	;NON-STANDARD MODE REQUEST
	JRST	1(P1)		;RETURN TO CALLER
	SUBTTL OPEN DIALOG MODE ROUTINE
SCNSWT:	SETZ	G3,		;CLEAR THE SWITCH INDEX
	JUMPN	T2,SCNSW0	;IS THERE A DELIMETER PENDING
SCNSWZ:	PUSHJ	P,SCNSIX	;NO, GO GET SOMETHING
	JUMPE	T1,SCNSW0	;GO CHECK FOR A SWITCH
	MOVEI	G3,INXNAM	;ASSUME A FILE NAME
	TRZE	T2,1B':'	;IS THIS A DEVICE
	MOVEI	G3,INXDEV	;YES, PROCESS THE DEVICE NAME
	JRST	SCNSW6		;DATAM IS IN  AC T1
SCNSW0:	TLZE	T2,(1B'/')	;IS THIS A SWITCH
	JRST	SCNSW1		;YES, PROCESS THE SWITCH
	TLZE	T2,400000	;CHECK FOR END
	POPJ	P,
	TRZE	T2,1B'<'	;CHECK FOR A PROTECTION CODE
	MOVEI	G3,INXPRV	;YES, GO TO PROTECTION ROUTINE
	TRZE	T2,1B19		;NO,CHECK FOR A [ PPN,SFD]
	MOVEI	G3,INXPPN	;YES GO PROCESS THE PPN,SFD
	JUMPN	G3,SCNSW5	;PROCESS THE PSEUDO SWITCH
	JRST	SCNSWZ		;GARBAGE IN THE STRING (IGNORE IT)

SWTERR:	TLO	P2,OP.ERR	;SET ERROR FOUND FLAG
	ERROR	(OPN,11,7,CPOPJ)

SCNSW1:	TLNE	P2,OP.DIA	;SWITCH STOP THE DIALOG ARGUMENT SCAN
	POPJ	P,		;RETURN
	PUSHJ	P,SCNFIV	;GET THE SWITCH ID
	TRZN	T2,1B'='!1B':'	;SWITCH MUST BE TERMINATES BY AN =
	JRST	SWTERR		;SWITCH ERROR INCORRECT TERMINATOR
	SETO	T3,		;SET UP A MASK
	LSH	T3,-5		;SHIFT MASK
	TDNE	T1,T3		;CHECK MASK AGAINST SIGNIFICANT BYTES
	JUMPN	T3,.-2		;RETRY THE MASK TEST
SCNSW2:	MOVSI	T4,-OP.MAX	;GET SWITCH TABLE SIZE
	MOVE	T5,OP.SWT(T4)	;SEARCH TABLE FOR DEFINED SWITCHES
	ANDCAM	T3,T5		;REDUCE THE SWITCH TO USER LENGTH
	CAME	T5,T1		;IS THIS THE SWITCH
SCNSW3:	AOBJN	T4,.-3		;REDUCE COUNT AND CONTINUE SEARCH
	JUMPGE	T4,SCNSW4	;END OF LIST CHECK RESULTS
	SKIPE	T2		;HAVE WE SEEN A ABRIV. SWITCH
	SETO	T2,		;YES, SET MULTI SWITCH FLAG
	HRRI	T2,(T4)		;SAVE SWITCH INDEX IN ANY CASE
	CAME	T1,OP.SWT(T4)	;EXACT MATCH
	JRST	SCNSW3		;NO CONTINUE
	ANDI	T2,-1		;YES, CLEAR THE MULTI SWITCH FLAG
SCNSW4:	SKIPG	G3,T2		;IS THERE A VALID SWITCH (UNIQUE)
	JRST	SWTERR		;NO,ERROR
SCNSW5:	LDB	G2,[POINT 3,OP.DSP(G3),8] ;LOAD THE SCANNER TYPE
	PUSHJ	P,SCNNER(G2)	;GET THE ARGUMENT FOR THE SWITCH
SCNSW6:	PUSHJ	P,@OP.DSP(G3)	;PROCESS THE ARGUMENT
	JRST	SCNSWT		;PROCESS NEXT SWITCH
	SUBTTL OPNXXX SWITCH PROCESSING ROUTINES
OPNDEV:
	MOVEM	T1,DD.DEV(P2)	;SAVE THE DEVICE NAME
	POPJ	P,		;RETURN TO THE SWITCH SCANNER

OPNBUF:
	HRLM	T1,DD.BUF(P2)	;SAVE THE BUFFER COUT
	POPJ	P,		;RETURN TO THE SWITCH SCANNER

OPNBLK:
	ADDI	T1,3		;ALLOCATE SPACE FOR BUFFER HEADER
	HRRM	T1,DD.BUF(P2)	;SAVE THE BLOCK SIZE
	POPJ	P,		;RETURN TO THE SWITCH SCANNER

OPNNAM:
	JUMPL	P2,OPNNA1	;JUMP IF READING A FILE
	CAIGE	T5,TP%DOR	;TWO WORD OR MORE ARGUMENT
	ANDCMI	T1,77		;NO, KILL THE LOW ORDER CHARACTER
OPNNA1:	MOVEM	T1,DD.NAM(P2)	;SAVE THE FILE NAME
	MOVSI	T1,(SIXBIT /DAT/);DEFAULT EXTENSION
	TLZE	T2,(1B'.')	;IS THERE AN EXTENSION FOLLOWING
	PUSHJ	P,SCNSIX	;YES, GET THE EXTENSION
	HLLZM	T1,DD.EXT(P2)	;SAVE THE EXTENSION
	POPJ	P,		;RETURN TO THE SWITCH SCANNER

OPNPPN:
	TLNN	P2,OP.OPN	;DIALOG MODE
	CAIN	T5,TP%LIT	;LITERAL TYPE
	JRST	OPNPP2		;YES, TREAT AS DIALOG MODE
	SKIPN	G2,T1		;DEFAULT PPN
	JRST	OPNPP3		;YES
	TLNE	G2,-1		;PROJECT NUMBER IN THE LEFT
	JRST	OPNPP3		;YES, PPN IS OK
	HRL	G2,T1		;NO, PUT PROJ NUMBER IN LEFT
	HRR	G2,1(G1)	;PUT PROGRAMMER  NUMBER IN RIGHT HALF
	AOS	G1		;UPDATE POINTER
OPNPP3:	AOJA	G1,OPNPP4	;UPDATE POINTER
OPNPP2:	JUMPE	T2,SWTERR	;NOT AN OCTAL NUMBER QUIT
	TLZN	T2,(1B',')	;CHECK FOR A COMMA
	JRST SWTERR		;NO COMMA, ERROR
	HRLZ	G2,T1		;SAVE THE PROJECT NUMBER
	PUSHJ	P,SCNOCT	;GET THE PROGRAMMER NUMBER
	JUMPE	T2,SWTERR	;NOT AN OCTAL NUMBER
	HRR	G2,T1		;SAVE PROGRAMMER NUMBER
OPNPP4:	SKIPN	T1,DD.PPN(P2)	;GET THE POINTER WORD
	HRLI	T1,-1		;CORE BLOCK NOT AVAILABLE
	TRZN	T2,1B21		;RIGHR BRACKET TERMINATOR (OR END)
	JUMPGE	T2,OPNPP5	;NO, CHECK FOR SFD'S
	TLNN	T1,-1		;PPN OR CORE POINTER
	PUSHJ	P,GET12		;CORE POINTER DELETE CORE BLOCK
	MOVEM	G2,DD.PPN(P2)	;SAVE THE PPN
	SETZ	T2,		;CLEAR THE FLAG WORD
	POPJ	P,		;RETURN

OPNPP5:	MOVEI	T0,^D10		;GET TEN WORD TO STORE THE SFD'S
	TLNE	T1,-1		;CHECK FOR A CORE POINTER OF PPN
	PUSHJ	P,GETOWN	; PPN, GET DYNAMIC CORE
	HRRZM	T1,DD.PPN(P2)	;SAVE SFD POINTER
	MOVEM	G2,2(T1)	;SAVE PPN
	MOVEI	G2,3(T1)	;SET UP THE POINTER TO THE SFD LIST
	HRLI	G2,-10		;MAE AN AOBJN POINTER
	PJRST	SCNSTR		;GET THE ID FIELD FORM SCNSTR

OPNPR1:	PUSHJ	P,SCNOCT
OPNPRV:	SKIPGE	P2		;DIALOG MODE
	JUMPE	T2,SWTERR	;YES, NOT AN OCTAL NUMBER
	ROT	T1,-11		;POSITION THE PROTECTION CODE
	MOVEM	T1,DD.PRV(P2)	;SAVE PROTECTION CODE
	TRZ	T2,1B'>'	;CHECK THE TERMINATOR
	POPJ	P,		;JUST RETURN

OPNEST:
	MOVEM	T1,DD.EST(P2)	;SAVE ESTIMATED FILE SIZE
	POPJ	P,		;RETURN

OPNREC:
	MOVNM	T1,DD.LOG(P2)	;SAVE THE LOGICAL RECORD LENGTH
				;SET NEGATIVE DON'T KNOW (CHAR/WORD)
	POPJ	P,		;RETURN

OPNVER:
	MOVEM	T1,DD.VER(P2)	;SAVE THE VERSION VUMBER
	POPJ	P,		;RETURN

OPNRLS:
	MOVEI	T0,^D12		;NO, ASK FOR DYNAMIC CORE
	SKIPN	T1,DD.RLS(P2)	;HAS SPACE BEEN ALLOCATED FOR REELS
	PUSHJ	P,GETOWN	;GET DYNAMIC CORE FOR REELS ARRAY
	HRRZM	T1,DD.RLS(P2)	;SAVE THE ADDRESS OF THE ARRAY
OPNRL1:	MOVEI	G2,(T1)		;GET THE ADDRESS
	HRLI	G2,-^D11	;MAKE AN AOBJN POINTER TO THE REELS BLOCK
	PJRST	SCNSTR		;GET THE ID FIELDS FOR SCNSTR
				; T1 = THE FIRST REEL ID

OPNLIM:
	MOVEM	T1,DD.LIM(P2)	;SAVE IN DD BLOCK
	POPJ	P,		;RETURN

OPNASC:
	HRRZM	G1,DD.ASC(P2)	;SAVE THE ASSOCIATE VARIABLE ADDRESS
	POPJ	P,		;RETURN

OPNERV:
	HRRZM	G1,DD.ERV(P2)	;SAVE THE ERROR VARIABLE ADDRESS
	POPJ	P,		;RETURN
OPNUNT:
	POPJ	P,		;RETURN

OPNACC:				;DEFINE THE ACCESS METHOD
	MOVSI	T3,-ACC.SZ	;GET THE TABLE SIZE
	CAME	T1,ACC.TB(T3)	;LOOKUP THE ACCESS TYPE
	AOBJN	T3,.-1		;CONTINUE LOOKING
	JUMPGE	T3,SWTERR	;UNDEFINE ACCES METHOD
	DPB	T3,[POINT 6,DD.BLK(P2),5] ;STORE THE ACCESS POINTER
	POPJ	P,		;RETURN

OPNMOD:		;DEFINE THE FILE MODE AND ACCESS
	MOVSI	T3,-MOD.SZ	;GET THE MODE TABLE SIZE
	CAME	T1,MOD.TB(T3)	;LOOK UP THE MODE ENTRY
	AOBJN	T3,.-1		;CONTINUE LOOKING
	JUMPGE	T3,SWTERR	;NOT IN THE TABLE (ERROR)
	DPB	T3,[POINT 6,DD.BLK(P2),11] ;STORE THE MODE INDEX
	POPJ	P,		;RETURN

OPNDIA:			;DILOG ROUTINE TO CHANGE THE INPUT DEVICE
			;FOR OPEN STATEMENT ARGUMENTS
	SKIPE	T1,P3		;IS A BLOCK ASSIGNED
	TLNE	P3,IO.TTA	;AND THE USR'S TTY
	JRST	.+2		;NO,
	PUSHJ	P,GET12		;YES, DELETE THE BLOCK
	PUSH	P,P2		;SAVE THE CURRENT DD.BLK POINTER
	MOVEI	T1,DDB.SZ	; ALLOCATE A 10 WORD BLOCK
	PUSHJ	P,GETOWN	;ALLOCATE IT
	MOVEI	P2,(T1)		;SET UP NEW POINTER TO DIALOG BLOCK
	MOVSI	T1,(SIXBIT /TTY/)	;DEFAULT DEVICE IS TTY
	MOVEM	T1,DD.DEV(P2)	;PUT IN DD.BLK OVERRIDDEN BY DIALOG
	TLO	P2,OP.DIA	;TELL SCAN LOOKING DIALOG ARGS
	PUSHJ	P,SCNSWT	;SCAN THE DIALOG ARGUMENT
	MOVEI	P3,(P2)		;SET THE DIALOG BLOCK IN P3
	PUSHJ	P,OPEND		;OPEN THE DIALOG BLOCK
	JRST	OPNDI2		;BLOK OPEN
	ERROR	(OPN,14,7,OPNDI1)	;ERROR IN DIALOG OPN
OPNDI1:	SETZ	P3,		;CLEAR THE DIALOG BLOCK
OPNDI2:	POP	P,P2		;RESTORE THE PRIMARY DD UNIT
	POPJ	P,		;RETURN TO THE SCANNER
	SUBTTL SCANNER ROUTINE FOR PPN AND REELS
SCNSTR:			;SPECIAL STRING SCANNER FOR REELS/PPN ROUTINES
	PUSHJ	P,SCNSIX	;GET THE ID NAME
	TLNN	P2,OP.OPN	;DIALOG MODE
	CAIN	T5,TP%LIT	;IS THIS A LTERAL STRING
	JRST	SCNST1		;YES, CONTINUE IN DIALOG MODE
	CAIL	T5,TP%DOR	;CHECK FOR DOUBLE PRECISION
	CAILE	T5,TP%COM	;OR COMPLEX
	TRZN	T1,77		;NO,SINGLE PRECISION ALLOW ON FIVE CHAR
	ADDI	G1,1		;UPDATE SRTING POINTER
	TLZ	G1,-1		;CLEAN UP THE BYTE POINTER
SCNST1:	MOVEM	T1,(G2)		;SAVE THE  ID NAME
	SKIPL	P2		;CHECK FOR SCANNER MODE
	SKIPE	(G1)		;CHECK FOR A NULL TERMINATOR
	TLZN	T2,(1B','!1B' ');COMMA OR BLANK
	TRZA	T2,1B21		;RIGHT BRACKET ]
	AOBJN	G2,SCNSTR	;GET NEXT ID ARG
SCNST2:	SETZM	1(G2)		;SET END OF ARRAY FLAG
	POPJ	P,		;RETURN
	SUBTTL TABLES FOR THE OPEN STATEMENT
OP.SWT::
	FIVBIT	(UNIT  )	;00 /UNIT=INTEGER
	FIVBIT	(DIALOG)	;01 /DIALOG=STRING
	FIVBIT	(ACCESS)	;02 /ACCESS=STRING
	FIVBIT	(DEVICE)	;03 /DEVICE=STRING
	FIVBIT	(BUFFERS)	;04 /BUFFER=INTEGER
	FIVBIT	(BLKSIZE)	;05 /BLOCK SIZE=INTEGER
	FIVBIT	(FILENAM)	;06 /FILE NAME=STRING.STRING
	FIVBIT	(PROTECT)	;07 /PROTECTION=OCTAL
	FIVBIT	(DIRECT)	;10 /DIRECTORY=OCTAL,OCTAL,STRING,,,
	FIVBIT	(LIMIT )	;11 /LIMIT=INTEGER
	FIVBIT	(MODE  )	;12 /MODE=STRING
	FIVBIT	(FILESIZ)	;13 /FILE SIZE=INTEGER
	FIVBIT	(RECSIZ)	;14 /RECORD SIZE=INTEGER
	FIVBIT	(DISPOSE)	;15 /DISPOSE=STARING
	FIVBIT	(VERSION)	;17 /VERSION=INTEGER
	FIVBIT	(REELS )	;17 /REELS=STRING,STRING....
	FIVBIT	(MOUNT )	;20 /MOUNT=STRING
OP.MAX==.-OP.SWT			;MAXIUM TABLE SIZE
	DEFINE OPNARG(LABEL,CONTYP,TYPE)
<IFNDEF DD.'LABEL,<DDBINX==0>
IFDEF DD.'LABEL,<DDBINX==DD.'LABEL>
BYTE	(6)DDBINX(3)<SCN'CONTYP-SCNNER>(4)TP%'TYPE(5)0(18)OPN'LABEL
	INX'LABEL==.-OP.DSP-1>

OP.DSP::
	OPNARG	UNT,DEC,INT	;0	UNIT=	
	OPNARG	DIA,NER,LIT	;1	DIALOG=		/DIALOG=
	OPNARG	ACC,FIV,LIT	;2	ACCESS=		/ACCESS=ILLEGAL
	OPNARG	DEV,SIX,LIT	;3	DEVICE=		STRING:
	OPNARG	BUF,DEC,INT	;4	BUF COUNT=	/BUF COUNT=
	OPNARG	BLK,DEC,INT	;5	BLOCK SIZE=	/BLOCK SIZE=
	OPNARG	NAM,SIX,LIT	;6	FILE NAME=	STRING.STRING
	OPNARG	PRV,OCT,OCT	;7	PROTECTION=	/PROTECT= OR <NNN>
	OPNARG	PPN,OCT,OCT	;10	DIRECTORY=	/DIRECTORY OR [N,N,STRING]
	OPNARG	LIM,DEC,INT	;11	LIMIT=		/LIMIT=
	OPNARG	MOD,FIV,LIT	;12	MODE=		/MODE=
	OPNARG	EST,DEC,INT	;13	FILE SIZE=	/FILE SIZE=
	OPNARG	REC,DEC,INT	;14	RECORD SIZE=	/RECORD=
	OPNARG	DIS,FIV,LIT	;15	DISPOSE=	/DISPOSE=
	OPNARG	VER,OCT,OCT	;16	VERSION=	/VERSION=
	OPNARG	RLS,NER,LIT	;17	REELS=		/REELS=STRING,STRING,...
	OPNARG	MNT,SIX,LIT	;20	MOUNT=		/MOUNT=
	OPNARG	ERV,OCT,UDF	;21	ERROR=
	OPNARG	ASC,OCT,UDF	;22	ASSOCIATE VARIABLE=


OPNDIS:OPNMNT:
	POPJ	P,



MOD.TB::			;/MODE=STRING
	FIVBIT	(ASCII)		;0  /MODE=ASCII
	FIVBIT	(LINED)		;1  /MODE=LINED,INTEGER
	FIVBIT	(SIXBIT)	;2  /MODE=FIVBIT
	FIVBIT	(EBCDIC)	;3  /MODE=EBCDIC
	FIVBIT	(BCD)		;4  /MODE=BCD
	FIVBIT	(BINARY)	;5  /MODE=BINARY
	FIVBIT	(DUMP)		;6  /MODE=DUMP
	FIVBIT	(IMAGE)		;7  /MODE=IMAGE
MOD.SZ==.-MOD.TB


	DEFINE MODARG(BYTSIZ,MODE)<
	BYTE (6)0(6)BYTSIZ(2)0(4)MODE(18)0>

MOD.DP:				;DEFINE THE ACCESS MODE BITS
MOD.AS:	MODARG	7,0		;/ASCII
	MODARG	7,0		;/LINED
	MODARG	6,14		;/SIXBIT
	MODARG	8,14		;/EBCDIC
	MODARG	6,14		;/BCD
MOD.FM=.-MOD.DP		;DEFINE THE END OF THE FORMATED I/O MODES
MOD.BN:	MODARG	44,14		;/BINARY
	MODARG	44,17		;/DUMP
MOD.IM:	MODARG	(0,10)		;/IMAGE

ACC.TB::			;ACCESS TABLE
	FIVBIT	(SEQIN)		;SEQUENTAIL INPUT
	FIVBIT	(SEQOUT)	;SEQUENTAIL OUTPUT
	FIVBIT	(SEQINOU)	;SEQUENTAIL INPUT/OUTPUT
	FIVBIT	(RANDOM)	;RANDOM ACCESS
	FIVBIT	(RANDIN)	;RANDOM INPUT
	FIVBIT	(APPEND)	;APPEND MODE
ACC.SZ==.-ACC.TB		;ACCESS TABLE SIZE

ACC.DP:				;ACCESS FLAG BITS
	XWD	IO.SIN		;SEQ IN
	XWD	IO.SOU		;SEQ OUT
	XWD	IO.SIN!IO.SOU	;SEQ IN/OUT
	XWD	IO.RAN!IO.SIN!IO.SOU	;RANDOM INPUT.OUTPUT
	XWD	IO.RAN!IO.SIN		;RANDOM INPUT
	XWD	IO.RAN!IO.SOU		;APPEND OUTPUT
	SUBTTL	SCANNER ROUTINE TO SCAN AND CONVERT ASCII STRINGS
SCNNER:	POPJ	P,		;DUMMY ENTRY POINT
SCNFIV:	SKIPA	T2,[POINT 5]	;SET FIVBIT SCAN MODE
SCNSIX:	MOVSI	T2,(POINT 6)	;SET SIXBIT BYTE POINTER
	AOJA	T2,SCNCON	;SET BYTE POINTER TO T1 ADDRESS
SCNOCT:	SKIPA	T2,[10]		;SET OCTAL SCAN MODE
SCNDEC:	MOVEI	T2,12		;SET DECIMAL SCAN MODE
SCNCON:	SETZ	T1,		;CLEAR THE OUTPUT WORD
	JUMPL	P2,SCNSI0	;CHECK FOR MEMORY SCAN(DIALOG)
	TLNN	G1,-1		;IS AN ASCII POINTER VALID
	HRLI	G1,(POINT 7)	;NO, SET AN ASCII BYTE POINTER
SCNSI1:	JUMPGE	P2,SCNSI8	;G1=ARGUMENT ADDR FOR OPEN STATEMENT
				; OR A POINTER TO THE DIALOG BLOCK (DIALOG)
SCNSI0:	TLNE	P3,IO.EOL	;AT END OF LINE
	PUSHJ	P,NXTLNI	;YES, GET THE NEXT INPUT LINE
	JSP	P1,IBYTE.	;GET AN INPUT CHARACTER
	CAIE	T0,176		;CHECK FOR THE ALT MODES
	CAIN	T0,175		;AGAIN
	MOVEI	T0,33		;REPLACE WITH STANDARD ALT MODE
	CAIN	T0,33		;IS THIS AN ALTMODE
	SETZ	T0,		;CLEAR OUT THE CHARACTER
	JRST	SCNSI9		;NO CONTINUE
SCNSI8:	ILDB	T0,G1		;LOAD ASCII CHARACTER (OPEN ARGS)
SCNSI9:	JUMPE	T0,SCNSI7	;QUIT ON A NULL
	TRC	T0,140		;INVERT CONTROL AND SHIFT BITS
	TRNN	T0,140		;LOWER CASE ALPHA CHARACTER
	IORI	T0,40		;YES, SET TO UPPER CASE
	ANDCMI	T0,100		;SET TO SIXBIT AND CLEAR HIGH ORDER BIT
	CAIL	T0,'0'		;CHECK FOR CHARACTER RANGE
	CAILE	T0,'Z'		;IS THE A ALPHA NUMBERIC CHARACTER
	JRST	SCNSI2		;NO, CHECK FOR DELIMITER
	CAIGE	T0,'A'		;CHECK FOR ALPHA CHARACTER
	CAIG	T0,'9'		;CHECK FOR NUMBERIC
	JRST	SCNSI3		;YES ALPHA NUMBERIC CHARACTER
SCNSI2:	JUMPN	T0,SCNSI5	;CHECK FOR A BLANK CHARACTER
	JUMPE	T1,SCNSI1	;DIGIT, IGNORE LEADING BLANKS
	TLNE	T2,-1		;BLANK, CHECK FOR DIGIT OR ALPHA MODE
SCNSI6:	JUMPL	P2,SCNSI1	;ALHA-DIALOG, IGNORE BLANKS ALWAYS
SCNSI5:	CAILE	T0,'Z'		;IS DELIMITER IN THE 7X GROUP
	ANDCMI	T0,50		;YES PUT IN THE 2X GROUP
SCNSI7:	MOVSI	T2,400000	;MAKE A 1 BIT FLAG FOR THE DELIMITER
SCNSI4:	MOVN	T3,T0		;SET THE SHIFT COUNT
	LSH	T2,(T3)		;SET THE FLAG FOR THE DELIMITER
	POPJ	P,		;RETURN TO CALLER
SCNSI3:	TLNN	T2,-1		;CHECK FOR DIGIT MODE
	JRST	.+5		;YES, GO TO DIGIT ROUTINE
	TLNN	T2,760000	;ALPHA/DIGIT ANY ROOM FOR OUTPUT
	JRST	SCNSI6		;NO, IGNORE DIGIT/ALPHA
	IDPB	T0,T2		;YES, DEPOSITE BYTE
	JRST	SCNSI1		;RETURN FOR NEXT
	CAIL	T0,+20(T2)	;IS DIGIT IN RANGE (OCTAL/DECIMAL)
	JRST	SCNSI4		;NO, TREAT AS DELIMETER RETURN A ZERO
	IMULI	T1,(T2)		;IN RANGE MAKE ROOM FOR NEW DIGIT
	ANDI	T0,17		;MAKE A BINARY DIGIT
	ADD	T1,T0		;ACCUMULATE THE SUM
	JRST	SCNSI1		;RETURN FOR NEXT DIGIT
	SUBTTL		GENERAL ROUTINES TO SET,CLEAR AND SEARCH TABLES

;ROUTINE TO SEARCH THE FORTRAN LOGICAL UNIT TABLE AND RETURN IN
;(P3) THE CHANNEL CONTROL WORD.

SRCFLU:	SETZM	ERR.TB(P4)	;CLEAR THE ERROR RETURN ADDRESS
	SETZM	END.TB(P4)	;CLEAR THE EOF RETURN
	PUSH	P,P1		;SAVE THE RETURN ADDRESS
	JSP	P1,EFCTVL	;GET THE EFFECTIVE ADDRESS OF THE FLU
	HRRZI	T1,6(G1)	;CONVERT TO POSITIVE FLU
	JUMPN	T1,SRCFL0	;NOT A REREAD DEVICE
	SKIPN P3,RER.SV(P4)	;IS THERE A REREAD DEVICE
	ERROR	(DAT,12,10)	;NO, EXIT WITH MESSAGE
	AOS	(P)		;SET SKIP RETURN
	MOVE	G3,DD.STS(P3)	;GET THE DEVICE STATUS
	PJRST	BSREAD		;BACK UP A RECORD
SRCFL0:	CAILE	T1,FLU.MX+6	;IS THE FLU IN RANGE
	ERROR	(OPN,13,10,)	;NO, DIE
SRCFL1:	IDIVI	T1,^D6		;YES, SIX ENTRIES /WORD
	IMULI	T2,^D6		;NUMBER OF BITS LEFT
	ROT	T2,-^D6		;POSITION FOR THE BYTE POINTER
	IOR	T2,[POINT 6,FLU.TB(P4),35];SET THE SIZE FIELD
	ADDI	T2,(T1)		;POINT TO THE WORD ENTRY
	LDB	T1,T2		;LOAD THE CHANNEL INDEX
	MOVEM	T2,FLU.BP(P4)	;SAVE THE BYTE POINTER
	JUMPE	T1,CPOPJ	;FLU NOT ASSIGNED TO A CHANNEL
	ADDI	T1,CHN.TB(P4)	;SET THE OFFSET FOR CHANNEL CONTROL WD
	MOVE	P3,(T1)		;SETUP THE I/O REG
	POP	P,P1		;RESTORE P1
	JRST	1(P1)		;CHANNEL ASSIGNED T1=STATIC CORE POINTER


FLUSIX:				;CONVERT FORTRAN LOGICAL UNIT TO SIXBIT
	IDIVI	T1,12		;SEPERATE UNITS POSITION INTO T2
	LSH	T1,6		;SHIFT TWO OCTAL DIGITS
	ADDI	T1,2020(T2)	;CONVERT TO SIXBIT IN T1
	LSHC	T1,-^D12		;PUT SIXBIT FLU LEFT HALF ON T2
	JRST	(P1)		;RETURN T1=JUNK, T2=FLU IN SIXBIT


FILDFT:	SKIPE	T1,DD.NAM(P3)	;IS THERE A FILE NAME
	POPJ	P,		;YES, RETURN
	HRRE	T1,DD.UNT(P3)	;GET THE FORTRAN LOGICAL UNIT NUMBER
	JUMPGE	T1,.+2		;JUMP IF A +FLU
	SKIPA	T2,DEVTB.(T1)	;NO GET THE DEVICE NAME FOR A FILE NAME
	JSP	P1,FLUSIX	;CONVERT TO SIXBIT
	MOVSI	T1,(SIXBIT/FOR/);SET UP T1 WITH DEFAULT FILE NAME
	HLR	T1,T2		; AS FORXXX  XXX=FLU
	MOVEM	T1,DD.NAM(P3)	;PUT FILE NAME IN DD.BLK
EXTDFT:	SKIPE	T1,DD.EXT(P3)	;IS THERE AN EXTENSION
	POPJ	P,		;YES, RETURN
	MOVSI	T1,(SIXBIT /DAT/);NO, USE DAT AS A DEFAULT
	MOVEM	T1,DD.EXT(P3)	;PUT EXTENSION IN DD.BLK
	POPJ	P,		;RETURN

ALCHN%:	PUSHJ	P,SAVE.		;USER'S ENTRY TO GET A CHANNEL
	JSP	P1,GETCHN	;GO TO FOROTS (GETCHN) ROUTINE
	SETO	T1,		;NO CHANNELS AVAILABLE
	MOVEM	T1,@(L)		;STORE CHANNEL NUMBER OR ERROR FLAG
	POPJ	P,		;RETURN TO USER

GETCHN:				;FOROTS ENTRY TO ALLOCATE A CHANNEL
	MOVSI	T1,-20		;SET CHANNEL SEARCH COUNT
GTCH1:	ADDI	T1,CHN.TB(P4)	;SET SOFTWARE CHANNEL ORGIN
	AOBJP	T1,(P1)		;END OF SEARCH ..... NO CHANNEL
	SKIPE	(T1)		;IS THIS CHANNEL AVAILABLE
	JRST	.-2		;NO, CONTINUE SEARCH TO END
	SUBI	T1,CHN.TB(P4)	;RELOACTE T1 TO CHANNEL NUMBER
        MOVEI   T2,(T1)
        CAMLE   T2,JOBHCU##
        JRST    1(P1)           ;ITS OK
        SKIPE   JOBJDA##(T2)
        JRST    GTCH1           ;AVOID CONFLICT WITH OTHER FOLKS
	JRST	1(P1)		;RETURN TO CALLER

DECHN%:	PUSHJ	P,SAVE.		;USER'S ENTRY TO RELEASE A CHANNEL
	MOVE	T1,@(L)		;GET THE CHANNEL NUMBER
	CAIL	T1,20		;IS THE CHANNEL NUMBER LEGAL
	POPJ	P,		;RETURN TO USER (IGNORE REQUEST
	ADDI	T1,CHN.TB(P4)	;RELOCATE TO CHANNEL ENTRY
	SETCM	T0,(T1)		;TEST THAT USER REALLY HAS THE CHANNEL
	JUMPN	T0,.+2		;NO,IGNORE THE REQUEST
	JSP	P1,PUTCHN+1	;YES, GO TO FOROTS (PUTCHN) ROUTINE
	POPJ	P,		;RETURN TO USER (NO ERROR RETURN)

PUTCHN:				;FOROTS ENTRY TO RELEASE A CHANNEL
	ADDI	T1,CHN.TB(P4)	;RELOACTE TO CHANNEL TABLE
	SETZM	(T1)		;CLEAR THE CHANNEL ENTRY
	JRST	(P1)		;RETURN

GETDV.:			;GET THE PHYSICAL DEVICE AND CHARASTICS
	;T1 = SIXBIT DEVICE NAME 
	;OR   THE FORTRAN LOGCIAL UNIT NUMBER
	;RETURN
	;G3 = DEVCHR BITS
	;G2 = PHYSICAL DEVICE NAME
	;G1 = LOGICAL DEVICE NAME

	TLNE	T1,-1		;IS THIS A FLU
	JRST	GETDV2		;NO, A LOGICAL DEVICE NAME
	HRRES	T3,T1		;GET THE SIGN FOR DEFAULT DEVICES
	JUMPL	T1,GETDV1	;IS THIS A NEGATIVE DEFAULT
	JSP	P1,FLUSIX	;CONVERT FLU TO SIXBIT
	TLNN	T2,170000	;IS THE FLU LESS THAN 10
	LSH	T2,6		;YES KILL THE LEADING ZERO
	MOVE	G3,T2		;GET THE FLU FOR A LOGICAL DEVICE CHECK
	MOVE	G1,T2		;SET UP DEVICE NAME FOR PHYSICAL NAME
	DEVCHR	G3,		;GET THE DEVICE CHARASTICS
	JUMPN	G3,GETDV3	;THE DEVICE IS A LOGICAL NAME
GETDV1:	CAIG	T3,DEV.SZ	;IS THE FLU IN THE TABLE RANGE
	SKIPN	G1,DEVTB.(T3)	;GET THE DEVICE NAME
	MOVSI	G1,(SIXBIT /DSK/)	;NOT IN RANGE OR ZERO ENTRY
	JRST	.+2		;CONTINUE
GETDV2:	MOVE	G1,T1		;SET UP FOR A DEVCHR UUO
	MOVE	G3,G1		;SET UP THE PHYSICAL NAME UUO
	DEVCHR	G3,		;GET THE DEVICE BITS IN G3
GETDV3:	MOVE	G2,G1		;GET THE DEVICE NAME
	DEVNAM	G2,		;GET THE PHYSICAL DEVICE NAME
	JFCL			;IGNORE THE ERROR RETURN
	POPJ	P,		;RETURN

EFCTVL:
	MOVE	G1,(L)		;GET THE ARGUMENT POINTED TO BY (L)
EFCTV1:	HLRZ	T1,G1		;GET THE INDEX AND INDIRECT BITS
	ANDI	T1,17		;SAVE THE INDEX BITS
	JUMPE	T1,EFCTV2	;NO INDEXING
	ADDI	T1,ACC.SV(P4)	;RELOCATE TO THE SAVE AREA
	HRRZ	T1,(T1)		;GET THE CONTENTS ON THE INDEX REG
	ADDI	G1,(T1)		;GET THE NEW EFFECTIVE ADDRESS
EFCTV2:	TLZ	G1,777757	;CLEAR ALL EXCEPT THE INDIRECT BIT
	TLZN	G1,20		;INDIRECT BIT ON
	JRST	(P1)		;NO G1 IS THE EFFECTIVE ADDRESS
	TRNN	G1,-20		;IN THE AC SAVE AREA
	ADDI	G1,ACC.SV(P4)	;YES,RELOCATE
	MOVE	G1,(G1)		;YES, GO COMPUTE A NEW EFFECTIVE ADDRESS
	JRST	EFCTV1		;DO IT AGAIN


;ROUTINE TO COMPUT A FOLDED CHECKSUM IN T1
;THE WORD TO BE CHECK SUMMED IS IN G3
;THE FOLDED CHECK SUM IS RETRUN IN T1 BITS( 27-35) 9 BITS

IFN CHKSUM,<
CHKSM.:	HLRZ	T1,G3		;GET THE HIGH ORDER 18 BITS
	XORB	T1,G3		;CHECK SUM THE HIGH AND LOW ORDER
	LSH	T1,-^D9		;POSITION FOR A 9 BIT CHACKSUM
	XOR	T1,G3		;GET THE 9 BIT CHECKSUM
	ANDI	T1,777		;SAVE ONLY NINE BITS
	JRST	(P1)		;RETURN
>

	SUBTTL INBYTE GENERAL INPUT ROUTINES

	INTERNAL IBYTE.,IBLOK.,IPEEK.

IPEEK.:	SKIPG	DD.HRI+2(P3)	;PEEK AT NEXT CHARACTER ANY LEFT
	PUSHJ	P,IBLOK.	;NO, GET NEXT BLOCK
	MOVE	T0,DD.HRI+1(P3)	;GET THE BYTE POINTER
	ILDB	T0,T0		;PEEK AT THE NEXT CHARACTER
	JUMPN	T0,(P1)		;RETURN WITH T0 = PEEKED CHARACTER
	IBP	DD.HRI+1(P3)	;SKIP THE NULL
	SOS	DD.HRI+2(P3)	;ACCOUNT FOR THE CHARACTER POS.
	JRST	IPEEK.		;TRY AGAIN

IBYTE.:
IBYTE0:	TLNE	P3,IO.EOL!IO.EOF	;CHECK FOR END OF LINE
	JRST	IEOL		;YES, RETURN A BLANK
	SKIPG	DD.HRI+2(P3)	;REDUCE INPUT BYTE COUNT
	PUSHJ	P,IBLOK.	;NONE LEFT , GET A BUFFER
	TLNE	P3,IO.EOF	;END OF FILE
	JRST	IEOL		;STOP THE INPUT
	SOS	DD.HRI+2(P3)	;COUNT THIS DATA ITEM
	TLNE	P3,IO.FMT	;IS THIS FORMATED I/O
	JRST	IBYTE1		;YES, DO THE ILDB
	AOS	DD.HRI+1(P3)	;NO, UPDATE THE BYTE POINTER
	MOVE	T0,@DD.HRI+1(P3);GET THE DATA ITEM
	JRST	(P1)		;RETURN

IBYTE1:	ILDB	T0,DD.HRI+1(P3)	;GET INPUT CHARACTER
	JUMPE	T0,IBYTE0	;IGNORE NULL CHARACTERS
	CAIN	T0,15		;CHECK FOR A CARRAGE RETURN
	JRST	IBYTE.		;YES, IGNORE ALL CR'S
	CAIG	T0,15		;CHECK FOR A LINE TERMINATOR CHACTER
	CAIGE	T0,12		;VT, FF, LF
	JRST	(P1)		;NO, RETURN DATA CHARACTER

IBYTE2:	TLO	P3,IO.EOL	;YES SET END OF LINE FLAG
IEOL:	MOVEI	T0," "		;SET UP A BLANK FOR RETURN
	JRST	(P1)		;RETURN TO CALLER

IBLOK.:	TLNE	P3,IO.EDC!IO.STR	;IS THIS AN ENCODE/DECODE/STRING REQUEST
	JRST	IBLOK1		;YES, (SKIP UUO PROCESS)
	TLNE	P3,IO.TTA	;USER'S TTY
	JRST	IBLOK2		;YES, USE A TTCALL
	AOS	DD.BLK(P3)	;COUNT THIS BLOCK
IBLOK0:	HLLZ	T0,DD.UNT(P3)	;GET THE CHANNEL NUMBER
	TLO	T0,(IN)		;SETUP AN INPUT UUO
	TLZE	P3,IO.RNG	;CHANGING RINGS
	HRR	T0,DD.HRI(P3)	;GET THE NEW RING ADDRESS
	XCT	T0		;EXECUTE THE UUO
	POPJ	P,		;GET THE NEXT CHARACTER FROM THE BLOCK
	ERROR	(DEV,0,5,IBLOK1);DO THE ERROR PROCESSING

IBLOKT:	POP	P,T1		;RESTORE T1 FROM TTY ROUTINE
IBLOK1:	TLO	P3,IO.EOL!IO.EOF;SET END OF LINE
	POPJ	P,		;RETURN

IBLOK2:	PUSH	P,T1		;SAVE T1
	HRRZS	T1,DD.HRI(P3)	;GET THE BUFFER ADDRESS CLEAR USE BIT
	AOSN	-1(T1)		;END OF FILE SET LAST TIME (-1)
	ERROR	(DEV,4,5,IBLOKT)	;CALL THE ERROR ROUTINE
	HRLI	T1,440700	;SET UP AN ASCII BYTE POINTER
	ADDI	T1,2		;POINT TO DATA
	MOVEM	T1,DD.HRI+1(P3)	;SET BYTE POINTER IN RING BUFFER
	PUSH	P,T2		;SAVE AC 2
	MOVEI	T2,0		;CLEAR THE BYTE COUNT
	INCHWL	T0		;WAIT FOR A CHARACTER
	JRST	IBLOK4		;GO A CHARACTER
IBLOK3:	INCHSL	T0		;GET ANOTHER CHARACTER
	JRST	IBLOK5		;NONE LEFT
IBLOK4:	CAIN	T0,32		;^Z FOR EOF
	JRST	[MOVE	T1,DD.HRI(P3)	;GET THE RING ADDRESS
		SETOM	-1(T1)	;SET EOF FLAG
		JRST	IBLOK5]	;EXIT WITH EOF SET
	IDPB	T0,T1		;STORE CHARACTER IN BUFFER
	CAIGE	T2,<23-3>*5-1 ;CHECK FOR FULL BUFFER
	AOJA	T2,IBLOK3	;NO, CONTINUE FOR NEXT CHARACTER
IBLOK5:	MOVEM	T2,DD.HRI+2(P3)	;SAVE THE CHARACTER COUNT
	POP	P,T2		;RESTORE AC 2
	POP	P,T1		;RESTORE T1 REGISTER
	POPJ	P,		;GET THE CHARACTER
	SUBTTL END OF FORMATED LINE ROUTINES

;ADVANCE TO THE END OF THE CURRENT INPUT LINE

	INTERNAL	NXTLN.

NXTLN.:
NXTLNI:	PUSHJ	P,ENDLN.	;FINISH UP THE CURRENT LINE
	JUMPO	NXTLN2		;JUMP ON OUTPUT
	JSP	P1,IPEEK.	;PEEK AT THE NEXT CHARACTER
	CAIG	T0,14		;IGNORE VT,FF,LF IN THE POS FIELD
	CAIGE	T0,12		;IS THIS THE END OF THE POS FIELD
	TLZA	P3,IO.EOL	;YES, CLEAR EOL
NXTLN1:	SOJA	P1,IBYTE0	;NO, EAT NEXT CHARACTER AND RETURN TO PEEK
NXTLN2:	TLNE	P3,IO.STR	;STING REQUIRED
	PJRST	SETSTR		;YES, SET UP THE STRING
	POPJ	P,		;POSITIONED AT NEXT INPUT LINE

ENDLN.:	TLNN	P3,IO.STR	;IS THIS A STRING
	JRST	ENDLN1		;NO
	PUSHJ	P,DMPSTR	;YES, DUMP THE STRING
	PUSHJ	P,ENDLN1	;DO END OF LINE
	TLO	P3,IO.STR	;TURN THE STRING FLAG ON
	POPJ	P,		;RETURN
ENDLN1:	JUMPO	ENDLNO		;FINISH UP THE CURRENT LINE
ENDLNI:				;FINISH OF THE CURRENT INPUT LINE
	JSP	P1,IBYTE.	;EAT THE NEXT CHARACTER
	TLNN	P3,IO.EOL!IO.EOF;CHECK FOR END OF LINE FLAG
	PJSP	IBYTE.		;NO,EAT ANOTHER RETURN AT (.-1)
	POPJ	P,		;AT THE END OF THE CURRENT LINE OF INPUT

ENDLNO:
NXTLNO:	TLNE	P3,IO.INT	;OUTPUT, INTERACTIVE DEVICE?
	PUSHJ	P,OBLOK.	;YES, DUMP THE BUFFER
	MOVEI	T0,15		;GET A CARRAGE RETURN
	TLC	P2,FT.FIN!FT.DOL;COMPLEMENT LAST RIGHT PAREN AND DOL FLAG
	TLCN	P2,FT.FIN!FT.DOL;IF BOTH ON SKIP THE CR AND RESTORE THE FLAGS
	JRST	.+4		;SKIPT THE CR/LF
	JSP	P1,OBYTEC	;OUTPUT THE CARRAGE RETURN
	MOVEI	T0,12		;GET A LINE FEED
	JSP	P1,OBYTEC	;OUTPUT THE LINE FEED
				;(THIS LINE FEED MAY BE CHANGED BY THE
				; BY THE FORMAT CARRAGE CONTROL ROUTINE)
	TLNE	P3,IO.CCC	;CHECK FOR FORMATED OUTPUT
	JRST	NXTLNF		;WORD BOUNDRY NOT REQUIRED
	MOVSI	T0,760000	;SET UP A BYTE POINTER MASK AND A
				;PSEUDO NULL IN THE RIGHT
	SKIPE	DD.LOG(P3)	;FIXED LENGTH RECORDS
	TLZE	P3,IO.EOL	;YES, AT END OF LINE
	JRST	.+3		;YES, GO FILL OUT LAST WORD
	JSP	P1,OBYTE.	;NO, OUTPUT THE NULL
	JRST	.-3		;CONTINUE UNTIL END OF FIXED RECORD
	TDNN	T0,DD.HRO+1(P3)	;MUST FILL OUT THE LAST WORD
	JRST	.+3		;WORD FILLED OUT
	JSP	P1,OBYTEC	;OUTPUT A NULL
	JRST	.-3		;CONTINUE FILLING
	TSOA	T0,DD.LOG(P3)	;GET THE LOGCIAL RECORD SIZE
NXTLNF:	MOVEI	T0,1		;SET A FORMAT FLAG
	HRRZM	T0,POS.TB(P4)	;STORE IN THE POSITION TABLE
	POPJ	P,		;RETURN (AT END OF CURRENT OUTPUT)
	SUBTTL OUT BYTE GENERAL OUTPUT ROUTINES

	INTERNAL OBYTE.,OBLOK.
OBYTE.:	TLNE	P3,IO.EOL	;CHECK FOR END OF LOGICAL FIXED RECORD
	JRST	(P1)		;YES, CAN NOT OUTPUT CHARACTER
	TLNE	P3,IO.STR	;OUTPUT TO AN INCORE STRIN
	JRST	OBYTEC		;YES, DON'T COUNT
	SOSN	POS.TB(P4)	;COUNT THIS ITEM IN THE HORIZ. POS
	PJRST	OUTCCC		;FIRST CHARACTER, CHECK FOR CARRIAGE CONTROL
OBYTEC:	SKIPG	DD.HRO+2(P3)	;CHECK FOR A FULL BUFFER
	PUSHJ	P,OBLOK.	;BUFFER IS FULL
	SOS	DD.HRO+2(P3)	;REDUCE THE ITEM COUNT
	TLNE	P3,IO.FMT	;IS THIS FORMATED I/O
	JRST	OBYTE1		;YES. DO ILDB
	AOS	DD.HRO+1(P3)	;BINARY I/O UPDATE THE BYTE POINTER
	MOVEM	T0,@DD.HRO+1(P3);DUMP THE DATA WORD
	JRST	(P1)		;RETURN
OBYTE1:	JUMPN	T0,.+2		;CHECK FOR NULL OUTPUT
	MOVEI	T0," "		;YES,REPLACE WITH A BLANK
	IDPB	T0,DD.HRO+1(P3)	;PUT THE CHARACTER IN THE OUTPUT BUFFER
	JRST	(P1)		;NO RETURN

OBLOK.:	PUSH	P,T0		;SAVE THE OUTPUT WORD
	TLNE	P3,IO.EDC!IO.STR	;CHECK FOR ENCODE/DECODE/STRING
	JRST	OBLOK1		;YES, (SKIP UUO)
	TLNE	P3,IO.TTA	;USER'S TTY
	JRST	OBLOK2		;YES, USE A TTCALL
	TLNE	P3,IO.RAN	;RANDOM ACCESS OUTPUT
	JRST	[PUSH	P,P1	;SAVE THE JSP RETURN
		PUSHJ	P,WBLOK.	;WRITE THIS BLOCK
		AOS	DD.BLK(P3)	;STEP TO THE NEXT BLOCK
		PUSHJ	P,RBLOK.	;READ THE NEXT BLOCK
		POP	P,P1		;RESTORE THE JSP POINTER
		JRST	OBLOK3]		;COMMON EXIT
	AOS	DD.BLK(P3)	;COUNT THIS BLOCK
OBLOK0:	HLLZ	T0,DD.UNT(P3)	;GET THE CHANNEL NUMBER
	TLO	T0,(OUT)	;NO, BUFFERED OUTPUT
	TLZE	P3,IO.RNG	;CHANGING RINGS
	HRR	T0,DD.HRO(P3)	;GET THE NEW RING ADDRESS
	XCT	T0		;OUTPUT THE BUFFER
	PJRST	OBLOK3		;EXIT FROM BLOCK ROUTINE
	ERROR	(DEV,0,5,OBLOK1);DO THE ERROR REPORT

OBLOK1:	TLO	P3,IO.EOL	;SET END OF LING FLAG
	JRST	OBLOK3		;RESTORE AND EXIT

OBLOK2:	MOVSI	T0,440700	;SET AN ASCII BYTE POINTER
	IDPB	T0,DD.HRO+1(P3)	;SET A NULL AT THE END
	HRR	T0,DD.HRO(P3)	;GET THE BUFFER ADDRESS
	ADDI	T0,2		;POINT TO DATA
	MOVEM	T0,DD.HRO+1(P3)	;SET IN RING HEADER
	MOVEI	T0,<23-3>*5-1  ;GET BUFFER SIZE IN CHARACTERS
	MOVEM	T0,DD.HRO+2(P3)	;SAVE IN RING HEADER
	OUTSTR	@DD.HRO+1(P3)	;OUTPUT THE STRING
OBLOK3:	POP	P,T0		;RETORE THE OUTPUT WORD
	POPJ	P,		;RETURN
	SUBTTL CARRAGE CONTROL ROUTINES
OUTCCC:	TLNN	P3,IO.CCC	;FORMS CONTROL REQUIRED
	JRST	[TLO	P3,IO.EOL ;SET END OF LINE FLAG
		JRST	OBYTEC]	;OUTPUT THIS CHARACTER
	PUSH	P,P1		;SAVE THE RETURN ADDRESS(POPJ ED)
	PUSH	P,T0		;SAVE THE CONTROL CHARACTER
	SUBI	T0,"*"		;RELOCATE CONTROL CHARACTER FOR INDEXING
	JUMPL	T0,OUTCC2	;CHARACTER IS NOT IN RANGE
	CAILE	T0,"3"-"*"	;CHECK THE HIGH END
	JRST	OUTCC2		;NOT IN RANGE USE THE PREVIOUS CCC
	ADDI	T0,CCC.TB	;POINT TO THE TABLE
	MOVE	T0,@T0		;GET THE CONTROL CHARACTERS
	ROT	T0,5		;GET THE LOW ORDER 4 BITS
	TLNN	P3,IO.TTA	;IS THIS THE USER'S TTY
	JRST	OUTCC0		;NO,CONTINUE NORMAL
	SKIPN	T0		;+ CARRIAGE CONTROL
	MOVEI	T0,177		;YES, SEND A RUB OUT (NULL'S DON'T WORD)
	SKIPGE	DD.HRO+1(P3)	;IS THE TTY BUFFER EMPTY
	JSP	P1,OBYTEC	;YES, OUTPUT THIS NORMAL
OUTCC0:	DPB	T0,DD.HRO+1(P3)	;OVER RIDE THE PRECIOUS CHARACTER
OUTCC1:	ANDCMI	T0,177		;CLEAR THE LAST CHARACTER
	JUMPE	T0,OUTCC2	;NONE LEFT EXIT
	ROT	T0,5		;GET THE NEXT CHARACTER
	JSP	P1,OBYTEC	;OUTPUT THE CHARACTER AND ADVANCE
	JRST	OUTCC1		;CHECK FOR MORE CHARACTER
OUTCC2:	POP	P,T0		;RESTORE THE CHARACTER
	POP	P,P1		;RESTORE THE JSP POINTER
	JRST	(P1)		;RETURN

CCC.TB:			;CARRAGE CONTROL CHARACTER CONVERSION TABLES
	BYTE (5)023(13)000		;*;
	BYTE (5)000(13)000		;+;
	BYTE (5)021(13)000		;,;
	BYTE (5)012(5)012(5)12(3)0	;-;
	BYTE (5)022(13)000		;.;
	BYTE (5)0024(13)000		;/;
	BYTE (5)012(5)012(8)000		;0;
	BYTE (5)014(13)000		;1;
	BYTE (5)020(13)000		;2;
	BYTE (5)013(13)000		;3;
	SUBTTL INCORE STRING ROUTINES
SETSTR:				;DEFINE AN STRING AND COPY THE INPUT
				;INTO THE STRING
	MOVEI	T0,^D32		;THREE WORD HEADER AND 29 WORD STRING
	PUSHJ	P,GETOWN	;GET THE CORE
	PUSH	P,T1		;SAVE THE STRING ADDRESS
	MOVEI	T2,2(T1)	;POINT TO THE DATA
	HRLI	T2,(POINT 7,0,34);SET UP AN ASCII BYTE POINTER
	PUSH	P,T2		;SAVE THE BYTE POINTER
	MOVSI	T3,-<^D29*5>	;GET THE BYTE COUNT
	JUMPO	SETST5		;JUMP ON OUTPUT
SETST1:	JSP	P1,IBYTE.	;READ IN THE INPUT
	TLNE	P3,IO.EOL	;END OF LOGICAL RECORD
	JRST	SETST2		;YES, STOP READING
	IDPB	T0,T2		;NO, STORE THE CHARACTER
	AOBJN	T3,SETST1	;OR END OF STRING BUFFER
SETST2:	HRLI	T1,DD.HRI(P3)	;GET THE INPUT RING ADDRESS
	BLT	T1,@(P)		;SAVE THE DEVICE INFORMATION
	POP	P,DD.HRI+1(P3)	;INSERT THE STRING BYTE POINTER
	POP	P,DD.HRI(P3)	;AND THE STRING ADDRESS
	HRRZM	T3,DD.HRI+2(P3)	;AND THE STRING SIZE
	JRST	SETST6		;COMMON EXIT
SETST5:	HRLI	T1,DD.HRO(P3)	;GET THE OUTPUT HEADER
	BLT	T1,@(P)		;SAVE THE OUTPUT RING HEADER
	MOVEI	T3,<^D29*5>	;GET THE CHARACTER COUNT
	MOVEM	T3,DD.HRO+2(P3)	;SAVE THE CHARACTER COUNT
	POP	P,DD.HRO+1(P3)	;SAVE THE BYTE POINTER
	POP	P,DD.HRO(P3)	;AND THE STRING ADDRESS
SETST6:	TLO	P3,IO.STR	;SET THE STRING FLAG
	TLZ	P3,IO.EOL	;CLEAR OND OF LINE FLAG
	POPJ	P,		;RETURN


DMPSTR:				;OUTPUT A STRING BLOCK
	JUMPO	DMPST5		;JUMP ON OUTPUT
	MOVE	T1,DD.HRI(P3)	;GET THE STRING POINTER
	MOVSI	T2,(T1)		;SET UP TO RESTORE THE RING HEADER
	HRRI	T2,DD.HRI(P3)	;THE TO ADDRESS
	BLT	T2,DD.HRI+2(P3)	;RESTORE THE RING HEADER
	LDB	T0,DD.HRI+1(P3)	;GET THE DELIMETER
	TLO	P3,IO.EOL	;SET END OF LINE
	CAIG	T0,15		;CARRIAGE RETURN
	CAIGE	T0,12		;THRU LF
	TLZ	P3,IO.EOL	;NO, CLEAR END OF LINE FLAG
	PJRST	GET12		;DELETE THE STRING BLOCK
DMPST5:	MOVE	T1,DD.HRO(P3)	;GET THE OUTPUT STRING POINTER
	MOVSI	T2,(T1)		;SET UP TO RESTORE THE OUTPUT RING HEADER
	HRRI	T2,DD.HRO(P3)	;THE TO ADDRESS
	BLT	T2,DD.HRO+2(P3)	;RESTORE THE OUTPUT RING HEADER
	MOVEI	T2,2(T1)	;SET UP A BYTE POINTER
	HRLI	T2,(POINT 7,0,34)	;TO THE STRING BUFFER
	TLZ	P3,IO.STR	;CLEAR THE STRING FLAG
DMPST6:	ILDB	T0,T2		;GET A CHARACTER
	JUMPE	T0,GET12	;DELETE THE CORE BLOCK AT END OF STR
	JSP	P1,OBYTE.	;OUTPUT THE CHARACTER
	JRST	DMPST6		;CONTINUE
	SUBTTL FIND RANDOM ACCESS POSITIONING ROUTINES
FIND%:	HALT	.		;ENTRY TO POSITION FOR THE NEXT RANDOM BLOCK
	PUSHJ	P,SAVE.		;SAVE THE USER'S ACS
	MOVSI	P2,IO.INO!IO.RAN;SET OUTPUT AND RANDOM FLAGS
	JSP	P1,SRCFLU	;IS THE UNIT DEFINED
	POPJ	P,		;NO, IGNORE THE CALL
	TLNN	P3,IO.RAN	;IS THE FILE RANDOM ACCESS
	POPJ	P,		;NO, IGNORE THE CALL
FIND%%:	HALT	.		;FOROTS ENTRY
	TLZ	P3,IO.EOL	;CLEAR THE END OF LINE
	MOVE	G1,3(L)		;POINT TO THE RECORD NUMBER VARIABLE
	JSP	P1,EFCTV1	;GET THE ADDRESS
	TRNN	G1,-20		;IN THE AC SAVE AREA
	ADDI	G1,ACC.SV(P4)	;YES, RELOCATE TO THE SAVE AREA
	SKIPG	T4,(G1)		;GET THE RECORD NUMBER
	MOVEI	T4,1		;ILLEGAL RECORD NUMBERS GET A 1(ONE)
	SKIPE	T1,DD.ASC(P3)	;GET THE ASSOCIATE VARIABLE ADDRESS
	MOVEM	T4,(T1)		;STORE THE CURRENT RECORD NUMBER
				;UPDATED BY ("NSTLN.")
	SUBI	T4,1		;START AT RELATIVE REOCRD 0
	HRRZ	T2,DD.LOG(P3)	;GET THE LOGICAL RECORD SIZE
	IMULI	T4,(T2)		;COMPUT THE NUMBER OF WORD FROM THE BOF.
	IDIVI	T4,200		;GET THE BLOCK IN T4/ WORD IN T5
	ADDI	T4,1		;BLOCK START AT 1 FOR FILSER
	HRRZ	T0,DD.BLK(P3)	;GET THE CURRENT BLOCK NUMBER
	JUMPGE	G4,[JUMPI	FIND0	;INPUT
		JRST	FIND00]	;OUTPUT
	TLCE	P3,IO.INO	;YES, OUTPUT LAST
FIND00:	JUMPN	T0,FIND3A	;NO INCORE BLOCKS
FIND0:	CAIGE	T0,(T4)		;IS THE BLOCK CURRENT OR ADVANCING IN THE FILE
	JRST	FIND3		;NO, BACKING UP
FIND1:	SKIPA	T1,DD.HRI(P3)	;GET THE INPUT HEADER
FIND2:	HRRZI	T1,(T2)		;STEP ALONG THE BUFFER CHAIN
	SKIPL	T2,(T1)		;GET THE BUFFER HEADER
	JRST	FIND3		;NO, END OF ACTIVE BUFFERS
	CAIN	T0,(T4)		;IS THIS THE BLOCK WE WANT
	JRST	FIND5		;YES, THIS IS THE BUFFER
	TLZ	T2,400000	;CLEAR THE USE BIT
	MOVEM	T2,(T1)		;STORE THE BUFFER HEADER (USE=0)
	AOJA	T0,FIND2	;NO, STEP TO THE NEXT BUFFER
FIND5:	MOVEM	T1,DD.HRI(P3)	;SET THIS AS THE CURRENT BUFFER
	JRST	FIND4		;GO SET UP THE REST OF THE RING HEADER
FIND3A:	PUSHJ	P,WBLOK.	;GO DUMP THE INCORE BLOCK
FIND3:	HRRM	T4,DD.BLK(P3)	;SET UP THE BLOCK NUMBER
	PUSHJ	P,RBLOK.	;GET THE NEXT RANDOM BLOCK
	MOVE	T1,DD.HRI(P3)	;GET THE CURRENT BUFFER
FIND4:	MOVEM	T1,DD.HRO(P3)	;SAVE IN THE OUTPUT RING HEADER
	HLL	T1,DD.HRI+1(P3);GET THE BYTE INFO
	TLZ	T1,770000	;CLEAR THE POSITION FIELD
	ADDI	T1,1(T5)	;POINT TO THE DATA WORD -1
	MOVEM	T1,DD.HRI+1(P3)	;STORE IN THE INPUT RING HEADER
	MOVEM	T1,DD.HRO+1(P3)	;AND THE OUTPUT RINGG HEADER
	MOVEI	T1,200		;GET THE DISK BUFFER SIZE
	SUBI	T1,(T5)		;MINUS THE WORDS SKIPPED
	TLNE	P3,IO.FMT	;CHECK FOR ASCII I/O
	IMULI	T1,5		;CONVERT TO CHARACTERS
	MOVEM	T1,DD.HRI+2(P3)	;SAVE IN THE INPUT RING HEADER
	MOVEM	T1,DD.HRO+2(P3)	;ALSO THE OUTPUT RING HEADER
	POPJ	P,		;RETURN

RBLOK.:	HALT	.		;GET THE NEXT RANDOM BLOCK IN CORE
	JSP	P1,WAIT.	;STOP THE DEVICE
	JSP	P1,CLRUSE
	MOVE	T0,DD.BLK(P3)	;GET THE BLOCK NUMBER
	HLL	T0,DD.UNT(P3)	;GET THE CHANNEL NUMBER
	TLO	T0,(USETI)	;TELL FILSER THE BLOCK WE WANT
	XCT	T0		;DO IT
	PUSH	P,T0		;SAVE THE USETI BLK#
	HLLZ	T0,DD.UNT(P3)	;GET THE CHANNEL NUMBER
	IOR	T0,[STATO 0,20000] ;CHECK FOR EOF
	XCT	T0		;DO IT
	JRST	RBLOK1		;OK, NO EOF
	JUMPI	RBLOK1		;ALLOW EOF TO STAND ON INPUT
	HLLZ	T0,DD.UNT(P3)	;GET THE CHANNEL NUMBER
	IOR	T0,[SETSTS 0,@DD.OPN(P3)] ;RESET THE THE DEVICE STATS
	XCT	T0		;DO IT
	POP	P,T0		;RESTORE THE USETI BLK#
	TLO	T0,(USETO)	;CHANGE THE USETI TO USETO
	XCT	T0		;ALLOCATE THE DISK SPACE
	POPJ	P,		;RETURN
RBLOK1:	TLO	P3,IO.RNG	;CHANG RINGS FLAG
	POP	P,T0		;RESTORE THE STACK
	PJRST	IBLOK0		;INPUT THE BLOCK

WBLOK.:	HALT	.		;WRITE THE CURRENT BLOCK
	JSP	P1,WAIT.	;STOP THE DEVICE
	PUSH	P,@DD.HRO(P3)	;SAVE THE CURRENT BUFFER
	JSP	P1,CLRUSE	;CLEAR THE USE BITS
	POP	P,@DD.HRO(P3)	;RESTORE THE CURRENT BUFFER
	MOVE	T0,DD.BLK(P3)	;NO, GET THE CURRENT BLOCK NUMBER
	HLL	T0,DD.UNT(P3)	;NO, GET THE CHANNEL NUMBER
	TLO	T0,(USETO)	;SET UP A USETO TO THE LAST BLOCK
	XCT	T0		;DO IT
	TLO	P3,IO.RNG	;SET CHANGE RING FLAG
	AOBJN	P,OBLOK0	;OUTPUT THE BLOCK

WAIT.:				;WAIT FOR THE DEVICE TO STOP
	HLLZ	T0,DD.UNT(P3)	;GET THE CHANNEL NUMBER
	IOR	T0,[WAIT]	;SET UP A WAIT UUO
	XCT	T0		;STOP THE DEVICE FROM FILLINGG BUFFERS
	JRST	(P1)		;RETURN TO THE CALLER

CLRUSE:	HALT	.		;ROUTINE TO CLEAR THE USE BITS IN A RING
	PUSH	P,T1		;SAVE T1
	MOVSI	T0,400000	;SET UP A USE BIT MASK
	IORM	T0,DD.HRI(P3)	;*****"RI514H"***********
	MOVE	T1,DD.HRI(P3)	;GET THE RING BUFFER POINTER
CLRUS2:	SKIPL	(T1)		;USE BIT SET
	JRST	CLRUS1		;NO, EXIT
	ANDCAM	T0,(T1)		;CLEAR THE USE BIT
	MOVE	T1,(T1)		;GET THE NEXT BUFFER
	JRST	CLRUS2		;CONTINUE
CLRUS1:	POP	P,T1		;YES, RESTORE T1
	JRST	(P1)		;RETURN
	SUBTTL ENCODE/DECODE SETUP ROUNTINES
ENC%:	PUSHJ	P,SAVE.		;SAVE THE USER'S AC'S
	MOVSI	P3,IO.INO!IO.EDC!IO.FMT!IO.SOU	;ENCODE/OUTPUT/FORMAT
	JRST	ENCDEC		;GO TO COMMON CODE

DEC%:	PUSHJ	P,SAVE.		;SAVE THE USER'S AC'S
	MOVSI	P3,IO.EDC!IO.FMT!IO.SIN	;DECODE/INPUT/FORMAT

ENCDEC:	HRRI	P3,DEC.TB-DD.HRI(P4)	;GET A DUMMY DD POINTER
	JSP	P1,EFCTVL	;GET EFFECTIVE ADDRESS (E)
	MOVEM	G1,DD.HRI+2(P3)	;SAVE CHARACTER COUNT IN HEADER BLOCK
	MOVE	G1,3(L)		;GET ARRAY POINTER FROM ARG BLOCK
	JSP	P1,EFCTV1	;GET THE EFFECTIVE ADDRESS (E)
	HRLI	G1,(POINT 7)	;MAKE A BYTE POINTER
	MOVEM	G1,DD.HRI+1(P3)	;PUT IN HEADER BLOCK
	JUMPI	.+2		;SKIP ON INPUT
	HRRI	P3,-<DD.HRO-DD.HRI>(P3)	;SET OUTPUT
	MOVEI	T1,-3(G1)	;BUILD A RING POINTER
	MOVEM	T1,DD.HRI(P3)	;STORE IT
	SETZM	POS.TB(P4)	;CLEAR THE COLUMN COUNTER
	SETZM	END.TB(P4)	;CLEAR THE END RETURN
	SETZM	ERR.TB(P4)	;CLEAR THE ERR RETURN
	JRST	SETIO3	;GO SET UP THE POS TABLE
	SUBTTL I/O INITIALIZATION ROUTINES

NLO%:	PUSHJ	P,SAVE.		;SAVE THE USER'S ACS
	MOVSI	P2,IO.INO!IO.FMT!IO.SOU!FT.NML	;SET NAMELIST OUTPUT
	JRST	SETIO		;GO TO SETUP

NLI%:	PUSHJ	P,SAVE.		;SAVE THE USER'S ACS
	MOVSI	P2,IO.FMT!IO.SIN!FT.NML ;SET NAMELIST INPUT
	JRST	SETIO

IN%:	PUSHJ	P,SAVE.		;SAVE THE USER'S ACS
	MOVSI	P2,IO.FMT!IO.SIN	;SET FORMATED INPUT
	JRST	SETIO

OUT%:	PUSHJ	P,SAVE.		;SAVE THE USER'S ACS
	MOVSI	P2,IO.INO!IO.FMT!IO.SOU	;SET FORMATED OUTPUT
	JRST	SETIO

RTB%:	PUSHJ	P,SAVE.		;SAVE THE USER'S ACS
	MOVSI	P2,IO.SIN		;SET UN-FORMATED INPUT
	JRST	SETIO

WTB%:	PUSHJ	P,SAVE.		;SAVE THE USER'S ACS
	MOVSI	P2,IO.INO!IO.SOU	;SET UN-FORMATED OUTPUT
;	JRST	SETIO

SETIO:	HLRZ	T2,(L)		;GET THE ARG BLOCK SIZE
	CAIL	T2,4000		;MUST BE AT LEAST FOUR ARGS FOR RANDOM
	SKIPN	3(L)		;IS THERE AN ARGUEMNT
	TLZA	P2,IO.RAN	;CLEAR THE RANDOM FLAG
	TLO	P2,IO.RAN	;YES, RANDOM ACCESS SET FLAG
SETIO0:	JSP	P1,SRCFLU	;SEE IF THE UNIT IS DEFINED
	PUSHJ	P,SETOPN	;DO A DEFAULT OPEN
	HLRZ	T2,(L)		;GET THE ARG BLOCK SIZE
	CAIL	T2,2000		;IS THE AT LEAST TWO ARGS
	SKIPN	T1,1(L)		;GET THE RETURN ADDRESS
	SETZ	T1,		;NO, RETURN ADDRESS
	HRRZM	T1,END.TB(P4)	;STORE THE EOF RETURN
	HLRZM	T1,ERR.TB(P4)	;STORE THE ERROR RETURN
	MOVE	G3,DD.STS(P3)	;GET THE DEVCHR BITS
	TLNN	P3,IO.OPN	;IS THE FILE OPEN
	PUSHJ	P,SETDIR	;NO, SET UP THE DIRECTORY
	TLNN	P2,IO.RAN	;SWITCHING RANDOM/SEQUENTIAL ACCESS
	JRST	SETIOA		;NO,
	TLNN	P3,IO.RAN	;IS THIS A RANDOM FILE
	ERROR	(DAT,13,10,)	;CAN NOT RANDOM ACCESS A SEQ FILE
SETIOA:	MOVE	G4,P2		;COPY THE FLAGS
	XOR	G4,P3		;CHECK FOR MODE CHANGES
	JUMPGE	G4,SETIO1	;SWITCHING FROM IN/OUT OR OUT/IN
	TLNN	P3,IO.RAN	;UNLESS RANDOM ACCESS MODE
	PUSHJ	P,SETRWR	;YES, DO A MODE SWITCH
SETIO1:	TLNE	G4,IO.FMT	;SWITCHING FROM FORMATED/UN-FORMATED
	PUSHJ	P,SETMOD	;DO A MODE SWITCH
	SKIPL	T1,DD.LOG(P3)	;ARE THERE FIXED LENGTH RECORDS
	JRST	SETIO2		;ALREADY DEFINED
	MOVNS	T5,T1		;YES, GET THE USER'S RECORD SIZE
	LDB	T2,[POINT 6,DD.HRI+1(P3),11] 	;GET THE MODE POINTER
	LDB	T4,[POINT 6,DD.BLK(P3),11]	;GET THE MODE TYPE POINTER
	CAIE	T4,MOD.IM-MOD.DP;IMAGE MODE
	ADDI	T1,2		;NO, ALLOW FOR (LSCW OR CR-LF)
	MOVEI	T3,44		;GET THE NUMBER OF BITS PER WORD
	IDIVI	T3,(T2)		;GET THE ITEMS PER WORD
	IDIVI	T1,(T3)		;GET THE NUMBER OF WORD/RECORD
	SKIPE	T2		;IS THERE A PARTICAL WORD
	ADDI	T1,1		;YES, ALLOCATE ANOTHER WORD
	HRLI	T1,(T5)		;GET THE ITEMS/RECORD (USER VALUE)
	MOVEM	T1,DD.LOG(P3)	;STORE THE LOG REC SIZE
SETIO2:	TLNE	P3,IO.CCC	;IS THE OUTPUT FORMATED
	MOVSI	T1,1		;SET UP A FLAG FOR "OUTCCC"
	HLRZM	T1,POS.TB(P4)	;SET UP THE POSITION TABLE
	TLNE	P2,IO.RAN	;RANDOM ACCESS REQUEST
	PUSHJ	P,FIND%%	;GO SET UP THE BUFFERS
	TLNN	P3,IO.FMT	;IS THIS FORMATED I/O
	JRST	BINIO		;NO, GO TO BINARY ROUTINES
	TLNN	P2,FT.NML	;YES, NAME LIST I/O
	JRST	SETIO3		;NO,
	MOVE	G1,2(L)		;GET THE NAME LIST ARRAY POINTER
	JSP	P1,EFCTV1	;GET THE EFFECTIVE ADDRESS
	PUSHJ	P,NMLST%##	;GO PROCESS THE NAME LIST REQUEST
	PJRST	FINF1		;GO TO FIN% TO CLEAN UP
SETIO3:	MOVE	T1,DD.HRO+1(P3)	;OUTPUT GET THE OUTPUT HEADER
	JUMPO	SETIO4		;JUMP ON INPUT
	TLNE	P3,IO.EOL	;AT END OF LAST LINE
	PUSHJ	P,NXTLNI	;YES, GET THE NEXT INPUT LINE
	MOVE	T1,DD.HRI+1(P3)	; GET THE BEGINNNG BYTE POINTER
SETIO4:	TLZ	P3,IO.EOL	;CLEAR THE END OF LINE
	MOVEM	T1,POS.TB+1(P4)	;SAVE FOR AN ERROR PRINT (T FORMAT)
	JRST	FMTSRC		;GO TO THE FORMAT SCANNER
	SUBTTL	ACCESS MODE CHANGE ROUTINES

SETDIR:	HLLZS	DD.BLK(P3)	;CLEAR THE BLOCK COUNT
	TLNN	G3,DV.DIR	;DIRECTORY DEVICE
	JRST	SETDI1		;NO, DO NOT LOOKUP/ENTER
	SETZM	DD.ALC(P3)	;***** CLEAR BLOCKS ALLOCATED
	MOVEI	P1,LOOKU.	;ASSUME INPUT
	JUMPGE	P2,SETDI0	;JUMP ON INPUT
	MOVEI	P1,ENTER.	;SET OUTPUT
SETDI0:	JSP	P1,(P1)		;SET UP THE FILE
	ERROR	(OPN,0,7,)	;FILE NOT FOUND
SETDI1:	JUMPGE	P2,SETDI2	;JUMP ON OUTPUT
	PUSHJ	P,OBLOK.	;DUMMY OUTPUT
	TLOA	P3,IO.INO	;SET OUTPUT
SETDI2:	TLZ	P3,IO.INO	;SET INPUT
	TLO	P3,IO.OPN	;SET FILE OPEN
	POPJ	P,		;RETURN


SETMOD:	MOVEI	T0,MOD.AS-MOD.DP;ASSUME ASCII MODE SWITCH
	TLZE	P3,IO.FMT	;CHECK THE PREVIOUS I/O MODE
	MOVEI	T0,MOD.BN-MOD.DP;SET BINARY MODE
	DPB	T0,[POINT 6,DD.BLK(P3),11] ;SAVE THE NEW MODE INDEX
	TLNN	P3,IO.NON	;NON STANDARD MODE (ERROR IF SO)
	JSP	P1,OPENDM	;MAKE THE MODE SWITCH
	ERROR	(OPN,1,10)	;ILLEGAL MODE
	HLLZ	T0,DD.UNT(P3)	;GET THE CHANNEL NUMBER
	TLO	T0,(SETSTS)	;SET UP A STATUS UUO
	HRR	T0,DD.OPN(P3)	;GET THE STATUS ADDRESS
	XCT	T0		;TELL THE MONITOR ABOUT THE MODE CHANGE
	HLRZ	T0,MOD.DP(T5)	;GET THE BYTE SIZE
	ANDI	T0,7700		;CLEAR OUT ALL BUT BYTE SIZE
	HRLM	T0,DD.HRI+1(P3)	;SET UP THE NEW BYTE POINTER
	HRLM	T0,DD.HRO+1(P3)	;BOTH INPUT AND OUTPUT
	MOVE	T1,DD.HRI+2(P3)	;GET THE INTPUT ITEM COUNT
	JUMPI	.+2		;SKIP ON INPUT
	MOVE	T1,DD.HRO+2(P3)	;GET THE OUTPUT ITEM COUNT
	JUMPE	T1,.+7		;EXIT IF THE BUFFER IS EMPTY/FULL
	TLNE	P3,IO.FMT	;SWITCHING TO FORMAT
	IMULI	T1,5		;YES, CHANGE ITEM COUNT TO CHARACTER
	TLNN	P3,IO.FMT	;SWITCHING TO BINARY
	IDIVI	T1,5		;YES, CHANGE CHARACTERS TO WORDS
	MOVEM	T1,DD.HRI+2(P3)	;SAVE THE NEW ITEM COUNT
	MOVEM	T1,DD.HRO+2(P3)	;FOR BOTH INPUT/OUTPUT
	POPJ	P,		;RETUNR
	SUBTTL SETWRT ROUTINE TO SWITCH THE FILE FROM READ TO WRITE MODE
SETRWR:	TLNN	G3,DV.TTY!DV.TTA	;USER'S TTY
	JRST	SETRW1		;NO, CONTINUE
	TLCE	P3,IO.INO	;YES, OUTPUT LAST
	PJRST	OBLOK.		;YES, DUMP THE LAST BLOCK
	JRST	SETRW7		;EXIT RETURN
SETRW1:	HRRZ	T2,DD.BLK(P3)	;GET THE BLOCK COUNT
	JUMPE	T2,SETRW0	;BEGINNING OF FILE ANY SWITCH OK
	JUMPI	SETRW2		;SWITCH TO OUTPUT IS LEGAL
	ERROR	(DAT,10,10,)	;KILL THE JOB READ_WRITE
SETRW0:	AOS	T2,DD.BLK(P3)	;SET TO FIRST BLOCK
SETRW2:	JSP	P1,WAIT.	;STOP THE DEVICE
	TLNN	G3,DV.OUT	;CAN THE DEVICE DO OUTPUT
	ERROR	(OPN,2,7,)	;NO, KILL THE JOB WITH A MESSAGE
	DMOVE	T4,DD.HRI(P3)	;GET THE INPUT RING HEADER
	MOVE	G1,DD.HRI+2(P3)	;GET THE INPUT ITEM COUNT
	TLNN	G3,DV.DSK	;IS THIS A DSK TYPE DEVICE
	JRST	SETRW4		;NO
	HRRZM	T2,DD.ALC(P3)	;STORE THE CURRENT BLOCK NUMBER
	JSP	P1,RENAM.	;TRUNCATE THE FILE
	JRST	SETRW3		;ERROR
	JSP	P1,LOOKU.	;LOOKUP THE FILE AGAIN
	JRST	SETRW3		;ERROR
	JSP	P1,ENTER.	;GO TO UPDATE MODE
SETRW3:	ERROR	(OPN,0,7,)	;FAILURE TRYING  TO TRUNCATE THE FILE
	HLL	T2,DD.UNT(P3)	;YES, GET THE CHANNEL NUMBER
	TLO	T2,(USETO)	;SET OUTPUT THE THE CURRENT BLOCK NUMBER
	XCT	T2		;SET FILSER TO THE BLOCK FOR A REWRITE
	TLO	P3,IO.RNG	;SET RING CHANGE FLAG
	JRST	SETRW5		;COMMON EXIT
SETRW4:	TLNN	G3,DV.MTA	;IS THIS A MAGE TAPE
	ERROR	(OPN,2,10,)	;BLOCK CAN NOT BE REWRITTEN
	SETZ	T3,		;CLEAR THE BACKSPACE COUNT
	JSP	P1,BSRMTA	;BACK UP THE MAGTAPE

SETRW5:	DMOVEM	T4,DD.HRO(P3)	;SET UP THE OUTPUT RING HEADER
	MOVEM	G1,DD.HRO+2(P3)	;PUT IN THE OUTPUT RING HEADER
	TLO	P3,IO.INO	;SET OUTPUT MODE
SETRW7:	TLZ	P3,IO.EOL	;CLEAR END OF LINE
	POPJ	P,		;RETURN
	SUBTTL BINXX BINARY FORMATED DATA TRANS INIT ROUTINES
BINIO:	SETZB	P2,G4		;CLEAR THE FORMAT REGISTER
	TLZ	P3,IO.EOL!IO.FMT;CLEAR END OF LINE AND FORMAT FLAG
	TLNE	P3,IO.NON	;NON STANDARD I/O MODE
	JRST	[MOVEI	G4,-1;SET THE LARGEST RECORD SIZE
		MOVEM	G4,POS.TB(P4)	;STORE IN POSITION TABLE
		JRST	BINXIT]		;EXIT TO I/O LIST
	JUMPI	BINRD.		;JUMP ON INPUT
BINWR.:	MOVSI	T0,(1B8)	;SET UP THE BEGIN OF RECORD CONTROL WORD
	AOS	G4,T0		;COUNT THIS RECORD LSCW=G4
	MOVS	T1,DD.LOG(P3)	;FIXED LENGTH OUTPUT
	JUMPE	T1,BINWR1	;JUMP IF VARIABLE LENGTH
	ADDI	T0,(T1)		;ADD THE USER'S RECORD SIZE
	AOS	POS.TB(P4)	;DO NOT COUNT CONTROL WORDS
BINWR1:	JSP	P1,OBYTE.	;OUTPUT THE LSCW
	HRRZ	P2,DD.HRO+1(P3)	;SAVE THE LSCW POSITION CLEAR FLAGS
	SETZM	POS.TB+2(P4)	;CLEAR THE RECORD COUNTER
	JRST	BINXIT		;TAKE THE COMMON EXIT


BINRD.:	JSP	P1,IBYTE.	;GET A CONTROL WORD
	JUMPE	T0,IBYTE.	;FIND AN INPUT RECORD
	MOVEM	T0,POS.TB+2(P4)	;SAVE THE LSCW
	HLRZ	T1,T0		;GET THE HIGH ORDER NINE  BIT
	LSH	T1,-^D9		;POSITION THE RECORD TYPE
	CAIN	T1,1		;FOROTS TYPE 1 LSCW
	SOJA	T0,BINRD1	;YES, COUNT THE LSCW
IFN FORSE,<
	JUMPE	T1,BINFSE	;IS IT A FORSE CONTROL WORD
>
	ERROR	(DAT,2,7,)	;NO, ILLEGAL DATA
IFN FORSE,<
BINFSE:	HLRZ	G4,T0		;GENERATE A FOROTS TYPE 1 LSCW
	TLOA	P2,FT.FSE	;SET FORSE BINARY RECORD SEEN
>
BINRD1:	HRRZ	G4,T0		;GET THE SEGMENT COUNT
BINXIT:
IFN CHKSUM,<
	SETZB	G3,POS.TB+1(P4)	;CLEAR THE CHECK SUM COUNTERS
>
;	PJRST	BINCON		;DROP INTO THE BINARY I/O ROUTINES
	SUBTTL BINARY INPUT/OUTPUT ROUTINES SYNC DATA WITH THE I/O LIST

BINCON:			;ENTRY FOR THE NEXT LIST ITEM FROM IOLST%
	JSP	P1,IOLS%%	;GET THE NEXT LIST ITEM
	TLNE	P3,IO.EOL	;END OF RECORD
	JRST	BINCON		;YES IGNORE THE LIST ITEM
	JUMPI	BINRED		;JUMP ON INPUT
	SKIPG	T5,DD.HRO+2(P3)	;IS THE BUFFER FULL/EMPTY
	PUSHJ	P,LSCWW2	;YES, OUTPUT A TYPE 2 LSCW
	TLZE	P2,FT.SLT	;IS THE A SLIST
	CAME	G2,[XWD 1,1]	;IS THE INCREMENT ASSENDING BY 1
	AOJA	G4,BINWRW	;NO DO A WORD TRANSFER


;ROUTINE TO TRANSFER BLOCK OF ARRAYS TO THE OUTPUT BUFFER
		;T0=	I/O DATA ITEM
		;T1=	THE BLT POINTER WORD
		;T2=	NOT USED
		;T3=	NOT USED
		;T4=	THE NUMBER OF WORDS IN THE CURRENT SEGMENT
		;T5=	THE NUMBER OF WORDS LEFT IN THE CURRNT BUFFER
		;G1=	IOWD -SIZE,,ADR
		;G2=	WORDS LEFT TO BE TRANSFERED
		;G3=	CHECK SUM WORD
		;G4=	LSCW
		;P2	ADDRESS OF THE LAST LSCW
		;P3	I/O REGISTER

	HLRE	G2,G1		;GET THE NEGATIVE ARRAY SIZE
	ADDM	G2,POS.TB(P4)	;UPDATE THE COLUMN COUNTER
	SKIPE	DD.LOG(P3)	;FIXED LENGTH OUTPUT
	SKIPLE	POS.TB(P4)	;AND EXCEEDING RECORD SIZE
	JRST	BINSLW		;NO, G2=ARRAY SIZE
	SUB	G2,POS.TB(P4)	;YES, REDUCE THE ARRAY SIZE TO FIT
	TLO	P3,IO.EOL	;LITE THE END OR RECORD FLAG
BINSLW:	MOVMS	T4,G2		;CONVERT TO POSITIVE IN T4 AND G2
	CAILE	T4,(T5)		;WILL THE ARRAY FIT IN THE BUFFER
	MOVEI	T4,(T5)		;NO, GET THE  SPACE LEFT IN THE BUFFER
	SUBI	G2,(T4)		;REDUCE THE ARRAY SIZE BY THE BUFFER SPACE
	ADDI	G4,(T4)		;UPDATE THE LSCW WORD COUNT
	MOVE	T1,DD.HRO+1(P3)	;GET THE BYTE POINTER TO THE BUFFER
	HRLI	T1,(G1)		;GET THE ARRAY ADDRESS (BLT POINTER)
	ADDM	T4,DD.HRO+1(P3)	;UPDATE THE BYTE POINTER
	SUBI	T5,(T4)		;REDUCE THE BYTE COUNTER
	MOVEM	T5,DD.HRO+2(P3)	;STORE THE NEXT BYTE POINTER
	ADDI	T1,1		;POINT TO THE FIRST AVAILABLE BUFFER WORD
	BLT	T1,@DD.HRO+1(P3);TRANSFER THE ARRAY BLOCK
IFN CHKSUM,<
	XOR	G3,(G1)		;ACCUMULATE THE CHECK SUM
	ADDI	G1,1		;UPDAT THE ARRAY POINTER
	SOJG	T4,.-2		;CHECK SUM THE NUMBER OF WORD TRANSFERED
>
IFE CHKSUM,<
	ADDI	G1,(T4)		;UPDATE THE ARRAY ADDRESS
>
	JUMPN	T5,.+3		;IS THE BUFFER FULL
	PUSHJ	P,LSCWW2	;YES, OUTPUT THE BUFFER AND A TYPE 2 LSCW
	MOVE	T5,DD.HRO+2(P3)	;GET THE NUMBER OF FREE WORD IN THE BUFFER
	JUMPN	G2,BINSLW	;IS THE ARRAY DONE
	JRST	BINCON		;YES, GET NEXT IOLST ITEM


;SINGLE WORD DATA TRANSFER ROUTINE (OUTPUT)

BINWRW:	MOVE	T0,(G1)		;GET THE DATA WORD
IFN CHKSUM,<
	XOR	G3,T0		;ACCUMULATE THE CHECK SUM
>
	JSP	P1,OBYTE.	;OUTPUT THE WORD
	SKIPG	T5,DD.HRO+2(P3)	;IS THE OUTPUT BUFFER FULL
	PUSHJ	P,LSCWW2	;YES OUTPUT A CONTROL WORD
	ADD	G1,G2		;COMPUTE THE NEXT VARIABLE ADDRESS
	TLNE	P3,IO.EOL	;CHECK FOR END OF LINE
	JRST	BINCON		;YES, IGNORE THE LIST ITEMS
	JUMPGE	G1,BINCON	;GET THE NEXT IOLST ITEM
	AOJA	G4,BINWRW	;ADD THEIS WORD AND CONTIUE

BINRED:				;BINARY INPUT ROUTINES
	JUMPN	G4,.+3		;IS THE SEGMENT EMPTY
	PUSHJ	P,LSCWR2	;YES READ A TYPE 2 LSCW
	JRST	BINCON		;READ TYPE 3 IGNORE THE LIST
	TLZE	P2,FT.SLT	;IS THERE A SLIST CALL
	CAME	G2,[XWD 1,1]	;AND ASSENDING BY 1
	SOJA	G4,BINRDW	;NO, DO A WORD BY WORD TRANSFER

	HLRE	G2,G1		;GET THE NEGATIVE ARRAY SIZE
BINSLR:	SKIPG	DD.HRI+2(P3)	;GET THE BUFFER ITEM COUNT
	PUSHJ	P,IBLOK.	;BUFFER IS EMPTY
	MOVE	T5,DD.HRI+2(P3)	;GET THE ITEM COUNT
	MOVMS	T4,G2		;GET A POSITIVE COPY IN G2 AND T4
	CAILE	T4,(T5)		;FIND THE SMALLEST VALUE OF
	MOVEI	T4,(T5)		; NUMBER OF WORDS IN THE BUFFER
	CAILE	T4,(G4)		; NUMBER OF WORD IN THE SEGMENT
	MOVEI	T4,(G4)		; AND THE ARRAY SIZE PUT IN T4
	SUBI	G2,(T4)		;REDUCE THE ARRAY SIZE BY THE TRANS.
	SUBI	G4,(T4)		;REDUCE THE LSCW COUNT BY TRANS.
	HRLO	T1,DD.HRI+1(P3)	;GET THE FROM ADDR. (-1)
			;SET RIGHT HALF TO -1 TO FORSE A CARRY ONTO
			;THE LEFT ON THE NEXT INSTRUCTION(ADDS 1 TO LEFT)
	ADDI	T1,1(G1)	;GET THE TO ADDR (ADD 1 TO THE LEFT HALF)
	SUBI	T5,(T4)		;REDUCE THE BUFFER ITEM COUNT
	ADDM	T4,DD.HRI+1(P3)	;UPDATE THE BYTE POINTER
	MOVEM	T5,DD.HRI+2(P3)	;PUT IN THE RING HEADER
	ADDI	G1,(T4)		;UPDATE THE ARRAY ADDRESS
	BLT	T1,-1(G1)	;MOVE THE ARRAY INTO MEMORY
IFN CHKSUM,<
	MOVNS	T4		;NEGATE THE ARRAY SIZE
	HRLI	T4,-1(T4)	;MAKE AN AOBJN POINTER
	ADDI	T4,(G1)		;GET THE ARRAY ADDRES BACK
	XOR	G3,(T4)		;ACCUMULATE THE CHECK SUM
	AOBJN	T4,.-1		;CKECK SUM THE ARRAY
>
	JUMPE	G2,BINCON	;END OF ARRAY GET NEXT LIST ITEM
	JUMPN	G4,BINSLR	;IS THE SEGMENT EMPTY
	PUSHJ	P,LSCWR2	;YES, READ A LSCW TYPE 2
	JRST	BINCON		;IGNORE THE I/O LIST
	JRST	BINSLR		;CONTINUE THE ARRAY

BINRDW:				;ENTRY TO DO A WORD BY WORD DATA TRANSFER
	JSP	P1,IBYTE.	;GET A DATA ITEM
	MOVEM	T0,(G1)		;STORE THE DATA IN MEMORY
IFN CHKSUM,<
	XOR	G3,T0		;ACCUMULATE THE CHECK SUM
>
	ADDB	G1,G2		;UPDATE THE MEMORY ADDRESS
	JUMPGE	G1,BINCON	;END OF LIST GET NEXT LIST ITEM
	SOJGE	G4,BINRDW	;IS THE SEGMENT EMPTY
	PUSHJ	P,LSCWR2	;READ A TYPE 2 LSCW
	JRST	BINCON		;IGNORE THE I/O LIST
	JRST	.-3		;MAY BE A NULL SEGMENT
	SUBTTL LSCWXX ROUTINE TO PROCESS THE LOGICAL SEGMENT CONTROL WORDS
;	ROUTINE TO OUTPUT A TYPE 2 LSCW ON THE CURRENT DEVICE
;	CALL
;	PUSHJ	P,LSCWW2
;	(RETURN)

LSCWW2:
	TLNN	P3,IO.NON	;SKIP CONTOL WORD FOR NON STANDARD
	SKIPE	DD.LOG(P3)	;FIXED LENGTH OUTPUT (RANDOM)
	PJRST	OBLOK.		;YES, DUMP THE BLOCK (DON'T RETURN)
IFN CHKSUM,<
	JSP	P1,CHKSM.	;DO A FOLDED CHECK SUM ON G3 RESULT IN T1
	TLO	G4,(T1)		;INSERT THE CHECK SUM IN THE LSCW
	XORM	G4,POS.TB+1(P4)	;ACCUMULATE THE RECORD CHECKSUM
	SETZ	G3,		;INITIALIZE THE CHECK SUM WORD
>
	MOVEM	G4,(P2)		;STORE THE LSCW IN THE BUFFER
	ADD	G4,POS.TB+2(P4)	;GET THE REOCRD COUNT
	HRRZM	G4,POS.TB+2(P4)	;KEEP THE WORD COUNT FOR THE RECORD
	MOVSI	T0,(2B8)	;SET UP A NEW CONTROL WORD
	AOS	G4,T0		;GET THE CONTINUE LSCW IN G4
	JSP	P1,OBYTE.	;OUTPUT THE LSCW
	HRR	P2,DD.HRO+1(P3)	;SAVE THE POSITION OF THE LSCW
	POPJ	P,		;RETURN

;	ROUTINE TO READ THE NEXT LSCW TYE 2
;	CALL
;	PUSHJ	P,LSCWR2
;	(RETURN)		;TYPE 3 LSCW FOUND
	;	(RETURN)	;TYPE 2 LSCW FOUND
;				;CALLS THE ERROR MACRO ON ERROR

LSCWR2:			;READ A TYPE 2 LSCW
IFN FORSE,<
	TLNN	P2,FT.FSE	;IS THIS A FORSE RECORD
	JRST	LSCWFSE		;NO, GO TO FOROTS ROUTINE
	SETZM	DD.HRI+2(P3)	;CLEAR THE ITEM COUNT(FORSES NEXT BLOCK)
	HRRZ	T0,POS.TB+2(P4)	;GET THE CURRENT CONTROL WORD COUNT
	JUMPE	T0,.+3		;IS IT A CONTINUE LSCW
	ERROR	(DAT,4,2,)	;NO, I/O LIST GREATER THAN RECORD
	JSP	P1,IBYTE.	;GET THE CONTROL WORD
	HLRZ	G4,T0		;SIMULATE A FOROTS CONTROL WORD
	MOVEM	T0,POS.TB+2(P4)	;SAVE THE FORSE CONTROL WORD
	AOS	(P)		;SKIP
	POPJ	P,		;RETURN
LSCWFSE:>

IFN CHKSUM,<
	JSP	P1,CHKSM.	;COMPUTE THE CHECK SUM ON G3
	HLRZ	T0,POS.TB+2(P4)	;MATCH UP THE CHECK SUMS
	ANDI	T0,777		;ONLY NINE BITS
	JUMPE	T0,.+5		;NO CHECK SUM ON INPUT
	XORI	T0,(T1)		;XOR THE CHECK SUMS
	JUMPE	T0,.+3		;YES MATCHING CHECK SUMS
	ERROR	(DAT,3,7,)	;NO SEGMENT ERROR
	MOVE	T1,POS.TB+2(P4)	;INSERT THE CONTROL INFO
	DPB	T0,[POINT 9,T1,17] ;PUT THE CHECK SUM IN THE RECORD
	XORM	T1,POS.TB+1(P4)	;ACCUMULATE THE REOCRD CHECK SUM
	SETZ	G3,		;CLEAR THE CHECKSUM
>
	JSP	P1,IBYTE.	;GET THE NEXT CONTROL WORD
	MOVEM	T0,POS.TB+2(P4)	;SAVE THE LSCW
	HLRZ	T1,T0		;GET THE CONTROL BITS + CHKSUM
	LSH	T1,-^D9		;POSITION THE CONTROL BITS
	CAIE	T1,2		;IS THIS A TYPE 2 LSCW
	JRST	LSCWR3		;NO, CKECK ON TYPE 3
	SOS	G4,T0		;COUNT THE LSCW IN THE SEGMENT COUNT
	ANDI	G4,-1		;CLEAR THE LEFT HALF
	AOS	(P)		;SKIP RETURN
	POPJ	P,		;RETURN

LSCWR3:		;CHECK ON TYPE 3 LSCW
	CAIE	T1,3		;IS THIS A TYPE 3 CONTROL WORD
	ERROR	(DAT,2,7,)	;NO, ERROR IN THE DATA RECORD
IFN CHKSUM,<
	JSP	P1,CHKSM.	;FOLD THE CHECK SUMB
	HLRZ	T0,POS.TB+1(P4)	;GET THE REOCRD CHECK SUM WORD
	ANDI	T0,777		;ONLY NINE BITS
	JUMPE	T0,.+5		;SKIP IF NO INPUT CHECK SUM
	XORI	T0,(T1)		;COMPARE THE CHECK SUMS
	JUMPE	T0,.+3		;EQUAL IF ZERO
	ERROR	(DAT,3,7,)	;NO CHECK SUM ERROR
>
	TLO	P3,IO.EOL	;SET END OF LINE FLAG
	POPJ	P,		;RETURN FOR TYPE 3 LSCW FOUND
	SUBTTL IOLST% INPUT/OUTPUT LIST PROCESSING ROUTINE

IOLST%:	PUSHJ	P,SAVE.		;SAVE THE USER'S ACS
	SKIPN	P3,IOL.P3(P4)	;RELOAD THE I/O REG
	POPJ	P,		;I/O NOT ACTIVE
	MOVSI	T1,IOL.SV(P4)	;GET THE ADRESS OF THE STATE TABLE
	HRRI	T1,G3		;AND BLT INTO THE AC'S
	BLT	T1,P2		;RESTORE
	TLO	P2,FT.LST	;SET IOLIST SEEN FLAG
IOLST1:	SKIPN	G1,(L)		;GET THE NEXT IOLIST ARGUMENT
	PJRST	IOLSAV		;SAVE THE I/O LIST STATE
	HLRZ	G2,(L)		;GET THE IO LIST ARG TYPE
	LSH	G2,-^D9		;LEFT 9 BITS ONLY
	CAIGE	G2,IOL.MX	;CHECK FOR AN IMPLIED FIN CALL
	JRST	@IOLST(G2)	;GO TO THE CORRECT ROUTINE
ELIST:
ELISTX:
XLIST:
IOLST2:	ERROR	(SYS,2,10,FIN%%)	;NO,IOLST ARGUMENT ERROR
IOLST:	JRST	IOLST2		;(0) ERROR, ZERO NOT ALLOWD
	JRST	DATA		;(1) DATA ARGUMENT
	JRST	SLIST		;(2) SLIST ARUMNET
	JRST	ELIST		;(3) ELIST ARGUMENT
	JRST	FIN%%		;(4) IO FINISHED
	JRST	XLIST		;(5) XLIST ARGUMENT
IOL.MX==.-IOLST		;IOLST TABLE SIZE

;REENTRY POINT TO THE IOLST% ROUTINE FOR NEXT VARIABLE

IOLS%%::TLNN	P2,FT.LST	;HAS AN I/O LIST BEN SEEN
	PJRST	IOLSAV		;NO, SAVE THE STATE TABLES
	TLNN	P2,FT.SLT!FT.ELT	;IS A LIST IN PROCESS
	AOJA	L,IOLST1	;NO, GET NEXT ARGUMENT
	TLNN	P2,FT.ELT	;YES, GO TO CORRECT LIST ROUTINE
	JRST	SLISTX		;SLIST LIST IN PROCESS
	JRST	ELISTX		;ELIST LIST IN PROCESS


;	ROUTINE TO SAVE THE STATE OF THE I/O LIST
IOLSAV:
	MOVEI	T1,IOL.SV(P4)	;GET THE SAVE AREA ADDRESS
	HRLI	T1,G3		;BLT TO SAVE THE AC'S FOR A USER'S RETURN
	BLT	T1,IOL.P3(P4)	;SAVE AC'S G3-P3
CPOPJ:	POPJ	P,		;RETURN FOR THE NEXT LIST ITEM
	SUBTTL SLIST INPUT/OUTPUT LIST ROUTINE

SLIST:	ADDI	L,2		;STEP TO THE ARRAY ADDRESS
	TLO	P2,FT.SLT	;SET SLIST FLAG
DATA:
	JSP	P1,EFCTVL	;GET THE ADDRESS
	TRNN	G1,-20		;IN THE AC SAVE AREA
	ADDI	G1,ACC.SV(P4)	;YES, RELOCATE TO THE SAVE AREA
	HLRZ	T5,(L)		;GET THE ARG TYPE CODE
	LSH	T5,-5		;POSITION
	ANDI	T5,17		;FOUR BITS ONLY
	TLNN	P2,FT.SLT	;SLIST I/O
	JRST	DATA0		;NO, GO TO THE DATA ROUTINE
	MOVEI	G2,(G1)	;PUT THE ADDRESS IN A SAFE PLACE
	MOVE	G1,-2(L)	;GET THE #ELEMENT ADDRESS
	JSP	P1,EFCTV1	;GET THE #ELEMENTS
	MOVNS	G1		;NEGATE IT
	CAIE	T5,TP%DOR	;IS THE VARIABLE IN THE DOUBLE PRECISION
	CAIN	T5,TP%COM	;OR COMPLEX
	ASH	G1,1		;YES, DOUBLE THE ARRAY SIZE
	HRLI	G2,(G1)		;BUILD A IOWD WORD - SIZE,,ARRAY
	MOVE	G1,-1(L)	;GET THE OFFSET ADDRESS
	JSP	P1,EFCTV1	;GET IT
	TRNN	G1,400000	;CHECK FOR A NEGATIVE INCREMENT
				;IF THE INCREMENT IS <0 WE GET A FREE
				;CARRY IN BIT 17. THEREFORE DO NOT ADD
				;IN THE DECREMENT CONSTANT 1. THE HARDWARE
				;DOES IT FREE.
	HRLI	G1,1		;ADD IN A 1 FOR THE DECREMENT CONSTANT
				;ON A POSITIVE OR ZERO INCREMENT
	EXCH	G1,G2		;PUT THE ITEM COUNT IN G2
	SKIPE	T4,1(L)		;LOOK AT THE NEXT ENTRY
	TLNE	T4,777000	;IS THIS AN EXTENDED SLIST
	JRST	SLIST1		;NO, CONTINUE
SLIST1:	TLNN	P3,IO.FMT	;FORMATED I/O
	JRST	DATA2		;NO, UN-FORMATED I/O
	CAIN	T5,TP%DOR	;YES, DOUBLE PRECISION REAL
	ASH	G2,1		;YES, DOUBLE UP THE INCREMENT
	JRST	DATA2		;CONTINE AT THE DATA ROUTINE

SLISTX:				;ENTRY FOR THE NEXT ITEM FROM SLIST
	MOVE	G1,DAT.TP+1(P4)	;GET THE INCREMENT
	ADDB	G1,DAT.TP(P4)	;GET THE NEXT ADDRESS IN G1/DAT.TP
	JUMPL	G1,(P1)		;YES, RETURN TO FORMAT STATEMENT
	TLZ	P2,FT.SLT	;CLEAR SLIST FLAG
	AOJA	L,IOLST1	;END OF SLIST GET NEXT ARG


;DATA INPUT/OUTPUT LIST ROUTINE

DATA0:	CAIN	T5,TP%COM	;IS THE VARIABLE COMPLEX
	JRST	DATA1		;YES, ALWAYS "SLIST"
	CAIN	T5,TP%DOR	;IS VARIABLE DOUBLE REAL
	TLNE	P3,IO.FMT	;AND FORMATED
				;OR SINGLE PRECISION
	JRST	DATA3		;YES, EXIT I/O PROCESSIN ROUTINE
DATA1:	HRLI	G1,-2		;BUILD AN SLIST CONTROL WORD
	MOVE	G2,[XWD 1,1]	;SET THE INCREMENT TO 1
DATA2:	TLO	P2,FT.SLT	;SET THE SLIST FLAG
DATA3:	DMOVEM	G1,DAT.TP(P4)	;SAVE THE SLIST CONTROL WORDS
	MOVEM	T5,DAT.TP+2(P4)	;SAVE THE VARIABLE TYPE FOR G FORMAT
	MOVE	P1,IOL.P1(P4)	;GET THE RETURN ADDRESS
	JRST	(P1)		;RETURN TO THE CALLER
	SUBTTL FIN INPUT/OUTPUT LIST TERMINATION ROUTINE
FIN%:	PUSHJ	P,SAVE.		;SAVE THE USER'S ACS
	SKIPN	P3,IOL.P3(P4)	;GET THE SYSTEM AC'S
	POPJ	P,		;NO, I/O IN PROCESS (RETURN)
	MOVE	P2,IOL.P2(P4)	;GET THE OTHER AC
	DMOVE	G3,IOL.G3(P4)	;RELOAD THE SYSTEM G REG'S (G3,G4)

FIN%%:			;ENTRY FROM THE IO LIST ROUTINE (FIN IMPLIED)

	TLO	P2,FT.FIN	;SET THE FIN FLAG FOR ENDLN.
	TLNN	P3,IO.FMT	;IS THIS FORMATED I/O
	JRST	FINBIN		;NO, BINARY I/O
	TLNE	P2,FT.LSD	;LIST DIRECTED I/O
	JRST	FINF1		;YES, SKIP THE FORMAT STATEMENT CLEAN UP
	MOVE	T1,FST.DY(P4)	;PICK UP THE FORMAT STATMENT POINTER
	MOVE	T2,(T1)		;GET THE PAREN STACK POINTER
	HLRS	T2		;GET THE DEPTH IN BOTH HALFS
	EXCH	T2,@FST.DY(P4)	;SWAP THE POINTERS
	SUBM	T2,@FST.DY(P4)	;ADJUST THE PAREN STACK
	HRRZI	T1,-2(T1)	;GET THE POINTER TO THE ENCODED FMT STACK
	SKIPGE	(T1)		;CHECK FOR DELETION OF ENCODED STACK
	PUSHJ	P,GET12		;YES, DEALLOCATE THE ENCODED STACK
	TLNE	P3,IO.EDC	;ENCODE/DECODE REQUEST
	JRST	[JUMPI	FINXI1	;JUMP ON DECODE
		MOVEI	T0," "	;GET A BLANK
		JSP	P1,OBYTE.;BLANK OUT THE ARRAY
		TLNN	P3,IO.EOL;CHECK FOR END
		PJSP	OBYTE.	;CONTINUE
		POPJ	P,]		;RETURN
FINF1:	PUSHJ	P,ENDLN.	;FINISH UP THIS LINE
	TLZ	P3,IO.STR	;CLEAT THE STRING BIT
	JUMPO	FINXIT		;JUMP ON OUTPUT
	MOVEM	P3,RER.SV(P4)	;SAVE THE REREAD DEVICE
FINXIT:	SKIPE	T1,DD.ASC(P3)	;IS THERE AN ASSOCIATE VARIABLE
	AOS	(T1)		;YES UPDATE IT
FINXI0:	HLRZ	T1,DD.UNT(P3)	;GET THE CHANNEL NUMBER
	LSH	T1,-5		;POSITION TO MAKE AN OFFSET
	ADDI	T1,CHN.TB(P4)	;GET THE LOCATION OF THE CHANNEL TABLE
	MOVEM	P3,(T1)		;SAVE THE I/O REG CHANNEL STATUS
FINXI1:	SETZM	IOL.P3(P4)	;CLEAR THE I/O REGISTER
	POPJ	P,		;RETURN TO THE USER


FINBIN:	TLNE	P3,IO.NON	;NON-STANDARD I/O
	JRST	FINXIT		;YES, JUST EXIT
	JUMPI	FINBI1		;JUMP ON INPUT
	SKIPN	DD.LOG(P3)	;CHECK FOR FIXED LENGTH RECORD
	JRST	.+5		;NO, JUMP
	SETZ	T0,		;CLEAR THE OUTPUT WORD
	MOVEI	P1,.+1		;SET UP A RETURN FROM OBYTE.
	TLNN	P3,IO.EOL	;AT END OF LINE
	AOJA	G4,OBYTE.	;NO, OUTPUT A PADDING WORD
IFN CHKSUM,<
	JSP	P1,CHKSM.	;DO A FOLDED CHECK SUM ON G3
	TLO	G4,(T1)		;INSERT IN THE CONTROL WORD
>
	SKIPN	DD.LOG(P3)	;NO TYPE CONTROL WORD FOR FIXED LENGTH
	MOVEM	G4,(P2)		;INSERT THE LSCW IN THE BUFFER
IFN CHKSUM,<
	XORM	G4,POS.TB+1(P4)	;ACCUMULATE THE TOTAL RECORD CHECK SUM
	MOVE	G3,POS.TB+1(P4)	;GET THE TOTAL CHECK SUM
	JSP	P1,CHKSM.	;COMPUTE THE RECORD CHECK SUM
>
	MOVSI	T0,(3B8)	;SET UP THE END OF RECORD LSCW
	HRR	T0,POS.TB+2(P4)	;GET THE TOTAL RECORD COUNT (WORDS)
	ADDI	T0,1(G4)	;SET WORD COUNT TO PREVIOUS RECORD OF BOF
IFN CHKSUM,<
	TLO	T0,(T1)		;INSET THE RECORD CHECKSUM
>
	TLZ	P3,IO.EOL	;CLEAR END OF LINE FLAG
	JSP	P1,OBYTE.	;OUTPUT THE TERMINING LSCW
	PJRST	FINXIT		;RETURN
FINBI1:	TLZE	P3,IO.EOL	;END OF LOGICAL RECORD
	JRST	FINXIT		;YES, EXIT(NEXT RECORD READ LATER)
IFN FORSE,<
	TLNN	P2,FT.FSE	;PROCESSING FORSE RECORD
	JRST	FINFS1		;NO, GO TO FOROTS
	SETZM	DD.HRI+2(P3)	;CLEAR THE ITEM COUNT
	MOVE	T1,DD.HRI(P3)	;GET THE ADDRESS OF THE BUFFER
	HRRZ	T0,2(T1)	;GET THE FORSE CONTROL WORD
	JUMPN	T0,FINXIT	;POSTIONED AT NEXT RECORD
	PUSHJ	P,IBLOK.	;NO GET THE NEXT INPUT BLOCK
	JRST	.-4		;CHECK THIS RECORD
FINFS1:>

	JUMPE	G4,FINBI4	;IS THE CURRENT SEGMENT DEPLEATED
FINBI2:	JSP	P1,IBYTE.	;NO, GET THE NEXT WORD
IFN CHKSUM,<
	XOR	G3,T0		;ACCUMULATE THE CHECKSUM
>
FINBI3:	SOJG	G4,FINBI2	;CONTINUE THIS SEGMENT
FINBI4:	PUSHJ	P,LSCWR2	;READ ANOTHER LSCW TYPE 2
	JRST	FINBI1		;EXIT, "LSCWR2" CLEANS UP THE RECORD
	AOJA	G4,FINBI3	;CONTINUE SCANNING TYPE 2 FOUND
				;PROTECT AGAINST A NULL SEGMENT BY ADDING 1
	SUBTTL	FMTXXX ROUTINE TO INITIALIZE THE FORMAT SCANNER

	INTERNAL	OPOINT,WPOINT,DPOINT


OPOINT:	POINT	5,G4,4	;BYTE POINTER TO THE OP CODE IN THE FS STACK
DPOINT:	POINT	6,G4,10	;BYTE POINTER TO THE D FIELD IN THE FS STACK
WPOINT:	POINT	7,G4,17	;BYTE POINTER TO THE W FIELD IN THE FS STACK

FMTSRC:	SKIPN	G1,2(L)		;LIST DIRECT I/O
	JRST	LSTDR%%##	;YES, PROCESS THE LIST DIRECTED I/O
	JUMPL	G1,FMTSR0	;STATEMENT NOT TO BE RETAINED
	MOVEI	G3,FMT.DY(P4)	;GET THE START OF THE ENCODED LIST
	HRRZ	T1,(G3)		;LOAD POSSIBLE FMT POINTER TO LIST
	JUMPE	T1,FMTSR0	;CHAIN DOES NOT EXIST
	CAMN	G1,1(T1)	;SEARCH FOR A MATCHING ENCODED FMT
	AOJA	T1,FMTSR1	;FOUND A STACK POINTER THAT MATCHES
	HRRZ	G3,T1		;NO,STEP POINTER TO NEXT ENTRY
	HRRZ	T1,(T1)		;LOAD NEXT FMT POINTER IN LIST
	JUMPN	T1,.-4		;IF NOT AT THE ENT4, GET NEXT POINTER
FMTSR0:	HRRZI	G2,-1(G1)	;GET THE LOCATION OF THE FORMAT STAT.
	HRLI	G2,(POINT 7,0,34)	;BUILD AN ASCII BYTE POINTER
	MOVEM	G2,FBG.BP(P4)	;SAVE THE BYTE POINTER TOT THE FORMAT STATEMENT
	HLRZ	T0,G1		;FETCH THE SIZE OF THE FORMAT STATEMENT
	ANDI	T0,377777	;CLEAR THE ENCODING FLAG
	MOVEM	G2,FEN.BP(P4)	;STORE THE BEGINNING OF THE FMT
	ADDM	T0,FEN.BP(P4)	;UPDATE TO THE END OF THE FMT
	ASH	T0,2		;DOUBLE THE STACK SIZE
	ADDI	T0,^D25		;INCREASE THE SIZE OF THE ARRAY
	PUSHJ	P,GETOWN	;GET MEMORY FOR THE ENCODING
	JUMPL	G1,FMTSR1+1	;DO NOT LINK UNWANTED ENCODED BLOCKS
	HRRM	T1,(G3)		;LINK THE CORE BLOCKS
	SOSA	(G3)		;MAKE THE POINTER RIGHT
FMTSR1:	SETZ	G2,		;SET G2_0 FORMAT ALREADY ENCODED
	MOVN	P2,-1(T1)	;GET THE ENCODED ARRAY SIZE
	HRRI	P2,-1(T1)	;BUILD THE ENCODE STACK POINTER
	PUSH	P2,G1		;PUT THE FORMAT LOCATION ON THE STACK
	AOS	1(P2)		;UPDATE THE ACTIVITY COUNT
	ADD	P2,[XWD 2,2]	;ALOCATE ROOM FOR THE PAREN STACK POINTER
	HRRZM	P2,FST.DY(P4)	;SAVE THE ORGIN OF THE FMT STACK
	JUMPE	G2,FSXXEQ	;GO TO FORMAT STATEMENT DECODER
	MOVSI	G1,1		;SET INITIAL LEFT PAREN POINTER
	MOVEM	G1,LPN.BP(P4)	;SAVE THE INITIAL LEFT PAREN POINTER
	SETZB	G1,G3		;CLEAR THE PAREN COUNTERS
;	JRST	FMTINE		;CONVERT ASCII FORMAT TO ENCODED LIST
	SUBTTL FMTXXX JUMP TABLES FOR THE FORMAT SCANNER
FMTINE:	SETZB	G4,T5		;ZERO THE FORMAT DESCRIPTOR WORD
FMTRIN:	SETZ	T1,		;ZERO THE DIGIT COUNTER
FMTIN:	ILDB	T2,G2		;NEXT FORMAT CHARACTER
	CAIN	T2,11		;CHECK FOR A <TAB>
	JRST	FMTIN		;IGNORE ALL TABS AS DESCRIPTORS
	TRZ	T2,100		;CLEAR THE HIGH ORDER BIT OF THE ASCII
	TRC	T2,40		;CONVERT THE ASCII TO SIXBIT
	MOVE	T3,T2		;SAVE THE CHARACTER IN B
	IDIVI	T3,6		;SET UP FOR A TABLE INDEX
	LDB	T3,FMTPTR(T4)	;LOAD TABLE INDEX
	HRRZ	T4,FMTDIS(T3)	;LOAD DISPATCH ADDRESS
	JRST	(T4)		;GO TO THE ROUTINE
FMTPTR:	REPEAT 6,<POINT 6,FMTIR(T3),35-<.-FMTPTR>*6> ;INDEX POINTER IRTAB
FMTIR:
;				 %,  $, #, ", !,SPACE
	BYTE	(6)		EE,%DL,EE,EE,EE,%S

;				 +, *, ) , ( , ', &
	BYTE	(6)		%S,EE,%RP,%LP,%Q,EE

;				 1, 0, /, ., -, ,,
	BYTE	(6)		%N,%N,%Z,%W,%M,%C

;				 7, 6, 5, 4, 3, 2
	BYTE	(6)		%N,%N,%N,%N,%N,%N

;				 =, <, ;, :, 9, 8
	BYTE	(6)		EE,EE,EE,EE,%N,%N

;				 C, B, A, @, ?, >
	BYTE	(6)		EE,%B,%A,EE,EE,EE

;				 I, H, G, F, E, D
	BYTE	(6)		%I,%H,%G,%F,%E,%D

;				 O, N, M, L, K, J
	BYTE	(6)		%O,EE,EE,%L,EE,EE

;				 U, T, S, R, Q, P
	BYTE	(6)		EE,%T,EE,%R,EE,%P

;				 [, Z, Y, X, W, V
	BYTE	(6)		EE,EE,EE,%X,EE,EE

;				       _, ^, ], \
	BYTE	(6)		EE,EE,EE,EE,EE,EE

FMTDIS:
	PHASE	0		;SET TABLE ORGIN TO 0
EE:!	XWD	FSXLRP,FMTERR	; ; ILLEGAL CHARACTER IN FORMAT STATEMENT
%B:!	XWD	FSXI,FMTOPS	;I; INTEGER I/O(DEFAULT FOR UNDEFINED)
%L:!	XWD	FSXL,FMTOPS	;L; LOGICAL VARIABLE I/O
%I:!	XWD	FSXI,FMTOPS	;I; INTEGER VARIABLE
%A:!	XWD	FSXA,FMTOPS	;A; ALPHA I/O
%F:!	XWD	FSXF,FMTOPS	;F; FLOATING POINT I/O
%E:!	XWD	FSXE,FMTOPS	;E; POWERS OF 10 FLOATING POINT I/O
%O:!	XWD	FSXO,FMTOPS	;O; OCTAL I/O
%G:!	XWD	FSXG,FMTOPS	;G; VARIABLE OUTPUT FORMAT I/O
%D:!	XWD	FSXD,FMTOPS	;D; DOUBLE PRECISION FLOATING POINT I/O
%R:!	XWD	FSXR,FMTOPS	;R; ALPHA RIGHT JUSTIFIED
%DAT:!				;   THE ABOVE DESCRIPTORS REQUIRE DATA
%T:!	XWD	FSXT,FMTT	;T; TABBING TO COLUMNS
%Z:!	XWD	FSXZ,FMTZ	;/; END OF LINE
%DL:!	XWD	FSXDL,FMTDL	;$; C-R CONTROL FUNCTION
%IC:!				;   FOLLOWING DESCRIPTOR DO NOT HAVE AN
				;   INTERATION COUNT IN THE RIGHT HALF
%LP:!	XWD	0,FMTLP		;(; LEFT PAREN GROUP START
%RP:!	XWD	FSXRP,FMTRP	;); RIGHT PAREN GROUP END
%X:!	XWD	FSXX,FMTX	;X; SPACING OF COLUMNS
%H:!	XWD	FSXH,FMTH	;H; HOLLERITH STRING I/O
%Q:!	XWD	FSXQ,FMTQ	;'; QUOTE STRING I/O
%P:!	XWD	FSXP,FMTP	;P; FLOATING POINT SCALLING
%V:!	XWD	0,FMTV		; ; DYNAMIC VARIABLE
				;   FOLLOWING DESCRIPTORS DO NOT
				;   GENERATE FS STACK CODES.
%S:!	XWD	0,FMTIN		;+; SPACE OF PLUS IGNORE
%M:!	XWD	0,FMTM		;-; NEGATIVE SCALE FACTOR
%N:!	XWD	0,FMTN		;0-9; ASCII DIGITS
%W:!	XWD	0,FMTW		;.; SEPERATE W AND D FIELD FOR FLOATING 
%C:!	XWD	0,FMTC		;,; BASIC FIELD SEPERATOR
	DEPHASE			;RETURN TO RELOCATABLE ADDRESSING
FMTERR:	HRLS	G1		;REMOVE ( FROM STACK
	SUB	P,G1		;ADJUST STACK POINTER
	ERROR	(DAT,1,5,)	;ILLEGAL CHARACTER IN FORMAT
	SUBTTL FMTXXX CONVERSION ROUNTINES (FS STACK _ ASCII FORMAT)
;CHARACTER IS A DIGIT		0,1,2,3,4,5,6,7,8,9
FMTN:	IMULI	T1,12		;MULT SUMS BY 10
	ADDI	T1,-20(T2)	;CONVERT SIXBIT TO BINAY AND ADD
	JRST	FMTIN		;RETURN TO FORMAT SCAN

;CHARACTER IS A  P		P
FMTP:	TLZE	T5,FT.SCL	;NEGATIVE SCALING FACTOR
	MOVNS	T1		;YES, NEGATE

;CHARACTER IS A	X
FMTX:	MOVEI	G4,(T1)		;SET SCALING FACTOR IN E OR SPACE COUNT
	DPB	T3,OPOINT	;SET OP CODE IN E
;	JRST	FMTC		;PUSH FS ON THE STACK

;CHARACTER IS A COMMA		,
FMTC:	JSP	P1,FMTPSH	;PUSH DOWN FS IF THERE IS A OP CODE
	JRST	FMTINE		;RETURN TO FORMAT SCAN

;CHARACTER IS A LEFT PAREN	(
FMTLP:	HRLI	T1,1(P2)	;SAVE ABS LOC OF LEFT PAREN ON STACK
	PUSH	P,T1		;SAVE ON SYS STACK FOR RIGHT PAREN
	CAIGE	G3,1(G1)	;HAS NESTING DEPTH INCREASED
	MOVEI	G3,1(G1)	;YES, SAVE THE NEW DEPTH
	AOJA	G1,FMTRIN	;UPDATE () COUNT AND RETURN

;CHARACTER IS A RIGHT PAREN	)
FMTRP:	JSP	P1,FMTPSH	;PUSH DOWN FS STACK IF NECESSARY
	POP	P,G4		;PICK UP LEFT PAREN POINTER AND GROUP
	HLRZ	T4,G4		;LOAD THE ABS LOC OF LEFT PAREN
	SUB	T4,FST.DY(P4)	;CALCUATE THE REL POSITION IN THE FS STACK
	HRL	G4,T4		;BUILD THE RIGHT PAREN STACK WORD
	CAIN	G1,2		;LEVEL 1 PAREN ? COUNTING FROM 1
	MOVEM	G4,LPN.BP(P4)	;LEVEL 1 PAREN SAVE FOR AUTO REPEAT
	SOJLE	G1,FSXEE	;EXIT IF A LEVEL 0 RIGHT PAREN
	DPB	T3,OPOINT	;INSERT RIGHT PAREN OP CODE
	TRNE	G4,777776	;IS THERE A REPEAT COUNT
	PUSH	P2,G4		;YES SAVE THIS POINTER
	JRST	FMTINE		;RETURN TO FORMAT SCAN

;CHARACTER IS A SLASH		/
FMTZ:

;CHARACTER IS A DOLLAR SIGN	$
FMTDL:	JSP	P1,FMTPSH	;PUSH DOWN FS STACK
	MOVEI	G4,1		;SET THE INTERATION COUNT
	DPB	T3,OPOINT	;STORE THE OP CODE
	JRST	FMTC		;SIMULATE A FOLLOWING COMMA

;CHARACTER IS A TEE		T
FMTT:	MOVSI	T0,400000	;SET UP A T FLAG
	IORM	T0,@FST.DY(P4)	;SET THE FLAG FOR A LINE BUFFER
	TLO	T5,FT.TXX	;SET T SEEN IN FORMAT

;CHARACTER IS A BASIC FIELD DESCRIPTOR	A,B,D,E,F,G,I,L,O
FMTOPS:	SKIPN	G4,T1		;IS THE REPEAT COUNT SUPPLIED
	MOVEI	G4,1		;NO, DEFAULT TO 1
	DPB	T3,OPOINT	;SAVE OPCODE IN E
	JRST	FMTRIN		;RETURN TO FORMAT SCAN

;CHARACTER IS A MINUS		-
FMTM:	TLOA	T5,FT.SCL	;SET NEGATIVE SCALE FACTOR FLAG

;CHARACTER IS A PERIOD		.
FMTW:	DPB	T1,WPOINT	;PLACE THE W FIELD IN E
	JRST	FMTRIN		;RETURN TO FORMAT SCAN

;CHARACTER IS A SINGLE QUOTE	'
FMTQ:	HRRZ	T1,FEN.BP(P4)	;LOAD THE END OF FORMAT POINT TO CHECK
	SUBI	T1,-1(G2)	;SUB THE CURRENT POSITION
	IMULI	T1,5		;CONVERT TO CHARACTER
;	JRST	FMTH		;CONTINUE AS A HOLLERITH SCAN

;CHARACTER IS A H		H
FMTH:	PUSH	P2,G2		;SAVE THE BYTE POINTER TO THE FORMAT STRING
FMTH1:	SOJL	T1,FMTH3		;IS THIS THE END
	ILDB	T2,G2		;NO, GET THE NEXT HOLLERITH CHARACTER
	CAIN	T2,"'"		;IS THE CHARACTER A SINGLE QUOTE
	CAIE	T3,%Q		;AND IN SINGLE QUOTE MODE
FMTH2:	AOJA	G4,FMTH1		;NO, COUNT THE CHARACTER
	MOVEM	G2,1(P)		;YES, SAVE POINTER ON THE STACK
	ILDB	T2,G2		;GET LOOK AHEAD CHARACTER
	CAIN	T2,"'"		;DOUBLE SQUOTE CHARACTERS
	AOJA	G4,FMTH2		;YES COUNT BOTH SQUOTES
	MOVE	G2,1(P)		;NO, RELOAD THE CORRECT POINTER
FMTH3:	HRLZS	G4		;PUT THE CHARACTER COUNT IN LEFT
	DPB	T3,OPOINT	;DEPOSITE THE OP CODE
	HLRZ	T1,(P2)		;GET THE BYTE POINTER TO THE STRING
	IDIVI	T1,70000	;COMPUTE THE CHARACTER POSITIION
	DPB	T1,[POINT 3,G4,7] ;SAVE THE RELATIVE CHARACTER POSITION
	HLLM	G4,(P2)		;PUT THE STRING INFO ON THE STACK
	JRST	FMTINE		;RETURN TO THE FORMAT SCAN

;CHARACTER IS A DYNAMIC POINTER	V
FMTV:	PUSH	P2,(G2)		;SAVE THE ADDRESS OF THE VARIABLE
	HRLI	G2,10700		;FORCE THE POINTER TO THE NEXT WORD
	JRST	FMTRIN		;RETURN TO THE FORMAT SCAN

;ROUTINE TO PUSH THE FS STACK 	;ENTER VIA JSP P1,FMTPSH
FMTPSH:	TLNN	G4,760000	;IS THERE AN OP IN E
	JRST	(P1)		;NO RETURN
	TLZE	T5,FT.TXX	;IS THIS A T FORMAT
	JRST	[TSO	G4,T1	;SET THE COLUMN COUNT IN W AND D
		JRST	FMTPS3]	;STORE THE DESCRIPTOR
	TLNE	G4,177		;IS THERE A W FIELD
	JRST	FMTPS1		;YES, STORE THE D FIELD
	CAILE	T1,^D127	;GREATER THE 127
	SETO	T1		;SET 127
	DPB	T1,WPOINT	;STORE THE W FIELD
	JRST	FMTPS3		;CONTINUE
FMTPS1:	CAILE	T1,^D63		;W>63
	SETO	T1,		;SET TO 63
	DPB	T1,DPOINT	;STORE THE D FIELD
FMTPS3:	HLRZ	T1,(P)		;PICK UP POINTER TO LAST LEFT PAREN
	MOVEM	G4,1(P2)	;ASSUME DESCRIPTOR IS NOT BOUNDED
	XOR	G4,(P2)		;COMPARE OPS,W,E ARE EQUAL
	CAIE	T1,1(P2)	;IS E BOUNDED BY A LEFT PAREN
	TLNE	G4,-1		;ARE THE DESCRIPTORS EQUAL
	AOBJN	P2,.+3		;NO, UPDATE THE STACK POINTER
	HRRZ	G4,1(P2)	;YES, UPDATE THE INTERATION COUNT
	ADDM	G4,(P2)		;INCREMENT THE IC FOR NEW E
	SETZB	G4,T1		;CLEAR THE OPS,W,E AND IC FIELDS
	JRST	(P1)		;RETURN

;ROUTINE TO CLEAN UP THE ENCODED FORMAT LIST AND RETURN TO THE USER

FSXEE:	PUSH	P2,LPN.BP(P4)	;SETUP LAST LEFT PAREN FOR RESCAN
	PUSH	P2,[0]		;SET A NULL FOR THE PAREN STACK
	HRRM	P2,@FST.DY(P4)	;SET THE PAREN STACK POINTER
	LSH	G3,1		;DOUBLE THE PAREN STACK SIZE
	HRLS	G3		;SET TO ADD INTO THE STACK POINTER
	ADD	P2,G3		;UPDATE THE ENCODED STACK SIZE
	AOBJP	P2,[ERROR (SYS,,,)] ;STACK WILL NOT FIT
	SKIPGE	2(L)		;IS THE FMT ENCODED LIST TO BE RETAINED
	JRST	FSXXEQ		;NO, DON'T RELEASE UNUSED ARRAY SPACE
	HLLO	T2,P2		;GET THE REMAINING SPACE FROMT THE POINTER
	ADD	T2,[XWD 1,1]	;ADD 2 LEFT, 0 RIGHT CHECK ERRORS
	HRRZ	T1,FST.DY(P4)	;GET THE STARTING LOCATION
	ADDM	T2,-3(T1)	;REDUCE THE CORE BLOCK COUNT BY UNUSED SPACE
	MOVNS	T2		;MAKE THE UNUSED SPACE COUNT POSITIVE
	HLLZM	T2,2(P2)	;BUILD A NEW CORE BLOCK POINTER
	HRRI	T1,3(P2)	;MAKE A POINTER TO THE FREE BLOCK
	PUSHJ	P,GET12		;DELETE THE UNUSED CORE SPACE
FSXXEQ:	SETZM	SCL.SV(P4)	;CLEAR THE SCALE FACTOR
	HRRZ	P2,FST.DY(P4)	;SET THE ENCODE LIST POINTER
	TLNN	P3,IO.EDC!IO.STR;ENCODE/DECODE/STRING
	SKIPL	(P2)		;LINE BUFFER REQUIRED FOR T FORMAT
	JRST	FSXXE1		;NO, CONTINUE
	PUSHJ	P,SETSTR	;SET UP A STRING BUFFER
FSXXE1:	ADDI	P2,1		; AND POINT TO THE FIRST DESCRIPTOR
;	JRST	FSXNXT		;GO DISPATCH ON ENCODED FORMAT
	SUBTTL FSXXXX	ROUTINES TO DISPATCH OF THE ENCODED STACK
FSXNXT:	MOVE	G4,(P2)		;LOAD E WITH STACK ELEMENT FOR DISPAT
	HRRZM	G4,LPN.BP(P4)	;SAVE A POSSIBLE INTERATION COUNT
FSXREP:	LDB	T3,OPOINT	;GET OP CODE FOR TABLE DISPATCH
	HLRZ	G3,FMTDIS(T3)	;GET DISPATCH ADDRESS
	TLZ	P2,FT.ETP!FT.GTP!FT.PRC!FT.LSD ;YES, CLEAR THE CONVERSION TYPE
	CAIL	T3,%DAT		;IS DATA REQUIRED FOR THIS FIELD DISC.
	JRST	(G3)		;NO, GO TO CONVERSION ROUTINE
	TLNN	P2,FT.LST	;HAS AN I/O LIST BEEN SEEN
	JUMPE	T3,FSXLR1	;NO, AND  LAST RIGHT PAREN
	JSP	P1,IOLS%%	;NO, GET THE NEXT I/O LIST ITEM
FSXCON:	PUSHJ	P,(G3)		;NO, DO THE CONVERSION
FSXRTN:	SOSG	LPN.BP(P4)	;REDUCE INTERATION COUNT
	AOJA	P2,FSXNXT	;GET NEXT DESCRIPTOR FROM FS
	MOVE	G4,(P2)		;RELOAD THE SAVE DESCRIPTOR
	JRST	FSXREP		;REEXECUTE THE SAME DESCRIPTOR

FSXRP:				;ROUTINE TO PROCESS THE RIGHT PAREN
	MOVE	P1,@FST.DY(P4)	;GET THE PAREN STACK POINTER
	HRRZ	T4,-1(P1)	;LOAD THE FS POINTER OF THE LAST PAREN
	CAIE	T4,(P2)		;IS THIS THE SAME PAREN OR NESTING
	JRST	FSXRP2		;NESTING OF PARENS
FSXRP0:	SOSLE	(P1)		;SAME PAREN REDUCE THE INTERATION COUNT
	JRST	FSXRP1		;NOT THE END OF INTERATION
	SUB	P1,[XWD 2,2]	;END OF INTERATION, REMOVE POINTERS
	MOVEM	P1,@FST.DY(P4)	;SAVE THE NEW STACK POINTER
	AOJA	P2,FSXNXT	;RETURN FOR NEXT DESCRIPTOR
FSXRP1:	HLR	P2,-1(P1)	;MODIFY FS TO LEFT PAREN POSITION RELAT.
	TRZ	P2,760000
	ADD	P2,FST.DY(P4)	;ADJUST TO STACK ORGIN
	JRST	FSXNXT	;RETURN
FSXRP2:	PUSH	P1,G4		;PUT THE RELATIVE POSITION ON THE STACK
	HRRM	P2,(P1)		;PUT THE FS POSITION ON THE STACK
	PUSH	P1,LPN.BP(P4)	;PUT THE INTERATION COUNT ON
	MOVEM	P1,@FST.DY(P4)	;SAVE THE PAREN STACK POINTER
	JRST	FSXRP0		;PROCESS THIS LEFT PAREN


FSXLRP:				;LAST RIGHT PAREN FOR AUTO REPEAT
	HLR	P2,G4		;GET THE RELATIVE ADDRESS OF THE LEFT PAREN
	ADD	P2,FST.DY(P4)	;RELOACTE TO DISCRIPTOR ADDRESS
	PUSHJ	P,NXTLN.	;MORE IO LIST AND LAST RIGHT PAREN
				; GET THE NEXT RECORD
	POP	P,(P)		;POP OFF THE RETURN ADDRESS
	SKIPE	T1,DD.ASC(P3)	;IS THERE AN ASSOCITE VARIABLE
	AOS	(T1)		;YES, UPDATE IT
	JRST	FSXNXT		;GET THE NEXT DESCRITPOR

FSXLR1:			;LAST RIGHT PAREN WITH OUT AN I/O LIST
	JSP	P1,IOLS%%	;SEE IF A VARIABLE EXISTS IN THE LIST
	ERROR	(DAT,6,2,FIN%%);INPUT OUTPUT WITHOUT DATA CONVERSION
	SUBTTL FSXXXX CONVERSION ROUTINE NOT REQUIRING UUO DATA
FSXX:	MOVEI	T4,OBYTE.	;LOAD OUTPUT ROUTINE ADDRESS
	SKIPL	P3		;INPUT OR OUTPUT
	MOVEI	T4,IBYTE.	;INPUT, LOAD INPUT IO ADDRESS
	HRLI	G4,0		;CLEAR THE OPS FIELD RT= COUNT
	MOVEI	0," "		;LOAD A BLANK
	JSP	P1,(T4)		;OUTPUT A SPACE OR SKIP AN INPUT COLUMN
	SOJG	G4,.-2		;CONTINUE UNTIL COUNT =0
	AOJA	P2,FSXNXT	;RETURN FOR NEST DESCRIPTOR

FSXP:	HRRZM	G4,SCL.SV(P4)	;SAVE THE CURRENT SCALE FACTOR
	AOJA	P2,FSXNXT	;RETURN FOR NEXT DESCRIPTOR

FSXH:				;H CONVERSION
FSXQ:				;SINGLE QUTOE CONVERSION
	HLRZ	T4,(P2)		;LOAD THE NUMBER OF CHARACTER IN THE STR
	ANDI	T4,1777		;CLEAR OUT THE JUNK
	JUMPE	T4,FSXIQ3	;EXIT ON ZERO LENGTH
	LDB	T1,[POINT 3,G4,7];LOAD THE RELATIVE CHARACTER POSITION
	IMULI	T1,70000	;COMPUTE THE NUMBER OF BITS TO THE RIGHT
	HRLI	G4,10700(T1)	;INSERT THE BYTE SIZE AND POSITION
	JUMPO	FSXOQ1		;JUMP ON OUTPUT
FSXIQ1:	JSP	P1,IBYTE.	;GET THE NEXT INPUT BYTE
	CAIE	T3,%Q		;SINGLE QUOTE MODE
	JRST	FSXIQ2		;NO, H CONVERSION
	CAIN	0,"'"		;SINGLE QUOTE MODG4, QUOTE IN INPUT
	MOVEI	0,42;"		;YES, REPLACE WITH DOUBLE QUOTE
FSXIQ2:	IDPB	0,G4		;PUT THE BYTE IN THE FORMAT STATEMENT
	SOJG	T4,FSXIQ1	;REDUCE COUNT AND RETURN FOR NEXT CHAR
FSXIQ3:	AOJA	P2,FSXNXT	;RETURN FOR NEXT DESCRIPTOR

FSXOQ1:	ILDB	0,G4		;LOAD NEXT OUTPUT CHARACTER
	CAIE	T3,%Q		;SINGLE QUOTE MODE
	JRST	FSXOQ2		;NO, H CONVERSION
	CAIE	0,"'"		;SINGLE QUOTE IN OUTPUT
	JRST	FSXOQ2		;NO, CONTINUE
	IBP	G4		;YES, IGNORE
	SUBI	T4,1		;REDUCE COUNT FOR SINGLE QUOTE
FSXOQ2:	JSP	P1,OBYTE.	;OUTPUT THIS STRING CHARACTER
	SOJG	T4,FSXOQ1	;REDUCE COUNT AND CONTINUE
	AOJA	P2,FSXNXT	;RETURN FOR NEXT FIELD DESCRIPTOR

FSXZ:				;END OF LINE ROUTINE
	PUSHJ	P,NXTLN.		;DO END OF LINE STUFF
	SKIPE	T1,DD.ASC(P3)	;IS THERE AN ASSOCIATE VARIABLE
	AOS	(T1)		;YES, UPDATE IT
	SOSLE	LPN.BP(P4)	;COUNT THE INTERATIONS
	JRST	FSXZ		;DO IT AGAIN
	AOJA	P2,FSXNXT	;GET THE NEXT DESCRIPTOR

FSXDL:	JUMPI	FSXDL1		;IGNORE ThE $ ON ONPUT
	TLNE	P3,IO.TTA!IO.TTY;IS THIS THE USER'S TTY
	TLO	P2,FT.DOL	;YES, TTY DOINT OUTPUT
FSXDL1:	AOJA	P2,FSXNXT	;GET THE NEXT DESCRIPTOR
	SUBTTL	FSXT T FORMAT ROUTINE
FSXT:
	HLRZ	T3,G4		;GET THE COLUMN POSITION
	ANDI	T3,17777	;SAVE 13 BITS FOR THE COLUMN
	MOVEI	T5,DD.HRI(P3)	;GET THE INPUT HEADER
	JUMPI	FSXT1		;JUMP ON INPUT
	MOVEI	T5,DD.HRO(P3)	;GET THE OUTPUT RING HEADER
	SOJGE	T3,FSXT2	;JUMP IF GE = 0
FSXT1:	JUMPGE	T3,FSXT2	;JUMP IF A VALID T
	SETZ	T3,		;MAKE IT ZERO
FSXT2:	CAILE	T3,^D136	;MAX T FORMAT FOR NOW
	MOVEI	T3,^D136	;SET TO MAX
	PUSH	P,T3		;SAVE THE COLUMN
	IDIVI	T3,5		;CONVERT TO WORD/CHARACTERS
	HRLI	T3,(POINT 7)	;SET UP THE BYTE POINTER
	JUMPE	T4,FSXT3	;JUMP IF NO CHARACTERS
	IBP	T3		;SET OVER A CHARACTER
	SOJG	T4,.-1		;INCREMENT THE BYTE POINTER UNTIL CORRECT
FSXT3:	MOVE	T2,(T5)		;GET THE BUFFER ADDRESS
	ADDI	T3,3(T2)	;MAKE THE BYTE POINT IN THE BUFFER
	HRRZ	T4,1(T5)	;GET THE CURRENT POINTER
	SUBI	T4,3(T2)	;MINUS THE BEGINNING
	IMULI	T4,5		;FIVE CHARACTERS/WORD
	HLRZ	T1,1(T5)	;GET THE POSITION
	LSH	T1,-^D12	;FIELD
	IDIVI	T1,7		;NUMBER OF CHARACTERS LEFT
	MOVNI	T1,-5(T1)	;NUMBER OF CHARACTERS USED
	ADDI	T4,(T1)		;CURRENT POSITION
	SUB	T4,(P)		;ARE WE THERE
	JUMPE	T4,FSXT8	;YES, COMMON EXIT
	JUMPG	T4,FSXT7	;BACKING UP THE INPUT
	JUMPO	FSXT4		;FORWARD SPACING OUTPUT
	JSP	P1,IBYTE.	;EAT A CHARACTER
	AOJL	T4,IBYTE.	;CONTINUE UNTIL THERE
	JRST	FSXT8		;COMMON EXIT
FSXT4:	MOVEI	T1," "		;GET A BLANK TO FILL WITH
FSXT5:	ILDB	T0,DD.HRO+1(P3)	;SCAN THE OUTPUT BUFFER
	SOS	DD.HRO+2(P3)	;REDUCE THE COUNT
	JUMPN	T0,FSXT6	;JUMP IF DATA EXISTS
	DPB	T1,DD.HRO+1(P3)	;NO, EXPAND THE RECORD
FSXT6:	AOJL	T4,FSXT5	;CONTINUE
	JRST	FSXT8		;COMMON EXIT
FSXT7:				;SPACING BACKWARD
	MOVEM	T3,1(T5)	;STORE THE BYTE POINTER
	ADDM	T4,2(T5)	;ADJUST THE NUMBER OF CHARACTERS
FSXT8:	POP	P,T0		;ADJUST THE STACK
	AOJA	P2,FSXNXT
	SUBTTL FSXXXX CONVERSION ROUNTINES REQUIRING MEMORY DATA

FSXR=ALPHA%##			;ALPHA CONVERSION RIGHT JUSTIFIED
FSXA=ALPHA%##			;ALPHA CONVERSION LEFT JUSTIFIED
FSXI=INTEG%##			;INTEGER CONVERSION
FSXL=LOGIC%##			;LOGICAL VARIABLE CONVERSION
FSXO=OCTAL%##			;OCTAL CONVERSION

FSXG:	TLO	P2,FT.GTP	;GET G FORMAT FLAG
	MOVE	T5,DAT.TP+2(P4)	;GET THE VARIABLE TYPE
	CAIGE	T5,TP%DOR	;IS VARIABLE DOUBLE PREC. OR COMPLEX
	JRST	[HLRZ	G3,FMTDIS+1(T5)	;NO, GET DISPATCH ADDRESS
		PJRST	(G3)]	;GO TO CONVERSION ROUTINE
	CAIN	T5,TP%DOR	;DOUBLE PREC REAL=D, COMPLEX =F
FSXD:	TLO	P2,FT.PRC	;SET DOUBLE PRECISION FLAG
FSXF:	TLZA	P2,FT.ETP	;CLEAR E TYPE CONVERSION AND 
FSXE:	TLO	P2,FT.ETP	;SET E TYPE CONVERSION
	PJRST	REAL%##		;GO TO FLOATING POINT CONVERSION
	SUBTTL MTOP MAGE TAPE SIMULATION ROUTINES
;				;FLAGS DEFINED IN P2 FOR MAG TAPE SIM.
MG.CLS==040000	;FILE MUST BE CLOSED
MG.ILL==020000	;FUNCTION IS ILLEGAL FOR AN OUTPUT DEVICE
MG.SIM==010000	;FUNCTION CAN BE SIMULATED FOR DEVICES OTHER THAN MAG TAPE


MTOP%:				;ENTRY POINT
	PUSHJ	P,SAVE.		;SAVE THE USER'S ACS
	LDB	P2,[POINT 4,(L),12]	;GET THE FUNCTION  CODE
	CAILE	P2,MAG.SZ	;IS THE FUNCTION DEFINED
	ERROR	(SYS,3,1,CPOPJ)	;NO,IGNORE THE REQUEST
	HLL	P2,MAGTBL(P2)	;GET THE FLAGS
	JSP	P1,SRCFLU	;IS THE UNIT DEFINED
	JRST	[MOVEI	T1,(G1)		;GET THE FLU
		PUSHJ	P,GETDV.	;GET THE ASSOCATED DEVICE
		TRNN	P2,777774	;REWIND/UNLOAD/BACKSPACE
		JRST	[TLNE	G3,DV.AVL	;IS THE DEVICE AVAILABLE
			TLNE	G3,DV.DTA!DV.MTA;DECTAPE/MAGTAPE
			JRST	MTOPEN
			POPJ	P,]		;NO, RETURN
		JRST	MTOPEN]	;OPEN THE DEVICE
	TLNE	P3,IO.RAN	;RANDOM ACCESS FILE
	PJRST	RELE%%		;RELEASE THE RANDOM FILE
MTOP%%:	MOVE	G3,DD.STS(P3)	;GET THE DEVICE STATUS
	TLNN	P3,IO.OPN	;CHECK FOR OPEN FILE
	JRST	[PUSHJ	P,SETDIR	;SET UP THE DIRECTORY
		JRST	MTOP1]		;CONTINUE
	JUMPI	MTOP1		;JUMP ON INPUT
	TLNE	P2,MG.ILL	;IS THIS AN ILLEGAL OUTPUT FUNCTION
	ERROR	(DAT,10,10,CPOPJ)	;ILLEGAL FUNCTION
MTOP1:	MOVE	P2,MAGTBL(P2)	;GET THE FLAGS
	TLNE	P2,MG.CLS	;MUST FILE BE CLOSED FIRST
	PUSHJ	P,CLOSB.	;YES CLOSE THE FILE
	TLNN	G3,DV.MTA	;IS THIS A MAG TAPE DEVICE
	TLNE	P2,MG.SIM	;NO, IS PROCESSING REQUIRED FOR OTHER DEVICES
	PJRST	(P2)		;YES, DO THE SPECIAL PROCESSING
	PJRST	FINXIT		;RETURN TO THE USER

MTOPEN:	JSP	P1,EFCTVL 	;YES, OPEN IT
	PUSHJ	P,SETOPN
	JRST	MTOP%%
MAGTBL:
	XWD	MG.CLS!MG.SIM!IO.SIN!IO.SOU,MAGREW	;REWIND
	XWD	MG.CLS!MG.SIM!IO.SIN!IO.SOU,MAGUNL	;REWIND/UNLOAD
	XWD	MG.SIM!       IO.SIN,MAGBSR	;BACKSPACE RECORD
	XWD	MG.CLS!       IO.SIN,MAGBSF	;BACKSPACE FILE
	XWD	IO.INO!MG.CLS!IO.SOU,MAGEOF	;ENDFILE
	XWD	MG.ILL!MG.SIM!IO.SIN,MAGSKR	;SKIP RECORD
	XWD	IO.INO!       IO.SOU,MAGBLK	;WRITE 3" BLANK TAPE
	XWD	MG.SIM!MG.ILL!IO.SIN,MAGSKF	;SKIP FILE
MAG.SZ==.-MAGTBL			;FUNCTION TABLE SIZE
	SUBTTL MTOP  DEVICE DEPENDENT FUNCTIONS
MAGEOF:	JUMPO	FINXIT		;JUMP ON OUTPUT
	PUSHJ	P,SETRWR	;INPUT, SWITCH TO OUTPUT
	PUSHJ	P,CLOSO.	;CLOSE THE FILE
	PJRST	FINXIT		;RETURN TO USER
MAGBSR:				;OPEN OUTPUT TO BACKSPACE
	TLNN	G3,DV.MTA!DV.DSK;MUST BE DSK OR MAGTAPE
	ERROR	(DAT,14,10)	;CALL THE ERROR ROUTINE
	JUMPI	MAGBSI		;JUMP ON INPUT
	PUSH	P,DD.HRO+2(P3)	;SAVE THE ITEM COUNT
	PUSH	P,DD.HRO+1(P3)	;SAVE THE BYTE POINTER
	PUSH	P,DD.HRO(P3)	;SAVE THE BUFFER ADDRESS
	PUSH	P,DD.BLK(P3)	;SAVE THE BLOCK NUMBER
	PUSHJ	P,OBLOK.	;DUMP THE BLOCK
	PUSHJ	P,CLOSO.	;CLOSE THE FILE
	MOVSI	P2,IO.SIN	;SET UP INPUT MODE
	PUSHJ	P,SETDIR	;OPEN THE FILE
	POP	P,DD.BLK(P3)	;RESTORE THE BLOCK NUMBER
	POP	P,DD.HRI(P3)	;SETUP THE INPUT BUFFER
	MOVNI	T3,1		;BACKSPACE TWO RECORDS
	PUSHJ	P,BSRMTB	;GET THE BLOCK JUST WRITTEN
MAGBS1:	POP	P,DD.HRI+1(P3)	;RESTORE THE BYTE POINTER
	POP	P,DD.HRI+2(P3)	;AND ITEM COUNT
BSREAD:				;RE-READ ENTRY POINT TO BACK UP
MAGBSI:
	SKIPG	T5,DD.HRI(P3)	;GET THE CURRENT BUFFER ADDRESS
	JRST	FINXIT		;NO, INPUT
	MOVE	T4,DD.HRI+1(P3)	;GET THE BYTE POINTER
	CAIL	T5,-1(T4)	;AT THE BEGINNING OF THE BUFFER
	PUSHJ	P,BSRAS3	;BACKSPACE A BLOCK
	MOVE	T1,(T4)		;GET THE LAST WORD OF THE RECORD
	HLRZ	T2,T1		;GET THE LEFT HALF
	LSH	T2,-^D9		;SHIFT OUT THE CHECK SUM (IF BINARY)
	TLZ	P3,IO.FMT!IO.EOL!IO.EOF	;CLEAR THE FORMAT FLAG
	CAIN	T2,3		;TYPE 3 BINARY CONTROL WORD
	JRST	BSRBIN		;YES, BINARY RECORD TO BACKSPACE
	TLNE	T4,3300		;ASCI BYTE POINTER
	JRST	BSRAS0		;YES, AN ASCII BYTE POINTER
	HRLI	T4,(POINT 7,0,34);SET UP AN ASCII BYTE POINTER
	MOVEI	T1,5		;FIVE CHARACTER/WORD
	IMULM	T1,DD.HRI+2(P3)	;CONVERT CHARACTERS TO WORDS
	MOVEM	T4,DD.HRI+1(P3)	;STORE THE BYTE POINTER
	JRST	BSRAS0		;CONT TNE FIRST CHARACTER
BSRASC:	MOVSI	T3,470000	;CONSTANT TO DECREMENT THE BYTE POINTER
	ADD	T4,T3		;STEP BACK ONE CHARACTER
	TLCE	T4,400000	;CHECK FOR OVERFLOW
	JRST	BSRAS0		;SAME WORD
	ADD	T4,[XWD 347777,-1] ;YES , MOVE BACK ONE WORD
	CAIL	T5,-1(T4)	;BEGINNING OF THE BUFFER
	PUSHJ	P,BSRAS3	;YES, READ A NEW BLOCK
	HLRZ	T1,(T4)		;GET THAT WORD'S LEFT HALF
	LSH	T1,-^D9		;IT COULD BE THE END OF A 
	CAIN	T1,3		;BINARY RECORD LSCW=3
	JRST	BSRAS2		;YES, BINARY EXIT
BSRAS0:	AOS	DD.HRI+2(P3)	;INCREMENT THE ITEM COUNT
BSRAS1:	LDB	T0,T4		;GET THIS CHARACTER
	CAIN	T0,12		;A LINE FEED
	TLON	P3,IO.FMT	;FIRST LF SET FMT FLAG
	JRST	BSRASC		;NO, TRY AGAIN
	SOS	DD.HRI+2(P3)	;DONT'T COUNT THE DELIMITER
BSRAS2:	MOVEM	T4,DD.HRI+1(P3)	;SAVE THE BYTE POINTER
	JRST	FINXI0		;RETURN
BSRAS3:	TLNE	G3,DV.DSK!DV.MTA;REREAD OF DEVICE
	PUSHJ	P,BSRPHY	;NO, DO A PHYSICAL BACKSPACE
	JRST	[POP	P,(P)	;MAKE THE STACK RIGHT
		TLO	P3,IO.FMT	;TURN THE FMT FLAG ON
		JRST	BSRAS2]	;BOF EXIT
	MOVE	T5,DD.HRI(P3)	;GET THE RING HEADER
	HRRZ	T4,DD.BUF(P3)	;GET THE BUFFER SIZE
	ADDI	T4,-2(T5)	;POINT THE END OF THE BUFFER
	HRLI	T4,(POINT 7,0,34);SET UP THE BYTE POINTER
	SETZM	DD.HRI+2(P3)	;CLEAR THE ITEM COUNT(BUFF FULL)
	POPJ	P,		;RETURN
BSRBIN:				;BACKSPACE ONE BINARY RECORD
	ANDI	T4,-1		;CLEAR THE BYTEM POINTER
	SUBI	T4,(T5)	;GET THE WORDS IN THE BUFFER
	SUBI	T4,(T1)		;MINUS THE WORD IN THE RECORD
	JUMPG	T4,BSRBI2	;START OF RECORD IN THE BUFFER
	HRRZ	T2,DD.BUF(P3)	;GET THE BUFFER SIZE
	MOVE	T3,T4		;GET THE WORD TO GO BACK
	IDIVI	T3,-3(T2)	;CONVERT TO BUFFERS
	ADDI	T4,-3(T2)	;WORD FROM THE START OF THE BUFFER
	PUSHJ	P,BSRPH1	;DO A BACKSPACE T3 = THE COUNT
	JFCL			;BOF RETURN (NOT USED)
BSRBI2:	HRRZ	T3,DD.BUF(P3)	;GET THE BUFFER SIZE
	SUBI	T3,2(T4)	;GET THE WORDS LEFT IN THE BUFFER
	MOVEM	T3,DD.HRI+2(P3)	;SAVE THE ITEM COUNT
	ADD	T4,DD.HRI(P3)	;GET THE BUFFER ADDRESS
	HRLI	T4,(POINT 36,0,35);GET A BINARY BYTE POINTER
	MOVEM	T4,DD.HRI+1(P3)	;STORE THE BYTE POINTER
	HLRZ	T1,1(T4)	;GET THE CONTOL WORD
	LSH	T1,-^D9		;SHIFT OUT THE CHECK SUM
	CAIE	T1,1		;TYPE 1 CONTROL WORD
	ERROR	(DAT,2,7,)	;ILLEGAL LSCW
	JRST	FINXI0		;RETURN
	SUBTTL	BSRXXX PHYSICAL BACKSPACE ROUTINES
BSRPHY:			;READ IN A PHYSICAL BLOCK
	SETZ	T3,		;BACKSPACE ONLY ONE BLOCK
BSRPH1:	HRRZ	T1,DD.BLK(P3)	;GET THE CURRENT BLOCK COUNT
	SOJLE	T1,CPOPJ	;BOF
	ADD	T1,T3		;NUMBER OF BLOCK TO GO BACK PLUS 1
	AOS	(P)		;SET SKIP RETURN (NOT BOF)
	HRRM	T1,DD.BLK(P3)	;STORE THE BLOCK NUMBER
BSRMTB:	TLNN	G3,DV.MTA	;IS THIS A MAG TAPE
	PJRST	RBLOK.		;READ A RANDOME ACCESS BLOCK
	JSP	P1,WAIT.	;STOP THE MAGTAPE FROM BUFFERING
	JSP	P1,BSRMTA	;BACK UP THE MAG TAPE
	SOS	DD.BLK(P3)	;RETARD THE BLOCK COUNT (IBLOCK. AOS ES)
	PJRST	IBLOK.		;READ THE RECORD IN
BSRMTA:	TLO	P3,IO.RNG	;SET RING CHANGE FLAG
	MOVSI	T0,400000	;SET UP A USE BIT MASK
	MOVE	T1,DD.HRI(P3)	;GET THE RING HEADER (BUFFER ADDRESS)
	IORM	T0,DD.HRI(P3)	;CHANGING RINGS FLAG
	SKIPL	(T1)		;IS THE USE BIT SET
	JRST	BSRMT1		;NO, THRU THE RING BUFFER
	ANDCAM	T0,(T1)		;YES CLEAR THE USE BIT
	MOVE	T1,(T1)		;GET THE NEXT BUFFER ADDRESS
	SOJA	T3,.-4		;COUNT THIS BUFFER
BSRMT1:	MOVE	T0,-1(T1)	;GET THE STATUS BITS
	SETZM	-1(T1)		;CLEAR THE STATUS (MTASRX) DOES NOT
	TLNE	T0,40		;IS END OF FILE SET ON LOOK AHEAD
	SUBI	T3,1		;YES, MUST BACK OVER EOF ALSO
	HLLZ	T0,DD.UNT(P3)	;GET THE CHANNEL NUMBER
	IOR	T0,[MTAPE 0,7]	;SET UP A PHYSICAL BACKSPACE UUO
	XCT	T0		;BACKSPACE THE TAPE UNIT
	AOJLE	T3,.-1		;AGAIN
	ANDCMI	T0,-1		;SET UP A NO OP
	XCT	T0		;WAIT UNTIL DEVICE STOPS
	JRST	(P1)		;RETURN

MAGBSF:	MOVEI	T1,17		;GET THE BACKSPACE FILE FUNCTION
	PUSHJ	P,MAGXCT	;DO THE BACKSPACE OPERATION
	ANDCMI	T1,-1		;SET UP A WAIT
	XCT	T1		;WAIT
	HLLZ	T1,DD.UNT(P3)	;GET THE CHANNEL NUMBER
	IOR	T1,[STATZ 0,4000];CHECK FOR BEGINNING OF TAPE
	XCT	T1		;EXECUTE THE UUO
	PJRST	FINXIT		;RETURN TO THE USER
	MOVEI	T1,16		;GET A MAGTAPE SKIP RECORD COMMAND
	PUSHJ	P,MAGXCT	;DO IT
	PJRST	FINXIT		;RETURN TO THE USER

MAGSKR:	TLNN	P3,IO.OPN	;IS THE FILE OPEN
	PUSHJ	P,SETDIR	;NO, OPEN THE FILE
	JSP	P1,IPEEK.	;LOOK AT THE NEXT ITEM
	MOVE	T1,DD.HRI+1(P3)	;GET THEBYTE POINTER
	TLNN	T1,760000	;END OF A WORD
	SKIPA	T1,1(T1)	;YES, GET THE NEXT WORD
	MOVE	T1,(T1)		;NO, USED THIS WORD
MAGSK2:	TLNN	T1,774000	;IS THIS AN ASCII RECORD
	JRST	MAGSK3	;BINARY SKIP
	TLNN	P3,IO.FMT	;INITED IN ASCII
	PUSHJ	P,SETMOD	;NO, DO A MODE SWITCH
	TLNE	P3,IO.EOL	;AT END OF A LINE
	PUSHJ	P,NXTLNI	;YES, GET THE NEXT INPUT LINE
	PJRST	FINF1		;SCAN TO THE END OF LINE
MAGSK3:	TLNE	P3,IO.FMT	;INITED IN BINARY MODE
	PUSHJ	P,SETMOD	;NO, GO SET BINARY MODE
	PUSHJ	P,BINIO		;BINARY, GO TO BINARY I/O ROUTINE
	PJRST	FINBIN		;FINISH UP BINARY I/O

	SUBTTL MAGXXX MAG TAPE UTILITY ROUTINES
MAGBLK:	JRST	FINXIT		;RETURN TO THE USER

MAGSKF:	TLNN	G3,DV.DSK	;IS THIS A DSK TYPE DEVICE
	JRST	.+4		;NO
	HLLO	T1,DD.UNT	;GET THE CHANNEL NUMBER
	TLO	T1,(USETI)	;A QUICK WAY TO EOF FOR DSK
	XCT	T1		;AT EOF NO GET A BLOCK TO SET EOF FLAG
	HLLZ	T1,DD.UNT(P3)	;GET THE CHANNEL NUMBER
	TLO	T1,(IN)		;INPUT UUO
	XCT	T1		;READ A BLOCK
	AOSA	DD.BLK(P3)	;COUNT THIS BLOCK
	PJRST	FINXIT		;RETURN TO THE USER
	JRST	.-3		;CONTINUE TO EOF OR ERROR


MAGUNL:	SKIPA	T1,[11]		;UNLOAD FUNCTION
MAGREW:	MOVEI	T1,1		;REWIND FUNCTION
	TLNN	G3,DV.MTA!DV.DTA;REWIND/UNLOA LEGAL FOR MTA/DTA
	PJRST	FINXIT		;RETURN TO THE USER
	PUSHJ	P,MAGXCT	;DO IT
	ANDCMI	T1,-1		;SET UP A WAIT UUO
	TLNN	T1,10		;UNLOAD REQUEST
	XCT	T1		;NO, REWIND WAIT
	PJRST	FINXIT

MAGXCT:				;EXECUTE THE MAG TAPE FUNCTION
	HLL	T1,DD.UNT(P3)	;GET THE CHANNEL NUMBER
	TLO	T1,(MTAPE)	;SET UP THE MTAPE UUO
	XCT	T1		;DO IT
	POPJ	P,		;RETURN
	SUBTTL CLOSE ROUTINE TO CLOSE THE FILE
CLOSE%:	PUSHJ	P,SAVE.		;SAVE THE USER'S ACS
	JSP	P1,SRCFLU	;IS THE UNIT DEFINED
	POPJ	P,		;NO, RETURN
CLOS%%:	TLZN	P3,IO.OPN	;IS THE UNIT OPEN
	POPJ	P,		;UNIT DEFINE BUT NOT OPEN RETURN
	TLNN	P3,IO.RAN	;RANDOM ACCESS
	JRST	CLOSB.		;NO,SEQUENTIAL ACCESS
	TLNE	P3,IO.INO	;OUTPUT LAST
	SKIPG	DD.HRO(P3)	;YES, IS THE RING BUFFERS SET UP
	JRST	CLOSE1		;NO, OUTPUT RING OR INPUT
	PUSHJ	P,WBLOK.	;DOMP THE BLOCK
CLOSE1:	JSP	P1,WAIT.	;STOP THE DEVICE AFTER THE LAST BLOCK
	MOVSI	T0,400000	;SET UP A USE BIT
	IORM	T0,DD.HRO(P3)	;SET THE RING NOT IN USE
	IORM	T0,DD.HRI(P3)
	JRST	CLOSB.		;CLOSE THE FILE

CLOSO.::MOVEI	T1,2		;CLOSE OUTPUT
	JRST	CLOSI.+1	;COMMON ROUTINE
CLOSB.::TDZA	T1,T1		;CLOSE INPUT/OUTPUT
CLOSI.::MOVEI	T1,1		;CLOSE INPUT ONLY
	HLRZ	T2,DD.UNT(P3)	;GET THE CHANNEL NUMBER
	TLO	T1,<(CLOSE)>(T2);SET UP THE UUO
	XCT	T1		;CLOSE THE FILE
	LSH	T2,-5		;POSITION THE CHANNEL NUMBER
	ADDI	T2,CHN.TB(P4)	;POINT TO THE CHANNEL ENTRY
	TLZ	P3,IO.OPN!IO.EOF;CLEAR THE OPEN BIT
	MOVEM	P3,(T2)		;UPDATE THE CHANNEL TABLE
	SETZM	DD.HRI+2(P3)	;CLEAR THE ITEM COUNTS
	SETZM	DD.HRO+2(P3)	;ETC
	POPJ	P,		;EXIT
	SUBTTL RELEASE ROUTINE TO RELEASE A SOFTWARE CHANNEL AND DD.BLK

RELEA%:			;ENTRY TO RELEASE A FORTRAN LOGICAL UNIT
	PUSHJ	P,SAVE.		;SAVE THE USER'S ACS
	JSP	P1,SRCFLU	;IS THE UNIT ASSIGNED
	POPJ	P,		;NO, RETURN UNIT IS RELEASED
RELE%%::TLNE	P3,IO.OPN	;IS THE CHANNEL OPEN
	PUSHJ	P,CLOS%%	;YES CLOSE THE DEVICE FIRST
	HLLZ	T1,DD.UNT(P3)	;GET THE CHANNEL NUMBER
	TLO	T1,(RELEAS)	;SET UP THE RELEASE UUO
	XCT	T1		;RELEAE THE SOFTWARE CHANNEL
	HLRZ	T1,DD.UNT(P3)	;GET THE CHANNEL NUMBER
	LSH	T1,-5		;POSITION
	JSP	P1,PUTCHN	;DEALLOCATE THE CHANNEL
	SETZ	T0,		;CLEAR T0
	DPB	T0,FLU.BP(P4)	;CLEAR THE CHANNEL POINTER IN THE FLU TABE
;				;ENTER HERE TO REMOVE A DDB IN P3
RELE%1:	SKIPE	T1,DD.RLS(P3)	;IS THERE A REELS ARRAY ASSIGNED
	PUSHJ	P,GET12		;YES, DEALLOCATE THE REELS ARRAY
	SKIPN	T1,DD.PPN(P3)	;CHECK FOR A PPN
	JRST	.+3		;NO, PPN
	TLNN	T1,-1		;IS THERE A SFD ARRAY
	PUSHJ	P,GET12		;YES, DEALLOCATE THE SFD ARRAY
	HRRZI	T1,(P3)		;GET THE DD.BLK POINTER
	PJRST	GET12		;DEALLOCATE THE DD.BLK (RETURN)
	SUBTTL	EXIT CLOSE OUT THE I/O CHANNEL AND EXIT VIA FORERR
EXIT%::	PUSHJ	P,SAVE.		;SAVE THE USER'S ACS
EXIT%%:	MOVEI	P2,CHN.TB+1(P4)	;GET THE CHANNEL TABLE ADDRESS
	HRLI	P2,-17		;SCAN ONLY 15 CHANNELS
	SKIPE	P3,(P2)		;IS THIS CHANNEL DEFINED
	PUSHJ	P,RELE%%	;YES, RELEASE THE CHANNEL
	AOBJN	P2,.-2		;CONTINUE THRU ALL CHANNELS
	SKIPE	P3,CHN.TB+20(P4);GET THE TTY CHANNEL
	PUSHJ	P,OBLOK.	;DUMP THE LAST LINE
        SETZB   0,.JBAPR##
        APRENB                  ;TURN OFF ALL TRAPS
        MOVEI   1,SGED##
        MOVEI   2,1
        JSP     17,GOSEG##      ;BACK TO CCS EDITOR
SUBTTL GETOWN - GET OWN SPACE ROUTINE

; ON ENTRY,
; IF T0 < 0, A DEFRAGMENTATION IS PERFORMED, AND THE MAXIMUM
; CONTIGUOUS AREA RETURNED
; IF T0 = 0, T1 IS THE ADDRESS OF A SPACE, OR A CHAIN OF SPACES
; TO BE RETURNED TO THE INACTIVE HEAP CHAIN
; IF T0 > 0, T0 IS THE NUMBER OF WORDS OF SPACE REQUIRED
; NON SKIP EXIT FOR FAILURE ON GETTING, AND ALWAYS ON DELETING
; OK SKIP EXIT WITH T1 = ADDRESS OF SPACE OBTAINED

; THE INACTIVE HEAP CHAIN IS ADDRESSED BY FRE.DY, AND CONSISTS
; OF A CHAIN OF SPACES WHOSE FIRST WORD IS FORMATTED AS FOLLOWS:

;	LH: NUMBER OF WORDS IN SPACE (INCLUDING THIS ONE)
;	RH: POINTER TO NEXT SPACE (ZERO IF NONE)

DECOR%:	PUSHJ	P,SAVE.		;SAVE THE USER'S AC'S
	JSP	P1,EFCTVL	;GET THE ADDRESS OF THE BLOCK TO RETURN
	TRNN	G1,-20		;IN THE AC SAVE AREA
	ADDI	G1,ACC.SV(P4)	;YES, RELOCATE TO THE SAVE AREA
	HRRZ	T1,(G1)		;GET UP THE DECORE CALL
	PJRST	GET12		;RELEASE THE CORCK

ALCOR%:	PUSHJ	P,SAVE.		;ENTRY FROM USER PROGRAMS
	JSP	P1,EFCTVL	;GET THE NUMBER OF WORD REQUESTED
	TRNN	G1,-20		;IN THE AC SAVE AREA
	ADDI	G1,ACC.SV(P4)	;YES, RELOCATE TO THE SAVE AREA
	HRRZ	T0,(G1)		;SET UP FOR A GET CORE CALL
	PUSHJ	P,GETOWN	;GET THE CORE BLOCK
	HRRZM	T1,ACC.SV+T0(P4);SAVE CORE ADDRESS IN USER'S ACS
	POPJ	P,		;RETURN TO USER

GETOWN:	JUMPE	T0,GET12	; JUMP IF SPACE TO BE RETURNED

GET0:	JUMPL	T0,GET17	; SUPER-GETOWN

GET1:	MOVEI	T2,FRE.DY(P4)	; PREPARE FOR SEARCH
	SKIPN	T1,(T2)		;ANY HEAP LEFT
	JRST	GET2B		;NO, GET SOME

GET2:	HLRZ	T3,(T1)		; GET SIZE OF THIS SPACE
	JUMPE	T3,GET8	; DEFENSIVE!
	CAMLE	T3,T0		; BIG ENOUGH?
	AOJA	T0,GET9		; YES
	MOVE	T2,T1		; NO -
	HRRZ	T1,(T2)		; SELECT NEXT SPACE
	JUMPN	T1,GET2		; AND CONTINUE UNLESS NONE LEFT
GET2A:	PUSHJ	P,GET3		;TAKE A GARBAGE COLLECTION
	HLRZ	T1,(T2)		;LOAD THE MAXIUM SIZE AVAILABLE
	CAMLE	T1,T0		;IS THIS ENOUGH ROOM
	JRST	GET1		;YES, SPACE IS AVAILABLE, GET IT
GET2B:	AOS	T3,.JBREL	;SET .JBREL UP 1K (.JBREL/ IS NOT CHANGED)
	CORE	T3,		;ALLOCATE CORE (CORE UUO CHANGES .JBREL)
	  HALT
	MOVE	T1,.JBFF	;GET THE FIRST UNUSED LOCATION
	HRRM	T1,(T2)		;LINK TO FREE SPACE
	HRRZ	T3,.JBREL	;GET LAST LOCATION ALLOC\TED BY MONITOR
	SUBI	T3,-1(T1)	;GET THE SIZE OF THE NEW FREE CORE BLOCK
	HRLZM	T3,@.JBFF	;SET THE SIZE OF THE FREE BLOCK
	ADDB	T3,.JBFF	;UPDATE JOBFF
	JRST	GET2A		;RETURN FOR ADJACENT TEST

GET3:	MOVEI	T2,FRE.DY(P4)	; NO - DEFRAGMENTATION SCAN
	MOVE	T1,FRE.DY(P4)	; INITIALIZE LH POINTER

GET4:	MOVEI	T3,FRE.DY(P4)
	MOVE	T4,FRE.DY(P4)	; INITIALIZE RH POINTER
	HLRZ	T5,(T1)		; EXTRACT LENGTH OF LH SPACE
	ADDI	T5,(T1)		; AND ADD TO ORIGIN
GET5:	CAME	T1,T4		; SKIP ADJACENCY TEST IF SAME SPACES
	CAME	T5,T4		; ADJACENT SPACES?
	JRST	GET7		; NO
	HRRZ	T5,(T1)
	CAMN	T2,T4
	JRST	[
	HRRM	T5,(T3)
	JRST	GET6]
	HRRM	T5,(T2)		; REMOVE LH SPACE FROM CHAIN
	HRRZ	T5,(T4)
	CAMN	T1,T3
	JRST	[
	HRRM	T5,(T2)
	JRST	GET6]
	HRRM	T5,(T3)		; REMOVE RH SPACE FROM CHAIN

GET6:	HLRZ	T5,(T4)
	HLRZ	T3,(T1)
	ADDI	T5,(T3)		; TOTAL LENGTH OF SPACES
	HRLZM	T5,(T1)		; STORE IN AUGMENTED SPACE
	PUSHJ	P,GET13		; DELETE AUGMENTED SPACE
	JRST	GET3		; AND RECOMMENCE DEFRAGMENTATION SCAN

GET7:	MOVE	T3,T4
	HRRZ	T4,(T3)		; MOVE RH POINTER TO NEXT SPACE
	JUMPN	T4,GET5		; AND CONTINUE TILL END
	MOVE	T2,T1		; IF SO -
	HRRZ	T1,(T2)		; MOVE LH POINTER TO NEXT SPACE
	JUMPN	T1,GET4		; AND CONTINUE TILL END
GET8:	POPJ	P,0		;RETURN FROM DEFRAGMENTATION ROUTINE
GET9:	HRRZ	T4,(T1)		; SPACE FOUND
	HRRM	T4,(T2)		; REMOVE SPACE FROM CHAIN
	HRLZM	T0,(T1)		; AND FILL IN SIZE
	HRRI	T4,2(T1)	;SET A BLT POINTER TO CLEAR
	HRLI	T4,-1(T4)	;THE REQUEST CORE BLOCK
	HRRZ	T5,T0		;GET THE SIZE OF THE BLOCK
	ADDI	T5,-1(T1)	;GET THE ENDING ADDRESS
	SETZM	1(T1)		;CLEAR THE FIRST WORD
	BLT	T4,(T5)		;CLEAR THE REST OF THE BLOCK
	CAML	T0,T3		; EXACTLY RIGHT?
	AOJA	T1,GET8		; YES
	SUB	T3,T0		; NO - COMPUTE REMAINDER
	PUSH	P,T1		; AND SAVE T1
	ADD	T1,T0		; GET ADDRESS OF FRAGMENT
	HRLZM	T3,(T1)		; AND FILL IN ITS LENGTH
	PUSHJ	P,GET13		; DELETE IT
	POP	P,T1		; RESTORE T1
	AOJA	T1,GET8		;INCREMENT FOR USER

GET12:	SUBI	T1,1		; DECREMENT T1
GET13:	SKIPE	T2,FRE.DY(P4)	; DELETE SPACE - CHAIN EMPTY?
	JRST	GET14		; NO
	HRRZM	T1,FRE.DY(P4)	; YES - START IT UP
	POPJ	P,0

GET14:	HLRZ	T3,(T1)		; GET LENGTH OF SPACE TO BE RETURNED
	JUMPE	T3,GET8		; DEFENSIVE!
	MOVEI	T4,FRE.DY(P4)	; AND PREPARE FOR SEARCH

GET15:	HLRZ	T5,(T2)		; GET LENGTH OF THIS SPACE
	CAML	T5,T3		; BIGGER THAN ONE TO BE DELETED?
	JRST	GET16		; YES
	MOVE	T4,T2		; NO -
	HRRZ	T2,(T4)		; SELECT NEXT SPACE
	JUMPN	T2,GET15	; AND CONTINUE UNLESS NONE LEFT

GET16:	HRRM	T1,(T4)		; CHAIN FROM LEFT
	HRRZ	T4,(T1)		; EXTRACT RH FIRST
	HRRM	T2,(T1)		; CHAIN TO RIGHT
	JUMPE	T4,GET8		; EXIT IF IT WAS A SINGLE SPACE
	MOVE	T1,T4		; NO -
	JRST	GET13		; DELETE REMAINDER

GET17:	HRLZI	T0,000001	; SUPER-GETOWN
	PUSHJ	P,GET3		; FORCE DEFRAGMENTATION
	HLRZ	T0,(T2)		; GET SIZE OF LAST AREA IN CHAIN
	SOJA	T0,GET0		; AND ASK FOR IT
	SUBTTL DEVTB. DEFAULT DEVICE TABLE FOR FORTRAN IV

	SIXBIT	.REREAD.	;-6;	REREAD
	SIXBIT	.CDR.		;-5;	READ
	SIXBIT	.TTY.		;-4;	ACCEPT
	SIXBIT	.LPT.		;-3;	PRINT
	SIXBIT	.PTP.		;-2;	PUNCH
	SIXBIT	.TTY.		;-1;	TYPE
DEVTB.:	SIXBIT	.TMP.		;00;	TEMP CORE DEVICE
	SIXBIT	.DSK.		;01;	DISC
	SIXBIT	.CDR.		;02;	CARD READER
	SIXBIT	.LPT.		;03;	LINE PRINTER
	SIXBIT	.CTY.		;04;	CONSOLE TELETYPE
	SIXBIT	.TTY.		;05;	USER'S TELETYPE
	SIXBIT	.PTR.		;06;	PAPER TAPE READER
	SIXBIT	.PTP.		;07;	PAPER TAPE PUNCH
	SIXBIT	.DIS.		;08;	DISPLAY
	SIXBIT	.DTA1.		;09;	DECTAPE
	SIXBIT	.DTA2.		;10;
	SIXBIT	.DTA3.		;11;
	SIXBIT	.DTA4.		;12;
	SIXBIT	.DTA5.		;13;
	SIXBIT	.DTA6.		;14;
	SIXBIT	.DTA7.		;15;
	SIXBIT	.MTA0.		;16;	MAG TAPE
	SIXBIT	.MTA1.		;17;
	SIXBIT	.MTA2.		;18;
	SIXBIT	.FORTR.		;19;
	SIXBIT	.DSK.		;20;
	SIXBIT	.DSK.		;21;
	SIXBIT	.DSK.		;22;
	SIXBIT	.DSK.		;23;
	SIXBIT	.DSK.		;24;
	SIXBIT	.DEV1.		;25;
	SIXBIT	.DEV2.		;26;
	SIXBIT	.DEV3.		;27;
	SIXBIT	.DEV4.		;28;
	SIXBIT	.DEV5.		;29;
DEV.SZ==.-DEVTB.+1
        END     INIT%
!@f