MODULE GNNAME(DOLLAR,ENTRIES=($GNLAB,$GWVAR,$GNNAME,$GRLAB,$GFLAB,$GLABL,$GNLI,$GNLIT),FSAVE,TIMING,TIMER=EXTERNAL(SIX12))=
  BEGIN

  REQUIRE ADEFS.BLI[7,107355];
  REQUIRE DTDEFS.BLI[7,107355];
  REQUIRE FDEFS.BLI[7,107355];
  REQUIRE FPDEFS.BLI[7,107355];
  REQUIRE GDEFS.BLI[7,107355];
  REQUIRE SDEFS.BLI[7,107355];
  REQUIRE TDEFS.BLI[7,107355];
  REQUIRE UDEFS.BLI[7,107355];
  REQUIRE ZDEFS.BLI[7,107355];

  UNDECLARE $GNLAB, $GWVAR, $GNNAME, $GRLAB, $GFLAB, $GLABL, $GNLI, $GNLIT;
  UNDECLARE $GDWVAR;

  MAP Z$ ZBSTK$;
  MAP G$OPND GGBOP$;
  MAP A$ GBTKN$;


%****
  CREATE A NEW SYMBOLIC NAME AND IT'S SYMBOL TABLE NAME ENTRY. THIS ROUTINE RETURNS THE ADDRESS
  OF THE SYMBOL TABLE ENTRY BUFFER WHICH CONTAINS THE NEW NAME ENTRY. THIS ROUTINE IS CALLED BY
  $GNLAB,$GWVAR, AND $GEXEC.
****%
    GLOBAL ROUTINE $GNNAME(TYPE) =
      BEGIN
      LOCAL S$ STENTRY;
      BIND NAMROOT = PLIT '#%NAM!    ';
      LOCAL NAMSIZE, NAMSTR[2], PTR, CHAR[5], NUM, I;

      NUM := GNAMN$ := .GNAMN$+1;
      I := 0;
      DO
        BEGIN
        I := .I + 1;
        CHAR[.I] := .NUM MOD 10;
        NUM := .NUM/10;
        END
      UNTIL .NUM EQL 0;
      NAMSTR[0] := .NAMROOT[0];
      NAMSTR[1] := .NAMROOT[1];
      PTR := NAMSTR[1]<29,7>;
      DECR J FROM .I TO 1
        DO
          REPLACEI(PTR,.CHAR[.J]+"0");
      NAMSIZE := 6 + .I;
      STENTRY := $SGVSTS(.TYPE,3);
      STENTRY[S$NCHAR] := .NAMSIZE;
      (STENTRY[S$NAME])[1] := .NAMSTR[0];
      (STENTRY[S$NAME])[2] := .NAMSTR[1];

      .STENTRY
      END;


%*****
  THIS ROUTINE CREATES A LITERAL NAME ENTRY AND LITERAL INCARNATION ENTRY USING THE NAME BLOCK CONTAINING THE LITERAL
*****%
  GLOBAL ROUTINE $GNLIT(NAMEP,NAMELEN)=
    BEGIN

    MAP SNAM$ NAMEP;
    LOCAL S$ NAMESTE:INCSTE;
    LOCAL LITSTP, LTYPE;

    LITSTP := $SLKUP(.NAMEP,.NAMELEN);
    IF .LITSTP EQL 0
      THEN
        BEGIN
        LTYPE :=
            IF .NAMEP[S$DDTYPE] EQL SV$SINGD
              THEN
                SV$SWLIT
              ELSE
                IF .NAMEP[S$DDTYPE] EQL SV$DBLD
                  THEN
                    SV$DWLIT
                  ELSE
                    SV$STLIT;
        NAMESTE := $SGVSTS(.LTYPE,.NAMELEN);
        INCSTE := $SGVSTS(SV$LIE,.NAMELEN);
        INCR I FROM 0 TO .NAMELEN - 1
          DO
            (NAMESTE[S$NAME])[.I] := (INCSTE[S$NAME])[.I] := .((.NAMEP)[.I]);
        NAMESTE[S$STP1] := INCSTE[S$STP1] := .NAMESTE[S$STPX];
        NAMESTE[S$IDSTP] := NAMESTE[S$CISTP] := SV$NULL;
        LITSTP := NAMESTE[S$LITINCP] := .INCSTE[S$STPX];
        INCSTE[S$DDBT] := SV$NONE;
        $SFNME(.NAMESTE,.NAMELEN);
        $SFRCH(.INCSTE);
        END
      ELSE
        BEGIN
        NAMESTE := $SGSTE(.LITSTP);
        LITSTP := .NAMESTE[S$LITINCP];
        $SFRNCH(.NAMESTE);
        END;

    .LITSTP

    END;


%*****
  CREATE A LABEL INCARNATION ENTRY AND LINK IT TO IT'S NAME ENTRY.
*****%
  GLOBAL ROUTINE $GNLI(NAMESTE) =
    BEGIN

    MAP S$ NAMESTE;
    LOCAL S$ INCSTE;

    INCSTE := $SGSTSP(SV$LABINC);
    INCSTE[S$STP1] := .NAMESTE[S$STPX];
    INCSTE[S$DBT]  := SV$NONE;
    INCSTE[S$ENDSTP] := SV$NULL;
    INCSTE[S$BRCHF] := SV$FALSE;
    INCSTE[S$SEMP] := SV$NULL;

    NAMESTE[S$DSTP] := NAMESTE[S$IDSTP] := NAMESTE[S$CISTP] := .INCSTE[S$STPX];
    $SFGCH(.NAMESTE);
    $SFRCH(.INCSTE);
    END;


%****
  CREATE A NEW LABEL INCLUDING A NAME AND DEF ENTRY. THIS ROUTINE RETURNS THE STP FOR
   THE LABEL DEFINITION ENTRY FOR THE NEW LABEL. THIS ROUTINE IS CALLED BY THE FOLLOWING ROUTINES:
       $GFIN, $GIF, AND $GTHEN.
****%
  GLOBAL ROUTINE $GNLAB =
    BEGIN

    MAP GDBG$ GDBGF$;

    LOCAL S$ NAMEP;
    LOCAL INCSTP;
    LOCAL NAMESTP;

    NAMEP := $GNNAME(SV$LABEL);
    NAMEP[S$STP1] := .NAMEP[S$STPX];
    NAMESTP := .NAMEP[S$STPX];
    $SFNME(.NAMEP,3);
    NAMEP := $SGSTE(.NAMESTP);
    $GNLI(.NAMEP);
    INCSTP := .NAMEP[S$CISTP];
    $SFRNCH(.NAMEP);

!** $SFNME(.NAMEP,3);

    .INCSTP
    END;


%****
  CREATE A WORK VARIABLE INCLUDING NAME, DEF, ITEM, AND INCARNATION ENTRIES. THIS ROUTINE RETURNS THE
  ADDRESS OF THE SYMBOL TABLE ENTRY BUFFER WHICH CONTAINS THE NEW NAME ENTRY. THIS ROUTINE IS
  CALLED BY $GEXEC EXCLUSIVELY.

    PARAMETERS:
        TYPE   INPUT  INDICATES THE DATA TYPE THAT THE VARIABLE IS TO HAVE.
        ICNT   INPUT  IF TYPE IS NUMERIC THEN THIS PARAM. SPECIFIES THE NO. OF INTEGER PLACES IN THE VARIABLE.
        DCNT   INPUT  IF TYPE IS NUMERIC THEN THIS PARAM. SPECIFIES THE NO. OF DECIMAL PLACES IN THE VARIABLE.
****%
  GLOBAL ROUTINE $GWVAR(TYPE,ICNT,DCNT)=
    BEGIN

    MAP GDBG$ GDBGF$;

    LOCAL S$ NAMEP:DEFP:ITEMP:INCARP;
    LOCAL NAMESTP, DEFSTP;
    LOCAL FP$I PICTURE;

    PICTURE := ZV$NULL;
    NAMEP := $GNNAME(SV$NAME);
    DEFP := $SGSTSP(SV$FIELD);           % GET SPACE FOR A DEF. ENTRY %
    NAMESTP := .NAMEP[S$STPX];
    DEFSTP  := .DEFP[S$STPX];
    NAMEP[S$DSTP] := .DEFSTP;
    NAMEP[S$STP1] := .NAMESTP;
    NAMEP[S$IDSTP] := NAMEP[S$CISTP] := SV$NULL;
    DEFP[S$STP1] := .NAMESTP;
    SELECT .TYPE OF
                NSET
      ZV$NUMERIC:
        BEGIN
        DEFP[S$LWORD] := (.ICNT + .DCNT + 9)/10;  % NO. OF WORDS OF STORAGE NEEDED  %
        DEFP[S$INTD]  := .ICNT;
        DEFP[S$DECD]  := .DCNT;
        PICTURE[FP$TYPE] := FPV$NUM;
        PICTURE[FP$SIGN] := FPV$LMP;
        PICTURE[FP$XI]   := 1;
        PICTURE[FP$FS]   := FPV$MINUS;
        PICTURE[FP$FI]   := .ICNT - 1;
        PICTURE[FP$DI]   := .DCNT;
        IF .DCNT GTR 0
          THEN
            PICTURE[FP$SP2] := FPV$TRUE;
        DEFP[S$FP]    := .PICTURE;
        DEFP[S$DFLT]  := .SZERO$;
        DEFP[S$DTYP]  := (CASE (.DEFP[S$LWORD] - 1) OF
                               SET
                           SV$SINGD;
                           SV$DBLD;
                           SV$TRID;
                               TES    )
        END;
      ZV$STRING:
        BEGIN
        DEFP[S$LWORD] := (.ICNT + 4)/5;
        PICTURE[FP$TYPE] := FPV$STR;
        PICTURE[FP$C]    := .ICNT;
        DEFP[S$FP]    := .PICTURE;
        DEFP[S$DFLT]  := .SBLNK$;
        DEFP[S$DTYP]  := SV$SLIT;
        DEFP[S$LCHAR] := .ICNT;
        END;
                TESN;
    ITEMP   := $GNITM(.DEFP);            % CREATE AN ITEM ENTRY     %
    INCARP    := $GNFI(.NAMEP,.DEFP);      % CREATE A FIELD INCARNATION ENTRY  %
    NAMEP[S$IDSTP] := NAMEP[S$CISTP] := .INCARP[S$STPX];
    DEFP[S$RSFSN] := .ITEMP[S$STPX];

    $SFRCH(.DEFP);
    $SFRNCH(.ITEMP);
    $SFRNCH(.INCARP);

    .NAMEP
    END;


  GLOBAL ROUTINE $GDWVAR(DTMP)=
    BEGIN

    MAP DT$ DTMP;
    LOCAL S$ NAMEP : DEFP : ITEMP : INCARP;

    NAMEP := $GNNAME(SV$NAME);
    DEFP := $SGSTSP(SV$FIELD);
    NAMEP[S$STP1] := .NAMEP[S$STPX];
    NAMEP[S$DSTP] := .DEFP[S$STPX];
    NAMEP[S$IDSTP] := NAMEP[S$CISTP] := SV$NULL;
    DEFP[S$STP1] := .NAMEP[S$STPX];
    DEFP[S$LWORD] := 1;
    DEFP[S$INTD] := 8;
    DEFP[S$DECD] := 0;
    DEFP[S$DFLT] := .SZERO$;
    DEFP[S$DTYP] := SV$DLIT;
     DEFP[S$DTP][0] := @(.DTMP);
     DEFP[S$DTP][1] := @(.DTMP+1);
    ITEMP := $GNITM(.DEFP);
    INCARP := $GNFI(.NAMEP,.DEFP);
    NAMEP[S$IDSTP] := NAMEP[S$CISTP] := .INCARP[S$STPX];
    DEFP[S$RSFSN] := .ITEMP[S$STPX];
    $SFRCH(.DEFP);
    $SFRNCH(.ITEMP);
    $SFRNCH(.INCARP);

    .NAMEP

    END;


%*****
  PROCESS A LABEL TO IDENTIFY IT AS A LEGAL OBJECT OF A REPEAT OR FINISH STATEMENT.
*****%
  GLOBAL ROUTINE $GRLAB(STKPTR) =
    BEGIN

    LOCAL S$ STENTRY;

    STENTRY := $SGSTE(.ZBSTK$[Z$DEFSTP,.STKPTR]);
    STENTRY[S$BRCHF] := SV$TRUE;
    STENTRY[S$SEMP]  := .STKPTR;
    $SFRCH(.STENTRY);
    END;


%*****
  DETERMINES IF A LABEL WAS REFERENCED BY A FINISH STATEMENT AND TAKES THE APPROPRIATE ACTION.
*****%
  GLOBAL ROUTINE $GFLAB(STKPTR) =
    BEGIN

    LOCAL S$ STENTRY;

    STENTRY := $SGSTE(.ZBSTK$[Z$DEFSTP,.STKPTR]);
    IF .STENTRY[S$ENDSTP] NEQ SV$NULL           % WAS THE LABEL REFERENCED BY A FINISH? %
      THEN                                      % YES! %
        BEGIN
        $GIREC(GV$LABEL,3);                     % GENERATE THE LABEL TO BE BRANCHED TO BY THE FINISH %
        GGBOP$[0,G$OPTYP] := GV$STP;
        GGBOP$[0,G$OPVAL] := .STENTRY[S$ENDSTP];
        $GWBUF(.GGBFP$,.GOB1I$);
        STENTRY[S$SEMP] := SV$NULL;
        STENTRY[S$BRCHF] := SV$FALSE;
        END;
    $SFRCH(.STENTRY);
    $GPOP();                                    % POP THE LABEL %
    END;


%****
  PROCESS A LABEL (I.E. TV$LABEL TOKEN). THIS ROUTINE IS CALLED BY $GEXEC EXCLUSIVELY.
****%
  GLOBAL ROUTINE $GLABL =
    BEGIN

    LOCAL S$ NAMESTE;

    NAMESTE := $SGSTE(.GBTKN$[A$STP]);
    $GPUSH(.GBTKN$,5);
    $GNLI(.NAMESTE);
    ZBSTK$[Z$SBID,.ZSTKP$] := ZV$LBL;
    ZBSTK$[Z$INCSTP,.ZSTKP$] := ZBSTK$[Z$DEFSTP,.ZSTKP$] := .NAMESTE[S$CISTP];
    $SFRNCH(.NAMESTE);

    %***
    GENERATE A GV$LABEL N-TUPLE
    ***%
    $GIREC(GV$LABEL,3);
    GGBOP$[0,G$OPTYP] := GV$STP;
    GGBOP$[0,G$OPVAL] := .ZBSTK$[Z$DEFSTP, .ZSTKP$];
    $GWBUF(.GGBFP$,.GOB1I$);
    END;


  END
ELUDOM
    