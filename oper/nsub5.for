      SUBROUTINE RELOC( IT )
      COMMON NREF,ICH,NLNX,IMODE,LOCCNT,LOCNXT,ICORE,IRADIX,LABEL
     1,INDRCT,NLINE,IPAGE,NCER,NEREF,IOCLAS,ICARD,NWDS,IWTYPE,IRELO
     2,NRELO,IWDCT,IADL,INOLOD,ITITLE,RELASM,XREF,PASS1
     3,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG,ANYPCH,CODE,LOCALS
     4,CROSS(3,1000),LN(81),LNX(81)
     5,ISOUR(80),NEREFS(50),NCERS(10),IWORD(40),IBL(22),LOCS(3)
      COMMON /CDS/ INFILE,IOFILE,IPFILE,ISCR
     1,LETA,LETB,LETC,LETD,LETE,LETZ,INU0,INU9,IPRD,IPLUS,ISEMI,IEQLS
     2,ICOLN,IBLNK,IRAGL,ILAGL,IAT,INLOD,ICOMA,ICLAS(7)
      LOGICAL RELASM,XREF,PASS1,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG
     1	  ,ANYPCH,CODE,LOCALS
      COMMON /LIMITS/ NSYMX,NREFX,NLINEX,NCERX,NEREFX
      COMMON / SYMTB / SYNAME(1000),SYVALU(1000),SYTYPE(1000),NSYM
      INTEGER SYNAME,SYTYPE,SYVALU,CROSS
C
C
C			     PROCESS THE RELOCATION BITS IT AND STORE
C			     IN THEIR PROPER PLACE
      I = IAND(IT,7)
      IF(( I.EQ.3).OR.(I.EQ.4)) I=7 - I
C			     LOOK AT THE SHIFT COUNT
      IF( IRELO .GT. 1 ) GO TO 10
C			     RECYCLE THE SHIFT AND BUMP THE WORD
      IRELO = 16
      NRELO = NRELO + 1
C
 10   CONTINUE
      IRELO = IRELO - 3
      IBL(NRELO) = IBL(NRELO) + ILEFT(I,IRELO)
      RETURN
      END
      SUBROUTINE SETUP
C
      COMMON NREF,ICH,NLNX,IMODE,LOCCNT,LOCNXT,ICORE,IRADIX,LABEL
     1,INDRCT,NLINE,IPAGE,NCER,NEREF,IOCLAS,ICARD,NWDS,IWTYPE,IRELO
     2,NRELO,IWDCT,IADL,INOLOD,ITITLE,RELASM,XREF,PASS1
     3,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG,ANYPCH,CODE,LOCALS
     4,CROSS(3,1000),LN(81),LNX(81)
     5,ISOUR(80),NEREFS(50),NCERS(10),IWORD(40),IBL(22),LOCS(3)
      COMMON /CDS/ INFILE,IOFILE,IPFILE,ISCR
     1,LETA,LETB,LETC,LETD,LETE,LETZ,INU0,INU9,IPRD,IPLUS,ISEMI,IEQLS
     2,ICOLN,IBLNK,IRAGL,ILAGL,IAT,INLOD,ICOMA,ICLAS(7)
      LOGICAL RELASM,XREF,PASS1,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG
     1	  ,ANYPCH,CODE,LOCALS
      COMMON /LIMITS/ NSYMX,NREFX,NLINEX,NCERX,NEREFX
      COMMON / SYMTB / SYNAME(1000),SYVALU(1000),SYTYPE(1000),NSYM
      INTEGER SYNAME,SYTYPE,SYVALU,CROSS
      COMMON /FILNM/ INAME,IONAME
      COMMON /XLIT/ NOLIST,EQFLG
      COMMON /CSEQ/ SEQ
      LOGICAL NOLIST,EQFLG,SEQ
C
      LOGICAL LDOP
      DIMENSION NAMS(3)
      NAMS(1) = 'NVSRC'
      NAMS(2) = 0
      NAMS(3) = 'LISTF'
      RELASM=.FALSE.
      LDOP=.FALSE.
      LOCALS=.FALSE.
      XREF=.TRUE.
      PTAPE=.TRUE.
      NOLIST=.FALSE.
      SEQ = .FALSE.
      TYPE 1002
 1002 FORMAT (' *'$)
      ACCEPT 1000, (LN(I), I=1,80)
 1000 FORMAT (80A1)
      DO 5 I=1,80
    5 ISOUR(I) = LN(I)
      LN(81) = 64
      CALL CONVRT(LN)
      ICH=1
  100 CONTINUE
      CALL NEXTNM(NAME)
      CALL FIND(NAME,I)
      IF(LN(ICH).NE.ICOMA) GO TO 130
      IF((I.LE.0).OR.(I.GT.8)) GO TO 400
      IF( I .EQ. 1 ) RELASM=.TRUE.
      IF( I .EQ. 2 ) RELASM=.FALSE.
      IF( I .EQ. 3 ) LDOP =.TRUE.
      IF( I .EQ. 4 ) XREF= .FALSE.
      IF( I .EQ. 5 ) LOCALS=.TRUE.
      IF( I .EQ. 6 ) PTAPE=.FALSE.
      IF( I .EQ. 7 ) NOLIST=.TRUE.
      IF( I .EQ. 8 ) SEQ=.TRUE.
      GO TO 100
C
C
  130 CONTINUE
      IF(LN(ICH).NE.IEQLS) GO TO 140
      ICH=ICH + 1
      IF((I. LT. 9) .OR. (I.GT.11)) GO TO 400
      CALL NEXTNM(NAME)
      IF(NAME.EQ.0) GO TO 400
      CALL ASNAM (NAME)
      I = I - 8
      NAMS(I) = NAME
      GO TO 100
  140 CONTINUE
      IF(LN(ICH).NE.64) GO TO 400
      INAME = NAMS(1)
      IPNAM = NAMS(2)
      IONAME = NAMS(3)
      CALL STOPSP(K)
      TYPE 2000, (ISOUR(I),I=1,K)
      IF ((.NOT.NOLIST).OR.(XREF)) CALL OFILE (IOFILE,IONAME)
      IF (PTAPE) CALL INITP (IPNAM)
      IF(LDOP) CALL LOADOP
 2000 FORMAT (' OPTIONS IN EFFECT:   ',80A1//)
      RETURN
  400 CONTINUE
      TYPE 4100, ICH
 4100 FORMAT (' ASSEMBLER OPTION ERROR ON OR NEAR CHARACTER
     * NUMBER' I5 /' ***  ASSEMBLER ABORTING ***'//)
      STOP
      END
      SUBROUTINE SKPBLK
      COMMON NREF,ICH,NLNX,IMODE,LOCCNT,LOCNXT,ICORE,IRADIX,LABEL
     1,INDRCT,NLINE,IPAGE,NCER,NEREF,IOCLAS,ICARD,NWDS,IWTYPE,IRELO
     2,NRELO,IWDCT,IADL,INOLOD,ITITLE,RELASM,XREF,PASS1
     3,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG,ANYPCH,CODE,LOCALS
     4,CROSS(3,1000),LN(81),LNX(81)
     5,ISOUR(80),NEREFS(50),NCERS(10),IWORD(40),IBL(22),LOCS(3)
      COMMON /CDS/ INFILE,IOFILE,IPFILE,ISCR
     1,LETA,LETB,LETC,LETD,LETE,LETZ,INU0,INU9,IPRD,IPLUS,ISEMI,IEQLS
     2,ICOLN,IBLNK,IRAGL,ILAGL,IAT,INLOD,ICOMA,ICLAS(7)
      LOGICAL RELASM,XREF,PASS1,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG
     1	  ,ANYPCH,CODE,LOCALS
      COMMON /LIMITS/ NSYMX,NREFX,NLINEX,NCERX,NEREFX
      COMMON / SYMTB / SYNAME(1000),SYVALU(1000),SYTYPE(1000),NSYM
      INTEGER SYNAME,SYTYPE,SYVALU,CROSS
C
C
 10   CALL IATNOL
      IF( LN(ICH) .NE. IBLNK ) RETURN
      ICH = ICH + 1
      GO TO 10
      END
      SUBROUTINE STOPSP(K)
      COMMON NREF,ICH,NLNX,IMODE,LOCCNT,LOCNXT,ICORE,IRADIX,LABEL
     1,INDRCT,NLINE,IPAGE,NCER,NEREF,IOCLAS,ICARD,NWDS,IWTYPE,IRELO
     2,NRELO,IWDCT,IADL,INOLOD,ITITLE,RELASM,XREF,PASS1
     3,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG,ANYPCH,CODE,LOCALS
     4,CROSS(3,1000),LN(81),LNX(81)
     5,ISOUR(80),NEREFS(50),NCERS(10),IWORD(40),IBL(22),LOCS(3)
      COMMON /CDS/ INFILE,IOFILE,IPFILE,ISCR
     1,LETA,LETB,LETC,LETD,LETE,LETZ,INU0,INU9,IPRD,IPLUS,ISEMI,IEQLS
     2,ICOLN,IBLNK,IRAGL,ILAGL,IAT,INLOD,ICOMA,ICLAS(7)
      LOGICAL RELASM,XREF,PASS1,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG
     1	  ,ANYPCH,CODE,LOCALS
      COMMON /LIMITS/ NSYMX,NREFX,NLINEX,NCERX,NEREFX
      COMMON / SYMTB / SYNAME(1000),SYVALU(1000),SYTYPE(1000),NSYM
      INTEGER SYNAME,SYTYPE,SYVALU,CROSS
C
C
      K = 80
      DO 10 I = 1,80
C
CLOOK FOR NON-BLANK CHARACTERS
C
      IF (LN(K).NE.IBLNK) RETURN
      K = K-1
  10  CONTINUE
      K = 80
C
CDIDN'T FIND ONE, RESET K TO END OF LINE
C
      RETURN
      END
      SUBROUTINE STRBLK( N )
      COMMON NREF,ICH,NLNX,IMODE,LOCCNT,LOCNXT,ICORE,IRADIX,LABEL
     1,INDRCT,NLINE,IPAGE,NCER,NEREF,IOCLAS,ICARD,NWDS,IWTYPE,IRELO
     2,NRELO,IWDCT,IADL,INOLOD,ITITLE,RELASM,XREF,PASS1
     3,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG,ANYPCH,CODE,LOCALS
     4,CROSS(3,1000),LN(81),LNX(81)
     5,ISOUR(80),NEREFS(50),NCERS(10),IWORD(40),IBL(22),LOCS(3)
      COMMON /CDS/ INFILE,IOFILE,IPFILE,ISCR
     1,LETA,LETB,LETC,LETD,LETE,LETZ,INU0,INU9,IPRD,IPLUS,ISEMI,IEQLS
     2,ICOLN,IBLNK,IRAGL,ILAGL,IAT,INLOD,ICOMA,ICLAS(7)
      LOGICAL RELASM,XREF,PASS1,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG
     1	  ,ANYPCH,CODE,LOCALS
      COMMON /LIMITS/ NSYMX,NREFX,NLINEX,NCERX,NEREFX
      COMMON / SYMTB / SYNAME(1000),SYVALU(1000),SYTYPE(1000),NSYM
      INTEGER SYNAME,SYTYPE,SYVALU,CROSS
C
C
C			     START A NEW RELOCATABLE BLOCK
C			     MAKE SURE THAT THE TYPE WILL CAUSE THE
C			     ADDRESS OF THE NEXT DATUM TO RESET THE ADDR
C			     ESS IN THE BUFFER
C
      IADL = -1
      IBL(1) = N
C			     RESET THE RELOCATION BITS POINTERS
      NRELO = 2
      IRELO = 0
      IWDCT = 6
C
      DO 10 I= 2,22
 10   IBL(I) = 0
      RETURN
      END
      SUBROUTINE STROLD
      COMMON NREF,ICH,NLNX,IMODE,LOCCNT,LOCNXT,ICORE,IRADIX,LABEL
     1,INDRCT,NLINE,IPAGE,NCER,NEREF,IOCLAS,ICARD,NWDS,IWTYPE,IRELO
     2,NRELO,IWDCT,IADL,INOLOD,ITITLE,RELASM,XREF,PASS1
     3,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG,ANYPCH,CODE,LOCALS
     4,CROSS(3,1000),LN(81),LNX(81)
     5,ISOUR(80),NEREFS(50),NCERS(10),IWORD(40),IBL(22),LOCS(3)
      COMMON /CDS/ INFILE,IOFILE,IPFILE,ISCR
     1,LETA,LETB,LETC,LETD,LETE,LETZ,INU0,INU9,IPRD,IPLUS,ISEMI,IEQLS
     2,ICOLN,IBLNK,IRAGL,ILAGL,IAT,INLOD,ICOMA,ICLAS(7)
      LOGICAL RELASM,XREF,PASS1,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG
     1	  ,ANYPCH,CODE,LOCALS
      COMMON /LIMITS/ NSYMX,NREFX,NLINEX,NCERX,NEREFX
      COMMON / SYMTB / SYNAME(1000),SYVALU(1000),SYTYPE(1000),NSYM
      INTEGER SYNAME,SYTYPE,SYVALU,CROSS
C
C
C			     BEGIN AN OLD STYLE OUTPUT BLOCK
C
C			     SET HIGH BIT ON
C			     SET LAST ADDRESS OUT OF RANGE SO
C			     ADDRESS WILL BE PUT IN ON NEXT ENTRY
      IADL = 65536
C			     ZERO THE OUTPUT BUFFER
      DO 10 I=1,22
 10   IBL(I) = 0
C			     SET WORD COUNT
      IWDCT = 3
      RETURN
      END
      SUBROUTINE TEXTS( IV )
C
C
      COMMON NREF,ICH,NLNX,IMODE,LOCCNT,LOCNXT,ICORE,IRADIX,LABEL
     1,INDRCT,NLINE,IPAGE,NCER,NEREF,IOCLAS,ICARD,NWDS,IWTYPE,IRELO
     2,NRELO,IWDCT,IADL,INOLOD,ITITLE,RELASM,XREF,PASS1
     3,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG,ANYPCH,CODE,LOCALS
     4,CROSS(3,1000),LN(81),LNX(81)
     5,ISOUR(80),NEREFS(50),NCERS(10),IWORD(40),IBL(22),LOCS(3)
      COMMON /CDS/ INFILE,IOFILE,IPFILE,ISCR
     1,LETA,LETB,LETC,LETD,LETE,LETZ,INU0,INU9,IPRD,IPLUS,ISEMI,IEQLS
     2,ICOLN,IBLNK,IRAGL,ILAGL,IAT,INLOD,ICOMA,ICLAS(7)
      LOGICAL RELASM,XREF,PASS1,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG
     1	  ,ANYPCH,CODE,LOCALS
      COMMON /LIMITS/ NSYMX,NREFX,NLINEX,NCERX,NEREFX
      COMMON / SYMTB / SYNAME(1000),SYVALU(1000),SYTYPE(1000),NSYM
      INTEGER SYNAME,SYTYPE,SYVALU,CROSS
C
C
      COMMON /TXTBLK/ JSVE,IJ,LCHAR,TXTMOD,LSVE
      LOGICAL TXTMOD
C
      IOCLAS = 4
      NWDS = 0
      IF( SKPFLG ) RETURN
      CODE = .TRUE.
      IWTYPE = 1
      IJ= IAND( IV, 7)
      IF(IJ .EQ. 5 ) GO TO 100
      IOCLAS = 2
      TXTFLG = .TRUE.
C
C			     SEARCH AHEAD TO FIRST NON-BLANK
    2 LCHAR = LN(ICH)
      IF( LCHAR .NE. IBLNK ) GO TO 4
      ICH = ICH + 1
      IF( ICH .LT. 80 ) GO TO 2
      CALL ERROR(1HT )
      NWDS = 1
      IWORD(1) = 0
      TXTFLG = .FALSE.
      GO TO 20
    4 CONTINUE
      LSVE = 8
      JSVE = 0
      CALL MORTXT
C
   20 CONTINUE
      IF( LABEL .NE. 0 ) CALL ADDSYM( LABEL, LOCCNT, IMODE)
      LOCNXT = LOCCNT + NWDS
      RETURN
  100 CONTINUE
      CALL EXPRES( IV, ITP, MO)
      IF( ITP.NE.1 .OR. MO.NE.1 ) CALL ERROR(1HX)
      TXTMOD = .FALSE.
      IF( IV .NE. 0 ) TXTMOD = .TRUE.
      IOCLAS = 3
      NWDS = 0
      IWORD(1) = IV
      RETURN
      END
      SUBROUTINE TITLE( IV)
C
C
      COMMON NREF,ICH,NLNX,IMODE,LOCCNT,LOCNXT,ICORE,IRADIX,LABEL
     1,INDRCT,NLINE,IPAGE,NCER,NEREF,IOCLAS,ICARD,NWDS,IWTYPE,IRELO
     2,NRELO,IWDCT,IADL,INOLOD,ITITLE,RELASM,XREF,PASS1
     3,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG,ANYPCH,CODE,LOCALS
     4,CROSS(3,1000),LN(81),LNX(81)
     5,ISOUR(80),NEREFS(50),NCERS(10),IWORD(40),IBL(22),LOCS(3)
      COMMON /CDS/ INFILE,IOFILE,IPFILE,ISCR
     1,LETA,LETB,LETC,LETD,LETE,LETZ,INU0,INU9,IPRD,IPLUS,ISEMI,IEQLS
     2,ICOLN,IBLNK,IRAGL,ILAGL,IAT,INLOD,ICOMA,ICLAS(7)
      LOGICAL RELASM,XREF,PASS1,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG
     1	  ,ANYPCH,CODE,LOCALS
      COMMON /LIMITS/ NSYMX,NREFX,NLINEX,NCERX,NEREFX
      COMMON / SYMTB / SYNAME(1000),SYVALU(1000),SYTYPE(1000),NSYM
      INTEGER SYNAME,SYTYPE,SYVALU,CROSS
C
C
      IWTYPE = 1
      IOCLAS = 4
      IF( SKPFLG ) RETURN
      RELASM = .TRUE.
      CALL GETSYM( ITITLE )
      IF( ITITLE .EQ. 0 ) CALL ERROR( 1HG)
      RETURN
      END
      SUBROUTINE TOP3(NAME, ITOP3)
      DATA MASK / 1073737728 /
      ITOP3 = IAND( MASK, NAME )
      RETURN
      END
      SUBROUTINE TYPE1( IVL, ITP)
      COMMON NREF,ICH,NLNX,IMODE,LOCCNT,LOCNXT,ICORE,IRADIX,LABEL
     1,INDRCT,NLINE,IPAGE,NCER,NEREF,IOCLAS,ICARD,NWDS,IWTYPE,IRELO
     2,NRELO,IWDCT,IADL,INOLOD,ITITLE,RELASM,XREF,PASS1
     3,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG,ANYPCH,CODE,LOCALS
     4,CROSS(3,1000),LN(81),LNX(81)
     5,ISOUR(80),NEREFS(50),NCERS(10),IWORD(40),IBL(22),LOCS(3)
      COMMON /CDS/ INFILE,IOFILE,IPFILE,ISCR
     1,LETA,LETB,LETC,LETD,LETE,LETZ,INU0,INU9,IPRD,IPLUS,ISEMI,IEQLS
     2,ICOLN,IBLNK,IRAGL,ILAGL,IAT,INLOD,ICOMA,ICLAS(7)
      LOGICAL RELASM,XREF,PASS1,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG
     1	  ,ANYPCH,CODE,LOCALS
      COMMON /LIMITS/ NSYMX,NREFX,NLINEX,NCERX,NEREFX
      COMMON / SYMTB / SYNAME(1000),SYVALU(1000),SYTYPE(1000),NSYM
      INTEGER SYNAME,SYTYPE,SYVALU,CROSS
C
C
C
C			     PROCESS AN ALC TYPE INST. REG. OR F.P.
C
C
      IOCLAS = 1
C			     GET FIRST AC
      CALL ACNUM( IACS )
C			     GET DESTINATION AC
      IF((LN(ICH).EQ.64).OR.(LN(ICH).EQ.ISEMI)) CALL ERROR(1HF)
      CALL ACNUM( IACD )
C			     LOOK FOR A CONDITIONAL
      CALL GETSYM( ICOND )
      IV = 0
      IT = 0
      IF( ICOND .EQ. 0 ) GO TO 10
      CALL LOOKUP( ICOND, IV, IT )
      IF( IT .EQ. 16 ) GO TO 10
C			     IT'S NOT A CONDITIONAL
      ICOND = 0
      IV = 0
      CALL ERROR( 1HQ )
C
C
 10   CONTINUE
      CALL NOTAT
      CALL CAREND
C			     CHECK THAT THE REST OF THE CARD IS OK
      IVL = ILEFT(IACS,13) + ILEFT(IACD,11) + IV + IVL
      IF( INOLOD .NE. 0 ) IVL = IOR( IVL, 8)
       IF( INDRCT .NE. 0 ) CALL ERROR(1HQ)
      NWDS = 1
      IWTYPE = 1
      IWORD(1) = IVL
      RETURN
      END
      SUBROUTINE TYPE2( IV, IT)
      COMMON NREF,ICH,NLNX,IMODE,LOCCNT,LOCNXT,ICORE,IRADIX,LABEL
     1,INDRCT,NLINE,IPAGE,NCER,NEREF,IOCLAS,ICARD,NWDS,IWTYPE,IRELO
     2,NRELO,IWDCT,IADL,INOLOD,ITITLE,RELASM,XREF,PASS1
     3,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG,ANYPCH,CODE,LOCALS
     4,CROSS(3,1000),LN(81),LNX(81)
     5,ISOUR(80),NEREFS(50),NCERS(10),IWORD(40),IBL(22),LOCS(3)
      COMMON /CDS/ INFILE,IOFILE,IPFILE,ISCR
     1,LETA,LETB,LETC,LETD,LETE,LETZ,INU0,INU9,IPRD,IPLUS,ISEMI,IEQLS
     2,ICOLN,IBLNK,IRAGL,ILAGL,IAT,INLOD,ICOMA,ICLAS(7)
      LOGICAL RELASM,XREF,PASS1,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG
     1	  ,ANYPCH,CODE,LOCALS
      COMMON /LIMITS/ NSYMX,NREFX,NLINEX,NCERX,NEREFX
      COMMON / SYMTB / SYNAME(1000),SYVALU(1000),SYTYPE(1000),NSYM
      INTEGER SYNAME,SYTYPE,SYVALU,CROSS
C
C
C			     PROCESS  INST WITH AC TYPE INST.
C
C
      IOCLAS = 1
C			     GET THE AC NUMBER
      IF((LN(ICH).EQ.64).OR.(LN(ICH).EQ.ISEMI)) CALL ERROR(1HF)
      CALL ACNUM( IAC )
C
      IV  = IV	+ ILEFT(IAC,11)
C			     CHECK THAT THE REST OF TH ECARD IS OK
      NWDS = 1
      IWTYPE = 1
      IWORD(1) = IV
      CALL NOTAT
      CALL NONOLD
      CALL CAREND
      RETURN
      END
      SUBROUTINE TYPE3( IVL, IT)
      COMMON NREF,ICH,NLNX,IMODE,LOCCNT,LOCNXT,ICORE,IRADIX,LABEL
     1,INDRCT,NLINE,IPAGE,NCER,NEREF,IOCLAS,ICARD,NWDS,IWTYPE,IRELO
     2,NRELO,IWDCT,IADL,INOLOD,ITITLE,RELASM,XREF,PASS1
     3,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG,ANYPCH,CODE,LOCALS
     4,CROSS(3,1000),LN(81),LNX(81)
     5,ISOUR(80),NEREFS(50),NCERS(10),IWORD(40),IBL(22),LOCS(3)
      COMMON /CDS/ INFILE,IOFILE,IPFILE,ISCR
     1,LETA,LETB,LETC,LETD,LETE,LETZ,INU0,INU9,IPRD,IPLUS,ISEMI,IEQLS
     2,ICOLN,IBLNK,IRAGL,ILAGL,IAT,INLOD,ICOMA,ICLAS(7)
      LOGICAL RELASM,XREF,PASS1,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG
     1	  ,ANYPCH,CODE,LOCALS
      COMMON /LIMITS/ NSYMX,NREFX,NLINEX,NCERX,NEREFX
      COMMON / SYMTB / SYNAME(1000),SYVALU(1000),SYTYPE(1000),NSYM
      INTEGER SYNAME,SYTYPE,SYVALU,CROSS
C
C
C			     PROCESS AN I/O INST
C
C
      IOCLAS = 1
C			     GET THE DEVICE CODE
      IF((LN(ICH).EQ.64).OR.(LN(ICH).EQ.ISEMI)) CALL ERROR(1HF)
      CALL DEVICE( IDVC )
C
      IVL = IVL + IDVC
C			     CHECK THAT THE REST OF THE CARD IS OK
      NWDS = 1
      IWTYPE = 1
      IWORD(1) = IVL
      CALL NOTAT
      CALL NONOLD
      CALL CAREND
      RETURN
      END
      SUBROUTINE TYPE4( IVL, IT)
      COMMON NREF,ICH,NLNX,IMODE,LOCCNT,LOCNXT,ICORE,IRADIX,LABEL
     1,INDRCT,NLINE,IPAGE,NCER,NEREF,IOCLAS,ICARD,NWDS,IWTYPE,IRELO
     2,NRELO,IWDCT,IADL,INOLOD,ITITLE,RELASM,XREF,PASS1
     3,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG,ANYPCH,CODE,LOCALS
     4,CROSS(3,1000),LN(81),LNX(81)
     5,ISOUR(80),NEREFS(50),NCERS(10),IWORD(40),IBL(22),LOCS(3)
      COMMON /CDS/ INFILE,IOFILE,IPFILE,ISCR
     1,LETA,LETB,LETC,LETD,LETE,LETZ,INU0,INU9,IPRD,IPLUS,ISEMI,IEQLS
     2,ICOLN,IBLNK,IRAGL,ILAGL,IAT,INLOD,ICOMA,ICLAS(7)
      LOGICAL RELASM,XREF,PASS1,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG
     1	  ,ANYPCH,CODE,LOCALS
      COMMON /LIMITS/ NSYMX,NREFX,NLINEX,NCERX,NEREFX
      COMMON / SYMTB / SYNAME(1000),SYVALU(1000),SYTYPE(1000),NSYM
      INTEGER SYNAME,SYTYPE,SYVALU,CROSS
C
C
C			     PROCESS AN I/O INST WITH AC
C
      IOCLAS = 1
      IT = 1
C			     GET THE AC NUMBER
      CALL ACNUM( IAC )
C			     GET THE DEVICE CODE
      IF((LN(ICH).EQ.64).OR.(LN(ICH).EQ.ISEMI)) CALL ERROR(1HF)
      CALL DEVICE( IDVC )
C
      IVL = IVL + ILEFT(IAC,11) + IDVC
      IWTYPE = 1
      NWDS = 1
      IWORD(1) = IVL
C			     CHECK THAT THE REST OF THE CARD IS OK
      CALL NOTAT
      CALL NONOLD
      CALL CAREND
      RETURN
      END
      SUBROUTINE TYPE5( IVL, IT)
      COMMON NREF,ICH,NLNX,IMODE,LOCCNT,LOCNXT,ICORE,IRADIX,LABEL
     1,INDRCT,NLINE,IPAGE,NCER,NEREF,IOCLAS,ICARD,NWDS,IWTYPE,IRELO
     2,NRELO,IWDCT,IADL,INOLOD,ITITLE,RELASM,XREF,PASS1
     3,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG,ANYPCH,CODE,LOCALS
     4,CROSS(3,1000),LN(81),LNX(81)
     5,ISOUR(80),NEREFS(50),NCERS(10),IWORD(40),IBL(22),LOCS(3)
      COMMON /CDS/ INFILE,IOFILE,IPFILE,ISCR
     1,LETA,LETB,LETC,LETD,LETE,LETZ,INU0,INU9,IPRD,IPLUS,ISEMI,IEQLS
     2,ICOLN,IBLNK,IRAGL,ILAGL,IAT,INLOD,ICOMA,ICLAS(7)
      LOGICAL RELASM,XREF,PASS1,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG
     1	  ,ANYPCH,CODE,LOCALS
      COMMON /LIMITS/ NSYMX,NREFX,NLINEX,NCERX,NEREFX
      COMMON / SYMTB / SYNAME(1000),SYVALU(1000),SYTYPE(1000),NSYM
      INTEGER SYNAME,SYTYPE,SYVALU,CROSS
C
C
C
C			     PROCESS A MEMORY REF INST
C
      IOCLAS = 1
C			     GO GET THE ADDRESS
      IF((LN(ICH).EQ.64).OR.(LN(ICH).EQ.ISEMI)) CALL ERROR(1HF)
      CALL ADDRES(IADR, KTYPE)
C
      IVL = IVL + IADR
      IT = KTYPE
      NWDS = 1
      IWTYPE = IT
      IWORD(1) = IVL
C			     CHECK THAT THE REST OF THE CARD IS OK
      CALL NONOLD
      CALL CAREND
      RETURN
      END
      SUBROUTINE TYPE6( IVL, IT)
      COMMON NREF,ICH,NLNX,IMODE,LOCCNT,LOCNXT,ICORE,IRADIX,LABEL
     1,INDRCT,NLINE,IPAGE,NCER,NEREF,IOCLAS,ICARD,NWDS,IWTYPE,IRELO
     2,NRELO,IWDCT,IADL,INOLOD,ITITLE,RELASM,XREF,PASS1
     3,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG,ANYPCH,CODE,LOCALS
     4,CROSS(3,1000),LN(81),LNX(81)
     5,IS0),NEREFS(50),NCERS(10),IWORD(40),IBL(22),LOCS(3)
      COMMON /CDS/ INFILE,IOFILE,IPFILE,ISCR
     1,LETA,LETB,LETC,LETD,LETE,LETZ,INU0,INU9,IPRD,IPLUS,ISEMI,IEQLS
     2,ICOLN,IBLNK,IRAGL,ILAGL,IAT,INLOD,ICOMA,ICLAS(7)
      LOGICAL RELASM,XREF,PASS1,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG
     1	  ,ANYPCH,CODE,LOCALS
      COMMON /LIMITS/ NSYMX,NREFX,NLINEX,NCERX,NEREFX
      COMMON / SYMTB / SYNAME(1000),SYVALU(1000),SYTYPE(1000),NSYM
      INTEGER SYNAME,SYTYPE,SYVALU,CROSS
C
C
C			     PROCESS A MEMORY REF WITH AC INST
C
      IOCLAS = 1
C			     GET THE AC NUMBER
      IF((LN(ICH).EQ.64).OR.(LN(ICH).EQ.ISEMI)) CALL ERROR(1HF)
      CALL ACNUM( IAC )
      IVL = IVL + ILEFT(IAC,11)
C			     NOW USE TYPE 5 TO GET THE ADDRESS
      CALL TYPE5( IVL, IT )
      RETURN
      END
      SUBROUTINE TYPE7( IVL, IT )
      COMMON NREF,ICH,NLNX,IMODE,LOCCNT,LOCNXT,ICORE,IRADIX,LABEL
     1,INDRCT,NLINE,IPAGE,NCER,NEREF,IOCLAS,ICARD,NWDS,IWTYPE,IRELO
     2,NRELO,IWDCT,IADL,INOLOD,ITITLE,RELASM,XREF,PASS1
     3,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG,ANYPCH,CODE,LOCALS
     4,CROSS(3,1000),LN(81),LNX(81)
     5,ISOUR(80),NEREFS(50),NCERS(10),IWORD(40),IBL(22),LOCS(3)
      COMMON /CDS/ INFILE,IOFILE,IPFILE,ISCR
     1,LETA,LETB,LETC,LETD,LETE,LETZ,INU0,INU9,IPRD,IPLUS,ISEMI,IEQLS
     2,ICOLN,IBLNK,IRAGL,ILAGL,IAT,INLOD,ICOMA,ICLAS(7)
      LOGICAL RELASM,XREF,PASS1,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG
     1	  ,ANYPCH,CODE,LOCALS
      COMMON /LIMITS/ NSYMX,NREFX,NLINEX,NCERX,NEREFX
      COMMON / SYMTB / SYNAME(1000),SYVALU(1000),SYTYPE(1000),NSYM
      INTEGER SYNAME,SYTYPE,SYVALU,CROSS
C
C
C			     PROCESS A USER  INST NO OTHER FIELDS
      IOCLAS = 1
      IT = 1
      NWDS = 1
      IWTYPE = 1
      IWORD(1) = IVL
      CALL CAREND
      RETURN
      END
      SUBROUTINE XREFS
      COMMON NREF,ICH,NLNX,IMODE,LOCCNT,LOCNXT,ICORE,IRADIX,LABEL
     1,INDRCT,NLINE,IPAGE,NCER,NEREF,IOCLAS,ICARD,NWDS,IWTYPE,IRELO
     2,NRELO,IWDCT,IADL,INOLOD,ITITLE,RELASM,XREF,PASS1
     3,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG,ANYPCH,CODE,LOCALS
     4,CROSS(3,1000),LN(81),LNX(81)
     5,ISOUR(80),NEREFS(50),NCERS(10),IWORD(40),IBL(22),LOCS(3)
      COMMON /CDS/ INFILE,IOFILE,IPFILE,ISCR
     1,LETA,LETB,LETC,LETD,LETE,LETZ,INU0,INU9,IPRD,IPLUS,ISEMI,IEQLS
     2,ICOLN,IBLNK,IRAGL,ILAGL,IAT,INLOD,ICOMA,ICLAS(7)
      LOGICAL RELASM,XREF,PASS1,PTAPE,SKPFLG,IFMODE,EOFLG,TXTFLG,ERRFLG
     1	  ,ANYPCH,CODE,LOCALS
      COMMON /LIMITS/ NSYMX,NREFX,NLINEX,NCERX,NEREFX
      COMMON / SYMTB / SYNAME(1000),SYVALU(1000),SYTYPE(1000),NSYM
      INTEGER SYNAME,SYTYPE,SYVALU,CROSS
C
C
      LOGICAL IPRT
      DATA IBK /1H / ,IXX /1HX /
C
      DIMENSION IX(18),INM(5),IVL(6)
      LOGICAL OVR
      IF(.NOT. XREF) RETURN
      IPRT=.TRUE.
      DO 100 I=1,NSYM
      J= SYTYPE(I)
      IF( IAND(J,32).NE.0)  GO TO 100
      K= IAND(J,31)
      IXTN = IBK
      IF( K .LE. 24 ) GO TO 5
      IXTN = IXX
      K = K - 24
    5 CONTINUE
      IF(K.GT.7) GO TO 100
      IF(IPRT) WRITE (IOFILE,1050)
 1050 FORMAT ('1'///15X,' CROSS REFERENCE TABLE'/10X,'NAME   LOC &
     * TYPE	 LINE'/34X, 'NUMBER'/)
      IPRT=.FALSE.
      L = IRIGHT(J,6)
      NT=0
   10 CONTINUE
      NF=0
      OVR=.FALSE.
      NT=NT+1
      IF(L.LE.0) GO TO 30
   20 CONTINUE
      IF( L .GT. NREFX ) GO TO 30
      NF=NF+1
      IX(NF) = CROSS(2,L)
      IF(CROSS(3,L).EQ.0) GO TO 30
      NF=NF+1
      IX(NF)= CROSS(3,L)
      L = CROSS(1,L)
      IF(L.LE.0) GO TO 30
      IF(NF.LT.18) GO TO 20
      OVR=.TRUE.
   30 IF(NT.NE.1) GO TO 50
      CALL CONV50(SYNAME(I),INM(1))
      J = SYVALU(I)
      CALL OCTL (J,IVL(1))
      IF(NF.GT.0) GO TO 40
      WRITE(IOFILE,1000) INM,IVL,ICLAS(K),IXTN
      GO TO 100
C
C
   40 WRITE(IOFILE,1000) INM,IVL,ICLAS(K),IXTN,(IX(N),N=1,NF)
 1000 FORMAT(11X5A1,2X6I1,1X2A1,4X18I6)
      GO TO 60
   50 WRITE (IOFILE,1001) (IX(N),N=1,NF)
 1001 FORMAT(31X18I6)
   60 IF(OVR) GO TO 10
  100 CONTINUE
      RETURN
      END
    @2Ü