TITLE   CMD     01/08/73
;*MAKE PART NUMBERS START AT ZERO INSTEAD OF ONE
;*FIX INVALID COMMAND MSG TO PRINT OUT COMMAND
;*MOVETHE IGNORE CHARACTER LOGIC TO UUO PACKAGE
;*FIND OUT HOW DASH IS USED IN LISTS OF FILE NAMES
;*SHOULD NOT ALLOW *X.*X AS A FILE NAME
;*MAKE SURE 'STORE NOT (JIMF)FILE.EXT' DOES WHAT IT SHOULD
;*BE SURE EXTRA LONG COMMAND GIVES PROPER DIAGNOSTIC
;*ACCEPT COMMANDS IN UPPER AND LOWER CASE
;*CHANGE QUIT TO NOT PRINT EXIT AND PRINT 3 CR'S INSTEAD
;*DISALLOW RESTORE CHANGED
        INTERNAL CIN,FF2,TE,NU
        EXTERNAL PRONUM,CHRCNT
        EXTERNAL JOBAPR,JOBCNI ;JOBTPC


W=      5       ;CURRENT PART OF COMMAND BEING READ
S=      6       ;CURRENT STATE
ASTRSK= 52
COLON=  72
QUOTE=  42
ECHR=   105
DOTCHR= 56
LBROK==74
RBROK==76

DATE==  14

CIN:    0
STACKL= 40                      ;LENGTH OF STACK
STACK:: XWD     -STACKL,.       ;INITIAL STACK POINTER
        BLOCK   STACKL          ;PUSH DOWN STACK
STACKE: 0                       ;STACK OVERFLOW MARKER

DEFINE  CMND(C,F,R,H)
< XWD [XWD F,R
       ASCIZ "H'"],[ASCIZ "C'"]>

DUM==   400000          ;DUMMY ENTRY - NO COMMAND
MOK==   200000          ;MORE PARTS TO COMMAND ARE OK

CM1==   1               ;FIRST PART OF ALL COMMANDS
SR2==   2               ;SECOND PART OF STORE/RESTORE
SR3==   3               ;THIRD PART OF STORE/RESTORE
MM2==   4               ;SECOND PART OF MODE
MS3==   5               ;THIRD PART OF MODE STORE/RESTORE
MO3==   6               ;THIRD PART OF MODE OLD FILE/SYS
NCSEC== 6               ;NUMBER OF DIFFERENT COMMAND SECTIONS
MORMSK==37              ;MASK OF FIELD FOR NEXT PART OF COMMAND

KF0TAB: CMND    DUMMY,CM1,0,<DUMMY ENTRY TO START ALL COMMANDS>

KF1TAB: BLOCK   0
        CMND STORE,SR2,STOROU##,<STORES FILES FROM DISC TO TAPE>
        CMND RESTORE,SR2,RESROU##,<RESTORES FILES TO DISC FROM TAPE>
        CMND DIRECTORY,0,DIRROU##,<PRINT DIRECTORY OF THE TAPE>
        CMND COF,0,COFROU,<CHANGE OUTPUT FILE FOR NEXT COMMAND>
        CMND REWIND,0,REWROU##,<REWIND THE TAPE>
        CMND RWNW,0,RWNROU##,<REWIND BUT DON'T WAIT FOR COMPLETION>
        CMND HELP,0,HELROU,<PRINTS LIST OF VALID COMMANDS>
        CMND INSTRUCTIONS,0,INSROU##,<PRINTS INSTRUCTIONS FOR USING TEX>
        CMND ?,0,HELROU,<SAME AS HELP>
        CMND QUIT,0,QUIROU##,<EXIT FROM PROGRAM>
        CMND SKIP,0,SKIROU,<SKIP N SAVE SETS OR TO END OF TAPE>
        CMND GET,SR2,GETROU##,<SAME AS RESTORE BUT RESTORES TO UFD OF USER RUNNING TEX>
        CMND SAMPLE,0,SAMROU##,<PRINT SAMPLE EXECUTIONS>
        CMND CAPABILITIES,0,CAPROU##,<CAPABILITIES OF THE PROGRAM>
        CMND MODE,MOK+MM2,MDEROU,<PRINT AND SET DEFAULT MODES>
       ;CMND CONTINUE,0,CNYI,<RESTART AN INTERRUPTED TAPE OPERATION>
       ;CMND STRUCTURE,0,CNYI,<SPECIFY A NON-STANDARD DISC STRUCTURE>
       ;CMND DENSITY,0,CNYI,<SPECIFY A TAPE DENSITY OTHER THAN 800 BPI>
       ;CMND FORMAT,0,CNYI,<SPECIFY A TAPE FORMAT OTHER THAN TEX FORMAT>
       ;CMND EXIT,0,CNYI,<SAME AS QUIT EXCEPT THAT TAPE IS NOT REWOUND>
       ;CMND GROUP,0,CNYI,<SPECIFY GROUP OF FILES ON TAPE FOR RESTORE>
       ;CMND CUT,0,CNYI,<SPECIFIES POINT WHERE FILES ARE TO BE ADDED TO TAPE>
       ;CMND DATE,0,CNYI,<PRINT DATE AND TIME>
       ;CMND ECHO,0,CNYI,<TURN ON OR OFF ECHOING FROM COMMAND FILES>
       ;CMND HUSH,0,CNYI,<TURN OFF ALL PROGRAM OUTPUT EXCEPT ERROR MESSAGES>
       ;CMND TALK,0,CNYI,<OPPOSITE OF HUSH>
       ;CMND VERSION,0,CNYI,<PRINT VERSION NUMBER>
KF1TBE: BLOCK   0

KF2TAB: CMND ALL,MOK+SR3,ALLROU,<ALL FILES>
;*      CMND NOT,0,CNYI,<EXCLUDES THE ITEMS LISTED>
        CMND HELP,0,HELROU,<LISTS VALID OPTIONS AT THIS POINT IN COMMAND>
        CMND ?,0,HELROU,<SAME AS HELP>
KF2TBE: BLOCK   0

GF2TAB: CMND <1-4,6>,DUM+MOK+SR3,0,<A LIST OF GLOBAL ACCOUNT NUMBERS>
GF2TBE: BLOCK   0

UF2TAB: CMND <[1,1],[1,4]>,DUM+MOK+SR3,0,<A LIST OF PPN NUMBERS>
UF2TBE: BLOCK   0

FF2TAB: CMND <[1,4]A.X,B.X>,DUM+MOK+SR3,0,<A LIST OF FILE NAMES PRECEDED BY A PPN NUMBER>
FF2TBE: BLOCK   0

;PF2TAB: CMND <#1,#5-#E>,DUM+MOK+SR3,0,<A LIST OF TAPE POSITION NUMBERS PRECEDED BY A #>
;PF2TBE: BLOCK   0

KF3TAB: CMND CREATED,0,CREROU,<COMMAND APPLIES ONLY TO FILES CREATED BEFORE OR AFTER HH:MM DA MON YR>
        CMND CHANGED,0,CHAROU,<COMMAND APPLIES ONLY TO FILES CHANGED SINCE LAST ALL FILES OR BACKUP>
        CMND <STARTING WITH>,0,STAROU,<RESTART WITH [GAN,UUN]FILE.EXT>
KF3TBE: BLOCK   0

KF4TAB: CMND STORE,MS3,MSROU,<MODES FOR STORE COMMAND>
        CMND RESTORE,MS3,MRROU,<MODES FOR RESTORE COMMAND>
        CMND OLD,MO3,MOROU,<MODES FOR RESTORING OLD FILES OTHER THAN SYS>
        CMND SYS,MO3,MSYROU,<MODES FOR RESTORING OLD FILES TO SYS>
KF4TBE: BLOCK   0

KF5TAB: CMND TOTALS,0,MSTROU,<PRINT TOTALS ONLY>
        CMND USERS,0,MSUROU,<PRINT TOTALS FOR EACH USER>
        CMND FILES,0,MSFROU,<PRINT EACH FILE NAME>
KF5TBE: BLOCK   0

KF6TAB: CMND NEWEST,0,MONROU,<RESTORE MOST RECENT FILE>
        CMND TAPE,0,MOTROU,<RESTORE THE FILE FROM TAPE>
        CMND DISC,0,MODROU,<RETAIN THE FILE CURRENTLY ON DISC>
        CMND CONFIRM,0,MOCROU,<ASK FOR CONFIRMATION BEFORE RESTORING>
KF6TBE: BLOCK   0

;THE FOLLOWING ARE ROUTINES TO READ ANYTHING AND EVERYTHING OUT OF THE
;COMMAND TABLE.  NOTHING SHOULD ACCESS THIS TABLE EXCEPT
;THROUGH THESE ROUTINES SO THAT THE FORMAT CAN EASILY BE CHANGED.
;ALL ROUTINES ARE CALLED WITH THE ADDRESS OF THE MAIN TABLE ENTRY IN R1.
;THE RESULT IS RETURNED IN R2.

GETHLP: BLOCK   0               ;GET ADDRESS OF FIRST WORD OF HELP MSG
        HLRZ    R2,(R1)         ;GET ADDRESS OF WORD BEFORE HELP MSG
        AOJA    R2,CPOPJ##      ;INCREMENT AND DO A POPJ

GETCMD: HRRZ    R2,(R1)         ;GET ADDRESS OF FIRST WORD OF COMMAND
        POPJ    P,              ;RETURN

GETFLG: BLOCK   0               ;GET FLAG WORD
        HLRZ    R2,(R1)         ;GET ADDRESS OF FLAG WORD
        MOVE    R2,(R2)         ;GET FLAGS
        POPJ    P,              ;RETURN

GETADR: BLOCK   0               ;GET ADDRESS OF ROUTINE FOR THIS CMD
        HLRZ    R2,(R1)         ;GET ADDRESS OF THE ADDRESS WE WANT
        MOVE    R2,(R2)         ;GET THE ADDRESS OF THE ROUTINE
        POPJ    P,              ;RETURN

GETTST: PUSH    P,R2            ;SAVE R2 ON THE STACK
        MOVE    R1,CTABLE-1(W)  ;GET POINTER TO LAST PART OF CMD READ
        PUSHJ   P,GETFLG        ;GET TYPE OF NEXT PART OF COMMAND
        HLRZ    R2,R2           ;PUT FLAGS IN RH
        ANDI    R2,MORMSK       ;KEEP ONLY THE TYPE
        MOVE    R1,TSTAB(R2)    ;ADDR OF TERM STATE TAB FOR THIS PART
        POP     P,R2            ;RESTORE R2 FROM STACK
        POPJ    P,              ;RETURN FROM GETTST

COMPTR: XWD     0700,COMBUF-1
COMPT1: XWD     0700,COMBUF-1
COMPT2: 0

COMBUF: BLOCK 100
COMBFE: BLOCK 0

CLDSP:: CLRIN                   ;CLEAR INPUT BUFFER
        JRST    CDISP           ;BRANCH TO COMMAND DISPATCHER

SCDISP::MOVEI   R1,ESCR1        ;GET ADDRESS OF ESCAPE ROUTINE
        MOVEM   R1,JOBAPR       ;PUT IN TRAP LOCATION
        MOVEI   R1,2000         ;BIT TO TRAP ESCAPES
        APRENB  R1,             ;TRAP ESCAPES
        SETZM   ESCFLG#         ;NO ESCAPES SEEN YET
CDISP:: BLOCK   0
                                ;*CHECK HERE FOR ESCAPES ENABLED*
        MOVE    P,STACK         ;ADJUST THE STACK
        SKIPE   STACKE          ;SKIP IF STACK HAS NOT OVERFLOWED
        TYPE    [ASCIZ "$STACK HAS OVERFLOWED.  REPORT TO S.Q.A.$"]
        SETZM   STACKE          ;MARK STACK AS NOT OVERFLOWED
        SETZM   COUT            ;OUTPUT TO TERMINAL
        SKIPN   COFCNT          ;SKIP IF OUTPUT FILE SHOULD NOT BE CLOSED
        RELEASE COF,            ;CLOSE OUTPUT AND RELEASE DEVICE
        SKIPN   COFCNT          ;SKIP IF OUTPUT FILE SHOULD NOT BE CLOSED
        SETZM   COFFLG          ;MARK FILE AS CLOSED
        PUSHJ   P,IPTR          ;INITIALIZE POINTER TO COMBUF
        SKIPE   CHRCNT          ;SKIP IF WE'RE AT START OF LINE
        TCO     [CRCHR]         ;CR IF WE NEED IT
        TCO     [ASTRSK]        ;OUTPUT COMMAND DISPATCHER SYMBOL (*)
        MOVEI   W,NPARTS        ;NUMBER OF PARTS IN A COMMAND
        SETZM   CTABLE(W)       ;INITIALIZE TABLE OF CMDS READ
        SETZM   CTABL2(W)       ;INITIALIZE TABLE DESCRIBING CMDS TO ROU
        SOJG    W,.-2           ;LOOP
        MOVEI   W,1             ;INITIALIZE PART OF CMD WE'RE WORKING ON
        SETZM   STRPPN##        ;ZERO THE STARTING PPN
        SETZM   STRFIL##        ;ZERO THE STARTING FILE
        SETZM   STRBLK##        ;ZERO THE STARTING BLOCK
        SETZM   CREDAT##        ;ZERO THE CREATION DATE
        SETZM   CRETIM##        ;ZERO THE CREATION TIME
        SETZM   CHANGD##        ;NOT LOOKING FOR CHANGED FILES YET
        SETZM   CURPPN##        ;NO CURRENT FILE
        SETZM   FILCNT##        ;NO FILES TRANSFERED FOR THIS USER
        SETZM   TOTCNT##        ;NO FILES TRANSFERED FOR THIS SAVE SET
NXTPRT: MOVE    R1,CTABLE-1(W)  ;GET PTR TO LAST PART OF CMD READ
        PUSHJ   P,GETFLG        ;GET TYPE OF NEXT PART OF COMMAND
        HLRZ    R2,R2           ;PUT FLAGS IN RH
        ANDI    R2,MORMSK       ;KEEP ONLY THE TYPE
        HLRZ    S,ISTAB(R2)     ;GET INITIAL STATE
        MOVE    R1,COMPTR       ;ADDRESS-1 OF STRING WE'LL READ
        ADDI    R1,1            ;MAKE IT POINT TO THE STRING
        HRRM    R1,CTABL2(W)    ;IF IT ISN'T A COMMAND WE'LL NEED IT
NXTCHR: TCI     CT,CH           ;GET A CHARACTER AND ITS TYPE
        SETZM   ESCFLG          ;SOMETHING DONE SINCE LAST ESCAPE
SAMCHR: MOVE    R1,CTABLE-1(W)  ;GET POINTER TO LAST PART OF CMD READ
        PUSHJ   P,GETFLG        ;GET TYPE OF NEXT PART OF COMMAND
        HLRZ    R2,R2           ;PUT FLAGS IN RH
        ANDI    R2,MORMSK       ;KEEP ONLY THE TYPE
        MOVE    R2,ISTAB(R2)    ;GET ADDRESS OF TABLES FOR THIS PART
        ADD     R2,S            ;ADD THE CURRENT STATE TO THIS ADDR
        MOVE    R2,(R2)         ;GET ADDRESS OF TABLE FOR THIS STATE
        ADD     R2,CT           ;ADD TYPE OF THE CHARACTER JUST READ
        HLRZ    S,(R2)          ;GET THE NEW STATE
        MOVE    R2,(R2)         ;GET ADDRESS OF ROUTINE TO GO TO
        JRST    (R2)            ;GO TO PROPER ROUTINE

EXTCOM: MOVEI   R1,CNTFC        ;DELIMITER IS A COMMA
        PUSHJ   P,FFTRM         ;TERMINATE THE EXTENSION NAME
FILDOT: AOS     R1,COMPTR       ;GET ADDR OF NEXT AVAILABLE WORD
        PUSHJ   P,S6PTR         ;SET UP POINTERS
        JRST    NXTCHR          ;GET NEXT CHARACTER
FILCOM: AOS     R1,COMPTR       ;GET ADDRESS OF NEXT AVAILABLE WORD
        PUSHJ   P,S6PTR         ;SET UP POINTERS
        JRST    SAMCHR          ;REPLAY THE SAME CHARACTER
ENDUN:  MOVEI   R1,CNTFT        ;TERMINATOR FOR USER LIST
        PUSHJ   P,UFTRM         ;STORE ACCUMULATOR
        PUSHJ   P,NPTR          ;REINITIALIZE THE POINTERS
STRTUN: MOVEI   R1,0600         ;SIXBIT BYTE POINTER
        HRLM    R1,COMPTR       ;CHANGE STRING PTR FROM 7 BIT TO SIXBIT
        HRLM    R1,COMPT1       ;DITTO
        HRRZ    R1,COMPT1       ;GET NEXT FREE ADDR-1
        SUBI    R1,COMBFE-1     ;NUMBER OF FREE WORDS
        IMUL    R1,[-6]         ;NUMBER OF FREE CHARACTERS
        MOVEM   R1,COMPT2       ;SAVE NUMBER OF AVAILABLE CHARACTERS
STOSIX: SUBI    CH,40           ;CONVERT CHAR JUST READ TO SIXBIT
STOCHR: WCI     CH,COMPTR
        ERROR   [ASCIZ "RAN OUT OF SPACE FOR INPUT STRING."]
        JRST    NXTCHR

ACCNUM: EXCH    CH,ACMLTR       ;GET NUMBER READ SO FAR
        IMULI   CH,10           ;*SHOULD THIS BE OCTAL OR DECIMAL?*
        SUBI    CH,60           ;CHAR READ WAS IN THE RANGE 60-71
        ADDM    CH,ACMLTR       ;FORM THE NEW RESULT
        JRST    NXTCHR          ;GET THE NEXT CHAR OF THE COMMAND
ACCEND: CAIE    CH,ECHR         ;SKIP IF CHAR "E" READ
        ERROR   [ASCIZ "ILLEGAL NUMBER READ"]
        SETOM   ACMLTR          ;SET NUMBER TO -1 FOR HIGHEST POSSIBLE
        JRST    NXTCHR          ;GET THE NEXT CHAR OF THE COMMAND
ACCCOM: SKIPA   R1,[CNTFC##]    ;NUMBER TERMINATED WITH A COMMA
ACCDSH: MOVEI   R1,CNTFD##      ;NUMBER TERMINATED WITH A DASH
        PUSHJ   P,GFTRM         ;STORE ACCUMULATOR IN LIST
        JRST    NXTCHR          ;READ THE NEXT CHARACTER

TSTLPI: CAIE    CH,LPAREN       ;DON'T SKIP IF LEFT BRACKET READ
        MOVEI   S,YL2           ;READ PPN INSTEAD OF USER NAME
        JRST    NXTCHR          ;GET THE NEXT CHARACTER

TSTLPP: CAIE    CH,LPAREN       ;DON'T SKIP IF LEFT BRACKET READ
        MOVEI   S,PL2           ;READ PPN INSTEAD OF USER NAME
        JRST    NXTCHR          ;GET THE NEXT CHARACTER
CONVUN: MOVE    R1,COMPTR       ;GET STARTING ADDR-1 OF USER NAME
        MOVE    R0,1(R1)        ;GET FIRST WORD OF USER NAME
        MOVE    R1,2(R1)        ;GET SECOND WORD OF USER NAME
        PUSHJ   P,USRPPN##      ;CONVERT USER NAME TO PPN
        ERROR   [ASCIZ "NO SUCH USER."]
        HRRZM   R0,ACMLTR       ;SAVE THE UNIVERSAL USER NUMBER
        JRST    NXTCHR          ;GET THE NEXT CHARACTER

TRMEOL: SKIPA   R2,[0]          ;LINE TERMINATED WITH CR OR LF
TRMNAT: HRREI   R2,-1           ;TERMINATION OF A PART OF THE COMMAND
        MOVEM   R2,EOLFLG#      ;SAVE FLAG TO KNOW HOW LINE WAS ENDED
        PUSHJ   P,GETTST        ;RETURN ADDR OF TERM STATE TABLE IN R1
        ADD     R1,S            ;ADDRESS OF ENTRY FOR THIS STATE
        MOVS    R2,(R1)         ;ADDRESS OF ROUTINE TO FINISH UP
        MOVEI   R1,CNTFT##      ;TERMINATING CHARACTER JUST READ
        PUSHJ   P,(R2)          ;FINISH READING WHATEVER WE JUST READ
        PUSHJ   P,GETTST        ;RETURN ADDR OF TERM STATE TABLE IN R1
        ADD     R1,S            ;GET ADDRESS FOR THIS STATE
        MOVE    R1,(R1)         ;GET TERM STATE TAB ENTRY FOR THIS STATE
        MOVE    R1,(R1)         ;GET ADDR OF CMD TABLE FOR THIS STATE
        PUSHJ   P,GETFLG        ;GET FLAGS FOR FIRST COMMAND IN TABLE
        MOVE    R3,CTABL2(W)    ;GET ADDRESS OF STRING JUST READ
        TLNN    R2,DUM          ;SKIP IF IT'S A DUMMY ENTRY
        PUSHJ   P,CMDSRC        ;SEARCH TABLE FOR COMMAND
        PUSH    P,R1            ;SAVE COMMAND POINTER ON STACK
        PUSHJ   P,NPTR          ;STRAIGHTEN UP POINTERS FOR NEXT PART
        POP     P,R1            ;RESTORE COMMAND POINTER FROM STACK
        HRLM    S,CTABLE(W)     ;SAVE THE STATE
        HRLM    S,CTABL2(W)     ;SAVE STATE FOR STORE/RESTORE
        PUSHJ   P,GETFLG        ;GET THE FLAGS FOR THIS THING
        HRRM    R1,CTABLE(W)    ;SAVE POINTER TO CMD TABLE
        TLNE    R2,MOK          ;SKIP IF MORE INPUT NOT OPTIONAL
        JRST    TRMNA3          ;CHECK FOR OPTIONAL INPUT
        TLNE    R2,MORMSK       ;SKIP IF THERE'S NO MORE
        AOJA    W,CPRMPT        ;PROMPT IF CARRIAGE RETURN TYPED
TRMNA2: SKIPGE  COFFLG          ;SKIP IF NO OUTPUT FILE
        SETOM   COUT##          ;OUTPUT NOW GOES TO OUTPUT FILE
        SETZM   COFCNT          ;TELL CDISP TO CLOSE OUTPUT FILE
TRMNA1: PUSHJ   P,GETTST        ;RETURN ADDR OF TERM STATE TABLE IN R1
        HLRZ    R3,CTABLE(W)    ;GET STATE FOR THIS PART OF COMMAND
        ADD     R3,(R1)         ;ADD ADDR OF BEG OF TERM STATE TAB
        MOVE    R1,(R3)         ;GET FIRST COMMAND IN TABLE FOR THIS STATE
        PUSHJ   P,GETFLG        ;GET THE FLAGS FOR THIS COMMAND
        TLNN    R2,DUM          ;SKIP IF IT'S A DUMMY COMMAND
        MOVE    R1,CTABLE(W)    ;NOT DUMMY SO GET READ COMMAND
        PUSHJ   P,GETADR        ;GET ADDRESS OF ROUTINE FOR CMD
        TRNN    R2,-1           ;SKIP IF A GOOD ADDRESS WAS FOUND
ALLREE: SOJG    W,TRMNA1        ;GET ADDR FROM PREVIOUS PART IF ANY
        SKIPG   W               ;SKIP IF WE HAVE A GOOD ADDRESS
        PUSHJ   P,FERR          ;FATAL ERROR
        JRST    (R2)            ;GO EXECUTE THE COMMAND

TRMNA3: SKIPE   EOLFLG          ;SKIP IF LINE TERMINATED
        AOJA    W,NXTPRT        ;INPUT NEXT PART OF COMMAND
        JRST    TRMNA2          ;DONE WITH INPUT SO PROCESS THE COMMAND

CPRMPT: SKIPN   EOLFLG          ;SKIP IF CARRIAGE RETURN NOT TYPED
PROMPT: TYPE    [ASCIZ "MORE INPUT NEEDED: "]
        JRST    NXTPRT          ;INPUT NEXT PART OF COMMAND

KFTRM:  MOVEI   R1,EOLIT        ;TERMINATE STRING
        WCI     R1,COMPTR       ;WRITE BACK ARROW TO END OF STRING
        PUSHJ   P,FERR          ;RAN OUT OF SPACE FOR STRING INPUT
        POPJ    P,              ;RETURN TO TRMNAT ROUTINE

UFTRM:  BLOCK   0
GFTRM:  DPB     R1,[XWD CNTFP##,ACMLTR]
        AOS     R2,COMPTR       ;INC AND GET ADDRESS OF LIST ENTRY
        MOVEM   R2,COMPT1       ;SET UP FOR NPTR
        MOVE    R1,ACMLTR       ;GET THE NUMBER TO BE SAVED
        MOVEM   R1,(R2)         ;STORE THE NUMBER
        SETZM   ACMLTR          ;ZERO ACCUMULATOR FOR NEXT TIME
        POPJ    P,              ;RETURN TO TRMNAT ROUTINE

FFTRM:  MOVE    R2,COMPTR       ;GET ADDR OF EXTENSION -1
        HLRZ    R3,1(R2)        ;PUT EXTENSION IN RH
        DPB     R1,[XWD CNTFP,R3]
        MOVEM   R3,1(R2)        ;PUT EXTENSION BACK WHERE IT BELONGS
        POPJ    P,              ;RETURN

CMDSRC: SETOM   GOODC#          ;INDICATE THAT NO CMDS HAVE BEEN FOUND
CDLP:   PUSHJ   P,GETCMD        ;GET ADDRESS OF THIS COMMAND'S NAME
        SSKE    R3,(R2)         ;SKIP IF THE STRINGS ARE EQUAL
        JRST    CDLP1           ;THEY'RE NOT EQUAL SO CHECK ANOTHER
        AOS     GOODC           ;INCREMENT THE NUMBER OF COMMANDS FOUND
        HRLM    R1,GOODC        ;SAVE POINTER INTO COMMAND TABLE
CDLP1:  AOBJN   R1,CDLP         ;CONTINUE SEARCH IF NOT DONE
        PUSHJ   P,NPTR          ;FIX PTR TO START ON WORD BOUNDARY
        MOVS    R1,GOODC        ;GET NUMBER OF COMMANDS FOUND AND PTR
        TLNE    R1,400000       ;SKIP IF AT LEAST ONE WAS FOUND
        JRST    CDLP0           ;INVALID COMMAND
        TLNN    R1,-1           ;SKIP IF ONLY ONE WAS FOUND
        POPJ    P,              ;RETURN WITH POINTER IN R1
        MOVE    R2,R1
        HLREM   R1,GOODC
        PUSHJ   P,GETTST        ;RETURN ADDR OF TERM STATE TABLE IN R1
        ADD     R1,S
        MOVE    R1,(R1)
        MOVE    R1,(R1)
        TLNE    R2,-2           ;SKIP IF ONLY TWO COMMANDS WERE FOUND
     ST    CDLP3
        TYPE    [ASCIZ "CANNOT DISTINGUISH BETWEEN "]
        PUSHJ   P,GETCMD
        SSKE    R3,(R2)
        AOBJN   R1,.-2
        TYPE    (R2)
        TCO     [SPACE]
CDLP2:  TYPE    [ASCIZ "AND "]
        AOBJN   R1,.+1
        PUSHJ   P,GETCMD
        SSKE    R3,(R2)
        AOBJN   R1,.-2
        TYPE    (R2)
        TCO     [DOTCHR]
        JRST    CLDSP
CDLP3:  TYPE    [ASCIZ "CANNOT DISTINGUISH AMONG "]
        PUSHJ   P,GETCMD
        SSKE    R3,(R2)
        AOBJN   R1,.-2
        TYPE    (R2)
        TYPE    [ASCIZ ", "]
        SOSLE   GOODC
        JRST    .-4
        JRST    CDLP2
CDLP0:  TYPE    (R3)            ;TYPE COMMAND JUST TYPED
        ERROR   [ASCIZ " IS AN INVALID COMMAND."]

HELROU: PUSHJ   P,GETTST        ;RETURN ADDR OF TERM STATE TAB IN R1
        MOVE    R3,R1           ;PUT ADDR IN R3
HELLP1: MOVE    R1,(R3)         ;GET TERM STATE TAB ENTRY FOR THIS STATE
        MOVE    R1,(R1)         ;GET ADDRESS OF COMMAND TABLE
HELLP:  PUSHJ   P,GETCMD        ;GET ADDRESS OF COMMAND STRING
        TYPE    (R2)            ;TYPE THE COMMAND
        TAB     15              ;TAB TO POSITION 15 OCTAL
        PUSHJ   P,GETHLP        ;GET ADDRESS OF THE HELP MESSAGE
        TYPE    (R2)            ;TYPE DESCRIPTION OF THE COMMAND
        TCO     [CRCHR]         ;END THE LINE WITH A CARRIAGE RETURN
        AOBJN   R1,HELLP        ;LOOP FOR NEXT CMD FOR THIS STATE
        AOBJN   R3,HELLP1       ;LOOP FOR NEXT STATE FOR THIS PART
        JRST    CDISP           ;*CHANGE THIS?*

ALLROU: MOVEI   R2,ALLLST##     ;DUMMY LIST FOR ALL FILES
        HRRM    R2,CTABL2(W)    ;SET UP THE LIST
        JRST    ALLREE          ;REENTER THE COMMAND DISPATCHER

STAROU: BLOCK   0               ;*KLUDGE - DO IT RIGHT ASAP
        SETZM   COUT            ;*KLUDGE TO PUT OUTPUT TO TERMINAL
        SKIPN   EOLFLG          ;SKIP IF NO NEED TO PROMPT
        JRST    STAPMT          ;PROMPT FOR PPN AND FILE.EXT
        TCI     CT,CH           ;INPUT A CHAR
        CAIN    CT,SP           ;SKIP IF NOT A SPACE
        JRST    .-2             ;TRY AGAIN
        CAIN    CT,TE           ;SKIP IF NOT A TERMINATOR
        JRST    STAPMT          ;PROMPT FOR PPN AND FILE.EXT
        CAIE    CT,AL           ;SKIP IF ALPHABETIC
        JRST    STALBR          ;CHECK FOR LEFT BRACKET
        TCI     CT,CH           ;READ ANOTHER CHAR
        CAIN    CT,AL           ;SKIP IF ALPHABETIC
        JRST    .-2             ;TRY AGAIN
        CAIN    CT,SP           ;SKIP IF NOT A SPACE
        JRST    STARED          ;START READING PPN ETC
        CAIE    CT,TE           ;SKIP IF TERMINATOR
        JRST    STALBR          ;CHECK FOR LEFT BRACKET
STAPMT: TYPE    [ASCIZ "TYPE [GAN,UUN]FILE.EXT"]
STARED: TCI     CT,CH           ;READ LEFT BRACKET
STALBR: CAIE    CT,LP           ;SKIP IF RIGHT BRACKET
        JRST    ILCH            ;ILLEGAL CHARACTER
        PUSHJ   P,READUN        ;READ USER NAME OR PPN
        MOVEM   R0,STRPPN       ;STORE STARTING UUN
        TCI     CT,CH           ;INPUT TERMINATOR OR FILE NAME
        CAIE    CT,NU           ;SKIP IF IT'S A NUMBER
        CAIN    CT,AL           ;SKIP IF NOT ALPHABETIC
        SKIPA                   ;SKIP ALWAYS
        JRST    CHARET          ;TERMINATOR OR BAD CHARACTER
        MOVEI   R1,0600         ;SIXBIT BYTE POINTER
        HRLM    R1,COMPTR       ;CHANGE STRING PTR FROM 7 BIT TO SIXBIT
        HRLM    R1,COMPT1       ;DITTO
        HRRZ    R1,COMPT1       ;GET NEXT FREE ADDR-1
        SUBI    R1,COMBFE-1     ;NUMBER OF FREE WORDS
        IMUL    R1,[-6]         ;NUMBER OF FREE CHARACTERS
        MOVEM   R1,COMPT2       ;SAVE NUMBER OF AVAILABLE CHARACTERS
        PUSHJ   P,STASIX        ;READ AND STORE FILE NAME
        AOS     R1,COMPTR       ;GET ADDRESS OF NEXT AVAILABLE WORD
        PUSHJ   P,S6PTR         ;SET UP NEW POINTERS
        MOVE    R1,@COMPTR      ;GET FILE NAME
        MOVEM   R1,STRFIL       ;SAVE STARTING FILE NAME
        CAIN    CT,AT           ;SKIP IF LAST CHAR NOT @ FOR STARTING WRD
        JRST    STATRM          ;END OF FILE NAME
        CAIE    CT,TE           ;SKIP IF LAST CHAR WAS A CR ETC
        CAIN    CT,SP           ;SKIP IF LAST CHAR WAS NOT A SPACE
        JRST    STATRM          ;TERMINATOR OF THIS PART OF COMMAND
        CAIE    CT,EX           ;IT HAD BETTER BE A DOT
        JRST    ILCH            ;ILLEGAL CHARACTER
        PUSHJ   P,STASX1        ;READ AND STORE EXTENSION
STATRM: AOS     R1,COMPTR       ;GET ADDRESS OF EXTENSION
        HLRZ    R2,(R1)         ;PUT EXTENSION IN RH
        MOVEM   R2,STREXT##     ;SAVE STARTING EXTENSION
        PUSHJ   P,S6PTR         ;INITIALIZE THE POINTERS FOR NEXT PART
        MOVEI   R0,0            ;DEFAULT STARTING BLK IS ZERO
        CAIN    CH,LBROK        ;SKIP IF LAST CHAR NOT < FOR STR BLK
        PUSHJ   P,RDDNUM        ;READ STARTING BLOCK NUMBER
        MOVEM   R0,STRBLK       ;SAVE STARTING BLOCK OF FILE
        CAIN    CH,RBROK        ;SKIP IF LAST CHAR WAS A >
        TCI     CT,CH           ;READ NEXT CHAR
CHARET: CAIN    CT,SP           ;SKIP IF LAST CHARACTER WAS NOT A SPACE
        JRST    NXTPRT          ;READ NEXT PART OF COMMAND
        CAIN    CT,TE           ;SKIP IF LAST CHAR WAS NOT A CR ETC
        JRST    ALLREE          ;CONTINUE DISPATCHING COMMAND
        JRST    ILCH            ;ILLEGAL CHARACTER
STASIX: SUBI    CH,40           ;CONVERT CHAR TO SIXBIT
        WCI     CH,COMPTR       ;WRITE CHAR TO STRING
        ERROR   [ASCIZ "RAN OUT OF SPACE FOR INPUT STRING."]
STASX1: TCI     CT,CH           ;INPUT THE NEXT CHARACTER
        CAIE    CT,NU           ;SKIP IF IT'S A NUMBER
        CAIN    CT,AL           ;SKIP IF IT'S NOT ALPHABETIC
        JRST    STASIX          ;LOOP
        POPJ    P,              ;RETURN

READUN: PUSH    P,R1            ;SAVE R1 ON STACK
        PUSH    P,R2            ;SAVE R2 ON STACK
        CAIE    CH,LPAREN       ;SKIP IF USER AND NOT PPN
        JRST    READPP          ;READ PPN
        PUSH    P,R3            ;SAVE R3 ON STACK
        MOVE    R0,[XWD 0600,1] ;BYTE POINTER POINTING TO R2
        SETZB   R2,R3           ;ZERO R2 AND R3 FOR STRING
REDUN2: TCI     CT,CH           ;READ NEXT CHAR OF USER NAME
        CAIN    CT,RP           ;SKIP IF NOT RIGHT PAREN
        JRST    REDUN1          ;DONE READING USER NAME
        SUBI    CH,40           ;CONVERT CHAR TO SIXBIT
        IBP     R0              ;INCREMENT BYTE POINTER
        TRNE    R0,777774       ;SKIP IF USER NAME NOT TOO LONG
        ERROR   [ASCIZ "USER NAME MAY NOT BE LONGER THAN 12 CHARACTERS."]
        DPB     CH,R0           ;DEPOSIT BYTE IN STRING
        JRST    REDUN2          ;GET NEXT CHARACTER
REDUN1: MOVE    R0,R2           ;NEED USER NAME IN R0 AND R1
        MOVE    R1,R3           ;MOVE SECOND HALF OF USER NAME
        PUSHJ   P,USRPPN        ;CONVERT USER NAME TO PPN
        ERROR   [ASCIZ "NO SUCH USER."]
        POP     P,R3            ;RESTORE R3 FROM STACK
UU1RE2: POP     P,R2            ;RESTORE R2 FROM STACK
        POP     P,R1            ;RESTORE R1 FROM STACK
        POPJ    P,              ;RETURN
READPP: PUSHJ   P,RDONUM##      ;READ GAN
        CAIE    CT,CO           ;SKIP IF TERMINATED WITH A COMMA
        JRST    ILCH            ;ILLEGAL TERMINATOR
        MOVE    R2,R0           ;SAVE GAN IN R2
        PUSHJ   P,RDONUM        ;READ UUN
        HRL     R0,R2           ;COMBINE GAN AND UUN TO FORM PPN
        CAIE    CT,RP           ;SKIP IF TERMINATED WITH RIGHT BRACKET
        JRST    ILCH            ;ILLEGAL TERMINATOR
        JRST    UU1RE2          ;RETURN FROM READUN

MODWRD: BYTE    (2)MSMUSR,MSMUSR,MOMCON,MOMCON ;DEFAULT MODES
MODTMP: 0                       ;TEMP CELL FOR STORING MODE

MSPTR:: POINT   2,MODWRD,1      ;POINTER FOR STORE MODES
MRPTR:: POINT   2,MODWRD,3      ;POINTER FOR RESTORE MODES
MOPTR:: POINT   2,MODWRD,5      ;POINTER FOR OLD FILE MODES
MSYPTR::POINT   2,MODWRD,7      ;POINTER FOR OLD SYS FILE MODES

MSMTOT==:0                      ;MODE FOR STORE/RESTORE IS TOTALS
MSMUSR==:2                      ;MODE FOR STORE/RESTORE IS USERS
MSMFIL==:3                      ;MODE FOR STORE/RESTORE IS FILES

MOMNEW==:0                      ;MODE FOR OLD/SYS IS NEWEST
MOMTAP==:1                      ;MODE FOR OLD/SYS IS TAPE
MOMDIS==:2                      ;MODE FOR OLD/SYS IS DISC
MOMCON==:3                      ;MODE FOR OLD/SYS IS CONFIRM

MODROU: SKIPA   R1,[MOMDIS]     ;GET MODE FOR KEEPING DISC FILE
MOCROU: MOVEI   R1,MOMCON       ;GET MODE FOR CONFIRMATION
MOCOM:  MOVEM   R1,MODTMP       ;SAVE IT FOR NEXT PART OF THE COMMAND
        JRST    ALLREE          ;REENTER THE COMMAND DISPATCHER
MONROU: SKIPA   R1,[MOMNEW]     ;MODE TO KEEP NEWEST FILE
MOTROU: MOVEI   R1,MOMTAP       ;MODE TO RESTORE THE TAPE FILE
        JRST    MOCOM           ;SAVE MODE AND REENTER COMMAND DISPATCHER
MSFROU: MOVEI   R1,MSMFIL       ;PRINT EACH FILE NAME
        JRST    MOCOM           ;SAVE MODE AND REENTER CMD DISPATCHER
MSTROU: SKIPA   R1,[MSMTOT]     ;PRINT ONLY TOTALS FOR THE TAPE
MSUROU: MOVEI   R1,MSMUSR       ;PRINT TOTALS FOR EACH USER
        JRST    MOCOM           ;SAVE MODE AND REENTER CMD DISPATCHER

MSROU:  MOVE    R1,MODTMP       ;GET THE MODE
        DPB     R1,MSPTR        ;SAVE NEW STORE MODE
        JRST    CDISP           ;REENTER COMMAND DISPATCHER
MRROU:  MOVE    R1,MODTMP       ;GET THE MODE
        DPB     R1,MRPTR        ;SAVE NEW RESTORE MODE
        JRST    CDISP           ;REENTER THE COMMAND DISPATCHER
MOROU:  MOVE    R1,MODTMP       ;GET THE NEW MODE
        DPB     R1,MOPTR        ;SAVE THE NEW OLD FILE MODE
        JRST    CDISP           ;REENTER THE COMMAND DISPATCHER
MSYROU: MOVE    R1,MODTMP       ;GET THE NEW MODE
        DPB     R1,MSYPTR       ;SAVE THE NEW SYS MODE
        JRST    CDISP           ;REENTER THE COMMAND DISPATCHER

MDEROU: TYPE    [ASCIZ "STORE:   "]
        LDB     R1,MSPTR        ;GET MODE FOR STORE
        PUSHJ   P,TYPSRM        ;TYPE STORE/RESTORE MODE
        TYPE    [ASCIZ "RESTORE: "]
        LDB     R1,MRPTR        ;GET RESTORE MODE
        PUSHJ   P,TYPSRM        ;TYPE STORE/RESTORE MODE
        TYPE    [ASCIZ "OLD FILES:    "]
        LDB     R1,MOPTR        ;GET MODE FOR OLD FILES
        PUSHJ   P,TYPOM         ;TYPE OLD FILE MODE
        TYPE    [ASCIZ "OLD SYS FILES:"]
        LDB     R1,MSYPTR       ;GET SYS MODE
        PUSHJ   P,TYPOM         ;TYPE OLD FILE MODE
        JRST    CDISP           ;RETURN TO COMMAND DISPATCHER

TYPSRM: CAIN    R1,MSMTOT       ;SKIP IF NOT TOTALS
        TYPE    [ASCIZ "TOTALS$"]
        CAIN    R1,MSMUSR       ;SKIP IF NOT USERS
        TYPE    [ASCIZ "USERS$"]
        CAIN    R1,MSMFIL       ;SKIP IF NOT FILES
        TYPE    [ASCIZ "FILES$"]
        POPJ    P,              ;RETURN FROM TYPSRM

TYPOM:  CAIN    R1,MOMNEW       ;SKIP IF NOT NEWEST
        TYPE    [ASCIZ "NEWEST$"]
        CAIN    R1,MOMTAP       ;SKIP IF NOT TAPE
        TYPE    [ASCIZ "TAPE$"]
        CAIN    R1,MOMDIS       ;SKIP IF NOT DISC
        TYPE    [ASCIZ "DISC$"]
        CAIN    R1,MOMCON       ;SKIP IF NOT CONFIRM
        TYPE    [ASCIZ "CONFIRM$"]
        POPJ    P,              ;RETURN FROM TYPOM

SKIROU: SETZM   COUT            ;*KLUDGE
        SKIPN   EOLFLG          ;SKIP IF NO NEED TO PROMPT
        TYPE    [ASCIZ "NUMBER OF SAVE SETS TO SKIP (DECIMAL): "]
        SETZ    R0,             ;ZERO THE ACCUMULATOR
SKILUP: TCI     CT,CH           ;READ IN THE NEXT CHAR
        CAIN    CT,TE           ;SKIP IF NOT A TERMINATOR
        JRST    SKITRM          ;END OF LINE
        CAIN    CH,ECHR         ;SKIP IF NOT CHAR E
        JRST    SKIEND          ;SKIP TO END OF TAPE
        CAIE    CT,NU           ;SKIP IF IT'S A DIGIT
        ERROR   [ASCIZ "INVALID CHARACTER"]
        IMULI   R0,12           ;MULTIPLY ACCUMULATOR BY TEN
        ADDI    R0,(CH)         ;ADD TO ACCUMULATOR
        SUBI    R0,60           ;CONVERT CHAR TO DIGIT
        JRST    SKILUP          ;GET NEXT DIGIT
SKIEND: MOVE    R0,[XWD 377777,777777] ;HIGHEST POSSIBLE NUMBER
        TCI     CT,CH           ;READ NEXT CHARACTER
        CAIE    CT,TE           ;SKIP IF IT'S A TERMINATOR
        JRST    .-2             ;LOOP
        JRST    SKITRM##        ;GO TO SKIP ROUTINE IN TAPE PACKAGE

CHAROU: SETOM   CHANGD          ;LOOKING ONLY FOR CHANGED FILES
        JRST    CHARET          ;FINISH PROCESSING COMMAND

COFENT: BLOCK   4               ;TABLE FOR ENTER
COFENE= COFENT+3

COFFIL: 0
COFEXN: 0
        0                       ;PROT-TIME-DATE FOR ENTER
        0                       ;PPN FOR ENTER
DEVWRD: XWD     DEVTAB-DEVTBE,DEVTAB
DEVTAB: XWD     PRIDEV,[ASCIZ "PRINTER"]
;*      XWD     NOTDEV,[ASCIZ "NOTHING"]
        XWD     CDISP,[ASCIZ "TERMINAL"]
        XWD     CDISP,[ASCIZ "TELETYPE"]
DEVTBE: BLOCK   0
COFXBF: BLOCK   203*2           ;*LET'S HOPE THIS IS RIGHT
COFSTS: 0                       ;COF STATUS WORD
COFDEV: 0                       ;COF DEVICE WORD
COFBUF: 0                       ;COF BUFFER WORD
AL==1
COF==2
COFN==2

;*THIS THING IS A KLUDGE AND SHOULD BE REDONE ASAP
;*IT SHOULD BE ABLE TO ACCESS FILES IN OTHER DIRECTORIES
COFROU: SETZM   COUT            ;*KLUDGE
        SKIPN   EOLFLG          ;SKIP IF NO NEED TO PROMPT
        TYPE    [ASCIZ "TO FILE: "]
        MOVEI   R0,COFXBF       ;ADDRESS OF COF BUFFER
        MOVEM   R0,JOBFF##      ;THIS IS WHERE BUFFER SHOULD GO
        MOVEI   R0,AL           ;ASCII LINE MODE
        MOVEM   R0,COFSTS       ;SAVE THE STATUS
        MOVSI   R0,COFHED##     ;CHANGE OUTPUT FILE BUFFER HEADER
        MOVEM   R0,COFBUF       ;ADDRESS OF OUTPUT BUFFER
        MOVE    R3,[XWD 0600,R2-1]
        SETZ    R2,             ;FILE NAME TO BE READ
        MOVEI   R0,6            ;SIX CHAR IN FILE NAME
COFCHR: TCI     CT,CH           ;READ A CHAR OF FILE NAME
        CAIN    CT,TE           ;SKIP IF NOT A CARRIAGE RETURN
        JRST    COFTRM          ;END OF LINE
        WCI     CH,COMPTR       ;WRITE CHAR TO STRING
        ERROR   [ASCIZ "TOO MANY CHARACTERS IN COMMAND"]
        CAIN    CT,EX           ;SKIP IF NOT DOT
        JRST    COFEXT          ;START READING EXTENSION
        SOJL    R0,COFCHR       ;JUMP IF SIX CHAR READ
        SUBI    CH,40           ;CONVERT TO SIXBIT
        IDPB    CH,R3           ;ADD CHAR TO FILE NAME
        JRST    COFCHR          ;LOOP
COFEXT: MOVEM   R2,COFFIL       ;SAVE THE FILE NAME
        SETZ    R2,             ;ZERO THE EXTENSION
        MOVE    R3,[XWD 0600,R2-1]
        MOVEI   R0,3            ;READ THREE CHAR FOR EXTENSION
COFXCH: TCI     CT,CH           ;READ A CHAR OF EXTENSION
        CAIN    CT,TE           ;SKIP IF NOT CR ETC
        JRST    COFXTR          ;END OF EXTENSION
        SOJL    R0,COFXCH       ;JUMP IF THREE CHAR READ
        SUBI    CH,40           ;CONVERT CHARACTER TO SIXBIT
        IDPB    CH,R3           ;ADD CHAR TO EXTENSION
        JRST    COFXCH          ;LOOP

COFTRM: MOVEM   R2,COFFIL       ;SAVE THE FILE NAME
        SETZ    R2,             ;ZERO THE EXTENSION
COFXTR: MOVEM   R2,COFEXN       ;SAVE THE EXTENSION
        MOVEI   R1,EOLIT        ;TERMINATE STRING
        WCI     R1,COMPTR       ;ADD IT TO STRING
        ERROR   [ASCIZ "TOO MANY CHARACTERS IN COMMAND"]
        MOVE    R1,DEVWRD       ;LOOP CONTROL WORD
        MOVE    R3,COMPTR       ;STRING WE JUST READ
        ADDI    R3,1            ;POINT TO STRING
COFLUP: MOVE    R2,(R1)         ;GET ADDRESS OF STRING TO COMPARE
        SSKE    R3,(R2)         ;SKIP IF STRINGS MATCH
        AOBJN   R1,COFLUP       ;LOOP IF NOT DONE
        MOVS    R2,(R1)         ;GET ADDRESS TO GO TO
        JUMPL   R1,(R2)         ;GO THERE IF STRINGS MATCHED
        MOVSI   R1,(SIXBIT /DSK/)
        MOVEM   R1,COFDEV       ;DEVICE IS DISC
        OPEN    COF,COFSTS      ;INIT THE DEVICE
        ERROR   [ASCIZ "CANNOT ACCESS DEVICE"]
        OUTBUF  COF,COFN        ;SET UP BUFFERS
        MOVE    R1,[XWD COFFIL,COFENT]
        BLT     R1,COFENE       ;SET UP TABLE FOR LOOKUP
        LOOKUP  COF,COFENT      ;SEE IF IT'S ALREADY THERE
        JRST    COFNEW          ;IT'S A NEW FILE
        TYPE    [ASCIZ "OLD FILE "]
        CLOSE   COF,            ;CLOSE THE FILE WE JUST OPENED
COFTST: TCI     CT,CH
        JRST    .+2
        TCI     CT,CH
        CAIE    CT,TE
        JRST    .-2
        CAIE    CH,CRCHR
        JRST    COFABT
        MOVE    R1,[XWD COFFIL,COFENT]
        BLT     R1,COFENE       ;SET UP TABLE FOR ENTER
        ENTER   COF,COFENT
        ERROR   [ASCIZ "UNABLE TO DO ENTER ON FILE"]
COFRET: SETOM   COFFLG#         ;TELL CDISP THERE IS A COF FILE
        SETOM   COFCNT#         ;TELL CDISP NOT TO CLOSE COF FILE
        JRST    CDISP
COFNEW: TYPE    [ASCIZ "NEW FILE "]
        JRST    COFTST
COFABT: RELEASE COF,
        JRST    CDISP
PRIDEV: MOVSI   R1,(SIXBIT /LPT/)
        MOVEM   R1,COFDEV
        OPEN    COF,COFSTS
        ERROR   [ASCIZ "UNABLE TO ACCESS THE LINE PRINTER"]
        JRST    COFRET

AFTSTR: ASCIZ   "AFTER"
BEFSTR: ASCIZ   "BEFORE"

CREROU: PUSHJ   P,READKW        ;READ IN A KEYWORD
        SSKE    R3,BEFSTR       ;SKIP IF HE TYPED "BEFORE"
        SKIPA                   ;SKIP ALWAYS
        ERROR   [ASCIZ "BEFORE IS NOT YET IMPLEMENTED."]
        SSKE    R3,AFTSTR       ;SKIP IF HE TYPED "AFTER"
        ERROR   [ASCIZ "INVALID PARAMETER TYPED."]
        CAIN    CT,TE           ;SKIP IF NOT TERMINATED BY A CR
        TYPE    [ASCIZ "TYPE DATE AS HH:MM DD MON YY: "]
        AOS     R1,COMPTR       ;GET ADDRESS OF CURRENT STRING
        PUSHJ   P,SPTR          ;RETURN THE SPACE
        PUSHJ   P,RDDNUM##      ;READ HOURS
        MOVE    R3,R0           ;SAVE HOURS IN R3
        CAIE    CH,COLON        ;SKIP IF TERMINATED BY A COLON
        ERROR   [ASCIZ "HOURS MUST BE TERMINATED BY A COLON."]
        CAIL    R3,30           ;SKIP IF HOURS LESS THAN TWENTY-FOUR
        ERROR   [ASCIZ "HOURS MUST BE LESS THAN 24"]
        IMULI   R3,74           ;CONVERT HOURS TO MINUTES
        PUSHJ   P,RDDNUM        ;READ MINUTES
        CAIL    R0,74           ;SKIP IF MINUTES LESS THAN SIXTY
        ERROR   [ASCIZ "MINUTES MUST BE LESS THAN 60."]
        ADD     R3,R0           ;ADD MINUTES TO HOURS
        IMULI   R3,740000       ;CONVERT TO SECONDS AND SHIFT TO PROPER PLACE
        MOVEM   R3,CRETIM       ;SAVE CREATION TIME
        CAIN    CT,TE           ;SKIP IF TERMINATED WITH A CR
        JRST    CREDMY          ;USE CURRENT DAY-MONTH-YEAR
        CAIE    CT,SP           ;SKIP IF TERMINATED WITH A SPACE
        ERROR   [ASCIZ "TIME MUST BE TERMINATED WITH A SPACE OR CARRIAGE RETURN."]
        PUSHJ   P,RDDNUM        ;READ DAY OF MONTH
        CAIE    R0,0            ;SKIP IF IT'S ZERO
        CAIL    R0,40           ;SKIP IF DAY LESS THAN 32
        ERROR   [ASCIZ "DAY MUST BE IN THE RANGE 0-31."]
        SOS     R3,R0           ;PUT DAY-1 IN R3
        CAIN    CT,TE           ;SKIP IF NOT TERMINATED WITH A CR
        JRST    CREMY           ;USE CURRENT MONTH-YEAR
        CAIE    CT,SP           ;SKIP IF TERMINATED WITH A SPACE
        CAIN    CT,DA           ;SKIP IF NOT TERM WITH A DASH
        SKIPA                   ;TERMINATED WITH SPACE, DASH, OR CR
        ERROR   [ASCIZ "DAY MUST BE TERMINATED WITH A SPACE, DASH, OR CARRIAGE RETURN."]
        PUSHJ   P,RDMON##       ;READ MONTH-1 AND RETURN IT IN R2
        IMULI   R2,37           ;CONVERT MONTH TO DAY OF YEAR
        ADD     R3,R2           ;ADD IT INTO THE DAY OF MONTH
        TCI     CT,CH           ;READ CR OR SPACE AFTER MONTH
        CAIN    CT,TE           ;SKIP IF NOT A CARRIAGE RETURN
        JRST    CREY            ;USE CURRENT YEAR
        CAIE    CT,SP           ;SKIP IF TERMINATED WITH A SPACE
        CAIN    CT,DA           ;SKIP IF NOT TERMINATED WITH A DASH
        SKIPA                   ;TERMINATED WITH A SPACE OR DASH
        ERROR   [ASCIZ "YEAR MUST BE TERMINATED WITH A SPACE, DASH, OR CARRIAGE RETURN."]
        PUSHJ   P,RDDNUM        ;READ YEAR
        CAIL    R0,100          ;SKIP IF LESS THAN SIXTY-FOUR
        CAIL    R0,144          ;SKIP IF LESS THAN ONE HUNDRED
        ERROR   [ASCIZ "YEAR MUST BE IN THE RANGE 64-99."]
        SUBI    R0,100          ;CONVERT TO YEARS SINCE 1964
CRETRM: IMULI   R0,14*37        ;CONVERT TO DAYS SINCE 1964
CRETR1: ADD     R3,R0           ;ADD IT INTO THE DAY OF THE DAY
CRETR2: HRRZM   R3,CREDAT       ;SAVE CREATION DATE
        CAIE    CT,TE           ;SKIP IF TERMINATED WITH A CARRIAGE RET
        JRST    NXTPRT          ;CONTINUE READING COMMAND
        SOJA    W,TRMNA2        ;CONTINUE DISPATCHING COMMAND
CREY:   CALLI   R0,DATE         ;READ CURRENT DATE
        IDIVI   R0,14*37        ;CONVERT TO YEARS SINCE 1964
        JRST    CRETRM          ;FINISH UP
CREMY:  CALLI   R0,DATE         ;GET CURRENT DATE
        IDIVI   R0,37           ;CONVERT TO MONTHS SINCE 1964
        IMULI   R0,37           ;CONVERT THAT BACK TO DAYS
        JRST    CRETR1          ;FINISH UP
CREDMY: CALLI   R3,DATE         ;READ CURRENT DATE
        JRST    CRETR2          ;FINISH UP

CNYI:   BLOCK   0               ;ROUTINE FOR COMMANDS NOT YET IMPLEMENTED
        PUSHJ   P,GETCMD        ;GET ADDRESS OF COMMAND NAME
        TYPE    (R2)            ;TYPE THE NAME OF THE COMMAND
        ERROR   [ASCIZ " NOT YET IMPLEMENTED"]

CFNYI:  ERROR   [ASCIZ "COMMAND FILES NOT YET IMPLEMENTED"]

ILCH:   TYPE    [ASCIZ "ILLEGAL INPUT CHARACTER: "]
        TCO     [LPAREN]        ;TYPE LEFT PAREN
        MOVE    R0,CH           ;PUT NUMBER IN R0 TO PRINT
        PUSHJ   P,PRONUM        ;PRINT OCTAL NUMBER
        TCO     [RPAREN]        ;TYPE RIGHT PAREN
        TCO     [SPACE]         ;SPACE
        TCO     [QUOTE]         ;OUTPUT A QUOTE MARK
        TCO     CH              ;OUTPUT THE CHARACTER
        TCO     [QUOTE]         ;OUTPUT ANOTHER QUOTE MARK
        JRST    CLDSP           ;CLEAR INPUT BUFFER AND GO TO CDISP
ESCR1:  HLR     R1,JOBCNI
        ANDI    R1,1
        CAIE    R1,1
        PUSHJ   P,FERR          ;*NOT SURE WHY IT WOULD COME HERE*
        PUSH    P,JOBTPC##      ;SAVE RETURN ADDRESS ON STACK
        PUSH    P,R0            ;SAVE R0 ON STACK
        MOVEI   R1,2000         ;BIT TO TRAP ON ESCAPE
        APRENB  R1,             ;TRAP ON ESCAPE
        MOVSI   R0,-1           ;STATUS BITS FOR THIS JOB
        GETTAB  R0,             ;GET STATUS OF THIS JOB
        SETZ    R0,             ;FAIL - SET ALL BITS TO ZERO
        TLNE    R0,1            ;SKIP IF THE JAL BIT IS NOT SET
        JRST    UUORET##        ;IGNORE THE ESCAPE
        POP     P,R0            ;RESTORE R0 EVEN IF NOT NECESSARY
        POP     P,JOBTPC        ;POP STACK ONCE MORE
ESCR::  HRROI   R1,6            ;PRV WORD FOR THIS JOB
        GETTAB  R1,             ;FIND OUT IF THIS IS A TYMEX USER
        SETZ    R1,             ;FAILED SO ASSUME PDP10 USER
        TRC     R1,200          ;COMPLEMENT THE TYMEX BIT
        TRNE    R1,600          ;SKIP IF THIS IS A TYMEX USER
        JRST    ESCR2           ;PDP10, GE, OR SUDS USER
        CLRBFO                  ;CLEAR OUTPUT BUFFER
        TCO     [BARROW]
        TCO     [BARROW]
ESCR2:  SKIPGE  ESCFLG          ;SKIP IF NOT SECOND ESCAPE IN A ROW
        EXIT                    ;*LET THE GUY OUT - MAY WANT TO CHANGE THIS
        SETOM   ESCFLG          ;SET FLAG FOR NEXT TIME
        MOVEI   R1,2000
        APRENB  R1,
        JRST    CLDSP           ;CLEAR INPUT BUFFER AND GO TO CDISP

FERR::  BLOCK   0               ;FATAL ERROR ROUTINE
        TYPE    [ASCIZ "$FATAL ERROR AT LOCATION: "]
        HRRZ    R0,(P)          ;FIND FROM WHERE THIS WAS CALLED
        SUBI    R0,1            ;DECREMENT ADDRESS
        PUSHJ   P,PRONUM        ;PRINT THE ADDRESS
        JRST    CLDSP           ;CLEAR INPUT BUFFER AND GO TO CDISP

S6PTR:  PUSH    P,R0
        MOVEI   R0,6
        JRST    APTR
IPTR:   SKIPA   R1,[COMBUF-1]
NPTR:   MOVE    R1,COMPT1
SPTR:   PUSH    P,R0
        MOVEI   R0,7
APTR:   DPB     R0,[POINT 6,R0,11]
        PUSH    P,R2            ;*
        HLL     R1,R0
        HRRZ    R0,R0
        MOVEM   R1,COMPTR
        CAMN    R1,COMPT1
        JRST    NPTR1
        PUSH    P,@R1
        SETZM   @R1
        HRL     R1,R1
        AOJ     R1,
        BLT     R1,@COMPT1
        POP     P,@COMPTR
        MOVE    R1,COMPTR
NPTR1:  MOVEM   R1,COMPT1
        MOVEI   R2,COMBFE
        SUBI    R2,1(R1)
        IDIVI   R0,44
        IMUL    R1,R2
        MOVEM   R1,COMPT2
        SETZM   ACMLTR#         ;INITIALIZE NUMBER BEING READ
        POP     P,R2
        POP     P,R0
        POPJ    P,

READKW: TCI     CT,CH           ;INPUT NEXT CHAR OF WORD AFTER
        CAIE    CT,SP           ;SKIP IF SPACE WAS READ
        CAIN    CT,TE           ;SKIP IF CRARRIAGE RETURN NOT READ
        JRST    RKWBAT          ;TERMINATOR READ
        WCI     CH,COMPTR       ;PUT CHAR IN STRING
        ERROR   [ASCIZ "TOO MANY CHARACTERS IN COMMAND."]
        JRST    READKW          ;LOOP
RKWBAT: MOVEI   CH,EOLIT        ;TERMINATE STRING
        WCI     CH,COMPTR       ;WRITE BACK ARROW TO STRING
        ERROR   [ASCIZ "TOO MANY CHARACTERS IN COMMAND."]
        MOVE    R3,COMPTR       ;GET ADDRESS-1 OF STRING
        ADDI    R3,1            ;ADDRESS OF STRING
        POPJ    P,              ;RETURN FROM READKW

;STATES FOR THE COMMAND DISPATCHER

DEFINE  STATBT(B,S)     <
.'S'B>

DEFINE  ISTATE(A,B)     <
A'B=    .-ISTAB'B
        [CHARDO <STATBT B,A>
        ]
;;NIS'B= .-ISTAB'B
>

DEFINE  TSTATE(A,B)     <
A'B=    .-TSTAB'B
        XWD     A'TRM,[XWD A'B'TAB-A'B'TBE,A'B'TAB]
NTS'B=  .-TSTAB'B>

NPARTS==3       ;NUMBER OF COMMAND PARTS

DEFINE  XWDM(A,B,C)     <
        XWD     A'C,B'C>

DEFINE  XSTABM(T,L,R)   <X==0
T=.-1
REPEAT  NCSEC,  <X==X+1
        XWDM    L,R,\X>>

CTABL2::BLOCK   NPARTS+1        ;CELL DESCRIBING COMMAND READ

CTABLE: XWD     0,KF0TAB        ;STATE/COMMAND POINTER
        BLOCK   NPARTS          ;CTABLE REMEMBERS COMMANDS WE'VE READ

        XSTABM  ISTAB,IS,ISTAB; POINTER TO INITIAL STATE TABLES

        XSTABM  TSTAB,-NTS,TSTAB; POINTERS TO TERMINAL STATE TABLES


;SYMBOLS FORMING STATE DIAGRAM FOR FIRST PART OF COMMAND

.ISIC1= XWD     000,ILCH
.ISAL1= XWD     KN1,STOCHR
.ISNU1= XWD     000,ILCH
.ISRP1= XWD     000,ILCH
.ISIG1= XWD     IS1,NXTCHR
.ISLP1= XWD     000,ILCH
.ISAS1= XWD     000,ILCH
.ISEX1= XWD     000,ILCH
.ISAT1= XWD     000,CFNYI
.ISCO1= XWD     000,ILCH
.ISTE1= XWD     000,CDISP
.ISSP1= XWD     IS1,NXTCHR
.ISPO1= XWD     000,ILCH
.ISQU1= XWD     KN1,STOCHR
.ISPU1= XWD     000,ILCH
.ISDA1= XWD     000,ILCH

.KNIC1= XWD     000,ILCH
.KNAL1= XWD     KN1,STOCHR
.KNNU1= XWD     000,ILCH
.KNRP1= XWD     000,ILCH
.KNIG1= XWD     KN1,NXTCHR
.KNLP1= XWD     000,ILCH
.KNAS1= XWD     000,ILCH
.KNEX1= XWD     000,ILCH
.KNAT1= XWD     000,ILCH
.KNCO1= XWD     000,ILCH
.KNTE1= XWD     KF1,TRMEOL
.KNSP1= XWD     KF1,TRMNAT
.KNPO1= XWD     000,ILCH
.KNQU1= XWD     KN1,STOCHR
.KNPU1= XWD     000,ILCH
.KNDA1= XWD     000,ILCH

;INTERMEDIATE STATE FOR FIRST PART OF COMMAND

ISTAB1: BLOCK   0
        ISTATE  IS,1;   INITIAL STATE
        ISTATE  KN,1;   KEYWORD PARTIALLY READ


;TERMINAL STATES FOR FIRST PART OF COMMAND


TSTAB1: BLOCK   0
        TSTATE  KF,1;   KEYWORD FOUND

ISTAB4==ISTAB1
ISTAB5==ISTAB1
ISTAB6==ISTAB1

IS4==   IS1
IS5==   IS1
IS6==   IS1

TSTAB4: TSTATE  KF,4;           KEYWORD FOUND
TSTAB5: TSTATE  KF,5;           KEYWORD FOUND
TSTAB6: TSTATE  KF,6;           KEYWORD FOUND

;SYMBOLS FORMING STATE DIAGRAM FOR SECOND PART OF COMMAND

.ISIC2= XWD     000,ILCH
.ISAL2= XWD     KN2,STOCHR
.ISNU2= XWD     GN2,ACCNUM
.ISRP2= XWD     000,ILCH
.ISIG2= XWD     IS2,NXTCHR
.ISLP2= XWD     XL2,TSTLPI
.ISAS2= XWD     000,ILCH
.ISEX2= XWD     000,ILCH
.ISAT2= XWD     000,CFNYI
.ISCO2= XWD     000,ILCH
.ISTE2= XWD     IS2,PROMPT
.ISSP2= XWD     IS2,NXTCHR
.ISPO2= XWD     000,ILCH
.ISQU2= XWD     KN2,STOCHR
.ISPU2= XWD     000,ILCH
.ISDA2= XWD     000,ILCH

.KNIC2= XWD     000,ILCH
.KNAL2= XWD     KN2,STOCHR
.KNNU2= XWD     000,ILCH
.KNRP2= XWD     000,ILCH
.KNIG2= XWD     KN2,NXTCHR
.KNLP2= XWD     000,ILCH
.KNAS2= XWD     000,ILCH
.KNEX2= XWD     000,ILCH
.KNAT2= XWD     000,ILCH
.KNCO2= XWD     000,ILCH
.KNTE2= XWD     KF2,TRMEOL
.KNSP2= XWD     KF2,TRMNAT
.KNPO2= XWD     000,ILCH
.KNQU2= XWD     000,ILCH
.KNPU2= XWD     000,ILCH
.KNDA2= XWD     000,ILCH

.GNIC2= XWD     000,ILCH
.GNAL2= XWD     000,ILCH
.GNNU2= XWD     GN2,ACCNUM
.GNRP2= XWD     000,ILCH
.GNIG2= XWD     GN2,NXTCHR
.GNLP2= XWD     000,ILCH
.GNAS2= XWD     000,ILCH
.GNEX2= XWD     000,ILCH
.GNAT2= XWD     000,ILCH
.GNCO2= XWD     GC2,ACCCOM
.GNTE2= XWD     GF2,TRMEOL
.GNSP2= XWD     GF2,TRMNAT
.GNPO2= XWD     000,ILCH
.GNQU2= XWD     000,ILCH
.GNPU2= XWD     000,ILCH
.GNDA2= XWD     GD2,ACCDSH

.GCIC2= XWD     000,ILCH
.GCAL2= XWD     000,ILCH
.GCNU2= XWD     GN2,ACCNUM
.GCRP2= XWD     000,ILCH
.GCIG2= XWD     GC2,NXTCHR
.GCLP2= XWD     000,ILCH
.GCAS2= XWD     000,ILCH
.GCEX2= XWD     000,ILCH
.GCAT2= XWD     000,ILCH
.GCCO2= XWD     000,ILCH
.GCTE2= XWD     000,ILCH
.GCSP2= XWD     000,ILCH
.GCPO2= XWD     000,ILCH
.GCQU2= XWD     000,ILCH
.GCPU2= XWD     000,ILCH
.GCDA2= XWD     000,ILCH

.GDIC2= XWD     000,ILCH
.GDAL2= XWD     GE2,ACCEND
.GDNU2= XWD     GS2,ACCNUM
.GDRP2= XWD     000,ILCH
.GDIG2= XWD     GD2,NXTCHR
.GDLP2= XWD     000,ILCH
.GDAS2= XWD     000,ILCH
.GDEX2= XWD     000,ILCH
.GDAT2= XWD     000,ILCH
.GDCO2= XWD     000,ILCH
.GDTE2= XWD     000,ILCH
.GDSP2= XWD     000,ILCH
.GDPO2= XWD     000,ILCH
.GDQU2= XWD     000,ILCH
.GDPU2= XWD     000,ILCH
.GDDA2= XWD     000,ILCH

.GSIC2= XWD     000,ILCH
.GSAL2= XWD     000,ILCH
.GSNU2= XWD     GS2,ACCNUM
.GSRP2= XWD     000,ILCH
.GSIG2= XWD     GS2,NXTCHR
.GSLP2= XWD     000,ILCH
.GSAS2= XWD     000,ILCH
.GSEX2= XWD     000,ILCH
.GSAT2= XWD     000,ILCH
.GSCO2= XWD     GC2,ACCCOM
.GSTE2= XWD     GF2,TRMEOL
.GSSP2= XWD     GF2,TRMNAT
.GSPO2= XWD     000,ILCH
.GSQU2= XWD     000,ILCH
.GSPU2= XWD     000,ILCH
.GSDA2= XWD     000,ILCH

.GEIC2= XWD     000,ILCH
.GEAL2= XWD     000,ILCH
.GENU2= XWD     000,ILCH
.GERP2= XWD     000,ILCH
.GEIG2= XWD     GE2,NXTCHR
.GELP2= XWD     000,ILCH
.GEAS2= XWD     000,ILCH
.GEEX2= XWD     000,ILCH
.GEAT2= XWD     000,ILCH
.GECO2= XWD     GC2,ACCCOM
.GETE2= XWD     GF2,TRMEOL
.GESP2= XWD     GF2,TRMNAT
.GEPO2= XWD     000,ILCH
.GEQU2= XWD     000,ILCH
.GEPU2= XWD     000,ILCH
.GEDA2= XWD     000,ILCH

.YLIC2= XWD     000,ILCH
.YLAL2= XWD     000,ILCH
.YLNU2= XWD     YA2,NXTCHR
.YLRP2= XWD     000,ILCH
.YLIG2= XWD     YL2,NXTCHR
.YLLP2= XWD     000,ILCH
.YLAS2= XWD     000,ILCH
.YLEX2= XWD     000,ILCH
.YLAT2= XWD     000,ILCH
.YLCO2= XWD     000,ILCH
.YLTE2= XWD     000,ILCH
.YLSP2= XWD     000,ILCH
.YLPO2= XWD     000,ILCH
.YLQU2= XWD     000,ILCH
.YLPU2= XWD     000,ILCH
.YLDA2= XWD     000,ILCH

.YAIC2= XWD     000,ILCH
.YAAL2= XWD     000,ILCH
.YANU2= XWD     YA2,NXTCHR
.YARP2= XWD     000,ILCH
.YAIG2= XWD     YA2,NXTCHR
.YALP2= XWD     000,ILCH
.YAAS2= XWD     000,ILCH
.YAEX2= XWD     000,ILCH
.YAAT2= XWD     000,ILCH
.YACO2= XWD     YC2,NXTCHR
.YATE2= XWD     000,ILCH
.YASP2= XWD     000,ILCH
.YAPO2= XWD     000,ILCH
.YAQU2= XWD     000,ILCH
.YAPU2= XWD     000,ILCH
.YADA2= XWD     000,ILCH

.YCIC2= XWD     000,ILCH
.YCAL2= XWD     000,ILCH
.YCNU2= XWD     YU2,ACCNUM
.YCRP2= XWD     000,ILCH
.YCIG2= XWD     YC2,NXTCHR
.YCLP2= XWD     000,ILCH
.YCAS2= XWD     000,ILCH
.YCEX2= XWD     000,ILCH
.YCAT2= XWD     000,ILCH
.YCCO2= XWD     000,ILCH
.YCTE2= XWD     000,ILCH
.YCSP2= XWD     000,ILCH
.YCPO2= XWD     000,ILCH
.YCQU2= XWD     000,ILCH
.YCPU2= XWD     000,ILCH
.YCDA2= XWD     000,ILCH

.YUIC2= XWD     000,ILCH
.YUAL2= XWD     000,ILCH
.YUNU2= XWD     YU2,ACCNUM
.YURP2= XWD     YR2,NXTCHR
.YUIG2= XWD     YU2,NXTCHR
.YULP2= XWD     000,ILCH
.YUAS2= XWD     000,ILCH
.YUEX2= XWD     000,ILCH
.YUAT2= XWD     000,ILCH
.YUCO2= XWD     000,ILCH
.YUTE2= XWD     000,ILCH
.YUSP2= XWD     000,ILCH
.YUPO2= XWD     000,ILCH
.YUQU2= XWD     000,ILCH
.YUPU2= XWD     000,ILCH
.YUDA2= XWD     000,ILCH

.YRIC2= XWD     000,ILCH
.YRAL2= XWD     FN2,ENDUN
.YRNU2= XWD     FN2,ENDUN
.YRRP2= XWD     000,ILCH
.YRIG2= XWD     YR2,NXTCHR
.YRLP2= XWD     000,ILCH
.YRAS2= XWD     FN2,ENDUN
.YREX2= XWD     000,ILCH
.YRAT2= XWD     000,ILCH
.YRCO2= XWD     PD2,ACCCOM
.YRTE2= XWD     UF2,TRMEOL
.YRSP2= XWD     UF2,TRMNAT
.YRPO2= XWD     FN2,ENDUN
.YRQU2= XWD     FN2,ENDUN
.YRPU2= XWD     000,ILCH
.YRDA2= XWD     000,ILCH

.PLIC2= XWD     000,ILCH
.PLAL2= XWD     000,ILCH
.PLNU2= XWD     PA2,NXTCHR
.PLRP2= XWD     000,ILCH
.PLIG2= XWD     PL2,NXTCHR
.PLLP2= XWD     000,ILCH
.PLAS2= XWD     000,ILCH
.PLEX2= XWD     000,ILCH
.PLAT2= XWD     000,ILCH
.PLCO2= XWD     000,ILCH
.PLTE2= XWD     000,ILCH
.PLSP2= XWD     000,ILCH
.PLPO2= XWD     000,ILCH
.PLQU2= XWD     000,ILCH
.PLPU2= XWD     000,ILCH
.PLDA2= XWD     000,ILCH

.PAIC2= XWD     000,ILCH
.PAAL2= XWD     000,ILCH
.PANU2= XWD     PA2,NXTCHR
.PARP2= XWD     000,ILCH
.PAIG2= XWD     PA2,NXTCHR
.PALP2= XWD     000,ILCH
.PAAS2= XWD     000,ILCH
.PAEX2= XWD     000,ILCH
.PAAT2= XWD     000,ILCH
.PACO2= XWD     PC2,NXTCHR
.PATE2= XWD     000,ILCH
.PASP2= XWD     000,ILCH
.PAPO2= XWD     000,ILCH
.PAQU2= XWD     000,ILCH
.PAPU2= XWD     000,ILCH
.PADA2= XWD     000,ILCH

.PCIC2= XWD     000,ILCH
.PCAL2= XWD     000,ILCH
.PCNU2= XWD     PU2,ACCNUM
.PCRP2= XWD     000,ILCH
.PCIG2= XWD     PC2,NXTCHR
.PCLP2= XWD     000,ILCH
.PCAS2= XWD     000,ILCH
.PCEX2= XWD     000,ILCH
.PCAT2= XWD     000,ILCH
.PCCO2= XWD     000,ILCH
.PCTE2= XWD     000,ILCH
.PCSP2= XWD     000,ILCH
.PCPO2= XWD     000,ILCH
.PCQU2= XWD     000,ILCH
.PCPU2= XWD     000,ILCH
.PCDA2= XWD     000,ILCH

.PUIC2= XWD     000,ILCH
.PUAL2= XWD     000,ILCH
.PUNU2= XWD     PU2,ACCNUM
.PURP2= XWD     PR2,NXTCHR
.PUIG2= XWD     PU2,NXTCHR
.PULP2= XWD     000,ILCH
.PUAS2= XWD     000,ILCH
.PUEX2= XWD     000,ILCH
.PUAT2= XWD     000,ILCH
.PUCO2= XWD     000,ILCH
.PUTE2= XWD     000,ILCH
.PUSP2= XWD     000,ILCH
.PUPO2= XWD     000,ILCH
.PUQU2= XWD     000,ILCH
.PUPU2= XWD     000,ILCH
.PUDA2= XWD     000,ILCH

.PRIC2= XWD     000,ILCH
.PRAL2= XWD     000,ILCH
.PRNU2= XWD     000,ILCH
.PRRP2= XWD     000,ILCH
.PRIG2= XWD     PR2,NXTCHR
.PRLP2= XWD     000,ILCH
.PRAS2= XWD     000,ILCH
.PREX2= XWD     000,ILCH
.PRAT2= XWD     000,ILCH
.PRCO2= XWD     PD2,ACCCOM
.PRTE2= XWD     UF2,TRMEOL
.PRSP2= XWD     UF2,TRMNAT
.PRPO2= XWD     000,ILCH
.PRQU2= XWD     000,ILCH
.PRPU2= XWD     000,ILCH
.PRDA2= XWD     000,ILCH

.PDIC2= XWD     000,ILCH
.PDAL2= XWD     000,ILCH
.PDNU2= XWD     000,ILCH
.PDRP2= XWD     000,ILCH
.PDIG2= XWD     PD2,NXTCHR
.PDLP2= XWD     UL2,TSTLPP
.PDAS2= XWD     000,ILCH
.PDEX2= XWD     000,ILCH
.PDAT2= XWD     000,ILCH
.PDCO2= XWD     000,ILCH
.PDTE2= XWD     000,ILCH
.PDSP2= XWD     000,ILCH
.PDPO2= XWD     000,ILCH
.PDQU2= XWD     000,ILCH
.PDPU2= XWD     000,ILCH
.PDDA2= XWD     000,ILCH

.ULIC2= XWD     000,ILCH
.ULAL2= XWD     UN2,STRTUN
.ULNU2= XWD     UN2,STRTUN
.ULRP2= XWD     000,ILCH
.ULIG2= XWD     UL2,NXTCHR
.ULLP2= XWD     000,ILCH
.ULAS2= XWD     UN2,STRTUN
.ULEX2= XWD     UN2,STRTUN
.ULAT2= XWD     000,ILCH
.ULCO2= XWD     000,ILCH
.ULTE2= XWD     000,ILCH
.ULSP2= XWD     000,ILCH
.ULPO2= XWD     000,ILCH
.ULQU2= XWD     000,ILCH
.ULPU2= XWD     UN2,STRTUN
.ULDA2= XWD     UN2,STRTUN

.UNIC2= XWD     000,ILCH
.UNAL2= XWD     UN2,STOSIX
.UNNU2= XWD     UN2,STOSIX
.UNRP2= XWD     PR2,CONVUN
.UNIG2= XWD     UN2,NXTCHR
.UNLP2= XWD     000,ILCH
.UNAS2= XWD     UN2,STOSIX
.UNEX2= XWD     UN2,STOSIX
.UNAT2= XWD     000,ILCH
.UNCO2= XWD     000,ILCH
.UNTE2= XWD     000,ILCH
.UNSP2= XWD     UN2,STOSIX
.UNPO2= XWD     000,ILCH
.UNQU2= XWD     000,ILCH
.UNPU2= XWD     UN2,STOSIX
.UNDA2= XWD     UN2,STOSIX

.XLIC2= XWD     000,ILCH
.XLAL2= XWD     XN2,STRTUN
.XLNU2= XWD     XN2,STRTUN
.XLRP2= XWD     000,ILCH
.XLIG2= XWD     XL2,NXTCHR
.XLLP2= XWD     000,ILCH
.XLAS2= XWD     XN2,STRTUN
.XLEX2= XWD     XN2,STRTUN
.XLAT2= XWD     000,ILCH
.XLCO2= XWD     000,ILCH
.XLTE2= XWD     000,ILCH
.XLSP2= XWD     000,ILCH
.XLPO2= XWD     000,ILCH
.XLQU2= XWD     000,ILCH
.XLPU2= XWD     XN2,STRTUN
.XLDA2= XWD     XN2,STRTUN

.XNIC2= XWD     000,ILCH
.XNAL2= XWD     XN2,STOSIX
.XNNU2= XWD     XN2,STOSIX
.XNRP2= XWD     YR2,CONVUN
.XNIG2= XWD     XN2,NXTCHR
.XNLP2= XWD     000,ILCH
.XNAS2= XWD     XN2,STOSIX
.XNEX2= XWD     XN2,STOSIX
.XNAT2= XWD     000,ILCH
.XNCO2= XWD     000,ILCH
.XNTE2= XWD     000,ILCH
.XNSP2= XWD     XN2,STOSIX
.XNPO2= XWD     000,ILCH
.XNQU2= XWD     000,ILCH
.XNPU2= XWD     XN2,STOSIX
.XNDA2= XWD     XN2,STOSIX

.FXIC2= XWD     000,ILCH
.FXAL2= XWD     FX2,STOSIX
.FXNU2= XWD     FX2,STOSIX
.FXRP2= XWD     000,ILCH
.FXIG2= XWD     FX2,NXTCHR
.FXLP2= XWD     000,ILCH
.FXAS2= XWD     FX2,STOSIX
.FXEX2= XWD     000,ILCH
.FXAT2= XWD     000,ILCH
.FXCO2= XWD     FC2,EXTCOM
.FXTE2= XWD     FF2,TRMEOL
.FXSP2= XWD     FF2,TRMNAT
.FXPO2= XWD     FX2,STOSIX
.FXQU2= XWD     FX2,STOSIX
.FXPU2= XWD     000,ILCH
.FXDA2= XWD     000,ILCH

.FCIC2= XWD     000,ILCH
.FCAL2= XWD     FN2,STOSIX
.FCNU2= XWD     FN2,STOSIX
.FCRP2= XWD     000,ILCH
.FCIG2= XWD     FC2,NXTCHR
.FCLP2= XWD     000,ILCH
.FCAS2= XWD     FN2,STOSIX
.FCEX2= XWD     000,ILCH
.FCAT2= XWD     000,ILCH
.FCCO2= XWD     000,ILCH
.FCTE2= XWD     000,ILCH
.FCSP2= XWD     000,ILCH
.FCPO2= XWD     FN2,STOSIX
.FCQU2= XWD     FN2,STOSIX
.FCPU2= XWD     000,ILCH
.FCDA2= XWD     000,ILCH

.FNIC2= XWD     000,ILCH
.FNAL2= XWD     FN2,STOSIX
.FNNU2= XWD     FN2,STOSIX
.FNRP2= XWD     000,ILCH
.FNIG2= XWD     FN2,NXTCHR
.FNLP2= XWD     000,ILCH
.FNAS2= XWD     000,ILCH
.FNEX2= XWD     FX2,FILDOT
.FNAT2= XWD     000,ILCH
.FNCO2= XWD     FX2,FILCOM
.FNTE2= XWD     FX2,FILCOM
.FNSP2= XWD     FX2,FILCOM
.FNPO2= XWD     FN2,STOSIX
.FNQU2= XWD     FN2,STOSIX
.FNPU2= XWD     000,ILCH
.FNDA2= XWD     000,ILCH

;PPIC2= XWD     000,ILCH
;PPAL2= XWD     000,ILCH
;PPNU2= XWD     000,ILCH
;PPRP2= XWD     000,ILCH
;PPIG2= XWD     000,ILCH
;PPLP2= XWD     000,ILCH
;PPAS2= XWD     000,ILCH
;PPEX2= XWD     000,ILCH
;PPAT2= XWD     000,ILCH
;PPCO2= XWD     000,ILCH
;PPTE2= XWD     000,ILCH
;PPSP2= XWD     000,ILCH
;PPPO2= XWD     000,ILCH
;PPQU2= XWD     000,ILCH
;PPPU2= XWD     000,ILCH
;PPDA2= XWD     000,ILCH

;PNIC2= XWD     000,ILCH
;PNAL2= XWD     000,ILCH
;PNNU2= XWD     000,ILCH
;PNRP2= XWD     000,ILCH
;PNIG2= XWD     000,ILCH
;PNLP2= XWD     000,ILCH
;PNAS2= XWD     000,ILCH
;PNEX2= XWD     000,ILCH
;PNAT2= XWD     000,ILCH
;PNCO2= XWD     000,ILCH
;PNTE2= XWD     000,ILCH
;PNSP2= XWD     000,ILCH
;PNPO2= XWD     000,ILCH
;PNQU2= XWD     000,ILCH
;PNPU2= XWD     000,ILCH
;PNDA2= XWD     000,ILCH

;PCIC2= XWD     000,ILCH
;PCAL2= XWD     000,ILCH
;PCNU2= XWD     000,ILCH
;PCRP2= XWD     000,ILCH
;PCIG2= XWD     000,ILCH
;PCLP2= XWD     000,ILCH
;PCAS2= XWD     000,ILCH
;PCEX2= XWD     000,ILCH
;PCAT2= XWD     000,ILCH
;PCCO2= XWD     000,ILCH
;PCTE2= XWD     000,ILCH
;PCSP2= XWD     000,ILCH
;PCPO2= XWD     000,ILCH
;PCQU2= XWD     000,ILCH
;PCPU2= XWD     000,ILCH
;PCDA2= XWD     000,ILCH

;PDIC2= XWD     000,ILCH
;PDAL2= XWD     000,ILCH
;PDNU2= XWD     000,ILCH
;PDRP2= XWD     000,ILCH
;PDIG2= XWD     000,ILCH
;PDLP2= XWD     000,ILCH
;PDAS2= XWD     000,ILCH
;PDEX2= XWD     000,ILCH
;PDAT2= XWD     000,ILCH
;PDCO2= XWD     000,ILCH
;PDTE2= XWD     000,ILCH
;PDSP2= XWD     000,ILCH
;PDPO2= XWD     000,ILCH
;PDQU2= XWD     000,ILCH
;PDPU2= XWD     000,ILCH
;PDDA2= XWD     000,ILCH

;INTERMEDIATE STATES FOR SECOND PART OF COMMAND

ISTAB2: BLOCK   0
        ISTATE  IS,2;   INITIAL STATE
        ISTATE  KN,2;   KEYWORD PARTIALLY READ
        ISTATE  GN,2;   GAN - PARTIALLY READ
        ISTATE  GC,2;   GAN - COMMA JUST READ
        ISTATE  GD,2;   GAN - DASH JUST READ
        ISTATE  GS,2;   GAN - SECOND GAN OF RANGE PARTIALLY READ
        ISTATE  GE,2;   GAN - E FOR END JUST READ IN 2ND HALF OF RANGE
        ISTATE  YL,2;   PPN OR F - LEFT BRACKET JUST READ
        ISTATE  YA,2;   PPN OR F - ACCT NUMBER PARTIALLY READ
        ISTATE  YC,2;   PPN OR F - COMMA JUST READ
        ISTATE  YU,2;   PPN OR F - USER NUMBER PARTIALLY READ
        ISTATE  YR,2;   PPN OR F - RIGHT BRACKET JUST READ
        ISTATE  PL,2;   PPN - LEFT BRACKET JUST READ
        ISTATE  PA,2;   PPN - ACCT NUMBER PARTIALLY READ
        ISTATE  PC,2;   PPN - COMMA BETWEEN GAN AND UUN JUST READ
        ISTATE  PU,2;   PPN - USER NUMBER PARTIALLY READ
        ISTATE  PR,2;   PPN - RIGHT BRACKET JUST READ
        ISTATE  PD,2;   PPN - COMMA BETWEEN PPNS JUST READ
        ISTATE  UL,2;   UN - LEFT PAREN JUST READ
        ISTATE  UN,2;   UN - NAME PARTIALLY READ
        ISTATE  XL,2;   UN OR F - LEFT PAREN JUST READ
        ISTATE  XN,2;   UN OR F - NAME PARTIALLY READ
        ISTATE  FX,2;   F - EXTENSION PARTIALLY READ
        ISTATE  FC,2;   F - COMMA JUST READ
        ISTATE  FN,2;   F - NAME PARTIALLY READ
       ;ISTATE  PP,2;   POS - # JUST READ
       ;ISTATE  PN,2;   POS - NUMBER PARTIALLY READ
       ;ISTATE  PC,2;   POS - COMMA JUST READ
       ;ISTATE  PD,2;   POS - DASH JUST READ

;TERMINAL STATES FOR SECOND PART OF COMMAND

TSTAB2: BLOCK   0
        TSTATE  KF,2;   KEYWORD FOUND
        TSTATE  GF,2;   GAN FOUND
        TSTATE  UF,2;   USER NAME FOUND
        TSTATE  FF,2;   FILE NAME FOUND
       ;TSTATE  PF,2;   POSITION NUMBER FOUND

;SYMBOLS FORMING STATE DIAGRAM FOR THIRD PART OF COMMAND

.ISIC3= XWD     000,ILCH
.ISAL3= XWD     KN3,STOCHR
.ISNU3= XWD     000,ILCH
.ISRP3= XWD     000,ILCH
.ISIG3= XWD     IS3,NXTCHR
.ISLP3= XWD     000,ILCH
.ISAS3= XWD     000,ILCH
.ISEX3= XWD     000,ILCH
.ISAT3= XWD     000,CFNYI
.ISCO3= XWD     000,ILCH
.ISTE3= XWD     000,CDISP
.ISSP3= XWD     IS3,NXTCHR
.ISPO3= XWD     000,ILCH
.ISQU3= XWD     KN3,STOCHR
.ISPU3= XWD     000,ILCH
.ISDA3= XWD     000,ILCH

.KNIC3= XWD     000,ILCH
.KNAL3= XWD     KN3,STOCHR
.KNNU3= XWD     000,ILCH
.KNRP3= XWD     000,ILCH
.KNIG3= XWD     KN3,NXTCHR
.KNLP3= XWD     000,ILCH
.KNAS3= XWD     000,ILCH
.KNEX3= XWD     000,ILCH
.KNAT3= XWD     000,ILCH
.KNCO3= XWD     000,ILCH
.KNTE3= XWD     KF3,TRMEOL
.KNSP3= XWD     KF3,TRMNAT
.KNPO3= XWD     000,ILCH
.KNQU3= XWD     KN3,STOCHR
.KNPU3= XWD     000,ILCH
.KNDA3= XWD     000,ILCH

;INTERMEDIATE STATE FOR THIRD PART OF COMMAND

ISTAB3: BLOCK   0
        ISTATE  IS,3;   INITIAL STATE
        ISTATE  KN,3;   KEYWORD PARTIALLY READ


;TERMINAL STATES FOR THIRD PART OF COMMAND


TSTAB3: BLOCK   0
        TSTATE  KF,3;   KEYWORD FOUND

;*

        VAR
        END
   tYH