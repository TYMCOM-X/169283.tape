!COPYRIGHT 1972,DIGITAL EQUIPMENT CORP., MAYNARD, MASS.
!AUTHOR: F. INFANTE
GLOBAL BIND OPMOV=27;	!VERSION DATE:29-MAR-73
EXTERNAL RDATWD,LSTOUT,ERROUT,RELDATA,RELBLOCK,HILOC,RELOCWD,RELOUT;
FORWARD ALLFORM,PROCCOM,PROCEQUIV,RADIX50,ZOUTBLOCK;
EXTERNAL RELOCPTR;

MACRO	RCODE = 1$,	!CODE AND DATA BLOCK
	RSYMBOL = 2$,	!SYMBOL BLOCK
		RGLOBDEF = 4^30$,	!GLOBAL DEF IN RSYMBOL
		RLOCDEF = #10^30$,	!LOCAL DEF IN RSYMBOL
		RLOCREQ = #10^30$,	!LOCAL REQUEST IN RSYMBOL
		RGLOBREQ = #60^30$,	!GLOBAL REQUEST
		RGLOB0 = 0$,	!CHAINED GLOBAL REQUEST
		RGLOB4 = 400000$,	!ADDITIVE GLOBAL IN RSYMBOL
	RHISEG = 3$,	!HISEG BLOCK
	RENTRY = 4$,	!ENTRY BLOCK
	REND =   5$,	!END BLOCK
	RNAME  = 6$,	!NAME BLOCK
	RADDRESS = 7$,	!ADDRESS BLOCK
	RLOCAL = #10$,	!LOCAL BLOCK
	RELN =  0$,	!NO RELOCATION BITS
	RELRI = 1$,	!RELOCATE RIGHT
	RELL = 2$,	!RELOCATE LEFT
	RELB = 3$;	!RELOCATE BOTH HALVES
MACRO RBLOKTYPE = RELBLOCK[0]<LEFT>$,
	RDATCOUNT = RELBLOCK[0]<RIGHT>$,
	RRELOC = RELBLOCK[1]$,
	RDATA(I) = (RELBLOCK+2)[I]$,
	RBLKSIZ = #22$,	!SIZE OF REL DATA BLOCK
	ZDATCNT = RELDATA<RIGHT>$,	!CURRENT COUNT OF DATA WORDS MAX IS 18
	CBLK = RELDATA<LEFT>$;	!CURRENT BLOCK TYPE



%(*** SET UP THE TYMSHARE DEBUGGER LOADER TYPE INFORMATION.
       THIS BLOCK TYPE, AND STRUCTURE DEFINITIONS ARE FOR
        THE SUPER FORTRAN LOADER, AND DEBUGGER.

WORD 0:         FLAGS   TYPE    LENGTH
WORD 1:         #DIMS   .....BASE.....
WORD 3:         .........NAME.........
...........................................ARRAY INFO
WORD 4:         SIZE...........OFFSET
WORD 5:         M1............M2
WORD 6:         M3...........ETC.
WORD N:

***************************************************************)%


MACRO           RDEB = #30$,            !DEBUGGER BLOCK TYPE 
                STTYPE  =  6,6$,        !VAR/ARRAY TYPE
                STLNGH  =  6,0$,       !LENGTH OF THIS ENTRY
                DIMS  =  18,18$,        ! # DIMS
                ARBASE  =  0,18$,       !BASE ADDRESS FOR ARRAY
                ARSIZ  =  18,18$,       !# WRDS IN ARRAY
                AROFF  =  0,18$,        ! ARRAY OFFSET

                STVAR =  35,1$,         !VAR OR ARRAY DEFINITION
                
                STCOM  =  34,1$,        !COMMON BLOCK INFO

!       NOT USED        33,1$,
!       NOT USED        32,1$,
!       NOT USED        31,1$,

                STFUN  =  30,1$,        !FUNCTION DEF OR REF

                STSUBR  =  29,1$,       !SUBROUTINE REFERENCE

                STSUBD  =  28,1$,       !SUBROUTINE DEFINITION

!       NOT USED        27,1$,
!       NOT USED        26,1$,
!       NOT USED        25,1$,
!       NOT USED        24,1$,
!       NOT USED        23,1$,

                STDUM  =  22,1$,        !SUBROUTINE DUMMY PARAMETER
        
                STADJ  =  21,1$,        !DUMMY ARRAY HAS ADJ DIM
        
                STLIB  =  20,1$,      !REF IS TO A LIBRARY FUNCTION

                STARY  =  19,1$,        !ARRAY DEFINITION

                STLONG  =  18,1$;      !NAME > 6 CHARACTERS

%(*****************************************************************)%



ROUTINE CRLF=	!OUTPUT CR/LF TO LISTING DEVICE
BEGIN
	EXTERNAL LSTOUT;
	CHR_#15;LSTOUT();CHR_#12;LSTOUT()
END;
ROUTINE DATAOUT(ZBLKTYPE,RELBITS)=
BEGIN
%
ROUTINE BUILDS RELOCATABLE BINARY BLOCKS FOR DATA INITIALIZATION
%
EXTERNAL ZDMPBLK;
	IF .ZDATCNT EQL RBLKSIZ-2 THEN ZDMPBLK();
	IF .ZBLKTYPE NEQ .CBLK THEN (ZDMPBLK(); CBLK _ .ZBLKTYPE;);
	REPLACEI(RELOCPTR,.RELBITS);
	RDATA(.ZDATCNT) _ .RDATWD;
	RELDATA _ .RELDATA + 1;
END;	!OF DATAOUT
GLOBAL ROUTINE OUTDATA(SYMADDR,SYMVALUE,SYMPT)=
BEGIN
%
ROUTINE INSTRUCTS LOADER ABOUT INITIALIZATION OF LOW SEG DATA AS SPECIFIED
IN DATA STATEMENTS.  SYMPT IS PTR TO SYMBOL BEING INITIALIZED.
SYMVALUE IS VALUE TO USE IN ITIALIZATION. SYMADDR IS THE ALLOCATED
ADDRESS OF THE SYMBOL
%
EXTERNAL ZDMPBLK;
MAP BASE R2:SYMPT;
BIND RDATBLK = #21;	!LOADER BLOCK TYPE FOR DATA FIXUP
	IF .SYMPT[IDATTRIBUT(INCOM)]
	THEN BEGIN	!DO SPECIAL BLOCK 1 FIXUP
		IF .ZDATCNT GTR RBLKSIZ-5 THEN ZDMPBLK();	!NO ROOM LEFT IN BUFFER FOR NEXT 3 WORDS
		R2 _ .SYMPT[IDCOMMON]; !PTR TO COMMON BLOCK NODE
		R2 _ .R2[COMNAME];
		RDATWD _ RGLOBREQ + RADIX50();
		DATAOUT(RDATBLK,RELN);
		RDATWD _ (1^18) + .SYMADDR<RIGHT>;
		DATAOUT(RDATBLK,RELN);
		RDATWD _ .SYMVALUE;
		DATAOUT(RDATBLK,RELN);
	     END
	ELSE BEGIN
		IF .ZDATCNT GTR RBLKSIZ-4 THEN ZDMPBLK(); !NO ROOM LEFT IN BUFFER FOR 2 WORDS
		RDATWD _ (1^18)+.SYMADDR<RIGHT>;
		DATAOUT(RDATBLK,RELRI);
		RDATWD _ .SYMVALUE;
		DATAOUT(RDATBLK,RELN);
	     END;
END;	!OF OUTDATA
ROUTINE ROUIMFUN(FUNCPTR,FUNAME)=	!OUTPUT FUNCTION REQUEST GLOBAL
BEGIN
			RDATWD_.FUNCPTR<LEFT>^18; ZOUTBLOCK(RCODE,RELN);
			R2 _ .FUNAME; !SIXBIT SYMBOL NAME
			RDATWD_(RGLOBREQ +RADIX50()); ZOUTBLOCK(RSYMBOL,RELN);
			RDATWD_RGLOB0^18 + .HILOC;
			ZOUTBLOCK(RSYMBOL,RELRI)
END;
ROUTINE ZOUTSYM=
!R2 CONTAINS SYMBOL IN SIXBIT TO BE LISTED
DECR I FROM 5 TO 0 DO
BEGIN
	R1 _ 0; LSHC(R1,6);
	IF .R1 GTR 0
	  THEN (CHR _ .R1+#40; LSTOUT())
	  ELSE RETURN
END;
GLOBAL ROUTINE ZOUTMSG(PTR)=
BEGIN
	PTR_(.PTR-1)<0,7>;
	UNTIL (CHR_SCANI(PTR)) EQL 0 DO LSTOUT();
END;
ROUTINE ZOUTOCT=	!LIST OCTAL HALF WORD OR FULL WORD
			!R2<LEFT> CONTAINS HALF WORD OCTAL VALUE
BEGIN
	REGISTER I;
	R1 _ 0; I _ 6;
	DO (LSHC(R1,3); I_ .I-1; IF .I EQL 0 THEN EXITLOOP;) WHILE .R1 EQL 0;
	DO ( CHR_#60[.R1]<0,0>; LSTOUT();
		R1 _ 0; LSHC(R1,3);
	   ) WHILE (I_.I-1) GEQ 0;
	.VREG
END; !OF ZOUTOCT
ROUTINE RADIX50=	!R2 CONTAINS THE SYMBOL IN SIXBIT LEFT JUSTIFIED
			!CONVERT IT TO RADIX 50
BEGIN
REGISTER R50;
MACRO SIXALPHA(X) =MOVEI(VREG,-#40,X) LEQ ("Z"-#100)$, !SIXBIT ALPHA
	SIXDIGIT(X) =MOVEI(VREG,-#20,X) LEQ 9$; !SIXBIT DIGIT
R50_0;
DO (
	R1 _ 0; LSHC(R1,6);
	IF SIXALPHA(R1) THEN R1 _ .R1 -#26
	  ELSE IF SIXDIGIT(R1) THEN R1 _ .R1 -#17
	    ELSE R1 _ #45;	!A . BY DEFAULT
	R50 _ .R50*#50; R50 _ .R50 + .R1;
   ) WHILE .R2 NEQ 0;
RETURN .R50
END;
ROUTINE ZOUDECIMAL=
BEGIN
!	DECIMAL OUTPUT VALUE IN R1
LOCAL Z[6];
INCR I FROM 0 TO 5 DO
	(Z[.I] _ (.R1 MOD 10);
	 R1 _ .R1/10;
	 IF .R1 EQL 0 THEN
		(DECR J FROM .I TO 0 DO (CHR _  .Z[.J] +#60; LSTOUT());
		 RETURN
		);
	)
END;
GLOBAL ROUTINE ZOUOFFSET=
BEGIN
LOCAL Z[6];
!LIST IN ASCII THE VALUE OF R1 A REGISTER
IF .R1 LSS 0 THEN CHR _ "-" ELSE CHR _ "+";
LSTOUT();
R1 _ ABS(.R1);
ZOUDECIMAL();	!DECIMAL OUTPUT VALUE IN R1
END;
GLOBAL ROUTINE ZDMPBLK=
BEGIN
%OUTPUT THE RELBLOCK TO THE REL FILE%
IF .ZDATCNT NEQ 0
THEN
  BEGIN
	RBLOKTYPE _ .CBLK;
	RRELOC _ .RELOCWD; !RELOCATION BITS
	RDATCOUNT _ .ZDATCNT;
	INCR I FROM 0 TO .RDATCOUNT+1 DO
	  (CHR _ .RELBLOCK[.I]; RELOUT());
	ZDATCNT _ 0; RELOCWD _ 0; RELOCPTR _ (RELOCWD-1)<0,2>; !REINITIALIZE
  END;

  .VREG
END;	!OF ROUTINE ZDMPBLK
GLOBAL ROUTINE ZOUTBLOCK(ZBLKTYPE,RELBITS)=
BEGIN
EXTERNAL RELOUT;
%
ROUTINE OUTPUTS THE RELOCATABLE DATA IN RDATWD TO THE REL FILE
USES A 20 WORD BUFFER TO STORE DATA AS DEFINED BY THE LOADER
SPECIFICATIONS.
ZBLKTYPE IS THE BLOCK TYPE TO BE OUTPUT NOW
RELBITS IS THE RELOCATION INFORMATION ASSOCIATED WITH THE CURRENT WORD OF DATA
%
!
!
!BEGIN ZOUTBLOCK HERE
!
IF .ZDATCNT EQL RBLKSIZ-2 THEN ZDMPBLK();
IF .ZBLKTYPE NEQ .CBLK
THEN
  (ZDMPBLK(); CBLK _ .ZBLKTYPE); !DUMP OUT OLD BLOCK BEGIN A NEW TYPE
	IF (.CBLK EQL RCODE) AND (.ZDATCNT EQL 0)
	THEN	( !PUT OUT ADDRESS WORD AS FIRST WORD OF CODE BLOCK
		 REPLACEI(RELOCPTR,RELRI);
		 RDATA(0)_.HILOC;	!START ADDR FOR LOADING CODE OR DATA
		RELDATA _ .RELDATA+1; !INCREMENT ZDATCNT
		);
REPLACEI(RELOCPTR,.RELBITS);
RDATA(.ZDATCNT) _ .RDATWD;
RELDATA _ .RELDATA+1;	!INCREMENTING ZDATCNT
END;	!OF ROUTINE ZOUTBLOCK
ROUTINE LISTSYM(PTR)=
BEGIN
EXTERNAL LSTOUT,ZOUTSYM,ZOUTOCT,ZOUTMSG,PROGNAME;
MAP BASE PTR;
			     		R2 _ .PTR[IDSYMBOL]; ZOUTSYM();
					CHR _ #11; LSTOUT(); !TAB
					R2<LEFT> _ .PTR[IDADDR]; ZOUTOCT();
					CHR_#11;LSTOUT();!TAB
END;
ROUTINE ALLSCAA=	!ALLOCATES STORAGE TO LOCAL SCALARS AND 
				!ARRAYS (NOT IN COMMON AND NOT IN EQUIVALENCE LISTS)
				!SEARCHES SYMTBL
				!ASSUMES ALL FIXUPS AND ALLOCATION  FOR COMMON AND EQUIVALENCE
				!HAVE ALREADY BEEN DONE.
BEGIN
OWN PTR,SCNT;
EXTERNAL LSTOUT,LOWLOC,ZOUTSYM,ZOUTOCT,ZOUTMSG,PROGNAME;
EXTERNAL RDATWD,ZOUTBLOCK,HILOC;
LOCAL ARRAPT;
LABEL L1,L2;
MAP BASE PTR;
	SCNT_0;
	IF .FLGREG<LISTING>
	THEN
	ZOUTMSG(PLIT '?M?J?M?JSCALARS AND ARRAYS?M?J?M?J');
	DECR I FROM SSIZ-1 TO 0 DO
	BEGIN
	  IF (PTR _ .SYMTBL[.I]) NEQ 0
	  THEN	BEGIN
		DO BEGIN
		L1: IF NOT .PTR[IDATTRIBUT(COMBL)]
		     THEN IF NOT  .PTR[IDATTRIBUT(INCOM)]
			THEN IF NOT .PTR[IDATTRIBUT(NAMNAM)]
			THEN(  IF NOT .PTR[IDATTRIBUT(INEQV)]
			     THEN
			     L2:BEGIN
				IF NOT .PTR[IDATTRIBUT(DUMMY)]
				THEN
				 IF .PTR[OPRSP1] EQL FNNAME1	!IF FUNCTION NAME
				   THEN
				    IF NOT .PTR[IDATTRIBUT(FENTRYNAME)] THEN LEAVE L1;
			!
			!ALLOACATE AN ADDRESS ONLY IF ALL ABOVE TESTS PASSED
			!
				PTR[IDADDR] _ .LOWLOC;

				IF .PTR[OPERSP] EQL ARRAYNAME !IS IT AN ARRAY?
				 THEN IF NOT .PTR[IDATTRIBUT(DUMMY)]
				       THEN (	MAP BASE ARRAPT;
						ARRAPT _ .PTR[IDDIM];	!PTR TO DIMENSION NODE
						LOWLOC _ .LOWLOC+ .ARRAPT[ARASIZ];
						LEAVE L2;
					       );

                                IF .PTR[VALTYPE] EQL STRING
                                THEN
                                BEGIN
                                LOWLOC  _  .LOWLOC + .PTR[CW2L];
                                LEAVE L2;
                                END;

				  IF .PTR[DBLFLG] !IS THE VARIABLE DOUBLE LENGTH?
					THEN LOWLOC _ .LOWLOC + 2
					ELSE LOWLOC _ .LOWLOC + 1
			     END;
			     IF .FLGREG<LISTING>
				THEN
				BEGIN
					LISTSYM(.PTR);
					IF .SCNT LSS 5 THEN SCNT _ .SCNT+1 ELSE (SCNT _ 0; CRLF());
				END;
			);
		    END WHILE (PTR _ .PTR[CLINK]) NEQ 0
	   END
	END
END;
!THE ROUTINES IN THIS MODULE ARE FOR THE PURPOSE
!OF GENERATING THE FOLLOWING THINGS:
%	THE CORRECT ALLOCATION OF ADDRESSES TO THE VARIABLES,ARRAYS
	CONSTANTS,STRINGS ETC., IN THE SUBPROGRAM BEING COMPILED
	.THE STATISTICS LISTING OF THE SCALARS,ARRAYS ,COMMON,
	 CONSTANTS,TEMPORARIES ETC. THAT THE SUBPROGRAM DEFINES.
%
!
ROUTINE ALLCOM=
BEGIN
%ROUTINE ALLOCATES RELATIVE ADDRESSES TO ALL VARIABLES DECLARED IN COMMON.
THE ADDRESSES OF THE VARIABLES / ARRAYS IN A COMMON BLOCK ARE ARLATIVE TO THE 
BEGINNING OF THE BLOCK IN WHICH THEY ARE DECLARED. EACH BLOCK HAS AN ORIGIN
OF ZERO. AT LOAD TIME THE LOADER WILL ASSIGN ACTUAL LOCATIONS TO 
COMMON BLOCKS BASED ON THEIR SIZES AND ORDER OF
APPEARANCE TO LOADER. IN THE RLOACTABLE BINARY, REFERENCES TO
COMMON VARIABLES WILL USE ADDITIVE GLOBAL FIXUPS.

THE CALL TO THIS ROUTINE OCCURS AFTER ANY EQUIVALENCE RELATIONS 
HAVE BEEN PROCESSED BY ROUTINE PROCEQUIV
%
REGISTER ICNT;
EXTERNAL COMBLKPTR,EQVPTR;
REGISTER BASE CSYMPTR;
LOCAL BASE CCOMPTR;
MACRO COMBLOK=#20$;

ICNT _ 0;
IF .FLGREG<LISTING> THEN ZOUTMSG(PLIT'?M?J?M?JCOMMON BLOCKS?M?J');
CCOMPTR _ .FIRCOMBLK; !PTR TO FIRST COMMON BLOCK DECLARED
WHILE 1 DO  %1%
BEGIN
	!START BY OUTPUTTING NAME OF BLOCK
	IF .FLGREG<LISTING> THEN
	BEGIN
	  CRLF(); CHR_"/";LSTOUT();
	R2 _ .CCOMPTR[COMNAME]; ZOUTSYM();
	  CHR _ "/"; LSTOUT();
	  CHR _ "("; LSTOUT(); R1 _ .CCOMPTR[COMSIZE]; ZOUOFFSET(); CHR _ ")"; LSTOUT();
	END;
	!RELOCATABLE BINARY IF NECESSARY
	IF .FLGREG<OBJECT>
	THEN (R2 _ .CCOMPTR[COMNAME]; !FOR RADIX 50 CONVERSION
		RDATWD_RGLOBDEF+RADIX50(); ZOUTBLOCK(COMBLOK,RELN);
		RDATWD_ .CCOMPTR[COMSIZE]; ZOUTBLOCK(COMBLOK,RELN);
	     );
	!NOW LIST THE SYMBOLS IN THE BLOCK

		IF .FLGREG<LISTING> THEN
		BEGIN
			CSYMPTR _ .CCOMPTR[COMFIRST];
		CRLF();!CR/LF
		WHILE 1 DO %2%
		BEGIN
		R2 _ .CSYMPTR[IDSYMBOL]; ZOUTSYM();
		CHR _ #11; LSTOUT();	!TAB
		R1 _ .CSYMPTR[IDADDR]; ZOUOFFSET();
		IF (CSYMPTR _ .CSYMPTR[IDCOLINK]) EQL 0 THEN EXITLOOP;
		IF (ICNT _ .ICNT +1) EQL 5
		THEN (ICNT _ 0; CRLF()) ELSE (CHR _ #11; LSTOUT() %TAB% );
		END; !OF %2%
	END;

	IF (CCOMPTR _ .CCOMPTR[NEXCOMBLK]) EQL 0 THEN RETURN;
END
END;	!OF ALLCOM ROUTINE
ROUTINE ALLOCAT=
BEGIN
%ALOCATES RELATIVE ADDRESSES TO ALL VARIABLES AND STORAGE
 IN THE LOW SEGMENT,EXCEPT TEMPORARIES WHICH ARE ALLOCATED AFTER
 CODE GENERATION.
THIS ROUTINE CONTROLS THE ALLOCATION BY CALLING THE ACTUAL ROUTINES
THAT DO THE ALLOCATION AND PROCESSING OF VARIABLES,COMMON BLOCKS,EQUIVALENCE
 GROUPS ,DATA FIXUPS ETC.
%

EXTERNAL LSTOUT,ERROUT,FORMPTR,COMBLKPTR,EQVPTR,
	LOWLOC,	!LOW SEG AVAILABLE ADDRESS
	COMSIZ;	!CURRENT TOTAL SIZE OF COMMON INCLUDING BLANK

COMSIZ _ 0;
IF .COMBLKPTR NEQ 0 THEN COMSIZ _ PROCCOM(); ! PROCESS COMMON BLOCKS
IF .EQVPTR NEQ 0 THEN PROCEQUIV();	!PROCESS EQUIVALENCE GROUPS
IF .COMBLKPTR NEQ 0 THEN ALLCOM(); !ALLOCATE COMMON NOW
!
!NOW ALLOCATE AND LIST ALL VARIABLES,ARRAYS ETC.
!
ALLSCAA();	!ALLOCATE SCALARS AND ARRAYS

IF .FORMPTR NEQ 0 THEN ALLFORM();	!ALLOCATE FORMAT STRINGS

END;
ROUTINE DMPFORMAT=
BEGIN
!
!DUMPS FORMAT STRING DEFINITIONS  TO REL FILE AFTER ALL LOWSEG
!ALLOCATION HAS BEEN DONE
!
LOCAL SAVHILOC;
REGISTER BASE ZFORPTR;
EXTERNAL LOWLOC,FORMPTR,HILOC,ZDMPBLK;
ZFORPTR _ .FORMPTR<LEFT>;	!PTR TO FIRST FORMAT STRING
SAVHILOC _ .HILOC; HILOC _ .ZFORPTR[FORADDR]; !TO PUT DATA BLOCK IN LOWSEG
DO
BEGIN
	INCR I FROM 0 TO .ZFORPTR[FORSIZ]-1 DO
	 (RDATWD _ .(.ZFORPTR[FORSTRING])[.I]<FULL>;
	  ZOUTBLOCK(RCODE,RELN);
	   HILOC _ .HILOC+1;	!INCREMENT FOR POSSIBLE USE IN ZOUTBLOCK
	 );
END WHILE (ZFORPTR _ .ZFORPTR[FMTLINK]) NEQ 0;
ZDMPBLK();	!DUMP OUT THE CODE BLOCK IMMEDIATELY
HILOC _ .SAVHILOC;
RETURN .VREG
END;
ROUTINE ALLFORM=
BEGIN
%ALLOCATES LOW SEG STORAGE ADDRESS TO FORMAT STRINGS
BUT DOES NOT TELL THE LOADER YET
%
REGISTER BASE ZFORPTR;
EXTERNAL LOWLOC,FORMPTR,HILOC,ZDMPBLK;
ZFORPTR _ .FORMPTR<LEFT>;	!PTR TO FIRST FORMAT STRING
WHILE 1 DO
BEGIN
	ZFORPTR[FORADDR] _ .LOWLOC;
	LOWLOC _ .LOWLOC+.ZFORPTR[FORSIZ];
	IF .ZFORPTR[FMTLINK] EQL 0
	THEN EXITLOOP
	ELSE ZFORPTR _ .ZFORPTR[FMTLINK]
END;
RETURN .VREG
END;
ROUTINE PROCCOM=
BEGIN
%ROUTINE MAKES A FAST PASS THRU THE LINKED LISTS OF COMMON BLOCKS
AND ASSOCIATED SYMBOL TABLE ENTRIES COMPUTING THE DECLARED SIZE OF EACH
BLOCK AND ASSIGNING A TEMPORARY ADDRESS TO THE VARIABLES IN EACH
BLOCK RELATIVE TO THE BEGINNING OF THE BLOCK
%
EXTERNAL COMBLKPTR;
MACRO CBLKSIZ = R1$,	!SIZE OF CURRENT BLOCK
	TCOMSIZ = R2$;
REGISTER BASE CSYMPTR;
LOCAL BASE CCOMPTR;
!
XTRAC;
!
TCOMSIZ _ 0;
CCOMPTR _ .FIRCOMBLK;	!PTR TO FIRST COMMON BLOCK

WHILE 1 DO	%1% !LOOP ON LINKED LIST
BEGIN
	CSYMPTR _ .CCOMPTR[COMFIRST];	!PTR TO FIRST SYMBOL ENTRY IN BLOCK
	CBLKSIZ _ 0;
	WHILE 1 DO %2% !LOOP ON LINKEDLIST OF SYMBOLS IN BLOCK
	BEGIN
	  CSYMPTR[IDADDR] _.CBLKSIZ;
	  IF .CSYMPTR[IDDIM] NEQ 0
	  THEN (LOCAL BASE DIMPTR;
		DIMPTR _ .CSYMPTR[IDDIM];
		CBLKSIZ _ .CBLKSIZ + .DIMPTR[ARASIZ];
		)
	  ELSE (IF .CSYMPTR[VALTYPE] GTR REAL
		THEN CBLKSIZ _ .CBLKSIZ + 2
		ELSE CBLKSIZ _ .CBLKSIZ + 1
		);
	  IF .CSYMPTR[IDCOLINK] EQL 0 THEN EXITLOOP
		ELSE CSYMPTR _ .CSYMPTR[IDCOLINK];
	END;! OF %2% LOOP
  !NOW UPDATE TOTAL SIZE OF COMMON
	CCOMPTR[COMSIZE] _ .CBLKSIZ;
	TCOMSIZ _ .TCOMSIZ + .CBLKSIZ;
	IF .CCOMPTR[NEXCOMBLK] EQL 0
	  THEN EXITLOOP
	  ELSE CCOMPTR _ .CCOMPTR[NEXCOMBLK];
END; !OF %1% LOOP
RETURN .TCOMSIZ
END; !OF ROUTINE
ROUTINE EQERRLIST(GROUP)=
BEGIN
!LIST THE GROUP OF EQUIVALENCE VARIABLES IN CONFLICT
!
EXTERNAL LSTOUT,ZOUTMSG;
MAP BASE GROUP:R2;
LOCAL BASE SYMPTR;
	SYMPTR _ .GROUP[EQVFIRST];
	ERROUT(49);	!SAME MESSAGE AS BELOW
	ZOUTMSG(PLIT '?M?JCONFLICTING EQUIVALENCE DECLARATION ( ?0');
	WHILE 1 DO(	R2 _ .SYMPTR[EQLID];
			R2 _ .R2[IDSYMBOL]; ZOUTSYM();
			IF (SYMPTR _ .SYMPTR[EQLLINK]) EQL 0 THEN EXITLOOP
				ELSE (C _ ","; LSTOUT());
		   );
END;	!OF EQERRLIST
ROUTINE ELISTSRCH(ECLASS,EGROUP)=
BEGIN
%SEARCH EACH ITEM IN GROUP POINTED TO BY EGROUP AGAINST ALL ITEMS IN CLASS
POINTED TO BY ECLASS. WHEN MATCH IS FOUND IF AT ALL, THEN LINK
ITEMS IN EGROUP INTO ECLASS IF NEITHER EGROUP NOR ECLASS IS IN COMMON.
 IF EITHER (BUT NOT BOTH)ARE IN COMMON THEN ADD NEW ITEMS
NOT IN COMMON INTO COMMON BLOCK OF WHICH ECLASS OR EGROUP ITEMS ARE MEMBERS.
 ERRORS OCCUR IF BOTH ECLASS AND EGROUP ARE IN COMMON.
%
LABEL ELIS1,ELIS2;
LOCAL	EGSYM,	!SYMBOL BEING SEARCHED IN GROUP
	EGSYMPTR,	!PTR TO SYMBOL TABLE OF SYMBOL BING SEARCHED
	EGITEM,	!PTR TO CURRENT EQUIVLIST ITEM IN GROUP
	CITEM,	!PTR TO LIST ITEM IN CLASS ECLASS
	CSYMPTR;	!PTR TO SYMBOL TABLE OF ITEM IN ECLASS

MAP BASE ECLASS :EGROUP :EGSYMPTR :CITEM :CSYMPTR :EGITEM;
!
XTRAC;	!FOR DEBUGGING TRACE
!
EGITEM _ .EGROUP[EQVFIRST];	!FIRST LIST ITEM IN EGROUP

IF 
ELIS1: (WHILE 1 DO
       BEGIN
	!SEARCH FOR MATCH OF ITEM IN ECLASS WITH ITEM IN EGROUP
	EGSYMPTR _ .EGITEM[EQLID]; EGSYM _ .EGSYMPTR[IDSYMBOL]; !GET THE SYMBOL
	CITEM _  .ECLASS[EQVFIRST]; !THE PTR TO FIRST LIST ITEM IN ECLASS
 ELIS2: WHILE 1 DO %2%
	BEGIN
		CSYMPTR _ .CITEM[EQLID]; !SYMBOL TABLE PTR
		IF .EGSYM EQL .CSYMPTR [IDSYMBOL]
		THEN LEAVE ELIS1 WITH (-1);
		IF .CITEM[EQLLINK] EQL 0
		THEN LEAVE ELIS2
		ELSE CITEM _ .CITEM[EQLLINK];
	END; !OF %2%
	IF .EGITEM[EQLLINK] EQL 0
	THEN LEAVE ELIS1 WITH  (0)
	ELSE EGITEM _ .EGITEM[EQLLINK];
       END !OF WHILE %1%
  )  EQL 0 THEN RETURN 0; !RETURN 0 IF NO MATCH BETWEEN ECLASS AND EGROUP
!
!WE GET HERE IF AN ITEM IN EGROUP MATCHES AN ITEM IN ECLASS
!CITEM POINTS TO THE ITEM IN ECLASS AND EGITEM POINTS TO THE
!ITEM IN EGROUP. WE NOW CHECK FOR COMMON EQUIVALENCE INTERACTION
!AND DECIDE WHETHER TO LINK THE NEW ITEMS INTO ECLASS OR TO ADD NEW ITEMS TO
!THE COMMON BLOCK OF WHICH ECLASS OR EGROUP (BUT NOT BOTH) IS A PART
!
BEGIN LOCAL EGDISPL,ELIM,ECDISPL;
	IF .CSYMPTR[IDATTRIBUT(INCOM)] THEN ECLASS[EQVINCOM] _ 1;  !SET CLASS IN COMMON
!
!CSYMPTR CONTAINS PTR TO MATCHED SYMBOL IN ECLASS
!EGSYMPTR CONTAINS PTR TO MATCHED SYMBOL IN EGROUP
!
ELIM _ .ECLASS[EQVLIMIT];	!LIMIT OF GROUP
EGDISPL _ .EGITEM[EQLDISPL];
ECDISPL _ .CITEM[EQLDISPL];
EGITEM _ .EGROUP[EQVFIRST];
EGSYMPTR _ .EGITEM[EQLID]; !SET PTR TO FIRST ITEM IN GROUP 

!
!TEST FOR GROUP OR CLASS IN COMMON
!
IF .ECLASS[EQVINCOM] OR .EGROUP[EQVINCOM]
  THEN
   BEGIN
!	IF .ECLASS[EQVINCOM] AND .EGROUP[EQV]
!	THEN ( IF .ECLASS[EQVHEAD] NEQ .EGROUP[EQVHEAD]
!		 THEN (ERROUT(48); RETURN -1;); !TWO COMMON ITEMS EQUIVALENCED
!	     )
!	ELSE
	 IF .EGROUP[EQVINCOM]
	  THEN( !ASSIGN COMMON ADDRESSES TO ECLASS
		ELIM _ .EGROUP[EQVLIMIT];
		EGDISPL _ .CITEM[EQLDISPL]; ECDISPL _ .EGITEM[EQLDISPL];
		CSYMPTR _ .EGITEM[EQLID];
		EGITEM _ .ECLASS[EQVFIRST]; EGSYMPTR _ .EGITEM[EQLID];
	      );
	WHILE 1 DO %1%
	BEGIN
  !NOW CHECK NEW COMMON ADDRESS NOW AND LINK NEW ITEM INTO EXISTING COMMON BLOCK
	IF .CSYMPTR NEQ .EGSYMPTR
	THEN
	  IF NOT (.ECLASS[EQVINCOM] AND .EGROUP[EQVINCOM])
	  THEN IF NOT .EGSYMPTR[IDATTRIBUT(INCOM)]
	     THEN
	        BEGIN LOCAL BASE CLCOMPTR :GPCOMPTR :COMSYM;
		  IF (EGSYMPTR[IDADDR] _ .CSYMPTR[IDADDR] + .EGITEM[EQLDISPL] -.EGDISPL) LSS 0
			THEN (MAP BASE R1;
				R1 _ .CSYMPTR[IDCOMMON];ENTRY[1] _ R1[COMNAME];RETURN ERROUT(33)
		     );
			 !ERROR EQUIVALENCE ITEM EXTENDS COMMON BACKWARD
	
		  EGSYMPTR[IDATTRIBUT(INCOM)] _ 1; !MAKE SYMBOL IN COMMON
		  CLCOMPTR _ .CSYMPTR[IDCOMMON]; !PTR TO COMMON BLOCK HDR
		  COMSYM _ .CLCOMPTR[COMLAST];	!PTR TO LAST SYMBOL IN BLOCK
		  COMSYM[IDCOLINK] _ .EGSYMPTR; !LINK IN NEW SYMBOL
		  CLCOMPTR[COMLAST] _ .EGSYMPTR;
		  EGSYMPTR[IDCOLINK] _ 0; !NEW END OF LINK
		  EGSYMPTR[IDCOMMON] _ .CLCOMPTR; !SYMBOL TO POINT TO BLOCK
	!  COMPUTE NEW BLOCK SIZE
	!  
		  IF .CLCOMPTR[COMSIZE] LSS (R1 _ .EGSYMPTR[IDADDR] +.ELIM - .EGITEM[EQLDISPL])
		   THEN CLCOMPTR[COMSIZE] _ .R1;
	       END
	    ELSE IF (.EGSYMPTR[IDADDR]-.EGITEM[EQLDISPL])
			NEQ (.CSYMPTR[IDADDR]-.EGDISPL)
			THEN (EQERRLIST(.EGROUP); EGROUP[EQVAVAIL] _ 3; RETURN -1);
!
!TESTING FOR END OF CHAIN OF GROUP GOING INTO COMMON
	  IF .EGITEM[EQLLINK] EQL 0
	   THEN (EGROUP[EQVAVAIL] _ 3; EGROUP[EQVINCOM]_1;RETURN 0)
	   ELSE (EGITEM _ .EGITEM[EQLLINK]; EGSYMPTR _ .EGITEM[EQLID]);
	END; !OF LOOP%1%
   END; !END OF IF INCOMMON
!
!HERE IF NEITHER GROUP NOR CLASS IN COMMON
!LINK ITEMS IN EGROUP INTO ECLASS, MARK EACH GROUP UNAVAILABLE
!CHECK FOR ERRORS OF FORM
! EQUIVALENCE (A(5),B(2)),(C(2),B(2)),(C(2),A(4))
!
EGITEM _ .EGROUP[EQVFIRST];
WHILE 1 DO
BEGIN LOCAL ENEXITEM,NEWDISPL;
	ENEXITEM _ .EGITEM[EQLLINK];  !PTR TO NEXT ITEM IN GROUP TO BE LINKED TO CLASS
	EGSYMPTR _ .EGITEM[EQLID];
	EGSYM _ .EGSYMPTR[IDSYMBOL];

!NOW SEARCH FOR EGSYM IN ECLASS
!
	CITEM _ .ECLASS[EQVFIRST];	!PTR TO FIRST ITEM IN CLASS
	NEWDISPL _ .ECDISPL + .EGITEM[EQLDISPL] -.EGDISPL;
	IF WHILE 1 DO
	   BEGIN   %2%
		CSYMPTR _ .CITEM[EQLID];
		IF .EGSYM EQL .CSYMPTR[IDSYMBOL]
		  THEN EXITLOOP (-1);
		IF .CITEM[EQLLINK] EQL 0
		  THEN EXITLOOP (0)
		  ELSE CITEM _ .CITEM[EQLLINK]
	   END  !OF %2%
	NEQ 0
	  THEN	!MAKE SURE DISPLACEMENTS OF MATCHING ITMES ARE OK
	    (	IF .NEWDISPL NEQ .CITEM[EQLDISPL]
		  THEN (EQERRLIST(.EGROUP); !INCONSISTENT OR CONFLICTING EQUIVALENCES
			EGROUP[EQVAVAIL] _ 3; RETURN -1
		       );
	    )
	  ELSE	(CITEM[EQLLINK] _ .EGITEM;
		);
	EGITEM[EQLLINK] _ 0;	!CLEAR LINK
	EGITEM[EQLDISPL] _ .NEWDISPL;
	IF .NEWDISPL LSS .ECLASS[EQVADDR]
	  THEN ECLASS[EQVADDR] _ .NEWDISPL;
!
!NOW COMPUTE NEW EQVLIMIT
!
	BEGIN LOCAL BASE ESYM, EQSIZ;
	  EQSIZ _ IF .EGSYMPTR[IDDIM] NEQ 0
			THEN (ESYM _ .EGSYMPTR[IDDIM]; .ESYM[ARASIZ])
			ELSE IF .EGSYMPTR[DBLFLG] THEN 2 ELSE 1;
	  IF (.EGITEM[EQLDISPL] + .EQSIZ) GTR .ECLASS[EQVLIMIT]
		THEN ECLASS[EQVLIMIT] _ (.EGITEM[EQLDISPL] + .EQSIZ);
	END;
	IF .ENEXITEM EQL 0 THEN RETURN 1  !GOOD RETURN (ALLITEMS IN EGROUP LINKED TO ECLASS)
		 ELSE EGITEM _ .ENEXITEM;
END; !OF %1%
END;
END;	!OF ROUTINE ELISTSRCH
ROUTINE EQCALLOC(ECLASS)=
BEGIN
%
ALLOCATE RELOCATABLE ADDRESSES TO AN EQUIVALENCE CLASS (ECLASS)
%
EXTERNAL LOWLOC;	!THE LOW SEG AVAILABLE LOCATION
MAP BASE ECLASS;
LOCAL BASE CITEM :CSYMPTR;
LOCAL TLOC;
OWN CNT;
%
THE ADDRESS OF ANITEM IN ECLASS IS COMPUTED AS FOLLOWS
 ADDR _ .LOWLOC + (RELATIVE DISPLACEMENT OF ITEM IN ECLASS (CITEM[EQLDISPL] 
		- SMALLEST RELATIVE DISPLACEMENT IN ECLASS (ECLASS[EQVADDR])
%
CNT _ 0;
IF .FLGREG<LISTING> THEN ZOUTMSG(PLIT '?M?J( ?0');
TLOC _ .LOWLOC - .ECLASS[EQVADDR];
CITEM _ .ECLASS[EQVFIRST];
WHILE 1 DO
BEGIN
	CSYMPTR _ .CITEM[EQLID];	!PTR TO SYMBOL
	CSYMPTR[IDADDR] _ .CITEM[EQLDISPL] + .TLOC;
	IF .FLGREG<LISTING>
	THEN(LISTSYM(.CSYMPTR);
	     IF .CNT LSS 5 THEN CNT _ .CNT+1
		ELSE (CNT _ 0; CRLF());
	    );
	IF .CITEM[EQLLINK] EQL 0
	  THEN EXITLOOP ELSE CITEM _ .CITEM[EQLLINK];
END;
LOWLOC _ .LOWLOC + .ECLASS[EQVLIMIT] - .ECLASS[EQVADDR];
!
!LOWLOC + SPAN OF THE CLASS
!
END;	!OF EQCALOC
ROUTINE PROCEQUIV=
BEGIN
%PROCESSES EQUIVALNCE GROUPS AS DECLARED IN THE SOURCE -N RESOLVING
IMPLICIT EQUIVALENCES AND EQUIVALENCES INTO COMMON. CHECKS FOR
ALLOCATION ERRORS DUE TO IMPROPER EQUIVALENCES. ASSIGNS TEMPORARY
ADDRESSES TO EQUIVALENCE VARIABLES AND NEW VARIABLES EQUIVALENCED INTO COMMON.
%
EXTERNAL EQVPTR,	!PTR TO FIRST AND LAST EQUIVALENCE GROUPS
	ARRXPN,	!FOR EXPANDING ARRAY REFERENCES IN EQUIVALENCE ITEMS
	ZOUTMSG,	!MESSAGE OUTPUTTER
	ELISTSRCH,	!ROUTINE THAT SEARCHES FOR A MATCH OF ONE ITEM
			!IN A CLASS IN ANY AVAILABLE GROUP
	EQCALLOC;	!ALLOCATION OF EQUIVALENCE CLASSES
LOCAL BASE EQVCPTR,	!PTR TO CURRENT EQUIV CLASS HEADER
	ECOMMPTR,	!PTR COMMON ITEM IF GROUP IS IN COMMON
	ECOMMHDR,	!PTR TO COMMON BLOCK HDR
	LCLHD;	!PTR TO LOCAL HEAD OF A GROUP FOR ALLOCATION PURPOSES
REGISTER BASE EQLPTR;
LABEL COMN1,LOOP2;

!
!THE FIRST STEP IS TO COMPUTE RELATIVE DISPLACEMENTS OF EACH ITEM IN
!AND EQUIVALENCE GROUP. THIS IS SIMPLY 1 MINUS THE SUBSCRIPT
!VALUE OF EACH ITEM IN THE GROUP.
!I.E A(1) HAS DISPLACEMENT 0 AND A(4) HAS DISPLACEMENT -3
!
IF .FLGREG<LISTING> THEN ZOUTMSG(PLIT'?M?JEQUIVALENCED VARIABLES?M?J?0');
EQVCPTR _ .EQVPTR<LEFT>;	!PTR TO FIRST GROUP
WHILE 1 DO	%1%
BEGIN
	ECOMMPTR _ 0;	!INITIALIZING
	!IF GROUP IS IN COMMON THEN FIND THE ELEMENT IN COMMON
    COMN1: IF .EQVCPTR[EQVINCOM]
	THEN(	LOCAL BASE COMPTR;
			EQLPTR _ .EQVCPTR[EQVHEAD]; !PTR TO LIST ITEM THAT IS IN COMMON
			COMPTR_ .EQLPTR[EQLID];
			ECOMMPTR _ .EQLPTR; !PTR TO COMMON ITEM EQL LIST ITEM
			ECOMMHDR _ .COMPTR[IDCOMMON];
			LCLHD _ .EQLPTR[EQLID];
	     )
	ELSE LCLHD _ 0;
    EQLPTR _ .EQVCPTR[EQVFIRST]; !PTR TO FIRST ITEM IN GROUP
    R2 _ R1 _ 0;	!EQVLIMIT IN R2, SMALLEST DISPLACEMENT IN R1
    LOOP2: WHILE 1 DO %2%
       BEGIN
	IF .EQLPTR[EQLINDIC] NEQ 0
	THEN (LOCAL BASE PT1;
		EQLPTR[EQLINDIC] _ 0;
		 PT1 _ ARRXPN(.EQLPTR[EQLID],.EQLPTR[EQLLIST]);
		EQLPTR[EQLDISPL] _ -(EXTSIGN(.PT1[TARGET])); !GET - DISPLACEMENT
	     );
!
!
!NOW CHECK FOR NEW EQVLIMIT (R2) FOR THIS GROUP
	BEGIN LOCAL BASE ESYM, EQSIZ;
	   ESYM _ .EQLPTR[EQLID]; !PTR TO SYMBOL TABLE
	!
	   EQSIZ _ IF .ESYM[IDDIM] NEQ 0
			THEN (ESYM _.ESYM[IDDIM]; .ESYM[ARASIZ])
			ELSE IF .ESYM[DBLFLG] THEN 2 ELSE 1;
	   IF (.EQLPTR[EQLDISPL] + .EQSIZ) GTR .R2 %EQVLIMIT%
		THEN R2 _ (.EQLPTR[EQLDISPL] +.EQSIZ);
	END;
!
!NOW CHECK FOR NEW MIN(R(I)) RELATIVE DISPLACEMENT
!
	IF .EQLPTR[EQLDISPL] LSS .R1
		THEN (R1 _ .EQLPTR[EQLDISPL]; LCLHD _ .EQLPTR[EQLID]);
	IF .ECOMMPTR NEQ 0
	  THEN IF .EQLPTR NEQ .ECOMMPTR
		THEN(	LOCAL BASE LINK:COM;
			MAP BASE ECOMMHDR :ECOMMPTR;
			LINK _ .EQLPTR[EQLID];
			COM _ .ECOMMPTR[EQLID];	!PTR TO ITEM IN CO MMON
			IF NOT .LINK[IDATTRIBUT(INCOM)] 
			THEN(
				LINK _ .ECOMMHDR[COMLAST];
				ECOMMHDR[COMLAST] _ .EQLPTR[EQLID];
				LINK _ LINK[IDCOLINK] _ .EQLPTR[EQLID]; !PTR TO SYMBOL TABLES NODE
				LINK[IDATTRIBUT(INCOM)] _ 1; !SET IN COMMON
				LINK[IDCOMMON] _ .ECOMMHDR;
				LINK[IDCOLINK] _ 0;
				IF (LINK[IDADDR] _ (.EQLPTR[EQLDISPL] - .ECOMMPTR[EQLDISPL] + .COM[IDADDR]) ) LSS 0
				THEN (ENTRY[1] _ ECOMMHDR[COMNAME]; ERROUT(33);
					LEAVE LOOP2;
				     );
				IF .ECOMMHDR[COMSIZE] LSS (.LINK[IDADDR] +.R2 - .EQLPTR[EQLDISPL])
				THEN ECOMMHDR[COMSIZE] _(.LINK[IDADDR] +.R2 - .EQLPTR[EQLDISPL]);
			)
		         ELSE IF (.COM[IDADDR]-.ECOMMPTR[EQLDISPL]) NEQ (.LINK[IDADDR]-.EQLPTR[EQLDISPL])
				THEN (EQERRLIST(.EQVCPTR); EQVCPTR[EQVAVAIL] _ 3;LEAVE LOOP2);
	!
	!CHECKING THE DECLARATIONS FOR VIOLATING BEGINNING OF COMMON BLOCK
	!
		    );
!
!CHECKING FOR END OF CHAIN OF ITEMS
!
	IF .EQLPTR[EQLLINK] EQL 0
	THEN EXITLOOP	!END OF CHAIN
	ELSE EQLPTR _ .EQLPTR[EQLLINK]
    END; !OF WHILE %2%
!
    EQVCPTR[EQVADDR] _ .R1;	!LOWEST RELATIVE DISPLACEMENT

!    EQVCPTR[EQVHEAD] _ .LCLHD;	!PTR TO HED OF GROUP

    EQVCPTR[EQVLIMIT] _ .R2;	!SPAN OF GROUP RELATIVE TO 0
!
!REAL SPAN (#OF WORDS OCCUPIED BY ALL ELEMNTS OF GROUP)
!IS EQVLIMIT - EQVADDR
!
    IF .EQVCPTR[EQVLINK] EQL 0
    THEN EXITLOOP	!END OF CHAIN OF GROUPS
    ELSE EQVCPTR _ .EQVCPTR[EQVLINK]
END; !OF %1%
!
!NOW START TO MAKE EQUIVALENCE CLASSES BY COMBINING GROUPS IF POSSIBLE
!
EQVCPTR _ .EQVPTR<LEFT>;	!START WITH FIRST GROUP
WHILE 1 DO	%1%
BEGIN
    WHILE 1 DO	%2% !GROUP(I) BECOMING A CLASS
    BEGIN
	IF .EQVCPTR[EQVAVAIL] EQL 0 !GROUP AVAILABLE FOR CLASS
	THEN ( MACRO EQGPPTR = EQLPTR$;
		EQVCPTR[EQVAVAIL] _ 2; !MAKE GROUP A CLASS
		EQGPPTR _ .EQVCPTR; !BEGIN SRCH OF OTHER GROUPS ON CURRENT GROUP
		DO
		BEGIN
		  IF .EQGPPTR[EQVAVAIL] EQL 0
		  THEN (
			IF (ELISTSRCH(.EQVCPTR,.EQGPPTR)) GTR 0
			THEN EQGPPTR[EQVAVAIL] _ 2;
			!
			!IF ERROR OCCURRED IN ELSTSRCH THEN EQGPPTR[EQVAVAIL]
			!WILL BE SET TO 3 (ERROR)
			!
		       );
		END
		    WHILE (EQGPPTR _ .EQGPPTR[EQVLINK]) NEQ 0;
		IF NOT .EQVCPTR[EQVINCOM]
		  THEN IF .EQVCPTR[EQVAVAIL] NEQ 3
			THEN EQCALLOC(.EQVCPTR); !ALLOCATE CLASS POINTED TO BY EQVCPTR
	      ); !END OF IF AVAIL TEST
	  IF .EQVCPTR[EQVLINK] EQL 0
		THEN EXITLOOP  !NO MORE GROUPS TO PROCESS INTO CLASS
		ELSE EQVCPTR _ .EQVCPTR[EQVLINK]; !NEXT GROUP TO BE A CLASS
	END; !OF LOOP %2%
	IF (EQVCPTR _ .EQVCPTR[EQVLINK]) EQL 0 THEN RETURN;
!
!ALL GROUPS PROCESSED IF RETURN TAKEN
!
END; ! OF LOOP %1%
END; !OF ROUTINE PROCEQUIV



GLOBAL ROUTINE  KISNGL(X,Y)=
BEGIN
	!X IS THE HIGH ORDER KI-10 CNSTANT, Y IS LOW ORDER WORD
!
	BIND HI=R1,LOW=R2;
	MACHOP ADDI=#271,TLZE=#623,TLO=#661,LSH=#242,DFN=#131;
MACRO EXPON=27,8$;
	HI _ .X; LOW _ .Y;
	IF .HI LSS 0
	THEN (HI _ -.HI; LOW _ -.LOW;
		IF .LOW NEQ 0 THEN HI _ .HI-1;
	     );
	IF .LOW<34,1>		!IS ROUNDING NECESSARY?
	THEN(
		IF .HI NEQ #377777777777
		THEN HI _ .HI+1;
		HI<26,1> _ 1;	!SET HIGHORDER BIT ON
	    );
	IF .X LSS 0 THEN HI _ -.HI;	!RESTORING SIGN
	.HI		!IS RETURNED
END;
GLOBAL ROUTINE KITOKA(X,Y)=
BEGIN
	EXTERNAL C2H,C2L;	!GLOBALS TO RETURN CONVERTED  CP CONSTANTS
	BIND HI=R1,LOW=R2;
	MACHOP ADDI=#271,TLZE=#623,TLO=#661,LSH=#242,DFN=#131;
MACRO EXPON=27,8$;
	HI _ .X;	!GET THE VALUE INT REGISTERS 1 AND 2
	LOW _ .Y;
	IF .X LSS 0 
	THEN( LOW _ -.LOW;
		HI _ -.HI;
		TLZE(LOW,#400000);
		HI _ .HI -1;	!SUBTRACT ONE FOR ONES COPLEMENT
	    );
	IF .HI<EXPON> GEQ 27
	THEN( LOW _ .LOW + #200;
		TLZE(LOW,#400000);
		ADDI(HI,1);
	    )
	ELSE( TLZE(LOW,#200000);
		ADDI(HI,1);
		LOW _ 0;
	    );
	TLO(HI,#400);	!SET THE HI ORDER BIT
	IF .HI LSS 0 THEN (HI _ #377777777777;	!OVERFLOW OCCURRED
				LOW _ #377777777777;
			);
	LSH(LOW,-8);	!SHIFT OUT EXPON BITS
	IF .LOW NEQ 0
		THEN	LOW<EXPON> _ .HI<EXPON> - 27;	!LOW ORDER EXPONENT
	IF .X LSS 0 THEN DFN(HI,LOW);
	C2H _ .HI;	!RESTORING VALUES
	C2L _ .LOW;
END; !OF KITO KA
GLOBAL ROUTINE ALCCON=
BEGIN
	!ALLOCATE (USING HILOC) ALL THE CONSTANTS THAT HAVE
	!THE FLAG CNTOBEALCFLG SET.  THIS FLAG IS SET BY CALLS TO
	!ALOCONST.
	EXTERNAL HILOC,RDATWD,ZOUTBLOCK,C2H,C2L;

	EXTERNAL LITPOINTER;
	BIND HI=R1,LOW=R2;
	MACHOP ADDI=#271,TLZE=#623,TLO=#661,LSH=#242,DFN=#131;
MACRO EXPON=27,8$;
MACRO RELCONST(CXPTR)=	 !DUMPS CONSTANTS ONTO REL FIE
BEGIN
MAP BASE CXPTR;
	IF .CXPTR[VALTP1] EQL INTEG1
	 THEN RDATWD _ .CXPTR[CONST2]
	 ELSE RDATWD _ .CXPTR[CONST1];	!HIGH ORDER FOR REAL OR DOUBLE
	ZOUTBLOCK(RCODE,RELN);
	HILOC_.HILOC+1;
	IF .CXPTR[DBLFLG]	!IF DOUBLE OR COMPLEX CONSTANT
	 THEN ( RDATWD _ .CXPTR[CONST2]; ZOUTBLOCK(RCODE,RELN);
			HILOC_ .HILOC+1;
		);
END$;
	LOCAL BASE CPTR;

	INCR I FROM 0 TO CSIZ-1 DO
	BEGIN
	IF .CONTBL[.I] NEQ 0 THEN
	BEGIN
		CPTR_.CONTBL[.I];
		WHILE .CPTR NEQ 0 DO
		BEGIN
			!NOW CHECK FOR KA-10 DP CONSTANT O/P
			IF .CPTR[CONST1] NEQ 0
			THEN
				IF .CPTR[VALTYPE] EQL DOUBLPREC
				THEN (
					IF .FLGREG<KA10>
					 THEN (KITOKA(.CPTR[CONST1],.CPTR[CONST2]);	!DO THE CORRECT FIXUP
						CPTR[CONST1] _ .C2H;
						CPTR[CONST2] _ .C2L;
					     )
				     )
				ELSE IF .CPTR[VALTYPE] EQL REAL
					THEN CPTR[CONST1] _ KISNGL(.CPTR[CONST1],.CPTR[CONST2]);
			IF .CPTR[CNTOBEALCFLG] THEN
			BEGIN
				CPTR[IDADDR]_.HILOC;
				%NOW PUT CONSTANT OUT IN REL FILE
				REMEMBER THAT THIS ROUTINE IS EXECUTED WITHIN
				A TEST FOR THE REL FILE GENERATION%

				RELCONST(CPTR);		!IN MACRO ABOVE
			END;
			CPTR_.CPTR[CLINK];
		END;
		END;
	END;
	IF (CPTR _ .LITPOINTER<LEFT>) NEQ 0
	THEN DO
		(IF .CPTR[CNTOBEALCFLG] THEN
		 BEGIN
			CPTR[LITADDR] _ .HILOC;
			INCR I FROM 0 TO .CPTR[LITSIZ]-1 DO
			  (RDATWD _ .(CPTR[LIT1]+.I);
			   ZOUTBLOCK(RCODE,RELN);
			   HILOC _ .HILOC+1;	!INCREMENTING FOR ZOUTBLOCK
			  );
		  END;
		) WHILE (CPTR _ .CPTR[LITLINK]) NEQ 0;
END;
GLOBAL ROUTINE ALCTMPS=
BEGIN
	!ROUTINE CLEANS UP ALL THE ALLOCATION OF VARIABLES.
	!THIS IS A THREE STEP PROCESS.
	!	1. GO THROUGH THE SYMBOL TABLE AND ALLOCATE ALL
	!	  THOSE PREVIOUSLY UNALLOCATED. THIS IS PRIMARILY
	!	  THE TEMPS GENERATED FOR REGISTER SAVE/RESTORE
	!	  FOR A SUBROUTINE OR FUNCTION.
        !       2. STRING ALLOCATION
	!	3. THE TEMPS GENERATED IN THE LOCAL REGISTER
	!	  ALLOCATION PROCESS.

	EXTERNAL SYMTBL,LOWLOC,ADJHEAD,FRSTLNK,PROGNAME;

        EXTERNAL        HISEGBLK,ZOUTBLOCK,RDATWD,HILOC;

        LABEL L1,L2;
        LOCAL PTR;


	LOCAL CNT;

	IF .FLGREG<LISTING> THEN ZOUTMSG(PLIT'?M?J?M?JTEMPORARIES?M?J?M?J');
	!FIRST THE SYMBOL TABLE

		CNT _ 0;
		INCR K FROM 0 TO SSIZ-1 DO
		BEGIN
			REGISTER BASE T;
			T_.SYMTBL[.K];
			WHILE .T NEQ 0 DO
			BEGIN
			     IF .T[IDADDR] EQL 0
				THEN IF NOT .T[IDATTRIBUT(INCOM)]  AND .T[OPRSP1] NEQ FNNAME1 AND NOT .T[IDATTRIBUT(COMBL)] THEN
				BEGIN
					T[IDADDR]_.LOWLOC;
					LOWLOC_.LOWLOC+1+.T[DBLFLG];
					IF .FLGREG<LISTING> THEN 
					   (LISTSYM(.T);
						IF (CNT _ .CNT+1) GTR 5 THEN (CNT_0; CRLF());
					   );
				END;
				T_.T[CLINK];
			END;
		END;

	!NOW (FOR EITHER SUBPROGRAM OR MAIN PROGRAM, THE TEMPS
	!GENERATED BY LOCAL REGISTER ALLOCATION

	WHILE .FRSTLNK NEQ 0 DO
	BEGIN
		MAP BASE FRSTLNK;
		FRSTLNK[IDADDR]_.LOWLOC;
		LOWLOC_.LOWLOC+1;
		IF .FLGREG<LISTING>
		 THEN ( LISTSYM(.FRSTLNK);
			IF (CNT _ .CNT+1) GTR 5 THEN (CNT_0; CRLF());
		      );
		!**NOTE**
		!THESE ARE ALSO SINGLE CELL. NXTTMP TAKES
		!CARE OF GETTING TWO FOR A DOUBLE WORD QUANTITY
		FRSTLNK_.FRSTLNK[CLINK];
        END;

%(****************************************************************

AT THIS POINT ALL THE LOWSEG CELLS HAVE BEEN ALLOCATED.
WE ARE NOW READY TO OUTPUT THE HISEG STRING POINTERS,
AND THE DEBUGGER BLOCK 30 SYMBOL TABLES FOR VARIABLES, AND ARRAYS.
BUT FIRST WE MUST OUTPUT THE LOADER BLOCK TYPE 3

***************************************************************)%


HISEGBLK();


%(***********NOW BEGIN THE STRING POINTER ALLOCATION***********)%


        INCR K FROM 0 TO SSIZ - 1  DO
        BEGIN

                REGISTER BASE T;
                T  _  .SYMTBL[.K];

                WHILE .T  NEQ  0  DO
                BEGIN

                        IF  .T[VALTYPE]  EQL  STRING

                        THEN
                        BEGIN
                                RDATWD  _  .T[CW2];
                                ZOUTBLOCK(RCODE,RELN);
                                T[CW2]  _  .HILOC;
                                HILOC  _  .HILOC  +  1;
                        END;

                        T  _  .T[CLINK];
                END;
        END;


        INCR  K  FROM  0 TO  SSIZ  -  1  DO
        BEGIN
        
                REGISTER BASE T;
                T  _  .SYMTBL[.K];

                WHILE  .T  NEQ  0  DO
                BEGIN

                L1:
                        IF NOT .T[IDATTRIBUT(COMBL)]
                        THEN
                        IF NOT .T[IDATTRIBUT(INCOM)]
                        THEN
                        IF NOT .T[IDATTRIBUT(NAMNAM)]
                        THEN
                        (
                           IF  NOT  .T[IDATTRIBUT(INEQV)]
                           THEN
                                L2:
                                BEGIN
                                IF  NOT .T[IDATTRIBUT(DUMMY)]
                                THEN
                                IF  .T[OPRSP1]  EQL  FNNAME1
                                THEN
                                IF NOT .T[IDATTRIBUT(FENTRYNAME)]
                                THEN
                                LEAVE  L1;


        !WE NOEW HAVE ONLY VARIABLES, AND ARRAYS LEFT.

        ! SO FORMAT, AND OUTPUT THEM.


                !AM ONLY DOING VARIABLES, AND ARRAYS...NO FORMLVAR/ARY

                IF  .T[OPERSP]  EQL  VARIABLE

                THEN
                BEGIN
                        RDATWD  _  0;
                        RDATWD<35,1>  _  1;     !SET THE VAR FLG
                        RDATWD<6,6>  _  .T[VALTYPE];
                        RDATWD<0,6>  _  3;            !LENGTH OF SYM ENT
                        ZOUTBLOCK(RDEB,RELN);


                        !NOW OUTPUT WORD TWO

                        RDATWD  _  .T[IDADDR];
                        ZOUTBLOCK(RDEB,RELRI);

                        !NOW OUTPUT WORD THREE



                        RDATWD  _  .T[IDSYMBOL];
                        ZOUTBLOCK(RDEB,RELN);

                END;

                IF  .T[OPERSP]  EQL ARRAYNAME

                THEN
                BEGIN
                

                        PTR  _  .T[IDDIM];    !FETCH THE ARRAY INFO NODE
                        CNT  _  .PTR  +  1;
                        RDATWD  _  0;
                        RDATWD<19,1>  _  1;
                        RDATWD<6,6>  _  .T[VALTYPE];
                        RDATWD<0,6>  _  .PTR<34,16>+4;  !ENT SIZ
                        ZOUTBLOCK(RDEB,RELN);

                        ! NOW OUTPUT WORD TWO

                        RDATWD<LEFT>  _  .PTR<34,16>;   !#DIMS
                        RDATWD<RIGHT> _  .CNT<LEFT>;     !ARAOFFSET
                        ZOUTBLOCK(RDEB,RELRI);

                        ! NOW OUTPUT WORD THREE

                        RDATWD  _  .T[IDSYMBOL];
                        ZOUTBLOCK(RDEB,RELN);

                        ! NOW OUTPUT WORD N


                        RDATWD<LEFT>  _  .PTR<RIGHT>;   !# WRDS IN ARRAY
                        RDATWD<RIGHT>  _  .CNT<RIGHT>;   !ARADDVAR
                        ZOUTBLOCK(RDEB,RELN);

                END;
             END;

            );
                T  _  .T[CLINK];
        END;    !THIS END THE LOOP LOGIC
    END;        !THIS ENDS THE OUTER LOOP LOGIC

END;




GLOBAL ROUTINE HISEGBLK=
BEGIN
!ROUTINE GENERATES A HISEG BLOCK IN THE THE REL FILE
!WORD 1 OF THE HISEG BLOCK IS THE TWOSEG PSEUDO OP ID
!WORD 2 IS THE SIZE OF THE LOWSEG IN WORDS IN THE LEFT HALF
!	AND ZERO IN THE RIGHT HALF
!WORD 2 IS ONLY USEFUL IF WE WISH TO LOAD EXECUTABLE CODE IN THE LOWSEG
!	INSTEAD OF THE HISEG

EXTERNAL RDATWD,ZOUTBLOCK,LOWLOC;
	RDATWD _ #400000^18 + #400000;
	ZOUTBLOCK(RHISEG,RELRI);
	RDATWD _ .LOWLOC^18 + 0;
	ZOUTBLOCK(RHISEG,RELN);
END;	!OF HISEGBLK
GLOBAL ROUTINE RELINIT= !INITIALIZES REL FILE
BEGIN
%
GENERATES BLOCKS	4 - ENTRY
			6 - NAME
			3 - HISEG
%
EXTERNAL RELDATA,RELOCWD,PROGNAME,MULENTRY,HILOC;
MAP BASE MULENTRY;	!PTR TO CHAIN OF MULTIPLE ENTRIES OF THIS SUBPROGRAM
!
!INIT FIRST BLOCK
!
	RELOCPTR_(RELOCWD-1)<0,2>; !INIT RELOC BITS BYTE PTR
	RELDATA<LEFT>_RENTRY;  !CURRENT BLOCK TYPE IS ENTRY
	RELOCWD _ 0; R2 _.PROGNAME;
	WHILE 1 DO
	(
		RDATWD _ RADIX50();
		ZOUTBLOCK(RENTRY,RELN);
		IF .MULENTRY NEQ 0
		THEN (R2 _ .MULENTRY[ENTSYM]; MULENTRY _ .MULENTRY[CLINK])
		ELSE EXITLOOP;
	);
	RDATWD _ (R2 _ .PROGNAME; RADIX50());
	ZOUTBLOCK(RNAME,RELN);  !NAME BLOCK
	RDATWD_ IF .FLGREG<KA10> THEN (#10)^18 ELSE (#20010)^18;
	ZOUTBLOCK(RNAME,RELN);	!THE FORTRAN-IV IDENTIFER
!NOW FOR HISEG
	 HILOC _   #400000;
	.VREG
END;
 =w7g|