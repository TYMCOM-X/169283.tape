




%%
%              ----------H1DECL.BLI----------
               16 MAY 72-A
%
%%




%%
%     THE GENERAL STRUCTURE OF THE ROUTINE/FUNCTION/STRUCTURE
  DECLARATION PROCESSORS IS AS FOLLOWS+
    
    1. THERE ARE 4 SYNTAX ROUTINES:SGLOROU,SROUTINE,
      SFUNCTION, AND SSTRUCTURE; EACH IS A GLOBAL ROUTINE
      OF NO PARAMETERS CALLED WHEN THE WINDOW IS IN THE
      FORM:
        (XXX,"SROUTINE",<ROUTINE NAME>,"(").

    2.  THE FIRST 3 OF THESE DIFFER SIGNIFICANTLY ONLY
        IN THAT THEIR STE TYPES ARE DIFFERENT AND THEY SET
        THE GPV "FCNSTATE" DIFFERENTLY.  HENCE, THEY SIMPLY
        CALL THE ROUTINE "DECSIMPLE" WITH THEIR TYPE, VALUE
        THAT FCNSTATE IS TO BE SET TO, AND ERROR INCREMENT:
        NOTE: A FUNCTION MAY NOT BE DECLARED WITHIN A ROUTINE.
%
%%

    FORWARD DECSIMPLE;
!    GLOBAL ROUTINE SGLOROU = DECSIMPLE(GLOBALT,1);
    GLOBAL ROUTINE SROUTINE = DECSIMPLE(RTNT, 1);
    GLOBAL ROUTINE SFUNCTION =  DECSIMPLE(FUNCT, 2);

%%
%   3.  IT WILL BE SEEN THAT "DECSIMPLE" ACTUALLY CORRESPONDS
        (ON THE SAME LEVEL) TO SSTRUCTURE, AND HENCE WILL BE
        EXPLAINED FIRST.  DECSIMPLE DOES EVERYTHING IT CAN
        WITHIN THE CURRENT BLOCKLEVEL/FUNCTIONLEVEL CONTEXT, WHICH IS

        A.  SAVE THE GPV "FCNSTATE" AND SET THE NEW VALUE TO ITS
          SECOND PARAMETER VALUE;
      B.  CREATE A SYMBOL TABLE ENTRY AT THE CURRENT BLOCK/FUNCTION
          LEVEL FOR THE ROUTINE/FUNCTION NAME, IF IT IS NOT ALREADY
          DECLARED TO BE FORWARD;
      C.  CALL "RFS" TO PROCESS THE ROUTINE/FUNCTION IN A NEW
          BLOCK/FUNCTION LEVEL CONTEXT, WITH PARAMETERS
          WHICH INDICATE:
        I.  THE STE FOR THE CURRENT R/F/S NAME;
       II.  THE FORMAL PARAMETER TYPE NAME: FORMALT;
      III.  THE LEFT-DELIMITER FOR THE PARAMETER LIST: "(";
       IV.  THE RIGHT-DELIMITER FOR THE SAME: ")";
        V.  THE FACT THAT WE ARE NOT PROCESSING A STRUCTURE: 0;
%
%%

     ROUTINE DECSIMPLE(DSTYPE,DSFUNST) =
      BEGIN
                LOCAL LOCGPV[1];
        PUSHGPV(0,FCNSTATE)_.DSFUNST;
        BEGIN
          LOCAL DSSTE,DSSTTP,DSSTWD1;
          % COMPARE DECSYM AND DECSYN%
          IF .REALFS EQL 0
            THEN (RECOVER(.NFUTSYM,ERSYNAME); EXITBLOCK)
            ELSE IF (DSSTWD1_.ST[DSSTE_.REALFS,0]; .DSSTWD1<BLF>)
                    EQL  .BLOCKLEVEL
                    THEN IF (DSSTTP_.DSSTWD1<TYPEF>) EQL
                         UNDEDT
                           THEN (ST[.DSSTE,0]<TYPEF>_.DSTYPE;
                                 ST[.DSSTE,1]_0)
                           ELSE IF .DSSTTP EQL FORWT
                                  THEN (ST[.DSSTE,0]<TYPEF>_.DSTYPE)
                                  ELSE (RECOVER(.NFUTSYM,ERSMPREV);
                                        EXITBLOCK)

                    ELSE DSSTE_DECSYQ(.DSSTE,.DSTYPE,0);
          RFS(.DSSTE,0,.DSTYPE EQL #12);
        END;
        POPGPV(0,FCNSTATE);
      END;

%%
%   4. "SSTRUCTURE" BEHAVES DIFFERENTLY FROM "DECSIMPLE"
       IN THAT:
      A.  ALTHOUGH "FCNSTATE" IS SAVED, IT IS SET TO THE SAME
          VALUE AS THE LAST STATE (IF IN FUNCTION OR ROUTINE)
          OR TO A ROUTINE AT FUNCTIONLEVEL 0.
      B.  THE ADDITIONAL GPVS: CURST, CURSTI, AND STRDEF
          ARE SAVED AND INITIALIZED TO THE STE INDEX ,
          THE STE INDEX, AND 3, RESPECTIVELY.
      C.  FORWARD STRUCTURE DEFINITIONS CANNOT OCCUR; HENCE, THE
          DECLARE SIMPLE VARIABLE ROUTINE DECSYN IS USED.
      D.  CALLS RFS WITH PARAMETERS:
        I.  THE STRUCTURE NAME STE INDEX;
       II.  THE FACT THAT WE ARE PROCESSING A STRUCTURE: 1;
%
%%

    GLOBAL ROUTINE SSTRUCTURE =
      BEGIN
        LOCAL LOCGPV[4];
        PUSHGPV(0,STRDEF)_0;
        PUSHGPV(1,CURST);
        PUSHGPV(2,CURSTI);
        PUSHGPV(3,FCNSTATE)_1;
        BEGIN
          LOCAL STVEC STRSTE;
          IF DECSYN(STRSTE,STRT)
            THEN
              BEGIN
                IF (.STRSTE[2] EQL .WDVECTOR) AND
                   .WDVECTOR[1] EQL .STRSTE[3]
                  THEN PTOVECTOR_.STRSTE; ! CURRENT "VECTOR"
                RFS(CURST_.STRSTE,1,0);
                IF (.SERRPOS NEQ 0) AND NOT .STRSTE[1]<SIMBITAF>
                  THEN
                    (ERROR(.SERRPOS,#40); SERRPOS_0);
              END;
        END;
        POPGPV(3,FCNSTATE);
        POPGPV(2,CURSTI);
        POPGPV(1,CURST);
        POPGPV(0,STRDEF);
      END;

  GLOBAL ROUTINE SUNDECLARE =
    BEGIN
      DO
        IF .REALFS NEQ 0
          THEN DECSYQ(.REALFS, UNDEDT, 0)
          ELSE RECOVER(.NFUTSYM,ERSYNAME)
        WHILE (HRUND(); .DEL<LEFTHALF> EQL HCOMMA);
    END;

  GLOBAL ROUTINE SFORWARD =
    BEGIN
            LOCAL SFSTE, SFSYNCHK;
      DO
        (IF DECSYM(SFSTE, FORWT)
          THEN
            SYM_(IF .DEL<LEFTHALF> EQL HPAROPEN
                 THEN
                   (HRUND();
                   SFSYNCHK_.NSYM;
                    EXPRESSION(1);
                    IF NOT LITP(.SYM)  THEN (RECOVER(.SFSYNCHK,ERSMBADFEXP); RETURN);
                    IF (.DEL<LEFTHALF> NEQ HROCLO) OR
                       (.FUTSYM NEQ HEMPTY)
                      THEN (RECOVER(.NDEL,ERSYMNPRD); RETURN);
                    SFSYNCHK_.SYM;
                    HRUND();
                    .SFSYNCHK)
                 ELSE 0)
          ELSE RETURN;
       ST[.SFSTE,1]<NPARMF>_.SYM;
       GENFCN(.SFSTE);)
      WHILE (SFSYNCHK_.DEL<LEFTHALF>) EQL HCOMMA;
      IF .SFSYNCHK NEQ HSEMCOL THEN RECOVER(.NDEL,ERSYMDEL);
    END;


%%
%        THE GLOBAL ROUTINES FOR MAPPING DECLARATIONS:
  (S) BIND, EXTERNAL, GLOBAL, LOCAL, MAP, OWN, AND REGISTER.  THE
  LOCAL ROUTINES "GROMLIST", "COPYINCA", AND THOSE PRECEDED BY "P" ARE
  SIMPLY USEFUL AND NEED NOT BE DECLARED GLOBAL.  GENERALLY, EACH OF THE
  MAPPING DECLARATION ROUTINES CALLS "GROMLIST" WITH A SET OF ROUTINES
  AS PARAMETERS.  GROMLIST THEN HANDLES THE COMMON SYNTAX, CALLING THE
  PASSED ROUTINES TO PROCESS THE DECLARATION SPECIFIC INFORMATION.
%
%%
  FORWARD GROMLIST, PBIND, BINDEQ;
  !EXTERNAL STRSTE,     !STRUCTURE SYMBOL TABLE INDEX
!      SIZE,       ! ALLOCATION SIZE FOR DECLARED VARIABLE
!      INCA,       ! INDEX OF INCARNATION ACTUALS
!      NUMPARS,    ! NUMBER OF EXPECTED ACTUALS
!      INCASIZE,   ! NUMBER OF INCARNATION ACTUAL CELLS
!      STE,        ! SYMBOL TABLE INDEX OF SYMBOL BEING DECLARED
!      STELIST,    ! INDEX OF LIST OF SYMBOL TABLE INDICES
!      STELAST,    ! INDEX OF LAST STELIST ELEMENT
!      STRLXS,     ! LEXEME STREAM FOR SIZE (INDEX)
!      OFLAGS;      ! SEE MACROS FOR BIT MEANINGS

  % BIT ASSIGNMENTS FOR OFLAGS %

  MACRO FBIT(A)=A,1$;
  MACRO MUSTDECLARE=FBIT(0)$,      ! DECLARATION OTHER THAN MAP
        MUSTMAP=FBIT(1)$,          ! MUST BE MAPPED
        ISSBSLEX=FBIT(2)$,         ! HAS A SIZE LEXEME STREAM
        TEMPF=FBIT(3)$,            ! TEMPORARY BOOLEAN
        WASANEQL=FBIT(4)$,         ! EQUAL FOUND FOLLOWING INCACTS
        EQLPAR=18,18$;             ! PARAM FOR EQUALS FOUND

    
  GLOBAL ROUTINE PGLO(PGTABLE, PGSIZE, PGSTE)=
    BEGIN
      GLOBAL ROUTINE SLOCAL=GROMLIST(LOCALT,NEXTLOCAL,PGLO,0,0);
      GLOBAL ROUTINE SOWN  =GROMLIST(OWNT  ,NEXTOWN,PGLO  ,0,0);
      GLOBAL ROUTINE SGLOBAL=(IF .FUTSYM EQL HEMPTY AND
                                 .FUTDEL<ADDRESSF> EQL (#777777 AND NSROUTINE<0,0>) 
                                THEN (HRUND(); DECSIMPLE(GROUTINET,3))
                                ELSE IF .FUTDEL<ADDRESSF> EQL NSBIND<0,0>
                                THEN (HRUND(); GROMLIST(BINDT,1,PBIND,-BINDEQ<0,0>,0))
                                ELSE GROMLIST(GLOBALT,NEXTGLOBAL,PGLO,0,0));

            
      %%
      %  STORE THE CURRENT TABLE INDEX IN THE ADDITIONAL INFORMATION
         WORD OF THE SYMBOL BEING DECLARED AND UPDATE THE TABLE INDEX BY THE
         LENGTH OF THE SYMBOL.
      %
      %%

      ST[.PGSTE,1]<ADDRESSF>_..PGTABLE;
      .PGTABLE_..PGTABLE+.PGSIZE;
      IF .PGTABLE NEQ NEXTLOCAL THEN DEFLOW(.PGSTE);
      0
    END;


  GLOBAL ROUTINE PEXTERNAL(IGPARAM,IGSIZE,PESTE)=
    BEGIN
      GLOBAL ROUTINE SEXTERNAL=GROMLIST(EXTRNT,0,PEXTERNAL,0,0);
      
      %%
      %   SIMPLY SET THE ADDITIONAL INFORMATION WORD TO #777777 FOR THE
          LOADER INTERFACE.
      %
      %%
 
      ST[.PESTE,1]<ADDRESSF>_#777777;
      0
    END;

  ROUTINE PREGISTER(IGPARAM,PRSIZE,PRSTE)=
    BEGIN
      ROUTINE REGEQ=
        BEGIN
          LOCAL L,M;
          L_.NSYM; %KEEP THIS IN CASE OF SEMANTIC ERRORS%
          EXPRESSION(1);
          IF .SYM EQL HEMPTY THEN SYM_LITLEXEME(0);
          IF NOT LITP(.SYM) THEN (RECOVER(.L,ERSMNOTL); RETURN 1);
          M_LITV(.SYM);
          IF (.M GEQ 16) OR (.M LSS 0)
            THEN (RECOVER(.L,ERSMINREG); RETURN 1);
          IF NOT .MODREGM<.M,1> THEN WARNEM(.L,ERSMNDEC);
          0
        END;
      GLOBAL ROUTINE SREGISTER=GROMLIST(REGT,0,PREGISTER,REGEQ,0);
    
      %%
      %   ACQUIRE THE REGISTER, INSERT IT IN THE LITERAL TABLE, AND SET
          THE ADDITIONAL INFORMATION FIELD TO THIS LITERAL TABLE INDEX.
      %
      %%
   
            IF .OFLAGS<WASANEQL>
        THEN  %DECLARE AS ABSOLUTE TYPE%
          (ST[.PRSTE,0]<TYPEF>_ABSOLUTET;
%2.17%     SYM_ST[.PRSTE,1]<ADDRESSF>_LTINSERT(0<0,36>+LITV(.SYM))+VEM)
        ELSE
          (ST[.PRSTE,1]<ADDRESSF>_LTINSERT(0<0,36>+ACQUIRE(.PRSTE+16,.PRSIZE));
          ST[.PRSTE,1]<NRF>_.PRSIZE;);
      0
    END;

GLOBAL ROUTINE WHICHBIND =
 %  THIS ROUTINE CALLS EXPRESSION AND DETERMINES
  WHICH TYPE OF EXPRESSION IT IS:

    0--CODE MUST BE GENERATED TO PRODUCE THIS RESULT;
    1--LITERAL LEXEME;
    2--GENERAL ADDRESS LEXEME.  %

  BEGIN 
    LOCAL LOCGPV,RVAL;
    PUSHGPV(0,CODEPROP)_0;
    RVAL_
      BEGIN
        EXPRESSION(1);
        IF .SYM EQL HEMPTY THEN (SYM_ZERO; 1) ELSE
          IF .CODEPROP OR ((.SYM AND (COPM+RTEM)) NEQ 0)
            THEN 0 
            ELSE 2-LITP(.SYM)
      END;
    POPGPV(0,CODEPROP);
    .RVAL
  END;
GLOBAL ROUTINE MKDUMINCA(VEC)=
  BEGIN
    LOCAL SIZE, NPARS, STVEC NEWACTS;
    MAP STVEC VEC;
    NEWACTS_GETSPACE(SIZE_((NPARS_.VEC[1]<NPARMF>)^(-1)+1));
    NEWACTS[0]<STRXF>_.VEC;
    NEWACTS[0]<PSZF>_.SIZE;
    INCR I FROM 1 TO .NPARS DO NEWACTS[.I]_1; %DEFAULT ACTUAL VALUES%
    .NEWACTS
  END;


ROUTINE PBIND(PARM,SIZE,STE)=
  BEGIN
  LOCAL TYPE;
    % BODY OF PBIND %
    ST[.STE,0]<TYPEF>_
      TYPE_CASE .OFLAGS<EQLPAR> OF SET BINDT; ABSOLUTET; LEXEMT TES;
    ST[.STE,1]<ADDRESSF>_.SYM;
        !OPAR EQL 1 <=> WE HAVE A GLOBAL BIND IN WHICH CASE THE
        !BIND EXPRESSION MUST EVALUATE TO A COMPILE TIME
        !CONSTANT FOR NOW.

  IF .OPAR THEN
    IF GLOBALCHECK(.STE) NEQ 0 THEN WARNEM(.NSYM,ERALDECGL)
    ELSE IF .TYPE EQL ABSOLUTET
      THEN
        BEGIN
          ST[.STE,0]<TYPEF>_GABSOLUTET;
          DEFGB(.STE,           !STE OF SYMBOL TO BE BOUND
                IF .ST[.STE,1]<VEF>     !GET VALUE FROM LT IF NECESSARY
                  THEN GETLITVAL(.ST[.STE,1]<LTEF>)
                  ELSE .ST[.STE,1]<LTEF>
               )
        END
      ELSE WARNEM(.NSYM,ERGBMBCTC);     !GLOBAL BIND MUST BE TO COMPILE TIME CONSTANT
    0
  END;  % OF PBIND %
    ROUTINE BINDEQ=
      BEGIN
        OFLAGS<EQLPAR>_WHICHBIND();
        CASE .OFLAGS<EQLPAR> OF
          SET

          % CODE GENERATED %
          BEGIN
            LOCAL LEFTOP;
            LEFTOP_LEXRA(.FREG);
            LEFTOP<STEF>_.NEXTLOCAL;
            LEFTOP<POSNSIZEF>_36;
            IF .CODETOG THEN (DULEX(GSTO(.LEFTOP,.SYM)); CT[.CT[.CODEPTR,1]<PREVF>,0]<RELOCF>_LOCRELOC);

            SYM_.NEXTLOCAL;  % PASS PARAM TO PBIND %
            NEXTLOCAL_.NEXTLOCAL+1
          END;

          % LITERAL %;
         
          % POINTER %
          BEGIN
            LOCAL LEXSTE;
            ST[LEXSTE_GETSPACE(1),0]_.SYM;
            ST[.LEXSTE,1]_.MAPTB;
            SYM_MAPTB_.LEXSTE
          END
          TES;
        0
      END; %OF BINDEQ %
    
    GLOBAL ROUTINE SBIND=GROMLIST(BINDT,0,PBIND,-BINDEQ<0,0>,0);

%%
%  MAP FUNCTION NOT CALLED--MAPONE CALLED FOR EVERYONE.
%
%%

%V2H%   GLOBAL ROUTINE SDECLABEL=
%V2H%     !WE HAVE SEEN A LABEL DECLARATION SO DECLARE THE FOLLOWING LIST
%V2H%     !AS LABELS.
%V2H%       GROMLIST(LABELT,0,0,0,0);


GLOBAL ROUTINE SMAP=GROMLIST(0,0,0,0,0);


%%
%     MAPONE(MPSTE:<ST INDEX OF VARIABLE BEING MAPPED>,
             MPCP: <INPUT STRING POINTER IF ERRORS>,
             MPINCA:<STE INDEX OF INCARNATION ACTUALS>,
             MPTYPE:<IF TYPE KNOWN, THEN MAP IS ALLOWED>)

  THIS ROUTINE IS CALLED TO MAP A SINGLE VARIABLE.  IF THE TYPE IS NOT SPECIFIED
   (AND THUS, THE VARIABLE IS NOT SIMULTANEOUSLY BEING DECLARED, WE MUST  INSURE:

     1. THAT THE VARIABLE MAY BE USED IN THE CURRENT CONTEXT;
     2. THAT THE TYPE OF THE VARIABLE ALLOWS IT TO BE MAPPED.


     A SYMBOL FROM AN OUTER BLOCK IS REDEFINED (VIA THE ABSOLUTET)
IN THE CURRENT CONTEXT BEFORE IT IS MAPPED.

     MAPPING ITSELF IS TRIVIAL.  WE SIMPLY SET THE STRF FIELD OF THE STE ADDITIONAL
INFORMATION WORD TO THE INDEX OF THE INCARNATION ACTUALS.

     WINDOW: UNCHANGED.
%
%%

  ROUTINE MAPONE(MPSTE,MPCP,MPINCA,MPTYPE)=
    BEGIN
      MAP STVEC MPSTE;
      IF .MPTYPE EQL 0
        THEN
          BEGIN
            IF NOT CHKULA(.MPSTE) OR NOT MAPPABLE((.MPSTE[0]<TYPEF>))
              THEN (RECOVER(.MPCP,ERSMNOMAP); RETURN 1);
            IF .BLOCKLEVEL NEQ .MPSTE[0]<BLF>
              THEN MPSTE_DECSYQ(.MPSTE,ABSOLUTET,LSM+.MPSTE)
          END; % NO ELSE PART %
      MPSTE[1]<STRF>_.MPINCA;
      0
    END;

%%
%     UNMAP SIMPLY RELEASES ALL THE LEXEME TYPE ENTRIES FOR
  SYMBOLS AT THE CURRENT BLOCKLEVEL.
%
%%

GLOBAL ROUTINE UNMAP=
  BEGIN
    REGISTER TEMP;

    WHILE .MAPTB NEQ 0 DO
      (TEMP_.ST[.MAPTB,1];
       RELEASESPACE(.MAPTB,1);
       MAPTB_.TEMP);
  END;



%%
%    GROMLIST(GRLTYPE:<TYPE OF SYMBOL TO BE DECLARED>,
              GRLPARAM:<PARAMETER PASSED TO GRLFUN>,
              GRLFUN:<ROUTINE TO PROCESS DECLARATION SPECIFIC INF.>,
              GRLEQL:<ROUTINE TO PROCESS "=">,
              GRLASS:<ROUTINE TO PROCESS "_">)

  THIS ROUTINE:

    1. DECLARES EACH VARIABLE WITH NON-ZERO TYPE (GRLTYPE);
    2. MAPS EACH VARIABLE WHICH MUST BE MAPPED;
    3. PASSES EACH VARIABLE TO THE PARAMETER ROUTINE (GRLFUN).
%
%%
  FORWARD STARTNAME, STARTCOL, CONTIDLIST, DOSIZE, ENDIDBATCH, DOEQL;
  ROUTINE GROMLIST(GRLTYPE,GRLPARAM,GRLFUN,GRLEQL,GRLASS)=
    BEGIN

!     MACRO CHECK(A)=IF A() THEN RETURN$;
      OTYPE_.GRLTYPE;
      OPAR_.GRLPARAM;
      OFUN_.GRLFUN;
      OEQL_.GRLEQL;
      OASS_.GRLASS;
      OFLAGS<MUSTDECLARE>_.GRLTYPE NEQ 0;

      DO % UNTIL NO COMMA %
        (CHECK(STARTNAME);
         DO % UNTIL NO OUTER COLON %
           (CHECK(STARTCOL);
            WHILE .FUTDEL<LEFTHALF> EQL HCOLON DO (CHECK(CONTIDLIST));
            CHECK(DOSIZE);
            CHECK(DOEQL);
            CHECK(ENDIDBATCH);)
         WHILE .DEL<LEFTHALF> EQL HCOLON;)
      WHILE .DEL<LEFTHALF> EQL HCOMMA;

      IF .DEL<LEFTHALF> NEQ HSEMCOL THEN RETURN RECOVER(.NDEL,ERSYMGRLD);
    END;


%%
%    STARTNAME:  WE FIRST SET UP THE STRUCTURE STE IF THE STRUCTURE
  IS SPECIFIED--THERE IS AN ERROR LEXEME IN FUTDEL, USING THE ASSUMED
  "VECTOR" STRUCTURE IF NOT.  WE KNOW AT THIS POINT WHETHER WE MUST MAP THIS
  STRING OF IDS; IF:

    1. A STRUCTURE WAS SPECIFIED EXPLICITLY;
    2. FUTURE DELIMITER IS A COLON OR OPEN BRACKET;
    3. THE DECLARATION IS A MAP DECLARATION--IN PARTICULAR,
       "MAP A;" = "MAP VECTOR A;".

  WE THEN SET THE OWNS RELEVANT TO THE STRUCTURE ONLY (IF THE SYMBOLS ARE
  TO BE MAPPED), NAMELY:

    1. THE FLAG FOR THE LEXEME STREAM TYPE (SIMBITS);
    2. THE STRUCTURE LEXEME STREAM INDEX;
    3. THE INCARNATION ACTUALS CELL BLOCK-SIZE;
    4. THE NUMBER OF EXPECTED INCARNATION ACTUALS.
%
%%

  ROUTINE STARTNAME=
    BEGIN
      REGISTER TEMP;
            
      % WINDOW: (XXX,"SLOCAL",STRUCTURE-NAME,HERRLEX) OR
                (XXX,"SLOCAL",FIRST-ID,(";"/":"/"["/",")) %

      IF .REALFS EQL 0 THEN (RECOVER(.NFUTSYM,ERSYNAME); RETURN 1);

      IF .FUTDEL EQL HERRLEX
        THEN IF .ST[STRSTE_.REALFS,0]<TYPEF> NEQ STRT
          THEN (RECOVER(.NFUTSYM,ERSMNOTSTR); RETURN 1)
          ELSE (OFLAGS<MUSTMAP>_1; HRUND();)
        ELSE (STRSTE_.PTOVECTOR; OFLAGS<MUSTMAP>_0;);

      IF OFLAGS<MUSTMAP>_
          .OFLAGS<MUSTMAP> OR
          (TEMP_.FUTDEL<LEFTHALF>; .TEMP) EQL HCOLON
          OR .TEMP EQL HSQOPEN OR
          NOT .OFLAGS<MUSTDECLARE>

        THEN
          (TEMP_.ST[.STRSTE,1];
           OFLAGS<ISSBSLEX>_.TEMP<SIMBITSF>;
           STRLXS_.TEMP<LXTESF>;
           INCASIZE_(NUMPARS_.TEMP<NPARMF>)^(-1)+1;); % NO ELSE %
      
      0
    END;


%%
%    MAYBEDECLARE DECLARS THE SYMBOL IN FUTSYM IF IT SHOULD BE
  (.GRLTYPE IS NON-ZERO), AND RETURNS THE VALUE 1 IF THERE WERE
  ERRORS.
%
%%

  ROUTINE MAYBEDECLARE=(IF .OFLAGS<MUSTDECLARE>
                              THEN NOT DECSYN(STE,.OTYPE)
                              ELSE (STE_.REALFS; 0));

%%
% STARTCOL TAKES THE ID IN FUTSYM, DECLARES IT IF
  NECESSARY AND PUTS IT AS THE FIRST ELEMENT ON THE STELIST.
%
%%

  ROUTINE STARTCOL=
    BEGIN
      REGISTER TEMP;
      IF MAYBEDECLARE() THEN RETURN 1;
      (TEMP_ST[STELAST_STELIST_GETSPACE(1),0])<STELSTEF>_.STE;
      (.TEMP+1)<STELCPF>_.NFUTSYM;
      0
    END;

%%
%    CONTIDLIST SIMPLY DOES A RUND AND DECLARES THE SYMBOL IN FUTSYM
  (IF NECESSARY).  IT THEN PUTS THE DECLARED SYMBOL ON THE STE LIST.

  WINDOW: (XXX,XXX,ID,":");
  WINDOW OUT: (ID,":",NEXTID,(":"/"["/","/";")).
%
%%

  ROUTINE CONTIDLIST=
    BEGIN REGISTER TEMP;
      HRUND();
      IF MAYBEDECLARE() THEN RETURN 1;
      ST[.STELAST,0]<STELNEXTF>_TEMP_GETSPACE(1);
      (TEMP_ST[STELAST_.TEMP,0])<STELSTEF>_.STE;
      (.TEMP+1)<STELCPF>_.NFUTSYM;
      0
    END;


%%
%    DOSIZE: WINDOW (XXX,XXX,LAST-ID,("["/","/";"))

  SET ASSUMED SIZE TO 1.  IF WE MUST MAP THE SYMBOL, WE MUST
  CREATE A SET OF INCARNATION ACTUALS.  HENCE, WE SET UP A PROTOTYPE
  INCARNATION ACTUALS AREA (WHOSE INDEX IS "INCA") AND DEFAULT ALL OF THEM
  TO 1.  WE THEN CHECK TO SEE IF A SIZE-LIST WAS SPECIFIED.  IF SO, WE
  FILL THE INCARNATION ACTUALS SUCCESSIVELY, UNTIL WE RUN OUT OF EXPRESSIONS,
  OR ATTEMPT TO GIVE TOO MANY ACTUALS.  WE THEN GET THE SIZE FROM THE SIZE EXPRESSION ON THE
  STRUCTURE DECLARATION (IF SPECIFIED).  OTHERWISE, WE USE THE PRODUCT OF THE SPECIFIED INCARNATION
  INCARNATION ACTUALS.

  WINDOW OUT: (LASTSIZE,"]",EMPTY(CHECKED),(":"/";"/",")) OR WINDOW IN.
%
%%

  FORWARD GSSA;
  ROUTINE DOSIZE=
    BEGIN
      LOCAL KEEPSTSIZE;
              REGISTER TEMP;
      SIZE_1;
      IF NOT .OFLAGS<MUSTMAP> THEN RETURN 0;

      % SET UP EMPTY INCARNATION ACTUALS AREA %
      (TEMP_ST[INCA_GETSPACE(.INCASIZE),0])<PSZF>_.INCASIZE;
      (.TEMP)<STRXPF>_.STRSTE;

      % PUT THE ACTUALS IN WHILE THE SIZE IS SPECIFIED, PUT DEFAULT OF
        1 IN WHEN NOT. %
      
      IF OFLAGS<TEMPF>_(.FUTDEL<LEFTHALF> EQL HSQOPEN) THEN HRUND();

      INCR I FROM 1 TO .NUMPARS DO
        IF .OFLAGS<TEMPF>
          THEN
            (HRUND();
             KEEPSTSIZE_.NSYM;
             EXPRESSION(1);
             IF NOT LITP(.SYM) THEN (RECOVER(.KEEPSTSIZE,ERSMSIZE); RETURN 1);
             SIZE_.SIZE*LITV(.SYM);
             (.TEMP+.I)_.SYM;
             IF .DEL<LEFTHALF> EQL HSQCLO
               THEN (OFLAGS<TEMPF>_0;
                     IF .FUTSYM NEQ HEMPTY THEN (RECOVER(.NFUTSYM,ERSYMGRLD); RETURN 1);)
               ELSE IF .DEL<LEFTHALF> NEQ HCOMMA
                 THEN (RECOVER(.NDEL,ERSYMRBRAC); RETURN 1);)
          ELSE (.TEMP+.I)_1; % END OF DO %

      % PULSE PAST REMAINING (EXTRA) ACTUALS %

      IF .OFLAGS<TEMPF>
        THEN
          (WARNEM(.NFUTSYM,ERSMEXPAR);
           DO
             (HRUND();
              KEEPSTSIZE_.NSYM;
              EXPRESSION(1);
              IF NOT LITP(.SYM) THEN (RECOVER(.KEEPSTSIZE,ERSMSIZE); RETURN 1);)
           WHILE (TEMP_.DEL<LEFTHALF>) EQL HCOMMA;
          IF .TEMP NEQ HSQCLO THEN (RECOVER(.NDEL,ERSYMRBRAC); RETURN 1);
          IF .FUTSYM NEQ HEMPTY THEN (RECOVER(.NFUTSYM,ERSYMRBRAC); RETURN 1););

      % WINDOW: (SIZE, "]", EMPTY, (":"/","/";"))
        WE MUST NOW DETERMINE THE SIZE FROM THE LEXEME STREAM, IF
        NECESSARY.  %

      IF NOT .OFLAGS<ISSBSLEX> OR .STRLXS EQL 0 THEN RETURN 0;

      % NOTE--SIZE DECLARATION MAY HAVE TO FUDGE ";" ON END %
      GSSA(0,.INCA,.STRSTE,0,.NFUTSYM);SYM_GENCODE(.SYM,2);
     IF NOT LITP(.SYM) THEN (RECOVER(.KEEPSTSIZE,ERSMSIZE); RETURN 1);
      SIZE_LITV(.SYM);
    0
    END;

%%
%  ENDIDBATCH: PROCESS THE LIST OF STES BY:
    1. MAPPING EACH VARIABLE THAT MUST BE MAPPED;
    2. CALLING THE PASSED FUNCTION TO PROCESS THE DECLARATION
       SPECIFIC INFORMATION.  CALL FORMAT:

       (@OFUN)(<USER PARAMETER>, <DECLARATION SIZE>, <STE INDEX OF SYMBOL>)
%
%%

  FORWARD COPYINCA;
  ROUTINE ENDIDBATCH=
    BEGIN REGISTER TEMP;
      DO
        (IF .OFLAGS<MUSTMAP> 
            THEN
             (IF MAPONE(STE_.ST[.STELIST,0]<STELSTEF>,
                        .ST[.STELIST,1]<STELCPF>, .INCA, .OTYPE) THEN RETURN 1;);
        
%V2H%   !IF WE HAVE A LABEL TYPE ID, NO FURTHER DECLARATION IS NECESSARY
%V2H%         IF .OFLAGS<MUSTDECLARE> THEN IF .OTYPE NEQ LABELT THEN (IF (@OFUN)(.OPAR,.SIZE,.STE) THEN RETURN 1;);)
      WHILE
        (TEMP_.STELIST;
         STELIST_.ST[.TEMP,0]<STELNEXTF>;
         RELEASESPACE(.TEMP,1);
         IF .TEMP NEQ .STELAST
           THEN (COPYINCA(); 1)
           ELSE 0);

      IF NOT .OFLAGS<WASANEQL> THEN HRUND();

      % WINDOW: (XXX,":",ID,("["/":"/","/";")) OR
                (XXX,",",ID,(HERRLEX/":"/","/"["/";")) OR
                (XXX,";",XXX,XXX) %
      
      0
    END;
%%
%   THE EQUAL SIGN IS HANDLED BY THE "OEQL" PARAMETER.
  IF IT IS NON-ZERO, AN EQUAL SIGN IS PERMISSABLE.  IF IT IS NEGATIVE,
  AN EQUAL SIGN IS NECESSARY (E.G. IN BIND).  THE PROCESSING ROUTINE
  MUST RETURN AN ERROR BOOLEAN--1 IF ERRORS.  THE ROUTINE IS PASSED
  THE SINGLE PARAMETER "OPAR".  THE DECLARATION PROCESSING ROUTINE
  MAY COUNT ON THE VALUE OF SYM NOT CHANGING BETWEEN THE EQUAL
  PROCESSING AND THE DECLARATION ROUTINE ITSELF.  THE ROUTINES MAY
  LATER TEST "OFLAGS<WASANEQL>" TO SEE IF THERE WAS ONE (I.E. IT
  DOES NOT HAVE TO SAVE THE INFORMATION ITSELF.
%
%%

  ROUTINE DOEQL=
    BEGIN
      REGISTER R;
      IF R_OFLAGS<WASANEQL>_(.OEQL NEQ 0) AND 
         (.FUTDEL<LEFTHALF> EQL HEQL)
        THEN (HRUND(); HRUND(););
    
      CASE (.R^1)+(.OEQL LSS 0) OF
        SET
          0;    !NO EQUALS AND DID NOT NEED ONE
          (RECOVER(.NFUTDEL,ERSYMEQ); 1); !NO EQUALS AND NEEDED ONE
          (@OEQL)(.OPAR);  !OPTIONAL EQUAL
          (-.OEQL)(.OPAR)  !REQUIRED EQUAL
        TES
    END;
%%
%   CHKULA(STEINDEX: <INDEX OF SYMBOL WHOSE ADDRESSING IS TO BE CHECKED>)
       =1 IF THE SYMBOL IS A FORMAL, STRUCTURE FORMAL, LOCAL, OR FUNCTION AND
           IS ADDRESSABLE;
       =0 IF ONE OF THE ABOVE TYPES AND NOT ADDRESSABLE (EVEN THROUGH THE DISPLAY).

     WE SIMPLY TEST THOSE SYMBOLS WITH THE ABOVE TYPES TO INSURE THAT THEIR BLOCKLEVEL
   IS GREATER THAN OR EQUAL TO TRBLEVEL--THE BLOCKLEVEL OF THE MOST RECENT ROUTINE
   DECLARATION.
%
%%

GLOBAL ROUTINE CHKULA(STEINDEX)=
  BEGIN
    MAP STVEC STEINDEX;
    MACRO RET(PRED)=IF PRED THEN RETURN 1$;
    RET( NOT (1^LOCALT+1^FORMALT+1^FUNCT+1^STRFPT+1^BINDT)^(-.STEINDEX[0]<TYPEF>));
    RET(.TRBLEVEL LSS .STEINDEX[0]<BLF>);
    IF .STRDEF THEN
      (SERRPOS_.NSYM;
       SERRSTE_.STEINDEX;
       RETURN 1);
    0
  END;


%%
%    THE FOLLOWING ROUTINES ARE USED FOR SETTING UP FOR A LEXEME COPY
  (EITHER SIZE OR ACCESS) AND FOR STOPPING SUCH A COPY--STRSCOPY AND
  STRECOPY RESPECTIVELY.  THE FIRST MERELY STICKS IN AN EXTRA LEFT PARENTHESIS
  AS THE FIRST WORD OF THE EXPRESSION.  THE SECOND INSERTS AN EXTRA RIGHT PAREN.
  RELSTRLIST(LXTI:<INDEX OF FIRST CELL ON THE LIST>) RELEASES A LEXEME STREAM 
  FROM LXT.

     THE FORMER SETS CSTI AND RETURNS THE NEW CELL INDEX AS ITS VALUE.
%
%%

ROUTINE STRSCOPY(NPS)=
  BEGIN
        CSTIL_CSTI_GETSPACE(2);
    LXT[.CSTI,0]_-1;
    LXT[.CSTI,1]_0;
    LXT[.CSTI,2]_0;
    LXT[.CSTI,3]_0;
    IF .STRDEF<TACCESS>
      THEN
        (STRDEF<LEFTHALF>_GETSPACE((.NPS^(-1))+1);
        STRDEF<NPF>_.NPS);
    WRUND2();
    IF .CSTI NEQ .CSTIL THEN (RELEASESPACE(.CSTIL,2); CSTIL_.CSTI);
    .CSTI
  END;

ROUTINE STRECOPY=
  BEGIN
        RELEASESPACE(.CSTI,2);
    LXT[.CSTIL,1]_0;
    LXT[.CSTIL,3]_.LXCLOA;
  END;

GLOBAL ROUTINE RELSTRLIST(LXTI)=
  BEGIN
    REGISTER TOGO, NEXTTOGO;
    NEXTTOGO_.LXTI;
    WHILE (TOGO_.NEXTTOGO) NEQ 0 DO
      (NEXTTOGO_.LXT[.NEXTTOGO,1]; RELEASESPACE(.TOGO,2););
  END;


%%
%  GSSA(ACTUALS:<STE INDEX OF ACTUALS BLOCK>,
        INCACTS:<STE INDEX OF INCARNATION ACTUALS BLOCK>,
        STRUCT:<STE INDEX OF STRUCTURE BEING EXPANDED>,
        ACCESS:<0--SIZE EXPANSION, 1--ACCESS EXPANSION>,
        CHARPT:<POINTER TO INPUT STRING ERROR POSITION THROUGHOUT GENERATION>)

      SAVE THE STRUCTURE ACCESSING LEXEME GENERATION VARIABLES, NAMELY:
  SSTREX, STREXP, CURSTE, CURSTAP, CURSTIP, CURSTNP ALONG WITH FUTSYM, FUTDEL,
  NFUTSYM, AND NFUTDEL WHICH WILL HAVE CHANGED THROUGH THE EXPANSION.  WE
  THEN INITIALIZE THE SAME VARIABLES TO THE DEFAULTS MENTIONED BELOW;

     NOTE: THE NEXT HRUND WILL PRETEND THE LXT LEXEME STREAM WAS IN FUTSYM
  AND FUTDEL.
%
%%

GLOBAL ROUTINE GSSA(ACTUALS, INCACTS, STRUCT, ACCESS, CHARPT)=
  BEGIN
        REGISTER L;
    ST[L_GETSPACE(6),0]_.SSTREX;
    ST[.L,1]_.STREXP;
    ST[.L,2]_.CURSTE;
    ST[.L,3]_.CURSTAP;
    ST[.L,4]_.CURSTIP;
    ST[.L,5]_.CURSTNP;

    ST[.L,8]_IF .REALFS NEQ 0 THEN .REALFS+LSM ELSE .FUTSYM;
    ST[.L,9]_.FUTDEL;
    ST[.L,10]_.NFUTSYM;
    ST[.L,11]_.NFUTDEL;

    % DEFAULTS %
    SSTREX_.L;
    STREXP_1+(1-.ACCESS)^1;
    CURSTE_(IF .ACCESS THEN .ST[.STRUCT,1]<LXTEAF> ELSE .ST[.STRUCT,1]<LXTESF>);
    CURSTAP_.ACTUALS;
    CURSTIP_.INCACTS;
    CURSTNP_.ST[.STRUCT,1]<NPARMF>;
    NFUTSYM_NFUTDEL_.CHARPT;
    SYM_DEL_FUTSYM_FUTDEL_0; %NO SIDE EFFECTS FROM HRUND %
    HRUND(); HRUND(); EXPRESSION(0);
  END;



%%
%   COPYINCA()--GET MORE SPACE, PUT ADDRESS INTO INCA AND COPY THE
    OLD LIST OVER.
%
%%
  ROUTINE COPYINCA=
    BEGIN
      REGISTER R;
      LOCAL MAX;
      INCA_GETSPACE(MAX_.ST[R_.INCA,0]<PSZF>);
      INCR I FROM 0 TO 2*.MAX-1 DO
        ST[.INCA,.I]_.ST[.R,.I];
    END;


%%
%    THE FOLLOWING DECLARATIONS PROCESS:
       SWITCHES,
       AND MODULE HEAD.
%
%%



MACRO BS(NUM,STR)=('STR' OR ((-1)^(-7*NUM))) AND (-2)$,
        BL(STR)='STR' AND (-2)$;

BIND SWTBL=PLIT (

  BL(EXPAN) %D%,
  BL(NOEXP) %AND%,
  BS(4,LIST),
  BL(NOLIS) %T%,
  BS(4,ERRS),
  BL(NOERR) %S%,
  BL(MLIST),
  BL(NOMLI) %ST%,
  BL(INSPE) %CT%,
  BL(NOINS) %PECT%,
  BL(OPTIM) %IZE%,
  BL(NOOPT) %IMIZE%,
  BL(GLORO) %UTINES%,
BL(NOGLO) %ROUTINES%,
  BL(TIMIN) %G%,
  BL(NOTIM) %ING%,
  BL(DOLLA) %R%,

  % END OF COMMON SWITCHES , MODIFY BOTH "SWSWL" AND "ALLSWL" IN GLOBALS.
 BEGIN MODULE SWITCHES ONLY %

  BL(TIMER),
  BL(RESER) %VE%,
  BS(3,CCL),
  BL(DREGS),
  BS(4,SREG),
  BS(4,BREG),
  BS(4,FREG),
  BS(4,VREG),
  BL(STACK),
  BL(SYNTA) %X%,
  BL(HISEG),
  BL(LOWSE) %G%,
  BL(RSAVE),
  BL(NORSA) %VE%,
  BL(ENTRI) %ES%

  % END OF SWITCHES, MODIFY "ALLSWL" (ONLY) IN GLOBALS. % );


%       ROUTINE TO SWITCH SCANNER TO ACCEPT A $ IN AN ID AND
        TO USE & FOR MACRO TERMINATOR
%
ROUTINE SWDOLLR=
BEGIN
   MACTRM_"&";
   TYPETAB["$"]_2;
   TYPETAB["&"]_7
END;

GLOBAL ROUTINE SWITCHER(HIGH)=
    BEGIN
    MACRO SYCHK(X)=IF X THEN RETURN 1$;
    REGISTER X;
    DO  % UNTIL DEL IS NOT A COMMA %
        BEGIN
        IF .REALFS EQL 0 
            THEN (RETURN 1)
            ELSE X_.ST[.REALFS,2];
        HRUND();   !SWITCH NAME NOW IN SYM
        X_INCR I FROM 0 TO .HIGH DO IF .X EQL .SWTBL[.I] THEN BREAK .I;
        CASE 1+.X OF
            SET
%ERROR%             RETURN 3;           ! ERROR, NOT FOUND
%EXPAND%            EMFLG_1;            ! EXPAND MACRO
%NOEXPAND%          EMFLG_0;            ! DON'T EXPAND MACRO
%2.14%  %LIST%  IF.(NAME+1)<0,36> NEQ 0 THEN LSTFLG_0;  !LIST
%NOLIST%            LSTFLG_1;           ! NO LIST
%ERRS%              ERRBIT_0;           ! ERR MSGS TO TTY
%NOERRS%            ERRBIT_1;           ! NO ERR MSGS TO TTY
%MLIST%             MLFLG_1;            ! MACH LIST
%NOMLIST%           MLFLG_0;            ! NO MACH LIST
%INSPECT%           LUNDEFLG_1;         ! INSPECT
%NOINSPECT%         LUNDEFLG_0;         ! NO INSPECT
%OPTIMIZE%          NPTFLG_0;           ! OPTIMIZE
%NOOPTIMIZE%        NPTFLG_1;           ! NO-OPTIMIZE
%GLOROUTINES%       GRFLG_1;            ! LOCAL ROUTINES DECLARED GLOBAL
%NOGLOROUTINES%     GRFLG_0;            ! LOCAL ROUTINES STAY LOCAL
%TIMING%            TTFLAG_.MHTIME;     ! SET TIMING FLAG ON
%NOTIMING%          TTFLAG_0;           ! SET TIMING FLAG OFF
%DOLLAR%            SWDOLLR();          ! SET SCANNER FOR $ IN ID
%%
%
        END OF COMMON SWITCHES
%
%%
%TIMER%             SYCHK((PSWTIM()));  ! PROCESS TIMER DECL
%RESERVE%           SYCHK((PSWRES()));  ! RESERVE SPECIFIC REGS.
%CCL%               CCLFLAG_1;          ! GENERATE CCL LINK CODE
%DREGS%             SYCHK((PSWSAV()));  ! NO DECLARABLE REGS.
%SREG=%             SYCHK((PSWSPC(0))); ! DEFINE SREG
%BREG=%             SYCHK((PSWSPC(1))); ! DEFINE BREG
%FREG=%             SYCHK((PSWSPC(2))); ! DEFINE FREG
%VREG=%             SYCHK((PSWSPC(3))); ! DEFINE VREG
%STACK%             SYCHK((PSWSTK()));  ! DEFINE STACK
%SYNTAX%            CODETOG_0;          ! SYNTAX CHECK ONLY
%HISEG%             (HGHFLG_1; TWOSEGFLG_0);           ! HIGH SEGMENT 
%LOWSEG%            (HGHFLG_0; TWOSEGFLG_0);           ! LOW SEGMENT
%RSAVE%             SVERGFLG_1;         ! SAVE/RESTORE REGISTERS AT EXCHJ
%NORSAVE%           SVERGFLG_0;         ! NO SAVE/RESTORE AT EXCHJ
%ENTRIES%           SYCHK((PSWENT()));  ! ENTRY LIST
            TES;
        END UNTIL .DEL<LEFTHALF> NEQ HCOMMA;

    END;


ROUTINE SSWITCHES=
    BEGIN LOCAL X;
    X_SWITCHER(SWSWL);
    IF .X THEN RECOVER(.NFUTSYM,#600+.X) ELSE
    IF .DEL<LEFTHALF> NEQ HSEMCOL THEN RECOVER(.NDEL,#602)
    END;


GLOBAL ROUTINE SMODHEAD=
  BEGIN
    REGISTER R;
    R_.NDEL;
    HRUND();
    RECOVER(.R,ERSYINVMDEC);
  END;
ROUTINE H1RFS(RFSTE,L2,RFSTRB) =
        BEGIN

            IF .CODETOG THEN
              (ACPR1(); ! [SEE E]
              PUSHCODE(););
  
            % COMPILE THE BODY AND CONVEY THE VALUE/NO VALUE TO
              THE CODE GENERATORS.  WINDOW HERE: (<EMPTY>,"=",...)%

            HRUND(); ! WINDOW: (<BODY SYM 1>,<BODY DEL 1>,...)
            EXPRESSION(1); ! WINDOW: (<BODY LEXEME>,";",XXX,XXX)
            IF .CODETOG THEN CONVEY(.SYM);

% NOTE: STRUCTURES ARE PROCESSED BY COPYING THE LEXEME STREAM
  FOR THE STRUCTURE AND AT THE SAME TIME GENERATING CODE
  FOR THE BODY.  THE CODE IS KEPT IF ANY DECLARATIONS ARE NECESSARY,
  THE CONDITION FOR A BLOCK.  THE LEXEME SCAN IS TURNED OFF IF
  A BLOCK IS DECLARED.  HENCE, AT THIS POINT WE MUST FIX UP MACRO
  TYPE STRUCTURES, BY:

   1.  ERASING THE CODE GENERATED FOR THE STRUCTURE;
   2.  RELEASING THE FUNCTION HEADER FROM FCNLIST;
   3.  SETTING THE STE TO INDICATE A MACRO-TYPE STRUCTURE.  %

            % CHECK FOR STRUCTURE OF MACRO-TYPE: %

            IF .RFSTRB THEN
              (IF .STRDEF
                 THEN (IF .CODETOG THEN (ERASE(.L2); CLEARRTGT());
                       ST[.RFSTE,1]<SIMBITAF>_1;
                       ST[.RFSTE,1]<LXTEAF>_.CURST;
                       STRECOPY();
                       RETURN 1;)
                 ELSE RELSTRLIST(.CURST));
        0
        END;


% END OF DECLARE MODULE %
  1 h