LOCAL %ITEMTYP,%NUMTYP,%SIXTYP,%TYP,%OCTWDTYP,%CENTTYP,%CHRTYP
FIND TOKEN(0),%INIT.TTY,%GET.NUM,%NUM.OUT,%SIX.OUT,%OCT.OUT,%OCTWD.OUT
FIND %CHR.OUT,%OUT,%GETTOKEN,%CHOOSE,%LISTABLE,%MAKESIXBIT
FIND   CHOUT,P,NUMBER
FIND PROMPT:

!THE FOLLOWING MACRO COMPUTES A GENERAL BYT POINTER SO THAT NCHV ON
!THE PDP-10 WILL DO ILDB'S FOR ANY BYTE SIZE
DEF BYPT(Y,P1,S) AS [6,6,6,18]*[IF P1>=0 THEN 36-S*(P1 MOD(36/S)-1)&
	ELSE 36-S*(36/S-(-P1)MOD(36/S)+1),S,0,&
	IF P1>=0 THEN Y+P1/(36/S) ELSE Y+(P1+1)/(36/S)-1]
DEF NBYV AS NCHV
DEF BYV AS CHV
GLOBAL WD(0:31),I,J,K,F
GLOBAL CMD,FIRST,LAST,%FAST,%LIST,%CENTOUT,%X,ITEM,LITEM
GLOBAL %RDREC,%WREC,Q,%ITEMOUT,SYSNO

DEF B AS CHROUT($ )  !BLANK TO TEL OR FILE  (SEE CH.OUT)
DEF C AS CHROUT(CARRET)
DEF CTYP AS CHRTYP(CARRET)


%FAST(K)
LOCAL I,J,TOT

RDREC(K)  !READ REQ K

[6,6,6,BITS.PER.WORD-18]*[,I,J,] _ WD(0)   !GET 1ST TWO DIGITS OF WD(0)
IF (I-OCT 20)*10 + J-OCT 20 # SYSNO AND SYSNO#0 THEN &
 [NUMOUT(SYSNO); OUT(' NOT SYS NO.$')]  !PPRACT SYSNO DOESN'T MATCH
SIXOUT(@WD(0),6); B         !BATCH REQ # & BLANK
SIXOUT(@WD(1),12); B         !DATE AND TIME   & B
SIXOUT(@WD(3),12); C         !USER NAME
OCTWDOUT(WD(5)); B            !PPN    GAN,UUN
SIXOUT(@WD(6),18); C        !PROJECT CODE
IF WD(9)=0 THEN OUT(' IN') ELSE IF WD(9)=1 THEN OUT('OUT') ELSE OUT('???')
B
IF WD(10)=0 THEN B ELSE IF WD(10)=$* THEN CHROUT($*) ELSE CHROUT($?)
OUT('$')
J _ WD(OCT 14)
NUMOUT(J); OUT(' JOB TYPE(S)$')   !NUMBER OF TYPES OF WORK
TOT _ 0    !INIT TOTAL CHARGES FOR RECORD
FOR I _ OCT 15 TO OCT 12+3*J BY 3 DO
 OCTWDOUT(WD(I)); B          !TYPE , VOLUME
 IF BYT(WD(I),18,18)=1 THEN OCTWDOUT(WD(I+1)) ELSE NUMOUT(WD(I+1)); B
 NUMOUT(WD(I+2)); TOT+_WD(I+2); OUT('$')
END
OUT('$')
IF TOT < 500 THEN TOT _ 500
FOR K _ I+3 TO OCT 31 IF WD(K) # 0 THEN DO
        OUT('JUNK IN ITEM ')
        ITEMOUT(5*K/3-13)
        C
                                        END   !FOR K _ I+3 ETC.
NUMOUT(WD(OCT 34)); B        !POSTAGE
NUMOUT(WD(OCT 35)); B         !TOTAL
IF TOT+_WD(OCT 34) # WD(OCT 35) THEN [OUT('$ERR IN TOTAL ');NUMOUT(TOT)&
;OUT('$$')]
SIXOUT(@WD(OCT 36),6); B    !DATE COMPLETED
OCTOUT(WD(OCT 37)); OUT('$$')   !POINTER TO NEXT RECORD IN SAME PROJECT
RETURN
END FAST
%LIST(K)   !GIVE A SLOW LIST OUT FOR RECORD K
LOCAL I,J,TOT,L,M

RDREC(K)   !READ BATCH REQ. K INTO CORE

[6,6,6,BITS.PER.WORD-18]*[,I,J,] _ WD(0)   !GET 1ST TWO DIGITS OF WD(0)
IF WD(0)=0 THEN IF FIRST=LAST THEN [NUMOUT(K); OUT(' NOT ENTERED'); GO PROMPT] &
 ELSE RETURN
IF (I-OCT 20)*10 + J-OCT 20 # SYSNO THEN &
 [SIXOUT(@WD(0),3); MSG(' + 3 DIGITS NEEDED$'); GO PROMPT]
C; ITEMOUT(Q_0); OUT('REQ # ');SIXOUT(@WD(0),6); C         !BATCH REQ # & BLANK
ITEMTYP(INC Q); TYP('DATE/TIME ');SIXTYP(@WD(1),12); CTYP
ITEMTYP(INC Q); TYP('USERNAME ');SIXTYP(@WD(3),12); CTYP      !USER NAME
ITEMTYP(INC Q); TYP('PPN ');OCTWDTYP(WD(5)); CTYP            !PPN    GAN,UUN
ITEMTYP(INC Q); TYP('PROJ CODE ');SIXTYP(@WD(6),18); CTYP        !PROJECT CODE
ITEMTYP(INC Q); IF WD(9)=0 THEN TYP('INHOUSE') ELSE IF WD(9)=1 THEN TYP('CUSTOMER') &
ELSE TYP('ERROR, MAKE THIS INHOUSE OR CUSTOMER')
INC Q  !THIS WORD NO LONGER USED, NOT AN EDITABLE ITEM EITHER
TYP('$')
J _ WD(OCT 14)
ITEMTYP(INC Q); TYP('JOB TYPES '); NUMTYP(J); CTYP !NUMBER OF TYPES OF WORK
TOT _ 0    !INIT TOTAL CHARGES FOR RECORD
FOR I _ OCT 15 TO OCT 12+3*J BY 3 DO
C
[18,18]*[L,M] _ WD(I)
ITEMTYP(INC Q); TYP('TYPE '); NUMTYP(L); CTYP
IF L = 224233 THEN [TYP('$VOID$'); GO VOID]   !VOID IN 6BIT IS 224233
ITEMTYP(INC Q); TYP('VOL. '); NUMTYP(M); CTYP
IF L=1 THEN DO
 [18,18]*[L,M] _ WD(I+1)
 ITEMTYP(INC Q);  TYP('PARTS '); NUMTYP(L); CTYP
 ITEMTYP(INC Q);  TYP('DECOLLATED '); NUMTYP(M); CTYP
            END ELSE DO
 ITEMTYP(INC Q); INC Q;  TYP('OTHER CHRG ')
  CENTTYP(WD(I+1))
  CTYP
                     END
ITEMTYP(INC Q); TYP('COST '); CENTTYP(WD(I+2)); CTYP
TOT+_WD(I+2)
END
VOID: TYP('$')
IF TOT < 500 THEN TOT _ 500
FOR K _ I+3 TO OCT 31 IF WD(K) # 0 THEN DO
        ITEMTYP(5*K/3-13)
        TYP('THRU ')
        ITEMTYP(32)
        TYP('SHOULD ALL BE MADE ZERO TO BE CONSISTENT WITH$')
        ITEMTYP(7)
        TYP('JOB TYPES ')
        NUMTYP(WD(OCT 14))
        CTYP; CTYP
                                        END  !FOR K _ I+3 ETC.
ITEMTYP(Q_33);  TYP('POSTAGE '); CENTTYP(WD(OCT 34)); CTYP
ITEMTYP(INC Q); TYP('TOTAL '); CENTTYP(WD(OCT 35)); CTYP
IF TOT+_WD(OCT 34) # WD(OCT 35) THEN [TYP('$ERR IN TOTAL ');CENTTYP(TOT)&
;TYP('$$')]
ITEMTYP(INC Q); TYP('COMPLETED ')
I _ BYPT(@WD(OCT 36),-1,6)     !BYTE POINTER SET-UP FOR SIXBIT
CHRTYP($ + NBYV I)
CHRTYP($ + NBYV I)
CHRTYP($-)
CHRTYP($ + NBYV I)
CHRTYP($ + NBYV I)
CHRTYP($-)
CHRTYP($ + NBYV I)
CHRTYP($ + NBYV I)
CTYP
ITEMTYP(INC Q); TYP('PTR ');NUMTYP(WD(OCT 37)); C           !POINTER TO NEXT RECORD IN SAME PROJECT
RETURN
END LIST


%CENTOUT(N)      !OUTPUT TO CHOUT WITH A DOT BETWEEN $'S & DIMES
LOCAL L,M
[L;M] _ N DIVMOD 100
NUMOUT(L)
CHROUT($.)
IF M<10 THEN CHROUT($0)
NUMOUT(M)
RETURN
END CENTOUT

%RDREC(K)  !READ RECORD K INTO WD ARRAY

LOCAL I,J,TOT,L,M
[SYSNO;I] _ K DIVMOD 1000   !BREAK NUM INTO 1ST 2 AND LAST 3 DIGITS
SETCP(F, 32*I) !SET CURSOR POS TO 1ST WORD OF ITH RECORD
FOR I _ 0 TO 31 WD(I) _ R(F)   !READ THE WHOLE RECORD INTO WD ARRAY
RETURN
END RDREC

%WREC(K)   !WRITE RECORD AT RECNO OFLAST 3 DIGITS OF K
LOCAL I,SYSNO
[SYSNO;I] _ K DIVMOD 1000
SETCP(F, 32*I)
FOR I _ 0 TO 31 W(F, WD(I))
RETURN
END WREC

%ITEMOUT(I)   !TYPE AS DECIMAL NUMBER FOLLOWED BY A ) & A SPACE
IF I<10 THEN CHROUT($ )
NUMOUT(I)
CHROUT($))
CHROUT($ )
RETURN
END ITEMOUT

%X   !TRANSLATE ITEM NUMBER INTO WD NUMBER
LOCAL Q,R
[Q;R] _ (ITEM-7) DIVMOD 5
RETURN (R+1)/2 + Q*3 + 12
END X

%ITEMTYP(K)
IF ITEM <= Q <= LITEM THEN ITEMOUT(K)
RETURN
END ITEMTYP

%NUMTYP(K)
IF ITEM <= Q <= LITEM THEN NUMOUT(K)
RETURN
END NUMTYP

%SIXTYP(K,L)
IF ITEM <= Q <= LITEM THEN SIXOUT(K,L)
RETURN
END SIXTYP

%TYP(K)
IF ITEM <= Q <= LITEM THEN OUT(K)
RETURN
END TYP

%OCTWDTYP(K)
IF ITEM <= Q <= LITEM THEN OCTWDOUT(K)
RETURN
END OCTWDTYP

%CENTTYP(K)
IF ITEM <= Q <= LITEM THEN CENTOUT(K)
RETURN
END CENTTYP

%CHRTYP(K)
IF ITEM <= Q <= LITEM THEN CHROUT(K)
RETURN
END CHRTYP
