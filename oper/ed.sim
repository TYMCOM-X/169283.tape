!  CCS EDITOR
!  IOCSU+PFU+CCOMU MUST PRECEDE


GLOBAL %CCS, S:
LOCAL %CCS.INIT

S:      CCS.INIT        !INITIAL ENTRY POINT
S1:     GO S1S          !RECOVERY FROM EXECUTION
S2:     CCS(0)          !RECOVERY FROM DEBUGGER, COMMAND ALREADY IN BUFFER
S1S:    CCS(1)


%CCS (NEDCMD)

LOCAL %CSCAN, %CEXU, %XINIT

! USED IN COMMAND PROCESSING (NOT SAVED BETWEEN COMMANDS):

LOCAL SCR(NLMAX)             !SCRATCH ARRAY
LOCAL INFN                   !INPUT FILE NUMBER

!  ERROR MESSAGES TO USER OF CCS

TABLE EDILNG       ['TRUNCATED LINE AVAILABLE FOR EDIT']
TABLE NODFLT       ['NO DEFAULT NAME']
TABLE BDIOSD       ['BAD I/O SOURCE OR DESTINATION']
TABLE CNTREN       ['CANNOT RENUMBER, CHECK LINE RANGE']
TABLE BDANS        ['ILLEGAL RESPONSE IN COMMAND FILE']
TABLE DISORD       ['DISORDERLY LINE NUMBER']
TABLE PTROOM       ['NOT ENOUGH ROOM, CANNOT ENTER LINE']
TABLE NOROOM       ['NOT ENOUGH ROOM, COMMAND NOT EXECUTED']
TABLE BDLNFL       ['FILE HAS LINE NUMBERS']
TABLE NODBG        ['DEBUGGER COMMANDS NOT ALLOWED HERE']


LOCAL PTR, CNT, TEMP, I

LOCAL NCOM:, MDOUT:
FIND JOBERR

        OFFALT
        CCOM(NCOM)

!  ACCEPT A COMMAND LINE
!  NOTE: DO OFFALT BEFORE BRANCH HERE OR TO ANY LABELS FOLLOWING
!  ABOVE OFFALT

NCOM:    IF PF.FN <= TEL THEN XINIT     !MUST HAVE A PROGRAM FILE
         FIXUP _ NCOM; JOBERR _ 0
         ONALT.C
         IF NEDCMD THEN GETCOM ELSE SETREC
         NEDCMD _ 1
         IF CMN(PF.CNUM) BAND DBIT THEN CERR(NODBG)
         CSCAN; CEXU; INC PF.INTNO
         GO NCOM


%CCS.INIT
!INITIALIZES CCS WHEN FIRST ENTERED.  HANDLES -SFO COMMAND AND STUFF.

FIND SEGTAB(0), BIGBUF(0), KK.DUMP

LOCAL OK1:, NOTSYS:

DEF NBUFS AS 10 !THIS HAD BETTER AGREE WITH DEF IN LODAT

TABLE SFOWD(2)["SFORTRAN",ND.STR]

        IOCS([18,18]*[BIGBUF,NBUFS])
        FIXUP _ NCOM
        CCOM(NCOM)
	KK.DUMP _ K.DUMP	!LOADER HACK
        ^14 _ - OCT 25
        EXU(OCT 47,14,OCT 41,OK1); ^14 _ 0
OK1:    IF ^14 # OCT 1.000004 THEN GO NOTSYS
        EXU(OCT 51,8,0) !RESCAN
        GETSTR(CFN)     !GET COMMAND LINE
        WDSTOR(CLMAX,NOTSYS)
        CMDREC(SFOWD,NOTSYS)
GETPF:  CSCAN.INIT
        FFID(OCT 604755.000000)  !.PGM
        PF.FN _ TEL
        DO PF.OPEN(EL(1)) OF -1:1
-1:     CERR(BDIOSD)
0:      GO OPNERR
        END
        RETURN

%%XINIT
!ASKS FOR PROGRAM FILE AND GETS IT

NOTSYS: MSG("PROGRAM FILE: "); GETSTR(CFN); GO GETPF

END CCS.INIT


%CSCAN

!  CCS COMMAND LINE SCANNER

!  STORES COMMAND LINE ELEMENT IDENTIFIERS (IN EL.ID ARRAY) & INFO
!  NEEDED TO ACCESS ELEMENTS (IN EL ARRAY).
!  PF.CNUM (COMMAND NO.) RETURNED IF SCAN SUCCESSFUL, WITH 0'S IN
!  UNUSED EL.ID POSITIONS.

DEF ELW(X,Y) AS [EL(INC ELP)_(Y); EL.ID(ELP)_(X)]

LOCAL EROUT:, CRCHK:

         CSCAN.INIT

         DO PF.CNUM OF CMDCNT

K.OPEN: FFID(OCT 604755.000000) !.PGM

K.LINE:	   IF NOT FRNG OR EL.ID(1)#LKY.ID THEN GO EROUT
           IF NSPCH(NXCHAR)  THEN BACKSP     !ABSORB BLANK AFTER LINE KEY
           ELW(FOR.ID,LPTR); RETURN PF.CNUM

K.ENT:	FPWD(K.FRM,IF NOT FRNG THEN EROUT ELSE CRCHK)
	FFID(0)

K.CLR:   K.RUN:  K.INIT:  K.DUMP:  K.QUIT:  NULL

K.EDIT:  K.MOD:  K.DEL:  K.OVLY:  &
         IF NOT FLST THEN GO EROUT

K.COPY:  K.MOVE:  &
	IF NOT FLST THEN GO EROUT
	FPWD(K.TO,MDOUT); GO RENA

K.REN:   FLST; FPWD(K.AS,CRCHK)
RENA:	 IF NOT FRNG THEN GO EROUT

K.SRCH:	 RETURN

         END

! CR MUST FOLLOW
CRCHK:   IF NOT FCR THEN CPERR(%PCMDL); RETURN

EROUT:   IF NXNSP#CARRET THEN CERR(BDLRNG)
MDOUT:	CPERR(%PCMDL)


END CSCAN


%CEXU

!  EXECUTES COMMAND PF.CNUM.
!  WHEN FALL THRU TO END OF CASE STATEMENT, ALT MODE MUST BE OFF
!  (BECAUSE OF SUBSEQUENT BRANCH TO NCOM:).
!  FIXUP LOCATION SHOULD NOT INCLUDE OFFALT (WILL BE OFF WHEN 
!  GO ^FIXUP).

LOCAL %INRANG, %INTXL
LOCAL %MRGINP, %SET.INCR
GLOBAL %MKDL, %DELMKD, %UNMKDL
LOCAL %ANS

LOCAL LOKEY      !1ST KEY OF RANGE
LOCAL HIKEY      !LAST ALLOWABLE KEY
LOCAL INCR       !RANGE INCREMENT 
LOCAL LONUM      !1ST DICT. POSITION TO BE AFFECTED BY NEW RANGE
LOCAL HINUM      !POSITION OF 1ST LINE BEYOND AFFECTED RANGE IN PROG.
LOCAL TXINCT     !TEXT INPUT COUNT (NO. LINES ENTERED)
LOCAL MXINCT     !MAXIMUM TEXT INPUT COUNT

LOCAL I, J, WD(), TEMP
LOCAL LNERRB:, COP.B:
LOCAL LOADFX:, ENTFX:, MERGN:, LOAD.C:
LOCAL %SET.INFN


         DO PF.CNUM OF CMDCNT

K.CHK:  K.DUMP:  CERR(NOTIMP)

K.LINE:  LINES:  &
    	 INRANG(1)
         FIXUP _ ENTFX     !== FIXUP TO NCOM UNTIL LINE HAS BEEN ENTERED
         EIF EL.ID(1)=LKY.ID THEN INTXL    !LPTR IS OK

         ORIF INCR<0 THEN DO   !NO INCREMENT - AT SIGN PROMPT
           PRMNUM _ K.PAT
           LOOP DO
             GETSTR(CFN); WHILE NXCHAR#CARRET; BACKSP; INTXL
           END
         END
  
         ELSE DO    !INCREMENT - LINE KEY PROMPT
           PRMNUM _ K.PLK; TEMP _ LOKEY
ENT.B:     PRMKEY _ BCD(TEMP); GETSTR(CFN)
           IF NXCHAR#CARRET THEN DO
             BACKSP; INTXL
             IF TEMP +_ INCR <= HIKEY THEN GO ENT.B
           END
         END

         OFFALT
ENTFX:   PF.DOT _ MRGINP


K.ENT:	EIF EL.ID(2)#0 THEN DO    !RANGE FROM FILE
           OFFALT
           SETRWE(SET.INFN(2),COP.B); IF PLNCHK(INFN) THEN ABERR(BDLNFL)
           FIXUP _ LOAD.C
           ONALT
             INRANG(1)
!* NOTE: NOROOM ERR IF INCR>=0 AND LINE KEY>HIKEY (MXINCT EXCEEDED)
             LOOP [GETSTR(INFN); INTXL]
	END

	ORIF EL.ID(1)=RNG.ID THEN GO LINES    !RANGE (FROM TEL)

	ELSE DO    !FROM (NUMBERED) FILE
          OFFALT     !SINGLE LINE ENTER FROM FILE
          SETRWE(SET.INFN(1),MERGN); FIXUP _ LOAD.C; ONALT
          LOOP DO
            GETSTR(INFN)
            IF NXNSP#CARRET THEN DO
              BACKSP; PF.CNUM _ K.LINE; CSCAN
              INRANG(1)
              INTXL; OFFALT; PF.DOT _ MRGINP; ONALT
            END
          END
	END

COP.B:	LNGCHK; OFFALT; PF.DOT _ MRGINP; GO LOAD.C

MERGN:  LNGCHK; OFFALT

LOAD.C: CLOSE(INFN)


K.COPY:  K.MOVE: &
	   INLIST(1)
             INRANG(2)
             OFFALT
             REPEAT LSTCNT DO
               NXLNUM
               IF PF.CNUM=K.MOVE THEN DO
                 IF NOT(LONUM<=LNUM<HINUM) AND PF.KEYD(LNUM)>0 THEN DO
                 !IF OUTSIDE RANGE AND NOT ALREADY MARKED FOR DELETION:
                   INC MXINCT; MKDL(LNUM)
                 END
               END
               IF TXINCT=MXINCT THEN ABERR(NOROOM)
               SCR(INC TXINCT) _ PF.CPD(LNUM)
             END
             IF PF.CNUM=K.MOVE THEN DO     !SET UP FOR MRGINP
               LONUM _ DELMKD(1,LONUM-1)+1
               PF.NLINES _ DELMKD(HINUM,PF.NLINES)
             END
             PF.DOT _ MRGINP


K.MOD: &
K.EDIT:  INLIST(1); OUTFN _ TEL; PRMNUM _ K.PLK
         REPEAT LSTCNT DO
           PRMKEY _ PF.KEYD(NXLNUM)
           OUTCNT _ LLEN; UNPKTK(CHPT(IMAGE,-1),LNERRB)
EDIT.A:    IF PF.CNUM=K.EDIT THEN [OUTKEY(0,0,0); PRINTC(IMAGE)]
           GETSTR(TEL)
           IF NXCHAR#CARRET THEN DO
             BACKSP
             OFFALT
             PF.CPD(PF.DOT _ LNUM) _ PF.WTLIN(LPTR)
             PF.RELOK _ 0
             ONALT
           END
         END
         OFFALT


K.CLR:     IF ANS('ALL')=YES THEN DO
             OFFALT;  PF.CLEAR;  GO NCOM
           END ELSE OFFALT

K.DEL:     INLIST(1)
           OFFALT
           REPEAT LSTCNT MKDL(NXLNUM)
           PF.NLINES _ DELMKD(1,PF.NLINES)
           PF.RELOK _ 0


K.REN: &
! WILL NOT MOVE OR DELETE LINES! &
         IF ELID(1)=RNG.ID THEN DO
           ELID(1) <=> ELID(2)     !MOVE RANGE INFO, ZERO LIST ID
           EL(2) _ EL(1)           !FOR %INLIST
         END
         IF INLIST(1)>1 THEN CPERR(%PCMDL)
         IF ELID(1)#0=ELID(2) THEN DO
           !REN ADR1:ADR2 - ASSUME AS KEY(ADR1):KEY(ADR2)
           !MXINCT CHECK NOT NEEDED
           INCR _ -1
           LOKEY _ INTKEY(LONUM _ LTBL(1))
           HIKEY _ INTKEY((HINUM _ LTBL(1)+LSTCNT)-1)
         END ELSE [INRANG(2); IF LSTCNT>MXINCT THEN CERR(CNTREN)]
         IF NOT(LONUM>= LNUM _ LTBL(1) >=HINUM-LSTCNT) THEN CERR(CNTREN) 
         TXINCT _ LSTCNT; SET.INCR; DEC LNUM
         OFFALT
         REPEAT LSTCNT PF.KEYD(INC LNUM) _ BCD(LOKEY <== LOKEY+INCR)


LOCAL SRCFID(0:WPF-1)

K.SRCH:	TEMP _ I _ 0
	IF NXNSP#CARRET THEN DO
	  TEMP _ PF.STCP(PF.TOP)
	  BACKSP
	  LOOP DO
	    SETFID(SRCFID,@LPTR,OCT 624554.000000,MDOUT)
	    PF.WB(WPF,SRCFID)
	    INC I
	    WHILE NXNSP=$,
	  END
	  IF CHRLST#CARRET THEN GO MDOUT
	END
	OFFALT
	PF.SRCH _ [18,18]*[I,TEMP]


K.OVLY:	INLIST(1); OFFALT
	FOR I _ 1 BY 1 TO NLMAX PF.FLGD(I) _ PF.FLGD(I) BAND BNOT PFL.OVL
	REPEAT LSTCNT PF.FLGD(NXLNUM) _ PF.FLGD(LNUM) BOR PFL.OVL
	PF.OVFL _ -1


FIND SGLD:, SGSFA:

K.RUN:  K.INIT:  K.DUMP: &
         PF.UPDATE
         GOSEG(IF PF.RELOK THEN SGLD ELSE SGSFA, 0)


K.QUIT: OFFALT; QUIT


K.OPEN: OFFALT
        DO PF.OPEN(EL(1)) OF -1:1
-1:     CERR(BDIOSD)
0:      GO OPNERR
        END
        OKAY
        GO NCOM         !DON'T WANT TO INCREMENT PROMPT#


         END
         RETURN


LNERRB:  MSG(LNLONG); MSG(EDILNG); GO EDIT.A

%SET.INFN (N)
LOCAL INERR:

        LOOP DO
         IF INFN _ OPEN(EL(N),INPUT+SEQUEN+CHARACTER,INERR,2) &
          =TEL THEN CERR(BDIOSD); OKAY; RETURN INFN
INERR:   IF ERRNUM#FNFERR OR EXTQ(FIDP)=YES THEN GO OPNERR
         EXTQ(FIDP) _ YES; EXTARG(FIDP) _ 0
        END

END SET.INFN


%INRANG (I)

!  I IS INDEX INTO EL.ID & EL ARRAYS FOR LINE RANGE INFO. EL(I) IS
!  ADDRESS OF WD BEFORE 1ST WD OF SUBELEMENT LIST,
!  UNLESS EL.ID(I) IS 0, TO INDICATE DEFAULT RANGE OF 1(1) (RENUMBER).
!  ALSO SPECIAL RENUMBER CASE: IF UPPER LIMIT OMITTED, IS LAST LINE
!  IN LIST TO BE RENUMBERED.
!  CALCULATES AND STORES RANGE PARAMETERS: LOKEY, HIKEY, INCR (-1
!  IF NONE), LONUM, HINUM, MXINCT.
!  INITS TXINCT & CURSOR FOR %INTXL
!  NOTE: NEGATIVE INTEGER REPRESENTS LINE KEY.

LOCAL CONT:, NXT:, NXT1:

         IF EL.ID(I)=0 THEN [LOKEY _ INCR _ PWR10(D.DGMAX); GO INRA]
         WD _ EL(I)
         LOKEY _ -WD(1); INCR _ -1
         IF WD(2)=0 THEN HIKEY_LOKEY ELSE DO
           IF WD(2)=$: THEN HIKEY_-WD(3) ELSE DO
             INCR _ -WD(3)    !WD(2) IS (, WD(4) IS )
             IF HIKEY _ -WD(5)=0 THEN DO    !CREATE UPPER LIMIT KEY
INRA:          IF PF.CNUM=K.REN THEN LNUM _ LTBL(1)+LSTCNT ELSE DO
                 XLKLN(LOKEY,CONT); INC LNUM
                 ! LNUM IS 1ST PROG. LINE ABOVE LOWER LIMIT
               END
CONT:          HIKEY _ IF LNUM >PF.NLINES THEN LKY.MAX ELSE &
                 INTKEY(LNUM)-1
             END
           END
           IF HIKEY < LOKEY THEN CERR(BDLRNG)   !OLD CCS DISALLOWED =
         END

         XLKLN(LOKEY,NXT)
NXT:     LONUM _ LNUM
         XLKLN(HIKEY,NXT1); INC LNUM
NXT1:    HINUM _ LNUM
         ! HINUM-LONUM IS NO. OF LINES CURRENTLY IN RANGE
         MXINCT _ NLMAX MIN 1+(HIKEY-LOKEY)/(IF INCR<0 THEN 1 &
           ELSE INCR) MIN HINUM-LONUM+NLMAX-PF.NLINES

         TXINCT _ 0; RETURN

END INRANG


%INTXL

!  WRITE LINE AT LPTR ON PF AND STORE CORRESPONDING PF.CPD ENTRY
!  IN SCR ARRAY.
!  OFFALT PROTECTS AGAINST TXINCT BEING 1>NO. OF SCR ENTRIES.

         IF TXINCT = MXINCT THEN &
         ABERR(IF PF.CNUM=K.ENT THEN PTROOM ELSE NOROOM)
         OFFALT; SCR(INC TXINCT) _ PF.WTLIN(LPTR); ONALT
         RETURN

END INTXL


%MRGINP

!  MERGE THOSE LINES WHICH HAVE PF.CPD ENTRIES IN SCR ARRAY.
!  (TXINCT LINES IN ALL).  1ST KEY IS LOKEY; INCR IS CALCULATED IF
!  NEVER SPECIFIED.  1ST LNUM IS LONUM; LOKEY AND LONUM ARE UPDATED.
!  RETURNS NO. OF LAST LINE MERGED, POSSIBLY USED TO SET PF.DOT
!  (THUS DOES NOTHING BUT RETURN PF.DOT IF TXINCT IS 0.)

LOCAL MVCNT, MVDIS

         IF TXINCT=0 THEN RETURN PF.DOT
         SET.INCR
         MVCNT _ PF.NLINES-HINUM+1
         IF MVDIS _ LONUM+TXINCT-HINUM >0 THEN DO
!  MOVE DOWN LOWER PART OF EACH DICTIONARY,STARTING WITH LAST ENTRY
!  (PF.NLINES), ENDING WITH BEGINNING OF LOWER PART (HINUM).
           PTR _ PF.NLINES+1
           REPEAT MVCNT DO
             PF.CPD(PTR+MVDIS) _ PF.CPD(DEC PTR)
             PF.KEYD(PTR+MVDIS) _ PF.KEYD(PTR)
           END
         END ELSE IF MVDIS<0 THEN DO     !MOVE UP LOWER PART
           MOVE MVCNT FROM @PF.CPD(HINUM) TO @PF.CPD(LONUM+TXINCT)
           MOVE MVCNT FROM @PF.KEYD(HINUM) TO @PF.KEYD(LONUM+TXINCT)
         END
         DEC LONUM; I _ 0
         WHILE INC I <= TXINCT THEN DO
           PF.CPD(INC LONUM) _ SCR(I)
           PF.KEYD(LONUM) _ BCD(LOKEY<==LOKEY+INCR)
         END
         PF.NLINES +_ MVDIS
         PF.RELOK _ 0
         RETURN LONUM
END MRGINP


%SET.INCR

! COMPUTE INCREMENT IF NECESSARY.

IF TXINCT>1 AND INCR<0 THEN DO
  TEMP _ (HIKEY-LOKEY)/(TXINCT-1) +1
  I _ D.DGMAX+1
  WHILE TEMP <= PWR10(DEC I) THEN NULL; INCR _ PWR10(I)
END
RETURN

END SET.INCR


%MKDL (LNUM)

!  MARK LINE WITH NUMBER LNUM FOR DELETION (TURN ON SIGN BIT)

PF.KEYD(LNUM) BOR_ SGNBIT; RETURN

END MKDL


%DELMKD (LO, HI)

!  DELETE LINES MARKED FOR DELETION (SIGN BIT ON) IN RANGE OF LINE
!  NUMBERS LO TO HI; I.E., CRUNCH UNMARKED LINES.
!  RETURNS INDEX TO LAST OF CRUNCHED LINES (LO-1 IF ALL MARKED).
!  IF HI EXCEEDS LO, RETURNS LO-1; WHEN CALLED IN MOVING
!  LIST TO RANGE, WILL WORK OK IF LONUM IS 0 OR HINUM IS PF.NLINES+1.
!  ADJUST PF.DOT IF IN AFFECTED RANGE.

LNUM _ I _ LO-1
WHILE INC LNUM<=HI THEN DO
  IF PF.KEYD(LNUM)>0 THEN DO
    PF.KEYD(INC I) _ PF.KEYD(LNUM)
    PF.CPD(I) _ PF.CPD(LNUM)
  END
  IF LNUM=PF.DOT AND PF.DOT _ I =0 THEN INC PF.DOT
END
RETURN I

END DELMKD


%UNMKDL

!  UNMARK ALL LINES MARKED FOR DELETION (TURN OFF SIGN BIT).

LNUM _ 0
REPEAT PF.NLINES &
  PF.KEYD(INC LNUM) BAND_ BNOT SGNBIT
RETURN

END UNMKDL


%ANS (QUES)

!  PRINTS QUES (IF COMMAND FILE TEL), READS ANSWER AND RETURNS 1 IF YES,
!  0 IF NO.

         IF CFN=TEL THEN [MSG(QUES); PRMNUM _ K.PQM]
         LOOP DO
           GETSTR(CFN)
           IF LWALPH(NXNSP) THEN XLWUP(CHRLST)
           IF NOT($Y#CHRLST#$N) THEN RETURN [CHRLST=$Y]
           IF CFN#TEL THEN CERR(BDANS)
           MSG('WHAT')
         END

END ANS

END CEXU

END CCS
  