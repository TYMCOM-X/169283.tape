BASE 0

!PROCEDURES
FIND %BYPT, %GETDUM, %HASH, %OCTOUT, %SIXOUT, %NUMOUT
FIND %CALNCS, %GETNUM, %INITTTY, %DATOUT, %CHR.OUT, %OUT
LOCAL %MRGSTR, %CHK.ACT.ERR, %CHK.IO.ERR, %INITMRG
LOCAL %GETSLS, %UNSQZ, %DUL.LOOK, %DUL.OVERFLOW
LOCAL %ERROR, %LOKUP.DUL, %LOKUP.LUD
LOCAL %LUD.LOOK, %LUD.OVERFLOW, %SET.UP.LINE

! 128 WORDS IN A PDP-10 BLOCK
DEF SIZE.BLK AS 128

!ID'S
GLOBAL LOC.HASH, NAME.HASH
GLOBAL USER(20),  CUST(150),  PPN, IER, ICODE, MODE
GLOBAL CH.OUT, P, NUMBER
LOCAL PCODE, TCODE, CUSTN
LOCAL OLDUSR, P1, CH.CUS
FIND FILNO
LOCAL TEMP, CHAN, CH.LUD, CH.DUL, IO.ADR
LOCAL D.INDEX, D.BLK(SIZE.BLK), DULNAM, DULFLG
LOCAL L.INDEX, L.BLK(SIZE.BLK), LUDNAM
LOCAL SIT31NAME, SITE, S.DIST, ERRFLG, A.VALID
LOCAL IOTAB(WPF)


!MACRO'S
DEF ACTSIT(A) AS BYT(A,1,(BITS.PER.WORD-1)-SITE) !COMPUTE ACCTG. SITE
DEF CALL.GETACT(A,B) AS [ICODE_A; MODE_B; GETDUM]
DEF CR AS CHR.OUT(CARRET)
DEF DIST.BITS AS BYT(LUD(1),8,0)
DEF DOTS AS OUT('...')
DEF ENDIT AS [CLOSE.ALL; EXIT]
DEF FIXCP(A) AS (A-1)*SIZE.BLK	!COMPUTE CURSOR POS. FROM BLK. NO.
DEF LUD.READ AS [RB(CH.LUD,SIZE.BLK,L.BLK); L.INDEX_0]
DEF DUL(A) AS D.BLK(D.INDEX+A)
DEF LUD(A) AS L.BLK(L.INDEX+A)
DEF DUL.READ AS [RB(CH.DUL,SIZE.BLK,D.BLK); D.INDEX_0]
DEF NO.BILL.OLD AS 100	!OLD NON-BILLABLE PRICING CODE
DEF NO.BILL.NEW AS OCT 77	!NEW NON-BILLABLE PRICING CODE
DEF OCTWD.OUT(A) AS [OCTOUT(HW(@A,0)); CHR.OUT($,); OCTOUT(HW(@A,1))]
DEF PASS AS [WHILE NCHV P = SPACE THEN NULL; PCHV P]
DEF PUTSITE(A) AS ACTSIT(A) _ 1
DEF SIZE.LUD.ENT AS BYT(LUD(2),7,0)
DEF SETTEL AS [CH.OUT_OPEN('TEL',SEQUEN+OUTPUT+CHARACTER,0,2)]
DEF SETSITE AS [HW(@EXTARG(IOTAB),0)_SIT31NAME; SITBYT_SITBYT+SITE-31]
DEF SPACE AS $ 
DEF SITBYT AS BYT(EXTARG(IOTAB),6,24)
DEF SITOUT AS [OUT('...SITE '); NUMOUT(SITE)]
DEF TYMSH.OLD.NUM AS 3376
DEF TYMSH.NEW.NUM AS 1
DEF OTITLE AS [CR; OUT('MRGSTR - VERSION '); NUMOUT(VERSION); CR; DATOUT]
DEF VERSION AS 21
DEF ZERO AS 0

!ERROR MESSAGES
DEF NO.DUL AS 1
DEF NO.LUD AS 2
DEF DUL.MISSING AS 3
DEF LUD.MISSING AS 4
DEF DIFF.DIS AS 5
DEF NO.SLS AS 6
DEF OVER.BAD AS 7
DEF DIFF.CUS AS 8
DEF DIFF.NAM AS 9
DEF BAD.LUD AS 10
DEF BAD.DUL AS 11

!DEF'S FOR USE WITH GETACT
!ICODE VALUES
DEF INIT.UPD AS 2
DEF RD.SPEC AS 3
DEF WR.SPEC AS 5
DEF CL AS 6

!MODE VALUES
DEF USR.ASC AS -2
DEF USR.SIX AS -1

!IER VALUES
DEF FOUND AS 0
DEF NOT.FOUND AS 1

!LABELS
LOCAL CHK.ERR:,ERRUSR:,BADADR:,ERRCUS:,OUTERR:

%MRGSTR
	!MAIN LINE TO LOOK UP USERS IN LUD, DUL FOR EACH SITE


START: INITMRG
\\->START
FILNO _ OPEN('(CUD10)USERS.DAT',SEQUEN+INPUT+CHARACTER,ERRUSR,2)
CH.CUS _ OPEN('(CUD10)TABLE.DAT',DIRECT+INPUT+CHARACTER,ERRCUS)
CALL.GETACT(INIT.UPD,USR.SIX); CHK.ACT.ERR	!INITIALIZE
AGAIN:LOOP DO
   ERRFLG _ 0    !=1 IF USER NOT FOUND IN ACCTG. ALLREADY - FORGET IT
   SET.UP.LINE	!INPUT A LINE AND SET UP VARIABLES
   IF DUL.LOOK # 0 THEN DO
      IF LUD.LOOK = 0 THEN DO
         IF A.VALID # 0 THEN [ERROR(LUD.MISSING); INC ERRFLG]
      END
      CLOSE(CH.LUD)
   END ELSE [ERROR(DUL.MISSING); INC ERRFLG]
   CLOSE(CH.DUL)
   CALL.GETACT(RD.SPEC,USR.SIX)
   EIF IER = NOT.FOUND THEN DO
      IF ERRFLG > 0 THEN GO AGAIN
      USER(1) _ PCODE; USER(2) _ TCODE
      USER(4) _ CUSTN; USER(5) _ USER(6) _ 0
      USER(7) _ BYT(LUD(3),2,13)
      USER(8) _ DUL(1); USER(9) _ DUL(2)
      IF GETSLS = 1 THEN DO
         IF USER(4) # TYMSH.NEW.NUM THEN DO
            IF S.DIST _ USER(3)/100 # DIST.BITS THEN DO
		ERROR(DIFF.DIS)
		USER(3) _ (USER(3) - S.DIST*100) + DIST.BITS * 100
            END
         END ELSE USER(3) _ (DIST.BITS * 100) + 1
      END ELSE ERROR(NOSLS)
   END
   ORIF IER = FOUND AND ERRFLG = 0 THEN DO
      IF CUSTN # USER(4) THEN [IF USER(4) # 1 THEN ERROR(DIFF.CUS)]
      IF USER(8) # DUL(1) OR USER(9) # DUL(2) THEN ERROR(DIFF.NAM)
   END
   ELSE CHK.ACT.ERR
   IF A.VALID # 0 THEN PUTSITE(USER(5))
CALL.GETACT(WR.SPEC,USR.SIX); CHK.ACT.ERR
END
ERRUSR: IF ERRNUM # EOFERR THEN CHK.IO.ERR
	CALL.GETACT(CL,USR.ASC); CHK.ACT.ERR; MSG('$USERS.DAT TRANSLATED.$')
	CLOSE.ALL
	CALNCS
	EXIT
BADADR: MSG('BAD I/O FROM INPUT FILE.$'); ENDIT
OUTERR:	MSG(' ERROR ON OUTPUT FILE - MRGERR.OUT.$'); ENDIT





%INITMRG
	!INITIALIZE IOCS,TTYIO
	!OUTPUT HEADING TO TEL AND SET UP OUTPUT FILE
	!INITIALIZE USERNA.MES & CUSTOM.ERS
	!SET UP 6-BIT STRINGS FOR READING LUD.3N AND DUL.3N
IOCS(2)
INITTTY(BADADR)	!ERROR RETURN SET UP
SETTEL; OTITLE; CLOSE(CH.OUT)
CH.OUT _ OPEN('MRGERR.OUT',SEQUEN+OUTPUT+CHARACTER,OUTERR,2)
OTITLE

PPN _ OCT 1042313	!PPN FOR CUD10 WHERE OUTPUT FILES ARE TO GO

!CREATE USERNA.MES AND CUSTOM.ERS
   CHAN _ OPEN('(CUD10)USERNA.MES',DIRECT+OUTPUT+WORD,CHKERR)
   SETCP(CHAN,SIZE.BLK*105)	!105 BLOCKS IN USERNA.MES
   W(CHAN,ZERO);  CLOSE(CHAN)

   CHAN _ OPEN('(CUD10)CUSTOM.ERS',DIRECT+OUTPUT+WORD,CHKERR)
   SETCP(CHAN,SIZE.BLK*535)	!535 BLOCKS IN CUSTOM.ERS
   W(CHAN,ZERO); CLOSE(CHAN)

IO.ADR _ ERRUSR	!SET UP ERROR RETURN

!SET UP STRINGS FOR LUD.3N,DUL.3N
   P1 _ CHPT('(CUD10)LUD.31',-1)
   SETFID(IOTAB,@P1,0,CHK.ERR)
   LUDNAM _ NAMARG(IOTAB)	!SAVE "(CUD10)LUD"
   SIT31NAME _ HW(@EXTARG(IOTAB),0)	!SAVE "31"

   P1 _ CHPT('(CUD10)DUL.31',-1)
   SETFID(IOTAB,@P1,0,CHK.ERR)
   DULNAM _ NAMARG(IOTAB)	!SAVE "(CUD10)DUL"

RETURN
END INITMRG



%SET.UP.LINE
	!PUT INFO FROM 1 LINE INTO VARIABLES:
	!USER,A.VALID,SITE,PCODE,TCODE,CUST
P _ GETLINE(FILNO); NCHV (P)	!FIRST CHAR IS A BLANK
!FILL IN SQUEEZED PPN IN OLDUSR AND UNSQUEEZE
   P1 _ BYPT(@OLDUSR,1,6)
   REPEAT 6 NCHV(P1) _ (NCHV(P) - SPACE) BAND OCT 77
   UNSQZ

SITE _ (NCHV(P) - $0) + 30	!GET SITE
A.VALID _ NCHV(P) -$0	!=0 IF MARKED FOR DELETION
PASS	!SKIP TO NEXT NON-BLANK CHAR.
IF PCODE _ GETNUM = NO.BILL.OLD THEN PCODE _ NO.BILL.NEW
TCODE _ GETNUM
IF CUSTN _ GETNUM = TYMSH.OLD.NUM THEN CUSTN _ TYMSH.NEW.NUM
RETURN
END SET.UP.LINE



%UNSQZ
	!UNSQUEEZE VALUE IN OLDUSR AND PUT IN USER(0)
LOCAL TMP1,TMP2,NO
TMP1 _ OLDUSR; TMP2 _ NO _ 0
REPEAT 2 DO
    REPEAT 3 DO
	[TMP2;TMP1] _ [TMP2;TMP1] DROTL 6
	IF TMP2 _ TMP2 BAND OCT 77 = 0 THEN TMP2 _ 26
	IF TMP2 - _ 16 >= 17 THEN TMP2 - _ 6
	NO _ NO*OCT 50+TMP2
    END
HW(@TMP1,1) _ NO; NO _ 0
END
USER(0) _ TMP1
RETURN
END UNSQZ


%GETSLS
	!READ THRU TABLE.DAT LOOKING FOR THE CUST. IN CUSTN
	!RETURN = 1 IF FOUND, =0 IF NOT

DEF NEWLINE AS [P _ GETLINE(CH.CUS); PASS]

IF USER(4) = TYMSH.NEW.NUM THEN RETURN 1 !IF TYMSH, DON'T BOTHER TO
			!LOOK FOR SALESMAN - USE DIST * 100 + 1
SETCP(CH.CUS,0)
NEWLINE
WHILE GETNUM # CUSTN THEN NEWLINE
USER(3) _ GETNUM	!SAVE NEXT NUMBER AS SALESMAN
RETURN 1
ERRCUS:	IF ERRNUM # EOFERR THEN CHK.IO.ERR
	USER(3) _ 0
RETURN 0
END GETSLS




%LUD.LOOK
	!LOOK UP NAME IN USER+8,USER+9 IN LUD
LOKUP.LUD
HASH(DUL(1),DUL(2))
SETCP(CH.LUD,FIXCP(LOC.HASH)); LUD.READ 
WHILE USER(0) # LUD(0) THEN DO
	L.INDEX+_SIZE.LUD.ENT
	IF LUD(0)=0 THEN RETURN 0
	IF LUD(0)<0 THEN LUD.OVERFLOW
	END
RETURN 1
END LUD.LOOK


%DUL.LOOK
	!LOOK UP USER(0) IN DUL
LOKUP.DUL
SETCP(CH.DUL,FIXCP((USER(0) MOD 101)+1)); DUL.READ
WHILE DUL(0) # USER(0) THEN DO
	D.INDEX+_3
	IF DUL(0)=0 THEN RETURN 0
	IF DUL(0)<0 THEN DUL.OVERFLOW
	END
RETURN 1
END DUL.LOOK


%CHK.ACT.ERR
	!CHECK ACCTG. FILE ERRORS
 IF IER=0 THEN RETURN
 MSG('ERROR ON '); IF MODE <0 THEN MSG('USERNA.MES') ELSE MSG('CUSTOM.ERS')
SETTEL; DOTS; CR

 DO IER OF 1:4
1:  MSG('ENTRY NOT FOUND.')
2:  MSG('NO END OF FILE ADR. SET UP.')
3: MSG('ERROR ON FILE.')
4: MSG('MISC. ERROR.')
END
  EXIT
END CHK.ACT.ERR


%CHK.IO.ERR
	!TAKE CARE OF ALL I/O ERRORS FROM IOCS
CHK.ERR: IF ERRNUM=EOFERR AND IO.ADR # 0 THEN GO ^IO.ADR
SETTEL;  MSG('ERROR ON ');WFID(FIDP);DOTS ;CR
  DO ERRNUM OF TMFERR:CORERR
FMDERR: MSG('BAD FILE MODE OR TYPE')
IFDERR: MSG('ILLEGAL FILE IDENTIFIER')
FNFERR: MSG('FILE NOT FOUND')
IUSERR: MSG('INVALID USER NAME')
PRTERR: MSG('PROTECTION FAILURE')
EOFERR: MSG('END OF FILE')
 END
MSG('.$ERROR ');NUMOUT(ERRNUM);EXIT
END CHK.IO.ERR


%LUD.OVERFLOW
	!READ LUD OVERFLOW BLOCK
IF L.INDEX<SIZE.BLK-20 THEN [TEMP_'LUD';ERROR(OVER.BAD)]
SETCP(CH.LUD,HW(LUD(0),1)*SIZE.BLK)
LUD.READ
RETURN
END LUD.OVERFLOW


%DUL.OVERFLOW
	!READ DUL OVERFLOW BLOCK
IF D.INDEX<SIZE.BLK-6 THEN [TEMP_'DUL';ERROR(OVER.BAD)]
SETCP(CH.DUL,HW(DUL(0),1)*SIZE.BLK)
DUL.READ
RETURN
END DUL.OVERFLOW


%ERROR(ERR)
	!TYPE OUT DATA ERRORS TO USER
CR; DO ERR OF NO.DUL:BAD.DUL
NO.DUL: MSG('NO DUL.'); SETTEL; NUMOUT(SITE); ENDIT
NO.LUD: MSG('NO LUD.'); SETTEL; NUMOUT(SITE); ENDIT
DUL.MISSING: OUT('NO DUL ENTRY FOR '); OCTWD.OUT(USER(0)); SITOUT
	RETURN
LUD.MISSING: OUT('NO LUD ENTRY FOR '); SIXOUT(D.BLK+D.INDEX+1,12)
	DOTS; OCTWD.OUT(USER(0)); SITOUT
	RETURN
DIFF.DIS: OUT('DISTRICTS FOR '); SIXOUT(USER+8,12); OUT('DO NOT MATCH'); SITOUT
	CR; OUT('LUD = '); NUMOUT(DIST.BITS); OUT('	ACCTG. = ')
	NUMOUT(USER(3)/100); OUT('	CUST. = '); NUMOUT(USER(4)); RETURN
NO.SLS: OUT('NO SALESMAN FOR CUSTOMER '); NUMOUT(USER(4))
OVER.BAD: MSG('BAD OVERFLOW BLOCK IN '); MSG(TEMP); ENDIT
DIFF.CUS: OUT('USER NAME: '); SIXOUT(USER+8,12); CR
	OUT('CUST. NO. IN ACCTG. = '); NUMOUT(USER(4))
	OUT('   CUST. NO. IN USERS = '); NUMOUT(CUSTN); RETURN
DIFF.NAM: OUT('NAME IN ACCTG. = '); SIXOUT(USER+8,12)
	OUT('$NAME IN DUL = '); SIXOUT(D.BLK+D.INDEX+1,12); RETURN
BAD.LUD: MSG('BAD LUD.'); SETTEL; NUMOUT(SITE); ENDIT
BAD.DUL: MSG('BAD DUL.'); SETTEL; NUMOUT(SITE); ENDIT
END
	CR; GO AGAIN
END ERROR



%LOKUP.LUD
	!LOOK FOR LUD.SITE ON DSK
LOCAL LUD.ERR:
	NAMARG(IOTAB)_LUDNAM; SETSITE
	CH.LUD_OPEN(-IOTAB,DIRECT+INPUT+WORD,LUD.ERR)
	RETURN 
LUD.ERR: EIF ERRNUM = FNFERR THEN ERROR(NO.LUD)
	ORIF ERRNUM = EOFERR THEN ERROR(BAD.LUD)
	ELSE CHK.IO.ERR
END LOKUP.LUD


%LOKUP.DUL
	!LOOK FOR DUL.SITE ON DSK
LOCAL DUL.ERR:
	NAMARG(IOTAB)_DULNAM; SETSITE
	CH.DUL_OPEN(-IOTAB,DIRECT+INPUT+WORD,DUL.ERR)
	RETURN
DUL.ERR: EIF ERRNUM = FNFERR THEN ERROR(NO.DUL)
	ORIF ERRNUM = EOFERR THEN ERROR(BAD.DUL)
	ELSE CHK.IO.ERR
END LOKUP.DUL


END MRGSTR
    