C	COPYRIGHT C 1972 BY CORE & CODE, INC.
	FUNCTION NBKZZZ(IARRAY,ISTART,ISTOP)
C
C RETURNS THE POSITION OF THE FIRST NON-BLANK BETWEEN
C ISTART AND ISTOP. IF NONE FOUND, NONBLK=-1.
C
C IARRAY=PASSED IN AS ARRAY OF ARBITRARY SIZE AND SHAPE
C        CONTAINING A1 CHARS WHERE NON-BLANK IS TO OCCUR
C ISTART & ISTOP=WHERE TO START AND STOP LOOKING IN IARRAY.
C        NO CHECK IS MADE FOR ABOVE OR BELOW RANGE.
C
	COMMON /C01ZZZ/ NASCII(128)
	DIMENSION IARRAY(1)
	IF(ISTART.GT.ISTOP) GO TO 20
	IF(ISTART.LE.0) ISTART=1
	DO 10 NBKZZZ=ISTART,ISTOP
	IF(IARRAY(NBKZZZ).NE.NASCII(33)) RETURN
10	CONTINUE
20	NBKZZZ=-1
	RETURN
	END
C
C
C
	FUNCTION NBCZZZ(IARRAY,ISTART,ISTOP)
C RETURNS POSITION IN IARRAY BETWEEN ISTART AND ISTOP
C OF NEXT BLANK OR COMMA.  IF NONE FOUND, NEXBOC=-1.
C
C IARRAY=PASSED IN AS A1 ARRAY OF ARBITRARY SIZE AND SHAPE
C        TO BE SEARCHED.
C ISTART & ISTOP=WHERE TO START AND STOP IN IARRAY.
C
	COMMON /C01ZZZ/ NASCII(128)
	DIMENSION IARRAY(1)
	NBCZZZ=MAX0(1,ISTART)
10	IF(NBCZZZ.GT.ISTOP) GO TO 20
	IF(IARRAY(NBCZZZ).EQ.NASCII(33)) RETURN
	IF(IARRAY(NBCZZZ).EQ.NASCII(45)) RETURN
	NBCZZZ=NBCZZZ+1
	GO TO 10
20	NBCZZZ=-1
	RETURN
	END
C
C
C
	FUNCTION LSGZZZ(IARRAY,ISTART,ISTOP)
C
C FINDS THE LAST SGNIFICANT NON-BLANK WORD AND RETURNS ITS
C POSITION. IF NONE FOUND, LASSIG=-1
C
C IARRAY=PASSED IN AS ARRAY OF ARBITRARY SIZE AND SHAPE
C WHOSE LAST NON-BLANK POSITION IS TO BE FOUND. CAN BE PACKED
C A5 OR UNPACKED A1. IF A5, THE LAST NON-BLANK WORD (WHICH
C ITSELF MAY CONTAIN UP TO 4 TRAILING BLANKS) IS RETURNED.
C ISTART & ISTOP=PASSED IN AS WHERE TO START AND STOP SEARCH
C        IN IARRAY. IT IS ASSUMED THAT ISTOP IS GREATER THAN OR
C        EQUAL TO ISTART.
C
	DIMENSION IARRAY(1)
	DATA IBLANK /5H     /
	LSGZZZ=ISTOP
10	IF(IARRAY(LSGZZZ).NE.IBLANK) RETURN
	LSGZZZ=LSGZZZ-1
	IF(LSGZZZ.GE.ISTART) GO TO 10
	LSGZZZ=-1
	RETURN
	END
C
C
C
	SUBROUTINE TRZZZ(VALIN,IFLAG,NOCHRS)
C
C ROUTINE TO TRANSLATE FROM A FLOATING POINT VALUE TO A STRING
C OF A1 ALPHA CHARS.  THE TOTAL MAXIMUM NUMBER OF CHARS
C RETURNED IS 'MAXSHO', CURRENTLY 11.  THE NUMBER OF DECIMAL
C PLACES SHOWN CAN BE CONTROLLED BY 'IFLAG'. THE DEFAULT NUMBER
C OF DECIMALS IS 'NOSIG', CURRENTLY 5 SIGNIFICANT DIGITS.  IF THE
C DEFAULT IS TAKEN AND THE NUMBER IS TOO LARGE, IT IS CONVERTED TO
C E FORMAT.  IF A SPECIFIC NUMBER OF DECIMALS ARE SPECIFIED AND THE
C NUMBER IS TOO BIG, '***' IS RETURNED.
C
C VALIN =VALUE PASSED IN TO BE TRANSLATED
C IFLAG =10 MEANS DEFAULT NUMBER OF DECIMALS
C        11 MEANS USER SPECIFIED 0 DECIMALS
C        12 MEANS USER SPECIFIED 1 DECIMAL PLACE
C          .
C          .
C          .
C        19 MEANS USER SPECIFIED 8 DECIMAL PLACES
C        SAME TRUE FOR 20-29 BUT ADD LEADING $
C        SAME TRUE FOR 30-39 BUT ADD TRAILING %
C        SAME TRUE FOR 40-49 BUT ENCLOSE NEGATIVES IN PARENS
C        60-99 IDENTICAL TO 10-49 EXCEPT SHOW COMMAS IN THOUSANDS PLACES
C NOCHRS=RETURNS THE TOTAL NUMBER OF CHARS, INCLUDING SIGNS, DEC POINT
C        ETC. IN THE NUMBER
C
C COMMONS: THE ALPHA CHARS ARE INSERTED INTO 'INPUT'
C
	COMMON /C01ZZZ/ NASCII(128)
	COMMON /C14ZZZ/ MAXDAT,MAXTMP,MAXROW,MAXCOL,MAXTRI,
     +  MAXRSK,MAXPRO,  MAXPFR,IWDSIZ,MAXOUT,MAXIN ,MAXTIT,
     +  MAXTWD,MAXTCH,  MAXCWD,MAXCCH,MAXRWD,MAXRCH,MSTDAL,
     +  MAXROP,MPFRAL,  MAXRAL,MAXVAR,MAXDWD,MAXEXP,EXPMAX,
     +  MINEXP,EXPMIN,  NOCONT,LENAME,MAXCPP,ICOLWD,LENEXT,
     +  MAXCOP
	COMMON /C04ZZZ/ INPUT(320),INPOS,INSIZE,INCONT
	DIMENSION IOCHAR(5,3),IOLEN(5),IFXXX(4)
	DATA NOSIG /5/, IOLEN /2,3,2,3,2/, IFXXX /10,20,30,40/
	DATA IOCHAR /1H ,1H$,1H-,1H$,1H(,3*1H ,1H-,6*1H /, MAXSHO /11/
	DATA BIGINT /34359738367.5/
C	BIGINT = THE LARGEST INTEGER +.5
	VALUE=VALIN
	ITFLAG=IFLAG
	IF(ITFLAG.LT.50)GO TO 2
	ITFLAG=ITFLAG-50
	ICOMMA=1
	GO TO 4
2	ICOMMA=0
4	IFSIGN=ITFLAG/10
	NODEC=ITFLAG-IFXXX(IFSIGN)
	IFCASE=1
	IF(VALUE.GE.0.0) GO TO 15
	IF(IFSIGN.NE.4)GO TO 5
	IFCASE=5
	GO TO 10
5	IFCASE=3
10	VALUE=-VALUE
15	IF(IFSIGN.EQ.2) IFCASE=IFCASE+1
	DO 20 I=1,3
20	INPUT(I)=IOCHAR(IFCASE,I)
	IPLACE=IOLEN(IFCASE)
	IF(VALUE.NE.0.0) GO TO 100
	IOSTOP=NODEC+1
	IF(IOSTOP.EQ.2) IOSTOP=1
	DO 30 I=1,IOSTOP
30	INPUT(IPLACE+I-1)=NASCII(49)
	IF(IOSTOP.GT.1) INPUT(IPLACE+1)=NASCII(47)
	IPLACE=IPLACE+IOSTOP
55	IF(IFSIGN.GE.3) GO TO 60
	NOCHRS=IPLACE-1
	GO TO 70
60	NOCHRS=IPLACE
	IF(IFSIGN.EQ.4)GO TO 65
	INPUT(IPLACE)=NASCII(38)
	GO TO 70
65	INPUT(IPLACE)=NASCII(42)
	IF(IFCASE.NE.5)INPUT(IPLACE)=NASCII(33)
70	INCONT=MAXIN
	RETURN
100	IF(NODEC.EQ.0) GO TO 110
	NUMDEC=NODEC-1
	GO TO 120
110	EXPON=ALOG10(VALUE)
	IF(EXPON.GE.0.0)GO TO 112
	IEXPON=INT(EXPON-1.0)
	GO TO 114
112	IEXPON=INT(EXPON)
114	IF((IEXPON+1).GT.NOSIG) GO TO 115
	NUMDEC=NOSIG-(IEXPON+1)
	GO TO 120
115	NUMDEC=0
120	INOW=MAXIN
	XFRAC=VALUE*10.0**NUMDEC
123	IF(XFRAC.LT.BIGINT) GO TO 125
	XFRAC=XFRAC/10.0
	INPUT(INOW)=NASCII(49)
	INOW=INOW-1
	GO TO 123
125	IFRAC=INT(XFRAC+.5)
	LOCDEC=MAXIN-NUMDEC
126	IF(INOW-LOCDEC) 127,140,130
127	INPUT(LOCDEC)=NASCII(47)
	INPUT(INOW)=NASCII(49)
	GO TO 145
130	IX=IFRAC/10
	INPUT(INOW)=NASCII(49+IFRAC-10*IX)
	IFRAC=IX
	INOW=INOW-1
	GO TO 126
140	INPUT(INOW)=NASCII(47)
145	INOW=INOW-1
150	IF(IFRAC.LE.0) GO TO 160
	IX=IFRAC/10
	INPUT(INOW)=NASCII(49+IFRAC-10*IX)
	IFRAC=IX
	INOW=INOW-1
	GO TO 150
160	ISTOP=MAXIN
	IF(NODEC.GT.0) GO TO 180
170	IF(INPUT(ISTOP).NE.NASCII(49)) GO TO 180
	ISTOP=ISTOP-1
	GO TO 170
180	IF((ISTOP-INOW).LE.1) INPUT(ISTOP)=NASCII(49)
	IF(INPUT(ISTOP).EQ.NASCII(47)) ISTOP=ISTOP-1
	IF(ICOMMA.LE.0)GO TO 186
	ICOMMA=(LOCDEC-INOW-2)/3
	IF(ICOMMA.LE.0)GO TO 186
	NOSHOW=ISTOP-(INOW-ICOMMA)
	IF((IPLACE+NOSHOW).GT.MAXSHO)GO TO 200
	IPULL=INOW
	INOW=INOW-ICOMMA
	IPUT=INOW
	NCOMMA=LOCDEC-ICOMMA*4
182	IPULL=IPULL+1
	IPUT=IPUT+1
	IF(IPUT.NE.NCOMMA)GO TO 184
	INPUT(IPUT)=NASCII(45)
	ICOMMA=ICOMMA-1
	IF(ICOMMA.LE.0)GO TO 186
	NCOMMA=NCOMMA+4
	IPUT=IPUT+1
184	INPUT(IPUT)=INPUT(IPULL)
	GO TO 182
186	NOSHOW=ISTOP-INOW
	IF((IPLACE+NOSHOW).GT.MAXSHO) GO TO 200
	DO 190 I=1,NOSHOW
	INPUT(IPLACE)=INPUT(INOW+I)
190	IPLACE=IPLACE+1
	GO TO 55
200	IF(NODEC.EQ.0) GO TO 220
	DO 210 I=1,3
	INPUT(IPLACE)=NASCII(43)
210	IPLACE=IPLACE+1
	GO TO 55
220	IEXPON=0
230	IF(LOCDEC-INOW-2) 240,270,260
240	IEXPON=IEXPON-1
	IF(INPUT(LOCDEC+1).NE.NASCII(49)) GO TO 250
	LOCDEC=LOCDEC+1
	GO TO 240
250	INPUT(LOCDEC)=INPUT(LOCDEC+1)
	INPUT(LOCDEC+1)=NASCII(47)
	INOW=LOCDEC-1
	GO TO 270
260	INPUT(LOCDEC)=INPUT(LOCDEC-1)
	LOCDEC=LOCDEC-1
	INPUT(LOCDEC)=NASCII(47)
	IEXPON=IEXPON+1
	GO TO 230
270	NOSHOW=MIN0((ISTOP-INOW),(NOSIG))
	DO 280 I=1,NOSHOW
	INPUT(IPLACE)=INPUT(INOW+I)
280	IPLACE=IPLACE+1
290	IF(INPUT(IPLACE-1).NE.NASCII(49))GO TO 300
	IPLACE=IPLACE-1
	GO TO 290
300	INPUT(IPLACE)=NASCII(70)
	IF(IEXPON.GE.0)GO TO 350
	INPUT(IPLACE+1)=NASCII(46)
	IEXPON=-IEXPON
	GO TO 360
350	INPUT(IPLACE+1)=NASCII(44)
360	IF(IEXPON.GT.9)GO TO 370
	INPUT(IPLACE+2)=NASCII(49+IEXPON)
	IPLACE=IPLACE+3
	GO TO 55
370	IX=IEXPON/10
	INPUT(IPLACE+2)=NASCII(49+IX)
	INPUT(IPLACE+3)=NASCII(49+IEXPON-10*IX)
	IPLACE=IPLACE+4
	GO TO 55
	END
C
C
C
	FUNCTION FIXZZZ(RADIX,IOK)
C
C ROUTINE TO CONVERT FROM A1 CHARS INTO (THE FLOATING REPRESENTATION
C OF) AN INTEGER.  IT IS ASSUMED THAT THE SIGN IS HANDLED ELSEWHERE.
C ANY CHARS WHICH WOULD MAKE THE NUMBER GREATER THAN THE LARGEST
C REPRESENTABLE FLOATING POINT NUMBER ARE IGNORED.  THE
C SEARCH FOR NUMERIC CHARS IS STOPPED WHEN ANY NON-NUMERIC CHAR IS
C FOUND.
C
C RADIX =BASE (10,8,2, ETC.) TO WHICH NUMBER APPLIES.
C IOK   =RETURNED AS -1 IF NO NUMERIC CHAR FOUND, AND FIXNUM=0.0
C        OTHERWISE=+1
C COMMONS:
C INPUT = VECTOR WHERE A1 CHARS ARE TO BE FOUND
C INPOS =STARTING POINT FOR SEARCH IN INPUT. IF THIS POSITION
C        IS NOT NUMERIC, IOK=-1 AND RETURN.  RESET AS THE POSITION
C        OF THE LAST CHAR PROCESSED.
C INSIZE=MUST BE SET AS THE LAST SIGNIFICANT POSITION IN INPUT TO
C       BE SEARCHED.
C
	COMMON /C04ZZZ/ INPUT(320),INPOS,INSIZE,INCONT
	COMMON /C14ZZZ/ MAXDAT,MAXTMP,MAXROW,MAXCOL,MAXTRI,
     +  MAXRSK,MAXPRO,  MAXPFR,IWDSIZ,MAXOUT,MAXIN ,MAXTIT,
     +  MAXTWD,MAXTCH,  MAXCWD,MAXCCH,MAXRWD,MAXRCH,MSTDAL,
     +  MAXROP,MPFRAL,  MAXRAL,MAXVAR,MAXDWD,MAXEXP,EXPMAX,
     +  MINEXP,EXPMIN,  NOCONT,LENAME,MAXCPP,ICOLWD,LENEXT,
     +  MAXCOP
	COMMON /C01ZZZ/ NASCII(128)
	FIXZZZ=0.0
	DO 10 J=INPOS,INSIZE
	INO=NBRZZZ(INPUT(J))
	IF(INO.LT.0) GO TO 20
	IF(J.GE.(INPOS+MAXEXP)) GO TO 10
	FIXZZZ=FIXZZZ*RADIX+FLOAT(INO)
10	CONTINUE
	INPOS=INSIZE
	GO TO 30
20	IF(J.EQ.INPOS) GO TO 40
	INPOS=J-1
30	IOK=+1
	RETURN
40	IOK=-1
	RETURN
	END
C
C
C
	FUNCTION FLOZZZ(IOK)
C
C ROUTINE TO CONVERT FROM A1 CHARS INTO A FLOATING POINT
C NUMBER.  IT WILL HANDLE E FORMAT.  ANY CHARS WHICH WOULD MAKE THE
C NUMBER GREATER THAN THE LARGEST REPRESENTABLE FLOATING POINT NUMBER
C ARE IGNORED.  THE SEARCH FOR THE NUMBER IS TERMINATED BY ANY NON
C 'FLOATING POINT CHAR', SUCH AS A BLANK, A SECOND 'E', ETC.
C
C IOK   =RETURNED AS -1 IF NO NUMERIC DATA FOUND AND FLONUM=0.0
C        OTHERWISE=+1
C COMMONS:
C INPUT = VECTOR WHERE A1 CHARS ARE TO BE FOUND
C INPOS =STARTING POINT FOR SEARCH IN INPUT. IF THIS POSITION
C        IS NOT NUMERIC, IOK=-1 AND RETURN.  RESET AS THE POSITION
C        OF THE LAST CHAR PROCESSED.
C INSIZE=MUST BE SET AS THE LAST SIGNIFICANT POSITION IN INPUT TO
C       BE SEARCHED.
C
	COMMON /C04ZZZ/ INPUT(320),INPOS,INSIZE,INCONT
	COMMON /C14ZZZ/ MAXDAT,MAXTMP,MAXROW,MAXCOL,MAXTRI,
     +  MAXRSK,MAXPRO,  MAXPFR,IWDSIZ,MAXOUT,MAXIN ,MAXTIT,
     +  MAXTWD,MAXTCH,  MAXCWD,MAXCCH,MAXRWD,MAXRCH,MSTDAL,
     +  MAXROP,MPFRAL,  MAXRAL,MAXVAR,MAXDWD,MAXEXP,EXPMAX,
     +  MINEXP,EXPMIN,  NOCONT,LENAME,MAXCPP,ICOLWD,LENEXT,
     +  MAXCOP
	COMMON /C01ZZZ/ NASCII(128)
	FLOZZZ=0.0
	IF(INPUT(INPOS).NE.NASCII(47)) GO TO 10
	INPOS=INPOS+1
	IF(INPOS.GT.INSIZE) GO TO 5
	IOK=+1
	IF(NBRZZZ(INPUT(INPOS)).GE.0) GO TO 20
5	IOK=-1
	INPOS=INPOS-1
	RETURN
10	FLOZZZ=FIXZZZ(10.0,IOK)
	IF(IOK.LT.0) RETURN
	IF((INPOS+1).GT.INSIZE) RETURN
	IF(INPUT(INPOS+1).EQ.NASCII(70)) GO TO 40
	IF(INPUT(INPOS+1).NE.NASCII(47)) GO TO 90
	INPOS=INPOS+2
	IF(INPOS.LE.INSIZE) GO TO 20
	INPOS=INSIZE
	RETURN
20	IOSAVE=INPOS
	FPART=FIXZZZ(10.0,JOK)
	IPLACE=INPOS-IOSAVE+1
	IF(IPLACE.GT.MAXEXP) IPLACE=MAXEXP
	FLOZZZ=FLOZZZ+FPART*10.0**(-IPLACE)
	IF(JOK.LT.0)INPOS=INPOS-1
	IF(INPOS.GE.INSIZE) RETURN
	IF(INPUT(INPOS+1).NE.NASCII(70)) GO TO 90
40	IONEXT=INPOS+2
	IF(IONEXT.GT.INSIZE) RETURN
	ISIGN=ISNZZZ(INPUT(IONEXT))
	IF(ISIGN.EQ.0) GO TO 50
	IONEXT=IONEXT+1
	IF(IONEXT.GT.INSIZE) RETURN
50	IOSAVE=INPOS
	INPOS=IONEXT
	XPN=FIXZZZ(10.0,JOK)
	IF(JOK.GT.0) GO TO 60
	INPOS=IOSAVE
	RETURN
60	IF(ISIGN.LT.0) XPN=-XPN
	BASE=AINT(ALOG10(FLOZZZ)+EXPMAX+1.0)-EXPMAX
	IF((BASE+XPN).LE.EXPMAX) GO TO 75
	XPN=EXPMAX-BASE
	GO TO 80
75	IF((BASE+XPN).LT.EXPMIN) XPN=EXPMIN-BASE
80	FLOZZZ=FLOZZZ*10.0**XPN
	IF(INPOS.GE.INSIZE) RETURN
90	IF(INPUT(INPOS+1).NE.NASCII(38)) RETURN
	INPOS=INPOS+1
	FLOZZZ=FLOZZZ*.01
	RETURN
	END
C
C
C
	FUNCTION ISNZZZ(K)
C
C IF ALPHA A1 CHAR 'K' IS 1H+, IOSIGN=1
C IF                      1H-, IOSIGN=-1
C IF                  NEITHER, IOSIGN=0
C
	COMMON /C01ZZZ/ NASCII(128)
	ISNZZZ=0
	IF(K.EQ.NASCII(46)) GO TO 10
	IF(K.EQ.NASCII(44)) ISNZZZ=1
	RETURN
10	ISNZZZ=-1
	RETURN
	END
C
C
C
	FUNCTION LNMZZZ(ISTART,ISTOP)
C
C FINDS THE POSITION OF THE FIRST NUMERIC CHAR (0-9) BETWEEN
C ISTART AND ISTOP.  IF NONE FOUND, LOCNUM=-1. IF ONE IS FOUND,
C 'INPOS' IS RESET TO LOCNUM.
C
C ISTART & ISTOP=PASSED IN AS WHERE TO START AND STOP SEARCH FOR
C        NUMERIC CHAR.
C COMMONS:
C INPUT =VECTOR WHERE A1 CHARS ARE TO BE FOUND.
C INPOS =IS RESET TO LOCATION OF FIRST NUMBER BETWEEN ISTART
C        AND ISTOP. IF NO NUMBER FOUND, INPOS IS NOT CHANGED.
C
	COMMON /C04ZZZ/ INPUT(320),INPOS,INSIZE,INCONT
	DO 10 LNMZZZ=ISTART,ISTOP
	IF(NBRZZZ(INPUT(LNMZZZ)).GE.0) GO TO 20
10	CONTINUE
	LNMZZZ=-1
	RETURN
20	INPOS=LNMZZZ
	RETURN
	END
C
C
C
	FUNCTION ISCZZZ(ISTART,IARRAY,IAWD,MINCHR,MAXCHR)
C
C ROUTINE TO SCAN VECTOR 'INPUT' TO SEE IF IT MATCHES THE
C COMMAND IN IARRAY.  IF SUCCESSFUL, ISCAN RETURNS AS THE
C POSITION OF THE LAST CHAR IN INPUT SUCCESSFULLY MATCHED.
C IF FAILURE, ISCAN=-1.
C IF, AFTER A SUCCESSFUL MATCH, THE COMMAND IS FOUND TO CONTAIN
C TRAILING BLANKS, ISCAN IS RESET TO THE LAST NON-BLANK CHAR.
C
C ISTART=POSITION TO START THE SCAN IN INPUT.  IF LESS
C        THAN 1, ISCAN=-1.
C IARRAY=PASSED IN ARRAY OF ARBITRARY SHAPE AND SIZE CONTAINING
C        PACKED A5 CHARS TO BE MATCHED.
C IAWD  =PASSED IN AS WORD (NOT CHAR) IN IARRAY TELLING WHERE TO
C        START MATCHING. NO CHECK IS MAKE ON IAWD TO SEE IF
C        IT IS IN PROPER RANGE.
C MINCHR=PASSED IN AS THE MINIMUM NUMBER OF CHARS WHICH MUST BE
C        MATCHED TO BE SUCCESSFUL. IF MINCHR LESS THAN 1, ISCAN=-1
C MAXCHR=PASSED IN AS MAXIMUM NUMBER OF CHARS TO BE MATCHED.
C        IF MAXCHR LESS THAN 1, ISCAN=-1. WARNING: MINCHR CANNOT BE
C        GREATER THAN MAXCHR.
C
C COMMONS:
C INPUT =VECTOR WHERE USER ENTERED A1 CHARS ARE TO BE FOUND
C
	COMMON /C04ZZZ/ INPUT(320),INPOS,INSIZE,INCONT
	COMMON /C14ZZZ/ MAXDAT,MAXTMP,MAXROW,MAXCOL,MAXTRI,
     +  MAXRSK,MAXPRO,  MAXPFR,IWDSIZ,MAXOUT,MAXIN ,MAXTIT,
     +  MAXTWD,MAXTCH,  MAXCWD,MAXCCH,MAXRWD,MAXRCH,MSTDAL,
     +  MAXROP,MPFRAL,  MAXRAL,MAXVAR,MAXDWD,MAXEXP,EXPMAX,
     +  MINEXP,EXPMIN,  NOCONT,LENAME,MAXCPP,ICOLWD,LENEXT,
     +  MAXCOP
	COMMON /C08ZZZ/ IPAK(5)
	COMMON /C01ZZZ/ NASCII(128)
	DIMENSION IARRAY(1)
	IF(MINCHR.LE.0) GO TO 40
	IF(MAXCHR.LE.0) GO TO 40
	IF(ISTART.LT.1) GO TO 40
	MXCHR=MAXCHR
	IWD=IAWD
	ISCZZZ=ISTART
5	CALL UPKZZZ(IARRAY(IWD))
	MSTOP=MIN0(MXCHR,IWDSIZ)
	DO 10 M=1,MSTOP
	IF(ISCZZZ.GT.INSIZE) GO TO 20
	IF(INPUT(ISCZZZ).NE.IPAK(M)) GO TO 20
10	ISCZZZ=ISCZZZ+1
	MXCHR=MXCHR-IWDSIZ
	IF(MXCHR.LE.0) GO TO 20
	IWD=IWD+1
	GO TO 5
20	IF(ISCZZZ-ISTART.LT.MINCHR) GO TO 40
30	ISCZZZ=ISCZZZ-1
	IF(INPUT(ISCZZZ).EQ.NASCII(33)) GO TO 30
	RETURN
40	ISCZZZ=-1
	RETURN
	END
C
C
C
	SUBROUTINE RZZZ(LOGUNI,IEOF)
C
C ROUTINE TO ACCEPT INPUT FROM ANY DEVICE. WILL STRIP OFF LEADING
C LINE NUMBERS AND THE FIRST CHAR AFTER THE LINE NUMBER (USUALLY
C A TAB) IF THE FIRST DISK RECORD STARTS WITH A NUMBER. WILL READ
C UP TO 'INCONT' RECORDS IF LAST SIGNIFICANT CHAR IS '&'.
C
C LOGUNI=PASSED IN AS LOGICAL UNIT NUMBER.
C IEOF  =RETURNED AS 1 IF END-OF-FILE ENCOUNTERED
C
C COMMONS:
C INPUT(320)=A1 VECOTR INTO WHICH CHARS ARE READ
C INPOS = SET TO ZERO, CURRENT POINTER WITHIN INPUT.
C INSIZE=SET AT LAST SIGNIFICANT CHAR IN INPUT
C IRECNO=RECORD NUMBER, INCREMENTED BY READING
C ISTRIP=SET TO 1 IF NECESSARY TO STRIP OFF LINE NUMBERS,
C        OTHERWISE=0, SET TO ZERO BY CLOSE.
C
	COMMON /C04ZZZ/ INPUT(320),INPOS,INSIZE,INCONT
	COMMON /C05ZZZ/ ITTYI,ITTYO,IOFILE,IPOUT,IRECNO(2),ISTRIP(2),
     +  IROUTE,IRTOPN,IFFPOS,IOCMD,IOCMDN(2),IOCMDX(2),ICMDOP,ITTYSK,
     +  ITTYOC,ITTYOH,ICMDGR,ICMDUS,ISYSGR,ISYSUS
	COMMON /C01ZZZ/ NASCII(128)
	COMMON /C14ZZZ/ MAXDAT,MAXTMP,MAXROW,MAXCOL,MAXTRI,
     +  MAXRSK,MAXPRO,  MAXPFR,IWDSIZ,MAXOUT,MAXIN ,MAXTIT,
     +  MAXTWD,MAXTCH,  MAXCWD,MAXCCH,MAXRWD,MAXRCH,MSTDAL,
     +  MAXROP,MPFRAL,  MAXRAL,MAXVAR,MAXDWD,MAXEXP,EXPMAX,
     +  MINEXP,EXPMIN,  NOCONT,LENAME,MAXCPP,ICOLWD,LENEXT,
     +  MAXCOP
	COMMON /C07ZZZ/ LINOUT(136),LINPOS
	DIMENSION NAME(2),NAMEXT(2)
5	IEOF=0
	INPOS=0
	INSIZE=1
	DO 100 I=1,NOCONT
	LSTOP=INSIZE+79
	IF(LOGUNI.NE.ITTYI)GO TO 20
	IF(ICMDOP.NE.1)GO TO 10
	CALL MRDZZZ(IOCMD,INSIZE,LSTOP,LSIZE,IEOF)
	LCHAN=2
	IF(IEOF.NE.1)GO TO 30
	CALL CLOZZZ(IOCMD)
	ITTYSK=0
	ICMDOP=0
	LINPOS=ITTYOC
	CALL WZZZ(LOGUNI,ITTYOH)
	GO TO 5
10	CALL TRDZZZ(INPUT,INSIZE,LSTOP,LSIZE)
	GO TO 50
20	CALL MRDZZZ(LOGUNI,INSIZE,LSTOP,LSIZE,IEOF)
	LCHAN=1
	IF(IEOF.GE.1)GO TO 800
30	IRECNO(LCHAN)=IRECNO(LCHAN)+1
	IF(ISTRIP(LCHAN).EQ.1)GO TO 40
	IF(IRECNO(LCHAN).NE.2)GO TO 50
	NPOS=NBKZZZ(INPUT,INSIZE,LSTOP)
	IF(NPOS.LE.0) GO TO 50
	IF(NRCZZZ(INPUT(NPOS)).LT.0) GO TO 50
	ISTRIP(LCHAN)=1
40	CALL STRZZZ(INSIZE,LSTOP)
50	INSIZE=LSGZZZ(INPUT,1,LSTOP)
	IF(INSIZE.LE.0)GO TO 110
	IF(INPUT(INSIZE).NE.NASCII(39))GO TO 110
100	CONTINUE
110	IF(LSTOP.GE.INCONT)GO TO 130
120	INPUT(INCONT)=NASCII(33)
	INCONT=INCONT-1
	GO TO 110
130	INCONT=LSTOP
	IF(INSIZE.LE.0)GO TO 200
	DO 150 I=1,INSIZE
150	IF(INPUT(I).EQ.NASCII(10))INPUT(I)=NASCII(33)
200	IF(LOGUNI.NE.ITTYI)RETURN
	IF(ICMDOP.NE.1)GO TO 250
	IF(IRECNO(2).NE.2)RETURN
	IF(ISCZZZ(NBKZZZ(INPUT,1,INSIZE),9H*RESPONSE,1,3,9).GT.0)GO TO 5
	CALL SPKZZZ(16HWANTED *RESPONSE,16,1,0,1)
	GO TO 600
250	NPOS=NBKZZZ(INPUT,1,INSIZE)
	IF(INPUT(NPOS).NE.NASCII(65))RETURN
	INPUT(NPOS)=NASCII(33)
	KTTYOC=ITTYOC
	KTTYOH=ITTYOH
	DO 300 I=1,KTTYOC
300	LINOUT(MAXOUT-I)=LINOUT(I)
	CALL GETZZZ(NAME,NAMEXT,NGROUP,NUSER)
	IF(NAMZZZ(NAME,NAMEXT))600,600,500
500	CALL OPNZZZ(1,IOCMD,NAME,NAMEXT,NGROUP,NUSER,IOK)
	IF(IOK.LE.0)GO TO 600
	ICMDGR=NGROUP
	ICMDUS=NUSER
	ICMDOP=1
	ITTYSK=1
	GO TO 5
600	CALL SKPZZZ(ITTYO,1)
	DO 700 I=1,KTTYOC
700	LINOUT(I)=LINOUT(MAXOUT-I)
	LINPOS=KTTYOC
	CALL WZZZ(ITTYO,KTTYOH)
	GO TO 5
800	LSTOP=LSTOP-80
	GO TO 110
	END
C
C
C
	SUBROUTINE STRZZZ(ISTART,ISTOP)
C
C UTILITY TO 'READ' , STRIPS OFF LEADING LINE NUMBERS FROM
C POSITION ISTART TO ISTOP
C
	COMMON /C04ZZZ/ INPUT(320),INPOS,INSIZE,INCONT
	COMMON /C01ZZZ/ NASCII(128)
	IBEG=NBKZZZ(INPUT,ISTART,ISTOP)
	IF(IBEG.LE.0) RETURN
	IF(NRCZZZ(INPUT(IBEG)).LT.0) RETURN
	KOUNT=IBEG-ISTART
	DO 10 I=IBEG,ISTOP
	IF(NRCZZZ(INPUT(I)).LT.0) GO TO 20
10	KOUNT=KOUNT+1
20	IF(KOUNT.EQ.0) RETURN
	KOUNT=KOUNT+1
	IEND=ISTOP-KOUNT
	DO 30 I=ISTART,IEND
30	INPUT(I)=INPUT(I+KOUNT)
	DO 40 I=1,KOUNT
40	INPUT(I+IEND)=NASCII(33)
	RETURN
	END
C
C
C
	SUBROUTINE OPNZZZ(IODIR,LOGUNI,NAME,NAMEXT,NGROUP,NUSER,IOK)
C
C ROUTINE TO OPEN A DISK FILE FOR INPUT OR OUTPUT. FILES ARE CHECKED
C FOR PROPER MODES, PROTECTION CODES ETC. IMPROPER CHARACTERISTICS
C SET IOK=-1
C
C IODIR =PASSED IN 1=INPUT, OTHERWISE OUTPUT
C LOGUNI=PASSED AS LOGICAL UNIT #. IF TTY, SIMPLY RETURNS
C NAME  =A5 FILE NAME
C NAMEXT=A5 FILE EXTENSION
C IOK   =-1 IF FILE CANNOT BE OPENED.
C
C COMMONS:
C IRECNO=SET TO 1, UNLESS LOGUNI=TTY  POINTER WORD), WHEN INPUT
C	FILE OPENED.
C
	COMMON /C08ZZZ/ IPAK(5)
	COMMON /C01ZZZ/ NASCII(128)
	COMMON /C05ZZZ/ ITTYI,ITTYO,IOFILE,IPOUT,IRECNO(2),ISTRIP(2),
     +  IROUTE,IRTOPN,IFFPOS,IOCMD,IOCMDN(2),IOCMDX(2),ICMDOP,ITTYSK,
     +  ITTYOC,ITTYOH,ICMDGR,ICMDUS,ISYSGR,ISYSUS
	COMMON /C14ZZZ/ MAXDAT,MAXTMP,MAXROW,MAXCOL,MAXTRI,
     +  MAXRSK,MAXPRO,  MAXPFR,IWDSIZ,MAXOUT,MAXIN ,MAXTIT,
     +  MAXTWD,MAXTCH,  MAXCWD,MAXCCH,MAXRWD,MAXRCH,MSTDAL,
     +  MAXROP,MPFRAL,  MAXRAL,MAXVAR,MAXDWD,MAXEXP,EXPMAX,
     +  MINEXP,EXPMIN,  NOCONT,LENAME,MAXCPP,ICOLWD,LENEXT,
     +  MAXCOP
	COMMON /C09ZZZ/ MACBUF(128,2),MACLOC(2),MACCHR(2),MACSIZ,
     +  NUMBLK(2),NUMSIZ(2),MACOUT(2),MACCHN(2)
	DIMENSION NAME(2),NAMEXT(2)
	DIMENSION NAMTMP(2)
	DOUBLE PRECISION NAMDBL
	EQUIVALENCE (NAMTMP(1),NAMDBL)
	CALL C76ZZZ(NEW6,NAME(1),NAME(2))
	CALL C76ZZZ(NEXT6,NAMEXT(1),NAMEXT(2))
	LCHAN=LOGUNI-IOFILE+1
	IF(IODIR.EQ.1) GO TO 15
	IF(LOGUNI.NE.IOFILE)GO TO 10
	CALL OPMZZZ(2,NEW6,NEXT6,NGROUP,NUSER,MACCHN(LCHAN),IOK)
	IF(IOK.LT.0)GO TO 20
	MACLOC(LCHAN)=0
	MACOUT(LCHAN)=1
	IOK=1
	RETURN
10	CALL OPMZZZ(2,NEW6,NEXT6,NGROUP,NUSER,0,IOK)
	IF(IOK.LT.0)GO TO 20
	CALL CLMZZZ(0)
	JOK=JJ1ZZZ(LOGUNI)
	NAMTMP(1)=NAME(1)
	CALL UPKZZZ(NAME(2))
	I6=IPAK(1)
	CALL UPKZZZ(NAMEXT(1))
	IPAK(5)=IPAK(3)
	IPAK(4)=IPAK(2)
	IPAK(3)=IPAK(1)
	IPAK(2)=NASCII(47)
	IPAK(1)=I6
	CALL PKZZZ(NAMTMP(2))
	CALL DEFINE FILE(LOGUNI,132,IDUM,NAMDBL,NGROUP,NUSER)
	IFFPOS=0
	IOK=1
	RETURN
15	CALL OPMZZZ(1,NEW6,NEXT6,NGROUP,NUSER,MACCHN(LCHAN),IOK)
	IF(IOK.LT.0)GO TO 20
	CALL GSIZZZ(ISIZE)
	MACCHR(LCHAN)=IWDSIZ
	MACLOC(LCHAN)=MACSIZ
	NUMBLK(LCHAN)=0
	NUMSIZ(LCHAN)=MIN0((ISIZE-1)/MACSIZ+1,ISIZE)
	IRECNO(LCHAN)=1
	IOK=1
	IF(LOGUNI.NE.IOCMD)RETURN
	DO 16 I=1,2
	IOCMDN(I)=NAME(I)
16	IOCMDX(I)=NAMEXT(I)
	RETURN
20	CALL SPKZZZ(15HCAN'T OPEN FILE,15,1,0,1)
	IOK=-1
	RETURN
	END
C
C
C
	SUBROUTINE CLOZZZ(LOGUNI)
C
C RELEASES LOGICAL UNIT 'LOGUNI' AND SETS ISTRIP TO ZERO
C
	COMMON /C01ZZZ/ NASCII(128)
	COMMON /C09ZZZ/ MACBUF(128,2),MACLOC(2),MACCHR(2),MACSIZ,
     +  NUMBLK(2),NUMSIZ(2),MACOUT(2),MACCHN(2)
	COMMON /C05ZZZ/ ITTYI,ITTYO,IOFILE,IPOUT,IRECNO(2),ISTRIP(2),
     +  IROUTE,IRTOPN,IFFPOS,IOCMD,IOCMDN(2),IOCMDX(2),ICMDOP,ITTYSK,
     +  ITTYOC,ITTYOH,ICMDGR,ICMDUS,ISYSGR,ISYSUS
	IF(LOGUNI.NE.IROUTE)GO TO 10
	CALL RELEAS(LOGUNI)
	RETURN
10	IF(LOGUNI.EQ.IOCMD)GO TO 40
	IF(MACOUT(1).NE.1)GO TO 40
20	MACLOC(1)=MACLOC(1)+1
	IF(MACLOC(1).GT.MACSIZ)GO TO 30
	MACBUF(MACLOC(1),1)=0
	GO TO 20
30	CALL MIOZZZ(MACBUF,1,MACSIZ,2,MACCHN(1),IOK)
	MACOUT(1)=0
40	LCHAN=LOGUNI-IOFILE+1
	CALL CLMZZZ(MACCHN(LCHAN))
	ISTRIP(LCHAN)=0
	RETURN
	END
C
C
C
	SUBROUTINE WZZZ(LOGUNI,LHNG)
C
C ROUTINE TO WRITE TO DISK OR TTY, CUTTING OFF TRAILING BLANKS.
C WILL GIVE A CARRIAGE RETURN IF THERE IS NOTHING TO WRITE,
C UNLESS A HANGING CARRIAGE RETURN WAS SPECIFIED, IN WHICH CASE IT
C DOES NOTHING.
C
C LOGUNI=PASSED IN AS LOGICAL UNIT #
C LHNG  =PASSED IN AS =1 IF HANGING CARRIAGE RETURN (IN WHICH
C        CASE LOGUNI=TTY ASSUMED); OTHERWISE=0. TRAILING BLANKS ARE
C        PRINTED WHEN HANGING CR.
C
C COMMONS:
C LINOUT(136)=VECTOR FROM WHICH A1 CHARS ARE PRINTED
C LINPOS=PRINTS FROM 1 TO LINPOS, IGNORING TRAILING BLANKS UNLESS
C        HANGING. LINPOS ALWAYS RESET TO ZERO.
C
	COMMON /C07ZZZ/ LINOUT(136),LINPOS
	COMMON /C01ZZZ/ NASCII(128)
	COMMON /C05ZZZ/ ITTYI,ITTYO,IOFILE,IPOUT,IRECNO(2),ISTRIP(2),
     +  IROUTE,IRTOPN,IFFPOS,IOCMD,IOCMDN(2),IOCMDX(2),ICMDOP,ITTYSK,
     +  ITTYOC,ITTYOH,ICMDGR,ICMDUS,ISYSGR,ISYSUS
	DIMENSION IPAD(6)
	DATA IPAD/"065004020100,"051004020100,4*"001004020100/,NOPAD/6/
	KTTYOC=LINPOS
	IF(LHNG.EQ.1)GO TO 30
5	IF(LINPOS.LE.0)GO TO 10
	IF(LINOUT(LINPOS).NE.NASCII(33))GO TO 10
	LINPOS=LINPOS-1
	GO TO 5
10	IF(LOGUNI.EQ.IROUTE)GO TO 40
	DO 20 I=1,NOPAD
20	LINOUT(LINPOS+I)=IPAD(I)
	LINPOS=LINPOS+2
	IF(LOGUNI.EQ.ITTYO)GO TO 30
	CALL MWTZZZ
	GO TO 70
30	IF(ITTYSK.NE.1)CALL TWTZZZ(LINPOS,LINOUT)
	IF(KTTYOC.LE.0)GO TO 60
	ITTYOC=KTTYOC
	ITTYOH=LHNG
	GO TO 60
40	IF(LINPOS.LE.0)GO TO 80
	WRITE(LOGUNI,50)(LINOUT(L),L=1,LINPOS)
50	FORMAT(130A1)
60	IFFPOS=IFFPOS+1
70	LINPOS=0
	RETURN
80	WRITE(LOGUNI,90)
90	FORMAT(0X)
	GO TO 60
	END
C
C
C
	SUBROUTINE OUTZZZ(IPACK,IARRAY,ISTART,ICHRS,JUST,JFLAG,LOGUNI)
C
C ROUTINE TO LOAD UP THE A1 VECTOR 'LINOUT' TO GET READY FOR
C WRITING.  (CAN HAVE THE EFFECT OF CONCATENATION.)
C
C IPACK =PASSED IN AS =1 IF IARRAY IN A1 FORMAT, OTHERWISE
C        IARRAY ASSUMED TO BE A5 FORMAT
C IARRAY=PASSED IN AS A1 OR A5 ARRAY OF ARBITRARY SHAPE AND SIZE
C        CONTAINING THE CHARS TO BE OUTPUTTED.
C ISTART=PASSED IN AS THE WORD IN IARRAY TO START OUTPUTTING;
C        ASSUMED TO BE IN CORRECT RANGE.
C ICHRS =PASSED IN AS NUMBER OF CHARS TO BE OUTPUTTED. ANY
C        NUMBER CAN BE PASSED IN, BUT CENTERING, LEFT AND
C        RIGHT JUSTIFICATION WILL NOT WORK PROPERLY IF ICHRS IS
C        TOO LARGE.
C    JUST=                       JFLAG=
C    -----                       ------
C 1 MEANS RIGHT JUSTIFY          CHAR POSITION IN LINOUT WHERE STOP
C 2 MEANS LEFT JUSTIFY           CHAR POSITION IN LINOUT WHERE START
C 3 MEANS CONTINUE               =0
C 4 MEANS CENTER IN PAGE         WIDTH IN CHARS IN WHICH TO BE CENTERED
C
C CONVENTIONS:
C 1 & 2 RIGHT & LEFT JUSTIFY: IF THE BUFFER ALREADY CONTAINS
C   TOO MANY CHARS SO THAT THE NEW ONES CANNOT FIT, THE BUFFER IS
C   FIRST DUMPED. IF JFLAG IS GREATER THAN THE BUFFER SIZE, THE
C   BUFFER IS "LOGICALLY" EXTENDED WITH AN INTERVENING CR.
C 3 CONTINUE: CHARACTERS ARE INSERTED STARTING WHERE THE OLD
C   'LINPOS' LEFT OFF. IF THE BUFFER BECOMES FULL, IT IS DUMPED.
C 4 CENTER: THE BUFFER IS ALWAYS IMMEDIATELY DUMPED IF THE CENTERED
C   CHARACTERS WILL OVERLAP THE CURRENT CONTENTS. IF THE CHARACTERS
C   ARE TOO LONG TO BE FIT INTO THE WIDTH, THE WIDTH IS "LOGICALLY"
C   EXTENDED WITH AN INTERVENING CR. (THIS DOES NOT PRODUCE
C   CENTERING.)
C
C LOGUNI=PASSED IN LOGICAL UNIT #
C
C COMMONS:
C LINOUT=A1 VECTOR INTO WHICH ALPHAS ARE LOADED
C LINPOS=CURRENT POINTER OF LINOUT, ALWAYS SITTING AT LAST CHAR
C        PROCESSED; SET TO ZERO BY WRITE. ALWAYS SET TO
C        LAST ELEMENT PROCESSED.
C
	COMMON /C07ZZZ/ LINOUT(136),LINPOS
	COMMON /C01ZZZ/ NASCII(128)
	COMMON /C14ZZZ/ MAXDAT,MAXTMP,MAXROW,MAXCOL,MAXTRI,
     +  MAXRSK,MAXPRO,  MAXPFR,IWDSIZ,MAXOUT,MAXIN ,MAXTIT,
     +  MAXTWD,MAXTCH,  MAXCWD,MAXCCH,MAXRWD,MAXRCH,MSTDAL,
     +  MAXROP,MPFRAL,  MAXRAL,MAXVAR,MAXDWD,MAXEXP,EXPMAX,
     +  MINEXP,EXPMIN,  NOCONT,LENAME,MAXCPP,ICOLWD,LENEXT,
     +  MAXCOP
	COMMON /C08ZZZ/ IPAK(5)
	DIMENSION IARRAY(1)
	IF(ICHRS.LE.0) RETURN
	GO TO (100,200,300,400), JUST
C
100	IBEG=JFLAG-ICHRS+1
	IEND=JFLAG
C ENTRY POINT FOR LEFT AND RIGHT JUSTIFICATION
110	IF(IBEG-(LINPOS+1)) 120,150,130
120	CALL WZZZ(LOGUNI,0)
C ENTRY POINT FOR CENTERING
130	IBSTAR=LINPOS+1
	IBSTO=IBEG-1
	DO 140 LINPOS=IBSTAR,IBSTO
140	LINOUT(LINPOS)=NASCII(33)
	LINPOS=IBSTO
C ENTRY POINT FOR CONTINUING
150	DO 160 I=IBEG,IEND
	IF(LINPOS.GE.MAXOUT) CALL WZZZ(LOGUNI,0)
	LINPOS=LINPOS+1
	IF(IPACK.EQ.1)GO TO 155
	NOWNO=MOD(I-IBEG,IWDSIZ)+1
	IF(NOWNO.EQ.1)CALL UPKZZZ(IARRAY(ISTART+(I-IBEG)/IWDSIZ))
	LINOUT(LINPOS)=IPAK(NOWNO)
	GO TO 160
155	LINOUT(LINPOS)=IARRAY(ISTART+I-IBEG)
160	CONTINUE
	RETURN
200	IBEG=JFLAG
	IEND=IBEG+ICHRS-1
	GO TO 110
300	IBEG=LINPOS+1
	IEND=IBEG+ICHRS-1
	GO TO 150
400	IBEG=(JFLAG-ICHRS)/2+1
	IF(IBEG.LE.LINPOS) CALL WZZZ(LOGUNI,0)
	IF(IBEG.LT.1) IBEG=1
	IEND=IBEG+ICHRS-1
	GO TO 130
	END
C
C
C
	SUBROUTINE ASKZZZ(MSG,NOCHRS,ISKIP,IHNG)
C
C PUTS OUT A MESSAGE, LEFT JUSTIFIED, ON THE TTY
C AND THEN GETS A RESPONSE READ INTO 'INPUT'
C
C MSG   =PASSED IN AS ARRAY OF ARBITRARY SHAPE AND SIZE
C        PACKED A5 WITH ALPHAS TO BE DISPLAYED.
C NOCHRS=PASSED IN AS NUMBER OF CHARS TO BE SHOWN
C ISKIP =NUMBER OF LINES TO SKIP BEFORE PRINTING
C IHNG  =1 MEANS HANG THE CARRIAGE RETURN, OTHERWISE NO HANG.
C
	COMMON /C05ZZZ/ ITTYI,ITTYO,IOFILE,IPOUT,IRECNO(2),ISTRIP(2),
     +  IROUTE,IRTOPN,IFFPOS,IOCMD,IOCMDN(2),IOCMDX(2),ICMDOP,ITTYSK,
     +  ITTYOC,ITTYOH,ICMDGR,ICMDUS,ISYSGR,ISYSUS
	DIMENSION MSG(1)
	CALL CR1ZZZ
	CALL SPKZZZ(MSG,NOCHRS,ISKIP,IHNG,0)
	CALL RZZZ(ITTYO,IEOF)
	RETURN
	END
C
C
C
	SUBROUTINE SPKZZZ(MSG,NOCHRS,ISKIP,IHNG,IERMSG)
C
C PUTS OUT A MESSAGE, LEFT JUSTIFIED, ON THE TTY
C
C MSG   =PASSED IN AS ARRAY OF ARBITRARY SHAPE AND SIZE
C        PACKED A5 WITH ALPHAS TO BE DISPLAYED.
C NOCHRS=PASSED IN AS NUMBER OF CHARS TO BE SHOWN
C ISKIP =NUMBER OF LINES TO SKIP BEFORE PRINTING
C IHNG  =1 MEANS HANG THE CARRIAGE RETURN, OTHERWISE NO HANG.
C IERMSG=ERROR MESSAGE FLAG (1=ERROR MSG,0=NO ERROR)
C
	COMMON /C05ZZZ/ ITTYI,ITTYO,IOFILE,IPOUT,IRECNO(2),ISTRIP(2),
     +  IROUTE,IRTOPN,IFFPOS,IOCMD,IOCMDN(2),IOCMDX(2),ICMDOP,ITTYSK,
     +  ITTYOC,ITTYOH,ICMDGR,ICMDUS,ISYSGR,ISYSUS
	COMMON /C04ZZZ/ INPUT(320),INPOS,INSIZE,INCONT
	DIMENSION MSG(1)
	IF(IERMSG.LE.0)GO TO 100
	IF(ICMDOP.LE.0)GO TO 100
	CALL CLOZZZ(IOCMD)
	ITTYSK=0
	ICMDOP=0
	CALL SKPZZZ(ITTYO,ISKIP)
	CALL OUTZZZ(2,24HRESPONSE FILE CLOSED AT:,1,24,2,1,ITTYO)
	CALL WZZZ(ITTYO,0)
	CALL OUTZZZ(1,INPUT,1,INSIZE,2,1,ITTYO)
	CALL WZZZ(ITTYO,0)
	GO TO 200
100	CALL SKPZZZ(ITTYO,ISKIP)
200	CALL OUTZZZ(2,MSG,1,NOCHRS,2,1,ITTYO)
	CALL WZZZ(ITTYO,IHNG)
	RETURN
	END
C
C
C
	SUBROUTINE SKPZZZ(LOGUNI,NO)
C
C SKIPS 'NO' NUMBER OF LINES ON LOGICAL UNIT 'LOGUNI'. ALWAYS
C EMPTIES BUFFER 'LINOUT' PRIOR TO SKIPPING.  JUST RETURNS
C IF 'NO' LESS THAN OR EQUAL TO ZERO
C
	IF(NO.LE.0) RETURN
	DO 10 I=1,NO
10	CALL WZZZ(LOGUNI,0)
	RETURN
	END
C
C
C
	SUBROUTINE GETZZZ(NAME,NAMEXT,NGROUP,NUSER)
C
C ASSUMING A REQUEST FOR A FILE NAME HAS BEEN DONE ELSEWHERE,
C GETNAM PACKS UP TO 'LENAME' CHARS FROM INPUT STARTING AT THE FIRST
C NON-BLANK AFTER INPOS AND ENDING AT THE LAST CHAR BEFORE THE
C NEXT BLANK OR COMMA. NAMES SHORTER THAN LENAME ARE
C PADDED WITH BLANKS.
C
C NAME  =RETURNED AS A5 FILENAME, ALL BLANKS IF NO RESPONSE.
C        NOT CHECKED FOR VALIDITY.
C NAMEXT=RETURNED AS A5 FILE EXTENSION, ALL BLANKS IF NO RESPONSE.
C        NOT CHECKED FOR VALIDITY
C NGROUP=RETURNED AS OCTAL GROUP (PROJECT) NO.
C NUSER =RETURNED AS OCTAL USER (PROGRAMMER) NO.
C
C COMMONS:
C INPUT =CONTAINS CHARS MAKING UP FILENAME
C INPOS =BEGINNING OF SEARCH FOR FILENAME STARTS ONE AFTER INPOS
C        RESET TO THE POSITION OF THE LAST CHAR IN FILENAME.
C
	COMMON /C05ZZZ/ ITTYI,ITTYO,IOFILE,IPOUT,IRECNO(2),ISTRIP(2),
     +  IROUTE,IRTOPN,IFFPOS,IOCMD,IOCMDN(2),IOCMDX(2),ICMDOP,ITTYSK,
     +  ITTYOC,ITTYOH,ICMDGR,ICMDUS,ISYSGR,ISYSUS
	COMMON /C04ZZZ/ INPUT(320),INPOS,INSIZE,INCONT
	COMMON /C14ZZZ/ MAXDAT,MAXTMP,MAXROW,MAXCOL,MAXTRI,
     +  MAXRSK,MAXPRO,  MAXPFR,IWDSIZ,MAXOUT,MAXIN ,MAXTIT,
     +  MAXTWD,MAXTCH,  MAXCWD,MAXCCH,MAXRWD,MAXRCH,MSTDAL,
     +  MAXROP,MPFRAL,  MAXRAL,MAXVAR,MAXDWD,MAXEXP,EXPMAX,
     +  MINEXP,EXPMIN,  NOCONT,LENAME,MAXCPP,ICOLWD,LENEXT,
     +  MAXCOP
	COMMON /C01ZZZ/ NASCII(128)
	COMMON /C08ZZZ/ IPAK(5)
	DIMENSION NAME(2),NAMEXT(2),IBLANK(2),IXSUM(2)
	DATA IBLANK /2*5H     /, IXSUM /2*5H     /
	DATA IBAD/5H*****/
	DO 2 I=1,2
	NAMEXT(I)=IXSUM(I)
2	NAME(I)=IBLANK(I)
	NGROUP=0
	NUSER=0
	IF(INSIZE.LE.0) RETURN
	IBEG=NBKZZZ(INPUT,INPOS,INSIZE)-1
	KSIZE=INSIZE
	KEND=0
	IF(ISCZZZ(IBEG+1,5HSYS: ,1,4,4).LT.0)GO TO 4
	IBEG=IBEG+4
	IF(IBEG.GT.INSIZE)RETURN
	NGROUP=ISYSGR
	NUSER=ISYSUS
	GO TO 5
4	IBKT=LOCZZZ(NASCII(92),INPOS,INSIZE-1)
	IF(IBKT.LE.IBEG)GO TO 5
	INSAVE=INPOS
	INPOS=IBKT+1
	NGROUP=FIXZZZ(8.0,IOK)
	IF(IOK.LE.0)GO TO 40
	INPOS=INPOS+2
	NUSER=FIXZZZ(8.0,IOK)
	IF(IOK.LE.0)GO TO 40
	KEND=INPOS
	IF(INPUT(KEND+1).EQ.NASCII(94))KEND=KEND+1
	INPOS=INSAVE
	INSIZE=IBKT-1
5	IDOT=LOCZZZ(NASCII(47),INPOS,INSIZE)
	IEND=IDOT-1
	IF(IEND.LE.0)IEND=INSIZE
	ISTOP=((LENAME-1)/IWDSIZ+1)*IWDSIZ
	DO 10 I=1,ISTOP
	IKUR=IBEG+I
	K=I-((I-1)/IWDSIZ)*IWDSIZ
	IF(IKUR.LE.IEND) IPAK(K)=INPUT(IKUR)
	IF(IKUR.GT.IEND) IPAK(K)=NASCII(33)
10	IF(MOD(I,IWDSIZ).EQ.0) CALL PKZZZ(NAME((I-1)/IWDSIZ+1))
	IF(IDOT.LE.0)GO TO 30
	IEND=INSIZE
	ISTOP=((LENEXT-1)/IWDSIZ+1)*IWDSIZ
	DO 20 I=1,ISTOP
	IKUR=IDOT+I
	K=I-((I-1)/IWDSIZ)*IWDSIZ
	IF(IKUR.LE.IEND)IPAK(K)=INPUT(IKUR)
	IF(IKUR.GT.IEND)IPAK(K)=NASCII(33)
20	IF(MOD(I,IWDSIZ).EQ.0)CALL PKZZZ(NAMEXT((I-1)/IWDSIZ+1))
30	INPOS=MAX0(IEND,KEND)
	INSIZE=KSIZE
	RETURN
40	NAME(1)=IBAD
	RETURN
	END
C
C
C
	FUNCTION NAMZZZ(NAME,NAMEXT)
C
C ENSURES THAT FILENAME IS SYNTACTICALLY VALID, I.E.
C ALL CHARS ARE ALPHANUMERIC AND THE FIRST IS ALPHABETIC.
C
C RETURNS -1 IF NAME INCORRECT
C          0 IF NAME ALL BLANKS
C         +1 IF NAME OK
C
C WHEN NAMCHK=-1, 'BAD FILE NAME' WILL HAVE ALREADY BEEN DISPLAYED.
C
C NAME  =PASSED IN AS A5 FILE NAME
C NAMEXT=PASSED IN AS A5 FILE EXTENSION
C
	COMMON /C14ZZZ/ MAXDAT,MAXTMP,MAXROW,MAXCOL,MAXTRI,
     +  MAXRSK,MAXPRO,  MAXPFR,IWDSIZ,MAXOUT,MAXIN ,MAXTIT,
     +  MAXTWD,MAXTCH,  MAXCWD,MAXCCH,MAXRWD,MAXRCH,MSTDAL,
     +  MAXROP,MPFRAL,  MAXRAL,MAXVAR,MAXDWD,MAXEXP,EXPMAX,
     +  MINEXP,EXPMIN,  NOCONT,LENAME,MAXCPP,ICOLWD,LENEXT,
     +  MAXCOP
	DIMENSION NAME(2),NAMEXT(2)
	CALL FNVZZZ(NAME,IFL)
	CALL FNVZZZ(NAMEXT,JFL)
	NAMZZZ=-1
	IF(IFL)30,20,10
10	IF(JFL.LE.-1)GO TO 30
	NAMZZZ=1
	RETURN
20	IF(JFL.NE.0)GO TO 30
	NAMZZZ=0
30	IF(NAMZZZ.LE.-1)CALL SPKZZZ(13HBAD FILE NAME,13,1,0,1)
	RETURN
	END
C
C
C
	SUBROUTINE FNVZZZ(LNAME,LFLAG)
C
C THIS ROUTINE CHECKS THE FILE NAMES AND EXTENSIONS TO INSURE THAT
C THEY ARE ALPHANUMERIC
C
C LNAME=VECTOR CONTAINING NAME OR EXTENSION
C LFLAG=+1 IF OK, 0 IF BLANK, -1 IF NON-ALPHANUMERIC
C
	COMMON /C14ZZZ/ MAXDAT,MAXTMP,MAXROW,MAXCOL,MAXTRI,
     +  MAXRSK,MAXPRO,  MAXPFR,IWDSIZ,MAXOUT,MAXIN ,MAXTIT,
     +  MAXTWD,MAXTCH,  MAXCWD,MAXCCH,MAXRWD,MAXRCH,MSTDAL,
     +  MAXROP,MPFRAL,  MAXRAL,MAXVAR,MAXDWD,MAXEXP,EXPMAX,
     +  MINEXP,EXPMIN,  NOCONT,LENAME,MAXCPP,ICOLWD,LENEXT,
     +  MAXCOP
	COMMON /C08ZZZ/ IPAK(5)
	COMMON /C01ZZZ/ NASCII(128)
	DIMENSION LNAME(2)
	LFLAG=-1
	ISTOP=LASZZZ(LNAME,1,2)
	IF(ISTOP.GT.0)GO TO 10
	LFLAG=0
	RETURN
10	DO 20 I=1,ISTOP
	IF(MOD(I,IWDSIZ).EQ.1)CALL UPKZZZ(LNAME((I-1)/IWDSIZ+1))
	ICHR=IPAK(I-((I-1)/IWDSIZ)*IWDSIZ)
20	IF(IBNZZZ(ICHR).LT.0)RETURN
	LFLAG=1
	RETURN
	END
C
C
C
	SUBROUTINE COMZZZ(INOW,ICOMAN,ISTART,ISTOP,NOGOT)
C
C THIS ROUTINE CHECKS A PASSED STRING OF PACKED COMMAND ALPHANUMERICS
C AGAINST THE CURRENT CONTENTS OF THE INPUT BUFFER AND PASSES BACK THE
C NUMBER OF THE COMMAND WHICH MATCHES.
C
C INOW=CURRENT POSITION WITHIN INPUT BUFFER
C ICOMAN=STRING OF PACKED COMMANDS PASSED IN
C ISTART=1ST COMMAND TO CHECK AGAINST
C ISTOP=LAST COMMAND TO CHECK AGAINST
C NOGOT=NUMBER OF MATCHED COMMAND RELATIVE TO START.  (IF NO MATCH
C       FOUND, NOGOT IS SET TO 1 GREATER THAN THE NUMBER OF THE LAST
C       POSSIBLE MATCHED COMMAND RELATIVE TO THE START.)
C
	COMMON /C04ZZZ/ INPUT(320),INPOS,INSIZE,INCONT
	DIMENSION ICOMAN(1)
	NOGOT=1
	DO 10 I=ISTART,ISTOP
	INPOS=ISCZZZ(INOW,ICOMAN,2*I-1,3,10)
	IF(INPOS.GT.0)RETURN
10	NOGOT=NOGOT+1
	RETURN
	END
C
C
C
	SUBROUTINE INPZZZ(ISTART,INSTOP,VALUE,NOWANT,NOGOT)
C
C THIS ROUTINE WILL LOCATE AND CONTROL THE INTERPRETATION OF NOWANT
C INPUT VALUES STARTING AT ISTART IN THE INPUT VECTOR.
C
C ISTART=LOCATION IN INPUT TO START INTERPRETING VALUES
C VALUE=VECTOR TO RETURN INTERPRETED INPUT VALUES
C NOWANT=NUMBER OF INPUT VALUES WANTED
C NOGOT=NUMBER OF INPUT VALUES FOUND
C
	COMMON /C04ZZZ/ INPUT(320),INPOS,INSIZE,INCONT
	COMMON /C01ZZZ/ NASCII(128)
	DIMENSION VALUE(NOWANT)
	DO 10 I=1,NOWANT
10	VALUE(I)=0.0
	NOGOT=0
	INOW=ISTART
	ISTOP=INSTOP
	IF(ISTOP.LE.0)ISTOP=INSIZE
	ISIGN=0
20	IF(INOW.GT.ISTOP)RETURN
	IF(LNMZZZ(INOW,ISTOP).LT.0)RETURN
	IF(INPOS.LE.1)GO TO 30
	IF(INPUT(INPOS-1).EQ.NASCII(47))INPOS=INPOS-1
	IF(INPOS.GT.1)ISIGN=ISNZZZ(INPUT(INPOS-1))
30	NOGOT=NOGOT+1
	VALUE(NOGOT)=FLOZZZ(IOK)
	IF(ISIGN.LT.0)VALUE(NOGOT)=-VALUE(NOGOT)
	IF(NOGOT.GE.NOWANT)RETURN
	INOW=INPOS+1
	GO TO 20
	END
C
C
C
C
C
C
	FUNCTION LASZZZ(IARRAY,ISTART,ISTOP)
C
C THIS ROUTINE WILL CONTROL THE CALCULATION OF THE LAST SIGNIFICANT
C CHARACTER IN IARRRAY BETWEEN TWO GIVEN WORDS, ISTART AND ISTOP.
C IF NO SIGNIFICANT CHARACTERS ARE FOUND, THE FUNCTION TAKES ON THE
C DEFAULT VALUE OF LASSIG WHICH IS -1.
C
C IARRAY=ARRAY WHERE LAST SIGNIFICANT CHARACTER IS TO BE FOUND
C ISTART=FIRST WORD IN ARRAY WHERE CHARACTER CAN BE FOUND
C ISTOP=LAST WORD IN ARRAY WHERE CHARACTER CAN BE FOUND
C
	COMMON /C01ZZZ/ NASCII(128)
	COMMON /C14ZZZ/ MAXDAT,MAXTMP,MAXROW,MAXCOL,MAXTRI,
     +  MAXRSK,MAXPRO,  MAXPFR,IWDSIZ,MAXOUT,MAXIN ,MAXTIT,
     +  MAXTWD,MAXTCH,  MAXCWD,MAXCCH,MAXRWD,MAXRCH,MSTDAL,
     +  MAXROP,MPFRAL,  MAXRAL,MAXVAR,MAXDWD,MAXEXP,EXPMAX,
     +  MINEXP,EXPMIN,  NOCONT,LENAME,MAXCPP,ICOLWD,LENEXT,
     +  MAXCOP
	COMMON /C08ZZZ/ IPAK(5)
	DIMENSION IARRAY(1)
	LASZZZ=LSGZZZ(IARRAY,ISTART,ISTOP)
	IF(LASZZZ.LE.0)RETURN
	CALL UPKZZZ(IARRAY(LASZZZ))
	LASZZZ=(LASZZZ-1)*IWDSIZ+LSGZZZ(IPAK,1,IWDSIZ)
	RETURN
	END
C
C
C
	FUNCTION LOCZZZ(NASCHR,ISTART,ISTOP)
C
C FINDS LOCATION OF ANY CHAR 'NASCHR' IN INPUT BETWEEN ISTART
C AND ISTOP. IF NONE FOUND, LOCCHR=-1.
C
C NASCHR=THE CHAR WHICH IS TO BE SEARCHED FOR
C ISTART & ISTOP=STARTING AND STOPING LOCATIONS WHERE TO LOOK IN INPUT
C
	COMMON /C04ZZZ/ INPUT(320),INPOS,INSIZE,INCONT
	LOCZZZ=MAX0(ISTART,1)
10	IF(LOCZZZ.GT.ISTOP) GO TO 20
	IF(INPUT(LOCZZZ).EQ.NASCHR) RETURN
	LOCZZZ=LOCZZZ+1
	GO TO 10
20	LOCZZZ=-1
	RETURN
	END
C
C
C
	SUBROUTINE RPRZZZ(IALLOW,SAVSUB,NAMRUN,NEXRUN)
C
C THIS ROUTINE WILL ALLOW ANY PROFILE PROGRAM TO ACCESS ANY
C OTHER PROFILE PROGRAM.  THIS AVOIDS HAVING TO FIRST
C EXIT TO THE MONITOR AN INITIATE THE OTHER PROGRAM.
C
C IALLOW=FLAG TO CLOSE ROUTE FILE IF COMING FROM PROFILE
C SAVSUB=EXTERNAL SUBROUTINE TO SAVE PRIOR TO LEAVING
C
	COMMON /C18ZZZ/ IAGRUS(2),IOCTGR,IOCTUS
	COMMON /C05ZZZ/ ITTYI,ITTYO,IOFILE,IPOUT,IRECNO(2),ISTRIP(2),
     +  IROUTE,IRTOPN,IFFPOS,IOCMD,IOCMDN(2),IOCMDX(2),ICMDOP,ITTYSK,
     +  ITTYOC,ITTYOH,ICMDGR,ICMDUS,ISYSGR,ISYSUS
	COMMON /C04ZZZ/ INPUT(320),INPOS,INSIZE,INCONT
	DIMENSION IPRO(3),KPRO(3),KPROX(3),NAMRUN(2),NEXRUN(2)
	DATA IPRO/1HF,1HR,1HD/
	DATA KPRO/5HPROFI,5HPRORE,5HPRODE/
	DATA KPROX/5HL    ,5HP    ,5HP    /
	DATA IPRBIL/5HPRBIL/
	EXTERNAL SAVSUB
	DO 100 I=1,3
	IF(INPUT(INPOS+1).EQ.IPRO(I))GO TO 200
100	CONTINUE
	RETURN
200	IOK=1
	IF(IOUZZZ(6HSAVE? ,6,1,1).GE.1)CALL SAVSUB(IOK)
	IF(IOK.LE.0)GO TO 200
	IF(IALLOW.EQ.1)CALL CLOZZZ(IROUTE)
	CALL PR1ZZZ(NAMRUN,NEXRUN)
	CALL C76ZZZ(NEW6,KPRO(I),KPROX(I))
	CALL VALPR3(4,352,IPRBIL,"13063000)
	IF(IOCTGR.NE.ISYSGR)GO TO 300
	IF(IOCTUS.NE.ISYSUS)GO TO 300
	CALL C76ZZZ(IDSK,5HSYS  ,1H )
	CALL RUPZZZ(IDSK,NEW6,0,0,0,ICMDOP)
	CALL VALPR3(3,352,IPRBIL,"13063000)
	RETURN
300	CALL C76ZZZ(IDSK,5HDSK  ,1H )
	CALL RUPZZZ(IDSK,NEW6,0,IOCTGR,IOCTUS,ICMDOP)
	CALL VALPR3(3,352,IPRBIL,"13063000)
	RETURN
	END
C
C
C
	FUNCTION IOUZZZ(MSG,NOCHRS,ISKIP,IHNG)
C
C PUTS OUT A MESSAGE, LEFT JUSTIFIED, ON THE TTY
C AND THEN GETS A RESPONSE READ INTO 'INPUT'
C AND THEN CHECKS TO SEE IF RESPONSE WAS POSITIVE OR NEGATIVE
C IF 'YES' IOUI=+   IF 'NO', IOUI=-1
C
C MSG   =PASSED IN AS ARRAY OF ARBITRARY SHAPE AND SIZE
C        PACKED A5 WITH ALPHAS TO BE DISPLAYED.
C NOCHRS=PASSED IN AS NUMBER OF CHARS TO BE SHOWN
C ISKIP =NUMBER OF LINES TO SKIP BEFORE PRINTING
C IHNG  =1 MEANS HANG THE CARRIAGE RETURN, OTHERWISE NO HANG.
C
	COMMON /C04ZZZ/ INPUT(320),INPOS,INSIZE,INCONT
	DIMENSION MSG(1)
	IOUZZZ=1
	CALL ASKZZZ(MSG,NOCHRS,ISKIP,IHNG)
	ISTART=NBKZZZ(INPUT,1,INSIZE)
	IF(ISTART.LE.0)RETURN
	IOUZZZ=ISCZZZ(ISTART,3HYES,1,1,3)
	INPOS=IOUZZZ
	RETURN
	END
C
C
C
	SUBROUTINE UNSZZZ
C
C ASKS FOR A FILENAME AND UNSAVES THAT FILE.  IF NO RESPONSE,
C RETURNS. IF ILLEGAL FILE NAME, SAYS 'BAD FILE NAME' AND RETURNS
C
	DIMENSION NAME(2),NAMEXT(2)
	DATA IBLANK /0/
	CALL ASKZZZ(11HFILE NAME? ,11,1,1)
	CALL GETZZZ(NAME,NAMEXT,NGROUP,NUSER)
	IF(NAMZZZ(NAME,NAMEXT).LE.0) RETURN
	CALL C76ZZZ(NEW6,NAME(1),NAME(2))
	CALL C76ZZZ(NEXT6,NAMEXT(1),NAMEXT(2))
	CALL FFXZZZ(IBLANK,IBLANK,NEW6,NEXT6,MODE,IPROT,ISIZE,
     +  ITIME,IDATE,NGROUP,NUSER,IOK,JOK)
	IF(JOK.LT.0)CALL SPKZZZ(17HCAN'T UNSAVE FILE,17,1,0,1)
	RETURN
	END
C
C
C
	SUBROUTINE TWOZZZ(ID1,ID2,IAD1,IAD2,IMAX,IOK)
C
C THIS ROUTINE WILL CONTROL THE INTERPRETING OF TWO INTEGER VALUES
C FOUND IN THE INPUT VECTOR.
C
C ID1=FIRST INTERPRETED INTEGER VALUE
C ID2=SECOND INTERPRETED INTEGER VALUE
C IAD1=VALUE TO ASSUME FOR FIRST INTEGER VALUE IF NONE FOUND
C IAD2=VALUE TO ASSUME FOR SECOND INTEGER VALUE IF NONE FOUND
C IMAX=MAXIMUM ALLOWED VALUE FOR EITHER INTEGER
C IOK=ERROR FLAG  (-1=BAD INFO, 0=NO INFO, +1=GOOD INFO)
C
	COMMON /C04ZZZ/ INPUT(320),INPOS,INSIZE,INCONT
	DIMENSION VALUE(2)
	CALL INPZZZ(INPOS+1,0,VALUE,2,NOGOT)
	ID1=INT(VALUE(1)+.5)
	ID2=INT(VALUE(2)+.5)
	IF(NOGOT-1)20,10,30
10	ID2=ID1
	GO TO 40
20	ID1=IAD1
	ID2=IAD2
30	IF(ID2.LT.ID1)ID2=ID1
40	IF(ID1.LE.0)GO TO 50
	IF(ID2.GT.IMAX)GO TO 50
	IOK=1
	RETURN
50	IOK=-1
	CALL SPKZZZ(13HCOMMAND ERROR,13,1,0,1)
	RETURN
	END
C
C
C
	SUBROUTINE MWTZZZ
C
C THIS ROUTINE WILL WRITE OUT THE CURRENT CONTENTS OF LINOUT (FROM
C 1 TO LINPOS) INTO THE MACRO IO BUFFER (MACBUF) AND DUMP THE BUFFER
C IF THE BUFFER GETS FULL.
C
	COMMON /C14ZZZ/ MAXDAT,MAXTMP,MAXROW,MAXCOL,MAXTRI,
     +  MAXRSK,MAXPRO,  MAXPFR,IWDSIZ,MAXOUT,MAXIN ,MAXTIT,
     +  MAXTWD,MAXTCH,  MAXCWD,MAXCCH,MAXRWD,MAXRCH,MSTDAL,
     +  MAXROP,MPFRAL,  MAXRAL,MAXVAR,MAXDWD,MAXEXP,EXPMAX,
     +  MINEXP,EXPMIN,  NOCONT,LENAME,MAXCPP,ICOLWD,LENEXT,
     +  MAXCOP
	COMMON /C07ZZZ/ LINOUT(136),LINPOS
	COMMON /C09ZZZ/ MACBUF(128,2),MACLOC(2),MACCHR(2),MACSIZ,
     +  NUMBLK(2),NUMSIZ(2),MACOUT(2),MACCHN(2)
	COMMON /C08ZZZ/ IPAK(5)
	LINNOW=0
	MACCHR(1)=0
200	MACCHR(1)=MACCHR(1)+1
	IF(MACCHR(1).GT.IWDSIZ)GO TO 400
300	LINNOW=LINNOW+1
	IPAK(MACCHR(1))=LINOUT(LINNOW)
	GO TO 200
400	MACCHR(1)=1
	MACLOC(1)=MACLOC(1)+1
	IF(MACLOC(1).GT.MACSIZ)GO TO 600
500	CALL PKZZZ(MACTMP)
	MACBUF(MACLOC(1),1)=MACTMP
	IF(LINNOW.LT.LINPOS)GO TO 300
	RETURN
600	MACLOC(1)=1
	CALL MIOZZZ(MACBUF,1,MACSIZ,2,MACCHN(1),IOK)
	GO TO 500
	END
C
C
C
	SUBROUTINE MRDZZZ(LOGUNI,INSTAR,INSTOP,LSIZE,IEOF)
C
C THIS ROUTINE WILL READ IN ONE LINE FROM THE MACRO IO BUFFER
C INTO INPUT (FROM INSTAR TO INSTOP) AND READ ANOTHER BUFFER
C FROM THE IO FILE IF REQUIRED.  IF INPUT IS REQUESTED AND NO
C MORE BLOCKS EXIST THEN THE IEOF FLAG IS SET TO 1.  THE PORTION
C OF INPUT WHICH IS REQUESTED, BUT WHICH IS NOT FILLED BECAUSE
C THE RECORD USED TO FILL INPUT IS SHORTER THAN THE MAXIMUM AMOUNT,
C IS PADDED WITH BLANKS SIMILAR TO FORTRAN IO.
C
C LOGUNI=LOGICAL UNIT NUMBER
C INSTAR=FIRST POSITION IN INPUT TO FILL
C INSTOP=LAST POSITION IN INPUT TO FILL
C LSIZE=POSITION OF LAST NON-BLANK CHARACTER READ
C IEOF=FLAG FOR END OF FILE (1=END, 0=NO END)
C
	COMMON /C01ZZZ/ NASCII(128)
	COMMON /C14ZZZ/ MAXDAT,MAXTMP,MAXROW,MAXCOL,MAXTRI,
     +  MAXRSK,MAXPRO,  MAXPFR,IWDSIZ,MAXOUT,MAXIN ,MAXTIT,
     +  MAXTWD,MAXTCH,  MAXCWD,MAXCCH,MAXRWD,MAXRCH,MSTDAL,
     +  MAXROP,MPFRAL,  MAXRAL,MAXVAR,MAXDWD,MAXEXP,EXPMAX,
     +  MINEXP,EXPMIN,  NOCONT,LENAME,MAXCPP,ICOLWD,LENEXT,
     +  MAXCOP
	COMMON /C04ZZZ/ INPUT(320),INPOS,INSIZE,INCONT
	COMMON /C09ZZZ/ MACBUF(128,2),MACLOC(2),MACCHR(2),MACSIZ,
     +  NUMBLK(2),NUMSIZ(2),MACOUT(2),MACCHN(2)
	COMMON /C08ZZZ/ IPAK(5)
	COMMON /C05ZZZ/ ITTYI,ITTYO,IOFILE,IPOUT,IRECNO(2),ISTRIP(2),
     +  IROUTE,IRTOPN,IFFPOS,IOCMD,IOCMDN(2),IOCMDX(2),ICMDOP,ITTYSK,
     +  ITTYOC,ITTYOH,ICMDGR,ICMDUS,ISYSGR,ISYSUS
	LCHAN=LOGUNI-IOFILE+1
	INSPOT=INSTAR
	MTCHR=MACCHR(LCHAN)
	MTLOC=MACLOC(LCHAN)
	CALL UPKZZZ(MACBUF(MTLOC,LCHAN))
100	MTCHR=MTCHR+1
	IF(MTCHR.GT.IWDSIZ)GO TO 400
200	IF(IPAK(MTCHR).EQ.NASCII(11))GO TO 800
	IF(IPAK(MTCHR).EQ.NASCII(1))GO TO 100
	IF(INSPOT.GT.INSTOP)GO TO 100
	INPUT(INSPOT)=IPAK(MTCHR)
	INSPOT=INSPOT+1
	GO TO 100
400	MTCHR=1
	MTLOC=MTLOC+1
	IF(MTLOC.GT.MACSIZ)GO TO 600
500	CALL UPKZZZ(MACBUF(MTLOC,LCHAN))
	GO TO 200
600	MTLOC=1
	NUMBLK(LCHAN)=NUMBLK(LCHAN)+1
	IF(NUMBLK(LCHAN).GT.NUMSIZ(LCHAN))GO TO 700
	IF(LOGUNI.NE.IOCMD)GO TO 650
	IF(NUMBLK(LCHAN).EQ.1)GO TO 650
	CALL C76ZZZ(NAME6,IOCMDN(1),IOCMDN(2))
	CALL C76ZZZ(NEXT6,IOCMDX(1),IOCMDX(2))
	CALL OPMZZZ(1,NAME6,NEXT6,ICMDGR,ICMDUS,MACCHN(LCHAN),IOK)
	CALL USTZZZ(MACCHN(LCHAN),NUMBLK(LCHAN),1)
650	CALL MIOZZZ(MACBUF,(LCHAN-1)*MACSIZ+1,LCHAN*MACSIZ,
     +  1,MACCHN(LCHAN),IOK)
	GO TO 500
700	IEOF=1
	INSPOT=INSTAR
	GO TO 900
800	IF(INSPOT.LE.1)GO TO 810
	IF(INPUT(INSPOT-1).NE.NASCII(14))GO TO 810
	INSPOT=INSPOT-1
810	IEOF=0
900	DO 1000 I=INSPOT,INSTOP
1000	INPUT(I)=NASCII(33)
	LSIZE=INSPOT-1
	MACCHR(LCHAN)=MTCHR
	MACLOC(LCHAN)=MTLOC
	RETURN
	END
C
C
C
	SUBROUTINE LODZZZ(LOGUNT,IDNO,JUST,JFLAG)
C
C THIS ROUTINE LOADS THE ALPHANUMERICS FOR A DATA VARIABLE INTO THE
C OUTPUT BUFFER, STARTING AT THE JUSTIFICATION INDICATED.
C
C LOGUNT=LOGICAL UNIT TO WRITE INFORMATION TO
C IDNO=DATA VARIABLE NUMBER
C JUST=JUSTIFICATION FLAG
C JFLAG=INFORMATION ASSOCIATED WITH JUSTIFICATION FLAG:
C	IF JUST=1      RIGHT JUSTIFY STOPING AT JFLAG
C	IF JUST=2      LEFT JUSTIFY STARTING AT JFLAG
C	IF JUST=3      CONTINUE WHERE STOPPED (JFLAG=0)
C	IF JUST=4      CENTER WITH JFLAG=WIDTH IN CHARACTERS
C
	COMMON /C04ZZZ/ INPUT(320),INPOS,INSIZE,INCONT
	COMMON /C01ZZZ/ NASCII(128)
	CALL TRZZZ(FLOAT(IDNO),11,NOCHRS)
	DO 10 I=1,NOCHRS
10	INPUT(NOCHRS-I+2)=INPUT(NOCHRS-I+1)
	INPUT(1)=NASCII(69)
	INPUT(2)=NASCII(41)
	NOCHRS=NOCHRS+2
	INPUT(NOCHRS)=NASCII(42)
	CALL OUTZZZ(1,INPUT,1,NOCHRS,JUST,JFLAG,LOGUNT)
	RETURN
	END
C
C
C
	SUBROUTINE PR1ZZZ(NAMRUN,NEXRUN)
C
C THIS ROUTINE OPENS A TMP FILE IN THE USER'S AREA TO SAVE INFOR-
C MATION PASSED FROM ONE PROFILE PROGRAM TO THE NEXT.  THE TMP
C FILE IS GIVEN A NAME UNIQUE TO EACH JOB NUMBER SO THAT SEVERAL
C JOBS CAN OPERATE SIMULTANEOUSLY UNDER THE SAME GROUP,USER.
C
C NAMRUN=7 BIT ASCII NAME OF PROGRAM ABOUT TO BE RUN
C NEXRUN=7 BIT ASCII NAME OF FILE EXTENSION OF PROGRAM TO BE RUN
C
	COMMON /C15ZZZ/ ITIMON,ICONN(4),ICOMP(4)
	COMMON /C05ZZZ/ ITTYI,ITTYO,IOFILE,IPOUT,IRECNO(2),ISTRIP(2),
     +  IROUTE,IRTOPN,IFFPOS,IOCMD,IOCMDN(2),IOCMDX(2),ICMDOP,ITTYSK,
     +  ITTYOC,ITTYOH,ICMDGR,ICMDUS,ISYSGR,ISYSUS
	COMMON /C09ZZZ/ MACBUF(128,2),MACLOC(2),MACCHR(2),MACSIZ,
     +  NUMBLK(2),NUMSIZ(2),MACOUT(2),MACCHN(2)
	COMMON /C19ZZZ/ ITPCHK,NAMTP1(2),NEXTP1(2),ITPSAV(18)
	DIMENSION NAMRUN(2),NEXRUN(2)
	CALL SETZZZ(4)
	ITPSAV(1)=ICONN(4)+12344321
	ITPSAV(2)=ICMDOP
	ITPSAV(3)=IOCMDN(1)
	ITPSAV(4)=IOCMDN(2)
	ITPSAV(5)=IOCMDX(1)
	ITPSAV(6)=IOCMDX(2)
	ITPSAV(7)=MACLOC(2)
	ITPSAV(8)=MACCHR(2)
	ITPSAV(9)=NUMBLK(2)
	ITPSAV(10)=IRECNO(2)
	ITPSAV(11)=ISTRIP(2)
	ITPSAV(12)=ICONN(4)+43211234
	ITPSAV(13)=NAMRUN(1)
	ITPSAV(14)=NAMRUN(2)
	ITPSAV(15)=NEXRUN(1)
	ITPSAV(16)=NEXRUN(2)
	ITPSAV(17)=ICMDGR
	ITPSAV(18)=ICMDUS
	CALL TMPZZZ(NAMTP1(1))
	CALL OPNZZZ(2,IOFILE,NAMTP1,NEXTP1,0,0,IOK)
	CALL MIOZZZ(ITPSAV,1,18,2,MACCHN(1),IOK)
	CALL CLMZZZ(MACCHN(1))
	RETURN
	END
C
C
C
	SUBROUTINE PR2ZZZ(NAMRUN,NEXRUN)
C
C THIS ROUTINE CHECKS TO SEE IF ANY INFORMATION IS BEING PASSED
C FROM THE LAST PROFILE PROGRAM VIA A TMP FILE. (EACH TMP FILE IS
C GIVEN A NAME UNIQUE TO THE CURRENT JOB SO THAT SEVERAL JOBS CAN
C OPERATE SIMULTANEOUSLY UNDER A SINGLE GROUP,USER.) PROFILE ALWAYS
C PASSES INFORMATION TO THE MODEL LINK. PRODEP AND PROREP AND
C THE COMMAND LINK ALWAYS PASS INFORMATION TO WHICH EVER PROFILE
C PROGRAM THE USER RUNS VIA THE RUN UUO.  IF PRODEP, PROFILE, OR
C PROREP ARE RUN FROM THE MONITOR, NO PASSED-IN INFORMATION IS
C ASSUMED.
C
C NAMRUN=7 BIT ASCII FILE NAME OF PROGRAM BEING RUN
C NEXRUN=7 BIT ASCII FILE EXTENSION OF PROGRAM BEING RUN
C
	COMMON /C15ZZZ/ ITIMON,ICONN(4),ICOMP(4)
	COMMON /C05ZZZ/ ITTYI,ITTYO,IOFILE,IPOUT,IRECNO(2),ISTRIP(2),
     +  IROUTE,IRTOPN,IFFPOS,IOCMD,IOCMDN(2),IOCMDX(2),ICMDOP,ITTYSK,
     +  ITTYOC,ITTYOH,ICMDGR,ICMDUS,ISYSGR,ISYSUS
	COMMON /C09ZZZ/ MACBUF(128,2),MACLOC(2),MACCHR(2),MACSIZ,
     +  NUMBLK(2),NUMSIZ(2),MACOUT(2),MACCHN(2)
	COMMON /C19ZZZ/ ITPCHK,NAMTP1(2),NEXTP1(2),ITPSAV(18)
	DIMENSION NAMRUN(2),NEXRUN(2)
	IF(ITPCHK.LE.0)RETURN
	CALL SETZZZ(4)
	CALL TMPZZZ(NAMTP1(1))
	CALL OPNZZZ(1,IOFILE,NAMTP1,NEXTP1,0,0,IOK)
	IF(IOK.LE.0)GO TO 10
	CALL MIOZZZ(ITPSAV,1,18,1,MACCHN(1),IOK)
	IF(IOK.LE.0)GO TO 10
	CALL CLMZZZ(MACCHN(1))
10	CALL C76ZZZ(NEW6,NAMTP1(1),NAMTP1(2))
	CALL C76ZZZ(NEXT6,NEXTP1(1),NEXTP1(2))
	CALL FFXZZZ(0,0,NEW6,NEXT6,IDUM,IDUM,IDUM,IDUM,IDUM,0,0,
     +  IDUM,IDUM)
	IF(IOK.LE.0)GO TO 100
	ITPSAV(1)=(ITPSAV(1)-12344321+ITPSAV(12)-43211234)/2
	IF(ITPSAV(1).GT.ICONN(4))GO TO 100
C	IF(ICONN(4)-ITPSAV(1).GT.300000)GO TO 100
	IF(ITPSAV(2).EQ.0)GO TO 20
	ICMDOP=1
	ITTYSK=1
	IOCMDN(1)=ITPSAV(3)
	IOCMDN(2)=ITPSAV(4)
	IOCMDX(1)=ITPSAV(5)
	IOCMDX(2)=ITPSAV(6)
	ICMDGR=ITPSAV(17)
	ICMDUS=ITPSAV(18)
	CALL OPNZZZ(1,IOCMD,IOCMDN,IOCMDX,ICMDGR,ICMDUS,IOK)
	IF(IOK.LE.0)GO TO 100
	MACLOC(2)=ITPSAV(7)
	MACCHR(2)=ITPSAV(8)
	NUMBLK(2)=ITPSAV(9)
	IRECNO(2)=ITPSAV(10)
	ISTRIP(2)=ITPSAV(11)
	CALL USTZZZ(MACCHN(2),NUMBLK(2),1)
	CALL MIOZZZ(MACBUF,MACSIZ+1,2*MACSIZ,1,MACCHN(2),IOK)
20	NAMRUN(1)=ITPSAV(13)
	NAMRUN(2)=ITPSAV(14)
	NEXRUN(1)=ITPSAV(15)
	NEXRUN(2)=ITPSAV(16)
	IF(IOK.GT.0)RETURN
100	CALL SPKZZZ(20HTMP/PROTECTION ERROR,20,0,0,0)
	CALL PEXZZZ
	END
C
C
C
	SUBROUTINE SEEZZZ(INDEX1,INDEX2,LOGUNT,ISKIP)
C
C THIS ROUTINE CONTROLS PRINTING THE COMPUTE TIME IN SECONDS AND THE
C CONNECT TIME IN MINUTES AS CALCULATED FROM THE DIFFERENCES BETWEEN
C INDEX2 AND INDEX1 IN THE ICOMP AND ICONN VECTORS.
C
C INDEX1=POSITION OF EARLIEST TIMES IN ICOMP AND ICONN
C INDEX2=POSITION OF LATEST TIMES IN ICOMP AND ICONN
C LOGUNT=LOGICAL UNIT TO WRITE INFORMATION TO
C
	COMMON /C15ZZZ/ ITIMON,ICONN(4),ICOMP(4)
	COMMON /C04ZZZ/ INPUT(320),INPOS,INSIZE,INCONT
	CALL SKPZZZ(LOGUNT,ISKIP)
	CALL OUTZZZ(2,16HEFFECTIVE TRU'S=,1,16,2,1,LOGUNT)
	CALL TRZZZ(FLOAT(ICOMP(INDEX2)-ICOMP(INDEX1))/10000.0*2.50,13,
     +  NOCHRS)
	CALL OUTZZZ(1,INPUT,1,NOCHRS,3,0,LOGUNT)
	CALL WZZZ(LOGUNT,0)
	CALL OUTZZZ(2,16HCONNECT MINUTES=,1,16,2,1,LOGUNT)
	CALL TRZZZ(FLOAT(ICONN(INDEX2)-ICONN(INDEX1))/60000.0,13,NOCHRS)
	CALL OUTZZZ(1,INPUT,1,NOCHRS,3,0,LOGUNT)
	CALL WZZZ(LOGUNT,0)
	RETURN
	END
 P a