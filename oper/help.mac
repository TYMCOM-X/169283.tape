	TITLE HELP - CUSP TO TYPE OUT HELPFUL DOCUMENTATION.  %4(54)
	SUBTTL MLB(ADR)/PFC	25-NOV-72

;*** COPYRIGHT 1971, 1972 DIGITAL EQUIPMENT CORP., MAYNARD, MASS. ***




; FOR OPERATING INSTRUCTIONS READ HELP.HLP.  THERE ARE NO SPECIAL
;  COMPILE, LOAD OR SAVE INSTRUCTIONS.
; A NULL FILENAME IS CONSIDERED TO BE HELP.HLP BY DEFAULT.
; HELP *, LISTS ALL *.HLP FILES WHICH COULD BE LISTED BY HELP FOO.


	EXTERNAL .JBFF,.JBREL

;  COLS IS NUMBER OF COLUMNS / LINE WHEN LISTING HELP *
;  DEFAULT COLS==^D8
	IFNDEF COLS,<COLS==^D8>

VWHO==0		;WHO LAST EDITTED
VERSIN==4	;VERSION NUMBER
VPATCH==0	;VERSION LETTER
VEDIT==54	;EDIT NUMBER
;NONE OF THE FOLLOWING ACS ARELOCATION DEPENDENT,
; THEY CAN BE MOVED TO ANY POSITION IF NECESSARY.
F=0
T=1
T1=T+1
T2=T1+1
T3=T2+1
CH=5		; CONTAINS CURRENT CHARACTER
EOL=6		; -1 IF END OF LINE SEEN. 0 OTHERWISE
STS=7		; LAST GETSTS INFO.
D=10		; COUNTS # OF NAMES PER LINE (COLUMN ROUTINE)
;11-16 ARE FREE
P=17

;I/O CHANNELS
DSK==1
TTY==2
FIL==3

PDLSIZ==10	;LENGTH OF PUSH DOWN LIST


	TWOSEG

	LOC	137
	BYTE	(3)VWHO (9)VERSIN (6)VPATCH (18)VEDIT
	RELOC	400000
;REVISION HISTORY

;%3(34) RELEASED FEB, 1972

;35	REMOVE SPECIAL TEST FOR 175 (ALTMODE)
;36	CORRECT ERROR IN PRINTING "ILLEGAL CHAR" MESSAGE
;37	USE JOBSTS TO DETERMINE IF LOGGED IN
;40	SKIP REST OF COMMAND ON COMMAND ERRORS
;41	USE DEFAULT NUMBER OF DISK BUFFERS
;42	ADD EXPLICIT DEVICE ALLOWED
;43	HANDLE HLP:,NEW:,OLD:
;44	ADD MONITOR COMMANDS TO HELP *
;45	FIX BUG WHICH OCCASIONALLY INCLUDED ONE JUNK LINE IN HELP *
;46	ONLY LIST IN HELP * THOSE FILES WHOSE PROT. CODE ALLOWS THEM
;	TO BE PRINTED.
;47	HANDLE PHYSICAL UUOS IN HELP * SO THE LIST INCLUDES ALL THOSE
;	FILES WHICH CAN BE LISTED.
;50	TRANSLATE COMMON WORDS, EG "HELP ME" TO "HELP HELP".
;51	CHANGE TO 8 COLS PER LINE INSTEAD OF 6
;52	REMOVE LOOKUPS INTRODUCED BY 46 UNTIL CHANCE TO CODE
;	HISTORY TO MAKE SPEED ACCEPTABLE.
;53	MAKE REENTRANT
;54	EXTEND 43 TO HANDLE SYS: CORRECTLY IF /NEW ON HELP *.
HELP:	JFCL			;DEFEND AGAINST CCL CALL
	RESET
	RESCAN
	SETZB	EOL,FWAZER
	MOVE	T,[FWAZER,,FWAZER+1]
	BLT	T,LWAZER
	MOVE	P,[IOWD PDLSIZ,PDL]

HELP0:	PUSHJ	P,CHAR		;SKIP UP TO FIRST ATOM
	  JRST	DEFAULT		; SHOULDN'T SEE EOL UNTIL AFTER FIRST ATOM
	  JRST	HELP0		; OVER ANY SPACES,TABS, OR COMMAS
HELP1:	PUSHJ	P,CHAR		;SKIP PAST FIRST ATOM
	  JRST	DEFAULT		; NO FILNAME.
	  JRST	HELP2
	JRST	HELP1

HELP2:	PUSHJ	P,CHAR		;AND UP TO THE SECOND ATOM.
	  JRST	DEFAULT
	  JRST	HELP2
	SETZM	FILNAM		;CLEAR FILNAME
	MOVE	T,[POINT 6,FILNAM]
	MOVEI	T1,6		;ONLY LOOK AT NEXT 6 CHARS.
	JRST	HELP4

HELP3:	PUSHJ	P,CHAR		;GET A CHAR.
	  JRST	DONE		;EOL RETURN.
	  JRST	DONE		;SPACE,TAB,OR COMMA RET
HELP4:	CAIN	CH,"*"		;IS CHAR A *
	JRST	SEARCH		;USER TYPED *--WANTS LIST OF ALL INFO
	CAIN	CH,":"		;SEE IF DEVICE
	JRST	GETDEV		;YES--STORE IT AWAY
	CAIL	CH,"A"+40		;LOWER CASE
	CAILE	CH,"Z"+40		;ALPHABETIC
	SKIPA			;NO.
	TRZ	CH,40		;YES MAKE IT UPPER CASE.
	CAIL	CH,"A"		;IS IT A-Z?
	CAILE	CH,"Z"
	SKIPA
	JRST	OK
	CAIL	CH,"0"
	CAILE	CH,"9"		;IS IT 0-9?
	JRST	NOTASC		;NOPE--HE LOOSES
OK:	SUBI	CH,40		;MAKE TO SIXBIT
	SOJL	T1,HELP3
	IDPB	CH,T
	JRST	HELP3

GETDEV:	SKIPN	DEVICE		;SEE IF ALREADY A DEVICE
	SKIPN	T,FILNAM	;OR NO NAME
	JRST	ILLDEV		;YES--ERROR
	MOVEM	T,DEVICE	;OK--STORE AS DEVICE
	JRST	HELP2		;LOOP FOR MORE
;USER JUST TYPE HELP, PRETEND HE TYPED HELP HELP
DEFAULT:
	MOVE	T,[SIXBIT/HELP/]
	MOVEM	T,FILNAM

;READ TO END OF LINE, IF NOT ALREADY THERE
;INIT DSK FOR ASCII INPUT
;LOOKUP INFO
;INIT TTY FOR OUTPUT
;OUTPUT INFO TO TTY
DONE:	PUSHJ	P,CHAR		;NOPE.
	  JRST	DONE03		;EOL SEEN.
	  JRST	DONE		; GO LOOK FOR IT.
	JRST	DONE		;KEEP LOOKING.
DONE03:	PUSHJ	P,SETDEV	;OK--INITIALIZE FOR DEVICE
DONE05:	MOVEI	T,0		;SET ASCII MODE
	SKIPN	T1,DEVICE	;SEE IF USER DEVICE
	MOVE	T1,(D)		;SET DEVICE
	JUMPE	T1,NOINF	;NO-INFO IF NOT FOUND
	MOVEI	T2,IBUF		;POINT TO BUFFER HEADERS
DONE07:	OPEN	DSK,T		;TRY TO OPEN
	  JRST	NODEV		;SOMEONE MUST BE KIDDING
	MOVSI	T3,(SIXBIT/HLP/)	;EXTENSION IS .HLP
	MOVEM	T3,FILNAM+1	;NOTHING ELSE IS POSSIBLE
	SETZM	FILNAM+2	;CLEAR RESULTS
	SETZM	FILNAM+3	;AND DIRECTORY
	LOOKUP	DSK,FILNAM	;LOOKUP FILE
	  JRST	DONE7
	INBUF	DSK,0
	PUSHJ	P,TTYINI	;INIT TTY
	PUSHJ	P,CRLF		;SKIP A LINE

DONE1:	PUSHJ	P,INR		;GET A CHAR
	  JRST	EXITL		;NO MORE CHARS.
	PUSHJ	P,OUTR		;OUTPUT CHAR.
	JRST	DONE1		;GO DO IT AGAIN

DONE7:	TLON	T,(1B0)		;SET PHYSICAL AND TRY AGAIN
	JRST	DONE07		;LOOP BACK ONCE
	SKIPE	DEVICE		;SEE IF USER DEVICE
	JRST	NOINF		;ELSE, COMPLAIN

NODEV:	SKIPE	DEVICE		;SEE IF USER DEVICE
	JRST	NODSK		;ERROR IF SO
	AOJA	D,DONE05	;ELSE, TRY NEXT IN LIST
;HERE WHEN CAN NOT FIND ANYPLACE--TRY TRANSLATION

NOINF:	SKIPE	T,OLDNAM	;SEE IF ALREADY HERE ONCE
	JRST	[MOVEM T,FILNAM	;YES--RESTORE ARGUMENT
		 JRST  NOINFO]	;AND GIVE ERROR
	MOVE	T,[-TNAML,,TNAM-1]
	MOVE	T1,FILNAM	;GET MATCH
	MOVEM	T1,OLDNAM	;SAVE FOR LATER
NOINFL:	AOS	T		;SKIP VALUE
	CAME	T1,(T)		;SEE IF MATCH
	AOBJN	T,NOINFL	;NO--LOOP
	JUMPGE	T,NOINFO	;DONE--SEE IF MATCHED
	MOVE	T,1(T)		;YES--GET VALUE
	MOVEM	T,FILNAM	;CHANGE ARGUMENT
	JRST	DONE03		;AND GO DO IT AGAIN

;TABLE OF PAIRS TO TRANSLATE FROM X TO Y

	DEFINE	TRANS(X,Y),<XLIST
	EXP	<SIXBIT \X\>
	EXP	<SIXBIT \Y\>
	LIST>

TNAM:
	TRANS	US,HELP
	TRANS	ME,HELP

TNAML==.-TNAM
;CHAR--GETS NEXT CHAR FROM TTY INPUT BUFFER
;	IF END OF LINE SEEN SETS EOL TO -1
;CALL:	PUSHJ	P,CHAR
;	EOL RETURN
;	SPACE,COMMA,OR TAB RETURN
;	OTHER CHARACTER RETURN

CHAR:	JUMPL	EOL,CHAR2	;RETURN IF DONE
	INCHSL	CH		;GET A CHAR FROM TTY
	JRST	CHAR2		; IF NO CHARS LEFT CONSIDER IT EOL.
	ANDI	CH,177		;MAKE SURE IT LOOKS LIKE CHAR
	AOS	0(P)		;INCR RETURN ADDR
	AOS	0(P)		;TWICE
	CAIN	CH," "		;IS CHAR A SPACE?
	SOS	0(P)		;YES. DECR RETURN ADDR.
	CAIE	CH,"	"	;IS CHAR A TAB?
	CAIN	CH,","		;MAYBE ITS A COMMA?
	SOS	0(P)		;DECR RET ADDR IF SO.
	CAIN	CH,33
	JRST	CHAR1		;YES.
	CAIG	CH,15		;IS IT CR,VT,FF,OR LF?
	CAIGE	CH,12
	POPJ	P,		;NO.
CHAR1:	SOS	0(P)		;YES. DECR RETURN ADDR
	SOS	0(P)		;TWICE
	CAIN	CH,15		;IF <CR>
	JRST	CHAR		;  GO GET <LF>
CHAR2:	SETOI	EOL,		;SET EOL TO -1
	POPJ	P,		;AND GO AWAY.
;SETDEV--INITIALIZES TO CORRECT DEFAULT LIST OF HELP DEVICES
;RETURNS WITH D POINTING TO LIST ENDED BY 0

SETDEV:	MOVEI	D,NOTNEW	;PRESET TO ANSWER IF NOT /NEW
	MOVE	T,[2,,T1]	;SETUP INVESTIGATION
	HRROI	T1,-4		;READ DEFAULT PATH
	MOVEI	T2,0
	PATH.	T,
	  POPJ	P,		;IF NOT IMPLEMENTED, RETURN DEFAULT
	TRNE	T2,1B32		;SEE IF /NEW
	MOVEI	D,YESNEW	;YES--SET ALTERNATE LIST
	POPJ	P,		;AND RETURN


;IN--READS BYTE OF INPUT FROM DSK, BYTE SIZE DEPENDS ON
; MODE DISK INITED IN, FOR *.HLP FILE 7 BIT ASCII, FOR
; TXTDIR.UFD FILE 36 BIT BINARY.
;
;CALL	PUSHJ	P,INR
;	EOF RETURN
;	NORMAL RETURN
; BYTE IS RETURNED IN CH.
; THERE IS NO RETURN ON AN ERROR.

INR:	SOSGE	IBUF+2		;ANY CHARS LEFT IN BUFFER
	JRST	IN1		;NOPE.
	ILDB	CH,IBUF+1	;YES--GO GET IT
IN0:	AOS	(P)		;AND INCR RET ADDR
	POPJ	P,		;RETURN.
IN1:	IN	DSK,		;GET NEW BUFFER.
	  JRST	INR		;GO BACK, GET CHAR
	GETSTS	DSK,STS		;SOMETHING GOOFED--FIND OUT WHAT
	TRNE	STS,74B23	;CHECK FOR ERROR BITS.
	JRST	INERR		;YES ERROR--GIVE UP.
	TRNN	STS,1B22	;EOF?
	JRST	GOOF		;NOT ERROR BITS OR EOF--CAN NEVER GET HERE
	POPJ	P,		;EOF RETURN
;TTYINI-INIT TTY FOR OUTPUT.
;CALL	PUSHJ	P,TTYINI
;	NORMAL RETURN
; NEVER RETURNS IF ANY ERROR.

TTYINI:	INIT	TTY,1
	  SIXBIT /TTY/
	  XWD	OBUF,0
	  JRST	NOTTY		;NEVER GET HERE--I HOPE
	OUTBUF	TTY,0
	POPJ	P,

;OUT--OUTPUTS BYTE TO TTY.  CALLED WITH BYTE IN CH.
;TAB--OUTPUTS TAB TO TTY.
;CRLF-OOUTPUTS CR-LF SEQUENCE TO TTY.
;
;CALL	PUSHJ	P,<ROUTINE>
;	NORMAL RETURN
; THERE IS NO RETURN ON ANY ERROR.

CRLF:	MOVEI	CH,15
	PUSHJ	P,OUTR
	MOVEI	CH,12
	PUSHJ	P,OUTR
	POPJ	P,

TAB:	MOVEI	CH,11		;PUT OUT TAB.

OUTR:	SOSG	OBUF+2		;ROM FOR ONE MORE?
	JRST	OUT1		;NO--GO MAKE ROOM
	IDPB	CH,OBUF+1	;YES--PUT IT THERE
	POPJ	P,		;AND RETURN?
OUT1:	OUT	TTY,		;OUTPUT A BUFFER
	  JRST	OUTR		;GO TRY NOW
	GETSTS	TTY,STS		;SOMETHING WENT WRONG--GET STATUS
	TRNN	STS,74B23	;ERROR?
	JRST	GOOF		;SHOULDN'T GET HERE
	JRST	OUTERR		;LEGIT. ERROR  TELL USER.
; SEARCH--TYPE OUT LIST OF ALL AVAILABLE *.HLP FILES
;  IN HELP'S DIRECTORY.
;	FIRST  READ PAST END OF COMMAND
;	LOOKUP DIRECTORY--COMPUTE SIZE OF PDL
;	  NEEDED.
;	READ DIRECTORY FOR ALL *.HLP FILES, PUT NAMES FOUND
;	  AT .JBFF
;	SORT LIST
;	TYPE OUT LIST.

SEARCH:	PUSHJ	P,CHAR		;READ TO END OF COMMAND
	  JRST	S0
	  JRST	SEARCH
	JRST	SEARCH		;KEEP LOOKING.
S0:	PUSHJ	P,TTYINI	;SETUP TTY
	PUSHJ	P,SETDEV	;SETUP DEFAULT DEVICE LIST
	MOVE	T,.JBFF		;SAVE INITIAL
	MOVEM	T,SAVFF		; .JBFF
	MOVEI	F,0		;CLEAR COUNT
S0A:	TLZ	F,(1B0)		;CLEAR PHYS BIT
	MOVEI	T,14		;SET FOR BINARY MODE
S0B:	SKIPN	T1,DEVICE	;GET USER DEVICE IF ANY
	MOVE	T1,(D)		;ELSE GET NEXT DEFAULT
	JUMPE	T1,S2A		;EXIT WHEN ALL DONE
	MOVEI	T2,IBUF		;POINT TO INPUT HEADER
	OPEN	DSK,T		;OPEN DEVICE
	  JRST	NODSKS		;GIVE UP.
	MOVE	T2,SAVFF	;GET ORIGINAL .JBFF
	EXCH	T2,.JBFF	;RESTORE FOR BUFFERS
	INBUF	DSK,0
	CAMLE	T2,.JBFF	;IF FIRST TIME,
	MOVEM	T2,.JBFF	;  RESTORE UPDATED VALUE
	MOVEI	T2,0		;ALSO OPEN
	OPEN	FIL,T		;  EXTRA CHANNEL
	  JRST	NODSKS		;UUPS
	MOVE	T,[DEVPPN T1,]
	TLNE	F,(1B0)
	TRO	T,1B19
	XCT	T
	  JRST	[MOVE	T1,[1,,16]
		 GETTAB	T1,
		   MOVE	T1,[1,,1]
		 JRST	.+1]
	MOVE	T,[25,,16]	;IDENTIFY NEW:
	GETTAB	T,
	  MOVEI	T,0		;MUST NOT EXIST
	CAMN	T,T1		;SEE IF WE HAVE THAT ONE
	JRST	[MOVS	T,(D)	;YES--GET ARGUMENT
		 CAIN	T,'SYS'	;SEE IF SYS:
		 SKIPE	DEVICE	;AND NO USER ARGUMENT
		 JRST	.+1	;NO--LEAVE ALONE
		 MOVE	T1,[1,,16] ;YES--CHANGE TO REAL SYS:
		 GETTAB T1,
		   MOVE	T1,[1,,4]
		 JRST	.+1]	;AND CONTINUE
	MOVEM	T1,FILNAM
	MOVSI	T,(SIXBIT/UFD/)
	MOVEM	T,FILNAM+1
	SETZM	FILNAM+2
	MOVEI	T,16
	GETTAB	T,
	  MOVE	T,[XWD 1,1]
	MOVEM	T,FILNAM+3
	LOOKUP	DSK,FILNAM
	  JRST	NOUFD		;OUCH!!! CAN'T GET UFD.
;READ DIRECTORY
S1:	PUSHJ	P,INR
	  JRST	S2
	MOVE	T,CH
	PUSHJ	P,INR
	JRST	GOOF		;PRETEND EOF WILL NEVER OCCUR HERE.
	HLRZS	CH
	CAIE	CH,(SIXBIT/HLP/)
	JRST	S1		; NOT A *.HLP FILE KEEP LOOKING.
	MOVSI	T1,'HLP'	;SET IN EXTENSION
	SETZB	T2,T3		;CLEAR DIRECTORY
COMMENT	\	;EDIT 52
	LOOKUP	FIL,T		;LOOKUP FILE
	  MOVEI T,0		;DON'T INCLUDE IF CAN'T READ IT
	CLOSE	FIL,100		;DON'T KEEP ACCESS TABLE
\			;END EDIT 52

	PUSHJ	P,STORE		;SAVE NAME
	JRST	S1		;AND LOOP

NOUFD:	SKIPE	DEVICE		;SEE IF USER DEVICE
	JRST	TROUBLE		;YES--HE IS IN TROUBLE
NODSKS:	SKIPE	DEVICE		;SEE IF USER DEVICE
	JRST	NODSK		;YES--ERROR
S2:	SKIPE	DEVICE		;SEE IF USER DEVICE
	JRST	S2A		;YES--ALL DONE
	TLOE	F,(1B0)		;SET/TEST FLAG FOR PHYSICAL
	AOJA	D,S0A		;LOOP OVER ALL DEVICES
	MOVE	T,(D)		;REFETCH DEVICE NAME
	DEVNAM	T,		;GET PHYSICAL NAME
	  AOJA	D,S0A		;CAN'T--GO ON TO NEXT DEVICE
	CAMN	T,(D)		;SEE IF SAME
	AOJA	D,S0A		;YES--NOT A LOGICAL NAME
	MOVE	T,[1B0+14]	;NO--TRY PHYSICAL
	JRST	S0B		; AS WELL

S2A:	RELEAS	DSK,		;FREE CHANNEL
	RELEAS	FIL,		; ..

	JUMPE	F,MONCMD	;SKIP ON IF NOTHING!
	PUSHJ	P,SORT		;ELSE GO SORT LIST

	MOVE	D,[POINT 7,[ASCIZ/
HELP is available for the following:/]]
	PUSHJ	P,HEAD		;OUTPUT HEADING AND LIST
MONCMD:	MOVSI	T,30		;POINT TO COMMAND TABLE
	MOVE	D,[POINT 7,[ASCIZ /
The monitor has the following commands:/]]
	PUSHJ	P,MONTAB	;GET AND OUTPUT A TABLE

	MOVSI	T,43		;POINT TO SET COMMAND TABLE
	MOVE	D,[POINT 7,[ASCIZ /
The monitor has the following SET commands:/]]
	PUSHJ	P,MONTAB	;GET AND OUTPUT THE TABLE

;ADD SET WATCH AND SET TTY TABLES HERE

	JRST	EXITL		;GO FINISH UP
;MONTAB -- ROUTINE TO GET A MONITOR TABLE, SORT IT, AND LIST IT
;CALL:	MOVSI	T,TABLE NUMBER (MUST BE IN SIXBIT)
;	MOVE	D,[POINT 7,ASCIZ STRING FOR HEADING]
;	PUSHJ	P,MONTAB

MONTAB:	MOVE	T1,SAVFF	;RESTORE .JBFF
	MOVEM	T1,.JBFF	; ..
	MOVE	T2,T		;SHIFT ARG TO MORE CONVENIENT PLACE
	MOVEI	F,0		;CLEAR COUNT

MONTB1:	MOVS	T1,T2		;GET NEXT
	GETTAB	T1,		; ENTRY
	  JRST	MONTB2		;DONE
	MOVEI	T,0		;CLEAR AC
	LSHC	T,6		;GET FIRST CHAR
	CAIN	T,'.'		;SEE IF STARTS WITH PERIOD
	SETZB	T,T1		;YES--CLEAR COMMAND
	LSHC	T,^D30		;REPOSITION COMMAND
	PUSHJ	P,STORE		;SAVE AWAY
	AOJA	T2,MONTB1	;INCREMENT ENTRY AND TRY AGAIN
MONTB2:	JUMPE	F,CPOPJ		;RETURN OF NOTHING
	PUSHJ	P,SORT		;GO SORT TABLE
				;THEN OUTPUT THE WHOLE THING

;HEAD -- ROUTINE TO OUTPUT HEADING AND THEN LIST
;CALL:	MOVE	D,[POINT 7,ASCIZ STRING]
;	PUSHJ	P,HEAD

HEAD1:	PUSHJ	P,OUTR
HEAD:	ILDB	CH,D
	JUMPN	CH,HEAD1
NEWLIN:	PUSHJ	P,CRLF
	MOVEI	D,COLS
	SKIPA
NEXT:	PUSHJ	P,TAB
	MOVE	T3,(T1)
NEXT1:	MOVEI	T2,0
	LSHC	T2,6
	MOVEI	CH,40(T2)
	PUSHJ	P,OUTR
	JUMPN	T3,NEXT1
NEXT2:	SOS	T1
	CAMGE	T1,T
	JRST	CRLF		;ALL DONE--END THE LINE
	MOVE	T3,(T1)	;GET NEXT ITEM
	CAMN	T3,1(T1)	;COMPARE WITH PREVIOUS ONE
	JRST	NEXT2		;SAME--SKIP PRINTING
	SOJG	D,NEXT
	JRST	NEWLIN
;STORE--ROUTINE TO ADD ENTRY TO LIST
;CALL:	MOVE	T,ENTRY
;	PUSHJ	P,STORE

STORE:	JUMPE	T,CPOPJ		;RETURN IF BLANK ENTRY
	MOVE	T1,.JBFF	;SEE IF ENOUGH CORE
	CAMLE	T1,.JBREL	; ..
	JRST	[CORE	T1,	; NO--GET MORE
		   JRST	NOCORE	;GIVE UP IF NO MORE TO BE HAD
		 JRST	.+1]
	MOVEM	T,@.JBFF	;STORE NAME
	AOS	.JBFF		;AND ADVANCE POINTER
	AOS	F		;COUNT RESULT
CPOPJ:	POPJ	P,		;RETURN


; BUBBLE SORT FOLLOWS--VERY SLOW METHOD--COULD BE SPED
; UP BY AN AMBITIOUS PERSON.
; WORKS BY COMPARING TWO ADJACENT ITEMS ON LIST, IF
;  NEED IT SWAPS THEM, AND STARTS GOING DOWN THE LIST
;  AGAIN.
; F - NUMBER OF ENTRIES
; T - LOWER BOUND OF SEARCH, T1 - UPPER BOUND
; T2- POINTS TO ITEM TO BE COMPARED  0(T2) MUST BE < -1(T2)
; CH- USED FOR TEMP STORAGE OF ITEM
;
;CALL:	MOVEI	F,NUMBER OF ENTRIES
;	.JBFF POINT TO LAST PLUS ONE
;	PUSHJ	P,SORT
;RETURN WITH T=END OF LIST (LOW), T1=START (HIGH)

SORT:	CAIG	F,1		;SEE IF JUST ONE ENTRY
	POPJ	P,		;YES--ALREADY IN ORDER
	MOVE	T,.JBFF		;GET END+1
	MOVEI	T1,-1(T)	;SET END INTO T1
	SUB	T,F		;COMPUTE LOWER BOUND OF SEARCH
S3:	MOVE	T2,T1		;START AT TOP OF LIST
S4:	MOVE	CH,-1(T2)	;GET NEXT ITEM
	CAMGE	CH,0(T2)	;COMPARE THEM.
	JRST	SWAP		;NOT IN ORDER
				;  IF EQUAL, LEAVE ALONE
				;  THEY WILL BE FILTERED AT PRINT TIME
	SOS	T2		;OK--TRY NEXT ITEM.
	CAMLE	T2,T		;DONE YET?
	JRST	S4		;NO KEEP GOING DOWN LIST
	POPJ	P,		;YES--RETURN
SWAP:	EXCH	CH,0(T2)	;EXCAHNGE ITEMS ON LIST
	MOVEM	CH,-1(T2)	;
	JRST	S3		;START LIST OVER AGAIN.
EXITL:	PUSHJ	P,CRLF
EXITR:	RELEAS	TTY,
EXITRL:	PUSHJ	P,CHAR
	  JRST	EXITRX
	  JRST	EXITRL
	JRST	EXITRL
EXITRX:	RESET
	PJOB	F,
	MOVNS	F
	JOBSTS	F,
	  MOVEI	F,0
	TLNE	F,(1B1)
	JRST	[EXIT 1,
		 EXIT]
	SKIPE	F
	OUTSTR	[ASCIZ/
.KJOB
./]				;NO. MAKE SURE HE KNOWS IT
	LOGOUT
;ERROR AND WARNING MESSAGES

NOTASC:	OUTSTR	[ASCIZ/% Illegal char: "/]
	CAIGE	CH,40
	JRST	[OUTSTR	[ASCIZ /^/]
		 ADDI	CH,100
		 JRST	.+1]
	OUTCHR	CH
	OUTSTR	[ASCIZ/", for HELP type HELP/]
	JRST	EXITX

;POSSIBLE WAYS TO GOOF,
;  IN OR OUT FAILED WITHOUT ANY 74B23 BITS SET.
;  READ FILNAME BUT NOT EXTENSION OUT OF A DIR BLOCK.
; NOTE THAT NONE OF THESE SHOULD EVER HAPPEN.
GOOF:	OUTSTR	[ASCIZ/?? Horrible bug somewhere..../]
	JRST	EXITR

NOINFO:	OUTSTR	[ASCIZ/% No info on "/]
	MOVE	T1,FILNAM
NOINF1:	MOVEI	T,0
	LSHC	T,6
	ADDI	T,40
	OUTCHR	T		;PRINT IT.
	JUMPN	T1,NOINF1
	OUTSTR	[ASCIZ /"
/]
	JRST	EXITR		;ALL DONE.

INERR:	OUTSTR	[ASCIZ/? Input error /]
	JRST	TYPSTS

OUTERR:	OUTSTR	[ASCIZ/? Output error /]
TYPSTS:	HRLZ	T1,STS
	MOVEI	F,6
TYPST1:	MOVEI	T,0
	LSHC	T,3
	ADDI	T,"0"
	OUTCHR	T
	SOJG	F,TYPST1
	JRST	EXITX
ILLDEV:	OUTSTR	[ASCIZ /? Illegal device specification in command/]
	JRST	EXITX

NOTTY:	OUTSTR	[ASCIZ/? Can't OPEN output device/]
	JRST	EXITX

NODSK:	OUTSTR	[ASCIZ/? Can't OPEN input device/]
	JRST	EXITX

TROUBLE:
	OUTSTR	[ASCIZ/? Can't LOOKUP directory/]
	JRST	EXITX

NOCORE:	OUTSTR	[ASCIZ/? Core exceeded/]
EXITX:	OUTSTR	[ASCIZ /
/]
	JRST	EXITR
NOTNEW:			;LIST OF DEVICES IF USER DOES NOT HAVE /NEW
	SIXBIT	/HLP/
	SIXBIT	/SYS/
	SIXBIT	/NEW/
	SIXBIT	/OLD/
	0

YESNEW:			;LIST OF DEVICES IF USER DOES HAVE /NEW
	SIXBIT	/HLP/
	SIXBIT	/NEW/
	SIXBIT	/SYS/
	SIXBIT	/OLD/
	0

	XLIST	;LITERALS
	LIT
	LIST

	RELOC	;SWITCH TO LOW SEG


;STORAGE AREA

FWAZER:!		;START OF AREA TO ZERO
OLDNAM:	BLOCK	1
SAVFF:	BLOCK	1
DEVICE:	BLOCK	1
FILNAM:	BLOCK	4
IBUF:	BLOCK	3
OBUF:	BLOCK	3
PDL:	BLOCK	PDLSIZ
LWAZER==.-1	;END


	END	HELP
