FIND NAEOPS,SWTCH(0:9),%SET.OLD.EVAL,LSTIFDIR,LSTIFCD
GLOBAL %DMP.C.POOL,CUR.CK,SCK(),ECK(),PURE,NO.CKSUMS
FIND FIRST.SCK,LAST.ECK,BEG.CKS.POOL,END.CKS.POOL,PCKDIR
GLOBAL LINES
FIND NCOPIES,QSAV,CSAV,C.STR.P,COM.STR(72/CPW),%NXTSRC,PROMPT:,S,E,NO.LST,NO.REL,A.PTR,PCTR.PTR
FIND %R.LEAS.SYM.TBL,INIT:
GLOBAL EOF3:,%PASS2,%PASS2B,%LIS.LN,PRINTED,A,%W.REL,%INIT.W.REL,BIN,%PR.FILE
GLOBAL %BEG.LIS.LN,%END.LIS.LN,%LIS.DEF,%LIS.REF
FIND C,%PR,%PRF,%ERR,%THING.GETTER,TOK,VAL,PCTR,Q,%MESS,%FIL.ERR
FIND OPTAB,NALLOPS
FIND MAP(0:127),%EVAL,F,L,%NEXTLN,%GETLN
FIND SYMTAB,LABPNT,SYMN,SYMD,SYME,SYMCC,SYMPNT,CREF,LABCC,NOCORE:
FIND %INITPRIF,%PRIF,TMPLT,OPVL
FIND BEG.LIT.POOL,BEG.IND.POOL,CUR.IND.ADD,CUR.LIT.ADD,END.IND.POOL,NEWMODE,END.LIT.POOL
FIND SYMBUF(0:SYMBUF.L),INDTAB,%SYMPOS,LITTAB,%GET.SYM,%DMP,%D.NXT.SYM
FIND F.VAR(50),F.LST,F.ERR,LINE.NUM,%PR.TAB
FIND EDIT10,PAGE.NUM,PRINT.LINE,NEW.PAGE

%PASS2
LOCAL B,M,%P2SCAN,I,%DUMP,%ABX,%PRAE2

IF S#1 THEN MESS(E,'$ENDIF MISSING$')
C.STR.P _ CHPT(COM.STR,-1)  !SET COMMAND STRING PTR BACK TO 1ST SRC FILE
NXTSRC

IF NOT NO.REL THEN INIT.W.REL
PCTR_0
LINE.NUM_0
BEG.LIS.LN
NCOPIES _ -1
CUR.LIT.ADD _ BEG.LIT.POOL <== -1
CUR.CK _ PURE _ 0  !CODE BEFORE 1ST SCKSUM CONSIDRED IMPURE
NO.CKSUMS _ (END.CKS.POOL-BEG.CKS.POOL)/2
BEG.CKS.POOL _ -1
IF LAST.ECK # -1 THEN DO
  SCK _ BLOCK((NO.CKSUMS+130)/131,0,NOCORE)  !GRAB CORE FOR SCKSUM PCTRS
  ECK _ BLOCK((NO.CKSUMS+130)/131,0,NOCORE)  !AND ECKSUM PCTRS
  END
CUR.IND.ADD _ BEG.IND.POOL <== -1
INITPRIF

%%PASS2B

GETLN
  C_NCHV Q  !1ST CHAR

WHILE 1=1 THEN DO  !DUMMY LOOP

  IF NCOPIES < 0 THEN P2SCAN ELSE DO   !RPT1 DIRECTIVE
        QSAV _ Q
        CSAV _ C
        IF NCOPIES = 0 THEN LIS.LN(ALONE)
        WHILE DEC NCOPIES >= 0 THEN [P2SCAN; Q_QSAV; C_CSAV]
        TOK _ 0    !SO NEXTLN WILL FLUSH STATEMENT
        END
  NEXTLN
  END

EOF3: IF ERRNUM#EOFERR THEN [FIL.ERR(F.VAR); GO PROMPT] ELSE DO
  IF NXTSRC THEN PASS2B
END.LIS.LN
 IF CUR.IND.ADD#-1#BEG.IND.POOL THEN DO
   IF CUR.IND.ADD> END.IND.POOL THEN DO  !INDIRECT OVERFLOW
     MESS(E,'$OVERFLOW OF INDIRECT POOL, USE$$   I  *+')
     PRF(E,CUR.IND.ADD-BEG.IND.POOL,8)
     MESS(E,'$')
     END
   IF NOT NO.LST THEN [MESS(L,'$$INDIRECT POOL$'); LINES_LINES+3]
   BEG.LIS.LN
   DUMP(INDTAB,BEG.IND.POOL,CUR.IND.ADD)
   END.LIS.LN
   END
 IF CUR.LIT.ADD#-1 THEN DO
   IF CUR.LIT.ADD> END.LIT.POOL THEN DO   !LITERAL POOL OVERFLOW
     MESS(E,'$OVERFLOW OF LITERAL POOL, USE$$   L  *+')
     PRF(E,CUR.LIT.ADD-BEG.LIT.POOL,8)
     END
   IF NOT NO.LST THEN [MESS(L,'$LITERAL POOL$'); LINES_LINES+2]
   BEG.LIS.LN
   DUMP(LITTAB,BEG.LIT.POOL,CUR.LIT.ADD)
   END.LIS.LN
   END

DMP.C.POOL  !THIS WILL JUST RETURN IF NO CKSUM DIRECTIVES

IF NOT NO.REL THEN DO
   WREL(0,0)  !FINAL CALL WILL CLEAR OUT ANYTHING IN WD CURRENTLY
   I _ SETCP(BIN,SIZE(BIN)) !PDP SAV NEEDS NEXT 3 WDS AT END
   W(BIN,OCT 777777000776)
   W(BIN,OCT 254200000777)
   W(BIN,OCT 254000000777)
   SETCP(BIN,0)
   W(BIN,[18,18]*[-I+1,OCT 777])  !1ST WD OF SAV FILE (REL)
   CLOSE(BIN)
   END
   CLOSE(F)
IF NOT NO.LST THEN CLOSE(L)
 R.LEAS.SYM.TBL(SYMTAB)
 R.LEAS.SYM.TBL(LITTAB)
 R.LEAS.SYM.TBL(INDTAB)
 GO INIT
 END

%P2SCAN
LOCAL A.SAVE

   IF THING.GETTER = STAR THEN [LIS.LN(ALONE); RETURN]
   IF TOK = SPACE THEN [LABPNT_0; GO X]
   IF TOK # SYM THEN GO Y
   SYMUPK(SYMN,SYME,SYMD,) _ ^(LABPNT _ SYMPOS(SYMTAB))
   LABCC_SYMCC
   IF NOT SYME THEN LIS.DEF
   IF SYMD#0 THEN ERR('$DUPLICATE DEFINITIONS$')
   IF THING.GETTER # SPACE THEN [ERR('$SPACE EXPECTED$'); GO Y]
X: IF THING.GETTER = SYM THEN GO Z
Y: IF TOK = TERM THEN [LIS.LN(ALONE);RETURN]  !NULL LINE
   A _ EVAL
   LISLN(BOTH)  !DATA WORD
   RETURN
Z: [BPW-21,5,16]*[,TMPLT,OPVL] _ ^SYMPOS(OPTAB)
   DO TMPLT OF 0:NUM.TMPLTS
0: A_0; LIS.LN(BOTH); ERR('$ILLEGAL OPCODE$')
 1: A_OPVL; LIS.LN(BOTH)
2: 3: 4:  5: IF THING.GETTER # SPACE THEN ERR('$SPACE EXPECTED$')
THING.GETTER
    IF A _ EVAL > OCT 777 THEN [A _ A BAND OCT 777; ERR('$TRUNC TO 9$')]
    A _ OPVL + A
    LIS.LN(BOTH)
 6: IF THING.GETTER # SPACE THEN ERR('$SPACE EXPECTED$')
THING.GETTER
    A _ EVAL
    EIF TOK # COMMA THEN DO  !NO B,X, OR I (5,6, OR 7)
      IF A > OCT 3777 THEN DO  !CAN'T GO DIRECT
        EIF A<=PCTR OR A-PCTR > OCT 777 THEN DO
          SYMBUF(0) _ 1
          SYMBUF(1) _ A SHL 1  !AVOID FUNNY BIT
          IF ^(I_SYMPOS(INDTAB))=VIRGIN THEN ^I _ INC CUR.IND.ADD
          A _ OCT 7000 + ^I - 1  !VAL STORED IS 1 HIGH TO AVOID ZERO

          END
        ELSE A _ RELATIVE + A - PCTR - 1
        END

      A _ OPVL + A
      END
    ELSE DO
      IF A > OCT 777 THEN [A_A BAND OCT 777; ERR('$9 BITS$')]
      EIF THING.GETTER = NUM THEN DO
        IF NOT 3 < VAL < 8 THEN ERR('$ILLEGAL 2ND PARAMETER$')
        A _ OPVL + VAL SHL 9 + A  !5,6, OR 7
        END
      ELSE DO  !LOOK FOR B,X, OR I
        EIF B _ NCHV SYMPNT = $B THEN M _ OCT 6000  !INDEX BY B REG
        ORIF B = $X THEN M _ OCT 5000          !INDEX BY X REG
        ORIF B = $I THEN M _ OCT 7000          !PROGRAMMER IS FORCING INDIRECT
        ELSE ERR('$ILLEGAL 2ND PARAMETER$')
        IF NCHV SYMPNT # EOLIT THEN ERR('$ILLEGAL 2ND PARAMETER$')
        A _ OPVL + M + A
        END
      END
      LIS.LN(BOTH)
 7: IF THING.GETTER # SPACE THEN ERR('$SPACE EXPECTED$')
    A _ OPVL + ABX SHL 3 + ABX
    IF TOK = COMMA THEN DO
      THING.GETTER
      IF NCHV SYMPNT = $V THEN A _ A + OCT 400   !BIT FOR IF OVERFLOW
      END
   LIS.LN(BOTH)

 9: IF THING.GETTER # SPACE THEN ERR('$SPACE EXPECTED$')
    THING.GETTER
    A _ OPVL
    A.SAVE _ EVAL
    IF TOK = COMMA THEN DO
      IF THING.GETTER = SYM AND NCHV SYMPNT = $I &
        THEN A.SAVE _ A.SAVE BOR OCT 100000 &
        ELSE ERR('$ILLEGAL 2ND PARAMETER$')
      END
    LIS.LN(BOTH); A_A.SAVE; LIS.LN(BOTH)
10: IF THING.GETTER # SPACE THEN ERR('$SPACE EXPECTED$')
THING.GETTER
    IF A _ EVAL > OCT 77 THEN [A _ A BAND OCT 77; ERR('$6 BITS$')]
    A _ OPVL + A
    IF TOK # COMMA THEN ERR('$COMMA EXPECTED$')
    THING.GETTER
    A.SAVE _ EVAL
    LIS.LN(BOTH); A_A.SAVE; LIS.LN(BOTH)
11: IF THING.GETTER # SPACE THEN ERR('$SPACE EXPECTED$')
THING.GETTER
    IF A _ EVAL > OCT 777 THEN [A _ A BAND OCT 777; ERR('$9 BITS$')]
    A _ OPVL + A
    IF TOK # COMMA THEN ERR('$COMMA EXPECTED$')
    THING.GETTER
    A.SAVE _ EVAL
    LIS.LN(BOTH); A_A.SAVE; LIS.LN(BOTH)
AE.DIR: PRAE2
IF.DIR: PRIF
END  !DO TMPLT OF

RETURN

%ABX
EIF THING.GETTER=COMMA THEN RETURN 0   !NULL SOURCE (OR DESTINATION)
ORIF TOK=SYM THEN DO
  I_0  !INIT DIGIT TO BE 1 THRU 7 SOON
  WHILE B_NCHV SYMPNT#EOLIT THEN DO   !P IS POINTING TO BEGINNING OF SYM
    EIF B=$A THEN IF I BAND 1 THEN ERR("$2 A'S$") ELSE I_I+1  !A FOUND
    ORIF B=$B THEN IF I BAND 2 THEN ERR("$2 B'S$") ELSE I_I+2  !B
    ORIF B=$X THEN IF I BAND 4 THEN ERR("$2 X'S$") ELSE I_I+4  !X
    ELSE ERR('$A,B, OR X EXPECTED')
    END
  THING.GETTER  !SET UP TOK, SPACE OR COMMA EXPECTED
  RETURN I
  END
ELSE ERR('$UNEXPECTED STUFF$')
RETURN -1
END ABX

%PRAE2
  LOCAL I,PCTR.SAV
  PCTR.SAV _ PCTR
  IF OPVL > 8 THEN GO NO.PARAM
  IF THING.GETTER # SPACE THEN ERR('$SPACE EXPECTED$')
  IF OPVL > NAEOPS THEN ERR('$OPTAB BUG$')
  IF OPVL # ASC.DIR THEN THING.GETTER  !ASC DIRECTIVE NEEDS C

NO.PARAM: DO OPVL OF 16   !NUMBER OF AE DIRECTIVES

1: IF BEG.LIT.POOL # -1 THEN ERR('$2ND DIRECTIVE (IGNORED)$') ELSE DO
      BEG.LIT.POOL _ PCTR
      LIS.LN(NO.OCTAL)
      IF (END.LIT.POOL_PCTR_EVAL) > OCT 3777 THEN ERR('$L DIR MUST BE IN 1ST 4K$')
      END
   I _ BEG.LIT.POOL-1
   WHILE INC I < END.LIT.POOL THEN W.REL(I,0)  !CKSUMMABLE ZEROES

2: IF BEG.IND.POOL #-1 THEN ERR('$2ND DIRECTIVE (IGNORED)$') ELSE DO
      BEG.IND.POOL _ PCTR
      LIS.LN(NO.OCTAL)
      IF END.IND.POOL _ PCTR _ EVAL > OCT 777 THEN ERR('$I DIR MUST BE IN 1ST K$')
      END
   I _ BEG.IND.POOL-1
   WHILE INC I < END.IND.POOL THEN W.REL(I,0)  !PURE CODE INITTED

3: IF BEG.CKS.POOL # -1 THEN ERR('$2ND DIRECTIVE (IGNORED)$') ELSE DO
      BEG.CKS.POOL _ PCTR
      LIS.LN(NO.OCTAL)
      END.CKS.POOL _ PCTR _ EVAL
      IF PURE THEN DO
        ECK(CUR.CK) _ BEG.CKS.POOL   !DON'T LET THE POOL ITSELF
        SCK(INC CUR.CK) _ END.CKS.POOL  !BE CONSIDERED PURE
        END
      END

4: LIS.LN(NO.OCTAL)
   PCTR _ EVAL  ! R DIRECTIVE

E.DIR:  A _ EVAL
        EIF LABPNT#0 THEN DO
          ^LABPNT _ SYMPCK(SYMN,SYME,SYMD,A)
          SYMCC_LABCC; GETSYM(LABPNT); LIS.DEF
          LIS.LN(NO.PCTR)
          END
        ELSE ERR('$LABEL REQUIRED$')
ASC.DIR: A _ -1
         WHILE I _ NCHV Q # C THEN DO
           EIF A = -1 THEN A _ I SHL 8 BOR OCT 100200 !SET BOTH 8TH BITS
           ELSE DO
             A _ A BOR I
             LIS.LN(BOTH)
             A _ -1
             END
           IF I = CARRET THEN GETLN
           END
         IF A # -1 THEN LIS.LN(BOTH)

7: SWTCH(EVAL)_1  !SWITCH DIRECTIVE
   LIS.LN(NO.PCTR)

8: IF A _NCOPIES _ EVAL < 0 THEN ERR('$NEGATIVE PARAMETER$')  !RPT1 DIR
   LIS.LN(NO.PCTR)

9: SET.OLD.EVAL
   LIS.LN(ALONE)

10: INC LSTIFDIR; INC LSTIFCD
    LIS.LN(ALONE)

11: INC LSTIFDIR
    LIS.LN(ALONE)

12: LSTIFDIR _ LSTIFCD _ 0
    LIS.LN(ALONE)

13:   IF PURE OR PCTR >= LAST.ECK THEN ERR('$MISPLACED DIRECTIVE (IGNORED)$') ELSE DO
        INC PURE  !SWITCH TO PURE MODE, CHECKSUM ALL CODE
        IF INC CUR.CK<NO.CKSUMS THEN SCK(CUR.CK)_PCTR
        IF PCKDIR THEN LIS.LN(NO.OCTAL)
        END
14:   IF PURE THEN DO
        PURE _ 0
        ECK(CUR.CK) _ PCTR
        IF PCKDIR THEN LIS.LN(NO.OCTAL)
        END ELSE ERR('$MISPLACED DIRECTIVE (IGNORED)$')

15: INC PCKDIR
    LIS.LN(ALONE)
16: PCKDIR _ 0
    LIS.LN(ALONE)

  END !DO OPVL OF
  IF PCTR < PCTR.SAV THEN ERR('$PROGRAM COUNTER DECREASED$')
  RETURN
END PRAE2
END P2SCAN

%LIS.LN(HOW)
LOCAL I,MSEC,SEC,MINIT
IF HOW=ALONE AND PRINTED THEN RETURN
IF NO.LST THEN DO
  IF HOW=BOTH THEN [W.REL(PCTR,A); INC PCTR]
  RETURN
  END
IF NEW.PAGE OR INC LINES>53 THEN DO
  LINES_0
  END.LIS.LN
  W(L, OCT 14)  !FORM FEED
  MESS(L,'PAGE ')
  PR(PAGE.NUM,10)
  MESS(L,'  ')
  PR.FILE(L,F.VAR)
  MESS(L,'  ')
  EXU(OCT 47,OCT 16,OCT 14)   !DATE AS AN INTEGER
  I _ ^OCT 16
  [I;MSEC] _ I DIVMOD 31; INC MSEC  !DAY OF THE MONTH IN MSEC
  [I;SEC] _ I DIVMOD 12             !MONTH-1 IN SEC
  I _ I + 64                      !YEAR IN I
  IF 0<=SEC<=11 THEN DO SEC OF 0:11
 0: MINIT_'JAN'
 1: MINIT_'FEB'
 2: MINIT_'MAR'
 3: MINIT_'APR'
 4: MINIT_'MAY'
 5: MINIT_'JUN'
 6: MINIT_'JUL'
 7: MINIT_'AUG'
 8: MINIT_'SEP'
 9: MINIT_'OCT'
10: MINIT_'NOV'
11: MINIT_'DEC'
END ELSE MINIT_'BUG'
PR(MSEC,10); W(L,$-); MESS(L,MINIT); W(L,$-); PR(I,10); MESS(L,'  ')
  EXU(OCT 47,OCT 16,OCT 23)  
  I _ ^OCT 16  !TIME OF DAY IN MILLISECONDS
  [I;MSEC] _ I DIVMOD 1000
  [I; SEC] _ I DIVMOD   60
  [I;MINIT] _ I DIVMOD   60
  PR(I,10); W(L,$:); PR(MINIT,10);W(L,$:);PR(SEC,10);W(L,$.)
  IF MSEC<100 THEN W(L,$0)
  PR(MSEC,10)
  MESS(L,'$$')
  NEW.PAGE _ 0
  BEG.LIS.LN
  END
IF CREF THEN [W(L,OCT 177); W(L,OCT 103); W(L,OCT 11)] !CREF INFO

DO HOW OF 4
BOTH: I_PCTR.PTR
      REPEAT 5 W(L,NBYV I+$0)  !THE 5 DIGITS OF THE PROGRAM COUNTER
      IF PURE THEN W(L,$.)  !DOTS WILL SHOW PURE CODE
      W(L,$	)
      W.REL(PCTR,A)    !PUT OCTAL ON REL FILE AT PROPER LOCATION
   INC PCTR
      I_A.PTR; REPEAT 6 W(L,NBYV I+$0); W(L,$	)
NO.OCTAL: I_PCTR.PTR; REPEAT 5 W(L,NBYV I+$0); W(L,$	)
          REPEAT 6 WX(L,$ )
          W(L,$	)   !TAB INSTEAD OF 7TH SPACE
ALONE: REPEAT 6 WX(L,$ )
       W(L,$	)  !TAB INSTEAD OF 7TH SPACE
       REPEAT 6 WX(L,$ )
       W(L,$	)  !TAB INSTEAD OF 7TH SPACE
NO.PCTR: REPEAT 6 WX(L,$ )
         W(L,$	)  !TAB INSTEAD OF 7TH SPACE
         I_A.PTR; REPEAT 6 W(L,NBYV I+$0); W(L,$	)
END
EIF NOT PRINTED THEN DO
  I_PRINT.LINE
  WHILE W(L,NCHV I) # CARRET THEN NULL
  INC PRINTED
  END
ELSE W(L,CARRET)
BEG.LIS.LN
RETURN

%PR.FILE(F,FIDP())   !PRINT FILE NAME
DEF SXPT(X) AS [6,6,24]*[36,6,(X)]
LOCAL CHAR,SIXPTR

SIXPTR _ SXPT(@NAMARG(FIDP))
LOOP [REPEAT 6; WHILE CHAR_NCHV SIXPTR#0; W(F,CHAR+ OCT 40)]
IF HW(@EXTARG(FIDP))#0 THEN DO
  W(F,$.); SIXPTR _ SXPT(@EXTARG(FIDP))
  LOOP [REPEAT 3; WHILE CHAR_NCHV SIXPTR#0; W(F,CHAR+OCT 40)]
  END
RETURN

END PR.FILE

END LIS.LN

%BEG.LIS.LN
IF CREF THEN [W(L,OCT 177); W(L,OCT 102)]
RETURN
END BEG.LIS.LN

%END.LIS.LN
IF CREF THEN [W(L,OCT 177); W(L,OCT 104)]
RETURN
END END.LIS.LN

%LIS.REF(X)
LOCAL I,P
IF CREF THEN DO
   WX(L,OCT 1)
   I_SYMCC MIN 6
   WX(L,I)
   P_CHPT(@SYMBUF(1),-1)
   REPEAT I W(L,NCHV P)
END
RETURN
END LIS.REF

%LIS.DEF
IF CREF THEN [LIS.REF(LABPNT); WX(L,OCT 2)]
RETURN
END LIS.DEF

%DUMP(TAB,BEG.TAB,CUR.ADD)
LOCAL NOMORE:,ARRAY(),I

ARRAY_BLOCK( (CUR.ADD-BEG.TAB+130)/131, 0, NOCORE)  !GRAB SOME CORE

DMP(TAB,NOMORE)  !GET READY TO DUMP TABLE

REPEAT CUR.ADD-BEG.TAB+10 DO
  GET.SYM(I_D.NXT.SYM)
  ARRAY(^I-BEG.TAB) _ SYMBUF(1) SHR 1  !THE ADDRESS SHOULD BE IN ^I
! PR(SYMBUF(1) SHR 1,8)    DEBUG
  END
ERR('$BUG IN DUMP$')

NOMORE: PCTR _ BEG.TAB
        I _ 0
        WHILE PCTR < CUR.ADD THEN DO
          A _ ARRAY(INC I)  !2ND COLUMN WILL BE VALUE OF ITEM
          LISLN(BOTH)  !1ST COLUMN WILL SHOW ADDRESS
          END
        RELEASE((CUR.ADD-BEG.TAB+130)/131, ARRAY, NOCORE)  !RELEASE CORE
RETURN
END DUMP
END PASS2

%W.REL(LOC,OCTAL)
LOCAL PLOC,WD,OLDWD,I,J


IF NO.REL THEN RETURN
IF WD#-1 THEN DO   !SOMETHING IN WD?
  IF PLOC=LOC-1 THEN DO   !DOES IT GO WITH CURRENT OCTAL?
    WD_WD BOR OCTAL SHL 4 BOR 1     !YES, PUT EM TOGETHER, TURN ON 1 BIT
    SETCP(BIN,(LOC+2)/2)      !AND WRITE THEM AT
    W(BIN,WD)             !THE PROPER PLACE
    WD_-1
    RETURN
    END
  I_SIZE(BIN)-1
  IF J_SETCP(BIN,(PLOC+2)/2)>I THEN OLDWD_0 ELSE [OLDWD_R(BIN);SETCP(BIN,J)]
  W(BIN,WD BOR (OLDWD BAND OCT 3777761))  !NO, PUT LEFT PART OUT
  WD_-1
  END
IF LOC MOD 2 THEN DO   !IS LOC ODD OR EVEN?
  I_SIZE(BIN)-1
  IF J_SETCP(BIN,(LOC+2)/2)>I THEN OLDWD_0 ELSE [OLDWD_R(BIN);SETCP(BIN,J)]
  W(BIN,(OLDWD BAND OCT 777774000002) BOR (OCTAL SHL 4) BOR 1)
  RETURN   !PUT OCTAL IN RIGHT PART OF APPROP FILE WORD
  END
WD_OCTAL SHL 20 BOR 2  !PUT OCTAL IN LEFT PART OF WORD, TURN ON 2 BIT
PLOC_LOC          !SAVE LOC IT BELONGS IN
RETURN

%INIT.W.REL
WD _ PLOC _ -1
W(BIN,OCT 770000000777) !PDP SAV NEEDS THIS AS 1ST WD
RETURN
END INIT.W.REL

END W.REL


%DMP.C.POOL

LOCAL J,LOC,ENDPURE,ENDIMPURE,%CKSUM,LOC.PTR,%LIS.LOC

IF LAST.ECK=FIRST.SCK=-1 THEN RETURN
IF LAST.ECK<0 OR FIRST.SCK<0 THEN DO
  MESS(E,'$C DIRECTIVE NEEDS AT LEAST ONE SCKSUM-ECKSUM PAIR$')
  RETURN
  END
IF NO.REL THEN DO
  MESS(E,'$SPECIFY REL TO LIST C POOL$')
  RETURN
  END
IF NOT NO.LST THEN [MESS(L,'$CHECKSUM POOL$'); LINES+_2]
BEG.LIS.LN
PCTR _ BEG.CKS.POOL
A _ FIRST.SCK
LISLN(BOTH)


J_ECK(CUR.CK);SCK(INC CUR.CK)_J  ! MAKES THE ENDING NEATER
A _ 1  !LEAVE ROOM FOR 2 HEADER WDS IN CKSUM POOL
J _ 0
WHILE INC J < CUR.CK THEN DO
  A +_ (ECK(J)-SCK(J))/255 + 1
  A +_ (SCK(J+1)-ECK(J))/255
  END
IF A > NO.CKSUMS THEN DO
  MESS(E,'$OVERFLOW OF CKSUM POOL, USE$$  C  *+')
  PRF(E,A*2,8)
  MESS(E,'$')
  RETURN
  END
DEBUG: NULL
NO.CKSUMS _ A +_ A  !DOUBLE IT, 2 WORDS FOR EACH ENTRY
A +_ BEG.CKS.POOL-1
LISLN(BOTH)
LOC.PTR _ BYPT(@LOC,6,3)  !SO LOC CAN BE SHOWN ON LISTING
J _ 0

WHILE INC J < CUR.CK THEN DO
  LOC _ ENDPURE _ SCK(J)
  ENDIMPURE _ ECK(J)
  WHILE ENDPURE < ECK(J) THEN DO
    IF ENDPURE +_ 255 >= ECK(J) THEN DO
      ENDPURE _ ECK(J)
      ENDIMPURE _ ENDIMPURE+255 MIN SCK(J+1)
      END
    A _ [BPW-16,8,8]*[0,ENDPURE-LOC,ENDIMPURE-ECK(J)]
    LIS.LOC
    LIS.LN(BOTH)
    A _ CKSUM  !THIS WILL CAUSE LOC _ ENDPURE
    LIS.LN(BOTH)
    END

  WHILE ENDIMPURE < SCK(J+1) THEN DO
    LOC _ ENDIMPURE <== ENDIMPURE+255 MIN SCK(J+1)
    A _ [BPW-16,8,8]*[0,0,ENDIMPURE-LOC]
    LIS.LOC
    LIS.LN(BOTH)
    A _ 0
    LIS.LN(BOTH)
    END

  END
END.LIS.LN
RELEASE((NO.CKSUMS+130)/131,SCK,NOCORE)
RELEASE((NO.CKSUMS+130)/131,ECK,NOCORE)
IF PCTR-BEG.CKS.POOL # NO.CKSUMS THEN MESS(E,'$CKSUM BUG$')
RETURN

%CKSUM

LOCAL WD,CHKSUM,A

CHKSUM _ 0
SETCP(BIN,(LOC+2)/2)
WD _ R(BIN)

WHILE LOC < ENDPURE THEN DO
  IF LOC MOD 2 THEN [A_WD SHR 4;WD_R(BIN)] ELSE A_WD SHR 20
  CHKSUM BXOR _ (A BAND OCT 177777)
  INC LOC
  END
RETURN CHKSUM

END CKSUM

%LIS.LOC

LOCAL P,Q

    P_PRINTLINE; Q_LOC.PTR
    REPEAT 5 NCHV P _ NBYV Q + $0  !LIST 5 DIGITS OF LOC
    NCHV P _ CARRET
    PRINTED _ 0
    RETURN
END LIS.LOC
END DMP.C.POOL
 