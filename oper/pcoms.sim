TABLE HELPM["ENTER DICTIONARY NAME AND RECORD NAME SERPARATED$&
BY A SEMI-COLON.$"]
TABLE HELPM2["ENTER DICTIONARY NAME, RECORD NAME, AND FIELD NAME $&
SEPARATED BY SEMI-COLONS.$"]

GLOBAL %RSTAT,%INITR,%DISP,%EDIT,%MODIFY,%SAVE,%ADDR,%DEL, %PRNT
GLOBAL %MULTIPLE,%QUIT,%HELP,%EXPL,%LATER, %TOUT, %ECHO
GLOBAL %CONTINUE, %TRUNCATE, %SEARCH, %TRACE
GLOBAL %TIN, %INCLUDE, %EOF, %ABORT, %INT.LIN, %CLR.IN, %CLS.IN
FIND %XPUTC, %XMSG, %XPUT, %GRAB, %UNGRAB, %IXPUTC, %IXPUT, %READID
FIND %EXTRAN, %EXTERR, %PNUM, %IXMSG, %SPACER, QPTR, %QSAVE
FIND %AMBIG, %GARB, %RDLINE, %FMATCH, LINPTR, %ERROR
FIND ERRET:, %MATERR, %RNUM, STATUS, %SETSIZ, %UNWIND, %TRANID
FIND %FORMAT, %FINDER, %CHKSTA, %PRINTER, DBLOCK(), OFFSDP, FLDOFF
FIND OFFEDT, %RSIZE, %ADDSUB, %RBASE, %NEW.DBLK, %COP.DBLK
FIND FLOATER(), %OPEND, %DELID, %DCTERR, %YESNO, %ADDID, DNOFF
FIND SAVPTR, %READER, %WRT.REC
LOCAL %SPRNT

DEF SET.CONT(X) AS STATUS _ (STATUS BAND OCT 77777777777) BOR X

%RSTAT
STATUS _ -1
RETURN
END RSTAT

%INITR
FIND FTAB(1), FDCT, RDCT, REC1, REC2, FILERR(1)
LOCAL FNUM, PTAB(), ERR:, I

GRAB(0)

FNUM _ OPEND(@FDCT,1,1,200)
FOR I _ 1 TO FTAB(0) DO
  PTAB _ FTAB(I)
  ADDID(FNUM, ERR, ERR, PTAB(0), 0, @PTAB(2), PTAB(1))
END
CLOSE(FNUM)

SETSIZ(-1,0)
FNUM _ OPEND(@RDCT,1,1,20)
PTAB _ @REC1
ADDID(FNUM, ERR, ERR, PTAB(0), 0, @PTAB(2), PTAB(1))
PTAB _ @REC2
ADDID(FNUM, ERR, ERR, PTAB(0), 0, @PTAB(2), PTAB(1))
CLOSE(FNUM)

UNGRAB(-1)
RETURN

ERR: IXMSG("ERROR INITIALIZING"); DCTERR; GO ERRET

END INITR

%DISP
LOCAL TRAY(), I, FLDID, BIT, OFF, T1, T2, TREC()
READID ("IDENTITY: ",HELPM,2)
TRANID (2)

TRAY _ FADD(DFORM)

IF TRAY(@OFFSDP) BAND STATUS = 0 THEN &
  ERROR ("NOT ALLOWED TO DISPLAY THIS DICTIONARY$")

IF CHKSTA(DISP.OK) # 0 THEN RETURN

FORMAT (@TRAY(@FLDOFF))

TREC _ FADD(RECORD)
T1 _ TREC(0); T2 _  TREC(1)

FOR I _ 1 TO TRAY(@FLDOFF) DO
  IF T1 < 0 THEN DO
    [12,12,12]*[FLDID,BIT,OFF] _ TRAY(I+@FLDOFF)
    PRINTER(FLDID,BIT,OFF)
  END
  [T1; T2] _ [T1; T2] DSHL 1
END

XPUT(CARRET)
RETURN
END DISP

%EDIT
LOCAL ODB

READID("IDENTITY: ",HELPM2, 3)
TRANID(3)

GRAB(0)
ODB _ DBLOCK(1)
NEW.DBLK

SPRNT(EDIT.OK)

WRT.REC(1)
COP.DBLK(ODB)

UNGRAB(0)
RETURN

END EDIT

%MODIFY
RETURN
END MODIFY

%SAVE
RETURN
END SAVE

%ADDR
LOCAL I, TMP1, TMP2, ODB, TMP3

ODB _ DBLOCK(1)
NEW.DBLK

ADDSUB

COP.DBLK(ODB)

UNGRAB( TMP2 )
DBLOCK _ ODB

RETURN
END ADDR

%DEL
LOCAL FNUM

READID("IDENTITY: ",HELPM,2)
TRANID(2)

GRAB(0)

FNUM _ OPEND( FADDS( DFORM, @DNOFF ), 2, 0)

OFF.ALT
IF DELID( FNUM, 0, 0, DBLOCK(LOCTAB(RID)) )# 0 THEN DO
  ON.ALT
  IXMSG("ERROR DELETING RECORD$")
  DCTERR
  GO ERRET
END
DBLOCK( LOCTAB(RID) ) _ DBLOCK(LOCTAB(RECORD)) _ 0
CLOSE( FNUM )
UNGRAB( 0 )
ON.ALT

RETURN

END DEL

%MULTIPLE
FIND SAVPTR,LINPTR,ERRET:,%DISPATCH
DEF TBUFF AS FLOATER(4)
DEF TPTR1 AS FLOATER(3)
DEF TPTR2 AS FLOATER(2)
DEF BLEN AS 52
TABLE REPTM["TYPE THE COMMAND STRING THAT YOU WOULD LIKE REPEATED."]
TABLE HMESS["TYPE 'YES' IF YOU WANT THE COMMAND STRING REPEATED.$&
TYPE 'NO' IF YOU DO NOT WANT THE COMMAND STRING REPEATED."]
LOCAL TPTR3, DUM1, TMP1, ID

[DUM1; TMP1] _ DOUBLE GRAB(BLEN+5)
FLOATER(0) _ RETURN
FLOATER(1) _ ID <== TMP1

TPTR1_LINPTR_RDLINE("COMMAND STRING: ",REPTM,0,1)
TPTR3_TPTR2_CHPT(@TBUFF,-1)

LOOP WHILE NCHV TPTR2 _ NCHV TPTR1 # EOLIT

IF SAVPTR # 0 THEN DO
  TPTR1 _ SAVPTR <== TPTR2
  LOOP WHILE NCHV TPTR2 _ NCHV TPTR1 # CARRET
END

TPTR1 _ SAVPTR
TPTR2 _ TPTR3

LOOP DO
  IF DISPATCH = -1 THEN GO ERRET
  IXMSG("$$"); QSAVE("DO "); NCHV QPTR _ $"
  TPTR3 _ TPTR2
  LOOP WHILE NCHV TPTR3 = $ 
  PCHV TPTR3
  WHILE NCHV TPTR3 # EOLIT THEN NCHV QPTR _ CHV TPTR3
  NCHV QPTR _ $"
  WHILE YESNO(" AGAIN? ",HMESS) = 0
  SAVPTR _ TPTR1
  LINPTR _ TPTR2
END
UNWIND(ID)
RETURN _ FLOATER(0)
ID _ FLOATER(1)
UNGRAB(-1)
RETURN
END MULTIPLE

%QUIT
CLS.IN
CLOSEALL
EXIT
GO ERRET
END QUIT

%EXPL
FIND CMDS, NCMDS
LOCAL %EXP, FVL, PTR, PTR2, FRAY(), I
TABLE EXPM["TYPE THE COMMAND YOU WANT EXPLAINED OR 'ALL'"]
TABLE ATAB["ALL"]

FRAY _ @CMDS

PTR2 _ PTR _ RDLINE("COMMAND: ",EXPM,0,1)

IF FVL _ FMATCH(@CMDS,NCMDS,@LINPTR,-1,-1,-1) >= 0 THEN &
  [EXP( FVL); RETURN]

PTR <=> LINPTR

IF FMATCH(@ATAB,1,@LINPTR,-1,0,-1) < 0 THEN [MATERR(FVL,PTR2,PTR);&
  GO ERRET]

XMSG("VALID COMMANDS ARE:$")
FOR I _ 0 TO NCMDS-1 &
  IF STATUS BAND ^BYT( FRAY(I), 18, 18) # 0 THEN EXP(I)

RETURN

%EXP(I)
XMSG( OCT 777777 BAND FRAY(I))
XMSG(" - ")
XMSG( BYT( ^( BYT( FRAY(I), 18, 18)+1 ), 18, 18))
XPUT(CARRET)
RETURN
END EXP
END EXPL

%HELP
FIND CMDS, NCMDS
LOCAL FRAY(), I

FRAY _ @CMDS

XMSG("VALID COMMANDS ARE:$")
FOR I _ 0 TO NCMDS-1 &
  IF STATUS BAND ^BYT( FRAY(I), 18, 18) # 0 THEN &
  [XMSG( OCT 777777 BAND FRAY(I)); XPUT(CARRET)]

RETURN
END HELP

%LATER
FIND  ERRLOC, CONFLG
FIND LAT.LEV, TRUNFLG, %DISPATCH, LINBUF(1)
LOCAL PTR1, PTR2, LRET:, TVL, DUM1, ID
DEF TB AS FLOATER(3)

[DUM1; TVL] _ DOUBLE GRAB(55)
FLOATER(0) _ RETURN
FLOATER(1) _ ERRLOC <== LRET
FLOATER(2) _ ID <== TVL
TB _ EOLIT

LRET: LOOP DO
  UNWIND(ID)
  MOVE 52 FROM @TB TO IMAGE
  NCHV QPTR _ $(; QSAVE(PNUM(LAT.LEV),10); NCHV QPTR _ $)
  PTR1 _ PTR2 _ RDLINE(" ?? ",0,2,0)
  MOVE 52 FROM LINBUF TO @TB
  SET.CONT(OCT 600000000000)
  IF DISPATCH >= 0 AND (CONFLG # 0 OR TRUNFLG # 0) THEN DO
    UNWIND(ID)
    CONFLG _ 0
    RETURN _ FLOATER(0)
    ERRLOC _ FLOATER(1)
    ID _ FLOATER(2)
    UNGRAB(-1)
    RETURN
  END
END
END LATER

%EOF
!%%%
FIND RLC:, ITELFN
LOCAL %SAVE.FILE, %NEXT.FILE, TINEOF:
LOCAL TMP, CBP(0:15), IBP(0:15), STRINGS(0:299), FIL.NUMS(0:15)
LOCAL STKPTR, CHAR.CNT, NBP

LOOP WHILE TMP _ NCHV LINPTR = $ 
PCHV LINPTR
IF TMP = EOLIT AND SAVPTR = 0 THEN [ NEXT.FILE; RETURN ]

%%TIN
!%%%

CLOSE( HW( @FIL.NUMS(STKPTR), 1) )
CHAR.CNT - _ HW( @FIL.NUMS(STKPTR), 0)
NBP _ IBP( STKPTR )
DEC STKPTR

%%INCLUDE
!%%%%%%%%
TABLE INM["TYPE THE NAME OF YOUR COMMAND INPUT FILE$"]

RDLINE( "FILE: ", INM, 0, 1)
SAVE.FILE
NEXT.FILE
RETURN

%%ABORT

CLS.IN
INT.LIN
RETURN


TINEOF: NEXT.FILE; GO RLC


%SAVE.FILE
!%%%%%%%%%
LOCAL OLD.CNT, TAB(0:51), TINERR:
FIND FILERR(1), ERRNUM

IF INC STKPTR > 15 THEN DO
  DEC STKPTR
  ERROR ("TOO MANY STACKED COMMAND FILES$")
END

CBP(STKPTR) _ IBP(STKPTR) _ NBP

OLD.CNT _ CHAR.CNT

LOOP DO

  LOOP WHILE NCHV LINPTR = $ 

  WHILE CHV LINPTR # EOLIT

  PCHV LINPTR

  LOOP DO

    IF INC CHAR.CNT >= 299 THEN ERROR("FILE NAME TABLE OVERFLOW$")

    WHILE EOLIT # NCHV NBP _ NCHV LINPTR # $+
    WHILE CHV NBP # $,

  END

  PCHV NBP

  LOOP DO

    WHILE CHV NBP = $ 
    PCHV NBP
    DEC CHAR.CNT
  END

  NCHV NBP _ EOLIT

  IF CHV LINPTR = EOLIT THEN PCHV LINPTR

END

PCHV LINPTR

NCHV NBP _ CARRET
INC CHAR.CNT

FIL.NUMS(STKPTR) _ [18,18]*[ CHAR.CNT - OLD.CNT, 0 ]

RETURN

%%NEXT.FILE
!%%%%%%%%%%
LOCAL FPTR

CLOSE( HW( @FIL.NUMS(STKPTR), 1) )

EIF NCHV CBP(STKPTR) = CARRET THEN DO

  IF STKPTR = 0 THEN [CLS.IN; INT.LIN; RETURN ]
  NBP _ IBP(STKPTR)
  CHAR.CNT - _ HW( @FIL.NUMS(STKPTR), 0)
  ITELFN _ HW( @FIL.NUMS( DEC STKPTR ), 1)

END

ELSE DO

  PCHV CBP(STKPTR)

  FPTR _ CHPT(TAB,-1)

  LOOP WHILE NCHV FPTR _ NCHV CBP(STKPTR) # EOLIT

  SETRWE( HW(@FIL.NUMS(STKPTR),1) _ ITELFN _ &
    OPEN( TAB, SEQUEN+INPUT+CHARACTER,TINERR,1), TINEOF)

END

RETURN

TINERR: IXMSG("ERROR OPENING FILE - "); IXMSG(TAB)
IXMSG( FILERR(ERRNUM) )
GO ERRET

%CLR.IN
!%%%%%%%
FIND OTELFN

CLS.IN
CLOSE( OTELFN <== TEL )
CLIBUF

%%INT.LIN
!%%%%%%%%%
FIND TB(1), QBUFF(1)

STKPTR _ 0
NBP _ CBP(0) _ IBP(0) _ CHPT( STRINGS, -1)
NCHV NBP _ CARRET
FIL.NUMS(0) _ [18,18]*[1,TEL]
CHAR.CNT _ 1
LINPTR _ CHPT(TB,-1)
TB(0) _ EOLIT
SAVPTR _ 0
QPTR _ CHPT(QBUFF,-1)
RETURN


END CLR.IN



END SAVE.FILE

%CLS.IN
!%%%%%%

LOOP DO

  WHILE STKPTR > 0
  CLOSE( HW( @FIL.NUMS(STKPTR), 1) )
  DEC STKPTR

END

ITELFN _ TEL

RETURN

END CLS.IN


END EOF


%TOUT
LOCAL TOOTE1:,TOOTE2:, DTAB(0:51), %RFNAME
FIND OTELFN, FILERR(1), FECHO
TABLE OUTM["TYPE THE NAME OF YOUR COMMAND OUTPUT FILE"]
CLOSE(OTELFN <== OPEN(RFNAME(OUTM), SEQUEN+OUTPUT+CHARACTER,TOOTE1,1) )
SETRWE(OTELFN,TOOTE2)
RETURN
TOOTE1: IXMSG("ERROR OPENING FILE- "); IXMSG(DTAB)
IXMSG(FILERR(ERRNUM))
CLRIN; GO ERRET
TOOTE2: IXMSG("ERROR ON TOUT FILE."); ERROR(FILERR(ERRNUM))
%%ECHO
TABLE ETAB(0:1)["ON","OFF"]
TABLE HM["TYPE 'ON' IF YOU WANT ALL INPUT ECHOED TO THE$&
COMMAND OUTPUT FILE. OTHERWISE, TYPE 'OFF'."]
RDLINE("ON OR OFF? ",HM, 0, 1)
LOOP DO
  DO FMATCH(ETAB,2,@LINPTR,-1,0,-1)+2 OF 0:3
0: 1: CLRIN
SPACER(-1)
RDLINE("PARDON? ","TYPE 'ON' OR 'OFF'", 2, 1)
2: FECHO _ 0
RETURN
3: FECHO _ -1
RETURN
END
END

%RFNAME (MESS)
LOCAL DPTR
RDLINE("FILE: ",MESS, 0, 1)
DPTR _ CHPT(DTAB,-1)
LOOP WHILE NCHV LINPTR = $ 
PCHV LINPTR
LOOP DO
  NCHV DPTR _ NCHV LINPTR
  WHILE CHV LINPTR # EOLIT
END
PCHV LINPTR
RETURN DTAB
END RFNAME

END TOUT

%CONTINUE
FIND CONFLG
CONFLG _ -1
RETURN
END CONTINUE

%TRUNCATE
FIND TRUNFLG
LOCAL FVL
FVL _ RNUM(10)
IF EXTRAN # 2 THEN [EXTERR(LINPTR,2); GO ERRET]
TRUNFLG _ FVL MAX 1
RETURN
END TRUNCATE

%SEARCH
FIND LAT.LEV, TRUNFLG
GRAB(1)
FLOATER(0) _ RETURN
INC LAT.LEV
LOOP DO
  XMSG("FAKING SEARCH$")
  LATER
  WHILE TRUNFLG = 0
END
DEC TRUNFLG
DEC LAT.LEV
RETURN _ FLOATER(0)
UNGRAB(-1)
RETURN
END SEARCH

%TRACE
FIND LAT.LEV, TRUNFLG
GRAB(1)
FLOATER(0) _ RETURN
INC LAT.LEV
LOOP DO
  XMSG("FAKING TRACE$")
  LATER
  WHILE TRUNFLG = 0
END
DEC TRUNFLG
DEC LAT.LEV
RETURN _ FLOATER(0)
UNGRAB(-1)
RETURN
END TRACE

%PRNT
READID("IDENTITY: ",HELPM2, 3)
TRANID(3)
SPRNT(DISP.OK)
XPUT(CARRET)
RETURN
END PRNT

%SPRNT (MODE)
LOCAL TRAY(), TREC(), I, T1, T2, TID, FLDID, BIT, OFF

TRAY _ FADD(DFORM)

IF TRAY( IF MODE = DISP.OK THEN @OFFSDP ELSE @OFFEDT) BAND STATUS = 0 &
  THEN ERROR("SPECIFIED COMMAND NOT ALLOWED ON THIS DICTONARY.$")

IF CHKSTA(MODE) # 0 THEN RETURN

TREC _ FADD(RECORD)
T1 _ TREC(0); T2 _ TREC(1)

TID _ DBLOCK(LOCTAB(FID))

FOR I _ 1 TO TRAY(@FLDOFF) DO
  IF T1 < 0 THEN DO
    [12,12,12]*[FLDID,BIT,OFF] _ TRAY(I+@FLDOFF)
    IF TID = FLDID THEN DO
      XPUT(CARRET)
      EIF MODE # EDIT.OK THEN DO
        IF PRINTER(TID, BIT, OFF) # 0 THEN &
          ERROR("MAY NOT PRINT THIS FIELD.$")
      END
      ELSE READER(TID, BIT, OFF, MODE)
      RETURN
    END
  END
  [T1; T2] _ [T1; T2] DSHL 1
END

ERROR("CANNOT FIND FIELD IN RECORD.$")

END SPRNT
 