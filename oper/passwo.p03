BASE 0

!PROCEDURES
GLOBAL %PASSWO
FIND %PASSIN, %BYPT, %INITTTY,%HASH,%QUERY, %GETTOKEN
FIND %CHR.OUT,%NUMOUT,%SIXOUT,%MAKE.SIXBIT
FIND %DATOUT, %A.CIR.OP
LOCAL %CHK.IO.ERR, %COMPRS.NAME
LOCAL %FIND.NXT.NAME, %SEND.ONE.CHG
LOCAL %DUL.LOOK,%DUL.OVERFLOW
LOCAL %LUD.LOOK, %LUD.OVERFLOW
LOCAL %INITPASSWO
DEF SIZE.BLK AS 128

GLOBAL TABLE COMPRS(0:44)[$ ,$A,$B,$C,$D,$E,$F,$G,$H,$I,$J,$K,$L,$M,&
   $N,$O,$P,$Q,$R,$S,$T,$U,$V,$W,$X,$Y,$Z,0,$-,$.,$/,$0,$1,$2,$3,$4,&
   $5,$6,$7,$8,$9,$:,$*,$',0]

!ID'S
FIND TOKEN(0)
LOCAL  THISPPN,THISACCT,THISLIC, THISNAM(2)
GLOBAL NUMBER,NAME.HASH,LOC.HASH,P,CH.OUT, PASSW(2)
GLOBAL USER(2), CUSER(4), TYPALT:
GLOBAL OP, A.CHAR, A.STR, A.CHAN

LOCAL CH.LUD,CH.DUL,IO.ADR
LOCAL D.INDEX,D.BLK(SIZE.BLK)
LOCAL L.INDEX,L.BLK(SIZE.BLK)
LOCAL CH.IN, FILE.FLG, MORE.FLG
LOCAL TEMP, COUNT

!MACRO'S
DEF ACTSUP.BIT AS BYT(LUD(3),1,13)
DEF BLD AS -1
DEF BUILD.CIR AS [CALL.CIR.OP(BLD,0,'CUD:1;'); IF A.CHAN < 0 THEN CIR.ERR]
DEF CALL.CIR.OP(A,B,C) AS [OP_A;A.CHAR_B;A.STR_C;A.CIR.OP]
DEF CIR.ERR AS [MSG('$CIRCUIT NOT BUILT - ERROR '); A.CHAN_(A.CHAN SHL 1) SHL -1;&
	A.CHAN_HW(@A.CHAN,0); NUMOUT(A.CHAN); GO TYPALT]
DEF CODE AS 2
DEF CR AS CHR.OUT(CARRET)
DEF FIRSTOF24(A) AS BYT(A,1,23)
DEF FIXCP(A) AS (A-1)*SIZE.BLK	!COMPUTE CURSOR POS. FROM BLK. NO.
DEF LUD.READ AS [RB(CH.LUD,SIZE.BLK,L.BLK); L.INDEX_0]
DEF DUL(A) AS D.BLK(D.INDEX+A)
DEF LUD(A) AS L.BLK(L.INDEX+A)
DEF DUL.READ AS [RB(CH.DUL,SIZE.BLK,D.BLK); D.INDEX_0]
DEF GETNAME AS [GETTOKEN(2);MAKE.SIXBIT(TOKEN,USER,12)]
DEF NOT.VALID AS [IF FILE.FLG # 0 THEN [SIXOUT(USER,12); SP];&
	MSG(' INVALID NAME$')]
DEF OPEN.DUL AS CH.DUL _ OPEN('(SYS)DUL.SYS',DIRECT+INPUT+WORD,&
	CHK.ERR)
DEF OPEN.LUD AS CH.LUD _ OPEN('(SYS)LUD.SYS',DIRECT+INPUT+WORD,&
	CHK.ERR)
DEF OV.BLK AS HW(@LUD(0),1)
DEF PROT.FAILURE AS [IF FILE.FLG # 0 THEN [SIXOUT(USER,12); SP];&
	MSG(' NOT YOUR GLOBAL ACCOUNT$')]
DEF A.RECIEVE.8 AS 0
DEF SAMACCT AS THISACCT = HW(@LUD(0),0)
DEF SAMUSER AS THISNAM(0) = USER(0) AND THISNAM(1) = USER(1)
DEF SEND.WD(A) AS [PTR_BYPT(A,4,4) BAND SIZ.OUT + SIZ.IN;&
	REPEAT 3 CALL.CIR.OP(A.SEND.8,NCHV PTR,0)]
DEF A.SEND.8 AS 3
DEF SIXBIT.TAB(A) AS COMPRS(A) - OCT 40
DEF SIZ.OUT AS OCT 770000777777
DEF SIZ.IN AS OCT 1000000000
DEF SIZE.LUD.ENT AS BYT(LUD(2),7,0)
DEF SP AS CHR.OUT($ )
DEF VERSION AS 3
DEF ZAP AS -2


!LABELS
LOCAL CHK.ERR:
%PASSWO
	!MAINLINE
START: IOCS(2); INITPASSWO
\\->START
	 CH.OUT _ OPEN('TEL',SEQUEN+OUTPUT+CHARACTER,CHK.ERR,2)
IF THISLIC = 0 OR QUERY('$YOURS ONLY') = 1 THEN DO
	PASSIN
	SEND.ONE.CHG
	GO TYPALT
END
PASSIN
MSG('$ENTER USER NAMES: ')
LOOP DO
   FIND.NXT.NAME
   IF MORE.FLG = 0 THEN GO TYPALT
   SEND.ONE.CHG
END
TYPALT: A.CHAN _ -1; CALL.CIR.OP(ZAP,0,0);  CLOSE.ALL; ONALT
	MSG('$$END OF JOB$'); EXIT

%LUD.LOOK(ADR)
	!LOOK UP NAME IN ADR,ADR+1 IN LUD
OPEN.LUD
HASH(^ADR,^(ADR+1))
SETCP(CH.LUD,FIXCP(LOC.HASH)); LUD.READ 
WHILE NAME.HASH # LUD(4) THEN DO	
	L.INDEX+_SIZE.LUD.ENT
	IF LUD(0)=0 THEN RETURN 0
	IF LUD(0)<0 THEN LUD.OVERFLOW
	END
RETURN 1
END LUD.LOOK


%DUL.LOOK(PPN)
	!LOOK UP PPN IN DUL
OPEN.DUL
SETCP(CH.DUL,FIXCP((PPN MOD 101)+1)); DUL.READ
WHILE DUL(0)#PPN THEN DO
	D.INDEX+_3
	IF DUL(0)=0 THEN RETURN 0
	IF DUL(0)<0 THEN DUL.OVERFLOW
	END
RETURN 1
END DUL.LOOK


%CHK.IO.ERR
	!TAKE CARE OF ALL I/O ERRORS FROM IOCS...
CHK.ERR: IF ERRNUM=EOFERR AND IO.ADR # 0 THEN GO ^IO.ADR
 MSG('ERROR ON ');WFID(FIDP);MSG('...');CR
  DO ERRNUM OF TMFERR:CORERR
FNDERR: MSG('BAD FILE MODE OR TYPE')
IFDERR: MSG('ILLEGAL FILE IDENTIFIER')
FNFERR: MSG('FILE NOT FOUND')
IUSERR: MSG('INVALID USER NAME')
PRTERR: MSG('PROTECTION FAILURE')
EOFERR: MSG('END OF FILE')
 END
MSG('.$ERROR ');NUMOUT(ERRNUM);EXIT
END CHK.IO.ERR



%LUD.OVERFLOW
	!READ LUD OVERFLOW BLOCK
SETCP(CH.LUD,OV.BLK*SIZE.BLK)
LUD.READ
RETURN
END LUD.OVERFLOW


%DUL.OVERFLOW
	!READ DUL OVERFLOW BLOCK
SETCP(CH.DUL,HW(DUL(0),1)*SIZE.BLK)
DUL.READ
RETURN
END DUL.OVERFLOW


%INITPASSWO
	!INIT PROGRAM
INITTTY(TYPALT)
MSG('$CHANGE PASSWORD - VERSION '); NUMOUT(VERSION)
	DATOUT
MOVE 72/CHARS.PER.WORD FROM ALL 0 TO TOKEN
THISPPN _ EXU(OCT 47,OCT 1,OCT 24)
THISACCT _ HW(@THISPPN,0)
IF DUL.LOOK(THISPPN) = 0 THEN [MSG(' THIS USER NAME NOT IN DUL');&
	EXIT]
USER(0) _ THISNAM(0) _ DUL(1); USER(1) _ THISNAM(1) _ DUL(2)
OPEN.LUD
IF LUD.LOOK(@DUL(1)) = 0 THEN [SIXOUT(D.BLK+D.INDEX+1,12); MSG(' NOT IN LUD')&
	;EXIT]
THISLIC _ ACTSUP.BIT
FILE.FLG _ 0; MORE.FLG _ 1
ALTLOC _ TYPALT; OFFALT
CLOSE.ALL
BUILD.CIR
TRY: CALL.CIR.OP(A.RECIEVE.8,0,0); IF A.CHAR = 1 THEN DO
    CALL.CIR.OP(A.RECIEVE.8,0,0); IF A.CHAR = 1 THEN DO
	CALL.CIR.OP(A.RECIEVE.8,0,0); IF A.CHAR # OCT 40 THEN GO TRY
   END ELSE GO TRY
END ELSE GO TRY
CALL.CIR.OP(A.SEND.8,1,0); CALL.CIR.OP(A.SEND.8,1,0)
CALL.CIR.OP(A.SEND.8,OCT 40,0)
OPEN.LUD
RETURN
END INITPASSWO

%COMPRS.NAME
	!COMPRESS USER NAME IN USER,USER+1 INTO CUSER,CUSER+1,CUSER+2
LOCAL P1,I,J,K,CHARS(4),TEMP
COUNT _ 10
P1 _ BYPT(USER,1,6)
FOR K _ 0 TO 2 DO
   FOR J _ 0 TO 3 DO
	TEMP _ NCHV P1; I _ -1
		!IF LOWER CASE, CONVERT TO UPPER
	IF TEMP > OCT 100 AND TEMP < OCT 133 THEN TEMP - _ OCT 40
	WHILE INC I < 44 AND TEMP # SIXBIT.TAB(I) THEN NULL
	CHARS(J) _ I
   END
CUSER(K) _ (((CHARS(0)*45)+CHARS(1))*45+CHARS(2))*45+CHARS(3)
END


EIF CUSER(1) = 0 THEN FIRSTOF24(CUSER(0)) _ 1
ORIF CUSER(2) = 0 THEN [COUNT+_3; FIRSTOF24(CUSER(1))_1]
ELSE COUNT+_6

RETURN
END COMPRS.NAME


%FIND.NXT.NAME
LOCAL IN.END:, TMP
LOOP DO
 IF FILE.FLG = 0 THEN DO
   P _ GETLINE(TEL)
   IF TMP _ NCHV P = CARRET THEN [MORE.FLG _ 0; RETURN]
   IF TMP = $@ THEN DO
	INC FILE.FLG
	GETTOKEN(0)
	CH.IN _ OPEN(TOKEN,SEQUEN+CHARACTER+INPUT,IN.END,2)
	P _ GETLINE(CH.IN)
   END ELSE PCHV P
 END ELSE P _ GETLINE(CH.IN)
   GETNAME
   IF LUD.LOOK(USER) # 0 THEN DO
	IF (THIS.LIC = 1 AND SAMACCT) OR SAMUSER THEN &
	   RETURN ELSE PROT.FAILURE
   END ELSE NOT.VALID
END

IN.END: IF ERRNUM # EOFERR THEN CHK.IO.ERR
   FILE.FLG _ 0; MORE.FLG _ 0
   RETURN
END FIND.NXT.NAME


%SEND.ONE.CHG
LOCAL PTR
COMPRS.NAME
CALL.CIR.OP(A.SEND.8,COUNT,0); CALL.CIR.OP(A.SEND.8,CODE,0)
FOR TEMP _ 1 TO 2 SEND.WD(PASSW+TEMP-1)
FOR TEMP _ 1 TO (COUNT-7)/3 SEND.WD(CUSER+TEMP-1)
CALL.CIR.OP(A.SEND.8,OCT 40,0)
CALL.CIR.OP(A.RECIEVE.8,0,0)
IF A.CHAR = 0 THEN [CALL.CIR.OP(A.RECIEVE.8,0,0); RETURN]
MSG('$ERROR ON AUX. CIR.$')
CALL.CIR.OP(A.RECIEVE.8,0,0)
EIF A.CHAR = 1 THEN [NOT.VALID; RETURN]
ORIF A.CHAR = 3 THEN MSG('MUD FILE BUSY - TRY AGAIN LATER$')
ELSE [MSG('ERROR '); NUMOUT(A.CHAR)]
GO TYPALT
END SEND.ONE.CHG

END PASSWO
