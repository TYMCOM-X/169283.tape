     10=INPUT,TAPE50)
      COMMON /CONTRL/ NTYPE,JSTAR,JDTI,JSTOP,JDTF
      COMMON /SGDTS/ JDTS,J1ST,JPDT,J1SAV,JSAVDT,JINT,JRXGEN
      COMMON /PASS/ FILT,VECTOR,BKDOWN,RSS
      LOGICAL FILT,VECTOR,BKDOWN,RSS
      COMMON /COUNTR/ J,JDT,JIN,JIDT,JFDT,NERR
      COMMON /LOGICL/ FILTAP,JSTART,VCHAN,LRESET
      LOGICAL FILTAP,JSTART,VCHAN,LRESET
      COMMON /SGDATA/ LISTH,LISTV,JRESTR,JDUM1,JDUM2
      COMMON /RESTR/ RESTAR,NRLEVL,NRPASS
      LOGICAL RESTAR
C
C     MAIN PROGRAM. CONTAINS PRIMARY SYSTEM DRIVE LOOPS
C
      CALL ZMEN
    1 CALL DATAIN
      CALL START
      CALL PLABAK
      DO 200 J=JSTAR,JSTOP
      CALL SEGIN
      CALL PATHIN
      IF (NTYPE.EQ.4) GO TO 4
      IF (VECTOR) GO TO 2
      CALL COVIN
      CALL RINIT
      IF (FILT) CALL SIMIN
      CALL FMATIN
      CALL GMATIN
      GO TO 3
    2 CALL STATIN
      CALL FMATIN
    3 CALL TRNMAT
    4 CALL PATHRS
      DO 100 JDT=JIDT,JFDT
      IF (JDT.LE.0) GO TO 10
      DO 5 JIN=1,JINT
      CALL PROPM
      CALL PATH
      IF (NTYPE.EQ.4) GO TO 5
      CALL PROPQ
    5 CONTINUE
   10 CALL ESTMT
   11 IF (JDT.GE.J1ST.AND. MOD(JDT-J1ST,JPDT).EQ.0) CALL PRINTO
      IF (JDT.GE.J1SAV.AND.MOD(JDT-J1SAV,JSAVDT).EQ.0) CALL DATAPE
  100 CONTINUE
      IF (JRESTR.NE.0) CALL RECORD
  200 CONTINUE
      GO TO 1
      END
C
      SUBROUTINE AAT(B,A,NR,NC,NBR,NAR)
      DIMENSION B(NBR,1),A(NAR,1)
C
C     COMPUTE  B = A*AT
      DO 10 I=1,NR
      DO 10 J=I,NR
      X = 0.
      DO 1 K=1,NC
      X = X + A(I,K)*A(J,K)
    1 CONTINUE
      B(I,J) = B(J,I) = X
   10 CONTINUE
      RETURN
      END
      SUBROUTINE ADAT(R,S,G,NR,NG,NRR,NGR)
      DIMENSION S(1),R(NRR,1),G(NGR,1)
C
C     COMPUTE ADAT WHERE D IS A DIAGONIAL MATRIX
C
      DO 10 I=1,NR
      DO 10 J=I,NR
      X = 0.
      DO 1 K=1,NG
      X = X + G(I,K)*G(J,K)*S(K)
    1 CONTINUE
      R(I,J) = R(J,I) = X
   10 CONTINUE
      RETURN
      END
C
      SUBROUTINE ARAT(T,R,A,NR,NC,NRT,NRR,NAR,ICK)
      DIMENSION  A(NAR,1), R(NRR,1), T(NRT,1),  S(25)
      COMMON  /DIMENS/  NF, NS, NSF, NDYN, NCTRL, NRA, NG, LINK(50)
C
COMMENT     COMPUTE  T(NR,NR) = A(NR,NC)R(NC,NC)AT(NC,NR)
C                  WHERE  A  IS PARTITIONED
C
      JX = 1
      JXX = NC
      DO 9 J=1,NR
      IF (J.LE.ICK)     GO TO 1
      LX = LINK(J)
      IF (LX.LE.0)     GO TO 1
      JX = J
      JXX = JX + LX - 1
C
COMMENT     COMPUTE DOT PRODUCT OF  R  AND JTH COLUMN OF  A(T)
C                  STORE IN INTERNAL STORAGE VECTOR  S
    1 DO 3 L=JX,NC
      X = 0.0
      DO 2 K=JX,JXX
      X = X + R(L,K)*A(J,K)
    2 CONTINUE
      S(L) = X
    3 CONTINUE
C
      IX = 1
      IXX = NC
      DO 7 I=J,NR
      IF (I.LE.ICK)     GO TO 5
      LX = LINK(I)
      IF (LX.LE.0)      GO TO 5
      IX = I
      IXX = IX + LX - 1
C
COMMENT     COMPUTE DOT PRODUCT OF  A  AND  S
    5 X = 0.0
      DO 6 K=IX,IXX
      X = X + A(I,K)*S(K)
    6 CONTINUE
      T(I,J) = T(J,I) = X
    7 CONTINUE
    9 CONTINUE
      RETURN
      END
C
      SUBROUTINE CEPPOS(CEP,SIGX,SIGY,SIGXY,PER)
      CEP = 0.
      U = SIGX + SIGY
      IF (U.LT.0.) U=0.
      V = SIGX*SIGY - SIGXY**2
      R = U**2 - 4.*V
      IF (R.LT.0.) R = 0.
      R = SQRT(R)
      IF (R.GT.U) R = U
      X = 0.5*(U+R)
      Y = 0.5*(U-R)
      IF (PER.GE..001) GO TO 100
      X = SQRT(X)
      Y = SQRT(Y)
      IF (X.LE.0) RETURN
    1 R = Y/X
      IF (R.LT..4) GO TO 2
      CEP = .6121*Y + .5653*X
      RETURN
    2 CEP = .8317*R*Y + .6745*X
      RETURN
  100 R = Y/X
      A = (1.+R**2)/( (1.+R)**2)
      B = ((R*(1.-R))**2)/((1.+R)**4)
      U = 1. - 2.*A/9. - 40.*B/81.
      SIG = SQRT(2.*A/9. + 16.*B/27.)
      PROB =  (100. - PER)/100.
      XP = SQRT(-ALOG(PROB**2))
      R = XP - (2.515517+.802853*XP+.010324*XP**2)/(1.+1.432788*XP+.1892
     169'XP''2+.001308'XP''3)
      CEP = SQRT(X*(R*SIG+U)**3)
      RETURN
      END
      SUBROUTINE COVIN
      COMMON /STATE/ IST(50,5),ST(50,4),LOGIC(50,25),LABEL(50)
      LOGICAL LOGIC
      COMMON /QRMAT/ Q(25,25),R(25,25),S(25,25,6)
      COMMON /LOGICL/ FILTAP,JSTART,VCHAN,LRESET
      LOGICAL FILTAP,JSTART,VCHAN,LRESET
      COMMON /DIMENS/ NF,NS,NSF,NDYN,NCTRL,NRA, NG,LINK(50)
      COMMON /COUNTR/ J,JDT,JIN,JIDT,JFDT,NERR
      COMMON /PASS/ FILT,VECTOR,BKDOWN,RSS
      LOGICAL FILT,VECTOR,BKDOWN,RSS
      TYPE LOGICAL LOGN,LOGM
C
C     SETS UP INITIAL COVARIANCE MATRIX
C
      N1 = 1
      IF (BKDOWN) N1 = NCTRL + 1
      IF (.NOT.JSTART) GO TO 1
      CALL ZERO(Q,NDYN,NDYN,25)
    1 DO 2 I=N1,NDYN
      IF (LINK(I).EQ.0.AND.I.GT.LINK(1)) GO TO 2
      IT = IST(I,2)
      IF (IT.EQ.3) GO TO 2
      LOGN = LOGIC(I,J)
      LOGM = .FALSE.
      IF (.NOT.JSTART) LOGM = LOGIC(I,J-1)
      IF (IT.LT.0.OR.IT.GE.9) CALL ERROR1(7)
      IF (LOGM.AND.LOGN.OR..NOT.(LOGM.OR.LOGN)) GO TO 2
      LX = I
      LINKI = LINK(I)
      IF (I.LE.LINK(1)) LINKI = 1
      LXX = I + LINKI - 1
      DO 4 L=LX,LXX
      DO 4 K=1,NDYN
      Q(K,L) = 0.
      Q(L,K) = 0.
    4 CONTINUE
      IF (.NOT.LOGN) GO TO 2
      DO 5 L=LX,LXX
      Q(L,L) = (ST(L)*ST(L,2))**2
    5 CONTINUE
    2 CONTINUE
      RETURN
      END
C
      SUBROUTINE CROSS(A,B,C)
      DIMENSION A(3),B(3),C(3)
C
C     A = B CROSS C
C
      A(1) = B(2)*C(3) - B(3)*C(2)
      A(2) = B(3)*C(1) - B(1)*C(3)
      A(3) = B(1)*C(2) - B(2)*C(1)
      RETURN
      END
C
      SUBROUTINE DATAIN
      COMMON /LABEL/ XLABEL(6),SLABEL(6),SGLABL(6),OL(2,10)
      COMMON /RESTR/ RESTAR,NRLEVL,NRPASS
      LOGICAL RESTAR
      COMMON /CONTRL/ NTYPE,JSTAR,JDTI,JSTOP,JDTF
      COMMON /LOGICL/ FILTAP,JSTART,VCHAN,LRESET
      LOGICAL FILTAP,JSTART,VCHAN,LRESET
      COMMON /PASS/ FILT,VECTOR,BKDOWN,RSS
      LOGICAL FILT,VECTOR,BKDOWN,RSS
      COMMON /RXGEN/ RX(11,10),MDT(11),RANIN
      COMMON /LIST/ XLIST(50,15),LC(15)
      COMMON /INIT/ LATO,LONGO,PSIO,ALPHAO,VELO,ALTO,VZO
      COMMON /DIMENS/ NF,NS,NSF,NDYN,NCTRL,NRA, NG,LINK(50)
      COMMON /TIMER/ TIME,TS,TF,DTSTEP,DTINTG,TBASE
      COMMON /OUTPT/ NINERT,NCOV,NTRN,NRXO,NERS,NSAVE(6),SAVO,FRSS,PRMIN
      COMMON /PAGIN/ LPAG(5),PAGX(5)
      LOGICAL MATCH
      TYPE LOGICALPRMIN,SAVO,FRSS
      TYPE LOGICAL LPAG
      COMMON /SEGMNT/ JPATH(25),JMECH(25),JSYS(25),JFILT(25),JDIFF(25),
     1JDTS(25),JINT(25),JRXGEN(25),LISTVH(25),JOBS(25,8),J1ST(25),
     2JPDT(25),JVERT(25),J1SAV(25),JSAVDT(25),JRESTR(25),JDUM(25,2),
     3VEL(25),DT(25),HEAD(25),LONG(25),TREF(25),THALF(25),XLEVER(25),
     4YLEVER(25),ZLEVER(25),CL1(25),CL2(25),CL3(25),CL4(25),CL5(25),
     5VCL1(25),VCL2(25),AVGACC(25),VZ(25),DUM(25,2),SEGLAB(25,6)
      COMMON /OBSERV/ KCODE(20),K1ST(20),KON(20),KOFF(20),KST(20,6),
     1KDUM(20,2),OBSIG(20),OBSF(20),OB1(20),OB2(20),OB3(20),OB4(20),
     2OBLABL(2,20)
      COMMON /STATE/ ICODE(50),ITYPE(50),ILIST(50),LINKS(50),IFILT(50),
     1SIG(50),SF(50),TAU(50),RNOISE(50),LOGIC(50,25),LABEL(50)
      LOGICAL LOGIC
      LOGICAL FILTP
      DIMENSION T(6),U(7)
C
C
C     READ INPUT DATA
C
C
      REAL LATO,LONGO,LONG
      NAMELIST /DATA/ KCODE,K1ST,KON,KOFF,KST,KDUM,OBSIG,OBSF,OB1,
     1OB2,OB3,OB4,JPATH,JMECH,JSYS,JFILT,JDIFF,JDTS,JINT,JRXGEN,LISTVH,
     2JOBS,J1ST,JPDT,JVERT,J1SAV,JSAVDT,JRESTR,JDUM,VEL,DT,HEAD,
     3LONG,TREF,XLEVER,YLEVER,ZLEVER,CL1,CL2,CL3,CL4,CL5,
     4VCL1,VCL2,AVGACC,VZ,DUM,JSTAR,JDTI,JSTOP,JDTF,NER,NTYPE,JFINAL,
     5NRESTR,ICODE,ITYPE,ILIST,LINKS,IFILT,SIG,SF,TAU,RNOISE,LOGIC,
     6RESTAR,FILTAP,VCHAN,RX,MDT,RANIN,XLIST,LC,LATO,LONGO,PSIO,
     7ALPHAO,VELO,ALTO,VZO,NF,NS,TBASE,NINERT,NCOV,NTRN,NRXO,NERS,
     8SAVO,FRSS,PRMIN,LPAG,THALF
C
C
      RESTAR = .FALSE.
C
      ENTRY DATARS
C
      FILTP = NTYPE.EQ.0
  101 READ 100,I,(U(L),L=1,7)
  100 FORMAT (I1,7A10)
      IF (EOF(60)) 120,102
  102 IF(I.LE.1) GO TO 1
      DECODE (70,103,U) JF,JL,(T(L),L=1,6)
  103 FORMAT(2I2,5X,6A10)
      GO TO (1,2,3,4,5),I
    2 DO 20 K=1,6
   20 XLABEL(K) = T(K)
      GO TO 101
    3 IF (JL.GT.20) CALL ERROR1(0)
      DECODE (60,30,T) ((OBLABL(K,J),K=1,2),J=JF,JL)
   30 FORMAT (6A10)
      GO TO 101
    4 IF (JL.GT.50) CALL ERROR1(0)
      DECODE (60,40,T) (LABEL(J),J=JF,JL)
   40 FORMAT (6A10)
      DO 50 J=JF,JL
      CALL SETSF(SF(J),LABEL(J),MATCH)
      IF (MATCH) GO TO 50
   50 CONTINUE
      GO TO 101
    5 DO 51 K=1,6
      SEGLAB(JF,K) = T(K)
   51 CONTINUE
      GO TO 101
C
    1 BACKSPACE 60
      READ (60,DATA)
      FILT = NTYPE.EQ.0
      IF (FILTP.AND..NOT.FILT) CALL SAVTAP
      RETURN
C
  120 ENDFILE 50
      ENDFILE 40
      IF(FILT) CALL SAVTAP
      CALL ZPLOT
      STOP
      END
      SUBROUTINE DATAPE
      COMMON /OUTPT/ NSAVE(11),SAVO,FRSS,PRMIN
      TYPE LOGICAL SAVO
C
      IF (.NOT.SAVO) RETURN
      PRINT 1
    1 FORMAT (1H1,' DATA TAPE ROUTINE NOT COMPLETED= SAVO SET TO FALSE')
      SAVO = .FALSE.
      RETURN
      END
      SUBROUTINE DIST(RANGE,PSII,PSIF,PI,PF)
      DIMENSION PSII(3),PSIF(3),PI(3),PF(3)
      DATA RE/2.0926E+07/
C
C     SOLVES GREAT CIRCLE GEOMETRY GIVEN END POINT DATA. RETURNS MINIMUM
C     DISTANCE BETWEEN SPECIFIED POINTS AS WELL AS INITIAL AND FINAL
C     HEADING.
C
      SLATF = SIN(PF(1))
      SLATI = SIN(PI(1))
      CLATF = COS(PF(1))
      CLATI = COS(PI(1))
      CLONG = COS(PI(2)-PF(2))
      CROE = SLATF*SLATI +CLATF*CLATI*CLONG
      RANGE = RE*ACOS(CROE)
      SLONG = SIN(PI(2)-PF(2))
      IF (CLATI.NE.0) GO TO 1
      PSII(1) = SIGN(1.570796327,PI(1)) + 1.570796327
      GO TO 2
    1 PSII(1) = ATAN2(SLONG*CLATF,(SLATF-CROE*SLATI)/CLATI)
    2 IF (CLATF.NE.0.) GO TO 3
      PSIF(1) = SIGN(1.570796327,PI(1)) + 1.570796327
      RETURN
    3 PSIF(1) = ATAN2(SLONG*CLATI,(CROE*SLATF-SLATI)/CLATF)
      RETURN
      END
C
      SUBROUTINE ERROR1(I)
      PRINT 1,I
    1 FORMAT (1H1,'PROGRAM ERROR NO. 'I2'. PROBLEM NOT VALID')
      STOP
      END
C
C
      SUBROUTINE ESTMT
      COMMON /OBSERV/ KOBS(20,12),OBS(20,6),OBLABL(2,20)
      COMMON /OBDATA/ NOBS,KOB,KCODE,NOBZ
      COMMON /DIMENS/ NF,NS,NSF,NDYN,NCTRL,NRA, NG,LINK(50)
      COMMON /SEGMNT/ JSEG(25,25),SEG(25,20),SEGLAB(25,6)
      COMMON /LOGICL/ FILTAP,JSTART,VCHAN,LRESET
      LOGICAL FILTAP,JSTART,VCHAN,LRESET
      COMMON /COUNTR/ J,JDT,JIN,JIDT,JFDT,NERR
      COMMON /QRMAT/ Q(25,25),R(25,25),TEMP1(25,25),A(25,25),TEMP(25,25)
     1,AR(25,25),ARESET(25,50)
      COMMON /FGMAT/ F(25,25),G(25,25),T(25,25),ARSET(25,25)
      COMMON /PASS/ FILT,VECTOR,BKDOWN,RSS
      LOGICAL FILT,VECTOR,BKDOWN,RSS
      COMMON /OBMAT/ OBMAT(10,50),OBNV(10,10),COEF(50,10),OBNS(10,10),OB
     1SIG(10),X(40)
C
C     DISCRETE OR KALMAN RESETS TO SYSTEM MATRICES
C
      LRESET = .FALSE.
      IF (JDT.NE.0) GO TO 1
      CALL RESET1
      IF (VECTOR) GO TO 3
    2 CALL ARAT (TEMP,Q,ARESET,NDYN,NDYN,25,25,25,LINK(1))
      CALL MATMOV(Q,TEMP,NDYN,NDYN,25,25)
      GO TO 1
    3 CALL MATMPY(TEMP,ARESET,Q,NCTRL,NCTRL,NDYN,25,25,25)
      CALL MATMOV(Q,TEMP,NCTRL,NDYN,25,25)
    1 NOBS = 0
      CALL ZERO(OBSIG,10,1,10)
      CALL ZERO(OBNV,10,10,10)
      CALL ZERO(OBMAT,10,NDYN,10)
      DO 10 I=1,8
      KOB =JSEG(J,I+9)
      KCODE = KOBS(KOB)
      IF (KCODE.LE.0.OR.KCODE.GT.99.OR.KOB.EQ.0) GO TO 10
      IF (JDT.LT.KOBS(KOB,2).OR.(MOD(JDT-KOBS(KOB,2),KOBS(KOB,3)+KOBS(KO
     1B,4)).GE.KOBS(KOB,3)))  GO TO 10
      CALL OBSET
   10 CONTINUE
      IF (NOBS.EQ.0) GO TO 100
      LRESET = .TRUE.
      IF (RSS) GO TO 50
      CALL MATMOV(TEMP1,Q,NRA,NDYN,25,25)
      IF (.NOT.FILT) GO TO 50
      CALL ARAT(OBNS,Q,OBMAT,NOBS,NDYN,10,25,10,10)
      DO 11 I=1,NOBS
      DO 19 IA=1,NOBS
      OBNS(I,IA) = OBNS(I,IA) + OBNV(I,IA)
   19 CONTINUE
      OBNS(I,I) = OBNS(I,I) + OBSIG(I)
   11 CONTINUE
      CALL MATALG(OBNS,OBNV,NOBS,NOBS,1,DET,10)
      CALL MATTRN(COEF,OBMAT,NDYN,NOBS,50,10)
      CALL MATMPY(TEMP,Q,COEF,NDYN,NDYN,NOBS,25,25,50)
      CALL MATMPY(COEF,TEMP,OBNV,NDYN,NOBS,NOBS,50,25,10)
      CALL SAVCOF
      CALL MATMPY(TEMP,COEF,OBMAT,NDYN,NOBS,NDYN,25,50,10)
      DO 12 I=1,NDYN
      DO 13 K=1,NDYN
      TEMP(I,K) = -TEMP(I,K)
   13 CONTINUE
      TEMP(I,I) = TEMP(I,I) + 1
   12 CONTINUE
      CALL MATMPY( ARSET,TEMP,Q,NDYN,NDYN,NDYN,25,25,25)
      CALL MATMOV(Q, ARSET,NDYN,NDYN,25,25)
      CALL MATSYM(Q,NDYN,NDYN,25)
      GO TO 100
   50 CALL ZERO(COEF,NRA,NOBS,50)
      CALL SETCOF
      IF (RSS) RETURN
      ND = NDYN
      IF (VECTOR) ND = NCTRL
      CALL MATMPY(TEMP,COEF,OBMAT, ND ,NOBS,NDYN,25,50,10)
      DO 51 I=1,ND
      DO 53 K=1,NDYN
      TEMP(I,K) = -TEMP(I,K)
   53 CONTINUE
      TEMP(I,I) = TEMP(I,I) + 1
   51 CONTINUE
      IF (VECTOR) GO TO 60
      CALL ARAT( ARSET,Q,TEMP,NDYN,NDYN,25,25,25,NCTRL)
      IF (BKDOWN.AND.NS.NE.0) GO TO 52
      DO 59 I=1,NOBS
      OBNV(I,I) = OBNV(I,I) + OBSIG(I)
   59 CONTINUE
      CALL ARAT(TEMP,OBNV,COEF,NDYN,NOBS,25,10,50,NDYN)
      CALL MATADD(Q,ARSET ,TEMP,NDYN,NDYN,25,25,25)
      GO TO 100
   52 CALL MATMOV(Q,ARSET,NDYN,NDYN,25,25)
      GO TO 100
   60 IF (NDYN.LE.NCTRL) GO TO 62
      NDX = NCTRL + 1
      DO 63 I=NDX,NDYN
      LINKI = LINK(I)
      IF (LINKI.EQ.0) GO TO 63
      DO 61 K=1,LINKI
      DO 61 L=1,LINKI
      KX = NCTRL + K
      LX = I + L - 1
      TEMP(KX,LX) = 0.
      IF (K.EQ.L) TEMP(KX,LX) = 1.
   61 CONTINUE
   63 CONTINUE
   62 CALL ZERO(ARESET,NRA,NDYN,25)
      CALL MATMP1(ARESET,TEMP,Q)
      CALL MATMOV(Q,ARESET,NRA,NDYN,25,25)
  100 NOBZ = 0
      DO 101 I=1,8
      KOB = JSEG(J,I+9)
      KCODE = KOBS(KOB)
      IF (KCODE.LE.50.OR.KCODE.GT.59.OR.KOB.EQ.0) GO TO 101
      IF (JDT.LT.KOBS(KOB,2).OR.(MOD(JDT-KOBS(KOB,2),KOBS(KOB,3)+KOBS(KO
     1B,4)).GE.KOBS(KOB,3))) GO TO 101
      CALL RESET
  101 CONTINUE
      IF (NOBZ.EQ.0) RETURN
      IF (LRESET) GO TO 102
      CALL MATMOV(TEMP1,Q,NRA,NDYN,25,25)
  102 IF (VECTOR) GO TO 103
      CALL ARAT(TEMP,Q,ARESET,NDYN,NDYN,25,25,25,25)
      CALL MATMOV(Q,TEMP,NDYN,NDYN,25,25)
      RETURN
  103 CALL MATMPY(TEMP,ARESET,Q,NCTRL,NCTRL,NDYN,25,25,25)
      CALL MATMOV(Q,TEMP,NCTRL,NDYN,25,25)
      RETURN
      END
C
      SUBROUTINE FLYBY
      COMMON /OBSERV/ KOBS(20,12),OBS(20,6),OBLABL(2,20)
      COMMON /OBDATA/ NOBS,KOB,KCODE,NOBZ
      COMMON /LABEL/ XLABEL(6),SLABEL(6),SGLABL(6),OL(2,10)
      COMMON /PERT/  W(3),A(3),V(3),P(3),PSI(3),WB(3),WBD(3),TSB(3,3)
      COMMON /TIMER/ TIME,TIMES,TIMEF,DT,DTINTG,TBASE
      COMMON /OBMAT/ OBMAT(10,50),OBNV(10,10),COEF(50,10),OBNS(10,10),OB
     1SIG(10),Z(40)
      COMMON /ENDPTS/ VI(3),VF(3),VFP(3),WI(3),WF(3),PI(3),PF(3),PSII(3)
     1,PSIF(3),PSIP(3)
      DIMENSION PIX(3),PSIX(3),X(3),Y(3)
      DATA (RE=2.0926E+07),(RAD=57.2958)
      DATA (RTURN=1.570796327)
C
C     COMPUTES RANGE AND VELOCITY OBSERVABLES TO A KNOWN POINT(LAT,LONG)
C
      SIG = (OBS(KOB)*OBS(KOB,2))**2
      NOBS = NOBS + 1
      IX = KOBS(KOB,5)
      IY = KOBS(KOB,6)
      IZ = KOBS(KOB,7)
      IF (KCODE.LE.4) GO TO 62
      KCODE = KCODE - 4
      PIX(1) = PI(1)
      PIX(2) = PI(2)
      PSIX(1) = PSII(1)
      PSIX(2) = PSII(2)
      CALL LOCATE(Y,X,PIX,PSIX,OBS(KOB,3))
      X(1) = X(1) + RTURN
      CALL LOCATE(PIX,PSIX,Y,X,OBS(KOB,4))
      GO TO 66
   62 PIX(1) = OBS(KOB,3)/RAD
      PIX(2) = OBS(KOB,4)/RAD
   66 CALL DIST(RANG,X,Y,P,PIX)
      SR = RE*SIN(RANG/RE)
      CR = RE*(1.-COS(RANG/RE)) + P(3)
      CRS = SQRT(SR**2 + CR**2)
      GAMZ = -SR/CRS
   63 OBSIG(NOBS) = SIG
      OL(1,NOBS) = OBLABL(1,KOB)
      OL(2,NOBS) = OBLABL(2,KOB)
      GAMX = COS(X(1)-PSI(2))*CR/CRS
      GAMY = SIN(X(1)-PSI(2))*CR/CRS
      IF (KCODE.GE.3) GO TO 64
      OBMAT(NOBS,1) = GAMX
      OBMAT(NOBS,2) = GAMY
      IF (IX.NE.0) OBMAT(NOBS,IX) = GAMZ
      IF (IY.NE.0) OBMAT(NOBS,IY) = 9.83E+08
      IF (IZ.NE.0) OBMAT(NOBS,IZ) = 1.
      IF (KCODE.LE.1) RETURN
      NOBS = NOBS + 1
      KCODE = 1
      X(1) = 2.*PSI(1) - X(1)
      GO TO 63
   64 OBMAT(NOBS,3) = GAMX
      OBMAT(NOBS,4) = GAMY
      VDOP = GAMX*V(1) + GAMY*V(2) + GAMZ*V(3)
      OBMAT(NOBS,1) = (V(1)-VDOP*GAMX)/CRS
      OBMAT(NOBS,2) = (V(2)-VDOP*GAMY)/CRS
      IF (IX.EQ.0) GO TO 65
      OBMAT(NOBS,9) = (V(3)-VDOP*GAMZ)/CRS
      OBMAT(NOBS,8) = GAMZ
   65 IF (IY.NE.0) OBMAT(NOBS,IY) = 9.83E+08
      IF (IZ.NE.0) OBMAT(NOBS,IZ) = 1.
      IF (KCODE.LE.3) RETURN
      NOBS = NOBS + 1
      KCODE = 3
      X(1) = 2.*PSI(1) - X(1)
      GO TO 63
      END
C
      SUBROUTINE FMATIN
      COMMON /CLOOP/ GL1,GL2,GL3,GL4,GK1,GK2,GK3
      COMMON /DIMENS/ NF,NS,NSF,NDYN,NCTRL,NRA, NG,LINK(50)
      COMMON /STATE/ IST(50,5),ST(50,4),LOGIC(50,25),LABEL(50)
      LOGICAL LOGIC
      COMMON /PASS/ FILT,VECTOR,BKDOWN,RSS
      LOGICAL FILT,VECTOR,BKDOWN,RSS
      COMMON /FGMAT/ F(25,25),G(25,25),T(25,25),ARESET(25,25)
      COMMON /SGMODL/ JPATH,JMECH,JMODL,JDIFF,JFRAM,JVDAMP,JCLOOP,JGENX
      COMMON /SEGMNT/ JSEG(25,25),SEG(25,20),SEGLAB(25,6)
      COMMON /PERT/  W(3),A(3),V(3),P(3),PSI(3),WB(3),WBD(3),TSB(3,3)
      COMMON /DYNAM/ WT(3),AT(3),VT(3),PT(3),PSIT(3),WBT(3),WBDT(3),TSBT
     1(3,3)
      COMMON /OUTPT/ NINERT,NCOV,NTRN,NRXO,NERS,NSAVE(6),SAVO,FRSS,PRMIN
      COMMON /COUNTR/ J,JDT,JIN,JIDT,JFDT,NERR
      COMMON /TIMER/ TIME,TIMES,TIMEF,DT,DTINTG,TBASE
        COMMON /LOGICL/ FILTAP,JSTART,VCHAN,LRESET
      LOGICAL FILTAP,JSTART,VCHAN,LRESET
      DATA RE,WIT/2.0926E+07,7.29E-05/
C
C     MODE = 0 , FREE INERTIAL MODEL  (SCHULER TUNED)
C          = 1 , FREE INERTIAL, OPEN LOOP  (GROUND ALIGNMENT)
C          = 2 , FREE INERTIAL, SIMPLE FILTER MODEL
C          = 3 , OPEN LOOP FREE INERTIAL, SIMPLE FILTER MODEL
C          = 4 , THIRD  ORDER CLOSED LOOP LORAN INERTIAL
C          = 5 , FOURTH ORDER CLOSED LOOP LORAN INERTIAL
C          = 6 , SECOND ORDER CLOSED LOOP LEVELING, GROUND ALIGNMENT
C          = 7 , THIRD  ORDER CLOSED LOOP GYROCOMPASS, GROUND ALIGNMENT
C          = 8 , KALMAN OBSERVER OF FOURTH ORDER LORAN INERTIAL
C
C     STATE CODE  = 1 , X-AXIS POSITION ERROR
C                 = 2 , Y-AXIS POSITION ERROR
C                 = 3 , X-AXIS VELOCITY ERROR
C                 = 4 , Y-AXISCITY ERROR
C                 = 5 , TILT ABOUT X-AXIS
C                 = 6 , TILT ABOUT Y-AXIS
C                 = 7 , AZIMUTH MISALIGNMENT ERROR
C                 = 8 , VERTICAL VELOCITY ERROR
C                 = 9 , VERTICAL POSITION ERROR
C
      CALL ZERO (F,NRA,NSF,25)
C
C     DRIVING ERROR SOURCES
C
      IX = LINK(1) + 1
      DO 1001 I=IX,NDYN
      IF (LINK(I).EQ.0.OR..NOT.LOGIC(I,J)) GO TO 1001
      ITYPE = IST(I,2)
      IE = I
      IF (VECTOR.AND.I.GT.NCTRL) IE = NCTRL + 1
      IF (ITYPE.NE.1.AND.ITYPE.NE.5) GO TO 200
      F(IE,I) = -1./ST(I,3)
      GO TO 1001
  200 IF (ITYPE.GE.4.AND.ITYPE.LE.6) GO TO 300
      IF (ITYPE.NE.8) GO TO 1001
      IXX = LINK(I)
      DO 250 K=1,IXX
      KX = I + K - 1
      F(IE,KX) = ST(KX,3)
      IF (K.EQ.1) GO TO 250
      IEE = IE + K - 1
      F(IEE,KX-1) = 1.
  250 CONTINUE
      GO TO 1001
  300 IF (LINK(I+1).NE.0) CALL ERROR1(10)
      F(IE,I+1) = -ST(I,3)
      F(IE+1,I) = + ST(I,3)
      IF (ITYPE.EQ.6) GO TO 301
      F(IE,I) = -2.*ST(I,3)*ST(I+1,3)
      GO TO 1001
  301 F(IE,I) =-ST(I,3)*ST(I+1,3)
      F(IE+1,I+1) = F(IE,I)
 1001 CONTINUE
      WIT = 7.29E-05
      IF (JFRAM.GT.0) WIT = 0.
C
COMMENT     CLOSED  LOOP  MECHANIZATIONS
      JM = 0
      GL1 = GL2 = GL3 = GL4 = 0.0
      GK1 = GK2 = GK3 = 0.0
      IF (JMODL.LT.4)     GO TO 400
      IF (JMODL.GT.8)     CALL  ERROR1(35)
      JM = JMODL -3
      Z2 = SEG(J,10)**2
      TAU = SEG(J,11)
      GO TO (310,320,330,340,320), JM
C
COMMENT     THIRD ORDER LORAN INERTIAL GAIN CALCULATIONS
  310 GL4P = 0.
      GL1 = 3./TAU
      GL2P = (1.+2.*Z2)/(Z2*TAU**2)
      GL3P = 1./(Z2*TAU**3)
      GO TO 400
C
COMMENT     FOURTH ORDER LORAN INERTIAL GAIN CALCULATIONS
  320 GL1 = 4./TAU
      GL2P = 2.*(1.+2.*Z2)/(Z2*TAU**2)
      GL3P = 4./(Z2*TAU**3)
      GL4P = 1./(Z2*TAU**2)**2
      GO TO 400
C
COMMENT     SECOND ORDER LEVELING GAIN CALCULATIONS
C        GROUND  ALIGNMENT  ONLY
  330 GK3 = 0.
      GK1 = 2./TAU
      GK2 = 1./(Z2*TAU**2*32.174) - 1./2.0926E+07
      GO TO 400
C
COMMENT     THIRD ORDER GYROCOMPASSING GAIN CALCULATIONS
C        GROUND  ALIGNMENT  ONLY
  340 GK1 = 3./TAU
      GK2 = (1.+2.*Z2)/(Z2*TAU**2*32.174) - 1./2.0926E+07
      GK3 = 1./(Z2*TAU**3*32.174*W(1))
      GO TO 400
C
C
      ENTRY FMAT
C
C
  400 RE = 2.0926E+07 + P(3)
      GR= 32.174*(2.0926E+07/RE)**2 - (V(1)**2 + V(2)**2)/RE
      F(1,1) = F(2,2) = F(3,3) = F(4,4) = 0.0
      F(3,1) = F(4,2) = F(5,2) = F(6,1) = F(7,1) = 0.0
      F(5,4) = F(6,3) = F(7,3) = 0.0
      F(8,9) = 0.0
C
COMMENT     COMPUTE  RHO  VECTOR  (PLATFORM RATE)
      RX = -V(2)/RE
      RY =  V(1)/RE
COMMENT      RN ' RX'COS(PSI(2)) - RY'SIN(PSI(2))   -   ALPHA NOT ZERO
      RN = RX
      RW = RY
      RZ = RN*TAN(P(1))
C
COMMENT     COMPUTE  (W+OM)  VECTOR
      WOMX = 2.*W(1) - RX
      WOMY = 2.*W(2) - RY
      WOMZ = 2.*W(3) - RZ
C
COMMENT     COMPUTE  RHO(DOT)  VECTOR
      RDX = -(A(2) - WOMZ*V(1) + WOMX*V(3))/RE
      RDY = (A(1) - WOMY*V(3) + WOMZ*V(2))/RE
COM   RDN = RDX*COS(PSI(2)) - RDY*SIN(PSI(2))   -   ALPHA NOT ZERO
      RDN = RDX
      RDZ = RDN*TAN(P(1)) + RN*RW/COS(P(1))**2
      WMOM2 = W(1)**2 + W(2)**2 + W(3)**2 - WIT**2
C
      IF (JMODL.EQ.1 .OR. JMODL.EQ.3)     GO TO 510
COMMENT     THESE TERMS OMMITTED FOR OPEN LOOP OPERATION
      F(1,3) = 1.
      F(2,4) = 1.
      F(5,4) =-1./RE
      F(6,3) = 1./RE
  510 F(3,7) = A(2)
      F(4,7) = -A(1)
      F(5,7) = -W(2)
      F(6,7) = W(1)
COMMENT     CHECK FOR CLOSED LOOP OBSERVER FILTER MODEL
      IF (JMODL.EQ.8)     GO TO 545
      F(3,1) = A(3)/RE + WMOM2 - WOMX*RX
      F(3,2) = RDZ - WOMY*RX
      F(3,4) = 2.*W(3)
      F(3,6) = -A(3) - GR
      F(4,1) = -RDZ -WOMX*RY
      F(4,2) = A(3)/RE + WMOM2 - WOMY*RY
      F(4,3) = -2.*W(3)
      F(4,5) = A(3) + GR
      F(5,1) = -W(3)/RE
      F(5,6) = W(3)
      F(6,2) = -W(3)/RE
      F(6,5) = -W(3)
      F(7,1) = W(1)/RE
      F(7,2) = W(2)/RE
      F(7,5) = W(2)
      F(7,6) = -W(1)
C
      IF (.NOT.VCHAN)     GO TO 540
      IF (JMODL.EQ.2 .OR. JMODL.EQ.3)     GO TO 1000
COMMENT     THE FOLLOWING IS OMITTED FOR THE SIMPLIFIED KALMAN FILTER
C             OR WHEN THE VERTICAL CHANNEL IS  NOT  MODELED
      F(8,1) = RDY -A(1)/RE -WOMX*RZ
      F(8,2) =-RDX -A(2)/RE -WOMY*RZ
      F(3,9) = -RDY -WOMZ*RX
      F(4,9) = RDX -WOMZ*RY
      F(8,9) = WMOM2 -WOMZ*RZ + 2.*GR/RE
      F(3,8) = -2.*W(2)
      F(8,3) = -F(3,8)
      F(4,8) = 2*W(1)
      F(8,4) = -F(4,8)
      F(8,5) = -A(2)
      F(8,6) = A(1)
C
COM   OMITTED FOR OPEN LOOP OPERATION
      IF (JMODL.EQ.1) GO TO 520
      F(9,8) = 1.
C
COMMENT     VERTICAL  CHANNEL  MECHANIZATION
C          SECOND  ORDER  CRITICALLY  DAMPED
  520 IF (JVDAMP.NE.1)     GO TO 540
      X = SEG(J,15)
      F(8,9) = F(8,9) -1./X**2 - 2.*GR/RE
      F(9,9) = -2./X
C
COMMENT     CHECK FOR CLOSED LOOP OPERATION
  540 IF (JM.EQ.0)     GO TO 1000
      GO TO (550,550,560,560), JM
C
COMMENT     KALMAN OBSERVER OF FOURTH ORDER LORAN INERTIAL
  545 F(3,6) = -GR
      F(4,5) = GR
C
COMMENT     ADD  LORAN  INERTIAL  GAINS
  550 GL2 = GL2P -GR/RE
      GL3 = GL3P/GR- GL1/RE
      GL4 = GL4P/(GR*W(1))
      F(1,1) = F(1,1) - GL1
      F(2,2) = F(2,2) - GL1
      F(3,1) = F(3,1) - GL2
      F(4,2) = F(4,2) - GL2
      F(5,2) = F(5,2) - GL3
      F(6,1) = F(6,1) + GL3
      F(7,1) = F(7,1) + GL4
      GO TO 1000
C
COMMENT     ADD  CLOSED  LOOP  GROUND  ALIGNMENT  GAINS
  560 F(3,3) = F(3,3) - GK1
      F(4,4) = F(4,4) - GK1
      F(5,4) = F(5,4) - GK2
      F(6,3) = F(6,3) + GK2
      F(7,3) = F(7,3) + GK3
      GO TO 1000
C
 1000 CALL FMATX
      IF (NTRN.LT.2) RETURN
      IF (NTRN.EQ.2) GO TO 1006
      PRINT 1007,TIME
 1007 FORMAT (1H1,14X,'DYNAMICS MATRIX BY COLUMNS AT TIME 'E16.7 'SEC.')
      GO TO 1008
 1006 IF (JDT.NE.JIDT) RETURN
      PRINT 1002,J
 1002 FORMAT (1H1,14X,'DYNAMICS MATRIX BY COLUMNS AT START OF SEGMENT',
     1I3)
 1008 DO 1004 I=1,NSF
      PRINT 1003 ,I,(F(IA,I),IA=1,NRA)
 1003 FORMAT (1H0,14X,'COLUMN NO.',I2/(15X,5E14.5))
 1004 CONTINUE
      PRINT 1005,(W(I),I=1,3),(A(I),I=1,3),(V(I),I=1,3),(P(I),I=1,3),
     1(PSI(I),I=1,3),GL1,GL2,GL3,GL4,GK1,GK2,GK3,WMOM2,RDN,RDX,RDY,RDZ,
     2RN,RW,RZ,WOMX,WOMY,WOMZ
 1005 FORMAT (1H0,14X,'DYNAMICS DATA'/(15X,3E14.5))
      RETURN
      END
C
      SUBROUTINE FMATSP
      COMMON /COUNTR/ J,JDT,JIN,JIDT,JFDT,NERR
      COMMON /STDATA/ ICODE,I,IFRAM,IE,IB,IA,LINKI,LOGIJ,ISP(4)
      COMMON /FGMAT/ F(25,25),G(25,25),T(25,25),ARESET(25,25)
      COMMON /LOGICL/ FILTAP,JSTART,VCHAN,LRESET
      LOGICAL FILTAP,JSTART,VCHAN,LRESET
      COMMON /PERT/  W(3),A(3),V(3),P(3),PSI(3),WS(3),WBD(3),TSB(3,3)
      DIMENSION WB(3),AB(3),TSI(3,3),TBI(3,3),AT(3)
      DATA CA,SA,HCA,HSA/0.85065,0.52574,0.425325,0.26287/
C
C
      NENTRY = 0
      GO TO 1
C
      ENTRY FMSPEC
      NENTRY = 1
C
    1 IF ((ICODE-14)'(ICODE-19)) 2,2,3
    2 ICODE = 100*(ICODE-13)
    3 IE = ICODE/100
      IA = (ICODE-100*IE)/10 + 1
      IB = MOD(ICODE,10) + 1
      Z = 1.0
    4 GO TO (11,12,13,14,15,16),IE
   11 TBI(1,1) = TBI(3,3) = SA
      TBI(3,1) = CA
      TBI(1,3) = -CA
      TBI(2,2) = 1.0
      TBI(2,1) = TBI(1,2) = TBI(3,2) = TBI(2,3) = 0.0
      GO TO 20
   12 TBI(1,1) = TBI(3,3) = -SA
      TBI(3,1) = CA
      TBI(1,3) = -CA
      TBI(2,2) = 1.0
      TBI(2,1) = TBI(1,2) = TBI(3,2) = TBI(2,3) = 0.0
      GO TO 20
   13 TBI(1,1) = TBI(2,3) = CA
      TBI(2,1) = SA
      TBI(1,3) = -SA
      TBI(3,2) = -1.0
      TBI(3,1) = TBI(1,2) = TBI(2,2) = TBI(3,3) = 0.0
      GO TO 20
   14 TBI(1,1) = TBI(2,3) = CA
      TBI(2,1) = -SA
      TBI(1,3) = SA
      TBI(3,2) = -1.0
      TBI(3,1) = TBI(1,2) = TBI(2,2) = TBI(3,3) = 0.0
      GO TO 20
   15 TBI(3,1) = TBI(2,3) = SA
      TBI(2,1) = CA
      TBI(3,3) = -CA
      TBI(1,2) = 1.0
      TBI(1,1) = TBI(2,2) = TBI(3,2) = TBI(1,3) = 0.0
      GO TO 20
   16 TBI(3,1) = TBI(2,3) = -SA
      TBI(2,1) = CA
      TBI(3,3) = -CA
      TBI(1,2) = 1.0
      TBI(1,1) = TBI(2,2) = TBI(3,2) = TBI(1,3) = 0.0
   20 IF (J.NE.6) GO TO 120
      SG = SIN(0.9)
      CG = COS(0.9)
      CXX = TBI(1,1)*CG - TBI(3,1)*SG
      CYX = TBI(1,2)*CG - TBI(3,2)*SG
      CZX = TBI(1,3)*CG - TBI(3,3)*SG
      TBI(3,1) = TBI(1,1)*SG + TBI(3,1)*CG
      TBI(3,2) = TBI(1,2)*SG + TBI(3,2)*CG
      TBI(3,3) = TBI(1,3)*SG + TBI(3,3)*CG
      TBI(1,1) = CXX
      TBI(1,2) = CYX
      TBI(1,3) = CZX
  120 CALL MATMPY(TSI,TSB,TBI,3,3,3,3,3,3)
      AT(1) = A(1)
      AT(2) = A(2)
      RE = 2.0926E+07 + P(3)
      GR= 32.174*(2.0926E+07/RE)**2 - (V(1)**2 + V(2)**2)/RE
      AT(3) = A(3) + GR
      DO 21 K=1,3
      WB(K) = WS(K)
      AB(K) = 0.0
      DO 21 L=1,3
      WB(K) = WB(K) + TSI(L,K)*W(L)
      AB(K) = AB(K) + TSI(L,K)*AT(L)
   21 CONTINUE
      GO TO (30,22,23,24,25,26,27,100),IA
   22 Z = WB(1)
      GO TO 30
   23 Z = WB(2)
      GO TO 30
   24 Z = WB(3)
      GO TO 30
   25 Z = AB(1)
      GO TO 30
   26 Z = AB(2)
      GO TO 30
   27 Z = AB(3)
   30 GO TO (50,31,32,33,34,35,36,100),IB
   31 Z = Z*WB(1)
      GO TO 50
   32 Z = Z*WB(2)
      GO TO 50
   33 Z = Z*WB(3)
      GO TO 50
   34 Z = Z*AB(1)
      GO TO 50
   35 Z = Z*AB(2)
      GO TO 50
   36 Z = Z*AB(3)
   50 IF (NENTRY) 51,51,60
   51 GO TO (52,53,54,55,56,57),IE
   52 F(5,I) = Z*(HSA*TSB(1,1)+HCA*TSB(1,3))
      F(6,I) = Z*(HSA*TSB(2,1)+HCA*TSB(2,3))
      F(7,I) = Z*(HSA*TSB(3,1)+HCA*TSB(3,3))
      RETURN
   53 F(5,I) = Z*(-HSA*TSB(1,1)+HCA*TSB(1,3))
      F(6,I) = Z*(-HSA*TSB(2,1)+HCA*TSB(2,3))
      F(7,I) = Z*(-HSA*TSB(3,1)+HCA*TSB(3,3))
      RETURN
   54 F(5,I) = Z*(HCA*TSB(1,1) + HSA*TSB(1,2))
      F(6,I) = Z*(HCA*TSB(2,1) + HSA*TSB(2,2))
      F(7,I) = Z*(HCA*TSB(3,1) + HSA*TSB(3,2))
      RETURN
   55 F(5,I) = Z*(HCA*TSB(1,1) - HSA*TSB(1,2))
      F(6,I) = Z*(HCA*TSB(2,1) - HSA*TSB(2,2))
      F(7,I) = Z*(HCA*TSB(3,1) - HSA*TSB(2,2))
      RETURN
   56 F(5,I) = Z*(HCA*TSB(1,2) + HSA*TSB(1,3))
      F(6,I) = Z*(HCA*TSB(2,2) + HSA*TSB(2,3))
      F(7,I) = Z*(HCA*TSB(3,2) + HSA*TSB(3,3))
      RETURN
   57 F(5,I) = Z*(HCA*TSB(1,2) - HSA*TSB(1,3))
      F(6,I) = Z*(HCA*TSB(2,2) - HSA*TSB(2,3))
      F(7,I) = Z*(HCA*TSB(3,2) - HSA*TSB(3,3))
      RETURN
   60 GO TO (61,62,63,64,65,66),IE
   61 F(3,I) = Z*( HSA*TSB(1,1) + HCA*TSB(1,2))
      F(4,I) = Z*( HSA*TSB(2,1) + HCA*TSB(2,2))
      IF (.NOT.VCHAN) RETURN
      F(8,I) = Z*( HSA*TSB(3,1) + HCA*TSB(3,2))
      RETURN
   62 F(3,I) = Z*(-HSA*TSB(1,1) + HCA*TSB(1,2))
      F(4,I) = Z*(-HSA*TSB(2,1) + HCA*TSB(2,2))
      IF (.NOT.VCHAN) RETURN
      F(8,I) = Z*(-HSA*TSB(3,1) + HCA*TSB(3,2))
      RETURN
   63 F(3,I) = Z*(HCA*TSB(1,1) + HSA*TSB(1,2))
      F(4,I) = Z*(HCA*TSB(2,1) + HSA*TSB(2,2))
      IF (.NOT.VCHAN) RETURN
      F(8,I) = Z*(HCA*TSB(3,1) + HSA*TSB(3,2))
      RETURN
   64 F(3,I) = Z*(HCA*TSB(1,1) - HSA*TSB(1,2))
      F(4,I) = Z*(HCA*TSB(2,1) - HSA*TSB(2,2))
      IF (.NOT.VCHAN) RETURN
      F(8,I) = Z*(HCA*TSB(3,1) - HSA*TSB(3,2))
      RETURN
   65 F(3,I) = Z*(HCA*TSB(1,2) + HSA*TSB(1,3))
      F(4,I) = Z*(HCA*TSB(2,2) + HSA*TSB(2,3))
      IF (.NOT.VCHAN) RETURN
      F(8,I) = Z*(HCA*TSB(3,2) + HSA*TSB(3,3))
      RETURN
   66 F(3,I) = Z*(HCA*TSB(1,2) - HSA*TSB(1,3))
      F(4,I) = Z*(HCA*TSB(2,2) - HSA*TSB(2,3))
      IF (.NOT.VCHAN) RETURN
      F(8,I) = Z*(HCA*TSB(3,2) - HSA*TSB(3,3))
  100 RETURN
      END
      SUBROUTINE FMATX
      COMMON /FGMAT/ F(25,25),G(25,25),T(25,25),ARESET(25,25)
      COMMON /DIMENS/ NF,NS,NSF,NDYN,NCTRL,NRA, NG,LINK(50)
      COMMON /STATE/ IST(50,5),ST(50,4),LOGIC(50,25),LABEL(50)
      LOGICAL LOGIC
      COMMON /STDATA/ ICODE,I,IFRAM,IE,IB,IA,LINKI,LOGIJ,ISP(4)
      COMMON /COUNTR/ J,JDT,JIN,JIDT,JFDT,NERR
C
C     STATE CODE 14 = X GYRO DRIFT
C                15 = Y GYRO DRIFT
C                16 = Z GYRO DRIFT
C                17 = X ACCELEROMETER BIAS
C                18 = Y ACCELEROMETER BIAS
C                19 = Z ACCELEROMETER BIAS
C                21 = X-AXIS REFERENCE VELOCITY ERROR
C                22 = Y-AXIS REFERENCE VELOCITY ERROR
C                23 = DOWN-RANGE REFERENCE VELOCITY ERROR
C                24 = CROSS-RANGE REFERENCE VELOCITY ERROR
C                25 = REFERENCE VELOCITY SCALE FACTOR ERROR
C                26 = REFERENCE VELOCITY BORESIGHT ERROR
C                27 = DOWN-RANGE DOPPLER FLUCTUATION NOISE
C                28 = CROSS-RANGE DOPPLER FLUCTUATION NOISE
C                29 = ALTIMETER ERROR
C
      IX = LINK(1) + 1
      DO 100 I=IX,NSF
      IF (.NOT.LOGIC(I,J)) GO TO 100
      ICODE = IST(I)
      IFRAM = ICODE/1000
      ICODE = ICODE - 1000*IFRAM
      IFRAM = IFRAM + 1
      IF (ICODE.LE.0) GO TO 100
      IF (ICODE.LE.13) GO TO 101
      GO TO (1,2,3,4,100),IFRAM
    1 CALL FMWAND
      GO TO 100
    2 CALL FMBODY
      GO TO 100
    3 CALL FMATSP
      GO TO 100
    4 CALL FMSPEC
      GO TO 100
  101 IF (I.LE.NCTRL.OR.ICODE.GT.10) GO TO 100
      CALL MATMOV(F(1,I),F(1,ICODE),LINK(1),1,25,25)
  100 CONTINUE
      RETURN
      END
C
      SUBROUTINE FMBODY
      COMMON /STDATA/ ICODE,I,IFRAM,IE,IB,IA,LINKI,LOGIJ,ISP(4)
      COMMON /FGMAT/ F(25,25),G(25,25),T(25,25),ARESET(25,25)
      COMMON /LOGICL/ FILTAP,JSTART,VCHAN,LRESET
      LOGICAL FILTAP,JSTART,VCHAN,LRESET
      COMMON /PERT/  W(3),A(3),V(3),P(3),PSI(3),WS(3),WBD(3),TSB(3,3)
      DIMENSION WB(3),AB(3),AT(3)
C
C
      RE = 2.0926E+07 + P(3)
      GR= 32.174*(2.0926E+07/RE)**2 - (V(1)**2+V(2)**2)/RE
      AT(1)=A(1)
      AT(2)=A(2)
      AT(3)=A(3)
      AT(3)=A(3) + GR
    1 DO 2 K=1,3
      WB(K)=WS(K)
      AB(K)=0.0
      DO 2 L=1,3
      WB(K) = WB(K) + TSB(L,K)*W(L)
      AB(K) = AB(K) + TSB(L,K)*AT(L)
    2 CONTINUE
      IF ((ICODE-14)'(ICODE-19)) 101,101,102
  101 ICODE = 100*(ICODE-13)
  102 IE = ICODE/100
      IA = (ICODE-100*IE)/10 + 1
      IB = MOD(ICODE,10) + 1
      IF (IE.LE.0.OR.IE.GE.7) RETURN
      Z = 1.0
      GO TO (20,11,12,13,14,15,16,100),IA
   11 Z = WB(1)
      GO TO 20
   12 Z = WB(2)
      GO TO 20
   13 Z = WB(3)
      GO TO 20
   14 Z = AB(1)
      GO TO 20
   15 Z = AB(2)
      GO TO 20
   16 Z = AB(3)
   20 GO TO (30,21,22,23,24,25,26,100),IB
   21 Z = Z*WB(1)
      GO TO 30
   22 Z = Z*WB(2)
      GO TO 30
   23 Z = Z*WB(3)
      GO TO 30
   24 Z = Z*AB(1)
      GO TO 30
   25 Z = Z*AB(2)
      GO TO 30
   26 Z = Z*AB(3)
   30 GO TO (31,32,33,34,35,36,100),IE
   31 F(5,I) = Z*TSB(1,1)
      F(6,I) = Z*TSB(2,1)
      F(7,I) = Z*TSB(3,1)
      RETURN
   32 F(5,I) = Z*TSB(1,2)
      F(6,I) = Z*TSB(2,2)
      F(7,I) = Z*TSB(3,2)
      RETURN
   33 F(5,I) = Z*TSB(1,3)
      F(6,I) = Z*TSB(2,3)
      F(7,I) = Z*TSB(3,3)
      RETURN
   34 F(3,I) = Z*TSB(1,1)
      F(4,I) = Z*TSB(2,1)
      IF (.NOT.VCHAN) RETURN
      F(8,I) = Z*TSB(3,1)
      RETURN
   35 F(3,I) = Z*TSB(1,2)
      F(4,I) = Z*TSB(2,2)
      IF (.NOT.VCHAN) RETURN
      F(8,I) = Z*TSB(3,2)
      RETURN
   36 F(3,I) = Z*TSB(1,3)
      F(4,I) = Z*TSB(2,3)
      IF (.NOT.VCHAN) RETURN
      F(8,I) = Z*TSB(3,3)
  100 RETURN
      END
C
      SUBROUTINE FMWAND
      COMMON /CLOOP/ GL1,GL2,GL3,GL4,GK1,GK2,GK3
      COMMON /STDATA/ ICODE,I,IFRAM,IE,IB,IA,LINKI,LOGIJ,ISP(4)
      COMMON /FGMAT/ F(25,25),G(25,25),T(25,25),ARESET(25,25)
      COMMON /LOGICL/ FILTAP,JSTART,VCHAN,LRESET
      LOGICAL FILTAP,JSTART,VCHAN,LRESET
      COMMON /PERT/  W(3),A(3),V(3),P(3),PSI(3),WB(3),WBD(3),TSB(3,3)
      COMMON /SGMODL/ JPATH,JMECH,JMODL,JDIFF,JFRAM,JVDAMP,JCLOOP,JGENX
      COMMON /SEGMNT/ JSEG(25,25),SEG(25,20),SEGLAB(25,6)
      COMMON /COUNTR/ J,JDT,JIN,JIDT,JFDT,NERR
C
C
      K = ICODE - 13
      IF (K.GT.7) GO TO 20
      X = 1.
  111 GO TO (1,2,3,4,5,6,100),K
    1 F(5,I) = X
      GO TO 100
    2 F(6,I) = X
      GO TO 100
    3 F(7,I) = X
      GO TO 100
    4 F(3,I) = X
      GO TO 100
    5 F(4,I) = X
      GO TO 100
    6 IF (.NOT.VCHAN) GO TO 7
      F(8,I) = X
      GO TO 100
    7 F(3,I) = -2.0*W(2)*X
      F(4,I) = 2.0*W(1)*X
      GO TO 100
   20 K = K - 7
      IF (K.GE.9)     GO TO 29
   21 IF (JMODL.LE.0) GO TO 100
      KX = 8
      IF (VCHAN) KX = 10
      GO TO (121,22,23,24,25,26,27,28),K
  121 F(KX,I) = 1.
      GO TO 100
   22 F(KX+1,I) = 1.
      GO TO 100
   23 F(KX,I) = -COS(PSI(3))
      F(KX+1,I) = SIN(PSI(3))
      GO TO 100
   24 F(KX,I) = -SIN(PSI(3))
      F(KX+1,I) = -COS(PSI(3))
      GO TO 100
   25 F(KX,I) = -V(2)
      F(KX+1,I) = V(1)
      GO TO 100
   26 F(KX,I) = -V(1)
      F(KX+1,I) = -V(2)
      GO TO 100
   27 VL = SQRT(V(1)**2+V(2)**2)
      VL = SQRT(VL)
      F(KX,I) = -V(2)/VL
      F(KX+1,I) = V(1)/VL
      GO TO 100
   28 VL = SQRT(V(1)**2+V(2)**2)
      VL = SQRT(VL)
      F(KX,I) = -V(1)/VL
      F(KX+1,I) = -V(2)/VL
      GO TO 100
   29 IF (K.GT.10)     GO TO 130
C
COMMENT     ICODE = 29     ALTIMETER BIAS ERROR
C                 = 30     ALTIMETER SCALE FACTOR ERROR
C
      IF (.NOT.VCHAN)     RETURN
      IF (JVDAMP.EQ.0)     RETURN
      SF = 1.
      IF (K.EQ.10)     SF = AMAX1(P(3),5000.)
      CON = SEG(J,15)
      RE = 2.0926E+07 + P(3)
      GR= 32.174*(2.0926E+07/RE)**2 - (V(1)**2 + V(2)**2)/RE
      F(8,I)=-(2.*GR/RE +1./CON**2)*SF
      F(9,I)=-(2./CON)*SF
      GO TO 100
  130 K = K-10
      IF (K.GT.9)     GO TO 31
C
COMMENT     CLOSED LOOP MECHANIZATION
C        ICODE = 31,  X(N) CHANNEL  LORAN  POSITION  ERROR
C                32,  Y(W) CHANNEL  LORAN  POSITION  ERROR
C                36,  X(N) CHANNEL  VELOCITY  REFERENCE  ERROR
C                37,  Y(W) CHANNEL  VELOCITY  REFERENCE  ERROR
C
      GO TO (51,52,100,100,100,56,57,100,100), K
COMMENT     CLOSED LOOP LORAN ERRORS
   51 F(1,I) =-GL1
      F(3,I) =-GL2
      F(6,I) = GL3
      F(7,I) = GL4
      GO TO 100
   52 F(2,I) =-GL1
      F(4,I) =-GL2
      F(5,I) =-GL3
      GO TO 100
COMMENT     CLOSED LOOP GROUND GYROCOMPASSING REFERENCE VELOCITY ERRORS
   56 F(3,I) =-GK1
      F(6,I) = GK2
      F(7,I) = GK3
      GO TO 100
   57 F(4,I) =-GK1
      F(5,I) =-GK2
      GO TO 100
C
   31 IF (K.LE.69) GO TO 100
      IE = ICODE/100
      IA = (ICODE-100*IE)/10 + 1
      IB = MOD(ICODE,10) + 1
      K = IE
      X = 1.
      GO TO (40,32,33,34,35,36,37,38,100),IA
   32 X = W(1)
      GO TO 40
   33 X = W(2)
      GO TO 40
   34 X = W(3)
      GO TO 40
   35 X = A(1)
      GO TO 40
   36 X = A(2)
      GO TO 40
   37 RE = 2.0926E+07 + P(3)
      GR= 32.174*(2.0926E+07/RE)**2 - (V(1)**2 + V(2)**2)/RE
      X = A(3) + GR
      GO TO 40
   38 X = A(3)
   40 GO TO (111,42,43,44,45,46,47,48,100),IB
   42 X = X*W(1)
      GO TO 111
   43 X = X*W(2)
      GO TO 111
   44 X = X*W(3)
      GO TO 111
   45 X = X*A(1)
      GO TO 111
   46 X = X*A(2)
      GO TO 111
   47 RE = 2.0926E+07 + P(3)
      GR= 32.174*(2.0926E+07/RE)**2 - (V(1)**2 + V(2)**2)/RE
      X = X*(A(3) + GR)
      GO TO 111
   48 X = X*A(3)
      GO TO 111
  100 RETURN
      END
C
      SUBROUTINE GCPATH
      COMMON /COUNTR/ J,JDT,JIN,JIDT,JFDT,NERR
      COMMON /TIMER/ TIME,TIMES,TIMEF,DT,DTINTG,TBASE
      COMMON /SEGMNT/ JSEG(25,25),SEG(25,20),SEGLAB(25,6)
      COMMON /ENDPTS/ VI(3),VF(3),VFP(3),WI(3),WF(3),PI(3),PF(3),PSII(3)
     1,PSIF(3),PSIP(3)
      COMMON /DYNAM/ W(3),A(3),V(3),P(3),PSI(3),WB(3),WBD(3),TSB(3,3)
      COMMON /SGMODL/ JPATH,JMECH,JMODL,JDIFF,JFRAM,JVDAMP,JCLOOP,JGENX
      COMMON /SGDATA/ LISTH,LISTV,JRESTR,JDUM1,JDUM2
      COMMON /SGDTS/ JDTS,J1ST,JPDT,J1SAV,JSAVDT,JINT,JRXGEN
      DATA RAD/57.2958/
C
C     CIRCULAR
C     GREAT CIRCLE PATH,LOCATES END POINTS AND COMPUTES CONSTANTS TO
C     BE USED IN PIECEWISE CONSTANT DIFFERENTIAL EQUATIONS
C     PATH CODE = 0, INTIAL HEADING SPECIFIED
C               = 1, INITIAL HEADING SPEFIFIED
C               = 2, END POINTS SPECIFIED.  VELOCITY ADJUSTED
C               = 3, END POINTS SPECIFIED . DT ADJUSTED.
C
      IF (JPATH-1)  30,20,40
   20 PSII(1) = PSIP(1) + SEG(J,3)/RAD
      GO TO 11
   30 PSII(1) = SEG(J,3)/RAD
   11 TIMEF = TIMES + DT*JDTS
      IF (LISTH.NE.0) GO TO 31
      RANGE = SEG(J)*DT*JDTS
      VI(1) = VF(1) = SEG(J)
      GO TO 100
   31 CALL ITABLE(RANGE,TIMEF,TIMES,LISTH)
      CALL TABLE(VI,TIMES,LISTH,1.)
      CALL TABLE(VF,TIMEF,LISTH,1.)
      GO TO 100
   40 PF(1) = SEG(J,3)/RAD
      PF(2) = SEG(J,4)/RAD
      CALL DIST(RANGE,PSII,PSIF,PI,PF)
      PSII(2) = PSIP(2)
      PSII(3) = PSIF(3) = PSII(1) - PSII(2)
      PSIF(2) = PSIF(1) - PSIF(3)
      TIMEF = TIMES + DT*JDTS
      IF (LISTH.NE.0) GO TO 61
      VI(1) = VF(1) =RANGE/(DT*JDTS)
      GO TO 101
   61 CALL ITABLE(RA,TIMEF,TIMES,LISTH)
      CALL XTABLE(LISTH,RANGE/RA)
      CALL TABLE(VI,TIMES,LISTH,1.)
      CALL TABLE(VF,TIMEF,LISTH,1.)
      GO TO 101
  100 PSII(2) = PSIP(2)
      PSII(3) = PSII(1) - PSII(2)
      PSIF(3) = PSII(3)
      CALL LOCATE(PF,PSIF,PI,PSII,RANGE)
  101 C = COS(PSII(3))
      S = SIN(PSII(3))
      VI(2) = VI(1)*S
      VI(1) = VI(1)*C
      VF(2) = VF(1)*S
      VF(1) = VF(1)*C
      PSIF(2) = PSIF(1) - PSIF(3)
      CALL OMEGA(WI,PI,VI,PSII)
      CALL OMEGA(WF,PF,VF,PSIF)
      TIME = TIMES
 1000 JX = JDIFF + 1
      GO TO (1100,1100,1300,1300,1300),JX
 1100 TIMEY= TIMES + SEG(J,5)
      DX = DT
      GO TO 90
C
      ENTRY PATHGC
C
      DX = DTINTG
      TIMEY = TIME
   90 IF (LISTH.NE.0) GO TO 111
      RANGE = SEG(J)*(TIMEY-TIMES)
      V(1) = VI(1)
      V(2) = VI(2)
      A(1) =A(2) = 0.
      GO TO 112
  111 CALL ITABLE(RANGE,TIMEY,TIMES,LISTH)
      CALL TABLE (V,TIMEY,LISTH,1.)
      V(2) = V(1)*S
      V(1) = V(1)*C
      CALL TABLE(VRANGE,TIMEY-DX,LISTH,1.)
      A(1) = (V(1)-VRANGE*C)/DX
      A(2) = (V(2)-VRANGE*S)/DX
  112 CALL LOCATE(P,PSI,PI,PSII,RANGE)
      PSI(3) = PSII(3)
      PSI(2) = PSI(1) - PSI(3)
  115 CALL OMEGA(W,P,V,PSI)
      RETURN
C
      ENTRY RESTGC
C
 1300 TIME = TIMES
      DO 301 L=1,3
      W(L) = WI(L)
      PSI(L) = PSII(L)
  301 CONTINUE
      DO 302 L=1,2
      P(L) = PI(L)
      V(L) = VI(L)
      A(L) = 0.
  302 CONTINUE
      IF (LISTH.EQ.0) RETURN
      CALL TABLE(VR,TIME+DT,LISTH,1.)
      A(1) = (VR*C - V(1))/DT
      A(2) = (VR*S - V(2))/DT
      RETURN
      END
C
      SUBROUTINE GMATIN
      COMMON /PASS/ FILT,VECTOR,BKDOWN,RSS
      LOGICAL FILT,VECTOR,BKDOWN,RSS
      COMMON /FGMAT/ F(25,25),G(25,25),T(25,25),A(25,25)
      COMMON /DIMENS/ NF,NS,NSF,NDYN,NCTRL,NRA, NG,LINK(50)
      COMMON /STATE/ IST(50,5),ST(50,4),LOGIC(50,25),LABEL(50)
      LOGICAL LOGIC
      COMMON /QRMAT/ Q(25,25),R(25,25),S(25,25,6)
      COMMON /NOISE/ SM(25)
      DIMENSION B(25)
C
C     SET UP INPUT MATRIX
C
      CALL ZERO(R,NDYN,NDYN,25)
      IF (BKDOWN) GO TO 10
      N1 = 1
      N2 = NSF
      GO TO 20
   10 N1 = NCTRL + 1
      N2 = N1
   20 NX = 0
      IF (NS.EQ.0) RETURN
      DO 1 I=N1,N2
      IF (IST(I,2).NE.3) GO TO 1
      NX = NX + 1
      B(NX) = SM(I)
      SM(I) = 0.0
    1 CONTINUE
C
      ENTRY GMAT
C
      IF (NX.LE.0) GO TO 3
      NXX = NDYN + 1
      CALL ADAT(R,B,F(1,NXX),NDYN,NX,25,25)
      DO 2 I=1,NDYN
      R(I,I) = R(I,I) + SM(I)
    2 CONTINUE
      RETURN
C
    3 DO 4 I=1,NDYN
      R(I,I) = SM(I)
    4 CONTINUE
      RETURN
      END
C
      SUBROUTINE ITABLE(X,T,TI,L)
      COMMON /LIST/ XL(50,15),LC(15)
C
C     COMPUTE INTEGRATED DATA LIST FROM A SPECINIED STARTING TIME TO A
C     SPECIFIED FINAL TIME. SEE SUBROUTINE TABLE FOR LC DEFINITIONS.
C
      X = 0.
      I = LC(L)
      IF (I.GE.6.OR.I.LE.0) CALL ERROR1(8)
      IF (T.LT.TI) CALL ERROR1(9)
      IF (I.GE.4) GO TO 400
      TB = XL(1,L)
      DT = XL(2,L)
      IF (T.GE.TB.AND.TI.LE.(TB+47.'DT)) GO TO 100
      RETURN
  100 NI = (TI-TB)/DT + 3.
      NF = (T -TB)/DT + 3.
      IF (NF.GT.49) NF = 49
      IF (NI.LT.3) NI = 3
      IF (I-2) 1,2,3
    1 X = XL(NI,L)*(TB+(NI-3)*DT-TI) + XL(NF,L)*(T-TB-(NF-2)*DT)
      DO 102 J=NI,NF
      X = X + XL(J,L)*DT
  102 CONTINUE
      RETURN
    2 CALL TABLE(XA,TI,L,1.)
      CALL TABLE(XB,T ,L,1.)
      X = 0.5*((XA+XL(NI,L))*(TB+(NI-3)*DT-TI) + (XB+XL(NF+1,L))*(T-TB-(
     1NF-2)'DT))
      DO 202 J=NI,NF
      X = X + 0.5*(XL(J,L)+XL(J+1,L))*DT
  202 CONTINUE
      RETURN
    3 NI = 2*((NI+1)/2)
      NF = 2*((NF+1)/2)
      CALL TABLE(XA,TI,L,1.)
      CALL TABLE(XB,T ,L,1.)
      TA = TI - TB - (NI-3)*DT
      TC = T  - TB - (NF-3)*DT
      C = XL(NI,L)
      B = (XL(NI+1,L) - XL(NI-1,L))/(2.*DT)
      A = (XL(NI+1,L) - 2.*C + XL(NI-1,L))/(2.*DT**2)
      F = XL(NF,L)
      E = (XL(NF+1,L) - XL(NF-1,L))/(2.*DT)
      D = (XL(NF+1,L) - 2.*F + XL(NF-1,L))/(2.*DT**2)
      X = (-(A+D)*DT**3 + D*TC**3 - A*TA**3)/3. + ((B-E)*DT**2 + E*TC**2
     1 - B'TA''2)/2. + (-(C+F)'DT - C'TA + F'TC)
      DO 302 J=NI,NF,2
      X = X + (XL(J-1,L) + 4.*XL(J,L) + XL(J+1,L))*DT/3.
  302 CONTINUE
      RETURN
  400 JA = 0
      DO 402 J=1,49,2
      IF (JA.EQ.0.AND.XL(J,L).GT.TI) JA=J
      IF (XL(J,L).GT.T) GO TO 403
  402 CONTINUE
  403 IF (J.EQ.1.OR.JA.EQ.0) RETURN
      IF (I.GE.5) GO TO 5
      DO 404 K=JA,J,2
      TA = XL(K-2,L)
      IF (K.EQ.JA) TA = TI
      TB = XL(K,L)
      IF (K.EQ.J) TB = T
      X = X + (TB-TA)*XL(K-1,L)
  404 CONTINUE
      RETURN
    5 DO 504 K=JA,J,2
      TA = XL(K-2,L)
      XA = XL(K-1,L)
      IF (K.NE.JA) GO TO 501
      TA = TI
      CALL TABLE(XA,TI,L,1.)
  501 TB = XL(K,L)
      XB = XL(K+1,L)
       IF (K.NE.J) GO TO 502
      TB = T
      CALL TABLE(XB,T,L,1.)
  502 X = X + (XA+XB)*(TB-TA)/2.
  504 CONTINUE
      RETURN
      END
C
      SUBROUTINE LIMITQ
      COMMON /QRMAT/ Q(25,25),R(25,25),S(25,25,6)
      COMMON /DIMENS/ NF,NS,NSF,NDYN,NCTRL,NRA, NG,LINK(50)
C
C     LIMIT CORRELATION COEFFICIENT, RANGE(-1,+1)
C
      DO 1 I=1,NDYN
      IF (Q(I,I).GE.0.) GO TO 3
      NX = NX + 1
      DO 2 J=1,NDYN
      Q(I,J) = 0.
      Q(J,I) = 0.
    2 CONTINUE
    3 IX = I - 1
      IF (I.EQ.1) GO TO 1
      DO 4 J=1,IX
      X = Q(I,I)*Q(J,J)
      IF (Q(I,J)''2 - X) 4,4,5
    5 X = SQRT(X)
      X = SIGN(X,Q(I,J))*0.99999999
      NX = NX + 1
      Q(I,J) = X
      Q(J,I) = X
    4 CONTINUE
    1 CONTINUE
      IF (NX.EQ.NXP) RETURN
      NXP = NX
      PRINT 10,NX
   10 FORMAT (1H+,99X,'COV. UNSTABLE'I5)
      RETURN
C
      ENTRY QCOUNT
C
      NXP = 0
      NX = 0
      RETURN
      END
C
      SUBROUTINE LOCATE(P,PSI,PI,PSII,RANGE)
      DIMENSION P(3),PSI(3),PI(3),PSII(3)
      DATA RE/2.0926E+07/
C
C     SOLVES GREAT CIRCLE GEOMETRY GIVEN INITIAL POSITION AND HEADING
C     AND TOTAL DISTANCE TRAVELED.
C     P    = COMPUTED POSITION (LAT-LONG)
C     PSI  = COMPUTED HEADING.
C     PI   = INITIAL POSITION (LAT-LONG)
C     PSII = INITIAL HEADING.
C     RANGE= SPECIFIED DISTANCE ALONG GREAT CIRCLE PATH
C
      IF (RANGE.NE.0) GO TO 1
      P(1) = PI(1)
      P(2) = PI(2)
      PSI(1) = PSII(1)
      RETURN
    1 CLAI = COS(PI(1))
      IF (CLAI.NE.0) GO TO 2
      P(2) = PI(2)
      PSI(1) = SIGN(1.570796327,PI(1)) + 1.570796327
      P(1) = SIGN(1.570796327 - RANGE/RE,PI(1))
      RETURN
    2 SLAI = SIN(PI(1))
      CROE = COS(RANGE/RE)
      SROE = SIN(RANGE/RE)
      SLAF = CROE*SLAI + SROE*CLAI*COS(PSII(1))
      P(1) = ASIN(SLAF)
      CLAF = COS(P(1))
      IF(CLAF.NE.0.) GO TO 3
      P(2) = PI(2) + 3.141592654
      PSI(1) = SIGN(1.570796327,P(1)) + 1.570796327
      RETURN
    3 SPSI = SIN(PSII(1))
      PSI(1) = ATAN2(CLAI*SPSI,(CROE*SLAF-SLAI)/SROE)
      P(2) = PI(2) - ATAN2(SROE*SPSI,(CROE-SLAF*SLAI)/CLAI)
      RETURN
      END
C
      SUBROUTINE LORAN
      COMMON /OBSERV/ KOBS(20,12),OBS(20,6),OBLABL(2,20)
      COMMON /OBDATA/ NOBS,KOB,KCODE,NOBZ
      COMMON /LABEL/ XLABEL(6),SLABEL(6),SGLABL(6),OL(2,10)
      COMMON /OBMAT/ OBMAT(10,50),OBNV(10,10),COEF(50,10),OBNS(10,10),OB
     1SIG(10),X(40)
      COMMON /PERT/  W(3),A(3),V(3),P(3),PSI(3),WB(3),WBD(3),TSB(3,3)
      DIMENSION PIY(3),PSIX(3),PSIY(3),SIGS(4)
      DATA RAD/57.2958/
C
C        KCODE = 71  TIME DIFFERENCE LORAN MEASUREMENT
C        KCODE = 72  TIME DIFFERENCE LORAN MEASUREMENTS ON A 3-STATION NET
C        KCODE = 73  TIME DIFFERENCE LORAN MEASUREMENTS ON A 4-STATION NET
C
      SF = OBS(KOB,2)
      IF (KCODE.GT.3) GO TO 10
      PIY(1)= OBS(KOB,5)/RAD
      PIY(2) = OBS(KOB,6)/RAD
      CALL DIST(RANGE,PSIX,PSIY,P,PIY)
      CALL LORSIG(SIGS(4),RANGE,SF)
      SM= SIN(PSIX(1)-PSI(2))
      CM = COS(PSIX(1)-PSI(2))
      DO 1 I=1,KCODE
      KX = KOB + I - 1
      PIY(1) = OBS(KX,3)/RAD
      PIY(2) = OBS(KX,4)/RAD
      CALL DIST(RANGE,PSIX,PSIY,P,PIY)
      CALL LORSIG(SIGS(I),RANGE,SF)
      S = SIN(PSIX(1)-PSI(2))
      C = COS(PSIX(1)-PSI(2))
      NOBS = NOBS + 1
      OL(1,NOBS) = OBLABL(1,KX)
      OL(2,NOBS) = OBLABL(2,KX)
      OBMAT(NOBS,1) = CM-C
      OBMAT(NOBS,2) = SM-S
    1 CONTINUE
      KI = NOBS - KCODE + 1
      DO 2 I=KI,NOBS
      DO 2 L=KI,NOBS
      OBNV(I,L) = SIGS(4)
      IF (I.EQ.L) OBNV(I,L) = SIGS(4) + SIGS(I)
    2 CONTINUE
      RETURN
C
C        KCODE = 74  DIRECT DISTANCE LORAN MEASUREMENTS
C
   10 PIY(1) = OBS(KOB,3)/RAD
      PIY(2) = OBS(KOB,4)/RAD
      CALL DIST(RANGE,PSIX,PSIY,P,PIY)
      NOBS = NOBS + 1
      OL(1,NOBS) = OBLABL(1,KOB)
      OL(2,NOBS) = OBLABL(2,KOB)
      OBMAT(NOBS,1) = COS(PSIX(1)-PSI(2))
      OBMAT(NOBS,2) = SIN(PSIX(1)-PSI(2))
      IX = KOBS(KOB,5)
      IF (IX.LE.0) GO TO 11
      OBMAT(NOBS,IX) = 1.0
   11 CALL LORSIG(OBSIG(NOBS),RANGE,SF)
      RETURN
      END
      SUBROUTINE LORSIG(SIG,RANGE,SF)
C
C        COMPUTE LORAN ACCURACY VERSUS RANGE
C
      IF (RANGE.GT.2.64E+06) GO TO 1
      SIG = RANGE*1.32E-05
      GO TO 10
C
    1 IF (RANGE.GT.4.56E+06) GO TO 2
      SIG = 3.4E-05*RANGE - 54.0
      GO TO 10
C
    2 SIG = 6.78E-05*RANGE - 209.0
C
   10 SIG = (SIG*SF)**2 + (35.*SF)**2
      END
      SUBROUTINE MATADD(A,B,C,NR,NC,NAR,NBR,NCR)
      DIMENSION A(NAR,1),B(NBR,1),C(NCR,1)
      DO 1 I=1,NR
      DO 1 J=1,NC
      A(I,J) = B(I,J) + C(I,J)
    1 CONTINUE
      RETURN
      END
C
      SUBROUTINE MATAD1(A,B,SC,C,NR,NC,NAR,NBR,NCR)
      DIMENSION A(NAR,1),B(NBR,1),C(NCR,1)
C
C     COMPUTE A = B + SC*C WHERE  A,B,C ARE SYMMETRIC
C
      DO 10 I=1,NR
      DO 10 J=I,NC
      A(I,J) = A(J,I) = B(I,J) + SC*C(I,J)
   10 CONTINUE
      RETURN
      END
C
      SUBROUTINE MATAD2(A,B,SC,C,NR,NC,NAR,NBR,NCR)
      DIMENSION A(NAR,1),B(NBR,1),C(NCR,1)
      DO 10 I=1,NR
      DO 10 J=1,NC
      A(I,J) = B(I,J) + SC*C(I,J)
   10 CONTINUE
      RETURN
      END
      SUBROUTINE MATALG(A,X,NR,NV,IDO,DET,NACT)
      DIMENSION A(NACT,NACT),X(NACT,NACT)
C
      IF (NR-1) 100,21,20
   20 IF (IDO) 1,2,1
    1 DO 3 I=1,NR
      DO 4 J=1,NR
      X(I,J)=0.0
    4 CONTINUE
      X(I,I)=1.0
    3 CONTINUE
      NV=NR
    2 DET=1.0
      NR1=NR-1
      DO 5 K=1,NR1
      IR1=K+1
      PIVOT=0.0
      DO 6 I=K,NR
      Z=ABS( A(I,K))
      IF(Z-PIVOT) 6,6,7
    7 PIVOT=Z
      IPR=I
    6 CONTINUE
      IF(PIVOT) 8,9,8
    9 DET=0.0
      RETURN
    8 IF(IPR-K) 10,11,10
   10 DO 12 J=K,NR
      Z=A(IPR,J)
      A(IPR,J)=A(K,J)
      A(K,J)=Z
   12 CONTINUE
      DO 13 J=1,NV
      Z=X(IPR,J)
      X(IPR,J)=X(K,J)
      X(K,J)=Z
   13 CONTINUE
      DET=-DET
   11 DET=DET*A(K,K)
      PIVOT=1.0/A(K,K)
      DO 14 J=IR1,NR
      A(K,J)=A(K,J)*PIVOT
      DO 14 I=IR1,NR
      A(I,J)=A(I,J)-A(I,K)*A(K,J)
   14 CONTINUE
      DO 5 J=1,NV
      IF(X(K,J)) 15,5,15
   15 X(K,J)=X(K,J)*PIVOT
      DO 16 I=IR1,NR
      X(I,J)=X(I,J)-A(I,K)*X(K,J)
   16 CONTINUE
    5 CONTINUE
      IF (A(NR,NR).EQ. 0.)     GO TO 100
   17 DET=DET*A(NR,NR)
      PIVOT=1.0/A(NR,NR)
      DO 18 J=1,NV
      X(NR,J)=X(NR,J)*PIVOT
      DO 18 K=1,NR1
      I=NR-K
      SUM=0.0
      DO 19 L=I,NR1
      SUM=SUM+A(I,L+1)*X(L+1,J)
   19 CONTINUE
      X(I,J)=X(I,J)-SUM
   18 CONTINUE
      RETURN
   21 DET = A(1,1)
      IF (IDO) 22,23,22
   22 NV = 1
      X(1,1) = 1.0
   23 DO 24 I=1,NV
      X(1,I) = X(1,I)/DET
   24 CONTINUE
      RETURN
  100 DET = 0.0
      RETURN
      END
      SUBROUTINE MATEQ(LSW,A,B,NR,NC,NAR,NBR)
      DIMENSION A(NAR,1),B(NBR,1)
      TYPE INTEGER A,B
      TYPE LOGICAL LSW
C     IF LSW IS .TRUE. MATRIX A EQUALS MATRIX B
      LSW = .TRUE.
      DO 1 I=1,NR
      DO 1 J=1,NC
      IF (A(I,J)-B(I,J)) 2,1,2
    1 CONTINUE
      RETURN
    2 LSW = .FALSE.
      RETURN
      END
      SUBROUTINE MATMAX(X,A,NR,NC,NAR)
      DIMENSION A(NAR,1)
      TYPE INTEGER A,X
C
C     RETURNS MAXIMUM ELEMENT IN MATRIX A
C
      X = A(1,1)
      DO 1 I=1,NR
      DO 1 J=1,NC
      IF (X.LT.A(I,J)) X = A(I,J)
    1 CONTINUE
      RETURN
      END
      SUBROUTINE MATMOV(A,B,NR,NC,NAR,NBR)
      DIMENSION A(NAR,1),B(NBR,1)
      DO 1 I=1,NR
      DO 1 J=1,NC
      A(I,J) = B(I,J)
    1 CONTINUE
      RETURN
      END
C
      SUBROUTINE MATMPY(A,B,C,NR,NRC,NC,NAR,NBR,NCR)
      DIMENSION A(NAR,1),B(NBR,1),C(NCR,1)
C
C     COMPUTES A = B*C
C
      DO 1 I=1,NR
      DO 1 J=1,NC
      X = 0.
      DO 2 K=1,NRC
      X = X + B(I,K)*C(K,J)
    2 CONTINUE
      A(I,J) = X
    1 CONTINUE
      RETURN
      END
C
      SUBROUTINE MATMP1(A,B,C)
      COMMON /DIMENS/ NF,NS,NSF,NDYN,NCTRL,NRA, NG,LINK(50)
      DIMENSION A(25,50),B(25,50),C(25,50)
C
C     COMPUTES A = B*C WHERE ALL MATRICES ARE IN COMPRESSED FORM
C
      IF (NDYN.LE.NCTRL) GO TO 7
      N = NCTRL + 1
      NDIF = NRA - NCTRL
      CALL ZERO(A(N,1),NDIF,NDYN,25)
      DO 1 I=N,NDYN
      LINKI = LINK(I)
      IF (LINKI.EQ.0) GO TO 1
      M = I - 1
      DO 2 IX=1,NCTRL
      DO 2 IY=1,LINKI
      X = 0.
      DO 3 IZ=1,NCTRL
      X = X + B(IX,IZ)*C(IZ,M+IY)
    3 CONTINUE
      DO 4 IZ=1,LINKI
      X = X + B(IX,M+IZ)*C(NCTRL+IZ,M+IY)
    4 CONTINUE
      A(IX,M+IY) = X
    2 CONTINUE
      DO 5 IX=1,LINKI
      DO 5 IY=1,LINKI
      X = 0.
      DO 6 IZ=1,LINKI
      X = X + B(NCTRL+IX,M+IZ)*C(NCTRL+IZ,M+IY)
    6 CONTINUE
      A(NCTRL+IX,M+IY) = X
    5 CONTINUE
    1 CONTINUE
    7 CALL MATMPY (A,B,C,NCTRL,NCTRL,NCTRL,25,25,25)
      RETURN
      END
C
      SUBROUTINE MATMP2(A,F,Q,ND,NDYN,NAR,NRF,NRQ)
      DIMENSION A(NAR,1),F(NRF,1),Q(NRQ,1)
      COMMON  /DIMENS/  NF, NS, NSF, NDY , NCTRL, NRA, NG, LINK(50)
C
C     COMPUTE A=F*Q WHERE F IS PARTIONED
C
      DO 1 J=1,NDYN
      DO 1 I=1,NDYN
      X = 0.0
      IF (I.GT.ND) GO TO 2
      DO 3 K=1,NDYN
      X = X + F(I,K)*Q(K,J)
    3 CONTINUE
      GO TO 4
    2 LX = LINK(I)
      IF (LX.EQ.0) GO TO 5
      IX = I
      IXX = I + LX - 1
    5 DO 6 K=IX,IXX
      X = X + F(I,K)*Q(K,J)
    6 CONTINUE
    4 A(I,J) = X
    1 CONTINUE
      RETURN
      END
      SUBROUTINE MATSER(TRAN,F,T,N,M,NTRAN,NF,NT)
      DIMENSION TRAN(NTRAN,1),F(NF,1),T(NT,1)
C
C     COMPUTES FIRST 'N' TERMS OF MATRIX EXPONENTIAL SERIES
C
      DO 1 I=1,M
      DO 2 J=1,M
      TRAN(I,J) = 0.
    2 CONTINUE
      TRAN(I,I) = 1.
    1 CONTINUE
      DO 10 I=1,N
      SF = 1./(N+1-I)
      CALL MATMPY(T,TRAN,F,M,M,M,NT,NTRAN,NF)
      DO 10 J=1,M
      DO 20 K=1,M
      TRAN(J,K) = SF*T(J,K)
   20 CONTINUE
      TRAN(J,J) = TRAN(J,J) + 1.
   10 CONTINUE
      RETURN
      END
C
      SUBROUTINE MATSM2(A,N,M,NR)
      DIMENSION A(NR,1)
      DO 1 I=1,N
      DO 1 J=I,N
      A(I,J) = A(J,I) = A(I,J) + A(J,I)
    1 CONTINUE
      RETURN
      END
C
      SUBROUTINE MATSYM(A,N,M,NAR)
      DIMENSION A(NAR,1)
      DO 1 I=1,N
      DO 1 J=I,N
      X = 0.5*(A(I,J) + A(J,I))
      A(I,J) = X
      A(J,I) = X
    1 CONTINUE
      RETURN
      END
      SUBROUTINE MATTRN(A,B,NR,NC,NAR,NBR)
      DIMENSION A(NAR,1),B(NBR,1)
      DO 1 I=1,NR
      DO 1 K=1,NC
      A(I,K) = B(K,I)
    1 CONTINUE
      RETURN
      END
C
      SUBROUTINE MASTER
      COMMON /OBSERV/ KOBS(20,12),OBS(20,6),OBLABL(2,20)
      COMMON /OBDATA/ NOBS,KOB,KCODE,NOBZ
      COMMON /LABEL/ XLABEL(6),SLABEL(6),SGLABL(6),OL(2,10)
      COMMON /COUNTR/ J,JDT,JIN,JIDT,JFDT,NERR
      COMMON /OBRLZ/ THA,THI(3),THB,TH(3),OBRLZ
      COMMON /TIMER/ TIME,TIMES,TIMEF,DT,DTINTG,TBASE
      COMMON /OBMAT/ OBMAT(10,50),OBNV(10,10),COEF(50,10),OBNS(10,10),OB
     1SIG(10),X(40)
C
C     COMPUTE OBSERVABLE FOR ALIGNING TO A MASTER REFERENCE
C
      SIG = (OBS(KOB)*OBS(KOB,2))**2
      SIGA = (OBS(KOB,3)*OBS(KOB,4))**2
      CH = COS(THB+TH(3))
      SH = SIN(THB+TH(3))
      CP = COS(TH(2))
      SP = SIN(TH(2))
      CR = COS(TH(1))
      SR = SIN(TH(1))
      IX = KOBS(KOB,5)
      IY = KOBS(KOB,6)
      IZ = KOBS(KOB,7)
      IR = KOBS(KOB,8)
      IL = KOBS(KOB,9)
      IV = KOBS(KOB,10)
      IF (KCODE.GT.1) GO TO 100
      CHO = COS(THA+THI(3))
      SHO = SIN(THA+THI(3))
      CPO = COS(THI(2))
      SPO = SIN(THI(2))
      CRO = COS(THI(1))
      SRO = SIN(THI(1))
      IF (IX) 60,40,31
   31 NOBS = NOBS + 1
      OBMAT(NOBS,IX) = 1.
      OBSIG(NOBS) = SIG
      OL(1,NOBS) = OBLABL(1,KOB)
      OL(2,NOBS) = OBLABL(2,KOB)
      IF (IR) 60,33,32
   32 OBMAT(NOBS,IR) = -CH*CP + CHO*CPO
   33 IF (IL) 60,35,34
   34 OBMAT(NOBS,IL) = -CH*SP*SR + SH*CR + CHO*SPO*SRO - SHO*CRO
   35 IF (IV) 60,40,36
   36 OBMAT(NOBS,IV) = -CH*SP*CR - SH*SR + CHO*SPO*CRO + SHO*SRO
   40 IF (IY) 60,50,41
   41 NOBS = NOBS + 1
      OBMAT(NOBS,IY) = 1.
      OBSIG(NOBS) = SIG
      OL(1,NOBS) = OBLABL(1,KOB)
      OL(2,NOBS) = OBLABL(2,KOB)
      IF (IR) 60,43,42
   42 OBMAT(NOBS,IR) = -SH*CP + SHO*CPO
   43 IF (IL) 60,45,44
   44 OBMAT(NOBS,IL) = -SH*SP*SR - CH*CR + SHO*SPO*SRO + CHO*CRO
   45 IF(IV) 60,50,46
   46 OBMAT(NOBS,IV) = -SH*SP*CR + CH*SR + SHO*SPO*CRO - CHO*SRO
   50 IF (IZ) 60,60,51
   51 NOBS=NOBS+1
      OBMAT(NOBS,IZ) = 1.
      OBSIG(NOBS) = SIGA
      OL(1,NOBS) = OBLABL(1,KOB)
      OL(2,NOBS) = OBLABL(2,KOB)
      IF (IR) 60,53,52
   52 OBMAT(NOBS,IR) =  SP - SPO
   53 IF (IL) 60,55,54
   54 OBMAT(NOBS,IL) = -CP*SR + CPO*SRO
   55 IF (IV) 60,60,56
   56 OBMAT(NOBS,IV) = -CP*CR + CPO*CRO
   60 RETURN
  100 PD = THI(1)
      RD = THI(2)
      IF (JDT.LE.1) THM = THA
      HD = THI(3) + (THB - THM)/((KOBS(KOB,3)+KOBS(KOB,4))*DT )
      THM = THB
      IF (IX) 60,70,61
   61 NOBS = NOBS + 1
      OBMAT(NOBS,IX) = 1.
      OBSIG(NOBS) = SIG
      OL(1,NOBS) = OBLABL(1,KOB)
      OL(2,NOBS) = OBLABL(2,KOB)
      IF (IR) 60,63,62
   62 OBMAT(NOBS,IR) = -SH*CP*HD - CH*SP*PD
   63 IF (IL) 60,65,64
   64 OBMAT(NOBS,IL) = -SH*SP*SR*HD-CH*CR*HD+CH*CP*SR*PD+CH*SP*CR*RD+
     1SH'SR'RD
   65 IF (IV) 60,70,66
   66 OBMAT(NOBS,IV) = -SH*SP*CR*HD+CH*SR*HD+CH*CP*CR*PD-CH*SP*SR*RD+
     1SH'CR'RD
   70 IF (IY) 60,80,71
   71 NOBS = NOBS + 1
      OBMAT(NOBS,IY) = 1.
      OBSIG(NOBS) = SIG
      OL(1,NOBS) = OBLABL(1,KOB)
      OL(2,NOBS) = OBLABL(2,KOB)
      IF (IR) 60,73,72
   72 OBMAT(NOBS,IR) = CH*CP*HD - SH*SP*PD
   73 IF (IL) 60,75,74
   74 OBMAT(NOBS,IL) = CH*SP*SR*HD-SH*CR*HD+SH*CP*SR*PD+SH*SP*CR*RD-
     1CH'SR'RD
   75 IF (IV) 60,80,76
   76 OBMAT(NOBS,IV) = -CH*SP*CR*HD+SH*SR*HD+SH*CP*CR*PD-SH*SP*SR*RD-
     1CH'CR'RD
   80 IF(IZ) 60,60,81
   81 NOBS = NOBS + 1
      OBMAT(NOBS,IZ) = 1.
      OBSIG(NOBS) = SIGA
      OL(1,NOBS) = OBLABL(1,KOB)
      OL(2,NOBS) = OBLABL(2,KOB)
      IF (IR) 60,83,82
   82 OBMAT(NOBS,IR) = -CP*PD
   83 IF (IL) 60,85,84
   84 OBMAT(NOBS,IL) = -SP*SR*PD + CP*CR*RD
   85 IF (IV) 60,60,86
   86 OBMAT(NOBS,IV) = -SP*CR*PD - CP*SR*RD
      RETURN
      END
C
      SUBROUTINE NAVSAT
      COMMON /COUNTR/ J,JDT,JIN,JIDT,JFDT,NERR
      COMMON /OBSERV/ KOBS(20,12),OBS(20,6),OBLABL(2,20)
      COMMON /OBDATA/ NOBS,KOB,KCODE,NOBZ
      COMMON /LABEL/ XLABEL(6),SLABEL(6),SGLABL(6),OL(2,10)
      COMMON /PERT/  W(3),A(3),V(3),P(3),PSI(3),WB(3),WBD(3),TSB(3,3)
      COMMON /OBMAT/ OBMAT(10,50),OBNV(10,10),COEF(50,10),OBNS(10,10),OB
     1SIG(10),X(40)
      DATA (RE=2.0926E+07),(RAD=57.2958),(RSAT=1.3833E+08)
C
C     COMPUTE OBSERVABLE FOR RANGING ON A SATELLITE IN SYNCHRONOUS ORBIT
C
      IC = KCODE
      IF (IC.GE.5) RETURN
      SLAT = SIN(P(1))
      CLAT = COS(P(1))
      SPSI = SIN(PSI(2))
      CPSI = COS(PSI(2))
      NOBS = NOBS - 1
      IX = KOBS(KOB,5)
      IY = KOBS(KOB,6)
      IZ = KOBS(KOB,7)
      IT = KOBS(KOB,8)
      KOA = KOB - 1
      DO 71 I=1,IC
      KOA = KOA + 1
      IF (JDT.LT.KOBS(KOA,2).OR.(MOD(JDT-KOBS(KOA,2),KOBS(KOA,3)+KOBS(KO
     1A,4)).GE.KOBS(KOA,3)))  GO TO 71
      NOBS = NOBS + 1
      IV = KOBS(KOA,9)
      SLONG = SIN(P(2) - OBS(KOA,3)/RAD)
      CLONG = COS(P(2) - OBS(KOA,3)/RAD)
      SLATS = SIN(OBS(KOA,4)/RAD)
      CLATS = COS(OBS(KOA,4)/RAD)
      RN = (RE+P(3))/RSAT
      RNN = SQRT(1. - 2.*( SLAT*SLATS + CLAT*CLONG*CLATS)*RN + RN**2)
      GAMX = (CPSI*CLAT*SLATS - CPSI*SLAT*CLONG*CLATS + SPSI*SLONG*CLATS
     1  )/RNN
      GAMY = (-SPSI*CLAT*SLATS+ SPSI*SLAT*CLONG*CLATS + CPSI*SLONG*CLATS
     1  )/RNN
      GAMZ = (SLAT*SLATS + CLAT*CLONG*CLATS - RN)/RNN
      OBSIG(NOBS) = (OBS(KOA)*OBS(KOA,2))**2
      OL(1,NOBS) = OBLABL(1,KOB)
      OL(2,NOBS) = OBLABL(2,KOB)
      OBMAT(NOBS,IX) = GAMX
      OBMAT(NOBS,IY) = GAMY
      IF (IZ.NE.0) OBMAT(NOBS,IZ) = GAMZ
      IF (IT.NE.0) OBMAT(NOBS,IT) = 9.83E+08
      IF (IV.NE.0) OBMAT(NOBS,IV) = 1.
   71 CONTINUE
      RETURN
      END
C
      SUBROUTINE  NORTH
      COMMON /DYNAM/ W(3),A(3),V(3),P(3),PSI(3),WB(3),WBD(3),TSB(3,3)
      COMMON /SGMODL/ JPATH,JMECH,JMODL,JDIFF,JFRAM,JVDAMP,JCLOOP,JGENX
C
C            THIS SUBROUTINE TRANSFORMS THE INERTIAL RATES, THE ACCELER-
C        ATIONS, AND VELOCITIES ONTO A NORTH POINTING COORDINATE FRAME
C        AND CONVERTS EARTH FIXED ACCELERATIONS INTO INERTIAL ACCELER.
C
      CAL = COS(PSI(2))
      SAL = SIN(PSI(2))
      IF (JMECH.EQ.0) GO TO 1
      OMW = 0.
      OMN = 7.29E-05*COS(P(1))
      OMZ = 7.29E-05*SIN(P(1))
C
C           ROTATE W, A, AND V FROM ALPHA WANDER INTO NORTH POINTING
      T = W(1)*CAL - W(2)*SAL
      W(2) = W(1)*SAL + W(2)*CAL
      W(1) = T
      T = A(1)*CAL - A(2)*SAL
      A(2) = A(1)*SAL + A(2)*CAL
      A(1) = T
      T = V(1)*CAL - V(2)*SAL
      V(2) = V(1)*SAL + V(2)*CAL
      V(1) = T
C
C           SET   ALPHA = 0    AND    ETA = PSI
      PSI(2) = 0.
      PSI(3) = PSI(1)
      CAL = 1.0
      SAL = 0.
C           ADD  RHO Z  TO  INERTIAL  RATES
      W(3) = OMZ  - V(2)*TAN(P(1))/(P(3) +2.0926E+07)
    1 OMW=-OMN*SAL
      OMN = OMN*CAL
C
C           CQNVERT EARTH FIXED ACCELERATION INTO INERTIAL ACCELERATION
C        A(INER)  =  A(EARTH) +  2*OMEGA(EARTH RATE) X VELOCITY
      A(1) = A(1) - 2.*OMZ*V(2) + 2.*OMW*V(3)
      A(2) = A(2) + 2.*(OMZ*V(1) -OMN*V(3))
      A(3) = A(3) + 2.*OMN*V(2) - OMW*V(1)*2.
      RETURN
      END
      SUBROUTINE OBPATH
      COMMON /OBSERV/ KOBS(20,12),OBS(20,6),OBLABL(2,20)
      COMMON /OBDATA/ NOBS,KOB,KCODE,NOBZ
      COMMON /LABEL/ XLABEL(6),SLABEL(6),SGLABL(6),OL(2,10)
      COMMON /TIMER/ TIME,TIMES,TIMEF,DT,DTINTG,TBASE
      COMMON /OBMAT/ OBMAT(10,50),OBNV(10,10),COEF(50,10),OBNS(10,10),OB
     1SIG(10),X(40)
      COMMON /PERT/  W(3),A(3),V(3),P(3),PSI(3),WB(3),WBD(3),TSB(3,3)
      COMMON /QRMAT/ Q(25,25),R(25,25),S(25,25,6)
C
      SIG = (OBS(KOB)*OBS(KOB,2))**2
      SIGA= (OBS(KOB,3)*OBS(KOB,4))**2
      SF = 1.
      IF (KCODE-10) 26,120,20
   26 GO TO (21,22,21,24,24,24,125,225,25),KCODE
   21 NOBS = NOBS + 1
      OBSIG(NOBS) = SIG
      OL(1,NOBS) = OBLABL(1,KOB)
      OL(2,NOBS) = OBLABL(2,KOB)
      IA = KOBS(KOB,5)
      IB = KOBS(KOB,6)
      OBMAT(NOBS,IA) = V(1)*SF
      OBMAT(NOBS,IB) = V(2)*SF
      IF (KCODE.EQ.1) RETURN
      I = 2
      SIG = SIGA
      GO TO 23
   22 I = 0
   23 NOBS = NOBS + 1
      OBSIG(NOBS) = SIG
      OL(1,NOBS) = OBLABL(1,KOB)
      OL(2,NOBS) = OBLABL(2,KOB)
      IA = KOBS(KOB,I+5)
      IB = KOBS(KOB,I+6)
      OBMAT(NOBS,IA) = -V(2)*SF
      OBMAT(NOBS,IB) = V(1)*SF
      RETURN
   24 SF = 1/SQRT(V(1)**2+V(2)**2)
      KCODE = KCODE - 3
      GO TO 26
  125 NOBS = NOBS + 1
      IA = KOBS(KOB,5)
      OBMAT(NOBS,IA) = 1.0
      OBSIG(NOBS) = SIG*(1.+3.2E+09*Q(6,6)+8.0E+06*(Q(10,10)+Q(11,11)))
      OL(1,NOBS) = OBLABL(1,KOB)
      OL(2,NOBS) = OBLABL(2,KOB)
      RETURN
  225 NOBS = NOBS + 1
      IA = KOBS(KOB,5)
      OBMAT(NOBS,IA) = 1.0
      OBSIG(NOBS) = SIG*(1.+3.2E+09*Q(5,5)+8.0E+06*(Q(10,10)+Q(11,11)))
      OL(1,NOBS) = OBLABL(1,KOB)
      OL(2,NOBS) = OBLABL(2,KOB)
   25 RETURN
C
COMMENT    KCODE = 20   ALTIMETER SCALE FACTOR ERROR
  120 NOBS = NOBS + 1
      SF = AMAX1(P(3),5000.)
      OBSIG(NOBS) = SIG*SF**2
      OL(1,NOBS) = OBLABL(1,KOB)
      OL(2,NOBS) = OBLABL(2,KOB)
      IA = KOBS(KOB,5)
      IB = KOBS(KOB,6)
      OBMAT(NOBS,IA) = 1.0
      OBMAT(NOBS,IB) = SF
   20 RETURN
      END
      SUBROUTINE OBSET
      COMMON /OBSERV/ KOBS(20,12),OBS(20,6),OBLABL(2,20)
      COMMON /OBDATA/ NOBS,KOB,KCODE,NOBZ
      COMMON /OBMAT/ OBMAT(10,50),OBNV(10,10),COEF(50,10),OBNS(10,10),OB
     1SIG(10),X(40)
C
C     SET UP FILTER OR SYSTEM MATRICES
C
      IF (KCODE.NE.10) NOBSIN = NOBS + 1
      KCODE2 = KCODE/10 + 1
      KCODE = MOD(KCODE,10)
      GO TO (1,2,3,4,5,6,6,8,6,6),KCODE2
C
    1 IF (KCODE.GT.3) GO TO 11
      CALL OBSTAT
      GO TO 100
   11 IF (KCODE.GT.8) GO TO 21
      CALL OBSPEC
      GO TO 100
   21 CALL OBSUM
      GO TO 100
    2 IF (KCODE.NE.0) GO TO 12
      KAMEND = KOB
      GO TO 101
   12 CALL OBPATH
      GO TO 100
    3 CALL MASTER
      GO TO 100
    4 CALL FLYBY
      GO TO 100
    5 CALL NAVSAT
      GO TO 100
    8 CALL LORAN
      GO TO 100
    6 RETURN
C
  100 KAMEND = KOBS(KOB,11)
      IF (KAMEND.EQ.0) RETURN
  101 DO 200 I=5,10
      IX = KOBS(KAMEND,I)
      IF (IX.LE.0) GO TO 200
      SF = OBS(KAMEND,I-4)
      IF (SF.EQ.0) SF = 1.0
      DO 300 IA=NOBSIN,NOBS
      OBMAT(IA,IX) = SF
  300 CONTINUE
  200 CONTINUE
      RETURN
      END
      SUBROUTINE OBSPEC
      COMMON /OBSERV/ KOBS(20,12),OBS(20,6),OBLABL(2,20)
      COMMON /OBDATA/ NOBS,KOB,KCODE,NOBZ
      COMMON /LABEL/ XLABEL(6),SLABEL(6),SGLABL(6),OL(2,10)
      COMMON /TIMER/ TIME,TIMES,TIMEF,DT,DTINTG,TBASE
      COMMON /OBMAT/ OBMAT(10,50),OBNV(10,10),COEF(50,10),OBNS(10,10),OB
     1SIG(10),X(40)
C
      SIG = (OBS(KOB)*OBS(KOB,2))**2
      KX = KCODE - 3
      GO TO (4,5,4,7,7),KX
    4 IA= KOBS(KOB,5)
      IB= KOBS(KOB,6)
      IC= KOBS(KOB,7)
      NOBS = NOBS + 1
      OBSIG(NOBS) = SIG
      OL(1,NOBS) = OBLABL(1,KOB)
      OL(2,NOBS) = OBLABL(2,KOB)
      OBMAT(NOBS,IA) = 1.
      OBMAT(NOBS,IB) = 16.087*DT
      OBMAT(NOBS,IC) =  -16.087*DT**2/3.
      IF (KCODE.EQ.4) RETURN
      I = 3
      GO TO 6
    5 I = 0
    6 IA = KOBS(KOB,I+5)
      IB = KOBS(KOB,I+6)
      IC = KOBS(KOB,I+7)
      NOBS = NOBS + 1
      OBSIG(NOBS) = SIG
      OL(1,NOBS) = OBLABL(1,KOB)
      OL(2,NOBS) = OBLABL(2,KOB)
      OBMAT(NOBS,IA) = 1.
      OBMAT(NOBS,IB) = -16.087*DT
      OBMAT(NOBS,IC)  =  16.087*DT**2/3.
      RETURN
    7 ID = KOBS(KOB,8)
      RATIO = 1.
      TCON = OBS(KOB,3)
      IF (TCON.NE.0) RATIO = TCON/DT
      EXP3 = 32.174*(EXP(RATIO) - 1. + RATIO - 0.5*RATIO**2)/(RATIO**3)
      IF (KCODE-8) 11,12,13
   13 RETURN
   12 OBMAT(NOBS+1,ID) = EXP3
      GO TO 5
   11 OBMAT(NOBS+1,ID) = -EXP3
      KCODE = 4
      GO TO 4
      END
      SUBROUTINE OBSTAT
      COMMON /OBSERV/ KOBS(20,12),OBS(20,6),OBLABL(2,20)
      COMMON /OBDATA/ NOBS,KOB,KCODE,NOBZ
      COMMON /LABEL/ XLABEL(6),SLABEL(6),SGLABL(6),OL(2,10)
      COMMON /OBMAT/ OBMAT(10,50),OBNV(10,10),COEF(50,10),OBNS(10,10),OB
     1SIG(10),X(40)
C
      SIG = (OBS(KOB)*OBS(KOB,2))**2
    1 DO 2 I=1,KCODE
      NOBS = NOBS + 1
      OBSIG(NOBS) = SIG
      OL(1,NOBS) = OBLABL(1,KOB)
      OL(2,NOBS) = OBLABL(2,KOB)
      IK = KOBS(KOB,I+4)
      OBMAT(NOBS,IK) = 1.
    2 CONTINUE
      RETURN
C
      ENTRY OBSUM
      SIG = (OBS(KOB)*OBS(KOB,2))**2
      NOBS = NOBS + 1
      OBSIG(NOBS) = SIG
      OL(1,NOBS) = OBLABL(1,KOB)
      OL(2,NOBS) = OBLABL(2,KOB)
      DO 18 I=5,10
      IX = KOBS(KOB,I)
      IF (IX.NE.0) OBMAT(NOBS,IX) = 1.
   18 CONTINUE
      RETURN
      END
      SUBROUTINE OMEGA(W,P,V,PSI)
      COMMON /SGMODL/ JPATH,JMECH,JMODL,JDIFF,JFRAM,JVDAMP,JCLOOP,JGENX
      DIMENSION P(3),PSI(3),V(3),W(3)
      DATA WI,RADIUS/7.29E-05,2.0926E+07/
C
C     COMPUTE VEHICLE RATE WITH RESPECT TO INERTIAL SPACE
C
      W(1) = -V(2)/(RADIUS+P(3))
      W(2) = V(1)/(RADIUS+P(3))
      W(3) = 0.
      IF (JFRAM.GT.0) RETURN
      CLAT = COS( P(1))*WI
      W(1) = W(1) + CLAT*COS(PSI(2))
      W(2) = W(2) - CLAT*SIN(PSI(2))
      W(3) =  WI*SIN( P(1))
      RETURN
      END
C
      SUBROUTINE ORDER
      COMMON /DIMENS/ NF,NS,NSF,NDYN,NCTRL,NRA, NG,LINK(50)
      COMMON /STATE/ IST(50,5),ST(50,4),LOGIC(50,25),LABEL(50)
      LOGICAL LOGIC
      COMMON /PASS/ FILT,VECTOR,BKDOWN,RSS
      LOGICAL FILT,VECTOR,BKDOWN,RSS
      COMMON /OBSERV/ KOBS(20,12),OBS(20,6),OBLABL(2,20)
       DIMENSION ISTA(5),STA(4),LOGICA(25)
      LOGICAL LOGICA
C
C     REORDERS INPUT STATE LIST SO THAT WHITE NOISE SOURCES APPEAR LAST.
C
      DO 100 IZ=1,NSF
      IF (IST(IZ).GT.0) GO TO 100
      IST(IZ) = 20
      IST(IZ,4) = 1
  100 CONTINUE
      NDYN = NSF
      IF (BKDOWN) GO TO 10
      DO 1 IC=1,NSF
      DO 2 IA=1,NSF
      IF (IST(IA,2).NE.3) GO TO 2
      IX = IA
      GO TO 3
    2 CONTINUE
      NDYN = NSF
      GO TO 5
    3 DO 4 IB=1,NSF
      IBB = NSF + 1 - IB
      IF (IST(IBB,2).EQ.3) GO TO 4
      NDYN = IBB
      GO TO 7
    4 CONTINUE
      CALL ERROR1(13)
    7 IF (IBB.LT.IX) GO TO 5
      LAB = LABEL(IX)
      DO 31 K=1,4
      STA(K) = ST(IX,K)
   31 CONTINUE
      DO 32 K=1,5
      ISTA(K) = IST(IX,K)
   32 CONTINUE
      DO 33 K=1,25
      LOGICA(K) = LOGIC(IX,K)
   33 CONTINUE
      DO 34 LX=1,20
      DO 34 KX=5,10
      IF (KOBS(LX,KX).NE.IX) GO TO 34
      KOBS(LX,KX) = 0
   34 CONTINUE
      IBX = IBB - 1
      DO 40 L=IX,IBX
      LABEL(L) = LABEL(L+1)
      DO 41 K=1,4
      ST(L,K) = ST(L+1,K)
   41 CONTINUE
      DO 42 K=1,5
      IST(L,K) = IST(L+1,K)
   42 CONTINUE
      DO 43 K=1,25
      LOGIC(L,K) = LOGIC(L+1,K)
   43 CONTINUE
      DO 44 LX=1,20
      DO 44 KX=5,10
      LXX = L + 1
      IF (KOBS(LX,KX).NE.LXX) GO TO 44
      KOBS(LX,KX) = L
   44 CONTINUE
   40 CONTINUE
      LABEL(IBB) = LAB
      DO 51 K=1,4
      ST(IBB,K) = STA(K)
   51 CONTINUE
      DO 52 K=1,5
      IST(IBB,K) = ISTA(K)
   52 CONTINUE
      DO 53 K=1,25
      LOGIC(IBB,K) = LOGICA(K)
   53 CONTINUE
    1 CONTINUE
      CALL ERROR1(13)
    5 IF (FILT) NCTRL = NDYN
      NG = 0
      DO 6 I=1,NSF
      ITYPE = IST(I,2)
      IF ((ITYPE.GE.1.AND.ITYPE.LE.4).OR.ST(I,4).NE.0) NG = NG + 1
    6 CONTINUE
   10 IF (FILT) RETURN
      DO 17 I=1,NDYN
      IF (IST(I,5).GT.0) NX = I
   17 CONTINUE
      IF (NX.GT.NCTRL)  NCTRL = NX
      IF (.NOT.BKDOWN) RETURN
      IF (NS.EQ.0) GO TO 30
      N = IST(NS,4)
      DO 11 I=1,N
      DO 12 K=1,4
      ST(NCTRL+I,K) = ST(NS+I-1,K)
   12 CONTINUE
      DO 13 K=1,5
      IST(NCTRL+I,K) = IST(NS+I-1,K)
   13 CONTINUE
      DO 14 K=1,25
      LOGIC(NCTRL+I,K) = LOGIC(NS+I-1,K)
   14 CONTINUE
      LABEL(NCTRL+I) = LABEL(NS+I-1)
      LINK(NCTRL+I) = IST(NS+I-1,4)
      DO 11 LX=1,20
      DO 11 KX=5,10
      IOBS = KOBS(LX,KX)
      IF (NS+I-1-IOBS) 26,25,11
   25 KOBS(LX,KX) = NCTRL + I
      GO TO 11
   26 IF((NCTRL+I).EQ.IOBS) KOBS(LX,KX) = 0
   11 CONTINUE
      NDYN = NCTRL + N
      NG = 1
      IF (IST(NS,2).EQ.3) NDYN = NCTRL
      RETURN
   30 NDYN = NCTRL
      NG = 0
      NSF = NCTRL
      RETURN
      END
C
      SUBROUTINE PAGE1
      COMMON /PASS/ FILT,VECTOR,BKDOWN,RSS
      LOGICAL FILT,VECTOR,BKDOWN,RSS
      COMMON /LABEL/ XLABEL(6),SLABEL(6),SGLABL(6),OL(2,10)
      COMMON /LOGICL/ FILTAP,JSTART,VCHAN,LRESET
      LOGICAL FILTAP,JSTART,VCHAN,LRESET
      COMMON /SGMODL/ JPATH,JMECH,JMODL,JDIFF,JFRAM,JVDAMP,JCLOOP,JGENX
      COMMON /COUNTR/ J,JDT,JIN,JIDT,JFDT,NERR
      COMMON /DIMENS/ NF,NS,NSF,NDYN,NCTRL,NRA, NG,LINK(50)
      COMMON /OBSERV/ KOBS(20,12),OBS(20,6),OBLABL(2,20)
      COMMON /OBDATA/ NOBS,KOB,KCODE,NOBZ
      DATA (NPAG=0)
C
C     CONTROLS PAGE LENGTH
C
      NPAG = NPAG + 1
      PRINT 111,(XLABEL(I),I=1,6),NPAG
      N = 22
      IF (BKDOWN) N = 23
      IF (JDT.EQ.JIDT) GO TO 10
      IF (JDIFF.LE.1) GO TO 20
      N = N + 2
      IF (VCHAN) N = N + 1
      GO TO 20
   10 N = N + 4
      IF (VCHAN) N = N + 1
   20 IF (LRESET) N = N + 1
      IF (VCHAN) N = N + 2
      NRX = 62
      NC = NRA/5 + 3
      IF (5*(NRA/5).EQ.NRA) NC = NC - 1
      RETURN
C
      ENTRY PAGE2
      N = 5
      NC = NDYN/5 + 3
      IF (5*(NDYN/5).EQ.NDYN) NC = NC - 1
      NPAG = NPAG + 1
      PRINT 111,(XLABEL(I),I=1,6),NPAG
      NRX = 62
      RETURN
C
      ENTRY CKPAG1
      N = N + NC
   30 IF (N.LE.60) RETURN
      NPAG = NPAG + 1
      PRINT 111,(XLABEL(I),I=1,6),NPAG
  111 FORMAT (1H1,14X,6A10,'   PAGE ',I4/ )
      N = NC + 2
      RETURN
C
      ENTRY CKPAG2
      N = N + NC - 1
      GO TO 30
C
      ENTRY CKPAG3
      N = N + 1
      RETURN
C
      ENTRY CKPAG4
      NRX = NRX + 4
      IF (NRX.LE.60) RETURN
      NPAG = NPAG + 1
      PRINT 112,(XLABEL(I),I=1,6),NPAG
  112 FORMAT (1H1,14X,6A10,'   PAGE ',I4//17X,'PERT VEL    PERT ACC    T
     1OTAL VEL    TOTAL ACC    TH(RAD)     WAS(RPS)')
      NRX = 3
      RETURN
      END
      SUBROUTINE PATHIN
      COMMON /TIMER/ TIME,TIMES,TIMEF,DT,DTINTG,TBASE
      COMMON /SEGMNT/ JSEG(25,25),SEG(25,20),SEGLAB(25,6)
      COMMON /ENDPTS/ VI(3),VF(3),VFP(3),WI(3),WF(3),PI(3),PF(3),PSII(3)
     1,PSIF(3),PSIP(3)
      COMMON /CONTRL/ NTYPE,JSTAR,JDTI,JSTOP,JDTF
      COMMON /DYNAM/ W(3),A(3),V(3),P(3),PSI(3),WB(3),WBD(3),TSB(3,3)
      COMMON /PASS/ FILT,VECTOR,BKDOWN,RSS
      LOGICAL FILT,VECTOR,BKDOWN,RSS
      COMMON /PERT/ WT(30)
      COMMON /SGMODL/ JPATH,JMECH,JMODL,JDIFF,JFRAM,JVDAMP,JCLOOP,JGENX
      COMMON /OBRLZ/ OBRLZ(8),SWRLZ
      COMMON /OBSERV/ KOBS(20,12),OBS(20,6),OBLABL(2,20)
      COMMON /COUNTR/ J,JDT,JIN,JIDT,JFDT,NERR
      COMMON /SGDTS/ JDTS,J1ST,JPDT,J1SAV,JSAVDT,JINT,JRXGEN
      TYPE LOGICAL SWRLZ
C
C     LOCATES SEGMENT END POINTS AND COMPUTES CONSTANTS TO BE USED IN A
C     PIECEWISE CONSTANT APPROXIMATION.
C
      IF (.NOT.FILT) GO TO 2100
      DT = SEG(J,2)
      TIMES = TIMEF
      DO 3 I=1,3
      VFP(I) = VF(I)
      PI(I) = PF(I)
      PSIP(I) = PSIF(I)
    3 CONTINUE
      IF (JPATH.GE.4) GO TO 6
      CALL VTRAJ
      CALL GCPATH
      GO TO 2000
    6 IF (JPATH.GE.8) GO TO 9
      CALL VTRAJ
      CALL TNPATH
      GO TO 2000
    9 CALL RBPATH
 2000 DTINTG = DT/JINT
      SWRLZ = .FALSE.
      DO 2002 K=10,17
      IOB = JSEG(J,K)
      IF (IOB.EQ.0) GO TO 2002
      IOBT = KOBS(IOB)
      IF (IOBT.EQ.21) SWRLZ = .TRUE.
 2002 CONTINUE
      IF (.NOT.SWRLZ) GO TO 2006
      IF (J.EQ.JSTAR) GO TO 2004
      DO 2003 K=10,17
      IOB = JSEG(J-1,K)
      IF (IOB.EQ.0) GO TO 2003
      IOBT = KOBS(IOB)
      IF (IOBT.EQ.21) GO TO 2006
 2003 CONTINUE
 2004 DO 2005 K=1,8
      OBRLZ(K) = 0.
 2005 CONTINUE
      OBRLZ(1) = PSII(3)
      OBRLZ(5) = PSII(3)
 2006 CALL NORTH
      CALL STRAPD
      CALL SAVPTH
      GO TO 2001
 2100 CALL SETPTH
 2001 DO 2101 I=1,30
      WT(I) = W(I)
 2101 CONTINUE
      RETURN
C
      ENTRY PATH
C
      IF (.NOT.FILT) GO TO 1100
      IF (JPATH.GE.4) GO TO 16
      CALL TRAJV
      CALL PATHGC
      GO TO 1000
   16 IF (JPATH.GE.8) GO TO 19
      CALL TRAJV
      CALL PATHTN
      GO TO 1000
   19 CALL PATHRB
 1000 CALL NORTH
      CALL STRAPD
 1002 DO 1001 I=1,30
      WT(I) = W(I)
 1001 CONTINUE
      IF (JGENX.NE.0) CALL VECHMO
      CALL SAVDYN
      RETURN
 1100 CALL SETDYN
      RETURN
C
      ENTRY PATHRS
C
      IF (.NOT.FILT) GO TO 26
      CALL VERTRS
      IF (JPATH.GE.4) GO TO 21
      CALL RESTGC
      GO TO 25
   21 IF (JPATH.GE.8) GO TO 25
      CALL RESTTN
   25 CALL NORTH
      CALL STRAPD
      CALL SAVDYN
      RETURN
   26 CALL SETDYN
      RETURN
      END
C
      SUBROUTINE PLABAK
      COMMON /OBSERV/ KOBS(20,12),OBS(20,6),OBLABL(2,20)
      COMMON /SEGMNT/ JSEG(25,25),SEG(25,20),SEGLAB(25,6)
      COMMON /STATE/ IST(50,5),ST(50,4),LOGIC(50,25),LABEL(50)
      LOGICAL LOGIC
      COMMON /CONTRL/ NTYPE,JSTAR,JDTI,JSTOP,JDTF
      COMMON /RESTR/ RESTAR,NRLEVL,NRPASS
      LOGICAL RESTAR
      COMMON /LOGICL/ FILTAP,JSTART,VCHAN,LRESET
      LOGICAL FILTAP,JSTART,VCHAN,LRESET
      COMMON /LIST/ XLIST(50,15),LC(15)
      COMMON /RXGEN/ RX(11,10),MDT(11),RANIN
      COMMON /OUTPT/ NINERT,NCOV,NTRN,NRXO,NERS,NSAVE(6),SAVO,FRSS,PRMIN
      COMMON /INIT/ LATO,LONGO,PSIO,ALPHAO,VELO,ALTO,VZO
      COMMON /DIMENS/ NF,NS,NSF,NDYN,NCTRL,NRA, NG,LINK(50)
      COMMON /TIMER/ T,TS,TF,DT,DTINTG,TBASE
      COMMON /LABEL/ XLABEL(6),SLABEL(6),SGLABL(6),OL(2,10)
      COMMON /PAGIN/ LPAG(5),PAGX(5)
      TYPE LOGICAL LPAG
      TYPE REAL LATO,LONGO
C
C     PRINTS OUT STATE OF PROGRAM AFTER EACH CALL TO INPUT SUBROUTINE
C
      IF (.NOT.LPAG(1)) GO TO 2
      PRINT 111,(XLABEL(I),I=1,6)
  111 FORMAT (1H1,14X,6A10)
      PRINT 10
   10 FORMAT (1H0,9X,' PTH MEC SYS FIL DIF SEG DIF GEN LST OBSERVABLES F
     1OR SEGMENT 1ST P/O VER'/8X'NO COD COD MOD MOD PRO DTS DTS DTS V-H
     2 1  2  3  4  5  6  7  8 P/O DEL LOO')
      DO 101 I=1,25
      PRINT 11,I,(JSEG(I,K),K=1,20)
   11 FORMAT (1H ,I9,9I4,8I3,3I4)
  101 CONTINUE
      PRINT 12
   12 FORMAT (1H0,9X'    VELOCITY   STEP SIZE  HEAD.-LAT.   LONGITUDE
     1REF. TIME  HALF CRIT.')
      DO 102 I=1,25
      PRINT 13,I,(SEG(I,K),K=1,6)
   13 FORMAT (1H ,I9,6E12.4)
  102 CONTINUE
      PRINT 111,(XLABEL(I),I=1,6)
      PRINT 14
   14 FORMAT (1H0,9X'     X-LEVER     Y-LEVER     Z-LEVER   CL GAIN 1
     1CL GAIN 2   CL GAIN 3')
      DO 103 I=1,25
      PRINT 13,I,(SEG(I,K),K=7,12)
  103 CONTINUE
      PRINT 15
   15 FORMAT (1H0,9X'   CL GAIN 4   CL GAIN 5   VT GAIN 1   VT GAIN 2
     1  AVG ACC  Z-VELOCITY')
      DO 104 I=1,25
      PRINT 13,I,(SEG(I,K),K=13,18)
  104 CONTINUE
      PRINT 111,(XLABEL(I),I=1,6)
      PRINT 16
   16 FORMAT (1H0,9X'SEGMENT-STATE CORRELATION'//10X,'SEG  ST    5    10
     1    15    20    25    30    35    40    45    50')
      DO 105 I=1,25
      PRINT 17,I,(LOGIC(K,I),K=1,50)
   17 FORMAT (1H ,I12,3X,10(1X,5L1))
  105 CONTINUE
      PRINT 30
   30 FORMAT (1H0,9X,' 1ST SAV RES DUM DUM'/10X,' SAV DEL PT. VAR VAR'
     133X'   DUMMY VAR   DUMMY VAR')
      DO 112 I=1,25
      PRINT 31,I,(JSEG(I,K),K=21,25),SEG(I,19),SEG(I,20)
   31 FORMAT (1H ,I9,5I4,33X,2E12.4)
  112 CONTINUE
    2 IF (.NOT.LPAG(3)) GO TO 3
      PRINT 111,(XLABEL(I),I=1,6)
      PRINT 18
   18 FORMAT (1H0,9X,'STATE DESCRIPTION'/8X'NO CO TY LI NO FI   RMS ERRO
     1R   UNITS   SC. FACTOR    CONSTANT    W. NOISE')
      DO 106 I=1,NSF
      PRINT 19,I,(IST(I,K),K=1,5),ST(I),LABEL(I),(ST(I,K),K=2,4)
   19 FORMAT (1H ,I8,I4,4I3,E12.4,X,A7,X,3E12.4)
  106 CONTINUE
    3 IF (.NOT.LPAG(2)) GO TO 4
      PRINT 111,(XLABEL(I),I=1,6)
      PRINT 20
   20 FORMAT (1H0,9X,'OBSERVABLE DEFINITIONS'//10X,'  OBS  1ST  DTS  DTS
     1    STATES IN OBSERVABLE DEF.   DUMMY ST'/8X'NO CODE   DT   ON  OF
     1F    1    2    3    4    5    6    1    2')
      DO 107 I=1,20
      PRINT 21,I,(KOBS(I,K),K=1,12)
   21 FORMAT (1H ,I9,12I5)
  107 CONTINUE
      PRINT 22
   22 FORMAT (1H0,9X,'   RMS ERROR    IDENTITY  SC, FACTOR  DATA WORD1
     1DATA WORD2  DATA WORD3')
      DO 108 I=1,20
      PRINT 32,I,OBS(I,1),OBLABL(1,I),OBLABL(2,I),(OBS(I,K),K=2,5)
   32 FORMAT (1H ,I9,E12.4,A10,A2,4E12.4)
  108 CONTINUE
    4 IF (.NOT.LPAG(4)) GO TO 5
      PRINT 111,(XLABEL(I),I=1,6)
      PRINT 23
   23 FORMAT (1H0,7X,'NO. CO  DATA LIST VALUES')
      DO 109 I=1,15
      IF (LC(I).EQ.0) GO TO 109
      PRINT 24,I,LC(I),(XLIST(K,I),K=1,50)
   24 FORMAT (1H0,I9,I4,4X,5E12.4/(18X,5E12.4))
  109 CONTINUE
      PRINT 25
   25 FORMAT (1H0,7X,'NO  CO  RANDOM GENERATOR DATA VALUES')
      DO 110 I=1,11
      IF (MDT(I).LE.0) GO TO 110
      PRINT 26,I,MDT(I),(RX(I,K),K=1,10)
   26 FORMAT (1H0,I9,I4,4X,5E12.4/18X,5E12.4)
  110 CONTINUE
    5 PRINT 111,(XLABEL(I),I=1,6)
      PRINT 27,LATO,LONGO,PSIO,ALPHAO,VELO,ALTO,TBASE,RANIN
   27 FORMAT (1H0,9X,'INITIALIZATION'//10X,'LAT   ='E12.4/10X,'LONG  ='E
     112.4/10X,*PSI   =*E12.4/10X,*ALPHA =*E12.4/10X,*VEL   =*E12.4/10X,
     2*ALTO  =*E12.4//10X,*TBASE =*E12.4//10X,*RANDOM NUMBER INITIALIZAT
     3ION =*E12.4)
      PRINT 28,NS,NF,JSTAR,JDTI,JSTOP,JDTF,NTYPE,NINERT,NCOV,NTRN,NRXO,
     1NERS,NRPASS,NRLEVL
   28 FORMAT (1H0,9X,'NUMBER OF SYSTEM STATE(S) ='I3/10X,'NUMBER OF FILT
     1ER STATES =*I3/10X,*BEGIN RUN AT SEGMENT =*I3*,DT =*I3/10X,*END RU
     2N AT SEGMENT =*I3*,DT =*I3/10X,*ERROR PROPOGATION MODE =*I3//10X,*
     3INERTIAL STATES OUTPUT MODE =*I3/10X,*COVARIANCE OUTPUT MODE =*I3/
     410X,*TRANSITION MATRIX OUTPUT MODE =*I3/10X*RANDOM MOTION OUTPUT M
     5ODE =*I3/10X,*SPECIAL OUTPUT CODE =*I3/10X,*RESTART AT PASS =*I3*,
     6 LEVEL =*I3)
      PRINT 29,PRMIN,VCHAN,FILTAP,SAVO,FRSS
   29 FORMAT (1H0,9X,'PRINTOUT IN MINUTES ='L3/10X,'VERTICAL CHANNEL SPE
     1CIFIED =*L3/10X,*FILTER HAS BEEN STORED ON TAPE =*L3/10X,*OUTPUT S
     2AVED IN DATA TAPE =*L3/10X,*FILTER INCLUDED IN RSS=*L3)
      RETURN
      END
C
      SUBROUTINE PRINTA
      COMMON /DIMENS/ NF,NS,NSF,NDYN,NCTRL,NRA, NG,LINK(50)
      COMMON /TIMER/ TIME,TIMES,TIMEF,DT,DTINTG,TBASE
      COMMON /PERT/  W(3),A(3),V(3),P(3),PSI(3),WB(3),WBD(3),TSB(3,3)
      COMMON /ENDPTS/ VI(3),VF(3),VFP(3),WI(3),WF(3),PI(3),PF(3),PSII(3)
     1,PSIF(3),PSIP(3)
      COMMON /OUTPT/ NINERT,NCOV,NTRN,NRXO,NERS,NSAVE(6),SAVO,FRSS,PRMIN
      TYPE LOGICAL PRMIN
      COMMON /COUNTR/ J,JDT,JIN,JIDT,JFDT,NERR
      COMMON /CONTRL/ NTYPE,JSTAR,JDTI,JSTOP,JDTF
      COMMON /LABEL/ XLABEL(6),SLABEL(6),SGLABL(6),OL(2,10)
      COMMON /SGMODL/ JPATH,JMECH,JMODL,JDIFF,JFRAM,JVDAMP,JCLOOP,JGENX
      COMMON /LOGICL/ FILTAP,JSTART,VCHAN,LRESET
      LOGICAL FILTAP,JSTART,VCHAN,LRESET
      DIMENSION HEADER(6,4),COMM1(6)
      DATA HEADER/1H ,10H         F,10HILTER COVA,10HRIANCE PRO,10HPOGAT
     1ION  ,1H ,1H ,10H       COL,10HLECTION OF,10H DETERMINI,10HSTIC ER
     2ROR,1HS,1H ,10H        CO,10HLLECTION O,10HF STOCHAST,10HIC ERRORS
     3 ,1H ,1H ,10H    RSS SY,10HSTEM ERROR,10H THRU    E,10HRROR SOURC,
     42HES/
      DATA RAD/57.2958/
      DATA COMM1/10H(15X,*TIME,10H =*E10.3,*,10H          ,10H/15X,*SEG
     1,10HNO.'I2', D,10HT NO.'I4) /
      DATA COMMA,COMMB,BLANK/5HSEC.',5HMIN.',1H  /
C
C        PRINT TRAJECTORY AND HEADER DATA
C
      I = NTYPE
      IF  (I-1) 60,61,62
   60 I=1
   62 DO 63 L=1,6
      SLABEL(L) = HEADER(L,I)
   63 CONTINUE
      IF (I-4) 1,64,1
   64 ENCODE (10,164,SLABEL(4)) NERR
  164 FORMAT (6H THRU ,I2,2H E)
      GO TO 1
   61 CALL STLABL(NCTRL+1)
      PRINT 102,SLABEL(1)
  102 FORMAT (37X,'ERROR SOURCE-',A10)
    1 PRINT 110,BLANK,(SLABEL(K),K=2,6)
  110 FORMAT (15X,6A10)
      IF (PRMIN) GO TO 2
      ENCODE (10,109,COMM1(3)) COMMA
  109 FORMAT (A10)
      TIMEA = TIME
      GO TO 3
    2 TIMEA = TIME/60.
      ENCODE (10,109,COMM1(3)) COMMB
    3 PRINT COMM1,TIMEA,J,JDT
      IF (JDT.EQ.0) GO TO 4
      PLAT = P*RAD
      PLONG = P(2)*RAD
      ALT = P(3)
      GO TO 5
    4 PLAT = PF*RAD
      PLONG = PF(2)*RAD
      PRINT 103,PLAT,PLONG
  103 FORMAT (15X,'FINAL  LATITUDE  ='F10.5/15X,'FINAL  LONGITUDE ='F10.
     15)
      PLAT = PI*RAD
      PLONG = PI(2)*RAD
      ALT = PI(3)
    5 IF (VCHAN) GO TO 6
      PRINT 104,PLAT,PLONG
  104 FORMAT (15X,'CURRENT LATITUDE ='F10.5/15X,'CURRENT LONGITUDE='F10.
     15)
      GO TO 7
    6 PRINT 122,PLAT,PLONG,ALT
  122 FORMAT (15X,'CURRENT LATITUDE ='F10.5/15X,'CURRENT LONGITUDE='F10.
     15/15X,*CURRENT ALTITUDE =*F10.2)
    7 RETURN
      END
      SUBROUTINE PRINTK
      COMMON /COUNTR/ J,JDT,JIN,JIDT,JFDT,NERR
      COMMON /DIMENS/ NF,NS,NSF,NDYN,NCTRL,NRA, NG,LINK(50)
      COMMON /OBMAT/ OBMAT(10,50),OBNV(10,10),COEF(50,10),OBNS(10,10),OB
     1SIG(10),X(40)
      COMMON /CONTRL/ NTYPE,JSTAR,JDTI,JSTOP,JDTF
      COMMON /LOGICL/ FILTAP,JSTART,VCHAN,LRESET
      LOGICAL FILTAP,JSTART,VCHAN,LRESET
      COMMON /LABEL/ XLABEL(6),SLABEL(6),SGLABL(6),OL(2,10)
      COMMON /OBDATA/ NOBS,KOB,KCODE,NOBZ
C
C        PRINT KALMAN FEEDBACK COEFFICIENTS ON
C        FILTER PASS AND FIRST SYSTEM PASS
C
  100 IF (.NOT.LRESET.OR.NERR.GT.1) GO TO 200
      IF (NOBS.EQ.0) GO TO 200
      DO 20 I=1,NOBS
      CALL CKPAG1
      PRINT 111,I,OL(1,I),OL(2,I),(COEF(K,I),K=1,NCTRL)
  111 FORMAT (1H0,14X,'OBSERVABLE NUMBER',I2,1H,,2A10/(15X,5E14.5))
   20 CONTINUE
  200 RETURN
      END
      SUBROUTINE PRINTN
      COMMON /COUNTR/ J,JDT,JIN,JIDT,JFDT,NERR
      COMMON /OUTPT/ NINERT,NCOV,NTRN,NRXO,NERS,NSAVE(6),SAVO,FRSS,PRMIN
      COMMON /RSS/ RSSB(25,25),RSSA(25,25),RSSO(12,4)
      COMMON /LOGICL/ FILTAP,JSTART,VCHAN,LRESET
      LOGICAL FILTAP,JSTART,VCHAN,LRESET
      COMMON /CONTRL/ NTYPE,JSTAR,JDTI,JSTOP,JDTF
      DIMENSION COMMNT(60),COM(4)
      DATA  COMMNT/10H0         ,10H     LEVEL,10H POSITION ,10HERROR-CE
     1P ,10H(FEET)    ,10H          ,10H       X-P,10HOSITION ER,10HROR-
     2RMS (F,10HEET)      ,10H          ,10H       Y-P,10HOSITION ER,10H
     3ROR-RMS (F,10HEET)      ,10H          ,10H     Z-ALT,10HITUDE ERRO
     4,10HR-RMS (FEE,10HT)        ,10H0         ,10H     LEVEL,10H VELOC
     5ITY ,10HERROR-RMS ,10H(FPS)     ,10H          ,10H       X-V,10HEL
     6OCITY ER,10HROR-RMS (F,10HPS)       ,10H          ,10H       Y-V,1
     70HELOCITY ER,10HROR-RMS (F,10HPS)       ,10H          ,10H     Z-V
     8EL,10HOCITY ERRO,10HR-RMS (FPS,10H)         ,10H0         ,10H
     9 PHI-X,10H, TILT ABO,10HUT X-RMS (,10HSEC)      ,10H          ,10H
     9     PHI-Y,10H, TILT ABO,10HUT Y-RMS (,10HSEC)      ,10H0
     1,10H     PSI-Z,10H, AZIMUTH ,10HERROR RMS ,10H(SEC)     ,10H
     2    ,10H     PHI-Z,10H, HEADING ,10HERROR-RMS ,10H(SEC)     /
C
C
C        PRINT POSITION, VELOCITY AND ATTITUDE ERRORS
C        AT EACH DT
C
C
    7 IF (NINERT.EQ.1) GO TO 100
      PRINT 105,NERR
  105 FORMAT (61X,'SYSTEM ERROR',27X,'RSS THRU NO.'I3)
      IF (LRESET) GO TO 8
      NOUT = 2
      ENCODE (33,106,COM)
  106 FORMAT (33H(5A10,10X,F14.3,29X,F14.3)        )
      GO TO 10
    8 NOUT = 4
      PRINT 107
  107 FORMAT(52X,'BEFORE RESET      AFTER RESET',11X,'BEFORE RESET
     1AFTER RESET')
      ENCODE (33,108,COM)
  108 FORMAT (33H(5A10,F14.3,F18.3,9X,F14.3,F18.3))
   10 DO 11 I=1,12
      IF (.NOT.VCHAN.AND.(I.EQ.4.OR.I.EQ.8)) GO TO 11
      KA = 5*I - 4
      KB = KA + 4
      PRINT COM,(COMMNT(K),K=KA,KB),(RSSO(I,K),K=1,NOUT)
   11 CONTINUE
  100 RETURN
      END
      SUBROUTINE PRINTO
      COMMON /COUNTR/ J,JDT,JIN,JIDT,JFDT,NERR
      COMMON /OBSERV/ KOBS(20,12),OBS(20,6),OBLABL(2,20)
      COMMON /OBDATA/ NOBS,KOB,KCODE,NOBZ
      COMMON /PASS/ FILT,VECTOR,BKDOWN,RSS
      LOGICAL FILT,VECTOR,BKDOWN,RSS
      COMMON /LOGICL/ FILTAP,JSTART,VCHAN,LRESET
      LOGICAL FILTAP,JSTART,VCHAN,LRESET
C
C        EXECUTIVE PRINT SUBROUTINE
C
      CALL PAGE1
      CALL PRINTA
      CALL SYSOUT
      CALL PRINTN
      IF(LRESET.AND.NERR.LE.1) CALL PRINTK
      IF(VECTOR) GO TO 10
      CALL PRINTQ
      IF (RSS) CALL SAVSUM
      RETURN
C
   10 CALL PRINTV
      RETURN
      END
      SUBROUTINE PRINTQ
      COMMON /DIMENS/ NF,NS,NSF,NDYN,NCTRL,NRA, NG,LINK(50)
      COMMON /OUTPT/ NINERT,NCOV,NTRN,NRXO,NERS,NSAVE(6),SAVO,FRSS,PRMIN
      COMMON /QRMAT/ Q(25,25),R(25,25),TEMP(25,25),C(25,25),S(25,25),D(2
     15,25,3)
      COMMON /PASS/ FILT,VECTOR,BKDOWN,RSS
      LOGICAL FILT,VECTOR,BKDOWN,RSS
      COMMON /STATE/ IST(50,5),ST(50,4),LOGIC(50,25),LABEL(50)
      LOGICAL LOGIC
      COMMON /LOGICL/ FILTAP,JSTART,VCHAN,LRESET
      LOGICAL FILTAP,JSTART,VCHAN,LRESET
      DIMENSION WORK(50)
C
C        PRINT Q-MATRIX FOR NOISE OR FILTER PASSES
C
      IF (NCOV.LE.0) RETURN
      IF (NCOV.GT.1) GO TO 500
      DO 21 I=1,NDYN
      Z = Q(I,I)
      IF(Z.LT.0.) Z=0.
      WORK(I) = SQRT(Z)/ST(I,2)
   21 CONTINUE
      IF (.NOT.FILT) GO TO 22
      PRINT 112
  112 FORMAT (1H0,14X,'ONE SIGMA FILTER ERROR')
      GO TO 23
   22 PRINT 113
  113 FORMAT (1H0,14X,'ONE SIGMA SYSTEM ERRORS DUE TO THIS ERROR SOURCE'
     1)
   23 IF (LRESET) GO TO 25
      PRINT 114,(WORK(I),I=1,NDYN)
  114 FORMAT ((15X,5E14.5))
      RETURN
   25 DO 24 I=1,NDYN
      Z = TEMP(I,I)
      IF (Z.LT.0.) Z = 0.
      WORK(I+25) = SQRT(Z)/ST(I,2)
   24 CONTINUE
      NXX = NDYN+25
      CALL CKPAG2
      PRINT 117, (WORK(I),I=26,NXX)
  117 FORMAT (15X,'BEFORE RESET'/(15X,5E14.5))
      CALL CKPAG2
      PRINT 118, (WORK(I),I=1,NDYN)
  118 FORMAT (15X,'AFTER RESET'/(15X,5E14.5))
      RETURN
  500 IF (FILT) GO TO 51
      PRINT 115
  115 FORMAT (1H0,14X,'FILTER COVARIANCE MATRIX')
      GO TO 52
   51 PRINT 116
  116 FORMAT (1H0,14X,'SYSTEM COVARIANCE MATRIX')
   52 IF (LRESET) GO TO 54
      DO 53 I=1,NDYN
      CALL CKPAG1
      PRINT 119,I
      DO 153 K=1,NDYN
      WORK(K) = Q(I,K)/(ST(I,2)*ST(K,2))
  153 CONTINUE
      PRINT 114,(WORK(K),K=1,NDYN)
   53 CONTINUE
      RETURN
   54 DO 55 I=1,NDYN
      CALL CKPAG1
      PRINT 119,I
  119 FORMAT (1H0,14X,'ROW NUMBER'I3)
      KXX = NDYN + 25
      DO 155 K=1,NDYN
      SF = 1./(ST(I,2)*ST(K,2))
      WORK(K) = Q(I,K)*SF
      WORK(K+25) = TEMP(I,K)*SF
  155 CONTINUE
      CALL CKPAG3
      PRINT 117, (WORK(K),K=26,KXX)
      CALL CKPAG2
      PRINT 118, (WORK(K),K=1,NDYN)
   55 CONTINUE
      RETURN
      END
      SUBROUTINE PRINTV
      COMMON /DIMENS/ NF,NS,NSF,NDYN,NCTRL,NRA, NG,LINK(50)
      COMMON /QRMAT/ Q(25,25),R(25,25),TEMP(25,25),C(25,25),S(25,25),D(2
     15,25,3)
      COMMON /LABEL/ XLABEL(6),SLABEL(6),SGLABL(6),OL(2,10)
      COMMON /LOGICL/ FILTAP,JSTART,VCHAN,LRESET
        LOGICAL FILTAP,JSTART,VCHAN,LRESET
      COMMON /STATE/ IST(50,5),ST(50,4),LOGIC(50,25),LABEL(50)
      LOGICAL LOGIC
      DIMENSION WORK(50),SFX(15)
C
C        PRINT STATE VECTOR DATA FOR DETERMINISTIC PASSES
C
 1000 PRINT 120
  120 FORMAT (1H0,30X,'STATE VECTOR ERROR PROPOGATION VALUES')
      DO 1001 I=1,NDYN
      DO 1002 K=1,NRA
      IF (Q(K,I).NE.0.) GO TO 1003
 1002 CONTINUE
      GO TO 1001
 1003 CALL STLABL(I)
      CALL CKPAG1
      PRINT 121,I,(SLABEL(K),K=1,6)
  121 FORMAT (1H0,10X,I2,2X,6A10)
      IF (I.LE.NCTRL) GO TO 1005
      IF (LINK(I).EQ.0) GO TO 1006
      LINKI = LINK(I)
      NXX = NCTRL + LINKI
      DO 1004 L = 1,LINKI
      SFX(L) = 1./ST(I+L-1,2)
 1004 CONTINUE
      GO TO 1006
 1005 NXX = NCTRL
 1006 DO 31 K=1,NCTRL
      WORK(K) = Q(K,I)/ST(K,2)
      IF (LRESET) WORK(K+25) = TEMP(K,I)/ST(K,2)
   31 CONTINUE
      IF (I.LE.NCTRL) GO TO 1007
      DO 32 K=1,LINKI
      KZ = NCTRL+K
      WORK(KZ) = Q(KZ,I)*SFX(K)
      IF (LRESET) WORK(KZ+25) = TEMP(KZ,I)*SFX(K)
   32 CONTINUE
 1007 IF (LRESET) GO TO 1008
      PRINT 114,(WORK(K),K=1,NXX)
  114 FORMAT((15X,5E14.5))
      GO TO 1001
 1008 NZZ = NXX + 25
      CALL CKPAG3
      PRINT 118,(WORK(K),K=1,NXX)
  118 FORMAT(15X,'AFTER RESET'/(15X,5E14.5))
 1001 CONTINUE
      RETURN
      END
      SUBROUTINE PROPM
      COMMON /TIMER/ T,TS,TF,DT,DTINTG,TBASE
      COMMON /STATE/ IST(50,5),ST(50,4),LOGIC(50,25),LABEL(50)
      LOGICAL LOGIC
      COMMON /COUNTR/ J,JDT,JIN,JIDT,JFDT,NERR
      COMMON /DIMENS/ NF,NS,NSF,NDYN,NCTRL,NRA, NG,LINK(50)
      COMMON /QRMAT/ Q(25,25),R(25,25),S(25,25,6)
      COMMON /PASS/ FILT,VECTOR,BKDOWN,RSS
      LOGICAL FILT,VECTOR,BKDOWN,RSS
      COMMON /SGMODL/ JPATH,JMECH,JMODL,JDIFF,JFRAM,JVDAMP,JCLOOP,JGENX
      COMMON /LOGICL/ FILTAP,JSTART,VCHAN,LRESET
      LOGICAL FILTAP,JSTART,VCHAN,LRESET
C
C     PROPOGATE PATH MODEL FOR DTING SECONDS
C
      T = T + DTINTG
      IF (JDIFF.LT.1) T = TS + JDT*DT
  100 DO 10 I=1,NDYN
      IF(IST(I,2).NE.7) GO TO 10
      IF (.NOT.LOGIC(I,J)) GO TO 10
      CALL TABLE (X,T,IST(I,3),ST(I,2))
      IF (VECTOR) GO TO 11
      Q(I,I) = X**2
      GO TO 10
   11 IX = I
      IF (I.GT.NCTRL) IX = NCTRL + 1
      Q(IX,I) = X
   10 CONTINUE
      RETURN
      END
C
      SUBROUTINE PROPQ
      COMMON /TIMER/ TIME,TIMES,TIMEF,DT,DTINTG,TBASE
      COMMON /QRMAT/ Q(25,25),R(25,25),C(25,25),D(25,25),E(25,25),
     1B(25,25),ARESET(25,50)
      COMMON /PASS/ FILT,VECTOR,BKDOWN,RSS
      LOGICAL FILT,VECTOR,BKDOWN,RSS
      COMMON /DIMENS/ NF,NS,NSF,NDYN,NCTRL,NRA, NG,LINK(50)
      COMMON /SEGMNT/ JSEG(25,25),SEG(25,20),SEGLAB(25,6)
      COMMON /SGMODL/ JPATH,JMECH,JMODL,JDIFF,JFRAM,JVDAMP,JCLOOP,JGENX
      COMMON /FGMAT/ F(25,25),G(25,25),T(25,25),A(25,25)
      COMMON /COUNTR/ J,JDT,JIN,JIDT,JFDT,NERR
C
C     PROPOGATE STATE VECTOR OR COVARIANCE ERROR
C
      MODEL = JDIFF + 1
      IF (VECTOR) GO TO 100
      GO TO (1,3,3,5,6),MODEL
    1 CALL ARAT(C,Q,T,NDYN,NDYN,25,25,25,LINK(1))
      CALL MATADD(Q,C,R,NDYN,NDYN,25,25,25)
      GO TO 150
    3 CALL QPRIME(E,F,Q,R,NDYN,LINK(1))
      CALL MATAD1(Q,Q,DTINTG,E,NDYN,NDYN,25,25,25)
      CALL FMAT
      CALL GMAT
      GO TO 150
    5 CALL QPRIME(E,F,Q,R,NDYN,LINK(1))
      CALL MATAD1(D,Q,DTINTG,E,NDYN,NDYN,25,25,25)
      CALL FMAT
      CALL GMAT
      CALL QPRIME(E,F,D,R,NDYN,LINK(1))
      DO 10 I=1,NDYN
      DO 10 K=1,NDYN
      Q(I,K) = 0.5*(Q(I,K) + D(I,K) + DTINTG*E(I,K))
   10 CONTINUE
      GO TO 150
    6 DTX = DTINTG/3.
      IF ( 2'(JIN/2).EQ.JIN) GO TO 7
      DTY = 2.*DTINTG/3.
      DTZ= 2.*DTINTG
      CALL QPRIME(E,F,Q,R,NDYN,LINK(1))
      CALL MATAD1(C,Q,DTINTG,E,NDYN,NDYN,25,25,25)
      CALL MATAD1(T,Q,DTX,E,NDYN,NDYN,25,25,25)
      CALL FMAT
      CALL GMAT
      CALL QPRIME(E,F,C,R,NDYN,LINK(1))
      CALL MATAD1(C,Q,DTINTG,E,NDYN,NDYN,25,25,25)
      CALL MATAD1(T,T,DTY,E,NDYN,NDYN,25,25,25)
      CALL QPRIME(E,F,C,R,NDYN,LINK(1))
      CALL MATAD1(C,Q,DTZ,E,NDYN,NDYN,25,25,25)
      CALL MATAD1(T,T,DTY,E,NDYN,NDYN,25,25,25)
      RETURN
    7 CALL FMAT
      CALL GMAT
      CALL QPRIME(E,F,C,R,NDYN,LINK(1))
      CALL MATAD1(Q,T,DTX,E,NDYN,NDYN,25,25,25)
  150 CALL LIMITQ
      RETURN
  100 NX = NRA
      GO TO (101,103,103,106,16),MODEL
  101 CALL MATMP1(C,T,Q)
      CALL MATMOV(Q,C,NRA,NDYN,25,25)
      RETURN
  103 CALL MATMP1(C,F,Q)
      CALL MATAD2(Q,Q,DTINTG,C,NRA,NDYN,25,25,25)
      CALL FMAT
      RETURN
  106 CALL MATMP1(C,F,Q)
      CALL MATAD2(T,Q,DTINTG,C,NRA,NDYN,25,25,25)
      CALL FMAT
      CALL MATMP1(C,F,T)
      DO 13 I=1,NRA
      DO 13 K=1,NDYN
      Q(I,K) = 0.5*(Q(I,K) + T(I,K) + DTINTG*C(I,K))
   13 CONTINUE
      RETURN
   16 DTX = DTINTG/3.
      IF (2'(JIN/2).EQ.JIN) GO TO 17
      DTY = 2.*DTINTG/3.
      DTZ = 2.*DTINTG
      CALL MATMP1(E,F,Q)
      CALL MATAD2(C,Q,DTINTG,E,NRA,NDYN,25,25,25)
      CALL MATAD2(T,Q,DTX,E,NRA,NDYN,25,25,25)
      CALL FMAT
      CALL MATMP1(E,F,C)
      CALL MATAD2(C,Q,DTINTG,E,NRA,NDYN,25,25,25)
      CALL MATAD2(T,T,DTY,E,NRA,NDYN,25,25,25)
      CALL MATMP1(E,F,C)
      CALL MATAD2(C,Q,DTZ,E,NRA,NDYN,25,25,25)
      CALL MATAD2(T,T,DTY,E,NRA,NDYN,25,25,25)
      RETURN
   17 CALL FMAT
      CALL MATMP1(E,F,C)
      CALL MATAD2(Q,T,DTX,E,NRA,NDYN,25,25,25)
      RETURN
      END
C
      SUBROUTINE QPRIME(QP,F,Q,R,NDYN,LINK1)
      DIMENSION QP(25,25),F(25,25),Q(25,25),R(25,25)
C
C     COMPUTE QPRIME = FQ + QFT + R
C
      CALL MATMP2(QP,F,Q,LINK1,NDYN,25,25,25)
      DO 1 I=1,NDYN
      DO 1 J=I,NDYN
      QP(I,J) = QP(J,I) = QP(J,I) + QP(I,J) + R(J,I)
    1 CONTINUE
      RETURN
      END
      SUBROUTINE RANSS(KK,U)
      COMMON /RXGEN/ RX(11,10),MDT(11),RANIN
C
C     COMPUTE ZERO MEAN GAUSSIAN RANDOM VARIABLE
C
      X = 0.
      DO 1 I=1,12
      CALL RANF(RANIN)
      X = X + RANIN
    1 CONTINUE
      U = X - 6.
      RETURN
      END
      SUBROUTINE RBPATH
      COMMON /SGDTS/ JDTS,J1ST,JPDT,J1SAV,JSAVDT,JINT,JRXGEN
      COMMON /TIMER/ T,TS,TF,DT,DTINTG,TBASE
      COMMON /ENDPTS/ VI(3),VF(3),VFP(3),WI(3),WF(3),PI(3),PF(3),PSII(3)
     1,PSIF(3),PSIP(3)
      COMMON /DYNAM/ W(3),A(3),V(3),P(3),PSI(3),WB(3),WBD(3),TSB(3,3)
      COMMON /SEGMNT/ JSEG(25,25),SEG(25,20),SEGLAB(25,6)
      COMMON /COUNTR/ J,JDT,JIN,JIDT,JFDT,NERR
C
C        SPECIAL FLIGHT PROFILE FOR ITTAV JINXING MANEUVERS.
C
      TF = TS + DT*JDTS
      VI(1) = VF(1) = SEG(J)
      PSII(1) = PSIP(1)
      PSII(2) = PSIP(2)
      PSII(3) = PSIP(3)
      VI(3) = VF(3) = SEG(J,18)
      PF(3) = PI(3) + VI(3)*DT*JDTS
      RA = 231073. + (TF - TS - 307.177948)*800.
      CALL LOCATE(PF,PSIF,PI,PSII,RA)
      PSIF(3) = PSII(3)
      PSIF(2) = PSIF(1) - PSIF(3)
      C = COS(PSII(3))
      S = SIN(PSII(3))
      VI(2) = VI(1)*S
      VI(1) = VI(1)*C
      VF(2) = VF(1)*S
      VF(1) = VF(1)*C
      CALL OMEGA(WI,PI,VI,PSII)
      CALL OMEGA(WF,PF,VF,PSIF)
      DO 1 I=1,3
      V(I) = VI(I)
      W(I) = WI(I)
      P(I) = PI(I)
      PSI(I) = PSII(I)
      A(I) = 0.0
    1 CONTINUE
      RETURN
C
C
      ENTRY PATHRB
      TIME = T - TS
      IF (TIME.GT.13.962634) GO TO 10
      ST = SIN(.225*TIME)
      VL = 282.8*ST
      VR = 800.0*SQRT(1.0-0.25*ST**2)
      CT = COS(.225*TIME)
      AL = 63.63*CT
      AR = -36000.*CT*ST/VR
      R = 787.312*TIME
      GO TO 100
C
   10 TIME = TIME - 13.962634
      IF (TIME.GT.279.25268) GO TO 20
      ST = SIN(.225*TIME)
      VL = -565.6*ST
      VR = 800.0*SQRT(1.0-0.5*ST**2)
      CT = COS(.225*TIME)
      AL = -127.26*CT
      AR = -72000.*CT*ST/VR
      R = 747.472*TIME + 10992.95
      GO TO 100
C
   20 TIME = TIME - 279.25268
      IF (TIME.GT.13.962634) GO TO 30
      ST = SIN(.225*TIME)
      VL = -282.8*ST
      VR = 800.0*SQRT(1.0-0.25*ST**2)
      CT = COS(.225*TIME)
      AL = -63.63*CT
      AR = -36000.0*CT*ST/VR
      R = 787.312*TIME + 220079.24
      GO TO 100
C
   30 TIME = TIME - 13.962634
      VL = 0.0
      VR = 800.0
      AL = 0.0
      AR = 0.0
      R = 800.0*TIME + 231073.07
C
  100 V(1) = VR*C - VL*S
      V(2) = VR*S + VL*C
      A(1) = AR*C - AL*S
      A(2) = AR*S + VL*C
      V(3) = VI(3)
      A(3) = 0.0
      P(3) = PI(3) + VI(3)*(T-TS)
      CALL LOCATE(P,PSI,PI,PSII,R)
      PSI(3) = PSII(3)
      PSI(2) = PSI(1) - PSI(3)
      CALL OMEGA(W,P,V,PSI)
      RETURN
      END
      SUBROUTINE RECORD
      COMMON /OBSERV/ OBSERV(400)
      COMMON /SEGMNT/ SEGMNT(1275)
      COMMON /STATE/ IST(1750)
      COMMON /LOGICL/ LOGICL(4)
      COMMON /CONTRL/ CONTRL(5)
      COMMON /PASS/ PASS(4)
      COMMON /RESTR/ RESTR(3)
      COMMON /COUNTR/ COUNTR(5),NERR
      COMMON /RXGEN/ RXGEN(122)
      COMMON /LIST/ LIST(765)
      COMMON /INIT/ INIT(7)
      COMMON /DIMENS/ DIMENS(57)
      COMMON /TIMER/ TIMER(6)
      COMMON /OUTPT/ OUTPT(14)
      COMMON /LABEL/ LABEL(38)
      COMMON /ENDPTS/ ENDPTS(30)
      COMMON /QRMAT/ QRMAT(25,50),S(25,25,6)
C
C
C     SAVE PROGRAM STATUS AT RESTART POINTS
C
      REWIND 30
      READ (30) NLEVEL,NPASS
   20 IF (EOF(30)) 2,120
  120 IF (NLEVEL.EQ.NRLEVL.AND.NPASS.EQ.NRPASS) GO TO 200
      READ (30)
      GO TO 20
    2 BACKSPACE 30
      WRITE (30) NRLEVL,NERR
      WRITE (30) OBSERV,SEGMNT,LIMITS,CONTRL,STATE,LOGICL,RXGEN,LIST,INI
     1T,DIMENS,TIMER,OUTPT,LABEL,ENDPTS,QRMAT,PASS,RESTR,COUNTR
      RETURN
C
  200 PRINT 202,NRLEVL,NRPASS
  202 FORMAT ('  RESTART RECORD'2I3'ALREADY EXISTS, NEW RESTART RECORD N
     1EW RESTART RECORD NOT CREATED')
      RETURN
C
C
      ENTRY RESTOR
C
      REWIND 30
   10 READ (30) NLEVEL,NPASS
      IF (EOF(30)) 100,11
   11 IF (NLEVEL.NE.NRLEVL) GO TO 1
      IF (NPASS.NE.NRPASS) GO TO 1
      READ (30) OBSERV,SEGMNT,LIMITS,CONTRL,STATE,LOGICL,RXGEN,LIST,INIT
     1,DIMENS,TIMER,OUTPT,LABEL,ENDPTS,QRMAT,PASS,RESTR,COUNTR
      RETURN
    1 READ (30)
      GO TO 10
C
  100 PRINT 101,NRLEVL,NRPASS
  101 FORMAT ('  RESTART FILE'2I3' NOT ON TAPE 30')
      RETURN
      END
      SUBROUTINE RESET
      COMMON /QRMAT/ Q(25,25),R(25,25,5),AM(25,50)
      COMMON /OBSERV/ KOBS(20,12),OBS(20,6),OBLABL(2,20)
      COMMON /OBDATA/ NOBS,KOB,KCODE,NOBZ
      COMMON /DIMENS/ NF,NS,NSF,NDYN,NCTRL,NRA, NG,LINK(50)
      COMMON /PERT/  W(3),A(3),V(3),P(3),PSI(3),WB(3),WBD(3),TSB(3,3)
C
C     PERFORM CONVENTIONAL RESETS AFTER ANY KALMAN RESETS
C
      IF (NOBZ.NE.0) GO TO 21
      NOBZ = 1
      DO 20 I=1,NRA
      DO 20 K=1,NRA
      AM(I,K) = 0.
      IF (I.EQ.K) AM(I,I)=1.
   20 CONTINUE
   21 KCODE = KOBS(KOB) - 50
      IF (KCODE.GT.6) GO TO 100
      DO 50 I=1,KCODE
      KX = KOBS(KOB,I+4)
      AM(KX,KX) = AM(KX,KX) - 1.
   50 CONTINUE
      RETURN
  100 IF (KCODE-8) 101,103,102
  103 IA = KOBS(KOB,5)
      IB = KOBS(KOB,6)
      AM(IA,IA) = 0.0
      AM(IA,IB) = 1.0
      RETURN
  101 S = SIN(PSI(2))
      C = COS(PSI(2))
      ND = LINK(1)
      OMEG = 7.29E-05*COS(P(1))
      ND = KOBS(KOB,5)
      NE = KOBS(KOB,6)
      AM(7,ND) = S/OMEG
      AM(7,NE) = C/OMEG
      AM(ND,ND) = C**2 - 1.
      AM(ND,NE) = -S*C
      AM(NE,ND) = -S*C
      AM(NE,NE) = S**2 - 1.
  102 RETURN
      END
C
      SUBROUTINE RESET1
      COMMON /QRMAT/ Q(25,25,6),AM(25,50)
      COMMON /DIMENS/ NF,NS,NSF,NDYN,NCTRL,NRA, NG,LINK(50)
      COMMON /ENDPTS/ VI(3),VF(3),VFP(3),WI(3),WF(3),PI(3),PF(3),PSII(3)
     1,PSIF(3),PSIP(3)
      COMMON /LOGICL/ FILTAP,JSTART,VCHAN,LRESET
      LOGICAL FILTAP,JSTART,VCHAN,LRESET
      COMMON /SEGMNT/ JSEG(25,25),SEG(25,20),SEGLAB(25,6)
      COMMON /PERT/  W(3),A(3),V(3),P(3),PSI(3),WB(3),WBD(3),TSB(3,3)
      COMMON /STATE/ IST(50,5),ST(50,4),LOGIC(50,25),LABEL(50)
      LOGICAL LOGIC
      COMMON /COUNTR/ J,JDT,JIN,JIDT,JFDT,NERR
      DIMENSION DV(3)
C
C     SET UP INITIAL RESET AFTER AN IMPULSIVE ACCELERATION
C
      RE = 2.0926E+07 + PI(3)
      DO 1 I=1,NRA
      DO 2 K=1,NDYN
      AM(I,K) = 0.
    2 CONTINUE
      AM(I,I) = 1.
    1 CONTINUE
      DO 3 I=1,3
      DV(I) = VI(I) - VFP(I)
    3 CONTINUE
C
C     ROTATE DELTAV TO NORTH FOR ITTAV
      CAL = COS(PSII(2))
      SAL = SIN(PSII(2))
      T = DV(1)*CAL - DV(2)*SAL
      DV(2) = DV(1)*SAL + DV(2)*CAL
      DV(1) = T
      AM(3,1) = DV(3)/RE
      AM(4,2) = DV(3)/RE
      AM(4,1) = DV(2)*TAN(PI(1))/RE
      AM(3,2) = -AM(4,1)
      AM(3,6) = -DV(3)
      AM(3,7) = DV(2)
      AM(4,5) = DV(3)
      AM(4,7) = -DV(1)
      IF (.NOT.VCHAN) GO TO 50
      AM(3,9) = -DV(1)/RE
      AM(4,9) = -DV(2)/RE
      AM(8,5) = -DV(2)
      AM(8,6) = DV(1)
   50 ACC = SEG(J,17)
      IX = LINK(1) + 1
      DO 10 I=IX,NDYN
      IC = MOD(IST(I),1000)
      IE = IC/100
      IF (IE) 10,10,11
   11 IA = (IC-100*IE)/10
      IB = MOD(IC,10)
      IF (IA.LE.3.AND.IB.LE.3) GO TO 10
      IF (.NOT.(IA.GE.4.AND.IB.GE.4)) GO TO 14
      IF (IA.NE.IB) GO TO 12
      X = ACC*DV(IA-3)
      GO TO 30
   12 U = SQRT(DV(IA-3)**2 + DV(IB-3)**2)
      IF (U) 10,10,13
   13 X = ACC*DV(IA-3)*DV(IB-3)/U
      GO TO 30
   14 IF (IA.GT.IB) GO TO 15
      IZ = IA
      IA = IB
      IB = IZ
   15 IF (IB) 16,16,17
   16 X = 1.
      GO TO 18
   17 X = W(IB)
   18 X = X*DV(IA-3)
   30 GO TO (31,32,33,34,35,36),IE
   31 AM(5,I) = X
      GO TO 10
   32 AM(6,I) = X
      GO TO 10
   33 AM(7,I) = X
      GO TO 10
   34 AM(3,I) = X
      GO TO 10
   35 AM(4,I) = X
      GO TO 10
   36 IF (.NOT.VCHAN) RETURN
      AM(8,I) = X
   10 CONTINUE
      RETURN
      END
C
      SUBROUTINE RINIT
      COMMON /STATE/ IST(50,5),ST(50,4),LOGIC(50,25),LABEL(50)
      LOGICAL LOGIC
      COMMON /RESTR/ RESTAR,NRLEVL,NRPASS
      LOGICAL RESTAR
      COMMON /DIMENS/ NF,NS,NSF,NDYN,NCTRL,NRA, NG,LINK(50)
      COMMON /COUNTR/ J,JDT,JIN,JIDT,JFDT,NERR
      COMMON /PASS/ FILT,VECTOR,BKDOWN,RSS
      LOGICAL FILT,VECTOR,BKDOWN,RSS
      COMMON /NOISE/ SM(25)
C
C     SETS UP DIAGONAL OF NOISE MATRIX
C
      CALL ZERO(SM,25,1,25)
      NX = 0
      IF (BKDOWN) GO TO 10
      N1 = 1
      N2 = NSF
      GO TO 20
   10 N1 = NCTRL + 1
      N2 = N1
      IF (NS.EQ.0) GO TO 11
   20 DO 1 I=N1,N2
      IT = IST(I,2) + 1
      IF (.NOT.(IT.GE.2.AND.IT.LE.5 .OR.ST(I,4).NE.0.)) GO TO 1
      IF (.NOT.LOGIC(I,J)) GO TO 1
      GO TO (2,3,3,4,5,2,2,1,2) IT
    2 SM( I) = (ST(I,4)*ST(I,2))**2
      GO TO 1
    3 SM(I)  = 2.*(ST(I)*ST(I,2))**2/ST(I,3)
      GO TO 1
    4 SM(I) = 2*(ST(I)*ST(I,2))**2*ST(I,3)
      GO TO 1
    5 SM(I) = (ST(I)*ST(I,2))**2*4.0*ST(I,3)*ST(I+1,3)
    1 CONTINUE
   11 RETURN
      END
C
      SUBROUTINE SAVRSS
      COMMON /COUNTR/ J,JDT,JIN,JIDT,JFDT,NERR
      COMMON /PASS/ FILT,VECTOR,BKDOWN,RSS
      LOGICAL FILT,VECTOR,BKDOWN,RSS
      COMMON /RSS/ RSSB(625),RSSA(625),RSSO(12,4)
C
      IF (.NOT.RSS) GO TO 10
      IF (2'(NERR/2).EQ.NERR) GO TO 4
      GO TO 1
C
   10 IF (2'(NERR/2).EQ.NERR) GO TO 1
    4 WRITE (20) RSSA,RSSB
      RETURN
    1 WRITE (21) RSSA,RSSB
      RETURN
C
C
      ENTRY SETRSS
C
      IF (.NOT.RSS) GO TO 20
      IF (2'(NERR/2).EQ.NERR) GO TO 5
      GO TO 2
C
   20 IF (2'(NERR/2).EQ.NERR) GO TO 2
    5 READ (21) RSSA,RSSB
      RETURN
    2 IF (NERR.EQ.0) RETURN
      READ (20) RSSA,RSSB
      RETURN
C
C
      ENTRY ZRSS
C
      REWIND 20
      REWIND 21
      RETURN
C
      ENTRY RSSEOF
C
      IF (.NOT.RSS) GO TO 30
      IF (2'(NERR/2).EQ.NERR) GO TO 6
      GO TO 3
C
   30 IF (2'(NERR/2).EQ.NERR) GO TO 3
    6 ENDFILE 20
      RETURN
    3 ENDFILE 21
      RETURN
      END
      SUBROUTINE SAVSUM
        LOGICAL FILTAP,JSTART,VCHAN,LRESET
      COMMON /LOGICL/ FILTAP,JSTART,VCHAN,LRESET
      COMMON /COUNTR/ J,JDT,JIN,JIDT,JFDT,NERR
      COMMON /TIMER/ TIME,TIMES,TIMEF,DT,DTINTG,TBASE
      COMMON /RSS/ RSSB(25,25),RSSA(25,25),RSSO(12,4)
C
C         SAVE RSS DATA ON TAPE50 FOR ABBREVIATED OUTPUT
C
      I=1
      IF(LRESET) I=2
      WRITE(50) (RSSO(K,I),K=1,12),TIME,J,JDT
      RETURN
      END
      SUBROUTINE SAVTAP
        COMMON /LOGICL/ FILTAP,JSTART,VCHAN,LRESET
      LOGICAL FILTAP,JSTART,VCHAN,LRESET
      COMMON /OBDATA/ NOBS,KOB,KCODE,NOBZ
      COMMON /TIMER/ TIME(6)
      COMMON /DIMENS/ NF,NS,NSF,NDYN,NCTRL,NRA, NG,LINK(50)
      COMMON /ENDPTS/ ENDPTS(30)
      COMMON /DYNAM/ POS(30)
      COMMON /PERT/ PATH(30)
      COMMON /OBMAT/ OBMAT(10,50),OBNV(10,10),COEF(50,10),OBNS(10,10),OB
     1SIG(10),X(40)
      COMMON /STATE/ IST(50,5),ST(50,4),LOGIC(50,25),LABEL(50)
      LOGICAL LOGIC
      COMMON /OBRLZ/ OBRLZ(8),SWRLZ
      COMMON /QRMAT/ Q(25,25,4),TEMP(10,50),S(750),ARESET(25,50)
      DIMENSION B(4000)
C
C     DATA MANIPULATION ROUTINE. IF INTERNAL MEMORY OVERFLOWS(UNDERFLOWS
C     THE PROGRAM WRITES(READS) ON(FROM) TAPE. IF NO TAPE HAS BEEN DESIG
C     NATED IN THE PROBLEM INPUT THE PROGRAM TERMINATES.
C
C
      NENTRY = 1
      K = NUMB
    1 WRITE(10) K
      WRITE (10) (B(I),I=1,K)
      NUMB = 0.
      FILTAP = .TRUE.
      GO TO (100,2,3,4),NENTRY
  100 ENDFILE 10
      RETURN
C
      ENTRY SAVPTH
      NENTRY = 2
    2 K = NUMB
      NUMB = NUMB + 65
      LIMIT = NUMB
      IF (NUMB.GT. 4000) GO TO 1
      DO 21 I=1,5
      B(K+I) = TIME(I)
   21 CONTINUE
      DO 22 I=6,35
      B(K+I) = POS(I-5)
   22 CONTINUE
      DO 23 I=36,65
      B(K+I) = ENDPTS(I-35)
   23 CONTINUE
      RETURN
C
      ENTRY SAVDYN
      NENTRY = 3
    3 K = NUMB
      NUMB = NUMB + 38
      LIMIT = NUMB
      IF (NUMB.GT. 4000) GO TO 1
      DO 31 I=1,30
      B(K+I) = PATH(I)
   31 CONTINUE
      DO 32 I=1,8
      B(K+I+30) = OBRLZ(I)
   32 CONTINUE
      RETURN
C
      ENTRY SAVCOF
      NENTRY = 4
    4 K = NUMB
      NUMB = NUMB + NOBS*NCTRL + 2
      LIMIT = NUMB
      IF (NUMB.GT. 4000) GO TO 1
      K = K + 2
      B(K-1) = NOBS + .5
      B(K) = NCTRL + .5
      DO 41 I=1,NOBS
      DO 41 IA=1,NCTRL
      K = K+1
      B(K) = COEF(IA,I)
   41 CONTINUE
      RETURN
C
C     READ PROBLEM DATA FROM TAPE STARTING AT THE BEGINING
      ENTRY GETTAP
      REWIND 10
      NENTRY = 1
    5 READ (10) LIMIT
      READ (10) (B(I),I=1,LIMIT)
      NUMB = 0
      GO TO (200,6,7,8),NENTRY
  200 RETURN
C
      ENTRY SETPTH
      NENTRY = 2
    6 K = NUMB
      NUMB = NUMB + 65
      IF (NUMB.GT.LIMIT) GO TO 5
      DO 61 I=1,5
      TIME(I) = B(K+I)
   61 CONTINUE
      DO 62 I=6,35
      POS(I-5) = B(K+I)
   62 CONTINUE
      DO 63 I=36,65
      ENDPTS(I-35) = B(K+I)
   63 CONTINUE
      RETURN
C
      ENTRY SETDYN
      NENTRY = 3
    7 K = NUMB
      NUMB = NUMB + 38
      IF (NUMB.GT.LIMIT) GO TO 5
      DO 71 I=1,30
      PATH(I) = B(K+I)
   71 CONTINUE
      DO 72 I=1,8
      OBRLZ(I) = B(K+I+30)
   72 CONTINUE
      RETURN
C
      ENTRY SETCOF
      CALL ZERO(TEMP,NOBS,NRA,10)
      NENTRY = 4
    8 IF (NUMB-LIMIT) 84,5,5
   84 K = NUMB + 2
      NOBX = B(K-1)
      NCTRLZ = B(K)
      IF (NOBS.NE.NOBX) CALL ERROR1(17)
      NUMB = K + NOBX*NCTRLZ
      IF (NUMB.GT.LIMIT) GO TO 5
      DO 81 I=1,NOBX
      DO 81 IA=1,NCTRLZ
      K = K+1
      TEMP(I,IA) = B(K)
   81 CONTINUE
      DO 82 IA=1,NDYN
      IX = IST(IA,5)
      IF (IX.EQ.0) GO TO 82
      IF (IX.GT.NCTRL) CALL ERROR1(14)
      DO 83 K=1,NOBS
      COEF(IA,K) =  TEMP(K,IX)
   83 CONTINUE
   82 CONTINUE
      RETURN
C
      ENTRY ZCOEFF
      NUMB = 0
      RETURN
      END
      SUBROUTINE SEGIN
      COMMON /SEGMNT/ JSEG(25,25),SEG(25,20),SEGLAB(25,6)
      COMMON /SGMODL/ JPATH,JMECH,JMODL,JDIFF,JFRAM,JVDAMP,JCLOOP,JGENX
      COMMON /SGDATA/ LISTH,LISTV,JRESTR,JDUM1,JDUM2
      COMMON /SGDTS/ JDTS,J1ST,JPDT,J1SAV,JSAVDT,JINT,JRXGEN
      COMMON /CONTRL/ NTYPE,JSTAR,JDTI,JSTOP,JDTF
      COMMON /COUNTR/ J,JDT,JIN,JIDT,JFDT,NERR
      COMMON /PASS/ FILT,VECTOR,BKDOWN,RSS
      LOGICAL FILT,VECTOR,BKDOWN,RSS
      COMMON /RESTR/ RESTAR,NRLEVL,NRPASS
      LOGICAL RESTAR
      COMMON /LOGICL/ FILTAP,JSTART,VCHAN,LRESET
      LOGICAL FILTAP,JSTART,VCHAN,LRESET
      COMMON /DIMENS/ NF,NS,NSF,NDYN,NCTRL,NRA, NG,LINK(50)
      COMMON /STATE/ IST(50,5),ST(50,4),LOGIC(50,25),LABEL(50)
      DIMENSION MAX(10)
      DATA MAX/7,7,7,7,7,7,7,7,7,7/
C
C     SET UP SEGMENT DEPENDENT CONTROLS
C
      JSTART = (J.EQ.JSTAR).AND..NOT.RESTAR
      JX = JSEG(J)
      JFRAM = JX/100
      JGENX = (JX - 100*JFRAM)/10
      JPATH = MOD(JX,10)
      JMECH = JSEG(J,2)
      JMODL = JSEG(J,3)
      IF (FILT) JMODL = JSEG(J,4)
      JCLOOP = JMODL/10
      JMODL = MOD(JMODL,10)
      JDIFF = JSEG(J,5)
C         TEMPORARY CONVERSION FROM OLD FORMAT TO NEW FORMAT
      IF (JDIFF.GT.4) JDIFF = JDIFF - 2
      JDTS = JSEG(J,6)
      JINT = MAX0(1,JSEG(J,7))
      IF (JDIFF.LT.1) JINT = 1
      IF (JDIFF.EQ.4) JINT = 2*((JINT+1)/2)
      JRXGEN = MAX0(1,JSEG(J,8))
      LISTV = JSEG(J,9)/10
      LISTH = MOD(JSEG(J,9),10)
      J1ST = JSEG(J,18)
      JPDT = JSEG(J,19)
      JVDAMP = JSEG(J,20)/10
      IF (FILT) JVDAMP = MOD(JSEG(J,20),10)
      J1SAV = JSEG(J,21)
      JSAVDT = JSEG(J,22)
      JRESTR = JSEG(J,23)
      JIDT = 0
      IF (J.EQ.JSTAR) JIDT = JDTI
      JDT = JIDT
      JFDT = JDTS
      IF (J.EQ.JSTOP) JFDT = JDTF
      IF (JGENX.GT.0 .AND.  JDIFF.LE.0) JDIFF = JDIFF + 2
      IF (JMECH.GT.1.OR.JDIFF.GE.7) CALL ERROR1(4)
      CALL ZERO(LINK,50,1,50)
      LINK(1) = MAX(JMODL+1)
      IF (VCHAN) LINK(1) = LINK(1) + 2
      IF (JVDAMP.EQ.2) LINK(1) = LINK(1) + 1
      NX = LINK(1) + 1
      NY = NSF
      DO 13 I=NX,NY
      LINK(I) = IST(I,4)
   13 CONTINUE
      RETURN
      END
C
      SUBROUTINE SEPAR(VAS,ACC,WAS,WDAS,THET,GEN)
      COMMON /RXGEN/ RX(11,10),MDT(11),RANIN
      DIMENSION VAS(3),ACC(3),WAS(3),WDAS(3),GEN(6,10),THET(3)
      DATA (RX(I),I=  1, 11)/4*0.,.1344,0.,.08252,0.,0.,.00647,0./
      DATA (RX(I),I= 23, 33)/4*0.,1.253,.2048,1.062,.2738,.2048,.291,0./
      DATA (RX(I),I= 34, 44)/4*0.,1.244,.1664,1.013,.3589,.2304,.4108,0/
      DATA (RX(I),I= 45, 55)/4*0.,2.337,2.032,2.253,2.111,2.064,2.134,0/
      DATA (RX(I),I= 56, 66)/4*0.,1.718,0.,-.002442,0.,0.,.007001,0./
      DATA (RX(I),I= 67, 77)/4*0.,.3539,0.,-.001392,0.,0.,.0005923,0./
      DATA (RX(I),I= 78, 88)/4*0.,4.764,.007736,-.01743,.004855,.01304,
     1.008869,0./
      DATA (RX(I),I= 89, 99)/4*0.,6*1.,0./
      DATA MDT/4'0,6'500,0/
C
C     SHIP MOTION MODEL OUTPUT
C
      WDAS(1) = 0.
      WDAS(2) = RX(7,7)*GEN(5,7) + RX(7,6)*GEN(4,7)
      WDAS(3) =  RX(10,7)*GEN(5,10) + RX(10,6)*GEN(4,10)
      ACC(3) = RX(5,7)*GEN(5,5) + RX(5,6)*GEN(4,5)
      THET(2) = RX(7,8)*GEN(4,7) + RX(7,7)*GEN(3,7) + RX(7,6)*GEN(2,7) +
     1 RX(8,8)'GEN(4,8)
      WAS( 2) = RX(7,8)*GEN(5,7) + RX(7,7)*GEN(4,7) + RX(7,6)*GEN(3,7) +
     1 RX(8,8)'GEN(5,8)
      THET(1) = RX(6,8)*GEN(4,6) + RX(9,8)*GEN(4,9)
      WAS( 1) = RX(6,8)*GEN(5,6) + RX(9,8)*GEN(5,9)
      THET(3)= RX(10,8)*GEN(4,10) + RX(10,7)*GEN(3,10) + RX(10,6)*GEN(2,
     110)
      WAS( 3) = RX(10,8)*GEN(5,10) + RX(10,7)*GEN(4,10) + RX(10,6)*GEN(3
     1,10)
      VAS(3) = RX(5,8)*GEN(5,5) + RX(5,7)*GEN(4,5) + RX(5,6)*GEN(3,5)
      VAS(2) = 0.
      VAS(1) = 0.
      ACC(1) = 0.
      ACC(2) = 0.
      RETURN
      END
C
      SUBROUTINE SETSF(SFJ,LABELJ,MATCH)
      DIMENSION LABEL(43),SF(43)
      TYPE LOGICAL MATCH
      DATA LABEL/4HFEET,3HNM.,6HMETERS,2HKM,6HFT/SEC,3HKTS,5HM/SEC,5HKM/
     1HR,3HSEC,3HMIN,3HDEG,2HMR,3HRAD,6HDEG/HR,6HMR/SEC,6HRAD/HR,7HMIN/S
     2EC,7HRAD/SEC,3HERU,4HMERU,7HUG-BIAS,7HMG-BIAS,6HG-BIAS,5HDPH/G,7HD
     3PH/A  ,6HDPH/G2,7HDPH/A2 ,3HPPM,5HPPM/G,7HPPM/A  ,7HPPM/RPS,7HPPM/
     4DPH,6HUG/RPS,6HUG/DPH,7HSEC/RPS,7HSEC/DPH,7HUG/RPS2,7HUG/DPH2,7HSE
     5/PRS2,7HSE/DPH2,7HSECBIAS,7HPERCENT,1H /
      DATA SF/1.,6080.20,3.28083,3280.83,1.,1.688944,3.28083,0.91134,4.8
     1481368E-06,2.908882E-04,.01745329,0.001,1.,4.8481368E-06,.001,2.77
     277778E-04,2.908882E-04,1.,7.29211E-05,7.29211E-08,3.2174E-05,3.217
     34E-02,32.174,1.50684E-07,4.8481368E-06,4.8634E-09,4.8481368E-06,1.
     4E-06,3.1081E-08,1.E-06,1.E-06,.2062648,3.2174E-05,6.63636,4.848136
     58E-06,1.0,3.2174E-05,1368847,4.8481368E-06,206264.8,1.55984E-04,0.
     601,0.0/
C
C
C     LOCATES SCALE FACTOR FOR INPUT ALPHA-CODE
      DO 1 I=1,42
      LOG = LABEL(I)
      LOG = (LABELJ.A..N.LOG).O.(LOG.A..N.LABELJ)
      IF (LOG.NE.0) GO TO 1
      GO TO 2
    1 CONTINUE
      MATCH = .FALSE.
      LABELJ = LABEL(43)
      RETURN
    2 SFJ = SF(I)
      MATCH = .TRUE.
      RETURN
      END
C
      SUBROUTINE SIMIN
      COMMON /SEGMNT/ JSEG(25,25),SEG(25,20),SEGLAB(25,6)
      COMMON /TIMER/ T,TS,TF,DT,DTINTA,TBASE
      COMMON /CONTRL/ NTYPE,JSTAR,JDTI,JSTOP,JDTF
      COMMON /COUNTR/ J,JDT,JIN,JIDT,JFDT,NERR
      COMMON /RXGEN/ RX(11,10),MDT(11),RANIN
      COMMON /PERT/  W(3),A(3),V(3),P(3),PSI(3),WB(3),WBD(3),TSB(3,3)
      COMMON /DYNAM/ WT(3),AT(3),VT(3),PT(3),PSIT(3),WBT(3),WBDT(3),TSBT
     1(3,3)
      COMMON /OUTPT/ NINERT,NCOV,NTRN,NRXO,NERS,NSAVE(6),SAVO,FRSS,PRMIN
      COMMON /OBRLZ/ THA,THI(3),THB,TH(3),OBRLZ
      COMMON /OBSERV/ KOBS(20,12),OBS(20,6),OBLABL(2,20)
      COMMON /LOGICL/ FILTAP,JSTART,VCHAN,LRESET
      LOGICAL FILTAP,JSTART,VCHAN,LRESET
      COMMON /ENDPTS/ VI(3),VF(3),VFP(3),WI(3),WF(3),PI(3),PF(3),PSII(3)
     1,PSIF(3),PSIP(3)
      COMMON /SGDTS/ JDTS,J1ST,JPDT,J1SAV,JSAVDT,JINT,JRXGEN
      COMMON /SGMODL/ JPATH,JMECH,JMODL,JDIFF,JFRAM,JVDAMP,JCLOOP,JGENX
      TYPE LOGICAL SW,SINU,OBRLZ
      DIMENSION TRAN(5,5,10),F(5,5),GEN(6,10),X(6),VAS(3),ACC(3),WAS(3),
     1WDAS(3),ARM(3),SW(10),THET(3)
      DATA F,RADIUS/25'0.,2.0926E+07/
C
C     COMPUTE SHIPS MOTION DATA
C
      DTINTG = SQRT(DTINTA/JRXGEN)
      JPDM = 0
      IF (.NOT.JSTART) JPDM = JPDN
      JPDN = JGENX
      IF (JPDM.EQ.JPDN) RETURN
      IF (JPDN.GE.6.OR.JPDN.LT.0) CALL ERROR1(10)
      DO 1 I=1,3
      ARM(I) = SEG(J,I+6)
    1 CONTINUE
      DO 2 I=1,10
      SW(I) = .FALSE.
    2 CONTINUE
      SINU = .FALSE.
      IF (JPDN.EQ.0) RETURN
      IF (JPDN.EQ.2.OR.JPDN.EQ.3) GO TO 4
      SINU = .TRUE.
      IF (JPDM.EQ.1.OR.JPDM.GE.4) GO TO 3
      TREF = TS
      PSINU = RX(11,1)
      WSINU = RX(11,2)
    3 IF (JPDN.EQ.1) RETURN
    4 IF (JPDN.EQ.3.OR.JPDN.EQ.5) GO TO 6
      DO 5 I=1,5
      IF (MDT(I).NE.0) SW(I) = .TRUE.
    5 CONTINUE
      NGENF = 5
      GO TO 8
    6 NGENF = 10
      DO 7 I=1,10
      IF (MDT(I).NE.0) SW(I) = .TRUE.
      IF ((I.EQ.6.OR.I.EQ.7).AND..NOT.SW(5)) SW(I) = .FALSE.
    7 CONTINUE
    8 NGENS = 1
      IF (JPDN.GE.4) JPDN = JPDN - 2
      IF (JPDM.GE.4) JPDM = JPDM - 2
      IF (JPDN.EQ.2.AND.JPDM.EQ.3) RETURN
      IF (JPDM.NE.2.OR.JPDN.NE.3) GO TO 9
      NGENS = 8
      IF (SW(5)) NGENS = 5
    9 DO 10 I=1,4
      F(I,I+1) = DTINTA/JRXGEN
   10 CONTINUE
      DO 20 I=NGENS,NGENF
      IF (.NOT.SW(I)) GO TO 20
      DO 11 K=1,5
      GEN(K,I) = 0.
      F(5,K) = -RX(I,K)*DTINTA/JRXGEN
   11 CONTINUE
      CALL MATSER(TRAN(1,1,I),F,S,4,5,5,5,5)
   20 CONTINUE
      DO 30 I=NGENS,NGENF
      IF (I.EQ.6.OR.I.EQ.7) GO TO 30
      IF (.NOT.SW(I)) GO TO 30
      MX = MDT(I)
      DO 25 K=1,MX
      CALL RANSS(KK,U)
      CALL MATMOV(X,GEN(1,I),5,1,5,5)
      GEN(6,I) = U*RX(I,9)*DTINTG
      X(5) = X(5) + GEN(6,I)
      CALL MATMPY(GEN(1,I),TRAN(1,1,I),X,5,5,1,5,5,5)
      IF (I.NE.5) GO TO 25
      IF (.NOT.SW(6)) GO TO 21
      CALL MATMOV(X,GEN(1,6),5,1,5,5)
      GEN(6,6) = U*RX(6,9)*DTINTG
      X(5) = X(5) + GEN(6,6)
      CALL MATMPY(GEN(1,6),TRAN(1,1,6),X,5,5,1,5,5,5)
   21 IF (.NOT.SW(7)) GO TO 25
      CALL MATMOV(X,GEN(1,7),5,1,5,5)
      GEN(6,7) = U*RX(7,9)*DTINTG
      X(5) = X(5) + GEN(6,7)
      CALL MATMPY(GEN(1,7),TRAN(1,1,7),X,5,5,1,5,5,5)
   25 CONTINUE
   30 CONTINUE
      OBRLZ = .FALSE.
      DO 40 K=10,15
      IOB = JSEG(J,K)
      IOBT = KOBS(IOB)
      IF (IOBT.EQ.21) OBRLZ = .TRUE.
   40 CONTINUE
      IF (.NOT.OBRLZ) GO TO 50
      IF (J.EQ.JSTAR) GO TO 45
      DO 41 K=10,15
      IOB = JSEG(J-1,K)
      IOBT = KOBS(IOB)
      IF (IOBT.EQ.21) GO TO 50
   41 CONTINUE
   45 CALL SEPAR(VAS,ACC,WAS,WDAS,THET,GEN)
      IF (SINU) GO TO 47
      THA = PSII(3)
      GO TO 48
   47 VTOT = SQRT(VT(1)**2+VT(2)**2)
      THA = PSII(3) + ATAN( PSINU*WSINU/VTOT)
   48 DO 46 I=1,3
      THI(I) = THET(I)
   46 CONTINUE
      GO TO 50
C
      ENTRY VECHMO
C
      DO 100 ICOUNT=1,JRXGEN
      DO 100 I=1,10
      IF (.NOT.SW(I)) GO TO 100
      CALL MATMOV(X,GEN(1,I),5,1,5,5)
      IF (I.EQ.6.OR.I.EQ.7) GO TO 101
      CALL RANSS(KK,U)
  101 GEN(6,I) = U*RX(I,9)*DTINTG
      X(5) = X(5) + GEN(6,I)
      CALL MATMPY(GEN(1,I),TRAN(1,1,I),X,5,5,1,5,5,5)
  100 CONTINUE
      CALL SEPAR(VAS,ACC,WAS,WDAS,THET,GEN)
   50 THB = PSI(3)
      DO 107 I=1,3
      IF (.NOT.OBRLZ) THI(I) = WAS(I)
      TH(I) = THET(I)
  107 CONTINUE
      CALL CROSS(X,WAS,ARM)
      DO 102 I=1,3
      VAS(I) = VAS(I) + X(I)
  102 CONTINUE
      CALL CROSS(X(4),WAS,X)
      CALL CROSS(X,WDAS,ARM)
      DO 103 I=1,3
      ACC(I) = ACC(I) + X(I) + X(I+3)
  103 CONTINUE
      IF (SINU) GO TO 108
      VS = 0.
      AS = 0.
      GO TO 109
  108 THX = WSINU*(T-TREF)
      VS = WSINU*COS(THX)*PSINU
      AS = -WSINU**2*SIN(THX)*PSINU
  109 THB = PSI(3) + ATAN( VS/VTOT)
      CA = COS(PSI(3))
      SA = SIN(PSI(3))
      V( 1) = CA*VAS(1) - SA*VAS(2) - SA*VS
      V( 2) = SA*VAS(1) + CA*VAS(2) + CA*VS
      A( 1) = CA*ACC(1) - SA*ACC(2) + AT(1) - SA*AS
      A( 2) = SA*ACC(1) + CA*ACC(2) + AT(2) + CA*AS
      V( 3) = VAS(3) + VT(3)
      A( 3) = ACC(3) + AT(3)
      W( 1) = WT(1) -  V(2) /RADIUS
      W( 2) = WT(2) +  V(1) /RADIUS
      V( 2) =  V(2) + VT(2)
      V( 1) =  V(1) + VT(1)
      W( 3) = WT(3)
      CH = COS(TH(3))
      SH = SIN(TH(3))
      CP = COS(TH(2))
      SP = SIN(TH(2))
      CR = COS(TH(1))
      SR = SIN(TH(1))
      F(1,1) = CH*CP
      F(1,2) = CH*SP*SR - SH*CR
      F(1,3) = CH*SP*CR + SH*SR
      F(2,1) = SH*CP
      F(2,2) = SH*SP*SR + CH*CR
      F(2,3) = SH*SP*CR - CH*SR
      F(3,1) = -SP
      F(3,2) = CP*SR
      F(3,3) = CP*CR
      CALL MATMPY(TSB,TSBT,F,3,3,3,3,3,5)
      DO 105 I=1,3
      WB(I) = WBT(I) + WAS(I)
  105 CONTINUE
      IF (JDT.EQ.JIDT) GO TO 120
      IF (JDT.NE.JFDT) GO TO 111
      DO 112 I=1,3
      VF(I) = V(I)
  112 CONTINUE
  111 IF (NRXO.EQ.0) GO TO 104
      CALL CKPAG4
      PRINT 110,((V(I),A(I),VAS(I),ACC(I),THET(I),WAS(I)),I=1,3)
  110 FORMAT (1H0,14X,2HX ,6E12.4/15X,2HY ,6E12.4/15X,2HZ ,6E12.4)
  104 RETURN
  120 DO 121 I=1,3
      VI(I) = V(I)
  121 CONTINUE
      RETURN
      END
C
      SUBROUTINE START
      COMMON /RESTR/ RESTAR,NRLEVL,NRPASS
      LOGICAL RESTAR
      COMMON /PASS/ FILT,VECTOR,BKDOWN,RSS
      LOGICAL FILT,VECTOR,BKDOWN,RSS
      COMMON /CONTRL/ NTYPE,JSTAR,JDTI,JSTOP,JDTF
      COMMON /DIMENS/ NF,NS,NSF,NDYN,NCTRL,NRA, NG,LINK(50)
      COMMON /LOGICL/ FILTAP,JSTART,VCHAN,LRESET
        LOGICAL FILTAP,JSTART,VCHAN,LRESET
      COMMON /COUNTR/ J,JDT,JIN,JIDT,JFDT,NERR
      COMMON /ENDPTS/ VI(3),VF(3),VFP(3),WI(3),WF(3),PI(3),PF(3),PSII(3)
     1,PSIF(3),PSIP(3)
      COMMON /TIMER/ T,TS,TF,DT,DTINTG,TBASE
      COMMON /INIT/ LATO,LONGO,PSIO,ALPHAO,VELO,ALTO,VZO
      COMMON /RXGEN/ RX(11,10),MDT(11),RANIN
      COMMON /STATE/ IST(50,5),ST(50,4),LOGIC(50,25),LABEL(50)
      COMMON /SEGMNT/ JSEG(25,25),SEG(25,20),SEGLAB(25,6)
      COMMON /SGMODL/ JPATH,JMECH,JMODL,JDIFF,JFRAM,JVDAMP,JCLOOP,JGENX
      TYPE REAL LATO,LONGO
      DATA RAD/57.2958/
C
C     SET UP FOR ONE PASS THROUGH PROBLEM
C
      IF (RESTAR) GO TO 10
      FILT = NTYPE.EQ.0
      BKDOWN = NTYPE.EQ.1
      VECTOR = NTYPE.EQ.2
      RSS = NTYPE.EQ.4
      IF (FILT) NERR = 0
      IF (.NOT.FILT.AND.NTYPE.NE.4) NERR = NERR + 1
      CALL ZRSS
      CALL ZCOEFF
      IF (JSTAR.LE.0) JSTAR = 1
      JFRAM = JSEG(JSTAR)/100
      T  = TBASE
      TF = TBASE
      J = JSTAR
      NSF = NS
      IF (FILT) NSF = NF
      CALL ORDER
      IF (NDYN.GT.25.AND..NOT.VECTOR.OR.NDYN.GT.50.AND.VECTOR) CALL ERRO
     1R1(3)
      IF (.NOT.FILT.AND.FILTAP) CALL GETTAP
      PF(1) = LATO/RAD
      PF(2) = LONGO/RAD
      PF(3) = ALTO
      PSIF(1) = PSIO/RAD
      PSIF(2) = ALPHAO/RAD
      PSIF(3) = (PSIO - ALPHAO)/RAD
      VF(1) = VELO*COS( PSIF(3))
      VF(2) = VELO*SIN( PSIF(3))
      VF(3) = VZO
      CALL OMEGA(WF,PF,VF,PSIF)
      NRA = NDYN
      CALL QCOUNT
      IF (.NOT.VECTOR) RETURN
      NCTRA = NCTRL + 1
      CALL MATMAX(NRA,IST(NCTRA,4),NDYN-NCTRL,1,50)
      NRA = NRA + NCTRL
      RETURN
C
   10 NSF = NS
      IF (FILT) NSF = NF
      CALL ORDER
      IF (NDYN.GT.25.AND..NOT.VECTOR.OR.NDYN.GT.50.AND.VECTOR) CALL ERRO
     1R1(3)
      NRA = NDYN
      NCTRA = NCTRL + 1
      IF (.NOT.VECTOR) GO TO 11
      CALL MATMAX(NRA,IST(NCTRA,4),NDYN-NCTRL,1,50)
      NRA = NRA + NCTRL
   11 IF (NRLEVL.EQ.0) RETURN
      CALL RESTOR
      CALL DATARS
      RETURN
      END
C
      SUBROUTINE STLABL(I)
      COMMON /LABEL/ XLABEL(6),SLABEL(6),SGLABL(6),OL(2,10)
      COMMON /STATE/ IST(50,5),ST(50,4),LOGIC(50,25),LABEL(50)
      COMMON /DIMENS/ NF,NS,NSF,NDYN,NCTRL,NRA, NG,LINK(50)
      DIMENSION STLBL(40),STLBA(8),STLBC(8),TY(2,8)
      DIMENSION STLBD(8),STLBE(8),STLBF(8),STLBG(8),STLBH(8)
C
      DATA STLBL/10HX POSITION,10HY POSITION,10HX VELOCITY,10HY VELOCITY
     1,10HPHI-X TILT,10HPHI-Y TILT,7HAZIMUTH,10HZ VELOCITY,10HZ POSITION
     2,10HZ POS INTG,10HX VEL INTG,10HY VEL INTG,10HZ VEL INTG,10HX GYRO
     3 DR.,10HY GYRO DR.,10HZ GYRO DR.,10HX ACC BIAS,10HY ACC BIAS,10HZ
     4ACC BIAS,9HDUMMY ST.,10HX REF VEL.,10HY REF VEL.,10HR REF VEL.,10H
     5L REF VEL.,10HREF VEL SF,9HBORESIGHT,8HR FLUCT.,8HL FLUCT.,9HALT E
     6RROR,8HALT S.F.,10HN POS REF.,10HW POS REF.,9HDUMMY ST.,9HDUMMY ST
     7.,9HDUMMY ST.,10HCL XV REF.,10HCL YV REF.,9HDUMMY ST./
      DATA STLBA/2H1.,2HEX,2HEY,2HEZ,2HBX,2HBY,2HBZ,2H1./
      DATA STLBC/2H1.,2HWX,2HWY,2HWZ,2HAX,2HAY,2HAZ,2HAV/
      DATA STLBD/2H1.,2HER,2HEP,2HEY,2HBR,2HBP,2HBY,2H1./
      DATA STLBE/2H1.,2HWR,2HWP,2HWY,2HAR,2HAP,2HAY,2H1./
      DATA STLBF/2H1.,2HEA,2HEB,2HEC,2HED,2HEE,2HEF,2H1./
      DATA STLBG/2H1.,2HWI,2HWO,2HWS,2HAI,2HAO,2HAS,2H1./
      DATA STLBH/2H1.,2HBA,2HBB,2HBC,2HBD,2HBE,2HBF,2H1./
      DATA BL,SECO,RPS/1H ,3HSEC,3HRPS/
      DATA TA,WN,ZETA/4H TA=,4H WN=,4H ZE=/
      DATA TY/10HBIAS ERROR,1H ,10HRANDOM EXP,1H ,10HRANDOM WAL,1HK,10HW
     1HITE NOIS,1HE,10HNARROW BAN,1HD,10HEXPONENTIA,1HL,10HSINUSOIDAL,1H
     2 ,10HTABULATED ,1H /
C
C     GENERATE STATE LABEL IDENTIFIER
C
      IF (NS.NE.0) GO TO 3
      ENCODE (60,4,SLABEL)
    4 FORMAT (22X,'MEASUREMENT NOISE',21X)
      RETURN
    3 ID = MOD(IST(I),1000)
      IG = IST(I)/1000 + 1
      IC = ID/100
      IF (IC.NE.0) GO TO 10
      IF (ID.LE.0.OR.ID.GT.38) ID = 38
      STCODE = STLBL(ID)
      GO TO 11
   10 IA = MOD(ID,10) + 1
      IB = (ID - 100*IC)/10 + 1
      IC = IC + 1
      IF (IA.GT.8) IA = 1
      IF (IB.GT.8) IB = 1
      IF (IC.GT.7) IC = 1
      GO TO (21,22,23,24),IG
   21 ENCODE (10,2,STCODE) STLBA(IC),STLBC(IB),STLBC(IA)
    2 FORMAT (A2,3H=K',A2,1H',A2)
      GO TO 11
   22 ENCODE (10,2,STCODE) STLBD(IC),STLBE(IB),STLBE(IA)
      GO TO 11
   23 ENCODE (10,2,STCODE) STLBF(IC),STLBG(IB),STLBG(IA)
      GO TO 11
   24 ENCODE (10,2,STCODE) STLBH(IC),STLBG(IB),STLBG(IA)
   11 SIGMA = ST(I)
      IZ = I
      IF (.NOT.(I.GT.LINK(1).AND.LINK(I).EQ.0)) GO TO 13
      DO 12 K=1,10
      IZ = IZ - 1
      IF (LINK(IZ).NE.0) GO TO 14
   12 CONTINUE
      CALL ERROR1(18)
   14 TLBL = ZETA
      T = ST(I,3)
      GO TO 15
   13 IX = IST(IZ,2) + 1
      IF (IX.GT.8) IX = 8
      T = ST(I,3)
      GO TO (5,6,6,6,7,6,7,5),IX
    5 TLBL = BL
   15 SEC = BL
      GO TO 8
    6 SEC = SECO
      TLBL = TA
      GO TO 8
    7 SEC = RPS
      TLBL = WN
    8 ENCODE (60,1,SLABEL) STCODE,SIGMA,LABEL(I),TY(1,IX),TY(2,IX),TLBL,
     1T,SEC
    1 FORMAT (A10,E12.3,1H ,A7,1H,,A10,A1,A4,E11.3,A3)
      RETURN
      END
C
      SUBROUTINE STRAPD
      COMMON /DYNAM/ W(3),A(3),V(3),P(3),PSI(3),WB(3),WBD(3),TSB(3,3)
C
C        CONPUTE TRANSITION MATRIX FROM STRAPDOWN TO SYSTEM COORDINATES
C
      S = SIN(PSI(3))
      C = COS(PSI(3))
    1 VR = SQRT(V(1)**2 + V(2)**2)
      VT = SQRT(VR**2 + V(3)**2)
      IF (VT.LE.0.) GO TO 2
      SD = -V(3)/VT
      CD = VR/VT
      WB(1) = WB(3) = 0.0
      IF (VR.EQ.0.) GO TO 3
      WB(2) = (-VR*A(3) + (V(1)*V(3)*A(1) + V(2)*V(3)*A(2))/VR)/VT**2
      GO TO 4
    3 WB(2) = V(3)*(A(1)*COS(PSI(3)) + A(2)*SIN(PSI(3)))/VT**2
    4 TSB(1,1) = C*CD
      TSB(2,1) = S*CD
      TSB(3,1) = -SD
      TSB(1,2) = -S
      TSB(2,2) = C
      TSB(3,2) = 0.
      TSB(1,3) = C*SD
      TSB(2,3) = S*SD
      TSB(3,3) = CD
      RETURN
    2 TSB(3,3) = 1.0
      TSB(1,1) = TSB(2,2) = C
      TSB(1,2) = -S
      TSB(2,1) = S
      TSB(1,3) = TSB(2,3) = TSB(3,1) = TSB(3,2) = 0.
      WB(1) = WB(2) = WB(3) = 0.0
      RETURN
      END
      SUBROUTINE STATIN
      COMMON /COUNTR/ J,JDT,JIN,JIDT,JFDT,NERR
      COMMON /STATE/ IST(50,5),ST(50,4),LOGIC(50,25),LABEL(50)
      LOGICAL LOGIC
      COMMON /QRMAT/ Q(25,25),R(25,25),S(25,25,6)
      COMMON /TIMER/ T,TS,TF,DT,DTINTG,TBASE
      COMMON /DIMENS/ NF,NS,NSF,NDYN,NCTRL,NRA, NG,LINK(50)
      COMMON /LOGICL/ FILTAP,JSTART,VCHAN,LRESET
      LOGICAL FILTAP,JSTART,VCHAN,LRESET
      TYPE LOGICAL LOGN,LOGM
C
C     STATE TYPE = 0 , BIAS STATE
C                = 5 , DETERMINISTIC EXPONENTIAL
C                = 6 , DETERMINISTIC SINUSOID
C                = 7 , TABULATED ERROR SOURCE
C
      IF (.NOT.JSTART) GO TO 1
      CALL ZERO(Q,NRA,NDYN,25)
    1 DO 2 I=1,NDYN
      IT = IST(I,2)
      IF (IT.GE.1.AND.IT.LE.4) GO TO 2
      LOGN = LOGIC(I,J)
      LOGM = .FALSE.
      IF (.NOT.JSTART) LOGM = LOGIC(I,J-1)
      IF (LOGM.AND.LOGN.OR..NOT.(LOGM.OR.LOGN)) GO TO 2
      IXX = LINK(I)
      IF (I.LE.LINK(1)) IXX = 1
      IF (IXX.EQ.0.AND.I.GT.LINK(1)) GO TO 2
      IX = I
      IF (I.GT.NCTRL) IX = NCTRL + 1
      IF (LOGN.AND..NOT.LOGM) GO TO 3
      DO 10 K=1,IXX
      DO 10 L=1,IXX
      Q(IX+K-1,I+L-1) = 0.
   10 CONTINUE
      GO TO 2
    3 IF (IT.EQ.7) GO TO 7
      DO 5 K=1,IXX
      KX = I + K - 1
      KXX = IX + K - 1
      Q(KXX,KX) = ST(KX)*ST(KX,2)
    5 CONTINUE
      GO TO 2
    7 CALL TABLE(X,T,IST(I,3),1.)
      Q(IX,I) = X*ST(I,2)
    2 CONTINUE
      RETURN
      END
C
      SUBROUTINE SYSOUT
      COMMON /COUNTR/ J,JDT,JIN,JIDT,JFDT,NERR
      COMMON /PASS/ FILT,VECTOR,BKDOWN,RSSSS
      LOGICAL FILT,VECTOR,BKDOWN,RSSSS
      COMMON /LOGICL/ FILTAP,JSTART,VCHAN,LRESET
      LOGICAL FILTAP,JSTART,VCHAN,LRESET
      COMMON /OUTPT/ NINERT,NCOV,NTRN,NRXO,NERS,NSAVE(6),SAVO,FRSS,PRMIN
      COMMON /DIMENS/ NF,NS,NSF,NDYN,NCTRL,NRA, NG,LINK(50)
      COMMON /RSS/ RSSB(25,25),RSSA(25,25),RSSO(12,4)
      COMMON /QRMAT/ Q(25,25),R(25,25),B(25,25),C(25,25),RSS(25,25),
     1RST(25,25),RSX(25,25),RSY(25,25)
      LOGICAL FRSS,PRMIN
C
      PER = 0.
      IF (FILT) GO TO 20
      CALL SETRSS
      IF (FRSS.OR.NERR.GT.1) GO TO 6
      CALL ZERO(RSSB,25,25,25)
      IF (LRESET) CALL ZERO(RSSA,25,25,25)
    6 IF (VECTOR) GO TO 7
      IF (RSSSS) GO TO 11
      CALL MATMOV(RSS,Q,NCTRL,NCTRL,25,25)
      IF (LRESET) CALL MATMOV(RST,B,NCTRL,NCTRL,25,25)
      GO TO 10
   11 CALL MATMOV (RSS,RSSB,NCTRL,NCTRL,25,25)
      CALL MATMOV(Q,RSSB,NCTRL,NCTRL,25,25)
      IF (LRESET) CALL MATMOV(RST,RSSA,NCTRL,NCTRL,25,25)
      IF (LRESET) CALL MATMOV(B,RSSA,NCTRL,NCTRL,25,25)
      GO TO 25
    7 CALL ZERO(RSS,25,25,25)
      DO 8 I=1,NDYN
      CALL AAT(RSX,Q(1,I),NCTRL,1,25,25)
      CALL MATADD(RSS,RSS,RSX,NCTRL,NCTRL,25,25,25)
    8 CONTINUE
      IF (.NOT.LRESET) GO TO 10
      CALL ZERO(RST,25,25,25)
      CALL ZERO(RSY,25,25,25)
      DO 9 I=1,NDYN
      CALL AAT(RSY,B(1,I),NCTRL,1,25,25)
      CALL MATADD(RST,RST,RSY,NCTRL,NCTRL,25,25,25)
    9 CONTINUE
   10 CALL MATADD(RSSB,RSSB,RSS,NCTRL,NCTRL,25,25,25)
      IF (LRESET) CALL MATADD(RSSA,RSSA,RST,NCTRL,NCTRL,25,25,25)
      GO TO 25
   20 CALL MATMOV(RSS,Q,NCTRL,NCTRL,25,25)
      IF (LRESET) CALL MATMOV(RST,B,NCTRL,NCTRL,25,25)
      IF (FRSS) GO TO 21
      CALL ZERO(RSSB,25,25,25)
      IF (LRESET) CALL ZERO(RSSA,25,25,25)
      GO TO 25
   21 CALL MATMOV(RSSB,Q,NCTRL,NCTRL,25,25)
      IF (LRESET) CALL MATMOV(RSSA,B,NCTRL,NCTRL,25,25)
   25 CALL SAVRSS
      IF (LRESET) GO TO 26
      CALL SETOUT(RSSO,RSS,PER)
      CALL SETOUT(RSSO(1,2),RSSB,PER)
      RETURN
   26 CALL SETOUT(RSSO,RST,PER)
      CALL SETOUT(RSSO(1,2),RSS,PER)
      CALL SETOUT(RSSO(1,3),RSSA,PER)
      CALL SETOUT(RSSO(1,4),RSSB,PER)
      RETURN
      END
C
      SUBROUTINE SETOUT(RSSO,RSS,PER)
      COMMON /PERT/  W(3),A(3),V(3),P(3),PSI(3),WS(3),WBD(3),TSB(3,3)
      LOGICAL FILTAP,JSTART,VCHAN,LRESET
      COMMON /LOGICL/ FILTAP,JSTART,VCHAN,LRESET
      DIMENSION RSSO(12),RSS(25,25)
      DATA (RADSEC=206264.88)
C
C     TRANSFORM OUTPUT TO DESIRED FORM
C
      CALL CEPPOS(RSSO,RSS,RSS(2,2),RSS(1,2),PER)
      IF (VCHAN)     GO TO 1
      RSSO(4) = 0.
      RSSO(8) = 0.
      GO TO 2
    1 RSSO(4) = SQRT(RSS(9,9))
      RSSO(8) = SQRT(RSS(8,8))
    2 RSSO(2) = SQRT(RSS)
      RSSO(3) = SQRT(RSS(2,2))
      RSSO(5) = SQRT(RSS(3,3) + RSS(4,4))
      RSSO(6) = SQRT(RSS(3,3))
      RSSO(7) = SQRT(RSS(4,4))
      RSSO(9) = SQRT(RSS(5,5))
      RSSO(10)= SQRT(RSS(6,6))
      RSSO(11)= SQRT(RSS(7,7))
      TH = TAN( P(1) )/2.0926E+07
      S = SIN(PSI(2))*TH
      C = COS(PSI(2))*TH
      RSSO(12)= SQRT(RSS(7,7) + RSS(1,1)*S*S + RSS(2,2)*C*C - S*RSS(1,7)
     1 - C'RSS(2,7) + C'S'RSS(1,2))
      DO 31 I=9,12
      RSSO(I) = RSSO(I)*RADSEC
   31 CONTINUE
      RETURN
      END
C
      SUBROUTINE TABLE(X,T,L,SF)
      COMMON /LIST/ XLIST(50,15),LC(15)
C
C     LC(L) = 1 ,TBASE,DT SPECIFIED ,ZERO ORDER INTERPOLATION.
C     LC(L) = 2 ,TBASE,DT SPECIFIED ,FIRST ORDER INTERPOLATION.
C     LC(L) = 3 ,TBASE,DT SPECIFIED ,SECOND ORDER INTERPOLATION.
C     LC(L) = 4 ,TIME(J),DATA(J) SPECIFIED ,ZERO ORDER INTERPOLATION.
C     LC(L) = 5 ,TIME(J),DATA(J) SPECIFIED ,FIRST ORDER INTERPOLATION.
C
C     IF THE TIME INPUT IS OUTSIDE OF THE DEFINED RANGE  AN X VALUE OF
C     ZERO IS RETURNED
C
      I = LC(L)
      IF (I.GE.6.OR.I.LE.0) CALL ERROR1(8)
      IF (I.GT.3) GO TO 400
      DT = XLIST(2,L)
      TBASE = XLIST(1,L)
      IF (T.GE.TBASE.AND.T.LT.(TBASE+47.'DT)) GO TO 100
  101 X = 0.
      RETURN
  100 N = (T-TBASE)/DT + 3.
      IF (I-2) 1,2,3
    1 X = XLIST(N,L)*SF
      RETURN
    2 C = T-TBASE-(N-3)*DT
      D = DT - C
      X = SF*(D*XLIST(N,L) + C*XLIST(N+1,L))/(C+D)
      RETURN
    3 N = 2*((N+1)/2)
      TA =(T - TBASE - (N-3)*DT)/DT
      X = SF*(XLIST(N,L)*(1.-TA*TA) + (TA/2.)*(XLIST(N-1,L)*(TA-1.)+XLIS
     1T(N+1,L)'(TA+1.)))
      RETURN
  400 IF (T.LE.XLIST(1,L)) GO TO 101
      DO 401 J=1,49,2
      IF (T.LE.XLIST(J,L)) GO TO 402
  401 CONTINUE
      GO TO 101
  402 IF (I.EQ.5) GO TO 5
      X = SF*XLIST(J-1,L)
      RETURN
    5 C = T - XLIST(J-2,L)
      D = XLIST(J,L) - T
      X = SF*(XLIST(J-1,L)*D + XLIST(J+1,L)*C)/(C+D)
      RETURN
      END
C
      SUBROUTINE TNPATH
      COMMON /COUNTR/ J,JDT,JIN,JIDT,JFDT,NERR
      COMMON /SGMODL/ JPATH,JMECH,JMODL,JDIFF,JFRAM,JVDAMP,JCLOOP,JGENX
      COMMON /TIMER/ TIME,TIMES,TIMEF,DT,DTINTG,TBASE
      COMMON /SGDTS/ JDTS,J1ST,JPDT,J1SAV,JSAVDT,JINT,JRXGEN
      COMMON /SEGMNT/ JSEG(25,25),SEG(25,20),SEGLAB(25,6)
      COMMON /ENDPTS/ VI(3),VF(3),VFP(3),WI(3),WF(3),PI(3),PF(3),PSII(3)
     1,PSIF(3),PSIP(3)
      COMMON /DYNAM/ W(3),A(3),V(3),P(3),PSI(3),WB(3),WBD(3),TSB(3,3)
      COMMON /SGDATA/ LISTH,LISTV,JRESTR,JDUM1,JDUM2
      COMMON /OBRLZ/ THA,THI(3),THB,THF(3),OBRLZ
      DIMENSION PC(3),PSIC(3),PSID(3)
      DATA RE,RAD,RTURN/2.0926E+07,57.2958,1.570796327/
C
C     CIRCULAR TURN PATH. LOCATES END POINTS AND COMPUTES CONSTANTS TO
C     BE USED IN PIECEWISE CONSTANT DIFFERENTIAL EQUATION.
C     PATH CODE = 4, VELOCITY AND TURNING RADIUS SPECIFIED.
C               = 5, VELOCITY AND TURNING RATE SPECIFIED.
C               = 6, VELOCITY AND TOTAL ANGLE SPECIFIED.
C               = 7, VELOCITY AND TOTAL ANGLE SPECIFIED,60DEG INCREMENTS
C
      VS = SEG(J)
      IF (JPATH.EQ.7) CALL ERROR1(20)
      IF (JPATH-5) 4,5,6
    4 R = SEG(J,4)*6080.
      IF (R.LE.0.) CALL ERROR1(6)
      TH = R/RE
      WP = VS/(RE*TAN( TH))
      WC = WP/COS(TH)
      GO TO 1
    5 WP = SEG(J,4)/RAD
      IF (ABS(WP).LE.1.E-07) CALL ERROR1(7)
      TH = ATAN(VS/(WP*RE))
      WC = WP/COS(TH)
      GO TO 2
    6 WC = SEG(J,4)/(JDTS*DT*RAD)
      TH = ASIN(VS/(WC*RE))
      WP = WC*COS(TH)
    2 R = RE*TH
    1 PSII(1) = PSIP(1) + SEG(J,3)/RAD
      PSII(2) = PSIP(2)
      PSII(3) = PSII(1) - PSII(2)
      VI(1) = VS*COS(PSII(3))
      VI(2) = VS*SIN(PSII(3))
      PSII(1) = PSII(1) + RTURN
      CALL LOCATE(PC,PSIC,PI,PSII,R)
      PSII(1) = PSII(1) - RTURN
      PSIC(3) = PSII(3) + RTURN
      PSIC(2) = PSIC(1) - PSIC(3)
      T = JDTS*DT
      TIMEF = TIMES + T
      PSID(1) = 2*RTURN + WC*T + PSIC(1)
      CALL LOCATE(PF,PSIF,PC,PSID,R)
   12 PSIF(1) = PSIF(1) + RTURN
      PSIF(3) = PSIC(3) + 3.*RTURN + WC*T
      PSIF(2) = PSIF(1) - PSIF(3)
      VF(1) = VS*COS(PSIF(3))
      VF(2) = VS*SIN(PSIF(3))
      CALL OMEGA(WI,PI,VI,PSII)
      CALL OMEGA(WF,PF,VF,PSIF)
      JX = JDIFF + 1
      GO TO (100,300,500,500,500),JX
  100 PSID(1) = 2.*RTURN + WC*SEG(J,5) + PSIC(1)
      CALL LOCATE(P,PSI,PC,PSID,R)
      PSI(1) = PSI(1) + RTURN
      PSI(3) = PSIC(3) + 3.*RTURN + WC*SEG(J,5)
      PSI(2) = PSI(1) - PSI(3)
      V(1) = VS*COS(PSI(3))
      V(2) = VS*SIN(PSI(3))
  112 A(1) = -WP*V(2)
      A(2) = WP*V(1)
      CALL OMEGA(W,P,V,PSI)
      RETURN
  300 PSID(1) = 2.*RTURN + WC*DTINTG + PSIC(1)
      DO 301 I=1,3
      V(I) = A(I) = 0.
  301 CONTINUE
      CALL LOCATE(P,PSI,PC,PSID,R)
      PSI(1) = PSI(1) + RTURN
      PSI(3) = PSIC(3) + 3.*RTURN + WC*SEG(J,5)
      PSI(2) = PSI(1) - PSI(3)
      CALL OMEGA(W,P,V,PSI)
      GO TO 10
C
      ENTRY RESTTN
C
      TIME = TIMES
  500 DO 501 I=1,3
      W(I) = WI(I)
      PSI(I) = PSII(I)
      P(I) = PI(I)
      V(I) = VI(I)
  501 CONTINUE
      A(1) = -WP*V(2)
      A(2) = WP*V(1)
      RETURN
C
      ENTRY PATHTN
C
      TX = TIME - TIMES
      IF (JDIFF.LE.0) GO TO 30
      IF (JDIFF.LE.1) GO TO 20
      PSID(1) = PSIC(1) + 2.*RTURN + WC*TX
      CALL LOCATE(P,PSI,PC,PSID,R)
      PSI(1) = PSI(1) + RTURN
  512 PSI(3) = PSIC(3) + 3.*RTURN + WC*TX
      PSI(2) = PSI(1) - PSI(3)
      V(1) = VS*COS(PSI(3))
      V(2) = VS*SIN(PSI(3))
      A(1) = -WP*V(2)
      A(2) = WP*V(1)
      CALL OMEGA(W,P,V,PSI)
      THB = PSI(3)
      RETURN
   10 DO 11 I=1,3
      V(I) = VI(I)
      PSID(I) = W(I)
   11 CONTINUE
      A(3) = 0.
      A(1) = -WP*V(2)
      A(2) = WP*V(1)
      GO TO 21
   20 TH = WC*(TIME - TIMES)
      C = COS(TH)
      S = SIN(TH)
      V(1) =  VI(1)*C - VI(2)*S
      V(2) =  VI(1)*S + VI(2)*C
      A(1) = -WP*V(2)
      A(2) = WP*V(1)
      PSI(1) = PSII(1) + TH
      PSI(3) = PSII(3) + TH
      THB = PSI(3)
   21 W(1) = PSID(1) - V(2)/RE
      W(2) = PSID(2) + V(1)/RE
      W(3) = PSID(3)
      RETURN
   30 TH = WC*(TIME-TIMES)
      PSI(1) = PSII(1) + TH
      PSI(3) = THB = PSII(3) + TH
      RETURN
      END
C
      SUBROUTINE TRNMAT
      COMMON /SEGMNT/ JSEG(25,25),SEG(25,20),SEGLAB(25,6)
      COMMON /COUNTR/ J,JDT,JIN,JIDT,JFDT,NERR
      COMMON /DIMENS/ NF,NS,NSF,NDYN,NCTRL,NRA, NG,LINK(50)
      COMMON /FGMAT/ F(25,25),G(25,25),T(25,25),A(25,25)
      COMMON /QRMAT/ Q(25,25),R(25,25),C(25,25),D(25,25),E(25,25),
     1B(25,25),ARESET(25,50)
      COMMON /STATE/ IST(50,5),ST(50,4),LOGIC(50,25),LABEL(50)
      COMMON /TIMER/ TIME,TIMES,TIMEF,DT,DTINTG,TBASE
      COMMON /PASS/ FILT,VECTOR,BKDOWN,RSS
      LOGICAL FILT,VECTOR,BKDOWN,RSS
      COMMON /OUTPT/ NINERT,NCOV,NTRN,NRXO,NERS,NSAVE(6),SAVO,FRSS,PRMIN
      COMMON /SGMODL/ JPATH,JMECH,JMODL,JDIFF,JFRAM,JVDAMP,JCLOOP,JGENX
      DATA RATIO/1.E-10/
C
C     COMPUTE TRANSITION AND NOISE MATRICES
C
      IF (JDIFF.GE.1) RETURN
      DTH = SEG(J,6)
      IF (DTH.LE.0.001) CALL ERROR1(13)
      NX = 1
      TA = 2.*DT
    1 TA = TA/2.
      IF (TA.LE.DTH) GO TO 2
      NX = NX + 1
      GO TO 1
    2 MS = JMODL + 1
      NCOUP = IXX = LINK(1)
      CALL ZERO(T,NRA,NDYN,25)
      DO 3 I=1,NDYN
      IF (.NOT.VECTOR.OR.I.LE.NCTRL) GO TO 4
      LINKI = LINK(I)
      IF (LINKI.EQ.0) GO TO 6
      DO 5 K=1,LINKI
      T(NCTRL+K, K+I-1) = 1.
    5 CONTINUE
      GO TO 6
    4 T(I,I) = 1.
    6 DO 3 K=1,NRA
      E(K,I) = F(K,I)*TA
    3 CONTINUE
      CALL MATMOV(C,T,NRA,NDYN,25,25)
C
C     COMPUTE TRANSITION MATRIX. TERMINATE SERIES WHEN ABS(PHI-DEL(PHI))
C     IS LESS THAN A SPECIFIED LIMIT.IF MATRIX DOES NOT CONVERGE WITHIN
C     32 TERMS, PROBLEM IS TERMINATED.
C
      SF = 1.
      NXX = IXX + 1
      DO 10 ICOUNT=1,32
      SF = SF/ICOUNT
      IF (NDYN-NCOUP) 7,19,8
    7 CALL ERROR1(16)
    8 DO 11 I=NXX,NDYN
      LINKI = LINK(I)
      IF (LINKI.EQ.0) GO TO 11
      NA = I - 1
      NB = NA
      IF (VECTOR.AND.I.GT.NCTRL) NB = NCTRL
      DO 17 IX=1,NCOUP
      DO 17 IY=1,LINKI
      X = 0.
      DO 12 IZ=1,NCOUP
      X = X + C(IX,IZ)*E(IZ,NA+IY)
   12 CONTINUE
      DO 13 IZ=1,LINKI
      X = X + C(IX,NA+IZ)*E(NB+IZ,NA+IY)
   13 CONTINUE
      F(IX,NA+IY) = X
   17 CONTINUE
      DO 14 IX=1,LINKI
      DO 14 IY=1,LINKI
      X = 0.
      DO 15 IZ=1,LINKI
      X = X + C(NB+IX,NA+IZ)*E(NB+IZ,NA+IY)
   15 CONTINUE
      F(NB+IX,NA+IY) = X
   14 CONTINUE
   11 CONTINUE
   19 CALL MATMPY(F,C,E,NCOUP,NCOUP,NCOUP,25,25,25)
      CALL MATMOV(C,F,NRA,NDYN,25,25)
      ANORM = 0.
      DO 20 IX=1,NRA
      DO 20 IY=1,NDYN
      X = SF*(C(IX,IY))
      TX = T(IX,IY) + X
      T(IX,IY) = TX
      IF (TX.LE.1.E-36) GO TO 20
      ANORM = ANORM + ABS(X/TX)
   20 CONTINUE
      IF (ANORM.LE.RATIO) GO TO 100
   10 CONTINUE
      CALL ERROR1(14)
  100 ITRAN = ICOUNT
      IF (VECTOR ) GO TO 1000
      DO 101 IX=1,NDYN
      DO 101 IY=1,NDYN
      B(IX,IY) = R(IX,IY)*TA
      R(IX,IY) = B(IX,IY)
  101 CONTINUE
      SF = 1.
      DO 110 ICOUNT=2,32
      SF = 1./ICOUNT
      BNORM = 0.
      CALL MATMP2(C,E,B,LINK(1),NDYN,25,25,25)
      CALL MATSM2(C,NDYN,NDYN,25)
      DO 111 IX=1,NDYN
      DO 111 IY=1,NDYN
      X = C(IX,IY)*SF
      B(IX,IY) = X
      BX = R(IX,IY) + X
      R(IX,IY) = BX
      IF (BX.LE.1.E-36) GO TO 111
      BNORM = BNORM + ABS(X/BX)
  111 CONTINUE
      IF (BNORM.LE.RATIO) GO TO 1000
  110 CONTINUE
      CALL ERROR1(15)
 1000 IF (NX.EQ.1) GO TO 2000
      DO 1101 LXX=2,NX
      IF (VECTOR) GO TO 1100
      CALL ARAT(C,R,T,NDYN,NDYN,25,25,25,LINK(1))
      CALL MATADD(R,R,C,NDYN,NDYN,25,25,25)
      CALL MATMPY(C,T,T,NDYN,NDYN,NDYN,25,25,25)
      CALL MATMOV(T,C,NDYN,NDYN,25,25)
      GO TO 1101
 1100 CALL MATMP1(C,T,T)
      CALL MATMOV(T,C,NRA,NDYN,25,25)
 1101 CONTINUE
 2000 IF (NTRN.LE.0) RETURN
      CALL PAGE2
      PRINT 999,ITRAN,J
  999 FORMAT (1H0,14X,'TRANSITION MATRIX BY ROWS, EXP. SERIES CONVERGES
     1AFTER*I3* ITERATIONS*/15X*SEGMENT =*I3)
      DO 2001 I=1,NRA
      CALL CKPAG1
      PRINT 998,I,IST(I),IST(I,2),(T(I,K),K=1,NDYN)
 2001 CONTINUE
  998 FORMAT (1H0,14X,'ROW ='I3'   STCODE ='I3'   TYPE='I3/(15X,5E14.5))
      IF (VECTOR) RETURN
      CALL PAGE2
      PRINT 997,ICOUNT,J
  997 FORMAT (1H0,14X,'NOISE MATRIX BY ROWS, EXP. SERIES CONVERGES AFTER
     1*I3* ITERATIONS*/15X*SEGMENT =*I3)
      DO 2002 I=1,NDYN
      CALL CKPAG1
      PRINT 998 ,I,IST(I),IST(I,2),(R(I,K),K=1,NDYN)
 2002 CONTINUE
      RETURN
      END
C
      SUBROUTINE VTRAJ
      COMMON /SGMODL/ JPATH,JMECH,JMODL,JDIFF,JFRAM,JVDAMP,JCLOOP,JGENX
      COMMON /COUNTR/ J,JDT,JIN,JIDT,JFDT,NERR
      COMMON /SGDATA/ LISTH,LISTV,JRESTR,JDUM1,JDUM2
      COMMON /ENDPTS/ VI(3),VF(3),VFP(3),WI(3),WF(3),PI(3),PF(3),PSII(3)
     1,PSIF(3),PSIP(3)
      COMMON /SGDTS/ JDTS,J1ST,JPDT,J1SAV,JSAVDT,JINT,JRXGEN
      COMMON /SEGMNT/ JSEG(25,25),SEG(25,20),SEGLAB(25,6)
      COMMON /TIMER/ TIME,TIMES,TIMEF,DT,DTINTG,TBASE
      COMMON /DYNAM/ W(3),A(3),V(3),P(3),PSI(3),WB(3),WBD(3),TSB(3,3)
C
C        COMPUTE VERTICAL FLIGHT PROFILE
C
      JX = JDIFF + 1
      TIMEF = TIMES + DT*JDTS
      IF (LISTV.NE.0) GO TO 33
      VI(3) = VF(3) = SEG(J,18)
      PF(3) = PI(3) + VI(3)*DT*JDTS
      GO TO 100
   33 CALL TABLE(VI(3),TIMES,LISTV,1.)
      CALL TABLE(VF(3),TIMEF,LISTV,1.)
      CALL ITABLE(RA,TIMEF,TIMES,LISTV)
      PF(3) = PI(3) + RA
      DX = DT
      GO TO (70,70,80,80,80),JX
   70 TIMEY = TIMES + SEG(J,5)
      GO TO 100
C
      ENTRY VERTRS
C
   80 TIMEY = TIMES
      GO TO 100
C
      ENTRY TRAJV
C
      TIMEY = TIME
  100 DX = DTINTG
      IF (LISTV.NE.0) GO TO 113
      P(3) = PI(3) + VI(3)*(TIMEY-TIMES)
      V(3) = VI(3)
      A(3) = 0.
      RETURN
  113 CALL ITABLE(RA,TIMEY,TIMES,LISTV)
      P(3) = PI(3) + RA
      CALL TABLE (V(3),TIMEY,LISTV,1.)
      CALL TABLE(VERTIC,TIMEY-DX,LISTV,1.)
      A(3) = (V(3)-VERTIC)/DX
      RETURN
      END
      SUBROUTINE XTABLE(L,SF)
      COMMON /LIST/ XLIST(50,15),LC(15)
C
C     SCALE THE PARAMETERS IN DATA LIST L
C
      I = LC(L)
      IF (I.GE.6.OR.I.LE.0) CALL ERROR1(8)
      IF (I.GE.4) GO TO 4
      DO 1 J=3,50
      XLIST(J,L) = XLIST(J,L)*SF
    1 CONTINUE
      RETURN
    4 DO 5 J=2,50,2
      XLIST(J,L) = XLIST(J,L)*SF
    5 CONTINUE
      RETURN
      END
C
      SUBROUTINE ZERO(A,NR,NC,NRA)
      DIMENSION A(NRA,1)
      DO 10 I=1,NR
      DO 10 J=1,NC
      A(I,J) = 0.
   10 CONTINUE
      RETURN
      END
C
      SUBROUTINE ZMEN
      COMMON /SEGMNT/ JSEG(25,25),SEG(25,20),SEGLAB(25,6)
      COMMON /OBSERV/ KOBS(20,12),OBS(20,6),OBLABL(2,20)
      COMMON /STATE/ IST(50,5),ST(50,4),LOGIC(50,25),LABEL(50)
      LOGICAL LOGIC
      COMMON /LIST/ XLIST(50,15),LC(15)
      COMMON /COUNTR/ J,JDT,JIN,JIDT,JFDT,NERR
      COMMON /RESTR/ RESTAR,NRLEVL,NRPASS
      LOGICAL RESTAR
      COMMON /LOGICL/ FILTAP,JSTART,VCHAN,LRESET
      LOGICAL FILTAP,JSTART,VCHAN,LRESET
      COMMON /OBRLZ/ OBRLZ(8),SWRLZ
      COMMON /LABEL/ XLABEL(6),SLABEL(6),SGLABL(6),OL(2,10)
      LOGICAL SWRLZ
      COMMON /RXGEN/ RX(11,10),MDT(11),RANIN
      COMMON /OUTPT/  NSAVE(11),SAVO,FRSS,PRMIN
      LOGICAL PRMIN,SAVO,FRSS
      COMMON /CONTRL/ NTYPE,JSTAR,JDTI,JSTOP,JDTF
      DATA IBL,OBL/1H ,1H /
C
C     SETS UP PROBLEM DEFINITION ARRAYS
C
      WHEN=DATE(D)
      CLTIME=TIME(A)
      CALL ZERO(JSEG,25,25,25)
      CALL ZERO(SEG,25,20,25)
      CALL ZERO(KOBS,20,12,20)
      CALL ZERO(OBS,20,5,20)
      CALL ZERO(IST,50,5,50)
      CALL ZERO(ST,50,4,50)
      CALL ZERO(XLIST,50,15,50)
      CALL ZERO(LC,15,1,15)
      DO 111 I=1,50
      DO 111 K=1,25
      LOGIC(I,K) = .TRUE.
  111 CONTINUE
      NERR = 0
      RESTAR = .FALSE.
      VCHAN = .FALSE.
      NRLEVL = 0
      NRPASS = 0
      FILTAP = .FALSE.
      SWRLZ = .FALSE.
      PRMIN = .FALSE.
      FRSS = .FALSE.
      SAVO = .FALSE.
      RANIN = 0.0
      NTYPE = 1
      DO 222 I=1,20
      OBLABL(1,I) = OBL
      OBLABL(2,I) = OBL
  222 CONTINUE
      DO 333 I=1,8
      OBRLZ(I) = 0.
  333 CONTINUE
      DO 444 I=1,50
      LABEL(I) = IBL
  444 CONTINUE
      REWIND 10
      REWIND 20
      REWIND 21
      REWIND 30
      REWIND 40
      REWIND 50
      WRITE(50) WHEN,CLTIME
      RETURN
      END
C
C
C
      SUBROUTINE ZPLOT
      DIMENSION SPECMAT(3),RX(1500),RY(1500),RZ(1500)
      COMMON /QRMAT/ X(1500),Y(1500),Z(1500),RSSO(500)
      CALL ZERO(X,5000,1,5000)
      REWIND 50
      N=1
      READ(50) WHEN,CLTIME
C
C        REFERENCE  SUBROUTINE  SETOUT IN DOCUMENTATION FOR RSSO VALUES
C
   15 READ(50) (RSSO(K),K=1,12),TIME,J,JDT
      IF(EOF(50)) 23,20
C
C     J=SEGMENT NUMBER
C   JDT=SEGMENT DT
C  TIME=FLIGHT TIME
C
  20  X(N) =TIME/60.0
C
C     RSSO(1)= POSITION CEP ERROR
C     RSSO(5)= VELOCITY RSS ERROR
C
      Y(N)=RSSO(1)
      Z(N)=RSSO(5)
      IF(N.EQ.1500) GO TO 23
      N=N+1
      GO TO 15
C
   23 CONTINUE
C
C    ALL DATA IS STORED IN ARRAYS X,Y,Z AT THIS POINT.
C
C    BEGIN TO PLOT
C
C    COMPUTE MINIMUM AND MAXIMUM VALUES OF X,Y,Z ARRAYS
C
      CALL ZMINMX(XMAX,XMIN,X,N,1,1500)
      CALL ZMINMX(YMAX,YMIN,Y,N,1,1500)
      CALL ZMINMX(ZMAX,ZMIN,Z,N,1,1500)
      XINT=(XMAX-XMIN)/(N-1)
      YINT=(YMAX-YMIN)/100.0
      ZINT=(ZMAX-ZMIN)/100.0
      RX(1)=XMIN
      RY(1)=YMIN
      RZ(1)=ZMIN
      KOUNT=0
      DO 45 J=2,N
      RX(J)=XMIN+(J-1)*XINT
   25 I=J+KOUNT
C TEST TO SEE IF MORE THAN ONE DATA POINT IS IN THE INTERVAL
      IF(X(I+1).GT.RX(J)) GO TO 28
      KOUNT=KOUNT+1
      GO TO 25
C
C TEST TO SEE IF X(I) IS@ SHORT OF , EQUAL TO , OR NOT WITHIN  RX(J)
C
   28 IF(X(I)-RX(J)) 30,35,40
C
C THERE ARE NO DATA POINTS IN INTERVAL
C
   40 KOUNT=KOUNT-1
      I=J+KOUNT
C
C  X(I) IS NOT EQUAL TO RX(J) MAKE A LINEAR APPROXIMATION..........
C
   30 XX=(RX(J)-X(I))/(X(I+1)-X(I))
      RY(J)=Y(I)+(Y(I+1)-Y(I))*XX
      RZ(J)=Z(I)+(Z(I+1)-Z(I))*XX
      GO TO 45
C
C   X(I) IS EQUAL TO RX(J) USE X AND Y FOR RX AND RY
   35 RY(J)=Y(I)
      RZ(J)=Z(I)
   45 CONTINUE
      DO 49 J=1,N
      X(J)=RX(J)
      Y(J)=RY(J)
      Z(J)=RZ(J)
   49 CONTINUE
C
C     LINEAR APPROXIMATION OF  Y AND Z  OVER THE INCREMENTED X.
C
      PRINT 300,    WHEN,CLTIME,XMAX,XMIN,XINT,YMAX,YMIN,YINT
  300 FORMAT(1H1,50X,A10,5X,A10/50X,'POSITION CEP ERROR VS. TIME.'//
     130X,*TIME MAX=  *,F15.3, 5X,*TIME MIN=  *,F15.3, 5X,
     2*TIME INTERVAL=  *,F15.3/30X,*POS. MAX=  *,F15.3,5X,*POS. MIN=  *
     3,F15.3,5X,*POS. INTERVAL=  *,F15.3//)
      PRT=0
      CALL ZPRINT(PRT,YMAX,YMIN,YINT),RETURNS(105)
      PASS=1
C
C     SET UP ORDINATE DISPLACEMENT AND  ABSISSOR AXIS
C
   50 ARIA=0.0
      DO 100 I=1,N
      DO  70 J=1,101
      IF(YMIN+YINT'(J-1)+YINT/2.0.GE.Y(I)) GO TO 75
   70 CONTINUE
   75 ENCODE(26,80,SPECMAT)J
   80 FORMAT(17H(1X,F14.2,3X,1H',,I3,6HX,'+'))
      PRINT SPECMAT,X(I)
      IF(I.EQ.1) GO TO 95
      IF(I.EQ.N) GO TO 95
      ARIA=ARIA+XINT*Y(I)
      GO TO 100
   95 ARIA=ARIA+.5*XINT*Y(I)
  100 CONTINUE
      CALL ZPRINT(PRT,YMAX,YMIN,YINT),RETURNS(150)
      PRINT 320,ARIA
  320 FORMAT(1H0,'THE APROXIMATE AREA UNDER THE CURVE IS@ ',E15.8////)
      IF(PASS.GE.2)GO TO 150
C
C     START VELOCITY PLOT
C
  105 DO 110 I=1,N
  110 Y(I)=Z(I)
      YMAX=ZMAX
      YMIN=ZMIN
      YINT=ZINT
      PRINT 310,   WHEN,CLTIME,XMAX,XMIN,XINT,YMAX,YMIN,YINT
  310 FORMAT(1H1,50X,A10,5X,A10/50X,'VELOCITY RMS ERROR VS. TIME.'//
     130X,*TIME MAX=  *,F15.3, 5X,*TIME MIN=  *,F15.3, 5X,
     2*TIME INTERVAL=  *,F15.3/30X,*VEL. MAX=  *,F15.3,5X,*VEL. MIN=  *
     3,F15.3,5X,*VEL. INTERVAL=  *,F15.3//)
      PASS=PASS+1
      PRT=0
      CALL ZPRINT(PRT,YMAX,YMIN,YINT),RETURNS(150)
      GO TO 50
  150 RETURN
      END
C
C
      SUBROUTINE ZPRINT (PRT,AMAX,AMIN,AINT),RETURNS(IN)
C
C      THIS  SUBROUTINE PRINTS THE ORDINATE AXIS.
C
      DIMENSION A(6)
      IF(AMAX.EQ.AMIN) GO TO 60
      DO 10 I=1,6
   10 A(I)=AMIN+(I-1)*20.00*AINT
      IF(PRT.GE.1)GO TO 40
      PRINT 20,    (A(I),I=1,6)
   20 FORMAT(13X,6(5X,E15.8))
      PRINT 25
   25 FORMAT(20X,5(''                   '),''')
      PRINT 30
   30 FORMAT(20X,10(''....+....'),''')
      GO TO 50
   40 PRINT 30
      PRINT 25
      PRINT 20,    (A(I),I=1,6)
   50 PRT=1
      RETURN
   60 PRINT 80
   80 FORMAT(1H0,//5X,'ALL ORDINATE VALUES ARE EQUAL')
      RETURN IN
      END
C
C
      SUBROUTINE ZMINMX(XMAX,XMIN ,X,NR,NC,NAR)
      DIMENSION X(NAR,1)
C
C          RETURNS MAXIMUM AND MINIMUM VALUES IN MATRIX X.
C
C
      XMAX= X(1,1)
      XMIN=XMAX
      DO 1 I=1,NR
      DO 1 J=1,NC
      IF (XMAX.LT.X(I,J)) XMAX=X(I,J)
      IF (XMIN.GT.X(I,J)) XMIN=X(I,J)
    1 CONTINUE
      RETURN
      END
C
  A@c