BASE 0

!PROCEDURES
FIND %GETDUM,%HASH,%OCTOUT,%SIXOUT,%NUMOUT,%OCTWD.OUT
FIND %BYPT,%INITTTY,%DATOUT
LOCAL %MUDCHK,%L.FIRST,%ACT.LOOK,%CHKMUD,%CHK.ACT.ERR,%CHK.IO.ERR
LOCAL %MUD.HASH,%DUL.LOOK,%DUL.OVERFLOW,%MUD.SEQ,%M.FIRST
LOCAL %ERROR,%LOKUP.DUL,%LOKUP.LUD
LOCAL %LUD.LOOK,%MUD.LOOK,%LUD.SEQ,%LUDCHK,%LUD.OVERFLOW

DEF SIXBIT.TAB(A) AS COMPRS(A) - OCT 40
DEF SIZE.BLK AS 128
DEF M.SIZE.BLK AS 256
!ID'S
GLOBAL USER(20),CUST(1),PPN,IER,ICODE,MODE,NAME.HASH,LOC.HASH
GLOBAL CH.OUT,P,NUMBER
LOCAL CH.LUD,CH.DUL,CH.MUD,ACT.ADR,IO.ADR
LOCAL D.INDEX,D.BLK(SIZE.BLK),DULNAM
LOCAL L.INDEX,L.BLKNO,L.BLK(SIZE.BLK),LUDNAM,I
LOCAL M.INDEX,M.BLK(M.SIZE.BLK)
LOCAL SAVCP,SIT31NAME,SITE,TMP1,TMP2,OLDBLK
LOCAL IOTAB(WPF),NAME(3),MUD.TMP


GLOBAL TABLE COMPRS(0:44)[$ ,$A,$B,$C,$D,$E,$F,$G,$H,$I,$J,$K,$L,$M,&
$N,$O,$P,$Q,$R,$S,$T,$U,$V,$W,$X,$Y,$Z,0,$-,$.,$/,$0,$1,$2,$3,$4,$5,$6,&
$7,$8,$9,$:,$*,$',0]

!MACRO'S
DEF ACTSIT(A) AS BYT(USER(5),1,(BITS.PER.WORD-1)-A) !COMPUTE ACCTG. SITE
DEF BEFORE24(A) AS BYT(A,1,24)
DEF CALL.GETACT(A,B) AS [ICODE_A; MODE_B; GETDUM]
DEF CHARGE.EQ AS (M.CHARGE=0 AND USER(1)=77) OR (M.CHARGE=1 AND USER(1)#77)
DEF CR AS PUT(CARRET)
DEF DIST.BITS AS BYT(LUD(1),8,0)
DEF DOTS AS MSG('...')
DEF EXTRACT(A) AS A BAND MONE.IN.24
DEF FIRSTOF24(A) AS BYT(A,1,23)
DEF FIXCP(A) AS (A-1)*SIZE.BLK	!COMPUTE CURSOR POS. FROM BLK. NO.
DEF LUD.READ AS [RB(CH.LUD,SIZE.BLK,L.BLK); L.INDEX_0]
DEF L.ACCT.SUP AS BYT(LUD(3),1,14)
DEF LT(A) AS FIRSTOF24(A) = 1
DEF L.TYM AS BYT(LUD(3),1,13)
DEF L.MSG AS BYT(LUD(2),1,34)
DEF DUL(A) AS D.BLK(D.INDEX+A)
DEF LUD(A) AS L.BLK(L.INDEX+A)
DEF DUL.READ AS [RB(CH.DUL,SIZE.BLK,D.BLK); D.INDEX_0]
DEF LASTOF24(A) AS BYT(A,1,0)
DEF MONE.IN.24 AS OCT 77777777
DEF MUD(A) AS M.BLK(M.INDEX+A+MUD.TMP)
DEF MUD.READ AS [RB(CH.MUD,M.SIZE.BLK,M.BLK);M.INDEX_MUD.TMP_0]
DEF M.DIST AS BYT(MUD(6),12,0)	!SHIFT 2 PLACES!!
DEF M.ACCT.SUP AS BYT(MUD(6),1,20)
DEF M.TYM AS BYT(MUD(6),1,24)
DEF M.MSG AS BYT(MUD(6),1,19)
DEF M.CHARGE AS BYT(MUD(4),1,0)
DEF NBYV AS NCHV
DEF PPN.OUT AS OCTWD.OUT(LUD(0))
DEF ROTATEL24 AS [TMP1_TMP1 SHL 1; TMP2_TMP2 SHL 1; LASTOF24(TMP2)_BEFORE24(TMP1);&
	LASTOF24(TMP1)_BEFORE24(TMP2); TMP1_EXTRACT(TMP1);&
	TMP2_EXTRACT(TMP2)]
DEF SIZE.LUD.ENT AS BYT(LUD(2),7,0)
DEF SETSITE AS [HW(@EXTARG(IOTAB),0)_SIT31NAME; SITBYT_SITBYT+SITE-31]
DEF SITBYT AS BYT(EXTARG(IOTAB),6,24)
DEF SYSINC AS [I_SITBYT; INC I; SITBYT_I]
DEF VERSION AS 1

!ERROR MESSAGES FOR READ DATA ERRORS
DEF DIST.BAD AS 2
DEF ACCTS.BAD AS 3
DEF TYM.BAD AS 4
DEF MSG.BAD AS 5
DEF NO.ACTG.BAD AS 6
DEF NODUL.BAD AS 7
DEF CHARGE.BAD AS 10
DEF SYS.BAD AS 11
DEF NOUSER.BAD AS 12
DEF MISC.BAD AS 13
DEF NODULENT.BAD AS 14
DEF GAN.BAD AS 15
DEF AUN.BAD AS 16

!LABELS
LOCAL CHK.ERR:,MUD.ERR:

%CHKMUD
	!MAIN LINE TO LOOK UP LUD FOR EACH SITE AND CHECK THEM
	!AGAINST THE MUD

LOCAL P1

START: IOCS(2); INITTTY; CH.OUT_OPEN('TEL',SEQUEN+OUTPUT+CHARACTER,0,2)
MSG('$PDP-10 MUD CHECK - VERSION ');NUMOUT(VERSION)
CR; DATOUT
\\->START
PPN _ OCT 1042313

P1_CHPT('(CUD10)LUD.31',-1)
SETFID(IOTAB,@P1,0,CHK.ERR)
LUDNAM_NAMARG(IOTAB); SIT31NAME_HW(@EXTARG(IOTAB),0)

P1_CHPT('(CUD10)DUL.31',-1)
SETFID(IOTAB,@P1,0,CHK.ERR)
DULNAM_NAMARG(IOTAB)

CH.MUD _ OPEN('(CUD10)MUD.SYS',DIRECT+INPUT+WORD,MUD.ERR)

FOR SITE _ 31 TO 35 DO
 IF LOKUP.LUD=1 THEN [IF LOKUP.DUL=1 THEN LUDCHK ELSE CHK.IO.ERR]&
	  ELSE IF ERRNUM#FNFERR THEN CHK.IO.ERR
SYSINC
END

	MUDCHK

	CLOSE.ALL
	EXIT

MUD.ERR:MSG('ERROR ON MUD...'); CR;CR;EXIT

%LUDCHK
	!READ THROUGH LUD, LOOKING UP AND CHECKING EACH ENTRY IN MUD
LOCAL ENDLUD:
IO.ADR _ ENDLUD
CR; CR; MSG('CHECKING LUD.');NUMOUT(SITE);CR;CR
CALL.GETACT(1,-1); CHK.ACT.ERR
SETCP(CH.LUD,0); L.BLKNO _ 1; LUD.READ; L.INDEX _ 0; OLDBLK _ 0
L.FIRST; GO LP1
LOOP DO
	LUD.SEQ
	LP1: WHILE LUD(4)=0 THEN LUD.SEQ
	     IF DUL.LOOK(LUD(0)) = 1 THEN DO
	IF MUD.LOOK # 0 THEN DO
	   IF HW(LUD(0),0) # HW(MUD(3),1) THEN ERROR(GAN.BAD)
	   IF HW(LUD(0),1) # HW(MUD(4),1) THEN ERROR(AUN.BAD)
	   IF DIST.BITS # M.DIST THEN ERROR(DIST.BAD)
	   IF L.ACCT.SUP # M.ACCT.SUP THEN ERROR(ACCTS.BAD)
	   IF L.TYM # M.TYM THEN ERROR(TYM.BAD)
	   IF L.MSG # M.MSG THEN ERROR(MSG.BAD)
	   USER(0) _ DUL(0)
	   IF ACT.LOOK # 0 THEN DO
	   IF NOT(CHARGE.EQ) THEN ERROR(CHARGE.BAD)
	   END ELSE ERROR(NO.ACTG.BAD)
	END ELSE ERROR(NOUSER.BAD)
	END ELSE ERROR(NODULENT.BAD)
END
ENDLUD: RETURN
END LUDCHK



%MUD.SEQ
	!READ NEXT SEQUENTIAL MUD ENRY
LOOP DO
M.INDEX+_MUD.TMP+7; MUD.TMP _ 0
%%M.FIRST
WHILE MUD(0) = 0 THEN MUD.READ
IF MUD(0) # MONE.IN.24 THEN DO
	IF LT(MUD(0)) THEN RETURN
	INC MUD.TMP
	IF LT(MUD(0)) THEN RETURN
	INC MUD.TMP
	RETURN
END ELSE MUD.READ
END
END MUD.SEQ






%LUD.SEQ
	!READ NEXT SEQUENTIAL LUD ENTRY
LOOP DO
L.INDEX+_SIZE.LUD.ENT
 IF LUD(0)<0 THEN LUD.OVERFLOW
%%L.FIRST
WHILE LUD(0)=0 THEN DO
 	IF OLDBLK#0 THEN [SETCP(CH.LUD,OLDBLK*SIZE.BLK+1);OLDBLK_0]
	INC L.BLKNO; LUD.READ
END
	IF LUD(4) #0 THEN RETURN
END
END LUD.SEQ




%LUD.LOOK(ADR)
	!LOOK UP NAME IN ADR,ADR+1 IN LUD
HASH(^ADR,^(ADR+1))
SETCP(CH.LUD,FIXCP(LOC.HASH)); LUD.READ 
WHILE NAME.HASH # LUD(4) THEN DO
	L.INDEX+_SIZE.LUD.ENT
	IF LUD(0)=0 THEN RETURN 0
	IF LUD(0)<0 THEN LUD.OVERFLOW
	END
RETURN 1
END LUD.LOOK


%DUL.LOOK(PPN)
	!LOOK UP PPN IN DUL
SETCP(CH.DUL,FIXCP((PPN MOD 101)+1)); DUL.READ
WHILE DUL(0)#PPN THEN DO
	D.INDEX+_3
	IF DUL(0)=0 THEN RETURN 0
	IF DUL(0)<0 THEN DUL.OVERFLOW
	END
RETURN 1
END DUL.LOOK


%ACT.LOOK
	!LOOK UP USER IN USERNA.MES
CALL.GETACT(3,-1); IF IER = 0 THEN RETURN 1
IF IER = 1 THEN RETURN 0 ELSE CHK.ACT.ERR
END ACT.LOOK





%CHK.ACT.ERR
	!CHECK ACCTG. FILE ERRORS
 IF IER=0 THEN RETURN
IF IER=2 THEN [IF ACT.ADR#0 THEN GO ^ACT.ADR]
 MSG('ERROR ON '); IF MODE <0 THEN MSG('USERNA.MES') ELSE MSG('CUSTOM.ERS')
DOTS; CR

 DO IER OF 1:4
1:  MSG('ENTRY NOT FOUND.')
2:  MSG('NO END OF FILE ADR. SET UP.')
3: MSG('ERROR ON FILE.')
4: MSG('MISC. ERROR.')
END
  EXIT
END CHK.ACT.ERR


%CHK.IO.ERR
	!TAKE CARE OF ALL I/O ERRORS FROM IOCS
CHK.ERR: IF ERRNUM=EOFERR AND IO.ADR # 0 THEN GO ^IO.ADR
 MSG('ERROR ON ');WFID(FIDP);DOTS ;CR
  DO ERRNUM OF TMFERR:CORERR
FNDERR: MSG('BAD FILE MODE OR TYPE')
IFDERR: MSG('ILLEGAL FILE IDENTIFIER')
FNFERR: MSG('FILE NOT FOUND')
IUSERR: MSG('INVALID USER NAME')
PRTERR: MSG('PROTECTION FAILURE')
EOFERR: MSG('END OF FILE')
 END
MSG('.$ERROR ');NUMOUT(ERRNUM);EXIT
END CHK.IO.ERR


%LUD.OVERFLOW
	!READ LUD OVERFLOW BLOCK
SAVCP_CP(CH.LUD)
SETCP(CH.LUD,HW(LUD(0),1)*SIZE.BLK)
LUD.READ
SETCP(CH.LUD,SAVCP)
RETURN
END LUD.OVERFLOW


%DUL.OVERFLOW
	!READ DUL OVERFLOW BLOCK
SAVCP_CP(CH.DUL)
SETCP(CH.DUL,HW(DUL(0),1)*SIZE.BLK)
DUL.READ
SETCP(CH.DUL,SAVCP)
RETURN
END DUL.OVERFLOW


%ERROR(ERR)
	!TYPE OUT DATA ERRORS TO USER
NUMOUT(ERR)
DO ERR OF DIST.BAD:AUN.BAD
DIST.BAD:MSG('DISTRICTS DO NOT MATCH')
ACCTS.BAD: MSG('ACCOUNT SUPERVISOR BIT DOES NOT MATCH')
TYM.BAD: MSG('TYMSHARE PROPRIETARY BIT DOES NOT MATCH')
MSG.BAD: MSG('SUPRESS MESSAGE AT LOGIN BIT DOES NOT MATCH')
NO.ACTG.BAD: MSG('NO ACCTG. ENTRY FOUND FOR '); PPN.OUT
NODUL.BAD: MSG('NO DUL ENTRY FOUND FOR '); PPN.OUT
CHARGE.BAD: MSG('CHARGE/NO CHARGE BIT DOES NOT MATCH')
SYS.BAD: MSG('SYSTEMS DO NOT MATCH')
NOUSER.BAD: MSG('NOT FOUND IN...')
MISC.BAD: MSG('MISC ERROR')
NODULENT.BAD: MSG('NO DUL ENTRY')
GAN.BAD: MSG('LUD GAN = '); OCTOUT(HW(LUD(0),0)); DOTS
	MSG('MUD GAN = '); OCTOUT(HW(MUD(4),1))
AUN.BAD: MSG('LUD AUN = '); OCTOUT(HW(LUD(0),1)); DOTS
	MSG('MUD GAN = '); OCTOUT(HW(MUD(5),1))
END
CR;RETURN
END ERROR


%LOKUP.LUD
	!LOOK FOR LUD.SITE ON DSK
LOCAL LUD.ERR:
	NAMARG(IOTAB)_LUDNAM; SETSITE
	CHLUD_OPEN(-IOTAB,DIRECT+INPUT+WORD,LUD.ERR)
	RETURN 1
LUD.ERR: IF ERRNUM#FNFERR THEN CHK.IO.ERR ELSE RETURN 0
END LOKUP.LUD


%LOKUP.DUL
	!LOOK FOR DUL.SITE ON DSK
LOCAL DUL.ERR:
	NAMARG(IOTAB)_DULNAM; SETSITE
	CH.DUL_OPEN(-IOTAB,DIRECT+INPUT+WORD,DUL.ERR)
	RETURN 1
DUL.ERR: IF ERRNUM# FNFERR THEN CHK.IO.ERR ELSE RETURN 0
END LOKUP.DUL



%MUD.LOOK
	!LOOK UP NAME IN MUD
LOCAL P1,I,J,K,CHARS(4),BLK,TEMP
P1 _ BYPT(@DUL(1),1,6)
FOR K _ 0 TO 2 DO
	FOR J _ 0 TO 3 DO
		TEMP _ NBYV P1; I _ -1
			!IF LOWER CASE, CONVERT TO UPPER
		IF TEMP>OCT 100 AND TEMP<OCT 133 THEN TEMP-_OCT 40
		WHILE INC I <44 AND TEMP # SIXBIT.TAB(I) THEN NULL
		CHARS(J) _ I
	END
NAME(K) _(((CHARS(0)*45)+CHARS(1))*45+CHARS(2))*45+CHARS(3)
END

IF NAME(1)=0 THEN FIRSTOF24(NAME(0))_1 ELSE DO
	IF NAME(2) = 0 THEN FIRSTOF24(NAME(1)) _ 1
END

BLK _ MUD.HASH
SETCP(CH.MUD,BLK*M.SIZE.BLK);MUD.READ
WHILE MUD(0) # 0 THEN DO
    IF MUD(0) = MONE.IN.24 THEN MUD.READ ELSE DO
	IF NAME(0) = MUD(0) THEN DO
	    IF LT(NAME(0)) THEN RETURN 1
	    IF NAME(1) = MUD(1) THEN DO
		IF LT(NAME(1)) THEN [INC MUD.TMP; RETURN 1]
		IF NAME(2) = MUD(2) THEN [MUD.TMP+_2; RETURN 1]
	    END
	END
    END
END
RETURN 0
END MUD.LOOK



%MUDCHK
LOCAL MUD1.ERR:,PN
	!READ THRU MUD - IF HOME SYS IS 31 - 35, LOOK UP DUL
CR; CR; MSG('CHECKING MUD.SYS.'); CR; CR
CLOSE.ALL
CH.MUD _ OPEN('(CUD10)MUD.SYS',SEQUEN+INPUT+WORD,MUD1.ERR)
MUD.READ;M.FIRST;GO M1
LOOP DO
	MUD.SEQ
	M1: SITE _ BYT(MUD(5),6,0); SETSITE!PUT NAME IN NAME(0)-NAME(3)
	IF LOKUP.DUL # 0 THEN DO
		HW(PN,0) _ HW(MUD(3),1); HW(PN,1) _ HW(MUD(4),1)
		IF DUL.LOOK(PN) = 0 THEN ERROR(NOUSER.BAD)
		CLOSE(CH.DUL)
	END ELSE ERROR(NODUL.BAD)
END
MUD1.ERR: IF ERRNUM = EOFERR THEN RETURN
	GO MUD.ERR
RETURN
END MUDCHK



%MUD.HASH
	!DO MUD HASH ROUTINE
TMP1 _ NAME(0); TMP2 _ NAME(0); ROTATEL24
TMP1+_NAME(1); ROTATEL24
TMP1+_NAME(2)
RETURN (TMP1 MOD 2039)
END MUD.HASH
END CHKMUD
