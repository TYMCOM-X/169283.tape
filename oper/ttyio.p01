BASE 0


GLOBAL %INITTTY,%QUERY,%GETNUM,%GETOCT,%GETTOKEN
GLOBAL %CHR.OUT,%OCTWD.OUT,%OCTOUT,%OUT,%NUMOUT,%SIXOUT
GLOBAL %MAKE.SIXBIT,%LISTABLE,%SHORT.OUT,%DATOUT,%CHOOSE,%MATCH
GLOBAL %SPOUT

GLOBAL TOKEN(72/CHARS.PER.WORD)

TABLE TEN(7)[1,10,100,1000,10000,100000,1000000]

FIND CH.OUT,P,NUMBER

LOCAL COUNT,TEMP,CHAR,TOKENP,RETADR,PTR,DISP,I
LOCAL %FILL.IN.TOKEN,%GETSPECIF,%TTYIO

!THE FOLLOWING MACRO COMPUTES A GENERAL BYT POINTER SO THAT NCHV ON
!THE PDP-10 WILL DO ILDB'S FOR ANY BYTE SIZE
DEF BYPT(Y,P1,S) AS [6,6,6,18]*[IF P1>=0 THEN 36-S*(P1 MOD(36/S)-1)&
	ELSE 36-S*(36/S-(-P1)MOD(36/S)+1),S,0,&
	IF P1>=0 THEN Y+P1/(36/S) ELSE Y+(P1+1)/(36/S)-1]
DEF NBYV AS NCHV
DEF BYV AS CHV

DEF ALPHA AS 0
DEF NUMERIC AS 1
DEF USERNAME AS 2
DEF OCTAL AS 3

DEF IFCHAR(A) AS ($A <= A <= $Z) OR IFNUMBER(A) OR A=$.
DEF IF.OCT.NUMBER(A) AS $0 <= A <= $7
DEF IFNUMBER(A) AS $0 <= A <= $9
DEF COLON AS CHR.OUT($:)
DEF CR AS CHR.OUT(CARRET)
DEF SLASH AS CHR.OUT($/)
DEF SPACE AS $ 
DEF SP AS CHR.OUT(SPACE)
DEF IFNAME.CHAR(A) AS IFCHAR(A) OR IFNUMBER(A) OR A=SPACE OR &
	A=$* OR A=$. OR A=$- OR A=$/ OR A=$:
DEF WHAT AS [MSG('?$'); GO ^RETADR]
DEF PASS AS [WHILE NCHV P = SPACE THEN NULL; PCHV P]
DEF STILL.MORE AS INC ANS <= N.TAB
DEF SET.PTR AS PTR _ CHPT(NAME.TAB(ANS),-1)
DEF SETCOUNT AS [TOKENP _ CHPT(TOKEN,-1); COUNT _ -1;&
 WHILE NCHV TOKENP # EOLIT THEN INC COUNT; TOKENP _ CHPT(TOKEN,-1)]



%TTYIO



%INITTTY(INIT:)
P _ CHPT(IMAGE,-1)
RETADR _ INIT
RETURN
END INITTTY


%GETTOKEN(KIND)
MOVE 72/CHARS.PER.WORD FROM ALL 0 TO TOKEN
TOKENP _ CHPT(TOKEN,-1)
IF CHAR _ NCHV P = CARRET OR CHAR = EOLIT THEN P _ GETLINE(TEL) ELSE PCHV P
FILL.IN.TOKEN(KIND); PASS; RETURN
END GETTOKEN


%FILL.IN.TOKEN(KIND)
LOCAL ENDT:
WHILE CHAR _ NCHV P # CARRET AND CHAR # EOLIT THEN DO
IF KIND # USERNAME THEN [IF CHAR = SPACE THEN  GO ENDT]
IF CHAR = $? THEN GO ^RETADR
	DO KIND OF ALPHA:OCTAL
	ALPHA: IF IFCHAR(CHAR) THEN NULL ELSE  WHAT
	NUMERIC: IF IFNUMBER(CHAR) THEN NULL ELSE WHAT
	USERNAME: IF IFNAME.CHAR(CHAR) THEN NULL ELSE WHAT
	OCTAL: IF IF.OCT.NUMBER(CHAR) THEN NULL ELSE WHAT
	END
NCHV TOKENP _ CHAR
END
ENDT:NCHV TOKENP _ EOLIT
RETURN
END FILL.IN.TOKEN


%GETSPECIF(THISONE)
WHILE CHAR _ NCHV P # CARRET THEN IF CHAR = THISONE THEN RETURN 1
RETURN 0
END GETSPECIF



%QUERY(QUES)
MSG(QUES); PUT($?)
LOOP DO 
P _ GETLINE(TEL); TEMP _ NCHV P; WHILE NCHV P # EOLIT THEN NULL
IF TEMP = $Y OR TEMP = CARRET THEN RETURN 1
IF TEMP = $N THEN RETURN 0
MSG('TYPE "Y" OR "N": ')
END
END QUERY


%GETNUM
	!RETURN DECIMAL NUMBER IN NUMBER
GETTOKEN(NUMERIC);SETCOUNT; NUMBER _ 0
FOR I_COUNT TO 0 BY -1 NUMBER+_(NCHV TOKENP-$0)*TEN(I)
RETURN
END GETNUM


%GETOCT
	!INPUT AN OCTAL NUMBER INTO NUMBER
NUMBER _ 0
GETTOKEN(OCTAL); SETCOUNT
DISP _ BITS.PER.WORD
 REPEAT BITS.PER.WORD/3-COUNT-1 DISP-_3
WHILE CHAR_NCHV TOKENP#EOLIT THEN [DISP-_3; BYT(NUMBER,3,DISP)_(CHAR-$0) BAND 7]
RETURN
END GETOCT




%CHR.OUT(A)
W(CH.OUT,A)
RETURN
END CHR.OUT



%OCTWD.OUT(A)
OCTOUT(HW(@A,0)); CHROUT($,); OCTOUT(HW(@A,1))
RETURN
END OCTWD.OUT



%OUT(A)
	!OUTPUT A MESSAGE
TEMP _ CHPT(A,-1)
WHILE CHAR_NCHV TEMP#EOLIT THEN [IF CHAR=$$ THEN CHAR_CARRET;&
			CHR.OUT(CHAR)]
RETURN
END OUT



%NUMOUT(N)
	!OUTPUT DECIMAL NUMBER
IF N<0 THEN [CHR.OUT($-); N-_]
I_0; WHILE N>=TEN(I+1) THEN INC I
WHILE I>=0 THEN [CHR.OUT($0+N/TEN(I)); N_N MOD TEN(I); DEC I]
RETURN
END NUMOUT


%OCTOUT(N)
	!OUTPUT AN OCTAL HALF WORD
DISP _ BITS.PER.WORD/2
WHILE DISP > 0 THEN [DISP-_3; CHR.OUT($0+BYT(N,3,DISP))]
RETURN
END OCTOUT



%SIXOUT(ADR,N)
	!OUTPUT N CHARACTERS IN SIXBIT
PTR _ BYPT(ADR,-1,6)
REPEAT N CHR.OUT(SPACE+NBYV PTR)
RETURN 
END SIXOUT



%MAKE.SIXBIT(FROMADR,TOADR,N)
	!CHANGE N CHARACTERS FROM ASCII IN FROMADR TO SIXBIT IN TOADR
LOCAL FROMP,CHAR
FROMP _ CHPT(FROMADR,-1)
PTR _ BYPT(TOADR,-1,6)
REPEAT N DO
IF CHAR _ NCHV FROMP # EOLIT THEN NBYV PTR _ (CHAR-SPACE) BAND OCT 77 &
		ELSE NBYV PTR _ EOLIT
END
RETURN
END MAKE.SIXBIT



%LISTABLE(N.TAB,TAB())
	!LIST ENTIRE TABLE, WITH ENTRIES SEPARATED BY COMMAS...
	!TABLE MUST HAVE >1 ENTRIES...DOES NOT TYPE ENTRIES OF -1
I_1
WHILE TAB(I)=-1 THEN INC I
MSG(TAB(I)); INC I
WHILE  I <=N.TAB THEN DO
	IF TAB(I)#-1 THEN [IF I#N.TAB THEN MSG(', ') ELSE &
			MSG(' OR '); MSG(TAB(I))]
	INC I
END
RETURN
END LISTABLE



%SPOUT(A,B)
TEMP _ B
WHILE A < TEN(TEMP) THEN [SP; DEC TEMP]
RETURN
END SPOUT


%SHORT.OUT(PTR,N)
	!OUTPUT TEXT ONLY IN N SPACES...
REPEAT N DO
IF CHAR _ NCHV PTR = EOLIT THEN [SP; PCHV PTR] ELSE CHR.OUT(CHAR)
END
RETURN
END SHORT.OUT




%DATOUT
	!OUTPUT DATE AND TIME
LOCAL MON,HOURS,DAY,MINUTE
CR; TEMP _ EXU(OCT 47,OCT 1,OCT 14)
[TEMP; DAY] _ TEMP DIVMOD 31
[TEMP; MON] _ TEMP DIVMOD 12
NUMOUT(MON+1);SLASH; NUMOUT(DAY+1);SLASH; NUMOUT(64+TEMP); SP; SP
TEMP _ EXU(OCT 47, OCT 1,OCT 22)
[TEMP; ] _ TEMP DIVMOD 3600
[HOURS;MINUTE] _ TEMP DIVMOD 60
NUMOUT(HOURS); COLON
IF MINUTE < 10 THEN CHR.OUT($0)
IF MINUTE = 0 THEN CHR.OUT($0) ELSE NUMOUT(MINUTE)
CR; CR; RETURN
END DATOUT



%CHOOSE(N.TAB,NAME.TAB())
	!FIND A UNIQUE MATCH IN NAM.TAB WITH TOKEN
LOCAL ANS,FIRST
ANS _ 0
WHILE STILL.MORE THEN DO
	SET.PTR
	IF MATCH(PTR) = 1 THEN DO
		FIRST_ANS
		WHILE STILL.MORE THEN [SET.PTR;&
			IF MATCH(PTR)=1 THEN [MSG('$NOT UNIQUE$');RETURN 0]]
		RETURN FIRST
	END
END
RETURN 0
END CHOOSE


%MATCH(PTR)
	!RETURN 0 IF NO MATCH, 1 IF MATCH
LOCAL P
P _ CHPT(TOKEN,-1)
IF NCHV P # NCHV PTR THEN RETURN 0
WHILE NCHV P # EOLIT THEN IF CHV P # NCHV PTR THEN RETURN 0
RETURN 1
END MATCH


END TTYIO
