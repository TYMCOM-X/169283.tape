        OPEN (11,'CONFIL',RANDIO(256),BINARY)
        OPEN(12,'KEYFIL',RANDIO(100),BINARY)
        OPEN(1,'FIL1',RANDIO(34),BINARY)
        OPEN(2,'FIL2',RANDIO(34),BINARY)
        OPEN(3,'FIL3',RANDIO(32),BINARY)
        OPEN(4,'FIL4',RANDIO(32),BINARY)
C           DESCRIPTION OF PRE-UPDATE MODULE - PMSC10
C           LAST UPDATED ON 12/16/72 BY DBP VERSION 2
C         
C !!!    SUBROUTINE PREUPD(DUMMY,IOMOD,NXTNAM,IPGER)
         COMMON ITODAY,LSTDAY,ISTATE,IRNCTL(2),LOLDAY
         DIMENSION MBUF(40),ISMF(40),ISMFT(40),ISLF(40),I5(6)
C !!!    FILENAME NXTNAM,MESSAGE
C !!!    ASCII FNAME,TYPE,TRAN(4)
C         
         DATA I2,I1,I10,I24,I25,I26,I11,I13,I12,I21,I27,I20
     1   ,I14,I23,I22
     1 ,I28,I29,I30,I4,I32,I16,I15,I17,I9,I18,I19/26*  0/
         DATA ICUSIP,NKSLF,NKEY,ITHUR,NULL,KIND
     1       /0,1,2,71224,O377777777777,1820447457/
C          
C            RESET NEW FILES
         CALL IOMOD(10,0,0,0,0)
C          
         CALL IOMOD(12,'SMFN',IERR,MBUF,IKEY)
         CALL IOMOD(12,'SLFN',IERR,MBUF,IKEY)
C         **** SMF FILE RE-COPY *****
C         
C           FIND SMF RECORD LOCATIONS
C                I4=SPEC. SPROV. POINTER  I9=INTEREST PAYMENT
C                I1=CUSIP NUMBER    I2=SMF TRAILER POINTER
C         
C         
C           FIND SMF TRAILER RECORD LOCATIONS
C                I3=TRAILER POINTERS   I5=SLF RECORD POINTERS
C         
         CALL IOMOD(4,'SMFN',IERR,MBUF,2)
         I3=MBUF(1)
         DO 210 I=1,6
210       I5(I)=MBUF(I*4-1)
C         
C           FIND SLF RECORD LOCATIONS
C           I6=COLLATERAL POINTER   I7=NEXT LEDGER RECORD
C           I8=TRANSACTION NUMBER
C         
         CALL IOMOD(4,'SLFN',IERR,MBUF,1)
         I6=MBUF(10)
         I7=MBUF(4)
         I8=MBUF(2)
C         
C           I10=ACCOUNTING CODE   I11=ISSUE DATE
C           I12=COUPON RATE       I13=MATURITY DATE
C         
         CALL IOMOD(4,'SMFN',IERR,MBUF,1)
        I2=MBUF(1)
        I1=MBUF(2)
        I4=MBUF(19)
C         
C           ZERO SMF KEY TO READ 'SMF'  'SEQUENTIALLY'
C         
260       KEY=0
         CALL IOMOD(4,'SMFO',IERR,ISMF,KEY)
         IF(IERR.NE.0) GOTO 1000
C         
C           WRITE SMF RECORD ON SMFNEW SAVE NEW KEY IN TABLE FOR USE
C          IN UPDATING COLLATERAL POINTER ON SLF
C         
270       NKEY=ISMF(I1)
         CALL IOMOD(7,'SMFN',IERR,ISMF,NKEY)
         IF(IERR.NE.0) GO TO 2002
         IHOLD=NKEY
         NOSMF=NOSMF+1
C         
C           SET SMF TRAILER POINTER
C         
         KEY=ISMF(I2)
C         
C           SET TRAILER POINTER FOR SMFNEW = TO KEY OF SMF RECORD + 1
C         
         ISMF(I2)=NKEY +1
C         
C           READ TRAILER RECORD
C         
16        CALL IOMOD(4,'SMFO',IERR,ISMFT,KEY)
         IF(IERR.NE.0) GO TO 2000
         NKEY=NKEY+1
C         
C          LOOP THROUGH TRAILER AND RE-COPY SLF
C         
         DO 22 KK=1,6
         KEYSLF=ISMFT(I5(KK))
         IF(KEYSLF.EQ.0) GOTO 22
         ISMFT(I5(KK))=NKSLF+1
C         
C          RECOPY SECURITY LEDGER FILE FOR EACH HOLDING
C         
28        CALL IOMOD(4,'SLFO',IERR,ISLF,KEYSLF)
         IF(IERR.NE.0) GO TO 2003
23        KEYSLF=ISLF(I7)
         IF(KEYSLF.GT.0) ISLF(I7)=NKSLF+2
         NKSLF=ISLF(I8)
         CALL IOMOD(7,'SLFN',IERR,ISLF,NKSLF)
         IF(IERR.NE.0) GOTO 2005
         NOSLF=NOSLF+1
         IF(KEYSLF.GT.0) GOTO 28
22        CONTINUE
C         
C          WRITE TRAILER RECORD AND SEE IF THERE IS ANOTHER ON
C           TRAILER ON SMFNEW
C         
         KEY=ISMFT(I3)
         IF(KEY.GT.0) ISMFT(I3)=NKEY+1
         CALL IOMOD(7,'SMFN',IERR,ISMFT,NKEY)
         IF(IERR.NE.0) GO TO 2002
         IF(KEY.GT.0) GOTO 16
C         
C           SET NEW SMF SPEC PROV POINTER
C         
         KEY=ISMF(I4)
         IF(KEY.GT.0) ISMF(I4)=NKEY+1
         CALL IOMOD(7,'SMFN',IERR,ISMF,IHOLD)
         IF(IERR.NE.0) GOTO 2002
C         
C           READ SPEC PROV PRECORD
C         
19        IF(KEY.EQ.0) GOTO 260
         CALL IOMOD(4,'SMFO',IERR,ISMF,KEY)
         IF(IERR.NE.0) GOTO 2007
         NKEY=NKEY+1
C         
C          WRITE ALL CHAINED SPECIAL PROVISION RECORDS ON NEW FILE
C         
         KEY=ISMF(1)
         IF(KEY.GT.0) ISMF(1)=NKEY+1
         CALL IOMOD(7,'SMFN',IERR,ISMF,NKEY)
         IF(IERR.NE.0) GOTO 2002
         GOTO 19
C         
C         RE-PURCHASE INDEX PORTFOLIO
C         
1000      IF(IERR.EQ.45) GOTO 2400
C         
C          ERROR PRINT OUTS
C         
2000      IOER=1
         GOTO 2010
2002      IOER=2
         GOTO 2010
2003      IOER=3
         GOTO 2010
2005      IOER=4
         GOTO 2010
2007      IOER=5
         GOTO 2010
2008      IOER=6
         GOTO 2010
2009      IOER=7
2010      TYPE 2020,IOER,IERR
2020      FORMAT(' *****I/O MODULE ERROR (PREU)',2I6/1X)
         GOTO 2500
2400      IPGER=0
        TYPE 2430,NOSMF,NOSLF
2430      FORMAT(5X,'END OF PRE-UPDATE PROCESSING'/1X/5X,I5,
     1    ' SECURITIES ON MASTER FILE'/5X,I5,' HOLDINGS ON LEDGER FILE'/
     1 / 1X)
         GOTO 3000
2500      IPGER=IERR
3000      CONTINUE
         RETURN
         END
  
C             DESCRIPTION OF SUBROUTINE IOMOD
C             LAST UPDATED ON 10/9/72 BY DBP
C         
C             PREAMBLE OF IOMOD -DESCRIPTION OF FCB
C         
C             WORD 1-2  LOGICAL FILE NAME
C             WORD 3    FILE STATUS  1=OPEN  OR 0=CLOSE
C             WORD 4    NUMBER OF WORDS/RECORD
C             WORD 5    NUMBER OF RECORDS(USED)-LAST RECORD USED
C             WORD 6    LOCATION (DISK) OF LAST DATA RECORD READ OR WRITTEN
C             WORD 7    DISK ADDRESS OF LAST RECORD OF KEYS USED
C             WORD 8    LOCATION (DISPLACEMENT) OF LAST KEY USED ON REC.OF KEYS
C             WORD 9    NUMBER OF RECORDS ALLOCATED (DATA RECORD)
C             WORD 10   NUMBER OF RECORDS OF KEYS' FOR THE FILE IN USE
C             WORD 11   STARTING LOCATION (DISPLACEMENT)OF WHERE THE HIGH
C                       LEVEL KEY ARRAY STARTS FOR A FILE 'KARY(FCB(I,11),X)'
C             WORD 12   PHYSICAL NAME OF FILE
C             WORD 13   TOTAL NUMBER OF 'RECORD OF KEYS' ALLOCATED
C         
C          KARY(X,Y) - FILE KEY BLOCK PRINTER ARRAY
C         
C             KARY(X,1) - SMALLEST KEY IN THE KEY BUCKET
C             KARY(X,2) - DISK LOCATION OF THE KEY BUCKET
C         
C          ITKEY(50,2,5) - AREA WHERE THE RECORDS OF KEYS ARE STORED
C             RECORDS CONTAIN 50 KEYS WITH THEIR DATA RECORD DISK ADDR.
C             -FIVE FILES CAN ONLY BE OPENED AT THE SAME TIME
C             ICON(5,2)  - DESIGNATES THE FILES (I.E.I) AND THE DISK ADDR
C             WHICH IDENTIFIES WHICH RECORD OF KEYS IS ACTIVE
C             THUS ICON (4,1) = 5 AND ICON (4,2) = 18 THIS
C             DESIGNATES THE 4TH BLOCK OF ITKEY (ITKEY(X,X,4) IS BEGING
C             USED BY FILE 5 AND THE DISK ADDRESS OF THE RECORD OF KEYS
C             WHICH IS BEING STORED IN ITKEY (X,X,4) IS IDENTIFIED AS 18.
C         
         SUBROUTINE IOMOD(INUM,FILNAM,ERROR,IAREA,KEYRW)
         DIMENSION IAREA(40),FCB(14,13),KARY(234,2),ICON(5,2)
     1   ,ITKEY(50,2,5)
     1     ,IHDR(14)
         COMMON JCON(6)
C !!!    FILENAME CONFIL,KEYFIL,SOL
         INTEGER FCB,FILNAM,ERROR,PLOC,ERR
C !!!    ASCII   TEMA,IPEN
C !!!    DATA KEYFIL/'KEYFIL  '/,SOL/'        '/,CONFIL/'CONFIL  '/
         DATA NULL/O377777777777/,IPUT/1/,KEE/1/,MAXBUK/234/
         DATA NFILE/14/,MAXOFL/15/,IWFCB/0/,IOFIL/0/,
     1    IHDR/2,2,4*1,2,5*1,2,1/
         KEY=KEYRW
         ERR=0
C         
C         THE CLEANUP AND INITIALIZE ROUTINES DO NOT HAVE TO BE CHECKED FOR FILE
C         
         IF (INUM.EQ.9.OR.INUM.EQ.10.OR.INUM.EQ.1) GO TO 20
C         
C         MUST OBTAIN CORRECT FCB FOR THE FILNAM DESIGNATED
C         WILL ONLY CHECK THE FIRST FOUR LETTERS OF FILNAME
C         
         ITEMP=FILNAM
         DO 10 I=1, NFILE
         IF (ITEMP.NE.FCB(I,1)) GO TO 10
         IF (FCB(I,3).EQ.1) GO TO 20
         IF (INUM.GT.8) GO TO 20
C         
C          FILE MUST BE OPENED - FIND SLOT FOR FILE IN ICON
C         
         DO 5 IK=1,MAXOFL
         IF (ICON(IK,1).EQ.0) GO TO 7
5         CONTINUE
         ERR=2
         GO TO 1000
7         ICON(IK,1)=I
            ICON(IK,2)=0
         FCB(I,3)=1
         IOFIL=IOFIL+1
         GO TO 20
10        CONTINUE
         ERR=1
         GO TO 1000
C         
C          NUM     1-OPEN  2-CLOSE  3-READ  4-READK
C                  5-READGE 6-WRITE 7-WRITEK 8-DELETE
C                  9-CLEAN UP 10-INITIAL 11-SPACE 12-RESET
C                  13-SWITCH
C         
20        GO TO(30,40,50,60,70,80,90,100,110,120,130,140,150),INUM
C         
C          SET MAXIMUM FILES OPEN LIMIT
C         
30        MAXOFL=KEY
         GO TO 1000
C         
C             THE 'CLOSE' PORTION OF IOMOD
C         
C          MUST CLOSD FILE, RESET FCB, AND RESET ICON
C         
40        CONTINUE
C !!!    CALL CLOFIL(FCB(I,12))
C          RESET FCB TO A CLOSE CONDITION
         FCB(I,3)=0
         FCB(I,6)=0
         FCB(I,7)=0
         FCB(I,8)=0
C          FIND THE FILE IN ICON AND CLEAR
         DO 41 IK=1,MAXOFL
         IF (ICON(IK,1).EQ.I) GO TO 42
41        CONTINUE
         GO TO 1000
42        ICON(IK,1)=0
         IF (ICON(IK,2).EQ.0) GO TO 43
         IDISK=ICON(IK,2)
C          WRITE KEY BUCKETS BACK TO KEYFIL
         WRITE(12#IDISK) ((ITKEY(K1,K2,IK),K2=1,2),K1=1,50)
C !!!    CLOSEFILE KEYFIL
         ICON(IK,2)=0
C          WRITE FCB AND COMMON BACK TO CONFIL
         WRITE(11#1)JCON,((FCB(JZ,JZ1),JZ1=1,13),JZ=1,NFILE)
         WRITE(11#2)((KARY(K1,K2),K2=1,2),K1=1,128)
         WRITE(11#3)((KARY(K1,K2),K2=1,2),K1=129,MAXBUK)
C !!!    CLOSEFILE CONFIL
43        IOFIL=IOFIL-1
         GO TO 1000
C         
C          THE READ-READK-READGE PORTION OF IOMOD
C         
C          READ - BY OBTAINING THE LAST RECORD READ - UTILIZING @CB(I,6)
C          ----     A READ OF THE NEXT PHYSICAL RECORD ON DISK
C                       WILL BE PERFORMED
C         
50        CONTINUE
C         
         LOC=FCB(I,6)+1
         IF (LOC.LE.FCB(I,5)) GO TO 52
         ERR=5
         GO TO 1000
C         
52        FCB(I,6)=LOC
         GO TO 603
C         
C          READK-READ WITH KEY
C         
C          CHECK IF KEY IS A DISK DATA ADDR.
C         
60        IF (KEY.GT.10000) GO TO 610
C         
         IF (KEY.EQ.0.) GO TO 62
         FCB(I,6)=KEY
         LOC=KEY
         IF (LOC.LE.FCB(I,5)) GO TO 604
         ERR=45
         GO TO 1000
C         
C          IF KEY =0 -  THEN THE NEXT HIGHEST KEY VALUE DATA RECORD IS READ.
C          MUST OBTAIN THE NEXT KEY AND DISK LOC.BY INCREMENT THE LAST
C          LOCATION ON THE RECORD OF KEYS (FCB(I,7) AND FCB (I,8))
C         
62        DO 6200 IK=1,MAXOFL
         IF (ICON(IK,1).EQ.I) GO TO 6205
6200      CONTINUE
         ERR=2
         GO TO 1000
6205      IF (ICON(IK,2).GT.0) GO TO 64
C         
C          MUST OPEN FILE MUST REWIND FILE THEREFORE MUST START ON FIRST
C         RECORD OF KEYS FCB(I,11)+1 POINTS TO FIRST RECORD OF KEYS
C                WITHIN KARY
C         
         IDISK=KARY(FCB(I,11)+1,2)
C !!!    IF (IOFIL.GE.MAXOFL) CALL CLOFIL(FCB(I,12))
C         
C          OBTAIN RECORD OF KEYS FROM FIND
C         
         CALL FIND(I,ITKEY,IK,IDISK,ICON,ERR)
         IF (ERR.NE.0) GO TO 1000
         WRITE(11#1) JCON,((FCB(JZ,JZ1),JZ1=1,13),JZ=1,NFILE)
C !!!    CLOSEFILE CONFIL
C         
C          THE FIRST DISK ADDR FOR THE FILE WILL BE USED
C         
63        IPUT=1
C         CHECK IF KEY IS EMPTY IF SO EOF
         IF (ITKEY(IPUT,1,IK).NE.NULL) GO TO 66
         ERR=45
         GO TO 1000
C          FILE IS OPEN THEREFORE THE CORRECT BLOCK IS IN ITKEY
64        IDISK=FCB(I,7)
C          INCREMENT LOC.OF LAST KEY USED FCB(I,8)
         IPUT=FCB(I,8)+1
66        KEY=ITKEY(IPUT,1,IK)
         LOC=ITKEY(IPUT,2,IK)
C          MUST CHECK IF KEY IS EMPTY MUST GO TO NEXT RECORD OF KEYS
         IF (KEY.EQ.NULL) GO TO 72
C         MUST CHECK IF RECORD IS A DELETED RECORD-IF GO TO NEXT RECORD
660       IF (LOC.NE.0) GO TO 602
         IPUT=IPUT+1
         IF (IPUT.LE.50) GO TO 66
         ERR=20
         GO TO 1000
C          MUST GO THROUGH THE 'KARY' TO FIND WHERE 'IDISK' WAS OBTAINED
C          THE NEXT 'KEY AND IDISK' IN KARY WILL BE USED
C          SPECIAL CASE WILL BE USED FOR READGE WHEN IPUT=99
72        IFIRT=FCB(I,11)+1
         IF (FCB(I,7).LE.FCB(I,11)+FCB(I,13)) GO TO 672
         ERR=45  
C         THIS USED TO BE ERR=19
         GO TO 1000
672       IEND=FCB(I,10)
         DO 67 JB=1,IEND
         IF (IDISK.EQ.KARY(IFIRT+JB-1,2)) GO TO 68
67        CONTINUE
         ERR=7
         GO TO 1000
C         OBTAIN THE NEXT DISK LOCATION FOR THE NEXT 'REC.OF KEYS'
68        IDISK=KARY(IFIRT+JB,2)
         IF (JB.LT.IEND) GO TO 685
C         TRYING TO GET NEXT BLOCK AND IT IS LARGER THAN FILE
         ERR=45
         GO TO 1000
C         
C          MUST CHECK IF FIVE FILES OPEN
C         
685      CONTINUE
         CALL FIND(I,ITKEY,IK,IDISK,ICON,ERR)
         IF (ERR.NE.0) GO TO 1000
         WRITE(11#1) JCON,((FCB(K1,K2),K2=1,13),K1=1,NFILE)
C !!!    CLOSEFILE CONFIL
C         GO TO 66 TO OBTAIN LOC AND KEY AND CHECK FOR DELETED RECORD
C         ALSO SPECIAL CASE IPUT=-99 RETURN TO READGE CODE
601       IF (IPUT.EQ.(-99)) GO TO 73
         GO TO 63
C          A READ WITH A NORMAL KEY VALUE
C          GO TO COMMON CODE STARTS AT 2000
610       IGO=1
         GO TO 2000
C          RETURN FROM COMMON CODE
C          RESET FCB(I,6),FCB(I,7),FCB(I,8)
C         CHEX IF LOC= -1 ERROR
602       IF (LOC.GT.0) GO TO 605
         ERR=16
         GO TO 1000
C         STORE RECORD OF READ
605       FCB(I,6)=LOC
         FCB(I,7)=IDISK
         FCB(I,8)=IPUT
C          DO THE READ
603       KEY=LOC
604     CONTINUE
         ISARAH=FCB(I,4)
         READ (I#LOC) (IAREA(K),K=1,ISARAH)
         GO TO 1000
C         
C          READGE-READ KEY IF GREATER THAN OR EQUAL
C          MUST DESIGNATE IPUT=-99 SO BINTAB ROUTINE SEARCH
C          ON THE GREATER THAN OR EQUAL
C         
C          MUST CHECK KEY-MUST BE A KEY VALUE ONLY
C         
70        IF (KEY.GE.10000) GO TO 71
         ERR=9
         GO TO 1000
71        IGO=1
         IPUT=-99
         GO TO 2000
C          MUST OBTAIN THE FIRST KEY OF THE NEXT HIGHER GROUP OF KEYS
C          WITHIN A RECORD OF KEYS--THE FIRST KEY WILL
C          GIVE THE GREATER THAN CONDITION DESIRED
C          THIS CODE STARTS AT LOCATION 72
C          CHECK IF THE FIRST KEY IS AN EMPTY RECORD
73        LOC=ITKEY(1,2,IK)
         IF (LOC.NE.NULL) GO TO 74
         ERR=10
         GO TO 1000
C          MUST RESET IPUT=1 AND READ DATA RECORD
C         
74        IPUT=-99
         GO TO 204
C         
C          WRITE - WRITEK - WRITE - WRITEK
C         
C          THE WRITE - WRITEK PORTION OF IOMOD
C         
C          FOR THE WRITE SEQUENTIAL - WRITE WITHOUT REFERENCE
C          TO THE RECORD OF KEYS - DIRECT WRITE
C         
80        CONTINUE
C          CHECK TO SEE IF FILE IS FULL
81        IF (FCB(I,5).LT.FCB(I,9)) GO TO 82
         ERR=12
         GO TO 1000
C          OBTAIN LOCATION FOR NEXT WRITE
82        KEY=FCB(I,6)+1
         GO TO 99
C          THE WRITE WITH KEY IF KEY LESS THAN 10000 - PHYSICAL WRITE
C          MUST GO TO STATEMENT 2000 WHERE THE RECORD
C          OF KEYS IS OBTAINED AND A BINARY SEARCH IS EXECUTED
90        IF (KEY.LT.10000) GO TO 99
         IGO=2
         GO TO 2000
C         
C          WILL RETURN HERE IF KEY=(-1) - AN ADDITION TO THE FILE
C          MUST BE UNDERTAKEN
C         
C          MUST CHECK IF THE KEY AND LOC CAN BE ADDED INTO
C          THE CURRENT RECORD OF KEYS IN 'ITKEY'
C         
C          OBTAIN LOC FROM THE LAST RECORD WRITTEN
91        IF (LOC.GT.0) GO TO 940
         LOCSAV=LOC
         LOC=FCB(I,5)+1
         IF (FCB(I,5).LT.FCB(I,9)) GO TO 910
         ERR=18
         GO TO 1000
910       FCB(I,5)=LOC
C         IF LOC =0 THEN RECORD HAS BEEN DELETED BUT KEY STILL EXISTS
         IF (LOCSAV.EQ.0) GO TO 942
C          THE KEY AND LOC CAN BE ADDED TO THE CURRENT
C          RECORD OF KEYS IN ITKEY IF IT IS NOT THE LAST ENTRY IN THE
C          BLOCK OF 50 ENTRIES
C          MUST FIND OUT WHERE THE NEW ENTRY MUST GO BY OBTAIN THE FIRST
C          LOCATION IN ITKEY BLOCK WHICH HAS AN EMPTY ENTRY LOCATION
         DO 92 IC=1,50
         ID=51-IC
         IF (ITKEY(ID,1,IK).NE.NULL) GO TO 93
92        CONTINUE
         ID=0
C          STORE KEY AND LOC IN APPROPRIATE ENTRY IN THE RECORD OF KEYS
93        ID=ID+1
         ITKEY(ID,1,IK)=KEY
         ITKEY(ID,2,IK)=LOC
C          CHECK IF A SORT MUST BE PERFORMED BY CHECKING IF KEY ADDED
C          IS LARGER THAN KEY PRECEDING IT
         IF (ID.EQ.1) GO TO 94
         IF (ITKEY(ID-1,1,IK).LT.ITKEY(ID,1,IK)) GO TO 94
         CALL SORTER(50,ITKEY(1,1,IK),50,2,0,1,KEE)
C          CHECK FOR SPECIAL CASE
C          CHECK FOR LAST LOCATION IN RECORD OF KEYS IS ONLY
C             AVAILABLE ID=50
         IF (ID.EQ.50) GO TO 95
C         RESET FCB(I,8)=0  OR AFTER A NEW BLOCK IS CREATED
939       FCB(I,6)=LOC
         FCB(I,8)=0
         FCB(I,7)=IDIST
         GO TO 98
C         
94        IF (ID.EQ.50) GO TO 95
         IPUT=ID
940       FCB(I,7)=IDISK
         FCB(I,6)=LOC
         FCB(I,8)=IPUT
         GO TO 98
C         WRITE TO A RECORD THAT WAS PREVIOUSLY DELETED
942       ITKEY(IPUT,2,IK)=LOC
         GO TO 940
C         
C          FOR OVER FLOW IN RECORD OF KEYS
C         
C          1)  TAKE LAST 10 ENTRIES AND PUT INTO NEW REOCRD OF KEYS
C          2)  MAKE NULL RECORDS OF THE LAST 10 ENTRIES IN OLD RECORD
C          3)  UPDATE 'KARY' TO ADD NEW HIGHER LEVEL KEY AND RECORD LOC
C          4)  DO A SORT FOR THE KEYS IN KARY FOR THIS FILE
C         
C          FCB(I,10) - DESIGNATES THE LAST RECORD ALLOCATED TO THIS FILE
C          FCB(I,11) - DESIGNATES THE RELATIVE ADDR OF THE FIRST RECORD
C          ALLOCATED TO THIS ON DISK (FILE KEYFIL)
C         
95        IF (F10).LT.FCB(I,13)) GO TO 950
         ERR=13
         GO TO 1000
C          OBTAIN DISK RELATIVE ADDRESS
950       FCB(I,10)=FCB(I,10)+1
         IRAD=FCB(I,10)+FCB(I,11)
C          MUST CHECK IF FIVE FILES OPEN BEFORE WRITING TO 'KEYFIL'
C !!!    IF (IOFIL.GE.MAXOFL) CALL CLOFIL(FCB(I,12))
C         DO THE WRITE ON 10 ENTRIES INTO NEW FILE
         WRITE(12#IRAD)((ITKEY(K1,K2,IK),K2=1,2),K1=41,50)
C          UPATE 'KARY' IRAD POINTS TO THE NEW ENTRY IN KARY AND
C          STORE THE FIRST KEY OF NEW RECORD
         KARY(IRAD,1)=ITKEY(41,1,IK)
         IBEG=FCB(I,11)+1
C         IRAD IS ALSO THE RELATIVE DISK ADDR OF THE NEW RECORD
         KARY(IRAD,2)=IRAD
C         RESET THE LAST 10 ENTRIES TO NULL IN OLD RECORD
         DO 97 LC=41,50
97        ITKEY(LC,1,IK)=NULL
         IDISK=ICON(IK,2)
         WRITE(12#IDISK)((ITKEY(K1,K2,IK),K2=1,2),K1=1,50)
C !!!    CLOSEFILE KEYFIL
C          MUST SORT THE HIGH LEVEL KEYS FOR THIS FILE
         CALL SORTER(FCB(I,10),KARY(IBEG,1),MAXBUK,2,0,1,KEE)
C         REWRITE CONFIL TO RECORD NEW KEY BUCKET - MUST BE DONE
         WRITE(11#1) JCON,((FCB(K1,K2),K2=1,13),K1=1,14)
         WRITE(11#2) ((KARY(K1,K2),K2=1,2),K1=1,128)
         WRITE(11#3) ((KARY(K1,K2),K2=1,2),K1=129,MAXBUK)
C !!!    CLOSEFILE CONFIL
C          RESET FCB AND DO WRITE
         IDIST=IRAD
         GO TO 939
C          DO THE WRITE
98        KEY=LOC
         ISARAH=FCB(I,4)
         WRITE(I#LOC) (IAREA(K),K=1,ISARAH)
         GO TO 1000
C         
C          WRITE DIRECT KEY=TO A DISK DATA ADDRESS
C         
99        LOC=KEY
         FCB(I,6)=LOC
C         MUST CHEX IF THE PHYSICAL WRIT IS NEXT LOC TO WRIT ON FILE
         IF (LOC.LE.FCB(I,5)) GO TO 98
         IF (LOC.EQ.(FCB(I,5)+1)) GO TO 988
         ERR=22
         GO TO 1000
988       FCB(I,5)=FCB(I,5)+1
         GO TO 98
C         
C          FROM FCB(I,10) AND FCB(I,11) OBTAINS THE AREA IN 'KARY' FOR THE
C          FIRST LEVEL OF SEARCH TO OBTAIN THE DISK ADD OF THE RECORD
C          DESIRED
C         
2000      ILAS=FCB(I,11)+FCB(I,10)
         IONO=FCB(I,10)
         DO 200 K1=1, IONO
         IF (KEY.GE.KARY(ILAS-K1+1,1)) GO TO 201
200       CONTINUE
         ERR=200
         GO TO 1000
C         
C          OBTAIN THE DISK ADDRESS OF THE RECORD OF KEYS
C          WHICH COULD CONTAIN THE KEY BEING PROCESSED
C         
201       IDISK = KARY (ILAS-K1+1,2)
         GO TO 206
C         
C          MUST GO THROUGH THE BINARY SEARCH TO OBTAIN THE CORRECT KEY
C         
204       CALL BINTAB(IK,KEY,LOC,ITKEY,IPUT)
C          CHECK FOR A READGT (SPECIAL)
         IF (IPUT.EQ.(-99)) GO TO 72
C          NO KEY WAS FOUND IF A READ OCCURRED RETURN WITH ERROR
C          IF WRITE MUST ADD A NEW KEY AND ADD A NEW DATA RECORD
C          IGO=1-READ  IGO=2-WRITE  IGO=3-DELETE
C          PROCESS READ,WRITE OR DELETE
         GO TO (602,91,102), IGO
C         
C          THE FILE IS OPEN - 1) CHECK IF THE RECORD OF KEYS IN ITKEY IS THE
C          BLOCK OF KEYS DESIRED
C                             2) IF TRUE - GO TO BINTAB FOR PROCESSING (204)
C         
C                               3) IF FALSE
C          MUST CHECK IF FIVE FILES ARE OPEN
C             A)  IF NOT - CAN READ FROM 'KEYFIL' AND PROCESS
C             B)  IF YES - MUST CLOSEFILE (I) READ 'KEYFIL' TO
C                 OBTAIN CORRECT RECORD OF KEY AND PROCESS.
C          IK POINTS TO ITKEY SUBCRIPT WHERE THE REC OF KEY IS STORED
C          IS CORRECT RECORD OF KEYS IN ITKEY
206       DO 207 IK=1,MAXOFL
         IF (ICON(IK,1).EQ.I) GO TO 208
207       CONTINUE
         ERR=203
         GO TO 1000
C         
C          CHECK IF IDISK IS SAME AS ICON (IK,2) - CORRECT BLOCK IN CORE
C         
208       IF (ICON(IK,2).EQ.IDISK) GO TO 204
C          MUST CHECK IF FIVE FILES ARE OPEN
209      CONTINUE
         CALL FIND(I,ITKEY,IK,IDISK,ICON,ERR)
         IF (ERR.NE.0) GO TO 1000
         WRITE(11#1) JCON,((FCB(K1,K2),K2=1,13),K1=1,NFILE)
C !!!    CLOSEFILE CONFIL
         GO TO 204
C         
C          DELETE  DELETE  DELETE
C         
C          TO DELETE A RECORD YOU ZERO OUT THE DISK DATA ADDRESS
C             WITH THE 'RECORD OF KEYS'
C         
100       CONTINUE
         IGO=3
         IF (KEY.GT.10000) GO TO 2000
         ERR=15
         GO TO 1000
C         CHECK IF LOC=-1
102       IF(LOC.GT.0) GOTO 103
         ERR=17
         GO TO 1000
C          STORE ZEROS IN LOC OF THE ENTRY ASSOCIATED WITH
C             THE RECORD TO BE DELETED
103       ITKEY(IPUT,2,IK)=0
         GO TO 1000
C         
C          CLEANUP PORTION OF IOMOD
C         
C          MUST CLOSE ALL FILES THAT ARE OPEN
C          MUST RESET FCB AND ICON FOR EACH FILE TO BE CLOSED
C         
C          MUST STORE ALL RECORD OF KEYS THAT ARE ACTIVE
C             INTO 'KEYFIL'
C          MUST STORE THE 'FCB'S, 'KARY'AND CONTROL WORD INTO 'CONTROL'
C         
110       IF (IWFCB.EQ.0) GO TO 114
         DO 112 IK=1,5
         IF (ICON(IK,1).EQ.0) GO TO 112
C          OBTAIN FILE NAME AND CLOSE
         I=ICON(IK,1)
C !!!    CALL CLOFIL(FCB(I,12))
         FCB(I,3)=0
         FCB(I,6)=0
         FCB(I,7)=0
         FCB(I,8)=0
         ICON(IK,1)=0
C          STORE ITKEY INTO KEYFIL
         IDISK=ICON(IK,2)
         IF (IDISK.EQ.0) GO TO 112
         WRITE(12#IDISK) ((ITKEY(K1,K2,IK),K2=1,2),K1=1,50)
         ICON(IK,2)=0
112        CONTINUE
C         
C          STORE FCB AND KARY AND JCON  -200 WORDS/RECORD
C          JCON WILL BE STORED IN THE FCB RECORD OF '
C         
         WRITE(11#1) JCON,((FCB(K1,K2),K2=1,13),K1=1,NFILE)
         WRITE (11#2) ((KARY(K1,K2), K2=1,2), K1=1,128)
         WRITE (11#3) ((KARY(K1,K2), K2=1,2), K1=129,MAXBUK)
C !!!    CLOSEFILE KEYFIL
C !!!    CLOSEFILE CONFIL
         MAXOFL=5
         IOFIL=0
         GO TO 1000
C          ATTEMPT TO WRITE FCB BEFORE IT HAS BEEN READ
114       TYPE 1114
1114     FORMAT(1X,'CLEAN UP ERROR')

         ERR=300
         GO TO 1000
C         
C          INITIAL  INITIAL  INITIAL  INITIAL
C          INITIALIZATION PORTION OF IOMOD
C         
C          MUST READ THE CONTROL WORD,FCB'S AND 'KARY' FROM
C             THE 'CONTFIL' FILE   RESET ICON AND HAVE
C             ALL FILES CLOSED
C         
120       READ(11#1) JCON,((FCB(K1,K2),K2=1,13),K1=1,14)
         READ(11#2) ((KARY(K1,K2),K2=1,2),K1=1,128)
         READ(11#3) ((KARY(K1,K2),K2=1,2),K1=129,MAXBUK)
C          CLEAR ICON
         DO 121 IK=1,5
         DO 121 K1=1,2
121       ICON(IK,K1)=0
C          CLEAR FCB
         DO 122 I=1,NFILE
         FCB(I,3)=0
         FCB(I,6)=0
         FCB(I,7)=0
122       FCB(I,8)=0
C !!!    CLOSEFILE CONFIL
C          SET FCB WORD TO INDICATE FCB HAS BEEN READ
         IWFCB=1 
         MAXOFL=5 
         IOFIL=0
         GO TO 1000
C         
C          SPACE  SPACE  SPACE  SPACE  SPACE  SPACE
C         
C          SPACE PORTION OF IOMOD
C         
C          MUST OBTAIN THE AMOUNT OF RECORDS LEFT ON DISK
C          IAREA WILL TRANSFER THIS INFO TO SPACE ROUTINE
C         IAREA(2) HAS LAST LOC USED -- LOC OF NEXT RECORD TO BE ADDED
C         
130       IAREA(1)=FCB(I,9)-FCB(I,5)
         IAREA(2)=FCB(I,5)
         GO TO 1000
C         
C          RESET  RESET  RESET  RESET
C         
C          RESET PORTION OF IOMOD
C          BEFORE RESETT MUST CLOSEFILE
C         
C          FCB(I,5)-RESET TO FIRST RECORD
C          FCB(I,6)-SET TO 0
C          FCB(I,7)- SET TO 0
C          FCB(I,8)-SET TO 0
C          FCB(I,10)=SET TO 1 - ALWAYS 1 'RECORD OF KEYS' IN USE
C         
140       CONTINUE
         ISTRT=FCB(I,11)+1
         IEND=FCB(I,11)+FCB(I,13)
         IF (FCB(I,3).EQ.0) GO TO 1420
C         FILE IS OPEN
         DO 1410 ILOC=1,MAXOFL
         IF (ICON(ILOC,1).EQ.I) GO TO 1440
1410      CONTINUE
C         ERROR CONDITION SHOULD NOT HAPPEN
         GO TO 1490
1420      DO 1430 ILOC=1,MAXOFL
         IF (ICON(ILOC,1).EQ.0) GO TO 1440
1430      CONTINUE
C         ERROR --MORE THAN 5 FILES OPEN--- USER MUST CLOSE ONE
         GO TO 1490
1440      DO 1450 IL=1,50
         ITKEY(IL,1,ILOC)=NULL
         ITKEY(IL,2,ILOC)=0
1450      CONTINUE
         DO 1460 IX=ISTRT,IEND
         KARY(IX,1)=NULL
         KARY(IX,2)=0
         WRITE(12#IX)((ITKEY(KK,KK1,ILOC),KK1=1,2),KK=1,50)
1460      CONTINUE
C !!!    CLOSEFILE KEYFIL
         KARY(ISTRT,1)=0
         KARY(ISTRT,2)=ISTRT
         FCB(I,5)=IHDR(I)
         FCB(I,6)=0
         FCB(I,8)=0
         FCB(I,7)=0
         FCB(I,10)=1
         GO TO 1000
1490      ERR=140
         GO TO 1000
C         SWITCH TWO FILES--FILE AND FILE TWO
C         ARE INTERCHANGED  --FILES MUST NOT BE OPEN TO SWITCH
C         KEY HAS SECOND FILE NAME-----
150       CONTINUE
         IF (FCB(I,3).EQ.1) GO TO 157
         DO 152 J=1,NFILE
         IF (FCB(J,1).EQ.KEY) GO TO 155
152       CONTINUE
         ERR=151
         GO TO 1000
155       ITEMP=FCB(I,1)
         FCB(I,1)=FCB(J,1)
         FCB(J,1)=ITEMP
         ITEMP=FCB(I,2)
         FCB(I,2)=FCB(J,2)
         FCB(J,2)=ITEMP
         GO TO 1000
157       ERR=150
1000      CONTINUE
         ERROR=ERR
         KEYRW=KEY
         RETURN
         END
C         
C         BINTAB    BINTAB    BINTAB      BINTAB
C         
C         BINTAB WILL GO THROUGH A BINARY SEARCH OF AN INDEX TABLE
C         TO OBTAIN THE RECORD LOCATION ON DISK -THE KEY WILL BE
C         COMPARED IN THIS SEARCH
C         
C         ARGUEMENTS OF THE BINTAB ROUTINE
C         
C           IK - THE SUBSCRIPT OF THE BLOCK OF KEYS IN ITKEY TO BE SEARCHED
C           KEY - THE VALUE TO SEARCH FOR    (GIVEN)
C           LOC- DISK DATA ADDRESS   (RETURNED)
C           ITKEY- AREA WHERE  KEYS,LOCATIONS  ARE STORED
C           IPUT - THE PLACE IN ITKEY WHERE THE KEY WAS FOUND
C                    THE KEY VALUE WAS FOUND
C           EACH KEY BUCKET IS DATA'D TO CONTAIN 50 ENTRIES
C         
C           IF LOC IS SET TO -1 KEY WAS NO FOUND
C           IPUT WILL BE RETURNED AS -99 IF A HIT WAS NOT MADE IN THE
C           CURRENT KEY BUCKET.  THIS SIGNALS IOMOD TO GET THE NEXT BUCKET.
C         
         SUBROUTINE BINTAB(IKK,KEY,LOC,ITKEY,IPUT)
         DIMENSION ITKEY(50,2,5)
         DATA NULL/O377777777777/,IDEL/0/,IGER/-99/
         IK=IKK
         IMIN=0
         IMAX=51
4         IF ((IMAX-IMIN).LE.1) GO TO 5
         I=(IMIN+IMAX)/2
         IF (ITKEY(I,1,IK)-KEY) 1,7,3
1         IMIN=I
         GO TO 4
3         IMAX=I
         GO TO 4
C         IF NO HIT-CHECK IF A GT OR EQ - IF NOT RETURN IN KEY=(-1)
5         IF (IPUT.NE.IGER) GO TO 11
C          CHECK FOR A EMPTY RECORD OR A DELETED RECORD
6         IF (ITKEY(I,1,IK).GT.KEY) GO TO 8
         I=I+1
8         IF (ITKEY(I,1,IK).NE.NULL) GO TO 9
         RETURN
9         IF (ITKEY(I,2,IK).NE.IDEL) GO TO 10
         I=I+1
         GO TO 6
C           A SUCCESSFUL HIT
7         LOC=ITKEY(I,2,IK)
         IF (LOC.EQ.IDEL.AND.IPUT.EQ.IGER) GO TO 5
         IPUT=I
         RETURN
C          HIT ON GREATER THAN
10        LOC=ITKEY(I,2,IK)
         IPUT=I
         RETURN
C         LOC NOT FOUND
11        LOC=(-1)
         RETURN
         END
C         
C         THIS ROUTINE WILL READ A KEYBUCKET INTO CORE
C         IF AN ARRAY IS CURRENTY IN CORE FIND SALL
C         RE-WRITE THE ARRAY TO KEYFIL
C         
         SUBROUTINE FIND(I,ITKEY,IK,IDISK,ICON,IERR)
         DIMENSION ITKEY(50,2,5),ICON(5,2)
C !!!    FILENAME KEYFIL
C !!!    DATA KEYFIL/'KEYFIL  '/
         IF (ICON(IK,1).EQ.I) GO TO 50
         IERR=201
         GO TO 150
50        IF (ICON(IK,2).EQ.0) GO TO 100
         IOLD=ICON(IK,2)
         WRITE(12#IOLD) ((ITKEY(K,KK,IK),KK=1,2),K=1,50)
100       ICON(IK,2)=IDISK
         READ(12#IDISK) ((ITKEY(K,KK,IK),KK=1,2),K=1,50)
C !!!    CLOSEFILE KEYFIL
         IERR=0
150       RETURN
         END
C         
C         THIS ROUTINE WILL CLOSE A FILE
C         
C !!!    SUBROUTINE CLOFIL(JFCB)
C !!!    FILENAME SOL
C !!!    DATA SOL/'        '/
C !!!    CALL MOVE(JFCB,SOL,1)
C !!!    CLOSEFILE SOL
C !!!    RETURN
C !!!    END
        SUBROUTINE SORTER(INUM,IA,M,LEN,NKEYS,KEYS)
        DIMENSION IA(50,2),IREC(50),IDBLE(100),IB(50,2)
        DO 5 I=1,INUM
5       IREC(I)=I
        DO 10 I=1,INUM
        KD=I*2-1
        IDBLE(KD)=IA(I,1)
        IDBLE(KD+1)=IA(I,2)
10      CONTINUE
        CALL SORT2(IDBLE,IREC,1,INUM)
        DO 30 I=1,INUM
        IB(I,1)=IA(IREC(I),1)
        IB(I,2)=IA(IREC(I),2)
30      CONTINUE
        DO 40 I=1,INUM
        IA(I,1)=IB(I,1)
        IA(I,2)=IB(I,2)
40      CONTINUE
        RETURN
        END
	SUBROUTINE SORT2(IWORK,IREC,II,JJ)
	DIMENSION IWORK(1),IREC(1),IL(16),IU(16)
	DOUBLE PRECISION IWORK
	INTEGER   T,TT
	M =1
	I = II
	J = JJ
C  RE-ARRANGE IREC AS IWORK IS SORTED
   25 IF (I.GE.J) GO TO 60
   30 K=I
      IJ=(J+I)/2
      T=IREC(IJ)
      IF(IWORK(IREC(I)).LE.IWORK(T))GO TO 35
      IREC(IJ)=IREC(I)
      IREC(I)=T
      T=IREC(IJ)
   35 L=J
      IF(IWORK(IREC(J)).GE.IWORK(T)) GO TO 45
      IREC(IJ)=IREC(J)
      IREC(J)=T
      T=IREC(IJ)
      IF(IWORK(IREC(I)).LE.IWORK(T)) GO TO 45
      IREC(IJ)=IREC(I)
      IREC(I)=T
      T=IREC(IJ)
      GO TO 45
   40 IREC(L)=IREC(K)
      IREC(K)=TT
   45 L=L-1
      IF (IWORK(IREC(L)).GT.IWORK(T)) GO TO 45
      TT=IREC(L)
   50 K=K+1
      IF(IWORK(IREC(K)).LT.IWORK(T))GO TO 50
      IF(K.LE.L)GO TO 40
      IF((L-I).LE.(J-K)) GO TO 55
      IL(M)=I
      IU(M)=L
      I=K
      M=M+1
      GO TO 65
   55 IL(M)=K
      IU(M)=J
      J=L
      M=M+1
      GO TO 65
   60 M=M-1
      IF(M.EQ.0) GO TO 80
      I=IL(M)
      J=IU(M)
   65 IF(J-I.GE.1) GO TO 30
      IF(I.EQ.1) GO TO 25
      I=I-1
   70 I=I+1
      IF(I.EQ.J) GO TO 60
      T=IREC(I+1)
      IF(IWORK(IREC(I)).LE.IWORK(T)) GO TO 70
      K=I
   75 IREC(K+1)=IREC(K)
      K=K-1
      IF(IWORK(T).LT.IWORK(IREC(K))) GO TO 75
      IREC(K+1)=T
      GO TO 70
   80 CONTINUE
	RETURN
	END
0 kb