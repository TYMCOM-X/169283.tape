FIND NCOPIES,QSAV,CSAV,C.STR.P,COM.STR(72/CPW),%NXTSRC,PROMPT:,S,E,NO.LST,NO.REL,A.PTR,PCTR.PTR
FIND %R.LEAS.SYM.TBL,INIT:
GLOBAL EOF3:,%PASS2,%PASS2B,%LIS.LN,PRINTED,A,%W.REL,%INIT.W.REL,BIN,%PR.FILE
GLOBAL %BEG.LIS.LN,%END.LIS.LN,%LIS.DEF,%LIS.REF
FIND C,%PR,%ERR,%THING.GETTER,TOK,VAL,PCTR,Q,%MESS,%FIL.ERR
FIND OPTAB,NALLOPS
FIND MAP(0:127),%EVAL,F,L,%NEXTLN,%GETLN
FIND SYMTAB,LABPNT,SYMN,SYMD,SYME,SYMCC,SYMPNT,CREF,LABCC,NOCORE:
FIND %INITPRIF,%PRIF,%PRAE,TMPLT,OPVL
FIND BEG.LIT.POOL,BEG.IND.POOL,CUR.IND.ADD,CUR.LIT.ADD,END.IND.POOL,NEWMODE,END.LIT.POOL
FIND SYMBUF(0:SYMBUF.L),INDTAB,%SYMPOS,LITTAB,%GET.SYM,%DMP,%D.NXT.SYM
FIND F.VAR(50),F.LST,F.ERR,LINE.NUM,%PR.TAB
FIND EDIT10,PAGE.NUM,PRINT.LINE,NEW.PAGE

%PASS2
LOCAL B,M,%P2SCAN,I,%DUMP,%ABX,LINES

C.STR.P _ CHPT(COM.STR,-1)  !SET COMMAND STRING POINTER BACK TO FIRST SOURCE FILE
NXTSRC

IF NOT NO.REL THEN INIT.W.REL
PCTR_0
LINE.NUM_0
BEG.LIS.LN
NCOPIES _ -1
CUR.LIT.ADD _ BEG.LIT.POOL <== -1
CUR.IND.ADD _ BEG.IND.POOL <== -1
IF S#1 THEN MESS(E,'$ENDIF MISSING$')
INITPRIF

%%PASS2B

GETLN
  C_NCHV Q  !1ST CHAR

WHILE 1=1 THEN DO  !DUMMY LOOP

  IF NCOPIES < 0 THEN P2SCAN ELSE DO   !RPT1 DIRECTIVE
        QSAV _ Q
        CSAV _ C
        IF NCOPIES = 0 THEN LIS.LN(ALONE)
        WHILE DEC NCOPIES >= 0 THEN [P2SCAN; Q_QSAV; C_CSAV]
        TOK _ 0    !SO NEXTLN WILL FLUSH STATEMENT
        END
  NEXTLN
  END

EOF3: IF ERRNUM#EOFERR THEN [FIL.ERR(F.VAR); GO PROMPT] ELSE DO
  IF NXTSRC THEN PASS2B
END.LIS.LN
 IF CUR.IND.ADD#-1#BEG.IND.POOL THEN DO
   IF CUR.IND.ADD> END.IND.POOL THEN DO  !INDIRECT OVERFLOW
     MESS(E,'$OVERFLOW OF INDIRECT POOL, USE$$   I  *+')
     I _ L <== E
     PR(CUR.IND.ADD-BEG.IND.POOL,8)
     L _ I
     MESS(E,'$')
     END
   IF NOT NO.LST THEN [MESS(L,'$$INDIRECT POOL$'); LINES_LINES+3]
   BEG.LIS.LN
   DUMP(INDTAB,BEG.IND.POOL,CUR.IND.ADD)
   END.LIS.LN
   END
 IF CUR.LIT.ADD#-1 THEN DO
   IF CUR.LIT.ADD> END.LIT.POOL THEN DO   !LITERAL POOL OVERFLOW
     MESS(E,'$OVERFLOW OF LITERAL POOL, USE$$   L  *+')
     I _ L <== E
     PR(CUR.LIT.ADD-BEG.LIT.POOL,8)
     L _ I
     END
   IF NOT NO.LST THEN [MESS(L,'$LITERAL POOL$'); LINES_LINES+2]
   BEG.LIS.LN
   DUMP(LITTAB,BEG.LIT.POOL,CUR.LIT.ADD)
   END.LIS.LN
   END
IF NOT NO.REL THEN DO
   WREL(0,0)  !FINAL CALL WILL CLEAR OUT ANYTHING IN WD CURRENTLY
   SETCP(BIN,OCT 10001)   !PDP SAV NEEDS NEXT 3 WDS AT END
   W(BIN,OCT 777777000776)
   W(BIN,OCT 254200000777)
   W(BIN,OCT 254000000777)
   CLOSE(BIN)
   END
   CLOSE(F)
IF NOT NO.LST THEN CLOSE(L)
 R.LEAS.SYM.TBL(SYMTAB)
 R.LEAS.SYM.TBL(LITTAB)
 R.LEAS.SYM.TBL(INDTAB)
 GO INIT
 END

%P2SCAN
LOCAL A.SAVE

   IF THING.GETTER = STAR THEN [LIS.LN(ALONE); RETURN]
   IF TOK = SPACE THEN [LABPNT_0; GO X]
   IF TOK # SYM THEN GO Y
   SYMUPK(SYMN,SYME,SYMD,) _ ^(LABPNT _ SYMPOS(SYMTAB))
   LABCC_SYMCC
   IF NOT SYME THEN LIS.DEF
   IF SYMD#0 THEN ERR('$DUPLICATE DEFINITIONS$')
   IF THING.GETTER # SPACE THEN [ERR('$SPACE EXPECTED$'); GO Y]
X: IF THING.GETTER = SYM THEN GO Z
Y: IF TOK = TERM THEN [LIS.LN(ALONE);RETURN]  !NULL LINE
   A _ EVAL
   LISLN(BOTH)  !DATA WORD
   RETURN
Z: [BPW-21,5,16]*[,TMPLT,OPVL] _ ^SYMPOS(OPTAB)
   DO TMPLT OF 0:NUM.TMPLTS
0: A_0; LIS.LN(BOTH); ERR('$ILLEGAL OPCODE$')
 1: A_OPVL; LIS.LN(BOTH)
2: 3: 4:  5: IF THING.GETTER # SPACE THEN ERR('$SPACE EXPECTED$')
THING.GETTER
    IF A _ EVAL > OCT 777 THEN [A _ A BAND OCT 777; ERR('$TRUNC TO 9$')]
    A _ OPVL + A
    LIS.LN(BOTH)
 6: IF THING.GETTER # SPACE THEN ERR('$SPACE EXPECTED$')
THING.GETTER
    A _ EVAL
    EIF TOK # COMMA THEN DO  !NO B,X, OR I (5,6, OR 7)
      IF A > OCT 3777 THEN DO  !CAN'T GO DIRECT
        EIF A<=PCTR OR A-PCTR > OCT 777 THEN DO
          SYMBUF(0) _ 1
          SYMBUF(1) _ A SHL 1  !AVOID FUNNY BIT
          IF ^(I_SYMPOS(INDTAB))=VIRGIN THEN ^I _ INC CUR.IND.ADD
          A _ OCT 7000 + ^I - 1  !VAL STORED IS 1 HIGH TO AVOID ZERO

          END
        ELSE A _ RELATIVE + A - PCTR - 1
        END

      A _ OPVL + A
      END
    ELSE DO
      IF A > OCT 777 THEN [A_A BAND OCT 777; ERR('$9 BITS$')]
      EIF THING.GETTER = NUM THEN DO
        IF NOT 4 < VAL < 8 THEN ERR('$ILLEGAL 2ND PARAMETER$')
        A _ OPVL + VAL SHL 9 + A  !5,6, OR 7
        END
      ELSE DO  !LOOK FOR B,X, OR I
        EIF B _ NCHV SYMPNT = $B THEN M _ OCT 6000  !INDEX BY B REG
        ORIF B = $X THEN M _ OCT 5000          !INDEX BY X REG
        ORIF B = $I THEN M _ OCT 7000          !PROGRAMMER IS FORCING INDIRECT
        ELSE ERR('$ILLEGAL 2ND PARAMETER$')
        IF NCHV SYMPNT # EOLIT THEN ERR('$ILLEGAL 2ND PARAMETER$')
        A _ OPVL + M + A
        END
      END
      LIS.LN(BOTH)
 7: IF THING.GETTER # SPACE THEN ERR('$SPACE EXPECTED$')
    A _ OPVL + ABX SHL 3 + ABX
    IF TOK = COMMA THEN DO
      THING.GETTER
      IF NCHV SYMPNT = $V THEN A _ A + OCT 400   !BIT FOR IF OVERFLOW
      END
   LIS.LN(BOTH)

 9: IF THING.GETTER # SPACE THEN ERR('$SPACE EXPECTED$')
    THING.GETTER
    A _ OPVL
    A.SAVE _ EVAL
    IF TOK = COMMA THEN DO
      IF THING.GETTER = SYM AND NCHV SYMPNT = $I &
        THEN A.SAVE _ A.SAVE BOR OCT 100000 &
        ELSE ERR('$ILLEGAL 2ND PARAMETER$')
      END
    LIS.LN(BOTH); A_A.SAVE; LIS.LN(BOTH)
10: IF THING.GETTER # SPACE THEN ERR('$SPACE EXPECTED$')
THING.GETTER
    IF A _ EVAL > OCT 77 THEN [A _ A BAND OCT 77; ERR('$6 BITS$')]
    A _ OPVL + A
    IF TOK # COMMA THEN ERR('$COMMA EXPECTED$')
    THING.GETTER
    A.SAVE _ EVAL
    LIS.LN(BOTH); A_A.SAVE; LIS.LN(BOTH)
11: IF THING.GETTER # SPACE THEN ERR('$SPACE EXPECTED$')
THING.GETTER
    IF A _ EVAL > OCT 777 THEN [A _ A BAND OCT 77; ERR('$9 BITS$')]
    A _ OPVL + A
    IF TOK # COMMA THEN ERR('$COMMA EXPECTED$')
    THING.GETTER
    A.SAVE _ EVAL
    LIS.LN(BOTH); A_A.SAVE; LIS.LN(BOTH)
AE.DIR: EIF OPVL=E.DIR OR OPVL=7 !RPT1! THEN [PRAE; LIS.LN(NO.PCTR)]
    ORIF OPVL=ASC.DIR THEN PRAE
    ELSE DO
        A.SAVE_PCTR
        PRAE
        A.SAVE<=>PCTR
        LIS.LN(NO.OCTAL)
        A.SAVE<=>PCTR
    END
IF.DIR: PRIF
END  !DO TMPLT OF

RETURN

%ABX
EIF THING.GETTER=COMMA THEN RETURN 0   !NULL SOURCE (OR DESTINATION)
ORIF TOK=SYM THEN DO
  I_0  !INIT DIGIT TO BE 1 THRU 7 SOON
  WHILE B_NCHV SYMPNT#EOLIT THEN DO   !P IS POINTING TO BEGINNING OF SYM
    EIF B=$A THEN IF I BAND 1 THEN ERR("$2 A'S$") ELSE I_I+1  !A FOUND
    ORIF B=$B THEN IF I BAND 2 THEN ERR("$2 B'S$") ELSE I_I+2  !B
    ORIF B=$X THEN IF I BAND 4 THEN ERR("$2 X'S$") ELSE I_I+4  !X
    ELSE ERR('$A,B, OR X EXPECTED')
    END
  THING.GETTER  !SET UP TOK, SPACE OR COMMA EXPECTED
  RETURN I
  END
ELSE ERR('$UNEXPECTED STUFF$')
RETURN -1
END ABX
END P2SCAN

%LIS.LN(HOW)
LOCAL I,MSEC,SEC,MINIT
IF HOW=ALONE AND PRINTED THEN RETURN
IF NO.LST THEN DO
  IF HOW=BOTH THEN [W.REL(PCTR,A); INC PCTR]
  RETURN
  END
IF NEW.PAGE OR INC LINES>53 THEN DO
  LINES_0
  END.LIS.LN
  W(L, OCT 14)  !FORM FEED
  MESS(L,'PAGE ')
  PR(PAGE.NUM,10)
  MESS(L,'  ')
  PR.FILE(L,F.VAR)
  MESS(L,'  ')
  EXU(OCT 47,OCT 16,OCT 14)   !DATE AS AN INTEGER
  I _ ^OCT 16
  [I;MSEC] _ I DIVMOD 31; INC MSEC  !DAY OF THE MONTH IN MSEC
  [I;SEC] _ I DIVMOD 12             !MONTH-1 IN SEC
  I _ I + 64                      !YEAR IN I
  IF 0<=SEC<=11 THEN DO SEC OF 0:11
 0: MINIT_'JAN'
 1: MINIT_'FEB'
 2: MINIT_'MAR'
 3: MINIT_'APR'
 4: MINIT_'MAY'
 5: MINIT_'JUN'
 6: MINIT_'JUL'
 7: MINIT_'AUG'
 8: MINIT_'SEP'
 9: MINIT_'OCT'
10: MINIT_'NOV'
11: MINIT_'DEC'
END ELSE MINIT_'BUG'
PR(MSEC,10); W(L,$-); MESS(L,MINIT); W(L,$-); PR(I,10); MESS(L,'  ')
  EXU(OCT 47,OCT 16,OCT 23)  
  I _ ^OCT 16  !TIME OF DAY IN MILLISECONDS
  [I;MSEC] _ I DIVMOD 1000
  [I; SEC] _ I DIVMOD   60
  [I;MINIT] _ I DIVMOD   60
  PR(I,10); W(L,$:); PR(MINIT,10);W(L,$:);PR(SEC,10);W(L,$.)
  IF MSEC<100 THEN W(L,$0)
  PR(MSEC,10)
  MESS(L,'$$')
  NEW.PAGE _ 0
  BEG.LIS.LN
  END
IF CREF THEN [W(L,OCT 177); W(L,OCT 103); W(L,OCT 11)] !CREF INFO

DO HOW OF 4
BOTH: I_PCTR.PTR
      REPEAT 5 W(L,NBYV I+$0)  !THE 5 DIGITS OF THE PROGRAM COUNTER
      W(L,$	)
      W.REL(PCTR,A)    !PUT OCTAL ON REL FILE AT PROPER LOCATION
   INC PCTR
      I_A.PTR; REPEAT 6 W(L,NBYV I+$0); W(L,$	)
NO.OCTAL: I_PCTR.PTR; REPEAT 5 W(L,NBYV I+$0); W(L,$	)
          REPEAT 6 WX(L,$ )
          W(L,$	)   !TAB INSTEAD OF 7TH SPACE
ALONE: REPEAT 6 WX(L,$ )
       W(L,$	)  !TAB INSTEAD OF 7TH SPACE
       REPEAT 6 WX(L,$ )
       W(L,$	)  !TAB INSTEAD OF 7TH SPACE
NO.PCTR: REPEAT 6 WX(L,$ )
         W(L,$	)  !TAB INSTEAD OF 7TH SPACE
         I_A.PTR; REPEAT 6 W(L,NBYV I+$0); W(L,$	)
END
EIF NOT PRINTED THEN DO
  I_PRINT.LINE
  WHILE W(L,NCHV I) # CARRET THEN NULL
  INC PRINTED
  END
ELSE W(L,CARRET)
BEG.LIS.LN
RETURN

%PR.FILE(F,FIDP())   !PRINT FILE NAME
DEF SXPT(X) AS [6,6,24]*[36,6,(X)]
LOCAL CHAR,SIXPTR

SIXPTR _ SXPT(@NAMARG(FIDP))
LOOP [REPEAT 6; WHILE CHAR_NCHV SIXPTR#0; W(F,CHAR+ OCT 40)]
IF HW(@EXTARG(FIDP))#0 THEN DO
  W(F,$.); SIXPTR _ SXPT(@EXTARG(FIDP))
  LOOP [REPEAT 3; WHILE CHAR_NCHV SIXPTR#0; W(F,CHAR+OCT 40)]
  END
RETURN

END PR.FILE

END LIS.LN

%BEG.LIS.LN
IF CREF THEN [W(L,OCT 177); W(L,OCT 102)]
RETURN
END BEG.LIS.LN

%END.LIS.LN
IF CREF THEN [W(L,OCT 177); W(L,OCT 104)]
RETURN
END END.LIS.LN

%LIS.REF(X)
LOCAL I,P
IF CREF THEN DO
   WX(L,OCT 1)
   I_SYMCC MIN 6
   WX(L,I)
   P_CHPT(@SYMBUF(1),-1)
   REPEAT I W(L,NCHV P)
END
RETURN
END LIS.REF

%LIS.DEF
IF CREF THEN [LIS.REF(LABPNT); WX(L,OCT 2)]
RETURN
END LIS.DEF

%DUMP(TAB,BEG.TAB,CUR.ADD)
LOCAL NOMORE:,ARRAY(),I

ARRAY_BLOCK( (CUR.ADD-BEG.TAB+130)/131, 0, NOCORE)  !GRAB SOME CORE

DMP(TAB,NOMORE)  !GET READY TO DUMP TABLE

REPEAT CUR.ADD-BEG.TAB+10 DO
  GET.SYM(I_D.NXT.SYM)
  ARRAY(^I-BEG.TAB) _ SYMBUF(1) SHR 1  !THE ADDRESS SHOULD BE IN ^I
! PR(SYMBUF(1) SHR 1,8)    DEBUG
  END
ERR('$BUG IN DUMP$')

NOMORE: PCTR _ BEG.TAB
        I _ 0
        WHILE PCTR < CUR.ADD THEN DO
          A _ ARRAY(INC I)  !2ND COLUMN WILL BE VALUE OF ITEM
          LISLN(BOTH)  !1ST COLUMN WILL SHOW ADDRESS
          END
        RELEASE((CUR.ADD-BEG.TAB+130)/131, ARRAY, NOCORE)  !RELEASE CORE
RETURN
END DUMP
END PASS2

%W.REL(LOC,OCTAL)
LOCAL PLOC,WD,OLDWD,I,J

IF NO.REL THEN RETURN
IF WD#-1 THEN DO   !SOMETHING IN WD?
  IF PLOC=LOC-1 THEN DO   !DOES IT GO WITH CURRENT OCTAL?
    WD_WD BOR OCTAL SHL 4 BOR 1     !YES, PUT EM TOGETHER, TURN ON 1 BIT
    SETCP(BIN,(LOC+2)/2)      !AND WRITE THEM AT
    W(BIN,WD)             !THE PROPER PLACE
    WD_-1
    RETURN
    END
  I_SIZE(BIN)-1
  IF J_SETCP(BIN,(PLOC+2)/2)>I THEN OLDWD_0 ELSE [OLDWD_R(BIN);SETCP(BIN,J)]
  W(BIN,WD BOR (OLDWD BAND OCT 3777761))  !NO, PUT LEFT PART OUT
  WD_-1
  END
IF LOC MOD 2 THEN DO   !IS LOC ODD OR EVEN?
  I_SIZE(BIN)-1
  IF J_SETCP(BIN,(LOC+2)/2)>I THEN OLDWD_0 ELSE [OLDWD_R(BIN);SETCP(BIN,J)]
  W(BIN,(OLDWD BAND OCT 777774000002) BOR (OCTAL SHL 4) BOR 1)
  RETURN   !PUT OCTAL IN RIGHT PART OF APPROP FILE WORD
  END
WD_OCTAL SHL 20 BOR 2  !PUT OCTAL IN LEFT PART OF WORD, TURN ON 2 BIT
PLOC_LOC          !SAVE LOC IT BELONGS IN
RETURN

%INIT.W.REL
WD _ PLOC _ -1
W(BIN,OCT 770000000777) !PDP SAV NEEDS THIS AS 1ST WD
RETURN
END INIT.W.REL

END W.REL

  