!  CCS ROUTINES COMMON TO EDIT AND DEBUG MODES.
!  IOCSU AND PFU MUST PRECEDE.

!  MACHINE DEPENDENT MACROS

! IF INCREASE TOTAL DGMAX, MUST EXPAND PWR10 TABLE!
DEF I.DGMAX AS 5     !MAX NO. INTEGER & DECIMAL LINE KEY DIGITS (4 BITS
DEF D.DGMAX AS 3     !PER - MUST FIT IN WORD ALONG WITH SIGN BIT)
DEF LBL.DGMAX AS 5   !MAX NO. DIGITS IN FORTRAN LABEL

DEF LWUPDIF AS OCT 40     !LWR CASE CHAR MINUS UPR CASE OF SAME
DEF LESSTR(X,Y) AS (X) SHR 1 < (Y) SHR 1  !STRING COMPARISON
DEF ND.STR AS '[[[[['    !STRING LIT > WD OF ALPHA CHARS
DEF EOLITWD AS 0         !WORD OF EOLITS
DEF TABCH AS OCT 11      !HANDLED IN MACHINE DEPENDENT MANNER
DEF NSPCH(CHAR) AS ($ #CHAR#TABCH)
DEF SPCH(CHAR) AS NOT NSPCH(CHAR)


GLOBAL OPNERR:, CFNEOF:

GLOBAL %CCOM
GLOBAL %PRMPT, %NXNSP, %BACKSP, %OFFSET, LASTCH
DEF NXCHAR AS LASTCH _ NCHV LPTR
GLOBAL %GETSTR, %GETCOM
GLOBAL %OUTKEY, %PRMPTKEY, %PLNKEY, %OUTDEC
GLOBAL %WDSTOR, %WDREC
GLOBAL %CERR, %CPERR, %ABERR, %EXERR, %LNGCHK, %CFNCLS, %PCMDL
GLOBAL FIXUP		!LABEL USED IN FIXUP AFTER ALT MODE OR
			!UNRECOVERABLE ERROR

GLOBAL %CSCAN.INIT, %FCR, %FFID, %FPWD
GLOBAL %FRNG, %FADR, %FLST

GLOBAL %PRGCHK, %OKAY, %INLIST
GLOBAL %I.NXLNUM, %NXLNUM
GLOBAL %XLKLN, %BCD, %INTKEY
GLOBAL %ALPH

GLOBAL %UNPKTK, %LIST.EXU


!  MACHINE/IMPLEMENTATION DEPENDENT I/O DATA

GLOBAL FREEPTR                !PTR TO BEGINNING OF FREE BUFFER
GLOBAL IMGPTR

! USED IN COMMAND PROCESSING (NOT SAVED BETWEEN COMMANDS):

GLOBAL OUTFN
GLOBAL OUTCNT    !ORIGINALLY MAX NO. OF OUTPUT CHARS; DEC'D. SET TO
                !VERY LARGE NO. IF NO LIMIT
GLOBAL LPTR                   !INPUT LINE STRING POINTER
GLOBAL EL(4), ELID(4), ELP    !COMMAND LINE ELEMENTS, ELEMENT IDS
DEF SELLIM AS GLBSZ
GLOBAL SEL(-1:SELLIM)         !SUBELEMENTS (LINE LIST & RANGE)
DEF LTBL(X) AS SEL((X)-2)    !LINE LIST NOS. & COUNTS
GLOBAL SELP                   !SEL PTR
GLOBAL LSTCNT	!NO. LINES SPECIFIED IN LINE LIST
GLOBAL LNUM

!  PROMPT PARAMETERS

GLOBAL PRMNUM                 !PROMPT IDENTIFYING NO.
DEF K.PFE AS 1
DEF K.PAT AS (K.PFE+1)
DEF K.PLK AS (K.PAT+1)
DEF K.PQM AS (K.PLK+1)
DEF PRMCNT AS K.PQM
GLOBAL PRMKEY                 !LINE KEY TO PRINT IF PRMNUM=K.PLK

!  COMMAND WORDS

DEF K.CLR  AS 1
DEF K.COMP AS 2
DEF K.COPY AS 3
DEF K.DEL  AS 4
DEF K.DO   AS 5
DEF K.EDIT AS 6
DEF K.ENT  AS 7
DEF K.FAST AS 8
DEF K.LIST AS 9
DEF K.MERG AS 10
DEF K.MOD  AS 11
DEF K.MOVE AS 12
DEF K.OPEN AS 13
DEF K.PRNT AS 14
DEF K.QUIT AS 15
DEF K.REN  AS 16
DEF K.RUN  AS 17
DEF K.SAVE AS 18
DEF K.SET  AS 19
DEF K.VER  AS 20
DEF CWDCNT AS K.VER

GLOBAL TABLE CWD(CWDCNT+1)["CLEAR","COMPILE",&
  "COPY","DELETE","DO","EDIT","ENTER","FAST",&
  "LIST","MERGE","MODIFY",&
  "MOVE","OPEN","PRINT","QUIT","RENUMBER",&
  "RUN","SAVE","SET","VERSION",ND.STR]

DEF CLMAX AS 8     !COMMAND LENGTH MAX

! PREPOSITIONAL WORDS - NO EL.ID/EL ENTRY FOR THESE

DEF K.AS   AS 1
DEF K.TO   AS 2
DEF PWDCNT AS K.TO
GLOBAL TABLE PWD(PWDCNT+1)["AS","TO",ND.STR]
DEF PLMAX AS 2               !MAX LENGTH OF PREP WD

!  COMMAND LINE ELEMENT IDENTIFIERS

DEF FID.ID AS 1              !FILE IDENTIFIER INDEX
DEF LST.ID AS 2              !LINE LIST
DEF ADR.ID AS 3              !LINE ADDRESS
DEF RNG.ID AS 4              !LINE RANGE
DEF LKY.ID AS 5              !LINE KEY
DEF FOR.ID AS 6              !FORTRAN ELEMENT (STMT, LABEL, VAR)
DEF INT.ID AS 7              !POSITIVE INTEGER

!  ERROR MESSAGES TO USER OF CCS

GLOBAL TABLE LNLONG       ['LINE TOO LONG']
GLOBAL TABLE BDLRNG       ['ILLEGAL LINE RANGE']

!FILE OPEN ERRORS
GLOBAL TABLE FILERR(IFDERR:FBSERR) ['ILLEGAL FILE IDENTIFIER', &
 '$NEW/OLD FILE MESSAGE NOT CONFIRMED', &
 'FILE NOT FOUND', 'INVALID USER NAME', &
 'PROTECTION VIOLATION ATTEMPT', 'FILE BUSY']


!  OF GENERAL INTEREST:

DEF UPALPH(X) AS ($A<=X<=$Z)
DEF LWALPH(X) AS ($A+LWUPDIF <= X <= $Z+LWUPDIF)
DEF XLWUP(X) AS X _ X-LWUPDIF   !TRANSFORM X FROM LWR TO UPR CASE
DEF NUM(X) AS ($0<=X<=$9)

DEF DGMAX AS (I.DGMAX+D.DGMAX) !MAX. TOTAL LINE KEY DIGITS
TABLE PWR10(0:DGMAX) [1,10,100,1000,10000,100000,1000000,10000000, &
   100000000]
DEF LKY.MAX AS (PWR10(DGMAX)-1)        !MAX. LINE KEY VALUE

DEF SGNBIT AS (1 ROTR 1)
DEF BIGNUM AS BNOT SGNBIT
DEF BPW AS BITS.PER.WORD
DEF BPC AS (BPW/CPW)

DEF YES AS 1
DEF NO  AS 0


%CCOM (NCOM:)

DEF INWDSZ AS (CLMAX+CPW-1)/CPW
LOCAL INWD(0:INWDSZ-1)       !MUST HOLD CLMAX CHARS
LOCAL TABSP	!LINE INDENTATION FOR LISTING
LOCAL PTR, CNT, TEMP, I

TABLE BDCMND       ['NO SUCH COMMAND']
TABLE AMBGCM       ['AMBIGUOUS COMMAND, TYPE MORE CHARACTERS']
TABLE LSTLNG       ['LINE LIST TOO LONG']
TABLE NOPROG       ['NO PROGRAM']
TABLE NOCORE       ['NOT ENOUGH CORE FOR BUFFER RING']
!  COMMAND MODELS

LOCAL CMDL(CWDCNT)
CMDL(K.ENT) _ '<LINE NUMBER> <STATEMENT>$  OR: <LINE RANGE> <CR> &
<STATEMENTS> <CR>'
CMDL(K.CLR) _ CMDL(K.QUIT) _ CMDL(K.VER) _ ''
CMDL(K.SAVE) _ '[ <FILE> ]'
CMDL(K.MERG) _ CMDL(K.DO) _ '<FILE>'
CMDL(K.EDIT) _ '<LINES OR FILE>'
CMDL(K.MOD) _ '<LINES>'
CMDL(K.DEL) _ '[ <LINES> ]'
CMDL(K.FAST) _ CMDL(K.LIST) _ '[ <LINES> ] [ TO <FILE> ]'
CMDL(K.COPY) _ '<LINES OR FILE> TO <LINE RANGE OR FILE>'
CMDL(K.MOVE) _ '<LINES> TO <LINE RANGE OR FILE>'
CMDL(K.REN) _ '[ <LINE> [ :<LINE> ] ] [ AS <LINE RANGE> ]'
CMDL(K.RUN) _ CMDL(K.COMP) _ '[ <ARGUMENTS> ]'

LOCAL ALT:

FREEPTR _ CHPT(FREE,-1); IMGPTR _ CHPT(IMAGE,-1)
SETRWE(CFN,CFNEOF)
SETPRMPT(%PRMPT); TAB.OFF(%OFFSET)
ALTLOC _ ALT

RETURN

ALT:    OFFALT; CLOBUF; CLIBUF; PUT(CARRET)
        IF CFN#TEL THEN [MSG('ABORTED$'); CFNCLS]
        GO ^FIXUP

%PCMDL

MSG("$SHOULD BE:$"); PRINT(CWD(PF.CNUM)); PUT($ ); CERR(CMDL(PF.CNUM))

END PCMDL


%GETCOM
! GET COMMAND LINE.  SET PF.CNUM IF OK ELSE ERROR EXIT.

LOCAL ERRA:

PRMNUM _ K.PFE
LOOP[GETSTR(CFN); WHILE NXNSP =CARRET]
BACKSP; IF ALPH(LASTCH) THEN [WDSTOR(CLMAX,ERRA); &
  PF.CNUM _ WDREC(CWD,ERRA)] ELSE PF.CNUM _ K.ENT
RETURN

ERRA:  CERR(BDCMND)

END GETCOM


%GETSTR (FN)

INLA:    RETURN LPTR _ GETLINE(FN)

CFNEOF:  OFFALT; LNGCHK; CFNCLS; FN _ TEL; ONALT.C; GO INLA

%CPERR (%MSGPROC)

ONALT.C
CLIBUF; MSGPROC
GO BELOW

%%CERR (N)

!  FN IS LAST FILE GETSTR READ FROM.
!  HANDLES RECOVERABLE TEL INPUT ERRORS AND CFN INPUT ERRORS WHICH
!  DO NOT ABORT CFN INPUT IF FN  WAS INFN (EG, LOAD OR COPY).
!  IF FN WAS COMMAND FILE NOT TEL (EG, ENTER) ABORTS CFN INPUT AND
!  OMITS FIXUP.

         ONALT.C
         CLIBUF; MSG(N)
BELOW:   PUT(CARRET); IF FN=TEL THEN GO INLA
         PRINT(FREE)
         IF FN#CFN THEN GO INLA
         OFFALT; CFNCLS; GO NCOM

END CPERR


%EXERR (N)

LOCAL HERE:

!  HANDLES FATAL ERRORS THAT RESULT IN EXIT.

  OFFALT; FIXUP _ HERE

%%ABERR (N)

!  HANDLES UNRECOVERABLE ERRORS.  CFN INPUT ABORTED.
!  DOES SAME FIXUP AS ALT MODE.

       ONALT.C
       CLIBUF; MSG(N); PUT(CARRET); IF FN#TEL THEN PRINT(FREE)
       OFFALT; CFNCLS; GO ^FIXUP

!SAME AS QUIT COMMAND:
HERE:	PF.CLOSE; CLOSE.ALL; ONALT; EXIT

END EXERR

END GETSTR


%LNGCHK
IF ERRNUM=LNGERR THEN CERR(LNLONG); RETURN
END LNGCHK


%CFNCLS
CLOSE(CFN <== TEL); RETURN
END CFNCLS


%PRMPT

! PROMPTS AS SPECIFIED BY PRMNUM

         DO PRMNUM OF PRMCNT
K.PFE:     OUTFN _ TEL; OUTDEC(PF.INTNO); MSG(': ')
K.PAT:     PUT($@)
K.PLK:     OUTFN _ TEL; PRMPTKEY(0,0,0)
K.PQM:     PUT($?); PUT($ )
         END
         RETURN

END PRMPT


%OFFSET
!  STATEMENT TAB ORIGIN MUST BE PAST LINE NO. ( & ENTER, IF ANY)

LOCAL PTR, OFF, CHAR

OFF _ 0
IF PRMNUM=K.PFE THEN DO
  PTR _ IMGPTR; WHILE SPCH(CHAR_NCHV PTR) OR ALPH(CHAR) THEN INC OFF
  IF CHAR=EOLIT OR (CHAR#$. AND NOT($0<=CHAR<=$9)) THEN RETURN 0; INC OFF
  WHILE $0<=CHAR _ NCHV PTR<=$9 OR CHAR=$. THEN INC OFF
  IF CHAR=EOLIT OR SPCH(CHAR) THEN INC OFF
END
RETURN OFF

END OFFSET


%NXNSP

! STORES IN LASTCH & RETURNS NEXT NON-BLANK

WHILE SPCH(NXCHAR) THEN NULL; RETURN LASTCH

END NXNSP


%BACKSP

PCHV LPTR; RETURN

END BACKSP


%WDSTOR (LMAX, LAB:)

!  NEXT CHAR IS ALPHABETIC.  STORES CHARS UP TO NEXT NON-ALPHA
!  IN INWD ARRAY; LPTR UPON RETURN IS BEFORE WD TERMINATOR.
!  GOES TO LAB IF NO. OF ALPHA CHARS EXCEEDS LMAX.
!  CONVERTS LOWER CASE ALPHA TO UPPER CASE.

       MOVE INWDSZ FROM ALL EOLITWD TO INWD
       PTR _ CHPT(INWD,CNT _ -1)
       WHILE INC CNT<=LMAX THEN DO
         IF NOT UPALPH(NXCHAR) THEN DO
           IF LWALPH(LASTCH) THEN XLWUP(LASTCH) ELSE [BACKSP; RETURN]
         END
         NCHV PTR _ LASTCH
       END
       GO LAB

END WDSTOR


%WDREC (WD(), LAB:)

! WORD RECOGNITION

!  WORD IS AT ADDR INWD, NO. OF CHARS IS IN CNT.
!  IF RECOGNIZES WORD AS WD(I), RETURNS I.
!  ALLOWS SHORTEST UNIQUE ABBREVIATION.
!  GOES TO LAB IF NO MATCH.
!  IF COMMAND LOOKUP (CWD ARRAY), MAY BE AMBIGUITY, IN WHICH CASE
!  ERR EXIT IS TAKEN.

LOCAL %COMPARE
LOCAL W, SAVE

       [W;CNT] _ CNT DIVMOD CPW
       PTR _ 0
       WHILE INWD(0) # ^WD(INC PTR) THEN DO
         IF LESSTR(INWD(0),^WD(PTR)) THEN GO NXT
       END
! INWD(0) <= ^WD(PTR)
NXT:   DO COMPARE OF -1:1
-1:      GO LAB                !<, NO MATCH
1:       INC PTR; GO NXT       !>, ONLY 1ST WD MATCH, CONTINUE
0:       SAVE _ PTR; INC PTR   !=, MATCH
         DO COMPARE OF -1:1    !AMBIGUITY CHECK
 -1: 1:    RETURN SAVE         !<, NO AMBIGUITY
  0:       CERR(AMBGCM)
         END
       END

%COMPARE

! COMPARES INWD TO COMMAND AT WD(PTR), UP TO END OF INWD.
! RETURNS -1, 0 OR 1, IF <, = OR >, RESPECTIVELY.

LOCAL J

       I _ TEMP _ -1
       WHILE INC I<W THEN DO
CA:      J _ ^(WD(PTR)+I) BAND TEMP
         IF INWD(I)#J THEN DO
           RETURN IF LESSTR(INWD(I),J) THEN -1 ELSE 1
         END
       END
       IF TEMP=-1 THEN [TEMP _ TEMP SHL (BPW-BPC*CNT); GO CA]
       RETURN 0

END COMPARE

END WDREC


DEF ELW(X,Y) AS [EL(INC ELP)_(Y); EL.ID(ELP)_(X)]
LOCAL FIDP
LOCAL FIDTBL(0:2*WPF-1)


%CSCAN.INIT

MOVE 4 FROM ALL 0 TO ELID+1; SELP _ ELP _ 0
FIDP _ FIDTBL-WPF; RETURN

END CSCAN.INIT


%FCR

TEMP _ [NXNSP=CARRET]; BACKSP; RETURN TEMP

END FCR


%FFID (EXTDEF)

!  SCANS FOR FILE IDENTIFIER (FID) TERMINATED BY BLANK OR CR.
!  CALLED WHEN NO ALTERNATIVE TO FID, SO TAKES ERROR EXIT IF FAILS.
!  STORES FID INFO WITH SETFID; IF OK, STORES FID.ID & ARG TO BE 
!  USED IN OPEN CALL.

LOCAL EROUT:

         IF NXNSP=CARRET THEN PCMDL
         BACKSP; SETFID(FIDP +_ WPF, @LPTR, EXTDEF, EROUT)
         ELW(FID.ID,-FIDP); RETURN

EROUT:   ABERR(FILERR(IFDERR))

END FFID


%FPWD (K.PWD,LAB:)

!  SCANS FOR PREP. WD SPECIFIED BY K.PWD (INCL. ABBREVIATIONS).
!  IF SUCCESSFUL, RETURNS K.PWD ELSE RESETS LPTR & GOES TO LAB.
!  SPECIAL CASE: IF K.PWD IS EOLIT, RETURNS INDEX TO PREP. WD FOUND;
!  IF WD IS NONE OF THE PREP. WDS, GOES TO LAB.

LOCAL OUT:

         TEMP _ LPTR
         IF NOT ALPH(NXNSP) THEN GO OUT
         BACKSP; WDSTOR(PLMAX,OUT)
         IF I _ WDREC(PWD,OUT)=KPWD OR KPWD=0 THEN RETURN I
OUT:     LPTR _ TEMP; GO LAB

END FPWD


%FRNG

!  SCANS FOR CONSTRUCTION SPECIFIED AT ENTRY POINT.
!
!  RNG      LKEY:LKEY  OR  LKEY(LKEY)LKEY  OR  LKEY(LKEY)  OR  LKEY
!           (LKEY FORM IS 0 TO I.DGMAX DIGITS, OPTIONAL 0 TO D.DGMAX
!           DECIMAL DIGITS WITH >0 DIGITS IN ALL)
!  ADR      LKEY  OR  $  OR  .  OR  *INT  OR  ADR+INT  OR  ADR-INT
!  LST      ADR[:ADR],...,ADR[:ADR]  OR  ALL
!
!  IF SUCCESSFUL, STORES APPROPRIATE EL.ID AND, IN EL ARRAY,
!     ADR OF WD BEFORE 1ST WD OF SUBELEMENT LIST
!                    (SEE %FRL)
!
!  RETURNS 1, WITH LPTR BEFORE CONSTRUCTION TERMINATOR.
!  IF NOT SUCCESSFUL, RESETS LPTR AND RETURNS 0.
!
!  LOW-ORDER BITS OF LFGS REPRESENT STATES AS FOLLOWS:
!
!            RNG     ADR
!    LST      :       (
!  + OR -     $       )
!     *     DIGIT     .
!
!  THUS:

DEF DOTB  AS 1
DEF DGTB  AS (1 SHL 1)
DEF ASTB  AS (1 SHL 2)
DEF RGTB  AS (1 SHL 3)
DEF DLRB  AS (1 SHL 4)
DEF SGNB  AS (1 SHL 5)
DEF LFTB  AS (1 SHL 6)
DEF CLNB  AS (1 SHL 7)
DEF LSTB  AS (1 SHL 8)
DEF ADRB  AS (1 SHL 9)
DEF RNGB  AS (1 SHL 10)

LOCAL %FRL
LOCAL LFGS

         LFGS _ RNGB; I _ FRL
         ELW(IF PF.CNUM=K.ENT AND LFGS BAND (CLNB+RGTB)=0 THEN LKY.ID &
           ELSE RNG.ID, I)
         RETURN YES


%%FADR

         LFGS _ ADRB; ELW(ADR.ID,FRL); RETURN YES


%%FLST

         LFGS _ LSTB
         ELW(LST.ID,FRL); RETURN YES


LAB:    RETURN NO


%FRL

!    TERMINATES ON ANY SYMBOL NOT : ( + - $ ) * DIGIT .
!    STORES SUBELEMENTS IN SEL ARRAY (1 PER WD) & RETURNS ADR OF
!    WD BEFORE 1ST WD OF LIST.  SUBELEMENTS INCLUDE ANY SPECIAL
!    SYMBOL & (NEGATIVE OF) ANY NUMBER READ (LKEY STORED AS INTEGER).
!    LIST TERMINATED BY 0.
!    SPECIAL CASE FOR LSTB: 'ALL' INDICATES ALL LINES, RETURNS 0

LOCAL %SVNUM, %SELW
LOCAL LVAL, TEMP

! EXTRACTION OF TYPE BIT:
DEF TYPB AS (LFGS BAND (RNGB+ADRB+LSTB))

! CHECK FOR ILLEGAL STATES:
DEF NG(X) AS IF LFGS BAND (X) THEN GO OUT

DEF PARENS AS (LFTB+RGTB)

         TEMP _ LPTR
         IF NXNSP=CARRET THEN GO OUT
         PTR _ SELP
         CNT _ I.DGMAX; LVAL _ 0    !LVAL RESET IN SVNUM

       LOOP DO
         EIF NUM(LASTCH) THEN DO
           NG(DLRB)
           LVAL _ LVAL*10+LASTCH-$0
! DON'T DEC CNT IF LEADING INTEGER ZERO
           IF NOT(LVAL=0=LFGS BAND DOTB) THEN IF DEC CNT<0 THEN GO OUT
           LFGS BOR_ DGTB
         END

         ORIF LASTCH=$. THEN DO
           NG(SGNB+DLRB+ASTB+DOTB)
           LFGS BOR_ DOTB
           CNT _ D.DGMAX
         END

         ELSE DO
           EIF LASTCH=$: THEN DO
             NG(ADRB+CLNB+PARENS)
             SVNUM; LFGS _ TYPB BOR CLNB
           END

           ORIF LASTCH=$( THEN DO
             NG(ADRB+LSTB+CLNB+PARENS)
             SVNUM; LFGS _ TYPB BOR LFTB
           END

           ORIF LASTCH=$) THEN DO
             IF LFGS BAND PARENS#LFTB THEN GO OUT
             SVNUM; LFGS _ TYPB BOR RGTB
           END

           ORIF LASTCH=$+ OR LASTCH=$- THEN DO
             NG(RNGB+SGNB)
             SVNUM; LFGS _ TYPB BOR (LFGS BAND CLNB) BOR SGNB
           END

           ORIF LASTCH=$$ OR LASTCH=$* THEN DO
             NG(BNOT(ADRB+LSTB+CLNB))
             LFGS BOR_ IF LASTCH=$$ THEN DLRB ELSE ASTB
           END

           ORIF LASTCH=$, THEN DO
             NG(RNGB+ADRB) 
             SVNUM; LFGS _ TYPB
           END

           ELSE GO ENDCH

           SELW(LASTCH); CNT _ I.DGMAX

         END

         NXCHAR
       END

ENDCH:   IF LFGS BAND PARENS=LFTB THEN GO OUT
         SVNUM; SELW(0); BACKSP; RETURN @SEL(PTR)

OUT:     LPTR _ TEMP
        IF (LFGS<==0) BAND LSTB=0 THEN GO LAB
        NXNSP; BACKSP; WDSTOR(3,OUT)  !LEAVES LPTR BEFORE TERM
        IF INWD(0)=^'ALL' THEN RETURN 0; GO OUT


%SELW (X)

!  SUBELEMENT WRITE WITH OVERFLOW CHECK

IF INC SELP>SELLIM THEN CERR(LSTLNG)
SEL(SELP) _ X; RETURN

END SELW


%SVNUM

!  CALLED AT : ( ) + - , (BEFORE SETTING STATE BIT) AND AT
!  TERMINATOR, TO STORE NEGATIVE OF LKEY/INTEGER PRECEDING, IF ANY.  
!  %FRL ACCUMULATED NUMBER IN LVAL, WITH LKEY DOT IGNORED
!  AND NO. OF DIGITS PAST DOT = 3-CNT.
!  MAY BE $ OR CURRENT LINE DOT OR NO LKEY AFTER );  IN ANY OTHER
!  CASE, ABSENCE OF DIGIT IS ILLEGAL.
!  0 ILLEGAL EXCEPT AFTER SIGN.

         IF LFGS BAND DLRB THEN RETURN  !PREVIOUSLY DISALLOWED $DIGIT
         IF LFGS BAND DGTB=0 THEN DO
           IF LFGS BAND RGTB THEN RETURN
           IF LFGS BAND DOTB AND TYPB#RNGB THEN [SELW($.); RETURN]
           GO OUT
         END
         IF LVAL=0 AND LFGS BAND SGNB=0 THEN GO OUT
         SELW ((LVAL<==0) * (IF LFGS BAND (SGNB+ASTB) THEN 1 ELSE &
           IF LFGS BAND DOTB THEN PWR10(CNT) ELSE PWR10(DDGMAX))*-1)
         RETURN

END SVNUM

END FRL

END FRNG


DEF RNGMX AS 10  !MAX NO. OF SUBRANGES IN LINE LIST

LOCAL J, WD()


%PRGCHK
IF PF.NLINES=0 THEN CERR(NOPROG); RETURN
END PRGCHK


%OKAY
IF CFN=TEL THEN MSG("OK$"); RETURN
END OKAY


%INLIST (I)

!  IF NO PROGRAM, ERROR.
!  I IS INDEX INTO EL.ID & EL ARRAYS FOR LINE LIST INFO.
! EL.ID(I) IS LST.ID OR 0: IF LST.ID, EL(I) IS
!  ADDRESS OF WD BEFORE 1ST WD OF SUBELEMENT LIST; IF 0, OR
!  IF EL.ID(I) IS 0, INDICATES DEFAULT LIST OF *1:$.
!  CALCULATES AND STORES LIST PARAMETERS AS FOLLOWS:
!    LSTCNT    TOTAL NO. OF LINES SPECIFIED
!    LTBL(1)   LINE NO. OF 1ST LINE OF 1ST SUBRANGE (LIST CONSTRUCTION
!              IS SUBRANGES SEPARATED BY COMMAS)
!    LTBL(2)   NO. OF LINES IN THIS SUBRANGE (>=0)
!    LTBL(3)   LINE NO. OF 2ND SUBRANGE (IF ANY)
!    ETC.
!  RETURNS NO. OF SUBRANGES READ.

LOCAL %NXADR
LOCAL MTCHFG, SAVE, CNT
LOCAL TERM

         PRGCHK
         IF EL.ID(I)=0 OR EL(I)=0 THEN DO     !ALL LINES
           LSTCNT _ LTBL(2) _ PF.NLINES; LTBL(1) _ CNT _ 1
         END ELSE DO
           WD _ EL(I)
           CNT _ LSTCNT _ PTR _ I _ 0
           LOOP DO
             IF INC CNT>RNGMX THEN CERR(LSTLNG)
             SAVE _ 0; LTBL(INC I) _ NXADR
             IF TERM=$: THEN DO
               IF LTBL(INC I) _ NXADR-LTBL(I)+1 <0 THEN CERR(BDLRNG)
             END ELSE LTBL(INC I) _ MTCHFG
             LSTCNT +_ LTBL(I)
             WHILE TERM=$,
           END
         END

         I.NXLNUM; RETURN CNT

%NXADR

!  RETURNS LINE NO. CORRESPONDING TO NEXT LINE ADDRESS (BEGINNING
!  AT INC PTR). LEAVES PTR AT : , OR 0, WITH WD(PTR) IN TERM.
!  NOTE: IF NEGATIVE SUBELEMENT, IS INTEGER REPRESENTING LINE KEY OR 
!  DISPLACEMENT.

LOCAL NX1:, LKEY

         MTCHFG _ YES; LKEY _ 0
         EIF WD(INC PTR)<0 THEN DO
           XLKLN(LKEY_-WD(PTR),NX1)    !STORES RESULT IN LNUM
           GO NX2
NX1:       MTCHFG _ NO   !IS 1+GREATEST LINE NO. WITH SMALLER KEY
         END
         ORIF WD(PTR)=$. THEN LNUM_PF.DOT
         ORIF WD(PTR)=$$ THEN LNUM _ PF.NLINES
         ELSE !IS $*! IF LNUM_-WD(INC PTR)>PF.NLINES THEN CERR(BDLRNG)

NX2:     IF TEMP_[WD(INC PTR)=$-] OR WD(PTR)=$+ THEN DO
           IF MTCHFG=NO THEN CERR(BDLRNG)
           INC PTR; LNUM +_ IF TEMP THEN WD(PTR) ELSE -WD(PTR)
           IF NOT(1<=LNUM<=PF.NLINES) THEN CERR(BDLRNG)
           INC PTR
         END ELSE DO     !NO DISPLACEMENT
       F SAVE#0 AND MTCHFG=NO THEN DEC LNUM
         END

         IF LKEY=0 THEN LKEY _ INTKEY(LNUM)
         IF SAVE=0 THEN SAVE _ LKEY ELSE IF SAVE>LKEY THEN CERR(BDLRNG)
         TERM _ WD(PTR); RETURN LNUM

END NXADR

END INLIST


%I.NXLNUM

!  INITIALIZES %NXLNUM TO RETURN 1ST LINE NO. IN LTBL
!  CALLED BEFORE %INLIST RETURN.

LOCAL CNT, PTR

CNT _ -1; PTR _ 1; RETURN

%%NXLNUM

!  RETURNS (AND STORES IN LNUM) NEXT LINE NO. SPECIFIED IN LTBL.
!  BEWARE OF OVERCALLING (MAX. OF LSTCNT CALLS AFTER I.NXNLUM)!!

IF INC CNT = LTBL(PTR+1) THEN DO
  WHILE LTBL(1+PTR+_2)=0 THEN NULL; CNT _ 0
END
RETURN LNUM _ LTBL(PTR)+CNT

END I.NXLNUM


%OUTKEY (DEST, IFS, DFS)

! WRITES PRMKEY (LINE KEY IN DICTIONARY FORM) PLUS A BLANK, ON OUTFN IF
! DEST IS 0 ELSE AT CHAR PTR DEST.  DECS OUTCNT WITH EACH WRITE.  
!  PRMPTKEY CALLED FROM %PRMPT; PRMKEY SET BEFORE %GETSTR CALL.
! IFS IS INTEGER FIELD SIZE (BLANKS IN PLACE OF LEADING ZEROES); DFS
! IS DECIMAL FIELD SIZE (BLANKS IN PLACE OF TRAILING ZEROES).
! IFS=DFS=0 SUPPRESSES THESE ZEROES.
! RETURNS DEST (IS ADVANCED CHAR PTR IF NOT 0).

LOCAL %OUT
LOCAL FLG, KEY, TEMP

         PRMKEY _ PF.KEYD(LNUM)

%%PRMPTKEY (DEST, IFS, DFS)

         FLG _ NO; KEY _ PRMKEY SHL (BPW-(CNT_DGMAX)*4)
         WHILE DEC CNT>=D.DGMAX THEN DO      !PRINT INTEGER DIGITS
           [TEMP;KEY] _ [0;KEY] DSHL 4
           IF TEMP THEN FLG _ YES  !SUPPRESS LEADING ZEROES
           IF FLG THEN OUT(TEMP+$0) ELSE IF CNT-D.DGMAX<IFS THEN OUT($ )
         END
         IF KEY THEN DO  !PRINT DEC. DIGITS
           OUT($.)
           WHILE KEY THEN DO
             [TEMP;KEY] _ [0;KEY] DSHL 4; OUT(TEMP+$0); DEC DFS
           END
         END ELSE IF DFS THEN INC DFS !NO DEC. PART - BLANK DOT POSITION
         REPEAT DFS OUT($ )
         OUT($ ); RETURN DEST

%OUT (X)
  IF DEST THEN NCHV DEST _ X ELSE W(OUTFN,X); DEC OUTCNT; RETURN
END OUT


%PLNKEY

! MACHINE DEPENDENT.  SPECIAL FILE OUTPUT FOR SAVE AND FAST.
! CONVERTS PF.KEYD(LNUM) TO CHARS RIGHT-JUSTIFIED WITH LEADING $0'S,
! WITH TRAILING 0'S SUPPRESSED.
! STORES RESULT AT PLN & CALLS PLNW TO WRITE KEY.

LOCAL I, PLN(0:1)
DEF NXRDG AS ((KEY<==KEY SHR 4) BAND OCT 17)

         PLN(0) _ PLN(1) _ ^'00000'; TEMP _ CHPT(PLN+2)
         KEY _ PF.KEYD(LNUM); I _ 0
         WHILE KEY BAND OCT 17=0 THEN DO
           KEY _ KEY SHR 4
           IF INC I=DDGMAX THEN GO INT
         END
         REPEAT DDGMAX-I PCHV TEMP _ NXRDG+$0   !OUT DEC. PART
         PCHV TEMP _ $.
INT:     REPEAT IDGMAX PCHV TEMP _ NXRDG+$0
         I _ 1
         IF PLN(0)=^'00000' THEN PLN(0) _ PLN(1) ELSE INC I
         PLNW(OUTFN,PLN,I); RETURN

END PLNKEY


END OUTKEY


%XLKLN (ILKEY,LAB:)

!  TRANSFORMS ILKEY (LINE KEY IN INTEGER FORM) TO ORDINAL LINE
!  NO., STORING RESULT IN LNUM.  IF EXACT MATCH, RETURNS; IF NOT,
!  RESULT IS 1+GREATEST LINE NO. WITH SMALLER LKEY & GOES TO LAB
!  RATHER THAN RETURN.

         LNUM _ 0; TEMP _ BCD(ILKEY)
         WHILE INC LNUM<=PF.NLINES THEN DO
           IF TEMP <= PF.KEYD(LNUM) THEN DO
             IF TEMP=PF.KEYD(LNUM) THEN RETURN; GO LAB
           END
         END
         GO LAB

END XLKLN


%BCD (ILKEY)

!  TRANSFORMS ILKEY (LINE KEY IN INTEGER FORM) TO BCD (DICTIONARY)
!  FORM
!  AND RETURNS RESULT.

LOCAL TEMP, I

         TEMP _ 0; CNT _ -4
         WHILE ILKEY THEN DO
           [ILKEY;I] _ ILKEY DIVMOD 10
           TEMP BOR_ (I SHL CNT +_ 4)
         END
         RETURN TEMP

END BCD


%INTKEY (LNUM)

LOCAL TEMP, I

!  TRANSFORMS LINE KEY CORRESPONDING TO LNUM FROM BCD (DICTIONARY
!  FORM) TO INTEGER FORM AND RETURNS RESULT.

         TEMP _ (I_PF.KEYD(LNUM)) BAND HEX F; CNT _ 0
         WHILE I _ I SHR 4 > 0 THEN DO
           TEMP _ TEMP + (I BAND HEX F) * PWR10(INC CNT)
         END
         RETURN TEMP

END INTKEY


%OUTDEC (N)

! CONVERTS N TO DECIMAL AND WRITES IT ON OUTFN

LOCAL BUF(12)

IF N < 0 THEN [W(OUTFN,$-); N - _]
LOOP [FOR I _ 1 BY 1 TO 12; [N; BUF(I)] _ N DIVMOD 10; WHILE N # 0]
LOOP [W(OUTFN,BUF(I)+$0); WHILE DEC I > 0]
RETURN

END OUTDEC


%ALPH (X)
! NOT MACRO SO X CAN HAVE SIDE EFFECT (I.E., NCHV)
RETURN [UPALPH(X) OR LWALPH(X)]
END ALPH


%UNPKTK (DEST, LAB:)

!  WRITES TEXT OF LINE LNUM ON OUTFN IF DEST IS 0 ELSE AT
!  CHAR PTR DEST.  DECS OUTCNT WITH EACH WRITE;
!  GOES TO LAB IF <0 (LINE TOO LONG).
!  RETURNS DEST (IS ADVANCED CHAR PTR IF NOT 0)
!  IMPLEMENTATION DEPENDENCY: PHASE 2 INPUT MUST BE FORMATTED,
!  SO LABEL SEPARATION IS UNNECESSARY.

LOCAL LAST, PP

         PP _ PF.RDLIN(LNUM)
         LAST _ 0
         WHILE (TEMP _ NCHV PP) # EOLIT THEN DO
           IF DEST THEN NCHV DEST _ TEMP ELSE DO
             IF LAST=LNFEED THEN DO
               REPEAT TABSP+LBL.DGMAX+1 [W(OUTFN,$ ); DEC OUTCNT]
             END
             LAST _ W(OUTFN,TEMP)
           END
           IF DEC OUTCNT<0 THEN DO
             IF DEST THEN [CHV DEST_EOLIT; PCHV DEST_CARRET]
             GO LAB
            END
         END
         IF DEST THEN REPEAT 3 NCHV DEST _ EOLIT   !FILL LAST WORD
         RETURN DEST

END UNPKTK


%LIST.EXU

GLOBAL %LIST.PAR
GLOBAL LNERRA:, HERE:, COPFX:

         IF EL.ID(1)=FID.ID THEN DO
           ELID(1) <=> ELID(2)      !MOVE FID INFO; ZERO LIST ID
           EL(2) _ EL(1)            !FOR %INLIST
         END
           INLIST(1)
             OFFALT
             IF OUTFN _ IF ELID(2)=0 THEN TEL ELSE &
              OPEN(EL(2),OUTMSG+SEQUEN+CHARACTER,OPNERR,2)#TEL THEN OKAY
             FIXUP _ COPFX
             ONALT
             [I;J] _ DOUBLE LIST.PAR
             REPEAT LSTCNT DO
               NXLNUM
	       IF PF.CNUM=K.LIST THEN DO
	         OUTCNT _ BIGNUM; OUTKEY(0,I,J)
	       END ELSE DO
	         OUTCNT _ LLEN
	         IF OUTFN#TEL THEN PLNKEY ELSE OUTKEY(0,0,0)
	       END
               UNPKTK(0,LNERRA)
             END
             OFFALT
             CLOSE(OUTFN)
             IF OUTFN=TEL THEN [PF.DOT _ LNUM; IF PF.CNUM=K.LIST THEN PUT(CARRET)]
	     RETURN


OPNERR:  IF ERRNUM=CORERR THEN EXERR(NOCORE)
         IF ERRNUM>FNFERR THEN DO
           PRINT('CANNOT OPEN '); WFID(FIDP); PUT(CARRET)
         END
         ABERR(FILERR(ERRNUM))

LNERRA:  OFFALT; PF.DOT _ LNUM; ONALT   !ERROR LINE = DOT
         IF OUTFN#TEL THEN UNPKTK(IF K.COPY#PF.CNUM#K.MOVE THEN &
           OUTKEY(FREEPTR,I,J) ELSE FREEPTR, HERE)
HERE:    ABERR(LNLONG)

FIND %UNMKDL

COPFX:  IF OUTFN#TEL THEN [CLOSE(OUTFN); DELETE(-FIDP)]
         IF PF.CNUM=K.MOVE THEN UNMKDL
         GO NCOM


%LIST.PAR

!  DETERMINES LINE KEY FIELD SIZE BY
!  EXAMINING KEYS OF ALL LINES SPECIFIED IN LTBL AND RETURNS DOUBLE
!  ARITHMETIC EXPRESSION SPECIFYING MAX. NO. OF INTEGER DIGITS
!  AND MAX. NO. OF DECIMAL DIGITS IN EXAMINED KEYS.
!  ALSO SETS TABSP (LIST INDENTATION FOR UNPKTK).
!  RETURNS ZEROES IF COMMAND IS NOT LIST.
!  ASSUMES I.NXLNUM PREV. CALLED, AND CALLS AGAIN BEFORE RETURN.

         I _ J _ TABSP _ 0
         IF PF.CNUM=K.LIST AND LSTCNT#0 THEN DO
           TEMP _ 0; REPEAT LSTCNT TEMP BOR_ PF.KEYD(NXLNUM)
           I.NXLNUM
           WHILE J<D.DGMAX AND TEMP BAND HEX F=0 THEN DO
             TEMP _ TEMP SHR 4; INC J   !J=NO. OF TRAILING DECIMAL 0'S
           END
           WHILE TEMP THEN DO
             TEMP _ TEMP SHR 4; INC I    !I=TOTAL NO. DIGITS
           END
           I _ 0 MAX I-J_(D.DGMAX-J)   !ALLOWS FOR LEADING DECIMAL 0'S
           TABSP _ I+J+1      !ADD 1 FOR BLANK
           IF J>0 THEN INC TABSP      !ADD 1 FOR ., IF ANY
           IF OUTFN=TEL THEN PUT(CARRET)   !FOR BOB RASMUSSEN
         END
         RETURN [I;J]

END LIST.PAR

END LIST.EXU

END CCOM
  @y¯