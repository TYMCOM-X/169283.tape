!  CCS EDITOR
! VERSION 1.00 FOR FCCS - GARY GERE -    K L U D G E
! (SORRY I HAD TO DO THIS FOLKS)!
!  IOCSU+PFU+CCOMU MUST PRECEDE


FIND %FGETCOM    ! FIND THE COMMAND GETTER
GLOBAL %CCS, S:, %XCTCCS, %FCCS.INIT
LOCAL %CCS.INIT

S:      CCS.INIT        !INITIAL ENTRY POINT
S1:     GO S1S          !RECOVERY FROM EXECUTION
S2:     CCS(0)          !RECOVERY FROM DEBUGGER, COMMAND ALREADY IN BUFFER
S1S:    CCS(1)


DEF CKCPOP AS IF PF.FN = TEL THEN CERR(NPFOPN)
%CCS (NEDCMD)

LOCAL %CSCAN, %CEXU, %XINIT, SVALT

! USED IN COMMAND PROCESSING (NOT SAVED BETWEEN COMMANDS):

LOCAL SCR(NLMAX)             !SCRATCH ARRAY
LOCAL INFN                   !INPUT FILE NUMBER

!  ERROR MESSAGES TO USER OF CCS

TABLE NPFOPN    ['NO PROGRAM FILE OPEN']
TABLE EDILNG       ['TRUNCATED LINE AVAILABLE FOR EDIT']
TABLE NODFLT       ['NO DEFAULT NAME']
TABLE BDIOSD       ['BAD I/O SOURCE OR DESTINATION']
TABLE CNTREN       ['CANNOT RENUMBER, CHECK LINE RANGE']
TABLE BDANS        ['ILLEGAL RESPONSE IN COMMAND FILE']
TABLE DISORD       ['DISORDERLY LINE NUMBER']
TABLE PTROOM       ['NOT ENOUGH ROOM, CANNOT ENTER LINE']
TABLE NOROOM       ['NOT ENOUGH ROOM, COMMAND NOT EXECUTED']
TABLE BDLNFL       ['FILE HAS LINE NUMBERS']
TABLE NODBG        ['DEBUGGER COMMANDS NOT ALLOWED HERE']


LOCAL PTR, CNT, TEMP, I

GLOBAL RETXCT:
LOCAL NCOM:


! THE REWORKING OF CCS FOR FCCS BY GARY GER
! NCOM: OLD WAS FOR NEW COMMAND. THIS HAS BEEN ABANDONED.
! THE NEW PURPOSE OF NCOM IS TO RETURN FROM FCCS TO
! THE CALLING PROGRAM.  IT RETURNS WITH 'TRUE' (MEANING THAT
! EVERYTHING WAS OKAY).
! RETXCT: THIS RETURNS FALSE.  THIS IS FOR THOSE HARDCORE
! ERRORS THAT NO-ONE KNOWS ABOUT.
! XCTCCS: CALLED AS SUBROUTINES, EXECUTES ONE CCS COMMAND AND
! LEAVES THE WORLD.

NCOM:   ALTLOC _ SVALT; PRMNUM _ 1; RETURN -1                       !RETURN OKAY

!0HERE WHEN WE ARE REALLY PUZZLED

RETXCT: ALTLOC _ SVALT; PRMNUM _ 1; RETURN 0                !RETURN FALSE

!ENTRY POINT TO EXECUTE A COMMAND
! %XCTCCS EXECUTES ONE COMMAND
! LPTR ALREADY HAS SOMETHING IN IT
!  (BECAUSE OF THIS, GETCOM WAS ALSO KLUDGES UP)

%%XCTCCS

        SVALT _ ALTLOC
        OFFALT; CCOM (FIXUP _ NCOM) ! ALL RETURNS ARE GOOD
        ONALT.C; FGETCOM; CSCAN; CEXU; INC PF.INTNO
        GO NCOM

! THAT WAS THAT!  
!HOW ABOUT SOME KLUDGE, EH?!


%CCS.INIT
! HERE WE ARE AGAIN...
! THE ENTRY POINT %%FCCSINIT WAS PUT IN BECAUSE CCSINI
! IS THE NAME OF ONE OF MY OTHER ROUTINES......... BAH!!!!!
! IT OPENS A PROGRAM FILE (UH-HA)
%%FCCS.INIT
!INITIALIZES CCS WHEN FIRST ENTERED.  HANDLES -SFO COMMAND AND STUFF.

        SVALT _ ALTLOC
FIND JOBERR

LOCAL NOTSYS:,FIRKKK:

        JOBERR _ 0
        CCOM(FIXUP_FIRKKK)
GETPF:  CSCAN.INIT
        FFID(OCT 604755.000000)  !.PGM
        IF PF.FN # TEL THEN DO
                MSG('CURRENT PROGRAM FILE CLOSED$')
                CLOSE(PF.FN<==TEL)
                END
        PF.FN _ TEL
        DO PF.OPEN(EL(1)) OF -1:1
-1:     MSG(BDIOSD)
0:      IF ERRNUM=CORERR THEN MSG('OUT OF CORE$')
        IF ERRNUM>FNFERR THEN DO
                PRINT('CAN NOT OPEN FILE: '); WFID(FIDP)
                PUT(CAR.RET)
                END
        MSG(FILERR(ERRNUM)); PUT(CAR.RET)
1:      ALTLOC_SVALT; RETURN -1 !0THIS IS THE TRUE RETURN, MAN.
        END
        ALTLOC_SVALT; RETURN 0 !0FALSE RETURN

%%XINIT
!ASKS FOR PROGRAM FILE AND GETS IT

NOTSYS: MSG("PROGRAM FILE: "); GETSTR(CFN); GO GETPF

END CCS.INIT


%CSCAN

!  CCS COMMAND LINE SCANNER

!  STORES COMMAND LINE ELEMENT IDENTIFIERS (IN EL.ID ARRAY) & INFO
!  NEEDED TO ACCESS ELEMENTS (IN EL ARRAY).
!  PF.CNUM (COMMAND NO.) RETURNED IF SCAN SUCCESSFUL, WITH 0'S IN
!  UNUSED EL.ID POSITIONS.

DEF ELW(X,Y) AS [EL(INC ELP)_(Y); EL.ID(ELP)_(X)]

LOCAL EROUT:, CRCHK:, MDOUT:

         CSCAN.INIT

         DO PF.CNUM OF CMDCNT

K.SRCH:  K.OVLY:  CERR(NOTIMP)

K.OPEN: FFID(OCT 604755.000000) !.PGM

K.LINE:	CKCPOP;    IF NOT FRNG OR EL.ID(1)#LKY.ID THEN GO EROUT
           IF NSPCH(NXCHAR)  THEN BACKSP     !ABSORB BLANK AFTER LINE KEY
           ELW(FOR.ID,LPTR); RETURN PF.CNUM

K.ENT:	CKCPOP;  FPWD(K.FRM,IF NOT FRNG THEN EROUT ELSE CRCHK)
	FFID(0)

K.CLR:   K.RUN:  K.INIT:  K.DUMP:  K.QUIT:  NULL

K.EDIT:  K.MOD:  K.DEL:  &
        CKCPOP;  IF NOT FLST THEN GO EROUT

K.COPY:  K.MOVE:  &
	CKCPOP; IF NOT FLST THEN GO EROUT
	FPWD(K.TO,MDOUT); GO RENA

K.REN:  CKCPOP;  FLST; FPWD(K.AS,CRCHK)
RENA:	 IF NOT FRNG THEN GO EROUT

         END

! CR MUST FOLLOW
CRCHK:   IF NOT FCR THEN PCMDL; RETURN

EROUT:   IF NXNSP#CARRET THEN CERR(BDLRNG)
MDOUT:	PCMDL


END CSCAN


%CEXU

!  EXECUTES COMMAND PF.CNUM.
!  WHEN FALL THRU TO END OF CASE STATEMENT, ALT MODE MUST BE OFF
!  (BECAUSE OF SUBSEQUENT BRANCH TO NCOM:).
!  FIXUP LOCATION SHOULD NOT INCLUDE OFFALT (WILL BE OFF WHEN 
!  GO ^FIXUP).

LOCAL %INRANG, %INTXL
LOCAL %MRGINP, %SET.INCR
GLOBAL %MKDL, %DELMKD, %UNMKDL
LOCAL %ANS

LOCAL LOKEY      !1ST KEY OF RANGE
LOCAL HIKEY      !LAST ALLOWABLE KEY
LOCAL INCR       !RANGE INCREMENT 
LOCAL LONUM      !1ST DICT. POSITION TO BE AFFECTED BY NEW RANGE
LOCAL HINUM      !POSITION OF 1ST LINE BEYOND AFFECTED RANGE IN PROG.
LOCAL TXINCT     !TEXT INPUT COUNT (NO. LINES ENTERED)
LOCAL MXINCT     !MAXIMUM TEXT INPUT COUNT

LOCAL I, J, WD(), TEMP
LOCAL LNERRB:, COP.B:
LOCAL LOADFX:, ENTFX:, MERGN:, LOAD.C:
LOCAL %SET.INFN


         DO PF.CNUM OF CMDCNT

K.CHK:  K.DUMP:  CERR(NOTIMP)

K.LINE:  LINES:  CKCPOP; &
    	 INRANG(1)
         FIXUP _ ENTFX     !== FIXUP TO NCOM UNTIL LINE HAS BEEN ENTERED
         EIF EL.ID(1)=LKY.ID THEN INTXL    !LPTR IS OK

         ORIF INCR<0 THEN DO   !NO INCREMENT - AT SIGN PROMPT
           PRMNUM _ K.PAT
           LOOP DO
             GETSTR(CFN); WHILE NXCHAR#CARRET; BACKSP; INTXL
           END
         END
  
         ELSE DO    !INCREMENT - LINE KEY PROMPT
           PRMNUM _ K.PLK; TEMP _ LOKEY
ENT.B:     PRMKEY _ BCD(TEMP); GETSTR(CFN)
           IF NXCHAR#CARRET THEN DO
             BACKSP; INTXL
             IF TEMP +_ INCR <= HIKEY THEN GO ENT.B
           END
         END

         OFFALT
ENTFX:   PF.DOT _ MRGINP


K.ENT:	CKCPOP; EIF EL.ID(2)#0 THEN DO    !RANGE FROM FILE
           OFFALT
           SETRWE(SET.INFN(2),COP.B); IF PLNCHK(INFN) THEN ABERR(BDLNFL)
           FIXUP _ LOAD.C
           ONALT
             INRANG(1)
!* NOTE: NOROOM ERR IF INCR>=0 AND LINE KEY>HIKEY (MXINCT EXCEEDED)
             LOOP [GETSTR(INFN); INTXL]
	END

	ORIF EL.ID(1)=RNG.ID THEN GO LINES    !RANGE (FROM TEL)

	ELSE DO    !FROM (NUMBERED) FILE
          OFFALT     !SINGLE LINE ENTER FROM FILE
          SETRWE(SET.INFN(1),MERGN); FIXUP _ LOAD.C; ONALT
          LOOP DO
            GETSTR(INFN)
            IF NXNSP#CARRET THEN DO
              BACKSP; PF.CNUM _ K.LINE; CSCAN
              INRANG(1)
              INTXL; OFFALT; PF.DOT _ MRGINP; ONALT
            END
          END
	END

COP.B:	LNGCHK; OFFALT; PF.DOT _ MRGINP; GO LOAD.C

MERGN:  LNGCHK; OFFALT

LOAD.C: CLOSE(INFN)


K.COPY: K.MOVE: CKCPOP; &
	   INLIST(1)
             INRANG(2)
             OFFALT
             REPEAT LSTCNT DO
               NXLNUM
               IF PF.CNUM=K.MOVE THEN DO
                 IF NOT(LONUM<=LNUM<HINUM) AND PF.KEYD(LNUM)>0 THEN DO
                 !IF OUTSIDE RANGE AND NOT ALREADY MARKED FOR DELETION:
                   INC MXINCT; MKDL(LNUM)
                 END
               END
               IF TXINCT=MXINCT THEN ABERR(NOROOM)
               SCR(INC TXINCT) _ PF.CPD(LNUM)
             END
             IF PF.CNUM=K.MOVE THEN DO     !SET UP FOR MRGINP
               LONUM _ DELMKD(1,LONUM-1)+1
               PF.NLINES _ DELMKD(HINUM,PF.NLINES)
             END
             PF.DOT _ MRGINP


K.MOD: &
K.EDIT: CKCPOP;  INLIST(1); OUTFN _ TEL; PRMNUM _ K.PLK
         REPEAT LSTCNT DO
           PRMKEY _ PF.KEYD(NXLNUM)
           OUTCNT _ LLEN; UNPKTK(CHPT(IMAGE,-1),LNERRB)
EDIT.A:    IF PF.CNUM=K.EDIT THEN [OUTKEY(0,0,0); PRINTC(IMAGE)]
           GETSTR(TEL)
           IF NXCHAR#CARRET THEN DO
             BACKSP
             OFFALT
             PF.CPD(PF.DOT _ LNUM) _ PF.WTLIN(LPTR)
             PF.RELOK _ 0
             ONALT
           END
         END
         OFFALT


K.CLR:  CKCPOP;    IF ANS('ALL')=YES THEN DO
             OFFALT;  PF.CLEAR;  GO NCOM
           END ELSE OFFALT

K.DEL:  CKCPOP;    INLIST(1)
           OFFALT
           REPEAT LSTCNT MKDL(NXLNUM)
           PF.NLINES _ DELMKD(1,PF.NLINES)
           PF.RELOK _ 0


K.REN: CKCPOP; &
! WILL NOT MOVE OR DELETE LINES! &
         IF ELID(1)=RNG.ID THEN DO
           ELID(1) <=> ELID(2)     !MOVE RANGE INFO, ZERO LIST ID
           EL(2) _ EL(1)           !FOR %INLIST
         END
         IF INLIST(1)>1 THEN PCMDL
         IF ELID(1)#0=ELID(2) THEN DO
           !REN ADR1:ADR2 - ASSUME AS KEY(ADR1):KEY(ADR2)
           !MXINCT CHECK NOT NEEDED
           INCR _ -1
           LOKEY _ INTKEY(LONUM _ LTBL(1))
           HIKEY _ INTKEY((HINUM _ LTBL(1)+LSTCNT)-1)
         END ELSE [INRANG(2); IF LSTCNT>MXINCT THEN CERR(CNTREN)]
         IF NOT(LONUM>= LNUM _ LTBL(1) >=HINUM-LSTCNT) THEN CERR(CNTREN) 
         TXINCT _ LSTCNT; SET.INCR; DEC LNUM
         OFFALT
         REPEAT LSTCNT PF.KEYD(INC LNUM) _ BCD(LOKEY <== LOKEY+INCR)



K.RUN:  K.INIT: CKCPOP; &
         PF.UPDATE


K.QUIT: OFFALT; QUIT


K.OPEN: OFFALT
        DO PF.OPEN(EL(1)) OF -1:1
-1:     CERR(BDIOSD)
0:      GO OPNERR
        END
        OKAY
        GO NCOM         !DON'T WANT TO INCREMENT PROMPT#


         END
         RETURN


LNERRB:  MSG(LNLONG); MSG(EDILNG); GO EDIT.A

%SET.INFN (N)
LOCAL INERR:

        LOOP DO
         IF INFN _ OPEN(EL(N),INPUT+SEQUEN+CHARACTER,INERR,2) &
          =TEL THEN CERR(BDIOSD); OKAY; RETURN INFN
INERR:   IF ERRNUM#FNFERR OR EXTQ(FIDP)=YES THEN GO OPNERR
         EXTQ(FIDP) _ YES; EXTARG(FIDP) _ 0
        END

END SET.INFN


%INRANG (I)

!  I IS INDEX INTO EL.ID & EL ARRAYS FOR LINE RANGE INFO. EL(I) IS
!  ADDRESS OF WD BEFORE 1ST WD OF SUBELEMENT LIST,
!  UNLESS EL.ID(I) IS 0, TO INDICATE DEFAULT RANGE OF 1(1) (RENUMBER).
!  ALSO SPECIAL RENUMBER CASE: IF UPPER LIMIT OMITTED, IS LAST LINE
!  IN LIST TO BE RENUMBERED.
!  CALCULATES AND STORES RANGE PARAMETERS: LOKEY, HIKEY, INCR (-1
!  IF NONE), LONUM, HINUM, MXINCT.
!  INITS TXINCT & CURSOR FOR %INTXL
!  NOTE: NEGATIVE INTEGER REPRESENTS LINE KEY.

LOCAL CONT:, NXT:, NXT1:

         IF EL.ID(I)=0 THEN [LOKEY _ INCR _ PWR10(D.DGMAX); GO INRA]
         WD _ EL(I)
         LOKEY _ -WD(1); INCR _ -1
         IF WD(2)=0 THEN HIKEY_LOKEY ELSE DO
           IF WD(2)=$: THEN HIKEY_-WD(3) ELSE DO
             INCR _ -WD(3)    !WD(2) IS (, WD(4) IS )
             IF HIKEY _ -WD(5)=0 THEN DO    !CREATE UPPER LIMIT KEY
INRA:          IF PF.CNUM=K.REN THEN LNUM _ LTBL(1)+LSTCNT ELSE DO
                 XLKLN(LOKEY,CONT); INC LNUM
                 ! LNUM IS 1ST PROG. LINE ABOVE LOWER LIMIT
               END
CONT:          HIKEY _ IF LNUM >PF.NLINES THEN LKY.MAX ELSE &
                 INTKEY(LNUM)-1
             END
           END
           IF HIKEY < LOKEY THEN CERR(BDLRNG)   !OLD CCS DISALLOWED =
         END

         XLKLN(LOKEY,NXT)
NXT:     LONUM _ LNUM
         XLKLN(HIKEY,NXT1); INC LNUM
NXT1:    HINUM _ LNUM
         ! HINUM-LONUM IS NO. OF LINES CURRENTLY IN RANGE
         MXINCT _ NLMAX MIN 1+(HIKEY-LOKEY)/(IF INCR<0 THEN 1 &
           ELSE INCR) MIN HINUM-LONUM+NLMAX-PF.NLINES

         TXINCT _ 0; RETURN

END INRANG


%INTXL

!  WRITE LINE AT LPTR ON PF AND STORE CORRESPONDING PF.CPD ENTRY
!  IN SCR ARRAY.
!  OFFALT PROTECTS AGAINST TXINCT BEING 1>NO. OF SCR ENTRIES.

         IF TXINCT = MXINCT THEN &
         ABERR(IF PF.CNUM=K.ENT THEN PTROOM ELSE NOROOM)
         OFFALT; SCR(INC TXINCT) _ PF.WTLIN(LPTR); ONALT
         RETURN

END INTXL


%MRGINP

!  MERGE THOSE LINES WHICH HAVE PF.CPD ENTRIES IN SCR ARRAY.
!  (TXINCT LINES IN ALL).  1ST KEY IS LOKEY; INCR IS CALCULATED IF
!  NEVER SPECIFIED.  1ST LNUM IS LONUM; LOKEY AND LONUM ARE UPDATED.
!  RETURNS NO. OF LAST LINE MERGED, POSSIBLY USED TO SET PF.DOT
!  (THUS DOES NOTHING BUT RETURN PF.DOT IF TXINCT IS 0.)

LOCAL MVCNT, MVDIS

         IF TXINCT=0 THEN RETURN PF.DOT
         SET.INCR
         MVCNT _ PF.NLINES-HINUM+1
         IF MVDIS _ LONUM+TXINCT-HINUM >0 THEN DO
!  MOVE DOWN LOWER PART OF EACH DICTIONARY,STARTING WITH LAST ENTRY
!  (PF.NLINES), ENDING WITH BEGINNING OF LOWER PART (HINUM).
           PTR _ PF.NLINES+1
           REPEAT MVCNT DO
             PF.CPD(PTR+MVDIS) _ PF.CPD(DEC PTR)
             PF.KEYD(PTR+MVDIS) _ PF.KEYD(PTR)
           END
         END ELSE IF MVDIS<0 THEN DO     !MOVE UP LOWER PART
           MOVE MVCNT FROM @PF.CPD(HINUM) TO @PF.CPD(LONUM+TXINCT)
           MOVE MVCNT FROM @PF.KEYD(HINUM) TO @PF.KEYD(LONUM+TXINCT)
         END
         DEC LONUM; I _ 0
         WHILE INC I <= TXINCT THEN DO
           PF.CPD(INC LONUM) _ SCR(I)
           PF.KEYD(LONUM) _ BCD(LOKEY<==LOKEY+INCR)
         END
         PF.NLINES +_ MVDIS
         PF.RELOK _ 0
         RETURN LONUM
END MRGINP


%SET.INCR

! COMPUTE INCREMENT IF NECESSARY.

IF TXINCT>1 AND INCR<0 THEN DO
  TEMP _ (HIKEY-LOKEY)/(TXINCT-1) +1
  I _ D.DGMAX+1
  WHILE TEMP <= PWR10(DEC I) THEN NULL; INCR _ PWR10(I)
END
RETURN

END SET.INCR


%MKDL (LNUM)

!  MARK LINE WITH NUMBER LNUM FOR DELETION (TURN ON SIGN BIT)

PF.KEYD(LNUM) BOR_ SGNBIT; RETURN

END MKDL


%DELMKD (LO, HI)

!  DELETE LINES MARKED FOR DELETION (SIGN BIT ON) IN RANGE OF LINE
!  NUMBERS LO TO HI; I.E., CRUNCH UNMARKED LINES.
!  RETURNS INDEX TO LAST OF CRUNCHED LINES (LO-1 IF ALL MARKED).
!  IF HI EXCEEDS LO, RETURNS LO-1; WHEN CALLED IN MOVING
!  LIST TO RANGE, WILL WORK OK IF LONUM IS 0 OR HINUM IS PF.NLINES+1.
!  ADJUST PF.DOT IF IN AFFECTED RANGE.

LNUM _ I _ LO-1
WHILE INC LNUM<=HI THEN DO
  IF PF.KEYD(LNUM)>0 THEN DO
    PF.KEYD(INC I) _ PF.KEYD(LNUM)
    PF.CPD(I) _ PF.CPD(LNUM)
  END
  IF LNUM=PF.DOT AND PF.DOT _ I =0 THEN INC PF.DOT
END
RETURN I

END DELMKD


%UNMKDL

!  UNMARK ALL LINES MARKED FOR DELETION (TURN OFF SIGN BIT).

LNUM _ 0
REPEAT PF.NLINES &
  PF.KEYD(INC LNUM) BAND_ BNOT SGNBIT
RETURN

END UNMKDL


%ANS (QUES)

!  PRINTS QUES (IF COMMAND FILE TEL), READS ANSWER AND RETURNS 1 IF YES,
!  0 IF NO.

         IF CFN=TEL THEN [MSG(QUES); PRMNUM _ K.PQM]
         LOOP DO
           GETSTR(CFN)
           IF LWALPH(NXNSP) THEN XLWUP(CHRLST)
           IF NOT($Y#CHRLST#$N) THEN RETURN [CHRLST=$Y]
           IF CFN#TEL THEN CERR(BDANS)
           MSG('WHAT')
         END

END ANS

END CEXU

END CCS
   