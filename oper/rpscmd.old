! RPS COMMAND DECODER

FIND %STROUT, GTYPE
GLOBAL %GETOKEN, %UP.CHAR, %STRCOMP, %SINC, %INSC, %INDEX, %A.CHAR
GLOBAL %OUTNUM, %NXLIN

! PROCEDURE: GETOKEN
! GETS SCANS A GIVEN LINE AND RETURNS EITHER TOKEN TYPE FOUND
! OR NOTHING.
!@ARG:1 - BYTE POINTER TO BEG. OF TOKEN TO SCAN
!  IF THIS IS ZERO, WILL ASSUME THE GLOBAL STRING 'POINTER'
!  ALSO, IF ARG:1 GIVES OUT AT FIRST CALL THEN WILL TYPE ARG:7
!  AND INPUT DATA WHICH WILL THEN BE USED.
! ARG:2 - RESERVED WORD TABLE TO SCAN [0 IF NO RES.WRD SCAN]
! ARG:3 - -1 IF NUMERIC TOKEN OKAY ELSE 0
! ARG:4 - -1 IF STRING TOKEN OKAY ELSE 0
! ARG:5 - MESSAGE FOR THE ? TOKEN
! ARG:6 - MESSAGE FOR THE HELP TOKEN
! ARG:7 - MESSAGE INCASE INPUT NEEDED FROM TELETYPE
!
! RETURNS
! IF TOKEN ACCEPTABLE, RETURNS TOKEN TYPE
!       TOKBUF(TOKEN) RETURNS THE TOKEN
! IF NSL, RETURNS FALSE
! IF HELP OR ? TOKEN, WILL RETURN QUEST [MAY NEVER HAPPEN]
! IN ANY EVENT, LASTOK CONTAINS THE CONTENTS OF ARG:1 B4 SCAN
! AND GTYPE [GLOBAL] WILL CONTAIN THE LAST TYPE BY GETOKEN
%GETOKEN(@ARG.1,ARG.2(),ARG.3,ARG.4,ARG.5,ARG.6,ARG.7)

LOCAL PTR,CNTR,PLACE,FOUND,THS.THN

! STRIP OFF LEADING BLANKS FROM THE TOKEN
        LASTOK_THS.THN_ARG.1             ! SAVE TOKEN POINTER
        IF THS.THN = 0 THEN DO
! INPUT NEEDED
          THS.THN _ POINTER
           END


         WHILE TYPE_UP.CHAR(@THS.THN)=DELIMT AND CHAR=$  THEN NULL

! CHECK FOR E.O.F
HWIIN:  IF CHAR=CAR.RET OR CHAR=E.O.LIT THEN DO !EXCUSE LABLE,PLS!
          MSG(ARG.7); THS.THN _ NXLIN; TYPE _ UP.CHAR(@THS.THN)
          END

! DONE...  SEE IF NEXT TOKEN CHAR IS A ?  AND IF SO TYPE ARG:5
        IF CHV THS.THN = $? THEN DO
          STROUT(ARG.5)
          CHAR_CAR.RET ! FORCE PROMPT
          GO HWIIN ! SORRY ABOUT LABLE
          END
! DONE...  SCAN FOR TOKEN

! IS A RESERVED WORD CALLED FOR ??
        IF ARG2(0)#0 AND $A<=CHAR<=$Z THEN DO

 ! YES, WE HAVE A RESERVED WORD TODAY
          FOR PTR_0 TO 20 MTOKS(PTR)_-1 !RESET AMBIGUITY TEST
          PTR_POINTX(TOKBUF);  NCHV PTR_CHAR
           WHILE TYPE_UP.CHAR(@THS.THN)=STRING OR TYPE=NUMBER THEN NCHV PTR_CHAR
  ! CHECK, IF NOT VALID TERMINATOR (TYPE=DELIMT) THEN EXIT
  ! WITH BADCHR RETURN
           IF TYPE = CHRCTR THEN DO
                TOKEN_TERMCH_CHAR
                RETURN BADCHR
                END
  ! OKAY TERMINATOR
           TERMCH_CHAR; NCHV PTR_E.O.LIT; CNTR_-1; FOUND_PLACE_0
        WHILE ARG2(INC CNTR)#0 THEN DO
          EIF STRCOMP(POINTX(TOKBUF),POINT(ARG2(CNTR)))=TRUE&
          THEN DO
! CHECK FOR HELP TOKEN (IS ALWAYS 0)
          IF TOKEN_PLACE_CNTR = 0 THEN DO
           STROUT(ARG.6); CHAR_CAR.RET; GO HWIIN !SORRY ABOUT GO
           END
          IF ARG.1 # 0 THEN ARG.1 _ THS.THN ELSE POINTER_THS.THN
          RETURN GTYPE_RESWRD
          END
          FIF INDEX(POINTX(TOKBUF),POINT(ARG2(CNTR)))=TRUE&
          THEN [MTOKS(INC FOUND)_ARG2(CNTR); PLACE_CNTR]
          END
        EIF FOUND=0 THEN [IF ARG.1 # 0 THEN ARG.1 _ THS.THN ELSE POINTER_THS.THN; RETURN GTYPE_BADRES]
        ORIF FOUND#1 THEN [IF ARG.1 # 0 THEN ARG.1 _ THS.THN ELSE POINTER_THS.THN; RETURN GTYPE_AMBIG]
        ELSE TOKEN_PLACE
        IF ARG.1 # 0 THEN ARG.1 _ THS.THN ELSE POINTER_THS.THN; RETURN GTYPE_RESWRD
        END

! IS A NUMBER IN THE MAKING ????
        IF TYPE=NUMBER AND ARG.3 = -1 THEN DO

 ! YES, WE HAVE A NUMBER TODAY

          PTR_POINTX(TOKBUF); NCHV PTR_CHAR
          WHILE TYPE_UP.CHAR(@THS.THN)=NUMBER THEN NCHV PTR_CHAR
          NCHV PTR_E.O.LIT; PTR_POINTX(TOKBUF)
          TERMCH_CHAR
          EIF CHAR=$O OR CHAR=$B THEN TOKEN_SINC(@PTR,8)
          ORIF CHAR=$D OR TYPE=DELIMT THEN TOKEN_SINC(@PTR,10)
          ELSE DO
            MSG('$INVALID CHARACTER$'); PUT(CHAR); MSG('$IN NUMBER$')
            MSG(@TOKEN); PUT(CARRET); IF ARG.1 # 0 THEN ARG.1 _ THS.THN ELSE POINTER_THS.THN; RETURN GTYPE_FIRK
            END

          IF TOKEN<0 THEN DO
            MSG('$ILLEGAL CHARACTER$'); PUT(-TOKEN)
            MSG('$FOR INPUT RADIX$'); IF ARG.1 # 0 THEN ARG.1 _ THS.THN ELSE POINTER_THS.THN; RETURN GTYPE_FIRK
            END
          IF TERMCH=$O OR TERMCH=$D OR TERMCH=$B OR TYPE#DELIMT THEN DO
            TYPE_UP.CHAR(@THS.THN); TERMCH_CHAR
            END
          IF ARG.1 # 0 THEN ARG.1 _ THS.THN ELSE POINTER_THS.THN; RETURN GTYPE_NUMBER
          END

 ! ERROR RETURN
        IF ARG.1 # 0 THEN ARG.1 _ THS.THN ELSE POINTER_THS.THN
        IF TYPE = DELIMT OR TYPE = CHRCTR THEN TOKEN_TERMCH_CHAR
        RETURN GTYPE_TYPE

END GETOKEN

! PROCEDURE: STRCOMP
! ARG:1,ARG:2 STRINGS TO COMPARE
! RETURNS 'TRUE' IF STRINGS COMPARE OR 'FALSE' IF THEY DONT
%STRCOMP(ARG.1,ARG.2)

LOCAL TMP.1,TMP.2

        WHILE TMP.1_NCHV ARG.1=TMP.2_NCHV ARG.2#E.O.LIT THEN NULL
        IF TMP.1=TMP.2 THEN RETURN TRUE ELSE RETURN FALSE

END STRCOMP

! PROCEDURE: INDEX
! ARG:1 = SUBSET STRING
! ARG:2 = COMPARE STRING
! RETURNS 'TRUE' IF ARG:1 IS SUBSET OF ARG:2
%INDEX(ARG.1,ARG.2)

LOCAL TMP.1,TMP.2

        LOOP DO
          EIF TMP.1_NCHV ARG.1 = E.O.LIT OR TMP.1 = CAR.RET THEN RETURN TRUE
          FIF TMP.2_NCHV ARG.2 = E.O.LIT THEN RETURN FALSE
          WHILE TMP.1=TMP.2
          END
        RETURN FALSE

END INDEX

! PROCEDURE: SINC
! ARG:1 POINTER TO STRING WITH @
! ARG:2 RADIX
! STRING TO INTERNAL CONVERSION
%SINC(@ARG.1,ARG.2)

LOCAL VAL,TMP.1

        VAL_0
        LOOP DO
          IF TMP.1_NCHV ARG.1=E.O.LIT OR TMP.1=CAR.RET THEN RETURN VAL
          IF NOT ($0<=TMP.1<=ARG.2+$0) THEN RETURN -TMP.1
          VAL_VAL*ARG2+(TMP.1-$0)
          END
        RETURN VAL

END SINC

! PROCEDURE: INSC
! ARG:1 NUMBER
! ARG:2 STRING TO APPEND NUMBER TO
! ARG:3 RADIX
! INTERNAL TO STRING CONVERSION
%INSC(ARG.1,@ARG.2,ARG.3)

LOCAL T(11),K,L

        K_ARG.1
        LOOP DO
          FOR L_11 BY -1
          [K;T(L)]_K DIVMOD ARG.3
          WHILE K>0
          END

        FOR L_L TO 11 NCHV ARG.2_T(L)+$0
        NCHV ARG.2_E.O.LIT
        RETURN

END INSC

! PROCEDURE: UP.CHAR
! RETURNS CHARACTER, UPPER CASE FROM LOWER CASE
! ARG:1 @ STRING TO GRAB FROM
%UP.CHAR(@ARG.1)

LOCAL TMP.1

        TMP.1_A.CHAR(@ARG.1)
        IF $A+OCT 40<=CHAR<=$Z+OCT 40 THEN CHAR_CHAR-OCT 40
        RETURN TMP.1

END UP.CHAR

! PROCEDURE: ACHAR
! ARG:1 @ STRING TO GRAB FROM
! RETURN CHAR=CHARACTER AND VALUE _ TYPE OF CHARACTER
%A.CHAR(@ARG.1)

        EIF CHAR_NCHV ARG.1 = E.O.LIT THEN [PCHV ARG.1;RETURN FALSE]
        ORIF ($A<=CHAR<=$Z) OR ($A+OCT 40<=CHAR<=$Z+OCT 40) THEN RETURN STRING
        ORIF $0<=CHAR<=$9 THEN RETURN NUMBER
        ORIF CHAR=$, OR CHAR=$  OR CHAR=$; OR CHAR=$= &
                OR CHAR=CAR.RET OR CHAR=LN.FEED THEN RETURN DELIMT
        ELSE RETURN CHRCTR

END A.CHAR

! PROCEDURE: OUTNUM
! ARG:1 IS THE NUMBER TO OUTPUT
! ARG:2 IS THE RADIX TO OUTPUT
! ARG:3 IS THE FILE NUMBER
! OUTPUTS THE NUMBERS ARG:1 IN RADIX ARG:2 TO FILE ARG:3
%OUTNUM(ARG.1,ARG.2,ARG.3)

LOCAL TMP.1,TMP.2(0:5)

        TMP.1_POINTX(TMP.2)
        INSC(ARG.1,@TMP.1,ARG.2)
        TMP.1_POINTX(TMP.2)
        WHILE NCHV TMP.1#E.O.LIT THEN W(ARG.3,CHV TMP.1)
        RETURN TRUE

END OUTNUM

! PROCEDURE: NXLIN
! RETURNS NEXT LINE OF INPUT AS BYTE POINTER
%NXLIN

        RETURN GETLINE(TELFIL)

END NXLIN
