





!COPYRIGHT 1972,1973,  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS
!AUTHOR:S. MURPHY
GLOBAL BIND CGSTV=91;		!VERSION DATE:APRIL 20, 1973


MAP PEXPRNODE TREEPTR:A1NODE:A2NODE;

MAP BASE CSTMNT;

OWN BASE TOPSTMNT;	!WHEN HAVE A STATEMENT EMBEDDED INSIDE ANOTHER (EG IN 
			! LOGICAL IFS) THIS VAR PTS TO THE TOP LEVEL STMNT NODE

GLOBAL ROUTINE CGSTMNT=
%(***************************************************************************
	ROUTINE TO PERFORM CODE GENERATION FOR A STATEMENT.
	CALLED WITH THE GLOBAL CSTMNT POINTING TO THE STATEMENT FOR WHICH CODE
	IS TO BE GENERATED.
***************************************************************************)%
BEGIN
        EXTERNAL        PBFPTR,OPDSPIX,OPGSTM,PBOPWD;
        REGISTER        OPGENTRY OPGENPTR;





	MAP PPEEPFRAME PBFPTR;

	%(***IF THERE IS A LABEL ON THIS STATEMENT, ASSOCIATE THAT LABEL WITH THE
		CURRENT LOCATION***)%
	IF .CSTMNT[SRCLBL] NEQ 0
        THEN DEFLAB(.CSTMNT[SRCLBL]);


  %(*****************OUTPUT THE TYMSHARE DEBUGGER LOADER BLK #31**)%
        OPDSPIX _ OPGSTM;
        OPGENPTR_@.OPDSPIX;
        PBOPWD_.OPGENPTR[PATTERN];  !PICK UP THE INSTRUCTION WORD
        PBOPWD _ .PBOPWD+.CSTMNT[SRCISN];
        PSYMPTR  _  4;
        OBUFF();                !OUTPUT STMNT UUO





	%(***SET ISN FIELD FOR NEXT INSTR TO BE GENERATED TO ISN OF THIS STMNT***)%
	PBFPTR[PBFISN]_.CSTMNT[SRCISN];

	%(***GENERATE CODE FOR THE STATEMENT************)%
	CASE .CSTMNT[SRCID] OF SET

	CGASMNT();		!FOR AN ASSIGNMENT
	CGASSI();		! ASSIGN
	CGSBPRGM(.CSTMNT[CALLIST],.CSTMNT[CALSYM]);	! CALL
	BEGIN END;		! CONTINUE
	CGDOLOOP();		! DO
	CGPROEPI();		! ENTRY
	CGASMNT();		! COMMON SUBEXPR - SAME AS ASMNT

	JRSTGEN(.CSTMNT[GOTOLBL]);	!GOTO
	CGAGO();		! ASSIGNED GOTO
	CGCGO();		! COMPUTED GOTO
	CGARIF();		!ARITHMETIC IF
	CGLOGIF();		! LOGICAL IF
	CGRETURN(.CSTMNT[RETEXPR]);	! RETURN
	CGSTOP();		! STOP

	CGREAD();		! READ
	CGWRIT();		! WRITE
	CGDECO();		! DECODE
	CGENCO();		! ENCODE
	CGRERE();		! REREAD
	CGFIND();		! FIND
	CGCLOS();		! CLOSE
	BEGIN END;		! INPUT (NOT IN RELEASE 1)
	BEGIN END;		! OUTPUT (NOT IN RELEASE 1)

	CGMTOP();		! BACKSPACE
	CGMTOP();		! BACKFILE
	CGMTOP();		! REWIND
	CGMTOP();		! SKIP FILE
	CGMTOP();		! SKIP RECORD
	CGMTOP();		! UNLOAD
	CGMTOP();		! RELEASE
	CGMTOP();		! ENDFILE

	CGEND();		! END
	CGPAUSE();		! PAUSE
	CGOPEN();		! OPEN
	CGSFN();		! STATEMENT FN
	BEGIN END;		! FORMAT - NO CODE GENERATED
	BEGIN END;		! BLT (NOT IN RELEASE 1)
	BEGIN END;		! OVERLAY ID
	TES;

	%(***IF THIS STMNT HAS A LABEL, CHECK FOR WHETHER IT ENDS A DO STMNT***)%
	IF .CSTMNT[SRCLBL] NEQ 0
	THEN CGDOEND(.CSTMNT[SRCLBL]);

END;


GLOBAL ROUTINE CGASMNT=
%(***************************************************************************
	ROUTINE TO GENERATE CODE FOR ASSIGNMENT STATEMENTS.
	CALLED WITH THE GLOBAL CSTMNT POINTING TO THE STATEMENT FOR
	WHICH CODE IS TO BE GENERATED.
***************************************************************************)%
BEGIN

	%(***COMPUTE THE VALUES OF ANY COMMON SUBEXPRS ASSOCIATED WITH THIS STATEMENT***)%
	IF .CSTMNT[SRCCOMNSUB] NEQ 0 THEN CGCMNSUB();


%(***STRING HANDLING*********************************)%

        
        A1NODE  _  .CSTMNT[LHEXP];
        IF  .A1NODE[VALTYPE]  EQL  STRING

        THEN
        BEGIN

                TREEPTR  _  .CSTMNT;
                OPDSPIX  _  OPGSES;     !OUTPUT THE START STRING CODE
                CGOPGEN();


%(*******************PROCESS RHEXP..IF A LEAF OUTPUT IT*****************)%

                IF  NOT  .CSTMNT[A2VALFLG]

                THEN
                BEGIN
                        TREEPTR  _  .CSTMNT[RHEXP];
                        CGETVAL();
                END
                ELSE
                BEGIN
                        A1NODE  _  .CSTMNT[RHEXP];
                        OPDSPIX  _  OPGSRR;
                        CGOPGEN();
                END;

%(********************PROCESS LHEXP..IF A LEAF OUTPUT IT**************)%


                IF  NOT  .CSTMNT[A1VALFLG]

                THEN
                BEGIN
                        TREEPTR  _  .CSTMNT[LHEXP];
                        CGETVAL();
                        A1NODE  _  .CSTMNT[LHEXP];
                        OPDSPIX  _  OPGSSA;
                        CGOPGEN();
                END
                ELSE
                BEGIN
                        OPDSPIX  _  OPGSSR;
                        A1NODE  _  .CSTMNT[LHEXP];
                        CGOPGEN();
                END;
          RETURN;
        END;



	%(***GET THE VALUE OF THE LEFT HAND SIDE OF THE STATEMENT AND THE ADDRESS
		OF THE RIGHT HAND SIDE WITHIN REACH OF ONE INSTRUCTION***)%
	IF .CSTMNT[A1VALFLG]
	THEN
	BEGIN
		IF NOT .CSTMNT[A2VALFLG]
		THEN
		BEGIN
			TREEPTR_.CSTMNT[RHEXP];
			CGETVAL();
		END;
	END
	ELSE
	IF .CSTMNT[A2VALFLG]
	THEN
	BEGIN
		TREEPTR_.CSTMNT[LHEXP];
		CGETVAL();
	END
	ELSE
	IF .CSTMNT[RVRSFLG]
	THEN
	%(***IF RIGHT-HAND SIDE SHOULD BE EVALUATED FIRST***)%
	BEGIN
		TREEPTR_.CSTMNT[RHEXP];
		CGETVAL();
		TREEPTR_.CSTMNT[LHEXP];
		CGETVAL();
	END
	ELSE
	%(***IF LEFT-HAND SIDE SHOULD BE EVALUATED FIRST***)%
	BEGIN
		TREEPTR_.CSTMNT[LHEXP];
		CGETVAL();
		TREEPTR_.CSTMNT[RHEXP];
		CGETVAL();
	END;


	%(***IN GENERAL, IF THE VAL OF THE RHS HAD TO BE NEGATED BEFORE IT WAS STORED IN THE
		LHS, WE WANT TO NEGATE ON THE STORE OPERATION ("MOVNM").
		HOWEVER IF THE RHS IS COMPUTED DIRECTLY INTO THE LOC CORRESPONDING
		TO THE LHS (EG IF LHS LIVES IN A REG), THE NEG MUST BE PERFORMED ON
		RHS COMPUTATION****)%
	IF NOT .CSTMNT[A1SAMEFLG]
	THEN
	BEGIN
		CSTMNT[A1NEGFLG]_.CSTMNT[A2NEGFLG];
		CSTMNT[A1NOTFLG]_.CSTMNT[A2NOTFLG];
		CSTMNT[A2NEGFLG]_0;
		CSTMNT[A2NOTFLG]_0;
	END;



	%(***IF THE RHS WAS NOT COMPUTED DIRECTLY INTO THE MEMORY LOC FOR THE LHS, PICK UP THE
		RHS AND STORE IT INTO THE LHS*******)%
	IF NOT .CSTMNT[MEMCMPFLG]
	THEN
	BEGIN
		REGFORCOMP_GETASMNREG(CSTMNT);
		%(***GET VAL OF RIGHT-HAND SIDE INTO REG FOR COMPUTATION OF THE STMNT***)%
		A1NODE_.CSTMNT[RHEXP];
		TREEPTR_.CSTMNT;
		OPDSPIX_GETA2OPIX(CSTMNT,A1NODE);
		CGOPGEN();

		%(***STORE THE VALUE FROM REG-FOR-COMPUTATION INTO THE ADDRESS
			SPECIFIED BY THE LEFT-HAND-SIDE***)%
		IF NOT .CSTMNT[A1SAMEFLG]
		THEN
		BEGIN
			TREEPTR_.CSTMNT[LHEXP];
			OPDSPIX_ASNOPIX(CSTMNT,TREEPTR);
			CGOPGEN();
		END;
	END;
END;

GLOBAL ROUTINE CGASSI=
%(***************************************************************************
	GENERATE CODE FOR AN ASSIGN STATEMENT.
	NOTE THAT THE VARIABLE WILL ALWAYS BE LOADED INTO REGISTER 1
***************************************************************************)%
BEGIN
	%(***IF THE ASSIGNED VAR IS AN ARRAYREF, GENERATE CODE TO COMPUTE ITS ADDR***)%
	TREEPTR_.CSTMNT[ASISYM];
	IF .TREEPTR[OPRCLS] EQL ARRAYREF
	THEN
	CGETVAL();

	%(***COMPUTE THE ASSIGN*******)%
	A1NODE_.CSTMNT[ASISYM];
	A1LABEL_.CSTMNT[ASILBL];
	OPDSPIX_OPASIN;
	CGOPGEN();
END;

GLOBAL ROUTINE CGAGO=
%(***************************************************************************
	ROUTINE TO GENERATE CODE FOR ASSIGNED GOTO STATEMENT.
	CALLED WITH "CSTMNT" POINTING TO THE STATEMENT TO BE PROCESSED.
	IF A LIST OF LABELS WAS SPECIFIED FOR THIS STMNT,
	CODE GENERATED IS:
		MOVE	1,VAR
		CAIN	1,LAB1
		JRST	LAB1
		CAIN	1,LAB2
		JRST	LAB2
		.
		.
	IF NOT, THE CODE GENERATED IS
		SKIPE	1,VAR
		JRST	0(1)
***************************************************************************)%
BEGIN

	%(***OPCODES NEEDED FOR CODE FOR ASSIGNED GOTO***)%
	BIND
		HRRZOC=#550^27,
		CAINOC=#306^27,
		SKIPEOC=#332^27;

	%(***ALWAYS USE REGISTER 1 TO HOLD THE ASSIGNED VAR***)%
	BIND AGOREG=1^23;
	BIND AGORGIX=1^18;

	OWN AGOLSTPTR;
	OWN PEXPRNODE AGOVAR;

	%(***SET UP THE GLOBALS "PBOPWD" AND "PSYMPTR" USED BY THE OUTPUT ROUTINE 
		TO INDICATE AN ADDRESS REFERENCE TO THE ASSIGNED VARIABLE***)%

	AGOVAR_.CSTMNT[AGOTOLBL];

	%(***IF ASSIGNED VAR IS AN ARRAY REFERENCE*****)%
	IF .AGOVAR[OPRCLS] EQL ARRAYREF
	THEN
	BEGIN
		TREEPTR_.AGOVAR;
		CGETVAL();

		PSYMPTR_.AGOVAR[ARG1PTR];		!SYMBOL TABLE ENTRY FOR THE
							! ARRAY
		PBOPWD_.AGOVAR[TARGET];			!ADDRESS FIELD TO REF THE ARRAY
							! ELEMENT DESIRED
	END

	%(***IF ASSIGNED VAR IS A SCALAR***)%
	ELSE
	BEGIN
		PSYMPTR_.AGOVAR;
		PBOPWD_.AGOVAR[IDADDR];
	END;


	%(****IF NO LIST OF LABELS WAS SPECIFIED******)%
	IF .CSTMNT[GOTOLIST] EQL 0
	THEN
	BEGIN
		%(***GENERATE "SKIPE 1,VAR" ***)%
		PBOPWD_.PBOPWD OR SKIPEOC OR AGOREG;
		OBUFF();

		%(***GENERATE JRST 0(1)***)%
		PSYMPTR_PBFNOSYM;
		PBOPWD_JRSTOC OR AGORGIX;
		OBUFF();
	END

	%(***IF A LIST OF LABELS WAS SPECIFIED***)%
	ELSE
	BEGIN
		%(***GENERATE HRRZ 1,VAR****)%
		PBOPWD_.PBOPWD OR HRRZOC OR AGOREG;
		OBUFF();

		%(***FOR EACH LABEL IN THE LIST, COMPARE REG 1 WITH THE LABEL AND
			IF IT IS EQUAL, TRANSFER TO THE LABEL*****)%
		AGOLSTPTR_.CSTMNT[GOTOLIST];
		DECR CT FROM (.CSTMNT[GOTONUM]-1) TO 0
		DO
		BEGIN
			PBOPWD_CAINOC OR AGOREG OR @.AGOLSTPTR;
			PSYMPTR_PBFLABREF;
			OBUFF();
			JRSTGEN(@.AGOLSTPTR);
			AGOLSTPTR_.AGOLSTPTR+1;
		END;
	END;
END;



GLOBAL ROUTINE CGCGO=
%(***************************************************************************
	ROUTINE TO GENERATE CODE FOR COMPUTED GOTO.
	CODE GENERATED IS:
		SKIPLE	01,VAL
		CAILE	01,CT
		JRST	Y
		JRST	@.(1)
		ARG	L1
		ARG	L2
		.
		.
	   Y:	1ST INSTR OF NEXT STMNT
	CALLED WITH THE GLOBAL CSTMNT POINTING TO THE COMPUTED GOTO STMNT
***************************************************************************)%
BEGIN
	OWN BASE NXTSTMNT;

	%(***DEFINE OPCODES USED FOR COMPUTED GOTO***)%
	BIND	SKIPLEOC=#333^27,
		CAILEOC=#303^27,
		SKIPAOC=#334^27,
		ARGOC=JUMPOCD^27;			!USE JUMP

	%(***ALWAYS USE REGISTER 1 TO HOLD THE COMPUTED VAL***)%
	BIND	CGOREG=1^23,
		CGORGIX=1^18;

	OWN PEXPRNODE CGOEXP;
	OWN CLOC;
	OWN CGOLSTPTR;

	%(***COMPUTE THE VALUES OF ANY COMMON SUBEXPRS ASSOCIATED WITH THIS STMNT***)%
	IF .CSTMNT[SRCCOMNSUB] NEQ 0 THEN CGCMNSUB();


	CGOEXP_.CSTMNT[CGOTOLBL];

	%(***IF THE EXPRESSION IS NOT A SCALAR OR A COMMON SUB, EVALUATE IT***)%
	IF .CGOEXP[OPRCLS] NEQ DATAOPR AND .CGOEXP[OPRCLS] NEQ CMNSUB
	THEN
	BEGIN
		TREEPTR_.CGOEXP;
		CGETVAL();
	END;

	%(***GENERATE THE SKIPLE, CAILE, JRST SEQUENCE***)%

	%(******DETERMINE WHAT THE LABEL ON THE NEXT STMNT IS, IF THERE IS NONE, GENERATE ONE***)%
	%(*******(NOTE THAT IF THIS STMNT IS EMBEDDED INSIDE AN ARITH OR LOGICAL IF, MUST
		LOOK AT THE "TOP-LEVEL" STMNT NODE TO GET A PTR TO THE NEXT STMNT)***)%
	NXTSTMNT_(IF .CSTMNT[CLINK] NEQ 0 THEN .CSTMNT[CLINK] ELSE .TOPSTMNT[CLINK]);
	A1LABEL_(IF .NXTSTMNT[SRCLBL] NEQ 0 THEN .NXTSTMNT[SRCLBL]
		 ELSE (NXTSTMNT[SRCLBL]_GENLAB() )  );

	A1NODE_.CGOEXP;
	C1H_.CSTMNT[GOTONUM];

	%(***HAVE A SPECIAL CASE WHEN THE EXPRESSION IS THE LOOP INDEX OF A LOOP IN
		WHICH THE INDEX IS STORED IN THE RIGHT HALF OF AN AC
		(IN THIS CASE GENERATE:
			MOVEI	1,0(LOOPAC)
			JUMPLE	1,Y
			CAILE	1,CT
			JRST	Y) 
	*********)%
	IF .CSTMNT[A1IMMEDFLG] AND .CGOEXP[OPRCLS] EQL REGCONTENTS
	THEN OPDSPIX_OPGCGI

	ELSE OPDSPIX_OPGCGO;
	CGOPGEN();


	%(***ASSOCIATE A LABEL WITH THE CURRENT LOC***)%
	CLOC_GENLAB();
	DEFLAB(.CLOC);

	%(***GENERATE JRST @CLOC(1)***)%
	PBOPWD_JRSTOC OR INDBIT OR CGORGIX OR .CLOC;
	PSYMPTR_PBFLABREF;
	OBUFF();

	%(***FOR EACH LABEL LISTED, GENERTAE "ARG LAB"***)%
	PSYMPTR_PBFLABREF;
	CGOLSTPTR_.CSTMNT[GOTOLIST];
	DECR CT FROM (.CSTMNT[GOTONUM]-1) TO 0
	DO
	BEGIN
		PBOPWD_ARGOC OR @.CGOLSTPTR;
		OBUFF();
		CGOLSTPTR_.CGOLSTPTR+1;
	END;

END;

GLOBAL ROUTINE CGLOGIF=
%(***************************************************************************
	ROUTINE TO GENERATE CODE FOR LOGICAL IF STATEMENTS.
	CALLED WITH THE GLOBAL CSTMNT POINTING TO THE STATEMENT FOR
	WHICH CODE IS TO BE GENERATED.
	A LOGICAL IF STATEMENT NODE MAY HAVE THE FLAG "A1NOTFLG" SET, WHICH
	MEANS TO TAKE THE "NOT" (COMPLEMENT) OF THE CONDITION SPECIFIED.
	BECAUSE "NOT" PROPAGATES OVER BOTH BOOLEANS AND RELATIONALS, IT IS ASSUMED
	THAT THIS FLAG WILL NEVER BE SET WHEN THE CONDITION IS A BOOLEAN OR RELATIONAL.
***************************************************************************)%
BEGIN
	OWN THENLAB,ELSELAB;		!NEW LABEL TABLE ENTRIES
					!WHICH WILL BE CREATED TO PROCESS
					! THIS STMNT
	OWN BASE SUBSTATMNT;		!STATEMENT TO BE EXECUTED IF CONDITION HOLDS
	OWN BASE SAVSTMNT;		!SAVE PTR TO THE LOG IF  STATEMENT
	OWN PEXPRNODE CONDEXPR;		!CONDITIONAL EXPRESSION TO BE TESTED

	%(***EVALUATE ANY COMMON SUBEXPRESSIONS UNDER THIS STATEMENT***)%
	IF .CSTMNT[SRCCOMNSUB] NEQ 0 THEN CGCMNSUB();


	SUBSTATMNT_.CSTMNT[LIFSTATE];
	CONDEXPR_.CSTMNT[LIFEXPR];
	TREEPTR_.CSTMNT[LIFEXPR];
        IF  .CONDEXPR[VALTYPE]  EQL  STRING

        THEN
        BEGIN
                OPDSPIX  _  OPGSES;
                CGOPGEN();

                IF  NOT  .CONDEXPR[A1VALFLG]

                THEN
                BEGIN
                        TREEPTR  _  .CONDEXPR[ARG1PTR];
                        CGETVAL();
                END
                ELSE
                BEGIN
                        TREEPTR  _  .CONDEXPR[ARG1PTR];
                        A1NODE  _  .CONDEXPR[ARG1PTR];
                        OPDSPIX  _  OPGSRR;
                        CGOPGEN();
                END;

                
                OPDSPIX  _  OPGSES;
                CGOPGEN();

                IF  NOT  .CONDEXPR[A2VALFLG]

                THEN
                BEGIN
                        TREEPTR  _  .CONDEXPR[ARG2PTR];
                        CGETVAL();
                END
                ELSE
                BEGIN
                        TREEPTR  _  .CONDEXPR[ARG2PTR];
                        A1NODE  _  .CONDEXPR[ARG2PTR];
                        OPDSPIX  _  OPGSRR;
                        CGOPGEN();
                END;

                CASE  .CONDEXPR[OPERSP]  OF  SET

                        %(***NOT USED***)%
                        BEGIN  END;


                        %(***LESS THAN***)%
                        OPDSPIX  _  OPGSKL;

                        %(***EQUAL***)%
                        OPDSPIX  _  OPGSKP;

                        %(***LESS; EQUAL***)%
                        OPDSPIX  _  OPGSLE;

                        %(***NOT USED****)%
                        BEGIN  END;

                        %(***> ; =***)%
                        OPDSPIX  _  OPGSGE;

                        %(*** #  ***)%
                        OPDSPIX  _  OPGSKN;

                        %(***  GT ****)%
                        OPDSPIX  _  OPGSKG;
                TES;
                CGOPGEN();

                        ELSELAB  _  GENLAB();
                        JRSTGEN(.ELSELAB);
                        TOPSTMNT  _  .CSTMNT;
                        SAVSTMNT  _  .CSTMNT;
                        CSTMNT  _  .SUBSTATMNT;
                        CGSTMNT();
                        CSTMNT  _  .SAVSTMNT;
                        DEFLAB(.ELSELAB);
        END
        ELSE




	%(*****WHEN THE STATEMENT TO BE EXECUTED IF  CONDITION IS TRUE IS A GOTO***)%
	IF .SUBSTATMNT[SRCID] EQL GOTOID
	THEN
	BEGIN
		%(****IF THE CONDITION TO BE TESTED IS A RELATIONAL***)%
		IF .CONDEXPR[OPRCLS] EQL  RELATIONAL
		THEN
		BEGIN
			CGREL1(FALSE);		!SKIP NEXT INSTR IF REL IS FALSE
			%(***GENERATE A JRST TO THE GOTO-LABEL***)%
			JRSTGEN(.SUBSTATMNT[GOTOLBL]);
		END

		%(***IF THE CONDITION TO BE TESTED IS A BOOLEAN***)%
		ELSE
		IF .CONDEXPR[OPRCLS] EQL BOOLEAN
		THEN
		BEGIN
			ELSELAB_GENLAB();	!CREATE LABEL TABLE ENTRY FOR LABEL
						! TO GO TO IF CONDITION IS FALSE
			CGCBOOL(.SUBSTATMNT[GOTOLBL],.ELSELAB);
			DEFLAB(.ELSELAB);
		END


		ELSE
		%(***IF CONDITION IS NOT A RELATIONAL OR BOOLEAN, EVALUATE THE CONDEXPR AND
			TEST WHETHER IS IS TRUE (SIGN BIT EQUAL 1) OR FALSE(SIGN=0) ***)%
		BEGIN
			CGETVAL();

			%(***TEST VAL OF CONDEXPR,
				IF "A1NOTFLG" IS SET, TRANSFER TO GOTO-LABEL IF ARG IS
				FALSE, OTHERWISE TRANSFER TO GOTOLABEL IF ARG IS TRUE***)%
			OPDSPIX_CNDVTRIX(CONDEXPR,(IF .CSTMNT[A1NOTFLG] THEN FALSE ELSE TRUE));
			A1LABEL_.SUBSTATMNT[GOTOLBL];
			TREEPTR_.CONDEXPR;
			REGFORCOMP_GETTAC(TREEPTR);
			CGOPGEN();
		END;

	END


	%(****WHEN STATEMENT TO BE EXECUTED ON TRUE CONDITION IS NOT A GOTO***)%
	ELSE
	BEGIN
		ELSELAB_GENLAB();		!CREATE LABEL TABLE ENTRY FOR LABEL
						! TO GO TO WHEN CONDITION IS FALSE

		%(***IF CONDITION TO BE TESTED IS A RELATIONAL***)%
		IF .CONDEXPR[OPRCLS] EQL RELATIONAL
		THEN
		BEGIN
			CGREL1(TRUE);		!SKIP NEXT INSTR IF REL IS TRUE
			%(***GENERTAE CODE TO GO TO THE LABEL ON THE CODE FOLLOWING THAT
				FOR THE SUBSTATMNT OF THE IF STMNT***)%
			JRSTGEN(.ELSELAB);
		END

		%(***IF THE CONDITION TO BE TESTED IS A BOOLEAN*****)%
		ELSE
		IF .CONDEXPR[OPRCLS] EQL BOOLEAN
		THEN
		BEGIN
			THENLAB_GENLAB();	!CREATE LABEL TABLE ENTRY FOR LABEL TO
						! GO TO WHEN CONDITION IS TRUE
			CGCBOOL(.THENLAB,.ELSELAB);
			DEFLAB(.THENLAB);	!ASSOCIATE THIS LOC WITH THENLAB
		END

		%(***IF CONDITIONAL EXPRESSION IS NOT A REL OR BOOLEAN, EVALUATE IT AND
			TEST WHETHER ITS VAL IS TRUE (SIGN=1) OR FALSE (SIGN=0)***)%
		ELSE
		BEGIN
			CGETVAL();

			%(***TEST VAL OF CONDEXPR,
				IF "A1NOTFLG" IS SET, TRANSFER TO ELSELAB IF VAL IS TRUE
				OTHERWISE TRANSFER TO ELSELAB IF VAL IS FALSE***)%
			OPDSPIX_CNDVTRIX(CONDEXPR,(IF .CSTMNT[A1NOTFLG] THEN TRUE ELSE FALSE));
			A1LABEL_.ELSELAB;
			TREEPTR_.CONDEXPR;
			REGFORCOMP_GETTAC(TREEPTR);
			CGOPGEN();
		END;

		%(****GENERATE CODE FOR THE STATEMENT TO BE EXECUTED WHEN THE CONDITION IS TRUE***)%
		TOPSTMNT_.CSTMNT;	!SAVE A PTR TO THIS "TOP-LEVEL" STMNT 
		SAVSTMNT_.CSTMNT;
		CSTMNT_.SUBSTATMNT;
		CGSTMNT();
		CSTMNT_.SAVSTMNT;		!RESTORE THE GLOBAL CSTMNT

		%(***ASSOCIATE THIS LOC WITH THE LABEL TRANSFERED TO WHEN THE CONDITION
			IS FALSE****)%
		DEFLAB(.ELSELAB);

	END;

END;


GLOBAL ROUTINE CGEND=
%(*********************************************************
	TO GENERATE CODE FOR AN END STATEMENT
*****************************************************)%
BEGIN
	EXTERNAL PROEPITYP,ZERBLK;
	!AN END TRIGGERS A CALL TO EXIT ONLY IN A MAIN
	!PROGRAM, NOT FOR A SUBPROGRAM
	!IN A SUBPROGRAM THE END TRIGGERS A RETURN.

	EXTERNAL PROGNAME;
	IF .PROGNAME EQL SIXBIT'MAIN. ' 
	THEN
	BEGIN
		A1LABEL_.ZERBLK;	!ARGLIST FOR CALL TO EXIT IS ALWAYS
					! 0 FOR THE END STMNT
		OPDSPIX_OPGEXI;
		CGOPGEN();
	END
	ELSE
		!ALSO CHECK FOR A BLOCK DATA SUBPROGRAM
		!THESE HAVE THE NAME *.BLOCK*
		IF .PROGNAME NEQ SIXBIT'.BLOCK' THEN
			CGRETURN(0);
END;
GLOBAL ROUTINE CGSTOP=
%(***************************************************************************
	TO GENERATE CODE FOR A STOP STMNT
***************************************************************************)%
BEGIN
	EXTERNAL ZERBLK;


        IF  .CSTMNT[STOPIDENT]  NEQ  0

        THEN
        BEGIN
                A1LABEL  _  GENLAB();
                TREEPTR  _  .CSTMNT[STOPIDENT];
                IF  .TREEPTR[VALTYPE]  EQL  STRING

                THEN
                BEGIN
                        OPDSPIX  _  OPGSES;
                        CGOPGEN();
                        A1NODE  _  .TREEPTR;
                        OPDSPIX  _  OPGSRR;
                        CGOPGEN();
                        OPDSPIX  _  OPGSPR;
                        CGOPGEN();
                END;
        END
        ELSE
        BEGIN
                A1LABEL  _  .ZERBLK;
        END;

        CSTMNT[STOPLBL]  _  .A1LABEL;
        OPDSPIX  _  OPGSTP;
        CGOPGEN();

END;


GLOBAL ROUTINE CGPAUSE=
%(***************************************************************************
	ROUTINE TO GENERATE CODE FOR PAUSE
***************************************************************************)%
BEGIN
        
        EXTERNAL ZERBLK;

        IF  .CSTMNT[PAUSIDENT]  NEQ  0          !AN ARG LIST EXISTS

        THEN
        BEGIN                                   !GENERATE LIST LABEL
                A1LABEL  _  GENLAB();
                TREEPTR  _  .CSTMNT[PAUSIDENT];
                IF  .TREEPTR[VALTYPE]  EQL  STRING

                THEN
                BEGIN
                        OPDSPIX  _  OPGSES;
                        CGOPGEN();
                        A1NODE  _  .TREEPTR;
                        OPDSPIX  _  OPGSRR;
                        CGOPGEN();
                        OPDSPIX  _  OPGSPR;
                        CGOPGEN();
                END;
        END
        ELSE
        BEGIN

        A1LABEL  _  .ZERBLK;
        
        END;

        CSTMNT[PAUSLBL]  _  .A1LABEL;
        OPDSPIX  _  OPGPAU;
        CGOPGEN();
END;
	

GLOBAL ROUTINE CGARIF=
%(***************************************************************************
	ROUTINE TO GENERATE CODE FOR AN ARITHMETIC IF STATEMENT.
	CALLED WITH THE GLOBAL CSTMNT POINTING TO THE STATEMENT
	FOR WHICH CODE IS TO BE GENERATED.
***************************************************************************)%
BEGIN
	EXTERNAL A1LABEL,A2LABEL,A3LABEL;	!GLOBALS USED BY THE CODE-GENERATION
	EXTERNAL REGFORCOMP,A1NODE,A2NODE;	! TABLE DRIVER
	EXTERNAL TREEPTR;

	MAP PEXPRNODE A1NODE:A2NODE:TREEPTR;

	OWN BASE NXTSTMNT;
	OWN PEXPRNODE CONDEXPR;		!THE ARITHMETIC EXPRESSION UNDER THIS STMNT

	%(***COMPUTE ANY COMMON SUBEXPRESSIONS UNDER THIS NODE***)%
	IF .CSTMNT[SRCCOMNSUB] NEQ 0 THEN CGCMNSUB();


	%(***DETERMINE WHICH (IF ANY) OF THE 3 LABELS ASSOCIATED WITH
		THIS NODE ARE EQUAL TO THE LABEL ON THE FOLLOWING STMNT***)%
	NXTSTMNT_.CSTMNT[SRCLINK];
	CSTMNT[AIFLBNXT]_
	BEGIN
		IF .CSTMNT[AIFLESS] EQL .NXTSTMNT[SRCLBL]
		THEN LLBNXT
		ELSE
		IF .CSTMNT[AIFEQL] EQL .NXTSTMNT[SRCLBL]
		THEN ELBNXT
		ELSE
		IF .CSTMNT[AIFGTR] EQL .NXTSTMNT[SRCLBL]
		THEN GLBNXT
		ELSE NOLBNXT
	END;


	%(***GET PTR TO THE CONDITIONAL EXPRESSION***)%
	CONDEXPR_.CSTMNT[AIFEXPR];
	TREEPTR_.CONDEXPR;
	%(***COMPUTE THE VAL OF THE ARITH EXPR, THEN TEST IT****)%

	%(***COMPUTE THE VAL OF THE ARITH EXPR***)%
	IF NOT .CSTMNT[A1VALFLG]
	THEN CGETVAL();

	%(***IF THERE IS A NEG ON THE VALUE, EXCHANGE THE GTR AND LESS LABELS***)%
	IF .CSTMNT[A1NEGFLG]
	THEN
	BEGIN
		A1LABEL_.CSTMNT[AIFGTR];
		A3LABEL_.CSTMNT[AIFLESS];
		A2LABEL_.CSTMNT[AIFEQL];

		%(***MODIFY THE "AIFLBNXT" FIELD WHICH INDICATED WHICH OF
			THE 3 LABELS IS ON THE NEXT STMNT (CHANGE "GTR LABEL NEXT"
			TO "LESS LABEL NEXT", "LESS LABEL NEXT" TO
			"GTR LABEL NXT" LEAVE OTHERS UNCHANGED
			MODIFY THE "AIFLBEQV" FIELD SO THAT "GTR LABEL SAME
			AS EQL LABEL" BECOMES "LESS LABEL SAME AS EQL LABEL"
			AND VICE-VERSA
		****)%
		SWPAIFFLGS(CSTMNT);
	END
	ELSE
	BEGIN
		A1LABEL_.CSTMNT[AIFLESS];
		A3LABEL_.CSTMNT[AIFGTR];
		A2LABEL_.CSTMNT[AIFEQL];
	END;

	%(***USE THE TABLE-DRIVER TO GENERATE CODE TO TEST THE VAL AND TRANSFER***)%
	REGFORCOMP_GETAIFREG(CSTMNT);
	OPDSPIX_AIFIX(CSTMNT,CONDEXPR);
	A1NODE_.CONDEXPR;
	CGOPGEN();
END;

GLOBAL ROUTINE CGCMNSUB=
%(***************************************************************************
	GENERATE CODE TO EVLUATE ANY COMMON SUBEXPRESSIONS THAT OCCUR UNDER
	THE STATEMENT NODE POINTED TO BY "CSTMNT"
***************************************************************************)%
BEGIN
	OWN PEXPRNODE CCMNSUB;

	%(***COMPUTE THE VALUES OF ANY COMMON SUBEXPRS ASSOCIATED WITH THIS STATEMENT***)%
	CCMNSUB_.CSTMNT[SRCCOMNSUB];
	UNTIL .CCMNSUB EQL 0
	DO
	BEGIN
		IF NOT .CCMNSUB[A2VALFLG]
		THEN
		BEGIN
			TREEPTR_.CCMNSUB[ARG2PTR];
			CGETVAL();
		END;

		%(***IF THE COMMON SUBEXPR IS TO BE LEFT IN A DIFFERENT PLACE THAN
			THAT INTO WHICH IT WAS COMPUTED, PUT IT THERE.
			NOT THAT THIS CAN ONLY OCCUR WHEN THE PLACE IN WHICH
			IT IS TO BE LEFT IS A REGISTER.
		*******)%
		IF NOT .CCMNSUB[A2SAMEFLG]
		THEN
		BEGIN
			A1NODE_.CCMNSUB[ARG2PTR];
			OPDSPIX_GETA2OPIX(CCMNSUB,A1NODE);
			REGFORCOMP_GETTAC(CCMNSUB);
			CGOPGEN();
		END;


		%(***IF THE VAL OF THIS COMMON SUB MUST BE STORED INTO A TMP, GENERATE
			CODE TO DO SO***)%
		IF .CCMNSUB[STOREFLG]
		THEN
		BEGIN
			TREEPTR_.CCMNSUB;
			REGFORCOMP_GETTAC(CCMNSUB);
			OPDSPIX_STOROPIX(CCMNSUB);
			CGOPGEN();
		END;


		CCMNSUB_.CCMNSUB[CLINK];
	END;

END;



GLOBAL ROUTINE CGIOLST=
%(***************************************************************************
	ROUTINE TO PERFORM CODE GENERATION FOR AN IOLIST.
	CALLED WITH THE GLOBAL CSTMNT POINTING TO THE STATEMENT FOR WHICH AN
	IOLIST IS TO BE PROCESSED.
	FOR EACH ELEMENT IN THE IOLIST:
		1. IF THE ELEMENT IS A "STATEMENT" (EITHER A DO, OR A CONTINUE
			WHICH TERMINATES A DO-LOOP, OR AN ASSIGNMENT),  PERFORM
			USUAL CODE GENERATION FOR THAT TYPE OF STATEMENT
		2. IF THE ELEMENT IS AN "IOLSCLS" NODE (IE A DATACALL, SLISTCALL,
			IOLSTCALL,E1LISTCALL,OR E2LISTCALL), PERFORM CODE
			GENERATION FOR ALL ELEMENTS UNDER THE NODE AND
			ALSO GENERATE:
				MOVEI	16,ARGBLKP
				PUSHJ	17,IOLST.
			WHERE ARGBLKP IS A PTR TO THE ARGBLOCK FOR THIS ELEMENT
***************************************************************************)%
BEGIN
	LOCAL SAVSTMNT;
	LOCAL BASE IOLELEM;
	EXTERNAL GENLAB;
	EXTERNAL OPDSPIX,A1LABEL,CGOPGEN,OPGFIN;

	%(***GET PTR TO 1ST ELEMENT ON THE IOLIST TO BE PROCESSED***)%
	IOLELEM_.CSTMNT[IOLIST];

	%(***SAVE PTR TO CURRENT STATEMENT (IF THERE ARE DO-STMNTS IN THE IOLIST,
		WILL CLOBBER CSTMNT) *****)%
	SAVSTMNT_.CSTMNT;

	%(***WALK THUR THE IOLIST, PROCESSING ALL ELEMENTS***)%
	UNTIL .IOLELEM EQL 0
	DO
	BEGIN
		IF .IOLELEM[OPRCLS] EQL STATEMENT
		THEN
		BEGIN
			CSTMNT_.IOLELEM;
			CGSTMNT();

			%(***IF THE LAST ELEMENT IN AN IO-LIST FOR  A GIVEN STMNT IS
				NOT OF IOLSCLS (IE DOES NOT GENERATE AN ARG-LIST)
				THEN MUST GENERATE A "PUSHJ 17,FIN."
			********)%
			IF .IOLELEM[CLINK] EQL 0
			THEN
			BEGIN
				OPDSPIX_OPGFIN;
				CGOPGEN();
			END;
		END

		ELSE
		IF .IOLELEM[OPRCLS] EQL IOLSCLS
		THEN
		BEGIN
			%(***GENERATE CODE TO EVALUATE ALL EXPRESSIONS UNDER THIS ELEMENT***)%
			CASE .IOLELEM[OPERSP] OF SET

			%(***FOR A DATACALL NODE - EVAL THE EXPR UNDER THE NODE ***)%
			BEGIN
				TREEPTR_.IOLELEM[DCALLELEM];
				IF .TREEPTR[OPRCLS] NEQ DATAOPR
				THEN
				CGETVAL();
			END;

			%(***FOR AN SLISTCALL NODE - EVAL THE EXPR FOR THE NUMBER OF ELEMS***)%
			BEGIN
				TREEPTR_.IOLELEM[SCALLCT];
				IF .TREEPTR[OPRCLS] NEQ DATAOPR
				THEN
				CGETVAL();
			END;

			%(***FOR AN IOLSTCALL NODE - EVAL ALL EXPRS UNDER IT****)%
			CGIOCALL(.IOLELEM);

			%(***FOR AN E1LISTCALL NODE - NOT IMPLEMENTED IN RELEASE 1***)%
			BEGIN END;

			%(**FOR AN E2LISTCALL NODE - NOT IMPLEMENTED IN RELEASE 1****)%
			BEGIN END;

			TES;


			%(***CREATE A LABEL TABLE ENTRY FOR THE LABEL ASSOCIATED WITH
				THE ARGBLOCK FOR THIS NODE***)%
			A1LABEL_GENLAB();
			IOLELEM[IOLSTLBL]_.A1LABEL;

			%(***GENERATE CALL TO IOLST.***)%
			OPDSPIX_OPGIOL;
			CGOPGEN();
		END
		ELSE CGERR();

		%(***GO ON TO NEXT ELEMENT***)%
		IOLELEM_.IOLELEM[CLINK];
	END;

	CSTMNT_.SAVSTMNT;
END;



GLOBAL ROUTINE CGIOCALL(IOLSNODE)=
%(***************************************************************************
	ROUTINE TO GENERATE THE CODE FOR AN IOLSTCALL NODE.
	GENERATES CODE TO EVALUATE ALL EXPRESSIONS UNDER THE
	IOLSTCALL.
***************************************************************************)%
BEGIN
	MAP BASE IOLSNODE;
	OWN BASE IOLELEM;
	OWN SAVSTMNT;

	%(***SAVE THE GLOBAL CSTMNT***)%
	SAVSTMNT_.CSTMNT;

	%(***GENERATE CODE FOR ANY COMMON SUBEXPRS UNDER THIS NODE***)%
	CSTMNT_.IOLSNODE;
	CGCMNSUB();

	%(***WALK THRU THE ELEMS UNDER THIS IOLSTCALL***)%
	IOLELEM_.IOLSNODE[IOLSTPTR];
	UNTIL .IOLELEM EQL 0
	DO
	BEGIN
		CASE .IOLELEM[OPERSP] OF SET

		%(***FOR A DATACALL****)%
		BEGIN
			TREEPTR_.IOLELEM[DCALLELEM];
			IF .TREEPTR[OPRCLS] NEQ DATAOPR
			THEN CGETVAL();
		END;

		%(***FOR AN SLISTCALL (AN SLIST THAT HAS ONLY ONE ARRAYREF, AND
			THAT ARRAYREF STARTS AT THE BASE OF THE ARRAY, AND THE
			INCREMENT IS A CONSTANT) ***)%
		BEGIN
			TREEPTR_.IOLELEM[SCALLCT];
			IF .TREEPTR[OPRCLS] NEQ DATAOPR
			THEN CGETVAL();
		END;

		%(***AN IOLSTCALL NODE UNDER ANOTHER IOLSTCALL NODE IS ILLEGAL***)%
		CGERR();

		%(***FOR AN S1LISTCALL (AN SLISTCALL THAT WAS DETECTED BY PHASE 2 SKEL - 
			MAY HAVE MORE THAN ONE ARRAYREF, VARIABLE BASE AND/OR INCR):
			NOT IMPLEMENTED IN RELEASE 1*****)%
		BEGIN END;

		%(***FOR AN ELISTCALL: NOT IMPLEMENTED IN RELEASE 1***)%
		BEGIN END;

		TES;

		IOLELEM_.IOLELEM[CLINK];
	END;

	%(***RESTORE CSTMNT***)%
	CSTMNT_.SAVSTMNT;
END;


MAP PEXPRNODE TREEPTR;




GLOBAL ROUTINE CGIOLARGS=
%(***************************************************************************
	ROUTINE TO GENERATE THE ARG BLOCKS FOR AN IOLIST.
	CALLED WITH THE GLOBAL TREEPTR POINTING TO THE IOLIST.
***************************************************************************)%
BEGIN
	MAP OBJECTCODE PBOPWD;
	MAP PEXPRNODE PSYMPTR;
	OWN SAVTREEPTR;

	%(***WALK THRU ALL THE ELEMENTS ON THE IOLIST***)%
	UNTIL .TREEPTR EQL 0
	DO
	BEGIN
		%(**ONLY GENERATE ARG BLOCKS FOR NODES OF OPRCLS "IOLSCLS" (IGNORE
			STATEMENT NODES) ***)%
		IF .TREEPTR[OPRCLS] EQL IOLSCLS
		THEN
		BEGIN
			%(***ASSOCIATE CURRENT LOC WITH THE LABEL ON THIS ARGBLOCK***)%
			DEFLAB(.TREEPTR[IOLSTLBL]);


			%(********GENERATE THE ARG BLOCK************************)%
			CASE .TREEPTR[OPERSP] OF SET

			%(***FOR DATACALL***)%
			CGDCALL();

			%(***FOR SLISTCALL***)%
			CGSLIST();

			%(***FOR IOLSTCALL***)%
			BEGIN
				%(***SAVE VAL OF TREEPTR***)%
				SAVTREEPTR_.TREEPTR;

				%(***WALK THRU THE ELEMENTS UNDER THIS NODE, GENERATING
					ARG BLOCKS FOR THEM***)%
				TREEPTR_.TREEPTR[IOLSTPTR];
				UNTIL .TREEPTR EQL 0
				DO
				BEGIN
					CASE .TREEPTR[OPERSP] OF SET
					CGDCALL();	!FOR A DATACALL
					CGSLIST();	!FOR AN SLIST
					CGERR();	!IOLSTCALL IS ILLEGAL UNDER
							! ANOTHER IOLSTCALL
					BEGIN END;	!S1LISTCALL (UNIMPLEMENTED
							! IN RELEASE 1)
					BEGIN END;	!ELISTCALL (UNIMPLEMENTED
							! IN RELEASE 1)
					TES;

					TREEPTR_.TREEPTR[CLINK];
				END;

				%(***RESTORE TREEPTR***)%
				TREEPTR_.SAVTREEPTR;
			END;

			%(***FOR S1LISTCALL (AN SLIST DETECTED IN PHASE 2 SKEL -
				MAY HAVE MORE THAN ONE ARRAYREF AND VARIABLE BASE
				AND INCR) - NOT IN RELEASE 1***)%
			BEGIN END;

			%(***FOR ELIST - NOT IN RELEASE 1***)%
			BEGIN END

			TES;


			%(***IF THIS IS THE LAST ARG-BLOCK FOR THIS STMNT, GENERATE A FIN-BLOCK
				AFTER IT; OTHERWISE GENERATE A ZERO-BLOCK AFTER IT***)%
			PBOPWD_(IF .TREEPTR[CLINK] EQL 0 THEN OTSFINWD ELSE OTSZERWD);
			PSYMPTR_PBF2NOSYM;
			OBUFFA();
		END;

		%(***GO ON TO NEXT ELEMENT***)%
		TREEPTR_.TREEPTR[CLINK];
	END;
END;



GLOBAL ROUTINE CGDCALL=
%(***************************************************************************
	ROUTINE TO GENERATE AN ARG BLOCK FOR A DATACALL ELEMENT IN AN IOLIST
	CALLED WITH THE GLOBAL TREEPTR POINTING TO THE DATACALL NODE FOR
	WHICH THE BLOCK IS TO BE GENERATED.
***************************************************************************)%
BEGIN
	MAP OBJECTCODE PBOPWD;
	MAP PEXPRNODE PSYMPTR;
	OWN PEXPRNODE ARGNODE;
	EXTERNAL EVALU;

	%(***GET PTR TO THE EXPRESSION-NODE WHOSE VAL IS TO BE AN ARG***)%
	ARGNODE_.TREEPTR[DCALLELEM];


	%(***INIT OUTPUT WD TO 0****)%
	PBOPWD_0;

	%(***SET ID FIELD OF OUTPUT WD TO INDICATE DATA***)%
	PBOPWD[OTSIDN]_OTSDATA;

	%(***SET TYPE FIELD OF ARG BLOCK TO THE EXTERNAL-TYPE CODE CORRESPONDING
		TO THE VALTYPE INDICATED IN ARGNODE***)%
	PBOPWD[OTSTYPE]_.EVALU[.ARGNODE[VALTYPE]];

	%(***IF THE EXPRESSION IS A SCALER VARIABLE***)%
	IF .ARGNODE[OPRCLS] EQL DATAOPR
	THEN
	BEGIN
		PBOPWD[OTSADDR]_.ARGNODE[IDADDR];
		PSYMPTR_.ARGNODE;		!PTR TO SYMBOL TABLE ENTRY
	END

	ELSE
	%(***IF THE EXPRESSION IS AN ARRAYREF****)%
	IF .ARGNODE[OPRCLS] EQL ARRAYREF
	THEN
	BEGIN
		PBOPWD[OTSMEMRF]_.ARGNODE[TARGTMEM];
		PSYMPTR_.ARGNODE[ARG1PTR];

		%(***FOR A FORMAL ARRAY, WILL NOT WANT TO RELOCATE THE ADDRESS
			FIELD OF THE ARGUMENT - SINCE WILL HAVE COMPUTED THE ARRAY BASE
			ADDRESS INTO THE SUBSCRIPT***)%
		IF .PSYMPTR[FORMLFLG] THEN PSYMPTR_PBF2NOSYM;
	END

	ELSE
	%(***IF THE VAL OF THE EXPRESSION IS IN A REG***)%
	IF .ARGNODE[INREGFLG]
	THEN
	BEGIN
		PBOPWD[OTSADDR]_.ARGNODE[TARGADDR];
		PSYMPTR_PBF2NOSYM;
	END

	ELSE
	%(***IF THE VAL OF THE EXPRESSION IS IN A TEMP***)%
	BEGIN
		PSYMPTR_.ARGNODE[TARGADDR];
		PBOPWD[OTSADDR]_.PSYMPTR[IDADDR];
		PBOPWD[OTSIND]_.ARGNODE[TARGIF];
	END;

	OBUFFA();
END;





GLOBAL ROUTINE CGSLIST=
%(***************************************************************************
	ROUTINE TO GENERATE AN ARGUMENT BLOCK FOR AN SLIST CALL
	IN AN IOLIST.
	CALLED WITH THE GLOBAL POINTING TO THE SLISTCALL NODE.
	THIS ROUTINE IS USED ONLY FOR THE SLISTS GENERATED BY
	PHASE 1 FOR STMNTS OF THE FORM:
		READ 11,A
	WHERE A IS AN ARRAY. 
	IN A LATER RELEASE, PHASE 2 SKELETON WILL RECOGNIZE 
	IOLISTS THAT CAN BE TRANSFORMED INTO SLISTS AND WILL FORM
	"S1LISTCALL" NODES FOR THESE SLISTS (WHICH MAY HAVE MORE THAN ONE ARRAY
	AND INCREMENTS OTHER THAN 1).
***************************************************************************)%
BEGIN
	MAP OBJECTCODE PBOPWD;
	MAP PEXPRNODE PSYMPTR;
	EXTERNAL EVALU;

	%(******OUTPUT FIRST WD OF ARGBLOCK (WD CONTAINING CODE FOR SLSIST AND COUNT)*****)%

	%(***INIT OUTPUT WD TO 0***)%
	PBOPWD_0;

	%(***SET IDN FIELD TO CODE FOR SLSIST**)%
	PBOPWD[OTSIDN]_OTSSLIST;

	%(***BUILD THE WD THAT CONTAINS THE CT***)%
	BLDIOIMWD(.TREEPTR[SCALLCT]);

	OBUFFA();

	%(****OUTPUT THE 2ND WD  OF ARGBLOCK (WHICH CONTAINS THE INCREMENT 1)***)%
	PBOPWD_1;
	PSYMPTR_PBF2NOSYM;
	OBUFFA();

	%(***OUTPUT THE 3RD WD (WHICH CONTAINS A PTR TO THE ARRAY TO BE USED)*******)%

	%(***GET PTR TO SYMBOL TABLE ENTRY FOR THE ARRAY***)%
	PSYMPTR_.TREEPTR[SCALLELEM];

	%(***ADDRESS FOR ARGBLOCK IS ADDRESS INDICATED BY THE SYMBOL TABLE ENTRY***)%
	PBOPWD[OTSADDR]_.PSYMPTR[IDADDR];
	PBOPWD[OTSTYPE]_.EVALU[.PSYMPTR[VALTYPE]];

	%(***SET INDIRECT BIT FOR A FORMAL ARRAY***)%
	IF .PSYMPTR[FORMLFLG]
	THEN
	PBOPWD[OTSIND]_1;

	OBUFFA();


END;



GLOBAL ROUTINE BLDIOIMWD(ARGNODE)=
%(***************************************************************************
	ROUTINE TO BUILD A WD OF AN ARGUMENT BLOCK FOR FOROTS WHEN
	THAT WORD IS TO HAVE EITHER THE FORM:
		1. INDIRECT BIT=0, IMMEDIATE CONSTANT IN RIGHT HALF
	  OR	2. INDIRECT BIT=1, PTR TO VAL IN RIGHT HALF
	CALLED WITH THE ARG:
		ARGNODE - PTR TO THE EXPRESSION NODE FOR THE VAL TO
				BE REPRESENTED
	CALLED WITH PBOPWD INITIALIZED SUCH THAT THE FIRST 9 BITS HAVE
	THE VALUE DESIRED,AND THE RIGHT 27 BITS ARE 0.
***************************************************************************)%
BEGIN
	MAP OBJECTCODE PBOPWD;
	MAP PEXPRNODE PSYMPTR;
	MAP PEXPRNODE ARGNODE;


	%(***IF THE ARG IS A CONSTANT, USE THE IMMEDIATE FORM***)%
	IF .ARGNODE[OPR1] EQL CONSTFL
	THEN
	BEGIN
		PBOPWD[OTSADDR]_.ARGNODE[CONST2];
		PSYMPTR_PBF2NOSYM;		!FLAG TO OUTMOD THAT NO SYMBOLIC
						! REPRESENTATION CAN BE USED
	END

	ELSE
	%(***IF ARG IS A VARIABLE, USE INDIRECT THRU ITS ADDR***)%
	IF .ARGNODE[OPRCLS] EQL DATAOPR
	THEN
	BEGIN
		PBOPWD[OTSIND]_1;
		PBOPWD[OTSADDR]_.ARGNODE[IDADDR];
		PSYMPTR_.ARGNODE;		!PTR TO SYMBOL TABLE ENTRY
	END

	ELSE
	%(***IF ARG IS AN EXPRESSION,  USE THE TEMP IN WHICH THE VAL WAS STORED***)%
	BEGIN
		%(***IF VAL WAS LEFT IN AREG***)%
		IF .ARGNODE[INREGFLG]
		THEN
		BEGIN
			PBOPWD[OTSADDR]_.ARGNODE[TARGADDR];
			PBOPWD[OTSIND]_1;
			PSYMPTR_PBF2NOSYM;
		END

		ELSE
		%(***IF VAL WAS LEFT IN A TEMP***)%
		BEGIN
			%(***GET PTR TO TEMPORARY TABLE ENTRY***)%
			PSYMPTR_.ARGNODE[TARGADDR];
			PBOPWD[OTSADDR]_.PSYMPTR[IDADDR];
			PBOPWD[OTSIND]_1;
		END;
	END;

END;




GLOBAL ROUTINE CGSTPAUARGS=
%(***************************************************************************
	ROUTINE TO GENERATE THE ARG BLOCK FOR A STOP/PAUSE STMNT.
	THIS BLOCK WILL HAVE THE FORM:
		-------------------------------
		!   ARGCT	!    0		!
		---------------------------------
	LABEL:	!     !TYPE !	!  ARGPTR	!
		----------------------------------
	WHERE "LABEL" IS THE ARG-BLOCK LABEL, ARGCT IS NEG ARGCT AND WILL ALWAYS
	BE -1 OR 0, TYPE IS THE VALUE TYPE OF THE ARG (LITERAL,OCTAL,INTEGER,REAL
	DOUBLE PREC, OR COMPLEX) AND IS IN BITS 9-12, AND ARGPTR PTS TO THE ARG

	THIS ROUTINE IS CALLED WITH THE GLOBAL "CSTMNT" POINTING TO THE STOP OR
	PAUSE STMNT FOR WHICH AN ARG-BLOCK IS TO BE GENERATED.
***************************************************************************)%
BEGIN
	EXTERNAL EVALU;			!TABLE OF EXTERNAL VALUE-TYPE CODES
	MAP OBJECTCODE PBOPWD;		!GLOBAL IN WHICH THE WD TO
					! BE OUTPUT IS PASSED TO THE ROUTINE "OBUFFA"

	MAP PEXPRNODE PSYMPTR;		!WILL PT TO THE SYMBOL TABLE ENTRY (OR
					! CONSTANT TABLE ENTRY) FOR THE ARG OF THE STOP/PAUSE


	%(***IF THE STOP/PAUSE HAD NO ARG, WILL HAVE USED "ZERBLK" FOR THE
		ARG-BLOCK. SO DONT HAVE TO GENERATE ANYTHING.***)%
	IF .CSTMNT[PAUSIDENT] EQL 0
	THEN RETURN;


	%(***IF THIS STMNT WAS ELIMINATED (BY FOLDING A LOG IF), DO NOT WANT TO
		GENERATE AN ARG LIST***)%
	IF .CSTMNT[PAUSLBL] EQL 0 THEN RETURN;


        PSYMPTR  _  .CSTMNT[PAUSIDENT];

	%(***OUTPUT THE ARG-CT WD*****)%
	PSYMPTR_PBF2NOSYM;
	PBOPWD_(-1)^18;
	OBUFFA();

	%(***ASSOCIATE THE LABEL FOR THIS ARG-LIST WITH THE 2ND WD***)%
	DEFLAB(.CSTMNT[PAUSLBL]);

	%(***OUTPUT THE PTR WD***)%
	PSYMPTR_.CSTMNT[PAUSIDENT];
	PBOPWD_0;				!INIT WD TO BE OUTPUT TO 0
	PBOPWD[OTSTYPE]_.EVALU[.PSYMPTR[VALTYPE]];	!SET TYPE FIELD OF WD TO BE OUTPUT
	PBOPWD[OTSADDR]_.PSYMPTR[IDADDR];		!ADDRESS OF VAR/CONSTANT/LITERAL
							! TO BE OUTPUT
	OBUFFA();

	RETURN
END;

!AUTHOR: NORMA ABEL


!THIS FILE CONTAINS THE ROUTINES NECESSARY TO GENERATE CODE
!FOR THE I/O STATEMENTS THEMSELVES. WHERE APPROPRIATE THE ROUTINE
!CGIOLST IS CALLED TO GENERATE THE CALLS TO IOLST.

GLOBAL ROUTINE CGMTOP=
BEGIN
	!CALLS TO MTOP FOR ALL STATEMENTS BACKID THRU ENDFID

	EXTERNAL CSTMNT,GENLAB,A1LABEL,CGOPGEN,OPDSPIX;
	MAP BASE CSTMNT;

	EXTERNAL OPGMTO;
	!FILL IN IOARGLBL FIELD
	A1LABEL_CSTMNT[IOARGLBL]_GENLAB();
	OPDSPIX_OPGMTO;
	CGOPGEN();
END;

GLOBAL ROUTINE CGENCO=
BEGIN
	!CODE GENERATION FOR ENCODE

	EXTERNAL CSTMNT,GENLAB,A1LABEL,CGOPGEN,OPDSPIX;
	MAP BASE CSTMNT;

	EXTERNAL CGIOLST,OPGENC;
	EXTERNAL TREEPTR,CGETVAL;

	%(***IF THE COUNT FIELD IS AN EXPRESSION, EVALUATE IT***)%
	TREEPTR_.CSTMNT[IOCNT];
	CGETVAL();

	%(***IF THE ENCODE VAR IS AN ARRAY-REF, GENERATE CODE FOR THE
		SS CALCULATION***)%
	TREEPTR_.CSTMNT[IOVAR];
	CGETVAL();

	!FILL IN IOARGLBL FIELD
	A1LABEL_CSTMNT[IOARGLBL]_GENLAB();
	OPDSPIX_OPGENC;
	CGOPGEN();
	CGIOLST();
END;

GLOBAL ROUTINE CGDECO=
BEGIN
	!CODE GENERATION FOR DECODE
	EXTERNAL CSTMNT,GENLAB,A1LABEL,CGOPGEN,OPDSPIX;
	MAP BASE CSTMNT;
	EXTERNAL OPGDEC,CGIOLST;

	%(***IF THE COUNT FIELD IS AN EXPRESSION, EVALUATE IT***)%
	TREEPTR_.CSTMNT[IOCNT];
	CGETVAL();


	%(***IF THE DECODE ARRAY IS AN ARRAYREF - CALCULATE THE
		OFFSET***)%
	TREEPTR_.CSTMNT[IOVAR];
	CGETVAL();

	!FILL IN IOARGLBL FIELD
	A1LABEL_CSTMNT[IOARGLBL]_GENLAB();
	OPDSPIX_OPGDEC;
	CGOPGEN();
	CGIOLST();
END;

GLOBAL ROUTINE CGRERE=
BEGIN
	!CODE GENERATION FOR REREAD

	EXTERNAL CSTMNT,GENLAB,A1LABEL,CGOPGEN,OPDSPIX;
	EXTERNAL OPGFIN;
	MAP BASE CSTMNT;
	EXTERNAL CGIOLST,OPGIN;
	!FILL IN IOARGLBL FIELD
	A1LABEL_CSTMNT[IOARGLBL]_GENLAB();
	OPDSPIX_OPGIN;
	CGOPGEN();
	IF .CSTMNT[IOLIST]EQL 0
	THEN
	BEGIN
		%(***IF HAVE NO IOLIST GENERATE A CALL TO FIN***)%
		OPDSPIX_OPGFIN;
		CGOPGEN();
	END
	ELSE
	CGIOLST();
END;

GLOBAL ROUTINE CGRECNUM=
%(***************************************************************************
	TO GENERATE THE CODE TO COMPUTE THE RECORD NUMBER FOR AN IO STMNT
	THAT HAS AN EXPRESSION FOR A RECORD NUMBER (UGH!!!)
***************************************************************************)%
BEGIN
	EXTERNAL CSTMNT;
	MAP PEXPRNODE CSTMNT;
	OWN PEXPRNODE RECNUM;

	IF (RECNUM_.CSTMNT[IORECORD]) NEQ 0
	THEN
	BEGIN
		IF .RECNUM[OPRCLS] NEQ DATAOPR
		THEN
		BEGIN
			TREEPTR_.RECNUM;
			CGETVAL()
		END
	END
END;

GLOBAL ROUTINE CGREAD=
BEGIN
	!CODE GENERATION FOR ALL TYPES OF READ
	EXTERNAL CSTMNT,GENLAB,A1LABEL,CGOPGEN,OPDSPIX;
	MAP BASE CSTMNT;
	EXTERNAL CGIOLST,OPGNLI,OPGIN,OPGRTB,OPGFIN;
	LOCAL BASE T1;

	!FILL IN IOARGLBL FIELD
	A1LABEL_CSTMNT[IOARGLBL]_GENLAB();

	%(***IF THERE AN EXPRESSION TO BE EVALUATED FOR THE RECORD NUMBER (UGH!!!)
		GENERATE CODE TO EVALUATE IT***)%
	CGRECNUM();

	IF .CSTMNT[IOLIST] EQL 0 THEN

		BEGIN
			T1_.CSTMNT[IONAME];
			IF .T1[OPRCLS] NEQ STATEMENT AND	!IONAME ==IOFORM
			 .T1[IDATTRIBUT(NAMNAM)] THEN

			   OPDSPIX_OPGNLI	!NAME LIST READ

			ELSE
			IF .CSTMNT[IOFORM] EQL 0
			THEN OPDSPIX_OPGRTB	!BINARY READ
			ELSE

			   OPDSPIX_OPGIN;	!FORMATED READ
			CGOPGEN();

			OPDSPIX_OPGFIN;
			CGOPGEN();

		END ELSE
		BEGIN
			IF .CSTMNT[IOFORM] EQL 0 THEN

			   OPDSPIX_OPGRTB
			ELSE
			   OPDSPIX_OPGIN;
			CGOPGEN();
			CGIOLST();
		END;
END;


GLOBAL ROUTINE CGWRIT=
BEGIN
	!CODE GENERATION FOR WRITE STATEMENTS OF ALL FORMS

	EXTERNAL CGOPGEN,OPDSPIX,A1LABEL,OPGOUT,OPGNLO,OPGWTB,GENLAB,
		CGIOLST,CSTMNT,OPGFIN;

	MAP BASE CSTMNT;

	LOCAL BASE T1;

		!FILL IN IOARGLBL FIELD

		A1LABEL_CSTMNT[IOARGLBL]_GENLAB();

	%(***IF THERE AN EXPRESSION TO BE EVALUATED FOR THE RECORD NUMBER (UGH!!!)
		GENERATE CODE TO EVALUATE IT***)%
	CGRECNUM();


		IF .CSTMNT[IOLIST] EQL 0 THEN

		BEGIN
			T1_.CSTMNT[IONAME];
			IF .T1[OPRCLS] NEQ STATEMENT AND
			 .T1[IDATTRIBUT(NAMNAM)] THEN
			OPDSPIX_OPGNLO

			ELSE

			   OPDSPIX_OPGOUT;
			CGOPGEN();

			OPDSPIX_OPGFIN;
			CGOPGEN();
		END ELSE
		BEGIN

		IF .CSTMNT[IOFORM] EQL 0 THEN
		   OPDSPIX_OPGWTB
		ELSE
		   OPDSPIX_OPGOUT;
			CGOPGEN();
			CGIOLST();
		END;
END;

GLOBAL ROUTINE CGOPEN=
BEGIN
	!CODE GENERATION FOR THE CALL TO OPEN.

	EXTERNAL CGOPGEN,OPDSPIX,A1LABEL,GENLAB,OPGOPE;
	EXTERNAL CSTMNT;  MAP BASE CSTMNT;

	!FILL IN IOARGLBL FIELD

	A1LABEL_CSTMNT[IOARGLBL]_GENLAB();

	OPDSPIX_OPGOPE;
	CGOPGEN();
END;

GLOBAL ROUTINE CGRELS=
BEGIN
	!CODE GENERATION FOR RELAEASE STATEMENT

	EXTERNAL CSTMNT,CGOPGEN,OPDSPIX,A1LABEL,OPGREL,GENLAB;
	MAP BASE CSTMNT;
	!FILL IN IOARGLBL FIELD

	A1LABEL_CSTMNT[IOARGLBL]_GENLAB();
	OPDSPIX_OPGREL;
	CGOPGEN();
END;

GLOBAL ROUTINE CGFIND=
BEGIN
	!CODE GENERATION FOR FIND

	EXTERNAL CGOPGEN,CSTMNT,A1LABEL,GENLAB,OPDSPIX,OPGFND;

	MAP BASE CSTMNT;
	!FILL IN IOARGLBL FIELD
	A1LABEL_CSTMNT[IOARGLBL]_GENLAB();

	%(***IF THERE AN EXPRESSION TO BE EVALUATED FOR THE RECORD NUMBER (UGH!!!)
		GENERATE CODE TO EVALUATE IT***)%
	CGRECNUM();

	OPDSPIX_OPGFND;
	CGOPGEN();
END;

GLOBAL ROUTINE CGCLOS=
BEGIN
	!CODE GENERATION FOR CLOSE STATEMENT

	EXTERNAL CSTMNT,GENLAB,A1LABEL,OPDSPIX,CGOPGEN,OPGCLO;

	MAP BASE CSTMNT;

	!FILL IN IOARGLBL FIELD

	A1LABEL_CSTMNT[IOARGLBL]_GENLAB();

	OPDSPIX_OPGCLO;
	CGOPGEN();
END;

MACRO
	IOWHOLE=0,7,0,36$,
	OPENFFIELD=0,33,3$,
	OPENGFIELD=0,27,5$,
	OPENCODE=0,0,18,18$,
	OPENARG=0,0,0,18$,
	UTILLOW=BACKID$,
	UTILHI=ENDFID$;
GLOBAL ROUTINE	CGDECARGS=
%(***************************************************************************
	TO GENERATE THE ARG BLOCK FOR AN ENCODE OR DECODE STATEMENT
	ARG BLOCK HAS THE FORM:
		--------------------------------------------------
		!	-6		!			!
		--------------------------------------------------
		!	!TYPE	!I! X	! CHAR CT (IMMED)	!
		--------------------------------------------------
		!	!TYPE	!I! X	!  END=			!
		--------------------------------------------------
		!	!TYPE	!I! X	!  ERR=			!
		--------------------------------------------------
		!	!TYPE	!I! X	!  FORMAT ADDR		!
		--------------------------------------------------
		!	!TYPE	!I! X	!  FORMAT SIZE(IMMED)	!
		--------------------------------------------------
		!	!TYPE	!I! X	!   VAR ARRAY ADDR	!
		--------------------------------------------------
	WHERE THE ARGLIST PTR POINTS TO THE WORD CONTAINING THE CHAR CT (IE
	THE -6 IS IN THE WD PRECEEDING THE ARG PTR)
***************************************************************************)%
BEGIN
	EXTERNAL IOIMMED,IOPTR;
	EXTERNAL PBOPWD,CSTMNT,PSYMPTR,OBUFF;
	EXTERNAL IOENDERR,IOFORMAT,EVALU;
	MAP PEXPRNODE CSTMNT;		!ENCODE OR DECODE STMNT FOR WHICH ARG BLOCK
					! IS TO BE GENERATED
	MAP OBJECTCODE PBOPWD;

	OWN PEXPRNODE ENCARRAY;		!ARRAY TO BE INPUT OR OUTPUT
	OWN PEXPRNODE CHARCT;		!NUMBER OF CHARS TO BE PROCESSED

	ENCARRAY_.CSTMNT[IOVAR];
	CHARCT_.CSTMNT[IOCNT];

	%(***OUTPUT WD CONTAINING THE CT OF WDS IN THE ARGLIST***)%
	PBOPWD_(-6)^18;		!CT IN LEFT HALF WD
	PSYMPTR_PBF2NOSYM;
	OBUFFA();

	%(***ASSOCIATE THE LABEL ON THE ARGLIST WITH THIS LOC***)%
	DEFLAB(.CSTMNT[IOARGLBL]);




	%(***SET UP THE COUNT OF CHARS TO BE PROCESSED IN THE 1ST WD OF THE ARG BLOCK***)%
	IOIMMED(.CHARCT);

	IOENDERR();		!OUTPUT THE END/ERROR WORDS OF THE ARG BLOCK

	IOFORMAT();		!OUTPUT THE FORMAT WDS OF THE ARG BLOCK

	%(***OUTPUT A PTR TO THE ARRAY***)%
	IOPTR(.ENCARRAY);
END;



ROUTINE	IO1ARG(NUMB)=
%(*********************
	ROUTINE TO OUTPUT 2 WDS OF THE FORM:
		--------------------------------------------------
		!	-CT		!			!
		-------------------------------------------------
	 LAB:	!	! TYPE	!I! X	!	UNIT		!
		---------------------------------------------------
	WHERE "UNIT" IS IMMEDIATE
***********************)%
BEGIN
	OWN 	BASE	CNTINFO;
	EXTERNAL	PBOPWD,PSYMPTR,OBUFF,CSTMNT;
	MAP	BASE	CSTMNT;
	MAP OBJECTCODE	PBOPWD;

	%(***OUTPUT MINUS THE CT OF WDS IN THE ARG BLOCK***)%
	PBOPWD_(-.NUMB)^18;	!CT IN LEFT HALF WD
	PSYMPTR_PBF2NOSYM;
	OBUFFA();

	%(***ASSOCIATE THE LABEL ON THE ARG BLOCK WITH THIS LOC***)%
	DEFLAB(.CSTMNT[IOARGLBL]);


	PBOPWD_0;		!INIT WD TO BE OUTPUT

	CNTINFO_.CSTMNT[IOUNIT];
	IF .CNTINFO[OPR1] EQL CONSTFL THEN
	BEGIN
		PSYMPTR_PBF2NOSYM;
		PBOPWD[OTSUNIT]_.CNTINFO[CONST2];	!IT HAD BETTER BE AN
							!IMMEDIATE INTEGER
	END ELSE
	BEGIN
		PSYMPTR_(IF .CNTINFO[OPRCLS] EQL REGCONTENTS THEN
			PBF2NOSYM
			ELSE
			.CNTINFO);
		PBOPWD[OTSUNIT]_.CNTINFO[IDADDR];
		PBOPWD_.PBOPWD OR INDBIT;
	END;

	PBOPWD[OTSTYPE]_IMMEDTYPE;	!SET TYPE CODE INDICATING THAT THIS ARG
					! SHOULD BE REFERENCED IMMEDIATE

	OBUFFA();
	PBOPWD_0;
END;
GLOBAL ROUTINE IOENDERR=
%(***********************
	OUTPUT THE END= AND ERR-= WORDS OF AN IO ARG BLOCK.
	THESE 2 WDS HAVE THE FORM:
		---------------------------------------------------------
		!	! TYPE	!I! X	!	IOEND			!
		---------------------------------------------------------
		!	! TYPE	!I! X	!	IOERR			!
		---------------------------------------------------------
**************************)%
BEGIN
	EXTERNAL PBOPWD,OBUFFA,PSYMPTR,CSTMNT;
	MAP BASE CSTMNT;
	MAP OBJECTCODE PBOPWD;
	%(***OUTPUT THE "END" WD***)%
	PBOPWD_0;
	IF .CSTMNT[IOEND] EQL 0
	THEN PSYMPTR_PBF2NOSYM
	ELSE
	BEGIN
		PBOPWD[OTSTYPE]_ADDRTYPE;	!TYPE IS "ADDRESS"
		PBOPWD[OTSADDR]_.CSTMNT[IOEND];
		PSYMPTR_PBFLABREF;
	END;
	OBUFFA();

	%(***OUTPUT THE "ERROR" WD***)%
	PBOPWD_0;
	IF .CSTMNT[IOERR] EQL 0
	THEN PSYMPTR_PBF2NOSYM
	ELSE
	BEGIN
		PBOPWD[OTSTYPE]_ADDRTYPE;	!TYPE IS "ADDRESS"
		PBOPWD[OTSADDR]_.CSTMNT[IOERR];
		PSYMPTR_PBFLABREF;
	END;
	OBUFFA();

	PBOPWD_0;
END;


GLOBAL ROUTINE IOFORMAT=
%(********************
	ROUTINE TO OUTPUT THE 2 FORMAT WDS OF AN IO ARG-BLOCK
	THESE WDS HAVE THE FORM:
		----------------------------------------------------------
		!	! TYPE	!I! X	!	FORMAT ADDR		!
		----------------------------------------------------------
		!	! TYPE	!I! X!	!	FORMAT SIZE		!
		----------------------------------------------------------
************************)%
BEGIN
	EXTERNAL ENTRY,ERROUT;
	EXTERNAL CSTMNT,PBOPWD,OBUFFA,PSYMPTR;
	EXTERNAL EVALU;
	MAP BASE CSTMNT;
	MAP OBJECTCODE PBOPWD;
	MAP PEXPRNODE PSYMPTR;
	OWN BASE T:FORMATP;
	FORMATP_.CSTMNT[IOFORM];
	!IOSTATEMENT CONTAINS POINTER TO LABEL TABLES
	!OR VARIABLE

	PBOPWD_0;

	IF .FORMATP[OPRCLS] EQL LABOP
	 THEN
	%(***IF FORMAT IS A STMNT- HAVE A PTR TO THE LABEL TABLE ENTRY FOR ITS LABEL***)%
	BEGIN
		FORMATP_.FORMATP[SNHDR];

		%(***IF THE STMNT REFERENCED IS NOT A FORMAT STMNT, GIVE AN ERROR MESSAGE.***)%
		IF .FORMATP[SRCID] NEQ FORMID
		THEN
		BEGIN
			ENTRY[1]_.FORMATP[SRCISN];	!ISN OF THE STMNT BEING
							! USED ERRONEOUSLY AS A FORMAT
			ERROUT(83);

			%(***PUT OUT 2 WDS OF 0 FOR THE FORMAT WDS***)%
			ZIPOUT;
			ZIPOUT;

			RETURN;
		END;


		%(***OUTPUT THE FORMAT ADDRESS WD***)%
		PBOPWD[OTSADDR]_.FORMATP[FORADDR];
		PBOPWD[OTSTYPE]_ADDRTYPE;		!TYPE FIELD EQL TO "ADDRESS"
							! INDICATES THAT FORMAT IS NOT 
							! AN ARRAY
		PSYMPTR_PBFFORMAT;
		OBUFFA();

		%(***OUTPUT THE FORMAT SIZE WD***)%
		PBOPWD_.FORMATP[FORSIZ];
		PBOPWD[OTSTYPE]_IMMEDTYPE;	!SIZE IS REFERENCED IMMED
		PSYMPTR_PBF2NOSYM;
		OBUFFA();
	END
	ELSE
	%(***IF FORMAT IS AN ARRAY, HAVE A PTR TO THE SYMBOL TABLE ENTRY FOR THE ARRAY NAME***)%
	BEGIN
		%(***OUTPUT THE FORMAT ADDRESS WD - IF THE ARRAY IS A FORMAL SHOULD
			SET THE INDIRECT BIT***)%
		PBOPWD[OTSADDR]_.FORMATP[IDADDR];	!ADDRESS OF THE ARRAY
		IF .FORMATP[FORMLFLG] THEN PBOPWD[OTSIND]_1;
		PBOPWD[OTSTYPE]_.EVALU[.FORMATP[VALTYPE]];	!TYPE OF THE ARRAY
		PSYMPTR_.FORMATP;			!PTR TO THE SYMBOL TABLE ENTRY
							! FOR THE ARRAY
		OBUFFA();

		%(***OUTPUT THE FORMAT SIZE WORD. IT WILL BE REFERENCED IMMED, HENCE IF
			THE ARRAY SIZE IS VARIABLE, SET THE INDIRECT BIT***)%
		PBOPWD_0;
		T_.FORMATP[IDDIM];		!GET PTR TO DIMENSION TABLE ENTRY

		IF .T[ADJDIMFLG]
		THEN
		%(***IF THE ARRAY IS ADJUSTABLY DIMENSIONED***)%
		BEGIN
			PSYMPTR_.T[ARASIZ];		!PTR TO THE SYM TAB ENTRY FOR THE
							! TMP THAT HOLDS THE ARRAY SIZE
			PBOPWD[OTSADDR]_.PSYMPTR[IDADDR];
			PBOPWD[OTSIND]_1;
		END
		ELSE
		BEGIN
			PBOPWD[OTSADDR]_.T[ARASIZ];	!THE CONSTANT FOR ARRAY SIZE
			PSYMPTR_PBF2NOSYM;
		END;
		PBOPWD[OTSTYPE]_IMMEDTYPE;	!IMDICATING TO REFERENCE IMMED
		OBUFFA();
	END;
	PBOPWD_0;
END;
GLOBAL ROUTINE IOPTR(EXPR)=
BEGIN
	!OUTPUT A WORD OF THE FORM
	!
	!
	!-----------------------------------------------!
	!		!TYPE !I!  X  !  ADDRESS	!
	!-----------------------------------------------!
	!
	!
	EXTERNAL CSTMNT,PBOPWD,OBUFFA,PSYMPTR,EVALU;
	MAP PEXPRNODE PSYMPTR;
	MAP BASE CSTMNT:EXPR;
	MAP OBJECTCODE PBOPWD;

	%(***FILL IN TYPE-CODE FIELD OF WD TO BE OUTPUT***)%
	PBOPWD[OTSTYPE]_.EVALU[.EXPR[VALTYPE]];


	%(***FILL IN PTR TO THE VALUE TO BE OUTPUT. THIS PTR IS BUILT DIFFERENTLY
		DEPENDING ON THE OPERATOR-CLASS OF THE EXPRESSION NODE***)%
	SELECT .EXPR[OPRCLS] OF NSET
DATAOPR:  BEGIN
		PBOPWD[OTSADDR]_.EXPR[IDADDR];
		IF .EXPR[OPERSP] EQL FORMLARRAY THEN
		PBOPWD_.PBOPWD OR INDBIT;
		PSYMPTR_.EXPR;
	END;
ARRAYREF:  BEGIN
		OWN PEXPRNODE ARRSYMENTRY;	!SYMBOL TABLE ENTRY FOR THE ARRAY NAME
		PBOPWD[OTSMEMRF]_.EXPR[TARGTMEM];	!INDEX,ADDR AND INDIRECT FIELDS
		ARRSYMENTRY_.EXPR[ARG1PTR];
		PSYMPTR_(IF .ARRSYMENTRY[FORMLFLG]	!IF ARRAY IS A FORMAL THEN
			THEN PBF2NOSYM			! ADDR WILL NOT BE RELOCATED
			ELSE .ARRSYMENTRY);
	END;
OTHERWISE:  BEGIN
		%(***SET INDEX AND INDIRECT BITS OF THE OUTPUT WD FROM THE TARGET OF THE EXPR***)%
		PBOPWD_.PBOPWD+GETTXFI(EXPR);

		%(***IF THE TARGET-MEMREF IS USING AN AC AS A CORE LOCATION THEN
			THERE IS NO SYMBOLIC REPRESENTATION***)%
		IF .EXPR[INREGFLG]
		THEN
		BEGIN
			PBOPWD[OTSADDR]_.EXPR[TARGTAC];
			PSYMPTR_PBF2NOSYM
		END
		ELSE
		%(***IF THE VAL HAS BEEN STORED IN A TEMPORARY***)%
		BEGIN
			PSYMPTR_.EXPR[TARGADDR];
			PBOPWD[OTSADDR]_.PSYMPTR[IDADDR]
		END;
	END;

	TESN;

	OBUFFA();
	PBOPWD_0;
END;


GLOBAL ROUTINE IOIMMED(EXPR)=
%(***************************************************************************
	OUTPUT AN IMMED-MODE FOROTS ARG FOR THE VAL OF "EXPR".
	EXPR MAY BE ANY INTEGER EXPRESSION.
	IF EXPR IS NOT A CONSTANT, THE INDIRECT BIT IN THE ARG WILL BE SET.
***************************************************************************)%
BEGIN
	EXTERNAL PBOPWD,OBUFFA,PSYMPTR;
	MAP PEXPRNODE PSYMPTR;
	MAP OBJECTCODE PBOPWD;
	MAP PEXPRNODE EXPR;

	PBOPWD_0;

	%(***IF THE ARG IS NOT TYPE INTEGER OR IF THE ARG ALREADY MUST BE REFERENCED
		INDIRECT, THEN HAVE AN INTERNAL COMPILER BUG***)%
	IF .EXPR [VALTP1] NEQ INTEG1
	THEN CGERR();

	IF .EXPR[TARGIF] NEQ 0
	THEN CGERR();

	%(***SET TYPE CODE FIELD TO "IMMEDIATE-TYPE"***)%
	PBOPWD[OTSTYPE]_IMMEDTYPE;


	%(***HOW THE PTR IS TO BE BUILT DEPENDS ON THE OPERATOR OF THE EXPRESSION***)%
	SELECT .EXPR[OPRCLS] OF NSET
DATAOPR:  BEGIN
		%(***IF THE EXPRESSION IS AN INTEGER CONSTANT, PUT THE CONSTANT
			DIRECTLY IN THE ARG LIST***)%
		IF .EXPR[OPR1] EQL CONSTFL
		THEN
		BEGIN
			PBOPWD[OTSADDR]_.EXPR[CONST2];
			PSYMPTR_PBF2NOSYM
		END

		%(***IF THE EXPRESSION IS AN INTEGER VARIABLE - USE A PTR TO IT AND
			SET THE INDIRECT BIT***)%
		ELSE
		BEGIN
			PBOPWD[OTSADDR]_.EXPR[IDADDR];
			PBOPWD[OTSIND]_1;
			PSYMPTR_.EXPR
		END;
	END;
ARRAYREF:  BEGIN
		OWN PEXPRNODE ARRSYMENTRY;	!SYMBOL TABLE ENTRY FOR THE ARRAY NAME
		PBOPWD[OTSMEMRF]_.EXPR[TARGTMEM];	!INDEX AND BASE ADDR FOR THE ARRAYREF
		PBOPWD[OTSIND]_1;			!SET INDIRECT BIT (SINCE ARE IMMED)

		ARRSYMENTRY_.EXPR[ARG1PTR];
		PSYMPTR_(IF .ARRSYMENTRY[FORMLFLG]	!IF ARRAY IS A FORMAL THEN
			THEN PBF2NOSYM			! ADDR WILL NOT BE RELOCATED
			ELSE .ARRSYMENTRY);
	END;
OTHERWISE:  BEGIN
		%(***SET INDEX FIELD FROM THE TARGET OF THE EXPR***)%
		PBOPWD_.PBOPWD+GETTXFI(EXPR);

		%(***SET THE INDIRECT BIT***)%
		PBOPWD[OTSIND]_1;

		%(***IF THE TARGET MEMREF IS USING AN AC AS A CORE LOCATION THEN
			THERE IS NO SYMBOLIC REPRESENTATION***)%
		IF .EXPR[INREGFLG]
		THEN
		BEGIN
			PBOPWD[OTSADDR]_.EXPR[TARGTAC];
			PSYMPTR_PBF2NOSYM
		END
		ELSE
		%(***IF THE VAL HAS BEEN STORED IN A TEMP***)%
		BEGIN
			PSYMPTR_.EXPR[TARGADDR];
			PBOPWD[OTSADDR]_.PSYMPTR[IDADDR];
		END;
	END;

	TESN;

	OBUFFA();

	PBOPWD_0;
END;


ROUTINE CGOPARGS=
BEGIN
	!GENERATE AN OPEN TYPE ARGUMENT


	EXTERNAL EVALU;

	EXTERNAL OBUFF,PBOPWD,PSYMPTR,CSTMNT;
	MAP BASE CSTMNT;
	MAP OBJECTCODE PBOPWD;

	LOCAL OPENLIST ARVALLST;	!LIST OF ARGS UNDER THIS OPEN STMNT
	LOCAL PEXPRNODE ARGVAL;		!PTR TO SYMBOL TABLE OR CONSTANT TABLE
					! ENTRY FOR THE VALUE TO BE PASSED TO FOROTS
					! FOR A GIVEN ARG

	ARVALLST_.CSTMNT[OPLST];

	%(***WALK THRU THE LIST OF ARGS GENERATING CODE FOR THEM***)%
	INCR I FROM 0 TO (.CSTMNT[OPSIZ]-1) DO
	BEGIN
		PBOPWD_0;
		PBOPWD[OPENGFIELD]_.ARVALLST[.I,OPENLCODE];

		%(***FOR ALL  ARGS, WILL GET THE ADDRESS OF THE VARIABLE/CONSTANT FROM
			ITS SYMBOL TABLE ENTRY***)%
		ARGVAL_.ARVALLST[.I,OPENLPTR];
		PBOPWD[OTSADDR]_.ARGVAL[IDADDR];
		PBOPWD[OTSTYPE]_.EVALU[.ARGVAL[VALTYPE]];
		PSYMPTR_.ARGVAL;
		OBUFFA();
	END;
END;
MACRO ZIPOUT=
BEGIN
	PSYMPTR_PBF2NOSYM;
	PBOPWD_0;
	OBUFFA();
END$;
FORWARD REDORWRIT;
GLOBAL ROUTINE CGIOARGS=
BEGIN
	%(******************************
		CODE GENERATION FOR ARGUMENT BLOCKS
		FOR I/O STATEMENTS THEMSELVES.
		IT IS ASSUMED THAT CSTMNT
		POINTS TO THE STATEMENT.  THIS IMPLIES
		THAT THERE IS A DRIVER ROUTINE
		THAT IS FOLLOWING THE LINK LIST OF I/O
		STATEMENTS AND CALLING THIS ROUTINE
		AND THEN CGIOLARGS TO GENERATE THE ARGUMENT
		BLOCK FOR THE I/O LIST

	******************************)%
	MACRO IOSRCIDBAS=READID$;

	!TO OUTPUT A WORD FOR ZEROS. THIS WORD DISTINGUISHES
	!BINARY WRITES FROM LIST DIRECTED WRITES (READS TOO)


	LOCAL T;
	EXTERNAL DEFLAB,MTOPFUN,CGERR,TREEPTR;
	EXTERNAL CSTMNT,PBOPWD,PSYMPTR,OBUFF;
	MAP BASE CSTMNT;
	MAP OBJECTCODE PBOPWD;

	!INITIALIZE PBOPWD
	PBOPWD_0;


	!IF THIS STMNT WAS REMOVED FROM THE PROGRAM BY P2SKEL, THEN
	!IOARGLBL FIELD WILL NEVER HAVE BEEN FILLED IN. DO NOT GENERATE
	! AN ARGLIST IN THIS CASE 
	! *****WARNING**** WILL HAVE PROBLEMS IF "IOARGLBL" FIELD IS EVER USED
	! FOR ANYTHING ELSE AND SO IS NON-ZERO 
	IF .CSTMNT[IOARGLBL] EQL 0 THEN RETURN;




	IF .CSTMNT[SRCID] EQL OPENID THEN
	BEGIN
		IO1ARG(.CSTMNT[OPSIZ]+3);
		IOENDERR();
		CGOPARGS();
		RETURN	!DO NOT WANT TO LOOK AT THE IOLIST
	END ELSE
	IF .CSTMNT[SRCID] EQL CLOSID THEN
	BEGIN
		IO1ARG(.CSTMNT[OPSIZ]+3);
		IOENDERR();
		CGOPARGS();
		RETURN		!DO NOT WANT TO LOOK AT THE IOLIST
	END ELSE
	IF .CSTMNT[SRCID] EQL RELSID THEN
		IO1ARG(1)
	ELSE

	!LOOK FOR CALLS TO MTOP.
	IF .CSTMNT[SRCID] GEQ UTILLOW
	AND .CSTMNT[SRCID] LEQ UTILHI THEN
	BEGIN
		IO1ARG(T_(IF .CSTMNT[IOREPT] NEQ 0 THEN 5 ELSE 4));
		IOENDERR();

		%(***OUTPUT A WD THAT CONTAINS A CODE INDICATING THE FUN TO BE PERFORMED***)%
		PBOPWD_0;
		PBOPWD[OTSTYPE]_IMMEDTYPE;
		PBOPWD[OTSADDR]_.MTOPFUN[.CSTMNT[SRCID]-UTILLOW];
		PSYMPTR_PBF2NOSYM;
		OBUFFA();

		%(***OUTPUT THE REPEAT WD IF THERE IS A REPEAT CT***)%
		IF .CSTMNT[IOREPT] NEQ 0 THEN
		BEGIN
			REGISTER BASE T1;
			PBOPWD_0;
			T1_.CSTMNT[IOREPT];
			IF .T1[OPR1] EQL CONSTFL THEN
			BEGIN
				PBOPWD[OTSADDR]_.T1[CONST2];
				PSYMPTR_PBF2NOSYM;
			END ELSE
			BEGIN
				PSYMPTR_.T1;
				PBOPWD[OTSADDR]_.T1[IDADDR];
				PBOPWD[OTSIND]_1;
			END;
			PBOPWD[OTSTYPE]_IMMEDTYPE;
			OBUFFA();
		END;
	END ELSE
	BEGIN
		CASE (.CSTMNT[SRCID]-IOSRCIDBAS) OF SET
!	READID:
		REDORWRIT();
!	WRITID:
		REDORWRIT();
!	DECOID:
		CGDECARGS();
!	ENCOID:
		CGDECARGS();
!	REREDID:
	BEGIN
		IO1ARG(5);
		IOENDERR();
		IOFORMAT();
	END;
!	FINDID:
	BEGIN
		REGISTER BASE T1;
		IO1ARG(6);
		IOENDERR();
		ZIPOUT;
		ZIPOUT;
		IOPTR(.CSTMNT[IORECORD]);
	END;
!	CLOSID:
	BEGIN
		IO1ARG(.CSTMNT[OPSIZ]+3);
		IOENDERR();
		CGOPARGS();
		RETURN		!DO NOT WANT TO LOOK AT THE IOLIST
	END;
!	INPUID:	!NOT IN RELEASE 1
	BEGIN
	END;
!	OUTPID:	!NOT IN RELEASE 1
	BEGIN
	END;

	TES;
	END;
	IF .CSTMNT[IOLIST] NEQ 0 THEN
	BEGIN
		TREEPTR_.CSTMNT[IOLIST];
		CGIOLARGS();
	END;
END;
GLOBAL ROUTINE REDORWRIT=
BEGIN
	!CODE GENERATION FOR A READ OR WRITE STATEMENT
	!INCLUDING ALL SIZES,SHAPES, VARIETIES AND COLORS

	EXTERNAL CSTMNT,PBOPWD,OBUFFA,PSYMPTR,GENLAB;
	MAP BASE CSTMNT;
	MAP OBJECTCODE PBOPWD;
		REGISTER BASE T1;
		T1_(.CSTMNT[IORECORD] NEQ 0);
		IF EXTSIGN(.CSTMNT[IOFORM]) EQL 0 THEN
		BEGIN					!LIST DIRECTED READ
			IO1ARG(IF .T1 THEN 6 ELSE 3);
			IOENDERR();
			IF .T1 THEN ( ZIPOUT; ZIPOUT);
		END ELSE
		IF EXTSIGN(.CSTMNT[IOFORM]) EQL -1 THEN
		BEGIN
			IO1ARG(5+.T1);
			IOENDERR();
			ZIPOUT;
			ZIPOUT;
		END ELSE
		BEGIN
			T1_.CSTMNT[IONAME];
			IF .T1[OPRCLS] EQL DATAOPR AND .T1[IDATTRIBUT(NAMNAM)] THEN
			BEGIN				!NAME LIST READ
				IO1ARG(4);
				IOENDERR();
				!MAKE A LABEL FOR THE NAME LIST ARG BLK
				!AND TUCK IT AWAY IN THE IDCOMMON FIELD
				!OF THE SYMBOL TABLE
				!MAKE IT ONLY IF THERE ISNT ALREADY ONE THERE
				IF .T1[IDCOMMON] EQL 0 THEN
					T1[IDCOMMON]_GENLAB();
				PSYMPTR_PBFLABREF;
				PBOPWD_ 0 OR .T1[IDCOMMON];
				OBUFFA();
			END ELSE
			BEGIN					!FORMATTER READ
				T1_(.CSTMNT[IORECORD] NEQ 0);
				IO1ARG(5+.T1);
				IOENDERR();
				IOFORMAT();
			END;
		END;
		IF .CSTMNT[IORECORD] NEQ 0 THEN
		IOPTR(.CSTMNT[IORECORD]);
END;
GLOBAL ROUTINE NAMGEN=
BEGIN
	!GENERATE NAMELIST BLOCKS FOR FORDTS
	EXTERNAL OBUFFA, PSYMPTR, PBOPWD,NAMLPTR;
	MAP OBJECTCODE PBOPWD;

	OWN	MRNAMPTR,		!MASTER NAME LIST POINTER
		NAMLENTRY,		!POINTER TO EACH NAMELIST ENTRY
		DMETRY;			!POINTER TO DIMENSION TABLE ENTRY

LOCAL BASE PTR;
MAP BASE MRNAMPTR: NAMLENTRY: DMETRY;


MRNAMPTR_.NAMLPTR<LEFT>;
WHILE .MRNAMPTR NEQ 0 DO

	BEGIN

		!SIXBIT NAMELIST NAME

		PSYMPTR _ PBF2NOSYM;
		PTR_.MRNAMPTR[NAMLID];

		%(***IF THIS NAMELIST IS NEVER REFERENCED IN THE PROGRAM, THEN
			NO LABEL WILL HAVE BEEN ASSOCIATED WITH IT. IF SO DO NOT GENERATE
			IT. (NOTE THAT THE "IDCOMMON" FIELD IS USED TO HOLD THE LABEL
			OF A NAMELIST)*******)%
		IF .PTR[IDCOMMON] NEQ 0
		THEN
		BEGIN


			!DEFINE THE ARG BLOCK LABEL THAT
			!WAS STORED IN THE IDCOMMON FIELD OF
			!THE NAMELIST NAME BY REDORWRIT

			DEFLAB(.PTR[IDCOMMON]);

			PBOPWD _ 0 OR .PTR[IDSYMBOL];

			OBUFFA();
			PBOPWD_0;

			!NOW EACH ENTRY IN THE NAMELIST

			INCR I FROM 0 TO .MRNAMPTR[NAMCNT]-1 DO

			BEGIN

				NAMLENTRY _@(.MRNAMPTR[NAMLIST]+.I);

				!OUTPUT 	SIXBIT NAME

				PBOPWD_.NAMLENTRY[IDSYMBOL];

				PSYMPTR_PBF2NOSYM;

				OBUFFA();
				PBOPWD_0;

				IF .NAMLENTRY[OPERSP] EQL ARRAYNAME THEN

				BEGIN		!OUTPUT ARRAYNAME ENTRY

					!------------------------------------------!
					!#DIMS !	T  !I!  X  !   BASE ADR    !
					!------------------------------------------!

					DMETRY _.NAMLENTRY [IDDIM];

					PBOPWD[OTSCNT]_.DMETRY[DIMNUM];
					IOPTR (.NAMLENTRY);

					!------------------------------------------!
					!	SIZE(ITEMS)   ! POS  OFFSET(WDS)   !
					!------------------------------------------!

					%(***GET ARRAY SIZE IN ITEMS (ARASIZ FIELD IS IN WDS)***)%
					PBOPWD[OTSFSIZ]_(IF .NAMLENTRY[DBLFLG]
							THEN .DMETRY[ARASIZ]/2
							ELSE .DMETRY[ARASIZ]);
					PTR_.DMETRY[ARAOFFSET];
					! (NOTE THAT ADJUSTABLY DIMENSIONED ARRAYS
					! ARE ILLEGAL IN NAMELISTS)
						%(***COMPILER ADDS THE OFFSET - FOROTS
							SUBTRACTS IT. THEREFORE MUST PASS
							FOROTS THE NEG OF THE OFFSET USED
							BY THE COMPILER***)%
					IF .PTR[OPR1] EQL CONSTFL THEN
						PBOPWD[OTSADDR]_-.PTR[CONST2]
					ELSE
					CGERR();	!(ADJUSTABLY DIM ARRAY ILLEGAL)

					PSYMPTR_PBF2NOSYM;
					OBUFFA();
					PBOPWD_0;

					!FACTORS

					!------------------------------------------!
					!			 !    FACTOR (IN ITEMS)!
					!------------------------------------------!

					!FACTORS NECESSARY

					INCR K FROM 1 TO .DMETRY[DIMNUM] DO

					BEGIN

						PTR_.DMETRY[DFACTOR ((.K-1))];

						IF .PTR [OPR1] EQL CONSTFL THEN

						BEGIN		!A CONSTANT

							PSYMPTR_PBF2NOSYM;
							%(***GET FACTOR IN ITEMS (NOT WDS)**)%
							PBOPWD_(IF .NAMLENTRY[DBLFLG]
								THEN .PTR[CONST2]/2
								ELSE .PTR[CONST2]);
							OBUFFA();

						END ELSE

						CGERR();
					END;		!FACTOR  OUTPUT

				END ELSE	!ARRAY  OUTPUT

				IOPTR(.NAMLENTRY);

			END;			!INCR LOOP ON ENTRIES IN NAMELIST

			ZIPOUT;			!ZERO TERMINATING WORD
		END;

		MRNAMPTR_.MRNAMPTR[NAMLINK];

	END;			!WHILE LOOP;
END;				!NAMGEN
'X2