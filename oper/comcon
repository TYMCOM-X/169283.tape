C    THIS PROGRAM MAKES A BLOCK DATA SUBROUTINE TO READ ALL
C    COMMAND LISTS INTO LABELED COMMON.
C
      INTEGER LISPOINT(51),ENTPOINT(301),MINTYP(300),ALLCOM(450)
      INTEGER IPAR(50),INLINE(80)
      COMMON /COMPKG/ IP,LISMAX,IPAR,INLINE,LISPOINT,ENTPOINT,MINTYP
      COMMON /COMPKG/ ALLCOM
C
C
      INTEGER COLON,SLASH,ASTRSK,SPACE,ZERO,NINE,NAME(2)
      DATA COLON,SLASH,ASTRSK,SPACE,ZERO,NINE/58,47,42,32,48,57/
      DOUBLE PRECISION FIN,FOUT
C
5     TYPE 10
   10 FORMAT(' COMMAND LIST FILE: ',$)
      ACCEPT 20,FIN
      CALL LOOKUP(FIN,IERR)
      IF(IERR.EQ.1 .OR. IERR.EQ.2) GO TO 5
      IF(IERR.EQ.0) GO TO 25
      TYPE 15
15    FORMAT('+ FILE NOT THERE')
      GO TO 5
   20 FORMAT(A10)
25    TYPE 30
   30 FORMAT(' BLOCK DATA FILE: ',$)
      ACCEPT 20,FOUT
      CALL LOOKUP(FOUT,IERR)
      IF(IERR.EQ.1 .OR. IERR.EQ.2) GO TO 25
      IF(IERR.EQ.0) TYPE 32
32    FORMAT('+ OLD FILE',$)
      IF(IERR.EQ.3) TYPE 33
33    FORMAT('+ NEW FILE',$)
      ACCEPT 20,DUMMY
C
      CALL IFILE(1,FIN)
C
C
      ENTPOINT(1)=1
      LISPOINT(1)=1
      JENT=1
      JLIS=1
      IL=0
C
   40 READ(1,50,END=160) (INLINE(I),I=1,20)
   50 FORMAT(20A5)
      DO 60 J=100,1,-1
      IF(ICHAR(INLINE,J).NE.32) GO TO 70
   60 CONTINUE
      J=0
   70 IPAR(3)=J
      IP=0
      MINC=0
C
   80 IP=IP+1
C    IGNORE BLANK LINES
      IF(IP.GT.IPAR(3) .AND. IP.EQ.1) GO TO 40
      IF(IP.GT.IPAR(3)) GO TO 140
      IC=ICHAR(INLINE,IP)
C    IGNORE LINE IF SLASH IN COLUMN 1
      IF(IC.EQ.SLASH .AND. IP.EQ.1) GO TO 40
C    ANYTHING AFTER SLASH IS IGNORED
      IF(IC.EQ.SLASH) GO TO 140
C    SKIP OVER ASTERISK IF IN COLUMN 1
      IF(IC.EQ.ASTRSK .AND. IP.EQ.1) GO TO 80
C    IF ASTERISK IN COLUMN 2, AND NOTHING MORE ON LINE, LIST TERMINATED
      IF(IC.EQ.ASTRSK.AND.IP.EQ.2.AND.IP+1.GT.IPAR(3)) GO TO 150
C    THIS PLOY ALLOWS A COMMAND TO BEGIN WITH AN ASTERISK
      IF(IC.EQ.ASTRSK .AND. IP.EQ.2) GO TO 80
C    A SPACE TERMINATES A COMMAND
      IF(IC.EQ.SPACE) GO TO 90
C    COLON TERMINATES COMMAND & BEGINS MINIMUM COMMAND LENGTH SPEC
      IF(IC.EQ.COLON) GO TO 120
C
      IL=IL+1
      K=(IL-1)/5
      L=(IL-1)-K*5
      ISH=7*(4-L)+1
      ALLCOM(K+1)=ALLCOM(K+1)+LSH(IC,ISH)
      GO TO 80
C
C    SPACE DETECTED - GOBBLE EM ALL UP
   90 IP=IP+1
      IF(IP.GT.IPAR(3)) GO TO 140
      IC=ICHAR(INLINE,IP)
      IF(IC.EQ.SPACE) GO TO 90
      IF(IC.EQ.COLON) GO TO 120
      IF(IC.EQ.SLASH) GO TO 140
  100 ICC=LSH(IC,29)
      JENTREL=JENT-LISPOINT(JLIS)+1
      TYPE 110,ICC,JLIS,JENTREL
  110 FORMAT(' BAD CHARACTER "',A1,'" IN LIST',I3,' ENTRY',I3)
      STOP
C
C
C    COLON DETECTED - COMMAND TERMINATED
  120 IP=IP+1
      IF(IP.GT.IPAR(3)) GO TO 140
      IC=ICHAR(INLINE,IP)
      IF(IC.LT.ZERO .OR. IC.GT.NINE) GO TO 130
      MINC=MINC*10+(IC-48)
      GO TO 120
C    A CHARACTER AFTER COLON IS NOT NUMERIC
C    CHECK FOR SPACE AND/OR A SLASH
  130 IF(IC.EQ.SPACE .OR. IC.EQ.SLASH) GO TO 140
      GO TO 100
C
C    END OF LINE HIT
  140 MINTYP(JENT)=MINC
      JENT=JENT+1
      ENTPOINT(JENT)=IL+1
      GO TO 40
C
C    COMMAND LIST TERMINATION
  150 JLIS=JLIS+1
      LISPOINT(JLIS)=JENT
      GO TO 40
C
C    END OF FILE REACHED
  160 END FILE 1
C
      LISMAX=JLIS-1
C
      IF(L.EQ.4) GO TO 180
C    PACK OUT LAST WORK OF ALLCOM WITH SPACES TO MAKE
C    BLOCK COMMON EASIER TO WRITE
      DO 170 JFIT=L+1,4
      ISH=7*(4-JFIT)+1
  170 ALLCOM(K+1)=ALLCOM(K+1)+LSH(SPACE,ISH)
C
C
C    COMPUTE THE MINIMUM MATCH FOR EACH UNSPECIFIED ENTRY
C    FIRST, SET ALL SPECIFIED ENTRIES NEGATIVE
  180 KJENT=JENT-1
      DO 190 KREST=1,KJENT
  190 MINTYP(KREST)=-MINTYP(KREST)
C
      DO 240 KLIS=1,LISMAX
C
      NENTRY=LISPOINT(KLIS+1)-LISPOINT(KLIS)
      DO 240 KENT=1,NENTRY
C    COMPUTE THE ABSOLUTE ENTRY NUMBER
      MINT=LISPOINT(KLIS)+KENT-1
C    COMPUTE MAXIMUM NUMBER OF CHARACTERS IN REFERENCE ENTRY
      MX1=ENTPOINT(LISPOINT(KLIS)+KENT)-ENTPOINT(LISPOINT(KLIS)
     1+KENT-1)
C    SKIP OVER COMMANDS WITH MINIMUM MATCH SPECIFIED BY USER
      IF(MINTYP(MINT).LT.0) GO TO 240
C    DEFINE FIRST CHARACTER IN REFERENCE COMMAND
      IT1=LCH(KLIS,KENT,1)
C
C    NOW RUN THRU ALL SUCCEEDING COMMANDS
      KNEX=KENT+1
      IF(KNEX.GT.NENTRY) GO TO 230
      DO 230 KREST=KNEX,NENTRY
      MINMAT=1
C    COMPARE AGAINST ENTRY EVEN IF MINIMUM MATCH SPECIFIED BY USER
      NINT=LISPOINT(KLIS)+KREST-1
      MX2=ENTPOINT(LISPOINT(KLIS)+KREST)-ENTPOINT(LISPOINT(KLIS)
     1+KREST-1)
C    TEST FIRST CHARACTER OF THIS ENTRY AGAINST FIRST CHAR OF REF ENTRY
      IT2=LCH(KLIS,KREST,1)
C    JUMP TO NEXT ENTRY IF NO MATCH
      IF(IT1.NE.IT2) GO TO 230
C    MATCH, LOOK AT NEXT CHARACTER
  200 MINMAT=MINMAT+1
C    IF EITHER ENTRY IS EXCEEDED,(I.E., VER & VERSION) WITHOUT A
C    MISMATCH, AMBIGUITY EXISTS.  SET MATCH POINTER TO FULL
C    LENGTH OF SHORTEST WORD.  HOPEFULLY, THIS WILL BE RARE, OR
C    USER WILL SPECIFY THE MATCH LENGTHS OF THESE COMMANDS HIMSELF.
      IF(MINMAT.GT.MX1 .OR. MINMAT.GT.MX2) GO TO 220
      IT1=LCH(KLIS,KENT,MINMAT)
      IT2=LCH(KLIS,KREST,MINMAT)
      IF(IT1.EQ.IT2) GO TO 200
C    MISMATCH - SAVE THIS POSITION, DISCARDING ANY OLD LESSOR POSITION
  210 MINTYP(MINT)=MAX0(MINTYP(MINT),MINMAT)
C    SET OTHER ENTRY TOO, UNLESS PRESET BY USER
      IF(MINTYP(NINT).GE.0) MINTYP(NINT)=MAX0(MINTYP(NINT),MINMAT)
C    NOW GO ON TO LOOK AT THE REST OF THE COMMAND ENTRIES
      GO TO 230
C
  220 MINMAT=MINMAT-1
      GO TO 210
C
  230 CONTINUE
  240 CONTINUE
C
C    NOW RESET ALL USER SPECIFIED MINIMUM MATCHES POSITIVE
C    ALSO HANDLE NON PROCESSED LISTS WITH A SINGLE ENTRY
      DO 250 KREST=1,KJENT
      IF(MINTYP(KREST).EQ.0) MINTYP(KREST)=1
  250 MINTYP(KREST)=IABS(MINTYP(KREST))
C
      KJENT=JENT-1
      KP1=K+1
      TYPE 260,LISMAX,KJENT,KP1
  260 FORMAT(1X,I3,' LISTS,',I4,' TOTAL ENTRIES, REQUIRING',I4,
     1' WORDS OF LIST STORAGE'/)
C
  270 CONTINUE
      CALL OFILE(1,FOUT)
C
      WRITE(1,280)
  280 FORMAT(6X,'BLOCK DATA')
C
      WRITE(1,290)
  290 FORMAT('C'/6X,'INTEGER LISPOINT(51),ENTPOINT(301),MINTYP(300)',
     1',ALLCOM(450)'/,6X,'INTEGER IPAR(50),INLINE(80)'/
     26X,'COMMON /COMPKG/ IP,LISMAX,IPAR,INLINE,LISPOINT',
     3',ENTPOINT,MINTYP'/
     46X,'COMMON /COMPKG/ ALLCOM'/'C')
C
      WRITE(1,300) LISMAX
  300 FORMAT(6X,'DATA LISMAX/',I3,'/',/,'C')
C
      WRITE(1,302)
302   FORMAT('C    DEFINE TERMINAL UNIT'/'      DATA IPAR(1)/5/')
C
      WRITE(1,303)
303   FORMAT('C    DEFINE ERROR INDICATOR MODE'/
     1'      DATA IPAR(20)/2/')
C
      WRITE(1,304)
304   FORMAT('C    DEFINE CONTINUATION CHAR(&)'/
     1'      DATA IPAR(23)/38/')
C
      WRITE(1,306)
306   FORMAT('C    DEFINE COMMENT CHARACTER(!)'/
     1'      DATA IPAR(24)/33/')
C
      WRITE(1,308)
308   FORMAT('C    DEFINE TERMINATION CHARACTER(S)'/
     1'      DATA IPAR(26)/3/')
C
C    WRITE OUT THE ARRAY OF COMMAND ENTRIES
      NAME(1)='ALLCO'
      NAME(2)='M'
      CALL ABLOCK(1,NAME,ALLCOM,KP1)
C
C    WRITE OUT THE ENTRY POINTER ARRAY
      NAME(1)='ENTPO'
      NAME(2)='INT'
      CALL IBLOCK(1,NAME,ENTPOINT,JENT)
C
C    WRITE OUT THE ARRAY OF MINIMUM MATCHES
      NAME(1)='MINTYP'
      NAME(2)='P'
      CALL IBLOCK(1,NAME,MINTYP,KJENT)
C
C
  310 LSMAX1=LISMAX+1
C
C    WRITE OUT THE LIST POINTER ARRAY
      NAME(1)='LISPO'
      NAME(2)='INT'
      CALL IBLOCK(1,NAME,LISPOINT,LSMAX1)
C
  320 WRITE(1,330)
  330 FORMAT('C',/,6X,'END')
C
      ENDFILE 1
      CALL NEXIT
C
      END
C
C
      SUBROUTINE IBLOCK(IUNIT,NAME,IARRAY,LENGTH)
C
      INTEGER KFORM(8),IARRAY(1),NAME(1)
C
      DATA (KFORM(I),I=1,7)/4H(5X,, 4H'+',, 1H , 4H,I4,, 1H ,
     15H(',',, 3HI4)/,ISPACE/' '/
C
C    INITIAL SETTING FOR FIRST SECTION OF ARRAY PRINTOUT
      KLO=1
      KHI=MIN0(100,LENGTH)
C    DEFINE FIRST COMMA/SPACE LOCATION AND END OF FORMAT TERMINATOR
   10 KFORM(3)='1X'
      KFORM(8)=')'
C    WRITE OUT THE ARRAY NAME
   20 WRITE(IUNIT,30) NAME(1),NAME(2),KLO,KHI
   30 FORMAT(6X,'DATA (',2A5,'(I),I=',I3,',',I3,')/')
C    SET INNER LOOP LOW AND HIGH ARRAY LIMITS
      MLO=KLO
      MHI=MLO-1+MIN0(10,KHI-KLO+1)
C    ADD FINAL SLASH TO FORMAT IF 10 OR LESS VALUES TO PRINT IN
C    THIS SECTION OF 100 MAX
   40 IF((KHI-MLO+1).LE.10) KFORM(8)=4H'/')
C    COMPUTE FORMAT GROUP REPETITION NUMBER, IF NEED THAT PART OF FORMAT
      IF(MHI-MLO.EQ.0) GO TO 50
C    WHEN GETTING THE EQUIVALENT DIGIT, SPACES WILL BE IN WORD
      MDIF=(MHI-MLO)+16
      KFORM(5)=ISPACE+LSH(MDIF,1)
      GO TO 60
   50 KFORM(5)=4H'/')
C    WRITE OUT A LINE OF DATA
   60 WRITE(IUNIT,KFORM) (IARRAY(J),J=MLO,MHI)
C    FINISHED WITH THIS SECTION OF 100 MAX?
      IF(MHI.EQ.KHI) GO TO 70
      MLO=MLO+10
      MHI=MHI+MIN0(10,KHI-MHI)
C    PUT THE LEADING COMMA INTO ALL LINES PAST SECOND CONT. LINE
      KFORM(3)='1H,'
      GO TO 40
C    DONE IF WE HAVE REACHED THE LIMIT
   70 IF(LENGTH.EQ.MHI) GO TO 90
C    INCREMENT & GO BACK TO DO ANOTHER 100 (MAXIMUM)
   80 KLO=KLO+100
      KHI=KHI+MIN0(100,LENGTH-KHI)
      GO TO 10
C
   90 RETURN
      END
C
C
      SUBROUTINE ABLOCK(IUNIT,NAME,IARRAY,LENGTH)
C
      INTEGER KFORM(9),IARRAY(1),NAME(1)
C
      DATA (KFORM(I),I=1,8)/4H(5X,, 4H'+',, 1H , 5H'5H',, 3HA5,,
     11H , 5H(',5H, 5H',A5)/, ISPACE/' '/
C
C    INITIAL SETTING FOR FIRST SECTION OF ARRAY PRINTOUT
      KLO=1
      KHI=MIN0(80,LENGTH)
C    DEFINE FIRST COMMA/SPACE LOCATION AND END OF FORMAT TERMINATOR
   10 KFORM(3)='1X,'
      KFORM(9)=')'
C    WRITE OUT THE ARRAY NAME
   20 WRITE(IUNIT,30) NAME(1),NAME(2),KLO,KHI
   30 FORMAT(6X,'DATA (',2A5,'(I),I=',I3,',',I3,')/')
C    SET INNER LOOP LOW AND HIGH ARRAY LIMITS
      MLO=KLO
      MHI=MLO-1+MIN0(8,KHI-KLO+1)
C    ADD FINAL SLASH TO FORMAT IF 8 OR LESS VALUES TO PRINT IN
C    THIS SECTION OF 80 MAX
   40 IF((KHI-MLO+1).LE.8) KFORM(9)=4H'/')
C    COMPUTE FORMAT GROUP REPETITION NUMBER, IF NEED THAT PART OF FORMAT
      IF(MHI-MLO.EQ.0) GO TO 50
C    WHEN GETTING THE EQUIVALENT DIGIT, SPACES WILL BE IN WORD
      MDIF=(MHI-MLO)+16
      KFORM(6)=ISPACE+LSH(MDIF,1)
      GO TO 60
   50 KFORM(6)=4H'/')
C    WRITE OUT A LINE OF DATA
   60 WRITE(IUNIT,KFORM) (IARRAY(J),J=MLO,MHI)
C    FINISHED WITH THIS SECTION OF 80 MAX?
      IF(MHI.EQ.KHI) GO TO 70
      MLO=MLO+8
      MHI=MHI+MIN0(8,KHI-MHI)
C    PUT THE LEADING COMMA INTO ALL LINES PAST SECOND CONT. LINE
      KFORM(3)='1H,'
      GO TO 40
C    DONE IF WE HAVE REACHED THE LIMIT
   70 IF(LENGTH.EQ.MHI) GO TO 90
C    INCREMENT & GO BACK TO DO ANOTHER 80 (MAXIMUM)
   80 KLO=KLO+80
      KHI=KHI+MIN0(80,LENGTH-KHI)
      GO TO 10
C
   90 RETURN
      END
    