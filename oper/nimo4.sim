!13 MAR 73     NIMO4.SIM    *CW
!MODEM OUTPUT ROUTINES
DEF A.L.B AS 0    !****
FIND OUT.H.Q
FIND OUT.Q
FIND MAST.Q
FIND SLAVE.Q
FIND MODEM.Q
FIND MAX.LINE
FIND P.LINES
FIND P.Q.AREA
FIND STORE(0)

FIND %E.SP.AR
FIND %R.P.CDR
FIND %L.P.CDR
FIND %R.BUF.N.C
FIND %L.BUF.N.C
FIND %R.C.B.F.SW.P
FIND %L.C.B.F.SW.P
FIND %R.C.B.HEAD
FIND %L.C.B.HEAD
FIND %R.C.B.ADDR
FIND %R.C.B.F.TEXT.P
FIND %R.C.B.TEXT
FIND %L.C.B.TEXT
FIND %R.C.B.SEND
FIND %R.C.B.SEQ.NO
FIND %R.C.B.INCOMP.P
FIND %LN.O.BUF
FIND %S.LN.O.BUF
FIND %S.LN.IN.BUF
FIND %LN.O.B.CNT
FIND %S.LN.O.B.CNT
FIND %LN.O.CHS
FIND %S.LN.O.CHS
FIND %LN.O.VECTOR
FIND %S.LN.O.VECTOR
FIND %S.LN.IN.VECTOR
FIND %LN.L.O.TIME
FIND %S.LN.L.O.TIME
FIND %LN.INC.CH
FIND %S.LN.INC.CH
FIND %LN.O.PORT
FIND %LN.CHOKE
FIND %LN.O.R.C.B
FIND %S.LN.O.R.C.B
FIND %LN.CK.PT.TIME
FIND %S.LN.CK.PT.TIME
FIND %FUSBUDGET
FIND %APP.CH       !***
FIND %OUT.X.BUF    !***
FIND %FM.FR.INT    !***
FIND N.AREA        !***
FIND %G.BUFFERLET  !***
FIND %TIME
FIND %COMP.SEQ.NUM
FIND %P.INSERT.LIST
FIND %R.R.C.B
FIND %S.SP.AR
FIND %P.APPEND.LIST
FIND %GET.BUF.CHAR
FIND %R.P.L.DATA
FIND %L.P.L.DATA
FIND %P.R.LIST
FIND %R.ELMT
FIND %LN.NUM

GLOBAL.PROC(SV.OUT,H.SV.OUT)
GLOBAL.PROC(POST.OUT,H.POST.OUT)
LOCAL %POST.O.LINE,  %LINE.NUM
GLOBAL.PROC(SV.OWN,H.SV.OWN)
FIND %OUT.BUF
FIND %OUT.MAP
FIND %FM.R.C.B
FIND %SET.UP.LINES
!
PROC(SV.OWN,H.SV.OWN,'SV.OWN',)
LOCAL TEMP
FUSBUDGET                       !****
WHILE TEMP _ R.P.CDR(MODEM.Q) # 0 &
 THEN &
  DO
  MSG('MODEM RECORD RECEIVED:$')
  OUT.R.C.B(TEL,TEMP)
  L.P.CDR(MODEM.Q,R.P.CDR(TEMP))
  R.R.C.B(TEMP)
  END
RETURN
END.PROC(SV.OWN,H.SV.OWN)
!
PROC(SV.OUT,H.SV.OUT,'SV.OUT',)
!########
LOCAL CUR.LINE,  CUR.L.C.B,  CUR.C.B, CUR.O.BUF,  CUR.CH.POS
LOCAL CUR.CHAR,  CUR.VECTOR(),  CUR.L.O.TIME
LOCAL CUR.O.CHS, CUR.PORT,   CUR.CH.CL,  CUR.CHOKE,  CUR.INC.CH
LOCAL CUR.CK.PT.TIME
LOCAL %C.OUT.CL,  %PULL.OUT.GLOBALS,  %PUSH.OUT.GLOBALS
LOCAL %OUT.CALL,  %CHOKE.P,  %GET.CH,  %PRIME.OUT
LOCAL LAST.LINE     !******

FUSBUDGET               !***
CUR.LINE _ 0
WHILE INC CUR.LINE <= MAX.LINE &
 THEN &
  DO
  IF CUR.L.C.B _ R.P.L.DATA(P.LINES,CUR.LINE) < 0 &
   THEN NULL &
   ELSE &
    DO
    IF CUR.C.B _ LN.O.R.C.B(CUR.LINE) = E.O.L &
     THEN NULL &
     ELSE &
      DO
      PULL.OUT.GLOBALS
      IF NOT CHOKE.P &
       THEN &
        DO
        IF CUR.LINE # LAST.LINE !****! &
         THEN !****! &
          DO    !******
          LOCAL LAST.LN.MSG !***
          LOCAL LN.MSG.SW   !***
          LN.MSG.SW _ TRUE   !*****
          END
        GET.CH
        OUT.CALL
        PUSH.OUT.GLOBALS
        END
      END
    END
  END

LAST.LN.MSG _ 0

FUSBUDGET               !***
RETURN
               !BLOCK ENDS AFTER ASSOCIATED ROUTINES
!
%CHOKE.P        !CHOKE PREDICATE
!#######
!VALUE TRUE IF CHOKE IS IN EFFECT
!ELSE VALUE FALSE
LOCAL T
IF CUR.CHOKE # 0 &
 THEN &
  DO
  IF CUR.INC.CH >= CUR.CHOKE &
   THEN &
    DO
    IF (T _ TIME) - CUR.CK.PT.TIME < 60 THEN RETURN(TRUE)
    CUR.INC.CH _ 0      !RELEASE THE CHOKE
    S.LN.CK.PT.TIME(CUR.LINE,CUR.CK.PT.TIME _ T)
    END
  END
RETURN(FALSE)
END CHOKE.P


%C.OUT.CL
!########


!CHARACTER CLASSES

!CLASS WRITTEN CHARS
!----- ------- --------------------------
! 0     A       NONE
! 1     B       XBEL,XESC,XSOH,XSTX,XETX,XON,XOFF
! 2     C       ALL OTHERS

LOCAL STRING

TABLE STRING.TBL1 (0:0)['&
CCCCCCCBCCCCCCCCCBCCCCCCCCCCCCCC&
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC']

TABLE STRING.TBL2 (0:0)['&
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC&
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC']

TABLE STRING.TBL3 (0:0)['&
CBBBCCCCCCCCCCCCCCCBCCCCCCCCCCCC&
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC']

TABLE STRING.TBL4 (0:0)['&
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC&
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCB']

IF CUR.CHAR < OCT 200 &
 THEN &
  DO
  IF CUR.CHAR < OCT 100 &
   THEN STRING _ STRING.TBL1(0) &
   ELSE STRING _ STRING.TBL2(0)
  END &
 ELSE &
  DO
  IF CUR.CHAR < OCT 300 &
   THEN STRING _ STRING.TBL3(0) &
   ELSE STRING _ STRING.TBL4(0)
  END
RETURN(CH(STRING,CUR.CHAR BAND OCT 77) - $A)
END C.OUT.CL


%OUT.CALL
!########

!TABLE FIRST(0:2)[P.XSOH.SH1,P.XSOH.SH1,P.XSOH.SH1]
TABLE FIRST(0:0)['JJJ']

!TABLE HEAD.1 (0:2) [P.XSTX.ST1,P.XESC.SH2,P.STEP.H]
TABLE HEAD.1 (0:0) ['KHE']

!TABLE HEAD.2 (0:2) [ERR,X.P.S.SH1,ERR]
TABLE HEAD.2 (0:0) ['BTB']

!TABLE TEXT.1 (0:2) [P.XETX.T.N.D.R,P.XESC.ST2,P.STEP.T]
TABLE TEXT.1 (0:0) ['GIF']

!TABLE TEXT.2 (0:2) [ERR,X.P.S.ST1,ERR]
TABLE TEXT.2 (0:0) ['BUB']

!TABLE FREE (0:2) [T.FREE,P.STEP.F,P.STEP.F]
TABLE FREE (0:0) ['QDD']

LOCAL P,  ROUTINE.NUM
LOCAL %ERR, %P.CHAR, %P.STEP.F,  %P.STEP.H,  %P.STEP.T,  %P.X,  %P.XETX
LOCAL %P.XESC,  %P.XETX.T.NDR,  %P.XESC.SH2,  %P.XESC.ST2
LOCAL %P.XSOH.SH1,  %P.XSTX.ST1,  %SF,  %SH1,  %SH2,  %ST1
LOCAL %ST2,  %STEP.F,  %STEP.H,  %STEP.T,  %T.FREE,  %T.NDR,  %X.P
LOCAL %X.P.S.SH1,  %X.P.S.ST1

P _ TRUE
WHILE P AND NOT CHOKE.P &
 THEN &
  DO
  ROUTINE.NUM _ CH(CUR.VECTOR(0),CUR.CH.CL) - $A
  IF NOT(0<ROUTINE.NUM<21)THEN [MSG('$WILD ROUTINE');HALT]  !***
  DO ROUTINE.NUM OF 1:20
  1:  P _ ERR
  2:  P _ P.CHAR
  3:  P _ P.STEP.F
  4:  P _ P.STEP.H
  5:  P _ P.STEP.T
  6:  P _ P.XETX.T.NDR
  7:  P _ P.XESC.SH2
  8:  P _ P.XESC.ST2
  9:  P _ P.XSOH.SH1
  10:  P _ P.XSTX.ST1
  11:  P _ SF
  12:  P _ SH1
  13:  P _ SH2
  14:  P _ ST1
  15:  P _ ST2
  16:  P _ T.FREE
  17:  P _ T.NDR
  18:  P _ X.P
  19:  P _ X.P.S.SH1
  20:  P _ X.P.S.ST1
  END
  END
RETURN


%ERR
MSG('$ERR')
!###
HALT
END ERR


%POST.O.LINE(LINE,C.B)          !POST TO OUTPUT LINE
!LINE MAY BE CURRENT OUT.LINE, REQUIRING ALL SEMI-GLOBALS
!TO BE POSTED, OR WE MAY NOT BE DOING ANY OUTPUT, REQUIRING
!LINE COMTROL BLOCK TO BE INITIALIZED.  DO BOTH.
S.LN.O.R.C.B(LINE,CUR.C.B _ C.B)
IF R.C.B.F.TEXT.P(C.B) &
 THEN &
  DO    !FREE TEXT CASE
  CUR.VECTOR _ FREE
  CUR.O.BUF _ R.C.B.TEXT(C.B)
  END &
 ELSE &
  DO    !NET DATA RECORD CASE
  CUR.VECTOR _ FIRST
  CUR.O.BUF _ R.C.B.HEAD(C.B)
  END
S.LN.O.VECTOR(LINE,CUR.VECTOR)
S.LN.O.BUF(LINE,CUR.O.BUF)
S.LN.O.B.CNT(LINE,CUR.CH.POS _ 1)
RETURN(GET.CH)
END POST.O.LINE


%P.CHAR        !POST A CHARACTER TO OUTPUT LINE
!######
INC CUR.INC.CH
INC CUR.O.CHS
CUR.L.O.TIME _ TIME
LOCAL BUF                 !****
IF LN.MSG.SW AND LAST.LN.MSG # CUR.LINE !***! &
 THEN  !***! &
  DO   !***
  MSG('$OUT-LINE ')   !***
  BUF _ G.BUFFERLET   !***
  OUT.BUF(0,FM.FR.INT(BUF,CUR.LINE))   !***
  R.ELMT(BUF)   !***
  MSG(': ')     !***
  LAST.LN.MSG _ CUR.LINE  !***
  END    !***
LN.MSG.SW _ FALSE    !***
BUF _ G.BUFFERLET    !***
OUT.X.BUF(0,APP.CH(BUF,CUR.CHAR))   !***
R.ELMT(BUF)    !***
W(CUR.PORT,CUR.CHAR)
RETURN
END P.CHAR


%P.STEP.F
!########
P.CHAR
RETURN(STEP.F)
END P.STEP.F


%P.STEP.H
!########
P.CHAR
RETURN(STEP.H)
END P.STEP.H


%P.STEP.T
!########
P.CHAR
RETURN(STEP.T)
END P.STEP.T


%P.X(CHAR)      !PUT AN X CHAR TO OUT LINE
!###
CUR.CHAR _ CHAR
RETURN(P.CHAR)
END P.X


%P.XESC
!######
RETURN(P.X(XESC))
END P.XESC


%P.XETX
!######
RETURN(P.X(XETX))
END P.XETX


%P.XETX.T.NDR
!############
IF R.C.B.F.SW.P(CUR.C.B) AND R.C.B.INCOMP.P(CUR.C.B) &
 THEN RETURN(FALSE)
P.XETX
RETURN(T.NDR)
END P.XETX.T.NDR


%P.XESC.SH2
!##########
P.XESC
RETURN(SH2)
END P.XESC.SH2


%P.XESC.ST2
!##########
P.XESC
RETURN(ST2)
END P.XESC.ST2


%P.XSOH.SH1
!##########
P.X(XSOH)
SH1
RETURN(GET.CH)
END P.XSOH.SH1


%P.XSTX.ST1
!##########
P.X(XSTX)
IF NOT(R.C.B.SEQ.NO(CUR.C.B)BAND OCT 200) &
 THEN &
  DO       !NOT SEQUENCED NUMBERED, THUS NO GURANTEE OF DELIVERY RQD
  P.R.LIST(CUR.O.BUF)   !SCAVENGE HEAD BUFFERLETS
  L.C.B.HEAD(CUR.C.B,0)
  END
                        !PRIME FOR OUTPUTTING OF TEXT
S.LN.O.BUF(CUR.LINE,CUR.O.BUF _ R.C.B.TEXT(CUR.C.B))
CUR.CH.POS _ 1
ST1
RETURN(GET.CH)
END P.XSTX.ST1


%SF
!##
CUR.VECTOR _ FIRST
RETURN
END SF


%SH1
!###
CUR.VECTOR _ HEAD.1
RETURN
END SH1


%SH2
!###
CUR.VECTOR _ HEAD.2
RETURN(GET.CH)
END SH2


%ST1
!###
CUR.VECTOR _ TEXT.1
RETURN
END ST1


%ST2
!###
CUR.VECTOR _ TEXT2
RETURN(GET.CH)
END ST2


%STEP.F         !STEP FREE TEXT
!######
LOCAL NEW.BUF
IF INC CUR.CH.POS > R.BUF.N.C(CUR.O.BUF) &
 THEN &
  DO            !WE ARE AT THE END OF A FREE TEXT BUFFERLET
  NEW.BUF _ R.P.CDR(CUR.O.BUF)
  R.ELMT(CUR.O.BUF)
  S.LN.O.BUF(CUR.LINE,CUR.O.BUF _ NEW.BUF)
  CUR.CH.POS _ 1
  END
RETURN(GET.CH)
END STEP.F


%STEP.H         !STEP HEAD
!######
IF INC CUR.CH.POS > R.BUF.N.C(CUR.O.BUF) &
 THEN &
  DO            !WE ARE AT THE END OF A HEAD BUFFERLET
                !SET NEW BUFFERLET AND COUNT
  CUR.CH.POS _ 1
  S.LN.O.BUF(CUR.LINE,CUR.O.BUF _ R.P.CDR(CUR.O.BUF))
                !WE SCAVENGE THESE BUFFERLETS LATER
  END
RETURN(GET.CH)
END STEP.H


%STEP.T         !STEP TEXT
!######
LOCAL NEW.BUF
IF INC CUR.CH.POS > R.BUF.N.C(CUR.O.BUF) &
 THEN &
  DO
  !WE ARE AT THE END OF A TEXT BUFFERLET
  CUR.CH.POS _ 1
  IF NOT(NEW.BUF _ R.P.CDR(CUR.O.BUF)=E.O.L &
         AND R.C.B.INCOMP.P(CUR.C.B) &
         AND R.C.B.SEQ.NO(CUR.C.B)BAND OCT 200) &
   THEN &
    DO            !STEP AND SCAVENGE BUFFERLET
    R.ELMT(CUR.O.BUF)
    S.LN.O.BUF(CUR.LINE,CUR.O.BUF _ NEW.BUF)
    L.C.B.TEXT(CUR.C.B,CUR.O.BUF)
    END &
   ELSE &
    DO            !WE ARE AT THE END OF AN INCOMPLETE, FORWARD SW MSG
                  !RE-USE THIS BUFFERLET FOR THE INPUT
    S.LN.IN.BUF(CUR.LINE,CUR.O.BUF)
    L.BUF.N.C(CUR.O.BUF,0)
    END
  END
RETURN(GET.CH)
END STEP.T


%T.FREE
!######
!SCAVENGE THE OUTPUT RCB, ETC.
R.R.C.B(CUR.C.B)
!REMOVE RCB FROM OUT LINE
CUR.C.B _ 0
!PRIME THE OUTPUT ON THIS LINE IF POSSIBLE
RETURN(PRIME.OUT(CUR.LINE))
END T.FREE


%T.NDR
!#####
LOCAL %HOLD.FOR.ACK, O.Q, OLD.O.Q
!IF FORWARD SWITCHING, OR IF NO SEQUENCE NUMBER &
 THEN DISCARD &
 ELSE HOLD FOR ACKNOWLEDGEMENT
IF R.C.B.F.SW.P(CUR.C.B) OR NOT(R.C.B.SEQ.NO(CUR.C.B)BAND OCT 200)&
 THEN R.R.C.B(CUR.C.B) &
 ELSE HOLD.FOR.ACK
!REMOVE FROM OUT LINE
S.LN.O.R.C.B(CUR.LINE,CUR.C.B _ E.O.L)
!PRIME THE OUTPUT ON THIS LINE IF POSSIBLE
RETURN(PRIME.OUT(CUR.LINE))


%HOLD.FOR.ACK
!############
!HOLD FOR ACKNOWLEDGEMENT
LOCAL C.B
IF C.B _ E.SP.AR(3,OUT.H.Q,CUR.C.B,R.C.B.ADDR(CUR.C.B), &
 R.C.B.SEND(CUR.C.B),R.C.B.SEQ.NO(CUR.C.B)) # 0 THEN R.R.C.B(C.B)
RETURN
END HOLD.FOR.ACK
END T.NDR


%X.P
!###
TABLE XFORM1(0:6)[&
 XESC &
,XOFF &
,XON  &
,XBEL &
,XSOH &
,XSTX &
,XETX ]
LOCAL I
I _ 0
WHILE I < 7 AND CUR.CHAR # XFORM1(I) THEN INC I
IF I >= 7 THEN HALT
CUR.CHAR _ I BXOR OCT 377
RETURN
END X.P


%X.P.S.SH1
!#########
X.P
SH1
RETURN(P.STEP.H)
END X.P.S.SH1


%X.P.S.ST1
!#########
X.P
ST1
RETURN(P.STEP.T)
END X.P.S.ST1
END OUT.CALL


%GET.CH
FUSBUDGET               !***
!######
IF CUR.O.BUF = E.O.L OR CUR.CH.POS > R.BUF.N.C(CUR.O.BUF) &
 THEN &
  DO            !NO MORE CHARACTERS IN THIS BUFFERLET
  CUR.CHAR _ 0
  CUR.CH.CL _ 0
  FUSBUDGET             !***
  RETURN(FALSE)
  END
CUR.CHAR _ GET.BUF.CHAR(CUR.O.BUF,CUR.CH.POS)
CUR.CH.CL _ C.OUT.CL
FUSBUDGET               !***
RETURN(TRUE)
END GET.CH


%PULL.OUT.GLOBALS
!################
CUR.O.BUF _ LN.O.BUF(CUR.LINE)
CUR.CH.POS  _ LN.O.B.CNT(CUR.LINE)
CUR.O.CHS   _ LN.O.CHS(CUR.LINE)
CUR.VECTOR  _ LN.O.VECTOR(CUR.LINE)
CUR.L.O.TIME _ LN.L.O.TIME(CUR.LINE)
CUR.INC.CH _ LN.INC.CH(CUR.LINE)
CUR.PORT    _ LN.O.PORT(CUR.LINE)
CUR.CHOKE   _ LN.CHOKE(CUR.LINE)
CUR.INC.CH  _ LN.INC.CH(CUR.LINE)
CUR.CK.PT.TIME _ LN.CK.PT.TIME(CUR.LINE)
RETURN
END PULL.OUT.GLOBALS


%PUSH.OUT.GLOBALS
FUSBUDGET               !***
!################
S.LN.O.B.CNT(CUR.LINE,CUR.CH.POS)
S.LN.O.CHS(CUR.LINE,CUR.O.CHS)
S.LN.O.VECTOR(CUR.LINE,CUR.VECTOR)
S.LN.L.O.TIME(CUR.LINE,CUR.L.O.TIME)
S.LN.O.CHS(CUR.LINE,CUR.O.CHS)
S.LN.INC.CH(CUR.LINE,CUR.INC.CH)
FUSBUDGET               !***
RETURN
END PUSH.OUT.GLOBALS


%PRIME.OUT(LINE)        !PRIME THE OUTPUT ON A LINE
!#########
LOCAL OLD.O.Q,  C.B
OLD.O.Q _ C.B _ OUT.Q
WHILE C.B _ R.P.CDR(C.B) # E.O.L &
 THEN &
  DO            !TRY THIS ONE
  IF LINE.NUM(R.C.B.ADDR(C.B)) = LINE &
   THEN &
    DO          !CAN PUT THIS ONE OUT
                !REMOVE IT FROM THE OUT.Q
    L.P.CDR(OLD.O.Q,R.P.CDR(C.B))
                !POST TO LINE; RETURN
    RETURN(POST.O.LINE(LINE,C.B))
    END
  OLD.O.Q _ C.B         !PREPARE TO TRY NEXT RKD ON OUT.Q
  END           !LOOP
                !NOTHING TO PRIME THE OUTPUT WITH
RETURN(FALSE)
END PRIME.OUT


%LINE.NUM(ADDR)         !GET LINE NUMBER ASSOCIATED W/ ADDR
!########
LOCAL VAL
ADDR _ ADDR BAND OCT 177        !ELIDE MODEM INDICATOR
IF ADDR = 0 THEN RETURN(1)    !MASTER
IF VAL _ LN.NUM(ADDR) = 0 THEN RETURN(1)   !DESTINATION UNKNOWN
                                !SHIP TOWARD MASTER
RETURN(VAL)
END LINE.NUM
END.PROC(SV.OUT,H.SV.OUT)


PROC(POST.OUT,H.POST.OUT,'POST.OUT',(C.B))  !POST TO OUTPUT QUEUE
!########
!WILL POST DIRECTLY TO LINE IF IT IS NOT BUSY, ELSE TO OUT.Q
LOCAL LINE
LINE _ LINE.NUM(R.C.B.ADDR(C.B))
IF LN.O.R.C.B(LINE) = E.O.L &
 THEN &
  DO    !LINE NOT BUSY, POST DIRECTLY TO LINE
  POST.O.LINE(LINE,C.B)
  END &
 ELSE &
  DO
                !LINE HAS OUTPUT UNDERWAY, STICK ON OUT.Q
  P.APPEND.LIST(OUT.Q,C.B)
  END
RETURN
END.PROC(POST.OUT,H.POST.OUT)
