!
!SRCHB IS COMPILED WITH THE FILES(IN ORDER) SCHBHD,FIRST,TABLES,SRCHB,END
!AUTHOR: F. INFANTE
!COPYRIGHT 1973, DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
!
GLOBAL BIND SRVBV = 35;	!VERSION DATE: 31-MAY-73




GLOBAL ROUTINE LITERL=
! - LITERAL TABLE LOOKUP AND ENTRY OF VARIABLE NUMBER OF ASCII
!		CHARACTERS
!	THIS ROUTINE HAS TWO BRANCHES BASED ON THE VALUE OF ENTRY IN THE
!	CALL TBLSEARCH(LITTBL,ENTRY)
!	IF .ENTRY IS NON-ZERO IT MAKES .ENTRY CALLS TO CHAR()
!	IF .ENTRY = 0, IT COPIES UNTIL IT HITS A QUOTE NOT FOLLOWED
!	BY A QUOTE (') AND THEN QUEUE()'S THE EXTRA CHARACTER
!
BEGIN
	EXTERNAL NEWENTRY,ENTRY,CHAR,QUEUE,ERROUT,POOL;
	LOCAL POINT,WDS,CT;
	LOCAL PEXPRNODE LITENTRY;
	BIND	NULL=0,
		BLANK=#40,
		NULLWD=0,
		EOL=#777777;
!
	MACRO ERR72=(ENTRY[0]_ .ISN; ERROUT(72))$;

	%(****IF .ENTRY IS 0, THEN DO NOT KNOW SIZE OF LITERAL. HENCE MUST
		READ CHARS INTO THE POOL AREA UNTIL REACH A QUOTE (NOT FOLLOWED
		BY ANOTHER QUOTE), THEN GET TABLE SPACE TO STORE THE LIERAL IN
		AND THEN COPY THE LITERAL INTO THE TABLE***)%
	IF .ENTRY EQL 0
	THEN
	BEGIN
		POINT_(POOL-1)<0,7>;		!GET BYTE PTR TO BYTE THAT PRECEEDS
						! THE 1ST WD OF POOL
		CT_0;

		UNTIL CHAR() EQL EOL
		DO
		BEGIN
			IF .C NEQ "'"
			THEN
			(
			REPLACEI(POINT,.C);	!INCR BYTE PTR AND STORE CHAR
			 CT _ .CT + 1;
			)
						! INTO NEXT BYTE OF POOL

			%(***IF THE NEXT CHAR WAS A QUOTE, CHECK FOR THE CHAR FOLLOWING ALSO
				EQL TO QUOTE***)%
			ELSE
			IF CHAR() EQL "'"
			THEN
			%(***IF HAD 2 QUOTES IN A ROW, IGNORE THE 1ST,
				STORE THE 2ND***)%
			(
			REPLACEI(POINT,.C);
			CT _ .CT + 1;
			)

			ELSE

			%(***IF HAVE REACHED THE FINAL QUOTE******)%

			BEGIN
				QUEUE();	!SAVE THE EXTRA CHAR
						! THAT WAS LOOKED AT

				%(***PAD WITH BLANKS TO THE WD BOUNDARY**)%
				IF (.CT MOD 5) NEQ 0 THEN
				DECR K1 FROM (4-(.CT MOD 5)) TO 0
				DO REPLACEI(POINT,BLANK);

				%(***MAKE  THE  LITERAL TABLE ENTRY. ***)%
				WDS_((.CT-1)/5+2);		!NUMBER OF WDS IN THE LITERAL
								! (WILL ALWAYS HAVE AN EXTRA WD
								! OF NULLS ON THE END)
				NAME<LEFT>_ (IF .WDS LEQ 2 THEN 5 ELSE 3+.WDS);
				NAME<RIGHT>_LITTAB;
				LITENTRY_NEWENTRY();
				LITENTRY[LITSIZ]_.WDS;

				%(***COPY THE LITERAL INTO THE TABLE ENTRY***)%
				IF .WDS GTR 1
				THEN
				BEGIN
					%(***COPY THE LITERAL, TURNING OFF BIT 35 OF EACH WD
						(BECAUSE IT WAS WRITTEN IN POOL SPACE, BIT 35
						CAN CONTAIN GARBAGE)***)%
					INCR CT FROM 1 TO (.WDS-1)
					DO
					(LITENTRY[LITWD(.CT)]_.POOL[.CT-1] AND #777777777776);
				END
				ELSE
				%(**IF LITERAL IS ONLY 1 WD, HAVE A 2ND WD OF NULLS IN TABLE**)%
				BEGIN
					LITENTRY[LIT1]_.POOL[0] AND #777777777776;
					LITENTRY[LIT2]_NULLWD;
				END;

				LITENTRY[OPERATOR]_LITCONST;

				%(***FOR THIS TO BE AN ASCIZ STRING, MUST ALWAYS HAVE
					A WD OF ZERO ON THE END (MUST PAD THE LAST
					WD WITH BLANKS IN ORDER TO BE COMPATIBLE WITH FOROTS)***)%
				LITENTRY[LITWD(.WDS)]_NULLWD;	!SET THE XTRA WD TO 0
				 LITENTRY[LITEXWDFLG] _ 1;	!SET A FLAG

				RETURN .LITENTRY;
			END
		END;

		%(***IF REACH EOL WITHOUT FINDING THE CLOSING QUOTE***)%
		RETURN ERR72;
	END

	%(***IF KNOW IN ADVANCE THE NUMBER OF CHARS IN THE LITERAL, GET A LITERAL
		TABLE ENTRY OF THE REQUIRED SIZE AND COPY THE LITERAL DIRECTLY
		INTO IT****)%
	ELSE
	BEGIN
		%(***GET A NEW LITERAL TABLE ENTRY OF THE SIZE REQUIRED***)%
		WDS_(.ENTRY-1)/5 + 2;
		NAME<LEFT>_(IF .WDS LEQ 2 THEN 5 ELSE 3 + .WDS);
		NAME<RIGHT>_LITTAB;
		LITENTRY_NEWENTRY();
		LITENTRY[LITSIZ]_.WDS;

		%(***SET UP BYTE PTR TO BYTE BEFORE THE FIRST BYTE OF THE ENTRY TO BE STORED**)%
		POINT_(LITENTRY[LIT1]-1)<0,7>;

		DECR I FROM .ENTRY-1 TO 0 DO
		BEGIN
			IF CHAR() NEQ EOL THEN REPLACEI(POINT,.CHR)
			%(***IF REACH END-OF-LINE BEFORE THE REQUIRED NUMBER
				OF CHARS, PAD OUT WITH SPACES***)%
			  ELSE
			BEGIN
				WHILE .I NEQ 0
				DO
				BEGIN
					REPLACEI(POINT," ");
					I_.I-1;
				END;

			END;
		END;


		%(***PAD WITH BLANKS TO THE WD BOUNDARY***)%
		IF (.ENTRY MOD 5) NEQ 0
		THEN
		DECR K1 FROM (4-(.ENTRY MOD 5)) TO 0
		DO REPLACEI(POINT,BLANK);

		LITENTRY[OPERATOR]_LITCONST;

		%(***FOR THIS TO BE AN ASCIZ STRING, MUST ALWAYS HAVE
			A WD OF ZERO ON THE END (MUST PAD THE LAST
			WD WITH BLANKS IN ORDER TO BE COMPATIBLE WITH FOROTS)***)%
		LITENTRY[LITWD(.WDS)]_NULLWD;	!SET THE XTRA WD TO 0
		 LITENTRY[LITEXWDFLG] _ 1;	!SET A FLAG

		RETURN .LITENTRY;
	END
END;
!
!	THE FOLLOWING ROUTINE READS CHARACTERS
!
!
!	THE NEXT ROUTNE SETS THE TYPE OF SYMBOLS
!
!
%
ROUTINE IMPTYPSET=	!SET IMPLICIT TYPE OF CHARACTERS IN ENTRY THRU ENTRY +1
BEGIN
!
!	ENTRY +1 AND ENTRY+2 CONTAIN THE SIXBIT ALPHABETIC CHARACTER
!	RANGE THAT HAS AN ASSOCIATED IMPLICIT TYPE DEFINED BY PARAM
!	THIS IMFORMATION IS SPECIFIED IN THE IMPLICIT STATEMENT AS
!	E.G. IMPLICIT REAL (K-M)   ETC.
!
MACRO IMPBIT = R2<18,1>$;
!
!
	XTRAC;	!FOR DEBUGGING TRACE
	INCR I FROM .(ENTRY+1) TO .(ENTRY+2) DO
	BEGIN
	R2<FULL> _ .(TYPTAB-41)[.I];
	R1<FULL> _ .ENTRY;		!THE NEW TYPE CODE
	IF .IMPBIT
	  THEN (IF .R1<FULL> NEQ .R2<RIGHT> THEN RETURN -1);
	IMPBIT _ 1;
	TYPTAB[-41+.I]<RIGHT> _ .R1<RIGHT>;
	TYPTAB[-41+.I]<LEFT> _ .R2<LEFT>;
	END;
RETURN
END;
%
!
!
!
ROUTINE INTEXPONENT=		!DEVELOP INTEGER EXPONENT FOR CONSTANT GEN
BEGIN
EXTERNAL DECEXP,CHAR,QUEUE,ERROUT;
MACRO SUM = R2<FULL>$;
REGISTER R2;
LOCAL SIIGN;
!
	XTRAC;	!FOR DEBUGGING TRACE
!
	SUM _0; SIIGN _0 ;
	IF .CHR EQL "-"  THEN ( SIIGN _ -1; SIGCHAR)
	  ELSE IF .CHR EQL "+" THEN SIGCHAR;
	IF NOT DIGIT(CHR) THEN  RETURN ERROUT(95); !NO EXPONENT AFTER D OR E
	WHILE DIGIT(CHR) DO
	BEGIN
		CHR _ .CHR AND #17; SUM _ .SUM *10 ; SUM _ .SUM +.CHR; SIGCHAR
	END;
	IF .SIIGN NEQ 0 THEN SUM _ -.SUM;
	QUEUE();	!SAVE CHARACTER AFTER EXPONENT
	DECEXP _.DECEXP+.SUM
END;
!
!
!
!THE NEXT ROUTINE BUILDS A DOUBLE PRECISION INTEGER IF NEED BE
!
ROUTINE BILDDBLINT=
BEGIN
EXTERNAL DECEXP,INCREM,CHAR;
MACRO LO = R2<FULL>$,
	HI = R1<FULL>$;
GLOBAL HIAC,LOAC;
MACRO DPADD1(X) =	ADD(X+1,LOAC);
			TLZE(X+1,#400000);
			AOS(X,HIAC);
			MOVEM(X+1,LOAC)$;
MACRO DPADD(X) = ADDB(X,HIAC);
		   DPADD1(X);$;
!
!ALGORITHM IS SIMPLY
!	(HIAC,LOAC)_ (HIAC,LOAC)*8 + (HIAC,LOAC)*2 + .CHR -"0"
!
!
	XTRAC;	!FOR DEBUGGING TRACE
!
	DO
	BEGIN
	  HI _ .HIAC;
	  IF (.HI AND #760000000000 ) EQL 0
	  THEN BEGIN
		DECEXP _ .DECEXP+.INCREM;
		LO _ .LOAC;
		ASHC(HI,3);
		HIAC _ .HI; LOAC _ .LO;
		ASHC(HI,-2);
		DPADD(HI)	!MACRO ABOVE
		LO _ .CHR;
		LO _ .LO - "0";
		DPADD1(HI)	!MACRO ABOVE
	      END;
	SIGCHAR;
	END WHILE DIGIT(CHR)
END;
!
GLOBAL ROUTINE GETCONST=	!MAKE A CONSTANT
!
!THIS ROUTINE IS CALLED BY LEXEME() OR DOT() TO DEVELOP AN INTEGER OR REAL
!OR DOUBLE PRECISION CONSTANT
!IT LOADS ENTRY AND ENTRY +1 WITH THE CONSTANT AND CALLS TBLSEARCH TO
!ENTER IT IN THE CONSTANT POOL
!THE TYPE OF THE CONSTANT IS ALSO DETERMINED
!
BEGIN
BIND CONST=21,LITER = 22;
EXTERNAL ENTRY,SYMTYPE,NAME,TBLSEARCH,BILDDBLINT,FCMML,CHAR,QUEUE;
EXTERNAL HIAC,LOAC;
EXTERNAL  DECEXP,INCREM;
OWN EXPO;
LABEL C2;
!
	XTRAC;	!FOR DEBUGGING TRACE
!
!
	DECEXP _ 0; EXPO _ 0;  INCREM_0; HIAC _0; LOAC _ 0; NAME _ CONTAB; SYMTYPE _INTEGER;
!
!NOW IGNORE LEADING ZEROES IF ANY
!
	IF DIGIT(CHR) THEN BILDDBLINT();		!MAKE INTEGER PART IF ANY
	IF .CHR EQL "H"
	THEN
	  BEGIN
		ENTRY _ .LOAC;
		RETURN (LITER^18 + LITERL())
	  END;
	!HERE IF DIGITS FOLLOWED BY NON "H"
    C2: IF .CHR EQL "."
	THEN
	   BEGIN
		SYMTYPE _ REAL;
		SIGCHAR;
		IF .CHR EQL "."
		THEN
		   (QUEUE(); LEAVE C2)  !. FOLLOWED BY .
		ELSE
		   (IF DIGIT(CHR)
			THEN(INCREM _ -1; BILDDBLINT());
		    IF .CHR EQL "D"
			THEN(SIGCHAR; SYMTYPE _ DOUBLPREC; EXPO _ -1; LEAVE C2);
		    IF .CHR EQL "E"
			THEN (SIGCHAR;
				IF ALPHA(CHR)
				THEN(LOCAL TCHR; IF NOT .INCREM THEN SYMTYPE _ INTEGER;
				     TCHR _ .CHR; CHR _ "."; QUEUE();
				     CHR _ "E"; QUEUE(); CHR _.TCHR; QUEUE();
				     LEAVE C2
				    )
				ELSE (EXPO _ -1; LEAVE C2)
			     );
		    IF NOT ALPHA(CHR) THEN (QUEUE(); LEAVE C2)
			ELSE (LOCAL TCHR;
				IF NOT .INCREM THEN SYMTYPE _ INTEGER;
				TCHR _.CHR; CHR _ "."; QUEUE();
				CHR _ .TCHR; QUEUE();
				LEAVE C2
			     )
		   );
	   END
	ELSE
	   BEGIN
		IF .CHR EQL "D"
		THEN (SIGCHAR; SYMTYPE _ DOUBLPREC; EXPO _ -1; LEAVE C2);
		IF .CHR EQL "E"
		THEN (SIGCHAR;
		      IF ALPHA(CHR)
			THEN(QUEUE(); LEAVE C2)
			ELSE(SYMTYPE _ REAL; EXPO _ -1; LEAVE C2);
		     );
		QUEUE(); LEAVE C2
	   END;
	IF .EXPO LSS 0 THEN INTEXPONENT();
	IF .SYMTYPE NEQ INTEGER THEN
	  BEGIN
	    FCMML();
	!ALWAYS KEEP MAXIMUM PRECISION FOR REAL CONSTANTS
	    ENTRY[0] _ .HIAC;
	    ENTRY[1] _ .LOAC;	!LOW ORDER PART
	  END
	  ELSE (ENTRY[1] _ .LOAC; ENTRY[0] _ 0);
	RETURN(CONST^18 + TBLSEARCH())
END;
    