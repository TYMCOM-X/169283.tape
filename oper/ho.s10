GLOBAL %HOST

BASE 0
FIND JOBERR,%RETLIN
!CG INTERFACE:

FIND %TV,P,T(10),V(10),X(10),CREFSW,%OUTCH,%BIO,INP
FIND ID(10),%UTV,%UNARY,%JMP.LNK,%CJMP.LNK,%CG
FIND %FGTALL,%CLOSE,%CRR.SYM,%CRD.SYM,LASTBR,%UPERR

! PA INTERFACE:

FIND %REMOVMAC,%NEW.BLOCK,STB,%DMP,%D.NXT.SYM,%PRINT.LINE.CR
DEF KIND.V(I) AS (^I SHR 27)
DEF KIND.VS(I) AS (^(I+BLK.SIZ) SHR 27)
DEF LOC.V(I) AS (^I BAND OCT 1.777.777)
DEF LOC.VS(I) AS (^(I+BLK.SIZ) BAND OCT 1.777.777)
DEF ID.SPLIT(K,D,SC,ST,L) AS [9,5,2,1,19]*[K,D,SC,ST,L]

DEF KON AS 3
DEF W.ABS AS 4
DEF W.REL AS 5
DEF REG        AS 8
DEF INDR.OP AS 10
DEF AT.OP AS 9
DEF BLK.SIZ AS 256

!GI INTERFACE:

FIND %WARN,%STK.ID,%USTK.ID,%GETSYM,%PRINT,%PUT,%OPEN,%CIO,%GET
FIND RESULT(2),LSNUM,SYMBUF(2),RPTR
FIND %GI,PRO.DP,NULL.DP,RECOVER:

GLOBAL KIND,DEPTH,SCOPE,STATE,LOC,%PAK.VB,%UNPAK.VB,%HOSTEND
GLOBAL %GEN,%GLNUM,%BEG.LV,%END.LV,%HO.CLR,%IDWF,%MK.ST.BLK
GLOBAL CD.P,DT.P,%DCL,%DCL.STR,%K.ADD,%K.NOT,%TV.KON
GLOBAL %K.AR,%MAK.POS,%RLS.K,%TV.ID,%DCL.LAB,%LOC.MOD
GLOBAL %TVKI,%LOG,%K.NEG,%K.SIGN,%TVDKI,%K.SGN
GLOBAL %K.SPLIT,%GEN.KON,K.LH,K.RH
GLOBAL %INPW,%FWF,%PWF,IDW,HIB, LOB,%PVAL,%BFWD,%FIXUP,%BCFWD
GLOBAL %GKIND,FNO,TITLE.P
GLOBAL %ERR,%IERR,ERRCNT
GLOBAL %ALLOC,%ALTER,%LDEF,%PDEF,%OUT.SYM,PRO.NAME

LOCAL OUTREL,RELBYT,%KONREF,%STBLK,IDSTART
LOCAL %PSYM,%POCT,%BL.START,%BL.PUT,%BL.END
LOCAL %RAX50
LOCAL %SYMLIT,%DEF.CD,%STEP.C
LOCAL FUP.BEG,FUP.BLK(),FUP.INX
LOCAL ECS.BEG,ECS.BLK(),ECS.INX
LOCAL DLN.BEG,DLN.BLK(),DLN.INX

DEF FN.REL AS FNO
DEF ABSOLUTE AS 0
DEF LO.SEG AS 1
DEF HI.SEG AS 2
DEF LR.HI.SEG AS 3
DEF KVSZ AS 30
LOCAL KV(KVSZ),KU(KVSZ)
LOCAL J,MV,K.INDX
DEF SPLIT AS [BITSPERWORD/2,BITSPERWORD/2]
DEF K.LEFT(K) AS (K SHR (BITSPERWORD/2))



DEF CODE(L) AS L<OCT 1.000000
DEF CD.END AS OCT 777.777
DEF DT.END AS OCT 1.777.777
DEF CD.BEG AS OCT 1
DEF DT.BEG AS OCT 1.000.001

DEF NULL.LINK AS 0

! ORDER SIGNIFICANT IN THESE DEFS, RANGE TEST MADE IN CODE:
!
!      KIND   LOC
!      ---------------        ----------------

DEF UNDCL      AS 0           !      0
DEF FLAB        AS 1    ! FONY LABEL
DEF LABEL      AS 2
DEF PROC       AS 3
DEF VARB       AS 4
DEF SVEC       AS 5
DEF DVEC       AS 6
DEF TEXT       AS 7
DEF MACRO      AS 14 !        INDEX FOR MACRO PROCESSOR


!      SCOPE:

DEF FIND.S     AS 0
DEF GLOBAL.S   AS 1
DEF PARAM.S    AS 2           !      @<NAME>  ONLY
DEF LOCAL.S    AS 3

! STATE IS 1 IF DEFINED.

! DEPTH IS NULL.DP BEFORE FIRST PROCEDURE

!****************************

%HOST(CFILE)

LOCAL PTR1,CHAR
PTR1_TITLE.P
       IF CREFSW#0 THEN DO
       OUTCH(OCT 177); OUTCH(OCT 102); OUTCH(OCT 20)
       WHILE CHAR_NCHV(PTR1)#E.O.LIT THEN OUTCH(CHAR)
       OUTCH(OCT 177); OUTCH(OCT 104)
	END

ERRCNT_0
CD.P_CD.BEG; DT.P_DT.BEG
BL.START(OCT 20); RELBYT_ABSOLUTE; OUTREL_0 ; BL.PUT; BLEND
 BL.START(6); RELBYT_ABSOLUTE
OUTREL_RAX50(TITLE.P); BL.PUT; BL.END
ECS.BEG_0; ECS.BLK_@ECS.BEG; ECS.INX_BLK.SIZ-1
DLN.BEG_0; DLN.BLK_@DLN.BEG; DLN.INX_BLK.SIZ-1
FUP.BEG_0; FUP.BLK_@FUP.BEG; FUP.INX_BLK.SIZ-1
K.INDX_0; IDSTART_0
IDW_-1; BEG.LV; GI; CG
RETURN

%HOSTEND
LOCAL I,J,K,L2:,L4:,LITARY(1:25),PTR1,PTR2,D,F,N

IDW_-1; END.LV
ECS.BLK_ECS.BEG
WHILE ECS.BLK#0 THEN DO
	K_0; J_IF ECS.BLK(0)=0 THEN ECS.INX ELSE BLK.SIZ-1
	WHILE INC K<=J THEN DO
		RELBYT_ABSOLUTE
		OUTREL_OCT 600.000.000.000 BOR RAX50(CHPT( &
			SYMLIT(HW(@ECS.BLK(K))),-1))
		BL.PUT
		RELBYT_HI.SEG
		OUTREL_OCT 400.000.000.000 BOR HW(@ECS.BLK(K),1)
		BL.PUT
	END
	ECS.BLK_ECS.BLK(0)
END

DLN.BLK_DLN.BEG; I_0
WHILE DLN.BLK#0 THEN DO
	K_0; J_IF DLN.BLK(0)=0 THEN DLN.INX ELSE BLK.SIZ-1
	WHILE INC K<=J THEN DO
		RELBYT_ABSOLUTE; F_1; OUTREL_OCT 46; N_INC I
		WHILE F_F*10<=N THEN NULL
		WHILE F_F/10>0 THEN [[D;N]_N DIVMOD F; OUTREL_ &
			OUTREL*OCT 50+D+1]
		OUTREL_OUTREL BOR OCT 100.000.000.000
		BL.PUT
		RELBYT_HI.SEG; OUTREL_DLN.BLK(K); BL.PUT
	END
	DLN.BLK_DLN.BLK(0)
END

BL.END
I_CD.P; RELBYT_ABSOLUTE
BL.START(1); J_-1
WHILE INC J<K.INDX THEN [OUTREL_KV(J); STEP.C]

DMPSY:	DMP(STB,L2)
L1: J_D.NXT.SYM; IF KIND.VS(J)=TEXT THEN DO
	GETSYM(J)
K_26; WHILE DEC K>0 THEN LITARY(K)_0
PTR1_CHPT(SYMBUF+1); PTR2_CHPT(LITARY+1,-1); K_CHV(PTR1)
WHILE NCHV(PTR2)_NCHV(PTR1)#K THEN NULL; J_0
CHV(PTR2)_E.O.LIT
WHILE INC J<=SYMBUF(0) THEN [OUTREL_LITARY(J); STEP.C]
END
GO L1

L2:	BL.END; BL.START(OCT 10); RELBYT_LR.HI.SEG; J_-1
WHILE INC J<K.INDX THEN [OUTREL_[18,18]*[KU(J)-CD.BEG,I-CD.BEG]&
		;BL.PUT; I_LOC.MOD(I,1)]

DMP(STB,L4)
L3: J_D.NXT.SYM; IF KIND.VS(J)=TEXT THEN DO
	GETSYM(J)
	OUTREL_[18,18]*[LOC.VS(J)-CD.BEG,I-CD.BEG]; I_LOC.MOD(I,SYMBUF(0))
	BL.PUT
END
GO L3

L4: FUP.BLK_FUP.BEG
WHILE FUP.BLK#0 THEN DO
	K_0; J_IF FUP.BLK(0)=0 THEN FUP.INX ELSE BLK.SIZ-1
	WHILE INC K<=J THEN [OUTREL_FUP.BLK(K); BL.PUT]
	FUP.BLK_FUP.BLK(0)
END

BL.END; STBLK; BL.START(5); RELBYT_HI.SEG; OUTREL_CD.P-CD.BEG; BL.PUT
RELBYT_LO.SEG; OUTREL_DT.P-DT.BEG; BL.PUT
BL.END; CLOSE(FN.REL)

IF INP#0 THEN IF ERRCNT=0 THEN RETURN ELSE GO ERRPRT
PUT(CARRET); PRINT('PROG SIZE = '); POCT(CD.P-CD.BEG)
PUT(CARRET); PRINT('DATA SIZE = '); POCT(DT.P-DT.BEG)
PUT(CARRET)
ERRPRT:	IF ERRCNT=0 THEN PRINT('NO') ELSE [PVAL(ERRCNT); &
        UPERR(JOBERR_ERRCNT)]
PRINT(' ERROR'); IF ERRCNT#1 THEN PUT($S)
PRINT(' FOUND'); PUT(CARRET)

RETURN
END HOSTEND

%HO.CLR
RETURN
END HO.CLR

%FWF
%%IDWF
	RETURN IDW_INPW
END FWF

%PWF
       [BITSPERWORD-8,8]*[HIB,LOB]_INPW
RETURN
END PWF


%INPW
       RETURN RESULT(INC RPTR)
END INPW

%ERR(LIT)
RETLIN; PRINT(LIT); PRINT.LINE.CR; GO RECOVER
END ERR

%IERR(LIT)
RETLIN; PRINT(LIT); PSYM(IDW); PRINT.LINE.CR; GO RECOVER
END IERR

%PSYM(I)
PRINT(SYMLIT(I))
RETURN
END PSYM

%SYMLIT(I)
GETSYM(I-BLK.SIZ); CH(@SYMBUF(SYMBUF(0)+1))_EOLIT
RETURN @SYMBUF(1)
END SYMLIT

%POCT(N)
       LOCAL K
       IF N =0 THEN [PUT($0);RETURN]
       K_BITSPERWORD/3
       WHILE 7 BAND(N_N ROTL 3)=0 THEN DEC K
       WHILE DEC K>=0 THEN PUT($0+7 BAND N<==N ROTL 3)
RETURN
END POCT

%PVAL(N) ! PRINT DECIMAL NUMBER
IF N<0 THEN [N_-N; PUT($-)]
LOCAL D,F
F_1; WHILE F_F*10<=N THEN NULL
WHILE F_F/10>0 THEN [[D;N]_N DIVMOD F; PUT($0+D)]
RETURN
END PVAL

%GLNUM ! GENERATE LINE NUMBER COMMENT:
!IF DLN.INX>BLK.SIZ-2 THEN [DLN.BLK_DLN.BLK(0)_NEW.BLOCK(1) &
	; DLN.INX_0; DLN.BLK(0)_0]
!DLN.BLK(INC DLN.INX)_CD.P-CD.BEG
RETURN
END GLNUM


!*****************
!      
!      EMITTERS OF WORDS OF CODE:

%GEN(MODE,INS,AC,IX,INDR,OPND)

LOCAL %OCD.P,%ODT.P,%OLNK

! MODE OPND
! 
! 0    OPERAND INDEX
! 1    ABSOLUTE
! 2    CODE ADDRESS
! 3    DATA ADDRESS
! 4    LINK

OUTREL_[9,4,1,4,18]*[INS,AC,INDR,IX,0]
LASTBR_0

DO MODE OF 0:4

0 !OPERAND! : IDW_ID(OPND); MV_V(OPND)
       DO T(OPND) OF KON:REG
       REG:W.ABS: HW(@OUTREL,1)_MV; RELBYT_ABSOLUTE
       KON: OLNK(KON.REF(MV))
       W.REL: IF IDW=0 THEN ODT.P(MV) ELSE DO
		UNPAK.VB
		EIF SCOPE=FIND.S THEN DO
			EIF HW(@IX)=0 THEN [OLNK(@LOC); PAK.VB]
			ELSE DO
			     IF ECS.INX>BLK.SIZ-2 THEN [ECS.BLK_ &
			       ECS.BLK(0)_NEW.BLOCK(1); ECS.INX_ &
			       0; ECS.BLK(0)_0]
			     ECS.BLK(INC ECS.INX)_[18,18]* &
			       [IDW,CD.P-CD.BEG]
			     HW(@OUTREL,1)_HW(@IX); RELBYT_ABSOLUTE
			END
		END
		ELSE DO KIND OF FLAB:TEXT
		FLAB: LABEL: PROC: EIF SCOPE=PARAM.S THEN ODT.P(LOC)
		ORIF STATE=1 THEN OCD.P(LOC)
		ELSE [OLNK(@LOC);PAK.VB]
		VARB: SVEC: DVEC: IF CODE(LOC) THEN OCD.P(LOC) ELSE ODT.P(LOC)
		TEXT: OLNK(@LOC); PAK.VB
		END ! KIND OF LABEL:TEXT
	END
       END ! T(OPND) OF KON:REG

1 !ABSOLUTE! : RELBYT_ABSOLUTE; HW(@OUTREL,1)_OPND

2 !CODE! : OCD.P(OPND)

3 !DATA! : ODT.P(OPND)

4 !LINK! : OLNK(OPND)

END ! MODE OF 0:4

STEP.C; RETURN

%OCD.P(CD) ! OUTPUT CODE REFERENCE RELATIVE TO C.
RELBYT_HI.SEG; HW(@OUTREL,1)_CD-CD.BEG+HW(@IX)
RETURN
END OCD.P

%ODT.P(DT) ! OUTPUT DATA REFERENCE RELATIVE TO D.
RELBYT_LO.SEG; HW(@OUTREL,1)_DT-DT.BEG+HW(@IX)
RETURN
END ODT.P

%OLNK(@LNK) ! OUTPUT REFERENCE TO LINK
! CD.BEG MUST BE SUBTRACTED FROM ALL CD.P REFERENCES
! NOTE THAT IF LINK=0, IT IS END OF CHAIN SINCE LOWEST CD.P=1
IF LNK=0 THEN RELBYT_0 ELSE [RELBYT_HI.SEG; LNK_LNK-CD.BEG]
HW(@OUTREL,1)_LNK<==CD.P
RETURN
END OLNK

END GEN


%GEN.KON
EIF T(P)=KON THEN [RELBYT_ABSOLUTE; OUTREL_V(P); STEP.C]
ELSE GEN(0,0,0,0,0,P)
RETURN
END GEN.KON

%STEP.C
BL.PUT
IF INC CD.P<CD.END THEN RETURN; WARN('PROG OFL'); EXIT
END STEP.C

%MKSTBLK  !MAKE A START BLOCK---TYPE 7
	UNPAK.VB
	IDSTART_LOC; RETURN
%STBLK
	IF IDSTART=0 THEN RETURN
	BLSTART(7) !START TYPE 7
	RELBYT_HISEG; OUTREL_IDSTART-CD.BEG; BL.PUT; BL.END
	RETURN
END STBLK
END MKSTBLK


!*********************

%PAK.VB
^IDW_ID.SPLIT(KIND,DEPTH,SCOPE,STATE,LOC); RETURN
END PAK.VB

%UNPAK.VB
ID.SPLIT(KIND,DEPTH,SCOPE,STATE,LOC)_^IDW; RETURN
END UNPAK.VB

%GKIND (IDPT)  !RETURN KIND GIVEN SYMBOL ID
RETURN KIND.V(IDPT)
END GKIND

%ALLOC(N) ! ALLOCATE DATA STORAGE AND RETURN DT.P TO FIRST WORD
IF N_DT.P+N<DT.END THEN RETURN DT.P<==N
WARN('DATA OFL'); EXIT
END ALLOC

%ALTER(CD) ! ALTER CD.P TO CD
CD.P_CD; BL.END; BL.START(1)
RETURN
END ALTER

%LOC.MOD(L,M) ! MODIFY PROGRAM LOCATION L BY M
RETURN [18,18]*[HW(@L),HW(@L,1)+M]
END LOC.MOD

%DCL(KIND.1,SCOPE.1,LOC.1) ! DECLARE A VARIABLE (IDW)
IF CREFSW#0 THEN IF LABEL#KIND.1#PROC THEN CRD.SYM ELSE CRR.SYM
UNPAK.VB
IF FLAB#KIND#UNDCL AND DEPTH=PRO.DP THEN IERR('DUPLICATE: ')
STK.ID(IDW)
KIND_KIND.1; DEPTH_PRO.DP; SCOPE_SCOPE.1; LOC_LOC.1
STATE_[KIND>PROC OR SCOPE=FIND.S OR SCOPE=PARAM.S]
PAK.VB
RETURN
END DCL

%DCL.STR
IF KIND.V(IDW)=UNDCL THEN DO
KIND_TEXT; SCOPE_LOCAL.S; DEPTH_NULL.DP; STATE_1; LOC_NULL.LINK
PAK.VB
END
RETURN
END DCL.STR


%LDEF ! DEFINE LABEL HERE
LOCAL X
UNPAK.VB
IF FLAB#KIND#LABEL OR STATE#0 THEN DCL(LABEL,LOCAL.S,NULL.LINK)
KIND_LABEL
DEF.CD
RETURN
END LDEF

%PDEF ! DEFINE PROCEDURE HERE
UNPAK.VB
IF KIND#PROC OR STATE#0 THEN IERR('UNDECLARED: ')
DEF.CD
RETURN
END PDEF

%DEF.CD ! PACK AWAY DEF OF CD.P
IF CREFSW#0 THEN CRD.SYM
IF LOCAL.S#SCOPE#GLOBAL.S THEN IERR('NO NO: ')
FIXUP(LOC)
STATE_1; LOC_CD.P; PAK.VB; FGTALL
RETURN
END DEF.CD


%BFWD(XLINK) ! ONE OF A LIST OF LINKED BRANCHES TO UNKNOWN LOCATION
IF LASTBR=0 THEN JMP.LNK(XLINK)
RETURN
END BFWD

%BCFWD(XLINK,CREL)
CJMP.LNK(XLINK,CREL); RETURN
END BCFWD

%FIXUP(LINK) ! SATISFY CHAINED REFERENCES HERE (CD.P)
IF LINK=NULL.LINK THEN RETURN
IF FUP.INX>BLK.SIZ-2 THEN [FUP.BLK_FUP.BLK(0)_NEW.BLOCK(1); &
	FUP.INX_0; FUP.BLK(0)_0]
FUP.BLK(INC FUP.INX)_[18,18]*[LINK-CD.BEG,CD.P-CD.BEG]
FGTALL
RETURN
END FIXUP

%OUT.SYM ! CLOSE OUT IDW
LOCAL T
UNPAK.VB
EIF STATE=0 AND KIND#FLAB THEN DO
       WARN('UNDEFINED: '); PSYM(IDW); PUT(CARRET)
END
ORIF KIND=FLAB THEN RETURN
ELSE DO
	EIF SCOPE#FIND.S THEN DO
	   OUTREL_IF SCOPE=GLOBAL.S THEN OCT 040.000.000.000 &
		ELSE OCT 100.000.000.000
	   T_IF CODE(LOC) THEN HI.SEG ELSE LO.SEG
	END
	ELSE DO
	   OUTREL_OCT 600.000.000.000
	   T_HI.SEG
	END
	OUTREL_OUTREL BOR RAX50(CHPT(SYMLIT(IDW),-1))
	RELBYT_ABSOLUTE; BL.PUT
	IF LOC#NULL.LINK THEN [OUTREL_(LOC-1) BAND OCT 777.777; RELBYT_T] &
	ELSE [OUTREL_0; RELBYT_ABSOLUTE];  BL.PUT
END
RETURN
END OUT.SYM

%TV.ID
       UNPAK.VB
       IF KIND=UNDCL THEN IERR('UNDECLARED: ')
       TV(W.REL); ID(P)_IDW
       EIF KIND=TEXT THEN UNARY(AT.OP)
	ELSE IF CREFSW#0 THEN CRR.SYM
       IF SCOPE=PARAM.S THEN UNARY(INDR.OP)
RETURN
END TV.ID

%DCL.LAB ! IMPLICIT DECL OF LABEL BY VIRTUE OF "GO"
UNPAK.VB
IF KIND=LABEL AND DEPTH<PRO.DP &
 AND SCOPE=LOCAL.S THEN [ DCL(FLAB,LOCAL.S,NULL.LINK);RETURN]
IF LABEL#KIND#FLAB THEN DCL(LABEL,LOCAL.S,NULL.LINK)
RETURN
END DCL.LAB

%BEG.LV ! BEGIN A PROCEDURE
IF IDW#-1 THEN BL.END
STKID(@IDW); BL.START(1); RETURN
END BEG.LV

%END.LV        !END A PROCEDURE
LOCAL PRNAME,T,ID,TCD.P,XLINK
       ID_IDW; BL.END; BL.START(2); RELBYT_ABSOLUTE
	OUTREL_RAX50(IF IDW#-1 THEN CHPT(SYMLIT(IDW),-1) ELSE &
		TITLE.P) BOR OCT 140.000.000.000
	BL.PUT; OUTREL_PRO.DP+1; BL.PUT
       WHILE IDW_USTKID(@T)#@IDW THEN DO
        UNPAK.VB
       IF KIND.V(IDW)=MACRO THEN REMOVMAC(LOC.V(IDW)) ELSE &
                IF KIND =FLAB THEN DO
                XLINK_LOC
                ^IDW_T
                UNPAK.VB
                TCD.P_CD.P<==LOC
                FIXUP(XLINK)
                CD.P_TCD.P
        END &
ELSE OUT.SYM
       ^IDW_T
       END
       IF T#ID THEN [IDW_T;IERR('SHOULD BE END OF ')]
       RETURN
END ENDLV

!******************

!      KONSTANT MANAGEMENT:

%RLS.K(O)
RETURN
END RLS.K

%K.ADD(O,N)
       V(O)_V(O)+N
       RETURN
END K.ADD

%K.SGN(O)
        RETURN IF V(O)<0 THEN 1  ELSE 0
END K.SGN
%K.SIGN(O)
       RETURN IF V(O)<0 THEN -1 ELSE 0
END K.SIGN

%K.NEG(O)
       V(O)_-V(O)
       RETURN
END K.NEG

%K.NOT(O)
       V(O)_BNOT V(O)
       RETURN
END K.NOT

%K.SPLIT(O)
       SPLIT*[K.LH,K.RH]_V(O)
       RETURN
END K.SPLIT

%K.AR (OP) ! RETURN 1 IF CONSTANT CLOSURE SUCCESSFUL
LOCAL I,J
DEF KOP(OPR) AS V(P-1) OPR_J
DEF KOP1(OPR) AS V(P-1)_I OPR J

IF NOT T(P-1)=KON=T(P) THEN RETURN 0
J_V(P); I_V(P-1)
DO OP SHR 4 OF 0:4
0:     DO OP OF HEX 00 !+!:HEX 03 !/!
       HEX 00 !+!: KOP(+)
       HEX 01 !-!: KOP(-)
       HEX 02 !*!: KOP(*)
       HEX 03 !/!: IF J=0 THEN WARN('ZERO DIV') ELSE KOP(/)
       END
1:     KOP1(MOD)
2:     DO OP OF HEX 20 !BAND!:HEX 23 !BEQV!
       HEX 20 !BAND!: KOP(BAND)
       HEX 21 !BOR! : KOP(BOR)
       HEX 22 !BXOR!: KOP(BXOR)
       HEX 23 !BEQV!: KOP(BEQV)
       END
3:     DO OP OF HEX 30 !SHL!:HEX 33 !ROTR!
       HEX 30 !SHL! : KOP1(SHL)
       HEX 31 !SHR! : KOP1(SHR)
       HEX 32 !ROTL!: KOP1(ROTL)
       HEX 33 !ROTR!: KOP1(ROTR)
       END
4:     DO OP OF HEX 40 !MAX!:HEX 41 !MIN!
       HEX 40 !MAX!: KOP1(MAX)
       HEX 41 !MIN!: KOP1(MIN)
       END
END
RETURN 1
END K.AR

%MAK.POS(O) ! MAKE OPERAND O POSITIVE, RETURN 1 IF NEGATION REQUIRED
       IF K.SIGN(O)=0 THEN RETURN 0
       K.NEG(O); RETURN 1
END MAK.POS

%LOG(O) ! RETURN LOG BASE 2 OF VALUE IF EXACT ELSE -1
       IF T(O)#KON THEN RETURN -1
       J_ABS V(O)
       IF J=0 OR J BAND -J # J THEN RETURN -1
       LOCAL K
       K_0; WHILE J>1 THEN [J_J/2; INC K]; RETURN K
END LOG

%TVKI(K)
       TV(KON)
       V(P)_K
RETURN
END TVKI

%KON.REF(K) ! RETURN LINK TO KONSTANT K
J_K.INDX
WHILE DEC J>=0 THEN IF K=KV(J) THEN RETURN @KU(J)
IF K.INDX>KVSZ THEN ERR('KON OFL')
KV(K.INDX)_K; KU(K.INDX)_NULL.LINK
J_@KU(K.INDX); INC K.INDX
RETURN J
END KON.REF

%TVDKI(LH,RH)
TVKI(SPLIT*[LH,RH]); RETURN
END TVDKI

%TV.KON(KTYPE)
LOCAL C,NC,BAS,NUM
TABLE BAS.TAB(1:4)[16,8,128,10]
BAS_BAS.TAB(KTYPE)
C_CHPT(SYMLIT(IDW),-1); NUM_0
WHILE NC_NCHV C#EOLIT THEN DO
       DO KTYPE OF 4
       1:     NUM_(NUM SHL 4)+(NC_NC-IF NC>$9 THEN $A-HEX A ELSE $0)
       2:     NUM_(NUM SHL 3)+(NC_NC-$0)
       3:     NUM_(NUM SHL 7)+NC
       4:     NUM_NUM*10+(NC_NC-$0)
       END
       IF NOT 0<=NC<BAS THEN IERR('FAR OUT DIGIT')
END
TVKI(NUM)
RETURN
END TV.KON

%RAX50(PTR) ! CONVERT SYMBOL PTR TO RADIX 50
LOCAL J,R,CHR
J_6; R_0
WHILE DEC J>=0 AND CHR_NCHV(PTR)#EOLIT THEN DO
	EIF $0<=CHR<=$9 THEN CHR_CHR+(1-$0)
	ORIF $A<=CHR<=$Z THEN CHR_CHR+(OCT 13-$A)
	ORIF CHR=$. THEN CHR_OCT 45
	ORIF $$<=CHR<=$% THEN CHR_CHR+(OCT 46-$$)
	ELSE HALT
	R_OCT 50*R+CHR
END
RETURN R
END RAX50

%BL.START (TYP)  !START A REL BLOCK TYPE=TYP
LOCAL OUTBUF(247),OUTPTR,RELWD,NWFLAG
	OUTBUF(0)_TYP SHL 18
	OUTPTR_RELWD_1
	IF TYP=1 THEN DO
		OUTPTR_2; OUTBUF(2)_CD.P-CD.BEG; OUTBUF(1)_HI.SEG
		INC OUTBUF(0)
	END
NWFLAG_-1
RETURN

%BL.PUT    !PUT OUTREL INTO BUFFER WITH RELOCATION OF RELBYT
	IF INC OUTPTR>247 THEN DO
		BIO(FN.REL,OUTBUF,248)
		BL.START(HW(OUTBUF)); INC OUTPTR
	END
	IF (OUTPTR-1)MOD 19=0 THEN [RELWD_RELWD+19; INC OUTPTR]
	OUTBUF(OUTPTR)_OUTREL; INC OUTBUF(0)
	OUTBUF(RELWD)_(OUTBUF(RELWD)SHL 2) BOR RELBYT
NWFLAG_0
RETURN

%BL.END   !END UP BLOCK
	IF NWFLAG#0 THEN RETURN
	IF (OUTPTR-1) MOD 19#0 THEN  &
   OUTBUF(RELWD)_OUTBUF(RELWD) SHL (36-(((OUTPTR-1) MOD 19)*2))
	BIO(FN.REL,OUTBUF,INC OUTPTR)
RETURN
END BL.END
END BL.PUT
END BL.START

END HOST
 