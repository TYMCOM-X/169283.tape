.;updated by sandy july 18, 1972
.paper size 54, 70
.LEFT MARGIN 0
.RIGHT MARGIN 70
.SPACING 1
.NOFILL
.PAGE
.CENTER
Section 1
.CENTER
Basic Elements of SIMPL
.SKIP 1
.SKIP 2
1.A.  Constants (KON)
.SKIP 1
.LEFT MARGIN 5
.FILL
    All values are integer.  The maximum value is (2_^N) -1, where  N is
    the number of bits in a word.
.LEFT MARGIN 10
.INDENT -5
.SKIP 1
    1.  Decimal
.SKIP 1
              Example: 0,179
.SKIP 1
.SKIP 1
.INDENT -5
    2.  Octal
.SKIP 1
         To specify an octal constant, precede the value with the word
         OCT; for example, OCT 77 designates octal 77.
.INDENT -5
.SKIP 1
    3.  Hexadecimal
.SKIP 1
         To specify a hexadecimal constant, precede the value with the
         word HEX; for example, HEX 7FFA designates hexadecimal
         7FFA.
.INDENT -5
.SKIP 1
    4.  Character
.SKIP 1
         Preceding a character by the $ symbol yields its internal
         representation as a right-justified integer.  For example,
         when generating code for the PDP-10, SIMPL evaluates the
         constant $A as octal 101, the ASCII code for the
         character A.
.SKIP 1
.INDENT -5
    5.  String
.SKIP 1
         To designate a string constant, surround the string with
         single or double quote marks.  The enclosed characters are
         stored however characters are stored on the machine being
         used, followed by at least one string terminator, the
         definition of which is also machine dependent.  As many
         terminators are added as necessary to fill the last word
         of the string.  If the last word of the string is already
         full (that is, if the number of characters is a multiple
         of the number of characters per word), a word of terminators
         is added.
.SKIP 1
         The value of a string constant is the address of the first
         word of the string.
.SKIP 1
.LEFT MARGIN 15
              Example:
.SKIP 1
              The constant "ABCDEF" is stored on the Sigma 7 as
.SKIP 1
               HEXC1C2C3C4#####HEXC5C60000
.SKIP 1
              Word 1#########Word 2
.SKIP 1
              and its value is the address of "word 1" of this diagram.
.LEFT MARGIN 10
.SKIP 1
.INDENT -5
    6.  Miscellaneous
.SKIP 1
        The value of the following constants are machine dependent:
.SKIP 1
        a.  EOLIT - the string terminator (0 on PDP-10 and Sigma 7)
.SKIP 1
.LEFT MARGIN 20
.INDENT -10
        b.  CHARSPERWORD - the number of characters per word (5 on
                           PDP-10, 4 on Sigma 7)
.skip 1
.INDENT -10
        c.  BITSPERWORD - the number of bits per word
.skip 1
.INDENT -10
        d.  CARRET - the internal representation of the carriage
                     return character.
.skip 1
.INDENT -10
        e.  LNFEED - the internal representation of the line feed
                     character
.skip 1
.LEFT MARGIN 5
    Periods are ignored within all constant types above except
    character and string constants.  Thus they can be used
    for decorative purposes, possibly to show separation
    between different parts of a word, without having any
    effect on the value.  For example, HEX 3C1C2C3 can also
    be written as HEX 3.C1C2C3, or HEX 3.C1.C2.C3.  The
    miscellanous constants might be made more readable by adding
    periods, as in CHARS.PER.WORD or CAR.RET.
.SKIP 2
.INDENT -5
1.B. Identifiers (ID)
.SKIP 1
    SIMPL variables, labels, procedures and macros are named with
    identifiers (IDs) which must begin with an alphabetic character (A
    to Z) and include only alphanumeric characters (A to Z, 0 to 9)
    thereafter.  Thus, the following are legal identifiers:
.SKIP 1
.NOFILL
.LEFT MARGIN 15
              A
              X12
              NMBUFND
.SKIP 1
.FILL
.LEFT MARGIN 2
    Periods are ignored within identifiers and may therefore  be used
    for decorative purposes, possibly to clarify the meaning of a
    particular string of characters.  For example, NMBUFND could
    alternately be written as NMBUF.ND, or NM.BUF.ND, or any
    combination within the same program, and SIMPL will equate all such
    forms to the identifier NMBUFND.
.SKIP 1
    The alphabetic strings that have a special meaning to SIMPL
    (reserved words, such as OCT, HEX, EOLIT) may not be used as
    identifiers.  However, a reserved word will be recognized as such
    only if it is terminated by a  space (or a non-alphanumeric
    character).  Thus, HEX C1 is read as a constant, but HEXC1 is an
    identifier.
.SKIP 1
    An  identifier may represent only one language element at a time.
    (See Section 4.F for information on scope of names when a SIMPL
    program  contains procedures.)
.SKIP 1
.SKIP 1
.INDENT -5
1.C. Variables and Arrays
.SKIP 1
    Each variable occupies a word of storage.  A variable may be simple
    (not subscripted) or have a single subscript (forming a
    one-dimensional array).  Variables are named with identifiers
    and must always be declared by the user.  (Note: When
    generating code for certain machines, SIMPL will initialize
    variables to 0, but this is not a standard SIMPL specification.
    Thus, if variables are to be initialized, the user should do so
    himself.)
.SKIP 1
    To declare a simple variable, type the identifier in the LOCAL
    declaration statement as follows:
.SKIP 1
    LOCAL ID
.SKIP 1
    To declare an array, follow its identifier  by the subscript limits
    in parentheses, in the form ID(KON:KON).  For example,
.SKIP 1
    LOCAL B(3:50)
.SKIP 1
    declares the 48-element array B.  If the subscript lower limit is
    1, it need not be specified.  For example,
.SKIP 1
    LOCAL SP(35) is equivalent to LOCAL SP(1:35)
.LEFT MARGIN 10
.SKIP 1
.INDENT -5
    Note: A subscript limit may in fact be any constant expression,
          including -KON; expressions are discussed in Section 1.E
          and 1.F.  Other types of declaration statements, and a
          statement that specifies the default subscript lower
          limit, are explained in Section 3.A.
.SKIP 1
.LEFT MARGIN 5
    Refer to a simple variable by its identifier, and to an array
    element by the array identifier followed by the  subscript in
    parentheses.  The subscript may be any arithmetic expression.  Thus
    B(4) and PTR(JCT+1) are legal references to array elements.  The
    user must himself check that when referencing an array element, the
    value of the subscript lies within the range of the limits as
    specified in the declaration statement.  SIMPL does not perform any
    subscript checking and will react unpredictably if a subscript is
    out of range.
.SKIP 1
    An array identifier may be typed alone, not followed by a
    subscript, in which case its value is the base address of the array
    (the address of its 0th element).  For example, if an array is
    declared as B(3:50), the value of B+3 is the address of array
    element B(3), and B+4 is the address of B(4), and so on.  It can be
    seen from this that a simple variable and array cannot have the
    same identifier.
.SKIP 1
.INDENT 5
      1.C.1  Floating Arrays
.SKIP 1
    The user may also declare a "floating array", as follows:
.SKIP 1
    LOCAL ID()
.SKIP 1
    This allocates one word of storage which can be referenced by the
    identifier ID and set to a value which is then taken to be the base
    address of an array identified by ID.  This allows, for example,
    parts of an array to be addressed by different identifiers than
    that of the entire array. If the statement
.SKIP 1
    LOCAL TEXT(200),BLK1(),BLK2()
.SKIP 1
    is followed by the statements that set BLK1 to the value of TEXT
    (the base address of the array TEXT), and BLK2 to TEXT+100, then
    BLK1(x) is equivalent to TEXT(x), and BLK2(x) is equivalent to
    TEXT(x+100). Changing the value of BLK1 or BLK2 effectively moves
    or  "floats" the arrays they identify.  For example, exchanging
    their values causes BLK2 to reference the lower half of TEXT and
    BLK1 the upper half, rather than vice versa.
.SKIP 1
.INDENT 5
      1.C.2  Indirect Addressing -_^
.SKIP 1
    The up arrow may be used to designate indirect addressing, that is,
    to refer to a word whose address is a specified value.  Thus, _^X
    refers to the variable whose address is stored in X.  What follows
    the _^ may be an identifier, subscripted or not, or an arithmetic
    expression in parentheses.  (Note: It may be any primary, as
    described in Section 1.L.) For example, suppose that an array is
    declared as
.SKIP 1
    LOCAL B(3:50)
.SKIP 1
    Since B is evaluated as the base address of the array, _^(B+3)
    refers to B(3) and can be used anywhere that B(3) can to address
    that particular storage word.
.SKIP 1
.INDENT 5
      1.C.3  Storage Word (SW)
.SKIP 1
    The different ways of addressing a storage word in SIMPL may be
    summarized as follows:
.SKIP 1
.LEFT MARGIN 10
.INDENT -4
    1.  An identifier typed alone; e.g., X, BLK1
.SKIP 1
.INDENT -4
    2.  An identifier followed by a subscript in parentheses; e.g.,
         B(7), BLK1(I), PTR(L+3).
.SKIP 1
.INDENT -4
    3.  Indirect addressing using the  _^; e.g., _^X, _^PTR(L+3), _^(B+3).
.SKIP 1
.LEFT MARGIN 5
    These three constitute the language element SW (storage word).
.SKIP 1
.INDENT 5
      1.C.4  Address Operator -@
.SKIP 1
    @ is a unary operator that operates on any storage word reference
    (SW) and returns the address of that word.  Note that the _^ and @
    cancel each other's effect.
.SKIP 1
    Example:
.SKIP 1
    If an array is declared as
.SKIP 1
    LOCAL B(3:50)
.SKIP 1
    then @B(3) is equal to B+3 (since B is the base address of the
    array).
.SKIP 1
.INDENT -5
1.D.  Labels
.SKIP 1
    A label may be an identifier followed by a colon, or, within the
    case statement (Section 3.C.2), a constant followed by a colon;
    that is,
.SKIP 1
    ID:
.BREAK
    or
.BREAK
    KON:## (only  within the case statement)
.SKIP 1
    A label may appear only at the beginning of a line. Since a line
    may be blank, a label may appear alone.  A line may have more than
    one label;  for example,
.SKIP 1
    L3: CPYRD:   statement
.SKIP 1
    Declaration statements, procedure heads and ends, and macro
    definition statements may not be labelled.
.SKIP 1
    Unlike variables and procedure heads, labels do not normally have
    to be declared.  For example, SIMPL can assume that an ID after
    the word GO identifies a label, since "GO variable" and "GO
    procedure" are illegal constructions.  In this case declaring the
    label would be redundant.  However, it is possible to use an ID
    where its function is not implicitly declared; for example, in the
    statement
.SKIP 1
    A__LAB
.SKIP 1
    which specifies that the value of LAB be stored in A, SIMPL can
    only  know what LAB identifies if an explicit declaration has been
    made. It may identify a label, enabling the user to branch
    indirectly by typing
.SKIP 1
    GO _^A
.SKIP 1
    In this case, then, LAB would have to be declared a label.
.SKIP 1
    To declare a label, type it in the LOCAL declaration statement, as
    follows:
.SKIP 1
    LOCAL ID:
.SKIP 1
    The KON: form of a label is declared within the case statement, the
    only statement in which it can appear.
.SKIP 1
.INDENT -5
1.E.  Arithmetic Expression
.SKIP 1
.INDENT 5
         1.E.1  Standard Mathematical Operators
.SKIP 1
         All arithmetic is fixed point.
.SKIP 1
         Binary operators:
.SKIP 1
.nofill.
.left margin 0
         +     Addition
         -     Subtraction
         *     Multiplication (machine dependency: low-order word of
                  the result)
         /     Division
         MOD   Modulo operator; if x and y are both positive, x MOD
               y yields the remainder of the division of x by y in
               the standard mathematical sense of modulus.  If x or
               y is not positive, the results are unpredictable.
         MAX   Maximum
         MIN   Minimum
.SKIP 1
         Unary operators:
.SKIP 1
         ABS   Absolute value
         -     Negative; 2's complement (unary minus)
.SKIP 1
.INDENT 5
         1.E.2  Bit Operators
.SKIP 1
         These operators perform the specified operations on the bits
         of their operands.
.SKIP 1
         Binary operators:
.SKIP 1
         BAND   Binary and                  BITS.PER.WORD
         BOR    Binary inclusive or         bits at
         BXOR   Binary exclusive or         a time
         BEQV   Binary equivalence
         SHL    Logical left shift
         SHR    Logical right shift
         ROTL   Circular left shift
         ROTR   Circular right shift
.SKIP 1
         Unary operator:
.SKIP 1
         BNOT  Binary not; 1's complement
.SKIP 1
.fill
.left margin 10
         The second operand of the shift operators specifies the shift
         count and must have a positive value.  For example, X SHL 3
         is calculated to be X shifted left 3 bit positions; the value
         of the expression X SHL -3 is not predictable.
.SKIP 1
    Note that the operators that are words as opposed to symbols, such
    as ABS and MOD, must be terminated by a space (or a
    non-alphanumeric character) since SIMPL allows identifiers to begin
    with these words.  For example, the strings ABSB and MOD2 are
    recognized as identifiers, not as operators and operands.
.SKIP 1
.INDENT 5
         1.E.3  Rules Governing Operands
.SKIP 1
         All of the above operators can operate
         on the SIMPL language element known as the primary, or PRIM
         (the complete definition of which is given in Section
         1.L).  Included in the PRIM category are a constant
         (KON), a storage word reference (SW), and a unary operator
         with its operand (such as @SW, ABS PRIM, -PRIM, and BNOT
         PRIM).
.SKIP 2
.LEFT MARGIN 5
.SKIP 1
.LEFT MARGIN 10
.NOFILL
Example:                           Illustrates:
.BREAK
HEX FF + ABS J                     KON + ABS SW
@X MOD Y                           @SW MOD SW
_^C(I)*-3                           SW*-KON
.SKIP 1
.FILL
.LEFT MARGIN 5
         Clearly then, the operands in these examples all qualify
         as primaries.
.SKIP 1
       The expression resulting from the use of any of the arithmetic
       operators may be enclosed in parentheses and operated on
       further; that is, the expression enclosed in parentheses also
       qualifies as a primary.  Thus,
.SKIP 1
       (HEX FF + ABS J)+2
.BREAK
       (@X MOD Y)*(_^C(I)*-3)
.SKIP 1
       are allowed as expressions.
.SKIP 1
.INDENT -5
1.E.4   Operator Precedence
.SKIP 1
       Several operators may appear in a single expression, as
       illustrated above or in the expression A+B/C.  The sequence of
       operations is given below.  Each numbered item in the list
       represents a level of precedence.  Several operators
       of the same precedence in a single expression are applied from
       left to right; for example, X-Y-Z is evaluated as (X-Y)-Z.
.SKIP 1
.LEFT MARGIN 10
.INDENT -3
       1.      An expression in parentheses. For example, the
               sequence of operations in the evaluation of X-Y-Z can be
               reversed by using parentheses as follows:  X-(Y-Z).
.SKIP 1
.INDENT -3
       2.      Any unary operations.
.SKIP 1
.INDENT -3
       3.      The shift operations:  SHL, SHR, ROTL, ROTR.
.SKIP 1
.INDENT -3
       4.      The other bitwise operations:  BAND, BOR, BXOR, BEQV.
               Thus, A BOR B SHL 4 is evaluated as A BOR (B SHL 4).
.SKIP 1
.INDENT -3
       5.      Multiplication, division and MOD.  Thus, X2 MOD 4/2 is
               calculated as (X2 MOD 4)/2 (i.e., left to right), and
               X*Y SHL 4 is equivalent to X*(Y SHL 4).
.SKIP 1
.INDENT -3
       6.      Addition and subtraction.  For example, A+B/C is
               calculated  as A+(B/C).
.SKIP 1
.INDENT -3
       7.      MAX and MIN.  Thus, A+B MAX C is evaluated as the 
               maximum of A+B and C.
.SKIP 1
.LEFT MARGIN 5
.INDENT -5
1.E.5    The  AE Classification
.SKIP 1
       An expression resulting from the use of the arithmetic
       operators is called an arithmetic expression, or AE.  As
       explained above, many of the arithmetic operators take primaries
       as their operands.  The AE classification also includes a
       primary alone, so that all of the following are classified as
       arithmetic expressions:
.SKIP 1
       16
.BREAK
       PTR
.BREAK
       _^ADR(K)
.BREAK
       BNOT S2
.BREAK
       A+B/C
.BREAK
       (A+3)
.SKIP 1
       The term AE as described here will be useful in defining other
       language elements of SIMPL.  For example, since a subscript may
       be any arithmetic expression, the general method of referencing
       an array element is
.SKIP 1
       ID(AE)
.SKIP 1
       Note that an AE may be parenthesized whenever desired;
       it will still qualify as an AE.
.SKIP 1
.INDENT -5
1.F  Constant Expression (KONEX)
.SKIP 1
     The previous section describes the AE, or arithmetic expression,
     classification.  A subset of this classification is the
     KONEX, or constant expression, which is an arithmetic
     expression having only KON type operands (excluding the string
     constant type of KON).  This classification can be used
     wherever it has been mentioned that a KON can be used.
     Thus, the general form of a LOCAL array declaration is
     LOCAL ID(KONEX:KONEX), and a label in a case statement can
     take the form KONEX:.
.SKIP 1
     This feature is valuable when used in conjunction with
     SIMPL macros, explained in Section 5.  For example, BUFSZ
     and NBUFS can be defined as the constants 200 and 5, so
     that the statement LOCAL A(BUFSZ*NBUFS) would be
     equivalent to LOCAL A(1000).
.SKIP 1
.INDENT -5     Relational Expression
.SKIP 1
       The relational operators, or RELOPs, are:
.SKIP 1
.NOFILL
       <       less than
       <=      less than or equal to
       =       equal to
       _#       not equal to
       >=      greater than or equal to
       >       greater than
.SKIP 1
.FILL
       Relational operators operate on arithmetic expressions (AEs)
       to form relational expressions, or RELs, which have logical
       values (true or false).  The different forms a relational
       expression may take are:
.SKIP 1
.LEFT MARGIN 10
.INDENT -5
       1.      AE1 RELOP AE2
.SKIP 1
.NOFILL
               Examples:
.SKIP 1
               A<3
               SYNTAB(IEW)=0
               HEX 17*X>=J+1 or (HEX 17*X)>=(J+1)
.SKIP 1
.FILL
               Note from the last example that parentheses around the
               arithmetic expressions are optional; the arithmetic
               operators have a higher precedence than the relational.
.SKIP 1
              The order of evaluation of the AE's in a relational
              expression is a machine dependency.  For example, in
              an expression such as _^PTR < _^INC PTR, in which INC
              PTR increments the value of PTR by 1, it is possible
              that PTR on the left will be evaluated after PTR has
              been incremented on the right.
.SKIP 1
.INDENT -5
       2.      AE1 RELOP AE2 RELOP AE3
.SKIP 1
               This is equivalent to an AND of the values of the
               expressions AE1 RELOP AE2 and AE2 RELOP AE3.
               For example, $A<=CHAR<=$Z is true if CHAR is both
               greater than or equal to $A and less than or equal to
               $Z.  If either or both of the expressions $A<=CHAR and
               CHAR<=$Z  are false, then $A<=CHAR<=$Z is false.
.SKIP 1
               Note that when this form of the relational expression
               is used, the evaluation of the expression is ended as
               soon as a false condition is encountered.  Thus, if the
               first condition to be checked, AE1 RELOP AE2, is false,
               the value of the whole expression is considered false
               and AE2 RELOP AE3 is not evaluated.
.SKIP 1
.INDENT -5
       3.      AE
.SKIP 1
               An AE alone may be used as a relational expression: it
               is true if its value is non-zero, false if its value
               is zero.
.SKIP 1
.INDENT -5
       4.      NOT REL
.SKIP 1
               Each of the above forms may be preceded by NOT to form
               a relational expression whose value is the logical NOT
                of the value of the expression modified.
.SKIP 1
               For example:
.SKIP 1
.NOFILL
NOT A<3          true if A>=3
                 false if A<3
.SKIP 1
NOT $A<=CHAR<=$Z  true if $A>CHAR or CHAR>$Z
                  false if $A<=CHAR  and CHAR<=$Z
.SKIP 1
NOT FLG           true if FLG=0
                  false if FLG_#0
.SKIP 1
.LEFT MARGIN 5
.INDENT -5
.FILL
1.H.     Logical Expression
.SKIP 1
       As explained above in the description of relational expressions,
       a REL may be preceded by the logical operator NOT to form a
       construction that is also classified as a REL.
.SKIP 1
       Relational expressions may be operated on by the logical
       operators AND and OR as well; that is,
.SKIP 1
       REL1 AND REL2#########Example:  A=6 AND NOT CD<3
.BREAK
       REL1 OR REL2###################  A=6 OR B>=BNOT J
.SKIP 1
       Parentheses around the RELs are optional, since the relational
       operators have a higher precedence than the logical.
.SKIP 1
       The expressions resulting from the use of the logical operators
       are called logical expressions and may themselves be
       parenthesized and operated on by NOT, AND, and OR.  For example:
.SKIP 1
.NOFILL
       NOT(CHAR<$A OR CHAR>$Z)
       (A<3 AND B<4) OR C=6
       (A=6 OR B>=BNOT J) AND (X<Y OR Z=1)
.SKIP 1
.FILL
       In fact, the logical expression (LE) classification includes
       all of the following:
.SKIP 1
.NOFILL
       x
       x [OR/AND] x
       x [OR/AND] x [OR/AND] x...   any number of ORs and ANDs
.SKIP 1
.FILL
       where x may be REL, (LE), or NOT(LE).  (Remember that REL
       includes the construction NOT REL.)
.SKIP 1
       It can be seen from this that several logical operators may
       appear in a single expression without benefit of parentheses
       to clearly indicate the precedence of operations.  The
       precedence after parenthesized expressions are evaluated is:
       first NOT, followed by AND,  and finally, OR.  Thus,
.SKIP 1
       A=6 AND NOT CD<3 OR C=6
.SKIP 1
       is evaluated as
.SKIP 1
       (A=6 AND (NOT CD<3)) OR C=6
.SKIP 1
       The evaluation of a logical expression is ended as soon as it
       is known whether the expression is true or false. For example,
       the expression
.SKIP 1
       b OR c OR d OR e
.SKIP 1
       is considered true as soon as an operand is encountered  that is
       true. Thus, if b is false and c is true, b OR c is true, as is
       therefore the entire expression; no further evaluation is made.
.SKIP 1
       This rule is especially significant when the expression
       includes a construction that has a side effect when evaluated,
       such as INC SW, which increments SW and is evaluated as the
       incremented value.  Consider the expression:
.SKIP 1
       INC K>10 AND INC J>1
.SKIP 1
       K will be incremented. If the incremented value is less than or
       equal to 10, INC K>10 is false, so that the entire expression
       is false; INC J>1 is never evaluated,
       which means that J is not incremented.
       However, if  INC K is greater than 10, SIMPL proceeds to
       evaluate INC J>1, so that J will be incremented in this case.
.SKIP 1
       When a logical expression is enclosed in brackets, it is given
       an arithmetic rather than a logical value: 1 if the LE is
       true and 0 if it is false.  For example,
.SKIP 1
       2+[B=3]
.BREAK
       2+[A=6 OR B>=BNOT J]
.SKIP 1
       Each of the above expressions equals 2 if the enclosed LE
       is false, and 3 if it is true.
.SKIP 1
       The construction [LE] is classified as a primary; thus it
       can be operated on by an arithmetic operator (as
       shown above) and can be used wherever it is stated in this
       document that a primary can be used.
.SKIP 1
.INDENT -5
1.I      Conditional Expression
.SKIP 1
       The conditional expression takes the form
.SKIP 1
       IF LE THEN AE1 ELSE AE2
.SKIP 1
       and is a primary that is evaluated as AE1 if  the logical
       expression LE is true, and AE2 if LE is false.
.SKIP 1
       Example 1:
.SKIP 1
.INDENT 5
               2* IF I=100 THEN J ELSE J+1
.SKIP 1
       is evaluated as 2*J if I=100, and 2*(J+1) if I _#100
.SKIP 1
       Example 2:
.SKIP 1
.INDENT 5
               PCP(IF A<3 THEN 1 ELSE 0)
.SKIP 1
       references the storage word PCP(1) if A<3, and PCP(0) if A>=3.
       Note that this could also have been written as
.SKIP 1
       PCP([A<3])
.SKIP 1
       Example 3:
.SKIP 1
.INDENT 5
               Y-(IF X>Z THEN A ELSE B)*2
.SKIP 1
       is evaluated as Y-A*2 if X>Z and Y-B*2 if X<=Z.
       Note that if the parentheses are omitted, the multiplication
       by 2 applies to B only.  The user should guard against errors of
        this nature when operating on conditional expressions.
.SKIP 1
.INDENT -5
1.J      Operators with Side Effects
.SKIP 1
       The SIMPL constructions using the operators described below
       are classified as primaries; each of them not only has an
       arithmetic value as do other primaries,
       but also has the side effect of taking some specific action.
       The NCHV and PCHV operators, also in this category, are
       explained in Section 1.K.
.SKIP 1
.INDENT 5
1.J.1    INC and DEC
.SKIP 1
       INC and DEC are unary operators that operate on any storage
       word reference (SW).  INC SW increments SW by 1 and returns
       the incremented value.  Similarly, DEC SW decrements SW by 1
       and returns the decremented value.  Note that the value of the
       storage word referenced is actually changed when either of these
       operators is used.  For example, if I=0, INC I sets I to 1 and
       returns the value 1, so that the next use of INC I would set I
       to  2 and return the value 2, and so on.
.SKIP 1
       The constructions INC SW and DEC SW are thus classified
       as primaries (PRIM); however, they also classify as statements
       in themselves, that increment and decrement the SW.
.SKIP 1
.INDENT 5
1.J.2    Assignment - __
.SKIP 1
       The assignment operation takes the form
.SKIP 1
       LP__AE
.SKIP 1
       and constitutes a primary which causes the value of the AE
       (arithmetic expression) to be stored in the left part (LP);
       the primary is evaluated as that value. For a complete list of
       legal left parts, refer to Section 3.B.1, the description of
       this construction when used as a statement.
.SKIP 1
       Example 1:
.SKIP 1
       P(I__SYM(LOC)-J)
.SKIP 1
       sets I to the value of the expression SYM(LOC)-J and
       references the array element P(I).
.SKIP 1
       Example 2:
.SKIP 1
       The relational expression
.SKIP 1
       $ <=CHAR__TTY
.SKIP 1
       causes a character to be read from the terminal, stored in
       CHAR and compared to a blank.
.SKIP 1
       Note that if the AE of LP__AE is itself an assignment, the
       construction appears as, for example,
.SKIP 1
       X__Y__I
.SKIP 1
       which assigns the value of I to both X and Y.  In general
       this extends to
.SKIP 1
       LP1__LP2__...LPn__AE
.SKIP 1
.INDENT 5
1.J.3    Deferred Assignment - <==
.SKIP 1
       The deferred assignment operator is used as follows:
.SKIP 1
       SW<==AE
.SKIP 1
       This construction is classified as a primary only.  It has
       the same side effect as regular assignment; that is, it stores
       the value of AE, an arithmetic expression, in SW, a storage
       word. However, this primary is evaluated not as the value of AE,
       but as the value of SW before the assignment is made.   In other
       words, the assignment is deferred until after the value of the
       primary is taken to  be SW.
.SKIP 1
       Example 1:
.SKIP 1
       The statements
.SKIP 1
       J__K
.BREAK
       K__T
.SKIP 1
       assign the value of K to J and then set K to the value of T.
       This can alternately be written as
.SKIP 1
       J__K<==T
.SKIP 1
       Example 2:
.SKIP 1
       The value of the expression
.SKIP 1
       BFSZ*LNK<==BLK(N)+1
.SKIP 1
       is BFSZ multiplied by whatever is the value of LNK immediately
       before the expression is encountered.  After the expression is
       so evaluated, the value of BLK(N)+1 is assigned to LNK.
.SKIP 1
       Note that not all the forms of the LP, the left part of a
       regular assignment, may appear to the left of the <==; only an
       SW is permitted.
.SKIP 1
.INDENT 5
1.J.4   Storage Word Modification
.SKIP 1
       The storage modification operation may be unary or 
       binary.  The unary operations are represented by
.SKIP 1
       SW -__
.BREAK
       SW ABS__
.BREAK
       SW BNOT__
.SKIP 1
       That is, a storage word followed by any of the unary
       arithmetic operators, followed by a back arrow.  The
       specified operation is performed on the SW, so that, for
      example, SW-__ is equivalent to SW__-SW (but produces more
       efficient code).
.SKIP 1
       The binary arithmetic operators, excluding the shift
       operators and MOD, may similarly be used for storage
       modification, as follows:
.SKIP 1
       SW+__AE
.SKIP 1
       In this case, SW is incremented by the value of AE.
.SKIP 1
       When used as primaries, these constructions are evaluated
       as the modified value of the storage word; however,
       they may also be used as statements in themselves.
.SKIP 1
.INDENT -5
1.K      Functions and Other Operators
.SKIP 1
.INDENT 5
1.K.1    Character and Half Word Handling
.SKIP 1
.INDENT 10
1.K.1.1       CH (and HW)
.SKIP 1
       CH is a function that takes two arithmetic expressions as
       arguments; that is,
.SKIP 1
       CH(AE1,AE2)
.SKIP 1
       It returns the value of the character (the size of which is a
       machine dependency) located AE2 character positions from the
       first character of the word addressed by AE1.  In other
       words,
.SKIP 1
       AE1 is the word address
.BREAK
       AE2 is the character displacement
.SKIP 1
       The second argument may be omitted, in which case it is assumed
       to be zero; CH(AE) is equivalent to CH(AE,0).
.SKIP 1
       Example  1 (machine dependent - Sigma 7):
.SKIP 1
       If the value of the simple variable A is HEX 12345678,
       CH(@A) equals HEX 12 and CH(@A,1) equals HEX 34.
.SKIP 1
       Example 2:
.SKIP 1
       The statement
.SKIP 1
       TS__'ABCDEF'
.SKIP 1
       stores the value of the string constant 'ABCDEF' in TS.
       Since this value is the address of the first word of the string,
       CH(TS) equals $A (whatever is the internal representation of the
       character A), and CH(TS,5) equals $F.
.SKIP 1
       The above examples use the CH construction as a primary whose
       value is the character addressed; however, it can also be used
       to set a character to a value.  For example, the assignment
.SKIP 1
       CH(TS,1)__$G
.SKIP 1
       stores the internal representation of the character G in the
       second character position of the string 'ABCDEF'.  Thus, the
       CH construction can also be used as an LP, the left part of
       an assignment.
.SKIP 1
       Half words are handled in a perfectly analogous way.  The
       function  is  HW rather than CH; AE2 is a half word displacement.
.SKIP 1
.INDENT 10
1.K.1.2       CHPT (and HWPT)
.SKIP 1
       CHPT is a function that takes the same type of arguments
       as the CH function, that is,
.SKIP 1
       CHPT(AE1,AE2)
.BREAK
          or
.BREAK
       CHPT(AE1) if AE2=0
.SKIP 1
       where AE1 is the word address and AE2 is the character
       displacement.
.SKIP 1
       The value returned is a character pointer which may then be used
       with the CHV, NCHV or PCHV  operator, described
       below. The actual  value need not be known and should not be
       altered by the user.
.SKIP 1
       The CHPT construction may also be used as an LP, the
       left part of an assignment.
.SKIP 1
       CHPT (SW1,SW2)__AE
.SKIP 1
       where the value of AE is a character pointer, assigns
       to SW1 the corresponding word address, and to SW2, the
       character displacement (a value between 0 and CHARS.PER.WORD-1).
.SKIP 1
       The HWPT function is perfectly analogous to CHPT,
       with half word rather than character displacement.
.SKIP 1
.INDENT 10
1.K.1.3   CHV (and HWV)
.SKIP 1
       CHV is a unary operator that operates on a storage
       word (SW) whose value is the character pointer that the
      CHPT function returns.
.SKIP 1
       CHV returns the character  to which its
       argument points; that is, if PTR=CHPT(AE1,AE2), then
       CHV PTR = CH(AE1,AE2).
.SKIP 1
       The CHV construction can be used in the same ways that CH can -
       as a PRIM or as an LP (the left part of an assignment).
       The CH description (above) includes an  explanation and
       illustration of this.
.SKIP 1
       HWV is the corresponding operator for half word handling.
.SKIP 1
.INDENT 10
1.K.1.4       NCHV (and NHWV)
.SKIP 1
       NCHV is a unary operator  that operates on a
       storage word  (SW) whose value is the character pointer that
       the CHPT function returns. NCHV SW increments SW so that it
       points to the next character and returns that character (the CHV
        of the incremented character pointer).
.SKIP 1
       The NCHV construction can be used in the same ways that the CHV
       construction can: as a primary (evaluated as the next character)
       or as the left part of an assignment (where it may be
       used to set the next character to a particular value).  For
       example, the statements
.SKIP 1
       TS__'ABCDEF'
.BREAK
       P__CHPT(TS,-1)
.SKIP 1
       store in P the pointer to the character preceding the first
       character of the string 'ABCDEF' (displacement of -1), so that
.LEFT MARGIN 10
.INDENT -5
.SKIP 1
.INDENT -5
       1.      Used as a primary, NCHV P would have the value
               $A; its next use would be evaluated as $B, and so on.
.SKIP 1
.INDENT -5
       2.      Used as an LP (the left part of an assignment),
               NCHV P would store the specified value in the first
               character position of the string; its next such use
               would store into the next position, and so on.
.SKIP 1
.LEFT MARGIN 5
       A third use of the NCHV SW construction is as a statement in
       itself, in which case it simply increments the pointer SW so
       that it points to the next character.
.SKIP 1
       For corresponding half word handling, use NHWV SW, where SW
       has the value of the half word pointer HWPT(AE1,AE2); it
       will increment SW and refer to the next half word.
.SKIP 1
.INDENT 10
1.K.1.5  PCHV (and PHWV)
.SKIP 1
      The constructions PCHV SW and PHWV SW are perfectly analogous
      to NCHV SW and NHWV SW; they decrement rather than increment
SW, to return the previous rather than the next character
      or half word.
.SKIP 1
.INDENT 5
1.K.2    Bit Field Manipulation
.SKIP 1
.INDENT 10
1.K.2.1    BYT Function
.SKIP 1
       BYT is a function that returns a byte of any size from any
       position in a word.  It takes three arguments:
.SKIP 1
       BYT(AE,AE1,AE2)
.SKIP 1
       The value of AE is the word, and
.SKIP 1
       AE1 is the field width (number of bits in the byte)
.BREAK
       AE2 is the bit displacement from the right (positive only)
.SKIP 1
       For example, if the following is a diagram of the variable A,
.SKIP 1
.NOFILL
.LEFT MARGIN 0
       HEX C           HEX 2A1          HEX 6BF2
       4 bits          12 bits          16 bits
.SKIP 1
.LEFT MARGIN 5
.FILL
       then BYT(A,4,28)=HEX C, BYT(A,12,16)=HEX 2A1, and
       BYT(A,16,0)=HEX 6BF2.
.SKIP 1
       The BYT construction may be  used as a primary, in which case
       it is evaluated as explained above, or it may be used to set a
       byte to a value (as an LP, or left part of an assignment).
       As an example of  the latter, consider the statement
.SKIP 1
       BYT(A,4,28)__HEX F
.SKIP 1
       which stores the value HEX F   in the byte referenced by BYT(A,4,
       28).  Note that when the BYT construction is used as a left
       part, its form  must be
.SKIP 1
       BYT(SW,AE1,AE2)
.SKIP 1
.INDENT 10
1.K.2.2    Word Packing and Unpacking
.SKIP 1
       The SIMPL construction
.SKIP 1
       [KONEX1,KONEX2,...,KONEXn]*[AE1,AE2,...,AEn]
.SKIP 1
       is a primary that returns the value of the word formed by
       packing the values of the listed arithmetic expressions into
       bit fields whose widths are specified by the listed constants.
       In other words, the first KONEX1 bits of the word will hold the
       value of AE1, the next KONEX2 bits, the value of AE2, and so on.
       The sum of the constants must be the total number of bits in
       a word.  Each AEi is evaluated in the usual way (i.e., as a
       word value); KONEX1 bits are taken from the right of the value,
       so that an AE value too large for its field will be truncated
       from the left.
.SKIP 1
       Example 1:
.SKIP 1
       [4,12,16]*[HEX C,X,_^PTR+1]
.SKIP 1
       where X=HEX 2A1  and _^PTR+1=HEX 6BF2, returns the value of the
       variable A as diagrammed in the BYT function description, above.
.SKIP 1
       The construction
.SKIP 1
       [KONEX1,KONEX2,...,KONEXn]*[LP1,LP2,...,LPn]
.SKIP 1
       can be used as an LP (left part of an assignment) to unpack bit
       fields from a word.  The value of the AE (of LP__AE) is divided
       into  n bit fields as specified by the listed constants, and LPi
       is  assigned the value in its corresponding field.  The sum of
       the constants must be BITS.PER.WORD.
.SKIP 1
       Example 2:
.SKIP 1
       Assume that the variable A has the value of the primary shown
       Example 1.  Then
.SKIP 1
       [4,12,16]*[X,Y,Z]__A
.SKIP 1
       assigns HEX C  to X, HEX 2A1  to Y, and HEX 6BF2  to Z.   
       Suppose that we want to assign the value of only the second 
       field of A:
.SKIP 1
       [4,12,16]*[,Y,]__A
.SKIP 1
       assigns HEX 2A1  to Y. An LP1 was not specified, so the first four
       bits of A were not assigned to a left part.  The third field
       was also ignored, since a third left part was not listed.
.SKIP 1
.INDENT 5
1.K.3 Terminal Input and Output - TTY
.SKIP 1
       TTY is a function with no arguments.  It may be used as a
       primary, in which case it accepts a character of input from
       the terminal and is evaluated as the internal representation
       of the character read.  For example:
.SKIP 1
       CHAR__TTY
.SKIP 1
       reads a character from the terminal and stores its value
       in CHAR.
.SKIP 1
       TTY may also be used as follows:
.SKIP 1
       TTY__AE
.SKIP 1
       where it is an LP, or left part of an assignment.  In this case,
       the character represented by the value of the AE is printed on
       the terminal.  Thus, if CHAR has the value $A,
.SKIP 1
       TTY__CHAR
.SKIP 1
       prints an A on the terminal.
.SKIP 1
.INDENT -5
1.L      Primary (PRIM)
.SKIP 1
       Several SIMPL constructions described in this section have been
       classified as primaries (PRIM), and it has been stated that
       certain operators can take only primaries as their operands.
.SKIP 1
       Listed here are all those constructions which constitute the
       PRIM category and examples of each.  This is an important
       classification, since it is from primaries that arithmetic
       expressions are built, and therefore relational and logical
       expressions as well.
.SKIP 1
.NOFILL
.LEFT MARGIN 0
      1.      Constant (KON) -  $A,17
      2.      Storage word reference (SW) - B, _^PTR(I)
      3.      Unary operator with its operand - ABS PRIM, -17, NCHV
              SW, @VAR(J1)
      4.      Function with its argument list, if any -
              CH(@A), BYT(Q,5,6), TTY
              Special word packing function -
                         [4,12,16]*[HEX C,X,_^PTR+1]
      5.      Arithmetic expression in parentheses - (I+3),
              (TRM BAND S(I))
      6.      Relational expression in square brackets (value of 1 if
              true, 0 if false) - [B=3], [NOT SYM(IW)<C]
      7.      Conditional expression - IF B<7 THEN J ELSE J+1
      8.      Assignment operation - I__SYM(LOC)-J
      9.      Deferred assignment - X<==Y
     10.      Storage Word Modification - B-__,CNT+__D+2
     11.      Procedure calls (explained in Section 4) -  CLR,
              TYP2(VAL)
.SKIP 1
.FILL
.LEFT MARGIN 5
       Note that a PRIM may be parenthesized
       whenever desired; it will still qualify as a PRIM.
.SKIP 1
.INDENT -5
1.M      Doubleword Manipulation
.SKIP 1
.INDENT 5
1.M.1    Doubleword Arithmetic Expression
.SKIP 1
      The doubleword arithmetic expression, or DAE, yields a
      doubleword value that can be assigned to a double
      left part (see below).  A simple form of the DAE is
.SKIP 1
      [AE1;AE2]
.SKIP 1
      where AE1 is the most significant, and AE2 the least
      signficant, word of the value.  For example,
.SKIP 1
      [-1;0]
.BREAK
      [A;X*Y]
.SKIP 1
      The operators used in forming doubleword arithmetic expressions
      are explained below.  Note the different operand types:
      DMUL, MODDIV and DIVMOD operate only on AEs (single word
      arithmetic expressions), while each of the remaining operators
      takes a DAE as its first argument.  All return doubleword values.
.SKIP 1
.NOFILL
Expression (DAE):                    Result:
.SKIP 1
AE1 DMUL AE2                  Doubleword product of AE1 and AE2
AE1 MODDIV AE2                Modulo division.  Most significant
                              word of result is remainder; least
                              significant is quotient.  (More
                              efficient than DIVMOD on certain
                              machines, such as Sigma 7)
AE1 DIVMOD AE2                Modulo division.  Most significant
                              word of result is quotient; least
                              significant is remainder.  (More
                              efficient than MODDIV on certain
                              machines, such as PDP-10)
.SKIP 1
DAE DMODDIV AE                Same result as MODDIV
DAE DDIVMOD AE                Same result as DIVMOD
DAE DSHL AE                   Doubleword logical left shift
DAE DSHR AE                   Doubleword logical right shift
DAE DROTL AE                  Doubleword circular left shift
DAE DROTR AE                  Doubleword circular right shift
.SKIP 1
.FILL
      Examples:
.SKIP 1
      CP DIVMOD EBUFSZ
.BREAK
      [X,Y] DMODDIV B
.BREAK
      C DMUL FPC DSHL 2
.SKIP 1
      To improve the readability of an expression such as the last
      example above, SIMPL allows any DAE to be parenthesized; thus
      C DMUL FPC DSHL 2 may also be typed as (C DMUL FPC) DSHL 2.
.SKIP 1
      The second operand of the shift operators (the AE) specifies the
      shift count and must have a positive value.  A negative shift
      count yields unpredictable results.
.SKIP 1
      Another form of the doubleword arithmetic expression is DOUBLE
      preceding a call to a procedure that terminates with a RETURN
      DAE statement.  In addition, DAEs can be passed as arguments
      to a procedure.  Additional details are included in the 
DESCRIPTION OF PROCEDURES, IN SECTION 4 OF THIS DOCUMENT.
.SKIP 1
.INDENT 5
1.M.2    Doubleword Assignment
.SKIP 1
      The doubleword assignment construction is
.SKIP 1
      DLP__DAE
.SKIP 1
      where DLP, the double left part, takes the form [LP1,LP2].
      The most significant word of DAE is assigned to LP1, and the
      least significant to LP2.  This construction classifies as a
      SIMPL statement or as a DAE.  Note that since the DAE of
      DLP __ DAE may be another doubleword assignment, whose DAE
      may be another assignment, and so on, the following
      construction is permitted:
.SKIP 1
      DLP1 __ DLP2 __ ...DLPn __ DAE
.SKIP 1
      with the result that DAE is assigned to each of the DLPs listed.
.SKIP 1
      Either LP of the DLP may be omitted, as in
.SKIP 1
      [LP;] __ DAE DMODDIV AE
.SKIP 1
      where the remainder of the division of DAE by AE is stored in
      the specified left part.  Similarly, [;LP] can be used as a
      DLP reference to the least significant word of a doubleword
      value (the quotient, in the above example).
.SKIP 1
      Note: Neither AE of the DAE form [AE1;AE2] may be omitted.
.SKIP 1
.PAGE
.CENTER
Section 2
.CENTER
Program Structure
.SKIP 1
.SKIP 1
.INDENT -5
2.A      Statement Delimiters
.SKIP 1
       A SIMPL program is made up of statements, usually separated by
       carriage returns.  Successive occurrences of a certain type of
       statement, known as the SST or short statement, may be separated
       by semicolons rather than carriage returns if desired. A
       subset of SIMPL statements will be classified in this
       document as SSTs; one of them is the assignment statement.
       Thus, the statements
.SKIP 1
       I__1
.BREAK
       A2__0
.BREAK
       NEWCHAR(J)__6
.SKIP 1
       may alternately be typed as:
.SKIP 1
       I__1; A2__0; NEWCHAR(J)__6
.SKIP 1
       A label may appear at the beginning of this line, before the
       statement I__1. But the other statements cannot be labelled,
       since a label may never appear in mid-line.
.SKIP 1
.INDENT -5
2.B      Compound Statements
.SKIP 1
       Several SIMPL statements may be compounded to form a single
       statement.
.SKIP 1
.INDENT 5
2.B.1    Compounding Short Statements
.SKIP 1
       Short statements may be compounded as follows:
.SKIP 1
       [SST1;SST2;...;SSTn]
.SKIP 1
       A label is not permitted within the brackets.
.SKIP 1
       This construction is itself classified as an SST.  Thus an
       example of the IF statement, whose simplest general form is
       IF LE THEN statement, is
.SKIP 1
IF#IK=0#THEN#[J__1;K(I)__I]
.BREAK
####LE##########SST
.SKIP 1
       Note that without the surrounding brackets, the semicolon
       serves merely to separate the SSTs as does the carriage return.
       Thus,
.SKIP 1
IF IK=0 THEN J__1;K(I)__I
.BREAK
#####SST###########SST
.SKIP 1
.INDENT 5
2.B.2    Compounding with DO...END
.SKIP 1
       Any SIMPL statements may be compounded through the use of the
       DO...END construction, which takes the form
.SKIP 1
.NOFILL
DO
statement1
statement2
 ...
statementN
END
.FILL
.SKIP 1
       Any of the statements compounded in this way may be labelled.
       The only restriction is that on labelling in general - a label
       must appear at the beginning of a line.  If the statements are
       SSTs (short statements), they may be separated by semicolons if
       desired, but a carriage return must follow DO and precede END.
.SKIP 1
       The DO...END construction itself is considered a single
       statement and can therefore be labelled, compounded, and 
whatever else can be done with a SIMPL statement.  Note, however,
       that it does not fall into the SST classification.
.SKIP 1
       Example:
.SKIP 1
.INDENT 5
               A compound statement may follow  the word THEN
       in an IF statement, so that the following is allowed:
.SKIP 1
       IF PL THEN DO
.BREAK
       J__1
.BREAK
       K__[PL>=1]
.BREAK
       I(K)__PL
.BREAK
       END
.SKIP 1
.INDENT -5
2.C      Line Continuation -_&
.SKIP 1
       An _& followed by a carriage return is ignored by SIMPL,
       thereby allowing program line continuation over any
       number of physical lines.  For example,
.SKIP 1
       L1: IF I=0 THEN J_0 ELSE _&
.BREAK
####       P(I)__RCDPNT(__I)
.SKIP 1
       is read by SIMPL exactly as  though it had been entered as
.SKIP 1
       L1:  IF I=0 THEN J__0 ELSE P(I)__RCDPNT(I)
.SKIP 1
       Note that _&  does not allow the user to have labels in mid-line;
       in the example here, a label cannot precede P(I) when the line
       is continued just as it cannot when line continuation is not
       used.
.SKIP 1
.INDENT -5
2.D      Comments -!
.SKIP 1
       Program comments may be entered using the exclamation point.
       To enter a comment at the end of a line, precede it by a !.
       Anything typed between the ! and the end of the line (except
       for another !; see below) will be ignored.  For example,
.SKIP 1
       DCTPTR__@DCTTBL(0)    !THE DICTIONARY PTR
.SKIP 1
       Any characters typed between exclamation points are ignored,
       thereby allowing comments to be entered in mid-line.
       For example,
.SKIP 1
       DCTPTR  !THE DICTIONARY PTR!   __@DCTTBL(0)
.SKIP 1
       The second exclamation point indicates the end of the comment.
.PAGE
.CENTER
Section 3
.CENTER
Statements of SIMPL
.SKIP 1
.INDENT -5
3.A      Declaration Statements
.SKIP 1
.INDENT 5
3.A.1    LOCAL Declaration
.SKIP 1
       The LOCAL statement is used to declare variables and
       procedures, which must always be declared, and labels,
       which may be declared.  Details on the declaration of any of
       these language elements may be found in the section describing
       that element.
.SKIP 1
       The general form of the LOCAL statement is
.SKIP 1
       LOCAL d1
.BREAK
###       or
.BREAK
       LOCAL d1,d2,...,dN
.SKIP 1
       where dI may be any of the declarations listed below.
.SKIP 1
.NOFILL
.LEFT MARGIN 0
       General form:            Element declared:
.SKIP 1
       ID                         Simple variable
       ID(KONEX1:KONEX2)          Array with subscript range
                                  KONEX1 to KONEX2
       ID(KONEX)                  Array with subscript range 1 to 
                                  KONEX
       ID()                       Floating array
       ID:                        Label
       %ID                        Procedure
.SKIP 1
.LEFT MARGIN 5
.FILL
       The declaration of a SIMPL language element must precede its
       first use.  Redeclaration (successive declarations using the
       same identifier) is not permitted.
.SKIP 1
.INDENT 5
3.A.2    TABLE Statement
.SKIP 1
      The TABLE statement may be used to declare read-only variables
      and arrays and fill them with specified constant values (which
      cannot be changed).  The constant values may be represented
      by the KONEX construction (such as BITS.PER.WORD/2)
      or by a string constant (such as "ABCDE").  The table
      statement takes the form:
.SKIP 1
      TABLE d1
.BREAK
##      or
.BREAK
      TABLE d1,d2,...,dN
.SKIP 1
      where dI may be any of the declarations explained below.
.SKIP 1
      To declare a simple variable ID and set it to the value of KONEX,
      enter the declaration
.SKIP 1
      ID[KONEX]
.SKIP 1
      in the TABLE statement; for example,
.SKIP 1
      TABLE X[0]
.SKIP 1
      To declare an array and set its elements to a list of values,
      first enter the array declaration as it would appear in any other
      declaration statement; that is, ID(KONEX1:KONEX2) or ID(KONEX). 
      Follow this immediately by a list of constants enclosed in
      brackets, for example,
.SKIP 1
      TABLE ABC(0:3)[1,2,3,0]
.SKIP 1
      If fewer constants are listed than array elements declared, SIMPL
      fills the rest of the constant list with zeroes.  Thus, in the
      above example, the closing bracket could follow the 3 in the
      constant list, and ABC(3) would still be initialized to 0. 
      Listing more constants than elements declared is considered an
      error by SIMPL.
.SKIP 1
      The constant list may also include the construction
      KONEX1(KONEX2), which indicates the repetition of the value
      KONEX2, KONEX1 times. For example,
.SKIP 1
      TABLE FCB(8)[3,0,0,0,0,0,0,1]
.SKIP 1
      can more easily be entered as follows:
.SKIP 1
      TABLE FCB(8)[3,6(0),1]
.SKIP 1
.INDENT 5
3.A.3    GLOBAL and FIND
.SKIP 1
      A number of SIMPL source files can be compiled separately and
      loaded together in such a way that they share procedures,
      variables and other language elements.  Two types of declaration
      statements must be used to accomplish this sharing of elements:
      GLOBAL and FIND, which take the same form as the LOCAL statement:
.SKIP 1
      GLOBAL list of declarations
.BREAK
      FIND list of declarations
.SKIP 1
      The GLOBAL statement must be used in place of LOCAL when the
      declared element is to be referenced from another file (that is,
      when it is to be shared).  Similarly, the FIND statement must be
      used to declare that an element is to be found elsewhere than
      in the current file; the SIMPL loader will search the other
      files entered for a GLOBAL statement declaring that element.
.SKIP 1
      It is not necessary, in FINDing an array, to enter the
      declaration exactly as it appears in the GLOBAL statement.  As
      long as there is a constant within the parentheses - to
      distinguish it from a floating array, whose declaration is ID() -
      the array will be found.  For example, an array declared as
.SKIP 1
      GLOBAL HEAD(0:100)
.SKIP 1
      may be found with
.SKIP 1
      FIND HEAD(0:100)
.SKIP 1
      or just
.SKIP 1
      FIND HEAD(0)
.SKIP 1
      or FIND HEAD followed by any parenthesized constant.
.SKIP 1
      TABLE statements may also be GLOBALly declared; for 
      example
.SKIP 1
      GLOBAL#TABLE#COMWD(4)['EDIT',#'LIST',#'RUN',#'ZZZZZ']
.SKIP 1
      which may be found by
.SKIP 1
      FIND COMWD(1)
.SKIP 1
.INDENT 5
3.A.4    BASE Statement
.SKIP 1
      When the subscript lower limit is not specified in a LOCAL, 
      GLOBAL or TABLE array declaration, the limit is normally assumed
      to be 1; that is,
.SKIP 1
      LOCAL ID(50)
.SKIP 1
      is equivalent to LOCAL ID(1:50).  However, the BASE statement may
      be used to change the default lower limit to a specified
      constant. 
.SKIP 1
      BASE KONEX
.SKIP 1
      sets the default lower limit to the value of KONEX.  For example,
      BASE 0 causes LOCAL ID(50) to be equivalent to LOCAL ID(0:50).
      The specified limit applies to all subsequent array declarations
      and may be changed at any time by another BASE statement.
.SKIP 1
.INDENT -5
3.B      Value Manipulation
.SKIP 1
       The statements described here are SSTs (short statements) that
       can be used to store values into a word, doubleword, half word,
       character, or bit field, exchange and move values,
        and increment or decrement the value of a storage word.
.SKIP 1
       Most of these constructions can also be used as primaries,
       as explained in Section 1.
.SKIP 1
.INDENT 5
3.B.1    Assignment Statement
.SKIP 1
       The assignment statement takes the form
.SKIP 1
       LP__AE
.SKIP 1
       and stores the value of the AE (an arithmetic expression) in
       whatever is specified by the LP, or left part.  The following
       is a complete list of legal left parts:
.SKIP 1
.NOFILL
 1.      Storage word reference (SW).
.SKIP 1
 2.      Character and half word references:
.SKIP 1
         CH(AE1,AE2)      HW(AE1,AE2)
         CHPT(SW1,SW2)    HWPT(SW1,SW2)
         CHV SW           HWV SW
         NCHV  SW         NHWV SW
         PCHV SW          PHWV SW
.SKIP 1
 3.      Bit field references:  BYT(SW,AE1,AE2) and
         [KONEX1,KONEX2,...,KONEXn]*[LP1,LP2,...,LPn]
.SKIP 1
 4.      TTY, designating terminal output; for example, TTY__$A
         prints out the  character A.
.SKIP 1
.FILL
       Since the assignment construction also qualifies as a primary,
       the AE of LP__AE may be another assignment, whose AE may be
       another assignment, and  so on, allowing the construction:
.SKIP 1
       LP1__LP2__...LPn__AE
.SKIP 1
3.B.2   Doubleword Assignment Statement
.SKIP 1
      The doubleword assignment statement takes the form
.SKIP 1
      DLP __ DAE
.SKIP 1
      and stores the value of DAE (a doubleword arithmetic expression)
      in the specified double left part, DLP, which may take any
      of the forms
.SKIP 1
      [LP1;LP2]
.BREAK
      [LP1;]
.BREAK
      [;LP2]
.SKIP 1
      LP1 is assigned to the most significant, and LP2 the least
      significant, word of the DAE.  Since the doubleword assignment is
      itself classified as a DAE, the following type of construction is
      permitted:
.SKIP 1
      DLP1__DLP2__...__DLPn__DAE
.SKIP 1
      where DAE is assigned to each of the DLPs listed.
.SKIP 1
      Further information on doubleword manipulation may be found in
      Section l.
.SKIP 1
.INDENT 5
3.B.3   Storage Word Modification
.SKIP 1
      The operation performed by a storage word modification
      statement may be unary or binary.
.SKIP 1
      An SW followed by any unary arithmetic operator, followed
      by a back arrow, causes the specified operation to be
      performed on the SW.  Thus, SW-__ negates the contents
      of SW.
.SKIP 1
      The binary arithmetic operators, excluding the shift
      operators and MOD, may similarly be used for storage
      modification, as follows:
.SKIP 1
      SW+__AE
.SKIP 1
      In this case, SW is incremented by the value of AE.
.SKIP 1
      This construction also qualifies as a primary; thus,
.BREAK
      A__B BNOT__
.SKIP 1
      leaves the 1's complement of B in both B and A.
.SKIP 1
.INDENT 5
3.B.4   Exchange Statement
.SKIP 1
       The exchange statement takes the form
.SKIP 1
       SW1<=>SW2
.SKIP 1
       and exchanges the values of the specified storage words.
.SKIP 1
.SKIP 1
.INDENT 5
3.B.5  MOVE Statement
.SKIP 1
       The MOVE statement may be used to move a number of values from
       one set of consecutive locations to another, as follows:
.SKIP 1
       MOVE AE1 FROM AE2 TO AE3
.SKIP 1
       AE1 specifies how many values are to be moved.
.BREAK
       AE2 is the address from which to move the first value.
.BREAK
       AE3 is the address to which to move the first value.
.SKIP 1
       For example,
.SKIP 1
.NOFILL
 LOCAL BLK(0:49),TEST(100)
 .
 .
 .
 MOVE 50 FROM BLK TO TEST+1
.SKIP 1
.FILL
       replaces TEST(1) by the value of BLK(0), TEST(2) by BLK(1), and
       so on, until 50 values have been moved.  This statement could
       also have been written as
.SKIP 1
       MOVE 50 FROM @BLK(0) TO @TEST(1)
.SKIP 1
       The MOVE statement may also be used to store a single specified
       value in a number of consecutive locations, as follows:
.SKIP 1
       MOVE AE1 FROM ALL AE2 TO AE3
.SKIP 1
       AE2 specifies the value to be moved.  For example,
.SKIP 1
       MOVE N FROM ALL 0 TO STP
.SKIP 1
       stores 0 in STP(0) to STP(N-1).
.SKIP 1
.INDENT 5
3.B.6    INC and DEC
.SKIP 1
       INC SW
.SKIP 1
       increments the specified storage word.
.SKIP 1
       DEC SW
.SKIP 1
       decrements the specified storage word.
.SKIP 1
.INDENT 5
3.B.7    NCHV and NHWV
.SKIP 1
       The NCHV statement takes the form
.SKIP 1
       NCHV  SW
.SKIP 1
       where SW is a storage word whose value is a character pointer
       (as returned by the CHPT function; see Section 1.K.1).  NCHV SW
       increments SW so that it points to the next character.
.SKIP 1
       NHWV SW
.SKIP 1
       is the corresponding statement for half word handling (a half
       word pointer is returned by the HWPT function).
.SKIP 1
.INDENT 5
3.B.8    PCHV and PHWV
.SKIP 1
      The statements PCHV SW and PHWV SW are perfectly analogous to
      NCHV SW and NHWV SW: they decrement rather than increment
      SW, to point to the previous rather than the next character
      or half word.
.SKIP 1
.INDENT -5
3.C      Transfer of Control
.SKIP 1
.INDENT 5
       3.C.1     Unconditional Transfer: GO
.SKIP 1
.LEFT MARGIN 10
               The GO statement may take either of the forms
.SKIP 1
               GO ID
.BREAK
##               or
.BREAK
               GO _^PRIM
.SKIP 1
               The first form transfers control to the statement
               labelled ID:.  When the second form is used, the loca-
               tion to which the transfer is made is the value of PRIM
               (a primary).  For example,
.SKIP 1
               LOCAL A,LAB1:,LAB2:
.BREAK
               A__LAB1    !NECESSITATES DECLARATION
.BREAK
               GO _^A     !SAME AS GO LAB1
.BREAK
               A__LAB2
.BREAK
               GO _^A     !SAME AS GO LAB2
.BREAK
               LAB1:  statement
.BREAK
               LAB2:  statement
.SKIP 1
               The variable A is assigned the value of LAB1, so that
               GO _^A branches to the statement labelled LAB1.  A is
               then reset to LAB2, changing the effect of GO _^A.  Note
               that the actual value of a label need not be known and
               should not be altered by the user. It is very unlikely,
               for example, that a label value plus 1 will address the
               next statement. When then might the  PRIM of GO _^PRIM be
               some arithmetic expression?  Consider the following
               case:  the user has stored in an array named W some data
                (which are machine instructions) that he wishes to
               branch to. Since W is evaluated as the  base address of
               the array, the statement
.SKIP 1
.LEFT MARGIN 0
.NOFILL
               GO _^(W+I)
.SKIP 1
.LEFT MARGIN 10
               will branch to the Ith entry in the array W.
.SKIP 1
.fill
       3.C.2     Case Statement
.SKIP 1
               The case statement takes the form
.SKIP 1
               DO AE OF KONEX1:KONEXn
.BREAK
               statements (some labelled with constants
               that lie in the range KONEX1 to KONEXn)
.BREAK
               END
.SKIP 1
               KONEX1:KONEXn indicates the range of expected values of
               the AE, an arithmetic expression; if the AE should have
               a value out of this range, the results will be
               unpredictable. SIMPL evaluates the AE and then searches
               within the case statement for a statement labelled with
               a KONEX whose value is the value of the AE.  If found,
               control transfers to that statement and execution
               continues  sequentially with the next statement until
               another  constant label or the END of the case statement
               is encountered. Unless a statement was executed that
               transferred control elsewhere, execution then continues
               with the statement following the case statement (that
               is, following the END).  If a statement labelled with
               the value of the AE is not found within the case
               statement, SIMPL does nothing but continue execution
               with the statement  following the END. KONEX1 need not
               be specified if its value is 1; that is,
.SKIP 1
               DO AE OF KONEX
.SKIP 1
               is equivalent to
.SKIP 1
               DO AE OF 1:KONEX
.SKIP 1
               Example:
.SKIP 1
.LEFT MARGIN 0
.NOFILL
               DO LOB OF 6
               2: 4:  5:  GO RTEST
               1:         LAB __ GEN(SUM)
                          INC GSUM
               3:         BRF(BLP) __ LAB
               6:         VAL __ 0
               END
.LEFT MARGIN 10
.FILL
.SKIP 1
               If the value of LOB is 2, 4, or 5, a transfer to the
               statement labelled RTEST is made. If LOB equals 1,
               the statements LAB__GEN(SUM) and INC GSUM are executed,
               followed by whatever follows the END.  Similarly, if
               LOB equals 3 or 6, the statement so labelled is executed
               and SIMPL proceeds with the statement after the END.
.SKIP 1
               Note that the above example illustrates multiple
               labels on a statement, a useful construction within
               the case statement.  Note also that the constant labels
               need not appear in any particular order.
.SKIP 1
               Constant labels are permitted nowhere else in a SIMPL
               program other than within a case statement.  The same
               constant label may appear within different case
               statements in the same program; each case statement
               searches only up to its own END for a constant label.
               Since  GO KONEX is not permitted by SIMPL,  a branch to
               any statement within the case statement implies that
               that statement must be labelled with an identifier.
               For example, suppose that the above example is to be
               extended so that if  LOB equals 1, an additional
               statement, VAL__0, is to be executed.  VAL__0 already
               appears within the case statement and can be branched to
               as follows:
.SKIP 1
.LEFT MARGIN 0
.NOFILL
               DO LOB OF 6
               2: 4: 5:  GO RTEST
               1:        LAB __ GEN(SUM)
                         INC GSUM; GO TP
               3:        BRF(BLP) __ LAB
               6: TP:    VAL __ 0
               END
.FILL
.LEFT MARGIN 10
.SKIP 1
               Here we have added GO TP (taking the option to separate
               it from INC GSUM with a semicolon rather than a
               carriage return).   The statement labelled 6: is now
               also labelled TP:.
.SKIP 1
               The user may branch from outside the case statement to
               anywhere within it; the subsequent transfer of control
               follows the same rules as when a "normal" entry into
               the case statement is made.  Thus, if the statement
               labelled 3: in the above example were changed to
.SKIP 1
               ABC: 3: BRF(BLP)__LAB
.SKIP 1
               then GO ABC appearing outside the case statement would
               transfer control here. BRF(BLP) would be set to LAB and
               execution would continue with the statement following
               the  END.
.SKIP 1
               Note that since a constant label terminates execution
               within the case statement (by transferring control to
               the statement following the END), SIMPL will not proceed
               from any line, even a blank line, to one that is
               labelled with a constant.  For example, if the case
               statement appears in part as:
.SKIP 1
.BREAK
               DO CHAR OF $A:$Z
.BREAK
               $Q:$R:$Z:
.BREAK
               $L:$M:$N: GO NTCH
.BREAK
               .
.BREAK
               .
.BREAK
               .
.BREAK
               END
.SKIP 1
               and CHAR equals $Q,$R or $Z, the effect will be the
               same as if those three labels were excluded from the
               case statement:  control would transfer to the
               statement after the  END.  Note that this is equivalent
               to omitting the labels $Q:, $R:, and $Z from within the
               case statement.
.SKIP 1
               SIMPL reacts  unpredictably if the value of the AE does
               not lie within the specified range. It is, however,
               simple enough to check for this condition by using the
               IF statement; for example,
.SKIP 1
.BREAK
               IF $A<=CHAR<=$Z THEN DO CHAR OF $A:$Z
.BREAK
               .
.BREAK
               .
.BREAK
               .
.BREAK
               END ELSE GO INP.ERR
.SKIP 1
               A complete description of the IF statement can be found
               in Section 3.D.2.
.SKIP 1
.INDENT -10
3.D      Conditional Statements
.SKIP 1
       3.D.1     The STMT Classification
.SKIP 1
               The discussion of conditional and loop control statements
will refer to the STMT classification.  This
               includes the following constructions:
.SKIP 1
.NOFILL
.LEFT MARGIN 0
               1.    Any SST, or short statement.  Remember that
                     this includes the construction [SST1;...;SSTn]
               2.    The IF statement, explained below.
               3.    The case statement.
               4.    A compound statement formed by using
                     DO...END.  Remember that any statements
                     can be compounded in this way.
.LEFT MARGIN 10
.FILL
.SKIP 1
       3.D.2     IF Statement
.SKIP 1
               The IF statement takes the form
.SKIP 1
               IF LE THEN STMT1
.BREAK
####               or
.BREAK
               IF LE THEN STMT1 ELSE STMT2
.SKIP 1
               If the logical expression (LE) specified is
               true, STMT1 is executed; unless STMT1 caused
               a transfer of control to another statement, execution
               continues with the statement following  the IF
               statement.  If the LE specified is false and an
               ELSE  clause is not provided, SIMPL continues  with the
               next statement.  If the LE is false and an ELSE
               clause is provided, STMT2 is executed; execution 
continues with the next statement unless STMT2 transferred
               control elsewhere.
.SKIP 1
               Example 1:
.SKIP 1
               IF X=ASYM THEN X__0
.BREAK
               Y__0
.SKIP 1
               If X equals ASYM, X is set to 0; if X does not equal
               ASYM, its value is unchanged.  In either case, Y
               is then set to 0,
.SKIP 1
               Example 2:
.SKIP 1
               IF I>A OR J<B  THEN [LC(I)__1;R(TR)__TR] ELSE GO L2
.SKIP 1
               If the expression I>A OR J<B is true, the compound
               statement [LC(I)__1;R(TR)__TR] is executed, followed by
               the statement after the IF statement.  If the expression
               is false, control transfers to the statement labelled
               L2.
.SKIP 1
               An IF statement qualifies as an SST (short statement)
               only if all of the statements contained within it are
               SSTs.
.SKIP 1
               Since the THEN or ELSE clause may contain another IF
               statement, which may contain another IF statement, and
               so on, constructions like the following are possible:
.SKIP 1
               IF ... THEN ... ELSE IF ... THEN ...
.BREAK
               IF ... THEN ... ELSE IF ... THEN ... ELSE ...
.BREAK
               IF ... THEN IF ... THEN ... ELSE ...
.SKIP 1
               Note that the ELSE clause in the last example is part
               of the second IF statement; it matches the THEN clause
               closest to it.  The rule for matching THEN and ELSE
               clauses is similar to the rule for matching parentheses:
               they are matched from the inside out.
.SKIP 1
               Suppose that a construction is desired like the
               last one listed above but with the ELSE matching the
               outer THEN.  Two solutions are possible:
.SKIP 1
               IF ... THEN IF ... THEN ... ELSE NULL ELSE ...
.SKIP 1
               A dummy ELSE clause (NULL does
               nothing ) is inserted to match the inner THEN so that
               the other ELSE clause matches the outer THEN.  Or,
               if the statement following the inner THEN is an SST,
               it may be enclosed in square brackets (a "compound
               statement" only one statement long); that is,
.SKIP 1
               IF ... THEN [IF ... THEN ...]ELSE ...
.SKIP 1
       3.D.3     EIF Statement
.SKIP 1
               The EIF statement takes  the form
.SKIP 1
.NOFILL
.LEFT MARGIN 0
               EIF LE1 THEN STMT1
               ORIF LE2 THEN STMT2
               .
               .
               .
               ORIF LEn THEN STMTn
                FIF LE THEN STMT
                   or
                ELSE STMT
.FILL
.LEFT MARGIN 10
.SKIP 1
               EIF and FIF are mnemonics for "Either IF" and
               "Finally IF".  The construction must begin with EIF.
               The ORIF lines are optional, and the ending line
               must begin with either FIF or ELSE.
.SKIP 1
               The first logical expression is evaluated.  If it is
               true, STMT1 is executed; unless STMT1 caused a transfer
               of control to another statement, execution continues
               with the statement following the EIF statement.  If the
               LE is false, SIMPL proceeds to the next line and
               evaluates its LE.  When a true  logical expression is
               found, the corresponding statement is executed and
               SIMPL transfers out of the EIF statement.  A false
               LE causes the next line to be examined.  If all
               the LEs listed are false, and the construction
               ends with an ELSE line, the ELSE statement is executed.
               If there is no ELSE line (that is, if the ending line
               begins with FIF), SIMPL will naturally fall through
               to the statement following the  EIF statement if all
               the LEs are false.
.SKIP 1
               Example:
.SKIP 1
.NOFILL
.LEFT MARGIN 0
               EIF TYPE(I2)_#2 THEN GO ERR
               ORIF WTP=4 THEN [APPL__ABQ;J__0]
               ORIF WTP=5 THEN BPPL__ABQ
               ELSE GO CHK
.FILL
.LEFT MARGIN 10
.SKIP 1
               The effect of this construction can be achieved
               through nested IF statements, but the latter is
               easily liable to appear complicated and difficult to
               read, especially if any of the statements contained
               within is long (such as a  DO...END compounded
               statement).  The EIF statement is provided as a more
               convenient method  of testing a number of conditions.
.SKIP 1
               Any of the lines in the EIF statement may be labelled.
               The user may branch from outside the EIF statement to
               anywhere within it; SIMPL does not disallow entering
               the construction at an ORIF (or FIF) rather than at the
               EIF.
.SKIP 1
               Note that the EIF statement falls into neither the SST
               nor the STMT classification.
.SKIP 1
.INDENT -10
3.E      Loop Control Statements
.SKIP 1
       3.E.1     WHILE Statement
.SKIP 1
              The WHILE statement takes the form
.SKIP 1
              WHILE LE THEN STMT
.SKIP 1
              The statement following THEN is executed and reexecuted
              as long as the logical expression (LE) specified is
              true.  As soon as the LE becomes false, execution
              continues with the statement following the WHILE
              statement.  For example,
.SKIP 1
              SUM__I__0
.BREAK
              WHILE INC I<=N THEN SUM__SUM+A(I)
.SKIP 1
              After these two statements are executed, SUM contains
              the sum of array elements A(1) through A(N), and I is
              equal to N+1.
.SKIP 1
              A WHILE statement qualifies as an SST (short statement)
              only if the statement following THEN is an SST.
.SKIP 1
       3.E.2  REPEAT Statement
.SKIP 1
               The REPEAT statement takes the form
.SKIP 1
               REPEAT AE STMT
.SKIP 1
               It executes the statement STMT as many times as
               specified by the value of the arithmetic expression AE. 
               For example, 
.SKIP 1
               REPEAT LLEN TTY__NCHV PTR
.SKIP 1
               The AE is evaluated only once, when the statement
is first encountered; any change made to
               its value during loop execution has no effect 
               on the REPEAT count.
.SKIP 1
               The REPEAT statement qualifies as an SST (short
               statement) if the statement to be repeated is an SST.
.SKIP 1
       3.E.3  FOR Statement
.SKIP 1
               The simplest form of the FOR statement is
.SKIP 1
               FOR SW__ITPT STMT
.SKIP 1
               where ITPT, the iteration part, specifies those values
               of the storage word SW for which the statement STMT (the
               FOR "loop") is to be executed.  For example,
.SKIP 1
               SUM__0
.BREAK
               FOR I__1 TO 10 SUM__SUM+A(I)
.SKIP 1
               stores in SUM the sum of array elements A(1) to A(10).
.SKIP 1
               The general form of the ITPT is
.SKIP 1
               AE1 BY AE2 TO AE3
.BREAK
#######               or
.BREAK
               AE1 TO AE3 BY AE2
.SKIP 1
               AE1 is an arithmetic expression specifying the initial
               value to be assigned to SW.  AE2 specifies the value by
               which SW is incremented as long as the result is less
               than or equal to the limit A3.
.SKIP 1
               The FOR loop is executed each time the SW is assigned
               a value.  The value of the SW upon falling through the
               FOR statement is the last value of SW for which the loop
               is executed.  If the loop is never executed, as in FOR
               I__N TO 1 BY -1 where N equals 0, the value of the SW
               immediately thereafter is unpredictable.
.SKIP 1
               As shown in the example above, the BY clause may be
               omitted; BY 1 is assumed.  The TO clause may also be
               omitted, in which case some other means of exiting the
               FOR loop must be provided.  For example,
.SKIP 1
               FOR J__1 BY 1 DO
.BREAK
               .
.BREAK
               .
.BREAK
               IF CHAR__TTY=CAR.RET THEN GO OUT
.BREAK
               .
.BREAK
               END
.BREAK
.SKIP 1
               The exit from this loop is made when a carriage return
               character is read from the terminal.
.SKIP 1
               If both the BY and the TO clauses are omitted, so
               that the ITPT consists of only an AE, the STMT following
               the ITPT is executed once, with the value of AE assigned
               to SW.  This is a useful feature in view of the fact
               that several ITPTs may be specified in a single FOR
               statement, separated by commas; in general,
.SKIP 1
               FOR SW__ITPT1,ITPT2,...,ITPTn STMT
.SKIP 1
               For example,
.SKIP 1
               FOR RPC__1,6,8 TO 11,12 TO 18 BY 2 DO
.BREAK
               .
.BREAK
               .
.BREAK
               END
.BREAK
.SKIP 1
               The values of RPC for which the DO...END STMT is
               executed are 1,#6,#8,#9,#10,#11,#12,#14,#16 and 18.  Note that
               the commas completely separate the ITPTs, so that, for
               example, the BY 2 above refers only to 12 TO 18, and has
               no effect on any other ITPTs listed.
.SKIP 1
               When a number of ITPTs are listed in this way, the first
               ITPT is evaluated and the loop executed for the
               specified value(s), then the second ITPT is evaluated,
               and so on, so that if a FOR statement begins
.SKIP 1
               FOR I__1 TO J, M TO N ...
.SKIP 1
               M and N are not evaluated until after the loop is
               executed for I__1 TO J.
.SKIP 1
               The AEs in an ITPT are evaluated once, when the ITPT is
               first encountered.  Thus if a variable is included in
               any of the AEs, changing the value of that variable
               within the FOR loop does not affect the increment or
               limit originally calculated for the ITPT.
.SKIP 1
               Similarly, if the value of the SW is changed within
               the FOR loop, the change will not be recognized in
               the test for when to terminate loop execution. 
.SKIP 1
               Suppose that the SW in a FOR statement takes either of
               the forms ID(AE) or _^(AE), where AE includes a variable.
               Changing that variable within the  FOR loop does not
               result in the modification of a different SW.  The
               address of the SW is noted by SIMPL when the FOR
               statement is first encountered and is not affected by
               any changes within the loop. 
.SKIP 1
               If a transfer out of a FOR loop is made by means of a
               GO statement, a subsequent GO back into the loop can be
               made without disturbing the progress of the SW test and
               modification, just as though the statements executed
               outside the loop had instead been located within it. 
               However, the result of transferring into a FOR loop from
               outside the loop is unpredictable in any other case,
               that is, if the last transfer out of the loop was made
               after the usual completion of the iterations on the SW
               rather than by means of a GO statement. The FOR statement
               qualifies as an SST (short statement) if the statement
               comprising the FOR loop is an SST. 
.SKIP 1
       3.E.4  LOOP Statement
.SKIP 1
              The LOOP statement takes the form
.SKIP 1
              LOOP STMT
.SKIP 1
              where STMT may contain the special short statements
.SKIP 1
              WHILE LE
.BREAK
              REPEAT AE
.BREAK
              FOR SW __ ITPT1,...,ITPTn
.SKIP 1
              which may be used for exit from the loop and do
              not have any meaning outside of the LOOP statement.
              If these statements are not used, the LOOP STMT
              is simply executed over and over again; some explicit
              means of exit must be encoded in the loop.  For example,
.SKIP 1
              LOOP NCHV LPTR __ GETCH(CHKLN)
.SKIP 1
              where GETCH is a procedure that reads a character
              from the terminal and branches to CHKLN when a
              CARRET is encountered.
.SKIP 1
              The WHILE LE statement specifies that loop execution
              is to be repeated as long as the specified logical
              expression is true.  As soon as the LE becomes false,
              execution continues with the statement following
              the LOOP statement.  For example
.SKIP 1
              LOOP [GETLINE; WHILE CHAR __ NCHV LPTR=CARRET]
.SKIP 1
              Where GETLINE is a procedure that reads a line of
              input and stores a corresponding pointer in LPTR.
              The effect of this statement is to ignore all lines
              that begin with the character CARRET.
.SKIP 1
              The above example qualifies as a short statement (SST)
              because the statement comprising the loop is an SST;
              the statement
.SKIP 1
.NOFILL
.LEFT MARGIN 0
              LOOP DO
                 NXADR     ! SETS TERMCH
                 IF TERMCH=$: THEN ERR(BCLN)
                 LSTCNT__LSTCNT+LTBL(I)
                 WHILE TERMCH_#$,
                 IF INC CNT=RNGMX THEN ERR(LNG)
              END
.FILL
.LEFT MARGIN 10
.SKIP 1
              is not an SST.
.SKIP 1
              The REPEAT AE statement may be used to specify that
              the LOOP code be executed AE times, after which 
              control passes to the statement following the LOOP
              STMT.  In other words, the loop exit takes place
              the AE+1st time that the REPEAT AE statement is
              encountered.  As in the regular REPEAT statement,
              the AE is evaluated only once.
.SKIP 1
               Similarly, the FOR SW __ ITPT1,...,ITPTn  statement may be
               used to specify values of SW for which the LOOP code is to
               be executed, following the same rules as those of the
               regular FOR statement.
.SKIP 1
               Note that if the special WHILE, REPEAT, or FOR statement
               is the first statement of the LOOP STMT, the resulting
               construction is equivalent to the regular WHILE, REPEAT
               or FOR statement.
.SKIP 1
.INDENT -10
3.F.     Miscellaneous Statements
.LEFT MARGIN 5
.SKIP 1
.INDENT 5
       3.F.1     NULL
.SKIP 1
               NULL
.SKIP 1
               has exactly that effect.
.SKIP 1
.INDENT 5
       3.F.2     HALT
.SKIP 1
               HALT
.SKIP 1
               traps (attempts to execute an illegal instruction).
.SKIP 1
.INDENT 5
       3.F.3     EXIT
.SKIP 1
               EXIT
.SKIP 1
               provides a normal return to the supervisory level.
.PAGE
.center
Section 4
.center
SIMPL Procedures
.SKIP 1
.SKIP 1
.INDENT -5
4.A.     Procedure Declaration
.SKIP 1
       Procedures are named with identifiers and must always be
       declared.  To declare a procedure, precede its identifier
       with a % in the LOCAL statement; that is,
.SKIP 1
       LOCAL %ID
.SKIP 1
.INDENT -5
4.B.     Procedure Definition
.SKIP 1
       A procedure is defined as follows:
.SKIP 1
       %ID(par1, par2,...,parN)
.BREAK
        statements constituting the procedure
.BREAK
       END ID
.SKIP 1
       where parI is a parameter  declaration (explained in Section
       4.E). There may be no parameters, in which case the procedure
       head is simply
.SKIP 1
       %ID
.SKIP 1
       The identifier typed in the procedure head must appear
       in that procedure's END statement.
       Procedure definitions must be placed after the main program
       with no statements between the end of one procedure and the
       head of the next.
.SKIP 1
.SKIP 1
.INDENT -5
4.C.     Parameters and Arguments
.SKIP 1
       Input to a procedure is made through parameters.  Procedures
       that do not require input from the calling program have no
       parameters.  The maximum allowable number of parameters is
       a machine dependency (14 on the Sigma 7 or PDP-10).  When
       a procedure is called, arithmetic expressions (the "arguments"
       to the procedure) are listed in place of the parameters; the
       first parameter is given the value of the first argument listed,
       the second parameter is assigned the second argument, and so
       on.  It is left up to the user to check that the number of
       arguments at calling time matches the number of parameters
       specified in the procedure definition; SIMPL does not make this
       check.  If fewer arguments are given than parameters specified,
       the extra parameters will be assigned values unknown to the
       user. If more arguments are given than parameters specified, the
       extra arguments will be ignored.
.SKIP 1
       Parameters are local to the procedure definition; a parameter
       may have the same identifier as another language element outside
       the procedure without conflict (that is, without affecting
       the outside element in any way).
.SKIP 1
.INDENT -5
4.D.     Procedure Call and RETURN
.SKIP 1
       To call a procedure, type its identifier followed by
       the list of arguments, if any; that is,
.SKIP 1
       ID
        or
       ID(arg1, arg2,...,argN)
.SKIP 1
       Note: Section 4.H describes entry into a procedure at some point
             other than its beginning.
.SKIP 1
       A procedure may be used  either as a statement or as a function
       reference. A procedure call that appears alone classifies as
       a statement (an SST); the statements contained within the
       procedure are executed until a
.SKIP 1
       RETURN
.SKIP 1
       statement is encountered, at which time control transfers to the
       statement following the procedure call.
.SKIP 1
       A procedure may be used as a function reference (that is,
       to return a value).  A procedure call of this type, classified
       as a primary, causes SIMPL to execute the statements of
       the procedure until a statement of the form
.SKIP 1
       RETURN AE
.SKIP 1
       is encountered, at which time the value of the AE, an
       arithmetic expression, is returned.
.SKIP 1
       For example, suppose a program includes the statement
.SKIP 1
       CLEAR; S__2*SQR(A)+I
.SKIP 1
       and the procedure definitions
.SKIP 1
.NOFILL
.LEFT MARGIN 0
       %CLEAR
       .
       .
       RETURN
       END CLEAR
       %SQR(X)
       .
       .
       RETURN Z
       END SQR
.FILL
.LEFT MARGIN 5
.SKIP 1
       The procedure CLEAR is used as a statement.  SQR is used as a
       primary in an arithmetic expression; the value of Z as evaluated
       in the procedure is returned.
.SKIP 1
       If a procedure is used as a statement but the return is made
       through a RETURN AE statement, the value returned will
       simply be ignored.  If a procedure is used as a primary but the
       return is made through a simple RETURN statement, some
       unpredictable value will be returned.
.SKIP 1
       In addition to RETURN AE, SIMPL allows the construction
       RETURN DAE, where DAE is a doubleword arithmetic expression.
       When RETURN DAE is used, the procedure call must be preceded
       by the word DOUBLE; this construction (DOUBLE procedure call)
       is classified as a DAE.
.SKIP 1
       Note that a RETURN is automatically generated if SIMPL
       falls through to the end of a procedure because a RETURN
       or transfer out of the procedure was accidentally omitted.
.SKIP 1
       When a procedure is called, its return point is saved,
       specifying where control is to be transferred when a RETURN is
       encountered within that procedure.  Any previous value of
       the return point is destroyed.
.SKIP 1
       Once a transfer out of a procedure through a RETURN statement
       has been made, SIMPL assumes the user is temporarily
       finished with that procedure, and no longer retains the value
       of the return point.  However, if a transfer out of a procedure
       is made by some means other than a RETURN, the value of the
       return point is saved.  Thus, if a transfer back into the
       procedure is made (by some means other than a call, which would
        destroy the previous return point value), a subsequent RETURN
       in the procedure would return to the originally calculated
       return point, as though a transfer out of the procedure had not
       been made.  This implies that procedures can be nested with
       the expected results.  For example,
.SKIP 1
.NOFILL
.LEFT MARGIN 0
       %SVAL(X)
       .
       .
       TPRT
       !RETURNS HERE FROM TPRT
       .
       .
       RETURN
       %TPRT
       .
       .
       RETURN
       END TPRT
       END SVAL
.LEFT MARGIN 5
.FILL
.SKIP 1
       If SVAL is called from the main program, its return point will
       be saved throughout the call to and return from the
       procedure TPRT, so that the RETURN in SVAL will transfer
       control to the statement following the call to SVAL in the main
       program.
.SKIP 1
       The limit to the depth of nesting is 10 procedures (an
       implementation dependency).  The general rule for the
       placement of procedure definitions is that they must be located
       at the very end of the block containing them, be it the main
       program or another procedure.
.SKIP 1
       Another method of transferring out of a procedure other than
       the normal RETURN is by means of the GO statement.
       As explained above, the user may GO out of a procedure and GO
       back into it without losing the value of the return point, as
       long as the procedure is not called again before the
       transfer back into it is made (since that would destroy the
       original return point value).
.SKIP 1
       The information given here about the return point value tells us
       what to expect when a transfer into a procedure is made
       through a GO statement rather than a call, and a RETURN is
       encountered in the procedure.  The subsequent action taken by
       SIMPL depends on how the last transfer out of that procedure was
       made. If it was made by some means other than a RETURN
       statement, the return point value saved the last time the
       procedure was called will have been retained.  If the last
       transfer out of the procedure was made through a RETURN
       statement, however, the return point value will not have been
       retained and the action taken by SIMPL will be unpredictable.
.SKIP 1
       Finally, the above information implies that procedures are
       not recursive.
.SKIP 1
.INDENT -5
4.E.     Parameter Declarations
.SKIP 1
       A parameter may represent a variable used within the procedure,
       or an address, a label, or another procedure name.  The type of
       language element that the parameter represents is specified in
       the procedure head, in the parameter declaration list.  This
       list tells SIMPL how to interpret the argument passed, but the
       type of the argument is not checked against the type of the
       parameter.  It is left up to the user to check, for example,
       that an address is passed as an argument when the corresponding
       parameter has been declared an address.
.SKIP 1
       A parameter may be declared in any of the following ways:
.SKIP 1
.LEFT MARGIN 0
.NOFILL
       1.      ID              Simple variable value
       2.      @ID             Address
       3.      ID()            Base address of array ID
       4.      ID:             Label
       5.      %ID             Procedure name
.FILL
.LEFT MARGIN 5
.SKIP 1
       These declarations are explained in detail below.  Note their
       similarity to the declarations that can be made in the LOCAL
       statement.  The parameter declarations do not include
       ID(KONEX:KONEX);  the LOCAL declarations do not include @ID. 
       The two types of  declarations also differ in that the LOCAL
       statement declares  but does not allocate space for labels and
       procedure names. Each parameter declaration does allocate a word
       in which the value of the argument passed will be stored.
.SKIP 1
.SKIP 1
       1.  ID
.SKIP 1
       The value of the argument passed is stored in the simple
       variable  ID. Note that if the argument is a variable, any
       changes made to ID within the procedure will not affect that
       variable.  SIMPL merely passes its value.  For example, suppose
       the procedure
.SKIP 1
       %CUBE(X)
.BREAK
       X__X*X*X; RETURN X
.BREAK
       END CUBE
.SKIP 1
       is called as a primary, as CUBE(VAR). The value returned
       will be VAR cubed.  The variable VAR will not be affected.
.SKIP 1
       SIMPL also allows the values of DAEs (doubleword arithmetic
       expressions) to be passed through parameters.  When this is
       done, two identifiers must be specified in the parameter list,
       one for each word of the value.  For example, the procedure
       SPROC might be headed
.SKIP 1
       %SPROC(X,Y)
.SKIP 1
       and called with SPROC(DAE), where DAE is any form of doubleword
       arithmetic expression.
.SKIP 1
.SKIP 1
       2.  @ID
.SKIP 1
       The parameter represents  an address; SIMPL therefore 
automatically performs indirect addressing on ID whenever it is
       used within the procedure. For example, a statement of the form
       LP__ID would assign to LP the value stored in the word addressed
       by the value passed through ID.  The user may specify at
       calling time a variable whose value will be changed from within
       the procedure, by passing the address of that variable (rather
       than just its value as in 1. above). For example, suppose the
       procedure
.SKIP 1
       %CUBE(@X)
.BREAK
       X__X*X*X
.BREAK
       END CUBE
.SKIP 1
       is called as a statement, as CUBE(@VAR).  First indirection is
       performed on each X in the expression X*X*X so that
       the value of VAR is cubed.  Then indirection is  applied
       to the left part, storing this value into VAR.
.SKIP 1
       Note that this can be achieved less conveniently by passing
       the address without declaring it to be one, and then explicitly
       applying indirection:
.SKIP 1
       %CUBE(XADR)
.BREAK
       _^XADR__^XADR*_^XADR*_^XADR
.BREAK
       END CUBE
.SKIP 1
       3.  ID()
.SKIP 1
       This declaration is similar to 2. above in that it declares
       ID to be an address and it can be used to affect variables
       outside the procedure. The argument passed becomes the base
       address of the array ID.  For example, suppose that the main
       program includes the array B(3:50) and a procedure headed
.SKIP 1
       %PROC(Z())
.SKIP 1
       Since B represents the base address of the array B(3:50),
       calling this procedure by PROC(B) causes  Z(i) to
       reference B(i); calling PROC(@B(2)) causes Z(i) to
       reference B(i+2).  Z(i) appearing as a left part (of an
       assignment statement)  would store into the corresponding
       element of the array B.
.SKIP 1
       4.  ID:
.SKIP 1
       The parameter represents a label.  For example, if the
       procedure headed
.SKIP 1
       %FCHK(L:)
.SKIP 1
       is called as FCHK(EOF) the statement GO L in the procedure
       will transfer to the line labelled EOF.  Note that (as usual
       when a label is used in an arithmetic expression) EOF must
       be a declared label in the calling program in order to be
       passed as an argument.
.SKIP 1
       5.  %ID
.SKIP 1
       A procedure name will be passed.  For example, if the
       procedure headed
.SKIP 1
       %PR(%SPR)
.SKIP 1
       is called as PR(%VAL), then a call to SPR within the
       procedure effectively calls the procedure VAL.
       Note that it is the procedure name that is passed, not its
       value. The  latter occurs when the argument is an actual
       procedure call (used as a function reference, it qualifies as a
       primary, which is a form of AE).  For example, calling the
       procedure headed %CUBE(X) by CUBE(ABC), where ABC is a procedure
       with no parameters, causes  SIMPL to pass the value returned
       from ABC as the argument to CUBE.
.SKIP 1
.INDENT -5
4.F.     Scope of Names
.SKIP 1
       As noted above, parameters are local to the procedure
       definition.  To use other identifiers locally within a
       procedure, declare them in a LOCAL statement within the
       procedure; as usual, a label normally does not
       require declaration.  If SIMPL encounters in a procedure an
       identifier that is not local to that procedure, it searches
       for the declaration of that element in the outer block,
       which will be the main program or (in the case of nested
       procedures) another procedure.  If the identifier is not
       found there, either in a LOCAL  statement or parameter list or
       as a label, the next outer block is searched, and so on.  Some
       type of declaration or use of the identifier as a label must
       appear in the procedure or in one of its outer blocks.
.SKIP 1
.NOFILL
.LEFT MARGIN 0
       Example 1:
.SKIP 1
               LOCAL %A,%B,%C,I,Z
               Z__I__0
               .
               .
               %A(X)
               INC Z
               .
               .
               %B
               LOCAL I
               IF Z>100 THEN I__X+1
               .
               .
               END B
               %C
               LOCAL J
               IF I=100 THEN J__-1
               .
               .
               END C
               END A
.FILL
.LEFT MARGIN 5
.SKIP 1
.SKIP 1
       Here the outer block for procedure A is the main program and
       the outer block for B and C is A.  Procedure C declares a local
       J; since the identifier J is not declared elsewhere, J is
       undefined anywhere except within C.   Procedure C references I,
       which is  declared neither in C nor in its outer block A, but in
       the next outer block, the main program; thus it refers to the
       global I.  The I referenced in the procedure B is local to B;
       the X referenced there is declared in the outer block A, as a
       parameter.  The Z in procedures A and B is declared in the main
       program.
.SKIP 1
.NOFILL
.LEFT MARGIN 0
       Example 2:
.SKIP 1
               LOCAL %D,%E
               .
               .
               EOF:
               .
               .
               %D
               .
               .
               GO EOF
               .
               .
               END D
               %E
               .
               .
               GO ERR
               .
               .
               ERR:
               .
               .
               END E
.FILL
.LEFT MARGIN 5
.SKIP 1
       When GO EOF is encountered within the procedure D, SIMPL
       finds the label EOF not in D, but in the outer block (the main
       program).  Suppose that D also includes the statement GO ERR,
       where ERR is a label in the procedure E, as illustrated.
       When this statement is encountered in D, SIMPL first
       finds that ERR is not local to D, so it looks in the outer
       block, the main program, and doesn't find any information
       on ERR there,  either:  end of search, and error!  The way to
       satisfy this search is to declare ERR in the main program.  Once
       SIMPL is so satisfied that the label ERR does exist, it will
       transfer to that label, which happens to be located in
       the procedure E.
.SKIP 1
.NOFILL
.LEFT MARGIN 0
       Example 3:
.SKIP 1
               LOCAL %IOPK,%OPEN,%CLOSE
               .
               .
               %IOPK
               LOCAL %FNLU,BUF(2000)
               %FNLU
               .
               .
               END FNLU
               %OPEN
               .
               .
               END OPEN
               %CLOSE
               .
               .
               END CLOSE
               END IOPK
.FILL
.LEFT MARGIN 5
.SKIP 1
.SKIP 1
       The procedures OPEN and CLOSE can be called from the main
       program, and they in turn can call the procedure FNLU,
       since  FNLU is declared and defined in their outer block,
       the procedure IOPK.  Since it is local to IOPK, however,
       FNLU cannot be called directly from the main program.
       Similarly, the array BUF cannot be referenced outside of
       IOPK.  This procedure entry and data protection is a useful
       feature of SIMPL. In this example, the OPEN and CLOSE procedures
might perform certain checks before calling FNLU, and
       the programmer might wish to protect himself (or someone
       else adding code to the main program) from accessing FNLU
       until these different checks have been made.  He is also
       protecting the array BUF from accidental manipulation outside
       of IOPK, at the same time allowing it to be
       manipulated freely in all of the procedures in his package.
.SKIP 1
       Example 4:
.SKIP 1
       Continuing from Example 3, suppose that the programmer wishes to
       remove the restrictions on entry into the procedure FNLU, that
       is, to allow it to be called directly from the main program.
       If FNLU were still declared local to  IOPK, the definition
       of the procedure FNLU would not extend beyond IOPK; thus
       another %FNLU declaration outside of IOPK would find no
       corresponding procedure  definition.  The correct solution,
       of course, is to declare FNLU only in the main program.
.SKIP 1
       If for some reason the programmer wished to retain the FNLU
       procedure local to IOPK but have a different FNLU that
       could be accessed from the main program, he could simply declare
        and define an FNLU in both places, that is
.SKIP 1
.NOFILL
.LEFT MARGIN 0
               LOCAL %IOPK,%OPEN,%CLOSE,%FNLU
               .
               .
               %FNLU
               .
               .
               END FNLU
               %IOPK
               (remainder as in Example 3)
               .
               .
               .
.FILL
.LEFT MARGIN 5
.SKIP 1
.SKIP 1
.INDENT -5
4.G.     Procedure Entry Points
.SKIP 1
       A procedure may have several entry points, each with its own
       name and parameter list.  Procedure entry points are declared in
       the same way as procedures, that is,
.SKIP 1
       LOCAL %ID
.SKIP 1
       and called in the same way -- by typing the identifier followed
       by the list of arguments, if any.  An entry point is indicated
       within a procedure by two % signs preceding the identifier
       rather than a single %.  For example,
.SKIP 1
.NOFILL
.LEFT MARGIN 0
       %EXUC(X,Y,Z:,N)
       .
       .
       %%EXU(X,Y,Z:)
       .
       .
       RETURN
       END EXUC
.FILL
.LEFT MARGIN 5
.SKIP 1
       EXU identifies an entry point to the procedure EXUC.  Since EXUC
       requires an argument that EXU does not, EXU has one less
       parameter. When EXUC is called, SIMPL proceeds in the usual
       manner, falling through the entry point EXU (assuming it has not
       encountered a RETURN before that point).  When EXU is called,
       execution begins at the indicated point within the procedure,
       and the subsequent RETURN transfers control as usual, to the
       statement following the call. 
.SKIP 1
       The following rules apply to entry point parameter lists:
.SKIP 1
.LEFT MARGIN 10
.INDENT -3
       1.  Any identifiers in an entry point parameter list that also
           appear in previous parameter lists within the procedure must
           be declared the same way as in the previous lists; they
           identify the same elements.  Thus, in the above example, X
           and Y can only be declared as simple variables, and Z as a
           label, in EXU's parameter list.
.SKIP 1
.INDENT -3
       2.  New parameters can be introduced at an entry point,
           declaring those identifiers locally at that point.  In our
           example here, the EXU entry point might be changed to
           %%EXU(X,Y,Z:,A). If this is done and an outer-declared A is
           referenced before this point, then falling through to here
           would cause a declaration conflict.
.SKIP 1
           A nested procedure can reference all the identifiers local
           to the procedure in which it is nested.  If the outer
           procedure has multiple entry points, this includes not only
           those identifiers declared at the procedure head (in the
           parameter list or a declaration statement), but also those
           in the entry point parameter lists.
.SKIP 1
           Consider the following example:
.SKIP 1
.NOFILL
.LEFT MARGIN 0
           LOCAL %RW,%R,%W
           %RW
           LOCAL %GETCHK
           %%R(FN)
           IF TYP(FN)=DIR THEN GETCHK
           .
           .
           RETURN
           %%W(FN,VAL)
           .
           .
           GETCHK
           .
           RETURN
           %GETCHK
           IF ID(BUF(FN))=0 THEN DO
           .
           .
           RETURN
           END GETCHK
           END RW
.FILL
.LEFT MARGIN 10
.SKIP 1
           Here the procedure RW has three entry points (RW, R and W)
           and one nested procedure, GETCHK.  When GETCHK is
           called from R or W, it can reference FN since FN is local
           to RW.  Suppose that procedure entry points were not
           available to the user, and R and W were therefore separate
           procedures.  In order to create a situation in which both
           R and W could call GETCHK and GETCHK could reference FN,
           GETCHK would have to be a separate procedure local to
           neither (declared in an outer block), having FN as a
           parameter. 
.SKIP 1
.LEFT MARGIN 5
.INDENT -5
4.H.     RETURN as an SW
.SKIP 1
       We have discussed  at length when SIMPL does or does not save
       the value of the return point of a procedure.  That
       value is, in fact, saved in a storage word that can be
       referenced by the identifier RETURN.
.SKIP 1
       Since the former value of the return point is destroyed when
       a procedure is called, SIMPL procedures are not recursive.
       Using RETURN as an SW, however, the user can effectively have
       recursion by saving and later restoring the proper return
       point values.
.SKIP 1
       The value of RETURN should not be manipulated by the user, but
       only stored back into a RETURN, either into another procedure's
       RETURN or back into itself.  As an example of the latter, consider
.SKIP 1
.NOFILL
.LEFT MARGIN 0
       %PROC
       .
       .
       SAVE __ RETURN; DOIT; RETURN __ SAVE
       .
       .
       RETURN
       %%DOIT
       .
       .

       END PROC
.FILL
.LEFT MARGIN 5
.SKIP 1
       DOIT is an entry point within PROC and is usually called from
       outside PROC.  If called from within PROC, DOIT destroys PROC's
       RETURN value.  To circumvent this, the value of RETURN is saved
       before calling DOIT and restored after the return from DOIT has
       been made.
.SKIP 1
.PAGE
.CENTER
Section 5
.CENTER
SIMPL Macros
.SKIP 1
.INDENT -5
5.A.     MACRO Definition
.SKIP 1
       To define a macro that consists of a single SIMPL line or
       part of a line, use the DEF statement, as follows:
.SKIP 1
       DEF ID(ID1,ID2,...,IDn) AS definition
.SKIP 1
       ID is the macro identifier.  The parenthesized IDs
       are the parameters used in the macro definition; they are
       local to that definition.  The maximum number of parameters
       a macro may have is an implementation dependency.  A macro
       may have no parameters, in which case the DEF statement
       takes the form
.SKIP 1
       DEF ID AS definition
.SKIP 1
       The definition is terminated by a carriage return and can
       be anything that may be typed in a SIMPL program: a statement
       or part of one, several short statements separated by
       semicolons, an operator, any SIMPL language elements.  The
       characters between AS and the carriage return are not checked
       for syntax when the DEF statement is encountered.
.SKIP 1
       Examples:
.SKIP 1
.nofill
       DEF ADD AS +
       DEF SUM(X,Y) AS X+Y
       DEF FIX(X1,X2,X3) AS __X1-ABS(X2/X3)
       DEF CNT AS IF INC X>100 THEN GO ERR; DEC Z
.fill
.SKIP 1
       A macro may also consist of more than a single line.  A
       multiple-line macro is defined in the same way as a single-
       line macro -- with a DEF statement -- except that BY replaces
       the word AS, and the definition is terminated not by a car-
       riage return but by ENDM ID, where ID is the macro
       identifier.  For example,
.SKIP 1
.nofill
       DEF RCGO(X) BY
       IF DEC ECNT(X)>=0 THEN RETURN CPTR(X)
       IF WLAB(FN)_#W.ERR THEN WLAB(FN)_WSET
       GO _^RLAB(FN)_RADDR(X)
       ENDM RCGO
.fill
.SKIP 1
       The definition consists of all the characters between BY and
       ENDM, including all carriage returns (four in this example).
       A carriage return is not required after BY or before ENDM.  
       For example, if the above DEF statement were modified 
       so that it ended with
.SKIP 1
       GO _^RLAB(FN)_ ENDM RCGO
.SKIP 1
       it could be used as in
.SKIP 1
       RCGO(N) RINIT
.SKIP 1
       A macro definition must precede the first use of the macro and
       is local to the procedure in which it appears.  The DEF
       statement may not be labelled.
.SKIP 1
.INDENT -5
5.B.   Macro Expansion
.SKIP 1
       To use a macro, type its identifier followed by the list of
       arguments, if any; that is,
.SKIP 1
       ID
.BREAK
       or
.BREAK
       ID(arg1,arg2,...,argN)
.SKIP 1
       When SIMPL encounters the use of a macro having no parameters
       it simply substitutes the text of the macro definition in
       place of the macro identifier.  For example, if ADD and SUB
       are defined as
.SKIP 1
       DEF ADD AS +
.BREAK
       DEF SUB AS -
.BREAK
       DEF NBLKS AS 15
.SKIP 1
       then
.SKIP 1
       D__A ADD B SUB NBLKS
.SKIP 1
       is equivalent to
.SKIP 1
       D__A + B - 15
.SKIP 1
.SKIP 1
       If a macro has parameters, arguments must be specified when the
       macro is used.  Each argument replaces its corresponding
       parameter in the macro definition.  The argument can be, like
       the definition itself, absolutely anything that may be typed into
a SIMPL program.  When SIMPL encounters the use of a macro
       having parameters, it substitutes the arguments for  the
       parameters in the macro definition and generates the result
       in place of the macro call.  For example, suppose
       a macro is defined as
.SKIP 1
       DEF SUM(X,Y) AS X+Y
.SKIP 1
       and used in the statement
.SKIP 1
       Z__SUM(A,B)
.SKIP 1
       A+B is generated in place of SUM(A,B), so that this statement
becomes Z__A+B.  Only after a macro is expanded in this
       way  is the statement syntactically examined by SIMPL.  Thus,
       if the macro SUM is used as follows
.SKIP 1
       P__Q*SUM(R,S)
.SKIP 1
       then this statement becomes
.SKIP 1
       P__Q*R+S
.SKIP 1
       where the product of Q and R is added to S.  If SUM were
       instead defined as
.SKIP 1
       DEF SUM(X,Y) AS (X+Y)
.SKIP 1
       the statement P__Q*SUM(R,S) would become
.SKIP 1
       P__Q*(R+S)
.SKIP 1
       Remember that anything is legal as an argument.  The macro
       SUM as just defined could be used as SUM(F1__F,2*Z) in which
       case it would expand to (F1__F+2*Z), a primary assigning
       F+2*Z to F1.
.SKIP 1
       Commas normally separate macro arguments; however, SIMPL
       matches parentheses within an argument list and does not
       consider commas between them to be separators.  For example,
.SKIP 1
       X __SUM(A(J),PRC(2,C))
.SKIP 1
       is a permitted use of the macro SUM; the second argument
       is PRC(2,C).  Anywhere except within parentheses, commas
       do separate arguments, so that, for example, ([18,18]*[A,B],Q)
       is interpreted by SIMPL as listing four arguments.
.SKIP 1
       Macros are expanded from left to right; thus, the user
       cannot define the macros
.SKIP 1
       DEF BAR AS (A,B)
.break
       DEF FOO(X,Y) AS X+Y/2
.SKIP 1
       and use them together as FOO BAR, expecting BAR to be expanded
       first as the arguments to FOO.  Instead, the construction FOO
       BAR would in this case be illegal.
.SKIP 1
       A procedure may redefine a macro originally defined on some
       outer level.
.SKIP 1
.NOFILL
.LEFT MARGIN 0
       %PROG
       LOCAL %P1, %P2
       DEF NBUFS AS 30
       .                        !CANNOT BE REDEF'D HERE
       .
       %P1
       DEF NBUFS AS 12
       .
       .
       END P1
       %P2
       .
       .
.FILL
.LEFT MARGIN 5
.SKIP 1
       The second DEF statement above redefines NBUFS so that it is 12
       rather than 30 within the procedure P1.  NBUFS resumes its
       definition as 30 within the procedure P2.
.SKIP 1
       As noted by the comment in this example, redefinition is not
       permitted within a single program level.
.SKIP 1
       Two additional examples of the use of macros are given below.
.SKIP 1
       Consider the user who needs to reference the four bit index
       field of a number of storage words, a field displaced 17 bits
       from the right.  He could define a macro
.SKIP 1
       DEF XFLD(X) AS BYT(X,4,17)
.SKIP 1
       and enjoy the convenience of entering such statements as
.SKIP 1
       I__XFLD(WD1)
.break
       XFLD(C)__0
.SKIP 1
       The following macro
.SKIP 1
       DEF DO.FOR(A,B,C) BY
.BREAK
       A__B__1
.BREAK
       WHILE INC A<=C THEN ENDM DO.FOR
.SKIP 1
       might be used as in
.SKIP 1
       SUM__0
.BREAK
       DO.FOR (I,1,10) SUM__SUM+X(I)
.SKIP 1
       where it sums array elements X(1) through X(10).
.SKIP 1
.INDENT -5
5.C.     UNDEF Statement
.SKIP 1
       A procedure can undefine a macro defined on some outer level,
       through the use of the statement
.SKIP 1
       UNDEF ID
.SKIP 1
       where ID is the macro identifier.  This would be used, for
       example, in a procedure containing a local variable ID which
       also identifies a macro in the main program.  The effect of
       the UNDEF statement is local to the procedure in which the
       statement appears.  An UNDEF statement may not be labelled.
.SKIP 1
       The same rule applies for undefinition as for redefinition:
       it is not permitted within a single program level.
.SKIP 1
.SKIP 1
.PAGE
.SKIP 1
.SKIP 1
.nofill
.nojustify
                         APPENDIX A
.SKIP 1
                 IMPLEMENTATION DEPENDENCIES
.SKIP 1
.SKIP 1
.; NO JUSTIFICATION
.LEFT MARGIN 0
.RIGHT MARGIN 70
This section lists any SIMPL features which have not been implemented
on particular machines, and describes additional features (not
previously documented in this manual) which are machine-exclusive
and are not planned for implementation on any other systems.
.SKIP 1
.INDENT -5
A.1   XDS 940
.SKIP 1
      None of the following has been implemented in the 940
      version of SIMPL:
.SKIP 1
         Half word handling
         CHPT(SW1,SW2) as an LP (left part)
         MOVE AE1 FROM AE2 TO AE3
         Storage word modification (B-__; CNT+__D+2)
         GLOBAL TABLE statements
         FOR or LOOP statements
.SKIP 1
      On the 940, MAX and MIN are functions rather than arithmetic
      operators.  They may take two or more arguments; that is,
.SKIP 1
      MAX(AE1,AE2,...,AEn)
      MIN(AE1,AE2,...,AEn)
.SKIP 1
      System calls may be made on the 940 through use of the back
      slash, as follows:
.SKIP 1
      _\ID1(SW,AE1,AE2,AE3,GO ID)
.SKIP 1
      _\BRS KON (AE1,AE2,AE3,GO ID)
.SKIP 1
      where
.SKIP 1
      ID1 is any opcode that the assembler will recognize (such
          as a SYSPOP or machine instruction).
.SKIP 1
      SW  contains the contents of the address field.
.SKIP 1
      KON is the BRS number.
.SKIP 1
      AE1,AE2, and AE3 specify the contents of the A, B and
          X registers.  These arguments are optional but are order-
          dependent when specified.  For example, if only the contents
          of the A and X registers need to be specified, the corres-
          ponding arguments must be separated by two commas; the 
          second comma terminates a null B register argument.
.SKIP 1
      GO ID must be specified when the return from the call may be
          either skip or non-skip.  ID is the label to be branched to
          if the non-skip return is taken.  GO ID may be preceded by
          any number of register arguments (including none); the only
          restriction is that it be the last argument listed.
.SKIP 1
      These constructions may stand alone as statements or qualify
      as AE's which are evaluated as the contents of the A register
      after the call is made (or, if preceded by DOUBLE, the contents
      of the A and B registers).
.SKIP 1
      Examples:
.SKIP 1
      _\BRS 113
      _\STB(BREG)
      _\BIO(FILE,COUNT,,WHERE,GO SHORT)
      _\BRS48 (MSP(LIT),GO NO)
.SKIP 1
.INDENT -5
A.2   PDP-10
.SKIP 1
      Two back slashes will be used to precede any SIMPL
      constructions that are exclusive to the PDP-10.
.SKIP 1
      The statement
.SKIP 1
      _\_\->ID
.SKIP 1
      where ID is a label previously allocated on the same
      program level, specifies ID to be the starting location of the
      program.
.SKIP 1
  ~<~