!**COPYRIGHT 1972,1973, DIGITAL EQUIPMENT CORPORATION MAYNARD MA**
!AUTHOR NORMA ABEL

GLOBAL BIND PNROV=103;		!VERSION DATE : 5/23/73

EXTERNAL CNSTCMB,COPRIX,SPKABA,C1H,C1L,C2H,C2L,CMBEQLARGS,BLCMB,ARCMB,
TBLSEARCH,PREV,LOOPNO,OLDHEAD,NXTTMP;
FORWARD RDCTMP;
EXTERNAL RDCCT;		!COUNTER FOR CREATION OF UNIQUE NAMES
				!FOR REDUCTION IN STRENGTH TEMPORARIES
OWN DEFKEP,DEFKEEPER;		!USED IN LOKDEF AND FOLDER
OWN PAPPY;		!PARENT POINTER
EXTERNAL INDVAR,CORMAN;
EXTERNAL TOP,BOTTOM,LEND,LENTRY,PM1,PM3;
MAP PEXPRNODE PM1:PM3:TOP:LENTRY:LEND;
FORWARD REDUCE;
FORWARD FIX1NN,FIX2NN;
OWN RDCCNT,RDCLST[9];


ROUTINE SETPNOT(DAD,SON)=
BEGIN
	!THIS ROUTINE EXAMINES DAD, DETERMINES IF SON IS
	!ARG1 OR ARG 2 AND 
	!COMPLEMENT THE NOTFLG OF THE CORRECT ARGUMENT
	MAP BASE DAD:SON;

	!IF ITS A STATEMENT LOOK AT ASSIGNEMNT
	!LOGICAL AND ARITHMETIC IF.
	IF .DAD[OPRCLS] EQL STATEMENT THEN
	BEGIN
		IF .DAD[SRCID] EQL ASGNID THEN
		BEGIN
			IF .SON EQL .DAD[RHEXP] THEN
				DAD[A2NOTFLG]_NOT .DAD[A2NOTFLG]
			ELSE
				DAD[A1NOTFLG]_NOT .DAD[A1NOTFLG];
		END ELSE
		IF .DAD[SRCID] EQL IFLID THEN
			DAD[A1NOTFLG]_NOT .DAD[A1NOTFLG]
		ELSE
		IF .DAD[SRCID] EQL IFAID THEN
			DAD[A1NOTFLG]_NOT .DAD[A1NOTFLG];
	END ELSE
	!IT MUST BE AN EXPRESSION. IT HAD BETTER NOT BE
	!A FUNCTION CALL (FNCALL)

	IF .DAD[ARG1PTR] EQL .SON THEN
		DAD[A1NOTFLG]_NOT .DAD[A1NOTFLG]
	ELSE
		DAD[A2NOTFLG]_NOT .DAD[A2NOTFLG];
END;

ROUTINE SETPNEG(DAD,SON)=
BEGIN
	EXTERNAL SETNEG;
	!THIS ROUTINE EXAMINES DAD, DETERMINES IF SON IS
	!ARG1 OR ARG 2 AND CALLS THE ROUTINE SETNEG TO
	!COMPLEMENT THE NEGFLG OF THE CORRECT ARGUMENT
	MAP BASE DAD:SON;

	!IF ITS A STATEMENT LOOK AT ASSIGNEMNT
	!LOGICAL AND ARITHMETIC IF.
	IF .DAD[OPRCLS] EQL STATEMENT THEN
	BEGIN
		IF .DAD[SRCID] EQL ASGNID THEN
		BEGIN
			IF .SON EQL .DAD[RHEXP] THEN
				DAD[A2NEGFLG]_NOT .DAD[A2NEGFLG]
			ELSE
				DAD[A1NEGFLG]_NOT .DAD[A1NEGFLG];
		END ELSE
		IF .DAD[SRCID] EQL IFLID THEN
			DAD[A1NEGFLG]_NOT .DAD[A1NEGFLG]
		ELSE
		IF .DAD[SRCID] EQL IFAID THEN
			DAD[A1NEGFLG]_NOT .DAD[A1NEGFLG];
	END ELSE
	!IT MUST BE AN EXPRESSION. IT HAD BETTER NOT BE
	!A FUNCTION CALL (FNCALL)

	IF .DAD[ARG1PTR] EQL .SON THEN
		SETNEG(.DAD,1)
	ELSE
		SETNEG(.DAD,0);
END;
ROUTINE FOLDER(EXPR)=
BEGIN
	EXTERNAL SETPVAL;
	EXTERNAL KSPECB,DNEGCNST,KILFBA,KILFBR;
	EXTERNAL RELSKOPT,BLSKOPT,ARSKOPT,KTYCM,KTYPCB;
	EXTERNAL NEGFLG,NOTFLG;
	MAP PEXPRNODE EXPR;
	!A CONSTANT HAS JUST PROPAGATED
	!CHECK FOR AND PERFORM ANY POSSIBLE FOLDING ETC
	!
	LOCAL PHAZ2 OPEXPR:T;

	OPEXPR_.EXPR;		!SAVE TO SEE IF IT REALLY FOLDED
	!FOR SOME OPERATIONS WE MAY BE HERE BECAUSE ONE OF
	!TWO CONSTANTS IN THE EXPRESSION FOLDED, BUT NOT
	!NECESSARILY BOTH. THIS IS OK, IN THAT ROUTINES LIKE RELSKOPT,
	!ARSKOPT, ETC HANDLE THIS SITUATION. IT IS NOT
	!ACCEPTABLE, HOWEVER, FOR SPECOPS AND INLINFNS.
	!SO WE WILL TEST FOR THE THREE EXCEPTIONS AND QUIT
	!IF BOTH ARGS ARE NOT CONSTANTS.

	!WE MUST ALSO MAKE SURE THAT NEG/NOT FLAGS ARE FOLDED
	!INTO ANY CONSTANTS THAT ARE CURRENTLY EXTANT OR CREATED.
	EXPR_(
	CASE .EXPR[OPRCLS] OF SET

	!BOOLEAN
	BEGIN
		!FOLD NEG/NOT FLAGS, IF THERE
		T_.EXPR[ARG1PTR];
		IF .T[OPR1] EQL CONSTFL THEN FIX1NN(.EXPR,.EXPR[ARG1PTR]);
		T_.EXPR[ARG2PTR];
		IF .T[OPR1] EQL CONSTFL THEN FIX2NN(.EXPR,.EXPR[ARG2PTR]);
		PAPPY_.EXPR[PARENT];
		!SET NOT FLAG FALSE
		NOTFLG_FALSE;
		EXPR_BLSKOPT(.EXPR);
		!IF BLSKOPT SET NOTFLG THEN WE HAVE TO PASS IT BACK UP
		IF .NOTFLG THEN
			SETPNOT(.PAPPY,.OPEXPR);
		.EXPR
	END;

	!DATAOPR
		BEGIN END;

	!RELATIONAL
	BEGIN
		!FOLD NEG/NOT FLAGS IF THERE
		T_.EXPR[ARG1PTR];
		IF .T[OPR1] EQL CONSTFL THEN FIX1NN(.EXPR,.EXPR[ARG1PTR]);
		T_.EXPR[ARG2PTR];
		IF .T[OPR1] EQL CONSTFL THEN FIX2NN(.EXPR,.EXPR[ARG2PTR]);
		RELSKOPT(.EXPR)
	END;

	!FNCALL
		.EXPR;

	!ARITHMETIC
	BEGIN
		!FOLD NEG/NOT FLAGS IF THERE
		T_.EXPR[ARG1PTR];
		IF .T[OPR1] EQL CONSTFL THEN FIX1NN(.EXPR,.EXPR[ARG1PTR]);
		T_.EXPR[ARG2PTR];
		IF .T[OPR1] EQL CONSTFL THEN FIX2NN(.EXPR,.EXPR[ARG2PTR]);
		!SAVE PARENT POINTER FOR THE NEGFLAG PROPAGATION HASSLE
		PAPPY_.EXPR[PARENT];
		!SET NEGFLG FALSE
		NEGFLG_FALSE;
		EXPR_ARSKOPT(.EXPR);
		!IF NEGFLG IS NOW TRUE WE HAVE TO SET THE NEGFLG ON
		!PAPPY FOR THE CORRECT ARGUMENT. NOT SET BUT COMPLEMENT.
		IF .NEGFLG THEN
			SETPNEG(.PAPPY,.OPEXPR);
		.EXPR
	END;

	!TYPECNV
	BEGIN
		LOCAL BASE ARG2NODE;
		!FOLD NEG/NOT FLAGS, IF THERE
		T_.EXPR[ARG2PTR];
		IF .T[OPR1] NEQ CONSTFL THEN RETURN(.EXPR);
		IF .T[OPR1] EQL CONSTFL THEN FIX2NN(.EXPR,.EXPR[ARG2PTR]);
		!IF THIS IS A CONVERSION FROM LOGICLA (INDICATED BY OPERSP)
		!TO DOUBLE PRECISION DO NOT DO IT ELSE THERE WILL
		!BE ROUNDING ERRORS ON A KA.
		IF .EXPR[VALTYPE] EQL DOUBLPREC AND .EXPR[OPERSP] EQL
		LOGICAL THEN RETURN(.EXPR);

		COPRIX_KTPCNVIX(EXPR);
		ARG2NODE_.EXPR[ARG2PTR];
		C1H_.ARG2NODE[CONST1];
		C1L_.ARG2NODE[CONST2];
		CNSTCMB();
		MAKECNST(.EXPR[VALTYPE],.C2H,.C2L)
	END;

	!ARRAYREF
		IF NOT .EXPR[A2VALFLG] THEN 
		BEGIN
			!FOLD NEG/NOT FLAGS, IF THERE
		T_.EXPR[ARG2PTR];
		IF .T[OPR1] EQL CONSTFL THEN FIX2NN(.EXPR,.EXPR[ARG2PTR]);
			ARSKOPT(.EXPR[ARG2PTR])
		END
		ELSE
		.EXPR;

	!CMNSUB
		.EXPR;		!SHOULD NEVER HAPPEN

	!NEGNOT
	BEGIN
		LOCAL BASE ARGNODE;
		!FOLD NEG/NOT FLAGS, IF THERE
		T_.EXPR[ARG2PTR];
		IF .T[OPR1] EQL CONSTFL THEN FIX2NN(.EXPR,.EXPR[ARG2PTR]);
		ARGNODE_.EXPR[ARG2PTR];
		IF .ARGNODE[OPR1] NEQ CONSTFL THEN RETURN(.EXPR);
		IF .EXPR[OPERSP] EQL NEGOP THEN
			NEGCNST(ARGNODE)
		ELSE
			NOTCNST(ARGNODE)
	END;

	!SPECOP
	BEGIN
		LOCAL BASE ARG1NODE;
		T_.EXPR[ARG1PTR];
		IF .T[OPR1] NEQ CONSTFL THEN RETURN(.EXPR);
		IF .T[OPR1] EQL CONSTFL THEN FIX1NN(.EXPR,.EXPR[ARG1PTR]);
		ARG1NODE_.EXPR[ARG1PTR];
		COPRIX_KSPECOPIX(EXPR);
		C1H_.ARG1NODE[CONST1];
		C1L_.ARG1NODE[CONST2];
		C2L_.EXPR[ARG2PTR];
		CNSTCMB();
		MAKECNST(.EXPR[VALTYPE],.C2H,.C2L)
	END;

	!FIELDREF
	BEGIN
	END;
	!STOERCLS
	BEGIN END;
	!REGCONTENTS
	BEGIN END;
	!LABOP
	BEGIN END;
	!STATEMENT
	BEGIN END;
	!IOLCLS
	BEGIN END;
	!INLINFN
	BEGIN
		LOCAL BASE ARGNODE;
		T_.EXPR[ARG1PTR];
		IF .T[OPR1] EQL CONSTFL THEN FIX1NN(.EXPR,.EXPR[ARG1PTR]);
		ARGNODE_.EXPR[ARG1PTR];
		IF .ARGNODE[OPR1] NEQ CONSTFL THEN RETURN(.EXPR);
		ARGNODE_.EXPR[ARG2PTR];
		IF .ARGNODE NEQ 0 THEN
		BEGIN
			T_.EXPR[ARG2PTR];
			IF .T[OPR1] EQL CONSTFL THEN FIX2NN(.EXPR,.EXPR[ARG2PTR]);
			IF .ARGNODE[OPR1] NEQ CONSTFL THEN
				RETURN(.EXPR);
		END;
		ARGNODE_.EXPR[ARG1PTR];
		C1H_.ARGNODE[CONST1];
		C1L_.ARGNODE[CONST2];
		ARGNODE_.EXPR[ARG2PTR];
		C2H_.ARGNODE[CONST1];
		C2L_.ARGNODE[CONST2];
		COPRIX_KILFOPIX(EXPR);
		CNSTCMB();
		MAKECNST(.EXPR[VALTYPE],.C2H,.C2L)
	END
	TES);
	!NOW LOOK TO SEE IF ANY PROPAGATION TOOK PLACE
	!IF IT DID (THE CONSTANTS FOLDED OR COMBINED) THEN
	!CHECK TO SEE THAT DEFPOINTS OF ITEMS LEFT ARE SET
	!WHEN PROPAGATING TO INNER DOS DEFKEEPER IS 0

	IF .OPEXPR NEQ .EXPR THEN
	BEGIN
		!CHECK TO SEE THAT FOLD WAS INDEED TO A 
		!DATA ITEM. EXPRESSION AND TRUE FOLDS
		!TO EXPRESSION AND SETTING THE VAL FLAG WOULD BE A NO-NO
		IF .EXPR[OPRCLS] EQL DATAOPR THEN
			SETPVAL(.OPEXPR);
		T_.OPEXPR[PARENT];	!LOOK AT PARENT
		IF .T[OPRCLS] EQL STATEMENT THEN	!POINTS BACK TO
							!STATEMENT
			IF .T[SRCOPT] NEQ 0 THEN
			T[OPDEF]_(IF .EXPR[OPR1] EQL CONSTFL THEN
					.LENTRY ELSE .DEFKEEPER);
	END;
	.EXPR
END;

!*****************************************
!THE FOLLOWING ROUTINES THROUGH PEEK DEAL ONLY WITH CONSTANTS
!THE ARE PROPAGATING AFTER THE DEFINITION POINT INFO HAS
!GONE AWAY, AS TO INNER LOOPS WHEN PROCESSING AN OUTER
!ONE.
!*********************************************

FORWARD PEEK;

ROUTINE FOLD1CHK(EXPR)=
BEGIN
	!CHECK IF ARG1 IS A CONSTANT AND CALL FOLDER TO FOLD THE
	!NODE

	MAP BASE EXPR;

	REGISTER BASE ARGNOD;

	ARGNOD_.EXPR[ARG1PTR];
	IF .ARGNOD[OPR1] EQL CONSTFL THEN
		RETURN(FOLDER(.EXPR));
	.EXPR
END;
ROUTINE FOLD2CHK(EXPR)=
BEGIN
	!SAME AS FOLD1CHK EXCEPT FOR ARG2
	MAP BASE EXPR;
	REGISTER BASE ARGNOD;

	ARGNOD_.EXPR[ARG2PTR];
	IF .ARGNOD[OPR1] EQL CONSTFL THEN
		RETURN(FOLDER(EXPR));
	.EXPR
END;
ROUTINE FOLBOTH(EXPR)=
BEGIN
	!CAUSE THE NODE TO FOLD IF BOTH ARGS ARE
	!CONSTANT

	MAP BASE EXPR;

	REGISTER BASE TMP;

	TMP_.EXPR[ARG1PTR];

	IF .TMP[OPR1] EQL CONSTFL THEN
	BEGIN
		TMP_.EXPR[ARG2PTR];
		IF .TMP[OPR1] EQL CONSTFL THEN
			RETURN(FOLDER(.EXPR));
	END;
	.EXPR
END;
ROUTINE PEEK1ARG(EXPR)=
BEGIN
	!AUXILLARY ROUTINE TO HELP PEEK EXAMINE ARG1PTR OF
	!EXPP. THE VARIABLE BEING PROPAGATED IS IN CHOSEN[0]
	!(SYMBOL TABLE POINTER) AND THE CONSTANT IT IS TO
	!BECOME IN CHOSENGLOBREGHE ROUTINE FIX1NN IS USED TO
	!TAKE CARE OF NEG/NOT FLAGS. (SEE THESE ROUTINES FOR
	!COMMENTS ON THEIR FUNCTIONS).

	EXTERNAL GLOBREG,CHOSEN;
	MAP PEXPRNODE EXPR;
	!SEE IF ARG1PTR  IS THE VARIABLE. IT IS JUST
	!ASS EFFICIENT TO TEST THE ADDRESSES AS IT IS
	!TO CHECK THE VAL FLAGS.

	IF .EXPR[ARG1PTR] EQL .CHOSEN[0] THEN
	BEGIN
		!SUBSTITUTE THE CONSTANT
		EXPR[ARG1PTR]_.GLOBREG[0];
		!FIX NEG/NOT FLAGS
		FIX1NN(.EXPR,.GLOBREG[0]);
	END ELSE
		!WALK ON
		IF NOT .EXPR[A1VALFLG] THEN
			EXPR[ARG1PTR]_PEEK(.EXPR[ARG1PTR],.CHOSEN[0],.GLOBREG[0]);
END;

ROUTINE PEEK2ARG(EXPR)=
BEGIN
	!SAME AS PEEK1ARG (SEE COMMENTS THERE) EXCEPT IT
	!EXAMINES ARG2PTR OF EXPR.

	EXTERNAL GLOBREG,CHOSEN;
	MAP PEXPRNODE EXPR;

	!SEE IF ARG2 IS THE VARIABLE
	IF .EXPR[ARG2PTR] EQL .CHOSEN[0] THEN
	BEGIN
		!SUBSTITUTE THE CONSTANT
		EXPR[ARG2PTR]_.GLOBREG[0];
		FIX2NN(.EXPR,.GLOBREG[0]);
	END ELSE
		!WALK ON
		IF NOT .EXPR[A2VALFLG] THEN
			EXPR[ARG2PTR]_PEEK(.EXPR[ARG2PTR],.CHOSEN[0],.GLOBREG[0]);
END;

ROUTINE PEEK(EXPR,VAR,NUMB)=
BEGIN
	EXTERNAL CHOSEN,GLOBREG,DNEGCNST;
	MAP PEXPRNODE EXPR:NUMB;
	!EXPR POINTS AT AN EXPRESSION TREE TO BE WALKED
	!VAR IS THE VARIABLE WE ARE LOOKING FOR
	!NUMB IS THE CONSTANT THAT REPLACES IT

	!SAVE THE NUMB AND VARIABLE WE ARE PROPAGATING
	!IN GLOBALS CHOSEN AND GLOBREG.

	CHOSEN[0]_.VAR;  GLOBREG[0]_.NUMB;

	!SET DEFKEEPER TO ZERO. WE ARE NOT INTERESTED IN
	!INSERTING JUNK DEFINITION POINTS INTO
	!NODES NOW

	DEFKEEPER_0;
	CASE .EXPR[OPRCLS] OF SET

	!BOOLEAN
	BEGIN
		PEEK1ARG(.EXPR);
		PEEK2ARG(.EXPR);
		EXPR_FOLBOTH(.EXPR);
	END;

	!DATAOPR
		BEGIN END;

	!RELATIONAL
	BEGIN
		PEEK1ARG(.EXPR);
		PEEK2ARG(.EXPR);
		EXPR_FOLBOTH(.EXPR);
	END;

	!FNCALL
		BEGIN END;

	!ARITHMETIC
	BEGIN
		PEEK1ARG(.EXPR);
		PEEK2ARG(.EXPR);
		EXPR_FOLBOTH(.EXPR);
	END;

	!TYPECNV
	BEGIN
		PEEK2ARG(.EXPR);
		EXPR_FOLD2CHK(.EXPR);
	END;

	!ARRAYREF
	BEGIN
		IF .EXPR[ARG2PTR] NEQ 0 THEN
			PEEK2ARG(.EXPR);
	END;

	!CMNSUB
		BEGIN END;

	!NEGNOT
	BEGIN
		PEEK2ARG(.EXPR);
		EXPR_FOLD2CHK(.EXPR);
	END;

	!SPECOP
	BEGIN
		PEEK1ARG(.EXPR);
		EXPR_FOLD1CHK(.EXPR);
	END;

	!FIELDREF		NOT IN RELEASE 1
		BEGIN END;

	!STORECLS
		BEGIN END;

	!REGCONTENTS
		BEGIN END;

	!LABOP
		BEGIN END;

	!STATEMENT
		BEGIN END;

	!IOLSCLS
		BEGIN END;

	!INLINFN
	BEGIN
		PEEK1ARG(.EXPR);
		IF .EXPR[ARG2PTR] NEQ 0 THEN
		BEGIN
			 PEEK2ARG(.EXPR);
			EXPR_FOLBOTH(.EXPR);
		END ELSE
			EXPR_FOLD1CHK(.EXPR);
	END

	TES;
.EXPR
END;



FORWARD STMTPROP;

ROUTINE DOPROPAGATE(STMT,VAR,NUMB)=
BEGIN
	!TO EXAMINE ALL STATEMENTS IN THE LOOP HEADED BY STMT
	!FOR PROPAGATION OF THE VARIABLE VAR TO THE CONSTNT NUMB
	!STMT IS THE DO STATEMENT
	!VAR IS THE SYMBOL TABLE POINTER FOR THE VARIABLE
	!NUMB IS THE CONSTANT TABLE POINTER

	LOCAL PEXPRNODE P:PB:PA;
	MAP PEXPRNODE STMT:VAR:NUMB;
	P_.STMT;
	PB_.STMT[DOLBL];
	PB_.PB[SNHDR];
	DO
	BEGIN
		!WE NOW HANDLE ONLY ASSIGNMENT STATEMENTS AND DO LOOPS
		IF .P[SRCID] EQL ASGNID THEN
		BEGIN
			IF .P[LHEXP] EQL .VAR THEN RETURN;
			IF NOT .P[A1VALFLG] THEN
			BEGIN
				PA_.P[LHEXP];
				IF NOT .PA[A2VALFLG] THEN
				PA[ARG2PTR]_PEEK(.PA[ARG2PTR],.VAR,.NUMB);
			END;

			IF NOT .P[A2VALFLG] THEN
				P[RHEXP]_PEEK(.P[RHEXP],.VAR,.NUMB)
			ELSE
				IF .P[RHEXP] EQL .VAR THEN
					P[RHEXP]_.NUMB;
			!MAKE SURE &%$# VAL FLAGS ARE SET
			PA_.P[LHEXP];
			IF .PA[OPRCLS] EQL DATAOPR THEN
				PA[A1VALFLG]_1;
			PA_.P[RHEXP];
			IF .PA[OPRCLS] EQL DATAOPR THEN
				PA[A2VALFLG]_1;
		END ELSE

		IF .P[SRCID] EQL DOID THEN
		BEGIN
			!FIRST FIND OUT IF THE VARIBALE IS CHANGED
			!IN THE LOOP.
			IF .P[DOSYM] EQL .VAR THEN RETURN;
			IF .P[SRCOPT] NEQ 0 THEN
			BEGIN
				MAP PHAZ2 P;
				IF .P[DOCHNGL] NEQ 0 THEN
				BEGIN
					PA_.P[DOCHNGL];
					WHILE .PA NEQ 0 DO
					BEGIN
						IF .PA[LEFTP] EQL .VAR THEN
								RETURN;
						PA_.PA[RIGHTP];
					END;
				END;
			END;

			IF .P NEQ .STMT THEN
			IF NOT .P[FLCWD] THEN
			BEGIN
				PA_.P[DOLPCTL];
				IF .PA[OPR1] EQL VARFL THEN
				BEGIN
					IF .PA EQL .VAR THEN
					P[DOLPCTL]_.NUMB;
				END ELSE
				P[DOLPCTL]_PEEK(.P[DOLPCTL],.VAR,.NUMB);
				PA_.P[DOLPCTL];
			IF .PA[OPR1] EQL CONSTFL THEN STMTPROP(.P);
			END;
		END;
		P_.P[SRCLINK];
	END UNTIL .P EQL .PB[SRCLINK];
END;
EXTERNAL QQ;
MAP PHAZ2 QQ;

FORWARD VALCNV;


!*******************************************
!MACRO TESTS ALL PROPERTIES NECESSARY FOR A STRENGTH REDUCTION.
!THESE ARE RELEASE 1 PROPERTIES AND THE MACRO MAY BE CHANGED WHEN
!MORE SOPHISTICATED REDUCTIONS ARE ATTEMPTED.
MACRO REDUCOP(ANODE)=
	IF .ANODE[A1VALFLG] AND .ANODE[A2VALFLG] THEN
		IF .ANODE[VALTP1] EQL INTEG1 THEN
			IF .ANODE[OPR1] EQL MULOPF THEN
					1
		ELSE
	0$;

!***********************************************


ROUTINE VALCNV(LHSNOD,RHSNOD)=
BEGIN
	!WHEN A CONSTANT TO PROPAGATE HAS BEEN FOUND
	!WE MUST PERHAPS PERFORM SOME TYPE CONVERSION WONDERS ON
	!IT. SINCE ALL CONSTANTS (REAL) ARE CARRIED IN DOUBLE
	!PRECISION, WE MUST ROUND BEFORE USE IF THIS IS A REAL
	!VARIABLE. IF THE VALUE TYPE ON BOTH SIDES OF THE
	!ASSIGNMENT IS NOT THE SAME, WE MUST ALSO CONVERT THE CONSTANT.
	!THIS IS FOR CASES LIKE A=.TRUE..
	!ALSO WE DO NOT WANT TO CONVERT DP=".........
	!OR DP='....'

	EXTERNAL KTYPCB;
	EXTERNAL COPRIX,C1H,C1L,C2H,C2L,KDPRL,CNSTCMB;
	MAP BASE RHSNOD:LHSNOD;

	!SAME VALTYPE, REAL
	IF .LHSNOD[VALTYPE] EQL .RHSNOD[VALTYPE] AND .LHSNOD[VALTYPE]
	  EQL REAL THEN
	BEGIN
		COPRIX_KDPRL;
		C1H_.RHSNOD[CONST1];
		C1L_.RHSNOD[CONST2];
		CNSTCMB();
		RETURN(MAKECNST(REAL,.C2H,.C2L));
	END ELSE
	BEGIN
		!VALTYPES DIFFERENT
		IF .LHSNOD[VALTYPE] NEQ .RHSNOD[VALTYPE] THEN
		BEGIN
			!CHECK FOR THOSE ADDITIONAL ONES NOT TO CONVERT
			IF .LHSNOD[VALTYPE] EQL DOUBLPREC AND
			(.RHSNOD[VALTYPE] EQL LITERAL OR
			 .RHSNOD[VALTYPE] EQL DOUBLOCT) THEN
				RETURN(.RHSNOD);	!NO CONVERSION
			!WE ARE HERE AND WANT TO CONVERT
			COPRIX_KKTPCNVIX(.LHSNOD[VALTP2],.RHSNOD[VALTP2]);
			C1H_.RHSNOD[CONST1];
			C1L_.RHSNOD[CONST2];
			CNSTCMB();
			RETURN(MAKECNST(.LHSNOD[VALTYPE],.C2H,.C2L));
		END;
	END;
	!ELSE ALL IS OK JUST USE CONSTANT AS IS
	RETURN(.RHSNOD);
END;


ROUTINE FIX1NN(EXPR,NUMB)=
BEGIN
	!CHECK FOR A NEG AND(SHOULD NEVER BE)/OR NOT FLAG
	!OVER ARG1 OF EXPR. ARG1 IS A CONSTANT. NEGATE
	!OR COMPLEMENT THE CONSTANT AND FIX ARG1PTR.
	!NUMB IS THE CONSTANT.

	MAP PEXPRNODE EXPR:NUMB;

	EXTERNAL DNEGCNST;

					IF .EXPR[A1NEGFLG] THEN
					BEGIN
						EXPR[ARG1PTR]_NEGCNST(NUMB);
						EXPR[A1NEGFLG]_0;
					END;
					IF .EXPR[A1NOTFLG] THEN
					BEGIN
						EXPR[ARG1PTR]_NOTCNST(NUMB);
						EXPR[A1NOTFLG]_0;
					END;
END;

!**********************************************


ROUTINE CONS1DEF(EXPR)=
BEGIN
	!DETERMINE IF A PROPAGATION CAN OCCUR
	!AND DO IT FOR THE FIRST ARGUMENT OF EXPR

	EXTERNAL DNEGCNST,CHOSEN,GLOBREG,LENTRY;
	MAP PEXPRNODE EXPR;
	LOCAL BASE PC:PB:PA;

		!WE ARE LOOKING AT A LEAF
		!IF IT IS A CONSTANT OR VARIABLE THAT PROPAGATES
		!RETURN 1. THIS MAY CAUSE SOME EXTRA WORK
		!IN THAT THE VARIABLE CONSTANT COMBO WILL CAUSE
		!AN EXTRA CALL TO LOCAL OPTIMIZATION ROUTINES
		!BUT IT IS THE ONLY WAY WE CAN FOLD HAIRY EXPRESSIONS
		!THAT COLLAPSE UP FROM A SINGLE PROPAGATE.
		PC_.EXPR[ARG1PTR];
		IF .PC[OPR1] EQL CONSTFL THEN
		BEGIN
			EXPR[DEFPT1]_0;
			FIX1NN(.EXPR,.PC);
			RETURN(1);
		END;

		IF .PC[OPR1] EQL VARFL THEN
		BEGIN
			!THE LEAF IS A VARIABLE
			DEFKEP_
			PA_.EXPR[DEFPT1];
			!DONT MISTAKENLY PROPAGATE THE CONSTANT THAT
			!MAY SIT AT LENTRY.
			IF .PA EQL 0 OR .PA EQL .LENTRY  THEN
			(EXPR[DEFPT1]_0; RETURN(0));
			!ZERO DEFPT FIELDS WHILE WE'RE HERE
			EXPR[DEFPT1]_0;
			IF .PA[SRCID] EQL ASGNID AND
				.PA[LHEXP] EQL .PC THEN
			!THE DEFINITION FPOINT IS AN ASSIGNMENT OF THAT 
			!VARIABLE
			BEGIN
				PB_.PA[RHEXP];
				!LOOK AT THE RIGHT  HAND SIDE
				IF .PB[OPR1] EQL CONSTFL THEN
				BEGIN
					!REALLY GOT ONE!
					!SAVE DEFINITION POINT
					DEFKEEPER_.EXPR[DEFPT2];
					PB_VALCNV(.PA[LHEXP],.PB);
					EXPR[ARG1PTR]_.PB;
					FIX1NN(.EXPR,.PB);
					!SAVE THE PROPAGATION THAT
					!JUST HAPPENED
					CHOSEN[0]_.PC;
					GLOBREG[0]_.EXPR[ARG1PTR];
					RETURN(1)
				END;
			END;
		END ELSE
		BEGIN
			 EXPR[DEFPT1]_0;
			!IF IT WAS A CONSTANT MAKE SURE THAT THERE
			!ARE NO NEG OR NOT FLAGS LEFT ABOVE IT. THE
			!CASE MAY ARISE IF THE CONSTANT IS A PROPAGATED
			!EXPRESSION (LIKE INLINFN). FOR THE NEG OR
			!NOT INTO THE CONSTANT
			IF .PC[OPR1] EQL CONSTFL THEN
				FIX1NN(.EXPR,.EXPR[ARG1PTR]);
		END;
END;

ROUTINE FIX2NN(EXPR,NUMB)=
BEGIN
	!EXPR[ARG2PTR] IS A CONSTANT. SEE THAT NEG AND NOT FLAGS
	!ARE FOLDED INTO THE CONSTANT. NUMB IS EXPR[ARG2PTR].
	!EQUIVALENT OF FIX1NN FOR ARG2.

	MAP PEXPRNODE EXPR:NUMB;

	EXTERNAL DNEGCNST;

					IF .EXPR[A2NEGFLG] THEN
					BEGIN
						EXPR[ARG2PTR]_NEGCNST(NUMB);
						EXPR[A2NEGFLG]_0;
					END;
					IF .EXPR[A2NOTFLG] THEN
					BEGIN
						EXPR[ARG2PTR]_NOTCNST(NUMB);
						EXPR[A2NOTFLG]_0;
					END;
END;

!*******************************************

ROUTINE CONS2DEF(EXPR)=
BEGIN
	!DETERMINE IF A PROPAGATION CAN OCCUR AND DO IT
	!FOR THE SECOND ARGUMENT OF EXPR
	EXTERNAL DNEGCNST,CHOSEN,GLOBREG,LENTRY;
	MAP PEXPRNODE EXPR;
	LOCAL BASE PC:PB:PA;

		!WE ARE LOOKING AT A LEAF
		!SEE COMMENTS IN FRONT OF CONS1DEF

		PC_.EXPR[ARG2PTR];

		IF .PC[OPR1] EQL CONSTEN
		BEGIN
			EXPR[DEFPT2]_0;
			FIX2NN(.EXPR,.PC);
			RETURN(1);
		END;

		IF .PC[OPR1] EQL VARFL THEN
		BEGIN
			!THE LEAF IS A VARIABLE
			PA_.EXPR[DEFPT2];
			!DO NOT INADVERTENTLY PROPAGATE AN INNOCENT
			!ASSIGNMENT AT ENTRY
			IF .PA EQL 0 OR .PA EQL .LENTRY  THEN
			(EXPR[DEFPT2]_0; RETURN(0));
			!ZERO DEFPTS WHILE WE'RE HERE
			EXPR[DEFPT2]_0;
			IF .PA[SRCID] EQL ASGNID AND .PA[LHEXP] EQL .PC THEN
			BEGIN
				!THE DEFINITION POINT IS AN ASSIGNMENT OF THAT VARIABLE
				PB_.PA[RHEXP];
				!LOOK AT THE RIGHT HAND SIDE
				IF .PB[OPR1] EQL CONSTFL THEN
				BEGIN
					!REALLY GOT ONE!
					PB_VALCNV(.PA[LHEXP],.PB);
					EXPR[ARG2PTR]_.PB;
					DEFKEEPER_.DEFKEP;
					FIX2NN(.EXPR,.PB);
					!SAVE THE PROPAGATION THAT JUST
					!TOOK PLACE
					CHOSEN[0]_.PC;
					GLOBREG[0]_.EXPR[ARG2PTR];
					RETURN(1);
				END;
			END;
		END ELSE
		BEGIN
			 EXPR[DEFPT2]_0;
			!IF IF IS ALREADY A CONSTANT (PROPAGATED EXPRESSION)
			!MAKE SURE NEG/NOT FLAGS ARE FOLDED INTO IT.
			IF .PC[OPR1] EQL CONSTFL THEN
				FIX2NN(.EXPR,.EXPR[ARG2PTR]);
		END;
END;

!MACROS TO CHECK ARGS AND SET VALFLAGS WHEN NEEDED.
MACRO VAL1FX(EXPR)=
	BEGIN
		PA_.EXPR[ARG1PTR];
		IF .PA[OPRCLS] EQL DATAOPR THEN
			EXPR[A1VALFLG]_1;
	END$,

	VAL2FX(EXPR)=
	BEGIN
		PA_.EXPR[ARG2PTR];
		IF .PA[OPRCLS] EQL DATAOPR THEN
			EXPR[A2VALFLG]_1;
	END$,

	VALBFX(EXPR)=
	BEGIN
		VAL1FX(EXPR);
		VAL2FX(EXPR);
	END$;


ROUTINE LOKDEFPT(EXPRNODE)=
BEGIN
	EXTERNAL LOOP;


!LOOK AT ALL LEAVES. EXAMINE THE DEFINITION POINT FOR AN ASSIGNMENT
!OF THAT VARIABLE TO A CONSTANT.  SUBSTITUTE THAT CONSTANT FOR THE
!VARIABLE. @ROCESSING IS DONE IN MOORE FLOOD ORDER. THIS HOPEFULLY
!INSURES THAT ALL PROPAGATIONS WHICH CAUSE OTHER PROPAGATIONS ARE CAUGHT

REGISTER PEXPRNODE EXPR;
LOCAL BASE PA;
LOCAL WHATSUP;
EXPR_.EXPRNODE;


	!INITIALIZE THE LOCAL THAT WILL TELL US IF PROPAGATION
	!DID ACTUALLY DID OCCUR.
	!FOR EACH OPERCLASS THE ARGS ARE EXAMINED.
	!CONS1DEF AND CONS2DEF RETURN A 1 IF A PROPAGATION
	!OCCURRED AND A 0 OTHERWISE. IN ALL CASES WE WAIT TO
	!FOLD UNTIL BOTH ARGS HAVE BEEN EXAMINED. THIS IS DONE
	!FOR TWO REASONS:
	!	1. THE NODE MIGHT CHANGE FORM IN THE MIDDLE
	!	2.IT SHOULD BE FASTER IF ONLY ONE PROPAGATES

	WHATSUP_0;
	!HANDLE THE CASE WHERE THEY ARE ALEEADY BOTH CONSTANTS
	!AND FOR SOME REASON HAVE NOT BEEN *LOCALLY* FOLDED

	IF .EXPR[A1VALFLG] THEN
	BEGIN
		PA_.EXPR[ARG1PTR];
		IF .PA[OPR1] EQL CONSTFL THEN
			IF .EXPR[A2VALFLG] THEN
			BEGIN
				PA_.EXPR[ARG2PTR];
				IF .PA[OPR1] EQL CONSTFL THEN
				BEGIN
					!ZERO THE DEFINITION POINTS
					EXPR[DEFPT1]_0;
					EXPR[DEFPT2]_0;
					EXPR_FOLDER(.EXPR);
					RETURN(.EXPR);
				END;
			END;
	END;

	CASE .EXPR[OPRCLS] OF SET
	!BOOLEAN
	BEGIN
		IF NOT .EXPR[A1VALFLG] THEN
		BEGIN
			EXPR[DEFPT1]_0;
			EXPR[ARG1PTR]_LOKDEFPT(.EXPR[ARG1PTR]);
		END;
		IF .EXPR[A1VALFLG] THEN
			WHATSUP_CONS1DEF(.EXPR);

		IF NOT .EXPR[A2VALFLG] THEN
		BEGIN
			EXPR[DEFPT2]_0;
			EXPR[ARG2PTR]_LOKDEFPT(.EXPR[ARG2PTR]);
		END;
		IF .EXPR[A2VALFLG] THEN
			WHATSUP_.WHATSUP+CONS2DEF(.EXPR);
		IF .WHATSUP GTR 0 THEN EXPR_FOLDER(.EXPR);
	END;

	!DATAOPR
		RETURN(.EXPR);

	!RELATIONAL
	BEGIN
		IF NOT .EXPR[A1VALFLG] THEN
		BEGIN
			EXPR[DEFPT1]_0;
			EXPR[ARG1PTR]_LOKDEFPT(.EXPR[ARG1PTR]);
		END;
		IF .EXPR[A1VALFLG] THEN
			WHATSUP_CONS1DEF(.EXPR);

		IF NOT .EXPR[A2VALFLG] THEN
		BEGIN
			EXPR[DEFPT2]_0;
			EXPR[ARG2PTR]_LOKDEFPT(.EXPR[ARG2PTR]);
		END;
		IF .EXPR[A2VALFLG] THEN
			WHATSUP_.WHATSUP+CONS2DEF(.EXPR);
		IF .WHATSUP GTR 0 THEN EXPR_FOLDER(.EXPR);
	END;

	!FNCALL
	BEGIN
		EXTERNAL SETPVAL;
		!THIS IS VERY SAD. IF A LIBRARY FUNCTION, IT
		!COULD BE MOVED TO PROGRAM ENTRY, BUT ARGLISTS
		!HAVE NO RROM FOR DEFINITION POINT INFO.
		!WE WILL TRY FOR A CONSTANT ARGUMENT
		!THIS WILL APPLY ONLY (MOST PROBABLY) TO BENCHMARKS

			LOCAL ARGUMENTLIST AG;
			AG_.EXPR[ARG2PTR];

		!FOR A LIBRARY FUNCTION OF ONE ARGUMENT
		IF .EXPR[OPERSP] EQL LIBARY AND .LOOP NEQ 0  THEN
		BEGIN
			IF .AG[ARGCOUNT] EQL 1 THEN
			BEGIN
				REGISTER BASE TMP;
				TMP_.AG[1,ARGNPTR];
				IF .TMP[OPR1] EQL CONSTFL THEN
				BEGIN
					OWN BASE FRONT:STMT;
					!SET VAL FLG ON OLD PARENT
					SETPVAL(.EXPR);
					FRONT_.SORCPTR<LEFT>;	!FIRST STATEMENT OF PROG
					!THIS COULD BE AN ENTRY FOR A SUBPROGRAM
					STMT_.FRONT[SRCLINK];
					WHILE .STMT[SRCID] EQL ENTRID DO
						STMT_.STMT[SRCLINK];
					IF .STMT NEQ .FRONT[SRCLINK] THEN
						FRONT_.STMT;
					NAME<LEFT>_ASGNSIZ + SRCSIZ;
					STMT_CORMAN();
					STMT[OPRCLS]_STATEMENT;
					STMT[OPERSP]_ASGNID;
					STMT[A1VALFLG]_1;
					STMT[LHEXP]_RDCTMP();
					STMT[RHEXP]_.EXPR;
					!SET THE NEW PARENT OF THE FUNCTION CALL
					EXPR[PARENT]_.STMT;
					STMT[SRCLINK]_.FRONT[SRCLINK];
					FRONT[SRCLINK]_.STMT;
					RETURN(.STMT[LHEXP]);
				END;
			END;
		END;
		!ZERO ANY DEFINITION POINTS ON EXPRESSION ARGS
		!THE CHEAPEST WAY (CODE SIZE-WISE) IS TO CALL
		!LOKDEF

		INCR I FROM 1 TO .AG[ARGCOUNT] DO
		BEGIN
			LOCAL BASE TMP1;

			TMP1_.AG[.I,ARGNPTR];	!LOOK AT ARG
			IF .TMP1[OPRCLS] NEQ DATAOPR THEN
			AG[.I,ARGNPTR]_LOKDEFPT(.TMP1);
		END;
		RETURN(.EXPR);
	END;

	!ARITHMETIC
	BEGIN
		IF NOT .EXPR[A1VALFLG] THEN
		BEGIN
			EXPR[DEFPT1]_0;
			EXPR[ARG1PTR]_LOKDEFPT(.EXPR[ARG1PTR]);
		END;
		IF .EXPR[A1VALFLG] THEN
			WHATSUP_CONS1DEF(.EXPR);

		IF NOT .EXPR[A2VALFLG] THEN
		BEGIN
			EXPR[DEFPT2]_0;
			EXPR[ARG2PTR]_LOKDEFPT(.EXPR[ARG2PTR]);
		END;
		IF .EXPR[A2VALFLG] THEN
			WHATSUP_.WHATSUP+CONS2DEF(.EXPR);
		IF .WHATSUP GTR 0 THEN EXPR_FOLDER(.EXPR);
		IF .EXPR[OPR1] EQL MULOPF THEN
		EXPR_REDUCE(.EXPR);
	END;

	!TYPECNV
	BEGIN
		IF NOT .EXPR[A2VALFLG] THEN
		BEGIN
			EXPR[DEFPT2]_0;
			EXPR[ARG2PTR]_LOKDEFPT(.EXPR[ARG2PTR]);
		END;
		IF .EXPR[A2VALFLG] THEN
			WHATSUP_CONS2DEF(.EXPR);
		IF .WHATSUP GTR 0 THEN EXPR_FOLDER(.EXPR);
	END;

	!ARRAYREF
	BEGIN
		IF .EXPR[A2VALFLG] THEN
		BEGIN
			IF .EXPR[ARG2PTR] NEQ 0 THEN
			WHATSUP_CONS2DEF(.EXPR)
			ELSE EXPR[DEFPT2]_0;
		END
		ELSE
		BEGIN
			EXPR[DEFPT2]_0;
			EXPR[ARG2PTR]_LOKDEFPT(.EXPR[ARG2PTR]);
		END;

		IF .WHATSUP GTR 0 THEN EXPR_FOLDER(.EXPR);
	END;

	!CMNSUB
		RETURN(.EXPR);

	!NEGNOT
	BEGIN
		IF NOT .EXPR[A2VALFLG] THEN
		BEGIN
			EXPR[DEFPT2]_0;
			EXPR[ARG2PTR]_LOKDEFPT(.EXPR[ARG2PTR]);
		END;
		IF .EXPR[A2VALFLG] THEN
			WHATSUP_CONS2DEF(.EXPR);
		IF .WHATSUP GTR 0 THEN EXPR_FOLDER(.EXPR);
	END;

	!SPECOP
	BEGIN
		IF NOT .EXPR[A1VALFLG] THEN
		BEGIN
			EXPR[DEFPT1]_0;
			EXPR[ARG1PTR]_LOKDEFPT(.EXPR[ARG1PTR]);
		END;
		IF .EXPR[A1VALFLG] THEN
			WHATSUP_CONS1DEF(.EXPR);

		IF .WHATSUP GTR 0 THEN EXPR_FOLDER(.EXPR);
	END;

	!FIELDREF
		RETURN(.EXPR);

	!STORECLS
		RETURN(.EXPR);

	!RECONTENTS
		RETURN(.EXPR);

	!LABOP
		!ILLEGAL
		RETURN(.EXPR);

	!STATEMENT
		!ILLEGAL
		RETURN(.EXPR);

	!IOLSCLS
		RETURN(.EXPR);
	!INLINFN
	BEGIN
		IF NOT .EXPR[A1VALFLG] THEN
		BEGIN
			EXPR[DEFPT1]_0;
			EXPR[ARG1PTR]_LOKDEFPT(.EXPR[ARG1PTR]);
		END;
		IF .EXPR[A1VALFLG] THEN
			WHATSUP_CONS1DEF(.EXPR);

		IF .EXPR[ARG2PTR] NEQ 0 THEN
		IF NOT .EXPR[A2VALFLG] THEN
		BEGIN
			EXPR[DEFPT2]_0;
			EXPR[ARG2PTR]_LOKDEFPT(.EXPR[ARG2PTR]);
		END;
		IF .EXPR[A2VALFLG] THEN
			WHATSUP_.WHATSUP+CONS2DEF(.EXPR);
		IF .WHATSUP GTR 0 THEN EXPR_FOLDER(.EXPR);
	END
	TES;
	!NOW ONCE MORE LOOK AT WHAT HAS BECOME OF THE EXPRESSION
	!AND SET THE VAL FLAGS IF APPROPRIATE. FULL CASE IS NEEDED
	!CAUSE PHASE 1 SEEMS TO HAVE THE NTY HABIT OF LEAVING
	!JUNK IN ARG1 OF NODES THAT SHOULD HAVE ARG1 ZERO.
	CASE .EXPR[OPRCLS] OF SET
	!BOOLEAN
		VALBFX(EXPR);
	!DATAOPR
		BEGIN END;
	!RELATIONAL
		VALBFX(EXPR);
	!FNCALL
		BEGIN END;
	!ARITHMETIC
		VALBFX(EXPR);
	!TYPECNV
		VAL1FX(EXPR);
	!ARRAYREF
		VAL2FX(EXPR);
	!CMNSUB
		BEGIN END;
	!NEGNOT
		VAL2FX(EXPR);
	!SPECOP
		VAL1FX(EXPR);
	!FIELDREF
		BEGIN END;
	!STORECLS
		BEGIN END;
	!REGCONTENTS
		BEGIN END;
	!LABOP
		BEGIN END;
	!STATEMENT
		BEGIN END;
	!IOLSCLS
		BEGIN END;
	!INLINFN
	BEGIN
		VAL1FX(EXPR);
		IF .EXPR[ARG2PTR] NEQ 0 THEN
			VAL2FX(EXPR);
	END
	TES;
	RETURN .EXPR
END;

!***************************************************


	!DELETE A LOGICAL IF FROM THE FLOW OF CONTROL
	MACRO WIPEOUT(NUMB)=
	BEGIN
		HEAD[SRCID]_CONTID;
		IF .NUMB LSS 0 THEN
		BEGIN
			PB_.HEAD[SRCLINK];
			HEAD[SRCLINK]_.HEAD[LIFSTATE];
			PA_.HEAD[LIFSTATE];
			PA[SRCLINK]_.PB;
		END;
	END$;


FORWARD IFNN,ASGNNN;

ROUTINE ASGNPROP(HEAD)=
BEGIN
	!PROPAGATE STUFF FOR AN ASIGNMENT STATEMENT
	MAP PHAZ2 HEAD;
	LOCAL PHAZ2 PA;
	!THIS REGISTER IS TO PREVENT BLISS GENERATION OF
	!EXCESSIVE LOCALS
	REGISTER TMP;

		!LOOK AT THE LEFT HAND SIDE FIRST.
		!IF IT IS NOT A LEAF TRY TO PROPAGATE  WITH IN THE
		!EXPRESSION.
			IF NOT .HEAD[A1VALFLG] THEN
			BEGIN
				PA_.HEAD[LHEXP];
				!AN ARRAY REF IS ALL THAT IS LEGEL
				!SO WE WILL LOOK ONLY AT ARG2.
				!IF IT IS NOT A LEAF PROPAGATE AND REDUCE
				IF NOT .PA[A2VALFLG] THEN
				BEGIN
					TMP_LOKDEFPT(.PA[ARG2PTR]);
					PA[ARG2PTR]_.TMP;
				END;
				!IT HAS NOT BECOME A LEAF, THEREFOR IT
				!HAS NOT PROPAGATED, SO TRY A REDUCTION.
				IF NOT .PA[A2VALFLG] THEN
				BEGIN
					TMP_REDUCE(.PA[ARG2PTR]);
					PA[ARG2PTR]_.TMP;
				END;
			END;
			!DONE WITH LEFT HAND SIDE. NOT LOOK AT RIGHT HAND SIDE.
			!IF IT IS NOT A LEAF TRY PROPAGATION.
			IF NOT .HEAD[A2VALFLG] THEN
			BEGIN
				TMP_LOKDEFPT(.HEAD[RHEXP]);
				HEAD[RHEXP]_.TMP;
				!IT MAY NOW HAVE BECOME A LEAF. MAKE SURE
				!THAT THE NEG ANF NOT FLGS ARE PICKED UP.
				IF .HEAD[A2VALFLG] THEN
				BEGIN
					PA_.HEAD[RHEXP];
					IF .PA[OPR1] EQL CONSTFL THEN
						ASGNNN(.HEAD);
				END;
			END ELSE
			!IT WAS A LEAF TO BEGIN WITH. PROPAGATE.
				STMTPROP(.HEAD);
END;


GLOBAL ROUTINE PROPAGATE=
!THIS IS THE CONTROLLING ROUTINE FOR CONSTANT PROPAGATION
!AND REDUCTION IN STRENGTH

BEGIN

EXTERNAL CHOSEN,GLOBREG,CSTMNT,FOLDAIF,ISN,LOOP;
LABEL SELCT;
LOCAL HEAD,PA,PB,PC;
MAP PHAZ2 HEAD:TOP:PC:PA:PB;
MAP BASE CSTMNT;
!THIS REGISTER TO PREVENT BLISS FROM GENERATING EXCESSIVE TEMPS
REGISTER TMP;

!GO THROUGH BUSY LIST TRYING TO PROPAGATE CONSTANTS

!INITIALIZE SPECIAL REDUCTION VARIABLES
RDCCNT_0;
INCR I FROM 0 TO 8 DO
	RDCLST[.I]_0;

HEAD_.TOP;
IF .HEAD[SRCID] EQL DOID THEN
	HEAD_.HEAD[BUSY];

DO
BEGIN
	CSTMNT_.HEAD;
	ISN_.CSTMNT[SRCISN];

	SELCT:
	SELECT .HEAD[SRCID] OF NSET

	ASGNID:
		BEGIN
			ASGNPROP(.HEAD);
		END;

	IFLID: BEGIN
			!LOOK AT THE EXPRESION. IF ITS A LEAF CALL THE
			!STATEMENT PROPAGATION ROUTINE ELSE
			!DO THE REGULAR EXPRESSION PROPRAGATION.
			PA_.HEAD[LIFEXPR];
			IF .PA[OPRCLS] EQL DATAOPR THEN
			STMTPROP(.HEAD) 
			ELSE
			BEGIN
				TMP_LOKDEFPT(.HEAD[LIFEXPR]);
				HEAD[LIFEXPR]_.TMP;
			END;
			!WE HAVW TRIED PROPAGATION  NOW SEE WHATS LEFT.
			PA_.HEAD[LIFEXPR];
			IF .PA[OPR1] EQL MULOPF THEN
				HEAD[LIFEXPR]_REDUCE(.PA);
			!IF THE EXPRESSION HAS BECOME A CONSTANT
			!THEN GET RID OF THE STATEMENT
			PA_.HEAD[LIFEXPR];
			IF .PA[OPR1] EQL CONSTFL THEN
			BEGIN
				!MAKE SURE THAT ANY NEG NOT FLAGS ON THE
				!STATEMENT HAVE BEEN INCLUDED
				IFNN(.HEAD);
				IF .PA[VALTP1] EQL INTEG1 THEN
					WIPEOUT(PA[CONST2])
				ELSE
					WIPEOUT(PA[CONST1]);
			END;
	  END;
	IFAID:	BEGIN
			!EXAMINE THE EXPRESSION.
			PA_.HEAD[AIFEXPR];
			IF .PA[OPRCLS] EQL DATAOPR THEN
			STMTPROP(.HEAD)
			ELSE
			BEGIN
				!ITS NOT A LEAF, TRY PROPAGATION.
				TMP_LOKDEFPT(.HEAD[AIFEXPR]);
				HEAD[AIFEXPR]_.TMP;
				!LOOK AGAIN TO SEE WHAT THE EXPRESSION HAS BECOMEME
				PA_.HEAD[AIFEXPR];
				IF .PA[OPRCLS] EQL ARITHMETIC THEN
				BEGIN
					TMP_REDUCE(.HEAD[AIFEXPR]);
					HEAD[AIFEXPR]_.TMP;
				END;
			END;
		!IF IT REDUCED TO A CONSTANT, FOLD THE
		!STATEMENT, CUZ THE CONSTANT WILL NOT BE ALLOCATED
		PA_.HEAD[AIFEXPR];
		IF .PA[OPR1] EQL CONSTFL THEN
		BEGIN
			!FIRST MAKE SURE THAT ANY NEG/NOT FLAGS ON THE STATEMENT
			!HAVE BEEN PICKED UP.
			IFNN(.HEAD);
			CSTMNT_.HEAD;
			FOLDAIF();
		END;
		END;
	DOID:
		BEGIN
			!THIS IS AN INNER DO LOOP. LOOK AT THE
			!CONTROL EXPRESSION
			PA_.HEAD[DOLPCTL];
			!IT MAY ALREADY BE A CONSTANT IN WHICH
			!CASE WE WANT TO QUIT WHILE AHEAD
			IF .PA[OPR1] EQL CONSTFL THEN LEAVE SELCT;
			IF .PA[OPRCLS] EQL DATAOPR AND NOT .HEAD[FLCWD]
			AND .HEAD[SRCOPT] NEQ 0  THEN
			BEGIN
				PB_.HEAD[DOPDEF];
				IF .PB NEQ 0 THEN
					IF .PB[SRCID] EQL ASGNID 
					AND .PB[LHEXP] EQL .PA THEN
					BEGIN
					PC_.PB[RHEXP];
					IF .PC[OPR1] EQL CONSTFL THEN
					BEGIN
						HEAD[DOLPCTL]_.PC;
						CHOSEN[0]_.PA;
						GLOBREG[0]_.PC;
					END;
				END;
			END ELSE
			HEAD[DOLPCTL]_LOKDEFPT(.HEAD[DOLPCTL]);
			PA_.HEAD[DOLPCTL];
			IF NOT .HEAD[FLCWD] AND .PA[OPR1] EQL CONSTFL THEN
				IF STMTPROP(.HEAD) THEN
					DOPROPAGATE(.HEAD,.CHOSEN[0],.GLOBREG[0]);
		END;
	CALLID:
	BEGIN
		!ZERO OPTIMIZERS INFO IN EXPRESSIONS ON LIST.
		!ALSO PROPAGATE CONSTANTS TO EXPRESSIONS ONLY.
		!PROPAGATING CONSTANTS TO VARIABLES IS PRECLUDED
		!BY THE FACT THAT THERE ARE NO DEFINITION POINTS FOR
		!SINGLE VARIABLES ON ARGUMENT LISTS.

		IF .HEAD[CALLIST] NEQ 0 THEN
		BEGIN
			LOCAL ARGUMENTLIST AG;
			LOCAL BASE T1;
			AG_.HEAD[CALLIST];
			INCR I FROM 1 TO .AG[ARGCOUNT] DO
			BEGIN
				T1_.AG[.I,ARGNPTR];
				IF .T1[OPRCLS] NEQ DATAOPR THEN
					AG[.I,ARGNPTR]_LOKDEFPT(.T1);
			END;
		END;
	END;
	TESN;
	HEAD_.HEAD[BUSY];
END UNTIL .HEAD EQL 0;
!NOW GO THROUGH ALL THE STATEMENTS CREATED BY THE OPTIMIZER
!THESE ARE NOT IN THE GRAPH

HEAD_.TOP[SRCLINK];
WHILE .HEAD NEQ .BOTTOM DO
BEGIN
	!SKIP OVER STATEEMENTS IN INNER DO LOOPS
	IF .HEAD[SRCID] EQL DOID THEN
	BEGIN
		HEAD_.HEAD[DOLBL];
		!INDIRECT THROUGH THE SYMBOL TABEL TO GET ENDING STATEMENT
		HEAD_.HEAD[SNHDR];
	END ELSE
	IF .HEAD[SRCOPT] EQL 0 THEN
		IF .HEAD[SRCID] EQL ASGNID THEN
			ASGNPROP(.HEAD);
	HEAD_.HEAD[SRCLINK];
	IF .HEAD EQL 0 THEN RETURN;
END;
!FOR A MAIN PROGRAM LOOK AT THE STATEMENTS BETWEEN TOP AND LENTRY
!THIS MECHANISM IS THE CHEAPEST FOR ZEROING THE
!DEFPT FIELDS OF THSES EXPRESSIONS

IF .LOOP EQL 0 THEN
BEGIN
	HEAD_.SORCPTR<LEFT>;
	WHILE .HEAD[SRCISN] EQL 0 DO
	BEGIN
		IF .HEAD[SRCID] EQL ASGNID THEN
			ASGNPROP(.HEAD);
		HEAD_.HEAD[SRCLINK];
	END;
END;

END;
!
!*******************************
!
ROUTINE DEFSUB(NITIONPT,		!DEFINITION POINT
		OLDARG)=		!OLD ARGUMENT FOR RETURNING
BEGIN

!CHECK TO SEE IF THE DEFINITION POINT PASSED IS AN ASSIGNMENT OF
!OLDARG TO A CONSTANT. IF SO, RETURN CONSTANT ELSE
!RETURN OLDARG.

EXTERNAL DNEGCNST;
MAP BASE NITIONPT;
LOCAL INQUEST; MAP BASE INQUEST;

	IF .NITIONPT[SRCID] EQL ASGNID THEN
		IF .NITIONPT[LHEXP] EQL .OLDARG THEN
		BEGIN
			INQUEST_.NITIONPT[RHEXP];
			IF .INQUEST[OPR1] EQL CONSTFL THEN
			BEGIN
				INQUEST_VALCNV(.INQUEST);
				IF .NITIONPT[A2NEGFLG] THEN
				BEGIN
					INQUEST_NEGCNST(INQUEST);
					NITIONPT[A2NEGFLG]_0;
				END;
				IF .NITIONPT[A2NOTFLG] THEN
				BEGIN
					INQUEST_NOTCNST(INQUEST);
					NITIONPT[A2NOTFLG]_0;
				END;
				RETURN(.INQUEST);
			END;
		END;
	.OLDARG
END;

!*************************************
ROUTINE IFNN(STMT)=
BEGIN
	!STMT POINTS TO AN ARITHMETIC OR LOGICAL IF.
	!LIFEXPR OR AIFEXPR HAVE BECOME CONSTANTS.
	!CHECK THE NEG/NOT FLAGS AND FOLD THEM INTO THE CONSTANT.

	MAP BASE STMT;
	LOCAL BASE T1;
			T1_.STMT[LIFEXPR];
			IF .STMT[A1NEGFLG] THEN
			BEGIN
				STMT[LIFEXPR]_NEGCNST(T1);
				STMT[A1NEGFLG]_0;
			END;
			IF .STMT[A1NOTFLG] THEN
			BEGIN
				STMT[LIFEXPR]_NOTCNST(T1);
				STMT[A1NOTFLG]_0;
			END;
END;
ROUTINE ASGNNN(STMT)=
BEGIN
	!STMT IS AN ASIGNMENT STATEMENT.
	!THE RIGHT HAND SIDE IS A CONSTANT. CHECK THE NEG/NOT FLAGS
	!AND FOLD THEM INTO THE CONSTANT.
	MAP BASE STMT;
	LOCAL BASE T1;

			T1_.STMT[RHEXP];
			IF .STMT[A2NEGFLG] THEN
			BEGIN
				STMT[RHEXP]_NEGCNST(T1);
				STMT[A2NEGFLG]_0;
			END;
			IF .STMT[A2NOTFLG] THEN
			BEGIN
				STMT[RHEXP]_NOTCNST(T1);
				STMT[A2NOTFLG]_0;
			END;
END;
ROUTINE STMTPROP(STMT)=
BEGIN
!HANDLES A SINGLE VARIABLE AS A STATEMENT EXPRESSION AND TRIES TO
!PROPAGATE IT IF POSSIBLE
	EXTERNAL CSTMNT,FOLDAIF,DNEGCNST;

MAP PHAZ2 STMT;

SELECT .STMT[SRCID] OF NSET
ASGNID:	BEGIN
		LOCAL BASE PA:PB;
		PA_.STMT[RHEXP];
		IF .PA[OPR1] EQL VARFL THEN
		BEGIN
			IF .STMT[SRCOPT] EQL 0 THEN RETURN;
			PB_.STMT[OPDEF];
			IF .PB EQL 0 THEN RETURN;
			STMT[RHEXP]_DEFSUB(.PB,.STMT[RHEXP]);
			!CHECK FOR NEG AND NOT FLAGS IF IT PROPAGATED
			PA_.STMT[RHEXP];
			IF .PA[OPR1] NEQ CONSTFL THEN RETURN;
			!HERE WE KNOW ITS A CONSTANT
			!CATCH THOSE NASTY LITTLE NEG/NOT FLAGS.
			ASGNNN(.STMT);
		END;
			!RESET VAL FLGS
			PA_.STMT[RHEXP];
			IF .PA[OPRCLS] EQL DATAOPR THEN STMT[A2VALFLG]_1;
	END;

DOID:	BEGIN
		!NUMBER OF TIMES THROUGH A LOOP HAS BECOME A CONSTANT
	!BUT THAT MAY NOT BE MEANINGFUL. ON INNER DO LOOPS
	!THE FLAG NOFLCWDREG (SET BY P2S) SAYS THAT THIS
	!LOOP SHOULD NOT BE AN AOBJN LOOP. THE FLAG WILL BE SET
	!1. THE INDEX VARIABLE WAS AT A TOP LEVEL ARITHMETIC IF
	!2. THE INDEX VARIABLE WAS AT A TOP LEVEL LOGICAL IF
	!3. THE INDEX WAS AN ITEM ON AN I/O (BETTER B O) LIST
	!4. THE INDEX WAS AT A TOP LEVEL COMPUTED GO TO
	!5. THE INDEX WAS ON THE LHS OF AN ASSIGNMENT

		LOCAL BASE PA:PB;
	IF .STMT[INNERDOFLG] AND NOT .STMT[NOFLCWDREG] THEN
	BEGIN
		PA_.STMT[DOLPCTL];
		IF .PA[VALTYPE] EQL INTEGER THEN
			IF ABS(.PA[CONST2]) GEQ 0 AND ABS(.PA[CONST2]) LEQ #377777
			 AND .STMT[SSIZONE] THEN
			BEGIN
				PB_.STMT[DOM1];	!INITIAL VALUE
				IF .PB[VALTYPE] EQL INTEGER AND .PB[OPR1] EQL CONSTFL THEN
				IF .PB[CONST2] GEQ 0 AND .PB[CONST2] LEQ #377777 THEN
				BEGIN
				STMT[OTHDOFLGS]_0;
				STMT[FLCWD]_1;
				STMT[DOLPCTL]_MAKECNST(INTEGER,0,
						-(ABS(.PA[CONST2]))^18+.PB[CONST2]);
					RETURN(1);
				END;
			END;
	END;
		RETURN(0);
	END;
IFLID:	BEGIN
		LOCAL BASE PA:PB;
		EXTERNAL FOLDLIF,CSTMNT;
		PA_.STMT[OPDEF];
		IF .PA EQL 0 THEN RETURN;
		STMT[LIFEXPR]_DEFSUB(.PA,.STMT[LIFEXPR]);
		PB_.STMT[LIFEXPR];
		IF .PB[OPR1] NEQ CONSTFL THEN RETURN;
		!FIRST CHECK FOR NOT FLG AND NEG FLG
			IFNN(.STMT);
			PB_.STMT[LIFEXPR];
		PA_.STMT[LIFSTATE];	!SAVE FOR LATER
		CSTMNT_.STMT;
		FOLDLIF();
		!THE OPTIMIZER WILL TRY TO BE CLEVEL
		!LIFSTATE WILL BE EXAMINED. IF IT IS AN UNCONDITIONAL BRANCH
		!WE WILL DELETE ALL DEAD CODE UP TO THE NEXT LABELED
		!STATEMENT.
		!A COMPUTED GO TO IS NOT CONSIDIERED AN UNCONDITIONAL
		!BRANCH BECAUSE IT MAY GO TO THE NEXT STATEMENT IF THE
		!VALUE OF THE VARIABLE IS OUT OF RANGE
		!REMEMBER PA IS A POINTER TO THE STATEMENT IN QUESTION

		IF .PA[SRCID] EQL GOTOID OR .PA[SRCID] EQL AGOID THEN
		BEGIN
			PB_.PA[SRCLINK];
			WHILE .PB[SRCLBL] EQL 0 DO
			BEGIN
				PB_.PB[SRCLINK];
			END;
			PA[SRCLINK]_.PB;
		END;
	END;

IFAID:	BEGIN
		LOCAL BASE PA:PB;
		PA_.STMT[OPDEF];
		IF .PA EQL 0 THEN RETURN;
		STMT[AIFEXPR]_DEFSUB(.PA,.STMT[AIFEXPR]);
		PB_.STMT[AIFEXPR];
		IF .PB[OPR1] NEQ CONSTFL THEN RETURN
		!FIRST CHECK FOR NOT FLG AND NEG FLG
		IFNN(.STMT);
		CSTMNT_.STMT;
		FOLDAIF();
	END;
TESN;
END;

EXTERNAL MAKPR1;
MAP PEXPRNODE INDVAR:LENTRY:LEND;
ROUTINE REDUCE(CNODE)=
BEGIN
EXTERNAL GENLAB,ARSKOPT,DOWDP,TOP,MOVLAB;
OWN TEMP;
LOCAL A1NODE,A2NODE,PA,PB,T;
MAP OBJECTCODE DOWDP;
MAP PEXPRNODE CNODE:A1NODE:A2NODE:PA:PB:T;
MAP PHAZ2 TOP;

!INDVAR IS THE INDEX VARIABLE

	!CHECK THAT TWO LEAVES AND INTEGER MULTIPLY

	IF NOT (REDUCOP(CNODE)) THEN RETURN(.CNODE);

	!NOW WE KNOW THAT THERE IS A POTENTIAL REDUCTION

	!LOOK AT THE VARIABLES INVOLVED

	IF .CNODE[ARG2PTR] EQL .INDVAR OR
	   .CNODE[ARG1PTR] EQL .INDVAR THEN
	ELSE
		RETURN(.CNODE);

	!CHECK FOR NOT FLAGS

	IF .CNODE[A1NOTFLG] OR .CNODE[A2NOTFLG] THEN RETURN(.CNODE);

	!FIND THE NODES

	A1NODE_.CNODE[ARG1PTR]; A2NODE_.CNODE[ARG2PTR];


	!PUT THE NODES IN THE RIGHT ORDER

	IF .A1NODE EQL .INDVAR THEN
	BEGIN
		SWAPARGS(CNODE);
		A1NODE_.CNODE[ARG1PTR];
		A2NODE_.CNODE[ARG2PTR];
	END;

	!IN THE EVENT THAT THE OTHER LEAF IS
	!NOT A CONSTANT IT MUST BE A LOOP CONSTANT OR WE ARE NOT
	!INTERESTED IN IT.

	IF .A1NODE[OPR1] NEQ CONSTFL THEN
	BEGIN

		!MAKE SURE THE RESULT OF THE MULTIPLICATION IS
		!POSITIVE

		IF .CNODE[A1NEGFLG] AND .CNODE[A2NEGFLG]
			THEN
			ELSE
			IF .CNODE[A1NEGFLG] OR .CNODE[A2NEGFLG] THEN
				RETURN(.CNODE);

		!LOOK AT THE LIST OF VARIABLES ON THE DOCHNGL LIST
		!FOR THIS LOOP. DEFINITION POINT INFO IS NO LONGER
		!AVAILABLE, NEITHER ARE THE SYMBOL TABLE FLAGS FROM
		!FROM THE DEFINITION POINT ALGORITHM.
		!SEE DEF0, AND DEFCHANGE FOR A DESCRIPTION OF
		!THE DOCHNGL LIST.

		PA_.TOP[DOCHNGL];
		WHILE .PA NEQ 0 DO
		BEGIN
			IF .A1NODE EQL .PA[LEFTP] THEN
				RETURN(.CNODE);
			PA_.PA[RIGHTP];
		END;

		!IF WE GOT HERE IT IS A REGION CONSTANT
		!KEEP GOING**********

	END
	ELSE
	BEGIN

		!GENERATE CONSTANT WITH THE RIGHT SIGN

		IF .CNODE[A1NEGFLG] THEN
		BEGIN
			A1NODE_MAKECNST(INTEGER,0,-.A1NODE[CONST2]);
			CNODE[A1NEGFLG]_0
		END;
		IF .CNODE[A2NEGFLG] THEN
		BEGIN
			A1NODE_MAKECNST(INTEGER,0,-.A1NODE[CONST2]);
			CNODE[A2NEGFLG]_0
		END;
	END;

!********************************************************
!
!NOW WE HAVE A REDUCTION AND IT IS IN THE ORDER CONSTANT * INDVAR
!
!*******************************************************
	!SEE IF THIS REDUCTION HAS BEEN DONE BEFORE
	TEMP_0;
	!THE FORMAT OF THE LIST IS 
	!	LEFT HALF WORD POINTS TO REDUCTION VARIBALE
	!	RIGHT HALF POINTS TO CONSTANT
	IF .RDCCNT NEQ 0 THEN
	BEGIN
		INCR I FROM 1 TO .RDCCNT DO
			IF .RDCLST[.I]<RIGHT> EQL .A1NODE THEN
				TEMP_.RDCLST[.I]<LEFT>;
	END;
	IF .TEMP EQL 0 THEN
	BEGIN
		TEMP_RDCTMP();

		!NOW ADD THIS ONE TO THE LIST. IF THE LIST OVERFLOWS REINITIALIZE
		!AND START AGAIN.
		IF .RDCCNT EQL 8 THEN
		BEGIN
			RDCCNT_0;
			INCR I FROM 0 TO 8 DO
				RDCLST[.I]_0;
		END;
		!WE ARE SURE WE CAN NOW ADD
		RDCCNT_.RDCCNT+1;
		RDCLST[.RDCCNT]<LEFT>_.TEMP;
		RDCLST[.RDCCNT]<RIGHT>_.A1NODE;

		NAME<LEFT>_ASGNSIZ+SRCSIZ;
		!BUILD  A NODE OF
		!	TEMP =M1*CONSTANT
		!
		PA_CORMAN();
		PA[OPRCLS]_STATEMENT;
		PA[SRCID]_ASGNID;
		PA[LHEXP]_.TEMP;
		PA[A1VALFLG]_1;
		PA[RHEXP]_MAKPR1(.PA,ARITHMETIC,MULOP,INTEGER,
				.PM1,.A1NODE);

		!SINCE THIS EXPRESSION IS LINKED IN FRONT OF THE CURRENT LOOP
		!IT WILL BE LOCALLY OPTIMIZED WHEN THE NEXT OUTER LOOP IS
		!PROCESSED.

		!LINK THIS STATEMENT IN FRONT OF THE DO LOOP
		!ALSO MOVE ANY LABEL THAT IS ON THE
		!PHYSICAL SUCCESSOR OF LENTRY BACK TO THE REDUCTION

		T_.LENTRY[SRCLINK];
		LENTRY[SRCLINK]_.PA;
		PA[SRCLINK]_.T;
		IF .T[SRCLBL] NEQ 0 THEN
		BEGIN
			PB_PA[SRCLBL]_.T[SRCLBL];
			T[SRCLBL]_0;
			PB[SNHDR]_.PA;
		END;

		!
		!BUILD A NODE FOR
		!	TEMP=TEMP+CONSTANT*M3
		!
		NAME<LEFT>_ASGNSIZ+SRCSIZ;
		PA_CORMAN();
		PA[OPRCLS]_STATEMENT;
		PA[SRCID]_ASGNID;
		PA[LHEXP]_.TEMP;
		PA[A1VALFLG]_1;

		!THIS STATEMENT IS STILL WITHIN THIS LOOP SO IT WILL BE
		!LOCALLY OPTIMIZED NOW

		PB_ARSKOPT(MAKPR1(.PA,ARITHMETIC,MULOP,INTEGER,.PM3,.A1NODE));
		PA[RHEXP]_ARSKOPT(MAKPR1(.PA,ARITHMETIC,ADDOP,INTEGER,.PB,.TEMP));

		!LINK THIS AT LOOP END
		!
		T_.LEND[CLINK];
		LEND[CLINK]_.PA;
		PA[CLINK]_.T;
		!ADJUST ALL LABELS ON DO'S WITH END HERE TO POINT TO A
		!NEW LABEL.
		MOVLAB(.TOP[DOLBL],.PA,.TOP);
		!FIX LEND TO BE THIS NEW STATEMENT
		LEND_.PA;
		!
	END;		!HAVE NOT DONE THIS ONE YET


	!FIX UP THE VALFLGAS ON THE PARENT ONCE AND FOR
	!ALL HERE.

	PA_.CNODE[PARENT];
	IF .PA[OPRCLS] EQL STATEMENT THEN
	BEGIN
		IF .PA[SRCID] EQL ASGNID THEN
			PA[A2VALFLG]_1;
	END ELSE
	IF .PA[ARG1PTR] EQL .CNODE THEN
		PA[A1VALFLG]_1
	ELSE
		PA[A2VALFLG]_1;

	!LINK USE OF TEMP INTO THE TREE BY RETURNING IT
	.TEMP
END;
!
!*******************************
ROUTINE RDCTMP=
BEGIN
!CREATE A REDUCTION IN STRENGTH TEMPORARY

	NAME _ IDTAB;
	ENTRY_SIXBIT'.R' +MAKNAME(RDCCT);
	RDCCT_.RDCCT+1;
	TBLSEARCH()
END;
  
]BI