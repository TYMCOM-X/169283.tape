BASE 0
GLOBAL %LUDUPD

%LUDUPD


FIND %BYPT
FIND %INITTTY, %GETNUM, %GETTOKEN, %NUMOUT, %OCTOUT, %GETOCT, %QUERY
FIND %IMGIO, %HASH, %MAKE.SIXBIT, %CHR.OUT
FIND TOKEN(0)

GLOBAL CHK.ERR:, IO.ADR, IOTAB(WPF)

GLOBAL INDEX, OLD.CODE
GLOBAL OP, CHR	!VARIABLES FOR IMAGE I/O
GLOBAL D.BLK(128), D.INDEX, D.LOC, CH.DUL,  DUL.NAME, D.OV.BLK.N
GLOBAL SIZE.DUL
GLOBAL L.BLK(128), L.INDEX, LOC.HASH, CH.LUD, LUD.NAME, L.OV.BLK.N
GLOBAL L.SAVE(128), SIZE.LUD
GLOBAL SITE.31.NAME, SITE, CODE
GLOBAL CH.OUT, P, NUMBER, P1, TMP, USER(3), FOUND
GLOBAL STRINF(3), NAME.HASH, OLD.NAME(2), PRIV, DIST, RUB
GLOBAL L.OLD.INDEX, LOC.OLD.HASH, O.ENT.SIZE, OLD.HASH
GLOBAL SAV.EXT, UFD, LST.END:, FROMTTY:

GLOBAL %ERROR, %INITUPD, %LOKUP.LUD, %LUD.SEQ, %LOKUP.DUL
GLOBAL %LUD.LOOK, %DUL.LOOK, %DEL.FILES, %CALL.GETTAB
GLOBAL %FIND.STR, %FIND.L.ROOM, %FIND.D.ROOM, %MAKE.L.OVER
GLOBAL %MAKE.D.OVER, %CHK.IO.ERR, %GET.STR.INF, %SEND.O.WD



!COMMANDS
DEF DEL.USR AS 1
DEF ADD.USR AS 2
DEF CH.NAME AS 3
DEF CH.PRIV AS 4
DEF CH.STR AS 7
DEF CH.RUB AS 9
DEF UP.OTH.LUD AS 12
DEF LST.PRJ AS 16
DEF REVERSE AS 17
DEF LST.USR AS 18
DEF CH.DIST AS 22

!FLAGS
GLOBAL N.OFFICIAL	!=1 IF CHANGING NON-OFFICIAL LUD/DUL
GLOBAL TTYF	!=1 IF RUN FROM TTY; =0 IF FROM CIRCUITS
   DEF CIR AS 0

!IMAGE MODE OPERATIONS
DEF SET.UP.TTY AS 1
DEF SEND AS 2
DEF RECEIVE AS 3
DEF CIR.EOF AS OCT 377

!WORDS IN LUD/DUL ENTRIES
DEF WD.PPN AS 0
DEF WD.S.NAME AS 0
DEF WD.DIST AS 1
DEF WD.NAME AS 1	!DUL ENTRY ONLY
DEF WD.INIT AS 2
DEF WD.SIZE AS 2
DEF WD.RUB AS 2
DEF WD.PRIV AS 3
DEF WD.HASH AS 4
DEF WD.STRN AS 5
DEF WD.QIN AS 6
DEF WD.QOUT AS 7



GLOBAL TABLE ERRTAB(1:17)['ENTRY COMPLETED','NAME ALLREADY THERE',&
'NAME NOT FOUND','STR NOT FOUND','STR ALLREADY THERE','MISC',&
'BAD SITE','MISC','MISC','BILLING FILE ERROR','MISC','FILE BUSY',&
'MISC','FILE DELETION ERROR','USER STILL IN DUL','BAD CODE',&
'SIMPL ERROR']



DEF CHG.ENT(A) AS [L.BLK.UP; A; LUD.CL]
DEF C.IMGIO(A,B) AS [OP _ A; CHR _ B; IMGIO]
DEF CHECK.OK AS [IF TTYF # CIR THEN [IF QUERY('ALL ENTRIES CORRECT')&
	= NO THEN GO GETCMD]]
DEF CIR.WD.OUT(A,B) AS REPEAT B C.IMGIO(SEND,NCHV A)
DEF CR AS IF TTYF # CIR THEN MSG('$')
DEF D.BLK.UP AS [LOKUP.DUL(UPDATE); SETCP(CH.DUL,D.LOC);&
	RB(CH.DUL,SIZE.BLK,D.BLK); SETCP(CH.DUL,FIXCP(D.LOC))]
DEF DIST.BITS AS BYT(LUD(WD.DIST),8,0)
DEF DUL(A) AS D.BLK(D.INDEX+A)
DEF DUL.OVER AS [D.OV.BLK.N_GET.D.OV.BLK; LOKUP.DUL(READ);SETCP(CH.DUL,FIXCP(D.OV.BLK.N));&
	DUL.READ; CLOSE(CH.DUL)]
DEF DUL.READ AS [RB(CH.DUL,SIZE.BLK,D.BLK); D.INDEX _ 0]
DEF DUL.WRIT AS [WB(CH.DUL,SIZE.BLK,D.BLK); CLOSE(CH.DUL)]
DEF ERR.OUT(A) AS [IF TTYF = CIR THEN C.IMGIO(SEND,A) ELSE &
	[MSG(ERRTAB(A)); CR]]
DEF FIND.NAME AS [GET.WD('USER NAME: ',USER,12);&
   IF FOUND _ LUD.LOOK = THERE THEN MOVE SIZE.LUD.ENT FROM @LUD(WD.PPN) TO L.SAVE]
DEF FIXCP(A) AS (A-1)*SIZE.BLK
DEF G.CIR.NUM AS [P1 _ BYPT(NUMBER,8,24); NUMBER _ 0;&
   REPEAT 3 C.IMGIO(RECEIVE,NCHV P1)]
DEF G.CIR.WD(A,B) AS [P1 _ CHPT(A,-1); REPEAT B IMGIO(RECEIVE,P1)]
DEF GET.CODE AS [GETNUM.INF('$*'); IF CODE_NUMBER>MAX.CMD OR &
	CODE < MIN.CMD THEN ERROR(BAD.CODE)]
DEF GET.DIST AS [GET.NUM.INF('DISTRICT: '); DIST _ NUMBER]
DEF GET.D.OV.BLK AS HW(@DUL(WD.PPN),1)
DEF GET.L.OV.BLK AS HW(@LUD(WD.PPN),1)
DEF GET.NEW AS IF TTYF # CIR THEN MSG('NEW ')
DEF GET.NUM.INF(A) AS [IF TTYF # CIR THEN [MSG(A); GETNUM] &
   ELSE G.CIR.NUM]
DEF GET.O.NUM(A) AS [IF TTYF # CIR THEN [MSG(A); GETOCT] &
   ELSE G.CIR.NUM]
DEF GET.P.BITS AS [GET.O.NUM('PRIV. BITS: '); PRIV _ NUMBER]
DEF GET.WD(A,B,C) AS [IF TTYF # CIR THEN [MSG(A); GETTOKEN(2);&
   MAKE.SIXBIT(TOKEN,B,C)] ELSE G.CIR.WD(B,C)]
DEF HIGH.UFD.INDEX AS 125
DEF INIT.BIT AS BYT(LUD(WD.INIT),1,8)
DEF IN.VAL.LUD AS CHG.ENT(LUD(WD.HASH) _ 0)
DEF L.BLK.UP AS [LOKUP.LUD(UPDATE); SETCP(CH.LUD,FIXCP(LOC.HASH));&
   RB(CH.LUD,SIZE.BLK,L.BLK); SETCP(CH.LUD,FIXCP(LOC.HASH))]
DEF L.OV.BLK AS HW(@LUD(WD.PPN),1)
DEF LUD(A) AS L.BLK(L.INDEX+A)
DEF LUD.CL AS [LUD.WRIT; CLOSE(CH.LUD)]
DEF LUD.OVER AS [L.OV.BLK.N _ GET.L.OV.BLK; LOKUP.LUD(READ);&
   SETCP(CH.LUD,FIXCP(L.OV.BLK.N)); LUD.READ; CLOSE(CH.LUD)]
DEF LUD.READ AS [RB(CH.LUD,SIZE.BLK,L.BLK); L.INDEX _ 0]
DEF LUD.WRIT AS WB(CH.LUD,SIZE.BLK,L.BLK)
DEF MAKE.CHG(A) AS [CHECK.OK; CHG.ENT(A)]
DEF MAKE.VALID AS CHG.ENT(LUD(HASH) _ NAME.HASH)
DEF MIN.CMD AS 1
DEF MIN.SITE AS 31
DEF MAX.CMD AS 26
DEF MAX.SITE AS 34
DEF N.DUL.BLKS AS SIZE(CH.DUL)/SIZE.BLK
DEF NEW.ENT.SIZE AS 10
DEF N.LUD.BLKS AS SIZE(CH.LUD)/SIZE.BLK
DEF NO AS 0
DEF NOT.THERE AS 0
DEF OV.BIT AS OCT 400000
DEF OV.L.BIT AS HW(@LUD(WD.PPN),0)
DEF OV.D.BIT AS HW(@DUL(WD.PPN),0)
DEF READ AS 0
DEF RUB.BIT AS BYT(LUD(WD.RUB),1,33)
DEF S.CIR.NUM(A) AS [P1 _ BYPT(A,8,24); REPEAT 3 C.IMGIO(SEND,NCHV P1)]
DEF SEND.CIR(A) AS IF TTYF = CIR THEN C.IMGIO(SEND,A)
DEF SEND.NUM(A,B) AS [IF TTYF # CIR THEN [MSG(A); NUMOUT(B)]&
   ELSE S.CIR.NUM(B)]
DEF SEND.O.NUM(A,B) AS [IF TTYF # CIR THEN [MSG(A); OCTOUT(B)]&
   ELSE S.CIR.NUM(B)]
DEF SEND.WD(A,B,C) AS [P1 _ B; IF TTYF # CIR THEN [MSG(A);&
   REPEAT C CHR.OUT(NCHV P1 + OCT 40)] ELSE CIR.WD.OUT(P1,C)]
DEF SET.SITE AS [HW(@EXTARG(IOTAB),0) _ SITE.31.NAME;&
   SITBYT _ SITBYT + SITE - 31]
DEF SITBYT AS BYT(EXTARG(IOTAB),6,24)
DEF SIZE.BLK AS 128
DEF SIZE.DUL.ENT AS 3
DEF SIZE.INIT.INF AS 3
DEF SIZE.LUD.ENT AS BYT(LUD(WD.SIZE),7,0)
DEF SIZE.STR.INF AS 3
DEF SIZE.UFD.ENT AS 5
DEF THERE AS 1
DEF UFD.READ AS [RB(CH.UFD,SIZE.BLK,UFD.BLK); INDEX _ 0]
DEF UPDATE AS 1
DEF VERSION AS 23
DEF YES AS 1

!ERRORS
DEF OK AS 1
DEF NAME.THERE AS 2
DEF NAME.NT.THERE AS 3
DEF STR.NT.THERE AS 4
DEF STR.THERE AS 5
DEF MISC AS 6
DEF BAD.SITE AS 7
DEF BILL.FILE.ERR AS 10
DEF FILE.BUSY AS 12
DEF DEL.ERR AS 14
DEF IN.DUL AS 15
DEF BAD.CODE AS 16
DEF SIMPL.ERR AS 17

START: GO FROMCIR	!START HERE IF FROM A CIRCUIT
FROMTTY: TTYF _ 1; GO ST1	!HERE IF FROM TTY - SET TTYF
\\->FROMTTY
FROMCIR: TTYF _ CIR
ST1: 	INITUPD

GETCMD: GET.CODE
SITE _ 0
IF CODE # REVERSE THEN OLD.CODE _ CODE
DISP: DO CODE OF MIN.CMD:MAX.CMD
5: 6: 8: 10: 11: 13: 14: 15: 19: 20: 21: ERROR(BAD.CODE)

UP.OTH.LUD: GET.NUM.INF('SITE: ')
   IF MIN.SITE <= SITE _ NUMBER <= MAX.SITE THEN DO
	GET.CODE
	IF CODE = UP.OTH.LUD THEN ERROR(BAD.CODE)
	GO DISP
   	INC N.OFFICIAL
   END ELSE ERROR(BAD.SITE)

LST.PRJ: IO.ADR _ LST.END; GET.O.NUM('GAN: ')
   LOKUP.LUD(READ); LUD.READ
   LOOP DO
      LUD.SEQ
      IF HW(@LUD(WD.PPN),0) = NUMBER THEN DO
	IF DUL.LOOK = THERE THEN SEND.WD($$,BYPT(@DUL(WD.NAME),6,0),12)
	END
   END
   LST.END: SEND.CIR(CIR.EOF)

DEL.USR: FIND.NAME
   IF FOUND = THERE THEN DO
   IF LUD(WD.PPN) = OCT 1000001 OR LUD(WD.PPN) = OCT 1000004 THEN ERROR(13)
   CHECK.OK
   IF N.OFFICIAL = 0 THEN DEL.FILES
   L.BLK.UP; LUD(WD.HASH) _ 0; LUD.CL
  END ELSE ERROR(NAME.NT.THERE)

CH.PRIV: FIND.NAME
   IF FOUND = THERE THEN DO
   GET.NEW
   GET.P.BITS
   MAKE.CHG(LUD(WD.PRIV) _ PRIV)
  END ELSE ERROR(NAME.NT.THERE)

CH.STR: FIND.NAME
   IF FOUND = THERE THEN DO
   GET.WD('STR: ',STRINF(WD.S.NAME),4)
   IF FIND.STR = THERE THEN DO
	GET.NEW
	GET.STR.INF
	MAKE.CHG(MOVE SIZE.STR.INF FROM STRINF TO @LUD(INDEX))
   END ELSE ERROR(STR.NT.THERE)
  END ELSE ERROR(NAME.NT.THERE)

ADD.USR: FIND.NAME
   IF FOUND = NOT.THERE THEN DO
   FIND.L.ROOM
   GET.O.NUM('GAN: ')
   HW(@L.SAVE(WD.PPN),0) _ NUMBER
   GET.O.NUM('UUN: '); HW(@L.SAVE(WD.PPN),1) _ NUMBER
   BYT(L.SAVE(WD.SIZE),7,0) _ NEW.ENT.SIZE
   GET.NUM.INF('DISTRICT: '); BYT(L.SAVE(WD.DIST),8,0) _ NUMBER
   GET.O.NUM('PRIV.BITS: '); L.SAVE(WD.PRIV) _ NUMBER
   GET.STR.INF
   MAKE.CHG(MOVE NEW.ENT.SIZE FROM L.SAVE TO @LUD(WD.PPN); &
	   MOVE SIZE.STR.INF FROM STRINF TO @LUD(WD.STRN))
   IF DUL.LOOK = THERE THEN [IN.VAL.LUD; ERROR(IN.DUL)]
   FIND.D.ROOM
   D.BLK.UP
   DUL(WD.PPN) _ LUD(WD.PPN)
   MOVE 2 FROM USER TO @DUL(WD.NAME)
   DUL.WRIT
  END ELSE ERROR(NAME.THERE)

CH.DIST: FIND.NAME
   IF FOUND = THERE THEN DO
   GET.NEW
   GET.DIST
   MAKE.CHG(DIST.BITS _ DIST)
  END ELSE ERROR(NAME.NT.THERE)

CH.RUB: FIND.NAME
   IF FOUND = THERE THEN DO
   IF TTYF # CIR THEN DO
	RUB _ QUERY('$SET RESTRICTED USE BIT')
   END ELSE [C.IMGIO(RECEIVE,0); RUB _ CHR]
   MAKE.CHG(RUB.BIT _ RUB)
  END ELSE ERROR(NAME.NT.THERE)


REVERSE: IF MIN.CMD<=OLD.CODE<=MAX.CMD THEN DO
	DO OLD.CODE OF MIN.CMD:MAX.CMD
   DEL.USR: MAKE.VALID
   ADD.USR: IN.VAL.LUD
	D.BLK.UP; DUL(WD.PPN) _ DUL(WD.NAME) _ DUL(WD.NAME+1) _ 0
	DUL.WRIT
   CH.NAME: IN.VAL.LUD
      LOC.HASH _ LOC.OLD.HASH
      NAME.HASH _ OLD.HASH
      L.INDEX _ L.OLD.INDEX
      MAKE.VALID
      D.BLK.UP
      MOVE 2 FROM OLD.NAME TO @DUL(WD.NAME)
      DUL.WRIT
   CH.PRIV: CHG.ENT(LUD(PRIV) _ L.SAVE(PRIV))
   CH.STR: CHG.ENT(MOVE SIZE.STR.INF FROM L.SAVE TO @LUD(INDEX))
   CH.RUB: CHG.ENT(RUB.BIT _ BYT(L.SAVE(WD.RUB),1,33))
   CH.DIST: CHG.ENT(DIST.BITS _ BYT(L.SAVE(WD.DIST),8,0))
   LST.PRJ: REVERSE: LST.USR: UP.OTH.LUD: ERROR(BAD.CODE)
   END
  END ELSE ERROR(BAD.CODE)
   
CH.NAME: FIND.NAME
   IF FOUND = THERE THEN DO
   GET.WD('NEW USER NAME: ',USER(0),12)
   MAKE.CHG(LUD(WD.HASH) _ 0)
   O.ENT.SIZE _ SIZE.LUD.ENT
   L.OLD.INDEX _ L.INDEX
   LOC.OLD.HASH _ LOC.HASH
   OLD.HASH _ NAME.HASH
   IF LUD.LOOK = THERE THEN DO
	NAME.HASH _ OLD.HASH
	LOC.HASH _ LOC.OLD.HASH
	L.INDEX _ L.OLD.INDEX
	MAKE.VALID
	ERROR(NAME.THERE)
   END
   FIND.L.ROOM
   MOVE O.ENT.SIZE FROM L.SAVE TO @LUD(WD.PPN)
   IF DUL.LOOK = NOT.THERE THEN DO
	LOC.HASH _ LOC.OLD.HASH
	NAME.HASH _ OLD.HASH
	L.INDEX _ L.OLD.INDEX
	MAKE.VALID
	ERROR(NAME.NT.THERE)
   END
   MOVE 2 FROM @DUL(WD.NAME) TO OLD.NAME
   D.BLK.UP
   MOVE 2 FROM USER TO @DUL(WD.NAME)
   DUL.WRIT
   CHG.ENT(LUD(WD.HASH) _ NAME.HASH)
  END ELSE ERROR(NAME.NT.THERE)

LST.USR: FIND.NAME
   IF FOUND = THERE THEN DO
   SEND.CIR(OK)
   SEND.O.WD('PPN: ',@LUD(WD.PPN))
   S.CIR.NUM(LUD(WD.DIST))
   SEND.NUM('$DISTRICT: ',LUD(WD.DIST))
   SEND.O.NUM('$PRIV.BITS: ',LUD(WD.PRIV))
   INDEX _ WD.STRN; TMP _ 0
   IF INIT.BIT = 1 THEN [INDEX+_SIZE.INIT.INF; TMP _ SIZE.INIT.INF]
   TMP _ ((SIZE.LUD.ENT-TMP) - WD.STRN)/SIZE.STR.INF
   SEND.CIR(TMP)
   REPEAT TMP DO
	SEND.WD('$STRUCTURE: ',BYPT(@LUD(INDEX),6,0),4)
	SEND.NUM('$QUOTA IN: ',LUD(INDEX+1))
	SEND.NUM('$QUOTA OUT: ',LUD(INDEX+2))
	INDEX+_SIZE.STR.INF
	END
  END ELSE ERROR(NAME.NT.THERE)
END
GO GETCMD



%INITUPD
LOCAL L.TMP
IOCS(2)
IF TTYF # CIR THEN DO
   INITTTY(CHK.ERR)
   CH.OUT _ OPEN('TEL', SEQUEN+OUTPUT+CHARACTER,0,2)
   MOVE 72/CHARS.PER.WORD FROM ALL 0 TO TOKEN
   MSG('$LUD UPDATER - VERSION '); NUMOUT(VERSION)
END ELSE DO
   C.IMGIO(SET.UP.TTY,0)
   REPEAT 2 C.IMGIO(SEND,1)
   C.IMGIO(SEND,OCT 40)
   L.TMP _ 0
   WHILE L.TMP = 0 THEN DO
	C.IMGIO(RECEIVE,0); IF CHR = 1 THEN DO
	   C.IMGIO(RECEIVE,0); IF CHR = 1 THEN DO
	      C.IMGIO(RECEIVE,0); IF CHR = OCT 40 THEN INC L.TMP
	   END
	END
   END
END
P1 _ CHPT('(CUD10)LUD.31',-1)
   SETFID(IOTAB,@P1,0,CHK.ERR)
   LUD.NAME _ NAMARG(IOTAB)
   SITE.31.NAME _ HW(@EXTARG(IOTAB),0)
P1 _ CHPT('(CUD10)DUL.UFD',-1)
   SETFID(IOTAB,@P1,0,CHKERR)
   DUL.NAME _ NAMARG(IOTAB)
   UFD _ HW(@EXTARG(IOTAB),0)
INDEX _ D.LOC _ D.OV.BLK.N _ TMP _ CODE _ OLD.NAME(0) _ 0
OLD.NAME(1) _ L.OLD.INDEX _ LOC.OLD.HASH _ O.ENT.SIZE _ OLD.HASH _ 0
FOUND _ N.OFFICIAL _ SITE _ OLD.CODE _ 0
RETURN
END INIT.UPD



%LOKUP.LUD(MODE)
	!MODE = READ OR UPDATE
IF N.OFFICIAL = 0 THEN DO
   IF MODE = READ THEN CH.LUD _ OPEN('(NICRAM)LUD.SYS',DIRECT+INPUT+WORD,CHK.ERR)&
	ELSE CH.LUD _ OPEN('(NICRAM)LUD.SYS',DIRECT+UPDATE+WORD,CHK.ERR)
END ELSE DO
   NAMARG(IOTAB) _ LUD.NAME
   SET.SITE
   IF MODE = READ THEN CH.LUD _ OPEN(-IOTAB,DIRECT+INPUT+WORD,CHK.ERR)&
	ELSE CH.LUD _ OPEN(-IOTAB,DIRECT+UPDATE+WORD,CHK.ERR)
END
SIZE.LUD _ N.LUD.BLKS
RETURN
END LOKUP.LUD


%LOKUP.DUL(MODE)
IF N.OFFICIAL = 0 THEN DO
IF MODE = READ THEN CH.DUL _ OPEN('(NICRAM)DUL.SYS',DIRECT+INPUT+WORD,CHK.ERR)&
	ELSE CH.DUL _ OPEN('(NICRAM)DUL.SYS',DIRECT+UPDATE+WORD,CHK.ERR)
END ELSE DO
   NAMARG(IOTAB) _ DUL.NAME
   SET.SITE
   IF MODE = READ THEN CH.DUL _ OPEN(-IOTAB,DIRECT+INPUT+WORD,CHK.ERR)&
	ELSE CH.DUL _ OPEN(-IOTAB,DIRECT+UPDATE+WORD,CHK.ERR)
END
SIZE.DUL _ N.DUL.BLKS
RETURN
END LOKUP.DUL


%LUD.LOOK
	!LOOKUP USER,USER+1 IN LUD
HASH(USER(0),USER(1)); L.OV.BLK.N _ 0
LOKUP.LUD(READ)
SETCP(CH.LUD,FIXCP(LOC.HASH)); LUD.READ; CLOSE(CH.LUD)
WHILE LUD(WD.HASH) # NAME.HASH THEN DO
   EIF LUD(WD.PPN) = 0 THEN RETURN NOT.THERE
   ORIF LUD(WD.PPN) < 0 THEN LUD.OVER
   ELSE L.INDEX + _ SIZE.LUD.ENT
END
RETURN THERE
END LUD.LOOK



%DUL.LOOK
LOKUP.DUL(READ); D.OV.BLK.N _ 0
SETCP(CH.DUL,FIXCP(D.LOC _ (LUD(WD.PPN) MOD 101) + 1))
DUL.READ; CLOSE(CH.DUL)
WHILE DUL(WD.PPN) # LUD(WD.PPN) THEN DO
   IF DUL(WD.PPN) = 0 THEN RETURN 0
   IF DUL(WD.PPN) < 0 THEN DUL.OVER
   D.INDEX + _ SIZE.DUL.ENT
END
RETURN THERE
END DUL.LOOK


%CHK.IO.ERR
CHK.ERR: IF ERRNUM = EOFERR AND IO.ADR # 0 THEN GO ^IO.ADR
   IF TTYF = CIR THEN ERROR(SIMPL.ERR)
   MSG('$ERROR ON '); WFID(FIDP); CR
   DO ERRNUM OF TMFERR:CORERR
TMFERR: MSG('TOO MANY FILES OPEN')
FMDERR: MSG('BAD FILE MODE OR TYPE')
IFDERR: MSG('ILLEGAL FILE ID')
FNFERR: MSG('FILE NOT FOUND')
IUSERR: MSG('INVALID USER NAME')
PRTERR: MSG('PROTECTION FAILURE')
EOFERR: MSG('END OF FILE')
   END
   MSG('.$ ERROR '); NUMOUT(ERRNUM); EXIT
END CHK.IO.ERR


%ERROR(NUM)
ERR.OUT(NUM)
IF NUM = BAD.CODE THEN SEND.CIR(CODE)
IF NUM = SIMPL.ERR THEN SEND.CIR(ERRNUM)
IF TTYF = CIR THEN EXIT ELSE GO GETCMD

END ERROR


%LUD.SEQ
LOOP DO
   L.INDEX + _ SIZE.LUD.ENT
   IF LUD(WD.PPN) < 0 THEN LUD.OVER
   WHILE LUD(WD.PPN) <= 0 THEN LUD.READ
   IF LUD(HASH) # 0 THEN RETURN
END
END LUD.SEQ


%FIND.STR
!FIND STR IN STRINF IN LUD,
!IF FOUND, LOC IN INDEX UPDON RETURN
INDEX _ WD.STRN
WHILE LUD(INDEX) # STRINF(WD.S.NAME) THEN DO
   INDEX + _ SIZE.STR.INF
   IF INDEX >=SIZE.LUD.ENT THEN RETURN NOT.THERE
END
RETURN THERE
END FIND.STR


%FIND.L.ROOM
!MAKE ROOM FOR NEW ENTRY (NEW.ENT.SIZE WDS)
!CREATE OVERFLOW IF NECESSARY
L.INDEX _ 0
LOOP DO
   EIF LUD(WD.PPN) = 0 THEN DO
	IF L.INDEX + NEW.ENT.SIZE <= SIZE.BLK-1 THEN RETURN
	MAKE.L.OVER; RETURN
     END
   ORIF LUD(WD.PPN) < 0 THEN LUD.OVER
   ORIF LUD(HASH) = 0 THEN DO
	IF SIZE.LUD.ENT = NEW.ENT.SIZE THEN RETURN
	MOVE SIZE.BLK-(L.INDEX+SIZE.LUD.ENT) FROM @LUD(SIZE.LUD.ENT)&
	TO @LUD(SIZE.LUD.ENT-NEW.ENT.SIZE)
	RETURN
     END
   ELSE L.INDEX+_SIZE.LUD.ENT
END
END FIND.L.ROOM


%FIND.D.ROOM
D.INDEX _ 0
LOOP DO
   EIF DUL(WD.PPN) = 0 THEN DO
	IF D.INDEX + SIZE.DUL.ENT < SIZE.BLK THEN RETURN
	MAKE.D.OVER; RETURN
   END
   ORIF DUL(WD.PPN) < 0 THEN DUL.OVER
   ELSE D.INDEX + _ SIZE.DUL.ENT
END
END FIND.D.ROOM


%MAKE.L.OVER
L.BLK.UP
SIZE.LUD _ GET.L.OV.BLK _ L.OV.BLK.N _ SIZE.LUD + 1
OV.L.BIT _ OV.BIT; LUD.CL
MOVE SIZE.BLK FROM ALL 0 TO @LUD(WD.PPN)
LOKUP.LUD(UPDATE)
SETCP(CH.LUD,FIXCP(SIZE.LUD))
LUD.CL
L.INDEX _ 0
RETURN
END MAKE.L.OVER


%MAKE.D.OVER
D.BLK.UP; SIZE.DUL _ GET.D.OV.BLK _ D.OV.BLK.N _ SIZE.DUL + 1
OV.D.BIT _ OV.BIT; DUL.WRIT
MOVE SIZE.BLK FROM ALL 0 TO @DUL(WD.PPN)
LOKUP.DUL(UPDATE); SETCP(CH.DUL,FIXCP(SIZE.DUL))
DUL.WRIT
D.INDEX _ 0
RETURN
END MAKE.D.OVER



%DELFILES
LOCAL CH.UFD, UFDBLK(SIZE.BLK)
LOCAL T.PPN, HIGHJOB, ACC, USR.TAB(WPF)
ERRNUM _ 0
ACC _ OCT 20000012
HIGHJOB _ CALL.GETTAB(ACC)
WHILE DEC HIGH.JOB >= 0 THEN DO
   HW(ACC,0) _ HIGHJOB + 1; HW(ACC,1) _ 2
   IF CALL.GETTAB(ACC) = LUD(WD.PPN) THEN ERR.OUT(DEL.ERR)
END
PPNARG(IOTAB) _ OCT 1000001; NAMARG(IOTAB) _ LUD(WD.PPN)
EXTARG(IOTAB) _ UFD
CH.UFD _ OPEN(-IOTAB,DIRECT+INPUT+WORD,CHK.ERR)
PPNARG(IOTAB) _ LUD(WD.PPN)
UFD.READ
WHILE NAMARG(USR.TAB) _ UFD.BLK(INDEX) # 0 THEN DO
   IF INDEX >= HIGH.UFD.INDEX THEN UFD.READ ELSE DO
	HW(@EXTARG(USR.TAB),0) _ HW(@UFD.BLK(INDEX+1),0)
	DELETE(-USR.TAB,CHK.ERR)
	INDEX + _ SIZE.UFD.ENT
    END
END
END.UFD: DELETE(-IOTAB,CHK.ERR)
IF TTYF = CIR THEN DO
   C.IMGIO(SEND,1)
   SEND.O.WD('$PPN: ',^L.BLK+L.INDEX+WD.PPN)
END
RETURN
END DELFILES


%CALL.GETTAB(AC)
LOCAL DIDIT:
TMP _ EXU(OCT 47,AC,OCT 41,DIDIT)
ERROR(MISC)
DIDIT: RETURN TMP
END CALL.GETTAB

%GET.STR.INF
GET.WD('STRUCTURE: ',STRINF,4)
GET.NUM.INF('QUOTA IN: '); STRINF(1) _ NUMBER
GET.NUM.INF('QUOTA OUT: '); STRINF(2) _ NUMBER
RETURN
END GET.STR.INF


%SEND.O.WD(A,B)
IF TTYF # CIR THEN DO
   TMP _ HW(B,0)
   SEND.O.NUM(A,TMP)
   TMP _ HW(B,1)
   SEND.O.NUM(',',TMP)
END ELSE DO
   TMP _ HW(B,0)
   S.CIR.NUM(TMP)
   TMP _ HW(B,1)
   S.CIR.NUM(TMP)
END
RETURN
END SEND.O.WD



END LUDUPD
    