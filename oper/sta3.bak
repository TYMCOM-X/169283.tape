!THE STA3 MODULE MUST BE COMPILED IN THE ORDER: ST3HD,FIRST,TABLES,META72,STAMN3
!***COPYRIGHT 1972, DIGITAL EQUIPEMENT CORP., MAYNARD, MASS.***
!AUTHOR: T.E. OSTEN
GLOBAL BIND	STA3V=36;	!22-MAY-73
	SWITCHES LIST;
!	EXTERNAL PROGNAME,OUTZ,SCAN;
!THIS FORWARD DECLARATION AND THE FOLLOWING ROUTINES
!WERE PRODUCED BY THE FORTRAN PROGRAM HASHGEN.F4.
!THE NUMBER IN COMMENT'S IS THE STATEMENTS LOCATION
!IN THE HASH TABLE .
FORWARD
%  4%	PROTSTA,	!PROTECT - P.31
% 30%	IMPLSTA,	!IMPLICIT - P.30
% 32%	GLOBSTA,	!GLOBAL - P.32
% 60%	INCLSTA,	!INCLUDE - P.29
% 65%	EQUISTA,	!EQUIVALENCE - P.27
% 71%	NAMESTA,	!NAMELIST - P.33
% 79%	UNLOSTA,	!UNLOAD - P.35
% 88%	SKIPSTA,	!SKIPRECORD OR SKIPFILE - P.34
% 91%	EXTESTA,	!EXTERNAL - P.28
	ASSIGNMENT,	!SCALAR ASSIGNMENT - P.36
	DOLOOP,		!DO LOOP - P.37
	LOGICALIF,	!"LOGICAL" IF - P.38
	ARITHIF,	!"ARITHMETIC" IF - P.39
	STATEFUNC;	!STATEMENT FUNCTION - P.40
GLOBAL ROUTINE EQUISTA=
BEGIN
	MAP BASE T1 :T2; REGISTER BASE R1 :R2;
	BIND EQUIPLIT=PLIT 'EQUIVALENCE';
	EXTERNAL EQVPTR,CORMAN,NAME,NEWENTRY,BLDVAR,STK,SAVSPACE,ERROUT;
	MACRO ERR52 = ( ERROUT(E52))$,
		ERR53 = ( ERROUT(E53))$;
!MACRO GENERATES AN EQUIVALENCE GROUP ENTRY
!ENTRIES ARE LINKED BY NEWENTRY()
!
	MACRO GEQGROUP(EPTR)=
	BEGIN
		NAME _ EQVTAB; ENTRY _ R1 _ EPTR;
		R2 _ NEWENTRY();
		R1 _ EPTR[EQLID];
		IF .R1[IDATTRIBUT(INCOM)] THEN (R2[EQVINCOM]_1;
						R2[EQVHEAD] _ EPTR;
						);
		.R2
	END$;
	MACRO ELMNT =0,0,FULL$, ELMNT1 =0,1,FULL$, ELMNT2 =0,2,FULL$, ELMNT3 =0,3,FULL$;
!
ROUTINE GEQITEM(PTR)=	!GENERATE AN EQUIVALENCE ITEM ENTRY
BEGIN
	LOCAL BASE EPTR ; MAP BASE PTR :T1;
	NAME _ EQLTAB; EPTR _ NEWENTRY();	!MAKE AN EQUIV ITEM NODE
	EPTR[EQLID] _ R1 _ .PTR[ELMNT]; !PTR TO SYMBOL IN EQUIVALENCE
	R1[IDATTRIBUT(INEQV)] _ 1;
	IF .R1[IDATTRIBUT(DUMMY)] THEN ERR52; !IF DUMMY SYMBOL THEN ERROR
	IF .PTR[ELMNT1] NEQ 0
	THEN	!ITEM IS SUBSCRIPTED
	  BEGIN
		IF .R1[IDDIM] NEQ 0
		THEN	!ITEM ALSO DIMENSIONED
		  IF (T2 _ .PTR[ELMNT2]; .T2[ELMNT]<LEFT>) EQL 0
		  THEN
		  BEGIN !A SINGLE SUBSCRIPT
			 T1 _ @.T2[ELMNT]; !PTR TO SUBSCRIPT
			SAVSPACE(0,.T2); SAVSPACE(.PTR<LEFT>,.PTR);
			IF .T1[OPERSP] NEQ CONSTANT
			   THEN RETURN ERR53;
			!NOW GEN THE OFFSET
			EPTR[EQLDISPL] _ - .T1[CONST2]  !THE SUBSCRIPT VALUE
					+( T2 _ .R1[IDDIM]; T2 _ .T2[DIMENL(0)]; .T2[CONST2]);
			IF .R1[DBLFLG] THEN EPTR[EQLDISPL] _ .EPTR[EQLDISPL] * 2;
			EPTR[EQLLIST] _ 0;
		  END
		  ELSE
		  BEGIN
			T1 _ BLDVAR(.PTR);	!RETURNS PTR TO ARRAY REF EXPRESSION NODE
				!MUST DELETE THIS NODE AFTER USE
				!T1[ARG2PTR] MUST BE ZERO OTHERWISE
				!ERROR DUE TO NON-CONSTANT SUBSCRIPT
			IF .T1[ARG2PTR] NEQ 0 THEN ERR53;
			EPTR[EQLDISPL] _-(EXTSIGN(.T1[TARGET])); !HALF WORD VALUE MUST BE EXTENDED
			EPTR[EQLLIST] _ 0; !SO THAT WE KNOW DISPL IS COMPUTED
		  END
		ELSE	!SET EQLLIST PTR TO POINT TO LIST OF SUBSCRIPTS
			!FOR USE IN LATER CALCULATION WHEN DIMENSIONS ARE KNOWN
		  BEGIN
			R2 _ .PTR[ELMNT2]; T1 _ .R2[ELMNT]; SAVSPACE(0,.R2);
		!	NAME<LEFT>_ .T1<LEFT>+1;  R2_CORMAN(); !MAKE SUBSCRIPT LST BLOCK
		!	INCR SCR FROM  .T1 TO .T1+.T1<LEFT> DO
		!	BEGIN MAP BASE SCR; MACRO SCRFLGS = 0,0,LEFT$,SCRPTR=0,0,RIGHT$;
		!		R2[SCRPTR] _ .SCR[ELMNT];
		!		R2[SCRFLGS]_0;
		!		R2 _ .R2+1;
		!	END;
			EPTR[EQLINDIC]_ 1; !FLAG FOR NOT YET DIMENSIONED
			EPTR[EQLLIST] _ .T1<RIGHT>;	!PTR TO SUBSCRIPT LIST
		!	EPTR[EQLLIST]_.R2-.T1<LEFT>-1; !RESET R2 TO POINT TO FIRST WORD OF SUBSCRIPT LIST
		  END;
	  END	!OF ITEM IS SUBSCRIPTED
	ELSE	!ITEM NOT SUBSCRIPTED, IS IT DECLARED AN ARRAY?
	  BEGIN
		IF .R1[OPERSP] LSS FNNAME  THEN EPTR[EQLDISPL] _ 0 ELSE ERR52; !FUNCTION OR DUMMY IN EQUIVALENCE
	  END;
   RETURN .EPTR
END;	!OF ROUTINE GEQITEM
 LOCAL BASE GRUPHD;
LOCAL BASE ELISTPTR :EGROUP;	!PTR TO LAST EQUIV ITEM ENTRY
        IF SCAN(PLIT'VALENCE') LSS 0 THEN (ENTRY[1]_EQUIPLIT;ERROUT(E12));
        IF SYNTAX(EQUIVALENCE) LSS 0 THEN RETURN -1;
!SEMANTIC ANALYSIS BEGINS
T1 _ @.STK[0];	!LIST PTR TO LIST OF EQV GROUPS
INCR GROUP FROM .T1 TO .T1+.T1<LEFT> DO
BEGIN	MAP BASE GROUP;
	!EACH EQUIV GROUP IS COMPOSED OF 2 PARTS:
	!1. APTR TO THE FIRST EQUIV ITEM AND A LIST PTR TO A LIST
	!	OF EQUIV ITEM PTRS
	!EACH EQUIV ITEM IS A PTR TO A 3 OR 4 PART LIST
	!	.IDENTIFIER
	!	.OPTION (0 OR 1)
	!	.PTR TO SUBSCRIPT EXPRESSION LISTS PTR (IF OPTION 1)
	!	  OR A PTR TO A FIELDSPEC OPTION OR 0
	!	.IF OPTION IS 1 IN WORD 2 THEN A FOURTH WORD IS PRESENT
	!	  WHICH IS A PTR TO A FIELDSPEC OPTION OR IS ZERO
	!
	GRUPHD _ .GROUP[ELMNT];
	ELISTPTR _ GEQITEM(.GRUPHD[ELMNT]); !GENERATE AN EQUIVALENCE ITEM NODE
	EGROUP _ GEQGROUP(.ELISTPTR); !MACRO GENERATES AN EQUIVALENCE GROUP ENTRY
	R1 _ .GRUPHD[ELMNT1];	!PTR TO LIST EQUIVALENCED TO "GRUPHD"
	INCR LST FROM .R1 TO .R1+.R1<LEFT> DO
	BEGIN	!PROCESS LIST OF ITEMS EQUIVALENCE TO GROUP HEAD
	  MAP BASE LST;
		ELISTPTR _ .EGROUP[EQVLAST]; !PTR TO LAST ITEM IN GROUP
		ELISTPTR[EQLLINK] _ EGROUP[EQVLAST] _ GEQITEM(.LST[ELMNT]);
		R1 _ .EGROUP[EQVLAST]; R1 _ .R1[EQLID]; !PTR TO SYMBOL NODE
		IF .R1[IDATTRIBUT(INCOM)]
		THEN IF .EGROUP[EQVINCOM] THEN ERROUT(48)	!TWO ITEMS IN COMMON
					  ELSE (EGROUP[EQVINCOM] _ 1;
						EGROUP[EQVHEAD] _ .EGROUP[EQVLAST]
						);
	END;	!END OF INCR LST...
END;	!END OF INCR GROUP
	T1_@.STK[0];
	SAVSPACE(.T1<LEFT>,.T1); SAVSPACE(0,.STK[0]);
	.VREG
END;
GLOBAL ROUTINE EXTESTA=
BEGIN
	EXTERNAL TYPE,STK,SAVSPACE %(SIZE,LOC)%,BLDARRAY %(ONEARRAY LIST)%;
	BIND EXTEPLIT= PLIT'EXTERNAL';MAP BASE T1;MACRO ELMNT=0,0,FULL$;
        IF SCAN(PLIT'RNAL') LSS 0 THEN (ENTRY[1]_EXTEPLIT;ERROUT(E12));
        IF SYNTAX(EXTERNSPEC) LSS 0 THEN RETURN -1;
!SEMANTIC ANALYSIS BEGINS
	IDTYPE_-1;TYPE_2;T1_.STK[0];BLDARRAY(.T1[ELMNT]);
	SAVSPACE(0,@STK[0]);
	.VREG
END;
GLOBAL ROUTINE INCLSTA=
BEGIN
	BIND INCLPLIT= PLIT'INCLUDE';
	ENTRY[1] _ INCLPLIT; RETURN ERROUT(73); !STATEMENT NOT YET SUPPORTED
        IF SCAN(PLIT'UDE') LSS 0 THEN (ENTRY[1]_INCLPLIT;ERROUT(E12));
        IF SYNTAX(INCLUDESPEC) LSS 0 THEN RETURN -1;
!SEMANTIC ANALYSIS BEGINS
	.VREG
END;
GLOBAL ROUTINE DUMYIDMOD=
BEGIN
!FIXES UP THE VALTYPE OF DUMMY VARIABLES AFTER AN IMPLICIT
!STATEMENT WAS PROCESSED
EXTERNAL SORCPTR,TYPTAB;
REGISTER BASE R1:R2; MAP BASE T1:T2;
!
!DO THE FUNCTION NAME IF PRESENT
!
R1 _ .SORCPTR<RIGHT>;
R2 _ .R1[ENTSYM];
T2 _ .R2[IDSYMBOL]<30,6>; !FIRST CHARACTER
R2[VALTYPE] _ .TYPTAB[.T2-SIXBIT"A"]<RIGHT>;
!NOW REST OF DUMMYS
!
T1 _ .R1[ENTLIST]; !T1 POINTS TO ARGLIST
DECR I FROM .(.T1+1)<RIGHT>-1 TO 0 DO
BEGIN
	R2 _ .(.T1+2)[.I]<RIGHT>; !PTR TO ARG
	T2 _ .R2[IDSYMBOL]<30,6>;
	R2[VALTYPE] _ .TYPTAB[.T2-SIXBIT"A"]<RIGHT>;
END;
END;  !OF DUMTIDMOD
GLOBAL ROUTINE IMPLSTA=
BEGIN
	EXTERNAL DUMYIDMOD,SORCPTR;
	REGISTER BASE R1;
	BIND IMPLPLIT= PLIT'IMPLICIT';
        IF SCAN(PLIT'ICIT') LSS 0 THEN (ENTRY[1]_IMPLPLIT;ERROUT(E12));
        IF SYNTAX(IMPLICIT) LSS 0 THEN RETURN -1;
!SEMANTIC ANALYSIS BEGINS
	IF (R1 _ .SORCPTR<RIGHT>) NEQ 0
	THEN IF .R1[SRCID] EQL ENTRID
		  THEN DUMYIDMOD();
	.VREG
END;
GLOBAL ROUTINE PROTSTA=
BEGIN
	EXTERNAL STK,BLDARRAY %(ONEARRAY LIST)%,SAVSPACE %(SIZE,LOC)%,TYPE;
	MAP BASE T1;MACRO ELMNT=0,0,FULL$;
	BIND PROTPLIT= PLIT'PROTECT';
	ENTRY[1] _ PROTPLIT;
	ERROUT(73);	!STATEMENT NOT YET SUPPORTED
	UNTIL .C EQL ";" DO CHAR();
!        IF SCAN(PLIT'ECT') LSS 0 THEN (ENTRY[1]_PROTPLIT;ERROUT(E12));
!        IF SYNTAX(PROTECT) LSS 0 THEN RETURN -1;
!!SEMANTIC ANALYSIS BEGINS
!	IDTYPE_-1;TYPE_3;T1_.STK[0];
!	BLDARRAY(.T1[ELMNT]);SAVSPACE(0,@STK[0]);
!	.VREG
	RETURN -1
END;
GLOBAL ROUTINE GLOBSTA=
BEGIN
	EXTERNAL STK,BLDARRAY %(ONEARRAY LIST)%,SAVSPACE %(SIZE,LOC)%,TYPE;
	MAP BASE T1;MACRO ELMNT=0,0,FULL$;
	BIND GLOBPLIT= PLIT'GLOBAL';
        IF SCAN(PLIT'AL') LSS 0 THEN (ENTRY[1]_GLOBPLIT;ERROUT(E12));
        IF SYNTAX(GLOBALSPEC) LSS 0 THEN RETURN -1;
!SEMANTIC ANALYSIS BEGINS
	IDTYPE_-1;TYPE_1;T1_.STK[0];
	BLDARRAY(.T1[ELMNT]);SAVSPACE(0,@STK[0]);
	.VREG
END;
GLOBAL ROUTINE NAMESTA=
BEGIN
%
	ROUTINE EXPECTS STK[0] TO CONTAIN A POINTER TO ALIST  POINTER
	OF THE FORM (COUNT,,PTR). THE LIST PTR POINTS TO A LIST OF
	COUNT+1 POINTERS THAT EACH POINT TO A 4 WORD BLOCK OF THE FORM:
	0. /
	1. NAMELIST NAME PTR
	2. /
	3. LIST POINTER (COUNT,,LISTPTR)

	WHERE THE LIST POINTER IN 3. POINTS TO ALIST OF IDENTIFIER PTRS
	THAT ARE THE ITEMS IN THE NAMELIST
%
MACRO ERR58(X)=( ENTRY[1] _  X; ERROUT(58))$;
MACRO ELMNT = 0,0,FULL$, ELMNT1=0,1,FULL$, ELMNT2=0,2,FULL$, ELMNT3=0,3,FULL$;
EXTERNAL SAVSPACE,NAME,NEWENTRY,STK,CORMAN,ENTRY,ERROUT;
REGISTER BASE R1:R2;
MAP BASE T1:T2;
	BIND NAMEPLIT= PLIT'NAMELIST';
        IF SCAN(PLIT'LIST') LSS 0 THEN (ENTRY[1]_NAMEPLIT;ERROUT(E12));
        IF SYNTAX(NAMELIST) LSS 0 THEN RETURN -1;
!SEMANTIC ANALYSIS BEGINS
	T1 _ @.STK[0];	!GET PTR TO NAMELIST BLOCK
	INCR NLST FROM .T1 TO .T1+.T1<LEFT> DO
	BEGIN
		MAP BASE NLST;
		T1 _ .NLST[ELMNT];	!PTR TO BLOCKLIST NAME
		R1 _ .T1[ELMNT1];	!PTR TO NAMELIST NAME
		IF ((.R1[IDATTRIBUT(ALLOFTHEM)] AND #777777) OR
			(.R1[IDDIM] NEQ 0) OR (.R1[OPRSP1] EQL FNNAME1))
			THEN ERR58(R1[IDSYMBOL]);	!NAME ALREADY INUSE
		R1[IDATTRIBUT(NAMNAM)] _ 1;
		R2 _ .T1[ELMNT3]; !PTR TO LIST OF NAMELST ANME PTRS
		SAVSPACE(.T1<LEFT>,.T1);
		INCR ILST FROM .R2 TO .R2+.R2<LEFT> DO
		BEGIN
			MAP BASE ILST;
			T2 _ .ILST[ELMNT]; !GET PTR TO NAMELIST ITEM
			!CHECK FOR ILLEGAL NAMES
			IF (.T2[IDATTRIBUT(DUMMY)] OR .T2[IDATTRIBUT(NAMNAM)]
				OR .T2[IDATTRIBUT(COMBL)] OR (.T2[OPRSP1] EQL FNNAME1) 
				OR .T2[IDATTRIBUT(SFN)]
			   )
			   THEN ERR58(T2[IDSYMBOL])
			   ELSE ILST[ELMNT]<LEFT> _ 0;
		END; !END OF INCR ILST
		NAME _ NAMTAB;  T2 _ NEWENTRY();
		T2[NAMLIST] _ .R2<RIGHT>;
		T2[NAMCNT] _ .R2<LEFT>+1;
		T2[NAMLID] _ .R1; !NAMLIST NAME
	END;	!OF INCR NLST
	T1 _ @.STK[0]; SAVSPACE(.T1<LEFT>,.T1); SAVSPACE(0,.STK[0]);
	.VREG
END;
GLOBAL ROUTINE SKIPSTA=
BEGIN
	EXTERNAL BLDREPT;
	BIND	SKIPPLIT= PLIT(PLIT'SKIPRECORD?0',PLIT'SKIPFILE'),
		SCANPLIT= PLIT(PLIT'ECORD?0',PLIT'ILE?0');
	MACRO REC=0$,FIL=1$;REGISTER R;
	SIGCHAR;
	IF .C EQL "R" THEN R_REC ELSE R_FIL;
	IF SCAN(.SCANPLIT[.R]) LSS 0 THEN (ENTRY[1]_.SKIPPLIT[.R];ERROUT(E12));
	IF SYNTAX(SKIPSPEC) LSS 0 THEN RETURN -1;
!SEMANTIC ANALYSIS BEGINS
	BLDREPT(IF .R EQL REC THEN SKIPDATA ELSE SKIPFDATA);
	.VREG
END;
GLOBAL ROUTINE UNLOSTA=
BEGIN
	EXTERNAL BLDUTILITY;
	BIND UNLOPLIT= PLIT'UNLOAD?0';
	IF SCAN(PLIT'AD') LSS 0 THEN (ENTRY[1]_UNLOPLIT;ERROUT(E12));
	IF SYNTAX(UNLOAD) LSS 0 THEN RETURN -1;
!SEMANTIC ANALYSIS BEGINS
	BLDUTILITY(UNLODATA);
	.VREG
END;
GLOBAL ROUTINE ASSIGNMENT =
BEGIN
	BIND ASPLIT=PLIT'ASSIGNMENT';
	MAP BASE T1:T2;REGISTER BASE R1:R2;
	EXTERNAL STK,SP,NEWENTRY %()%,SAVSPACE %(SIZE,LOC)%,MULTIASGN %()%,PROGNAME;
	MACRO ELMNT=0,0,FULL$,ELMNT1=0,1,FULL$,ELMNT2=0,2,FULL$;
	IF SYNTAX(ASSIGNSPEC) LSS 0 THEN RETURN -1;
!------------------------------------------------------------------------------------------------------------------
!	SYNTAX RETURNS A LIST POINTER (COUNT^18+LOC) IN STK[0]. THIS LIST CONTAINS:
!
!	IDENTIFIER(20^18+LOC) - TO BE ASSIGNED
!	OPTION 0 - NO FIELDSPEC	OR OPTION 1 - FIELDSPEC POINTER FOLLOWS
!				FIELDSPEC(2^18+LOC) - POINTER TO FIELDSPEC VALUES
!	REPEAT LIST(COUNT^18+LOC) - POINTER TO A LIST OF POINTERS TO LOGICAL EXPRESSIONS
!
!	THE LAST LOGICAL EXPRESSION IN THE LIST IS THE VALUE TO BE ASSIGNED TO THE IDENTIFIER AND
!	THE REMAINDER OF THE LIST. THE REMAINDER OF THE LIST SHOULD BE IDENTIFIERS, ARRAY REFERENCES,
!	 OR FIELD REFERENCES. THIS MUST BE CHECKED SINCE THE SYNTAX ALLOWS ANY LOGICAL EXPRESSION.
!	THE REPEAT LIST WHICH REPRESENTS A MULTIPLE ASSIGNMENT IS HANDLED AS IF THE MULTIPLE ASSIGNMENT WERE A
!	SERIES OF ASSIGNMENTS. FOR EXAMPLE: A=B=C=1; IS THE SAME AS A=1;B=1;C=1; .
!------------------------------------------------------------------------------------------------------------------
	T1_.STK[0];	!T1_LIST POINTER (COUNT^18+LOC)
	T2_.T1[ELMNT];	!T2_LOC(IDENTIFIER)
	T2[IDATTRIBUT(STORD)] _ 1; !VARIABLE IS STORED INTO (FOR ARGLIST OPTIMIZATION)
	IF (ISNOTVAR(T2)) THEN RETURN .VREG;
	IF .T2[PARENLSTFLG] THEN IF .T2[IDSYMBOL] NEQ .PROGNAME THEN
	BEGIN
		ENTRY[2]_T2[IDSYMBOL];
		IF .T2[OPERSP] GEQ FNNAME THEN
			(ENTRY[1]_FNPLIT;ENTRY[3]_ARGPLIT)
			ELSE (ENTRY[1]_ARPLIT;ENTRY[3]_SUBSPLIT);
		RETURN ERROUT(E4)
	END;
	MULTIASGN()
END;
GLOBAL ROUTINE DOLOOP =
BEGIN
	BIND DOPLIT=PLIT'DO LOOP';
	MAP BASE T1:T2;REGISTER BASE R1:R2;
	EXTERNAL STK,SP,NEWENTRY %()%,SAVSPACE %(SIZE,LOC)%,ONEPLIT,TBLSEARCH %()%,CORMAN %()%;
	EXTERNAL DONESTLEVEL,	!CURRENT LEVEL OF DO NESTING
		 LASDOLABEL,	!LABEL PTR TO LAST LABEL SEEN IN DO STATEMENT
		DOXPN,	!MAKES DO INITIALIZATION TREE
		DOINDEX,	!PTR TO CURRENT DO INDEX VARIABLE
		ADDLOOP;	!MAKES DO TREE STRUCTURE FOR OPTIMIZER
	LOCAL BEFOREDO;	!HOLDS DO PREDECESSOR
	MACRO ADDOLAB(X)=	NAME<LEFT> _ 1; !LINK IN NEW LABEL
				T2 _ CORMAN();
				T2[ELMNT] _ .LASDOLABEL; !SAVE LAST
				LASDOLABEL<LEFT> _ .T2; LASDOLABEL<RIGHT> _ X
				$;
!
	MACRO
	LBL=0,0,FULL$,INDX=0,1,FULL$,INITIAL=0,2,FULL$,FINAL=0,3,FULL$,
	INCROPT=0,4,FULL$,INCREMENT=0,5,FULL$,ELMNT=0,0,FULL$;
	IF SCAN(PLIT'DO') LSS 0 THEN (ENTRY[1]_DOPLIT;RETURN ERROUT(E12));
	IF SYNTAX(DOSPEC) LSS 0 THEN RETURN -1;
!------------------------------------------------------------------------------------------------------------------
!	THE SYNTAX ROUTINE RETURNS A POINTER IN STK[0] WHICH POINTS TO THE LIST:
!
!	CONSTANT(21^18+LOC) - LABEL OF DO TERMINAL STATEMENT
!	IDENTIFIER(20^18+LOC) - DO INDEX
!	EXPRESSION(1^18+LOC) - POINTER TO POINTER TO INITIAL VALUE OF DO INDEX
!	EXPRESSION(1^18+LOC) - POINTER TO POINTER TO FINAL VALUE OF DO INDEX
!	OPTION 0 - INCREMENT OF DO INDEX IS ONE
!	OPTION 1 - INCREMENT OF DO INDEX IS EXPRESSION FOLLOWING
!	LIST(1^18+LOC) - POINTER TO POINTER TO POINTER TO INCREMENT OF DO INDEX
!------------------------------------------------------------------------------------------------------------------
	T1_.STK[0];	!T1_LOC(LIST)
	R1_.T1[LBL];R2_.T1[INDX];
	ADDOLAB(.R1);	!LINK IN NEW LOOP LABEL TO PREVIOUS ONES
	IF (T2_.R1[SNHDR]) NEQ 0 THEN !ERROR DO TERMINAL ALREADY SEEN
		(ENTRY[1]_.T2[SNUMBER];ENTRY[2]_.T2[SRCISN];RETURN ERROUT(E20));
	IF (ISNOTVAR(R2)) THEN RETURN .VREG;
	IF .R2[PARENLSTFLG] THEN
	BEGIN
		ENTRY[2]_R2[IDSYMBOL];
		IF .R2[OPERSP] GEQ FNNAME THEN
			(ENTRY[1]_FNPLIT;ENTRY[3]_ARGPLIT)
			ELSE (ENTRY[1]_ARPLIT;ENTRY[3]_SUBSPLIT);
		RETURN ERROUT(E4)
	END;
	BEFOREDO _ .SORCPTR<RIGHT>; !PTR TO STATEMENT NODE PRECEDING DO
	NAME_IDOFSTATEMENT_DODATA;NAME<RIGHT>_SORTAB;
	T2_NEWENTRY();
	T2[DOPRED] _ IF .BEFOREDO EQL 0 THEN .SORCPTR<LEFT> ELSE .BEFOREDO; !LINK IN PREVIOUS STATEMENT NODE
	DONESTLEVEL _ .DONESTLEVEL+1;
	T2[DOSYM]_.R2;T2[DOLBL]_.R1;
	IF .DOINDEX<RIGHT> EQL .R2<RIGHT>
	THEN (ENTRY[1] _ R2[IDSYMBOL]; ERROUT(21))   !DO INDEX ALREADY ACTIVE
	ELSE DOINDEX _ .R2;		!PTR TO DO INDEX VARIABLE
!
!CHECK IF THIS DO ENDS ANOTHER DO
!
	IF (R2_.T2[SRCLBL]) NEQ 0
	THEN IF .R2[SNDOLNK] NEQ 0
		THEN (ERROUT(64)); !YES DO ENDS ANOTHER DO ERROR
!
!NOW SEE IF DO TERMINUS HAS ALREADY APPEARED
!
	IF .R1[SNUMBER] EQL 0 THEN RETURN ERROUT(19);
	IF .R1[SNHDR] NEQ 0 THEN ERROUT(68); !DO TERMINAL LABEL ALREADY DEFINES A STATEMENT
	R2_.R1[SNDOLNK];R1[SNDOLVL]_.R1[SNDOLVL]+1;NAME<LEFT>_1;R1[SNDOLNK]_CORMAN();
	(@VREG)<LEFT>_@T2;(@VREG)<RIGHT>_@R2;
	R1_.T1[INITIAL];R2_.T1[FINAL];T2[DOM1]_.R1%[ELMNT]%;T2[DOM2]_.R2%[ELMNT]%;
!	SAVSPACE(.R1<LEFT>,@R1);SAVSPACE(.R2<LEFT>,@R2);
	IF .T1[INCROPT] NEQ 0 THEN
	BEGIN
		R1_.T1[INCREMENT];T2[DOM3]_.R1[ELMNT];
		SAVSPACE(.R1<LEFT>,.R1);
	END ELSE T2[DOM3]_.ONEPLIT;
	SAVSPACE(.T1<LEFT>,.T1);
	ADDLOOP(.DONESTLEVEL); !FOR OPTIMIZER
	DOXPN(.T2<RIGHT>);	!CREATE THE NODE FOR THE DO INITIALIZATION CODE
	.VREG
END;
GLOBAL ROUTINE LOGICALIF =
BEGIN
	BIND LIFPLIT= PLIT'LOGICAL IF';
	LOCAL BASE IFEXPR,LASTTRUESRC;
	MAP BASE T1:T2;
	EXTERNAL SAVSPACE,	%SAVSPACE(SIZE,PNTR)%
		CLASSIFIER,	%CLASSIFIER()%
		STK,SP,
		FORMSTA,
		NEWENTRY;	%NEWENTRY()%
	MACRO ELMNT=0,0,FULL$;
	IF .C NEQ "(" THEN (ENTRY[1]_LIFPLIT;ERROUT(E12));
	IF SYNTAX(LOGICALIFSPEC) LSS 0 THEN RETURN -1;
	IFEXPR _ .STK[0];	!SAVING PTR TO EXPR PTR
!SEMANTIC ANALYSIS BEGINS
	IF (T1_CLASSIFIER()) EQL 0 THEN (RETURN ERROUT(E10))
		ELSE IF .T1 EQL LOGICALIF THEN (RETURN ERROUT(E23))
			ELSE IF .T1 EQL DOLOOP THEN (RETURN ERROUT(E23))
				ELSE IF .T1 EQL FORMSTA THEN RETURN ERROUT(23);
!
!STK[0] CONTAINS A PTR TO PTR TO PTR TO EXPRESSION NODE
!
	STK[0] _ .IFEXPR; !RESTORING THE PTR
	T2_.STK[0];IFEXPR_.T2[ELMNT];SAVSPACE(.T2<LEFT>,.T2);LASTTRUESRC_.LASTSRC;
	SP_-1; !RESET STK PTR FOR PARSE
	IF (.T1)() LSS 0 THEN RETURN;	!STATEMENT HAD AN ERROR
!------------------------------------------------------------------------------------------------------------------
!	REMOVE THE FALSE SOURCE NODE FROM THE LINKED LIST OF SOURCE STATEMENTS
!------------------------------------------------------------------------------------------------------------------
	T1_.LASTSRC; IF .LASTTRUESRC EQL 0 THEN LASTSRC _ .SORCPTR<LEFT> ELSE LASTSRC_.LASTTRUESRC;
	IF .T1[SRCID] EQL SFNID %STATEMENT FUNCTION% THEN ERROUT(23);
	NAME_IDOFSTATEMENT_IFLDATA; NAME<RIGHT> _ SORTAB;T2_NEWENTRY();
	T2[LIFEXPR]_.IFEXPR;T2[LIFSTATE]_.T1;
	IF .IFEXPR[OPRCLS]NEQ DATAOPR
		THEN IFEXPR[PARENT] _ .T2;	!EXPR NODE POINTS TO SRC NODE
	T1[SRCLBL] _ 0;	!REMOVING ANY LABEL THE STATEMENT HAD FROM THE STATEMENT PART
END;
GLOBAL ROUTINE ARITHIF =
BEGIN
	EXTERNAL STK,SP,NEWENTRY %()%,SAVSPACE %(SIZE,LOC)%,TBLSEARCH %()%;
	BIND AIFPLIT= PLIT'ARITHMETIC IF';
	MAP BASE T1:T2;REGISTER BASE R1:R2;
	MACRO	IFEXPR=0,0,FULL$,LTLABEL=0,1,FULL$,EQLABEL=0,2,FULL$,
		GTOPT=0,3,FULL$,GTLABEL=0,4,FULL$,ELMNT=0,0,FULL$;
	BIND IFPLIT=PLIT 'IF(';
	IF SCAN(IFPLIT) LSS 0 THEN (ENTRY[1]_AIFPLIT;ERROUT(E12));
	IF SYNTAX(ARITHIFSPEC) LSS 0 THEN RETURN -1;
!SEMANTIC ANALYSIS BEGINS
	T1_.STK[0];	!T1_LOC(LIST)
	R1_.T1[LTLABEL];R2_.T1[EQLABEL];
	IF .R1[VALTYPE] NEQ INTEGER THEN (RETURN ERROUT(E25))
	ELSE
		IF .R1[CONST2] GTR 99999 THEN (RETURN ERROUT(E19));
	IF .R2[VALTYPE] NEQ INTEGER THEN (RETURN ERROUT(E25))
	ELSE
		IF .R2[CONST2] GTR 99999 THEN (RETURN ERROUT(E19));
	IF .T1[GTOPT] NEQ 0 THEN
	BEGIN
		T2_.T1[GTLABEL];T1_LMNT];SAVSPACE(.T2<LEFT>,@T2);
		IF .T1[VALTYPE] NEQ INTEGER THEN (RETURN ERROUT(E25))
		ELSE
			IF .T1[CONST2] GTR 99999 THEN (RETURN ERROUT(E19));
	END ELSE T1_@R2;
	NAME_IDOFSTATEMENT_IFADATA;NAME<RIGHT>_SORTAB;T2_NEWENTRY();
	!
	!SEE IF THIS STATEMENT IS TERMINAL OF A DO
	!
	IF .T2[SRCLBL] NEQ 0
	THEN BEGIN LOCAL BASE LBL;
		LBL _ .T2[SRCLBL];
		IF .LBL[SNDOLNK] NEQ 0 THEN ERROUT(67);
		!ERROR
	     END;
	NAME_LABTAB;
	ENTRY[0]_.R1[CONST2];T2[AIFLESS]_TBLSEARCH();
	ENTRY[0]_.R2[CONST2];T2[AIFEQL]_TBLSEARCH();
	ENTRY[0]_.T1[CONST2];T2[AIFGTR]_TBLSEARCH();
	T1_.STK[0]; R1 _ T2[AIFEXPR]_.T1[ELMNT];
	!
	!CHECK TO POINT BACK TO SRC NODE
	!
	IF .R1[OPRCLS] NEQ DATAOPR
		THEN R1[PARENT] _ .T2;	!EXPR POINTS BACK TO SRC NODE
	SAVSPACE(.T1<LEFT>,@T1);
END;
ROUTINE BLDSFN=	!BUILDS A STATEMENT FUNCTION SOURCE TREE NODE
BEGIN
MACRO ELMNT = 0,0,FULL$, ELMNT1 = 0,1,FULL$, ELMNT2 = 0,2,FULL$;
EXTERNAL STK,NEWENTRY,CORMAN,NAME,ASTATFUN,IDOFSTATMENT,SAVSPACE,ASGNTYPER;
MAP BASE T1:T2; REGISTER BASE R1:R2;
!
!STK[0] CONTAINS APTR TO THE OUTPUT FROM A STATEFUNCTION PARSE
!
!BUILD THE NODE
!
	NAME _ IDOFSTATEMENT _ SFNDATA; NAME<RIGHT> _ SORTAB;
	R1 _ NEWENTRY();
	T1 _ .STK[0];
	R1[SFNNAME] _ .ASTATFUN; !PTR PUT IN ASTATFUN BY STATEFUNC ROUTINE
	R1[SFNEXPR] _ R2 _  .T1[ELMNT1]; !PTR TO EXPRESSION
	ASGNTYPER(.R1);	!CHECK FOR TYPE CONVERSION
	R2 _ .R1[SFNEXPR];	!RESTORE EXPRESSION PTR
	IF .R2[OPRCLS] NEQ DATAOPR THEN R2[PARENT] _ .R1; !PTR TO STATEMENT FUNCTION AS PARENT
!BUILD THE NEW ARGLIST BLOCK 2 WORDS LONGER THAN NUM OF ARGS
	NAME<LEFT> _ .T1[ELMNT]<LEFT>+1+2;
	T2 _ CORMAN();
	R2 _ .T1[ELMNT];
	T2[ELMNT1] _ .T1[ELMNT]<LEFT>+1; !NUMBER OF ARGS
	T2 _ .T2+2;
	DECR I FROM .T1[ELMNT]<LEFT> TO 0 DO
		(.T2)[.I] _ @(.R2)[.I];  !TRANSFERING ARGLIST TO NEW BLOCK
	R1[SFNLIST] _ T2 _ .T2-2;  !PUT THE POINTER VALUE BACK TO BEGINNNING OF BLOCK
	SAVSPACE(.R2<LEFT>,.R2);  SAVSPACE(.STK[0]<LEFT>,.STK[0]);
	RETURN .R1
END;
GLOBAL ROUTINE STATEFUNC =
BEGIN
	MAP BASE T1:T2;REGISTER BASE R1:R2;
	EXTERNAL
		ARRXPND,	%ARRXPND(ARRAYNAME, SUBSCRIPTLIST)
				SUBSCRIPTLIST= LOC(COUNT,SUBSCRIPT#1,...,SUBSCRIPT#COUNT-1)%
		SAVSPACE,	%SAVSPACE(SIZE,LOCATION)%
		NEWENTRY,	%NEWENTRY()%
		MULTIASGN,	%MULTIASGN()%
		ASTATFUN,	!FLAG PTR WHEN PARSING A STATEMENT FUNCTION
		STK,SP;
	MACRO ERR15 = (ENTRY[1]_T2[IDSYMBOL];ENTRY[2] _ PLIT 'UNIQUE STATEMENT FUNCTION NAME?0'; ERROUT(E15))$;
	MACRO
	ELMNT=	0,0,FULL$,	CNT=	0,0,LEFT$;
	BIND	SFPLIT= PLIT'STATEMENT FUNCTION?0',
		ASGNPLIT= PLIT'ARRAY ASSIGNMENT ';
	LOCAL LNAME;
	T2_LEXEMEGEN();
	IF .T2<LEFT> NEQ IDENT THEN (RETURN ERROUT(E11));
	LNAME _ .T2;  !SAVING THE ARRAY OR FUNCTION NAME PTR
	IF .T2[OPERSP] NEQ ARRAYNAME THEN
		IF .T2[OPERSP] NEQ FORMLARRAY THEN
		BEGIN
			IF ISDEFIND(T2) THEN ERR15;  !SFN NAME ALREADY SEEN
			T2[IDATTRIBUT(FENTRYNAME)] _ 1; !ENTRY NAME GETS ALLOCATED
			T2[IDATTRIBUT(SFN)]_1;T2[OPERSP]_FNNAME;
			ASTATFUN _ .T2<RIGHT>;	!FLAG PTR USED IN MULTIA ASGN
			IF SYNTAX(STATEFUNCSPEC) LSS 0 THEN (ASTATFUN _ 0; RETURN -1);
			BLDSFN();   !BUILD ASTATEFUNCTION NODE
			ASTATFUN _ 0; !RESET SINCE PARSE IS FINISHED
			RETURN
		END;
!------------------------------------------------------------------------------------------------------------------
!	AN ARRAY ASSIGNMENT WITH POSSIBLE MULTIPLE ASSIGNMENTS
!------------------------------------------------------------------------------------------------------------------
	IF SYNTAX(ARRAYASSIGNSPEC) LSS 0 THEN RETURN -1;
	T1_.STK[0];T2_.T1[ELMNT];	!T1_LIST BASE
	INCR SCR FROM @T2 TO @T2+.T2<LEFT> DO
	BEGIN
		MAP BASE SCR;
		MACRO SCRFLAGS=0,0,LEFT$,SCRCNT=0,0,LEFT$,SCRLOC=0,0,RIGHT$;
		R1_.SCR[ELMNT];
		SCR[SCRFLAGS]_0;SCR[SCRLOC]_.R1;!PTR TO SUBSCRIPT EXPRESSION
		IF .R1[OPRCLS] EQL DATAOPR THEN SCR[P1AVALFLG]_1
		ELSE
			IF .R1[OPRCLS] EQL ARRAYREF THEN SCR[P1AVALFLG]_1;
	END;
	IF (T2_ARRXPND(@LNAME,@T2))LSS 0 THEN (ENTRY[1] _ PLIT 'STATEFUNC?0'; RETURN ERROUT(61));
	MULTIASGN()
END;
t–