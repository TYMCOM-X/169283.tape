TITLE   TAP     08/07/72
;*ACCESS REAL MTA AND NOT ASSIGNED UNIT
;*PRINT VERSION ETC IN START ROUTINE IN THIS PACKAGE
;*ERROR ROUTINE SHOULD MARK FILE AS BAD
;*TAPIN ERR SHOULD SAY WHAT KINDS OF ERRORS
;*DON'T RESTORE LICENSE TO FILES WITHOUT LICENSE
;*FIGURE OUT HOW TO DO UPDATE MODE FILES
;*HAVE OPERS RECOVER BAD FILES
;*PRINT CHECKSUM IN DIRECTORY
;*ZERO DISC AND TAPE BUFFERS BEFORE INPUT
;*CHECK EACH TAPE TO BE SURE IT'S NOT THE ONE WE JUST DUMPED

VERLOC= 137
        LOC     VERLOC
        VERSION                         ;STORE VERSION NUMBER IN LOC 137
        RELOC

;ACCUMULATOR ASSIGNMENTS
F=      10      ;FLAG AC
U=      15      ;FIRST  WORD ON A READ OF MFD OR UFD
W=      16      ;SECOND WORD ON A READ OF MFD OR UFD

;CHARACTERS
QCHR=   121
PRIME=  47
COMMA=  54
LBRACK= 133
RBRACK= 135

;PARAMETER ASSIGNMENTS
XLOOKN==40              ;NO. OF ARGS FOR EXTENDED LOOKUP/ENTER
USRCTD==200000          ;(LH) USER CONTINUED ON NEXT TAPE BIT IN TRAILER
TAPCTD==400000          ;(LH) CONTINUATION TAPE(S) FOLLOW BIT IN TRAILER

;CALLI ADDRESSES
DEVCHR==4
RESET== 0
WAIT==  10
DATE==  14
MSTIME==23

;DEVICE ASSIGNMENTS
TAP==   3               ;MAGNETIC TAPE FOR READ OR WRITE
MFD==   4               ;DISK FOR MASTER FILE DIRECTORY
UFD==   5               ;DISK FOR USER FILE DIRECTORY (MUST BE MFD+1)
FIL==   6               ;DISC FOR USER FILE
CHK==   7               ;DISC FOR FILE DATE CHECK

;NUMBER OF BUFFERS/CHANNEL
TAPN==  2
MFDN==  2
UFDN==  2
FILN==  5
CHKN==  2

;SIZE OF BUFFERS/DEVICE
TAPSIZ==1003
DSKSIZ==203

;I/O STATUS BIT ASSIGNMENTS
BUFBIN==14              ;BUFFERED BINARY MODE
NOCNT== 20              ;MONITOR IS NOT TO COMPUTE BUFFER WORD COUNT
SYNCIN==40              ;SYNCHRONOUS INPUT
IOEND== 20000           ;END OF FILE
IOTEND==2000            ;END OF TAPE
IOBAD== 740000          ;I/O ERROR
BTL==   40000           ;BLOCK TOO LARGE FOR BUFFER
DNC==   10              ;DO NOT CHG ACCESS DATE

;EXTENDED LOOKUP FILE STATUS BITS
.RPNFS==40000           ;(RH) DO-NOT-SAVE BIT

;FLAG ASSIGNMENTS (LH OF AC F)
FILFND==40              ;A FILE WAS SAVED FOR THIS USER

START:  MOVE    P,STACK##       ;INITIALIZE THE STACK
        CALLI   RESET           ;CLEAR ALL I/O
        TYPE    [ASCII "$TEX - VERSION _"]
        MOVE    R0,VERLOC       ;GET THE VERSION NUMBER
        PUSHJ   P,PRONUM        ;PRINT OCTAL VERSION NUMBER
        HRROI   R1,-20          ;LOOK FOR OPERATOR LICENSE
        GETTAB  R1,
        JRST    NOLIC           ;CANNOT READ LICENSE
        TRNN    R1,100000       ;SKIP IF LICENSE SET
        JRST    NOLIC           ;GUY DOESN'T HAVE OPER LICENSE
        MOVSI   R1,TAPSIZ-2     ;DATA WORDS/BUFFER
        SETZM   TAPBUF          ;CLR STATUS OF 1ST BUFFER
        HRRI    R1,TAPBUF+1+TAPSIZ ;ADDR OF NEXT BUFFER
        MOVEM   R1,TAPBUF+1     ;STORE POINTER INTO THIS BUFFER
        SETZM   TAPBUF+TAPSIZ   ;CLR STATUS OF 2ND BUFFER
        HRRI    R1,TAPBUF+1     ;LAST BUFFER SHOULD POINT TO FIRST
        MOVEM   R1,TAPBUF+1+TAPSIZ
UNIROU: TYPE    [ASCII "$UNIT: _"]
        TCI     R1,R0           ;READ THE UNIT NUMBER
        CAIE    R1,NU##         ;SKIP IF IT'S A DIGIT
        JRST    UNIERR          ;PRINT ERROR MESSAGE AND TRY AGAIN
        TCI     R1,R2           ;INPUT THE CARRIAGE RETURN
        CAIE    R1,TE##         ;SKIP IF IT'S A LINE TERMINATOR
        JRST    UNIERR          ;PRINT ERROR MESSAGE AND TRY AGAIN
        SUBI    R0,40           ;CONVERT TO SIXBIT
        LSH     R0,14           ;LEFT SHIFT DIGIT TWO PLACES
        HRLI    R0,(SIXBIT /MTA/)
        MOVEM   R0,FS6BIT       ;SAVE THE UNIT NUMBER
        PUSHJ   P,SETIN         ;ASSIGN THE TAPE UNIT
        JRST    SCDISP##        ;START UP THE COMMAND DISPATCHER
NOLIC:  TYPE    [ASCII "$OPERATOR LICENSE IS REQUIRED TO RUN THIS PROGRAM._"]
        EXIT
UNIERR: CLRIN                   ;CLEAR INPUT BUFFER
        TYPE    [ASCII "TYPE 0 OR 1$_"]
        JRST    UNIROU          ;TRY TO INPUT UNIT NUMBER AGAIN

STOROU::SKIPE   R1,STRPPN       ;SKIP IF NO STARTING PPN
        TYPE    [ASCII "REEL NUMBER: _"]
        SETZM   TAPNUM          ;STARTING REEL IS ONE IF NO STARTING PPN
        JUMPE   R1,CONSTO       ;JUMP IF NO STARTING PPN
        PUSHJ   P,RDDNUM##      ;READ DECIMAL NUMBER
        CAIE    R2,TE           ;SKIP IF NUMBER TERMINATED BY A CR
        ERROR   [ASCII "INVALID REEL NUMBER_"]
        SOJ     R0,             ;DECREMENT REEL NUMBER
        MOVEM   R0,TAPNUM#      ;INITIALIZE THE TAPE SEQ NUMBER
CONSTO: PUSHJ   P,SETOUT        ;INIT TAPE AND SET UP HEADER AS VIRGIN
        OUTPUT  TAP,            ;DUMMY OUTPUT TO SET UP TAPHED
        PUSHJ   P,TAPOU3        ;SET UP BUFFER COUNTS
        TYPE    [ASCII "$$TAPE NUMBER _"]
        AOS     R1,TAPNUM       ;INCREMENT AND LOAD TAPE SEQ NUMBER
        HRRM    R1,FIRBL2       ;PLACE IN HEADER
        MOVE    R0,TAPNUM       ;GET TAPE NUMBER TO PRINT
        PUSHJ   P,PRDNUM##      ;PRINT DECIMAL NUMBER
        TYPE    [ASCII " FOR _"]
        CALLI   R1,MSTIME       ;FORM THE TAPE'S DATE AND TIME
        IDIVI   R1,^D60000      ;FLUSH JIFFIES AND SECONDS
        CALLI   R2,DATE         ;GET TODAY'S DATE
        ANDI    R1,3777
        LSH     R1,^D12         ;TIME IN BITS 13-23
        IOR     R1,R2           ;DATE IN 24-35
        SKIPGE  FIRBL3          ;CONTINUE TAPE BIT SET IN LAST TRAILER?
        TLO     R1,400000       ;YES, KEEP IT IN THIS HEADER
        MOVEM   R1,FIRBL3       ;STASH AWAY IN HEADER LABEL
        MOVEI   R2,FIRBL3       ;GET ADDRESS OF DATE AND TIME
        PUSHJ   P,PRTDT##       ;PRINT THEM OUT
        TCO     [CRCHR]         ;PRINT A CARRIAGE RETURN
        PUSHJ   P,LABBLT        ;WRITE OUT HEADER
        MOVEI   R1,MFDHED
        MOVEM   R1,IOBUF
        OPEN    MFD,MFDSPK      ;WANT TO READ MFD FOR THIS STR
        ERROR   [ASCII "NO MFD FOUND - SOMETHING IS VERY WRONG._"]
        MOVEI   R1,MFDBUF       ;SET UP BUFFERS
        MOVEM   R1,JOBFF##      ;TELL SYSTEM WHERE TO PUT THE BUFFERS
        INBUF   MFD,MFDN
        MOVE    R1,SYSPP        ;LOOK FOR MFD
        MOVEM   R1,MFDDI3       ;IN THE MFD
        MOVEM   R1,MFDDIR
        MOVSI   R1,(SIXBIT /UFD/)
        MOVEM   R1,MFDDI1
        LOOKUP  MFD,MFDDIR      ;(OLD STYLE LOOKUP)
        ERROR   [ASCII "UNABLE TO DO LOOKUP ON MFD._"]

MORE1:  PUSHJ   P,MFD2          ;GET ENTRY FROM MFD - SKIP IF NOT DONE
        JRST    CDISP##         ;DONE WITH STORE SO RET TO CMD DISP

        INIT    UFD,BUFBIN      ;IS IT AVAILABLE
        SIXBIT  /DSK/
        XWD     0,UFDHED        ;INPUT ONLY
        ERROR   [ASCII "UNABLE TO INIT DSK_"]
        MOVEI   R1,UFDBUF       ;SETUP BUFFERING
        MOVEM   R1,JOBFF
        INBUF   UFD,UFDN
        MOVE    R1,SYSPP        ;LOOK FOR UFD
        MOVEM   R1,UFDDI1       ;IN THE UFD
        MOVEI   R1,XLOOKN       ;EXT. LOOKUP
        MOVEM   R1,UFDDIR
        MOVEM   U,UFDDI2        ;PPN FOR THIS USER
        HRLZM   W,UFDDI3        ;THE EXTENSION "UFD"
        LOOKUP  UFD,UFDDIR      ;IS IT STILL THERE
        ERROR   [ASCII "UNABLE TO DO LOOKUP ON UFD._"];*
        TLZ     F,FILFND        ;NO FILES FOUND YET FOR THIS USER

MORE2:  PUSHJ   P,UFD2          ;GET ENTRY FROM UFD - SKIP IF NOT DONE
        JRST    MORE1           ;DONE WITH THIS UFD

        MOVEI   R1,XLOOKN       ;EXT. LOOKUP
        MOVEM   R1,FILDIR
        MOVEM   U,FILDI2        ;FILE NAME
        HRLZM   W,FILDI3        ;EXTENSION
        MOVE    R1,UFDDI2       ;PROJ-PROG NUMBER
        MOVEM   R1,FILDI1

        INIT    FIL,BUFBIN      ;SET TO GET FILE
        SIXBIT  /DSK/
        XWD     0,FILHED        ;INPUT ONLY
        ERROR   [ASCII "UNABLE TO INIT DSK._"]
        MOVEI   R1,FILBUF       ;SETUP BUFFERS
        MOVEM   R1,JOBFF
        INBUF   FIL,FILN
        LOOKUP  FIL,FILDIR      ;IS IT THERE?
        ERROR   [ASCII "UNABLE TO DO LOOKUP ON FILE._"];*
        MOVE    R1,FRBSTS       ;GET FILE STATUS
        TRNE    R1,.RPNFS       ;DO-NOT-SAVE BIT ON?
        JRST    MORE2           ;YES

        TLO     F,FILFND        ;INDICATE FILE FOUND
        SETZM   RECCNT#         ;NO RECORDS FOR THIS FILE OUTPUT YET
        MOVE    R1,[XWD CURPPN,LSTPPN]
        BLT     R1,LSTEXT       ;SAVE OLD PPN, FILE, AND EXTENSION
        HRLZM   W,CUREXT        ;SAVE NEW EXTENSION
        MOVEM   U,CURFIL        ;SAVE NEW FILE NAME
        MOVE    R1,UFDDI2       ;GET NEW PPN
        MOVEM   R1,CURPPN       ;SAVE NEW PPN
        PUSHJ   P,DIRBLT        ;BLT DIRECTORY INTO TAPE BUFFER

MORE3:  SOSLE   FILHD2          ;GET A WORD FROM USER FILE
        JRST    .+3             ;NOT OUT OF WORDS
        PUSHJ   P,FILIN         ;INPUT A BUFFER - SKIP IF NOT END OF FILE
        JRST    MORE2           ;DONE WITH THIS FILE SO GET NEXT
        ILDB    R1,FILHD1
        MOVEM   R1,MORE3W#      ;*KLUDGE CAUSE TAPOUT DOESN'T PRESERVE R1
        SOSG    TAPHD2          ;STASH IT AWAY ON TAPE
        PUSHJ   P,TAPOUT
        MOVE    R1,MORE3W       ;RESTORE R1
        IDPB    R1,TAPHD1
        JRST    MORE3           ;CONTINUE FILLING BUFFER

;READ MFD

MFD2:   PUSHJ   P,GETMFD        ;READ WORD 0 OF MFD ENTRY
        JUMPE   R1,MFD2         ;SKIP TO NEXT PAIR ON 0
        MOVE    U,R1            ;SAVE PPN IN REGISTER U
        PUSHJ   P,GETMFD        ;READ WORD 1 OF MFD ENTRY
        HLRZ    W,R1            ;EXTENSION IN RH FOR EASY COMPARE
        PUSHJ   P,GETMFD        ;READ WORD 2 OF MFD ENTRY
        PUSHJ   P,GETMFD        ;READ WORD 3 OF MFD ENTRY
        PUSHJ   P,GETMFD        ;READ WORD 4 OF MFD ENTRY
        CAIE    W,(SIXBIT /UFD/);SKIP IF THIS IS A UFD
        JRST    MFD2            ;LOOK FOR NEXT UFD
        HRRZ    R1,U            ;COMPARE ONLY THE UUN
        CAMN    R1,STRPPN       ;SKIP IF IT'S NOT THE STARTING USER
        SETZM   STRPPN          ;WE'VE FOUND THE STARTING USER
        SKIPE   STRPPN          ;SKIP IF WE'RE NOT LOOKING FOR USER
        JRST    MFD2            ;STILL LOOKING FOR STARTING USER
        PUSHJ   P,CKNPPN        ;SKIP IF THIS USER SHOULD BE DUMPED
        JRST    MFD2            ;NOT THIS USER, TRY THE NEXT
        AOS     (P)             ;WE READ SOMETHING SO SKIP
        POPJ    P,              ;SKIP RETURN

GETMFD: SOSG    MFDHD2          ;SKIP IF MORE WORDS IN BUFFER
        PUSHJ   P,MFDIN         ;GET ANOTHER BUFFER
        ILDB    R1,MFDHD1       ;NEXT WORD INTO R1
        POPJ    P,

MFDIN:  IN      MFD,            ;READ ANOTHER BUFFER
        POPJ    P,              ;HAPPY, RETURN
        STATZ   MFD,IOBAD       ;SKIP IF NO ERROR (END OF BUFFER)
        ERROR   [ASCII "ERROR IN READING MFD_"];*
        CLOSE   MFD,DNC
        RELEASE MFD,
        SKIPE   STRPPN          ;SKIP IF NOT LOOKING FOR STARTING PPN
        ERROR   [ASCII "CANNOT FIND STARTING USER_"]
        MOVSI   R1,TAPCTD!USRCTD;NEITHER TAPE NOR USER IS CONTINUED
        ANDCAM  R1,FIRBL3  
        MOVN    R1,TAPNUM       ;NEGATE TAPE #
        HRRM    R1,FIRBL2
        MTAPE   TAP,7           ;BAKSP OVER EOF
        MTAPE   TAP,0           ;WAIT FOR OPERATION TO TERMINATE
        PUSHJ   P,LABBLT        ;WRITE TRAILER RECORD
        TYPE    [ASCII "STORE COMPLETED$$_"]
        SUB     P,[XWD 2,2]     ;POP STACK TWICE
        POPJ    P,              ;FAIL RETURN FROM MFD2

;READ UFD

UFD2:   PUSHJ   P,GETUFD        ;READ WORD 0 OF UFD ENTRY
        JUMPE   R1,UFD2         ;SKIP TO NEXT ENTRY ON ZERO
        MOVE    U,R1            ;PLACE IN FIRST WORD REGISTER
        PUSHJ   P,GETUFD        ;READ WORD 1 OF UFD ENTRY
        HLRZ    W,R1            ;PUT EXTENSION IN RH FOR EASY COMPARE
        PUSHJ   P,GETUFD        ;READ WORD 2 OF UFD ENTRY
        MOVEM   R1,CRTION       ;SAVE CREATION DATE
        PUSHJ   P,GETUFD        ;READ WORD 3 OF UFD ENTRY
        PUSHJ   P,GETUFD        ;READ WORD 4 OF UFD ENTRY
        CAIN    W,(SIXBIT /TMP/);IGNORE TEMP FILES
        JRST    UFD2            ;GET NEXT ENTRY FROM UFD
        MOVE    R1,STRFIL       ;ZERO IF NOT LOOKING FOR STARTING FILE
        CAMN    W,STREXT        ;SKIP IF NOT STARTING EXTENSION
        CAME    U,STRFIL        ;SKIP IF THIS IS THE STARTING FILE
        JUMPN   R1,UFD2         ;JUMP IF STARTING FILE NOT YET FOUND
        SETZM   STRFIL          ;MARK STARTING FILE AS FOUND
        PUSHJ   P,CKNFIL        ;SKIP IF THIS FILE SHOULD BE STORED
        JRST    UFD2            ;NO - TRY ANOTHER
        PUSHJ   P,CKNCRE        ;SKIP IF CREATION DATE OK TO DUMP
        JRST    UFD2            ;NO - TRY ANOTHER
        JRST    CPOPJ1          ;SKIP RETURN FROM UFD2

GETUFD: SOSG    UFDHD2          ;ANY MORE WORDS IN BUFFER?
        PUSHJ   P,UFDIN         ;NO, GET SOME
        ILDB    R1,UFDHD1       ;NEXT WORD
        POPJ    P,

UFDIN:  IN      UFD,            ;READ ANOTHER BUFFER
        POPJ    P,              ;HAPPY, RETURN
        STATO   UFD,IOBAD       ;END OF FILE?
        JRST    ENDUFD          ;YES, GO DO WRAPUP
        STATZ   UFD,BTL         ;SKIP IF BLOCK NOT TOO LARGE
        TYPE    [ASCII "BLOCK TOO LARGE$_"]
        TYPE    [ASCII "ERROR READING UFD$_"]
        JRST    UFDFR           ;UFD2 FAIL RETURN
ENDUFD: SKIPE   STRFIL          ;SKIP IF NOT LOOKING FOR STARTING FILE
        ERROR   [ASCII "CANNOT FIND STARTING FILE_"]
        TLZN    F,FILFND        ;ANY FILES FOR THIS USER?
        JRST    NULUFD          ;NOPE
        PUSHJ   P,CLSUSR        ;WRITE EOFS ON TAPE
        MOVEI   R2,CURPPN       ;GET ADDR OF PPN WE JUST STORED ON TAPE
        PUSHJ   P,PRTPPN        ;PRINT THE PPN
        TCO     [CRCHR]         ;PRINT A CARRIAGE RETURN
        SKIPA   
NULUFD: PUSHJ   P,NULTAP        ;RESET BUFFER
        CLOSE   UFD,DNC
        RELEASE UFD,            ;GIVE UP UFD DDB
UFDFR:  SUB     P,[XWD 2,2]     ;POP STACK TWICE TO RETURN FROM UFD2
        POPJ    P,              ;FAIL RETURN FROM UFD2

;DISK FILE INPUT

FILIN:  IN      FIL,            ;GET NEXT BUFFER
        JRST    CPOPJ1          ;SUCCESSFUL - SKIP RETURN
        STATZ   FIL,IOBAD       ;SKIP IF NO ERROR
        PUSHJ   P,FILINE        ;DSK ERR - FALL INTO ENDFIL ON RETURN
        MOVE    R2,TAPHD2       ;CHECK FOR EMPTY BUFFER
        CAIE    R2,TAPSIZ-4     ;SKIP IF NOT EMPTY
        SOS     TAPHD2          ;DECREMENT TO ADJUST COUNT
        PUSHJ   P,TAPOUT        ;OUTPUT LAST BUFFER
        CLOSE   FIL,DNC
        RELEASE FIL,            ;GIVE UP USER FILE
        POPJ    P,              ;FAIL RETURN FROM FILIN

FILINE: TYPE    [ASCII "$ERROR IN READING FILE: _"]
        MOVEI   R2,CURPPN       ;ADDRESS OF CURRENT PPN, FIL.EXT
        PUSHJ   P,PRTPFX        ;PRINT PPN, FILE.EXT
        TCO     [CRCHR]         ;END THE LINE
        POPJ    P,              ;RETURN

;MAG TAPE OUTPUT

TAPOUT: MOVEI   R2,TAPSIZ-4     ;DATA WORDS/BUFFER
        SUBB    R2,TAPHD2       ;COMPUTE WORDS USED
        JUMPE   R2,NULTAP       ;NONE USED, DONT OUTPUT
        HRRZ    R1,TAPHED       ;ADDR OF BUFFER CURRENTLY IN USE
        HRRM    R2,2(R1)        ;BUFFERED BINARY WORD COUNT FOR FAILSAFE
        AOS     R2
        HRRZM   R2,1(R1)        ;TOTAL DATA WORD COUNT FOR MONITOR
;       MOVEI   R1,0            ;NOT NECESSARY BECAUSE IT'S ALREADY +
TAPOU1: OUT     TAP,            ;WRITE ANOTHER RECORD
        SETOM   R1              ;MAKE R1 NEGATIVE FOR SUCCESSFUL OUTPUT
        AOS     RECCNT          ;COUNT RECORD WHETHER GOOD OR BAD
        STATZ   TAP,IOTEND      ;END OF TAPE?
        JRST    ENDTAP          ;*THIS SCREWS UP THE STACK
        JUMPL   R1,TAPOU3       ;JUMP IF ABOVE OUTPUT WAS SUCCESSFUL
        STATZ   TAP,400000      ;NO, WRITE-LOCKED TAPE?
        JRST    TAPNWR          ;NEED WRITE RING IN TAPE
        STATZ   TAP,200000      ;NO, PHYSICAL DEVICE ERROR?
        JRST    TAPPDE          ;PHYSICAL DEVICE ERROR
        TYPE    [ASCII "MAG TAPE WRITE ERROR--TRYING AGAIN$_"]
        GETSTS  TAP,R2          ;CLEAR ERROR BITS FOR RETRY
        ANDCMI  R2,760000
        SETSTS  TAP,(R2)
        MTAPE   TAP,7           ;BACKSPACE RECORD
        MTAPE   TAP,13          ;WRITE 3 INCH BLANK TAPE
        MTAPE   TAP,0           ;WAIT FOR OPERATION TO TERMINATE
        SOS     RECCNT          ;DON'T COUNT THAT RECORD TWICE
        JRST    TAPOU1          ;TRY AGAIN
TAPPDE: TYPE    [ASCII "PHYSICAL DEVICE ERROR._"]
        CLRIN                   ;CLEAR INPUT BUFFER
        JRST    TAPCON          ;ACCEPT CARRIAGE RETURN AND RETRY
TAPNWR: TYPE    [ASCII "TAPE NEEDS A WRITE RING._"]
TAPCON: TYPE    [ASCII "TYPE A CARRIAGE RETURN TO CONTINUE:_"]
        TCI     R1,R2           ;INPUT THE CARRIAGE RETURN
        CAIE    R1,TE           ;SKIP IF IT WAS A CARRIAGE RETURN
        ERROR   [ASCII "COMMAND ABORTED._"]
        SOS     RECCNT          ;THAT RECORD DIDN'T GET WRITTEN
        GETSTS  TAP,R2          ;CLEAR ERROR BITS FOR RETRY
        ANDCMI  R2,760000       ;CLEAR THE BITS
        SETSTS  TAP,(R2)        ;PUT STATUS BACK
        JRST    TAPOU1          ;TRY AGAIN

AGUFO:  SETZ    R2,             ;ALL
        HLRZ    R2,U            ;GANS
        HRRZ    R2,U            ;USERS
        HRRZ    R2,U            ;FILES

DEFINE  CNTF    (X) <
CNTF'X==:.-CNTTAB
        CNTF'X'R>

CNTFP==:(POINT 2,0,1)           ;POINTER USED TO GET THIS FIELD
CNTTAB: BLOCK   0               ;TABLE FOR CONTROL FIELD OF LIST
        CNTF    (C)             ;ITEM TERMINATED WITH A COMMA
        CNTF    (D)             ;ITEM TERMINATED WITH A DASH
        CNTF    (T)             ;ITEM TERMINATED WITH A CR
        CNTF    (N)             ;NOT

ALLLST::BYTE(2)CNTFT            ;DUMMY LIST FOR ALL FILES
CKNCHR: XOR     R2,[SIXBIT /#/] ;CHECK FOR POUND SIGN CHAR
        TLNN    R2,770000       ;SKIP IF IT'S NOT A POUND SIGN
        TLZ     R3,770000       ;THAT CHAR OF FILE MATCHES
        XOR     R2,[BYTE (6)34] ;EXCLUSIVE OR OF QUESTION AND POUND
        TLZN    R2,770000       ;SKIP IF IT'S NOT A QUESTION MARK
        TLZ     R3,770000       ;MAKE THAT CHAR OF FILE MATCH
        TLZE    R3,770000       ;SKIP IF CHARS MATCH
        POPJ    P,              ;FAIL RETURN     LSHC    R2,6            ;SHIFT TO NEXT CHAR
        JUMPN   R3,CKNCHR       ;LOOP IF OTHER CHARS DON'T MATCH
        JRST    CPOPJ1          ;SUCCESS RETURN


CKNCRE: HRRZ    R1,CRTION       ;GET CREATION DATE
        ANDI    R1,7777         ;THROW AWAY NON-DATE BITS
        CAMLE   R1,CREDAT       ;SKIP IF DATE OF FILE NOT GREATER
        JRST    CPOPJ1          ;SKIP RETURN
        CAME    R1,CREDAT       ;SKIP IF DATES ARE EQUAL
        POPJ    P,              ;FAIL RETURN
        MOVE    R1,CRTION       ;GET CREATION DATE AND TIME
        AND     R1,[XWD 3777,770000] ;TURN OFF NON-TIME BITS
        CAML    R1,CRETIM       ;SKIP IF FILE TIME IS TOO OLD
        JRST    CPOPJ1          ;SKIP RETURN
        POPJ    P,              ;FAIL RETURN

CKNFIL: MOVEI   R1,2            ;SECOND PART OF COMMAND
        HLRZ    R2,CTABLE(R1)   ;GET STATE FOR SECOND PART OF COMMAND
        CAIE    R2,FF2##        ;SKIP IF CHECKING FOR INDIVIDUAL FILES
        JRST    CPOPJ1          ;SUCCESS RETURN - ALL FILES ARE OK
        HRRZ    R1,CTABLE(R1)   ;ADDRESS OF LIST
        LDB     R2,[XWD CNTFP+R1,0]
        CAIE    R2,CNTFT        ;SKIP IF THIS IS END OF USER NAME ETC
        AOJA    R1,.-2          ;LOOK AT THE NEXT ENTRY
CKNNX1: HRRZ    R2,2(R1)        ;GET THE EXTENSION
        MOVS    R3,1(R1)        ;GET FILE NAME BACKWARDS
        CAIN    R3,(SIXBIT /ALL/)
        JUMPE   R2,CPOPJ1       ;SUCCESS RETURN IF FILE "ALL"
        CAIN    R3,(SIXBIT /*/) ;SKIP IF NOT WILD CARD
        MOVS    R3,U            ;MAKE THE FILE NAMES MATCH
        MOVS    R3,R3           ;PUT THE FILE NAME BACK THE WAY IT SHOULD BE
        MOVE    R2,R3           ;ALSO PUT FILE NAME IN R2
        XOR     R3,U            ;EXCLUSIVE OR THE NAMES TO FIND DIFF
        PUSHJ   P,CKNCHR        ;SKIP IF NAMES MATCH
        AOJA    R1,CKNNXT       ;DON'T MATCH SO TRY THE NEXT
        HRRZ    R3,2(R1)        ;EXTENSION IN RH FOR EASY COMPARE
        CAIN    R3,(SIXBIT /*/) ;SKIP IF IT'S NOT A WILD CARD
        HRRZ    R3,W            ;MAKE THE EXTENSIONS MATCH
        MOVE    R2,R3           ;ALSO PUT EXTENSION IN R2
        XOR     R3,W            ;EXCLUSIVE OR THE EXTENSIONS TO FIND DIFF
        LSHC    R2,22           ;THIS ISN'T NECESSARY BUT SPEEDS UP CKNCHR
        PUSHJ   P,CKNCHR        ;SKIP IF NAMES MATCH
        AOJA    R1,CKNNXT       ;DON'T MATCH SO TRY THE NEXT
        JRST    CPOPJ1          ;SUCCESS RETURN FOR MATCH
CKNNXT: LDB     R2,[XWD CNTFP+R1,1]
        CAIN    R2,CNTFT        ;SKIP IF NOT THE LAST FILE IN LIST
        POPJ    P,              ;FAIL RETURN
        AOJA    R1,CKNNX1       ;CHECK THE NEXT FILE NAME

CKNPPN: SETOM   NOTWRD#         ;-1 FOR NORMAL, 0 FOR NOT
        MOVEI   R1,2
        MOVE    R1,CTABLE##(R1)
        HLRZ    R3,R1           ;SAVE STATE IN R3
        JUMPE   R1,CPOPJ1       ;SUCCESS RET IF NOT SET UP
        LDB     R2,[XWD CNTFP+R1,0]
        HRRZ    R0,(R1)
        PUSHJ   P,@CNTTAB(R2)
        AOJA    R1,.-3          ;LOOP
        CAME    R2,[-1]         ;SKIP IF NO MATCH
        SETZ    R2,             ;ZERO FOR MATCH
        XOR     R2,NOTWRD       ;INVERT IF NORMAL, DO NOTHING IF NOT
        JRST    CPOPJ(R2)       ;ADD ONE FOR SUCCESS RETURN

CNTFNR: SETCMM  NOTWRD          ;INVERT THE OPERATION
        POPJ    P,
CNTFCR: XCT     AGUFO(R3)
        CAMN    R0,R2           ;SKIP IF NOT DONE
        AOS     (P)             ;DONE - DON'T LOOP ANYMORE
        POPJ    P,
CNTFDR: XCT     AGUFO(R3)
        AOJ     R1,
        CAMLE   R0,R2
        JRST    CNTFTT
        HRRZ    R0,(R1)
        CAML    R0,R2
        JRST    CPOPJ1 
CNTFTT: LDB     R2,[XWD CNTFP+R1,0]
        SETO    R0,
        CAIN    R2,CNTFT        ;SKIP IF NOT A TERMINATOR
        AOS     (P)             ;TERMINATOR, SO STOP LOOPING
        POPJ    P,
CNTFTR: XCT     AGUFO(R3)
        CAME    R0,R2           ;SKIP IF MATCH
        SETO    R2,             ;TERMINATE WITHOUT MATCH
        JRST    CPOPJ1          ;DONE LOOPING NO MATTER WHAT HAPPENED

;OUTPUT TRAILER BLOCK

TRLOUT: BLOCK   0               ;*SET TAPE CONTINUATION BIT IF CONT
        MOVN    R1,TAPNUM       ;NEGATE TAPE #
        HRRM    R1,FIRBL2       ;RESET TRAILER
                                ;FALL INTO LABBLT

;WRITE HEADER OR TRAILER ON TAPE

LABBLT: MOVSI   R1,FIRBLK       ;ADDR OF HEADER
        HRR     R1,TAPHD1       ;GET BUFFER DATA ADDR FROM BYTE PTR
        MOVEI   R2,4(R1)        ;SET STOP AT 5TH DATA WORD
        BLT     R1,(R2)         ;BLT HEADER INTO BUFFER
        HRRM    R2,TAPHD1       ;RESET BYTE POINTER
        MOVNI   R1,3            ;RESET COUNT
        ADDM    R1,TAPHD2
        SOS     TAPHD2          ;ADJUST FOR NON-LOOP CALL
        PUSHJ   P,TAPOUT        ;WRITE ONE RECORD
CLSUSR: CLOSE   TAP,            ;ASK THE MONITOR TO CLOSE
        CALLI   TAP,WAIT        ;WAIT UNTIL OUTPUT FINISHED
NULTAP: MOVSI   R1,400000       ;TURN OFF VIRGIN BIT
        ANDCAB  R1,TAPHED
        AOS     R1              ;SET BYTE POINTER TO BEG OF BUFFER
        HRRM    R1,TAPHD1
TAPOU3: MOVEI   R1,TAPSIZ-4     ;DATA WORDS/BUFFER -1
        HRRZM   R1,TAPHD2       ;BUFFER COUNT
        IDPB    R1,TAPHD1       ;BUFFER COUNT TO 1ST DATA WORD
        POPJ    P,              ;RETURN

;BLT HEADERS INTO TAPE BUFFER

DIRBLT: MOVSI   R1,FILMRK       ;HEADER WORD FOR DIRECTORY
        HRR     R1,TAPHD1       ;GET BUFFER DATA ADDR FROM BYTE PTR
        MOVEI   R2,XLOOKN+2(R1) ;SET STOP AT LAST RETRIEVAL WORD
        BLT     R1,(R2)         ;BLT HEADER INTO BUFFER
        HRRM    R2,TAPHD1       ;RESET BYTE POINTER
        MOVNI   R1,XLOOKN+1     ;RESET COUNT
        ADDM    R1,TAPHD2
        POPJ    P,              ;RETURN

ENDTAP: PUSHJ   P,CLSUSR        ;CLOSE TAPE FILE AND RESET BUFFERS
        MTAPE   TAP,7           ;BACKSPACE OVER THE EOF JUST WRITTEN
        PUSHJ   P,SETINS        ;SET TAPE FOR SYNC INPUT
        MOVE    R1,RECCNT       ;NUMBER RECORDS OUTPUT FOR CURRENT FILE
        MTAPE   TAP,7           ;BACK UP A RECORD
        SOJG    R1,.-1          ;JUMP IF WE'RE NOT TO START OF CURR FILE
        MTAPE   TAP,0           ;WAIT FOR COMPLETION
        IN      TAP,            ;INPUT A RECORD
        JRST    EOT1            ;INPUT WAS SUCCESSFUL
        STATZ   TAP,IOEND       ;SKIP IF END OF FILE NOT READ
        ERROR   [ASCII "FILE MARK READ IN WRONG PLACE_"];*
        ERROR   [ASCII "TAPE ERROR WHILE TRYING TO END TAPE_"];*
EOT1:   PUSHJ   P,EOTWRD        ;READ A WORD FROM THE RECORD
        HLRE    R1,R1           ;ONLY WANT LH
        JUMPE   R1,[ERROR [ASCII "DATA RECORD IN WRONG PLACE_"]];*
        JUMPG   R1,[ERROR [ASCII "TRAILER IN WRONG PLACE_"]];*
        CAME    R1,[-1]         ;SKIP IF FILE HEADER
        ERROR   [ASCII "FILE HEADER NOT FOUND_"];*
        PUSHJ   P,EOTWRD        ;READ STRUCTURE NAME
        PUSHJ   P,EOTWRD        ;READ SOMETHING OR OTHER
        PUSHJ   P,EOTWRD        ;READ PPN
        CAME    R1,CURPPN       ;SKIP IF IT'S THE RIGHT PPN
        ERROR   [ASCII "FOUND WRONG PPN AT EOT_"];*
        PUSHJ   P,EOTWRD        ;READ THE FILE NAME
        CAME    R1,CURFIL       ;SKIP IF IT'S THE RIGHT NAME
        ERROR   [ASCII "FOUND WRONG FILE AT EOT_"];*
        PUSHJ   P,EOTWRD        ;READ FILE EXTENSION
        HLLZS   R1              ;ZERO RH
        CAME    R1,CUREXT       ;SKIP IF IT'S THE RIGHT EXTENSION
        ERROR   [ASCII "FOUND WRONG EXTENSION AT EOT_"];*
        MTAPE   TAP,7           ;BACK OVER DIRECTORY
        MTAPE   TAP,0           ;WAIT FOR OPERATION TO FINISH
        MOVE    R1,CURPPN       ;GET CURRENT USER
        CAME    R1,LSTPPN       ;IF SAME AS LAST WE DON'T WANT 2 EOFS
        MTAPE   TAP,7           ;BACK UP ONE RECORD
        MTAPE   TAP,0           ;WAIT FOR OPERATION TO FINISH
        PUSHJ   P,SETOUT        ;SET TAPE FOR OUTPUT
        OUTPUT  TAP,            ;SET UP BUFFERS - TAPE NOT WRITTEN
        PUSHJ   P,TAPOU3        ;SET UP HEADER
        PUSHJ   P,TRLOUT        ;WRITE TRAILER
        MTAPE   TAP,11          ;REWIND (AND UNLOAD) WITHOUT WAIT
        TYPE    [ASCII "THE LAST FILE ON THIS TAPE IS: _"]
        MOVEI   R2,LSTPPN       ;GET ADDRESS OF LSTPPN, LSTFIL, LSTEXT
        PUSHJ   P,PRTPFX        ;PRINT FILE NAME, EXTENSION, AND PPN
        TYPE    [ASCII "$THE FIRST FILE ON THE NEXT TAPE WILL BE: _"]
        MOVEI   R2,CURPPN       ;GET ADDRESS OF CURPPN, CURFIL, CUREXT
        PUSHJ   P,PRTPFX        ;PRINT FILE NAME, EXTENSION, AND PPN
        HRRZ    R1,CURPPN       ;GET CURRENT PPN - ONLY RH COUNTS
        MOVEM   R1,STRPPN       ;MAKE IT THE STARTING PPN FOR NEXT TAPE
        MOVE    R1,CURFIL       ;GET CURRENT FILE NAME
        MOVEM   R1,STRFIL       ;MAKE IT THE STARTING FILE FOR NEXT TAPE
        MOVE    R1,CUREXT       ;GET CURRENT EXTENSION
        HLRZM   R1,STREXT       ;MAKE IT THE STARTING EXT FOR NEXT TAPE
        TYPE    [ASCII "$MOUNT NEXT TAPE AND TYPE A CARRIAGE RETURN TO CONTINUE: _"]
        CLOSE   MFD,DNC         ;CLOSE THE MFD
        RELEASE MFD,
CHKCON: CLRIN                   ;CLEAR INPUT BUFFER
        TCI     R1              ;*IMPROVE THIS TO ALLOW HELP ETC
        CAIN    R1,CRCHR        ;SKIP IF NOT A CARRIAGE RETURN
        JRST    CONSTR          ;*CONTINUE THE STORE - IS STACK OK?
        CAIN    R1,QCHR         ;SKIP IF NOT A Q FOR QUIT
        JRST    CLDSP##         ;CLEAR INPUT AND GO TO COMMAND DISP
        TYPE    [ASCII "PLEASE TYPE CR TO CONTINUE OR Q TO QUIT: _"]
        CLRIN                   ;CLEAR INPUT BUFFER
        JRST    CHKCON          ;CHECK FOR CONTINUE
CONSTR: MTAPE   TAP,1           ;REWIND THE NEW TAPE
        MTAPE   TAP,0           ;WAIT FOR REWIND TO FINISH
        JRST    CONSTO          ;CONTINUE STORING FILES ON TAPE

EOTWRD: ILDB    R1,TAPHD1       ;GET NEXT WORD OF RECORD
        SOS     TAPHD2          ;*REDUCE COUNT
        POPJ    P,              ;RETURN WITH WORD

;PRINT FILE NAME, EXTENSION, AND PPN
;*MAYBE THIS SHOULD TAB
PRTPFX: PUSHJ   P,PRTPPN        ;PRINT PPN
        JRST    PRTFX           ;PRINT FILE AND EXTENSION AND RETURN

PRTFX:: BLOCK   0               ;PRINT NAME AND EXT - ADDR IN R2
        HRLI    R2,0600         ;MAKE SIXBIT BYTE STRING
        HLRZ    R1,1(R2)        ;GET THE EXTENSION
        CAIN    R1,(SIXBIT /UFD/);SKIP IF NOT A UFD
        JRST    PRTUFD          ;*SHOULD ALSO CHECK PPN
        SOJ     R2,             ;DECREMENT TO POINT TO WORD BEFORE
        MOVEI   R1,6            ;PRINT SIX CHARACTER FILE NAME
PRTFN1: ILDB    R0,R2           ;GET NEXT CHARACTER
        ADDI    R0,40           ;CONVERT FROM SIXBIT TO ASCII
        TCO     R0              ;PRINT THE CHARACTER
        SOJG    R1,PRTFN1       ;LOOP IF NOT DONE
PRTDOT: TCO     [DOTCHR]        ;*FIX THIS FOR UFD
        MOVEI   R1,3            ;PRINT THREE CHARACTERS
PRTFN2: ILDB    R0,R2           ;GET THE NEXT CHAR
        ADDI    R0,40           ;CONVERT FROM SIXBIT TO ASCII
        TCO     R0              ;OUTPUT NEXT CHAR OF EXTENSION
        SOJG    R1,PRTFN2       ;LOOP IF NOT DONE WITH EXTENSION
        AOJ     R2,             ;POINT TO WORD FOLLOWING EXTENSION
        HRRZ    R2,R2           ;*MAYBE WE SHOULDN'T CLEAR BYTE POINTER
        POPJ    P,              ;RETURN
PRTUFD: HLRZ    R0,(R2)         ;GET THE GLOBAL ACCT NUMBER
        PUSHJ   P,PRONUM##      ;PRINT THE GAN
        TCO     [COMMA]         ;TYPE A COMMA
        HRRZ    R0,(R2)         ;GET THE UNIVERSAL USER NUMBER
        PUSHJ   P,PRONUM        ;PRINT THE UUN
        JRST    PRTDOT          ;PRINT DOT AND THE EXTENSION

PRTPPN: TCO     [LBRACK]        ;OUTPUT A LEFT BRACKET
        HLRZ    R0,(R2)         ;GET THE GLOBAL ACCT NUMBER
        PUSHJ   P,PRONUM        ;PRINT GLOBAL ACCOUNT NUMBER
        TCO     [COMMA]         ;PRINT A COMMA
        HRRZ    R0,(R2)         ;GET UNIVERSAL USER NUMBER
        PUSHJ   P,PRONUM        ;PRINT UNIVERSAL USER NUMBER
        TCO     [RBRACK]        ;PRINT A RIGHT BRACKET
        AOJA    R2,CPOPJ        ;RETURN

;INITIALIZE MAGNETIC TAPE

SETINS: MOVEI   R1,SYNCIN       ;GET SYNC INPUT BIT
        IORM    R1,TAPOPN       ;TURN ON SYNC INPUT BIT FOR OPEN
SETIN:  HRRZI   R1,TAPHED       ;SET UP FOR INPUT
        SKIPA
SETOUT: HRLZI   R1,TAPHED       ;SET UP FOR OUTPUT
        MOVEM   R1,INOUT        ;SET HEADER
        OPEN    TAP,TAPOPN      ;OPEN UNIT 0 OR 1
        ERROR   [ASCII "UNABLE TO ACCESS TAPE UNIT._"]
        MOVE    R1,[XWD 400000,TAPBUF+1] ;INIT 1ST WORD OF HEADER
        MOVEM   R1,TAPHED
        POPJ    P,              ;RETURN

TAPOPN: EXP BUFBIN!NOCNT!1B0    ;*SIGN BIT DOESN'T WORK
FS6BIT: SIXBIT /MTAX/           ;STORED INTO BY START ROUTINE
INOUT:  XWD     0,0             ;STORED INTO BY SETIN/SETOUT

; TAPIN READS ONE RECORDS FROM TAPE AND RETURNS TO:
;  CALL+1 IF END OF FILE READ
;  CALL+2 IF DIRECTORY, HEADER, OR TRAILER IS READ
;  CALL+3 IF DATA RECORD READ
; IF IT RETURNS TO CALL+2, R1 TELLS WHAT WAS READ:
;  TRAILER=-1, HEADER=0, DIRECTORY=1

TAPIN:  SETOM   R0              ;INITIALIZE ERROR COUNT TO 0-1
TAPINE: IN      TAP,            ;READ ANOTHER BUFFER
        JRST    TAPIN2          ;READ OK
        STATO   TAP,IOEND       ;END OF FILE?
        JRST    ERRTIN          ;GO TO ERROR ROUTINE
        CLOSE   TAP,            ;CLEAR END BIT
        POPJ    P,              ;RETURN CALL+1 (EOF)

TAPIN2: ILDB    R2,TAPHD1       ;PICKUP WORD COUNT
        SOS     TAPHD2          ;ADJUST WD CT BELOW THIS WORD
        HLRZ    R2,R2           ;0 FOR DATA, -1 FOR DIR
        JUMPE   R2,CPOPJ2       ;JUMP IF IT'S A DATA RECORD
        MOVE    R1,TAPHED       ;GET ADDRESS OF CURRENT BUFFER
        CAIN    R2,-1           ;SKIP IF NOT A DIR RECORD
        JRST    TINDIR          ;DIRECTORY FOUND
        HRLE    R1,4(R1)        ;-=TRAILER, +=HEADER; 0 OR -1 IN ADDR
        CAIN    R2,-6
        ERROR   [ASCII "FAILSAFE LEVEL C FORMAT TAPE_"];*
        SKIPGE  R1              ;SKIP IF HEADER (OR MAYBE ERROR)
        CALLI   TAP,WAIT        ;WAIT FOR TAPE TO PASS ONE EOF
        JUMPG   R2,CPOPJ1       ;HEADER/TRAILER
        ERROR   [ASCII "ERROR IN TAPE DATA._"];*

ERRTIN: GETSTS  TAP,R1          ;GET ERROR BITS
        TRZ     R1,760000       ;CLEAR ERROR BITS
        SETSTS  TAP,(R1)        ;SET NEW STATUS
        AOJG    R0,TAPINE       ;INC ERR CNT - JUMP IF NOT 1ST ERROR
        PUSHJ   P,TAPINE        ;NOTE THAT THIS IS CALLED RECURSIVELY
        JRST    ETIEOF          ;EOF - TELL OPERATOR AND RETURN
        JRST    ETIDIR          ;DIR - TELL OPERATOR AND RETURN
        JRST    .-3             ;DATA - READ UNTIL NEXT FILE
ETIDIR: SKIPA   R2,[1]          ;SKIP ONCE WHEN WE RET FROM ORIG TAPIN
ETIEOF: MOVEI   R2,0            ;DON'T SKIP WHEN WE RETURN FROM ORIG TAPIN
        ADDM    R2,(P)          ;INCREMENT 0 OR 1 FOR ORIG TAPIN RET
        PUSH    P,R2            ;SAVE TYPE OF BLOCK JUST READ ON STACK
        PUSH    P,R1            ;SAVE CONTENTS OF R1 FOR RETURN
        AOS     R0              ;INCREMENT ERROR CNT BEFORE PRINTING
        PUSHJ   P,PRDNUM        ;PRINT NUMBER OF ERRORS
        TYPE    [ASCII " TAPE ERROR(S) READING USER FILE _"]
        MOVEI   R2,LSTPPN       ;ADDRESS OF LAST PPN, FILE, AND EXT
        PUSHJ   P,PRTPFX        ;PRINT FILE, EXT, AND PPN
        POP     P,R0            ;RESTORE TYPE OF BLOCK JUST READ
        JUMPG   R0,.+3          ;JUMP IF DIRECTORY JUST READ
        TYPE    [ASCII "$CONTINUING WITH THE NEXT USER.$_"]
        JRST    ETIRET          ;RETURN FROM ORIG TAPIN CALL
        TYPE    [ASCII "$CONTINUING WITH FILE _"]
        MOVEI   R2,CURPPN       ;GET ADDRESS OF CURRENT PPN, FILE, EXT
        PUSHJ   P,PRTPFX        ;PRINT PPN, FILE NAME, AND EXTENSION
        TCO     [CRCHR]         ;OUTPUT A CARRIAGE RETURN
ETIRET: POP     P,R1            ;RESTORE R1 FOR HEADER, TRAILER, DIR
        POPJ    P,              ;RETURN FROM ORIGINAL TAPIN CALL

TINDIR: MOVE    R2,[XWD CURPPN,LSTPPN]
        BLT     R2,LSTEXT       ;MOVE CURPPN-FIL-EXT TO LSTPPN-FIL-EXT
        MOVSI   R2,5(R1)        ;ADDRESS OF NEW PPN-FIL-EXT
        HRRI    R2,CURPPN       ;ADDRESS OF CURRENT PPN
        BLT     R2,CUREXT       ;SET UP NEW CURRENT PPN-FIL-EXT
        MOVEI   R1,1            ;JUST READ A DIRECTORY
        JRST    CPOPJ1          ;SKIP RETURN FROM TAPIN

CPOPJ2: AOS     0(P)            ;RETURN TWO SKIPS
CPOPJ1: AOS     (P)             ;RETURN +1
CPOPJ:  POPJ    P,              ;RETURN

DIRROU::MTAPE   TAP,1           ;*REWIND THE TAPE - THIS MAY NOT BE RIGHT
        MTAPE   TAP,0           ;WAIT FOR REWIND TO FINISH
        SETZM   DIRSSC#         ;ZERO THE SAVE SET COUNT
        AOS     DIRSSC          ;WORKING ON FIRST SAVE SET
        PUSHJ   P,HEADIN        ;READ IN HEADER
        JRST    DIR1A
DIR1:   PUSHJ   P,TAPIN         ;INPUT A RECORD FROM TAPE
        ERROR   [ASCII "$NO TRAILER RECORD BEFORE LOGICAL EOT._"]
        JRST    .+3(R1)         ;TRAILER=-1, HEADER=0, DIR=1
        ERROR   [ASCII "$DIRECTORY RECORD NOT FOUND BEFORE DATA._"]
        ERROR   [ASCII "TRAILER FOUND AFTER EOF_"];*
        ERROR   [ASCII "HEADER FOUND IN MIDDLE OF TAPE_"]
DIR1A:  TYPE    [ASCII "$DIRECTORY FOR _"]
        MOVE    R2,TAPHED       ;WHERE THE DIRECTORY IS
        MOVEI   R2,5(R2)        ;PROJ-PROG NUMBER
        PUSHJ   P,PRTPPN        ;PRINT PPN FOR THIS USER
        TCO     [CRCHR]         ;END THE LINE
DIR2:   MOVE    R2,TAPHED       ;GET ADDRESS OF CURRENT BUFFER
        MOVEI   R2,6(R2)        ;GET ADDRESS OF FILE NAME
        PUSHJ   P,PRTFX         ;PRINT FILE NAME AND EXTENSION
        TAB     14              ;SPACE OUT TO MAKE IT PRETTY
        PUSHJ   P,PRTDT         ;PRINT DATE-TIME FOLLOWING EXT IN DIR
        TCO     [CRCHR]         ;PRINT A CARRIAGE RETURN
DIR3:   PUSHJ   P,TAPIN         ;IGNORE DATA
        JRST    DIR1            ;EOF - DONE WITH THIS USER
        JRST    .+3(R1)         ;TRAILER=-1, HEADER=0, DIR=1
        JRST    DIR3            ;IGNORE DATA
        JRST    DIR4            ;FOUND TRAILER SO WE'RE DONE
        ERROR   [ASCII "HEADER FOUND IN MIDDLE OF TAPE_"]
        JRST    DIR2            ;DIRECTORY - START NEXT FILE
DIR4:   MOVE    R2,TAPHED       ;GET ADDRESS OF CURRENT BUFFER
        MOVE    R2,5(R2)        ;GET CONTINUATION BITS FROM TRAILER
        TLNE    R2,USRCTD       ;SKIP IF USER IS NOT CONTINUED
        TYPE    [ASCII "$USER IS CONTINUED ON THE NEXT TAPE.$_"]
        TLNE    R2,TAPCTD       ;SKIP IF THIS IS THE LAST TAPE
        TYPE    [ASCII "$CONTINUATION TAPE(S) FOLLOW._"]
        PUSHJ   P,TAPIN         ;READ EOF AFTER TRAILER
        JRST    .+3             ;READ EOF
        JUMP                    ;FALL INTO ERROR MSG BELOW
        ERROR   [ASCII "EOF NOT FOUND AFTER TRAILER_"]
        PUSHJ   P,TAPIN         ;READ THE NEXT RECORD
        JRST    DIREOT          ;LOGICAL END OF TAPE
        JRST    .+3(R1)         ;TRAILER=-1, HEADER=0, DIR=1
        ERROR   [ASCII "DATA BLOCK FOUND WITHOUT HEADER_"]
        ERROR   [ASCII "FOUND TWO TRAILER BLOCKS IN A ROW_"]
        JRST    DIRNSS          ;PROCESS NEXT SAVE SET
        ERROR   [ASCII "FOUND DIRECTORY BLOCK WITHOUT HEADER_"]
DIRNSS: TYPE    [ASCII "$$$THIS IS SAVE SET NUMBER _"]
        AOS     R2,DIRSSC       ;INCREMENT THE SAVE SET COUNT
        MOVE    R0,DIRSSC       ;GET THE SAVE SET COUNT
        PUSHJ   P,PRDNUM        ;PRINT THE SAVE SET COUNT
        CAIL    R2,12           ;DON'T PRINT DECIMAL IF LESS THAN TEN
        TYPE    [ASCII " (DECIMAL)_"]
        PUSHJ   P,DIRHED        ;FINISH PROCESSING HEADER
        JRST    DIR1A           ;PRINT THE SAVE SET
DIREOT: MTAPE   TAP,1           ;REWIND THE TAPE
        TYPE    [ASCII "$LOGICAL END OF TAPE_"]
        JRST    CDISP           ;RETURN TO COMMAND DISPATCHER

SKITRM::MOVEM   R0,SKICNT#      ;SAVE THE SKIP COUNT
        PUSHJ   P,SETIN         ;SET TAPE FOR INPUT
SKITIN: PUSHJ   P,TAPIN         ;READ A RECORD
        JRST    SKITIN          ;IGNORE END OF FILE
        JRST    .+3(R1)         ;TRAILER=-1, HEADER=0, DIR=1
        JRST    SKITIN          ;IGNORE DATA
        JRST    SKITRL          ;TRAILER
        JRST    SKITIN          ;IGNORE HEADER
        JRST    SKITIN          ;IGNORE DIRECTORIES
SKITRL: PUSHJ   P,TAPIN         ;READ EOF FOLLOWING TRAILER
        JRST    .+3             ;EOF - CONTINUE
        JUMP                    ;TRAILER, HEADER, OR DIR - ERROR
        ERROR   [ASCII "END OF FILE NOT FOUND AFTER TRAILER_"]
        SOSG    SKICNT          ;DECREMENT COUNT AND SKIP IF NOT DONE
        JRST    CDISP           ;RETURN TO COMMAND DISPATCHER
        PUSHJ   P,TAPIN         ;READ EOF OR HEADER AFTER LAST EOF
        JRST    SKIEOT          ;END OF TAPE
        JRST    SKITIN          ;PROBABLY HEADER SO CONTINUE LOOPING
        JRST    SKITIN          ;SHOULDN'T BE DATA HERE BUT IGNORE IT
SKIEOT: MTAPE   TAP,17          ;BACKSPACE OVER LAST EOF
        MTAPE   TAP,0           ;WAIT FOR OPERATION TO COMPLETE
        TYPE    [ASCII "NOW POSITIONED AT LOGICAL END OF TAPE._"]
        JRST    CDISP           ;RETURN TO COMMAND DISPATCHER
;*-

QUIROU::CALLI   RESET           ;TERMINATE ALL I/O
        EXIT                    ;RETURN TO EXEC
REWROU::MTAPE   TAP,1           ;REWIND THE TAPE
        MTAPE   TAP,0           ;*WAIT FOR REWIND TO FINISH
        JRST    CDISP           ;RETURN TO COMMAND DISPATCHER

ILLFMT: ERROR   [ASCII "$ILLEGAL TAPE FORMAT_"] ;*
HEADIN: PUSHJ   P,SETIN         ;INSURE BUFFERS
        PUSHJ   P,TAPIN         ;READ FIRST RECORD
        JRST    BADHED          ;EOF
        TRNE    R1,1            ;SKIP IF HEADER - OTHERWISE BAD FMT
        JRST    BADHED
DIRHED: TYPE    [ASCII "$FAILSAFE TAPE _"]
        MOVE    R2,TAPHED       ;WHERE THE HEADER IS
        HLRE    R0,2(R2)        ;XWD HEADER FLAG,INTERNAL WORD COUNT
        JUMPLE  R0,BADHED       ;INSIST ON HEADER FLAG (VERSION #)
        HRRE    R0,4(R2)        ;GET TAPE NUMBER
        MOVMS   R0              ;MAGNITUDE ONLY
        PUSHJ   P,PRDNUM        ;PUBLISH IT
        TYPE    [ASCII " RECORDED _"]
        MOVEI   R2,5(R2)        ;GET ADDRESS OF DATE AND TIME
        PUSHJ   P,PRTDT         ;PUBLISH DATE AND TIME
        MOVE    R2,TAPHED       ;ADDRESS OF CURRENT BUFFER
        MOVE    R1,5(R2)        ;GET TAPE CONTINUE BIT
        TLNE    R1,TAPCTD       ;SKIP IF NOT A CONTINUATION TAPE
        TYPE    [ASCII "$THIS IS A CONTINUATION TAPE._"]
        TCO     [CRCHR]         ;END THE LINE
        PUSHJ   P,TAPIN         ;INPUT A RECORD
        JRST    FSTDIR          ;EOF - READ FIRST DIR
        JUMP
        TYPE    [ASCII "EOF NOT FOUND AFTER HEADER._"]
FSTDIR: PUSHJ   P,TAPIN         ;READ NEXT RECORD
        JRST    FSTDIR          ;*EOF - IGNORE
        JRST    .+3(R1)         ;TRAILER=-1, HEADER=0, DIR=1
        JRST    FSTDIR          ;*DATA - IGNORE
        JRST    FSTDIR          ;*TRAILER - IGNORE
        JRST    FSTDIR          ;*HEADER - IGNORE
        POPJ    P,              ;DIRECTORY
BADHED: TYPE    [ASCII "NO HEADER FOUND AT BEGINNING OF TAPE.$"]
        CAIE    R1,1            ;SKIP IF DIR READ
        JRST    FSTDIR          ;NO - FIND FIRST DIR
        POPJ    P,              ;RETURN

;*ADD APPENDIX E ERROR CODES FOR UUO ERRORS
;*CHECK FOR OPERATOR LICENSE
GETROU::SKIPA   R1,[0]          ;GET ROUTINE
RESROU::HRREI   R1,-1           ;RESTORE ROUTINE
        MOVEM   R1,GETFLG#      ;FLAG TO DISTINGUISH BETWEEN GET AND RESTORE
CONRES: PUSHJ   P,HEADIN        ;READ IN HEADER AND PRINT INFO
        JRST    UNSLU6          ;READ IN DIRECTORY OR WHATEVER
SETST1: JRST    SETST2          ;*DON'T EXECUTE THE CODE FOR A WHILE
        MOVEM   R1,UFDDI1       ;SAVE PPN FOR UFD LOOKUPS
        INIT    UFD,BUFBIN
        SIXBIT  /DSK/
        XWD     0,UFDHED        ;LOOKUPS ONLY
        ERROR   [ASCII "CANNOT ACCESS THE DISC._"]
        MOVEI   R1,UFDBUF       ;USE THE UFD BUFFERS
        MOVEM   R1,JOBFF        ;TELL MONITOR WHERE TO PUT THE BUFFERS
        INBUF   UFD,UFDN        ;SET UP THE BUFFERS
        MOVEI   R1,XLOOKN       ;SET SPECS FOR LOOKUP
        MOVEM   R1,UFDDIR
        MOVE    R1,6(R2)        ;UFD NAME
        MOVEM   R1,UFDDI2
        HLLZ    R1,7(R2)        ;*EXT="UFD" - WHAT IF IT ISN'T?
        MOVEM   R1,UFDDI3
        LOOKUP  UFD,UFDDIR      ;DOES THIS UFD ALREADY EXIST?
        JRST    FIXUFD          ;NO, MAKE ONE LIKE THE ORIGINAL

;MOVE TO NEXT UFD

SETST2: PUSHJ   P,TAPIN         ;READ NEXT RECORD FROM TAPE
        JRST    SETST3          ;EOF - START RESTORING
        JRST    .+3(R1)         ;TRAILER=-1, HEADER=0, DIR=1
        JRST    SETST2          ;IGNORE DATA RECORDS
        ERROR   [ASCII "HEADER FOUND IN MIDDLE OF TAPE_"];*
        JRST    TAPEND          ;TRAILER
        CLOSE   UFD,DNC         ;DIR - CLOSE THIS UFD
        JRST    SETST1          ;NO, PROCESS NEXT UFD
SETST3: CLOSE   UFD,DNC         ;CLOSE UFD
        JRST    UNSLU5          ;START RESTORING

;MAKE A UFD ON THIS STR WITH QUOTA FROM THE TAPE
;*PERHAPS THIS SHOULD NOT BE DONE

FIXUFD: MOVSI   R1,2(R2)        ;START OF SPECS IN TAPBUF
        HRRI    R1,UFDDIR       ;SPEC AREA
        BLT     R1,UFDDIR+XLOOKN
        SETZM   URBPOS          ;CLR SPECIAL ITEMS
        SETZM   URBNXT
        SETZM   URBPRD
        SETZM   URBUFD
        SETZM   URBELB
        SETZM   URBEUN
        INIT    MFD,BUFBIN
        SIXBIT  /DSK/
        XWD     MFDHED,0
        ERROR   [ASCII "UNABLE TO ACCESS MFD_"]
        MOVEI   R1,UFDDIR
        HRLI    R1,4(R2)
        BLT     R1,UFDDIR+XLOOKN;RESTORE SPECS AFTER LOOKUP
        SETZM   URBCSZ          ;ZERO CURRENT SIZE SINCE NO FILES
        ENTER   MFD,UFDDIR      ;CREATE THIS UFD
        ERROR   [ASCII "UNABLE TO OUTPUT TO MFD_"]
        OUTPUT  MFD,            ;OUTPUT THE NEW UFD
        CLOSE   MFD,DNC         ;CLOSE THE MFD
        RELEAS  MFD,            ;RELEASE THE MFD
        JRST    SETST2          ;GET NEXT UFD

UNSLU5: PUSHJ   P,TAPIN         ;GET 1ST RECORD OF NEXT FILE
        ERROR   [ASCII "NO TRAILER FOUND BEFORE LOGICAL END OF TAPE_"]
        JRST    .+3(R1)         ;TRAILER=-1, HEADER=0, DIR=1
        ERROR   [ASCII "DATA RECORD FOUND WITH NO DIRECTORY_"]
        JRST    TAPEND          ;TRAILER
HEDERR: ERROR   [ASCII "HEADER FOUND IN MIDDLE OF TAPE_"]
;*      MOVE    R1,FILDI1       ;DIR
;*      MOVEM   R1,UFDDI2
UNSLU6: MOVE    R2,TAPHED       ;GET ADDRESS OF CURRENT BUFFER
        MOVE    U,5(R2)         ;GET PPN
        CAMN    U,SYSPP         ;SKIP IF NOT USER 1,1 (UFD)
        JRST    SETST1          ;*THIS SHOULD BE IMPROVED
        PUSHJ   P,CKNPPN        ;SEE IF THIS PPN SHOULD BE RESTORED
        JRST    UNSLU2          ;IGNORE THIS USER
UNSLU1: MOVE    R2,TAPHED       ;GET ADDRESS OF CURRENT BUFFER
        MOVE    U,6(R2)         ;GET FILE NAME
        HLRZ    W,7(R2)         ;GET EXTENSION
        PUSHJ   P,CKNFIL        ;SKIP IF THIS FILE SHOULD BE RESTORED
        JRST    UNSLU3          ;IGNORE THIS FILE
        PUSHJ   P,XFER          ;MOVE A USER FILE FROM TAPE TO DISK
        JRST    UNSLU5          ;EOF - NEXT USER
        JRST    UNSLU1          ;GET NEXT FILE FOR THIS USER
        TYPE    [ASCII "$RESTORE COMPLETED._"]
        JRST    CDISP           ;RETURN TO COMMAND DISPATCHER
UNSLU2: PUSHJ   P,TAPIN         ;INPUT A RECORD FROM TAPE
        JRST    UNSLU5          ;EOF - TRY NEXT USER
        JRST    .+3(R1)         ;TRAILER=-1, HEADER=0, DIR=1
        JRST    UNSLU2          ;IGNORE DATA RECORDS
        JRST    TAPEND          ;TRAILER - HANDLE END OF TAPE
        JRST    HEDERR          ;HEADER
        JRST    UNSLU2          ;DIR - IGNORE THIS FILE TOO

UNSLU3: PUSHJ   P,TAPIN         ;INPUT A RECORD FROM TAPE
        JRST    UNSLU5          ;EOF - TRY NEXT USER
        JRST    .+3(R1)         ;TRAILER=-1, HEADER=0, DIR=1
        JRST    UNSLU3          ;DATA - IGNORE IT
        JRST    TAPEND          ;TRAILER - HANDLE END OF TAPE
        JRST    HEDERR          ;HEADER
        JRST    UNSLU1          ;DIR - TRY THIS FILE

TAPEND: CLOSE   TAP,            ;*CLEAR UP TAPE BUFFERS - MAY NOT BE NECESSARY
        CLOSE   FIL,DNC
        RELEASE FIL,
        CLOSE   UFD,DNC
        RELEASE UFD,
        MOVE    R2,TAPHED       ;GET ADDRESS OF CURRENT BUFFER
        SKIPL   5(R2)           ;CONTINUED?
        JRST    FINTAP          ;NO
        TYPE    [ASCII "END OF FAILSAFE TAPE _"]
        MOVE    R2,TAPHED       ;GET ADDRESS OF CURRENT BUFFER
        HRRE    R0,4(R2)        ;GET TAPE NUMBER
        MOVMS   R0              ;MAGNITUDE
        PUSHJ   P,PRDNUM        ;PRINT IT
        TYPE    [ASCII " FOR _"]
        MOVEI   R2,5(R2)        ;GET ADDRESS OF DATE AND TIME
        PUSHJ   P,PRTDT         ;PRINT THEM
        MTAPE   TAP,1           ;REWIND
        TYPE    [ASCII "$TO CONTINUE RESTORING THE DISC, MOUNT$_"]
        TYPE    [ASCII "THE NEXT TAPE ON THE SAME DRIVE$_"]
        TYPE    [ASCII "WHEN IT IS MOUNTED TYPE A CARRIAGE RETURN: _"]
        CLRIN                   ;CLEAR INPUT BUFFER
        TCI     R1,R2           ;INPUT THE CARRIAGE RETURN
        CAIE    R1,TE           ;SKIP IF IT'S A TERMINATOR
        ERROR   [ASCII "RESTORE ABORTED._"]
        JRST    CONRES          ;START RESTORING NEXT TAPE
FINTAP: TYPE    [ASCII "$RESTORE COMPLETED._"];*PRINT CORRECT COMMAND
        JRST    CDISP           ;RETURN TO COMMAND DISPATCHER

XFER:   MOVE    R2,TAPHED       ;WHERE TAPE BUFFER IS
        SKIPN   GETFLG          ;SKIP IF NOT A GET COMMAND
        SETZM   5(R2)           ;ZERO PPN TO RESTORE TO THIS USER
        MOVSI   R1,3(R2)        ;NO, SET UP LOOKUP HEADER
        HRRI    R1,FILDM1
        BLT     R1,FILDIR+XLOOKN
        INIT    CHK,14          ;INIT FOR DISK FILE DATE CHECK
        SIXBIT  /DSK/
        XWD     0,CHKHED        ;=UFDHED
        ERROR   [ASCII "CANNOT INIT DISC FOR DATE CHECK_"];*
        MOVEI   R1,CHKBUF       ;SET UP BUFFERS
        MOVEM   R1,JOBFF
        INBUF   CHK,CHKN
        LOOKUP  CHK,FILDIR      ;CHECK CURRENT DISK FILE
        JRST    XFER3           ;RESTORE FILE IF LOOKUP FAILS
                                ;*CHECK CREATION DATES ETC HERE?
        CLOSE   CHK,DNC         ;NO, CLOSE DISK FILE
XFER3:  MOVE    R2,TAPHED       ;GET ADDRESS OF CURRENT BUFFER
        MOVSI   R1,4(R2)        ;
        HRRI    R1,FILDIR
        BLT     R1,FILDIR+XLOOKN
        SETZM   FRBPOS
        SETZM   FRBNXT
        SETZM   FRBUFD
        SETZM   FRBELB
        SETZM   FRBEUN
        MOVEI   R1,XLOOKN+2     ;REMOVE HEADER WORDS FROM BEGINNING OF FILE
        ADDM    R1,TAPHD1
        MOVNI   R1,XLOOKN+2
        ADDM    R1,TAPHD2
        INIT    FIL,BUFBIN
        SIXBIT  /DSK/
        XWD     FILHED,0
        ERROR   [ASCII "DISC NOT AVAILABLE_"]
        MOVEI   R1,FILBUF
        MOVEM   R1,JOBFF
        OUTBUF  FIL,FILN
        PUSHJ   P,CKLIC
        HLLZS   FILLIC          ;DON'T ENTER LICENSE
        ENTER   FIL,FILDIR
        PUSHJ   P,ENTFER        ;ENTER ERROR ROUTINE
        MOVE    R1,FILDI3       ;GET OLD/NEW BIT FOR THIS FILE
        TRNE    R1,400000       ;SKIP IF NEW FILE
        JRST    XFER3A          ;SEE IF HE REALLY WANTS TO WRITE FILE
XFER3C: AOS     TAPHD2          ;ADJUST FOR SOSG ENTERED FROM ABOVE
XFER2:  SOSLE   TAPHD2          ;GET A WORD FROM TAPE
        JRST    XFER2A          ;SOME THERE ALREADY
        PUSHJ   P,TAPIN
        JRST    XFER2C          ;EOF
        JRST    XFER2D+1(R1)    ;-1=TRAILER, 0=HEADER, 1=DIR
XFER2A: ILDB    R1,TAPHD1
        SOSG    FILHD2          ;STASH INTO USER FILE
        OUT     FIL,            ;OUTPUT THE FILE
        JRST    XFER2B          ;SUCCESSFUL
        ERROR   [ASCII "ERROR IN WRITING TO USER FILE_"];**
XFER2B: IDPB    R1,FILHD1
        JRST    XFER2           ;TRY AGAIN
XFER2D: AOSA    (P)             ;SKIP TWICE TO TRAILER
        ERROR   [ASCII "$HEADER FOUND IN MIDDLE OF TAPE._"]
        AOS     (P)             ;SKIP RETURN FOR DIRECTORY
XFER2C: CLOSE   FIL,DNC         ;CLOSE THE FILE
        MOVEI   R2,LSTPPN       ;ADDRESS OF PPN FIL.EXT JUST DONE
        PUSHJ   P,PRTPFX        ;PRINT PPN FIL.EXT
        TCO     [CRCHR]         ;END THE LINE
        POPJ    P,              ;RETURN
XFER3A: CLOSE   FIL,40          ;CLOSE FILE AND KEEP IT OUT OF DIR
        CLRIN                   ;CLEAR INPUT BUFFER
        MOVE    R1,COUT##       ;GET COMMAND FILE FLAG
        MOVEM   R1,XFCOUT#      ;SAVE IN TEMP CELL
        SETZM   COUT            ;TERMINAL OUTPUT
        TYPE    [ASCII "FILE _"]
        MOVEI   R2,CURPPN       ;ADDRESS OF CURRENT PPN FILE.EXT
        PUSHJ   P,PRTPFX        ;PRINT CURRENT PPN FILE.EXT
        TYPE    [ASCII " ALREADY EXISTS.$TYPE A CARRIAGE RETURN TO WRITE OVER IT: _"]
        TCI     R1              ;GET THE GUY'S CARRIAGE RETURN
        CLRIN                   ;LAZY WAY TO READ REST OF LINE
        MOVE    R2,XFCOUT       ;GET NORMAL OUTPUT FILE
        MOVEM   R2,COUT         ;RESTORE NORMAL OUTPUT
        CAIN    R1,CRCHR        ;SKIP IF HE DIDN'T TYPE A CR
        JRST    XFER3B          ;OK TO WRITE OVER FILE
        PUSHJ   P,TAPIN         ;SKIP TO NEXT FILE ON TAPE
        POPJ    P,              ;EOF - RETURN
        JRST    .+3(R1)         ;-1=TRAILER, 0=HEADER, 1=DIR
        JRST    .-3             ;IGNORE DATA
        AOSA    (P)             ;SKIP TWICE FOR TRAILER
        JRST    HEDERR          ;SHOULDN'T FIND HEADER HERE
        JRST    CPOPJ1          ;SKIP RETURN FOR DIR
XFER3B: ENTER   FIL,FILDIR      ;DO THE ENTER AGAIN
        PUSHJ   P,ENTFER        ;HANDLE THE ERROR
        JRST    XFER3C          ;CONTINUE AS USUAL
ENTFER: BLOCK   0               ;*IMPROVE THIS KLUDGE
        HRRZ    R1,FILDI3       ;GET ERROR BITS
        TRZ     R1,400000       ;TURN OFF OLD/NEW BIT
        CAIE    R1,17           ;SKIP IF IT'S A FRAGMENTATION ERROR
        ERROR   [ASCII "UNABLE TO ENTER FILE._"];*
        SETZM   FRBALC          ;FRAGMENTATION IS OK
        CLOSE   FIL,40          ;CLOSE TO KEEP IT OUT OF DIRECTORY
        SOS     (P)             ;DECREMENT FIRST TIME FOR REPOP
        SOS     (P)             ;DECREMENT SECOND TIME FOR REPOP
        POPJ    P,              ;RETRY THE ENTER

CKLIC:  HRRZ R1,FILLIC
        JUMPE   R1,CPOPJ
        MOVEI   R2,FILDI2       ;ADDRESS OF FILE NAME
        PUSHJ   P,PRTFX         ;PRINT FILE NAME AND EXTENSION
        MOVEI   R2,FILDI1       ;ADDRESS OF PPN
        PUSHJ   P,PRTPPN        ;PRINT THE PPN
        TYPE    [ASCII "NEEDS LICENSE_"]
        HRRZ R0,FILLIC      
        PUSHJ P,PRONUM
        TCO     [CRCHR]

;BUFFER HEADERS

TAPHED: BLOCK   3               ;MAGTAP INPUT OR OUTPUT BUFFER HEADER**2
TAPHD1= TAPHED+1
TAPHD2= TAPHED+2 

MFDHED: BLOCK   3               ;DISK MFD BUFFER HEADER**2
MFDHD1= MFDHED+1
MFDHD2= MFDHED+2

UFDHED: BLOCK   3               ;DISK UFD BUFFER HEADER**2
UFDHD1= UFDHED+1
UFDHD2= UFDHED+2

FILHED: BLOCK   3               ;DISK USER FILE BUFFER HEADER**2
FILHD1= FILHED+1
FILHD2= FILHED+2

COFHED::BLOCK   3               ;OUTPUT FILE
COFHD1=:COFHED+1
COFHD2=:COFHED+2

CHKHED: BLOCK   3               ;DATE CHECK FILE HEADER

;MTA HEADER BLOCK
FIRBLK: XWD     VERSION,4       ;WD0=XWD HEADER FLAG,BLK WDCT
        SIXBIT  /*FAILS/        ;WD1
FIRBL2: SIXBIT  /AFE   /        ;WD2=XWD SIXBIT "AFE",TAPE SEQ#
                                ;NEGATIVE TAPE SEQ# MEANS TRAILER
FIRBL3: EXP     0               ;WD3=TAPCTD BIT (B0), USRCTD BIT (B1)
                                ;    CRTIME (B13-23), CRDATE (B24-35)
        XWD     1,2             ;WD4=FAILSAFE PROJ,PROG #

SYSPP:  XWD     1,1

STRPPN::0                       ;STARTING PPN
STRFIL::0                       ;STARTING FILE
STREXT::0                       ;STARTING EXTENSION
CURPPN: 0                       ;CURRENT PPN
CURFIL: 0                       ;CURRENT FILE NAME
CUREXT: 0                       ;CURRENT EXTENSION
LSTPPN: 0                       ;LAST PPN
LSTFIL: 0                       ;LAST FILE NAME
LSTEXT: 0                       ;LAST EXTENSION

CREDAT::0                       ;CREATION DATE - DAYS SINCE 1964
CRETIM::0                       ;CREATION TIME - SECONDS LSH 12
CRTION: 0                       ;CREATION DATE AND TIME FROM UFD

;LOOKUP & ENTER SPECS
                                ;EXT LOOKUP     -    OLD LOOKUP
MFDDIR: 0                       ;0,XLOOKN       -     FILNAM
MFDDI1: 0                       ;PPN            -     EXT.,ACC.DAT.
        0                       ;FILNAM         -     PROT,MODE,CREAT
MFDDI3: 0                       ;EXT.,ACC.DAT.   -    PPN
        0                       ;PROT,MODE,CREAT
        BLOCK   5               ;--NEVER TOUCH--
        0                       ;--CLR BEFORE RESTORE--
        0                       ;   "    "       "
        0                       ;   "    "       "
        BLOCK   1               ;--NEVER TOUCH--
        0                       ;--CLR BEFORE RESTORE--
        0                       ;FILE STATUS WORD
        0                       ;--CLR BEFORE RESTORE--
        0                       ;   "    "       "
        BLOCK   XLOOKN+.-MFDDIR

UFDDIR: 0                       ;0,XLOOKN       -     FILNAM
UFDDI1: 0                       ;PPN            -     EXT.,ACC.DAT.
UFDDI2: 0                       ;FILNAM         -     PROT,MODE,CREAT
UFDDI3: 0                       ;EXT.,ACC.DAT.   -    PPN
        0                       ;PROT,MODE,CREAT
        BLOCK   5               ;--NEVER TOUCH--
URBPOS: 0                       ;--CLR BEFORE RESTORE--
URBNXT: 0                       ;   "    "       "
URBPRD: 0                       ;   "    "       "
        BLOCK   1               ;--NEVER TOUCH--
URBUFD: 0                       ;--CLR BEFORE RESTORE--
        0                       ;FILE STATUS WORD
URBELB: 0                       ;--CLR BEFORE RESTORE--
URBEUN: 0                       ;   "    "       "
        BLOCK   3
URBCSZ: BLOCK   1               ;CURRENT SIZE
        BLOCK   XLOOKN+.-UFDDIR ;---NEVER TOUCH ON SAVE OR RESTORE--

FILMRK: XWD     -1,XLOOKN+2     ;FILE HEADER (MUST PRECEDE CURSTR)
FILDM1: SIXBIT  /DSK/   ;CURRENT FILE STRUCTURE (MUST PRECEDE FILDIR)
FILDIR: 0                       ;0,XLOOKN       -     FILNAM
FILDI1: 0                       ;PPN            -     EXT.,ACC.DAT.
FILDI2: 0                       ;FILNAM         -     PROT,MODE,CREAT
FILDI3: 0                       ;EXT.,ACC.DAT.   -    PPN
        0                       ;PROT,MODE,CREAT
        BLOCK   4               ;--NEVER TOUCH--
FRBALC: 0                       ;# OF BLKS NEEDED
FRBPOS: 0                       ;--CLR BEFORE RESTORE--
FRBNXT: 0                       ;   "    "       "
        0                       ;   "    "       "
FILLIC: BLOCK   1               ;FILE LICENSE
FRBUFD: 0                       ;--CLR BEFORE RESTORE--
FRBSTS: 0                       ;FILE STATUS WORD
FRBELB: 0                       ;--CLR BEFORE RESTORE--
FRBEUN: 0                       ;   "    "       "
        BLOCK   XLOOKN+.-FILDIR
;MISCELLANEOUS DATA

MFDSPK: BUFBIN
        SIXBIT  /DSK/           ;MUST BE MFDSPK+1
IOBUF:  0                       ;OBUF,IBUF FOR MFD - MUST BE MFDSPK+2

        VAR                     ;MISC. VARIABLES

;I/O BUFFERS

MFDBUF: BLOCK   MFDN*DSKSIZ     ;BUFFERS FOR MFD
UFDBUF: BLOCK   UFDN*DSKSIZ     ;BUFFERS FOR UFD
CHKBUF: BLOCK   CHKN*DSKSIZ     ;DATE CHECK FILE BUFFER
FILBUF: BLOCK   FILN*DSKSIZ     ;BUFFERS FOR USER FILE
TAPBUF: BLOCK   TAPN*TAPSIZ
        END     START
   >a67