!22 MAR 73       NISLA.SIM      *CW
DEF BINARY AS 1
DEF CLUMP.SZ AS 5

LOCAL SECRET.NUM

GLOBAL SLAVE.Q
GLOBAL %SLAVE
GLOBAL %INIT.SLAVE
GLOBAL %R.ACKN
GLOBAL %R.ACKP
GLOBAL %R.BCKSUM
GLOBAL %R.BCKT
GLOBAL %R.BDATA
GLOBAL %R.CHAN
GLOBAL %R.CHOKE
GLOBAL %R.CLOSE
GLOBAL %R.KLOSEA
GLOBAL %R.CREATE
GLOBAL %R.ECHO
GLOBAL %R.ECHOR
GLOBAL %R.ERASE
GLOBAL %R.ERR
GLOBAL %R.FCBDATA
GLOBAL %R.MACK
GLOBAL %R.NULL
GLOBAL %R.OPEN
GLOBAL %R.PAUSE
GLOBAL %R.QUIT
GLOBAL %R.RBLKS
GLOBAL %R.RENAME
GLOBAL %R.RTEXT
GLOBAL %R.SBLKS
GLOBAL %R.SENDFCB
GLOBAL %R.SENDV
GLOBAL %R.SETV
GLOBAL %R.STEST
GLOBAL %R.STEXT
GLOBAL %R.VAR
GLOBAL %R.WSLAVE
GLOBAL %R.ZCKT

GLOBAL FCB.AREA
GLOBAL TCB.AREA

FIND %FUSBUDGET
FIND %HD.FULL.P
FIND %END.RECIP
FIND %FM.PTR
FIND %N.OFF.PACK
FIND %B.RECHO
FIND %FM.ELMT
FIND %LOCAL.Q
FIND %W.BLK
FIND %HD.FULL
FIND %B.ACKP
FIND %AR.N
FIND %CLOSE.IT
FIND %D.AREA
FIND %R.ELMT
FIND %GET.TCB
FIND %SEND.IT
FIND %B.M.ACK
FIND %DUP.BUF
FIND %APP.EXT
FIND %FILE.EXISTS
FIND %G.ANCHOR
FIND %R.P.CDR
FIND %L.P.CDR
FIND %S.LN.CHOKE
FIND %HD.TURN.ON
FIND %HD.TST.BIT
FIND %ARG.CK
FIND %STR.BLD
FIND %B.RBLKS
FIND %BLD.ARG
FIND %S.SP.AR
FIND %C.AREA
FIND %OPEN.IT
FIND %G.ELMT
FIND %FM.STRING
FIND %GET.SYMBOL.VALUE
FIND %SET.SYMBOL.VALUE
FIND %FM.FR.INT
FIND %OUT.BUF
FIND %OUT.MAP
FIND %R.P.L.DATA
FIND %LN.NUM
FIND %LN.ESTABLISH
FIND %LN.ASSOC
FIND %LN.IDEN
FIND %BLD.CMD
FIND %OUT.RKD
FIND %BUF.LENGTH
FIND %GET.BUF.CHAR
FIND %C.ELMTS
FIND %L.P.L.DATA
FIND %R.RCB
FIND %ENCODE.CMND
FIND %PUNT
FIND %AUDIT
FIND %BLD.CKT

FIND TCB.LIST
FIND MASK(0)
FIND MASK.COMP(0)
FIND P.Q.AREA
FIND LOCAL.NAME
FIND STORE(0)


!
%SLAVE
!INPUT:  NONE
!VALUE:  NONE

!PROCESSES SLAVE COMMANDS FOUND IN THE SLAVE.Q

LOCAL RCB.PTR
LOCAL CMD.BLK
LOCAL P

LOCAL %DO.CMD

TOP:NULL
IF  (RCB.PTR _ R.P.CDR(SLAVE.Q)) = E.O.L  &
 THEN &
 DO
  MSG('NO WORK FOR SLAVE$')
  RETURN (TRUE)
 END

WHILE  (CMD.BLK _ ENCODE.CMND(RCB.PTR)) &
 THEN &
 DO
  FUSBUDGET
  DO.CMD
  FUSBUDGET
 END
FUSBUDGET

L.P.CDR(SLAVE.Q,R.P.CDR(RCB.PTR))               !STEP DOWN SLAVE.Q
R.RCB(RCB.PTR)                                 !DELETE PROCESSED RCB
GO TOP

!
%DO.CMD
!INPUT: NONE
!VALUE: NONE

LOCAL CMD.CODE

!PERFORM THE DO CASE ON SLAVE COMMANDS

IF 0>(CMD.CODE _ R.CMD.CODE(CMD.BLK))>MAX.CMND &
 THEN &
 DO
  PUNT(HARD,'SLAVE.CMD OUT OF BOUNDS BEFORE DO CASE IN SLAVE$',0)
 END

DO CMD.CODE OF 0:MAX.CMND

0: MSG('SLAVE CMD.CODE IS 0: BOO..$')

ACKN.CMND:    P _ R.ACKN(CMD.BLK)
ACKP.CMND:    P _ R.ACKP(CMD.BLK)
BCKSUM.CMND:  P _ R.BCKSUM(CMD.BLK)
BCKT.CMND:    P _ R.BCKT(CMD.BLK)
MACK.CMND:    P _ R.MACK(CMD.BLK)
BDATA.CMND:   P _ R.BDATA(CMD.BLK)
CHAN.CMND:    P _ R.CHAN(CMD.BLK)
CHOKE.CMND:   P _ R.CHOKE(CMD.BLK)
CLOSE.CMND:   P _ R.CLOSE(CMD.BLK)
CLOSEA.CMND:  P _ R.KLOSEA(CMD.BLK)
CREATE.CMND:  P _ R.CREATE(CMD.BLK)
ECHO.CMND:    P _ R.ECHO(CMD.BLK)
ECHOR.CMND:   P _ R.ECHOR(CMD.BLK)
ERASE.CMND:   P _ R.ERASE(CMD.BLK)
ERR.CMND:     P _ R.ERR(CMD.BLK)
FCBDATA.CMND: P _ R.FCBDATA(CMD.BLK)
NULL.CMND:    P _ R.NULL(CMD.BLK)
OPEN.CMND:    P _ R.OPEN(CMD.BLK)
PAUSE.CMND:   P _ R.PAUSE(CMD.BLK)
QUIT.CMND:    P _ R.QUIT(CMD.BLK)
RBLKS.CMND:   P _ R.RBLKS(CMD.BLK)
RENAME.CMND:  P _ R.RENAME(CMD.BLK)
RTEXT.CMND:   P _ R.RTEXT(CMD.BLK)
SBLKS.CMND:   P _ R.SBLKS(CMD.BLK)
SENDFCB.CMND: P _ R.SENDFCB(CMD.BLK)
SENDV.CMND:   P _ R.SENDV(CMD.BLK)
SETV.CMND:    P _ R.SETV(CMD.BLK)
STEST.CMND:   P _ R.STEST(CMD.BLK)
STEXT.CMND:   P _ R.STEXT(CMD.BLK)
VAR.CMND:     P _ R.VAR(CMD.BLK)
WSLAVE.CMND:  P _ R.WSLAVE(CMD.BLK)
ZCKT.CMND:    P _ R.ZCKT(CMD.BLK)

END  !END OF DOCASE

R.ELMT(CMD.BLK)                !RETURN USED COMMAND BLOCK
IF P THEN RETURN (TRUE)

MSG('COMMAND PROCESSOR FAILED IN SLAVE. CMD.CODE # IS ')
OUT.FR.INT(TEL,CMD.CODE)

RETURN  (FALSE)
END DO.CMD

END SLAVE
!
%R.ACKN(CMD.BLK)                        !NEGATIVE ACKNOWLEDGEMENT
HALT !**********
END R.ACKN
!
%R.ACKP(CMD.BLK)                        !POSITIVE ACKNOWLEDGEMENT
!INPUT: THE ENCODED COMMAND BLOCK
!VALUE: TRUE

LOCAL I, TRANS.NO, FIRST.BLK, LAST.BLK, TCB, HD

!DUTIES:
! 1. GET ARGUMENTS FROM COMMAND BLOCK
! 2. IF A NON-ZERO BLOCK IS BEING ACKNOWLEDGED THEN MARK HDCNT TABLE.
! 3. CALL SEND.IT TO SEND NEXT SET OF CHACKSUMS OR NEXT DATA BLK.

MSG('R.ACKP$')

! 1. SET UP ARGS
IF (I _ R.NUMARG(CMD.BLK)) # 3 &
 THEN &
  PUNT( MED, 'WRONG NUM ARGS: ', 1, 1, I)

TRANS.NO  _ R.ARGVAL(CMD.BLK, 1)
FIRST.BLK _ R.ARGVAL(CMD.BLK, 2)
LAST.BLK  _ R.ARGVAL(CMD.BLK, 3)

IF (TCB _ GET.TCB(TRANS.NO)) = 0 THEN RETURN (TRUE) !IGNORE EXTRA CMD

! 2. MARK HDCNT TABLE IF NECESSARY
HD _ R.TCB.HD(TCB)
IF FIRST.BLK # 0 &
 THEN &
 DO
  I _ FIRST.BLK-1
  WHILE (INC I) <= LAST.BLK &
   THEN &
   DO
    IF HD.TST.BIT(HD, I) &
     THEN &
      PUNT(MED, 'HDCNT BIT ALREADY ON. BLK# ', 1, 1, FIRST.BLK+I)
    HD.TURN.ON(HD, I)
   END
 END

! 3. CALL SEND.IT TO SEND NEXT SET OF CHECKSUMS OR NEXT DATA BLK.
SEND.IT(TRANS.NO)

RETURN (TRUE)

END R.ACKP

!
%R.BCKSUM(CMD.BLK)                      !PROCESS BLOCK CHECKSUMS
!INPUT: THE ENCODED COMMAND BLOCK
!VALUE: FALSE IF END.RECIP FAILS, TRUE OTHERWISE

DEF ODD.P(X) AS BYT(X,1,0)

LOCAL FILE.INFO, N, TCB, TYPE, SUM(1:CLUMP.SZ+1), HD
LOCAL ICP, BS, POS, FCB.B, FCB, I, P, CKSUM, BUF, CHAR
LOCAL OK.P, BAD.P, FILE.P, FOUND.P, TOT, K, TRANS.NO, FIRST.BLK
LOCAL FN, FN.B, FIRST, LAST

LOCAL %SUM.IT, %COMP.SUM

!DUTIES:
! 1. SET UP OPERANDS
! 2. COMPUTE POSITION OF BLK IN FILE.BAD AND/OR FILE
! 3. IF BLK EXISTS IN FILE.BAD (IN FILE IF NO PRIOR FILE.BAD), THEN
!    COMPUTE CKSUM AND COMPARE TO INPUT CKSUM: IF EQUAL SET
!    SUM(I) TRUE, ELSE SET SUM(I) FALSE.
! 5. SEND ACKP COMMAND TO DONOR FOR BLOCKS WHOSE SUM(I)=TRUE.

! 1. SET UP OPERANDS
IF I _ R.NUMARG(CMD.BLK) # 4 + (N _ R.ARGVAL(CMD.BLK, 4)) &
 THEN PUNT(MED, 'WRONG NUM ARGS: BCKSUM: ',1, 1, I)

TRANS.NO  _ R.ARGVAL(CMD.BLK, 1)
TYPE      _ R.ARGVAL(CMD.BLK, 2)
FIRST.BLK _ R.ARGVAL(CMD.BLK, 3)
I _ 0
WHILE (INC I) <= N THEN SUM(I) _ R.ARGVAL(CMD.BLK, I+4)

TCB _ GET.TCB(TRANS.NO)

FILE.INFO _ R.TCB.INFO(TCB)
HD        _ R.TCB.HD  (TCB)

IF FILE.INFO = 0 &
 THEN &
 DO
  PUNT(SOFT, 'BCKSUM: FILE.INFO=0', 0)
  RETURN (FALSE)
 END

FCB _ R.TCB.FCB(TCB)            !FILE CTL BLK FOR FILE
FCB.B _ R.TCB.FCB.B(TCB)        !FILE CTL BLK FOR FILE.BAD

ICP _ R.TCB.ICP(TCB)            !INITIAL CURSOR POSITION FOR BLK
BS  _ R.TCB.BS (TCB)            !BLOCK SIZE
TOT _ R.TCB.BYTS(TCB) + 1       !POSITION OF LAST BYTE +1

! 2. COMPUTE POSITION OF BLK IN FILE.BAD
POS _ ICP + BS*(FIRST.BLK-1)    !START OF FIRST BLOCK

!IF BLOCK EXISTS IN FILE.BAD, THEN COMPUTE CKSUM AND COMPARE.
!COMP.SUM SETS SUM(I) TRUE OR FALSE IF EQUAL OR NOT
BAD.P _ ODD.P(FILE.INFO)        !TRUE IF FILE.BAD EXTANT PRIOR
FILE.P _ FALSE
IF FILE.INFO>1 THEN FILE.P _ TRUE       !TRUE IF FILE EXTANT PRIOR

POS _ POS - BS                  !INITIALIZE FOR LOOP TOP TEST
TOT _ TOT + BS
I _ 0
WHILE (INC I) <= N &
 THEN &
 DO
  POS _ POS + BS        !UPDATE POSITION BY BLOCK SIZE
  TOT _ TOT - BS        !REDUCE TOTAL BYTES LEFT BY BLOCK SIZE
  IF TOT < BS THEN BS _ TOT
  OK.P _ FALSE
  IF BAD.P THEN [P;CKSUM] _ DOUBLE SUM.IT(FCB.B,POS,BS)
  IF P THEN OK.P _ COMP.SUM(CKSUM,SUM(I))

  IF FILE.P AND NOT OK.P &
   THEN [P;CKSUM] _ DOUBLE SUM.IT(FCB,POS,BS)
  IF P AND COMP.SUM(CKSUM, SUM(I)) &
   THEN &
   DO           !COPY BLOCK FROM FILE TO FILE.BAD
    MSG('COPY BLOCK FROM FILE TO FILE.BAD$')
    SETCP(FN   _ R.FCB.FN(FCB  ), POS)  !POSITION FILE
    SETCP(FN.B _ R.FCB.FN(FCB.B), POS)  !POSITION FILE.BAD

    K _ 0
    WHILE (INC K) <= BS &
     THEN &
     DO
      W(FN.B, CHAR_R(FN))
      MSG('CHAR: ');OUT.PTR(TEL, CHAR)
     END
   END

 END    !END OF WHILE LOOP

!NOW LOOP THROUGH SUM(I) LOOKING FOR SEQUENCE OF TRUES TO SEND ACKP
!FOR THAT SEQUENCE.  WE LOOP ONE EXTRA TIME WITH THE EXTRA SUM(I) SET
!FALSE PRIOR TO THE LOOP
I _ FIRST.BLK -1
SUM(FIRST.BLK+N) _ FALSE
FOUND.P _ FALSE
WHILE (INC I) <= FIRST.BLK+N &
 THEN &
 DO
  IF SUM(I) &
   THEN &
   DO
    HD.TURN.ON(HD, I)           !WE HAVE A GOOD BLOCK I
    LAST _ I
    IF NOT FOUND.P THEN FIRST _ I
    FOUND.P _ TRUE
   END &
  ELSE &
   DO
    IF FOUND.P !THEN A SEQUENCE FROM FIRST TO LAST EXISTS! &
     THEN &
     DO
      FOUND.P _ FALSE
      IF NOT(HD.FULL.P(HD)) &
       THEN &
       DO
        BUF _ B.ACKP(E.O.L, TRANS.NO-1, FIRST, LAST)
        OUT.RKD(BUF, R.TCB.JOB(TCB), LOCAL.NAME, TRUE, TRUE)
       END &
      ELSE  RETURN (END.RECIP(TRANS.NO))
     END
   END
 END

RETURN (TRUE)

!
%COMP.SUM(SUM1, SUM2)
!INPUT: CKSUMS TO BE COMPARED
!VALUE: TRUE/FALSE IF COMPARE EQUAL/UNEQUAL

IF SUM1 # SUM2 THEN SUM(I)_FALSE ELSE SUM(I)_TRUE

RETURN (SUM(I))

END COMP.SUM




%SUM.IT(FCB, ICP, N)    !COMPUTE CKSUM FOR N CHARS AT ICP IN FILE FN(FCB)
!INPUT: FILE CONTROL BLOCK FOR THE FILE
!       CURSOR POSITION OF THE START OF BLOCK
!       NUMBER OF 8-BIT BYTES TO CKSUM
!VALUE: 1. TRUE/FALSE IF CKSUM COMPUTED
!       2. THE BARBERPOLE CKSUM

LOCAL FN, ERR:, CHAR, SUM

MSG('SUM.IT$')

!IF BLOCK EXISTS ON FILE, THEN COMPUTE CKSUM
IF NOT(FCB)  THEN  RETURN [FALSE;0]

IF (ICP+N) > SIZE(FN _ R.FCB.FN(FCB))  THEN  RETURN [FALSE;0]

SETRWE(FN, ERR)         !WE SHOULD NOT HIT END OF FILE
SETCP(FN, ICP)

I _ SUM _ 0
WHILE (INC I) <= N &
 THEN &
 DO
  CHAR _ R(FN)          !READ 8 BITS
  MSG('CHAR: '); W(TEL, CHAR)   !***********DEBUG*********
  SUM _ (((SUM SHL 1) BOR (SUM SHR 23)) BAND OCT 77777777) BXOR CHAR
 END

RETURN [TRUE;SUM]

ERR: PUNT(MED,'READ ERR ON CKSUM FILE ',1, 2,STR.BLD(R.FCB.NAME(FCB),0))

END SUM.IT

END R.BCKSUM
!
%R.BCKT(CMD.BLK)                !BUILD CIRCUIT
!INPUT:  THE ENCODED COMMAND BLOCK
!VALUE:  TRUE/FALSE IF CIRCUIT BUILT OR NOT

LOCAL P,  DEST,  COMPUTER,  NAME,  PORT,  BLD.BUF,  ADDR,  LINE
!VALIDATE COMMAND ARGS

                        !CHECK NUMBER OF ARGUMENTS
IF R.NUMARG(CMD.BLK) # 3  THEN PUNT(HARD,'WRONG NUMBER OF ARGS',0)
IF R.ARGTYP(CMD.BLK,1) # PRS.T.CHAN  OR  &
   R.ARGTYP(CMD.BLK,2) # PRS.T.INT   OR  &
   R.ARGTYP(CMD.BLK,3) # PRS.T.CHAN  THEN PUNT(HARD,'BAD OPND',0)

DEST     _ R.ARGVAL(CMD.BLK,1)          !DESTINATION CHAN NAME
COMPUTER _ R.ARGVAL(CMD.BLK,2)          !COMP # TO BLD CKT TO
NAME     _ R.ARGVAL(CMD.BLK,3)          !NAME TO ASSOC WITH NEW CKT

IF LOCAL.NAME = DEST &
 THEN &
 DO                                     !BUILD AUX CIRCUIT
  [P;PORT] _ DOUBLE BLD.CKT(COMPUTER)
  IF P &
   THEN  LN.ESTABLISH(PORT,NAME,COMPUTER) &
   ELSE  [MSG('BLD.CKT FAILED$'); RETURN FALSE]
 END &
 ELSE &
 DO
  LINE _ LN.ASSOC(DEST,NAME)            !ASSOC NAME WITH LINE
  ADDR _ LN.IDEN(LINE)                  !FIND NEXT ADDRESSEE
  BLD.BUF _ BLD.CMD(E.O.L,CMD.BLK,BCKT.CMND)     
  OUT.RKD(BLD.BUF,ADDR,LOCAL.NAME,TRUE,TRUE)
 END

RETURN (TRUE)

END R.BCKT
!
%R.BDATA(CMD.BLK)                       !PROCESS BLOCK OF DATA 
!INPUT: ENCODED COMMAND BLOCK
!VALUE: TRUE

LOCAL FILE.INFO, DUP.TO, HD
LOCAL TRANS.NO, BLK, N, DATA, I, TCB, BUF, FCB, FCB.B, JOB
LOCAL OFF, BUF.NAME, BUF.NAME.B, NAME(1:15), REN.ERR:

!DUTIES:
! 1. SET UP OPERANDS
! 2. IF ALL DATA IS HERE, THEN IGNORE THIS COMMAND
! 3. CALL ROUTINE TO WRITE DATA ON RECIPIENT FILE.BAD
! 4. IF THIS IS NOT THE LAST BLOCK TO BE REC'D, THEN SEND ACK.P TO DONOR
! 5. OTHERWISE, ALL DATA IS HERE, SO SEND MACK(100), CLEANUP (INCLUDING
!         RENAMING FILE.BAD TO FILE, ETC), AND SEND MACK(200)

MSG('R.BDATA$')

! 1. SET UP OPERANDS
IF I _ R.NUMARG(CMD.BLK) # 5 &
 THEN &
  PUNT(MED, 'WRONG NUM ARGS:', 1, 1, I)

TRANS.NO _ R.ARGVAL(CMD.BLK, 1)
BLK      _ R.ARGVAL(CMD.BLK, 2)
N        _ R.ARGVAL(CMD.BLK, 3) !NUMBER OF CHARS OF DATA
DATA     _ R.ARGVAL(CMD.BLK, 4)         !BUF PTR TO DATA
OFF      _ R.ARGVAL(CMD.BLK, 5)         !BUF OFFSET TO FIRST BYTE DATA

! 2. IF ALL DATA ALREADY HERE THEN IGNORE THIS COMMAND
IF (TCB _ GET.TCB(TRANS.NO)) = 0 THEN RETURN (TRUE) !IGNORE CMD
HD _ R.TCB.HD(TCB)

! 3. CALL W.BLK TO PERFORM FILE WRITE
IF HD.TST.BIT(HD, BLK) THEN RETURN (TRUE)       !ALREADY REC'D THIS BLK
W.BLK(TCB, N, DATA, OFF)                !WRITE N-BYTE BLOCK TO FILE.BAD
HD.TURN.ON(HD, BLK)                     !MARK BLOCK REC'D IN HD.CNT TABL
L.TCB.WBLK(TCB, R.TCB.WBLK(TCB)+1)      !UPDATE BLKS REC'D BY 1

! 4. IF THIS IS NOT THE LAST BLOCK THEN SEND ACKP TO DONOR
IF  NOT (HD.FULL(HD)) &
 THEN &
 DO
  BUF _ B.ACKP(E.O.L, TRANS.NO-1, BLK, BLK)     !BUILD ACKP COMMAND
  OUT.RKD(BUF, R.TCB.JOB(TCB), LOCAL.NAME, TRUE, TRUE)!SEND TO DONOR
  RETURN (TRUE)
 END

RETURN (END.RECIP(TRANS.NO))
END R.BDATA
!
%R.CHAN(CMD.BLK)                !ASSOCIATE CHANNEL NAME
!INPUT:  THE ENCODED COMMAND BLOCK
!VALUE:  TRUE 

IF R.NUMARG(CMD.BLK) # 2 THEN PUNT(HARD,'WRONG NUMBER OF ARGS',0)
IF R.ARGTYP(CMD.BLK,1) # PRS.T.CHAN  OR &
   R.ARGTYP(CMD.BLK,2) # PRS.T.CHAN  &
 THEN &
  PUNT(HARD,'BAD ARG TYPE',0)

LN.ASSOC(R.ARGVAL(CMD.BLK,1),R.ARGVAL(CMD.BLK,2))       !DO THE WORK

RETURN (TRUE)

END R.CHAN
!
%R.CHOKE(CMD.BLK)                       !RESTRICT RATE OF OUTBOUND DATA
!INPUT:  THEN ENCODED COMMAND BLOCK
!VALUE:  TRUE

LOCAL PT1,PT2,PV1,PV2

!GET THE PARAMETER TYPES AND VALUES
PT1 _ R.ARGTYP(CMD.BLK,1)
PV1 _ R.ARGVAL(CMD.BLK,1)
PT2 _ R.ARGTYP(CMD.BLK,2)
PV2 _ R.ARGVAL(CMD.BLK,2)

!VALIDATE PARAMETERS
IF PT1 # S.V.T.INT OR &
   PT2 # S.V.T.INT &
 THEN &
  PUNT(HARD,'BAD ARG TYPE',0)

!SET THE CHOKE FOR THIS LINE
S.LN.CHOKE(LN.NUM(PV1),PV2)

RETURN (TRUE)

END R.CHOKE
!
%R.CLOSE(CMD.BLK)                       !CLOSE A FILE
!INPUT:  THE ENCODED COMMAND BLOCK
!VALUE:  TRUE

LOCAL FCB

IF R.NUMARG(CMD.BLK) # 1  THEN  PUNT(HARD,'WRONG NUMBER OF ARGS',0)
IF R.ARGTYP(CMD.BLK,1) # S.V.T.PTR &
 THEN PUNT(HARD,'INVALID ARG',0)

FCB _ R.ARGVAL(CMD.BLK,1)               !FILE CONTROL BLOCK PTR
CLOSE(R.FCB.FN(FCB))                    !IOCS OR 940 ROUTINE CALL
L.FCB.OP.P(FCB,FALSE)                   !OPEN PRED = FALSE ***GRBG COLL

RETURN (TRUE)

END R.CLOSE
!
%R.KLOSEA(CMD.BLK)                      !CLOSE ALL OPENED FILES
HALT !*******
END R.KLOSEA

%R.CREATE(CMD.BLK)                      !CREATE A NEW FILE
HALT !*******
END R.CREATE

%R.ECHO(CMD.BLK)                        !ECHO THE ECHO DATA
MSG('ECHO CMD$')
RETURN
END R.ECHO

%R.ECHOR(CMD.BLK)                       !RETURN OF THE ECHO DATA
MSG('ECHOR CMD$')
RETURN
END R.ECHOR

%R.ERASE(CMD.BLK)                       !SET CURSOR AND ERASE BLOCKS
HALT !*********
END R.ERASE

%R.ERR(CMD.BLK)                         !ERROR MESSAGES
HALT !******
END R.ERR

%R.FCBDATA(CMD.BLK)                     !FILE CONTROL BLOCK DATA
HALT !*******
END R.FCBDATA

!
%R.M.ACK(CMD.BLK)                       !MACRO (LARGE) ACKNOWLEDGEMENT
!INPUT:  THE ENCODED COMMAND BLK
!VALUE:  TRUE

LOCAL I, TRANS.NO, FILE.INFO, TCB, BUF

MSG('R.M.ACK$')
!VALIDATE ARGS
IF I _ R.NUMARG(CMD.BLK) # 2 &
 THEN &
  PUNT(MED, 'WRONG NUM ARGS:',1, 1, I)
I _ 0
WHILE (INC I) <= 2 THEN ARG.CK(CMD.BLK, PRS.T.INT, I)

TRANS.NO _ R.ARGVAL(CMD.BLK, 1)
FILE.INFO _ R.ARGVAL(CMD.BLK, 2)

IF 0<=FILE.INFO<=3  THEN  I _ 0  ELSE  I _ FILE.INFO/100    !FOR DO CASE
IF  NOT( 0<=I<=3 ) &
 THEN &
 DO
  PUNT(MED, 'FILE.INFO INVALID:', 1, 1, FILE.INFO)
  FILE.INFO _ I _ 0                             !IF CONTINUE AFTER PUNT
 END

!DO THE WORK
IF I#3 THEN  TCB _ GET.TCB(TRANS.NO)    !NO TCB IN I=3 CASE: JOB DONE
DO  I OF 0:3

0: L.TCB.INFO(TCB,FILE.INFO)
   IF FILE.INFO=0 THEN I_2 ELSE I_1
   L.TCB.STEP(TCB,I)            !START SENDING BCKSUMS OR BDATAS
   SEND.IT(TRANS.NO)            !0 <= FILE.INFO <= 3

1: NULL                         !FILE.INFO = 100...TIME TO CLEANUP
   CLOSE.IT(R.TCB.FCB(TCB))     !CLOSE DONOR FILE
   D.AREA(AR.N(R.TCB.HD(TCB)))  !DELETE HDCNT AREA

2: NULL                         !FILE.INFO = 200...TRANSACTION COMPLETE
   BUF _ B.RECHO(E.O.L, R.TCB.ECH1(TCB), R.TCB.ECH2(TCB))
                                !TELL MASTER OF COMPLETION
   OUT.RKD(BUF, 0 !MASTER!, LOCAL.NAME, TRUE, TRUE)
   S.SP.AR(1,TCB.LIST,0,TRANS.NO)  !DELETE TCB FROM SPARSE ARRAY
   R.ELMT(TCB)                  !RETURN TCB 

3: NULL                         !THIS SHOULD BE FIELDED BY MASTER

END !END OF DO CASE

RETURN (TRUE)

END R.M.ACK
!
%R.NULL(CMD.BLK)                        !DO NOTHING--READ MESSAGE
HALT !**********
END R.NULL
!
%R.OPEN(CMD.BLK)                        !OPEN A FILE
!INPUT:  THEN ENCODED COMMAND BLOCK
!VALUE:  TRUE/FALSE IF FILE OPENED

LOCAL FN,NAME,P,MODE,ERR,SYM,VALUE,FCB,TYPE

!VALIDATE ARGS
IF R.NUMARG(CMD.BLK)#2 THEN PUNT(HARD,'WRONG NUMBER OF ARGS',0)

IF R.ARGTYP(CMD.BLK,1) # S.V.T.PTR OR &
   R.ARGTYP(CMD.BLK,2) # PRS.T.INT  THEN  PUNT(HARD,'U.CMND.OP',0)

NAME _ STR.BLD(SYM _ R.ARGVAL(CMD.BLK,1),0)
[P;FN] _ DOUBLE OPEN.IT(NAME,MODE _ R.ARGVAL(CMD.BLK,2)) !OPEN FILE
IF NOT P &
 THEN &
 DO 
  !FN HOLDS ERROR MSG; NEED TO BUILD ERR COMMAND HERE *****
  RETURN (FALSE)
 END

!FILE MAY BE IN SYMBOL TABLE
[TYPE;FCB] _ DOUBLE GET.SYMBOL.VALUE(SYM,S.T.FILE)
IF TYPE # S.V.T.PTR &
 THEN &
 DO
  !MUST ENTER FILE NAME INTO SYMBOL TABLE
  P _ SET.SYMBOL.VALUE(SYM,S.T.FILE,S.V.T.PTR,FCB _ G.ELMT(FCB.AREA))
  IF NOT P &
   THEN &
   DO
    MSG('FILE NOT ENTERED IN SYMVOL TABLE IN R.OPEN$')
    RETURN (FALSE)
   END
  TYPE _ S.V.T.PTR
 END

!SET UP FILE CONTROL BLOCK
L.FCB.FN(FCB,FN)                        !FILE NUMBER
L.FCB.CP(FCB,0)                         !CURSOR POSITION
L.FCB.OP.P(FCB,TRUE)                    !YES, THIS FILE IS OPEN
L.FCB.MODE(FCB,MODE)                    !READ=1,WRITE=2,UPDATE=3
[TYPE;VALUE] _ DOUBLE GET.SYMBOL.VALUE(FM.STRING('STDBLKSZ'),S.T.VAR)
IF TYPE # S.V.T.INT &
 THEN &
  MSG('GET.SYM.VAL OF STD.BLK.SZ FAILED IN R.OPEN$') !DEBUG****
L.FCB.BS(FCB,VALUE)                     !STANDARD BLOCK SIZE IN BYTES
L.FCB.FT(FCB,1)                         !1=BINARY FILE
L.FCB.NAME(FCB,SYM)                     !BUF PTR TO FILE NAME


RETURN (TRUE)

END R.OPEN

%R.PAUSE(CMD.BLK)                       !STOP PROCESFOR A TIME
HALT !********
END R.PAUSE

%R.QUIT(CMD.BLK)                        !QUIT THE BUSINESS ENTIRELY
HALT !********
END R.QUIT
!
%R.RBLKS(CMD.BLK)                       !GET READY TO RECEIVE BLOCKS
!INPUT: RECIPIENT FILE NAME STRING
!       DONOR JOB NAME
!       TRANSACTION NUMBER 
!       BLOCK SIZE IN 8-BIT BYTES
!       NUMBER OF BLOCKS TO BE RECEIVED
!       INITIAL CURSOR POSITION
!       CHECKSUM FOLD SIZE
!       FILE TYPE: BINARY, SYMBOLIC
!VALUE: TRUE

LOCAL %OP.EXT

FUSS: FUSBUDGET

LOCAL FILE.INFO, HD, ORG, EXT, DUP.TO, FNUM, FNUM.B, FID, FID.B
LOCAL TCB, FCB, FCB.B, ARG, FN.BUF
LOCAL FN, DONOR, TRANS.NO, BS, BLKS, CP, FOLD, FT, BUF, BYTS

!DUTIES OF R.RBLKS ROUTINE:
!
! 1. SET UP PARAMETERS FROM ENCODED COMMAND BLOCK
! 2. SET UP HD.CNT TABLE
! 3. OPEN RECIPIENT FILE
!    A. CHECK IF FILE.BAD EXISTS: 
!        I. IF SO, OPEN FOR UPDATE, SET FILE.INFO TO 1
!       II. ELSE, CREATE FILE.BAD, SET FILE.INFO TO 0
!    B. CHECK IF RECIPIENT FILE EXISTS ALREADY:
!        I. IF SO, OPEN FOR INPUT (READ), SET FILE.INFO TO FILE.INFO+2
! 4. SET UP TRANSACTON CONTROL BLOCK (TCB) AND ENTER ONTO ARRAY
! 5. SEND MACK COMMAND TO DONOR SO THAT DONOR WILL START SENDING
!        BCKSUM OR BDATA COMMANDS


! 1. SET UP ARGS FROM ENCODED CMD BLK
IF FN _ R.NUMARG(CMD.BLK) # 8 &
 THEN &
  PUNT(MED,'RBLKS WITH WRONG NUMBER ARGS', 1, 1, FN)
ARG _ 1
ARG.CK(CMD.BLK, PRS.T.LIT, ARG)
ARG.CK(CMD.BLK, PRS.T.INT, INC ARG)
WHILE (INC ARG) <= 8 &
 THEN &
  ARG.CK(CMD.BLK, PRS.T.INT, ARG)

FN       _ R.ARGVAL(CMD.BLK, 1)
DONOR    _ R.ARGVAL(CMD.BLK, 2)
TRANS.NO _ R.ARGVAL(CMD.BLK, 3)
BS       _ R.ARGVAL(CMD.BLK, 4)
BYTS     _ R.ARGVAL(CMD.BLK, 5)
CP       _ R.ARGVAL(CMD.BLK, 6)
FOLD     _ R.ARGVAL(CMD.BLK, 7)
FT       _ R.ARGVAL(CMD.BLK, 8)

! 2. SET UP HDCNT TABLE
[;HD] _ DOUBLE C.AREA((BLKS/BITS.PER.WORD+1)+1) !NEED 1 BIT PER BLK
HD _ N.OFF.PACK(HD, 0)          !BUILD PTR FROM AREA NAME
BLKS _ BYTS/BS
IF (BYTS MOD BS)#0 THEN BLKS _ BLKS+1
L.P.L.DATA(HD, 0, BLKS)               !NUMBER OF BITS (= NUMBER OF BLKS)

! 3. OPEN RECIPIENT FILE: CHECK IF FILE.BAD EXITS, ETC.
OP.EXT                          !OPEN FILE.BAD, ETC.

! 4. SET UP TCB AND ATTACH TO 1 DIMENSIONAL SPARSE ARRAY
TCB _ G.ELMT(TCB.AREA)

L.TCB.FCB  (TCB,FCB)            !FILE FCB OR 0
L.TCB.FCB.B(TCB,FCB.B)          !FILE.BAD FCB
L.TCB.HD   (TCB,HD)             !HDCNT TABLE PTR
L.TCB.CP   (TCB,CP)             !WORKING CURSOR POSITION
L.TCB.ICP  (TCB,CP)             !INITIAL CURSOR POSITION
L.TCB.BS   (TCB,BS)             !BLOCK SIZE IN 8-BIT BYTES
L.TCB.BYTS (TCB,BYTS)           !NUMBER OF BYTS IN THIS TRANSACTION
L.TCB.WBLK (TCB,0)              !NUMBER OF BLOCKS REC'D
L.TCB.JOB  (TCB,DONOR)          !DONOR JOB NUMBER
L.TCB.FOLD (TCB,FOLD)   !CHECKSUM FOLD SIZE OF DONOR FILE
L.TCB.INFO (TCB, FILE.INFO)     

S.SP.AR(1, TCB.LIST, TCB, TRANS.NO)     !USE TRANS.NO AS COORDINATE IN
                                        !ARRAY. ELEMENT VALUE IS TCB PTR

! 5. SEND MACK COMMAND TO DONOR (CONTAINING FILE.INFO) SO THAT DONOR
!    WILL START SENDING BCKSUM OR BDATA COMMANDS

BUF _ B.MACK(E.O.L, TRANS.NO-1, FILE.INFO)      !BUILD MACK COMMAND
OUT.RKD(BUF, DONOR, LOCAL.NAME, TRUE, TRUE)     !SEND MACK TO DONOR

RETURN (TRUE)
!
%OP.EXT                         !OPEN FILE.BAD ETC.
!INPUT: NONE
!VALUE: NONE

IF PDP10.P &
 THEN &
 DO
  ORG _ PACK                    !8-BIT BYTES FOR IOCS
  EXT _ '.BAD'
  DUP.TO _ '.'
 END &
ELSE &
 DO
  ORG _ CHARACTER
  EXT _ '/BAD/'
  DUP.TO _ 0
 END

!IF EXTENSION EXISTS ON PDP10, THEN DUP NAME WITHOUT EXTENSION
FN.BUF _ DUP.BUF(E.O.L, FN, DUP.TO)
FN.BUF _ APP.EXT(FN.BUF, EXT)           !APPEND EXTENSION TO FILE NAME
IF FILE.EXISTS(FN.BUF)                  !DOES FILE.BAD EXIST! &
 THEN &
  FILE.INFO _ 1                         !FILE.BAD EXISTS ALREADY! &
ELSE &
 FILE.INFO _ 0                          !FILE.BAD WILL BE CREATED NEW

FCB.B _ OPEN.IT(FN.BUF, UPDATE, BINARY) !OPEN FILE.BAD

IF FILE.EXISTS(FN)                      !DOES RECIPIENT FILE EXIST ! &
 THEN &
 DO
  FILE.INFO _ FILE.INFO+2               !FILE EXISTS
  FCB _ OPEN.IT(FN, INPUT, BINARY)      !OPEN EXISTING RECIPIENT FILE
 END

RETURN

END OP.EXT


END R.RBLKS
!
%R.RENAME(CMD.BLK)                      !RENAME A FILE
HALT !*******
END R.RENAME

%R.RTEXT(CMD.BLK)                        !RECEIVE FREE TEXT
HALT !*********
END R.RTEXT
!
%R.SBLKS(CMD.BLK)                       !TELL RECIPIENT TO SEND BLOCKS
!INPUT:  THE ENCODED COMMAND BLOCK
!VALUE:  TRUE

!DUTIES OF THIS ROUTINE ARE:
!
! 1. CHECK LINE EXISTS TO RECIPIENT
! 2. OPEN DONOR FILE
! 3. CHECK ARGUMENTS FOR DEFAULT CASES
! 4. SET UP HEAD COUNT TABLE
! 5. SET UP TRANSACTION CONTROL BLOCK (TCB)
! 6. GENERATE TRANSACTION NUMBER AND ATTACH TCB TO ARRAY OF TCB'S
! 7. SEND RBLKS COMMAND TO RECIPIENT

LOCAL LINE, TRANS.NO, FCB
LOCAL BLKS, BS, CP, FOLD
LOCAL FT, P, RECIP.JOB
LOCAL BUF, TCB, HD, BYTS

!MSG('R.SBLKS. CMD.BLK IS:$')
!OUT.ELMT(TEL, CMD.BLK)

!VALIDATE OPERANDS
IF R.NUMARG(CMD.BLK) # 10 THEN PUNT(HARD,'WRONG NUMBER OF ARGS',0)

! 1. CHECK LINE EXISTS TO RECIPIENT
LINE _ LN.NUM(RECIP.JOB _ R.ARGVAL(CMD.BLK,3))
IF LINE = 0 &
 THEN &
  IF NOT(LOCAL.Q(RECIP.JOB)) &
   THEN &
   DO
    PUNT(MED, 'LINE NOT EXTANT FOR SBLKS', 0)
    !**************ERR COMMAND GOES HERE**************
   END

! 2. OPEN DONOR FILE
FCB _ OPEN.IT(R.ARGVAL(CMD.BLK, 1), INPUT, BINARY)

! 3. CHECK ARGS FOR DEFAULT CASES
IF R.ARGTYP(CMD.BLK,3) #PRS.T.CHAN  THEN  PUNT(HARD,'U.CMND.OP',0)
RECIP.JOB _ R.ARGVAL(CMD.BLK,3)           !RECIPIENT JOB NAME

BS _ R.ARGVAL(CMD.BLK,4)                !BLOCK SIZE
IF R.ARGTYP(CMD.BLK,4) # PRS.T.INT  OR &
   BS = 0 &
 THEN &
 DO
  BS _ R.FCB.BS(FCB)
 END

BYTS _ R.ARGVAL(CMD.BLK,5)              !NUMBER OF BYTES TO SHIP
IF R.ARGTYP(CMD.BLK,5) # PRS.T.INT OR &
   BYTS = 0 &
 THEN &
 DO
  BYTS _ SIZE(R.FCB.FN(FCB))        !FILE SIZE IN 8-BIT BYTES ******
                                        !WRONG NUMBER FOR ODD WORD PDP10
                                        !**************************
 END
BLKS _ BYTS/BS                        !# BLOCKS IN FILE WITH A
IF (BYTS MOD BS)#0 THEN BLKS _ BLKS+1 !MINOR ADJUSTMENT

CP _ R.ARGVAL(CMD.BLK,6)                !INIT CURSOR POSITION FOR TRANS
IF R.ARGTYP(CMD.BLK,6) # PRS.T.INT &
 THEN &
 DO
  CP _ R.FCB.CP(FCB)                    !TAKE DEFAULT CP FROM FILE CTL B
 END

FOLD _ R.ARGVAL(CMD.BLK,7)              !CHECKSUM FOLD SIZE
IF NOT (FOLD = 3) THEN FOLD _ 3 !DEFAULT FOLD SIZE IS 3 BYTES

FT _ R.ARGVAL(CMD.BLK,8)                !FILE TYPE: BINARY, SYMBOLIC,ETC
IF R.ARGTYP(CMD.BLK,8) # PRS.T.INT &
 THEN &
  FT _ 1                                !DEFAULT IS BINARY FILE

! 4. SET UP HDCNT TABLE
[;HD] _ DOUBLE C.AREA((BLKS/BITS.PER.WORD+1)+1)  !NEED 1 BIT/BLOCK 
HD _ N.OFF.PACK(HD, 0)          !BUILD PTR FROM AREA NAME
L.P.L.DATA(HD,0,BLKS)      !HD TABLE 0-TH WORD HAS #BITS (OR #BLKS)

! 5. SET UP TCB (TRANSACTION CONTROL BLOCK), AND ATTACH TO TCB LIST
TCB _ G.ELMT(TCB.AREA)                  !GET TCB ELEMENT

L.TCB.FCB (TCB,FCB)                     !DONOR FILE CONTROL BLOCK PTR
L.TCB.HD  (TCB,HD)                      !HEAD COUNT TABLE PTR
L.TCB.CP  (TCB,CP)                      !WORKING CURSOR POSITION
L.TCB.ICP (TCB,CP)                      !INITIAL CURSOR POSITION
L.TCB.BS  (TCB,BS)                      !BLOCK SIZE IN 8-BIT BYTES
L.TCB.BYTS(TCB,BYTS)                    !NUMBER OF BYTES  TO SHIP
L.TCB.JOB (TCB,RECIP.JOB)               !RECIPIENT JOB NUMBER
L.TCB.WBLK(TCB,1)                       !WORKING NUMBER OF BLOCKS
L.TCB.FOLD(TCB,FOLD)                    !CHECKSUM FOLD SIZE
L.TCB.ECH1(TCB,R.ARGVAL(CMD.BLK,9))     !ECHO DATA TO SEND TO MASTER
L.TCB.ECH2(TCB,R.ARGVAL(CMD.BLK,10))    !UPON TRANSACTION COMPLETION

! 6. GENERATE TRANSACTION NUMBER AND ENTER TCB ONTO TCB.LIST
TRANS.NO _ (LOCAL.NAME SHL 16) + (SECRET.NUM _ SECRET.NUM+2)

!USE TRANSACTION NUMBER AS COORDINATE IN ONE-DIMENSIONAL SPARSE ARRAY
!THE VALUE OF THE ARRAY ELEMENT IS THE TCB PTR
S.SP.AR(1,TCB.LIST,TCB,TRANS.NO)

! 7. SEND RBLKS COMMAND TO RECIPIENT
BUF _ B.RBLKS(E.O.L, R.ARGVAL(CMD.BLK,2), LOCAL.NAME, TRANS.NO+1, &
              BS, BLKS, CP, FOLD, FT)   !BUILD RBLKS COMMAND STRING
                                        !NOTE THAT TRANS.NO IS 1 GREATER
                                        !FOR RECIPIENT. RECIPIENT WILL
                                        !DECREMENT ITS TRANS.NO BY 1 
                                        !WHEN SENDING MACK OR ACKP CMDS
                                        !TO THE DONOR
OUT.RKD(BUF, RECIP.JOB, LOCAL.NAME, TRUE, TRUE)

!FINISHED
RETURN (TRUE)

END R.SBLKS
!

%R.SENDFCB(CMD.BLK)                     !SEND FILE CONTROL BLOCK INFO
HALT !*********
END R.SENDFCB

%R.SENDV(CMD.BLK)                       !SEND VARIABLE
HALT !*****
END R.SENDV

%R.SETV(CMD.BLK)                        !SET VALUE OF VARIABLE
HALT !*******
END R.SETV

%R.STEST(CMD.BLK)                       !SEND TEST PATTERN
HALT !******
END R.STEST

%R.STEXT(CMD.BLK)                       !SEND FREE TEXT
HALT !********
END R.STEXT

%R.VAR(CMD.BLK)                         !THE VARIABLE AND ITS VALUE
HALT !******
END R.VAR

%R.WSLAVE(CMD.BLK)                      !AWAKEN SLAVE
HALT !******
END R.WSLAVE

%R.ZCKT(CMD.BLK)                        !ZAP CIRCUIT
HALT !******
END R.ZCKT
!
%INIT.SLAVE                     !INITIALIZE SLAVE
!INPUT:  NONE
!VALUE:  TRUE

SLAVE.Q _ G.ANCHOR

FCB.AREA _ C.ELMTS(FCB.SZ,2)    !CREATE FILE CONTROL BLOCK AREA
TCB.AREA _ C.ELMTS(TCB.SZ,2)    !CREATE TRANSACTION CONTROL BLOCK AREA
TCB.LIST _ G.ANCHOR         !INITIALIZE TCB LIST PTR FOR SPARSE ARR
SECRET.NUM _ 2                  !INITIALIZE TRANSACTION NUMBER GENERATOR

RETURN (TRUE)

END INIT.SLAVE
    co@}