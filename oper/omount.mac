TITLE OMOUNT - OPERATOR HALF OF MOUNT, DISMOUNT & FILE COMMAND - V.23
;COPYRIGHT 1972, DIGITAL EQUIPMENT CORP., MAYNARD, MASS.
SUBTTL R CLEMENTS /RCC/DJB  30-OCT-72
VOMNT==XWD 2300,35

IFNDEF PURESW,<PURESW==1>	;NON-ZERO MEANS REENTRANT SHARABLE
IFNDEF NOTISW,<NOTISW==1>	;NON-ZERO MEANS NO DATE/TIME TYPEOUT
IFNDEF UNLOSW,<UNLOSW==1>	;NON-ZERO MEANS REWIND AND UNLOAD DTAS
IFNDEF DBUGSW,<DBUGSW==0>	;NON-ZERO MEANS ASSEMBLE FOR DEBUGGING (SEE BELOW)
IFNDEF R12SW,<R12SW==1>	;NON-ZERO MEANS OMOUNT MUST RUN AS A 1,2 JOB
				;  THIS SWITCH SHOULD =0 ONLY FOR SPECIAL DEBUGGING
IFNDEF SLPSW,<SLPSW==5>		;5 = MINUTES TO WAIT FOR OPERATOR RESPONSE BEFORE
				;  RETYPING THE OMOUNT REQUEST
IFNDEF RPTSIZ,<RPTSIZ==100>	;SIZE OF BLOCK TO SAVE TTY OUTPUT IN FOR /WHAT SWITCH

JOBREN=124
JOBVER=137

LOC JOBVER
EXP VOMNT
LOC JOBREN
EXP	REENT

EXTERNAL JOBFF
INTERNAL JOBVER,JOBREN,OMOUNT


IFN PURESW,<
TWOSEG
RELOC	0
RELOC	400000
DEFINE	UU(A,B)<
RELOC
A:	BLOCK	B
RELOC>
> ;IFN PURESW

IFE PURESW,<
RELOC
DEFINE	UU(A,B)<
A:	BLOCK	B>
> ;IFE PURESW

DEFINE	U(A)<UU(A,1)>

MLON
;PARAMETERS, SPECIAL CHARACTERS, ETC.

CHRLIN=="-"	;LINE CONTIN.
VIDMAX==^D25	;MAX.LENGTH OF /VID: SWITCH VALUE
VIDCH1=="'"	;OPENING DELIMITER FOR  VID STRINGS
VIDCH2=="'"	;CLOSING . . .

			;SLEEP TIMES IF NO HIBER UUO
SLPCOM==^D15		;BETWEEN QUEUE SCANS
SLPUNI==^D15		;WAITING FOR UNITS TO READY

CMDPPX==3,,3		;DEFAULT REQUEST QUEUE AREA
CMDSTX==SIXBIT/DSK/
STLPPX==0	;WHERE TO LOOK FOR STRLST.SYS
STLSTX==SIXBIT/SYS/

		;VALUES FOR MODNAM TABLE
SYSFIL==SIXBIT/OPRFIL/	;PROG.NAME WHEN LOOKING ONLY FOR 'FILE'
SYSMNT==SIXBIT/OPRMNT/	;... 'MOUNT' & 'DISMOUNT'
SYSALL==SIXBIT/OPROMO/	;...EVERYTHING
SYSNON==SIXBIT/OMOUNT/	;...NOTHING (ONLY OPR. COMMANDS)
;-------AC'S

F=0
A=1
B=2
C=3
D=4
E=5

IO=10
M=11
N=12
N1=13
BP=14
CH=15
WD=16
P=17

;I/O CHANNELS

CMD==1
CMU==2
USR==3	;MUST NOT BE CHAN.0
DSK==4
DTA==5
TTY==6
UFD==7
CM1==10
CH.FS==11	;FOR DEFINING NEW F.S. (READING HOME BLOCKS ETC.)
;FLAGS  (LH OF F)

L.OCAN==1
L.WFIL==2
L.WEXT==4
L.TYO==10
L.SLP==20
L.TAPE==40
L.RCOM==100
L.REEN==200
L.VIDT==400
L.STOP==1000
L.MNT==2000
L.LVD==4000
L.CMDS==10000	;1 IF COMMANDS IN QUE (NXTASK)
L.CLR==L.REEN!L.OCAN!L.TAPE	;BITS TO CLEAR

;MISC BITS AND VALUES

MODEF==1	;'FILE' MODE
MODEM==2	;'MOUNT/DISMOUNT' MODE
DVDTA==100
MINDAY==^D60*^D24
;PARAMETERS FROM COMMOD

EXLLEN==27
EXLPPN==1
EXLNAM==2
EXLEXT==3
EXLATT==4
EXLQTR==24
EXLQTF==22
EXLQTO==23
EXLSTS==17
.RBSTS==17
  .RBNDL==1B19
EXLAUT==26
  RIPDIR==400000

DEFINE	JLEVC	(ADDRES)<
	TLNN	F,L.LVD
	JRST	ADDRES	;JRST IF LEVEL-C>
;SOME SYSTEM PARAMETERS

;STATES WORD
STAVER==POINT 3,STATES,9	;MONITOR VERSION #
V503==2		;'5.03' VERSION FIELD

MAXUNI==10	;MAX. # UNITS IN A FS.
MAXSPT==10	;MAX SPT TABLE SIZE (SATS/UNIT)
MAXFSL==11	;MAX # F/S IN A SEARCH LIST

HOMEB1==1	;LOG.BLK.NO. OF 1ST HOME BLOCK
HOMEB2==12	;"""2ND"""

UNVRSF==^D500	;RECIPROCAL SAFTY FACTOR FOR FREE-BLOCK TALLYS (MONGEN SYM.)
DSKTRY==3	;NUM. RETRIES ON ERROR--STRTRY (MONGEN SYM.)

;PARAMETERS FOR STRLST.SYS

STRFOR==0	;STRLST.SYS FORMAT VERSION #
STYPE:	POINT 3,UNITCL(D),^D32	;BYTE PTR FOR UNIT TYPE
SKTYP:	POINT 6,UNITCL(D),^D26	;  KONT TYPE
UCLDEF==2010		;UNITCL DEFAULT

;PARAMETERS FOR QUOTA.SYS
QUOFOR==0	;QUOTA.SYS FORMAT VERSION NUM.
;PARAMETERS FROM COMMOD

HOMSNM==4
HOMGAR==33
HOMOVR==32
HOMPT1==47
HOMUN1==50
HOMBSC==14
HOMSCU==15
HOMCNP==16
HOMCKP==17
HOMCLP==20
HOMHID==1
HOMLOG==7
HOMLUN==10
HOMGRP==13
HOMBPC==21
HOMSIC==24
HOMSPU==31
HOMSAT==34
HOMMFD==46
HOMCOD==176
HOMNAM==0
CODHOM==707070

RIBFIR==0
RIBNAM==2
RIBEXT==3
RIBCOD==176
CODRIB==777777

TALSIZ==^D13
TALPOS==^D12
CLASIZ==^D23
CLAPOS==^D35

SAFFIR==0	;1ST (RELATIVE) LOCATION IN SAF BLOCK OF SAT BITS
PHONLY==200000		;PHYSICAL DEVICE NAME ONLY FOR UUOS

;DEVCHR UUO PARAMETERS

ASSPRG==200000	;(RH) ASSIGNED BY PROGRAM
ASSCON==400000	;(RH) ASSIGNED BY CONSOLE
DC.FS==200000	;(LH)FILE STRUCTURE
DC.DTA==100	;(LH)DEC TAPE
DC.MTA==20	;(LH)MAG TAPE
DC.AVA==40	;(LH)AVAILABLE

;DEVTYPE UUO PARAMETERS

	OPDEF	DEVTYP	[CALLI 53]

.TYAVL==40	;(LH)AVAILABLE
.TYJOB==POINT 9,0,26	;JOB #
.TYTYP==POINT 6,0,35	;DEVICE TYPE
  .TYDSK==0	;DISK

;DSKCHR UUO AND PARAMETERS

	OPDEF	DSKCHR	[CALLI 45]

;BITS RETURNED IN LH(AC)
.UPOFL==200000	;UNIT OFF LINE
.UPHWP==100000	;UNIT HARD WRITE PROTECT
.UPSWP== 40000	;F/S  SOFT WRITE PROTECT
.UPSAF== 20000	;F/S SINGLE ACCESS
.UPZMT== 10000	;F/S HAS ZERO MOUNT COUNT
.UPNNA==   200	;F/S IS LOCKED
.UPAWL==   100	;F/S IS WRITE-LOCKED FOR ALL JOBS
DCHUST:	POINT 2,A,^D8	;BYTE PTR FOR UNIT STATE
UNVNPM==2	;UNIT STATE FOR 'NO PACK MOUNTED'
DCHCOD:	POINT 3,A,^D17	;BYTE PTR FOR NAME CODE

;BITS RETURNED IN RH(AC)
DCHKTP:	POINT 6,A,^D26	;BYTE PTR FOR CONTROLLER TYPE
DCHUTP:	POINT 3,A,^D32	;BYTE PTR FOR UNIT TYPE

;DISPLACEMENTS FOR ARGS
.STNAM==4	;F/S NAME
.UNBPU==6	;BLOCKS/UNIT
.STMNT==7	;MOUNT COUNT
.UNK4S==12	;# K FOR SWAPPING
.UNJOB==13	;JOB # OF SING.ACCESSER (STRJOB)
.UNLOG==14	;LOGICAL UNIT NAME (UNILOG)
.UNNAM==15	;PHYSICAL UNIT NAME (UNINAM)
.UNHID==16	;PACK I.D. (UNIHID)
DSKCHL==17	;LENGTH OF FULL ARG.LIST
;GETTAB UUO AND PARAMETERS

	OPDEF	GETTAB	[CALLI 41]

CNFTBL==11	;CONFIGURATION TABLE
  SEGPTR==15	;XWD MAX.SEG#,MAX.JOB#

PRJPRG==2	;PPN TABLE

	OPQPTB==16		;TABLE FOR COMMAND QUEUE PPN
	OPQPIN==4		;INDEX IN TABLE FOR COMMAND QUEUE PPN
	OPQSTB==16		;TABLE FOR STR FOR COMMAND QUEUE
	OPQSIN==15		;INDEX IN TABLE FOR STR FOR COMMAND QUEUE
	STATAB==11		;TABLE FOR STATES WORD
	STAIND==17		;INDEX IN TABLE FOR STATES WORD

	LEVDS==7B27		;7B9 IS LEVEL D FLAG (3 BITS LEFT HALF)
;STRUUO UUO AND PARAMETERS

	OPDEF	STRUUO	[CALLI 50]

.FSDSL==1	;FUNCTION FOR DEF.SL.
.FSDEF==2	;" DEFINE FS.
.FSRDF==3	;" RE-DEFINE FS.
.FSLOK==4	;" LOCK FS.
.FSREM==5	;" REMOVE FS.
.FSULK==6	;" TEST/SET UFD INTERLOCK
.FSUCL==7	;" CLEAR "

;DISPLACEMENTS FOR STRUUO(.FSDEF) ARG.LIST
SS.NAM==0	;STRNAM--STR PARAMETER BLOCK
SS.UNM==1	;STRUNM
SS.HGH==2	;STRHGH
SS.SIZ==3	;STRSIZ
SS.GAR==4	;STRGAR
SS.RES==5	;STRRES
SS.TAL==6	;STRTAL
SS.OVR==7	;STROVR
SS.PT1==10	;STRPT1
SS.1PT==11	;STR1PT
SS.UN1==12	;STRUN1
SS.TRY==13	;STRTRY
SS.BPU==14	;STRBPU
SS.BSC==15	;STRBSC
SS.SCU==16	;STRSCU
SS.JOB==17	;STRJOB
SS.CNP==20	;STRCNP
SS.CKP==21	;STRCKP
SS.CLP==22	;STRCLP
SS.L==23	;LENGTH OF STR PARAMETER BLOCK

SU.NAM==0	;UNINAM--UNIT PARAMETER BLOCK
SU.HID==1	;UNIHID
SU.LOG==2	;UNILOG
SU.LUN==3	;UNILUN
SU.DES==4	;UNIDES (SEE BELOW FOR BITS)
SU.GRP==5	;UNIGRP
SU.TAL==6	;UNITAL
SU.BPC==7	;UNIBPC
SU.CPS==10	;UNICPS
SU.WPS==11	;UNIWPS
SU.SIC==12	;UNISIC
SU.SPU==13	;UNISPU
SU.SPT==14	;PTR (XWD LENGTH,ADDRESS) TO SPT TABLE
SU.L==15	;LENGTH OF UNIT PARAMETER BLOCK
;BITS FOR STRUUO(.FSDSL)
DSLNOC==200000	;LH(F/S STATUS WD)  1=NO CREATE
DSLWLK==400000	;LH(F/S STATUS WD)  1=WRITE LOCK
DSLREM==     1	;RH(FLAGS WD) 1=REMOVE F/S & DEC. MOUNT COUNT

;BITS FOR STRUUO(.FSRDF)
DEFAWL==400000	;BIT FOR 'WRITE LOCK ALL USERS'
DEFSAF==200000	;"""'SINGLE-ACCESS'
;ERROR RETURN CODES
.ERUNC==13	;UNABLE TO COMPLETE--TRY AGAIN

;HIBERNATE UUO

	OPDEF	HIBER [CALLI 72]

HIBNOJ==4	;(LH) ONLY PRIV.JOBS CAN WAKE
HIBTTL==20	;(LH) WAKE ON TTY LINE
HIBSWP==400000	;(LH) SWAPOUT IMMEDIATELY
;OTHER UUO'S AND OPDEFS

OPDEF	PJRST	[JRST]
OPDEF	SYSPHY	[CALLI 51]
OPDEF	GOBSTR	[CALLI 66]
OPDEF	SLEEP	[CALLI 31]
OPDEF	PJOB	[CALLI 30]
OPDEF	GETPPN	[CALLI 24]
OPDEF	DEVCHR	[CALLI 4]
   AVAIL.==40	;'DEVICE AVAILABLE' BIT
OPDEF	RESET	[CALLI 0]
OPDEF	EXIT	[CALLI 12]
OPDEF	UTPCLR	[CALLI 13]
OPDEF	DATE	[CALLI 14]
OPDEF	MSTIME	[CALLI 23]
OPDEF	SETNAM	[CALLI 43]
OPDEF	DEVPPN	[CALLI 55]
OPDEF	DEVNAM	[CALLI 64]
OPDEF	SYSTER	[CALLI 46]
OPDEF	DEVLNM	[CALLI 107]
OPDEF	WAKE	[CALLI 73]
  HIBPRO==7	;PROTECTION
  HIBTTL==20	;WAKE ON TTY LINE
  HIBTTC==10	;WAKE ON TTY CHAR
;SWITCH BITS (RH F)

SB.H==     1	;/HELP
SB.WE==1000	;/WENABL
SB.WL==    2	;/WLOCK
SB.RO==SB.WL	;/RONLY
SB.UWL==   4	;/UWLOCK
SB.URO==SB.UWL	;/URONLY
SB.UWE==0	;/UWENAB
SB.M==0		;/MULTI
SB.SSL==  10	;/SYSTEM
SB.S==    20	;/SINGLE
SB.C==    40	;/CHECK
SB.P==   100	;/PAUSE
SB.R==   200	;/REMOVE
SB.VID==400	;/VID:
SB.NOS==2000	;/NOSEARCH
SB.CLR==3777	;BITS TO CLEAR AT BEG3

;OTHER BITS (RH F)

OB.NOC==200000	;1 IF ^C NOT ALLOWED
OB.NED==400000	;BIT FOR 'NOT ENOUGH DRIVES' (PICKD SUBROT)
OB.WFI==4000	;'WAIT FOR USER INPUT'
OB.PRO==10000	;REMEMBER TO TYPE 'PROCEED?'
OB.OPC==20000	;1 IF OPR. COMMAND BEING PROCESSED
OB.UFD==40000	;1 IF WE HAVE THE UFD INTERLOCK
OB.RDF==100000	;1 IF ALLOWED TO CHANGE F/S STATUS
OB.CLR==OB.NED!OB.PRO!OB.OPC!OB.RDF!OB.UFD!OB.NOC ;BITS TO CLEAR AT BEG3

;-------REDEFINE SOME THINGS IF DEBUGGING
IFN DBUGSW,<
SYSFIL==SIXBIT/XXXFIL/	;USE DIFFERENT NAMES SO AS NOT TO INTEFERE WITH OTHER OMOUNTS
SYSMNT==SIXBIT/XXXMNT/
SYSALL==SIXBIT/XXXOMO/
SYSNON==SIXBIT/OMOUNT/
CMDPPX==12,,47	;USE DIFFERENT '3,3' AREA SO DONT CONFLICT WITH RUNNING OMOUNTS
CMDSTX==SIXBIT/QUEUE/
STLPPX==0	;WHERE TO FIND STRLST.SYS
STLSTX==SIXBIT/STRLST/
>  ;IFN DBUGSW
;START OF PROGRAM

OMOUNT:	JFCL			;IN CASE OF CCL
	SETZB	F,CMDNAM
	MOVE P,PDP
	INIT TTY,0
	SIXBIT /TTY/
	XWD WH.TTY,RH.TTY
	EXIT			;NOT MUCH GOOD WITHOUT A TTY
	MOVEI A,B.TTY
	MOVEM A,JOBFF
	INBUF TTY,1
	OUTBUF TTY,1

	PJOB	A,		;GET OUR JOB
	MOVEM	A,OURJOB
	GETPPN	A,		;GET OUR PPN
	MOVEM	A,OURPPN

IFN R12SW,<	;SOME SPECIAL CASES OF DEBUGGING DONT WANT RUN AS 1,2
	CAMN A,FSFPPN		;WE NEED TO BE FAILSAFE PPN
	JRST START1		;OH
	MOVEI M,[ASCIZ /?MUST BE RUN AS [1,2]
/]
	PUSHJ P,MSGTTY
	EXIT
>  ;IFN R12SW

START1:	MOVE	A,[IOWD 200,DTADIR]	;MOVE IOWD LIST TO LOW SEG.
	MOVEM	A,DIRIOW
	SETZM	DIRIOW+1

	SETZM	MODE		;START OFF AS 'START:NONE'
	MOVE	A,NAMNON
	SETNAM	A,

	MOVE	A,[XWD STAIND,STATAB]
	GETTAB	A,
	  SETZ	A,
	MOVEM	A,STATES	;SAVE STATES WORD
	TLNE	A,LEVDS
	TLO	F,L.LVD
	MOVE	B,SYSPPC	;LEVEL C DEFAULT SYS PPN
	TLNE	F,L.LVD
	MOVE	B,SYSPPD	;LEVEL D DEFAULT SYS PPN
	MOVSI	A,(SIXBIT .SYS.)
	DEVPPN	A,
	  MOVE	A,B
	MOVEM	A,SYSPPN
IFE DBUGSW,<

	MOVE	A,[XWD OPQPIN,OPQPTB]
STAR11:	GETTAB	A,		;GET PPN FOR COMMANDS
	  MOVE	A,[CMDPPX]
	MOVEM	A,CMDPPN
	MOVE	A,[XWD OPQSIN,OPQSTB]
STAR12:	GETTAB	A,		;GET STR FOR COMMANDS
	  MOVE	A,[CMDSTX]
	MOVEM	A,CMDSTR
	PUSHJ	P,DSKUUO	;MAKE SURE CMDSTR NOT LOGICAL NAME
	  JRST	START2
	MOVE	A,DSKCHA+.STNAM
	CAMN	A,CMDSTR
	JRST	BEG1
START2:	MOVEI	M,[ASCIZ/? /]
	PUSHJ	P,MSGTTY
	MOVE	M,CMDSTR
	PUSHJ	P,SIXMSG
	MOVEI	M,[ASCIZ/ MUST NOT BE LOGICAL NAME/]
	PUSHJ	P,MSGTTY
	EXIT

>  ;IFE DBUGSW

IFN DBUGSW,<	;IF DEBUGGING USE SEPERATE AREA FOR REQUESTS

	MOVE	A,[CMDSTX]
	MOVEM	A,CMDSTR
	MOVE	A,[CMDPPX]
	MOVEM	A,CMDPPN
	JRST	BEG1
PAT:	BLOCK	100

> ;IFN DBUGSW
BEG1:	MOVE	P,PDP		;GET OFF ON THE RIGHT FOOT
	TDZ	F,[XWD L.CLR,OB.CLR!SB.CLR]
	SETZM	CMDNAM
	PUSHJ	P,CONCON

	MOVE	A,[ASCII /
   /]
	MOVEM	A,RPTTY		;NOTE THIS IS A REPEAT OF TTY OUTPUT
	MOVE	A,[ASCIZ/... /]
	MOVEM	A,RPTTY+RPTSIZ+1
	MOVE	A,[XWD RPTTY+1,RPTTY+2]
	SETZM	RPTTY+1		;ZERO THE REPEAT TTY BUFFER
	BLT	A,RPTTY+RPTSIZ	;DO IT
	MOVE	A,[POINT 7,RPTTY+1]
	MOVEM	A,RPTTYB	;INITIALIZE BYTE-POINTER
	MOVEI	A,RPTSIZ*5	; AND BYTE-COUNT
	MOVEM	A,RPTTYC	;

	JLEVC	BEG4
	SETZM	RH.TTY+2	;WIPE THIS INPUT

	SKIPE	MODE		;WHAT  MODE?
	JRST	BEG2
	MOVEI	CH,"*"		;ONLY LISTENING TO TTY
	PUSHJ	P,W.TTY
	OUTPUT	TTY,
	INCHWL	CH
	JRST	OPCOM
BEG2:	MOVEI	CH,"!"
	PUSHJ	P,W.TTY
	OUTPUT	TTY,		;FORCE OUTPUT

BEG3:	TTCALL	14,
	SKIPA
	JRST	OPCOMS		;YES-SEE WHAT HE WANTS
	TRZN	F,OB.WFI	;NO--ARE WE SUPPOSED TO WAIT FOR HIM?
	JRST	BEG4		;NO
	MOVEI	A,5		;YES-GIVE HIM 5 SECONDS
	MOVE	B,[XWD HIBTTL,^D5000]
	HIBER	B,
	  SLEEP	A,
	JRST	BEG3

BEG4:	JRST	CKCMD		;GO SEE IF ANY COMMAND-FILES TO DO
NOCMD:				;HERE IF NONE
	TLO	F,L.SLP
	MOVEI	A,SLPCOM	;   SO SLEEP AWAILE
	MOVSI	B,HIBTTL!HIBSWP
	HRRI	B,^D60000
	HIBER	B,		;HIBERNATE
	  SLEEP	A,		;  OR IF DOESNT WORK, SLEEP
	JLEVC	BEG4
	JRST	BEG3		;   AND DO IT AGAIN
;HERE AFTER COMPLETION OF A COMMAND FILE

FSQUIT:	MOVE	C,FSNAME	;UNLOCK UFD
	MOVE	D,FSPPN
	TRZE	F,OB.UFD	;IF ITS LOCKED BY US
	PUSHJ	P,UFDUNL

;LOOKUP COMMAND FILE AGAIN

	SKIPN	A,CMDNAM	;INCASE OPR.COMMAND OR 'WAIT' REQUEST
	JRST	COMEN1
	MOVSI B,(SIXBIT /CMD/)
	MOVEI C,0
	MOVE D,CMDPPN
	LOOKUP CMD,A
	JRST ERR098		;ITS VANISHED!

	LDB CH,PCRETM		;GET CREATION TIME
	MOVEM CH,CMDCTM
	LDB CH,PCREDA		;   AND DATE
	MOVEM CH,CMDCDA
	MOVEI A,B.CMD	;LOOKUP THE COMMAND FILE AGAIN
	MOVEM A,JOBFF
	INBUF	CMD,1

	TLNE	F,L.TAPE
IFE UNLOSW,<	MTAPE DTA,1>
IFN UNLOSW,<	MTAPE DTA,11>
COMEN1:	MOVEI M,CMPMSG		;"---DONE---"
	SKIPN	NOTDON		;SKIP IF NOT DONE
	PUSHJ P,MSGTTY		;COMPLETED AT
	SETZM	NOTDON		;-1 IF REQUEST WAS NOT SUCESSFUL

IFE NOTISW,<

	MSTIME	A,		;   TIME...
	IDIVI A,^D60000
	MOVEM A,NOWMIN
	PUSHJ P,MINOUT
	PUSHJ P,SPACE
	DATE	A,		;   DATE...
	MOVEM A,TODAY
	PUSHJ P,DATOUT

	TRNE	F,OB.OPC	;DONT PRINT DELAY IF OPER. COMMAND
	JRST	COMEN5
	MOVEI M,DLYMSG	;DELAY WAS...
	PUSHJ P,MSG
	MOVE B,TODAY
	SUB B,CMDCDA
	IMULI B,MINDAY
	MOVE A,NOWMIN
	SUB A,CMDCTM
	ADD A,B
	PUSHJ P,MINOUT
COMEN5:
> ;IFE NOTISW

	PUSHJ P,CRLF

	SKIPE	CMDNAM		;IF OPR.COMMAND OR 'DEFER'
	JRST	COMEN3
	CLOSE	CMD,0		;   THEN DONT DELETE FILE
	CLOSE	CM1,0
	JRST	COMEN4
COMEN3:	PUSHJ	P,DELCMD	;   OTHERWISE DELETE COMMAND FILE
	MOVE	A,CMDJOB	;   AND WAKE UMOUNT'R
	WAKE	A,
	  JFCL
COMEN4:	RELEAS CMD,0
	RELEAS CM1,
	RELEAS DTA,0
	JRST	BEG1
;HERE TO CHECK FOR COMMAND-FILES
;   JRST TO 'NOCMD' IF NO COMMANDS
;   OTHERWISE PROCESS ONE COMMAND-FILE AND JRST TO FSQUIT
CKCMD:	SKIPN	MODE		;SERVICING ANY USER COMMANDS?
	JRST	NOCMD		;NO
	PUSHJ	P,OPNCMU	;OPEN COMMAND FILE UFD
	  JRST	NOCMU
	SETZM	CMDNAM		;SO FSQUIT  WONT TRY TO DELETE NONEX FILE
	TLO	F,L.MNT		;SET MOUNT FLAG (CLEARED FOR DTA STUFF)
	MOVSI	D,-TYPL		;LOOK FOR A COMMAND FILE
CKCMD2:	LDB	C,[POINT 6,TYPCOM(D),17]	;CK MODE SWITCH
	TDNN	C,MODE
	JRST	CKCMD4		;NOT LOOKING FOR THIS KIND
	HLRZ	C,TYPCOM(D)	;RIGHT HALF OF C = TYPE DESIRED
	TRZ	C,77
	PUSHJ	P,NXTASK
	  JRST	CKCMD3		;NONE - LOOK FOR NEXT TYPE
	HRRZ	C,TYPCOM(D)	;TYPE FOUND OR END OF LIST
	JRST	(C)		;CALL ROUTINE TO PROCESS IT
CKCMD3:	TLZE	F,L.CMDS	;ANY FILES WITH .CMD AT ALL?
CKCMD4:	AOBJN	D,CKCMD2	;YES
	JRST	NOCMD		;NO

TYPCOM:
	XWD	MODEM!SIXBIT .   D.,DICOMF
	XWD	MODEM!SIXBIT .   M.,MOCOMF
	XWD	MODEF!SIXBIT .   F.,REQTAP
TYPL==.-TYPCOM

NOCMU:	TRNE	B,-1		;WHATS THE PROBLEM?
	JRST	ERR101		;ERROR
	PUSHJ	P,MAKCMU	;NO-UFD  CREATE ONE
	JRST	NOCMD		;AND RETURN FROM CKCMD
;C(WN=TYPE OF COMMAND TO LOOK FOR
;RET+1	NO COMMANDS OF PROPER TYPE
;	OB.CMDS=0 IF NO FILES WITH .CMD AT ALL
;RET+2	IF ONE FOUND
NXTASK:	MOVEM	D,SAVD
	PUSHJ	P,OPNCMD	;FIND A COMMAND FILE
	  JRST	NRET		;NONE OF THE PROPER TYPE
	PUSHJ	P,REWCMD	;START AT BEGINNING OF CMD FILE
	MOVEI	M,BELMSG
	TLZE	F,L.SLP		;WAKE UP OPR IF WE SLEPT
	PUSHJ	P,MSGTTY
PARSE1:	PUSHJ	P,R.CMD	;TYPE COMMAND FILE
	  JRST	ERR099
	CAIN	CH,12
	JRST	PARSE2
	PUSHJ	P,W.TTY
	JRST	PARSE1
PARSE2:	MOVEI	IO,W.TTY
	PUSHJ	P,CRLF
	MOVEI	IO,R.CMD
	PUSHJ	P,REWCMD
	PUSHJ P,SSIXBR		;FIRST ARG TO A AFTER SSST
	ROT A,6
	ANDI A,77		;JUST ONE CHAR
	MOVEM A,CMDCHR		;TYPE OF COMMAND
	PUSHJ	P,SSST	;GET JOB NUMBER
	PUSHJ	P,(IO)
	  JRST	ERR099
	PUSHJ	P,(IO)
	  JRST	ERR099
	PUSHJ	P,SDECIN
	JUMPE	N,ERR099
	MOVEM N,CMDJOB
	PUSHJ P,SSIXBR		;AND ITS TTY
	MOVEM A,CMDTTY
	PUSHJ P,SOCTIN		;PROJECT
	MOVSM N,USRPPN
	PUSHJ P,SOCTIN		;AND PROGRAMMER NUMBER
	HRRM N,USRPPN

;USE FILE AUTHOR IN CASE DIFFERENT THAN ADVERTISED

	JLEVC	PARSE3
	MOVE	A,SRCBUF+EXLAUT	;AUTHOR FROM EXTENDED LOOKUP
	CAME	A,USRPPN
	PUSHJ	P,MSG210
	MOVEM	A,USRPPN

PARSE3:	PUSHJ P,SSIXBR		;AND TAPE NUMBER OR FILE STRUCTURE NAME
	MOVEM CH,TERMCH		;SAVE TERMINATING CHAR
	MOVEM A,CMDTAP
	AOS	(P)		;SKIP RETURN
NRET:	MOVE	D,SAVD
	POPJ	P,
REWCMU:	MOVE	A,CMDPPN
	MOVSI	B,(SIXBIT .UFD.)
	SETZ	C,
	MOVE	D,MFDPPN
	LOOKUP	CMU,A
	  JSP	N,DSKERR
	POPJ	P,

REWCMD:	MOVEI	A,EXLLEN-1
	MOVEM	A,SRCBUF
	MOVE	A,CMDNAM
	MOVEM	A,SRCBUF+EXLNAM
	MOVSI B,(SIXBIT /CMD/)
	MOVEM	B,SRCBUF+EXLEXT
	MOVE D,CMDPPN
	MOVEM	D,SRCBUF+EXLPPN
	JLEVC	REWCMC
	LOOKUP CMD,SRCBUF		;WE KNOW THE FILE EXISTS
	  JRST	ERR098
	POPJ	P,

REWCMC:	SETZM	C	;HERE IF LEVEL C
	LOOKUP	CMD,A
	  JRST	ERR098
	POPJ	P,
;DELETE COMMAND FILE HELD ON CMD & CM1

DELCMD:	SETZB A,B		;SETUP FOR RENAME
	MOVEI C,0
	MOVE D,CMDPPN
	CLOSE CMD,0	;CLOSE THE COMMAND FILE
	RENAME CM1,A		;DELETE COMMAND FROM QUEUE
	  PJRST	NEVMSJ
	POPJ	P,


;OPEN & LOOKUP COMMAND UFD ON CMU
;RET+0	NO UFD EXISTS
;RET+1	NORMALLY

OPNCMU:	MOVEI	A,14		;OPEN COMMAND FILE DEVICE
	MOVE	B,CMDSTR
	MOVEI	C,RH.CMU
	OPEN	CMU,A
	  JSP	N,DSKERR

	MOVEI A,B.CMU
	MOVEM A,JOBFF
	INBUF CMU,1

	MOVE A,CMDPPN		;LOOKUP COMMAND UFD
	MOVSI B,(SIXBIT /UFD/)
	MOVEI C,0
	MOVE D,MFDPPN
	LOOKUP CMU,A		;SEE IF COMMAND AREA EXISTS
	  POPJ	P,		;NO COMMAND UFD
	JRST	CPOPJ1
;THIS ROUTINE SEARCHES THE COMMAND AREA FOR THE NEXT COMMAND
;THE TYPE OF COMMAND REQUESTED IS IN THE RIGHT HALF OF C
;  IF C=0 ALL TYPES WILL DO
;RET+1	IF NO COMMANDS OF REQUESTED TYPE
;	OB.CMDS=0 IF NO FILES WITH .CMD EXTENSION AT ALL
;RET+2	IF ONE FOUND

OPNCMD:	TLZ	F,L.CMDS
	MOVEM	C,SAVC
	PUSHJ	P,REWCMU	;START AT THE BEGINNING OF THE UFD
ASK1:	PUSHJ	P,R.CMU		;READ NEXT FILE NAME
	  POPJ	P,		;EOF - GIVE UP
	MOVE	A,WD
	PUSHJ	P,R.CMU		;READ EXT
	  POPJ	P,		;NONE
	HLRZ	B,WD
	CAIE	B,(SIXBIT .CMD.)
	JRST	ASK1		;IF EXT IS NOT CMD, ITS NOT OUR BABY
	HLRZ	C,A		;C=LEFT HALF OF FILE NAME
	TRZ	C,7777		;1ST CHAR ONLY
	SKIPE	SAVC
	CAMN	C,SAVC
	JRST	ASK2		;STILL CANT GET A MATCH
	TLO	F,L.CMDS
	JRST	ASK1

ASK2:	MOVEM	A,CMDNAM	;GOT A COMMAND FILE
	MOVE	B,CMDSTR
	SETZ	A,
	MOVEI	C,RH.CMD
	OPEN	CMD,A
	  JSP	N,DSKERR
	MOVEI A,B.CMD
	MOVEM A,JOBFF
	INBUF CMD,1

;MAKE SURE THIS COMMAND NOT BEING 'HELD' BY ANOTHER OMOUNT

	MOVEI	A,17		;OPEN 'HOLDING' CHAN. (CM1)
	SETZM	C
	OPEN	CM1,A
	  JSP	N,DSKERR

	MOVE	A,CMDNAM	;LOOKUP THE COMMAND FILE
	MOVSI	B,(SIXBIT/CMD/)
	MOVE	D,CMDPPN
	LOOKUP	CM1,A
	  JRST	ASK1		;SOME ONE JUST GOT IT?

	MOVE	D,CMDPPN	;NOW TRY AN ENTER TO SEE IF ITS FREE
	ENTER	CM1,A
	  JRST	ASK1		;   NOT FREOTHER OMOUNT HAS IT)
	JRST	CPOPJ1
REQTAP:	MOVEI IO,W.TTY		;ENTER HERE FROM FILE COMMAND
	TLZ	F,L.MNT		;CLEAR MOUNT FLAG CAUSE WE ARE DTA STUFF
	MOVEI M,MNTMSG
	PUSHJ P,MSG		;ASK OPR TO PLEASE MOUNT
	MOVE M,CMDTAP
	PUSHJ P,SIXMSO		;OUR TAPE
	MOVEI M,FORMSG
	PUSHJ P,MSG		;FOR USER

	HLRZ N,USRPPN
	PUSHJ P,OCTPRT		;PROJECT
	PUSHJ P,COMMA
	HRRZ N,USRPPN
	PUSHJ P,OCTPRT		;PROGRAMMER
	MOVEI	M,[ASCIZ/] /]
	PUSHJ	P,MSGTTY
RQTAP4:	MOVEI M,WRLMSG
	MOVE D,CMDCHR
	CAIE D,"Z"-40		;IF Z
	CAIN D,"F"-40		;OR F
	MOVEI	M,WRTMSG
	CAIN D,"D"-40		;TEST FOR D -
	MOVEI	M,WRTMSG
	PUSHJ P,MSGTTY		;REQUEST WRITE ENABLE OR LOCK
	MOVEI M,DRVMSG
	PUSHJ P,MSGTTY		;ON DRIVE:

;TYPE (N): IF DTAN IS ASSIGNED

	SETOM	DTDRIV
	MOVSI	A,(SIXBIT/DTA/)	;IS A DTA ASSIGNED?
	DEVNAM	A,
	  JRST	RQTAP5		;FORGET IT
	MOVE	B,A		;SAVE IT IN B
	DEVCHR	A,		;ASSIGNED?
	TRNN	A,ASSCON
	JRST	RQTAP5		;NO-FORGET IT
	MOVEM	B,DTDRIV
	HRLZ	M,B
	LSH	M,-6		;YES-PRINT ITS NUMBER IN PARENS
	TLO	M,(SIXBIT/( )/)
	PUSHJ	P,SIXMSO
RQTAP5:	PUSHJ	P,COLON
	OUTPUT	TTY,		;FORCE OUTPUT
	MOVEI IO,R.TTY
	MOVEI	M,FILHLP
	PUSHJ	P,OPRARG
	JRST	.+1(N)	;DISPATCH ON N

	JRST	RQTAP7	;0-LONE C.R
	JUMPN	A,RQTAP6;1-NOT LONE C.R.
	JRST	RQTAP4	;2-/HELP
	JRST	RQTAP9	;3-SOME GARBAGE
	JRST	RQTAP9	;4-ERROR

RQTAP7:	MOVE A,DTDRIV
RQTAP6:	MOVEM	A,DTDRIV
	DEVCHR	A,		;IF OPR TYPED DTAN, WE CAN PROCEED
	JUMPN A,RQTAP1
	MOVSI A,(SIXBIT /DTA/)	;MUST HAVE BEEN N
	HLR A,DTDRIV
	MOVEM A,DTDRIV		;SO BUILD DTAN
	DEVCHR	A,
RQTAP1:	TLNE A,DVDTA		;MUST BE A DECTAPE
	JRST	RQTAP2
	PUSHJ	P,MSG702
	JRST	RQTAP4
RQTAP2:	TLNE	A,AVAIL.		;AND AVAILABLE
	JRST	RQTAP3
	PUSHJ	P,MSG701
	JRST	RQTAP4
RQTAP3:	MOVEI A,117		;DUMP MODE FOR DT DIR
	MOVE B,DTDRIV
	MOVEI C,0
	OPEN DTA,A
	JRST REQTAP
	USETI DTA,144
	INPUT DTA,DIRIOW	;READ DIRECTORY
	STATZ DTA,740000
	JSP	N,DTERR
	TLO	F,L.TAPE	;NOW WE KNOW WE HAVE A TAPE
	MOVSI N,-DTDNFI
	MOVEI N1,1
	ANDCAM N1,DTDBYT(N)	;CLEAR BITS TO USE FOR *
	AOBJN N,.-1
	RELEAS DTA,0		;SO MONITOR WILL READ DTDIR
	MOVEI A,14		;FURTHER IO IS BINARY AND BUFFERED
	MOVE C,[XWD WH.DTA,RH.DTA]
	OPEN DTA,A		;GET DTA AGAIN
	JSP	N,DTERR		;SHOULDNT FAIL
	MOVE	D,CMDCHR
	CAIN D,"Z"-40		;FIND OUT WHAT WE'RE EXPECTED TO DO
	JRST ZCOM
	CAIN D,"F"-40
	JRST FCOM
	CAIN D,"R"-40
	JRST RCOM
	CAIN D,"D"-40
	JRST DCOM
	CAIN D,"L"-40
	JRST LCOM
	JRST	ERR099		;BAD COMMAND FILE FORMAT

RQTAP9:	PUSHJ	P,MSG200	;/H FOR HELP
	JRST	RQTAP4
	;WRITE DIRECTORY AS DISK FILE TAPENUM.DIR

LCOM:	MOVEI	IO,R.CMD
	PUSHJ	P,SSIXBR
	SKIPN	B,A
	MOVSI	B,(SIXBIT .DSK.)
	JRST	.+2
LCOM1:	MOVE	B,DIRDEV
	MOVEM	B,FILDEV
DCRTRY:	SETZ	A,
	HRLZI	C,WH.USR
	OPEN	USR,A
	  JSP	N,DSKERR
	MOVEI A,B.USR
	MOVEM A,JOBFF
	OUTBUF USR,1
	SKIPN A,CMDTAP		;TAPE NUM IS FILE NAME
	MOVSI A,(SIXBIT /DIR/)	;DIR IF 0
	MOVSI B,(SIXBIT /DIR/)	;EXT IS DIR
	MOVEI C,0
	MOVE D,USRPPN
	ENTER USR,A
	JRST DCNUFD
	MOVEI IO,W.USR
	MOVEI D,0
	PUSHJ P,DTDCNT		;COUNT BLOCKS FOR FILE (D)
	PUSHJ P,DECPR2
	MOVEI M,FREMSG		;WRITE NUMBER OF FREE BLOCKS
	PUSHJ P,MSG
	MOVSI D,-DTDNFI		;NUMBER OF FILES ON DTA
	HRRI D,1
LCOML:	SKIPN M,DTDFIL-1(D)
	JRST LCOMN		;NO FILE NAME IN THIS SLOT
	PUSHJ P,SIXMSG		;SO PUT OUT THE FILE
	PUSHJ P,DOT
	HLLZ M,DTDEXT-1(D)	;EXTENSION
	PUSHJ P,SIXMS4		;OUTPUT EXACTLY 4 CHARS
	PUSHJ P,DTDCNT		;COUNT ITS BLOCKS
	PUSHJ P,DECPR3
	PUSHJ P,TAB
	LDB A,[POINT 12,DTDEXT-1(D),35]
	PUSHJ P,DATOUT		;AND THE CREATION DATE
	PUSHJ P,CRLF
LCOMN:	AOBJN D,LCOML		;LOOP FOR ALL POSSIBLE FILES
	PUSHJ P,CRLF
LCOMN1:	RELEAS USR,0
	JRST FSQUIT


DCNUFD:	RELEAS	USR,
	PUSHJ	P,UFDERR	;MAKE A UFD IF NECESSARY
	  JRST	LCOMN1		;CANT OR OTHER ERRORS
	MOVE	B,FILDEV
	JRST	DCRTRY		;TRY AGAIN
;RECALL COMMAND (DTA TO DSK)

RCOM:	MOVEI A,B.DTA
	MOVEM A,JOBFF
	INBUF DTA,2
	TLZ F,L.WFIL+L.WEXT
	TLO F,L.RCOM
	PUSHJ	P,COMSET
RCOML:	MOVEI IO,R.CMD		;GET NEXT FILE NAME
	PUSHJ P,NXTFIL
	JRST RCOME		;NONE LEFT - ALL DONE
	SKIPN	B,FILDEV
	MOVSI	B,(SIXBIT .DSK.)
	MOVEI	A,14
	HRLZI	C,WH.DSK
	OPEN	DSK,A
	  JSP	N,DSKERR
	MOVEI A,B.DSK
	MOVEM A,JOBFF
	OUTBUF DSK,2
RCRTRY:	SKIPN A,FILNAM
	JRST RCBADN
	HLLZ B,FILEXT		;AND EXT
	SETZB C,D
	LOOKUP DTA,A
	JRST RCMISS		;NOT THERE ON DTA
	MOVE D,USRPPN
	ENTER DSK,A		;SET UP TO WRITE ON DSK
	JRST RCNUFD
RCOML2:	PUSHJ P,R.DTA		;TRANSFER THE FILE
	JRST RCEOF
	PUSHJ P,W.DSK
	JRST RCOML2
RCMISS:	MOVEI M,[ASCIZ /?REQUESTED FILE MISSING - /]
RCMIS1:	PUSHJ P,MSGTTY		;TELL OPR USER MESSED UP
	MOVE M,FILNAM
	PUSHJ P,SIXMSG
	PUSHJ P,DOT
	HLLZ M,FILEXT
	PUSHJ P,SIXMSG
	PUSHJ P,CRLF
	JRST RCEOF		;BUT KEEP GOING

RCEOF:	CLOSE DTA,0		;FINISH UP AND GO FOR NEXT FILE
	CLOSE DSK,0
	JRST RCOML

RCNUFD:	PUSHJ	P,UFDERR	;MAKE A UFD IF NECESSARY
	  JRST	RCENTF		;OTHER ERRORS
	JRST	RCRTRY		;TRY AGAIN

RCENTF:	MOVEI M,[ASCIZ /?ENTER FAILURE: /]
	PUSHJ P,MSGTTY
	MOVE N,B
	PUSHJ P,OCTPRT
	MOVEI M,[ASCIZ / CAN'T WRITE USER FILE - /]
	JRST	RCMIS1
RCBADN:	MOVEI M,[ASCIZ /?BAD FILE NAME, R COMMAND - /]
	JRST RCMIS1

UFDERR:	HRRZS	B		;IS THERE A UFD?
	CAIE	B,1
	POPJ	P,		;YES-SOME OTHER ERROR
	MOVE	A,USRPPN	;NO--TRY TO MAKE ONE
	MOVE	B,FILDEV
	PJRST	MAKUFD
;DELETE FILES FROM DECTAPE

DCOM:	TLZ F,L.WFIL+L.WEXT	;RESET WILD FILE AND EXT FLAGS
	TLO F,L.RCOM		;SET RCOM TO SEARCH DTA FOR "*"
	PUSHJ	P,COMSET
DCOML:	MOVEI IO,R.CMD		;SET INPUT FROM COMMAND
	PUSHJ P,NXTFIL		;GET NEXT FILE NAME AND EXT
	JRST DCOME		;ALL DONE - BRANCH
	MOVE A,FILNAM		;GET FILE NAME
	HLLZ B,FILEXT		;AND EXTENSION
	SETZB C,D
	LOOKUP DTA,A		;GET FILE TO BE DELETED
	JRST DCEOF		;NOT THERE - FORGET IT
	SETZB A,B		;SET FOR DELETE
	RENAME DTA,A		;DELETE FILE
	JFCL			;IGNORE ERROR
DCEOF:	CLOSE DTA,0
	JRST DCOML		;AND DO NEXT
;ZERO AND FILE COMMAND

ZCOM:	UTPCLR DTA,		;CLEAR DIRECTORY
				;AND FALL INTO F COMMAND
;FILE COMMAND (DSK TO DTA)

FCOM:	MOVEI A,B.DTA
	MOVEM A,JOBFF
	OUTBUF DTA,2
	TLZ F,L.WFIL+L.WEXT+L.RCOM
	PUSHJ	P,COMSET
FCOML:	MOVEI IO,R.CMD
	PUSHJ P,NXTFIL
	JRST FCOME
	SKIPN	B,FILDEV
	MOVSI	B,(SIXBIT .DSK.)
	MOVEI	A,14
	MOVEI	C,RH.DSK
	OPEN	DSK,A
	  JSP	N,DSKERR
	MOVEI A,B.DSK
	MOVEM A,JOBFF
	INBUF DSK,2
	SKIPN A,FILNAM
	JRST FCBADN
	HLLZ B,FILEXT
	MOVEI C,0
	MOVE D,USRPPN
	LOOKUP DSK,A
	JRST FCMISS
	ENTER DTA,A
	JRST FCENTF
FCOML2:	PUSHJ P,R.DSK
	JRST FCEOF
	PUSHJ P,W.DTA
	JRST FCOML2
FCMISS:	MOVEI M,[ASCIZ /?REQUESTED FILE MISSING - /]
FCMIS1:	PUSHJ P,MSGTTY
	MOVE M,FILNAM
	PUSHJ P,SIXMSG
	PUSHJ P,DOT
	HLLZ M,FILEXT
	PUSHJ P,SIXMSG
	PUSHJ P,CRLF
	JRST FCEOF

FCENTF:	MOVEI M,[ASCIZ /?DTA DIRECTORY FULL, FILE /]
	JRST FCMIS1

FCBADN:	MOVEI M,[ASCIZ /?BAD FILE NAME, F COMMAND - /]
	JRST FCMIS1

FCEOF:	CLOSE DTA,0
	CLOSE DSK,0
	JRST FCOML

DCOME:			;ENTER FROM DELETE COMMAND
	TLZ F,L.RCOM	;CLEAR SO UPDATES DIRECTORY PROPERLY
RCOME:			;ENTER FROM RECALL COMMAND
FCOME:	RELEAS DTA,0
	MOVEI A,117
	MOVE B,DTDRIV
	MOVEI C,0
	OPEN DTA,A		;OPEN TAPE AGAIN
	JSP	N,DTERR
	CLOSE DSK,0
	TLNE F,L.RCOM
	JRST FCOME1		;IF READING, CORE DIRECTORY IS STILL VALID
	USETI DTA,144
	INPUT DTA,DIRIOW	;ELSE READ DIRECTORY AGAIN
	STATZ DTA,740000
	JSP	N,DTERR
FCOME1:	JRST LCOM1		;DO DIRECTORY COM FOR FREE

COMSET:	MOVEI	IO,R.CMD
	PUSHJ	P,NXTFIL
	  JRST	.+2
	SKIPN	B,FILDEV
	MOVSI	B,(SIXBIT .DSK.)
	MOVEM	B,DIRDEV
	POPJ	P,
;HERE FOR OPERATOR COMMANDS

OPCOMS:	MOVEI	IO,R.TTY
	PUSHJ	P,SSST
OPCOM:	TRZ	F,OB.WFI	;CLEAR 'WAIT-FOR-INPUT' FLAG
	TRO	F,OB.OPC	;SET 'OPR-COMMAND' BIT
	SETZM	CMDNAM
	MOVE	A,OURJOB	;SET OUR JOB# & PPN
	MOVEM	A,FSJOB
	MOVE	A,OURPPN
	MOVEM	A,FSPPN

	MOVEI	B,OPCTAB	;LOOKUP NAME
	PUSHJ	P,TABLU0
	  SKIPA
	JRST	@OPCDIS(B)	;DISPATCH
	CAIN	CH,12		;IS IT LONE C.R.?
	JUMPE	A,OPCOM1	;YES--THATS ALRIGHT
OPCOM0:	MOVEI	M,[ASCIZ/? BAD COMMAND NAME--TYPE H FOR HELP/] ;REMIND CLUMSY OPERATOR
	PUSHJ	P,MSGTTY
	TTCALL	11,		;CLEAR TTY INPUT BUFFER
OPCOM1:	TRO	F,OB.WFI	;WAIT FOR NEW INPUT
	JRST	BEG1

;REMOVE COMMAND

RECOM:	MOVEI	D,NOSWIT	;NO SWITCHES
	PUSHJ	P,COMNAM	;GET F/S NAME
	JUMPE	A,ERR411	;NO NAME
	MOVEM	A,FSNAME
	JRST	REMOV

;LOCK COMMAND

LOCOM:	MOVEI	D,NOSWIT	;NO SWITCHES
	PUSHJ	P,COMNAM	;GET F/S NAME
	JUMPE	A,ERR421	;NO NAME
	MOVEM	A,FSNAME	;GOOD F/S NAME?
	PUSHJ	P,CKFS
	  JRST	ERR421		;NO
	PUSHJ	P,CKMNC		;YES-CHECK THE MOUNT-COUNT
	MOVEI	A,.FSLOK	;DO STRUUO
	MOVE	B,FSNAME
	MOVEI	C,A
	STRUUO	C,
	  JRST	ERR422		;UUO LOOSES
	PUSHJ	P,MSG423	;UUO WINS--TYPE CONFIRMATION
	JRST	FSQUIT

;HELP

HECOM:	MOVEI	M,OPCHEL
	PUSHJ	P,MSGTTY
	JRST	OPCOM1		;GIVE HIM ANOTHER CHANCE

WHTCOM:	PUSHJ	P,MSG800	;TYPE NO COMMANDS WAITING
	JRST	OPCOM1
;START:X COMMAND
;STOP:X COMMAND

STOCOM:	TLOA	F,L.STOP
STACOM:	TLZ	F,L.STOP
	PUSHJ	P,SETMOD
	  JRST	OPCOM0
	JRST	BEG1

;KILL COMMAND

KILCOM:	PUSHJ	P,GETMOD	;WHAT TO KILL?
	  JRST	OPCOM0
	CAIL	B,3
	JRST	BEG1		;NONE
	MOVE	E,B
	PUSHJ	P,OPNCMU	;SOME-OPEN CMD. UFD
	  JRST	BEG1
	MOVEI	C,0
	CAIN	E,2
	JRST	KILCO4		;ALL
	MOVEI	C,'F  '
	JUMPE	E,KILCO4		;FILE
	MOVEI	C,'D  '		;MOUNT (AND DISMOUNT)
	PUSHJ	P,KILCMD
	MOVEI	C,'M  '
KILCO4:	PUSHJ	P,KILCMD
	JRST	BEG1

KILCMD:	HRLM	C,(P)
KILCM2:	HLRZ	C,(P)
	PUSHJ	P,OPNCMD
	  POPJ	P,
	PUSHJ	P,DELCMD	;ZAP IT
	JRST	KILCM2
;SUBROUTINE TO PROCESS VALUES TO STOP/START COMMAND AND SWITCH
;L.STOP=1 FOR 'STOP'    =0 FOR 'START'
;NO ARGUMENT DEFAULT = 'ALL'
;RET+1	ERROR
;RET+2	OK

SETMOD:	PUSHJ	P,GETMOD
	  POPJ	P,
SETMO1:	MOVE	A,MODVAL(B)
	ANDCAM	A,MODE		;REMOVE OR ADD BIT DEPENDING
	TLNN	F,L.STOP	;   ON 'STOP' OR 'START'
	IORM	A,MODE
	MOVE	A,MODE		;SET PROG.NAME IN ACCORDENCE
	MOVSI	B,-MODNUM
SETMO3:	CAME	A,MODVAL(B)
	AOBJN	B,SETMO3
	MOVE	A,MODNAM(B)
	SETNAM	A,
	JRST	CPOPJ1
;SUBROUT TO GET VALUES TO START/STOP/KILL COMMANDS
;NO ARGUMENT DEFAULT = 'ALL'
;RET+1	ERROR
;RET+2	B=INDEX TO MODE TABLES (0...3)

GETMOD:	SETZ	A,
	CAIE	CH,":"
	JRST	GETMO2
	MOVEI	B,MODTAB	;READ & LOOKUP ARG
	PUSHJ	P,TABLUK
	  SKIPA
	JRST	CPOPJ1
	JUMPN	A,CPOPJ
GETMO2:	MOVEI	B,MODALL-MODTAB	;NO ARG='ALL'
	JRST	CPOPJ1

	U(MODE)
;USERS COMMAND

USCOM:	MOVEI	D,NOSWIT	;NO SWITCHES
	PUSHJ	P,COMNAM	;GET F/S NAME
	JUMPE	A,USCALL	;NO NAME MEANS ALL
	MOVEM	A,FSNAME
	PUSHJ	P,CKFS		;VALID F/S NAME?
	  JRST	ERR421		;NO
	PUSHJ	P,FSTAT		;PRINT ITS STATUS
	JRST	FSQUIT

USCALL:	MOVEI	M,0	;USE SYSSTR TO GET ALL F.S.S
USCAL2:	SYSTER	M,
	  JSP	A,NEVERR
	JUMPE	M,FSQUIT
	MOVEM	M,FSNAME
	MOVEI	IO,W.TTY
	PUSHJ	P,SIXMSO	;PRINT F.S. NAME
	PUSHJ	P,COLON
	PUSHJ	P,CRLF
	PUSHJ	P,FSTAT		;PRINT ITS STATUS
	PUSHJ	P,CRLF
	MOVE	M,FSNAME	;GET NEXT F.S.
	JRST	USCAL2

;SUBROUTINE TO PRINT F/S STATUS AND USERS
;CALL	FSNAME=F/S NAME

FSTAT:	PUSHJ	P,GETUNI	;GET UNIT DRIVES & ID'S
	  JRST	FSTA0
	MOVE	D,FSUAOB	;CLEAR UDRIVE SO PRTUNI WILL IGNORE IT
FSTAT4:	SETZM	UDRIVE(D)
	AOBJN	D,FSTAT4
	PUSHJ	P,PRTUNI	;PRINT DRIVE-ID LIST
FSTA0:	MOVE	A,FSNAME	;GET ITS CHARACTERSSTICS
	PUSHJ	P,DSKUUO
	  PUSHJ	P,NEVMSJ	;SHOULD'A BEEN A GOOD NAME
	PUSH	P,A		;SAVE THE UUO AC

	MOVE	N,DSKCHA+.STMNT	;PRINT THE MOUNT COUNT
	PUSHJ	P,MSG312
	SKIPN	DSKCHA+.STMNT	;IF 0, DONT PRINT USER LIST
	JRST	FSTAT3
	MOVEI	M,[ASCIZ/JOB(S) /]
	PUSHJ	P,MSGTTY
;PRINT LIST OF JOB #S WITH THIS F/S IN THEIR SEARCH LISTS

	MOVE	A,[XWD SEGPTR,CNFTBL]	;GET MAX JOB #
	GETTAB	A,
	  MOVEI	A,100	;DEFAULT
	HRRZM	A,GOBSTA+0	;   AND STORE FOR GOBSTR UUO
	MOVEI	C,^D10		;NUM. JOB NUMS/LINE

FSTAT0:	JUMPN	A,FSTAT9	;SYS (JOB 0)?
	MOVE	A,SYSPPN	;YES
	JRST	FSTAT8
FSTAT9:	MOVSS	A
	HRRI	A,PRJPRG	;GET THIS JOB'S PPN
	GETTAB	A,
	  JSP	A,NEVERR
	JUMPE	A,FSTAT2	;0,0 NOT A JOB
FSTAT8:	MOVEM	A,GOBSTA+1	;AND STORE FOR GOBSTR
	MOVE	A,FSNAME	;GET F.S. NAME
	MOVEM	A,GOBSTA+2

	MOVEI	A,GOBSTA	;DO THE GOBSTR UUO
	GOBSTR	A,
	  JRST	FSTAT2		;DONT QUIT--JOB MAY HAVE JUST DISAPEARED

	SOJGE	C,FSTAT6	; COUNT JOBS/LINE
	MOVEI	M,[ASCIZ/
       /]
	PUSHJ	P,MSGTTY
	MOVEI	C,^D9
FSTAT6:	SKIPE	N,GOBSTA+0	;YES-PRINT THIS JOB #
	JRST	FSTAT7
	MOVE	M,[' SYS  ']	;JOB 0 IS REALLY SYS
	PUSHJ	P,SIXMSO
	JRST	FSTAT2
FSTAT7:	PUSHJ	P,DECPR3

FSTAT2:	SOSL	A,GOBSTA+0	;MORE JOBS TO CHECK?
	JRST	FSTAT0		;YES
	PUSHJ	P,CRLF		;NO


FSTAT3:	POP	P,A		;RESTORE DSKCHR UUO AC
	TLNE	A,.UPNNA	;IF F/S LOCKED
	PUSHJ	P,MSG255	;   PRINT MESSAGE
	TLNE	A,.UPZMT	;DONT BELIEVE AWL & SAF IF M.C.=0
	JRST	FSTAT5
	TLNE	A,.UPAWL	;IF F/S IS READ-ONLY
	PUSHJ	P,MSG254	;   PRINT MESSAGE
	TLNE	A,.UPSAF	;IF F/S SINGLE-ACCESS
	PUSHJ	P,MSG256	;   PRINT MESSAGE

FSTAT5:	POPJ	P,
;SUBROUTINE TO GET OPERATOR ANSWER TO 'PROCEED?'

OPER:	MOVEI	M,[ASCIZ/PROCEED?   /]
	PUSHJ	P,MSGTTY
	MOVEI	IO,R.TTY
OPER1:	PUSHJ	P,SSST	;GET HIS REPLY
	CAIN	CH,"/"		;IGNORE ANY /'S
	JRST	OPER1
	CAIN	CH,12		;WAS IT JUST CR (LF)?
	JRST	OPER		;YES--TRY AGAIN
OPER3:	MOVEI	B,OPRTAB	;MATCH THE REPLY
	PUSHJ	P,TABLU0
	  JRST	OPER0		;WHAT?
	JRST	@OPRDIS(B)

OPER0:	MOVEI	M,[ASCIZ/?TYPE H FOR HELP
/]				;REMIND OPR THAT HE'S A CLOD
	PUSHJ	P,MSGTTY
	SETZM	RH.TTY+2	;WIPE INPUT
	JRST	OPER


;'START:X' / 'STOP:X'

OPRSTA:	TLZA	F,L.STOP
OPRSTO:	TLO	F,L.STOP
	PUSHJ	P,SETMOD
	  JRST	OPER0	;TRY AGAIN
	JRST	OPER1

;'NO'

OPRNO:	JRST	FSQUIT

;'YES'

OPRYES:	POPJ	P,

;'DEFER'

OPRDEF:	PUSHJ	P,DEFERQ
	  JRST	OPER
	JRST	FSQUIT

;'HELP'

OPRHLP:	MOVEI	M,OPRHEL
	PUSHJ	P,MSGTTY
	JRST 	OPER

;'WHAT'
OPRWHT:	TTCALL	3,RPTTY
	JRST	OPER
;HERE ON REENTER

	EXTERN	JOBOPC

REENT:	TLO	F,L.REEN	;REMEMBER REENTER
	TRO	F,OB.PRO	;REMEMBER TO 'PROCEED?'
	TRNE	F,OB.NOC	;IS ^C ALLOWED?
	JRST	@JOBOPC		;NO--TEND TO IT LATER

	MOVEM	17,SAVEAC+17	;YES-SAVE AC'S
	MOVEI	17,SAVEAC
	BLT	17,16
	MOVE	17,SAVEAC+17
	PUSHJ	P,OPER		;ASK THE OPERATOR
	TLZ	F,L.REEN	;HE CHANGED HIS MIND
	HRLZI	17,SAVEAC	;  SO RESTORE THE AC'S & CONTINUE
	BLT	17,17
	JRST	@JOBOPC


;SUBROUTINE TO DISABLE ^C (SOME-DAY)

CONCOF:	TRO	F,OB.NOC	;BEST WE CAN DO NOW IS SET A BIT
	POPJ	P,

;SUBROUTINE TO ENABLE ^C

CONCON:	TRZ	F,OB.NOC
	TLNE	F,L.REEN	;DID OPER. TRY TO REENTER
	TRZN	F,OB.PRO	;   DURING ^C-DISABLE?
	POPJ	P,		;NO--RETURN
	POP	P,JOBOPC	;YES-DO THE REENTER NOW
	JRST	REENT
; M O U N T   C O M M A N D

;HERE TO READ COMMAND FILE

MOCOMF:	JLEVC	ERR099
	MOVEI	IO,R.CMD
	PUSHJ	P,SSIXIN	;STEP PAST COMMAND NAME
	JRST 	MOCOM

;HERE TO READ TTY

MOCOMT:	MOVEI	IO,R.TTY

MOCOM:	MOVEI	D,MOSWIT	;CHECK FOR SWITCHES
	PUSHJ	P,COMNAM	;   AND GET F/S NAME
	JUMPE	A,ERR201	;ERROR IF NONE
	TRNE	A,77		;PROPER NAME?
	JRST	ERR200		;NO
	MOVEM	A,DVVNAM

	MOVEI	D,MOSWIT	;GET LOGICAL NAME (IF ANY)
	PUSHJ	P,COMNAM
	MOVEM	A,LOGNAM

	MOVEI	D,MOSWIT	;CK FOR SWITCHES AGAIN
	PUSHJ	P,SWITCH
	  JRST	FSQUIT		;BAD SWITCH

	HRLZI	D,-MAXUNI	;DEFAULT UNIT TABLES
MOCOM2:	SETZM	UDRIVE(D)
	SETZM	UNITID(D)
	SETZM	PDRIVE(D)
	MOVE	A,[UCLDEF]
	MOVEM	A,UNITCL(D)
	AOBJN	D,MOCOM2
	MOVE	B,[XWD -MAXUNI,UDRIVE] ;USER DRIVE TABLE
	PUSHJ	P,SIXLIS
	  JRST	FSQUIT		;SYNTAX ERROR
	MOVEM	B,FSUUNM	;REMEBER NUM. DRIVES USER REQUESTED

	MOVEI	D,MOSWIT	;CK SWITCHES A FINAL TIME
	PUSHJ	P,SWITCH
	  JRST	FSQUIT
	MOVEI	IO,W.TTY	;FOR MSG TYPING

;WHAT TYPE OF BEAST IS IT?

	MOVE	A,DVVNAM
	DEVCHR	A,PHONLY
	JUMPE	A,MOFS0		;IF NOT A DEVICE, ASSUME A F.S.
	MOVEM	A,DEVMOD
	TLNE	A,DC.FS
	JRST	MOFS1		;A DISK--NEEDS SPECIAL ATTENTION
	TRNE	F,OB.OPC	;OPR.COMMANDS ARE ONLY FOR F.S.'S
	JRST	ERR300

;HERE IF NOT A F.S. REQUEST -- GENERIC OR SPECIFIC NAME?

	LDB	A,[STAVER]	;MUST BE 503 FROM HERE ON IN
	CAIGE	A,V503
	JRST	ERR097		;  QUIT IF NOT
	TRNE	F,SB.WL		;YEPE SPECIAL SWITCHES
	PUSHJ	P,MSG503
	TRNE	F,SB.WE
	PUSHJ	P,MSG504

MOUNT0:	MOVE	B,DVVNAM	;3 LETTERS OR LESS?
	TRNN	B,-1
	JRST	MOUNT1		;YES-GO FIND SPECIFIC UNIT
	MOVE	A,B		;NO--WHO DOES IT BELONG TO?
	DEVTYP	A,PHONLY
	  JSP	A,NEVERR
	SKIPN	A
	JSP	A,NEVERR	;  (SHOULD WORK IF DEVCHR WORKS)
	LDB	C,[.TYJOB+A]
	TLNE	A,.TYAVL	;   HAS ANYONE ASSIGNED DEVICE
	JUMPE	C,MOUNT4	;   NO ONE--TRY TO GET FOR USER
	CAMN	C,CMDJOB
	JRST	MOUNT8		;   THE USER-SKIP A LOT OF STUFF
	PUSHJ	P,MSG500	;   SOMEONE ELSE -- TELL OPERATOR

;HERE IF MUST FIND FREE UNIT FOR USER

MOUNT1:	HLLZ	B,DVVNAM	;START WITH DEV0
	HRRI	B,'0  '
MOUN11:	MOVE	A,B
	DEVTYP	A,PHONLY
	  JRST	MOUNT3
	JUMPE	A,MOUNT3	;CANT FIND AVAILABLE UNIT
	LDB	C,[.TYJOB+A]
	TLNE	A,.TYAVL	;SKIP IF NOT AVAILABLE
	JUMPE	C,MOUNT4	;FOUND ONE (JOB#=0)
	ADDI	B,10000		;TRY NEXT ONE
	JRST	MOUN11

;HERE IF CANT FIND FREE UNIT

MOUNT3:	PUSHJ	P,MSG501	;TELL OPERATOR
	HLLZ	B,DVVNAM	;USE ONLY GENERIC NAME
;HERE TO GET OPERATORS OK OR CHOICE
;B HAS NAME TO TYPE AT HIM

MOUNT4:	MOVEI	M,[ASCIZ/ASSIGN /]
	PUSHJ	P,MSGTTY
	HRRZ	M,B
	JUMPE	M,MOUN41
	CAMN	B,DVVNAM	;IS THIS THE USERS DESIRE?
	JRST	MOUN41		;YES
	ROT	M,-6		;NO-PUT PARENS AROUND UNIT NUMBER
	ADDI	M,'( )'
MOUN41:	HLL	M,B
	PUSHJ	P,SIXMSO
	PUSHJ	P,COLON

	PUSH	P,B
	MOVEI	M,MONHLP	;GET THE WORD
	PUSHJ	P,OPRARG
	POP	P,B
	JRST	.+1(N)	;DISP. ON N
	JRST	MOUN42	;0-LONE C.R.
	JUMPN	A,MOUN44;1-NOT LONE C.R.
	JRST	MOUNT0	;2-/HELP
	JRST	MOUN54	;3-SOME GARBAGE
	JRST	MOUN54	;4-ERROR

MOUN42:	TRNE	B,-1		;WAS IT A SPECIFIC UNIT?
	JRST	MOUNT5		;YES-USE IT
	PUSHJ	P,MSG701	;NO--TELL OPR TO TRY AGAIN
	JRST	MOUNT0

MOUN44:	TRNE	A,-1		;DEVN ?
	HRLZS	A		;YES, THROUGH AWAY DEV - SAVE N
	ROT	A,6
	CAIL	A,'0'		;DIGIT?
	CAILE	A,'7'
	JRST	MOUN54		;NO--TRY AGAIN
	DPB	A,[POINT 6,B,23]	;YES-USE IT
;HERE WITH DEVICE THAT OPERATOR HAS BLESSED IN B
;TRY TO INIT IT

MOUNT5:	HRLZ	C,DEVMOD	;FIND A LEGAL MODE FOR THIS GUY
	TLZ	C,600000
	JFFO	C,MOUN51	;  CONVERT BIT.POSIT. TO NUMBER
	JSP	A,NEVERR
MOUN51:	MOVEI	A,^D17
	SUB	A,D
	MOVEI	C,0	;NOW DO THE OPEN
	OPEN	USR,A
	  SKIPA	A,B
	JRST	MOUNT6	;SUCCESS

	DEVTYP	A,PHONLY	;WHATS THE PROBLEM?
	  JSP	A,NEVERR
	JUMPN	A,MOUN52
	PUSHJ	P,MSG703	;ILLEGAL NAME
	JRST	MOUNT0
MOUN52:	TLNE	A,.TYAVL
	JRST	MOUN53
	PUSHJ	P,MSG701	;UNAVAILABLE
	JRST	MOUNT0
MOUN53:	MOVE	C,B		;RANDOM OPEN FAILURE
	PUSHJ	P,MSG272
	JRST	MOUNT01

MOUN54:	PUSHJ	P,MSG200	;/H FOR HELP
	JRST	MOUNT0
;HERE WITH DEVICE NAMED IN B OPENED ON USR
;ASSIGN LOGICAL NAME (IF ANY)

MOUNT6:	SKIPN	B,LOGNAM
	JRST	MOUNT7		;NO LOGICAL NAME
	MOVEI	A,USR
	DEVLNM	A,
	  AOSA	A
	JRST	MOUNT7		;SUCCESS
	AOJE	A,MOUN62	;LOGICAL NAME CONFICT?
	JSP	A,NEVERR	;NO--SHOULDNT BE
MOUN62:	PUSHJ	P,MSG502	;YES-TELL OPERATOR
	PUSHJ	P,OPER		;   AND GIVE HIM A CHANCE TO RECOVER
	RELEASE	USR,
	JRST	MOUNT1

;HERE WITH ALL DONE EXCEPT REASSIGNMENT TO USER (OPENED ON USR)

MOUNT7:	HRLZ	A,CMDJOB	;SEE IF JOB HAS SAME PPN AS REQUESTOR
	HRRI	A,2		;
	GETTAB	A,		;
	  JRST	MOUN71		;
	CAME	A,USRPPN	;PPN'S THE SAME?
	JRST	ERR500		;NO -- USER JOB NO LONGER AROUND
MOUN71:	MOVE	A,CMDJOB
	MOVEI	B,USR
	REASSI	A,
	JUMPE	B,NEVERR	;JUMP IF UUO SAID DEVICE NOT ASSIGNED
	JUMPE	A,ERR500	;JUMP IF USER JOB NO LONGER AROUND

	JRST	MOFIN		;YEA!


;HERE IF USER ALREADY HAS DEVICE

MOUNT8:	MOVEI	M,[ASCIZ/ALREADY ASSIGNED TO USER
/]
	PUSHJ	P,MSGTTY
	PUSHJ	P,OPER
	JRST	MOFIN
;SUBROUTINE TO GET OPERATOR ARGUMENT
;CALL	M=0 OR ADDRESS OF HELP MESSAGE
;RET+1	A= 6 BIT ARGUMENT OR 0 IF NONE
;	N=4 IF ERROR
;	  3 IF GARBAGE
;	  2 IF /HELP TYPED
;	  1 IF NOT LONE C.R. (SWITCHES?)
;	   0 IF LONE CAR.RET.
;	  OTHERWISE A SIXBIT THING

OPRARG:	MOVEM	M,OPRAH	;SAVE HELP MSG
	PUSH	P,IO	;AND CALLERS DEVICE ADDRESS
	MOVEI	IO,R.TTY
	SETZB	N,A		;RETURN 0 IF LONE C.R.
	PUSH	P,A
	PUSHJ	P,SSST
	CAIE	CH,33
	CAIG	CH,14
	JRST	OPRAR6
	MOVEI	N,1		;NOT C.R. -- -1 IIF NOTHING ELSE
	MOVEI	D,OPSWIT	;CK FOR SWITCHES
	PUSHJ	P,SWITCH
	  JRST	OPRAR4		;ERROR RETURN -4
	JUMPN	A,OPRAR3	;SPECIAL SWITCH LIKE /HELP
	PUSHJ	P,SIXIN		;GET ARGUMENT
	MOVEM	A,(P)
	MOVEI	D,OPSWIT	;CHECK SWITCHES AGAIN
	PUSHJ	P,SWITCH
	  JRST	OPRAR4
	JUMPN	A,OPRAR3
	PUSHJ	P,SST		;CHECK FOR REMAINING GARBAGE
	CAIE	CH,33
	CAIG	CH,14
	JRST	OPRAR6

	MOVEI	N,3		;RETURN -3 FOR GARBAGE
	JRST	OPRAR5
OPRAR3:	MOVE	N,A
	JRST	OPRAR5
OPRAR4:	MOVEI	N,4		;RETURN -4 FOR ERROR
OPRAR5:	SETZM	RH.TTY+2	;ZAP REMAINING INPUT
OPRAR6:	POP	P,A
	POP	P,IO
	TLZN	F,L.OCAN	;/CANCEL /DEFER ETC
	POPJ	P,		;NO
	JRST	FSQUIT		;YES-SHUT IT DOWN


U(OPRAH)
;HERE IF UNDEF.DEVICE NAME (ASSUME F.S. TO BE MOUNTED)

MOFS0:	TRNE	F,SB.NOS	;SUPPRESS STRLST.SYS SEARCH?
	JRST	STR301		;YES

;LOOKUP SYS:STRLST.SYS ENTRY FOR THIS F/S

	INIT	USR,14		;BINARY MODE
	STLSTX
	XWD	0,RH.USR
	  JRST	ERR211		;IF SYS DOES NOT EXIST

	MOVEI	A,B.USR		;SET UP 1 BUFFER
	MOVEM	A,JOBFF
	INBUF	USR,1

	MOVE	A,[SIXBIT .STRLST.] ;LOOKUP STRLST.SYS
	MOVSI	B,(SIXBIT .SYS.)
	SETZM	C
	MOVE	D,[STLPPX]
	LOOKUP	USR,A
	  JRST	STR212		;ERROR 'NO STRLST.SYS'

	PUSHJ	P,R.USR		;READ FORMAT VERSION NUMBER
	  JRST	STR213
	HLRZS	WD		;LH=NUMBER
	CAIE	WD,STRFOR
	JRST	STR215		;ERROR 'WRONG FORMAT VERSION'

STR1:	PUSHJ	P,R.USR		;GET NEXT WORD IN WD
	  SKIPA
	JRST	STR2
	STATZ	USR,20000	;WHATS THE PROBLEM?
	JRST	STR216		;EOF--USER/OPER FAULT
	JRST	STR213		;IO ERROR--SYSTEM FAULT

STR2:	JUMPE	WD,STR1		;IGNORE 0 LENGTH BLOCKS
	MOVEI	A,-1(WD)	;A=NUMBER OF WORDS THAT FOLLOW
	PUSHJ	P,R.USR		;READ FILE STRUCTURE NAME
	  JRST	STR213	
	CAMN	WD,FSNAME	;SEE IF THIS IS THE RIGHT ENTRY
	JRST	STR3		;YES!

STR21:	PUSHJ	P,R.USR		;SKIP THE REST OF THIS ENTRY
	  JRST	STR216
	SOJG	A,STR21

	JRST	STR1
;FOUND STRLST.SYS ENTRY  -- READ IT

STR3:	SUBI	A,3		;COMPUTE NUM. OF PACKS
	LSH	A,-1
	MOVEM	A,FSUNM
	MOVNS	A		;FOR AOBJ POINTERS
	HRLZM	A,FSUAOB

	PUSHJ	P,R.USR		;GET PROJ,PROG OF OWNER
	  JRST	STR213
	MOVEM	WD,OWNPPN

	PUSHJ	P,R.USR		;SKIP OWNER'S NAME
	  JRST	STR216
	PUSHJ	P,R.USR
	  JRST	STR216

	MOVE	D,FSUAOB	;D=AOBJ PTR FOR # OF PACKS
STR4:	PUSHJ	P,R.USR		;GET PACK ID
	  JRST	STR213
	MOVEM	WD,UNITID(D)	;   AND STORE IN TABLE
	PUSHJ	P,R.USR		;GET CLASS, ETC.
	  JRST	STR213
	MOVEM	WD,UNITCL(D)	;   AND STORE
	AOBJN	D,STR4		;LOOP FOR ALL PACKS

	RELEASE	USR,		;GET RID OF SYS
	JRST	STR40

;VARIOUS ERRORS WHILE SEARCHING STRLST.SYS

STR212:	PUSHJ	P,MSG219	;NO STRLST.SYS
	JRST	STR300
STR213:	PUSHJ	P,MSG220	;I/O ERROR
	JRST	STR300
STR215:	PUSHJ	P,MSG221	;WRONG FORMAT VERSION
	JRST	STR300
STR216:	PUSHJ	P,MSG222	;NOT IN STRLST.SYS
STR300:	RELEAS	USR,
;HERE IF SUPPRESSED OR FAILED STRLST.SYS SEARCH

STR301:	SETOM	OWNPPN		;DEFAULT F.S. OWNER TO 'ANYONE'
	SKIPE	A,FSUUNM		;USER TYPE A DRIVE LIST?
	JRST	STR302		;  YES
	MOVSI	A,'DP '		;  NO-DEFAULT 1 'DP' DRIVE
	MOVEM	UDRIVE
	MOVEI	A,1
STR302:	MOVEM	A,FSUNM
	MOVNS	A
	HRLZM	A,FSUAOB
	JRST	STR41

;CK. NUM. DRIVES USER TYPED

STR40:	MOVE	N,FSUNM		;TOO MANY DRIVES REQUESTED?
	CAML	N,FSUUNM
	JRST	STR41		;NO
	TRO	F,OB.PRO	;YES-REMEMBER TO ASK 'PROCEED'
	PUSHJ	P,MSG212

;IF OPR.COMMAND, /SING IS ILLEGAL

STR41:	TRNE	F,OB.OPC	;OPR.COMMAND?
	TRZN	F,SB.S		;AND /SINGLE?
	JRST	STR42		;NO
	TRO	F,OB.PRO	;YES-TELL OPR NO
	PUSHJ	P,MSG214

;IF /SING OR /UWLOCK SWITCH, CHECK PROJ. #

STR42:	TRNN	F,SB.S!SB.UWL	;/SING OR /UWLOCK?
	JRST	STR5		;NO
	MOVE	A,FSPPN		;IF USER IS
	CAMN	A,[1,,2]	;    1,2
	JRST	STR5		;    ITS OK
	HLRZ	A,OWNPPN	;YES-OWNER PROJ.=USER PROJ.?
	HLRZ	B,FSPPN
	CAIE	A,-1		;  OR OWNER=-1?
	CAMN	A,B
	JRST	STR5		;YES-ITS OK THEN
	TRZ	F,SB.S!SB.UWL	;NO--CANCEL SWITCHES
	TRO	F,OB.PRO	;   REMEMBER TO 'PROCEED?'
	PUSHJ	P,MSG211	;   AND WRITE MESSAGE
;CK USER DRIVE REQUESTS

STR5:	MOVE	D,FSUAOB	;D=AOBJ PTR FOR UNITS

	;HERE FOR EACH UNIT

STR61:	MOVE	A,UDRIVE(D)	;DID USER SPECIFY DRIVE?
	JUMPE	A,STR66		;NO
	PUSHJ	P,DSKUUO	;YES--DO A DSKCHR
	  JRST	STR62		;NOT EVEN A DISK ! !

	LDB	B,DCHCOD	;WAS USER NAME  A UNIT OR CONTROLER?
	CAIL	B,3
	JRST	STR63		;YES
STR62:	PUSHJ	P,MSG218	;NO--TELL USER
	JRST	STR65

STR63:	LDB	C,DCHKTP	;*** CK CONTROLLER TYPE
	LDB	E,SKTYP		;
	CAME	C,E		;***
	JRST	STR64		;*** COMPLAIN

	CAIE	B,6		;DONT CK UNIT TYPE UNLESS ITS A UNIT NAME
	JRST	STR66
	LDB	B,DCHUTP	;IS UNIT TYPE OK?
	LDB	C,STYPE
	CAMN	B,C
	JRST	STR66		;YES
STR64:	PUSHJ	P,MSG217	;NO--TELL USER
STR65:	TRO	F,OB.PRO	;ASK OPERATOR'S ADVICE
	SETZM	UDRIVE(D)	;AND FORGET LOOSING DRIVE REQUEST

STR66:	AOBJN	D,STR61		;USER DRIVE PASSES--CK NEXT ONE

;SEE IF F/S ALREADY EXISTS

MOFS1:	MOVE	A,FSNAME	;DSKCHR ON FSNAME
	PUSHJ	P,DSKUUO
	  PUSHJ	P,DEFIN		;NOT YET--GO DEFINE IT
	LDB	B,DCHCOD
	CAIE	B,2		;IS THIS A F/S NAME?
	JRST	ERR300		;NO
;FSNAME ALREADY DEFINED
;	CK USER ACCESS TO IT

	TLNE	A,.UPNNA	;F/S LOCKED?
	JRST	ERR221		;YES

;	IF F/S  SINGLE FOR USER, SKIP SOME TESTS

	TRO	F,OB.RDF	;PRESUME HE CAN CHANGE STATUS
	HRRZ	B,DSKCHA+.UNJOB	;B=SINGLE USER JOB # (IF ANY)
	CAMN	B,FSJOB		;STRJOB=USER JOB #?
	JRST	DSKCK4		;YES-THE USER IS ONLY USER OF F/S
	SKIPLE	DSKCHA+.UNJOB
	JRST	ERR222		;NO--IF F/S  IS S.A.  THIS REQUEST LOOSES
	TLNN	A,.UPZMT	;IF MOUNT-COUNT NOT 0
	TRZ	F,OB.RDF	;   DONT CHANGE STATUS

;CHECK USER SWITCHES AGAINST CURRENT STATUS OF F/S

	TLNN	A,.UPZMT	;/SING WHEN MOUNT COUNT NOT 0?
	TRZN	F,SB.S
	JRST	DSKCK2		;NO
	PUSHJ	P,MSG223	;YES-CANCEL SWITCH AND TYPE MESSAGE
	TRO	F,OB.PRO

DSKCK2:	TLNN	A,.UPZMT	;/UWLOCK WHEN MOUNT-COUNT NOT 0?
	TRNN	F,SB.UWL
	JRST	DSKCK3		;NO
	TLNE	A,.UPAWL	;YES-IS IT ALREADY W.L.'D FOR ALL?
	JRST	DSKCK3		;YES-DONT GRIPE THEN
	TRZ	F,SB.UWL	;NO--CANCEL SWITCH AND TYPE MESSAGE
	TRO	F,OB.PRO
	PUSHJ	P,MSG223

DSKCK3:	TLNE	A,.UPAWL	;IS F/S W.L.'D FOR ALL
	TRNE	F,SB.UWL	;   BUT USER DIDNT TYPE /UWL?
	JRST	DSKCK4		;NO
	HLRZ	C,OWNPPN	;YES-IS HE ALLOWED TO TURN IT OFF?
	HLRZ	D,FSPPN		;   I.E. HIS PROJ.=OWNERS PROJ.?
	CAIE	C,-1		;   OR OWNER = 'ANYONE'?
	CAMN	C,D
	JRST	DSKCK4		;YES-ASSUME HE KNOWS WHAT HES DOING
	PUSHJ	P,MSG224	;NO--TELL HIM ITS W.L.'D FOR ALL
	TRON	F,SB.UWL!SB.WL	;IF HE DIDNT /WLOCK
	PUSHJ	P,MSG225	;   DO IT FOR HIM & TELL HIM YOU DID
;CHECK ACTUAL DRIVES AGAINST USER REQUEST & MAKE SURE UNITS ARE READY

DSKCK4:	PUSHJ	P,GETUNI	;GET F/S PHYSICAL UNITS
	  PUSHJ	P,NEVMSJ

;SHOULD WE CONSULT OPERATOR BEFORE PROCEEDING?

	TRZE	F,OB.PRO
	PUSHJ	P,OPER		;YES--DO SO

;	MAKE SURE UNITS ARE READY

	PUSHJ	P,WATUNI

;RESET THE F/S STATUS BITS

	TRNN	F,OB.RDF	;ALLOWED TO CHANGE STATUS?
	JRST	SLCK		;NO
	PUSHJ	P,FSRDF		;YES--DO IT
;CHECK FOR F/S IN JOB'S SEARCH LIST

SLCK:	TRNE	F,OB.OPC	;OPR.COMMAND?
	JRST	MOFIN		;YES-SKIP IT

	MOVE	C,FSNAME
	MOVE	D,FSPPN
	TRON	F,OB.UFD	;GET UFD INTERLOCK
	PUSHJ	P,UFDLOK	;  IF DONT ALREADY HAVE IT
	PUSHJ	P,MAKSL
	SKIPE	C		;MAKE FENCE (IF ANY) THE END OF LIST
	MOVE	B,C
	JUMPE	A,SLCK2		;JUMP IF NOT IN SEARCH-LIST
	CAMG	A,C		;WHICH SIDE OF FENCE IS F/S?
	JRST	SLCK3		;ACTIVE
SLCK2:	MOVE	A,B		;PUT F/S AT END OF LIST
	MOVEI	B,3(A)		;   AND BUMP END PAST IT
SLCK3:	MOVE	C,FSNAME	;F/S NAME TO ARG.LIST
	MOVEM	C,(A)
	SETZB	C,1(A)		;***PPN ENTRY = 0 FOR NOW
	TRNE	F,SB.WL		;WRITE-LOCK?
	TLO	C,DSLWLK	;YES-SET BIT
;----------------
; PUT NO-CREATE' IN C WHEN IMPLEMENTED
;----------------
	MOVEM	C,2(A)		;STATUS BITS TO ARG.LIST

	SUBI	B,FSDSLA	;COMPUTE ARG.LIST LENGTH
	HRLZM	B,FSDSLA	;   AND SAVE IN FSDSLA FOR SLADD

;MAKE AND CHECK USER UFD ON THIS F/S IF NECCESSARY

	MOVE	A,FSPPN
	MOVE	B,FSNAME
	PUSHJ	P,MAKUFD
	  JUMPN	A,FSQUIT	;IF ITS JUST NO QUOTA.SYS
				;  GO AHEAD AND MOUNT
;ADD F/S TO END OF USER'S ACTIVE SEARCH LIST

	MOVEI	A,.FSDSL	;SET FUNCTION CODE
	EXCH	A,FSDSLA	;AND BUILD UUO AC
	HRRI	A,FSDSLA
	STRUUO	A,
	  JRST	ERR241		;UUO FAILURE

;HERE WHEN ALL HAS BEEN DONE THAT CAN BE DONE FOR THIS MOUNT

MOFIN:

	JRST	FSQUIT
;SUBROUTINE TO DEFINE A NEW F/S TO THE SYSTEM
;CALL	FSNAME=F/S NAME
;	UDRIVE=LIST OF USER DRIVE REQUESTS
;	UNITID=PACK I.D.'S
;	UNITCL=PACK CLASS AND TYPE (FROM STRLST.SYS)
;	FSUNM=NUM. OF UNITS
;	FSUAOB=AOBJ PTR FOR UNIT TABLES (XWD -#UNITS,0)
;RET+0	PDRIVE=PHYSICAL DRIVE NAMES
;	A=DSKCHR UUO AC
;	REST OF DSKCHR UUO VALUES IN DSKCHA...

DEFIN:

;TRY TO SATISFY USER DRIVE REQUESTS

;	FIND MOST SPECIFIC USER REQUESTS FIRST

	SETZ	B,		;USE B FOR MASK
UPICK2:	LSH	B,6		;EXPAND MASK
	ORI	B,77
	MOVE	D,FSUAOB	;D=AOBJ PTR TO DRIVE TABLES
UPICK3:	SKIPE	PDRIVE(D)	;HAVE WE ALREADY SELECTED THIS ONE?
	JRST	UPICK4		;YES
	SKIPL	B		;LAST TIME THRU CATCH 0 ENTRIES
	TDNE	B,UDRIVE(D)	;NO--IS IT SPECIFIC ENOUGH?
	PUSHJ	P,MPICK		;YES-GO FIND A DRIVE FOR IT
UPICK4:	AOBJN	D,UPICK3	;JUMP IF MORE DRIVES TO DO FOR THIS MASK
	JUMPGE	B,UPICK2	;JUMP IF MORE MASKS TO DO

;IF ANY PROBLEMS--ASK OPERATOR WHAT TO DO

	TRZE	F,OB.PRO
	PUSHJ	P,OPER

;TELL OPERATOR TO MOUNT UNITS & READ HIS DRIVE SELECTIONS

	PUSHJ	P,OPICK

;WAIT FOR UNITS TO BECOME READY

	PUSHJ	P,WATUNI
;HERE WHEN UNITS ARE FINALLY MOUNTED AND READY
;   FSNAME=F.S. NAME, FSUNM=NUM. OF LOG.UNITS
;   PDRIVE=LIST OF PHYS.DRIVE.NAMES, UNITID=LIST OF PACK ID'S

	MOVEI	A,DSKTRY	;INIT FSTRY
	MOVEM	A,FSTRY

;PUT 1ST HOME BLOCK (LOG.UNIT 0) INTO 'HOME'.

	SETZM	FSLUN		;LOG.UNIT=0
	PUSHJ	P,GETHOM	;READ HOME BLK
	  JRST	FSQUIT		;CANT--QUIT

;FILL IN STR PARAMETER BLOCK FOR STRUUO(.FSDEF)
;   STUFF FROM HOME BLOCK (AND A FEW OTHER PLACES)
;   ALSO SETS UP FSCNP & FSCLP POINTERS TO RIB-POINTERS

	SETZM	FSASTR+SS.JOB	;STRJOB=0
	MOVE	B,[XWD -FSXSTL,FSXSTR]
	MOVEI	C,FSASTR
	PUSHJ	P,MOVALU
	MOVEI	A,A		;MAKE FSCNP & FSCLP ADDRESS A
	HRRM	A,FSCNP
	HRRM	A,FSCLP

;CHECK HOME BLOCK NAME

	MOVE	N,HOME+HOMSNM
	CAMN	N,FSNAME
	JRST	FSDF5
	PUSHJ	P,MSG276	;DIFFERENT
	PUSHJ	P,OPER		;ASK OPR IF THATS OK

;USE DSKCHR TO COMPUTE STRBPU, STRSIZ, & STRHGH

FSDF5:	MOVE	B,FSUNM	;COUNT NO. OF UNITS IN B
	SETZB	C,D		;C FOR BIGGEST UNIT, D FOR SUM
FSDF6:	MOVE	A,PDRIVE-1(B)	;GET PHYS UNIT NAME
	PUSHJ	P,DSKUUO	;DO DSKCHR FOR IT
	  JSP	A,NEVERR	;IMPOSSIBLE ERROR RETURN
	ADD	D,DSKCHA+.UNBPU	;ACCUMULATE TOTAL BLOCKS
	CAMGE	C,DSKCHA+.UNBPU	;CK. FOR LARGEST UNIT
	MOVE	C,DSKCHA+.UNBPU
	SOJG	B,FSDF6		;LOOP FOR ALL UNITS

	MOVEM	C,FSASTR+SS.BPU	;PUT VALUES IN STR PARAM.BLOCK
	MOVEM	D,FSASTR+SS.SIZ
	MOVEM	C,FSBPU		;GETFSB NEEDS THIS
	IMUL	C,FSUNM		;COMPUTE STRHGH
	SOS	C
	MOVEM	C,FSASTR+SS.HGH

;SET STR1PT PARAMETER

	SETOM	FSASTR+SS.1PT	;ASSUME ONLY 1 PTR.

MFDRIB==SATRIB		;USE SATRIB BUFFER

	MOVE A,[IOWD 200,MFDRIB];GET MFD RIB
	MOVE	B,HOME+HOMMFD
	PUSHJ	P,GETFSB
	  JRST	ERR276		;'ERROR WHILE GETTING MFD-RIB'
	MOVE	A,RIBFIR+MFDRIB	;GET REL.ADDR. OF 1ST PTR.
	SKIPE	A,MFDRIB+2(A)	;SKIP IF 2ND PTR.=0 (ONLY 1 PTR.)
	SETZM	FSASTR+SS.1PT	;CLEAR 'ONLY 1 PTR.' BIT
;PUT SAT-RIB IN 'SATRIB'

	MOVE	A,[IOWD 200,SATRIB]
	MOVE	B,HOME+HOMSAT	;LOG.BLK.NO. IS IN HOME BLOCK
	PUSHJ	P,GETFSB
	  JRST	ERR270		;ERROR 'WHILE GETTING SAT-RIB'
	MOVS	A,SATRIB+RIBNAM	;IS IT SAT.SYS?
	HLRZ	B,SATRIB+RIBEXT
	CAIN	A,(SIXBIT /SAT/)
	CAIE	B,(SIXBIT /SYS/)
	JRST	ERR271		;NO--TYPE 'NAME OR CODE FAILURE...'

;INITIALIZATION FOR LOOKING AT UNITS

	MOVE	A,SATRIB+RIBFIR	;MAKE AOBJ PTR. INTO SAT-RIB
	ADDI	A,SATRIB
	MOVE	B,(A)		;MOVE 1ST PTR. (UNIT PTR.) DOWN OVER
	MOVEM	B,1(A)		;   2ND PTR.(RIB) SO UNIT CK. BELOW WILL WORK
	MOVEM	A,FSATPT	;AND STORE PTR. IN FSATPT

	SETZM	FSASTR+SS.TAL	;CLEAR THESE SO CAN ACCUM. SUMS
	SETZM	FSASTR+SS.RES
	PUSHJ	P,FSBITS	;SETUP UNIDES BITS

;HERE FOR EACH UNIT TO FILL ITS PARAMETER BLOCK
;ITS HOME BLOCK IS ALREADY IN 'HOME AND FSLUN=ITS LOG.UNIT.NO.

FSDF10:

	MOVE	A,FSLUN

;GET ADDRESS OF THIS UNIT PARAMETER BLOCK (SAVE IN FSUPA)

	MOVE	C,FSARG+2(A)
	MOVEM	C,FSUPA

;DO DSKCHR FOR THIS UNIT (C=PARAM.BLK.ADDR.)

	MOVE	B,FSNAME	;MAKE NEW F.S. LOG. UNIT NAME
	PUSHJ	P,LOGUNI
	MOVEM	B,SU.LOG(C)
	MOVE	B,HOME+HOMHID	;AND GET PACK ID IF DONT HAVE IT
	SKIPN	UNITID(A)
	MOVEM	B,UNITID(A)
	MOVE	A,PDRIVE(A)	;A=PHYS.UNIT NAME
	MOVEM	A,SU.NAM(C)	;STORE IT IN UNIT PARAM.BLOCK
	PUSHJ	P,DSKUUO	; DO DSKCHR
	  JSP	A,NEVERR	;IMPOSSIBLE ERROR RETURN
;MOVE SOME STUFF INTO PARAM.BLOCK (MOSTLY HOME BLOCK VALUES)

	MOVE	B,[XWD -FSXUNL,FSXUNI]
	PUSHJ	P,MOVALU

;COMPUTE UNICPS & UNIWPS  (STILL EXPECT C=PARAM.BLK.ADDRESS)

	MOVE	A,DSKCHA+.UNBPU	;A=BLOCKS/UNIT
	SOS	A
	IDIV	A,HOME+HOMBPC	;A=LARGEST CLUSTER ADDRESS
	IDIV	A,HOME+HOMSPU	;A=CLUSTERS/SAT-1
	MOVEM	A,SU.CPS(C)	;STORE
	AOS	SU.CPS(C)	;   & BUMP
	IDIVI	A,^D36		;A=WORDS/SAT-1
	AOS	A		;BUMP
	MOVEM	A,SU.WPS(C)	;   & STORE

;MAKE & STORE PTR. TO SPT TABLE (STILL NEED C=PARAM.BLK.ADDRESS)

	MOVS	D,HOME+HOMSPU	;LENGTH=SATS/UNIT
	HRRI	D,SU.L(C)	;EXPECT ROOM FOR SPT AT END OF
	MOVEM	D,SU.SPT(C)	;   UNIT PARAM.BLOCK
	MOVN	A,HOME+HOMSPU	;MAKE AOBJ PTR TO SPT TABLE
	HRL	D,A

	SETZM	SU.TAL(C)	;CLEAR FREE BLOCK TALLY

;BUILD SPT TABLE FROM SAT-RIB PTRS. (D=SPT TABLE ADDRESS)
;   CK THAT UNIT PTR. IS FOR THIS UNIT

	MOVE	C,FSATPT	;C=AOBJ PTR. INTO RIB
	AOBJP	C,ERR273
	MOVE	A,(C)		;A=1ST RIB PTR.
	JUMPE	A,ERR273	;IF 1ST PTR. NOT THIS UNIT 
	LDB	B,FSCNP	;   ERROR'SAT-RIB HAS BAD FORMAT...
	JUMPN	B,ERR273
	ANDI	A,77
	CAME	A,FSLUN
	JRST	ERR273
;HERE FOR EACH GROUP PTR. FOR THIS UNIT
;   C=AOBJ PTR. INTO RIB, D=AOBJ PT. TO SPT

FSDF12:	AOBJP	C,ERR273	;GET NEXT PTR.
	MOVE	A,(C)
	LDB	B,FSCNP	;IS IT A GROUP PTR.?
	JUMPE	B,ERR273	;NO--ERROR 'BAD FORMAT...'

	LDB	B,FSCLP	;YES-PUT CLUST.ADDR. IN SPT TABLE
	DPB	B,FSCLA

;READ SAT BLOCK INTO 'SAT'

	IMUL	B,HOME+HOMBPC	;MAKE BLOCK ADDR. FROM CLUST.ADDR.
	MOVEM	D,FSPTAD	;SAVE SOME AC'S
	MOVEM	C,FSATPT
	MOVE	A,[IOWD 200,SAT]
	MOVE	C,FSLUN
	PUSHJ	P,GETUNB	;READ SAT IN
	  JRST	ERR274		;ERROR 'WHILE GETTING SAT BLOCK'

;COUNT 0'S AND ADD TO VARIOUS TALLYS

	MOVE	D,FSUPA	;MAKE AOBJ PTR. FOR ZBITS
	MOVN	D,SU.WPS(D)
	MOVSS	D
	HRRI	D,SAT+SAFFIR
	PUSHJ	P,ZBITS		;RETURN NUM. 0'S IN A
	MOVE	D,FSPTAD	;RESTOR SPT ADDRESS
	DPB	A,FSTAL		;   AND DEPOSIT IN SPT PTR.

	IMUL	A,HOME+HOMBPC	;MAKE A=FREE BLOCK COUNT
	MOVE	B,DSKCHA+.UNBPU ;B=TOTAL BLOCKS ON UNIT
;	MOVE	C,HOME+HOMK4S	;   MINUS SWAPPING SPACE
;	IMULI	C,BLKBPK
;	SUB	B,C
	IDIVI	B,UNVRSF	;COMPUTE SAFTY FACTOR FROM IT
	SUB	A,B		;  AND SUBTRACT FROM FREE COUNT

	MOVE	B,FSUPA	;B=ADDR. OF UNIT PARAM.BLOCK
	ADDM	A,FSASTR+SS.TAL	;ADD TO STR TALLY
	ADDM	A,SU.TAL(B)	;   AND UNIT TALLY

;LOOP BACK TO FSDF12 FOR NEXT RIB GROUP PTR.

	MOVE	C,FSATPT	;RESTORE RIB PTR. PTR.
	AOBJN	D,FSDF12	;BUMP SPT PTR. AND LOOP IF MORE TO DO
;HERE WHEN FINISHED WITH A UNIT
;IF ANY MORE UNITS, GET HOME BLOCK & LOOP BACK TO FSDF10

	AOS	A,FSLUN		;BUMP LOG.UNIT NUM.
	CAML	A,FSUNM
	JRST	FSDF20		;TO FSDF20 IF ALL DONE
	PUSHJ	P,GETHOM
	  JRST	FSQUIT		;QUIT IF CANT GET HOME BOLCK
	JRST	FSDF10


;HERE WHEN FINISHED WITH LAST UNIT

FSDF20:	MOVE	C,FSATPT	;CK. SAT-RIB TO SEE THAT ONLY 2ND
	AOBJP	C,ERR273	;   RIB PTR. & EOF PTR. REMAIN
	AOBJP	C,ERR273
	SKIPE	(C)
	JRST	ERR273

;DO THE STRUUO(.FSDEF)

	HRLZ	A,FSUNM		;BUILD UUO AC
	ADD	A,[XWD 2,FSARG]
	STRUUO	A,
	  JRST	ERR275		;DIDNT WORK
	MOVE	A,FSNAME	;DSKCHR THE NEW F/S
	PUSHJ	P,DSKUUO
	  PUSHJ	P,NEVMSJ	;DIDNT LAST LONG
	POPJ	P,		;F/S IS NOW DEFINED--GO FINISH MOUNT
; D I S M O U N T    C O M M A N D

;HERE TO READ TTY

DICOMT=ERR302		;USE REMOVE

;HERE TO READ COMMAND FILE

DICOMF:	JLEVC	ERR099
	MOVEI	IO,R.CMD
	PUSHJ	P,SSIXIN	;STEP PAST COMMAND NAME

	MOVEI	D,DISWIT	;CHECK FOR SWITCHES
	PUSHJ	P,COMNAM	;   AND GET F/S NAME
	JUMPE	A,ERR301	;ERROR IF NONE
	TRNE	A,77		;PROPER NAME?
	JRST	ERR300		;NO
	MOVEM	A,DVVNAM

	MOVEI	D,DISWIT	;CHECK SWITCHES AGAIN
	PUSHJ	P,SWITCH
	  JRST	FSQUIT		;BAD SWITCH

;IS IT A DISK?

	MOVE	A,DVVNAM
	DEVTYP	A,
	  JRST	ERR501
	JUMPE	A,ERR501	;UNDEF.DEVICE
	LDB	B,[.TYTYP+A]
	CAIN	B,.TYDSK	;DISK OR F.S.?
	JRST	DISFS		;YES--SPECIAL ATTENTION

;HERE IF NOT A F.S.

	LDB	B,[.TYJOB+A]	;ASSIGNED TO JOB WHO CALLED US?
	CAME	B,CMDJOB
	JRST	ERR502		;NO--IGNORE IT
	TRNE	F,SB.R		;BRING /REMOVE SWITCH TO OPRS ATTENTION
	PUSHJ	P,MSG505
	PUSHJ	P,OPER		;GET OPERATORS GOAHEAD
	JRST	DIFIN
;HERE IF F.S.
;IS F/S IN HIS SEARCH LIST?

DISFS:	PUSHJ	P,CKFS		;IS IT A GOOD F/S NAME?
	  JRST	ERR311		;NO
	TRNE	F,OB.OPC	;OPR.COMMAND?
	JRST	DISFS2		;YES-IGNORE SEARCH LIST
	MOVE	C,FSNAME
	MOVE	D,FSPPN
	TRON	F,OB.UFD	;GET THE UFD INTERLOCK
	PUSHJ	P,UFDLOK	;   IF DONT HAVE IT YET
	PUSHJ	P,MAKSL		;SEE IF ITS IN S.L. & BUILD .FSDSL ARG.LST
	JUMPE	A,REMSL5	;NOT IN S.L.--SKIP STRUUO(.FSDSL)

;YES--MUST CHECK UFD BEFORE REMOVING

	MOVE	A,FSPPN		;GET QUOTA.SYS LOG-OUT QUOTA
	MOVE	B,FSNAME
	PUSHJ	P,GETQUO
	  SETOM	D
	MOVE	A,FSPPN
	MOVE	B,FSJOB
	SETZ	N,
	MOVE	N1,MFDPPN
	MOVE	M,FSNAME
	MOVEI	IO,W.TTY

	PUSHJ	P,UFDCLR
	  JRST	FSQUIT
;NOW REMOVE IT FROM SEARCH-LIST

	PUSHJ	P,MAKSL
	  JUMPE	A,REMSL5
	HRLI	A,3(A)		;IS IN S.L.--REMOVE IT FROM ARG.LST.
	BLT	A,-3(B)		;   BY BLT'ING OVER IT
	MOVEI	A,.FSDSL	;SET FUNCTION CODE
	MOVEM	A,FSDSLA
	MOVEI	A,DSLREM	;SET BIT TO REMOVE F/S & DEC. MNT.COUNT
	ORM	A,FSDSLA+3

	SUBI	B,FSDSLA+3	;BUILD UUO AC
	HRL	A,B
	HRRI	A,FSDSLA
	STRUUO	A,
	  JRST	ERR241		;UUO FAILED

REMSL5:	MOVE	C,FSNAME	;GIVEUP THE UFD INTERLOCK
	MOVE	D,FSPPN
	TRZE	F,OB.UFD	;   IF WE HAVE IT
	PUSHJ	P,UFDUNL

DISFS2:	TRNE	F,SB.R		;WANTS TO REMOVE PACKS?
	JRST	REMOV		;YES

	PUSHJ	P,CKFS		;IS MOUNT COUNT NOW 0?
	  PUSHJ	P,NEVMSJ
	TRZ	F,SB.S!SB.UWL
	SKIPN	DSKCHA+.STMNT
	PUSHJ	P,FSRDF		;YES-SET F/S STATUS BIT S TO 0

;HERE WHEN ALL HAS BEEN DONE THAT CAN BE DONE FOR DISMOUNT

DIFIN:	JRST 	FSQUIT
;HERE TO REMOVE F/S FROM THE SYSTEM

REMOV:	PUSHJ	P,CKFS		;IS IT A FILE STRUCTURE?
	  JRST	ERR311		;NO--SAY SO

	TRNN	F,OB.OPC	;OPERATOR COMMAND?
	PUSHJ	P,MSG320	;NO--TELL HIM USER WANTS TO REMOVE

REMOV1:	PUSHJ	P,CKMNC		;CHECK MOUNT COUNT
REMOV2:	PUSHJ	P,GETUNI	;GET PHYS. DRIVE NAMES
	  PUSHJ	P,NEVMSJ
REMOV3:	MOVEI	A,.FSREM	;DO THE STRUUO
	MOVE	B,FSNAME
	MOVEI	C,A
	STRUUO	C,
	  JRST	REMOV5		;WHAT ERROR?

;F/S IS NOW GONE -- TELL OPERATOR

	PUSHJ	P,MSG330

;	PRINT DRIVE NAMES

	MOVE	D,FSUAOB
REMOV4:	MOVE	M,PDRIVE(D)
	PUSHJ	P,SIXMSG
	AOBJN	D,REMOV4
	PUSHJ	P,CRLF

	JRST	DIFIN

REMOV5:	CAIN	C,.ERUNC	;IS IT THE 'TRY AGAIN' ERROR?
	JRST	REMOV3		;YES--TRY AGAIN THEN
	JRST	ERR320		;NO---LOOSE
;SUBROUTINE TO GET DRIVE FOR A USER REQUEST
;CALL	D=INDEX ON PDRIVE-UDRIVE
;	B=MASK RIGHT JUSTIFIED COVERING LOW ORDER CHARACTER

MPICK:	MOVEM	B,MPICKB	;SAVE B
	SKIPL	B
	LSH	B,-6		;MAKE A LEFT JUST. MASK
	SETCA	B,

;LOOK THROUGH SYSTEM UNITS FOR ONE THAT SATISFIES

MPICK0:	SETZM	DSKCHA
MPICK1:	PUSHJ	P,NXDRIV	;GET NEXT SYS.DRIVE
	  JRST	MPICK5		;  NO MORE
	MOVE	C,UDRIVE(D)	;YES-DOES IT SATISFY USER REQUEST
	AND	C,B		;   WHEN MASKED?
	MOVE	A,DSKCHA
	AND	A,B
	CAME	A,C
	JRST	MPICK1		;NO--TOO BAD

	MOVE	A,FSUAOB	;YES-HAVE WE ALREADY USED IT?
	MOVE	C,DSKCHA
MPICK3:	CAMN	C,PDRIVE(A)
	JRST	MPICK1		;YES-FORGET IT THEN
	AOBJN	A,MPICK3

;	HERE WHEN FOUND A DRIVE (NOT NECESSARILLY USER'S REQUEST)

	MOVEM	C,PDRIVE(D)	;NO--USE IT
	LSH	B,6		;DID WE SATISFY THE REQUEST?
	SETCA	B,
	CAME	B,MPICKB
	PUSHJ	P,MSG250	;NO--TELL THE USER
	MOVE	B,MPICKB
	POPJ	P,
;	HERE WHEN CANT FIND A SATISFING DRIVE FOR THIS MASK

MPICK5:	TRO	F,OB.PRO	;REMEMBER TO ASK OPR 'PROCEED?'
	TLNN	B,77		;MORE SPECIFIC THAN CONTROLLER CLASS?
	JRST	MPICK7		;NO--NOT ENOUGH DRIVES THEN
	LSH	B,6		;YES-TRY SOMETHING MORE GENERAL
	JRST	MPICK0

;	HERE WHEN CANT FIND ANY DRIVE THAT WILL WORK

MPICK7:	TRON	F,OB.NED	;HAVE WE ALREADY FAILED?
	PUSHJ	P,MSG251	;NO--TYPE THE BAD NEWS
	MOVE	B,MPICKB	;RESTORE B
	POPJ	P,		;   AND RETURN

	U(MPICKB)
;SUBROUTINE TO GET OPERATOR DRIVES
;CALL	PDRIVE=SYSTEM PICKED UNITS (MPICK)
;	UDRIVE=USER "
;RET+0	PDRIVE=OPERATOR PICKED UNITS

;	TYPE F/S NAME

OPICK:	TRNN	F,OB.OPC	;SKIP MESSAGE IF AN OPERATOR COMMAND
	PUSHJ	P,MSG253

;	TYPE LIST OFFREE DRIVES

	PUSHJ	P,MSG252
	SETZM	DSKCHA
	MOVE	D,FSUAOB	;INIT INDEX
	PUSHJ	P,NXDRIV
	  MOVE	A,['NONE  ']	;NO FREE DRIVES
OPICK1:	MOVE	M,A
	PUSHJ	P,SIXMSO
	PUSHJ	P,SPACE
	PUSHJ	P,NXDRIV
	  SKIPA
	JRST	OPICK1
	PUSHJ	P,CRLF

;	GET OPERATOR DRIVES

OPICK0:	MOVE	D,FSUAOB	;AOBJ PTR
OPICK3:	MOVEI	IO,W.TTY
	PUSHJ	P,CRLF
	MOVE	M,UNITID(D)	;TYPE UNIT ID
	JUMPN	M,OPIC32	;IF NO UNIT ID
	PUSHJ	P,QUOTE		;  PRINT LOG NAME IN QUOTES
	MOVE	B,FSNAME
	MOVE	A,D
	PUSHJ	P,LOGUNI
	MOVE	M,B
	PUSHJ	P,SIXMSO
	PUSHJ	P,QUOTE
	JRST	OPIC33
OPIC32:	PUSHJ	P,SIXMSO
OPIC33:	PUSHJ	P,TAB
	SKIPN	PDRIVE(D)	;AVAILABLE DRIVE?
	JRST	OPIC34		;NO
	PUSHJ	P,LEFTP		;YES-TYPE IT IN PARENS
	MOVE	M,PDRIVE(D)
	PUSHJ	P,SIXMSO
	PUSHJ	P,RIGHTP
OPIC34:	PUSHJ	P,COLON
	OUTPUT	TTY,
	MOVEI	IO,R.TTY
	MOVEI	M,OPKHLP	;GET OPERATORS REPLY
	PUSH	P,D
	PUSHJ	P,OPRARG
	POP	P,D
	JRST	.+1(N)	;DISP. ON N
	JRST	OPICK4	;0-LONE C.R.
	JUMPN	A,OPICK5;1-NOT LONE C.R.
	JRST	OPICK3	;2-/HELP
	JRST	OPIC98	;3-GARBAGE
	JRST	OPIC98	;4-ERROR

OPICK4:	MOVE	A,PDRIVE(D)	;USE THE SUGGESTED DRIVE
OPICK5:	HRRZ	B,D		;ARE WE ALREADY USING THIS NAME?
OPIK51:	SOJL	B,OPIK52
	CAME	A,PDRIVE(B)
	JRST	OPIK51
	JRST	C,OPICK8	;'UNAVAILABLE' MSG.

OPIK52:	PUSHJ	P,CKDRIV	;NO--CHECK THIS NAME
	  JRST	OPICK8		;ITS NO GOOD
	MOVE	A,DSKCHA	;ITS OK SO SUBSTITUTE IT
	MOVEM	A,PDRIVE(D)	;  FOR SUGGESTED DRIVE

	AOBJN	D,OPICK3	;LOOP
	POPJ	P,

OPICK8:	MOVEI	M,[ASCIZ/  UNAVAILABLE/]
	PUSHJ	P,MSGTTY
	JRST	OPICK3

OPIC98:	PUSHJ	P,MSG200	;/H FOR HELP

	JRST	OPICK3
;SUBROUTINE TO WAIT FOR UNITS TO BECOME READY
;CALL	PDRIVE=DRIVE NAMES
;	UNITID=UNIT ID'S


WATUN0:	SLEEP	A,

WATUNI:	SETZB	A,FSLUN		;LOGICAL UNIT 0
	SETZM	WATUNS		;CLEAR SLEEP FLAG

WATUN3:
;	MOVE	A,PDRIVE(A)	;DO A DSKCHR ON THIS UNIT
;	PUSHJ	P,DSKUUO
;	  JSP	A,NEVERR
;	--IF NOT ONLINE GO TO WATUN4--
	PUSHJ	P,GETHOM	;READ HOME BLOCK
	  JRST	WATUN4		;NOT READY YET
	MOVE	D,FSLUN		;IS IT RIGHT PACK?
	MOVE	A,UNITID(D)
	JUMPE	A,WATUN5	;SKIP CK. IF NO UNITID
	CAMN	A,HOME+HOMHID
	JRST	WATUN5		;YES

	MOVEI	M,[ASCIZ/WRONG UNIT ON /] ;NO--TELL OPERATOR
	PUSHJ	P,MSGTTY
	MOVE	M,PDRIVE(D)
	PUSHJ	P,SIXMS4
	MOVEI	M,[ASCIZ/
...IS /]
	PUSHJ	P,MSGTTY
	MOVE	M,HOME+HOMHID
	PUSHJ	P,SIXMSG
	MOVEI	M,[ASCIZ/ SHOULD BE /]
	PUSHJ	P,MSGTTY
	MOVE	M,UNITID(D)
	PUSHJ	P,SIXMSG
	PUSHJ	P,CRLF
	HRROS	WATUNS		;SET SLEEP SWITCH FOR 'LONG TIME'
	JRST	WATUN5

WATUN4:	HLLOS	WATUNS		;SET SLEEP SWITCH FOR 'SHORT TIME'
WATUN5:	AOS	A,FSLUN		;BUMP LOG.UNIT #
	CAMGE	A,FSUNM
	JRST	WATUN3		;LOOP IF MORE TO CHECK

	SKIPN	A,WATUNS	;WAS EVERYTHING OK?
	POPJ	P,		;YES-RETURN
	JUMPG	A,WATUN0		;NO--SLEEP SHORT
	PJRST	OPER		;NO--GIVE OPER CHANCE TO FLUSH

	U(WATUNS)

;SUBROUTINE TO GET F/S DRIVE NAMES AND PACK I.D.'S
;CALL	FSNAME=F/S NAME
;RET+0	NO UNITS--ERGO--NO F/S
;RET+1	DRIVES IN PDRIVE
;	I.D.'S IN UNITID
;	FSUNM=NUM. OF UNITS
;	FSUAOB=AOBJ PTR FOR UNITS

GETUNI:	MOVEI	C,1		;COUNT UNITS IN C
	MOVEI	A,-1(C)
	MOVE	B,FSNAME
	PUSHJ	P,LOGUNI
	MOVE	D,N		;SAVE BYTE-PTR TO THE LAST BYTE
	HRRI	D,A		;  LOG-NAME IS IN A
	MOVE	A,B
	PUSHJ	P,DSKUUO
	  POPJ	P,		;NO UNITS

GETUN2:	MOVE	A,DSKCHA+.UNNAM	;PUT DRIVE NAME IN PDRIVE
	MOVEM	A,PDRIVE-1(C)
	MOVE	A,DSKCHA+.UNHID	;AND I.D. IN UNITID
	MOVEM	A,UNITID-1(C)
	MOVE	A,DSKCHA	;MAKE NEXT LOG.NAME
	MOVEI	E,'  0'(C)	;INCREMENT THE LAST BYTE
	DPB	E,D		;  AND UPDATE THE UNIT NAME
	PUSHJ	P,DSKUUO
	  SKIPA
	AOJA	C,GETUN2

	MOVEM	C,FSUNM		;NUM. UNITS TO FSUNM
	MOVNS	C		;& AOBJ PTR TO FSUAOB
	HRLZM	C,FSUAOB
	JRST	CPOPJ1

;SUBROUTINE TO CREATE LOG.UNIT NAMES
;CALL	A=LOGICAL UNIT NUMBER (PRESERVED)
;	B=F.S. NAME
;RET+1	B=LOG.UNIT NAME

LOGUNI:	MOVE	N,[POINT 6,B]
LOGUN1:	ILDB	M,N
	JUMPN	M,LOGUN1
	MOVEI	M,'  0'(A)
	DPB	M,N
	POPJ	P,
;SUBROUTINE TO CHECK A DRIVE FOR TYPE AND AVAILABLILITY
;CALL	A=DRIVE NAME
;	D=INDEX ON UNITCL
;RET+0	C .EQ. 0 IF ILLEGAL NAME OR TYPE
;	C .NE. 0 IF NOT AVAILABLE
;RET+1	IF AVAILABLE AND OK
;	PRESERVES B AND D

CKDRIV:	PUSHJ	P,DSKUUO
	  JRST	CKDRI2		;BAD NAME
	LDB	C,DCHCOD	;SPECIFIC DRIVE NAME?
	CAIE	C,6
	JRST	CKDRI2		;NO--REJECT IT
	LDB	C,DCHKTP	;YES-RIGHT CONTROLLER TYPE?
	LDB	E,SKTYP		;
	CAME	C,E		;***
	JRST	CKDRI2		;***NO

	LDB	C,DCHUST	;YES-DOES STATE CODE='NO PACK MOUNTED?
	CAIE	C,UNVNPM
	JRST	CKDRI3		;NO--RET+0

	LDB	C,DCHUTP	;YES-RIGHT UNIT TYPE?
	LDB	A,STYPE
	CAMN	C,A
	JRST	CPOPJ1		;YES-RET+1
CKDRI2:	TDZA	C,C		;NO--RETURN+0 C=0
CKDRI3:	SETO	C,		;    RETURN+0 C NON0
	POPJ	P,

;SUBROUTINE TO GET SUCCESSIVE FREE DRIVES
;INIT	SETZM DSKCHA
;CALL	LAST DRIVE NAME IN DSKCHA
;RET+1	NO MORE DRIVES
;RET+2	DRIVE NAME IN A & DSKCHA
NXDRIV:	MOVE	A,DSKCHA	;GET NEXT SYSTEM DRIVE
	SYSPHY	A,
	  JSP	A,NEVERR		;UUO FAILURE
	JUMPE	A,CPOPJ	;JUMP IF THAT WAS LAST UNIT
	PUSHJ	P,CKDRIV	;WILL THIS DRIVE DO?
	  JRST	NXDRIV		;NO
	MOVE	A,DSKCHA
	JRST	CPOPJ1
;SUBROUTINE TO GET UFD INTERLOCK
;CALL	C=F/S
;	D=PPN
;RET+0	;ALWAYS WHEN HAVE THE INTERLOCK
;
;	USES A,B,C,D

UFDLOK:	PUSHJ	P,CONCOF	;NO ^C WHILE HAVE UFD INTERLOCK
	MOVEI	N,10		;PANIC IF CANT GET INTERLOCK IN 10 SEC.
UFDLO0:	MOVEI	B,.FSULK
	PUSHJ	P,UFDLUU	;ALREADY LOCKKED?
	  SKIPA
	POPJ	P,		;NO--WE HAVE IT NOW
	MOVEI	A,1		;YES-SLEEP AND TRY AGAIN
	SLEEP	A,
	SOJG	N,UFDLO0	;TRY AGAIN IF NOT EXAUSTED
	PUSHJ	P,MSG260	;SOMETHING WRONG--
	PJRST	OPER		;   LET OPERATOR DECIDE

;SUBROUTINE TO CLEAR UFD INTERLOCK
;CALL	C=F/S
;	D=PPPN
;RET+0	ALWAYS
;
;	USES A,B,C,D

UFDUNL:	MOVEI	B,.FSUCL
	PUSHJ	P,UFDLUU
	  JSP	A,NEVERR
	PJRST	CONCON		;^C OK NOW

UFDLUU:	MOVEI	A,B		;HERE WITH FCN.CODE IN B TO DO THE UUO
	HRLI	A,3
	STRUUO	A,
	  POPJ	P,
	JRST	CPOPJ1
;SUBROUTINE TO CHECK IF FSNAME IS A CUREN F/S NAME
;CALL	FSNAME=F/S NAME
;RET+0	NOT MOUNTED OR NOT A F/S NAME
;RET+1	FSNAME IS A CURRENTLY MOUNTED F/S

CKFS:	MOVE	A,FSNAME
	PUSHJ	P,DSKUUO	;DO A DSKCHR ON IT
	  POPJ	P,
	LDB	A,DCHCOD	;CK NAME TYPE
	CAIE	A,2
	  POPJ	P,	;NOT A F/S NAME
	JRST	CPOPJ1
;SUBROUTINE TO CHECK F.S. FOR SPECIAL CONDITIONS (SYSTEM S.L. NON-ZERO MOUNTCOUNT ETC.)
;CALL	DSKCHR STUFF IN DSKCHA...
;RET+0	IF F.S. PASSES ALL TESTS OR OPR. SAYS GO AHEAD ANYWAY
;	OTHERWISE JRSTS TO FSQUIT

CKMNC:	SKIPE	N,DSKCHA+.STMNT	;MOUNT-COUNT=0?
	PUSHJ	P,MSG312	;NO--TELL THE OPER
	LDB	A,[STAVER]
	CAIGE	A,V503
	JRST	CKMNC2
	MOVEI	N,A		;CHECK SYS.SRC.LST
	SETZM	A
	MOVE	B,SYSPPN
	MOVE	C,FSNAME
	GOBSTR	N,
	  JRST	CKMNC1
	PUSHJ	P,MSG313	;TELL OPR ITS IN SYS.SRC.LST
	JRST	CKMNC2
CKMNC1:	CAIE	N,3	;'NOT THERE' RETURN?
	PUSHJ	P,NEVMSJ	;NO-THATS AN ERROR
CKMNC2:	MOVE	A,FSNAME	;IS THIS THE QUEUE F.S. (3,3)?
	CAMN	A,CMDSTR
	PUSHJ	P,MSG314	;YES-TELL OPR

;SEE IF F.S. CONTAINS STRLST.SYS

	MOVE	B,FSNAME	;OPEN F.S.
	SETZB	A,C
	OPEN	USR,A
	  JRST	CKMNC3
	MOVE	A,[SIXBIT/STRLST/]	;LOOKUP STRLST.SYS
	MOVSI	B,(SIXBIT/SYS/)
	SETZM	C
	MOVE	D,SYSPPN
	LOOKUP	USR,A
	  JRST	CKMNC3		;NOT THERE
	PUSHJ	P,MSG317	;ITS THERE SO TELL OPR.
CKMNC3:	RELEASE	USR,

;CK. ALL UNITS FOR SWAPPNIG SPACE

	MOVEI	C,0
CKMNC4:	MOVE	A,C
	MOVE	B,FSNAME
	PUSHJ	P,LOGUNI
	MOVE	A,B
	PUSHJ	P,DSKUUO
	  JRST	CKMNC6
	SKIPN	DSKCHA+.UNK4S
	AOJA	C,CKMNC4
	PUSHJ	P,MSG315	;TELL OPER THERES SWAPPING SPACE

CKMNC6:	TRZE	F,OB.PRO	;ANY PROBLEMS?
	PUSHJ	P,OPER		;YES-LET OPR MAKE DECISION
	POPJ	P,		;NO--OR OPR SAYS GO AHEAD ANYWAY
;SUBROUTINE TO MAKE UNIDES BITS FROM SWITCH BITS
;CALL	F=SWITCH BITS
;RET+0	ALWAYS WITH FSDES=UNIDES BITS

FSBITS:	SETZ	A,
	TRNE	F,SB.S		;SING-ACCESS?
	TLO	A,DEFSAF
	TRNE	F,SB.UWL	;WRITE-LOCK ALL JOBS?
	TLO	A,DEFAWL
	MOVEM	A,FSDES
	POPJ	P,


;SUBROUTINE TO SET F/S STATUS BITS
;CALL	SWITCH BITS (SB.S,SB.UWL) IN F
;RET+0	ALWAYS (UNLESS UUO FAILS)

FSRDF:	PUSHJ	P,FSBITS	;YES-MAKE UNIDES BITS OUT OF SWITCH-BITS
	MOVE	B,[XWD -FSXRDL,FSXRDF]	;SETUP .FSRDF ARG.LIST
	MOVEI	C,FSRDFA
	PUSHJ	P,MOVALU
	STRUUO	C,		;DO THE UUO
	  JRST	ERR225		;RATS
	POPJ	P,
;SUBROUTINE TO BUILD SEARCH LIST IN STRUUO(.FSDSL)FORMAT
;CALL	FSPPN=JOB'S PPN
;	FSJOB=JOB'S #
;	FSNAME=A F/S NAME
;RET+0	ALWAYS
;	A=ADDR. OF F/S ENTRY (OR 0 IF NONE)
;	B=ADDR. OF END OF ARG.LIST
;	C=ADDR. OF FENCE ENTRY (OR 0 IF NONE)

MAKSL:	MOVE	A,FSNAME	;A=F/S WERE LOOKING FOR
	MOVE	B,FSJOB		;SETUP GOBSTR ARG.LIST
	MOVEM	B,GOBSTA+0
	MOVEM	B,FSDSLA+1	;   AND .FSDSL ARG LIST
	MOVE	B,FSPPN
	MOVEM	B,GOBSTA+1
	MOVEM	B,FSDSLA+2
	SETOM	GOBSTA+2	;-1 GETS 1ST F/S
	SETZM	FSDSLA+3	;0 FOR FSDSL FLAGS

	MOVE	B,[XWD GOBSTA+2,FSDSLA+4] ;USE B FOR BLT'S TO FSDSLA
	SETZM	MAKSLA
	SETOM	MAKSLC

MAKSL2:	MOVE	C,[XWD 5,GOBSTA] ;USE C FOR GOBSTR AC
	GOBSTR	C,
	  JRST	ERR240		;UUO FAILURE
	SKIPN	D,GOBSTA+2	;IS IT THE FENCE?
	HRRZM	B,MAKSLC	;YES-REMEMBER ADDR.
	AOJE	D,MAKSL8	;NO--JUMP OUT OF LOOP IF LAST F/S (-1)
	CAMN	A,GOBSTA+2	;IS THIS THE F/S WERE LOOKING FOR?
	HRRZM	B,MAKSLA	;YES-REMEMBER ITS ADDR/
	MOVE	C,B		;BLT THIS TRIPLET OVER TO .FSDSL ARG.LST
	BLT	C,2(B)
	ADDI	B,3		;BUMP B FOR NEXT F/S
	JRST	MAKSL2		;   AND LOOP

MAKSL8:	MOVE	A,MAKSLA
	MOVE	C,MAKSLC
	POPJ	P,

	U(MAKSLA)
	U(MAKSLC)
;SUBROUTINE TO GET USERS QUOTAS FROM QUOTA.SYS
;CALL	B=F/S NAME
;	A=PPN
;RET+0	NO QUOTAS RETURNED
;RET+1	B=RESERVED QUOTA
;	C=FCFS QUOTA
;	D=LOGGED-OUT QUOTA

GETQUO:	MOVEM	A,QUOPPN
	HLLOM	A,QUODEF	;DEFAULT (PROJ,-1)
	MOVEI	A,14
	MOVEI	C,RH.USR
	OPEN	USR,A		;TRY TO OPEN STR
	  PJRST	MSG262
	MOVEI	A,B.USR
	MOVEM	A,JOBFF
	INBUF	USR,1		;DECLARE OUR 1 BUFFER
	MOVE	A,[SIXBIT .QUOTA.]
	MOVSI	B,(SIXBIT .SYS.)
	MOVE	D,SYSPPN
	LOOKUP	USR,A		;SEE IF QUOTA.SYS EXISTS
	  JRST	GETAQ1		;NO -- SO TRY FOR AUXACC.SYS
	PUSHJ	P,R.USR		;READ SIZE OF ENTRY
	  PJRST	MSG262
	HLRZ	B,WD		;B=FORMAT VERSION NUMBER
	CAIE	B,QUOFOR
	PJRST	MSG263
	HRRZ	A,WD
	SETOM	QUODFR		;USE QUODFR AS A SWITCH
	PUSHJ	P,R.USR		;GET 1ST ENTRY
	  JRST	GETQU3
	AOSE	WD		;IS IT -1,-1?
	SOJA	WD,GETQU5	;NO
	PUSHJ	P,GETQU		;YES-REMEMBER ITS QUOTAS FOR DEFAULTS
	  POPJ	P,
	MOVEM	B,QUODFR
	MOVEM	C,QUODFF
	MOVEM	D,QUODFO
	JRST	GETQU6

GETQU1:	PUSHJ	P,R.USR		;READ FIRST WORD OF ENTRY (PPN)
	  JRST	GETQU3
GETQU5:	CAMLE	WD,QUODEF	;SKIP IF NOT YET PAST USER
	JRST	GETQU7		;HE AIN'T THERE
	CAME	WD,QUODEF	;DEFAULT?
	CAMN	WD,QUOPPN	;SKIP IF THIS IS NOT USER'S PPN
	JRST	GETQU4		;HE EXISTS, GO MAKE UFD
GETQU6:	MOVE	B,A		;SKIP REST OF THIS ENTRY
GETQU2:	SOJLE	B,GETQU1
	PUSHJ	P,R.USR
	  JRST	GETQU3
	JRST	GETQU2
GETQU3:	STATZ	USR,20000	;EOF?
	JRST	GETQU7		;YES-NO ENTRY IN QUOTA.SYS
	PJRST	MSG262		;NO--ERROR

GETQU4:	PUSHJ	P,GETQU		;READ ENTRY
	  POPJ	P,
	JRST	GETQU8		;  & RETURN

GETQU7:	SKIPGE	B,QUODFR	;WAS THERE A DEFAULT?
	JRST	GETAQ1		;NO -- SO TRY FOR AUXACC.SYS
	MOVE	C,QUODFF	;YES-USE THEM
	MOVE	D,QUODFO
GETQU8:	RELEASE	USR,
	JRST	CPOPJ1

;SUBROUT TO READ READ QUOTAS INTO B,C,D

GETQU:	PUSHJ	P,R.USR		;READ RESERVED QUOTA
	  PJRST	MSG262
	MOVEM	WD,B		;B=QTR
	PUSHJ	P,R.USR		;READ FIRST COME, FIRST SERVED QUOTA
	  PJRST	MSG262
	MOVEM	WD,C		;C=QTF
	PUSHJ	P,R.USR		;AND LOGGED-OUT QUOTA
	  PJRST	MSG262
	MOVEM	WD,D		;D=QTO
	JRST	CPOPJ1

	U(QUOPPN)
	U(QUODFR)
	U(QUODFF)
	U(QUODFO)
	U(QUODEF)
	;NO QUOTAS IN QUOTA.SYS SO TRY AUXACC.SYS
GETAQ1:	MOVEI	A,14
	HRLZI	B,(SIXBIT .SYS.)
	MOVEI	C,RH.USR
	OPEN	USR,A
	  PJRST	MSG262
	MOVEI	A,B.USR
	MOVEM	A,JOBFF
	INBUF	USR,1		;DECLARE OUR 1 BUFFER
	MOVE	A,[SIXBIT .AUXACC.]
	MOVSI	B,(SIXBIT .SYS.)
	MOVE	D,SYSPPN
	LOOKUP	USR,A		;AUXACC.SYS
	  PJRST	MSG261		;LOOKUP FAILED
	PUSHJ	P,R.USR		;PASSOVER THE NULL WORD
	  PJRST	GETAQ9		;SOMETHING IS WRONG HERE
GETAQ2:	PUSHJ	P,R.USR		;READ WORD 0  =  -1
	  PJRST	GETAQ9		;READ ERROR OR NO ENTRY
	AOJN	A,MSG264	;NO ENTRY
	PUSHJ	P,R.USR		;NUMBER OF WORDS REMAINING IN THIS ENTRY
	  JRST	GETAQ9		;
	MOVEI	D,-1(A)		;DONT COUNT THE "P,,P" WORD
	PUSHJ	P,R.USR		;READ THE "P,,P" WORD
	  JRST	GETAQ9		;
	CAML	A,QUOPPN	;COULD THIS BE THE ENTRY?
	JRST	GETAQ4		;YES
GETAQ3:	PUSHJ	P,R.USR		;NO -- SO PASS OVER THIS ENTRY
	  JRST	GETAQ9		;
	SOJG	D,GETAQ3	;
	JRST	GETAQ2		;AND TRY THE NEXT ONE

	;EITHER THIS IS IT OR ITS NOT HERE
GETAQ4:	CAME	A,QUOPPN	;EXACT MATCH
	CAMN	A,QUODEF	;OR DEFAULT PROG NUMBER
	JRST	GETAQ5		;YES
	PJRST	MSG264		;NO -- NOT HERE
GETAQ5:	PUSHJ	P,R.USR		;READ FILE-STR NAME
	  JRST	GETAQ9		;
GETAQ6:	CAMN	A,FSNAME	;IS THIS THE FILE-STR?
	JRST	GETQU4		;YES -- GET QUOTAS AND EXIT
	SUBI	D,5		;NO -- SKIP OVER THIS FILE-STR
	JUMPLE	D,MSG264	;ANY MORE FILE-STRS?  TOO BAD
	MOVEI	C,5		;YES
GETAQ7:	PUSHJ	P,R.USR		;SKIP OVER THE CURRENT ONE
	  JRST	GETAQ9		;
	SOJG	C,GETAQ7	;
	JRST	GETAQ6		;AND TRY THE NEXT ONE

GETAQ9:	STATZ	USR,20000	;EOF?
	PJRST	MSG264		;YES -- NO QUOTAS
	PJRST	MSG262		;READ ERRROR
;ERROR RETURNS---JRST TO FSQUIT WHEN FINISHED

ERR010:	MOVEI	M,[ASCIZ/? SYNTAX ERROR/]
	JRST	ERR994

ERR040=ERR010	;NAME-LIST TOO LONG

ERR041=ERR010	;NO CLOSING PAREN ON NAME-LIST

ERR097:	MOVEI	M,[ASCIZ/?MONITOR MUST BE 5.03 OR LATER/]
	JRST	ERR994

ERR098:	SETZM	CMDNAM		;SO WONT GET HERE AGAIN
	MOVEI	M,[ASCIZ/COMMAND-FILE HAS VANISHED!/]
	JRST	ERR994

ERR099:	MOVEI	M,[ASCIZ/BAD COMMAND-FILE FORMAT/]
	JRST	ERR990

ERR100:	MOVEI	M,[ASCIZ/...CANT CREATE UFD FOR COMMAND-FILES/]
	JRST	ERR994

ERR101:	MOVEI	M,[ASCIZ/CANT READ UFD FOR COMMAND-FILES/]
	JRST	ERR990

ERR200:	MOVEI	M,[ASCIZ/? UNDEFINED DEVICE/]
	JRST	ERR994

ERR201=ERR200	;NO F/S NAME

ERR211:	MOVEI	M,[ASCIZ/CANT INIT SYS/]
	JRST	ERR990

ERR221:	MOVEI	M,[ASCIZ/? LOCKED-OUT BY OPERATOR/]
	JRST	ERR994

ERR222:	MOVE	N,DSKCHA+.UNJOB	;PICKUP JOB #
	MOVEI	M,[ASCIZ/? SINGLE-ACCESS BY JOB /]
	JRST	ERR998

ERR225:	MOVE	N,C
	MOVEI	M,[ASCIZ/STRUUO(.FSRDF) UUO -- ERROR CODE /]
	JRST	ERR996
ERR240:	MOVE	N,C		;SAVE UUO ERROR CODE
ERR242:	MOVEI	M,[ASCIZ/GOBSTR UUO --ERROR CODE /]
	JRST	ERR996

ERR241:	MOVE	N,A
	MOVEI	M,[ASCIZ/STRUUO(.FSDSL) UUO --ERROR CODE /]
	JRST	ERR996

ERR270:	MOVEI	M,[ASCIZ/...WHILE GETTING SAF-RIB/]
	JRST	ERR994

ERR271:	MOVEI	M,[ASCIZ/CONSISTANCY FAILURE  FOR SAT-RIB/]
	JRST	ERR990

ERR273:	MOVEI	M,[ASCIZ/SAT-RIB HAS BAD FORMAT/]
	JRST	ERR990

ERR274:	MOVEI	M,[ASCIZ/...WHILE GETTING SAT BLOCK/]
	JRST	ERR994

ERR275:	MOVE	N,A		;SAVE ERR CODE FOR TYPEOUT
	MOVEI	M,[ASCIZ/STRUUO(.FSDEF) UUO --ERROR CODE /]
	JRST	ERR996

ERR276:	MOVEI	M,[ASCIZ/...WHILE GETTING MFD-RIB/]
	JRST	ERR994

ERR300:	MOVEI	M,[ASCIZ/?ILLEGAL STRUCTURE NAME/]
	JRST	ERR994

ERR301=ERR201	;NO F/S NAME ON DISMOUNT COMMAND

ERR302:	MOVEI	M,[ASCIZ/PLEASE USE REMOVE/]
	JRST ERR994

ERR311=ERR300		;ILLEGAL F/S NAME

ERR320:	MOVE	N,C
	MOVEI	M,[ASCIZ/STRUUO(.FSREM) UUO --ERROR CODE /]
	JRST	ERR996

ERR411=ERR201		;NO F/S NAME ON REMOVE COMMAND

ERR421=ERR201		;NO F/S NAME ON LOCK COMMAND

ERR422:	MOVE	N,C
	MOVEI	M,[ASCIZ/STRUUO(.FSLOK) UUO --ERROR CODE /]
	JRST	ERR996

ERR500:	MOVEI	M,[ASCIZ/? INVALID JOB - CANCELLED/]
	JRST	ERR994

ERR501==ERR200

ERR502:	MOVEI	M,[ASCIZ/? DEVICE NOT ASSIGNED TO THIS JOB/]
	JRST	ERR994
;HERE  (JSP A) ON'CANT HAPPEN' ERROR
NEVERR:	HRRZ	N,A	;SAVE ADDRESS FOR TYPEOUT
	MOVEI	M,[ASCIZ/? SYSTEM ERROR AT LOC /]
	JRST ERR991

ERR990:	PUSHJ	P,ERRSYS
	JRST	ERR994

ERR996:	PUSHJ	P,ERRSYS	;'SYSTEM ERROR' WITH TRAILING OCTAL
ERR991:	PUSHJ	P,MSGTTY	;PRINT TRAILING OCTAL #
	PUSHJ	P,OCTPRT
	JRST	ERR995

ERR998:	PUSHJ	P,MSGTTY	;PRINT TRAILING DECIMAL #
	PUSHJ	P,DECPR3
	JRST	ERR995

ERR993:	PUSHJ	P,MSGTTY	;PRINT TRAILING SIXBIT NAME
	MOVE	M,N
	PUSHJ	P,SIXMSGTTY
	JRST	ERR995

ERR994:	PUSHJ	P,MSGTTY
ERR995:	PUSHJ	P,CRLF
	SETOM	NOTDON		;REMEMBER NOT TO TYPE "DONE"
	JRST	FSQUIT

;ERROR RETURNS--EXIT WHEN FINISHED
;CALL WITH JSP N,...

TTYERR:	MOVEI	M,[ASCIZ/? TTY/]
	JRST	BADERR
DSKERR:	MOVEI M,[ASCIZ /? DISK/]
	JRST	BADERR
DTERR:	MOVEI M,[ASCIZ /? DECTAPE/]
BADERR:	PUSHJ	P,MSGTTY
	MOVEI	M,[ASCIZ/ ERROR AT LOC /]
	PUSHJ	P,MSGTTY
	HRRZS	N
	PUSHJ	P,OCTPRT
	EXIT
	EXIT	1

ERRSYS:	PUSH	P,M
	MOVEI	M,[ASCIZ/? SYSTEM ERROR -- /]
	PUSHJ	P,MSGTTY
	POP	P,M
	POPJ	P,
;MESSAGE TYPEOUTS--POPJ WHEN FINISHED

MSG010:	MOVEI	M,[ASCIZ/?SYNTAX ERROR/]
	JRST	MSG994

MSG050=MSG010	;'/' WITH NO NAME

MSG051:	MOVE	N,A
	MOVEI	M,[ASCIZ\?UNDEFINED SWITCH /\]
	JRST	MSG993

MSG052=MSG051	;NON-UNIQUE SWITCH

MSG200:	MOVEI	M,[ASCIZ ./H FOR HELP.]
	JRST	MSG994

MSG210:	MOVEI	M,[ASCIZ/CMD.FILE AUTHOR=/]
	JRST	MSG991

MSG211:	HLRZ	N,OWNPPN	;GET OWNER PROJ.#
	MOVEI	M,[ASCIZ\/SING OR /UWLOCK REQUIRES OWNERS PROJECT --\]
MSG213:	PUSHJ	P,MSG991
	MOVEI	M,[ASCIZ/...SWITCH(S) IGNORED/]
	JRST	MSG994

MSG214:	MOVEI	M,[ASCIZ\/SINGLE NOT ALLOWED IN OPER. COMMAND\]
	JRST	MSG213

MSG212:	MOVEI	M,[ASCIZ/TOO MANY DRIVES TYPED--STRUCTURE HAS ONLY /]
	JRST	MSG991

MSG217:	MOVE	N,DSKCHA	;PICKUP UNIT NAME  FROM DSKCHR
	MOVEI	M,[ASCIZ/? ILLEGAL DRIVE-- /]
	JRST	MSG993

MSG218:	MOVE	N,DSKCHA
	MOVEI	M,[ASCIZ/? NON-EXISTANT DRIVE-- /]
	JRST	MSG993

MSG219:	MOVEI	M,[ASCIZ/NO STRLST.SYS/]
	JRST	MSG994
MSG220:	MOVEI	M,[ASCIZ/...WHILE READING STRLST.SYS/]
	JRST	MSG994

MSG221:	MOVEI	M,[ASCIZ/WRONG FORMAT VERSION STRLST.SYS/]
	JRST	MSG994

MSG222:	MOVEI	M,[ASCIZ/STRUCTURE NOT IN STRLST.SYS/]
	JRST	MSG994

MSG223:	MOVEI	M,[ASCIZ\OTHER USERS -- CAN'T /SING OR /UWLOCK
...SWITCH(S) IGNORED\]
	JRST	MSG994

MSG224:	MOVEI	M,[ASCIZ/STRUCTURE IS WRITE-LOCKED FOR ALL JOBS/]
	JRST	MSG994

MSG225:	TRO	F,OB.PRO
	MOVEI	M,[ASCIZ\...ASSUME /WLOCK\]
	JRST	MSG994

MSG250:	MOVE	N,UDRIVE(D)	;GET DRIVE NAME
	MOVEI	M,[ASCIZ/UNAVAILABLE DRIVE-- /]
	JRST	MSG993

MSG251:	MOVEI	M,[ASCIZ/NOT ENOUGH DRIVES/]
	JRST	MSG994

MSG252:	MOVEI	M,[ASCIZ/FREE DRIVES: /]
	PJRST	MSGTTY
MSG253:	MOVE	N,FSNAME
	MOVEI	M,[ASCIZ/PLEASE MOUNT /]
	JRST	MSG993

MSG254:	MOVEI	M,[ASCIZ/WRITE-LOCKED/]
	JRST	MSG994

MSG255:	MOVEI	M,[ASCIZ/LOCKED/]
	JRST	MSG994

MSG256:	MOVE	N,DSKCHA+.UNJOB	;THE SINGLE-ACCESSOR
	MOVEI	M,[ASCIZ/SINGLE-ACCESS BY JOB /]
	JRST	MSG998

MSG260:	MOVEI	M,[ASCIZ/? CANT GET UFD INTERLOCK FOR /]
	PUSHJ	P,MSGTTY
	HLRZ	N,D
	PUSHJ	P,OCTPRT
	PUSHJ	P,COMMA
	HRRZ	N,D
	PUSHJ	P,OCTPRT
	PJRST	CRLF

MSG261:	MOVEI	M,[ASCIZ/NO AUXACC.SYS/]
	JRST	MSG266

MSG262:	MOVEI	M,[ASCIZ/CAN'T READ QUOTA.SYS OR AUXACC.SYS/]
	JRST	MSG266

MSG263:	MOVEI	M,[ASCIZ/QUOTA.SYS IS WRONG FORMAT VERSION #/]
	JRST	MSG266

MSG264:	MOVEI	M,[ASCIZ/NO ENTRY IN AUXACC.SYS/]
MSG266:	PUSHJ	P,MSG994
	MOVEI	M,[ASCIZ/...NO UFD CREATED/]
	JRST	MSG994

MSG270:	MOVEI	M,[ASCIZ/...WHILE READING 1ST HOME BLOCK/]
	JRST	MSG994

MSG271:	MOVEI	M,[ASCIZ/...WHILE READING 2ND HOME BLOCK/]
	JRST	MSG994

MSG272:	MOVE	N,C
	MOVEI	M,[ASCIZ/CANT OPEN UNIT /]
	JRST	MSG993

MSG273:	MOVE	N,C
	MOVEI	M,[ASCIZ/CANT READ UNIT /]
	JRST	MSG993

MSG275:	MOVEI	M,[ASCIZ/CONSISTANCY FAILURE/]
	JRST	MSG994

MSG276:	MOVEI	M,[ASCIZ/HOME BLOCK NAME = /]
	JRST	MSG993
MSG312:	MOVEI	M,[ASCIZ/MOUNT COUNT = /]
	TRO	F,OB.PRO	;SET 'ASK OPR' BIT
	JRST	MSG998

MSG313:	MOVEI	M,[ASCIZ/IN SYSTEM SEARCH LIST/]
	JRST	MSG316

MSG314:	MOVEI	M,[ASCIZ/CONTAINS QUEUE (3,3.UFD)/]
	JRST	MSG316

MSG315:	MOVEI	M,[ASCIZ/CONTAINS SWAPPING UNITS/]
MSG316:	TRO	F,OB.PRO	;SET 'CONSULT OPR' BIT
	JRST	MSG994

MSG317:	MOVEI	M,[ASCIZ/CONTAINS STRLST.SYS/]
	JRST	MSG316

MSG320:	TRO	F,OB.PRO	;REMEMBER TO ASK OPER
	MOVE	N,FSNAME
	MOVEI	M,[ASCIZ/REQUESTED TO REMOVE /]
	JRST	MSG993

MSG330:	MOVEI	IO,W.TTY
	MOVE	M,FSNAME
	PUSHJ	P,SIXMSG
	MOVEI	M,[ASCIZ/ REMOVED... DRIVE(S) /]
	PJRST	MSGTTY

MSG423:	MOVEI	IO,W.TTY
	MOVE	M,FSNAME
	PUSHJ	P,SIXMSG
	MOVEI	M,[ASCIZ/ LOCKED/]
	JRST	MSG994


MSG500:	MOVE	M,B
	PUSHJ	P,SIXMSO
	MOVEI	M,[ASCIZ/ ALREADY ASSIGNED TO JOB /]
	MOVE	N,C
	JRST	MSG998

MSG501:	HLLZ	M,DVVNAM
	PUSHJ	P,SIXMSO
	MOVEI	M,[ASCIZ/ HAS NO AVAILABLE UNITS/]
	JRST	MSG994

MSG502:	MOVEI	M,[ASCIZ/LOGICAL NAME CONFLICT/]
	JRST	MSG994

MSG503==MSG254		;WRITE-LOCKED

MSG504:	MOVEI	M,[ASCIZ/WRITE-ENABLED/]
	JRST	MSG994

MSG505==MSG320		;REMOVE SWITCH
MSG701:	MOVEI	M,[ASCIZ/NOT AVAILABLE/]
	JRST	MSG994

MSG702:	MOVEI	M,[ASCIZ/NOT A DECTAPE/]
	JRST	MSG994

MSG703:	MOVEI	M,[ASCIZ/NOT A DEVICE/]
	JRST	MSG994

MSG800:	MOVEI	M,[ASCIZ/NO COMMAND WAITING/]
	JRST	MSG994

NEVMSJ:	MOVE	N,(P)
NEVMSG:	HRRZS	N
	MOVEI	M,[ASCIZ/? SYSTEM ERROR AT LOC /]
	JRST	MSG991

NOTYET:	MOVEI	M,[ASCIZ/***NOT IMPLEMENTED YET***/]
	JRST	MSG994

MSG991:	PUSHJ	P,MSGTTY	;PRINT TRAILING OCTAL
	PUSHJ	P,OCTPRT
	PJRST	CRLF

MSG993:	PUSHJ	P,MSGTTY	;PRINT TRAILING SIXBIT
	MOVE	M,N
	PUSHJ	P,SIXMSO
	PJRST	CRLF

MSG994:	PUSHJ	P,MSGTTY
	PJRST	CRLF

MSG998:	PUSHJ	P,MSGTTY	;PRINT TRAILING DECIMAL
	PUSHJ	P,DECPRT
	PUSHJ	P,DOT
	PJRST	CRLF
;SUBROUTINE TO DO A DSKCHR UUO
;CALL	A=F/S OR UNIT NAME
;RET+0	UUO ERROR RETURN
;RET+1	A=DSKCHR AC

DSKUUO:	MOVEM	A,DSKCHA
	MOVE	A,[XWD DSKCHL,DSKCHA]
	DSKCHR	A,PHONLY
	  POPJ	P,
	JRST	CPOPJ1

;SUBROUTINE TO READ A /VID SWITCH
;ALWAYS SKIP RETURNS

VIDIN:	TRO	F,SB.VID
	SETZM	VIDK
	CAIE	CH,":"	;FOLLOWED BY TEXT?
	JRST	CPOPJ1		;NO-THATS ALL
	MOVNI	A,VIDMAX
	MOVE	B,[POINT 7,VID]
	TLZ	F,L.VIDT
	PUSHJ	P,(IO)
	  JRST	VIDIN4
	CAIE	CH,VIDCH1
	JRST	VIDIN6
	TLO	F,L.VIDT
	JRST	VIDIN3
VIDIN2:	PUSHJ	P,(IO)
	  JRST	VIDIN4
VIDIN6:	CAIL	CH,"0"	;DIGITS ARE LEGAL
	CAILE	CH,"9"
	CAIN	CH,"-"	;HYPHEN IS LEGAL
	JRST	VIDIN3
	CAIL	CH,"A"	;LETTERS ARE LEGAL
	CAILE	CH,"Z"
	CAIN	CH,"."	;PERIOD IS LEGAL
	JRST	VIDIN3
	CAILE	CH,15
	TLNN	F,L.VIDT
	JRST	VIDIN4
	CAIE	CH,VIDCH2
	JRST	VIDIN3
	AOSLE	A
	TDZA	A,A
	IBP	B
	DPB	CH,B
	PUSHJ	P,(IO)
	  JRST	VIDIN4
VIDIN4:	ADDI	A,VIDMAX	;FINISHED-COUNT CHARACTERS
	MOVEM	A,VIDK
	JRST	CPOPJ1
VIDIN3:	JUMPGE	A,VIDIN2	;DONT OVERUN BUFFER
	IDPB	CH,B
	AOJA	A,VIDIN2
;SUBROUTINE TO READ SWITCHES
;CALL	IO=READER ADDRESS (PRESERVED)
;	D=ADDR. OF: XWD  DISPATCH-TABLE,NAME-TABLE
;RET+0	ERROR--UNDEF. OR NON-UNIQUE SWITCH OR POPJ FROM SWITCH ROUTINE
;RET+1	NORMAL RETURN

SWITCH:	HRRZ	B,(D)		;SWITCB=OFFSET TO BITS TABLE
	MOVNM	B,SWITCB
	HLRZ	B,(D)
	ADDM	B,SWITCB
	MOVE	E,(D)
	SETZM	A

SWITC2:	MOVE	B,E
	PUSHJ	P,SST		;IGNORE BLANKS
	CAIE	CH,"/"		;SLASH?
	JRST	CPOPJ1		;NO--THATS ALL
	PUSHJ	P,(IO)		;YES-BUMP PAST IT
	  MOVEI	CH,32		;EOF
	PUSHJ	P,SIXIN		;GET NAME (RET'D IN A)
	JUMPE	A,MSG050	;ERROR IF NO NAME
	PUSHJ	P,NAMLUK	;LOOK UP THE NAME
	  JUMPN	B,MSG051	;JUMP IF 'NOT UNIQUE'
	JUMPE	B,MSG052	;JUMP IF 'NOT FOUND'

SWITC3:	ADD	B,SWITCB	;ADDRESS DISP. TABLE
	PUSHJ	P,@(B)		;DISPATCH
	  POPJ	P,	;PASS ERROR RETURN ALONG
	JRST	SWITC2

	U(SWITCB)

;SUBROUTINE TO READ AND LOOKUP NAME IN TABLE
;CALL	B=TABLE ADDRESS
;RET+1	A=0:     NO NAME TYPED
;	A NOT 0:
;		B=0:    NAME NOT FOUND
;		B NOT 0:NAME NOT UNIQUE
;RET+2	NAME FOUND & UNIQUE, B=TABLE DISPLACEMENT

TABLUK:	MOVEI	IO,R.TTY
	PUSHJ	P,SSST
TABLU0:	MOVEI	IO,R.TTY
	PUSHJ	P,SIXIN
	JUMPE	A,CPOPJ	;RET+1 A=0 IF NOTHING TO READ
	MOVE	D,B
	PUSHJ	P,NAMLUK
	  POPJ	P,		;PASS ON ERROR RETURN
	HRRZS	B
	SUB	B,D
	JRST	CPOPJ1		;RET+2 WITH DISP. IN B
;SUBROUTINE TO LOOKUP A NAME IN A TABLE
;
;CALL	A=SIXBIT NAME
;	B=ADDRESS OF NAME TABLE
;RET+0	B=0:	NOT FOUND
;	B.NE.0:	NOT UNIQUE--NO EXACT MATCH AND MULTIPLE PARTIAL MATCHES
;		RH(B)=ADDRESS OF 1ST PARTIAL MATCH
;RET+1	RH(B)=ADDRESS OF MATCH (EXACT OR UNIQUE PARTIAL)
;
;	USES C,LH(B)   PRESERVES A

NAMLUK:	SETZM	NAMLUT
NAMLU1:	PUSHJ	P,NAMCOM	;FIND A MATCH
	  JRST	NAMLU2		;END OF TABLE
	CAMN	A,(B)		;EXACT MATCH?
	JRST	CPOPJ1		;YES-RETURN IT
	SKIPE	C,NAMLUT	;NO--
	TLOA	C,-1		;   REMEMBER IF MORE THAN ONE PARTIAL
	HRRZ	C,B		;   AND 1ST ONE
	MOVEM	C,NAMLUT
	AOJA	B,NAMLU1

NAMLU2:	SKIPG	B,NAMLUT	;WAS THERE 1 & ONLY 1 PARTIAL MATCH?
	POPJ	P,		;NO--RET+0
	JRST	CPOPJ1		;YES-RET+1

	U(NAMLUT)

;SUBROUTINE TO COMPARE A NAME TO A TABLE & RETURN PARTIAL OR EXACT
;   MATCHES
;
;CALL	A=SIXBIT NAME
;	B=ADDRESS OF 1ST NAME-TABLE ENTRY TO TRY
;		(0 ENTRY SIGNALS END OF TABLE)
;RET+0	NO MATCH (PARTIAL OR EXACT)
;RET+1	RH(B)=ADDRESS OF 1ST MATCH (PARTIAL OR EXACT)

NAMCOM:	JUMPE	A,CPOPJ		;NULL NEVER MATCHES
	SETO	C,
NAMCO1:	LSH	C,-6		;MAKE MASK FOR A IN C
	TDNE	A,C
	JRST	NAMCO1
	SETCAM	C,NAMCOT

NAMCO2:	SKIPN	C,(B)		;END OF TABLE?
	POPJ	P,		;YES-RET+0
	AND	C,NAMCOT	;NO--MASK TABLE ENTRY
	CAME	C,A		;=A?
	AOJA	B,NAMCO2	;NO--CONTINUE
	JRST	CPOPJ1		;YES-RET+1

	U(NAMCOT)
;SUBROUTINE TO READ LIST OF SIXBIT NAMES
;   MUST BE DELIMITED BY COMMAS AND ENCLOSED BY PARENS
;
;CALL	IO=READER ADDRESS
;	B=XWD -LENGTH,NAMES   WHERE TO PUT NAMES FOUND
;RET+0	SYNTAX ERROR OR LIST TOO LONG
;RET+1	'PROCEED' RETURN--LIST NOT NECESSARILY FOUND

SIXLIS:	HRRZ	C,B		;REMEBER B FOR NAME COUNT
	PUSHJ	P,SST		;IGNORE LEADING BLANKS/TABS
	CAIE	CH,"("		;(?
	JRST	SIXLI3		;NO--NOT A LIST THEN
	SUB	B,[XWD 1,1]	;YES-MAKE LEADING AOBJ PTR

SIXLI2:	PUSHJ	P,SSIXIN	;GET A NAME
	AOBJP	B,ERR040	;ERROR IF LIST TOO LONG
	MOVEM	A,(B)		;STORE NAME (OR 0 IF LONE COMMA)
	PUSHJ	P,SST		;IGNORE SOME BLANKS
	CAIN	CH,","		;,?
	JRST	SIXLI2		;YES-GET NEXT NAME
	CAIE	CH,")"		;NO--CLOSING ) ?
	JRST	ERR041		;NO--SYNTAX ERROR
	PUSHJ	P,SSST		;YES-BUMP PAST )
SIXLI3:	SUBI	B,-1(C)		;CALC. NUM NAMES SEEN
	HRRZS	B
	JRST	CPOPJ1

;SUBROUTINE TO READ SWITCHES &  DEV. NAME OPTIONALLY FOLLOWED BY A COLON
;CALL	D=SWITCH TABLE ADDRESS (SEE SWITCH)

COMNAM:	PUSHJ	P,SWITCH	;GET SWITCHS IF ANY
	 JRST	FSQUIT		;SWITCH ERROR
	PUSHJ	P,SIXIN		;GET NAME
	CAIE	CH,":"
	POPJ	P,
	PUSHJ	P,(IO)
	POPJ	P,
	  MOVEI	CH,32	;EOF
	POPJ	P,
;SUBROUTINE TO PRINT LIST OF UNIT I.D.'S AND  DRIVES
;CALL	PDRIVE=LIST IF DRIVE NAMES
;	UNITID=LIST OF UNIT I.D.'S
;	FSUAOB=AOBJ PTR FOR THE ABOVE

PRTUNI:	MOVE	D,FSUAOB	;AOBJ PTR
	MOVEI	IO,W.TTY
PRTUN0:	MOVE	M,UNITID(D)	;TYPE UNIT ID
	PUSHJ	P,SIXMSO
	PUSHJ	P,TAB
	MOVE	M,PDRIVE(D)	;TYPE SUGGESTED DRIVE
	PUSHJ	P,SIXMSO
	PUSHJ	P,CRLF
	AOBJN	D,PRTUN0	;LOOP
	POPJ	P,
;SUBROUTINE TO GET HOME BLOCK
;CALL	FSLUN=LOG.UNIT NUM.
;RET+0	I/O ERRORS--MESSAGE HAS BEEN TYPED
;RET+1	OK

GETHOM:	MOVEI	B,HOMEB1	;TRY 1ST HOME BLOCK 1ST
	PUSHJ	P,GETHO
	  SKIPA			;ERROR--TRY 2ND BLOCK
	JRST	CPOPJ1		;GOT IT --RET+1
	PUSHJ	P,MSG270	;TYPE 'WHILE READING 1ST HOME BLOCK'
	MOVEI	B,HOMEB2
	PUSHJ	P,GETHO
	  PJRST	MSG271		;ERROR 'WHILE READING 2ND HOME BLOCK'
	JRST	CPOPJ1		;OK RETURN IF GOT 2ND HOME BLOCK

GETHO:	MOVE	A,[IOWD 200,HOME] ;PUT HOME BLOCK IN 'HOME'
	MOVE	C,FSLUN	;USE CURRENT UNIT.NO.
	PUSHJ	P,GETUNB
	  POPJ	P,		;PASS ERRROR RETURN ALONG
	MOVS	A,HOME+HOMNAM	;DO NAME AND CODE CHECK?
	MOVE	B,HOME+HOMCOD
	CAIN	A,(SIXBIT /HOM/)
	CAIE	B,CODHOM
	PJRST	MSG275		;NO--TYPE'NAME OR CODE FAILURE'
	AOS	(P)		;YES--GOOD, RETURN+1
	POPJ	P,


;SUBROUTINES TO READ A BLOCK
;CALL	GETFSB	A=CORE ADDRESS IOWD
;		B=LOG.BLOCK.NUM. WITHIN FS.
;		---EXPECTS FSBPU='NOMINAL'BLOCKS/UNIT---
;	GETUNB	A=CORE ADDRESS IOWD
;		B=LOG.BLOCK NUM. WITHIN UNIT
;		C=LOG.UNIT NUM.
;RET+0	I/O ERROR--MESSAGE TYPED
;RET+1	OK

GETFSB:	IDIV	B,FSBPU	;MAKE UNIT & UNIT BLK. FROM FS. BLK.
	EXCH	B,C

GETUNB:	MOVE	C,PDRIVE(C)	;C=PHYS.DRIVE NAME
	MOVEM	B,FSTEMP
	MOVEI	B,16		;FOR DUMP MODE
	SETZ	D,
	OPEN	CH.FS,B	;OPEN THE UNIT
	  PJRST	MSG272		;TYPE 'CANT OPEN UNIT ...' & RET+0
	USETI	CH.FS,FSTEMP	;SET BLK. NUM.
	SETZ	B,		;A,B=CHAN.COMMAND LIST FOR IN
	IN	CH.FS,A		;INPUT THE BLOCK
	JRST	CPOPJ1		;GOT IT--RET+1
	  PJRST	MSG273		;TYPE 'CANT READ UNIT ...' & RET+0
;SUBROUTINE TO MOVE VALUES INTO PARAMENTER BLOCKS
;CALL	B=XWD -LENGTH,ADDRESS  OF TRANSFER TABLE
;	C=ADDRESS OF PARAM. BLOCK
;RET+0	ALWAYS
;	C IS PRESERVED
;
;TRANSFER TABLE ENTRIES ARE XWD ADDRESS,DISPLACEMENT
;   WHERE ADDRESS=ADDRESS CONTAING VALUE (FETCH)
;   AND DISPLACEMENT= DISP. ON B INTO PARAMENTER TABLE (STORE)

MOVALU:	MOVS	A,(B)
	MOVE	A,(A)
	HRRZ	D,(B)
	ADD	D,C
	MOVEM	A,(D)
	AOBJN	B,MOVALU
	POPJ	P,


;TRANSFER TABLE FOR STR PARAMENTERS (STRUUO(.FSDEF))

FSXSTR:	XWD	FSNAME,SS.NAM
	XWD	FSUNM,SS.UNM
	XWD	HOME+HOMGAR,SS.GAR
	XWD	HOME+HOMOVR,SS.OVR
	XWD	HOME+HOMPT1,SS.PT1
	XWD	HOME+HOMUN1,SS.UN1
	XWD	FSTRY,SS.TRY
	XWD	HOME+HOMBSC,SS.BSC
	XWD	HOME+HOMSCU,SS.SCU
	XWD	HOME+HOMCNP,SS.CNP
	XWD	HOME+HOMCKP,SS.CKP
	XWD	HOME+HOMCLP,SS.CLP
	XWD	HOME+HOMCNP,FSCNP-FSASTR	;ALSO SETUP FSCNP
	XWD	HOME+HOMCLP,FSCLP-FSASTR	;   AND FSCLP
FSXSTL==.-FSXSTR

;TRANSFER TABLE FOR UNIT PARAMETER BLOCKS (STRUUO(.FSDEF))

FSXUNI:	XWD	HOME+HOMHID,SU.HID
	XWD	HOME+HOMLUN,SU.LUN
	XWD	HOME+HOMGRP,SU.GRP
	XWD	HOME+HOMBPC,SU.BPC
	XWD	HOME+HOMSIC,SU.SIC
	XWD	HOME+HOMSPU,SU.SPU
	XWD	FSDES,SU.DES
FSXUNL==.-FSXUNI

;TRANSFER TABLE TO SETUP FOR STRUUO(.FSRDF)

FSXRDF:	XWD	[.FSRDF],0
	XWD	FSJOB,1
	XWD	FSPPN,2
	XWD	FSNAME,3
	XWD	FSDES,4
FSXRDL==.-FSXRDF
;SUBROUTINE TO COUNT 0 BITS
;CALL	D=AOBJ PTR TO WORDS WHOSE BITS TO COUNT
;RET+0	ALWAYS--A=NO. OF 0 BITS

ZBITS:	TDZA	A,A		;COUNT BITS IN A
ZBITS1:	AOBJP	D,CPOPJ	;BUMP WD PTR
	SETCM	B,(D)		;GET COMP. OF WORD
	JUMPE	B,ZBITS1	;SKIP WDS WITH ALL 1'S

ZBITS2:	SETCA	B,		;COUNT LEADING 0'S
	JFFO	B,ZBITS3
	ADDI	A,^D36		;MUST HAVE BEEN ALL 0'S
	JRST	ZBITS1
ZBITS3:	SETCA	B,
	ADDI	A,(C)		;ADD COUNT TO A
	LSH	B,(C)		;SHIFT OFF 1'S
	JFFO	B,ZBITS4
	JRST	ZBITS1		;FINISHED WITH THIS WORD
ZBITS4:	LSH	B,(C)
	JRST	ZBITS2
;CONSTANT STORAGE

;ARG.LIST FOR STRUUO--.FSDEF FUNCTION

FSARG:	.FSDEF
	XWD	SS.L,FSASTR	;PTR. TO STR PARAMETER BLOCK
REPTEM==FSAUNI			;PTRS. TO UNIT PARAMETER BLOCKS
				;   LEAVE ROOM FOR SPT TABLE AFTER
				;   EVERY PARAMETER BLOCK
REPEAT	MAXUNI,<
	XWD	SU.L,REPTEM
	REPTEM==REPTEM+SU.L+MAXSPT>

FSTAL:	POINT	TALSIZ,(D),TALPOS	;SPT FREE CLUSTER TALLY FIELD
FSCLA:	POINT	CLASIZ,(D),CLAPOS	;"""CLUSTER ADDRESS"""
;SUBROUTINE TO CREATE THE COMMAND-FILE UFD
;CALL	CMDSTR=CMD F/S
;	CMDPPN=CMD PPN
;	MFDPPN=MFD PPN
;RET+0	ALWAYS

MAKCMU:	JLEVC	MAKCMC
	MOVE	C,CMDSTR	;GET UFD INTERLOCK
	MOVE	D,CMDPPN
	PUSHJ	P,UFDLOK
	MOVE	B,CMDSTR	;HERE FOR LEVEL-D
	MOVE	A,CMDPPN
	PUSHJ	P,GETQUO	;GET CMD QUOTAS
	  SKIPA
	JRST	MAKCM2
	MOVEI	B,^D1000	;DEFAULTS IF NO QUOTA.SYS
	MOVEI	C,^D1000
	MOVEI	D,^D1000
MAKCM2:	MOVEI	N,777		;PRIV.
	MOVE	N1,MFDPPN
	MOVE	M,CMDSTR
	MOVE	A,CMDPPN	;RESTORE COMMAND PPN
	MOVEI	IO,W.TTY
	PUSHJ	P,UFDSET
	  JRST	MAKCM3		;CANT
	MOVE	C,CMDSTR	;RETURN UFD INTERLOCK
	MOVE	D,CMDPPN
	PUSHJ	P,UFDUNL
	POPJ	P,

MAKCM3:	MOVE	C,CMDSTR	;RETURN UFD INTERLOCK AND GIVE ERROR MSG
	MOVE	D,CMDPPN
	PUSHJ	P,UFDUNL
	JRST	ERR100


MAKCMC:	MOVE	B,CMDSTR	;HERE FOR LEVEL-C
	MOVE	A,CMDPPN
	MOVSI	D,4000		;PROTECTION
	PJRST	UFDMAK
;SUBROUTINE TO MAKE USER UFD
;CALL	A=UFD PPN
;	B=F/S NAME
;RET+0	NO UFD CREATED
;	LEVEL-D: A=0 IF BECAUSE NO QUOTA.SYS ENTRY
;	         A NOT= 0 IF OTHER REASONS
;RET+1	UFD CREATED

MAKUFD:	JLEVC	MAKUFC
	MOVEM	A,UFDPP		;HERE FOR LEVEL-D
	MOVEM	B,UFDFS
	TRNE	F,OB.UFD	;GET INTRLOCK IF DONT HAVE IT
	JRST	MAKUF2
	MOVE	C,UFDFS
	MOVE	D,UFDPP
	PUSHJ	P,UFDLOK
	MOVE	A,UFDPP
	MOVE	B,UFDFS
	PUSHJ	P,MAKUF2	;MAKE THE UFD
	  SOS	(P)		;  OR AT LEAST TRY TO
	MOVE	N,A		;AND UNLOCK UFD IF WE LOCKED IT
	MOVE	C,UFDFS
	MOVE	D,UFDPP
	PUSHJ	P,UFDUNL
	MOVE	A,N
	JRST	CPOPJ1		;WILL SKIP OR NOT DEPENDING ON MAKUF2 RETURN ABOVE


MAKUF2:	PUSHJ	P,GETQUO	;GET USERS QUOTAS
	  JRST	MAKUF3		;NO QUOTAS
	MOVE	M,UFDFS		;F/S NAME
	MOVE	A,UFDPP		;PPN
	SETZM	N		;STANDARD PRIV.
	MOVE	N1,MFDPPN	;MFD PPN
	MOVEI	IO,W.TTY	;MESSAGE WRITER
	PUSHJ	P,UFDSET
	  TLOA	A,-1		;GIVE NON-0 ERROR RETURN
	JRST	CPOPJ1
	POPJ	P,

MAKUF3:	SETZM	A		;GIVE 0 ERROR RETURN
	POPJ	P,



MAKUFC:	SETZ	D,		;LEVEL-C  STANDARD PRIV
	PJRST	UFDMAK


	U(UFDFS)
	U(UFDPP)
;SUBROUTINE TO MAKE LEVEL-C UFD
;CALL	A=UFD PPN
;	B=F/S NAME
;	D=PROT. (BITS 0-7)
;RET+0	ALWAYS

UFDMAK:	MOVEM	A,SRCBUF+EXLNAM ;SAVE UFD NAME
	MOVEM	D,SRCBUF+EXLATT
	MOVEI	A,17
	SETZ	C,
	OPEN	UFD,A
	  JSP	N,DSKERR
	MOVE A,SRCBUF+EXLNAM
	MOVSI B,(SIXBIT /UFD/)
	MOVEI C,0
	MOVE D,MFDPPN
	ENTER UFD,A
	  JSP	N,DSKERR
	OUTPUT UFD,[IOWD 1,[0]
		    0]
	CLOSE UFD,0
	SKIPN	C,SRCBUF+EXLATT
	JRST	MAKUFX
	MOVE D,MFDPPN
	RENAME UFD,A
	  JSP	N,DSKERR
MAKUFX:	RELEASE	UFD,0
	POPJ	P,
;HANDY-DANDY SUBRS GO ON AND ON

DTDCNT:	MOVEI N,0		;THIS ROUTINE COUNTS BLOCKS
	MOVNI N1,1103		;ALLOCATED TO FILE (D) IN DTDIR
	MOVE BP,[XWD 440500,DTDBYT]	;ANSWER IN N.
DTDCL:	ILDB CH,BP
	CAIN CH,0(D)
	ADDI N,1
	AOJL N1,DTDCL
	POPJ P,0

DATOUT:	IDIVI A,^D12*^D31
	IDIVI B,^D31
	MOVEI N,1(C)
	PUSHJ P,DECPR2
	MOVE M,MONTAB(B)
	PUSHJ P,SIXMS4
	PUSHJ P,DASH
	MOVEI N,^D64(A)
	PUSHJ P,DECPRT
	POPJ P,0

MONTAB:	SIXBIT /-JAN/
	SIXBIT /-FEB/
	SIXBIT /-MAR/
	SIXBIT /-APR/
	SIXBIT /-MAY/
	SIXBIT /-JUN/
	SIXBIT /-JUL/
	SIXBIT /-AUG/
	SIXBIT /-SEP/
	SIXBIT /-OCT/
	SIXBIT /-NOV/
	SIXBIT /-DEC/

MINOUT:	IDIVI A,^D60
	MOVE N,A
	PUSHJ P,DECPR2
	PUSHJ P,COLON
	MOVE N,B
	PUSHJ P,DECPR2
	POPJ P,0
;SUBRS TO GET FILE NAME FROM COMMAND

NXTFIL:	TLNE F,L.WFIL+L.WEXT
	JRST REWILD
	SETZM FILNAM
	SETZM FILEXT
	SETZM	FILDEV
	MOVE CH,TERMCH
	CAIGE CH,40
	CAIN CH,11
	SKIPA
	POPJ P,0
NXTFLP:	PUSHJ P,SSIXBR
	MOVEM CH,TERMCH
	JUMPE A,CPOPJ1
	CAIN	CH,":"
	JRST	NXTFI2
	CAMN A,[SIXBIT /*/]
	TLO F,L.WFIL
	MOVEM A,FILNAM
	CAIE CH,"."
	JRST NXTFI1
	PUSHJ P,SSIXBR
	MOVEM CH,TERMCH
	CAMN A,[SIXBIT /*/]
	TLO F,L.WEXT
	HLLZM A,FILEXT
NXTFI1:	TLNN F,L.WEXT+L.WFIL
	JRST CPOPJ1
	MOVSI N,-DTDNFI
	TLNN F,L.RCOM
	JRST WWILD
WILDL1:	SKIPN A,DTDFIL(N)
	JRST WILDN
	HLLZ B,DTDEXT(N)
	TLNN F,L.WFIL
	CAMN A,FILNAM
	SKIPA
	JRST WILDN
	TLNN F,L.WEXT
	CAMN B,FILEXT
	JRST WILD1
WILDN:	AOBJN N,WILDL1
WILDN1:	TLZ F,L.WFIL+L.WEXT
	JRST NXTFIL

WILD1:	MOVE C,DTDBYT(N)
	TROE C,1
	JRST WILDN
	MOVEM C,DTDBYT(N)
	MOVEM A,FILNAM
	MOVEM B,FILEXT
	MOVEM N,STRPTR
	JRST CPOPJ1

NXTFI2:	MOVEM	A,FILDEV
	JRST	NXTFLP
;MORE OF NEXT FILE FINDER WILD STUFF

REWILD:	TLNN F,L.RCOM
	JRST RWWILD
	MOVE N,STRPTR
	JRST WILDN

WWILD:	SKIPN	B,FILDEV
	MOVSI	B,(SIXBIT /DSK/)
	MOVEI	A,14
	MOVEI	C,RH.USR
	OPEN	USR,A
	JSP	N,DSKERR
	MOVEI A,B.USR
	MOVEM A,JOBFF
	INBUF USR,1
	MOVE A,USRPPN
	MOVSI B,(SIXBIT /UFD/)
	MOVEI C,0
	MOVE D,MFDPPN
	LOOKUP USR,A
	JRST WNOUSR

RWWILD:	PUSHJ P,R.USR
	JRST RWWEND
	MOVE C,WD
	PUSHJ P,R.USR
	JRST RWWEND
	HLLZ D,WD
	JUMPE C,WWILDN
	TLNN F,L.WFIL
	CAMN C,FILNAM
	SKIPA
	JRST WWILDN
	TLNN F,L.WEXT
	CAMN D,FILEXT
	JRST WWILD1
WWILDN:	JRST RWWILD

WWILD1:	MOVEM C,FILNAM
	MOVEM D,FILEXT
	JRST CPOPJ1

RWWEND:	RELEAS USR,0
	JRST WILDN1

WNOUSR:	MOVEI M,[ASCIZ /?CANT FIND USER'S UFD
/]
	PUSHJ P,MSGTTY
	JRST RWWEND
;SUBROUTINES TO WRITE A SPECIAL CHAR(S)
;CALL	RH(IO)=WRITER ADDRESS (OR 0)

EXCLAM:	JSP	M,MSGTTY
	ASCIZ	/!/
TAB:	JSP M,MSG
	ASCIZ /	/
COMMA:	JSP M,MSG
	ASCIZ /,/
DOT:	JSP M,MSG
	ASCIZ /./
SPACE:	JSP M,MSG
	ASCIZ / /
DASH:	JSP M,MSG
	ASCIZ /-/
COLON:	JSP M,MSG
	ASCIZ /:/
QUOTE:	JSP	M,MSG
	ASCIZ /'/
LEFTP:	JSP M,MSG
	ASCIZ /(/
RIGHTP:	JSP M,MSG
	ASCIZ /)/
CRLF:	JSP M,MSG
	ASCIZ /
/

;SUBROUTINE TO WRITE MESSAGE
;CALL	MSGTTY	TO FORCE TTY
;	MSG	TO USE WRITER WHOSE ADDR. IS RH(IO) -- IF 0 THEN IGNORE
;		M=ADDR. ASCIZ STRING

MSGTTY:	MOVEI IO,W.TTY
MSG:	HRLI M,440700
MSGL:	ILDB CH,M
	JUMPE CH,CPOPJ
	PUSHJ P,0(IO)
	JRST MSGL

CPOPJ1:	AOS 0(P)
CPOPJ:	POPJ P,0
;SUBROUTINE TO WRITE DECIMAL NUMS.
;CALL	N=NUMBER

DECPR3:	CAIGE N,^D100
	PUSHJ P,SPACE
DECPR2:	MOVEI CH,"0"
	CAIGE N,^D10
	PUSHJ P,0(IO)
DECPRT:	IDIVI N,12
	HRLM N1,0(P)
	SKIPE N
	PUSHJ P,DECPRT
	HLRZ CH,0(P)
	ADDI CH,60
	JRST 0(IO)

;SUBROUTINE TO WRITE OCTAL NUMS.
;CALL	N=NUMBER

OCTPRT:	IDIVI N,10
	HRLM N1,0(P)
	SKIPE N
	PUSHJ P,OCTPRT
	HLRZ CH,0(P)
	ADDI CH,60
	JRST 0(IO)

;SUBROUTINE TO WRITE SIXBIT THING
;CALL	SIXMS4	FOR 4 LEFT-MOST CHAR'S
;	SIXMSL	FOR ALL 6
;		M=SIXBIT THING
;		RH(IO)=WRITER ADDRESS (OR 0)

SIXMS4:	SKIPA N1,[XWD 140600,M]
SIXMSG:	MOVE N1,[XWD 600,M]
	MOVE BP,[XWD 440600,M]
SIXMSL:	ILDB CH,BP
	ADDI CH,40
	TRNN	IO,-1
	POPJ	P,
	PUSHJ P,0(IO)
	CAME BP,N1
	JRST SIXMSL
	POPJ P,0

;SUBROUTINE TO PRINT SIXBIT & IGNORE TRAILING BLANKS
SIXMSO:	LDB	CH,[POINT 6,M,5]
	ADDI	CH,40
	PUSHJ	P,(IO)
	LSH	M,6
	JUMPN	M,SIXMSO
	POPJ	P,
;SUBROUTINE TO READ OCTAL NUMBER
;CALL	SOCTIN	IGNORE LEADING TAB/BLANK
;	OCTIN	IF 1ST CHAR. ALREADY IN CH
;		RH(IO)=READER ADDRESS
;RET+0	ALWAYS WITH N=NUMBER

SOCTIN:	PUSHJ P,SSST
OCTIN:	PUSHJ	P,SST
	MOVEI N,0
OCTINL:	CAIL CH,"0"
	CAILE CH,"7"
	POPJ P,0
	ASH N,3
	ADDI N,-60(CH)
	PUSHJ P,0(IO)
	  MOVEI CH,32		;EOF
	JRST OCTINL

;SUBROUTINE TO READ DECIMAL NUMBER

SDECIN:	PUSHJ	P,SSST
DECIN:	PUSHJ	P,SST
	MOVEI	N,0
DECINL:	CAIL	CH,"0"
	CAILE	CH,"9"
	POPJ	P,0
	IMULI	N,^D10
	ADDI	N,-60(CH)
	PUSHJ	P,(IO)
	  MOVEI	CH,32	;EOF
	JRST	DECINL
;SUBROUTINE TO READ NAME AND CONVERT TO SIXBIT
;CALL	SSIXIN	TO IGNORE LEADING TAB/BLANK
;	SIXIN	IF 1ST CHAR. ALREADY IN CH
;		RH(IO)=READER ADDRESS
;RET+0	ALWAYS WITH SIXBIT NAME IN A (0 IF NO NAME)

SSIXIN:	PUSHJ P,SSST
SIXIN:	PUSHJ	P,SST
	MOVEI A,0
	MOVE BP,[XWD 440600,A]
SIXINL:	CAIL CH,"0"
	CAILE CH,"9"
	SKIPA
	JRST SIXIN1
	CAIL CH,"A"
	CAILE CH,"Z"
	POPJ	P,
SIXIN1:	TRC CH,40
	TLNE BP,770000
	IDPB CH,BP
	PUSHJ P,0(IO)
	  MOVEI CH,32		;EOF
	JRST SIXINL

;SUBROUTINE TO READ FILE NAME (INCLUDING *) AND CONVERT TO SIXBIT
;CALL	RH(IO)=READER ADDRESS
;RET+0	ALWAYS WITH NAME IN A (OR 0 IF NO NAME)

SSIXBR:	PUSHJ	P,SSIXIN
	JUMPN	A,CPOPJ	;BLANK?
	CAIE	CH,"*"		;YES--WAS IT * ?
	POPJ	P,		;NO--RETURN BLANK
	TRC	CH,40
	IDPB	CH,BP
	PUSHJ	P,(IO)
	  MOVEI	CH,32		;EOF
	POPJ	P,
;SUBROUTINE TO IGNORE BLANKS AND TABS
;CALL	SSST	TO GET NEXT CHAR
;	SST	IF NEXT CHAR ALREADY IN CH
;RET+0	ALWAYS WITH 1ST NON-BLANK/TAB CHAR OR EOF(32) IN CH

SSST:	PUSHJ P,0(IO)
	  MOVEI CH,32		;EOF
SST:	JUMPE	CH,SSST
	CAIE CH,11
	CAIN CH,40
	JRST SSST
	CAIN	CH,15		;IGNORE CR
	JRST	SSST
	CAIE	CH,CHRLIN		;"?
	POPJ	P,		;NO
	PUSHJ	P,(IO)		;YES-INGORE IT AND EAT BREAK CHAR.
	  MOVEI	CH,32
	CAIE	CH,33
	CAIG	CH,14
	JRST	SSST
	POPJ P,0
;I/O SUBRS

R.TTY:	TLZE F,L.TYO
	OUTPUT TTY,0		;OUTPUT ANY CHARS LEFT HANGING AROUND
	SOSLE RH.TTY+2
	JRST R.TOK
R.TTY1:	MOVEI	M,SLPSW		;NUMBER OF MINUTES TO SLEEP
R.TTY3:	HRRI	CH,^D60000	;WAKE AFTER 60 SECONDS	
	HRLI	CH,HIBTTL	;    OR TTY BREAK CHARACTER
	HIBER	CH,		;HIBERNATE
	  JRST	R.TTY2		;IF ERROR JUST WAIT
	TTCALL	14,		;SKIP IF SOMETHING WAS TYPED
	JRST	[SOJG M,R.TTY3	;WAIT FOR 5 MINUTES
		TTCALL	3,RPTTY	;REMIND OPR A COMMAND IS WAITING
		JRST	R.TTY1]	;LOOP TIL BREAK CHARACTER IS TYPED
R.TTY2:	INPUT TTY,0
	STATZ TTY,760000
	  POPJ	P,
R.TOK:	ILDB CH,RH.TTY+1
	JUMPE CH,R.TTY
	SOSL	RPTTYC
	IDPB	CH,RPTTYB
	CAIE CH,177		;IGNORE RUBOUT
	CAIN CH,15		;OR CR
	JRST R.TTY
	CAIL CH,175		;CHANGE 175,176 TO ALTMO
	MOVEI CH,33		;WHICH IS ALTMODE
	CAIL CH,140
	TRZ CH,40		;CHANGE LOWER CASE TO UPPER
	JRST	CPOPJ1

W.TTY:	SOSLE WH.TTY+2
	JRST W.TOK
	OUTPUT TTY,0
	STATZ TTY,760000
	  JSP	N,TTYERR
W.TOK:	IDPB CH,WH.TTY+1
	SOSL RPTTYC
	IDPB CH,RPTTYB
	TLO F,L.TYO
	CAIG CH,14
	OUTPUT TTY,0
	POPJ P,0
;I/O ROUTINES

DEFINE READER (FILE,AC)<
R.'FILE:	IFIDN <FILE>,<TTY>,<
	TLZE F,L.TYO
	OUTPUT FILE,0
>
	SOSLE RH.'FILE+2
	JRST FILE'OKR
	INPUT FILE,0
	STATZ FILE,740000
	JRST FILE'ER
	STATZ FILE,20000
	JRST FILE'EOF
FILE'OKR:	ILDB AC,RH.'FILE+1
	IFIDN <AC>,<CH>,<
	JUMPE AC,R.'FILE
	CAIE AC,177
	CAIN AC,15
	JRST R.'FILE
	CAIL AC,175
	MOVEI AC,33
	CAIL AC,140
	TRZ AC,40
>
	JRST CPOPJ1

FILE'ER:	MOVEI M,[ASCIZ /? ERROR READING FILE  STATUS = /]
	PUSHJ P,MSGTTY
	GETSTS FILE,N
	PUSHJ P,OCTPRT
	PUSHJ P,CRLF
FILE'EOF:	POPJ P,0
UU(RH.'FILE,3)
>

DEFINE WRITER (FILE,AC) <

W.'FILE:	SOSLE WH.'FILE+2
	JRST FILE'OKW
	OUTPUT FILE,0
	STATZ FILE,760000
	JRST FILE'ERW
FILE'OKW:	IDPB AC,WH.'FILE+1
	IFIDN <FILE>,<TTY>,<
	TLO F,L.TYO
	CAIG AC,15
	OUTPUT FILE,0
>
	POPJ P,0

FILE'ERW:	MOVEI M,[ASCIZ /? ERROR WRITING FILE  STATUS = /]
	PUSHJ P,MSGTTY
	GETSTS FILE,N
	PUSHJ P,OCTPRT
	PUSHJ P,CRLF
	POPJ P,0
UU(WH.'FILE,3)
>

READER (CMD,CH)
READER (CMU,WD)
READER (USR,WD)
READER (DSK,WD)
READER(DTA,WD)
WRITER (DSK,WD)
WRITER (DTA,WD)
WRITER (USR,CH)
;SUBROUTINE TO SET UP A UFD FOR USE  V001
;ARGS	A=USER'S PPN
;	B=A+1=RESERVED QUOTA
;	C=B+1=FIRST COME FIRST SERVED QUOTA
;	D=C+1=LOGGED OUT QUOTA
;;	N=PRIV.BYTE (RIGHT-JUST.)
;	N1=N+1=MFD PPN
;	M=NAME OF STR
;	IO=ADDRESS OF ROUTINE TO TYPE A CHAR
;	CH=ACCUMULATOR TO CONTAIN CHAR TO BE TYPED
;;	WD=AC USED BY R.USR
;	F=FLAG REGISTER
;	  L.WRTL=BIT IN LH OF F = 1 IF USER REQUESTS WRITE LOCK
;	  L.NCR=BIT IN LH F = 1 IF USER REQUESTS NO CREATE SET
;	  L.SIN=BIT IN LH F = 1 IF SINGLE ACCESS REQUESTED
;	  L.FRE1=AVAILABLE BIT IN LH OF F
;	  L.FRE2=AVAILABLE BIT IN LH OF F
;	P=PUSH DOWN LIST POINTER
;
;	USR=FREE I/O CHANNEL
;	US1=FREE I/O CHANNEL
;
;CALL	PUSHJ	P,UFDSET
;ERROR	DONT PROCEED (MESSAGE TYPED)
;OK	STR IS IN SEARCH LIST (WARNING MAY BE TYPED)
;
;ASSUMES SYMBOLS FOR AC'S ABOVE DEFINED, LOCATIONS CPOPJ, CPOPJ1 DEFINED
;
;USES U AND UU MACROS TO RESERVE STORAGE FOR EITHER HIGH OR LOW
;SEGMENT OPERATION.
;
;ROUTINES DEFINED HERE:
;
;MSG:	 TYPES STRING OF ASCII CHARS TO FIRST NULL
;SIXMSG:	 TYPES CONTENTS OF M AS SIXBIT CHARS
;CRLF:	 TYPES CARRIAGE RETURN LINE FEED
;OCTPRT: TYPES CONTENTS OF N AS OCTAL NUMBER
;MPOPJ:	 POP P,M FOLLWED BY POPJ P,
;;R.USR:	 READS NEXT WORD FROM CHANNEL USR INTO WD (BUFFER HEADER RH.USR, BUFFER B.USR)
;ADDSTR: ADD FILE STRUCTURE TO SEARCH LIST
;DISSTR: DELETE FILE STRUCTURE FROM SEARCH LIST

;;MNTSUB==1		;DECLARE IN CASE DISMOUNT SUBROUTINE ALSO APPEARS

US1==16	;;

RACEY==2		;VALUE OF LEVEL D FIELD IN STATES WORD FOR
			;  FOR MONITORS WHICH CONTAIN RACE COND.STUFF
;ARGUMENTS FOR EXTENDED LOOKUP, ENTER, RENAME

EXLLEN==26	;LENGTH OF ARGUMENT LIST
EXLPPN==1	;DIRECTORY NAME
EXLNAM==2	;FILE NAME
EXLEXT==3	;EXT
EXLATT==4	;PRIV. IN LH
EXLALC==11	;BLOCKS ALLOCATED FOR FILE
EXLDEV==16	;DEVICE ON WHICH FILE LOOKED UP IS
EXLSTS==17	;STATUS BITS
  RIPLOG==400000	;LH BIT IS LOGGED IN BIT
  RIPDIR==400000	;RH BIT IS DIRECTORY BIT
EXLQTR==24	;RESERVED QUOTA
EXLQTF==22	;FIRST COME, FIRST SERVED QUOTA
EXLQTO==23	;LOGGED-OUT QUOTA
EXLUSD==25	;BLOCKS USED

CHRUFB==1	;UFBTAL WORD
CHRLEN==14	;LENGTH OF DSKCHR BLOCK
OPDEF	SLEEP	[CALLI 31]
OPDEF	GETTAB	[CALLI 41]
  CNFTBL==11	;CONFIGURATION TABLE FOR GETTAB
  SEGPTR==15	;INDEX FOR SEGMENTS, JOBS

	OPDEF STRUUO [CALLI 50]

SRCFST==0	;STRUUO FUNCTION TO SET NEW SEARCH LIST
  STRJMX==9	;MAXIMUM NUMBER OF STRS PER JOB
  SRWPS==3	;WORDS PER STR ENTRY IN SEARCH LIST
ULKSTR==6	;STRUUO FUNCTION TO TEST/SET UFD INTERLOCK
UCLSTR==7	;STRUUO FUNCTION TO CLEAR UFD INTERLOCK


	OPDEF GOBSTR [CALLI 66]

GOBJOB==0	;INDEX FOR JOB NUMBER IN ARG LIST
GOBPPN==1	;INDEX FOR PPN
GOBNAM==2	;INDEX FOR STR NAME

	OPDEF PJRST [JRST]

	DEFINE UFDSEM(TEXT)<
	XLIST
	MOVEI	N1,[ASCIZ \TEXT\]
	JRST	UFDSMP
	LIST
>
	EXTERN	JOBFF

UFDSET:	MOVEM	A,UFDUPN	;SAVE USER'S PPN
	MOVEM	N,UFDPRV	;;
	MOVEM	N1,UFDMPN	;AND MFD PPN
	MOVEM	M,UFDFSN	;AND NAME OF STR
	MOVE	N,B		;N=RESERVED QUOTA
	MOVE	M,C		;M=FCFS QUOTA
	MOVE	CH,D		;CH=LOGGED OUT QUOTA
UFDSTA:	MOVEI	B,ULKSTR	;USER-MODE UFD INTERLOCK FUNCTION
	PUSHJ	P,STUFC1	;TEST/SET UFD INTERLOCK
	  JRST	STUFBS		;BUSY, SLEEP AND RETRY
	MOVE	B,UFDFSN
	MOVEI	A,14
	MOVEI	C,RH.USR
	OPEN	USR,A		;INIT THIS FILE STRUCTURE
	  JRST	UFDSE2		;HOW CAN THIS BE?
	MOVEI	A,B.USR
	MOVEM	A,JOBFF
	INBUF	USR,1		;DECLARE OUR 1 BUFFER
	PUSHJ	P,SETEXL	;SET UP SRCBUF FOR EXTENDED LOOKUP OF UFD
	SETZB	C,SRCBUF+4	;CLEAR REST OF LOOKUP BLOCK
	MOVE	A,[XWD SRCBUF+4,SRCBUF+5]
	BLT	A,SRCBUF+EXLLEN-1
	LOOKUP	USR,SRCBUF	;LOOKUP UFD
	  SKIPA	A,SRCBUF+EXLEXT	;GET ERROR CODE IN A
	JRST	UFDEX		;UFD EXISTS, LOOK AT IT
	TRNE	A,-1		;SKIP IF NO UFD
	JRST	UFDSE3		;THERE'S SOMETHING WRONG WITH THIS UFD

;HERE IF MUST CREATE A UFD

	MOVEM	N,SRCBUF+EXLQTR	;STORE RESERVED QUOTA
	MOVEM	M,SRCBUF+EXLQTF	;AND FCFS
	MOVEM	CH,SRCBUF+EXLQTO	;AND LOGGED OUT QUOTA
	MOVE	A,UFDPRV	;;AND PRIV.
	DPB	A,[POINT 9,SRCBUF+EXLATT,8]	;;
	PUSHJ	P,SETEXL	;SET UP FOR EXTENDED ENTER OF UFD
	MOVE	A,[XWD RIPLOG,RIPDIR]	;SET DIRECTORY BIT AND LOGGED IN BIT
	MOVEM	A,SRCBUF+EXLSTS
	ENTER	USR,SRCBUF	;TRY TO CREATE A UFD
	  JRST	UFDSE1		;IDENTIFY ENTER FAILURE
	SETSTS	USR,17		;SET STATUS TO DUMP MODE SO CLOSE WONT DUMP BUFS
	USETO	USR,2
	CLOSE	USR,4		;AN EMPTY UFD
	JRST	UFDOK		;ALL SET
;HERE IF UFD ALREADY EXISTS

UFDEX:	MOVE	A,SRCBUF+.RBSTS	;ALLOWED TO RENAME?
	TRNE	A,.RBNDL
	JRST	UFDOK		;NO-THATS ALL
	MOVEM	N,SRCBUF+EXLQTR	;STORE RESERVED QUOTA
	MOVEM	M,SRCBUF+EXLQTF	;AND FCFS
	MOVEM	CH,SRCBUF+EXLQTO ;AND LOGGED OUT QUOTA
	MOVSI	A,RIPLOG	;LOGGED IN BIT
	TDNN	A,SRCBUF+EXLSTS	;SKIP IF BIT ON IN UFD
	JRST	UFDEX2		;NO, CAN PROCEED
	MOVE	B,[XWD SEGPTR,CNFTBL]
	GETTAB	B,		;GET NUMBER OF JOBS
	  MOVEI	B,100		;ASSUME 64
	MOVNI	B,-1(B)
	HRLZS	B		;LH B=-NUMBER OF REAL JOBS
UFDEX1:	MOVE	A,UFDFSN
	MOVEM	A,CHRBUF+GOBNAM	;NAME OF STR
	MOVE	A,UFDUPN
	MOVEM	A,CHRBUF+GOBPPN
	MOVEI	A,1(B)		;A=NEXT JOB NUMBER
	MOVEM	A,CHRBUF+GOBJOB
	MOVEI	A,CHRBUF
	GOBSTR	A,		;SEE IF STR IS IN THAT JOB'S SEARCH LIST
	  JRST	UFDEX0		;NOT IN THIS JOBS LIST OR NOT OUR PPN
	JRST	UFDOK		;OK IS IN SOMEBODY ELSES SEARCH LIST SAME PPN
UFDEX0:	AOBJN	B,UFDEX1	;LOOP FOR ALL JOBS

;HERE TO LOOKUP ALL FILES AND RECOMPUTE RIBUSD

	SETZB	A,C
	MOVE	B,UFDFSN
	MOVEM	B,CHRBUF	;SAVE FOR DSKCHR
	OPEN	US1,A		;OPEN FILE STRUCTURE
	  JRST	UFDSE2
	SETZM	SRCBUF+EXLUSD	;CLEAR USED WORD
	MOVE	A,[XWD CHRUFB+1,CHRBUF]
	DSKCHR	A,		;GET CURRENT UFBTAL
	  JSP	A,UFDNEV
ALLK1:	PUSHJ	P,R.USR		;READ NEXT WORD OF UFD
	  JRST	UFDRER		;READ ERROR (MAY BE EOF)
	MOVEM	WD,SECBUF+EXLNAM ;;FILE NAME
	PUSHJ	P,R.USR		;READ NEXT WORD OF UFD (EXT)
	  JRST	UFDRER		;READ ERROR
	SKIPN	SECBUF+EXLNAM	;SKIP IF REAL NAME
	JRST	ALLK1		;UFD'S DO HAVE ZEROS
	HLLZM	WD,SECBUF+EXLEXT ;;STORE EXT
	SETZM	SECBUF+EXLPPN	;CLEAR PPN WORD
	MOVEI	A,EXLALC
	MOVEM	A,SECBUF	;SET NUMBER OF ARGS TO GET ALC WORD
	LOOKUP	US1,SECBUF	;LOOKUP FILE
	  JRST	ALLK1		;SOMETHING WRONG, FORGET IT
	MOVE	A,SECBUF+EXLALC ;GET BLOCKS ALLOCATED FOR THIS FILE
	ADDM	A,SRCBUF+EXLUSD ;COUNT FOR ALL FILES
	JRST	ALLK1
;HERE IF READ ERROR (MAY BE EOF)

UFDRER:	CLOSE	US1,
	GETSTS	USR,A		;A=ERROR CODE
	MOVEI	M,[ASCIZ .UFD READ ERROR, STATUS = .]
	TRNN	A,20000		;SKIP IF ERROR, NOT EOF
	JRST	UFDSE4		;TELL USER ABOUT ERROR, NO UFD
	MOVE	B,CHRBUF+CHRUFB	;PREVIOUS UFBTAL
	CAMN	B,[XWD 400000,0]
	JRST	UFDEX3
	MOVE	A,[XWD CHRUFB+1,CHRBUF]
	DSKCHR	A,		;GET NEW UFBTAL
	  JSP	A,UFDNEV
	SUB	B,CHRBUF+CHRUFB	;OLD-NEW=-DIFFERENCE FREE
	ADDM	B,SRCBUF+EXLUSD	;=DIFFERENCE ALLOCATED
	JRST	UFDEX3		;ALL SET


UFDEX2:	IORM	A,SRCBUF+EXLSTS	;MAKE SURE LOGGED IN BIT ON
UFDEX5:	LDB	A,LVDBTS
	CAIL	A,RACEY
	SETOM	SRCBUF+EXLUSD	;USE MONITOR'S COPY OF UFBTAL TO COMPUTE RIBUSD
UFDEX3:	PUSHJ	P,SETEXL	;SET UP SRCBUF FOR EXTENDED RENAME
	RENAME	USR,SRCBUF
	  SKIPA	A,SRCBUF+EXLEXT
	JRST	UFDOK

	MOVEI	M,[ASCIZ .UFD RENAME FAILURE .]
	JRST	UFDSE4

UFDSE3:	MOVEI	M,[ASCIZ .UFD LOOKUP FAILURE .]
UFDSE4:	PUSHJ	P,MSG		;IDENTIFY FAILURE
	HRRZ	N,A		;N=ERROR CODE
	PUSHJ	P,OCTPRT
	PUSHJ	P,CRLF
	JRST	UFDOK

UFDSE1:	MOVEI	M,[ASCIZ .UFD ENTER FAILURE .]
	PUSHJ	P,MSG		;IDENTIFY FAILURE
	HRRZ	N,SRCBUF+EXLEXT
	PUSHJ	P,OCTPRT
	MOVEI	M,[ASCIZ .
NO UFD CREATED
.]
	PUSHJ	P,MSG		;TELL POOR USER WE CANT MAKE A UFD
UFDOK:	;;
;HERE TO CLEAR UFD INTERLOCK

	PUSHJ	P,STUFCL	;CLEAR UFD INTERLOCK
	JSP	A,UFDNEV
	JRST	CPOPJ1		;ALL DONE

;HERE WHEN UFD INTERLOCK IS BUSY - SLEEP AND RETRY

STUFBS:	MOVEI	A,1
	SLEEP	A,		;SLEEP FOR 1 SECOND
	JRST	UFDSTA

UFDSE2:	PUSHJ	P,STUFCL
	UFDSEM <CANT OPEN>


;SUBROUTINE TO TEST/SET OR CLEAR UFD INTERLOCK
;ENTER AT STUFCL TO CLEAR
;ENTER AT STUFC1 WITH B=FUNCTION
;RETURN POPJ IF FAILED
;RETURN CPOPJ1 IF OK

STUFC1:		;;
STUFCL:	JRST	CPOPJ1	;;

;;STUFCL:	MOVEI	B,UCLSTR
;;STUFC1:	MOVE	A,[XWD 3,B]
;;	MOVE	C,UFDFSN
;;	MOVE	D,UFDUPN
;;	STRUUO	A,
;;	  POPJ	P,
;;	PJRST	CPOPJ1

;SUBROUTINE TO SET UP HEADER FOR EXTENDED LOOKUP/ENTER/RENAME OF UFD

SETEXL:	MOVEI	A,EXLLEN-1	;LENGTH OF ARG LIST
	MOVEM	A,SRCBUF
	MOVE	A,UFDUPN	;NAME IS USER'S PPN
	MOVEM	A,SRCBUF+EXLNAM
	MOVSI	A,(SIXBIT .UFD.)	;EXT IS UFD
	MOVEM	A,SRCBUF+EXLEXT
	MOVE	A,UFDMPN	;DIRECTORY IS MFD
	MOVEM	A,SRCBUF+EXLPPN
	POPJ	P,

UFDSMP:	MOVEI	CH,"?"
	PUSHJ	P,(IO)
	MOVE	M,UFDFSN
	PUSHJ	P,SIXMSG
	MOVEI	CH," "
	PUSHJ	P,(IO)
	MOVE	M,N1
	PUSHJ	P,MSG
	PJRST	CRLF
;SUBROUTINE TO CLEAR A FILE STRUCTURE FOR DISMOUNT  V001
;ARGS	A=USER'S PPN
;	B=A+1=JOB NUMBER
;	C=B+1
;	D=C+1=LOGGED OUT QUOTA (-1 TO IGNORE)

;	N1=N+1=MFD PPN
;	M=NAME OF FILE STRUCTURE
;	IO=ADDRESS OF ROUTINE TO TYPE A CHARACTER
;	CH=ACCUMULATOR TO CONTAIN CHAR TO BE TYPED
;	F=FLAG REGISTER
;	  L.FRE1=AVAILABLE BIT IN LH OF F
;	  L.FRE2=AVAILABLE BIT IN LH OF F
;	P=PUSH DOWN LIST POINTER
;
;	USR=FREE I/O CHANNEL
;
;CALL	PUSHJ	P,UFDCLR
;ERROR	DONT PROCEED A=CODE (0=CANT OPEN 1=QUOTA EXCEEDED) MESSAGE TYPED
;OK	FILE STRUCTURE REMOVED FROM JOBS SEARCH LIST (WARNING MAY BE TYPED)
;SYMBOLS FROM COMMOD

EXLLEN==26		;LENGTH OF EXTENDED LOOKUP/ENTER/RENAME ARG LIST
EXLPPN==1		;DIRECTORY NAME
EXLNAM==2		;FILE NAME
EXLEXT==3		;EXT
EXLSIZ==5		;WORDS WRITTEN
EXLSTS==17		;STATUS BITS
  RIPLOG==400000	;LH BIT=LOGGED IN BIT
EXLQTF==22		;FIRST COME FIRST SERVED QUOTA
EXLQTR==24		;RESERVED QUOTA
EXLQTO==23		;LOGGED OUT QUOTA
EXLUSD==25		;BLOCKS ALLOCATED

	OPDEF STRUUO [CALLI 50]

SRCFST==0		;FUNCTION TO SET NEW SEARCH LIST
  STRJMX==9		;MAXIMUM NUMBER OF FILE STRUCTURES IN SEARCH LIST
  SRWPS==3		;NUMBER OF WORDS PER STR ENTRY
ULKSTR==6		;FUNCTION TO SET UFD INTERLOCK
UCLSTR==7		;FUNCTION TO CLEAR UFD INTERLOCK

	OPDEF GOBSTR [CALLI 66]

GOBJOB==0		;WORD IN GOBSTR ARG LIST CONTAINING JOB NUMBER
GOBPPN==1		;INDEX FOR PPN
GOBNAM==2		;INDEX FOR STR NAME

	OPDEF DSKCHR [CALLI 45]

CHRUFB==1		;WORD IN DSKCHR BLOCK CONTAING UFBTAL
CHRLEN==14

OPDEF	SLEEP	[CALLI 31]
OPDEF	GETTAB	[CALLI 41]
  CNFTBL==11
  SEGPTR==15

UFDQEE==1		;ERROR CODE FOR QUOTA EXHAUSTED

	DEFINE	UFDSEM(TEXT) <
	XLIST
	MOVEI	N1,[ASCIZ \TEXT\]
	JRST	UFDSMP
	LIST
>
	EXTERN	JOBFF

UFDCLR:	MOVEM	A,UFDUPN	;SAVE USER'S PPN
	MOVEM	B,UFDJBN	;AND JOB NUMBER
	MOVEM	D,UFBLOQ	;SAVE LOGGED-OUT QUOTA
	MOVEM	N1,UFDMPN	;MFD PPN
	MOVEM	M,UFDFSN	;STR NAME
	MOVEI	B,ULKSTR
UFDCLA:	PUSHJ	P,STUFC1	;TEST/SET UFD INTERLOCK
	  JRST	UFDCAA		;BUSY, SLEEP AND RETRY
	MOVEI	A,14
	MOVE	B,M		;STR NAME
	MOVEI	C,RH.USR
	OPEN	USR,A		;OPEN FILE STRUCTURE
	  JSP	A,UFDNEV
	MOVEI	A,B.USR
	MOVEM	A,JOBFF
	INBUF	USR,1		;DECLARE OUR 1 BUFFER
	PUSHJ	P,SETEXL	;SET UP FOR EXTENDED LOOKUP
	LOOKUP	USR,SRCBUF
	  SKIPA	A,SRCBUF+EXLEXT	;GET ERROR CODE
	JRST	UFDCLC		;UFD EXISTS
	TRNN	A,-1		;SKIP IF UFD EXISTS, LOOKUP FAILED
	JRST	UFDCLJ		;NO UFD

;HERE IF UFD LOOKUP ERROR

	MOVEI	M,[ASCIZ .UFD LOOKUP FAILURE .]
	JRST	UFDCFA

UFDCLC:	MOVE	B,[XWD SEGPTR,CNFTBL]
	GETTAB	B,		;GET NUMBER OF JOBS IN SYSTEM
	  MOVEI	B,100		;ASSUME 64
	MOVNI	B,-1(B)		;B=-NUMBER OF REAL JOBS (NOT NULL JOB)
	HRLZS	B
UFDCCA:	MOVE	A,UFDFSN	;NAME OF FILE STRUCTURE
	MOVEM	A,CHRBUF+GOBNAM	;STORE IN GOBSTR BLOCK
	MOVE	A,UFDUPN	;USER'S PPN
	MOVEM	A,CHRBUF+GOBPPN
	MOVEI	C,1(B)		;JOB NUMBER
	MOVEM	C,CHRBUF+GOBJOB
	MOVEI	A,CHRBUF
	GOBSTR	A,		;SEE IF IN THIS JOBS SEARCH LIST
	  JRST	UFDCCB		;NO
	CAME	C,UFDJBN	;YES, SEE IF THIS JOB
	JRST	UFDCLJ		;NO, SOMEBODY ELSE COMING
UFDCCB:	AOBJN	B,UFDCCA	;NOT IN THAT JOBS SEARCH LIST

	MOVE	A,UFDFSN
	MOVEM	A,CHRBUF
	MOVE	A,[XWD CHRUFB+1,CHRBUF]
	DSKCHR	A,		;GET CURRENT UFBTAL
	  JSP	A,UFDNEV
	MOVE	B,SRCBUF+EXLQTO	;USE UFD QUOTA
	SKIPGE	UFBLOQ		; IF NONE IN QUOTA.SYS OR AUXACC.SYS
	MOVEM	B,UFBLOQ	;
	MOVE	B,CHRBUF+CHRUFB
	CAMN	B,[XWD 400000,0]
	JRST	UFDCCC		;IGNORE QUOTA TEST
	MOVE	A,SRCBUF+EXLQTF	;FCFS QUOTA

REPEAT 0,<ADD	A,SRCBUF+EXLQTR	;RESERVED QUOTA WHEM IMPLEMENTED>

	SUB	A,B	;QUOTA IN-FREE=USED
	SUB	A,UFBLOQ	;-QUOTA OUT=BLOCKS OVER QUOTA
	JUMPG	A,UFDCLM	;JUMP IF OVER QUOTA

;HERE TO SEE IF UFD EMPTY

UFDCCC:	MOVE	B,SRCBUF+.RBSTS	;'NO DELETE/RENAME' BIT?
	TLNE	B,.RBNDL
	JRST	UFDCLJ		;YES-NO MORE TO DO
	SKIPN	B,SRCBUF+EXLSIZ	;WORDS WRITTEN IN UFD
	JRST	UFDCLI		;NO WORDS WRITTEN - DELETE UFD
UFDCLD:	PUSHJ	P,R.USR		;READ NEXT WORD OF UFD
	  JRST	UFDCDA		;JUMP IF ERROR OR EOF
	JUMPN	WD,UFDCLF	;JUMP IF NON-EMPTY ENTRY IN UFD
	SOJG	B,UFDCLD	;STILL EMPTY SO FAR, LOOP FOR WORDS WRITTEN

	JRST	UFDCLI		;NO NON-ZERO ENTRIES, DELETE UFD

UFDCDA:	GETSTS	USR,N
	TRNE	N,20000		;SKIP IF EOF
	JRST	UFDCLF		;EOF
	MOVEI	M,[ASCIZ .UFD READ ERROR, STATUS = .]
	PUSHJ	P,MSG
	PUSHJ	P,OCTPRT
	PUSHJ	P,CRLF
UFDCLF:	MOVSI	A,RIPLOG	;LOGGED IN BIT
	ANDCAM	A,SRCBUF+EXLSTS	;CLEAR IN RENAME ARG LIST
	LDB	A,LVDBTS
	CAIL	A,RACEY
	SETOM	SRCBUF+EXLUSD	;REQUEST MONITOR TO COMPUTE RIBUSD
	PUSHJ	P,SETEXL	;SET UP FOR EXTENDED RENAME
	RENAME	USR,SRCBUF	;EXTENDED RENAME
	  SKIPA	A,SRCBUF+EXLEXT
	JRST	UFDCLJ
	MOVEI	M,[ASCIZ/? UFD RENAME FAILURE/]
UFDCFA:	PUSHJ	P,MSG
	HRRZ	N,A
	PUSHJ	P,OCTPRT	;PRINT ERROR CODE
	PUSHJ	P,CRLF
	JRST	UFDCLJ		;GIVE UP
UFDCLI:	SETZB	A,B
	SETZB	C,D
	RENAME	USR,A		;DELETE UFD
	  JSP	A,UFDNEV

UFDCLJ:
;;	PUSHJ	P,DISSTR	;TAKE STR OUT OF JOB'S SEARCH LIST
	PUSHJ	P,STUFCL	;CLEAR UFD INTERLOCK
	  JRST	CPOPJ1
	JRST	CPOPJ1		;EVERYBODY HAPPY
UFDCLM:	MOVEI	M,[ASCIZ .EXCEED LOGGED OUT QUOTA .]
	PUSHJ	P,MSG
	MOVE	N,UFBLOQ
	PUSHJ	P,DECPRT
	MOVEI	M,[ASCIZ . BY .]
	PUSHJ	P,MSG
	MOVE	N,A
	PUSHJ	P,DECPRT
	MOVEI	M,[ASCIZ . BLOCKS
.]
	MOVEI	A,UFDQEE
	PJRST	MSG

UFDCAA:	MOVEI	A,1
	SLEEP	A,
	JRST	UFDCLA


UFDNEV:	MOVE	N,A		;HERE ON IMPOSSIBLE ERROR
	PJRST	NEVMSG
LVDBTS:	POINT 3,STATES,9
UU(CHRBUF,CHRLEN)
UU(SRCBUF,EXLLEN)
UU(SECBUF,EXLALC+1)
U(UFDMPN)
U(UFDPRV)	;;
U(UFDUPN)
U(UFDFSN)
U(UFDJBN)
U(UFBLOQ)
MONHLP:	ASCIZ/CAR.RET. USE SUGGESTED UNIT
DIGIT    USE UNIT 'DIGIT'
/

FILHLP==MONHLP

OPKHLP:	ASCIZ/CAR.RET. USE SUGGESTED DRIVE
NAME     USE DRIVE 'NAME'
/
;MACRO FOR SWITCH TABLES

DEFINE	SWITAB	(NAME)<
DEFINE	NAM	(A,B)<
SIXBIT	/A/>
MACT1=.
NAMES
EXP	0
DEFINE	NAM	(A,B)<
EXP	B>
MACT2=.
NAMES
NAME:	XWD	MACT2,MACT1>

;MOUNT SWITCHES

DEFINE	NAMES<
NAM	HELP  ,MOSH
NAM	UWLOCK,MOSUWL
NAM	URONLY,MOSURO
NAM	UWENAB,MOSUWE
NAM	WENABL,MOSWE
NAM	WLOCK ,MOSWL
NAM	RONLY ,MOSRO
NAM	MULTI ,MOSM
NAM	SINGLE,MOSS
NAM	NOSEAR,MOSNOS
NAM	VID   ,MOSVID>

SWITAB(MOSWIT)
MOSH:	MOVEI	M,MOHELP
	PUSHJ	P,MSGTTY
	POPJ	P,

MOSUWL:	TRO	F,SB.UWL
	TRZ	F,SB.UWE
	JRST	CPOPJ1

MOSURO==MOSUWL

MOSUWE:	TRO	F,SB.UWE
	TRZ	F,SB.UWL
	JRST	CPOPJ1

MOSWE:	TRO	F,SB.WE
	TRZ	F,SB.WL
	JRST	CPOPJ1

MOSWL:	TRO	F,SB.WL
	TRZ	F,SB.WE
	JRST	CPOPJ1

MOSRO==MOSWL

MOSM:	TRO	F,SB.M
	TRZ	F,SB.S
	JRST	CPOPJ1

MOSS:	TRO	F,SB.S
	TRZ	F,SB.M
	JRST	CPOPJ1

MOSNOS:	TRO	F,SB.NOS
	JRST	CPOPJ1

MOSVID==VIDIN
MOHELP:	ASCIZ\
(*=DEFAULT)
/WENABL *WRITE ENABLE
/WLOCK   WRITE LOCK
/RONLY   READ ONLY = /WLOCK
/MULTI  *MULTI ACCESS
/SINGLE  SINGLE ACCESS
/UWENAB *UNIVERSAL WRITE ENABLE
/UWLOCK  UNIVERSAL WRITE LOCK
/URONLY  =/UWLOCK
/NOSEARCH DONT SEARCH STRLST.SYS
\
;DISMOUNT SWITCHES

DEFINE	NAMES<
NAM	REMOVE,DMSR
NAM	VID   ,DMSVID>

SWITAB(DISWIT)


DMSR:	TRO	F,SB.R
	JRST	CPOPJ1

DMSVID==VIDIN
;'NO SWITCHES' SWITCHES

DEFINE NAMES<
NAM	HELP,NOSH>

SWITAB	(NOSWIT)

NOSH:	MOVEI	M,[ASCIZ/NO SWITCHES
/]
	PJRST	MSGTTY

;OPRARG SWITCHES

DEFINE	NAMES<
NAM	CANCEL,OPACAN
NAM	DEFER ,OPADEF
NAM	START ,OPASTA
NAM	STOP  ,OPASTO
NAM	HELP  ,OPAHEL
NAM	WHAT  ,OPAWHT>

SWITAB	(OPSWIT)
OPADEF:	PUSHJ	P,DEFERQ
	  POPJ	P,
OPACAN:	TLO	F,L.OCAN
OPACA2:	SETZM	A
	JRST	CPOPJ1

DEFERQ:	CAIE	CH,":"
	JRST	OPRDF2
	PUSHJ	P,SDECIN	;GET NUMBER OF MINS
	JUMPN	N,NOTYET	;WILL POPJ TO CALLER
OPRDF2:	TRO	F,OB.WFI	;WAIT FOR INPUT THEN TRY CMD FILE AGAIN
	SETZM	CMDNAM		;DONT DELETE COMMAND FILE
	JRST	CPOPJ1
OPAHEL:	PUSH	P,CH
	SKIPE	M,OPRAH		;TYPE CALLERS HELP MSG FIRST
	PUSHJ	P,MSGTTY
	MOVEI	M,OPAHMS	;THEN SWITCHES
	PUSHJ	P,MSGTTY
OPAHE2:	MOVEI	A,2
	POP	P,CH
	JRST	CPOPJ1

OPASTA:	TLZA	F,L.STOP
OPASTO:	TLO	F,L.STOP
	PUSHJ	P,SETMOD
	  POPJ	P,
	JRST	OPACA2

	;/WHAT -- REPEAT THE CURRENT REQUEST
OPAWHT:	TTCALL	3,RPTTY
	MOVEI	A,2
	JRST	CPOPJ1

OPAHMS:	ASCIZ*/CANCEL  CANCEL THIS COMMAND
/DEFER:N DEFER COMMAND FOR N MINUTES
/START:X START PROCESSING X REQUESTS
/STOP:X  STOP PROCESSING X REQUESTS
         X=ALL,NONE,FILE,MOUNT
/WHAT	 RETYPE THE REQUEST
*
;OPERATOR COMMANDS AND HELP MESSAGE

OPCTAB:	SIXBIT /MOUNT/
	SIXBIT /DISMOU/
	SIXBIT /REMOVE/
	SIXBIT /LOCK/
	SIXBIT /USERS/
	SIXBIT /HELP/
	SIXBIT	/START/
	SIXBIT	/STOP/
	SIXBIT	/KILL/
	SIXBIT	/WHAT/
	0			;0 FOR END OF TABLE

OPCDIS:	MOCOMT
	DICOMT
	RECOM
	LOCOM
	USCOM
	HECOM
	STACOM
	STOCOM
	KILCOM
	WHTCOM

OPCHEL:	ASCIZ\
START:X START PROCESSING X REQUESTS
STOP:X  STOP PROCESSING X REQUESTS
KILL:X  DELETE ALL PENDING X REQUESTS 
        X=ALL,NONE,FILE,MOUNT
MOUNT   MOUNT F/S
REMOVE  REMOVE F/S FROM SYSTEM
LOCK    LOCK-OUT F/S FROM FURTHER ACCESS
USERS   TYPE CURRENT USERS OF F/S
WHAT	TYPE NO COMMAND WAITING
\
;OPERATOR REPLIES TO 'PROCEED?'

OPRTAB:	SIXBIT/NO/
	SIXBIT/CANCEL/
	SIXBIT/YES/
	SIXBIT/DEFER/
	SIXBIT/HELP/
	SIXBIT/START/
	SIXBIT/STOP/
	SIXBIT/WHAT/
	0		;0  ENDS THE TABLE

OPRDIS:	OPRNO
	OPRNO
	OPRYES
	OPRDEF
	OPRHLP
	OPRSTA
	OPRSTO
	OPRWHT

OPRHEL:	ASCIZ\
CANCEL   CANCEL THIS COMMAND
NO       =CANCEL
YES      PROCEED IF POSSIBLE
START:X  START PROCESSING X REQUESTS
STOP:X   STOP PROCESSING X REQUESTS
         X=ALL,NONE,FILE,MOUNT
DEFER:N  DEFER COMMAND FOR N MINUTES
WHAT	 RETYPE THE REQUEST
\

;MODE SWITCH COMMAND ARGUMENTS (ORDER IS IMPORTANT)

MODTAB:	SIXBIT/FILE/
	SIXBIT/MOUNT/
MODALL:	SIXBIT/ALL/
	SIXBIT/NONE/
	0

MODVAL:	MODEF
	MODEM
	MODEF!MODEM
	0
MODNUM==.-MODVAL

MODNAM:
NAMFIL:	SYSFIL
NAMMNT:	SYSMNT
NAMALL:	SYSALL
NAMNON:	SYSNON
DEFINE MT (NAME,TEXT) <
NAME:	XLIST
	ASCIZ \TEXT\
	LIST>

BELMSG:	BYTE (7) 7,177,7,177,7,0
MT CMPMSG,<--DONE-->
MT DLYMSG,< DELAY WAS >
MT DRVMSG,<ON DTA>
MT FORMSG,< [>
MT FREMSG,<. FREE BLOCKS LEFT
>
MT MNTMSG,<MOUNT TAPE >
MT WRTMSG,<WRITE ENABLED >
MT WRLMSG,<WRITE LOCKED >
;FIXED DATA

FSFPPN:	XWD 1,2
MFDPPN:	XWD 1,1
PDP:	IOWD	20,PDLIST
PCRETM:	POINT 11,C,23	;CREATION TIME
PCREDA:	POINT 12,C,35	;CREATION DATE
SYSPPC==MFDPPN
SYSPPD:	XWD	1,4

;LITERALS HERE (UNDER XLIST)
XLIST
LIT
LIST

HIEND:
UU(DIRIOW,2)
U(CMDPPN)
U(CMDSTR)
U(SYSPPN)
U(CMDCDA)
U(CMDCHR)
U(CMDCTM)
U(CMDJOB)
U(CMDNAM)
U(CMDTAP)
U(CMDTTY)
U(DIRDEV)
U(DTDRIV)
U(DTNMSG)
U(FILDEV)
U(FILEXT)
U(FILNAM)
U(NOWMIN)
U(SAVC)
U(SAVD)
U(STATES)
U(STRPTR)

U(TERMCH)
U(TODAY)
U(USRPPN)

UU(PDLIST,20)

UU(DTADIR,200)
DTDBYT=DTADIR+0
DTDFIL=DTADIR+^D83
DTDEXT=DTADIR+^D105
DTDNFI=^D22
;IMPURE STORAGE

U(OURJOB)	;OUR JOB NO.
U(OURPPN)	;OUR PPN NO.
U(FSUUNM)	;NUM. DRIVES USER TYPED
U(FSTEMP)	;TEMPORARY
U(FSUPA)	;ADDRESS OF CURRENT UNIT PAR. BLOCK
U(FSLUN)	;CURRENT LOG.UNIT NUM.
U(FSUNM)	;NUM. OF UNITS IN FS.
U(FSUAOB)	;=XWD -NUM.UNITS,0   FOR AOBJ PTRS
U(DVVNAM)
FSNAME==DVVNAM		;6 BIT NAME OF FS.
U(LOGNAM)
U(DEVMOD)
VIDL==<VIDMAX+4>/5
UU(VID,VIDL)
U(VIDK)
U(FSDES)	;BITS FOR UNIDES (SING-ACCESS & WRITE PROT.)
U(FSBPU)	;BLOCKS/UNIT FOR CURRENT UNIT
U(FSCNP)	;PTR. TO RET.PTR. COUNT FIELD
U(FSCLP)	;"""ADDRESS"""
U(FSATPT)	;PTR. TO SAT-RIB PTR.S
U(FSPTAD)	;ADDR. OF CURRENT SPT WORD
U(FSTRY)	;STRTRY (NUM. ERRORRETRIES) VALUE
U(OWNPPN)	;PPN OF F/S OWNER (FROM STRLST.SYS)
FSPPN=USRPPN	;PROG PROG # OF USER REQUESTING MOUNT/DISMOUNT
FSJOB=CMDJOB	;JOB NUM. """
U(NOTDON)	;NON-ZERO IF REQUEST UNSUCESSFUL


UU(RH.TTY,3)
UU(WH.TTY,3)
UU(FSASTR,SS.L)	;STR PARAM.BLK FOR STRUUO(.FSDEF)
UU(FSAUNI,<MAXUNI*<SU.L+MAXSPT>>) ;UNI PARAM. & SPT BLKS. FOR STRUUO(.FSDEF)
UU(GOBSTA,5)		;GOBSTR ARG.LIST
FSRDFA==GOBSTA	;STRUUO(.FSRDF) ARG.LIST
UU(FSDSLA,3*MAXFSL+7)	;STRUUO(.FSDSL) ARG.LIST
UU(PDRIVE,MAXUNI)	;PHYS.DRIVE NAMES (IN LOG.UNIT ORDER)
UU(UNITID,MAXUNI)	;CORRESPONDING LIST OF PACK ID'S
UU(UNITCL,MAXUNI)	;   AND PACK CLASS
UU(UDRIVE,MAXUNI)	;USER DRIVE REQUESTS
UU(DSKCHA,DSKCHL)	;DSKCHR UUO ARG.LIST
UU(HOME,200)	;HOME BLOCK STORAGE
UU(SATRIB,200)	;SAT-RIB STORAGE
UU(SAT,200)	;SAT BLOCK STORAGE


UU(SAVEAC,20)	;SAVE AC'S ON REENTER
;I/O BUFFER AREAS

UU(B.CMU,205)
UU(B.CMD,205)
UU(B.USR,205)
UU(B.DTA,2*205)
UU(B.DSK,2*205)
UU(B.TTY,2*30)
U(RPTTYB)	;BYTE POINTER
U(RPTTYC)	;BYTE COUNT
UU(RPTTY,RPTSIZ+2)	;COPY OF TTY OUTPUT

RELOC
LOEND:	END	OMOUNT
 q r#