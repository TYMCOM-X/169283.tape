C       BOARD.FTF
        SUBROUTINE BOARD(VALID, REPEAT)
C
C       THIS IS THE BOARD FUNCTIONAL UNIT.
C
C       IT PERFORMS ALL THE PROCESSING ASSOCIATED WITH THE BOARD SPEC.
C
        EXTERNAL BDRILL, BGENER
C
        INTEGER GRPID(2), BCLIST(7), DBTEST, OUTTEST, REPEAT
        LOGICAL VALID, ULEGAL, FIRSTIM
        DATA FIRSTIM /.TRUE./
C
        COMMON /BELEMNT/ BID(2), BTYPE, BLSTPNT, BTHIS, BFLAG
        INTEGER BID, BTYPE, BLSTPNT, BTHIS
        LOGICAL BFLAG
C
        COMMON /BDISCR/ BDISCR(7), BDLAST, BDNEXT, BDTHIS, BDFLAG
        INTEGER BDISCR, BDLAST, BDNEXT, BDTHIS
        LOGICAL BDFLAG
C
        COMMON /TITLE/ TITLE(16), MODIFY(2), NEWMOD, MODFLG, WRITEIT,
     1  XMIN, XMAX, YMIN, YMAX, PICFRAM
        INTEGER TITLE
        LOGICAL MODFLG, NEWMOD, WRITEIT, PICFRAM
C
        COMMON /WITNESS/ WITNESS(9)
        INTEGER WITNESS
C
        COMMON /DTABASE/ DTABASE(9)
        INTEGER DTABASE
C
        COMMON /CPGLOB/ KURSOR, LINSIZ, NATCH, INLINE(270), ISTTY,
     1  HUSH, UNCOLA, IPROMP, IDFILE(5)
        LOGICAL ISTTY, HUSH, UNCOLA
C
        COMMON /FILES/ FILES(7, 8), FTEMP1(7), FTEMP2(7)
        INTEGER FTEMP1, FTEMP2
C
C       BOARD USES THE FILES FTEMP1 AND FTEMP2 FOR TEMPORARY STORAGE
C       FTEMP1 IS USED FOR BOARD ELEMENT DESCRIPTORS
C       FTEMP2 IS USED FOR THE INDIVIDUAL ELEMENT DESCRIPTIONS
C
C       EXIT IF THIS IS A VALIDITY CHECK
        IF (.NOT. VALID) GO TO 100
        IF (REPEAT .EQ. 0) RETURN
        CALL WCLOSE(FTEMP1(1) )
        CALL WCLOSE(FTEMP2(1) )
        FIRSTIM = .TRUE.
        RETURN
C
C       SET UP THE TEMP FILES
  100   IF (.NOT. FIRSTIM) GO TO 110
        FIRSTIM = .FALSE.
        FTEMP1(2) = 4
        FTEMP1(3) = 0
        FTEMP2(2) = 9
        FTEMP2(3) = 0
        BFLAG = .FALSE.
        BDFLAG = .FALSE.
        CALL WOPEN(FTEMP1(1) )
        CALL WOPEN(FTEMP2(1) )
C
C       READ A COMMAND, DETERMINE WHAT TO DO
  110   UNCOLA = .FALSE.
C
C       GET A COMMAND, FIGURE IT OUT
  120   CALL PROMPT
        IF (.NOT. FETCHL(I) ) GO TO 120
C
C       DETERMINE IF THIS IS A VALID COMMAND
  130   I = LPARSE(9)
        GO TO (140, 120, 200, 210, 220, 300, 400, 500, 600, 700, 800,
     1  140), I + 2
C
C       UNRECOGNIZED COMMAND..GO PROCESS IT AND CONTINUE
  140   CALL GENERAL
        GO TO 130
C
C       HERE IF ERROR IN COMMAND
  150   CALL ERROR ('COMMAND SYNTAX ERROR', 'SYNTAX')
        GO TO 130
C
C       UNDEFINED BOARD ELEMENT
  160   CALL ERROR ('UNDEFINED ELEMENT', 'UNDEFINED')
        GO TO 130
C
C       PREVIOUSLY DEFINED ELEMENT
  170   CALL ERROR ('ELEMENT ALREADY DEFINED', 'MULT. DEF.')
        GO TO 130
C
C       INSUFFICIENT SPACE TO ALLOCATE FOR EXPANSION OF FILE
  180   CALL ERROR ('CORE INSUFFICIENT TO EXPAND DESCRIPTIONS',
     1          'NO CORE')
        GO TO 130
C
C       ERROR IN FILE NAME
  190   CALL ERROR ('SYNTAX ERROR IN FILE NAME', 'FILE SYNTAX')
        GO TO 130
C
C
C
C       "SOCKET" COMMAND
  200   N = 1
        ULEGAL = .FALSE.
        GO TO 230
C
C
C
C       "EDGE" COMMAND...VERIFY EXISTANCE OF "SOCKET"
  210   IF (LPARSE(10) .NE. 1) GO TO 150
        N = 2
        ULEGAL = .FALSE.
        GO TO 230
C
C
C
C       "GROUP" COMMAND...SET IT SO
  220   N = 3
        ULEGAL = .TRUE.
C
C       VERIFY "DEFINITION"
  230   IF (LPARSE(11) .NE. 1) GO TO 150
C
C       NOW GET SOCKET IDENTIFICATION
        IF (.NOT. BIDENT(GRPID(1) ) ) GO TO 150
        IF (LPARSE(43) .NE. 1) GO TO 150
C
C       WE'VE NOW GOTTEN "****DEFINITION GRPID:";  VERIFY THIS IS UNIQUE
        IF (BLOOK(GRPID(1) ) ) GO TO 170
        CALL SOPM
C
C       DEFINE A NEW ELEMENT
        CALL BPUT
        BTHIS = FTEMP1(3)+1
        FTEMP1(3) = BTHIS
        BID(1) = GRPID(1)
        BID(2) = GRPID(2)
        BTYPE = N
        BLSTPNT = 0
        ITEM = 0
        BFLAG = .TRUE.
C
C       MAKE A NEW DEFINITION ENTRY
        CALL BDPUT
C
C       START A DEFINITION
        BCLIST(1) = "211400000000
        BCLIST(2) = 0
        BCLIST(3) = 0
        BCLIST(4) = 0
        BCLIST(5) = 0
        BCLIST(6) = 0
        BCLIST(7) = 0
C
C       GET A NEW DEFINITION LINE
  240   IF (.NOT. BGETC(BCLIST(1), ULEGAL) ) GO TO 260
C
C       GOT A VALID LINE...LINK INTO LIST
        J = FTEMP2(3) + 1
        FTEMP2(3) = J
        IF (ITEM .EQ. 0) BLSTPNT = J
        IF (ITEM .NE. 0) BDNEXT = J
        IF (ITEM .NE. 0) CALL BDPUT
        BDTHIS = J
        BDLAST = ITEM
        ITEM = J
        DO 250 II = 1, 7
  250    BDISCR(II) = BCLIST(II)
        BDNEXT = 0
        BDFLAG = .TRUE.
C
C       HERE AT LINE END...TEST IF DONE
  260   IF (LPARSE(43) .NE. 1) GO TO 240
        CALL ROPM
        CALL BDPUT
        CALL BPUT
        GO TO 110
C
C
C
C       "PRINT" COMMAND
  300   IF (.NOT. BIDENT(GRPID(1) ) ) GO TO 150
        IF (.NOT. BLOOK(GRPID(1) ) ) GO TO 160
        CALL BPRINT
        GO TO 110
C
C
C
C       "EDIT" COMMAND
  400   IF (.NOT. BIDENT(GRPID(1) ) ) GO TO 150
        IF (.NOT. BLOOK(GRPID(1) ) ) GO TO 160
        CALL BEDIT
        GO TO 110
C
C
C
C       "CHANNEL" COMMAND...GET "X"/"Y", ":"
  500   J = LPARSE(44)
        IF (J .LE. 0) GO TO 150
        IF (LPARSE(43) .NE. 1) GO TO 150
        CALL BXYCHAN(J)
        GO TO 110
C
C
C
C       "SAVE" COMMAND...GET "ON"
  600   IF (LPARSE(12) .NE. 1) GO TO 150
        IF (.NOT. LOOKFN(I) ) GO TO 190
C
C       GOT "SAVE ON ***"...VERIFY FILE USAGE
        I = OUTTEST(.TRUE., .TRUE.)
        GO TO (610, 110, 130), I
C
C       ACCEPTED...SAVE THE DATA ON THE FILE
  610   CALL BSAVE
        CALL WCLOSE(WITNESS(1) )
        GO TO 110
C
C
C
C       "DRILL" COMMAND..GET "TAPE"
  700   IF (LPARSE(13) .NE. 1) GO TO 150
        IF (.NOT. LOOKFN(I) ) GO TO 190
        IF (LPARSE(8) .NE. 1) GO TO 150
        IF (.NOT. BIDENT(GRPID(1) ) ) GO TO 150
C
C       WE'VE NOW GOTTEN "DRILL TAPE *** USE GRPID"...VERIFY VALID GRPID
        IF (.NOT. BLOOK(GRPID(1) ) ) GO TO 160
C
C       VERIFY FILE USAGE
        I = OUTTEST(.TRUE., .FALSE.)
        GO TO (710, 110, 130), I
C
C       ALL READY TO GO...ALLOCATE SPACE AND EXPAND IT
  710   CALL DYNARY(I, BDRILL, 4*FTEMP1(3), 0)
        IF (.NOT. I) GO TO 180
        GO TO 110
C
C
C
C       "GENERATE" COMMAND
  800   IF (.NOT. LOOKFN(I) ) GO TO 190
C
C       DATA-BASE FILE NAME ACCEPTED
        IF (LPARSE(8) .NE. 1) GO TO 150
        IF (.NOT. BIDENT(GRPID(1) ) ) GO TO 150
C
C       WE'VE NOW GOTTEN "GENERATE *** USE GRPID"...VERIFY VALID GRPID
        IF (.NOT. BLOOK(GRPID(1) ) ) GO TO 160
C
C       VALIDATE FILE NAME
        I = DBTEST(1)
        GO TO (810, 110, 130), I
C
C       ALL READY TO GO...ALLOCATE SPACE AND EXPAND DATA-BASE
  810   CALL DYNARY(I, BGENER, 7*FTEMP1(3), 0)
        IF (.NOT. I) GO TO 180
        GO TO 110
        END
        LOGICAL FUNCTION BGETC(BCLIST, ULEGAL)
C
C       GET ONE COMPLETE BOARD CLAUSE
C
        INTEGER BCLIST(7), TLIST(7), ID(2)
        LOGICAL FID, FDRILL, FBUSS, FUSING, FX, FY, ULEGAL
C
        COMMON /OWNPRM/ PRMPCP, UNPROMP, JPROM
        LOGICAL PRMPCP, UNPROMP
C
        COMMON /CPGLOB/ KURSOR
C
C       SET UP APPROPRIATE PARAMETERS
        BGETC = .TRUE.
        FID = .FALSE.
        FDRILL = .FALSE.
        FBUSS = .FALSE.
        FUSING = .FALSE.
        FX = .FALSE.
        FY = .FALSE.
        DO 100 I = 1, 5
  100   TLIST(I) = BCLIST(I)
        TLIST(6) = 0
        TLIST(7) = 0
C
C       DETERMINE IF LAST ID WAS "DRILL"
        IF (BCLIST(1) .EQ. 5HDRILL) FDRILL = .TRUE.
        IF (FDRILL) GO TO 110
C
C       HERE IF LAST ID WAS NOT DRILL...INCREMENT LAST CHAR
        CALL BUMPIT(TLIST(1) )
C
C       CLEAR ID, PARSE THE INPUT LINE
  110   ID(1) = 0
        ID(2) = 0
        N = KURSOR
        I = LPARSE(34)
        GO TO (120, 150, 160, 170, 190, 220, 230, 240, 260, 280, 290,
     1  120), I+2
C
C       NOT VALID KEYWORD...TEST IF LEGAL X-VALUE
  120   IF (.NOT. FX) GO TO 250
C
C       ERROR IN INPUT
  130   CALL ERROR ('INVALID CLAUSE SYNTAX', 'BAD CLAUSE')
  135   BGETC = .FALSE.
        RETURN
C
C       MULTIPLE USE OF ATTRIBUTE
  140   CALL ERROR ('MULTIPLE DEFINED CLAUSE ATTRIBUTE','MULT. DEF.')
        GO TO 110
C
C       LINE EMPTY..GET ANOTHER
  150   UNPROMP = .FALSE.
        CALL PROMPT
        IF (FETCHL(I) ) 110, 150
C
C       GOT "
  160   I = 1H"
        GO TO 180
C
C       GOT '
  170   I = 1H'
C
C       GET THE ID
  180   IF (.NOT. PACK(ID(1), 9, 0) ) GO TO 130
        IF (NOWCH(8, KANDO) .NE. I) GO TO 130
        CALL NEXTCH(8, KANDO)
        TLIST(1) = 0
        TLIST(2) = 0
        J = 1
        CALL BUFSTR(TLIST(1), J, I )
        CALL BUFSTR(TLIST(1), J, ID(1) )
        IF (J .GT. 11) GO TO 130
        FDRILL = .FALSE.
        GO TO 200
C
C       GOT "DRILL"
  190   TLIST(1) = 5HDRILL
        TLIST(2) = 0
        FDRILL = .TRUE.
C
C       CLEAN UP ON IDENTIFICATIONS
  200   IF (FID) GO TO 130
        FID = .TRUE.
C
C       SKIP ANY TRAILING ","
  210   CALL LPARSE(42)
        GO TO 110
C
C       GOT "BUSSED"
  220   IF (ULEGAL .OR. FBUSS .OR. FUSING) GO TO 130
        IF (LPARSE(45) .NE. 1) GO TO 130
        IF (.NOT. SIGSTR(ID(1) ) ) GO TO 130
        IF (LPARSE(45) .NE. 1) GO TO 130
        FBUSS = .TRUE.
        TLIST(6) = ID(1)
        TLIST(7) = ID(2)
        GO TO 210
C
C       GOT "USING"
  230   IF (.NOT. ULEGAL) GO TO 130
        IF (FBUSS .OR. FUSING) GO TO 140
        IF (.NOT. BIDENT(ID(1) ) ) GO TO 130
        FUSING = .TRUE.
        TLIST(6) = ID(1)
        TLIST(7) = ID(2)
        GO TO 210
C
C       GOT "X"
  240   IF (FX) GO TO 140
C
C       SKIP "="
        CALL LPARSE(35)
  250   IF (.NOT. GETREAL(TLIST(3) ) ) GO TO 135
        FX = .TRUE.
        IF (FY) GO TO 210
        IF (LPARSE(42) .NE. 1) GO TO 110
        I = LOOKRL(N)
        IF (I .EQ. 1) GO TO 110
        IF (I .EQ. 4) GO TO 110
        GO TO 270
C
C       GOT "Y"
  260   IF (FY) GO TO 140
        CALL LPARSE(35)
        IF (.NOT. GETREAL(N) ) GO TO 135
  270   TLIST(4) = N
        FY = .TRUE.
        GO TO 210
C
C       GOT ":".....BACK UP CURSOR FOR MAIN PROGRAM TO LOOK AT
  280   KURSOR = N
C
C       GOT ";"
C       VERIFY USING IF USING LEGAL
  290   IF (ULEGAL .AND. .NOT. (FDRILL .OR. FUSING) ) GO TO 130
        DO 300 I = 1, 7
  300   BCLIST(I) = TLIST(I)
        BCLIST(5) = FBUSS
        RETURN
        END
        LOGICAL FUNCTION BIDENT(ID)
C
C       THIS ROUTINE GETS A BOARD ELEMENT IDENTIFIER
C
        DIMENSION ID(2)
C
C       INITIALIZE THE DATA, GET THE STRING
        ID(1) = 0
        ID(2) = 0
        BIDENT = PACK(ID(1), 9, 0)
        RETURN
        END
        SUBROUTINE BPUT
C
C       THIS ROUTINE WRITES OUT THE ELEMENT DESCRIPTION IF NECESSARY
C
C
        COMMON /BELEMNT/ BID(2), BTYPE, BLSTPNT, BTHIS, BFLAG
        INTEGER BID, BTYPE, BLSTPNT, BTHIS
        LOGICAL BFLAG
C
        COMMON /FILES/ FILES(7, 8), FTEMP1(7), FTEMP2(7)
        INTEGER FTEMP1, FTEMP2
C
C       WRITE IT OUT IF NECESSARY
        IF (BFLAG) WRITE (FTEMP1(1) # BTHIS) BID, BTYPE, BLSTPNT
        BFLAG = .FALSE.
        RETURN
        END
        SUBROUTINE BGET(N)
C
C       THIS ROUTINE GETS IN ELEMENT N IF NECESSARY
C
        COMMON /BELEMNT/ BID(2), BTYPE, BLSTPNT, BTHIS, BFLAG
        INTEGER BID, BTYPE, BLSTPNT, BTHIS
        LOGICAL BFLAG
C
        COMMON /FILES/ FILES(7, 8), FTEMP1(7), FTEMP2(7)
        INTEGER FTEMP1, FTEMP2
C
C       DETERMINE IF ALREADY HAVE IT
        IF (N .EQ. BTHIS) RETURN
C
C       DETERMINE IF MUST SAVE OLD
        IF (BFLAG) CALL BPUT
C
C       READ NEW DESCRIPTION
        READ (FTEMP1(1) # N) BID, BTYPE, BLSTPNT
        BTHIS = N
        RETURN
        END
        SUBROUTINE BDPUT
C
C       THIS ROUTINE WRITES OUT THE CURRENT DISCRIPTION IF NECESSARY
C
        COMMON /BDISCR/ BDISCR(7), BDLAST, BDNEXT, BDTHIS, BDFLAG
        INTEGER BDISCR, BDLAST, BDNEXT, BDTHIS
        LOGICAL BDFLAG
C
        COMMON /FILES/ FILES(7, 8), FTEMP1(7), FTEMP2(7)
        INTEGER FTEMP1, FTEMP2
C
C       WRITE IT OUT IF NECESSARY
        IF (BDFLAG) WRITE (FTEMP2(1) # BDTHIS) BDISCR, BDLAST, BDNEXT
        BDFLAG = .FALSE.
        RETURN
        END
        SUBROUTINE BDGET(N)
C
C       THIS ROUTINE GETS IN BLOCK N IF NECESSARY
C
        COMMON /BDISCR/ BDISCR(7), BDLAST, BDNEXT, BDTHIS, BDFLAG
        INTEGER BDISCR, BDLAST, BDNEXT, BDTHIS
        LOGICAL BDFLAG
C
        COMMON /FILES/ FILES(7, 8), FTEMP1(7), FTEMP2(7)
        INTEGER FTEMP1, FTEMP2
C
C       DETERMINE IF NECESSARY TO DO ANYTHING
        IF (N .EQ. BDTHIS) RETURN
C
C       DETERMINE IF NECESSARY TO SAVE OLD
        IF (BDFLAG) CALL BDPUT
C
C       NOW GET IN THE NEW STUFF
        READ (FTEMP2(1) # N) BDISCR, BDLAST, BDNEXT
        BDTHIS = N
        RETURN
        END
        LOGICAL FUNCTION BLOOK(ID)
C
C       THIS ROUTINE LOOKS UP ID IN TEMP FILE 1, RETURNS .TRUE. IF THERE
C
        DIMENSION ID(2)
C
        COMMON /BELEMNT/ BID(2), BTYPE, BLSTPNT, BTHIS, BFLAG
        INTEGER BID, BTYPE, BLSTPNT, BTHIS
        LOGICAL BFLAG
C
        COMMON /FILES/ FILES(7, 8), FTEMP1(7), FTEMP2(7)
        INTEGER FTEMP1, FTEMP2
C
C       FIRST DETERMINE IF THERE IS ANYTHING IN THE FILE, RETURN .FALSE.
C       IF NOT
        BLOOK = .FALSE.
        J = FTEMP1(3)
        IF (J .LE. 0) RETURN
C
C       FILE IS NOT EMPTY...SEARCH FOR IT
        DO 100 I = 1, J
         CALL BGET(I)
         IF (BID(1) .NE. ID(1) ) GO TO 100
         IF (BID(2) .NE. ID(2) ) GO TO 100
C
C       GOT MATCH....RETURN
         BLOOK = .TRUE.
         RETURN
C
C       END OF LOOP
  100    CONTINUE
C
C       NOT THERE....RETURN
        RETURN
        END
        SUBROUTINE BICL
C
C       THIS ROUTINE OUTPUTS THE CURRENT BOARD.ID.CLAUSE INTO
C       INLINE
C
        COMMON /BDISCR/ BDID(2), BDX, BDY, FLAGUB, REF(2), BDLAST,
     1  BDNEXT, BDTHIS, BDFLAG
        INTEGER BDID, REF, BDLAST, BDNEXT, BDTHIS
        LOGICAL FLAGUB, BDFLAG
C
C       OUTPUT LEADING BLANK
        CALL BUFOUT ("200000000000)
C
C       MOVE THE ID
        CALL BUFOUT(BDID(1) )
        IF (BDID(1) .EQ. 'DRILL' ) RETURN
        I = BDID(1) .AND. "774000000000
        CALL BUFOUT(I)
        RETURN
        END
        SUBROUTINE BXCL
C
C       THIS ROUTINE OUTPUTS THE CURRENT BOARD.X.CLAUSE INTO INLINE
C
        COMMON /BDISCR/ BDID(2), BDX, BDY, FLAGUB, REF(2), BDLAST,
     1  BDNEXT, BDTHIS, BDFLAG
        INTEGER BDID, REF, BDLAST, BDNEXT, BDTHIS
        LOGICAL FLAGUB, BDFLAG
C
        DIMENSION ID(3)
C
    1   FORMAT ('X='F13.3)
C
C       FIRST OUTPUT A BLANK
        CALL BUFOUT ("200000000000)
C
C       NOW ENCODE THE VALUE
        ENCODE (15, 1, ID(1) ), BDX
        CALL RTRUNC(15, ID(1) )
        CALL BUFOUT(ID(1) )
        RETURN
        END
        SUBROUTINE BYCL
C
C       THIS ROUTINE OUTPUTS THE CURRENT BOARD.Y.CLAUSE INTO INLINE
C
        COMMON /BDISCR/ BDID(2), BDX, BDY, FLAGUB, REF(2), BDLAST,
     1  BDNEXT, BDTHIS, BDFLAG
        INTEGER BDID, REF, BDLAST, BDNEXT, BDTHIS
        LOGICAL FLAGUB, BDFLAG
C
        DIMENSION ID(3)
C
    1   FORMAT ('Y='F13.3)
C
C       FIRST OUTPUT A BLANK
        CALL BUFOUT ("200000000000)
C
C       NOW ENCODE THE VALUE
        ENCODE (15, 1, ID(1) ), BDY
        CALL RTRUNC(15, ID(1) )
        CALL BUFOUT(ID(1) )
        RETURN
        END
        LOGICAL FUNCTION BUBCL(NULL)
C
C       THIS ROUTINE OUTPUTS THE "BUSSED"/"USING".CLAUSE INTO INLINE
C       RETURNS FALSE IF IT HAD NOTHING TO DO
C
        COMMON /BDISCR/ BDID(2), BDX, BDY, FLAGUB, REF(2), BDLAST,
     1  BDNEXT, BDTHIS, BDFLAG
        INTEGER BDID, REF, BDLAST, BDNEXT, BDTHIS
        LOGICAL FLAGUB, BDFLAG
C
C       ASSUME NOTHING TO DO, TEST IF SO
        BUBCL = .FALSE.
        IF (REF(1) .EQ. 0) RETURN
        BUBCL = .TRUE.
C
C       DETERMINE IF BUSSED
        IF (.NOT. FLAGUB) GO TO 100
C
C       BUSSED...TAKE CARE OF IT
        CALL BUFOUT(' BUSSED  "')
        CALL BUFOUT(REF(1) )
        CALL BUFOUT("210000000000)
        RETURN
C
C       USING...DO IT
  100   CALL BUFOUT (' USE ')
        CALL BUFOUT(REF(1) )
        RETURN
        END
        SUBROUTINE BCL
C
C       THIS ROUTINE OUTPUTS THE ENTIRE CURRENT CLAUSE TO INLINE
C
C       BLANK OUT, THEN DO IT
        CALL BLANK
        CALL BICL
        CALL BXCL
        CALL BYCL
        CALL BUBCL(NULL)
        RETURN
        END
        SUBROUTINE BHEADER
C
C       THIS ROUTINE OUTPUTS THE ELEMENT HEADER INTO INLINE
C
C
        COMMON /BELEMNT/ BID(2), BTYPE, BLSTPNT, BTHIS, BFLAG
        INTEGER BID, BTYPE, BLSTPNT, BTHIS
        LOGICAL BFLAG
C
C       FIRST DETERMINE THE TYPE OF ELEMENT
        CALL BLANK
        GO TO (100, 110, 120), BTYPE
C
C       SOCKET DEFINITION
  100   CALL BUFOUT(' SOCKET DEFINITION')
        GO TO 130
C
C       EDGE SOCKET DEFINITION
  110   CALL BUFOUT(' EDGE SOCKET DEFINITION')
        GO TO 130
C
C       GROUP DEFINITION
  120   CALL BUFOUT(' GROUP DEFINITION')
C
C       NOW OUTPUT ID, ":"
  130   CALL BUFOUT(BID(1) )
        CALL BUFOUT(':')
        RETURN
        END
        SUBROUTINE BPRINT
C
C       THIS ROUTINE PRINTS OUT THE ENTIRE CURRENT BOARD ELEMENT
C
        COMMON /BELEMNT/ BID(2), BTYPE, BLSTPNT, BTHIS, BFLAG
        INTEGER BID, BTYPE, BLSTPNT, BTHIS
        LOGICAL BFLAG
C
        COMMON /BDISCR/ BDID(2), BDX, BDY, FLAGUB, REF(2), BDLAST,
     1  BDNEXT, BDTHIS, BDFLAG
        INTEGER BDID, REF, BDLAST, BDNEXT, BDTHIS
        LOGICAL FLAGUB, BDFLAG
C
C       OUTPUT THE HEADER FIRST
        CALL BHEADER
        CALL TYPE
C
C       GET THE FIRST ELEMENT OF THE LIST
        I = BLSTPNT
        IF (I .EQ. 0) GO TO 110
C
C       GET THE NEXT ELEMENT
  100   CALL BDGET(I)
        I = BDNEXT
        CALL BCL
        IF (I .EQ. 0) GO TO 110
        CALL BUFOUT(' ;')
        CALL TYPE
        GO TO 100
C
C       LAST ONE...SET IT UP AND DO IT
  110   CALL BUFOUT(' :')
        CALL TYPE
        CALL TYPE
        RETURN
        END
        SUBROUTINE BEDIT
C
C       TOUTINE PERFORMS THE BOARD EDIT FUNCTION
C
C
        COMMON /OWNPRM/ PRMPCP, UNPROMP, JPROM
        LOGICAL PRMPCP, UNPROMP
C
        COMMON /FILES/ FILES(7, 8), BFILE(7), BDFILE(7)
        INTEGER BFILE, BDFILE
C
        COMMON /BELEMNT/ BID(2), BTYPE, BLSTPNT, BTHIS, BFLAG
        INTEGER BID, BTYPE, BLSTPNT, BTHIS
        LOGICAL BFLAG
C
        COMMON /BDISCR/ BDID(2), BDX, BDY, FLAGUB, REF(2), BDLAST,
     1  BDNEXT, BDTHIS, BDFLAG
        INTEGER BDID, REF, BDLAST, BDNEXT, BDTHIS
        LOGICAL FLAGUB, BDFLAG
C
        INTEGER ID(7)
        LOGICAL ULEGAL, DELETE
C
    1   FORMAT( ' SOCKET DEFINITION ' $ )
    2   FORMAT( ' EDGE SOCKET DEFINITION ' $ )
    3   FORMAT( 'GROUP DEFINITION ' $ )
    4   FORMAT( ' DO YOU WISH TO APPEND ANY DEFINITIONS? :')
    5   FORMAT(' ERROR IN ELEMENT INPUT...TRY AGAIN'//)
    6   FORMAT (1X, 2A5, A1, ' OK?: ' $ )
    7   FORMAT (' X =',F10.3,' OK?: ' $ )
    8   FORMAT (' Y =',F10.3,' OK?: ' $ )
    9   FORMAT (' USING ', 2A5, ' OK?: ' $ )
   10   FORMAT (' BUSSED "', 2A5, '" OK?: ' $ )
C
C       OUTPUT THE HEADER, DETERMINE IF TO CHANGE IT
        J = BTYPE
  100   CALL BLANK
        CALL BHEADER
        CALL TYPE
        I = IEDIT(.FALSE.)
        GO TO (240, 110), I
C
C       MUST CHANGE IT
  110   GO TO (120, 130, 140), BTYPE
C
C       SOCKET DEFINITION
  120   TYPE 1
        GO TO 150
C
C       EDGE SOCKET DEFINITION
  130   TYPE 2
        GO TO 150
C
C       GROUP DEFINITION
  140   TYPE 3
C
C       DETERMINE IF TO CHANGE THIS CLAUSE
  150   IF (.NOT. FETCHL(I) ) GO TO 200
C
C       DETERMINE HOW TO CHANGE IT
  160   I = LPARSE(9)
        IF (I .GT. 3) GO TO 170
        GO TO (170, 200, 190, 180, 190), I+2
C
C       ERROR...BITCH
  170   CALL ERROR ('TYPE SOCKET/EDGE SOCKET/GROUP DEF','???')
        GO TO 160
C
C       EDGE...VERIFY "SOCKET"
  180   IF (LPARSE(10) .NE. 1) GO TO 170
C
C       VERIFY "DEF"
  190   IF (LPARSE(11) .NE. 1) GO TO 170
        BTYPE = I
        BFLAG = .TRUE.
C
C       NOW OUTPUT AND GET NEW NAME
  200   CALL BLANK
        CALL BUFOUT(BID(1) )
        CALL BUFOUT('OK?:')
        CALL TYPE
        IF (.NOT. FETCHL(I) ) GO TO 100
C
C       GOT A NEW NAME...LOOK IT UP
  210   IF (BIDENT(ID(1) ) ) GO TO 220
        IF (BLOOK(ID(1) ) ) GO TO 230
C
C       GOT IT...SET IT UP AND GO ON
        BID(1) = ID(1)
        BID(2) = ID(2)
        BFLAG = .TRUE.
        GO TO 100
C
C       ALREADY DEFINED
  220   CALL ERROR ('ELEMENT IDENTIFICATION SYNTAX', 'SYNTAX')
        GO TO 210
C
C       MULTIPLE DEFINED
  230   CALL ERROR ('ELEMENT ALREADY DEFINED', 'MULT. DEF.')
        GO TO 210
C
C
C
C       HERE WHEN DONE WITH SOCKET NAME...NOW DO ALL SUB-ELEMENTS
  240   ITEM = BLSTPNT
        ULEGAL = .TRUE.
        IF (BTYPE .NE. 3) ULEGAL = .FALSE.
        DELETE = .FALSE.
        IF (J .EQ. BTYPE) GO TO 250
        IF ( (J .EQ. 3) .OR. (BTYPE .EQ. 3) ) DELETE = .TRUE.
C
C       OUTPUT A DISCRIPTION
  250   IF (ITEM .EQ. 0) GO TO 540
        CALL BDGET(ITEM)
        ITEM = BDNEXT
C
C       DETERMINE IF IN DELETE MODE, AND IF TO DELETE
        IF ( (BDID(1) .NE. 5HDRILL) .AND. DELETE) GO TO 460
        CALL BLANK
        CALL BCL
        CALL TYPE
        I = IEDIT(.TRUE.)
C
C       SET UP PARAMETERS IN CASE INSERT OR REPLACE
        ID(1) = 5HDRILL
        ID(2) = 0
        ID(3) = 0
        ID(4) = 0
        ID(5) = 0
        ID(6) = 0
        ID(7) = 0
C
C       DETERMINE WHAT TO DO WITH THIS DESCRIPTION
        GO TO (250, 270, 400, 460, 490), I
C
C       HERE IF ERROR IN INPUT ELEMENTS...BITCH AND REPEAT
  260   TYPE 5
        ITEM = BDTHIS
        GO TO 250
C
C       EDIT INDIVIDUAL ELEMENTS
  270   I = 0
        IF (BDID(1) .NE. 5HDRILL) I = BDID(1)
        TYPE 6, BDID(1), BDID(2), I
        IF (.NOT. FETCHL(I) ) GO TO 320
        I = LPARSE(34)
        IF (I .LE. 0) GO TO 260
        IF (I .GT. 3) GO TO 260
        GO TO (280, 290, 310), I
C
C       "
  280   I = 1H"
        GO TO 300
C
C       '
  290   I = 1H'
C
C       GENERAL...GET TEXT
  300   IF (.NOT. PACK(ID(2), 9, 0) ) GO TO 260
        IF (NOWCH(8, KANDO) .NE. I) GO TO 260
        BDID(1) = 0
        BDID(2) = 0
        J = 1
        CALL BUFSTR(BDID, J, I)
        CALL BUFSTR(BDID, J, ID(2) )
        BDFLAG = .TRUE.
        GO TO 320
C
C       DRILL
  310   BDID(1) = 5HDRILL
        BDID(2) = 0
        REF(1) = 0
        REF(2) = 0
        BDFLAG = .TRUE.
C
C       DO X-ELEMENT
  320   TYPE 7, BDX
        IF (.NOT. FETCHL(I) ) GO TO 340
        I = LPARSE(34)
        IF (I .LE. 0) GO TO 330
        IF (I .GT. 9) GO TO 330
        IF (I .NE. 6) GO TO 260
        CALL LPARSE(35)
C
C       GET NUMBER
  330   I = LOOKRL(XY)
        IF (I .EQ. 1) GO TO 260
        IF (I .EQ. 4) GO TO 260
        BDX = XY
        BDFLAG = .TRUE.
C
C       DO Y-ELEMENT
  340   TYPE 8, BDY
        IF (.NOT. FETCHL(I) ) GO TO 360
        I = LPARSE(34)
        IF (I .LE. 0) GO TO 350
        IF (I .GT. 9) GO TO 350
        IF (I .NE. 7) GO TO 260
        CALL LPARSE(35)
C
C       GET NUMBER
  350   I = LOOKRL(XY)
        IF (I .EQ. 1) GO TO 260
        IF (I .EQ. 4) GO TO 260
        BDY = XY
        BDFLAG = .TRUE.
C
C       DETERMINE IF ANY USING, ETC.
  360   IF (BDID(1) .EQ. 5HDRILL) GO TO 250
        IF (.NOT. ULEGAL) GO TO 380
C
C       "USING"
        TYPE 9, REF
        IF (.NOT. FETCHL(I) ) GO TO 250
        I = LPARSE(34)
        IF (I .LE. 0) GO TO 370
        IF (I .GT. 9) GO TO 370
        IF (I .NE. 5) GO TO 260
  370   IF (.NOT. BIDENT(ID(1) ) ) GO TO 260
        FLAGUB = .FALSE.
        REF(1) = ID(1)
        REF(2) = ID(2)
        BDFLAG = .TRUE.
        GO TO 250
C
C       "BUSSED"
  380   TYPE 10, REF
        IF (.NOT. FETCHL(I) ) GO TO 250
        I = LPARSE(34)
        IF (I .LE. 0) GO TO 390
        IF (I .GT. 9) GO TO 390
        IF (I .NE. 4) GO TO 260
  390   IF (LPARSE(45) .NE. 1) GO TO 260
        IF (.NOT. SIGSTR(ID(1) ) ) GO TO 260
        IF (LPARSE(45) .NE. 1) GO TO 260
        FLAGUB = .TRUE.
        REF(1) = ID(1)
        REF(2) = ID(2)
        BDFLAG = .TRUE.
        GO TO 250
C
C       INSERT
  400   CALL SOPM
  410   CALL PROMPT
        IF (.NOT. FETCHL(I) ) GO TO 410
  420   IF (BGETC(ID(1), ULEGAL) ) GO TO 430
        CALL WHY('MUST BE SAME FORM AS DEFINITION, INCLUDING ":"')
        GO TO 420
C
C       NEW LINE INPUT SUCCESSFULLY
  430   CALL ROPM
        I = BDFILE(3) + 1
        BDFILE(3) = I
        J = BDLAST
        BDLAST = I
        ITEM = BDTHIS
        BDFLAG = .TRUE.
        IF (J .EQ. 0) GO TO 440
        CALL BDGET(J)
        BDNEXT = I
        BDFLAG = .TRUE.
  440   CALL BDPUT
        BDTHIS = I
        BDFLAG = .TRUE.
        BDNEXT = ITEM
        BDLAST = J
        DO 450 I = 1, 7
  450   BDID(I) = ID(I)
        CALL BDPUT
        IF (J .NE. 0) GO TO 250
C
C       FIRST ELEMENT...UPDATE BELEMENT
        BLSTPNT = J
        BFLAG = .TRUE.
        CALL BPUT
        GO TO 250
C
C       DELETE
  460   I = BDLAST
        IF (ITEM .EQ. 0) GO TO 470
        CALL BDGET(ITEM)
        BDLAST = I
        BDFLAG = .TRUE.
  470   IF (I .EQ. 0) GO TO 480
        CALL BDGET(I)
        BDNEXT = ITEM
        BDFLAG = .TRUE.
        GO TO 250
  480   BLSTPNT = ITEM
        BFLAG = .TRUE.
        GO TO 250
C
C       REPLACE
  490   CALL SOPM
  500   CALL PROMPT
        IF (.NOT. FETCHL(I) ) GO TO 500
  510   IF (BGETC(ID(1), ULEGAL) ) GO TO 520
        CALL WHY('MUST BE SAME FORM AS DEFINITION, INCLUDING ":"')
        GO TO 510
C
C       NEW LINE INPUT SUCCESSFULLY
  520   CALL ROPM
        DO 530 I = 1, 7
  530   BDID(I) = ID(I)
        BDFLAG = .TRUE.
        GO TO 250
C
C
C
C       DONE WITH ALL PRESENTLY DEFINED...DETERMINE IF ANY MORE
  540   TYPE 4
        IF (IEDIT(.FALSE.) .EQ. 2) RETURN
        CALL SOPM
  550   UNPROMP = .FALSE.
  560   CALL PROMPT
        IF (.NOT. FETCHL(I) ) GO TO 560
  570   IF (BGETC(ID(1), ULEGAL) ) GO TO 580
        CALL WHY('MUST BE SAME FORM AS DEFINITION, INCLUDING ":"')
        GO TO 570
C
C       GOT A NEW LINE...APPEND IT
  580   I = BDFILE(3) + 1
        BDFILE(3) = I
        IF (BLSTPNT .EQ. 0) GO TO 590
        J = BDTHIS
        BDNEXT = I
        BDFLAG = .TRUE.
        GO TO 600
C
C       FIRST ELEMENT IN NEW LIST
  590   BLSTPNT = I
        BFLAG = .TRUE.
        J = 0
        CALL BPUT
C
C       NOW MAKE NEW ELEMENT
  600   CALL BDPUT
        BDTHIS = I
        BDFLAG = .TRUE.
        BDNEXT = 0
        BDLAST = J
        DO 610 I = 1, 7
  610   BDID(I) = ID(I)
        CALL BDPUT
C
C       DETERMINE IF TRAILING ; OR :
        IF (LPARSE(43) .NE. 1) GO TO 550
        CALL ROPM
        RETURN
        END
        SUBROUTINE BSAVE
C
C       THIS ROUTINE PERFORMS THE BOARD "SAVE" FUNCTION
C
C       ASSUMES WITNESS FILE OPEN, ELEMENTS EXIST, ON ENTRY
C
        COMMON /WITNESS/ WITNESS(9)
        INTEGER WITNESS
C
        COMMON /FILES/ FILES(7, 8), BFILE(7), BDFILE(7)
        INTEGER BFILE, BDFILE
C
        COMMON /BELEMNT/ BID(2), BTYPE, BLSTPNT, BTHIS, BFLAG
        INTEGER BID, BTYPE, BLSTPNT, BTHIS
        LOGICAL BFLAG
C
        COMMON /BDISCR/ BDID(2), BDX, BDY, FLAGUB, REF(2), BDLAST,
     1  BDNEXT, BDTHIS, BDFLAG
        INTEGER BDID, REF, BDLAST, BDNEXT, BDTHIS
        LOGICAL FLAGUB, BDFLAG
C
        COMMON /CPGLOB/ KURSOR, LINSIZ, NATCH, INLINE(270)
C
        DIMENSION ID(3)
C
    1   FORMAT(1X, 80A1)
    2   FORMAT( F15.3)
    3   FORMAT( ', ', F15.3)
C
C       FIRST BLANK OUT THE BUFFER, THEN DETERMINE THE NUMBER OF ELEMENTS
        CALL BLANK
        N = BFILE(3)
C
C       NOW DO FOR ALL ELEMENTS
        DO 120 I = 1, N
         CALL BGET(I)
         CALL BHEADER
         CALL R TO A
         WRITE (WITNESS(1), 1) (INLINE(K), K = 1, LINSIZ)
         CALL BLANK
C
C       DO FOR ALL SUB-ELEMENTS
         J = BLSTPNT
         IF (J .EQ. 0) GO TO 110
  100    CALL BDGET(J)
         J = BDNEXT
         CALL BCL
         IF (J .EQ. 0) GO TO 110
C
C       NOT LAST SUB-ELEMENT...APPEND ";", WRITE IT
         CALL BUFOUT(' ;')
        CALL R TO A
         WRITE (WITNESS(1), 1) (INLINE(K), K = 1, LINSIZ)
         CALL BLANK
         GO TO 100
C
C       LAST ONE...DO IT
  110    CALL BUFOUT(' :')
        CALL R TO A
         WRITE (WITNESS(1), 1) (INLINE(K), K = 1, LINSIZ)
         CALL BLANK
  120    CONTINUE
C
C       NOW ALL DONE WITH ELEMENTS...OUTPUT ANY CHANNEL CODES
        J = 0
        N = BDFILE(3)
        DO 190 I = 1, N
         CALL BDGET(I)
         K = BDID(1) .AND. "7
         IF (K .NE. BDID(1) ) GO TO 190
C
C       WE'VE GOT A CHANNEL CODE...DETERMINE IF TO PRINT THE LAST ONE
          IF (J .EQ. K) GO TO 170
        IF (J .EQ. 0) GO TO 130
C
C       FINISH OFF LAST ONE
         CALL BUFOUT(' :')
        CALL R TO A
         WRITE (WITNESS(1), 1) (INLINE(K), K = 1, LINSIZ)
         CALL BLANK
C
C       SET NEW COMMAND INTO FILE
  130    J = K
         CALL BUFOUT('CHANNEL')
         GO TO (140, 150), J
C
C       X CHANNEL
  140    CALL BUFOUT('X:')
         GO TO 160
C
C       Y CHANNEL
  150    CALL BUFOUT ('Y:')
C
C       ENCODE FIRST VALUE
  160    ENCODE (15, 2, ID(1) ) BDID(2)
         GO TO 180
C
C       ENCODE SUCCESSIVE VALUE
  170    ENCODE (15, 3, ID(1) ) BDID(2)
C
C       PACK IT IN
  180    CALL RTRUNC(15, ID(1) )
         CALL BUFOUT(ID(1) )
C
C       END OF LOOP
  190    CONTINUE
C
C       OUTPUT LAST IF ANY
        IF (J .EQ. 0) RETURN
        CALL BUFOUT(' :')
        CALL R TO A
         WRITE (WITNESS(1), 1) (INLINE(K), K = 1, LINSIZ)
C
C       DONE..CLEAN UP AND EXIT
        RETURN
        END
        SUBROUTINE BXYCHAN(J)
C
C       THIS ROUTINE INPUTS THE CHANNEL DATA, AND PUTS IT INTO THE TABLE
C
        COMMON /BDISCR/ ITYPE, VALUE, NULL(7), BDTHIS, BDFLAG
        INTEGER BDTHIS
        LOGICAL BDFLAG
C
        COMMON /FILES/ FILES(7, 9), FTEMP2(7)
        INTEGER FTEMP2
C
        COMMON /OWNPRM/ PRMPCP, UNPROMP, JPROM
        LOGICAL PRMPCP, UNPROMP
C
C       SET SPECIAL PROMPT IF NECESSARY
        CALL SOPM
C
C       DETERMINE IF THE LINE IS EMPTY
  100   I = NOWCH(1, KANDO)
        IF (KANDO) GO TO 130
C
C       MUST READ A NEW LINE...PROMPT FIRST
  110   UNPROMP = .FALSE.
C
C       DO IT
  120   CALL PROMPT
        IF (.NOT. FETCHL(I) ) GO TO 120
C
C       SKIP IF ":"
  130   IF (LPARSE(43) .EQ. 1) GO TO 150
        IF (.NOT. GETREAL(V) ) GO TO 110
C
C       HERE IF SUCCESS
        FTEMP2(3) = FTEMP2(3) + 1
        CALL BDPUT
        BDTHIS = FTEMP2(3) 
        VALUE = V
        ITYPE = J
        BDFLAG = .TRUE.
C
C       SKIP IF ":"
        IF (LPARSE(43) .EQ. 1) GO TO 150
C
C       DELETE ANY "," PRESENT
        CALL LPARSE(42)
        GO TO 100
C
C       DONE...CLEAN UP AND EXIT
  150   CALL ROPM
        CALL BDPUT
        RETURN
        END
        SUBROUTINE BDRILL(LIST)
C
C       THIS ROUTINE EXPANDS AND GENERATES A DRILL FILE
C       IT RETURNS .TRUE. IF SUCCESSFUL, .FALSE. IF AN ERROR OCCURED.
C       IF AN ERROR OCCURED, AN ERROR MESSAGE IS OUTPUT.
C
        DIMENSION LIST(4, 1)
C
C       LIST IS A DYNAMICALLY ALLOCATED ARRAY, USED FOR STACKING ELEMENTS
C       IT HAS THE PIECES...
C       LIST(1, I)      POINTER TO I-TH BELEMENT BLOCK
C       LIST(2, I)      POINTER TO CURRENT BDISCR
C       LIST(3, I)      BASE X-VALUE OF ELEMENT
C       LIST(4, I)      BASE Y-VALUE OF ELEMENT
C
        COMMON /WITNESS/ WITNESS(9)
        INTEGER WITNESS
C
        COMMON /BELEMNT/ BID(2), BTYPE, BLSTPNT, BTHIS, BFLAG
        INTEGER BID, BTYPE, BLSTPNT, BTHIS
        LOGICAL BFLAG
C
        COMMON /BDISCR/ BDID(2), BDX, BDY, FLAGUB, REF(2), BDLAST,
     1  BDNEXT, BDTHIS, BDFLAG
        INTEGER BDID, REF, BDLAST, BDNEXT, BDTHIS
        LOGICAL FLAGUB, BDFLAG
C
        INTEGER TEXT(2), ID(2)
        DATA TEXT /'DRILL FILE'/
        EQUIVALENCE (XBASE, IXBASE)
        EQUIVALENCE (YBASE, IYBASE)
C
    1   FORMAT (' EMPTY ELEMENT ENCOUNTERED...IGNORED'/)
    2   FORMAT (' ELEMENT ',2A5,' NOT DEFINED...ABORT OPERATION'/)
    3   FORMAT (' RECURSIVE USE OF ELEMENT',2A5,'...ABORT OPERATION'/)
C
C       INITIALIZE PARAMETERS
        XMIN = 1000000.0
        YMIN = 1000000.0
        XMAX = -1000000.0
        YMAX = -1000000.0
        XBASE = 0.0
        YBASE = 0.0
C
C       OPEN THE FILE AND SET IT UP
        CALL WOPEN(WITNESS(1) )
        WRITE (WITNESS(1) # 1 ) TEXT, TEXT, TEXT, TEXT
        NPOINT = 0
C
C       SET UP AND SAVE AN ELEMENT DESCRIPTION
        I = 1
  100   LIST(1, I) = BTHIS
        LIST(2, I) = BLSTPNT
        LIST(3, I) = IXBASE
        LIST(4, I) = IYBASE
C
C       DETERMINE IF NULL ELEMENT
        IF (LIST(2, I) .NE. 0) GO TO 150
        TYPE 1
C
C       DONE WITH ELEMENT...UNSTACK IT
  110   I = I - 1
        IF (I .GT. 0) GO TO 140
C
C       DONE..CLEAN UP AND EXIT
        I = 0
        WRITE (WITNESS(1) # 1) TEXT, XMIN, XMAX, YMIN, YMAX,
     1          I, NPOINT
C
C       CLOSE AND DISPOSE OF FILE
  120   CALL WCLOSE(WITNESS(1) )
        DO 130 I = 5, 9
  130    WITNESS(I) = 0
        RETURN
C
C       HERE FOR SUCCESSIVE ENTRIES
  140   CALL BDGET(LIST(2, I) )
        IF (BDNEXT .EQ. 0) GO TO 110
        LIST(2, I) = BDNEXT
C
C       GET THE NEXT ELEMENT
  150   CALL BDGET(LIST(2, I) )
C
C       COMPUTE THE POSITION OF THIS ELEMENT
        IXBASE = LIST(3, I)
        IYBASE = LIST(4, I)
        XBASE = XBASE + BDX
        YBASE = YBASE + BDY
C
C       DETERMINE IF NEW LIMITS GENERATED
        IF (XBASE .LT. XMIN) XMIN = XBASE
        IF (YBASE .LT. YMIN) YMIN = YBASE
        IF (XBASE .GT. XMAX) XMAX = XBASE
        IF (YBASE .GT. YMAX) YMAX = YBASE
C
C       DETERMINE IF "USING"
        IF ( (REF(1) .NE. 0) .AND. (.NOT. FLAGUB) ) GO TO 160
C
C       NOT "USING"...OUTPUT COORDINATES
        WRITE (WITNESS(1) ) XBASE, YBASE
        NPOINT = NPOINT + 1
        GO TO 140
C
C       GOT A "USING CODE...CHECK IT OUT
  160   ID(1) = REF(1)
        ID(2) = REF(2)
        IF (.NOT. BLOOK(ID(1) ) ) GO TO 180
        DO 170 J = 1, I
         IF (LIST(1, J) .EQ. BTHIS) GO TO 190
  170   CONTINUE
C
C       IT'S A GOOD ONE...SET IT UP
        I = I + 1
        GO TO 100
C
C       UNDEFINED ELEMENT...BITCH
  180   TYPE 2, ID
        GO TO 120
C
C       RECURSIVE...BITCH
  190   TYPE 3, ID
        GO TO 120
        END
        SUBROUTINE BGENER(LIST)
C
C       THIS ROUTINE EXPANDS AND GENERATES A DATA-BASE
C       IF AN ERROR OCCURED, AN ERROR MESSAGE IS OUTPUT.
C
        INTEGER LIST(7, 1), ID(4), ELID(3), CORANOW, CORABAK
        LOGICAL CORAFLG
C
C       LIST IS A DYNAMICALLY ALLOCATED ARRAY, USED FOR STACKING ELEMENTS
C       IT HAS THE PIECES...
C       LIST(1, I)      POINTER TO I-TH BELEMENT BLOCK
C       LIST(2, I)      POINTER TO CURRENT BDISCR
C       LIST(3, I)      BASE X-VALUE OF ELEMENT
C       LIST(4, I)      BASE Y-VALUE OF ELEMENT
C       LIST(<5:6>, I)  CURRENT ACCUMULATED IDENTIFICATION FOR SOCKET
C       LIST(7, I)      FIRST EMPTY CHARACTER IN IDENTIFICATION
C
        COMMON /DTABASE/ DTABASE(9)
        INTEGER DTABASE
C
        COMMON /FILES/ XYFILE(7, 2), SFILE(7), PFILE(7),
     1  FILES(7, 4), BFILE(7), BDFILE(7)
        INTEGER XYFILE, SFILE, PFILE, BFILE, BDFILE
C
        COMMON /BELEMNT/ BID(2), BTYPE, BLSTPNT, BTHIS, BFLAG
        INTEGER BID, BTYPE, BLSTPNT, BTHIS
        LOGICAL BFLAG
C
        COMMON /BDISCR/ BDID(2), BDX, BDY, FLAGUB, REF(2), BDLAST,
     1  BDNEXT, BDTHIS, BDFLAG
        INTEGER BDID, REF, BDLAST, BDNEXT, BDTHIS
        LOGICAL FLAGUB, BDFLAG
C
        COMMON /HASHCON/ HASH, NHASH, THISSIG, SIGID(2), NEXTSIG,
     1  SIGPIN, SIGFLAG
        INTEGER HASH, NHASH, THISSIG, SIGID, SIGPIN
        LOGICAL SIGFLAG
C
        COMMON /SOCKET/ SOCID(2), NSOCPIN, NWORDS, SPINPNT, SOCFLAG,
     1  THISSOC
        INTEGER SOCID, NSOCPIN, SPINPNT, THISSOC
        LOGICAL SOCFLAG
C
        COMMON /PINS/ PINID, CORAL(2), XPIN, YPIN, PSIG(2), FROMSIG,
     1  TOSIG, PPPNT, SPRING, ATTRIB, DIST, CNGWORD, NULL, PINFLAG,
     2  THISPIN
        INTEGER PINID, CORAL, PSIG, FROMSIG, TOSIG, PPPNT, SPRING,
     1  ATTRIB, CNGWORD, NULL, THISPIN
        LOGICAL PINFLAG
C
        COMMON /TITLE/ TITLE(16), MODIFY(2), NEWMOD, MODFLG, WRITEIT,
     1  XMIN, XMAX, YMIN, YMAX, PICFRAM
        INTEGER TITLE
        LOGICAL MODFLG, NEWMOD, WRITEIT, PICFRAM
C
        EQUIVALENCE (XBASE, IXBASE)
        EQUIVALENCE (YBASE, IYBASE)
C
    1   FORMAT (' EMPTY ELEMENT ENCOUNTERED...IGNORED'/)
    2   FORMAT (' ELEMENT ',2A5,' NOT DEFINED...ABORT OPERATION'/)
    3   FORMAT (' RECURSIVE USE OF ELEMENT',2A5,'...ABORT OPERATION'/)
    4   FORMAT (' GENERATED SOCKET ID "',3A5,'" TOO LONG...ABORT',
     1  ' OPERATION'/ )
    5   FORMAT (' SUCCESS...PLEASE TYPE TITLE FOR THIS DATA-BASE'/ )
C
C       INITIALIZE PARAMETERS
        NSOCPIN = -1
        TOSIG = 0
        PPPNT = 0
        DIST = 0.0
        CNGWORD = 0
        NULL = 0
        XMIN = 1000000.0
        YMIN = 1000000.0
        XMAX = -1000000.0
        YMAX = -1000000.0
        XBASE = 0.0
        YBASE = 0.0
        ID(1) = 0
        ID(2) = 0
        NCHAR = 1
C
C       OPEN THE FILE AND SET IT UP
        CALL WOPEN(SFILE(1) )
        CALL WOPEN(PFILE(1) )
C
C       SET UP AND SAVE AN ELEMENT DESCRIPTION
        ISTAK = 1
  100   LIST(1, ISTAK) = BTHIS
        LIST(2, ISTAK) = BLSTPNT
        LIST(3, ISTAK) = IXBASE
        LIST(4, ISTAK) = IYBASE
        LIST(5, ISTAK) = ID(1)
        LIST(6, ISTAK) = ID(2)
        LIST(7, ISTAK) = NCHAR
C
C       DETERMINE IF NULL ELEMENT
        IF (LIST(2, ISTAK) .NE. 0) GO TO 190
        TYPE 1
C
C       DONE WITH ELEMENT...UNSTACK IT
  110   ISTAK = ISTAK - 1
        IF (ISTAK .LE. 0) GO TO 120
        CALL BGET(LIST(1, ISTAK) )
        GO TO 200
C
C       DONE..CLEAN UP AND EXIT
  120   CALL PUTPIN
        CALL PUTSOC
C
C       OPEN THE CHANNEL FILES
        CALL WOPEN(XYFILE(1, 1) )
        CALL WOPEN(XYFILE(1, 2) )
C
C       SEARCH FOR ALL CHANNEL SPECS, PUT THEM IN TOO
        J = BDFILE(3)
        DO 150 I = 1, J
         CALL BDGET(I)
         N = BDID(1) .AND. "7
         IF (BDID(1) .NE. N) GO TO 150
C
C       GOT AN X OR Y VALUE
         IXBASE = BDID(2)
         M = XYFILE(3, N)
         IF (M .EQ. 0) GO TO 140
C
C       CORRESPONDING CHANNEL TABLE NOT EMPTY...SEARCH FOR MATCH
         DO 130 K = 1, M
          READ (XYFILE(1, N) # K) YBASE
          IF (XBASE .EQ. YBASE) GO TO 150
          IF (XBASE .GT. YBASE) GO TO 130
C
C       MUST SWAP
          WRITE (XYFILE(1, N) # K) XBASE
          XBASE = YBASE
  130     CONTINUE
C
C       WRITE REMAINING ELEMENT TO FILE
  140    WRITE (XYFILE(1, N) ) XBASE
  150    CONTINUE
C
C       CLOSE THE CHANNEL FILES
        CALL WCLOSE(XYFILE(1, 1) )
        CALL WCLOSE(XYFILE(1, 2) )
C
C       NOW PROCESS THE TITLE INFORMATION
        TYPE 5
        CALL FETCHL(I)
        I = NOWCH(5, KANDO)
        CALL MPUTCH(I, 1, TITLE(1) )
        J = 2
  160   I = NEXTCH(5, KANDO)
        IF (.NOT. KANDO) GO TO 170
        CALL MPUTCH(I, J, TITLE(1) )
        J = J + 1
        IF (J .LE. 80) GO TO 160
C
C       TITLE PACKED...CLEAR MODIFICATION AND QUIT
  170   MODIFY(1) = 0
        MODIFY(2) = 0
        MODFLG = .FALSE.
        IF ( (XYFILE(3, 1) + XYFILE(3, 2) ) .GT. 0) PICFRAM = .TRUE.
        CALL SETWRI
C
C       CLOSE THE FILES USED
  180   CALL WCLOSE(SFILE(1) )
        THISSOC = 0
        CALL WCLOSE(PFILE(1) )
        THISPIN = 0
        RETURN
C
C       HERE FOR NON-NULL NEW ELEMENT
  190   IF (BTYPE .EQ. 3) GO TO 220
C
C       NOT GROUP ELEMENT...DEFINE SOCKET
        CALL PUTSOC
        THISSOC = SFILE(3)
        IF (NSOCPIN .NE. 0) THISSOC = THISSOC + 1
        SFILE(3) = THISSOC
        SOCID(1) = ID(1)
        SOCID(2) = ID(2)
        NWORDS = 0
        NSOCPIN = 0
        SPINPNT = 0
        IF (BTYPE .EQ. 2) SPINPNT = "400000000000
        ATTRIB = 0
        IF (BTYPE .EQ. 2) ATTRIB = "200000000000
        GO TO 220
C
C       HERE FOR SUCCESSIVE ENTRIES
  200   CALL BDGET(LIST(2, ISTAK) )
        IF (BDNEXT .NE. 0) GO TO 210
        IF (BTYPE .EQ. 3) GO TO 110
        IF (NSOCPIN .EQ. 0) GO TO 110
C
C       FINISH THE SOCKET RINGS, ETC.
        CORAL(1) = SPINPNT .AND. "377777777777
        I = THISPIN
        PINFLAG = .TRUE.
        CALL GETPIN(CORABAK)
        CORAL(2) = I
        PINFLAG = .TRUE.
        CALL GETPIN(LASTRNG)
        SPRING = ISPRING
        PINFLAG = .TRUE.
        CALL PUTPIN
        CALL PUTSOC
        GO TO 110
C
C       NOT LAST ELEMENT...GET NEXT
  210   LIST(2, ISTAK) = BDNEXT
C
C       GET THE NEXT ELEMENT
  220   CALL BDGET(LIST(2, ISTAK) )
C
C       COMPUTE THE POSITION OF THIS ELEMENT
        IXBASE = LIST(3, ISTAK)
        IYBASE = LIST(4, ISTAK)
        ID(1) = LIST(5, ISTAK)
        ID(2) = LIST(6, ISTAK)
        NCHAR = LIST(7, ISTAK)
        XBASE = XBASE + BDX
        YBASE = YBASE + BDY
C
C       DETERMINE IF NEW LIMITS GENERATED
        IF (XBASE .LT. XMIN) XMIN = XBASE
        IF (YBASE .LT. YMIN) YMIN = YBASE
        IF (XBASE .GT. XMAX) XMAX = XBASE
        IF (YBASE .GT. YMAX) YMAX = YBASE
C
C       IF "DRILL", IGNORE IT
        IF (BDID(1) .EQ. 5HDRILL) GO TO 200
C
C       STRETCH ID
        IF (MGETCH(1, BDID(1) ) .EQ. "42)
     1          CALL STRBUF(ID(1), NCHAR, BDID(1) )
C
C       IF GROUP, SKIP TO EXPAND IT
        IF (BTYPE .EQ. 3) GO TO 390
C
C       THIS IS A SOCKET DESCRIPTION...EXPAND IT
        I = PFILE(3) + 1
        PFILE(3) = I
        IF (NSOCPIN .NE. 0) GO TO 230
C
C       NEW SOCKET...SET UP STUFF
        SPINPNT = I .OR. SPINPNT
        ISPRING = 0
        LASTRNG = 0
        CORAFLG = .TRUE.
        CORANOW = 0
        CORABAK = 0
        SOCFLAG = .TRUE.
        GO TO 240
C
C       OLD SOCKET...LINK LAST ELEMENT TO NEW
  230   CORAL(1) = I
C
C       GENERAL STUFF...CONTINUE FOR ALL PINS
  240   IF (LASTRNG .EQ. 0)  GO TO 250
        IF (REF(1) .NE. 0) GO TO 250
        CALL GETPIN(LASTRNG)
        SPRING = I
        PINFLAG = .TRUE.
C
C       WRITE OUT PREVIOUS PIN DESCRIPTION
  250   CALL PUTPIN
        NSOCPIN = NSOCPIN + 1
        NWORDS = NWORDS + 15
        THISPIN = I
        PINFLAG = .TRUE.
        SPRING = 0
        PINID = 0
        J = 1
        CALL STRBUF(PINID, J, BDID(1) )
        IF (J .GT. 6) GO TO 430
        XPIN = XBASE
        YPIN = YBASE
        PSIG(1) = REF(1)
        PSIG(2) = REF(2)
        FROMSIG = 0
        IF (REF(1) .EQ. 0) GO TO 260
C
C       SET UP BUSSED STRUCTURE
        CALL SIGFIND(REF(1) )
        FROMSIG = SIGPIN .OR. "400000000000
        SIGPIN = THISPIN .OR. "400000000000
        SIGFLAG = .TRUE.
        GO TO 270
C
C       NOT BUSSED...SET UP SOCKET RING
  260   LASTRNG = THISPIN
        IF (ISPRING .EQ. 0) ISPRING = THISPIN
C
C       NOW SET UP CORAL RING
  270   IF (CORAFLG) CORAL(2) = THISSOC .OR. "400000000000
        IF (CORAFLG) GO TO 280
        CORAL(2) = CORANOW
        CORANOW = THISPIN
        IF (CORABAK .EQ. 0) CORABAK = THISPIN
C
C       SET FOR NEXT TIME CORAL
  280   CORAFLG = .NOT. CORAFLG
        GO TO 200
C
C
C
C       THIS IS A GROUP DESCRIPTION
C       DETERMINE IF "USING"
  390   IF (FLAGUB) GO TO 200
C
C       GOT A "USING" CODE...CHECK IT OUT
        IF (NCHAR .GT. 11) GO TO 430
        ELID(1) = REF(1)
        ELID(2) = REF(2)
        IF (.NOT. BLOOK(ELID(1) ) ) GO TO 410
        DO 400 I = 1, ISTAK
         IF (LIST(1, I) .EQ. BTHIS) GO TO 420
  400   CONTINUE
C
C       IT'S A GOOD ONE...SET IT UP
        ISTAK = ISTAK + 1
        GO TO 100
C
C       UNDEFINED ELEMENT...BITCH
  410   TYPE 2, ELID(1), ELID(2)
        GO TO 440
C
C       RECURSIVE...BITCH
  420   TYPE 3, ELID(1), ELID(2)
        GO TO 440
C
C       NAME TOO LONG...BITCH
  430   TYPE 4, ID(1), ID(2), ID(3)
C
C       ABORT HERE
  440   DO 450 I = 5, 9
  450    DTABASE(I) = 0
C
C       MAKE ALL THE FILES EMPTY
        XYFILE(3, 1) = 0
        XYFILE(3, 2) = 0
        SFILE(3) = 0
        PFILE(3) = 0
        GO TO 180
        END
 |Ô