		TITLE COMPRS
		EXTERN JOBREL,JOBSA

;ACCUMULATOR ASSIGNMENTS
		NAME=10
		EXTN=11
		DIRAD=12
;CONSTANTS
		ARGNUM=33	;NUMBER OF LOOKUP ARGUMENTS
START:	JSA	16,INITTY	;INITIALIZE TELETYPE FOR READING
	JSA	16,DOWHAT	;FIND OUT WHAT TO DO
	CAMN	0,YES		;TEST REPLY
	JSA	16,COMPCT	;GO AND COMPACT FILES
	CAMN	0,NO		;GO AND DECOMPRESS FILES
	JSA	16,DECOMP
COMPCT:	0
	JSA	16,GETCMP	;GET NAME FOR COMRESSED FILE
	JSA	16,SETIO	;SETUP BUFFER AREA
	JSA	16,GETPPN	;GET PPN
	SETZM	STRUCT		;ENSURE NULL STRUCTURE NAME
	INIT	2,16		;INIT CHANNEL FOR FILES IN DUMP MODE
	SIXBIT/DSK/
		0
	HALT
NEWSTR:	MOVE	0,STRUCT	;GET LAST USED STRUCTURE NAME
	CALLI	0,46		;GET NEXT STRUCTURE NAME
	JRST	IMPER3		;STRUCTURE NAME DOES NOT EXIST
	JUMPE	0,FINPAC	;IF ZERO THEN FINISHED PACKING
	MOVEM	0,STRUCT	;STORE STRUCTURE NAME
	INIT	1,14		;INITIALIZE CHANNEL FOR UFD
STRUCT:		0		;STRUCTURE NAME USED FOR UFD DEVICE
	XWD	0,UFDBUF	;NAME OF UFD BUFFER HEADER
	HALT			;CANNOT INIT STRUCTURE
	INBUF	1,2		;SETUP UFD BUFFERS
	SKIPE	PPN		;IS PPN SET?
	JRST	GETUFD		;YES SO DONT USE THIS JOB'S PPN
	CALLI	0,24		;GET PROJECT PROG NUM OF FILES
	MOVEM	0,PPN		;STORE FOR LATER USE
GETUFD:	MOVE	0,PPN		;GET PROJ PROG NUM OF FILES
	MOVEM	0,LKUPUF	;STORE FOR LOOKUP
	HRLZI	0,'UFD'		;GET MNEMONIC UFD
	MOVEM	0,LKUPUF+1	;STORE FOR LOOKUP
	MOVE	0,[XWD 1,1]	;GET 1,1
	MOVEM	0,LKUPUF+3	;STORE AS SYS USER NUMBER
	LOOKUP	1,LKUPUF	;LOOKUP ON STRUCTURE
	JRST	NOUFD		;CANNOT FIND UFD
GOTSOM:	JSA	16,GETFYL	;GO AND GET USER FILES
	JRST	NEWSTR		;GO AND TRY NEXT STRUCTURE
FINPAC:	JSA	16,FINPAK	;GO AND CLEAN UP OUTPUT BUFFERS
	CLOSE	3,
	RELEASE	3,
	CALLI	0,12		;EXIT
NOUFD:	TTCALL	3,[ASCIZ/
AN ERROR OCURRED IN ATTEMPTING TO READ THE DIRECTORY
/]
	CALLI	0,12		;EXIT
IMPER3:	TTCALL	3,[ASCIZ/
SYSTEM ERROR WHILST LOCATING FILE DIRECTORY
/]
	CALLI	0,12
LKUPUF:	BLOCK 4			;UFD LOOKUP BLOCK
UFDBUF:	BLOCK 3			;UFD BUFFER HEADERS

;ROUTINE TO CLEAN UP OUTPUT BUFFER
FINPAK:	0
	MOVE	0,NUMBR
	JUMPE	FINCLN		;BUFFER EMPTY
	MOVN	1,NUMBR		;GET NEGATIVE NUMBER OF WORDS TO OUTPUT
	HRL	1,1		;SET IN LH FOR IOWD
	HRR	1,BEGIN		;SET DATA START ADDRESIN IOWD
	SOS	1		;SUB 1 FOR IOWD
	SETZ	2,		;CLEAR END OF COMMAND LIST
	OUTPUT	3,1		;OUTPUT DATA IN BUFFER
	STATZ	3,740000	;CHECK STATUS
	JRST	OUTERR		;ERROR SO GO TO PRINT MESSAGE
FINCLN:	JRA	16,0(16)	;RETURN

;ROUTINE TO INFORM USER THAT A SYSTEM ERROR OCURRED DURING OUTPUT.
OUTERR:	JUMP
	TTCALL	3,[ASCIZ/
A SYSTEM ERROR OCCURRED WHILST WRITING COMPRESSED FILE. I CANNOT CONTINUE
/]
	CALLI	1,12		;EXIT

;ROUTINE TO GET FILENAME-EXTENSION PAIR FROM UFD. NOTE THAT WE ARE
;DISCARDING THE LAST THREE WORDS OF EACH ENTRY.
INNAME:	0
	JSA	16,GETCNT	;GETNAME
	JRA	16,0(16)	;RETURN ON END OF FILE
	JUMPE	0,INNAME+1	;IF NULLTHEN TRY NEXT NAME
	MOVEM	0,NAM		;STORE
	EXCH	0,NAME		;STORE IN NAME AC
	JSA	16,GETCNT	;GET EXTENSION
	JRA	16,0(16)	;RETURN ON END OF FILE
	HLLZM	0,EXT		;STORE
	EXCH	0,EXTN		;STORE IN EXTENSION AC
	JSA	16,GETCNT	;SKIP A WORD
	JRA	16,0(16)	;RETURN ON END OF FILE
	JSA	16,GETCNT	;SKIP A WORD
	JRA	16,0(16)	;RETURN ON END OF FILE
	JSA	16,GETCNT	;SKIP A WORD
	JRA	16,0(16)	;RETURN ON END OF FILE
	JRA	16,1(16)	;RETURN WITH SUCCESS
;ROUTINE TO GET A WORD FROM UFD BUFFER
GETCNT:	0
	SOSG	UFDBUF+2	;DECREMENT BYTE COUNT
	JRST	GETBF1		;FILL BUFFER
GETNX1:	ILDB	0,UFDBUF+1	;GET NAME
	JRA	16,1(16)	;RETURN
GETBF1:	IN	1,		;FILL BUFFER
	JRST	GETNX1		;GO AND PROCESS NAMES
	STATZ	1,740000	;TEST STATUS
	SKIPA			;BADUFD
	JRA	16,0(16)	;EOF RETURN
	TTCALL	3,[ASCIZ/
THERE IS AN ERROR IN YOUR FILE DIRECTORY. I CANNOT CONTINUE
/]
	CALLI	1,12		;EXIT
;ROUTINE TO CONTROL OUTPUTTING AND READING OF FILES
GETFYL:	0
	SKIPE	UPDATE		;UPDATE MODE
	JRST	INLST		;YES SO GET NAMES FROM LIST
	JSA	16,INNAME	;GET A FILENAME-EXTENSION PAIR
	JRA	16,0(16)	;END OF UFD SO RETURN
FYLRED:	TTCALL	3,[ASCIZ/READING FILE /]
	MOVE	0,NAM		;GET FILENAME
	MOVEM	0,FYLNAM	;STORE FOR LOOKUP
	MOVE	0,EXT		;GET FILE EXTENSION
	MOVEM	0,FYLNAM+1	;STORE FOR LOOKUP
	JSA	16,TYPE		;TYPE FILENAME
	MOVE	0,PPN		;GET PROJECT PROGRAMMER NUMBER
	MOVEM	0,FYL1+1	;STORE FOR LOOKUP
	MOVEI	0,ARGNUM	;GET NUMBER OF LOOKUP ARGUMENTS IN USE
	MOVEM	0,FYL1		;STORE FOR LOOKUP
	LOOKUP	2,FYL1		;DO EXTENDED LOOKUP ON FILE
	JRST	FYLGON		;AN ALMOST IMPOSSIBLE ERROR
	TTCALL	3,[ASCIZ/
/]				;FINISH MESSAGE
	AOS	COUNT		;INCREMENT FILE COUNTER
	JSA	16,GETIT	;GO AND GET FILE
	JRST	GETFYL+1	;GO FOR NEXT FILE
FYLGON:	TTCALL	3,[ASCIZ/. CANNOT COPY (READ PROTECTED)
/]
	JRST	GETFYL+1	;TRY NEXT FILE
INLST:	JSA	16,INLIST	;GET A FILE NAME
	JRA	16,0(16)	;FINISHED
	JRST	FYLRED		;GO AND PROCESS IT

;ROUTINE TO TYPE FILE NAME AND EXTENSION.
TYPE:	0
	MOVEM	0,SAVE1		;SAVE AC0
	MOVEM	1,SAVE1+1	;SAVE AC1
	MOVEM	2,SAVE1+2	;SAVE AC3
	MOVE	0,[POINT 6,NAM,];GET A POINTER TO FILENAME
	MOVEI	2,6		;GET A COUNTER
NXCR1:	ILDB	1,0		;GET A CHARACTER
	JUMPE	1,XT		;TEST IF DONE
	ADDI	1,40		;CONVERT TO 7-BIT
	TTCALL	1,1		;OUTPUT CHARACTER
	SOJG	2,NXCR1		;TEST IF DONE
XT:	MOVEI	1,56		;GET A PERIOD
	TTCALL	1,1		;TYPE A PERIOD
	MOVEI	2,3		;SET COUNTER
	MOVE	0,[POINT 6,EXT,];GET POINTER TO EXTENSION
NXCR2:	ILDB	1,0		;GET A CHARACTER
	JUMPE	1,RET1		;TEST IF DONE
	ADDI	1,40		;CONVERT TO 7-BIT
	TTCALL	1,1		;TYPE CHARACTER
	SOJG	2,NXCR2		;TEST IF DONE
RET1:	MOVE	0,SAVE1	;RESTORE AC0
	MOVE	1,SAVE1+1	;RESTORE AC1
	MOVE	2,SAVE1+2	;RESTORE AC2
	JRA	16,0(16)	;RETURN
SAVE1:	BLOCK 4			;PLACE TO SAVE AC'S

;ROUTINE TO INITIALISE BUFFER POINTERS
SETIO:	0
	MOVEI	0,FIRST		;GET BUFFER START ADDRESS
	MOVEM	0,BEGIN		;SET POINTER
	SETZM	NUMBR		;CLEAR WORD COUNTER
	JRA	16,0(16)	;RETURN
;ROUTINE TO CONTROL FILE READING
GETIT:	0
	MOVE	0,FYL1+5	;GET NUMBER OF WORDS IN FILE
	MOVEM	0,NUMLFT	;STORE
	MOVEI	0,ARGNUM	;GET NUMBER OF LOOKUP ARGUMENTS
	MOVEM	0,NUMIN		;SET FOR TRANSFER TO OUTPUT BUFFER
	JSA	16,STORLK	;STORE LOOKUP DATA IN OUTPUT BUFFER
NXTIN:	SKIPG	1,NUMLFT	;TEST IF FILE IS COMPLETLY TRANSFERRED
	JRA	16,0(16)	;YES SO RETURN
	CAMG	1,INSIZE	;TEST IF A BUFFERFUL OF FILE STILL TO READ
	JRST	LSTBLK		;NO SO HANDLE SEPARATELY
	MOVE	0,INSIZE	;GET READ BLOCK LENGTH(1 CLUSTER)
	MOVEM	0,NUMIN		;USE AS NUMBER OF WORDS TO READ
	SUB	1,INSIZE	;COMPUTE NUMBER OF WORDS REMAINING
	MOVEM	1,NUMLFT	;STORE
	JSA	16,INFYL	;READ THE FILE
	MOVE	1,NUMLFT	;GET # OF WORDS REMAINING
	JRST	NXTIN		;PROCESS FILE REMAINDER
LSTBLK:	MOVE	1,NUMLFT	;GET NUMBER OF WORDS RAMAINING
	MOVEM	1,NUMIN		;STORE FOR READ
	JSA	16,INFYL	;GET REMAINDER IN
	SETZM	NUMLFT		;CLEAR NUMBER OF WORDS REMAINING
	JRA	16,0(16)	;RETURN

;I/O ROUTINE FOR COMPRESSION SYSTEM
INFYL:	0
	SETZ	3,		;INDICATE ENTRY POINT
INFYL1:	MOVE	0,LAST		;GET BUFFER END ADDRESS
	SUB	0,NUMBR		;SUBTRACT NUMBER OF DATA WORDS IN BUFFER
	SUB	0,BEGIN		;SUBTRACT FIRST DATA WORD ADDRESS
	AOS	0		;COMPUTE # OF FREE BUFFER WORDS
	CAML	0,NUMIN		;ENOUGH FREE BUFFER WORDS LEFT?
	JRST	READ1		;YES-SO GO AND FILL BUFFER
	MOVE	1,NUMBR		;GET # OF WORDS IN BUFFER
	CAMGE	1,OUTSYZ	;TEST IF ENOUGH TO JUSTIFY OUTPUT
	JRST	TRANS		;NO SO COMPACT THE BUFFER
	IDIV	1,OUTSYZ	;DIVIDE # OF WORDS BY O/P BLOCK SIZE
	IMUL	1,OUTSYZ	;COMPUTE SIZE OF BLOCK TO OUTPUT
	MOVE	2,NUMBR		;GET NUMBER OF WORDS IN BUFFER
	SUB	2,1		;DECREMENT BY AMOUNT TO BE OUTPUT
	MOVEM	2,NUMBR		;STORE
	MOVE	0,1		;SAVE NUMBER OF WORDS TO BE OUTPUT
	MOVNS	1,1		;GET NEGATIVE # OF WORDS TO BE OUTPUT
	HRLZ	1,1		;SET # OF WORDS TO OUTPUT IN IOWD
	HRR	1,BEGIN		;SET START OF OUTPUT IN IOWD
	SOS	1		;SUB 1 FOR IOWD
	SETZ	2,		;SET END OF COMMAND LIST
	OUTPUT	3,1		;;OUTPUT FROM BUFFER
	STATZ	3,740000		;CHECK STATUS
	JRST	OUTERR		;GO AND HANDLE OUTPUT ERROR
	ADDM	0,BEGIN		;RESET POINTER TO FIRST DATA WORD
TRANS:	SKIPE	0,NUMBR	;TEST IF BUFFER EMPTY
	JRST	TRANS1		;NO SO GO TO COMPACT BUFFER
	MOVEI	0,FIRST		;GET FIRST WORD ADDRESS OF BUFFER
	MOVEM	0,BEGIN		;RESET FIRST DATA WORD POINTER
	JRST	READ1		;GO AND READ
TRANS1:	HRLZ	0,BEGIN		;SET WHERE TO TRANSFER FROM
	HRRI	0,FIRST		;SET FIRST WORD TO TRANSFER TO
	MOVE	1,NUMBR		;GET # OF WORDS IN BUFFER
	ADDI	1,FIRST-1	;COMPUTE LAST WORD TO TRANSFER TO
	BLT	0,0(1)		;TRANSFER WORDS
	HRRZI	0,FIRST		;GET FIRST WORD ADDRESS
	MOVEM	0,BEGIN		;USE AS FIRST DATA ADDRESS
READ1:	JUMPN	3,LUKSTR	;GO AND STORE LOOKUP DATA IF REQUIRED
	MOVE	1,BEGIN		;GET CURRENT FIRST DATA WORD ADDRESS
	ADD	1,NUMBR		;INCREMENT TO GET 1ST FREE WORD
	MOVN	2,NUMIN		;GETNEGATIVE NUMBER OF WORDS TO READ
	HRL	1,2		;STORE FOR IOWD
	SOS	1		;SUB 1 FOR IOWD
	SETZ	2,		;CLEAR END OF COMMAND LIST
	IN	2,1		;READ FILE
	JRST	SETPNT		;GO AND SET POINTERS
	TTCALL	3,[ASCIZ/
A SYSTEM ERROR OCURRED WHILST READING FILE /]
	JSA	16,TYPE		;TYPE FILE NAME
	TTCALL	3,[ASCIZ/
PLEASE CHECK THIS FILE.
/]
	CALLI	1,12
SETPNT:	MOVE	0,NUMIN		;GETNUMBER OF WORDS JUST READ
	ADDM	0,NUMBR		;INCREMENT # OF DATA WORDS IN BUFFER
	JRA	16,0(16)	;RETURN
STORLK:	0
	SETO	3,		;INDICATE ENTRY POINT
	JRST	INFYL1		;GO AND MANAGE BUFFER
LUKSTR:	HRLZI	0,FYL1		;SET LOOKUP BLOCK START ADDRESS
	HRR	0,BEGIN		;GET ADDRESS OF FIRST DATA WORD
	ADD	0,NUMBR		;INCREMENT TO POINT TO FIRST FREE WORD
	MOVEI	1,ARGNUM	;GET LENGTH OF LOOKUP DATA
	ADDM	1,NUMBR		;INCREMENT NUMBER OF DATA WORDS IN BUFFER
	HRRZ	1,0		;GET FIRST FREE WORD ADDRESS
	ADDI	1,ARGNUM-1	;COMPUTE LAST WORD TO BE WRITTEN INTO
	BLT	0,0(1)		;STORE LOOKUP DATA IN OUTPUT BUFFER
	JRA	16,0(16)	;RETURN

;ROUTINE TO GET NAME OF COMPRESSED FILE
GETCMP:	0
	TTCALL	3,[ASCIZ/
PLEASE TYPE NAME AND EXTENSION YOU WISH TO GIVE COMPRESSED FILE
*/]
	JSA	16,SETTTY	;INITIALIZE TTY FOR I/O
	JSA	16,GETNAM	;GET NAME
	INIT	3,16		;INITIALIZE OUTPUT CHANNEL
	SIXBIT/DSK/
	0
	HALT
	SETZ	3,		;CLEAR FOR PRJ PRG NO
	MOVEM	0,CMPNAM	;STORE NAME OF COMPRESSED FILE
	MOVEM	1,CMPEXT	;STORE EXTENSION OF COMPRESSED FILE
	ENTER	3,0		;DO THE ENTER
	SKIPA			;ERROR
	JRA	16,0(16)	;RETURN
	MOVEM	0,NAM		;STORE FOR MESSAGE
	HLLZM	1,EXT		;STORE FOR MESSAGE
	TTCALL	3,[ASCIZ/
A FILE NAMED /]
	JSA	16,TYPE		;TYPE NAME AND EXTENSION
	TTCALL	3,[ASCIZ/ ALREADY EXITS AND IS WRITE LOCKED/]
	JRST	GETCMP+1

;ROUTINE TO GET FILE NAME AND EXTENSION IN AC0 & AC1 RESPECTIVELY
GETNAM:	0
	MOVEM	3,SAV		;SAVE AC3
	MOVEM	4,SAV+1		;SAVE AC4
	MOVEM	5,SAV+2		;SAVE AC5
	SETZB	1,2		;CLEAR AC'S 1&2
	MOVE	3,[POINT 6,1,]	;GET A POINTER TO AC1
	MOVE	4,[POINT 6,2,]	;GET A POINTER TO AC2
	MOVEI	5,6		;SET A CHARACTER COUNTER
NX1:	JSA	16,GETTTY	;GET A CHARACTER FROM TTY
	JRST	FINNAM		;NO MORE SO RETURN
	SUBI	0,40		;CONVERT TO 6-BIT
	CAIN	0,16		;PERIOD?
	JRST	EXTIN		;YES SO START EXTENSION
	JUMPE	0,NX1		;IGNORE IF NULL
	IDPB	0,3		;STORE IN AC 1
	SOJG	5,NX1		;TEST IF DONE
	JSA	16,GETTTY	;SEE IF HE TYPED A PERIOD
	JRST	FINNAM		;YES-SO RETURN
	CAIE	0,56		;PERIOD?
	JRST	SMALL		;NO SO ERROR
EXTIN:	MOVEI	5,3		;SET EXTENSION CHARACTER COUNTER
NX2:	JSA	16,GETTTY	;GET A CHARACTER FROM TTY
	JRST	SMALL		;ERROR
NX3:	SUBI	0,40		;CONVERT TO 6-BIT
	JUMPE	0,NX2		;IGNORE NULLS
	IDPB	0,4		;DEPOSIT IN AC 2
	SOJG	5,NX2		;TEST IF DONE
FINNAM:	MOVE	0,1		;STORE ARGUMENT
	MOVE	1,2		;STORE EXTENSION ARGUMENT
	MOVE	3,SAV		;RESTORE AC'S
	MOVE	4,SAV+1
	MOVE	5,SAV+2
	JRA	16,0(16)
SMALL:	TTCALL	3,[ASCIZ/
AN EXTENSION MUST HAVE THREE LETTERS, PLEASE RETYPE EXTENSION ONLY
WITH NO PERIOD */]
	JSA	16,SETTTY	;REINITIALIZE TTY
	JSA	16,GETTTY	;GET A CHARACTER
	JRST	NON		;HE TYPED A CARRIAGE RETURN
	MOVEI	5,3		;RESET COUNTER
	JRST	NX3
NON:	SETZ	2,			;NO EXTENSION
	JRST	FINNAM
SAV:	BLOCK 3

;ROUTINIE TO DO TTY INPUTS
SETTTY:	0
	IN	5,		;GET A LINE
	JRA	16,0(16)
	HALT			;IMPOSSIBLE ERROR

;ROUTINE TO INITIALIZE TTY CHANNEL
INITTY:	0
	INIT	5,1
	SIXBIT/TTY/
	XWD	0,TTYBUF
	HALT
	INBUF	5,1		;SETUP A BUFFER
	JRA	16,0(16)
TTYBUF:	BLOCK 3

;ROUUTINE TO GET A CHARACTER FROM TTY
GETTTY:	0
	SETZ	0,
GETCR1:	SOSG	TTYBUF+2
	JRST	GETBF2
GETNX2:	ILDB	0,TTYBUF+1
	CAIL	0,40		;END OF LINE IF CHARACTER LESS THAN A BLANK
	JRA	16,1(16)
GETBF2:	JRA	16,0(16)

;ROUTINE TO ASK WHAT TO DO
DOWHAT:	0
	TTCALL	3,MESSAG
WHAT:	JSA	16,SETTTY	;INITIALIZE TTY
	JSA	16,GETNAM	;GET WHAT TO DO
	CAMN	0,DIRECT	;DIRECTORY LIST?
	JSA	16,DIREC	;YES
	CAMN	0,CRE		;CREATE?
	JSA	16,CREATE	;YES
	CAMN	0,HLP		;HELP?
	JRST	HELP		;YES
	CAMN	0,DEC		;DECOMPRESS?
	JSA	16,DECOMP	;YES
	CAMN	0,COMPRS		;COMPRESS?
	JSA	16,COMPCT	;YES
	CAMN	0,UPDT		;UPDATE?
	JSA	16,UPDTE	;YES
	CAMN	0,APPND		;APPEND?
	JSA	16,APEND	;YES
	CAMN	0,DELT		;DELETE?
	JSA	16,DELEET	;GO AND DELETE FILES
	CAMN	0,RESTR		;RESTORE
	JSA	16,SELECT	;YES
	TTCALL	3,[ASCIZ/
PLEASE RETYPE
*/]
	JRST	WHAT
HELP:	TTCALL	3,HELLP
	JRST	WHAT

;DECOMPRESS SYSTEM
DECOMP:	0
	JSA	16,SETCMP	;GET COMPRESSED FILE NAME AND LOOK IT UP
	JSA	16,READ2	;DO THE FIRST READ
NXTOUT:	JSA	16,EXTRCT	;GET LOOKUP BLOCK AND PERFORM THE ENTER
	JRST	TSTERR		;ERROR ON ENTER
	SKIPE	0,DIR		;TEST IF DOING DIRECTORY
	JRST	DIROUT		;YES SO DONT OUTPUT THE FILE
	JRST	TYPNAM		;START TO PROCESS THE FILE
TSTERR:	CAIN	0,2		;TEST IF WRITE PROTECTED FILE
	JRST	WRTLK		;YES SO PRINT MESSAGE
	TTCALL	3,[ASCIZ/FILE /]
	JSA	16,TYPE		;TYPE FILE NAME
	CAIE	0,10		;NEWER DISC VERSION?
	JRST	CUT		;NO SO IT'S ANOTHER ERROR
	TTCALL	3,[ASCIZ/ NOT TRANSFERRED-NEWER DISC VERSION
/]
	JRST	CICLE		;SKIP THE FILE
CUT:	TTCALL	3,[ASCIZ/ CANNOT BE TRANSFERRED TO DISC DUE TO EITHER:
1) IT IS CURRENTLY BEING MODIFIED, OR
2) YOU DO NOT HAVE ACCESS PRIVILEDGES TO THE DIRECTORY.
/]
	JRST	CICLE		;SKIP FILE
WRTLK:	TTCALL	3,[ASCIZ/FILE /];START MESSAGE
	JSA	16,TYPE		;TYPE FILENAME AND EXTENSION
	TTCALL	3,[ASCIZ/IS ALREADY ON DISC WRITE LOCKED.
/]
CICLE:	JSA	16,CYCLE	;SKIP OVER FILE
	JRST	TSTFIN		;GO AND TEST IF FINISHED
TYPNAM:	TTCALL	3,[ASCIZ/TRANSFERRING FILE /]
	JSA	16,TYPE		;TYPE FILE NAME AND EXTENSION
	TTCALL	3,[ASCIZ/
/]
	JSA	16,OUTFYL	;DO THE OUTPUT
	JSA	16,RENAM	;RENAME THE FILE
TSTFIN:	JSA	16,FINISH	;TEST IF FINISHED
	JRST	NXTOUT
	TTCALL	3,[ASCIZ/
FINSISHED
/]
	CALLI	0,12		;EXIT
DIROUT:	TTCALL	3,[ASCIZ/
DIRECTORY SEARCH NOT IMPLEMENTED YET
/]
	CALLI	0,12

;ROUTINE TO GET COMPRESSED FILE NAME AND INIT I/O CHANNELS
SETCMP:	0
	TTCALL	3,[ASCIZ/
ENTER NAME AND EXTENSION OF FILE TO BE DECOMPRESSED
*/]
	SKIPA
SETCM:	0
	JSA	16,SETTTY		;INITIALIZE TELETYPE
	JSA	16,GETNAM
	MOVEM	0,CMPNAM
	MOVEM	1,CMPEXT
	INIT	3,16		;INITIALIZE READ CHANNEL
	SIXBIT/DSK/
	0
	HALT
	INIT	2,16		;INITIALIZE OUTPUT CHANNEL
	SIXBIT/DSK/
	0
	HALT
	JSA	16,SETIO	;INITIALIZE BUFFER AREA
	MOVE	0,PPN		;GET PPN
	MOVEM	0,FYL1+2	;USE FOR COMPRESSED FILE
	MOVE	0,CMPNAM	;GET COMPRESSED FILE NAME
	MOVEM	0,FYLNAM	;STORE FOR LOOKUP
	MOVE	0,CMPEXT	;GET COMPRESSED FILE EXTENSION
	MOVEM	0,FYLNAM+1	;STORE FOR LOOKUP
	MOVEI	0,ARGNUM	;GET # OF LOOKUP ARGS
	MOVEM	0,FYL1		;STORE
	SKIPN	DELOPR		;IF DELETING CHAN 2 IS FOR INPUT
	JRST	OTHER		;NO SO USE CHAN 3 FOR INPUT
	LOOKUP	2,FYL1		;DO THE LOOKUP
	JRST	NOCMP		;CANT FIND FILE
	JRST	OKCMP		;FOUND IT
OTHER:	LOOKUP	3,FYL1		;DO THE LOOKUP
	SKIPA
	JRST	OKCMP		;CONTINUE
NOCMP:	TTCALL	3,[ASCIZ/CANNOT FIND COMPRESSED FILE CALLED /]
	MOVE	0,CMPNAM	;GET COMPRESSED FILE NAME
	MOVEM	0,NAM		;STORE FOR MESSAGE
	MOVE	0,CMPEXT	;GET COMPRESSED FILE EXTENSION
	HLLZM	0,EXT		;STORE FOR MESSAGE
	JSA	16,TYPE		;TYPE FILE NAME
	JRST	SETCMP+1	;TRY AGAIN
OKCMP:	MOVE	0,FYL1+5	;GET FILE LENGTH
	JUMPE	0,BADCMP	;TEST IF COMPRESSED FILE EMPTY
	MOVEM	0,LENGTH	;STORE
	JRA	16,0(16)	;RETURN
BADCMP:	TTCALL	3,[ASCIZ/
THE COMPRESSED FILE IS EMPTY. SORRY I CANNOT CONTINUE
/]
	CALLI	1,12		;EXIT

;ROUTINE TO CONTROL FILE OUTPUT
OUTFYL:	0
NXTBLK:	MOVE	0,NUMLFT	;GET NUMBER OF WORDS LEFT TO READ
	SKIPN	0		;TEST IF DONE
	JRA	16,0(16)	;YES SO RETURN
	CAMLE	0,OUTSYZ	;TEST IF LESS THAN OUTPUT BLOCK SIZE
	JRST	TSTSYZ		;SO TEST HOW MANY IN BUFFER
	CAMLE	0,NUMBR		;TEST AGAINST NUMBER OF WORDS IN BUFFER
	JSA	16,READ2	;NOT ALL IN CORE SO GET REMAINDER IF IT FITS
	JRST	OUTBF		;ALL IN CORE SO OUTPUT
TSTSYZ:	MOVE	0,NUMBR		;GET # OF WORDS IN BUFFER
	CAML	0,OUTSYZ	;TEST AGAINST OUTPUT BLOCK SIZE
	SKIPA			;NO ROOM FOR INPUT SO OUTPUT SOME FIRST
	JSA	16,READ2	;NO ENOUGH TO OUTPUT SO GET MORE
OUTBF:	MOVE	0,NUMLFT	;GET # OF WORDS STILL TO BE OUTPUT
	CAMGE	0,OUTSYZ	;TEST AGAINST OUTPUT BUFFER SIZE
	SKIPA			;LESS THAN SO USE NUMLFT FOR OUTPUT
	MOVE	0,OUTSYZ	;OUTPUT A BUFFER FULL
	ADDM	0,NUMOUT	;INCREMENT NUMBER OUTPUTTED TO DATE
	MOVN	1,0		;GET NEGATIVE NUMBER FOR IOWD
	HRL	1,1		;STORE IN LEFT HALF
	HRR	1,BEGIN		;GET START ADDRESS FOR OUTPUT
	ADDM	0,BEGIN		;SET POINTER TO NEW FIRST DATA WORD
	SOS	1,1		;DECREMENT(BECAUSE IT'S A NEG NUMBER)
	MOVN	4,0		;GET NEGATIV # OF WORDS TO READ
	ADDM	4,NUMBR		;DECREMENT # OF WORDS IN BUFFER
	ADDM	4,NUMLFT	;DECREMENT NUMBER STILL TO BE OUTPUTTED
	SETZ	2,		;CLEAR END OF COMMAND LIST
	OUTPUT	2,1		;DO THE OUTPUT
	STATZ	2,740000	;CHECK STATUS
	SKIPA
	JRST	NXTBLK		;CONTINUE
	TTCALL	3,[ASCIZ/
SYSTEM ERROR WHILST WRITING FILE /]
	MOVE	1,FYLNAM
	MOVEM	1,NAM
	MOVE	1,FYLNAM+1
	HLLZM	1,EXT
	JSA	16,TYPE		;TYPE FILENAME-EXTENSION
	TTCALL	3,[ASCIZ/
/]
	CALLI	0,12		;EXIT

;ROUTINE TO READ COMPRESSED FILE
READ2:	0
	MOVE	2,NUMBR		;GET # OF DATA WORDS IN BUFFER
	JUMPN	2,READ4		;IF NON ZERO SIMPLY CONTINUE
	MOVEI	2,FIRST	;GET BUFFER START ADDRESS
	MOVEM	2,BEGIN		;STORE AS FIRST BUFFER DATA WORD
	MOVE	2,LAST		;GET ADDRESS OF LAST BUFFER WORD
	SUBI	2,FIRST-1	;COMPUTE TOTAL NUMBER OF BUFFER WORDS
	JRST	READ3		;GO AND READ
READ4:	MOVE	2,LAST		;GET END OF BUFFER ADDRESS
	SUB	2,BEGIN		;SUBTRACT FIRST DATA WORD ADDRESS
	SUB	2,NUMBR		;SUBTRACT # OF WORDS IN BUFFER
	AOS	2		;FORM # OF FREE WORDS
	CAML	2,OUTSYZ	;GET SIZE OF OUTPUT BLOCK
	JRST	READ3		;ENOUGH FREE BUFFER SO READ
	HRL	0,BEGIN		;GET ADDRESS OF FIRST DATA WORD
	HRRI	0,FIRST		;GET ADDRESS OF FIRST BUFFER WORD
	ADD	2,BEGIN		;ADD BEGINNING ADDRESS TO # OF FREE WORDS
	SUBI	2,FIRST-1	;SUBTRACT TO FORM TOTAL # OF FREE WORDS
	HRRM	0,BEGIN		;STORE FIRST AS DATA START ADDRESS
	HRRI	1,FIRST-1	;COMPUTE LAST
	ADD	1,NUMBR		;WORD TO BE WRITTEN INTO BY BLT
	BLT	0,0(1)		;RETRIEVE BUFFER SPACE
READ3:	IDIV	2,OUTSYZ	;COMPUTE NUMBER OF FREE INPUT BLOCKS
	IMUL	2,OUTSYZ	;COMPUTE AS A NUMBER OF WORDS
	EXCH	0,2		;PUT IN AC 0
	CAMLE	0,LENGTH	;TEST IF A WHOLE BLOCK OF FILE LEFT TO READ
	MOVE	0,LENGTH	;NO SO GET IT ALL IN
	MOVN	4,0		;GET NEGATIVE # OF WORDS TO BE READ
	ADDM	4,LENGTH	;DECREMENT AMOUNT OF FILE STILL TO BE READE	1,0		;GET A COPY OF AMOUNT TO READ
	IDIVI	1,200		;COMPUTE EQUIVALENT # OF DISC BLOCKS
	SKIPE	0,2		;SKIP IF INTEGER
	ADDI	1,1		;NO SO ROUND UP
	ADDM	1,BLKNUM	;INCREMENT # OF BLOCKS READ TO DATE
	HRR	1,BEGIN		;GET DATA START ADDRESS
	ADD	1,NUMBR		;ADD # OF DATA WORDS IN BUFFER
	ADDM	0,NUMBR		;INCREMENT # OF WORDS IN BUFFER
	MOVN	0,0		;GET NEGATIVE # OF WORDS TO READ
	HRL	1,0		;STORE IN IOWD
	SOS	1		;POINT TO BEGIN-1 FOR IOWD
	SETZ	2,		;CLEAR END OF COMMAND LIST
	IN	3,1		;OERFORM THEE READ
	JRA	16,0(16)		;RETURN
READER:	STATZ	3,740000	;CHECK STATUS
	JRST	.+3		;RREAD ERROR
	TTCALL	3,[ASCIZ/
END OF COMPRESSED FILE MISSING/]
	SKIPA
	TTCALL	3,[ASCIZ/
SYSTEM ERROR WHILST READING COMPRESSED FILE/]
	CALLI	1,12		;EXIT

;ROUTINE TO CYCLE THROUGH FILE WITHOUT READING IT
CYCLE:	0
	MOVE	0,NUMLFT		;GET FILE LENGTH STILL TO BE READ
	ADDM	0,NUMOUT	;INCREMENT # OF MASTER FILE WORDS READ
	CAMG	0,NUMBR		;TEST IF ENTIRE FILE ALREADY IN BUFFER
	JRST	MOVPNT		;YES SO SIMPLY MOVE POINTERS
	SUB	0,NUMBR		;COMPUTE HOW MUCH OF FILE STILL TO BE READ
	IDIVI	0,200		;CONVERT TO A NUMBER OF DISC BLOCKS
	MOVEM	1,REM		;STORE REMAINDER AS ADDRESS OF NEXT LOOKUP
	ADDI	0,1		;ROUND UP
	MOVN	2,0		;GET # OF BLOCKS AS NEG NUM
	AOS	2		;DECREMENT
	IMULI	2,200		;CONVERT TO A NUMBER OF WORDS
	ADDM	2,LENGTH	;DECREMENT # OF WORDS TO READ
	ADD	0,BLKNUM	;COMPUTE NEW BLOCK NUMBER
	MOVEM	0,BLKNUM	;STORE NEW BLOCK NUMBER
	HLL	0,[USETI 3,0]	;GET A USETI INSTRUCTION
	XCT	0		;EXECUTE IT
	MOVN	3,INSIZE	;GET SIZE OF INPUT BLOCK
	SKIPE	0,DIR		;TEST IF DIRECTORY SEARCH ON
	HRROI	3,-200		;GET -200(A DISC BLOCK SIZE)
	MOVN	0,LENGTH	;GET REMAINING LENGTH
	CAML	0,3		;LESS THAN A BLOCK?
	MOVE	3,0		;YES SO JUST READ THE REMAINDER
	HRL	1,3		;READ ONLY ONE DISC BLOCK IF DIRECTORY SRCH
	HRRI	1,FIRST-1	;SET INPUT START ADDRESS
	SETZ	2,		;CLEAR END OF COMMAND LIST
	IN	3,1		;DO THE INPUT
	SKIPA			;SUCCESS
	JRST	READER		;READ ERROR
	MOVN	1,3		;GET # OF WORDS READ
	SUB	1,REM		;COMPUTE # OF NEW FILE WORDS IN BUFFER
	MOVEM	1,NUMBR		;STORE
	MOVN	1,3		;GET NUMBER OF WORDS READ
	IDIVI	1,200		;COMPUTE EQUIVALENT # OF DISC BLOCK
	SOS	1		;DECREMENT
	ADDM	1,BLKNUM	;UPDATE LAST BLOCK # READ
	MOVE	1,REM		;GET # OF OLD FILE WORDS IN BUFFER
	ADDI	1,FIRST		;GET BUFFER BEGINNING & COMPUTE NEW-FILE-
	MOVEM	1,BEGIN		;-BEGINNING ADDRESS AND STORE
	ADDM	3,LENGTH	;DECREMENT # OF COMP FILE WORDS TO READ
	JRA	16,0(16)	;RETURN
MOVPNT:	ADDM	0,BEGIN		;RESET BUFFER POINTER
	MOVE	1,NUMBR		;GET # OF WORDS IN BUFFER
	SUB	1,0		;SUBTRACT # OF WORDS TO SKIP
	MOVEM	1,NUMBR		;STORE REMAINDER
	JRA	16,0(16)	;RETURN

;ROUTINE TO PERFORM LOOKUP BLOCK EXTRACTION AND ENTERING ON DISC
EXTRCT:	0
	MOVEI	0,ARGNUM	;GET ARGUMENT BLOCK LENGTH
	CAMG	0,NUMBR		;TEST IF WHOLE BLOCK IN BUFFER
	SKIPA
	JSA	16,READ2	;NO SO GET IT
	HRL	0,BEGIN		;GET LOOKUP BLOCK START ADDRESS
	HRRI	0,FYL1		;GET ENTER BLOCK START ADDRESS
	MOVEI	1,ARGNUM-1	;GET # OF ARGS MINUS ONE
	ADDI	1,FYL1		;COMPUTE ADDRESS OF END OF ENTER BLOCK
	BLT	0,0(1)		;MOVE TO ENTER BLOCK
	MOVEI	1,ARGNUM	;GET LENGTH OF ARGUMENT BLOCK
	ADDM	1,BEGIN		;POINT TO IT
	MOVEI	0,ARGNUM	;GET LENGTH OF ARGUMENT BLOCK
	MOVN	4,0		;GET NEG NUMBER
	ADDM	4,NUMBR		;DECREMENT NUMBER OF DATA WORDS IN BUFFER
	ADDM	0,NUMOUT	;INCREMENT # OF WORDS OUTPUTTED
	MOVE	0,FYLNAM	;GET FILE NAME
	MOVEM	0,NAM		;STORE
	MOVE	0,FYLNAM+1	;GET EXTENSION
	HLLZM	0,EXT		;STORE
	MOVE	0,FYL1+5	;GET FILE LENGTH
	MOVEM	0,NUMLFT	;STORE
	MOVE	0,FYLNAM	;GET FILE NAME
	MOVE	1,FYLNAM+1	;GET EXTENSION
	SETZ	2,		;CLEAR AC2
	MOVE	3,PPN		;GET DESTINATION PPN
	MOVEM	3,FYL1+1	;STORE FOR RENAME
	SKIPE	0,DIR		;TEST IF DIRECTORY SEARCH ONLY
	JRA	16,1(16)	;YES SO SKIP RETURN
	SKIPE	0,NODATE	;TEST IF DATE IGNORE FLAGE SET
	JRST	ENT		;YES SO IGNORE DATE
	JSA	16,TSTTYM	;GO AND TEST TIME
	JRA	16,0(16)	;TIME CONFLICT SO RETURN
ENT:	MOVE	0,FYLNAM	;GET FILE NAME
	MOVE	1,FYLNAM+1	;GET EXTENSION
	MOVE	3,PPN		;GET PROJECT PROG NUMBER
	ENTER	2,0		;DO THE ENTER
	SKIPA			;ERROR RETURN
	JRA	16,1(16)	;SUCCESS RETURN
	HRRZ	0,1		;STORE ERROR CODE IN RH OF AC0
	JRA	16,0(16)	;ERROR RETURN

;ROUTINE TO RENAME FILE 
RENAM:	0
	RENAME	2,FYL1		;RENAME THE FILE
	SKIPA			;ERROR
	JRA	16,0(16)	;SUCCESS RETURN
	TTCALL	3,[ASCIZ/CANNOT STORE FILE /]
	JSA	16,TYPE		;TYPE FILENAME-EXTENSION
	TTCALL	3,[ASCIZ/ ON DISC. I AM CONTINUING
/]
	JRA	16,0(16)	;RETURN

;ROUTINE TO ALLOW FILES TO BE INDIVIDUALLY RESTORED TO DISC BY NAME
;THE LIST OF NAMES COMING EITHER FROM TTY OR A DISC FILE.

SELOUT:	0
	TTCALL	3,[ASCIZ/
WHERE ARE THE NAMES OF FILES TO BE RESTORED (TYPE TTY OR DSK)
*/]
	SKIPA
SELDEL:	0
	JSA	16,SETTTY	;INITIALIZE TTY FOR INPUT
	JSA	16,GETNAM	;GET WHERE FROM TTY
	CAME	0,TTY		;TELETYPE?
	JRST	DSKIN		;NO SO TRY DISC
INDEV:	JSA	16,INITDV	;INITIALIZE DEVICE
	JRST	NOFYL		;CANNOT FIND FILE ON DISC
	TTCALL	3,[ASCIZ/
PLEASE TYPE FILENAMES SEPARATED BY COMMAS. CARRIAGE RETURN TERMINATES LIST.
/]
SETCOR:	HLRZ	1,JOBSA		;GET CURRENT HIGHEST CORE LOCATION
	AOS	1		;INCREMENT
	MOVEM	1,NAMLST	;STORE AS START OF NAME LIST ADDRESS
	MOVEM	1,NAME
NXTNAM:	MOVE	1,NAME		;GET CURRENT LIST END ADDRESS
	JRST	GETCOR		;SEE IF WE HAVE ENOUGH CORE
NXTNM1:	JSA	16,NAMEIN	;GET A NAME
	JRA	16,0(16)	;FINISHED GETTING NAMES
	MOVEM	1,0(NAME)	;STORE NAME
	MOVEM	2,1(NAME)	;STORE EXTENSION
	ADDI	NAME,2		;INCREMENT LIST POINTER
	CAMG	NAME,JOBREL	;TEST IF MORE CORE NEEDED
	JRST	NXTNAM		;NO-SO GET NEXT NAME
	HRRZ	1,NAME		;GET NEW CORE AMOUNT
GETCOR:	ADDI	1,4		;INCREMENT
	CAMGE	1,JOBREL	;TEST IF SUFFICIENT CORE
	JRST	NXTNM1
	CALL	1,[SIXBIT/CORE/];GET CORE
	JRST	NOCOR		;NONE
	JRST	NXTNM1		;GET NEXT NAME
NOCOR:	TTCALL	3,[ASCIZ/
NOT ENOUGH CORE TO STORE YOUR INPUT LIST. PLEASE BREAK LIST INTO
SMALLER PORTIONS AND TRY AGAIN/]
	CALLI	0,12		;EXIT
DSKIN:	CAME	0,DSK		;DID HE TYPE DISC
	JRST	NOSUCH		;NO SO TELL HIM
	TTCALL	3,[ASCIZ/
PLEASE TYPE THE NAME OF THE DISC FILE CONTAINING YOUR FILE NAMES FOR TRANSFER
*/]
FYNDNM:	JSA	16,SETTTY	;INITIALIZE TTY
	JSA	16,GETNAM	;GET FILE NAME
	MOVEM	0,DSKFYL	;STORE
	MOVEM	1,DSKFYL+1	;STORE EXTENSION
	MOVE	0,DSK		;GET NAME 'DSK'
	JSA	16,INITDV	;INITIALIZE DISC
	JRST	NOFYL		;FILE NOT FOUND
	JRST	SETCOR		;GO AND SET CORE
NOSUCH:	TTCALL	3,[ASCIZ/
CANNOT FIND DEVICE/]
	JRST	SELOUT+1	;TRY AGAIN
NOFYL:	TTCALL	3,[ASCIZ/
CANNOT FIND FILE PLEASE RETYPE NAME*/]
	JRST	FYNDNM		;TRY AGAIN

;ROUTINE TO INITIALIZE NAME FILE INPUT DEVICE
INITDV:	0
	MOVEM	0,DEVNAM
	INIT	6,0		;INITIALIZE CHANNEL 6 IN ASCII MODE
DEVNAM:		0		;DEVICE NAME GOES HERE
	XWD	0,FYLBUF	;BUFFER HEADER
	HALT
	SETZM	DSKFYL+3	;CLEAR ANY OLD JUNK IN PPN
	LOOKUP	6,DSKFYL	;FIND IT
	JRA	16,0(16)	;NOT THERE ERROR RETURN
	MOVE	0,[XWD 400000,DSKBF1+1];GET HEADER WORD
	MOVEM	0,FYLBUF	;SET UP BUFFER RING
	MOVE	0,[POINT 7,0,35];GET BYTE POINTER
	MOVEM	0,FYLBUF+1	;PUT IN HEADER
	JRA	16,1(16)	;RETURN

;ROUTINE TO GET A NAME FROM INPUT DEVICE
NAMEIN:	0
	SETZB	1,2		;CLEAR RETURN AC'S
	MOVE	3,[POINT 6,1,]	;GET A POINTER TO AC 1
	MOVE	4,[POINT 6,2,]	;GET A POINTER TO AC 2
	MOVEI	5,6		;SET A CHARACTER COUNTER
NM1:	JSA	16,NAMGET	;GET A CHARACTER FROM INPUT
	JRST	DONE		;TEST IF DONE
	SUBI	0,40		;CONVERT TO SIXBIT
	CAIN	0,16		;PERIOD?
	JRST XIN1		;YES SO GET EXTENSION
	CAIN	0,14		;COMMA?
	JRST	DONE		;YES SO SEE IF DONE
	IDPB	0,3		;STORE CHARACTER
	SOJG	5,NM1		;TEST IF DONE SIX CHARACTERS
	JSA	16,NAMGET	;GET NEXT CHARACTER
	JRST	DONE		;TEST IF DONE
	CAIN	0,54		;COMMA?
	JRST	DONE		;TEST IF DONE
	CAIE	0,56		;PERIOD?
	JRST	TOOLNG		;NO SSO NAME TOO LONG
XIN1:	MOVEI	5,3		;SET A COUNTER
XIN2:	JSA	16,NAMGET	;GET A CHARACTER
	JRST	DONE		;SEE IF DONE
	SUBI	0,40		;CONVERT TO SIXBIT
	CAIN	0,14		;COMMA?
	JRST	DONE		;YES SO SEE IF DONE
	IDPB	0,4		;STORE CHARACTER IN AC 2
	SOJG	5,XIN2		;TRY NEXT CHARACTER
	JSA	16,NAMGET	;GET NEXT CHARACTER
	JRST	DONE		;TEST IF DONE
	CAIN	0,54		;COMMA?
	JRST	DONE		;YES SO TEST IF DONE
TOOLNG:	TTCALL	3,[ASCIZ/
NAME TOO LONG : /]
	MOVEM	1,NAM		;STORE NAME
	HLLZM	2,EXT		;STORE EXTENSION
	JSA	16,TYPE		;TYPE NAME AND EXTENSION
	ADDI	0,40		;CONVERT BUM CHARACTER BACK TO 7-BIT
	TTCALL	1,0		;TYPE IT
	TTCALL	3,[ASCIZ/
/]
	MOVE	1,DSK		;GET NAME DSK
	CAMN	1,DEVNAM	;IS DISC OUR INPT?
	CALLI	0,12		;REGRETFULLY YES SO TERMINATE
	TTCALL	3,[ASCIZ/
RETYPE FROM AND INCLUDING THIS NAME ON
*/]
	JRST	NAMEIN+1	;START AGAIN
DONE:	SKIPE	1		;IS OUR NAME NON NULL?
	JRA	16,1(16)	;WE HAVE A NAME SO RETURN
	JRA	16,0(16)	;NAME NULL SO FINISHED

;ROUTINE TO CHECK TIME AND CREATION DATE OF COMPRESSED FILE
;WHOSE NAME IS IN LOOKUP BLOCK FYL1, AGAINST ANY FILE ON DISC
;WITH THE SAME NAME
TSTTYM:	0
	LOOKUP	2,0		;DO A LOOKUP ON FILE
	JRA	16,1(16)	;DATE OK
	MOVE	3,[POINT 12,2,35];GET A POINTER TO DATE FIELD
	LDB	0,3		;GET DISC FILE DATE
	HRRI	3,FYL1+4	;SET POINTER TO COMPRESSED FILE DATE
	LDB	1,3		;GET DATE OF COMPRESSED FILE
	CAMLE	1,0		;COMPRESSED FILE DATE LE DISC FILE
	JRA	16,1(16)	;DATE OK
	CAME	0,1		;SAME DAY MONTH YEAR?
	JRST	SETRET		;NO SO IT'S AN OLDER VERSION DON'T COPY
	MOVE	3,[POINT 11,2,23];GET A POINTER TO TIME FIELD
	LDB	0,3		;GET DISC FILE TIME
	HRRI	3,FYL1+4	;SET POINTER TO COMPRESSED FILE TIME
	LDB	1,3		;GET COMPRESSED FILE TIME
	CAMLE	1,0		;IS COMP FILE OLDER OR EQUAL TIME TO DISC FILE
	JRA	16,1(16)	;DATE OK
SETRET:	HRRZI	0,10		;SET NO COPY CODE
	JRA	16,0(16)	;RETURN

;ROUTINE TO CONTROL INDIVIDUAL FILE RESTORATION
SELECT:	0
	JSA	16,SETIO	;SEUP BUFFERS
	JSA	16,SETCMP	;SETUP IO CHANNELS AND GET COMPRESSED FILE NAME
	JSA	16,SELOUT	;GO AND GET FILE NAMES IN
	SETOM	DIR		;SET DIRECTORY SEARCH FLAG
	JSA	16,READ2	;GO AND READ
FYNDNX:	JSA	16,EXTRCT	;GET LOOKUP BLOCK DATA
	JUMP			;CANNOT RETURN HERE
	JSA	16,TESTIT	;TEST IF THIS FILE HAS BEEN REQUESTED
	JRST	TSTFN1		;NO SO SEE IF FINISHED
	SKIPE	0,NODATE	;TEST IF IGNORING DATE
	JRST	ENT2		;YES SO DON'T CHECK IT
	JSA	16,TSTTYM	;GO AND TEST TIME AND DATE
	JRST	NOTCPY		;DONT COPY
ENT2:	MOVE	0,NAM		;GET FILENAME FOR ENTER
	MOVE	1,EXT		;GET EXTENSION FOR ENTER
	SETZ	2,		;CLEAR GARBAGE FROM AC2
	MOVE	3,PPN		;GET PPN FOR ENTER
	ENTER	2,0		;DO THE ENTER
	JRST	TSTENT		;FIND WHY ENTER FAILLED
	TTCALL	3,[ASCIZ/TRANSFERRING FILE /]
	JSA	16,TYPE		;TYPE NAME
	TTCALL	3,[ASCIZ/
/]
	JSA	16,OUTFYL	;OUTPUT THE FILE
	JSA	16,RENAM	;RENAME IT
TSTFN2:	JSA	16,ANYMOR	;TEST IF MORE FILE NAMES
	JRST	FINRES		;NO
	JSA	16,FINISH	;TEST IF DONE
	JRST	FYNDNX		;NO SO TRY AGAIN
FINRES:	TTCALL	3,[ASCIZ/FINISHED RESTORING
/]
	MOVE	2,NAMLST	;GET LIST START ADDRESS
	SETZB	3,5		;CLEAR AC'S
NXLST1:	MOVE	0,0(2)		;GET A NAME
	JUMPE	0,MESFIN	;IF NULL DONT OUTPUT
	MOVEM	0,NAM		;STORE FOR OUTPUT
	MOVE	0,1(2)		;GET EXTENSION
	HLLZM	0,EXT		;STORE
	TTCALL	3,[ASCIZ/FILE /]
	JSA	16,TYPE		;TYPE NAME & EXTENSION
	TTCALL	3,[ASCIZ/ NOT FOUND IN COMPRESSED FILE
/]
	SETO	5,		;SET NOT FOUND FLAG
MESFIN:	ADDI	2,2		;INCREMENT POINTER
	CAME	2,NAME		;TEST IF DONE
	JRST	NXLST1		;NO SO LOOK FOR NEXT UNFOUND NAME
	SKIPN	5		;DID WE TRANSFER ALL
	TTCALL	3,[ASCIZ/
ALL REQUESTED FILES TRANSFERRED
/]
	CALLI	0,12		;EXIT
NOTCPY:	TTCALL	3,[ASCIZ/
FILE /]
	JSA	16,TYPE		;TYPE TIME CONFLICT FILE NAME
	TTCALL	3,[ASCIZ/ NOT TRANSFERRED BECAUSE DISC VERSION IS NEWER
/]
	JRST	TSTFN1	;SEE IF DONE
TSTENT:	TTCALL	3,[ASCIZ/
CANNOT COPY FILE /]
	JSA	16,TYPE		;TYPE FILE NAME
	TTCALL	3,[ASCIZ/BECAUSE A WRITE PROTECTED VERSION ALREADY EXITS
/]
TSTFN1:	JSA	16,CYCLE	;SKIP THE REST OF THE FILE
	JRST	TSTFN2		;SEE IF WHOLE COMPRESSED FILE SEARCHED

;ROUTINE TO TEST IF CURRENT FILE NEEDED TO COPY
TESTIT:	0
	MOVE	2,NAMLST	;GET LIST START ADDRESS
NXTLST:	MOVE	0,0(2)		;GET A NAME
	CAME	0,NAM		;TEST NAME FOR MATCH
	JRST	INCRMT		;NO MATCH
	MOVE	1,1(2)		;GET EXTENSION
	CAME	1,EXT		;TEST FOR MATCH
	JRST	INCRMT		;NO MATCH
	SETZM	0(2)		;MATCH SO CLEAR LIST
	SETZM	1(2)		;CLEAR EXTENSION
	JRA	16,1(16)	;RETURN
INCRMT:	ADDI	2,2		;INCREMENT POINTER
	CAMN	2,NAME		;TEST IF DONE WITH LIST
	JRA	16,0(16)	;YES SO NON FIND RETURN
	JRST	NXTLST		;TRY NEXT ENTRY

;ROUTINE TO CONVERT A SIX CHARACTER PPN INTO BINARY
GETPPN:	0
	TTCALL	3,[ASCIZ/
ENTER SIX CHARACTER (OR LESS) USER NAME, FROM WHICH FILES ARE TO BE
COMPRESSED. (TYPE A CARRIAGE RETURN IF THIS USER NUMBER IS TO BE USED)
*/]
	JSA	16,SETTTY	;INITIALIZE TTY FOR INPUT
	JSA	16,GETNAM	;GET PPN IN SIXBIT
	SKIPN	0,0		;IF NULL RETURN
	JRA	16,0(16)	;HE WANTS THIS USER NUMBER
	MOVEM	0,USRNAM	;STORE SIXBIT PPN FOR LOOKUP
	SETZM	0,USRNAM+1	;CLEAR SECOND WORD
	MOVEI	1,USRNAM	;GET USER NAME BLOCK ADDRESS
	MOVEM	1,UFDNAM+1	;USE FOR LOOKUP
	INIT	7,0		;GET A CHANNEL
	SIXBIT/DSK/		;ON DISC
	0
	HALT
	LOOKUP	7,UFDNAM	;DO A LOOKUP
	JUMP			;WE DON'T CARE IF IT FAILED
	CAMN	1,UFDNAM+1	;DID WE GET BINARY USER NAME?
	JRST	REGET		;NO SO TRY AGAIN
	MOVE	0,UFDNAM+1	;GET BINARY PPN
	MOVEM	0,PPN		;STORE
	JRA	16,0(16)	;RETURN
REGET:	TTCALL	3,[ASCIZ/CANNOT FIND USER NAME/]
	JRST	GETPPN+1	;TRY AGAIN

;ROUTINE TO GET A CHARACTER FROM BUFFER
NAMGET:	0
NAM1:	SOSG	FYLBUF+2	;DECREMENT BYTE COUNT AND TEST
	JRST	NAM2		;NONE LEFT SO FILL BUFFER
NAM3:	ILDB	0,FYLBUF+1	;GET A CHARACTER
	JUMPE	0,NAM1		;IF NULL GET ANOTHER CHARACTER
	CAIN	0,40		;BLANK?
	JRST	NAM1		;YES SO IGNORE
	CAIN	0,14		;FORM FEED?
	JRA	16,0(16)	;YES SO RETURN
	CAIN	0,12		;LINE FEED
	JRA	16,0(16)	;YES SO RETURN
	CAIN	0,175		;ALTMODE
	JRA	16,0(16)	;YES SO RETURN
	CAIE	0,15		;CARRIAGE RETURN
	JRA	16,1(16)	;NO SO RETURN WITH A CHARACTER
	IBP	0,FYLBUF+1	;SKIP OVER THE LINE FEED
	SOS	FYLBUF+2	;DECREMENT BYTE COUNT
	JRA	16,0(16)	;NO CHARACTER RETURN
NAM2:	MOVE	0,DSK
	CAME	0,DEVNAM	;DISC INPUT?
	TTCALL	3,[ASCIZ/*/]	;NO SO OUTPUT AN ASTERISK
	IN	6,		;FILL BUFFER
	JRST	NAM3		;GO AND PROCESS CHARACTERS
	STATZ	6,740000	;TEST CHANNEL STATUS
	SKIPA			;ERROR
	JRA	16,0(16)	;END OF FILE RETURN
	TTCALL	3,[ASCIZ/
ERROR WHILST READING FILE NAMES
/]
	CALLI	1,12		;EXIT

;ROUTINE TO SKIP IF MORE FILES IN LIST
ANYMOR:	0
	MOVE	2,NAMLST	;GET LIST START ADDRESS
ANY1:	SKIPE	0(2)		;TEST IF LIST NAME ENTRY IS NULL
	JRA	16,1(16)	;NO SO RETURN WITH A SKIP
	ADDI	2,2		;INCREMENT LIST ADDRESS
	CAME	2,NAME		;FINISHED?
	JRST	ANY1		;NO SO TRY NEXT
	JRA	16,0(16)	;LIST IS EMPTY

;ROUTINE TO DELETE FILES

DELETE:	0
	MOVE	0,CMPNAM	;GET NAME OF COMPRESSED FILE
	MOVE	1,CMPEXT	;GET EXTENSION
	SETZ	3,		;CLEAR PPN
	ENTER	3,0		;ENTER NEW COMP FILE ON DISC
	SKIPA			;ERROR
	JRST	DEL1		;SUCCESS
	TTCALL	3,[ASCIZ/
COMPRESSED FILE MUST BE UNPROTECTED FOR UPDATING OR DELETING/]
	CALLI	1,12		;EXIT
DEL1:	MOVEI	0,1		;GET A 1
	MOVEM	0,BLKNUM	;SET CURRENT BLOCK NUMBER
	MOVEI	1,200		;GET NUMBER OF WORDS TO READ
	CAMLE	1,LENGTH	;LESS THAN TOTAL COMP FILE LENGTH?
	MOVE	1,LENGTH	;NO SO USE EXACT FILE LENGTH
	MOVEM	1,NUMBR		;SET NUMBER OF WORDS IN BUFFER
	MOVN	1,1		;MAKE NEGATIVE
	ADDM	1,LENGTH	;DECREMENT LENGTH OF FILE STILL TO READ
	HRL	1,1		;STORE LENGTH FOR IOWD
	HRRI	1,FIRST-1	;STORE ADDRESS FOR INPUT IN IOWD
	MOVEI	2,FIRST		;GET BUFFER START ADDRESS
	MOVEM	2,LOOK		;STORE AS LOOKUP BLOCK ADDRESS
	SETZ	2,		;CLEAR END OF COMMAND LIST
	IN	2,1		;GET SOME DATA
	SKIPA			;SUCCESS
	JRST	READER		;READ ERROR
	MOVE	0,FIRST+5	;GET FILE LENGTH
	MOVEM	0,NUMLFT	;STORE
	MOVE	0,FIRST+2	;GET FILE NAME
	MOVEM	0,NAM		;STORE
	MOVE	0,FIRST+3	;GET EXTENSION
	HLLZM	0,EXT		;STORE
DELNXT:	JSA	16,MORDEL	;TEST IF ALL DELETED
	JRST	ALLCPY		;FINISHED DELETING
	JSA	16,THIS1	;TEST IF THIS FILE TO BE DELETED
	JRST	COPY1		;NO SO COPY TO OUTPUT
	SKIPE	UPDATE		;TEST IF UPDATIN
	JRST	STDEL		;YES SO DONT TYPE DELETE MESSAGE
	TTCALL	3,[ASCIZ/DELETING FILE /]
	JSA	16,TYPE		;TYPE FILE NAME
	TTCALL	3,[ASCIZ/
/]
STDEL:	MOVE	0,NUMBR		;GET NUMBER OF DATA WORDS IN BUFFER
	SUB	0,LOOK		;SUBTRACT LOOKUP START ADDRESS
	ADD	0,BEGIN		;ADD BUFFER DATA START ADDRESS
	SUBI	0,ARGNUM	;SUBTRACT LENGTH OF LOOKUP DATA BLOCK
	CAMLE	0,NUMLFT	;IS # OF NEW FILE WORDS GT # IN BUFFER
	JRST	BLT1		;NO SO IT'S ALL IN JUST BLT
	MOVE	1,NUMLFT	;GET FILE LENGTH
	SUB	1,0		;SUBTRACT # OF NEW FILE WORDS IN BUFFER
	CAME	1,LENGTH	;IS THIS THE LAST FILE IN COMP FILE?
	JRST	CONTIN		;NO
	ADDI	0,ARGNUM	;YES SO COMPUT # LAST FILE WRDS + ARGNUM
	MOVE	1,NUMBR		;GET NUMBER OF WORDS IN BUFFER
	SUB	1,0		;COMPUTE # OF OLD FILE WORDS IN BUFFER
	MOVEM	1,NUMBR		;SAVE
	SETZM	LENGTH		;CLEAR LENGTH
	JRST	FNTST		;GO TO FINISH UP
CONTIN:	IDIVI	1,200		;COMPUTE # OF BLOCKS
	AOS	1		;STILL TO READ
	MOVE	4,2		;SAVE REMAINDER
	MOVN	3,1		;GET AS A NEG NUM
	AOS	3		;COMPUTE # OF BLOCKS SKIPPED
	IMULI	3,200		;CONVERT TO A NUMBER OF WORDS
	ADDM	3,LENGTH	;DECREMENT # OF COMP FILE WORDS TO READ
	ADD	1,BLKNUM	;COMPUTE NEXT BLOCK NUMBER
	MOVEM	1,BLKNUM	;STORE
	HLL	1,[USETI 2,0]	;GET A USETI INSTRUCTION
	XCT	1		;EXECUTE IT
	MOVEI	3,200		;GET BLOCK LENGTH
	CAML	3,LENGTH	;LESS THAN REMAINDER OF COMP FILE?
	MOVE	3,LENGTH	;NO SO USE REMAINDER FOR INPUT
	MOVN	3,3		;MAKE NEGATIVE
	ADDM	3,LENGTH	;DECREMENT # OF COMP FILE WORDS TO BE READ
	HRL	1,3		;SETUP # OF WORDS TO READ
	HRR	1,LOOK		;GET LOOKUP ADDRESS
	SOS	1		;DECREMENT FOR IOWD
	SETZ	2,		;CLEAR END OF COMMAND LIST
	IN	2,1		;GET DATA
	SKIPA			;SUCCESS
	JRST	READER		;READ ERROR
	MOVN	3,3		;GET # OF WORDS JUST READ
	MOVE	1,3		;GET A COPY
	SUB	3,4		;COMPUTE # OF NEW FILE WORDS NOW IN BUFFER
	SUB	3,0		;SUBTRACT # OF DATA WORDS THAT WERE IN BUFFER
	SUBI	3,ARGNUM	;LESS ARGUMENT BLOCK LENGTH
	ADDM	3,NUMBR		;ADD NEW NUMBER (NET) OF WORDS IN BUFFER
	JUMPE	4,SAVNAM	;IF NUMBER TO SKIP IS ZERO DONT BLT
	MOVE	0,LOOK		;GET LOOUP ADDRESS
	ADD	0,4		;COMPUT POSITION OF NEXT LOOKUP BLOCK
	HRL	0,0		;STORE IN LH FOR BLT
	HRR	0,LOOK		;GET LOOKUP ADDRESS
	SUB	1,4		;COMPUTE # OF NEW DATA WORDS JUST READ
	ADD	1,LOOK		;ADD ADDRESS OF LOOKUP WORD
	SOS	1		;DECREMENT TO POINT TO LAST BLT WORD
	BLT	0,0(1)		;BLT DATA
	JRST	SAVNAM		;GO TO STORE NAME OF NEW FILE ETC
BLT1:	MOVE	1,NUMLFT	;GET FILE LENGTH
	ADD	1,LOOK		
	ADDI	1,ARGNUM	;COMPUTE ADDRESS OF NEXT LOOKUP WORD
	HRL	1,1		;STORE AS BLT SOURCE ADDRESS
	HRR	1,LOOK		;STORE DESTINATION ADDRESS
	MOVE	2,NUMBR		;GET NUMBER OF WORDS IN BUFFER
	SUB	2,NUMLFT	;SUBTRACT # OF DATA WORDS SKIPPED
	SUBI	2,ARGNUM	;SUBTRACT LENGTH OF LOOKUP BLOCK
	MOVEM	2,NUMBR		;STORE NEW NUMBER OF DATA WORDS
	SUB	0,NUMLFT	;COMPUTE # OF NEXT FILE WORDS INBUFFER
	ADD	0,LOOK		;COMPUTE LSAT WORD FOR BLT
	SOS	0		;DECREMENT
	MOVE	7,0		;GET IN AC7
	BLT	1,0(7)	;BLT
SAVNAM:	MOVE	0,NUMBR		;GET # OF DAA WORDS IN BUFFER
	SUB	0,LOOK		;COMPUTE # OF NEXT FILE WORDS IN BUFFER
	ADD	0,BEGIN		;"" "" ""
	CAIL	0,ARGNUM	;DO WE HAVE ENTIRE ARGUMENT BLOCK
	JRST	STRNM		;YES SO DONT GET MORE IN
	MOVEI	1,200		;GET BLOCK LENGTH
	CAMLE	1,LENGTH	;AT LEAST 1 BLOCK OF COMP FILE LEFT?
	MOVE	1,LENGTH	;NO SO USE REMAINDER OF COMP FILE
	ADDM	1,NUMBR		;INCREMENT # OF DATA WORDS IN BUFFER
	MOVN	1,1		;GET AMOUNT TO READ AS NEGATIVE NUMBER
	ADDM	1,LENGTH	;DECREMENT AMOUNT OF COMP FILE LEFT
	HRL	1,1		;SET AMOUNT TO READ IN IOWD
	HRR	1,LOOK		;GET LOOKUP BLOCK ADDRESS
	ADD	1,0		;ADD # OF WORDS OF ARG BLOCK WE HAVE
	SOS	1		;DECREMENT FOR IOWD
	SETZ	2,		;CLEAR END OF COMMAND LIST
	AOS	BLKNUM		;INCREMENT BLOCK NUMBER
	IN	2,1		;GET REMAINDER OF ARG BLOCK
	SKIPA			;SUCCESS
	JRST	READER		;ERROR
STRNM:	MOVE	2,LOOK		;GET ADDRESS OF LOOKUP DATA
	MOVE	1,2(2)		;GET FILE NAME
	MOVEM	1,NAM		;STORE
	MOVE	1,3(2)		;GET EXTENSION
	HLLZM	1,EXT		;STORE
	MOVE	1,5(2)		;GET FILE LENGTH
	MOVEM	1,NUMLFT	;STORE
	JRST	DELNXT		;TRY NEXT FILE
SETLUK:	ADDI	2,ARGNUM	;AC2 WILL HAVE # OF OLD FILE + ARGNUM WORDS
	ADDM	2,LOOK		;POINT TO NEXT LOOKUP BLOCK WORD
	SKIPE	LENGTH		;FINISHED READING COMP FILE?
	JRST	SAVNAM	;NO SO CONTINUE
	MOVE	1,BEGIN		;GET BEGGINING ADDRESS OF DATA
	ADD	1,NUMBR		;COMPUTE ADDRESS OF FIRST FREE BUFFER WORD
	CAMN	1,LOOK		;IS THIS THE ADDRESS OF LOOKUP BLOCK?
	JRST	FNTST		;YES SO FINISHED
	JRST	SAVNAM		;NO SO CONTINUE
	JRST	SAVNAM		;GO AND STORE NAMES
COPY1:	MOVE	0,NUMBR		;COMPUTE NUMBER OF FILE WORDS IN-
	SUB	0,LOOK		;BUFFER. FORMULA IS :
	ADD	0,BEGIN		;NUMBR-(LOOK-BEGIN)-ARGNUM
	SUBI	0,ARGNUM	;OR: NUMBR-LOOK+BEGIN-ARGNUM
	MOVE	1,NUMLFT	;GET FILE LENGTH
	SUB	1,0		;COMPUTE NUMBER REMAINING
	SKIPG	1		;POSITIVE
	JRST	COPY2		;NO SO HANDLE SPECIALLY
	MOVEM	1,NUMLFT	;STORE NUMBER LEFT TO INPUT
	JRST	COPY4		;GO AND COPY
COPY2:	MOVE	2,NUMLFT	;GET FILE LENGTH
	CAMG	2,0		;IS ENTIRE FILE IN BUFFER
	JRST	SETLUK		;YES SO WE JUST SET NAME UP
	MOVEI	1,200		;GET BLOCK SIZE
	CAML	1,LENGTH	;LESS THAN REMAINDER OF COMP FILE?
	MOVE	1,LENGTH	;NO SO GET REMAINDER
	ADDM	1,NUMBR		;INCREMENT # OF DATA WORDS IN BUFFER
	MOVN	1,1		;GET NEG # OF WORDS TO BE READ
	ADDM	1,LENGTH	;DECREMENT AMOUNT OF COMP FILE LEFT
	AOS	BLKNUM		;INCREMENT BLOCK NUMBER
	HRL	1,1		;STORE # TO READ FOR IOWD
	HRR	1,BEGIN		;GET BUFFER START ADDRESS
	ADD	1,NUMBR		;ADD # OF DATA WORDS IN BUFFER
	SOS	1		;DECREMENT FIRST FREE WORD FOR IOWD
	SETZ	2,		;CLEAR END OF COMMAND LIST
	IN	2,1		;GET REMAINDER OF LOOKUP DATA
	SKIPA			;SUCCESS
	JRST	READER		;ERROR
	JRST	STRNM		;GO AND SET NAME
COPY4:	MOVE	2,NUMBR		;GET NUMBER OF DATA WORDS IN BUFFER
	CAMGE	2,OUTSYZ	;TEST IF ENOUGH TO WARRANT OUTPUT
	JRST	GETSUM		;NO SO FILL BUFFER
	IDIV	2,OUTSYZ	;COMPUTE HOW MANY OUTPUT BLOCKS
	IMUL	2,OUTSYZ	;AS A NUMBER OF WORDS
	HRR	1,BEGIN		;GET START ADDRESS FOR OUTPUT
	ADDM	2,BEGIN		;RESET BEGIN POINTER
	MOVN	2,2		;GET AS A NEGATIVE #
	HRL	1,2		;SET IN IOWD
	SOS	1		;DECREMENT FOR IOWD
	SETZ	2,		;CLEAR END OF COMMAND LIST
	OUTPUT	3,1		;OUTPUT A BUFFER FULL
	STATZ	3,740000		;CHECK OUTPUT STATUS
	JRST	OUTERR		;ERROR
	MOVEM	3,NUMBR		;STORE # OF DATA WORDS LEFT IN BUFFER
GETSUM:	SKIPE	0,NUMBR		;TEST IF NO MORE DATA WORDS LEFT
	JRST	SETIN1		;YES SO DONT RESET POINTERS
	MOVEI	0,FIRST		;GET BUFFER START ADDRESS
	MOVEM	0,BEGIN		;RESET FIRST DATA WORD POINTER
SETIN1:	MOVE	1,BEGIN		;GET FIRST DATA WORD POINTER
	ADD	1,NUMBR		;COMPUTE FIRST FREE WORD ADDRESS
	SOS	1		;COMPUTE LAST DATA WORD ADDRESS
	MOVE	2,LAST		;GET END OF BUFFER ADDRESS
	SUB	2,1		;COMPUTE # OF FOLLOWING FREE WORDS IN BUFFER
	IDIV	2,OUTSYZ	;COMPUTE # OF AVAILABLE OUTPUT BLOCKS
	IMUL	2,OUTSYZ	;COMPUTE AS A NUMBER OF WORDS
	JUMPE	2,BLT2		;IF NONE GO AND BLT THE DATA IN BUFFER
	CAML	2,NUMLFT	;LESS SPACE
	JRST	GETLST		;PLENTY OF SPACE SO GET REMAINDER OF FILE
	ADDM	2,NUMBR		;INCREMENT # OF DATA WORDS
	MOVN	2,2		;GET # TO READ AS A NEGATIVE #
	ADDM	2,NUMLFT	;DECREMENT # LEFT TO READ
	HRL	1,2		;STORE FOR IOWD
	ADDM	2,LENGTH	;DECREMENT FILE LENGTH LEFT
	MOVN	2,2		;GET POSITIVE # OF WORDS TO BE READ
	IDIVI	2,200		;CONVERT TO A NUMBER OF BLOCKS
	ADDM	2,BLKNUM	;INCREMENT DISC BLOCK NUMBER
	SETZ	2,		;CLEAR END OF COMMAND LIST
	IN	2,1		;GET DATA
	SKIPA			;SUCCESS
	JRST	READER		;ERROR
	SKIPE	0,NUMLFT	;TEST REMAINDER
	JRST	COPY4		;GET NEXT BLOCK IN
	JRST	GETLST		;GET LAST BLOCK
BLT2:	HRL	0,BEGIN		;GET DATA START ADDRESS FOR BLT
	HRRI	0,FIRST		;GET DESTINATION ADDRESS FOR BLT
	MOVEI	1,FIRST-1	;GET FIRST-1
	ADD	1,NUMBR		;COMPUTE LAST BLT ADDRESS
	BLT	0,0(1)		;MOVE DATA
	MOVEI	1,FIRST		;GET ADDRESS OF FIRST DATA WORD
	MOVEM	1,BEGIN		;STORE
	JRST	SETIN1		;GO AND READ
GETLST:	MOVN	3,NUMLFT	;GET NUMBER OF WORDS LEFT TO READ
	ADDM	3,LENGTH	;DECREMENT FILE LENGTH
	SKIPN	4,LENGTH	;IS LENGTH STILL POSITIVE
	JRST	WRAPUP		;NO SO GET THE LAST BIT IN
	MOVEI	3,ARGNUM	;GET # OF ARGUMENTS
	SUB	4,3		;SUBTRACT FROM COMP FILE LENGTH
	MOVEM	4,LENGTH	;STORE LENGTH
	ADD	3,NUMLFT	;COMPUT LENGTH PLUS NEXT FILE ARG BLOCK
	MOVE	4,3		;GET A COPY
	IDIVI	4,200		;COMPUTE AS A # OF BLOCKS
	SKIPE	5		;TEST REMAINDER
	AOS	4		;ROUND UP
	ADDM	4,BLKNUM	;STORE BLOCK NUMBER
	MOVEI	6,200		;GET BLOCK LENGTH
	SUB	6,5		;COMPUTE # OF NEXT FILE WORDS
	CAML	6,LENGTH	;TEST AGAINST LENGTH
	MOVE	6,LENGTH	;USE LENGTH
	ADD	3,6		;COMPUTE # OF WORDS TO READ
	MOVN	0,6		;GET LENGTH AS NEG NUM
	ADDM	0,LENGTH	;DECREMENT LENGTH REMAINING
	MOVE	4,1		;GET LAST DATA WORD ADDRESS
	ADD	4,NUMLFT	;ADD # OF THIS FILE WORDS TO BE READ
	AOS	4		;COMPUTE ADDRESS OF NEXT LOOKUP DATA
	MOVEM	4,LOOK		;STORE
	ADDM	3,NUMBR		;ADD NUMBER OF WORDS TO BE READ
	MOVN	3,3		;GET NEG # OF WORDS TO BE READ
	HRL	1,3		;STORE IN IOWD
	SETZ	2,		;CLEAR END OF COMMAND LIST
	IN	2,1		;GET DATA
	SKIPA			;SUCCESS
	JRST	READER		;ERROR
	MOVE	1,2(4)		;GET NEXT FILE NAME
	MOVEM	1,NAM		;STORE
	MOVE	1,3(4)		;GET EXTENSION
	HLLZM	1,EXT		;STORE
	MOVE	1,5(4)		;GET FILE LENGTH
	MOVEM	1,NUMLFT	;STORE
	JRST	DELNXT		;GO FOR NEXT FILE
WRAPUP:	MOVN	0,NUMLFT	;GET LENGTH OF FILE LEFT
	HRL	1,0		;STORE IN IOWD
	MOVE	0,NUMLFT	;GET NUMBER TO BE READ
	ADDM	0,NUMBR		;INCREMENT # OF WORDS IN BUFFER
	JUMPE	0,FNTST		;IF NONE TO READ DON"T TRY
	SETZ	2,		;CLEAR END OF COMMAND LIST
	IN	2,1		;GET DATA
	SKIPA			;SUCCESS
	JRST	READER		;ERROR
FNTST:	SKIPE	UPDATE		;ARE WE IN UPDATE MODE?
	JRA	16,0(16)	;YES SO RETURN TO CALLER
	MOVN	0,NUMBR		;GET NEG # OF WORDS IN BUFFER
	HRL	1,0		;SETUP IOWD
	HRR	1,BEGIN		;SET START ADDRESS
	SOS	1		;DECREMENT FOR IOWD
	SETZ	2,		;CLEAR END OF COMMAND LIST
	OUTPUT	3,1		;CLEAR BUFFER TO OUTPUT
	STATZ	3,740000		;CHECK STATUS
	JRST	OUTERR		;ERROR
	CLOSE	3,		;CLOSE THE CHANNEL
	JRA	16,0(16)	;RETURN TO CONTROL ROUTINE
ALLCPY:	MOVE	0,NUMBR		;GET NUMBER OF DATA WORDS IN BUFFER
	IDIV	0,OUTSYZ	;COMPUTE # OF OUTPUT BLOCKS
	IMUL	0,OUTSYZ	;CONVERT TO # OF WORDS
	JUMPE	0,BLT3		;IF TOO SMALL SIMPLY TRANSFER DATA
	MOVN	1,0		;GET AS A NEG NUM
	ADDM	1,NUMBR		;DECREMENT # OF DATA WORDS LEFT IN BUF
	HRL	1,1		;SET UP IOWD
	HRR	1,BEGIN		;SET DATA START ADDRESS
	SOS	1		;DECREMENT FOR IOWD
	SETZ	2,		;CLEAR END OFF COMMAND LIST
	OUTPUT	3,1		;OUTPUT DATA
	STATZ	3,740000		;CHECK STATUS
	JRST	OUTERR		;ERROR
	ADDM	0,BEGIN		;POINT TO START OF DATA
	JRST	ALLCPY		;TRY AGAIN
BLT3:	HRRZ	0,BEGIN		;GET DATA START ADDRESS
	CAIN	0,FIRST		;IS IT BEGINNING OF BUFFER?
	JRST	STRT		;YES SO DONT BLT
	SKIPN	1,NUMBR		;IS THERE SOME DATA IN BUFFER?
	JRST	STRT		;NO SO DONT BLT
	HRL	0,0		;SET BLT SOURCE ADDRESS
	HRRI	0,FIRST		;SET DESTINATION ADDRESS
	ADDI	1,FIRST-1	;SET LAST WORD TO BE WRITTEN ADDRESS
	BLT	0,0(1)		;MOVE DATA
STRT:	MOVEI	0,FIRST		;GET DATA START ADDRESS
	MOVEM	0,BEGIN		;STORE
	SKIPN	LENGTH		;FINISHED COMP FILE READING?
	JRST	FNTST		;YES SO CLEAN UP
	MOVE	0,LAST		;GET END OF BUFFER ADDRESS
	SUBI	0,FIRST-1	;COMPUTE BUFFER LENGTH
	SUB	0,NUMBR		;COMPUTE # OF FREE BUFFER WORDS
	IDIV	0,OUTSYZ	;COMPUTE # OF FREE OUTPUT BLOCKS
	IMUL	0,OUTSYZ	;COMPUTE # OF FREE OUTPUT BLOCK WORDS
	CAMLE	0,LENGTH	;TEST AGAINST REMAINING FILE LENGTH
	MOVE	0,LENGTH	;GREATER SO USE FILE REMAINDER
	MOVN	1,0		;GET AS A NEGITVE #
	ADDM	1,LENGTH	;DECREMENT AMOUNT OF FILE REMAINING
	HRL	1,1		;SET LENGTH TO READ IN IIOWD
	HRR	1,BEGIN		;GET DATA START ADDRESS
	ADD	1,NUMBR		;COMPUTE FIRST FREE WORD ADDRESS
	SOS	1		;DECREMENT FOR IOWD
	SETZ	2,		;CLEAR END OF COMMAND LIST
	IN	2,1		;GET DATA
	SKIPA			;SUCCESS
	JRST	READER		;ERROR
	ADDM	0,NUMBR		;INCREMENT # OF DATA WORDS IN BUFFER
	SKIPE	LENGTH		;TEST IF SOME COMP FILE LEFT TO READ
	JRST	ALLCPY		;NO SO CLEAN UP
	JRST	FNTST		;FINISHED

;ROUTINE TO TEST IF MORE FILES TO BE DELETED

MORDEL:	0
	MOVE	1,NAMLST	;GET NAME LIST START ADDRESS
LST1:	HRRZ	2,1(1)		;GET A NAME
	SKIPN	2		;TEST IF NULL
	JRA	16,1(16)	;NO SO NOT FINISHED DELETING
	ADDI	1,2		;INCREMENT NAME LIST POINTER
	CAMN	1,NAME		;DONE?
	JRA	16,0(16)	;YES SO NONE LEFT TO DELETE
	JRST	LST1		;TRY NEXT LIST ENTRY

;ROUTINE TO TEST IF THIS FILE TO BE DELETED

THIS1:	0
	MOVE	1,NAMLST	;GET LIST START ADDRESS
LST2:	HRRZ	2,1(1)		;GET EXTENSION WORD
	SKIPE	2		;TEST IF NULL
	JRST	LST3		;NON NULL SO ALREADY DONE
	MOVE	2,0(1)		;GET NAME
	CAME	2,NAM		;TEST FILE NAME
	JRST	LST3		;NO MATCH
	MOVE	2,1(1)		;GET EXTENSION
	CAME	2,EXT		;TEST EXTENSION
	JRST	LST3		;NO MATCH
	SKIPN	UPDATE		;UPDATE MODE?
	JRST	FOUND1		;NO SO DONT LOOKUP
	MOVE	2,0(1)		;GET NAME
	HLLZ	3,1(1)		;GET EXTENSION
	MOVE	5,PPN		;GET PPN
	LOOKUP	10,2		;DO LOOKUP
	JRST	NODEAL		;FAIL SO DONT DELETE
	JRST	FOUND1		;OK ITS ON DISC
LST3:	ADDI	1,2		;INCREMENT LIST POINTER
	CAMN	1,NAME		;TEST IF LIST EXHAUSTED
	JRA	16,0(16)	;YES SO DONT DELETE THIS ONE
	JRST	LST2		;TRY NEXT NAME
FOUND1:	MOVEI	3,1		;GET A 1
	HRRM	3,1(1)		;SET HANDLED BIT
	JRA	16,1(16)	;RETURN AND DELETE
NODEAL:	TTCALL	3,[ASCIZ/
FILE /]
	JSA	16,TYPE		;TYPE FILE NAME & EXTENSION
	TTCALL	3,[ASCIZ/ NOT ON DISC
/]
	MOVEI	3,3		;GET CODE
	HRRM	3,1(1)		;STORE NO DELETE CODE
	JRA	16,0(16)	;RETURN AND DONT DELETE

;ROUTINE TO CONTRL DELETION OF FILES FROM COMPRESSED FILE

DELEET:	0
	SETOM	DELOPR		;NDICATE THAT WE ARE DELETING
	TTCALL	3,[ASCIZ/
ENTER NAME OF COMPRESSED FILE */]
	JSA	16,SETCM	;GET COMPRESSED FILE DATA
	TTCALL	3,[ASCIZ/
WHERE ARE NAMES OF FILES TO BE DELETED (TYPE TTY OR DSK)
*/]
	JSA	16,SELDEL
	JSA	16,DELETE
	CALLI	0,12		;EXIT

;ROUTINE TO OUTPUT A SORTED DIRECTORY OF A COMPRESSED FILE

DIREC:	0
	JSA	16,SETCMP	;GET COMPRESSED FILE NAME AND LOOK IT UP
	SETOM	DIR		;INDICATE DIRECTORY SEARCH IN PROGRESS
	TTCALL	3,[ASCIZ/WHERE DO YOU WANT LISTING (TYPE TTY OR DSK)*/]
	JSA	16,SETTTY	;INITIALIZE TTY
TRY2:	JSA	16,GETNAM	;GET DESTINATION DEVICE
	CAMN	0,TTY		;TTY?
	JRST	OKDV		;YES OK
	CAMN	0,DSK		;DISC?
	JRST	OKDV		;YES OK
	TTCALL	3,[ASCIZ/ERROR PLEASE TYPE TTY OR DSK*/]
	JSA	16,SETTTY	;INITIALIZE TTY
	JRST	TRY2
OKDV:	MOVEM	0,OUTDEV	;STORE DEVICE NAME FOR INIT
	INIT	10,0		;INIT CHANNEL 10
OUTDEV:	0
	XWD	PRNHED,0	;OUTPUT BUFFER
	HALT			;ERROR
	MOVE	1,[XWD 400000,PRNBUF+1];SET HEADER
	MOVEM	1,PRNHED	;STORE
	MOVE	1,[POINT 7,0,35];SET BYTE POINTER
	MOVEM	1,PRNHED+1	;STORE
	CAME	0,DSK		;DISC OUTPUT?
	JRST	SETLST		;NO SO DONT ENTER
TRY3:	TTCALL	3,[ASCIZ/TYPE NAME TO BE GIVEN TO DIRECTORY FILE*/]
	JSA	16,SETTTY	;INITIALIZE TTY
	JSA	16,GETNAM	;GET FILE NAME
	SETZ	3,		;CLEAR AC3
	ENTER	10,0		;DO FILE CREATION
	SKIPA			;CANNOT ENTER
	JRST	SETLST		;CONTINUE
	TTCALL	3,[ASCIZ/NAME IN USE PLEASE TRY ANOTHER
/]
	JRST	TRY3		;TRY AGAIN
SETLST:	OUTPUT	10,0		;DUMMY OUTPUT TO SETUP BUFFERS
	HLRZ	DIRAD,JOBSA	;GET FIRST FREE WORD ADDRESS
	MOVEM	DIRAD,DIRLST	;STOR AS LIST START ADDRESS
	JSA	16,READ2	;DO THE FIRST READ
NXTDIR:	JSA	16,DIRCOR	;DO CORE MANAGEMENT
	AOS	COUNT		;INCREMENT FILE COUNTER
	JSA	16,EXTRCT	;GET FILE DATA
	JUMP			;CANNOT COME HERE SINCE DIR=-1
	MOVE	0,FYLNAM	;GET FILE NAME
	MOVEM	0,0(DIRAD)	;STORE IN LIST
	HLLZ	0,FYLNAM+1	;GET EXTENSION
	HLLZM	0,1(DIRAD)	;STORE IN LIST
	MOVE	2,[POINT 11,FYL1+4,23];POINTER TO TIME FIELD
	LDB	0,2		;GET TIME
	HRLZM	0,3(DIRAD)	;STORE IN LIST
	MOVE	2,[POINT 12,FYL1+4,35];POINTER TO DATE FIELD
	LDB	0,2		;GET CREATION DATE
	HRRM	0,1(DIRAD)	;STORE IN LIST
	MOVE	0,FYL1+5	;GET LENGTH
	MOVEM	0,2(DIRAD)	;STORE
	JSA	16,CYCLE	;CYCLE TO NEXT FILE
	ADDI	DIRAD,4		;INCREMENT POINTER TO LIST
	JSA	16,FINISH	;TEST IF DONE
	JRST	NXTDIR		;NO-SO PROCESS NEXT FILE
	JSA	16,SORT		;SORT THE LIST
	JSA	16,OUTHED	;PRINT HEADING
	MOVE	DIRAD,DIRONE	;GET SORTED LIST FIRST ENRTY ADDRESS
NXTDT:	JSA	16,OUTDAT	;OUTPUT DATA
	HRRZ	DIRAD,3(DIRAD)	;GET ADDRESS OF NEXT LIST ENTRY
	CAIE	DIRAD,-1	;LAST LIST ENTRY?
	JRST	NXTDT		;NO SO PROCESS NEXT ENTRY
FINFYL:	JSA	16,TOTFYL	;TYPE TOTAL MESSAGE
	MOVE	2,COUNT		;GET FILE COUNTER
	JSA	16,OUTLEN	;PRINT NUMBER OF FILES
	JSA	16,CLEER	;DO THE LAST OUTPUT
	CLOSE	10,0		;CLOSE THE FILE
	RESET			;RESET CHANNELS (OTHERWISE TTY PROBLEMS)
	CALLI	0,12		;EXIT

;ROUTINE TO SORT DIRECTORY LIST BY NAME ONLY

SORT:	0
	MOVE	0,DIRAD		;GET LAST+1 ENTRY ADDRESS
	SUB	0,DIRLST	;SUBTRACT FIRST ENTRY ADDRESS
	IDIVI	0,4		;COMPUTE # OF ENTRIES IN LIST
	MOVEI	2,DIRONE-3	;GET ADDRESS OF FIRST FILE IN LIST-3
RESET:	MOVE	3,DIRLST	;GET LIST START ADDRESS
	HRLOI	1,377777	;GET LARGEST POSITIVE INTEGER
GETDIR:	MOVE	5,0(3)		;GET FILENAME FROM LIST
	HRRZ	7,3(3)		;GET POINTER TO NEXT LIST WORD
	JUMPN	7,INCR		;IF POINTER SET ALREADY THEN IGNORE
	CAMLE	5,1		;TEST IF FILENAME LESS THAN LAST ONE
	JRST	INCR		;NO SO IGNORE
	EXCH	5,1		;STORE FILENAME FOR NEXT PASS
	MOVE	6,3		;SET ADDRESS IN AC6
INCR:	ADDI	3,4		;INCREMENT LIST POINTER
	CAME	3,DIRAD		;FINISHED THIS PASS?
	JRST	GETDIR		;NO SO TRY AGAIN
	HRRM	6,3(2)		;SET LIST POINTER TO WORD JUST FOUND
	HRRM	6,3(6)		;SET POINTER FIELD OF WORD JUST FOUND
	EXCH	2,6		;SAVE ADDRESS OF WORD JUST FOUND
	SOJN	0,RESET		;TEST IF ALL PASSES COMPLETE
	HRRZI	0,-1		;GET -1 IN RH OF AC0
	HRRM	0,3(2)		;STORE IN POINTER FIELD OF LAST FILE
	JRA	16,0(16)	;RETURN

;ROUTINE TO CONTROL GETTING OF CORE

DIRCOR:	0
	MOVE	0,DIRAD		;GET CURRENT HIGHEST USED LIST ADDRESS
	ADDI	0,4		;INCREMENT
	CAMG	0,JOBREL	;TEST IF WE EXCEED CURRENT CORE SIZE
	JRA	16,0(16)	;NO SO RETURN
	CALLI	0,11		;GET CORE
	SKIPA			;NONE LEFT
	JRA	16,0(16)	;RETURN
	TTCALL	3,[ASCIZ/INSUFFICIENT CORE TO ALLOW DIRECTORY READING/]
	CALLI	0,12		;EXIT

;ROUTINE TO OUTPUT A CHARACTER TO OUTPUT DEVICE

OUTCHR:	0
	SOSG	PRNHED+2	;IS BUFFER FULL?
	JRST	PUTOUT		;YES S EMPTY IT
STORIT:	IDPB	0,PRNHED+1	;STORE THE CHARACTER IN AC0
	JRA	16,0(16)	;RETURN
CLEER:	0			;ENTRY FOR LAST OUTPUT
PUTOUT:	OUT	10,		;OUTPUT THE BUFFER
	JRST	STORIT		;STORE DATA
	TTCALL	3,[ASCIZ/
SYSTEM ERROR WHILST WRITING FILE/]
	CALLI	1,12		;EXIT

;ROUTINE TO OUTPUT DIRECTORY FILE DATA

OUTDAT:	0
	MOVE	1,0(DIRAD)	;GET NAME
	MOVE	2,[POINT 6,1,]	;GET A SIXBIT POINTER
	MOVEI	3,6		;SET CHARACTER COUNTER
LOAD1:	ILDB	0,2		;GET A CHARACTER OF NAME
	JUMPE	0,EXTN1		;IF NULL GO FOR EXTENSION
	ADDI	0,40		;CONVERT
	JSA	16,OUTCHR	;OUTPUT
	SOJG	3,LOAD1		;NEXT CHARACTER
EXTN1:	MOVEI	0,11		;GET A TAB
	JSA	16,OUTCHR	;OUTPUT
	MOVE	1,1(DIRAD)	;GET EXTENSION
	MOVEI	3,3		;SET CHARACTER COUNTER
	MOVE	2,[POINT 6,1,]	;GET A SIXBIT POINTER
LOAD2:	ILDB	0,2		;GET A CHARACTER OF EXTENSION
	JUMPE	0,DATE		;IGNORE IF NULL
	ADDI	0,40		;CONVERT
	JSA	16,OUTCHR	;OUTPUT
	SOJG	3,LOAD2		;TEST IF DONE
DATE:	MOVEI	0,11		;GET A TAB
	JSA	16,OUTCHR	;OUTPUT
	HRRZ	1,1(DIRAD)	;GET DATE
	IDIVI	1,^D31		;GET DAY # IN AC1
	ADDI	2,1		;INCREMENT
	IDIVI	2,^D10		;SEPARATE TENS AND UNITS
	ADDI	2,60		;CONVERT
	ADDI	3,60		;CONVERT
	MOVE	0,2		;GET TENS
	JSA	16,OUTCHR	;OUTPUT
	MOVE	0,3		;GET UNITS
	JSA	16,OUTCHR	;OUTPUT
	IDIVI	1,^D12		;GET MONTH # IN AC2
	MOVEI	3,5		;SET CHARACTER COUNTER
	MOVE	4,[POINT 7,MONTH(2),];GET POINTER TO APPROPRIATE MONTH
NXMONT:	ILDB	0,4		;GET A CHARACTER
	JSA	16,OUTCHR	;OUTPUT IT
	SOJG	3,NXMONT	;GO FOR NEXT CHARACTER
	ADDI	1,^D64		;ADD BASE YEAR
	IDIVI	1,^D10		;GET UNITS IN AC2
	ADDI	1,60		;CONVERT TENS OF YEARS
	MOVE	0,1		;GET TENS
	JSA	16,OUTCHR	;OUTPUT TENS OF YEARS
	ADDI	2,60		;CONVERT UNITS
	MOVE	0,2		;GET UNITS
	JSA	16,OUTCHR	;OUTPUT
	MOVEI	0,11		;GET A TAB
	JSA	16,OUTCHR	;OUTPUT
	HLRZ	1,3(DIRAD)	;GET CREATIN TIME
	IDIVI	1,^D60		;GET MINUTES IN AC2
	MOVE	3,1		;GET TENS OF HOURS IN A CONVENIENT SPOT
	IDIVI	3,^D10		;PUT UNITS OF HOURS IN AC4
	MOVE	0,3		;GET TENS OF HOURS
	ADDI	0,60		;CONVERT
	JSA	16,OUTCHR	;OUTPUT TENS OF HOURS
	MOVE	0,4		;GET UNITS OF HOURS
	ADDI	0,60		;CONVERT
	JSA	16,OUTCHR	;OUTPUT
	MOVEI	0,72		;GET A COLON
	JSA	16,OUTCHR	;OUTPUT
	IDIVI	2,^D10		;PUT UNITS OF MINUTES IN AC3
	ADDI	2,60		;CONVERT TENS OF MINUTES
	MOVE	0,2		;GET TENS OF MINUTES
	JSA	16,OUTCHR	;OUTPUT
	MOVE	0,3		;GET UNITS OF MINUTES
	ADDI	0,60		;CONVERT
	JSA	16,OUTCHR	;OUTPUT
	MOVEI	0,11		;GET A TAB
	JSA	16,OUTCHR	;OUTPUT
	MOVE	2,2(DIRAD)	;GET FILE LENGTH
	JSA	16,OUTLEN	;OUTPUT LENGTH
	JRA	16,0(16)	;RETURN

;ROUTINE TO OUTPUT DIRECTORY HEADER

OUTHED:	0
	MOVE	1,[POINT 7,TITLE,];GET A POINTER TO HEADER STRING
NXTHED:	ILDB	0,1		;GET A CHARACTER
	JUMPE	0,GOBAK		;IF NULL THEN FINISHED
	JSA	16,OUTCHR	;OUTPUT
	JRST	NXTHED		;TRY AGAIN
GOBAK:	JRA	16,0(16)	;RETURN

;ROUTINE TO TEST IF COMPRESSED FILE IS FINISHED

FINISH:	0
	SKIPE	LENGTH		;IF NON NULL THEN SOME LEFT
	JRA	16,0(16)	;RETURN, SOME LEFT
	SKIPE	NUMBR		;IF NULL THEN FINISHED
	JRA	16,0(16)	;RETURN, SOME LEFT
	JRA	16,1(16)	;RETURN, FINISHED

;ROUTINE TO ALLOW UPDATING OF FILES

UPDTE:	0
	SETOM	DELOPR		;INDICATE THAT WE ARE DELETING TOO
	SETOM	UPDATE		;INDICATE THAT WE ARE IN UPDATE MODE
	TTCALL	3,[ASCIZ/
ENTER NAME OF COMPRESSED FILE TO BE UPDATED */]
	JSA	16,SETCM	;GET COMPRESSED FILE DATA
	TTCALL	3,[ASCIZ/WHERE ARE NAMES OF FILES TO BE UPDATED (TYPE TTY OR DSK)*/]
	JSA	16,SELDEL	;GET FILE NAMES
	INIT	10,0		;INIT THE CHANNEL USED FOR FILE LOOKUPS
	SIXBIT/DSK/
	0
	HALT
	JSA	16,DELETE	;DELETE FILES FIRST
	INIT	2,16		;REINITIALIZE INPUT CHANNEL
	SIXBIT/DSK/
	0
	HALT
	MOVE	DIRAD,NAMLST	;GET LIST START ADDRESS
	SUBI	DIRAD,2		;DECREMENT FOR INLIST ROUTINE
	JSA	16,GETFYL	;GET FILES IN
	JSA	16,FINPAK	;FINISH OUTPUTTING
	CALLI	0,12		;EXIT

;ROUTINE TO GET A NAME FROM LIST FOR UPDATING

INLIST:	0
INLST1:	ADDI	DIRAD,2		;INCREMENT LIST POINTER TO NEXT FILE
	CAMN	DIRAD,NAME	;LIST FINISHED?
	JRA	16,0(16)	;YES SO RETURN
	HRRZ	0,1(DIRAD)	;GET DELETE CODES
	CAIN	0,3		;IF 3 THEN DONT TRY TO READ
	JRST	INLST1		;TRY NEXT LIST ENTRY
	JUMPE	0,INLST1	;IF ZERO THEN FILE WASN'T IN COMP FILE
	MOVE	0,0(DIRAD)	;GET NAME
	MOVEM	0,NAM		;STORE
	MOVE	0,1(DIRAD)	;GET EXTENSION
	HLLZM	0,EXT		;STORE
	JRA	16,1(16)	;SKIP RETURN

;ROUTINE TO ALLOW FILES TO BE APPENDED TO A COMPRESSED FILE

APEND:	0
	SETOM	DELOPR		;SET TO NON NULL
	SETOM	UPDATE		;SET TO NON NULL
	TTCALL	3,[ASCIZ/
ENTER NAME OF COMPRESSED FILE TO BE APPENDED TO */]
	JSA	16,SETCM	;GET COMPRESSED FILE DATA
	TTCALL	3,[ASCIZ/WHERE ARE NAMES OF FILES TO BE APPENDED TO
COMPRESSED FILE (TYPE TTY OR DSK)*/]
CRENTR:	JSA	16,SELDEL	;GET FILE NAMES
	INIT	10,0		;INIT LOOKUP CHANNEL
	SIXBIT/DSK/
	0
	HALT
	MOVE	DIRAD,NAMLST	;GET NAME LIST START
	SKIPA			;SKIP
APEND1:	ADDI	DIRAD,2		;POINT TO NEXT LIST ENTRY
	CAMN	DIRAD,NAME	;FINISHED WITH LIST?
	JRST	APEND3		;YES
	MOVE	0,0(DIRAD)	;GET NAME
	MOVE	1,1(DIRAD)	;GET EXTENSION
	MOVE	3,PPN		;GET PPN
	LOOKUP	10,0		;DO THE LOOKUP
	JRST	APEND2		;FAILED
	AOS	1(DIRAD)	;SET SUCCESS BIT IN LIST
	JRST	APEND1		;TRY NEXT LIST ENTRY
APEND2:	MOVEM	0,NAM		;STORE NAME FOR TYPEOUT
	MOVEM	1,EXT		;STORE
	TTCALL	3,[ASCIZ/FILE /]
	JSA	16,TYPE		;TYPE NAME
	TTCALL	3,[ASCIZ/ NOT ON DISC
/]
	MOVEI	0,3		;DONT USE
	HRRM	0,1(DIRAD)	;STORE DONT USE CODE
	JRST	APEND1		;TRY NEXT LIST ENTRY
APEND3:	MOVE	0,LENGTH	;GET COMP FILE LENGTH
	SKIPN	0,0		;IF NON ZERO SKIP
	AOJA	0,APEND4	;MAKE 1 AND DONT READ FILE
	IDIVI	0,200		;CONVERT TO A BLOCK NUMBER
	MOVEM	1,NUMBR		;STORE REMAINDER
	SKIPE	NUMBR		;TEST IF REMAINDER IS NULL
	AOS	0		;INCREMENT BLOCK NUMBER
	JUMPE	1,APEND4	;IF NULL DONT DO INPUT
	MOVN	1,1		;GET REMAINDER AS NEG # FOR IOWD
	HRL	1,1		;SET IOWD
	HRRI	1,FIRST-1	;SET DESTINATION ADDRESS
	HLL	0,[USETI 2,0]	;GET A USETI ON INPUT CHANNEL
	XCT	0		;EXECUTE IT
	SETZ	2,		;CLEAR END OF COMMAND LIST
	IN	2,1		;GET LAST BLOCK OF FILE
	SKIPA			;SUCCESS
	JRST	READER		;ERROR
APEND4:	INIT	2,16		;RE INIT INPUT CHANNEL
	SIXBIT/DSK/
	0
	HALT
	MOVE	1,CMPNAM	;GET COMPRESSED FILE NAME
	MOVE	2,CMPEXT	;GET EXTENSION
	SETZ	4,		;CLEAR PPN
	SETZ	3,		;CLEAR AC 3
	LOOKUP	3,1		;FIND THE FILE AGAIN
	HALT
	SETZ	4,		;CLEAR PPN
	SETZ	3,		;CLEAR OLD GARBAGE FROM LOOKUP
	ENTER	3,1		;ALLOW UPDATING OF COMP FILE
	HALT
	HLL	0,[USETO 3,0]	;GET A USETO ON OUTPUT CHANNEL
	XCT	0		;EXECUTE IT
	MOVEI	0,FIRST		;GET ADDRESS OF BUFFER START
	MOVEM	0,BEGIN		;STORE FIRST FREE BUFFER WORD ADDRESS
	MOVE	DIRAD,NAMLST	;GET LIST START ADDRESS
	SUBI	DIRAD,2	;DECREMENT FOR INLIST ROUTINE
	JSA	16,GETFYL	;READ FILES
	JSA	16,FINPAK	;FINISH OUTPUT
	RELEASE			;RELEASE DEVICES(OTHERWISE TTY FAILS)
	CALLI	1,12		;EXIT

;SUBRROTINE TO ALLOW COMPRESSED FILES TO BE CREATED FROM A LIST
;OF FILE NAMES

CREATE:	0
	SETOM	DELOPR		;SET DELETE WORD
	SETOM	UPDATE		;SET UPDATE MODE
	JSA	16,GETCMP	;GET COMPRESSED FILE NAME
	CLOSE	3,		;CREATE AN EMPTY FILE
	JSA	16,GETPPN	;GET PPN FOR INPUT FILES
	TTCALL	3,[ASCIZ/WHERE ARE NAME OF FILES TO BE COMPRESSED
(TYPE TTY OR DSK) */]
	JRST	CRENTR		;GO AND CREATE FILE

;ROUTINE TO PRINT PRINT NUMBER IN AC2

OUTLEN:	0
	MOVE	1,PDLST		;GET PUSHDOWN POINTER
	SETZ	5,		;CLEAR CHARACTER COUNTER
NXLEN:	IDIVI	2,^D10		;GET LOW ORDER DECIMAL IN AC3
	ADDI	3,60		;CONVERT
	PUSH	1,3		;PUT ON STACK
	AOS	5		;INCREMENT COUNTER
	JUMPN	2,NXLEN		;IF MORE LEFT GO AGAIN
POPNXT:	POP	1,0		;RETRIEVE CHARACTER
	JSA	16,OUTCHR	;OUTPUT
	SOJN	5,POPNXT	;TEST IF DONE
	MOVEI	0,15		;GET A CARRIAGE RETURN
	JSA	16,OUTCHR	;OUTPUT
	MOVEI	0,12		;GET A LINE FEED
	JSA	16,OUTCHR	;OUTPUT
	JRA	16,0(16)	;RETURN

;ROUTINE TO PRINT TOTAL FILES MESSAGE

TOTFYL:	0
	MOVE	1,[POINT 7,FILES,]	;GET ADDRESS OF MESSAGE
NXTOOT:	ILDB	0,1		;GET A CHARACTER
	JUMPE	0,NNLFT		;QUIT IF NULL
	JSA	16,OUTCHR	;PUT IN BUFFER
	JRST	NXTOOT		;TRY NEXT
NNLFT:	JRA	16,0(16)	;RETURN
;STORAGE AREA
COUNT:	0			;COUNT OF NUMBER OF FILES
FILES:	ASCIZ/
TOTAL FILES = /
HELLP:	ASCIZ/
COMPRS	CREATES A COMPRESSED FILE CONTAINING ALL FILES FROM THE SPECIFIED
	USER'S AREA.  THE COMPRESSED FILE IS GIVEN A NAME SPECIFIED BY
	THE USER.

DECOMP	SEPARATES ALL INDIVIDUAL FILES FROM THE COMPRESSED FILE AND STORES
	THEM ON DISC WITH THEIR ORIGINAL NAME, CREATION DATE ETC.

RESTOR	ALLOWS SUBSETS OF THE COMPRESSED FILE TO BE RESTORED TO DISC. THE
	USER MAY SPECIFY WHICH FILES ARE TO BE RESTORED, EITHER BY TYPING
	THE FILE NAMES OR BY SPECIFYING A DISC FILE CONTAINING THE LIST
	OF FILE NAMES.  IN EITHER METHOD THE FILE NAMES TO BE RESTORED ARE
	SEPARATED BY COMMAS.  FOR EXAMPLE:
		FILE1.DAT,FILE2,FILE3.SAV
		FILE4,FILE6.DAT
	DO NOT TYPE A COMMA AFTER THE LAST FILE NAME ON A LINE.  WHEN
	INPUTTING NAMES FROM THE TERMINAL YOU WILL BE PROMPTED AFTER
	EACH LINE BY AN ASTERISK, THE LIST IS TERMINATED BY TYPING A
	CARRIAGE RETURN AFTER THE LAST ASTERISK.

UPDATE	INDIVIDUAL FILES IN AN EXISTING COMPRESSED FILE MAY BE REPLACED
	BY A FILE ON DISC WITH THE SAME NAME.  FILES TO BE REPLACED ARE
	SPECIFIED AS DESCRIBED IN THE RESTOR COMMAND.  IF THE FILE TO
	BE REPLACED IS NOT ON DISC OR NOT IN THE COMPRESSED FILE NO CHANGE
	TAKES PLACE.

APPEND	NEW FILES MAY BE APPENDED TO THE COMPRESSED FILE.  THIS IS A
	VERY EFFICIENT (LOW COST) OPERATION.  FILES TO BE APPENDED ARE
	SPECIFIED AS DESCRIBED IN THE RESTOR COMMAND.  IT IS POSSIBLE TO
	HAVE A COMPRESSED FILE WITH TWO FILES OF THE SAME NAME IN IT.  IF
	THIS HAPPENS THEN THE UPDATE, RESTORE AND DELETE COMMANDS WILL
	OPERATE ON THE PHYSICALLY FIRST FILE IN THE COMPRESSED FILE.
	HOWEVER IF THE DECOMP COMMAND IS USED ON A COMPRESSED FILE
	CONTAINING TWO FILES WITH THE SAME NAME THE ONE WITH THE LATEST
	CREATION DATE AND TIME WILL BE RESTORED.

DELETE	FILES MAY BE DELETED FROM THE COMPRESSED FILE.  FILES TO BE DELETED
	ARE SPECIFIED AS DESCRIBED IN THE RESTOR COMMAND.

DIR	A DIRECTORY OF FILES IN THE SPECIFIED COMPRESSED FILE IS PRINTED
	ALPHABETICALLY BY FILE NAME.  THE DIRECTORY CAN BE LISTED ON THE
	TERMINAL OR STORED ON DISC.  THE CREATION DATE AND TIME AND
	FILE LENGTH IN WORDS IS LISTED FOR EACH FILE.

CREATE	CREATES A COMPRESSED FILE USING SPECIFIED INDIVIDUAL FILE NAMES.
	FILE NAMES ARE SPECIFIED AS DECRIBED IN THE UPDATE COMMAND.  FILES
	ARE OBTAINED FROM THE SPECIFIED USER NUMBER.

PLEASE TYPE COMMAND
*/
TITLE:	ASCIZ/
 NAME	EXT	   DATE		 TIME	LENGTH(WORDS)

/
MONTH:	ASCII/-JAN-/
	ASCII/-FEB-/
	ASCII/-MAR-/
	ASCII/-APR-/
	ASCII/-MAY-/
	ASCII/-JUN-/
	ASCII/-JUL-/
	ASCII/-AUG-/
	ASCII/-SEP-/
	ASCII/-OCT-/
	ASCII/-NOV-/
	ASCII/-DEC-/
PDL:	BLOCK 12		;FOR CHARACTER STORAGE
PDLST:	XWD	-12,PDL		;LIST HEADER
PRNHED:	BLOCK	3		;DIRECTORY OUTPUT BUFFER HEADER
PRNBUF:	0
	XWD	201,PRNBF2+1
	BLOCK	201
PRNBF2:	0
	XWD	201,PRNBF3+1
	BLOCK	201
PRNBF3:	0
	XWD	201,PRNBUF+1
	BLOCK	201
DIRLST:	0			;DIRECTORY LIST POINTER GOES HERE
DIRONE:	0			;ADDRESS OF SORTED DIRECTORY START
DELOPR:	0			;SET TO -1 IF DELETING
UPDATE:	0			;SET TO NON ZERO IF UPDATE IN PROCESS
LOOK:	0			;ADDRESS OF LOOKUP DATA WORD
MESSAG:	ASCIZ/
PLEASE TYPE ONE OF THE FOLLOWING COMMANDS:
HELP		FOR DETAILED INSTRUCTIONS
CREATE		TO CREATE A COMPRESSED FILE FROM INDIVIDUAL FILES
DECOMP		TO DECOMPRESS A FILE
COMPRS		TO CREATE A COMPRESSED FILE
UPDATE		TO MODIFY FILES IN A COMPRESSED FILE
APPEND		TO APPEND NEW FILES TO A COMPRESSED FILE
DELETE		TO DELETE FILES FROM A COMPRESSED FILE
RESTOR		TO DECOMPRESS FILES BY NAME FROM A COMPRESSED FILE
DIR		TO OBTAIN DIRECTORY LISTING OF COMPRESSED FILE
*/
UPDT:	SIXBIT/UPDATE/
DIRECT:	SIXBIT/DIR/
CRE:	SIXBIT/CREATE/
HLP:	SIXBIT/HELP/
DEC:	SIXBIT/DECOMP/
COMPRS:	SIXBIT/COMPRS/
APPND:	SIXBIT/APPEND/
DELT:	SIXBIT/DELETE/
RESTR:	SIXBIT/RESTOR/
UFDNAM:	3			;LOOKUP BLOCK EXTENDED
	0			;ADDRESS OF BLOCK CONTAINING USER NAME
	SIXBIT/JUNK/		;ARBITRARY FILE NAME
	SIXBIT/JNK/		;ARBITRARY EXTENSION
USRNAM:	BLOCK 2			;BLOCK FOR SIXBIT USER NAME
NAMLST:	0			;ADDRESS OF NAME LIST START STORED HERE
TTY:	SIXBIT/TTY/		;DEVICE NAME
DSK:	SIXBIT/DSK/		;DEVICE NAME
DSKFYL:	BLOCK 4			;LOOKUP BLOCK FOR DISC NAME FILE
FYLBUF:	BLOCK 3			;BUFFER HEADER FOR DISC FILE I/O CHAN
DSKBF1:	0			;BUFFER
	XWD	201,DSKBF2+1	;POINTER TO NEXT BUFFER IN RING
	BLOCK 201
DSKBF2:	0
	XWD	201,DSKBF3+1	;POINTER TO NEXT BUFFER IN RING
	BLOCK 201
DSKBF3:	0
	XWD	201,DSKBF1+1	;POINTER BACK TO BUFFER 1
	BLOCK 201
NODATE:	0			;FLAG TO IGNORE CREATION DATA IF NON ZERO
DIR:	0				;DIRECTORY SEARCH FLAG
REM:	0				;LOOKUP BLOCK WORK NUMBER
YES:	SIXBIT/YES/
NO:	SIXBIT/NO/
PPN:	0			;PROJECT PROGRAMMER NUMBER
NAM:	0			;FILENAME STORED HERE
EXT:	0			;FILE EXTENSION STORED HERE
BEGIN:	0			;POINTER TO FIRST BUFFER DATA WORD
NUMBR:	0			;NUMBER OF WORDS CURRENTLY IN BUFFER
	JRA	16,1(16)	;DATE OK
LENGTH:	0			;# OF WORDS IN COMP FILE STILL TO BE READ
BLKNUM:	0			;NUMBER OF LAST BLOCK READ INTO BUFFER
INSIZE:				;SIZE OF AN INPUT BLOCK
OUTSYZ:	1000			;CLUSTER SIZE

CMPNAM:	0			;NAME OF COMPRESSED FILE
CMPEXT:	0			;EXTENSION OF COMPRESSED FILE
NUMOUT:	0			;NUMBER OF COMPRESSED FILE WORDS PROCESSED
NUMIN:	0			;NUMBER OF WORDS TO TRANSFER FROM I/P TO O/P
NUMLFT:	0			;NUMBER OF FILE WORDS STILL TO BE OUTPUT
FYL1:	0			;NUMBER OF LOOKUP ARGS
	0			;PROJECT PROGRAMMER NUMBER
FYLNAM:	BLOCK ARGNUM-2		;REMAINDER OF LOOKUP/RENAME BLOCK
FIRST:	BLOCK 3777		;BUFFER AREA
LS:	0			;LAST BUFFER WORD
EXTRA:	BLOCK 200		;EXTRA WORDS FOR DELETE ROUTINE
LAST:	LS			;ADDRESS OF LAST BUFFER WORD
	END START
    *6$y(