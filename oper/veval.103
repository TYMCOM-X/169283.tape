FIND ENDINDPOOL,EOFLAB,EOF3:,%LIS.REF,NEW.PAGE,A
FIND LSTIFDIR,LSTIFCD,%INITPRIF,LINE.NUM,BEGLITPOOL,BEGINDPOOL,EOF:
FIND EDIT10,PAGE.NUM,PRINT.LINE
GLOBAL NCOPIES,COM.STR(0:72/CPW),C.STR.P,%NXTSRC,PROMPT:,A.PTR,PCTR.PTR
FIND C,%PR,%ERR,%THING.GETTER,TOK,VAL,PCTR,OLDIF,%MESS,%FIL.ERR
FIND OPTAB,NAEOPS,NIFOPS,N1WDOPS,NALLOPS
FIND SYMTAB,BIN
FIND %PASS2,Q,JOBSA,JOBFF,JOBCOR,%PASS1
GLOBAL MAP(0:127),%EVAL,%INITMAP,F,L,E,DONE:,%SET.OLD.EVAL,NEWMODE,ALTMOD:
GLOBAL LITTAB,INDTAB,PASS.TWO,CREF,NO.LST,NO.REL
GLOBAL F.VAR(0:WPF),F.LST(0:WPF),F.REL(0:WPF),F.ERR
FIND SYMBUF(0:SYMBUF.L),%INIT.SYM.PAK,%NEW.SYM.TBL,CUR.LIT.ADD,%SYMPOS,END.LIT.POOL
GLOBAL NOCORE:,ERR.VAR:,ERR.REL:,ERR.LST:,ERR.ERR:,INIT:
LOCAL I,J,K,CHRCNT,Z,START:,DEF.LST,DEF.REL,DEF.VAR
LOCAL COM.ST,COM.F,COM.P,C.STR(0:50),T.COR.CTL(0:1)
LOCAL GOT.T.COR:,ERR.TMP:
TABLE INITBIN(MAX.CH.MAP)[0,0,0,1,2,3,4,5,6,7,8,9,10,0,16,17,18,19,0,0,0,0] !CHAR CLASSES MARKED NON-ZERO FOR BINARY OPERATORS
LOCAL BINARY(MAX.CH.MAP)  !CHAR CLASSES MARKED NON-ZERO FOR BINARY OPERATORS

START:  GO TTY.IN      !THIS IS START LOCATION  "R VAS" GOES HERE
        [18,18]*[JOBFF,]_JOBSA !THIS IS START LOC + 1, RPG GOES HERE
        JOBSA_0
        T.COR.CTL(0) _ DEF.VAR   !VAS IN SIXBIT
        T.COR.CTL(1) _ IOWD(50,C.STR)
        ^OCT 16 _ [18,18]*[2,T.COR.CTL]
        EXU(OCT 47,OCT 16,OCT 44,GOT.T.COR)
        COM.ST _ 3  ! MUST BE ON FILE <JOB>VAS.TMP
        EXU(OCT 47,OCT 16,OCT 30) ! GET JOB NUMBER
        K _ ^OCT 16; I _ 100; COM.P _ CHPT(C.STR,-1)
        WHILE I>0 THEN DO
          [J;K] _ K DIVMOD I
          I _ I/10
          NCHV COM.P _ J+$0
        END
        J _ CHPT('VAS.TMP',-1)
        WHILE NCHV COM.P_NCHV J#EOLIT THEN NULL
        COM.F _ OPEN(C.STR,SEQUEN+INPUT+CHARACTER,ERR.TMP,BUFFERS)
        GO INIT
GOT.T.COR: COM.P _ CHPT(C.STR,-1); COM.ST _ 2
        GO INIT

TTY.IN: [18,18]*[JOBFF,]_JOBSA
        JOBSA_0
        COM.ST _ 1 ; COM.F _ TEL
INIT: ON.ALT.C


      I_0
      WHILE INC I<MAX.CH.MAP+1 THEN BINARY(I)_INITBIN(I)
      NCOPIES _ -1
      F _ 0
      E _ TEL
      EOFLAB _ EOF
      PASS.TWO _ 0
      LSTIFDIR _ 0
      LSTIFCD _ 0
      NEWMODE _ 1  !SWITCH FOR NEW AND OLD MODES
      INITPRIF
      PCTR _ 0
      END.LIT.POOL _ BEG.LIT.POOL _ -1
      END.IND.POOL _ BEG.IND.POOL _ -1

      SYMTAB _ NEW.SYM.TBL(2,0)
      LITTAB _ NEW.SYM.TBL(2,VIRGIN)
      INDTAB _ NEW.SYM.TBL(2,VIRGIN)
PROMPT: DO COM.ST OF 3
1:      MSG('$*'); COM.P _ GET.LINE(COM.F)
2:      IF NCHV COM.P = EOLIT THEN [CLOSEALL;EXIT] ELSE PCHV COM.P
3:      COM.P _ GET.LINE(COM.F)
END
I _ COM.P
 
        IF C_NCHV I=$_ THEN [NOREL_NOLST_1;COM.P_I;CREF_0;GO SCNVAR]
        IF C  = $, THEN DO    !LEADING COMMA MEANS NO REL WANTED
          NO.REL _ 1
          COM.P _ I
          GO SCN.LST
          END
        NO.REL _ 0
        SETFID(F.REL,@COM.P,DEF.REL,ERR.REL)
MSG('$'); WFID(F.REL)   !DEBUG
        IF C _ NCHV COM.P=$! THEN DO
           C.STR(0) _ OCT 637163.000000 ! SYS IN SIXBIT
           C.STR(1) _ NAMARG(F.REL) ! FILE NAME IN SIXBIT
           MOVE 4 FROM ALL 0 TO @C.STR(2)
           ^OCT 16 _ [18,18]*[1,C.STR]
           EXU(OCT 47,OCT 16,OCT 35)  !  RUN UUO
           MSG('$?'); W.FID(F.REL); MSG('.SAV NOT FOUND$'); EXIT
        END
OP.REL: BIN _ OPEN(-F.REL,DIRECT+OUTPUT+WORD,ERR.REL,BUFFERS)
SCN.LST: IF C = $_ THEN DO !MISSING LST FILE MEANS NONE WANTED
          NO.LST _ 1
          CREF _ 0    !NO LIST IMPLIES NO CREF ALSO
          GO SCN.VAR
        END
        NO.LST _ 0
        IF C # $, THEN [MESS(E,'$COMMA EXPECTED$'); GO PROMPT]
        SETFID(F.LST,@COM.P,DEF.LST,ERR.LST)
MSG('$'); WFID(F.LST)   !DEBUG
        L_OPEN(-F.LST,SEQUEN+OUTPUT+CHARACTER,ERR.LST,BUFFERS)
        CREF _ 0
        IF C _ NCHV COM.P = $/ THEN DO
          EIF NCHV COM.P = $C THEN DO   ! /C MEANS HE WANTS CREF
            CREF _ 1
            C _ NCHV COM.P
            END
          ELSE DO
            MESS(E,'$VALID SWITCHES ARE:$ /C FOR CREF$')
            GO PROMPT
            END
          END
        IF C # $_ THEN [MESS(E,'$BACK ARROW EXPECTED$'); GO PROMPT]

SCN.VAR: C.STR.P _ J _ CHPT(COM.STR,-1)  !SET UP PTR FOR COMMAND STRING
        NCHV J _ $,  !A DUMMY COMMA MAKES NXTSRC SIMPLER
        WHILE NCHV J _ NCHV COM.P # CARRET THEN NULL   !MOV ALL SRC NAMES
        IF COM.ST=2 THEN NCHV COM.P               !TO COM.STR BUFFER
        NXT.SRC

        PASS1    !OFF IT GOES, NEVER TO RETURN

ERR.VAR: FIL.ERR(F.VAR)
         GO RESTART
ERR.LST: FIL.ERR(F.LST)
         GO RESTART

ERR.REL: FIL.ERR(F.REL)
         GO RESTART



ERR.ERR:  MSG('$ERROR IN OPENING TERMINAL$'); EXIT
ERR.TMP: IF ERRNUM=EOFERR THEN [CLOSE.ALL; EXIT]
         FIL.ERR(COM.F)
         GO RESTART

RESTART: ON.ALT.C; CLIBUF; CLOSE.ALL; GO PROMPT

ALTMOD: CLOBUF; CLIBUF; MSG('$<ESC>$'); CLOSE.ALL; EXIT
NOCORE: ERR('$NO CORE LEFT$'); EXIT

%NXT.SRC
IF C_NCHV C.STR.P=CARRET THEN RETURN 0   !MUST BE LAST SOURCE FILE
IF C # $, THEN MESS(E,'$COMMA EXPECTED$')  !SEPARATE SRC'S WITH COMMAS
PAGE.NUM _ 1  !1ST FILE AND 1ST EDIT10 PAGE NUMBER
IF F#0 THEN DO  !THIS INDICATES A FILE NEEDS TO BE CLOSED
  CLOSE(F)
  F _ 0
  PAGE.NUM _ 0  !FLAG TO CAUSE FORM FEED AFTER EACH SRC
  END
ON.ALT.C
SETFID(F.VAR,@C.STR.P,DEF.VAR,ERR.VAR)    !SETFID WILL SCAN FILE NAME
MSG('$'); WFID(F.VAR)  !DEBUG
F_OPEN(-F.VAR,SEQUEN+INPUT+CHARACTER,EOFLAB,BUFFERS)  !SOURCE FILE
LINE.NUM _ 0
EDIT10_PLNCHK(F)
NEW.PAGE _ 1
MSG('$')  !DEBUG
RETURN 1    !INDICATES THAT THERE WAS A SRC FILE
END NXTSRC



%EVAL

TABLE UNARY(MAX.CH.MAP)[0,0,0,0,13,14,0,0,0,0,0,0,0,11,12,0,0,0]
TABLE STKDPR(0:NUMOPS)[0,2,3,3,4,4,5,5,5,6,-1,1,8,8,8,10,11,11,11,11]  !STACKED PRECEDENCE
TABLE INCMPR(0:NUMOPS)[0,2,3,3,4,4,5,5,5,6,1,12,9,9,9,10,11,11,11,11]  !INCOMING PRECEDENCE
LOCAL VSTK(STKSIZ),OSTK(STKSIZ),VP,OP,X,Y,Z,%DOIT,LITERAL
VP _ OSTK(1) _ 0  !INIT WITH A BEGINNING OF LINE TYPE OPERATOR
OP _ 1
IF TOK=EQUAL THEN [THING.GETTER; INC LITERAL] ELSE LITERAL_0    !LITERAL FOLLOWS
WHILE 1=1 THEN DO   !DUMMY LOOP SUBSTITUTE
WHILE X _ UNARY(TOK) THEN DO  !UNARY OPERATORS - UNOPS

  DOIT
  THING.GETTER
  END
EIF TOK = NUM THEN NULL     !NUMERIC OPERAND
ORIF TOK = SYM THEN DO  !ALPHA OPERAND
  EIF ^(Z  _ SYMPOS(SYMTAB)) = 0 THEN [ERR('$SYMBOL NOT DEFINED$'); VAL_0]
  ELSE DO
     VAL _ SYMVAL(Z)
     IF VAL BAND OCT 100000 THEN VAL_VAL BOR OCT 777777.600000  !SIGN BIT
     END
  IF PASS.TWO THEN LIS.REF(Z)
  END
ORIF TOK = STAR THEN VAL _ PCTR  !CURRENT LOCATION OPERAND
ORIF TOK = DOT THEN VAL _ OCT 100000   !THE INDIRECT BIT
ELSE [ERR('$OPERAND EXPECTED HERE$'); RETURN VSTK(1) BAND OCT 177777]

IF INC VP<STKSIZ THEN VSTK(VP)_VAL ELSE [ERR('$VSTK OVERFLO$'); VP_STKSIZ-1]

THING.GETTER
RPAREN: EIF TOK=TERM OR TOK=SPACE OR TOK=COMMA THEN DO  !MUST BE END OF EXPRESSION
  X _ 0
  DOIT
  IF VP # 0 OR OP#0 THEN [ERR('$ILL-FORMED EXPRESSION$'); RETURN VSTK(1)]
!  ERR('  EQUALS  ')   DEBUG
!  PR(VSTK(1), 8)   DEBUG
  VSTK(1) _ VSTK(1) BAND OCT 177777  !CUT TO 16 BITS FOR VARIAN
  IF LITERAL THEN DO
    SYMBUF(0) _ 1       !WORD COUNT OF 1 FOR 16BITS OF LITERAL
    SYMBUF(1) _ VSTK(1) SHL 1   !TO AVOID THE FUNNY BIT ON THE PDP10
    IF ^(Y _ SYMPOS(LITTAB)) = VIRGIN THEN ^Y _ INC CUR.LIT.ADD

    RETURN ^Y-1  !ALL LITADDS ARE 1 HIGH TO AVOID ZERO
    END
  RETURN VSTK(1) !THE FINAL ANSWER
  END
ORIF X _ BINARY(TOK) THEN [DOIT; THING.GETTER]  !NON-ZERO MEANS IT'S A BINOP
ELSE [X _ INVIS.PLUS; DOIT]  !ASSUME AN INVISIBLE PLUS
IF X=10 THEN  GO RPAREN  !RIGHT PARENS ARE AN UNUSUAL BINOP

END         !DUMMY LOOP END



%DOIT
!  W(L,$ )  DEBUG
  WHILE INCMPR(X) <= STKDPR(Y _ OSTK(OP)) THEN DO


    IF DEC OP < 0 THEN [ ERR('$OSTK UNDERFLO$'); OP_0]
    IF Y<10 OR Y>14 THEN IF DEC VP < 0 THEN [ERR('$VSTK UNDERFLO$'); VP_0]
      DO Y OF 0:NUMOPS
 0: RETURN
1: VSTK(VP) _ VSTK(VP) SHL 8 + VSTK(VP+1) BAND OCT 377 !BACK SLASH

 2: VSTK(VP) _ VSTK(VP) + VSTK(VP+1)  !PLUS

 3: VSTK(VP) _ VSTK(VP) - VSTK(VP+1)  !MINUS

 4: VSTK(VP) _ VSTK(VP) * VSTK(VP+1)   !STAR

 5: VSTK(VP) _ VSTK(VP) / VSTK(VP+1)   !SLASH

 6: VSTK(VP) _ VSTK(VP) BOR VSTK(VP+1)  !BANG

 7: VSTK(VP) _ VSTK(VP) BAND VSTK(VP+1)  !AND

 8: VSTK(VP) _ VSTK(VP) BXOR VSTK(VP+1)  !UP ARROW

 9: IF Z _ VSTK(VP+1) > 0 THEN VSTK(VP) _ VSTK(VP) SHL Z &
      ELSE VSTK(VP) _ VSTK(VP) SHR - Z          !BACK ARROW

10: NULL    !RIGHT PAREN

11: IF X=10 THEN RETURN  !LEFT PAREN ZAPS INCOMING RIGHT PAREN
    IF X=0 THEN ERR("$( LACKS MATCHING )$")

12: VSTK(VP) _ BNOT VSTK(VP)  !POUND



13: NULL    !UNARY PLUS DOESN'T DO MUCH
14: VSTK(VP) _ - VSTK(VP)     !UNARY MINUS
15: VSTK(VP) _ VSTK(VP) + VSTK(VP+1)  !AN INVISIBLE PLUS

16: VSTK(VP) _ [VSTK(VP) # VSTK(VP+1)]  !POUND
    IF NOT NEWMODE THEN ERR('$# AS UNEQUAL NOT VALID IN OLD MODE$')

17: VSTK(VP) _ [VSTK(VP) = VSTK(VP+1)]  !EQUAL
    IF NOT NEWMODE THEN ERR('$= AS EQUAL NOT VALID IN OLD MODE$')

18: VSTK(VP) _ [VSTK(VP) > VSTK(VP+1)]  !GREATER
    IF NOT NEWMODE THEN ERR('$> NOT VALID IN OLD MODE$')

19: VSTK(VP) _ [VSTK(VP) < VSTK(VP+1)]  !LESS
    IF NOT NEWMODE THEN ERR('$< NOT VALID IN OLD MODE$')

      END  !  Y OF NUMOPS
  
                                               END  !INCOMING < STACKED
D:   IF X=10 THEN ERR("$) LACKS MATCHING ($") &
   ELSE DO
     IF INC OP > STKSIZ THEN [ERR('$OSTK OVERFLO$'); OP_STKSIZ-1]
     OSTK(OP) _ X  !PUT IT ON THE OPERATOR STACK
     END



  
RETURN
END DOIT

%SET.OLD.EVAL
BINARY(7) _ 0  ! * IS NOT BINARY OP FOR MULTIPLY IN OLD MODE
BINARY(8) _ 1  !CHANGE / TO SAME AS \ IN OLD MODE
OLDIF _ 0       !OLDIF WILL VARY BETWEEN  0 AND 1 FOR OLD IFS
NEWMODE_0   !OLD DIRECTIVE SEEN
RETURN
END SET.OLD.EVAL


%INITMAP
IOCS(BUFFERS)
ALTLOC _ ALTMOD   !SET ALTMODE LOCATION
Z_-1
WHILE INC Z<128 THEN MAP(Z)_MAX.CH.MAP
Z_$0-1
WHILE INC Z<$9+1 THEN MAP(Z)_NUM
Z_$A-1
WHILE INC Z<$Z+1 THEN MAP(Z)_SYM
Z_$a-1
WHILE INC Z<$z+1 THEN MAP(Z)_SYM
MAP($ )_SPACE
MAP($	)_SPACE  !TAB OR CONTROL I
Z_SPACE
MAP($\) _ 4
MAP($+) _ 5
MAP($-) _ 6
MAP($*) _ STAR
MAP($/) _ 8
MAP($!) _ 9
MAP($&) _ 10
MAP($^) _ 11
MAP($_) _ 12
MAP($)) _ 13
MAP($() _ 14
MAP($#) _ 15
MAP($=) _ EQUAL
MAP($>) _ GREATER
MAP($<) _ LESS

MAP($,) _ COMMA

MAP($.) _ DOT
MAP($:) _ COLON
MAP(CARRET)_TERM
MAP($;)_TERM

INIT.SYM.PAK
OPTAB _ NEW.SYM.TBL(2,0)

Z_OPEN('OPCDS',SEQUEN+INPUT+CHARACTER,DONE,BUFFERS)
I_K_0
WHILE 1=1 THEN DO
  EIF C_R(Z) = $* THEN DO
    IF INC K > 3 THEN [ERR('$TOO MANY STAR LINES IN OPCDS FILE$'); EXIT]
    DO K OF 3
    1: NAEOPS_I
    2: NIFOPS_I
    3: N1WDOPS_I
    END
    WHILE R(Z)#CARRET THEN NULL
    IF PDP10 THEN R(Z)
    END
  ELSE DO
    INC I
    CHRCNT_0
    J_CHPT(@SYMBUF(1),-1)
    MOVE SYMBUF.L FROM ALL 0 TO @SYMBUF(1)
    WHILE C#$  THEN DO  !UP TO A BLANK
      NCHV J_C
      C_R(Z)
      IF INC CHRCNT > CPW*SYMBUF.L THEN ERR('$TOO MANY CHARS IN OPCDS FILE$')
      END
    SYMBUF(0)_((CHRCNT-1)/CPW)+1
    WHILE MAP(C_R(Z))=SPACE THEN NULL  !UP TO A NON-SPACE
    VAL_TOK_0  !INIT TMPLT AND OPCODE VALUE TO ZERO
    WHILE MAP(C)=NUM THEN [VAL_VAL*10+C-$0; C_R(Z)]
    WHILE MAP(C_R(Z))=SPACE THEN NULL
    WHILE MAP(C)=NUM THEN [TOK_TOK SHL 3+C-$0; C_R(Z)]
    IF (^(SYMPOS(OPTAB))<==[BPW-21,5,16]*[0,VAL,TOK]) THEN ERR('$DUPLICATE OPCODE$')
    WHILE C#CARRET THEN C_R(Z)
    IF PDP10 THEN R(Z) !ABSORB PDP10 LNFEED
    END
  END
DONE: NALLOPS _ I; CLOSEALL; ON.ALT.C
      DEF.REL _ [6,6,6,BPW-18]*[$R-OCT 40,$E-OCT 40,$L-OCT 40,0]  !REL
      DEF.LST _ [6,6,6,BPW-18]*[$L-OCT 40,$S-OCT 40,$T-OCT 40,0]  !LST
      DEF.VAR _ [6,6,6,BPW-18]*[$V-OCT 40,$A-OCT 40,$S-OCT 40,0]  !VAS
E_TEL
A.PTR _ BYPT(@A,5,3)  !MAKE A BYT POINTER TO 1ST DIGIT
PCTR.PTR _ BYPT(@PCTR,6,3)  !PCTR HAS 1 LESS DIGIT


MSG('$INIT DONE, TYPE "-SAV VAS"')
JOBSA _ [18,18]*[JOBFF,START]
JOBCOR _ [18,18]*[JOBFF,0]
EXIT

END INITMAP
END EVAL

   