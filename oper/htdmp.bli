MODULE HTDMP(DOLLAR,ENTRIES=($HTDMP),FSAVE,TIMING,TIMER=EXTERNAL(SIX12))=
BEGIN

BIND DEBUGLVL=0;

REQUIRE CDEFS.BLI[7,107355];
REQUIRE FDEFS.BLI[7,107355];
REQUIRE HDEFS.BLI[7,107355];
REQUIRE UDEFS.BLI[7,107355];

UNDECLARE $HTDMP;

%  THIS ROUTINE FORMATS A SYNTAX TREE PRODUCED BY THE PARSER INTO A
   READABLE FORM AND WRITES IT TO THE TERMINAL
   IT USES THE ROUTINE $HNDMP TO FORMAT
   THE INDIVIDUAL NODES.
%


MACRO
   RH=0,18&,
   LH=18,18&,
   V=LH&,
   H=RH&,
   CODE=18,2&,
   DFBIT=20,1&,
   EOL=21,1&,
   SCBIT=22,1&,
   BETWEEN(A,L,U)=(L LEQ A AND A LEQ U)&,
   MIN(A,B)=(IF A LEQ B THEN A ELSE B)&,
   MAX(A,B)=(IF A GEQ B THEN A ELSE B)&;

%  THE STRUCTURE TNODE DEFINES THE FIELDS OF A TREE CREATED BY $HTDMP
   THAT PARALLELS THE STRUCTURE OF THE ARGUMENT TREE.  THIS TREE IS
   TO DO THE PHYSICAL LAYOUT ALLOCATION OF THE ARGUMENT TREE ONTO
   THE PHYSICAL LINE.
%
STRUCTURE TNODE[FIELD]=
   CASE .FIELD OF SET
%PTR  % (@.TNODE+0)<RH>;    % CORE ADDRESS OF CORRESP. NODE %
%VF   % (@.TNODE+0)<LH>;   % V FUNCTION VALUE FOR THIS NODE (SEE HV) %
%SUC  % (@.TNODE+1)<RH>;   % PTR TO SUCCESSOR NODE FOR THIS NODE %
%DEF  % (@.TNODE+1)<LH>;   % PTR TO DEFINITION NODE %
%HP   % (@.TNODE+2)<H>;    % HORIZONTAL COORDINATE OF THIS NODE IN LAYOUT %
%VP   % (@.TNODE+2)<V>;    % VERTICAL COORDINATE OF THEIS NODE IN LAYOUT %
%DEFVF% (.(@.TNODE+1)<LH>)<LH>  % VF FIELD OF THIS NODE'S DEF %
         TES;

BIND
   PTR  =0, VF  =1,
   SUC  =2, DEF =3,
   HP   =4, VP  =5,
   DEFVF=6, TNDSIZE=3;

%  HERE IS THE MAIN ROUTINE.  ITS HEAD CONTAINS A NUMBER OF INTERESTING
   RECURSIVE FUNCTIONS TO TRAVERSE THE TREE AND DETERMINE ITS SPATIAL LAYOUT
%
GLOBAL ROUTINE $HTDMP(TREE)=
   BEGIN

   MAP HTREE$I TREE;

   LOCAL
      NNODES,     % THE NUMBER OF NODES IN THE TREE %
      NSIZE,      % LOG 10 OF NNODES = # DIGITS IN NODE NUMBER %
      USIZE,      % NUMBER OF CHARS IN A PRINT UNIT %
      NUPL,       % NUMBER OF PRINT UNITS PER PHYSICAL LINE %
      M,          % NO OF ROWS IN LAYOUT ARRAY %
      N,          % NO OF COLS IN LAYOUT ARRAY %
      NXI,        % INDEX FOR USE BY THE ABSTRACT FUNCTION %
      NHB;        % NO OF HORIZONTAL BREAKS (PAGE FOLDS) %

%  VEC3 IS A STRUCTURE OF 3 WORD NODES ORGANIZED INTO AN ARRAY TO
   FORM THE INDEX OF THE TREE NODES.  THE INDEX NUMBERS ARE TYPED
   TO REPRESENT THE TREE STRUCTURE.
%
   STRUCTURE VEC3[I]=
      IF DEBUGLVL GTR 5
         THEN IF BETWEEN (.I,0,.NNODES-1)
                 THEN (@.VEC3+3*.I)<0,36>
                 ELSE ($UMESS($USPTR('VEC3 SUBSCRIPT CHECK')); $FATAL(0))
         ELSE (@.VEC3+3*.I)<0,36>;

%  DARY2 IS A STRUCTURE TO REPRESENT A 2-DIMENSIONAL ARRAY THROUGH A
   POINTER.  THE ARRAY IS STORED ROW-WISE.
%
   STRUCTURE DARY2[I,J]=
      IF DEBUGLVL GTR 5
         THEN IF BETWEEN(.I,0,.M-1) AND BETWEEN(.J,0,.N-1)
                 THEN (@.DARY2+.N*.I+.J)<0,36>
                 ELSE ($UMESS($USPTR('DARY2 SUBSCRIPT CHECK')); $FATAL(0))
         ELSE (@.DARY2+.N*.I+.J)<0,36>;

   LOCAL
      VEC3 T,     % AUXILIARY TREE ARRAY %
      DARY2 L;    % BASE OF LAYOUT ARRAY %

%  THE ARRAYS T AND L ARE THE PRIMARY DATA STRUCTURES USED IN
   COMPUTING THE LAYOUT OF THE TREE.  T IS A VECTOR OF NODES
   EACH OF STRUCTURE TNODE THAT IS A COPY OF THE INPUT TREE ALONG
   WITH ADDITIONAL INFORMATION TO FACILITATE THE COMPUTATIONS.

   THE L ARRAY IS IN DIRECT CORRESPONDENCE TO THE FINAL LAYOUT
   OF THE TREE.  ITS ROWS CORRESPOND TO ROWS ON THE PAGE AND
   SIMILARLY ITS COLUMNS.  EACH ARRAY ELEMENT CORRESPONDS TO A PRINT
   UNIT OF A NODE DESCRIPTOR, ITS SUCCESSOR LINK (IF ANY) AND
   ON THE NEXT LINE A DEF LINK (IF ANY).  EACH L ENTRY IS ONE WORD
   WITH THE RIGHT HALF BEING A POINTER TO THE T-ENTRY IF THERE
   IS A NODE TO APPEAR AT THIS SPOT OR ZERO IF NONE.  THE LEFT
   HALF CONTAINS A NUMBER OF FLAGS: AND END OF LINE FLAG TO TERMINATE
   PRINTING OF A LINE, SUC AND DEF BITS TO INDICATE IF THOSE MARKS
   ARE TO BE PRINTED FOR THIS NODE, AND A CODE FIELD TO INDICATE IF
   IT IS A NODE, NOTHING, OR A SPOT WHERE DEF LINKS SHOULD BE FILLED
   IN BECAUSE OF SPACING ARRANGEMENTS.  THE CORRESPONDING PROBLEM DOES
   NOT EXIST FOR SUC NODES AS THE POSITIONING ALGORITHM (POS AND
   HV FUNCTIONS) ALWAYS PLACE A SUCCESSOR IMMEDIATELY AFTER ITS PREDE-
   CESSOR, PLACING DEFS LOW ENOUGH TO MAKE THIS POSSIBLE.

   THE PRINTING IS DONE BY SCANNING THE L ARRAY ROW-WISE AND INTERPRETING
   ITS ENTRIES, MAKING CALLS ON THE UOUT PACKAGE FOR ACTUAL IO.
%
   BIND
      DFPA=PLIT(0,
         $USPTR('!'),
         $USPTR(' !'),
         $USPTR('  !')),
      NOTA=PLIT(0,
         $USPTR(' '),
         $USPTR('  '),
         $USPTR('   '));

   %  ROUTINE CNT COUNTS THE NUMBER OF NODES IN THE ARGUMENT
      TREE IN ORDER TO ALLOCATE THE T ARRAY.
   %
   ROUTINE CNT(NODE)=
      BEGIN
      MAP HNODE$ NODE;
      IF .NODE EQL HV$SIGMA
         THEN 0
         ELSE
            BEGIN
            LOCAL VAL;
            IF .NODE[H$FLAG]
               THEN
                  BEGIN
                  $UMESS($USPTR('HTDMP ERROR: CIRCULAR SYNTAX TREE'));
                  $FATAL(0)
                  END
               ELSE NODE[H$FLAG] := 1;
            VAL := (IF .NODE[H$TYPE] EQL HV$NTERM
                    THEN CNT(.NODE[H$DEF])
                    ELSE 0)
                +CNT(.NODE[H$SUC])+1;
            NODE[H$FLAG] := 0;
            .VAL
            END
      END;

   %   FUNCTION ABSTRACT MAKE THE PARALLEL COPY OF TREE INTO
      THE ARRAY T, SETTING UP DEF FIELDS OF 0 FOR TERMINALS.
   %
   FUNCTION ABSTRACT(TREE)=
      IF .TREE EQL HV$SIGMA
         THEN 0
         ELSE
            BEGIN
            MAP HNODE$ TREE;
            LOCAL TNODE TN;
            TN := T[.NXI]<0,0>;
            NXI := .NXI+1;
            TN[PTR] := .TREE;
            TN[VF] := 0;
            TN[DEF] := IF .TREE[H$TYPE] EQL HV$TERM
                       THEN 0
                       ELSE ABSTRACT(.TREE[H$DEF]);
            TN[SUC] := ABSTRACT(.TREE[H$SUC]);
            .TN
            END;


   %  ROUTINE HV MAKES THE BACKWARD PASS THROUGHT THE TREE COMPUTING
      THE H AND V VALUES WHICH DETERMINE A SUFFICIENT SIZE AND LAYOUT
      OF THE TREE.  THESE FUNCTIONS HAVE AN ELEGANT RECURSIVE
      FORMULATION WHICH IS USED HERE.
   %
   ROUTINE HV(TREE)=
      IF .TREE EQL 0
         THEN 0
         ELSE
            BEGIN
            MAP TNODE TREE;
            LOCAL
               DHV,  % DEF NODE HV %
               SHV,  % SUC NODE HV %
               MHV;  % THIS NODE HV %
            DHV := HV(.TREE[DEF]);
            SHV := HV(.TREE[SUC]);
            MHV<H> := MAX(1+.SHV<H>,.DHV<H>);
            TREE[VF] := MHV<V> := IF .DHV<H> EQL 1
                              THEN MAX(.SHV<V>,1+.DHV<V>) % NO INTERACTION %
                              ELSE MAX(1,.SHV<V>)+.DHV<V>; % SHOVE DEF DOWN %
            .MHV
            END;

   %  FUNCTION POS DOES THE FORWARD PASS ON THE TREE USING THE
      INFORMATION GARNERED BY THE HV FUNCTION TO ALLOCATE THE
      LOCATIONS OF THE NODES.
   %
   FUNCTION POS(TREE,VPOS,HPOS)=
      BEGIN
      MAP TNODE TREE;
      TREE<CODE> := 2;
      L[.VPOS,.HPOS] := .TREE;
      TREE[HP] := .HPOS;
      TREE[VP] := .VPOS;
      IF .TREE[DEF] NEQ 0
         THEN POS(.TREE[DEF],.VPOS+.TREE[VF]-.TREE[DEFVF],.HPOS);
      IF .TREE[SUC] NEQ 0
         THEN POS(.TREE[SUC],.VPOS,.HPOS+1)
      END;

%  WE NOW PICK UP THE MAIN LINE OF $HTDMP
%
   $UAPSZ($USPTR('$HTDMP ENTERED: TREE IS '));
   IF .TREE EQL HV$EMPTY
      THEN
         BEGIN
         $UAPSZ($USPTR('EMPTY'));
         $UOUTL();
         RETURN
         END;
   $UAPOC(.TREE);
   $UOUTL();

   NNODES := CNT(.TREE[H$HEAD]);
   IF .NNODES GEQ 1000
      THEN ($UMESS($USPTR('$HTDMP FAILURE: TOO MANY NODES IN TREE.')); RETURN);
   NSIZE := IF .NNODES LSS 10
            THEN 1
         ELSE IF .NNODES LSS 100
            THEN 2
         ELSE 3;
   USIZE := .NSIZE+1;
   NUPL := 78/.USIZE;
   NXI := 0;
   T := $CGETM(.NNODES*TNDSIZE);
   ABSTRACT(.TREE[H$HEAD]);
   M := HV(.T);
   N := .M<H>;
   M := .M<V>;
   L := $CGTZM(.M*.N);
   POS(.T,0,0);
   NHB := .N/.NUPL;

%  NOW WE GO THRU AND MARK THE SLOTS THAT LEAD TO OTHER NODES.
%
   BEGIN
   LOCAL
      TNODE TP,
      VPOS;
   INCR I TO .NNODES-1 DO
      BEGIN
      TP := T[.I]<0,0>;
      IF .TP[DEF] NEQ 0
         THEN
            BEGIN
            BIND LC=L[.TP[VP],.TP[HP]];
            LC[0]<DFBIT> := 1;   % MARK THIS AS A NODE WITH DEF %
            VPOS := .N;
            UNTIL .LC[.VPOS] NEQ 0 DO
               BEGIN
               LC[.VPOS]<CODE> := 1;  % MARK THIS AS ONE LEADING TO DEF %
               VPOS := .VPOS+.N
               END
            END;
      IF .TP[SUC] NEQ 0
         THEN L[.TP[VP],.TP[HP]]<SCBIT> := 1
      END
   END;

%  NOW GO THRU AND MARK THE END OF EACH LINE
%
   BEGIN
   LOCAL K;
   INCR J TO .M-1 DO
      BEGIN
      BIND LR=L[.J,0];
      K := .N-1;
      UNTIL .LR[.K] NEQ 0 DO
         K := .K-1;
      LR[.K]<EOL> := 1
      END
   END;

%  WE ARE NOW READY TO DO THE OUTPUT PROCESSING
   FIRST COMES THE DICTIONARY OF NODES.
%
   BEGIN
   LOCAL TNODE K;
   INCR I TO .NNODES-1 DO
      BEGIN
      K := T[.I]<0,0>;
      $UAPN(.I,10,.NSIZE);
      $UAPSZ($USPTR(': '));
      $HNDMP(.K[PTR]);
      $UOUTL()
      END;
   $UOUTL()
   END;

%  NOW COMES THE TREE REPRESENTATION ITSELF
%
   BEGIN
   LOCAL
      J,   % LINE INDEX %
      K,   % PRINT UNIT INDEX %
      K1,  % STARTING VALUE FOR K %
      K2,  % ENDING VALUE FOR K %
      P,   % TOP-BOTTOM LINE INDICATOR %
      LT;  % TEMPORARY FOR L VALUE %
   LABEL LINELP,BLKLP;

   INCR I TO .NHB DO
      BEGIN
      J := 0;
BLKLP:
      WHILE 1 DO
         BEGIN
         BIND LR=L[.J,0]<0,0>;
         K1 := .NUPL*.I;
         K2 := MIN(.N,.K1+.NUPL)-1;
         P := 0;
         DO BEGIN
            K := .K1;
   LINELP:
            WHILE 1 DO
               BEGIN
               LT := .LR[.K];
               CASE .LT<CODE> OF SET
   %NOTHING SPOT% $UAPSZ(.NOTA[.NSIZE]);
   %DEF LINK%     $UAPSZ(.DFPA[.NSIZE]);
   %NODE SPOT%    CASE .P OF SET
      %TOP LINE%     $UAPN((.LT<RH>-.T)/TNDSIZE,10,.NSIZE);
      %BOTTOM LINE%  $UAPSZ(IF .LT<DFBIT>
                                THEN .DFPA[.NSIZE]
                                ELSE .NOTA[.NSIZE])
                     TES
                  TES;
               IF .K GEQ .K2 OR .LT<EOL>
                  THEN LEAVE LINELP;
               $UOCHR(IF .LT<SCBIT> AND (.P EQL 0)
                                  THEN "-"
                                  ELSE " ");
               K := .K+1
               END;
            $UOUTL();
            IF .J EQL .M-1
               THEN LEAVE BLKLP;
            P := .P+1
            END
         WHILE .P LSS 2;
         J := .J+1
         END
      END;
   $UOUTL()
   END;

%  NOW WE CLEAN UP AND CHECK OUT
%
   $CFREEM(.T);
   $CFREEM(.L);
   END;

END
ELUDOM
 