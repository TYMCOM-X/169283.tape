TITLE	ISAM VERSION 2			
SUBTTL	ISAM FILE MAINTENANCE PROGRAM		AL BLACKINGTON/CAM

EDIT==075000            ;DEC-EDT=075,TYM-REL=000
VERSION==002001         ;DEC-VER=002,TYM-VER=001

;COPYRIGHT 1971,1972, DIGITAL EQUIPMENT CORP., MAYNARD, MASS.

IFNDEF NEW,<NEW==1>	;ELIMINATES "SIZE OF LARGEST INPUT BLOCK:" QUESTION
;ASSEMBLY INSTRUCTIONS
;	.COMPIL ISAM		(ASSUMING ISAM.MAC IS ON DSK:)
;	.LOAD ISAM,SYS:LIBOL/L$
;	.SSAVE DSK:ISAM

LOC	137
XWD     VERSION,EDIT
RELOC	0

TWOSEG
RELOC	400000
SUBTTL	PARAMETERS

;ACCUMULATOR DEFINITIONS

SW=0		;SWITCH REGISTER
TA=1		;TEMP
TB=TA+1		;TEMP
TC=TB+1		;TEMP
TD=TC+1		;TEMP
TE=TD+1		;TEMP
TF=TE+1		;TEMP

IX=7		;CURRENT INPUT INDEX LEVEL
OP=10		;OUTPUT BYTE-POINTER
KT=11		;KEY TYPE
IM=12		;INPUT MODE
OM=13		;OUTPUT MODE
OC=14		;NUMBER OF CHARACTERS IN OUTPUT RECORD
CH=15		;TTY CHARACTER
DA=16		;ADDRESS OF A FILE PARAMETER BLOCK
PP=17		;PUSH-DOWN POINTER

;I/O CHANNELS

OF1==1		;PRIMARY OUTPUT FILE
OF2==2		;SECONDARY OUTPUT FILE
IF1==3		;PRIMARY INPUT FILE
IF2==4		;SECONDARY INPUT FILE
CMD==5		;INDIRECT COMMAND FILE

;MONITOR COMMUNICATION

$MTA==1B31	;DEVICE IS A MAG-TAPE
$DSK==1B19	;DEVICE IS A DISK
$ERA==740000	;ERROR FLAGS FROM I/O

$GETCH==4	;CALLI CODE FOR 'DEVCHR'
$CORE==11	;CALLI CODE FOR CORE
$DATE==14	;CALLI CODE FOR DATE

$ISAMI==401	;FLAG FOR ISAM INDEX FILE
$ISAMS==1000	;FLAG FOR ISAM SIXBIT DATA FILE
$ISAMA==1100	;FLAG FOR ISAM ASCII DATA FILE
;SWITCH REGISTER FLAGS (LH)

FERROR==1B0	;ERROR IN COMMAND STRING
FNUM==1B1	;KEY IS NUMERIC
FSIGN==1B2	;'S' OR 'U' TYPED IN KEY DESCRIPTOR
FTAB==1B3	;WE ARE GETTING TABS FROM INPUT
FENDL==1B4	;WE HAVE AN END-OF-LINE
FENDIB==1B5	;END OF INPUT BLOCK
FEOF==1B6	;END OF INPUT FILE
FDSK==1B7	;/B INPUT OR /P OUTPUT IS DISK
FCNV==1B8	;CONVERT FROM ASCII TO SIXBIT
FMTA==1B9	;/B INPUT OR /P OUTPUT IS MAG-TAPE
FGETDC==1B10	;GETDEC ROUTINE SAW ACTUAL NUMBER
INDIR==1B11	;READING INDIRECT COMMAND FILE
FRECIN==1B12	;A DATA RECORD HAS BEEN SEEN

;SWITCH REGISTER FLAGS (RH)

OPT.M==1B33	;/M OPTION (MAINTAIN FILE)
OPT.P==1B34	;/P OPTION (PACK FILE)
OPT.B==1B35	;/B OPTION (BUILD INDEXED FILE)

;CONSTANTS USED TO INDEX INTO FILE PARAMETER DATA

DEV==0		;DEVICE NAME
FILNAM==1	;FILE NAME
FILEXT==2	;FILE EXTENSION
PPNUM==3	;PROJECT-PROGRAMMER NUMBER
BUFADR==4	;3-WORD BUFFER HEADER

;MISCELLANEOUS

UNSIGN==1B20	;'SIGNED' FLAG IN KEY DESCRIPTOR
PPSIZE==40	;SIZE OF PUSH-DOWN LIST
SUBTTL	INITIALIZATION

START:	CALLI	0		;RESET
	TTCALL	2,TTYKAR	;CLEAR ANY ^O CONDITION
	SETZM	TTYKAR		;CLEAR IF NOTHING READ

	SETZM	LOWCOR		;CLEAR IMPURE AREA (EXCEPT TTYKAR)
	MOVE	TA,[LOWCOR,,LOWCOR+1]
	HRRZ	TB,.JBREL##
	BLT	TA,(TB)

	MOVEI	SW,0		;CLEAR SWITCH REGISTER
	MOVE	PP,[IOWD PPSIZE,PPLIST]  ;INIT PDL
SUBTTL	READ COMMAND STRING

RCOM:	TTCALL	3,[ASCIZ "
*"]				;TYPE '*'
RCOM3:	PUSHJ	PP,GETTY	;GET FIRST CHARACTER OF COMMAND LINE
	CAIN	CH,15		;IF CARRIAGE-RETURN,
	JRST	RCOM		;  LOOP
	CAIN	CH,"@"		;INDIRECT?
	JRST	ICOM		;YES
	MOVEM	CH,TTYKAR	;SAVE THAT CHARACTER

	TRZ	SW,OPT.M+OPT.P+OPT.B  ;CLR OPTION FLAGS
	PUSHJ	PP,GETFIL	;GET 1ST FILENAME
	CAIN	CH,15		;END OF LINE ALREADY?
	JRST	RCOM2		;YES, THIS IS THE INPUT FILE
	MOVE	TA,[FILDAT,,OF1DAT]  ;NO, STORE PARAMS FOR 1ST OUT FILE
	BLT	TA,OF1DAT+BUFADR-1
	CAIE	CH,","		;IS THERE A SECONDARY OUTPUT FILENAME?
	JRST	RCOM1		;NO

	PUSHJ	PP,GETFIL	;GET NAME OF 2ND OUTPUT FILE
	MOVE	TA,[FILDAT,,OF2DAT]
	BLT	TA,OF2DAT+BUFADR-1

RCOM1:	CAIE	CH,"_"		;OUTPUT SPECIFICATIONS END WITH BACKARROW?
	JRST	BADCOM		;NO
	PUSHJ	PP,GETFIL	;YES, GET INPUT FILENAME

RCOM2:	MOVE	TA,[FILDAT,,IF1DAT]  ;STORE PARAMS FOR INPUT FILE
	BLT	TA,IF1DAT+BUFADR-1
	CAIE	CH,15		;COMMAND END WITH EOL CHAR?
	JRST	BADCOM		;NO

	MOVE	TA,OF2DAT+DEV	;CHECK THAT THERE IS NO 2ND
	IOR	TA,OF2DAT+FILNAM  ;OUTPUT FILE SPEC FOR
	IOR	TA,OF2DAT+FILEXT  ;THE /P OPTION
	IOR	TA,OF2DAT+PPNUM
	TRNE	SW,OPT.P
	JUMPN	TA,BADCOM	;IF THERE IS -- TOO BAD

	SKIPE	IF1DAT+FILNAM	;INPUT FILENAME GIVEN?
	JRST	DEFLT		;YES, CONTINUE
	MOVE	TA,IF1DAT	;NO, SEE IF DEVICE IS A MTA
	CALLI	TA,$GETCH	;DO A DEVCHR
	TLNE	TA,$MTA		;MTA?
	SKIPN	OF1DAT+FILNAM	;YES, OUTPUT FILENAME SPECIFIED?
	JRST	BADCOM		;NO
	JRST	DEFLT		;YES
;INIT INDIRECT COMMAND FILE

ICOM:	TLNE	SW,(INDIR)	;ALREADY INDIRECT?
	JRST	DBLIND		;CANT DO DOUBLE INDIRECT

	PUSHJ	PP,GETFIL	;GET FILE NAME
	CAIE	CH,15		;SHOULD END WITH CR
	JRST	BADCOM

	MOVEI	TA,0		;OPEN ASCII INPUT
	SKIPN	TB,FILDAT+DEV
	MOVSI	TB,(SIXBIT 'DSK')	;USE DSK BY DEFAULT
	MOVEI	TC,CMDBUF
	OPEN	CMD,TA
	JRST	CMDERR

	MOVE	TA,FILDAT+FILNAM	;LOOKUP COMMAND FILE
	HLLZ	TB,FILDAT+FILEXT
	MOVEI	TC,0
	MOVE	TD,FILDAT+PPNUM
	LOOKUP	CMD,TA
	JRST	CMDLER

	INBUF	CMD,2		;GET 2 BUFFERS
	TLO	SW,(INDIR)	;INDICATE INDIRECT INPUT
	JRST	RCOM3		;START READING COMMANDS
SUBTTL	SET COMMAND STRING DEFAULTS

DEFLT:	TRNN	SW,OPT.B+OPT.M+OPT.P  ;DEFAULT OPTION IS /B
	TRO	SW,OPT.B

	SKIPN	TA,OF1DAT+DEV	;DEFAULT DEVICE FOR
	MOVSI	TA,(SIXBIT "DSK")  ; FIRST OUTPUT FILE IS
	MOVEM	TA,OF1DAT+DEV	;  'DSK'
	SKIPN	OF2DAT+DEV	;DEFAULT DEVICE FOR 2ND OUTPUT FILE IS
	MOVEM	TA,OF2DAT+DEV	;  1ST OUTPUT DEVICE
	SKIPN	TA,IF1DAT+DEV	;DEFAULT DEVICE FOR
	MOVSI	TA,(SIXBIT "DSK")  ; INPUT FILE IS
	MOVEM	TA,IF1DAT+DEV	;  'DSK'

	SKIPN	TA,OF1DAT+FILNAM  ;DEFAULT NAME FOR OF1 IS IF1
	MOVE	TA,IF1DAT+FILNAM
	MOVEM	TA,OF1DAT+FILNAM
	SKIPN	OF2DAT+FILNAM	;DEFAULT NAME FOR OF2 IS OF1
	MOVEM	TA,OF2DAT+FILNAM

	TRNN	SW,OPT.P+OPT.M	;WHICH OPTION ARE WE DOING?
	JRST	DEFLT1		;/B

	SKIPN	TA,IF1DAT+FILEXT  ;/M OR /P: DEFAULT EXT FOR IF1 IS 'IDX'
	MOVSI	TA,(SIXBIT 'IDX')
	HLLZM	TA,IF1DAT+FILEXT

	TRNN	SW,OPT.P	;/P?
	JRST	DEFLT1		;NO, /M

	SKIPN	TA,OF1DAT+FILEXT  ;DEFAULT EXT FOR OF1 IS 'SEQ'
	MOVSI	TA,(SIXBIT 'SEQ')
	HLLZM	TA,OF1DAT+FILEXT
	MOVE	TA,[OF1DAT,,OF2DAT]	;REAL /P OUTPUT IS DONE ON OF2
	BLT	TA,OF2DAT+BUFADR-1
	JRST	OPENER

DEFLT1:	SKIPN	TA,OF1DAT+FILEXT  ;/B OR /M: DEFAULT EXT FOR OF1 IS 'IDX'
	MOVSI	TA,(SIXBIT 'IDX')
	HLLZM	TA,OF1DAT+FILEXT
	SKIPN	TA,OF2DAT+FILEXT  ;DEFAULT EXT FOR OF2 IS 'IDA'
	MOVSI	TA,(SIXBIT 'IDA')
	HLLZM	TA,OF2DAT+FILEXT

	TRNN	SW,OPT.B	;/B OR /M?
	JRST	OPENER		;/M

	SKIPN	TA,IF1DAT+FILEXT  ;/B: DEFAULT EXT FOR IF1 IS 'SEQ'
	MOVSI	TA,(SIXBIT 'SEQ')
	HLLZM	TA,IF1DAT+FILEXT
SUBTTL	OPEN I/O FILES

OPENER:	TRNN	SW,OPT.B	;INPUT SEQUENTIAL?
	JRST	OPEN1		;NO, INDEXED

	MOVEI	TA,14		;/B: BUFFERED INPUT
	MOVEI	TC,IF1BUF
	JRST	OPEN2

OPEN1:	MOVE	TB,IF1DAT+DEV	;/M OR /P: INPUT DEVICE MUST BE A DISK
	CALLI	TB,$GETCH
	TLNN	TB,$DSK
	JRST	BADDEV		;NOT A DISK

	MOVEI	TA,17		;/M OR /P: DUMP MODE INPUT
	MOVEI	TC,0

OPEN2:	MOVE	TB,IF1DAT+DEV	;OPEN PRIMARY INPUT FILE
	OPEN	IF1,TA
	PUSHJ	PP,CANTOP	;PROBLEMS

	TRNN	SW,OPT.B+OPT.M	;OUTPUT INDEXED?
	JRST	OPEN3		;NO, SEQUENTIAL

	MOVE	TA,OF1DAT+DEV	;/B OR /M: OUTPUT DEVICES MUST BE DISKS
	CALLI	TA,$GETCH
	TLNN	TA,$DSK
	JRST	BADDEV		;INDEX DEVICE NOT A DISK

	MOVE	TA,OF2DAT+DEV	;/B OR /M: OPEN OUTPUT DATA FILE
	CALLI	TA,$GETCH
	TLNN	TA,$DSK
	JRST	BADDEV		;DATA DEVICE NOT A DISK

OPEN3:	MOVEI	TA,14		;/P: PRIMARY OUTPUT, /B OR /M: SEC. OUTPUT
	MOVE	TB,OF2DAT+DEV
	MOVSI	TC,OF2BUF
	OPEN	OF2,TA
	PUSHJ	PP,CANTOP	;CAN'T

	TRNE	SW,OPT.P	;/P?
	JRST	OPEN4		;YES, NO OUTPUT ON OF1

	MOVEI	TA,17		;/B OR /M: DUMP MODE OUTPUT
	MOVEI	TC,0
	MOVE	TB,OF1DAT+DEV	;OPEN THE PRIMARY OUTPUT FILE
	OPEN	OF1,TA
	PUSHJ	PP,CANTOP	;PROBLEMS

OPEN4:	TLNE	SW,(FERROR)	;IF TROUBLE,
	JRST	START		;  QUIT AND TRY ANOTHER
LOOK:	MOVE	TA,IF1DAT+FILNAM  ;LOOKUP THE PRIMARY INPUT FILE
	HLLZ	TB,IF1DAT+FILEXT
	MOVEI	TC,0
	MOVE	TD,IF1DAT+PPNUM
	MOVEM	TD,IF2DAT+PPNUM	;IF2PPN = IF1PPN
	LOOKUP	IF1,TA
	PUSHJ	PP,LOOKF	;ERROR

	TRNE	SW,OPT.P	;/P?
	JRST	LOOK2		;YES

	MOVE	TA,OF1DAT+FILNAM  ;ENTER THE PRIMARY OUTPUT FILE
	HLLZ	TB,OF1DAT+FILEXT
	MOVEI	TC,0
	MOVE	TD,OF1DAT+PPNUM
	ENTER	OF1,TA
	PUSHJ	PP,ENTERF	;ERROR

LOOK2:	MOVE	TA,OF2DAT+FILNAM  ;/B OR /M: ENTER THE SEC. OUT FILE (/P: PRIM.)
	HLLZ	TB,OF2DAT+FILEXT
	MOVEI	TC,0
	MOVE	TD,OF2DAT+PPNUM
	ENTER	OF2,TA
	PUSHJ	PP,ENTERF	;ERROR

LOOK1:	TLNE	SW,(FERROR)	;IF THERE WAS TROUBLE,
	JRST	START		;  QUIT

	TRNE	SW,OPT.M	;ANY SEQUENTIAL I/O?
	JRST	STAT		;NO

	MOVE	TE,IF1DAT+DEV	;GET SEQUENTIAL FILE DEVICE TYPE
	TRNN	SW,OPT.B	;IF1DEV FOR /B
	MOVE	TE,OF2DAT+DEV	;OF2DEV FOR /P
	CALLI	TE,$GETCH
	TLNE	TE,$DSK		;IF DSK, SET DSK FLAG
	TLO	SW,(FDSK)
	TLNE	TE,$MTA		;IF MTA, SET MTA FLAG
	TLO	SW,(FMTA)
STAT:	MOVE	TE,[STHDR,,STHDR+1]  ;CLEAR STATISTICS BLOCKS
	SETZM	STHDR
	BLT	TE,STAT2+STATSZ-1

	TRNN	SW,OPT.P+OPT.M	;INDEX FILE INPUT?
	JRST	ASKM		;NO

	MOVE	TA,[IOWD STATSZ,STAT2]  ;/M OR /P: READ INPUT FILE STAT BLK
	MOVEI	TB,0
	IN	IF1,TA
	SKIPA			;OK
	JRST	STATER		;ERROR

	MOVE	TA,[STAT2,,STHDR]  ;INIT OUTPUT STAT = INPUT STAT
	BLT	TA,STHDR+STATSZ-1
	HRRZS	STHDR		;EXCEPT CLR FILE FORMAT FLAG

	SETZM	LEVELS		;/M: CLEAR STAT LOCS THAT MUST BE REDONE
	SETZM	NDATB
	MOVE	TE,[NDATB,,NDATB+1]
	BLT	TE,FEISEC
	SETZM	NUMOPS
	MOVE	TE,[NUMOPS,,NUMUUO]
	BLT	TE,SATBIT
	SETZM	IDXADR

	MOVEI	TA,17		;OPEN SECONDARY INPUT FILE
	MOVE	TB,IF1DAT+DEV
	MOVEM	TB,IF2DAT+DEV
	MOVEI	TC,0
	OPEN	IF2,TA
	PUSHJ	PP,CANTOP	;CAN'T
	TLNE	SW,(FERROR)	;RESTART IF ERROR
	JRST	START

	MOVE	TA,STNAM+I	;GET SPECIFICATIONS FOR INPUT DATA FILE
	MOVEM	TA,IF2DAT+FILNAM
	MOVE	TB,STEXT+I
	MOVEM	TB,IF2DAT+FILEXT
	MOVEI	TC,0
	MOVE	TD,IF2DAT+PPNUM

	LOOKUP	IF2,TA		;FIND DATA FILE
	PUSHJ	PP,LOOKF	;ERROR
	TLNE	SW,(FERROR)	;RESTART AFTER ERROR
	JRST	START
SUBTTL	GET FILE PARAMETERS

ASKM:	TRNE	SW,OPT.B	;/B?
	JRST	ASKM2		;YES

	LDB	IM,[POINT 1,KEYDES,18]  ;/M OR /P: GET INPUT MODE FROM STATISTICS
	TRC	IM,1		;INTERNAL MODE SWITCH = OPPOSITE OF EXTERNAL
	TRNN	SW,OPT.M	;/M?
	JRST	ASKM1		;NO, /P

	HRRZI	OM,(IM)		;/M: OUTPUT MODE SAME AS INPUT MODE
	JRST	ASKM8

ASKM1:	TLNN	SW,(INDIR)	;SKIP QUESTION IF INDIR CMD FILE
	TTCALL	3,[ASCIZ "MODE OF OUTPUT FILE: "]  ;/P
	JRST	ASKM3

ASKM2:	TLNN	SW,(INDIR)	;SKIP QUESTION IF INDIR CMD FILE
	TTCALL	3,[ASCIZ "MODE OF INPUT FILE: "]  ;/B
	PUSHJ	PP,GETMOD
	JRST	.-2		;TROUBLE
	SKIPN	TB		;SET
	TDCA	IM,IM		;  INPUT
	MOVEI	IM,1		;  MODE

	TLNN	SW,(INDIR)	;SKIP QUESTION IF INDIR CMD FILE
	TTCALL	3,[ASCIZ "MODE OF DATA FILE: "]
ASKM3:	PUSHJ	PP,GETMOD
	JRST	.-2
	SKIPN	TB		;SET
	TDCA	OM,OM		;  OUTPUT
	MOVEI	OM,1		;  MODE

ASKM4:	TRNN	SW,OPT.B	;/B?
	JRST	ASKM8		;NO, /P

ASKM5:	TLNN	SW,(INDIR)	;SKIP QUESTION IF INDIR CMD FILE
	TTCALL	3,[ASCIZ "MAXIMUM RECORD SIZE: "]
	PUSHJ	PP,GETPOS
	JRST	.-2
	CAILE	TE,7777		;RECORD SIZE MUST BE < 4096
	JRST	SIZERR		;TOO BIG

	MOVEM	TE,RECBYT
	CAIN	OM,0		;CONVERT
	JRST	ASKM6		;  RECORD
	ADDI	TE,5		;  SIZE
	IDIVI	TE,6		;  TO
	JRST	ASKM7		;  WORDS
ASKM6:	ADDI	TE,6		;  *
	IDIVI	TE,5		;  *
ASKM7:	MOVEM	TE,RECSIZ	;  *
ASKM8:	PUSHJ	PP,GETKEY	;GET KEY DESCRIPTOR
	TRNE	SW,OPT.M
	JRST	ASKM12		;SKIP NEXT QUESTION IF /M

	MOVE	TE,LASTKB	;IF KEY WON'T
	CAMLE	TE,RECBYT	;  FIT IN RECORD,
	JRST	BIGKEY		;  WE HAVE TROUBLE

ASKM9:	TRNN	SW,OPT.P
	JRST	ASKM10		;/B

	TLNN	SW,(INDIR)	;SKIP QUESTION IF INDIR CMD FILE
	TTCALL	3,[ASCIZ "RECORDS PER OUTPUT BLOCK: "]  ;/P
	MOVEI	TE,0		;IF NO ANSWER, ASSUME UNBLOCKED
	JRST	ASKM11

ASKM10:	TLNN	SW,(INDIR)	;SKIP QUESTION IF INDIR CMD FILE
	TTCALL	3,[ASCIZ "RECORDS PER INPUT BLOCK: "]  ;/B
ASKM11:	PUSHJ	PP,GETNUM
	JRST	.-2
	MOVEM	TE,INPBLK
	TRNE	SW,OPT.P
	JRST	ASKM14
ASKM12:	MOVE	TE,DATBLK+I	;AIM AT DATBLK
	TLNN	SW,(INDIR)	;SKIP QUESTION IF INDIR CMD FILE
	TTCALL	3,[ASCIZ "TOTAL RECORDS PER DATA BLOCK"]
	PUSHJ	PP,MCUR		;IF /M, GIVE CURRENT
	PUSHJ	PP,GETNUM
	JRST	.-3
	TRNN	SW,OPT.B	;IF /B, POSITIVE RESPONSE REQUIRED
	JRST	.+4		;NOT /B
	JUMPG	TE,.+3		;OK
	PUSHJ	PP,POSERR	;WARNING
	JRST	ASKM12		;TRY AGAIN
	TLZE	SW,(FGETDC)	;IF /M, LEAVE AS IS IF NULL RESPONSE
	MOVEM	TE,DATBLK

ASKM13:	MOVE	TE,EMPDAT+I	;AIM AT EMPDAT
	TLNN	SW,(INDIR)	;SKIP QUESTION IF INDIR CMD FILE
	TTCALL	3,[ASCIZ "EMPTY RECORDS PER DATA BLOCK"]
	PUSHJ	PP,MCUR		;IF /M, GIVE CURRENT
	PUSHJ	PP,GETNUM
	JRST	.-3
	TLZE	SW,(FGETDC)	;LEAVE AS IS IF NULL RESPONSE
	MOVEM	TE,EMPDAT

ASKM14:	MOVN	TE,EMPDAT	;COMPUTE
	ADD	TE,DATBLK	;  RECORDS
	MOVEM	TE,DATRIT	;  TO USE
	JUMPLE	TE,TOOMCH	;IF NOT POSITIVE, ERROR

	MOVE	TE,RECSIZ	;COMPUTE
	ADDI	TE,1		;  NUMBER
	IMUL	TE,DATBLK	;  OF
	ADDI	TE,177		;  SECTORS
	LSH	TE,-7		;  PER
	MOVEM	TE,DATSEC	;  DATA BLOCK
ASKM15:	TRNE	SW,OPT.P
	JRST	ASKM16

	MOVE	TE,IDXBLK+I	;AIM AT IDXBLK
	TLNN	SW,(INDIR)	;SKIP QUESTION IF INDIR CMD FILE
	TTCALL	3,[ASCIZ "TOTAL ENTRIES PER INDEX BLOCK"]
	PUSHJ	PP,MCUR		;IF /M, GIVE CURRENT
	PUSHJ	PP,GETNUM
	JRST	.-3
	TRNN	SW,OPT.B	;IF /B, POSITIVE RESPONSE REQUIRED
	JRST	.+4		;NOT /B
	JUMPG	TE,.+3		;OK
	PUSHJ	PP,POSERR	;WARNING
	JRST	ASKM12		;TRY AGAIN
	TLZE	SW,(FGETDC)	;IF /M, LEAVE AS IS IF NULL RESPONSE
	MOVEM	TE,IDXBLK
	MOVE	TE,IDXBLK
	CAIGE	TE,2		;MUST HAVE AT LEAST 2
	JRST	TOOFEW		;ERROR

	MOVE	TE,[IDXBLK,,IDXBLK+1]	;ALL LEVELS THE SAME
	BLT	TE,IDXBLK+^D9

ASKM16:	MOVE	TE,SIZIDX
	IMUL	TE,IDXBLK	;MULTIPLY INDEX ENTRY SIZE BY BLOCKING
	ADDI	TE,1+177	;ADD 1 WORD FOR HEADER, AND ROUND UP
	LSH	TE,-7		;CONVERT TO SECTORS
	MOVEM	TE,IDXSEC

	MOVEI	TE,1		;FIRST EMPTY INDEX SECTOR IS
	MOVEM	TE,FEISEC	;  NUMBER 1

	MOVE	TE,SIZIDX	;COMPUTE
	IMUL	TE,IDXBLK	;  NUMBER OF
	ADDI	TE,1		;  BYTES IN
	IMULI	TE,6		;  INDEX
	MOVEM	TE,STHDR	;  BLOCK
	CAILE	TE,7777		;IF IT IS NOT TOO BIG, ALL IS WELL
	JRST	BIGIDX		;IT IS TOO BIG

	TRNE	SW,OPT.P
	JRST	ASKM17

	MOVE	TE,EMPIDX+I	;AIM AT EMPIDX
	TLNN	SW,(INDIR)	;SKIP QUESTION IF INDIR CMD FILE
	TTCALL	3,[ASCIZ "EMPTY ENTRIES PER INDEX BLOCK"]
	PUSHJ	PP,MCUR		;IF /M, GIVE CURRENT
	PUSHJ	PP,GETNUM
	JRST	.-3
	TLZE	SW,(FGETDC)	;LEAVE AS IS IF NULL RESPONSE
	MOVEM	TE,EMPIDX

	MOVE	TE,[EMPIDX,,EMPIDX+1]	;ALL LEVELS THE SAME
	BLT	TE,EMPIDX+^D9
ASKM17:	MOVN	TE,EMPIDX	;COMPUTE
	ADD	TE,IDXBLK	;  NUMBER OF
	MOVEM	TE,IDXRIT	;  ENTRIES TO USE
	CAIG	TE,1		;IF ONLY ONE ENTRY
	JRST	TOOFEW		;  OR IF NOT POSITIVE, ERROR

	TRNE	SW,OPT.P
	JRST	SETIO

ASKM18:	MOVE	TE,%DAT+I	;AIM AT %DAT
	TLNN	SW,(INDIR)	;SKIP QUESTION IF INDIR CMD FILE
	TTCALL	3,[ASCIZ "PERCENTAGE OF DATA FILE TO LEAVE EMPTY"]
	PUSHJ	PP,MCUR		;IF /M, GIVE CURRENT
	PUSHJ	PP,GETNUM
	JRST	.-3
	TLZE	SW,(FGETDC)	;LEAVE AS IS IF NULL RESPONSE
	MOVEM	TE,%DAT
	CAIGE	TE,^D100	;% MUST BE 0 .LE. N .LT. 100
	JUMPGE	TE,ASKM19	;OK
	JRST	ERR%DA

ASKM19:	MOVE	TE,%IDX+I	;AIM AT %IDX
	TLNN	SW,(INDIR)	;SKIP QUESTION IF INDIR CMD FILE
	TTCALL	3,[ASCIZ "PERCENTAGE OF INDEX FILE TO LEAVE EMPTY"]
	PUSHJ	PP,MCUR		;IF /M, GIVE CURRENT
	PUSHJ	PP,GETNUM
	JRST	.-2
	TLZE	SW,(FGETDC)	;LEAVE AS IS IF NULL RESPONSE
	MOVEM	TE,%IDX
	CAIGE	TE,^D100
	JUMPGE	TE,ASKM20
	JRST	ERR%IX

ASKM20:	MOVE	TE,MAXSAT+I	;AIM AT MAX # RECORDS
	TLNN	SW,(INDIR)	;SKIP QUESTION IF INDIR CMD FILE
	TTCALL	3,[ASCIZ "MAXIMUM NUMBER OF RECORDS FILE CAN BECOME"]
	PUSHJ	PP,MCUR
	PUSHJ	PP,GETNUM
	JRST	.-3
	TLZE	SW,(FGETDC)
	MOVEM	TE,MAXSAT
;NOW FILL IN SOME STATISTIC WORDS

	MOVE	TE,[XWD OF2DAT+DEV,STDEV]
	BLT	TE,STEXT

	CALLI	TE,$DATE	;FIX
	MOVEM	TE,CREATE	;  CREATION DATE AND
	MOVEM	TE,ACCDAT	;  ACCESS DTAE

	MOVEI	TE,0		;SET DATA MODE BIT
	JUMPN	OM,.+2		;SIXBIT
	MOVEI	TE,1		;ASCII
	DPB	TE,[POINT 1,KEYDES,18]
SUBTTL	GET READY FOR I/O

SETIO:	RELEASE	CMD,		;IN CASE INDIRECT CMD FILE WAS OPEN
	TLZ	SW,(FRECIN)	;CLR RECORD-SEEN FLAG
	SETZM	IDXLOC		;CLEAR INDEX INFO
	MOVE	TE,[XWD IDXLOC,IDXLOC+1]
	BLT	TE,IDXFLG+^D9

	TRNE	SW,OPT.B
	JRST	SETIO3

	MOVE	TE,LEVELS+I	;GET INDEX SPACE FOR /P, /M INPUT
	MOVE	TA,IDXSEC+I
	LSH	TA,7		;TA=NUMBER OF WORDS/BLK OF INDEX
	MOVEM	TA,IDXSIZ
	IMULI	TE,(TA)		;TE=TOTAL # WORDS FOR ALL INDEX LEVELS
	HRRZ	TD,JOBFF##	;ADDR FOR 1ST LEVEL OF INPUT INDEX
	MOVEM	TD,IDXLIN
	PUSHJ	PP,GETCOR

	MOVE	TB,IDXLIN	;MAKE PTR TO EACH LEVEL
	MOVE	TE,IDXBLK+I	;# ENTRIES AT EACH INPUT INDEX BLK
	MOVEM	TE,IDXEIN
	MOVEI	TC,1		;START AT LEVEL 2
SETIO8:	ADD	TB,IDXSIZ
	MOVEM	TB,IDXLIN(TC)
	MOVEM	TE,IDXEIN(TC)
	CAMGE	TC,LEVELS+I
	AOJA	TC,SETIO8

	MOVE	TE,RECSIZ+I	;GET SPACE FOR /P, /M DATA INPUT
	ADDI	TE,1		;INCLUDE HEADER WORD OF EACH RECORD
	IMUL	TE,DATBLK+I
	MOVEM	TE,INSIZ
	MOVE	TD,JOBFF
	MOVEM	TD,INDAT
	PUSHJ	PP,GETCOR

	MOVE	IX,LEVELS+I	;READ IN TOP LEVEL OF INDEX
	MOVE	TA,IDXADR+I
	USETI	IF1,(TA)
	PUSHJ	PP,IDXREA
	MOVSI	TA,377777	;FORCE A CALL TO DATREA
	MOVEM	TA,DATFLG
SETIO3:	OUTBUF	OF2,2		;GET 2 BUFFERS FOR DATA FILE
	MOVEI	TE,7		;PUT CORRECT
	TRC	TE,(OM)		;  BYTE SIZE IN
	DPB	TE,[POINT 6,OF2BUF+1,11]; BUFFER HEADER WORD

	TRNE	SW,OPT.P	;/P?
	JRST	SETIO2		;YES

	PUSHJ	PP,GETLVL	;/M OR /B: GET CORE FOR OUTPUT INDEX

	TRNE	SW,OPT.M
	JRST	SETIO7

	INBUF	IF1,2		;/B: GET 2 BUFFERS FOR INPUT FILE
	MOVEI	TE,7		;GET CORRECT BYTE SIZE AGAIN
	TRC	TE,(IM)
	DPB	TE,[POINT 6,IF1BUF+1,11]

SETIO2:	TLNE	SW,(FMTA)	;MAG TAPE?
	PUSHJ	PP,BLDBUF	;YES, MAKE NON-STD BUFFERS
SETIO7:	MOVE	TE,SIZKEY	;GET SIZE OF INDEX KEY
	MOVE	TD,JOBFF	;RESERVE
	MOVEM	TD,OLDKEY	;  AN AREA TO
	PUSHJ	PP,GETCOR	;  SAVE RECORD KEY

	MOVE	TE,SIZKEY	;DO SAME
	MOVE	TD,JOBFF	;  FOR
	MOVEM	TD,NEWKEY	;  NEW
	PUSHJ	PP,GETCOR	;  KEY

	TRNE	SW,OPT.B
	JRST	SETIO9		;/B

	MOVE	TE,SIZKEY	;GET SPACE FOR INPUT KEY
	MOVE	TD,JOBFF
	MOVEM	TD,INKEY
	PUSHJ	PP,GETCOR

SETIO9:	MOVEI	TE,(POINT 7,0)	;CHANGE
	CAIE	OM,0		;  THOSE
	MOVEI	TE,(POINT 6,0)	;  ADDRESSES
	HRLM	TE,OLDKEY	;  TO
	HRLM	TE,NEWKEY	;  BYTE-POINTERS

	MOVEI	TE,(POINT 7,0)	;MAKE INPUT KEY BYTE PTR
	CAIE	IM,0
	MOVEI	TE,(POINT 6,0)
	HRLM	TE,INKEY

	TLNN	SW,(FNUM)	;IS KEY NUMERIC?
	TDCA	TE,TE		;NO--SET TO ALPHA LOW-VALUES
	MOVSI	TE,1B18		;YES--SET TO NUMERIC LOW-VALUES
	MOVE	TD,SIZKEY
	MOVE	TC,OLDKEY

	MOVEM	TE,(TC)
	SOJLE	TD,.+2
	AOJA	TC,.-2

	MOVE	TC,NEWKEY	;CLR NEWKEY AREA
	MOVE	TD,SIZKEY
	SETZM	(TC)
	SOJG	TD,.-1
	TLNE	SW,(FDSK)	;IF DISK INPUT & IT IS BLOCKED,
	SKIPN	INPBLK
	JRST	SETIO6
	MOVE	TE,RECBYT	;COMPUTE # SECTORS PER INPUT BLK
	CAIE	IM,1
	JRST	SETIO4
	ADDI	TE,^D11
	IDIVI	TE,6
	IMUL	TE,INPBLK
	JRST	SETIO5
SETIO4:	ADDI	TE,2
	IMUL	TE,INPBLK
	ADDI	TE,4
	IDIVI	TE,5
SETIO5:	ADDI	TE,177
	LSH	TE,-7
	MOVEM	TE,INPSEC

SETIO6:	SETOM	OSECC
	SETZM	MUCHO
	SETZM	DATLOC
	MOVEI	TE,1
	MOVEM	TE,DATLOK
	MOVE	TE,DATRIT
	MOVEM	TE,ORLEFTOVSI	TD,(POINT 6,0)
	CAIE	OM,1
	TLO	TD,100
	MOVE	TE,RECSIZ
	HRR	TD,JOBFF
	MOVEM	TD,RECPTR

	TRNN	SW,OPT.P	;/P?
	JRST	SETI10		;NO

	MOVE	TE,INPBLK	;FOR /P, SWITCH INPUT ARGS TO OUTPUT
	MOVEM	TE,DATBLK
	MOVEM	TE,DATRIT
	MOVEM	TE,ORLEFT	;NO EMPTY RECORDS ON /P
	SETZM	INPBLK
	MOVE	TE,INPSEC
	MOVEM	TE,DATSEC
	SETZM	INPSEC
	JRST	LOOP7

SETI10:	PUSHJ	PP,GETCOR

	PUSHJ	PP,RITID1	;WRITE OUT EMPTY BLOCK TO BE
				;  REPLACED LATER BY STATISTICS BLOCK

	JRST	LOOP7
SUBTTL	THE MAIN READ/WRITE LOOP

LOOP:	TLNE	SW,(FEOF)	;AT END OF FILE?
	JRST	ALLDUN		;YES
	SETZM	OC
	MOVE	OP,RECPTR
LOOP1:	TLZ	SW,(FENDL)
	SETZ	TF,		;TF=0 FOR SEQUENTIAL INPUT
	TRNN	SW,OPT.B
	AOJ	TF,		;TF=1 FOR INDEXED FILE INPUT
	PUSHJ	PP,@GETFB(TF)	;GET A CHARACTER
	TLNE	SW,(FEOF)	;AT END OF FILE NOW?
	JRST	ALLDUN		;YES
	TLO	SW,(FRECIN)	;A RECORD HAS BEEN SEEN
	TLNE	SW,(FENDIB)	;NO--AT END OF BLOCK?
	JRST	LOOP6		;YES
	TLNE	SW,(FENDL)	;NO--AT END OF LINE?
	JRST	LOOP1		;YES--SKIP PAST E-O-L


LOOP2:	XCT	@CONVRT(IM)	;CONVERT CHARACTER IF NECESSARY
	CAMGE	OC,RECBYT	;IF STILL ROOM IN RECORD,
	IDPB	CH,OP		;  STASH CHARACTER IN RECORD
	ADDI	OC,1

	SETZ	TF,
	TRNN	SW,OPT.B
	AOJ	TF,
	PUSHJ	PP,@GETBYT(TF)	;GET ANOTHER BYTE
	TLNN	SW,(FEOF!FENDIB!FENDL)
	JRST	LOOP2

	PUSHJ	PP,CAMKEY	;BE SURE KEYS ARE IN ORDER
	PUSHJ	PP,@FINREC(OM)	;FINISH UP THE RECORD
	TRNE	SW,OPT.P	;/P?
	JRST	LOOP9		;YES, NO OUTPUT INDEX

	MOVE	CH,ORLEFT	;IS THIS THE
	CAMN	CH,DATRIT	;  FIRST RECORD IN BLOCK?
	PUSHJ	PP,RITKEY	;YES--WRITE A KEY
LOOP8:	SOSLE	ORLEFT		;IS BLOCK FULL?
	JRST	LOOP5		;NO

	PUSHJ	PP,WRITE	;YES--WRITE IT OUT
LOOP3:	AOS	OF2BUF+2
	MOVE	TE,OSECC	;IF ENOUGH
	CAML	TE,DATSEC	;  SECTORS WRITTEN,
	JRST	LOOP4		;  NO MORE NEEDED
	PUSHJ	PP,WRITE	;WRITE AN EMPTY RECORD
	JRST	LOOP3		;  AND LOOP

LOOP4:	MOVE	TE,DATRIT	;RESET
	MOVEM	TE,ORLEFT	;  BLOCK COUNTER
	MOVE	TE,DATLOC	;REMEMBER LAST SECTOR USED
	MOVEM	TE,DATLOK
	SETZM	OSECC

LOOP5:	SKIPE	INPBLK		;IS INPUT BLOCKED?
	SOSLE	IRLEFT		;YES--ANYTHING LEFT IN BLOCK?
	JRST	LOOP		;NO

LOOP6:	TLZE	SW,(FENDIB)	;NO--ANY MORE SECTORS?
	JRST	LOOP7		;NO
	PUSHJ	PP,READ		;YES--GET ANOTHER SECTOR
	JRST	LOOP6		;  AND LOOP

LOOP7:	SETZM	IF1BUF+2	;BE SURE A READ HAPPENS NEXT TIME
	SETZM	ISECC
	MOVE	TE,INPBLK
	MOVEM	TE,IRLEFT
	JRST	LOOP

LOOP9:	SKIPE	DATBLK		;/P BLOCKED?
	JRST	LOOP8		;YES
	JRST	LOOP5		;NO
;FINISH UP OUTPUT RECORD

FINREC:	EXP	FINRCA		;OUTPUT IS ASCII
	EXP	FINRCS		;OUTPUT IS SIXBIT

FINRCA:	MOVEI	CH,15		;PUT
	IDPB	CH,OP		;  CARRIAGE-RETURN
	MOVEI	CH,12		;  AND LINE-FEED
	IDPB	CH,OP		;  INTO RECORD

	CAMLE	OC,RECBYT
	MOVE	OC,RECBYT
	ADDI	OC,2

	MOVE	TE,OC
	LSH	TE,1
	IORI	TE,1
	MOVNI	TD,4
	JRST	FINRCX

FINRCS:	CAMLE	OC,RECBYT
	MOVE	OC,RECBYT
	MOVE	TE,OC
	MOVNI	TD,5

FINRCX:	AOS	MUCHO
	JUMPN	OM,.+3		;SKIP TEST IF SIXBIT
	TRNE	SW,OPT.P	;ASCII /P?
	JRST	FINRC1		;YES
	MOVEI	CH,0		;GET BYTE-POINTER TO
	PUSHJ	PP,PUTBYT	;  FIRST WORD OF NEXT RECORD
	HRLI	TE,$ISAMS	;PUT SIXBIT ISAM DATA FLAG IN LEFT HALF
	JUMPN	OM,.+2
	HRLI	TE,$ISAMA	;OR ASCII ISAM DATA FLAG IF FILE IS ASCII
	TRNE	SW,OPT.P	;/P?
	HRRZI	TE,(TE)		;YES
	MOVEM	TE,@OF2BUF+1	;PUT OUT COUNT WORD
	MOVSI	TE,770000	;SET BYTE-POINTER TO
	ANDCAM	TE,OF2BUF+1	;  END OF WORD
	ADDB	TD,OF2BUF+2	;DECREMENT BUFFER COUNTER

FINRC1:	MOVE	OP,RECPTR

FINRCY:	ILDB	CH,OP		;GET BYTE FROM HOLD-RECORD AREA
	PUSHJ	PP,PUTBYT	;WRITE IT ONTO DATA FILE
	SOJG	OC,FINRCY	;LOOP THROUGH RECORD

FINRCZ:	JUMPN	OM,.+3		;SKIP TEST IF SIXBIT
	TRNE	SW,OPT.P
	POPJ	PP,
	MOVE	TE,OF2BUF+1	;IF
	TLNN	TE,760000	;  WE ARE NOT
	POPJ	PP,		;  AT THE END OF A WORD,
	SOS	OF2BUF+2	;  PUT
	IBP	OF2BUF+1	;  OUT LOW-VALUES
	JRST	FINRCZ		;  UNTIL WE ARE
;CONVERT INPUT CHARACTER IF NECESSARY

CONVRT:	Z	CONV1(OM)	;INPUT IS ASCII
	Z	CONV2(OM)	;INPUT IS SIXBIT
CONV1:	JFCL			;ASCII TO ASCII
	PUSHJ	PP,CONV3	;ASCII TO SIXBIT
CONV2:	ADDI	CH,40		;SIXBIT TO ASCII
	JFCL			;SIXBIT TO SIXBIT

CONV3:	CAIGE	CH,40		;IS IT A CONTROL CHARACTER?
	JRST	CONV5		;YES
	CAILE	CH,137		;NO--IS IT WITHIN SIXBIT RANGE?
	JRST	CONV4		;NO
	SUBI	CH,40		;YES--CONVERT IT TO SIXBIT
	POPJ	PP,

CONV4:	CAIG	CH,"Z"+40	;IF IT IS NOT
	CAIGE	CH,"A"+40	;  A LOWER-CASE LETTER
CONV5:	MOVEI	CH,"\"-40	;USE BACKSLASH
	POPJ	PP,
;GET A BYTE FROM INPUT FILE.
;WHICH ROUTINE IS USED DEPENDS UPON MODE OF INPUT.

GETBYT:	Z	@GETBY0(IM)	;SEQUENTIAL INPUT
	Z	GETDAT		;INDEXED INPUT

GETBY0:	EXP	GETAM		;INPUT IS ASCII
	EXP	GETSM		;INPUT IS SIXBIT

;GET FIRST BYTE OF A RECORD

GETFB:	Z	@GETFB0(IM)	;SEQUENTIAL INPUT
	Z	IDXFB		;INDEXED INPUT

GETFB0:	EXP	GETFB2		;INPUT IS ASCII
	EXP	GETFB1		;INPUT IS SIXBIT

GETFB1:	MOVEI	TE,1
	MOVEM	TE,INPSIZ
	PUSHJ	PP,GETSM
	MOVE	TE,@IF1BUF+1
	MOVEM	TE,INPSIZ
	MOVNI	TE,5
	ADDM	TE,IF1BUF+2
	MOVSI	TE,770000
	ANDCAM	TE,IF1BUF+1
	TLNE	SW,(FENDIB)
	POPJ	PP,

	SKIPN	INPSIZ
	JRST	GETFB1
	JRST	GETSM

GETFB2:	PUSHJ	PP,GETAM
	MOVE	TE,@IF1BUF+1
	TRNN	TE,1B35		;SEQ # FLAG UP?
	POPJ	PP,		;NO

	IBP	IF1BUF+1	;IGNORE SEQ # WORD
	IBP	IF1BUF+1
	IBP	IF1BUF+1
	IBP	IF1BUF+1
	JRST	GETAM		;NOW GET REAL 1ST CHAR
;GET FIRST BYTE OF RECORD (INDEXED FILE INPUT)

IDXFB:	PUSHJ	PP,GETREC	;GET RECORD OF INPUT
	JRST	GETDAT

;GET 1 RECORD OF INDEXED FILE

GETREC:	MOVE	TA,DATFLG	;USED ALL RECORDS IN CURRENT BLK?
	CAMGE	TA,DATBLK+I
	JRST	GETRE1		;NO

GETRE3:	PUSHJ	PP,GETENT	;READ 1 ENTRY OF INDEX
	TLNE	SW,(FEOF)	;END-OF-FILE?
	POPJ	PP,		;YES

	MOVE	TA,IDXHD1	;GET DATA BLK #
	USETI	IF2,(TA)	;AIM AT THAT BLK
	PUSHJ	PP,DATREA	;& READ IT IN

GETRE1:	AOS	TA,DATFLG	;INCR COUNT TO NEW RECORD
	SUBI	TA,1		;ADVANCE BYTE PTR TO NEW RECORD
	HRRZ	TA,INPTR	;INCREMENT INPTR TO 1ST WORD OF NEXT REC
	AOJ	TA,
	HRLI	TA,(POINT 6,0)
	CAIN	IM,0
	HRLI	TA,(POINT 7,0)
	MOVEM	TA,INPTR

	HRRZ	TA,@INPTR	;GET REC SIZE
	CAIN	IM,0
	LSH	TA,-1		;DROP BIT 35 IF ASCII FILE
	JUMPE	TA,GETRE3	;IGNORE EMPTIES
	MOVEM	TA,INPSIZ
	AOS	INPTR		;SET PTR TO 1ST REAL BYTE
	POPJ	PP,
;READ 1 ENTRY OF INDEX

GETENT:	MOVE	TA,IDXFLG-1(IX)	;LAST ENTRY READ AT THIS LEVEL
	CAMG	TA,IDXEIN-1(IX)	;ANYMORE THERE?
	JRST	GETEN1		;YES

GETEN2:	CAME	IX,LEVELS+I	;ARE WE ALREADY AT TOP LEVEL?
	AOJA	IX,GETENT	;NO, MOVE UP 1 LEVEL

	TLO	SW,(FEOF)	;HAVE HIT END OF FILE
CPOPJ:	POPJ	PP,

GETEN1:	MOVE	TF,IDXLIN-1(IX)	;MAKE BYTE PTR TO CURRENT ENTRY
	ADD	TF,IDXWIN-1(IX)

	MOVE	TA,(TF)		;STORE 1ST 2 WORDS OF ENTRY
	JUMPE	TA,GETEN2	;ENTRY IS EMPTY
	MOVEM	TA,IDXHD1	;BLOCK # THIS ENTRY POINTS TO
	MOVE	TA,1(TF)
	MOVEM	TA,IDXHD2	;ITS VERSION #

	MOVE	TC,SIZIDX+I	;READ & SAVE THE KEY
	SUBI	TC,2
	HRLZI	TA,2(TF)
	HRRZ	TB,INKEY
	HRRI	TA,(TB)
	ADDI	TB,-1(TC)
	BLT	TA,(TB)

	MOVE	TF,IDXWIN-1(IX)	;MAKE PTR TO NEXT INDEX ENTRY
	ADD	TF,SIZIDX+I
	MOVEM	TF,IDXWIN-1(IX)
	AOS	IDXFLG-1(IX)	;INCREMENT ENTRY USED CTR

	SOJE	IX,GETEN3	;EXIT IF AT LEVEL 0 INDEX
	MOVE	TA,IDXHD1	;  OTHERWISE DROP BACK DOWN 1 LEVEL
	USETI	IF1,(TA)	;AIM AT DESIRED LOWER LEVEL BLK OF IDX
	PUSHJ	PP,IDXREA	;READ IT
	JRST	GETEN1

GETEN3:	CAIN	IX,0		;IF IX HAS GONE TO 0, RESET IT TO 1
	MOVEI	IX,1
	POPJ	PP,
SUBTTL	COMPARE NEW KEY VERSUS OLD KEY

CAMKEY:	CAIE	OM,0		;IF
	TDCA	CH,CH		;  THE
	MOVEI	CH," "		;  RECORD
CAMK0:	CAML	OC,LASTKB	;  DOESN'T EXTEND
	JRST	CAMK1		;  PAST THE KEY FIELD,
	IDPB	CH,OP		;  PAD IT WITH
	AOJA	OC,CAMK0	;  SPACES

CAMK1:	HRRZ	TA,RECPTR	;GET THIS
	ADD	TA,RECKEY	;  KEY
	MOVE	TB,NEWKEY	;  INTO
	PUSHJ	PP,@CAMKZ(KT)	;  NEWKEY

;COMPARE THE KEYS

	MOVE	TA,OLDKEY
	MOVE	TB,NEWKEY
	MOVE	TC,SIZKEY

CAMK2:	MOVE	TE,(TB)
	CAME	TE,(TA)
	JRST	CAMK2A
	SOJLE	TC,CAMK3
	ADDI	TB,1
	AOJA	TA,CAMK2
CAMK2A:	JUMPE	KT,CAMK2B
	CAML	TE,(TA)
	JRST	CAMK4
	JRST	CAMK2C

CAMK2B:	MOVE	TD,(TA)
	TLC	TD,1B18
	TLC	TE,1B18
	CAML	TE,TD
	JRST	CAMK4

;KEYS ARE OUT OF ORDER

CAMK2C:	TTCALL	3,[ASCIZ "?KEYS ARE OUT OF ORDER
"]
	MOVE	TA,NEWKEY
	PUSHJ	PP,@CAMKX(KT)
	TTCALL	3,[ASCIZ "
IS AFTER
"]
	MOVE	TA,OLDKEY
	JRST	CAMK3A
;TWO KEYS ARE EQUAL

CAMK3:	TTCALL	3,[ASCIZ "?TWO KEYS WITH EQUAL VALUE = "]
	MOVE	TA,NEWKEY
CAMK3A:	PUSHJ	PP,@CAMKX(KT)
	TTCALL	3,[ASCIZ "
"]
	JRST	START

;ALL IS OK--MOVE NEW KEY TO OLD KEY

CAMK4:	MOVE	TB,SIZKEY
	MOVE	TA,NEWKEY
	MOVE	TC,OLDKEY

CAMK5:	MOVE	TE,(TA)
	MOVEM	TE,(TC)
	SOJLE	TB,CAMK5A
	ADDI	TC,1
	AOJA	TA,CAMK5
CAMK5A:	POPJ	PP,
;DISPLAY A KEY

CAMKX:	EXP	CAMKX1	;NON-NUMERIC
	EXP	CAMKX2	;1-WORD NUMERIC
	EXP	CAMKX3	;2-WORD NUMERIC
	EXP	CAMKX2	;1-WORD FIXED-POINT
	EXP	CAMKX3	;2-WORD FIXED-POINT
	EXP	CAMKX4	;1-WORD FLOATING-POINT
	EXP	CAMKX5	;2-WORD FLOATING-POINT

CAMKX1:	MOVE	TC,KEYDES
	ANDI	TC,7777
CAMX1A:	ILDB	CH,TA
	CAIE	OM,0
	ADDI	CH,40
	TTCALL	1,CH
	SOJG	TC,CAMX1A
	POPJ	PP,

;1-WORD FIXED-POINT

CAMKX2:	MOVE	TE,(TA)
	JRST	PUTDEC

;2-WORD FIXED-POINT

CAMKX3:	MOVE	TD,(TA)
	MOVE	TE,1(TA)
	JUMPGE	TD,CAMX3A

	TTCALL	3,[ASCIZ "-"]
	SETCA	TD,
	MOVMS	TE
	TLZ	TE,1B18
	SKIPN	TE
	ADDI	TD,1

CAMX3A:	JUMPE	TD,PUTDC1	;IF VALUE IS ONE-WORD, USE OTHER ROUTINE
	IDIV	TD,[DEC 10000000000]
	EXCH	TD,TE
	PUSHJ	PP,PUTDC1
	MOVE	TE,TD
	JRST	PUTDC2

;1-WORD FLOATING-POINT

CAMKX4:	MOVE	TE,(TA)
	MOVE	TF,[POINT 3,TE]
	JRST	PUTOC3

;2-WORD FLOATING-POINT

CAMKX5:	MOVE	TE,(TA)
	MOVE	TF,[POINT 3,TE]
	PUSHJ	PP,PUTOC3
	TTCALL	3,[ASCIZ ","]
	MOVE	TE,1(TA)
	MOVE	TF,[POINT 3,TE]
	JRST	PUTOC3
;PICK UP THE NEXT KEY

CAMKZ:	EXP	CAMKZ1	;NON-NUMERIC
	EXP	CAMKZ2	;NUMERIC DISPLAY < 11 DIGITS
	EXP	CAMKZ2	;NUMERIC DISPLAY > 10 DIGITS
	EXP	CAMKZ4	;1-WORD FIXED-POINT
	EXP	CAMKZ3	;2-WORD FIXED POINT
	EXP	CAMKZ4	;1-WORD FLOATING-POINT
	EXP	CAMKZ3	;2-WORD FLOATING-POINT

CAMKZ1:	MOVE	TE,KEYDES
	ANDI	TE,7777

CAMZ1A:	ILDB	CH,TA
	IDPB	CH,TB
	SOJG	TE,CAMZ1A
	POPJ	PP,

;KEY IS NUMERIC DISPLAY

CAMKZ2:	PUSHJ	PP,SAVAC	;SAVE AC'S 0-16
	TLZ	TA,7777		;BUILD
	MOVE	TE,KEYDES	;  PARAMETER
	DPB	TE,[POINT 11,TA,17]; FOR
	TLNN	TE,UNSIGN	;  'GD6.'
	TLO	TA,4000		;  OR
	MOVEM	TA,GDPARM	;  'GD7.'

	MOVEI	16,GDPARM
	MOVEI	TE,GD6.##
	CAIE	OM,1
	MOVEI	TE,GD7.##
	PUSHJ	PP,(TE)

	MOVE	TE,SAVEAC+TB
	MOVEM	0,(TE)
	MOVE	TD,SIZKEY
	CAILE	TD,1
	MOVEM	1,1(TE)
	JRST	RESAC		;RESTORE AC'S AND RETURN

;KEY IS 1-WORD (FIXED OR FLOATING)

CAMKZ3:	MOVE	TD,(TA)
	MOVE	TE,KEYDES
	TLNE	TE,UNSIGN
	MOVMS	TD
	MOVEM	TD,(TB)
	POPJ	PP,
;KEY IS 2-WORDS (FIXED OR FLOATING)


CAMKZ4:	MOVE	TE,KEYDES
	TLNN	TE,UNSIGN
	JRST	CAMKZ5

	PUSHJ	PP,SAVAC
	MOVE	16,(TA)
	HRLI	16,(Z TA,)
	PUSHJ	PP,MAG.##
	MOVE	TE,SAVEAC+TB
	MOVEM	TA,(TE)
	MOVEM	TA+1,1(TE)
	JRST	RESAC

CAMKZ5:	MOVE	TE,1(TA)
	MOVEM	TE,1(TB)
	MOVE	TE,(TA)
	MOVEM	TE,(TB)
	POPJ	PP,
SUBTTL	FILE IS COMPLETE--FINISH UP INDEX

ALLDUN:	CLOSE	IF1,
	MOVE	TE,ORLEFT	;IS ANYTHING
	CAMN	TE,DATRIT	;  IN DATA BUFFER?
	JRST	ALLD2		;NO

	PUSHJ	PP,WRITE	;YES--WRITE IT OUT
ALLD1:	MOVE	TE,OSECC	;MAKE SURE
	CAML	TE,DATSEC	;  ALL SECTORS
	JRST	ALLD2		;  WRITTEN
	PUSHJ	PP,WRITE	;NOT ENOUGH--WRITE EMPTY ONE
	JRST	ALLD1		;  AND LOOP

ALLD2:	TRNE	SW,OPT.P	;NO EMPTY BLKS WITH /P
	JRST	ALLD10
	MOVE	TD,%DAT		;COMPUTE
	IMUL	TD,NDATB	;  NUMBER OF EMPTY BLOCKS REQUIRED
	MOVEI	TA,^D100	;# ADDITIONAL = %*CURRENT/100-%
	SUB	TA,%DAT
	IDIVI	TD,(TA)
	JUMPE	TE,.+2		;ANY REMAINDER?
	ADDI	TD,1		;YES, ROUND UPWARDS
	JUMPN	TD,ALLD12	;IF ZERO,
	MOVEI	TD,1		;  GIVE 1 EMPTY
	PUSHJ	PP,WRITE	;(MUST DO DUMMY OUTPUT 1ST)

ALLD12:	MOVEM	TD,NDATBE	;THAT IS NUMBER OF EMPTY DATA BLOCKS
	ADDM	TD,NDATB	;UPDATE TOTAL NUMBER OF BLOCKS
	IMUL	TD,DATSEC	;MULTIPLY BY NUMBER OF SECTORS PER BLOCK

ALLD3:	PUSHJ	PP,WRITE	;WRITE EMPTY SECTOR
	SOJG	TD,ALLD3	;LOOP UNTIL DONE

ALLD10:	CLOSE	OF2,		;CLOSE DATA FILE
	STATZ	OF2,$ERA	;BE SURE NO ERRORS
	JRST	DATERA

	TRNE	SW,OPT.P	;IF /P, WE ARE ALL DONE
	JRST	START

;WRITE OUT INDEX BLOCKS STILL IN CORE

ALLD4:	TLZN	SW,(FRECIN)	;IF NO DATA RECORDS SEEN,
	PUSHJ	PP,RITKEY	;  WRITE A DUMMY INDEX ENTRY
	MOVEI	TA,1		;START AT LEVEL ONE

ALLD5:	CAMN	TA,LEVELS	;IS THIS THE TOP LEVEL?
	JRST	ALLD9		;YES

	PUSH	PP,TA		;SAVE LEVEL
	PUSHJ	PP,RITKY4	;UPDATE HIGHER LEVELS AND WRITE THIS ONE
	POP	PP,TA		;RESTORE IN CASE 'RITKY4' CLOBBERED IT
	AOJA	TA,ALLD5	;GO TO NEXT HIGHER LEVEL

ALLD9:	MOVE	TE,FEISEC	;NEXT FREE SECTOR IS
	MOVEM	TE,IDXADR	;  LOCATION OF HIGHEST LEVEL INDEX BLOCK
	PUSHJ	PP,RITIDX	;WRITE OUT THAT BLOCK
;WRITE OUT SAT BLOCKS

	MOVE	TE,STHDR	;SAVE INDEX RECORD SIZE
	MOVEM	TE,SAVSTH

	MOVE	TE,IDXSEC	;COMPUTE
	LSH	TE,7		;  NUMBER
	SUBI	TE,1		;  OF CHARACTERS IN
	IMULI	TE,6		;  INDEX SECTOR
	MOVEM	TE,STHDR	;THAT IS RECORD SIZE FOR SAT BLOCKS
	IMULI	TE,6		;COMPUTE NUMBER OF BITS
	MOVEM	TE,NB1SB	;SAVE THAT

	MOVE	TD,FEISEC	;SAT BLOCKS WILL BE
	MOVEM	TD,SATADR	;  WRITTEN IN FIRST AVAILABLE BLOCK

	MOVE	TA,NDATB	;GET NUMBER OF DATA BLOCKS
	SUB	TA,NDATBE	;  LESS NUMBER OF EMPTIES
	MOVEM	TA,NBWRIT	;WE MUST PUT OUT THAT MANY 1-BITS
	JUMPE	TA,ALLD0	;NO BITS IF TA=0

ALLD6:	CAMLE	TA,NB1SB	;WILL THIS BLOCK BE FULL OF 1-BITS?
	MOVE	TA,NB1SB	;YES
	MOVN	TB,TA		;DECREMENT
	ADDM	TB,NBWRIT	;  NUMBER LEFT TO GO AFTER THIS ONE

	HRRZ	TB,IDXLOC	;BUILD
	ADD	TB,[POINT 1,1]	;  BYTE-POINTER
	MOVEI	TC,1		;FILL BLOCK WITH
	IDPB	TC,TB		;  ENOUGH
	SOJG	TA,.-1		;  ONE-BITS

ALLD0:	PUSHJ	PP,RITID1	;WRITE OUT SAT BLOCK
	AOS	NUMSAT		;INCREMENT NUMBER WRITTEN
	SKIPLE	TA,NBWRIT	;IF MORE TO GO,
	JRST	ALLD6		;  LOOP

	MOVE	TD,MAXSAT	;HOW MANY DID HE SAY HE WANTED?
	IDIV	TD,DATBLK
	MOVE	TA,NDATB
	CAIL	TA,(TD)		;IF MORE THAN WHAT WE COUNT,
	MOVE	TD,NDATB	;  GIVE THEM TO HIM
	MOVEM	TD,NDATBT

ALLD7:	MOVE	TA,NB1SB	;DO WE
	IMUL	TA,NUMSAT	;  NEED
	CAML	TA,NDATBT	;  MORE EMPTY ONES?
	JRST	ALLD8		;NO

	AOS	NUMSAT		;YES--WRITE OUT
	PUSHJ	PP,RITID1	;  AN EMPTY ONE
	JRST	ALLD7		;LOOP

ALLD8:	MOVEM	TA,SATBIT	;SAVE TOTAL NUMBER OF BITS IN ALL SAT BLOCKS

	MOVE	TE,SAVSTH	;RESTORE
	MOVEM	TE,STHDR	;  ORIGINAL RECORD SIZE
;NOW WRITE OUT ANY EMPTY INDEX BLOCKS REQUIRED

	MOVN	TE,IDXOUT	;SAVE NUMBER OF BLOCKS
	IMUL	TE,IDXSEC	;  ALREADY WRITTEN
	MOVEM	TE,NSECIE	;  AS NEGATIVE NUMBER (UPDATED LATER)

	MOVE	TC,IDXOUT	;GET NUMBER OF INDEX BLOCKS WRITTEN
	SUB	TC,NUMSAT	;  LESS NUMBER OF SAT BLOCKS
	SUBI	TC,1		;  LESS 1 FOR STATISTICS BLOCK
	IMUL	TC,%IDX		;COMPUTE # EMPTY BLKS REQUIRED
	MOVEI	TA,^D100
	SUB	TA,%IDX
	IDIVI	TC,(TA)
	JUMPE	TD,ALLD11	;ANY REMAINDER?
	ADDI	TC,1		;YES, ROUND UP
	JRST	ALLD11

	PUSHJ	PP,RITID1	;WRITE UNTIL
ALLD11:	SOJGE	TC,.-1		;  ENOUGH WRITTEN

	MOVE	TE,IDXOUT	;COMPUTE NUMBER OF
	IMUL	TE,IDXSEC	;  BLOCKS WRITTEN
	MOVEM	TE,NSECI	;  AND PUT IN STAT BLOCK
	ADDM	TE,NSECIE	;NUMBER OF FREE BLOCKS
	SUB	TE,NSECIE	;RECOMPUTE
	ADDI	TE,1		;  ADDRESS OF FIRST
	MOVEM	TE,FEISEC	;  FREE SECTOR

;WRITE OUT STATISTICS BLOCK

	MOVEI	TE,$ISAMI	;SET ISAM INDEX FLAG IN 1ST WORD
	HRLM	TE,STHDR

	MOVE	TE,.JBVER##	;PUT ISAM VERSION # IN STAT BLK
	MOVEM	TE,ISAVER

	MOVE	TE,IDXLOC	;MOVE STAT BLOCK
	HRLI	TE,STHDR	;  OVER
	MOVE	TD,TE		;  TO FIRST
	BLT	TE,STATSZ-1(TD)	;  INDEX BLOCK

	USETO	OF1,1		;WE WILL WRITE IN FIRST INDEX BLOCK
	PUSHJ	PP,RITID1

	CLOSE	OF1,		;CLOSE INDEX FILE
	STATZ	OF1,$ERA	;BE SURE THERE ARE
	JRST	IDXERA		;  NO ERRORS

	RELEASE	OF1,		;RELEASE
	RELEASE	OF2,		;  ALL
	RELEASE	IF1,		;  FILES
;DISPLAY SOME OF THE FINAL STATISTICS

	TTCALL	3,[ASCIZ "
"]
	MOVE	TE,LEVELS
	PUSHJ	PP,PUTDEC
	TTCALL	3,[ASCIZ " LEVEL"]
	MOVE	TE,LEVELS
	CAIE	TE,1
	TTCALL	3,[ASCIZ "S"]
	TTCALL	3,[ASCIZ " OF INDEX
"]

	MOVE	TE,MUCHO
	PUSHJ	PP,PUTDEC
	TTCALL	3,[ASCIZ " DATA RECORD"]
	MOVE	TE,MUCHO
	CAIE	TE,1
	TTCALL	3,[ASCIZ "S"]
	TTCALL	3,[ASCIZ "

"]

	JRST	START		;LOOP BACK TO THE BEGINNING
SUBTTL	PUT KEY INTO AN INDEX BLOCK

RITKEY:	AOS	NDATB		;INCREMENT NUMBER OF DATA BLOCKS
	MOVEI	TA,1		;START AT LOWEST LEVEL INDEX

	MOVE	TE,IDXEIB-1(TA)	;IS THIS
	CAML	TE,IDXRIT	;  BLOCK FULL?
	PUSHJ	PP,RITKY4	;YES--UPDATE HIGHER LEVELS AND WRITE THIS

	MOVE	TB,OLDKEY	;MOVE KEY FROM 'OLDKEY'
	MOVE	TE,DATLOK	;GET 1ST SECTOR NUMBER OF DATA BLOCK

RITKY1:	MOVE	TD,IDXWRD-1(TA)	;GET DESTINATION ADDRESS
	MOVE	TC,SIZKEY	;GET KEY SIZE IN WORDS
	MOVEM	TE,(TD)		;STASH SECTOR NUMBER

RITKY2:	MOVE	TE,(TB)		;GET WORD OF KEY
	SKIPN	IDX1KY-1(TA)	;1ST KEY AT THIS LEVEL?
	MOVE	TE,LOWVAL(KT)	;YES, GET LOW VALUES FOR THIS KEY TYPE
	MOVEM	TE,2(TD)	;STORE WORD OF KEY
	SOJLE	TC,RITKY3
	ADDI	TB,1
	AOJA	TD,RITKY2

RITKY3:	AOS	IDX1KY-1(TA)	;HAVE DONE 1ST KEY AT THIS LEVEL
	AOS	IDXEIB-1(TA)	;BUMP ENTRY COUNT FOR THIS BLOCK
	ADDI	TD,3		;BUMP LOCATION FOR
	MOVEM	TD,IDXWRD-1(TA)	;  NEXT ENTRY

	POPJ	PP,		;RETURN

;CURRENT INDEX BLOCK IS COMPLETE--UPDATE HIGHER LEVELS

RITKY4:	ADDI	TA,1		;STEP UP TO NEXT LEVEL
	CAMLE	TA,LEVELS	;IF THERE IS NO NEXT LEVEL,
	PUSHJ	PP,GETLVL	;  MAKE ONE

	MOVE	TE,IDXEIB-1(TA)	;IS THAT
	CAML	TE,IDXRIT	;  BLOCK FULL?
	PUSHJ	PP,RITKY4	;YES--GO UP TO NEXT

	MOVE	TB,IDXLOC-2(TA)	;WE WILL MOVE KEY FROM 1ST ENTRY IN
	ADDI	TB,4		;  NEXT LOWER LEVEL
	MOVE	TE,FEISEC	;MOVE SECTOR NUMBER OF INDEX BLOCK

	PUSHJ	PP,RITKY1	;STASH ENTRY AND UPDATE INFO FOR THIS BLOCK

	SUBI	TA,1		;DROP DOWN ONE LEVEL
	JRST	RITIDX		;WRITE THAT BLOCK AND RETURN
;LOW VALUES FOR EACH KEY TYPE

LOWVAL:	0			;NON-NUMERIC
	1B0			;NUMERIC DISPLAY
	1B0
	1B0			;COMP
	1B0
	1B0+1B35		;COMP-1
	1B0+1B35
SUBTTL	PICK UP KEY DESCRIPTOR

;GET KEY DESCRIPTOR OF THE FORM 'SXA.B'

GETKEY:	TLZ	SW,(FSIGN!FNUM)
	TRNN	SW,OPT.B
	JRST	GETK13		;/M OR /P: GET KEY INFO FROM STAT BLK

	SETZB	KT,KEYDES
	SETZM	RECKEY

	TLNN	SW,(INDIR)	;SKIP QUESTION IF INDIRECT COMMANDS
	TTCALL	3,[ASCIZ "KEY DESCRIPTOR: "]
	PUSHJ	PP,GETTY
	CAIN	CH,"S"		;IF 'S', FIELD IS SIGNED
	JRST	GETKY2

GETKY1:	CAIE	CH,"U"
	JRST	GETKY3
	MOVEI	TE,UNSIGN
	MOVEM	TE,KEYDES
GETKY2:	TLO	SW,(FSIGN)
	PUSHJ	PP,GETTY

GETKY3:	CAIN	CH,"X"
	JRST	GETKY4
	CAIN	CH,"N"
	MOVEI	KT,1
	CAIN	CH,"C"
	MOVEI	KT,3
	CAIN	CH,"F"
	MOVEI	KT,5
	JUMPLE	KT,GETKY5

	TLOA	SW,(FNUM)

GETKY4:	TLZ	SW,(FNUM)	;IF NOT NUMERIC, CLR SIGN FLAG
	PUSHJ	PP,GETTY

GETKY5:	MOVEM	CH,TTYKAR	;SAVE CH SO IT WILL BE PICKED UP BY 'GETDEC'
	PUSHJ	PP,GETDEC	;GET BYTE POSITION
	JUMPLE	TE,BADKEY
	CAIE	CH,"."		;MUST BE TERMINATED BY
	JRST	BADKEY		;  PERIOD
	SUBI	TE,1
	MOVEM	TE,FRSTKB	;SAVE RELATIVE BYTE POSITION

	CAIE	OM,1		;IS DATA-MODE SIXBIT?
	JRST	GETKY6		;NO
	IDIVI	TE,6		;YES--COMPUTE WORD OF FIRST BYTE
	HRLI	TE,600		;START MAKING BYTE-POINTER
	IMULI	TF,6		;GET NUMBER OF BITS TO LEFT OF FIELD
	JRST	GETKY7

GETKY6:	IDIVI	TE,5		;SIMILAR FOR
	HRLI	TE,700		;  ASCII
	IMULI	TF,7		;  RECORDING MODE

GETKY7:	MOVNS	TF		;COMPUTE BYTE RESIDUE
	ADDI	TF,^D36
	DPB	TF,[POINT 6,TE,5]; FINISH BYTE-POINTER
	MOVEM	TE,RECKEY

	PUSHJ	PP,GETPOS	;GET POSITIVE DECIMAL NUMBER
	JRST	BADKEY		;TROUBLE
	IORM	TE,KEYDES	;SAVE SIZE

	CAIG	TE,^D10		;IS BYTE-SIZE > 10?
	JRST	GETKY8		;NO
	TLNE	SW,(FNUM)	;YES--IS KEY NUMERIC?
	ADDI	KT,1		;YES--BUMP KEY TYPE BY ONE

GETKY8:	MOVE	TD,FRSTKB	;COMPUTE
	XCT	GETK12(KT)	;  LAST BYTE
	MOVEM	TD,LASTKB	;  POSITION

	DPB	KT,[POINT 3,KEYDES,23]
	HRLM	KT,KEYDES
;COMPUTE SIZE OF AN INDEX ENTRY

GETK14:	JUMPN	KT,GETK10	;IS KEY ALPHANUMERIC?
	CAIE	OM,1		;YES--IS DATA MODE SIXBIT?
	JRST	GETKY9		;NO
	ADDI	TE,5		;YES--CONVERT SIZE TO
	IDIVI	TE,6		;  WORDS
	JRST	GETK11
GETKY9:	ADDI	TE,4		;SIMILAR FOR
	IDIVI	TE,5		;  ASCII
	JRST	GETK11

GETK10:	MOVEI	TE,1		;ONE-WORD
	TRNN	KT,1		;  OR
	MOVEI	TE,2		;  TWO

GETK11:	MOVEM	TE,SIZKEY	;SAVE SIZE OF KEY, IN WORDS
	ADDI	TE,2		;ADD TWO WORDS FOR VERSION, POINTER
	MOVEM	TE,SIZIDX
	POPJ	PP,

;TABLE TO COMPUTE LAST BYTE POSITION OF KEY

GETK12:	ADD	TD,TE		;NON-NUMERIC
	ADD	TD,TE		;NUMERIC DISPLAY < 11 DIGITS
	ADD	TD,TE		;NUMERIC DISPLAY > 10 DIGITS
	ADDI	TD,6		;1-WORD FIXED POINT
	ADDI	TD,^D12		;2-WORD FIXED POINT
	ADDI	TD,6		;1-WORD FLOATING POINT
	ADDI	TD,^D12		;2-WORD FLOATING POINT
;/M OR /P: GET KEY INFO FROM STATISTICS BLOCK

GETK13:	LDB	TA,[POINT 1,KEYDES,20]	;GET SIGN BIT
	JUMPE	TA,.+3
	TLNE	SW,(FNUM)	;DON'T SET SIGN FLAG IF NOT NUMERIC
	TLO	SW,(FSIGN)	;IF ON, SET "UNSIGNED" FLAG

	HLRZ	KT,KEYDES	;GET KEY TYPE
	JUMPE	KT,.+2
	TLO	SW,(FNUM)	;IF > 0, SET "NUMERIC" FLAG

	TRNE	SW,OPT.P	;IF /P, USE IM INSTEAD OF OM
	EXCH	IM,OM		;  DURING CALCULATION OF FRSTKB

	HRRZ	TA,RECKEY	;REL POSITION OF KEY IN RECORD
	HRRZI	TB,6
	JUMPN	OM,.+2
	HRRZI	TB,5
	IMULI	TA,(TB)		;TIMES # BYTES PER WORD
	LDB	TD,[POINT 6,RECKEY,5]	;PLUS EXTRA BYTES BEFORE KEY
	HRRZI	TE,^D36
	SUBI	TE,(TD)
	HRRZI	TB,6
	JUMPN	OM,.+2
	HRRZI	TB,7
	IDIVI	TE,(TB)
	ADDI	TA,(TE)
	MOVEM	TA,FRSTKB	;GIVES BYTE POSITION OF KEY IN REC

	TRNE	SW,OPT.P	;IF /P, RESTORE IM AND OM
	EXCH	IM,OM

	LDB	TE,[POINT 12,KEYDES,35]	;ADD SIZE OF KEY
	ADDI	TA,(TE)
	MOVEM	TA,LASTKB

	TRNE	SW,OPT.M	;/M OR /P?
	JRST	GETK14		;/M: GO ON TO GET SIZE OF KEY IN WORDS

;/P: CREATE OUTPUT RECKEY OFFSET

	MOVE	TB,FRSTKB	;GET # OF BYTES BEFORE KEY
	MOVEI	TA,6		;GET # OF BYTES PER OUTPUT WORD
	CAIN	OM,0
	MOVEI	TA,5
	IDIVI	TB,(TA)		;Q= # OF OUTPUT WORDS BEFORE KEY
	MOVEM	TB,RECKEY
	CAIE	TA,6		;GET # OF BITS PER OUTPUT BYTE
	MOVEI	TA,7
	DPB	TA,[POINT 6,RECKEY,11]
	IMULI	TC,(TA)		;36-(R*(#BITS)) = # ODD BITS BEF. KEY
	MOVEI	TA,^D36
	SUBI	TA,(TC)
	DPB	TA,[POINT 6,RECKEY,5]
	JRST	GETK14
SUBTTL	SCAN COMMAND STRING FOR ONE FILE DESCRIPTOR

GETFIL:	SETZM	FILDAT		;CLEAR FILE
	MOVE	TE,[FILDAT,,FILDAT+1]	;  PARAMETER AREA
	BLT	TE,FILDAT+BUFADR-1

	PUSHJ	PP,GETSIX	;GET A WORD
	CAIE	CH,":"		;IS IT A DEVICE?
	JRST	GETFL1		;NO
	MOVEM	TE,DEV+FILDAT	;YES--SAVE IT
	PUSHJ	PP,GETSIX	;GET ANOTHER WORD

GETFL1:	MOVEM	TE,FILNAM+FILDAT	;SAVE FILE NAME
	CAIE	CH,"."		;IS THERE AN EXTENSION?
	JRST	GETFL2		;NO
	PUSHJ	PP,GETSIX	;YES--GET IT
	HLLZM	TE,FILEXT+FILDAT	;  AND SAVE IT
	AOS	FILEXT+FILDAT	;"." SEEN

GETFL2:	CAIN	CH,"/"		;SWITCH DELIMITER?
	JRST	GETFL3		;YES
	CAIE	CH,"["		;IS THERE A P-P NUMBER?
	POPJ	PP,		;NO--QUIT

	PUSHJ	PP,GETOCT	;YES--GET LEFT-HALF
	MOVSM	TE,PPNUM+FILDAT
	CAIE	CH,","		;MUST TERMINATE WITH
	JRST	GETFL4		;  COMMA
	PUSHJ	PP,GETOCT	;GET RIGHT-HALF
	HRRM	TE,PPNUM+FILDAT
	CAIE	CH,"]"		;MUST TERMINATE WITH RIGHT-BRACKET
	JRST	GETFL4		;IT DIDN'T
	PUSHJ	PP,GETTY	;IS THERE A SWITCH?
	CAIE	CH,"/"
	POPJ	PP,		;NO

GETFL3:	PUSHJ	PP,GETTY	;GET SWITCH
	CAIE	CH,"B"
	JRST	.+3
	MOVEI	TA,OPT.B
	JRST	GETFL7
	CAIE	CH,"P"
	JRST	.+3
	MOVEI	TA,OPT.P
	JRST	GETFL7
	CAIE	CH,"M"
	JRST	GETFL6		;ILLEGAL SWITCH
	MOVEI	TA,OPT.M
GETFL7:	TRO	SW,(TA)
	JRST	GETTY		;GET NEXT CHAR & RETURN

GETFL6:	TTCALL	3,[ASCIZ "?ILLEGAL SWITCH
"]
	JRST	GETFL8

GETFL4:	TTCALL	3,[ASCIZ "?IMPROPER PROJ-PROG NUMBER
"]
GETFL8:	TLO	SW,(FERROR)

GETFL5:	CAIE	CH,15
	CAIN	CH,"_"
	POPJ	PP,

	PUSHJ	PP,GETTY
	JRST	GETFL5
SUBTTL	BUILD TWO MAG-TAPE BUFFERS OF NON-STANDARD SIZE

IFE NEW,<
BLDBUF:	SKIPE	TE,INPBLK	;# RECORDS PER INPUT BLK SPECIFIED?
	JRST	BLDBF2		;YES

BLDBF1:	TRNE	SW,OPT.P	;/P?
	TTCALL	3,[ASCIZ "SIZE OF LARGEST OUTPUT BLOCK: "]
	TRNN	SW,OPT.P	;/P?
	TTCALL	3,[ASCIZ "SIZE OF LARGEST INPUT BLOCK: "]
	PUSHJ	PP,GETNUM
	JRST	BLDBF1		;ERROR, TRY AGAIN
	JUMPN	TE,BLDBF3
	POPJ	PP,
>
IFN NEW,<
BLDBUF:	SKIPN	TE,INPBLK	;# RECORDS PER INPUT BLOCK SPECIFIED?
	POPJ	PP,		;NO -- USE STANDARD LENGTH BUFFERS
>

BLDBF2:	MOVE	TD,RECBYT
	IMULI	TE,^D11(TD)

BLDBF3:	JUMPN	IM,BLDBF4	;ASCII?
	ADDI	TE,4		;YES, CONVERT
	IDIVI	TE,5		;  TO WORDS
	JRST	BLDBF5

BLDBF4:	ADDI	TE,5
	IDIVI	TE,6

BLDBF5:	ADDI	TE,1		;ONE FOR MONITOR OVERHEAD
	CAIGE	TE,^D21		;LEAVE ENOUGH ROOM FOR
	MOVEI	TE,^D21		;  LABELS
	HRRZ	TA,IF1BUF	;REBUILD
	TRNE	SW,OPT.P
	HRRZ	TA,OF2BUF

	MOVEI	TB,3(TA)	;  POINTER
	ADD	TB,TE		;  TO
	HRRM	TB,(TA)		;  NEXT BUFFER
	DPB	TE,[POINT 17,(TA),17]	;PUT IN SIZE OF BUFFER

	MOVEI	TD,2(TB)	;GET ENOUGH CORE FOR
	PUSHJ	PP,GETCOR	;  TWO BUFFERS

	MOVE	TD,JOBFF	;CLEAR
	MOVSI	TC,2(TA)	;  CORE
	HRRI	TC,3(TA)	;  THROUGH
	SETZM	2(TA)		;  BOTH
	BLT	TC,-1(TD)	;  BUFFERS

	MOVE	TC,-1(TA)	;CREATE
	MOVEM	TC,-1(TB)	;  NEW
	MOVE	TC,1(TA)	;  THREE-
	MOVEM	TC,1(TB)	;  WORD
	MOVE	TC,(TA)		;  BUFFER
	TRNE	SW,OPT.B
	HRR	TC,IF1BUF	;  HEADER
	TRNE	SW,OPT.P
	HRR	TC,OF2BUF
	MOVEM	TC,(TB)		;  *

	SETZM	INPBLK
	POPJ	PP,
SUBTTL	ERROR ROUTINES

;ENTER FAILURE

ENTERF:	TTCALL	3,[ASCIZ "?ENTER FAILURE ON "]
	MOVE	TE,DEV+FILDAT
	PUSHJ	PP,PUTSIX
	TTCALL	3,[ASCIZ ":"]
	MOVE	TE,FILNAM+FILDAT
	PUSHJ	PP,PUTSIX
	HLLZ	TE,FILEXT+FILDAT
	JUMPE	TE,ENTRF1
	TTCALL	3,[ASCIZ "."]
	PUSHJ	PP,PUTSIX

ENTRF1:	TTCALL	3,[ASCIZ " -- ("]
	JRST	LOOKF1

;LOOKUP FAILURE

LOOKF:	TTCALL	3,[ASCIZ "?LOOKUP FAILURE ON INPUT FILE -- ("]
	TRNE	TB,-1		;IS IT CODE ZERO?
	JRST	LOOKF1		;NO
	TTCALL	3,[ASCIZ "0"]
	HRRI	TB,-1
	JRST	LOOKF2

LOOKF1:	MOVEI	TE,(TB)
	PUSHJ	PP,PUTOCT

LOOKF2:	MOVE	TE,[XWD -LISTSZ,ERALST]

LOOKF3:	HLRZ	TF,(TE)
	CAIE	TF,(TB)
	AOBJN	TE,LOOKF3

	MOVE	TF,(TE)
	TTCALL	3,(TF)
	TTCALL	3,[ASCIZ "
"]
	TLO	SW,(FERROR)
	POPJ	PP,
;TABLE OF ERROR MESSAGE FOR LOOKUP/ENTER FAILURES

ERALST:	XWD	-1,[ASCIZ ") FILE NOT FOUND"]
	XWD	0,[ASCIZ ") ILLEGAL FILE NAME"]
	XWD	1,[ASCIZ ") UFD DOESN'T EXIST"]
	XWD	2,[ASCIZ ") PROTECTION FAILURE"]
	XWD	3,[ASCIZ ") FILE BEING MODIFIED"]
	XWD	6,[ASCIZ ") BAD UFD OT BAD RIB"]
	XWD	14,[ASCIZ ") DEVICE FULL, OR QUOTA EXCEEDED"]
	XWD	15,[ASCIZ ") DEVICE IS WRITE-LOCKED"]
	XWD	16,[ASCIZ ") NOT ENOUGH MONITOR TABLE SPACE"]
	XWD	0,[ASCIZ ") UNKNOWN ERROR"]

LISTSZ==.-ERALST-1
BADCOM:	TTCALL	3,[ASCIZ "?IMPROPER COMMAND STRING
"]
	PUSHJ	PP,SKPTTY
	JRST	START

BADDEV:	TTCALL	3,[ASCIZ "?INDEXED FILE DEVICES MUST BE DISKS
"]
	JRST	START

CANTOP:	TLO	SW,(FERROR)
	TTCALL	3,[ASCIZ "?CANNOT OPEN DEVICE "]
	MOVE	TE,TB
	PUSHJ	PP,PUTSIX
	TTCALL	3,[ASCIZ ":
"]
	POPJ	PP,
BADKEY:	TTCALL	3,[ASCIZ "?IMPROPER KEY DESCRIPTOR
"]
	PUSHJ	PP,SKPTTY
	JRST	GETKEY

BIGLVL:	TTCALL	3,[ASCIZ "?MORE THAN 10 LEVELS OF INDEX REQUIRED
"]
	JRST	START

NOCORE:	TTCALL	3,[ASCIZ "?NOT ENOUGH CORE TO COMPLETE THE JOB
"]
	JRST	START

REDERA:	TTCALL	3,[ASCIZ "?ERROR READING INPUT FILE
"]
	JRST	START

DATERA:	TTCALL	3,[ASCIZ "?ERROR WRITING DATA FILE
"]
	JRST	START

IDXERA:	TTCALL	3,[ASCIZ "?ERROR WRITING INDEX FILE
"]
	JRST	START

STATER:	TTCALL	3,[ASCIZ "?ERROR READING INDEX FILE
"]
	JRST	START

SIZERR:	TTCALL	3,[ASCIZ "?RECORD SIZE MUST BE LESS THAN 4096
"]
	JRST	ASKM5

BIGKEY:	TTCALL	3,[ASCIZ "?KEY IS OUTSIDE THE MAXIMUM RECORD
"]
	JRST	ASKM8

TOOMCH:	TTCALL	3,[ASCIZ "?MUST BE LESS THAN RECORDS PER BLOCK
"]
	JRST	ASKM13

BIGIDX:	ADDI	TE,5		;CONVERT TO
	IDIVI	TE,6		;  WORDS
	TTCALL	3,[ASCIZ "?INDEX BLOCK CONTAINS "]
	PUSHJ	PP,PUTDEC
	TTCALL	3,[ASCIZ " WORDS, MUST BE LESS THAN 683.
REDUCE THE NUMBER OF ENTRIES PER INDEX BLOCK.

"]
	JRST	ASKM15

TOOFEW:	TTCALL	3,[ASCIZ "?MUST HAVE AT LEAST TWO FULL ENTRIES PER BLOCK
"]
	JRST	ASKM15

DATERR:	TTCALL	3,[ASCIZ "?ERROR READING DATA FILE
"]
	JRST	START

CMDERR:	TTCALL	3,[ASCIZ "?CANNOT OPEN COMMAND FILE
"]
	JRST	START

CMDLER:	PUSHJ	PP,LOOKF
	JRST	START

CMDRER:	TTCALL	3,[ASCIZ "?ERROR READING COMMAND FILE
"]
	JRST	START

DBLIND:	TTCALL	3,[ASCIZ "?DOUBLE INDIRECT COMMAND
"]
	JRST	START

ERR%DA:	TTCALL	3,[ASCIZ "?INVALID PERCENTAGE
"]
	JRST	ASKM18

ERR%IX:	TTCALL	3,[ASCIZ "?INVALID PERCENTAGE
"]
	JRST	ASKM19
SUBTTL	MISCELLANEOUS ROUTINES

;TYPE OUT A WORD OF SIXBIT DATA

PUTSIX:	MOVE	TF,[POINT 6,TE]
PUTSX1:	ILDB	CH,TF
	JUMPE	CH,PUTSX9
	ADDI	CH,40
	TTCALL	1,CH
	TLNE	TF,770000
	JRST	PUTSX1
PUTSX9:	POPJ	PP,

;TYPE OUT A WORD OF OCTAL DATA

PUTOCT:	MOVE	TF,[POINT 3,TE]
PUTOC1:	ILDB	CH,TF
	JUMPN	CH,PUTOC2
	TLNE	TF,770000
	JRST	PUTOC1

PUTOC2:	ADDI	CH,"0"
	TTCALL	1,CH
	TLNN	TF,770000
	POPJ	PP,
PUTOC3:	ILDB	CH,TF
	JRST	PUTOC2
;TYPE OUT A SIGNED DECIMAL NUMBER, REMOVING LEADING ZEROES

PUTDEC:	JUMPGE	TE,PUTDC1	;IF NEGATIVE,
	TTCALL	3,[ASCIZ "-"]	;  TYPE SIGNED AND
	MOVMS	TE		;  GET MAGNITUDE

PUTDC1:	IDIVI	TE,^D10
	HRLM	TF,(PP)
	SKIPE	TE
	PUSHJ	PP,PUTDC1

	HLRZ	CH,(PP)
	ADDI	CH,"0"
	TTCALL	1,CH
	POPJ	PP,

;TYPE OUT AN UNSIGNED DECIMAL NUMBER, WITHOUT SUPPRESSING LEADING ZEROES

PUTDC2:	MOVEI	TD,^D10
PUTDC3:	IDIVI	TE,^D10
	HRLM	TF,(PP)
	SOSLE	TD
	PUSHJ	PP,PUTDC3
	HLRZ	CH,(PP)
	ADDI	CH,"0"
	TTCALL	1,(CH)
	POPJ	PP,
;PRINT DECIMAL NUMBER IN TE IF /M IS IN EFFECT

MCUR:	TLNE	SW,(INDIR)	;IF INDIR COMMANDS, DO NOTHING
	POPJ	PP,

	TRNN	SW,OPT.M
	JRST	MCUR1
	TTCALL	3,[ASCIZ " ("]
	PUSHJ	PP,PUTDEC
	TTCALL	1,[")"]
MCUR1:	TTCALL	3,[ASCIZ ": "]
	POPJ	PP,
;GET A CHARACTER FROM TTY

GETTY:	SKIPE	CH,TTYKAR	;IF ONE WAITING, USE IT
	JRST	GETTY2

	TLNE	SW,(INDIR)	;INDIRECT COMMANDS?
	JRST	GETIND		;YES

	TTCALL	4,CH		;NONE-WAITING--GET IT FROM TTY

GETTY2:	SETZM	TTYKAR

	CAIE	CH,175		;CONVERT OLD ALTMODES TO NEW
	CAIN	CH,176
	MOVEI	CH,33
	CAIN	CH,"="		;CONVERT = TO _
	MOVEI	CH,"_"

	CAIG	CH,40
	JRST	GETTY1
	CAIGE	CH,"A"+40
	POPJ	PP,

	CAIG	CH,"Z"+40
	SUBI	CH,40
	POPJ	PP,

GETTY1:	JUMPE	CH,GETTY
	CAIE	CH,40		;IGNORE SPACES & TABS
	CAIN	CH,11
	JRST	GETTY
	CAIN	CH,15
	JRST	GETTY
	CAIE	CH,33		;ECHO CR-LF AFTER ALTMODE
	JRST	.+4
	TLNN	SW,(INDIR)
	TTCALL	3,[ASCIZ "
"]
	JRST	.+4
	CAILE	CH,11
	CAILE	CH,14
	POPJ	PP,
	MOVEI	CH,15
	POPJ	PP,

;GET A CHARACTER FROM INDIRECT COMMAND FILE

GETIND:	SOSGE	CMDBUF+2
	JRST	GETIN2

	ILDB	CH,CMDBUF+1
	JUMPE	CH,GETIND
	JRST	GETTY2

GETIN2:	IN	CMD,
	JRST	GETIND
	JRST	CMDRER
;GET A WORD OF SIXBIT CHARACTERS

GETSIX:	MOVE	TF,[POINT 6,TE]
	MOVEI	TE,0

GETSX1:	PUSHJ	PP,GETTY	;GET A CHARACTER
	CAIL	CH,"0"		;IF
	CAILE	CH,"Z"		;  NOT
	POPJ	PP,		;  LETTER
	CAIG	CH,"9"		;  OR
	JRST	GETSX2		;  DIGIT,
	CAIGE	CH,"A"		;  THEN
	POPJ	PP,		;  QUIT

GETSX2:	SUBI	CH,40		;CONVERT TO SIXBIT
	TLNE	TF,770000	;IF WORD NOT FULL,
	IDPB	CH,TF		;  STASH CHARACTER IN WORD
	JRST	GETSX1		;LOOP
;GET A POSITIVE NUMBER FROM TTY

GETPOS:	PUSHJ	PP,GETDEC	;GET A DECIMAL NUMBER
	POPJ	PP,		;ERROR--RETURN
	SKIPE	TE		;IS IT ZERO?
	AOSA	(PP)		;NO--SKIP RETURN
POSERR:	TTCALL	3,[ASCIZ "?POSITIVE NUMBER REQUIRED
"]
	POPJ	PP,

;GET A DECIMAL NUMBER FOLLOWED BY A CARRIAGE-RETURN

GETNUM:	PUSHJ	PP,GETDEC	;GET DECIMAL NUMBER
	JRST	SKPTTY		;TROUBLE
	CAIE	CH,15		;FOLLOWED BY CARRIAGE-RETURN?
	JRST	GETDC8		;NO--TROUBLE
	AOS	(PP)		;YES--SKIP RETURN
	POPJ	PP,		;RETURN

;GET A DECIMAL NUMBER FROM TTY

GETDEC:	MOVEI	TE,0
	TLZ	SW,(FGETDC)	;CLR ACTUAL NUMBER SEEN FLAG
	AOS	(PP)		;ASSUME NO ERRORS, SO SKIP RETURN

GETDC1:	PUSHJ	PP,GETTY
	CAIL	CH,"0"		;IS IT A
	CAILE	CH,"9"		;  DIGIT?
	POPJ	PP,		;NO

	TLO	SW,(FGETDC)	;DIGIT SEEN
	JOV	.+1		;CLEAR OVERFLOW FLAG
	IMULI	TE,^D10
	ADDI	TE,-"0"(CH)
	JOV	GETDC8		;IF OVERFLOW--ERROR
	JRST	GETDC1		;LOOP

GETDC8:	TTCALL	3,[ASCIZ "?BAD DECIMAL NUMBER
"]
	SOS	(PP)		;REMOVE THE SKIP
	JRST	SKPTTY
;GET AN OCTAL NUMBER FROM THE TTY

GETOCT:	MOVEI	TE,0

GETOC1:	PUSHJ	PP,GETTY	;GET A CHARACTER
	CAIL	CH,"0"		;IF NOT
	CAILE	CH,"7"		;  OCTAL DIGIT,
	POPJ	PP,		;  RETURN

	LSH	TE,3
	IORI	TE,-"0"(CH)
	TLNN	TE,-1		;IF MORE THAN
	JRST	GETOC1		;  HALF-WORD,
	POPJ	PP,		;  RETURN
;GET MODE OF A FILE

GETMOD:	PUSHJ	PP,GETSIX	;GET A WORD
	CAIE	CH,15		;IF IT DIDN'T TERMINATE WITH <C.R.>
	JRST	GETMD1		;  ERROR

	MOVNI	TB,1
	CAMN	TE,[SIXBIT "A"]
	MOVEI	TB,0
	CAMN	TE,[SIXBIT "S"]
	MOVEI	TB,14
	CAMN	TE,[SIXBIT "ASCII"]
	MOVEI	TB,0
	CAMN	TE,[SIXBIT "SIXBIT"]
	MOVEI	TB,14

	JUMPL	TB,GETMD1
	AOS	(PP)
	POPJ	PP,

GETMD1:	TTCALL	3,[ASCIZ "?IMPROPER MODE
"]

SKPTTY:	TLO	SW,(FERROR)
SKPTT1:	CAIN	CH,15
	POPJ	PP,
	PUSHJ	PP,GETTY
	JRST	SKPTT1
;GET A BLOCK OF FREE CORE FOR INDEX AND CLEAR IT

GETLVL:	MOVE	TE,IDXSEC	;NUMBER OF WORDS =
	LSH	TE,7		;  NUMBER OF SECTORS * 128

	HRRZ	TD,JOBFF	;GET CURRENT JOBFF
	AOS	TA,LEVELS	;BUMP NUMBER OF LEVELS
	CAILE	TA,^D10		;IF MORE THAN 10,
	JRST	BIGLVL		;  TOO BAD

	MOVEM	TD,IDXLOC-1(TA)	;SAVE LOCATION OF FREE SPACE
	PUSHJ	PP,GETCOR	;RESET JOBFF

CLRIDX:	MOVE	TD,IDXSEC	;COMPUTE
	LSH	TD,7		;  END OF
	ADD	TD,IDXLOC-1(TA)	;  INDEX CORE AREA
	MOVE	TE,IDXLOC-1(TA)	;CLEAR
	SETZM	0(TE)		;  AREA
	HRLS	TE		;  TO
	HRRI	TE,1(TE)	;  ZEROES
	BLT	TE,-1(TD)	;  *

	MOVE	TD,IDXLOC-1(TA)	;SET ADDRESS FOR FIRST ENTRY
	ADDI	TD,2
	MOVEM	TD,IDXWRD-1(TA)
	POPJ	PP,

GETCOR:	ADD	TD,TE		;COMPUTE NEW JOBFF
	HRRM	TD,JOBFF	;SET NEW JOBFF VALUE

	MOVEI	TE,(TD)		;IF
	CAMG	TE,JOBREL##	;  WE ARE
	POPJ	PP,		;  OVER JOBREL,
	IORI	TE,1777		;  GET
	CALLI	TE,$CORE	;  MORE CORE
	JRST	NOCORE		;NOT ENOUGH CORE, TROUBLE

	POPJ	PP,
;WRITE OUT AN INDEX BLOCK


;WRITE OUT FROM LEVEL 1

RITID1:	MOVEI	TA,1
	MOVE	TB,IDXLOC
	MOVE	TE,STHDR
	JRST	RITID2

;WRITE OUT FROM ANY LEVEL

RITIDX:	MOVE	TB,IDXLOC-1(TA)	;GET ADDRESS OF BLOCK
	MOVE	TE,STHDR	;GET SIZE OF BLOCK IN BYTES
	HRLI	TE,-1(TA)	;MAKE VISIBLE IDX LEVEL = 0-9 INSTEAD OF 1-10
RITID2:	MOVEM	TE,(TB)		;PUT THAT IN BLOCK

	MOVE	TE,IDXSEC	;COMPUTE SIZE OF BLOCK
	LSH	TE,7
	MOVNS	TE		;BUILD
	HRL	TB,TE		;  OUTPUT DUMP POINTER
	SUBI	TB,1
	MOVEM	TB,OUTLST
	SETZM	OUTLST+1

	MOVE	TE,IDXSEC	;UPDATE
	ADDM	TE,FEISEC	;  FIRST FREE SECTOR

	OUT	OF1,OUTLST	;WRITE OUT BLOCK
	SKIPA			;NO ERROR
	JRST	IDXERA		;WRITE ERROR

	AOS	IDXOUT		;BUMP 'NUMBER OF INDEX BLOCKS WRITTEN'
	SETZM	IDXEIB-1(TA)	;CLEAR 'NUMBER OF ENTRIES IN BLOCK'
	JRST	CLRIDX		;CLEAR THE BLOCK AND RETURN
;GET AN INPUT CHARACTER FROM ASCII FILE

GETAM:	SKIPE	CH,INPKAR	;ANY 'LOOK-AHEAD' CHARACTER?
	JRST	GETAM3		;YES

GETAM1:	TLNE	SW,(FENDL!FTAB!FENDIB)	;ANYTHING SPECIAL GOING ON?
	JRST	GETAM5		;YES

GETAM2:	SOSG	IF1BUF+2
	PUSHJ	PP,READ		;GET ANOTHER BUFFER
	TLNE	SW,(FENDIB)	;AT END OF BLOCK?
	POPJ	PP,		;YES--QUIT
	ILDB	CH,IF1BUF+1	;GET A CHARACTER FROM INPUT FILE
	JUMPE	CH,GETAM1	;IGNORE NULLS

GETAM3:	CAIL	CH,11		;ANY
	CAILE	CH,24		;  SPECIAL PROCESSING?
	JRST	GETA3A		;NO

	CAILE	CH,15		;MAYBE
	CAIL	CH,20
	JRST	GETAM4		;YES

GETA3A:	TLZ	SW,(FENDL)	;NO--CLEAR 'END-OF-LINE'
	POPJ	PP,

GETAM4:	CAIN	CH,11		;IS THE CHARACTER A TAB?
	JRST	GETAM7		;YES
	TLO	SW,(FENDL)	;NO--IT IS END-OF-LINE
	POPJ	PP,

GETAM5:	TLNN	SW,(FENDL!FENDIB)	;ARE WE SKIPPING PAST END-OF-LINE?
	JRST	GETAM8		;NO--MUST HAVE SEEN A TAB
GETAM6:	TLNE	SW,(FENDIB)	;IF END-OF-BLOCK
	POPJ	PP,		;  RETURN
	PUSHJ	PP,GETAM2	;GRAB A CHARACTER
	TLNE	SW,(FENDL)	;STILL END-OF-LINE?
	JRST	GETAM6		;YES--LOOP
	POPJ	PP,		;NO--RETURN

GETAM7:	TLNN	SW,(FCNV)	;IF WE ARE NOT CONVERTING,
	POPJ	PP,		;  RETURN
	TLO	SW,(FTAB)	;TAB WAS SEEN
	MOVEI	CH," "		;CHANGE TO SPACE
	POPJ	PP,

GETAM8:	MOVEI	CH," "
	CAMG	OC,RECSIZ	;ARE WE BEYOND END OF RECORD
	TLNE	OC,7		;  OR AT TAB STOP?
	TLZA	SW,(FTAB)	;YES--TURN OFF 'WE ARE TABBING'
	POPJ	PP,
	JRST	GETAM1
;GET A BYTE FROM SIXBIT INPUT FILE

GETSM:	SKIPG	INPSIZ		;ANYTHING LEFT IN RECORD?
	JRST	GETSM1		;NO

	SOSG	IF1BUF+2	;YES--IF BUFFER IS EMPTY,
	PUSHJ	PP,READ		;  GET ANOTHER BUFFER

	TLNN	SW,(FENDIB)	;DID WE HIT END-OF-BLOCK?
	ILDB	CH,IF1BUF+1	;NO--PICK UP BYTE
	SOS	INPSIZ
	POPJ	PP,

GETSM1:	TLO	SW,(FENDL)	;SET END-OF-LINE

GETSM2:	MOVE	CH,IF1BUF+1
	TLNN	CH,770000
	POPJ	PP,
	SOS	IF1BUF+2
	IBP	IF1BUF+1
	JRST	GETSM2

;GET A BYTE FROM INDEXED DATA FILE

GETDAT:	SKIPG	INPSIZ		;ANY LEFT?
	JRST	GETDA1		;NO

	ILDB	CH,INPTR	;YES, GET ONE
	SOS	INPSIZ
	POPJ	PP,

GETDA1:	TLO	SW,(FENDL)	;END OF LINE
	POPJ	PP,
;NEED ANOTHER BUFFER

READ:	AOS	CH,ISECC
	SKIPE	INPBLK		;IS INPUT BLOCKED?
	JRST	READ2		;YES
READ1:	IN	IF1,		;NO
	POPJ	PP,

	STATZ	IF1,$ERA	;IS IT AN ERROR?
	JRST	REDERA		;YES
	TLO	SW,(FEOF!FENDIB!FENDL)	;NO--END-OF-FILE
	JRST	READ3

READ2:	TLNE	SW,(FDSK)	;NO--IS INPUT FROM DISK?
	CAMG	CH,INPSEC	;YES--HAVE WE READ ENOUGH SECTORS?
	JRST	READ1		;NO
	TLO	SW,(FENDIB!FENDL)	;NO--END-OF-LINE AND END-OF-BLOCK

READ3:	MOVEI	CH,0
	POPJ	PP,
;PUT A CHARACTER INTO DATA-FILE BUFFER

PUTBYT:	SOSG	OF2BUF+2
	PUSHJ	PP,WRITE
	IDPB	CH,OF2BUF+1
	POPJ	PP,

;WRITE OUT A SECTOR OF DATA-FILE

WRITE:	AOS	DATLOC
	AOS	OSECC
	PUSH	PP,CH		;WE
	MOVE	CH,OF2BUF	;  WILL
	ADDI	CH,^D129	;  ALWAYS
	HLL	CH,OF2BUF+1	;  WRITE
	TLZ	CH,770000	;  128
	MOVEM	CH,OF2BUF+1	;  WORDS
	POP	PP,CH

	OUT	OF2,
	POPJ	PP,

	JRST	DATERA
;READ IN 1 BLK OF INDEX AT CURRENT LEVEL

IDXREA:	MOVN	TA,IDXSIZ	;WORD COUNT
	HRLS	TA
	HRR	TA,IDXLIN-1(IX)	;LOCATION
	SUBI	TA,1
	MOVEI	TB,0		;END OF ARGS
	IN	IF1,TA
	JRST	IDXRE1
	STATZ	IF1,$ERA
	JRST	STATER		;ERROR
	TLO	SW,(FEOF!FENDIB!FENDL)	;END-OF-FILE
	POPJ	PP,

IDXRE1:	MOVEI	TA,1		;INIT ENTRY COUNT
	MOVEM	TA,IDXFLG-1(IX)
	MOVEI	TA,2
	MOVEM	TA,IDXWIN-1(IX)	;POSITION OF 1ST ENTRY
	MOVE	TA,IDXLIN-1(IX)
	MOVE	TB,(TA)
	MOVEM	TB,IBW1		;1ST BLK HEADER WD
	MOVE	TB,1(TA)
	MOVEM	TB,IBW2		;2ND WORD OF BLK HEADR
	POPJ	PP,

;READ IN 1 BLK OF INDEXED DATA FILE

DATREA:	MOVN	TA,INSIZ	;WORD COUNT
	HRLS	TA
	HRR	TA,INDAT	;LOCATION
	SUBI	TA,1
	MOVEM	TA,INPTR	;INIT INPTR FOR GETREC
	MOVEI	TB,0
	IN	IF2,TA
	SKIPA			;NO ERRORS
	JRST	DATERR		;ERROR

	SETZM	DATFLG		;CLR RECORD USED CTR
	POPJ	PP,
;SAVE AC'S 0-16

SAVAC:	MOVEM	16,SAVEAC+16
	MOVEI	16,SAVEAC
	BLT	16,SAVEAC+15
	POPJ	PP,

;RESTORE AC'S 0-16

RESAC:	MOVSI	16,SAVEAC
	BLT	16,15
	MOVE	16,SAVEAC+16
	POPJ	PP,
SUBTTL	IMPURE AREA

RELOC

TTYKAR:	BLOCK	1	;IF NON-ZERO, THIS IS THE NEXT TTY INPUT CHARACTER
PATCH:	BLOCK	40

LOWCOR:	BLOCK	0	;BASE OF IMPURE AREA (EXCEPT TTYKAR)

INPKAR:	BLOCK	1	;IF NON-ZERO, THIS IS THE NEXT INPUT CHARACTER

FILDAT:	BLOCK	BUFADR	;GENERAL FILE DISCRIPTION PARAMETERS
OF1DAT:	BLOCK	BUFADR	;PARAMETERS FOR PRIMARY OUTPUT FILE
OF1BUF:	BLOCK	3	;BUFFER HEADER FOR 1ST OUTPUT FILE
OF2DAT:	BLOCK	BUFADR	;PARAMETERS FOR SECONDARY OUTPUT FILE
OF2BUF:	BLOCK	3	;BUFFER HEADER FOR 2ND OUTPUT FILE
IF1DAT:	BLOCK	BUFADR	;PARAMETERS FOR PRIMARY INPUT FILE
IF1BUF:	BLOCK	3	;BUFFER HEADER FOR 1ST INPUT FILE
IF2DAT:	BLOCK	BUFADR	;PARAMETERS FOR SECONDARY INPUT FILE
IF2BUF:	BLOCK	3	;BUFFER HEADER FOR 2ND INPUT FILE
CMDBUF:	BLOCK	3	;BUFFER HEADER FOR INDIRECT COMMAND FILE

PPLIST:	BLOCK	PPSIZE	;PUSH-DOWN LIST
INPBLK:	BLOCK	1	;BLOCKING FACTOR OF INPUT FILE
IDXLOC:	BLOCK	^D10	;ADDRESS IN FREE STORAGE FOR INDEX BLOCK
IDXWRD:	BLOCK	^D10	;RELATIVE WORD WITHIN INDEX BLOCK FOR NEXT KEY
IDXEIB:	BLOCK	^D10	;NUMBER OF ENTRIES IN INDEX BLOCK
IDXLIN:	BLOCK	^D10	;SAME AS IDXLOC BUT FOR INPUT
IDXWIN:	BLOCK	^D10	;  "   " IDXWRD  "   "     "
IDXEIN:	BLOCK	^D10	;  "   " IDXEIB  "   "     "
IDX1KY:	BLOCK	^D10	;SET TO 1 AFTER 1ST KEY WRITTEN AT EACH LVL
DATFLG:	BLOCK	1	;CURRENT ENTRY IN DATA BLK (INPUT)
IDXFLG:	BLOCK	^D10	;CURRENT ENTRY IN EACH INDEX BLK (INPUT)
ISECC:	BLOCK	1	;COUNT OF SECTORS READ IN CURRENT BLOCK
OSECC:	BLOCK	1	;COUNT OF SECTORS WRITTEN IN DATA FILE
IRLEFT:	BLOCK	1	;RECORDS LEFT IN INPUT BLOCK
ORLEFT:	BLOCK	1	;RECORDS LEFT TO FILL IN DATA BLOCK
OLDKEY:	BLOCK	1	;ADDRESS OF OLD KEY VALUE
NEWKEY:	BLOCK	1	;ADDRESS OF NEW KEY VALUE
INKEY:	BLOCK	1	;PTR TO INPUT KEY
SIZKEY:	BLOCK	1	;SIZE OF KEY IN WORDS
RECPTR:	BLOCK	1	;POINTER TO IN-CORE RECORD
DATSEC:	BLOCK	1	;NUMBER OF SECTORS IN DATA BLOCK
INPSEC:	BLOCK	1	;NUMBER OF SECTORS IN INPUT BLOCK
INPSIZ:	BLOCK	1	;SIZE OF CURRENT INPUT RECORD, IN BYTES
GDPARM:	BLOCK	1	;PARAMETER FOR 'GD6.' OR 'GD7.' CALL
SAVEAC:	BLOCK	17	;SAVE AREA FOR AC'S 0-16
DATLOC:	BLOCK	1	;NUMBER OF NEXT DATA SECTOR
DATLOK:	BLOCK	1	;NUMBER OF 1ST SECTOR OF CURRENT BLOCK
OUTLST:	BLOCK	2	;OUTPUT LIST FOR WRTING INDEX BLOCK
IDXOUT:	BLOCK	1	;NUMBER OF INDEX BLOCKS WRITTEN
NB1SB:	BLOCK	1	;NUMBER OF BITS IN ONE SAT BLOCK
NBWRIT:	BLOCK	1	;NUMBER OF 1-BITS WRITTEN INTO SAT
DATRIT:	BLOCK	1	;NUMBER OF DATA RECORDS PER BLOCK TO USE
IDXRIT:	BLOCK	1	;NUMBER OF INDEX ENTRIES PER BLOCK TO USE
LASTKB:	BLOCK	1	;SMALLEST RECORD SIZE WHICH CONTAINS KEY
FRSTKB:	BLOCK	1	;BYTE POSITION OF FIRST BYTE IN KEY
SAVSTH:	BLOCK	1	;TEMP TO SAVE 'STHDR' WHILE WRITING SATS
MUCHO:	BLOCK	1	;NUMBER OF DATA RECORDS WRITTEN
INDAT:	BLOCK	1	;PTR TO INPUT DATA BLK FOR /P OR /M
INSIZ:	BLOCK	1	;SIZE OF INPUT DATA BLK FOR /P OR /M
IDXSIZ:	BLOCK	1	;# WORDS/INPUT INDEX BLK
IDXHD1:	BLOCK	1	;1ST HEADER WORD OF INDEX ENTRY
IDXHD2:	BLOCK	1	;2ND "
IBW1:	BLOCK	1	;1ST HEADER WD OF INDEX BLK
IBW2:	BLOCK	1	;2ND "
NDATBT:	BLOCK	1	;TEMPORARY NDATB WHILE WRITING SAT BLKS
INPTR:	BLOCK	1	;BYTE PTR TO INDEXED DATA INPUT RECORD
;STATISTICS BLOCK FOR OUTPUT INDEX FILE

STHDR:	BLOCK	1	;HEADER WORD
STDEV:	BLOCK	1	;DEVICE NAME FOR DATA FILE
STNAM:	BLOCK	1	;FILE-NAME FOR DATA FILE
STEXT:	BLOCK	1	;FILE-EXTENSION FOR DATA-FILE
CREATE:	BLOCK	1	;DATE DATA-FILE CREATED
ACCDAT:	BLOCK	1	;ACCESS DATE FOR DATA-FILE
LEVELS:	BLOCK	1	;NUMBER OF INDEX LEVELS
DATBLK:	BLOCK	1	;BLOCKING FACTOR OF DATA FILE
EMPDAT:	BLOCK	1	;NUMBER OF EMPTY RECORDS PER DATA BLOCK
IDXBLK:	BLOCK	^D10	;NUMBER OF ENTRIES PER INDEX BLOCK
EMPIDX:	BLOCK	^D10	;NUMBER OF EMPTY ENTRIES PER INDEX BLOCK
NDATB:	BLOCK	1	;NUMBER OF DATA BLOCKS IN FILE
NDATBE:	BLOCK	1	;NUMBER OF EMPTY DATA BLOCKS IN FILE
NSECI:	BLOCK	1	;NUMBER OF SECTORS IN INDEX FILE
NSECIE:	BLOCK	1	;NUMBER OF EMPTY SECTORS IN INDEX FILE
FEISEC:	BLOCK	1	;FIRST EMPTY INDEX SECTOR
RECSIZ:	BLOCK	1	;SIZE OF LARGEST DATA RECORD, IN WORDS
RECKEY:	BLOCK	1	;POINTER TO RECORD KEY
NUMOPS:	BLOCK	1	;NUMBER OF I/O OPERATIONS
NUMUUO:	BLOCK	1	;NUMBER OF IN/OUT UUO'S EXECUTED
SATADR:	BLOCK	1	;ADDRESS OF FIRST SAT BLOCK
NUMSAT:	BLOCK	1	;NUMBER OF SAT BLOCKS
IDXSEC:	BLOCK	1	;NUMBER OF SECTORS IN INDEX BLOCK
SATBIT:	BLOCK	1	;NUMBER OF BITS IN ALL SAT BLOCKS
KEYDES:	BLOCK	1	;KEY DESCRIPTOR
SIZIDX:	BLOCK	1	;SIZE OF INDEX ENTRY
IDXADR:	BLOCK	1	;ADDRESS OF HIGHEST-LEVEL INDEX ENTRY
%DAT:	BLOCK	1	;PERCENTAGE OF DATA FILE TO LEAVE FREE
%IDX:	BLOCK	1	;PERCENTAGE OF INDEX FILE TO LEAVE FREE
RECBYT:	BLOCK	1	;SIZE OF LARGEST DATA RECORD, IN BYTES
MAXSAT:	BLOCK	1	;MAX # RECORDS FILE CAN BECOME
ISAVER:	BLOCK	1	;ISAM VERSION #

STATSZ==.-STHDR
I==STATSZ

;STATISTICS BLOCK FOR INPUT INDEX FILE

STAT2:	BLOCK	STATSZ	;REFERENCE AS STHDR VARIABLE + I

LOWSIZ==.-LOWCOR

X=START

RELOC

	END	START

 S'$;