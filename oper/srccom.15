TITLE	SRCCOM   V.015	22-NOV-70
SUBTTL SOURCE FILE COMPARE - BOWERING/TWE
;*****(C)COPYRIGHT 1969,1970 BY DIGITAL EQUIPMENT CORP., MAYNARD, MASS.,USA*****

INTERNAL JOBVER
LOC <JOBVER==137>
15

EXTERNAL	JOBFF,	JOBREL

TWOSEG
RELOC 400000

ACDEV=1
ACFILE=2
ACEXT=3
ACDEL=4
ACPNTR=5

CTL=0	;I/O CHANNEL ASSIGNMENTS
IN1=1
IN2=2
AL=1	;ASCII LINE MODE

W1=1
W2=2
W3=3
FIL=4	;FILE # (0 IS FILE 1; 1 IS FILE 2)
F1=5	;LINE POINTER FILE 1 (CONTAINS INTEGER)
F2=F1+1	;DITTO FILE 2
FR=7	;FLAG REGISTER (LH) AND FILE #(0 OR 1)(RH)
C=10	;CONTAINS 1 CHAR FOR PROCESSING
T=11	;TEMPORARY AC
TT=12	;TEMP AC
PP=17	;PUSH DOWN POINTER
LPDL==20	;LENGTH OF PUSH DOWN LIST

TAB==11
LF==12
FF==14
CR==15
VT==13	;VERTICAL TAB

NOFORM==1		;DON'T OUTPUT FORM FEED
PAGSW==2
ENDSW==4	;END SWITCH (SUPPRESS FORM-FEED  IF FILES IDENTICAL)
SSWBIT==100	;/S SWITCH - IGNORE SPACING
CSWBIT==200	;/C SWITCH - IGNORE COMMENTS
ALLSW==400	;/B SWITCH (ALLOWS COMPARING BLANK LINES)
EOF1SW==1000		;EOF SEEN ON FILE 1
EOF2SW==2000		;EOF SEEN ON FILE 2
IOTTY==4000		;OUTPUT TO TTY OR LPT
CTYPF==10000		;1 IF ANY CHARS TYPED FOR A COMMAND

MATCH==3		;# LINES TO BE MATCHED
WPL==^D100/5+1	;MEMORY WORDS/LINE
LPP==^D52	;LINES/PAGE
COMP:	CLOSE	CTL,
	RELEAS	CTL,
	RELEAS	IN1,
	RELEAS	IN2,
COMPGO:	CALLI
	MOVEI 0,ENDP
	MOVEM 0,JOBFF			;SET JOBFF AFTER VARIABLE AREA
	MOVE PP,[IOWD LPDL,PPSET]	;SET UP PUSH DOWN LIST
	MOVEI 0,ENDP+500	;GUARANTEE ROOM FOR BUFFERS (2 DSK +TTY IN AND OUT)
	CALLI 0,11	;CORE UUO
	 JRST ERRCOR		;NOT AVAILABLE
	SETZM PPSET	;THIS IS THE ZERO WHICH WILL
			;BE "BLT"ED TO CLEAR CORE
	MOVE	[XWD PPSET,PPSET+1]	;ZERO STORAGE AREA
	BLT	ENDP-1	;ZEROED

	MOVEI 0,MATCH-1
	MOVEM 0,NUMLIN		;MATCH IS NORMALLY 3 LINES (N-1)

	AOS PAGNUM+0		;ZEROED BY BLT ABOVE-1ST PAGE IS 1
	AOS PAGNUM+1		;DITTO FOR SECOND FILE


	MOVSI FR,PAGSW+NOFORM	;INIT FR FOR NEW PAGE HEADING
	PUSHJ	PP,INITTY	;INITIALIZE TTY
	PUSHJ	PP,CRLF		;OUTPUT CARRIAGE RETURN - LINE FEED
	MOVEI	C,"*"		;TELL USER WE ARE READY FOR COMMAND
	PUSHJ	PP,TYO		;OUTPUT THE *
	PUSHJ	PP,DMPOUT	;OUT GOES THE *

	PUSHJ	PP,NAME1	;ANALYIZE OUTPUT DEVICE AND NAME
	CAIN	C,"_"	;ERROR IF NO ARROW
	JRST	CTLSE1	;ITS THERE--PROCEED
	TLNN	FR,CTYPF	;ANY COMMAND TYPED?
	JRST	COMPGO		;NO
CTLSER:	JSP T,ERROUT
	ASCIZ /?COMMAND ERROR/

CTLSE1:	SKIPN	ACDEV		;ANY SPECIFIED DEVICE?
	MOVSI	ACDEV,(SIXBIT /TTY/)	;N0-ASSUME TTY
	MOVEM	ACDEV,OUTDEV
	SKIPN	ACFILE		;IS THERE A FILE NAME?
	MOVE 	ACFILE,[SIXBIT /SRCCOM/]	;NO, GIVE IT ONE
	MOVEM	ACFILE,OUTDIR	;PUT SIXBIT FILE NAME IN
	SKIPN ACEXT		;IS AN EXTENSION SPECIFIED?
	MOVSI ACEXT,(SIXBIT /LST/)	;NO, GIVE IT ONE
	MOVEM	ACEXT,OUTDIR+1	;AND EXTENSION

	PUSHJ	PP,NAME1	;GET INPUT COMMAND STRING
	CAIN	C,","		;COMMA TO TERMINATE 1ST INPUT FILE?
	TLNN	FR,CTYPF	;ANY FILE DESCRIPTOR TYPED?
	JRST	CTLSER		;NO, ERROR
	SKIPN	ACDEV		;ASSUME DSK IF NO SPECIFIED DEVICE
	MOVSI	ACDEV,(SIXBIT/DSK/)
	MOVEM	ACDEV,INDEV1
	MOVEM	ACFILE,INDIR1	;FIRST INPUT FILE
	MOVEM	ACEXT,INDIR1+1	;AND EXTENSION

	MOVE ,INA	;FOR THE REENTRANT CODE ,AND IN ORDER
			;TO BE NEAT, THE INITS ARE DONE IN THE ACS
			;GET INIT INSTRUCTION INTO AC0
	MOVE	2,INB	;THIS IS XWD
	MOVE	3,ER	;ERROR RETURN
	MOVE	4,OK	;O.K. RETURN FOR INIT
	JRST	0	;EXECUTE INIT WHICH IS NOW IN AC0

ON:	INBUF	IN1,2	;DO LOOKUP ON FIRST FILE NAME
	LOOKUP	IN1,INDIR1
	JRST	ERRIA	;ERROR RETURN

	PUSHJ	PP,NAME1
	TLNN	FR,CTYPF	;ANY FILE DESCRIPTOR TYPED?
	JRST	CTLSER		;NO, ERROR
	SKIPN	ACDEV
	MOVSI	ACDEV,(SIXBIT /DSK/)	;"DSK" IS DEFAULT
	MOVEM	ACDEV,INDEV1
	SKIPE	ACFILE
	MOVEM	ACFILE,INDIR1	;INSERT FILE NAME AND EXTENSION
	CAIN	ACDEL,"."	;PERIOD MEANS EXPLICIT EXTENSION
	MOVEM	ACEXT,INDIR1+1

	MOVE	0,INC	;GET SECOND INIT
	MOVE	1,INDEV1
	MOVE	2,IND
	MOVE	3,ER
	MOVE	4,OK1
	JRST	0

BACKB:	INBUF	IN2,2		;LOOKUP ON SECOND FILE NAME
	SETZM	INDIR1+3	;CLEAR PROJ,PROG #
	LOOKUP	IN2,INDIR1
	JRST	ERRIA

	MOVE	0,INE		;NOW TRY AND INITIALIZE THE OUTPUT DEVICE
	MOVE	1,OUTDEV
	MOVE 2,INF
	MOVE	3,ERO
	MOVE	4,OK2
	JRST	0

BACKC:	MOVE	TT,OUTDEV	;CAN OUTPUT DEVICE DO OUTPUT
	CALLI	TT,4
	TLNN	TT,1
	JRST	ERRO	;NO
	TLNE TT,40000+10	;IS OUTPUT DEVICE LPT OR TTY?
	TLO FR,IOTTY		;YES, DO 1 OUTPUT PER LINE

	ENTER	CTL,OUTDIR	;AND TRY TO ENTER OUTPUT FILE NAME
	JRST	ERRO
	OUTPUT	CTL,
;FIND OUT HOW MUCH CORE IS AVAILABLE AND SET POINTERS AND LIMITS

	AOS	W1,JOBFF
	HRRZM W1,LBUFP1		;SET 1ST ADDRESS FILE 0
	SETZM 1(W1)		;FORCE NULLS INTO BUFFER
	HRRZM	W1,LBUFP2		;DITTO FILE 2
	MOVE	W1,JOBREL
	SUB	W1,JOBFF		;COMPUTE SPACE AVAILABLE
	HRRZS	W1
	LSH	W1,-1		;AVAILABLE SPACE/2
	ADDB	W1,LBUFP2	;INPUT POINTER FILE 2 STARTS HALF WAY THROUGH BUFFER
	SETZM 1(W1)		;FORCE NULLS INTO BUFFER

	HRLOI 0,377777
	MOVEM 0,OLDNUM+0	;ANY LINE # IS SMALLER THAN
	MOVEM 0,OLDNUM+1	;  THIS ONE

	SETOB	F1,TOP1		;INITIALIZE TOP OF EACH FILE
	SETOB	F2,TOP2		;THE TOP IS THE HIGHEST LINE THAT WE HAVE EXAMINED
	PUSHJ	PP,GETTWO	;GET TWO TITLE LINES
	  JFCL			;ONE FILE HAS NO LINES
	MOVE W1,LBUFP1	;GET ADR OF 1ST BUFFER AREA
	HRRZ W2,(W1)	;GET WORD COUNT 1ST LINE
	MOVSI W1,1(W1)	;SET "FROM" ADR OF BLT
	HRRI W1,HBUF1	;SET "TO" ADR OF BLT
	CAIL W2,WPL	;IS WORD COUNT LESS THAN MAX?
	MOVEI W2,WPL	;NO, MAKE IT SHORTER
	BLT W1,HBUF1(W2)	;BLT 1ST LINE INTO TITLE AREA
	SETZM HBUF1+WPL-1	;FORCE TERMINATING NULLS INTO BUFFER

	MOVE W1,LBUFP2	;DUPLICATE ABOVE LOGIC FOR SECOND FILE
	HRRZ W2,(W1)
	MOVSI W1,1(W1)
	HRRI W1,HBUF2
	CAIL W2,WPL
	MOVEI W2,WPL
	BLT W1,HBUF2(W2)
	SETZM HBUF2+WPL-1

	JRST	MAINST		;START COMPARE WITH 1ST LINES
;THE FOLLOWING CODE IS THE GUTS OF THE PROGRAM.
;WHEN THE LOOP AROUND MAIN DETECTS THAT TWO LINES ARE NOT A MATCH
;CONTROL GOES OFF TO DETERMINE THE EXTENT OF THESE DIFFERENCES.
;THE TOTAL DIFFERENCES ARE DETERMINED AS FOLLOWS.  FIRST GET TWO 
;MORE LINES. DOES THE ORGINAL LINE IN FILE 1 WHICH DID NOT MATCH
;MATCH THE NEW LINE FROM FILE TWO. IF SO THEN THE ORGINAL LINE
;IN FILE 2 WAS AN INSERTION. (OR A DELETION).  IF NO MATCH THIS 
;WAY TRY IT THE OTHER WAY. IF STILL NO MATCH GET TWO MORE LINES
;TAKE THE NEW LINE FROM FILE 1 AND TRY TO MATCH IT AGAINST ALL THE
;LINES WE HAVE BEEN EXAMINING IN FILE TWO; THEN DO IT THE OTHER
;WAY AROUND. EOF'S ARE DETECTED BY "GETTWO"  WITH NO RETURN SKIP

MAIN:	TRZ	FR,-1		;THIS FOR FILE ONE
	PUSHJ	PP,MOVEUP	;MOVE UP THE BOTTOM, BECAUSE WE ARE FINISHED
				;WITH TWO LINES
	HRRI	FR,1		;NOW FOR FILE TWO
	PUSHJ	PP,MOVEUP	;UP GOES THE BOTTOM POINTER
MAINST:	SETOB	F1,F2		;INITIALIZE LINE POINTERS
	PUSHJ	PP,GETTWO	;GET TWO LINES
	  JRST	MAIN15		;ONE FILE SHORT
	PUSHJ	PP,COMPL	;COMPARE THESE TWO LINES
	JRST	MAIN		;THEY MATCH--LOOK AT NEXT TWO

;WHEN WE GET HERE WE HAVE DETECTD A DIFFERENCE
;NOW THE PROGRAM WILL LOOK AHEAD TO TRY AND FIND THE NEXT TWO
;MATCHING LINES

MAIN10:	PUSHJ	PP,GETTWO	;GET THE NEXT TWO LINES
	  JRST	MAIN15		;ONE FILE SHORT
	SETZ	F1,		;RESET POINTER FOR FIRST FILE TO
				;THE LINE IN WHICH THE DIFFERENCE WAS FOUND


MAIN12:	PUSHJ	PP,COMPL	;NOW SEE IF WE CAN MATCH THAT LINE
	JSP W1,MULTI		;FOUND 1 LINE MATCH- LOOK FOR MULTIPLE
	CAME	F1,F2		;HAVE WE LOOKED FROM THE MISMATCHED LINE
				;TO THE CURRENT LINE?
	AOJA	F1,MAIN12	;NO--UP LINE POINTER AND TRY AGAIN
	SETZ	F2,		;HAVEN'T FOUND A MATCH THIS TIME
				;NOW TRY IT THE OTHER WAY

MAIN14:	CAML	F2,F1		;LOOKED FAR ENOUGH? (THIS VERSION HAS
				;THE INEFFICIENCY MENTIONED IN THE LIBRARY
				;WRITE UP REMOVED- TWE)
	JRST	MAIN10		;YES
	PUSHJ	PP,COMPL
	JSP W1,MULTI		;LOOK FOR MULTI LINE MATCH
	AOJA	F2,MAIN14	;INDEX AND LOOK SOME MORE

;THE MAIN15 CODE HANDLES THE CASE OF EITHER (OR BOTH) FILES
;HAVING NO LINES TO COMPARE. IF BOTH FILES HAVE NO LINES, "FINISH"
;PRINTS OUT ALL LINES IN BOTH FILES (IF ANY) AS DIFFERENCES.
;IF EITHER FILE HAS A NEW LINE, THE SHORTER FILE IS
;SEARCHED FOR A MATCH FOR THAT LINE. THIS CONTINUES (READING A NEW LINE
;FROM THE LONGER FILE) UNTIL NEITHER FILE HAS ANY LINES OR UNTIL A
;MATCH IS FOUND.

MAIN15:	SKIPGE W1,GETFIL	;DOES EITHER FILE HAVE A LINE?
	JRST FINISH		;NO
	HRRZM W1,FIL		;SAVE FILE # THAT HAS LINES
	HRR FR,W1		;SETUP FR FOR MAIN18
	JUMPL F1,MAIN18		;TRA IF FILE 1 HAS NO LINES
	JUMPL F2,MAIN18		;DITTO FILE 2
	TRC FIL,1		;CHANGE 1 TO 0 (OR VICE VERSA)
	SETOM F1(FIL)		;LOOK THRU SHORT FILE FOR MATCH
MAIN17:	MOVE W1,F1(FIL)
	CAML W1,TOP1(FIL)	;SEARCHED THRU SHORT FILE?
	JRST MAIN10		;YES, AND NO MATCH
	AOS F1(FIL)		;INDEX LINE
	PUSHJ PP,COMPL		;LOOK FOR A MATCHING LINE
	JSP W1,MULTI		;FOUND A MATCH, NOW LOOK FOR MULTIPLE MATCH
	JRST MAIN17		;NO MULTI LINE MATCH

MAIN18:	PUSHJ PP,PNTTXT		;ALL LINES ARE GONE FROM 1 FILE,
				;OUTPUT THE OTHER WITHOUT USING CORE
	JRST MAIN

;AT THIS POINT NEITHER FILE HAS ANY MORE LINES TO BE READ.
;PRINT AS DIFFERENCES ANY LINES REMAINING FOR EITHER FILE.

FINISH:	JUMPGE F1,FIN1		;PRINT DIFFERENCES IF EITHER BUFFER
	JUMPL F2,FIN2		;  HAS ANY LINES IN IT
FIN1:	PUSHJ PP,PNTBTH		;PRINT ANY LINES
FIN2:	MOVEI T,[ASCIZ /NO DIFFERENCES ENCOUNTERED/]
	SKIPN ERRCNT		;ANY DIFFERENCES?
	PUSHJ PP,TYPMSG		;NO, PRINT MESSAGE
	PUSHJ PP,CRLF
	JRST COMP		;END OF SOURCE COMPARE

;THIS SECTION LOOKS FOR MULTI LINE MATCH

MULTI:	SKIPG NUMLIN		;MULTIPLE LINE TEST?
	JRST MULT8		;NO
	HRRZM W1,RTNTMP		;YES, SAVE RETURN ADDRESS
	SETZM NUMTMP		;INIT MULTI-LINE COUNTER
	MOVEM F1,TEMPF1		;SAVE CURRENT POINTERS
	MOVEM F2,TEMPF2
MULT2:	PUSHJ PP,GETTWO		;GET NEXT TWO LINES
	  JRST MULT4		;ONE FILE DOESN'T HAVE A LINE
	PUSHJ PP,COMPL		;COMPARE THEM
	JRST MULT6		;MATCH, TEST MULTI COUNTER
MULT4:	MOVE F1,TEMPF1		;NO MATCH, RESET REGS
	MOVE F2,TEMPF2
	JRST @RTNTMP		;RETURN TO WHERE WE GOT TO MULTI FROM

MULT6:	AOS W1,NUMTMP		;INDEX MULTI-LINE COUNTER
	CAMGE W1,NUMLIN		;TEST FOR END
	JRST MULT2		;TEST NEXT TWO
	SUB F1,W1		;RESET TO 1ST COMPARISON
	SUB F2,W1
MULT8:	PUSHJ PP,PNTBTH		;PRINT DIFFERENCES

;THE TEXT OF DIFFERENCES HAS BEEN PRINTED--PUT IN ******
;AND A CARRIAGE RETURN-LINE FEED AND GO BACK AND START COMPARING
;WHEN WE START COMPARING AGAIN THE LINE POINTERA WILL
;BE POINTING TO THE FIRST TWO LINES AFTER THE MATCHING LINES

	MOVE W1,[POINT 7,[ASCIZ /***************/]]
	PUSHJ PP,PRINT
	PUSHJ PP,PCRLF		;PRINT CARRIAGE RETURN-LINE FEED
	ADD F1,NUMLIN		;CAUSE MOVEUP TO FLUSH ALL THE
	ADD F2,NUMLIN		;  LINES THAT WERE JUST MATCHED
	JRST MAIN		;DIFFERENCES PRINTED- LOOK FOR MORE
;THIS ROUTINE SETS UP THE POINTERS TO THE TEXT

;MEMORY STORAGE AREA LOOKS LIKE THIS:
;1) BUFFER SPACE FOR FILE # 0 (POINTED TO BY LBUFP1)
;	A) XWD (PAGE #),(WORD COUNT FOR LINE (INCLUDING THIS WORD))
;	   TEXT FOR LINE 0
;	    MORE TEXT FOR LINE 0
;	     & MORE, ENDED WITH A NULL
;	B) MORE LINES (EACH WITH PAGE #,WORD COUNT, AND TEXT
;2) BUFFER SPACE FOR FILE 1 (POINTED TO BY LBUFP2)
;	A) AS ABOVE

SETP:	HRRI FR,1		;SET UP POINTER FILE 1
	PUSHJ PP,SETONE
	HRRI FR,0		;DITTO FILE 0

SETONE:	MOVE W3,F1(FR)		;GET LINE #
SETON1:	MOVE TT,OLDNUM(FR)	;GET LAST # COMPUTED FOR
	MOVEM W3,OLDNUM(FR)	;SAVE NEW # AS OLD
	CAML W3,TT		;IS NEW LARGER THAN OLD?
	SKIPA T,OLDPNT(FR)	;YES, START FROM OLD BYTE POINTER
	SKIPA T,LBUFP1(FR)	;NO, START FROM BEGINNING
	SUB W3,TT		;LOOP ONLY FROM OLD POINTER
	MOVSI TT,(ADD T,(T))	;(SET UP IN AC)
	MOVE TT+2,[JRST SETON2]	;SET UP AC
	MOVE TT+1,.+1		;SET UP AC
	SOJGE W3,TT
			;TT/	ADD T,(T)	;ADD IN WORD COUNT FOR LINE
			;TT+1/	SOJGE W3,.-1	;MORE LINES LEFT?
			;TT+2/	JRST SETON2	;NO

SETON2:	HRRZM T,OLDPNT(FR)		;SAVE POINTER TO THIS LINE
	HRLI T,(POINT 7,0,35)	;NO, CHANGE TO BYTE POINTER
	MOVEM T,W1(FR)
	POPJ PP,

;MOVE UP THE POINTERS WHICH POINT TO THE LINES FROM WHICH WE
;ARE EXAMINING.  THIS IS DONE EVERYTIME A MATCH IS FOUND

MOVEUP:	MOVE W3,F1(FR)		;GET LINE # FOR THIS FILE
	CAML W3,TOP(FR)		;GETTING RID OF ALL LINES?
	JRST MOVEX		;YES, DON'T MOVE MEMORY
	AOS W3,F1(FR)		;GET LINE # OF LINE TO SAVE
	PUSHJ PP,SETON1		;GET ADR OF 1ST LINE TO SAVE
	HRL T,LBUFP1(FR)	;SET UP BLT AC (REVERSED)
	PUSH PP,T		;SAVE
	AOS W3,TOP(FR)		;GET 1ST NON-EXISTANT LINE #
	PUSHJ PP,SETON1		;GET CORRESPONDING 1ST ADR
	POP PP,W1
	SUB T,W1		;CALCULATE WORD COUNT OF TRANSFER
	ADD T,LBUFP1(FR)	;CALCULATE "E" OF BLT AC,E
	MOVSS W1		;SWITCH AC TO XWD FROM,TO
	BLT W1,(T)		;AND AWAY WE GO

MOVEX:	SETCM	W2,F1(FR)	;W2_-<(F1)+1>
	ADDM	W2,TOP(FR)	;CHANGE TOP TO ACCOUNT FOR DEAR DEPARTED LINES
	HRLOI	0,377777
	MOVEM	0,OLDNUM(FR)	;FORCE SETON1 TO RECALCULATE
	POPJ	PP,
;CODE FOR GETTING TWO LINES
;CALLING SEQUENCE IS:
;	PUSHJ PP,GETTWO
;	   RETURN 1 IF EITHER FILE HAS NO MORE LINES
;	   RETURN 2 IF ONE LINE READ FROM EACH FILE
; C(GETFIL)=THE # OF FILE FOR WHICH A LINE WAS READ (OR -1 IF NONE)

GETTWO:	SETOM	GETCNT		;INIT # LINESOBTAINED
	SETOM GETFIL		;INIT FILE # LINE CAME FROM
	TRZ	FR,-1		;ZERO RIGHT HALF OF "FR"--SET FOR FIRST FILE
	PUSHJ	PP,GLINE	;GET A LINE FROM FIRST FILE
	HRRI	FR,1		;NOW DO FOR SECOND FILE
	PUSHJ	PP,GLINE
	SKIPLE	GETCNT		;GETCNT .G. 0 IF TWO LINES WERE GOT
	AOS	(PP)		;SKIP IF 2 LINES WERE AVAILABLE
	POPJ	PP,

GLINE:	AOS	W1,F1(FR)	;BUMP THE LINE POINTERS
	CAMG	W1,TOP(FR)	;HAVE WE GONE OVER THE TOP
	JRST	GLEXIT		;NO, LINE WAS AVAILABLE
	SOS	F1(FR)		;NOT CLEAR YET THAT A NEW LINE EXISTS
GLINE1:	HRLS	PAGNUM(FR)	;SAVE PAGE # AT BEGINNING OF LINE
	PUSHJ	PP,GCHAR	;GET A CHARACTER
	TLNE	FR,@EOFTBL(FR)	;END OF FILE?
	POPJ	PP,		;YES, NO LINE
	TLNN FR,ALLSW		;SKIP IF COMPARING BLANK LINES
	JUMPE	C,GLINE1	;NULLS INDICATE BLANK LINES
	AOS W1,F1(FR)		;THERE ARE CHARS FOR A NEW LINE
	MOVEM W1,TOP(FR)		;THIS LINE IS THE TOP LINE
	PUSHJ PP,SETONE		;CALCULATE BYTE POINTER
	MOVE W1,W1(FR)		;GET BYTE POINTER IN W1
	MOVEM W1,WCADR		;SAVE ADR OF LINE WORD COUNT
	MOVE W2,PAGNUM(FR)	;PICKUP PAGE # AT BEGINNING OF LINE
	HLLZM W2,(W1)		;SAVE WITH THIS LINE
	JRST GLINE3

MLON	;MULTI LINE LITERAL

GLINE2:	PUSHJ	PP,GCHAR	;GET NEXT CHAR FOR LINE
GLINE3:	TLNN W1,760000		;WILL NEXT IDPB GO INTO NEXT WORD?
	JRST	[HRRZ W3,@GLTBL(FR);YES,GET HIGHEST ADR FOR THIS BUFFER
		CAIG W3,3(W1)	;CHECK ADR. (LEAVE 1 WORD FOR WORD
				;COUNT FOR NEXT LINE PLUS 1 WORD
				;SLOP TO BE SAFE
		JRST NOROOM	;NO ROOM IN THE INN
		HLRZM C,1(W1)	;PUT BIT17 INTO BIT35 (FOR SEQUENCE #)
		JRST .+1]	;GO INTO MAIN LOOP
	IDPB	C,W1		;STORE CHARS IN LINE BUFFER
	JUMPN	C,GLINE2	;NULL CHARACTER IS END OF LINE
	MOVE W3,WCADR		;GET BACK ADR OF WORD COUNT
	SUBI W1,-1(W3)		;CALCULATE WORD COUNT
	HRRM W1,(W3)		;SAVE WORD COUNT IN BUFFER
GLEXIT:	AOS	GETCNT		;INDEX # LINES FOUND
	HRRZM	FR,GETFIL	;SAVE # OF THIS FILE
	POPJ	PP,

GLTBL:	LBUFP2		;POINTS TO TOP ADR FILE 0
	JOBREL		;POINTS TO TOP ADR FILE 1
;IF A "CORE" UUO IS INSTALLED HERE, IT MUST ADJUST THE FOLLOWING
;LIST OF LOCATIONS (ALL BY THE AMOUNT THE SECOND BUFFER AREA
;IS MOVED, IF ANY):
;1) BYTE POINTER ADDRESS IN: W1
;2) BUFFER POINTER IN: LBUFP2
;3) 1ST ADDRESS FOR LINE IN: 0(PP) ON PUSH DOWN LIST
;THEN RETURN TO THE IDPB NEAR GLINE2+6


NOROOM:	PUSH PP,W1	;SAVE BYTE POINTER
	TRC FR,1	;CHANGE 1 TO 0 (OR VICE VERSA)
	MOVE W3,TOP(FR)	;GET TOP LINE # FOR "OTHER" FILE
	ADDI W3,1	;FIND 1ST ADR OF THE NEXT LINE ABOVE TOP
	PUSHJ PP,SETON1	;GET ADR
	HRRZM T,HIGH	;SAVE 1ST FREE ADR OF NON-FULL FILE
	HRRZ T,@GLTBL(FR);GET HIGHEST ADR AVAILABLE TO NON-FULL FILE
	SUB T,HIGH	;GET SPACE AVAILABLE
	SUBI T,2	;LEAVE 1 WRD FOR NEXT LINE WORD COUNT
			;PLUS 1 WORD SLOP TO BE SAFE
	TRC FR,1	;CHANGE FILE # BACK TO THE WAY IT WAS
	MOVEM T,ROOM	;SAVE ROOM AVAILABLE
	CAIL T,^D400	;COMPARE WITH 400. (NO MAGIC SIGNIFICANCE)
	JRST NOR2	;PLENTY ROOM AVAILABLE- DON'T GET MORE CORE

	HRRZ T,JOBREL
	MOVEM T,W1	;SAVE THIS JOBREL AS "OLD" JOBREL
	ADDI T,1	;REQUEST CORE SIZE CONTAINING THIS ADDRESS
NOR1:	CALLI T,11	;CORE UUO
	SKIPA T,ROOM	;FAIL
	JRST NOR3	;SUCCESS
NOR11:	JUMPG T,NOR4	;ANY CORE LEFT AT ALL?
	JSP T,ERROUT	;NO, PRINT MESSAGE
	ASCIZ /?BUFFER CAPACITY EXCEEDED AND NO CORE AVAILABLE/

NOR3:	HRRZ T,JOBREL	;CORE UUO SUCCESFUL- GET "NEW" JOBREL
	SUB T,W1	;FIND OUT HOW MUCH WAS ADDED
	ADDB T,ROOM	;UPDATE TOTAL ROOM AVAILABLE
NOR33:	TRNE FR,1	;WHICH FILE NEEDED ROOM?
	JRST NOR98	;FILE #1, IT JUST GOT IT
			;FILE #0, SHUFFLE CORE
NOR2:	ASH T,-1	;DIVIDE AVAILABLE SPACE BETWEEN FILES
NOR4:	MOVEM T,ROOM	;FILE #1 GETS MOVED THIS AMOUNT
	TRNN FR,1	;WHICH FILE NEEDED ROOOM?
	JRST NOR5	;FILE #0. MOVE #1 TOWARD 777777
			;FILE #1. MOVE #1 TOWARD 0
NOR6:	MOVNS T,ROOM	;FILE IS MOVING IN NEGATIVE DIRECTION
	ADDM T,WCADR	;WORD COUNT ADR FOR FILE# 1 IS MOVED DOWN
	ADDM T,(PP)	;SAME WITH BYTE POINTER
	MOVE W1,(PP)	;GET LAST ADR TO MOVE FROM BYTE POINTER
	ADD T,LBUFP2	;GET "TO" ADR. [(LBUFP2)-D OF M]
	HRL T,LBUFP2	;GET "FROM" ADR
	BLT T,(W1)	;BLT T,"E" (T/  XWD "FROM","TO")
	JRST NOR90

NOR5:	MOVE W1,T	;GET D OF M
	HRLI W1,(POP T,(T))	;SETUP- POP T,<D OF M>(T) INTO W1
	MOVE W2,HIGH	;GET HIGH(+1) ADR OF FILE #1
	SUB W2,LBUFP2	;GET LENGTH OF FILE #1
	SOS T,HIGH	;GET LAST ADR IN FILE #1
	HRLI T,400000(W2);PUT WORD COUNT(+400000) IN LEFT HALF
			;400000 AVOIDS PDL OVERFLOW PROBLEM IN AC LOOP
	MOVE W3,[JRST NOR90]
	MOVE W2,.+1
	JUMPL T,W1	;W1/	POP T,<DISTANCE OF MOVE>(T)
			;W2/	JUMPL T,W1
			;W3/	JRST NOR90
;THE ABOVE INSTRUCTIONS ARE A REVERSE BLT AND ARE IN THE AC'S FOR SPEED

NOR90:	MOVE T,ROOM	;GET DISTANCE FILE #1 WAS MOVED
	ADDM T,LBUFP2	;MODIFY STARTING ADR OF FILE #1
	HRLOI 0,377777
	MOVEM 0,OLDNUM+1	;FORCE "SETONE" TO RECALCULATE BYTE POINTER
NOR98:	POP PP,W1
NOR99:	JRST GLINE3	;CHECK COMPUTATIONS ON RETURNING

;THIS PAGE CONTAINS ROUTINE FOR COMPARING TWO LINES
;IT HAS TWO RETURNS--CALLING ADR.+1 IF LINES MATCH OR
;CALLING ADR+2 IF NO MATCH

COMPL:	PUSHJ	PP,SETP		;CALCULATE POINTERS TO TEXT
	MOVEM	W1,P1		;P1=TEMP POINTER TO TEXT FOR FIRST FILE
	MOVEM	W2,P2		;P2 FOR SECOND FILE

	MOVEI W3,1
	TDNN W3,1(W1)		;TEST SEQUENCE # BIT
	JRST .+3		;NOT SEQ. #
	AOS P1			;SKIP OVER SEQ. # AND
	IBP P1			;THE TAB
	TDNN W3,1(W2)		;SAME THING FOR FILE #2
	JRST .+3
	AOS P2
	IBP P2

COMPL1:	ILDB	W1,P1		;GET A CHARACTER FROM LINE FROM FIRST FILE
COMPL2:	ILDB	W2,P2		;AND ONE FROM SECOND FILE
COMPL0:	CAME	W1,W2	;THIS IS THE BIG TEST--ARE THEY EQUAL
	JRST	COMPL4		;NO
COMPL7:	CAIN	W1,";"		;YES, COMMENT?
	TLNN	FR,CSWBIT	;YES, SUPPRESS COMMENTS?
	JUMPN	W1,COMPL1	;NO,NO. TEST FOR END OF LINE
	POPJ	PP,		;LINES MATCH, RETURN

COMPL3:	ILDB	W1;GET NEW CHAR FOR FILE 1
COMPL4:	CAIE	W1,40		;SPACE?
	CAIN	W1,TAB		;OR TAB?
	TLNN	FR,SSWBIT	;AND IS SPACING BEING IGNORED?
	SKIPA			;NO
	JRST	COMPL3		;FLUSH SPACE OR TAB FOR FILE 1

	CAIE	W2,40		;SPACE?
	CAIN	W2,TAB		;OR TAB?
	TLNN	FR,SSWBIT	;AND IS SPACING BEING IGNORED?
	SKIPA			;NO
	JRST	COMPL2		;YES, FLUSH A SPACE OR TAB FOR FILE 2

	CAMN	W1,W2		;ARE THE CHARACTERS NOW THE SAME?
	JRST	COMPL7		;YES, TEST FOR END OF LINES

	CAIE	W1,";"		;COMMENT IN FILE 1?
	CAIN	W2,";"		;OR IN FILE 2?
	TLNN	FR,CSWBIT	;AND ARE COMMENTS BEING IGNORED?
	JRST	CPOPJ1		;NO, FILES DON'T MATCH, SKIP RETURN
	JUMPE	W1,CPOPJ	;YES, OTHER CHAR MUST BE NULL OR ELSE ONE
	JUMPE	W2,CPOPJ	;  LINE IS LONGER THAN OTHER AND FILES DIFFER
CPOPJ1:	AOS	(PP)
CPOPJ:	POPJ	PP,
;WHEN WE GET TO THIS POINT WE HAVE FOUND 
;THE EXTENT OF THE DIFFERENCES AND WE ARE READY TO PRINT
;THESE DIFFERENCES OUT

PNTBTH:	TRZ FR,-1		;OUTPUT FILE 1
	PUSHJ PP,PNTTXT		;PRINT FILE 1 DIFFERENCES
	MOVE W1,[POINT 7,[ASCIZ /****/]]
	PUSHJ PP,PRINT
	PUSHJ PP,PCRLF
	HRRI FR,1		;THEN PRINT FILE 2 DIFFERENCES

;THIS SUBROUTINE PRINTS ALL THE TEXT IN THE
;BUFFER SPECIFIED BY C(FR)R. I. E. FILE 1 OR FILE 2

PNTTXT:	SETOM TEMP	;START POINTER AT -1
	SETOM PAGEN		;GUARANTEE PAGE # MISMATCH- THEREFORE PRINT IT
PNTTX1:	AOS W1,TEMP	;INDEX LINE COUNTER
	CAMLE W1,F1(FR)	;PRINTED ALL LINES?
	POPJ PP,	;YES, RETURN
	AOS ERRCNT	;MAKE ERRCNT NON-ZERO
	PUSH PP,F1	;NO, SAVE LINE POINTERS
	PUSH PP,F2
	SETZB F1,F2	;F1=F2=0
	MOVEM W1,F1(FR)	;SET UP EITHER FOR F1 OR F2
	PUSHJ PP,SETONE	;CALCULATE BYTE POINTERS TO TEXT
	MOVE W1,W1(FR)	;UNNECESSARY FOR FILE 1- MOVES BYTE PNT FILE 2
	PUSHJ PP,PLINEN	;PRINT: 1)	TEXT
	PUSHJ PP,PCRLF
	POP PP,F2
	POP PP,F1	;RESTORE REGS
	JRST PNTTX1	;FINISH OUT ALL LINES

;THE FOLLOWING CODE IS USED TO OUTPUT A LINE OF TEXT
PLINEN:	MOVEI C,"1"(FR)
	PUSHJ PP,PCHART		;PRINT 1 OR 2
	MOVEI C,")"
	PUSHJ PP,PCHART		;PRINT )
	HLRZ C,(W1)		;GET PAGE NUMBER FOR THIS LINE
	CAME C,PAGEN		;IS IT THE SAME AS PREVIOUS LINE?
	PUSHJ PP,PGNUM		;PRINT NEW PAGE NUMBER
	MOVEI C,"	"	;PRINT TAB
	PUSHJ PP,PCHART

PRINT:	ILDB C,W1		;GET CHARACTER
	JUMPN C,.-2		;LOOP UNTIL A NULL SHOWS UP
	POPJ PP,


PCRLF:		;THIS CODE OUTPUTS A CARRAIGE RETURN-LINE
			;FEED AND DECREMENTS THE LINE COUNT

	PUSHJ	PP,CRLF
	SOSN	LINCNT	;DECREMENT THE LINES/PAGE COUNT
	TLO	FR,PAGSW	;THIS MEANS WE GET A NEW HEADING
	POPJ	PP,

PGNUM:	MOVEM C,PAGEN		;SAVE NEW PAGE # AS OLD
PGNUM1:	IDIVI C,12		;STANDARD DECIMAL PRINT ROUTINE
	HRLM C+1,(PP)
	SKIPE C
	PUSHJ PP,PGNUM1
	HLRZ C,(PP)
	ADDI C,"0"
	JRST PCHART
;THIS PAGE CONTAINS ROUTINES FOR CHARACTER OUTPUT

;CHARACTERS OUTPUTED AS A STRING OF TEXT COME THROUGH HERE

PCHART:	JUMPE C,CPOPJ		;ZERO MEANS A CARRIAGE RETURN
				;IF SO WE ARE THROUGH WITH LINE
	CAIGE	C," "		;A PRINTING CHAR?
	CAIN C,TAB		;OR A TAB?
	JRST	PCHAR		;YES
	MOVSI	C,100(C)	;N0, CONTROL CHAR --SAVE
	HRRI	C,"^"		;THIS IS CONTROL SYMBOL
	PUSHJ	PP,PCHAR	;OUTPUT THE "^"
	MOVSS	C		;AND NOW FOR THE LETTER

PCHAR:	TLZN	FR,PAGSW	;DO WE NEED A NEW HEADING
	JRST	TYO	;NO--SIMPLE CHARACTER OUTPUT
	SETOM	LINCNT	;YES
;THIS CODE OUTPUTS A HEADING COMPRISES OF THE TITLE OF
;EACH FILE AFTER "FILE 1)" AND "FILE 2)"

	MOVEM	16,SAVEXS+16	;SAVE ACCUMULATORS WHILE OUTPUTING HEADING
	MOVEI	16,SAVEXS
	BLT	16,SAVEXS+15	;ACCUMULATORS ARE NOW SAVED
	TLNE FR,ENDSW		;DON'T BOTHER IF NO ERRORS DETECTED
	JRST PCHAR1
	MOVEI C,FF		;FOR NEW PAGE, ISSUE FORM FEED
	TLNN FR,NOFORM		;IF 1, SUPPRESS FORM FEED
	PUSHJ PP,TYO
	MOVE W1,[POINT 7,[ASCIZ /FILE 1)	/]]
	PUSHJ PP,PRINT
	MOVE W1,[POINT 7,HBUF1]
	PUSHJ PP,PRINT		;PRINT FILE 1 NAME
	PUSHJ PP,PCRLF
	MOVE W1,[POINT 7,[ASCIZ /FILE 2)	/]]
	PUSHJ PP,PRINT
	MOVE W1,[POINT 7,HBUF2]
	PUSHJ PP,PRINT		;PRINT FILE 2 NAME
PCHAR1:	PUSHJ	PP,CRLF	;FOLLOWED BY TWO CARRIAGE RETURN FINE FEEDS
	PUSHJ	PP,CRLF
	MOVEI	LPP	;RESET LINES/PAGE COUNT
	MOVEM	LINCNT
	MOVSI	16,SAVEXS	;AND RESTORE ACS
	BLT	16,15
	MOVE	16,SAVEXS+16
	TLZ	FR,NOFORM	;CLEAR SUPPRESS FF FLAG AFTER RESTORING AC'S
	JRST	TYO	;DON'T FORGET ABOUT THAT ORGINAL CHARACTER

;THE CODE ON THIS PAGE IS FOR HANDLING INPUT ERRORS
;THERE ARE TWO TYPES OF ERRORS--EITHER THE FILE IS NOT FOUND
;OR THE DEVICE IS NOT AVAILABLE--THE FORMAT FOR THESE MESSAGES
;IS THE SAME FORMAT USED FOR THE "TECO" MESSAGES.



ERRIA:	MOVEI	T,[ASCIZ /?INPUT ERROR- /]
	PUSHJ	PP,TYPMSG	;TYPE FIRST PART OF MESSAGE
	MOVE T,INDIR1		;GET FILE NAME
	PUSHJ PP,PNTSIX		;PRINT
	HLLZS T,INDIR1+1	;GET EXTENSION FREED FROM GARBAGE
	JUMPE T,NOEXT		;ANY EXTENSION?
	MOVEI C,"."		;YES, TYPE DOT
	PUSHJ PP,TYO
	MOVE T,INDIR1+1		;GET EXTENSION
	PUSHJ PP,PNTSIX		;PRINT
NOEXT:	MOVEI	T,[ASCIZ / FILE NOT FOUND/]	;FINISH MESSAGE
	PUSHJ	PP,TYPMS0
	JRST	CARR	;THIS WILL OUTPUT TWO C.R. AND EXIT


ERRA:	MOVE T,OUTDEV		;OUTPUT INIT FAIL
	MOVEM T,INDEV1

ERRI:	MOVEI	T,[ASCIZ /?DEVICE /]
	PUSHJ	PP,TYPMSG	;TYPE BEGINING OF MESSAGE
	MOVE T,INDEV1
	PUSHJ PP,PNTSIX
	MOVEI	T,[ASCIZ /: NOT AVAILABLE/]
	PUSHJ	PP,TYPMS0	;TYPE REST OF MESSAGE
	JRST	CARR	;INSERT CARRIAGE RETURNS AND EXIT

PNTSIX:	MOVE TT,[POINT 6,T]	;INIT SIXBIT BYTE POINTER
PNTS1:	TLNN TT,770000		;FINISHED WITH WORD?
	POPJ PP,		;YES
	ILDB C,TT		;NO, GET CHARACTER
	JUMPE C,PNTS1		;FLUSH SPACES
	ADDI C,40		;CHANGE TO ASCII
	PUSHJ PP,TYO
	JRST PNTS1
CRLF:	MOVEI	C,15	;OUTPUT A CARRIAGE RETURN-LINE FEED
	PUSHJ	PP,TYO
	MOVEI	C,12	;NOW THE LINE FEED

TYO:	SOSG	CTOBUF+2	;DECREMENT BUFFER COUNT
	PUSHJ PP,DMPOUT		;BUFFER WAS FULL
	IDPB	C,CTOBUF+1	;DEPOSIT CHAR.
	CAIN C,12		;LINE FEED?
	TLNN FR,IOTTY		;WHILE DOING 1 OUTPUT PER LINE?
	POPJ	PP,		;NO
DMPOUT:	OUT CTL,		;YES, OUTPUT BUFFER
	POPJ PP,		;OK
	JSP T,ERROUT
	ASCIZ /?OUTPUT DEVICE ERROR/

ERRO:	JSP T,ERROUT
	ASCIZ /?OUTPUT INITIALIZATION ERROR/
ERRCOR:	MOVEI T,[ASCIZ /?2K CORE NEEDED AND NOT AVAILABLE/]
	PUSHJ PP,TYPMSG
	CALLI 12		;PRINT MESSAGE AND EXIT

ERROUT:	PUSHJ	PP,TYPMSG	;OUTPUT ERROR
	JRST	CARR	;THROW IN TWO CR AND TRY AGAIN

;ROUTINES FOR OUTPUTING ERROR MESSAGES

TYPMSG:	PUSHJ PP,INITTY	;INTIALIZE TTY
	PUSHJ	PP,CRLF	;OUTPUT A CARRIAGE RETURN
TYPMS0:	HRLI	T,(POINT 7,,)	;THIS IS POINTER FOR ERROR MESSAGE
	SKIPA
	PUSHJ PP,TYO
TYPMS1:	ILDB	C,T		;LOAD A CHAR. FROM ERROR MESSAGE
	JUMPN	C,.-2		;ALL ERROR MESSAGES END WITH A ZERO
	POPJ	PP,	;THROUGH WITH ERROR MESSAGE

CARR:	PUSHJ	PP,CRLF	;COMMON EXIT FOR ERROR MESSAGES
	PUSHJ	PP,CRLF
	JRST	COMP	;GO TO VERY BEGINNING

;INITIALIZE TTY FOR ERROR MESSAGES
INITTY:	CLOSE CTL,
	RELEAS CTL,
	INIT CTL,1
	SIXBIT /TTY/
	XWD CTOBUF,CTIBUF
	HALT
	INBUF CTL,1
	OUTBUF CTL,1
	POPJ PP,
;ROUTINE TO GET A LEGIMATE CHARACTER

GCHAR:	TLNE FR,@EOFTBL(FR)		;EOF SEEN?
	JRST NULL		;YES, RETURN NULL
	SOSG @CNTTBL(FR)	;DECREMENT BUFFER COUNT
	JSP C,@[EXP GCHAR1,GCHAR2](FR)	;BUFFER EMPTY- DO "INPUT"
	SKIPN @CNTTBL(FR)	;DID WE GET ANY DATA
	JRST GCHAR		;NO
	ILDB C,@BYTTBL(FR)		;YES, GET A CHARACTER
	JUMPE C,GCHAR		;GET RID OF NULLS
	CAIE C,LF		;LINE FEED?
	CAIN C,VT		;NO-VERTICAL TAB?
	JRST NULL		;YES, RETURN NULL
	CAIN C,CR		;CARRIAGE RETURN?
	JRST GCHAR		;YES, FLUSH
	CAIN C,FF		;IS IT A FORM FEED?
	JRST FORM		;YES
	HRL C,@SEQTBL(FR)	;GET SEQUENCE # BIT (IF IT EXISTS)
	TLZ C,777776		;TURN OFF ALL BUT SEQ. # BIT
	POPJ PP,		;NO, RETURN WITH CHAR

GCHAR1:	INPUT IN1,		;INPUT FOR FILE 1
	STATO IN1,762000	;ERRORS OR END OF FILE?
	JRST (C)		;NO
	STATO IN1,742000	;YES, EOF?
	JRST EOF		;YES END OF FILE
	JSP T,ERROUT
	ASCIZ /?FILE 1 READ ERROR/

GCHAR2:	INPUT IN2,
	STATO IN2,762000
	JRST (C)
	STATO IN2,742000
	JRST EOF
	JSP T,ERROUT
	ASCIZ /?FILE 2 READ ERROR/

SEQTBL:	Z @INBUF1+1	;POINTS TO ADR OF LAST CHAR FILE #0
	Z @INBUF2+1	;DITTO FILE #1

BYTTBL:	INBUF1+1		;ADR OF BYTE POINTER FILE #0
	INBUF2+1		;DITTO FILE #1

EOFTBL:	EOF1SW		;EOF FLAG FOR FILE 1
	EOF2SW		;EOF FLAG FOR FILE 2

CNTTBL:	INBUF1+2		;POINTS TO FILE 1 CHAR COUNT
	INBUF2+2		;DITTO FILE 2

FORM:	AOSA PAGNUM(FR)		;INDEX PAGE NUMBER
EOF:	TLO FR,@EOFTBL(FR)	;SET EOF FLAG
NULL:	MOVEI C,0		;EOF IS A NULL
	POPJ PP,
NAME1:	SETZB ACDEV,ACDEL	;ZERO REGISTERS WHICH WILL RETURN THE NAMES
	SETZB ACFILE,ACEXT
	TLZ	FR,CTYPF	;CLEAR COMMAND TYPED FLAG

NAME3:	MOVSI	ACPNTR,(POINT 6,0)	;SET POINTER
	SETZB TT,0	;THE SIXBIT NAME WILL BE STORED IN THE AC0

GETIOC:	PUSHJ	PP,TTYIN	;GET INPUT CHARACTER
	CAIE	C,32		;AN EOF TERMINATES A FILE NAME
	CAIG	C,15		;THIS IS ANOTHER WAY TO GET A FILE NAME
	JRST	TERM		;CATCHES CR,LF,FF,VT
	CAIN	C,33		;ALT MODE?
	JRST	TERM		;YES
	CAIE	C,"_"	;ONE KIND OF SEPERATOR
	CAIN	C,","	;THIS ALSO MEANS WE HAVE FINISHED A TERM
	JRST	TERM	;TERM HAS BEEN READ
	CAIN	C,"/"	;IS THERE A SWITCH?
	JRST	GETSW	;YES
	TLO	FR,CTYPF	;SET COMMAND TYPED FLAG
	CAIN	C,":"	;HAVE WE BEEN GETTING A DEVICE NAME
	JRST	DEVICE	;YES
	CAIN	C,"."	;OR A FILE NAME
	JRST	NAME	;YES
	TRC	C,40		;CONVERT TO SIXBIT
	TLNE	ACPNTR,770000	;HAVE WE STORED SIX BYTES?
	IDPB	C,ACPNTR	;NO
	JRST	GETIOC		;GET ANOTHER CHAR.

TTYIN:	SOSG	CTIBUF+2	;DECREMENT CHARACTER COUNT, ANY LEFT?
	INPUT	CTL,		;NO, GET A BUFFER FULL
	ILDB	C,CTIBUF+1	;GET CHARACTER
	JUMPE	C,TTYIN		;FLUSH NULLS
	CAIE	C,176
	CAIN	C,175
	MOVEI	C,33	;CHANGE ALL ALT MODES TO NEW
	CAIL	C,140
	TRZ	C,40	;CHANGE LOWER CASE TO UPPER CASE
	CAIE	C," "		;SKIP BLANKS
	CAIN	C,"	"	;AND TABS
	JRST	TTYIN
	POPJ	PP,		;NO, EXIT
DEVICE:	SKIPA	ACDEV,0		;DEVICE NAME
NAME:	MOVE	ACFILE,0	;FILE NAME
	MOVE	ACDEL,C		;SET DELIMITER
	JRST	NAME3		;GET NEXT SYMBOL

TERM:	JUMPE ACDEL,.+3		;IF NO PREVIOUS DELIMITOR, OR
	CAIE	ACDEL,":"	;IF PREVIOUS DELIMITER
	JRST TERM1
	MOVE	ACFILE,0	;SET FILE
TERM1:	CAIE	ACDEL,"."	;IF PERIOD,
	POPJ	PP,
	HLLZ	ACEXT,0	;SET EXTENSION
	POPJ	PP,		;EXIT

GETSW:	PUSHJ PP,TTYIN		;A SWITCH HAS BEEN DETECTED
	MOVSI T,SWTBL-SWTBLE	;SET UP NEG. COUNT FOR TABLE SEARCH
	CAIE C,@SWTBL(T)	;FOUND CHAR? (INDIRECT=INDEX=0)
	AOBJN T,.-1
	JUMPGE T,GETSW1		;JUMP IF NOTHING FOUND
	TDO FR,SWTBL(T)		;TURN ON FLAG (GARBAGE IN RIGHT)
	JRST GETIOC		;GET NEXT PART OF COMMAND

GETSW1:	MOVEI C,-"1"(C)		;CHANGE CHAR TO NUMBER
	CAILE C,8
	JRST CTLSER		;ERROR IF CHAR ISN'T 1-9
	MOVEM C,NUMLIN		;SAVE AS # EXTRA LINES TO MATCH (AFTER 1ST)
	JRST GETIOC

SWTBL:	XWD SSWBIT,"S"		;/S SUPPRESSES COMPARING SPACES, TABS
	XWD CSWBIT+SSWBIT,"C"	;/C DON'T COMP. COMMENTS OR SPACING
	XWD ALLSW,"B"		;/B ALLOWS COMPARING BLANK LINES
SWTBLE:		;END OF TABLE

;THE FOLLOWING DATA IS FOR INITIALIZING DEVICES.
;THIS IS DONE IN THE ACCUMULATORS.


INA:	INIT	IN1,AL
INB:	XWD	0,INBUF1
ERO:	JRST ERRA		;OUTPUT INIT FAILURE
ER:	JRST ERRI
OK:	JRST	ON
INC:	INIT IN2,AL
IND:	XWD	0,INBUF2
OK1:	JRST BACKB
INE:	INIT	CTL,
INF:	XWD	CTOBUF,0
OK2:	JRST	BACKC


LIT
	RELOC 0			;IMPURE AREA

OUTDEV:	BLOCK 	1
PPSET:	BLOCK	LPDL		;PUSH DOWN LIST STORAGE

CTIBUF:	BLOCK	3
CTOBUF:	BLOCK	3
INBUF1:	BLOCK	3
INBUF2:	BLOCK	3
ERRCNT:	BLOCK	1		;DIFFERENCES COUNTER (0 MEANS NO DIFFERENCES)

INDEV1:	BLOCK 1

INDIR1:	BLOCK	4

OUTDIR:	BLOCK	4

TOP:		;CONTAINS # LINES ACTUALLY STORED IN BUFFER FOR:
TOP1:	BLOCK	1	;FILE #1
TOP2:	BLOCK	1	;FILE #2

LBUFP:
LBUFP1:	BLOCK	1	;POINTER TO BEGINNING OF LINE STORAGE FOR FILE #1
LBUFP2:	BLOCK	1	;DITTO FILE #2

P1:	BLOCK	1	;BYTE POINTERS USED BY "COMPL" SUBROUTINE
P2:	BLOCK	1

HBUF1:	BLOCK	WPL	;HOLDS TITLE FROM FIRST FILE
HBUF2:	BLOCK	WPL	;FROM SECOND FILE
PAGNUM:	BLOCK 2		;PAGE NUMBERS FOR THE TWO FILES
			;  LH(# AT BEGIN OF LINE), RH(# AFTER LAST CHAR)
PAGEN:	BLOCK 1		;TEMPORARY FOR PAGE #'S IN PLINEN SUBROUTINE
OLDNUM:	BLOCK 2		;LAST LINE # USED IN "SETONE"
OLDPNT:	BLOCK 2		;LAST BYTE POINTER CALCULATED BY "SETONE"

SAVEXS:	BLOCK	17	;STORAGE FOR AC'S WHEN PRINTING PAGE HEADERS

TEMP:	BLOCK	1
LINCNT:	BLOCK	1
RTNTMP:	BLOCK	1	;RETURN ADDRESS FOR "MULTI" SUBROUTINE
WCADR:	BLOCK 1		;TEMP IN GLINE SUBROUTINE
HIGH:	BLOCK	1	;USED BY NOROOM
ROOM:	BLOCK	1	;USED BY "NOROOM"
GETCNT:	BLOCK	1	;# LINES (-1) "GETTWO" GOT
GETFIL:	BLOCK	1	;# OF FILE FROM WHICH "GETTWO" GOT LINE (.L. 0 IF NONE)
NUMLIN:	BLOCK	1		;# LINES FOR A MATCH
NUMTMP:	BLOCK	1		;TEMP FOR NUMLIN
TEMPF1:	BLOCK	1		;TEMP FOR F1
TEMPF2:	BLOCK	1		;TEMP FOR F2

ENDP:

END COMPGO
                                                                                                                   h  MÆ