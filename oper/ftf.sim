!  IOCS DEFS OF INTEREST TO USER

!  FILE DESCRIPTORS PASSED TO %OPEN

!MAINTAIN ORDER OF FILE TYPES (SEE %OPEN1)

DEF INPUT AS 0
DEF UPDATE AS 1
DEF OUTPUT AS 2
DEF OUTMSG AS 3

!FILE TYPE MODIFIERS

DEF NEW AS OCT 100
DEF OLD AS OCT 200

!FILE MODES

DEF SEQUEN AS 0
DEF DIRECT AS OCT 10

!FILE ORGANIZATIONS

DEF WORD AS 0
DEF CHARACTER AS OCT 20
DEF PACK AS OCT 40

!  FILE NUMBERS  (FNMIN IS MIN CHANNEL WHICH WILL BE USED)

DEF FNMIN AS 1            !MIN AND MAX FILE NUMBERS
DEF FNMAX AS 15           !AVAILABLE, EXCLUDING TEL
DEF TEL AS (FNMIN-1)        !FILE NO. INDICATING TERMINAL 

!  ERROR NUMBERS (ERRNUM VALUES)

DEF TMFERR AS 1     !TOO MANY FILES OPEN (OPEN)
DEF FMDERR AS 2     !BAD FILE MODE OR TYPE FOR ATTEMPTED OPERATION
                    !(OPEN SEQUEN UPDATE, SETCP OR ERASE SEQUEN,
                    !WRITE OR ERASE INPUT, READ SEQUEN OUTPUT)
DEF IFDERR AS 3     !ILLEGAL FILE IDENTIFIER (SETFID, OPEN, DELETE, RENAME)
DEF CNFERR AS 4     !NEW/OLD FILE MESSAGE NOT CONFIRMED (OPEN OUTMSG)
                    !OR TYPE MODIFIER CONFLICT - FILE NOT NEW/OLD (OPEN OUTPUT OR UPDATE)

!ORDER OF FOLLOWING 5 NOS. SHALL BE MAINTAINED. (ALL BUT LAST MAY
!OCCUR DURING OPEN, DELETE, OR RENAME)

DEF FNFERR AS 5     !FILE NOT FOUND
DEF IUSERR AS 6     !INVALID USER NAME (BAD PPN)
DEF PRTERR AS 7     !PROTECTION VIOLATION ATTEMPT
DEF FBSERR AS 8     !FILE BUSY
DEF AEFERR AS 9     !NEW NAME BELONGS TO ALREADY EXISTING FILE  (RENAME)

DEF EOFERR AS 10    !END OF FILE (R, RB, GETLINE)
DEF LNGERR AS 11    !LINE TOO LONG (GETLINE FROM FILE)
DEF TELERR AS 12    !ILLEGAL OPERATION ON TEL (OPEN, DELETE, RENAME,
                    !CP, SIZE)
DEF ARGERR AS 13    !BAD ARGUMENT VALUE - SUCH AS:
                    !NEGATIVE CURSOR POSITION (SETCP, ERASE),
                    !NEG. COUNT (RB, WB)
DEF CORERR AS 14    !OUT OF CORE (OPEN, BLOCK, RELEASE)

FIND CFN, %SETCFN, %EXU
FIND %IOCS,%OPEN,%SETFID,%WFID,%CLOSE,%BUF.DUMP
FIND %CLOSE.ALL, %PLNCHK, %PLNW, %SET.TAB
FIND %SET.TERM, %SET.PRMPT, %TAB.OFF, %R, %GETLINE
FIND %W, %WX, %ERASE, %SETCP, %CP, %SIZE
FIND %WB, %RB
FIND %BLOCK, %RELEASE
FIND %DELETE,%RENAME
FIND %CLIBUF, %CLOBUF, %GET, %PUT, %PUTX, %PUTC
FIND %PRINT, %PRINTC, %MSG, %SETRWE
FIND %OFFALT, %ONALT, %ONALT.C, ALTLOC, ERRNUM

FIND FIDP()
DEF LOCWPF AS 4
DEF MAXARG AS 27
DEF MINARG AS 5
DEF WPF AS (LOCWPF+1+MINARG)
DEF MAXWPF AS (LOCWPF+1+MAXARG)
! EXTENDED ARGUMENT BLOCK:
DEF ARGCNT(TBL) AS TBL(LOCWPF)
DEF PPNARG(TBL) AS TBL(LOCWPF+1)
DEF NAMARG(TBL) AS TBL(LOCWPF+2)
DEF EXTARG(TBL) AS TBL(LOCWPF+3)
DEF PRVARG(TBL) AS TBL(LOCWPF+4)
DEF FILSIZ(TBL) AS TBL(LOCWPF+5)
DEF EXTQ(TBL) AS TBL(0)
DEF USRNAM(TBL) AS TBL(1)
DEF DEVNAM(TBL) AS TBL(3)

!  GETLINE 

DEF LLEN AS 256                !MAX. LINE LENGTH
DEF GLBCMX AS (LLEN+1)         !MAX. CHAR CAPACITY
DEF CPW AS CHARS.PER.WORD
DEF GLBSZ AS (GLBCMX+CPW-1)/CPW   !SIZE IN WORDS
FIND FREE(0:GLBSZ-1)         !GETLINE INTERNAL BUFFER (AVAILABLE
                             !BETWEEN GETLINE CALLS)
FIND IMAGE(0:GLBSZ-1)        !GETLINE IMAGE LINE BUFFER
FIND GLCNT                   !GETLINE CHAR COUNT
!TITLE: TF
!SUBTTL: PROGRAM FOR TRANSMITTAL MANAGEMENT

BASE 0
!DEF'S FOR TF

! FOLLOWING DEFS FOR THE CURRENT INTERNAL PROGRAM
DEF MBS AS 500 
DEF SMBS AS MBS/CHARS.PER.WORD 
DEF LBS AS 100 
DEF SLBS AS LBS/CHARS.PER.WORD 

GLOBAL SWN(LBS) ! SOFTWARE NAME
GLOBAL VER(4)   !4 PARTS OF VERSION: TS,TR,DS,DR
        DEF TS AS 1
        DEF TR AS 2
        DEF DS AS 3
        DEF DR AS 4
GLOBAL LNG(LBS) ! LANGUAGES
GLOBAL CTP      ! COMPUTER TYPE: 940 OR PDP-10
        DEF IX AS 1
        DEF X AS 2
GLOBAL WHO(LBS) ! PROGRAMMER NAME
GLOBAL SYS      ! SYSTEM NUMBER [REAL ONE]
GLOBAL WFK(LBS) ! WHERE FILES ARE KEPT
GLOBAL ESS(LBS) ! EXECUTION SYSTEM NUMBER
GLOBAL EWH(LBS) ! EXECUTION USER NAME
GLOBAL CLS      ! CLASSIFICATION
        DEF SYSTEM AS 1
        DEF TYMNET AS 2
        DEF UTILIT AS 3
        DEF APPLIC AS 4
        DEF ACCOUN AS 5
        DEF SUBSYS AS 6
        DEF UNSUPP AS 7
        DEF PREMIU AS 8
        DEF ROYALT AS 9
GLOBAL FIN(LBS) ! FILES INVOLVED (100*CHARS SIZE)
GLOBAL SSS(MBS) ! SPECIAL STATUS
GLOBAL NTF      ! NOTIFY
GLOBAL MTU(LBS) ! MAIL TO USER
GLOBAL MTS      ! MAIL TO SYSTEM

! SOME GLOBAL DEF'S
GLOBAL %NUMBER,%GETVER,%INDEX,%CMDIS
GLOBAL %OUTNUM,%TYPART,%NUMIN,%INTO,%CHNG,%YESNO,%CHNGER,%DEFIN

DEF TYARG AS MSG(PARTS(ARG1))
DEF YES AS 1
DEF NO AS 0

GLOBAL TABLE CLPTS(1:9) &
["SYSTEMS",&
"TYMNET",&
"UTILITIES",&
"APPLICATIONS",&
"ACCOUNTING",&
"SUBSYSTEMS",&
"UNSUPPORTED",&
"PREMIUM",&
"ROYALTY"]

DEF BEG AS 1
DEF LAS AS 12
GLOBAL TABLE PARTS(BEG:LAS) &
["1. SOFTWARE NAME: ",&
"2. CURRENT VERSION: ",&
"3. LANGUAGE(S): ",&
"4. COMPUTER TYPE: ",&
"5. PROGRAMMER: ",&
"6. SYSTEM NUMBER: ",&
"7. USER NAME WHERE FILES ARE KEPT: ",&
"8. EXECUTION SYSTEM(S): ",&
"9. USER NAME FOR EXECUTION: ",&
"10. CLASSIFICATION: ",&
"11. FILES INVOLVED: ",&
"12. SPECIAL STATUS:"]

! PROCEDURE: TYPART
! GIVEN ARG1:=PART NUMBER, WILL TYPE IT OUT FOR YOU
%TYPART(ARG1)

        DO ARG1 OF BEG:LAS+1

1:      TYARG; PRINT(@SWN(1))
2:      TYARG; OUTNUM(VER(TS),8); PUT($.)
        OUTNUM(VER(TR),8)
        IF VER(DS)+VER(DR)#0 THEN DO
          PUT($-); OUTNUM(VER(DS),8); PUT($.)
          OUTNUM(VER(DR),8)
          END
3:      TYARG; PRINT(@LNG(1))
4:      TYARG; MSG(IF CTP=IX THEN "TYMCOM-IX" ELSE "TYMCOM-X")
5:      TYARG; PRINT(@WHO(1))
6:      TYARG; OUTNUM(SYS,10)
7:      TYARG; PRINT(@WFK(1))
8:      TYARG; PRINT(@ESS(1))
9:      TYARG; PRINT(@EWH(1))
10:     TYARG; PRINT(@CLPTS(CLS))
11:     TYARG; PRINT(@FIN(1))
12:     TYARG; PUT(CARRET); PRINT(@SSS(1))
13:     IF NTF=NO THEN DO
          MSG("13. NO NOTIFICATION")
        END ELSE DO
          MSG("13. NOTIFY: "); PRINT(@MTU(1))
          MSG(" ON "); OUTNUM(MTS,10)
        END
        END

        PUT(CAR.RET)
        RETURN

END TYPART

! PROCEDURE: OUTNUM
! ARG1:NUMBER, ARG2:RADIX
! TYPES NUMBER ONTO TTY
%OUTNUM(ARG1,ARG2)

DEF MAX.DIG AS 11
LOCAL T(MAX.DIG),K,L

        K_ARG1
        LOOP DO
          FOR L_MAX.DIG BY -1
          [K;T(L)]_K DIVMOD ARG2
          WHILE K>0
          END

        FOR L_L TO MAX.DIG PUT(T(L)+$0)
        RETURN

END OUTNUM

! PROCEDURE: CHNG
! THIS PROCEDURE WILL DO ALL OF THOSE THINGS TO CHANGE CURRENT
! IN-CORE STATISTICS
! ARG1 = ITEM NO., ARG2 = YES IF OLD TYPE FIRST, NO IF DONT
%CHNG(ARG1,ARG2)

LOCAL TMP1,TMP2,TMP3,I

        IF ARG2=YES THEN DO
          MSG("$OLD: "); TYPART(ARG1)
          MSG("NEW: ")
          END

        DO ARG1 OF BEG:LAS+1
1:      TYARG; INTO(@SWN(1))
2:      TYARG; GETVER
3:      TYARG; INTO(@LNG(1))
4:      TYARG; TMP1_GETLINE(TEL)
        CTP_-1
        LOOP DO
        EIF NCHV TMP1=$I AND NCHV TMP1=$X THEN CTP_IX
        ORIF CHV TMP1=$X THEN CTP_X
        ELSE [MSG("$ERROR: NOT IX (FOR 940) OR X (FOR PDP-10)$"); TYARG; TMP1_GETLINE(TEL)]
        WHILE CTP=-1
        END
5:      TYARG; INTO(@WHO(1))
6:      TYARG; SYS_NUMIN(10)
7:      TYARG; INTO(@WFK(1))
8:      TYARG; INTO(@ESS(1))
9:      TYARG; INTO(@EWH(1))
12:     TYARG; PUT(CARRET); TMP1_CHPT(@SSS(1),-1)
        LOOP DO
          PUT($*); TMP2_TMP3_GETLINE(TEL)
          IF NCHV TMP2 = CARRET THEN TMP2_-1 ELSE DO
            WHILE NCHV TMP3 # E.O.LIT THEN NCHV TMP1_CHV TMP3
            TMP2_0
            END
          WHILE TMP2#-1
        END
        NCHV TMP1_E.O.LIT
11:     TYARG; INTO(@FIN(1))
10:     LOOP DO
        TYARG; TMP1_GETLINE(TEL)
        CLS_-1
        FOR I_1 TO 9 [IF INDEX(CHPT(@CLPTS(I),-1),TMP1)=YES THEN CLS_I]
        IF CLS=-1 THEN [MSG("$ERROR: TYPE ONE OF THE FOLLOWING: SYSTEM, TYMNET, UTILITIES, APPLICATIONS, ACCOUNTING, SUBSYSTEMS, UNSUPPORTED, PREMIUM, ROYALTY$")]
        WHILE CLS=-1
        END
13:     MSG("13. NOTIFICATION WHEN FILES COPIED? ")
        NTF_YESNO
        IF NTF=YES THEN DO
          MSG("13A. MAIL TO USER NAME: "); INTO(@MTU(1))
          MSG("13B. SYSTEM NUMBER FOR MAIL: "); MTS_NUMIN(10)
          END
        END

        RETURN
END CHNG

! PROCEDURE: NUMIN
! ARG1 = RADIX, RETURNS NUMBER
%NUMIN(ARG1)

LOCAL VAL,CHAR,TMP1

        TMP1_GETLINE(TEL)
        VAL_0
        LOOP DO
          IF NOT $0<=CHAR_NCHV TMP1<=$0+ARG1 THEN DO
           IF CHAR=CARRET OR CHAR=LNFEED THEN RETURN VAL
           MSG("$ERROR: BAD NUMBER--RETYPE IT--")
           TMP1_GETLINE(TEL)
           VAL_0; CHAR_-1
           END
        IF CHAR#-1 THEN VAL_VAL*ARG1+(CHAR-$0) ELSE CHAR_0
        END

END NUMIN

! PROCEDURE: INTO
! RETURNS STRING INTO ARG1 = BUFFER @ ADDRESS
%INTO(@ADR)

LOCAL TMP1,TMP2,TMP3

        TMP1_CHPT(@ADR,-1)
        TMP2_GETLINE(TEL)
        WHILE TMP3_NCHV TMP2#E.O.LIT AND TMP3#CAR.RET THEN NCHV TMP1_TMP3
        NCHV TMP1_E.O.LIT
        RETURN

END INTO

! PROCEDURE: YESNO
! GETS YES OR NO AND ANSWERS
%YESNO

LOCAL TMP1

        TMP1_GETLINE(TEL)

        IF NCHV TMP1=$Y THEN RETURN YES ELSE RETURN NO

END YESNO

! PROCEDURE: CHNGER
! REQUESTS CHANGES
%CHNGER

LOCAL TMP1,TMP2,TMP3

        LOOP DO
        MSG("$CHANGE WHICH ITEM? "); TMP1_NUMIN(10)
        IF TMP1 = 0 THEN RETURN
        IF BEG<=TMP1<=(LAS+1) THEN CHNG(TMP1,YES)
        END

END CHNGER

! PROCEDURE: DEFINE
! DEFINES ALL INPUT DATA
%DEFIN

LOCAL I

        FOR I_BEG TO (LAS+1) CHNG(I,NO)
        CHNGER
        RETURN

END DEFIN

! PROCEDURE: GETVER
! GET'S A VERSION FROM TELETYPE
%GETVER

LOCAL TMP1,TMP2,TMP3,TMP4

        TMP1_TMP2_GETLINE(TEL)
        IF NCHV TMP2#$. THEN DO
          VER(TS)_NUMBER(8,@TMP1,$.)
          TMP2_TMP1
          IF NCHV TMP2 = CARRET THEN [VER(TR)_0; RETURN]
          END
        VER(TR)_NUMBER(8,@TMP1,$-)
          TMP2_TMP1
          IF NCHV TMP2 = CARRET THEN RETURN
        VER(DS)_NUMBER(8,@TMP1,$.)
        VER(DR)_NUMBER(8,@TMP1,CARRET)
        RETURN

END GETVER

! PROCEDURE: NUMBER
! ARG1:=RADIX, ARG2:=STRING TO START EXTRACTING, ARG3:=SPC TERM CH
%NUMBER(ARG1,@ARG2,ARG3)

LOCAL VAL,CHAR,TMP1

        VAL_0
        LOOP DO

          EIF NOT $0<=CHAR_NCHV ARG2<=$0+ARG1 THEN DO
            IF CHAR=CARRET OR CHAR=LNFEED THEN DO
             PCHV ARG2_CHAR; RETURN VAL
             END
            IF CHAR=ARG3 THEN RETURN VAL
             MSG("$ERROR: BAD NUMBER BEFORE "); PUT(CHAR)
             MSG(" CHARACTER--RETYPE PAST THERE--"); ARG2_GETLINE(TEL); VAL_0
        END
        ELSE VAL_VAL*ARG1+(CHAR-$0)
        END

END NUMBER

! PROCEDURE: INDEX
! INDEX YES IF ARG1: INDEXES ON ARG2: ELSE NO
%INDEX(ARG2,ARG1)

LOCAL A,B

        LOOP DO
          EIF A_NCHV ARG1=E.O.LIT OR A=CARRET THEN RETURN YES
          FIF B_NCHV ARG2=E.O.LIT THEN RETURN NO
          WHILE A=B
        END
        RETURN NO

END INDEX

! COMMAND DISPATCHER
%CMDIS
BEGIN:  IOCS(0)
        DEFIN
END CMDIS

        \\->BEGIN
   