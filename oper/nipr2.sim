!15  MAR 73    NIPR2.SIM    *CW
!MISCELLANEOUS FUNCTIONS AND PROCEDURES

GLOBAL.PROC(IN.BUF,H.IN.BUF)
GLOBAL.PROC(AUDIT,H.AUDIT)
GLOBAL.PROC(ENCODE.CMND,H.ENCODE.CMND)
GLOBAL.PROC(PUTLINE,H.PUT.LINE)
GLOBAL.PROC(BLD.ARG,H.BLD.ARG)
GLOBAL.PROC(BLD.CMD,H.BLD.CMD)

FIND CMD.STR()
FIND CMND.BLK.AREA
FIND WORK.SPACE(0)
FIND STORE(0)
FIND LINE.WORK.SIZE
FIND AUD.FN

FIND %PUNT
FIND %OUT.X.BUF
FIND %R.FAST.VALUE
FIND %R.C.B.HEAD
FIND %R.C.B.TEXT
FIND %APP.LIST
FIND %FM.STRING
FIND %FM.PTR
FIND %FM.LIST
FIND %OUT.B.S
FIND %OUT.BUF
FIND %OUT.MAP
FIND %R.P.L.DATA
FIND %L.P.L.DATA
FIND %FM.FR.INT
FIND %GET.BUF.CHAR
FIND %P.R.LIST
FIND %WORK.TO.BUF
FIND %G.ELMT
FIND %SCAN.TOKEN
FIND %GET.SYMBOL.VALUE
FIND %EQV.BUF
FIND %L.CB.S.B
FIND %R.CB.S.B
FIND %L.CB.S.O
FIND %R.CB.S.O
DEF NOT.TEXT AS FALSE
DEF FIRST.TOKEN AS 2

!


PROC(IN.BUF,H.IN.BUF,'IN.BUF',(FILE.NUMBER,BUF.LIST,EDIT.P))
!INPUT:  FILE NUMBER OF INPUT FILE (MAY BE TEL);
!        BUFFERLET.STRING.PTR (OR EOL) TO APPEND THE
!             TRANSFORMED CHARACTERS TO
!        EDIT PREDICATE:  IF TRUE, THEN TAKE EDITTED INPUT FROM TELETYP
!                         IF FALSE, THEN READ LINE FROM FILE
!VALUE:  POINTER TO THE RESULTANT BUFFERLET.STRING

!FILL WORK.SPACE() WITH WORK.NUM.CHARS NUMBER OF TRANSFORMED
!CHARACTERS UP TO MAX.WORK.SPACE.  THEN CALL WORK.TO.BUF(BUF.LIST).
!REPEAT PROCESS UNTIL CARRET IS FOUND IN INPUT STREAM.


LOCAL %READIT
LOCAL %PUT.OUT
LOCAL CHAR,X.CHAR,XCLM.P,STRING

WORK.NUM.CHARS  _  0

IF EDIT.P &
 THEN &
 DO
  IF FILE.NUMBER # TEL THEN MSG('INVIS CALLED WITH FN#TEL$')
  MSG('TYPE VISIBLE 8-BIT LINE:$')
  STRING _ GETLINE(TEL)
  IF CHAR _ NCHV(STRING) = E.O.LIT THEN GO PURGE
  PCHV(STRING)
 END
WHILE E.O.LIT # CHAR _ READIT(FILE.NUMBER)  #  CARRET    &
    THEN      &
      DO
         IF  CHAR = $!       &
              THEN      &
                DO
                   XCLM.P  _  TRUE
                   CHAR  _  READIT(FILE.NUMBER)
               END      &
         ELSE      &
              XCLM.P  _  FALSE
         X.CHAR  _  CHAR

         IF  CHAR = $&       &
              THEN      &
                DO
                   IF  (CHAR _ READIT(FILE.NUMBER)) = $&   OR      &
                        CHAR = $!     &
                        THEN     &
                          DO
                             X.CHAR  _  CHAR    
                         END            &
                   ELSE      &
                   IF  CHAR = $$                 &
                        THEN      &
                          DO
                             X.CHAR  _  XDEL-OCT 200
                         END            &
                   ELSE      &
                   IF  CHAR = $#       &
                        THEN      &
                          DO
                             X.CHAR  _ $        !SPACE
                         END            &
                   ELSE      &
                   IF  $@ <= CHAR < $`   !CONTROL CHARS!&
                        THEN      &
                             X.CHAR  _  CHAR - OCT 100       &
                   ELSE      !WE HAVE AN HONEST & AND ANOTHER CHAR!&
                     DO
                        PUT.OUT($&)
                        X.CHAR  _  CHAR
                    END
               END      !END IF CHAR=$AMPERSAND
         PUT.OUT(X.CHAR)
     END      !END WHILE CHAR _ READIT(FN)#CARRET
PURGE:  NULL
IF WORK.NUM.CHARS > 0  &
  THEN  &
    DO
      BUF.LIST  _  WORK.TO.BUF(BUF.LIST)
      WORK.NUM.CHARS  _  0
   END
RETURN BUF.LIST
!

%PUT.OUT(CHAR)
!INPUT:  THE CHAR TO OUTPUT;  BUF.LIST AND XCLM.P ARE IMPLIED PARAMS
!VALUE:  NONE

!WRITE CHAR TO WORK.SPACE AFTER FINISHING THE TRANSFORM BEGUN IN
!IN.BUF.   WRITE WORK.TO.BUF, IF WORK.SPACE IS FULL.

CHAR  _  CHAR.XFORM.TO.ASCII(CHAR)
IF  XCLM.P = TRUE  THEN  CHAR _ CHAR - OCT 200
WORK.SPACE( INC WORK.NUM.CHARS )  _  CHAR
IF WORK.NUM.CHARS >= MAX.WORK.SPACE    &
    THEN      &
      DO
         BUF.LIST _ WORK.TO.BUF(BUF.LIST)
         WORK.NUM.CHARS  _  0
     END
RETURN
END PUT.OUT


%READIT(FN)
!INPUT:   FILE NUMBER
!VALUE: A SINGLE CHARACTER (EITHER FROM GETLINE BUFFER OR FROM FILE)

IF EDIT.P  THEN RETURN  NCHV(STRING)

RETURN R(FN)

END READIT
END.PROC(IN.BUF,H.IN.BUF)
!


PROC(AUDIT,H.AUDIT,'AUDIT',(TYPE,PTR))
!INPUT:  TYPE IS ONE OF A.SLAVE.CMND, A.FREE.TEXT,  ETC.
!        PTR IS EITHER AN R.C.B.PTR OR CHPT PTR AS DESCRIBED IN NIMAC
!VALUE:  NONE


LOCAL CHPTR, TEMP


DO  TYPE  OF  0:MAX.AUDIT.TYPE

A.SLAVE.CMND:       &
    IF R.FAST.VALUE(AUDIT.LEVEL) >= AUD.MOST         &
         THEN      &
           DO
              CHPTR  _  CHPT('SLAVE COMMAND (HEADER, THEN TEXT):')
           OUT.SLAVE.CMND:        &
              PUTLINE(AUD.FN,CHPTR)
              IF TEMP _ R.C.B.HEAD(PTR) <= 0  &
               THEN &
                PUTLINE(AUD.FN,CHPT('NO VALID HEADER PTR')) &
               ELSE  &
                OUT.B.S(AUD.FN,TEMP,%OUT.BUF)
              IF  TEMP_R.C.B.TEXT(PTR) <= 0 &
               THEN &
                PUTLINE(AUD.FN,CHPT('NO VALID TEXT PTR')) &
               ELSE  &
                OUT.B.S(AUD.FN,TEMP,%OUT.BUF)
          END

A.FREE.TEXT:       &
    CHPTR  _  CHPT('FREE TEXT (HEADER, THEN TEXT):')
    GO  OUT.SLAVE.CMND

A.NET.ERROR:       &
    CHPTR  _  CHPT('NET ERROR (HEADER, THEN TEXT):')
    GO OUT.SLAVE.CMND

A.MILESTONE:       &
    IF R.FAST.VALUE(AUDIT.LEVEL) >= AUD.MILESTONE         &
         THEN      &
           DO
              CHPTR  _  CHPT('MILESTONE MESSAGE:')
           DO.IT:       &
              PUTLINE(AUD.FN,CHPTR)
              PUTLINE(AUD.FN,PTR)
          END

A.CMND.ERROR:      &
    CHPTR  _  ('COMMAND ERROR,  MESSAGE FOLLOWS:')
    GO  DO.IT

A.AUDIT.MSG:       &
    IF  R.FAST.VALUE(AUDIT.LEVEL) >= AUD.MSG.MARK         &
         THEN      &
           DO
              CHPTR  _  CHPT('AUDIT MESSAGE:')
              GO  DO.IT
          END

END      !END DO CASE ON TYPE
RETURN
END.PROC(AUDIT,H.AUDIT)
!

PROC(PUTLINE,H.PUTLINE,'PUTLINE',(FN,PTR))

!INPUT:  THEN FILE NUMBER OF THE FILE TO WRITE TO
!        THE CHPT-TYPE PTR TO THE STRING TO OUTPUT
!VALUE:  NONE

!PUTLINE PUTS OUT A STRING AS A RECORD TO THE FN FILE USING THE IOCS
!ROUTINES W AND WX.  NOTE THAT A CARRET IS APPENDED TO EACH RECORD.

LOCAL CHAR

PCHV(PTR)         !BACK UP 1 CHAR SO NCHV WILL GRAB FIRST CHAR

IF  1 # BITS.PER.WORD/25    &
  THEN   &
    IF  FN=0  THEN  FN _ 1

LINE.WORK.SIZE  _  0
LOOPL:        &
IF  (INC LINE.WORK.SIZE) < LINE.MAX.SIZE         &
    THEN      &
      DO
         IF  (CHAR  _   NCHV(PTR)) # E.O.LIT             &
              THEN      &
                   WX(FN,CHAR)         &
         ELSE      &
           DO
              W(FN,CARRET)
              RETURN
          END
     END      &
ELSE          &
  DO
    W(FN,CARRET)
    LINE.WORK.SIZE  _   0
 END
 GO LOOPL

END.PROC(PUTLINE,H.PUTLINE)
!
PROC(ENCODE.CMND,H.ENCODE.CMND,'ENCODE.CMND',(C.B.PTR))

!THE ENCODE.CMND ROUTINE PROCESSES A SLAVE COMMAND FROM A BUFFERLET
!AND BUILDS AN ENCODED COMMAND BLOCK.
!
!INPUT:         RECORD CONTROL BLOCK POINTER FOR THE NET DATA RECORD
!               CONTAINING THE COMMAND TO BE ENCODED
!
!OUTPUT:        LIST ELEMENT POINTER TO THE ENCODED COMMAND BLOCK
!               OR  E.O.L IF THERE IS NO COMMAND TO ENCODE


LOCAL %NILNIL
LOCAL %CK.NIL.EOC
LOCAL %VARVAL


DEF MAX.REC.SZ AS 256

LOCAL SKELETON.TABLE

TABLE SKELETON.INDEX(1:MAX.CMND)  [&
 0,4,34,34,8&
,11,8,14,17,21&
,25,25,30,1,46&
,8,21,38,78,41&
,46,46,48,84,46&
,38,21,21,21,21&
,21,38,52,21,21&
,56,60,60,65,71&
,34&
]

LOCAL TOKEN.TYPE
LOCAL TOKEN.VALUE
LOCAL VALUE.TYPE
LOCAL VALUE
LOCAL TYPE
LOCAL NUM.PARAMS
LOCAL CMND.OP.TYPE
LOCAL CMND.CODE
LOCAL CHAR.INDEX
LOCAL CMD.BLK
LOCAL B
LOCAL I
LOCAL J
LOCAL K
LOCAL TEXT.P
LOCAL N, BUF, OFF


!START OF EXECUTABLE CODE

SKELETON.TABLE _  "&
2128222813&
8118148254&
8291835168&
2248211819&
8391180829&
9829782218&
3111841117&
831108..44&
42782478"



MSG('ENCODING: ')
IF NOT(BUF _ R.CB.SB(CB.PTR)) THEN BUF _ R.CB.TEXT(CB.PTR)
OUT.B.S(TEL, BUF, %OUT.X.BUF)

FIRST.SCAN:  NULL
!PUTLINE(AUD.FN,CHPT('ENCODE.CMND CALLING SCAN.TOKEN FOR FIRST TIME$'))
[TOKEN.TYPE;TOKEN.VALUE] _ DOUBLE SCAN.TOKEN(C.B.PTR,FIRST.TOKEN)
IF TOKEN.TYPE=T.T.EOC  &
 THEN &
  IF TOKEN.VALUE=FALSE THEN RETURN (E.O.L) &
   ELSE  &
    GO FIRST.SCAN

!HOOK(AFTOK)
!CHECK IF WE HAVE AN IDENTIFIER WHICH IS A COMMAND

IF TOKEN.TYPE # T.T.IDENT    &
     THEN   &
        PUNT(HARD,'SLV CMD SYMBOL NOT FOUND. ENCODE.CMND',0)

!NOW CAN HOPEFULLY FIND THIS IDENTIFIER IN SYMBOL TABLE AS A COMMAND

[VALUE.TYPE;VALUE] _ DOUBLE GET.SYMBOL.VALUE(TOKEN.VALUE,S.T.CMND)
!HOOK(AFTGET)

IF VALUE.TYPE # S.V.T.INT  &
     THEN   &
         PUNT(HARD,'SLV CMD NOT FND IN SYM TAB ',0)

!WE HAVE A COMMAND
!NEED TO GET A LIST ELEMENT FROM THE CMND.BLK.AREA IN WHICH TO PLACE
!THE ENCODED COMMAND BLOCK

CMD.BLK _ G.ELMT(CMND.BLK.AREA)
!HOOK(C)

!COMMAND CODE FROM SYM TAB OCCUPIES FIRST WORD OF CMD.BLK

L.CMD.CODE(CMD.BLK,VALUE)
CMND.CODE _ VALUE

!NEXT WE GET A SYNTAX SKELETON FOR THIS COMMAND.  TO DO THIS, WE SET UP
!A CHAR.INDEX TO USE THE CH FUNCTION ON THE SKELETON TABLE

!HOOK(D)
CHAR.INDEX _ SKELETON.INDEX(CMND.CODE)

!SET THE NUMBER OF COMMAND OPERANDS FROM SYNTAX SKELETON INTO THE
!SECOND WORD OF THE CMD.BLK

!HOOK(E)
NUM.PARAMS _ CH(SKELETON.TABLE,CHAR.INDEX)-$0

!SCAN NEXT TOKEN
!MATCH TOKEN WITH DESIRED PARAMETER TYPE
!PLACE PARAMETER TYPE AND VALUE IN ENCODED COMMAND BLOCK


I _ J _ 0
WHILE  INC J <= NUM.PARAMS          &
    THEN DO
         INC I
         !SET TEXT.P TRUE IF EXPECTED CMND OPERAND TYPE IS TEXT
         IF PRS.T.TEXT=       &
              (CMND.OP.TYPE _        &
                   CH(SKELETON.TABLE,(INC CHAR.INDEX))-$0)    &
              THEN      &
                   TEXT.P _ TRUE         &
              ELSE      &
                   TEXT.P _ FALSE

!HOOK(SCANTOK)
         !SCAN TOKEN
         [TOKEN.TYPE;TOKEN.VALUE] _ DOUBLE SCAN.TOKEN(C.B.PTR,TEXT.P)

         !MATCH EXPECTED CMND OPERAND TYPE TO TOKEN.TYPE.  USE LOCAL
         !TYPE,VALUE INSIDE DO CASE, THEN MAKE ONE ASSIGNMENT AT END

 DO  CMND.OP.TYPE  OF  PRS.T.DATA:PRS.T.MAX

PRS.T.DATA: NULL
 IF CK.NIL.EOC THEN NILNIL &
  ELSE &
  DO
   !KLUDGE TO HANDLE DATA EFFICIENTLY: DO NOT PASS OVER DATA DURING
   !THIS SCAN--RATHER, DIDDLE WITH SCAN PTRS AND BUILD ANOTHER
   !ARGUMENT IN THE ENCODED COMMAND BLOCK.
   BUF _ R.CB.SB(CB.PTR)        !SCAN BUFFER
   OFF _ R.CB.SO(CB.PTR)        !SCAN BUFFER OFFSET
   VALUE _ TOKEN.VALUE

MSG('SCAN BUF FOR PRS.T.DATA: ')
OUT.B.S(TEL, BUF, %OUT.X.BUF)
MSG('SCAN OFFSET IS ');OUT.PTR(TEL,OFF)
MSG('SCAN CHAR IS '); K_OFF+VALUE
WHILE (INC K) <= OFF+VALUE+3 THEN OUT.PTR(TEL,GET.BUF.CHAR(BUF,K))

   [B;K] _ DOUBLE EQV.BUF(BUF, OFF+VALUE+1)
   L.CB.SB(CB.PTR, B)           !UPDATE SCAN BUFFER
   L.CB.SO(CB.PTR, K)           !UPDATE SCAN OFFSET PAST DATA
                                !SCAN BUF NOT UPDATED*************

   L.ARGTYP(CMD.BLK, I, PRS.T.INT)
   L.ARGVAL(CMD.BLK, I, VALUE)          !# OF CHARS OF DATA

   INC I
   L.ARGTYP(CMD.BLK, I, PRS.T.INT)
   L.ARGVAL(CMD.BLK, I, BUF)            !DATA BUF PTR

   INC I
   [TYPE; VALUE] _ [PRS.T.INT; OFF]     !DATA BUF OFFSET

   INC J                                !END LOOP BEFORE NEXT OPERAND
 END

PRS.T.INT:  NULL
 IF CK.NIL.EOC THEN NILNIL &
  ELSE &
  DO
   IF TOKEN.TYPE = T.T.INT THEN TYPE _ PRS.T.INT &
   ELSE PUNT(MED,'INTEGER OPND NOT FOUND ',0)
   VALUE _ TOKEN.VALUE
  END

PRS.T.CHAN: NULL
 IF CK.NIL.EOC THEN NILNIL &
  ELSE &
  DO
   IF TOKEN.TYPE # T.T.INT &
    THEN &
     PUNT(HARD,'CHAN NAME NOT INTEGER ',0)
   IF NOT( 0<=TOKEN.VALUE<128 ) &
    THEN &
    DO
     PUNT(MED,'CHAN NAME NOT(0<=N<128) ',0)
     TOKEN.VALUE _ 127
    END
   [TYPE;VALUE] _ [PRS.T.CHAN;TOKEN.VALUE]
  END

PRS.T.TEXT: NULL
 IF CK.NIL.EOC THEN NILNIL &
  ELSE &
  DO
   IF TOKEN.TYPE # T.T.TEXT &
    THEN &
     PUNT(HARD,'TEXT NOT FND IN ENCODE.CMD',0)
   [TYPE;VALUE] _ [PRS.T.TEXT;TOKEN.VALUE]
  END

PRS.T.LIT: NULL
 IF CK.NIL.EOC THEN NILNIL &
  ELSE &
  DO
   IF TOKEN.TYPE # T.T.IDENT &
    THEN &
     PUNT(HARD,'LITERAL NOT FND ',0)
   [TYPE;VALUE] _ [PRS.T.LIT;TOKEN.VALUE]
  END

PRS.T.IDENT: NULL
 IF CK.NIL.EOC THEN NILNIL &
  ELSE &
  DO
   [TYPE;VALUE] _ DOUBLE GET.SYMBOL.VALUE(TOKEN.VALUE,S.T.VAR)
  END

PRS.T.FILE: NULL
 IF CK.NIL.EOC THEN NILNIL &
  ELSE &
  DO
   [TYPE;VALUE] _ DOUBLE GET.SYMBOL.VALUE(TOKEN.VALUE,S.T.FILE)
   IF TYPE = S.V.T.NIL &
    THEN &
     PUNT(MED, 'FILE NOT IN SYM TAB FOR PRS.T.FILE', 0)
  END

PRS.T.VARVAL: VARVAL

PRS.T.VARVALIST: NULL
 IF TOKEN.TYPE # T.T.EOC &
  THEN &
  DO
   DEC CHAR.INDEX               !EXPECT LIST OF VARVALS,SO BACK UP SKEL PTR
   DEC J                        !KEEP LOOP GOING
   VARVAL                       !PROCESS VARVAL
  END &
  ELSE   !TOKEN.TYPE IS EOC WHICH STOPS THE LIST OF VARVALS!&
  DO
   IF PRS.T.EOC # CH(SKELETON.TABLE,(INC CHAR.INDEX))-$0  &
    THEN PUNT(HARD,'VARVALIST NOT ENDED PROPERLY ',0)
   DEC I                !CORRECT FOR EOC NEXT TIME THRU LOOP
  END

PRS.T.EOC: NULL
 IF TOKEN.TYPE # T.T.EOC &
  THEN &
   PUNT(HARD,'END OF COMMAND NOT FND ',0)

 END          !END OF DO CASE

         !ASSIGN OPERAND TYPE AND VALUE TO ENCODED COMMAND BLOCK

         L.ARGTYP(CMD.BLK,I,TYPE)
         L.ARGVAL(CMD.BLK,I,VALUE)
    END       !END OF WHILE LOOP ON J <= NUM.PARAMS
L.NUMARG(CMD.BLK,I)

!PUTLINE(TEL   ,CHPT('RETURN FROM ENCOD.CMND, ENC.CMD.BLK IS:'))
!HOOK(OUTLI)
!OUT.LIST(AUD.FN, CMD.BLK)
RETURN CMD.BLK
%NILNIL

TYPE _ PRS.T.NIL
VALUE _ T.V.T.NIL

RETURN


END NILNIL

%CK.NIL.EOC

IF TOKEN.TYPE = T.T.EOC OR TOKEN.TYPE = T.T.NIL THEN RETURN TRUE

RETURN FALSE

END CK.NIL.EOC

%VARVAL

EIF CK.NIL.EOC THEN NILNIL
ORIF TOKEN.TYPE = T.T.INT THEN [TYPE;VALUE] _ [PRS.T.INT;TOKEN.VALUE]
ORIF TOKEN.TYPE = T.T.IDENT &
 THEN &
 DO
  [TYPE;VALUE] _ DOUBLE GET.SYMBOL.VALUE(TOKEN.VALUE,S.T.VAR)
  IF TYPE # S.V.T.INT THEN PUNT(MED,'INTEGER SYMBOL VALUE NOT FOUND',0)
  TYPE _ PRS.T.INT
 END
ELSE PUNT(MED,'INTEGER NOT FOUND FOR VARVAL ',0)

RETURN

END VARVAL

END.PROC(ENCODE.CMND,H.ENCODE.CMND)
!
PROC(BLD.ARG,H.BLD.ARG,'BLD.ARG',(CMD.BLK,ARG.TYP,ARG.VAL))
                                !BUILD ARG IN CMD BLOCK
!INPUT:  -THE CMD.BLK ELEMENT PTR OR E.O.L
!        -ARGUMENT PARSE TYPE, E.G., PRS.T.NIL
!        -ARGUMENT VALUE

!VALUE:    THE CMD.BLK ELEMENT PTR

LOCAL NUM

IF CMD.BLK = E.O.L  THEN  CMD.BLK _ G.ELMT(CMND.BLK.AREA)

NUM _ R.NUMARG(CMD.BLK)+1
IF NUM > (ENCODED.CMND.SIZE-2)/2 &
 THEN &
  MSG('TOO MANY OPERANDS FOR BLD.CMD.BLK$')

L.NUMARG(CMD.BLK,NUM)           !SET NUMBER OF ARGS IN CMD.BLK
                                !NOW READY TO SET TYPE AND VALUE OF ARG
IF PRS.T.NIL <= ARGTYP < PRS.T.VARVAL &
 THEN &
  L.ARGTYP(CMD.BLK,NUM,ARGTYP) &
 ELSE &
  MSG('BAD PRS.TYPE IN BLD.ARGS$')

L.ARGVAL(CMD.BLK,NUM,ARG.VAL)

RETURN (CMD.BLK)

END.PROC(BLD.ARG,H.BLD.ARG)
!
PROC(BLD.CMD,H.BLD.CMD,'BLD.CMD',(BUF,CMD.BLK,CMD.CODE))
                                !BUILD SLAVE CMD FROM CMD.BLK
!INPUT:  -BUFFER PTR (OR E.O.L) TO APPEND COMMAND TO
!        -PTR TO CMD.BLK CONTAINING OPERANDS
!        -CMD.CODE NUMBER

!VALUE:  BUFFER PTR TO COMMAND STRING

DEF STR.OUT(A) AS FM.STRING(BUF,CHPT(A))

LOCAL I,NUMARGS,VAL,TYP

IF BUF # E.O.L &
 THEN &
  BUF _ STR.OUT(';')

BUF _ STR.OUT(CMD.STR(CMD.CODE))
BUF _ STR.OUT(' ')
NUMARGS _ R.NUMARG(CMD.BLK)

I _ 0
WHILE (INC I) <= NUMARGS &
 THEN &
 DO                             !LOOP THROUGH ARGUMENTS
  VAL _ R.ARGVAL(CMD.BLK,I)
  TYP _ R.ARGTYP(CMD.BLK,I)
  IF I#1  THEN STR.OUT(',')

  IF NOT(PRS.T.NIL<=TYP<=PRS.T.IDENT) &
   THEN &
    PUNT(HARD,'SKELETON TABLE MESSY IN BLD.CMD',0)
  DO TYP OF PRS.T.NIL:PRS.T.IDENT
 
  PRS.T.NIL: NULL

  PRS.T.INT:  FM.FR.INT(BUF,VAL)

  PRS.T.IDENT:   &
  PRS.T.LIT:  &
  PRS.T.TEXT:   APP.LIST(BUF,VAL)

 END    !DO CASE
 END   !WHILE

STR.OUT(';')

RETURN (BUF)

END.PROC(BLD.CMD,H.BLD.CMD)
