




                          STRINGS IN SFORTRAN
                              ON TYMCOM-X


STRING EXPRESSIONS

     A string  expression  consists  of  one  or  more  string  elements
separated by a plus sign denoting concatenation.  String expressions may
have parentheses around subexpressions as in  numeric  expressions,  but
the  parentheses do not affect code generation.  A string element can be
either a string constant, a string  scalar  reference,  a  string  array
reference,  a  builtin  string  valued  function  call or a user defined
string valued function call.

     In all the syntax descriptions,  the  following  notation  will  be
used.


        <se> denotes a string expression
        <ne> denotes a numeric expression
        <e> denotes either a <se> or <ne>
        S,S1,S2,... denote string variables
        SF,SF1,SF2,... denote nonbuiltin string valued functions
        NF,NF1,NF2,... denote nonbuiltin numeric valued functions
        n,n1,n2,... denote integer constants
        d,d1,d2,... denote array dimensions


The following are the syntax equations for string expressions.

<se> _ <s> | <s> + <se>
<s>  _ "text" | 'text' | <sv> | <sf>
<sv> _ S | S( <ne>,...,<ne> )
<sf> _ SF [ ( <e>,...,<e> ) ]
        | LEFT( <se>,<ne> )
        | RIGHT( <se>,<ne> )
        | SUBSTR( <se>,<ne> [ ,<ne> ]  )
        | STR( <ne> )
        | CHAR( <ne> )
        | DATE( <ne> )
        | MAX( <se>,...,<se> )
        | MIN( <se>,...,<se> )



STRING USES

     String  expressions  and  string  variables  can  be  used  in  the
following places in a program.


Replacement statement:   <sv> = <se>

Numeric function call:   ASC( <se> )
                         IVAL( <se> )







STRINGS IN SFORTRAN ON TYMCOM-X                                 PAGE   2



                         VAL( <se> )
                         DVAL( <se> )
                         CVAL( <se> )
                         INDEX( <se>,<se> [ ,<ne> ] )
                         LENGTH( <se> )
                         NF( <e>,...,<e> )

I/O statements:          READ( <ne>,<se> ) ...,<se>,...,S,...
                            where S is a string array
                            (also WRITE, DISPLAY, etc.)
                         OPEN( <ne>,<se>,... )

Relationals:             <se> .eq. <se>
                         <se> .ne. <se>
                         <se> .lt. <se>
                         <se> .gt. <se>
                         <se> .le. <se>
                         <se> .ge. <se>

Declarations:            STRING S1(n1),S2(d1,...dn)(n2)
                         STRING S3(*,...,*),(n3)
                         STRING FUNCTION SF [ (dummies) ]

Message typeout:         PAUSE <string-constant>
                         STOP <string-constant>
                         QUIT <string-constant>
                         DONE <string-constant>
                         ACCEPT ...,<string-constant>,...



INTERNAL STRING REPRESENTATION

     The compiled code for string references will not address  the  text
for the string directly, but will instead address a string pointer.  The
string pointer will have the declared length in the left  half  and  the
address  of  the  first  word of text in the right half.  The text for a
string scalar and a string array element will start at the beginning  of
a  word.   String  array  elements  will be stored consecutively as with
numeric arrays.  The string pointer for the array will address the first
element  of the array.  Since a string may have as its value a string of
length less than the string's  declared  length,  the  last  word  which
contains  text  will  have  bit 35 set.  If this word contains less than
five characters, the  last  character  will  be  followed  by  an  EOLIT
character (000).

















STRINGS IN SFORTRAN ON TYMCOM-X                                 PAGE   3



Examples:


Declaration    Value          Representation




































CODE GENERATED BY COMPILER FOR STRINGS

     The compiler views the string routines in the library as  accessing
a  stack of variable length entries.  Each entry is a string expression.
The compiler generates code to start a new stack entry, to concatenate a
string  to  the  end of the top stack entry and to make reference to any
stack entry relative to the top  entry.   The  runtime  routines  handle
stacking and unstacking of strings on the stack.

     The notation

        CALL FUN(A1,...,An)

will be used as shorthand for the standard calling sequence








STRINGS IN SFORTRAN ON TYMCOM-X                                 PAGE   4



        MOVEI   16,PTR
        PUSHJ   17,FUN
        .
        .
        XWD     -n,0
ptr:    XWD     T1,A1
        .
        .
        XWD     Tn,An

where Ti is the type code for argument Ai.  If there are  no  arguments,
the MOVEI 16,PTR instruction and the argument block are not generated.

i) <se>

     The  first  instruction  in  the  code  generated  for  all  string
expressions is the call

        CALL SESTRT

which indicates the start of a new string expression  and  a  new  stack
entry.   To  concatenate  a  string variable to the string on top of the
string stack, the UUO

        STRNG   S

is called.  The string pointer for the  string  to  be  concatenated  is
stored in S.  To concatenate a string array reference, the UUO

        STRNGA  S(X)

is called.  The subscript is in register X and the  string  pointer  for
the array is stored in S.

     When showing compiled code, <se> will be used to  denote  the  code
generated to put the string expression <se> on the string stack.


ii) LEFT( <se>,<ne> ) RIGHT( <se>,<ne> ) SUBSTR( <se>,<ne>,<ne> )

        <se>
        CALL LEFT(<ne>) or RIGHT(<ne>) or SUBSTR(<ne>,<ne>)

Example: S1+LEFT(S2+S3,N)+S4

        PUSHJ   17,SESTRT
        STRNG   S1
        PUSHJ   17,SESTRT
        STRNG   S2
        STRNG   S3
        MOVEI   16,PTR
        PUSHJ   17,LEFT
        STRNG   S4
        .
        XWD     -1,0







STRINGS IN SFORTRAN ON TYMCOM-X                                 PAGE   5



PTR:    XWD     0,N

All three functions (LEFT,RIGHT,SUBSTR) remove the top stack  entry  and
then concatenate their value to the new top stack entry.


iii) STR(<ne>) CHAR(<ne>)

        CALL STR(<ne>) or CHAR(<ne>)

Example: S1+CHAR(N)

        PUSHJ   17,SESTRT
        STRNG   S1
        MOVEI   16,PTR
        PUSHJ   17,CHAR
        .
        XWD     -1,0
PTR:    XWD     0,N

Both functions concatenate their value to the top stack entry.


iv) DATE(<ne>)

        CALL DATE

The argument to the DATE  function  is  not  used.   The  value  of  the
function is concatenated to the top of the string stack.


v) MAX(<se>,...,<se>) MIN(<se>,...,<se>)

        <se>1
        .
        .
        <se>n
        CALL MAX(n) or MIN(n)

All arguments are removed from the string stack and after their removal,
the value is concatenated to the top stack entry.

Example: MAX(S1,S2,SUBSTR(S3,I,J))+S4

        PUSHJ   17,SESTRT
        PUSHJ   17,SESTRT
        STRNG   S1
        PUSHJ   17,SESTRT
        STRNG   S2
        PUSHJ   17,SESTRT
        STRNG   S3
        MOVEI   16,P1
        PUSHJ   17,SUBSTR
        MOVEI   16,P2
        PUSHJ   17,MAX







STRINGS IN SFORTRAN ON TYMCOM-X                                 PAGE   6



        STRNG   S4
        .
        .
        XWD     -2,0
P1:     XWD     0,I
        XWD     0,J
        XWD     -1,0
P2:     XWD     [3]


vi) SF(...,<se>,...) NF(...,<se>...)

     String arguments in all user defined function calls are  passed  on
the  string  stack.   A type code in the argument block indicates to the
function that the argument is on the stack rather than pointed to by the
right  half  of the argument block entry.  The strings on the stack will
be stored in local variables on entry to subroutines or  functions  with
string  dummies.   Also,  all  string arguments will be removed from the
stack after being stored in local variables.


vii) RETURN from a string valued function

     RETURN will concatenate its value to the top entry on the stack  by
generating a STRNG UUO of its value.


viii) <sv> = <se>

     Replacement statements into a string scalar S generate

        <se>
        SSTOR   S

and  replacement  statements  into  the  string  array   S(<subscripts>)
generate

        <se>
        <subscripts> into register X
        SSTORA  S(X)


ix) ASC(<se>) IVAL(<se>) VAL(<se>) DVAL(<se>) CVAL(<se>) LENGTH(<se>)

        <se>
        CALL ASC or IVAL or VAL or DVAL or CVAL or LENGTH

Each function removes the top stack entry before returning.


x) INDEX(<se>1,<se>2,<ne>)

        <se>1
        <se>2
        CALL INDEX(<ne>)







STRINGS IN SFORTRAN ON TYMCOM-X                                 PAGE   7



Before returning, the two argument strings are removed from the stack.


xi) <se> as FORMAT reference

        <se>
        CALL SFRFS(<unit>) or SFWFS(<unit>)

The format is passed to the format processor on the string  stack.   The
routine  SFRFS  is  for formatted read and SFWFS is for formatted write.
Both calls remove the top stack entry before returning.


xii) String references in I/O list

     I/O list items generate one of two calls.  For a string expression,
including string scalar and array references, the code generated is

        <se>
        CALL STREL

The top stack entry is  removed  before  returning.   For  unsubscripted
array references, the code generated is

        CALL STRELA(S,N)

where S is the string pointer for the array  and  N  is  the  number  of
elements in the array.


xiii) OPEN(<unit>,<se>,...)

        <se>
        CALL SFOPNS(<unit>,<type>,<record-size>)

The file name is passed on the string stack  and  is  removed  from  the
stack before returning.


xiv) relationals

     Six routines are used to compare two strings.  Each return  without
skipping  if  the tested condition is false and skip if the condition is
true.

Relation        Routine   Test

<se>1.EQ.<se>2  SKPSE     <se>1 = <se>2
<se>1.NE.<se>2  SKPSN     <se>1 # <se>2
<se>1.LT.<se>2  SKPSL     <se>1 < <se>2
<se>1.GT.<se>2  SKPSG     <se>1 > <se>2
<se>1.LE.<se>2  SKPSLE    <se>1 <= <se>2
<se>1.GE.<se>2  SKPSGE    <se>1 >= <se>2









STRINGS IN SFORTRAN ON TYMCOM-X                                 PAGE   8



All six routines remove both arguments from the stack before returning.

Example: IF(S1.GT.S2) S1=S2

        PUSHJ   17,SESTRT
        STRNG   S1
        PUSHJ   17,SESTRT
        STRNG   S2
        PUSHJ   17,SKPSG
        JRST    .+4
        PUSHJ   17,SESTRT
        STRNG   S2
        SSTOR   S1


xv) Message typeout (DONE QUIT STOP PAUSE ACCEPT)

     String constants are output to the terminal by the call

        CALL SFPRINT(<string-constant>)


SUMMARY OF CALLS GENERATED BY COMPILER

Call                     Meaning

STRNG S                  concatenate S to top entry on stack
STRNGA S(X)              concatenate S(X) to top entry on stack
SSTOR S                  store top stack entry into S
SSTORA S(X)              store top stack entry into S(X)
CALL SESTRT              start string expression
CALL LEFT(<ne>)          take left <ne> characters of top stack entry
CALL RIGHT(<ne>)         take right <ne> characters of top stack entry
CALL SUBSTR(<ne>1,<ne>2) take substring of length <ne>1 starting
                         at position <ne>2
CALL STR(<ne>)           generate string representation of <ne>
CALL CHAR(<ne>)          convert <ne> to a string
CALL DATE                generate date string
CALL MAX(n)              return maximum string of top n stack entries
CALL MIN(n)              return minimum string of top n stack entries
CALL ASC                 return numeric representation of first
                         character of top entry on stack
CALL IVAL                convert string to integer
CALL VAL                 convert string to real
CALL DVAL                convert string to double precision
CALL CVAL                convert string to complex
CALL LENGTH              return length of top stack entry
CALL INDEX(<ne>)         determine position of one string in another
                         starting at position <ne>
CALL SFRFS               formatted read with string expression as format
CALL SFWFS               formatted write with string expression as
                         format
CALL STREL               string I/O item on string stack
CALL STRELA              unsubscripted string array as I/O item
CALL SFOPNS              open file name on stack







STRINGS IN SFORTRAN ON TYMCOM-X                                 PAGE   9



CALL SKPSE               skip if strings equal
CALL SKPSN               skip if strings unequal
CALL SKPSL               skip if strings less than
CALL SKPSG               skip if strings greater
CALL SKPSLE              skip if strings less than or equal
CALL SKPSGE              skip if strings greater than or equal
CALL SFPRINT             type string constant


OTHER STRING ROUTINES

     Most of the string routines do not require knowledge of
the string stack structure or the internal representation
of strings.
They are

     VAL, IVAL, DVAL, CVAL, STR
     SFRFS, SFWFS, STREL, STRELA, SFOPNS, SFPRINT
     DATE, CHAR, ASC, LENGTH, INDEX
     MAX, MIN
     SKPSE, SKPSN, SKPSL, SKPSG, SKPSLE, SKPSLE

     These routines Either scan  entire  stack  entries  or  generate  a
string  which is concatenated to the top stack entry.  All references to
the stack are through routines in  the  library.   The  following  is  a
complete set of entries for these string routines.


i) Length of stack entry n - CALL SSIZE(n)

     Returns as its value the number of characters in stack entry n.


ii) remove stack entry n - CALL SREMOVE(n)

     Removes entry n from the string stack.  The LENGTH  function  could
be written as

N_SSIZE(1)
SREMOVE(1)
RETURN N


iii) Scan stack entry n - ISGET(P,N) C_SGET(P)

     The function ISGET is called to initialize the scan  of  the  stack
entry  n.  It returns in P, a pointer to the nth stack entry.  P must be
an array of length 3.  The function SGET returns  successive  characters
from  the  string stack entry pointed to by P.  The end of the string is
indicated by returning an EOLIT(000).

Example: Test if top two stack entries are equal

LOCAL P1(3),P2(3)
ISGET(P1,1)







STRINGS IN SFORTRAN ON TYMCOM-X                                 PAGE  10



ISGET(P2,2)
WHILE C1_SGET(P1)=C2_SGET(P2)#EOLIT THEN NULL
RETURN [C1=C2]


iv) Store into string - ISPUT(P,N) NSPUT(P,M) SPUT(P,C) S_ESPUT(P)

     The function ISPUT tests whether stack entry n can be stored  into.
Stack entries which can be stored into are single string scalar or array
references.  If the entry cannot be stored into,  ISPUT  returns  false.
Otherwise,  it returns true and stores into P a pointer to the string on
the string stack.  The function NSPUT  returns  in  P  a  pointer  to  a
temporary  string  variable  large  enough  to  store m characters.  The
subroutine SPUT concatenates the character C to the string pointed to by
P.   THe pointer P is either the pointer returned by ISPUT or NSPUT.  To
indicate THE end of the  string,  the  function  ESPUT  is  called.   It
returns a string pointer for the new string which can then be put on the
string stack with the STRNG UUO.

Example 1 - Set top entry to 'a' if possible

LOCAL P(3)
IF ISPUT(P,1) THEN DO
   SPUT(P,$A)
   S_ESPUT(P)
   SREMOVE(1)
END

Example 2 - The CHAR function

%CHAR(N)
LOCAL P(3)
NSPUT(P,1)
SPUT(P,N)
RETURN ESPUT(P)


STACK POINTER FORMAT

     The stack pointer set by ISGET, ISPUT and NSPUT has the following
 format.

Word 1 - the address of the current item in the stack entry being
scanned or written.

Word 2 - a PDP-10 byte pointer. Points to the last character
read or written.

Word 3 - the number of characters remaining in the stack entry item
 pointed
to by word 1.
For ISGET, it is initialized to the length of the item on the stack
pointed to by word 1.
For ISPUT and NSPUT, it is initialized to the capacity of the string
being created.







STRINGS IN SFORTRAN ON TYMCOM-X                                 PAGE  11
































































   