!13 MAR   73   NILST.SIM   *CW
!LIST FUNCTIONS

!COMPILATION PARAMETERS
DEF NUM.I.Q.EL AS 0            !INIT NUM Q ELMTS********

!LIST AREA DEFINITIONS
DEF L.EL.SZ AS 0          !OFFSET OF ELEMENT SIZE
DEF L.NUM.EL AS 1         !OFFSET FOR NUMBER OF ELEMENTS
DEF L.F.L AS 2            !OFFSET FOR HEAD OF FREE LIST
DEF L.INC.N AS 3          !INCREMENTAL NUMBER OF ELEMENTS
DEF FIRST.FREE.EL AS 4    !FIRST FREE ELEMENT
DEF NUM.EL(N) AS AR.CE(N,L.NUM.EL)      !NUMBER OF ELEMTS
DEF EL.SIZE(N) AS AR.CE(N,L.EL.SZ)      !ELMT SIZE
DEF F.LIST(N) AS AR.CE(N,L.F.L)         !FREE LIST ANCHOR
DEF INC.NUM(N) AS AR.CE(N,L.INC.N)      !INCREMENT NUMBER
DEF AR.CE(N,L) AS AR.CELL(N,L)   !KEY TO DEFINITIONS

!DEFINE Q ELEMENT SIZE
DEF Q.EL.SIZE AS 2

FIND N.AREA(0)
FIND S.TBL.PTR
FIND C.B.AREA
FIND BUFFERLETS
FIND %G.ELMT
FIND %P.INSERT.LIST
FIND %R.ELMT
FIND %L.P.CDR
FIND %R.P.CDR
FIND %R.P.CAR
FIND %L.P.CAR
FIND %FM.FR.INT
FIND %MX
FIND %N.OFF.PACK
FIND %AR.N
FIND %AR.OFF
FIND %G.BUFFERLET
FIND %REPLACD
FIND %R.P.L.DATA
FIND %L.P.L.DATA
FIND %FM.STRING
FIND %SET.AR
FIND %PUNT
FIND %C.AREA

FIND CR.STRING
FIND STORE(0)
FIND MASK(0)
FIND MASK.COMP(0)
FIND WORKSPACE(0)
FIND HACK.TEMP
FIND RADIX

GLOBAL.PROC(APPLY,H.APPLY)
GLOBAL.PROC(C.ELMTS,H.C.ELMTS)
GLOBAL.PROC(AD.ELMTS,H.AD.ELMTS)
GLOBAL.PROC(Q.PUSH,H.Q.PUSH)
GLOBAL.PROC(Q.POP,H.Q.POP)
GLOBAL.PROC(Q.DELETE,H.Q.DELETE)
GLOBAL.PROC(FUSBUDGET,H.FUSBUDGET)
!
!LIST ELEMENT CODE

PROC(C.ELMTS,H.C.ELMTS,'C.ELMTS',(SIZE,NUMBER))   !INITIALIZE LIST AREA
!INPUT: SIZE OF EACH ELEMENT,NUMBER OF ELEMENTS TO INITIALIZE
!VALUE: A POINTER TO THE ARRAY

!A SET OF ROUTINES: C.ELMTS, G.ELMT, R.ELMT, AND AD.ELMTS REALIZE
!THE ABSTRACTION OF LIST ELEMENTS, USING THE SPACE MANAGEMENT FUNCTIONS.

!A LINKED LIST AREA IS CREATED BY C.ELMTS.  SUCH AN AREA HAS THE
!ELEMENT SIZE (0<SIZE) IN LOCATION L.EL.SIZE, THE NUMBER OF
!ELEMENTS (0<=NUMBER) IN L.NUM.EL, THE INCREMENTAL ENLARGEMENT SIZE
!(NUMBER OF ELEMENTS TO ADD AT A CHUNK (INC.NUM = INITIAL NUMBER
!OF ELEMENTS >= 0) IN L.INC.NUM IN A HEADER OF THE AREA.
!A LIST OF FREE ELEMENTS IS MAINTAINED; THIS LIST STARTS IN
!L.FREE.LIST OF THE ARRAY, AND IS LINKED BY <POINTER>S; AN <E.O.L>
!POINTER TERMINATES THE LIST.

!AN ELEMENT HAS LENGTH <SIZE> (0<SIZE); THE FIRST CELL OF AN
!ELEMENT IS THE LINKAGE CELL (CDR), THE REST OF THE CELLS ARE
!DATA CELLS (1<=DATA CELL<=SIZE), INITIALIZED TO ZERO.

!LOCAL MACROS
DEF L.EL.SIZE AS 0      !OFFSET OF ELEMENT SIZE
DEF L.NUM.EL AS 1       !OFFSET FOR NUMBER OF ELEMENTS
DEF L.FREE.LIST AS 2    !OFFSET FOR HEAD OF FREE LIST
DEF L.INC.NUM AS 3      !INCREMENTAL NUMBER OF ELEMENTS
DEF FIRST.FREE.EL AS 4    !FIRST FREE ELEMENT
DEF NUM.EL(NAME) AS AR.CELL(NAME,L.NUM.EL)
DEF EL.SIZE(NAME) AS AR.CELL(NAME,L.EL.SIZE)
DEF FREE.LIST(NAME) AS AR.CELL(NAME,L.FREE.LIST)
DEF INC.NUM(NAME) AS AR.CELL(NAME,L.INC.NUM)

!BEGIN C.ELMTS CODE

LOCAL P,NAME,EL,NEXT,I,PTR

FUSBUDGET               !****
!FORCE SIZE > 0
IF SIZE <=0 THEN SIZE _ 1
!FORCE POSITIVE NUMBER OF ELEMENTS
IF NUMBER < 0 THEN NUMBER _ 0

!GET AN AREA FOR THE ELEMENTS
[P;NAME] _ DOUBLE C.AREA((SIZE*NUMBER)+FIRST.FREE.EL)
PTR _ N.OFF.PACK(NAME,0)

!WAS AREA CREATED?
IF NOT P THEN PUNT(HARD,'CANNOT CREATE ELEMENT AREA',0) !NO, DISASTER!
!YES, SEE THAT THE NAME WILL FIT INTO A <POINTER>
IF NAME > (1 SHL (BITS.PER.WORD-17))  &
                        !UNMITIGATED DISASTER! &
  THEN PUNT(HARD,'AREA NAME TOO LARGE AT CREATION',0)

!ALL OK WITH NAME.  INITIALIZE AREA
EL.SIZE(NAME) _ SIZE
NUM.EL(NAME) _ INC.NUM(NAME) _ NUMBER
!LINK THE FREE LIST
I _ NUMBER
EL _ FIRST.FREE.EL
FREE.LIST(NAME) _ E.O.L         !TEND TO END OF LIST
WHILE DEC I >= 0 &
  THEN &
    DO
    CDR(NAME,EL) _ REPLACD(NAME,L.FREE.LIST,N.OFF.PACK(NAME,EL))
    EL _ EL+SIZE
    END

FUSBUDGET               !****
RETURN(PTR)

                                !END OF C.ELMTS CODE
                                !BLOCK ENDS AFTER LAST ELMT ROUTINE
!
%AD.ELMTS(PTR,COUNT)            !ADD SOME ELEMENTS
!INPUT: AREA POINTER, COUNT OF ELEMENTS TO BE ADDED
!VALUE: AREA POINTER

LOCAL NAME, OFFSET,P,LNEXT,I

FUSBUDGET               !****
!VALIDATE AREA NAME-FIELD OF <PTR>
IF NOT 1<NAME _ AR.N(PTR) <= NUM.AREAS THEN RETURN(0)

!FORCE POSITIVE, FINITE COUNT
IF 0>=COUNT THEN COUNT _ 1

!REMEMBER WHERE FIRST NEW ELEMENT WILL BE
EL _ AR.SIZE(NAME)

!TRY FOR GREATER OF <INC.NUM> AND <COUNT> NEW ELEMENTS
[P;] _ DOUBLE SET.AR(NAME,AR.SIZE(NAME)+(I _ MX(INC.NUM(NAME), &
                     COUNT))*EL.SIZE(NAME))

!DID WE SUCCEED?
IF NOT P &
  THEN &
    DO          !OOPS!
    !FAILED, TRY FINAL RECOURSE
                !TRY LESS AMBITIOUS GOAL
    [P;] _ DOUBLE SET.AR(NAME,AR.SIZE(NAME)+((I _ COUNT)* &
                                   EL.SIZE(NAME)))
                !DID WE SUCCEED?
    IF NOT P THEN PUNT(HARD,'NO SPACE TO ADD ELEMENTS',0)  !DISASTER
    END

!HAVE SPACE; STRING ELEMENTS ON THE FREE LIST
!I IS NUMBER OF NEW ELEMENTS; EL IS LOC OF FIRST ELEMENT

!COUNT NEW ELEMENTS
NUM.EL(NAME) _ NUM.EL(NAME)+COUNT

WHILE DEC I >= 0 &
  THEN &
    DO
    CDR(NAME,EL) _ REPLACD(NAME,L.FREE.LIST,N.OFF.PACK(NAME,EL))
    EL _ EL+EL.SIZE(NAME)
    END

FUSBUDGET               !****
RETURN(PTR)

END AD.ELMTS

END.PROC(C.ELMTS,H.C.ELMTS)
!
PROC(APPLY,H.APPLY,'APPLY',(%FN,ARG,LIST)) !APPLY FN TO LIST ELMTS
!INPUT:  1) A FUNCTION
!        2) THE FIRST ARGUMENT TO BE GIVEN THE FUNCTION
!        3) A LIST, EACH ELEMENT OF WHICH WILL BE ITERATIVELY
!            APPLIED AS THE SECOND ARGUMENT OF THE FUNCTION
!VALUE: THE (UPDATED) FIRST  ARGUMENT 

!CAUTION ** THIS ROUTINE IS NOT EQUIVALENT TO A LISP APPLY.
!THIS APPLY IS INTENDED FOR USE WITH ROUTINES LIKE OUT.BUF,
!OUT.X.BUF, AND FM.BUF.CHARS.

!THE TRICK IS THAT THE VALUES OF THESE ROUTINES ARE FED BACK IN
!ON THE FUNCTION CALL AS THE FIRST ARGUMENT.

!A SAMPLE CALL:
!BUF _ APPLY(%FM.BUF.CHARS,BUF,SOME.LIST)
!THE RESULT WILL BE TO APPLY FM.BUF.CHARS TO EACH ELEMENT OF THE
!LIST IN TURN.

WHILE LIST # E.O.L &
 THEN &
  DO
  ARG _ FN(ARG,LIST)
  LIST _ R.P.CDR(LIST)
  END

RETURN(ARG)
END.PROC(APPLY,H.APPLY)
!
PROC(Q.POP,H.Q.POP,'Q.POP',(Q))
!INPUT:  THE Q TO BE POPPED
!VALUE:  THE CAR OF THE TOP ELEMENT

LOCAL EL,VAL

FUSBUDGET               !****
IF EL _ R.P.CDR(Q) = E.O.L  THEN RETURN (0)
VAL _ R.P.CAR(EL)
L.P.CDR(Q,R.P.CDR(EL))
R.ELMT(EL)

RETURN (VAL)

END.PROC(Q.POP,H.Q.POP)



PROC(Q.PUSH,H.Q.PUSH,'Q.PUSH',(Q,THING))
!INPUT:  THE Q ONTO WHICH THE THING WILL BE PUSHED
!VALUE:  THING

LOCAL EL

FUSBUDGET               !****
P.INSERT.LIST(Q,EL _ G.ELMT(TWO.AREA))
L.P.CAR(EL,THING)

RETURN (THING)

END.PROC(Q.PUSH,H.Q.PUSH)



PROC(Q.DELETE,H.Q.DELETE,'Q.DELETE',(Q.PTR))
!########

LOCAL EL
FUSBUDGET               !****
IF NOT(EL _ R.P.CDR(Q.PTR)) THEN RETURN(FALSE)
L.P.CDR(Q.PTR,R.P.CDR(EL))
R.ELMT(EL)
RETURN(TRUE)
END.PROC(Q.DELETE,H.Q.DELETE)
!
PROC(FUSBUDGET,H.FUSBUDGET,'FUSBUDGET',)  !VALIDATE THE STOREAGE
                                                !CONTROL INFORMATION
LOCAL I,  J,  %FUS.LIST
I _ 1
J _ 2
WHILE I <= STORE(0)-1 &
 THEN &
  DO
  WHILE STORE(J) = -1 THEN INC J
  IF STORE(J)-STORE(I) # STORE(STORE(0)+I) &
   THEN &
    DO
    PUNT(HARD,'STORE CONTROL MESSED UP',2,1,I,1,J)
    END
  I _ J
  INC J
  END
FUS.LIST
RETURN


%FUS.LIST               !FUSS ABOUT LIST AREAS
!FUSS ABOUT EACH KNOWN LIST AREA IN TURN
LOCAL %SUB.FUS,  I
I _ 1
WHILE INC I <= 4 &
 THEN &
  DO
  SUB.FUS(N.AREA(I))
  END
SUB.FUS(BUFFERLETS)
SUB.FUS(C.B.AREA)
SUB.FUS(S.TBL.PTR)
RETURN

%SUB.FUS(PTR)   !FUS ABOUT A GIVEN AREA
LOCAL N,  LOC,  %PUN
IF PTR = E.O.L THEN RETURN
N _ AR.N(PTR)
IF NOT (0<N<=NUM.AREAS) THEN PUN('FAR OUT LIST AREA NUM')
LOC _ AR.LOC(0)
IF NOT (2 <= EL.SIZE(N)<50) THEN PUN('FAR OUT LIST EL.SIZE')
IF INC.NUM(N) < 0 THEN PUN('LIST INC.NUM < 0')
IF NOT (AR.N(F.LIST(N))#0 OR AR.N(F.LIST(N))#N) &
 THEN PUN('BAD LIST AREA NUMBER IN POINTER')
IF AR.SIZE(N)# FIRST.FREE.EL+NUM.EL(N)*EL.SIZE(N) &
 THEN PUN("LIST AREA SIZE DOESN'T COMPUTE")
RETURN
%PUN(MESS)
PUNT(MED,MESS,1,%FM.FR.INT,N)
RETURN
END PUN
END SUB.FUS
END FUS.LIST
END.PROC(FUSBUDGET,H.FUSBUDGET)
 