MODULE DEAF(DOLLAR,ENTRIES=($DEFER,$DMKDD,$DINIT,$DMKRB,$DINSC),
        FSAVE,TIMING,TIMER=EXTERNAL(SIX12))=
BEGIN

REQUIRE DDEFS.BLI[7,107355];
REQUIRE DTDEFS.BLI[7,107355];
REQUIRE DVDEFS.BLI[7,107355];
REQUIRE GDEFS.BLI[7,107355];
REQUIRE UDEFS.BLI[7,107355];
REQUIRE SDEFS.BLI[7,107355];
REQUIRE RDEFS.BLI[7,107355];

MAP U$DYNARY DBASE$;
MAP G$ DGAM$;
MAP DL$ DLIST$;
MAP DR$ DREGS$;
MAP DF$I DFLAG$;
MAP U$DYNARY DPOOL$;
MAP U$DYNARY DEFER$;


UNDECLARE $DMKDD;

GLOBAL ROUTINE $DMKDD(IEB,FISTP)=
   BEGIN
   %$DMKDD MAKES ONE EACH DATA DESCRIPTOR...
   THE TWO PARAMETERS ARE:
        (1)IEB....ITEM ENTRY BUFFER(A SYMBOL TABLE ENTRY)
        (2)FISTP....SYMBOL TABLE POINTER TO A FIELD INCARNATION ENTRY

   THE GENERAL FLOW IS AS FOLLOWS...
        
        (1)USING THE FISTP, WE GET THE FIELD INCARNATION ENTRY;

        (2)WE EMIT A "DV$SET" TO SET THE LITERAL LOCATION CTR
        TO POINT TO WHERE THIS DD IS TO GO;

        (3)WE EMIT A "DV$USE" TO USE THE LITERAL LOCATION COUNTER;

        (4)WE BUILD THE FIRST WORD OF THE DD, FILLING IN THE BLANKS
        FOR DD$CLASS, DD$TYPE, DD$QP, AND THE WE EMIT IT
        TO DELTA CODE;

        (5)WE COPY THE FORMAT PICTURE FROM THE FIELD INCARNATION
        ENTRY AND EMIT IT;

        (6)WE FIND THE RELOCATIBLE ADDRESS OF THE LITERAL WHOSE VALUE IS 
        THE NAME OF THE FIELD WHOSE DD WE ARE BUILDING
        BY GETTING THE NAME ENTRY VIA S$STP1 FROM THE FIELD INCARNATION,
        AND DOING A $DNAME ON THE NAME ENTRY;  WE THEN GET THE
        NAME LITERAL FOR THE ASSOCIATED RELATION (NULL IF SCALAR)
        BY GETTING THE RELATION INCARNATION ENTRY VIA S$RSTP,
        THE NAME ENTRY VIA S$STP1 OF THE RELATION INCARNATION,
        THE LITERAL INCARNATION STP VIA $DNAME; AND THE RELOCATIBLE
        ADDRESS FROM THE LITERAL INCARNATION ENTRY OF THE RELATION NAME;

        (7)WE EMIT A DV$DRELB FOR THE TWO ADDRESSES FROM (6);

        (8)WE FIND THE RELOCATIBLE ADDRESS OF THE VERIFY
        CODE BY FIRST FETCHING THE FIELD DEFINITION ENTRY
        USING S$FDSTP, AND THEN FETCHING THE ADDRESS FROM THE
        LABEL INCARNATION POINTED TO BY THE S$VERFSTP IN THE
        FIELD DEFINITION ENTRY;  THEN WE GET THE RELOCATIBLE
        ADDRESS OF THE NULL VALUE BY FETCHING THE LITERAL INCARNATION
        ENTRY POINTED TO BY THE S$NULL ENTRY OF THE FIELD INCARNATION
        AND SAVING THE ADDRESS INFORMATION;

        (9)WE THEN EMIT A DV$DRELB FOR THE TWO ADDRESSES, FREE THE
        FIELD INCARNATION ENTRY, AND EXIT....

        N.B.  IN (8) WE GET THE FIELD DEFINITION FROM THE ITEM ENTRY
        BUFFER, AND THAT IS THE ONLY TIME IT IS ACCESSED IN THIS
        ROUTINE

   WELL, WITH ALL THAT GOOD STUFF, HOW CAN WE FAIL???

   THERE ARE AT LEAST SEVEN CALLS TO $SGSTE IN THIS ROUTINE...

   /JS..........................6/7/74
   %

   LOCAL P,FIB,R,T,P2,LBASE,LDISP,RBASE,RDISP,S;
   LOCAL A[2];
   MAP S$ FIB;  %FIELD INCARNATION BUFFER%
   MAP S$ P; %WORK BUFFER%
   MAP DDW$I P2;  
   MAP S$ IEB;
   LOCAL DTMP;
   MAP DT$ DTMP;

   FIB _ $SGSTE(.FISTP) ; %FIELD INCARNATION%

   $DEM1W(DV$SET,.FIB[S$DDB],0,.FIB[S$DDFO]);
   $DEUCE(DBV$DDBASE);

    %BUILD WORD WITH DD$CLASS, DD$TYPE, DD$QP%
   P2_0;
   IF .FIB[S$DTYP] EQL SV$DLIT THEN
        P2[DD$CLASS]_DDV$CLASS1   %A DATE FIELD%
   ELSE                         %2/7/75%
   P2[DD$CLASS]_DDV$CLASS2;  %A FIELD INCARNATION%
   SELECT .FIB[S$DTYP] OF 
        NSET
SV$SINGD:       BEGIN
                P2[DD$TYPE]_DDV$1WD;
                P2[DD$PRSIZE]_.FIB[S$LCHAR];
                P2[DD$QPINT]_.FIB[S$INTD];
                P2[DD$QPDEC]_.FIB[S$DECD];
                P2[DD$TRACE]_0;
                END;

SV$DBLD:        BEGIN
                P2[DD$TRACE]_0;
                P2[DD$TYPE]_DDV$2WD;
                P2[DD$PRSIZE]_.FIB[S$LCHAR];
                P2[DD$QPINT]_.FIB[S$INTD];
                P2[DD$QPDEC]_.FIB[S$DECD];
                END;

SV$SLIT:        BEGIN
                P2[DD$TRACE]_0;
                P2[DD$TYPE]_DDV$STR;
                P2[DD$PRSIZE]_.FIB[S$LCHAR];
                P2[DD$QP]_.FIB[S$LCHAR];
                END;
SV$DLIT:        BEGIN
                P2[DD$TRACE]_0;
                P2[DD$TYPE]_DDV$1WD;
                DTMP_FIB[S$DTP];
                P2[DD$PRSIZE]_.DTMP[DT$PRSIZE];
                P2[DD$QPINT]_.FIB[S$INTD];
                P2[DD$QPDEC]_.FIB[S$DECD];
                %DATE FIELD...TODAY IS 2/7/75%
                END;

        TESN;

    $DEMIT(DV$CNST,0,0,0,.P2);

    P2[DD$FP]_.FIB[S$FP];

    %EMIT SECOND WORD..FORMAT PICTURE%
   IF .FIB[S$DTYP] EQL SV$DLIT THEN
        $DEMIT(DV$CNST,0,0,0,0)  %ZERO FP FOR A DATE%
   ELSE
    $DEMIT(DV$CNST,0,0,0,.P2);


   %NOW WORD 3....RELNAME AND FLDNAME%
   T_$DNAME(.FIB[S$STP1]);   %T NOW HAS LITERAL STO FOR NAME ENTRY%
   P_$SGSTE(.T);  %P HAS THE LITERAL INCARNATION ENTRY%
   RBASE_.P[S$DB];   %BASE INFO%
   RDISP_.P[S$DFO];  %OFFSET INFO%
   $SFRNCH(.P);  

    %RBASE,RDISP HAVE REL ADDRESS OF NAME%

    IF .FIB[S$RNSTP] EQL SV$NULL THEN
        S_LBASE_LDISP_0    %A SCALAR%
    ELSE
        BEGIN
        P_$SGSTE(.FIB[S$RNSTP])  ;  %P HAS RELATION INCARNATION ENTRY%
        S_.P[S$STP1]; %S POINTS TO REL NAME ENTRY%
        $SFRNCH(.P);  %FREE P%
        T_$DNAME(.S); %T POINTS TO LITERAL INCARNATION FOR RELNAME%
        P_$SGSTE(.T); %P HAS LITERAL INCARNATION%
        LBASE_.P[S$DB];
        LDISP_.P[S$DFO];
        $SFRNCH(.P);
        END;

   A[0]_.S^18 + .FIB[S$STP1];  %SYMBOL TABLE NAME POINTERS%
   A[1]_.LDISP ^18 + .RDISP;

   $DEM1W(DV$SET,.FIB[S$DDB],0,.FIB[S$DDFO]+2);
   $DEUCE(DBV$DDBASE);
   $DEMVW(DV$DRELB,.LBASE,.RBASE,0,A[0],2);


   %WORD 4..LEFT HALF POINTS TO NULL VALUE AND RIGHT HALF TO VERIFY CODE%
   T_.IEB[S$FDSTP];  %T POINTS TO FIELD DEF%
        P_$SGSTE(.T); %P HAS FIELD DEFINITION ENTRY%
        IF .P[S$VERFSTP] EQL SV$NULL THEN
           RBASE_RDISP_S_0 %NO VERIFY CODE..%
        ELSE
           BEGIN
           T_.P[S$VERFSTP];  %T POINTS TO LABEL ENTRY%
           $SFRNCH(.P);
           P_$SGSTE(.T);  %P HAS LABEL ENTRY BUFFER%
           RBASE_.P[S$DB];
           RDISP_.P[S$DFO];
           S_.P[S$STP1];
           END;
        $SFRNCH(.P);

   IF .FIB[S$NULL] EQL SV$NULL THEN
        LBASE_LDISP_R_0
   ELSE
        BEGIN
        T_.FIB[S$NULL]; %T POINTS TO LITERAL INCARNATION ENTRY%
        $DGLIE(.T,-1); %GET THAT LITERAL%
        LBASE_.DREGS$[DR$BASE,1];  %BASE%
        LDISP_.DREGS$[DR$OFFSET,1]; %OFFSET%
        R_.DREGS$[DR$STP1,1]; %NAME STP%
        END;
   A[0]_.R ^ 18 + .S;
   A[1] _ .LDISP ^ 18 + .RDISP ;
   $DEM1W(DV$SET,.FIB[S$DDB],0,.FIB[S$DDFO]+3);
   $DEUCE(DBV$DDBASE);
   $DEMVW(DV$DRELB,.LBASE,.RBASE,0,A[0],2);
   IF .FIB[S$DTYP] EQL SV$DLIT THEN
        BEGIN
        %EMIT A DATE TEMPLATE FOR THIS FIELD%
        $DEMIT(DV$CNST,0,0,0,.FIB[S$DTP]); %FIRST WORD%
        $DEMIT(DV$CNST,0,0,0,.(FIB[S$DTP])[1]); %SECOND WORD..2/7/75%
        END;

   $SFRNCH(.FIB);

   END;


UNDECLARE $DINIT;
GLOBAL ROUTINE $DINIT(FIB) =
   BEGIN
   %$DINIT GENERATES THE INITIALIZATION CODE FOR
   SCALAR FIELDS; THIS IS DONE IN THE FOLLOWING WAY:

        (1)WE CLEAR THE FOUR FLAGS THAT CONTROL INITIALIZATION,
        AND THEN WE LOOK TO SEE IF WE HAVE A REAL NULL VALUE
        OR THE DEFAULT (CASE I OR II, RESPECTIVELY);

        CASE I: WE FETCH THE ADDRESSS OF THE LITERAL WHOSE 
        VALUE IS THE NULL VALUE TO DREGS$[1]; AND THE ADDRESS
        OF THE SCALAR TO DREGS$[2]; IF LONGER THAN ONE WORD,
        FLAG 16 IS SET; IF THREE WORDS, FLAG 15 IS SET; AND IF
        LONGER THAN 3 WORDS, FLAG 17 IS SET (DO A BLT) AND 
        DREGS$[3] IS SET TO A DESTINATION ADDRESS FOR THE BLT;
        WE THEN CALL $DPCP FOR A "DTPV$INIT" AND RETURN.

        CASE II: WE FETCH THE SCALAR'S ADDRESS TO DREGS$[2],
        AND THEN DO THE FOLLOWING SUBCASES:

           IIA: 1 WORD; WE SET FLAG 14 (NUMERIC) AND CALL
                $DPCP TO PERFORM A $NULL(SHOULD GIVE A SETZM TAG);

           IIB: 2 WORDS; WE SET FLAG 14, AND FLAG 16(TWO WORDS OR
                MORE) AND CALL $DPCP, WHICH SHOULD GIVE S

                SETZM  TAG
                SETZM TAG+1

           IIC: STRING; WE FORCE DREGS$[4] TO POINT
                TO A WORD OF BLANKS; THEN COMPUTE T, WHICH IS
                THE NUMBER OF WORDS; IF T = 1, WE CALL $DPCP
                IMMEDIATELY; IF T= 2, SET FLG 16 AND CALL $DPCP;
                IF T= 3, SET FLAG 16 AND FLAG 15, AND CALL $DPCP;
                IF T > 3 , THEN SET DREGS$[3] TO A DESTINATION
                ADDRESS , SET FLAG 17 TO FORCE A BLT, AND CALL $DPCP



   WOW!!!
   /JS.........................6/8/74
   %
   LOCAL T;
   MAP S$ FIB;
   DFLAG$[0,#17]_DFLAG$[0,#16]_DFLAG$[0,#15]_DFLAG$[0,#14]_0;
   
   IF (.FIB[S$NULL] EQL SV$NULL ) OR (.FIB[S$NULL] EQL .SZERO$)
        OR (.FIB[S$NULL] EQL .SBLNK$) THEN
        BEGIN
        % NULL VALUES CALLED FOR%
        $DGFIE(.FIB[S$STPX],2);

        SELECT .FIB[S$DTYP] OF
           NSET

SV$SINGD:       BEGIN
                DFLAG$[0,#14]_1;
                $DPCP(DTPV$NULL);
                RETURN;
                END;

SV$DBLD:        BEGIN
                DFLAG$[0,#14]_1;
                DFLAG$[0,#16]_1;
                $DPCP(DTPV$NULL);
                RETURN;
                END;

SV$SLIT:        BEGIN
                DFLAG$[0,#14]_0;  %UNDO $DGFIE'S WORK%
                $DGSYL('     ',4); %FIVE BLANKS..DEFAULT FOR STRINGS%
                T_$DECANT(FIB[S$LCHAR]);
                IF .T EQL 2 THEN
                   DFLAG$[0,#16]_1
                ELSE IF .T EQL 3 THEN
                   BEGIN
                   %3 WORDS%
                   DFLAG$[0,#16]_1;
                   DFLAG$[0,#15]_1;
                   END

                ELSE IF .T GTR 3 THEN
                   BEGIN
                   %A BLT IS CALLED FOR%
                   DFLAG$[0,#17]_1;
                   $DGFIE(.FIB[S$STPX],1);
                   DREGS$[DR$BASE,3]_.DREGS$[DR$BASE,2];
                   DREGS$[DR$OFFSET,3]_.DREGS$[DR$OFFSET,2]+.T-1;
                   DREGS$[DR$STP1,3]_0;
                   DREGS$[DR$DDTYPE,3]_.DREGS$[DR$DDTYPE,2];
                   END;

                $DPCP(DTPV$NULL);

                RETURN;
                END;

           TESN;
        END
    ELSE
        BEGIN
        %A NON-TRIVIAL NULL VALUE...%
        $DGLIE(.FIB[S$NULL],1);  %SOURCE TO R 1%
        $DGFIE(.FIB[S$STPX],2); %DEST TO R2%
        SELECT .FIB[S$DTYP] OF
           NSET

SV$SINGD:       0;  %FOR EQUAL TIME REQUIREMENT%

SV$DBLD:        BEGIN
                DFLAG$[0,#16]_1;
                END;

SV$SLIT:        BEGIN
                T_$DECANT(FIB[S$LCHAR]);
                IF .T EQL 2 THEN
                   DFLAG$[0,#16]_1
                ELSE IF .T EQL 3 THEN
                   BEGIN
                   DFLAG$[0,#16]_1;
                   DFLAG$[0,#15]_1;
                   END

                ELSE IF .T GTR 3 THEN
                   BEGIN
                   DFLAG$[0,#17]_1;
                   DREGS$[DR$BASE,3]_.DREGS$[DR$BASE,2];
                   DREGS$[DR$OFFSET,3]_.DREGS$[DR$OFFSET,2]+.T-1;
                   DREGS$[DR$QP,3]_0;
                   DREGS$[DR$STP1,3]_0;
                   DREGS$[DR$DDTYPE,3]_DDV$1WD;
                   END;

                END; %SV$SLIT%
        
                TESN;

           $DPCP(DTPV$INIT);

        END;


   END;


UNDECLARE $DMKRB;

GLOBAL ROUTINE $DMKRB(RBI) = 

   BEGIN
   %$DMKRB...MAKE ONE EACH REPORT BLOCK, WHICH HAS BEEN DEFERRED
   UNTIL NOW SINCE IT PROBABLY HAS SOME
   PROGRAM LABELS IN IT..

   AGAIN, LIKE IN $DGSCB, WE EILL GIVE YOU A BLOW-BY-BLOW
   DESCRIPTION, RATHER THAN A LOT OF ELEGANT COMMENTS HERE..


   /JS....6/29/74
   %

   LOCAL RBD,NOM,P,LDB,LFO,LSTP,RDB,RFO,RSTP;
   MAP S$ RBI;
   MAP S$ RBD;
   MAP S$ NOM;
   MAP RBW$I P;
   LOCAL A[2];

   %GET THE DEFINITION ENTRY%
   RBD_$SGSTE(.RBI[S$RPDSTP]);

%WORD 0...STATUS AND BUFFER%
   P[RB$FLG1]_(IF .RBD[S$APND] THEN RBV$APPND ELSE 0);
   P[RB$FLG2]_0;
   P[RB$FLG3]_0;
   P[RB$FLG4]_RBV$FTF; %FIRST TIME FLAG%
   P[RB$FLG5]_0;
   P[RB$FLG6]_RBV$NPH; %NEEDS PAGE HEADER%
   P[RB$FLG7]_0;
   P[RB$FLG8]_0;
   P[RB$FLG9]_0;
   IF .RBI[S$TTYOUT] EQL SV$TRUE THEN
        P[RB$TYPE] _ RBV$TYPE
   ELSE P[RB$TYPE] _ RBV$PRINT;
   P[RB$BUFFER]_0;

   $DEM1W(DV$SET,DBV$RBBASE,0,.RBD[S$DFO]);
   $DEUCE(DBV$RBBASE);
   $DEMIT(DV$DRELR,0,0,.RBI[S$STP1],.P);

%WORD 1..FILE CONTROL BLOCK AND RELATION/SOURCE CONTROL BLOCK%
   P[RB$FCB]_0;
   IF .RBI[S$RSISTP] NEQ SV$NULL THEN
        BEGIN
        %CONTROLLED..FIND OUT BY WHOM%

        NOM_$SGSTE(.RBI[S$RSISTP]);
        RDB_.NOM[S$DB];
        P[RB$RCB]_.NOM[S$DFO];
        RSTP_.NOM[S$STP1];
        $SFRNCH(.NOM);
        END
    ELSE
        RDB_P[RB$RCB]_RSTP_0;

    $DEMIT(DV$DRELR,0,.RDB,.RSTP,.P);

%WORD 2..FILE NAME LENGTH AND ADDRESS%
    $DGRUB(.RBI[S$RPFSTP],1);
    P[RB$HDSZ] _ 0; %DEFAULT HEADER SIZE%
    P[RB$FID]_.DREGS$[DR$OFFSET,1];
    RDB_.DREGS$[DR$BASE,1];
    RSTP_.DREGS$[DR$STP1,1];
    $DEUCE(DBV$RBBASE);
   
    $DEMIT(DV$DRELR,0,.RDB,.RSTP,.P);

%WORD 3..LINE MAX AND CURRENT COLUMN%
    P[RB$LMAX]_RBV$LMAX; %INITIAL LINE MAX%
    P[RB$CCOL]_0;
   
    $DEMIT(DV$CNST,0,0,0,.P);

%WORD 4..PAGE DIVIDER AND PAGE NUMBER%
    P[RB$PDIV]_0;
    P[RB$PAGE]_1;

    $DEMIT(DV$CNST,0,0,0,.P);

%WORD 5..PAGE SIZE AND LINE NUMBER%
    P[RB$PGSZ]_66;
    P[RB$LINE]_0;

    $DEMIT(DV$CNST,0,0,0,.P);

%WORD 6..TOP MARGIN AND BOTTOM MARGIN%
    P[RB$TOPM]_P[RB$BOTM]_0;

    $DEMIT(DV$CNST,0,0,0,.P);

%WORD 7..FOOTING SIZE AND MOST RECENT RB%
    P[RB$FTSZ]_0;
 
    IF .DXLASTRB$ EQL -1 THEN
        RDB_P[RB$NEXT]_0
    ELSE
        BEGIN
        RDB_DBV$RBBASE;
        P[RB$NEXT]_.DXLASTRB$;
        END;

    $DEMIT(DV$DRELR,0,.RDB,0,.P);

    DXLASTRB$_.RBD[S$DFO];

%WORD 8..PAGE HEADING AND PPAGE FOOTING CODE%
    IF .RBI[S$PHL] NEQ SV$NULL THEN
        BEGIN
        %SOME PAGE HEADING CODE..SO GET IT%
        NOM_$SGSTE(.RBI[S$PHL]);
        LDB_.NOM[S$DB];
        LFO_.NOM[S$DFO];
        LSTP_.NOM[S$STP1];
        $SFRNCH(.NOM);
        END
    ELSE
        LDB_LFO_LSTP_0;

%TRY TO THINK OF WHERE YOU HAVE SEEN THE FOLLOWING CODE BEFORE..%

    IF .RBI[S$PFL] NEQ SV$NULL THEN
        BEGIN
        %SOME PAGE FOOTING CODE..SO GET IT%
        NOM_$SGSTE(.RBI[S$PFL]);
        RDB_.NOM[S$DB];
        RFO_.NOM[S$DFO];
        RSTP_.NOM[S$STP1];
        $SFRNCH(.NOM);
        END
     ELSE
        RDB_RFO_RSTP_0;

     A[0]_(.LSTP ^ 18) + .RSTP;
     A[1]_(.LFO ^ 18) + .RFO;

     $DEMVW(DV$DRELB,.LDB,.RDB,0,A[0],2);

%WORD 9..NAME OF SOURCE(AT LAST)%

     $DGLIE(.DXCRSTP$,1);
     LDB_.DREGS$[DR$BASE,1]; 
     LFO_.DREGS$[DR$OFFSET,1];
     NOM_$SGSTE($DNAME(.RBI[S$STP1]));
     RDB_.NOM[S$DB];
     RFO_.NOM[S$DFO];
     RSTP_.NOM[S$STP1];
     $SFRNCH(.NOM);

     $DEUCE(DBV$RBBASE);
     A[0]_.RSTP;
     A[1]_.LFO^18+.RFO;
     $DEMVW(DV$DRELB,.LDB,.RDB,0,A[0],2);

%WORD 10..LINE CONTROL BLOCKS%

        $DEUCE(DBV$RBBASE);
        $DEMIT(DV$CNST,0,0,0,0);

%STAY TUNED FOR OUR "HEADING HOME SHOW", WHICH FOLLOWS NEXT%

     $SFRNCH(.RBD);

     END;


UNDECLARE $DEFER;
GLOBAL ROUTINE $DEFER  =
   BEGIN
   %$DEFER DISPATCHES DEFER ITEMS...MORE TO FOOLOW%

    LOCAL STP,P;

   MAP S$ P;

   %WE WILL NOW GENERATE THE FIXUP THAT  MAKES THE JRST,I
   THAT WE EMITTED IN DIME.. WORK%
   $DEM1W(DV$SET,DBV$LITBASE,0,.DXBACK$);
   $DEUCE(DBV$LITBASE);
   $DEMIT(DV$DRELR,0,DBV$PROGBASE,0,.DBASE$[DBV$PROGBASE]);
   $DEM1W(DV$SET,DBV$LITBASE,0,.DBASE$[DBV$LITBASE]);

   INCR I FROM 0 TO .DXDFRCT$-1 DO
        BEGIN
        STP_.DEFER$[.I] AND #777777;
        P_$SGSTE(.STP);
        IF .P[S$TYPE] EQL SV$ITEM THEN
           $DMKDD(.P, (.DEFER$[.I] ^ (-18)) AND #777777)
        ELSE IF .P[S$TYPE] EQL SV$FLDINC THEN
           $DINIT(.P)
    ELSE IF .P[S$TYPE] EQL SV$REPTINC THEN
        $DMKRB(.P);   %MAKE AN RB%
    $SFRNCH(.P);

        END;

    %FIX UP THE FIRST WORD OF THE PDB SO THAT RBNEXT IS CORRECT%
    IF .DXLASTRB$ NEQ -1 THEN
        BEGIN
        $DEM1W(DV$SET,DBV$PROCBASE,0,0); %WORD 1%
        $DEUCE(DBV$PROCBASE);
        DXPDBWD$_.DXPDBWD$ + (.DXLASTRB$ AND #777777);
        $DEMIT(DV$DRELR,0,DBV$RBBASE,0,.DXPDBWD$);
        $DEM1W(DV$SET,DBV$PROCBASE,0,.DBASE$[DBV$PROCBASE]);
        END;  %NO NEED TO DO THIS, IF NO RB'S..ALREADY SET TO 0 IN DIME%

    %NOW EMIT THE JUMP THAT TAKES US BACK TO PROC HEAD%
    DREGS$[DR$BASE,1]_DBV$PROGBASE;
    DREGS$[DR$OFFSET,1]_.DXWHERE$;
    DREGS$[DR$STP1,1]_0;
    DREGS$[DR$DDTYPE,1]_DDV$1WD;
    $DPCP(DTPV$BRNCH);

    END;

UNDECLARE $DINSC;
GLOBAL ROUTINE $DINSC(STP1,VAL)=
   BEGIN
   %PROCESS ONE EACH GV$INIT
        THIS IS DONE BY MAKING A LITERAL OUT OF VAL
        AND ATTACHING IT TO THE FI AS A NULL VALUE

   .JS................................9/23/74
   %

   LOCAL STP2,P;
   MAP S$ P;

   P_$SGSTE(.STP1);
   IF .P[S$DTYP] EQL SV$SINGD THEN
        STP2_$DMKL1(.P[S$INTD],.P[S$DECD],.VAL)
   ELSE IF .P[S$DTYP] EQL SV$SLIT THEN
        STP2_$DMKST(.P[S$LCHAR],.VAL);

   P[S$NULL]_.STP2;
   $SFRCH(.P);

   %NOW FORCE THE INIT CALL%
   $DGFIE(.STP1,1);

   END;


%*******************%
END ELUDOM
    