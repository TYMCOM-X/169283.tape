TITLE SLIB -- COEES LIBRARY -- DAVE ORTIZ
	SALL
	ENTRY	TRU,WAIT,     GETC,PUTC,      FILINF

        IFNDEF F40,<F40==0>     ;IF BEING USED FOR LIB40  THE SYMBOL
                                ; F40 MUST BE DEFINED:  F40==1
                                ;THIS MODIFIES THE ENTRY POINT
                                ;AND THE RETURN METHOD.


	DEFINE	SAVEM	<
        IFN F40,<Z>
        MOVEM   R17, SVR17
        MOVEI   R17, SVR0
        BLT     R17, SVR16
        >

	OPDEF	THREAD	[001000000000]	;; STRING UUO.

	DEFINE	NP(X) <SUBTTL X
	PAGE >

R0==0
R1==1
R2==2
R3==3
R4==4
R5==5
R6==6
R7==7
R8==8
R10=10
R11==11
R12==12
R13==13
R14==14
R15==15
R16==16
R17==17

TABLE:	POINT	7,0,6	; CHARACTER 0
	POINT	7,0,13	; CHARACTER 1
	POINT	7,0,20	; CHARACTER 2
	POINT	7,0,27	; CHARACTER 3
	POINT	7,0,34	; CHARACTER 4

;
; ****    REGISTER SAVE AREA BLOCK    ****
;
SVR0:	BLOCK	1
SVR1:	BLOCK	1
SVR2:	BLOCK	1
SVR3:	BLOCK	1
SVR4:	BLOCK	1
SVR5:	BLOCK	1
SVR6:	BLOCK	1
SVR7:	BLOCK	1
SVR10:	BLOCK	1
SVR11:	BLOCK	1
SVR12:	BLOCK	1
SVR13:	BLOCK	1
SVR14:	BLOCK	1
SVR15:	BLOCK	1
SVR16:	BLOCK	1
SVR17:	BLOCK	1

;
; **** RETURN TO CALLER AFTER RESTORING AC'S ****
;
RT:     MOVSI   R17, SVR0
        BLT     R17, R17
        IFE F40,<POPJ  R17,>
        IFN F40,<JRA   R16, (R16)>

	NP(TRU FUNCTION)
;
; FUNCTION 	TRU(X)
;
;  RETURNS NUMBER OF TRU'S EXPENDED SINCE LOGIN, AS A REAL
;  NUMBER ACCURATE TO .01 TRU
;
TRU:	SAVEM		; SAVE AWAY THE REGS.
	MOVE	R1,[-1,,4]	; CODE FOR CURRENT JOB,,TTIME.
	GETTAB	R1,		; DO THE GETTAB.
	MOVEI	R1,		; **THIS IS THE ERROR RETURN**
	FSC	R1,233		; FLOAT IT, TRUSTING DEC'S WORD.
	FDVR	R1,[^D10000.0]	; ADJUST IT, SINCE THE UUO RETURNS
	MOVEM	R1,SVR0		; TRU'S*10**4
	JRST	RT		; RETURN

	NP(WAIT SUBROUTINE)
;
; SUBROUTINE WAIT(X)
;
;  RETURNS AFTER X SECONDS HAVE ELAPSED. X IS A REAL NUMBER
;  BETWEEN 0 AND 20 MINUTES. VALUES OUTSIDE THIS RANGE CAUSE
;  AN IMMEDIATE RETURN.
;
WAIT: XWAIT:	SAVEM
	MOVE	R2,@(16)		; GET X
	JUMPLE	R2,RT			; X <= 0 -- RETURN.
	FMP	R2,[^D1000.0]	; GET MILLISECONDS FOR HIBER UUO.
	FIX	R2,		; UNFOLOAT IT.
	CAMLE	R2,MAXTIM	; TIME MUST BE < SOME MAXIMUM.
	JRST	RT			; ELSE ELSE QUICK TRIP RETURN.
	HIBER	R2,		; SZOOZE A WHILE.
	HALT				; *ERROR RETURN*
	JRST	RT

MAXTIM:	EXP	^D60*^D1000*^D20	; TWENTY MIN. IN MILLISECS.

	NP(GETC SUBROUTINE)
;
; SUBROUTINE GETC(I,J,K)
;
;  RETURNS IN K THE I'TH CHARACTER OF THE HOLLERITH ARRAY
;  J, WHERE K IS TO BE RIGHT JUSTIFIED.
;
;  **SPECIFIED BY COEES -- NO ERROR MESSAGES!**
;
GETC:	SAVEM			;

	MOVE	R1,@(R16)	; GET CHAR. POSITION.
	SKIPG	R1		; IF > 0, OK.
	JRST	RT		; IF <= 0, GO AWAY QUIETLY.

	MOVEI	R3,@1(R16)	; ADDR OF ARRAY.
	MOVEI	R4,@2(R16)	; ADDR OF K.

	SOS	R1		; DECREMENT R1
	IDIVI	R1,5		; AND BUILD BYTE POINTER TO
	IOR	R3,TABLE(R2)	; COORECT BYTE IN THE THING.
	ADD	R3,R1

	LDB	R0,R3		; GOT IT!
	MOVEM	R0,(R4)		; PUT IT!

	JRST	RT		; ALL DONE.

	NP(PUTC SUBROUTINE)
;
;  SUBROUTINE PUTC(I,J,K)
;
;   A SUBROUTINE LIKE UNTO GETC, BUT PLACES THE RIGHT-JUSTIFIED
;   CHARACTER WHICH IS IN K, IN THE I'TH POSITION OF THE
;   HOLLERITH ARRAY J.
;
PUTC:	SAVEM			;
	MOVE	R1,@(R16)	; GET CHAR. POSITION.
	SKIPG	R1		; ERROR CHECK.
	JRST	RT
	MOVEI	R3,@1(R16)	; ADDR OF THE ARRAY.
	MOVE	R4,@2(R16)	; GET R-J CHARACTER.

	SOS	R1		; START TO BUILD BYTE POINTER
	IDIVI	R1,5		; TO CORRECT CHARACTER.
	IOR	R3,TABLE(R2)
	ADD	R3,R1

	DPB	R4,R3

	JRST	RT		; ALL DONE.


	NP(BYE SUBROUTINE)
;
;  SUBROUTINE BYE
;    PERFORMS A RUN UUO ON SYS:LOGOUT WITH AN INCREMENT OF
;    1.
;       NOTE THAT THIS IS THE SAME AS THE F40/LIB40 LOGOUT ROUTINE.

	ENTRY	BYE

BYE:    IFN F40,<Z>
    	MOVSI	R1,1		; START ADDR INCREMENT.
	HRRI	R1,BYEBLK		; SET UP TO
	RUN	R1,			; RUN,RUN,RUN.
	HALT				; ERROR RETURN.

BYEBLK:	SIXBIT/SYS/	; USE SYS, NOT DSK.
	SIXBIT/LOGOUT/
	Z
	Z
	Z
	Z


	NP(FILINF SUBROUTINE)
;
; SUBROUTINE FILINF(FILE,IPROT,IERR)
;
;  FILE IS AN INPUT STRING OF 25 CHARACTERS OR LESS,FOR WHICH
;  THE INFORMATION IS DESIRED. IPROT IS A THREE WORD ARRAY
;  WHICH IS TO CONTAIN THE PRIVATE PROTECTION INFO IN ELEMENT 1,
;  THE ACCOUNT INFO IN ELEMENT 2 AND THE PUBLIC INFO IN ELEMENT
;  3.THE STANDARD DEC PROTECTION CODES WILL BE RETURNED.
;  IERR VALUES:
; 	0 -	NO ERRORS.
;	1 -	BAD FILENAME CONSTRUCTION.
;	2 -	SYSTEM ERROR.
;	3 -	FILE NOT FOUND.
;		   A.) NO FILE.
;		   B.) NO USER.
;		   C.) UFD PROTECTED.
;	4 -	FILE NOT RENAMED.
;	5 - 	FILE NOT DELETED DUE TO PROTECTION FAILURE.
;
;  NEEDLES TO SAY,(BUT I'LL SAY IT ANYHOO) SOME OTHER FILE
;  MASSAGING ROUTINES RETURN AN IERR CODE, ACCORDING TO THE
;  ABOVE DESCRIPTION OF IERR.
;
;
FILINF:	SAVEM



	MOVEI	@2(R16)			; ADDR OF ERR VARIABLE.
	MOVEM	IERR		; KEEP HERE.
	SETZM	@IERR		; CLEAR IT.
	MOVEI	@1(R16)		; ADDR OF CALLER'S 3 WD.ARRAY.
	MOVEM	IPROT#		; SAVE AWAY.

	MOVE	(R16)		; GET ADDR OF ARRAY OR STRNGPOINTER.
	MOVEM	AFILE		; STORE AWAY FOR ROUTINE GFN.


	JSP	R17,GFN		; GET FILE NAME.



GFGO:	JSP	R17,FCHNL	; FIND A CHANNEL IN R2.
	JRST	FERR6		; *ERROR RETURN*
	JSP	R17,CKFN	; CHECK FILENAME & SET IT UP.

	JSP	17,SETUP	; MOVE ARG BLOCK TO 'LOOKUP' ARG BLOCK.
	XCT	OPENER(R2)	; ISS YOU READY, FOLKS?
	JRST	FIOPNR		; *ERROR RETURN*

	XCT	LOOK(R2)	; AND FOR MY NEXT TRICK.....
	JRST	FILKPR		; *ERROR RETURN*

	MOVE	R3,IPROT	; ADDR OF USER'S ARRAY TO SET.
	MOVE	R1,[POINT 3,LKUP+2, ] ; TO GET PROTEXION CODES.
	ILDB	R1		; PRIVATE.
	MOVEM	(R3)
	ILDB	R1		; PROJECT.
	MOVEM	1(R3)
	ILDB	R1
	MOVEM	2(R3)		; PUBLIC.

	XCT	RELSE(R2)	; ALL RIGHT,NOW.
	JRST	RT

	NP(FILINF ROUTINES.)
; FCHNL IS THE CHANNEL-FINDER. IT FINDS ONE AND, IF THERE
; IS ONE, RETURNS IT IN R2.
; HERE WE GO.
FCHNL:	MOVEI	R2,1		; START WITH 1.
	CAMLE	R2,JOBHCU##	; IF LOW, DO FUTHER CHECKING.
	JRST	.+3
	SKIPE	JOBJDA##(R2)	; C IF IT'S FREE.
	AOJA	R2,.-3		; NOPE -- TRY NOTHER ONE.
	CAIG	R2,17		; HIGHEST USABLE IS 17.
	JRST	1(R17)		; NORMAL RETURN.
	JRST	(R17)		; GIFS ERRORS.





SETUP:	MOVE	[ITCH,,LKUP]	; COPY FROM SCRATCH AREA TO
	BLT	LKUP+3		; LOOKUP ARG BLOCK.
	JRST	(R17)		; DONE.


; OPNDEF -- CREATE A 'DEFAULT' OPEN ARG BLOCK
; DEVICE DSK, STATUS WORD 0.
;
OPNDEF:	SETZM	IBUF		; FORST, CLEAR THE BUFFER HEADERS.
	MOVE	[IBUF,,IBUF+1]	; .
	BLT	OBUF+2		; .
	SETZM	OPNBLK		; CLEAR STATUS WORD.
	MOVE	[SIXBIT/DSK/]	; SET DEFAULT DEVICE.
	MOVEM	OPNBLK+1
	MOVE	[OBUF,,IBUF]
	MOVEM	OPNBLK+2
	JRST	(R17)		; ALL DONE.



; GETTERM RETURNS IN R0 THE NEXT TERMINATOR IN THE IDFILE
; CHARACTER STRING. A TERMINATOR IS '(' OR ')' OR '.' OR ':'
; OR EOLIT.
;
GETTERM:	;
GT1:	ILDB	GNOFPD		; GET A CHARACTER.
	JUMPE	(R17)		; EOLIT -- RETURN
	CAIN	"("
	JRST	(R17)		; LEFT PAREN -- RETURN.
	CAIN	")"
	JRST	(R17)		; RIGHT PAREN -- RETURN.
	CAIN	":"
	JRST	(R17)		; COLON IS A TERMINATOR TOO.
	CAIN	"."
	JRST	(R17)		; PERIOD.
	JRST	GT1		; LOOK AGAIN.




; COLLECT 
; PICKS UP ASCII CHARACTERS , CVRTING THEM TO SIXBIT
; AND STORING THE SIXBIT CHARACTERS IN R4-R5 REGISTER
; PAIR. DOES THIS UNTIL A TERMINATOR IS FOUND.
;
COLLECT:	;
	MOVEI	R4,		; FIRST, CLEAR AC PAIR.
	MOVEI	R5,
	MOVE	R7,[POINT 6,R4, ] ; FOR STICKING SIXBITS IN.
COL0:	MOVEI	R10,0		; FOR HANDLING TERMINATORS.

COL1:	ILDB	GNOFP		; GET A CHARACTER.
	CAIN	"("		; IF WE HAVE A TERMINATOR,RETURN
	JRST	COL2		; WITHOUT INCREMENTING THE POINTER.
	CAIN	")"		; THIS IS SO THAT GETTERM WILL
	JRST	COL2		; FIND IT THE NEXT TIME IT IS
	CAIN	":"		; CALLED UPON TO FIND A TERMINATOR.
	JRST	COL2
	CAIN	"."
	JRST	COL2
	JUMPE	COL2		; (EOLIT)

	SUBI	40		; CONVERT TO SIXBIT
	IDPB	R7		; AND PLACE IN DESTINATION.
	AOJA	R10,COL1	; LOOK AGAIN.

COL2:	JUMPE	(R17)		; IF EOLIT OR BLANK,STOP COLLECTING.
	CAIN	" "
	JRST	(R17)
	JUMPE	R10,COL1	; IF TERMINATOR FOUND B4 COLLECTING,GET THEM OUT OF THE WAY,
	JRST	(R17)		; ELSE RETURN CUZ WE HAV SUMTHING.

;  GFN --
;    'GET FILE NAME ' ROUTINE. GETS A           HOLLERITH FILE
;    NAME AND MOVES IT INTO LOCATION 'IDFILE'. 
;  INPUTS --
;    LOCATION 'AFILE' SHOULD CONTAIN THE WORD FROM THE ARG
;    BLOCK WHICH HAS EITHER THE ADDRESS OF THE HOLERITH ARRAY
;    OR THE ADDRESS OF THE STRING POINTER.
;    LOCATION 'EXPNO' SHOULD CONTAIN THE STRING STACK EXPRESSION
;    NUMBER (I.E. 1=LATEST ENTRY, 2 = NEXT, ETC).
;
GFN:	MOVEM	R17,GFN1#	; SAVE RETUNR ADDR.
	MOVE	[POINT 7,IDFILE, ]
	MOVEM	GNOFP		; SET UP POINTER TO IDFILE.
	LDB	[POINT 4,AFILE,12] ; GET TYPE OF FILE NAME.

	MOVEI	@AFILE		; ADDR OF HOLLERITH ARRAY.
	MOVS
	HRRI	IDFILE
	BLT	IDFILE+4	; MOVE HOLLERITH ARRAY TO IDFILE.


	JRST	@GFN1		; RETURN.
;
;
; RDTMP ---
;   READS THE FIRST BLOCK OF THE FILE LOG##.TMP,
;   WHERE ## IS THE JOB NUMBER. READS THE FIRST FOUR WORDS INTO
;   LOCATIONS TMPINF TO TMPINF+3. THEN RETURNS.
;   FOR ERROR CONDITIONS,A CONSELE MESSAGE IS PRINTED AND A RETURN
;   IA MADE TO THE GLOBAL CALLING ROUTINE.
;
RDTMP:	MOVEM	R17,RDTM#	; SAVE LINK REGISTER.
	PJOB	R1,		; GET JOB NUMBER IN AC 1.
	IDIVI	R1,^D10		; CREATE 2-DIGIT SIXBIT REPRESENTATION OF JOB NR.
	LSH	R1,^D12
	LSH	R2,6
	IOR	R1,R2
	IOR	R1,[SIXBIT/LOG00/]
	MOVEM	R1,FTMP

	SETZM	FTMP+2
	SETZM	FTMP+3


	JSP	R17,FCHNL	; FIND A CHANNEL.
	JRST	TNCH		; *ERROR RETURN*

	XCT	INITS(R2)		; PERFORM INIT UUO.
	SIXBIT/DSK/
	0
	JRST	TOPNR		; *ERR RET *

	MOVE	[FTMP,,LKUP]	; MOVE TEMP BLK TO LKUP BLK.
	BLT	LKUP+3
	XCT	LOOK(R2)		; DO LOOKUP.
	JRST	TLKPR		; *ERR RET*

	XCT	INNER(R2)	; IN UUO.
	JRST	RDT1		; NORMAL RETURN.
	OUTSTR	[ASCIZ/INPUT ERR FOR LOG##.TMP - CALL IGNORED./]
	JRST	RLRT		; RELSE & RETURN TO CALLER(CALLER)

RDT1:	XCT	RELSE(R2)	; FREE UP.
	JRST	@RDTM		; RETURN.

TOPNR:	OUTSTR	[ASCIZ/CANNOT OPEN DSK IN RDTMP./]
	JRST	RLRT

TLKPR:	OUTSTR	[ASCIZ/CANNOT FIND LOG##.TMP FILE./]
	JRST	RLRT

TNCH:	OUTSTR	[ASCIZ/OUT OF CHANNELS IN RDTMP./]
	JRST	RT



; CKFN
; CHECK FILE NAME AND IF IT IS NOT VALID, SET THE APPROPRIATE
; ERROR AND RETURN TO THE CALLER OF THE MAJOR ROUTINE.
; OTHERWISE, SET UP OPEN AND LOOKUP ARG BLOCK BASED ON
; THE INFORMATION.
;
CKFN:	MOVEM	R17,CKFN1#	; SAVE RETURN ADDRESS.
	JSP	R17,OPNDEF	; CREATE DEFAULT OPEN ARG BLK.
	MOVE	[POINT 7,IDFILE, ]
	MOVEM	GNOFP		; SET UP FILENAME BYT POINTER.
	MOVEM	GNOFPD		; SAME FOR GETTERM'S COPY.

	SETZM	DEVFLG#		; CLEAR FLAGS.
	SETZM	UNMFLG#
	SETZM	EXTFLG#
	SETZM	ITCH		; CLEAR ALL OF ARG BLOCK.
	SETZM	ITCH+1
	SETZM	ITCH+2
	SETZM	ITCH+3		; CLEAR PPN AREA OF ARG BLK.


VFN1:	JSP	R17,GETTERM	; PICK UP A TERMINATOR.
	CAIE	":"		; IF COLON, THEY SPECIFIED DEVICE.
	JRST	VFN2		; IF NOT, CHECK NEXT ONE.
	SKIPE	DEVFLG		; IF WE'VE PROCESSED A DEVICE THING BEFORE,...
	JRST	FERR1		; KILL!
	JSP	R17,COLLECT	; GET THE USER SPEC.
	MOVEM	R4,OPNBLK+1	; AND SET IT.
	SETOM	DEVFLG		; SO WE WON'T DO IT AGAIN.
	JRST	VFN1		; ON AND ON....

VFN2:	CAIE	"("		; SEE IF IT'S A USERNAME.
	JRST	VFN3		; IF NOT... CK NEXXT.
	SKIPE	UNMFLG		; HAVE WE BEEN HERE BEFORE?
	JRST	FERR1		; IF SO, KILL.
	SETOM	UNMFLG		; SET IT .
	MOVEI	UNAM		; SINCE WE HAVE A USERNAME,
	MOVEM	ITCH+3		; SET UP ARG BLOCK ACCORDINGLY.
	JSP	R17,COLLECT	; GET IT.
	MOVEM	R4,UNAM	; PUT IT.
	MOVEM	R5,UNAM+1
	JSP	R17,GETTERM	; NEXT ONE HAS TO BE ")" OR ELSE.
	CAIE	")"
	JRST	FERR1
	JRST	VFN1		; IF SUCCESSFUL.

VFN3:	CAIE	"."		; SEE IF THEY HAVE AN EXT.
	JRST	VFN4		; NO -- CAN ONLY BE FILENAME.
	SKIPE	EXTFLG		; IF PREVIOUS EXT, GIVE THE AX.
	JRST	FERR1
	SETOM	EXTFLG		; SET IT.
	JSP	R17,COLLECT	; GET IT.
	MOVEM	R4,FNAME
	JSP	R17,COLLECT	; GET EXTENSION
	MOVEM	R4,EXT
	JRST	VFN5

VFN4:	JUMPN	FERR1		; TERMINATOR NUST BE EOLIT.
	JSP	R17,COLLECT	; CAN ONLY BE FILENAME.
	MOVEM	R4,FNAME

VFN5=	.
	JRST	@CKFN1		; RETURN.


; FIOPNR -- 'FILINF OPEN ERROR'
FIOPNR:	OUTSTR	FINFX
	JRST	RT

FINFX:	ASCIZ/OPEN ERROR IN FILINF,RENAME,OR DELETE - CALL IGNORED./

; FILKPR -- 'FILINF LOOKUP ERROR'
FILKPR:	HRRE	R1,LKUP+1	; GET ERROR NUMBER.
	MOVE	ERRTAB(R1)	; GET IERR CODE THAT CORRESPONDS.
	JRST	ERRSET

FERR1:	MOVEI	1
	JRST	ERRSET
FERR2:	MOVEI	2
	JRST	ERRSET
FERR3:	MOVEI	3
	JRST	ERRSET
FERR4:	MOVEI	4
	JRST	ERRSET
FERR5:	MOVEI	5
	JRST	ERRSET
FERR6:	MOVEI	6

ERRSET:	MOVEM	@IERR		; SET CALLER'S ERROR THING.
RLRT:	XCT	RELSE(R2)	; FREE UP THE CHANNEL.
	JRST	RT		; ALL OVER.

DEFINE XX(OPCODE,ADDR,AC)<IRP AC<OPCODE AC,ADDR>>

OPENER:	XX<OPEN>,<OPNBLK>,<0,1,2,3,4,5,6,7,10,11,12,13,14,15,16,17>
INNER:	XX<IN>,<IBLK>,<0,1,2,3,4,5,6,7,10,11,12,13,14,15,16,17>
RELSE:	XX<RELEASE>,<0>,<0,1,2,3,4,5,6,7,10,11,12,13,14,15,16,17>

LOOK:	XX<LOOKUP>,<LKUP>,<0,1,2,3,4,5,6,7,10,11,12,13,14,15,16,17>
ENTERS:	XX<ENTER>,<LKUP>,<0,1,2,3,4,5,6,7,10,11,12,13,14,15,16,17>
OUTER:	XX<OUTPUT>,<OBUF>,<0,1,2,3,4,5,6,7,10,11,12,13,14,15,16,17>
CLOSE0:	XX<CLOSE>,<0>,<0,1,2,3,4,5,6,7,10,11,12,13,14,15,16,17>
RENA:	XX<RENAME>,<LKUP>,<0,1,2,3,4,5,6,7,10,11,12,13,14,15,16,17>
INITS:	XX<INIT>,<16>,<0,1,2,3,4,5,6,7,10,11,12,13,14,15,16,17>

IBLK:	IOWD	4,TMPINF
	0

TMPINF:	BLOCK	4
CPFN:	Z
GNOFP:	Z
GNOFPD:	Z
EXPNO:	Z
AFILE:	Z
IERR:	Z
UNAM:	BLOCK	2
P1:	BLOCK	3
FTMP:	SIXBIT/LOG##/
	SIXBIT/TMP/
	Z
	Z
SCRA:	BLOCK	4
IDFILE:	BLOCK	5
	Z
OPNBLK:	Z
	Z
	OBUF,,IBUF
ITCH: FNAME:	Z
EXT:		Z
		Z
		Z
LKUP:	BLOCK	4
ERRTAB:	EXP	3,1,3,0,0,0,2,0,0,0,0,0,2,3,2,2,2,0,0,3,2,2,2,0
IBUF:	BLOCK	3
OBUF:	BLOCK	3

	NP(DELETE SUBPROGRAM)
;
;  SUBROUTINE DELET(FILE,IERR)
;
;    FILE   IS A H-ARRAY OF 25 CHARACTERS OR LESS CONTAINING THE
;    NAME OF A FILE TO BE DELETD. IERR IS AN INTEGER ERROR CODE
;    WHICH IS SET IF THE FILE CANNOT BE DELETD.(ZERO IF THE
;    FILE WAS DELETD.)
;
	ENTRY	DELET

DELET:	SAVEM

	MOVEI	@1(R16)		; ADDR OF IERR.
	MOVEM	IERR		; STASH.
	SETZM	@IERR		; ZERO OUT.

	MOVE	(R16)		; SET 'AFILE' FOR GFN ROUTINE.
	MOVEM	AFILE

	JSP	R17,GFN		; GET THE FILE NAME.

	JSP	R17,FCHNL	; FIND A CHANNEL.
	JRST	FERR6		; **ERROR RETURN**

	JSP	R17,CKFN	; CHECK FILE NAME, STORE IN LKUP BLK.

	JSP	R17,SETUP
	XCT	OPENER(R2)	; OPEN.
	JRST	FIOPNR		; **ERROR RETURN**

	XCT	ENTERS(R2)	; DO AN ENTER.
	JRST	FILKPR		; **ERROR RETURN**

	SETZM	LKUP		; ZERO OUT FILENAME FOR DELETION.
	MOVEI	[LKUP,,LKUP+1]
	BLT	LKUP+3

	XCT	RENA(R2)	; DELETE.
	JRST	FERR5		; **ERROR, FILE NOT DELETED**

	XCT	RELSE(R2)	; FREE UP.
	JRST	RT		; DONE.

	NP(RENAME SUBROUTINE)
;
; SUBROUTINE RENAM(OLD,NEW,IERR)
;
;    OLD AND NEW FILE NAMES ARE CONTAINED IN 'OLD' AND 'NEW',
;    RESPECTIVELY, WHICH ARE STRINGS OF 25 CHARACTERS OR LESS.
;    IERR IS SET AS DESCRIBED IN THE COMMENTS FOR FILINF.
;
	ENTRY	RENAM
RENAM: XRENAM:	SAVEM

	MOVE	(R16)		; GET OLD FILE NAME REF.
	MOVEM	AFILE		; WILL BE OUR FIRST REF.
	MOVE	1(R16)		; GET NEW FILE NAME REF.
	MOVEM	BFILE#		; SAVE IT FOR LATER USE.
	MOVEI	@2(R16)		; ADDR OF ERR VARIABLE.
	MOVEM	IERR
	SETZM	@IERR


	JSP	R17,GFN		; GET THE FILE NAME.
	JSP	R17,FCHNL	; FIND A CHANNEL.
	JRST	FERR6		; **ERROR RETURN**
	JSP	R17,CKFN	; CK FILE NAME & SET UP ARG BLK.
	JSP	R17,SETUP

	XCT	OPENER(R2)	; OPEN.
	JRST	FIOPNR		; *ERROR RETURN*

	XCT	ENTERS(R2)	; ISSUE ENTER UUO.
	JRST	FILKPR		; **ERROR RETURN**
	MOVEM	R2,CHAN#	; SAVE CHANNEL (CKFN NEEDS R2)

	MOVE	BFILE		; NOW SET UP FOR NEW FILE NAME.
	MOVEM	AFILE

	JSP	R17,GFN
	JSP	R17,CKFN	; GET NAME, CJECK VALIDITY.

	MOVE	R2,CHAN		; GET OUR CHANNEL BACK.
	XCT	RENA(R2)	; HERE IT ISS FOLKS.
	JRST	FERR4		; *ERROR RETURN**

	XCT	RELSE(R2)
	JRST	RT		; DONE.

	NP(CONNECT FUNCTION)
;
;  FUNCTION CONNECT(X)
;    RETURNS THE TOTAL EXPENDED CONNECT TIME SINCE LOGIN,
;    ACCURATE TO THE NEAREST SECOND.
;
	ENTRY	CONNECT

CONNEC:	SAVEM
	JSP	R17,RDTMP	; BRING IN THE LOGIN TIME.
	MSTIME	R0,		; CURRENT TOD IN MILLISECS.
	IDIVI	^D1000		; CURRENT TOD IN SECONDS.
	DATE	R1,		; CURRENT 12-BIT DATE.
	HLRZ	R2,TMPINF+3	; 'THEN' DATE.
	SUB	R1,R2		; DAYS DIFFERENCE
	IMUL	R1,DAYSEC	; IN SECONDS.
	ADD	R0,R1		; + CURRENT TOD
	HRRZ	R1,TMPINF+3	; 'THEN' LOGIN TIME.
	SUB	R1		; DIFF IN SECONDS
	FSC	233		; FLOAT IT.
	MOVEM	SVR0		; FOR FCN VALUE.
	JRST	RT		; ALL DONE.
DAYSEC:	EXP	^D3600*^D24	; 1 DAY IN SECONDS.

	NP(NEXIT SUBROUTINE)
;  SUBROUTINE NEXIT
;    EXITS THE USER TO THE MONITOR WITHOUT THE PRINTING OF
;    THE WORD 'EXIT' BY THE MONITOR.
;
	ENTRY	NEXIT

NEXIT:  IFN F40,<Z>
	EXIT	1,

	END
