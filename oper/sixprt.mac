	TITLE	SIXPRT	- PRINTS A SIXBIT FILE
	ENTRY	SIXPRT
;
JOBVER=137
LOC 137
VERWHO==0
VERVER==2
VERUPD==3
VERPAT==0
BYTE (3)VERWHO(9)VERVER(6)VERUPD(18)VERPAT

INTERN PURE,JOBVER
EXTERN JOBSA,JOBFF,JOBREL

IFNDEF PURE,<PURE==1>
IFN PURE,<HISEG>
IFE PURE,<RELOC>	;START NON-REENTRANT CODE AT RELOC
;
;
PPN=14
POINT=13
COUNT=12
NAME=11
FLAGS=1
CHAR=2
CLNFND=400000
PERFND=200000
ARRFND=100000
LFTFND=40000
RHTFND=20000
COMFND=10000
FNDPPN=4000
NEED=400000	;RIGHT HALF OF FLAGS - FLAGS IF NNED SPACER ON HEADERS
WRDS=3
ASC=4
Q=16		;JSP REGISTER
PSIZE=100
P=17		;PUSHJ REGISTER
CH1=1
CH2=2
;
T1=5
T2=6
T3=7
T4=10
T5=11
T6=12
T7=13		;THESE ARE USED ONLY WHEN CREATING BUFFERS
T8=14
;
; COUNTERS FOR SIXPRT TYPE OUTPUT
;
LCNT=13		;COUNTS LINES PER PAGE
PGLIM=^D59	;59 LINES PER PAGE
IFN PURE,<LOW=15>		;NON ZERO OFFSET IF HISEG
IFE PURE,<LOW=0>		;ZERO OFFSET IF NO HISEG
;
;
SIXPRT:	IFN	PURE,<
	MOVE	LOW,JOBFF	;STORE OFFSET IN LOW
	MOVE	1,JOBFF		;OBTAIN OLD FIRST FREE LOCATION
	ADDI	1,LOWSIZ	;SET FIRST FREE LOC PAST LOWSIZ
	HRLM	1,JOBSA		;RESET RESETS JOBFF FROM L H OF JOBSA
	>
	RESET
	IFN	PURE,<
	MOVE	1,JOBFF		;ASSIGN AT LEAST ENOUGH CORE FOR DATA
	CAMGE	1,JOBREL	;IS THIS LESS THAN CURRENT CORE?
	JRST	HAVCOR		;YES - DON'T DO CORE UUO
	CALLI	1,11		;CORE UUO
	JRST	,[TTCALL 3,[ASCIZ/
?CAN'T ASSIGN CORE IN LOW SEGMENT /]
		EXIT]
HAVCOR:	>
	MOVE	P,[IOWD PSIZE,PLIST]
	IFN	PURE,<ADD P,LOW	;ADD LOWSEG INCREMENT>
	MOVE	T1,JOBFF	;STORE JOBFF IN OLDFF(LOW)
	MOVEM	T1,OLDFF(LOW)
	JRST	START+2
START:	MOVE	T1,OLDFF(LOW)	;RESET JOBFF BACK TO ORIGINAL VALUE
	MOVEM	T1,JOBFF	;RESET
	TTCALL	3,[ASCIZ /*/]
	SETZ	PPN,
	SETZ	FLAGS,
	SETZM	,FILE1(LOW)
	SETZM	,FILE1+1(LOW)
	SETZM	,FILE1+2(LOW)
	SETZM	,FILE1+3(LOW)
	SETZM	,FILE2(LOW)
	SETZM	,FILE2+1(LOW)
	SETZM	,FILE2+2(LOW)
	SETZM	,FILE2+3(LOW)
	MOVE	T1,[SIXBIT /DSK/]
	MOVEM	T1,DEV1(LOW)
	MOVEM	T1,DEV2(LOW)
	MOVEI	T1,DEV2(LOW)
	MOVEI	T2,FILE2(LOW)
	PUSHJ	P,CLRNAM		;CLEAR NAME
TYIN:	TTCALL	4,CHAR
	HRRZ	T3,DESTAB(CHAR)		;GET THE DISPATCH ADDRESS IN T3
	JRST	,0(T3)			;AND DISPATCH CHARACTER
LEGAL:	TLNE	FLAGS,FNDPPN		;PPN MODE??
	JRST	ILLEGAL			;YES - ALPHA CHARACTERS ILLEGAL
NUMBER:	TLNE	FLAGS,FNDPPN		;NUMBER OR SIXBIT MODE?
	JRST	NUMMOD
	SUBI	CHAR,40			;NO - ALL CHARACTERS LEGAL
	SOSL	COUNT
	IDPB	CHAR,POINT
	JRST	TYIN
NUMMOD:	SUBI	CHAR,60
	IMULI	PPN,10
	ADD	PPN,CHAR
	JRST	TYIN
;
; CHARACTER HANDLING ROUTINES
;
ILLEGAL:TTCALL	3,[ASCIZ /
?ILLEGAL CHARACTER /]
	TTCALL	1,CHAR
	TTCALL	3,[ASCIZ /
/]
	JRST	GETLF
;
LOWER:	SUBI	CHAR,40			;CONVERT LOWER CASE TO UPPER
	JRST	LEGAL
;
; PROCESS A COLON IN THE INPUT STRING
; IF A PREVIOUS COLON OR PERIOD - COMMAND ERROR
; IF NO PREVIOUS COLON OR PERIOD BUT EMPTY NAME - COMMAND ERROR
; OTHERWISE STORE NAME IN DEVICE NAME IN INIT BLOCK
; IF IN FNDPPN MODE - CAUSES COMMAND ERROR
;
COLON:	TLNE	FLAGS,FNDPPN		;IN FNDPPN MODE?
	JRST	COMERR			;YES - COMMAND ERROR
	TLNE	FLAGS,CLNFND!PERFND	;SKIP IF NO PREVIOS COLON
					;OR PERIOD
	JRST	COMERR
	TLO	FLAGS,CLNFND		;SET COLON FOUND FLAG
	JUMPE	NAME,COMERR		;NULL NAME - COMMAND ERROR
	MOVEM	NAME,0(T1)
	PUSHJ	P,CLRNAM		;CLEAR NAME
	JRST	TYIN
;
; COMMAND ERROR
; TYPE "COMMAND ERROR"
; SLEW INPUT BUFFER
; RETURN TO START AND RESET ALL DEVICE AND FILE SPECIFICATIONS
;
COMERR:	TTCALL	3,[ASCIZ /
?COMMAND ERROR
/]
GETLF:	HRRZ	T1,DESTAB(CHAR)	;IS CHARACTER A BREAK
	CAIE	T1,BREAK
	CAIN	T1,SLEW
	JRST	START
	TTCALL	4,CHAR
	JRST	GETLF
;
; PROCESS A PERIOD IN THE INPUT STRING
; IF A PREVIOUS PERIOD - COMMAND ERROR
; IF NO PREVIOUS PERIOD BUT EMPTY NAME - COMMAND ERROR
; OTHERWISE STORE NAME IN FIRST WORD OF 4 BLOCK FILE AREA
; IF IN FNDPPN MODE - CAUSES COMMAND ERROR
;
PERIOD:	TLNE	FLAGS,FNDPPN		;FNDPPN MODE - ?
	JRST	COMERR			;YES - COMMAND ERROR
	TLNE	FLAGS,PERFND		;PREVIOS PERIOD?
	JRST	COMERR			;YES - COMMAND ERROR
	TLO	FLAGS,PERFND		;SET PERIOD FOUND FLAG
	JUMPE	NAME,COMERR		;EMPTY NAME - COMMAND ERROR
	MOVEM	NAME,0(T2)		;STORE FILENAME
	PUSHJ	P,CLRNAM		;CLEAR NAME
	JRST	TYIN
;
; PROCESS A LEFT BRACKET IN THE COMMAND STRING
; SET INPUT MODE TO PPN - ONLY ACCEPTABLE COMMAND CHARACTERS
; ARE , AND RIGHT BRACKET
; ONLY ACCEPTABLE CHARACTERS ARE NUMBERIC AND BLANKS (IGNORED)
; IF A PREVIOUS LEFT BRACKET - COMMAND ERROR
;
LEFT:	TLNE	FLAGS,LFTFND		;PREVIOUS LEFT BRACKET ?
	JRST	COMERR			;YES - COMMAND ERROR
	TLO	FLAGS,FNDPPN!LFTFND	;SET FLAGS
	JRST	TYIN
;
; PROCESS A RIGHT BRACKTET IN THE INPUT STRING
; IF A PREVIOUS RIGHT BRACKET - COMMAND ERROR
; IF NOT IN FNDPPN MODE WITH A COMMA FOUND - COMMAND ERROR
; OTHERWISE STORE NAME IN RIGHT HALF OF PPN WORD
; AND TURN OFF FNDPPN FLAG
;
RIGHT:	TLNN	FLAGS,FNDPPN		;IN PPN MODE
	JRST	COMERR			;NO
CNT3:	TLNN	FLAGS,COMFND		;COMMA FOUND?
	JRST	COMERR
CNT4:	TLO	FLAGS,RHTFND		;SET FLAG
	TLZ	FLAGS,FNDPPN		;TURN OFF PPN FLAG
	HRRM	PPN,3(T2)		;STORE PROGRAMMER NUMBER
	JRST	TYIN
;
; PROCESS A BACK ARROW IN THE INPUT STRING
; CALLS FINISH AND SETS BACK ARROW FOUND FLAG
;
ARROW:	PUSHJ	P,FINSH
	MOVEI	T1,DEV1(LOW)
	MOVEI	T2,FILE1(LOW)
	TLO	FLAGS,ARRFND
	JRST	TYIN
;
; PROCESS A COMMA IN THE INPUT STRING
; IF NOT IN FNDPPN MODE - COMMAND ERROR
; IF IN FNDPPN MODE AND SECOND COMMA - COMMAND ERROR
; OTHERWISE - STORE PROJECT NUMBER, CLEAR PPN, AND SET FLAG
;
COMMA:	TLNN	FLAGS,FNDPPN		;FNDPPN MODE ?
	JRST	COMERR			;NO - COMMAND ERROR
CNT6:	TLNE	FLAGS,COMFND		;PREVIOUS COMMA?
	JRST	COMERR			;YES - COMMAND ERROR
	TLO	FLAGS,COMFND		;SET COMMA FOUND FLAG
	HRLM	PPN,3(T2)		;STORE PROJECT NUMBER
	SETZ	PPN,
	JRST	TYIN
;
; SUBROUTINE TO FINISH OFF A STRING WHEN EITHER A BACK ARROW
; OR A BREAK CHARACTER IS ENCOUNTERED
; CALL IS A PUSHJ
;
; PROCESSING AS FOLLOWS
; IF IN FNDPPN MODE AND COMMA FOUND FINISHES STORING PPN WITH CURRENT
; CONTENTS OF PPN AND THEN FINISHES FILENAME/EXTENSION
; IF NOT IN FNDPPN MODE AND
;  COLON FOUND BUT NAME BLANK LEAVES FILENAME EXTENSION UNTOUCHED
;  PERIOD FOUND AND NAME BLANK ASSUMES BLANK EXTENSION
;  PERIOD FOUND AND NAME NOT BLANK STORES EXTENSION
;  PERIOD NOT FOUND AND NAME NOT BLANK STORS CURRENT
;  CONTENTS OF NAME IN FILENAME
; ROUTINE RESETS ALL APPROPRIATE FLAGS AND CLEARS NAME AND PPN
;
FINSH:	TLNE	FLAGS,FNDPPN		;FNDPPN MODE ?
	JRST	FINPPN			;YES FINISH PPN
CHKPER:	TLNE	FLAGS,PERFND		;PERIOD FOUND?
	JRST	FINPER			;YES
	JUMPE	NAME,NOACT		;EMPTY NAME - NO ACTION
	MOVEM	NAME,0(T2)		;STORE FILENAME
NOACT:	MOVE	T1,0(T1)		;MOVE DEVICE TO T1
	CALLI	T1,4			;GET DEVCHR
	TLNN	T1,4			;DIRECTORY DEVICE
	JRST	FINLIN			;NO
DIR:	MOVE	T2,0(T2)		;FILENAME TO T2
	JUMPE	T2,COMERR		;EMPTY EXTENSION - COMMAND ERROR
FINLIN:	SETZ	FLAGS,			;CLEAR FLAGS
	PUSHJ	P,CLRNAM		;CLEAR NAME
	SETZ	PPN,
	POPJ	P,
;
FINPER:	JUMPE	NAME,NOACT		;BLANK EXTENSION - NO ACTION
	HLLM	NAME,1(T2)		;STORE EXTENSION
	JRST	NOACT
;
FINPPN:	TLNN	FLAGS,COMFND		;COMMA FOUND
	JRST	COMERR			;NO
CNT10:	HRRM	PPN,3(T2)		;STORE PROGRAMMER NUMBER
	JRST	CHKPER
;
; SUBROUTINE TO CLEAR NAME
; ROUTINE SETS NAME TO ZERO, RESETS POINTER AND COUNTER
;
CLRNAM:	SETZ	NAME,
	MOVE	POINT,[POINT 6,NAME-1,35]
	MOVEI	COUNT,6
	POPJ	P,
;
;
SLEW:	TTCALL	3,[ASCIZ /
/]
BREAK:	PUSHJ	P,FINSH		;FINISH OFF LINE
	MOVEI	T1,14		;OPEN CH1 IN BINARY
	MOVEM	T1,HEAD1(LOW)
	MOVEI	T1,IBUF(LOW)
	MOVEM	T1,BUF1(LOW)		;SET UP BUFFER POINTER
	SETZM	,HEAD2(LOW)		;OPEN CH2 IN ASCII
	MOVSI	T1,OBUF(LOW)
	MOVEM	T1,BUF2(LOW)		;SET UP BUFFER POINTER
	OPEN	CH1,HEAD1(LOW)	;INIT INPUT CHANNEL IN BINARY
	JRST	,[TTCALL 3,[ASCIZ /
?CANNOT INITALIZE INPUT
/]
		JRST	START]
	OPEN	CH2,HEAD2(LOW)
	JRST	,[TTCALL 3,[ASCIZ /
?CANNOT INITALIZE OUTPUT
/]
		JRST	START]
	MOVE	T1,DEV1(LOW)
	CALLI	T1,4		;GET DEVICE CHARACTERISTICS IN T1
	TLNN	T1,4		;DIRECTORY DEVICE
	JRST	NODIR1
DIR1:	LOOKUP	CH1,FILE1(LOW)
	JRST	,[TTCALL 3,[ASCIZ /
?LOOKUP FAILURE
/]
		JRST	START]
NODIR1:	MOVE	T1,DEV2(LOW)
	CALLI	T1,4
	TLNN	T1,4
	JRST	NODIR2
DIR2:	ENTER	CH2,FILE2(LOW)
	JRST	,[TTCALL 3,[ASCIZ /
?ENTER FAILURE
/]
		JRST	START]
;
; SET UP OUTPUT BUFFERS AND UPDATE JOBFF TO POITN PAST BUFFERS
; THEN SET UP INPUT BUFFERS
;
NODIR2:	MOVEI	T1,HEAD2(LOW)	;GET OUTPUT BUFFER SIZE
	CALLI	T1,101		;DEVSIZ UUO
	JRST	,[TTCALL 3,[ASCIZ/
?NO DEVSIZ UUO
/]
		EXIT]
	MOVEM	T1,OUTSZE(LOW)	;STORE IN OUTSZE(LOW)
	MOVEI	T1,HEAD1(LOW)
	CALLI	T1,101
	HALT	.		;ERROR HERE IS IMPOSSIBLE BECAUSE OF ABOVE
	MOVEM	T1,INSIZE(LOW)	;STORE IN INSIZE(LOW)
	HLRZ	T2,T1		;DEFAULT INPUT IN T2
	HRRZ	T1,T1		;DEFAULT SIZE FOR INPUT IN T1
	HRRZ	T3,OUTSZE(LOW)	;DEFAULT SIZE FOR OUPUT IN T3
	HLRZ	T4,OUTSZE(LOW)	;DEFAULT OUTPUT IN T4
	MOVE	T5,T1
	IMUL	T5,T2
	MOVE	T6,T3
	IMUL	T6,T4
	ADD	T5,T6		;GET DEFAULT SIZE IN T5
	ADD	T5,JOBFF	;HOW MUCH CORE DO WE NEED AND
	HRRZ	T7,JOBREL	;HOW MUCH CORE WERE WE GIVEN
	SUB	T5,T7
	JUMPGE	T5,SETUP	;NEED MORE THAN WE HAVE - GET IT
				;AND MAKE THE BUFFERS
	MOVN	T5,T5	;GET EXTRA IN T5
	MOVE	T6,T1		;DEFAULT INPUT SIZE TO T6
	ADD	T6,T3		;TOTAL SIZE FOR 1 OF EACH IN T6
	IDIV	T5,T6		;HOW MANY MORE CAN WE FIT
	MOVS	T5,T5		;ADD EXTRA TO CURRENT COUNT
	ADDM	T5,OUTSZE(LOW)	;INCREASE NO OF OUTPUT
	ADDM	T5,INSIZE(LOW)	;INCREASE NUMBER OF INPUT BUFFERS
	CAIL	T3,T6		;RROM FOR ONE MORE OUTPUT BUFFER
	JRST	MOREIN		;NO - CHECK IF CAN FIT INPUT
	MOVSI	T5,1		;YES - ADD IT ON
	ADDM	T5,OUTSZE(LOW)
	JRST	SETUP		;AND SET THEM UP
MOREIN:	CAIL	T1,T6	;ROOM FOR ANOTHER INPUT
	JRST	SETUP		;NO - JUST SETUP
	MOVSI	T5,1		;YES - ADD IT ON
	ADDM	T5,INSIZE(LOW)
;
; OKAY - NOW GO SET UP BUFFERS
;
SETUP:	MOVEI	T7,OUTSZE(LOW)	;PUT ADDRESS OF BUFFER SIZE IN T7
	MOVEI	T8,OBUF(LOW)	;PUT BUFFER HEADER ADDRESS IN T8
	PUSHJ	P,SETBUF	;SET UP OUTPUT BUFFER RING
	MOVE	T7,[POINT 7,0 ]	;SET UP OUTPUT POINTER
	MOVEM	T7,OBUF+1(LOW)	;STORE IN OUTPUT BUFFER HEADER
	MOVEM	T5,JOBFF	;STORE LAST ADDRESS IN JOBFF
	MOVEI	T7,INSIZE(LOW)	;GET ADDREESS OF IONPUT BUFFER SIZE
	MOVEI	T8,IBUF(LOW)	;STORE BUFFER HEADER ADDRESS
	PUSHJ	P,SETBUF	;SET UP INPUT BUFFERS
	MOVE	T7,[POINT 36,0 ]	;SET UP INPUT POINTER
	MOVEM	T7,IBUF+1(LOW)	;STORE IN INPUT BUFFER HEADER
	SUBTTL	OPTION PROCESSING
	PAGE
;
; OPTIONS CONSIST OF
; F - FAST PROCESSING - NO LABEL RECORD
; H - HEADER PROCESSING - NO LABEL RECORD
; L - FAST PROCESSING - LABEL RECORD
; T - HEADER PROCESSING - LABEL RECORD
;
GETOPT:	TTCALL	3,[ASCIZ /ENTER OPTION (F,H,L OR T) /]
	TTCALL	4,CHAR		;GET OPTION IN CHAR
;
; GET THE LINEFEED
;
	CAIN	CHAR,12		;IS CHAR A LINEFEED
	JRST	GETOPT
	TTCALL	4,T1
	CAIE	T1,12
	JRST	.-2
	CAIN	CHAR,"F"	;FAST PROCESSING
	JRST	FAST
	CAIN	CHAR,"L"	;LABEL PROCESSING
	JRST	LABEL
	CAIN	CHAR,"H"	;HEADER PROCESSING
	JRST	HEADER
	CAIN	CHAR,"T"	;HEADER AND LABEL PROCESSING
	JRST	HDLBL
	JRST	GETOPT
	SUBTTL	OUTPUT WITH SIXPRT COBOL HEADERS
	PAGE
HDLBL:	PUSHJ	P,FRCIN		;FORCE A RECORD SKIP
HEADER:	MOVEI	LCNT,PGLIM	;START WITH A NEW PAGE
	MOVEI	T1,0		;GET THE DATE IN T1
	CALLI	T1,14		;DATE UUO
	IDIVI	T1,^D31		;GET THE DATE - 1 IN T2
	ADDI	T2,1
	IDIVI	T2,^D10		;DATE IN T2 AND T3
	ADDI	T2,60		;CONVERT TO ASCII
	ADDI	T3,60		;CONVERT TO ASCII
	DPB	T2,[POINT 7,DATTIM(LOW),27]
	DPB	T3,[POINT 7,DATTIM(LOW),34]
	IDIVI	T1,^D12		;GET THE MONTH -1 IN T2
	ADDI	T2,1		;GET THE MONTH IN T2
	IDIVI	T2,^D10		;MONTH IN T2 AND T3
	ADDI	T2,60		;CONVERT TO ASCII
	ADDI	T3,60		;CONVERT TO ASCII
	DPB	T2,[POINT 7,DATTIM(LOW),6]
	DPB	T3,[POINT 7,DATTIM(LOW),13]
	ADDI	T1,^D64		;YEAR IN T1
	IDIVI	T1,^D10		;YEAR IN T1 AND T2
	ADDI	T1,60		;CONVERT TI ASCII
	ADDI	T2,60		;CONVERT TO ASCII
	DPB	T1,[POINT 7,DATTIM+1(LOW),13]
	DPB	T2,[POINT 7,DATTIM+1(LOW),20]
	MOVEI	T1,0		;GET DAY TIME IN MS IN T1
	CALLI	T1,23		;TIME IN T1
	IDIVI	T1,^D60000	;MINUTES IN T1
	IDIVI	T1,^D60		;MINUTES IN T2
	IDIVI	T2,^D10		;MINUTES IN T2 AND T3
	ADDI	T2,60		;CONVERT TO ASCII
	ADDI	T3,60		;CONVERT TO ASCII
	DPB	T2,[POINT 7,DATTIM+2(LOW),20]
	DPB	T3,[POINT 7,DATTIM+2(LOW),27]
	IDIVI	T1,^D10		;HOURS IN T1 AND T2
	ADDI	T1,60		;CONVERT TO ASCII
	ADDI	T2,60		;CONVERT TO ASCII
	DPB	T1,[POINT 7,DATTIM+1(LOW),34]
	DPB	T2,[POINT 7,DATTIM+2(LOW),6]
	MOVEI	T1,40		;STORE BLANKS
	DPB	T1,[POINT 7,DATTIM+1(LOW),27]
	DPB	T1,[POINT 7,DATTIM+2(LOW),34]
	MOVEI	T1,":"
	DPB	T1,[POINT 7,DATTIM+2(LOW),13]
	MOVEI	T1,"-"
	DPB	T1,[POINT 7,DATTIM(LOW),20]
	DPB	T1,[POINT 7,DATTIM+1(LOW),6]
	SETZM	,RCNT(LOW)
	MOVEI	T1,1		;PAGE COUNT STARTS AT 1
	MOVEM	T1,PCNT(LOW)
;
; CHANGE IN SIXPRT - CHECK IF A LINE BEFORE OUTPUTTING HEADERS
;
OUTLNE:	JSP	Q,GETWRD		;GET THE CHARACTER COUNT
	JUMPE	CHAR,.-1		;IGNORE 0 RECORDS - 11/5/71
	TRZ	FLAGS,NEED		;CLEAR BEGIN FLAG
	CAIL	LCNT,PGLIM		;DO WE WANT THE HEADER
	PUSHJ	P,PRNTHD
	SETZM	CCNT(LOW)		;ZERO THE CHARACTER COUNT
	MOVEI	ASC," "		;START LINE WITH 5 BLANKS
	MOVEI	T1,5
	JSP	Q,PUTCHR	;OUTPUT THE BLANK
	SOJG	T1,.-1		;CONTINUE FOR FIVE
	AOS	,RCNT(LOW)		;INCREMENT RECORD COUNT
	MOVEI	T1,6
	MOVE	T2,[POINT 6,FILE2-1(LOW),35]
	ILDB	ASC,T2
	ADDI	ASC,40
	JSP	Q,PUTCHR
	SOJG	T1,.-3		;FILENAME
	MOVEI	ASC,"."
	JSP	Q,PUTCHR
	MOVEI	T1,3
	ILDB	ASC,T2
	ADDI	ASC,40
	JSP	Q,PUTCHR
	SOJG	T1,.-3		;EXTENSION
	MOVEI	ASC," "
	JSP	Q,PUTCHR
	JSP	Q,PUTCHR
	MOVE	T1,RCNT(LOW)		;OUTPUT RECORD NUMBER
	IDIVI	T1,^D100000
	IDIVI	T2,^D10000
	IDIVI	T3,^D1000
	IDIVI	T4,^D100
	IDIVI	T5,^D10
	MOVEI	ASC,60(T1)
	JSP	Q,PUTCHR
	MOVEI	ASC,60(T2)
	JSP	Q,PUTCHR
	MOVEI	ASC,60(T3)
	JSP	Q,PUTCHR
	MOVEI	ASC,60(T4)
	JSP	Q,PUTCHR
	MOVEI	ASC,60(T5)
	JSP	Q,PUTCHR
	MOVEI	ASC,60(T6)
	JSP	Q,PUTCHR
	MOVEI	ASC," "
	JSP	Q,PUTCHR
	JSP	Q,PUTCHR	;2 BLANKS BETWEEN RECORD NUMBER AND RCOUNT
	PUSHJ	P,MIDDLE
	MOVE	WRDS,CHAR		;STORE IN COUNTER
NXTWRD:	JSP	Q,GETWRD	;GET A WORD FROM THE FILE
	MOVE	T5,[POINT 6,CHAR-1,35]
	MOVEI	T6,6
LDCH:	TRZN	FLAGS,NEED		;CLEAR AND TEST FLAG
	JRST	NONEED
	MOVEI	ASC,15		;OUTPUT A CR-LF
	JSP	Q,PUTCHR
	MOVEI	ASC,12	
	JSP	Q,PUTCHR
	ADDI	LCNT,1		;INCREMENT LINE COUNT
	CAIL	LCNT,PGLIM	;NEED HEADER
	PUSHJ	P,PRNTHD	;YES- PRINT IT
	MOVEI	ASC,11
	JSP	Q,PUTCHR		;3 TABS AT BEGINNING OF LINE
	JSP	Q,PUTCHR		;3 TABS AT BEGINNING OF LINE
	JSP	Q,PUTCHR		;3 TABS AT BEGINNING OF LINE
	MOVEI	ASC," "
	JSP	Q,PUTCHR
	PUSHJ	P,MIDDLE
NONEED:	ILDB	ASC,T5
	ADDI	ASC,40
	JSP	Q,PUTCHR
	AOS	T3,CCNT(LOW)		;INCREMENT CCNT AND STORE IN T3
	IDIVI	T3,^D100	;100 CHARACTERS IN A LINE
	CAIN	T4,0		;SKIP IF NOT AN EVEN 100
	TRO	FLAGS,NEED	;SET NEED FLAG TO PRINT ON NEXT AROUND
GOON:	SOJLE	WRDS,ENDLNE
	SOJG	T6,LDCH
	JRST	NXTWRD
;
; END THE LINE WITH 2 CR-LF
;
ENDLNE:	MOVEI	WRDS,2
	MOVEI	ASC,15
	JSP	Q,PUTCHR
	MOVEI	ASC,12
	JSP	Q,PUTCHR
	ADDI	LCNT,1		;INCREMENT THE LINE COUNT
	CAIL	LCNT,PGLIM	;NEED A HEADER
	PUSHJ	P,PRNTHD	;PRINT HEADER
	SOJG	WRDS,ENDLNE+1
	JRST	OUTLNE		;GET ANOTHER RECORD
;
; SUBROUTINE TO OUTPUT (CCCC) AND A BLANK
; BEFORE BEGINNING THE LINE
;
MIDDLE:	MOVEI	ASC,"("
	JSP	Q,PUTCHR
	MOVE	T1,CCNT(LOW)
	IDIVI	T1,^D1000
	IDIVI	T2,^D100
	IDIVI	T3,^D10
	MOVEI	ASC,60(T1)
	JSP	Q,PUTCHR
	MOVEI	ASC,60(T2)
	JSP	Q,PUTCHR
	MOVEI	ASC,60(T3)
	JSP	Q,PUTCHR
	MOVEI	ASC,60(T4)
	JSP	Q,PUTCHR
	MOVEI	ASC,")"
	JSP	Q,PUTCHR
	MOVEI	ASC," "
	JSP	Q,PUTCHR	;READY TO CONVERT
	POPJ	P,		;CONTINUE OUTPUT
; SUBROUTINE TO PRINT THE HEADER
;
PRNTHD:	MOVEI	ASC,14		;INSERT A FORMFEED
	JSP	Q,PUTCHR
	MOVE	T1,[POINT 7,HDR-1,35]
PRTLP:	ILDB	ASC,T1
	JUMPE	ASC,RETHD	;STOP ON NULL IN HEADER
	JSP	Q,PUTCHR	;OTHERWISE- OUTPUT THE CHARACTER
	JRST	PRTLP		;AND GET ANOTHER
RETHD:	MOVEI	T1,^D15		;DATE AND TIME
	MOVE	T2,[POINT 7,DATTIM-1(LOW),35]
	ILDB	ASC,T2
	JSP	Q,PUTCHR
	SOJG	T1,.-2
	MOVEI	ASC,"P"
	JSP	Q,PUTCHR
	MOVEI	ASC,"A"
	JSP	Q,PUTCHR
	MOVEI	ASC,"G"
	JSP	Q,PUTCHR
	MOVEI	ASC,"E"
	JSP	Q,PUTCHR
	MOVEI	ASC,40
	JSP	Q,PUTCHR
	MOVE	T1,PCNT(LOW)
	IDIVI	T1,^D100
	IDIVI	T2,^D10
	MOVEI	ASC,60(T1)
	JSP	Q,PUTCHR
	MOVEI	ASC,60(T2)
	JSP	Q,PUTCHR
	MOVEI	ASC,60(T3)
	JSP	Q,PUTCHR
	MOVEI	ASC," "
	JSP	Q,PUTCHR
	MOVE	T1,[POINT 7,HDR2-1,35]
PRTLP2:	ILDB	ASC,T1
	JUMPE	ASC,RETHD2
	JSP	Q,PUTCHR
	JRST	PRTLP2
RETHD2:	MOVEI	LCNT,4		;4 LINES IN HEADER
	AOS	PCNT(LOW)		;INCREMENT PAGE COUNT
	POPJ	P,		;RETURN
HDR:	ASCIZ	+	S I X - B I T		/    0   /     1   /     2   /     3   /     4   /     5   /     6   /     7   /     8   /     9   /

	+
HDR2:	ASCIZ	+1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890

+
	SUBTTL	FAST PROCESSING
	PAGE
LABEL:	PUSHJ	P,FRCIN		;FORCE A RECORD SKIP
FAST:	JSP	Q,GETWRD		;GET THE CHARACTER COUNT
	JUMPE	CHAR,.-1		;IGNORE 0 RECORDS - 11/5/71
	MOVE	WRDS,CHAR		;STORE IN COUNTER
LOOP:	JSP	Q,GETWRD
	MOVE	T1,[POINT 6,CHAR-1,35]
	MOVEI	T2,6
LOADCH:	ILDB	ASC,T1
	ADDI	ASC,40
	JSP	Q,PUTCHR
	SOJLE	WRDS,CRLF	;END OF SIXBIT LINE?
	SOJG	T2,LOADCH	;END OF WORD?
	JRST	LOOP
CRLF:	MOVEI	ASC,15
	JSP	Q,PUTCHR
	MOVEI	ASC,12
	JSP	Q,PUTCHR
	JRST	FAST
	SUBTTL	FINISH THE FILE
	PAGE
CLOSE:	CLOSE	CH2,
	RELEASE	CH1,		;RELEASE I/O
	RELEASE	CH2,		;CHANNELS
	JRST	START
;
; ROUTINE TO GET A WORD FROM THE INPUT FILE
;
GETWRD:	SOSG	IBUF+2(LOW)
FRCIN:	IN	CH1,
	JRST	GETOK
	STATZ	CH1,740000
	JRST	RDERR		;CJECK IFF MTAPE AND BLOCK ERROR
	JRST	CLOSE
GETOK:	ILDB	CHAR,IBUF+1(LOW)
	JRST	,0(Q)			;JSP TYPE RETURN
;
; ROUTINE TO DEPOSIT AN ASCII CHARACTER IN THE OUTPUT BUFFER
;
PUTCHR:	SOSG	OBUF+2(LOW)
	OUT	CH2,
	JRST	PUTOK
	JRST	,[TTCALL 3,[ASCIZ /
?OUTPUT ERROR
/]
		JRST	START]
PUTOK:	IDPB	ASC,OBUF+1(LOW)
	JRST	,0(Q)		;JSP RETURN
;
RDERR:	MOVE	T1,DEV1(LOW)		;GET DEVICE CHARACTERISTICS
	CALLI	T1,4		;DEVCHR UUO
	TLNN	T1,20		;TEST FOR MAGTAPE
	JRST	ERRMSS	;NOT A MAGTAPE : GIVE ERROR MESSAGE
	STATZ	CH1,700000	;MAKE SURE NO OTHER ERRORS
	JRST	ERRMSS
	MOVEI	T1,2000		;INCREASE INPUT BUFFERS
	ADDM	T1,INSIZE(LOW)		;INCREMENT INPUT SIZE
	MOVEM	T7,SAVE7(LOW)
	MOVEI	T7,INSIZE(LOW)
	MOVEI	T8,IBUF(LOW)
	PUSHJ	P,SETBUF
	MOVE	T7,[POINT 36,0 ]	;SET UP BINARY INPUT POINTER
	MOVEM	T7,IBUF+1(LOW)		;STORE IN INPUT BUFFER HEADER
	MOVE	T7,SAVE7(LOW)
	MTAPE	CH1,7			;BACKSPACE A RECORD
	MTAPE	CH1,0			;WAIT FOR BACKSAPCE
	JRST	GETWRD			;TRY AGAIN
;
ERRMSS:	TTCALL	3,[ASCIZ/
?HARWARE READ ERROR
/]
	JRST	START
;
; SUBROUTINE TO SET UP BUFFERS
;
; USE WORD 0(T7) TO FIND OUT HOW MANY BUFFERS
; AND HOW LARGE THEY SHOULD BE
;
; BUFFERS ARE ST UP ON CHANNEL CH1
;
SETBUF:	HRRZ	T1,0(T7)	;GET BUFFER SIZE IN T1
	MOVE	T2,T1	;SAME IN T2
	HLRZ	T3,0(T7)	;GET NUMBER OF BUFFE T3
	IMUL	T2,T3		;GET ADDITIONAL CORE
	ADD	T2,JOBFF	;ADD FIRST FREE LOCASTION TO GET
				;NEW CORSIZE
	MOVE	T5,T2		;STORE NEW SIZE IN T5
	CORE	T2,		;TRY FOR CORE FOR BUFFERS
	JRST	,[TTCALL 3,[ASCIZ/
?CAN'T OBTAIN CORE FOR BUFFERS - JOB ABORTED
/]
		EXIT]
	HRR	T4,JOBFF
	SETZM	0(T4)		;CLEAR FIRST LOCATION IN BUF AREA
	HRL	T4,JOBFF
	ADDI	T4,1
	BLT	T4,0(T5)	;CLEAR THE BUFFER AREA
;
; SET UP THE BUFFER HEADERS
;
	MOVE	T4,JOBFF	;GET STARTING LOCATION IN T4
	MOVE	T2,T1		;GET SIZE IN T2
	SUBI	T2,2		;GET SIZE + 1 IN T2
	ADDI	T4,1		;FIRST LOCATION WHERE ANYTHING STORED
	MOVS	T2,T2		;SWAP HALVES OF T2
	MOVE	T6,T4		;MOVE START TO T6
MAKBUF:	MOVEM	T2,0(T6)	;STORE LEFT HALF
	HRRM	T6,0(T6)	;SET TO POINT TO SELF
	ADDM	T1,0(T6)	;SET TO POINT TO NEXT
	ADD	T6,T1		;INCREMENT T6
	SOJG	T3,MAKBUF	;CONTINUE FOR ALL BUFFERS
	SUB	T6,T1		;CORENT LAST BUFFER
	HRRM	T4,0(T6)	;CORRECT LAST BUFFER
	HRLI	T4,400000	;SET UP BUFFER HEADER
	MOVEM	T4,0(T8)
	SETZM	2(T8)	;CLEAR LAST WORD IN BUFFER HEADER
	POPJ	P,		;DONE
;
IFN PURE,<LOC 0>
;
OLDFF:	BLOCK	1	;STORE ORIGINAL VALUE OF JOBFF HERE
SAVE7:	BLOCK	1
INSIZE:	BLOCK	1	;INPUT BUFFER SIZE
OUTSZE:	BLOCK	1		;OUTPUT BUFFER SIZE
RCNT:	BLOCK	1		;COUNTS INPUT RECORDS
CCNT:	BLOCK	1		;COUNTS CHARACTERS ON LINE
PCNT:	BLOCK	1		;PAGE COUNTER
DATTIM:	BLOCK	3		;DATE AND TIME FOR HEADER
HEAD1:	BLOCK	1
DEV1:	BLOCK	1
BUF1:	BLOCK	1
HEAD2:	BLOCK	1
DEV2:	BLOCK	1
BUF2:	BLOCK	1
FILE1:	BLOCK	4
FILE2:	BLOCK	4
IBUF:	BLOCK	3
OBUF:	BLOCK	3
PLIST:	BLOCK	PSIZE
IFN PURE,<LOWSIZ=.>
	PAGE
;
; DISPATCH TABLE FOR INPUT CHARACTERS
;
IFN PURE,<RELOC>		;RETURN TO HIGH SEG ADDRESSES
DESTAB:	BYTE (9).-DESTAB,0(18)TYIN		;NULL - IGNORED
	BYTE (9).-DESTAB,0(18)ILLEGAL		;CONTROL A
	BYTE (9).-DESTAB,0(18)ILLEGAL		;CONTROL B
	BYTE (9).-DESTAB,0(18)ILLEGAL		;CONTROL C
	BYTE (9).-DESTAB,0(18)ILLEGAL		;CONTROL D
	BYTE (9).-DESTAB,0(18)ILLEGAL		;CONTROL E
	BYTE (9).-DESTAB,0(18)ILLEGAL		;CONTROL F
	BYTE (9).-DESTAB,0(18)BREAK		;CONTROL G - BELL
	BYTE (9).-DESTAB,0(18)ILLEGAL		;CONTROL H
	BYTE (9).-DESTAB,0(18)ILLEGAL		;CONTROL I
	BYTE (9).-DESTAB,0(18)BREAK		;CONTROL J - LINEFEED
	BYTE (9).-DESTAB,0(18)BREAK		;CONTROL K - VERTICAL TAB
	BYTE (9).-DESTAB,0(18)BREAK		;CONTROL L - FORMFEED
	BYTE (9).-DESTAB,0(18)TYIN		;CONTROL M -CARRAIGE RETURN - IGNORE
	BYTE (9).-DESTAB,0(18)ILLEGAL		;CONTROL N
	BYTE (9).-DESTAB,0(18)ILLEGAL		;CONTROL O
	BYTE (9).-DESTAB,0(18)ILLEGAL		;CONTROL P
	BYTE (9).-DESTAB,0(18)ILLEGAL		;CONTROL Q
	BYTE (9).-DESTAB,0(18)ILLEGAL		;CONTROL R
	BYTE (9).-DESTAB,0(18)ILLEGAL		;CONTROL S
	BYTE (9).-DESTAB,0(18)ILLEGAL		;CONTROL T
	BYTE (9).-DESTAB,0(18)ILLEGAL		;CONTROL U
	BYTE (9).-DESTAB,0(18)ILLEGAL		;CONTROL V
	BYTE (9).-DESTAB,0(18)ILLEGAL		;CONTROL W
	BYTE (9).-DESTAB,0(18)ILLEGAL		;CONTROL X
	BYTE (9).-DESTAB,0(18)ILLEGAL		;CONTROL Y
	BYTE (9).-DESTAB,0(18)BREAK		;CONTROL Z - END OF FILE
	BYTE (9).-DESTAB,0(18)SLEW		;ESCAPE
	BYTE (9).-DESTAB,0(18)ILLEGAL		;034
	BYTE (9).-DESTAB,0(18)ILLEGAL		;035
	BYTE (9).-DESTAB,0(18)ILLEGAL		;036
	BYTE (9).-DESTAB,0(18)ILLEGAL		;037
	BYTE (9).-DESTAB,0(18)TYIN		;SPACE -IGNORED
	BYTE (9).-DESTAB,0(18)ILLEGAL		;!
	BYTE (9).-DESTAB,0(18)ILLEGAL		;"
	BYTE (9).-DESTAB,0(18)ILLEGAL		;#
	BYTE (9).-DESTAB,0(18)ILLEGAL		;$
	BYTE (9).-DESTAB,0(18)ILLEGAL		;%
	BYTE (9).-DESTAB,0(18)ILLEGAL		;&
	BYTE (9).-DESTAB,0(18)ILLEGAL		;'
	BYTE (9).-DESTAB,0(18)ILLEGAL		;(
	BYTE (9).-DESTAB,0(18)ILLEGAL		;)
	BYTE (9).-DESTAB,0(18)ILLEGAL		;*
	BYTE (9).-DESTAB,0(18)ILLEGAL		;+
	BYTE (9).-DESTAB,0(18)COMMA		;,
	BYTE (9).-DESTAB,0(18)ILLEGAL		;-
	BYTE (9).-DESTAB,0(18)PERIOD		;.
	BYTE (9).-DESTAB,0(18)ILLEGAL		;SLASH
	BYTE (9).-DESTAB,0(18)NUMBER		;0
	BYTE (9).-DESTAB,0(18)NUMBER		;1
	BYTE (9).-DESTAB,0(18)NUMBER		;2
	BYTE (9).-DESTAB,0(18)NUMBER		;3
	BYTE (9).-DESTAB,0(18)NUMBER		;4
	BYTE (9).-DESTAB,0(18)NUMBER		;5
	BYTE (9).-DESTAB,0(18)NUMBER		;6
	BYTE (9).-DESTAB,0(18)NUMBER		;7
	BYTE (9).-DESTAB,0(18)LEGAL		;8 - PPN IS OCTAL
	BYTE (9).-DESTAB,0(18)LEGAL		;9
	BYTE (9).-DESTAB,0(18)COLON		;:
	BYTE (9).-DESTAB,0(18)ILLEGAL		;;
	BYTE (9).-DESTAB,0(18)ILLEGAL		;LESSTHAN
	BYTE (9).-DESTAB,0(18)ILLEGAL		;=
	BYTE (9).-DESTAB,0(18)ILLEGAL		;GREATERTHAN
	BYTE (9).-DESTAB,0(18)ILLEGAL		;?
	BYTE (9).-DESTAB,0(18)ILLEGAL		;@
	BYTE (9).-DESTAB,0(18)LEGAL		;A
	BYTE (9).-DESTAB,0(18)LEGAL		;B
	BYTE (9).-DESTAB,0(18)LEGAL		;C
	BYTE (9).-DESTAB,0(18)LEGAL		;D
	BYTE (9).-DESTAB,0(18)LEGAL		;E
	BYTE (9).-DESTAB,0(18)LEGAL		;F
	BYTE (9).-DESTAB,0(18)LEGAL		;G
	BYTE (9).-DESTAB,0(18)LEGAL		;H
	BYTE (9).-DESTAB,0(18)LEGAL		;I
	BYTE (9).-DESTAB,0(18)LEGAL		;J
	BYTE (9).-DESTAB,0(18)LEGAL		;K
	BYTE (9).-DESTAB,0(18)LEGAL		;L
	BYTE (9).-DESTAB,0(18)LEGAL		;M
	BYTE (9).-DESTAB,0(18)LEGAL		;N
	BYTE (9).-DESTAB,0(18)LEGAL		;O
	BYTE (9).-DESTAB,0(18)LEGAL		;P
	BYTE (9).-DESTAB,0(18)LEGAL		;Q
	BYTE (9).-DESTAB,0(18)LEGAL		;R
	BYTE (9).-DESTAB,0(18)LEGAL		;S
	BYTE (9).-DESTAB,0(18)LEGAL		;T
	BYTE (9).-DESTAB,0(18)LEGAL		;U
	BYTE (9).-DESTAB,0(18)LEGAL		;V
	BYTE (9).-DESTAB,0(18)LEGAL		;W
	BYTE (9).-DESTAB,0(18)LEGAL		;X
	BYTE (9).-DESTAB,0(18)LEGAL		;Y
	BYTE (9).-DESTAB,0(18)LEGAL		;Z
	BYTE (9).-DESTAB,0(18)LEFT		;[
	BYTE (9).-DESTAB,0(18)ILLEGAL		;\
	BYTE (9).-DESTAB,0(18)RIGHT		;]
	BYTE (9).-DESTAB,0(18)ILLEGAL		;^
	BYTE (9).-DESTAB,0(18)ARROW		;_
	BYTE (9).-DESTAB,0(18)ILLEGAL		;ACCENT GRAVE
	BYTE (9).-DESTAB,0(18)LOWER		;A
	BYTE (9).-DESTAB,0(18)LOWER		;B
	BYTE (9).-DESTAB,0(18)LOWER		;C
	BYTE (9).-DESTAB,0(18)LOWER		;D
	BYTE (9).-DESTAB,0(18)LOWER		;E
	BYTE (9).-DESTAB,0(18)LOWER		;F
	BYTE (9).-DESTAB,0(18)LOWER		;G
	BYTE (9).-DESTAB,0(18)LOWER		;H
	BYTE (9).-DESTAB,0(18)LOWER		;I
	BYTE (9).-DESTAB,0(18)LOWER		;J
	BYTE (9).-DESTAB,0(18)LOWER		;K
	BYTE (9).-DESTAB,0(18)LOWER		;L
	BYTE (9).-DESTAB,0(18)LOWER		;M
	BYTE (9).-DESTAB,0(18)LOWER		;N
	BYTE (9).-DESTAB,0(18)LOWER		;O
	BYTE (9).-DESTAB,0(18)LOWER		;P
	BYTE (9).-DESTAB,0(18)LOWER		;Q
	BYTE (9).-DESTAB,0(18)LOWER		;R
	BYTE (9).-DESTAB,0(18)LOWER		;S
	BYTE (9).-DESTAB,0(18)LOWER		;T
	BYTE (9).-DESTAB,0(18)LOWER		;U
	BYTE (9).-DESTAB,0(18)LOWER		;V
	BYTE (9).-DESTAB,0(18)LOWER		;W
	BYTE (9).-DESTAB,0(18)LOWER		;X
	BYTE (9).-DESTAB,0(18)LOWER		;Y
	BYTE (9).-DESTAB,0(18)LOWER		;Z
	BYTE (9).-DESTAB,0(18)ILLEGAL		;
	BYTE (9).-DESTAB,0(18)SLEW		;OLD ESCAPE
	BYTE (9).-DESTAB,0(18)SLEW		;OLD ESCAPE
	BYTE (9).-DESTAB,0(18)ILLEGAL		;
	BYTE (9).-DESTAB,0(18)ILLEGAL		;RUBOUT/DELETE
	PAGE
	LIT		;MAKE SURE LITERALS ARE IN HISEGMENT
	IFE PURE,<LOWSIZ:	END	SIXPRT>
	IFN PURE,<END	SIXPRT>
,V][