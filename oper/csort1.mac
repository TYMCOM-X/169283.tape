TITLE	CSORT FOR LIBOL 6(240)		
SUBTTL	COBOL SORT ROUTINES		WAYNE NEELY/ALB/CAM	

;COPYRIGHT 1970,1971,1972, DIGITAL EQUIPMENT CORP, MAYNARD, MA.

	HISEG
	SALL

;IF TIMING INFORMATION DESIRED (AS IN STAND ALONE SORT),
;	SET TIMING==1

	PP==17
	TA==16
	TB==15
	TC==14
	TD==13
	TE==12
	TR==1

	%RM.6B==0
	%RM.7B==2

	%US.D6==1
	%US.D7==2
	SZ.BUF==203
	SZ.OFT==^D18
	SZ.DEV==25
	SZ.REC==^D4095	;LARGEST ALLOWABLE RECORD SIZE

	$CORE==11	;CORE UUO
	$RTIME==27	;RUNTIME UUO
	$JOB==30	;PJOB UUO

EXTERNAL JOBFF,JOBREL,OPNCH.
EXTERNAL STOPR.,RSTAB.

	ENTRY PSORT.	;INITIALIZE
	ENTRY MERGE.	;MERGE THE SCRATCH FILES
	ENTRY RETRN.	;RETURN A RECORD
	ENTRY RELES.	;PROCESS A RELEASED RECORD
	ENTRY ENDS.	;CLEAN UP AFTER SORT

	OPDEF OPENO. [BYTE (9)1(4)10]
	OPDEF OPENI. [BYTE (9)1(4)4]
	OPDEF READ.  [BYTE (9)2(4)2]
	OPDEF WRITE. [BYTE (9)2(4)3]
	OPDEF CLOSE. [BYTE (9)1(4)1]
	OPDEF PURGE. [BYTE (9)2(4)10]

	IFNDEF TIMING,<TIMING==0>
;KILL JOB

	DEFINE	STOPIT(MESSAG)<
	TTCALL	3,[ASCIZ /MESSAG
/]
	JRST	STOPR.
	>


	DEFINE OPENIN,<
	HRLI	TB,(OPENI.)
	XCT	TB
	>

	DEFINE OPENOT,<
	HRLI	TB,(OPENO.)
	XCT	TB
	>

	DEFINE CLOSIT,<
	HRLI	TB,(CLOSE.)
	XCT	TB
	>

	DEFINE PURGIT,<
	HRLI	TB,(PURGE.)
	XCT	TB
	>

	DEFINE WRTEOF,<
	HRLI	TB,(WRITE.)
	XCT	TB
	EXP	6B11
	SKIPA
	JRST	WRTERR
	>

	DEFINE WRTEOS,<
	WRTEOF
	>

	DEFINE DOREAD,<
	HRLI	TB,(READ.)
	XCT	TB
	SKIPA
	JRST	ATEND
	>

;READ UNLESS DUMMY NULL STRING

	DEFINE IFREAD,<
	HRLI	TB,(READ.)
	SKIPG	NSTRAD(TA)
	XCT	TB
	SKIPA
	JRST	ATEND
	>
	SUBTTL	INITIALIZE

PSORT.:	MOVE	TA,[XWD WRITER,WRITIT]
	BLT	TA,WRITIT+3

	HRRZ	TA,JOBFF
	HRLS	TA
	HRRI	TA,1(TA)
	HRRZ	TB,JOBREL

PS0A:	CAIL	TB,(TA)		;IF
	JRST	PS0B		;  JOBFF
	MOVEI	TB,(TA)		;  ABOVE
	IORI	TB,1777		;  JOBREL
	CALLI	TB,$CORE	;  GET MORE CORE
	JRST	ERR.1		;CANNOT--TROUBLE

PS0B:	SETZM	-1(TA)
	BLT	TA,(TB)
	SETZ	TA,
IFN TIMING,<
	CALLI	TA,$RTIME
	MOVEM	TA,STIME
	>
	MOVEI	TA,2
	EXCH	TA,(PP)
	ADDM	TA,(PP)		;POPJ NOW RETURNS AFTER ARGUMENTS
	MOVE	TB,1(TA)
	MOVE	TA,(TA)
	HLRZM	TA,KEYSIZ	;SIZE OF CONVERTED KEY, IN WORDS
	HRRZM	TA,SDFILE	;SORT-FILE FILE TABLE ADDRESS
	HLRZM	TB,KEYLOC	;LOCATION OF CONVERTED KEYS
	HRRZM	TB,KEYCNV	;LOCATION OF KEY CREATION CODE
	LDB	TB,[POINT 12,7(TA),17]	;MAX. RECORD SIZE
	LDB	TC,[POINT 2,^D8(TA),15]	;INT. RECORDING MODE
	CAIN	TC,%RM.7B
	SKIPA	TC,[EXP 5]	;ASCII---5 CHARACTERS/WORD
	HRRZI	TC,6		;OTHER---6 CHARACTERS/WORD
	ADDI	TB,-1(TC)	;TO FORCE UPWARD ROUNDING
	IDIVI	TB,(TC)		;NO. WORDS TO HOLD LARGEST RECORD
	ADD	TB,KEYSIZ	;NO. WORDS FOR KEYS
	HRRZI	TB,1(TB)	;FLAG WORD
	HRRZM	TB,NWDREC	;RECORD SIZE IN WORDS
	IMULI	TB,6		;RECORD SIZE IN CHARACTERS
	CAILE	TB,SZ.REC
	JRST	ERR.3		;TOO LARGE
	HRRZM	TB,MXRCSZ
	MOVE	TR,NWDREC
	CAIGE	TR,^D16
	MOVEI	TR,^D16
	HRRZ	TA,SDFILE
	HRRZ	TB,^D8(TA)
	HRRZM	TB,NEWREC
	HRRZ	TB,6(TA)
	HRRZM	TB,OLDNXT
	HLRZ	TA,OPNCH.	;FREE CHANNELS
	SETZ	TE,
	JUMPE	TA,PS1.
	ANDI	TA,-1(TA)
	AOJA	TE,.-2
PS1.:	CAIGE	TE,6
	JRST	ERR.2		;NOT ENOUGH CHANNELS
	HRRZI	TE,-3(TE)	;SAVE 3 FOR USER
	HRRZM	TE,MAXCHA

	HRRZ	TA,JOBFF
	HRRZM	TA,SAVEFF
	HRRZ	TB,JOBREL
	HRRZM	TB,SAVREL

	SETZ	TB,
	CALLI	TB,$CORE	;GET MAX. BLOCKS OF CORE AVAILABLE
	JFCL			;IN CASE $CORE EVER SKIPS
	LSH	TB,^D9             ;CONVERT TO WORDS********1/2 TO TEST P014

	HRRZ	TC,.JBHRL##	;HOW MUCH HI-SEG CORE USED?
	ANDI	TC,377777
	SUBI	TB,1(TC)	;SUBTRACT THAT FROM AVAILABLE CORE

	MOVEM	TB,MAXCOR	;SAVE LARGEST ALLOWED CORE SIZE
	SUB	TB,SAVREL	;HOW MUCH AVAILABLE ABOVE USER?
	MOVE	TE,TB
	LSH	TE,-1		;CUT IN
	TRZ	TE,1000		;  HALF
	CAIG	TE,4*^D1024	;IF 1/2 .GT. 4K, USE IT
	JRST	[CAIG TB,4*^D1024	;ELSE IF NET AVAILABLE .GT. 4K, USE 4K
		SKIPA TE,TB		;OR IF NET AVAILABLE .LE. 4K, USE ALL
		MOVEI TE,4*^D1024
		SUBI  TE,1
		JRST  .+1]
	ADD	TE,SAVREL	;CALCULATE TOTAL WANTED
	IORI	TE,1777
	MOVEI	TB,1(TE)	;ROUND UP TO K BOUND

	HRRZ	TE,MEMRY.	;DID USER SPECIFY A SIZE?
	CAIN	TE,-1
	JRST	.+3		;NO
	SUBI	TE,1(TC)	;YES, SUBTRACT HI-SEG
	AOS	TB,TE		;AND USE THAT SIZE

	CAMLE	TB,MAXCOR	;IF TRIAL SIZE > MAXCOR, SUBSTITUTE MAXCOR
 	MOVE	TB,MAXCOR

	MOVEM	TB,CORSIZ	;SAVE TRIAL CORE SIZE

PS2.:	SUB	TB,SAVEFF	;COMPUTE NO. FREE WORDS
	MOVEM	TB,MAXFRE
	JUMPLE	TB,MORCOR	;NOT ENOUGH CORE
	HRRZ	TE,TR
	HRRZI	TE,SZ.OFT+SZ.DEV+2*SZ.BUF+4(TE)
	IMULI	TE,3		;ABSOLUTE MINIMUM REQUIRED
	SUBI	TB,(TE)		;COMPUTE AMOUNT LEFT
	JUMPL	TB,MORCOR	;NOT ENOUGH CORE
	HRRZ	TE,NWDREC
	IDIVI	TB,2(TE)	;NO. ADDITIONAL AREAS POSSIBLE
	HRRZI	TA,1(TB)	;TOTAL NUMBER OF AREAS
GETC.1:	HRRZM	TA,N		;TABLE SIZE IS N
	HRRZ	TE,NWDREC
	HRRZI	TE,2(TE)
	IMULI	TE,-1(TA)	;AMOUNT OF CORE NEEDED FOR ADDITIONAL AREAS
	HRRZ	TD,MAXFRE
	SUBI	TD,(TE)
	HRRZ	TC,TR
	IDIVI	TD,SZ.DEV+SZ.OFT+2*SZ.BUF+4(TC)
	CAIL	TD,3		;WILL AT LEAST 3 FILES FIT?
	JRST	GETC.2		;YES
	CAIG	TA,1		;NO -- WERE THERE ANY ADDITIONAL AREAS?
	JRST	MORCOR		;NO, THERE JUST ISN'T SPACE
	SOJA	TA,GETC.1	;TRY ONE LESS AREA
GETC.2:	CAMLE	TD,MAXCHA
	HRRZ	TD,MAXCHA	;MAXIMUM AVAILABLE FOR USE
	HRRZM	TD,NFILES
	HRRZ	TE,TR
	IMULI	TD,SZ.DEV+SZ.OFT+2(TE)
	ADD	TD,SAVEFF
	HRRM	TD,JOBFF	;BUMP JOBFF FOR FILE TABLES
	TRO	TD,1777
	CALLI	TD,$CORE	;GET CORE FOR FILE TABLES ONLY
	JRST	ERR.1		;COULDN'T GET IT
	HRRZ	TA,SAVEFF
	HRLS	TA
	HRRI	TA,1(TA)
	HRRZ	TB,JOBREL
	SETZM	-1(TA)
	BLT	TA,(TB)
	HRRZ	TA,SAVEFF
	HRRZI	TA,SZ.DEV(TA)
	HRRZM	TA,FILE1	;START OF FIRST FILE TABLE
	CALLI	TD,$JOB		;GET JOB NUMBER

	MOVEI	TE,3
GETC2A:	IDIVI	TD,^D10
	ADDI	TC,"0"-40
	LSHC	TC,-6
	SOJG	TE,GETC2A
	HLRZM	TB,JOBNUM

	HRRZ	TB,SDFILE
	MOVE	TC,5(TB)
	HRRZM	TC,DEVLOC	;LOCATION OF DEVICES TO USE
	HLRZS	TC
	ANDI	TC,77
	HRRZM	TC,NDEV
	SETZM	CURDEV
	SETZM	CURFIL
GETC.3:	MOVE	TB,[SIXBIT /--.000/]
	HRR	TB,JOBNUM
	MOVEM	TB,(TA)		;FIRST WORD OF FILE NAME
	HRLI	TB,(SIXBIT 'S')	;VALUE-OF-ID
	MOVSM	TB,SZ.OFT(TA)
	HRRZI	TB,1(TA)
	HRLI	TB,[SIXBIT /-INTERMEDIATE-FILE-000000/]
	BLT	TB,4(TA)
	MOVE	TB,[SIXBIT /TMP/]
	MOVEM	TB,SZ.OFT+1(TA)
	AOS	TB,CURFIL
	HRRZM	TA,FILLST-1(TB)	;SET UP FILLST ENTRY
	LDB	TC,[POINT 3,TB,32]
	ADDI	TC,"0"-40
	DPB	TC,[POINT 6,4(TA),29]
	LDB	TC,[POINT 3,TB,35]
	ADDI	TC,"0"-40
	DPB	TC,[POINT 6,4(TA),35]
	LDB	TC,[POINT 12,4(TA),35]
	IORM	TC,SZ.OFT(TA)
	HRRZ	TC,CURDEV
	CAML	TC,NDEV
	SETZB	TC,CURDEV
	AOS	CURDEV
	ADD	TC,DEVLOC
	HRLI	TC,1
	MOVEM	TC,5(TA)
	HRRZI	TC,SZ.DEV+SZ.OFT+2(TA)
	ADD	TC,TR
	CAML	TB,NFILES
	HRRZ	TC,OLDNXT
	HRRZM	TC,6(TA)	;NEXT TABLE LINK
	HRRZ	TC,MXRCSZ
	HRLZM	TC,7(TA)	;RECORD SIZE IN CHARACTERS
	HRRZI	TC,SZ.OFT+2(TA)
	HRLI	TC,040400
	MOVEM	TC,^D8(TA)	;FLAGS AND RECORD AREA ADDRESS
	SETZM	^D9(TA)
	SETZM	^D10(TA)
	HRRZI	TC,SZ.OFT(TA)
	HRLI	TC,440600
	MOVEM	TC,^D11(TA)	;VALUE-OF-ID BYTE POINTER
	SETZM	^D12(TA)
	HRRZI	TC,^D13(TA)
	HRLI	TC,USEPRC
	BLT	TC,SZ.OFT-1(TA)
	HRRZI	TA,SZ.OFT+SZ.DEV+2(TA)
	ADD	TA,TR
	CAMGE	TB,NFILES
	JRST	GETC.3		;DO NEXT TABLE
	HRRZ	TB,SDFILE
	HRRZ	TC,FILE1
	HRRM	TC,6(TB)	;SD FILE POINTS TO FIRST TEMP
	HRRZM	TA,TABLOC
	PUSHJ	PP,RSTAB.	;SET UP BUFFERS
	HRRZ	TB,N
	HRRZI	TE,-1(TB)	;NO. ADDITIONAL RECORD AREAS
	IMUL	TE,NWDREC	;AMOUNT OF CORE NEEDED
	CAMGE	TB,NFILES
	HRRZ	TB,NFILES
	HRRZ	TC,JOBFF
	HRRZ	TA,TABLOC
	HRRZM	TC,TABLOC	;TABLE STARTS HERE
	HRRZI	TA,-SZ.DEV(TA)
	SUB	TA,NWDREC
	HRRZM	TA,(TC)		;LAST FILE'S RECORD AREA IS USED
	ADDI	TC,(TB)
	HRRZM	TC,TEMLOC	;TEMP STARTS HERE
	ADDI	TC,(TB)
	HRRZM	TC,SRTARE	;ADDITIONAL AREAS START HERE
	ADDI	TC,(TE)
	HRRM	TC,JOBFF
	TRO	TC,1777
	CALLI	TC,$CORE
	JRST	ERR.1		;COULDN'T GET THE CORE
	HRRZ	TA,SRTARE
	HRRZ	TC,TABLOC
	HRRZI	TB,1
SET.1:	CAML	TB,N
	JRST	SET.2
	HRRZM	TA,1(TC)
	HRRZI	TC,1(TC)
	ADD	TA,NWDREC
	AOJA	TB,SET.1

SET.2:	HRRZ	TA,SRTARE
	HRLS	TA
	HRRI	TA,1(TA)
	SETZM	-1(TA)
	HRRZ	TB,JOBREL
	BLT	TA,(TB)
	SETZM	CURFIL
SET2.1:	AOS	TA,CURFIL	;OPEN ALL BUT LAST FILE FOR OUTPUT
	CAML	TA,NFILES
	JRST	SET.3
	HRRZI	TB,1
	HRRZM	TB,NSTRAD-1(TA)
	HRRZS	TB,FILLST-1(TA)
	OPENOT			;OPEN FOR OUTPUT
	JRST	SET2.1
SET.3:	SETZM	NSTRAD-1(TA)
	SETZM	CURFIL
	SETZM	IGNFIL
	SETZM	RECREL
	SETZM	RECRET
	HRRZI	TA,1
	HRRZM	TA,LV
	SETZM	NT
	POPJ	PP,


;NOT ENOUGH CORE ALLOCATED NOW -- TRY ONE MORE 1K BLOCK

MORCOR:	MOVEI	TB,2000		;GET INCREMENT
	ADDB	TB,CORSIZ	;INCREMENT THE CURRENT SIZE
	CAMG	TB,MAXCOR	;TOO MUCH?
	JRST	PS2.		;NO--TRY IT

	JRST	ERR.1		;YES--WE LOSE
	SUBTTL	MERGE PHASE

MERGE.:	HRRZ	TA,LV
	CAIN	TA,1
	JRST	M2		;NO INVISIBLE RECORDS
	HRRZM	TA,TCOUNT
	HRRZ	TA,LV
	JRST	M1.5
M1:	PUSHJ	PP,PUTOUT	;PUT OUT ALL VISIBLE RECORDS
	AOS	TA,LV
M1.5:	CAMG	TA,NT
	JRST	M1
	SOS	TA,TCOUNT
	HRRZM	TA,NT
	PUSHJ	PP,SETNXT	;SET UP NEW STRING
	HRRZI	TA,1		;MAKE REMAINING RECORDS VISIBLE
	HRRZM	TA,LV
M2:	PUSHJ	PP,PUTOUT	;PUT OUT CURRENTLY VISIBLE RECORDS
	AOS	TA,LV
	CAMG	TA,NT
	JRST	M2
	MOVE	TA,IGNFIL
	MOVEM	TA,TCOUNT
	PUSHJ	PP,SETNXT
	MOVE	TA,IGNFIL
	CAMN	TA,TCOUNT
	JRST	M3
	HRRZ	TA,NFILES	;DISTRIBUTION PERFECT --- BACK DOWN ONE LEVEL
	SETZM	NSTRAD-1(TA)
	SOJG	TA,.-1
M3:	SETZB	TA,CURFIL
M4:	HRRZ	TB,FILLST(TA)
	HRRZ	TC,^D8(TB)	;RECORD AREA
	MOVE	TD,EOF
	MOVEM	TD,(TC)
	HRRZ	TD,TABLOC
	ADDI	TD,(TA)
	HRRZM	TC,(TD)
	PUSH	PP,TB
	WRTEOF			;WRITE EOF AND CLOSE
	POP	PP,TB
	CLOSIT		;  ALL OUTPUT FILES
	AOS	TA,CURFIL
	HRRZ	TB,NFILES
	CAIGE	TA,-1(TB)
	JRST	M4
	HRRZ	TA,TABLOC
	ADD	TA,NFILES
	HRRM	TA,JOBFF	;NEED LESS TABLE DURING MERGE
	TRO	TA,1777
	CALLI	TA,$CORE
	JRST	ERR.4		;COULDN'T RESET CORE
	SETZB	TA,CURFIL
M5:	HRRZ	TC,FILLST(TA)
	HRRZ	TD,^D8(TC)
	HRRZ	TE,TABLOC
	ADDI	TE,(TA)
	HRRZM	TD,(TE)
	AOS	TA,CURFIL
	CAMGE	TA,NFILES
	JRST	M5
	SETZB	TB,CURFIL
	HRRZ	TA,NFILES
	HRRZI	TA,-1(TA)
	HRRZM	TA,OUTFIL
	SETZM	NSTRAD(TA)
P0:	HRRZ	TB,FILLST(TB)
	OPENIN			;OPEN FILE FOR INPUT
	AOS	TB,CURFIL
	HRRZ	TC,NFILES
	CAIGE	TB,-1(TC)
	JRST	P0
P1:	PUSHJ	PP,RDALL
P1.05:	SETZB	TA,CURFIL
P1.1:	CAMN	TA,OUTFIL
	JRST	P1.2		;NOT AN INPUT FILE
	HLRZ	TB,FILLST(TA)	;STRING COUNT
	SKIPLE	TC,NSTRAD(TA)
	ADD	TB,TC
	JUMPG	TB,P1.3		;MORE MERGE PASSES REQUIRED
P1.2:	HRRZI	TA,1(TA)
	CAMGE	TA,NFILES
	JRST	P1.1
SETRET:	SETOM	RETURN		;'RETURN OKAY' FLAG
	SETZM	RECRET
	POPJ	PP,
RDALL:	SETZB	TA,CURFIL
P1.30:	CAMN	TA,OUTFIL
	JRST	P1.31
	HRRZ	TB,FILLST(TA)
	HRRZ	TD,TABLOC
	ADDI	TD,(TA)
	HRRZ	TC,(TD)
	MOVE	TD,EOS
	MOVEM	TD,(TC)
	IFREAD			;READ UNLESS DUMMY STRING
	HRRZ	TA,CURFIL
	HLRZ	TB,FILLST(TA)	;NO. STRINGS ON FILE
	JUMPE	TB,.+2
	HRRZI	TB,-1(TB)	;DECREMENT IF POSITIVE
	SOSGE	NSTRAD(TA)
	HRLM	TB,FILLST(TA)	;PUT IN DECREMENTED COUNT
P1.31:	AOS	TA,CURFIL
	CAMGE	TA,NFILES
	JRST	P1.30
	POPJ	PP,
P1.3:	HRRZ	TA,OUTFIL
	HRRZS	TB,FILLST(TA)	;CLEAR STRING COUNT
	SETZM	NSTRAD(TA)
	OPENOT			;OPEN FOR OUTPUT
P2:	SETZB	TA,CURFIL
P2.1:	CAMN	TA,OUTFIL
	JRST	P2.2
	HRRZ	TE,TABLOC
	ADDI	TE,(TA)
	HRRZ	TB,(TE)
	MOVE	TE,(TB)
	CAMN	TE,EOF
	JRST	P4
P2.2:	AOS	TA,CURFIL
	CAMGE	TA,NFILES
	JRST	P2.1
P3:	PUSHJ	PP,GETSML	;FIND SMALLEST RECORD
	HRRZ	TA,I
	HRRZ	TC,TABLOC
	ADDI	TC,(TA)
	HRRZ	TB,(TC)
	MOVE	TC,(TB)
	CAMN	TC,EOS
	JRST	P3.1		;ALL AT EOS
	CAMN	TC,EOF
	JRST	RLYEOF
	HRRZI	TE,(TC)
	HRRZ	TC,OUTFIL
	HRRZ	TD,TABLOC
	ADDI	TD,(TC)
	HRRZ	TD,(TD)
	ADD	TE,KEYSIZ
	ADDI	TE,(TD)
	HRLI	TD,(TB)
	BLT	TD,(TE)		;MOVE RECORD TO OUTPUT AREA
	HRRZ	TD,FILLST(TC)
	HRRM	TD,WRITIT
	HRRZ	TA,I
	HRRZ	TC,TABLOC
	ADDI	TC,(TA)
	HRRZ	TB,(TC)
	HRRZ	TC,(TB)
	ADD	TC,KEYSIZ
	HRRZI	TC,1(TC)
	IMULI	TC,6
	DPB	TC,[POINT 12,WRITIT+1,11]
	PUSHJ	PP,WRITIT	;WRITE IT
	HRRZ	TA,I
	HRRZ	TB,FILLST(TA)
	DOREAD			;READ A RECORD
	JRST	P3

P3.1:	HRRZ	TA,OUTFIL
	HRRZ	TB,FILLST(TA)
	HRRZ	TD,TABLOC
	ADDI	TD,(TA)
	HRRZ	TC,(TD)
	MOVE	TD,EOS
	MOVEM	TD,(TC)
	HLRZ	TE,FILLST(TA)
	HRRZI	TE,1(TE)
	HRLM	TE,FILLST(TA)	;BUMP STRING COUNT
	WRTEOS			;WRITE 'END-OF-STRING'
	PUSHJ	PP,RDALL
	JRST	P2

P4:	HRRZ	TA,OUTFIL	;EOF ON CURFIL AFTER ALL REACHED EOS
	HRRZ	TB,FILLST(TA)	;OUTPUT FILE TABLE ADDRESS
	HRRZ	TD,TABLOC
	ADDI	TD,(TA)
	HRRZ	TC,(TD)		;OUTPUT RECORD AREA ADDRESS
	MOVE	TD,EOF
	MOVEM	TD,(TC)
	PUSH	PP,TB
	WRTEOF			;WRITE 'END-OF-FILE'
	MOVE	TB,(PP)
	CLOSIT			;CLOSE FILE
	POP	PP,TB
	OPENIN			;OPEN FILE FOR INPUT
	HRRZ	TA,CURFIL
	HRRZ	TB,FILLST(TA)
	PURGIT
	HRRZ	TA,CURFIL
	EXCH	TA,OUTFIL	;CURFIL WILL BECOME OUTPUT FILE
	HRRZM	TA,CURFIL	;AND OUTPUT FILE WILL BECOME INPUT FILE
	HRRZ	TB,FILLST(TA)
	HRRZ	TD,TABLOC
	ADDI	TD,(TA)
	HRRZ	TC,(TD)
	MOVE	TD,EOS
	MOVEM	TD,(TC)
	IFREAD			;READ FILE UNLESS DUMMY STRING
	HRRZ	TA,CURFIL
	HLRZ	TB,FILLST(TA)
	JUMPE	TB,.+2
	HRRZI	TB,-1(TB)
	SOSGE	NSTRAD(TA)
	HRLM	TB,FILLST(TA)
	JRST	P1.05
GETSML:	SETZB	TA,I
	CAMN	TA,OUTFIL
	HRRZI	TA,1(TA)
	HRRZM	TA,I
	HRRZM	TA,J
GET.01:	AOS	TB,J
	CAMN	TB,OUTFIL
	JRST	GET.01
	CAML	TB,NFILES
	JRST	GETS.3
	HRRZ	TA,I
	HRRZ	TE,TABLOC
	ADDI	TE,(TA)
	HRRZ	TC,(TE)
	MOVE	TE,(TC)		;FLAG WORD FOR RECORD I
	CAME	TE,EOS
	JRST	GETS.1		;NOT EOS
GET.05:	HRRZI	TA,(TB)
	HRRZM	TA,I		;I_J
	JRST	GET.01
GETS.1:	HRRZ	TE,TABLOC
	ADDI	TE,(TB)
	HRRZ	TD,(TE)
	MOVE	TE,(TD)		;FLAG WORD FOR RECORD J
	CAMN	TE,EOS
	JRST	GET.01		;EOS
	HRRZ	TE,KEYSIZ
GET1.5:	HRRZI	TC,1(TC)	;RECORD I
	HRRZI	TD,1(TD)	;RECORD J
	MOVE	TA,(TC)
	CAMN	TA,(TD)
	JRST	GETS.2		;EQUAL SO FAR
	CAMLE	TA,(TD)
	HRRZM	TB,I		;RECORD J < RECORD I
	JRST	GET.01
GETS.2:	SOJG	TE,GET1.5	;MORE KEY WORDS
	JRST	GET.01
GETS.3:	POPJ	PP,
SUBTTL RETURN RECORDS

RETRN.:	SKIPL	RETURN
	JRST	NORET		;RETURN NOT ACTIVE
	PUSHJ	PP,GETSML
	HRRZ	TA,I
	HRRZ	TE,TABLOC
	ADDI	TE,(TA)
	HRRZ	TB,(TE)
	MOVE	TE,(TB)		;RECORD I FLAG WORD
	CAMN	TE,EOS
	JRST	RETDUN		;FINISHED
	CAMN	TE,EOF
	JRST	RETDUN
	HRRZ	TC,NEWREC	;SD-FILE RECORD AREA
	HRRZI	TD,(TC)
	ADDI	TD,-1(TE)
	ADD	TB,KEYSIZ
	HRLI	TC,1(TB)	;START OF RECORD ITSELF
	BLT	TC,(TD)		;MOVE RECORD TO SD-FILE
	HRRZ	TB,FILLST(TA)
	DOREAD			;READ RECORD
	AOS	TA,RECRET
	CAMLE	TA,RECREL
	JRST	BAD1
	POPJ	PP,
RETDUN:	SETZM	RETURN
	MOVE	TA,RECREL
	CAME	TA,RECRET
	JRST	BADCNT
	AOS	(PP)
	POPJ	PP,
	SUBTTL	PROCESS RECORDS RELEASED

RELES.:	MOVEM	TA,RELSIZ	;SIZE OF RECORD RELEASED, IN WORDS
	SKIPN	TA,KEYCNV
	JRST	NOSORT		;NO ACTIVE SORT
	PUSHJ	PP,(TA)		;CONVERT KEYS
	HRRZ	TA,NT		;NO. RECORDS IN TABLE
	CAMGE	TA,N
	JRST	NOTFUL		;TABLE NOT FULL
	PUSHJ	PP,BINSER	;FIND PLACE IN TABLE FOR RELEASED RECORD
	HRRZ	TA,LV
	CAMG	TA,N
	JRST	P6		;SOME RECORDS ARE VISIBLE
	PUSHJ	PP,SETNXT	;SET UP TO START NEW STRING
	HRRZI	TA,1
	HRRZM	TA,LV		;MAKE ALL VISIBLE
P6:	PUSHJ	PP,PUTOUT	;OUTPUT TABLE(LV) RECORD
	HRRZ	TB,LV
	ADD	TB,TABLOC
	HRRZ	TA,-1(TB)	;CORE LOCATION OF RECORD PUT OUT
	HRRZ	TB,RELSIZ	;SIZE OF RECORD RELEASED
	HRRZM	TB,(TA)		;FLAG WORD FOR NEW RECORD
	HRRZI	TB,1(TA)	;FIRST LOCATION FOR KEYS
	HRL	TB,KEYLOC
	HRRZ	TC,KEYSIZ
	ADDI	TC,(TA)
	BLT	TB,(TC)		;MOVE KEYS TO SAVE AREA
	HRRZI	TD,1(TC)	;FIRST LOCATION FOR RECORD
	HRL	TD,NEWREC	;NEWREC POINTS TO SD-FILE RECORD AREA
	ADD	TC,RELSIZ
	BLT	TD,(TC)		;MOVE RECORD
	HRRZ	TA,I		;I IS INDEX OF TABLE ENTRY NEW RECORD
	CAMN	TA,LV		;SHOULD FOLLOW--0 IF IT PRECEDES ALL
	JRST	RELXIT		;SIMPLE REPLACEMENT
	CAML	TA,LV
	JRST	Q1		;NEW RECORD WILL BE VISIBLE
	HRRZ	TB,LV
	CAIG	TB,1(TA)
	JRST	P7		;NEW RECORD REPLACED OLD ONE INVISIBLY
	HRRZ	TD,TABLOC
	ADDI	TD,-1(TB)
	HRRZ	TE,(TD)
	HRRZ	TD,TABLOC
	ADDI	TD,(TA)
	HRLZI	TC,(TD)		;TABLE(I+1)
	ADD	TA,TEMLOC
	HRRI	TC,(TA)		;TEMP(I+1)
	MOVS	TD,TC		;TEMP(I+1),TABLE(I+1)
	ADD	TB,TEMLOC
	BLT	TC,-2(TB)	;TABLE(I+1) THRU TABLE(LV-1) MOVED TO TEMPS
	HRRI	TD,1(TD)	;TEMP(I+1),TABLE(I+2)
	HRRZ	TB,LV
	ADD	TB,TABLOC
	BLT	TD,-1(TB)
	HRRZ	TA,I
	ADD	TA,TABLOC
	HRRZM	TE,(TA)
P7:	AOS	LV
RELXIT:	AOS	RECREL
	POPJ	PP,
Q1:	HRRZ	TA,LV
	ADD	TA,TABLOC
	HRRZ	TE,-1(TA)


	HRLZI	TB,(TA)		;TABLE(LV)
	HRRI	TB,-1(TA)	;TABLE(LV-1)
	HRRZ	TC,I
	ADD	TC,TABLOC
	BLT	TB,-2(TC)	;TABLE(I-2)
	HRRZM	TE,-1(TC)	;TABLE(I-1)
	JRST	RELXIT
NOTFUL:	SKIPLE	TA,NT
	PUSHJ	PP,BINSER
	SKIPE	TA,NT
	CAMG	TA,I
	JRST	NOTF.1
	HRRZ	TA,I
	HRRZ	TB,TABLOC
	ADDI	TB,(TA)		;TABLE(I+1)
	HRRZ	TC,TEMLOC
	HRLZS	TB
	HRRI	TB,(TC)
	ADDI	TB,(TA)		;XWD TABLE(I+1),TEMP(I+1)
	MOVS	TD,TB
	HRRZ	TE,NT
	ADDI	TC,-1(TE)	;TEMP(NT)
	BLT	TB,(TC)
	HRRI	TD,1(TD)	;XWD TEMP(I),TABLE(I+1)
	HRRZ	TC,TABLOC
	ADDI	TC,(TE)		;TABLE(NT+1)
	MOVE	TB,(TC)
	BLT	TD,(TC)
	HRRZ	TA,I
	ADD	TA,TABLOC
	MOVEM	TB,(TA)		;TABLE(I+1)
	JRST	NOTF.2
NOTF.1:	ADD	TA,TABLOC
NOTF.2:	HRRZ	TA,(TA)		;RECORD AREA FOR NEW RECORD
	HRRZ	TC,RELSIZ
	HRRZM	TC,(TA)		;FLAG WORD
	HRRZI	TB,1(TA)
	HRL	TB,KEYLOC
	HRRZ	TC,KEYSIZ
	ADDI	TC,(TA)
	BLT	TB,(TC)		;KEYS
	HRRZI	TD,1(TC)
	HRL	TD,NEWREC
	ADD	TC,RELSIZ
	BLT	TD,(TC)
	AOS	NT
	JRST	RELXIT
	SUBTTL	CLEAN UP AFTER COBOL SORT

ENDS.:	SETZB	TA,CURFIL
END.1:	CAMN	TA,OUTFIL
	JRST	END.2
	HRRZ	TB,FILLST(TA)
	PURGIT
END.2:	AOS	TA,CURFIL
	CAMGE	TA,NFILES
	JRST	END.1

	SETZM	KEYCNV
	SETZM	RETURN
	HRRZ	TA,SDFILE
	HRRZ	TB,OLDNXT
	HRRM	TB,6(TA)
	HRRZ	TA,SAVREL
	HRRZ	TB,SAVEFF
	HRRM	TB,JOBFF
	CALLI	TA,$CORE
	JRST	ERR.5

	IFN TIMING,<
	PUSHJ	PP,TIMER
	>

	POPJ	PP,
	SUBTTL	OUTPUTS RECORD LV ON CURRENT STRING

PUTOUT:	HRRZ	TA,LV
	ADD	TA,TABLOC
	HRRZ	TB,-1(TA)	;ADDRESS OF RECORD IN SOR]2AREA
	HRRZ	TC,(TB)		;NO. WORDS IN REAL RECORD
	ADD	TC,KEYSIZ
	HRRZI	TC,1(TC)	;ADD KEY AND FLAG WORD
	HRRZ	TE,CURFIL
	HRRZ	TD,FILLST(TE)	;FILE TABLE ADDRESS
	HRRM	TD,WRITIT
	HRRZ	TE,^D8(TD)	;RECORD AREA
	HRLI	TE,(TB)
	HRRZI	TD,-1(TE)
	ADDI	TD,(TC)		;ADD KEY SIZE AND FLAG WORD
	BLT	TE,(TD)		;MOVE TO RECORD AREA
	IMULI	TC,6		;NO. OF CHARACTERS
	DPB	TC,[POINT 12,WRITIT+1,11]
	JRST	WRITIT
	SUBTTL	SET UP NEXT FILE TO RECEIVE OUTPUT STRING

SETNXT:	HRRZ	TA,CURFIL
	HLRZ	TB,FILLST(TA)
	HRRZI	TB,1(TB)		;INCREMENT STRING COUNT ON
	HRLM	TB,FILLST(TA)		;CURRENT FILE BY 1
	HRRZ	TB,FILLST(TA)		;FILE TABLE ADDRESS FOR CURRENT FILE
	MOVE	TC,EOS			;END-OF-STRING FLAG
	HRRZ	TD,^D8(TB)		;RECORD AREA ADDRESS
	MOVEM	TC,(TD)
	WRTEOS			;WRITE 'END-OF-STRING'
	HRRZ	TC,CURFIL
	SOS	NSTRAD(TC)	;DECREMENT NO. STRINGS TO ADD
SNX0.1:	AOS	TC,CURFIL
	HRRZ	TD,NFILES
	IDIVI	TC,-1(TD)
	HRRZM	TB,CURFIL	;ADVANCE CURFIL TO NEXT
	CAMN	TB,IGNFIL	;USABLE OUTPUT FILE
	JRST	SNX0.1
	SKIPLE	NSTRAD(TB)
	POPJ	PP,		;ADD STRING TO HIM
SNX0.2:	AOS	TC,IGNFIL
	HRRZ	TD,NFILES
	IDIVI	TC,-1(TD)
	HRRZM	TB,IGNFIL	;ADVANCE IGNFIL
	SETZM	NSTRAD(TB)
	HLRZ	TA,FILLST(TB)	;NO. STRINGS ON IGNFIL
	SETZ	TB,
SNX0.3:	CAME	TB,IGNFIL
	HRRZM	TA,NSTRAD(TB)	;IS NO. TO ADD TO OF OTHERS
	HRRZI	TB,1(TB)
	CAMGE	TB,NFILES
	JRST	SNX0.3
	HRRZ	TB,IGNFIL
	HRRZI	TB,1(TB)
	IDIVI	TB,-1(TD)
	HRRZM	TA,CURFIL	;CURFIL_IGNFIL+1
	POPJ	PP,
SUBTTL BINARY SEARCH OF KEYS FOR RECORDS IN CORE

BINSER:	HRRZ	TA,NT
	HRRZI	TB,(TA)
	ANDI	TA,-1(TB)
	JUMPN	TA,.-2		;FIND LARGEST POWER OF 2 <= NT
	HRRZI	TA,(TB)
	HRRZM	TA,J
	SETZ	TD,		;COMPARISON INDICATOR
	HRRZM	TA,I
B1:	ADD	TA,TABLOC
	HRRZ	TA,-1(TA)	;LOCATION OF RECORD I
	HRRZI	TA,1(TA)	;LOCATION OF KEYS FOR RECORD I
	HRRZ	TB,KEYLOC	;LOCATION OF KEYS FOR NEW RECORD
	HRRZ	TC,KEYSIZ	;NO. OF WORDS OF KEYS
B1.1:	SOJL	TC,B3		;COMPARISON COMPLETE
	MOVE	TE,(TA)		;KEY WORD FOR RECORD I
	CAMN	TE,(TB)
	JRST	B1.2		;EQUAL SO FAR
	CAMG	TE,(TB)
	TDZA	TD,TD		;RECORD I < NEW RECORD
	SETO	TD,		;RECORD I > NEW RECORD
	HRRZ	TA,J
	CAIG	TA,1
	JRST	B1.3		;COMPARISONS COMPLETE
	LSH	TA,-1
	HRRZM	TA,J		;J_J/2
	CAIGE	TD,0
	MOVNS	TA		;RECORD I > NEW RECORD
	ADDB	TA,I
	JUMPL	TD,B1		;CHECK NEXT RECORD
	CAMG	TA,NT		;OVER TOP OF TABLE?
	JRST	B1		;NO
	SUB	TA,J		;YES, SO SET I TO LAST I WHICH WAS
	HRRZI	TA,1(TA)	;WITHIN BOUNDS, + 1
	HRRZM	TA,I
B2:	CAMLE	TA,NT
	JRST	B2.4		;OVER TOP OF TABLE
	ADD	TA,TABLOC
	HRRZ	TA,-1(TA)	;LOCATION OF RECORD I
	HRRZI	TA,1(TA)	;LOCATION OF RECORD I KEYS
	HRRZ	TB,KEYLOC	;NEW RECORD KEY LOCATION
	HRRZ	TC,KEYSIZ
B2.1:	SOJL	TC,B3		;COMPARISON COMPLETE
	MOVE	TE,(TA)
	CAMN	TE,(TB)
	JRST	B2.2		;EQUAL SO FAR
	CAML	TE,(TB)
	JRST	B2.4		;RECORD I > NEW RECORD
	AOS	TA,I
	JRST	B2		;TRY NEXT
B2.2:	HRRZI	TA,1(TA)
	AOJA	TB,B2.1		;NEXT WORDS OF KEYS

B1.2:	HRRZI	TA,1(TA)
	AOJA	TB,B1.1

B1.3:	JUMPGE	TD,B3
B2.4:	SOS	I		;RECORD I > NEW, I-1 < NEW
B3:	POPJ	PP,
	SUBTTL TIMING TYPE-OUT ROUTINE

	IFN TIMING,<

TIMER:	SETZ	TE,
	CALLI	TE,$RTIME
	SUB	TE,STIME
	ADDI	TE,^D500	;ROUND UP TO NEAREST SECOND
	IDIVI	TE,^D1000	;TIME IN SECONDS
	IDIVI	TE,^D3600
	HRRZM	TD,STIME
	TTCALL	3,[ASCIZ "SORT COMPLETED: RUN TIME "]
	JUMPLE	TE,TIMER1
	PUSHJ	PP,TYPVAL
	TTCALL	3,[ASCIZ " HOURS, "]
TIMER1:	MOVE	TE,STIME
	IDIVI	TE,^D60
	HRRZM	TD,STIME
	JUMPE	TE,TIMER2
	PUSHJ	PP,TYPVAL
	TTCALL	3,[ASCIZ " MINUTES, "]
TIMER2:	HRRZ	TE,STIME
	PUSHJ	PP,TYPVAL
	TTCALL	3,[ASCIZ " SECONDS
"]
	MOVE	TE,RECREL
	CAME	TE,RECRET
	JRST	TIMER3
	PUSHJ	PP,TYPVAL
	TTCALL	3,[ASCIZ " RECORDS SORTED
"]
	POPJ	PP,

TIMER3:	PUSHJ	PP,TYPVAL
	TTCALL	3,[ASCIZ " RECORDS RELEASED, "]
T4:	MOVE	TE,RECRET
	PUSHJ	PP,TYPVAL
	TTCALL	3,[ASCIZ " RECORDS RETURNED
"]
	POPJ	PP,

TYPVAL:	IDIVI	TE,^D10
	HRLM	TE+1,(PP)
	SKIPE	TE
	PUSHJ	PP,TYPVAL
	HLRZ	TE,(PP)
	ADDI	TE,"0"
	TTCALL	1,TE
	POPJ	PP,

	>
	SUBTTL ERROR ROUTINES

WRTERR:	STOPIT	<INVALID KEY ON OUTPUT SORT TEMP FILE.>
ATEND:	STOPIT	<AT END ON SORT TEMP FILE.>

ERR.1:	STOPIT <INSUFFICIENT CORE FOR SORT.>
ERR.2:	STOPIT <TOO MANY OPEN FILES; CAN'T SORT.>
ERR.3:	STOPIT <RESTRUCTURED RECORD TOO LARGE FOR SORT.>
NORET:	STOPIT	<RETURN ENCOUNTERED, SORT NOT ACTIVE.>
BADCNT:	CAML	TA,RECRET
	JRST	BAD2
BAD1:	STOPIT	<RETURNED MORE RECORDS THAN RELEASED.>
BAD2:	STOPIT	<SOME RELEASED RECORDS LOST SOMEWHERE.>
ERR.4:	STOPIT <COULDN'T RESET CORE AT START OF MERGE.>
RLYEOF:	STOPIT	<EOF PRECEDES EOS ON MERGE FILE.>
NOSORT:	STOPIT	<RELEASE EXECUTED WITH NO SORT ACTIVE.>
ERR.5:	STOPIT	<COULDN'T GIVE UP CORE AFTER SORT.>
	SUBTTL USE PROCEDURES

USEPRC:	XWD	0,E1	;USE PROCEDURE FOR ERROR
	XWD	E2,E3	;BEFORE BEGINNING REEL, FILE
	XWD	E4,E5	;AFTER  BEGINNING REEL, FILE
	XWD	E6,E7	;BEFORE ENDING REEL, FILE
	XWD	E8,E9	;AFTER  ENDING REEL, FILE

E1:	STOPIT	<ERROR IN SORT I-O.>
E2: E3: E4: E5: E6: E7: E8: E9:
	POPJ	PP,

EOS:	XWD	-2,-2		;END-OF-STRING FLAG
EOF:	XWD	0,0		;END-OF-FILE FLAG

;WRITE ROUTINE (COPIED TO WRITIT DURING SETUP)

WRITER:	WRITE.	0
	XWD	0,0
	POPJ	PP,
	JRST	WRTERR		;INVALID KEY
	SUBTTL	IMPURE AREA
EXTERNAL MEMRY.
EXTERNAL WRITIT
EXTERNAL MAXCHA
EXTERNAL TCOUNT
EXTERNAL STIME
EXTERNAL FILE1
EXTERNAL SDFILE
EXTERNAL FILLST
EXTERNAL I
EXTERNAL J
EXTERNAL N
EXTERNAL NT
EXTERNAL KEYSIZ
EXTERNAL KEYLOC
EXTERNAL KEYCNV
EXTERNAL LV
EXTERNAL NFILES
EXTERNAL OLDNXT
EXTERNAL MXRCSZ
EXTERNAL NEWREC
EXTERNAL NWDREC
EXTERNAL S
EXTERNAL CURFIL
EXTERNAL IGNFIL
EXTERNAL RECREL
EXTERNAL RECRET
EXTERNAL RETURN
EXTERNAL RELSIZ
EXTERNAL OUTFIL
EXTERNAL NSTRAD
EXTERNAL TABLOC
EXTERNAL TEMLOC
EXTERNAL CURDEV
EXTERNAL DEVLOC
EXTERNAL JOBNUM
EXTERNAL MAXFRE
EXTERNAL NDEV
EXTERNAL SAVEFF
EXTERNAL SAVREL
EXTERNAL CORSIZ
EXTERNAL MAXCOR
EXTERNAL SRTARE

	XLIST	;LET'S NOT PRINT ALL THOSE LITERALS
	LIT
	LIST


	END

    m _Ë