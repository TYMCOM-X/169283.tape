	TITLE	FILDMP
	SUBTTL		BY:  BUREN W. HOFFMAN   JUNE '70

;	FILDMP.1(NO SECURITY SWITCHES)
;	FILDMP.2(HANDLES SECURITY SWITCH CODES)
;****** FILDMP CREATES AN ASCII OUTPUT FILE, FORMATTED FOR THE
;	LINE PRINTER, BUT MAY BE ROUTED TO ANY DESIRED OUTPUT
;	DEVICE.  (NOTE: A SPECIAL OUTPUT FORMAT IS PRODUCED
;	FOR OUTPUT TO THE TTY.)
;	THE ASCII FILE IS A DUMP OF THE CONTENTS OF THE SPECIFIED
;	FILE.
;
;	THE DUMP INDICATES THE CONTENTS OF THE SOURCE FILE IN
;	OCTAL, ASCII, AND SIXBIT TRANSLATIONS.
;
;	UNLESS FORCED WITH THE /L SWITCH, ANY OUTPUT SENT TO
;	THE LINE PRINTER IS QUEUED FOR LATER PRINTING.
;****** (NOTE CONDITIONAL ASSEMBLY FOR THIS FEATURE)

	EXTERN	JOBFF

	VERFDP==5		;FILDMP VERSION NUMBER


;************CHANNELS
	OCH==0		;OUTPUT CHANNEL
	ICH==1		;INPUT CHANNEL


;************ACCUMULATORS
	FLAG=0		;PROGRAM FLAGS
	CHR=1		;TEMP AC, FOR READ/WRITE CHAR.
	A=2		;A,B,C,& D USED MAINLY FOR
	B=3		;SPEC BLOCKS IN I/O UUO'S
	C=4
	D=5
	BP1=6		;POINTER FOR BYTE TO PICK UP
	BP2=7		;POINTER FOR BYTE DEST.
	ARG=10		;TO PICK UP TTY COMMAND ARGUMENTS
	AC1=11		;AC1,AC2,& AC3 ARE TEMP. AC'S.
	AC2=12
	AC3=13
	LCTR=14		;LOCATION COUNTER FOR FILE
	LINE=15		;COUNTER FOR PRINTED LINES
	PD=16		;PUSH-DOWN POINTER
	PGCT=17
		;PAGE COUNT

;************FLAGS
	EOF==1000		;TO DENOTE END-OF-FILE
	MATCH==20		;TO SIGNAL TWO OR MORE IDENTICAL LINES
	ALLDUN==40		;TO SIGNAL END OF COMMAND STRING
	QUEUE==100		;FLAG TO PUT OUTPUT IN PRINT QUEUE
	TTYOUT==10		;FLAG TO SIGNAL THIS IS OUTPUT TO TTY
	DVOUT==1		;OUTPUT FLAG FOR DEVCHR
	DVIN==2			;INPUT FLAG FOR DEVCHR
	LPTOUT==40000		;LINE PRINTER FLAG
	DVDSK==200000		;DISK FLAG
	VSVDMP==200		;FLAG FOR TRANSLATION OF SAVE FILE
	VXPDMP==400		;FLAG FOR EXPANSION OF SAVE FILE
	VSXDMP==2000		;FLAG FOR DUMP OF SAVE FILES
	F.REGO==EOF+MATCH+ALLDUN


	REENTR==124
	JOBVER==137

	LOC	REENTR
	EXP	FILDMP
	RELOC
	LOC	JOBVER
	EXP	VERFDP
	RELOC




;************COND. ASSEMBLY
;	IFL	BKGFL,<LPT OUTPUT NOT QUEUED>
;	IFE	BKGFL,<LPT OUTPUT QUEUED FOR PRINTING BY BKGRND>
;	IFG	BKGFL,<LPT OUTPUT QUEUED FOR PRINTING BY PRINTR>
;
;	IFN	SAVXT,<ALLOW TRANSLATION & EXPANSION OF SAVE FILES>
;*************

	BKGFL==0
	SAVXT==1




	REPEAT	0,<

** FOR OUTPUT QUEUED FOR PRINTING BY BKGRND, THE FILE STRUCTURE IS --

	WORD 1	- FILENAME OF FILE BEING DUMPED
	WORD 2	- EXTENSION IN LEFT HALF
		  AND IN RIGHT HALF ZERO
	WORD 3	- USER PROJECT,PROGRAMMER NUMBER

	WORD 4
	  .
	  .
	  .
	WORD N	- WORD 4 - WORD N IS THE ASCII DATA TO BE PRINTED


** FOR OUTPUT QUEUED FOR PRINTING BY PRINTR, THE FILE STRUCTURE IS --

	FILE IN [3,3] -- THE COMMAND FILE
	WORD 1	- USER PROJECT,PROGRAMMER NUMBER
	WORD 2	- FILENAME OF FILE BEING DUMPED
	WORD 3	- EXTENSION IN LEFT HALF
		  AND 400000 IN RIGHT HALF
		  (TO CAUSE ONE COPY TO PRINT, AND DELETE FILE
		   AFTER PRINTING)
	WORD 4	- ZERO (END OF FILE)

	FILE IN USER'S DISK AREA -- THE OBJECT FILE
	THIS FILE CONTAINS ONLY ASCII DATA FOR PRINTING.


NOTE:	FOR BKGRND THE ASCII TEXT IS A PART OF THE COMMAND FILE, BUT
	FOR PRINTR THE ASCII TEXT IS A SEPARATE FILE IN THE USER'S
	DISK AREA.

	THE EXTENSION GIVEN TO DUMPED FILES FOR LISTING IS  .DMP
>




	REPEAT	0,<
************

	SWITCHES --
		/L -FORCES LINE PRINTER OUTPUT TO THE LPT, WITHOUT
		    INTERMEDIATE SPOOLING.
		/S -CAUSES A FILE WRITTEN IN THE SAVE FORMAT TO BE READ,
		    EXPANDED, AND INTERPRETED.  THE INTERPRETATION
		    INCLUDES THE OCTAL, ASCII, AND SIXBIT TRANSLATIONS,
		    PLUS A DECODING AS IN AN ASSEMBLY INSTRUCTION.
		/E -CAUSES A FILE WRITTEN IN THE SAVE FORMAT TO BE
		    READ, EXPANDED, AND REWRITTEN ON THE SPECIFIED
		    OUTPUT DEVICE, AND GIVEN THE EXTENSION (.COR).
		    THE OUTPUT IS BINARY, AND WILL PROVIDE THE
		    EQUIVALENT OF A CORE IMAGE.
		/D -CAUSES A FILE WRITTEN IN THE SAVE FORMAT TO BE READ,
		    EXPANDED, AND OUTPUT AS AN ORDINARY DUMP FILE.
		/T -CAUSES DUMP OUTPUT TO BE FORMATTED FOR TTY PAGE,
		    FOR NON-TTY DEVICE.

		NOTE: SWITCHES MUST IMMEDIATELY FOLLOW THE OUTPUT
		      DEVICE IN THE COMMAND STRING.
>
	PAGE
FILDMP:	CALLI	0		;RESET ALL I/O
	MOVE	PD,STAK		;INITIALIZE PUSH-DOWN POINTER
	MOVSI	AC1,(SIXBIT /DSK/)
	MOVEM	AC1,INDEV	;SETUP DEFAULT DEVICES
	MOVEM	AC1,OUTDEV
	CALLI	AC1,4		;GET DEVCHR AND SAVE FOR LATER
	MOVEM	AC1,OUTCHR#	;SAVE THE DEVCHR
	MOVE	AC1,[XWD 15,16]
	CALLI	AC1,41		;GETTAB
	MOVSI	AC1,(SIXBIT .DSK.)	;DEFAULT
	MOVEM	AC1,QSTR#	;QUEUEING DEVICE
	MOVEI	AC2,4		;DEFAULT OF FOUR WORDS PER LINE
	MOVEM	AC2,WDPL#	;NUM. OF WORDS PER LINE IN DUMP
	MOVEI	FLAG,0		;INITIALIZE FLAG
	TTCALL	11,0		;FLUSH INPUT BUFFER
	TTCALL	3,[ASCIZ /
*/]				;PRINT ASTERISK ON USER TTY
	JSR	PARSE		;GET OUTPUT DEV.
	TLNE	FLAG,ALLDUN	;ANYTHING ENTERED ?
	JRST	NOINP		;NO
	CAIE	CHR,32		; (:) DEVICE SPECIFIED ?
	JRST	DSKM2		;NO -- USE DEFAULT
	JUMPE	ARG,WHAT	;IF NO DEVICE NAME, ERROR
	MOVEM	ARG,OUTDEV	;SAVE DEVICE NAME
	CALLI	ARG,4		;GET DEVCHR
	TLNN	ARG,DVOUT	;CAN IT OUTPUT ?
	JRST	BADOUT		;NO
	MOVEI	AC1,37		;LINE COUNT MASK FOR 4 WORD LINE
	MOVEM	AC1,LINMSK#	;SAVE THE LINE MASK

	IFGE	BKGFL,<
	TLNE	ARG,LPTOUT	;OUTPUT TO LINE PRINTER ?
	TLO	FLAG,QUEUE	;YES, SET QUEUE FLAG AS DEFAULT
>
	MOVEM	ARG,OUTCHR	;SAVE THE DEVCHR
	JSR	PARSE		;GET LEFT ARROW

DSKM2:	CAIN	CHR,77		;(_)
	JRST	DSKOUT		;GET THE INPUT DEVICE
	CAIE	CHR,17		; (/)
	JRST	WHAT		;ERROR
	JSR	PARSE		;GET SWITCH
	CAMN	ARG,[SIXBIT /L/]
	TLZ	FLAG,QUEUE	;TURN OFF QUEUE FLAG

	IFN	SAVXT,<
	CAMN	ARG,[SIXBIT /S/]	;TRANSLATE SAVE FILE ?
	TLO	FLAG,VSVDMP	;YES
	CAMN	ARG,[SIXBIT /E/]	;EXPAND SAVE FILE
	TLO	FLAG,VXPDMP	;YES
	CAMN	ARG,[SIXBIT /D/]	;SAVE DUMP ?
	TLO	FLAG,VSXDMP		;YES
>
	CAMN	ARG,[SIXBIT /T/]	;TTY FORMAT ?
	TLO	FLAG,TTYOUT		;YES

	IFN	SAVXT,<
	MOVE	ARG,OUTCHR	;GET THE DEVCHR
	TLNN	FLAG,VXPDMP	;EXPANDING SAVE FILE ?
	JRST	DSKM2		;NO
	TRNN	ARG,10000	;YES, IS BINARY MODE LEGAL ?
	JRST	BDOMOD		;NO
>
	JRST	DSKM2		;YES, GET NEXT INPUT

DSKOUT:
	IFGE	BKGFL,<
	MOVE	AC1,QSTR	;GET NAME OF QUEUEING DEVICE
	TLNE	FLAG,QUEUE	;QUEUED ?
	MOVEM	AC1,OUTDEV	;YES, OUTPUT TO QUEUE ON DSK
>


	MOVE	AC1,OUTCHR	;GET DEVCHR
	TLNE	AC1,TTYOUT	;IS IT A TTY ?
	TLO	FLAG,TTYOUT	;YES, SET FLAG
	TLNN	FLAG,TTYOUT	;IS FLAG SET ?
	JRST	.+5		;NO
	MOVEI	AC1,2
	MOVEM	AC1,WDPL	;TWO WORDS PER LINE
	MOVEI	AC1,17
	MOVEM	AC1,LINMSK	;SET THE LINE MASK

	IFN	SAVXT,<
	MOVEI	AC1,0		;INITIALIZE SWITCH COUNT
	TLNE	FLAG,VXPDMP	;THIS SWITCH ?
	ADDI	AC1,1		;YES
	TLNE	FLAG,VSVDMP	;THIS SWITCH ?
	ADDI	AC1,1		;YES
	TLNE	FLAG,VSXDMP	;THIS SWITCH
	ADDI	AC1,1		;YES
	CAILE	AC1,1		;MORE THAN ONE OF THESE SWITCHES ?
	JRST	WHAT		;YES
	MOVEI	AC1,1		;ASCII MODE NORMAL
	TLNE	FLAG,VXPDMP	;EXPANDING SAVE FILE ?
	MOVEI	AC1,14		;YES, USE BINARY MODE
	HRRM	AC1,.+1		;PUT IN THE CORRECT MODE
>

	INIT	OCH,1		;INIT THE OUTPUT DEVICE
OUTDEV:	Z
	XWD	OBUF,0
	JRST	NOOUT		;CAN'T INIT DEV
	MOVEI	AC1,BUF2
	MOVEM	AC1,JOBFF
	OUTBUF	OCH,2		;ESTABLISH TWO OUTPUT BUFFERS


REGO:	TLZ	FLAG,F.REGO	;RE-INITIALIZE FLAG
	JSR	PARSE		;GET INPUT DEV, OR FILENAME
	CAIE	CHR,32		;  (:)
	SKIPA	AC1,INDEV	;PICK UP DEFAULT INPUT DEVICE NAME
	MOVE	AC1,ARG
	MOVEM	AC1,INDEV	;SAVE INPUT DEV NAME
	CALLI	AC1,4		;DEVICE CHARACTERISTICS
	TLNN	AC1,DVIN	;CAN IT INPUT ?
	JRST	BADIN		;NO
	TRNN	AC1,10000	;IS BINARY MODE LEGAL ?
	JRST	BADMOD		;NO
	CAIN	CHR,32		; (:)
	JSR	PARSE		;NOW GET FILENAME

FILNAM:	MOVEM	ARG,NAME#	;SAVE THE FILENAME
	SETZM	EXT#		;SET EXT. IN CASE NULL
	SETZM	OWNER#		;ZERO PPN, IN CASE THIS USER
	JUMPE	ARG,WHAT	;IMBEDDED BLANKS, & MULT.DELIM ILLEG
	CAIN	CHR,14		; (,)
	JRST	GOTIT		;GO PROCESS THIS FILE
	TLNE	FLAG,ALLDUN	;C.R. MEANS DONE, SO PROC. FILE
	JRST	GOTIT
	CAIE	CHR,16		; (.)
	JRST	.+3		;NULL EXTENSION
	JSR	PARSE		;GET EXTENSION
	HLLZM	ARG,EXT		;SAVE THE EXT
	CAIN	CHR,14		; (,)
	JRST	GOTIT		;GO PROCESS FILE
	TLNE	FLAG,ALLDUN	;FINISHED WITH LINE ?
	JRST	GOTIT		;YES, GO PROCESS
	CAIE	CHR,73		; ([)
	JRST	WHAT		;ERROR -- EXPECTED LEFT BRACKET
	JSR	PARSE		;GET PROJECT NUMBER
	CAIE	CHR,14		; (,)
	JRST	WHAT		;EXPECTED COMMA
	JSR	SIXBIN		;CONVERT SIXBIT NUMBER TO BINARY
	HRLZM	ARG,OWNER	;SAVE THE PROJECT NUMBER
	JSR	PARSE		;GET PROGRAMMER NUMBER
	CAIE	CHR,75		; (])
	JRST	WHAT		;ERROR -- EXPECTED RIGHT BRACKET
	JSR	SIXBIN
	HRRM	ARG,OWNER	;AND SAVE THE PROGRAMMER NUMBER
	JSR	PARSE		;GET NEXT DELIMETER AFTER L.BRKET
	CAIN	CHR,17		;(/)
	PAGE
GOTIT:	MOVEM	CHR,DELMM#	;SAVE THE CURRENT DELIMETER
	INIT	ICH,14		;BINARY READ
INDEV:	Z
	XWD	0,IBUF
	JRST	NOIN		;CAN'T INIT DEVICE
	MOVEI	AC1,BUF1
	MOVEM	AC1,JOBFF
	INBUF	ICH,2		;ESTABLISH TWO INPUT BUFFERS
	MOVE	AC1,OUTCHR	;GET OUTPUT DEVCHR
	TLNE	AC1,TTYOUT	;TTY OUTPUT ?
	JRST	NOLABL		;YES, DON'T TYPE LABEL
	TTCALL	3,[ASCIZ /FILDMP: /]	;TYPE OUT    FILDMP:
	MOVEI	AC1,NAME	;ADDRESS OF FILENAME
	JSR	SIXPRT		;TYPE OUT FILENAME
	SKIPN	EXT		;NULL EXTENSION ?
	JRST	.+4		;YES
	TTCALL	3,[ASCIZ /./]	;TYPE PERIOD
	MOVEI	AC1,EXT		;ADDRESS OF EXTENSION
	JSR	SIXPRT		;TYPE OUT EXTENSION
NOLABL:
	IFE	BKGFL,<
	TLNE	FLAG,QUEUE	;QUEUED DEST. ?
	JRST	QUEIT		;YES
>

	MOVE	A,NAME		;PICK UP THE FILENAME
	MOVSI	B,(SIXBIT /DMP/)	;AND EXT=.DMP

	IFN	SAVXT,<
	TLNE	FLAG,VXPDMP	;EXPANDING SAVE FILE ?
	MOVSI	B,(SIXBIT /COR/)	;YES, USE THIS EXTENSION
>

	SETZB	C,D
	ENTER	OCH,A		;ENTER THE NEW FILE
	JRST	NOWRIT		;ERROR

QDONE:	MOVE	A,NAME		;FILE TO BE DUMPED
	MOVE	B,EXT
	MOVEI	C,0
	MOVE	D,OWNER		;PPN OF FILE OWNER
	LOOKUP	ICH,A		;FIND THE FILE
	JRST	NOFIL		;CAN'T FIND IT

	IFN	SAVXT,<
	TLNN	FLAG,VXPDMP	;EXPANDING SAVE FILE ?
>

	JSR	MAKHDG		;NO, CREATE PAGE HEADING
	JSR	DUMPIT		;GO DUMP THE FILE

GOBAK:	CLOSE	OCH,0		;CLOSE THE OUTPUT CHANNEL
	RELEAS	ICH,0		;RELEASE, BECAUSE MAYBE NEW DEVICE
;************ FOLLOWING CODE WRITES COMMAND FILE TO  PRINTR

	IFG	BKGFL,<
	TLNN	FLAG,QUEUE	;QUEUED ?
	JRST	GOBAK1		;NO, DON'T WORRY FURTHER
FD2:	MOVEI	AC1,(SIXBIT /000/)
FD2A:	MOVSI	A,(SIXBIT /PNT/)	;BUILD A FILENAME PNTXXX.TMP
	HRR	A,AC1		;PUT IN THE XXX
	MOVSI	B,(SIXBIT /TMP/)	;EXTENSION = TMP
	MOVEI	C,0
	MOVE	D,COMFIL	;QUEUE TO THIS UFD
	LOOKUP	OCH,A		;IS THERE ALREADY ONE LIKE THIS ?
	TRNE	B,-1		;NO, BUT IS THERE A DIR. ?
	JRST	CANT		;GO CHECK ON DIRECTORY EXISTENSE
	MOVEI	C,0
	MOVE	D,COMFIL

	ENTER	OCH,A		;QUEUE THE COMMAND FILE
	JRST	CANT		;WHY ?
	JSR	PUT		;A DUMMY OUTPUT TO DSK IN ASCII
	MOVE	AC2,OBUF+2	;PICK UP BYTE COUNT
	SUBI	AC2,^D14	;CORRECT IT FOR ITEMS TO BE ADDED
	MOVEM	AC2,OBUF+2	;AND PUT BACK IN RING HEADER
	MOVE	AC2,OBUF+1	;PICK UP BYTE POINTER
	CALLI	CHR,24		;GET PPN OF THIS USER
	MOVEM	CHR,(AC2)	;AND PUT IT IN BUFFER
	MOVE	CHR,NAME	;FILENAME
	MOVEM	CHR,1(AC2)	;INTO BUFFER TOO
	MOVSI	CHR,(SIXBIT /DMP/)	;EXTENSION
	TRO	CHR,400000	;DELETE AFTER PRINTING & ONLY ONE COPY
	MOVEM	CHR,2(AC2)	;PUT THIS IN BUFFER
	ADDI	AC2,3		;CORRECT ADDR IN BYTE POINTER
	HRLI	AC2,440700	;AND REST OF POINTER
	MOVEM	AC2,OBUF+1	;REPLACE IN MEMORY
	CLOSE	OCH,0		;CLOSE THE CHANNEL
>

GOBAK1:	TTCALL	3,[ASCIZ /
/]				;TYPE <CR> TO SIGNIFY DUMP COMP.
	MOVE	CHR,DELMM	;RESTORE LAST DELIMETER
	CAIN	CHR,14		; (,)
	JRST	REGO		;COMMA, SO GET NEXT ARG
	TLNN	FLAG,ALLDUN
	JRST	WHAT		;SOMETHING OTHER THAN COMMA OR <CR>
	JRST	FILDMP		;INITIALIZE FOR NEW COMMAND STRING
	PAGE
MAKHDG:	Z			;CREATE LISTING PAGE HEADER
	MOVE	BP1,[POINT 6,NAME]	;TO PICK UP FILENAME
	MOVE	BP2,[POINT 7,HDGC]	;TO PUT ASCII IN HDG
	MOVE	AC1,[ASCII /     /]
	MOVEM	AC1,HDGC		;INITIALZ HDG
	MOVEM	AC1,HDGC+1
	MOVEM	AC1,HDGC+2
	MOVEM	AC1,HDGC+^D9
	TLNE	FLAG,TTYOUT	;TTY OUTPUT ?
	MOVE	AC1,[EXP 064244020100]	;YES, USE THIS INSERT
	MOVEM	AC1,HDG+^D10	;PUT IN HDG LINE
	JSR	PUTSIX		;PUT FILENAME IN HDG
	SKIPN	EXT		;NULL EXTENSION ?
	JRST	.+5		;YES
	MOVE	BP1,[POINT 6,EXT]	;POINTER TO EXTENSION
	MOVEI	CHR,"."
	IDPB	CHR,BP2		;PUT IN A PERIOD
	JSR	PUTSIX		;PUT EXT IN HDG
	MOVEI	CHR,")"
	IDPB	CHR,BP2		;DELIM. WITH R.PAREN
	MOVE	BP2,[POINT 7,HDGC+3]
	PUSHJ	PD,TIMPRT	;PUT IN TIME OF DAY
	MOVE	BP2,[POINT 7,HDGC+4,13]
	PUSHJ	PD,DATPRT	;PUT IN DATE
	JRST	@MAKHDG		;COMPLETE, SO RETURN

PARSE:	Z			;RETURNS SIXBIT ARG. IN ARG
	MOVEI	ARG,0		;AND DELIMETER IN CHR
	MOVE	BP1,[POINT 6,ARG]	;USE BP1 TO POINT TO ARG
	TTCALL	4,CHR		;GET A CHAR. FROM USER TTY
	CAIE	CHR,15		;<C.R.> ?
	JRST	.+3		;NO
	TLO	FLAG,ALLDUN	;SET ALL DONE FLAG
	JRST	@PARSE		;RETURN
	MOVEI	CHR,-40(CHR)	;CONVERT CHR TO SIXBIT
	JSR	DELIM		;IS IT A DELIMETER ?
	JRST	@PARSE		;FOUND A DELIMETER
	TLNE	BP1,770000	;MAX OF 6 CHARS. PER ARG
	IDPB	CHR,BP1		;DEPOSIT CHR IN ARG
	JRST	PARSE+3		;GO GET NEXT CHARACTER

DELIM:	Z			;CHECK FOR DELIMETER IN CHR(SIXBIT)
	MOVE	BP2,[POINT 6,DTAB]	;BP2 TO POINT TO DELIM. TABLE
	ILDB	AC1,BP2		;PICK UP A DELIMETER
	JUMPN	AC1,.+3		;CHECK THIS ONE
	AOS	DELIM		;NO FIND - GIVE SKIP RETURN
	JRST	@DELIM
	CAMN	AC1,CHR		;EQUAL ?
	JRST	@DELIM		;YES - GIVE IMMED. RETURN
	JRST	DELIM+2		;GO CHK NEXT DELIM. IN TABLE
DTAB:	OCT	141632737577		;  (,.:[]_)
	OCT	170000000000		;  (/     )
	PAGE
;************ QUEIT AND EXTENS ARE USED TO PUT FILE IN LPT-QUEUE
	IFE	BKGFL,<
QUEIT:	IFN	SAVXT,<
	TLNE	FLAG,VXPDMP	;EXPANDING SAVE FILE ?
	JRST	NOWRIT		;YES, ILLEGAL MODE
>

	MOVE	A,[SIXBIT /PRINT/]	;NAME OF QUEUED FILE
REQUT:	PUSHJ	PD,EXTNS		;PUT SIXBIT EXT IN B
	MOVEI	C,0
	MOVE	D,COMFIL		;FILE DESTINATION
	LOOKUP	OCH,A		;CHECK THIS NAME
	TRNE	B,-1		;IS THERE ONE LIKE THIS ?
	JRST	REQUT		;YES, TRY ANOTHER EXTENSION
	MOVEI	C,0		;NO, USE THIS NAME
	MOVE	D,COMFIL
	ENTER	OCH,A		;ENTER THE FILE
	JRST	REQUT		;? CAN'T WRITE, TRY AGAIN
	JSR	PUT		;DUMMY OUTPUT
	MOVE	AC1,OBUF+1	;ADDR OF FIRST WORD IN BUFFER(DATA AREA)
	MOVE	AC2,NAME
	MOVEM	AC2,(AC1)	;PUT IN SIXBIT FILE NAME
	MOVSI	AC2,(SIXBIT /DMP/)	;USE EXTENSION OF  .DMP
	MOVEM	AC2,1(AC1)	;STORE THE EXTENSION IN BUFFER
	CALLI	AC2,24		;GET PPN THIS USER
	MOVEM	AC2,2(AC1)	;PUT PPN IN BUFFER
	ADDI	AC1,3		;CORRECT BYTE POINTER ADDRESS
	HRLI	AC1,440700	;CORRECT BYTE POINTER
	MOVEM	AC1,OBUF+1	;INSTALL NEW BYTE POINTER
	MOVE	AC1,OBUF+2	;PICK UP THE BYTE COUNT
	SUBI	AC1,^D14	;CORRECT BYTE COUNT - ONE ALREADY SUB.
	MOVEM	AC1,OBUF+2	;INSTALL NEW BYTE COUNT
	JRST	QDONE		;FINISHED, SO RETURN

EXTNS:	CALLI	AC1,22
	IDIVI	AC1,^D1000
	MOVE	BP2,[POINT 6,B]	;POINTER TO DEPOSIT EXT
	MOVEI	CHR,"0"-40	;SIXBIT ZERO
	CAIGE	AC2,^D100
	IDPB	CHR,BP2		;PUT IN LEADING ZERO
	CAIGE	AC2,^D10
	IDPB	CHR,BP2		;PUT IN LEADING ZERO
	IDIVI	AC2,^D10	;NOW CONVERT (AC2) TO DECIMAL
	HRLM	AC3,(PD)	;STORE REMAINDER IN PUSH-DOWN STACK
	SKIPE	AC2		;MORE TO DIVIDE ?
	PUSHJ	PD,.-3		;YES, DO IT
	HLRZ	CHR,(PD)	;NO, PICK UP LAST REM. FROM STACK
	ADDI	CHR,20		;CONVERT TO SIXBIT
	IDPB	CHR,BP2		;PUT IN B
	POPJ	PD,0
>

	IFG	BKGFL,<
CANT:	HRRZS	B		;CHECK ERROR FLAGS
	CAIE	B,1		;IS THERE A UFD ?
	JRST	NEXT		;YES, TRY ANOTHER FILENAME
	TTCALL	3,[ASCIZ /? NO PRINT UFD -- HAVE OPERATOR START "PRINTR"
/]
	JRST	FILDMP		;GO GET NEXT COMMAND STRING

NEXT:	ADDI	AC1,1		;BUMP THE FILE NUMBER
	TRZN	AC1,10		;OVERFLOW ?
	JRST	FD2A		;NO, TRY THIS ONE
	ADDI	AC1,100		;ADD THE OVERFLOW
	TRZN	AC1,1000	;OVERFLOW ?
	JRST	FD2A		;NO, TRY THIS NAME
	JRST	FD2		;START ALL OVER
>
	PAGE
;************ ROUTINE TO PERFORM THE DUMP

DUMPIT:	Z
	SETZB	LCTR,PGCT	;INITIALIZE LOC.CTR. & PAGE COUNT
	SETZM	LASTL#
	MOVN	BP1,WDPL	;SET UP NEGATIVE WORD COUNT
	HRLZM	BP1,WDPLN#	;SAVE THE NEGATIVE COUNT

	IFN	SAVXT,<
	TLNE	FLAG,VXPDMP;EXPANDING SAVE FILE ?
	JRST	EXPAND		;YES
>

	JSR	PAGE		;GO PRINT HEADING

	IFN	SAVXT,<
	TLNE	FLAG,VSVDMP	;TRANSLATING SAVE FILE ?
	JRST	SAVKOD		;YES
	TLNE	FLAG,VSXDMP	;DIRECT SAVE FILE DUMP ?
	JRST	EXPAND		;YES
>


NXLIN:	MOVE	BP1,WDPLN
	JSR	GETCHR		;GET WORD FROM INPUT FILE
	MOVEM	CHR,TEMP(BP1)	;STORE TEMPORARILY
	AOBJN	BP1,.-2		;GET NEXT WORD
	JSR	LDUMP		;GO DUMP THIS LINE
	TLNN	FLAG,EOF	;WAS THIS END OF FILE ?
	JRST	NXLIN		;NO, GO GET ANOTHER LINE TO DUMP

EXIT:	TLNE	FLAG,MATCH	;DUPLICATE LINES PENDING ?
	JSR	NEQ		;YES, GO PRINT MSG
	MOVEI	AC1,^D125
	TLNE	FLAG,TTYOUT	;TTY OUTPUT ?
	MOVEI	AC1,^D69	;YES, PRINT SHORT LINE OF PERIODS
	MOVEI	CHR,"."
	JSR	PUT
	SOJG	AC1,.-1		;PRINT THE LINE OF PERIODS
	JSR	CRLF		;PRINT CARR.RET, LINE FEED, AND 2 BLANKS
	MOVE	BP1,[POINT 7,ENDG]	;END OF DUMP MESSAGE
	JSR	PTSTRG		;PRINT THE MESSAGE
	JRST	@DUMPIT		;FINISHED, RETURN TO MAIN PROG


NEQ:	Z		;ENTERED WHEN TWO SUCCESIVE LINES DIFFERENT
	TLZ	FLAG,MATCH	;TURN OFF MATCH FLAG
	CAMG	LCTR,LASTL	;ONE OR MORE LINES OMITTED FROM OUTPUT ?
	JRST	@NEQ		;NO, RETURN WITH NO ACTION
	MOVE	BP1,[POINT 7,LLIN]
	JSR	PTSTRG		;PRINT MSG /LINES /
	MOVE	AC2,LASTL	;NUMBER OF LAST LINE PRINTED
	MOVE	BP1,[POINT 3,AC2,17]
	ADD	AC2,WDPL	;LINE NUMBER OF FIRST OMITTED LINE
	JSR	HWD		;PRINT THE NUMBER(OCTAL) IN AC2
	MOVEI	CHR,"-"
	JSR	PUT		;PUT IN A -
	MOVEI	CHR,40
	JSR	PUT		;AND A BLANK
	MOVE	AC2,LCTR	;PICK UP PRESENT LOCATION COUNTER
	SUB	AC2,WDPL	;LINE NUMBER OF LAST LINE OMITTED
	MOVE	BP1,[POINT 3,AC2,17]
	JSR	HWD		;PRINT THIS NUMBER
	MOVE	BP1,[POINT 7,SAMLIN]
	JSR	PTSTRG		;PRINT MSG /SAME AS LINE /
	MOVE	BP1,[POINT 3,LASTL,17]
	JSR	HWD		;PRINT NUMBER IN LASTL
	JSR	CRLF
	SUBI	LINE,2		;DECREMENT LINE COUNT
	JUMPGE	LINE,@NEQ	;RETURN IF LINE .GE. 0
	JSR	PAGE		;OTHERWISE START NEW PAGE
	JRST	@NEQ		;THEN RETURN



	IFN	SAVXT,<
SAVKOD:	MOVEI	CHR,1
	MOVEM	CHR,WDPL	;ONE INPUT WORD PER PRINTED LINE

EXPAND:	MOVE	A,WDPLN		;NEG. WORDS PER LINE FOR VSXDMP
	MOVNI	LCTR,1		;INITIALIZE THE LOCATION COUNTER
EXPND1:	JSR	GETCHR		;GET AN IOWD
	JUMPL	CHR,.+2		;LEGAL IOWD ?
	JRST	ENDSAV		;NO, END IT
	MOVEM	CHR,NIOWD#	;SAVE THE NEW IOWD
	HRRZ	ARG,CHR		;GET THE IOWD ADDR.
	TLNE	FLAG,VSVDMP	;TRANSLATING A SAVE FILE ?
	JRST	BLKPRT		;YES
	JRST	.+3

EXPND2:	CAIG	ARG,(LCTR)	;NEED NEW IOWD ?
	JRST	EXPND3		;YES
	MOVEI	CHR,0		;NO, ZERO FILL
	ADDI	LCTR,1		;BUMP THE LOCATION COUNTER
	JSR	VSXPRT		;GO WRITE THE WORD
	JRST	EXPND2		;GO DO NEXT WORD

EXPND3:	MOVE	LCTR,NIOWD	;GET THE NEW IOWD
	AOBJN	LCTR,.+1	;BUMP THE LCTR
	JSR	GETCHR		;PROCESS A WORD
	JSR	VSXPRT
	JUMPL	LCTR,EXPND3+1	;NEED A NEW IOWD ?
	JRST	EXPND1		;YES

BLKPRT:	HRRZ	AC1,NIOWD	;GET THE NEW IOWD ADDR.
	SUBI	AC1,(LCTR)	;SUBTRACT PRESENT LOCATION CTR.
	JUMPE	AC1,EXPND3	;DON'T PRINT ZERO SIZE BLOCK
	MOVEM	AC1,BLKSIZ#	;SAVE THE BLOCK SIZE
	JUMPLE	LCTR,EXPND3	;NO BLOCK FOR BEG. OF SAVE TRANS.
	ADDI	LC	;BUMP THE LOCATION COUNTER
	MOVE	BP1,[POINT 3,LCTR,17]
	JSR	HWD		;WRITE THE LOCATION COUNTER
	MOVSI	CHR,-5
	HRRI	CHR,11		;HORIZ. TAB
	JSR	PUT
	ADD	CHR,[XWD 1,0]
	JUMPL	CHR,.-2		;WRITE 5 TABS
	MOVEI	BP1,[SIXBIT /BLOCK/]
	JSR	SIXOUT		;WRITE THE WORD "BLOCK"
	MOVEI	CHR,40		;BLANK, TWO TIMES
	JSR	PUT
	JSR	PUT
	MOVE	AC1,BLKSIZ
	PUSHJ	PD,OCTOUT	;PRINT BLOCK SIZE
	JSR	CRLF
	SOSGE	LINE		;PAGE FULL ?
	JSR	PAGE		;YES, START NEW ONE
	JRST	EXPND3		;GO PROCESS NEXT IOWD

VSXPRT:	Z
	MOVEI	AC1,140		;FIRST USER LOCATION(RELOC)
	TLNN	FLAG,VXPDMP	;EXPANDING SAVE FILE ?
	JRST	.+4		;NO
	CAIG	AC1,(LCTR)	;LOC 140 OR MORE ?
	JSR	PUT		;YES
	JRST	@VSXPRT		;RETURN

	MOVEM	CHR,TEMP(A)	;PUT THE WORD IN TEMP
	TLNN	FLAG,VSVDMP	;TRANSLATING SAVE FILE ?
	JRST	.+3		;NO
	JSR	LDUMP		;GO DUMP THE WORD
	JRST	@VSXPRT		;RETURN

	CAILE	AC1,(LCTR)	;TO 140 YET ?
	JRST	@VSXPRT		;NO, RETURN
	AOBJN	A,@VSXPRT	;TEMP FULL YET ?
	MOVEM	LCTR,SAVLCT#	;YES
	MOVEI	LCTR,-137(LCTR)	;RELOCATE LCTR
	SUB	LCTR,WDPL	;ADDRESS OF FIRST WORD IN LINE
	JSR	LDUMP		;DUMP THE LINE
	MOVE	A,WDPLN		;RESET AC A TO STORE ANOTHER LINE
	MOVE	LCTR,SAVLCT	;RESTORE LCTR
	JRST	@VSXPRT		;AND RETURN
>
	PAGE
LDUMP:	Z			;DUMP LINE IN TEMP

	IFN	SAVXT,<
	TLNE	FLAG,VSVDMP	;TRANSLATING SAVE FILE ?
	JRST	LLDSMP		;YES
>

	MOVE	AC3,WDPLN	;NEG NUMBER OF WORDS PER LINE
NXCOMP:	MOVE	CHR,TEMP(AC3)	;PICK UP INPUT WORD
	CAME	CHR,COMP(AC3)	;EQUAL TO WORD IN LAST LINE PRINTED ?
	JRST	UNEQ		;NO, SEE IF MATCHED LINES PENDING
	AOBJN	AC3,NXCOMP
	JUMPE	LCTR,LLDUMP	;IF FIRST LINE, GO TO LLDUMP
	TLO	FLAG,MATCH	;SET MATCH FLAG
	ADD	LCTR,WDPL	;BUMP THE LOCATION COUNTER
	JRST	@LDUMP		;AND RETURN TO GET NEXT LINE

UNEQ:	TLNE	FLAG,MATCH	;HAS THERE BEEN A PREV. MATCH
	JSR	NEQ		;YES, GO CHECK IT OUT
LLDUMP:	MOVEM	LCTR,LASTL	;UPDATE LASTL
	MOVE	AC3,WDPLN	;WDPLN = [XWD  -WDPL,0]
	MOVE	CHR,TEMP(AC3)	;MOVE THE TEMP ROW
	MOVEM	CHR,COMP(AC3)	;INTO THE COMP ROW
	AOBJN	AC3,.-2

LLDSMP:	MOVE	BP1,[POINT 3,LCTR,17]
	JSR	HWD		;PRINT PRESENT VALUE OF LOCATION COUNTER
	JSR	PUT		;CHR STILL CONTAINS BLANK CHAR.
	JSR	PUT		;AFTER RETURN FROM HWD

	MOVE	BP1,[POINT 3,TEMP]	;PRINT TEMP LINE, AS OCTAL
	MOVE	AC2,WDPL	;PRINT THIS NUM. OF WORDS
NXWRD:	MOVEI	AC3,2		;TWO HALVES PER WORD
	JSR	HWD		;PRINT A HALF-WORD
	SOJG	AC3,.-1
	JSR	PUT		;PRINT EXTRA SPACE AFTER WHOLE WORD
	SOJG	AC2,NXWRD
	JSR	PUT
	JSR	PUT		;EXTRA SPACES AFTER ALL OF TEMP LINE
	JSR	PUT

	MOVE	BP1,[POINT 7,TEMP]	;NOW TEMP AGAIN, AS ASCII
	MOVE	AC3,WDPL	;THIS MANY WORDS IN TEMP
NXASC:	MOVEI	AC2,5		;FIVE ASCII CHARS. PER WORD
	ILDB	ARG,BP1		;PICK UP ASCII CHAR
	ROT	ARG,-1		;DIVIDE BY 2, SAVING REMAINDER
	MOVE	CHR,ASCTAB(ARG)	;PICK UP TABLE ENTRY
	TLNN	ARG,400000	;WAS THERE A REMAINDER ?
	MOVS	CHR,CHR		;NO, NEED CHAR. IN LEFT HALF - SO SWAP
	JSR	PUT		;PRINT CHAR. IN RIGHT HALF OF CHR
	SOJG	AC2,NXASC+1
	MOVEI	CHR,40		;SPACE
	JSR	PUT		;PRINT SPACE
	SOJG	AC3,NXASC
	JSR	PUT		;PRINT EXTRA SPACES AT END OF ASCII
	JSR	PUT

	MOVE	BP1,[POINT 6,TEMP]	;NOW TEMP AS SIXBIT
	MOVE	AC3,WDPL	;THIS NUM. OF WORDS PER LINE
NXSIX:	MOVEI	AC2,6		;SIX SIXBIT CHARS. PER WORD
	ILDB	ARG,BP1		;PICK UP SIXBIT CHAR.
	ROT	ARG,-1		;DIVIDE BY 2, SAVING REMAINDER
	MOVE	CHR,SIXTAB(ARG)	;PICK UP TABLE ENTRY
	TLNN	ARG,400000	;WAS THERE A REMAINDER ?
	MOVS	CHR,CHR		;NO, SWAP HALVES
	JSR	PUT		;GO PRINT THE CHAR.
	SOJG	AC2,NXSIX+1
	MOVEI	CHR,40		;SPACE
	JSR	PUT		;SPACE AFTER WORD
	SOJG	AC3,NXSIX

	IFN	SAVXT,<
	TLNN	FLAG,VSVDMP	;TRANSLATING SAVE FILE ?
	JRST	LDMP1		;NO
	MOVEI	CHR,11		;PRINT A HORIZ. TAB
	JSR	PUT
	LDB	BP1,[POINT 9,TEMP,8]	;OPCODE
	CAIGE	BP1,700		;IS IT AN I/O INSTR.?
	JRST	NOIO		;NO
	LDB	BP1,[POINT 3,TEMP,12]	;PICK UP I/O OPCODE
	TRO	BP1,700		;TURN ON BITS (27-29)
	MOVEI	BP1,OPCODE(BP1)	;ADDRESS OF OPCODE NAME
	JSR	SIXOUT		;WRITE THE OPCODE NAME
	MOVEI	CHR,40		;BLANK, TWO TIMES
	JSR	PUT
	JSR	PUT
	LDB	BP1,[POINT 7,TEMP,9]	;GET THE DEVICE CODE
	JRST	ANYINS		;AND PRINT LIKE AC AT ANYINS

NOIO:	MOVEI	BP1,OPCODE(BP1)	;ADDRESS OF OPCODE NAME
	JSR	SIXOUT		;WRITE THE OPCODE NAME
	MOVEI	CHR,40
	JSR	PUT
	JSR	PUT		;WRITE TWO BLANKS
	LDB	AC1,[POINT 4,TEMP,12]	;ACCUM.

ANYINS:	PUSHJ	PD,OCTOUT	;WRITE OUT THE AC
	MOVEI	CHR,","
	JSR	PUT		;WRITE THE COMMA
	LDB	AC1,[POINT 1,TEMP,13]	;GET THE INDIRECT BIT
	JUMPE	AC1,.+3		;IS IT ON ?
	MOVEI	CHR,"@"		;YES, PRINT THE @
	JSR	PUT
	HRRZ	AC1,TEMP	;GET THE DISPLACEMENT FIELD
	PUSHJ	PD,OCTOUT	;AND PRINT IT
	LDB	AC1,[POINT 4,TEMP,17]	;GET INDEX AC
	JUMPE	AC1,.+6		;INDEXING SPECIFIED ?
	MOVEI	CHR,"("		;YES
	JSR	PUT		;WRITE LEFT PAREN.
	PUSHJ	PD,OCTOUT	;PRINT THE INDEX AC
	MOVEI	CHR,")"
	JSR	PUT		;WRITE RIGHT PAREN.
	JSR	CRLF		;END OF LINE
	JRST	LDMP2
>



LDMP1:	ADD	LCTR,WDPL	;BUMP THE LOCATION COUNTER
	JSR	CRLF		;TERMINATE LINE
	SOJGE	LINE,.+2	;NEED A NEW PAGE ?
	JSR	PAGE		;YES, DO IT
	TDNN	LCTR,LINMSK	;NEED A BLANK LINE ?
	JRST	.+2		;YES
	JRST	@LDUMP		;GO GET ANOTHER LINE TO DUMP
	JSR	CRLF		;PRINT BLANK LINE
LDMP2:	SOJGE	LINE,@LDUMP	;NEED A NEW PAGE ?
	JSR	PAGE		;YES
	JRST	@LDUMP
	PAGE
SIXPRT:	Z			;PRINT SIXBIT WORD ON TTY
	HRLI	AC1,440600	;AC1 CONTAINS ADDR OF SIXBIT ARG
	ILDB	CHR,AC1		;PICK UP FIRST BYTE
	JUMPE	CHR,@SIXPRT	;TERMINATE ON NULL BYTE
	MOVEI	CHR,40(CHR)	;CONVERT TO ASCII
	TTCALL	1,CHR		;PRINT ON USER TTY
	TLNE	AC1,770000	;END OF WORD ?
	JRST	SIXPRT+2	;NO, GET NEXT CHAR.
	JRST	@SIXPRT		;ALL DONE, RETURN

SIXOUT:	Z			;BP1 CONTAINS ADDR OF SIXBIT WORD
	HRLI	BP1,440600	;BUILD BYTE POINTER
	ILDB	CHR,BP1		;PICK UP A BYTE
	ADDI	CHR,40		;CONVERT TO ASCII
	JSR	PUT		;AND WRITE IT
	TLNE	BP1,770000	;END OF WORD ?
	JRST	.-4		;NO, GET NEXT CHARACTER
	JRST	@SIXOUT		;YES, RETURN

PUTSIX:	Z			;PRINT SIXBIT WORD ON OUTPUT DEV
	ILDB	CHR,BP1		;PICK UP BYTE
	JUMPE	CHR,@PUTSIX	;TERMINATE ON NULL BYTE
	MOVEI	CHR,40(CHR)	;CONVERT CHR TO ASCII
	IDPB	CHR,BP2		;PUT IN BUFFER
	TLNE	BP1,770000	;WHOLE WORD PRINTED ?
	JRST	PUTSIX+1	;NO, GET NEXT BYTE
	JRST	@PUTSIX		;ALL DONE, RETURN

SIXBIN:	Z			;CONVERT SIXBIT NUMBER(OCTAL) IN ARG
	JUMPE	ARG,@SIXBIN	;ILLEGAL NUMBER
	MOVE	AC1,ARG		;TO BINARY, AND RETURN BINARY IN ARG
	MOVEI	AC3,1		;AC3 USED FOR POWER OF EIGHT
	MOVEI	ARG,0		;ZERO OUT ARG TO SUM UP BINARY NUM.
	MOVEI	AC2,0
	LSHC	AC1,-6		;SHIFT DIGIT INTO AC2
	JUMPE	AC2,.-1		;RIGHT JUSTIFY IN AC1 IF NECESSARY
	ROT	AC2,6		;PUT DIGIT IN LOW END OF AC2
	MOVEI	AC2,-20(AC2)	;CONVERT DIGIT TO BINARY
	IMUL	AC2,AC3		;MULT. BY APPROP. POWER OF EIGHT
	ADD	ARG,AC2		;ADD TO SUM IN ARG
	LSH	AC3,3		;ADJUST POWER OF 8 FOR NEXT DIGIT
	JUMPE	AC1,@SIXBIN	;FINISHED, RETURN
	JRST	SIXBIN+5	;GO PROCESS NEXT DIGIT

TIMPRT:	CALLI	A,22		;GET TIME IN JIFFIES
	IDIVI	A,^D3600	;CONVERT TO MINUTES
	IDIVI	A,^D60		;HOURS IN A,  MINUTES IN B
	MOVE	AC1,A
	PUSHJ	PD,DECPRT+3	;PRINT THE HOURS
	MOVEI	CHR,":"
	IDPB	CHR,BP2		;PRINT THE COLON
	MOVE	AC1,B
	PUSHJ	PD,DECPRT	;PRINT THE MINUTES
	POPJ	PD,0		;RETURN

DATPRT:	CALLI	A,14		;GET DATE
	IDIVI	A,^D12*^D31	;TO GET YEARS-64 IN A
	IDIVI	B,^D31		;MONTH-1 IN B, DAY-1 IN C
	MOVEI	AC1,1(C)
	PUSHJ	PD,DECPRT	;PRINT DAY
	MOVEI	BP1,DATTAB(B)	;ADDR OF ASCII MONTH NAME
	HRLI	BP1,440600	;BUILD BYTE POINTER IN AC1
	JSR	PUTSIX
	MOVEI	AC1,^D64(A)
	PUSHJ	PD,DECPRT	;PRINT THE YEAR
	POPJ	PD,0		;RETURN

DECPRT:	MOVEI	CHR,"0"		;PRINT DECIMAL OF NUM. IN AC1
	CAIGE	AC1,^D10
	IDPB	CHR,BP2		;PRINT LEADING ZERO IF NECC.
	IDIVI	AC1,^D10	;DIVIDE NUMBER BY 10
	HRLM	AC2,(PD)	;STORE REMAINDER IN STACK
	SKIPE	AC1		;MORE DIVIDE ?
	PUSHJ	PD,.-3		;YES, GO DO IT
	HLRZ	CHR,(PD)	;NO, GET LAST DIGIT FROM STACK
	MOVEI	CHR,60(CHR)	;CONVERT TO ASCII
	IDPB	CHR,BP2		;PUT IT IN PRINT LINE
	POPJ	PD,0		;RETURN WHEN STACK EMPTIED OF DIGITS

	IFN	SAVXT,<
OCTOUT:	IDIVI	AC1,10		;DIVIDE BY OCTAL RADIX
	HRLM	AC2,(PD)	;SAVE REMAINDER ON STACK
	SKIPE	AC1		;MORE TO DIVIDE ?
	PUSHJ	PD,.-3		;YES, DO IT
	HLRZ	CHR,(PD)	;GET LAST REMAINDER FROM STACK
	ADDI	CHR,60		;CONVERT TO ASCII CHARACTER
	JSR	PUT		;AND WRITE IT
	POPJ	PD,0
>

HWD:	Z		;PRINT HALFWORD POINTED TO BY BP1
	MOVEI	AC1,6		;SIX DIGITS PER HALFWORD
	ILDB	CHR,BP1		;PICK UP A BYTE
	ADDI	CHR,60		;CONVERT TO ASCII
	JSR	PUT		;PRINT THE CHAR.
	SOJG	AC1,.-3
	MOVEI	CHR,40		;SPACE
	JSR	PUT		;PRINT A SPACE
	JRST	@HWD		;RETURN

PTSTRG:	Z		;PRINT ASCIZ STRING POINTED TO BY BP1
	ILDB	CHR,BP1		;PICK UP A BYTE
	JUMPE	CHR,@PTSTRG	;TERMINATE ON NULL BYTE
	JSR	PUT		;PRINT THE CHARACTER
	JRST	.-3		;GET NEXT CHAR.

PAGE:	Z			;START A NEW OUTPUT PAGE
	MOVEI	CHR,14		;FORM FEED

	IFGE	BKGFL,<
	TLNE	FLAG,QUEUE	;ALWAYS A FORM FOR NON-QUEUED ON
				;FIRST PAGE
	>
	SKIPE	PGCT		;DON'T PUT IN FORM FEED FIRST PAGE
	JSR	PUT		;PRINT THE FORM FEED
	MOVE	BP2,[POINT 7,HDGC+11]	;TO PUT IN PAGE COUNT
	MOVEI	PGCT,1(PGCT)	;BUMP PAGE COUNT
	MOVE	AC1,PGCT
	PUSHJ	PD,DECPRT+3	;GO PUT IT IN HEADING
	MOVEI	CHR,0
	IDPB	CHR,BP2		;TERMINATE THE ASCIZ STRING
	MOVE	BP1,[POINT 7,HDG]	;TO PICK UP THIS NEW HEADING
	JSR	PTSTRG		;GO PRINT THE HEADING
	JSR	CRLF
	MOVE	BP1,[POINT 7,HDG2]	;TO PICK UP REST OF HEADING
	TLNE	FLAG,TTYOUT	;TTY OUTPUT ?
	MOVE	BP1,[POINT 7,HDGTT]	;YES, USE THIS HEADING

	IFN	SAVXT,<
	TLNE	FLAG,VSVDMP	;TRANSLATING A SAVE FILE ?
	MOVE	BP1,[POINT 7,HDGSAV]	;YES, USE THIS SPECIAL HDG.
>

	JSR	PTSTRG		;GO PRINT THIS STRING
	JSR	CRLF		;CAR.RET-LINE FEED
	MOVEI	AC1,^D125	;125 PERIODS TO PRINT
	TLNE	FLAG,TTYOUT	;TTY OUTPUT ?
	MOVEI	AC1,^D69	;YES, USE ONLY 69 PERIODS
	MOVEI	CHR,"."
	JSR	PUT		;PRINT A PERIOD
	SOJG	AC1,.-1
	MOVEI	LINE,^D53	;INITIALIZE LINE COUNT
	JSR	CRLF
	JRST	@PAGE		;RETURN

CRLF:	Z
	MOVEI	CHR,15		;CARRIAGE RETURN
	JSR	PUT		;PRINT IT
	MOVEI	CHR,12		;LINE FEED
	JSR	PUT		;PRINT IT
	MOVEI	CHR,40		;SPACE
	JSR	PUT		;PRINT TWO SPACES
	JSR	PUT
	JRST	@CRLF		;RETURN

PUT:	Z		;PUT CHARACTER IN CHR INTO OUTPUT BUFFER
	SOSG	OBUF+2		;BUFFER FULL ?
	JRST	.+3		;YES
	IDPB	CHR,OBUF+1	;DEPOSIT THE CHAR.
	JRST	@PUT		;RETURN
	OUT	OCH,0		;EMPTY THE BUFFER
	JRST	.-3		;NOW DEPOSIT THE BYTE
	HALT		;ERROR ON OUTPUT

GETCHR:	Z		;GET A CHARACTER IN CHR FROM INPUT BUFFER
	SOSG	IBUF+2		;BUFFER EMPTY ?
	JRST	.+3		;YES
	ILDB	CHR,IBUF+1	;GET A BYTE
	JRST	@GETCHR		;RETURN
	IN	ICH,0		;GET NEXT BUFFER FULL
	JRST	.-3		;NOW GO GET A BYTE
	STATZ	ICH,740000	;NO BUFFER ?
	HALT		;INPUT ERROR



	IFN	SAVXT,<
EXEX:	TLNE	FLAG,VXPDMP	;EXPANDING SAVE FILE ?
	JRST	@DUMPIT		;YES, THRU
	TLNE	FLAG,VSVDMP	;TRANSLATING SAVE FILE ?
	JRST	EXIT+2		;YES, THRU
	TLNN	FLAG,VSXDMP	;DUMPING SAVE FILE ?
	JRST	EXEX1		;NO, REGULAR DUMP
	HRRZ	LCTR,SAVLCT	;GET LAST LOCATION COUNTER
	HRRZ	AC1,A
	ADD	LCTR,AC1	;HOW FAR THRU LINE
	MOVEI	CHR,-140(CHR)	;CORRECT FOR 140 OFFSET
	MOVEM	CHR,TEMP(A)	;AND PUT BRANCH ADDR IN DUMP
	MOVEI	CHR,0		;ZERO FILL REST OF LINE
	ADDI	LCTR,1		;BUMP THE LOCATION COUNTER
	AOBJN	A,.-3		;FILL OUT THE LINE
	JSR	VSXPRT		;GO DUMP THE LINE
	JRST	EXIT		;THROUGH AT LAST
>

EXEX1:	MOVEI	CHR,0		;ZERO FILL REST OF LINE
	MOVEM	CHR,TEMP(BP1)	;FILL OUT TEMP
	AOBJN	BP1,.-1
	TLO	FLAG,EOF	;SET THE END-OF-FILE FLAG
	AOS	GETCHR		;INCREMENT RETURN ADDRESS
	JRST	@GETCHR		;TO GIVE A SKIP RETURN
	PAGE
;****** THE FOLLOWING TABLE CONTAINS THE TRANSLATIONS TO BE
;	USED FOR ASCII AND SIXBIT INTERPRETATIONS.
;
;	THE CHARACTER BYTE IS USED TO PICK UP AN ENTRY IN 
;	THE TABLE ACCORDING TO --
;
;	BYTE/2 = INDEX TO ENTRY IN TABLE
;	IF THERE IS A REMAINDER AFTER THE ABOVE DIVISION,
;	THEN THE CORRECT TRANSLATION IS IN THE RIGHT
;	SIDE OF THE WORD INDEXED.  IF NO REMAINDER, THEN
;	THE HALVES OF THE WORD ARE SWAPPED TO GET THE
;******	CORRECT TRANSLATION TO THE RIGHT SIDE OF WORD.

ASCTAB:	REPEAT	20,<	XWD	56,56>	;ALL PERIODS
SIXTAB:	XWD	40,56		;  SP !
	XWD	56,56		;  "  #
	XWD	56,56		;  $  %
	XWD	56,56		;  &  '
	XWD	50,51		;  (  )
	XWD	52,53		;  *  +
	XWD	54,55		;  ,  -
	XWD	56,57		;  .  /
OCTAB:	XWD	60,61		;  0  1
	XWD	62,63		;  2  3
	XWD	64,65		;  4  5
	XWD	66,67		;  6  7
	XWD	70,71		;  8  9
	XWD	56,56		;  :  ;
	XWD	56,75		;  <  =
	XWD	56,56		;  >  ?
	XWD	56,101		;  @  A
	XWD	102,103		;  B  C
	XWD	104,105		;  D  E
	XWD	106,107		;  F  G
	XWD	110,111		;  H  I
	XWD	112,113		;  J  K
	XWD	114,115		;  L  M
	XWD	116,117		;  N  O
	XWD	120,121		;  P  Q
	XWD	122,123		;  R  S
	XWD	124,125		;  T  U
	XWD	126,127		;  V  W
	XWD	130,131		;  X  Y
	XWD	132,56		;  Z  [
	REPEAT	22,<	XWD	56,56>


	IFN	SAVXT,<

OPCODE:

;************ THE TABLE OF PDP-10 OPCODES IS XLISTED BELOW.

	XLIST
;***(000)
	SIXBIT	/ /
	REPEAT	37,<	SIXBIT	/USRUUO/>
;***(040)
	SIXBIT	/CALL/
	SIXBIT	/INIT/
	REPEAT	5,<	SIXBIT	/ />
	SIXBIT	/CALLI/
;***(050)
	SIXBIT	/OPEN/
	SIXBIT	/TTCALL/
	REPEAT	3,<	SIXBIT	/ />
	SIXBIT	/RENAME/
	SIXBIT	/IN/
	SIXBIT	/OUT/
;***(060)
	SIXBIT	/SETSTS/
	SIXBIT	/STATO/
	SIXBIT	/STATUS/
	SIXBIT	/STATZ/
	SIXBIT	/INBUF/
	SIXBIT	/OUTBUF/
	SIXBIT	/INPUT/
	SIXBIT	/OUTPUT/
;***(070)
	SIXBIT	/CLOSE/
	SIXBIT	/RELEAS/
	SIXBIT	/MTAPE/
	SIXBIT	/UGETF/
	SIXBIT	/USETI/
	SIXBIT	/USETO/
	SIXBIT	/LOOKUP/
	SIXBIT	/ENTER/

;***(100)
	REPEAT 30,<	SIXBIT	/ />
;***(130)
	SIXBIT	/UFA/
	SIXBIT	/DFN/
	SIXBIT	/FSC/
	SIXBIT	/IBP/
	SIXBIT	/ILDB/
	SIXBIT	/LDB/
	SIXBIT	/IDPB/
	SIXBIT	/DPB/
;***(140)
	SIXBIT	/FAD/
	SIXBIT	/FADL/
	SIXBIT	/FADM/
	SIXBIT	/FADB/
	SIXBIT	/FADR/
	SIXBIT	/FADRI/
	SIXBIT	/FADRM/
	SIXBIT	/FADRB/
;***(150)
	SIXBIT	/FSB/
	SIXBIT	/FSBL/
	SIXBIT	/FSBM/
	SIXBIT	/FSBB/
	SIXBIT	/FSBR/
	SIXBIT	/FSBRI/
	SIXBIT	/FSBRM/
	SIXBIT	/FSBRB/
;***(160)
	SIXBIT	/FMP/
	SIXBIT	/FMPL/
	SIXBIT	/FMPM/
	SIXBIT	/FMPB/
	SIXBIT	/FMPR/
	SIXBIT	/FMPRI/
	SIXBIT	/FMPRM/
	SIXBIT	/FMPRB/
;***(170)
	SIXBIT	/FDV/
	SIXBIT	/FDVL/
	SIXBIT	/FDVM/
	SIXBIT	/FDVB/
	SIXBIT	/FDVR/
	SIXBIT	/FDVRI/
	SIXBIT	/FDVRM/
	SIXBIT	/FDVRB/

;***(200)
	SIXBIT	/MOVE/
	SIXBIT	/MOVEI/
	SIXBIT	/MOVEM/
	SIXBIT	/MOVES/
	SIXBIT	/MOVS/
	SIXBIT	/MOVSI/
	SIXBIT	/MOVSM/
	SIXBIT	/MOVSS/
;***(210)
	SIXBIT	/MOVN/
	SIXBIT	/MOVNI/
	SIXBIT	/MOVNM/
	SIXBIT	/MOVNS/
	SIXBIT	/MOVM/
	SIXBIT	/MOVMI/
	SIXBIT	/MOVMM/
	SIXBIT	/MOVMS/
;***(220)
	SIXBIT	/IMUL/
	SIXBIT	/IMULI/
	SIXBIT	/IMULM/
	SIXBIT	/IMULB/
	SIXBIT	/MUL/
	SIXBIT	/MULI/
	SIXBIT	/MULM/
	SIXBIT	/MULB/
;***(230)
	SIXBIT	/IDIV/
	SIXBIT	/IDIVI/
	SIXBIT	/IDIVM/
	SIXBIT	/IDIVB/
	SIXBIT	/DIV/
	SIXBIT	/DIVI/
	SIXBIT	/DIVM/
	SIXBIT	/DIVB/
;***(240)
	SIXBIT	/ASH/
	SIXBIT	/ROT/
	SIXBIT	/LSH/
	SIXBIT	/JFFO/
	SIXBIT	/ASHC/
	SIXBIT	/ROTC/
	SIXBIT	/LSHC/
	SIXBIT	/ /
;***(250)
	SIXBIT	/EXCH/
	SIXBIT	/BLT/
	SIXBIT	/AOBJP/
	SIXBIT	/AOBJN/
	SIXBIT	/JRST/
	SIXBIT	/JFCL/
	SIXBIT	/XCT/
	SIXBIT	/ /
;***(260)
	SIXBIT	/PUSHJ/
	SIXBIT	/PUSH/
	SIXBIT	/POP/
	SIXBIT	/POPJ/
	SIXBIT	/JSR/
	SIXBIT	/JSP/
	SIXBIT	/JSA/
	SIXBIT	/JRA/
;***(270)
	SIXBIT	/ADD/
	SIXBIT	/ADDI/
	SIXBIT	/ADDM/
	SIXBIT	/ADDB/
	SIXBIT	/SUB/
	SIXBIT	/SUBI/
	SIXBIT	/SUBM/
	SIXBIT	/SUBB/

;***(300)
	SIXBIT	/CAI/
	SIXBIT	/CAIL/
	SIXBIT	/CAIE/
	SIXBIT	/CAILE/
	SIXBIT	/CAIA/
	SIXBIT	/CAIGE/
	SIXBIT	/CAIN/
	SIXBIT	/CAIG/
;***(310)
	SIXBIT	/CAM/
	SIXBIT	/CAML/
	SIXBIT	/CAME/
	SIXBIT	/CAMLE/
	SIXBIT	/CAMA/
	SIXBIT	/CAMGE/
	SIXBIT	/CAMN/
	SIXBIT	/CAMG/
;***(320)
	SIXBIT	/JUMP/
	SIXBIT	/JUMPL/
	SIXBIT	/JUMPE/
	SIXBIT	/JUMPLE/
	SIXBIT	/JUMPA/
	SIXBIT	/JUMPGE/
	SIXBIT	/JUMPN/
	SIXBIT	/JUMPG/
;***(330)
	SIXBIT	/SKIP/
	SIXBIT	/SKIPL/
	SIXBIT	/SKIPE/
	SIXBIT	/SKIPLE/
	SIXBIT	/SKIPA/
	SIXBIT	/SKIPGE/
	SIXBIT	/SKIPN/
	SIXBIT	/SKIPG/
;***(340)
	SIXBIT	/AOJ/
	SIXBIT	/AOJL/
	SIXBIT	/AOJE/
	SIXBIT	/AOJLE/
	SIXBIT	/AOJA/
	SIXBIT	/AOJGE/
	SIXBIT	/AOJN/
	SIXBIT	/AOJG/
;***(350)
	SIXBIT	/AOS/
	SIXBIT	/AOSL/
	SIXBIT	/AOSE/
	SIXBIT	/AOSLE/
	SIXBIT	/AOSA/
	SIXBIT	/AOSGE/
	SIXBIT	/AOSN/
	SIXBIT	/AOSG/
;***(360)
	SIXBIT	/SOJ/
	SIXBIT	/SOJL/
	SIXBIT	/SOJE/
	SIXBIT	/SOJLE/
	SIXBIT	/SOJA/
	SIXBIT	/SOJGE/
	SIXBIT	/SOJN/
	SIXBIT	/SOJG/
;***(370)
	SIXBIT	/SOS/
	SIXBIT	/SOSL/
	SIXBIT	/SOSE/
	SIXBIT	/SOSLE/
	SIXBIT	/SOSA/
	SIXBIT	/SOSGE/
	SIXBIT	/SOSN/
	SIXBIT	/SOSG/

;***(400)
	SIXBIT	/SETZ/
	SIXBIT	/SETZI/
	SIXBIT	/SETZM/
	SIXBIT	/SETZB/
	SIXBIT	/AND/
	SIXBIT	/ANDI/
	SIXBIT	/ANDM/
	SIXBIT	/ANDB/
;***(410)
	SIXBIT	/ANDCA/
	SIXBIT	/ANDCAI/
	SIXBIT	/ANDCAM/
	SIXBIT	/ANDCAB/
	SIXBIT	/SETM/
	SIXBIT	/SETMI/
	SIXBIT	/SETMM/
	SIXBIT	/SETMB/
;***(420)
	SIXBIT	/ANDCM/
	SIXBIT	/ANDCMI/
	SIXBIT	/ANDCMM/
	SIXBIT	/ANDCMB/
	SIXBIT	/SETA/
	SIXBIT	/SETAI/
	SIXBIT	/SETAM/
	SIXBIT	/SETAB/
;***(430)
	SIXBIT	/XOR/
	SIXBIT	/XORI/
	SIXBIT	/XORM/
	SIXBIT	/XORB/
	SIXBIT	/IOR/
	SIXBIT	/IORI/
	SIXBIT	/IORM/
	SIXBIT	/IORB/
;***(440)
	SIXBIT	/ANDCB/
	SIXBIT	/ANDCBI/
	SIXBIT	/ANDCBM/
	SIXBIT	/ANDCBB/
	SIXBIT	/EQV/
	SIXBIT	/EQVI/
	SIXBIT	/EQVM/
	SIXBIT	/EQVB/
;***(450)
	SIXBIT	/SETCA/
	SIXBIT	/SETCAI/
	SIXBIT	/SETCAM/
	SIXBIT	/SETCAB/
	SIXBIT	/ORCA/
	SIXBIT	/ORCAI/
	SIXBIT	/ORCAM/
	SIXBIT	/ORCAB/
;***(460)
	SIXBIT	/SETCM/
	SIXBIT	/SETCMI/
	SIXBIT	/SETCMM/
	SIXBIT	/SETCMB/
	SIXBIT	/ORCM/
	SIXBIT	/ORCMI/
	SIXBIT	/ORCMM/
	SIXBIT	/ORCMB/
;***(470)
	SIXBIT	/ORCB/
	SIXBIT	/ORCBI/
	SIXBIT	/ORCBM/
	SIXBIT	/ORCBB/
	SIXBIT	/SETO/
	SIXBIT	/SETOI/
	SIXBIT	/SETOM/
	SIXBIT	/SETOB/

;***(500)
	SIXBIT	/HLL/
	SIXBIT	/HLLI/
	SIXBIT	/HLLM/
	SIXBIT	/HLLS/
	SIXBIT	/HRL/
	SIXBIT	/HRLI/
	SIXBIT	/HRLM/
	SIXBIT	/HRLS/
;***(510)
	SIXBIT	/HLLZ/
	SIXBIT	/HLLZI/
	SIXBIT	/HLLZM/
	SIXBIT	/HLLZS/
	SIXBIT	/HRLZ/
	SIXBIT	/HRLZI/
	SIXBIT	/HRLZM/
	SIXBIT	/HRLZS/
;***(520)
	SIXBIT	/HLLO/
	SIXBIT	/HLLOI/
	SIXBIT	/HLLOM/
	SIXBIT	/HLLOS/
	SIXBIT	/HRLO/
	SIXBIT	/HRLOI/
	SIXBIT	/HRLOM/
	SIXBIT	/HRLOS/
;***(530)
	SIXBIT	/HLLE/
	SIXBIT	/HLLEI/
	SIXBIT	/HLLEM/
	SIXBIT	/HLLES/
	SIXBIT	/HRLE/
	SIXBIT	/HRLEI/
	SIXBIT	/HRLEM/
	SIXBIT	/HRLES/
;***(540)
	SIXBIT	/HRR/
	SIXBIT	/HRRI/
	SIXBIT	/HRRM/
	SIXBIT	/HRRS/
	SIXBIT	/HLR/
	SIXBIT	/HLRI/
	SIXBIT	/HLRM/
	SIXBIT	/HLRS/
;***(550)
	SIXBIT	/HRRZ/
	SIXBIT	/HRRZI/
	SIXBIT	/HRRZM/
	SIXBIT	/HRRZS/
	SIXBIT	/HLRZ/
	SIXBIT	/HLRZI/
	SIXBIT	/HLRZM/
	SIXBIT	/HLRZS/
;***(560)
	SIXBIT	/HRRO/
	SIXBIT	/HRROI/
	SIXBIT	/HRROM/
	SIXBIT	/HRROS/
	SIXBIT	/HLRO/
	SIXBIT	/HLROI/
	SIXBIT	/HLROM/
	SIXBIT	/HLROS/
;***(570)
	SIXBIT	/HRRE/
	SIXBIT	/HRREI/
	SIXBIT	/HRREM/
	SIXBIT	/HRRES/
	SIXBIT	/HLRE/
	SIXBIT	/HLREI/
	SIXBIT	/HLREM/
	SIXBIT	/HLRES/

;***(600)
	SIXBIT	/TRN/
	SIXBIT	/TLN/
	SIXBIT	/TRNE/
	SIXBIT	/TLNE/
	SIXBIT	/TRNA/
	SIXBIT	/TLNA/
	SIXBIT	/TRNN/
	SIXBIT	/TLNN/
;***(610)
	SIXBIT	/TDN/
	SIXBIT	/TSN/
	SIXBIT	/TDNE/
	SIXBIT	/TSNE/
	SIXBIT	/TDNA/
	SIXBIT	/TSNA/
	SIXBIT	/TDNN/
	SIXBIT	/TSNN/
;***(620)
	SIXBIT	/TRZ/
	SIXBIT	/TLZ/
	SIXBIT	/TRZE/
	SIXBIT	/TLZE/
	SIXBIT	/TRZA/
	SIXBIT	/TLZA/
	SIXBIT	/TRZN/
	SIXBIT	/TLZN/
;***(630)
	SIXBIT	/TDZ/
	SIXBIT	/TSZ/
	SIXBIT	/TDZE/
	SIXBIT	/TSZE/
	SIXBIT	/TDZA/
	SIXBIT	/TSZA/
	SIXBIT	/TDZN/
	SIXBIT	/TSZN/
;***(640)
	SIXBIT	/TRC/
	SIXBIT	/TLC/
	SIXBIT	/TRCE/
	SIXBIT	/TLCE/
	SIXBIT	/TRCA/
	SIXBIT	/TLCA/
	SIXBIT	/TRCN/
	SIXBIT	/TLCN/
;***(650)
	SIXBIT	/TDC/
	SIXBIT	/TSC/
	SIXBIT	/TDCE/
	SIXBIT	/TSCE/
	SIXBIT	/TDCA/
	SIXBIT	/TSCA/
	SIXBIT	/TDCN/
	SIXBIT	/TSCN/
;***(660)
	SIXBIT	/TRO/
	SIXBIT	/TLO/
	SIXBIT	/TROE/
	SIXBIT	/TLOE/
	SIXBIT	/TROA/
	SIXBIT	/TLOA/
	SIXBIT	/TRON/
	SIXBIT	/TLON/
;***(670)
	SIXBIT	/TDO/
	SIXBIT	/TSO/
	SIXBIT	/TDOE/
	SIXBIT	/TSOE/
	SIXBIT	/TDOA/
	SIXBIT	/TSOA/
	SIXBIT	/TDON/
	SIXBIT	/TSON/

;***(700) I/O INSTR.
	SIXBIT	/BLKI/
	SIXBIT	/DATAI/
	SIXBIT	/BLKO/
	SIXBIT	/DATAO/
	SIXBIT	/CONO/
	SIXBIT	/CONI/
	SIXBIT	/CONSZ/
	SIXBIT	/CONSO/
	LIST
>


STAK:	XWD	-10,.		;STARTING PUSH-DOWN POINTER
	BLOCK	10		;PUSH-DOWN STACK AREA

IBUF:	BLOCK	3		;INPUT BUFFER RING HEADER
OBUF:	BLOCK	3		;OUTPUT BUFFER RING HEADER
BUF1:	BLOCK	203*2		;INPUT BUFFERS
BUF2:	BLOCK	203*2		;OUTPUT BUFFERS
TEMP:	BLOCK	4		;WORK AREA FOR CURRENT LINE TO BE DUMPED
COMP:	BLOCK	4		;FOR COMPARING LAST PRINTED LINE
				;TO CURRENT LINE IN TEMP

COMFIL:	XWD	3,3		;DESTINATION FOR QUEUED OUTPUT
	PAGE
WHAT:	TTCALL	3,[ASCIZ /
FILDMP COMMAND ERROR, TYPE HELP FOR HELP
/]
	JRST	FILDMP

NOINP:	JUMPN	ARG,.+2		;ANYTHING SPECIFIED ?
	JRST	FILDMP		;NO
	CAME	ARG,[SIXBIT /HELP/]
	CAMN	ARG,[SIXBIT /HELP!/]	;HELP REQ. ?
	JRST	HELP		;YES, SO GO TYPE MSG.
	JRST	WHAT		;NO, ERROR

BADOUT:	TTCALL	3,[ASCIZ /
NOT A LEGAL OUTPUT DEVICE, /]
	MOVEI	AC1,OUTDEV
	JRST	ERRRET

NOIN:	MOVEI	AC1,INDEV
	CAIA
NOOUT:	MOVEI	AC1,OUTDEV
	TTCALL	3,[ASCIZ /
CAN'T INIT DEVICE, /]
	JRST	ERRRET

BADIN:	TTCALL	3,[ASCIZ /
NOT A LEGAL INPUT DEVICE, /]
	MOVEI	AC1,INDEV
	JRST	ERRRET

BADMOD:	TTCALL	3,[ASCIZ /
DEVICE /]
	MOVEI	AC1,INDEV
	JSR	SIXPRT
	TTCALL	3,[ASCIZ / NOT CAPABLE OF BINARY INPUT
/]
	JRST	FILDMP

	IFN	SAVXT,<
BDOMOD:	TTCALL	3,[ASCIZ /
DEVICE /]
	MOVEI	AC1,OUTDEV
	JSR	SIXPRT
	TTCALL	3,[ASCIZ / NOT CAPABLE OF BINARY OUTPUT
/]
	JRST	FILDMP
>

ERRRET:	JSR	SIXPRT
	TTCALL	3,[ASCIZ /
/]
	JRST	FILDMP

NOFIL:	TTCALL	3,[ASCIZ /
?CAN'T FIND FILE/]
	JRST	GOBAK

NOWRIT:	TTCALL	3,[ASCIZ /
CAN'T WRITE FILE/]
	JRST	GOBAK

	IFN	SAVXT,<
ENDSAV:	MOVE	LCTR,CHR
	TLNE	FLAG,VXPDMP+VSXDMP	;EXPANDING SAVE FILE ?
	JRST	EXEX		;YES, FINISHED
	MOVEI	CHR,11		;HORIZ. TAB
	HRLI	CHR,-6		;WRITE SIX OF THEM
	JSR	PUT
	ADD	CHR,[XWD 1,0]
	JUMPL	CHR,.-2
	MOVEI	BP1,[SIXBIT /END/]
	JSR	SIXOUT		;WRITE THE ASSEMB. DIRECTIVE (END)
	MOVEI	CHR,40		;SPACE
	JSR	PUT
	JSR	PUT
	HRRZ	AC1,LCTR	;LCTR CONTAINS START ADDRESS
	PUSHJ	PD,OCTOUT	;WRITE THE ADDRESS
	JSR	CRLF		;END OF LINE
	JRST	EXEX		;DONE
>

HELP:	TTCALL	3,HLPMS1	;PRINT HELP MESSAGE
	IFN	SAVXT,<
	TTCALL	3,HLPMS2
>
	IFGE	BKGFL,<
	TTCALL	3,HLPMS3
>
	TTCALL	3,HLPMS4
	IFN	SAVXT,<
	TTCALL	3,HLPMS5
>
	IFGE	BKGFL,<
	TTCALL	3,HLPMS6
>
	IFN	SAVXT,<
	TTCALL	3,HLPMS7
>
	TTCALL	3,HLPMS8
	JRST	FILDMP		;THEN GO BACK TO BEGINNING
	PAGE
;************************
;	XLISTED BELOW
;
;	HEADINGS	---	HDG
;				HDG2
;				HDGC
;				HDGTT
;				HDGSAV
;
;	HELP MESSAGE	---	HLPMS1
;				HLPMS2
;				HLPMS3
;				HLPMS4
;				HLPMS5
;				HLPMS6
;				HLPMS7
;				HLPMS8
;
;	MONTH TABLE	---	DATTAB
;
;	LITERALS
;
;************************
	XLIST
;	A TABLE OF MONTHS, WITH ONE WORD PER NAME

DATTAB:	SIXBIT	/-JAN-'-FEB-'-MAR-'-APR-'-MAY-'-JUN-'/
	SIXBIT	/-JUL-'-AUG-'-SEP-'-OCT-'-NOV-'-DEC-'/

;	OUTPUT PAGE HEADINGS

HDG:	ASCII	/  O C T A L   &   A S C I I   F I L E   D U M P         DUMP OF (/
HDGC:	ASCII	/                                        PAGE           /

;	USED ON NON-TTY OUTPUT

HDG2:	ASCII	/ ADDR       ** 0 **        ** 1 **        ** 2 **      /
	ASCII	/  ** 3 **            ** ASCII **   /
	ASCIZ	/              ** SIXBIT **/

;	USED FOR TTY OUTPUT

HDGTT:	ASCII	/ ADDR       ** 0 **        ** 1 ** /
	ASCIZ	/       ** ASCII **   ** SIXBIT **/

;	HDGSAV USED FOR TRANSLATED SAVE FILES

	IFN	SAVXT,<
HDGSAV:	ASCII	/  LOC        OCTAL         ASCII   /
	ASCIZ	/SIXBIT   INSTRUCTION/
>

LLIN:	ASCIZ	/
        LINES  /
SAMLIN:	ASCIZ	/ SAME AS LINE  /
ENDG:	ASCIZ	/E N D   O F   D U M P
/
HLPMS1:	ASCIZ	/
*** GENERAL COMMAND FORMAT ***

LIST-DEV:_SOURCE DEV1:FILE1.EXT[PROJ,PROG],SOURCE DEV2:FILE3,... ETC.

	-LOGICAL DEVICE DSK ASSUMED WHEN NOT SPECIFIED.
	-NON-DIRECTORY DEVICE INPUT REQUIRES THAT A DUMMY FILENAME
	 BE INSERTED FOR EACH FILE.
	-THE ASTERISK (*) DESIGNATION FOR FILES IS NOT RECOGNIZED.
	-THE OUTPUT FILE RETAINS SAME NAME AS INPUT FILE,
	 BUT IS GIVEN THE EXTENSION OF (.DMP).
/

	IFN	SAVXT,<
HLPMS2:	ASCIZ	#	 IF /E SWITCH USED, THE EXTENSION OF (.COR) IS USED.
#
>
	IFGE	BKGFL,<
HLPMS3:	ASCIZ	/	-LINE PRINTER OUTPUT QUEUED FOR LATER PRINTING.
/
>

HLPMS4:	ASCIZ	/
*** SWITCHES ***

	-SWITCHES MUST IMMEDIATELY FOLLOW THE OUTPUT DEVICE DESIGNATION.

/
	IFN	SAVXT,<
HLPMS5:
ASCIZ	#		/D  A SAVE FILE IS READ, EXPANDED, AND DUMPED.
		/E  A SAVE FILE IS READ, EXPANDED, AND REWRITTEN.
#
>
	IFGE	BKGFL,<
HLPMS6:
ASCIZ	#		/L  LINE PRINTER OUTPUT SENT DIRECTLY TO THE
		    DEVICE, WITHOUT INTERMEDIATE QUEUEING.
#
>
	IFN	SAVXT,<
HLPMS7:
ASCIZ	#		/S  A SAVE FILE IS READ,EXPANDED, AND DUMPED,
		    ALSO SHOWING SYMBOLIC DUMP.
#
>
HLPMS8:
ASCIZ	#		/T  OUTPUT TO A NON-TELETYPE DEVICE IS FORMATTED
		    TO FIT A TTY PAGE.
#
	LIT
	LIST
THEEND:	END	FILDMP
   { k