BASE 0

!PROCEDURES
GLOBAL %LISACT
FIND %INITTTY,%HASH,%GETNUM,%GETOCT,%GETTOKEN,%LISTABLE
FIND %CHR.OUT,%OCTWD.OUT,%OCTOUT,%NUMOUT,%SIXOUT,%MAKE.SIXBIT
FIND %CHOOSE,%DATOUT,%GETDUM
LOCAL %LOOK.NAME,%CHK.IO.ERR,%CHK.ACT.ERR
LOCAL %OPEN.LUD
LOCAL %LUD.LOOK,%INITNONAME,%LIST.RECORD,%ADRESS.OUT,%LUD.OVERFLOW

DEF SIZE.BLK AS 128

!ID'S
FIND TOKEN(0)
GLOBAL USER(20),CUST(150),PPN,IER,ICODE,MODE
GLOBAL NUMBER,NAME.HASH,LOC.HASH,P,GETCMD:,CH.OUT
GLOBAL LISTFLG
LOCAL CH.LUD,TMP1,CMD,LIST, GAN
LOCAL L.INDEX,L.BLK(SIZE.BLK),TEMP,NAME(2)
LOCAL G.TMP, G.FLG, G.INDEX, G.TAB(500), A.ALL



!COMMANDS
DEF CMD.LIST AS 1
DEF CMD.ENDIT AS 2
DEF CMD.HELP AS 3


!FLAGS IN LISTFLG
DEF USER.LST AS 1
DEF CUST.LST AS 2
DEF ACCT.LST AS 3

! SIZE OF TABLES
DEF N.CMDS AS 3	!NUMBER OF PRIMARY COMMANDS
DEF N.LISTS AS 5 !NUMBER OF LIST COMMANDS

!TABLES
GLOBAL TABLE CMDS(1:N.CMDS)['LIST','QUIT','HELP']
GLOBAL TABLE LISTS(1:N.LISTS)['USER','PPN','ACCOUNT','CUSTOMER','ALL']
GLOBAL TABLE ALLS(1:2)['USERS','GANS']

!MACRO'S
DEF ACTSIT(A) AS BYT(USER(5),2,BITS.PER.WORD-2*(A-30))
DEF COLON AS CHR.OUT($:)
DEF CALL.GETACT(A,B) AS [ICODE_A; MODE_B; GETDUM]
DEF CHK.NO.USR AS [IF IER = 2 THEN [IF TEMP=0 THEN &
	MSG('NO USERS FOUND.$'); GO GETCMD]]
DEF CHECK.NO.MORE.IN(A) AS [IF TMP1_NCHV P=EOLIT OR TMP1=CARRET THEN A; PCHV P]
DEF CR AS CHR.OUT(CARRET)
DEF ENTER.NAME AS '$ENTER USER NAME: '
DEF FIXCP(A) AS (A-1)*SIZE.BLK	!COMPUTE CURSOR POS. FROM BLK. NO.
DEF LUD.READ AS [RB(CH.LUD,SIZE.BLK,L.BLK); L.INDEX_0]
DEF LUD(A) AS L.BLK(L.INDEX+A)
DEF GETNAME AS [CHECK.NO.MORE.IN(MSG(ENTER.NAME));GETTOKEN(2);MAKE.SIXBIT(TOKEN,NAME,12)]
DEF GET.GAN AS [CHECK.NO.MORE.IN(MSG('ACCOUNT: ')); GETOCT]
DEF GETCUST AS [CHECK.NO.MORE.IN(MSG('$ENTER CUSTOMER NO: ')); GETNUM]
DEF NAME.MATCH AS NAME(0)=USER(8) AND NAME(1)=USER(9)
DEF NOT.VALID AS [MSG('$NOT A VALID USER.$');CLOSE.ALL;GO GETCMD]
DEF NO.ACT AS [MSG('NO ACCOUNTING RECORD FOR '); IF LIST=1 THEN &
 SIXOUT(@NAME(0),12) ELSE OCTWD.OUT(USER(0));CLOSE.ALL;GO GETCMD]
DEF NO.CUST AS [MSG('NO ACCOUNTING RECORD FOR '); NUMOUT(CUST(0));GO GETCMD]
DEF OPT(A,B) AS [CR; LISTABLE(A,B); COLON]
DEF OV.BLK AS HW(@LUD(0),1)
DEF SIZE.LUD.ENT AS BYT(LUD(2),7,0)
DEF SP AS CHR.OUT(SPACE)
DEF SPACE AS $ 
DEF VERSION AS 10
DEF WHAT AS [MSG('?$'); GO GETCMD]


!LABELS
LOCAL LUD.ERR:,CHK.ERR:
%LISACT
	!MAINLINE
START: IOCS(2); INITNONAME
\\->START
GETCMD: LISTFLG _ 0
	CR; PUT($:); P _ GETLINE(TEL); GETTOKEN(0)
	IF CMD _ CHOOSE(N.CMDS,CMDS) = 0 THEN WHAT
	OPEN.LUD

DO CMD OF 1:N.CMDS

CMD.LIST: CHECK.NO.MORE.IN(OPT(N.LISTS,LISTS))
    GETTOKEN(0)
    WHILE LIST _ CHOOSE(N.LISTS,LISTS) = 0 THEN [OPT(N.LISTS,LISTS);&
	GETTOKEN(0)]

	DO LIST OF 1:N.LISTS

	1:    LISTFLG _ USER.LST; GETNAME
	   IF LUD.LOOK(NAME) = 0 THEN LOOK.NAME
	USER(0) _ LUD(0)
	A1: CALL.GETACT(1,-1); CHK.ACT.ERR
	    CALL.GETACT(3,-1); IF IER =1 THEN NO.ACT
	    CHK.ACT.ERR;LIST.RECORD

	2: LISTFLG _ USER.LST
	GET.GAN; HW(@TEMP,0) _ NUMBER
	CHECK.NO.MORE.IN(MSG('USER NO.: ')); GETOCT; HW(@TEMP,1) _ NUMBER
	USER(0) _ TEMP
	GO A1

	3: LISTFLG _ ACCT.LST; GET.GAN; GAN _ NUMBER
	   TEMP _ 0
	   CALL.GETACT(1,-1); CHK.ACT.ERR
	   LOOP DO
		CALL.GETACT(4,-1); CHK.NO.USR
		    CHK.ACT.ERR
		IF GAN=HW(USER,0) THEN [SIXOUT(@USER(8),12); CR; INC TEMP]
	   END

	4: LISTFLG _ CUST.LST; GETCUST
	CUST(0) _ NUMBER
	CALL.GETACT(1,1); CHK.ACT.ERR
	CALL.GETACT(3,1); IF IER = 1 THEN NO.CUST
	LIST.RECORD

	5: CHECK.NO.MORE.IN(OPT(2,ALLS))
	   GETTOKEN(0)
	   WHILE A.ALL_CHOOSE(2,ALLS)=0 THEN [OPT(2,ALLS);&
		GETTOKEN(0)]
	   G.INDEX _ 0; MOVE 100 FROM ALL 0 TO G.TAB
	   GETCUST; TEMP _ 0
	   USER(4)_NUMBER
	   CALL.GETACT(1,-1); CHK.ACT.ERR; CR
	   LOOP DO
		CALL.GETACT(8,-1); CHK.NO.USR
		CHK.ACT.ERR
		IF A.ALL = 1 THEN DO
		   SIXOUT(@USER(8),12); CR; INC TEMP
		END ELSE DO
		   G.FLG _ 0; GAN _ HW(USER,0)
		   FOR G.TMP _ 1 TO G.INDEX DO
			IF GAN = G.TAB(G.TMP) THEN INC G.FLG
		   END
		   IF G.FLG = 0 THEN DO
			OCTOUT(GAN); CR; INC TEMP
			G.TAB(INC G.INDEX) _ GAN
			IF G.INDEX=500 THEN [MSG('$OVER 500 GANS!');&
			   EXIT]
		   END
		END
	   END
	END

CMD.ENDIT: CLOSE.ALL; MSG('$E.O.J.$'); EXIT

CMD.HELP: MSG('LEGAL COMMANDS ARE:$')
   LISTABLE(N.CMDS,CMDS); MSG('.$')


END
  GO GETCMD





%LUD.LOOK(ADR)
	!LOOK UP NAME IN ADR,ADR+1 IN LUD
HASH(^ADR,^(ADR+1))
SETCP(CH.LUD,FIXCP(LOC.HASH)); LUD.READ 
WHILE NAME.HASH # LUD(4) THEN DO	
	L.INDEX+_SIZE.LUD.ENT
	IF LUD(0)=0 THEN RETURN 0
	IF LUD(0)<0 THEN LUD.OVERFLOW
	END
RETURN 1
END LUD.LOOK


%LOOK.NAME
	!SEARCH FOR NAME IN ACCTG.
CALL.GETACT(1,-1); CHK.ACT.ERR
LOOP DO
	CALL.GETACT(4,-1)
	IF NAME.MATCH THEN [LIST.RECORD; GO GETCMD]
	IF IER = 2 THEN NOT.VALID
	CHK.ACT.ERR
END
END LOOK.NAME


%CHK.ACT.ERR
	!CHECK ACCTG. ERROR
IF IER = 0 THEN RETURN
MSG('ERROR ON '); IF MODE < 0 THEN MSG('USERNA.MES') ELSE MSG('CUSTOM.ERS')
CR

DO IER OF 1:4
1: MSG('ENTRY NOT FOUND.')
2: MSG('END OF FILE FOUND.')
3: MSG('ERROR ON FILE.')
4: MSG('MISC. ERROR.')
END
EXIT
END CHK.ACT.ERR



%CHK.IO.ERR
	!TAKE CARE OF ALL I/O ERRORS FROM IOCS...
CHK.ERR: MSG('ERROR ON ');WFID(FIDP);MSG('...');CR
  DO ERRNUM OF TMFERR:CORERR
FNDERR: MSG('BAD FILE MODE OR TYPE')
IFDERR: MSG('ILLEGAL FILE IDENTIFIER')
FNFERR: MSG('FILE NOT FOUND')
IUSERR: MSG('INVALID USER NAME')
PRTERR: MSG('PROTECTION FAILURE')
EOFERR: MSG('END OF FILE')
 END
MSG('.$ERROR ');NUMOUT(ERRNUM);EXIT
END CHK.IO.ERR


%LUD.OVERFLOW
	!READ LUD OVERFLOW BLOCK
SETCP(CH.LUD,OV.BLK*SIZE.BLK)
LUD.READ
RETURN
END LUD.OVERFLOW




%INITNONAME
	!INIT PROGRAM
INITTTY(GETCMD)
CMD _ 0
PPN _ OCT 1042313
CH.OUT _ OPEN('TEL',SEQUEN+OUTPUT+CHARACTER,CHK.ERR,2)
MSG('$LIST ACCOUNTING - VERSION '); NUMOUT(VERSION);MSG('$$$')
MOVE 72/CHARS.PER.WORD FROM ALL 0 TO TOKEN
 RETURN
END INITNONAME



%LIST.RECORD(LISTNUM)
LOCAL VALIDF, FLG
VALIDF _ 0
DO LISTFLG OF 1:2

1: MSG('$USER NAME: '); SIXOUT(USER+8,12)
    MSG('$PPN: '); OCTWD.OUT(USER(0))
    MSG('$PRICING CODE: '); OCTOUT(USER(1))
    MSG('$TRACKING CODE: '); NUMOUT(USER(2))
    MSG('$SALESMAN: '); NUMOUT(USER(3))
    MSG('$CUSTOMER: '); NUMOUT(USER(4))
	FOR TEMP _ 31 TO 42 DO
		IF FLG _ ACTSIT(TEMP) = 2 THEN [MSG('$SITE: '); NUMOUT(TEMP);&
					INC VALIDF]
		IF FLG = 3 THEN [MSG('$SITE: '); NUMOUT(TEMP);&
		   MSG(' - INVALID'); INC VALIDF]
	END
	IF VALIDF = 0 THEN MSG('$NOT VALID ON ANY SYSTEM.')
	IF BYT(USER(7),1,1)=1 THEN MSG('$TYMSHARE')
	IF BYT(USER(7),1,0)=1 THEN MSG('$ACCOUNT SUPERVISOR')
2: SIXOUT(@CUST(9),30)
	MSG('$BILLING DISTRICT: '); NUMOUT(CUST(1))
	MSG('$'); IF CUST(81) = 1 THEN MSG('NON-')
	MSG('$STANDARD INVOICE.')
	MSG('$BILLING REGION: '); NUMOUT(CUST(78))
	IF CUST(75)=1 THEN MSG('$MINIMUM CUSTOMER.')
	IF CUST(77)=1 THEN MSG('$NON-TIMESHARING CUSTOMER.')
	ADRESS.OUT(0)
	IF CUST(45)#0 THEN ADRESS.OUT(30)
END
CR; RETURN
END LIST.RECORD




%ADRESS.OUT(INDEX)
	!OUTPUT ADDRESS IN 5[LINES OF 30 CHARS
CR; TEMP _ 0
REPEAT 5 DO
	IF BYT(CUST(15+TEMP+INDEX),6,30)=0 THEN RETURN
	SIXOUT(@CUST(15+TEMP+INDEX),30); TEMP+_5; CR
END
RETURN
END ADRESS.OUT


%OPEN.LUD
	!LOOK FOR LUD.SYS ON DSK
	CH.LUD_OPEN('(SYS)LUD.SYS',DIRECT+INPUT+WORD,LUD.ERR)
	RETURN
LUD.ERR:CHK.IO.ERR
END OPEN.LUD





END LISACT
