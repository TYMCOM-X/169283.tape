BASE 0

!PROCEDURES

GLOBAL %NONAME

FIND %INITTTY, %HASH, %QUERY, %GETNUM, %GETOCT, %GETTOKEN, %LISTABLE
FIND %CHR.OUT, %OCTWD.OUT, %OCTOUT, %OUT, %NUMOUT, %SIXOUT, %MAKE.SIXBIT
FIND %CHOOSE, %DATOUT, %SHORT.OUT, %SPOUT
FIND %GETULC, %NEWGET

LOCAL %CHK.IO.ERR, %CHECK.CHG, %HEADING, %FILL.G.TAB
LOCAL %DUL.LOOK, %DUL.OVERFLOW
LOCAL %OPEN.LUD, %MAKE.ROOM, %KNOW.ACCT
LOCAL %OPEN.AND.LUD.LOOK, %OPEN.AND.DUL.LOOK
LOCAL %LUD.LOOK, %LUD.SEQ, %DUL.SEQ, %LIST.RECORD, %LUD.OVERFLOW
LOCAL %CHANGEIT, %INITNONAME, %LIST.ALL.LISTS, %CHK.LUD.OR.ACCTG
LOCAL %LOOK.NAME, %LIST.A.RECORD, %ADRESS.OUT, %GANS.OUT, %CALL.UUO
LOCAL %CHK.ACT.ERR
LOCAL %CUS.CHK, %USR.CHK, %LUD.CHK, %DUL.CHK, %USRLDL, %ERROR
LOCAL %SERCH.CUS, %CUS.LOOK, %ACT.LOOK

DEF SIZE.BLK AS 128

!ID'S
FIND TOKEN(0), PPN, USER(0), CUST(0), ICODE, MODE, IER

GLOBAL NUMBER, NAME.HASH, LOC.HASH, P, CH.OUT
GLOBAL USER.NAME(2), LISTFLG, ALTTYP

LOCAL CK.C:
GLOBAL GETCMD:, LUD.ERR:, CHK.ERR:

LOCAL THIS.PPN, THIS.GAN, THIS.DIST, THIS.A.S, THIS.TYM, THIS.NAME(2)
LOCAL SALES
LOCAL THIS.SYS, GOD, OPER, C.SER.FLG, ACTG.SITE.FLG, CAN.LOOK
LOCAL DULFLG, SAVCP, BADBLK, BADFIL
LOCAL SAVORG(SIZE.BLK), OLDBLK, STATUS, TYPE, GAN, DIST, SITE, K.ALL
LOCAL CH.LUD, CH.DUL, IO.ADR, CMD, LIST, L.MODE, ZONE
LOCAL SEQ.FLG
LOCAL D.INDEX, D.BLK(SIZE.BLK), D.BLKNO
LOCAL L.INDEX, L.BLK(SIZE.BLK), L.BLKNO
LOCAL LUD.SIZE, TEMP, TEMP1, CH.NUM, TEMP.INDEX, BUD.INDEX
DEF G.MAX AS 3000
LOCAL G.TMP, G.FLG, G.INDEX, G.TAB(G.MAX), G.SITES(G.MAX)



!COMMANDS
DEF CMD.LST AS 1
DEF CMD.CHANGE AS 2
DEF CMD.NAMES AS 3
DEF CMD.ENDIT AS 6
DEF CMD.HELP AS 4
DEF CMD.INSTR AS 5
DEF CMD.CHECK AS 7


!MODES FOR NEWGET
DEF C.MODE AS 1
DEF U.MODE AS -1

!CODES FOR NEWGET
DEF INIT.RD AS 1
DEF READ.SP AS 3
DEF READ.NXT AS 4
DEF CLOSE.ACTG AS 6
DEF NXT.CST AS 8

!FLAGS IN LISTFLG
DEF CUST.LST AS 4
DEF USER.LST AS 1
DEF ACCT.LST AS 2
DEF CHANGE AS 4
DEF DIST.LST AS 3
DEF ALL.SET AS -1

!LISTING COMMANDS
DEF LST.USER AS 1	!LIST USER
   DEF LST.U.ACC AS 2		!ACCOUNTING
   DEF LST.U.LUD AS 1		!LUD
DEF LST.GAN AS 2	!LIST GAN
   DEF LST.G.LUD AS 1		!LUD
   DEF LST.G.ACC AS 2		!ACCOUNTING
DEF LST.DIST AS 3	!LIST DISTRICT
DEF LST.PPN AS 4	!LIST PROJECT-PROGRAMMER
   DEF LST.P.LUD AS 1		!LUD
   DEF LST.P.ACC AS 2		!ACCOUNTING
DEF LST.CUST AS 5	!LIST CUSTOMER
DEF LST.ALL AS 6	!LIST ALL
   DEF L.ALL.GANS AS 1		!GANS
   DEF L.ALL.USERS AS 2		!USERS
   DEF L.ALL.CUSTS AS 3		!CUSTOMERS
   DEF L.ALL.LUD AS 4		!USERS IN LUD
DEF LST.SALES AS 7	!LIST SALESMAN AND CUSTOMERS
DEF LST.RUB AS 8	!LIST ALL USERS WITH RUB ON

DEF G.SALES AS  1
DEF G.CUST AS 2

!CHANGES TO BE MADE
DEF CH.LIC AS 4
DEF CH.MSG AS 5
DEF CH.INIT AS 6
DEF CH.ZONE AS 7
DEF CH.DET AS 8
DEF CH.MODE AS 9
DEF CH.STR AS 10
DEF CH.CORE AS 11
DEF CH.GFD AS 12

!FLAGS IN STATUS
DEF NO.CHG AS 0
DEF OLD.OUT AS 1	!OLD BLK WAS WRITTEN OUT.WITHOUT THIS USER

!SIZE OF TABLES
DEF N.U.CMDS AS 6	!NUMBER OF USER COMMANDS
DEF N.O.CMDS AS 7	!NUMBER OF OPER-ONLY COMMAND
DEF N.U.LST.CMDS AS 3	!NUMBER OF USER LIST COMMANDS
DEF N.O.LST.CMDS AS 8	!NUMBER OF OPER-ONLY LIST COMMANDS
DEF N.CMDS AS 7	!NUMBER OF PRIMARY COMMANDS
DEF N.A.LST.CMDS AS 7
DEF N.TYPES AS 2
DEF N.ALL.CMDS AS 4
DEF N.MODES AS 4	!NUMBER OF MODES
DEF N.ZONES AS 17 	!NUMBER OF TIME ZONES

!TABLES

GLOBAL TABLE U.CMDS(1:N.U.CMDS)['LIST','CHANGE','NAMES','HELP',&
   'INSTRUCTIONS','QUIT']

GLOBAL TABLE O.CMDS(1:N.O.CMDS)[-1,-1,-1,-1,-1,-1,'CHECK']

GLOBAL TABLE A.LST.CMDS(1:N.A.LST.CMDS)[-1,-1,-1,-1,-1,-1,'SALESMEN']

GLOBAL TABLE U.LST.CMDS(1:N.U.LST.CMDS)['USER','GAN','DISTRICT']

GLOBAL TABLE O.LST.CMDS(1:N.O.LST.CMDS)[-1,-1,-1,'PPN','CUSTOMER','ALL',-1,'RUB']

GLOBAL TABLE TYPE.CMD(1:N.TYPES)['LUD','ACCOUNTING']

GLOBAL TABLE ALL.CMDS(1:N.ALL.CMDS)['GANS','USERS','CUSTOMERS','LUD']

GLOBAL TABLE MODES(1:N.MODES)['PDP10','XEXEC','XEXECH','SUDS']

GLOBAL TABLE ZONES(1:N.ZONES)[7(-1),'PACIFIC','MOUNTAIN','CENTRAL',&
	'EASTERN',4(-1),'LONDON','PARIS']

!ERROR MESSAGES FOR READ DATA ERRORS
DEF NODUL.BAD AS 1
DEF NOACT.BAD AS 2
DEF HASH.BAD AS 3
DEF BLKNO.BAD AS 4
DEF NAME.BAD AS 5
DEF DIST.BAD AS 6
DEF NOLUDA.BAD AS 7
DEF NOLUD.BAD AS 10
DEF NOUSER.BAD AS 12
DEF GARBAGE AS 13
DEF TEXT.BAD AS 14
DEF NOCUST.BAD AS 15
DEF BAD.PPNS AS 16
DEF OVER.BAD AS 20

!MACRO'S
DEF ACCT.GAN AS 4
DEF ACT.SIT(A) AS BYT(USER(5),2,BITS.PER.WORD-2*(A-30))
DEF ACTSUP.BIT AS BYT(LUD(3),1,13)
DEF ACT.NAME.OUT AS SIXOUT(USER+8,12)
DEF ALL.SITES AS 31 TO 42
DEF BIG AS (LISTFLG = ACCT.LST OR LISTFLG = DIST.LST)
DEF GETACT(A,B) AS [ICODE _ A; MODE _ B; NEWGET]
DEF COLON AS MSG(': ')
DEF COMMA AS MSG(', ')
DEF CHK.MAX AS IF G.INDEX >= G.MAX THEN [MSG('$OVER '); &
   NUMOUT(G.MAX); MSG(' ENTRIES IN G.TAB.$'); REPEAT 0]
DEF CHK.NO.USER AS [IF IER = 2 THEN [IF TEMP=0 THEN &
   MSG('$NO USERS FOUND.'); GO GETCMD]]
DEF CHK.OPER AS [IF OPER = 0 THEN [MSG('$YOU MAY NOT EXECUTE THIS ');&
   MSG('COMMAND.'); GO GETCMD]]
DEF CHK.SITE AS IF THIS.SYS # 32 THEN [MSG('$THIS COMMAND MAY ONLY &
BE EXECUTED ON THE ACCOUNTING SYSTEM.$'); GO GETCMD]
DEF CHECK.NO.MORE.IN(A) AS [IF TEMP_NCHV P=EOLIT OR TEMP=CARRET THEN A;&
	 PCHV P]
DEF CORE1.LUD AS BYT(LUD(3),7,0)
DEF CORE2.LUD AS BYT(LUD(3),7,18)
DEF CR AS CHR.OUT(CARRET)
DEF C.NAME.OUT AS SIXOUT(CUST+9,30)
DEF DASH AS CHR.OUT($-)
DEF DAYLIG.BIT AS BYT(LUD(3),1,33)
DEF DETACH.BIT AS BYT(LUD(3),1,15)
DEF DIST.BITS AS BYT(LUD(1),8,0)
DEF DISTOUT AS [SPOUT(DIST.BITS,4); NUMOUT(DIST.BITS)]
DEF DOTS AS OUT('...')
DEF DUL(A) AS D.BLK(D.INDEX+A)
DEF DUL.READ AS [RB(CH.DUL,SIZE.BLK,D.BLK); D.INDEX _ 0]
DEF ENTER.NAME AS '$ENTER USER NAME: '
DEF EQUALS AS CHR.OUT($=)
DEF FIXCP(A) AS (A-1)*SIZE.BLK	!COMPUTE CURSOR POS. FROM BLK. NO.
DEF L.GAN AS HW(@LUD(0),0)
DEF GAN.OUT AS OCTOUT(L.GAN)
DEF GFD.BIT AS BYT(LUD(2),1,32)
DEF GET.CUST AS [CHECK.NO.MORE.IN(MSG('$ENTER CUSTOMER NO: ')); GETNUM]
DEF GET.GAN AS [CHECK.NO.MORE.IN(MSG('$GLOBAL ACCOUNT: ')); GETOCT]
DEF GET.UUN AS [CHECK.NO.MORE.IN(MSG('$UUN: ')); GETOCT]
DEF GET.NAME(A) AS [IF OPER=1 OR THIS.A.S=1 THEN [&
   CHECK.NO.MORE.IN(A);GETTOKEN(2);MAKE.SIXBIT(TOKEN,USER.NAME,12)] ELSE [&
   USER.NAME(0) _ THIS.NAME(0); USER.NAME(1) _ THIS.NAME(1)]]
DEF INIT.BIT AS BYT(LUD(2),1,8)
DEF INIT.LONG.LIST AS [HEADING; OPEN.LUD; LUD.SEQ]
DEF KEEP.CP AS [TEMP _ CP(CH.LUD); TEMP-_SIZE.BLK; SETCP(CH.LUD,TEMP)]
DEF LEGAL AS (OPER # 0 OR (THIS.A.S = 1 AND SAMACCT) OR SAMUSR)
DEF LEGAL.CH(A) AS (OCT 37 < A < OCT 133) OR A = 0
DEF LITTLE AS NOT(BIG)
DEF LUD(A) AS L.BLK(L.INDEX+A)
DEF LUD.READ AS [RB(CH.LUD,SIZE.BLK,L.BLK); L.INDEX _ 0]
DEF LUD.TEMP(A) AS LUD(TEMP.INDEX+A)
DEF LUD.WRIT AS [KEEP.CP; WB(CH.LUD,SIZE.BLK,L.BLK)]
DEF MODE.BIT AS BYT(LUD(3),2,7)
DEF MOVE.DOWN AS [TEMP1_TRU.BIT;FOR TEMP_TEMP1+5 TO TEMP1+7 &
    LUD(TEMP+3) _ LUD(TEMP)]
DEF N.LUD.BLKS AS SIZE(CH.LUD)/SIZE.BLK
DEF NAME.MATCH AS USER.NAME(0)=USER(8) AND USER.NAME(1)=USER(9)
DEF NAMOUT AS SIXOUT(@DUL(1),12)
DEF NO.ACT AS [MSG('$NO ACCOUNTING RECORD FOR THAT USER.'); GO GETCMD]
DEF NO.CUST AS [MSG('$NO ACCOUNTING RECORD FOR '); NUMOUT(CUST(0)); GO GETCMD]
DEF NOT.VALID AS [MSG('$NOT A VALID USER'); GO GETCMD]
DEF NO.ZONE.CHG AS [MSG('$OPER CAN NOT HAVE ITS TIME ZONE CHANGED.');GO GETCMD]
DEF OPEN.TEL AS CH.OUT _ OPEN('TEL',SEQUEN+OUTPUT+CHARACTER,CHK.ERR,2)
DEF OPEN.DUL AS CH.DUL _ OPEN('(SYS)DUL.SYS',DIRECT+INPUT+WORD,CHK.ERR)
DEF OPER.PPN AS OCT 1000021
DEF OTITLE AS [OUT('$PDP-10 CONSISTENCY CHECK - SITE '); NUMOUT(THIS.SYS);&
   CR; DATOUT]
DEF OUT.WHERE AS [MSG('$OUTPUT TO: '); GETTOKEN(0); &
	CH.OUT _ OPEN(TOKEN,SEQUEN+OUTPUT+CHARACTER,CHK.ERR,2)]
DEF OV.BLK AS HW(@LUD(0),1)
DEF PPN.OUT AS OCTWD.OUT(LUD(0))
DEF PROT.FAILURE AS [MSG('$YOU DO NOT HAVE ACCESS TO THAT USER NAME$$'); GO GETCMD]
DEF RUB.BIT AS BYT(LUD(2),1,33)
DEF SAMACCT AS THIS.GAN = L.GAN
DEF SAMUSR AS THIS.PPN = LUD(0)
DEF SET.TEMP AS [IF INIT.BIT = 1 THEN TEMP.INDEX _ 3;&
   IF BUD.INDEX _ TRU.BIT = 1 THEN INC TEMP.INDEX]
DEF SIZE.INC AS SIZE.LUD.ENT _ SIZE.LUD.ENT + 3
DEF SIZE.DEC AS SIZE.LUD.ENT _ SIZE.LUD.ENT - 3
DEF SIZE.LUD.ENT AS BYT(LUD(2),7,0)
DEF SP AS CHR.OUT(SPACE)
DEF SPACE AS $ 
DEF SUPMSG.BIT AS BYT(LUD(2),1,34)
DEF TIM.OUT.BIT AS BYT(LUD(3),1,16)
DEF TRU.BIT AS BYT(LUD(2),1,31)
DEF TYM.BIT AS BYT(LUD(3),1,14)
DEF TYPSPACE(A) AS [REPEAT A SP]
DEF USER.MISSING AS [PPN.OUT; OUT(' MISSING FROM DUL.$')]
DEF L.UUN AS HW(@LUD(0),1)
DEF UUN.OUT AS OCTOUT(L.UUN)
DEF VALID AS 2
DEF VERSION AS 16
DEF WHAT AS [MSG('?$'); GO GETCMD]
DEF WRITE.OUT(A) AS [MSG(A); OUT(A)]
DEF ZONE.BIT AS BYT(LUD(3),5,28)


%NONAME
	!MAINLINE
LOCAL ENDLUD:
START: INITNONAME
\\->START
GETCMD: STATUS _ NO.CHG; SEQ.FLG _ IO.ADR _ 0; CLOSE.ALL
OPEN.TEL
CR; MSG('$: '); P _ GETLINE(TEL); GETTOKEN(0)
IF CMD _ CHOOSE(N.U.CMDS,U.CMDS) = 0 THEN DO
   IF OPER # 0 THEN DO
	IF CMD _ CHOOSE(7,O.CMDS) = 0 THEN WHAT
   END ELSE WHAT
END

DO CMD OF 1:N.CMDS

CMD.LST: LOOP DO
   IF TEMP_NCHV P=EOLIT OR TEMP=CARRET THEN LIST.ALL.LISTS &
	ELSE [PCHV P; GETTOKEN(0)]
   IF LIST _ CHOOSE(N.U.LST.CMDS,U.LST.CMDS) = 0 THEN DO
	IF THIS.GAN = ACCT.GAN OR GOD # 0 THEN DO
	   IF LIST _ CHOOSE(N.A.LST.CMDS,A.LST.CMDS) # 0 THEN GO GOT.LST
	END
	IF OPER # 0 OR CAN.LOOK # 0 THEN DO
	   IF LIST_CHOOSE(N.O.LST.CMDS,O.LST.CMDS) # 0 THEN GO GOT.LST
	   LIST.ALL.LISTS
	END ELSE LIST.ALL.LISTS
   END ELSE GO GOT.LST
END


GOT.LST: DO LIST OF LST.USER:LST.RUB
   LST.USER: CHK.LUD.OR.ACCTG; GET.NAME(MSG(ENTER.NAME))
	LIST.FLG _ USER.LST

   DO TYPE OF LST.U.LUD:LST.U.ACC

   LST.U.LUD: L.LUD: IF OPEN.AND.LUD.LOOK(USER.NAME) = 0 THEN NOT.VALID
	IF LEGAL THEN LIST.RECORD(ALL.SET) ELSE PROT.FAILURE

   LST.U.ACC: IF OPEN.AND.LUD.LOOK(USER.NAME) = 0 THEN LOOK.NAME
	USER(0) _ LUD(0)
	L.ACC: GETACT(INIT.RD,U.MODE); CHK.ACT.ERR
	GETACT(READ.SP,U.MODE); IF IER = 1 THEN NO.ACT
	CHK.ACT.ERR; LIST.A.RECORD

   END

LST.PPN: CHK.LUD.OR.ACCTG; LISTFLG _ USER.LST
   GET.GAN; HW(USER,0) _ NUMBER
   GET.UUN; HW(USER,1) _ NUMBER

   DO TYPE OF LST.P.LUD:LST.P.ACC

   LST.P.LUD: IF OPEN.AND.DUL.LOOK(USER(0)) # 0 THEN DO
	USER.NAME(0) _ DUL(1); USER.NAME(1) _ DUL(2)
	GO L.LUD
   END ELSE [LUD(0) _ USER(0); USER.MISSING]

   LST.P.ACC: GO L.ACC

   END


LST.GAN: CHK.LUD.OR.ACCTG; LISTFLG _ ACCT.LST

   DO TYPE OF LST.G.LUD: LST.G.ACC

   LST.G.LUD: IF OPER # 0 THEN DO
	   IF KNOW.ACCT = 1 THEN &
		[CHECK.NO.MORE.IN(MSG('$ACCOUNT: ')); GETOCT]
	END ELSE NUMBER _ THIS.GAN
	INIT.LONG.LIST; INC SEQ.FLG
	LOOP DO
	   IF LEGAL AND NUMBER = L.GAN THEN LIST.RECORD(ALL.SET)
	   LUD.SEQ
	END

   LST.G.ACC: LISTFLG _ ACCT.LST; GET.GAN; GAN _ NUMBER
	TEMP _ 0
	GETACT(INIT.RD,U.MODE); CHK.ACT.ERR
	LOOP DO
	   GETACT(READ.NXT,U.MODE); CHK.NO.USER; CHK.ACT.ERR
	   IF GAN=HW(USER,0) THEN DO
		ACT.NAME.OUT
		CR; INC TEMP
	   END
	END

   END

LST.CUST: CHK.SITE; LIST.FLG _ CUST.LST; GET.CUST
   CUST(0) _ NUMBER
   GETACT(INIT.RD,C.MODE); CHK.ACT.ERR
   GETACT(READ.SP,C.MODE); IF IER = 1 THEN NO.CUST
   LIST.A.RECORD

LST.RUB: CHK.OPER; IO.ADR _ ENDLUD
   OUT.WHERE; OPEN.LUD; INC SEQ.FLG; LUD.SEQ
   LOOP DO
	IF OPEN.AND.DUL.LOOK(LUD(0)) # 0 AND RUB.BIT # 0 THEN &
	   [NAMOUT; SP; NUMOUT(TYM.BIT); CR]
	CLOSE(CH.DUL); LUD.SEQ
   END

LST.DIST: CHK.SITE; IF THIS.TYM # 1 THEN WHAT
   IF DIST _ THIS.DIST = 0 OR GOD # 0 THEN DO
	MSG('$DISTRICT: '); GETNUM; 	DIST _ NUMBER
   END
   OUT.WHERE; TEMP _ 0
   GETACT(INIT.RD,C.MODE); CHK.ACT.ERR
   LOOP DO
	GETACT(READ.NXT,C.MODE)
	IF IER = 2 THEN DO
	   IF TEMP = 0 THEN OUT('$NO CUSTOMERS FOUND.')
	   GO GETCMD
	END
	CHK.ACT.ERR
	IF DIST = CUST(1) THEN DO
	   INC TEMP
	   SPOUT(CUST(0),5); NUMOUT(CUST(0)); SP
	C.NAME.OUT; CR
	END
   END

LST.SALES: CHK.SITE; OUT.WHERE; FILL.G.TAB(G.SALES); GETACT(INIT.RD,C.MODE)
   CHK.ACT.ERR
   LOOP DO
	GETACT(READ.NXT,C.MODE); WHILE IER # 2
	CHK.ACT.ERR
	SPOUT(CUST(0),4); NUMOUT(CUST(0));SP
	C.NAME.OUT; SP
	IF SALES _ SERCH.CUS # 0 THEN [SPOUT(USER(3),5); NUMOUT(SALES)]
	CR
   END

LST.ALL: CHECK.NO.MORE.IN([LISTABLE(N.ALL.CMDS,ALL.CMDS); COLON])
   GETTOKEN(0)
   WHILE K.ALL _ CHOOSE(N.ALL.CMDS,ALL.CMDS) = 0 THEN DO
	CR; LISTABLE(N.ALL.CMDS,ALL.CMDS)
	GETTOKEN(0)
   END

   OUT.WHERE

   DO K.ALL OF L.ALL.GANS:L.ALL.LUD

   L.ALL.GANS: CHK.SITE; GET.CUST; G.INDEX _ 0
	 MOVE 500 FROM ALL 0 TO G.TAB; TEMP _ 0
	USER(4) _ NUMBER
	GETACT(INIT.RD,U.MODE); CHK.ACT.ERR; CR
	LOOP DO
	   GETACT(NXT.CST,U.MODE); CHK.NO.USER; CHK.ACT.ERR
	   GANS.OUT
	END

   L.ALL.USERS: CHK.SITE
   IF OPER#0 AND TEMP_QUERY('$FOR ALL CUSTOMERS')=1 THEN DO
	GETACT(INIT.RD,-2); IF IER # 0 THEN CHK.ACT.ERR
	LOOP DO
	   GETACT(READ.NXT,-2); IF IER = 2 THEN GO GETCMD
	   CHK.ACT.ERR
	   OUT(USER+8); SP
	   OCTOUT(HW(USER,0)); CHR.OUT($,)
	   OCTOUT(HW(USER,1));  SP
	   OCTOUT(USER(1))
	   SPOUT(USER(2),3); NUMOUT(USER(2))
	   SPOUT(USER(3),5); NUMOUT(USER(3))
	   SPOUT(USER(4),4); NUMOUT(USER(4))
	   SP
	   FOR TEMP _ ALL.SITES NUMOUT(ACTSIT(TEMP))
	   SP; OCTOUT(BYT(USER(5),12,0)); CR
	END
   END ELSE DO
	   GET.CUST; USER(4) _ NUMBER; TEMP _ 0
	   GETACT(INIT.RD,U.MODE); CHK.ACT.ERR
	   LOOP DO
		GETACT(NXT.CST,U.MODE); CHK.NO.USER; CHK.ACT.ERR
		ACT.NAME.OUT; CR; INC TEMP
	   END
   END

   L.ALL.CUSTS: CHK.SITE; CHK.OPER; LIST.FLG _ CUST.LST
   IF SITE _ QUERY('$FOR ALL SITES') = 0 THEN DO
	MSG('$SITE: '); SITE _ GETNUM
   END ELSE SITE _ 0
   GAN _ QUERY('$INCLUDE GANS')
   IF SITE # 0 OR GAN = 1 THEN FILL.G.TAB(G.CUST)
   GETACT(INIT.RD,C.MODE); CHK.ACT.ERR
   LOOP DO
	GETACT(READ.NXT,C.MODE); WHILE IER # 2
	CHK.ACT.ERR; TEMP _ 0
	IF SITE # 0 THEN DO
	   FOR G.TMP _ 1 TO G.INDEX DO
		IF CUST(0)=HW(@G.TAB(G.TMP),1) THEN TEMP_TEMP BOR G.SITES(G.TMP)
	   END
	END
	IF SITE=0 OR BYT(TEMP,2,BITS.PER.WORD-2*(SITE-30))=2 THEN DO
	   LIST.A.RECORD
	   IF GAN = 1 THEN DO
		TEMP _ 10
		FOR G.TMP _ 1 TO G.INDEX DO
		   IF CUST(0)=HW(@G.TAB(G.TMP),1) THEN DO
			OCTOUT(HW(@G.TAB(G.TMP),0))
			IF DEC TEMP <= 0 THEN [CR; TEMP_10] ELSE SP
		   END
		END
	   END
	END
   END

   L.ALL.LUD: CHK.OPER; IO.ADR _ ENDLUD
   OPEN.LUD; INC SEQ.FLG; LUD.SEQ
   LOOP DO
      IF OPEN.AND.DUL.LOOK(LUD(0)) # 0 THEN DO
	CLOSE(CH.DUL)
	NAMOUT; SP
	GAN.OUT; SP
	DISTOUT; SP
	NUMOUT(TYM.BIT); CR
      END
      LUD.SEQ
   END

   END
END

CMD.CHANGE: GETNAME(MSG(ENTER.NAME))
	IF OPEN.AND.LUD.LOOK(USER.NAME) = 0 THEN NOT.VALID
	IF NOT(LEGAL) THEN PROT.FAILURE
	LISTFLG _ CHANGE; LIST.RECORD(ALL.SET)
   LOOP DO
	STATUS _ NO.CHG
	MOVE SIZE.BLK FROM LBLK TO SAVORG	!SAVE OLD ENTRY
	MSG('$CHANGE WHICH ITEM - TYPE NUMBER:  ')
	CH.NUM _ GETNUM; CR
	IF CHANGEIT(CH.NUM) = 1 THEN DO
	  IF CHECK.CHG(CH.NUM)=1 THEN &
		[LUD.WRIT; MSG('$CHANGE COMPLETED.$')]
	  IF QUERY('ANOTHER') = 0 THEN GO ENDLUD ELSE &
		[CLOSE.ALL; OPEN.AND.LUD.LOOK(USER.NAME)]
	END ELSE MSG('ILLEGAL NUMBER.$')
   END

CMD.NAMES: IO.ADR _ ENDLUD; OUT.WHERE
   IF THIS.A.S # 0 THEN DO
	OPEN.LUD; INC SEQ.FLG; LUD.SEQ
	LOOP DO
	   IF SAMACCT THEN DO
		IF OPEN.AND.DUL.LOOK(LUD(0)) = 0 THEN &
		   USER.MISSING ELSE [NAMOUT; CR]
	   END
	   LUD.SEQ
	END
   END ELSE [SIXOUT(THIS.NAME,12); CR]

CMD.ENDIT: CLOSE.ALL; MSG('$E.O.J.$'); EXIT

CMD.HELP: MSG('$LEGAL COMMANDS ARE:$')
   IF OPER = 1 THEN [MSG(O.CMDS(N.O.CMDS)); COMMA]
   LISTABLE(N.U.CMDS,U.CMDS); MSG('.$')

CMD.INSTR: MSG('$SEE (SYS)NONAME.INF')
   IF OPER = 1 OR THIS.GAN = ACCT.GAN THEN MSG('$ALSO (SYS)NONAME.OPR')

CMD.CHECK: IF THIS.SYS # 32 THEN &
    MSG('$MAKE SURE USERNA.MES IS UP TO DATE ON THIS SYSTEM BEFORE EXECUTING THIS COMMAND.$')
   OPEN.TEL; OTITLE
   OUT.WHERE; OTITLE
   IF THIS.SYS = 32 THEN [CUS.CHK; USR.CHK]
   OPEN.LUD; OPEN.DUL
   LUD.CHK; DUL.CHK; USRLDL
END

ENDLUD:  LISTFLG _ 0;  GO GETCMD

ALTTYP: IF STATUS = NO.CHG THEN [CLOSE.ALL; GO GETCMD]
	MOVE SIZE.BLK FROM SAVORG TO LBLK
	SETCP(CH.LUD,FIXCP(OLDBLK)); WB(CH.LUD,SIZE.BLK,L.BLK)
	CLOSE.ALL; GO GETCMD





%FILL.G.TAB(TYPE)
LOCAL OLD.PTR, NEW.PTR
G.INDEX _ 0; MOVE G.MAX FROM ALL 0 TO G.TAB
GETACT(INIT.RD,U.MODE); CHK.ACT.ERR
LOOP DO
   GETACT(READ.NXT,U.MODE); IF IER = 2 THEN RETURN
   CHK.ACT.ERR; G.FLG _ 0
   DO TYPE OF G.SALES:G.CUST

	G.SALES: G.TMP _ 0; LOOP DO
		WHILE INC G.TMP <= G.INDEX
		WHILE USER(4) # HW(@G.TAB(G.TMP),0)
	   END
	   IF G.TMP > G.INDEX THEN DO
		HW(@G.TAB(INC G.INDEX),0) _ USER(4)
		HW(@G.TAB(G.INDEX),1) _ USER(3)
	   END
	G.CUST: G.TMP _ 0; LOOP DO
		WHILE INC G.TMP <=G.INDEX
		WHILE HW(USER,0) # HW(@G.TAB(G.TMP),0)
	   END
	   IF G.TMP > G.INDEX THEN DO
		HW(@G.TAB(INC G.INDEX),0) _ HW(USER,0)
		HW(@G.TAB(G.INDEX),1) _ USER(4)
		G.TMP _ G.INDEX
	   END
	   G.SITES(G.TMP) _ G.SITES(G.TMP) BOR USER(5)
   END
   CHK.MAX
END
GETACT(CLOSE.ACTG,U.MODE)
RETURN
END FILL.G.TAB


%LUD.SEQ
	!READ NEXT SEQUENTIAL LUD ENTRY
TEMP.INDEX _ 0
LOOP DO
	L.INDEX+_SIZE.LUD.ENT
	IF LUD(0)<0 THEN LUD.OVERFLOW
	WHILE LUD(0) = 0 THEN LUD.READ
	IF LUD(4) # 0 THEN [SET.TEMP; RETURN]
END
END LUD.SEQ



%DUL.SEQ
	!READ NEXT SEQUENTIAL DUL ENTRY
LOCAL J
D.INDEX + _ 3
WHILE DUL(0) = 0 THEN DO
   LOOP DO
	FOR J _ 1 TO SIZE.BLK-1-D.INDEX &
	IF DUL(J)#0 THEN [BADBLK_D.BLKNO; ERROR(GARBAGE); REPEAT 0]
   REPEAT 0
   END
   INC D.BLKNO; DUL.READ
END
RETURN
END DUL.SEQ



%OPEN.AND.LUD.LOOK(ADR)
	!LOOK UP NAME IN ADR, ADR+1 IN LUD
OPEN.LUD
%%LUD.LOOK(ADR)
TEMP.INDEX _ 0
HASH(^ADR,^(ADR+1))
OLDBLK _ LOC.HASH
SETCP(CH.LUD,FIXCP(LOC.HASH)); LUD.READ 
WHILE NAME.HASH # LUD(4) THEN DO	
	L.INDEX+_SIZE.LUD.ENT
	IF LUD(0)=0 THEN RETURN 0
	IF LUD(0)<0 THEN LUD.OVERFLOW
END
SET.TEMP
RETURN 1
END OPEN.AND.LUD.LOOK



%OPEN.AND.DUL.LOOK(PP)
	!LOOK UP PP IN DUL
OPEN.DUL
%%DUL.LOOK(PP)
SETCP(CH.DUL,FIXCP((PP MOD 101)+1)); DUL.READ
WHILE DUL(0) # PP THEN DO
	D.INDEX+_3
	IF DUL(0)=0 THEN RETURN 0
	IF DUL(0)<0 THEN DUL.OVERFLOW
	END
RETURN 1
END OPEN.AND.DUL.LOOK


%CHK.IO.ERR
	!TAKE CARE OF ALL I/O ERRORS FROM IOCS.
CHK.ERR: IF ERRNUM=EOFERR AND IO.ADR # 0 THEN GO ^IO.ADR
 MSG('ERROR ON ');WFID(FIDP);MSG('...');CR
  DO ERRNUM OF TMFERR:CORERR
FNDERR: MSG('BAD FILE MODE OR TYPE')
IFDERR: MSG('ILLEGAL FILE IDENTIFIER')
FNFERR: MSG('FILE NOT FOUNIUSERR: MSG('INVALID USER NAME')
PRTERR: MSG('PROTECTION FAILURE')
EOFERR: MSG('END OF FILE')
 END
MSG('.$ERROR ');NUMOUT(ERRNUM);EXIT
END CHK.IO.ERR


%LUD.OVERFLOW
	!READ LUD OVERFLOW BLOCK
SETCP(CH.LUD,OV.BLK*SIZE.BLK); OLDBLK _ OV.BLK
LUD.READ
RETURN
END LUD.OVERFLOW


%DUL.OVERFLOW
	!READ DUL OVERFLOW BLOCK
SETCP(CH.DUL,HW(DUL(0),1)*SIZE.BLK)
DUL.READ
RETURN
END DUL.OVERFLOW


%INITNONAME
	!INIT PROGRAM
IOCS(2); INITTTY(GETCMD)
CMD _ 0
MSG('$USER VALIDATION PROGRAM - VERSION '); NUMOUT(VERSION)
CR; DATOUT
MOVE 72/CHARS.PER.WORD FROM ALL 0 TO TOKEN
THIS.PPN _ CALL.UUO(-OCT 23 BAND OCT 777777 BOR (-1 SHL 18),OCT 41,1)
 
OPEN.DUL; THIS.GAN _ HW(@THIS.PPN,0)
GOD _ IF HW(@THIS.PPN,1) = OCT 113407 THEN 1 ELSE 0
IF OPEN.AND.DUL.LOOK(THIS.PPN) = 0 THEN &
   [OCTWD.OUT(THIS.PPN); MSG(' NOT IN DUL'); EXIT]
THIS.NAME(0) _ DUL(1); THIS.NAME(1) _ DUL(2)
OPEN.LUD; LUD.SIZE _ N.LUD.BLKS
IF LUD.LOOK(@DUL(1)) = 0 THEN [NAM.OUT; MSG(' NOT IN LUD'); EXIT]
THIS.DIST _ DIST.BITS
THIS.A.S _ ACTSUP.BIT
THIS.TYM _ TYM.BIT
OPER _ BYT(TEMP _ CALL.UUO(-OCT 20,OCT 41,1),1,15)
IF OPER = 0 AND GOD = 1 THEN OPER _ 1
CAN.LOOK _ BYT(TEMP,1,3)	!1 IF RF LICENSE SET
ALTLOC _ ALTTYP; OFFALT
C.SER.FLG _ -1	!-1 MEANS FLAG NOT SET AS YET;0 MEANS NOT C.SET; 1 MEANS C.SER
CH.LUD _ OPEN('(BILLING10)BILDAT.CTL',DIRECT+INPUT+WORD,CHK.ERR,0)
   SETCP(CH.LUD,82); THIS.SYS _ R(CH..LUD); CLOSE(CH.LUD)
PPN _ OCT 1042313	!PPN FOR ACCOUNTING FILES
RETURN
END INITNONAME



%LIST.RECORD(LISTNUM)
	!LIST RECORD POINTED TO BY L.INDEX...LIST ONLY
	!ITEMS THAT CAN BE CHANGED IF USER WANTS TO CHANGE...LIST ONLY
	!SELECTIVE ITEMS IF ALL DIST OR ALL ACCT. REQUESTED
LOCAL FLG, I
IF LISTNUM=ALL.SET THEN [LISTNUM_1; FLG_1] ELSE FLG _ 0
IF OPEN.AND.DUL.LOOK(LUD(0))=0 THEN [CLOSE(CH.DUL);USER.MISSING;RETURN]
CLOSE(CH.DUL)
LOOP DO

   DO LISTNUM OF 1:14

1: IF LITTLE THEN DO
   CR
   IF LISTFLG#CHANGE THEN MSG('1. ')
   MSG('USER NAME: ')
END
NAMOUT

2: IF LISTFLG#CHANGE THEN DO
   IF LITTLE THEN MSG('$2. DISTRICT: ')
   IF BIG AND ((OPER#0 AND LISTFLG=ACCT.LST) OR OPER=0) THEN DO
	DISTOUT; SP
   END ELSE IF LITTLE THEN DISTOUT
END

3: IF LISTFLG#CHANGE THEN DO
   IF LITTLE THEN DO
	MSG('$3. GLOBAL ACCOUNT: '); GAN.OUT
	MSG('$UNIVERSAL USER NO.: '); UUN.OUT
   END ELSE DO
	IF OPER # 0 THEN [IF LISTFLG = DISTLST THEN [GAN.OUT; SP]]
	UUN.OUT; SP
   END
END

4: IF LISTFLG # CHANGE OR OPER # 0 THEN DO
   IF LITTLE THEN MSG('$4. LICENSE: ')
   IF TYM.BIT = 1 THEN OUT('TYM. ') ELSE OUT('     ')
   IF ACTSUP.BIT = 1 THEN OUT('ACT.SUP.') ELSE OUT('        ')
   IF BIG THEN SP
END

5: IF LITTLE THEN DO
   MSG('$5. '); IF SUPMSG.BIT = 0 THEN MSG('DO NOT ')
   MSG('SUPRESS TYMSHARE MESSAGE AT LOGIN.')
END ELSE [IF SUPMSG.BIT=0 THEN OUT('TYP') ELSE OUT('SUP'); SP]


6: IF LITTLE THEN MSG('$6. ')
   IF INIT.BIT = 1 THEN DO
	IF LITTLE THEN MSG('INIT FILE: ')
	IF LUD(6+BUD.INDEX)#0 OR LUD(7+BUD.INDEX)#0 THEN [CHR.OUT($();&
	   SIXOUT(@LUD(6+BUD.INDEX),12); CHR.OUT($))]
	 SIXOUT(@LUD(5+BUD.INDEX),6)
   END ELSE IF LITTLE THEN MSG('NO INIT FILE.')
   IF BIG THEN [CR; NAMOUT; TYPSPACE(5)]

7: IF LISTFLG # CHANGE THEN DO
   IF LITTLE THEN DO
	MSG('$7. ')
	IF ZONE.BIT#0 THEN [MSG(ZONES(ZONE.BIT)); MSG(' TIME ZONE.')]&
		ELSE MSG('TIME ZONE NOT SET.')
END ELSE DO
		IF ZONES(ZONE.BIT)=-1  OR ZONE.BIT=0 THEN [OUT('NOT SET'); TYPSPACE(4);&
		 GO STRTAGN]
		TEMP_CHPT(ZONES(ZONE.BIT),-1)
		SHORT.OUT(TEMP,5)
	END
	IF BIG THEN DASH
	IF DAYLIG.BIT = 1 THEN DO
		IF LITTLE THEN MSG('$SUBJECT TO DAYLIGHT SAVINGS.')
		IF BIG THEN CHR.OUT($D)
	END ELSE IF BIG THEN CHR.OUT($S)
	IF BIG THEN TYPSPACE(4)
   END

8: IF LITTLE THEN DO
   MSG('$8. ')
   IF DETACH.BIT = 1 THEN MSG('DETACH') ELSE MSG('LOGOUT')
   MSG(' ON DISCONNECT.')
   IF TIM.OUT.BIT = 1 THEN MSG(' - TIME OUT SET')
END ELSE DO
   IF DETACH.BIT = 1 THEN OUT('DET') ELSE OUT('LOG')
   IF TIM.OUT.BIT = 1 THEN OUT('-T  ') ELSE TYPSPACE(4)
END

9: IF LITTLE THEN [MSG('$9. MODE: '); MSG(MODES(MODE.BIT+1))] ELSE &
   [TEMP_CHPT(MODES(MODE.BIT+1),-1); SHORT.OUT(TEMP,6); SP]

10: IF LISTFLG # CHANGE OR OPER # 0 THEN DO
   IF LITTLE THEN MSG('$10. QUOTA IN: '); SPOUT(LUD.TEMP(6),6)
   NUMOUT(LUD.TEMP(6)); SP
   IF LITTLE THEN MSG('$QUOTA OUT: '); SPOUT(LUD.TEMP(7),6)
   NUMOUT(LUD.TEMP(7))
END
IF BIG THEN SP

11: IF LISTFLG # CHANGE OR OPER#0 THEN DO
   IF LITTLE THEN MSG('$11. AMOUNT OF CORE: ')
   IF TEMP _ CORE1.LUD = 0 THEN DO
	IF LITTLE THEN MSG('SYSTEM DEFAULT') ELSE OUT('DEF')
   END ELSE DO
	TEMP _ (TEMP+1) * 2
	IF BIG THEN SPOUT(TEMP,3)
	NUMOUT(TEMP)
   END
END

12: IF LITTLE THEN MSG('$12. ')
   IF GFD.BIT = 0 THEN DO
	IF LITTLE THEN MSG('NO ') ELSE OUT(' NO')
   END ELSE IF BIG THEN OUT(' ACC')
   IF LITTLE THEN MSG('GFD ACCESS')

13: IF LITTLE AND LISTFLG # CHANGE THEN DO
   MSG('$13. RUB: '); IF RUB.BIT # 1 THEN MSG('NOT '); MSG('SET')
   END

14: IF TYM.BIT AND LITTLE AND LISTFLG # CHANGE THEN DO
   MSG('$14. BUDGET: ')
   IF TRU.BIT = 0 THEN MSG('NOT SET') ELSE NUMOUT(LUD(5))
   END

END
STRTAGN: IF FLG = 0 OR INC LISTNUM = 14 THEN [CR; RETURN]
END
END LIST.RECORD



%CHANGEIT(WHICHONE)
	!CHANGE ITEM "WHICHONE" IN LUD
LOCAL TMP1, SAVNAM(2)
IF WHICHONE < CH.LIC OR WHICHONE > CH.GFD THEN RETURN 0
	DO WHICHONE OF CH.LIC:CH.GFD

CH.LIC: IF OPER = 0 THEN RETURN 0
   ACTSUP.BIT _ QUERY('ACCOUNT SUPERVISOR'); TYM.BIT _ QUERY('TYMSHARE')

CH.MSG: SUPMSG.BIT _ QUERY('SUPRESS TYMSHARE MESSAGE AT LOGIN')

CH.INIT: IF QUERY('DO YOU WANT TO SET AN INIT FILE') = 1 THEN DO
   IF INIT.BIT # 1 THEN [INIT.BIT _ 1; MAKE.ROOM; MOVE.DOWN; SIZE.INC]
   MOVE 2 FROM USER.NAME TO SAVNAM
   GETNAME(MSG('USER FILE BELONGS TO: '))
   MOVE 2 FROM USER TO @LUD(TRU.BIT+6)
   MOVE 2 FROM SAVNAM TO USER; MSG('FILE NAME: ')
   GETTOKEN(0); MAKE.SIXBIT(TOKEN,@LUD(BUD.INDEX+5),6)
END ELSE DO
   IF INIT.BIT=1 THEN DO
	INIT.BIT _ 0; SIZE.DEC
	MOVE (SIZE.BLK-(L.INDEX+SIZE.LUD.ENT)) FROM &
	   @LUD(BUD.INDEX+8) TO @LUD(BUD.INDEX+5)
	MOVE 3 FROM ALL 0 TO L.BLK(126)
   END
END

CH.ZONE:   IF LUD(0) = OPER.PPN THEN NO.ZONE.CHG; LOOP DO
	MSG('ENTER TIME ZONE: '); GETTOKEN(0)
	IF ZONE_CHOOSE(N.ZONES,ZONES)#0 THEN [ZONE.BIT_ZONE;REPEAT 0]&
	ELSE [MSG('$VALID TIME ZONES ARE '); LISTABLE(N.ZONES,ZONES); CR;CR]
END
   DAYLIG.BIT _ QUERY('$SUBJECT TO DAYLIGHT SAVING')

CH.DET: DETACH.BIT _ QUERY('DETACH ON DISCONNECT')
   TIM.OUT.BIT _ QUERY('SET 15 MIN. TIME OUT')

CH.MODE: LOOP DO
   MSG('MODE: '); GETTOKEN(0)
   IF L.MODE _ CHOOSE(N.MODES,MODES)#0 THEN [MODE.BIT_L.MODE-1; RETURN 1]
   MSG('$VALID MODES ARE '); LISTABLE(N.MODES,MODES); CR;CR
END

CH.STR:	IF OPER = 0 THEN RETURN 0
   MSG('QUOTA IN: '); LUD.TEMP(6) _ GETNUM
   MSG('QUOTA OUT: '); LUD.TEMP(7) _ GETNUM

CH.CORE: IF OPER = 0 THEN RETURN 0
   MSG('$ENTER AMOUNT OF CORE: ')
   IF GETNUM > 256 THEN NUMBER _ 256
   TMP1 _ NUMBER/2
   IF TMP1 * 2 # NUMBER THEN DO
	NUMBER+_1
	MSG('$AMOUNT OF CORE MUST BE EVEN.')
   END
   IF NUMBER # 0 THEN NUMBER _ (NUMBER/2)-1
   CORE1.LUD _ NUMBER
   CORE2.LUD _ NUMBER

CH.GFD: GFD.BIT _ QUERY('ALLOW ACCESS TO GFD')
END
RETURN 1
END CHANGEIT



%MAKE.ROOM
	!MAKE ROOM FOR AN ADDITIONAL 3 WORD IN ENTRY...CREATE OVERFLOW
	!BLOCK IF NECESSARY
LOCAL TMP,I,SAVENT(20)
TMP _ SIZE.LUD.ENT
MOVE TMP FROM @LUD(0) TO SAVENT
MOVE SIZE.BLK-L.INDEX-TMP FROM @LUD(TMP) TO @LUD(0)
WHILE LUD(0)#0 THEN L.INDEX+_SIZE.LUD.ENT
MOVE TMP FROM SAVENT TO @LUD(0)
IF L.INDEX+SIZE.LUD.ENT+3<SIZE.BLK THEN RETURN
HW(@LUD(0),0) _ -1; OV.BLK _ LUD.SIZE+ _ 1
STATUS _ OLD.OUT; LUD.WRIT; SETCP(CH.LUD,(LUD.SIZE+1)*SIZE.BLK)
L.INDEX _ 0
MOVE SIZE.BLK FROM ALL 0 TO LBLK
MOVE TMP FROM SAVENT TO @LUD(0)
RETURN
END MAKE.ROOM


%HEADING
OUT.WHERE
DATOUT
IF OPER # 0 THEN DO
   IF LISTFLG = ACCT.LST THEN [OUT('$GLOBAL ACCOUNT: ');&
	OCTOUT(NUMBER)]
   IF LISTFLG = DIST.LST THEN [OUT('$DISTRICT: ');NUMOUT(NUMBER)]
END ELSE [OUT('$GLOBAL ACCOUNT: '); OCTOUT(THIS.GAN)]
OUT('$$USER         ')
IF OPER = 0 OR LISTFLG=ACCT.LST THEN OUT('DIST ')
IF OPER # 0 AND LISTFLG=DIST.LST THEN OUT('GAN    ')
OUT('UUN      LICENSE     MSG INIT FILE$')
OUT('                   ZONE     DISC    MODE    Q-IN   Q-OUT  CORE GFD$$')
RETURN
END HEADING


%KNOW.ACCT
	!SEE IF USER KNOWS ACCT. NO...OR ASK HIM NAME
IF QUERY('$DO YOU KNOW THE GLOBAL ACCOUNT NUMBER') = 1 THEN RETURN 1
MSG('$ENTER A USERS NAME FROM THE ACCOUNT: '); GETTOKEN(2)
MAKE.SIXBIT(TOKEN,USER,12)
IF OPEN.AND.LUD.LOOK(USER.NAME) = 0 THEN NOT.VALID ELSE NUMBER _ L.GAN
RETURN 0
END KNOW.ACCT


%CHECK.CHG(NUMBER)
	!ASK IF USER IS SURE HE WANTS TO MAKE CHANGE
	!1=YES, 0=NO
LIST.RECORD(NUMBER)
TEMP _ QUERY('$OKAY'); RETURN TEMP
END CHECK.CHG


%OPEN.LUD
	!LOOK FOR LUD.SYS ON DSK
IF CMD # CMD.CHANGE THEN &
  CH.LUD_OPEN('(SYS)LUD.SYS',DIRECT+INPUT+WORD,LUD.ERR)&
   	ELSE CH.LUD_OPEN('(SYS)LUD.SYS',DIRECT+UPDATE+WORD,LUD.ERR)
RETURN
LUD.ERR: IF SEQ.FLG # 0 THEN GO GETCMD ELSE CHK.IO.ERR
END OPEN.LUD


%LIST.ALL.LISTS
IF THIS.GAN = ACCT.GAN OR GOD = 1 THEN &
   [MSG(A.LST.CMDS(N.A.LST.CMDS)); COMMA]
IF OPER = 1 THEN DO
   FOR TEMP _ 4 TO N.O.LST.CMDS DO
	IF O.LST.CMDS(TEMP) # -1 THEN [MSG(O.LST.CMDS(TEMP)); COMMA]
   END
   CR
END
LISTABLE(N.U.LST.CMDS,U.LST.CMDS)
COLON; GETTOKEN(0)
RETURN
END LIST.ALL.LISTS



%CHK.LUD.OR.ACCTG
IF OPER # 0 AND THIS.SYS = 32 THEN DO
   CHECK.NO.MORE.IN([LISTABLE(2,TYPE.CMD); COLON])
   GETTOKEN(0)
   WHILE TYPE _ CHOOSE(2,TYPE.CMD) = 0 THEN DO
	CR; LISTABLE(2,TYPE.CMD); COLON
	GETTOKEN(0)
   END
END ELSE TYPE _ 1
RETURN
END CHK.LUD.OR.ACCTG


%LOOK.NAME
		!SEARCH FOR NAME IN ACCTG FILE
GETACT(INIT.RD,U.MODE); CHK.ACT.ERR
LOOP DO
   GETACT(READ.NXT,U.MODE)
   IF NAME.MATCH THEN [LIST.A.RECORD; GO GETCMD]
   IF IER = 2 THEN NOT.VALID
   CHK.ACT.ERR
END
END LOOK.NAME



%LIST.A.RECORD
LOCAL VALIDF, FLG
VALIDF _ 0

DO LISTFLG OF USER.LST:CUST.LST

USER.LST: OUT('$USER NAME: '); ACT.NAME.OUT
   OUT('$PPN: '); OCTWD.OUT(USER(0))
   OUT('$PRICING CODE: '); OCTOUT(USER(1))
   OUT('$TRACKING CODE: '); OCTOUT(USER(2))
   OUT('$SALESMAN: '); NUMOUT(USER(3))
   OUT('$CUSTOMER: '); NUMOUT(USER(4))	!LOOK UP NAME
   GETACT(INIT.RD,C.MODE); CHK.ACT.ERR
   CUST(0) _ USER(4)
   GETACT(READ.SP,C.MODE); CHK.ACT.ERR
   OUT(' - '); C.NAME.OUT
   FOR TEMP _ ALL.SITES DO
	IF FLG _ ACTSIT(TEMP) = VALID THEN DO
	   OUT('$SITE: '); NUMOUT(TEMP)
	   INC VALIDF
	END
	IF FLG = 3 THEN DO
	   OUT('$SITE: '); NUMOUT(TEMP)
	   OUT(' - INVALID'); INC VALIDF
	END
   END
   IF VALIDF = 0 THEN OUT('$NOT VALID ON ANY SYSTEM.')
   IF BYT(USER(7),1,1) = 1 THEN OUT('$TYMSHARE')
   IF BYT(USER(7),1,0) = 1 THEN OUT('$ACCOUNT SUPERVISOR')

CUST.LST: OUT('$$CUSTOMER: '); NUMOUT(CUST(0)); SP; C.NAME.OUT
   OUT('$BILLING DISTRICT: '); NUMOUT(CUST(1))
   CR; IF CUST(81) = 1 THEN OUT('NON-')
   OUT('STANDARD INVOICE.')
   OUT('$BILLING REGION: '); NUMOUT(CUST(78))
   IF CUST(75) = 1 THEN OUT('$MINIMUM CUSTOMER.')
   IF CUST(77) = 1 THEN OUT('$NON-TIMESHARING CUSTOMER.')
   ADRESS.OUT(0)
   IF CUST(45) # 0 THEN ADRESS.OUT(30)
END
CR; RETURN
END LIST.A.RECORD

%ADRESS.OUT(INDEX)
	!OUTPUT ADDRESS IN 5 LINES OF 30 CHARACTERS
CR; TEMP _ 0
REPEAT 5 DO
   IF BYT(CUST(15+TEMP+INDEX),6,30) = 0 THEN RETURN
   SIXOUT(CUST+15+TEMP+INDEX,30); TEMP + _ 5; CR
END
RETURN
END ADRESS.OUT




%CHK.ACT.ERR
	!CHECK ACCTG. ERRORS
IF IER = 0 THEN RETURN
OPEN.TEL
MSG('$ERROR ON ')
IF MODE < 0 THEN MSG('USERNA.MES') ELSE MSG('CUSTOM.ERS')
CR; DO IER OF 1:4
1: MSG('ENTRY NOT FOUND')
2: MSG('END OF FILE FOUND')
3: MSG('ERROR ON FILE')
4: MSG('MISC. ERROR')
END 
EXIT
END CHK.ACT.ERR


%GANS.OUT
G.FLG _ 0; GAN _ HW(USER,0)
FOR G.TMP _ 1 TO G.INDEX DO
   IF GAN = G.TAB(G.TMP) THEN INC G.FLG
END
IF G.FLG = 0 THEN DO
   OCTOUT(GAN); CR; INC TEMP
   G.TAB(INC G.INDEX) _ GAN
   IF G.INDEX = 500 THEN [MSG('$OVER 500 GANS!$'); EXIT]
END 
RETURN
END GANS.OUT


%CALL.UUO(AC,ADDR,SKPFLG)
LOCAL DIDIT:
^OCT 12 _AC
EXU(OCT 47, OCT 12, ADDR, DIDIT)
IF SKPFLG = 1 THEN [MSG('$UUO FAILED.'); EXIT]
DIDIT: RETURN ^OCT 12
END CALL.UUO



%CUS.CHK
	!READ THRU CUSTOM.ERS - IF A CUST IS FOUND IN USERNA.MES, OK
	!IF NOT, ERROR
LOCAL CHAR
GETACT(INIT.RD,0); CHK.ACT.ERR
WRITE.OUT('$$CUSTOM.ERS - USERNA.MES CHECK$$')
FILL.G.TAB(G.SALES)
LOOP DO
   GETACT(READ.NXT,0); WHILE IER # 2; CHK.ACT.ERR	!GET NEXT CUSTOMER
   P _ CHPT(@CUST(3),-1)
   LOOP DO
	REPEAT 71*CHARS.PER.WORD DO
	   CHAR _ NCHV P
	   IF NOT(LEGAL.CH(CHAR)) THEN [ERROR(TEXT.BAD); REPEAT 0]
	END
	REPEAT 0
   END
   IF SERCHCUS = 0 THEN ERROR(NOUSER.BAD)
END
GETACT(CLOSE.ACTG,0); RETURN
END CUSCHK


%USRCHK
	!READ THRU USERNA.MES
	!CHECK TO SEE IF CUSTOMER EXISTS IN CUSTOMER
GETACT(INIT.RD,U.MODE); CHK.ACT.ERR
GETACT(INIT.RD,C.MODE); CHK.ACT.ERR
WRITE.OUT('$$USERNA.MES - CUSTOM.ERS CHECK$$')
G.INDEX _ 0; MOVE G.MAX FROM ALL 0 TO G.TAB
LOOP DO
   GETACT(READ.NXT,C.MODE); WHILE IER # 2
   CHK.ACT.ERR; G.TMP _ 0
   LOOP DO
	WHILE INC G.TMP <= G.INDEX
	WHILE CUST(0) # G.TAB(G.TMP)
   END
   IF G.TMP > G.INDEX THEN G.TAB(INC G.INDEX) _ CUST(0)
   CHK.MAX
END
GETACT(CLOSE.ACTG,C.MODE)
LOOP DO
   GETACT(READ.NXT,U.MODE); WHILE IER # 2
    CHK.ACT.ERR	!GET NEXT USER
   CUST(0) _ USER(4) !SAVE CUSTOMER NO.
   IF CUS.LOOK = 0 THEN ERROR(NOCUST.BAD)
END
GETACT(CLOSE.ACTG,U.MODE); CHK.ACT.ERR; RETURN
END USRCHK


%LUDCHK
	!READ THRU LUD, LOOKING UP AND CHECKING EACH ENTRY IN DUL
	!AND ACCOUNTING
LOCAL %CK.LUD.SEQ, %L.FIRST
LOCAL ENDLUD:, DULFLG, LP1:
IO.ADR _ ENDLUD
WRITE.OUT('$$LUD - DUL - USERNA.MES CHECK$$')
GETACT(INIT.RD,U.MODE); CHK.ACT.ERR
SETCP(CH.LUD,0); L.BLKNO _ 1; LUD.READ; L.FIRST; GO LP1
LOOP DO
   LP1:WHILE LUD(4) = 0 THEN CK.LUD.SEQ
   IF DULFLG _ DUL.LOOK(LUD(0)) = 1 THEN DO
	HASH(DUL(1),DUL(2))
	IF NAME.HASH # LUD(4) THEN ERROR(HASH.BAD)
	IF LOC.HASH # L.BLKNO THEN ERROR(BLKNO.BAD)
   END ELSE ERROR(NODUL.BAD)
   USER(0) _ LUD(0)
   IF ACT.LOOK = 1 AND ACT.SIT(THIS.SYS) = 2 THEN DO
	IF DULFLG = 1 THEN DO
	   IF DUL(1)#USER(8) OR DUL(2)#USER(9) THEN ERROR(NAME.BAD)
	END
   END ELSE ERROR(NOACT.BAD)
   CK.LUD.SEQ
END
ENDLUD: GETACT(CLOSE.ACTG,-1); RETURN

%CK.LUD.SEQ
LOCAL J
L.INDEX + _ SIZE.LUD.ENT
%%L.FIRST
WHILE LUD(0) = 0 THEN DO
   LOOP DO
   FOR J_1 TO SIZE.BLK-1-L.INDEX IF LUD(J)#0 THEN &
	[BADBLK_L.BLKNO; ERROR(GARBAGE); REPEAT 0]
   REPEAT 0
   END
   INC L.BLKNO; LUD.READ
END
RETURN
END CK.LUD.SEQ
END LUDCHK



%DULCHK
	!READ THRU DUL, LOOKING UP ENTRY IN LUD
LOCAL ENDDUL:
IO.ADR _ ENDDUL
WRITE.OUT('$$DUL - LUD CHECK$$')
DUL.READ; D.INDEX _ -3
LOOP DO
   DUL.SEQ
   IF LUD.LOOK(@DUL(1)) # 0 THEN DO
	IF LUD(0) # DUL(0) THEN ERROR(BAD.PPNS)
   END ELSE ERROR(NOLUD.BAD)
END
ENDDUL: RETURN
END DULCHK



%USRLDL
GETACT(INIT.RD,U.MODE); CHK.ACT.ERR
WRITE.OUT('$$USERNA.MES - LUD CHECK$$')
LOOP DO
   GETACT(READ.NXT,U.MODE); WHILE IER # 2; CHK.ACT.ERR
   IF ACT.SIT(THIS.SYS) = VALID THEN DO
	IF LUD.LOOK(USER+8) # 0 THEN DO
	     IF BYT(LUD(1),8,0) # USER(3)/100 THEN ERROR(DIST.BAD)
	END ELSE ERROR(NOLUDA.BAD)
   END
END
GETACT(CLOSE.ACTG,U.MODE); RETURN
END USRLDL



%ACT.LOOK
	!LOOK UP USER IN USERNA.MES
GETACT(READ.SP,U.MODE); IF IER = 0 THEN RETURN 1
IF IER = 1 THEN RETURN 0 ELSE CHK.ACT.ERR
END ACT.LOOK


%CUS.LOOK
LOCAL I
FOR I _ 0 TO G.INDEX IF CUST(0) = G.TAB(I) THEN RETURN 1
RETURN 0
END CUS.LOOK



%SERCH.CUS
LOCAL I
FOR I _ 1 TO G.INDEX IF CUST(0) = HW(@G.TAB(I),0) THEN RETURN HW(@G.TAB(I),1)
RETURN 0
END SERCHCUS



%ERROR(ERR)
	!TYPE OUT DATA ERRORS TO USER
DO ERR OF NODUL.BAD:OVER.BAD
   NODUL.BAD: OUT('NO DUL ENTRY FOR ');  PPN.OUT
   NOACT.BAD: OUT('NO ACCTG. ENTRY FOR '); PPN.OUT; DOTS; NAM.OUT
   HASH.BAD: OUT('HASH OF '); PPN.OUT; EQUALS
	OCTWD.OUT(NAME.HASH); CR; OUT('ENTRY IN LUD = ')
	OCTWD.OUT(LUD(4))
   BLKNO.BAD: OUT('HASH BLK. NO. OF '); PPN.OUT; EQUALS
	OCTOUT(LOC.HASH); CR; OUT('ENTRY IS IN BLK. NO. ')
	NUMOUT(L.BLKNO); DOTS; NAM.OUT
   NAME.BAD: PPN.OUT; DOTS; OUT('NAME IN DUL: '); NAM.OUT
	OUT('NAME IN ACCTG: '); ACT.NAME.OUT
   DIST.BAD: OUT('LUD DISTRICT = '); NUMOUT(DIST.BITS); DOTS
	OUT('ACCT. DISTRICT = '); NUMOUT(USER(3)/100)
	DOTS; PPN.OUT; DOTS; ACT.NAME.OUT
   NOLUD.BAD: OUT('NO LUD ENTRY FOR '); OCTWD.OUT(DUL(0)); DOTS
	NAM.OUT
   NOLUDA.BAD: OUT('NO LUD ENTRY FOR '); OCTWD.OUT(USER(0)); DOTS
	ACT.NAME.OUT
   NOUSER.BAD: OUT('CUSTOMER NUMBER '); NUMOUT(CUST(0))
	OUT(' HAS NO ENTRY IN USERNA.MES.')
   GARBAGE: OUT('GARBAGE IN BLOCK '); NUMOUT(BADBLK)
   TEXT.BAD: OUT('BAD TEXT FOR CUSTOMER '); NUMOUT(CUST(0))
   NOCUST.BAD: OUT('CUSTOMER NUMBER '); NUMOUT(CUST(0))
	OUT(' NOT FOUND')
   OVER.BAD: OUT('OVERFLOW POINT IN '); OUT(BADFIL); OUT(' IS IN WORD ')
	NUMOUT(BADBLK); OUT(' BLOCK '); NUMOUT(L.BLKNO)
	CR; CLOSE.ALL; EXIT
END
CR
RETURN
END ERROR

END NONAME
  M^X