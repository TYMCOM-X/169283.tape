BASE 0

!PROCEDURES
FIND %GETDUM,%HASH,%OCTOUT,%SIXOUT,%NUMOUT, %OUT
FIND %CHR.OUT
FIND %INITTTY,%DATOUT
LOCAL  %L.FIRST,%ACT.LOOK,%CHKACT,%CHK.ACT.ERR,%CHK.IO.ERR,%CUS.LOOK
LOCAL %USRLDL, %DUL.LOOK,%DUL.SEQ,%DULCHK,%DUL.OVERFLOW,%CUSCHK
LOCAL %LOKUP.DUL, %LOKUP.LUD
LOCAL %ERROR
LOCAL %LUD.LOOK,%LUD.SEQ,%LUDCHK,%LUD.OVERFLOW
LOCAL %SERCHCUS,%USRCHK

DEF SIZE.BLK AS 128
!ID'S
GLOBAL USER(20),CUST(150),PPN,IER,ICODE,MODE,NAME.HASH,LOC.HASH
GLOBAL CH.OUT,P,NUMBER
LOCAL CH.LUD,CH.DUL,ACT.ADR,IO.ADR
LOCAL D.INDEX,D.BLKNO,D.BLK(SIZE.BLK),DULFLG
LOCAL L.INDEX,L.BLKNO,L.BLK(SIZE.BLK)
LOCAL SAVCP,SITE
LOCAL BADBLK,BADFIL


!MACRO'S
DEF ACTGSIT AS 32
DEF ACT.SIT AS BYT(USER(5),2,BITS.PER.WORD-2*(SITE-30)) !COMPUTE ACCTG. SITE
DEF CALL.GETACT(A,B) AS [ICODE_A; MODE_B; GETDUM]
DEF CR AS CHR.OUT(CARRET)
DEF DOTS AS OUT('...')
DEF FIXCP(A) AS (A-1)*SIZE.BLK	!COMPUTE CURSOR POS. FROM BLK. NO.
DEF LEGAL(A) AS (OCT 37 < A < OCT 133) OR A=0
DEF LUD.READ AS [RB(CH.LUD,SIZE.BLK,L.BLK); L.INDEX_0]
DEF DUL(A) AS D.BLK(D.INDEX+A)
DEF LUD(A) AS L.BLK(L.INDEX+A)
DEF DUL.READ AS [RB(CH.DUL,SIZE.BLK,D.BLK); D.INDEX_0]
DEF OCTWD.OUT(A) AS [OCTOUT(HW(@A,0)); CHR.OUT($,); OCTOUT(HW(@A,1))]
DEF OPEN.TEL AS CH.OUT _ OPEN('TEL',SEQUEN+OUTPUT+CHARACTER,0,2)
DEF OTITLE AS [OUT('$PDP-10 CONSISTENCY CHECK - VERSION '); &
   NUMOUT(VERSION); OUT(' - SITE '); NUMOUT(SITE); CR; DATOUT]
DEF PPN.OUT AS OCTWD.OUT(LUD(0))
DEF SIZE.LUD.ENT AS BYT(LUD(2),7,0)
DEF VERSION AS 10
DEF WRITE.OUT(A) AS [MSG(A); OUT(A)]

!ERROR MESSAGES FOR READ DATA ERRORS
DEF NODUL.BAD AS 1
DEF NOACT.BAD AS 2
DEF HASH.BAD AS 3
DEF BLKNO.BAD AS 4
DEF NAME.BAD AS 5
DEF DIST.BAD AS 6
DEF NOLUDA.BAD AS 7
DEF NOLUD.BAD AS 10
DEF NOUSER.BAD AS 12
DEF GARBAGE AS 13
DEF TEXT.BAD AS 14
DEF NOCUST.BAD AS 15
DEF OVER.BAD AS 20

!LABELS
LOCAL CHK.ERR:

%CHKACT
	!MAIN LINE TO LOOK UP LUD, DUL FOR EACH SITE AND CHECK THEM
	!AGAINST EACH OTHER AND ACCOUNTING

START: IOCS(2); INITTTY
\\->START
CH.LUD _ OPEN('(BILLING10)BILDAT.CTL',DIRECT+INPUT+WORD,CHK.ERR,0)
	SETCP(CH.LUD,82); SITE _ R(CH.LUD); CLOSE(CH.LUD)

OPEN.TEL; OTITLE
CH.OUT _ OPEN('ERROUT',SEQUEN+OUTPUT+CHARACTER,0,2); OTITLE


PPN _ OCT 1042313
IF SITE = ACTGSIT THEN DO
CUSCHK
USRCHK
END

LOKUP.LUD; LOKUP.DUL
LUDCHK; DULCHK; USRLDL
	CLOSE.ALL
	EXIT

%LUDCHK
	!READ THROUGH LUD, LOOKING UP AND CHECKING EACH ENTRY IN DUL
	!AND ACCOUNTING
LOCAL ENDLUD:
IO.ADR _ ENDLUD
WRITE.OUT('$$LUD - DUL - USERNA.MES CHECK$$')
CALL.GETACT(1,-1); CHK.ACT.ERR
SETCP(CH.LUD,0); L.BLKNO _ 1; LUD.READ; L.INDEX _ 0
L.FIRST; GO LP1
LOOP DO
	LUD.SEQ
	LP1: WHILE LUD(4)=0 THEN LUD.SEQ
	IF DULFLG _ DUL.LOOK(LUD(0))=1 THEN DO
		HASH(DUL(1),DUL(2))
		IF NAME.HASH#LUD(4) THEN ERROR(HASH.BAD)
		IF LOC.HASH#L.BLKNO THEN ERROR(BLKNO.BAD)
		END ELSE ERROR(NODUL.BAD)
		USER(0)_LUD(0)
		IF(ACT.LOOK=1 AND ACT.SIT = 2) THEN DO
	IF DULFLG=1 THEN [IF (DUL(1)#USER(8) OR DUL(2)#USER(9)) THEN &
		    	ERROR(NAME.BAD)]
		    END ELSE ERROR(NOACT.BAD)
END
ENDLUD: CALL.GETACT(6,-1);  RETURN
END LUDCHK


%DULCHK
	!READ THROUH DUL, LOOKING UP ENTRY IN LUD
LOCAL ENDDUL:
IO.ADR _ ENDDUL
WRITE.OUT('$$DUL - LUD CHECK$$')
DUL.READ; D.INDEX _ -3
LOOP DO
	DUL.SEQ
	IF LUD.LOOK(@DUL(1))=0 THEN DO
		USER(0) _ DUL(0)
	END
END
ENDDUL: RETURN
END DULCHK


%USRCHK
	!READ THROUGH USERNA.MES,
	!CHECKING TO SEE IF CUSTOMER EXISTS IN CUSTOM.ERS
LOCAL ENDACT:
CALL.GETACT(1,-1); CHK.ACT.ERR
CALL.GETACT(1,0); CHK.ACT.ERR
ACT.ADR_ENDACT
WRITE.OUT('$$USERNA.MES - CUSTOM.ERS CHECK$$')
LOOP DO 
	CALL.GETACT(4,-1); CHK.ACT.ERR	!GET NEXT USER
	CUST(0)_USER(4)	!SAVE CUSTOMER NUMBER
	IF CUS.LOOK=0 THEN ERROR(NOCUST.BAD)
END
ENDACT: CALL.GETACT(6,-1); CALL.GETACT(6,0); RETURN
END USRCHK



%CUSCHK
	!READ THRU CUSTOM.ERS - IF A CUST IS FOUND IN USERNA.MES,OK
	!IF NOT, ERROR
LOCAL ENDCUS:,CHAR
ACT.ADR_ENDCUS
CALL.GETACT(1,0); CHK.ACT.ERR
WRITE.OUT('$$CUSTOM.ERS - USERNA.MES CHECK$$')
LOOP DO
	CALL.GETACT(4,0); CHK.ACT.ERR !GET NEXT CUSTOMER
	P _ CHPT(@CUST(3),-1)
	LOOP DO
	REPEAT 71*CHARS.PER.WORD DO
		CHAR _ NCHV P
		IF NOT(LEGAL(CHAR)) THEN [ERROR(TEXT.BAD); REPEAT 0]
	END
	REPEAT 0
	END
	IF SERCHCUS = 0 THEN ERROR(NOUSER.BAD)
END
ENDCUS: CALL.GETACT(6,0); RETURN
END CUSCHK



%USRLDL
LOCAL ENDACT:
ACT.ADR _ ENDACT
CALL.GETACT(1,-1); CHK.ACT.ERR
WRITE.OUT('$$USERNA.MES - LUD CHECK$$')
LOOP DO
   CALL.GETACT(4,-1); CHK.ACT.ERR
   IF ACT.SIT = 2 THEN DO
	IF LUD.LOOK(USER+8) # 0 THEN DO
	   IF BYT(LUD(1),8,0) # USER(3)/100 THEN ERROR(DIST.BAD)
	END ELSE ERROR(NOLUDA.BAD)
   END
END
ENDACT: CALL.GETACT(6,-1); RETURN
END USRLDL

%LUD.SEQ
	!READ NEXT SEQUENTIAL LUD ENTRY
LOCAL J
L.INDEX+_SIZE.LUD.ENT
 IF LUD(0)<0 THEN LUD.OVERFLOW
%%L.FIRST
WHILE LUD(0)=0 THEN DO
	LOOP DO
	FOR J_1 TO SIZE.BLK-1-L.INDEX IF LUD(J)#0 THEN [BADBLK_L.BLKNO;&
				ERROR(GARBAGE); REPEAT 0]
	REPEAT 0
	END
	INC L.BLKNO; LUD.READ
END
RETURN
END LUD.SEQ


%DUL.SEQ
	!READ NEXT SEQUENTIAL DUL ENTRY
LOCAL J
D.INDEX+_3
IF DUL(0)<0 THEN DUL.OVERFLOW
WHILE DUL(0)=0 THEN DO
	LOOP DO
	FOR J_1 TO SIZE.BLK-1-D.INDEX IF DUL(J)#0 THEN [BADBLK_D.BLKNO;&
				ERROR(GARBAGE); REPEAT 0]
	REPEAT 0
	END
	INC D.BLKNO; DUL.READ
END
RETURN
END DUL.SEQ


%LUD.LOOK(ADR)
	!LOOK UP NAME IN ADR,ADR+1 IN LUD
	!FIND PPN IN MATCH
HASH(^ADR,^(ADR+1))
L.BLKNO _ LOC.HASH
SETCP(CH.LUD,FIXCP(LOC.HASH)); LUD.READ 
WHILE NAME.HASH # LUD(4) THEN DO
	L.INDEX+_SIZE.LUD.ENT
	IF LUD(0)=0 THEN RETURN 0
	IF LUD(0)<0 THEN LUD.OVERFLOW
	END
RETURN 1
END LUD.LOOK


%DUL.LOOK(PP)
	!LOOK UP PPN IN DUL
SETCP(CH.DUL,FIXCP((PP MOD 101)+1)); DUL.READ
WHILE DUL(0) # PP THEN DO
	D.INDEX+_3
	IF DUL(0)=0 THEN RETURN 0
	IF DUL(0)<0 THEN DUL.OVERFLOW
	END
RETURN 1
END DUL.LOOK


%ACT.LOOK
	!LOOK UP USER IN USERNA.MES
CALL.GETACT(3,-1); IF IER = 0 THEN RETURN 1
IF IER = 1 THEN RETURN 0 ELSE CHK.ACT.ERR
END ACT.LOOK


%CUS.LOOK
	!LOOKUP CUSTOMER IN CUSTOM.ERS
CALL.GETACT(3,0); IF IER = 0 THEN RETURN 1
IF IER = 1 THEN RETURN 0 ELSE CHK.ACT.ERR
END CUS.LOOK



%SERCHCUS
	!LOOK FOR CUST(0) IN USERNA.MES
CALL.GETACT(1,-1); CHK.ACT.ERR	!INITIALIZE USERNA.MES
USER(4) _ CUST(0)
LOOP DO
	CALL.GETACT(8,-1); IF IER = 2 THEN RETURN 0
	IF IER # 0 THEN CHK.ACT.ERR
	CALL.GETACT(6,-1); RETURN 1
END
END SERCHCUS


%CHK.ACT.ERR
	!CHECK ACCTG. FILE ERRORS
 IF IER=0 THEN RETURN
IF IER=2 THEN [IF ACT.ADR#0 THEN GO ^ACT.ADR]
OPEN.TEL
 MSG('ERROR ON ')
 IF MODE <0 THEN MSG('USERNA.MES') ELSE MSG('CUSTOM.ERS')
DOTS; CR

 DO IER OF 1:4
1:  MSG('ENTRY NOT FOUND.')
2:  MSG('NO END OF FILE ADR. SET UP.')
3: MSG('ERROR ON FILE.')
4: MSG('FILE BUSY.')
END
  EXIT
END CHK.ACT.ERR


%CHK.IO.ERR
	!TAKE CARE OF ALL I/O ERRORS FROM IOCS
CHK.ERR: IF ERRNUM=EOFERR AND IO.ADR # 0 THEN GO ^IO.ADR
 OPEN.TEL
 MSG('ERROR ON ');WFID(FIDP);DOTS ;CR
  DO ERRNUM OF TMFERR:CORERR
FMDERR: MSG('BAD FILE MODE OR TYPE')
IFDERR: MSG('ILLEGAL FILE IDENTIFIER')
FNFERR: MSG('FILE NOT FOUND')
IUSERR: MSG('INVALID USER NAME')
PRTERR: MSG('PROTECTION FAILURE')
EOFERR: MSG('END OF FILE')
 END
MSG('.$ERROR ');NUMOUT(ERRNUM);EXIT
END CHK.IO.ERR


%LUD.OVERFLOW
	!READ LUD OVERFLOW BLOCK
IF L.INDEX<SIZE.BLK-20 THEN[BADBLK_L.INDEX;BADFIL_'LUD';ERROR(OVER.BAD)]
SAVCP_CP(CH.LUD)
SETCP(CH.LUD,HW(LUD(0),1)*SIZE.BLK)
LUD.READ
SETCP(CH.LUD,SAVCP)
RETURN
END LUD.OVERFLOW


%DUL.OVERFLOW
	!READ DUL OVERFLOW BLOCK
IF D.INDEX<SIZE.BLK-6 THEN [BADBLK_D.INDEX;BADFIL_'DUL';ERROR(OVER.BAD)]
SAVCP_CP(CH.DUL)
SETCP(CH.DUL,HW(DUL(0),1)*SIZE.BLK)
DUL.READ
SETCP(CH.DUL,SAVCP)
RETURN
END DUL.OVERFLOW


%ERROR(ERR)
	!TYPE OUT DATA ERRORS TO USER
DO ERR OF NODUL.BAD:OVER.BAD
NODUL.BAD: OUT('NO DUL ENTRY FOR ');PPN.OUT
NOACT.BAD: OUT('NO ACCTG. ENTRY FOR ');PPN.OUT;DOTS ;SIXOUT(@DUL(1),12)
HASH.BAD: OUT('HASH OF ');PPN.OUT;CHR.OUT($=);OCTWD.OUT(NAME.HASH);CR
	OUT('ENTRY IN LUD = ');OCTWD.OUT(LUD(4))
BLKNO.BAD: OUT('HASH BLK. NO. OF ');PPN.OUT;CHR.OUT($=);OCTOUT(LOC.HASH)
	CR;OUT('ENTRY IS IN BLK. NO. ');OCTOUT(L.BLKNO);DOTS;SIXOUT(@DUL(1),12)
NAME.BAD: PPN.OUT;DOTS ; OUT('NAME IN DUL: ');SIXOUT(@DUL(1),12)
	OUT('NAME IN ACCTG.: ');SIXOUT(@USER(8),12)
DIST.BAD: OUT('LUD DISTRICT = ');NUMOUT(BYT(LUD(1),8,0))
	DOTS; OUT('ACCT. DISTRICT = ');NUMOUT(USER(3)/100);DOTS;PPN.OUT;DOTS;SIXOUT(USER+8,12)
NOLUD.BAD: OUT('NO LUD ENTRY FOR ');OCTWD.OUT(DUL(0));DOTS; SIXOUT(@DUL(1),12)
NOLUDA.BAD: OUT('NO LUD ENTRY FOR ');OCTWD.OUT(USER(0));DOTS;SIXOUT(USER+8,12)
NOUSER.BAD: OUT('CUSTOMER NUMBER '); NUMOUT(CUST(0)); OUT(' HAS NO')
	OUT(' ENTRY IN USERNA.MES.')
GARBAGE: OUT('GARBAGE IN BLOCK '); NUMOUT(BADBLK)
TEXT.BAD: OUT('BAD TEXT FOR CUSTOMER '); NUMOUT(CUST(0))
NOCUST.BAD: OUT('CUSTOMER NUMBER ');NUMOUT(CUST(0));OUT(' NOT FOUND')
OVER.BAD: OUT('OVERFLOW POINTER IN '); OUT(BADFIL); OUT(' IS IN WORD ')
	NUMOUT(BADBLK); OUT(' BLOCK '); NUMOUT(L.BLKNO)
	 CR; CLOSE.ALL; EXIT

END
CR;RETURN
END ERROR





%LOKUP.DUL
LOCAL DUL.ERR:
  CH.DUL _ OPEN('(SYS)DUL.SYS',DIRECT+INPUT+WORD,DUL.ERR,0)
RETURN
DUL.ERR: IF ERRNUM # FNFERR THEN CHK.IO.ERR ELSE MSG('DUL NOT FOUND')
	EXIT
END LOKUP.DUL

%LOKUP.LUD
LOCAL LUD.ERR:
  CH.LUD _ OPEN('(SYS)LUD.SYS',DIRECT+INPUT+WORD,LUD.ERR,0)
RETURN
LUD.ERR: IF ERRNUM # FNFERR THEN CHK.IO.ERR ELSE MSG('LUD NOT FOUND')
	EXIT
END LOKUP.LUD

END CHKACT
   