
!**COPYRIGHT 1972,1973, DIGITAL EQUIPMENT CORPORATION, MAYNARD MA**
!AUTHOR: NORMA ABEL

GLOBAL BIND PHA2V=64;	!7/17/73
EXTERNAL SAVE17;		!TO SAVE STACK REGISTER IN CASE OF
				!EMERGENCY EXIT
%(********************************************
	OPTIMIZER OVERLAY
*************************************************)%

EXTERNAL DWP,WALKER,GPHBLD,LOOP,FNREFNO,TOP,BOTTOM,INDVAR,
	LENTRY,LEND,DOPARMS,FGP,RGP,GREGALC,FLOOD,LOOPNO,GLOBELIM,
	DEFDRIV,PROPAGATE,DOCOLLAPSE,RGPHBAS,FGPHBAS,RGRAPH,FGRAPH;


	EXTERNAL POOL,PROGNAME;

	MACHOP POPJ=#263;
MAP BASE LOOP:LENTRY:TOP;
EXTERNAL CSTMNT,P2SKSTMNT,LOCELIM;
MAP BASE CSTMNT;

!ERROR TRANSFER VECTOR FOR OPTIMIZER ERRORS. THE ERROR NUMBERS ARE
!SCATTERED THROUGHOUT ERROUT.BLI, THIS VECTOR PERMITS THE
!OPTIMIZER TO NUMBER THEM SEQUENTIALLY.
BIND ERRVECT = PLIT(
			78,	!INVALID
			63,	!OUT OF GRAPH SPACE
			62,	!ASSIGN TROUBLE
			78,	!WARNINGS IN P1
			79,	!VARIABLES NOT INITIALIZED
			37,	!DISCONNECTED
			100);	!INFINITE LOOP



!NEEDS FILE OPTMAC TO COMPILE NOW
!EXIT FROM PHASE 2
MACRO DEAD=
	BEGIN
		SREG<0,36>_.SAVE17<0,36>;
		POPJ (#17,0);
	END$;

ROUTINE PASSOUT=
BEGIN
	EXTERNAL CSTMNT,BACKST,LOCELIM,MEMCMCHK;
	MAP BASE CSTMNT;
	EXTERNAL CORMAN,LOCELMIO,LOCLNK;

	!THIS ROUTINE CLEANS UP FOR A GRACEFULL EXIT FROM
	!THE OPTIMIZER. IT IS USED IN THE NORMAL EXIT CASE
	!AFTER THE MAIN CODE AND ALSO FOR ERRORS.
	!THE SERVICES PERFORMED ARE:
	!1.	DO LOCAL COMMON SUBS
	!2.	CLEAR TARGET WORDS
	!3.	CATCH COMPUTATIONS TO MEMORY

	ROUTINE OUTPROCESS=
	BEGIN

		!CALL PHASE 2 SKELETON  FOR THOSE STATEMENTS
		!THAT HAVE NOT HAD IT CALLED. CALL LOCELIM
		!FOR ALL STATEMENTS
		EXTERNAL P2SKSTMN;
		IF NOT .CSTMNT[P2SDONE] THEN
			!DO LOCAL OPTS
			P2SKSTMN();
		LOCELIM(.CSTMNT);
		!TURN OFF THE BIT
		CSTMNT[P2SDONE]_0;
		!ALSO CHECK FOR A COMPUATAION TO MEMORY
		MEMCMCHK();
	END;
	!FIND LOCAL COMMON-SUB EXPRESSIONS IN ALL I/O STATEMENTS
	NAME<LEFT>_4;
	BACKST_CORMAN();
	!GO THROUGH ALL STATEMENTS AND AMKE SURE THAT THE
	!TARGET WORD IS ZERO
	!INITIALIZE THE GLOBAL LOCLNK
	LOCLNK_0;

	CSTMNT_.SORCPTR<LEFT>;
	FLGREG<OPTIMIZE>_0;
	WHILE .CSTMNT NEQ 0 DO
	BEGIN
		!ZERO TARGET FIELD
		CSTMNT[TARGADDR]_0;
		OUTPROCESS();
		CSTMNT_.CSTMNT[SRCLINK];
	END;
	FLGREG<OPTIMIZE>_1;
END;

GLOBAL ROUTINE OPTERR(NUMB)=
BEGIN
	!ERROR ROUTINE CALLED BY THE OPTIMIZER.
	!PRINT ERROR MESSAGE, RESTORE STACK TO VALUE IT
	!HAD ON ENTRY TO THIS OVERLAY AND GET OUT******


	EXTERNAL CSTMNT;
	MAP BASE CSTMNT;
	EXTERNAL ENTRY,ISN,WARNOUT;

	ENTRY[0]_.ISN;

	WARNOUT(.ERRVECT[.NUMB]);

	!CLEANUP GRAPG POINTERS LEFT IN STATEMENT NODES,ELSE
	!THE REGISTER ALLOCATOR WILL THINK THEY ARE POINTERS TO
	!LOCAL COMMON SUB-EXPRESSIONS.

	PASSOUT();

	!RESTORE STACK
	SREG<0,36>_.SAVE17<0,36>;

	POPJ (#17,0);
END;

!********************************************



!TWO LOCAL ROUTINES TO KLUDGE A PSEUDO DO-LOOP FOR THE MAIN PROGRAM

	ROUTINE FUDGDO=
	BEGIN
		LOCAL BASE P:T:DL;
	EXTERNAL CORMAN,TOP,LEND,QQ,NAME,GENLAB;
		MAP BASE TOP:QQ;

	!THE MAIN PROGRAM WILL HAVE
	!	1. THE DUMMY CONTINUE IN FRONT AS LENTRY
	!	2. THE FUDGED DO LOOP NEXT AS TOP
	!	3. BOTTOM WILL POINT TO THE END STATEMENT
	!	4. LEND WILL POINT TO THE FUDGED CONTINUE

		NAME_0;
		NAME<LEFT>_DOSIZ+SRCSIZ;
		TOP_
		P_CORMAN();
		!THIS WILL LOOK LIKE A DO LOOP IN THE SIZE
		!FLAGS AND LABEL FIELD. IT WILL HAVE A SRCID
		!OF A CONTINUE TO PREVENT PHASE 2 SKELETON
		!OPTIMIZATIONS ON IT

		P[SRCID]_CONTID;
		P[OPRCLS]_STATEMENT;
		DL_
		P[DOLBL]_GENLAB();
		!SET SNREFNO SO LABEL WILL BE CONSIDERED LOCAL
		DL[SNREFNO]_2;
		T_.SORCPTR<LEFT>;
		!FOR A SUBPROGRAM, MAKE THE ENTRY STATEMENT LENTRY
		!AND PUT TOP RIGHT AFTER IT, ELSE IF WE MOVE
		!ANYTHING TO LENTRY IT WOULD BE INACCESSIBLE CODE.
		!OPTIMIZING A BLOCK DATA PROGRAM IS ILLEGAL
		IF .PROGNAME NEQ SIXBIT'MAIN. ' THEN
		BEGIN
			T_.T[SRCLINK];
			WHILE .T[SRCID] EQL ENTRID DO
			BEGIN
				LENTRY_.T;
				IF .T[SRCLINK] EQL 0 THEN
					(PASSOUT(); DEAD;);
				T_.T[SRCLINK];
			END;
		END;
		P[SRCLINK]_.LENTRY[SRCLINK];
		LENTRY[SRCLINK]_.P;
		!GO THROUGH THE WHOLE THING LOOKING FOR
		!THE STATEMENT BEFORE THE LAST TO LINK INTO
		!THE CONTINUE WE WILL MAKE

		!A HALF SPECIAL CASE
		!SUBROUTINE SUB
		!END
		IF .T[SRCLINK] EQL 0 THEN
			(PASSOUT();DEAD;);

		WHILE .T[SRCLINK] NEQ .SORCPTR<RIGHT> DO
			T_.T[SRCLINK];
		!NOW MAKE THE CONTINUE TO GO WITH IT
		NAME<LEFT>_SRCSIZ;
		QQ_CORMAN();
		T[SRCLINK]_.QQ;
		QQ[OPRCLS]_STATEMENT;
		QQ[SRCID]_CONTID;
		QQ[SRCLBL]_.DL;
		!USE T AS A TEMP
		T_.P[DOLBL];
		T[SNHDR]_.QQ;
		BOTTOM_QQ[SRCLINK]_.SORCPTR<RIGHT>;
		!ALSO SET UP LEND
		LEND_.QQ;
	END;

	ROUTINE UNFUDGDO=
	BEGIN
		!UNDO THE DO LOOP FUDGE SO NO ATTEMPT WILL BE MADE TO
		!GENERATE CODE FOR IT

		EXTERNAL SAVSPACE,QQ;
		LOCAL BASE T;
	MAP BASE TOP;

		!UNFORTUNATELY, WE HAVE TO LEAVE THE DUMMY CONTINUE
		!IN THE PROGRAM TREE. BUT IT WILL NOT DEGRADE THE CODE.

		!ALSO GO THROUGH THE REMAINING STATEMENTS AND
		!RETURN THE OPTIMIZERS CORE TO THE FREE LIST
		!AND ZERO SRCOPT (ELSE THE REGISTER ALLOCATOR
		!ETC WILL THINK IT IS A POINTER TO A LOCAL COMNSUB
		!WATCH OUT !********

		T_.TOP;
		WHILE .T NEQ .BOTTOM DO
		BEGIN
			IF .T[SRCOPT] NEQ 0 THEN
			BEGIN
				SAVSPACE(4,.T[SRCOPT]);
				T[SRCOPT]_0;
				IF .T[SRCID] EQL IFLID THEN
				BEGIN
					!LOGICAL IF STATEMENT
					LOCAL BASE T1;
					T1_.T[LIFSTATE];
					SAVSPACE(4,.T1[SRCOPT]);
					T1[SRCOPT]_0;
				END;
			END;
			T_.T[SRCLINK];
		END;
		T_.SORCPTR<LEFT>;
		!LOOK FOR TOP (CODE MAY HAVE BEEN MOVED TO LENTRY)

		WHILE .T NEQ .TOP DO
		BEGIN
			QQ_.T;
			T_.T[SRCLINK];
		END;
		!QQ NOW POINTS TO THE STATEMENT IN FRONT OF TOP
		T_.QQ;
		T[SRCLINK]_.TOP[SRCLINK];
		SAVSPACE(DOSIZ+SRCSIZ-1,.TOP);
	END;

ROUTINE MAKASSOC=
BEGIN
	!ROUITNE LOOKS AT ALL CALLS FOR CALLS TO DEFINE FILE
	!AND ALL OPENS FOR ASSOCIATE VARIABLES AND CREATES A LINKED
	!LIST OF THE SAME HEADED BY THE GLOBAL ASSOCPT.

	EXTERNAL ASSOCPT,QQ;
	MAP BASE ASSOCPT:QQ;

	EXTERNAL CSTMNT,SORCPTR;
	MAP BASE CSTMNT;

	EXTERNAL NAME,CORMAN;

	ROUTINE LNKASSOC(AVAR)=
	BEGIN
		!LINK THE ASSOCIATED VARIABLE INTO
		!THE LINKED LIST

		MAP BASE AVAR;

		IF .AVAR[OPR1] EQL CONSTFL THEN
		ELSE
		IF .AVAR[OPRCLS] EQL ARRAYREF OR .AVAR[OPRCLS] EQL DATAOPR
		THEN
		BEGIN
			LOCAL BASE NEWLNK;
			NAME<LEFT>_1;
			!GET THE CORE FOR THE LINKED LIST
			NEWLNK_.ASSOCPT;
			ASSOCPT_CORMAN();
			IF .NEWLNK NEQ 0 THEN
				NEWLNK[RIGHTP]_.ASSOCPT;
			!NO ITS LINKED IN FILL IN THE INFO
			ASSOCPT[LEFTP]_(IF .AVAR[OPRCLS] EQL ARRAYREF
					THEN .AVAR[ARG1PTR] ELSE
					.AVAR);
		END;
	END;

	CSTMNT_.SORCPTR<LEFT>;
	!FROM FIRST TO LAST
	WHILE .CSTMNT NEQ 0 DO
	BEGIN
		IF .CSTMNT[SRCID] EQL CALLID THEN
		BEGIN
			QQ_.CSTMNT[CALSYM];
			IF .QQ[IDSYMBOL] EQL SIXBIT'DEFINE' THEN
			BEGIN
				LOCAL ARGUMENTLIST AG;
				AG_.CSTMNT[CALLIST];
				IF .AG[ARGCOUNT] GEQ 3 THEN
					LNKASSOC(.AG[3,ARGNPTR]);
			END;
		END
		ELSE
		IF  .CSTMNT[SRCID] EQL OPENID THEN
		BEGIN
			LOCAL OPENLIST AG;
			AG_.CSTMNT[OPLST];
			INCR I FROM 0 TO .CSTMNT[OPSIZ]-1 DO
			BEGIN
				IF .AG[.I,OPENLCODE] EQL OPNCASSOCI THEN
					LNKASSOC(.AG[.I,OPENLPTR]);
			END;
		END;
		CSTMNT_.CSTMNT[SRCLINK];
	END;
END;
GLOBAL ROUTINE MRP2=
BEGIN
EXTERNAL DLOOPTREE;
EXTERNAL QQ;
MAP BASE QQ;
EXTERNAL CORMAN,BACKST,LOCELMIO;
MAP BASE BACKST;
EXTERNAL MEMCMCHK;
EXTERNAL WARNOUT,NULLOOPTST,GLOBEND;
EXTERNAL CDONODE;

DWP_-1;
ISN_1;
IF .GLOBEND NEQ 0 THEN WARNOUT(78);

FGP_RGP_RGPHBAS_FGPHBAS_1;
POOL_POOL[POOLSIZ/2]_0;
RGRAPH_POOL<0,0>;
FGRAPH_POOL[POOLSIZ/2]<0,0>;
!ADJUST THE STACK SIZE TO REFLECT THE FACT THE
!THE OPTIMIZER IS ABOUT TO USE POOL TO BUILD
!THE GRAPH OF THE PROGRAM
SREG<LEFT>_EXTSIGN(.SREG<LEFT>)+POOLSIZ-1;
!INITAILIZE A VARIBALE TO STOP RANDOM USE. IT IS USED IN
!P2REGCNTS, A PART OF PHASE 2 SKELETON
NAME<LEFT>_DOSIZ+SRCSIZ;
CDONODE_CORMAN();
!MAKE LIST OF ASSOCIATE (RANDOM ACCESS I/O) VARIABLE
MAKASSOC();

	!CHECK FOR MAIN PROGRAM WITH NO LOOPS
	IF .DLOOPTREE EQL 0 THEN
		FNREFNO_1		!TO DECREASE REGISTER ALLOCATION
					!SINCE THE COST OF MATERIALIZATION
					!IS NOT DISTRIBUTED OVER MULTIPLE
					!EXECUTIONS OF THE LOOP
	ELSE
	BEGIN
		FNREFNO_0;
		LOOPNO_1;			!INITIALIZE LOOPNO
		LOOP_WALKER();			!GET A DO LOOP
		WHILE .LOOP NEQ 0 DO
		BEGIN
			DOPARMS(.LOOP);
			!PICK UP THE GLOBAL INFO USED
			GPHBLD();			!BUILD DIRECTED GRAPH
			!SAVE LOTS OF USELESS WORK BY
			!LOOKING FOR
			!DO 10
			!DO 10
			!AS A SPECIAL, OFT OCCURRING CASE
			QQ_.TOP[SRCLINK];
			IF .QQ[SRCID] EQL DOID AND
			.QQ[DOLBL] EQL .TOP[DOLBL] THEN
			BEGIN
				!ADD THE INDEX VARIABLE FOR THE LOOP
				!TO THE DOCHNGL LIST OF THE INNER MORE
				!LOOP
				MAP PHAZ2 QQ:TOP;
				LOCAL BASE TMP;
				EXTERNAL NAME,CORMAN;
				!GET CORE FOR ENTRY
				NAME<LEFT>_1;
				TMP_CORMAN();
				!THE LEFTP FIELD POINTS TO THE INDEX
				!VARIABLE FOR THIS LOOP
				TMP[LEFTP]_.TOP[DOSYM];
				!THE RIGHTP FIELD IS THE LINK TO 
				!THE PREVIOUS DOCHNGL LIST. NOTE:
				!THIS WORKS EVEN IF THE PREVIOUS DOCHNGL IS 0.
				TMP[RIGHTP]_.QQ[DOCHNGL];
				TOP[DOCHNGL]_.TMP;
			END
			ELSE
			BEGIN
				FLOOD();			!MOORE FLOOD
				DEFDRIV();			!GET DEFINITION POINTS
				GLOBELIM();			!COMMON SUBS AND
							!CODE MOTION
				PROPAGATE();			!CONSTANT PROPAGATION
							!AND REDUCTION IN STRENGTH
			END;
			DOCOLLAPSE();			!REDUCE LOOP TO A
							!SINGLE NODE FOR GRAPH
							!OF NEXT OUTER LOOP
			LOOP_WALKER();
			LOOPNO_.LOOPNO+1;
		END;
	END;
	!NOW WE ARE UP TO THE MAIN PROGRAM
	LENTRY_.SORCPTR<LEFT>;
	!LOOK FOR A DO LOOP AS THE FIRST STATEMENT AND QUIT HERE
	TOP_.LENTRY[SRCLINK];
	IF .TOP[SRCID] NEQ DOID THEN
	BEGIN
	FUDGDO();
	!INDVAR IS USED AS A POINTER. WE MUST MAKE IT SOMETHING
	!THAT WILL NOT BLOW UP WHEN USED AS A POINTER
	!POOL HAS A ZERO IN IT, SO WE WILL USE POOL

	INDVAR_POOL<0,0>;
	GPHBLD();
	FLOOD();			!MOORE FLOOD
	DEFDRIV();		!DEFINITION POINT
	GLOBELIM();		!CODE MOTION AND COMMON SUBS
	PROPAGATE();		!CONSTANT PROPAGATION AND REDUCTION IN STRENGTH
	UNFUDGDO();
	END;

	!GET OUT SMOOTHLY
	PASSOUT();

FLGREG<OPTIMIZE>_1;
!NOW MAKE THE STACK INCLUDE ALL OF POOL AGAIN
SREG<LEFT>_EXTSIGN(.SREG<LEFT>)-POOLSIZ+1;
END;			!END OF MRP2
SAVE17_.SREG<0,36>+#1000001;
MRP2();
POPJ(#17,0)
END ELUDOM
    