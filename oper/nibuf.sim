! 9 MAR 73    NIBUF.SIM     *CW
!BUFFERLET CODE


DEF TEL AS 0         !***************DEBUG***********

FIND HACK.TEMP
FIND WORKSPACE(0)
FIND MASK(0)
FIND MASK.COMP(0)
FIND CHAR.PROP(0)
FIND STORE(0)

FIND %FUSBUDGET   !****
FIND %OUTMAP      !*******DEBUG*******
FIND %MSG         !*******DEBUG*********
FIND %FM.PTR      !*******DEBUG*********
FIND %FM.FR.INT   !*******DEBUG*********
FIND %R.P.L.DATA
FIND %L.P.L.DATA
FIND %WORK.TO.BUF           !MAP CHARS FROM WORK SPACE TO BUFFERLETS
FIND %PUNT
FIND %C.ELMTS                 !CREATE ELEMENTS
FIND %G.ELMT                  !GET A LIST ELEMENT
FIND %R.P.CDR
FIND %L.P.CDR
FIND %AR.N
FIND %AR.OFF
FIND %R.C.B.TEXT
FIND %R.C.B.S.B
FIND %L.C.B.S.B
FIND %R.C.B.S.O
FIND %L.C.B.S.O

FIND LINE.WORK.SIZE

FIND %SET.BUF.CHAR
FIND %GET.BUF.CHAR          !GET A CHARACTER OUT OF A BUFFERLET
FIND %G.BUFFERLET
GLOBAL.PROC(SCAN.TOKEN,H.SCAN.TOKEN)!SCAN A TOKEN
GLOBAL.PROC(C.B.CK.SM,H.C.B.CK.SM)   !COMPUTE CHECKSUM FOR R.C.B
GLOBAL.PROC(EQ.IDENTIFIER.P,H.EQ.IDENTIFIER.P)  !EQUAL IDENT. PRED.
GLOBAL.PROC(HASH,H.HASH)            !COMPUTE HASH CODE
GLOBAL.PROC(EQV.BUF,H.EQV.BUF)

FIND %R.BUF.N.C               !DATA ACCESS ROUTINES
FIND %L.BUF.N.C

FIND BUFFERLETS
!
PROC(C.B.CK.SM,H.C.B.CK.SM,'C.B.CK.SM',(C.B))
!INPUT: CONTROL BLOCK POINTER
!VALUE: CHECKSUM: A 24 BIT QUANTITY IN LOW ORDER 24 BITS

LOCAL SUM,I,PTR,%SUB.C.B.CK.SM

!SLOW VERSION

SUM _ 0
!COMPUTE SUM OVER HEADER -- IGNORE CHECKSUM FIELD
!HEADER IS SITTING IN THE WORKSPACE
I _ 3
WHILE INC I <= WORK.NUM.CHARS THEN SUB.C.B.CK.SM(WORKSPACE(I))
SUB.C.B.CK.SM(XSTX)
                        !NOW WE CONTINUE WITH THE TEXT IN BUFFERLETS
PTR _ R.C.B.TEXT(C.B)
WHILE PTR # E.O.L &
 THEN &
  DO                     !FOR EACH BUFFERLET
  PTR _ R.P.CDR(PTR)
  I _ 0
  WHILE INC I <= R.BUF.N.C(PTR) &
   THEN &
    DO                 !FOR EACH CHARACTER
               !BARBER POLE CHECKSUM
    SUB.C.B.CK.SM(GET.BUF.CHAR(PTR,I))
    END
  END
SUB.C.B.CK.SM(XETX)           !SUM THE XETX
RETURN(SUM)



%SUB.C.B.CK.SM(CHAR)
SUM _ (((SUM SHL 1) BXOR (SUM SHR 23))BAND OCT 77777777)BXOR CHAR
RETURN
END SUB.C.B.CK.SM

END.PROC(C.B.CK.SM,H.C.B.CK.SM)
!
PROC(EQ.IDENTIFIER.P,H.EQ.IDENTIFIER.P,'EQ.IDENTIFIER.P',(A,B))
!INPUT: POINTERS TO TWO IDENTIFIERS
!VALUE: TRUE IF IDENTIFIERS EQUAL, ELSE FALSE

LOCAL J

!VALIDATE INPUT ARGUMENTS
IF NOT(AR.N(A) <= NUM.AREAS &
 AND AR.N(B) <= NUM.AREAS) &
  THEN RETURN(FALSE)
IF NOT(AR.OFF(A) <= AR.SIZE(AR.N(A)) &
 AND AR.OFF(B) <= AR.SIZE(AR.N(B))) &
  THEN RETURN(FALSE)

!IDENTITY CHECK
WHILE A # B &
 THEN &
  DO
  !KICK OUT ON EITHER STRING SHORTER
  !FIRST: FEWER BUFFERLETS
  IF A=E.O.L OR B=E.O.L THEN RETURN(FALSE)
  !SECOND: CHECK COUNT AND THE CHARACTERS BY WHOLE WORD MATCHES
  J _ 0
  WHILE INC J < BUF.SIZE &
   THEN &
    DO
    IF R.P.L.DATA(A,J) # R.P.L.DATA(B,J) THEN RETURN(FALSE)
    END
  !STEP TO NEXT BUFFERLETS
  A _ R.P.CDR(A)
  B _ R.P.CDR(B)
  END

!FULL EQUALITY
RETURN(TRUE)
END.PROC(EQ.IDENTIFIER.P,H.EQ.IDENTIFIER.P)
!
PROC(HASH,H.HASH,'HASH',(IDENT.PTR))  !COMP HASH OF AN IDENTIFIER
!INPUT: POINTER TO AN IDENTIFIER BUFFERLET STRING
!VALUE: A ONE WORD HASH VALUE

!FOR NOW, WE USE SIMPLE BARBER POLE LOGICAL SUM OF BUFFERLET
! WORDS FOR HASH

LOCAL HSH,I
FUSBUDGET               !****
IF AR.N(IDENT.PTR) # AR.N(BUFFERLETS) &
 THEN &
  DO            !******DRASTIC PROBLEM***
  PUNT(HARD,'BUFFER OPERATION REQUESTED ON NON-BUFFER',0)
  END

HSH _ 0                !INIT HASH
WHILE IDENT.PTR # E.O.L &
 THEN &
  DO                    !FOR EACH BUFFERLET
  I _ 0
  WHILE INC I <  BUF.SIZE &
   THEN &
    DO                  !FOR EACH CHARACTER
    HSH _ (HSH ROTL 1) BXOR R.P.L.DATA(IDENT.PTR,I)  !DO HASH OPER.
    END
  !STEP TO NEXT BUFFERLET
  IDENT.PTR _ R.P.CDR(IDENT.PTR)
  END

RETURN(ABS HSH)               !FORCE POSITIVE
END.PROC(HASH,H.HASH)
!
PROC(SCAN.TOKEN,H.SCAN.TOKEN,'SCAN.TOKEN',(C.B,PRED)) !SCAN NEXT TOKEN
!INPUT: CONTROL BLOCK POINTER, TEXT PREDICATE AND (HEADER.P SHL 1)
!VALUE: A TOKEN TYPE; A TOKEN VALUE

LOCAL %BACKSPACE,%CLEANUP,%GETNEXT,%POST.CHAR,%SCAN.DEL
LOCAL %SCAN.SPACES,%IDENTIFIER.END,%INTEGER.END

LOCAL BUF,BUF.I,OLD.BUF,OLD.BUF.I,MAX.BUF.I,CHAR,C.PROP,LIST,INT
DEF FLUSH AS IF WORK.I>0 THEN[LIST _ WORK.TO.BUF(LIST);WORK.I _ 0]
DEF WORK.I AS WORKSPACE(0)

!UNPACK PREDICATES
LOCAL TEXT.P
LOCAL HEADER.P
TEXT.P _ BYT(PRED,1,0)
HEADER.P _ BYT(PRED,1,1)

!GET SET UP TO SCAN 1ST CHAR
OLD.BUF _ BUF _ R.C.B.S.B(C.B)
OLD.BUF.I _ BUF.I _ R.C.B.S.O(C.B)
MAX.BUF.I _ R.BUF.N.C(BUF)
C.PROP _ 0

!MSG('SCAN.TOKEN IN BUFFERLET AT ')              *******DEBUG*********
!OUT.PTR(TEL,BUF)                                *******DEBUG*********
!MSG('  WITH OFFSET  ')
!OUT.FR.INT(TEL,BUF.I)   
!HOOK(SCANIT)


IF TEXT.P &
 THEN &
  DO                    !WE HAVE TEXT REQUEST

!HOOK(TEXTL)
!MSG('SCANNING FOR TEXT$')    *****DEBUG*********

  IF NOT GET.NEXT &
   THEN &
    DO                  !EMPTY INPUT STRING
    CLEANUP
    RETURN[T.T.NIL;T.V.T.NIL]
    END

  IF C.P.TEXT.TERM(CHAR) &
   THEN &
    DO                  !WE HAVE NIL LIST
    IF C.P.EOC(CHAR) THEN BACKSPACE   !DON'T SWALLOW EOC
    CLEANUP
    RETURN[T.T.NIL;T.V.T.NIL]
    END

!HOOK (GOTEXT)
!MSG('HAVE TEXT $')                       ********DEBUG******
  !WE HAVE FINITE TEXT
  LIST _ E.O.L
  !ACCUMULATE TEXT CHARACTERS
  WORKSPACE(WORK.I _ 1) _ CHAR
  WHILE GET.NEXT AND NOT C.P.TEXT.TERM(CHAR) THEN POST.CHAR
  IF C.P.EOC(CHAR) THEN BACKSPACE   !DON'T SWALLOW EOC
  FLUSH
  CLEANUP
  RETURN[T.T.TEXT;LIST]
  END


!NOT TEXT
IF NOT SCAN.SPACES &
 THEN &
  DO                    !NO SIGNIFICANT DATA
  CLEANUP
  RETURN[T.T.EOC;FALSE]
  END

IF C.P.COMMA(CHAR)  &
 THEN &
  DO            !WE HAVE A NIL ARGUMENT FIELD
  CLEANUP       !STEP PAST COMMA
  RETURN[T.T.NIL;T.V.T.NIL]
  END

IF C.P.EOC(CHAR) &
 THEN &
  DO            !WE HAVE AN END OF COMMAND
  CLEANUP       !STEP PAST IT
  RETURN[T.T.EOC;TRUE]
  END

IF C.P.NUMERIC(CHAR) &
 THEN &
  DO            !WE HAVE AN INTEGER (PERHAPS A DEL)

!MSG('SCANNING NUMBER OR DEL FROTZ $')        *****DEBUG****
!HOOK(NUMBER)

  INT _ CHAR-XZERO
  WHILE GET.NEXT &
   THEN &
    DO
    IF C.P.NUMERIC(CHAR)   !BUILD INTEGER! &
     THEN INT _ (INT*10)+CHAR-XZERO !IGNORE OVERFLOW, FOR NOW! &
     ELSE &
      DO        !END INTEGER
      IF C.P.SPACE(CHAR) THEN SCAN.SPACES
      IF C.P.DEL(CHAR) &
       THEN RETURN DOUBLE SCAN.DEL !IT IS A DEL FROTZ! &
       ELSE   !A TERMINATED INTEGER! &
        DO
         INTEGER.END
         CLEANUP
         RETURN [T.T.INT;INT]
        END
      END
    END
  !EMPTY ENDED INTEGER
  CLEANUP
  RETURN[T.T.INT;INT]
  END

IF C.P.ALPHA(CHAR) &
 THEN &
  DO            !WE HAVE A NORMAL IDENTIFIER

!MSG('SCANNING IDENTIFIER $')
!HOOK(IDENT)

  LIST _ E.O.L
  WORK.SPACE(WORK.I _ 1) _ CHAR
  WHILE GET.NEXT AND C.P.ALPHA.NUMERIC(CHAR) THEN POST.CHAR
  IDENTIFIER.END
  FLUSH
  RETURN[T.T.IDENT;LIST]
  END

IF C.P.DEL(CHAR) &
 THEN &
  DO            !WE HAVE A NIL DEL
  GET.NEXT
  IDENTIFIER.END
  RETURN[T.T.NIL;T.V.T.NIL]
  END

IF C.P.SOH(CHAR) OR C.P.OTHER(CHAR) &
 THEN PUNT(HARD,'ERROR IN SYNTAX SCAN',0)  !CANNOT RECOVER SAFELY

!IF CONTROL REACHES HERE, THEN THERE IS A BUG IN THE SCAN LOGIC
PUNT(HARD,'BUG IN SCAN LOGIC',0)

%BACKSPACE              !BACK UP IN INPUT STREAM
!INPUT: NONE
!VALUE: NONE

!VARIABLES BELONG TO SCAN.TOKEN

BUF _ OLD.BUF
BUF.I _ OLD.BUF.I
MAX.BUF.I _ R.BUF.N.C(BUF)
CHAR _ GET.BUF.CHAR(BUF,BUF.I)
C.PROP _ CHAR.PROP(CHAR)
RETURN
END BACKSPACE


%CLEANUP                !CLEAN UP AFTER SCAN
!INPUT: NONE
!VALUE: NONE

!VARIABLES BELONG TO SCAN.TOKEN

L.C.B.S.B(C.B,BUF)
L.C.B.S.O(C.B,BUF.I)
RETURN
END CLEANUP


%GET.NEXT               !GET NEXT CHAR FROM INPUT STREAM
!INPUT: NONE
!VALUE: TRUE IF THERE IS A CHARACTER; ELSE FALSE

!ALL VARIABLES BELONG TO SCAN.TOKEN

OLD.BUF.I _ BUF.I
IF BUF.I = 1  &
 THEN &
  OLD.BUF _ BUF      !IN ORDER TO BCKSPACE INTO SAME BUFFERLET
                     !AFTER THE VERY FIRST CHARACTER
IF BUF.I >= MAX.BUF.I &
 THEN &
  DO
  OLD.BUF _ BUF
  WHILE BUF.I >= MAX.BUF.I &
   THEN &
    DO
    IF NOT BUF = E.O.L &
     THEN &
      DO
      BUF _ R.P.CDR(BUF)
      BUF.I _ 0
      MAX.BUF.I _ C.PROP _ 0
      END
    IF BUF = E.O.L THEN RETURN(FALSE)
    MAX.BUF.I _ R.BUF.N.C(BUF)
    END
  END

CHAR _ GET.BUF.CHAR(BUF,INC BUF.I)
C.PROP _ CHAR.PROP(CHAR)
RETURN(TRUE)
END GET.NEXT


%POST.CHAR              !POST A CHARACTER TO WORKSPACE
!INPUT: NONE
!VALUE: NONE

!ALL VARIABLES BELONG TO SCAN.TOKEN

IF WORK.I >= MAX.WORK.SPACE THEN FLUSH
WORKSPACE(INC WORK.I) _ CHAR
RETURN
END POST.CHAR


%SCAN.DEL               !SCAN A DEL FROTZ
!INPUT: NONE
!VALUE: TOKEN TYPLE; TOKEN VALUE

!ALL VARIABLES BELONG TO SCAN.TOKEN

!SCAN INT NUMBER OF CHARACTERS OR 'TIL END OF DATA STRING
!MAKE SURE THERE IS AT LEAST ONE CHARACTER
IF NOT GET.NEXT THEN RETURN[T.T.NIL;T.V.T.NIL]

LIST _ E.O.L
WORKSPACE(WORK.I _ 1) _ CHAR
WHILE GET.NEXT AND DEC INT > 0 THEN POST.CHAR
FLUSH
IDENTIFIER.END
RETURN[T.T.IDENT;LIST]
END SCAN.DEL


%SCAN.SPACES            !SCAN PAST SPACES
!INPUT: NONE
!VALUE: TRUE IS ANY CHARACTERS LEFT, ELSE FALSE

!VARIABLES BELONG TO SCAN.TOKEN

WHILE GET.NEXT &
 THEN &
  DO
  IF NOT C.P.SPACE(CHAR) THEN RETURN(TRUE)
  END
RETURN(FALSE)
END SCAN.SPACES


%INTEGER.END           !USED AFTER INTEGERS
!INPUT: NONE
!VALUE: NONE

!VARIABLES BELONG TO SCAN.TOKEN

IF C.P.SPACE(CHAR) THEN SCAN.SPACES  !SWALLOW TRAILING SPACES
IF NOT C.P.COMMA(CHAR) THEN BACKSPACE  !SWALLOW ONLY COMMA
CLEANUP
RETURN
END INTEGER.END



%IDENTIFIER.END         !USED AFTER IDENTIFIERS
!INPUT: NONE
!VALUE: NONE

!VARIABLES BELONG TO SCAN.TOKEN

IF NOT HEADER.P &
 THEN &
  DO
  IF C.P.SPACE(CHAR) THEN SCAN.SPACES  !SWALLOW TRAILING SPACES
  IF NOT C.P.COMMA(CHAR) THEN BACKSPACE !SWALLOW ONLY COMMA
  END &
 ELSE BACKSPACE         !DON'T SWALLOW ANYTHING IF HEADER.P
CLEANUP
RETURN
END IDENTIFIER.END
END.PROC(SCAN.TOKEN,H.SCAN.TOKEN)
!
PROC(EQV.BUF,H.EQV.BUF,'EQV.BUF',(BUF,OFF)) !FIND EQV BUF, OFF PAIR
!INPUT: BUF PTR AND OFFSET
!VALUE: EQUIVALENT BUF PTR, OFFSET PAIR WHERE OFFSET DOES NOT 
!       CROSS A BUFFERLET BOUNDARY

LOCAL N

WHILE OFF > (N _ R.BUF.N.C(BUF)) &
 THEN &
 DO
  IF BUF _ R.P.CDR(BUF) = E.O.L THEN RETURN [FALSE;0]
  OFF _ OFF-N
 END

RETURN [BUF;OFF]

END.PROC(EQV.BUF,H.EQV.BUF)
  