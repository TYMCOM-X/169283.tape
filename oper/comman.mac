TITLE FTNCMD -- COMMAND SCANNER INTERFACE FOR FORTRAN COMPILER
SUBTTL DONALD LEWINE/DAL/FI/HPW 

	VCOMND2==12
;COPYRIGHT 1972,1973, DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS


	TWOSEG
;************ VERSION NUMBER *************
;
;15-MAY-73
;ADDED MAIN ENTRY SYMBOL MRP0 FOR SINGLE SEGMENT COMPILER/HPW

LASTED==0	;LAST EDITOR
MAJVER==1	;MAJOR VERSION NUMBER
MINVER==0	;MINOR VERSION NUMBER
EDNUM==0	;EDIT NUMBER
JOBVER=137

	LOC	JOBVER
	EXP	<LASTED>B2+<MAJVER>B11+<MINVER>B17+<EDNUM>
	RELOC	400000
;AC'S USED COMMAND SCANNER

	F=0		;FLAGS
	T1=1		;TEMP
	T2=2		; ..
	T3=3		; ..
	T4=4		; ..
	P1=5		;PRESERVED AC
	P2=6		; ..
	N=7		;NUMBER AC
	C=10		;CHARACTER AC
	FREG=16		;STACK FRAME POINTER
	P=17		;PUSH DOWN POINTER

;I/O CHANNELS
	BIN==1		;REL FILE OUTPUT
	LST==2		;LISTING FILE OUTPUT
	SRC==3		;SOURCE FILE INPUT

;OFFSETS INTO CHNLTBL
	TBLMAX==^D10
	HDR==3
	PNT==4
	CNT==5
;FLAG BITS IN F (SEE FIRST.BLI BEFORE CHANGING THESE BITS)

SW.OPT==1B35		;GLOBAL OPTIMIZE
SW.NET==1B34		;NO ERRORS ON TTY
SW.MAC==1B33		;MACRO CODE
SW.IDS==1B32		;INCLUDE DEBUG STATEMENTS
SW.EXP==1B31		;EXPAND
SW.DEB==1B30		;DEBUG
SW.CRF==1B29		;CREF
LSTFLG==1B25		;LISTING FILE BEING MADE
SW.KAX==1B24		;KA-10 FLAG
RELFLG==1B22		;REL FILE BEING MADE
SW.PHO==1B10		;PEEP HOLE OPTIMIZE
COMKA==1B12		;COMPILING ON A KA-10
SW.OCS==1B13		;ONLY CHECK SYNTAX
EOCS==1B8		;END OF COMMAND STRING
SW.TIM==1B16		;TIMING INFORMATION
TTYDEV==1B1		;LISTING ON TTY:
SW.NOW==1B2		;DON'T PRINT WARNING MESSAGES
;DEFAULTS


DM	ADV,1,0,1
DM	BAK,1,0,1
DM	CRF,1,0,1
DM	DEB,1,0,1
DM	EXP,1,0,1
DM	INC,1,0,1
DM	MAC,1,0,1
DM	NOE,1,0,1
DM	WEO,1,0,1
DM	ZER,1,0,1
DM	OPT,1,0,1
DM	OCS,1,0,1
DM	NOW,1,0,1
DM	TIM,1,0,1

ND	PDLLEN,^D500 + ^D1440		;LENGTH OF PDL
					;NOTE THE ADDITION OF 1440 OF SPACE TO PDLLEN!!!
					;SEEDECLARATION POOLSIZ IN FIRST.BLI
					;THIS SPACE WILLACTUALLY BE OCCUPIED BY
					;THE GLOBAL VECTORS STK AND POOL SO THAT
					;MORE SPACE FOR THE STACK CAN BE MADE AVAILABLE TO HIGHLY RECURSIVE OPERATIONS
					;THAT MAY OCCUR IN THE COMPILER

;DEFAULT FLAG SETTINGS
INDADF:	EXP	<AD.CRF>_<^L<SW.CRF>>+<AD.DEB>_<^L<SW.DEB>>+<AD.EXP>_<^L<SW.EXP>>+<AD.INC>_<^L<SW.IDS>>+<AD.MAC>_<^L<SW.MAC>>+<AD.NOE>_<^L<SW.NET>>

DEFINE	SWTCHS,<

SP	ADVANCE,FAREA+F.ADV,.SWDEC##,ADV
SP	BACKSPACE,FAREA+F.BACK,.SWDEC##,BAK
SP	CROSSREF,<POINTR(SAVEF,SW.CRF)>,.SWDEC##,CRF
SP	DEBUG,<POINTR(SAVEF,SW.DEB)>,.SWDEC##,DEB
SP	EXPAND,<POINTR(SAVEF,SW.EXP)>,.SWDEC##,EXP
SS	KA10,<POINTR(SAVEF,SW.KAX)>,1
SS	KI10,<POINTR(SAVEF,SW.KAX)>,0
SP	INCLUDE,<POINTR(SAVEF,SW.IDS)>,.SWDEC##,INC
SP	MACROCODE,<POINTR(SAVEF,SW.MAC)>,.SWDEC##,MAC
SP	NOERRORS,<POINTR(SAVEF,SW.NET)>,.SWDEC##,NOE
SP	NOWARNING,<POINTR(SAVEF,SW.NOW)>,.SWDEC##,NOW
SP	*OPTIMIZE,<POINTR(SAVEF,SW.OPT)>,.SWDEC##,OPT
SP	*SYNTAX,<POINTR(SAVEF,SW.OCS)>,.SWDEC##,OCS
SP	TAPEND,FAREA+F.WEOF,.SWDEC##,WEO
SP	TIME,<POINTR(SAVEF,SW.TIM)>,.SWDEC##,TIM
SP	ZERO,FAREA+F.DTZR,.SWDEC##,ZER
>
	XALL
	DOSCAN(FORT)
	SALL
	SUBTTL	COMPILER INITIALIZATION

MRP0::				;SINGLE SEGMENT ENTRY POINT
FORTRA:	TDZA	T1,T1		;FLAG AS NORMAL ENTRY
	MOVEI	T1,1		;FLAG AS CCL ENTRY
	MOVEM	T1,CCLSW##	;SAVE CCL SWITCH
	SKIPE	T1,GETSBL##	;HAVE WE BEEN HER BEFORE?
	JRST	FORTR1		;YES MUST BE DOING ^C START
	MOVEM	11,GETSBL##	;STORE DEVICE NAME FROM RUN
	MOVEM	7,GETSBL+4	;STORE FILE NAME FROM RUN COMMAND
FORTR1:
	MOVE	T2,[FIRZER,,FIRZER+1] ;CLEAR LOCAL STORAGE
	SETZM	FIRZER		; ..
	BLT	T2,LASZER	; ..
	JUMPPT	(T1,CP166,KA10)	;FIGURE OUT TYPE OF CPU
	TDZA	T1,T1		;KI-10 CLEAR FLAG
KA10:	MOVX	T1,SW.KAX!COMKA	;KA-10 SET FLAG
	IORM	T1,SAVEF	;STORE SWITCH IN MEMORY
	RESET			;RESET ACTIVE I/O
	MOVE	T1,.JBFF##	;START OF CORE
	CORE	T1,		;REMOVE CRUFT FROM PREVIOUS JOBS
	  JFCL			;DO NOT CARE IF IT FAILS
;
; SET UP TRAP FOR
;
; AP.POV	PUSHDOWN OVERFLOW
; AP.ABK	ADDRESS BREAK (FUTURE)
; AP.ILM	MEMORY PROTECTION VIOLATION
; AP.NXM	NON-EXISTENT MEMORY
;
	MOVEI	T1,APRTRP	;LOCATE TRAP ROUTINE
	MOVEM	T1,.JBAPR##	;TELL THE MONITOR WHEN TRAP OCCURS
	MOVEI	T1,AP.POV!AP.ABK!AP.ILM!AP.NXM	;SET CONDITIONS
	APRENB	T1,		;ENABLE TRAPS
;
	MOVE	P,[IOWD PDLLEN,STACK##] ;PUSH DOWN LIST
	HRRZI	FREG,(P)	;LIFE IS BLISS
	MOVE	T1,[2,,[EXP 0
			XWD CCLSW##,'FOR']]
	PUSHJ	P,.ISCAN##	;FIRE UP SCAN
COMND:
	MOVE	T1,[10,,[IOWD FORTL,FORTN
			 XWD  FORTD,FORTM
			 XWD      0,FORTP
			 EXP  -1
			 XWD  CLRALL,CLRFIL
			 XWD  ALLIN,ALLOUT
			 XWD  MEMSTK,APPSTK
			 XWD  CLRSTK,1B18
			 XWD       0,.POPJ1##]]
	PUSHJ	P,.TSCAN##	;SCAN 1 COMMAND LINE
	MOVE	T1,[4,,[IOWD FORTL,FORTN
			XWD  FORTD,FORTM
			XWD      0,FORTP
			EXP  -1]]
	PUSHJ	P,.OSCAN##		;SCAN THE OPTIONS FILE
	PUSHJ	P,ABSDEF	;FILL IN ABSENT DEFAULTS
	PUSHJ	P,NXTFIL	;GET THE NEXT FILE
	  JRST	FORTR1		;NO INPUT FILES GIVEN
	PUSHJ	P,OPENIN	;OPEN THE INPUT FILE
	MOVE	T1,F.NAME(P1)	;GET SRC FILENAME
	MOVEM	T1,CHNLTBL##+32	;PUT IN TABLE TO BE LOOKED
				; AT BY LISTING HEADER
	MOVE 	T1,F.EXT(P1)	;EXTENSION
	MOVEM	T1,CHNLTBL+33	;EXTENSION FIELD FOR SRC
				;ROUTINE IN CLASS
	MOVE	T1,LBLOCK+.RBALC;GET THE NUMBER OF BLOCKS ALLOCATED
	MOVEM	T1,LBLOCK+.RBEST; AND ESTIMATE THAT AS THE SIZE OF
	SETZM	LBLOCK+.RBALC	; EACH OUTPUT FILE.
	SKIPN	T2,RELSPC+F.DEV	;REL DEVICE GIVEN?
	JRST	NOREL		;NO--CONTINUE BELOW
	TXO	F,RELFLG	;LIGHT THE REL FILE BIT FOR OUTMOD
	MOVEI	P1,RELSPC	;POINTER TO FILESPEC
	PUSHJ	P,MTMODE	;SET UP MODE FOR MAG TAPE
	ADDX	T1,.IOBIN	;BINARY MODE
	MOVSI	T3,BINHDR	;HEADER POINTER
	OPEN	BIN,T1		;OPEN THE DEVICE
	  JRST	OPNERR		;CAN NOT DO IT!!!
	PUSHJ	P,SETENT	;SET UP FOR ENTER
	MOVEI	T1,BIN
	DEVCHR	T1,
	TXNN	T1,DV.DTA	;IS DEVICE A DECTAPE
	JRST	REL1		;NO
	ENTER	BIN,LBLOCK+2
	  JRST	UUOERR
	JRST	REL2
REL1:
	ENTER	BIN,LBLOCK	;ENTER IN UFD
	  JRST	UUOERR
REL2:
	OUTBUF	BIN,0		;SET UP O/P BUFFER
NOREL:	SKIPN	T2,LSTSPC+F.DEV	;GET THE DEVICE
	JRST	NOLST		;NO LISTING IF ZERO
;	MOVE	T3,LSTSPC+F.MOD
;	JRST	NOLST
	TXO	F,LSTFLG	;FLAG THAT A LISTING IS NEEDED
	MOVEI	P1,LSTSPC	;LISTING SPEC POINTER
	MOVE	T3,LSTSPC+F.MOD	;GET MODIFIERS
	TXNE	F,SW.CRF	;CREF ?
	TXNN	T3,FX.NUL	;NUL EXTENSION?
	JRST	NOCREF		;NOT CREF OR EXTENSION ALREADY SPECIFIED
;	MOVE	T3,LSTSPC+F.EXT
;	JUMPL	T3,NOCREF	;SKIP IF EXPLICIT EXTENSION
	MOVEI	T3,'CRF'
	HRLM	T3,F.EXT(P1)	;STORE CRF EXTENSION IN FILESPEC AREA
NOCREF:
	PUSHJ	P,MTMODE	;SET T1 FOR MAG TAPE MODE
	ADDX	T1,.IOASC	;ASCII MODE
	MOVSI	T3,LSTHDR	;POINTER TO BUFFER HEADER
	OPEN	LST,T1		;OPEN THE DEVICE
	  JRST	OPNERR		;CAN NOT OPEN DEVICE
	PUSHJ	P,SETENT	;SET UP FOR ENTER
	MOVEI	T1,LST
	DEVCHR	T1,
	TXNE	T1,DV.TTA
	TXO	F,TTYDEV	;SET BIT ON IF LST DEVICE IS TTY
	TXNN	T1,DV.DTA	;IS DEVICE A DECTAPE
	JRST	LST1		;NO
	ENTER	LST,LBLOCK+2
	  JRST	UUOERR
	JRST	LST2
LST1:
	ENTER	LST,LBLOCK	;ENTER THE FILE
	  JRST	UUOERR
LST2:
	MOVE	T1,F.NAME(P1)	;GET LISTING FILENAME
	MOVEM	T1,CHNLTB##+20	;STORE FOR USE IN PHASE1
	OUTBUF	LST,0		;SET UP O/P LST BUFFER
NOLST:	MOVEI	T1,[ASCIZ /% No output files given
/]
	TXNN	F,RELFLG!LSTFLG!SW.OCS	;ANY OUTPUT REQUESTED?
	PUSHJ	P,.TSTRG##	;NO--GIVE THE WARNING
LOOP:
	SKIPN	T1,CCLSW
	JRST	BYNAM
	MOVEI	T1,[ASCIZ /FORTRAN: /]
	PUSHJ	P,.TSTRG##
	SKIPE	T1,CHNLTB##+32	;GET FILE NAME IF ANY
	PUSHJ	P,.TSIXN##	;TYPE AS SIXBIT
	PUSHJ	P,.TCRLF##	;GIVE AN EOL
BYNAM:
	SETZM	SEGINCORE##	;ARGUMENT TO PHASE CONTROL
	PUSHJ	P,PHAZCONTROL##	;GET THE NEXT PHASE
	PUSHJ	P,NXTFIL	;LOOK FOR NEXT FILE SPEC
	JRST	LOOPDN		;END OF WILDCARD LST
	PUSHJ	P,OPENIN	;INPUT FILE NOT FOUND GET ANOTHER
	MOVE	T1,F.NAME(P1)	;GET SRC FILENAME
	MOVEM	T1,CHNLTBL##+32	;PUT IN TABLE TO BE LOOKED
				; AT BY LISTING HEADER
	MOVE 	T1,F.EXT(P1)	;EXTENSION
	MOVEM	T1,CHNLTBL+33	;EXTENSION FIELD FOR SRC
				;ROUTINE IN CLASS
	JRST	LOOP		;LOOP FOR MORE
LOOPDN:
	MOVEI	C,";"		;FUDGE UP AN END OF LINE
	TXON	F,EOCS		;FLAG AS END OF COMMAND STRING
	JRST	LOOP		;FINISH OFF COMPILATION
	CLOSE	LST,
	CLOSE	SRC,
	CLOSE	BIN,
	MOVE	T2,[FIRZER,,FIRZER+1] ;CLEAR LOCAL STORAGE
	SETZM	FIRZER		; ..
	BLT	T2,LASZER	; ..
	JUMPPT	(T1,CP166,KA102)	;FIGURE OUT TYPE OF CPU
	TDZA	T1,T1		;KI-10 CLEAR FLAG
KA102:	MOVX	T1,SW.KAX!COMKA	;KA-10 SET FLAG
	IORM	T1,SAVEF	;STORE SWITCH IN MEMORY
	RESET			;RESET ACTIVE I/O
	MOVE	T1,.JBFF##	;START OF CORE
	CORE	T1,		;REMOVE CRUFT FROM PREVIOUS JOBS
	  JFCL			;DO NOT CARE IF IT FAILS
	JRST	COMND		;INITIALIZE AND LOOK FOR NEXT COMMAND
	SUBTTL	SUBROUTINES CALLED FROM .TSCAN

;SUBROUTINE TO CLEAR ALL ANSWERS
CLRALL:	SKIPA	T2,[LSTCLR]	;THE WHOLE THING

;SUBROUTINE TO CLEAR FILE ANSWERS
CLRFIL:	MOVEI	T2,FAREA+F.LEN	;JUST CLEAR F AREA
	MOVE	T1,[FIRZER,,FIRZER+1] ;CLEAR FROM FIRZER
	SETZM	FIRZER		; ..
	BLT	T1,(T2)		; TO THE END
	POPJ	P,		; ..

;SUBROUTINE TO ALLOCATE AN OUTPUT AREA
ALLOUT:	AOS	T3,OUTCNT	;T3 = COUNT OF OUPUT FILES
	MOVE	T1,[EXP RELSPC,LSTSPC]-1(T3) ;T1 = ADDRESS OF SPEC
	MOVEI	T2,F.SLEN	;T2 = LENGTH OF SPEC
	CAIG	T3,2		;TOO MANY SPECS?
	POPJ	P,		;NO--ALL DONE
	M.FAIL	<More than 2 output files are not allowed>

;SUBROUTINE TO ALLOCATE AN INPUT AREA

ALLIN:	SKIPE	T1,LINPTR	;ANY LAST INPUT SPEC?
	JRST	ALLIN1		;YES--MAKE ANOTHER
	MOVE	T1,.JBFF##	;FIRST INPUT SPEC GOES HERE
	MOVEM	T1,FINPTR	;SAVE FOR LATER
	SUBI	T1,F.LEN	;FIX UP SO FIRST SPEC IS CORRECT
	MOVEM	T1,LINPTR	;SAVE AWAY
ALLIN1:	MOVEI	T2,<F.LEN*2>(T1);ADDRESS OF NEXT SPEC
	CAMGE	T2,.JBREL##	;WILL IT FIT?
	JRST	ALLIN2		;YES--CONTINUE
	CORE	T2,		;NO--EXPAND CORE
	  JRST	E.NCF		;NO CORE--YOU LOOSE
ALLIN2:	MOVEI	T1,F.LEN	;LENGTH OF SPEC
	ADDM	T1,.JBFF##	;UPDATE JOBFF
	ADDB	T1,LINPTR	;UPDATE T1 AND POINTER
	MOVEI	T2,F.SLEN	;AMOUNT SCAN KNOWS ABOUT
	POPJ	P,		;RETURN

;SUBROUTINE TO CLEAR STICKEY DEFAULTS

CLRSTK:	SETZM	PAREA		;ALL THE STICKEY DEFAULTS
	MOVE	T1,[PAREA,,PAREA+1] ; ..
	BLT	T1,PAREA+F.LEN-1; ARE IN THE PAREA
	POPJ	P,
	XALL
DEFINE	MEM(A),<
IRP	A,<
	SKIPE	T1,FAREA+F.'A	;IS A SPECIFIED?
	MOVEM	T1,PAREA+F.'A	;YES--REMEMBER A
>>

;SUBROUTINE TO MEMORIZE STICKEY DEFAULTS

MEMSTK:	MEM	(<ADV,BACK,WEOF,REW,DTZR>)
	POPJ	P,

DEFINE	APPLY(A),<
IRP	A,<
	MOVE	T1,PAREA+F.'A	;PICK UP STICKEY DEFAULT FOR A
	SKIPN	FAREA+F.'A	;IS A LOCAL OVER RIDE PRESENT
	MOVEM	T1,FAREA+F.'A	;NO--APPLY THE DEFAULT


>>

;SUBROUTINE TO APPLY STICKEY DEFAULTS

APPSTK:	APPLY	(<ADV,BACK,WEOF,REW,DTZR>)
	POPJ	P,
	SALL
	SUBTTL	SUBROUTINES FOR COMMAND SCANNING

;SUBROUTINE TO  APPLY ABSENT DEFAULTS

ABSDEF:	SETCM	F,SAVEFM	;T1 GETS A 1 BIT FOR EVERY BIT IN F
				; WHICH WAS NOT EXPLICITLY SPECIFIED
				; BY THE USER.
	AND	F,INDADF	;AND WITH THE DEFAULTS.
	IORB	F,SAVEF		;OR IN THE SELECTED BITS.
	MOVEI	T1,RELSPC	;POINT AT REL FILE
	HRLOI	T2,'REL'	;DEFAULT EXTENSION
	PUSHJ	P,DEFEXT	;FILL IN DEFAULT
	MOVEI	T1,LSTSPC	;POINT TO LISTING FILE SPEC
	HRLOI	T2,'LST'	;DEFAULT EXTENSION
	PUSHJ	P,DEFEXT	;FILL IN DEFAULT
	MOVE	T1,FINPTR	;POINT TO FIRST INPUT SPEC
ABSDF1:	HRLOI	T2,'FOR'	;DEFAULT EXTENSION
	PUSHJ	P,DEFEXT	;GO DEFAULT IT
	CAMN	T1,LINPTR	;LAST INPUT POINTER
	POPJ	P,		;YES--ALL SET UP
	ADDI	T1,F.LEN	;POINT TO NEXT SPEC
	JRST	ABSDF1		;LOOP FOR NEXT SPEC

;SUBROUTINE TO FILL IN A DEFAULT EXTENSION
;CALL WITH:
;	T1 = FILE SPEC POINTER (PRESERVED)
;	T2 = EXTENSION
;	PUSHJ	P,DEFEXT
;	RETURN HERE
DEFEXT:	HLRZ	T3,F.EXT(T1)	;GET EXTENSION
	JUMPN	T3,.POPJ##	;ALL DONE IF IT WAS GIVEN
	HRRE	T3,F.EXT(T1)	;EXPLICITLY NULL
	AOJE	T3,.POPJ##	;JUMP IF YES
	MOVEM	T2,F.EXT(T1)	;NO--SET UP DEFAULT
	POPJ	P,		; RETURN
	SUBTTL	LOOKUP/ENTER SUBROUTINES

;SUBROUTINE TO RETURN THE NEXT FILE TO BE READ BY FORTRAN.
;IT RETURNS WITH THE EOCS BIT SET IN F. IF THIS IS THE
; LAST SPEC IN THE COMMAND STRING. IT SKIP RETURNS IF A
; FILE SPEC HAS BEEN FOUND.
;CALL WITH:
;	PUSHJ	P,NXTFIL
;	  NOTHING FOUND
;	SPEC POINTER IN P1
NXTFIL:	MOVE	T1,[4,,[XWD FINPTR,LINPTR
			XWD OBLOCK,LBLOCK
			XWD F.LEN,.RBALC
			EXP 1B0+<SRC>B17+LKTEMP]]
	PUSHJ	P,.LKWLD##	;SCAN THE DISK OR TAPE
	  POPJ	P,		;NON-SKIP WHEN DONE
	MOVE	P1,LKTEMP	;POINTER TO CURRENT SPEC
	CAMN	P1,LINPTR	;SAME AS LAST SPEC
	SKIPE	.WLDFL##	; AND NO WILD CARDS?
	TXZA	F,EOCS		;NO--MAY BE MORE
	TXO	F,EOCS		;YES--THIS IS THE LAST SPEC.
	JRST	.POPJ1##	;SKIP RETURN


;SUBROUTINE TO OPEN THE INPUT FILE
;CALL WITH:
;	P1 = FILE SPEC POINTER
;	PUSHJ 	P,OPENIN
;	RETURN HERE
OPENIN:	HRRZI	T1,SRCHDR	;BUFFER HEADER
	MOVEM	T1,OBLOCK+2	;STORE IN OPEN BLOCK
	OPEN	SRC,OBLOCK	;OPEN THE DEVICE
	  JRST	OPNER1		;OPEN ERROR
	MOVEI 	T1,SRC
	DEVCHR	T1,
	TXNN	T1,DV.DTA	;IS DEVICE DECTAPE
	JRST	OPEN1		;NO
	LOOKUP	SRC,LBLOCK+2	;DO DIFFERENT LOOKUP
	JRST	OPNER2
	JRST	OPEN2
OPEN1:
	LOOKUP	SRC,LBLOCK	;LOOKUP THE FILE
	  JRST	OPNER2		;NO CAN DO
OPEN2:
	MOVE	T2,OBLOCK	;T2 GETS THE DEVICE NAME
	PJRST	MTAOP		;POSITION MAG TAPE
OPNER1:
	PUSHJ	P,E.DFO##
	SKIPE	T1,CCLSW
	JRST	COMND
	JRST	FORTR1		;LOOP BACK
OPNER2:
	HRRZ	T1,LBLOCK+.RBEXT
	JUMPN	T1,OPNE2A	;EXPLICIT EXTENSION FILE LOOKUP ERROR
	MOVX	T1,FX.NUL	;NULL EXT MASK
	TDNN	T1,F.MOD(P1)	;WAS NULL EXTENSION INPUT?
	JRST	OPNE2A		;NO
	ANDCAM	T1,F.MOD(P1)	;YES,TURN OFF THAT BIT TO AVOID ALOOP
	HRRZS	LBLOCK+.RBEXT	;ZERO THE EXTENSION FIELD IN LOOKUP BLOCK
	JRST	OPENIN		;TRY AGAIN WITH NULL EXTENSION
OPNE2A:
	PUSHJ	P,E.DFL##	;TRY AGAIN AFTER ERROR MESSAGE
	SKIPE	T1,CCLSW
	JRST	COMND
	JRST	FORTR1		;LOOP BACK
;SUBROUTINE TO SET UP FOR AN ENTER
;CALL WITH:
;	P1 = FILE SPEC POINTER
;	PUSHJ	P,SETENT
;	RETURN HERE
SETENT:	PUSHJ	P,MTAOP		;POSITION THE TAPE
	SETZM	LBLOCK+.RBPPN
	SETZM	LBLOCK+.RBSIZ
	SETZM	LBLOCK+.RBVER
	SETZM	LBLOCK+.RBSPL
	SETZM	LBLOCK+.RBALC
	MOVE	T1,F.NAME(P1)	;PICK UP FILE NAME
	MOVE	T2,F.NAMM(P1)	;PICK UP FILE NAME MASK
	AOJN	T2,E.WILD	;CAN NOT BE WILD
	MOVEM	T1,LBLOCK+.RBNAM;STORE THE FILE NAME
	HRRE	T2,F.EXT(P1)	;GET THE EXTION MASK
	AOJN	T2,E.WILD	;MUST BE ALL SPECIFIED
	HLLZ	T2,F.EXT(P1)	;PICK UP THE EXTENSION
	MOVEM	T2,LBLOCK+.RBEXT;STORE FOR THE ENTER
	LDB	T1,[<POINTR(F.MOD(P1),FX.PRO)>] ;GET THE PROTECTION
	ROT	T1,-^D9		;PUT IN THE LEFT 9 BITS
	MOVEM	T1,LBLOCK+.RBPRV;STORE FOR THE ENTER
	MOVX	T1,FX.DIR	;DIRECTORY SPECIFIED?
	TDNN	T1,.FXMOD(P1)	; ??
	POPJ	P,		;NO--ALL DONE
	MOVE	T1,F.DIR(P1)	;PICK UP PPN
	MOVEM	T1,LBLOCK+.RBPPN;STORE FOR THE MOMENT
	SKIPN	F.DIR+2(P1)	;NEED ANY SFD'S TODAY
	POPJ	P,		;NO--ALL DONE
	MOVEI	T2,PATH		;YES--POINT ENTER TO PATH
	MOVEM	T2,LBLOCK+.RBPPN;  ..
	ADDI	T2,2		;SKIP PAST SWITCHES
	MOVEM	T1,(T2)		;STORE PPN
	MOVEI	T1,F.DIR+2(P1)	;POINT TO SFD LIST
SETEN1:	MOVE	T3,(T1)		;PICK UP SFD
	MOVEM	T3,1(T2)	;STORE IN PATH
	ADDI	T1,2		;SKIP TO NEXT SFD
	SKIPN	(T1)		;IS IT THERE??
	AOJA	T2,SETEN1	;YES--LOOP OVER IT
	SETZM	2(T2)		;NO--END THE LIST
	POPJ	P,
;SUBROUTINE TO PERFORM MAG TAPE OPERATIONS
;CALL WITH:
;	MOVEI	P1,FILE-SPEC-POINTER
;	PUSHJ	P,MTAOP
;	RETURN HERE WITH TAPE POSITIONED
MTAOP:	POPJ	P,		;NULL FOR NOW

;SUBROUTINE TO SET UP T1 AS A MODE  WORD FOR MAG TAPES
;CALL WITH:
;	MOVEI	P1,FILE-SPEC-POINTER
;	PUSHJ	P,MTAOP
;	RETURN HERE WITH T1 SET UP
MTMODE:	SETZM	T1		;START WITH A CLEAN SLATE
	POPJ	P,		;RETURN
	SUBTTL	ERROR CONDITIONS

CP166:	OUTSTR	[ASCIZ /? FORTRAN will not run on a PDP-6
/]
	CLRBFI	
	EXIT

E.NCF:	MOVEI	N,1(T2)
	M.FAID	<Not enouGH core for file specs. Total K needed=>

UUOERR:	HRRZ	T2,LBLOCK+.RBEXT
	HRRZ	N,P1		
	CAIN	T2,2
	JRST	EER02
	CAIN	T2,6
	JRST	EER06
	CAIN	T2,14
	JRST	EER14
	M.FAIF	<ENTER failure>
EER02:	M.FAIF	<PROTECTION FAILURE>
EER06:	M.FAIF	<RIB or directory error>
EER14:	M.FAIF	<Quota exceeded or disk full>

OPNERR:	MOVE	T2,T1		;COPY DEVICE NAME
	JRST	OPNER1	;GIVE ERROR MESSAGE

E.WILD:	MOVE	N,P1
	MOVE	T1,F.DEV(P1)	;GET DEVICE NAME
	DEVTYP	T1,		;GET THE DEVICE TYPE
	  HALT	.		;CAN ONLY FAIL IF THERE IS A BUG IN FORTRAN
				; SINCE FOROTS NEEDS THIS CALLI IT MUST EXIST
	TXNN	T1,TY.MAN	;LOOKUP/ENTER MANDATORY?
	POPJ	P,		;NO--IGNORE BAD FILE NAME
	SETOM	T2		;YES--GIVE ERROR MESSAGE
	M.FAIF	<Incorrect use of * or ? in>

.TNEWL::PJRST	.TCRLF##	;ROUTINE TO FORCE A NEW LINE FOR
				; FOR ERROR MESSAGES.
	XLIST
LIT::	LIT
	LIST

	RELOC	0	;IMPURE CODE

; CORE UUO FAILURE ROUTINE IS LOW SEGMENT RESIDENT

CORERR::			;HERE WHEN CORE UUO FAILS
	MOVEM	T1,APRSV1	;STORE T1
	MOVEM	T2,APRSV2	;STORE T2
	SOS	T1,0(P)		;WHERE WERE WE CALLED FROM
	HRRZM	T1,.JBTPC##	;STORE ADDRESS
	MOVEI	T2,CORTXT	;LOCATE MESSAGE
	JRST	APRTR4		;FINISH MESSAGE
	
CORTXT:	ASCIZ	\?USER CORE EXCEEDED\

; APR TRAP ROUTINE IS LOW-SEGMENT RESIDENT

; TEXT FOR APR TRAP ROUTINE

APRNXM:	ASCIZ	\ILLEGAL MEMORY REFERENCE\
APRPOV:	ASCIZ	\STACK EXHAUSTED\
APRILM:	ASCIZ	\MEMORY PROTECTION VIOLATION\
APRABK:	ASCIZ	\ADDRESS BREAK\
APRTX0:	ASCIZ	\
?INTERNAL COMPILER ERROR
?\
APRTX1:	ASCIZ	\ AT LOCATION \
APRTX2:	ASCIZ	\ IN PHASE \
APRTX3:	ASCIZ	\
?WHILE PROCESSING STATEMENT \

APRPN1:	POINT	3,.JBTPC##,17		;USEFUL BYTE POINTER
APRPN2:	POINT	6,400005		;USEFUL BYTE POINTER

APRIOR:	ASCII	\00000\			;MAKE A NUMBER

APRTRP:	TTCALL	3,APRTX0		;PREFACE MESSAGE
	MOVEM	T1,APRSV1		;SAVE A REGISTER
	MOVEM	T2,APRSV2		;SAVE A REGISTER
	MOVEI	T2,APRNXM		;ASSUME ILL MEM REF
	MOVE	T1,.JBCNI##		;TEST ERROR
	TRNE	T1,AP.POV		;PDL OVERFLOW?
	MOVEI	T2,APRPOV		;LOCATE MESSAGE
	TRNE	T1,AP.ABK		;ADDRESS BREAK
	MOVEI	T2,APRABK		;LOCATE MESSAGE
	TRNE	T1,AP.ILM		;MEMORY PROTECTION
	MOVEI	T2,APRILM		;LOCATE MESSAGE
APRTR4:	TTCALL	3,0(T2)			;TYPE MESSAGE
	TTCALL	3,APRTX1		;CONTINUE
	MOVE	T2,APRPN1		;LOAD POINTER
APRTR1:	ILDB	T1,T2			;TYPE ADDRESS
	MOVEI	T1,"0"(T1)		;TYPE ADDRESS
	TTCALL	1,T1			;TYPE DIGIT
	TLNE	T2,770000		;TYPE 6 DIGITS
	JRST	APRTR1			;TYPE 6 DIGITS
	SKIPN	.JBHRL##		;HIGH SEGMENT?
	JRST	APRTR2			;NO
	TTCALL	3,APRTX2		;CONTINUE
	MOVE	T2,APRPN2		;TYPE SEGMENT NAME
APRTR3:	ILDB	T1,T2			;LOAD BYTE
	MOVEI	T1," "(T1)		;TO ASCII
	TTCALL	1,T1			;TYPE BYTE
	TLNE	T2,770000		;TYPE 6 CHARACTER
	JRST	APRTR3			;TYPE 6 CHARACTER
APRTR2:	TTCALL	3,APRTX3		;CONTINUE
	MOVE	T1,ISN##		;GET STATEMENT #
	MOVEM	T3,APRSV3		;SAVE A REGISTER
	IDIVI	T1,^D10			;BREAK DOWN
	LSHC	T2,-7			;STORE
	IDIVI	T1,^D10			;BREAK DOWN
	LSHC	T2,-7			;STORE
	IDIVI	T1,^D10			;BREAK DOWN
	LSHC	T2,-7			;STORE
	IDIVI	T1,^D10			;BREAK DOWN
	LSHC	T2,^D29			;BUILD NUMBER
	LSHC	T1,^D29			;BUILD NUMBER
	IOR	T1,APRIOR		;CONVERT TO ASCII
	MOVSI	T2,(BYTE (7)15,12)	;FINISH MESSAGE
	TTCALL	3,T1			;FINISH MESSAGE
	MOVE	T1,APRSV1		;RESTORE AC
	MOVEPRSV2		;RESTORE AC
	MOVE	T3,APRSV3		;RESTORE AC
	EXIT	1,			;DONE
APRSV1:	BLOCK	1
APRSV2:	BLOCK	1
APRSV3:	BLOCK	1

;FILE SPEC AREA DEFINITIONS

;CCLSW:	BLOCK 	1	;0 IF NORMAL START, 1IF CCL START
FIRZER:!		;FIRST LOCATION TO ZERO
FAREA:	PHASE	0
F.DEV:!	BLOCK	1	;DEVICE NAME
F.NAME:!BLOCK	1	;FILE NAME
F.NAMM:!BLOCK	1	;FILE NAME MASK
F.EXT:!	BLOCK	1	;EXTENSION
F.MOD:!	BLOCK	1	;MOD WORD
F.MODM:!BLOCK	1	;MOD MASKS
F.DIR:!	BLOCK	1	;PPN
F.DIRM:!BLOCK	1	;DIRECTORY MASK
	BLOCK	12	;SPACE FOR SFD BIWORDS
F.SLEN==.-F.DIR-1
F.ADV:!	BLOCK	1	;NUMBER OF FILES TO ADVANCE TAPE
F.BACK:!BLOCK	1	;NUMBER OF FILES TO BACKSPACE TAPE
F.WEOF:!BLOCK	1	;WRITE AN END OF FILE
F.REW:!	BLOCK	1	;REWIND THE TAPE
F.DTZR:!BLOCK	1	;ZERO THE DTA DIRECTORY
	DEPHASE
F.LEN=.-FAREA		;SIZE OF THE FAREA


;AREA TO REMEMBER STICKEY SWITCHES

PAREA:	BLOCK	F.LEN	;STICKEY SPEC BLOCK

;OTHER FILE SPECIFICATION STORAGE
RELSPC:	BLOCK	F.LEN	;AREA FOR REL FILE SPEC
LSTSPC:	BLOCK	F.LEN	;AREA FOR LIST FILE SPEC
FINPTR:	BLOCK	1	;POINTRER TO FIRST INPUT SPEC
LINPTR:	BLOCK	1	;POINTER TO LAST INPUT SPEC
OUTCNT:	BLOCK	1	;NUMBER OF OUTPUT FILE SPECS
LSTCLR==.-1		;LAST WORD TO ZERO ON A *


;RANDOM LOCATIONS
SAVEF:	BLOCK	1	;HOLDS F WHILE IN SCAN SO .SWDPB DOES NOT
			; HARM T1.
SAVEFM:	BLOCK	1	;MASKS FOR STORED FLAGS
;LOCATIONS IN GLOBAL USED BY INOUT BUT SET UP HERE

DEFINE	BUFHDR(A,B),<
IRP A,<
IRP B,<
	A'B=CHNLTBL##+<<A-1>*TBLMAX>+B
>>>

	BUFHDR	(<BIN,LST,SRC>,<HDR,PNT,CNT>)

;UUO BLOCKS

LBLOCK:	BLOCK	.RBALC+1	;FOR LOOKUPS
OBLOCK:	BLOCK	3		;FOR OPENS
LKTEMP:	BLOCK	1		;FOR WILD
PATH:	BLOCK	1		;FOR PATH. UUO
DUMMBL: BLOCK 500		;DUMMY BLOCK TO BE USED IN OTHER PHASES FOR OWN STORAGE
LASZER==.-1
	END	FORTRAN
    ] 	o€