BASE 0

!PROCEDURES
FIND %GETDUM,%HASH,%OCTOUT,%SIXOUT,%NUMOUT
FIND %INITTTY,%DATOUT
LOCAL %L.FIRST,%ACT.LOOK,%CHKACT,%CHK.ACT.ERR,%CHK.IO.ERR,%CUS.LOOK
LOCAL %DUL.LOOK,%DUL.SEQ,%DULCHK,%DUL.OVERFLOW,%CUSCHK
LOCAL %FINDCUS,%ERROR,%LOKUP.DUL,%LOKUP.LUD
LOCAL %LUD.LOOK,%LUD.SEQ,%LUDCHK,%LUD.OVERFLOW
LOCAL %SERCHCUS,%USRCHK

DEF SIZE.BLK AS 128
!ID'S
GLOBAL USER(20),CUST(150),PPN,IER,ICODE,MODE,NAME.HASH,LOC.HASH
GLOBAL CH.OUT,P,NUMBER
LOCAL CH.LUD,CH.DUL,CH.CUST,ACT.ADR,IO.ADR
LOCAL D.INDEX,D.BLKNO,D.BLK(SIZE.BLK),DULNAM,DULFLG
LOCAL L.INDEX,L.BLKNO,L.BLK(SIZE.BLK),LUDNAM,I
LOCAL SAVCP,SIT31NAME,SITE
LOCAL IOTAB(WPF),BADBLK,BADFIL


!MACRO'S
DEF ACTSIT(A) AS BYT(USER(5),1,(BITS.PER.WORD-1)-A) !COMPUTE ACCTG. SITE
DEF CALL.GETACT(A,B) AS [ICODE_A; MODE_B; GETDUM]
DEF CR AS PUT(CARRET)
DEF DOTS AS MSG('...')
DEF FIXCP(A) AS (A-1)*SIZE.BLK	!COMPUTE CURSOR POS. FROM BLK. NO.
DEF LEGAL(A) AS (OCT 37 < A < OCT 133) OR A=0
DEF LUD.READ AS [RB(CH.LUD,SIZE.BLK,L.BLK); L.INDEX_0]
DEF DUL(A) AS D.BLK(D.INDEX+A)
DEF LUD(A) AS L.BLK(L.INDEX+A)
DEF DUL.READ AS [RB(CH.DUL,SIZE.BLK,D.BLK); D.INDEX_0]
DEF OCTWD.OUT(A) AS [OCTOUT(HW(@A,0)); PUT($,); OCTOUT(HW(@A,1))]
DEF PPN.OUT AS OCTWD.OUT(LUD(0))
DEF SIZE.LUD.ENT AS BYT(LUD(2),7,0)
DEF SETSITE AS [HW(@EXTARG(IOTAB),0)_SIT31NAME; SITBYT_SITBYT+SITE-31]
DEF SITBYT AS BYT(EXTARG(IOTAB),6,24)
DEF SYSINC AS [I_SITBYT; INC I; SITBYT_I]
DEF VERSION AS 4

!ERROR MESSAGES FOR READ DATA ERRORS
DEF NODUL.BAD AS 1
DEF NOACT.BAD AS 2
DEF HASH.BAD AS 3
DEF BLKNO.BAD AS 4
DEF NAME.BAD AS 5
DEF DIST.BAD AS 6
DEF NOLUD.BAD AS 10
DEF NODULA.BAD AS 11
DEF NOUSER.BAD AS 12
DEF GARBAGE AS 13
DEF TEXT.BAD AS 14
DEF NOCUST.BAD AS 15
DEF OVER.BAD AS 20

!LABELS
LOCAL CHK.ERR:

%CHKACT
	!MAIN LINE TO LOOK UP LUD, DUL FOR EACH SITE AND CHECK THEM
	!AGAINST EACH OTHER AND ACCOUNTING

LOCAL P1

START: IOCS(2); INITTTY; CH.OUT_OPEN('TEL',SEQUEN+OUTPUT+CHARACTER,0,2)
MSG('$PDP-10 CONSISTENCY CHECK - VERSION ');NUMOUT(VERSION)
CR; DATOUT
\\->START
PPN _ OCT 1042313

P1_CHPT('(CUD10)LUD.31',-1)
SETFID(IOTAB,@P1,0,CHK.ERR)
LUDNAM_NAMARG(IOTAB); SIT31NAME_HW(@EXTARG(IOTAB),0)

P1_CHPT('(CUD10)DUL.31',-1)
SETFID(IOTAB,@P1,0,CHK.ERR)
DULNAM_NAMARG(IOTAB)

CALL.GETACT(1,-1); CHK.ACT.ERR	!INITIALIZE USERNA.MES
CALL.GETACT(1,0); CHK.ACT.ERR	!INITIALIZE CUSTOM.ERS
USRCHK
CUSCHK

FOR SITE _ 31 TO 35 DO
 IF LOKUP.LUD=1 THEN [IF LOKUP.DUL=1 THEN [LUDCHK; DULCHK] &
	ELSE CHK.IO.ERR]  ELSE IF ERRNUM#FNFERR THEN CHK.IO.ERR
SYSINC
END

	CALL.GETACT(6,0); CHK.ACT.ERR; CALL.GETACT(6,-1); CHK.ACT.ERR
	CLOSE.ALL
	EXIT

%LUDCHK
	!READ THROUGH LUD, LOOKING UP AND CHECKING EACH ENTRY IN DUL
	!AND ACCOUNTING
LOCAL ENDLUD:
IO.ADR _ ENDLUD
CR; CR; MSG('CHECKING LUD.');NUMOUT(SITE);CR;CR
SETCP(CH.LUD,0); L.BLKNO _ 1; LUD.READ; L.INDEX _ 0
L.FIRST; GO LP1
LOOP DO
	LUD.SEQ
	LP1: WHILE LUD(4)=0 THEN LUD.SEQ
	IF DULFLG _ DUL.LOOK(LUD(0))=1 THEN DO
		HASH(DUL(1),DUL(2))
		IF NAME.HASH#LUD(4) THEN ERROR(HASH.BAD)
		IF LOC.HASH#L.BLKNO THEN ERROR(BLKNO.BAD)
		END ELSE ERROR(NODUL.BAD)
		USER(0)_LUD(0)
		IF(ACT.LOOK=1 AND ACTSIT(SITE)=1) THEN DO
	IF DULFLG=1 THEN [IF (DUL(1)#USER(8) OR DUL(2)#USER(9)) THEN &
		    	ERROR(NAME.BAD)]
		    IF BYT(LUD(1),8,0)#USER(3)/100 THEN ERROR(DIST.BAD)
		    END ELSE ERROR(NOACT.BAD)
END
ENDLUD: RETURN
END LUDCHK


%DULCHK
	!READ THROUH DUL, LOOKING UP ENTRY IN LUD
LOCAL ENDDUL:
IO.ADR _ ENDDUL
CR; CR; MSG('CHECKING DUL.');NUMOUT(SITE);CR;CR
SETCP(CH.DUL,0); D.BLKNO _ 1
 DUL.READ; D.INDEX _ -3

LOOP DO
	DUL.SEQ
	IF LUD.LOOK(@DUL(1))=0 THEN DO
		USER(0) _ DUL(0)
		IF ACT.LOOK=1 THEN ERROR(NOLUD.BAD)
	END
END
ENDDUL: CLOSE(CH.LUD); CLOSE(CH.DUL);  RETURN
END DULCHK


%USRCHK
	!READ THROUGH USERNA.MES, LOOKING UP ENTRY IN DUL FOR EACH SITE
	!THEN CHECK TO SEE IF CUSTOMER EXISTS IN CUSTOM.ERS
LOCAL ENDACT:
ACT.ADR_ENDACT
CR; CR; MSG('CHECKING USERNA.MES.'); CR; CR
CH.CUST _ OPEN('ALLCUS.TS',SEQUEN+OUTPUT+WORD,CHK.ERR,2)
LOOP DO 
	CALL.GETACT(4,-1); CHK.ACT.ERR	!GET NEXT USER
	CUST(0)_USER(4)	!SAVE CUSTOMER NUMBER
	IF CUS.LOOK=0 THEN ERROR(NOCUST.BAD)
	W(CH.CUST,CUST(0))	!ALL CUSTOMERS FOUND IN USERNAMES
	FOR SITE _ 31 TO 35 DO
	  IF ACTSIT(SITE)=1 THEN DO
	   IF LOKUP.DUL#0 THEN DO
	   IF DUL.LOOK(USER(0))=0 THEN DO
		L.INDEX _ 0; LUD(0) _ USER(0); ERROR(NODULA.BAD)
		END
		 CLOSE(CH.DUL)
	END ELSE ERROR(NODULA.BAD)
	END
END
END
ENDACT: CLOSE(CH.CUST); RETURN
END USRCHK



%CUSCHK
	!READ THRU CUSTOM.ERS - IF A CUST IS FOUND IN ALLCUS.TS,OK
	!IF NOT, LOOK FOR IT IN USERNA.MES
LOCAL ENDCUS:,CHAR
ACT.ADR_ENDCUS
CR; CR; MSG('CHECKING CUSTOM.ERS.'); CR; CR
LOOP DO
	CALL.GETACT(4,0); CHK.ACT.ERR !GET NEXT CUSTOMER
	P _ CHPT(@CUST(3),-1)
	LOOP DO
	REPEAT 71*CHARS.PER.WORD DO
		CHAR _ NCHV P
		IF NOT(LEGAL(CHAR)) THEN [ERROR(TEXT.BAD); REPEAT 0]
	END
	REPEAT 0
	END
	IF FINDCUS = 0 AND SERCHCUS = 0 THEN ERROR(NOUSER.BAD)
END
ENDCUS: DELETE('ALLCUS.TS',CHK.ERR); RETURN
END CUSCHK


%LUD.SEQ
	!READ NEXT SEQUENTIAL LUD ENTRY
LOCAL J
L.INDEX+_SIZE.LUD.ENT
 IF LUD(0)<0 THEN LUD.OVERFLOW
%%L.FIRST
WHILE LUD(0)=0 THEN DO
	LOOP DO
	FOR J_1 TO SIZE.BLK-1-L.INDEX IF LUD(J)#0 THEN [BADBLK_L.BLKNO;&
				ERROR(GARBAGE); REPEAT 0]
	REPEAT 0
	END
	INC L.BLKNO; LUD.READ
END
RETURN
END LUD.SEQ


%DUL.SEQ
	!READ NEXT SEQUENTIAL DUL ENTRY
LOCAL J
D.INDEX+_3
IF DUL(0)<0 THEN DUL.OVERFLOW
WHILE DUL(0)=0 THEN DO
	LOOP DO
	FOR J_1 TO SIZE.BLK-1-D.INDEX IF DUL(J)#0 THEN [BADBLK_D.BLKNO;&
				ERROR(GARBAGE); REPEAT 0]
	REPEAT 0
	END
	INC D.BLKNO; DUL.READ
END
RETURN
END DUL.SEQ


%LUD.LOOK(ADR)
	!LOOK UP NAME IN ADR,ADR+1 IN LUD
HASH(^ADR,^(ADR+1))
SETCP(CH.LUD,FIXCP(LOC.HASH)); LUD.READ 
WHILE DUL(0)#LUD(0) THEN DO	!CHANGE LATER POSSIBLY TO COMPARE NAME.HASH # LUD(4)
	L.INDEX+_SIZE.LUD.ENT
	IF LUD(0)=0 THEN RETURN 0
	IF LUD(0)<0 THEN LUD.OVERFLOW
	END
RETURN 1
END LUD.LOOK


%DUL.LOOK(PPN)
	!LOOK UP PPN IN DUL
SETCP(CH.DUL,FIXCP((PPN MOD 101)+1)); DUL.READ
WHILE DUL(0)#PPN THEN DO
	D.INDEX+_3
	IF DUL(0)=0 THEN RETURN 0
	IF DUL(0)<0 THEN DUL.OVERFLOW
	END
RETURN 1
END DUL.LOOK


%ACT.LOOK
	!LOOK UP USER IN USERNA.MES
CALL.GETACT(3,-1); IF IER = 0 THEN RETURN 1
IF IER = 1 THEN RETURN 0 ELSE CHK.ACT.ERR
END ACT.LOOK


%CUS.LOOK
	!LOOKUP CUSTOMER IN CUSTOM.ERS
CALL.GETACT(3,0); IF IER = 0 THEN RETURN 1
IF IER = 1 THEN RETURN 0 ELSE CHK.ACT.ERR
END CUS.LOOK



%SERCHCUS
	!LOOK FOR CUST(0) IN USERNA.MES
CALL.GETACT(1,-1); CHK.ACT.ERR	!INITIALIZE USERNA.MES
LOOP DO
	CALL.GETACT(4,-1); IF IER = 2 THEN RETURN 0
	IF IER # 0 THEN CHK.ACT.ERR
	IF USER(4) = CUST(0) THEN RETURN 1
END
END SERCHCUS


%FINDCUS
	!LOOK FOR CUST(0) IN ALLCUS.TS
LOCAL CUSEND:
CH.CUST _ OPEN('ALLCUS.TS',SEQUEN+INPUT+WORD,CUSEND,2)
LOOP DO 
	IF R(CH.CUST) = CUST(0) THEN [CLOSE(CH.CUST); RETURN 1]
END
CUSEND:CLOSE(CH.CUST);  RETURN 0
END FINDCUS


%CHK.ACT.ERR
	!CHECK ACCTG. FILE ERRORS
 IF IER=0 THEN RETURN
IF IER=2 THEN [IF ACT.ADR#0 THEN GO ^ACT.ADR]
 MSG('ERROR ON '); IF MODE <0 THEN MSG('USERNA.MES') ELSE MSG('CUSTOM.ERS')
DOTS; CR

 DO IER OF 1:4
1:  MSG('ENTRY NOT FOUND.')
2:  MSG('NO END OF FILE ADR. SET UP.')
3: MSG('ERROR ON FILE.')
4: MSG('MISC. ERROR.')
END
  EXIT
END CHK.ACT.ERR


%CHK.IO.ERR
	!TAKE CARE OF ALL I/O ERRORS FROM IOCS
CHK.ERR: IF ERRNUM=EOFERR AND IO.ADR # 0 THEN GO ^IO.ADR
 MSG('ERROR ON ');WFID(FIDP);DOTS ;CR
  DO ERRNUM OF TMFERR:CORERR
FNDERR: MSG('BAD FILE MODE OR TYPE')
IFDERR: MSG('ILLEGAL FILE IDENTIFIER')
FNFERR: MSG('FILE NOT FOUND')
IUSERR: MSG('INVALID USER NAME')
PRTERR: MSG('PROTECTION FAILURE')
EOFERR: MSG('END OF FILE')
 END
MSG('.$ERROR ');NUMOUT(ERRNUM);EXIT
END CHK.IO.ERR


%LUD.OVERFLOW
	!READ LUD OVERFLOW BLOCK
IF L.INDEX<SIZE.BLK-20 THEN[BADBLK_L.INDEX;BADFIL_'LUD';ERROR(OVER.BAD)]
SAVCP_CP(CH.LUD)
SETCP(CH.LUD,HW(LUD(0),1)*SIZE.BLK)
LUD.READ
SETCP(CH.LUD,SAVCP)
RETURN
END LUD.OVERFLOW


%DUL.OVERFLOW
	!READ DUL OVERFLOW BLOCK
IF D.INDEX<SIZE.BLK-6 THEN [BADBLK_D.INDEX;BADFIL_'DUL';ERROR(OVER.BAD)]
SAVCP_CP(CH.DUL)
SETCP(CH.DUL,HW(DUL(0),1)*SIZE.BLK)
DUL.READ
SETCP(CH.DUL,SAVCP)
RETURN
END DUL.OVERFLOW


%ERROR(ERR)
	!TYPE OUT DATA ERRORS TO USER
DO ERR OF NODUL.BAD:OVER.BAD
NODUL.BAD: MSG('NO DUL ENTRY FOR ');PPN.OUT
NODULA.BAD: MSG('NO DUL ENTRY FOR ');PPN.OUT;DOTS;SIXOUT(@USER(8),12)
DOTS; 	MSG('SITE: '); NUMOUT(SITE)
NOACT.BAD: MSG('NO ACCTG. ENTRY FOR ');PPN.OUT;DOTS ;SIXOUT(@DUL(1),12)
HASH.BAD: MSG('HASH OF ');PPN.OUT;PUT($=);OCTWD.OUT(NAME.HASH);CR
	MSG('ENTRY IN LUD = ');OCTWD.OUT(LUD(4))
BLKNO.BAD: MSG('HASH BLK. NO. OF ');PPN.OUT;PUT($=);OCTOUT(LOC.HASH)
	CR;MSG('ENTRY IS IN BLK. NO. ');OCTOUT(L.BLKNO);DOTS;SIXOUT(@DUL(1),12)
NAME.BAD: PPN.OUT;DOTS ; MSG('NAME IN DUL: ');SIXOUT(@DUL(1),12)
	MSG('NAME IN ACCTG.: ');SIXOUT(@USER(8),12)
DIST.BAD: MSG('LUD DISTRICT = ');NUMOUT(BYT(LUD(1),8,0))
	DOTS; MSG('ACCT. DISTRICT = ');NUMOUT(USER(3)/100);DOTS;PPN.OUT;DOTS;SIXOUT(@DUL(1),12)
NOLUD.BAD: MSG('NO LUD ENTRY FOR ');OCTWD.OUT(DUL(0));DOTS; SIXOUT(@DUL(1),12)
NOUSER.BAD: MSG('CUSTOMER NUMBER '); NUMOUT(CUST(0)); MSG(' HAS NO')
	MSG(' ENTRY IN USERNA.MES.')
GARBAGE: MSG('GARBAGE IN BLOCK '); NUMOUT(BADBLK)
TEXT.BAD: MSG('BAD TEXT FOR CUSTOMER '); NUMOUT(CUST(0))
NOCUST.BAD: MSG('CUSTOMER NUMBER ');NUMOUT(CUST(0));MSG(' NOT FOUND')
OVER.BAD: MSG('OVERFLOW POINTER IN '); MSG(BADFIL); MSG(' IS IN WORD ')
	NUMOUT(BADBLK); CR; CLOSE.ALL; EXIT

END
CR;RETURN
END ERROR


%LOKUP.LUD
	!LOOK FOR LUD.SITE ON DSK
LOCAL LUD.ERR:
	NAMARG(IOTAB)_LUDNAM; SETSITE
	CH.LUD_OPEN(-IOTAB,DIRECT+INPUT+WORD,LUD.ERR)
	RETURN 1
LUD.ERR: IF ERRNUM#FNFERR THEN CHK.IO.ERR ELSE RETURN 0
END LOKUP.LUD


%LOKUP.DUL
	!LOOK FOR DUL.SITE ON DSK
LOCAL DUL.ERR:
	NAMARG(IOTAB)_DULNAM; SETSITE
	CH.DUL_OPEN(-IOTAB,DIRECT+INPUT+WORD,DUL.ERR)
	RETURN 1
DUL.ERR: IF ERRNUM# FNFERR THEN CHK.IO.ERR ELSE RETURN 0
END LOKUP.DUL


END CHKACT
   