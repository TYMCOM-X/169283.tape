SUBTTL DONALD LEWINE/AL/RCC/DAL - VERSION 4 - 18 JAN 1972

;***COPYRIGHT 1970,1971,1972  DIGITAL EQUIPMENT CORP.,  MAYNARD, MASS.****


;SWITCHES ARE ON IF THE ARE DEFINED NON-ZERO
	SALL			;SUPPRESS MACRO EXPANSION
IFNDEF ONESEG,	<TWOSEG>
IFDEF ONESEG,<IFE ONESEG,<TWOSEG>>

;DEFAULT CONDITIONS
;SCHEDULING PARAMETERS ARE ON PAGE 3
IFNDEF	HLINEN	<HLINEN==^D30	;30 LINES OF HEADERS>
IFNDEF	HSPACE	<HSPACE==4	;4 SPACES ON HEADERS>
IFNDEF	DSKBN	<DSKBN==4	;4 DISK INPUT BUFFERS>
IFNDEF	LPTBN	<LPTBN==2	;2 LINE PRINTER BUFFERS>
IFNDEF	PTPBN	<PTPBN==2	;2 PAPER TAPE PUNCH BUFFERS>
IFNDEF	PLTBN	<PLTBN==2	;2 PLOTTER BUFFERS>
IFNDEF	CDPBN	<CDPBN==2	;2 CARD PUNCH BUFFERS>
IFNDEF	TTYOBN	<TTYOBN==3  	;3 TELETYPE OUTPUT BUFFERS>
IFNDEF	PDSIZE	<PDSIZE==200  	;200 LOCATIONS ON PDL>
IFNDEF	SLTIME	<SLTIME==5  	;TIME TO HIBER FOR DEVICE NOT USEFUL>
IFNDEF	NENT	<NENT==20	;NUMBER OF FILES PER REQUEST>
IFNDEF	OLDMON	<OLDMON==0	;OLD DISK SERVICE (LEVEL C)>
IFNDEF	LPP	<LPP==^D60	;LINES PER PAGE>
IFNDEF	CPC	<CPC==^D80	;CHAR PER CARD>
IFNDEF	CPCMON	<CPCMON==^D81	;NO. CHARS/CARD THAT THE MONITOR BELIEVES>
IFNDEF	CPF	<CPF==^D120	;CHAR PER FOOT OF TAPE>
IFN	OLDMON	<MAXUUO==3	;NO EXTENDED UUO'S; ONLY NEED 4 WORDS>
IFNDEF	MAXUUO	<MAXUUO==7	;# OF ARGS IN UUO'S NOT INCLUDING COUNT>
IFNDEF	INIC	<INIC=="5"	;INITIAL CHATTINESS >
IFNDEF	INIL	<INIL=="0"	;INITIAL LENGTH OF MESSAGES>
IFNDEF	INIE	<INIE=="0"	;THIRD DIGIT OF MSGLVL>
IFNDEF	BDWAY	<BDWAY==0	;FLASH S IN LIGHTS>
;DO NOT SET FTLOCK NON ZERO - BUG IN GETSEG
IFNDEF	FTLOCK	<FTLOCK==0	;LOCK LOWSEG IN CORE>
IFNDEF	ENTSIZ	<ENTSIZ==13	;SIZE OF EACH ENTRY>
IFNDEF	MAXERR	<MAXERR==^D10	;NUMBER OF DISK I/O ERRORS PRIOR  TO PUNTING>
IFNDEF	FTDPM	<FTDPM==0	;IF -1 ALLOW THE LPT TO BE TURNED ON AND
				; OFF WITHOUT LOSS OF DATA. THIS WILL
				; SLOW DOWN LPTSP>
IFN	FTDPM	<LPTBN==1	;IF FTDPM MUST HAVE ONLY 1 BUFFER>
IFNDEF	PICNUM	<PICNUM==2	;NUMBER OF PICTURE PAGES IN LPTSPL>
IFNDEF	FTELF	<FTELF==0	;NON-ZERO TO SUPPORT MACX11  TAPE>
IFNDEF	ONESEG	<ONESEG==0	;NON-ZERO TO MAKE SINGLE-SEGMENT VERSION
				;(TO FACILITATE DEBUGGING)
				;(NOTE: USER SHOULD LOAD WITH %H)>
IFNDEF	FTRNM	<FTRNM==-1	;RENAME UNPRINTED FILES BACK TO USER>
IFNDEF	LOGCPY	<LOGCPY==1	;NUMBER OF COPIES OF LOG TO PRINT>
IFNDEF	LOGLIM	<LOGLIM==LPP*^D10	;LIMIT FORLOG FILES IF OVER QUOTA>
IFNDEF	CHRLIN	<CHRLIN==^D132	;WIDTH OF LPT LINE>
IFNDEF	SPLPRT	<SPLPRT==157000	;LH OF .RBPRV ON ENTERS>
IFNDEF	DATOFS	<DATOFS==^D38395	;DATE OFFSET>
IFNDEF	PDP6LP	<PDP6LP==0	;PDP6 LINE PRINTER>
IFNDEF	CNTRL	<CNTRL==0	;-1 TO XLIST 60 PAGES OR SO>
IFNDEF	JIFSEC	<JIFSEC==^D60	;UNITS OF RUNTIME>
IFNDEF	FACTSW	<FACTSW==-1	;-1 TO INCLUDE FACT STUFF>
IFNDEF	FCTCNT	<FCTCNT==1	;KEEP RETRYING FOR DAEMON EVERY FCTCNT TIMES
				;(1 MEANS TRY ALWAYS, 2^18-1 MEANS NEVER)>
IFNDEF	MINUSY	<MINUSY==^D1200	;NUMBER OF MINUS Y PRIOR TO PLOT>
IFNDEF	PLUSX	<PLUSX==^D225	;NUMBER OF +X BEFORE PLOT>
IFNDEF	PLUSY	<PLUSY==^D554	;NUMBER OF +Y BEFORE PLOT>
IFNDEF	MINPCK	<MINPCK==^D5	;MIN. PER CHKPNT>
IFNDEF	FTREM	<FTREM==0	;-1 TO DELETE SPACES ON REMOTE
				; DC71/LP08>
IFNDEF	RPW	<RPW==-1	;SUPPORT /REPORT:REPORT-NAME>



;VERSION NUMBERS

VWHO==:0	;WHO LAST EDITED THIS FILE
VMAJOR==:4	;MAJOR VERSION NUMBER
VMINOR==:1	;MINOR VERSION NUMBER
VEDIT==:141	;EDIT NUMBER

%SPOOL==:<BYTE (3)VWHO(9)VMAJOR(6)VMINOR(18)VEDIT>

;SCHEDULING PARAMETER USED TO SELECT THE NEXT JOB

IFNDEF	IFC	<IFC==^D20	;EVERY IFC JOB RUN THE OLDEST
				; JOB NOT THE "BEST. THE FAIR
				; COUNT IS RESET EVERY TIME THE
				; OUTPUT QUEUE IS DRAINED.>
IFNDEF	MAXLIM	<MAXLIM==^D10000;THE BIGGEST JOB THAT WILL BE RUN
				; ANYTHING BIGGER WILL BE IGNORED.
				; THIS VALUE IS CHANGED WITH THE
				; MLIMIT COMMAND.

;IF THE ENTRY IS TO BIG TO SCHEDULE AND THIS IS NOT A "FAIRNESS"
; TIME(IFC JOBS) THEN A PRIORITY IS COMPUTED FROM THE FOLLOWING
; FUNCTION:>


				;PRIORITY OF REQUEST=
IFNDEF	LIMFCT	<LIMFCT==^D1000000;LIMFCT/(OUTPUT FORMS LIMIT)>
IFNDEF	SIZFCT	<SIZFCT==^D10000;+SIZFCT/(BLOCKS*COPIES)>
IFNDEF	EPRFCT	<EPRFCT==^D17	;+EPRFCT*(EXTERNAL PRIORITY)>
IFNDEF	DEDFCT	<DEDFCT==^D32	;+DEDFCT*(TIME SINCE DEADLINE)>
IFNDEF	CSTFCT	<CSTFCT==0	;+CSTFCT*(LH OF Q.PRI)>
IFNDEF	FCHFCT	<FCHFCT==^D145	;-FCHFCT (IF FORMS CHANGE)>
IFNDEF	BIAS	<BIAS==^D50	;+BIAS>

;CHECK ONLY 1 SPOOLER BEING GENERATED

DEFINE	CHECK	(DEVICE,CODE,MODE)<	;;CHECK EACH UNIT
	IFNDEF DEVICE'SPL,<	;;IS THIS SPOOLER DEFINED
	DEVICE'SPL==0>		;;NO--DEFINE TO BE ZERO
	IFN	DEVICE'SPL,<	;;IS THIS UNIT SET UP YET
	IFN	K,<		;;ANY OTHER SPOOLERS
	PRINTX	?MORE THAN 1 SPOOLER  REQUESTED
	PASS2
	LOC	137
	CALLI	12
	END	137		;;STOP NOW>
	K==-1
	.TITL	(DEVICE,\VMAJOR,\VMINOR,\VEDIT,CODE,MODE)>>
;MACRO TO SETUP FOR 1 TYPE OF SPOOLER

DEFINE	.TITL	(DEVICE,R,M,E,CODE,MODE)<
TITLE	DEVICE'SPL DISK TO DEVICE SPOOLER - V R'A(E) - D LEWINE
	DEV==<SIXBIT /DEVICE/>	;;SIXBIT NAME OF DEVICE
				;;PROCESSING THE FILE
	XXXSPL==DEV+SIXBIT /   SPL/	;;NAME OF THIS PROGRAM
	PREFIX==DEV&7777B11	;;FIRST 2 LETTERS OF DEVICE
	CUSP==CODE		;;THE QUEUE CODE FOR THIS CUSP
	STATUS=MODE		;;FILE STATUS
	LOC	137
	+%SPOOL
	SEG==-1			;;FLAG AS A HISEG
	INTERN	QUEUEN,QUEUEM
	QUEUEN==XXXSPL
	QUEUEM==QUEUEN_<-^D18>
	IFE ONESEG,<RELOC 400000>
	IFN ONESEG,<RELOC 140>
	DEFINE	CSPNAME,<
	ASCIZ	\DEVICE'SPL Version R'A(E)  Running on +
\>
	IFNDEF ONESEG <JRST	SPOOL		;SO START 400010 WORKS>>

	K==0			;USED BY CHECK MACRO
	CHECK	LPT,PRINTR,A
	CHECK	PTP,TAPER,I
	CHECK	CDP,PUNCHR,I
	CHECK	PLT,PLOTR,I
IFE K,<	PRINTX	No SPOOLER selected
	PRINTX	to select a spooler define any ONE
	PRINTX	of the following symbols as -1 [leave rest 
	PRINTX	 undefined]
	PRINTX	
	PRINTX	LPTSPL	for line printer
	PRINTX	PTPSPL	for paper tape punch 
	PRINTX	CDPSPL	for card punch
	PRINTX	PLTSPL	for plotter
	PRINTX	
	PRINTX	The standard method of generating the spoolers
	PRINTX	 uses a batch control file (SPOOL.CTL) which
	PRINTX	 generates the spoolers. 
	PRINTX	
	PRINTX	There are 2 other files which must be loaded with
	PRINTX	 a spooler. The first is HELPER the 
	PRINTX	 DECsystem-10 help text printer. The other
	PRINTX	 is QUEUER which does a PUSHSEG to
	PRINTX	 the queue manager (QMANGR) to manipulate
	PRINTX	 the master queue.
	PRINTX	
	PRINTX	?SPOOLER GENERATION ABORTED

	LOC	137
	PASS2
	CALLI	12
	END	137>
	PURGE	K
SUBTTL	SYMBOLS

	IF1	<

;ACCUMULATORS
 S=:0			;STATUS FLAGS
T1=:1			;FIRST OF 5 CONSECUTIVE TEMPS
T2=:2			;SECOND   "      "        "
T3=:3			;THIRD    "      "        "
T4=:4			;FOURTH   "      "        "
T5=:5			;FIFTH    "      "        "
P1=:6			;PRESERVED AC'S - THESE CONSECUTIVE
P2=:7			; ACCUMULATORS ARE PRESERVED ACCROSS
P3=:10			; SUBROUTINE CALLS UNLESS A RESULT IS
P4=:11			; RETURNED IN THE AC. IN THAT CASE THE
P5=:12			; CALLER KNOWS THE AC IS USED.
 C=:13			;HOLDS A CHAR - ALMOST NEVER PRESERVED
 N=:14			;HOLDS A NUMBER - SIMILAR TO C
CA=:15			;FREE AC LEFT TO CUSTOMER
QP=:16			;POINTER TO CURRENT QUEUE ENTRY
 P=:17			;PUSH DOWN POINTER

;INPUT-OUTPUT CHANNELS

SEGCHN==0		;CLEARED BY GETSEG
DSK==1			;SPOOLED DATA ON DISK
LOGF==2			;LOG FILE ON DISK
LPT==3			;OUTPUT DEVICE
PTP==3			; ALL FOUR SYMBOLS MUST
PLT==3			; HAVE THE SAME CHANNEL
CDP==3			; NUMBER
TTY==4			;OPERATORS TTY
ALPCHN==5		;FOR ALIGN COMMAND
QUECHN==6		;USED TO READ @ QUEUE FILES
CRECHN==17		;USED BY QMANGR.SHR FOR CREATE

;STILL IN IF1

;GETTAB ADDRESSES

CNFTBL==XWD	11,23	;ADDRESS OF CONFIG TABLE
CONFI1==XWD	00,11	;SYSTEM NAME IN ASCIZ
CONFI2==XWD	01,11	; FOR HEADERS AND
CONFI3==XWD	02,11	; AND TRAILERS
CONFI4==XWD	03,11	
CONFI5==XWD	04,11
JBTDEV==XWD	00,24	;DEVICE WHICH STARTED THIS HISEG
JBTSGN==XWD	00,14	;HI-SEG # FOR THIS JOB
JBTNAM==XWD	00,03	;HI-SEG NAME
JBTPPN==XWD	00,02	;DIRECTORY OF THIS HISEG
TTIME==XWD	00,04	;TOTAL RUN TIME
JBTKCT==XWD	00,05	;KCS
JBTRCT==XWD	00,17	;BLOCKS READ
JBTWCT==XWD	00,20	;BLOCKS WRITTEN
JBTLOC==XWD	00,26	;LOCATION OF SPOOLER
SERIAL==XWD	20,11	;SERIAL NUMBER OF APR
STATES==XWD	17,11	;STATE OF SYSTEM
STNPRT==XWD	12,16	;STANDARD PROTECTION
UPTIME==XWD	15,12	;UPTIME IN JIFFIES
QUEPPN==XWD	04,16	;UFD OF RENAMED DATA

;DATA MODES

A==0			;ASCII
AL==1			;ASCII LINE
I==10			;IMAGE MODE
IB==13			;IMAGE BINARY
B==14			;BINARY
DR==16			;DUMP BY RECORD


;DAEMON FUNCTIONS

.FACT==3		;WRITE INTO FACT.SYS

>	;END IF1
SUBTTL	MACROS

	IF1	<
; STORAGE ALLOCATION MACROS

DEFINE	V(VAR,USER)<
	.XCREF			;;TURN OFF CREF INSIDE MACRO
	BLK	VAR,1,USER,	;;CALL BLOCK MACRO
	>



DEFINE	BLK(VAR,SIZE,USER),<	;;DEFINE CORE IF REQUIRED
	.XCREF			;;TURN OFF CREF INSIDE MACRO
	%F=0			;;FLAG USED TO EXPAND ONLY 1
				;;OF THE FOLLOWING
IFB <USER>,<%F=1		;;IF EVERYBOBY WANTS IT
	BLK2	VAR,SIZE	;;GENERATE FOR ALL
	>
IFE	%F,<			;;IF NOTHING DONE YET
	IRPC	USER,<		;;TRY EACH USER
IFN	LPTSPL,<		;;ARE WE DOING THE LPT
IFIDN	<USER><L>,<BLK2 VAR,SIZE>>
IFN	PTPSPL,<		;;ARE WE DOING THE PTP
IFIDN	<USER><T>,<BLK2 VAR,SIZE>>
IFN	PLTSPL,<		;;ARE WE DOING THE PLT
IFIDN	<USER><P>,<BLK2 VAR,SIZE>>
IFN	CDPSPL,<
IFIDN	<USER><C>,<BLK2 VAR,SIZE>>>>
	PURGE	%F		;;NO LONGER NEEDED>


DEFINE	BLK2(VAR,SIZE)<
	.CREF			;;TURN CREF BACK ON
VAR::	BLOCK	SIZE>		;;DATA AREA

;MACRO TO ASSIGN BITS WITHIN A WORD (NOTE: BIT 0 = 400000 000000)

DEFINE	BIT(AC,SYMBOL)<
	IF1,<			;;DO NOT REDEFINE IN PASS2
	IFDEF AC'..<		;;SET UP COUNTER
	AC'..==AC'.._<-1>	;;AND MOVE TO NEXT BIT
	>
	IFNDEF AC'..<		;;ON FIRST CALL
	AC'..==1B0>		;;GIVE AWAY FIRST BIT
	SYMBOL==AC'..		;;DEFINITION OF SYMBOL
	IFE	AC'..,<		;;NO MORE ROOM
	PRINTX	? AC IS FULL
	>>>

;STILL IN IF1
;FREQUENTLY USED INSTRUCTIONS SEQUENCES

DEFINE	ACTCHR	(CH,A)<
	CAIN	C,"CH"			;;IS THIS A CH
IFE	CNTRL,<XLIST>
	JRST	A			;YES
IFE	CNTRL,<LIST>
	>


;MEMORY-MEMORY MOVE INSTRUCTION

DEFINE	XFR(FROM,TO)<
	MOVE	T1,FROM		;;T1 MEETS A BAD FATE
IFE	CNTRL,<XLIST>
	MOVEM	T1,TO		;;WHICH MUST BE KEPT IN MIND
IFE	CNTRL,<LIST>>


IFE ONESEG,<

;RELOC TO HISEG

DEFINE	TOPSEG,<
	IFE	SEG,<
IFE	CNTRL,<XLIST>
	LIT
	SEG==-1
	RELOC>
IFE	CNTRL,<LIST>>

;RELOC TO LOWSEG

DEFINE	LOWSEG,<
	IFN	SEG,<
IFE	CNTRL,<XLIST>
	LIT
IFE	CNTRL,<LIST>
	RELOC>
	SEG==0>

>; END OF IFE ONESEG CONDITIONAL

IFN ONESEG,<
DEFINE TOPSEG,<>
DEFINE LOWSEG,<>
>

;STILL IN IF1
;BIT TESTING MACROS
DEFINE OP(AC,FLAG,L,R)<		;;TESTING MACRO
	.XCREF			;;TURN OFF CREF INSIDE MACRO
	IFN	BDWAY,<		;;IF WE ARE DEBUGGING LOOK
	PUSHJ	P,[LIGHTS S,	;;AT THE LIGHTS>
	IFG	<FLAG-777777>,<;;IN LEFT HALF?
	.CREF			;;TURN THE CREF BACK ON
	L	AC,(FLAG)>	;;TEST LEFT
	.XCREF			;;TURN OFF CREF INSIDE MACRO
	IFL	<FLAG-777777>,<;;IN RIGHT HALF
	.CREF			;;TURN THE CREF BACK ON
	R	AC,FLAG>	;;TEST RIGHT
	.XCREF			;;TURN OFF CREF INSIDE MACRO
	IFN	BDWAY,<		;;NOE WE HAVE SET THE FLAG
	POPJ	P,		;;NORMAL RETURN
	JRST	CPOPJ1]>	;;SKIP RETURN
	.CREF>			;;TURN CREFING BACK ON


DEFINE ON(AC,FLAG),< OP AC,FLAG,TLO,TRO>

DEFINE OFF(AC,FLAG),< OP AC,FLAG,TLZ,TRZ> ;TURN OFF A FLAG


DEFINE IFON(AC,FLAG,WHERE),< 
	.XCREF			;;TURN OFF CREF INSIDE MACRO
	IFB	<WHERE>,<
	OP	AC,FLAG,TLNE,TRNE>
	IFNB	<WHERE>,<
	YY..==400000000000&FLAG
	IFN	YY..,<
	.CREF			;;TURN THE CREF BACK ON
	JUMPL	AC,WHERE>
	.XCREF			;;TURN OFF CREF INSIDE MACRO
	IFE	YY..,<
	OP	AC,FLAG,TLNE,TRNE
	IFNB	<WHERE>,	;;ADDRESS SPECIFIED
	<			;;TURN OFF LIST
IFE	CNTRL,<XLIST>		;;UNLESS WIERD LISTING FORMAT
	.CREF			;;TURN THE CREF BACK ON
	JRST	WHERE		;;GO TO WHERE.
	PURGE	YY..>>
IFE CNTRL,<LIST>>
	.CREF			;;TURN THE CREF BACK ON
>

;STILL IN IF1
DEFINE	IFOFF(AC,FLAG,WHERE),< 
	.XCREF			;;TURN OFF CREF INSIDE MACRO
	IFB	<WHERE>,<
	OP	AC,FLAG,TLNN,TRNN>
	IFNB	<WHERE>,<
	YY..==400000000000&FLAG
	IFN	YY..,<
	.CREF			;;TURN THE CREF BACK ON
	JUMPGE	AC,WHERE>
	.XCREF			;;TURN OFF CREF INSIDE MACRO
	IFE	YY..,<
	OP	AC,FLAG,TLNN,TRNN
	IFNB	<WHERE>,	;;ADDRESS SPECIFIED?
	<
IFE	CNTRL,<XLIST>
	.CREF			;;TURN THE CREF BACK ON
	JRST	WHERE
	.XCREF			;;TURN OFF CREF INSIDE MACRO
	PURGE	YY..>>
IFE CNTRL,<LIST>>
	.CREF			;;TURN THE CREF BACK ON
>
;OPDEFS

	OPDEF	TELL	[1B8]		;TELL SOMEONE
	OPDEF	PJRST	[JRST]		;TO CLARIFY DOCUMENTATION
	OPDEF	STOPCD	[HALT]		;ERROR STOPS
	OPDEF	HIBER	[CALLI 72]	;HIBERNATE UUO
	OPDEF	ACCESS	[CALLI 100]	;ACCESS ALLOWED UUO AS DEFINED
					; IN BATMON.RNO%005
	OPDEF	DAEMON	[CALLI 102]	;POKE THE DAEMON
	OPDEF	PATH.	[CALLI 110]	;RETURN A PATH


;STILL IN IF1
>SUBTTL BIT DEFINITIONS
	IF1	<

;STATUS REGISTER

	BIT	S,RUNB,		;ON IF I/O IN PROGRESS TO OUTDEV
	BIT	S,TELOPR,	;PRINT ON OPERATORS TTY (SET BY TELL)
	BIT	S,TELLOG,	;PLACE IN LOG (SET BY TELL)
	BIT	S,TERR,		;ERROR MESSAGE (SET BY TELL)
	BIT	S,TELUSR,	;SENT DIRECTLY TO OUDEV(SET BY TELL)
;******* DO NOT MOVE BITS DEFINED ABOVE THIS LINE *******
	BIT	S,PAUSEB,	;PAUSE AT EOJ
	BIT	S,TNOACT,	;NO ACTION CHARACTERS
	BIT	S,EXTFLG,	;EXTENSION COMMING (FILSPC)
	BIT	S,OPENB,	;START COMMAND GIVEN, OUTPUT OPEN
	BIT	S,ARROW,	;ARROW MODE IN EFFECT
	BIT	S,SUPRES,	;NO USER FORM CONTROL
	BIT	S,SCLN,		; ";" SEEN (TYI) ALSO SET BY REQUEUE
	BIT	S,SPAC,		; " " SEEN (TYI)
	BIT	S,SOME,		;SOMETHING HAS BEEN STORED (TYI)
	BIT	S,QDIR,		;FILE IS IN QUEUE DIRECTORY
	BIT	S,SLOGB,	;LOG THIS COMMAND (COMIN)
	BIT	S,DSKOPN,	;DISK DATA READ GOING ON
	BIT	S,RQB,		;QUEUE ENTRY HAS BEEN DELETED
	BIT	S,STAMPB,	;=1 IF TIME STAMP IN LOG
	BIT	S,SUPJOB,	;SUPPRESS /JOB
	BIT	S,NOTYPE,	; CNTRL O THE OUTPUT DEVICE
	BIT	S,IHGTLP,	;I HAVE GOT THE LINE PRINTER
	BIT	S,LFSEEN,	;LINE FEED SEEN (LPTOUT) OR NULL(OUTPIC)
	BIT	S,PLOCK,	;DO NOT CLEAR THE PAUSE BIT
	BIT	S,FFSEEN,	;FORM FEED SEEN (LPTOUT)
	BIT	S,DAT,		;FILE IS FORTRAN OUTPUT
	BIT	S,NOCLOS,	;INHIBIT TTY CLOSE ON TELL UUO
	BIT	S,ABORT,	;THE SHIP IS SINKING
	BIT	S,FCONV,	;THE NEXT CHAR IS FORTRAN FORMAT DATA.
	BIT	S,LPODD,	;TOTAL # OF PAGES PRINTED MOD 2
	BIT	S,SFDMON,	;THIS IS 5.04 OR LATER
	BIT	S,USEFUL,	;SOME OUTPUT WAS GENERATED THIS PASS
	BIT	S,NEWLIN,	;FLAG FOR THE BEGINING OF LINE
	BIT	S,ANYCHR,	;CARD IS NON-BLANK IN CDPSPL
	BIT	S,MNTBIT,	;REQUEST FOR FORMS TO BE MOUNTED
	BIT	S,ISCDP,	;DEVICE IS REAL CDP (CDPSPL)

;INITIAL SETTING OF STATUS REGISTER
INITS==0
;BITS TO CLEAR WHEN IDLE
IDLZ==ARROW!SUPRES!QDIR!DAT!SOME!SPAC!SCLN
;BITS TO CLEAR WHEN ACTIVE
ACTVZ==SUPJOB!SUPRES!TELUSR!ABORT!TNOACT!LPODD
;BITS TO SET WHEN A NEW ENTRY IS FOUND
ACTVO==RUNB!FFSEEN!FCONV!NEWLIN
;STILL IN IF1

;AC FIELD OF TELL UUO


OPR==10				;SEND TO OPERATOR
LOG==4				;SEND TO LOG
ERR==2				;ERROR MESSAGE
USR==1				;ALSO PUT ON USER DEVICE

;DEVCHR BITS

DEVLPT==40000			;DEVICE IS AN LPT
DEVTTY==20010			;TTY ATTACHED TO A JOB
DEVLNG==1000			;LONG DISPATCH TABLE
DEVPTP==400			;PAPER TAPE PUNCH
DEVAVL==40			;DEVICE IS FREE FOR THIS JOB
DEVDIR==4			;DEVICE HAS A DIRECTORY

;BIT POSITION (FOR BYTE POINTERS)

SFRLOC==4			;LOCATION OF TELL BITS IN S
SFSBIT==4			;NUMBER OF TELL BITS
UURLOC==14			;LOCATION OF AC IN UUO
UUSBIT==4			;NUMBER OF BITS IN AC FIELD



;LOCATIONS IN .JBDAT

	EXTERN	.JBUUO,.JB41,.JBERR,.JBREL,.JBDDT,.JBHRL,.JBSYM,.JBINT
	EXTERN	.JBSA,.JBFF,.JBREN,.JBAPR,.JBCNI,.JBTPC,.JBVER


;STILL IN IF1
>SUBTTL EXTENDED UUO ARGUMENTS FOR DECsystem-10
	IF1	<
.RBPPN==1	;PROJECT PROGRAMMER NUMBER
.RBNAM==2	;FILE NAME
.RBEXT==3	;FILE EXTENSION AND ACCESS DATE
.RBPRV==4	;PRIVILEDGE BITS
		;MODE
		;CREATION TIME
		;CREATION DATE
.RBSIZ==5	;FILE SIZE IN +NO WORDS
.RBVER==6	;VERSION NUMBER
.RBSPL==7	;NAME ENTERED FOR SPOOLED FILE
.RBEST==10	;ESTIMATED LENGTH OF FILE
.RBALC==11	;HIGHEST BLOCK ALLOCATED IN FILE
		;ON ENTER RESERVE THIS MANY BLOCKS
.RBPOS==12	;LOGIGAL BLOCK NUMBER  OF FIRST BLOCK
		;TO ALLOCATE WITHIN F.S.
.RBFT1==13	;RESERVED FOR DIGITAL
.RBNCA==14	;RESERVED FOR CUSTOMER
.RBMTA==15	;TAPE LABLE OF FAILSAFE TAPE WITH THIS FILE
.RBDEV==16	;FILE STRUCTURE ON WHICH THIS FILE LIVES
.RBSTS==17	;FILE STATUS BITS
.RBELB==20	;BAD LOGICAL BLOCK WITHIN FILE
.RBEUN==21	;NUMBER OF BAD BLOCKS
.RBQTF==22	;(UFD ONLY) FCFS LOGGED IN QUOTA
.RBQTO==23	;(UFD ONLY) LOGGED OUT QUOTA
.RBQTR==24	;(UFD ONLY) RESERVED QUOTA
.RBUSD==25	;(UFD ONLY) NO OF BLOCKS IN USE AT LAST LOGOUT
.RBAUT==26	;PPN OF AUTHOR OF FILE
.RBNXT==27	;NEXT FILE STRUCTURE IF FILE IS CONTINUED
.RBPRD==30	;PREVIOUS FILE STRUCTURE
.RBPCA==31	;RESERVED FOR CUSTOMER (MAY NOT BE SET BY ENTER)
.RBUFD==32	;BLOCK NUMBER OF UFD WITHIN F.S.

	ASUPPRESS

	>	;END OF IF1 CONDITIONAL
RBPPN=UUOBLK+1	;PROJECT PROGRAMMER NUMBER
RBNAM=UUOBLK+2	;FILE NAME
RBEXT=UUOBLK+3	;FILE EXTENSION AND ACCESS DATE
RBPRV=UUOBLK+4	;PRIVILEDGE BITS
		;MODE
		;CREATION TIME
		;CREATION DATE
RBSIZ=UUOBLK+5	;FILE SIZE IN +N WORDS
RBVER=UUOBLK+6	;VERSION NUMBER
RBSPL=UUOBLK+7	;NAME ENTERED ON A SPOOLED FILE
RBEST=UUOBLK+10	;ESTIMATED LENGTH OF FILE
RBALC=UUOBLK+11	;HIGHEST BLOCK ALLOCATED IN FILE
		;ON ENTER RESERVE THIS MANY BLOCKS
RBPOS=UUOBLK+12	;LOGIGAL BLOCK NUMBER  OF FIRST BLOCK
		;TO ALLOCATE WITHIN F.S.
RBFT1=UUOBLK+13	;RESERVED FOR DIGITAL
RBNCA=UUOBLK+14	;RESERVED FOR CUSTOMER
RBMTA=UUOBLK+15	;TAPE LABLE OF FAILSAFE TAPE WITH THIS FILE
RBDEV=UUOBLK+16	;FILE STRUCTURE ON WHICH THIS FILE LIVES
RBSTS=UUOBLK+17	;FILE STATUS BITS
RBELB=UUOBLK+20	;BAD LOGICAL BLOCK WITHIN FILE
RBEUN=UUOBLK+21	;NUMBER OF BAD BLOCKS
RBQTF=UUOBLK+22	;(UFD ONLY) FCFS LOGGED IN QUOTA
RBQTO=UUOBLK+23	;(UFD ONLY) LOGGED OUT QUOTA
RBQTR=UUOBLK+24	;(UFD ONLY) RESERVED QUOTA
RBUSD=UUOBLK+25	;(UFD ONLY) NO OF BLOCKS IN USE AT LAST LOGOUT
RBAUT=UUOBLK+26	;PPN OF AUTHOR OF FILE
RBNXT=UUOBLK+27	;NEXT FILE STRUCTURE IF FILE IS CONTINUED
RBPRD=UUOBLK+30	;PREVIOUS FILE STRUCTURE
RBPCA=UUOBLK+31	;RESERVED FOR CUSTOMER (MAY NOT BE SET BY ENTER)
RBUFD=UUOBLK+32	;BLOCK NUMBER OF UFD WITHIN F.S.

IFN OLDMON,<
RBNAM=UUOBLK
RBEXT=UUOBLK+1
RBPRV=UUOBLK+2
RBPPN=UUOBLK+3
RBSIZ=RBPPN>


;FUNCTION CODES USED IN ACCESS UUO
	FNCRNM==0	;RENAME TO ZERO
	FNCRED==5	;READ A FILE

PAC:	POINT	UUSBIT,.JBUUO,UURLOC	;POINTER TO AC IN LUUO
PS:	POINT	SFSBIT,S,SFRLOC		;SAME FIELD IN S
	LOWSEG
SUBTTL	DATA CONTROL BLOCKS

;DISK FILE CONTROL BLOCK

	LOWEST=DFBHD			;FIRST LOCATION TO CLEAR
	V	DFBHD,,			;BUFFER HEADER
	V	DFBPT,,			;BYTE POINTER
	V	DFCNT,,			;BYTE COUNT
	V	DFNAME,,		;FILE NAME
	V	DFEXT,,			;FILE EXTENSION
	BLK	DFPTH,2			;STR NAME AND SCAN SWITCLK	DFDIR,7			;FILE'S PATH
	BLK	DFUSR,2			;USERS ACCT #
	V	DFECT,,			;ERROR COUNT
	V	DFSTR,,			;CURRENT FILE STRUCTURE
	BLK	DFBUF,203*DSKBN		;DISK INPUT BUFFERS
	BLK	UUOBLK,MAXUUO+1		;USED FOR LONG UUO'S
	V	DFQUE,,			;UFD OF RENAMED DATA
	V	DFDOT,,			;PLACE WITHIN FILE

;LOG FILE CONTROL BLOCK

	V	LOGBPT,,		;LOG FILE BYTE POINTER
	V	LOGCNT,,		;LOG BYTE COUNT
	BLK	LOGBUF,23		;TEMP FOR OPR TYPE-IN
	BLK	LOGOBF,200		;DUMP MODE OUTPUT BUFFER
	BLK	LOGSAV,10		;SAVE FULL PATH NAME HERE
;LINE PRINTER CONTROL BLOCK

	V	LPBHD,L,	;LINE PRINTER BUFFER HEADER
	V	LPBPT,L,	;BYPE POINTER
	V	LPCNT,L,	;BYTE COUNT
	V	LPQTA,L,	;OUTPUT QUOTA
	V	LPLOP,L,	;LOCATION ON PAGE
	V	LPLPP,L,	;LINES PER PAGE FOR THIS
				; TYPE OF FORM
	V	ALBHD,L,	;BUFFER HEADER FOR ALIGN
	V	ALBPT,L,	;BYTE POINTER
	V	ALCNT,L,	;BYTE COUNT
	V	LPTEMP,,	;TEMP FOR FORWAR AND BACKSPACE
	V	LPSTAT,,	;OUTPUT DEVICE STATUS
	V	LPDEV,,		;OUTPUT DEVICE
	V	LPNAM,,		;OUTPUT NAME
	V	LPEXT,,		;OUTPUT EXT
	V	LPPPN,,		;OUTPUT DIR
	V	LPJFF,,		;SAVE .JBFF AROUND INITS
	V	LPSIZ,,		;SIZE OF AN EMPTY BUFFER
	IFN	RPW,<		;IF WE SUPPORT /REPORT
	BLK	ISLIN,^D49,L,	; WE COMPILE A ROUTINE HERE.
>
	BLK	LPBUF,45,L,	;PLACE TO BUILD HEADERS
	BLK	LPCNF,5,L,	;CONFIG (VIA GETTAB)

	IFN	LPTSPL,<
	DVBHD==LPBHD
	DVQTA==LPQTA>

;CARD PUNCH CONTROL BLOCK

	V	CDBHD,C,	;BUFFER HEADER
	V	CDBPT,C,	;BYTE POINTER
	V	CDCNT,C,	;COUNT
	V	CDQTA,C,	;QUOTA
	BLK	CDPOUT,200,C,	;CODE IS BLT'ED INTO HERE

	IFN	CDPSPL,<
	DVBHD==CDBHD
	DVFCT==CPC
	DVQTA==CDQTA>


;PAPER TAPE PUNCH CONTROL BLOCK

	V	PTBHD,T,	;BUFFER HEADER
	V	PTBPT,T,	;BYTE POINTER
	V	PTCNT,T,	;COUNT
	V	PTQTA,T,	;QUOTA
	V	PTEMP,T,	;USED FOR FORWAR AND BACK
	BLK	PTPOUT,55,T,	;CODE IS BLT'ED INTO HERE

	IFN	PTPSPL,<
	DVBHD==PTBHD
	DVFCT==CPF
	DVQTA==PTQTA>
;PLOTTER CONTROL BLOCK

	V	PLBHD,P,		;BUFFER HEADER
	V	PLBPT,P,		;BYTE POINTER
	V	PLCNT,P,		;BYTE COUNT
	V	PLQTA,P,		;NUMBER OF MIN LEFT BEFORE
					; QUOTA IS UP. USED TO FAKE
					; OUT MOST ROUTINES
	V	PLIMIT,P,		;TIME OF DAY (IN UPTIME) TO
					; ABORT JOB.

	IFN	PLTSPL,<
	DVBHD==PLBHD
	DVFCT==1
	BACKSP==CPOPJ
	FORWAR==CPOPJ
	DVQTA==PLQTA>

;OPERATOR CONTROL BLOCK

	V	TTBHD,,		;TTY BUFFER HEADER
	V	TTBPT,,		;TTY BYTE COUNT
	V	TTCNT,,		;TTY BYTE COUNT

;RANDOM LOCATIONS TO CLEAR

	V	NXTJOB,,	;NEXT JOB TO RUN
	V	CHKTIM,,	;TIME TILL NEXT CHKPNT
	V	FORMS,,		;FORM TYPE
	V	FAIRCT,,	;FAIRNESS COUNT
	V	BP,,		;POINTER TO TEMP BUFFER FOR LOG
	V	OLDCOR,,	;WHAT TO RESET .JBFF TO AFTER READING
				; INDIRECT FILE INTO CORE
	BLK	INTLOC,4,	;.JBINT BLOCK
	V	RQFBIT,,	;TEMP FOR CHKPNT
	V	OLDSEG,,	;NON ZERO IF NEED HISEG

;RANDOM LOCATIONS NOT CLEARED

	HIEST==.
	V	SAVCHR,,	;PLACE TO SAVE 1 CHAR
	BLK	SEGBLK,6	;SPACE FOR GETSEGS
	BLK	PDL,PDSIZE,,	;PUSH DOWN STACK
MLIM:	+MAXLIM			;BIGGEST JOB THAT WILL BE RUN
MCKPNT:	+MINPCK*^D60*JIFSEC	;MIN. PER CHKPNT
EMSGLV:	+INIE			;ERROR MSGLVL
CMSGLV:	+INIC			;CHATTY MSGLVL
LMSGLV:	+INIL			;INITIAL LENGTH
LGIOWD:	IOWD	200,LOGOBF
	Z
SPCCNT:	0
HNGCNT:	-1			;NUMBER OF DEVICE OK'S

	IFN	PTPSPL,<
	IFN	FTELF,<
;THE WORD ELFCH IS USED TO STORE WORDS FOR THE /ELEVEN PROCESSING
;THE BYTE POINTERS FOLLOWING IT AREPUSED TO EXTRACT 4 BYTES
;FROM ELFCH, IN THE COMMENTS A IS THE ORDER IN WHICH THE BYTES ARE
;SELECTED AND POS IS THE BIT POSITION IN THE WORD IN DECIMAL
	V	ELFCH,T,	;HOLDS THE WORD
ELFPTR:	101000,,ELFCH		;A=4 POS=<20,27>
	001000,,ELFCH		;A=3 POS=<28,35>
	321000,,ELFCH		;A=2 POS=<2,9>
	221000,,ELFCH		;A=1 POS=<10,17>
	ELEVEN==6
> ;END TEST ON FTELF
> ;END TEST ON PTPSPL


;FACT FILE ENTRY

	IFN	FACTSW,<
FACT:	EXP	.FACT		;DAEMON FUNCTION
F.HEAD:	XWD	250000,13	;TYPE 250 - 13 WORDS
F.PPN:	0			;PPN OF USER
F.DATE:	0			;DATE AND TIME (FILLED IN BY DAEMON)
F.QUE:	0			;0-11 QUEUE NAME IN SIXBIT
				;12-17 STATION NUMBER
				;18-35 APR SERIAL NUMBER (MASTER IF 2 OR MORE)
F.TIME:	0			;RUN TIME USED BY SPOOLER
F.KCS:	0			;KCS USED BY SPOOLER
F.RCT:	0			;DISK READS
F.WCT:	0			;DISK WRITES
F.DEV:	0			;PHYSICAL DEVICE GETTING SPOOLED
F.SEQ:	0			;SEQUENCE NUMBER OF THE JOB
F.UNIT:	0			;QUANTITY OF OUTPUT IN PROPER UNITS
F.SIZE==.-FACT			;SIZE OF BLOCK>
SUBTTL	QUEUE PARAMETER AREA

;SYMBOLS IN PARENS () ARE BYTE POINTERS TO SELECTED FIELDS

Q.BLK::	Z		;TEMP USED BY QMANGR.SHR
Q.OPR::	0		;0-17 ADDRESS OF SCHEDULER
			;18-23 N/A
			;24-29 REQUESTING CUSP (P.RCP)
	QUSRCP==6	;SIZE OF BYTE
	QURRCP==^D29	;LOCATION OF BYTE

	PRINTR==4	;PRINT REQUEST
	PUNCHR==5	;CARD PUNCH REQUEST
	TAPER==6	;TAPE PUNCH REQUEST
	PLOTR==7	;PLOT REQUEST
			;30-35 REQUESTED OPERATION (P.ROP)

	QUSROP==6	;SIZE OF BYTE
	QURROP==^D35	;LOCATION OF BYTE

	O.CRE==1	;CREATE
	O.DFR==2	;DEFER
	O.ZDF==3	;ZDEFER
	O.LST==4	;LIST
	O.MOD==5	;MODIFY
	O.KIL==6	;KILL
	O.SCH==7	;SCHEDULE
	O.REL==10	;RELEASE
	O.REQ==11	;REQUEUE
	O.FLST==12	;FAST LIST OPTION
	O.CHK==13	;REQUEUE W/O RELEASE
Q.LEN::	0		;0-8 LENGTH OF HEADER FOR QUEUE REQUEST (P.LOH)

	QUSLOH==^D9	;SIZE OF BYTE
	QURLOH==^D8	;POSITION OF BYTE

			;9-17 LENGTH OF EACH FILE IN THIS QUEUE REQUEST(P.LOE)

	QUSLOE==^D9	;SIZE OF BYTE
	QURLOE==^D17	;POSITION OF BYTE

			;18-35 NUMBER OF FILES IN THIS REQUEST
Q.DEV::	0		;DESTINATION DEVICE
Q.PPN::	0		;PROJECT, PROGRAMMER # OF AUTHOR [DFUSR]
Q.JOB::	0		;JOB NAME
Q.SEQ::	0		;JOB SEQUENCE NUMBER
Q.PRI::	0		;0-17 RESERVED TO CUSTOMER
			;18-29 RESERVED TO DIGITAL (NOT POINTED TO)
			;30-35 EXTERNAL PRIORITY (P.EPR)

	QUSEPR==6	;SIZE OF BYTE
	QUREPR==^D35	;POSITION OF BYTE

Q.PDEV::0		;NAME OF DEVICE PROCESSING REQUEST
Q.TIME::0		;START TIME WHEN JOB SCHEDULED
Q.CREA::0		;TIME REQUEST WAS CREATED
Q.AFTR::0		; AFTER PARAMETER
Q.DEAD::0		;DEADLINE PARAMETER
Q.CNO::	0		;CHARGE NUMBER
Q.USER::EXP	0,0	;USER NAME

;THE OUTPUT QUEUE REQUEST CONTINUES:

Q.FRM::	0		;FORMS REQUEST (0=SYSTEM STANDARD)
Q.OSIZ::0		;SIZE OF REQUEST
			;0-17 OUTPUT LIMIT IN PROPER UNITS
			;18-35 REQUEST SIZE IN BLOCKS*COPIES
Q.ONOT::0		;ANNOTATION
	0

; OUTPUT FILE THEN HAS THE FOLLOWING ENTRIES:

Q.FSTR==:0		;FILE STRUCTURE
Q.FDIR==1		;ORIGINAL DIRECTORY
Q.FNAM==7		;ORIGINAL NAME
Q.FEXT==10		;ORIGINAL EXTENSION
Q.FRNM==11		;RENAMED NAME
Q.FBIT==12		;0	1 IF QUEUE RENAMED THE PROTECTION FIELD
	QUPSKP==1B1	;SKIP THIS REQUEST (NORMALY SET
			; BY REQUEUE COMMAND)
			;18-35 LINE NUMBER TO START AT
Q.FMOD==13		;0	1 IF REMOVE THIS FILE
	QUPRMV==400000000000	;THE BIT
			;1	1 IF THIS IS A LOG FILE
	QUPLOG==200000000000	;THE BIT
			;5	1 DO NOT PRINT FILE HEADERS
	QUPNFH==1B5		;THE BIT
			;18-20	SPACING CODE (P.SPC)

	QUSSPC==3	;SIZE OF BIT
	QURSPC==^D20	;LOCATION OF BIT
			;21-23	PAPER FORMAT (P.FMT)
	QUSFMT==3
	QURFMT==^D23
		;CODES ARE DEVICE DEPENDANT
			;24-26	FILE FORMAT
	QUSFFT==3
	QURFFT==^D26
			;27-29	FILE DISPOSITION (P.FDSP)
	KEEP==1	;PRESERVE
	DELETE==3	;KILL

	QUSDSP==3
	QURDSP==^D29

			;30-35	NUMBER OF COPIES (P.CPY)

	QUSCPY==6
	QURCPY==^D35

Q.FRPT==14			;2 WORD REPORT KEY
Q.FBLK::BLOCK	NENT*ENTSIZ	;FILE SPECS
Q.END::
QSIZE==.-Q.BLK
Q.LOG::	BLOCK	1		;POINTER TO LOG FILE
;BYTE POINTERS

P.RCP:	POINT	QUSRCP,Q.OPR,QURRCP		;REQUESTING CUSP
P.ROP:	POINT	QUSROP,Q.OPR,QURROP		;REQUESTED OPERATION
P.LOH:	POINT	QUSLOH,Q.LEN,QURLOH		;LENGTH OF HEADER
P.LOE:	POINT	QUSLOE,Q.LEN,QURLOE		;LENGTH OF ENTRY
P.EPR:	POINT	QUSEPR,Q.PRI,QUREPR		;EXTERNAL PRI
P.FMT:	POINT	QUSFMT,Q.FMOD(QP),QURFMT	;PAPER FORMAT
P.FFMT:	POINT	QUSFFT,Q.FMOD(QP),QURFFT	;FILE FORMAT
P.FDSP:	POINT	QUSDSP,Q.FMOD(QP),QURDSP	;DISPOSITION
P.CPY:	POINT	QUSCPY,Q.FMOD(QP),QURCPY	;COPIES
P.SPC:	POINT	QUSSPC,Q.FMOD(QP),QURSPC	;SPACING CODE

C.DAT:	POINT	12,RBPRV,35			;CREATION DATE FOR FILE
C.TIM:	POINT	11,RBPRV,23			;FILE CREATION TIME


P.TCPY:	POINT	6,DFDOT,5			;PLACE TO SAVE COPY NUMBER
SUBTTL	MAIN PROGRAM LOOP

	TOPSEG

;AC USAGE WITHIN MAIN

	ESIZ==P1		;XWD TO INCREMENT QP
	COPY==P2		;NUMBER OF COPIES LEFT TO PRINT
	FILN==P3		;NUMBER OF FILES IN THIS REQUEST

MAIN:	MOVE	T1,[Q.BLK,,Q.BLK+1] ;SET UP BLT POINTER
	SETZM	Q.BLK		;CLEAR THE QUEUE AREA
	BLT	T1,Q.END	;ZAP!! IT IS DONE
	IFOFF	S,IHGTLP,CHKPS	;JUMP IF WE DON'T HAVE THE OUTPUT DEVICE
	MOVE	T1,DVBHD+2	;GET AMOUNT OF ROOM IN BUFFER
	CAME	T1,LPSIZ	;SAME AS AN EMPTY BUFFER?
	OUTPUT	LPT,		;NO--DUMP OUT THE DATA
CHKPS:	IFOFF	S,USEFUL,CHKRN	;DO NOT PAUSE UNLESS ASKED
	IFON	S,PAUSEB	;TIME TO PAUSE
	PUSHJ	P,EOFSTP	;YES--PAUSE NOW
CHKRN:	IFOFF	S,RUNB		;CAN WE RUN?
	PUSHJ	P,GOWAIT	;NO--CAN'T EVEN LIMP
	TDZ	S,[IDLZ!ACTVZ]	;CLEAN UP S
	IFOFF	S,IHGTLP	;DO I OWN A LINE PRINTER?
	PUSHJ	P,GETLP2	;NO--GO GET ONE
	MOVEI	T1,LPT		;T1 _ CHANNEL # OF OUTPUT DEVICE
	DEVCHR	T1,		;GET THE DEVMOD WORD
	TLNE	T1,DEVLPT	;SKIP IF NOT LPT
	OUTPUT	LPT,		;CAUSE LISTING TO COME OUT
	MOVEI	T1,O.SCH	;ASK TO SCHEDULE
	DPB	T1,P.ROP	;STORE THE TYPE OF REQUEST
	PUSHJ	P,Q		;CALL IN THE QUEUE MANAGER
	  JRST	DOFILE		;HE HAS GIVEN ME WORK
	OP	S,USEFUL,TLZN,TRZN ;DO WE NEED A CLOSE?
	JRST	SLP1		;NO--JUST SLEEP
	OUTPUT	LPT,		;FAKE OUT MTASRB (OTHER DEVICES THIS
				; CODE WILL DO NO HARM)
	CLOSE	LPT,		;WRITE 2 END OF FILE MARKS (BACK OVER 1)
	MTAPE	LPT,17		;BACK OVER THE SECOND
	IFN CDPSPL,<
	MOVE	T1,[XXXSPL]
	IFOFF	S,ISCDP		;TELL OPR WE'RE DONE IF NOT PHYS. CDP
	TELL	OPR,[ASCIZ /99% + is idle
/]>
SLP1:	RELEAS	LPT,		; ..
	OFF	S,IHGTLP	;CLEAR I-HAVE-GOT-THE-LINE-PRINTER BIT
	MOVEI	T1,IFC		;RESET THE FAIRNESS COUNT
	MOVEM	T1,FAIRCT	; ..
	PUSHJ	P,WAIT1		;GO TO SLEEP
	PUSHJ	P,CHKOPR	;SEE IF THE OPERATOR WANTS ANYTHING
	JRST	MAIN		;GO BACK AND LOOK FOR MARE
;HERE WITH A RUNNABLE JOB IN THE QUEUE BLOCK
DOFILE:	IFN	FACTSW,<	;;IF WE ARE COUNTING
	HRROI	T1,TTIME	 ;GET THE RUNTIME
	GETTAB	T1,		; FROM THE MONITOR
	  SETZ	T1,		;FAILED!!!
	MOVNM	T1,F.TIME	;-VE TO FACT BLOCK
	HRROI	T1,JBTKCT	 ;GET THE TOTAL KCT'S
	GETTAB	T1,		; FROM THE MONITOR
	  SETZ	T1,		;FAILED!!!
	MOVNM	T1,F.KCS	 ;STORE -VE (SO ADDB WILL CAUSE SUB)
	HRROI	T1,JBTRCT	;BLOCKS READ
	GETTAB	T1,		; FROM THE MONITOR
	  SETZ	T1,		;FAILED!!!
	TLZ	T1,777700	;CLEAR INCR.
	MOVNM	T1,F.RCT	;STORE -VE IN BLOCK
	HRROI	T1,JBTWCT	;DISK WRITES
	GETTAB	T1,		 ;ASK THE MONITOR
	  SETZ	T1,		;EGAD!! MUST BE LEVEL C
	TLZ	T1,777700	;CLEAR INCREMENTAL
	MOVNM	T1,F.WCT	;STORE -VE FOR TESTQ
	MOVE	T1,Q.PPN	;GET PPN
	MOVEM	T1,F.PPN	;STORE FOR FACT FILE
	MOVE	T1,Q.SEQ	;GET SEQUENCE NUMBER
	MOVEM	T1,F.SEQ>	;STORE FOR FACT FILE
	ON	S,USEFUL	;WE WILL PRINT SOMETHING
	TDZ	S,[ACTVZ]	;CLEAR SOME BITS
	SOSGE	T1,FAIRCT	;COUNT DOWN THE FAIRNESS
	MOVEI	T1,IFC		;RESET IF IT GOES -VE
	MOVEM	T1,FAIRCT	;STORE THE UPDATED COUNT
	LDB	QP,P.LOH	;GET SIZE OF HEADER
	ADDI	QP,Q.OPR	;CONVER OFFSET TO ADDRESS
	LDB	ESIZ,P.LOE	;GET THE LENGTH OF EACH ENTRY
	HRRZ	FILN,Q.LEN	;GET THE NUMBER OF FILES
	MOVE	T1,[UPTIME]	;GET THE UPTIME
	GETTAB	T1,		;FROM THE MONITOR
	  SETZ	T1,		;FAILED
	ADD	T1,MCKPNT	;BUMP TO NEXT POINT
	MOVEM	T1,CHKTIM	;STORE FOR LATER
	PUSHJ	P,SETLOG	;SET UP LOG POINTER
M4:	MOVE	T1,Q.FMOD(QP)	;GET THE MOD WORD
	TLNE	T1,(QUPLOG)	;IS IT A LOG?
	MOVEM	QP,Q.LOG	;YES--CAUSE GOOD THINS TO HAPPEN
	JUMPGE	T1,M3		;JUMP UNLESS @ POINTER
	MOVE	T1,Q.FNAM(QP)	;GET THE FILE NAME
	MOVEM	T1,RBNAM	;STORE IN BLOCK
	MOVEM	T1,DFNAME	;STORE IN CASE OF ERROR
	MOVE	T1,Q.FEXT(QP)	;GET THE EXTENSION
	MOVEM	T1,RBEXT	;STORE IN RIB
	MOVEM	T1,DFEXT	;STARE FOR ERROR MESSAGES
	MOVE	T1,Q.FDIR(QP)	;GET THE DIRECTORY
	MOVEM	T1,RBPPN	;STORE FOR LOOKUP
	MOVEM	T1,DFDIR
	IFON	S,SFDMON	;DO WE HAVE SUB FILES
	PUSHJ	P,SFDSET	;YES--DO GOOD THINGS
	MOVEI	T1,17		;GET THE DISK IN MOD 17
	MOVE	T2,Q.FSTR(QP)	;PICK UP THE STRUCTURE
	SETZ	T3,
	OPEN	QUECHN,T1	;FIRE UP THE CHANEL
	  JRST	[MOVE  T1,T2	;COPY STR NAME
		 MOVEI T2,NOSTR	;MESSAGE TO USE
		 JRST  IFAIL]	;BOMB OUT
	LOOKUP	QUECHN,UUOBLK	;FIND THE FILE
	  JRST	[MOVE  N,RBEXT	;GET THE ERROR CODE
		 PUSHJ P,LERCOD
		 JRST  IFAIL1]	;BOMB OUT
	MOVE	T1,.JBFF	;GET TOP OF CORE
	MOVEM	T1,OLDCOR	;SAVE THIS NUMBER
	MOVE	T2,Q.BLK	;PICK UP MEM WORD
	MOVEM	T2,(T1)		;STORE FOR REQUEUE
	MOVEI	T2,1(T1)	;COPY .JBFF
	ADD	T2,RBSIZ	;ADD SIZE OF FILE
	MOVEM	T2,.JBFF	;RESET .JBFF
	CORE	T2,		;FIX USRREL
	  JRST	[MOVEI T2,NOCORE;NO CORE FREE
		 JRST  IFAIL]	;BOMB OUT
	MOVN	T2,RBSIZ	;GET LENGTH
	HRL	T1,T2		;MAKE AN IOWD
	SETZ	T2,		;CAUSE LIST TO END
	INPUT	QUECHN,T1	;READ THE FILE
	RELEAS	QUECHN,		;RETURN THE DDB
	HLRZ	T1,Q.FBIT(QP)	;GET NUMBER OF WORDS TO SKIP
	TRZ	T1,400000	;SHOULD ALREADY BE 0 BUT...
	MOVEI	T1,-1(T1)	;FIX THE BUG IN QMANGR
	LSH	T1,7		;MULTIPLY BY 128
	ADD	T1,Q.FBIT(QP)	;ADD WORDS TO SKIP
	HRRZI	QP,1(T1)	;COPY POINTER IN RIGHT AC
	ADD	QP,OLDCOR	;POINT TO RIGHT SPOT
	JRST	M4		;KEEP LOOKING
IFAIL:	TELL	USR!OPR!LOG!ERR,(T2)
IFAIL1:	HRRZ	T1,Q.LEN	;GET ORGINAL NUMBER OF FILES
	SUBI	T1,1(FILN)	;SUBTRACT OFF THE NUMBER WE READ
	HRRM	T1,Q.LEN	;AND STORE A NUMBER IN REQUEST
	SETZM	OLDCOR		;WE COULD NOT HAVE GOTTEN THE CORE
	JRST	M5		;DONE..(EXCEPT FOR INDIRECT)
M3:	ADD	QP,ESIZ		;POINT TO NEXT ENTRY
	SOJG	FILN,M4		;LOOP FOR ALL FILES
M5:	LDB	QP,P.LOH	;GET LENGTH OF HEADER
	SKIPN	T1,OLDCOR	;DID WE MOVE THE WORLD?
	MOVEI	T1,Q.BLK	;NO. USE NORMAL AREA
	ADDI	QP,1(T1)	;POINT THE POINTER
	LDB	ESIZ,P.LOE	;GET LENGTH OF ENTRY
	HRRZ	FILN,Q.LEN	;GET NUMBER OF ENTRIES
	MOVE	T1,LPDEV	;GET THE NAME OF THE DEVICE
	TELL	LOG,BEGIN	;NOTE THAT WE HAVE COME.
	HLRZ	T1,Q.OSIZ	;GET QUOTA IN PROPER UNITS
	IFN	LPTSPL,<
	IMUL	T1,LPLPP	;CONVERT TO INTERNAL UNITS
	MOVEM	T1,LPQTA>	;SAVE AS THIS GUYS QUOTA
	IFN	PTPSPL,<
	IMULI	T1,CPF		;CONVERT TO CHARS
	MOVEM	T1,PTQTA>	;SAVE AS OUTPUT QUOTA
	IFN	CDPSPL,<
	IMULI	T1,CPC
	MOVEM	T1,CDQTA>
	XFR	Q.PPN,DFUSR	;SAVE THIS GUYS NAME
	ON	S,MNTBIT	;ALLOW KILL REQUEUE, ETC.
	MOVE	T1,Q.FRM	;GET FORM TYPE
	CAME	T1,FORMS	;SAME TYPE?
	PUSHJ	P,MOUNT		;NO. CAUSE THE CHANGE
	OFF	S,MNTBIT	;CLEAR THE BIT
	IFN	LPTSPL*HLINEN,<	;THE LINE PRINTER HAS
	PUSHJ	P,JOBHDR>	; JOB AND FILE HEADERS
NEXT:	MOVSI	T1,(QUPLOG)	;IF THIS IS A LOG FILE
	MOVSI	T2,(QUPSKP)	;SET UP SKIP BIT
	TDNN	T2,Q.FBIT(QP)	;IF THIS IS A DUMMY REQUEST
	TDNE	T1,Q.FMOD(QP)	; IGNORE IT AND PRINT IT
	JRST	FIXQP		; LAST. IT MAY NOW BE ANYPLACE IN REQUEST
				; NOTE: ONLY QUPLOG BIT WILL CAUSE PRINTING
LOGFIL:	TDO	S,[ACTVO]	;SET THE FLAGS
	XFR	Q.FNAM(QP),DFNAME ;SAVE THE REAL FILE NAME
	XFR	Q.FEXT(QP),DFEXT  ; AND EXTENSION
	XFR	Q.FDIR(QP),DFDIR  ; FOR ERROR MESSAGES
	IFON	S,SFDMON	;DO WE HAVE SUBFILES
	PUSHJ	P,SFDSET	;YES--DO GOOD THINGS
	IFN	LPTSPL,<	;IF THIS IS A LINE PRINTER
	LDB	T2,P.FFMT	;GET THE /FILE: SWITHC
	LDB	T1,P.FMT	;GET THE FILE FORMAT
	CAIE	T2,COBOL	;IS IT COBOL?
	CAIN	T1,3		;IS IT OCTAL?
	SKIPA	T1,[STATUS+B]>	;YES--GET A FULL 36 BITS
	MOVEI	T1,STATUS	;NO--NOT OCTAL OR NOT LPTSPL
	SKIPN	T2,Q.FSTR(QP)	;SAME FILE STR
	MOVSI	T2,'DSK'	;GUARD AGAINST CONKLIN.
	MOVEM	T2,DFSTR	;SAVE FOR MESSAGES
	MOVEI	T3,DFBHD	;BUFFER HEADERS
	PUSH	P,.JBFF		;SAVE .JBFF
	MOVEI	T4,DFBUF	;ADDRESS OF BLOCK
	MOVEM	T4,.JBFF	;STORE IN .JBDAT
	OPEN	DSK,T1		;OPEN THE STR
	  JRST	CNTOPN		;CAN'T DO IT
	INBUF	DSK,DSKBN	;BUILD THE POOL OF BUFFERS
	POP	P,.JBFF		;RESTORE .JBFF
	SKIPN	T1,Q.FDIR(QP)	;PPN SPECIFIED
	MOVE	T1,DFUSR	;NO. USE DEFAULT
	MOVEM	T1,Q.FDIR(QP)	;SAVE FOR LOOKIE
	SKIPN	T1,Q.FRNM(QP)	;RENAMED DATA?
	JRST	NORMDI		;NO. LOOK IN NORMAL DIRECTORY
	MOVEM	T1,RBNAM	;YES. LOOKUP FUNNY NAME
	MOVSI	T1,(SIXBIT /QUD/) ; AND EXT QUD
	MOVEM	T1,RBEXT	; IN UUOBLK
	SETZM	RBPRV
	MOVE	T1,DFQUE	;GET QUEUE DIRECTORY
	MOVEM	T1,RBPPN	;SAVE AS USER PPN
	ON	S,QDIR		;FLAG AS FUNNY FILE
	JRST	LOOKIE		;LOOKUP FILE
NORMDI:	XFR	Q.FNAM(QP),RBNAM;STORE FOR LOOKUP
	XFR	Q.FDIR(QP),RBPPN; ..
	XFR	Q.FEXT(QP),RBEXT; ..
	OFF	S,QDIR		;FLAG AS NORMAL FILE

;HERE TO LOOK UP THE FILE AND SEE IF WE CAN READ
LOOKIE:	IFE	OLDMON,<	;DO THE STUFF FOR LEVEL D
	MOVEI	T1,MAXUUO	;PLACE LENGTH IN
	MOVEM	T1,UUOBLK	; BLOCK>
	IFON	S,SFDMON	;DO WE HAVE SUB-FILES
	PUSHJ	P,SFDSET	;YES--DO ALL GOOD THINGS
	LOOKUP	DSK,UUOBLK	;FIND THE FILE
	  JRST	FNF		;FILE NOT FOUND
	SKIPE	T1,RBSPL	;ANY REAL NAME FOR FILE
	MOVEM	T1,DFNAME	;YES, GIVE TO "DFNAME"
	SKIPE	T1		;REAL FILE NAME?
	SETZM	DFEXT		;NO--BLANK OUT THE .LPT
	IFON	S,ABORT,PUTBAK	;IF WE HAVE KILLED THIS GUY PUT HIS FILE BACK
NEXT1:	PUSHJ	P,SIZE		;GET FILE SIZE
	HLRZ	T2,RBPRV	;LOAD IN THE PRIV BITS
	LSH	T2,-^D9		;RIGHT JUSTIFY
	MOVE	T3,DFDIR	;FILES DIRECTORY
	MOVE	T4,Q.PPN	;USER'S PPN
	MOVEI	T1,T2		;ADDRESS OF BLOCK
	IFN	OLDMON,<	;OPTIONAL CODE TO RESTRICT ACCESS
				; IF YOU RUN A MONITOR PRIOR TO
				; 5.03 YOU MAY WISH TO WRITE YOUR
				; OWN ROUTINE TO DO ALL THE 
				; REQUIRED CHECKING. BUT THIS WILL DO
				; IF  ACCESS UUO IS NOT INSTALED.
	XOR	T3,T4		;SAME GUY?
	JUMPE	T3,ACCOK	;YES--GO DO THE STUFF
	TRNE	T3,-1		;IF INDPPN=0 THIS WILL IGNORE PROJECT
	JRST	FAILP2		;NO--BE AS NARROW MINDED AS PRINTR
	>
	ACCESS	T1,		;CAN WE KILL THIS FILE
	  JRST	ACCOK		;TONY WILL NOT TELL ME
	JUMPE	T1,ACCOK	;YES. IF I CAN DELETE I CAN READ
	LDB	T5,P.FDSP	;GET THE DISP CODE
	CAIE	T5,KEEP		;ONLY COMPLAIN IF NOT KEEP
	TELL	OPR!LOG!ERR,CNTDEL
	MOVEI	T5,KEEP		;CHANGE Q.FDSP TO
	DPB	T5,P.FDSP	;  KEEP SO IT WILL STAY
	HRLI	T2,FNCRED	;CAN WE READ.
	MOVEI	T1,T2		;RESET POINTER
	ACCESS	T1,		;ASK FILSER
	  STOPCD .		;UUO WENT AWAY
	JUMPE	T1,ACCOK	;WE CAN AT LEAST READ
FAILP2:	PUSHJ	P,HEAD		;GIVE A HEADER
	TELL	USR!OPR!LOG!ERR,PRTERR  ;TELL HIM HE LOST
	JRST	FIXQP		;TRY NEXT FILE
ACCOK:	LDB	COPY,P.CPY	;PICK UP COPIES
PUTFIL:	MOVE	T1,Q.JOB	;LOAD THE JOB NAME
	TELL	OPR!LOG,MESS1	;NOTE START OF A FILE
CPYLP:	ON	S,DSKOPN	;DISK I/O ACTIVE
	PUSHJ	P,HEAD		;PUT ON A HEADER
	USETI	DSK,1		;MAKE SURE WE ARE AT THE TOP
	MOVE	T1,DVQTA	;PICK UP QUOTA
	MOVEM	T1,DFDOT	;STORE FOR REQUEUE
	DPB	COPY,P.TCPY	;SAVE FOR REQUEUE
	IFON	S,SUPJOB	;SUPRES /JOB?
	ON	S,SUPRES	;YES.LIGHT A BIT
	MOVEI	T1,MAXERR	;NUMBER OF I/O ERROR BEFORE QUITTING
	MOVEM	T1,DFECT	;STORE IN DFCB
	HRRZ	T2,Q.FBIT(QP)	;# OF LINES TO SKIP
	SOJLE	T2,DOIT		;IF 0 START AT TOP
	XFR	DVQTA,LPTEMP	;SAVE OLD LIMIT
	MOVEM	T2,DVQTA	;FUDGE UP NEW LIMIT
	ON	S,NOTYPE	;MARK THE SKIP IN PROGRESS
DOIT:	PUSHJ	P,FILOUT	;PRINT THE FILE
	OP	S,NOTYPE,TLZN,TRZN ;EOF CAUSED BY FORWARD?
	JRST	PRTAIL		;NO--PRINT TRAILER
	XFR	LPTEMP,DVQTA	;YES--POP QUOTA BACK
PRTAIL:	IFON	S,RQB,TESTQ	;SKIP REST IF REQUEUED
	OFF	S,SUPRES	;CLEAR A BIT
	PUSHJ	P,TAIL		;PUT ON A TRAILER
	OFF	S,DSKOPN	;SPOOLER IDLE
	IFON	S,ABORT,PUTBAK	;DID HE HIT HIS LIMIT?
	SOJG	COPY,CPYLP	;ANY MORE COPIES?
	TELL	OPR!LOG,MESS2	;NOTE END OF FILE
NXTFIL:	SETZB	T2,T3		;SET UP A RENAME BLOCK
	SETZB	T4,T5		; WITH ALL ZEROS
	MOVSI	T4,(QUPSKP)	;LOAD THE SKIP BIT
	LDB	T1,P.FDSP	;LOAD THE DISP CODE
	CAIE	T1,DELETE	;SHOULD THE FILE GO AWAY
	IFON	S,QDIR		; OR IS IT RENAMED
	JRST	KILFIL		;YES. DO THE FILE IN
	JUMPE	T1,FIXQP	;PROTECT THE IGNORANT
	SKIPL	Q.FBIT(QP)	;WAS FILE PRESERVED BY QUEUE?
	JRST	FIXQP		;NO. LEAVE ALONE
UNPRES:	MOVE	T2,Q.FNAM(QP)	;FILE NAME
	MOVE	T3,Q.FEXT(QP)	;FILE EXT
	MOVE	T4,[STNPRT]	;STANDARD PROTECTION
	GETTAB	T4,		;GET FROM MONITOR
	  MOVSI	T4,055000	;LEVEL C STANDARD
	MOVE	T5,Q.FDIR(QP)	;DIRECTORY
	IFON	S,SFDMON	;DO WE HAVE SUBFILES
	MOVEI	T5,0		;YES--SET UP POINTER TO PATH
KILFIL:	IFN	OLDMON,<
	CLOSE	DSK,0		;CLOSE FOR LEVEL C>
	SKIPN	T2		;DELETE???
	IORM	T4,Q.FBIT(QP)	;YES--DO RETRY ON REQUEUE
	RENAME	DSK,T2		;AND RENAME
	  JRST	FNF2		;ERROR
	CAMN	QP,Q.LOG	;IS THIS THE LOG?
	SETZM	Q.LOG		;YES--THE LOG IS NOW GONE
FIXQP:	CLOSE	DSK,100		;ASK FILSER TO
	RELEAS	DSK,		;GIVE UP A.T.
	IFON	S,RQB		;QUEUE ENTRY GONE?
	JRST	FIXQP2		;YES--PUNT NOW
	ADD	QP,ESIZ		;POINT TO NEXT FILE
	SOJG	FILN,NEXT	;DO NEXT FILE
FIXQP2:	JUMPL	FILN,TESTQ	;DO NOT LOOP
	OFF	S,SUPJOB	;CLEAR A BIT
	PUSHJ	P,FINLOG	;OUTPUT PARTIAL BLOCK
	IFN	LPTSPL,<
	MOVE	QP,Q.LOG	;LOAD UP LOG POINTER
	JUMPE	QP,TESTQ	;JUMP IF NO LOG
	SETZM	Q.LOG		;ELSE CAUSE ONLY 1 LOG
	OFF	S,ABORT		;ALLOW PRINTING
	JRST	LOGFIL		;AND PRINT THE LOG
>	;END TEST OF LPTSPL
TESTQ:	IFN	FACTSW,<	;IF WE ARE COUNTING
	SOSLE	FACTFL		;TIME TO TRY AGAIN (OR WE BELIEVE DAEMON EXISTS)
	JRST	NOACCT		;NO - SKIP THIS
	MOVNI	T1,1		;GET THIS JOB'S TTY NUMBER
	GETLCH	T1		; ..
	TLNE	T1,(1B1)	;CTY?
	MOVNI	T1,1		;YES
	GETLIN	T2,		;SEE IF DETACHED
	TLNN	T2,-1		; ..
	MOVNI	T1,2		;YES. FLAG AS DETACHED
	DPB	T1,[POINT 12,F.HEAD,29] ;INTO FACT HEADER
	PJOB	T1,		;GET JOB NUMBER
	DPB	T1,[POINT 9,F.HEAD,17] ;SO CAN BE RE-CHARGED TO USER
	HRROI	T1,TTIME	;RUNTIME
	GETTAB	T1,		;GET FROM MONITOR
	  SETZ	T1,		;FAILED???
	ADDM	T1,F.TIME	;ADD TO -VE START TIME
	HRROI	T1,JBTKCT	;GET THE NUMBER OF KCT'S
	GETTAB	T1,		; FROM THE MONITOR
	  SETZ	T1,		;FAILED!!!
	ADDM	T1,F.KCS	;COMPUTE ELAPSED KCT'S
	HRROI	T1,JBTRCT	;GET THE NUMBER OF READS
	GETTAB	T1,		; FROM THE MONITOR
	  SETZ	T1,		;FAILED...
	TLZ	T1,777700	;CLEAR INCREMENTAL
	ADDM	T1,F.RCT	;GET ELAPSED READS
	HRROI	T1,JBTWCT	;GET THE NUMBER OF DISK WRITES
	GETTAB	T1,		; FROM THE MONITOR
	  SETZ	T1,		;FAILED,,,
	TLZ	T1,777700	;CLEAR INCREMENTAL
	ADDM	T1,F.WCT	;COMPUTE ELAPSED WRITES
	SKIPN	T1,F.UNIT	;PICK UP FUDGED AMOUNT
	MOVE	T1,DVQTA	;PICK UP AMOUNT LEFT
	IFN	LPTSPL,<
	IDIV	T1,LPLPP>	;CONVERT TO PAGES
	IFE	LPTSPL,<	;CDPSPL AND PTPSPL
	IDIVI	T1,DVFCT>	;CONVERT TO CARDS OR FEET
	HLRZ	T2,Q.OSIZ	;GET ORIGINAL LIMIT
	SUB	T2,T1		;FIND AMOUNT USED
	MOVEM	T2,F.UNIT	;STORE THE UNITS
	HRROI	T1,JBTLOC	;WHERE WE ARE
	GETTAB	T1,		;ASK THE MONITOR
	  SETZ	T1,		;WE ARE LOST DON'T SWEAT
	HRLZ	T2,T1		;SAVE OUR PLACE
	MOVE	T1,[SERIAL]	;APR SERIAL NUMBER (MASTER IF MORE
	GETTAB	T1,		; THAN ONE IN M/S)
	  SETZ	T1,		;EGAD!!
	HRR	T2,T1		;COPY APRSN
	MOVSI	T1,(PREFIX)	;QUEUE NAME
	IOR	T1,T2		;MUSH TOGETHER
	MOVEM	T1,F.QUE	;SAVE FOR FACT ENTRIES
	MOVE	N,[14,,FACT]	;14 WORDS - STARTING AT FACT
	DAEMON	N,		;ACTIVATE THE DAEMON
	  JRST	[MOVEI	T1,FCTCNT
		MOVEM	FACTFL
		JRST	NOACCT]
	SETZM	FACTFL		;INDICATE DAEMON EXISTS
NOACCT:
	IFN	LPTSPL,<
	MOVEI	C,14		;LOAD UP A FF
	OP	S,FFSEEN,TLON,TRON ;DO WE NEED IT?
	PUSHJ	P,DEVOUT	;YES--PRINT IT
	MOVE	N,F.TIME	;GET CP TIME USED
	IDIVI	N,JIFSEC	;DIVIDE BY JIFFIES PER SECOND
	TELL	USR,[ASCIZ /Spooler runtime # Seconds, /]
	MOVE	N,F.KCS		;GET # OF KCS USED
	IDIVI	N,JIFSEC	;CONVERT TO SECONDS
	TELL	USR,[ASCIZ /# KCS, /]
	MOVE	N,F.RCT		;READ COUNT
	TELL	USR,[ASCIZ /# disk reads, /]
	MOVE	N,F.WCT		;WRITE COUNT
	TELL	USR,[ASCIZ /# disk writes, /]
	MOVE	N,F.UNIT	;GET PAGES 
	TELL	USR,[ASCIZ /# pages
/]
	ON	S,FFSEEN	;INHIBIT FORM FEED
	PUSH	P,F.DEV		;SAVE DEVICE NAME
	SETZM	F.PPN		;ZERO PPN
	MOVE	T1,[F.PPN,,F.PPN+1] ;LOAD A BLT POINTER
	BLT	T1,F.UNIT	;CLEAR THE TRACES
	POP	P,F.DEV		;RESTORE THE DEVICE NAME
>
>;END OF IFN FACTSW FROM TESTQ:
	IFN	LPTSPL*HLINEN,<
	PUSHJ	P,.JBTRL	;GIVE A TRAILER
	>			;CLOSE LPTSPL CONDITIONAL
	MTAPE	LPT,3		;WRITE AN EOF
	OP	S,RQB,TLZE,TRZE	;HAS THIS ENTRY BEEN RELEASED?
	JRST	TSTCOR		;YES. DO NOT TRY AGAIN
	MOVEI	T1,O.REL	;RELEASE THE ENTRY
	DPB	T1,P.ROP	; THE ENTRY SO
	PUSHJ	P,Q		; OTHERS MAY USE IT
	  JFCL			;IGNORE ANY ERROR THE FILE IS GONE
TSTCOR:	SKIPN	T1,OLDCOR	;ANY CORE GRABBED?
	JRST	MAIN		;NO--BACK TO WORK
	MOVEM	T1,.JBFF	;RESET .JBFF
	SETZM	OLDCOR		;DO NOT RESET AGAIN
	CORE	T1,		;RESET .JBREL
	  STOPCD MAIN		;SHOULD NEVER HAPPEN
	JRST	MAIN		;LOOK FOR NEXT JOB

FORMF==14			;FORM-FEED
;HERE IF THE STRUCTURE CAN'T BE OPENED
CNTOPN:	POP	P,.JBFF		;RESTORE .JBFF
	PUSHJ	P,HEAD		;PRINT A HEADER
	MOVE	T1,T2		;SET UP STR NAME
	TELL	USR!OPR!ERR!LOG,NOSTR
	SETZM	DFSTR		;FLAG AS CAN'T INIT
	JRST	FIXQP		;TRY NEXT FILE


;HERE ON A LOOKUP/ENTER/RENAME FAILURE

FNF2:	SKIPA	N,T3		;SHORT UUO
FNF:	HRRZ	N,RBEXT		;LONG UUO
	PUSHJ	P,LERCOD	;PRINT THE LOOKUP, ERROR, RENAME CODE
	JRST	FIXQP		; AND DO NEXT FILE
;DO NOT WIPE OUT USER FILES IF HE TYPED A BAD QUEUE COMMAND.

;HERE TO PUT FILES BACK IN USER DIRECTORY
PUTBAK:	IFON	S,QDIR,RESTFL	;JUMP IF IN [3,3]
	SKIPL	Q.FBIT(QP)	;SKIP IF ARTIFICALY PRESERVED
	JRST	FIXQP		;NORMAL FILE
	JRST	UNPRES		;RESET TO STANDARD PROTECTION
RESTFL:	IFN	FTRNM,<		;IF WE WANT TO RENAME
	SKIPN	T2,RBSPL	;GET OLD NAME
	MOVE	T2,RBNAM	;USE FUNNY NAME IF RBSPL=0
	MOVSI	T3,(DEV)	;CAUSE TO BE RESUBMITTED BY KJOB
	MOVSI	T4,177000	;STANDARD PROTECTION FOR SPOOLED DATA
	MOVE	T5,Q.FDIR(QP)	;WHERE IT CAME FROM
	JRST	KILFIL		;DO THE RENAME
>

	IFE	FTRNM,<		;IF WE WANT TO DELETE
	SETZB	T2,T3		;CAUSE DELETION
	JRST	KILFIL		; ..
>
;SUBROUTINE TO PRINT A LOOKUP/ENTER/RENAME ERROR MESSAGE
;CALL WITH:
;	MOVE	N,RBEXT
;	PUSHJ	P,LERCOD
;LH OF N IS SET TO ZERO ALL ELSE IS PRESERVED

LERCOD:	HRRZI	N,(N)		;CLEAR LH OF N
	CAILE	N,MAXLER	;DO WE KNOW ABOUT THIS ERROR?
	JRST	TWLOST		;NO--MUST BE A FILUUO BUG
	TELL	USR!ERR!LOG!OPR,@ERRTBL(N) ;PRINT THE MESSAGE
GIVERF:	IFN	LPTSPL,<	;GIVE A FORM FEED
	PUSH	P,C		;SAVE C
	MOVEI	C,14		;LOAD A FF
	PUSHJ	P,DEVOUT	;GIVE A FORM FEED
	POP	P,C		;RESTORE C
>
	POPJ	P,0		;RETURN
TWLOST:	TELL	USR!ERR!LOG!OPR,UNDERR
	JRST	GIVERF


;TABLE OF ALL LOOKUP ENTER RENAME ERRORS

ERRTBL:	FNFERR			;(0) FILE NOT FOUND
	IPPERR			;(1) NO SUCH UFD
	PRTERR			;(2) PROTECTION FAILURE
	FBMERR			;(3) FILE BEING MODIFIED
	SYSERR			;(4) FILE EXISTS ON RENAME
	SYSERR			;(5) ILLEGAL SEQUENCE OF UUO'S
	RIBERR			;(6) I/O ERROR ON OVERHEAD BLOCK
	SYSERR			;(7) NOT A SAVE FILE (RUN, GETSEG)
	SYSERR			;(10) NOT ENOUGH CORE 
	SYSERR			;(11) DEVICE NOT AVAILABLE
	SYSERR			;(12) NO SUCH DEVICE
	SYSERR			;(13) GETSEG WITH 1 RELOCATION REG.
	NRMERR			;(14) NO ROOM FOR FILE
	WLKERR			;(15) WRITE LOCK ERROR
	NETERR			;(16) NOT ENOUGH TABLE SPACE
	SYSERR			;(17) PARTIAL ALOCATION ONLY
	SYSERR			;(20) BLOCK NOT FREE
	SYSERR			;(21) CAN NOT SUPERSEDE AN SFD OF UFD
	DNEERR			;(22) DIRECTORY NOT EMPTY ON DELETE
	SNFERR			;(23) SFD NOT FOUND
	SYSERR			;(24) SEARCH LIST EMPTY AND DSK: USED
	LVLERR			;(25) SFD NESTING TOO DEEP
	SYSERR			;(26) ALL STRS HAVE NO-CREATE OR WRITE LOCK
MAXLER==.-ERRTBL
;SUBROUTINE TO INIT THE OUTPUT DEVICE
;	PUSHJ	P,GETLPT
;	RETURN HERE WITH DEVICE (MAY HAVE TO WAIT)
;
;HERE ON FIRST CALL
GETLPT:	MOVE	T1,LPDEV	;OUTPUT DEVICE NAME
	DEVCHR	T1,		;GET IT'S DEVMOD WORD
	JUMPE	T1,NOSDEV	;SHOULD NEVER HAPPEN BUT...
	TLNN	T1,DEVAVL	;CAN WE USE THIS DEVICE
	TELL	OPR!ERR,DEVBSY	;TELL THE OPERATOR
;HERE TO BYPASS THE MESSAGE
GETLP2:	XFR	LPJFF,.JBFF	;FUDGE .JBFF
GETLP:	PUSHJ	P,CHKOPR	;SEE IF OPR GOT US OUT OF LOOP
	MOVE	T1,LPSTAT	;FILE STATUS
	MOVE	T2,LPDEV	;OUTPUT DEVICE NAME
	MOVSI	T3,DVBHD	;BUFFER HEADER
	OPEN	LPT,T1		;INIT THE DEVICE
	  JRST	[PUSHJ P,BDWAIT ;HIBER FOR 5 SECONDS
		 JRST GETLP]	;TRY AGAIN
	IFN	CDPSPL,<	;IF THIS IS CDPSPL
	MOVEI	T1,CDP		;PREPARE FOR DEVCHR
	DEVCHR	T1,
	OFF	S,ISCDP		;ASSUME NOT CDP...
	TLNE	T1,(1B2)	;IS IT A CDP?
	ON	S,ISCDP		;YES (ASSUME NOT SPOOLED)
	OUTBUF	CDP,CDPBN	;SET UP AN N BUFFER RING
	MOVSI	T1,1400		;ALSO SET BYTE SIZE TO 12
	MOVEM	T1,CDBPT	; BIT BYTES
>
	XFR	LPNAM,RBNAM	;FILE NAME
	XFR	LPEXT,RBEXT	;EXT
	XFR	LPPPN,RBPPN	;PPN
	IFN	LPTSPL,<
	OUTBUF	LPT,LPTBN>
	IFN	PTPSPL,<
	OUTBUF	PTP,PTPBN>
	IFE	OLDMON,<
	MOVEI	T1,MAXUUO	;SIZE OF BLOCK
	MOVEM	T1,UUOBLK>	;STORE IN BLOCK
	LOOKUP	LPT,UUOBLK	;FIND THE FILE
	  SETZM	RBSIZ		;GONE?
	ENTER	LPT,UUOBLK	;UPDATE THE FILE
	  JRST	CANTEF		;CAN'T ENTER FILE
	PUSHJ	P,SIZE		;GET FILE SIZE IN BLOCKS+1
	USETO	LPT,(T1)	;APPEND
	MOVE	T1,DVBHD+2	;GET THE BYTE COUNT
	MOVEM	T1,LPSIZ	;REMEMBER THE SIZE OF AN EMPTY BUFFER
	ON	S,IHGTLP	;I HAVE GOT THE LINE PRINTER
	POPJ	P,0		;RETURN

IFN	CNTRL,<XLIST>		;END OF USEFUL CODE
SUBTTL	ROUTINE TO GET MY HISEG
LOWSEG			;THIS MUST RESIDE IN LOW SEGMENT!
;SUBROUTINE TO GET THE SPOOLER HISEG
;CALL WITH:
;	PUSHJ	P,GETSPL
;	RETURN HERE
;

IFE ONESEG,<
GETSPL:	;IN 5.04 PUT THESE 2 LINES BACK
;	SKIPE	.JBHRL		;SKIPE IF NO HISEG
;	POPJ	P,		;ELSE SKIP SEGCON
;	* UNTIL THEN WE NEED A BETTER CHECK
	PUSH	P,T1		;SAVE T1
	HRROI	T1,JBTSGN	;GET HISGEG INDEX
	GETTAB	T1,		; FROM THE MONITOR
	  SETZ	T1,		;ASSUME WE DONT HAVE A HISEG
	JUMPN	T1,XCAPE	;JUMP IF WE HAVE A HISEG
	POP	P,T1		;PUT BACK T1
	PUSHJ	P,SAVALL	;SAVE THE AC'S
	MOVEI	T1,SEGBLK	;POINT TO SEGBLK
	PUSH	P,S
	MOVEM	P,SAVP#
	GETSEG	T1,		;GET IT
	  HALT
	MOVE	P,SAVP
	POP	P,S
	POPJ	P,		;RETURN
XCAPE:	POP	P,T1		;PUT T1 BACK
	POPJ	P,		;RETURN
>

IFN ONESEG,<GETSPL==CPOPJ>
;SUBROUTINE TO CLEAR A HIGH SEGMENT
;CALL WITH
;	PUSHJ	P,CLRSEG
;	RETURN HERE
;
IFE ONESEG,<
CLRSEG:	MOVSI	T1,1		;SET SIZE OF HISEG TO 1 WORD
	SETZM	.JBHRL		;SEGCON SHOULD CLEAR THIS WORD BUT
				; IT HAS A BUG AND ONLY CLEARS RH
	CORE	T1,		;CALL CORE0
	  POPJ	P,		;IGNORE ANY ERROR
	POPJ	P,		;IGNORE SUCCESS
>

IFN ONESEG,<CLRSEG==CPOPJ>
SUBTTL	APR INTERUPT AND OPERATOR CHECK MODULE

	LOWSEG			;PLACE IN LOW SEGMENT
CLKINT:	PUSH	P,.JBTPC	;SAVE RETURN ADDRESS
;THIS CODE IS DESIGNED TO GET THE HISEG IF THERE IS
;A WILD JRST TO A HISEG LOCATION. IT MAY BE THOUGHT OF
; AS DEMAND PAGING, OR A HACK.
	EXCH	T1,.JBCNI	;SAVE T1 GET .JBCNI
	HLLM	T1,.JBHRL	;CLEAR LH OF .JBHRL. NOTE: TABLE 3-5
				; IN MONIOR MANUAL IS WRONG. THE CORRECT
				; TEST FOR A HISEG IS RH OF .JBHRL =0
				; NOT THE WHOLE WORD.
	TRNN	T1,030000	;ILL. MEM. REF. OR NXM?
	STOPCD	CPOPJ		;NO--NOTHING ELSE SHOULD INTERUPT
;HERE ON AN ILL. MEM. REF.
	SKIPE	.JBHRL		;IS THERE A HISEG?
	STOPCD	CPOPJ		;REAL PROGRAM BUG.
	MOVE	T1,.JBTPC	;NO--GET PC
	TRNN	T1,400000	;IN THE HISEG?
	STOPCD	CPOPJ		;NO--REAL PROGRAM BUG
	PUSHJ	P,GETSPL	;DO THE GETSEG
	MOVEI	T1,30000	;RE-ENABLE
	APRENB	T1,		; FOR NEXT CLOCK INT
	MOVE	T1,.JBCNI	;PUT BACK T1
	POPJ	P,		;RETURN TO HISEG
CHKOPR:	SKPINL			;ANYTHING TYPED??
	  POPJ	P,		;NO--RETURN
DOCMD:	PUSHJ	P,SAVALL	;SAVE ALL AC'S
	SETZM	OLDSEG		;ASSUME NO OLD HISEG
	SKIPE	.JBHRL		;WAS THERE A HISEG
	SETOM	OLDSEG		;YES--SKIP CORE UUO
	MOVEI	T1,30000	;THIS SHOULD KILL THE PC
	APRENB	T1,		; OUT OF BOUNDS BUG. (I HOPE)
	SKIPN	.JBHRL		;SKIP IF HISEG IN CORE
	PUSHJ	P,GETSPL	;GET THE HISEG
	PUSHJ	P,COMIN		;PROCESS COMMAND
	SKIPN	OLDSEG		;WAS THERE A HISEG
	PUSHJ	P,CLRSEG	;NO--CLEAR THIS ONE
CLRBFR:	PUSHJ	P,TYI		;FLUSH REST OF LINE
	CAIE	C,12		; BUT ALLOW PARTIAL TYPE AHEAD
	JRST	CLRBFR		; ..
CLKJEN:	PUSH	P,CA		;SAVE AN AC
	MOVEI	CA,30000	;CLOCK FLAG - BAD MEM.
	APRENB	CA,		;ENABLE.
	POP	P,CA		;RESTORE CA
	POPJ	P,		;RETURN
SUBTTL COMMAND TABLES AND DISPATCHER
;FLAG BITS
	BIT	T2,LOGB,	;LOG THIS COMMAND
	BIT	T2,NOGO,	;CAN NOT BE TYPE WHEN RUNNING
	BIT	T2,NOFILE,	;CAN NOT BE TYPED IN VIRGIN STATE
	BIT	T2,ACTV,	;MUST BE TYPED WHEN RUNNING
	BIT	T2,IOACT,	;DISK FILE MUST BE OPEN
	BIT	T2,CLOSED,	;MUST BE TYPED IN VIRGIN STATE
	BIT	T2,IDLE,	;MUST NOT HAVE A REQUEST

;COMMANDS

DEFINE 	NAMES,<
	C	EXIT,XITCOM,IDLE
	C	MSGLVL,MSGLVL,0
	C	STOP,STOP,ACTV
IFE	CDPSPL,<
	C	BACKSP,BACKSP,IOACT!LOGB
	C	FORWAR,FORWAR,IOACT!LOGB>
	C	KILL,KILL,LOGB!IOACT
	C	FORMS,FIXFRM,IDLE
	C	GO,GO,NOGO!NOFILE
	C	ST,START,CLOSED
	C	START,START,CLOSED
	C	RESET,RESETC,IDLE!NOFILE
	C	REQUEU,REQUE,IOACT!LOGB
	C	CURRENT,CURDEF,0
	C	CHKPNT,TAKCHK,IOACT
	C	PAUSE,PAUSE,ACTV
	C	LOCK,SETLOK,0
	C	ZZZ,ZZZ,0
	C	TELL,CPOPJ,LOGB!IOACT
	C	WHAT,WHAT,0
	C	MLIMIT,MLIMIT,0
	C	LIMIT,LIMIT,LOGB!IOACT
	C	NEXT,NXTCOM,0	
	C	HELP,HELP,0
	IFN	LPTSPL,<
	C	SUPPRE,SUPPRE,IOACT!LOGB
	C	ALIGN,ALIGN,NOGO!NOFILE>>

;TABLES
DEFINE	C(A,B,C),<
	<SIXBIT	/A/>
	>
	XALL
	TOPSEG
COMTAB:	NAMES


DEFINE	C(A,B,D),<
	EXP	D+B
>
DSPTAB:	NAMES
DISPL=.-DSPTAB
	SALL			;BACK TO SHORT FORM

	UUMASK==TELOPR!TELUSR!TERR!TELUSR!TNOACT	;UUO BITS
						;ALL IN THE LH

;HERE WHEN A COMMAND HAS BEEN TYPED

COMIN:	MOVE	C,SAVCHR	;GET THE CHAR WE ARE HOLDING
	CAIE	C,"C"-100	;IS IT A CONTROL-C OR
	CAIN	C,"Z"-100	; A CONTROL Z?
	JRST	XITCOM		;YES-- ^C OR ^Z IMPLIES EXIT.
SKPINL			;MAKE SURE COMMAND REALY TYPED
	POPJ	P,		; NOT ^C CONT.
	MOVSI	T1,(UUMASK)	;BITS TO SAVE AROUND COMMAND
	AND	T1,S		;EXTRACT THE BITS
	TLZ	S,(UUMASK)	;CLEAR THE BITS
	MOVEM	T1,UUSAVE#	;SAVE THEM.
	XFR	<[POINT 7,LOGBUF]>,BP ;POINT TO LOG
	PUSHJ	P,SIXIN		;GET COMMAND
	  PJRST	CUE		;NULL COMMAND
	CAIE	C," "		;IF THE TERM. WAS NOT A BLANK
	MOVEM	C,SAVCHR	; SAVE FOR NEXT TIME
	CAIN	C,12		;IF TERM WAS LINE FEED
	SETZM	SAVCHR		; CLEAR TYPE AHEAD.
	MOVE	T2,T1		;COPY COMMAND
	SETO	T3,		;SET MASK TO ONES
	LSH	T3,-6		;SHIFT MASK
	LSH	T2,6		;SHIFT OFF 1 CHAR
	JUMPN	T2,.-2		;ANYTHING LEFT?
	MOVEI	T4,0		;CLEAR FLAGS
	MOVSI	T2,-DISPL	;SET UP LENGTH OF TABLE
COMLP:	MOVE	T5,COMTAB(T2)	;GET A COMMAND
	CAMN	T5,T1		;AN EXACT MATCH?
	JRST	COMFND		;YES. THIS IS IT
	TDZ	T5,T3		;CLEAR PART NOT TYPED
	CAME	T5,T1		;PARTIAL MATCH
	JRST	COMNEQ		;NO. TRY NEXT
	TROE	T4,1		;FIRST OCCURENCE
	JRST	NOCOM		;NO. CAN'T BE UNIQUE
	MOVE	N,T2		;YES. SAVE INDEX
COMNEQ:	AOBJN	T2,COMLP	;ANY MORE COMMANDS
	JUMPE	T4,NOCOM	;NO. EXACTLY 1 MATCH
	MOVE	T2,N		;YES. COPY INDEX

COMFND:	MOVE	T2,DSPTAB(T2)		;GET ADDRESS AND BITS
	IFOFF	T2,NOGO,COMCK1	;IS NOGO SET
	IFON	S,RUNB,COMSG1	;YES. IF RUN IS ON THEN ERROR
COMCK1:	IFOFF	T2,NOFILE,COMCK2;IS NOFILE SET
	IFOFF	S,OPENB,COMSG2	;YES. IF OPENB THEN ERROR
COMCK2:	IFOFF	T2,ACTV,CMCK2A	;IS ACTV SET
	IFOFF	S,RUNB,CMSG2A	;YES. IF .NOT. RUN THEN ERROR
CMCK2A:	IFOFF	T2,IOACT,CMCK2B	;SHOULD I/O BE GOING
	IFOFF	S,DSKOPN,CMSG2B	;IS IT GOING?
CMCK2B:	IFOFF	T2,CLOSED,COMCK3;SHOULD WE BE IN ITITIAL STATE
	IFON	S,OPENB,COMSG3	;ARE WE IN THAT STATE
COMCK3:	IFOFF	T2,IDLE,CMCK3A	;SHOULD WE BE IDLE
	IFON	S,DSKOPN,XITERR	;YES--JUMP IF YE ARE NOT
CMCK3A:	OFF	S,SLOGB		;CLEAR BIT
	IFON	T2,LOGB		;DO WE WANT TO LOG THIS
	ON	S,SLOGB		;REMEMBER BIT SETTING
	PUSHJ	P,(T2)		;NO. RETURN HERE AFTER COMAND
LOGIT:	PUSHJ	P,TYI		;PLACE REST OF LINE IN BUFFER
	CAIE	C,12		;ANYTHING LEFT
	JRST	LOGIT		;STILL MORE TO COME
	IFOFF	S,SLOGB,CUE	;IF WE DON'T NEED TO LOG TYPE * OR !
	MOVEI	T1,0		;MAKE SURE STRING IS IN
	IDPB	T1,BP		; ASCIZ FORMAT
	ON	S,TNOACT	;DO NOT EXPAND FUNNY CHARS
	TELL	LOG,LOGBUF	;PLACE IN THE LOG
	OFF	S,TNOACT	;CLEAR THE BIT
	JRST	CUE		;WAKE UP THE OPERATOR

NOCOM:	TELL	OPR!ERR,BADCOM	;NOT UNIQUE
	CLRBFI			;FLUSH REST OF LINE
	PJRST	CUE		;RETURN


COMSG1:	TELL	OPR!ERR,CMDER1
	PJRST	CUE
COMSG2:	TELL	OPR!ERR,CMDER2
	PJRST	CUE
CMSG2A:	TELL	OPR!ERR,CMDE2A
	JRST	CUE
CMSG2B:	IFON	S,MNTBIT,CMCK2B
	TELL	OPR!ERR,NOTBSY
	JRST	CUE
COMSG3:	TELL	OPR!ERR,COMER3

CUE:	IFON	S,RUNB		;IF RUN IS ON
	TELL	OPR,EXCLPT	; TYPE A !
	IFOFF	S,RUNB		;IF RUN IS OFF
	TELL	OPR,STAR	; TYPE A *
	TDZ	S,[UUMASK+SOME]	;CLEAR SAVED BITS
	IOR	S,UUSAVE	;PUT BACK ANY NEEDED
	POPJ	P,
SUBTTL	COMMAND SUBROUTINES
;SUBROUTINE TO SELECT OUTPUT DEVICE AND START SPOOLER
;CALL WITH
;	PUSHJ	P,START
;	RETURN HERE
;
START:	PUSHJ	P,SAV5		;SAVE PRESERVED ACS
	XFR	.JBFF,LPJFF	;SAVE .JBFF FOR NEXT INIT
	MOVSI	P1,(DEV)	;SET DEFAULT OUTPUT DEVICE
	SETZB	P2,P3		; WITH NO FILE NAME
	GETPPN	P5,		; AND MY PPN
	MOVSI	P4,SPLPRT	; AND 157 PROTECTION
	PUSHJ	P,FILSPC	;LET THE OPERATOR OVERRIDE
	JUMPE	P1,CPOPJ	;ERROR IN FILE SPEC
	IFN	FACTSW,<
	MOVEM	P1,F.DEV>	;STORE IN CASE DEVNAM FAILS
	MOVEM	P1,LPDEV	;OUTPUT DEVICE
	MOVEM	P2,LPNAM	;OUTPUT FILE NAME
	MOVEM	P3,LPEXT	;OUTPUT FILE EXT
	MOVEM	P5,LPPPN	;OUTPUT DIRECTORY
	MOVEI	T1,STATUS	;INITIAL FILE STATUS
	MOVEM	T1,LPSTAT	;SAVE FOR GETLPT
	MOVE	T2,P1		;AND DEVICE
	DEVCHR	P1,		;GET IT CHARACTORISTICS
	JUMPE	P1,NOSDEV	;NO SUCH DEVICE
	MOVEI	T1,100		;SMART PROGRAM BIT
	TLNE	P1,DEVLPT	;IS THIS A LINE PRINTER
	IORM	T1,LPSTAT	;YES--TURN ON THE BIT
	PUSHJ	P,GETLPT	;NOT FREE. WAIT
	ON	S,OPENB		;OUTPUT FILE OPEN
	MOVEI	T1,LPT		;OUTPUT CHANNEL
	DEVNAM	T1,		;GET PHYSICAL NAME
	  PJRST GO		;WE CAN NOT FIND OUT
	MOVEM	T1,LPDEV	;SAVE FOR FUTURE INITS
	IFN	FACTSW,<
	MOVEM	T1,F.DEV	;PHYSICAL SPOOLING DEVICE>
	MOVSI	T1,400000	;PHYSICAL INIT ONLY BIT
	ORM	T1,LPSTAT	;SAVE FOR FUTURE
	PJRST	GO		;GIVE A FREE GO
;HERE WHEN WE FIND DEVICE NOT USABLE
CANTEF:	TELL	OPR!ERR,FILBSY	;TELL OP ABOUT BAD FILE NAME
	OFF	S,OPENB		;CLEAR OUTPUT FILE OPEN BIT
	POPJ	P,		;RETURN
NOSDEV:	TELL	OPR!ERR,NODEV	;DOES NOT EXIST
	POPJ	P,
NULDEV:	TELL	OPR!ERR,[ASCIZ /99Bad file name
/]
	OFF	S,OPENB		;CLEAR WINNING BIT
	POPJ	P,		;GIVE UP
	IFN	LPTSPL,<

;SUBROUTINE TO ALLOW FORMS TO BE SET UP
;CALL WITH:
;	PUSHJ	P,ALIGN
;	HERE WHEN DONE
;
ALIGN:	PUSHJ	P,SAV5		;SAVE 5 AC'S
	IFOFF	S,IHGTLP	;MUST HAVE LPT
	PUSHJ	P,GETLPT	;GET THE LPT
ALIGN1:	MOVSI	P1,'SYS'	;DEFAULT IS SYS
	SKIPN	P2,FORMS	;GET FORM TYPE IF NON-STANDARD
	MOVSI	P2,'STD'	;STANDARD FORMS
	MOVSI	P3,'ALP'	;EXTENSION .ALP
	SETZB	P4,P5		;NO PPN
	PUSHJ	P,FILSPC	;GO CHANGE DEFAULTS
	CLRBFI
	JUMPE	P1,CPOPJ	;NULL DEVICE
	TELL	OPR,STAR	;TELL THE OP TO DO SOMETHING
	MOVE	T2,P1		;NAME OF DEVICE
	DEVCHR	T2,		;GET IT'S CHAR
	JUMPE	T2,NOSDEV	;NO SUCH DEVICE
	SETZ	T1,		;ASCII MODE
	MOVE	T4,.JBFF	;SAVE .JBFF
ALSET:	MOVEM	T4,.JBFF	;RESTORE .JBFF
	MOVEI	T3,ALBHD	;BUFFERS FOR ALIGN
	MOVE	T2,P1		;NAME OF DEVICE
	OPEN	ALPCHN,T1	;INIT THE DEVICE
	  JRST	NDEV		;NO SUCH DEVICE
	PUSH	P,P5		;SAVE PPN IF WE LOOP
	LOOKUP	ALPCHN,P2	;LOOK FOR FILE
	  JRST 	CNTFND		;FAILED
	POP	P,P5		;PUT THE PPN BACK
	INBUF	ALPCHN,DSKBN	;BUILD SOME BUFFERS
	OUTPUT	LPT,		;CLEAN UP
ALOOP:	SOSLE	ALCNT		;ROOM IN BUFFERS
	JRST	ALDB		;YES--SHOVE IT
	IN	ALPCHN,0	;READ SOME FILE
	  JRST	ALDB		;ALL IS O.K.
	STATZ	ALPCHN,1B22	;END OF FILE
	  JRST	ALSET		;DO IT AGAIN
	JRST	ALDIE		;STOP ON I/O ERROR
ALDB:	ILDB	C,ALBPT		;GET THE CHAR
	PUSHJ	P,DEVOUT	;PRINT THE CHAR
	SETOM	HNGCNT		;LPT IS RUNNING
	SKPINL			;ANY TYPIN WILL SAVE US
	JRST	ALOOP		;NOT SAVED
ALDIE:	RELEAS	ALPCHN,		;GIVE UP THE DISK
	MOVEM	T4,.JBFF	;PUT BACK .JBFF
	POPJ	P,
NDEV:	MOVEM	T4,.JBFF	;RESTORE .JBFF
	MOVE	T1,P1		;FOR ERROR MESSAGE
	TELL	OPR!ERR,ANODEV	;NOT FOR OUR USE
	POPJ	P,		;RETURN
CNTFND:	POP	P,P5		;KEEP PDL IN SYNC
	MOVEM	T4,.JBFF	;PUT BACK .JBFF
	TELL	OPR!ERR,ANOFIL	;CAN'T FIND FILE
	POPJ	P,		;RETURN>
;SUBROUTINE TO TYPE THE HELP TEXT
;CALL WITH:
;	PUSHJ	P,HELP
;	RETURN HERE
;
HELP:	MOVE	T1,[XXXSPL]	;FILE TO READ
	PUSHJ	P,.HELPR##	;GO TYPE IT OUT
	POPJ	P,


;SUBROUTINE TO SET MAX OUTPUT LIMIT FOR ALL JOBS
; ANY JOB OVER LIMIT WILL SIT IN QUEUE.
;CALL WITH:
;	PUSHJ	P,MLIMIT
;	RETURN HERE
;
MLIMIT:	PUSHJ	P,DECARG	;GET N
	  JRST	BADNBR		;BAD NUMBER
	JUMPE	N,LIMERR	;CAN'T BE ZERO
	MOVEM	N,MLIM		;STORE AWAY
	POPJ	P,		;RETURN


;SUBROUTINE TO EXIT FROM SPOOLER
;CALL WITH:
;	PUSHJ	P,XITCOM
;	RETURN ONLY IF ERROR
;
XITCOM:	CLOSE	LPT,		;CLOSE OUTPUT FILE
	EXIT	1,		;MONRET
	JRST	SPOOL
XITERR:	TELL	OPR!ERR,[ASCIZ /99Files active
/]
	JRST	LOGIT		;EAT REAST OF LINE AND TYPE
				; * OR !

;TAKCHK -- TAKE A CHKPNT
TAKCHK:	PUSHJ	P,SETDOT	;/CURRENT
	PJRST	DOREQ		;GO DI IT
;SUBROUTINE TO CHANGE LIMIT FOR THIS JOB ONLY
;CALL WITH:
;	PUSHJ	P,LIMIT
;	RETURN HERE
;
LIMIT:	HLRZ	T1,Q.OSIZ	;GET OLD LIMIT
	IFN	LPTSPL,<
	IMUL	T1,LPLPP	;CONVERT TO LINES PER PAGE>
	IFN	CDPSPL,<
	IMULI	T1,CPC		;CONVERT TO CHARACTERS>
	IFN	PTPSPL,<
	IMULI	T1,CPF		;CONVERT TO CHARS>
	PUSHJ	P,DECARG	;GET ARGUMENT
	  JRST	BADNBR		;OOPS
	JUMPE	N,LIMERR	;CAN'T BE ZERO
	HRLM	N,Q.OSIZ	;STORE
	IFN	LPTSPL,<
	IMUL	N,LPLPP>
	IFN	CDPSPL,<
	IMULI	N,CPC>
	IFN	PTPSPL,<
	IMULI	N,CPF>
	SUB	T1,DVQTA	;GET AMOUNT LEFT IN T1
	SUB	N,T1		;SUBTRACT FROM NEW QUOTA
	MOVEM	N,DVQTA		;STORE
	IFN	PLTSPL,<
	MOVE	T1,[UPTIME]	;GET THE UPTIME
	GETTAB	T1,		; FROM THE MONITOR
	  SETZ	T1,		;OOPS--WE LOST.
	IMULI	N,^D60*JIFSEC	;CONVERT TO JIFIES
	ADD	N,T1		;TIME TO ABORT
	MOVEM	N,PLIMIT>	;STORE FOR LATER
	POPJ	P,

LIMERR:	TELL	OPR!ERR,[ASCIZ /99Can not be #
/]
	POPJ	P,
;SUBROUTINE TO DECLARE A NEW TYPE OF FORMS TO BE MOUNTED
;CALL FROM COMAND DISPATCH
;
FIXFRM:	PUSHJ	P,SIXIN		;GET FORM TYPE
	  JRST	TELFTP		;NONE--TELL FORMS TYPE THEN
	MOVS	T2,T1		;MAKE CAIN-ABLE
	CAIN	T2,'STD'	;DOES HE WANT STD
	SETZ	T1,		;YES--THAT IS ZERO
	MOVEM	T1,FORMS	;STORE THE NEW VALUE
TELFTP:	SKIPN	T1,FORMS	;DO WE KNOW??
	MOVSI	T1,'STD'	;NO--MUST BE STD
	TELL	OPR,FTYPE	;TELL THE TYPE
	POPJ	P,

;SUBROUTINE TO KILL AN ENTRY
;CALL WITH
;	PUSHJ	P,KILL
;	RETURN HERE
;
KILL:	PUSHJ	P,DOSW		;GET SWITCH
	  JRST	REL		;NONE. ASSUME /OUTPUT
	ACTCHR	F,REL		;/FLUSH?
	TELL	OPR!ERR,BADSW	;BAD SWITCH
	POPJ	P,		;IGNORE COMMAND
	TELL	USR!ERR,KILLED	;NOTIFY USER ON LISTING
	OFF	S,FFSEEN	;CAUSE A FREE FORM FEED
REL:	IFON	S,DSKOPN
	USETI	DSK,777777	;CAUSE EOF TO BE SET
	ON	S,ABORT		;MARK ENTRY ZAPPED
	IFN	LPTSPL,<
	IFN	FACTSW,<	;IF WE ARE COUNTING
	MOVE	T1,LPQTA	;PICK UP THE QUOTA
	MOVEM	T1,F.UNIT>	;STORE FOR FACT FILE
	MOVEI	T1,LOGLIM	;SET UP THE LIMIT FOR THE LOG
	MOVEM	T1,LPQTA	;AND STORE IN LPCB>
	CAIN	C,"F"		;FLUSH??
	JRST	RELB1		;YES, GO CLEAR UP
	IFON	S,MNTBIT,GO	;ISSUE A "GO" ON KILL AT MOUNT REQUEST
	POPJ	P,		;NO. RETURN
RELB1:	PUSHJ	P,LOGIT		;FLASH AT THE OPR
	MOVE	P,[IOWD PDSIZE,PDL] ;BACK TO THE TOP
	JRST	MAIN		;LOOK AT NEXT ENTRY


KILLED:	ASCIZ	/Output killed by the operator for file ^

/

;SUBROUTINE TO CONTINUE FROM STOP/PAUSE
;CALL WITH:
;	PUSHJ	P,GO
;	RETURN HERE
;
GO:	ON	S,RUNB
	POPJ	P,


;SUBROUTINE TO WAIT FOR OPR TO TYPE GO
;CALL WITH:
;	PUSHJ	P,GOWAIT
;	RETURN HERE WHEN RUNNABLE
;
GOWAIT:	INCHWL	SAVCHR		;INPUT A CHAR 
	PUSHJ	P,DOCMD		;PROCESS COMMAND
	IFOFF	S,RUNB,GOWAIT	;WAIT IF NOT GO
	POPJ	P,		;RETURN
;SUBROUTINE TO CAUSE A STOP AFTER THIS JOB
;CALL WITH:
;	PUSHJ	P,PAUSE
;	RETURN	HERE
;
PAUSE:	IFOFF	S,RUNB,GOWAIT	;IF WE ARE NOT GOING DO A STOP
	ON	S,PAUSEB	;SET FLAG
	POPJ	P,


;SUBROUTINE TO CHANGE THE SLEEP VALUE
;CALL WITH:
;	PUSHJ	P,ZZZ
;	RETURN	HERE
;
ZZZ:	PUSHJ	P,DECARG
	  JRST	BADNBR
	MOVEM	N,ZZZVAL#
	POPJ	P,
BADNBR:	TELL	OPR!ERR,BADNMS
	POPJ	P,


;SUBROUTINE TO SET OR CLEAR BOTH PAUSE AND PAUSE LOCK
;CALL WITH:
;	PUSHJ	P,SETLOK
;	RETURN HERE
;
SETLOK:	PUSHJ	P,DOSW		;GET A SWITCH
	  POPJ	P,		;NO SWITCH--NO ACTION
	CAIN	C,"S"		;/SET?
	TDO	S,[PAUSEB!PLOCK];YES--SET BOTH
	CAIN	C,"C"		;/CLEAR?
	TDZ	S,[PAUSEB!PLOCK];YES--CLEAR BOTH
	POPJ	P,
;SUBROUTINE TO GIVE THE CURRENT DEFAULTS
;CALL WITH:
;	PUSHJ	P,CURDEF
;	RETURN HERE
;
CURDEF:	MOVE	N,MLIM		;PICK UP MLIMIT
	TELL	OPR,CURMS1	;GIVE THE FIRST MESSAGE
	OUTCHR	CMSGLV		;PRINT MSGLVL
	OUTCHR	LMSGLV		; ..
	OUTCHR	EMSGLV		; ..
	SKIPN	N,ZZZVAL	;GET THE SLEEP TIME
	MOVEI	N,SLTIME	; OR THE DEFAULT
	TELL	OPR,CURMS2	;GIVE REST OF MESSAGE
	POPJ	P,
;SUBROUTINE TO FORCE JOB #N TO BE RUN NEXT
;CALL WITH:
;	PUSHJ	P,NXTCOM
;	RETURN HERE
;
NXTCOM:	PUSHJ	P,DECARG	;READ A DECIMAL ARGUMENT
	  PJRST	BADNBR		;OOPS...
	MOVEM	N,NXTJOB	;SAVE FOR LATER
	POPJ	P,		;RETURN

;SUBROUTINE TO REQUEUE AN ENTRY
;CALL WITH:
;	PUSHJ	P,REQUE
;
REQUE:	MOVE	T1,Q.FBIT(QP)	;PICK UP POINTER
	MOVEM	T1,RQFBIT	;STORE (IT MAY BE CHANGED)
	LDB	T1,P.CPY	;GET THE COPY NUMBER
	MOVEM	T1,CPYTMP	;SAVE FOR LATER
	PUSHJ	P,DOSW		;SCAN FOR A /
	  JRST	DOREQ0		;FOUND ALL SWITCHES
	ACTCHR	A,RQAFT		;AFTER
	ACTCHR	H,RQHOLD	;HOLD
	ACTCHR	C,RQCUR		;CURRENT
	ACTCHR	T,RQTOP		;TOP OF JOB
	ACTCHR	B,RQBACK	;BACK N UNITS
	ACTCHR	F,RQFOR		;FORWARD N UNITS
	TELL	OPR!LOG!ERR,BADSW	;BAD SWITCH
	POPJ	P,		;PUNT THE COMMAND
RQHOLD:	MOVEI	T1,377777	;12 HOURS
	TLO	T1,(1B0)	;PLUS SIGN
	MOVEM	T1,Q.AFTR	;NEW AFTER PARAM
	JRST	REQUE		;DO NEXT SWITCH
RQBACK:	PUSHJ	P,GTARGU	;GET ARGUMENT
	MOVN	N,N		;BACK
	JRST	RQFOR1		;REST IS LIKE /FOR
RQCUR:	TDZA	N,N		;CURRENT LINE
RQFOR:	PUSHJ	P,GTARGU	;GET THE ARGUMENT
RQFOR1:	PUSHJ	P,SETDOT	;SET CURRENT POSITION
	MOVEM	T1,Q.FBIT(QP)	;THIS IS A LOAD BYTE
	TLNE	T1,(1B2)	; AND EXTEND.
	TLOA	T1,(3B1)	; ..
	TLZ	T1,(3B1)	; ..
	IFN	LPTSPL,<	;CONVERT FROM
	IMUL	N,LPLPP>	; EXTERNAL
	IFE	LPTSPL,<	; TO 
	IMULI	N,DVFCT>	; INTERNAL UNITS
	ADD	T1,N		;ADD IN ARGUMENT
	LDB	T2,[POINT 2,Q.FBIT(QP),1] ;SAVE FLAGS
	MOVEM	T1,Q.FBIT	;STRE RESULT
	SKIPG	Q.FBIT(QP)	;SKIP IF PLUS
	SETZM	Q.FBIT(QP)	;LINE 1 IS BEST WE CAN DO
	AOS	Q.FBIT(QP)	;BE THE SAME AS QUEUE
	DPB	T2,[POINT 2,Q.FBIT(QP),1] ;PUT FLAGS BACK
	JRST	REQUE		;DO NEXT SWITCH
RQAFT:	PUSHJ	P,FNDELM	;GET THE DELIMITER
	  SKIPA			;NONE
	PUSHJ	P,DECARG	;GET THE NUMBER
	  MOVEI	N,^D30		;ASSUME 30 MIN.
	IMULI	N,<777777/<^D3600*24>>*^D60
	TLO	N,(1B0)		;AFTER
	MOVEM	N,Q.AFTR	;STORE AWAY
	JRST	REQUE		;LOOP FOR MORE COMPLEX STUFF
RQTOP:	PUSHJ	P,SETDT1	;SET THE POINTER
	JRST	REQUE		;LOOK FOR MORE SWITCHES
GTARGU:	PUSHJ	P,FNDELM	;GET HTE DELIMITER
	  JFCL			;NONE DON'T SWEAT
	PUSHJ	P,DECARG	;GET A DECNAL NUMBER
	  JFCL			;LOSS DO NOT WORRY
	IFN	LPTSPL,<	;LPTSPL?
	IMUL	N,LPLPP	>	;YES--CONVERT TO NEW UNITS
	IFE	LPTSPL,<	;NO--THEN CONVERT
	IMULI	N,DVFCT>	; TO PROPER THING
	POPJ	P,		;RETURN



SETDOT:	SETZ	C,		;CLEAR THE FLAG
SETDT1:	SKIPN	T1,OLDCOR	;EXTENDED QUEUE REQUEST
	MOVEI	T1,Q.BLK	;NO--STANDARD POINTER
	LDB	T2,P.LOH	;SKIP OVER HEADER
	ADDI	T1,1(T2)	; ..
	LDB	T2,P.LOE	;GET LENGTH OF ENTRY
	MOVSI	T3,(QUPSKP)	;SET THE IGNORE BIT
RQLP1:	CAIL	T1,(QP)		;MORE TO COME???
	JRST	RQDOT1		;NO--LOOK FOR BUGS
	IORM	T3,Q.FBIT(T1)	;YES--SET THE FLAG
	CAIN	C,"T"		;/TOP GIVEN?
	ANDCAM	T3,Q.FBIT(T1)	;YES--CLEAR THE BIT
	ADDI	T1,(T2)		;POINT TO NEXT ENTRY
	JRST	RQLP1		;LOOP FOR MORE
RQDOT1:	CAME	T1,QP		;DOES ACTUAL=COMPUTED
	STOPCD	.		;NO--BOMB OUT
	JUMPN	C,TOPBIT	;JUMP IF /TOP
	LDB	T2,P.TCPY	;GET THE NUMBER OF COPIES
	LDB	T3,P.CPY	;GET THE ORIGINAL AMOUNT
	SUBI	T3,-1(T2)	;GET THE NUMBER OF COPIES LEFT
	MOVEM	T3,CPYTMP#	;SAVE COPY NUMBER
	LDB	T1,[POINT 30,DFDOT,35] ;GET THE CURRENT LINE NUMBER
	MOVE	T2,DVQTA	;GET THE AMOUNT LEFT
	SUB	T1,T2		;GET RESTART ADDRESS
SETBIT:	AOS	T1		;COUNTERACT SOJE
	SKIPG	Q.FBIT(QP)	;ART PRES?
	TLO	T1,(1B0)	;YES--SAVE THE BIT
	MOVEM	T1,RQFBIT	;STORE NEW VALUE FOR REQUEUE
	POPJ	P,		;RETURN

TOPBIT:	SETZ	T1,		;CLEAR T1
	JRST	SETBIT
DOREQ0:	OP	S,SCLN,TLOA,TROA
DOREQ:	OFF	S,SCLN		;NOT A COMMAND
	MOVEI	T1,O.CHK	;WE WANT TO REQUEUE
	DPB	T1,P.ROP	;STORE IN REQUEST
	MOVEI	T1,CUSP		;GET OUT NAME
	DPB	T1,P.RCP	;STORE IN REQUEST
	SKIPN	T4,OLDCOR	;DO WE HAVE A LONG LIST
	JRST	DOREQ1		;NO--DO NOT BLT
	MOVSI	T1,Q.BLK	;START POSITION
	HRRI	T1,(T4)		;END POSITION
	BLT	T1,Q.FBLK-Q.BLK(T4) ;BLT THE DATA
	JRST	.+2		;SKIP THE MOVEI
DOREQ1:	MOVEI	T4,Q.BLK	;POINT TO NORMAL BLOCK
	LDB	T1,P.LOH	;GET LENGTH OF HEADER
	LDB	T2,P.LOE	;GET LENGTH OF ENTRY
	HRRZ	T3,Q.LEN	;GET LENGTH OF REQUEST
	IMULI	T2,(T3)		;MULTIPLY THE LENGTHS
	ADDI	T1,1(T2)	;ADD TO SIZE OF HEADER
	HRLZI	T1,(T1)		;FLIP TO LEFT HALF
	HRRI	T1,(T4)		;COPY INDEX
	PUSH	P,Q.FMOD(QP)	;SAVE Q.FMOD (COPY COUNT)
	MOVE	T2,CPYTMP	;PICK UP NUMBER OF COPIES LEFT
				; WHEN WE RESUME.
	DPB	T2,P.CPY	;STORE FOR QMANGR
	PUSH	P,Q.FBIT(QP)	;SAVE Q.FBIT
	MOVE	T2,RQFBIT	;GET RESTART VALUE
	MOVEM	T2,Q.FBIT(QP)	;STORE IN REQUEST
	PUSHJ	P,QUEUER	;CALL QMANGR
	POP	P,Q.FBIT(QP)	;RESTORE Q.FBIT
	POP	P,Q.FMOD(QP)	;RESTORE COPY COUNT
	IFOFF	S,SCLN		;COMMAND?
	POPJ	P,		;NO--JUST A CHKPNT
	ON	S,RQB		;FLAG MAJOR LOSSAGE
	USETI	DSK,-1		;CAUSE THE LOSS
	SETOM	DFCNT		; NOW
	POPJ	P,		;RETURN
;SUBROUTINE TO GIVE CURRENT STATUS OF SPOOLER
;CALL WITH:
;	PUSHJ	P,WHAT
;	RETURN HERE
;
WHAT:	ON	S,NOCLOS	;SAVE AS 1 BUFFER
	IFOFF	S,RQB		;IF ENTRY HAS BEEN KILLED
				; DO NOT TRY AND TALK ABOUT IT.
				; EG. STOP, KILL, WHAT
	IFOFF	S,DSKOPN,WHATB	;SKIP IF NOT ACTIVE
	SKIPE	T1,Q.JOB	;ANY JOB NAME
	TELL	OPR,WHAT1	;YES. PRINT IT
	SKIPE	N,Q.SEQ		;ANY SEQUENCE #
	TELL	OPR,WHAT2	;YES. PRINT THAT TOO
	SKIPE	T1,Q.USER	;NAME?
	TELL	OPR,WHAT3	;TELL OPR
	TRNN	T1,77		;WAS THE LAST CHAR OF THE FIRST WORD
				; A SPACE?
	TELL	OPR,[ASCIZ /99 /] ;YES--PRINT ANOUTHER SPACE SINCE
				; TRAILING SPACES ARE DELETED BY
				; THE SIXBIT PRINTER
	MOVE	T1,Q.USER+1	;SECOND HALF OF NAME
	SKIPE	Q.USER		;PRINT IFF 1 HALF WAS PRINTED
	TELL	OPR,WHAT4	; ..
	TELL	OPR,WHAT4A	;PRINT USERS PPN
	TELL	OPR,WHAT5	;PRINT CURRENT FILE
	HLRZ	N,Q.OSIZ	;GET LIMIT
	TELL	OPR,WHAT6	;TELL OPR
	MOVE	N,DVQTA		;GET AMOUNT LEFT
	IFN	LPTSPL,<
	IDIV	N,LPLPP		;BACK TO PAGES>
	IFN	CDPSPL,<
	IDIVI	N,CPC		;BACK TO CARDS>
	IFN	PTPSPL,<
	IDIVI	N,CPF>		;BACK TO FEET
	TELL	OPR,WHAT7	;TELL OPR
	LDB	N,P.CPY		;GET # OF COPIES
	CAIL	N,2		;SKIP IF USUAL CASE
	TELL	OPR,WHAT8	;MORE THAN 1 COPY
	LDB	N,P.FDSP	;WHAT WILL WE DO?
	SKIPE	N
	TELL	OPR,WHAT9	;TELL THE OPR
WHATB:	IFOFF	S,DSKOPN	;ARE WE ACTIVE
	TELL	OPR,NOTBSY
	MOVE	T1,LPDEV	;GET THE DEVICE NUMBER
	MOVE	N,HNGCNT	;GET THE HUNG COUNT
	AOS	N		;KICK IT.
	SKIPE	N		;REALY HUNG?
	TELL	OPR,DEVNOK	;YES--COMPLAIN
	IFOFF	S,RUNB		;INTVN REQUIRED
	TELL	OPR,WHATB2	;YES. TELL HIM
	IFON	S,PAUSEB	;WAS PAUSE REQUESTED
	TELL	OPR,WHATB3	;YES. TELL HIM
	IFON	S,RQB		;IF WE ARE IDLE CLEAR HARMLESS
	TDZ	S,[ARROW!SUPRES!QDIR] ;BUT CONFUSING BITS
	IFON	S,ARROW		;ARROW MODE
	TELL	OPR,WHATB4	;YES. TELL HIM
	IFON	S,SUPRES	;SUPPRESS
	TELL	OPR,WHATB5	;YES TELL HIM
	IFON	S,QDIR		;RENAMED
	TELL	OPR,WHATB6	;YES. TELL THE OP
	IFON	S,NOTYPE	;^O THE LPT
	TELL	OPR,WHATB7	;TELL THAT TOO
	OUTPUT	TTY,0		;DUMP THE BUFFER
	OFF	S,NOCLOS	;RESET THE FLAG
	POPJ	P,
;SUBROUTINE TO DO A RESET
;CALL WITH:
;	PUSHJ	P,RESETC
;	NEVER RETURNS
;ALL AC'S REFRESHED
RESETC:	RELEAS	LPT,		;CLOSE DISK OUTPUT
	JRST	SPOOL


;SUBROUTINE TO CAUSE PAUSE TO STOP FLOW
;CALL WITH:
;	PUSHJ	P,EOFSTP
;	RETURN HERE WHEN RUNNABLE
;
EOFSTP:	IFOFF	S,PLOCK		;CLEAR BIT UNLESS LOCKED
	OFF	S,PAUSEB	;PREVENT LOOP AND FALL
				; INTO STOP

;SUBROUTINE TO DO A STOP
;CALL WITH:
;	PUSHJ	P,STOP
;	RETURN HERE WHEN RUNNABLE
;
STOP:	OFF	S,RUNB		;CLEAR RUN
	TELL	OPR,STAR	;PRINT A STAR
	PJRST	GOWAIT		;WAIT FOR RUN TO COME BACK ON
;SUBROUTINE TO DO MSGLVL COMMAND
;CALL WITH:
;	PUSHJ	P,MSGLVL
;
MSGLVL:	PUSHJ	P,DIGIT		;PICK UP C
	MOVEM	C,CMSGLV	;STORE IN CB
	PUSHJ	P,DIGIT		;PICK UP L
	MOVEM	C,LMSGLV	;STORE IN CB
	PUSHJ	P,DIGIT		;PICK UP S
	MOVEM	C,EMSGLV	;STORE
	POPJ	P,		;RETURN


;SUBROUTINE TO INPUT 1 DECMAL DIGIT
;CALL WITH:
;	PUSHJ	P,DIGIT
;	RETURN HERE
;
DIGIT:	PUSHJ	P,TYI		;GET A CHAR
	CAIN	C," "		;IGNORE BLANKS
	JRST	DIGIT		;LOOP BEYOND BLANK
	CAIN	C,12		;LINE FEED?
	JRST	NOTDEC		;YES--TOO FEW ARGUMENTS
	CAIGE	C,"0"		;BIGGER THAN 0
	JRST	NOTDEC		;NO. BAD DIGIT
	CAIG	C,"9"		;BIGGER THAN 9
	POPJ	P,		;NO. IT IS KOSHER
NOTDEC:	MOVEI	T1,-40(C)	;PRINT OFFENDING CHAR
	TELL	OPR!ERR,BADIGM	;TELL OPR TO RETRY
	MOVEI	C,"0"		;RETURN A GOOD CHAR
	POPJ	P,		;RETURN
	IFN	LPTSPL,<
;SUBROUTINE TO IMPLEMENT THE SUPPRESS COMMAND
;CALL WITH:
;	PUSHJ	P,SUPPRE
;	RETURN HERE
;
SUPPRE:	PUSHJ	P,DOSW		;PICK UP THE SWITCH
	  JRST	SUPFIL		;NO SWITCH DEFAULT IS /ON
	ACTCHR	O,CLRSUP	;/OFF ?
	ACTCHR	F,SUPFIL	;/FILE
	ACTCHR	J,SUPJB		;/JOB ?
	TELL	OPR!ERR,BADSW	;FUNNY SWITCH
	POPJ	P,
SUPJB:	ON	S,SUPJOB	;SET GLOBAL FLAG
SUPFIL:	ON	S,SUPRES	;SET LOCAL FILE
	POPJ	P,		;RETURN
CLRSUP:	OFF	S,SUPJOB	;CLEAR LOCAL FLAG
	OFF	S,SUPRES	;CLEAR GLOBAL FLAG
	POPJ	P,		;RETURN>

;SUBROUTINE TO FIND A DELIMITER (ANY OF :,=,_, OR -)
;CALL WITH:
;	PUSHJ	P,FNDELM
;	  CAN'T FIND A DELIMITER
;	RETURN HERE WITH DELIMITER IN C
;
FNDELM:	PUSHJ	P,TYI		;GET A CHAR
	CAIN	C,12		;LINE FEED?
	POPJ	P,		;YES. NO DELIMITER
	CAIE	C,":"		;COLON?
	CAIN	C,"="		; OR EQUALS
	JRST	CPOPJ1		;YES. WE HAVE A DELIMITER
	CAIE	C,"_"		;LEFT ARROW
	CAIN	C,"-"		; OR HYPHEN
	JRST	CPOPJ1		;YES WE HAVE A DELIMITER
	JRST	FNDELM		;NO KEEP LOOKING

;SUBROUTINE TO INSERT THE FIRST CHAR AFTER A / IN C
;CALL WITH
;	PUSHJ	P,DOSW
;	  RETURN HERE IF NO SWITCHES
;	RETURN HERE WITH C SET UP
;
DOSW:	PUSHJ	P,SIXIN	;LOOK FOR ANOTHER WORD
	  JRST	CHKSW		;FAILURE IS EXPECTED
	TELL	OPR!ERR,UNEXPD	;COMPLAIN ABOUT UNEXPECTED WORD
CHKSW:	MOVSI	T1,-40(C)	;COPY IN CASE IT IS WRONG
	LSH	T1,14		;PUT AT END OF WORD
	CAIN	C,12		;END OF LINE?
	POPJ	P,		;RETURN
	CAIN	C,"/"		;IS IT A /
	JRST	GIVSW		;YES--YIPPIE
	CAIE	C," "		;IS IT A SPACE
	TELL	OPR!ERR,UNEXPD	;NO ANOTHER UNEXPECTED THING
	JRST	DOSW		;KEEP LOOKING
GIVSW:	AOS	(P)		;CAUSE SKIP RETURN
	PJRST	TYI		;PLACE NEXT CHAR IN C
;SUBROUTINE TO INPUT A DECMAL NUMBER
;CALL WITH:
;	PUSHJ	P,DECARG
;	  INVALID DATA
;	RETURN HERE WITH NUMBER IN N
;MUST RESPECT T2
DECARG:	SETZ	N,		;CLEAR RESULT
DECAR1:	PUSHJ	P,TYI		;GET A CHAR
	CAIG	C,71		;IS THIS CHAR A DIGIT
	CAIGE	C,60		; ..
	JRST	ACH		;NO. MUST BE END OF NUMBER
	IMULI	N,12		;ADJUST N FOR NEXT DECADE
	ADDI	N,-60(C)	;NIFTY INSTRUCTION, TO INCR. N
	JRST	DECAR1		;GET NEXT DIGIT
ACH:	CAIE	C," "		;BLANKS TABS
	CAIN	C,12		; AND LINE FEEDS ARE VALID AFTER NUMBER
	AOS	(P)		;GOOD DELIMITER IN C
	POPJ	P,		;INVALID DELIMITER
;SUBROUTINE TO READ IN A STANDARD FILENAME
;CALL WITH:
;	PUSHJ	P,FILSPC
;	RETURN HERE
;***RESULT IS IN PERM. AC'S AS FOLLOWS:
;			P1 - DEVICE OR UNCHANGED
;			P2 - FILE   OR UNCHANGED
;			P3 - EXT    OR UNCHANGED
;			P4 - UNCHANGED
;			P5 - DIRECTORY
;
FILSPC:	OFF	S,EXTFLG	;NO EXTENSION YET
SPEC1:	PUSHJ	P,SIXIN		;GET A WORD
	  JRST	SPCEND		;NOTHING LEFT
	ACTCHR	<:>,DEVICE	;WORD IS A DEVICE
	ACTCHR	<.>,FILE	;WORD IS A FILE NEXT WORD IS AN EXT
	ACTCHR	<[>,PPN		;PPN COMING
SPCEND:	IFON	S,EXTFLG	;EXTENSION?
	SKIPA	P3,T1		;YES
	MOVE	P2,T1		;NO. FILENAME
	CAIE	C,12		;LINE FEED IS ONLY THING LEFT
	JRST	BADSPC		;BUT SOMETHING ELSE WAS FOUND
	POPJ	P,		;GIVE UP ON FILESPEC
DEVICE:	MOVE	P1,T1		;SAVE DEVICE NAME
	JRST	SPEC1		;AND CONTINUE
FILE:	OP	S,EXTFLG,TLOE,TROE  ;2 DOTS
	JRST	BADSPC		;YES. ERROR
	MOVE	P2,T1		;SAVE FILE NAME
	JRST	SPEC1		;AND LOOP BACK FOR MORE
PPN:	IFON	S,EXTFLG	;EXTENSION?
	SKIPA	P3,T1		;YES. STORE
	MOVE	P2,T1		;NO. STORE AS A FILE NAME
	PUSHJ	P,OCTIN		;GET PROJECT
	  GETPPN N,		;LOAD THE DEFAULT
	CAIE	C,","		;AND MUST BE FOLLOWED BY ,
	JRST	BADPPN		;INVALID
	HRLZ	P5,N		;STORE PROJECT
	PUSHJ	P,OCTIN		;GET PROGRAMMER
	  GETPPN N,		;LOAD THE DEFAULT
	HRR	P5,N		;SAVE PROGRAMMER
ENDSPC:	CAIN	C,12		;LET LINE FEED WIN ALSO
	POPJ	P,		;RETURN IF <LF>
	CAIE	C,"]"		;MUST BE FOLLOWED BY ]
	JRST	CHKSFD		;NOT ] LF OR EOL TRY ,
	POPJ	P,		;RETURN
CHKSFD:	CAIE	C,","		;COMMA?
	JRST	BADPPN		;NO--ERROR
	PUSHJ	P,SIXIN		;GET THE SFD
	  JRST	ENDSPC		;NULL SFD
	TELL	OPR,NOTSFD	;IGNORE THE SFD
	JRST	ENDSPC		;LOOK FOR ]
BADPPN:	TELL	OPR!ERR,NOPPN	;FUNNY PPN
	JRST	.+2		;SKIP THE TELL
BADSPC:	TELL	OPR!ERR,NOSPC	;PRINT MESSAGE
	SETZB	P1,P2		;FORCE INIT FAILURE
	POPJ	P,		;RETURN
;SUBROUTINE TO INPUT A SIXBIT WORD (A-Z AND 0-9 ONLY VALID CHARS.)
;CALL WITH:
;	PUSHJ	P,SIXIN
;	  RETURN HERE IF NOTHING FOUND
;	RETURN HERE WITH WORD IN T1
;
SIXIN:	SETZ	T1,		;CLEAR RESULT
	MOVE	T2,[POINT 6,T1];SET UP A BYTE POINTER
SIXLPI:	PUSHJ	P,TYI		;GET A CHAR
	CAIN	C,12		;LINE FEED
	JRST	CKT1		;YES. CHECK RESULT
	CAIL	C,"0"		;STANDARD CHECK
	CAILE	C,"Z"		; FOR ALPHABETIC
	JRST	CKT1		; OR NUMERIC DATA
	CAILE	C,"9"		; ANYTHING THAT FAILS
	CAIL	C,"A"		; IS CONSIDERED A TERMINAL
	JRST	.+2
	JRST	CKT1		; CHARACTOR
	SUBI	C,40		;CONVERT TO SIXBIT
	TLNE	T2,770000	;MORE THAN 6 CHARS?
	IDPB	C,T2		;STORE
	JRST	SIXLPI		;LOOP GO MORE
CKT1:	JUMPN	T1,CPOPJ1	;DID WE FIND A CHAR
	POPJ	P,		;NO. PUNT
;SUBROUTINE TO READ IN AN OCTAL NUMBER
;CALL WITH:
;	PUSHJ	P,OCTIN
;	  RETURN HERE IF NOTHING TO GET
;	RETURN HERE WITH NUMBER IN N
;
OCTIN:	SETZ	N,		;CLEAR N
OCTLPI:	PUSHJ	P,TYI		;GET A CHAR
	CAIG	C,"7"		;VALID OCTAL NUMBER
	CAIGE	C,"0"
	JRST	CKOCT		;NO. MUST BE DELIMITER (OR ERROR)
	LSH	N,3		;MAKE ROOM FOR THE DIGIT
	ORI	N,-60(C)	;STICK IT IN
	JRST	OCTLPI		;LOOK FOR MORE
CKOCT:	JUMPN	N,CPOPJ1	;NUMBER FOUND
	POPJ	P,		;NOPE.
;SUBROUTINE TO INPUT ONE CHAR HANDLING SYNTAX
;CALL WITH:
;	PUSHJ	P,TYI
;	RESULT IN C
TYI:	PUSHJ	P,TYIA1		;GET A CHAR
	CAIGE	C,"A"+40	;BIGGER THAN L.C. A
	POPJ	P,		;NO. U.C.
	CAIG	C,"Z"+40	;BIGGER THAN L.C  Z
	SUBI	C,40		;NO. CONVERT TO U.C.
	POPJ	P,		;YES. RETURN
;HERE TO GRAB A CHAR FROM OPR
TYIA1:	SKIPE	C,SAVCHR	;OLD CHAR?
	JRST	DOCHAR		;YES. PROCESS IT
TYIA:	INCHSL	C		;ANYTHING TO READ?
	SKIPA	C,[12]		;NO--SEND A TERMINATOR (DON'T LOG)
DOCHAR:	IDPB	C,BP		;SAVE FOR LOG
	SETZM	SAVCHR		;CLEAR FUDGED CHAR
	CAIE	C,"Z"-100	;IS IT A CONTROL-Z OR A
	CAIN	C,"C"-100	; CONTROL-C?
	JRST	XITCOM		;YES--MONRET
	CAIE	C,33		;MAKE ALL THE
	CAIN	C,176		; ALTMODES AND
	MOVEI	C,12		; A ^Z LOOK LIKE
	CAIE	C,175		; A LINE FEED SO
	CAIN	C,"Z"-100	; THE OPERATOR CAN
	MOVEI	C,12		; PLAY GAMES.
	CAIE	C,15		;CARRAGE RETURN
	CAIN	C,177		;RUBOUT
	JRST	TYIA		;GET A NEW CHAR
	CAIN	C,11		;TAB?
	MOVEI	C,40		;YES. SAME AS BLANK
	CAIE	C,12		;LINE FEED?
	JRST	TYI1		;NO. GOTO TYI1
	OFF	S,SCLN!SPAC	;YES. CLEAR BITS
;	IFON	S,HYPH,TYIA	;HYPHENATED COMMAND
	POPJ	P,

	
TYI1:	CAIN	C,";"		;COMMENT
	OP	S,SCLN,TLOA,TROA;YES. LIGHT BIT
	OP	S,SCLN,TLNE,TRNE;NO.  ARE WE IN A COMMENT
	JRST	TYIA		;YES. IGNORE
	CAIE	C," "		;SPACE?
	JRST	TYI2		;NO. GOTO TYI2
	IFON	S,SOME		;ANYTHING?
	ON	S,SPAC		;YES. GIVE EXACTLY 1 SPACE
	JRST	TYIA		;NO. IGNORE SPACE
TYI2:	MOVEM	C,SAVCHR	;SAVE FOR FUDGING
	OP	S,SPAC,TLZN,TRZN;NEED A SPACE
	JRST	TYI3		;NO. GOTO TYI3
	MOVEI	C," "		;YES. FUDGE TO BLANK
	JRST	TYI8		;RETURN
TYI3:;	OP	S,HYPH,TLZN,TRZN;HYPHEN
;	JRST	TYI4		;NO. GOTO TYI4
;	MOVEI	C,"-"		;YES. FUDGE TO BE -
;	JRST	TYI8		;AND RETURN
TYI4:	SETZM	SAVCHR		;CLEAR FUDGE FLAG
;	CAIE	C,"-"		;IS THIS A HYPHEN
;	JRST	TYI8
;	ON	S,HYPH		;YES. SET FLAG
;	JRST	TYIA		;SEE IF NEXT IS LF
TYI8:	ON	S,SOME		;SOMETING SEEN
	POPJ	P,		;RETURN
SUBTTL	MESSAGE HANDLER

;HERE FROM LOCATOIN 40 ON THE TELL UUO. SINCE THERE IS ONLY 1
;USER UUO NO CHECKING OF THE OP CODE IS NEEDED

	LOWSEG
UUOL:	MOVEM	N,SAVN#		;SAVE N
	MOVEM	T1,SAVT1#	;SAVE T1
	PUSHJ	P,SAVALL	;SAVE THE AC'S
	PUSHJ	P,GETSPL	;GET THE SPOOLER
	PJRST	UUOH		;PROCESS THE UUO
	TOPSEG
UUOH:	MOVE	P1,.JBUUO	;PICK UP THE UUO
	HRLI	P1,440700	;CONVERT TO BYTE POINTER
	LDB	T1,PAC		;PICK UP THE AC BITS
	DPB	T1,PS		;SAV3 IN STATUS REG.
	IFON	S,TELUSR	;IF THIS IS FOR THE USER
	OFF	S,FFSEEN	; THEN WE ARE NOT AT TOP OF FORM
	IFOFF	S,TELOPR,ERRCK1	;IF THIS IS NOT TO OPR. DON'T COMPUTE
	IFON	S,TERR		;IS THIS AN ERROR MESSAGE?
	SKIPA	T1,EMSGLV	;YES. GET ERROR PRIO
	MOVE	T1,CMSGLV	;NO. GET CHATTY MESSAGE LEVEL
	ILDB	C,P1		;GET PRIO OF MESSAGE?
	CAMG	C,T1		;IS IT BIGGER?
	OFF	S,TELOPR	;NO. DO NOT PRINT.
	ILDB	P2,P1		;SAVE INITIAL LENGTH
	MOVE	P3,LMSGLV	;SAVE LENGTH OPR WANTS
ERRCK1:	IFOFF	S,TERR,TLOOP	;ERROR?
	MOVEI	C,"?"		;YES. PRINT A
	PUSHJ	P,SEND		; QUESTION MARK
TLOOP:	ILDB	C,P1		;GET A CHAR
	JUMPE	C,UUORST	;JUMP IF NULL
	IFOFF	S,TERR		;ERROR MESSAGE?
	IFOFF	S,TNOACT	;ACTION ALLOWED?
	PUSHJ	P,DOACT		;YES. IS THIS ACTIVE
	  PUSHJ	P,SEND		;NO. JUST PRINT
	JRST	TLOOP		;DO NEXT CHAR
UUORST:	OFF	S,STAMPB	;CLEAR A BIT
	IFOFF	S,NOCLOS	;SKIP IF MANY UUO'S IN A ROW
	OUTPUT	TTY,		;EMPTY THE BUFFERS
	POPJ	P,		;RETURN
;SUBROUTINE TO PROCESS ACTION CHARS
;CALL WITH:
;	MOVE	C,CHAR-TO-CHECK
;	PUSHJ	P,DOACT
;	  NO SPECIAL ACTION
;	ACTION TAKEN
;ALL ACS PRESERVEVED UNLESS ACTION SAYS OTHERWISE
DOACT:	ACTCHR	<^>,A5		;PRINT FILE NAME
	ACTCHR	<[>,A6		;PRINT FILES UFD NAME
	ACTCHR	<]>,A7		;PRINT USERS PP,N
	ACTCHR	<;>,A8		;CHANGE LENGTH CODE
	ACTCHR	<+>,A9		;PRINT T1 AS SIXBIT
	ACTCHR	<#>,A10		;PRINT N AS DECMAL NUMBER
	ACTCHR	<@>,A11		;PRINT CURRENT TIME
	ACTCHR	<_>,A12		;PRINT CURRENT DATE
	ACTCHR	<&>,A13		;PRINT N AS OCTAL
	CAIN	C,42		;PRINT PROTECTION?
	JRST	A14		;YES--GO DO IT
	POPJ	P,		;RETURN - NOTHING DONE


;SUBROUTINE TO PRINT A SIXBIT VALUE PASSED TO MESSAGE HANDLER
;CALL WITH:
;	PUSHJ	P,A9
;	  NEVER RETURN HERE
;	RETURN	HERE
;
A9:	MOVE	T5,SAVT1	;PICK UP WORD
	PUSHJ	P,SIXOUT	;PRINT IT
	JRST	CPOPJ1		;SKIP RETURN


;SUBROUTINE TO PRINT N AS DECMAL
A10:	AOS	(P)		;SKIP RETURN
	MOVE	N,SAVN		;RESTORE N
	PJRST	DECOUT		;PRINT AND RETURN

;SUBROUTINE TO PRINT THE TIME
A11:	AOS	(P)		;CAUSE A SKIP
	PJRST	PRTIME		;PRINT TIME THEN RETURN

;SUBROUTINE TO PRINT THE DATE

A12:	AOS	(P)		;CAUSE A SKIP
	PJRST	PRDATE		;PRINT THE DATE



;SUBROUTINE TO PRINT N IN OCTAL
A13:	AOS	(P)
	MOVE	N,SAVN
	PJRST	OCTOUT
;SUBROUTINE TO PRINT A FILE NAME
;CALL WITH:
;	PUSHJ	P,A5
;	  NEVER RETURNS HERE
;	ALWAYS SKIP RETURN
;USES C, T5 AND N
A5:	MOVE	T5,DFSTR	;GET STR NAME
	JUMPE	T5,A5A		;DON'T PRINT COLON ON NULL DEVICE
	PUSHJ	P,SIXOUT	;PRINT IT
	MOVEI	C,":"		;DELIMIT WITH A
	PUSHJ	P,SEND		; DOUBLE DECKER PERIOD
A5A:	MOVE	T5,DFNAME	;PICK UP FILE NAME
	PUSHJ	P,SIXOUT	;AND PRINT IT
	HLLZ	T5,DFEXT	;GET EXTENSION
	JUMPE	T5,CPOPJ1	;GO AWAY IF NULL
	MOVEI	C,"."		;PRINT A DOT
	PUSHJ	P,SEND		; ..
	AOS	(P)		;CAUSE SKIP RETURN
	PJRST	SIXOUT		;AND PRINT EXT
;SUBROUTINE TO TYPE A PROJECT PROGRAMMER PAIR
;CALL WITH:
;	PUSHJ	P,A6
;	 -OR-
;	PUSHJ	P,A7
;USES C,N, AND T5
A6:	PUSHJ	P,SAV2		;SAVE AN AC
	MOVEI	P2,DFDIR	;SET UP DIRECTORY
	JRST	.+3		;SKIP USER STUFF
A7:	PUSHJ	P,SAV2		;SAVE 2 AC'S
	MOVEI	P2,DFUSR	;SET UP USER
	MOVE	P1,(P2)		;GET PPN
	JUMPE	P1,CPOPJ	;DO NOT PRINT [0,0]
	MOVEI	C,"["		;TYPE A SQUARE BRACKET
	PUSHJ	P,SEND		; ..
	HLRZ	N,P1		;PRINT THE PROJECT NUMBER
	PUSHJ	P,OCTOUT	;IN OCTAL
	MOVEI	C,","		;TYPE A COMMA
	PUSHJ	P,SEND		; BETWEEN PROJECT AND PROG
	HRRZ	N,P1		;SET UP PROG
	PUSHJ	P,OCTOUT	;AND PRINT IT
A7.1:	AOS	P2		;POINT TO NEXT WORD
	SKIPN	T5,(P2)		;IS THERE AN SFD SPEC
	JRST	A7.2		;NO--PRINT ] AND LEAVE
	MOVEI	C,","		;SET UP A ,
	PUSHJ	P,SEND		; AND PRINT IT.
	PUSHJ	P,SIXOUT	;PRINT THE SFD
	JRST	A7.1		;LOOP FOR NEXT SFD
A7.2:	MOVEI	C,"]"		;TYPE A CLOSE SQUARE BRACKET
	AOS	(P)		;CAUSE SKIP RETURN
	PJRST	SEND		;AND SEND LAST CHAR

;SUBROUTINE TO CHANGE LENGTH CODE
;CALL WITH:
;	PUSHJ	P,A8		;P1 IS A BYTE POINTER TO CODE
;	  NEVER RETURNS HERE
;	RETURN
;
A8:	ILDB	P2,P1		;CHANGE CODE
	JRST	CPOPJ1		;RETURN (SKIP)

;SUBROUTINE TO PRINT AT LEAST 3 OCTAL DIGITS
A14:	AOS	(P)
	MOVE	N,SAVN		;PICK UP N
	MOVEI	C,"0"		;LOAD C IF IT IS NEEDED
	CAIL	N,100		;3 DIGITS?
	PJRST	OCTOUT		;YES--JUST PRINT
	PUSHJ	P,SEND		;TYPE THE 0
	CAIL	N,10		;2 DIGITS
	PJRST	OCTOUT		;YES--JUST SEND
	PUSHJ	P,SEND		;TYPE THE 2ND 0
	PJRST	OCTOUT		;TYPE THE LAST DIGIT
;SUBROUTINE TO PRINT A NUMBER IN ANY RADIX
;CALL WITH:
;	MOVE	N,NUMBER-TO-PRINT
;	PUSHJ	P,OCTOUT
;
;	-OR-
;
;	MOVE	N,NUMBER-TO-PRINT
;	PUSHJ	P,DECOUT
;
;	-OR-
;
;	MOVEI	T5,RADIX
;	MOVE	N,NUMBER-TO-PRINT
;	PUSHJ	P,ANYRDX
;
;AC CA IS CLOBBERED CUSTOMER MUST SAVE HIMSALF
;
DECOUT:	SKIPA	T5,TEN		;BASE TEN
OCTOUT:	MOVEI	T5,10		;BASE EIGHT
ANYRDX:	JUMPGE	N,RDXOUT	;JUMP IF POSITIVE
	MOVEI	C,"-"		;LOAD A MINUS
	PUSHJ	P,SEND		;PRINT IT
	MOVM	N,N		;MAKE POSITIVE
RDXOUT:	IDIVI	N,(T5)		;FIND THE REMAINDER
	HRLM	CA,(P)		;PUSH ONTO STACK
	SKIPE	N		;FINISHED?
	PUSHJ	P,RDXOUT	;NO. RECUR
	HLRZ	C,(P)		;YES. POP OFF A DIGIT
	ADDI	C,60		;CONVERT TO ASCII
	PJRST	SEND		;PRINT THE DIGIT
;SUBROUTINE TO PRINT AC AS SIXBIT
;CALL WITH:
;	MOVE	T5,WORD-TO-PRINT
;	PUSHJ	P,SIXOUT
;	RETURN IS ALWAYS HERE
;USES C,N AND T5
SIXOUT:	SETZ	T4,		;CLEAR A TEMP
	JUMPE	T5,CPOPJ	;ANYTHING LEFT?
	LSHC	T4,6		;SHIFT IN ANOTHER CHAR
	MOVEI	C,40(T4)	;PUTCHAR IN C
	PUSHJ	P,SEND
	JRST	SIXOUT		;LOOP FOR MORE
;SUBROUTINE TO PLACE A CHAR IN ALL THE PROPER BUFFERS
;CALL WITH:
;	PUSHJ	P,SEND (CHAR IN C, FLAGS IN S)
;	RETURN HERE
;ALL AC'S RESPECTED (AT SOME PAIN)
;
SEND:	IFOFF	S,TELOPR,SLOG	;SHOULD WE GIVE TO OPSER
	CAMG	P2,P3		;ARE YOU SURE?
	JRST	SLOG		;NO.
	SOSLE	TTCNT		;ROOM IN THE BUFFER?
	JRST	TTDPB		;YES. GO STORE
	OUT	TTY,0		;NO. ADVANCE BUFFERS
	  JRST	TTDPB		;ALL IS WELL
	OUTSTR	TTIOER		;TRY TO TELL OPERATOR
	STOPCD	.+1		;HALT
TTDPB:	IDPB	C,TTBPT		;DEPOSIT
SLOG:	IFOFF	S,TELLOG,SDEV	;LOG THIS MESSAGE
	OP	S,STAMPB,TLON,TRON  ;PUT A TIME STAMP
	PUSHJ	P,STAMP		; ON EACH MESSAGE
	SOSG	LOGCNT		;ROOM IN LOG BUFFER?
	PUSHJ	P,PUTLOG	;WRITE OUT THE BUFFER
LOGDPB:	IDPB	C,LOGBPT	;PLACE THE BYTE IN BUFFER
SDEV:	IFON	S,TELUSR	;PRINT DIRECTLY?
	IFN	LPTSPL,<	;THE LINE PRINTER IS EASY.
	PJRST	DEVOUT>		;YES. CALL DEVICE DEPENDANT CODE
	IFN	PTPSPL,<	;IF THIS IS PTPSPL
	PJRST	PICTUR>		;MAKE IT SO IT CAN BE SEEN.
TEN:	POPJ	P,^D10		;RETURN,RH IS A CONSTANT
;SUBROUTINE TO SET UP PSEUDO-BUFFER HEADER
;CALL WITH:
;	PUSHJ	P,SETLOG
;	RETURN
;
SETLOG:	PUSHJ	P,SAV1		;SAVE A TEMP
	MOVE	P1,[POINT 7,LOGOBF]
	MOVEM	P1,LOGBPT	;STORE BYTE POINTER
	MOVEI	P1,5*140	;SHORT COUNT TO
	MOVEM	P1,LOGCNT	; ALLOW OVERFLOW
	SETZM	LOGOBF		;CLEAR THE BUFFER
	MOVE	P1,[LOGOBF,,LOGOBF+1]
	BLT	P1,LOGOBF+177	;RQB!!
	POPJ	P,		;RETURN
;SUBROUTINE TO WRITE BUFFER IN LINE MODE (SORT OF)
;CALL WITH:
;	PUSHJ	P,PUTLOG	;PUT OUT IN LINE MODE
;
;	-OR-
;
;	PUSHJ	P,FINLOG	;PUT OUT ANYTHING THAT EXISTS
;				; CALLED AT EOJ
;
PUTLOG:	CAIE	C,12		;END OF LINE?
	POPJ	P,		;NO--IGNORE 
FINLOG:	PUSHJ	P,SAV5		;GRAB SOME AC'S
	SKIPE	P2,Q.LOG	;IS THERE A LOG FILE?
	SKIPN	LOGOBF		; WHICH IS NOT EMPTY?
	JRST	SETLOG
	MOVEI	P1,MAXUUO	;GET THE BIGGEST UUO
	MOVEM	P1,UUOBLK	;STORE AWAY
	SKIPN	P1,Q.FRNM(P2)	;WAS FILE RENAMED
	MOVE	P1,Q.FNAM(P2)	;NO--GET THE NORMAL NAME
	MOVEM	P1,RBNAM	;STORE THE NAME
	MOVSI	P1,'QUD'	;RENAMED EXTENSION IS .QUD
	SKIPN	Q.FRNM(P2)	;IS IT RENAMED?
	MOVE	P1,Q.FEXT(P2)	;NO--USE REAL EXTENSION
	MOVEM	P1,RBEXT	;STORE AWAY
	MOVE	P1,DFQUE	;GET THE PPN
	SKIPN	Q.FRNM(P2)	;WAS THE FILE RENAMED?
	MOVE	P1,Q.FDIR(P2)	;NO--GET REAL PPN
	MOVEM	P1,RBPPN	;STORE THE PPN
	MOVE	P4,Q.FSTR(P2)	;GET THE STR
	MOVEI	P3,17		;SET IN A MODE
	SETZ	P5,
	OPEN	LOGF,P3		;OPEN THE LOG
	POPJ	P,		;PUNT
	PUSH	P,T1		;SAVE T1
	PUSH	P,QP		;SAVE QP
	MOVE	T1,[DFNAME,,LOGSAV] ;COPY THE PPN
	BLT	T1,LOGSAV+7	; INTO A SAVE AREA
	XFR	RBNAM,DFNAME	;COPY FILE NAME
	XFR	RBEXT,DFEXT	;COPY EXTENSION
	XFR	RBPPN,DFDIR	;SAVE PPN. SFDSET WILL SET PATH
	MOVEI	QP,(P2)		;COPY POINTER
	IFON	S,SFDMON	;DO WE HAVE SUB FILES?
	PUSHJ	P,SFDSET	;YES--DO GOOD THINGS
	LOOKUP	LOGF,UUOBLK	;FIND THE FILE
	  JRST	LLFAIL		;FAILED
	SKIPE	Q.FRNM(P2)	;WAS FILE RENAMED
	JRST	ENTLOG		;YES--ASSUME OK. IF WE WERE TO CHECK
				; WE WOULD FIND THAT USER CAN NOT WRITE
				; IN [3,3]
	MOVEI	T1,P1		;POINT TO LOC
	HLRZ	P1,RBPRV	;PICK UP PRIV BITS
	LSH	P1,-^D9		;SHIFT TO CORRECT FIELD
	HRLI	P1,4		;ASK ABOUT APPEND
	MOVE	P2,DFDIR	;GET DIRECTORY OF LOOKUP
	MOVE	P3,DFUSR	;GET USERS DIRECTORY
	ACCESS	T1,		;ASK TONY
	  JRST	ENTLOG		;DONT KNOW ASSUME OK
	JUMPN	T1,TPOPJ	;JUMP IF CAN NOT UPDATE. DO NOT COMPLAIN
				; SINCE USERS DON'T UNDERSTAND RENAMED
				; LOG FILES.
ENTLOG:	IFON	S,SFDMON	;SET UP A PATH
	PUSHJ	P,SFDSET	; IF WE NEED ONE
	ENTER	LOGF,UUOBLK	;UPDATE THE FILE
	  JRST	LEFAIL		;WE CANT ENTER
	PUSHJ	P,SIZE		;SET UP FOR USETI
	USETO	LOGF,(T1)	;POSITION THE FILE
	OUT	LOGF,LGIOWD	;WRITE THE BLOCK
	  JRST	.+2		;WON
	JRST	[GETSTS LOGF,N
		 TELL   OPR!USR!ERR,LOGERR
		 JRST   .+1]
	RELEAS	LOGF,		;AVOID DEADLY INTERLOCK
	JRST	TPOPJ		;RESTORE ACS AND RETURN
LLFAIL:	HRRZ	N,RBEXT		;GET FAILURE CODE
	JUMPE	N,ENTLOG	;FILE NOT FOUND IS OK
	PUSHJ	P,LERCOD	;COMPLAIN
	JRST	TPOPJ
LEFAIL:	HRRZ	N,RBEXT		;GET THE ERROR CODE
	PUSHJ	P,LERCOD	;GIVE THE ERROR MESSAGE
TPOPJ:	POP	P,QP		;RESTORE QP
	MOVS	T1,[DFNAME,,LOGSAV] ;PUT BACK THE CORRECT DATA
	BLT	T1,DFDIR+5	;RESTORE PATH
	POP	P,T1		;RESTORE T1
	PJRST	SETLOG		;RETURN VIA SETLOG
;SUBROUTINE TO SET T1 FOR A USETO TO APPEND
;CALL WITH:
;	LOOKUP	D,UUOBLK
;	  STOPCD
;	PUSHJ	P,SIZE
;	ENTER	D,UUOBLK
;	  STOPCD
;	USETO	D,(T1)
;	OUTPUT	D,
;
SIZE:	IFN	OLDMON,<
	HLRE	T1,RBPPN	;GET FILE SIZE
	JUMPG	T1,BUMPT1	;+ MEANS BLOCKS
	MOVMM	T1,RBSIZ	;LOOK LIKE FILSER>
	MOVE	T1,RBSIZ	;GET +WORD COUNT
	JUMPE	T1,BUMPT1	;NEW FILE
	IDIVI	T1,200		;CONVERT TO BLOCKS
	SKIPE	T2
	ADDI	T1,1		;ROUND UP
BUMPT1:	ADDI	T1,1		;POINT TI FIRST FREE BLOCK
	POPJ	P,

;SUBROUTINE TO PUT A TIME STAMP IN THE LOG
;CALL WITH:
;	PUSHJ	P,STAMP
;	RETURN HERE
;NOTE: THIS ROUTINE IS CALLED FROM SEND WHICH IT INTURN
;CALLS (IE. IT IS RECURSIVE) ONLY THOSE AC'S WHICH ARE MODIFIED
;ARE SAVED. ANYONE MODIFING THIS CODE SHOULD CONSULT THE AC USE
;MATRIX IN SPOOL.MAN
;
STAMP:	PUSHJ	P,SAV2		;GET SOME SCRATCH ACS
	PUSH	P,C		;ALSO SAVE SOME GLOBAL
	PUSH	P,T5		;AND TEMPS
	LDB	P2,PS		;SAVE SOME BITS FROM
	MOVEI	P1,LOG		; THE STATUS AC AND
	DPB	P1,PS		; PUT IN OUR OWN BITS
	PUSHJ	P,PRTIME	;PRINT THE TIME
	IFON	P2,ERR		;ERROR?
	SKIPA	T5,[EXP PREFIX+<SIXBIT .  ERR .>] ;YES
	MOVE	T5,[EXP PREFIX+<SIXBIT .  MSG .>] ;NO.
	MOVEI	C," "		;PRINT A SPACE
	PUSHJ	P,SEND		;.. 
	OP	S,SLOGB,TLZE,TRZE;OPERATOR COMMAND?
	MOVE	T5,[EXP PREFIX+<SIXBIT .  OPR .>] ;YES
	PUSHJ	P,SIXOUT	;PRINT THE KEY WORD
	MOVEI	C,11		;PRINT A TAB
	PUSHJ	P,SEND		; ..
	DPB	P2,PS		;RESTORE THE BITS
	POP	P,T5		; AND THE AC'S
	POP	P,C		; THAT WE SAVED
	POPJ	P,0		;AND RETURN

;ROUTINE TO PRINT TIME
;CALL WITH:
;	PUSHJ	P,PRTIME
;	RETURN HERE
;
PRTIME:	PUSHJ	P,SAV2		;GET SOME SCRATCH AC'S
	MSTIME	P1,		;PICK UP THE TIME OF DAY
PRTIM1:	IDIVI	P1,^D60000	;MILLISECS PER MIN
	PUSH	P,P2		;SAVE REMAINDER
	IDIVI	P1,^D60		;MAKE HOURS
	MOVE	N,P1		;MOVE TO BETTER AC
	PUSHJ	P,TWODIG	;PRINT HOURS AS TWO DIGITS
	MOVEI	C,":"		;PRINT A DELIMITER
	PUSHJ	P,SEND		; ..
	MOVE	P1,P2		;PRINT HOURS
	PUSHJ	P,PRT2		; ..
	MOVEI	C,":"		; DELIMIMIT THE HOURS
	PUSHJ	P,SEND		; FROM THE SECONDS
	POP	P,P1		;RESTORE SECONDS
	IDIVI	P1,^D1000	;THROW AWAY THE MS
PRT2:	MOVE	N,P1		;SETUP FOR DECOUT
;FALL INTO TWODIG

;SUBROUTION TO PRINT AT LEASE 2 DECMAL DIGITS
;CALL WITH:
;	MOVE	N,NUMBER-T0-PRINT
;	PUSHJ	P,TWODIG
;	RETURN HERE
;
TWODIG:	MOVEI	C,"0"		;ALWAYS PRINT 2 DIGITS
	CAIGE	N,12		;IF LESS TAN 10
	PUSHJ	P,SEND
	PJRST	DECOUT		;PRINT N AS DECMAL
;SUBROUTIN TO PRINT THE DATE
;CALL WITH:
;	PUSHJ	P,PRDATE
;	RETURN HERE
;
PRDATE:	PUSHJ	P,SAV5		;SAVE 5 AC'S
	DATE	P1,		;GET THE DATE
	JRST	.+2		;SKIP THE SAVE
PRDAT1:	PUSHJ	P,SAV5		;SAVE THE PRESERVED AC'S
	IDIVI	P1,^D31		;GET THE DAY
	MOVEI	N,1(P2)		;ADD AND MOVE
	PUSHJ	P,TWODIG	;PRINT THE DAY
	IDIVI	P1,^D12		;GET THE MONTH
	MOVE	P4,[POINT 7,MNTAB(P2)] ;LOAD A BYTE POINTER
	MOVEI	P3,5		;CHAR COUNT
	ILDB	C,P4		;LOAD A CHAR
	PUSHJ	P,SEND		;SHIP IT
	SOJG	P3,.-2		;LOOP OVER WORD
	MOVEI	N,^D64(P1)	;ADD YEAR ZERO
	PJRST	DECOUT		;AND PRINT
MNTAB:	ASCII	/-Jan-/
	ASCII	/-Feb-/
	ASCII	/-Mar-/
	ASCII	/-Apr-/		;OR IS IT CPU
	ASCII	/-May-/	
	ASCII	/-Jun-/	
	ASCII	/-Jul-/
	ASCII	/-Aug-/
	ASCII	/-Sep-/
	ASCII	/-Oct-/
	ASCII	/-Nov-/
	ASCII	/-Dec-/
SUBTTL	SUBROUTINES WHICH HAVE NOPLACE ELSE TO LIVE
;SUBROUTINE TO FILL DISK INPUT BUFFER
;CALL WITH:
;	PUSHJ	P,FILL
;	  EOF RETURN
;	DATA RETURN (DFCB UPDATED)
	LOWSEG
FILL:	PUSHJ	P,CHKOPR	;PROCESS ANY TYPE-IN
	PUSHJ	P,SAV1		;GO SAVE AN AC
	MOVE	P1,[UPTIME]	;POINTER TO UPTIME
	GETTAB	P1,		;GET FROM MONITOR
	  SETZ	P1,		;CLEAR P1
	CAML	P1,CHKTIM	;TIME TO GIVE A CHKPNT
	PUSHJ	P,DOCHKP	;YES--GIVE A CHKPNT
	SETOM	HNGCNT		;CLEAR THE FLAG
	IN	DSK,		;READ BLOCK
	JRST	CPOPJ1		;ALL OK
	STATZ	DSK,300000	;DATA OR DEVICE ERROR
	JRST	DSKERR		;YES.
	STATZ	DSK,1B22	;EOF?
	POPJ	P,		;YES.
	AOS	DFECT		;CRUEL OR UNUSUAL BIT. QUIT.
;HERE ON DATA/DEVICE ERROR
DSKERR:	GETSTS	DSK,N		;SEE WHAT HAPPENED
	TELL	OPR!LOG!ERR,BADATA
	TRZ	N,740000	;CLEAR ERROR BITS
	SETSTS	DSK,N		;SET THE STATUS BACK
	STATZ	DSK,1B22	;EOF?
	POPJ	P,		;YES.
	SOSLE	DFECT		;TOO MANY ERRORS?
	JRST	CPOPJ1		;IGNORE ERROR AND HELP
	TELL	OPR!USR!LOG!ERR,BABORT
	POPJ	P,

DOCHKP:	PUSHJ	P,SAVALL	;SAVE THE AC'S
	PUSHJ	P,GETSPL	;GET A HISEG
	ADD	P1,MCKPNT	;SKIP TO NEXT POINT
	MOVEM	P1,CHKTIM	;SAVE FOR LATER
	PJRST	TAKCHK		;TAKE A CHKPNT
;SUBROUTINE TO COMPUTE PRIORITY
;CALLED ONLY FROM QMANGR.SHR
;	PUSHJ	P,SCHED
;	RETURN HERE
;AT TIME OF CALL QUEUE AREA IS SET UP WITH
;ENTRY TO EVALUATE. RETURN WITH T1=PRIO
;THIS ROUTINE MUST PRESERVE ALL THE AC'S EXCEPT T1
; WHICH CONTAINS THE ANSWER. P IS THE PUSH DOWN POINTER
; BUT S DOES NOT CONTAIN THE STATUS BITS AND MAY NOT BE
; UPDATED BY THIS ROUTINE
SCHED:	PUSH	P,T2		;SAVE T2
	PUSH	P,T3		;SAVE T3
	SETZ	T1,		;CLEAR OUT ANSWER IN CASE THIS
				; THIS ENTRY IS TOO BIG.
	SKIPE	T3,NXTJOB	;GET NUMBER OF NEXT JOB OR SKIP
	CAME	T3,Q.SEQ	;SKIP IF THIS IS THE NEXT JOB
	JRST	SCHEDJ		;NOT NEXT JOB OR NO NEXT JOB
	HRLOI	T1,377777	;NEXT JOB = THIS JOB SO LAGE PRIO
	JRST	T3POPJ		;RETURN THAT ANSWER
SCHEDJ:	HLRZ	T3,Q.OSIZ	;PICK UP THE LIMIT
	CAMLE	T3,MLIM		;TOO BIG?
	JRST	T3POPJ		;YES--TOO BIG IS TOO BAD
	SKIPG	FAIRCT		;TIME TO PICK OLDEST ENTRY?
	JRST	GETOLD		;YES--GO GET HASTINGS JOB.
	MOVE	T2,[LIMFCT]	;PICK UP LIMIT FACTOR
	IDIVI	T2,(T3)		;DIVIDE BY SIZE
	MOVE	T1,T3		;ADD TO ANSWER (MOVE IS USED BECAUSE
				; T1 IS KNOWN TO BE ZERO.
	HRRZ	T3,Q.OSIZ	;GET OUTPUT SIZE.
	MOVE	T2,[SIZFCT]	;GET THE SIZE FACTOR
	IDIVI	T2,(T3)		;DIVIDE BY SIZE IN BLOCKS
	ADDI	T1,(T2)		;ADD TO PRIORITY
	LDB	T2,P.EPR	;PICK UP EXTERNAL PRIO
	IMULI	T2,EPRFCT	;MULTIPLY BY EXTERNAL FACTOR
	ADDI	T1,(T2)		;ADD TO PRIORITY
	HLRZ	T2,Q.PRI	;GET CUSTOMER VALUE
	IMULI	T2,CSTFCT	;MULTIPLY BY CUSTOMER FACTOR
	ADDI	T1,BIAS(T2)	;ADD TO ANSWER. ALSO ADD BIAS
	MOVE	T2,Q.FRM	;GET FORMS TYPE
	CAME	T2,FORMS	;SAME TYPE?
	SUBI	T1,FCHFCT	;NO--SUBTRACT FORMS CHANGE FACTOR
	MOVE	T2,Q.DEAD	;PICK UP DEADLINE
	JUMPE	T2,T3POPJ	;JUMP IF ZERO
	SUB	T2,Q.TIME	;ARE WE LATE?
	JUMPL	T2,T3POPJ	;NO-- DO NOT SWEAT
	IMULI	T2,DEDFCT	;MULTIPLY BY DEADLINE FACTOR
	ADD	T1,T2		;ADD TO PRIO
	JRST	T3POPJ		;RETURN
GETOLD:	MOVE	T1,[377777777777]
	SUB	T1,Q.CREA	;AGE OF REQUEST
T3POPJ:	POP	P,T3		;RESTORE T3
	POP	P,T2
	POPJ	P,
;SUBROUTINE TO CALL QMANGR.SHR
;CALL WITH:
;	PUSHJ	P,Q
;	  RETURN HERE WITH A JOB IN THE PARAMETER AREA
;	RETURN HERE IF NOTHING TO DO
;ALL AC'S PRESERVED
	TOPSEG
Q:	MOVSI	T1,SCHED	;PLACE ADDRESS OF SCHED
	HLLM	T1,Q.OPR	; IN Q.OPR
	MOVEI	T1,CUSP		;PLACE THE CUSP CODE
	DPB	T1,P.RCP	; WHERE QMANGR WILL FIND IT
	MOVSI	T1,(DEV)	;SET UP Q.DEV SINCE
	MOVEM	T1,Q.DEV	;IT IS ALWAYS NEEDED
	MOVE	T1,LPDEV	;GET PHYSICAL NAME OF OUTPUT DEVICE
	MOVEM	T1,Q.PDEV	;SAVE FOR QMANGR
	MOVE	T1,[QSIZE,,Q.BLK] ;POINTER WORD
	PUSHJ	P,QUEUER##	;CALL QMANGR
	SKIPN	Q.DEV		;Q.DEV=0
	AOS	(P)		;NO. SKIP RETURN
	POPJ	P,0		;YES. NON-SKIP RETURN
	LOWSEG

;SUBROUTINE TO SET UP FOR A FILE IN A SUB FILE DIRECTORY
;CALL WITH:
;	MOVEI	QP,POINTER-TO-QUEUE-ENTRY
;	PUSHJ	P,SETSFD
;	RETURN HERE WITH THE FULL PATH IN DFDIR AND
;	  RBPPN SET TO POINT TO A PATH SPECIFICATION
;USES T1
SFDSET:	MOVEI	T1,DFPTH		;GET ADDRESS OF PATH
	SKIPN	Q.FRNM(QP)		;WAS FILE RENAMED?
	MOVEM	T1,RBPPN		;NO--STORE POINTER
	HRLZI	T1,Q.FDIR(QP)		;GET ADDRESS OF PATH
	HRRI	T1,DFDIR		; AND A PLACE TO PUT IT
	BLT	T1,DFDIR+5		;MOVE THE DATA
	POPJ	P,			;RETURN
;HERE WHEN THE OUTPUT DEVICE IS HUNG
INT1:	PUSH	P,INTLOC+2
	PUSHJ	P,SAVALL	;SAVE THE AC'S
	HLRZ	T1,INTLOC+3	;GET INTERUPT TYPE
	CAIE	T1,1		;DEVICE OK TYPE?
	EXIT	1,		;NO--MUST BE CONTROL-C INTERCEPT
	HRRZ	T1,INTLOC+3	;GET THE CHANNEL
	CAIN	T1,LPT		;OUTPUT DEVICE?
	SKIPN	T1,LPDEV	;YES--ANY DEVICE NAME
	MOVSI	T1,'???'	;NO--THEN WE DON'T KNOW THE DEVICE
	MOVEM	S,UUSAVE	;STORE THE UUO
	OFF	S,TNOACT	;CLEAR THE IAC FLAG
	AOSG	N,HNGCNT	;TELL THE OPR
	TELL	OPR,DEVOK	;TELL THE OPR
	MOVE	S,UUSAVE	;PUT BACK THE WORD
BDWAIT:	SKIPN	P1,ZZZVAL	;SKIP IF OPR GAVE US A VALUE
	MOVEI	P1,SLTIME	;DEFAULT SLEEP TIME
	MOVE	T1,P1		;COPY "SLEEP" ARGUMENT
	IMULI	P1,^D1000	;SET "HIBER" ARGUMENT
	HRLI	P1,20		;"HIBER" WAKE ARGUMENT
	HIBER	P1,		;HIBERNATE
	  SLEEP	T1,		;NO. THEN SLEEP
	PUSHJ	P,CHKOPR	;ANY COMMANDS?


;SUBROUTINE TO SET UP .JBINT
;CALL WITH:
;	PUSHJ	P,SETINT
;	RETURN HERE
;
SETINT:	MOVEI	T1,INTLOC	;LOCATION OF BLOCK
	MOVEM	T1,.JBINT	;STORE IN JOB DATA AREA
	MOVE	T1,[4,,INT1]	;LH=SIZE OF BLOCK - RH=INTERUPT LOCATION
	MOVEM	T1,INTLOC	;SAVE IN BLOCK
	MOVE	T1,[400000,,3]	;LH=DONT PRINT MSG - RH=HNGSTP CALLS
				; ALSO ENABLE FOR CONTROL-C SINCE
				; NEW MONITORS WILL HAVE JACCT SET
				; FOR SPOOLERS.
	MOVEM	T1,INTLOC+1	;STORE IN BLOCK
	SETZM	INTLOC+2	;CLEAR OLD PC
	SETZM	INTLOC+3	;CLEAR CHANNEL #
	POPJ	P,

;SUBROUTINE TO PAUSE FOR THE CORRECT TIME
;CALL WITH:
;	PUSHJ	P,WAIT1
;	RETURN HERE LATER
;
	TOPSEG
WAIT1:	PUSHJ	P,SAV1
	SKIPN	P1,ZZZVAL
	MOVEI	P1,SLTIME	;GET THE DEFAULT
	PUSH	P,T1		;SAVE T1 ON PDL
	MOVE	T1,P1		;COPY ARG INCASE NO HIBER
	SETZ	P1,		;START WITH FRESH "P1"
	HRLI	P1,400020	;HIBERNATE ARGUMANTS
				; GET SWAPPED OUT NOW
				; WAKE ON ANY LINE OF INPUT
WAIT2:	HIBER	P1,		;HIBERNATE
	SLEEP	T1,		;SLEEP IF HIBER FAILS
	POP	P,T1		;PUT T1 BACK
	POPJ	P,		;RETURN

;SUBROUTINE TO ASK OPR TO CHANGE OUTPUT FORMS
;CALL WITH:
;	PUSHJ	P,MOUNT
;	RETURN HERE WITH DEVICE READY
;
MOUNT:	MOVEM	T1,FORMS	;SAVE FOR COMPARE
	SKIPN	T1		;ZERO IMPLIES STANDARD
	MOVE	T1,[SIXBIT ^STD.^]
	TELL	OPR,MOUNTM	;ASK OPR TO MOUNT
IFN LPTSPL,<
	MOVEI	C,14		;GIVE A FORM FEED
	PUSHJ	P,DEVOUT	; SO FORMS CAN BE CHANGED>
	OUTPUT	LPT,		; MORE EASILY.
	PJRST	STOP		;AND WAIT FOR ACTION
	LOWSEG
SUBTTL 	PUSH DOWN LIST MANIPULATION ROUTINES
;SUBROUTINE TO SAVE AC P1
;CALL WITH:
;	PUSHJ	P,SAV1
;	RETURN IS ALWAYS HERE
SAV1:	EXCH	P1,(P)		;SAVE P1
	PUSHJ	P,(P1)		;RETURN
	  JRST	.+2		;NON-SKIP RETURN
	AOS	-1(P)		;CAUSE SKIP RETURN
	JRST	RST1		;RESTORE ACS
;SUBROUTINE TO SAVE ACS P1-P2
;CALL WITH:
;	PUSHJ	P,SAV2
;	RETURN IS ALWAYS HERE
SAV2:	EXCH	P1,(P)		;SAVE P1
	PUSH	P,P2		;SAVE P2
	PUSHJ	P,(P1)		;RETURN
	  JRST	.+2		;NON-SKIP RETURN
	AOS	-2(P)		;SKIP RETURN
	JRST	RST2		;RESTORE ACS
	COMMENT	*
THESE SUBS NEVER CALLED BUT BAY BE NEEDED LATER
;SUBROUTINE TO SAVE ACS P1-P3
;CALL WITH
;	PUSHJ	P,SAV3
;	RETURN IS ALWAYS HERE
SAV3:	EXCH	P1,(P)		;SAVE P1
	PUSH	P,P2		;SAVE P2
	PUSH	P,P3		;SAVE P3
	PUSHJ	P,(P1)		;RETURN
	  JRST	.+2		;NON-SKIP RETURN
	AOS	-3(P)		;SKIP RETURN
	JRST	RST3		;RESTORE ACS


;SUBROUTINE TO SAVE ACS P1-P4
;CALL WITH
;	PUSHJ	P,SAV4
;	RETURN IS ALWAYS HERE
SAV4:	EXCH	P1,(P)		;SAVE P1
	PUSH	P,P2		;SAVE P2
	PUSH	P,P3		;SAVE P3
	PUSH	P,P4		;SAVE P4
	PUSHJ	P,(P1)		;RETURN
	  JRST	.+2		;NON-SKIP RETURN
	AOS	-4(P)		;SKIP RETURN
	JRST	RST4		;RESTORE P4
	*
;SUBROUTINE TO SAVE ACS P1-P5
;CALL WITH
;	PUSHJ	P,SAV5
;	RETURN IS ALWAYS HERE
SAV5:	MOVE	CA,(P)		;GET ADDRESS
	MOVEM	P1,(P)		;SAVE P1
	PUSH	P,P2		;SAVE P2
	PUSH	P,P3		;SAVE P3
	PUSH	P,P4		;SAVE P4
	PUSH	P,P5		;SAVE P5
	PUSHJ	P,(CA)		;RETURN
	  JRST	.+2		;NON-SKIP RETURN
	AOS	-5(P)		;SKIP RETURN
	POP	P,P5
RST4:	POP	P,P4		;RESTORE P4
RST3:	POP	P,P3		;RESTORE P3
RST2:	POP	P,P2		;RESTORE P2
RST1:	POP	P,P1		;RESTORE P1
	POPJ	P,		;RETURN TO ORIGINAL CALLER


;ROUTINES TO MANIPULATE THE PDL
CPOPJ1:	AOS	(P)		;SKIP RETURN
CPOPJ:	POPJ	P,0		;RETURN
;SUBROUTINE TO SAVE ACS 1 TO 16
;AC 0=S AND IS GLOBAL ACCROSS ALL ROUTINES
;AC 17=P AND SHOULD NOT BE PUSHED
;ACS ARE RESTORED AUTOMATICLY UPPON EXIT FROM A ROUTINE
; CALLING SAVALL AND CPOPJ1 RETURNS ARE HANDLED CORRECTLY
;CALL WITH:
;	PUSHJ	P,SAVALL
;	RETURN HERE
;***WARNING*** THIS USES SPACE ON THE PDL VERY QUICKLY AND SHOULD
; BE USED WITH CARE
SAVALL:	EXCH	1,(P)		;PUT AC1 ON PDL
	MOVEM	16,15(P)	;SAVE AC16 ON PDL
	HRRZI	16,1(P)		;DESTAINATION
	HRLI	16,2		;SOURCE
	BLT	16,14(P)	;STORE THE AC'S
	ADD	P,[15,,15]	;UPDATE BOTH HALVES OF P
	MOVE	16,(P)		;PUT AC16 BACK
	PUSHJ	P,(1)		;GO DO YOUR THING
	  JRST	.+2		;NON-SKIP RETURN
	AOS	-16(P)		;CAUSE SKIP RETURN
	HRLZI	16,-15(P)	;FROM HERE
	HRRI	16,1		; TO HERE
	BLT	16,16		;PUT BACK AC'S
	SUB	P,[16,,16]	;UPDATE BOTH HALVES OF P
	POPJ	P,		;RETURN
SUBTTL LPT CONTROL ROUTINES

IFN	CNTRL,<LIST>
IFE	LPTSPL,<XLIST>
IFN	LPTSPL,<

;BITS IN LEFT HALF OF SPECIAL CHARACTOR TABLE
	BIT	N,LFEED,	;THIS IS A LINE FEED
	BIT	N,FRAC,		;THIS CHAR SKIPS A FRACTION OF A PAGE
	BIT	N,FFEED,	;THIS IS A FORM FEED
	BIT	N,TAB,		;THIS IS A TAB
	BIT	N,CTLCH,	;THIS IS A ^N OR A ^O
	BIT	N,COUNT,	;THIS SKIPS A FIXED # OF LINES

CHTAB:	+TAB			;THIS IS A TAB
	+LFEED			;THIS IS A LINE FEED
	+FRAC+3			;THIS SKIPS 1/3 PAGE (VERT TAB)
	+FFEED			;THIS IS A FORM FEED
	Z			;CAR RET
	+CTLCH			;^N
	+CTLCH			;^O
	+FRAC+2			;THIS SKIPS 1/2 PAGE
	+COUNT+2		;THIS SKIPS 2 LINES (DC1)
	+COUNT+3		;THIS SKIPS 3 LINES (DC2)
	+COUNT+1		;THIS SKIPS 1 LINE (DC3)
	+FRAC+6			;THIS SKIPS 1/6 OF A PAGE (DC4)

;FORTRAN CONTROL CHARACTOR TRANSLATION TABLE

PCHTAB:	XWD	024*200+000,023*200+000	;/ *
	XWD	212*200+" ",177*200+000	;0 +
	XWD	014*200+000,021*200+000	;1 ,
	XWD	020*200+000,212*200+"0"	;2 -
	XWD	013*200+000,022*200+000	;3 .

;FILE FORMATS

	ASCII==1
	FORTR==2
	COBOL==3
	CREF==4
	RUNOFF==5

;PRESERVED AC NAMES
	VPOS==P1		;VERTICAL POSITION
	VSPC==P2		;VERTICAL SPACING
;SUBROUTINE TO SET UP FOR LPTIN AND LPTOUT
;CALL WITH:
;	PUSHJ	P,FILOOUT
;	RETURN HERE
;
	TOPSEG
FILOUT:	PUSHJ	P,SAV2		;SAVE P1 AND P2
	IFN	RPW,<		;IF WE SUPPORT /REPORT
	PUSHJ	P,SETLST	;SET UP TEST
>	;END TEST OF RPW
	LDB	P1,P.FFMT	;GET FILE FORMAT
	CAIN	P1,FORTR	;IS THIS FORTRAN?
	OP	S,DAT,TLOA,TROA	;YES--LIGHT A BIT
	OFF	S,DAT		;NO--CLEAR A BIT
	LDB	T1,P.FMT	;PICK UP /PRINT VALUE
	CAIG	T1,4		;TOO BIG?
	SKIPN	T1		;OR ZERO?
	JRST	CHKSPC		;YES--ASSUME ASCII
	JRST	@.(T1)		;DISPATCH
	+SETARO			;ARROW MODE
	+CHKSPC			;ASCII
	+OCTAL			;OCTAL
	+SETSUP			;SUPPRESS MODE
SETSUP:	ON	S,SUPRES	;SET SUPRESS FLAG
SETARO:	ON	S,ARROW		;SET ARROW MODE
CHKSPC:	LDB	VSPC,P.SPC	;GET SPACING CODE
	CAIN	P1,COBOL	;IS THIS SIXBIT COBOL
	JRST	COBDMP		;YES--GO PRINT IT OUT
	SKIPE	VSPC		;SKIP IF ZERO
	SOS	VSPC		; ELSE CONVERT TO # OF LF TO APPEND
	PUSH	P,[GETSPL]	;PUT A RETURN ADDRESS ON THE STACK
	MOVE	VPOS,LPLPP	;START AT TOP OF PAGE
	PJRST	LPTIN0		;GO PRINT THE FILE
;SUBROUTINE TO COMPILE CODE TO TEST EACH LINE FOR A MATCH AGAINST
; THE /REPORT VALUE.
;CALL WITH:
;	PUSHJ	P,SETLST
;	RETURN HERE
;
	IFN	RPW,<		;ONLY NEED FOR /REPORT
SETLST:	PUSHJ	P,SAV5		;SAVE P1 TO P5
	MOVEI	P5,ISLIN-1	;SET UP PDP TO COMPILED CODE
	LDB	T2,P.FFMT	;GET FILE TYPE
	LDB	T1,P.LOE	;PICK UP ENTRY SIZE
	CAIG	T1,Q.FRPT	;IS THIS ENTRY BIG ENOUGH?
	JRST	STLST3		;NO--ALL LINES MATCH
	SKIPN	Q.FRPT(QP)	;SKIP IF /REPORT SPECIFIED
	JRST	STLST3		;IT IS ZERO
	MOVE	T1,[XWD [PUSHJ P,DSKIN
			   JRST EOFPRC
			 CAIE	C,0
			 JRST  FLUSH7],P1]
	BLT	T1,P4		;PLACE CODE IN P1 TO P4
	CAIE	T2,COBOL	;IS IT COBOL?
	JRST	STLST1		;NO--ASCII
	HRRI	P4,FLUSH6	;REPLACE FLUSH7
	HRRI	P1,COBOL6	;REPLACE DSKIN
	TDZA	T5,T5		;CONVERSION FACTOR FOR SIXBIT TO SIXBIT
STLST1:	MOVEI	T5,40		;ADD-ON FOR SIXBIT TO ASCII
	MOVE	T3,[POINT 6,Q.FRPT(QP)] ;POINTER TO LIST
	MOVEI	T4,^D12		;ABSOLUTE LIMIT
STLST2:	ILDB	T1,T3		;GET A CHAR
	JUMPE	T1,STLST5	;JUMP IF DONE
	CAIE	T2,COBOL	;IS THIS THE FIRST TIME
	CAIE	T4,^D12		; PASTED AN ASCII FILE
	JRST	.+2		;NO--CONTINUE
	JRST	STLST4		;YES--CHAR ALRADY IN C
	PUSH	P5,P1		;COMPILE A PUSHJ
	CAIE	T2,COBOL	;COBOL FORMAT?
	PUSH	P5,P2		;NO--WE HAVE AN ERROR RETURN THEN
STLST4:	ADD	T1,T5		;CONVERT CHAR TO FINAL VALUE
	HRRI	P3,(T1)		;PLACE IN CAIE
	PUSH	P5,P3		;COMPILE THE CAIE
	PUSH	P5,P4		;COMPILE THE JRST TO FLUSHX
	SOJG	T4,STLST2	;LOOP FOR WHOLE STRING
STLST5:	CAIN	C,COBOL		;COBOL FORMAT?
	JRST	STLST3		;YES--ALL DONE
	PUSH	P5,P1		;NO--GET NEXT CHAR
	PUSH	P5,P2		; FOR ASCII CODE.
STLST3:	CAIN	T2,COBOL	;COBOL FORMAT?
	PUSH	P5,[JRST COBOL2];YES--MATCH IN COBOL FORMAT
	CAIE	T2,COBOL	;COBOL FORMAT?
	PUSH	P5,[JRST ASCLIN];NO--MATCH IN ASCII FORMAT
	POPJ	P,		;RETURN
>	;END TEST ON RPW
	LOWSEG
;SUBROUTINE TO PRINT A FILE ON THE LINE PRINTER
;CALL WITH:
;	PUSHJ	P,LPTIN
;	HERE ON END OF FILE
;
LPTIN0:	PUSHJ	P,CLRSEG	;CLEAR THE HI-SEG
LPTIN:	PUSHJ	P,DSKIN		;GO GET A CHAR
	  JRST	EOFPRC		;CHARGE FOR THE EOF
	JUMPE	C,LPTIN		;IGNORE NULLS (UNLESS YOU LIKE ^@)
	IFON	S,DAT,DOFORT	;JUMP IF FORTRAN
LPOPJ:	PUSHJ	P,LPTOUT	;PRINT THE CHAR
	JRST	LPTIN		;GET THE NEXT CHAR
DOFORT:	CAIGE	C,40		;PRINTING CHAR?
	JRST	FCKLF		;NO--SEE IF LINE FEED
	IFON	S,FCONV,FORTIT	;JUMP IF CONTROL
	JRST	LPOPJ		;LOOP FOR MORE
FCKLF:	CAIN	C,12		;LINE FEED?
	OP	S,FCONV,TLOA,TROA ;YES--CONVERT THE NEXT CHAR
	PUSHJ	P,DEVOUT	;NO--JUST PRINT
	JRST	LPTIN		;LOOP FOR MORE

;HERE TO CONVERT FORTRAN FORMAT CONTOL DATA TO LPT CONTROL CHARS
FORTIT:	OFF	S,FCONV		;NEXT CHAR IS DATA
	CAIN	C," "		;SPACE?
	JRST	[MOVEI C,12	;YES--CONVERT TO LF
		 JRST  LPOPJ]
	CAIG	C,"3"		;VALID?
	CAIGE	C,"*"		; ..
	JRST	[MOVEM C,SAVCH	;NO--PRINT AS LINE FEED
		 MOVEI C,12	; FOLLOWED BYBAD CHAR
		 JRST  LPOPJ]	;LOOP FOR MORE
	CAIG	C,"."		;LEFT HALF?
	SKIPA	C,PCHTAB-<"*">(C) ;NO--RIGHT HALF
	MOVS	C,PCHTAB-<"/">(C) ;YES--LEFT HALF
	DPB	C,[POINT 7,SAVCH,35] ;SAVE NEXT CHAR
	LSH	C,-7		;SHIFT OFF JUNK
	ANDI	C,377		;EXTRACT CHAR
	TRZE	C,200		;=1 IF STACKED CONTROL CHARS
	ON	S,FCONV		;FORMAT CONVERT
	JRST	LPOPJ		;LOOP FOR MORE

;HERE ON EOF TO CHARGE FOR THE FREE FORM FEED

EOFPRC:	CAME	QP,Q.LOG	;IS THIS THE LOG FILE
	JRST	EOFPR1		;NO--JUST GIVE FF
	ON	S,TNOACT	;NO ACTION
	TELL	USR,LOGOBF	;PRINT LAST PART LOG
	OFF	S,TNOACT	;ACTION
EOFPR1:	IFON	S,FFSEEN	;WILL THERE BE A FEED?
	POPJ	P,		;NO--DONT CHARGE
	MOVNI	N,(VPOS)	;NUMBER OF LINES TO COUNT
	MOVEI	C,14		;LOAD A FORM FEED
	PJRST	CNTDWN		;CHARGE AND RETURN
;SUBROUTINE TO PLACE A CHAR ON THE LINE PRINTER
;CALL WITH:
;	PUSHJ	P,LPTOUT
;	RETURN HERE (EOF SET IF OVER LIMIT)
;
	IFN	RPW,<
ASCLIN:	PUSHJ	P,ISEOL		;END OF LINE?
	  JRST	.+2		;NO--SKIPA
	ON	S,NEWLIN	;YES--LOOK FOR CODE
>
LPTOUT:	CAIG	C,40		;VISABLE ASCII
	JRST	CHKSP		;NO--SEE IF SPACE
LPTOU1:	IFN	RPW,<		;IF WE KNOW ABOUT /REPORT
	OP	S,NEWLIN,TLZE,TRZE ; AND THIS IS A NEW LINE
	JRST	ISLIN		;SEE IF REPORT LINE MATCHES
>	;END TEST ON RPW
	OFF	S,LFSEEN	;CLEAR LINE FEED FLAG
	OFF	S,FFSEEN	;SOMETHING HAS BEEN SEEN
	IFN	FTREM,<
	SKIPE	SPCCNT
	PUSHJ	P,SPCOUT
>
	PJRST	DEVOUT		;PRINT IT
CHKSP:	CAIN	C,40		;IS THIS A SPACE
	IFE	FTREM,<
	PJRST	DEVOUT>
	IFN	FTREM,<
	PJRST	CNTSPC		;GO INCREMENT SPACE COUNT
	CAIG	C,15
	CAIGE	C,12
	JRST	.+2
	SETZM	SPCCNT
	SKIPE	SPCCNT
	PUSHJ	P,SPCOUT>
	CAILE	C,10		;SMALLER THAN 10
	CAILE	C,24		;BIGGER THAN 24
	JRST	DOARO		;YES--GO SEE IF WE NEED AN ARROW
	IFON	S,SUPRES,DOSUP	;JUMP IF SUPRES MODE
	MOVE	N,CHTAB-11(C)	;GET THE BITS
	IFON	N,TAB,LPTOU1	;PRINT THE TAB
	IFON	N,LFEED,DOLF	;PRINT THE LINE FEED
	IFON	N,FFEED,DOFORM	;PRINT THE FORM FEED
	IFON	N,CTLCH,DOARO	;PRINT ^O OR ^N
	IFOFF	N,FRAC,FIXNBR	;JUMP IF THIS MOVES A FIXED # OF LINES
	MOVE	T1,LPLPP	;GET CURRENT PAGE SIZE
	IDIVI	T1,(N)		;FIND THE RIGHT PART
	MOVNI	N,(T1)		;MAKE -VE AND PUT IN N
	JRST	CNTDWN		;GO CHECK QUOTA
	IFN	FTREM,<
CNTSPC:	AOS	N,SPCCNT
	POPJ	P,
SPCOUT:	MOVE	N,SPCCNT
	PUSH	P,C
SPCOT1:	MOVEI	C,40
	PUSHJ	P,DEVOUT
	SOJG	N,SPCOT1
	SETZM	SPCCNT
	POP	P,C
	POPJ	P,
>


	IFN	RPW,<		;ONLY IF REPORT WRITER OUTPUT

;HERE TO THROW AWAY A LINE

FLUSH7:	PUSHJ	P,DSKIN		;GET A BYTE
	  JRST	EOFPRC		;END OF FILE
	PUSHJ	P,ISEOL		;END OF LINE?
	  JRST	FLUSH7		;NO--LOOP FOR REST OF LINE
FLUSH8:	PUSHJ	P,DSKIN		;GET A CHAR
	  JRST	EOFPRC		;END OF FILE
	PUSHJ	P,ISEOL		;END OF LINE?
	  JRST	ISLIN		;NO--FIRST CHAR ON NEW LINE
	JRST	FLUSH8		;YES--LOOP FOR REST OF <EOL>


ISEOL:	CAIL	C,12		;C .GT. 12?
	CAILE	C,24		;C .GT. 24?
	POPJ	P,		;NO--NOT END OF LINE
	CAILE	C,15		;C .LE. 15?
	CAIL	C,20		;C .GE. 20?
	AOS	(P)		;YES--CAUSE SKIP RETURN
	POPJ	P,		;NO--PLAIN RETURN

>	;END TEST ON RPW

;HERE ON A LINE FEED
DOLF:	MOVEI	T1,(VSPC)	;NUMBER OF ADDITIONAL LINE FEEDS
	SETO	N,		;START WITH 1 LINE
	SOJL	T1,CNTDWN	;ANY MORE?
	PUSHJ	P,DEVOUT	;YES--GIVE IT
	SOJA	N,.-2		;AND SUBTRACT FROM QUOTA

;HERE TO PROCESS A FORM FEED
DOFORM:	OP	S,FFSEEN,TLOE,TROE
	POPJ	P,		;DO NOT PRINT BLANK PAGES
	MOVNI	N,(VPOS)	;THIS TAKES ALL WE HAVE ON PAGE
	SKIPE	.JBHRL		;ANY HISEG
	PUSHJ	P,CLRSEG	;YES--THROW AWAY
	JRST	CNTDWN		;COUNT DOWN THE LIMIT

;HERE IF /PRINT:SUPRESS OR SUP COMMAND
DOSUP:	CAIE	C,12		;LINE FEED?
	POPJ	P,		;NO--SUPPRESS EVERYTHING ELSE
	OP	S,LFSEEN,TLOE,TROE
	POPJ	P,		;ONLY 1 LINE FEED IN A ROW
	SETO	N,
	JRST	CNTDWN		;CHARGE FOR THE LINE

;HERE TO DO ARROW MODE STUFF IF NEEDED
CHKARO:	IFOFF	S,ARROW		;ARROW MODE?
	JRST	DEVOUT		;NO--JUST PRINT
DOARO:	PUSH	P,C		;SAVE C
	MOVEI	C,"^"		;LOAD A ^
	PUSHJ	P,DEVOUT	;PRINT THE ^
	POP	P,C		;RESTORE C
	MOVEI	C,100(C)	;MAKE INTO REAL LETTER
	PJRST	DEVOUT		;PRINT

;HERE IF SPECIAL CHAR MOVES A FIXED # OF LINES (EXCEPT LINE FEED)
FIXNBR:	MOVNI	N,(N)		;MAKE -VE SO WE CAN DO ADDM'S

;HERE TO ADJUST QUOTA
CNTDWN:	ADD	VPOS,N		;REDUCE VPOS
	JUMPG	VPOS,FIXQTA	;JUMP IF STILL ON PAGE
	MOVE	VPOS,LPLPP	;BACK TO TOP OF PAGE
	ON	S,FFSEEN	;THIS IS A BLANK PAGE
	OP	S,LPODD,TLC,TRC	;ADD 1 TO PAGE COUNT
FIXQTA:	ADDB	N,LPQTA		;ADD TO QUOTA
	ON	S,NEWLIN	;FLAG NEW LINE
	JUMPLE	N,XCEED		;THAT DOES IT
	PJRST	DEVOUT		;PRINT THE POOR CHARACTOR.
;SUBROUTINE TO GIVE AN OCTAL DUMP ON LPT
;CALL WITH:
;	PUSHJ	P,OCTAL
;	RETURN HERE ON EOF
;
OCTAL:	PUSHJ	P,SAV5		;SAVE ACS ON THE PDL
	LDB	P1,P.SPC	;GET THE SPACING CODE
	CAIE	P1,1		;SINGLE SPACE?
	SKIPA	P5,[22,,1]	;NO--THEN TRIPLE SPACE, DOUBLE SPACE
				;IS UGLY --DO NOT ALLOW IT
	MOVE	P5,[12,,3]	;SINGLE SPACE THE LISTING
OCT1:	MOVEI	P1,(P5)		;BLOCK PER PAGE
OCT2:	MOVEI	P2,^D16		;LINES PER BLOCK
OCT3:	MOVEI	P3,^D8		;WORDS PER LINE
OCT4:	MOVEI	P4,^D12		;DIGITS PER WORD
	MOVEI	C," "		;EACH WORD BEGINS WITH 3 BLANKS
	PUSHJ	P,DEVOUT	;ONE
	PUSHJ	P,DEVOUT	;TWO
	PUSHJ	P,DEVOUT	;THREE
	PUSHJ	P,DSKIN		;GET THE NEXT WORD
	  JRST	OCT6		;DO THE EOF
	MOVE	N,C		;COPY WORD
	OFF	S,FFSEEN	;FLAG MIDDLE OF FORM
OCT5:	SETZ	C,		;CLEAR C
	LSHC	C,3		;SHIFT IN 1 DIGIT
	MOVEI	C,60(C)		;MAKE ASCII
	PUSHJ	P,DEVOUT	;PRINT CHAR
	SOJG	P4,OCT5		;END OF WORD?
	SOJG	P3,OCT4		;END OF LINE?
	HLRZ	C,P5		;GET MOTION CHARACTER
	PUSHJ	P,DEVOUT	; ..
	SOJG	P2,OCT3		;END OF BLOCK?
	PUSHJ	P,DEVOUT	;YES--2 EXTRA LINE FEEDS
	PUSHJ	P,DEVOUT	; ..
	SOJG	P1,OCT2		;END OF PAGE?
	MOVEI	C,14		;PRINT A FORM FEED
	ON	S,FFSEEN	;FLAG TOP OF FORM
	MOVN	N,LPLPP		;COUNT 1 PAGE AGAINST QUOTA
	PUSHJ	P,FIXQTA	; ..
	JRST	OCT1		;PRINT NEXT PAGE
OCT6:	MOVN	N,LPLPP		;ADD THE LAST PAGE
	PJRST	FIXQTA		;CHARGE AND RETURN
;SUBROUTINE TO PRINT COBOL SIXBIT FILES
;CALL WITH:
;	PUSHJ	P,COBDMP
;	RETURN HERE ON EOF
;
COBDMP:	PUSHJ	P,SAV1		;SAVE AN AC
	PUSHJ	P,CLRSEG	;CLEAR THE HISEG
	OFF	S,FFSEEN	;CAUSE A FORM FEED AT END
	PUSHJ	P,DSKIN		;GET THE FIRST WORD OF THE FILE
	  PJRST GETSPL		;NULL FILE
	HLRZ	T1,C		;COPY THE FIRST 3 LETERS
	CAIE	T1,'HDR'	;IS IT A HDR
	JRST	COBOL4		;NO--NORMAL INPUT
	MOVEI	T1,15		;FLUSH TAPE HEADER
	PUSHJ	P,DSKIN		;GET A WORD
	  PJRST GETSPL		;EOF
	SOJG	T1,.-2		;LOOP FOR MORE
COBOL1:	PUSHJ	P,DSKIN		;GET A WORD
	  PJRST GETSPL		;TEH LAST WORD HAS COME
COBOL4:	ANDI	C,7777			;MASK TO 12 BITS
	JUMPLE	C,COBOL5	;IGNORE 0 COUNTS FOR OBVIOUS REASON
	MOVEI	P1,(C)		;COPY THE COUNT
	IDIVI	C,CHRLIN	;CONVERT TO LINES
	MOVNI	C,(C)		;MAKE NEGATIVE BECAUSE SUBB IS BACKWARDS
	ADDB	C,LPQTA		;COUNT DOWN QUOTA
	JUMPLE	C,XCEED		;DIE IF TOO BIG. THE IDEA OF THIS
				; CHECK BEING DONE PRIOR TO PRINTING
				; IS TO PREVENT ASCII FILE FROM PRINTING
				; GREAT PILES OF JUNK.
	IFN	RPW,<		;IF WE SUPPORT /REPORT THEN
	JRST	ISLIN		; GO TO ISLIN WHICH WILL JRST
				; TO COBOL2 (.+1) IF THE HEADER
				; ON THIS LINE MATCHES. THE HEADER
				; MAY BE NULL, IN ANY EVENT IT IS
				; STRIPED OFF. IF THE LINE DOES NOT MATCH
				; ISLIN WILL JRST TO FLUSH6 TO IGNORE
				; THE REST OF THE LINE.
>	;END CONDITIONAL
;COBOL OUTPUT CONT.

COBOL2:	PUSHJ	P,DSKIN		;GET A DATA WORD
	  PJRST GETSPL		;END OF FILE-- ACTUALY THIS SHOULD
				; NEVER HAPPEN SINCE THE COUNT IS EXACT.
	MOVEI	T1,6		;CHARS PER WORD.
	CAIG	P1,6		;ARE WE DOWN TO LAST DREGS?
	MOVEI	T1,(P1)		;YES--USE EXACT COUNT TO AVOID FREE
				; CRLF ON EXTRA BLANKS.
	MOVE	N,C		;COPY WORD
COBOL3:	SETZ	C,		;CLEAR AC
	LSHC	C,6		;LOAD IN A CHAR
	MOVEI	C,40(C)		;MAKE ASCII
	PUSHJ	P,DEVOUT	;PRINT
	SOJG	T1,COBOL3	;LOOP FOR NEXT CHAR
	SUBI	P1,6		;COUNT 6 MORE CHARS
	JUMPG	P1,COBOL2	;GET MORE
	LDB	T1,P.SPC	;GET THE SPACING CODE
	MOVNI	C,-1(T1)	;GET THE NUMBER OF FREE LIN FEEDS
	ADDB	C,LPQTA		;FIX QUOTA
	MOVEI	C,12		;PRINT A LINE
	PUSHJ	P,DEVOUT	; ON THE LP10
	SOJG	T1,.-1		;GIVE CORRECT SPACING
	JRST	COBOL1		;LOOP FOR MORE.
COBOL5:	PUSHJ	P,FILL		;SKIP TO NEXT RECORD FOR ISAM
	  PJRST GETSPL		;END OF FILE
	AOS	DFCNT		;WILL BE RESET BY SOSLE AT DSKI:
	JRST	COBOL1		;LOOP FOR NEXT RECORD
	IFN	RPW,<


;COBOL6 IS CALLED FROM ISLIN TO GET THE NEXT SIXBIT CHAR. IT HANDLES
; THE SPECIAL CASES OF  THE FIRST PART OF THE HEADER MATCHING BUT THE
; LINE IS TOO SHORT OR THE HEADER EXACTLY MATCHES AND THE LINE IS NULL.
; IN THE CASE OF LENGTH FAILURE IT FIXES UP THE STACK
; AND GOES BACK TO COBOL1 TO READ ANOTHER COUNT WORD. THIS IS A VIOLATION
; OF THE DIGITAL CODING CONVENTIONS BECAUSE IT POPJ UP 2 LEVELS BUT
; YOU HAVE BEEN WARNED.
COBOL6:	SETZ	C,		;CLEAR C
	LSHC	C,6		;SHIFT IN NEXT CHAR
	SOJG	T1,CPOPJ	;RETURN IF STILL SOME
	SUBI	P1,6		;COUNT 6 MORE CHARS
	JUMPLE	P1,COBOL7	;JUMP IF EOL
	PUSHJ	P,DSKIN		;GO GET A WORD
	  JRST	COBOL7		;END OF FILE
	MOVEI	T1,6		;SET UP T1
	CAIG	P1,6		;EXACT COUNT
	MOVEI	T1,(P1)		;YES--USE THAT
	MOVE	N,C		;COPY WORD
	JRST	COBOL6		;LOOP BACK

COBOL7:	POP	P,(P)		;POP ADDRESS OFF STACK
	JRST	COBOL1		;LOOK FOR NEXT COUNT WORD

FLUSH6:	PUSHJ	P,COBOL6	;PICK UP NEW CHAR
	JRST	.-1

> ;END TEST ON RPW

;SUBROUTINE TO READ FROM THE DISK
;CALL WITH:
;	PUSHJ	P,DSKIN
;	  EOF RETURN
;	GOOD RETURN (CHAR IN C)
;
DSKIN:	SKIPN	C,SAVCH#	;ANYTHING SAVED
	JRST	DSKI		;NO--GOFISH
	SETZM	SAVCH		;CLEAR THE BAD WORD
	JRST	CPOPJ1		;GOOD RETURN
DSKI:	SOSLE	DFCNT		;COUNT DOWN WORDS
	JRST	LPLDB		;SOME LEFT
	PUSHJ	P,FILL		;REFILL
	  POPJ	P,
LPLDB:	ILDB	C,DFBPT		;GET A CHAR
	JRST	CPOPJ1		;RETURN
;SUBROUTINE TO SPACE FORWARD N PAGES
;CALLED FROM COMIN:
;	PUSHJ	P,FORWAR
;	RETURN WITH SOME LOCATIONS FIXED
;NOTE: THIS SHOULD LEAVE THE PAPER AT THE SAME RELATIVE LOCATION
; ON THE PAGE BUT SAVERAL PAGES AHEAD.
;
	TOPSEG
FORWAR:	PUSHJ	P,DECARG	;GET ARGUMENT
	  POPJ	P,		;ZERO
	ON	S,NOTYPE	;SILENCE THE LPT
	XFR	LPQTA,LPTEMP	;SAVE THE REAL QUOTA
	IMUL	N,LPLPP		;PAGES TO LINES
	SOJ	N,		;FORGET 1 LINE
	MOVEM	N,LPQTA		;SAVE AS PHONY QUOTA
	POPJ	P,		;RETURN

;SUBROUTINE TO BACKSPACE N PAGES
;SEE FORWARD
;NOTE: FILE IS READ FORWARD UNTILL DESIRED PAGE IS FOUND
;
BACKSP:	MOVE	T2,DFDOT	;PICK UP THE QUOTA WHEN
				; WE STARTED THIS COPY.
	TLZ	T2,(77B5)		;CLEAR THE COPY NUMBER
	SUB	T2,LPQTA	;WHERE WE ARE NOW
	PUSHJ	P,DECARG	;GET ARGUMENT
	 POPJ	P,		;ZERO OR FUNNY
	IMUL	N,LPLPP		;CONVERT TO LINES
	SUBI	T2,1(N)		;WHERE WE WANT TO BE
	XFR	LPQTA,LPTEMP	;SAVE REAL QUOTA
	MOVEM	T2,LPQTA	;SAVE AS TARGET
	USETI	DSK,1		;REWIND THE INPUT
	ON	S,NOTYPE	;DO NOT RETYPE 
	POPJ	P,

;SUBROUTINE TO OUTPUT ONE CHAR ON SELECTED DEVICE
;CALL WITH:
;	PUSHJ	P,DEVOUT
;	RETURN HERE (HALTS IF ERROR)
;
	LOWSEG
DEVOUT:	IFN	PDP6LP,<
	CAIE	C,12		;LINE FEED
	PJRST	DEVOU1		;NO--JUST PRINT
	MOVEI	C,15		;BUM UP A CR
	PUSHJ	P,DEVOU1	;PRINT THAT
	MOVEI	C,12		;PUT THE LF BACK
DEVOU1:>
	IFON	S,NOTYPE,CPOPJ	;IGNORE IF IN  A SEARCH
	SOSLE	LPCNT		;ROOM IN BUFFER
	JRST	LPDPB		;YES. STORE
FRCUUO:	OUT	LPT,0
	  JRST	LPDPB		;NO ERRORS
	GETSTS	LPT,N		;FOR DEBUGGING
	TELL	OPR!ERR,LPTERR	;TELL OP
	STOPCD	LPDPB		;DIE
LPDPB:	IDPB	C,LPBPT
IFN	FTDPM,<			;SPECIAL CODE TO HANDLE LPT OFF-LINE
				;CORRECTLY (AT SOME COST IN CPU TIME)
	CAIG	C,24		;IS IT A VERTICAL MOTION CHAR?
	CAIGE	C,12		; .. (^O AND ^N ARE RARE SO IGNORE THAT)
	POPJ	P,		;NO ALL DONE
	SETZ	C,		;INHIBIT A LOOP
	JRST	FRCUUO		;YES--GO DO OUTPUT UUO.
> ;END TEST ON FTDPM
	POPJ	P,0




;HERE WHEN USER IS OVER HIS PRINT OUT QUOTA

XCEED:	IFON	S,NOTYPE,FIXUPS	;JUMP IF FUDGE
	IFN	FACTSW,<	;IF WE ARE COUNTING
	XFR	LPQTA,F.UNIT>	;DO NOT WIPE OUT OLD VALUE
	MOVEI	T1,LOGLIM	;ALLOW LOG TO PRINT
	MOVEM	T1,LPQTA	; ..
	IFN	LPTSPL,<
	MOVEI	C,FORMF
	PUSHJ	P,DEVOUT
>
	TELL	USR!OPR!LOG!ERR,QTAOUT ;INFORM EVERYONE
	ON	S,ABORT		;HE HAS LOST
	OUTPUT	LPT,		;DUMP PARTIAL BUFFER
	SETOM	DFCNT		; AND DO IT NOW!
	USETI	DSK,-1		;CAUSE AN EOF
	POPJ	P,0



;HERE AFTER A FORWARD OR BACKSPACE HITS THE TARGET

FIXUPS:	XFR	LPTEMP,LPQTA	;RESTORE THE QUOTA
	OFF	S,NOTYPE	;CLEAR THE FLAG
	JRST	LPTOUT		;LOOP FOR MORE
	SUBTTL	ROUTINES TO GENERATE HEADERS AND TRAILERS

;JOB HEADERS AND TRAILERS
	TOPSEG
.JBTRL:	IFG	HLINEN,<	;ONLY IF + NUMBER OF LINES OF HDR
	MOVEI	C,14		;FORM FEED
	OP	S,FFSEEN,TLON,TRON
	PUSHJ	P,DEVOUT	;BEFORE TRAILER
	MOVE	T4,TRLADR	;ADDRESS OF END TEXT
	IFON	S,RQB		;IF THIS IS A REQUEUE
	MOVEI	T4,[ASCIZ /*REQUEUE*/] ;SAY SO
	MOVEI	T5,[0]		;POINT TO NOTHING
	IFN	FACTSW,<	;ONLY IF SWITCH SET
	SKIPN	FACTFL>		;ANY FACT MESSAGE
	MOVEI	T5,BEGIN	;POINTER TO STARTUP MESSAGE
	JRST	GIVHDR		;PRINT THE HEADER
JOBHDR:	MOVEI	T4,HDRMSG	;ADDRESS OF START TEXT
	MOVEI	T5,BEGIN	;ADDRESS OF START TEXT
GIVHDR:	OFF	S,SUPRESS	;CLEAR THE SUPPRESS BIT
	MOVE	T1,LPDEV	;LOAD OUTPUT DEVICE NAME AND PRINT A
	TELL	USR,(T5)	;GENERAL HEADER LINE
	PUSH	P,LPBPT		;SAVE BYTE POINTER
	PUSH	P,LPCNT		;SAVE REAL COUNT
	XFR	<[POINT 7,LPBUF]>,LPBPT
	MOVEI	T1,^D1000
	MOVEM	T1,LPCNT	;PREVENT AN OUTPUT
	TELL	USR,(T4)	;PRINT THE RIGHT THING
	MOVE	T1,Q.USER	;GET THE NAME
	TELL	USR,JBHDR1	;PRINT FIRST PART OF NAME
	TRNN	T1,77		;WAS LAST CHAR PRINTED A BLANK?
	TELL	USR,[ASCIZ / /]	;YES--REPRINT THE SPACE SINCE SIXOUT
				; HAS TRIMMED IT OFF
	MOVE	T1,Q.USER+1	;GET PART 2
	TELL	USR,JBHDR2	;PRINT SECOND PART OF NAME
	MOVE	T1,Q.JOB	;PICK UP JOB NAME
	TELL	USR,JBHDR3	;PRINT JOB NAME
	SKIPE	N,Q.SEQ		;IS THER A SEQ. NO
	TELL	USR,JBHDR4	;YES PRINT IT
	TELL	USR,JBHDR5	;PRINT THE DATE
	ON	S,TNOACT	;INHIBIT ACTION CHARS
	TELL	USR,LPCNF	;PRINT THE MONITOR NAME
	TELL	USR,(T4)	;PRINT A WORD
	SETZ	T1,		;MAKE SURE THAT THERE
	IDPB	T1,LPBPT	; IS A NULL AT THE END
	POP	P,LPCNT		;RESTORE THE REAL
	POP	P,LPBPT		; HEADER
	MOVEI	T1,<HLINEN*HSPACE/LPP> ;NUMBER OF PAGES OF HEADER
HLOOP1:	MOVEI	T2,<LPP/HSPACE>	;LINES PER PAGE
HLOOP2:	TELL	USR,LPBUF	;PRINT THE HEADER
	TELL	USR,HDCRLF		;SPACE
	SOJG	T2,HLOOP2	;PRINT ANOTHER LINE
	SOJE	T1,FINHDR	;LAST PAGE?
	PUSHJ	P,STARLP	;NO--GIVE SOME *S
	JRST	HLOOP1		;DO ANOTHER PAGE
FINHDR:	TLZE	T4,200000	;IS THIS THE TRAILER
	PUSHJ	P,STAR23	;YES--GIVE THE EXTRA 3 ROWS
	OFF	S,TNOACT	;STOP ACTION CHARS
	MOVEI	C,14
	PUSHJ	P,DEVOUT
TRLADR:	POPJ	P,TRLMSG	;RETURN. RH IS A CONST
STAR23:	TELL	USR,[BYTE (7)23,23,0,0,0]
STARLP:	TELL	USR,STARS	;PRINT SOME *S
	POPJ	P,		;RETURN

> ;END TEST ON HLINEN
;FILE HEADERS

IFE	PICNUM,<HEAD==CPOPJ>
IFN	PICNUM,<
HEAD:	PUSHJ	P,SAV5		;SAVE AN AC
IFN	<PICNUM-1>,<		;IF MORE THAN 1 PICTURE PAGE
	MOVEI	P3,PICNUM	;NUMBER OF PICTURE PAGES
	PUSHJ	P,.+3		;PRINT THE HEADER
	SOJG	P3,.-1	;LOOP FOR THE WHOLE WORKS
	POPJ	P,		;RETURN
> ;END THE TEST OF PICNUM-1
	MOVE	P1,Q.FMOD(QP)	;GET THE MOD WORD
	IFOFF	P1,QUPNFH	;DOES HE WANT FILE HEADERS
	POPJ	P,		;NO--MUST BE TH PRINTING MCO'S
	LDB	T1,P.LOE	;GET LENGTH OF ENTRY
	CAIG	T1,Q.FRPT	;INCLUDE /REPORT
	JRST	FHEAD		;NO--DONT GIVE IT
	SKIPN	P1,Q.FRPT(QP)	;IS /REPORT GIVEN
	JRST	FHEAD		;NO--NORMAL MODE
	PUSHJ	P,PICTURE	;YES--PRINT THAT
	MOVE	P1,Q.FRPT+1(QP)	; ..
	PUSHJ	P,PICTURE	; ..
	JRST	RHEAD		;GIVE NORMAL REST
FHEAD:	MOVE	P1,DFNAME	;PICK UP FILE NAME
	PUSHJ	P,PICTURE	;PRINT IT
	HLLZ	P1,DFEXT	;PICK UP EXT
	PUSHJ	P,PICTUR	;PRINT IT
RHEAD:	MOVE	T1,LPDEV	;GET THE DEVICE WE ARE GOING TO
	TELL	USR,BEGIN	;GIVE ALL THE INFO
	ON	S,TNOACT	; ..
	TELL	USR,LPBUF	; ..
	OFF	S,TNOACT	; ..
	TELL	USR,CRLF	; ..
	DATE	P1,		;PUT THE DATE IN P1
RCLOOP:	MOVE	T2,P1		;COPY DATE
	PUSHJ	P,GETNOW	;CONVERT TO UNIVERSAL DATES
	HLLZ	T3,Q.CREA	;GET CREATION DATE
	CAMN	T3,T1		;SAME DATE?
	JRST	RCHAVE		;YES--WE WIN
	CAMG	T3,T1		;WHICH WAY ARE WE OFF
	SOJA	P1,RCLOOP	;WE ARE LATE
	AOJA	P1,RCLOOP	;WE ARE EARLY
RCHAVE:	TELL	USR,[ASCIZ /Request created: /]
	PUSHJ	P,PRDAT1	;PRINT THE DATE
	TELL	USR,[ASCIZ /  /]
	HRRZ	P1,Q.CREA	;GET THE CREATION TIME
	IMULI	P1,^D330	;CONVERT TO MS.
	PUSHJ	P,PRTIM1	;PRINT THE TIME
	TELL	USR,[ASCIZ /
/]

;STILL IN IFN PICNUM
	TELL	USR,[ASCIZ /File: ^[ Created: /]
	LDB	P1,C.DAT		;GET CREATION DATE
	PUSHJ	P,PRDAT1	;AND PRINT CREATION DATE
	MOVEI	C,40
	PUSHJ	P,DEVOUT
	LDB	P1,C.TIM	;GET CREATION TIME
	IMULI	P1,^D60000	;MAKE TIME == MILLISECS.
	PUSHJ	P,PRTIM1	;AND PRINT IT
	LDB	N,[POINT 9,RBPRV,8]
	IFOFF	S,QDIR		;SKIP IF RENAMED TO [3,3]
	TELL	USR,[ASCIZ / <"> /]
	TELL	USR,[ASCIZ / Printed: /]
	PUSHJ	P,PRDATE
	MOVEI	C,40
	PUSHJ	P,DEVOUT
	PUSHJ	P,PRTIME
	MOVEI	C,12
	PUSHJ	P,DEVOUT
	TELL	USR,[ASCIZ .QUEUE Switches: .]
	LDB	T2,P.FMT	;GET /PRINT: VALUE
	MOVE	T1,FMTAB-1(T2)	;GET THE WORD
	SKIPE	T2		;DONT PRINT IF FORCED TO BE NULL
	TELL	USR,[ASCIZ . /PRINT:+.]
	LDB	T2,P.FFMT	;GET THE /FILE: WORD
	MOVE	T1,FFMTAB-1(T2)	;GET THE WORD
	SKIPE	T2		;SKIP IF NULL /FILE:
	TELL	USR,[ASCIZ . /FILE:+ .]
	LDB	N,P.CPY		;GET NUMBER OF COPIES
	TELL	USR,[ASCIZ ./COPIES:# .]
	LDB	N,P.SPC		;GET THE SPACING
	TELL	USR,[ASCIZ ./SPACING:# .]
	MOVE	N,LPQTA		;GET THE QUOTA
	IDIV	N,LPLPP		;CONVERT TO PAGES
	TELL	USR,[ASCIZ ./LIMIT:# 
.]

;STILL IN IFN PICNUM
	MOVE	N,Q.FBIT(QP)	;GET THE STARTING ADDRESS
	TLZ	N,(3B1)		;CLEAR OUT THE CRUD
	IDIV	N,LPLPP		;CONVERT TO PAGES
	SKIPE	N		;SKIP IF 0
	TELL	USR,[ASCIZ /
*****Printing started at page # *****
/]
	LDB	P1,P.FDSP	;GET THE DISPOSITION
	CAIE	P1,KEEP		;IS IT KEEP?
	TELL	USR,[ASCIZ /File will be deleted after printing
/]
	CAIE	P1,KEEP		;ARE WE GOING TO KEEP THIS FILE
	JRST	GIVEFF		;NO--GIVE A FORM FEED
	LDB	N,[POINT 9,RBPRV,8]
	TRZ	N,700		;CLEAR OWNER PROTECTION
	SKIPGE	Q.FBIT(QP)	;IS THIS FILE ARTIFICALY PRESERVED?
	TELL	USR,[ASCIZ /File will be RENAMEd to <"> protection
/]
GIVEFF:	MOVEI	C,14		;IT IS A FORM FEED
	PUSHJ	P,DEVOUT	;PRINT IT
	ON	S,FFSEEN	;TOP OF FORM
	POPJ	P,		;RETURN


FMTAB:	SIXBIT	/ARROW/
	SIXBIT	/ASCII/
	SIXBIT	/OCTAL/
	SIXBIT	/SUPRES/

FFMTAB:	SIXBIT	/ASCII/
	SIXBIT	/FORT/
	SIXBIT	/COBOL/
	SIXBIT	/CREF/
	SIXBIT	/RUNOFF/

TAIL:	OP	S,FFSEEN,TLOE,TROE
	POPJ	P,		;RETURN IF TOP OF FORM
	MOVEI	C,14		;SET UP FORM FEED
	PJRST	DEVOUT		;GO PRINT IT

;STILL IN PICNUM
;GETNOW -- COMPUTE CURRENT TIME IN SPECIAL FORMAT
;CALL:	PUSHJ	P,GETNOW
;RETURNS WITH RESULT IN T1
;USES T2, T3, T4, T5


	RADIX	10

GETNOW:	IDIVI	T2,12*31	;T2=YEARS-1964
	IDIVI	T3,31		;T3=MONTHS-JAN, T4=DAYS-1
	ADD	T4,MONTAB(T3)	;T4=DAYS-JAN 1
	MOVEI	T5,0		;LEAP YEAR ADDITIVE IF JAN, FEB
	CAIL	T3,2		;CHECK MONTH
	MOVEI	T5,1		;ADDITIVE IF MAR-DEC
	MOVE	T1,T2		;SAVE YEARS FOR REUSE
	ADDI	T2,3		;MAKE LEAP YEARS COME OUT RIGHT
	IDIVI	T2,4		;HANDLE REQULAR LEAP YEARS
	CAIE	T3,3		;SEE IF THIS IS LEAP YEAR
	MOVEI	T5,0		;NO--WIPE OUT ADDITIVE
	ADDI	T4,DATOFS(T2)	;T4=DAYS BEFORE JAN 1,1964 +SINCE JAN 1
				; +ALLOWANCE FOR ALL LEAP YEARS SINCE 64
	MOVE	T2,T1		;RESTORE YEARS SINCE 1964
	IMULI	T2,365		;DAYS SINCE 1964
	ADD	T4,T2		;T4=DAYS EXCEPT FOR 100 YR. FUDGE
	HRREI	T2,64-99(T1)	;T2=YEARS SINCE 2000
	JUMPLE	T2,GETNW1	;ALL DONE IF NOT YET 2000
	IDIVI	T2,100		;GET CENTURIES SINCE 2000
	SUB	T4,T2		;ALLOW FOR LOST LEAP YEARS
	CAIE	T3,99		;SEE IF THIS IS A LOST L.Y.
GETNW1:	ADD	T4,T5		;ALLOW FOR LEAP YEAR THIS YEAR

;HERE WITH T4 CONTAINING CORRECT NUMBER OF DAYS

	HRLZ	T1,T4		;COPY ANSWER
	POPJ	P,		;RETURN

MONTAB:	EXP	0,31,59,90,120,151,181,212,243,273,304,334
	RADIX	8
;STILL IN PICNUM
;SUBROUTINE TO PRINT BLOCK LETTERS
;CALL WITH:
;	MOVE	P1,WORD-IN-SIXBIT
;	PUSHJ	P,PICTUR
;	RETURN IS HERE
;
;THIS ROUTINE IS STOLEN FROM BOB CLEMENTS. I WISH TO THANK
;BOB FOR HIS CLEAR COMMENTS ON IT'S USE IN PRINTR.
;
PICTUR:	MOVNI	T3,43		;BITS IN MAP
PIC0:	REPEAT	3,<		;3 LINES PER
	PUSHJ	P,PIC1		; BLOCK LETTER>
	ADDI	T3,5		;COUNT ANOTHER ROW
	JUMPL	T3,PIC0		;LOOP IF MORE
	REPEAT	4,<		;LEAVE 4 LINES OF
	TELL	USR,CRLF		; BLANKS>
	POPJ	P,		;RETURN
;HERE TO PRINT A WHOLE ROW
PIC1:	MOVE	N,[440600,,P1]	;BYTE POINTER TO C
;HERE TO DO 1 CHAR
PIC2:	ILDB	T2,N		;GET A CHAR
	ADDI	T2,40		;MAKE ASCII
	MOVE	T1,CHRTAB-40(T2);GET PATTERN
	ROT	T1,43(T3)	;DIAL A BIT
	MOVNI	T4,5		;SET UP COUNT
PIC3:	MOVEI	C,40		;ASSUME IT IS A BLANK
	JUMPGE	T1,.+2		;WERE WE RIGHT
	MOVE	C,T2		;OF COURSE NOT
	PUSHJ	P,TELL3		;PRINT 3 WIDE
	ROT	T1,1		;GET NEXT BIT
	AOJL	T4,PIC3		;COUNT DOWN WIDTH
	MOVEI	C,40		;SET UP FOR SPACE
	TLNN	N,770000	;DONE?
	JRST	TCRLF		;YES. LEAVE A BLANK LINE
	PUSHJ	P,TELL3		;NO. PRINT 6 BLANK
	PUSHJ	P,TELL3		; COL. BETWEEN LETTERS
	JRST	PIC2		;DO ANOTHER LETTER
TCRLF:	TELL	USR,CRLF		;PRINT A BLANK LINE
	POPJ	P,		;RETURN
TELL3:	PUSHJ	P,DEVOUT	;PRINT THE CHAR
	PUSHJ	P,DEVOUT	; 3 TIMES
	PJRST	DEVOUT		; ..
	
;STILL IN PICNUM

CHRTAB:	BYTE (5) 00,00,00,00,00,00,00	;SP
	BYTE (5) 04,04,04,04,04,00,04	;!
	BYTE (5) 12,12,00,00,00,00,00	;"
	BYTE (5) 12,12,37,12,37,12,12	;#
	BYTE (5) 04,37,24,37,05,37,04	;$
	BYTE (5) 31,31,02,04,10,23,23	;%
	BYTE (5) 10,24,10,24,23,22,15	;&
	BYTE (5) 06,02,00,00,00,00,00	;'
	BYTE (5) 04,10,20,20,20,10,04	;(
	BYTE (5) 04,02,01,01,01,02,04	;)
	BYTE (5) 00,25,16,33,16,25,00	;*
	BYTE (5) 00,04,04,37,04,04,00	;+
	BYTE (5) 00,00,00,00,00,06,02	;,
	BYTE (5) 00,00,00,37,00,00,00	;-
	BYTE (5) 00,00,00,00,00,06,06	;.
	BYTE (5) 00,00,01,02,04,10,20	;/

	BYTE (5) 16,21,23,25,31,21,16	;0
	BYTE (5) 04,14,04,04,04,04,16	;1
	BYTE (5) 16,21,01,02,04,10,37	;2
	BYTE (5) 16,21,01,02,01,21,16	;3
	BYTE (5) 22,22,22,37,02,02,02	;4
	BYTE (5) 37,20,34,02,01,21,16	;5
	BYTE (5) 16,20,20,36,21,21,16	;6
	BYTE (5) 37,01,01,02,04,10,20	;7
	BYTE (5) 16,21,21,16,21,21,16	;8
	BYTE (5) 16,21,21,17,01,01,16	;9
	BYTE (5) 00,06,06,00,06,06,00	;:
	BYTE (5) 00,06,06,00,06,06,02	;;
	BYTE (5) 02,04,10,20,10,04,02	;<
	BYTE (5) 00,00,37,00,37,00,00	;=
	BYTE (5) 10,04,02,01,02,04,10	;>
	BYTE (5) 16,21,01,02,04,00,04	;?

	BYTE (5) 16,21,21,27,25,25,07	;@
	BYTE (5) 16,21,21,21,37,21,21	;A
	BYTE (5) 36,21,21,36,21,21,36	;B
	BYTE (5) 17,20,20,20,20,20,17	;C
	BYTE (5) 36,21,21,21,21,21,36	;D
	BYTE (5) 37,20,20,36,20,20,37	;E
	BYTE (5) 37,20,20,36,20,20,20	;F
	BYTE (5) 17,20,20,20,27,21,16	;G
	BYTE (5) 21,21,21,37,21,21,21	;H
	BYTE (5) 16,04,04,04,04,04,16	;I
	BYTE (5) 01,01,01,01,21,21,16	;J
	BYTE (5) 21,21,22,34,22,21,21	;K
	BYTE (5) 20,20,20,20,20,20,37	;L
	BYTE (5) 21,33,25,21,21,21,21	;M
	BYTE (5) 21,21,31,25,23,21,21	;N
	BYTE (5) 16,21,21,21,21,21,16	;O

	BYTE (5) 36,21,21,36,20,20,20	;P
	BYTE (5) 16,21,21,21,25,22,15	;Q
	BYTE (5) 36,21,21,36,24,22,21	;R
	BYTE (5) 17,20,20,16,01,01,36	;S
	BYTE (5) 37,04,04,04,04,04,04	;T
	BYTE (5) 21,21,21,21,21,21,37	;U
	BYTE (5) 21,21,21,21,21,12,04	;V
	BYTE (5) 21,21,21,21,25,33,21	;W
	BYTE (5) 21,21,12,04,12,21,21	;X
	BYTE (5) 21,21,12,04,04,04,04	;Y
	BYTE (5) 37,01,02,04,10,20,37	;Z
	BYTE (5) 14,10,10,10,10,10,14	;[
	BYTE (5) 00,00,20,10,04,02,01	;\
	BYTE (5) 06,02,02,02,02,02,06	;]
	BYTE (5) 00,04,16,25,04,04,00	;^
	BYTE (5) 00,04,10,37,10,04,00	;_
	>		;END IFN PICNUM
	>		;END LPTSPL FROM WAY WAY BACK
	LIST
SUBTTL	CARD PUNCH CONTROL

IFE	CDPSPL,<XLIST>
IFN	CDPSPL,<

;SUBROUTINE TO PLACE A FILE ON CARD PUNCH

	TOPSEG
	MNESIZ==BINSIZ

	MNEBIN==CDBIN
FILOUT:	LDB	T1,P.FMT	;GET FILE FORMAT
	JUMPN	T1,FILOU1	;JUMP IF NO DEFAULT WANTED
	LDB	T1,[POINT 4,RBPRV,12]
	MOVE	T1,[EXP 1,1,0,0,0,0,0,0,5,0,0,5,3,0,3,3](T1)
FILOU1:	JUMPE	T1,NOTYET	;BAD CODE
	CAIL	T1,6		;CODE TOO BIG? **NOTE: THIS
				; INHIBITS MNEMONIC.
	JRST	NOTYET		;YES--NOT KNOWN TO US
	HRRZI	T2,CDPOUT	;PLACE WE ARE BLITING TO
	HRL	T2,MODTBL(T1)	;WHERE TO GET THE CODE
	HLRZ	T3,MODTBL(T1)	;HOW MUCH TO GET
	BLT	T2,CDPOUT(T3)	;TRANSFER THE DATA
	PUSH	P,[CDPOUT]	;SAVE ADDRESS ON STACK
MODTBL:	PJRST	CLRSEG		;CLEAR THE HISEG AND PUNCH
	ASCSIZ,,CDASC		;ASCII OUTPUTTER
	C026SZ,,CD026		;026 MODE
	BINSIZ,,CDBIN		;CHECKSUM BINARY
	D029SZ,,CD029		;DEC 029 (CDRSRX ASCII)
	IMASIZ,,CDIMA		;IMAGE AND IMAGE BINARY
	MNESIZ,,MNEBIN		;MNEMONIC BINARY
NOTYET:	MOVE	T1,[SIXBIT /Q.FMT/] ;THE BAD FIELD
	TELL	OPR!ERR!LOG,NOTIMP ;TELL THE WORLD
	POPJ	P,		;PUNT
	LIT

CDIMA:	PHASE	CDPOUT		;WILL EXEC FROM LOWSEG
	MOVEI	T2,CPC		;SET UP COL COUNTER
CDPLP:	SOSLE	DFCNT		;COUNT DOWN BUFFER
	JRST	CDPLDB		;ROOM - GO STORE
	PUSHJ	P,FILL		;REFILL THE DISK INPUT BUFFER
	  PJRST	FINCRD		;END OF FILE -- NOW:
				; FINISH THE CARD
				; GET THE HISEG
				; POPJ BACK TO MAIN ROUTINE
CDPLDB:	ILDB	N,DFBPT		;GET A BYTE
	MOVEI	T1,3		;3 BYTES PER WORD
CDIMLP:	SETZ	C,		;CLEAR C
	LSHC	C,14		;SHIFT IN 1 BYTE
	PUSHJ	P,DEVOUT	;PUNCH IT
	SOJLE	T2,CDIM2	;JUMP IF CARD FULL
CDIM1:	SOJG	T1,CDIMLP	;LOOP FOR MORE BYTES
	JRST	CDPLP		;LOOP FOR MORE WORDS
CDIM2:	PUSHJ	P,OUTUUO	;IF FULL,OUTPUT CARD
	MOVEI	T2,CPC		;RESET COLUMN COUNTER
	JRST	CDIM1		;AND THEN LOOP FOR MORE
	LIT
	DEPHASE			;BACK TO NORMAL
IMASIZ=.-CDIMA			;SIZE OF LOOP

;THIS WILL PUNCH CHECKSUMED BINARY CARDS

CDBIN:	PHASE	CDPOUT		;WILL GET MOVED TO LOWSEG
	SETZ	T1,		;CLEAR SUM
	MOVSI	T2,-32		;AOBJN POINTER
CDBNLP:	SOSLE	DFCNT		;ANY INPUT
	JRST	CBNLDB		;YES--GO EAT A CHAR
	PUSHJ	P,FILL		;READ A BUFFER
	  JRST	[SETOM EOFWD	;END OF FILE
		 JRST  FINBIN]	;GO PUNCH LAST CARD
CBNLDB:	ILDB	C,DFBPT		;GO GET A CHAR
	ADD	T1,C		;ADD TO SUM
	MOVEM	C,CDBUF(T2)	;STORE FOR PASS2
	AOBJN	T2,CDBNLP	;LOOP FOR NEXT WORD
FINBIN:	HLRE	C,T2		;COPY FINAL COUNT
	ADDI	C,32		;SUBTRACT FROM 32
	JUMPE	C,FINCRD	;(C)=0 IF EOF AT EOC
	MOVNI	T5,(C)		;COPY -VE COUNT
	LSH	C,6		;SHIFT TO 12-4
	IORI	C,5		;PUNCH OUT 7-9
	PUSHJ	P,DEVOUT	;PUNCH THE WORD
	LSHC	T1,-30		;FOLD THE SUM
	LSH	T2,-14
	ADD	T1,T2
	LSHC	T1,-14
	LSH	T2,-30
	ADD	T1,T2
	TRZE	T1,770000
	AOS	T1
	MOVE	C,T1		;COPY FOLDED SUM
	PUSHJ	P,DEVOUT	;PUNCH THE SUM
	HRLZ	T5,T5		;CONVERT TO AOBJN POINTER
CKSLP1:	MOVE	N,CDBUF(T5)	;GET A WORD
	MOVEI	T1,3		;3 CHAR PER WORD
CKSLP2:	SETZ	C,		;CLEAR OUTPUT CHAR
	LSHC	C,14		;SHIFT IN 12 BITS
	PUSHJ	P,DEVOUT	;MAKE SOME HOLES
	SOJG	T1,CKSLP2	;LOOP FOR OTHER 2 COLS
	AOBJN	T5,CKSLP1	;LOOP FOR MORE
	PUSHJ	P,OUTUUO	;PUSH OUT THE CARD
	SKIPN	EOFWD		;END OF FILE?
	JRST	CDPOUT		;NO--KEEP MAKING HOLES
	PJRST	FINCR1		;RETURN TO TOP LEVEL
EOFWD:	0			;FLAG
CDBUF:	BLOCK	33		;TEMP BUFFER
	LIT
	DEPHASE
BINSIZ=.-CDBIN
;THE FOLLOWING MACRO IS USED TO CREATE THE CODE FOR ASCII, D029 AND 026 CARD CODES
;AS IT IS ESSENTIAL THAT ALL THE LABELS END UP WITH THE SAME ADDRESSES.

DEFINE XFRCRD(TYP),<
CDPLP1:	SOSLE	DFCNT		;ANYTHING IN BUFFER
	JRST	CDLDB		;YES--GO EAT
	PUSHJ	P,FILL		;FILL THE BUFFER
	  PJRST	FINCRD		;EOF--GET THE HISEG
CDLDB:	ILDB	N,DFBPT		;GET A CHAR
	TRZ	N,1		;ZERO BIT 35 (LINED FILE)
CDPGET:	JUMPE	N,CDPLP1	;IGNORE NULLS
	SETZ	C,		;CLEAR C
	LSHC	C,7		;COPY A CHAR
	JUMPE	C,CDPGET	;IGNORE NULL BYTES
	MOVE	T3,CPCNT
	CAIL	T3,CPC
	JRST	ENDCRD
	CAIN	C,11		;IS THIS A TAB
	JRST	TABBER		;YES, CHANGE TO APPROPRIATE #SPACES
	CAIN	C,12		;IS THIS A LINE FEED
	JRST	CDPGET		;YES--THROW AWAY
	CAIN	C,15		;IS THIS A CR?
	JRST	SPACES		;YES--CONVERT TO BLANKS
	MOVE	T1,C		 ;COPY CHAR
	IDIVI	T1,3		;FIND BYTE
	MOVE	C,TBL'TYP(T1)	;GET CHAR
	IMULI	T2,^D12		;ADJUST MASK
	LSH	C,-^D24(T2)	;DIAL A BYTE
	ANDI	C,7777		;MASK OUT JUNK
	PUSHJ	P,DEVOUT	;PUNCH
	JRST	CDPGET		;GET A NEW CARD
SPACES:	OP	S,ANYCHR,TLZE,TRZE ;IS THIS A BLANK CARD
	JRST	ENDCR1		;NO
	SETZ	C,		;YES - WE MUST GIVE CDPSER SOMETHING
	PUSHJ	P,DEVOUT	;SO OUTPUT A BLANK
	JRST	ENDCR1		;THEN FINISH UP CARD IN USUAL WAY

TABBER:	SETZ	C,		;C_[0]
	PUSHJ	P,DEVOUT	;PUNCH A BLANK
	MOVE	T1,CPCNT	;GET COLUMN #
	TRNE	T1,7		;TAB STOP?
	JRST	TABBER		;NO--TRY AGAIN
	JRST	CDPGET		;YES--WE WIN

ENDCRD:	CAIE	C,15		;IS IT A CARRIAGE RETURN?
	JRST	CDPGET		;NO, KEEP EATING
ENDCR1:	PUSHJ	P,OUTUUO	;SHOVE OUT CARD
	JRST	CDPGET		;AND GO ROUND FOR MORE.

	DEPHASE		;BACK TO NORMAL FORM
	SALL>
CD029:	PHASE	CDPOUT		;THE CODE WILL BE MOVED
	JRST	CDPLP1

;CAST OF CHARACTERS IN IMAGE FORMAT INDEXED BY ASCII VALUE

TBL029:	BYTE (12)	5403,4401,4201	;NULL ^A ^B
	BYTE (12)	4101,0003,1023	;^C ^D ^E
	BYTE (12)	1013,1007,2011	;^F ^G ^H
	BYTE (12)	4021,1021,4103	;TAB LF VT
	BYTE (12)	4043,4023,4013	;FF CR ^N
	BYTE (12)	4007,6403,2401	;^O ^P ^Q
	BYTE (12)	2201,2101,0013	;^R ^S ^T
	BYTE (12)	0023,0201,0011	;^U ^V ^W
	BYTE (12)	2003,2403,0007	;^X ^Y ^Z
	BYTE (12)	1005,2043,2023	;^[ ^\ ^]
	BYTE (12)	2013,2007,0000	;^^ ^_ SPACE
	BYTE (12)	2202,0006,0102	;! " #
	BYTE (12)	2102,1042,4000	;$ % &
	BYTE (12)	0022,4022,2022	;' ( )
	BYTE (12)	2042,4012,1102	;* + ,
	BYTE (12)	2000,4102,1400	;- . /
	BYTE (12)	1000,0400,0200	;0 1 2
	BYTE (12)	0100,0040,0020	;3 4 5
	BYTE (12)	0010,0004,0002	;6 7 8
	BYTE (12)	0001,0202,2012	;9 : ;
	BYTE (12)	4042,0012,1012	;< = >
	BYTE (12)	1006,0042,4400	;? @ A
	BYTE (12)	4200,4100,4040	;B C D
	BYTE (12)	4020,4010,4004	;E F G
	BYTE (12)	4002,4001,2400	;H I J
	BYTE (12)	2200,2100,2040	;K L M
	BYTE (12)	2020,2010,2004	;N O P
	BYTE (12)	2002,2001,1200	;Q R S
	BYTE (12)	1100,1040,1020	;T U V
	BYTE (12)	1010,1004,1002	;W X Y
	BYTE (12)	1001,4202,2006	;Z [ \
	BYTE (12)	1202,4006,1022	;] ^ _
	;FOLLOWING ALPHABETICS ARE SMALL LETTERS
	BYTE (12)	0402,5400,5200	;' A B
	BYTE (12)	5100,5040,5020	;C D E
	BYTE (12)	5010,5004,5002	;F G H
	BYTE (12)	5001,6400,6200	;I J K
	BYTE (12)	6100,6040,6020	;L M N
	BYTE (12)	6010,6004,6002	;O P Q
	BYTE (12)	6001,3200,3100	;R S T
	BYTE (12)	3040,3020,3010	;U V W
	BYTE (12)	3004,3002,3001	;X Y Z
	BYTE (12)	5000,6000,3000	;
	BYTE (12)	3400,0000,0000	;

	XFRCRD(029)		;CALL IN CODE TO PUNCH CARD
D029SZ=.-CD029		;SIZE OF BUFFER
CDASC:	PHASE	CDPOUT		;THE CODE WILL BE MOVED
	JRST	CDPLP1

;CAST OF CHARACTERS IN IMAGE FORMAT INDEXED BY ASCII VALUE

TBLASC:	BYTE (12)	5403,4401,4201	;NULL ^A ^B
	BYTE (12)	4101,0005,1023	;^C ^D ^E
	BYTE (12)	1013,1007,2011	;^F ^G ^H
	BYTE (12)	4021,1021,4103	;TAB LF VT
	BYTE (12)	4043,4023,4013	;FF CR ^N
	BYTE (12)	4007,6403,2401	;^O ^P ^Q
	BYTE (12)	2201,2101,0043	;^R ^S ^T
	BYTE (12)	0023,0201,1011	;^U ^V ^W
	BYTE (12)	2003,2403,0007	;^X ^Y ^Z
	BYTE (12)	1005,2043,2023	;^[ ^\ ^]
	BYTE (12)	2013,2007,0000	;^^ ^_ SPACE
	BYTE (12)	4006,0006,0102	;! " #
	BYTE (12)	2102,1042,4000	;$ % &
	BYTE (12)	0022,4022,2022	;' ( )
	BYTE (12)	2042,4012,1102	;* + ,
	BYTE (12)	2000,4102,1400	;- . /
	BYTE (12)	1000,0400,0200	;0 1 2
	BYTE (12)	0100,0040,0020	;3 4 5
	BYTE (12)	0010,0004,0002	;6 7 8
	BYTE (12)	0001,0202,2012	;9 : ;
	BYTE (12)	4042,0012,1012	;< = >
	BYTE (12)	1006,0042,4400	;? @ A
	BYTE (12)	4200,4100,4040	;B C D
	BYTE (12)	4020,4010,4004	;E F G
	BYTE (12)	4002,4001,2400	;H I J
	BYTE (12)	2200,2100,2040	;K L M
	BYTE (12)	2020,2010,2004	;N O P
	BYTE (12)	2002,2001,1200	;Q R S
	BYTE (12)	1100,1040,1020	;T U V
	BYTE (12)	1010,1004,1002	;W X Y
	BYTE (12)	1001,4202,1202	;Z [ \
	BYTE (12)	2202,2006,1022	;] ^ _
	;FOLLOWING ALPHABETICS ARE SMALL LETTERS
	BYTE (12)	0402,5400,5200	;' A B
	BYTE (12)	5100,5040,5020	;C D E
	BYTE (12)	5010,5004,5002	;F G H
	BYTE (12)	5001,6400,6200	;I J K
	BYTE (12)	6100,6040,6020	;L M N
	BYTE (12)	6010,6004,6002	;O P Q
	BYTE (12)	6001,3200,3100	;R S T
	BYTE (12)	3040,3020,3010	;U V W
	BYTE (12)	3004,3002,3001	;X Y Z
	BYTE (12)	5000,6000,3000	;
	BYTE (12)	3400,0000,0000	;

	XFRCRD(ASC)		;CALL IN CODE TO PUNCH BUFFER
ASCSIZ=.-CDASC		;SIZE OF BUFFER
CD026:	PHASE	CDPOUT		;THE CODE WILL BE MOVED
	JRST	CDPLP1

;CAST OF CHARACTERS IN IMAGE FORMAT INDEXED BY ASCII VALUE

TBL026:	BYTE (12)	5403,4401,4201	;NULL ^A ^B
	BYTE (12)	4101,0003,1023	;^C ^D ^E
	BYTE (12)	1013,1007,2011	;^F ^G ^H
	BYTE (12)	4021,1021,4103	;TAB LF VT
	BYTE (12)	4043,4023,4013	;FF CR ^N
	BYTE (12)	4007,6403,2401	;^O ^P ^Q
	BYTE (12)	2201,2101,0013	;^R ^S ^T
	BYTE (12)	0023,0201,0011	;^U ^V ^W
	BYTE (12)	2003,2403,0007	;^X ^Y ^Z
	BYTE (12)	1005,2043,2023	;^[ ^\ ^]
	BYTE (12)	2013,2007,0000	;^^ ^_ SPACE
	BYTE (12)	4006,1022,1012	;! " #
	BYTE (12)	2102,1006,2006	;$ % &
	BYTE (12)	0012,1042,4042	;' ( )
	BYTE (12)	2042,4000,1102	;* + ,
	BYTE (12)	2000,4102,1400	;- . /
	BYTE (12)	1000,0400,0200	;0 1 2
	BYTE (12)	0100,0040,0020	;3 4 5
	BYTE (12)	0010,0004,0002	;6 7 8
	BYTE (12)	0001,2202,1202	;9 : ;
	BYTE (12)	4012,0102,2012	;< = >
	BYTE (12)	4202,0042,4400	;? @ A
	BYTE (12)	4200,4100,4040	;B C D
	BYTE (12)	4020,4010,4004	;E F G
	BYTE (12)	4002,4001,2400	;H I J
	BYTE (12)	2200,2100,2040	;K L M
	BYTE (12)	2020,2010,2004	;N O P
	BYTE (12)	2002,2001,1200	;Q R S
	BYTE (12)	1100,1040,1020	;T U V
	BYTE (12)	1010,1004,1002	;W X Y
	BYTE (12)	1001,2022,0006	;Z [ \
	BYTE (12)	4022,0022,0202	;] ^ _
	;FOLLOWING ALPHABETICS ARE SMALL LETTERS
	BYTE (12)	0402,5400,5200	;' A B
	BYTE (12)	5100,5040,5020	;C D E
	BYTE (12)	5010,5004,5002	;F G H
	BYTE (12)	5001,6400,6200	;I J K
	BYTE (12)	6100,6040,6020	;L M N
	BYTE (12)	6010,6004,6002	;O P Q
	BYTE (12)	6001,3200,3100	;R S T
	BYTE (12)	3040,3020,3010	;U V W
	BYTE (12)	3004,3002,3001	;X Y Z
	BYTE (12)	5000,6000,3000	;
	BYTE (12)	3400,0000,0000	;

	XFRCRD(026)		;CALL IN CODE TO PUNCH CARDS.
C026SZ=.-CD026
HEAD:	PUSHJ	P,SAV5		;SAVE SOME ACS
	MOVEI	C,3776		;ROUNDED CORNER
	PUSHJ	P,DEVOUT	;PUNCH
	HRRZI	C,7777		;PUT SOME HOLES 
	PUSHJ	P,DEVOUT	; IN COL. 1
	MOVE	T1,Q.FNAM(QP)	;PICK UP FILE NAME
	PUSHJ	P,PUNWD		;PUNCH IT.
	PUSHJ	P,PUNBLK	;PUNCH A BLANK
	MOVEI	C,4001		;ROWS 12 AND 9
	PUSHJ	P,DEVOUT	;IN 77
	PUSHJ	P,DEVOUT	;AND 78
	MOVEI	C,7777		;FULLY LACE
	PUSHJ	P,DEVOUT	;COL 79
	MOVEI	C,3776		;ROUND EDGE
	PUSHJ	P,DEVOUT	;COL 80.
	PJRST	OUTUUO		;AND FLUSH CARD
PUNWD:	MOVEI	T3,6		;6 CHARS PER CARD
PUNLP2:	MOVEI	C,4001		;ROWS 12 AND 9
	PUSHJ	P,DEVOUT	;IN FIRST 3
	PUSHJ	P,DEVOUT	; COLS. OF
	PUSHJ	P,DEVOUT	; EACH CHAR.
	LSHC	T1,-6		;GET LAST BYTE
	LDB	C,[POINT 6,T2,5] ;PUT IN C
	CAIG	C,'Z'		;IS IT A LETTER?
	CAIGE	C,'A'		; ..
	JRST	.+3		;NO--SEE IF IT IS A NUMBER
	MOVE	P1,[LTRTAB-102(C)] ;YES--USE LETTER TABLE
	JRST	PUN		;AND PUNCH
	CAIG	C,'9'		;IS IT A NUMBER?
	CAIGE	C,'0'		; ..
PUNBLK:	SKIPA	P1,[Z OTHER]	 ;NO--PUNCH A PLANK
	MOVE	P1,[Z NUMTAB-40(C)] ;YES--USE NUMBER TABLE
PUN:	LSH	C,1		;2 WORDS PER LETTER
	MOVE	P2,@P1		;P2_FIRST WORD
	AOS	C		;POINT TO NEXT WORD
	MOVE	P3,@P1		;P3_SECOND WORD
	MOVEI	P5,10		;10 COLS PER LETTER
	SETZ	P1,		;CLEAR P1
PUNLP:	LSHC	P1,7		;SHIFT IN 7 BITS
	LSH	P1,3		;CENETER ON CARD
	MOVEI	C,4001(P1)	;TURN ON ROWS 12 AND 9
	PUSHJ	P,DEVOUT	;PUNCH
	SETZ	P1,		;CLEAR OUT WORK AC
	CAMN	P2,[1B0]	;END OF WORD?
	MOVE	P2,P3		;YES--FLIP WORD 2 INTO PLACE
	SOJG	P5,PUNLP	;LOOP FOR REST OF LETTER
	SOJG	T3,PUNLP2	;LOOP FOR REST OF WORD
	POPJ	P,		;RETURN
TAIL:	MOVEI	N,^D80		;PUNCH 80 COLUMNS
	MOVEI	T1,7417		;LACE FOR END CARD

OUDEV:	MOVE	C,T1		;COPY ARGUMENT
	JUMPLE	N,CPOPJ		;JUMP IS DO LOOP IS DONE
	PUSHJ	P,DEVOUT	;PUNCH IT
	SOJG	N,OUDEV		;LOOP FOR N COLS.
	PJRST	OUTUUO		;GET CARD OUT AND RETURN



	LOWSEG

CPCNT:	0

DEVOUT:	SOSG	CDCNT		;COUNT DOWN BUFFER HEADER COUNTER
	PUSHJ	P,OUTOUT
	IDPB	C,CDBPT		;PUT BYTE IN BUFFER
	ON	S,ANYCHR	;REMEMBER THAT WE HAVE OUTPUT SOMETHING
	AOS	CPCNT		;MAINTAIN BUFFER COUNTER
	SOSG	CDQTA		;COUNT DOWN QUOTA BY ONE COLUMN
	JRST	XCEED		;TOO MUCH OUTPUT
	POPJ	P,0		;RETURN

XCEED:	TELL	OPR!LOG!ERR,QTAOUT ;TELL THE WORLD
	ON	S,ABORT		;AND REMEMBER THE LOSS
	OUTPUT	CDP,		;SEEMS LIKE A NICE UUO
	USETI	DSK,-1		;CAUSE EOF
	SETOM	DFCNT		;NOW!!
	POPJ	P,		;RETURN


FINCRD:	PUSHJ	P,OUTUUO	;GET THE CARD OUT
FINCR1:	PJRST	GETSPL		;AND GET THE HI-SEG BACK
OUTUUO:	OP	S,ISCDP,TLNE,TRNE	;IS IT REAL CDP?
	JRST	OUTCDP		;YES
	SKIPN	CPCNT		;IS THIS A DUMMY OUTPUT?
	PJRST	OUTOUT		;YES - JUST DO UUO
	PUSH	P,T1		;WE MUST FILL
	MOVEI	T1,CPCMON	;TO 81 COLUMNS
	SUB	T1,CPCNT	;FIND HOW MANY COLS TO GO
	SETZ	C,		;FILL WITH BLANKS
FILLER:	SOJL	T1,OUTFIN	;LOOP UNTIL DONE
	SOSG	CDCNT		;COUNT DOWN BUFFER HEADER
	PUSHJ	P,OUTOUT	;GET NEW BUFFER
	IDPB	C,CDBPT		;DEPOSIT NULL
	JRST	FILLER		;GO ROUND FOR NEXT ONE

OUTCDP:	PUSHJ	P,OUTOUT	;PUNCH CARD
	CAIA
OUTFIN:	POP	P,T1		;RESTORE T1 (IF NOT CDP)
	SETZM	CPCNT		;ZERO COLUMN COUNTER
	OFF	S,ANYCHR	;CLEAR "SEEN A CHAR" FLAG
	POPJ	P,0		;RETURN

OUTOUT:	OUT	CDP,		;GIVE BUFFER TO MONITOR
	POPJ	P,0		;ALL'S WELL, RETURN
				; (THAT IS THE PLACE TO CHECK FOR HOPPER LOW, EOT)
	GETSTS	CDP,N		;RECORD STATUS
	TELL	OPR!ERR,LPTERR	;TELL ABOUT PROBLEM
	STOPCD	OUTOUT		;DIE
;	OP	S,ISCDP,TLNE,TRNE	;IS IT REAL CDP?
;	STOPCD	OUTOUT	;YES - HALT FOR NOW UNTIL CDPSER RETURNS ERRORS
;	PUSH	P,T1
;	GETSTS	CDP,T1		;GET STATUS
;	STOPCD	.		;DIE FOR NOW
	TOPSEG
LTRTAB:	BYTE	(7)	017,030,050,110,110 (1)1 (7) 050,030,017 ;A
	BYTE	(7)	066,111,111,111,111 (1)1 (7) 111,111,177 ;B
	BYTE	(7)	042,101,101,101,101 (1)1 (7) 101,101,076 ;C
	BYTE	(7)	076,101,101,101,101 (1)1 (7) 101,101,177 ;D
	BYTE	(7)	101,101,111,111,111 (1)1 (7) 111,111,177 ;E
	BYTE	(7)	100,100,110,110,110 (1)1 (7) 110,110,177 ;F
	BYTE	(7)	046,111,111,111,101 (1)1 (7) 101,101,076 ;G
	BYTE	(7)	177,010,010,010,010 (1)1 (7) 010,010,177 ;H
	BYTE	(7)	000,101,101,177,177 (1)1 (7) 101,101,000 ;I
	BYTE	(7)	176,001,001,001,001 (1)1 (7) 001,001,006 ;J
	BYTE	(7)	101,042,024,010,010 (1)1 (7) 010,010,177 ;K
	BYTE	(7)	001,001,001,001,001 (1)1 (7) 001,001,177 ;L
	BYTE	(7)	177,040,020,010,010 (1)1 (7) 020,040,177 ;M
	BYTE	(7)	177,002,004,010,010 (1)1 (7) 020,040,177 ;N
	BYTE	(7)	076,101,101,101,101 (1)1 (7) 101,101,076 ;O
	BYTE	(7)	060,110,110,110,110 (1)1 (7) 110,110,177 ;P
	BYTE	(7)	076,101,103,105,101 (1)1 (7) 101,101,076 ;Q
	BYTE	(7)	061,112,114,110,110 (1)1 (7) 110,110,177 ;R
	BYTE	(7)	106,111,111,111,111 (1)1 (7) 111,061,000 ;S
	BYTE	(7)	100,100,100,177,177 (1)1 (7) 100,100,100 ;T
	BYTE	(7)	176,001,001,001,001 (1)1 (7) 001,001,176 ;U
	BYTE	(7)	170,004,002,001,001 (1)1 (7) 002,004,170 ;V
	BYTE	(7)	177,002,004,010,010 (1)1 (7) 004,002,177 ;W
	BYTE	(7)	101,042,024,010,010 (1)1 (7) 024,042,101 ;X
	BYTE	(7)	100,040,020,017,017 (1)1 (7) 020,040,100 ;Y
	BYTE	(7)	101,141,121,111,111 (1)1 (7) 105,103,101 ;Z
NUMTAB:	BYTE	(7)	134,042,101,121,111 (1)1 (7) 105,042,035 ;0
	BYTE	(7)	000,001,001,177,177 (1)1 (7) 041,001,000 ;1
	BYTE	(7)	061,111,101,105,101 (1)1 (7) 103,101,041 ;2
	BYTE	(7)	066,111,111,111,111 (1)1 (7) 111,111,101 ;3
	BYTE	(7)	177,010,010,010,010 (1)1 (7) 010,010,170 ;4
	BYTE	(7)	106,111,111,111,111 (1)1 (7) 111,171,000 ;5
	BYTE	(7)	017,011,011,011,011 (1)1 (7) 111,077,000 ;6
	BYTE	(7)	100,140,120,110,104 (1)1 (7) 102,101,100 ;7
	BYTE	(7)	066,111,111,111,111 (1)1 (7) 111,111,066 ;8
	BYTE	(7)	176,111,110,110,110 (1)1 (7) 110,110,060 ;9
OTHER:	BYTE	(7)	000,000,000,000,000 (1)1 (7) 000,000,000 ;BLANK
>
LIST
SUBTTL	PLOTTER CONTROL ROUTINES

	IFE	PLTSPL,<XLIST>

	IFN	PLTSPL,<

	TOPSEG
FILOUT:	LDB	T1,P.FMT
	JUMPN	T1,FILOU1
	LDB	T2,[POINT 4,RBPRV,12]
	CAIL	T2,1
	AOS	T1
	AOS	T1
FILOU1:	CAIL	T1,4
	JRST	NOTYET
	MOVE	T1,SIZTAB(T1)
	HLLM	T1,DFBHD
	HLRZ	T1,Q.OSIZ
	IMULI	T1,^D60*JIFSEC
	MOVE	T2,[UPTIME]
	GETTAB	T2,
	  SETZ	T2,
	ADD	T1,T2
	MOVEM	T1,PLIMIT
	PUSH	P,[PLTOUT]
	PJRST	CLRSEG

SIZTAB:	440700,,0
	440600,,0
	440600,,0

NOTYET:	MOVE	T1,[SIXBIT /Q.FMT/]
	TELL	ERR!OPR!LOG,NOTIMP
	POPJ	P,
	LOWSEG
PLTOUT:	SOSLE	DFCNT
	JRST	PLTLDB
	PUSHJ	P,CHKLIM
	PUSHJ	P,FILL
	  PJRST	GETSPL
PLTLDB:	ILDB	C,DFBPT
	JUMPE	C,PLTOUT
	PUSHJ	P,DEVOUT
	JRST	PLTOUT

CHKLIM:	MOVE	T1,[UPTIME]
	GETTAB	T1,
	  SETZ	T1,
	MOVE	T2,PLIMIT
	SUB	T2,T1
	JUMPL	T2,XCEED
	IDIVI	T2,^D60*JIFSEC
	MOVEM	T2,PLQTA
	PJRST	CHKOPR

DEVOUT:	SOSLE	PLCNT
	JRST	PLDPB
DEVOU1:	OUT	PLT,
	JRST	PLDPB
	GETSTS	PLT,N
	TELL	OPR!ERR,LPTERR
	STOPCD	DEVOU1
PLDPB:	IDPB	C,PLBPT
	POPJ	P,

XCEED:	TELL	OPR!ERR!LOG,QTAOUT
	ON	S,ABORT
	SETOM	DFCNT
	USETI	DSK,-1
	POPJ	P,
	TOPSEG
HEAD:	MOVEI	C,40
	PUSHJ	P,DEVOUT
	MOVEI	N,MINUSY
	MOVEI	C,1
	PUSHJ	P,DEVOUT
	SOJG	N,.-1
	MOVEI	N,PLUSX
	MOVEI	C,4
	PUSHJ	P,DEVOUT
	SOJG	N,.-1
	MOVEI	N,PLUSY
	PUSHJ	P,DEVOUT
	SOJG	N,.-1
TAIL:	POPJ	P,>

	LIST
SUBTTL	PAPER TAPE PUNCH CONTROL
	IFE	PTPSPL,<XLIST>
	IFN	PTPSPL,<

;FILE HEADER AND TRAILER MAKERS

	TOPSEG
HEAD:	SETZ	C,		;CLEAR C
	MOVEI	N,^D25		;SET A COUNT
	PUSHJ	P,NOFC		;PUNCH N NULLS
	MOVSI	T1,(QUPNFH)	;BIT WHICH REALY MEANS PUNCH HEADERS
	TDNN	T1,Q.FMOD(QP)	;IS IT SET?
	POPJ	P,0		;NO--DO NOT PUNCH
	MOVEI	T2,14		;SET A COUNT
	MOVE	T1,[POINT 6,Q.USER] ;SET UP POINTER
	PUSHJ	P,OUTPIC	;PUNCH THE PICTURE
	SETZ	C,		;CLEAR C
	MOVEI	N,^D25		;SET COUNT
	PUSHJ	P,NOFC		;PUNCH THE NULLS
	PUSHJ	P,OUTFNM	;PRINT FILE NAME
	TELL	USR,[ASCIZ / ] _ @/]
	MOVEI	T5,^D10		;10 SETS
HEAD1:	MOVEI	N,12		;SET A COUNT
	MOVEI	C,0		;NULL
	PUSHJ	P,NOFC		;PUNCH SOME NULLS
	MOVEI	N,12		;SET THE COUNT AT 10
	MOVEI	C,177		;HOLY PAPER
	PUSHJ	P,NOFC		;PUNCH 10 LACED FRAMES
	SOJG	T5,HEAD1	;LOOP FOR MORE
	SETZ	C,		;CLEAR C
PTPCNT:	MOVEI	N,^D191		;ALLOW MORE ROOM
	PJRST	NOFC		;BANG OUT THE NULLS


;HERE TO PUNCH FILE.EXT INTO TAPE

OUTFNM:	MOVE	T1,[POINT 6,Q.FNAM(QP)]
	IFE	OLDMON,<	;NO SPOOLING UNDER C
	SKIPE	RBSPL		;SKIP UNLESS SPOOLED
	MOVE	T1,[POINT 6,RBSPL] ;PRINT NEW NAME>
	MOVEI	T2,6		;SET THE COUNT
	PUSHJ	P,OUTPIC	;PUNCH THE FILE NAME
	MOVEI	C,"."		;SET UP THE DOT
	PUSHJ	P,PICTURE	;PUNCH IT
	MOVE	T1,[POINT 6,Q.FEXT(QP)]
	MOVEI	T2,3		;SET THE COUNT
	PUSHJ	P,OUTPIC	;PUNCH THE PICTURE
	POPJ	P,		;RETURN
TAIL:	MOVEI	N,^D50		;ALLOW SOME SPACE
	SETZ	C,		;CLEAR C
	PUSHJ	P,NOFC		;PUNCH SOME BLANK TAPE
	MOVEI	N,5
	MOVEI	C,232		;EOF
	PUSHJ	P,NOFC		;PUNCH SOME EOF'S
	SETZ	C,		;AND A FEW NULLS
	MOVEI	N,^D20
	PUSHJ	P,NOFC		;GO BANG 'EM OUT
	MOVE	T1,[POINT 6,[SIXBIT .END OF FILE .]]
	MOVEI	T2,14		;CHAR COUNT
	PUSHJ	P,OUTPIC	;SAY END OF FILE
	PUSHJ	P,OUTFNM	; AND FILE NAME
	MOVEI	N,^D50		;GO TO A FOLD
	SETZ	C,		;PUSCH NULLS
	PJRST	NOFC		;GO DO IT.

;SUBROUTINE TO PLACE A FILE ON THE PAPER TAPE PUNCH
;CALL WITH:
;	PUSHJ	P,HELP
;	HERE WHEN DONE
;
FILOUT:	IFN	FTELF,<			;IF WE HAVE MACX11 PAPER TAPE
	LDB	T1,P.FFMT	;LOAD FILE FORMAT
	CAIN	T1,ELEVEN	;SKIP IF NOT /FILE:ELEVEN
	JRST	ELFOUT>		;GO OUTPUT THE ELEVEN FORMAT
	LDB	T1,P.FMT	;FILE FORMAT
	JUMPN	T1,FILOU1	;JUMP IF MODE GIVEN
	LDB	T1,[POINT 4,RBPRV,12]
	MOVE	T1,[EXP 1,1,0,0,0,0,0,0,2,0,0,3,4,4,4,4](T1)
FILOU1:	JUMPE	T1,NOTYET
	CAIL	T1,5		;TOO BIG?
	JRST	NOTYET		;YES--BAD CODE
ELFOUT:	HRRZI	T2,PTPOUT	;PLACE TO PLACE CODE
	HRL	T2,MODTBL(T1)	;WHERE TO GET IT
	HLRZ	T3,MODTBL(T1)	;HOW MUCH TO MOVE
	BLT	T2,PTPOUT(T3)	;MOVE THE CODE
	PUSHJ	P,SAV1		;SAVE P1
	MOVE	P1,PTQTA	;LOAD THE LIMIT
	PUSH	P,[PTPOUT]	;PUT AN ADDRESS ONTO STACK
MODTBL:	PJRST	CLRSEG		;GO CLEAR THE HISEG
	ASCSIZ,,PTASC		;ASCII Q.FMT=1
	IMASIZ,,PTIMA		;IMAGE Q.FMT=2
	IBISIZ,,PTIBI		;IBIN  Q.FMT=3
	BINSIZ,,PTBIN		;BIN   Q.FMT=4
	IFN	FTELF,<		;EXTEND TABLE FOR PDP-11
	Z			;CANT HAPPEN
	ELFSIZ,,PTELF>		;POINTER TO ELEVEN CODE
NOTYET:	MOVE	T1,[SIXBIT /Q.FMT/]	;THE BAD ITEM
	TELL	OPR!ERR!LOG,NOTIMP	;TELL THOSE WHO CARE
	POPJ	P,			;END OF THIS FILE
;SUBROUTINE TO PUNCH A FILE IN IMAGE MODE
; BLT INTO LOWSEG THEN CALL WITH:
;	PUSHJ	P,PTPOUT
;	EOF RETURN
;
PTIMA:	PHASE	PTPOUT		;WHERE IT SHOULD BE LOCATED
PTPLP:	SOSLE	DFCNT		;ANYTHING LEFT?
	JRST	PTPLDB		;YES--GET A WORD
	PUSHJ	P,FILL		;N0--FILL A BUFFER
	  PJRST	GETSPL		;OUT OF DATA
PTPLDB:	ILDB	C,DFBPT		;GET THE BYTE
	PUSHJ	P,DEVOUT	;PUNCH
	SOJG	P1,PTPLP	;COUNT DOWN QUOTA
	JRST	XCEED		;TOO MANY HOLES
	DEPHASE
IMASIZ==.-PTIMA
;SUBROUTINE TO PUNCH A FILE IN ELEVEN FORMAT
;THE FORMAT IS AS FOLLOWS:
;BYTE	1 IN BITS 10-17
;	2 IN BITS  2-09
;	3 IN BITS 28-35
;	4 IN BITS 20-27
IFN FTELF,<
PTELF:	PHASE	PTPOUT		;WHERE IT SHOULD BE LOCATED
PTPLP:	SOSLE	DFCNT		;ANYTHING LEFT
	JRST	PTPLDB		;YES--GET A WORD
	PUSHJ	P,FILL		;NO--FILL A BUFFER
	  PJRST	GETSPL		;OUT  OF DATA
PTPLDB:	ILDB	C,DFBPT		;LOAD A WORD
	MOVEM	C,ELFCH		;STORE IT FOR LATER
	MOVEI	T1,3		;FOR SELECTION OF BYTE POINTER
	SUBI	P1,3		;COUNT DOWN QUOTA
CCL11:	LDB	C,ELFPTR(T1)	;SELECT A BYTE
	PUSHJ	P,DEVOUT	;PUT IT IN THE TAPE
	SOJGE	T1,CCL11	;COUNT DOWN
	SOJG	P1,PTPLP	;COUNT DOWN QUOTA JUMP IF SOME LEFT
	PJRST	XCEED		;STOP IT
	DEPHASE
ELFSIZ==.-PTELF
> ;END TEST OF FTELF
;SUBROUTINE TO PUNCH A FILE IN ASCII
;CALL WITH
;	PUSHJ	P,PTPOUT	;AFTER BLT
;	EOF RETURN
;
PTASC:	PHASE	PTPOUT		;PHASED CODE
PTPLP1:	SOSLE	DFCNT		;ANYTHING TO PUNCH?
	JRST	PTLDB		;YES--GO PUNCH IT
	MOVEM	P1,PTQTA	;STORE QUOTA
	PUSHJ	P,FILL		;GO GET MORE
	  PJRST	GETSPL		;END OF FILE
PTLDB:	ILDB	N,DFBPT		;GET A WORD
PTPGET:	TRZ	N,1		;CLEAR BIT 35
	JUMPE	N,PTPLP1	;IGNORE NULL WORDS
	SETZ	C,
	LSHC	C,7		;SHIFT IN A CHAR
	JUMPE	C,PTPGET	;IGNORE NULLS
	MOVEI	T1,(C)		;COPY CHAR
	LSH	T1,-4		;SHIFT OVER
	XORI	T1,(C)		;FIND DIFFERENT BITS
	TRCE	T1,14		;LOOK AT 2 BITS
	TRNN	T1,14		;ARE THEY THE SAME?
	TRC	C,200		;YES--MAKE EVEN PARITY
	TRCE	T1,3		;LOOK AT THE OTHER 2 BITS
	TRNN	T1,3		;ARE THEY THE SAME?
	TRC	C,200		;YES--MAKE EVEN PARITY
PTPUT:	PUSHJ	P,DEVOUT	;PUNCH THE CHAR
	SOJLE	P1,XCEED	;COUNT DOWN QUOTA
	CAIE	C,11		;HORIZ. TAB?
	CAIN	C,213		;VERT. TAB?
	JRST	PTPP1		;YES--ADD A RUBOUT
	CAIE	C,14		;FORM FEED?
	JRST	PTPGET		;NO-- MARCH ON.
	MOVEI	T1,20		;NEED 20 NULLS
	SETZ	C,		;NULL
	PUSHJ	P,DEVOUT	;PUNCH
	SOJLE	P1,XCEED	;COUNT DOWN QUOTA
	SOJG	T1,.-2		;COUNT DOWN NULLS
	JRST	PTPGET		;GET NEXT CHAR
PTPP1:	MOVEI	C,377		;RUBOUT
	JRST	PTPUT		;PUNCH
	DEPHASE
ASCSIZ==.-PTASC
;SUBROUTINE TO PUNCH TAPE IN BINARY MODE
;BLT TO PTPOUT
;CALL WITH:
;	PUSHJ	P,PTPOUT
;	RETURN HERE
;
PTBIN:	PHASE	PTPOUT
	SETZ	T1,		;FORCE A CHECKSUM
BINLP:	SOSLE	DFCNT		;ANY CHARS?
	JRST	BNLDB		;YES--GO EAT ONE
	MOVEM	P1,PTQTA	;FOR "WHAT" COMMAND
	PUSHJ	P,FILL		;READ A BLOCK
	  PJRST	GETSPL		;GO IT
BNLDB:	SOJG	T1,CHECKD	;JUMP UNLESS WE NEED A CHECKSUM
;HERE TO COMPUTE THE FOLDED CHECKSUM. NOTE THAT THE DISK BUFFER
; MUST BE A MULTIPLE OF THE PUNCH BUFFER FOR THIS TO WORK SINCE
; IT LOOKS AHEAD IN THE INPUT BUFFER.
	HRLZI	T2,-40		;-VE WORD COUNT
	HRR	T2,DFBPT	;POINTER TO DATA
	AOS	T2		;INCREMENT BYTE POINTER
	SETZ	T1,		;CLEAR THE SUM
CKS12A:	ADD	T1,(T2)		;TAD IN A WORD
	AOBJN	T2,CKS12A	;LOOP FOR MORE
	LSHC	T1,-30		;FOLD THE SUM
	LSH	T2,-14
	ADD	T1,T2
	LSHC	T1,-14
	LSH	T2,-30
	ADD	T1,T2
	TRZE	T1,770000
	AOS	T1
	HRLZ	N,T1		;PUT SUM IN LEFT HALF
	HRRI	N,40		;I DO NOT KNOW THAT THIS IS REQUIRED
				; BUT IT WILL NOT HURT.
	MOVEI	T1,5		;LEAVE "SEVERAL" BLANK FRAMES
	SETZ	C,		;SUPER NULL
	PUSHJ	P,DEVOUT	;THWAP!
	SOJG	T1,.-1		;GRIND OUT SOME MORE
	PUSHJ	P,PUNWD
	  POPJ	P,
	MOVEI	T1,40		;NEW WORD COUNT
CHECKD:	ILDB	N,DFBPT		;GET A WORD
	PUSHJ	P,PUNWD		;PUNCH IT
	  POPJ	P,
	JRST	BINLP
PUNWD:	MOVEI	T2,6		;SET UP COUNT
BINLP1:	SETZ	C,		;CLEAR  TEMP
	LSHC	C,6		;LOAD A DIGIT
	TRO	C,200		;SET THE BINARY BIT
	PUSHJ	P,DEVOUT	;PUNCH IT-- AT LAST!
	SOJLE	P1,XCEED	;WATCH THE LIMIT
	SOJG	T2,BINLP1	;PUNCH ANOTHHER DIGIT
	JRST	CPOPJ1		;DONE!
	DEPHASE
BINSIZ==.-PTBIN
;SUBROUTINE TO PUNCH TAPE IN IMAGE BINARY
;BLT TO PTPOUT
;CALL WITH:
;	PUSHJ	P,PTPOUT
;	EXIT
;
PTIBI:	PHASE	PTPOUT
PTPLP2:	SOSLE	DFCNT		;ANYTHIN TO PUNCH?
	JRST	PTLDB1		;PUNCH IT
	MOVEM	P1,PTQTA	;STORE FOR "WHAT"
	PUSHJ	P,FILL		;REFILL BUFFER
	  PJRST GETSPL		;DONE!
PTLDB1:	ILDB	N,DFBPT		;PICK UP A WORD
	MOVEI	T1,6		;6 CHARS
IBLOOP:	SETZ	C,		;CLEAR C
	LSHC	C,6		;SHIFT IN A CHAR
	TRO	C,200		;ADD A BIT
	PUSHJ	P,DEVOUT	;PUNCH
	SOJLE	P1,XCEED	;COUNT DOWN QUOTA
	SOJG	T1,IBLOOP	;ANY MORE?
	JRST	PTPLP2		;LOOP FOR MORE
	DEPHASE
IBISIZ==.-PTIBI
;SUBROUTINE TO PRINT N LINES OF C(C)
;CALL WITH:
;	MOVEI	N,NUMBER-OF-COPIES
;	MOVE	C,CHAR
;	PUSHJ	P,NOFC
;	RETURN
;
NOFC:	PUSHJ	P,DEVOUT	;OUTPUT A CHAR
	SOJG	N,.-1		;LOOP FOR MORE
	POPJ	P,

;SUBROUTINE TO PRINT  A PICTURE IN TAPE
;CALL WITH:
;	MOVE	T1,BYTE-POINTER
;	MOVE	T2,LENGTH
;	PUSHJ	P,OUTPIC
;	RETURN HERE
;
OUTPIC:	MOVEM	T1,SAVT1	;SAVE POINTER
	MOVEM	T2,SAVN		;SAVE COUNT
	ON	S,LFSEEN	;IGNORE LEADING BLANKS
PICLP:	ILDB	C,SAVT1		;GET A BYTE
	JUMPE	C,NULCHR	;IGNORE NULLS
PUN:	MOVEI	C,40(C)		;CONVERT TO ASCII
	OFF	S,LFSEEN	;REAL CHARS
	PUSHJ	P,PICTUR	;PUNCH
NOPUN:	SOSE	SAVN		;COUNT DOWN COUNT
	JRST	PICLP		;LOOP FOR MORE
	POPJ	P,		;RETURN 
NULCHR:	IFON	S,LFSEEN,NOPUN
	JRST	PUN
;SUBROUTINE TO PUNCH 1 CHAR INTO TAPE
;CALL WITH:
;	MOVE	C,CHAR
;	PUSHJ	P,DEVOUT
;	RETURN HERE
;
	LOWSEG
DEVOUT:	IFON	S,NOTYPE,CPOPJ	;SPACE THE FILE
	SOSLE	PTCNT		;ROOM IN BUFFER
	JRST	PTDPB		;YES--DEPOSIT THE BYTE
DEVOU1:	OUT	PTP,0		;SHIP OUT THE BUFFER
	  JRST	PTDPB		;ALL IS WELL
	GETSTS	PTP,N		;GET STATUS
	TELL	OPR!ERR,LPTERR	;TELL OPR
	STOPCD	DEVOU1
PTDPB:	IDPB	C,PTBPT		;STORE BYTE
	POPJ	P,


;HERE WHEN USER IS OVER HIS PAPER TAPE QUOTA

XCEED:	IFON	S,NOTYPE,FIXUPS	;JUMPE IF FUDGE
	TELL	OPR!LOG!ERR,QTAOUT
	ON	S,ABORT		;HE HAS LOST
	OUTPUT	PTP,		;DUMP LAST BUFFER
	USETI	DSK,-1		;CAUSE EOF
	POPJ	P,		;RETURN

;HERE WHEN A FORWARD OR BACKSPACE HITS ITS TARGET

FIXUPS:	XFR	PTEMP,PTQTA	;RESTORE QUOTA
	OFF	S,NOTYPE	;CLEAR THE FLAG
	JRST	PTPOUT		;BACK TO WORK
	TOPSEG

;SUBROUTINE TO SPACE FORWARD N FEET
;CALLED FROM COMIN:
;	PUSHJ	P,FORWAR
;	RETURN WITH SOME LOCATIONS FIXED
;
FORWAR:	PUSHJ	P,DECARG	;GET ARGUMENT
	  POPJ	P,		;ZERO
	ON	S,NOTYPE	;SILENCE THE PTP
	XFR	PTQTA,PTEMP	;SAVE THE REAL QUOTA
	IMULI	N,CPF		;FEET TO CHARS
	MOVEM	N,PTQTA		;SAVE AS PHONY QUOTA
	POPJ	P,		;RETURN

;SUBROUTINE TO BACKSPACE N FEET
;SEE FORWARD
;NOTE: FILE IS READ FORWARD UNTILL DESIRED PART IS FOUND
;
BACKSP:	HLRZ	T2,Q.OSIZ	;GET OUTPUT SIZE
	IMULI	T2,CPF		;FORM OLD QUOTA
	SUB	T2,PTQTA	;WHERE WE ARE NOW
	PUSHJ	P,DECARG	;GET ARGUMENT
	 POPJ	P,		;ZERO OR FUNNY
	IMULI	N,CPF		;CONVERT TO CHARS
	SUB	T2,N		;WHERE WE WANT TO BE
	XFR	PTQTA,PTEMP	;SAVE REAL QUOTA
	MOVEM	T2,PTQTA	;SAVE AS TARGET
	USETI	DSK,1		;REWIND THE INPUT
	ON	S,NOTYPE	;DO NOT RETYPE 
	POPJ	P,
;SUBROUTINE TO PUNCH BLOCK CHARS. -- ART BAKER
;CALL WITH:
;	MOVE	C,CHAR-TO-PUNCH
;	PUSHJ	P,PICTURE
;	RETURN HERE
;
PICTUR:	PUSHJ	P,SAV2		;GET 2 AC'S
	MOVEI	P1,5		;HOW MANY COLUMNS
	CAIGE	C,40		;CAN WE PUNCH THIS?
	POPJ	P,		;NO--IGNORE
	CAILE	C,"_"		;LOWER CASE?
	MOVEI	C,-40(C)	;YES--CONVERT TO UPPER CASE
	MOVEI	T1,-40(C)	;SUBTRACT 40 -- MAKE SIXBIT
	MOVEI	T2,20		;A MASK FOR LATER

LOOP2:	MOVE	T4,[POINT	5,CHRTAB(T1)]	;POINTER TO CHARACTER
	MOVEI	P2,7		;HOW MANY ROWS

	SETZ	C,		;NEED THIS IN AWHILE

LOOP:	ILDB	T5,T4		;GET FIVE BITS FRM CHRTAB
	AND	T5,T2		;USE ONLY ONE OF THEM
	MOVN	T3,P1		;HOW MANY STILL LEFT?
	LSH	T5,10(T3)	;SHIFT IT TO THE LEFT
	IOR	C,T5		;AND PUT BIT IN PLACE
	LSH	C,-1		;THEN SHIFT EVERYONE RIGHT
	SOJG	P2,LOOP		;KEEP GOING?
	PUSHJ	P,DEVOUT	;OUTPUT THE BYTE (IMAGE MODE)
	SOJL	P1,AWAY		;ALL COLUMNS DONE?

	LSH	T2,-1		;SHIFT MASK TO RIGHT
	JRST	LOOP2		;AND KEEP GOING

AWAY:	SETZ	C,		;2 BLANK COLUMNS -- TO LOOK PRETTY
	PUSHJ	P,DEVOUT
	PUSHJ	P,DEVOUT
	POPJ	P,		;RETURN TO CALLER

CHRTAB:	BYTE (5) 00,00,00,00,00,00,00	;SP
	BYTE (5) 04,04,04,04,04,00,04	;!
	BYTE (5) 12,12,00,00,00,00,00	;"
	BYTE (5) 12,12,37,12,37,12,12	;#
	BYTE (5) 04,37,24,37,05,37,04	;$
	BYTE (5) 31,31,02,04,10,23,23	;%
	BYTE (5) 10,24,10,24,23,22,15	;&
	BYTE (5) 06,02,00,00,00,00,00	;'
	BYTE (5) 04,10,20,20,20,10,04	;(
	BYTE (5) 04,02,01,01,01,02,04	;)
	BYTE (5) 00,25,16,33,16,25,00	;*
	BYTE (5) 00,04,04,37,04,04,00	;+
	BYTE (5) 00,00,00,00,00,06,02	;,
	BYTE (5) 00,00,00,37,00,00,00	;-
	BYTE (5) 00,00,00,00,00,06,06	;.
	BYTE (5) 00,00,01,02,04,10,20	;/

	BYTE (5) 16,21,23,25,31,21,16	;0
	BYTE (5) 04,14,04,04,04,04,16	;1
	BYTE (5) 16,21,01,02,04,10,37	;2
	BYTE (5) 16,21,01,02,01,21,16	;3
	BYTE (5) 22,22,22,37,02,02,02	;4
	BYTE (5) 37,20,34,02,01,21,16	;5
	BYTE (5) 16,20,20,36,21,21,16	;6
	BYTE (5) 37,01,01,02,04,10,20	;7
	BYTE (5) 16,21,21,16,21,21,16	;8
	BYTE (5) 16,21,21,17,01,01,16	;9
	BYTE (5) 00,06,06,00,06,06,00	;:
	BYTE (5) 00,06,06,00,06,06,02	;;
	BYTE (5) 02,04,10,20,10,04,02	;<
	BYTE (5) 00,00,37,00,37,00,00	;=
	BYTE (5) 10,04,02,01,02,04,10	;>
	BYTE (5) 16,21,01,02,04,00,04	;?

	BYTE (5) 16,21,21,27,25,25,07	;@
	BYTE (5) 16,21,21,21,37,21,21	;A
	BYTE (5) 36,21,21,36,21,21,36	;B
	BYTE (5) 17,20,20,20,20,20,17	;C
	BYTE (5) 36,21,21,21,21,21,36	;D
	BYTE (5) 37,20,20,36,20,20,37	;E
	BYTE (5) 37,20,20,36,20,20,20	;F
	BYTE (5) 17,20,20,20,27,21,16	;G
	BYTE (5) 21,21,21,37,21,21,21	;H
	BYTE (5) 16,04,04,04,04,04,16	;I
	BYTE (5) 01,01,01,01,21,21,16	;J
	BYTE (5) 21,21,22,34,22,21,21	;K
	BYTE (5) 20,20,20,20,20,20,37	;L
	BYTE (5) 21,33,25,21,21,21,21	;M
	BYTE (5) 21,21,31,25,23,21,21	;N
	BYTE (5) 16,21,21,21,21,21,16	;O


	BYTE (5) 36,21,21,36,20,20,20	;P
	BYTE (5) 16,21,21,21,25,22,15	;Q
	BYTE (5) 36,21,21,36,24,22,21	;R
	BYTE (5) 17,20,20,16,01,01,36	;S
	BYTE (5) 37,04,04,04,04,04,04	;T
	BYTE (5) 21,21,21,21,21,21,37	;U
	BYTE (5) 21,21,21,21,21,12,04	;V
	BYTE (5) 21,21,21,21,25,33,21	;W
	BYTE (5) 21,21,12,04,12,21,21	;X
	BYTE (5) 21,21,12,04,04,04,04	;Y
	BYTE (5) 37,01,02,04,10,20,37	;Z
	BYTE (5) 14,10,10,10,10,10,14	;[
	BYTE (5) 00,00,20,10,04,02,01	;\
	BYTE (5) 06,02,02,02,02,02,06	;]
	BYTE (5) 00,04,16,25,04,04,00	;^
	BYTE (5) 00,04,10,37,10,04,00	;_
	>		;END PTPSPL FROM WAY BACK
	LIST
SUBTTL	INITIALIZATION AND REENTER

	LOWSEG
SPOOL:	JRST	.+2		;SKIP IF NORMAL START
	OUTSTR	[ASCIZ /% CCL START NOT SUPPORTED
/]
	RESET			;CLEAR ALL ACTIVE I/O
	SETZM	LOWEST		;CLEAR ALL SCRATCH
	MOVE	T1,[LOWEST,,LOWEST+1]  ; STORAGE
	BLT	T1,HIEST	;ZAPP!
	MOVE	P,[IOWD PDSIZE,PDL]
	MOVE	S,[INITS]	;SET OUR GLOBAL AC'S
	MOVE	T1,[QUEPPN]	;FIND THE UFD INTO WHICH
	GETTAB	T1,		;DATA WAS RENAMED
	  MOVE	T1,[3,,3]	;FOR COMPATABILITY
	MOVSI	T2,'QUE'	;NAME OF PRIVATE QUEUE DEVICE
	DEVPPN	T2,		;DOES IT EXIST?
	  GETPPN T2,		;GET THIS UFD
	MOVSI	T3,'QUE'	;SEE IF QUE EXISTS
	DEVCHR	T3,		; ..
	SKIPE	T3		; ..
	MOVE	T1,T2		;YES--USE PRIVATE QUE
	MOVEM	T1,DFQUE	;SAVE FOR LATER
	PUSHJ	P,GETSPL	;GET THE CORRECT HISEG
	PUSHJ	P,SETINT	;FOR DEVICE O.K. INTERRUPT
	JRST	REVUP		; AND GO TO IT
REN:	PUSHJ	P,GETSPL	;GET THE HISEG
	PUSHJ	P,SETINT
	IFON	S,DSKOPN,FILOUT	;HUNG DEVICE?? (PRAY SOME)
	JRST	MAIN		;TRY TO CONTINUE
	TOPSEG
REVUP:	HRROI	T1,JBTSGN	;GET HISEG INDEX
	GETTAB	T1,		; ..
	  STOPCD .		; ..
	HRLZ	T2,T1		;GET THE JOB STATUS
	GETTAB	T2,		; WORD FOR HISEG
	  SKIPA			;IT SHOULD BE THERE!!!
	TLNN	T2,200000	;SHARE SEG
	JRST	[OUTSTR	[ASCIZ	/% Hiseg not .SHR
/]
		MOVSI	T2,'DSK'
		JRST	REV1]
	HRLZ	T2,T1		;GET HISEG DEVICE
	HRRI	T2,JBTDEV	; ..
	GETTAB	T2,		; ..
	  MOVSI	T2,'DSK'	;NO TABLE IN LEVEL C
	HRRI	T3,JBTNAM	;GET HISEG DEVICE
	HRL	T3,T1		; ..
	GETTAB	T3,		; ..
REV1:	  MOVE	T3,[XXXSPL]	;GIVE THE DEFAULT
	HRLZ	T4,T1		;GET THE PPN
	HRRI	T4,JBTPPN	; ..
	GETTAB	T4,		; ..
	  GETPPN T4,		;SAY SOMETHING
	JUMPGE	T4,SVHISG	;NEGATIVE PPN
	CAMN	T2,[SIXBIT /DSK/]; AND DEVICE DSK MEAN PPN IS DEVICE
	MOVE	T2,T4		;SO PUT IN CORRECT PLACE
	MOVEI	T4,0		;AND CLEAR PPN
SVHISG:	MOVEM	T2,SEGBLK	;SAVE DEVICE
	MOVEM	T3,SEGBLK+1	;SAVE FILE NAME
	MOVEM	T4,SEGBLK+4	;SAVE DIRECTORY
	SETZM	SEGBLK+5	;AND DON'T CALL CORE0 
	INIT	TTY,AL		;INIT THE TTY
	SIXBIT	/TTY/		;DEVICE NAME
	XWD	TTBHD,0		;BUFFER HEADER
	  EXIT			;NO. TTY
	MOVSI	T2,'DSK'	;NAME FOR DSKCHR
	MOVE	T1,[1,,T2]	;POINTER
	DSKCHR	T1,		;GET CHAR
	  JRST NODSK		;NOT A DISK
	TLNE	T1,7		;IS IT A SUBSET
	  JRST NODSK		;YES. 
	IFN	LPTSPL,<	;GET STUFF FOR HEADER
	MOVE	T1,[CONFI1]	;NAME OF TABLE
	GETTAB	T1,		;LOOK IN TABLE
	  JFCL
	MOVEM	T1,LPCNF	;CONFIG DATA
	MOVE	T1,[CONFI2]	;NAME OF TABLE
	GETTAB	T1,
	  JFCL
	MOVEM	T1,LPCNF+1
	MOVE	T1,[CONFI3]
	GETTAB	T1,
	  JFCL
	MOVEM	T1,LPCNF+2
	MOVE	T1,[CONFI4]
	GETTAB	T1,
	  JFCL
	MOVEM	T1,LPCNF+3
	MOVE	T1,[CONFI5]
	GETTAB	T1,
	  JFCL
	MOVEM	T1,LPCNF+4
	MOVEI	T1,LPP		;LINES PER PAGE
	MOVEM	T1,LPLPP>	;STORE IN CONTROL BLOCK
	MOVE	T1,[10,,LOGSAV]	;TRY TO FIND OUR DEFAULT PATH
	SETOM	LOGSAV		;-1 FOR RETURN PATH
	PATH.	T1,		;ASK FOR PATH
	  OP	S,SFDMON,TLZA,TRZA ;NO SFD LOGIC
	ON	S,SFDMON	;WE HAVE SFD LOGIC
	MOVEI	T1,IFC		;INITIAL FAIRNESS COUNT
	MOVEM	T1,FAIRCT	;SAVE IN COUNTER
	MOVE	T1,[PUSHJ P,UUOL] ;PUSHJ FOR UUO'S
	MOVEM	T1,.JB41	;SAVE IN USER 41
	MOVEI	T1,CLKINT	;ADDRESS OF INTERUPT BLOCK
	MOVEM	T1,.JBAPR	;SAVE IN .JBDAT
	MOVEI	T1,REN		;SET UP REENTER ADDRESS
	MOVEM	T1,.JBREN	;STORE IN .JBDAT
	MOVSI	T1,(DEV)	;PUT DEFAULT DEVICE IN
	MOVSI	T2,(DEV)	; T1 - T3
	MOVSI	T3,(DEV)	;  ...
	DEVTYP	T2,		;GET DEVTYP OF DEFAULT
	  JRST	NOFACT		; 5.02 OR EARLIER
	DEVTYP	T3,1B19		;GET PHYSICAL DEVTYP
	  JRST	.+2		;STRANGE?
	CAME	T2,T3		;DOES REAL DEVTYP MATCH LOGICAL DEVTYP?
	TELL	OPR,[ASCIZ /99% + is a logial name
/]
	TLNE	T2,(1B13)	;YES--SPOOLED?
	TELL	OPR,[ASCIZ /99% + IS SPOOLED
/]
	IFN	FACTSW,<
	MOVE	N,[1,,FACT]	;WRITE A ZERO LENGTH
	DAEMON	N,		; FACT FILE ENTRY
	  JRST	DAEFAI		;UUO FAILED>
	IFE	OLDMON,<	;CHECK REALY LEVEL-D
NOFACT:	MOVE	T1,[STATES]	;GET THE STATES WORD
	GETTAB	T1,0		;TRY TO GET THE WORD
	  JRST	.+2		;NO GETTAB
	TLNN	T1,3400		;LEVEL-D
	JRST	[		;NO. PRINT A MESSAGE
	TELL	OPR!ERR,NEEDDM	;TELL THE OPERATOR
	EXIT	1,		;PUNT
	STOPCD	.-1]		;WISE GUY>
	PUSHJ	P,SETINT	;SET FOR DEVICE O.K.
	IFN	FTLOCK,<	;LOCK UUO
	MOVEI	N,1		;CODE FOR NOT THERE
	LOCK	N,		;LOCK THE JOB
	  TELL	OPR!ERR,NOKEYS>	;NOT EXACTLY
	MOVEI	T1,30000	;BAD MEM REF
	APRENB	T1,		;ENABLE
	TELL	OPR,STAR	;FLASH A STAR
INILP:	INCHWL	SAVCHR		;GET A CHAR
	PUSHJ	P,COMIN		;DO THE COMMAND
	IFOFF	S,OPENB,INILP	;IF NOT START TRY AGAIN
	JRST	MAIN
NODSK:	OUTSTR	[ASCIZ /?DSK IS A LOGICAL NAME
/]
	EXIT
;HERE IF DAEMON UUO FAILS

	IFN	FACTSW,<
DAEFAI:	SKIPLE	FACTFL#		;ONLY GIVE ERROR MESSAGE OCCASIONALLY
	JRST	NOFACT
	MOVEI	T1,FCTCNT	;RETRY EVERY FCTCNT TIMES
	MOVEM	FACTFL
	CAMN	N,[1,,FACT]	;WAS AC CHANGED
	TELL	OPR,[ASCIZ /99%DAEMON not running
/]
	CAIN	N,1		;ILL FUNCTION
	TELL	OPR,[ASCIZ /99% .FACT Function not in DAEMON
/]
	CAIN	N,6		;NO PRIVS.
	TELL	OPR,[ASCIZ /99% No privs to write FACT file
/]
	TELL	OPR,[ASCIZ /99% Accounting will not be done
/]
	JRST	NOFACT>

SUBTTL	MESSAGES

;THE FIRST CHAR OF EACH MESSAGE IS THE PRIORITY THE SECOND IS THE 
;INITIAL LENGTH CODE. THE FOLLOWING CHARACTORS HAVE A SPECIAL MEANING:
;
;	#	PRINT N AS DECMAL
;	&	PRINT N AS OCTAL
;	@	PRINT THE TIME 
;	_	PRINT THE DATE
;	^	PRINT THE CURRENT FILE NAME
;	[	PRINT THE CURRENT UFD
;	]	PRINT THE PPN OF CURRENT USER
;	;	CHANGE LENGTH CODE (NEW CODE AFTER ;)
;	+	PRINT T1 AS A SIXBIT WORD
;	"	PRINT N AS A PROTECTION (AT LEAST 3 OCTAL DIGITS)

;***WARNING*** This page is in upper and lower case and
; should not be edited with TECO unless you have a Full char
; set TTY. If it is neccessary to edit on a KSR33 or
; similar TTY use an editor which will indicate lower case
; for example SOS (DECUS 10-16)
;

	DEFINE	TEXT,<
	XLIST
WHAT1: ASCIZ ?99Job: +,?
WHAT2: ASCIZ ?99Seq: #,?
WHAT3: ASCIZ ?99Name: +?
WHAT4: ASCIZ ?99+,?
WHAT4A: ASCIZ ?99PPN:  ],
?
WHAT5: ASCIZ ?99File: ^[,?
WHAT6: ASCIZ ?99Limit: #,?
WHAT7: ASCIZ ?99Left: #,?
WHAT8: ASCIZ ?99Copies: #,?
WHAT9: ASCIZ ?99Disp: &
?
WHATB2: ASCIZ ?69Operator intervention required
?
WHATB3: ASCIZ ?69SPOOL will PAUSE at EOJ
?
WHATB4: ASCIZ ?69ARROW Mode
?
WHATB5: ASCIZ ?69SUPPRESS Mode
?
WHATB6: ASCIZ ?69File located in QUEUE directory
?
WHATB7: ASCIZ ?69BACKSPACE or FORWARD in progress
?
DEVNOK:	ASCIZ	.99Device + not ready # tries
.
NOTIMP: ASCIZ	.99Code too large in + Feature not implemented
.
NOSPC: ASCIZ .69Bad file syntax near +
.
NOPPN:	ASCIZ	.69Invalid Directory
.
BADIGM: ASCIZ /69+ is INVALID 0 Used
/
FTYPE:	ASCIZ	/99+ forms mounted
/
UNEXPD:	ASCIZ	\99Unexpected string (+) found while scanning for switch - ignored
\
BADNMS:	ASCIZ	/69 BAD Decmal number
/
	IFE	OLDMON,<
NEEDDM: ASCIZ /69 Level D version will not run under Level C
/>
ANODEV: ASCIZ /69Can't INIT +
/
ANOFIL: ASCIZ /69Can't find that file
/
	IFN	FTLOCK,<
NOKEYS: ASCIZ /69Lock UUO failed - Code: &
/>
NOSTR: ASCIZ /29Can't init STR for ^[
/
SYSERR: ASCIZ /69System failure for ^[  - UUO Code: &
/
FNFERR: ASCIZ /29^[ File not found
/
IPPERR: ASCIZ /49^[ No UFD on that File Structure
/
PRTERR: ASCIZ /29^[ File protected
/
FBMERR: ASCIZ /49^[ file being modified
/

DNEERR:	ASCIZ	/69Atempt to delete a nonempty SFD -^[
/
UNDERR:	ASCIZ	/99 Undefined error code (&) returned for file ^[
/
SNFERR:	ASCIZ	/29SFD not found for file ^[
/
LVLERR:	ASCIZ	/49Attempt to nest too many SFD's
/
NETERR: ASCIZ /99^[ No free core in monitor
/
BADSW: ASCIZ /69Bad Switch
/
CURMS1:	ASCIZ	/99Current defaults: MLIMIT:# MSGLVL:/
CURMS2:	ASCIZ	/99 ZZZ:#
/
DEVBSY: ASCIZ /69Device is Busy -- Waiting
/
FILBSY: ASCIZ /69Can't Create File
/
BADCOM: ASCIZ /69+ is an unknown Command
/

LOGERR:	ASCIZ	.69 I/O Error writing log file - Status: &
.
NOCORE:	ASCIZ	/99NOT ENOUGH CORE TO READ QUEUE REQUEST
/
NOTIME: ASCIZ /69Time switches are unsupported.
/
NOARG: ASCIZ /69Switch needs an argument
/

BADATA: ASCIZ .49Disk input data read I/O Error(&), Recovery attempted
.
CMDER1: ASCIZ /69Please type STOP or PAUSE
/
CMDER2: ASCIZ /99SPOOL is not START'ed
/
COMER3:	ASCIZ /99Type a RESET first
/
CMDE2A: ASCIZ /99No files active
/
NODEV: ASCIZ .69Device does not exist
.
MOUNTM: ASCIZ .99Mount type + forms then type GO
.
NOTSFD:	ASCIZ	.99% SFD specification (+) will not be used
.
NOTBSY:	ASCIZ	.69Spooler is idle
.
DEVOK:	ASCIZ /99% Device + is not ready
/
MESS1: ASCIZ /49Job + file ^[ for ] started 
/
MESS2: ASCIZ /29^[ Done
/
CNTDEL: ASCIZ /49 File ^[ Protected and will not be deleted
/
STAR:	 ASCIZ /99*/
EXCLPT: ASCIZ /99!/
RIBERR: ASCIZ .69I/O error on UFD or RIB of ^[
.
NRMERR:	ASCIZ	.99DISK QUOTA EXCEEDED FOR FILE ^[
.
WLKERR:	ASCIZ	.99 WRITE LOCK ERROR FOR FILE ^[
.
QTAOUT: ASCIZ .59Output forms limit  EXCEEDED for file ^

.
LPTERR:	ASCIZ	.99 I/O Error on output device  - Status: &
.
BEGIN:	CSPNAME	;TITLE LINE
BABORT: ASCIZ .99Request ABORTED because of I/O errors  -LAST GETSTS: &
.
	IFN	LPTSPL,<
STARS:	ASCII	"00000000000000000000000000000000000000000000000000"
	ASCII	"00000000000000000000000000000000000000000000000001"
	ASCII	"111111111111111111111111111111"
	BYTE	(7)177,61,177,61,23
	ASCII	"00000000011111111112222222222333333333344444444445"
	ASCII	"55555555566666666667777777777888888888899999999990"
	ASCII	"000000000111111111122222222223"
	BYTE	(7)177,63,177,63,23
	ASCII	"12345678901234567890123456789012345678901234567890"
	ASCII	"12345678901234567890123456789012345678901234567890"
	ASCII	"123456789012345678901234567890"
	BYTE	(7)61,62,23,0	; 12<DC3><NULL>
JBHDR1:	ASCIZ	/User +/
JBHDR2:	ASCIZ	/+ ] Job /
JBHDR3:	ASCIZ	/ + /
JBHDR4:	ASCIZ	/Seq. # /
JBHDR5:	ASCIZ	/Date _ @ Monitor /
HDRMSG:	ASCIZ	/ *START* /
TRLMSG:	ASCIZ	/ **END** /
HDCRLF:	REPEAT	HSPACE,<
	BYTE	(7) 40,40,40,15,23>
	Z
	>
CRLF:	BYTE	(7) 15,12,00,00,00

;USED BY OUTSTR UUO NOT TELL UUO

TTIOER:	ASCIZ	.I/O Error on device TTY
.
	LIST>			;CLOSE TEXT MACRO
	TEXT
	LOWSEG
	VAR
	LIT
SPLEND::END	SPOOL
dLr5S