




!COPYRIGHT 1972,1973, DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS
!AUTHOR: S. MURPHY
GLOBAL BIND STREV=91;		!VERSION DATE: JULY 11, 1973



EXTERNAL DBLMODE;		!THIS FLAG WORD IS SET WHEN A STATEMENT IS BEING
			! ALLOCATED DOUBLE-PRECISION MODE (IE FOR AN ASSIGNMENT
			! STMNT IF THE TOP-LEVEL EXPRESSIONS ARE DOUBLE-PRECISION)

MAP PEXPRNODE TREEPTR;

MAP BASE CSTMNT;


GLOBAL ROUTINE STREGA=
%(***************************************************************************
	ROUTINE TO PERFORM LOCAL REGISTER ALLOCATION FOR A STATEMENT.
	CALLED WITH THE GLOBAL CSTMNT POINTING TO THE STATEMENT.
	CALLED WITH THE GLOBALS
		STBSYR - HAS BIT SET FOR EACH REG AVAILABLE FOR USE IN EVALUATING
			THIS STATEMENT
		STRGCT - CT OF REGS AVAILABLE
***************************************************************************)%
BEGIN
	%(***PERFORM COMPLEXITY ANALYSIS ON THE STMNT***)%
	CMSTMN();

	%(***PERFORM REGISTER ALLOCATION ON THE STMNT***)%
	ALCSTMN();

END;


GLOBAL ROUTINE CMSTMN=
%(***************************************************************************
	TO PERFORM COMPLEXITY ANALYSIS ON A STATEMENT.
	CALLED WITH THE GLOBAL CSTMNT POINTING TO THE STATEMNET TO BE PROCESSED.
***************************************************************************)%
BEGIN
	EXTERNAL CMPFNARGS;
	EXTERNAL LPIXSUB;	!ROUTINE TO SUBSTITUTE REGCONTENTS NODES FOR
				! REFERENCES TO THE LOOP INDEXIN AN INNERMOST
				! DO LOOP
	EXTERNAL STCMSUB;
	OWN PEXPRNODE RECNO;	!PTR TO SYMBOL TABLE OR CONSTANT TABLE ENTRY
				! FOR A RECORD NUMBER FOR AN IO STMNT

	%(***DEFINE A ROUTINE TO USE TO ALLOCATE CORE FOR ANY CONSTANT USED AS
		A RECORD NUMBER IN AN IO STMNT***)%
	ROUTINE CMPRECNO=
	BEGIN
		IF (RECNO_.CSTMNT[IORECORD]) NEQ 0
		THEN
		BEGIN
			IF .RECNO[OPR1] EQL CONSTFL
			THEN ALOCONST(.RECNO)

			%(***IF RECORD NUMBER IS AN EXPRESSION
				PERFORM COMPLEXITY WALK ON IT***)%
			ELSE
			BEGIN
				TREEPTR_.RECNO;
				SETCOMPLEXITY();
			END;
		END
	END;

	%(***DEFINE MACRO FOR HANDLING REPT FIELDS OF IO STMNTS***)%
	MACRO CMPREPT=
	BEGIN
		IF .CSTMNT[IOREPT] EQL 0
		THEN
		CSTMNT[SRCCMPLX]_0
		ELSE
		BEGIN
			TREEPTR_.CSTMNT[IOREPT];
			CSTMNT[SRCCMPLX]_SETCOMPLEXITY();
		END
	END$;


	%(***IF ARE NOT GLOBALLY OPTIMIZING, THEN IF ARE IN A DO LOOP IN WHICH THE
		LOOP INDEX LIVES IN A REGISTER, SUBSTITUTE "REGCONTENTS" NODES FOR
		ALL REFERENCES TO THE LOOP INDEX THAT OCCUR IN THIS STMNT***)%
	IF NOT .FLGREG<OPTIMIZER> THEN LPIXSUB();

	%(***SRCID OF STMNT DETERMINES ACTION TO BE TAKEN***)%
	CASE .CSTMNT[SRCID] OF SET

	STCMASMNT();					!FOR ASSIGNMENT
	SCMASSI();					! ASSIGN
	CSTMNT[SRCCMPLX]_(IF .CSTMNT[CALLIST] EQL 0	! CALL
			THEN 0
			ELSE CMPFNARGS(.CSTMNT[CALLIST],FALSE));
	CSTMNT[SRCCMPLX]_0;				! CONTINUE
	STCMDO();					! DO
	STCMSUB();					! ENTRY
	STCMASMNT();					! COMMON SUB (SAME AS ASMNT

	CSTMNT[SRCCMPLX]_0;				! GOTO
	STCMAGO();					! ASSIGNED GOTO
	STCMCGO();					! COMPUTED GOTO
	STCMAIF();					! ARITHMETIC IF
	STCMLIF();					! LOGICAL IF
	STCMRETURN();					! RETURN
	STCMSTOP();					! STOP

	BEGIN						! READ
		CMPLIOLST();
		CMPRECNO();
	END;
	BEGIN						! WRITE
		CMPLIOLST();
		CMPRECNO();
	END;
	CMPDECENC();					! DECODE
	CMPDECENC();					! ENCODE
	CMPLIOLST();					! REREAD
	BEGIN						! FIND
		CSTMNT[SRCCMPLX]_0;
		CMPRECNO();
	END;
	STCMOPEN();					! CLOSE
	CSTMNT[SRCCMPLX]_0;				! INPUT (NOT IN RELEASE 1)
	CSTMNT[SRCCMPLX]_0;				!  OUTPUT (NOT IN RELEASE 1)

	CMPREPT;					! BACKSPACE
	CMPREPT;					! BACKFILE
	CSTMNT[SRCCMPLX]_0;				! REWIND
	CMPREPT;					! SKIPFILE
	CMPREPT;					! SKIP RECORD
	CSTMNT[SRCCMPLX]_0;				! UNLOAD
	CSTMNT[SRCCMPLX]_0;				! RELEASE
	CMPREPT;					! ENDFILE

	CSTMNT[SRCCMPLX]_0;				! END
	STCMSTOP();					! PAUSE
	STCMOPEN();					! OPEN
	STCMSFN();					! SFN
	CSTMNT[SRCCMPLX]_0;				!  FORMAT
	CSTMNT[SRCCMPLX]_0;				! BLT (NOT IN RELEASE 1)
	CSTMNT[SRCCMPLX]_0;				! OVERLAY ID
	TES;
END;

GLOBAL ROUTINE ALCSTMN=
%(***************************************************************************
	ROUTINE TO PERFORM LOCAL REGISTER ALLOCATION FOR A STATEMENT.
	CALLED WITH THE GLOBAL CSTMNT POINTING TO THE STATEMENT.
	CALLED WITH THE GLOBALS
		STBSYR - HAS BIT SET FOR EACH REG AVAILABLE FOR USE IN EVALUATING
			THIS STATEMENT
		STRGCT - CT OF REGS AVAILABLE
***************************************************************************)%
BEGIN
	%(***DEFINE MACRO TO PERFORM REG ALLOC FOR REPT FIELD FOR AN IO STMNT***)%
	MACRO ALCREPT=
	BEGIN
		IF .CSTMNT[IOREPT] NEQ 0
		THEN
		BEGIN
			TREEPTR_.CSTMNT[IOREPT];
			ALCINTMP(NXTTMP(.TREEPTR[DBLFLG]),.STBSYR,.STRGCT);
		END
	END$;


	%(***DEFINE MACRO TO PERFORM REGISTER ALLOC FOR THE COMPUTATION OF A RECORD NO.***)%
	MACRO ALCRECNO=
	BEGIN
		IF (TREEPTR_.CSTMNT[IORECORD]) NEQ 0
		THEN ALCINREG(FIRSTONE(.STBSYR),.STBSYR,.STRGCT)
	END$;
	%(***ACTION TO BE TAKEN IS DETERMINED BY THE SRCID***)%
	CASE .CSTMNT[SRCID] OF SET

	ALCASMNT();		!ASSIGNMENT
	ALCASSI();		!ASSIGN
	ALCCALL();		!CALL
	BEGIN END;		!CONTINUE
	ALCDOSTMT();		!DO
	BEGIN END;		!ENTRY
	ALCASMNT();		!COMMON SUB - SAME AS ASSIGNMENT

	BEGIN END;		! GOTO
	ALCAGO();		! ASSIGNED GOTO
	ALCCGO();		! COMPUTED GOTO
	ALCAIF();		! ARITH IF
	ALCLIF();		! LOGICAL IF
	ALCRETURN();		! RETURN
	BEGIN END;		! STOP

	BEGIN			! READ
		ALCRECNO;
		ALCIOLST();		
	END;
	BEGIN			! WRITE
		ALCRECNO;
		ALCIOLST();		
	END;
	ALCDECENC();		! DECODE
	ALCDECENC();		! ENCODE
	ALCIOLST();		! REREAD
	ALCRECNO;		! FIND
	BEGIN END;		!CLOSE
	BEGIN END;		! INPUT (NOT IN RELEASE 1)
	BEGIN END;		! OUTPUT (NOT IN RELEASE 1)

	ALCREPT;		!BACKSPACE
	ALCREPT;		!BACKFILE
	BEGIN END;		!REWIND
	ALCREPT;		!SKIPFILE
	ALCREPT;		!SKIPRECORD
	BEGIN END;		!UNLOAD
	BEGIN END;		!RELEASE
	ALCREPT;		!ENDFILE;

	BEGIN END;		!END
	BEGIN END;		!PAUSE
	BEGIN END;		!OPEN
	ALCSFN();		!SFN
	BEGIN END;		!FORMAT
	BEGIN END;		!BLT (NOT IN RELEASE 1)
	BEGIN END;		!OVERLAY ID
	TES;


	%(***IF THIS STMNT HAD REGISTER ALLOCATION PERFORMED FOR IT IN "DOUBLE-WD MODE"
		(IE FOR ASSIGNMENT STMNT, THE RHS AND LHS WERE DOUBLE-WD,
		FOR DO LOOP THE INDEX WAS DOUBLE-WD, ETC), THEN MUST SET
		THE BITS IN CLOBBREGS TO INDICATE THAT HAVE CLOBBERED THE
		ODD REG FOLLOWING EACH EVAN REG CLOBBERED***)%
	IF .DBLMODE
	THEN
	BEGIN
		SETDPCLOBB;
		DBLMODE_FALSE
	END;



	%(***IF THIS STMNT HAS A LABEL, PERFORM REG ALLOC FOR ANY DO-LOOP TERMINATION
		IMPLIED BY THAT LABEL****)%
	IF .CSTMNT[SRCLBL] NEQ 0
	THEN ALCDOEND(.CSTMNT[SRCLBL]);

END;

GLOBAL ROUTINE  STCMASMNT=
%(***************************************************************************
	ROUTINE TO PERFORM THE COMPLEXITY PASS FOR AN ASSIGNMENT
	STATEMENT.
	DETERMINES THE NUMBER OF REGS  NECESSARY FOR COMPUTATION OF THE
	LEFT AND RIGHT SIDES AND FOR ALL COMMON SUBEXPRESSIONS.
	DETERMINES WHICH SIDE SHOULD BE COMPUTED  FIRST.
	CALLED WITH THE GLOBAL CSTMNT POINTING TO THE STATEMENT NODE.
	THIS ROUTINE IS NOT CALLED RECURSIVELY.
***************************************************************************)%
BEGIN
	OWN CMPLX1:CMPLX2;
	OWN PEXPRNODE CCMNSUB;
	OWN PEXPRNODE LHNODE;
	OWN PEXPRNODE RHNODE;


	RHNODE_.CSTMNT[RHEXP];
	LHNODE_.CSTMNT[LHEXP];

	IF .CSTMNT[A1VALFLG]
	THEN
	%(***IF LHS IS A SIMPLE VARIABLE, SET UP PTR TO THE SYMBOL TABLE ENTRY***)%
	BEGIN
		RESNAME_.CSTMNT[LHEXP];
		CMPLX1_0
	END
	ELSE
	%(***IF LHS REQUIRES EVALUATION (IE IS AN ARRAY REFERENCE), DETERMINE NUMBER OF
		REGS NEEDED FOR THAT CALC***)%
	BEGIN
		TREEPTR_.CSTMNT[LHEXP];
		CMPLX1_SETCOMPLEXITY();
		RESNAME_.LHNODE[ARG1PTR];
	END;

	%(***DETERMINE THE NUMBER OF REGS NECESSARY FOR EVALUATION OF RHS***)%
	IF NOT .CSTMNT[A2VALFLG]
	THEN
	BEGIN
		TREEPTR_.CSTMNT[RHEXP];
		CMPLX2_SETCOMPLEXITY();
	END;

	%(***IF RIGHT HAND SIDE IS A VARIABLE OR A CONSTANT, STILL NEED ONE REG TO LOAD THE VAL INTO***)%
	IF .RHNODE[OPRCLS] EQL DATAOPR
	THEN
	BEGIN
		CMPLX2_1;

		%(***IF RHNODE IS A CONSTANT, DETERMINE WHETHER IT IS
			AN IMMED CONSTANT AND IF NOT ALLOCATE CORE FOR IT***)%
		IF .RHNODE[OPR1] EQL CONSTFL
		THEN
		PRCNSTARG(.CSTMNT,.RHNODE,FALSE);

	END;

	%(***IF THE RHS IS DOUBLE-PREC, NEED TWICE AS MANY REGS AS HAVE COMPUTED***)%
	IF .RHNODE[DBLFLG] THEN CMPLX2_2*.CMPLX2;


	%(***SET FIELD IN THE ASSIGNMENT-STMNT NODE TO INDICATE THE NUMBER OF REGS
		NECESSARY TO EVAL THE STMNT EXCLUSIVE OF COMMON SUBEXPRS***)%
	CSTMNT[SRCCMPLX]_
		(IF .CMPLX1 GTR .CMPLX2
		THEN .CMPLX1
		ELSE
		IF .CMPLX2 GTR .CMPLX1
		THEN .CMPLX2
		ELSE .CMPLX1+1 );


	%(***PERFORM COMPLEXITY ANALYSIS FOR EACH COMMON SUBEXPRESSION UNDER
		THIS NODE*******)%
	STCMCSB();
END;


GLOBAL ROUTINE STCMAGO=
%(***************************************************************************
	ROUTINE TO COMPUTE THE COMPLEXITY OF AN ASSIGNED GOTO
***************************************************************************)%
BEGIN
	%(***COMPUTE COMPLEXITY OF THE ASSIGNED VAL (MAY BE AN ARRAY-REF***)%
	TREEPTR_.CSTMNT[AGOTOLBL];
	IF .TREEPTR[OPRCLS] EQL DATAOPR
	THEN
	CSTMNT[SRCCMPLX]_0
	ELSE
	CSTMNT[SRCCMPLX]_SETCOMPLEXITY();

	%(***FIND COMPLEXITY OF ANY COMMON SUBEXPRS***)%
	STCMCSB();
END;


GLOBAL ROUTINE STCMCGO=
%(***************************************************************************
	ROUTINE TO COMPUTE COMPLEXITY OF A COMPUTED GOTO
***************************************************************************)%
BEGIN
	%(***CALCULATE THE COMPLEXITY OF THE EXPRESSION TO BE COMPUTED***)%
	TREEPTR_.CSTMNT[CGOTOLBL];
	IF .TREEPTR[OPRCLS] EQL DATAOPR
	THEN
	BEGIN
		IF .TREEPTR[OPR1] EQL CONSTFL THEN ALOCONST(.TREEPTR);
		CSTMNT[SRCCMPLX]_0
	END
	ELSE
	CSTMNT[SRCCMPLX]_SETCOMPLEXITY();

	%(***FIND COMPLEXITY OF ANY COMMON SUBEXPRS***)%
	STCMCSB();
END;

GLOBAL ROUTINE STCMSTOP=
%(***************************************************************************
	ROUTINE TO PERFORM THE COMPLEXITY FOR STOP AND PAUSE.
	THE ARG FOR STOP/PAUSE CAN ONLY BE A VARIABLE OR A CONSTANT OR
	LITERAL (CANNOT BE AN EXPRESSION).
	MUST ALLOCATE THE CONSTANT OR LITERAL IF THERE IS ONE.
***************************************************************************)%
BEGIN
	OWN PEXPRNODE STOPEXPR;

	IF (STOPEXPR_.CSTMNT[STOPIDENT]) NEQ 0
	THEN
	BEGIN
		IF .STOPEXPR[OPR1] EQL CONSTFL
		THEN ALOCONST(.STOPEXPR);
	END;

	CSTMNT[SRCCMPLX]_0;
END;
GLOBAL ROUTINE STCMLIF=
%(***************************************************************************
	ROUTINE TO PERFORM THE COMPLEXITY PASS FOR A LOGICAL IF.
	DETERMINES THE NUMBER OF REGS NECESSARY FOR COMPUTATION OF
	THE LOGICAL EXPRESSION AND FOR THE SUBSTATEMENT AND FOR ANY COMMON SUBEXPRS.
	SETS THE COMPLEXITY OF THE STATEMENT TO THE MAXIMUM OF THESE.
	CALLED WITH THE GLOBAL CSTMNT POINTING TO THE STATEMENT TO BE PROCESSED.
	THIS ROUTINE IS NEVER CALLED RECURSIVELY (SINCE IT IS ILLEGAL TO EMBED
	A LOGICAL IF INSIDE ANOTHER)
***************************************************************************)%
BEGIN
	EXTERNAL CMPLREL,CMPLBL;
	OWN PEXPRNODE CONDEXPR;
	OWN BASE SAVSTMNT;			!SAVE PTR TO THIS STMNT

	%(***PERFORM COMPLEXITY ANALYSIS ON THE CONDITIONAL EXPR***)%
	CONDEXPR_.CSTMNT[LIFEXPR];
	TREEPTR_.CONDEXPR;

	%(****FOR RELATIONALS AND CONTROL-TYPE BOOLEANS, NEED NEVER COMPUTE A VALUE***)%
	IF .CONDEXPR[VALTYPE] EQL CONTROL
	THEN
	BEGIN
		IF .CONDEXPR[OPRCLS] EQL BOOLEAN
		THEN
		CSTMNT[SRCCMPLX]_CMPLBL()
		ELSE
		IF .CONDEXPR[OPRCLS] EQL RELATIONAL
		THEN
		CSTMNT[SRCCMPLX]_CMPLREL()
		ELSE
		CGERR()
	END

	%(***FOR EXPRESSIONS WHICH DO NOT HAVE VALTYPE CONTROL, WILL COMPUTE A VAL AND TEST IT***)%
	ELSE
	BEGIN
		%(***IF CONDEXPR IS A CONSTANT, THIS STMNT WILL HAVE BEEN FOLDED AWAY IN
			P2SKEL IF P2SKEL IS USED; IF P2SKEL IS NOT USED, A CONSTANT
			CONDEXPR IS ALLOCATED TO CORE****)%
		IF .CONDEXPR[OPR1] EQL CONSTFL THEN ALOCONST(.TREEPTR);
		CSTMNT[SRCCMPLX]_SETCOMPLEXITY();
	END;


	%(***COMPUTE THE COMPLEXITY OF THE SUBSTATEMNT***)%
	SAVSTMNT_.CSTMNT;			!SAVE PTR TO THIS STMNT

	CSTMNT_.CSTMNT[LIFSTATE];

	CMSTMN();

	%(**THE IF STATEMENT REQUIRES AT LEAST AS MANY REGS AS ARE NECESSARY FOR
		COMPUTATION OF THE SUBSTATEMENT***)%
	IF .SAVSTMNT[SRCCMPLX] LSS .CSTMNT[SRCCMPLX]
	THEN
	SAVSTMNT[SRCCMPLX]_.CSTMNT[SRCCMPLX];

	CSTMNT_.SAVSTMNT;			!RESTORE VAL OF CSTMNT

	%(***PERFORM COMPLEXITY ANALYSIS FOR COMMON SUBEXPRS***)%
	STCMCSB();

END;



GLOBAL ROUTINE STCMAIF=
%(***************************************************************************
	ROUTINE TO PERFORM THE COMPLEXITY PASS FOR AN ARITHMETIC IF.
	DETERMINES THE NUMBER OF REGS NECESSARY FOR COMPUTATION OF THE
	ARITHMETIC EXPRESSION AND FOR ANY COMMON SUBEXPRESSIONS.
	SETS THE COMPLEXITY OF THE STATEMENT TO THE MAX OF THESE.
	CALLED WITH THE GLOBAL CSTMNT POINTING TO THE STATEMENT FOR
	WHICH ANALYSIS IS TO BE PERFORMED.
***************************************************************************)%
BEGIN
	%(***PERFORM COMPLEXITY ANALYSIS OF THE ARITH EXPR***)%
	TREEPTR_.CSTMNT[AIFEXPR];

	%(***IF THE ARITH EXPR IS A VARIABLE, WILL STILL USE A REG TO HOLD THE VAL***)%
	IF .TREEPTR[OPRCLS] EQL DATAOPR
	THEN
	BEGIN
		%(***IF CONDEXPR IS A CONSTANT, THIS STMNT WILL HAVE BEEN FOLDED AWAY IN 
			P2SKEL IF IT WAS USED; IF P2SKEL NOT USED, A CONSTANT CONDEXPR
			IS ALLOCATED TO CORE****)%
		IF .TREEPTR[OPR1] EQL CONSTFL THEN ALOCONST(.TREEPTR);
		CSTMNT[SRCCMPLX]_1
	END
	ELSE
	CSTMNT[SRCCMPLX]_SETCOMPLEXITY();

	%(***PERFORM COMPLEXITY ANALYSIS FOR ANY COMMON SUBEXPRSSIONS***)%
	IF .CSTMNT[SRCCOMNSUB] NEQ 0
	THEN STCMCSB();
END;


GLOBAL ROUTINE SCMASSI=
%(***************************************************************************
	PERFORM COMPLEXITY ANALYSIS FOR AN ASSIGN STMNT.
***************************************************************************)%
BEGIN
	EXTERNAL CMPLXARRAY;
	TREEPTR_.CSTMNT[ASISYM];

	%(***IF VAR ASSIGNED TO IS AN ARRAYREF, PERFORM COMPLEXITY ANALYSIS ON IT***)%
	IF .TREEPTR[OPRCLS] EQL ARRAYREF
	THEN
	BEGIN
		CSTMNT[SRCCMPLX]_CMPLXARRAY();
		IF .CSTMNT[SRCCMPLX] EQL 0 THEN CSTMNT[SRCCMPLX]_1;
	END
	ELSE
	CSTMNT[SRCCMPLX]_1;
END;




GLOBAL ROUTINE STCMOPEN=
%(***************************************************************************
	TO PERFORM COMPLEXITY PASS FOR AN OPEN STATEMENT.
	MUST ALLOCATE ALL CONSTANTS THAT OCCUR UNDER THIS STMNT.
***************************************************************************)%
BEGIN
	OWN PEXPRNODE ARGVAL;	!PTR TO SYMBOL OR CONSTANT TABLE ENTRY
				! FOR THE VALUE TO BE PASSED TO FOROTS
				! FOR A GIVEN ARG
	OWN OPENLIST ARVALLST;	!LIST OF ARGS UNDER THIS OPEN STMNT
	ARVALLST_.CSTMNT[OPLST];

	%(***WALK THRU THE LIST OF ARGS - FOR ANY ARG THAT IS A CONSTANT OR A LITERAL
		ALLOCATE CORE FOR THAT CONSTANT/LITERAL***)%
	INCR I FROM 0 TO (.CSTMNT[OPSIZ]-1)
	DO
	BEGIN
		ARGVAL_.ARVALLST[.I,OPENLPTR];
		IF .ARGVAL[OPR1] EQL CONSTFL THEN ALOCONST(.ARGVAL);
	END;

	CSTMNT[SRCCMPLX]_0;
END;



GLOBAL ROUTINE CMPDECENC=
%(***************************************************************************
	TO PERFORM COMPLEXITY PASS FOR AN ENCODE OR DECODE STMNT.
	THE ENCODE VAR MAY BE AN ARRAY REF THAT NEEDS TO HAVE AN ADDRESS CALC
	PERFORMED.
***************************************************************************)%
BEGIN
	EXTERNAL CMPLXARRAY,TREEPTR;
	OWN CMPL1;
	OWN PEXPRNODE ENCVAR;
	OWN PEXPRNODE ENCCT;

	ENCVAR_.CSTMNT[IOVAR];		!ENCODE/DECODE VARIABLE
	ENCCT_.CSTMNT[IOCNT];		!CHAR CT

	%(***IF CHAR CT IS AN EXPRESSION, PERFORM COMPLEXITY ANALYSIS FOR ITS
		CALCULATION***)%
	IF .ENCCT[OPRCLS] NEQ DATAOPR
	THEN
	BEGIN
		TREEPTR_.ENCCT;
		SETCOMPLEXITY()
	END;


	%(***IF ENCODE/DECODE VARIABLE IS AN ARRAY REF (RATHER  THAN A SYMBOL TABLE
		ENTRY FOR AN ARRAY NAME) - PERFORM COMPLEXITY PASS ON ADDRESS CALCULATION***)%
	IF .ENCVAR[OPRCLS] EQL ARRAYREF
	THEN
	BEGIN
		TREEPTR_.ENCVAR;
		CMPL1_CMPLXARRAY()
	END
	ELSE
	IF .ENCVAR[OPRCLS] EQL DATAOPR
	THEN CMPL1_0
	ELSE CGERR();

	CMPLIOLST();		!PERFORM COMPLEXITY ANALYSIS ON THE IOLIST
				! LEAVE THE STMNT COMPLEXITY FIELD SET TO THE NUMBER
				! OF REGS NECESSARY FOR COMP OF THE IOLIST

	%(***IF THE ADDR CALC FOR THE ENCODE VAR REQUIRES MORE REGS THAN CALC
		OF THE IOLIST DOES, ADJUST THE COMPLEXITY FIELD OF THE STMNT***)%
	IF .CMPL1  GTR .CSTMNT[SRCCMPLX]
	THEN CSTMNT[SRCCMPLX]_.CMPL1;
END;

GLOBAL ROUTINE STCMCSB=
%(***************************************************************************
	ROUTINE TO PERFORM COMPLEXITY ANALYSIS FOR EACH COMMON SUBEXPR UNDER THE NODE
	POINTED TO BY CSTMNT.
	LEAVES THE COMPLEXITY FIELD OF THE STATEMENT SET TO THE MAX OF ITS
	INITIAL VAL AND THE MAX COMPLEXITY OF ANY COMMON SUB
***************************************************************************)%
BEGIN
	OWN CMPLX1;
	OWN PEXPRNODE  CCMNSUB;

	CCMNSUB_.CSTMNT[SRCCOMNSUB];

	UNTIL .CCMNSUB EQL 0
	DO
	BEGIN
		TREEPTR_.CCMNSUB[ARG2PTR];
		CMPLX1_SETCOMPLEXITY();
		IF .CMPLX1 GTR .CSTMNT[SRCCMPLX]
		THEN CSTMNT[SRCCMPLX]_.CMPLX1;

		CCMNSUB[COMPLEXITY]_.CMPLX1;

		CCMNSUB_.CCMNSUB[CLINK];
	END;

END;


GLOBAL ROUTINE ALCASMNT=
%(***************************************************************************
	ROUTINE TO PERFORM REGISTER ALLOCATION FOR AN ASSIGNMENT STATEMENT.
	DETECTS OPERATONS OF THE FORM:
		A=A+B+C+...
		A=A*B*C....
	TO BE OPERATIONS TO MEMORY.

	CALLED WITH THE GLOBAL CSTMNT POINTING TO THE STATEMENT NODE FOR
	WHICH ALLOCATION IS TO BE PERFORMED.

	THIS ROUTINE IS NEVER CALLED RECURSIVELY.
***************************************************************************)%
BEGIN
	OWN PEXPRNODE ARGNODE:LHNODE:RHNODE;
	OWN RA;
	OWN PEXPRNODE SUBNODE;
	OWN RSV;


	%(***TO SET THE REG FOR COMPUTATION OF THE STATEMENT TO THE SAME REG
		INTO WHICH THE RIGHT-HAND SIDE WAS COMPUTED***)%
	MACRO SETREGTORH=
	BEGIN
		CSTMNT[ASMNTREG]_.RHNODE[TARGTAC];
		CSTMNT[A2SAMEFLG]_1;
	END$;


	%(***TO SET THE REG FOR COMPUTATION OF THE STATEMENT TO THE REG INDICATED BY
		THE INDEX IX*****)%
	MACRO SETREG(IX)=
	BEGIN
		CSTMNT[ASMNTREG]_ASNREG(IX);
		CLOBBREGS_SETBIT(.CLOBBREGS,IX);
	END$;

	ROUTINE USEAFREEREG=
	%(*****ROUTINEET A LEGAL REG FOR COMPUTATION OF THE ASSIGNMENT AND
		SET THE REG-TO-BE-USED TO THAT REG*****)%
	BEGIN
		RA_REGTOUSE(.CSTMNT,.RHNODE,.LHNODE,.RA,.STBSYR);
		SETREG(.RA)
	END;


	ROUTINE SETREGFORA2VAL=
	%(***ROUTINE TO SET THE "REG FOR COMP" OF THE STMNT WHEN THE RIGHT HAND SIDE IS
		A VARIABLE OR REGCONTENTS (IE WHEN A2VALFLG IS SET)***)%
	BEGIN
		IF .RHNODE[OPRCLS] EQL REGCONTENTS
		THEN
		%(***IF RHS IS A VAR WHICH LIVES IN A REG, WILL USUALLY WANT TO SET
			REG-FOR-COMP OF STMNT TO THAT REG***)%
		BEGIN
			%(***HAVE THE EXCEPTION THAT IF THE RHS IS AN AOBJN WORD
				FOR A LOOP CONTROL, WANT TO USE ONLY THE RIGHT HALF.
				THIS IS A PROBLEM IFF EITHER A2NEGFLG OR A2NOTFLG IS SET,
				IN WHICH AN EXTRA REG WILL BE NEEDED.
			*******)%
			IF .CSTMNT[A2IMMEDFLG] AND (.CSTMNT[A2NEGFLG] OR .CSTMNT[A2NOTFLG])
			THEN
			USEAFREEREG()
			ELSE
			SETREGTORH
		END
		ELSE
		%(***IF RHS IS A VARIABLE WHICH DOES NOT LIVE IN A REG, SET REG
			FOR COMP OF STMNT TO RA****)%
		USEAFREEREG()
	END;






	RHNODE_.CSTMNT[RHEXP];
	LHNODE_.CSTMNT[LHEXP];


	%(****PERFORM REGISTER ALLOCATION FOR THE COMMON SUBEXPRS UNDER THIS STMNT.****)%
	DBLMODE_FALSE;
	ALCCMNSB();


	%(***IF THIS STATEMENT IS DOUBLE-PREC, ADJUST SET OF BUSY REGS SO
		THAT ONLY EVEN REGS WILL BE ALLOCATED****)%
	IF .RHNODE[DBLFLG]
	THEN
	BEGIN
		STBSYR_DPBSYREGS(.STBSYR);
		STRGCT_ONESCOUNT(.STBSYR);
		DBLMODE_TRUE;
	END
	ELSE DBLMODE_FALSE;








	%(****IF THE LEFT-HAND SIDE OF THE ASSIGNMENT IS A VARIABLE THAT WAS ALLOCATED
		TO LIVE IN A REGISTER, WILL PROCESS THE RIGHT-HAND SIDE IN A SPECIAL
		MANNER*****)%
	IF .LHNODE[OPRCLS] EQL REGCONTENTS
	THEN
	BEGIN
		CSTMNT[MEMCMPFLG]_0;	!IF IN P2SKEL HAD DECIDED TO PERFORM THIS
					! OP TO MEMORY - UNDO THAT DECISION
		IF LHINREGALC() THEN RETURN;
	END;


	%(***IF THE RIGHT-HAND SIDE IS TO BE COMPUTED DIRECTLY TO MEMORY*****)%
	IF .CSTMNT[MEMCMPFLG]
	THEN
	BEGIN
		ALCMEMCMP();
		RETURN;
	END;


	RA_FIRSTONE(.STBSYR);



	%(***IF LEFT HAND SIDE OF STATEMENT IS A SIMPLE VARIABLE, PERFORM REGISTER
		ALLOCATION FOR THE RIGHT HAND SIDE****)%

	IF .CSTMNT[A1VALFLG]
	THEN
	BEGIN
		IF .CSTMNT[A2VALFLG]
		THEN
		%(***IF RIGHT-HAND SIDE IS ALSO A SIMPLE VARIABLE***)%
		SETREGFORA2VAL()
		ELSE
		BEGIN
			TREEPTR_.RHNODE;

			%(***IF THERE ARE NO REFERENCES TO THE LHS WITHIN THE EXPRESSION
				ON THE RHS AND THE RHS IS NOT AN ARRAYREF,
				AND THE NEG AND NOT FLAGS IN THE STATEMENT ARE BOTH 0,
				 ALLOCATE THE RHS TO BE COMPUTED TO THE
				VARIABLE ON THE LHS*******)%
			IF NOT .RHNODE[RESRFFLG] AND (NOT .RHNODE[OPRCLS] EQL ARRAYREF)
				AND (.CSTMNT[A2NGNTFLGS] EQL 0)
			THEN
			BEGIN
				ALCINTMP(.LHNODE,.STBSYR,.STRGCT);
				IF .RHNODE[TARGTMEM] EQL .LHNODE
				THEN
				%(***IF COULD COMPUTE RHS DIRECTLY TO LHS***)%
				BEGIN
					CSTMNT[MEMCMPFLG]_1;
					RETURN;
				END;
			END

			ELSE
			%(***OTHERWISE, ALLOCATE THE RHS TO BE COMPUTED TO THE REG RA***)%
			ALCINREG(.RA,.STBSYR,.STRGCT);

			%(***DETERMINE REG FOR COMPUTATION OF THE STMNT***)%
			IF .CSTMNT[ALCRETREGFLG]
			THEN
			%(***IF REG FOR COMPUTATION OF STMNT HAS ALREADY BEEN DETERMINED TO
				BE THE FN-RETURN REG****)%
			BEGIN  END
			ELSE
			IF .RHNODE[INREGFLG]
			THEN
			%(***IF RHS IS COMPUTED INTO A REG, USE THAT REG AS REG FOR COMP FOR STMNT***)%
			SETREGTORH
			ELSE
			%(***OTHERWISE USE SOME FREE REG***)%
			USEAFREEREG()
		END;

		RETURN

	END;




	%(***IF LEFT-HAND SIDE IS NOT A SIMPLE VARIABLE, IT MUST BE AN ARRAY****)%
	IF .LHNODE[OPRCLS] NEQ ARRAYREF
	THEN CGERR();


	%(****IF RIGHT HAND SIDE IS A SIMPLE VARIABLE, PERFORM REGISTER ALLOCATION FOR
		LEFT HAND SIDE*******)%

	IF .CSTMNT[A2VALFLG]
	THEN
	BEGIN
		TREEPTR_.LHNODE;
		ALCARRAY(.RA,.STBSYR,.STRGCT);

		%(***GET REG FOR COMP FOR STMNT- DO NOT USE THE REG IN WHICH THE
			INDEX INTO THE ARRAY WAS LEFT***)%
		IF .LHNODE[TARGXF] NEQ 0
		THEN STBSYR_CLRBIT(.STBSYR,INVASNREG(.LHNODE[TARGXF]) );

		RA_FIRSTONE(.STBSYR);

		%(***DECIDE WHICH REG TO COMPUTE THE STMNT IN (GIVEN THAT A2VALFLG WAS SET)***)%
		SETREGFORA2VAL();

		RETURN;
	END;


	%(***IF COMPUTATION OF THE RHS WILL CLOBBER ALL REGISTERS AVAILABLE, THEN
		SHOULD ALWAYS COMPUTE RHS BEFORE COMPUTING LHS, SO THAT
		DO NOT NEED TO LEAVE PTR TO LHS IN A TEMPORARY***)%
	IF .RHNODE[COMPLEXITY] GEQ .STRGCT
	THEN CSTMNT[RVRSFLG]_1;




	%(***IF RIGHT HAND SIDE IS COMPUTED BEFORE ADDRESS CALC FOR LEFT HAND SIDE****)%

	IF .CSTMNT[RVRSFLG]
	THEN
	BEGIN
		IF .LHNODE[COMPLEXITY] LSS .STRGCT
		THEN
		%(***IF ADDRESS CALCULATION CAN BE PERFORMED WITHOUT CLOBBERING
			THE REG IN WHICH RIGHT-HAND-SIDE VAL IS LEFT***)%
		BEGIN
			TREEPTR_.RHNODE;
			ALCINREG(.RA,.STBSYR,.STRGCT);

			%(***DETERMINE WHICH (IF ANY) REG MUST BE SAVED WHILE COMPUTING
				THE LHS BECAUSE IT HOLDS EITHER THE VAL OR A PTR TO THE
				VAL OF THE RIGHT-HAND-SIDE***)%
			RSV_RGTOSAVE(.RHNODE);
			IF .RSV NEQ -1
			THEN
			BEGIN
				%(***IF SOME REG MUST BE SAVED, ADJUST SET OF BUSY REGS***)%
				STBSYR_CLRBIT(.STBSYR,.RSV);
				STRGCT_.STRGCT-1;
			END;

			TREEPTR_.LHNODE;
			ALCARRAY(FIRSTONE(.STBSYR),.STBSYR,.STRGCT);
			IF .RHNODE[INREGFLG]
			THEN
			SETREGTORH
			ELSE
			USEAFREEREG()
		END
		ELSE
		BEGIN
			TREEPTR_.RHNODE;
			ALCINTMP(NXTTMP(.TREEPTR[DBLFLG]),.STBSYR,.STRGCT);
			TREEPTR_.LHNODE;
			ALCARRAY(FIRSTONE(CLRBIT(.STBSYR,.RA)),.STBSYR,.STRGCT);
			USEAFREEREG()
		END;

	END

	ELSE

	%(****IF ADDRESS CALC FOR LEFT-HAND SIDE IS PERFORMED BEFORE RIGHT-HAND SIDE IS COMPUTED***)%

	BEGIN
		%(***CAN ASSUME THAT THE COMPUTATION OF RHS WILL NOT CLOBBER
			THE PTR TO LHS****)%

		%(***PERFORM REG ALLOC FOR COMPUTATION OF THE ADDRESS OF THE LHS***)%
		TREEPTR_.LHNODE;
		ALCARRAY(.RA,.STBSYR,.STRGCT);

		%(***IF PTR TO LEFT-HAND-SIDE IS LEFT IN A REG, DO NOT USE THAT REG IN
			COMPUTATION OF RIGHT-HAND-SIDE***)%
		IF .LHNODE[TARGXF] NEQ 0
		THEN
		BEGIN
			STBSYR_CLRBIT(.STBSYR,INVASNREG(.LHNODE[TARGXF]));
			STRGCT_.STRGCT-1;
		END;

		%(***PERFORM REGISTER ALLOC FOR THE COMPUTATION OF THE RHS***)%
		RA_FIRSTONE(.STBSYR);
		TREEPTR_.RHNODE;

		ALCINREG(.RA,.STBSYR,.STRGCT);

		IF .RHNODE[INREGFLG]
		THEN
		SETREGTORH
		ELSE
		USEAFREEREG()
	END;
END;

	




GLOBAL ROUTINE ALCMEMCMP=
%(***************************************************************************
	ROUTINE TO PERFORM REGISTER ALLOCATION FOR AN ASSIGNMENT STMNT TO BE
	PERFORMED DIRECTLY TO MEMORY. IT IS ASSUMED THAT EITHER ARG1 OR  ARG2 UNDER
	THE RIGHT HAND SIDE IS EQUAL TO THE LEFT HAND SIDE.
	CALLED WITH THE GLOBAL CSTMNT POINTING TO THE ASSIGNMENT STMNT.
***************************************************************************)%
BEGIN
	OWN PEXPRNODE RHNODE:LHNODE:ARG1NODE:ARG2NODE;
	OWN RA;
	EXTERNAL EXCHARGS;

	ROUTINE ARREQLLH(NODE)=
	%(***TO DETERMINE IF 'NODE' IS AN ARRAYREF THAT IS IDENTICAL TO AN ARRAYREF
		ON THE LEFT-HAND-SIDE OF THIS ASSIGNMENT STMNT***)%
	BEGIN
		MAP PEXPRNODE NODE;
		IF .NODE[ARGWD] EQL .LHNODE[ARGWD]	!IF ARRAY NAME AND VARIABLE PART
							! OF SS EXPR ARE IDENTICAL
		THEN
		RETURN (.NODE[TARGET] EQL .LHNODE[TARGET] AND .NODE[OPRCLS] EQL ARRAYREF)
		ELSE RETURN FALSE
	END;


	RA_FIRSTONE(.STBSYR);
	RHNODE_.CSTMNT[RHEXP];
	LHNODE_.CSTMNT[LHEXP];
	ARG1NODE_.RHNODE[ARG1PTR];
	ARG2NODE_.RHNODE[ARG2PTR];

	%(***FOR P2PL1MUL,SQUARE, AND CUBE - THE ARG THAT IS EQL TO THE LEFT HAND
		SIDE IS ARG1 (AND THIS IS THE ONLY ARG). HENCE DONT HAVE TO
		WORRY ABOUT REORDERING THE ARGS NOR ABOUT ALLOCATING THE OTHER ARG***)%
	IF .RHNODE[OPRCLS] EQL SPECOP
	THEN
	BEGIN
		RA_RGTOU1(.RHNODE,.RHNODE[ARG1PTR],.RA,.STBSYR);
		SETTAC(.RHNODE,.RA)
	END

	%(***FOR ARITHMETIC AND BOOLEAN OPERATORS***********)%

	ELSE
	BEGIN
		%(***MUST BE SURE THAT THE ARG UNDER RHNODE WHICH IS EQUAL TO THE LEFT-HAND SIDE
			IS THE 2ND ARG (ARGS MAY HAVE BEEN REVERSED SOMETIME SINCE P2SKEL)***)%
		IF .CSTMNT[A1VALFLG]
		THEN
		BEGIN
			IF .ARG2NODE NEQ .LHNODE
			THEN
			BEGIN
				IF .ARG1NODE NEQ .LHNODE THEN CGERR();

				IF NOT EXCHARGS(.RHNODE) THEN CGERR();

				ARG1NODE_.RHNODE[ARG1PTR];
				ARG2NODE_.RHNODE[ARG2PTR];
			END
		END

		ELSE
		%(***FOR THE LEFT HAND SIDE AN ARRAYREF***)%
		IF .LHNODE[OPRCLS] EQL ARRAYREF
		THEN
		BEGIN
			IF NOT ARREQLLH(.ARG2NODE)
			THEN
			%(***IF ARG2 IS NOT EQUAL TO LHS***)%
			BEGIN
				%(***IF NEITHER ARG UNDER RHNODE WAS EQL TO LHNODE, SHOULD
					NOT HAVE CALLED THIS ROUTINE***)%
				IF NOT ARREQLLH(.ARG1NODE) THEN CGERR();

				%(***IF ARG1 AND ARG2 CANNOT BE SWAPPED, THEN COULD NEVER
					HAVE HAD THEM REVERSED EARLIER(IN P2SKEL WHEN DETECTED
					THIS COMP TO MEMORY) - HENCE HAVE A COMPILER BUG***)%
				IF NOT EXCHARGS(.RHNODE) THEN CGERR();

				%(***HAVE NOW SWITCHED THE ARGS (EXCHARGS DOES THIS)***)%
				ARG1NODE_.RHNODE[ARG1PTR];
				ARG2NODE_.RHNODE[ARG2PTR];
			END
		END;

		%(****PERFORM REGISTER ALLOCATION FOR ARG1 UNDER THE RIGHT HAND SIDE****)%
		IF .RHNODE[A1VALFLG]
		THEN
		BEGIN
			%(***IF ARG1 IS A REGCONTENTS NODE THEN
				1. IF ONLY WANT TO USE THE RIGHT HALF OF TH REG
					THEN MUST MOVE IT INTO RA
				2. IF THE OPERATION CLOBBERS THE REG USED
					THEN MUST MOVE IT TO RA
				3. OTHERWISE, USE THAT REGISTER AS REGFORCOMP
					FOR RHNODE
			********)%
			IF .ARG1NODE[OPRCLS] EQL REGCONTENTS AND NOT .RHNODE[A1IMMEDFLG]
				AND NOT .RHNODE[A1NEGFLG] AND NOT .RHNODE[A1NOTFLG]
				!(DOUBLE-PREC AND COMPLEX OPS TO MEMORY  CLOBBER THE REG)
				AND NOT .RHNODE[DBLFLG]
			THEN
			BEGIN
				RHNODE[TARGTAC]_.ARG1NODE[TARGTAC];
				RHNODE[A1SAMEFLG]_1;
			END

			%(***IF ARG1 IS A SCALAR, USE RA***)%
			ELSE
			SETTAC(.RHNODE,.RA)
		END
		ELSE
		BEGIN
			TREEPTR_.RHNODE[ARG1PTR];
			ALCINREG(.RA,.STBSYR,.STRGCT);
			IF .RHNODE[ALCRETREGFLG]
			THEN
			%(***IF WE DECIDED ON THE COMPLEXITY-PASS TO USE THE FN-RETURN REGISTER
				FOR COMPUTATION OF RHNODE*****)%
			BEGIN END
			ELSE
			IF .ARG1NODE[INREGFLG] AND NOT .ARG1NODE[ALCRETREGFLG]
			THEN
			%(***IF THE LEFT-ARGUMENT OF RHNODE HAD ITS VAL LEFT IN A REG****)%
			BEGIN
				RHNODE[TARGTAC]_.ARG1NODE[TARGTAC];
				RHNODE[A1SAMEFLG]_1;
			END
			ELSE
			%(***OTHERWISE USE RA TO COMPUTE RHNODE****)%
			BEGIN
				RA_REGTOUSE(.RHNODE,.RHNODE[ARG1PTR],.RHNODE[ARG2PTR],.RA,.STBSYR);
				SETTAC(.RHNODE,.RA)
			END
		END;
	END;


	%(***IF THE ELEMENT ON THE LHS (WHICH IS ALSO ARG2 UNDER THE RHS) IS
		AN ARRAY REF, PERFORM ALLOC FOR THOSE 2 NODES***)%
	IF NOT .CSTMNT[A1VALFLG]
	THEN
	BEGIN
		OWN BSYRG1:RB;
		BSYRG1_CLRBIT(.STBSYR,.RA);
		RB_FIRSTONE(.BSYRG1);
		TREEPTR_.LHNODE;
		ALCINREG(.RB,.BSYRG1,.STRGCT-1);
		TREEPTR_(IF .RHNODE[OPRCLS] EQL SPECOP THEN .RHNODE[ARG1PTR] ELSE .RHNODE[ARG2PTR]);
		ALCINREG(.RB,.BSYRG1,.STRGCT-1);
		%(***THE FIRST COMPUTATION TO PERFORM SHOULD ALWAYS BE
			THAT OF ARG1 UNDER THE RIGHT-HAND SIDE***)%
		CSTMNT[RVRSFLG]_1;
		RHNODE[RVRSFLG]_0;
	END;

	RHNODE[A2SAMEFLG]_1;		!WILL COMPUTE INTO THE LOC CONTAING ARG2
	RHNODE[MEMCMPFLG]_1;
END;

GLOBAL ROUTINE ALCASSI=
%(***************************************************************************
	ROUTINE TO PERFORM REGISTER ALLOCATION FOR AN ASSIGN STATEMENT.
	IF VAR ASSIGNED TO IS AN ARRAYREF, MUST PERFORM ALLOC FOR IT.
	THE "ASSIGN" OPERATION IS ALWAYS PERFORMED IN REGISTER 1.
***************************************************************************)%
BEGIN
	TREEPTR_.CSTMNT[ASISYM];

	IF .TREEPTR[OPRCLS] EQL ARRAYREF
	THEN
	ALCARRAY(FIRSTONE(.STBSYR),.STBSYR,.STRGCT);
END;

GLOBAL ROUTINE ALCCALL=
%(***************************************************************************
	ROUTINE TO PERFORM REGISTER ALLOCATION FOR A CALL STMNT.
***************************************************************************)%
BEGIN
	EXTERNAL ALCFNARGS;
	IF .CSTMNT[CALLIST] NEQ 0
	THEN
	BEGIN
		TREEPTR_.CSTMNT[CALLIST];
		ALCFNARGS(.STBSYR,.STRGCT,FALSE);
	END;
END;

GLOBAL ROUTINE ALCAGO=
%(***************************************************************************
	ROUTINE TO PERFORM REGISTER ALLOCATION FOR AN ASSIGNED GOTO
	(NOTE THAT THE ASSIGNED VAL MAY BE AN ARRAYREF THAT REQUIRES CALCULATION)
	THE ACTUAL TESTING OF THE VAL WILL ALWAYS BE PERFORMED IN REG 1.
	CALLED WITH THE GLOBALS
		CSTMNT - PTR TO THE STMNT
		STBSYR - HAS A BIT SET FOR EACH REG AVAILABLE FOR USE IN COMPUTING
			THIS STMNT
		STRGCT - CT OF REGS AVAILABLE FOR USE IN COMPUTING THIS STMNT
***************************************************************************)%
BEGIN
	%(***PERFORM REGISTER ALLOCATION FOR ANY COMMON SUBEXPRS UNDER THIS STATEMENT***)%
	ALCCMNSB();

	%(***PERFORM REG ALLOC FOR ACCESSING THE ASSIGNED VAR***)%
	TREEPTR_.CSTMNT[AGOTOLBL];
	IF .TREEPTR[OPRCLS] NEQ DATAOPR
	THEN
	ALCINREG(FIRSTONE(.STBSYR),.STBSYR,.STRGCT);

END;


GLOBAL ROUTINE ALCCGO=
%(***************************************************************************
	ROUTINE TO PERFORM REGISTER ALLOCATION FOR A COMPUTED GOTO.
	PERFORMS REGISTER-ALLOCATION FOR THE COMPUTATION OF THE COMPUTED
	EXPRESSION. THAT VAL WILL ALWAYS BE MOVED TO REG #1 (AS PART OF A SKIP
	OPERATION THAT TESTS ITS RANGE) FOR EXCUTION OF THE GOTO
	CALLED WITH THE GLOBALS
		CSTMNT - PTR TO THE STMNT
		STBSYR - HAS A BIT SET FOR EACH REG AVAILABLE FOR USE IN COMPUTING
			THIS STMNT
		STRGCT - CT OF REGS AVAILABLE FOR USE IN COMPUTING THIS STMNT
***************************************************************************)%
BEGIN
	%(***PERFORM REGISTER ALLOCATION FOR ANY COMMON SUBEXPRS UNDER THIS STATEMENT***)%
	ALCCMNSB();

	%(***PERFORM REGISTER ALLOCATION FOR COMPUTATION OF THE COMPUTED EXPR***)%
	TREEPTR_.CSTMNT[CGOTOLBL];
	IF .TREEPTR[OPRCLS] NEQ DATAOPR
	THEN
	ALCINREG(FIRSTONE(.STBSYR),.STBSYR,.STRGCT);

END;



GLOBAL ROUTINE ALCLIF=
%(***************************************************************************
	ROUTINE TO PERFORM REGISTER ALLOCATION FOR A LOGICAL IF STATEMNT.
	CALLED WITH THE GLOBALS
		CSTMNT - PTR TO THE STMNT
		STBSYR - HAS A BIT SET FOR EACH REG AVAILABLE FOR USE IN COMPUTING
			THIS STMNT
		STRGCT - CT OF REGS AVAILABLE FOR USE IN COMPUTING THIS STMNT
***************************************************************************)%
BEGIN
	OWN PEXPRNODE CONDEXPR;
	OWN BASE SAVSTMNT;
	OWN SAVBSYR,SAVRCT;

	SAVBSYR_.STBSYR;
	SAVRCT_.STRGCT;


	CONDEXPR_.CSTMNT[LIFEXPR];

	%(***IF THIS STATEMENT IS DOUBLE-PREC, ADJUST SET OF BUSY REGS SO
		THAT ONLY EVEN REGS WILL BE ALLOCATED****)%
	IF .CONDEXPR[DBLFLG]
	THEN
	BEGIN
		STBSYR_DPBSYREGS(.STBSYR);
		STRGCT_ONESCOUNT(.STBSYR);
		DBLMODE_TRUE;
	END
	ELSE
	DBLMODE_FALSE;

	%(***PERFORM REGISTER ALLOCATION FOR ANY COMMON SUBEXPRS UNDER THIS STMNT***)%
	ALCCMNSB();

	%(***PERFORM REGISTER ALLOCATION FOR THE CONDITIONAL EXPRESSION***)%

	TREEPTR_.CONDEXPR;

	%(***IF THE EXPRESSION IS OF TYPE CONTROL, NEED NEVER COMPUTE A VALUE FOR IT***)%
	IF .CONDEXPR[VALTYPE] EQL CONTROL
	THEN
	ALCNARG(.STBSYR,.STRGCT)

	%(***OTHERWISE WILL HAVE TO COMPUTE THE VAL AND TEST IT***)%
	ELSE
	BEGIN
		ALCINREG(FIRSTONE(.STBSYR),.STBSYR,.STRGCT);
	END;

	%(***PERFORM REGISTER ALLOCATION FOR THE SUBSTATEMENT****)%
	SAVSTMNT_.CSTMNT;
	STBSYR_.SAVBSYR;
	STRGCT_.SAVRCT;
	CSTMNT_.CSTMNT[LIFSTATE];
	ALCSTMN();
	CSTMNT_.SAVSTMNT;

END;


GLOBAL ROUTINE ALCAIF=
%(***************************************************************************
	ROUTINE TO PERFORM REGISTER ALLOCATION FOR AN ARITHMETIC IF.
	CALLED WITH THE GLOBALS
		CSTMNT - PTR TO THE STATEMENT
		STBSYR - HAS A BIT SET FOR EACH REG AVAILABLE FOR USE
			IN COMPUTING THIS STMNT
		STRGCT - CT OF REGS AVAILABLE
***************************************************************************)%
BEGIN
	OWN RA;
	TREEPTR_.CSTMNT[AIFEXPR];

	%(*****IF THE VALUE IS DOUBLE-WD, ADJUST THE SET OF REGS SO THAT ONLY EVEN
		REGS WILL BE ALLOCATED*****)%
	IF .TREEPTR[DBLFLG]
	THEN
	BEGIN
		STBSYR_DPBSYREGS(.STBSYR);
		STRGCT_ONESCOUNT(.STBSYR);
		DBLMODE_TRUE;
	END
	ELSE
	DBLMODE_FALSE;

	%(***PERFORM REGISTER ALLOCATION FOR ANY COMMON SUBEXPRS UNDER THIS STMNT***)%
	IF .CSTMNT[SRCCOMNSUB] NEQ 0 THEN ALCCMNSB();

	%(***PERFORM REGISTER ALLOCATION FOR THE COMPUTATION OF THE ARITHMETIC EXPRESSION***)%

	RA_FIRSTONE(.STBSYR);

	TREEPTR_.CSTMNT[AIFEXPR];
	ALCINREG(.RA,.STBSYR,.STRGCT);

	%(***DECIDE WHAT REG TO USE WHEN TESTING THE VALUE OF THE EXPR***)%
	TREEPTR_.CSTMNT[AIFEXPR];
	IF .TREEPTR[INREGFLG]
	THEN
	BEGIN
		CSTMNT[AIFREG]_.TREEPTR[TARGTAC];
		CSTMNT[A1SAMEFLG]_1;
	END
	ELSE
	BEGIN
		RA_RGTOU1(.CSTMNT,.TREEPTR,.RA,.STBSYR);
		CSTMNT[AIFREG]_ASNREG(.RA);
		CLOBBREGS_SETBIT(.CLOBBREGS,.RA);
	END;
END;


GLOBAL ROUTINE ALCDECENC=
%(***************************************************************************
	ROUTINE TO PERFORM REGISTER ALLOCATION FOR ENCODE/DECODE STMNTS.
***************************************************************************)%
BEGIN
	OWN RA;
	EXTERNAL ALCARRAY,TREEPTR;
	OWN PEXPRNODE ENCVAR;
	OWN PEXPRNODE ENCCT;		!EXPRESSION FOR CHAR CT

	ENCVAR_.CSTMNT[IOVAR];
	ENCCT_.CSTMNT[IOCNT];


	%(***IF THE CHARACTER CT IS AN EXPRESSION, PERFORM REGISTER ALLOC FOR
		ITS CALCULATION***)%
	IF .ENCCT[OPRCLS] NEQ DATAOPR
	THEN
	BEGIN
		TREEPTR_.ENCCT;
		ALCINREG(FIRSTONE(.STBSYR),.STBSYR,.STRGCT);

		%(***IF SOME REGISTER MUST BE PRESERVED IN ORDER TO PRESERVE THE
			VAL OF THE COUNT, DONT WANT TO USE THAT REG IN CALCULATING
			THE ARRAY ADDRESS***)%
		IF (RA_RGTOSAVE(.ENCCT)) NEQ -1
		THEN (STBSYR_CLRBIT(.STBSYR,.RA); STRGCT_.STRGCT-1);

	END;

	%(***IF THE ENCODE-ARRAY IS ACTUALLY AN "ARRAYREF" NODE (IE INCLUDES AN
		OFFSET WITHIN THE ARRAY), PERFORM REGISTER ALLOCATION FOR THE ADDRESS
		CALCULATION***)%
	IF .ENCVAR[OPRCLS] EQL ARRAYREF
	THEN
	BEGIN
		TREEPTR_.ENCVAR;
		ALCARRAY(FIRSTONE(.STBSYR),.STBSYR,.STRGCT);
	END;

	ALCIOLST();	!PERFORM REG ALLOC FOR THE IOLIST
END;


GLOBAL ROUTINE ALCCMNSB=
%(***************************************************************************
	ROUTINE TO PERFORM REGISTER ALLOCATION FOR ALL COMMON SUBEXPRS UNDER
	THE STATEMENT "CSTMNT".
	DEPENDING ON THE NUMBER OF REGS NECESSARY TO COMPUTE THE STATEMENT
	AND THE NUMBER OF REGS AVAILABLE (WHICH IS INDICATED BY THE GLOBAL "STRGCT",
	LEAVES AS MANY COMMON SUBEXPRS AS POSSIBLE IN REGISTERS.
***************************************************************************)%
BEGIN
	OWN RA;
	OWN PEXPRNODE CCMNSUB:ARGNODE;
	OWN BSYRG1,REGCT1;
	OWN STCMPLX;			!FOR "DBLMODE", NUMBER OF REGISTER PAIRS
					! NEEDED FOR THE STATEMENT EXCEPT FOR
					! COMMON SUBEXPRS; OTHERWISE, THE NUMBER OF
					! REGISTERS NEEDED EXCEPT FOR COMMON SUBEXPRS


	CCMNSUB_.CSTMNT[SRCCOMNSUB];

	STCMPLX_(IF .DBLMODE THEN (.CSTMNT[SRCCMPLX]/2+1) ELSE .CSTMNT[SRCCMPLX]);
	UNTIL .CCMNSUB EQL 0
	DO
	BEGIN
		ARGNODE_.CCMNSUB[ARG2PTR];
		TREEPTR_.ARGNODE;


		%(***IF THIS COMMON SUBEXPR IS DOUBLE-PREC AND THE STATEMENT IS NOT,
			THEN MUST ADJUST THE SET OF AVAILABLE REGS TO INCLUDE ONLY EVEN REGS***)%
		IF .ARGNODE[DBLFLG] AND NOT .DBLMODE
		THEN
		BEGIN
			BSYRG1_DPBSYREGS(.STBSYR);
			REGCT1_ONESCOUNT(.BSYRG1);
		END
		ELSE
		BEGIN
			BSYRG1_.STBSYR;
			REGCT1_.STRGCT;
		END;


		%(***IF THERE ARE ENOUGH REGISTERS FREE SO THAT THIS THIS EXPRESSION
			CAN BE LEFT IN A REG WHILE CALCULATING THE WHOLE STATEMENT,
			LEAVE THIS EXPR IN A REG.
			OTHERWISE LEAVE IT IN A TEMPORARY.
		********)%
		IF .STRGCT GTR (.STCMPLX + 1)
			!FOR COMMON SUBS THAT ARE SINGLE VARS - PUT THEM INTO REGS UNLESS
			! THERE WILL BE FEWER THAN 4 REGS LEFT IF DO SO
			OR (.CCMNSUB[A2VALFLG] AND (.STRGCT-.ARGNODE[DBLFLG]) GTR 4)
		THEN
		BEGIN
			RA_FIRSTONE(.BSYRG1);
			IF NOT .CCMNSUB[A2VALFLG]
			THEN
			ALCINREG(.RA,.BSYRG1,.REGCT1);

			%(***IF THE COMMON SUB WAS COMPUTED INTO A REG WHERE IT CAN
				BE LEFT - LEAVE IT THERE***)%
			IF .ARGNODE[INREGFLG] AND NOT .ARGNODE[ALCRETREGFLG]
				!IF THE COMMON SUB IS THE RIGHT HALF OF AN AOBJN WD
				! AND IS USED IN A CONTEXT THAT REQUIRES A FULL WD,
				! CANNOT USE THE AOBJN REG
				AND NOT (.CCMNSUB[A2IMMEDFLG] AND .CCMNSUB[CSFULLWDFLG])
			THEN
			BEGIN
				CCMNSUB[TARGTAC]_.ARGNODE[TARGTAC];
				CCMNSUB[TARGADDR]_.CCMNSUB[TARGTAC];
				CCMNSUB[A2SAMEFLG]_1;
			END
			ELSE
			BEGIN
				RA_RGTOU1(.CCMNSUB,.ARGNODE,.RA,.STBSYR);
				SETTARGINREG(.CCMNSUB,.RA)
			END;

			CCMNSUB[INREGFLG]_1;

			RA_INVASNREG(.CCMNSUB[TARGTAC]);
			%(***REMOVE THE REG HOLDING THIS COMMON SUB FROM THE REG POOL***)%
			STBSYR_CLRBIT(.STBSYR,.RA);
			STRGCT_.STRGCT-1;
			IF .ARGNODE[DBLFLG]
			THEN
			BEGIN
				OWN RB;
				RB_NXREG(.RA);
				CLOBBREGS_SETBIT(.CLOBBREGS,.RB);
				STBSYR_CLRBIT(.STBSYR,.RB);
				STRGCT_.STRGCT-1;
			END;

			%(***INDICATE THAT THIS REG IS CLOBBERED IN THIS SUBROUTINE***)%
			CLOBBREGS_SETBIT(.CLOBBREGS,.RA);
		END

		ELSE
		%(***IF CANNOT SPARE A REG TO LEAVE THIS COMMON SUBEXPR IN****)%
		BEGIN
			IF .CCMNSUB[A2VALFLG]
			THEN
			BEGIN
				%(***IF THIS ARG IS THE RIGHT HALF OF AN AONJN WD
					AND WE WILL NEED THE WHOLE THING, MUST LOAD AND STORE IT***)%
				IF .CCMNSUB[A2IMMEDFLG] AND .CCMNSUB[CSFULLWDFLG]
				THEN
				BEGIN
					RA_FIRSTONE(.BSYRG1);
					CCMNSUB[TARGTAC]_ASNREG(.RA);
					CLOBBREGS_SETBIT(.CLOBBREGS,.RA);
					CCMNSUB[TARGADDR]_NXTTMP(FALSE);
				END

				ELSE
				%(***IF THE COMMON SUB IS A REGCONTENTS THAT CAN BE USED, USE IT**)%
				IF .ARGNODE[OPRCLS] EQL REGCONTENTS
				THEN
				BEGIN
					CCMNSUB[TARGET]_.ARGNODE[TARGET];
					CCMNSUB[A2SAMEFLG]_1;
				END

				ELSE
				BEGIN
					CCMNSUB[TARGET]_.ARGNODE;
					CCMNSUB[A2SAMEFLG]_1;
				END
			END
			ELSE
			BEGIN
				ALCINTMP(NXTTMP(.TREEPTR[DBLFLG]),.BSYRG1,.REGCT1);
				CCMNSUB[TARGET]_.ARGNODE[TARGET];
				CCMNSUB[A2SAMEFLG]_1;
			END;
		END;

		CCMNSUB_.CCMNSUB[CLINK];

	END;
END;



GLOBAL ROUTINE ALCIOLST=
%(***************************************************************************
	ROUTINE TO PERFORM REGISTER ALLOCATION FOR AN IOLIST.
	CLAAED WITH THE GLOBAL CSTMNT POINTING TO THE STATEMENT FOR
	WHICH AN IOLIST IS TO BE PROCESSED.
	CALLED WITH THE GLOBALS STBSYR AND STRGCT INDICATING WHICH REGS
	ARE AVAILABLE FOR USE.
***************************************************************************)%
BEGIN
	EXTERNAL ALCINREG,ALCINTMP,ALCTARY;

	LOCAL BASE IOLELEM;
	LOCAL SAVSTMNT,SAVBSYR,SAVRGCT;

	%(***GET PTR TO 1ST ELEM ON IOLIST TO BE PROCESSED***)%
	IOLELEM_.CSTMNT[IOLIST];

	%(****SAVE PTR TO CURRENT STATEMENT (IF THERE ARE DO-STMNTS ON THE IOLIST
		WILL CLOBBER CSTMNT,STBSYR,STRGCT)*****)%
	SAVSTMNT_.CSTMNT;
	SAVBSYR_.STBSYR;
	SAVRGCT_.STRGCT;

	%(*****WALK THRU THE ELEMENTS ON THE IOLIST******)%
	UNTIL .IOLELEM EQL 0
	DO
	BEGIN
		IF .IOLELEM[OPRCLS] EQL STATEMENT
		THEN
		BEGIN
			CSTMNT_.IOLELEM;
			ALCSTMN();
		END

		ELSE
		IF .IOLELEM[OPRCLS] EQL IOLSCLS
		THEN
		BEGIN
			CASE .IOLELEM[OPERSP] OF SET

			%(***FOR A DATACALL NODE - PERFORM REG ALLOC FOR THE
				EXPRESSION UNDER THIS NODE*****)%
			BEGIN
				TREEPTR_.IOLELEM[DCALLELEM];
				IF .TREEPTR[OPRCLS] NEQ DATAOPR
				THEN
				ALCINREG(FIRSTONE(.STBSYR),.STBSYR,.STRGCT);
			END;

			%(***FOR AN SLISTCALL NODE - PERFORM REG ALLOC FOR THE OPERATION
				TO CALCULATE THE NUMBER OF ELEMS IN THE ARRAY (IF ARRAY
				HAS VARIABLE BOUNDS)****)%
			BEGIN
				TREEPTR_.IOLELEM[SCALLCT];
				IF .TREEPTR[OPRCLS] NEQ DATAOPR
				THEN
				ALCINREG(FIRSTONE(.STBSYR),.STBSYR,.STRGCT);
			END;

			%(***FOR AN IOLSTCALL NODE***************)%
			ALCIOCALL(.IOLELEM);

			%(****FOR AN E1LIST (NOT IMPLEMENTED IN RELEASE 1)***)%
			BEGIN END;

			%(***FOR AN E2LIST (NOT IMPLEMENTED IN RELEASE 1)***)%
			BEGIN END;

			TES;
		END;

		%(***RESTORE STBSYR,STRGCT FOR THE NEXT ELEM ON IOLIST***)%
		STBSYR_.SAVBSYR;
		STRGCT_.SAVRGCT;

		%(***GO ON TO NEXT ELEMENT****)%
		IOLELEM_.IOLELEM[CLINK];

	END;

	CSTMNT_.SAVSTMNT;
END;



GLOBAL ROUTINE ALCIOCALL(IOLSNODE)=
%(***************************************************************************
	TO PERFORM REGISTER ALLOCATION FOR AN IOLSTCALL NODE.
	THE ARG IOLSNODE PTS TO AN IOLSTCALL NODE.
	FOR IOLIST ELEMENTS THAT REQUIRE COMPUTATION, LEAVE AS MANY
	AS POSSIBLE IN THE REGS IN WHICH THEY WERE COMPUTED (RATHER THAN
	STORING THEM IN TEMPORARIES). ALSO LEAVE AS MANY ARRAY OFFSETS
	AS POSSIBLE IN REGISTERS.
***************************************************************************)%
BEGIN
	EXTERNAL RGTOSAVE;
	EXTERNAL ALCTARY;
	MAP BASE IOLSNODE;
	EXTERNAL TREEPTR;
	MAP PEXPRNODE TREEPTR;
	OWN BASE IOLELEM;
	OWN REGSREQ;
	OWN FREGCT,BSYREGS;	!REGISTERS AVAILABLE FOR USE AT THE CURRENT PT IN
				! THE IOLIST (AS EARLY ELEMS GET LEFT IN REGS,
				! THESE VARIABLES ARE ADJUSTED SO THAT LATER ELEMS
				! WONT CLOBBER THOSE REGS)
	OWN FRGCT1,BSYRG1;	!FOR A DATACALL NODE - THESE ARE ADJUSTED TO ACCOUNT
				! FOR  A DOUBLE PRECISION EXPRESSION
	OWN RA;
	OWN PEXPRNODE ARGNODE;
	OWN SAVSTMNT;


	%(***SAVE VAL OF THE GLOBAL CSTMNT***)%
	SAVSTMNT_.CSTMNT;

	%(***PERFORM REGISTER ALLOCATION FOR ANY COMMON SUBEXPRS ON THIS IOLST***)%
	CSTMNT_.IOLSNODE;
	ALCCMNSB();

	%(***GET NUMBER OF REGS REQUIRED FOR REST OF THIS IOLSTCALL***)%
	REGSREQ_.IOLSNODE[SRCCMPLX];

	BSYREGS_.STBSYR;
	FREGCT_.STRGCT;

	%(***WALK THRU ELEMENTS ON THIS IOLSTCALL***)%
	IOLELEM_.IOLSNODE[IOLSTPTR];
	UNTIL .IOLELEM EQL 0
	DO
	BEGIN
		CASE .IOLELEM[OPERSP] OF SET

		%(***FOR A DATACALL NODE****)%
		BEGIN
			TREEPTR_.IOLELEM[DCALLELEM];
			ARGNODE_.TREEPTR;

			%(***IF THIS ELEMENT IS DOUBLE-PREC - MUST ADJUST SET OF FREE REGS***)%
			IF .ARGNODE[DBLFLG]
			THEN
			(BSYRG1_DPBSYREGS(.BSYREGS); FRGCT1_ONESCOUNT(.BSYRG1) )
			ELSE
			(BSYRG1_.BSYREGS; FRGCT1_.FREGCT);

			%(***IF THERE ARE ENOUGH REGS TO LEAVE ALL FURTHER ARGS IN REGS***)%
			IF .REGSREQ LEQ .FREGCT
			THEN
			BEGIN
				ALCINREG(FIRSTONE(.BSYRG1),.BSYRG1,.FRGCT1);

				%(***IF THIS ARG WAS LEFT IN A REG, MUST TAKE THAT REG
					OUT OF THE SET OF REGS AVAILABLE FOR USE FOR
					LATER ELEMENTS****)%
				RA_RGTOSAVE(.ARGNODE);
				IF .RA NEQ -1
				THEN
				BEGIN
					BSYREGS_CLRBIT(.BSYREGS,.RA);

					%(***IF THIS ARG WAS DOUBLE-PREC MUST ALSO
						REMOVE THE REG AFTER RA FROM THE SET***)%
					IF .ARGNODE[DBLFLG]
					THEN
					BEGIN
						BSYREGS_CLRBIT(.BSYREGS,NXREG(.RA));
						FREGCT_.FREGCT-2;
						REGSREQ_.REGSREQ-2;
					END
					ELSE
					BEGIN
						FREGCT_.FREGCT-1;
						REGSREQ_.REGSREQ-1;
					END;
				END;
			END

			%(***IF THERE ARE NOT ENOUGH REGS, THEN IF THIS ELEM IS COMPUTED,
				LEAVE IT IN A TEMP***)%
			ELSE
			BEGIN
				IF .TREEPTR[OPRCLS] EQL ARRAYREF
				THEN
				%(***FOR AN ARRAYREF - IF THE SS IS ALREADY IN A REG, CAN PASS
					FOROTS ARG IN THE FORM "ADDR(R)"
					OTHERWISE, MUST MATERIALIZE THE ADDRESS REFERENCED***)%
				BEGIN
					IF .TREEPTR[A2VALFLG]
					THEN
					BEGIN
						OWN PEXPRNODE SSNODE;
						SSNODE_.TREEPTR[ARG2PTR];
						IF (.SSNODE[OPRCLS] EQL REGCONTENTS) OR 
							(.SSNODE[OPRCLS] EQL CMNSUB
								AND .SSNODE[INREGFLG])
						THEN
						BEGIN 
							%(***SET THE "INDEX" FIELD TO
								BE USED TO REFERENCE THE ELEMENT
								TO THE REG THAT HOLDS THE SS***)%
							TREEPTR[TARGXF]_.SSNODE[TARGTAC];
							TREEPTR[A2SAMEFLG]_1
						END

						ELSE IOLELEM[DCALLELEM]_ALCTARY(.BSYRG1,.FRGCT1)
					END
					ELSE
					IOLELEM[DCALLELEM]_ALCTARY(.BSYRG1,.FRGCT1)
				END
				ELSE
				ALCINTMP(NXTTMP(.TREEPTR[DBLFLG]),.BSYRG1,.FRGCT1);

				%(***IF AN ARG THAT MIGHT HAVE BEEN LEFT IN A REG WAS
					LEFT IN A TEMP, CAN REDUCE THE NUMBER OF FUTURE REGS
					REQUIRED BY 1***)%
				IF .TREEPTR[OPRCLS] NEQ DATAOPR AND .TREEPTR[OPRCLS] NEQ CMNSUB
				THEN
				BEGIN
					IF .TREEPTR[COMPLEXITY] NEQ 0
					THEN
					BEGIN
						%(***FOR DOUBLE-WD VAL HAVE 2 EXTRA REGS**)%
						IF .TREEPTR[DBLFLG]
						THEN REGSREQ_.REGSREQ-2
						ELSE REGSREQ_.REGSREQ-1;
					END
				END;
			END;
		END;

		%(***FOR AN SLISTCALL NODE (WHICH HAS ONLY ONE ARRAYREF 
			THAT STARTS AT THE ARRAY'S BASE AND HAS A CONSTANT INCR)******)%
		BEGIN
			TREEPTR_.IOLELEM[SCALLCT];
			IF .TREEPTR[OPRCLS] NEQ DATAOPR
			THEN
			%(***DONT BOTHER TO TRY TO LEAVE THIS IN A REG***)%
			ALCINTMP(NXTTMP(.TREEPTR[DBLFLG]),.BSYREGS,.FREGCT);
		END;

		%(***AN IOLSTCALL WITHIN AN IOLSTCALL IS ILLEGAL***)%
		BEGIN
		END;

		%(***FOR AN S1LISTCALL (IE AN SLIST WITH MORE THAN ONE ARRAYREF OR A 
			NON-CONSTANT INCREMENT) - NOT IN RELEASE 1***)%
		BEGIN END;

		%(***FOR AN ELISTCALL - NOT IN RELEASE 1***)%
		BEGIN END;

		TES;

		%(***GO ON TO NEXT ELEMENT***)%
		IOLELEM_.IOLELEM[CLINK];
	END;

	%(***RETSORE CSTMNT***)%
	CSTMNT_.SAVSTMNT;
END;

GLOBAL ROUTINE LHINREGALC=
%(*****
	ROUTINE TO PERFORM REGISTER ALLOCATION FOR AN ASSIGNMENT STATEMENT
	WHEN THE LEFT-HAND-SIDE IS ALLOCATED TO A REGISTER.
	THIS ROUTINE ATTEMPTS TO COMPUTE THE VALUE OF THE RIGHT-HAND-SIDE
	INTO THAT REGISTER.  IT IS ABLE TO DO SO IF EITHER:
		1.  THERE IS NO REFERENCE TO THE LHS VARIABLE IN THE
	    RHS EXPRESSION
		2.  THERE IS A REFERENCE TO THE LHS VARIABLE AT A DEPTH OF
		    1 OR 2 WITHIN THE RHS EXPRESSION.
	RETURNS TRUE IF SUCCEEDED, FALSE IF FAILED (IN WHICH CASE REGISTER
	ALLOCATION FOR THIS EXPRESSION MUST STILL BE PERFORMED)
*****)%
BEGIN
	REGISTER PEXPRNODE RHNODE;
	OWN PEXPRNODE LHNODE;
	OWN RA;
	OWN PEXPRNODE ARG1NODE;
	REGISTER PEXPRNODE ARG2NODE;

	%(***LOCAL ROUTINE TO SET REG FOR COMPUTATION OF RIGHT HAND EXPR EQUAL TO
	     REG TO WHICH LHS VARIABLE WAS ALLOCATED*****)%
	ROUTINE SETRHRGTOLH=
	BEGIN
		RHNODE[TARGTAC]_.LHNODE[TARGTAC];
		CSTMNT[ASMNTREG]_.LHNODE[TARGTAC];
		CSTMNT[A1SAMEFLG]_1;
		CSTMNT[A2SAMEFLG]_1;
	END;

	%(***LOCAL ROUTINE TO SPECIFY THAT THE COMPUTATION OF THE VALUE OF THE NODE
	     "PNODE" BE PERFORMED IN THE REGISTER USED FOR LHS WHEN ARG1
	     UNDER "PNODE" IS EQUAL TO LHS
		CAN BE CALLED FOR PNODE OF OPRCLS:
			ARITHMETIC,BOOLEAN,SPECOP
	****)%
	ROUTINE CMPNODINLH(PNODE)=
	BEGIN
		MAP PEXPRNODE PNODE;
		PNODE[A1SAMEFLG]_1;
		PNODE[TARGTAC]_.LHNODE[TARGTAC];
		%(****PERFORM REG ALLOC FOR ARG2 UNDER PNODE***)%
		IF NOT .PNODE[A2VALFLG] AND .PNODE[OPRCLS] NEQ SPECOP
		THEN
		BEGIN
			TREEPTR_.PNODE[ARG2PTR];
			ALCINREG(FIRSTONE(.STBSYR),.STBSYR,.STRGCT);
		END;
	END;


	ROUTINE CMPRHINLH=
	%(***LOCAL ROUTINE TO ALLOCATE THE COMPUTATION OF RHNODE TO BE
	     PERFORMED IN THE REGISTER ALLOCATED TO LHS, WHEN THE FIRST
	     ARG UNDER THE FIRST ARG OF RHNODE IS KNOWN TO BE EQUAL TO
	     THE VARIABLE ON THE LHS
	****)%
	BEGIN
		%(***IF THE COMPUTATION OF ARG2 UNDER RHS INCLUDES A REFERENCE
			TO THE VARIABLE FROM THE LHS, MUST COMPUTE ARG2 BEFORE
			COMPUTE ARG1 (SINCE THE COMPUTATION OF ARG1 WILL
			CLOBBER THE REG THAT HOLDS THAT VAR)
		***)%
		IF .ARG2NODE[RESRFFLG] AND NOT .RHNODE[RVRSFLG]
		THEN
		BEGIN
			RHNODE[RVRSFLG]_1;

			%(**IF ON COMPLEXITY PASS WE ALLOCATED ARG2 TO BE COMPUTED
				INTO FN-RETURN REG, AND THE COMPUTATION OF ARG1 WILL
				CLOBBER FN-RETURN REG, THEN WE MUST UNDO THAT ALLOCATION***)%
			IF .ARG2NODE[ALCRETREGFLG] AND .ARG1NODE[FNCALLSFLG]
			THEN
			BEGIN
				ARG2NODE[ALCRETREGFLG]_0;
				ARG2NODE[INREGFLG]_0;
				ARG2NODE[A1SAMEFLG]_0;
				ARG2NODE[A2SAMEFLG]_0;
			END
		END;


		%(***PERFORM REGISTER ALLOCATION FOR THE COMPUTATION OF ARG2 UNDER RHNODE
			(WE KNOW THAT THE VAL OF ARG1 WILL BE LEFT IN THE REG IN WHICH LHS
			IS ALLOCATED)
		****)%
		IF NOT .RHNODE[A2VALFLG] AND .RHNODE[OPRCLS] NEQ SPECOP
		THEN
		BEGIN
			TREEPTR_.ARG2NODE;
			ALCINREG(FIRSTONE(.STBSYR),.STBSYR,.STRGCT);

			%(***IF ARG2 IS COMPUTED BEFORE ARG1, THEN MUST NOT USE
				THE REG IN WHICH VAL OF ARG2 WAS LEFT IN COMPUTING ARG1**)%
			IF .RHNODE[RVRSFLG]
			THEN
			BEGIN
				OWN RB;
				IF (RB_RGTOSAVE(.ARG2NODE)) NEQ -1	!IF SOME REG MUST BE PRESERVED
									! TO PRESERVE VAL OF ARG2
				THEN
				BEGIN
					STBSYR_CLRBIT(.STBSYR,.RB);	!TAKE THAT REG OUT OF SET AVAILABL
					%(***IF THAT REG IS THE REG TO WHICH LHS WAS
						ALLOCATED, ARE IN AN IMPOSSIBLE SITUATION.
						THIS SHOULD NEVER OCCUR***)%
					IF .RB EQL INVASNREG(.LHNODE[TARGTAC]) THEN CGERR();
				END;
			END;
		END;

		%(***PERFORM ALLOCATION OF ARG1 UNDER RHNODE, COMPUTING ITS VAL INTO
			THE REG USED FOR LHS***)%
		CMPNODINLH(.ARG1NODE);

		RHNODE[TARGTAC]_.ARG1NODE[TARGTAC];
		RHNODE[A1SAMEFLG]_1;

		SETRHRGTOLH();		!SET FIELDS OF CSTMNT TO INDICATE THAT RHNODE WAS
					! COMPUTED INTO THE REG FOR LHNODE
	END;




	ROUTINE MUSTSAVLHREG(ANODE)=
	%(***************
		TESTS WHETHER THE VALUE OF ANODE WILL BE INACCESSIBLE IF THE
		REGISTER THAT HOLDS THE VARIABLE ON THE LHS HAS BEEN CLOBBERED.
		THIS IS TRUE ONLY IF ANODE IS AN ARRAYREF THAT WILL HAVE THE
		LHS VAR AS ITS SUBSCRIPT OR FOR DUMMY TYPE CONVERSION NODES
		THAT HAVE THE LHS VAR UNDER THEM
	******************)%
	BEGIN
		MAP PEXPRNODE ANODE;
		IF .ANODE EQL .LHNODE THEN RETURN TRUE	!TO REF THE LHS VAR ITSELF,
								! THE VAL MUST BE PRESERVED
		ELSE
		IF .ANODE[OPRCLS] EQL ARRAYREF	!FOR AN ARRAYREF, IF THE INDEX
		THEN RETURN MUSTSAVLHREG(.ANODE[ARG2PTR])	! IS A NODE THAT REQUIRES THE LHS TO
								! BE PRESERVED

		ELSE
		IF .ANODE[OPRCLS] EQL TYPECNV
		THEN
		BEGIN
			%(***IF THE ARG UNDER A DUMMY TYPE-CNV NODE REQUIRES THE REG TO
				BE PRESERVED, THEN THE TYPE-CNVNODE DOES ALSO***)%
			IF NOCNV(ANODE) THEN RETURN MUSTSAVLHREG(.ANODE[ARG2PTR])
			ELSE RETURN FALSE
		END
		ELSE RETURN FALSE
	END;











	LHNODE_.CSTMNT[LHEXP];

	%(***IF RHS IS A SCALAR, SIMPLY SET TARGET TO REG ALLOCATED FOR LHS***)%
	IF .CSTMNT[A2VALFLG]
	THEN
	BEGIN
		CSTMNT[ASMNTREG]_.LHNODE[TARGTAC];
		CSTMNT[A1SAMEFLG]_1;
		IF .CSTMNT[RHEXP] EQL .LHNODE
		THEN
		CSTMNT[A2SAMEFLG]_1;
		RETURN TRUE;
	END;


	RA_INVASNREG(.LHNODE[TARGTAC]);
	RHNODE_.CSTMNT[RHEXP];

	%(***IF THERE IS NO REFERENCE TO THE VARIABLE ON THE LHS IN THE
	     EXPRESSION ON THE RHS, SIMPLY ALLOCATE THE EXPRESSION TO BE
	     COMPUTED INTO THE REG USED FOR THE VARIABLE IF POSSIBLE
	****)%
	IF NOT .RHNODE[RESRFFLG]
	THEN
	BEGIN
		OWN STBSYR1;		!SET OF REGS AVAILABLE FOR USE IN COMPUTING THE
					! THE VAL OF THE RHS

		%(***FOR COMPUTING THE RHS OF THIS STMNT, CAN USE THE REG TO WHICH
			THE LHS WAS ALLOCATED (SINCE THE LHS VARIABLE DOES NOT OCCUR
			IN THE RHS EXPRESSION)***)%
		STBSYR1_SETBIT(.STBSYR,.RA);

		TREEPTR_.RHNODE;
		ALCINREG(.RA,.STBSYR1,ONESCOUNT(.STBSYR1));
		CSTMNT[ASMNTREG]_.LHNODE[TARGTAC];
		CSTMNT[A1SAMEFLG]_1;
		IF .RHNODE[TARGTAC] EQL .CSTMNT[ASMNTREG] AND .RHNODE [INREGFLG]
		THEN
		CSTMNT[A2SAMEFLG]_1;
		RETURN TRUE;
	END;


	%(***IF RHS IS AN ARRAY-REF - LOAD THE VAL INTO THE DESIRED REG***)%
	IF .RHNODE[OPRCLS] EQL ARRAYREF
	THEN
	BEGIN
		TREEPTR_.RHNODE;
		ALCARRAY(FIRSTONE(.STBSYR),.STBSYR,.STRGCT);
		CSTMNT[ASMNTREG]_.LHNODE[TARGTAC];
		CSTMNT[A1SAMEFLG]_1;
		RETURN TRUE;
	END;


	%(***IF RHS CONTAINS A REFERENCE TO LHS VAR AND IS A SPECIAL OPERATOR
	     (P2MUL OR P2DIV), CHECK FOR ARG1 OF THAT OPERATOR EQUAL
	     TO THE LHS - IF IT IS, PERFORM THE OPERATION IN THE REG
	     ALLOCATED TO LHS - OTHERWISE GIVE UP
	****)%
	IF .RHNODE[OPRCLS] EQL SPECOP
	THEN
	BEGIN
		IF .RHNODE[ARG1PTR] EQL .LHNODE
		THEN
		BEGIN
			SETRHRGTOLH();
			RHNODE[A1SAMEFLG]_1;
			RETURN TRUE;
		END
		ELSE
		RETURN FALSE;
	END;


	%(***IF RHS CONTAINS A REFERENCE TO LHS VAR AND IS A RELATIONAL,
	     FUNCTION CALL, TYPE-CONVERSION, OR NEG/NOT - DON'T BOTHER
	****)%
	IF .RHNODE[OPRCLS] NEQ ARITHMETIC AND .RHNODE[OPRCLS] NEQ BOOLEAN
	THEN
	RETURN FALSE;


	%(***WHEN RHS EXPRESSION IS ARITHMETIC OR BOOLEAN AND CONTAINS
	     A REFERENCE TO LHS VAR***)%

	%(***IF ARG1 IS EQUAL TO LHS VAR, SIMPLY PERFORM OP IN LHS REG***)%
	IF .RHNODE[ARG1PTR] EQL .LHNODE
	THEN
	BEGIN
		SETRHRGTOLH();
		CMPNODINLH(.RHNODE);
		RETURN TRUE;
	END;


	%(***IF ARG2 IS EQUAL TO LHS VAR. ATTEMPT TO SWAP THE ARGS.
	     IF CAN DO SO, THE PERFORM OP IN LHS REG***)%
	IF .RHNODE[ARG2PTR] EQL .LHNODE
	THEN
	BEGIN
		IF COMMUTATIVE(RHNODE)
		THEN
		BEGIN
			SWAPARGS(RHNODE);
			SETRHRGTOLH();
			CMPNODINLH(.RHNODE);
			RETURN TRUE;
		END
		ELSE
		RETURN FALSE
	END;


	%(***SEARCH DOWN ONE LEVEL ONLY FOR REFERENCES TO LHS.
		THUS CAN HANDLE:
		A=A+C
		A=A+B+C
		A=A*B+C*D
		BUT NOT:
		A=A*B+C*D+E*F
		A=A+B+C+D
	****)%
	ARG1NODE_.RHNODE[ARG1PTR];
	ARG2NODE_.RHNODE[ARG2PTR];
	%(***IF EITHER OF THE ARGS WILL BE IMPOSSIBLE TO REFERENCE IF THE
		OTHER ARG IS COMPUTED INTO THE REG HOLDING THE LHS VAR,
		THEN GIVE UP. (EG I=I*J+K(I) CANNOT BE COMPUTED BY COMPUTING
		I*J IN THE REG FOR I)
	*****)%
	IF .ARG1NODE[RESRFFLG] AND .ARG2NODE[RESRFFLG] AND .RHNODE[OPRCLS] NEQ SPECOP
	THEN
	BEGIN
		IF MUSTSAVLHREG(.ARG1NODE) OR MUSTSAVLHREG(.ARG2NODE)
		THEN RETURN FALSE
	END;
	IF .ARG1NODE[OPRCLS] EQL ARITHMETIC OR .ARG1NODE[OPRCLS] EQL BOOLEAN OR .ARG1NODE[OPRCLS] EQL SPECOP
	THEN
	BEGIN
		IF .ARG1NODE[ARG1PTR] EQL .LHNODE
		THEN
		BEGIN
			CMPRHINLH();
			RETURN TRUE;
		END
		ELSE
		IF .ARG1NODE[ARG2PTR] EQL .LHNODE
		THEN
		BEGIN
			IF COMMUTATIVE(ARG1NODE)
			THEN
			BEGIN
				SWAPARGS(ARG1NODE);
				CMPRHINLH();
				RETURN TRUE;
			END;
		END;
	END;
	IF NOT .RHNODE[A2VALFLG] AND COMMUTATIVE(RHNODE)
	THEN
	BEGIN
		IF .ARG2NODE[ARG1PTR] EQL .LHNODE
		THEN
		BEGIN
			SWAPARGS(RHNODE);
			RHNODE[RVRSFLG]_NOT .RHNODE[RVRSFLG];	!WHEN EXCHANGE ARG1 AND ARG2
								! COMPUTE THEM IN THE ORDER
								! ORIGINALLY DETERMINED
			ARG1NODE_.RHNODE[ARG1PTR];
			ARG2NODE_.RHNODE[ARG2PTR];
			CMPRHINLH();
			RETURN TRUE;
		END
		ELSE
		IF .ARG2NODE[ARG2PTR] EQL .LHNODE
		THEN
		BEGIN
			IF COMMUTATIVE(ARG2NODE)
			THEN
			BEGIN
				SWAPARGS(ARG2NODE);
				SWAPARGS(RHNODE);
				RHNODE[RVRSFLG]_NOT .RHNODE[RVRSFLG];	!WHEN EXCHANGE ARG1 AND ARG2
								! COMPUTE THEM IN THE ORDER
								! ORIGINALLY DETERMINED
				ARG1NODE_.RHNODE[ARG1PTR];
				ARG2NODE_.RHNODE[ARG2PTR];
				CMPRHINLH();
				RETURN TRUE;
			END
		END
	END;


	RETURN FALSE;
END;
    y3Cc