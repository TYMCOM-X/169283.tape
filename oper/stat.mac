        TITLE   STAT          JIM BLUM     3/30/73
        R0=0    ; REGISTER 0
        R1=1    ; GENERAL WORKING REGISTERS
        R2=2
        R3=3
        R4=4
        R5=5
        R6=6
        R7=7
        S1=10   ; GENERAL REGISTERS FOR SUBROUTINES
        S2=11
        S3=12
        X1=13   ; INDEX REGISTERS
        X2=14
        X3=15
        X4=16
        P=17    ; PUSH DOWN STACK POINTER FOR PROGRAM LOCATION

        OPDEF CAL[PUSHJ P,0]
        OPDEF RET[POPJ P,]
        STKSIZ=100
STACK:  BLOCK STKSIZ
        DEFINE OPNMAC(N)
        < OPEN N,OPN'N>

        DEFINE OPBMAC(N)
<OPN'N: 14
        SIXBIT /DSK/
        XWD 0,HBLK'N
HBLK'N: BLOCK 3>

        DEFINE BK1MAC(N)
        <XWD 0,HBLK'N+1>

        DEFINE BK2MAC(N)
        <XWD 0,HBLK'N+2>

        DEFINE LKPMAC(N)
        <LOOKUP N,FIL'N>

        DEFINE FILMAC(N)
<FIL'N: SIXBIT /TESTXX/
        SIXBIT /DAT/
        BLOCK 3>

        DEFINE INMAC(N)
        <IN N,>

        DEFINE EOFMAC(N)
        <STATZ N,1B22>

        DEFINE CLSMAC(N)
        <CLOSE N,>

        DEFINE RLSMAC(N)
        <RELEASE N,>

        DEFINE STPMAC(N)
        <POINT 36,STK'N>
        DEFINE STKMAC(N)
        <STK'N: BLOCK 100>

;       ***THIS ROUTINE GETS ONE WORD (BYTE) FROM THE INPUT FILE
;       CHANNEL IN REGISTER X1 AND SKIPS IF SUCCESSFUL. THE WORD
;       (BYTE) IS RETURNED IN REGISTER R4.  IT IS CALLED BY A
        CAL GETWRD.
GETWRD: SOSGE @BLKTB2(X1)
        JRST GETBUF
        ILDB R4,@BLKTB1(X1)
        AOS (P)
        RET
GETBUF: XCT INTBL(X1)
        JRST GETWRD
        XCT EOFCKT(X1)
        RET
        OUTSTR [ASCIZ /
INPUT FILE ERROR/]
        RET

;       ***THIS ROUTINE READS IN A DECIMAL NUMBER FROM THE TTY
;       INTO REGISTER S1 AND LEAVES THE DELIMITING CHAR IN S2.
;       IT IS CALLED BY A CAL TRDNUM.
TRDNUM: SETZM S1
        INCHRW S2
        CAIN S2,15
        INCHRW S3
        CAIG S2,71
        CAIGE S2,60
        RET
        SUBI S2,60
        IMULI S1,^D10
        ADDM S2,S1
        JRST TRDNUM+1

;       ***READ OCTAL NUMBER.
TRONUM: SETZM S1
        INCHRW S2
        CAIN S2,15
        INCHRW S3
        CAIG S2,71
        CAIGE S2,60
        RET
        SUBI S2,60
        IMULI S1,10
        ADDM S2,S1
        JRST TRONUM+1

;       ***PRINT DECIMAL NUMBER IN REGISTER S1. IT DESTROYS
;       REGISTERS S1,S2 AND IS CALLED BY A CAL TPDNUM.
TPDNUM: IDIVI S1,^D10
        PUSH P,S2
        SKIPE S1
        CAL TPDNUM
        POP P,S1
        ADDI S1,60
        OUTCHR S1
        RET

;       ***THIS ROUTINE PRINTS AN OCTAL NUMBER SUPRESSING LEADING
;       ZEROS.  IT IS CALLED WITH THE NUMBER IN S1 BY A CAL TPONUM.
TPONUM: IDIVI S1,10
        PUSH P,S2
        SKIPE S1
        CAL TPONUM
        POP P,S1
        ADDI S1,60
        OUTCHR S1
        RET

        N==0
OPNTBL: REPEAT 16,
        < OPNMAC \N
        N==N+1>

        N==0
        REPEAT 16,<OPBMAC \N
        N==N+1>

        N==0
BLKTB1: REPEAT 16,<BK1MAC \N
        N==N+1>

        N==0
BLKTB2: REPEAT 16,<BK2MAC \N
        N==N+1>

        N==0
LKUPTB: REPEAT 16,<LKPMAC \N
        N==N+1>

        N==0
        REPEAT 16,<FILMAC \N
        N==N+1>

        N==0
INTBL:  REPEAT 16,<INMAC \N
        N==N+1>

        N==0
EOFCKT: REPEAT 16,<EOFMAC \N
        N==N+1>


        N==0
CLSTBL: REPEAT 16,<CLSMAC \N
        N==N+1>

        N==0
RLSTBL: REPEAT 16,<RLSMAC \N
        N==N+1>

        N==0
RECSTP: REPEAT 16,<STPMAC \N
        N==N+1>

RECSTK: BLOCK 16

        N==0
        REPEAT 16,<STKMAC \N
        N==N+1>
;       ***THESE ARE THE JOB TABLES (INDEXED BY JOB NUMBER) WHICH ARE
;       USED TO MATCH LOGON, LOGOFFS, AND CHECKPOINTS.
LOGWRD: BLOCK ^D128       ;  CONTAINS TYPE OF REORD AND LOG INFO
ONDAT:  BLOCK ^D128       ;  CONTAINS DATE AND TIME OF LOG ON
OFFDAT: BLOCK ^D128       ;  CONTAINS DATE AND TIME OF LOGOUT
TICHRS: BLOCK ^D128       ;  CONTAINS TOTAL NUMBER OF TTY INPUT CHARS
TOCHRS: BLOCK ^D128       ;  CONTAINS TOTAL NUMBER OF TTY OUTPUT CHARS
NETWRD: BLOCK ^D128       ;  CONTAINS SUPERVISOR NETWORK INFO

OBUF:   BLOCK 500       ;  OUTPUT BUFFER FOR XMITTING CHARS TO OTHER END

GO:     MOVE P,[IOWD STKSIZ,STACK]
        SETZM R0
        RESET
        IONEOU [201]    ;  HANDSHAKE PROCEDURE TO OTHER END OF CIRCUIT
        IONEOU [202]    ;  SEND OUT 4 CHARACTERS
        IONEOU [203]
        IONEOU [204]
GO1:    INCHRW R1       ; AND WAIT FOR RESPONSE
        CAIE R1,41
        JRST GO1        ;  KEEP LOOKING FOR THE 4 RESPONSE CHARS.
        INCHRW R1
        CAIE R1,42
        JRST GO1
        INCHRW R1
        CAIE R1,43
        JRST GO1
        INCHRW R1
        CAIE R1,44
        JRST GO1
        CAL TRDNUM     ;  READ DECIMAL NUMBER FROM TTY
        MOVEM S1,BYEAR# ;  BEGINNING YEAR
        CAL TRDNUM
        MOVEM S1,BMONTH# ; BEGINNING MONTH
        CAL TRDNUM
        MOVEM S1,BDAY#  ;  BEGINNING DAY
        CAL TRDNUM
        MOVEM S1,TIME#  ;  STARTING TIME
        CAL TRDNUM  
        MOVEM S1,EYEAR# ;  ENDING YEAR
        CAL TRDNUM
        MOVEM S1,EMONTH# ; ENDING MONTH
        CAL TRDNUM
        MOVEM S1,EDAY#  ;  ENDING DAY
        MOVE R1,BYEAR   ;  CONVERT TO STANDARD PDP DATE FORMAT
        SUBI R1,^D64
        IMULI R1,^D12
        ADD R1,BMONTH
        SUBI R1,1
        IMULI R1,^D31
        ADD R1,BDAY
        SUBI R1,1
        MOVEM R1,BDATE# ;  SAVE BEGINNING DATE
        MOVE R2,EYEAR   ;  CONVERT TO STANDARD PDP DATE FORMAT
        SUBI R2,^D64
        IMULI R2,^D12
        ADD R2,EMONTH
        SUBI R2,1
        IMULI R2,^D31
        ADD R2,EDAY
        SUBI R2,1
        MOVEM R2,EDATE# ;  SAVE ENDING DATE
        MOVE R3,TIME    ;  CONVERT TO JIFFIES
        IMULI R3,^D216000
        MOVEM R3,BETIME#;  SAVE IT
        LSH R1,^D24     ;  COMBINE DATE AND TIME FOR BEGINNING DATE
        ADD R1,R3       ;  TO REGISTER R1
        LSH R2,^D24     ;  COMBINE DATE AND TIME FOR ENDING DATE
        ADD R2,R3       ;  TO REGISTER R2

;       ***THIS ROUTINE USES THE BEGINNING AND ENDING DAYS TO OPEN
;       ALL THE (SYS)TESTDD.DXX ACCOUNTING FILES.
        MOVEI R7,2
        SETZM X1        ;  REGISTER FOR CURRENT FILE CHANNEL INDEX
        MOVE R4,BDAY    ;  GET BEGINNING DAY OF MONTH
GETFIL: MOVEI R6,(SIXBIT /DAT/) ; EXTENSION
        IDIVI R4,^D10   ;  CONVERT INTO SIXBIT CHARS
        LSH R5,^D30
        LSHC R4,6
        ADDI R4,642020
GETFL1: HRRZ X2,LKUPTB(X1)  ;  PUT POINTER TO FILE NAME IN X2
        HRRM R4,(X2)        ;  STORE RIGHT 3 CHARS OF FILE NAME W/ DATE
        HRLM R6,1(X2)       ;  STORE EXTENSION IN SECOND WORD
        MOVEI R5,USRNAM         ;  SETUP BILLING10 USER NAME
        HRRZM R5,3(X2)         ;  IN THIRD WORD
        XCT OPNTBL(X1)  ;  TRY AND OPEN CHANNEL IN X1
        JRST CHNERR     ;  OUT OF CHANNELS, BAD NEWS
        XCT LKUPTB(X1)  ;  SEE IF THIS FILE EXISTS
        JRST GETFL2     ;  NO MORE FILES FOR THIS DAY, TRY ENDING DAY
        CAIN R6,(SIXBIT /DAT/) ; WAS EXTENSION /DAT/?
        MOVEI R6,(SIXBIT /D00/) ; YES, NOW USE /DXX/
        ADDI R6,1       ;  INCREMENT EXTENSION
        TRNN R6,7       ;  CONVERT TO /D7X/
        ADDI R6,100-10  ;  IF WE HAVE WRAPPED AROUND YET
        AOJA X1,GETFL1  ;  INCREMENT CHANNEL NUMBER AND OPEN NEXT FILE
GETFL2: MOVE R4,EDAY    ;  NOW USE NEXT DAY
        XCT RLSTBL(X1)     ;  RELEASE CHANNEL WHICH LAST LOOKUP FAILED ON
        SOJG R7,GETFIL   ; OPEN FILES FOR NEXT DAY IF HAVENT ALREADY
        TRNN X1,17      ;  TEST TO SEE IF ANY FILES WERE FOUND
        JRST EOD        ;  NO, SEND END OF DATA CHARACTER
        MOVNS X1        ;  SETUP X1 TO WORK WITH AOBJ INSTRUCTION
        HRLZS X1        ;  LH = NEGATED NUMBER OF OPENED CHANNELS, RH=0
        MOVEM X1,CHNLX# ;  SAVE FOR LATER USE

;       ***THIS ROUTINE MATCHES LOGON AND LOGOFFS AND MAKES UP RECORDS
;       TO BE SHIPPED OUT.  IF THERE IS NO LOGOUT RECORD, THE TIME OF THE
;       LAST CHECKPOINT IS USED.  THE RECORDS WHICH ARE SENT OUT
;       CONSIST OF ONLY THE TIME THAT THE USER IS ATTACHED.  IF
;       A CHECKPOINT RECORD IS INDICATES THE USER DETACHED,
;       THEN IT BECOMES A LOGOUT RECORD AND IS SHIPPED OUT.  ANY NEW
;       CHECKPOINT FOR THAT PARTICULAR JOB NUMBER WHICH IS RECEIVED
;       AND INDICATES THE USER IS NOW ATTACHED TO THAT JOB BECOMES
;       A NEW LOGIN RECORD FOR THAT JOB NUMBER.
MATCH: CAL GNXREC      ;  GET THE NEXT EARLIEST RECORD FROM ALL FILES
        JRST DONE       ;  NO MORE FINISHED
        MOVE X3,RECSTP(X2)      ;  POINTER TO BEGINNING OF RECORD
        MOVE R4,(X3)    ;  LOG INFO AND TYPE OF RECORD
        MOVE X1,R4
        LSH X1,-^D18
        ANDI X1,777     ;  JOB NUMBER
        MOVE R5,R4
        LSH R5,-^D27
        ANDI R5,777     ;  TYPE OF RECORD
        CAIE R5,100     ;  IS IT A LOGIN RECORD?
        JRST MATCH4     ;  NO
        CAMG R2,2(X3)
        JRST MATCH1     ;  LOGIN DATE IS GREATER THAN END DATE, IGNORE
        MOVEM R4,LOGWRD(X1) ;  YES, SAVE LOG WORD OF RECORD IN JOB TABLE
        MOVE R4,2(X3)   ;  GET LOGON DATE AND TIME
        MOVEM R4,ONDAT(X1)      ;  AND SAVE IN JOB TABLE
        MOVE R4,6(X3)   ;  GET NETWORK INFO
        MOVEM R4,NETWRD(X1)
MATCH1: SETZM @RECSTP(X2)       ;  ZERO FIRST WORD OF RECORD FOR GNXREC
        JRST MATCH      ;  GET NEXT RECORD
MATCH4: CAIE R5,140     ;  IS IT A LOGOUT RECORD?
        JRST MATCH5     ;  NO
        SKIPN LOGWRD(X1)  ;  DO WE HAVE A MATCHING LOG ON RECORD?
        JRST MATCH1     ;  NO,  IGNORE RECORD
        MOVE R4,2(X3)   ;  GET LOGOFF TIME
        MOVEM R4,OFFDAT(X1) ;   SAVE IN JOB TABLE
MATCH2: MOVE R4,13(X3)        ;  GET TOTAL NUMBER OF INPUT CHARS
        MOVEM R4,TICHRS(X1)
        MOVE R4,14(X3)        ;  GET TOTAL NUMBER OF OUTPUT CHARS
        MOVEM R4,TOCHRS(X1)
        CAL SNDREC      ;  SHIP THIS RECORD OUT
        SETZM LOGWRD(X1)  ;  ERASE INFO ABOUT THIS JOB NUMBER
        JRST MATCH1     ;  AND GO TO NEXT RECORD
MATCH5: CAIE R5,200     ;  IS IT A CHECKPOINT
        JRST MATCH1     ;  NO IGNORE RECORD
        SKIPE LOGWRD(X1)  ;  DO WE HAVE AN ASSOCIATED LOGON FOR THIS JOB
        JRST MATCH6     ;  YES
        SKIPE 24(X3)  ;  IS THE USER NOW DETACHED?
        CAMG R2,2(X3) ;  IS THE LOGIN DATE GREATER THAN END DATE?
        JRST MATCH1     ;  YES, IGNORE IT
        MOVEM R4,LOGWRD(X1)  ;  NO, MAKE UP A NEW LOGIN RECORD ON THIS JOB
        MOVE R4,2(X3)   ;  GET DATE AND RECORD IN JOB TABLE
        MOVEM R4,ONDAT(X1)
        MOVE R4,24(X3)  ;  RECORD NETWORK INFO
        MOVEM R4,NETWRD(X1)
        JRST MATCH1     ;  CONTINUE
MATCH6: MOVE R4,2(X3)   ;  GET DATE
        MOVEM R4,OFFDAT(X1)  ; AND STORE AS LOGOFF TIME
        SKIPE 24(X3)  ;  IS USER NOW DETACHED?
        JRST MATCH1     ;  NO, WAIT FOR LOGOUT OR DETACHED CKPT
        JRST MATCH2     ;  YES, MAKE UP RECORD TO BE SENT OUT

;       ***THIS ROUTINE FINDS THE EARLIEST NEXT RECORD FROM ALL THE OPENED
;       FILES AND RETURNS THE CHANNEL NUMBER OF THE EARLIEST RECORD
;       IN X2, AND THE DATE IN R5.  ALL THE CURRENT RECORDS ARE STORED
;       IN STACKS, INDEXED BY CHANNEL NUMBER, WHOSE POINTERS ARE IN
;       A TABLE CALLED "RECSTK". IE., TO GET THE FIRST WORD OF THE STACK
;       WHICH CONTAINS THE EARLIEST RECORD, A "ILDB RECSTK(X2)" CAN BE
;       USED.  IT IS THE RESPONSIBILITY OF THE ROUTINE WHICH FINSIHES
;       WITH THE RECORD TO STORE A ZERO IN THE FIRST WORD OF THE
;       RECORD IN THE STACK.  OTHERWISE THE SAME RECORD WILL STAY THERE.
;       THIS ROUTINE SKIPS IF A RECORD IS FOUND WITH A VALID DATE.
GNXREC: MOVE X1,CHNLX
GNXR4:  HRR X4,RECSTP(X1)       ;  POINTER TO BEG. OF CURRENT STACK
        SKIPE (X4)             ;  CHECK TO SEE IF STACK IS EMPTY
        JRST RNXFL1             ;  VALID RECORD, GO TO NEXT CHANNEL
GNXR3:  MOVE R4,RECSTP(X1)      ;  INITIALIZE STACK TO BEGINNING
        MOVEM R4,RECSTK(X1)
        CAL GETWRD              ;  READ NEXT WORD FROM FILE
        JRST RNXFIL             ;  EOF OR ERROR, SKIP THIS FILE
        TLNE R4,340000          ;  TEST VALIDITY OF FIRST WORD IN RECORD
        TLNE R4,37000
        JRST GNXR3              ;  NOT LEGIT,  KEEP READING FOR GOOD RECORD
        TRNN R4,77              ;  TEST FOR NON-ZERO RECORD LENGTH
        JRST GNXR3              ;  NO GOOD, KEEP READING
        MOVE R5,R4              ;  SETUP TO STACK THIS RECORD
        ANDI R5,77
        MOVNS R5
        HRLZS R5
GNXR2:  IDPB R4,RECSTK(X1)      ;  STORE IN CURRENT STACK
        AOBJP R5,GNXR1
        CAL GETWRD
        JRST RNXFIL
        JRST GNXR2
GNXR1:  CAMG R1,2(X4)          ;  COMPARE BEGIN DATE WITH CURRENT RECORD
        JRST RNXFL1             ;  DATE IS > THAN BEGIN DATE, NEXT CHANNEL
        JRST GNXR3              ;  DATE IS TOO EARLY, READ NEXT RECORD
RNXFIL: SETZM (X4)             ;  RECORD IS INVALID, ZERO OUT FIRST WORD
RNXFL1: AOBJN X1,GNXR4          ;  GO TO NEXT CHANNEL IF THERE ARE MORE
        MOVE X1,CHNLX           ;  ALL CHANNELS HAVE BEEN PROCESSED
        MOVSI R5,377777 ;  NOW FIND THE RECORD WITH THE EARLIEST DATE
FEREC:  HRR X4,RECSTP(X1)       ;  POINTER TO BEG. OF CURRENT STACK
        SKIPN (X4)             ;  SKIP ANY INVALID RECORDS (1ST WORD=0)
        JRST FEREC1
        CAMG R5,2(X4)           ;  COMPARE WITH LAST EARLIEST DATE
        JRST FEREC1
        MOVE R5,2(X4)           ;  FOUND AN EARLIER DATE, SAVE IN R5
        MOVE X2,X1              ;  AND SAVE CHANNEL NUMBER IN X2
FEREC1: AOBJN X1,FEREC          ;  CONTINUE UNTIL ALL RECORDS ARE TESTED
        MOVE R4,[XWD RECSTP,RECSTK]  ;  REINITIALIZE STACKS TO BEG.
        BLT R4,RECSTK+15
        CAME R5,[377777B17]     ;  WAS ANY VALID RECORD FOUND?
        AOS (P)                 ;  YES, SKIP RETURN
        RET

;       ***THIS ROUTINE TAKES INFO FROM THE JOB TABLES AND CONVERTS
;       IT INTO WORDS TO BE SENT OUT BY A ROUTINE CALLED "XMIT"
;       THE WORDS SENT OUT FORM A COMPLETE RECORD WHICH IS SIMPLY
;       PASSED ONTO THE OUTPUT FILE ON THE OTHER END OF THE CIRCUIT.
SNDREC: SETZM R5
        MOVE R4,NETWRD(X1)
        LSHC R3,^D20    ;  GET ORIGINATING NODE 
        LSH R4,2        ;  AND CONVERT IT TO A NUMBER
        LSHC R3,-6      ;  WHICH WHEN PRINTED OUT USING A DECIMAL
        MOVEI R6,4      ;  FORMAT, WILL APPEAR AS AN OCTAL NUMBER
        LSHC R3,3
        ANDI R3,7
        EXCH R3,R5
        IMULI R3,^D10
        ADDM R3,R5
        SOJN R6,.-5
        CAL XMIT        ;  ROUTINE TO SEND OUT ONE WORD
        MOVE R5,NETWRD(X1)  ;  NEXT GET THE ORIGINATING PORT
        ANDI R5,77
        CAL XMIT
        MOVE R5,NETWRD(X1)
        LSH R5,-^D24
        ANDI R5,77
        CAL XMIT        ;  TERMINAL ID
        MOVE R5,[XWD 0,11]
        GETTAB R5,      ;  GET HOST NUMBER
        JRST .+1
        LSHC R5,-^D22   ;  CONVERT THE 7-BIT ASC TO A NUMBER
        ANDI R5,177
        SUBI R5,60
        LSH R6,-^D29
        ANDI R6,177
        SUBI R6,60
        IMULI R5,^D10
        ADD R5,R6
        CAL XMIT        ;  SEND HOST NUMBER
        MOVE R5,X1      ;  HOST PORT NUMBER NOT AVAILABLE, SO
        ANDI R5,177     ;  SEND JOB NUMBER INSTEAD
        CAL XMIT
        MOVE R5,EYEAR   ;  SEND DATE OF LOG ON IN GMT
        IMULI R5,^D100
        ADD R5,EMONTH
        IMULI R5,^D100
        ADD R5,EDAY
        MOVE R3,R5
        CAL XMIT        ;  YYMMDD OF LOGON
        MOVE R5,ONDAT(X1)
        AND R5,[77777777]  ;  GET TIME IN JIFFIES
        IDIVI R5,^D3600
        IDIVI R5,^D60      ;  CONVERT TO HOURS IN R5, AND MINS IN R6
        SUB R5,TIME      ;  CONVERT TO GMT
        ADDI R5,^D24
        CAIL R5,^D24
        SUBI R5,^D24
        IMULI R5,^D100
        ADD R5,R6       ;  COMBINE INTO HHMM
        CAL XMIT        ;  TIME IN GMT HHMM FOR LOGON
        MOVE R5,TICHRS(X1)
        CAL XMIT        ;  NUMBER OF INPUT TERMINAL CHARS
        MOVE R5,TOCHRS(X1)
        CAL XMIT        ;  NUMBER OF OUTPUT TERMINAL CHARS
        MOVE R5,TICHRS(X1)
        ADD R5,TOCHRS(X1)
        CAL XMIT        ;  TOTAL NUMBER OF TERMINAL CHRS
        MOVE R5,R3
        CAMLE R2,OFFDAT(X1)  ;  CHECK IF LOGOFF DATE EXCEEDS EDATE
        JRST SNDRC1     ;  NO, OUTPUT DATE
        MOVE R5,EYEAR   ;  YES, BUMP DATE BY ONE
        IDIVI R5,4      ;  CHECK FOR LEAP YEAR
        MOVEI R5,^D29
        TRNE R6,3
        SUBI R5,1       ;  NOT LEAP YEAR, SET DAYS IN FEB TO 28
        MOVEM R5,MONTBL+2  ;  STORE IN MONTH TABLE
        MOVE R3,EDAY    ;  INCR DAY AND CHECK FOR CHANGE IN MONTH
        MOVE R4,EMONTH
        MOVE R5,EYEAR
        ADDI R3,1       ;  BUMP DAY
        CAMG R3,MONTBL(R4)  ;  CHECK AGAINST NUM OF DAYS IN MONTH
        JRST SNDRC2     ; NO CHANGE TO MONTH NOR YEAR
        MOVEI R3,1      ;  SET TO 1ST OF MONTH
        ADDI R4,1       ;  BUMP MONTH
        CAIG R4,^D12    ;  CHECK AGAINST NUMBER OF MONTHS IN A YEAR
        JRST SNDRC2     ;  OK, NO CHANGE TO YEAR
        MOVEI R4,1      ;  SET TO JANUARY
        ADDI R5,1       ;  BUMP YEAR
SNDRC2: IMULI R5,^D100  ;  COMBINE YEAR, MONTH AND DAY
        ADD R5,R4
        IMULI R5,^D100
        ADD R5,R3
SNDRC1: CAL XMIT        ;  LOFOFF DATE YYMMDD
        MOVE R5,OFFDAT(X1)
        AND R5,[77777777]  ;  LOGOFF TIME IN JIFFIES
        IDIVI R5,^D3600    ;  CONVERT TO HOURS AND MINUTES
        IDIVI R5,^D60      ;  HOURS IN R5, MINS IN R6
        SUB R5,TIME
        ADDI R5,^D24       ;  CONVERT TO GMT
        CAIL R5,^D24
        SUBI R5,^D24
        IMULI R5,^D100
        ADD R5,R6
        CAL XMIT        ;  SEND LOFOFF TIME IN GMT HHMM
        MOVE R4,NETWRD(X1)
        HRRZI R5,1      ;  SET UP TO SEND 1=LOGOFF, 2=DISCONNECT
        TLNE R4,1B19    ;  BIT 1 ON IMPLIES DISCONNECT
        ADDI R5,1       ;  DISC
        CAL XMIT
        SETZM R5
        CAL XMIT        ;  SPARE WORDS
        SETZM R5
        CAL XMIT
        SETZM R5
        CAL XMIT
        RET             ;  RETURN

;       ***THIS ROUTINES SENDS OUT THE RIGHT 24 BITS OF THE WORD
;       TO BE TRANSMITTED, ONE CHARACTER AT A TIME IN IMAGE MODE.
;       IT ALSO STACKS THE WORDS BERANSMITTED AND COMPUTES A
;       CHECKSUM OF THE RECORD WHICH IS 256 WORDS LONG. AFTER THE RECORD
;       IS SENT, THE END OF RECORD CHARACTER IS SENT FOLLOWED
;       BY THE CHECKSUM.  IT THEN AWAITS A GOOD OR BAD RESPONSE FROM
;       THE PROGRAM AT THE OTHER END.  IF THE RESPONSE IS NEGATIVE, THEN
;       THE ROUTINE RETRANSMITS THE RECORD.  IT GIVES UP ATER 4 TRIES.
XMIT:   SKIPE NWRDS#    ;  NWRDS = 0 IMPLIES START A NEW RECORD
        JRST XMIT1
        MOVEI R6,3
        MOVEM R6,RXMITN#  ;  NUMBER OF RETRIES
        MOVEI R6,377
        MOVEM R6,NWRDS  ;  256 WORD RECORD
        MOVE R6,[POINT 36,OBUF]
        MOVEM R6,OBUFWP#        ;  RECORD BUFFER WRITE IN POINTER
        MOVE R6,[POINT 36,OBUF]
        MOVEM R6,OBUFRP#        ;  RECORD BUFFER READ OUT POINTER
        MOVEM R5,CKSUM#         ;  START CHECKSUM WITH 1ST WORD
        IDPB R5,OBUFWP          ;  DEPOSIT 1ST WORD IN RECORD BUFFER
        IONEOU [200]            ;  SEND BLOCK CHARACTER
        IONEOU [201]            ;  START OF NEW RECORD CHARACTER
        CAL XWRD                ;  SEND OUT WORD TO OTHER END
        RET
XMIT1:  IDPB R5,OBUFWP          ;  CONTINUE DEPOSITING AND SENDING WORDS OUT
        ADDM R5,CKSUM
        CAL XWRD
        SOSE NWRDS
        RET
XMIT2:  IONEOU [200]    ;  END OF RECORD, SEND BLOCK CHARACTER
        IONEOU [202]    ;  FOLLOWED BY END OF RECORD CHARACTER
        MOVE R6,CKSUM  ;  SEND RIGHT 24 BITS OF CHECKSUM
        MOVEI R7,3
        IONEOU R6
        LSH R6,-^D8
        SOJN R7,.-2
;       ***THIS ROUTINE WAITS FOR A RESPONSE FROM THE OTHER END
;       THE CHARACTER "!" (41B) IS A POSITIVE RESPONSE, ANTHING ELSE
;       IS TREATED AS A NEGATIVE RESPONSE, AND THE RECORD IS 
;       RETRANSMITTED.
RSPNSE: INCHRW R6
        CAIN R6,41
        RET
RXMIT:  SOSGE RXMITN
        JRST XFAIL      ;  GIVE UP
        MOVE R6,[POINT 36,OBUF]
        MOVEM R6,OBUFRP
        MOVEI R6,400
        SUB R6,NWRDS
        IONEOU [200]
        IONEOU [201]
        CAL XWRD
        SOSE R6
        JRST .-2
        JRST XMIT2

;       ***THIS ROUTINE TRANSMITS THE RIGHT 24 BITS OF THE WORD IN THE
;       RECORD BUFFER POINTED TO BY "OBUFRP"
XWRD:   MOVEI R7,3
        ILDB R4,OBUFRP  ;  GET NEXT WORD TO BE SENT
XWRD1:  TRNE R4,200     ;  CHECK FOR BLOCK CHARACTER (200B)
        TRNE R4,177
        JRST .+2        ;  NO
        IONEOU R4       ;  YES, SEND ANOTHER ONE TO ACT AS ESCAPE CHAR
        IONEOU R4       ;  SEND ACTUAL CHARACTER
        LSH R4,-^D8
        SOJN R7,XWRD1
        RET

;       NO MORE RECORDS IN ALL THE FILES,  SEE IF THERE ANY UNMATCHED
;       LOGONS, AND USE THE LAST CHECKPOINT TIME, IF THERE
;       IS ONE,  AND SEND IT OUT.
DONE:   HRLZI X1,-^D128
        SKIPE LOGWRD(X1)  ;  IS THERE AN UNMATCHED LOGON RECORD
        SKIPN OFFDAT(X1)        ;  AND A CHECKPOINT?
        JRST .+2        ;  NO SKIP THIS ONE
        CAL SNDREC      ;  YES, SEND THIS RECORD OUT
        AOBJN X1,DONE+1  ;  ANY MORE?
        SKIPE NWRDS     ;  WAS A PARTIAL RECORD SENT?
        CALL XMIT2      ;  YES, TERMINATE RECORD AND WAIT FOR RESPONSE
EOD:    IONEOU [200]
        IONEOU [203]    ;  END OF DATA CHARACTER
        EXIT            ;  FINISHED

XFAIL:  IONEOU [200]    ;  FATAL TRANSMISSION PROBLEMS, QUIT
        IONEOU [205]
        EXIT

CHNERR: CAILE X1,7      ;  OUT OF CHANNELS OR CHANNEL PROBLEMS
        JRST GETFL2     ;  PROCESS WHAT FILES WE HAVE OPEN
        IONEOU [200]    ;  CHANNEL PROBLEMS, GIVE UP
        IONEOU [204]
        EXIT

USRNAM: SIXBIT /BILLING10/
MONTBL: EXP 0,^D31,^D28,^D31,^D30,^D31,^D30,^D31,^D31,^D30,^D31,^D30,^D31

        END GO
  @+$