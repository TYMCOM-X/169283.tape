^^
.paper size 60,72
.spacing 1
.title STRINGS IN SFORTRAN ON TYMCOM-X
.center
STRINGS IN SFORTRAN
.center
ON TYMCOM-X
.skip 2
STRING EXPRESSIONS
.paragraph
A string expression consists of one or more string elements
separated by a plus sign denoting concatenation.
String expressions may have parentheses around subexpressions
as in numeric expressions,
but the parentheses do not affect code generation.
A string element can be either a string constant, a string scalar
reference, a string array reference, a builtin string valued function
call or a user defined string valued function call.
.paragraph
In all the syntax descriptions, the following notation will be used.
.skip 2
.left margin 8
.nofill
<se> denotes a string expression
<ne> denotes a numeric expression
<e> denotes either a <se> or <ne>
S,S1,S2,... denote string variables
SF,SF1,SF2,... denote nonbuiltin string valued functions
NF,NF1,NF2,... denote nonbuiltin numeric valued functions
n,n1,n2,... denote integer constants
d,d1,d2,... denote array dimensions
.skip 2
.left margin 0
.tab stops 8
The following are the syntax equations for string expressions.
.skip 1
<se> __ <s> | <s> + <se>
<s>  __ "text" | 'text' | <sv> | <sf>
<sv> __ S | S( <ne>,...,<ne> )
<sf> __ SF [ ( <e>,...,<e> ) ]
	| LEFT( <se>,<ne> )
	| RIGHT( <se>,<ne> )
	| SUBSTR( <se>,<ne> [ ,<ne> ]  )
	| STR( <ne> )
	| CHAR( <ne> )
	| DATE( <ne> )
	| MAX( <se>,...,<se> )
	| MIN( <se>,...,<se> )
.skip 3
.fill
STRING USES
.paragraph
String expressions and string variables can be used in the following
places in a program.
.skip 2
.tab stops 25
.nofill
Replacement statement:	<sv> = <se>
.skip 1
Numeric function call:	ASC( <se> )
	IVAL( <se> )
	VAL( <se> )
	DVAL( <se> )
	CVAL( <se> )
	INDEX( <se>,<se> [ ,<ne> ] )
	LENGTH( <se> )
	NF( <e>,...,<e> )
.skip 1
I/O statements:	READ( <ne>,<se> ) ...,<se>,...,S,...
	   where S is a string array
	   (also WRITE, DISPLAY, etc.)
	OPEN( <ne>,<se>,... )
.skip 1
Relationals:	<se> .eq. <se>
	<se> .ne. <se>
	<se> .lt. <se>
	<se> .gt. <se>
	<se> .le. <se>
	<se> .ge. <se>
.skip 1
Declarations:	STRING S1(n1),S2(d1,...dn)(n2)
	STRING S3(*,...,*),(n3)
	STRING FUNCTION SF [ (dummies) ]
.skip 1
Message typeout:	PAUSE <string-constant>
	STOP <string-constant>
	QUIT <string-constant>
	DONE <string-constant>
	ACCEPT ...,<string-constant>,...
.skip 3
.fill
INTERNAL STRING REPRESENTATION
.paragraph
The compiled code for string references will not address the text
for the string directly,
but will instead address a string pointer.
The string pointer will have the declared length in the left
half and the address of the first word of text in the right half.
The text for a string scalar and a string array element will
start at the beginning of a word.
String array elements will be stored consecutively as with
numeric arrays.
The string pointer for the array will address the first
element of the array.
Since a string may have as its value a string of length less than
the string's declared length,
the last word which contains text will have bit 35 set.
If this word contains less than five characters,
the last character will be followed by an EOLIT character (000).
.skip 1
.test page 40
Examples:
.skip 2
.nofill
.tab stops 15 30
Declaration	Value	Representation
.figure 36
.fill
CODE GENERATED BY COMPILER FOR STRINGS
.paragraph
The compiler views the string routines in the library as accessing a
stack of variable length entries.
Each entry is a string expression.
The compiler generates code to start a new stack entry,
to concatenate a string to the end of the top stack entry
and to make reference to any stack entry relative to the top entry.
The runtime routines handle stacking and unstacking of strings
on the stack.
.paragraph
The notation
.skip 1
.indent 8
CALL FUN(A1,...,An)
.skip 1
will be used as shorthand for the standard calling sequence
.nofill
.tab stops 8 16
.skip 1
	MOVEI	16,PTR
	PUSHJ	17,FUN
	.
	.
	XWD	-n,0
ptr:	XWD	T1,A1
	.
	.
	XWD	Tn,An
.fill
.skip 1
where Ti is the type code for argument Ai.
If there are no arguments, the MOVEI 16,PTR instruction and the argument
block are not generated.
.skip 1
i) <se>
.paragraph
The first instruction in the code generated for all string expressions
is the call
.skip 1
	CALL SESTRT
.skip 1
which indicates the start of a new string expression and a new stack
entry.
To concatenate a string variable to the string on top of
the string stack, the UUO
.skip 1
	STRNG	S
.skip 1
is called.
The string pointer for the string to be concatenated is stored in S.
To concatenate a string array reference, the UUO
.skip 1
	STRNGA	S(X)
.skip 1
is called.
The subscript is in register X and the string pointer for the
array is stored in S.
.paragraph
When showing compiled code, <se> will be used to denote the code
generated to put the string expression <se> on the string stack.
.skip 2
ii) LEFT( <se>,<ne> ) RIGHT( <se>,<ne> ) SUBSTR( <se>,<ne>,<ne> )
.skip 1
.nofill
	<se>
	CALL LEFT(<ne>) or RIGHT(<ne>) or SUBSTR(<ne>,<ne>)
.skip 1
Example: S1+LEFT(S2+S3,N)+S4
.skip 1
	PUSHJ	17,SESTRT
	STRNG	S1
	PUSHJ	17,SESTRT
	STRNG	S2
	STRNG	S3
	MOVEI	16,PTR
	PUSHJ	17,LEFT
	STRNG	S4
	.
	XWD	-1,0
PTR:	XWD	0,N
.skip 1
.fill
All three functions (LEFT,RIGHT,SUBSTR) remove the top stack entry and then concatenate
their value to the new top stack entry.
.skip 2
iii) STR(<ne>) CHAR(<ne>)
.skip 1
.nofill
	CALL STR(<ne>) or CHAR(<ne>)
.skip 1
Example: S1+CHAR(N)
.skip 1
	PUSHJ	17,SESTRT
	STRNG	S1
	MOVEI	16,PTR
	PUSHJ	17,CHAR
	.
	XWD	-1,0
PTR:	XWD	0,N
.skip 1
.fill
Both functions concatenate their value to the top stack entry.
.skip 2
iv) DATE(<ne>)
.skip 1
	CALL DATE
.skip 1
The argument to the DATE function is not used.
The value of the function is concatenated to the top of the string
stack.
.skip 2
v) MAX(<se>,...,<se>) MIN(<se>,...,<se>)
.skip 1
.nofill
	<se>1
	.
	.
	<se>n
	CALL MAX(n) or MIN(n)
.skip 1
.fill
All arguments are removed from the string stack and after their
removal, the value is concatenated to the top stack entry.
.skip 1
.nofill
Example: MAX(S1,S2,SUBSTR(S3,I,J))+S4
.skip 1
	PUSHJ	17,SESTRT
	PUSHJ	17,SESTRT
	STRNG	S1
	PUSHJ	17,SESTRT
	STRNG	S2
	PUSHJ	17,SESTRT
	STRNG	S3
	MOVEI	16,P1
	PUSHJ	17,SUBSTR
	MOVEI	16,P2
	PUSHJ	17,MAX
	STRNG	S4
	.
	.
	XWD	-2,0
P1:	XWD	0,I
	XWD	0,J
	XWD	-1,0
P2:	XWD	[3]
.skip 2
.fill
vi) SF(...,<se>,...) NF(...,<se>...)
.paragraph
String arguments in all user defined function calls are passed on
the string stack.
A type code in the argument block indicates to the function
that the argument is on the stack rather than pointed to by the
right half of the argument block entry.
The strings on the stack will be stored in local variables
on entry to subroutines or functions with string dummies.
Also, all string arguments will be removed from the stack
after being stored in local variables.
.skip 2
vii) RETURN from a string valued function
.paragraph
RETURN will concatenate its value to the top
entry on the stack by generating a STRNG UUO of its value.
.skip 2
viii) <sv> = <se>
.paragraph
Replacement statements into a string scalar S generate
.skip 1
.nofill
	<se>
	SSTOR	S
.skip 1
.fill
and replacement statements into the string array S(<subscripts>)
generate
.skip 1
.nofill
	<se>
	<subscripts> into register X
	SSTORA	S(X)
.skip 2
.fill
ix) ASC(<se>) IVAL(<se>) VAL(<se>) DVAL(<se>) CVAL(<se>) LENGTH(<se>)
.skip 1
.nofill
	<se>
	CALL ASC or IVAL or VAL or DVAL or CVAL or LENGTH
.skip 1
.fill
Each function removes the top stack entry before returning.
.skip 2
x) INDEX(<se>1,<se>2,<ne>)
.skip 1
.nofill
	<se>1
	<se>2
	CALL INDEX(<ne>)
.skip 1
.fill
Before returning, the two argument strings are removed from the stack.
.skip 2
xi) <se> as FORMAT reference
.skip 1
.nofill
	<se>
	CALL SFRFS(<unit>) or SFWFS(<unit>)
.skip 1
.fill
The format is passed to the format processor on the string stack.
The routine SFRFS is for formatted read and SFWFS is for
formatted write.
Both calls remove the top stack entry before returning.
.skip 2
xii) String references in I/O list
.paragraph
I/O list items generate one of two calls.
For a string expression, including string scalar and array
references, the code generated is
.skip 1
.nofill
	<se>
	CALL STREL
.skip 1
.fill
The top stack entry is removed before returning.
For unsubscripted array references, the code generated is
.skip 1
	CALL STRELA(S,N)
.skip 1
where S is the string pointer for the array and N is the number
of elements in the array.
.skip 2
xiii) OPEN(<unit>,<se>,...)
.skip 1
.nofill
	<se>
	CALL SFOPNS(<unit>,<type>,<record-size>)
.skip 1
.fill
The file name is passed on the string stack and is removed from
the stack before returning.
.skip 2
xiv) relationals
.paragraph
Six routines are used to compare two strings.
Each return without skipping if the tested condition is false and
skip if the condition is true.
.skip 1
.nofill
.tab stops 16 26
Relation	Routine	Test
.skip
<se>1.EQ.<se>2	SKPSE	<se>1 = <se>2
<se>1.NE.<se>2	SKPSN	<se>1 _# <se>2
<se>1.LT.<se>2	SKPSL	<se>1 < <se>2
<se>1.GT.<se>2	SKPSG	<se>1 > <se>2
<se>1.LE.<se>2	SKPSLE	<se>1 <= <se>2
<se>1.GE.<se>2	SKPSGE	<se>1 >= <se>2
.fill
.skip 1
All six routines remove both arguments from the stack before returning.
.skip 1
.nofill
Example: IF(S1.GT.S2) S1=S2
.tab stops 8 16
.skip 1
	PUSHJ	17,SESTRT
	STRNG	S1
	PUSHJ	17,SESTRT
	STRNG	S2
	PUSHJ	17,SKPSG
	JRST	.+4
	PUSHJ	17,SESTRT
	STRNG	S2
	SSTOR	S1
.skip 2
.fill
xv) Message typeout (DONE QUIT STOP PAUSE ACCEPT)
.paragraph
String constants are output to the terminal by the call
.skip 1
	CALL SFPRINT(<string-constant>)
.skip 2
SUMMARY OF CALLS GENERATED BY COMPILER
.skip 1
.nofill
.tab stops 25
Call	Meaning
.skip 1
STRNG S	concatenate S to top entry on stack
STRNGA S(X)	concatenate S(X) to top entry on stack
SSTOR S	store top stack entry into S
SSTORA S(X)	store top stack entry into S(X)
CALL SESTRT	start string expression
CALL LEFT(<ne>)	take left <ne> characters of top stack entry
CALL RIGHT(<ne>)	take right <ne> characters of top stack entry
CALL SUBSTR(<ne>1,<ne>2)	take substring of length <ne>1 starting
	at position <ne>2
CALL STR(<ne>)	generate string representation of <ne>
CALL CHAR(<ne>)	convert <ne> to a string
CALL DATE	generate date string
CALL MAX(n)	return maximum string of top n stack entries
CALL MIN(n)	return minimum string of top n stack entries
CALL ASC	return numeric representation of first
	character of top entry on stack
CALL IVAL	convert string to integer
CALL VAL	convert string to real
CALL DVAL	convert string to double precision
CALL CVAL	convert string to complex
CALL LENGTH	return length of top stack entry
CALL INDEX(<ne>)	determine position of one string in another
	starting at position <ne>
CALL SFRFS	formatted read with string expression as format
CALL SFWFS	formatted write with string expression as
	format
CALL STREL	string I/O item on string stack
CALL STRELA	unsubscripted string array as I/O item
CALL SFOPNS	open file name on stack
CALL SKPSE	skip if strings equal
CALL SKPSN	skip if strings unequal
CALL SKPSL	skip if strings less than
CALL SKPSG	skip if strings greater
CALL SKPSLE	skip if strings less than or equal
CALL SKPSGE	skip if strings greater than or equal
CALL SFPRINT	type string constant
.skip 2
OTHER STRING ROUTINES
.PARAGRAPH
Most of the string routines do not require knowledge of
the string stack structure or the internal representation
of strings.
They are
.left margin 5
.skip 1
.nofill
VAL, IVAL, DVAL, CVAL, STR
SFRFS, SFWFS, STREL, STRELA, SFOPNS, SFPRINT
DATE, CHAR, ASC, LENGTH, INDEX
MAX, MIN
SKPSE, SKPSN, SKPSL, SKPSG, SKPSLE, SKPSLE
.LEFT MARGIN 0
.fill
.paragraph
These routines Either scan entire stack entries or generate
a string which is concatenated to the top stack entry.
All references to the stack are through routines in the library.
The following is a complete set of entries for these string routines.
.skip 2
i) Length of stack entry n - CALL SSIZE(n)
.paragraph
Returns as its value the number of characters
in stack entry n.
.skip 2
ii) remove stack entry n - CALL SREMOVE(n)
.paragraph
Removes entry n from the string stack.
The LENGTH function could be written as
.skip 1
.nofill
N__SSIZE(1)
SREMOVE(1)
RETURN N
.skip 2
.fill
iii) Scan stack entry n - ISGET(P,N)  C__SGET(P)
.paragraph
The function ISGET is called to initialize the scan of the stack
entry n.
It returns in P, a pointer to the nth stack entry.
P must be an array of length 3.
The function SGET returns successive characters from the
string stack entry pointed to by P.
The end of the string is indicated by returning an EOLIT(000).
.skip 1
Example: Test if top two stack entries are equal
.skip 1
.nofill
LOCAL P1(3),P2(3)
ISGET(P1,1)
ISGET(P2,2)
WHILE C1__SGET(P1)=C2__SGET(P2)_#EOLIT THEN NULL
RETURN [C1=C2]
.fill
.skip 2
iv) Store into string - ISPUT(P,N) NSPUT(P,M) SPUT(P,C) S__ESPUT(P)
.paragraph
The function ISPUT tests whether stack entry n can be stored into.
Stack entries which can be stored into are single string scalar
or array references.
If the entry cannot be stored into, ISPUT returns false.
Otherwise, it returns true and stores into P a pointer to the string on the string stack.
The function NSPUT returns in P a pointer to a temporary string
variable large enough to store m characters.
The subroutine SPUT concatenates the character C to the string
pointed to by P.
THe pointer P is either the pointer returned by ISPUT or NSPUT.
To indicate THE end of the string, the function ESPUT is called.
It returns a string pointer for the new string which can then be put on
the string stack with the STRNG UUO.
.skip 1
.nofill
Example 1 - Set top entry to 'a' if possible
.skip 1
LOCAL P(3)
IF ISPUT(P,1) THEN DO
   SPUT(P,$A)
   S__ESPUT(P)
   SREMOVE(1)
END
.skip 1
Example 2 - The CHAR function
.skip 1
%CHAR(N)
LOCAL P(3)
NSPUT(P,1)
SPUT(P,N)
RETURN ESPUT(P)
.skip 2
STACK POINTER FORMAT
.paragraph
The stack pointer set by ISGET, ISPUT and NSPUT has the following format.
.skip 1
Word 1 - the address of the current item in the stack entry being
scanned or written.
.skip 1
Word 2 - a PDP-10 byte pointer. Points to the last character
read or written.
.skip 1
Word 3 - the number of characters remaining in the stack entry item pointed
to by word 1.
For ISGET, it is initialized to the length of the item on the stack
pointed to by word 1.
For ISPUT and NSPUT, it is initialized to the capacity of the string
being created.
 