TITLE MAGIC - MAGnetic tape Input output Cusp
SUBTTL	DONALD LEWINE - VERSION 1 - 2 JANUARY 1972

;***COPYRIGHT (C) 1971,1972, DIGITAL EQUIPMENT CORP., MAYNARD MASS. 01754


;AC'S

S=0		;FLAGS
T1=1		;TEMPS
T2=2		; ..
T3=3		; ..
T4=4		; ..
I=5		;GLOBAL INDEX  ***P1 IN SCAN***
J=6		;GLOBAL INDEX  ***P2 IN SCAN***
N=7		;HOLD A NUMBER
C=10		;HOLD A BYTE
P1=11		;PRESERVED
P2=12		; ..
P3=13		; ..
P4=14		; ..
C2=15		;FOR VERIFY
P=17		;STACK POINTER

;VERSION NUMBERS
VWHO==0		;WHO LAST EDITED THIS FILE
VMAGIC==1	;VERSION NUMBER
VMINOR==0	;MINOR VERSION NUMBER
VEDIT==154	;EDIT NUMBER

	TWOSEG
	LOC	137
	BYTE	(3)VWHO(9)VMAGIC(6)VMINOR(18)VEDIT
	RELOC	400000


;COMMENTING CONVENTION: ALL CODE ASSUMES AC I POINTS TO AN I-BLOCK
; SO BYTE POINTERS AND SUBROUTINES CAN USE I AS AN INDEX. ANY LINE
; WHERE THIS IS NOT TRUE IS FLAGGED WITH %.
;EXTERNALS IN SCAN

	EXT	<.ISCAN,.TSCAN,.VSCAN,.FILIN,.SWDEC,.SWOCT>
	EXT	<.SWSXM,.SWSIX,.SWMAX,.SWDPB,.NAME,.MKMSK>
	EXT	<.NAMEW,.NAMEC,.NOCTW,.NOCTC,.DECNW,.DECNC>
	EXT	<.OCTNW,.OCTNC,.SIXSW,.SIXSC,.SIXMW,.SIXMC>
	EXT	<.TIAUC,.TIALT,.TICAN,.TICHR,.TIMUC>
	EXT	<.FMSG,.FMSGN,.FMSGD,.FMSGO,.FMSGF,.FMSGE,.FMSGX,E.UKK>
	EXT	<.TFBLK,.TDIRB,.TDECW,.TOCTW,.TRDXW,.TPPNW,.TXWDW>
	EXT	<.TSIXN,.TCRLF,.TSTRG,.TCHAR>
	EXT	<.GTSPC,.POPJ,.POPJ1>

;EXTERNALS IN WILD

	EXT	<.LKWLD,E.DFL,.TFILE,.LKERR>

;MISC. INFORMATION

	JOBJDA==:75		;JOB DEVICE ASSIGNMENNTS
	JOBHCU==:72		;HIGHEST CHANNEL IN USE

	XALL
SUBTTL FLAGS

;AC S - L.H.

CPYFLG==1B0	;COPY COMMAND IS IN PROGRESS (AS OPPOSED TO VERIFY)
INPFLG==1B3	;INPUT SPEC
HVSFD==1B4	;1=HAVE SFD LOGIC IN MONITOR, 0=DON'T OR DON'T KNOW
NEWLIN==1B5	;WE ARE AT THE START OF A NEW LINE ON TTY:


;IO CHANNELS

;0-4 ARE USED BY SCAN AND WILD
TBL==5		;USED TO READ IN TRANSLATION TABLES
;6-17 ARE USED FOR FILE IO THUS 8 OUTPUT FILES MAY BE WRITTEN AT
; ONE TIME. (SEE LOWCHN)
SUBTTL	LUUOS FOR I/O

;THESE UUOS TRAP TO USER 40 AND EXECUTE A PUSHJ IN 41. THE LUUO
; IS TURNED INTO AN MUUO AND THE CHANNEL IS PUT IN IT. THEN THE
; MUUO IS EXECUTED AND CONTROL RETURNS TO THE CALLER. THIS ALLOWS
; UUOS TO BE DONE WITHOUT WORYING ABOUT CHANNELS

OPDEF	OPEN.	[10B8]
OPDEF	RENAM.	[15B8]
OPDEF	IN.	[16B8]
OPDEF	OUT.	[17B8]
OPDEF	STSTS.	[20B8]
OPDEF	STATO.	[21B8]
OPDEF	GTSTS.	[22B8]
OPDEF	STATZ.	[23B8]
OPDEF	INBUF.	[24B8]
OPDEF	OUTBF.	[25B8]
OPDEF	INPUT.	[26B8]
OPDEF	OUTPT.	[27B8]
OPDEF	CLOSE.	[30B8]
OPDEF	REL.	[31B8]
OPDEF	MTAPE.	[32B8]
OPDEF	UGETF.	[33B8]
OPDEF	USETI.	[34B8]
OPDEF	USETO.	[35B8]
OPDEF	LKUP.	[36B8]
OPDEF	ENTER.	[37B8]


;UUO HANDLER

UUO:	EXCH	S,.JBUUO	;SAVE S IN 40 AND PICK UP UUO
	TLO	S,(1B3)		;TURN INTO AN MUUO
	IOR	S,I.CHAN(I)	;PUT IN CHANNEL NUMBER
	XCT	S		;PERFORM THE UUO
	  JRST	.+2		;ERROR RETURN
	AOS	(P)		;GOOD RETURN
	MOVE	S,.JBUUO	;RESTORE FLAGS
	POPJ	P,		;RETURN
SUBTTL	DEFAULTS

ND	LN.DRB,6	;SFD NESTING LIMIT
ND	PDSIZE,100	;SIZE OF PDL
ND	LOWCHN,6	;FIRST CHAN FREE FOR FILE I/O
ND	EXPAND,1	;-1 LIST NO TABLES
			;0  LIST ONLY MACRO CALLS
			;+1 LIST ALL
ND	AD.VER,1	;DEFAULT NUMBER OF VERIFY PASSES
ND	FTSFD,-1	;INCLUDE SFD LOGIC (NOT MUCH CODE HERE BUT
			; GOOD DEAL IN SCAN AND WILD)
	;SWITCH DEFAULTS

DM	ALI,1,0,1		;/ALIGN
DM	BLK,3777,1,10		;/BLKSIZE
DM	BUF,^D20,2,10		;/BUFFERS
DM	BYT,^D36,^D36,7		;/BYTSIZE
DM	COS,0,0,0		;/COUNTOFFSET
DM	ELM,1B1,^D150,^D1500	;/ERRLIM
DM	ILL,0,"\","?"		;/ILLEGAL
DM	OFF,1B1,0,0		;/OFFSET
DM	LEO,76,2,2		;/LEOT
DM	LIN,1,0,1		;/LINEBLOCK
DM	PAD,1B1,0,136		;/PAD
DM	REC,1B18-1,^D80,200	;/RECSIZE
DM	SPA,1,0,1		;/SPAN
DM	TRI,1,0,1		;/TRIM

IFL	EXPAND	<XLIST>
SUBTTL 	MACROS FOR COMMAND SCANNER

;MACROS SIMILAR TO SL, SP, SS EXCEPT INSTEAD OF A BYTE POINTER TO
; THE RESULT THEY HAVE 2 ARGUMENTS. THE FIRST IS A WORD ADDRESS
; THE SECOND IS A MASK WITHIN THAT WORD. A BYTE POINTER IS COMPUTED
; FROM THE MASK

	DEFINE	SLM(NAME,RESULT,MASK,TABLE,DEFAULT)<
	X	NAME,TABLE'.T-1,<POINTR(RESULT,MASK)>,DEFAULT,-TABLE'.L
>

	DEFINE	SPM(NAME,RESULT,MASK,PROCESSOR,ABBR)<
	X	NAME,PROCESSOR,<POINTR(RESULT,MASK)>,PD.'ABBR,MX.'ABBR
>

	DEFINE	SSM(NAME,RESULT,MASK,VALUE)<
	X	NAME,0,<POINTR(RESULT,MASK)>,VALUE,0
>
SUBTTL SCANNER TABLES

	DEFINE	SWTCHS,<

	SPM	ALIGN,F.SWT2,F2.ALI,NBRSW,ALI
	SP	BACKFILE,,BACKFILE
	SP	BACKREC,,BACKREC
	SPM	BLKSIZE,F.SWT1,F1.BLK,NBRSW,BLK
	SPM	BUFFERS,F.SWT3,F3.BUF,NBRSW,BUF
	SPM	BYTESIZE,F.SWT1,F1.BYT,NBRSW,BYT
	SLM	CODE,F.SWT1,F1.COD,CODE,KC.ASC
	SP	COPY,,COPY
	SLM	COUNT,F.SWT2,F2.CNT,CONT,KN.PBY
	SP	COUNTBYTE,,COUNTBY
	SP	COUNTOFFSET,F.CNTO,FWSWTD,COS
	SLM	CRLF,F.SWT3,F3.CRL,CRLF,KR.CPY
	SLM	DENSITY,F.SWT3,F3.DEN,DENS,KD.800
	SP	EOF,,EOFSW
	SP	ERRLIM,F.ELIM,FWSWTD,ELM
	SLM	ERROR,F.SWT3,F3.ERR,ERRO,KE.CNT
	SP	ILLEGAL,F.ILLC,FWSWTD,ILL
	SP	INPUT,,INPCOM
	SLM	LABEL,F.SWT2,F2.LAB,LABL,KL.NON
	SPM	LEOT,F.SWT4,F4.LEO,NBRSW,LEO
	SPM	LINEBLOCK,F.SWT2,F2.LIN,NBRSW,LIN
	SLM	MODE,F.SWT3,F3.MOD,MODE,KM.IND
	SP	OFFSET,F.OFFS,FWSWTD,OFF
	SP	OUTPUT,,OUTCOM
	SP	PAD,F.PAD,FWSWTD,PAD
	SLM	PARITY,F.SWT2,F2.PAR,PARY,KP.ODD
	SLM	RECFMT,F.SWT1,F1.RFM,RFM,KF.UNF
	SPM	RECSIZE,F.SWT2,F2.REC,NBRSW,REC
	SP	RESET,,MAGIC
	SP	REWIND,,REWIND
	SP	SKIPEOT,,SKIPEOT
	SP	SKIPFILE,,SKIPFILE
	SP	SKIPREC,,SKIPRE
	SPM	SPAN,F.SWT2,F2.SPA,NBRSW,SPA
	SP	TABLE,,TABLE
	SLM	TABS,F.SWT1,F1.TAB,TAB,KT.COP
	SP	TEST,,MTEST
	SPM	TRIM,F.SWT2,F2.TRI,NBRSW,TRI
	SP	TYPE,,TYPCOM
	SP	UNLOAD,,UNLOAD
	SP	VERIFY,,VERIFY

>
;KEY-WORD VALUES

;/CODE

KEYS	CODE,<ASCII,BCD,BINARY,EBCDIC,INTEGER,SIXBIT>

KC.ASC==1
KC.BCD==2
KC.BIN==3
KC.EBC==4
KC.INT==5
KC.SIX==6

;/COUNT

KEYS	CONT,<DECMAL,MINUSB,MINUSW,PLUSBY,PLUSWO>

KN.DEC==1
KN.MBY==2
KN.MWD==3
KN.PBY==4
KN.PWD==5

;/CRLF

KEYS	CRLF,<ADD,COPY,DELETE>

KR.ADD==1
KR.CPY==2
KR.DEL==3
;/DENSITY

KEYS	DENS,<200,556,800>

KD.200==1
KD.556==2
KD.800==3


;/ERROR

KEYS	ERRO,<IGNORE,WARN,COUNT,ASK>

KE.IGN==1
KE.WRN==2
KE.CNT==3
KE.ASK==4

;/LABEL

KEYS	LABL,<COBOL,DEC10,OS360,NONE>

KL.COB==1
KL.DEC==0
KL.OS3==3
KL.NON==4
;/MODE

KEYS	MODE,<DEC,INDUSTRY>

KM.DEC==1
KM.IND==1

;/PARITY

KEYS	PARY,<EVEN,ODD>

KP.EVN==1
KP.ODD==2

;/RECFMT

KEYS	RFM,<FIXED,UNFORMAT,VARIABLE>

KF.FIX==1
KF.UNF==2
KF.VAR==3
;/TABS

KEYS	TAB,<ADD,COPY,DELETE,FORMAT>

KT.ADD==1
KT.COP==2
KT.DEL==3
KT.FOR==4

IFE	EXPAND	<XLIST>
	DOSCAN(MGC)
	XALL
IFE	EXPAND	<LIST>
SUBTTL	TRANSLATION TABLE

;TABLE CONSISTS OF 4  9-BIT BYTES. (2 LEFT FOR EXPANSION) THE TABLE
; IS INDEXED BY ASCII VALUE. EACH BYTE IS 1 8-BIT CHAR AND A FLAG
; BIT. IF THE FLAG IS A ZERO THEN THIS IS AN EXACT MATCH. IF THE FLAG
; IS A 1 THEN THE CHAR IS NOT EXACT. $$$ USED TO FLAG THESE BAD
; CASES.
;THE TABLE BETWEEN ASCII AND EBCDIC IS ONE TO ONE. FOR THOSE CHARS.
; WHICH IBM DOES NOT SPECIFY AN EXACT MATCH THE CHARS. ARE TRANSLATED
; TO UASCII-8 (THESE ARE ALWAYS OPEN IN THE EBCDIC SET). 
;UASCII-8 IS ASCII WITH BIT 7 TWICE IN THE FORM B7 B6 B7 B5 B4 B3 B2 B1


; COL 1 IS EBCDIC
; COL 2 IS BCDIC
; COL 3 IS BCD

DEFINE	TABLE	<
	X	00,$$$,$$,<NULL>
	X	01,$$$,$$,<SOH>
	X	02,$$$,$$,<STX>
	X	03,$$$,$$,<ETX>
	X	55,$$$,$$,<EOT>
	X	45,$$$,$$,<ENQ>
	X	46,$$$,$$,<ACK>
	X	47,$$$,$$,<BEL>
	X	22,$$$,$$,<BS>
	X	05,$$$,$$,<HT>
	X	37,$$$,$$,<LF>
	X	11,$$$,$$,<VT>
	X	12,$$$,$$,<FF>
	X	13,$$$,$$,<CR>
	X	14,$$$,$$,<SO>
	X	15,$$$,$$,<SI>
	X	16,$$$,$$,<DLE>
	X	17,$$$,$$,<DC1>
	X	18,$$$,$$,<DC2>
	X	19,$$$,$$,<DC3>
	X	60,$$$,$$,<DC4>
	X	61,$$$,$$,<NAK>
	X	50,$$$,$$,<SYN>
	X	38,$$$,$$,<ETB>
	X	24,$$$,$$,<CAN>
	X	25,$$$,$$,<EM>
	X	63,$$$,$$,<SUB>
	X	39,$$$,$$,<ESC>
	X	34,$$$,$$,<FS>
	X	29,$$$,$$,<GS>
	X	53,$$$,$$,<RS>
	X	54,$$$,$$,<UC>
	X	64,016,16,<SP>
	X	090,208,42,<!>
	X	127,$$$,15,<">
	X	123,123,26,<#>
	X	091,091,43,<$>
	X	108,108,63,<%>
	X	080,080,29,<&>
	X	125,$$$,12,<'>
	X	077,108,28,<(>
	X	093,076,60,<)>
	X	092,092,44,<*>
	X	078,080,48,<+>
	X	107,107,27,<,>
	X	096,096,32,<->
	X	075,075,59,<.>
	X	097,097,17,</>
	X	240,240,10,<0>
	X	241,241,01,<1>
	X	242,242,02,<2>
	X	243,243,03,<3>
	X	244,244,04,<4>
	X	245,245,05,<5>
	X	246,246,06,<6>
	X	247,247,07,<7>
	X	248,248,08,<8>
	X	249,249,09,<9>
	X	122,125,13,<:>
	X	094,094,46,<;>
	X	076,078,62,<LEFT ANG BRACKET>
	X	126,123,13,<=>
	X	110,126,14,<RIGHT ANG BRACKET>
	X	111,192,58,<?>
	X	124,124,47,<@>
	X	193,193,49,<A>
	X	194,194,50,<B>
	X	195,195,51,<C>
	X	196,196,52,<D>
	X	197,197,53,<E>
	X	198,198,54,<F>
	X	199,199,55,<G>
	X	200,200,56,<H>
	X	201,201,57,<I>
	X	209,209,33,<J>
	X	210,210,34,<K>
	X	211,211,35,<L>
	X	212,212,36,<M>
	X	213,213,37,<N>
	X	214,214,38,<O>
	X	215,215,39,<P>
	X	216,216,40,<Q>
	X	217,217,41,<R>
	X	226,226,18,<S>
	X	227,227,19,<T>
	X	228,228,20,<U>
	X	229,229,21,<V>
	X	230,230,22,<W>
	X	231,231,23,<X>
	X	232,232,24,<Y>
	X	233,233,25,<Z>
	X	187,077,61,<LEFT SQUARE BRACKET>
	X	188,110,30,<BACKSLASH>
	X	189,093,45,<RIGHT SQUARE BRACKET>
	X	095,109,$$,<CIRCUMFLEX(^) [CONVERTED TO LOGICAL NOT]>
	X	109,$$$,37,<LEFT ARROW [UNDERLINE]>
	X	224,124,$$,<REVERSE QUOTE>
	X	129,$$$,$$,<A (LOWER CASE)>
	X	130,$$$,$$,<B (LOWER CASE)>
	X	131,$$$,$$,<C (LOWER CASE)>
	X	132,$$$,$$,<D (LOWER CASE)>
	X	133,$$$,$$,<E (LOWER CASE)>
	X	134,$$$,$$,<F (LOWER CASE)>
	X	135,$$$,$$,<G (LOWER CASE)>
	X	136,$$$,$$,<H (LOWER CASE)>
	X	137,$$$,$$,<I (LOWER CASE)>
	X	145,$$$,$$,<J (LOWER CASE)>
	X	146,$$$,$$,<K (LOWER CASE)>
	X	147,$$$,$$,<L (LOWER CASE)>
	X	148,$$$,$$,<M (LOWER CASE)>
	X	149,$$$,$$,<N (LOWER CASE)>
	X	150,$$$,$$,<O (LOWER CASE)>
	X	151,$$$,$$,<P (LOWER CASE)>
	X	152,$$$,$$,<Q (LOWER CASE)>
	X	153,$$$,$$,<R (LOWER CASE)>
	X	162,$$$,$$,<S (LOWER CASE)>
	X	163,$$$,$$,<T (LOWER CASE)>
	X	164,$$$,$$,<U (LOWER CASE)>
	X	165,$$$,$$,<V (LOWER CASE)>
	X	166,$$$,$$,<W (LOWER CASE)>
	X	167,$$$,$$,<X (LOWER CASE)>
	X	168,$$$,$$,<Y (LOWER CASE)>
	X	169,$$$,$$,<Z (LOWER CASE)>
	X	251,$$$,$$,<LEFT CURLY BRACKET>
	X	079,$$$,$$,<VERTBAR>
	X	252,$$$,$$,<RIGHT CURLY BRACKET>
	X	253,$$$,$$,<TILDE>
	X	007,$$$,$$,<DELETE>
>
IFE	EXPAND	<XLIST>
	$==<$$==<$$$==777>>	;VALUE USED FOR "CAN NOT TRANSLATE"

DEFINE	X	(EBCDIC,BCDIC,BCD,COMMNT)<
	BYTE	(9)	EBCDIC,BCDIC,BCD,$$$	;COMMNT
>

	RADIX	10
UNITAB:	TABLE	;THE TABLE
	RADIX	8

	LIST
SUBTTL	TABLE FOR DOING A LOAD BYTE AND EXTEND (IN GENERAL)

	IFL	EXPAND,<XLIST>
	MASK==-1
	MSKTAB=.-1
	IFE	EXPAND,<XLIST>
	REPEAT	^D35,<	EXP	<MASK==<MASK_1>>>
	IFG	EXPAND,<PAGE>
	IFE	EXPAND,<LIST>
	BIT==^D35
	BITTAB=.-1
	IFE	EXPAND,<XLIST>
	SALL
	REPEAT	^D35,<	TXNE	C,<1B<BIT>>
	BIT==BIT-1>
	LIST
	PURGE	MASK,BIT

SUBTTL	MAIN ROUTINE


MAGIC:	TDZA	T1,T1		;% CLEAR OFFSET
	MOVEI	T1,1		;% STARTED AT C(.JBSA)+1
	RESET			;% CLEAR THE WORLD
	SETZ	S,		;% CLEAR FLAGS
	MOVE	P,[PUSHJ P,UUO]	;% GET INSTRUCTION FOR LUUO TRAP
	MOVEM	P,.JB41		;% INSTALL IN JOBDAT
	MOVE	P,[IOWD PDSIZE,PDL] ;% SET UP STACK
	SETZM	STZER		;% CLEAR CORE
	MOVE	T2,[STZER,,STZER+1] ;%  ..
	BLT	T2,ENDZER	;%  ..
	MOVEM	T1,SAOFST	;% STORE OFFSET
	MOVE	T1,[3,,[EXP 0	;% FIRE UP SCAN
			SAOFST,,'MGC'
			SCNTCH]]
	PUSHJ	P,.ISCAN	;%  ..
	MOVE	T1,[4,,[IOWD MGCL,MGCN
			XWD  MGCD,MGCM
			XWD  0,MGCP
			EXP  -1]]
	PUSHJ	P,.VSCAN	;% GO DO CUSP
	JRST	MAGIC		;% SHOULD NEVER HAPPEN
SUBTTL	INPUT/OUTPUT COMMANDS

OUTCOM:	TXZA	S,INPFLG	;% FLAG OUTPUT COMMAND
INPCOM:	TXO	S,INPFLG	;% FLAG INPUT COMMAND
	SKIPGE	C		;% END OF LINE?
	JRST	E.ARGR		;% YES--ERROR
	SKIPE	F.CHAN		;% SKIP IF FIRST COMMAND
	PUSHJ	P,FILLIN	;%  ELSE PLUG IN DEFAULTS
	MOVE	T1,[F.ZER,,F.ZER+1] ;% CLEAR ANSWER AREA
	SETZM	F.ZER		;%  ..
	BLT	T1,F.END	;%  ..
	PUSHJ	P,.FILIN	;% READ A FILSPC
	MOVEI	T1,F.DEV	;% POINT TO MY AREA
	MOVEI	T2,F.SWT1-F.DEV-1 ;% LENGTH
	PUSHJ	P,.GTSPC	;% COPY FROM SCAN
	RELEAS	LOWCHN,		;% RELEASE INPUT CHANNEL?
	MOVEI	T1,LOWCHN	;% PUT IN INPUT CHANNEL NUMBER
	TXNE	S,INPFLG	;% INPUT?
	JRST	GIVCHN		;% YES--USE LOWCHN
	MOVEI	T1,LOWCHN+1	;% NO--LOAD FIRST CHAN TO SCAN
	FRECHN	T1,		;% FIND A FREE CHAN
	  JRST	.+2		;% UUO NOT IMPLEMENTED
	JRST	GIVCHN		;% RETURN THE CHANNEL
	JUMPL	T1,E.NFIC	;% -1 MEANS NO FREE CHANNELS
	MOVEI	T1,LOWCHN+1	;% RESTORE T1
FRELP1:	MOVEI	T2,(T1)		;% COPY CHANNEL NUMBER
	DEVCHR	T2,		;% SEE IF INITED
	JUMPE	T2,GIVCHN	;% JUMP IF NOT INITED
	CAIGE	T1,17		;% SKIP IF LAST CHANNEL
	AOJA	T1,FRELP1	;% LOOP BACK FOR NEXT CHAN
E.NFIC:	M.FAIL	<No more I/O channels>
GIVCHN:	ROT	T1,-^D13	;% SPIN TO AC FIELD
	MOVEM	T1,F.CHAN	;% SAVE FOR UUOS
	SETZB	T1,T3		;% CLEAR 2 AC'S
	MOVE	T2,F.DEV	;% SET UP REST OF OPEN BLOCK
	MOVX	T4,FM.PHY	;% LOAD A SWITCH BIT
	TDNE	T4,F.MOD	;% PHYSICAL I/O REQUESTED?
	TXO	T1,UU.PHS	;% YES--LIGHT PHONLY BIT
	MOVE	T4,[OPEN T1]	;% LOAD A UUO
	IOR	T4,F.CHAN	;% FILL IN CHAN. NUMBER
	XCT	T4		;% OPEN CHAN FOR A WHILE
	  JRST	E.FOF		;% CAN NOT GET AT DEVICE
	MOVEI	T1,I.LEN	;% SIZE OF AN I-BLOCK
	PUSHJ	P,GETCOR	;% GET THE CORE
	MOVE	T2,T1		;% MOVE THE POINTER
	TXNN	S,INPFLG	;% INPUT?
	SKIPA	T1,[OUTLST]	;% NO--POINT TO OUTPUT LIST
	MOVEI	T1,INLST	;% YES--POINT TO INPUT LIST
;THERE SHOULD BE NO ERROR PATHS BETWEEN THIS POINT AND THE POPJ

LINKCB:	MOVEM	T2,F.IBLK	;% SET CROSS LINK
	MOVS	T3,T2		;% T3_ XWD .JBFF,0
	HRRI	T3,1(T2)	;% T3_ XWD .JBFF,.JBFF+1
	SETZM	(T2)		;% ZERO FIRST FREE
	BLT	T3,I.LEN-1(T2)	;%  AND REST OF I BLOCK
	SKIPN	T3,(T1)		;% T3_START OF LIST OR ZERO
	JRST	NEWCB		;% T3=0 NEW LIST SO JUST SET PNTR
	SKIPA			;% BUG FIX
	MOVEI	T3,(T1)		;% T3_ADDRESS OF CORE BLOCK
	SKIPE	T1,I.LINK(T3)	;% T1_ADDRESS OF NEXT BLOCK
	JRST	.-2		;% LOOP UNTIL END OF LIST
	MOVEM	T2,I.LINK(T3)	;% ADD ON NEW BLOCK
	POPJ	P,		;% RETURN
NEWCB:	MOVEM	T2,(T1)		;% SET UP LIST WITH 1 ENTRY
	POPJ	P,		;% RETURN
E.NMC:	M.FAIL	<No more core available>

E.NSD:	M.FAIN	<No device named>
E.ARGR:	M.FAIL	<Argument required>
SUBTTL TABLE SWITCH - READ IN A TRANSLATION TABLE

TABLE:	SKIPGE	C		;% SKIP IF NOT EOL
	JRST	E.ARGR		;% EOL--ERROR
	PUSHJ	P,.FILIN	;% READ A FILE SPEC.
	MOVEI	T1,TBLSPC	;% POINT TO  SPEC
	MOVEI	T2,TBSPSZ	;% LENGTH OF SPEC
	PUSHJ	P,.GTSPC	;% COPY SPEC
	SETZM	TBLTMP		;% CLEAR TMP WORD
	MOVE	T1,[4,,[XWD [TBLSPC],0
			XWD OPNBLK,LUBLK
			XWD TBSPSZ,6
			TBLTMP]]
	PUSHJ	P,.LKWLD	;% LOOK FOR DISK FILE
	  PUSHJ	P,NOTDSK	;% LOOK FOR NON-DISK FILE
	SETZM	OPNBLK		;% CAUSE ASCII MODE
	MOVEI	T1,TBLBHD	;% POINTER TO BUFFER HEADER
	MOVEM	T1,OPNBLK+2	;% STORE IN OPEN BLOCK
	OPEN	TBL,OPNBLK	;% INIT DEVICE FOR READING TABLE
	  JRST	E.DFO		;% CALL ERROR PROCESSOR
	PUSH	P,.JBFF		;% SAVE TOP OF CORE
	MOVEI	T1,TBLBUF	;% POINT TO TEMP BUFFER
	MOVEM	T1,.JBFF	;% STORE FOR UUOCON
	INBUF	TBL,1		;% SET UP THE BUFFER
	POP	P,C2		;GET BACK .JBFF
	MOVEM	C2,.JBFF	;% PUT IN PLACE
	SETO	I,		;% BUILD A DUMMY TABLE
	MOVEI	N,^D600		;% SIZE OF DUMMY
	MOVE	J,F.ILLC	;% GET THE /ILL: VALUE
	SKIPN	F.ILLC+1	;% WAS IT GIVEN?
	MOVE	J,[AD.ILL]	;% NO--MUST DEFAULT EARLY
	PUSHJ	P,SETMAX	;% GO BUILD
	MOVEM	C2,.JBFF	;% RESET .JBFF
	LOOKUP	TBL,LUBLK	;% FIND THE FILE
	  JSP	T1,LERCOD	;% PUT OUT A MESSAGE
	SETO	I,		;% SET HIGHEST ADDRESS IN TABLE
	PJRST	TBLOOP		;% GO BUILD TABLE

;HERE IF WILD CAN NOT DO THE JOB

NOTDSK:	MOVE	T1,TBLSPC	;% GET DEVICE NAME
	MOVEM	T1,OPNBLK+1	;% STORE FOR OPEN
	MOVE	T1,TBLSPC+1	;% GET FILE NAME
	MOVEM	T1,LUBLK	;% STORE FOR LOOKUP
	MOVE	T1,TBLSPC+2	;% GET EXT
	HLLZM	T1,LUBLK+1	;% STORE
	SETZM	LUBLK+3		;% CLEAR PPN
	POPJ	P,		;% RETURN
;HERE TO READ IN TABLE FROM FILE
; THE FILE IS OF THE FORM M,N<CR><LF>
; WHERE M IS TO BE TRANSLATED TO N
;
; THE FILE NEED NOT BE IN ANY SPECIAL ORDER AND ONLY 
; VALUES WHICH WILL BE CHANGED NEED BE INCLUDED.

TBLOOP:	PUSHJ	P,OCTTBL	;% READ AN OCTAL NUMBER
	JUMPL	C,TBCEOL	;% EOL? CHECK FOR EOF TOO.
	CAIE	C,","		;% PROPER DELIMITER?
	JRST	E.ITF		;% NO--ERROR
	MOVEI	J,(N)		;% COPY NUMBER
	ADD	J,.JBFF		;% CONVERT TO AN ADDRESS
	PUSHJ	P,OCTTBL	;% READ NEW VALUE
	JUMPGE	C,E.ITF		;% JUMP IF NOT EOL
	MOVEM	N,(J)		;% STORE IN TABLE
TBCEOL:	AOJE	C,TBLOOP	;% LOOP FOR MORE (-2 IS EOF)
	MOVE	T1,.JBFF	;% GET START OF TABLE
	HRRM	T1,F.TABL	;% STORE IN FILE SPEC
	HRLM	I,F.TABL	;% ALSO STORE SIZE
	ADDI	T1,1(I)		;% RESET JOBFF
	MOVEM	T1,.JBFF	;%  ..
	RELEAS	TBL,		;% FREE CHAN
	POPJ	P,		;% RETURN
;SUBROUTINE TO READ AN OCTAL NUMBER FROM TABLE FILE
;CALL WITH:
;	PUSHJ	P,OCTTBL
;	RETURN HERE WITH:
; C = SEPERATOR (-1 IF EOL, -2 IF EOF)
; N = OCTAL NUMBER
; ALL ELSE UNCHANGED

OCTTBL:	SETZ	N,		;% CLEAR RESULT
OCTINL:	PUSHJ	P,TBLIN		;% READ A CHAR
	CAIL	C,"0"		;% IS IT AN OCTAL
	CAILE	C,"7"		;%  DIGIT?
	JRST	TBCEOC		;% NO--SEE IF EOL
	LSH	N,3		;% MULT BY 8
	ADDI	N,-"0"(C)	;% ADD IN DIGIT
	JRST	OCTINL		;% LOOP FOR MORE
TBCEOC:	CAIL	C,15		;% <CR>?
	CAIG	C,14		;% <FF>?
	JRST	.+2		;% NO--JUST GIVE CHAR
	PUSHJ	P,TBLIN		;% YES--LOOK FOR LF
	CAIN	C,12		;% LINE FEED?
	SETO	C,		;% YES--RETURN -1
	POPJ	P,		;% GIVE BACK SEPERATOR

;SUBROUTINE TO GET NEXT CHAR FOR TABLE
;CALL WITH:
;	PUSHJ	P,TBLIN
;	RETURN HERE WITH:
; C = NEXT CHAR OR -2 IF EOF
;
TBLIN:	SOSG	TBLBHD+2	;% ANYTHING IN BUFFER?
	JRST	TBLFIL		;% NO--GO READ
TBLDB:	ILDB	C,TBLBHD+1	;% READ THE CHAR
	JUMPE	C,TBLIN		;% IGNORE NULLS
	CAIN	C,177		;% IF THIS IS A RUBOUT
	JRST	TBLIN		;%  IGNORE IT TOO.
	CAIE	C," "		;% ALSO FLUSH SPACES AND TABS
	CAIN	C,"	"	;%  ..
	JRST	TBLIN		;%  ..
	CAIN	C,"Z"-100	;% CONVERT ^Z TO INTERNAL
	HRROI	C,-2		;%  EOF MARK. (-2)
	POPJ	P,		;% RETURN
TBLFIL:	IN	TBL,		;% READ A BUFFER
	JRST	TBLDB		;% STORE
	  HRROI	C,-2		;% EOF RETURN -1
	POPJ	P,		;% RETURN
;SUBROUTINE TO ADJUST TOP OF TABLE
;CALL WITH:
;	MOVE	I,CURRENT-TOP-OF-TABLE
;	MOVE	N,NEW-TOP
;	MOVE	J,ILLEGAL-CHAR OR -1 IF NO FLAGING
;	PUSHJ	P,SETMAX
;	RETURN HERE WITH:
; I = N = HIGHEST ENTRY IN TABLE
; T1 = ADDRESS OF HIGHEST ENTRY IN TABLE
;
SETMAX:	CAIL	I,(N)		;% IS I .LT. N?
	HALT	.+1		;% NO--INTERNAL CONFUSION
	MOVEI	T1,(N)		;% COPY SIZE WE NEED
	PUSHJ	P,GETCOR	;% GET THE CORE
	MOVEM	T1,TBASE	;% SAVE THE TABLE BASE
	ADDI	T1,1(I)		;% POINT TO FIRST ENTRY TO FILL
SETLP:	ADDI	I,1		;% BUMP INDEX TO TABLE
	SKIPG	T2,J		;% LOAD ILL CHAR
	MOVE	T2,I		;% NONE--DON'T TRANSLATE
	MOVEM	T2,(T1)		;% STORE. THIS WILL PRESET THE TABLE
				;%  TO THE DEFAULT.
	CAIE	I,(N)		;% END OF TABLE?
	AOJA	T1,SETLP	;% NO--KEEP GOING
	POPJ	P,		;% YES--RETURN
SUBTTL FILL IN DEFAULT VALUES


FILLIN:	MOVE	I,F.IBLK	;POINT TO I-
	HRLZI	T1,F.ZER	;WERE WE ARE
	HRRI	T1,(I)		;WHERE WE ARE GOING
	BLT	T1,F.LEN-2(I)	;COPY THE STUFF

;COMPUTE /BYTESIZE

	LDB	T1,PM.BYT	;GET THE BYTESIZE MASK
	JUMPN	T1,FILL01	;JUMP IS EXPLICITLY TYPED
	LDB	T1,PM.COD	;GET THE CODE TYPE
	JUMPN	T1,GETCOD	;GET THE CODE

;HERE IF NO /BYTESIZE AND NO /CODE

	MOVEI	T1,AD.BYT	;GET THE DEFAULT BYTESIZE
	DPB	T1,PI.BYT	;SET IN I-BLOCK
	JRST	FILL01		;PLUG IN DEFAULT CODE

;HERE IF /CODE AND NO /BYTESIZE

GETCOD:	LDB	T1,PI.COD	;GT THE CODE
	MOVE	T1,[EXP 7,6,44,8,44,6]-1(T1) ;COMPUT BYTESIZE
	DPB	T1,PI.BYT	;STORE IN I-BLOCK

;HERE IF NO /CODE AND /BYTESIZE

FILL01:	MOVEI	T1,KC.BIN	;MUST BE BINARY
	DPB	T1,PI.COD	; SO STORE THAT
;COMPUTE /COUNTBYTE

FILL02:	LDB	T1,PI.CNT	;IS THERE A COUNT
	JUMPE	T1,FILL03	;JUMP IF NOT
	HRRZ	T2,F.SWM3	;GET THE COUNTBYTE
	JUMPN	T2,FILL03	;JUMP IF GIVEN
	HLRZ	T1,[POINT 35,0,35
		    POINT 18,0,17
		    POINT 18,0,17
		    POINT 18,0,35
		    POINT 18,0,35]-1(T1)
	HRRM	T1,I.SWT3(I)

FILL03:
	MOVSI	T4,-SWTLEN	;NUMBER OF WORDS TO BE DEFAULTED
DFLTLP:	MOVEI	T3,(T4)		;COPY INDEX
	LSH	T3,-1		;SAVE SPACE
	MOVE	T1,DFLTTB(T3)	;GET THE DEFAULT
	MOVEI	T2,(T4)		;GET INDEX INTO IBLOCK
	ADDI	T2,I.SWT1(I)	; ..
	ANDCM	T1,1(T2)	;MASK OUT SWITCHES GIVEN
	IORM	T1,(T2)		;STORE DEFAULTS
	AOBJP	T4,[HALT .]	;BUMP COUNT TO MASK
	AOBJN	T4,DFLTLP	;LOOP FOR ALL SWITCHES
	SKIPN	I.SWT1+1(I)	;ANY SWITCHES IN FIRST
	SKIPE	I.SWT2+1(I)	; OR SECOND GROUP?
	JRST	CHKALL		;YES--GO CHECK FOR ABSURD COMBINATIONS
	SKIPN	I.SWT3+1(I)	;HOW ABOUT WORD 3
	POPJ	P,		;ALL CLEAR

;HERE WITH ALL THE SWITCHES SET UP LOOK FOR ANY STRANGE COMBINATIONS
; IF THE EXIST FIX THEM BY:
;
;  1. SWITCHING SOME WE JUST SELECTED
;
;  2. GIVING THE USER A WARNING IF HE SAID 11 BIT ASCII OR SOMETHING
;      ELSE SILLY BUT GO TRY TO DO IT ANYWAY
;
;  3. IF USER ASKED FOR SOMTING WE CAN NOT DO (E.G. ADD CRLF
;      IN SIXBIT) CHANGE IT AND WARN USER.


CHKALL:	POPJ	P,		;DON'T YOU WISH I HAD CODE TO GO
				; UNDER THAT COMMENT.
;TABLE OF DEFAULTS (THIS MUST CORROSPOND TO THE SWITCHES IN THE I-BLOCK)

DFLTTB:	BYTE	(6)AD.BYT,KC.BIN(3)KT.COP,KF.UNF(18)AD.BLK
	BYTE	(18)AD.REC(1)AD.ALI,AD.LIN,AD.TRI(3)0(1)AD.SPA(2)KP.ODD(9)KL.DEC
	BYTE	(3)KE.CNT,0(6)AD.BUF(1)KM.DEC(2)KD.800(3)KR.CPY(18)0
	BYTE	(6)AD.LEO
	EXP	AD.OFF
	EXP	AD.PAD
	EXP	AD.ELM
	EXP	AD.COS
	EXP	AD.ILL

IF2,<	IFN	<<.-DFLTTB>*2-SWTLEN>,<
	PRINTX	DFLTTB DOES NOT MATCH THE I-BLOCK
	PRINTX	?FATAL ERROR - MAGIC WILL NOT RUN
>>
SUBTTL MAGNETIC TAPE OPERATIONS

;BACKFILE

BACKFI:	MOVEI	J,17
	JRST	MTAOP

;BACKRECORD

BACKRE:	MOVEI	J,7
	JRST	MTAOP

;EOF

EOFSW:	MOVEI	J,3
	JRST	MTAOP

;REWIND

REWIND:	MOVEI	J,1
	JRST	MTAOP

;SKIPEOF

SKIPEO:	MOVEI	J,10
	JRST	MTAOP

;SKIPFILE

SKIPFI:	MOVEI	J,16
	JRST	MTAOP

;SKIPRECORD

SKIPRE:	MOVEI	J,6
	JRST	MTAOP

;UNLOAD

UNLOAD:	MOVEI	J,11

;HERE WHEN WE WANT TO DO AN MTAPE UUO

MTAOP:	SETZ	N,		;% CLEAR RESULT
	SKIPL	C		;% SKIP IF EOL
	PUSHJ	P,.DECNW	;% GET A DECMAL WORD
	TLO	J,(MTAPE)	;% PUT IN OP CODE
	IOR	J,F.CHAN	;% PUT IN CHAN
	MOVE	T2,F.CHAN	;% PICK UP CHAN
	ROT	T2,^D13		;% SPIN BACK
	SKIPGE	JOBJDA(T2)	;% SEE IF INITED
	CAMLE	T2,JOBHCU	;%  ..
	JRST	E.IOUC		;% NOT INITED, GIVE UP
MTAXCT:	XCT	J		;% ELSE DO UUO
	SOJG	N,.-1		;%  N TIMES
	POPJ	P,		;% RETURN

E.IOUC:	DEVCHR	T2,
	JUMPN	T2,MTAXCT	;% JUMP IF MONITOR SAID REALY INITED
	M.FAIL	<No device open>
SUBTTL	COPY AND VERIFY COMMANDS

COPY:	TXOA	S,CPYFLG	;% INDICATE COPY COMMAND
VERIFY:	TXZ	S,CPYFLG	;% INDICATE VERIFY COMMAND
	MOVEI	N,AD.VER	;% GET DEFAULT VERSION NUMBER
	SKIPLE	C		;% SKIP IF EOL
	PUSHJ	P,.SWDEC	;% READ A NUMBER
	JUMPN	N,STOREV	;% ZERO PASSES?
	TXNN	S,CPYFLG	;% YES--/VERIFY?
	AOS	N		;% YES--IF /VERIFY MUST DO AT LEAST 1 PASS
STOREV:	MOVEM	N,VERCNT	;% COUNT OF PENDING VERIFY PASSES
	PUSHJ	P,FILLIN	;% FILL IN LAST SET OF DEFAULTS
PASS:	SKIPN	I,INLST		;I _ LIST OF INPUT SPECS
	JRST	E.NFI		;NO FILES FOR INPUT
NEXTI:	PUSHJ	P,SETWLD	;SCAN FOR A WILD CARD
	  JRST	DONEIN		;NO MORE SPECS
	PUSHJ	P,UOPEN		;OPEN THE FILE
	LDB	T1,P.TYPE	;GET DEVICE TYPE
	CAIE	T1,.TYMTA	;IS IT A MAG TAPE?
	JRST	LKUUO		;NO--GO DO A LOOKUP
	LDB	T1,PI.LAB	;GET LABEL TYPE
	CAIN	T1,KL.NON	;ANY LABEL?
	JRST	LKUUOK		;NO--GOOD RETURN (NOTHING DONE)
	M.FAIL	<IF MAGTAPE LABEL CODE EXISTED IT WOULD GO HERE>
LKUUO:	LOOKUP	LOWCHN,I.RIB(I)	;FIND THE FILE
	  JSP	T1,LERCOD	;OK DON'T FIND IT.
LKUUOK:	PUSHJ	P,UINBUF	;SET UP A BUFFER RING
	MOVEM	I,ISAVE		;SAVE THE CURRENT I-BLOCK
	SKIPN	OUTLST		;GET THE OUTPUT LIST
	JRST	E.NFO		;NO FILES FOR OUTPUT
	MOVEI	J,SETOUT	;DO THE OUTPUT SETUP CODE
	PUSHJ	P,RUNSUB	; FOR EACH OUTPUT TAPE
	MOVEI	J,PUT		;OUTPUT ROUTINE
IOLOOP:	PUSHJ	P,GET		;GET A CHAR
	  JRST	INEOF		;END OF FILE
	PUSHJ	P,RUNSUB	;DO THE OUTPUT
	JRST	IOLOOP		;LOOP FOR MORE
INEOF:	MOVEI	J,UCLOSE	;POINT TO CLOSE ROUTINE
	PUSHJ	P,RUNSUB	; AND DO IT FOR EACH OUTPUT TAPE
	CLOSE	LOWCHN,		;CLOSE OUT INPUT
	MOVE	I,ISAVE		;GET BACK INPUT I-BLOCK
	AOS	I.FILE(I)	;COUNT UP FILE NUMBER
	SKIPE	I.LMEM(I)	;SKIP IF ONLY 1 CAN MATCH
	JRST	NEXTI		;LOOK FOR ANOTHER FILE
DONEIN:	PUSHJ	P,CLEANI	;CLEAN UP AFTER FILE
	SKIPE	I,I.LINK(I)	;GET NEXT INPUT SPEC
	JRST	NEXTI		;LOOP FOR ALL ITS FILES
	MOVEI	J,CLEANI	;CLEAN ALL THE I-BLOCKS
	PUSHJ	P,RUNSUB	; FOR THE OUTPUT SIDE.
	TXZ	S,CPYFLG	;CLEAR COPY BIT
	SOSLE	VERCNT		;IS IT VERIFIED ENOUGH
	JRST	PASS		;NO--DO SOME MORE
	OUTSTR	[ASCIZ /FINAL SUMMARY
/]
	POPJ	P,		;TYPE ANOTHER /
SUBTTL SUBROUTINES FOR COPY AND VERIFY

;SUBROUTINE TO RETURN ANOTHER FILE NAME
;CALL WITH:
;	PUSHJ	P,SETWLD
;	  RETURN HERE IF NO MORE FILES
;	RETURN HERE WITH FILE 
;UPDATES I.RIB AND I.OPN
;

SETWLD:	PUSHJ	P,SAVE4		;SAVE P1 - P4
	SKIPGE	T1,I.LMEM(I)	;IS THIS A DECTAPE (1B0 SET)?
	PJRST	SCNDTA		;YES--GO LOOK FOR NEXT FILE
	MOVE	T1,[4,,ARGBLK]	;POINTER TO ARGUMENT
	MOVEI	T2,ARGBLK-1	;POINTER FOR STORING ARGUMENTS
	PUSH	T2,[P1,,0]	;POINTER TO POINTER TO FILE SPEC
	HRRI	T3,I.RIB(I)	;PLACE TO PUT LOOKUP INFO
	HRLI	T3,I.OPN(I)	;PLACE TO PUT OPEN INFO
	PUSH	T2,T3		;STORE POINTERS
	PUSH	T2,[ISPLEN,,RIBLEN] ;STORE LENGTHS
	MOVEI	T3,I.LMEM(I)	;POINTER TO MEMORY WORD
	PUSH	T2,T3		;STORE LAST ARGUMENT
	MOVEI	P1,I.DEV(I)	;SET IN A POINTER TO SPEC
	PUSHJ	P,.LKWLD	;SCAN THE STR
	  JRST	NOTSTR		;LOST--SEE WHY
IFN	FTSFD,<			;IF WE HAVE SFD LOGIC
	JUMPE	T1,.POPJ1	;IF NO PPN THEN NO SFD
	MOVS	T1,I.RIB+.RBPPN(I) ;PICK UP POINTER TO PATH
	TRNE	T1,-1		;IS IT A PATH?
	JRST	.POPJ1		;NO--ALL IS SET ALREADY
	HRRI	T1,I.PATH(I)	;PUT IN POINTER TO WHERE WE WANT PATH
	HRRZM	T1,I.RIB+.RBPPN(I) ;STORE FOR FILUUO
	BLT	T1,I.PATH+LN.DRB(I) ;MOVE THE PATH
>	;END CONDITIONAL ON FTSFD
	JRST	.POPJ1		;SKIP RETURN
;HERE IF WILD GAVE ERROR RETURN -- SEE IF FILE EXISTS SOMEPLACE ELSE

NOTSTR:	AOJE	T1,.POPJ	;JUMP IN STR BUT NO FILES MATCHED
	HLLZS	I.OPN(I)	;CLEAR ALL BUT PHONLY
	SETZM	I.OPN+2(I)	;CLEAR BUFFER ADDRESS
	MOVE	T2,I.DEV(I)	;PICK UP DEVICE NAME
	MOVEM	T2,I.OPN+1(I)	;SAVE FOR OPEN
	SETCM	P1,I.NAMM(I)	;GET COMPLEMENT OF MASK
	SETCM	P2,I.EXT(I)	; ..
	TRNN	P2,-1		;WILD EXT?
	JUMPE	P1,SET4WD	;NO--IF NOT WILD FILE SET UP
				; A 4 WORD LOOKUP BLOCK
	TXNN	T1,DV.DTA	;DEC TAPE?
	JRST	WILDND		;NO--WILD NON DIRECTORY
	MOVEI	T1,317		;ALMOST STANDARD MODE
	HRRM	T1,I.OPN(I)	;SET FOR OPEN
	PUSHJ	P,UOPEN		;OPEN THE CHAN
	USETI.	^D100		;POINT TO DIRECTORY
	MOVE	T1,[IOWD 177,TBLBUF] ;SET UP IOWD
	SETZ	T2,		;MARK END OF LIST
	INPUT.	T1		;READ THE DIRECTORY
	HRLI	T1,-^D22	;SIZE OF DIRECTORY

;FALL INTO SCNDTA
;HERE WITH DIRECTORY IN TBLBUF AND UPDATED AOBJN POINTER IN T1

SCNDTA:	MOVE	T3,TBLBUF+^D83(T1)	;GET FILE NAME
	MOVE	T4,TBLBUF+^D105(T1)	;GET EXTENSION
	HRLZ	T2,I.EXT(I)	;GET EXT MASK
	XOR	T3,I.NAM(I)	;SET DIFF BITS
	XOR	T4,I.EXT(I)	;SET A 1 IN EACH NON MATCH
	AND	T3,I.NAMM(I)	;ZERO BITS WE DONT CARE ABOUT
	AND	T4,T2		; ..
	IOR	T4,T3		;PUT THEM ALL TOGETHER
	AOBJP	T1,.+1		;POINT TO NEXT ENTRY
	MOVEM	T1,I.LMEM(I)	;SAVE IN CASE WE MATCHED
	JUMPE	T4,DMATCH	;JUMP IF MATCH
	JUMPL	T1,SCNDTA	;JUMP IF MORE
	POPJ	P,		;ERROR RETURN

;HERE WITH T1  CONTAINIG INDEX OF MATCHING FILE

DMATCH:	MOVE	T3,TBLBUF+^D82(T1)	;GET FILE
	HLLZ	T4,TBLBUF+^D104(T1)	;GET EXTENSION
;	DMOVEM	T3,I.RIB(I)	;IF YOU ONLY HAVE A KI-10
	MOVEM	T3,I.RIB(I)	;STORE FILE NAME
	MOVEM	T4,I.RIB+1(I)	;STORE EXTENSION
	SETZM	I.RIB+2(I)	;CLEAR PRIV STUFF
	SETZM	I.RIB+3(I)	;CLEAR PPN
	JRST	.POPJ1		;RETURN

WILDND:	;HERE ON A WILD SPECIFICATION FOR A NON-DIRECTORY DEVICE

;HERE TO SET UP FOR LOOKUP IF NOT DISK AND NO WILD-CARDS

SET4WD:	MOVE	T1,I.NAM(I)	;PICK UP NAME
	MOVEM	T1,I.RIB(I)	;STORE AWAY
	HLLZ	T1,I.EXT(I)	;PICK UP EXT
	MOVEM	T1,I.RIB+1(I)	;STORE AWAY
	SETZM	I.RIB+2(I)	;CLEAR PRIV WORD
	SETZM	I.RIB+3(I)	;CLEAR PPN
	JRST	.POPJ1		;SKIP RETURN
;SUBROUTINE TO OPEN AN IO CHANNEL
;CALL WITH:
;	PUSHJ	P,UOPEN
;	RETURN HERE OR BOMB
;
UOPEN:	MOVSI	T2,I.BUFH(I)	;POINT TO BUFFER HEADER
	SETZM	I.OPN+2(I)	;CLEAN UP AFTER WILD
	HRRZ	T3,I.OPN(I)	;GET DATA MODE
	CAIL	T3,.IODPR	;DUMP MODE?
	JRST	XCTOPN		;YES--DO NOT SET UP A RING
	LDB	T3,P.CHAN	;GET CHANNEL #
	CAILE	T3,LOWCHN	;T3 .GE. LOWCHN IMPLIES OUTPUT
	TXNN	S,CPYFLG	;SKIP IF COPY -- ELSE VERIFY AND WE MUST
				; READ THE FILE
	MOVSS	T2		;INPUT FILP AROUND
	MOVEM	T2,I.OPN+2(I)	;STORE FOR OPEN
	MOVEI	T2,.IOBIN	;ASSUME BINARY MODE
	HRRM	T2,I.OPN(I)	; ..
	MOVE	T2,I.OPN+1(I)	;GET DEVICE NAME
	DEVCHR	T2,		;GET THE CHAR BITS
	TXNN	T2,DV.M14	;CAN DEVICE DO BINARY
	HLLZS	I.OPN(I)	;NO--USE ASCII
XCTOPN:	OPEN.	I.OPN(I)	;OPEN THE CHANNEL
	  PJRST	E.DFO		;LOST
	LDB	T2,PI.BYT	;GET BYTE SIZE
	DPB	T2,[POINT 6,I.BPNT(I),11] ;SAVE BYTE SIZE

;FALL INTO DEVTYP CODE
;SUBROUTINE TO DO A DEVTYP UUO
;CALL WITH:
;	PUSHJ	P,UDVTYP
;	RETURN HERE WITH DEVTYP IN T1 AND I.TYPE(I)
;
UDVTYP:	LDB	T1,P.CHAN	;GET THE CHANNEL #
	DEVTYP	T1,		;DO THE DEVTYP
	  JRST	SIMDTY		;LOST -- GO SIMULATE
	MOVEM	T1,I.TYPE(I)	;STORE FOR LATER TESTS
	PJRST	USETST		;GO DO THE SETSTS UUO

;SIMULATE A DEVTYP UUO BUT ONLY DO WHAT WE NEED. ALSO DEVTYP MUST
;WORK IF DEVCE IS SPOOLED.

SIMDTY:	MOVE	T1,OPNBLK+1	;GET DEVICE NAME
	DEVCHR	T1,		;DO A DEVCHR
	MOVE	T2,T1		;SAVE RESULT
	TLZ	T1,777724	;WIPE OUT DEVICE BITS
	TXNN	T2,DV.DTA!DV.DSK	;DECTAPE OR DISK?
	TXOA	T1,TY.VAR	;NO--CAN BUILD OUR OWN BUFFERS
	TXO	T1,TY.MAN	;YES--MUST DO LOOKUP OR ENTER
	TLZ	T2,435044	;WIPE OUT NON DEVICE BITS
	JFFO	T2,.+1		;FIND THE DEVICE
	HRR	T1,[EXP -1,0,10,7,-1,-1,-1,6,-1,4,5,1,-1,2,3,-1,-1,-1](T3)
	MOVEM	T1,I.TYPE(I)	;STORE AS DEVTYP
	POPJ	P,


;FALL INTO SETSTS CODE
;SUBROUTINE TO DO A SETSTS FOR PARITY AND DENSITY AND AN MTAPE FOR MODE
;CALL WITH:
;	MOVEI	I,POINTER-TO-I-BLOCK
;	PUSHJ	P,USTSTS
;	RETURN HERE
;USES T1-T2
;
USETST:	LDB	T1,P.TYPE	;GET DEVICE TYPE
	CAIE	T1,.TYMTA	;MAG TAPE?
	POPJ	P,		;RETURN
	LDB	T1,PI.MOD	;GET MODE
	CAIN	T1,KM.DEC	;/MODE:DEC?
	SKIPA	T1,[100]	;YES--MTAPE 100
	MOVEI	T1,101		;NO--MTAPE 101
	MTAPE.	(T1)		;SET THE MODE
	GTSTS.	T1		;GET THE CURRENT STATUS
	MOVSI	T2,(1B0)	;FLAG FOR BOT
	TXNE	T1,IO.BOT	;ARE WE AT THE START?
	IORM	T2,I.FILE(I)	;YES--WE CAN GET BACK WITH A REWIND
	LDB	T2,PI.PAR	;GET THE PARITY
	CAIE	T2,KP.ODD	;ODD PARITY?
	TXO	T1,IO.PAR	;NO--TURN ON THE EVEN BIT
	LDB	T2,PI.DEN	;GET THE DENSITY
	LSH	T2,7		;SHIFT TO CORRECT BYTE
	IOR	T1,T2		;OR INTO UUO
	STSTS.	(T1)		;SET THE STATUS
	POPJ	P,		;RETURN
;SUBROUTINE TO SET UP AN N BUFFER RING
;CALL:
;	MOVE	I,ADDRESS-OF-I-BLOCK
;	PUSHJ	P,UINBUF
;	RETURN HERE (BOMBS IF NO MORE CORE)
;
UINBUF:	MOVE	T1,I.TYPE(I)	;GET DEVTYPE WORD
	TXNE	T1,TY.VAR	;CAN WE ROLL OUR OWN?
	PJRST	BUFCLC		;YES--GO DO SO
	MOVEI	T1,T2		;T1 POINTS TO T2
	GTSTS.	T2		;GET THE STATUS FOR DEVSIZ
	LDB	T3,P.CHAN	;GET THE CHANNEL NUMBER
	DEVNAM	T3,		;GET THE DEVICE INITED ON THAT CHANNEL
	  SETZ	T3,		;OOPS..
	LDB	T4,P.TYPE	;GET THE DEVICE TYPE
	MOVE	T4,[EXP 203,202,203,23,43,43,0,37,36,35,23,46](T4)
				;GET THE DEFAULT BUFFERSIZE
	DEVSIZ	T1,		;DO A DEVSIZ UUO TO GET BUFFER SIZE
	  MOVE	T1,T4		;FAILED--COPY DEFAULT
	HRRZ	T1,T1		;FLUSH THE DEFAULT NUMBER OF BUFFERS
	LDB	T2,PI.BUF	;GET NUMBER OF BUFFERS
	IMUL	T1,T2		;COMPUTE CORE REQUIRED
	HRLZM	T1,I.BUFA(I)	;STORE SIZE OF BUFFER
	PUSHJ	P,GETCOR	;GET THE CORE
	HRRM	T1,I.BUFA(I)	;STORE ADDRESS OF BUFFER
	EXCH	T1,.JBFF	;SAVE .JBFF AND POINT TO CORE
	LDB	T3,P.CHAN	;GET THE CHANNEL NUMBER
	CAIE	T3,LOWCHN	;INPUT CHANNEL?
	TXNN	S,CPYFLG	;VERIFY PASS?
	SKIPA	T3,[INBUF (T2)]	;YES--DO AN INBUF
	MOVSI	T3,(OUTBUF (T2));NO--DO AN OUTBUF
	IOR	T3,I.CHAN(I)	;PUT IN CHANNEL NUMBER
	XCT	T3		;DO THE UUO
	MOVEM	T1,.JBFF	;STORE BACK .JBFF
	POPJ	P,		;RETURN
;HERE TO GENERATE A BUFFER RING
BUFCLC:	PUSHJ	P,SAVE2		;SAVE P1 AND P2
	LDB	T1,PI.BYT	;T1_BYTE SIZE
	MOVEI	T3,^D36		;T3_WORD SIZE
	IDIVI	T3,(T1)		;T3_BYTES PER WORD
	LDB	T1,PI.BLK	;T1_BYTES PER BLOCK
	IDIVI	T1,(T3)		;T1_WORDS PER BLOCK
	MOVE	T3,T1		;SAVE BUFFER SIZE
	LDB	P1,PI.BUF	;GET NUMBER OF BUFFERS
	IMUL	T1,P1		;GET TOTAL CORE NEEDED
	PUSHJ	P,GETCOR	;GRAB IT
	MOVE	P2,T1		;COPY ADDRESS OF RING
	AOS	T1		;POINT TO LINK WORD
	MOVE	T4,T1		;ADDRESS OF LINK
	HRL	T4,T3		;SIZE OF BUFFER
BUFC1:	ADD	T4,T3		;POINT TO NEXT BUFFER
	MOVEM	T4,(T1)		;STORE THE LINK
	MOVE	T1,T4		;LINK AROUDN THE RING
	SOJG	P1,BUFC1	;LOOP FOR WHOLE RING
	SUB	T1,T3		;GET BACK TO LINK OF LAST BUFFER
	HRRI	T4,1(P2)	;PUT IN LINK TO FIRST BUFFER
	MOVEM	T4,(T1)		;STORE AWAY
	HRLI	T4,(1B0)	;SET THE VIRGIN BIT
	MOVEM	T4,I.BUFH(I)	;STORE IN BUFFER HEADER
	POPJ	P,		;RETURN
;SUBROUTINE TO SET UP FOR OUTPUT FILES
;CALL WITH:
;	MOVEI	I,I-BLOCK
;	PUSHJ	P,SETOUT
;	RETURN HERE
;
SETOUT:	SETZB	T1,I.OPN+2(I)	;CLER ADDRESS OF BUFFERS
	MOVSI	T2,(FM.PHY)	;SET UP PHYSICAL BIT
	TDNE	T2,I.MOD(I)	;IS IT SET?
	TXO	T2,UU.PHS	;YES--TRANSPOSE BIT
	MOVEM	T2,I.OPN(I)	;SAVE AWAY
	MOVE	T1,I.DEV(I)	;PICK UP DEVICE
	MOVEM	T1,I.OPN+1(I)	;STORE AWAY
	PUSHJ	P,UOPEN
	PUSHJ	P,UINBUF
	PUSHJ	P,SETTBL

;FALL INTO UENTER

;SUBROUTINE TO ENTER A FILE ON A DIRECTORY DEVICE
;CALL WITH:
;	PUSHJ	P,UENTER
;	RETURN HERE (OR FAIL)
;

UENTER:	JUMPGE	S,LKUP		;JUMP IF WE DID THIS ONCE
UENTR1:	MOVX	T1,TY.MAN	;GET THE MANDATORY BIT
	TDNN	T1,I.TYPE(I)	;DO WE NEED THE ENTER
	JRST	[SKIPN I.NAM(I)	;SKIP IF INFO GIVEN
		 POPJ  P,	;RETURN--DO NOT NEED ENTER AND NO NAME
		 JRST  .+1]	;GIVE ENTER SINCE HE TYPED A NAME
	PUSHJ	P,SAVE4		;YES--SAVE SOME ACS
	PUSHJ	P,SAVEIJ	;SAVE I AND J
	MOVE	J,ISAVE		;HAVE J POINT TO INPUT I BLOCK
	SETCM	T1,I.NAMM(I)	;T1 _ 1 FOR EACH BIT THAT HAS AN OUTPUT
				; FILE NAME WILD.
	HRLZ	T2,I.EXT(I)	;T2 _ 1 FOR EACH BIT THAT HAS AN OUTPUT
				; EXTENSION SPECIFIED
	SETCM	T3,T2		;T3 _ 1 FOR EACH WILD EXTENSION BIT.
	MOVE	P1,I.NAM(I)	;P1 GET THE OUTPUT NAME
	MOVE	P2,I.EXT(I)	;P2 GETS THE OUTPUT EXTENSION
	SETZB	P3,P4		;CLEAR P3-P4 PRIVS AND PATH
	AND	P1,I.NAMM(I)	;MASK OUT UNSPECIFIED BITS
	AND	P2,T2		;SAME WITH EXTENSION
	MOVE	T4,I.RIB(J)	;GET FIRST WORD OF LOOKUP BLOCK
	TLNN	T4,-1		;EXTENDED UUO
	SKIPA	T2,I.RIB+.RBNAM(J) ;YES--GET FILE NAME
	SKIPA	T2,I.RIB(J)	;NO--GET FILE NAME
	SKIPA	T4,I.RIB+.RBEXT(J) ;YES--GET EXTENSION
	MOVE	T4,I.RIB+1(J)	;NO--GET EXTENSION
	AND	T2,T1		;USE ONLY THOSE BITS WHICH WERE NOT
	AND	T4,T3		; SPECIFIED IN THE OUTPUT COMMAND
	IOR	P1,T2		;PUT TOGETHER THE PART HE TYPED AND
	IOR	P2,T4		; THE PART HE LEFT WILD.
	IFN	FTSFD,<		;DO WE HAVE SFD'S?
	PUSHJ	P,SETSFD	;YES--SET A PATH
>
	IFE	FTSFD,<		;DO WE HAVE SFD'S?
	MOVE	P4,I.DIR(I)	;NO--GET THE PPN
>
	LDB	T1,[<POINT WID(TY.DEV),I.TYPE(J),POS(TY.DEV)>]
	JUMPN	T1,UENTR2	;JUMP IF NOT A DISK
	MOVEI	T1,RIBLEN	;GET LENGTH OF I.RIB
	MOVEM	T1,I.RIB(I)	;STORE FOR FILUUO
	MOVEM	P1,I.RIB+.RBNAM(I) ;STORE FILENAME
	MOVEM	P2,I.RIB+.RBEXT(I) ;STORE EXTENSION
	MOVEM	P3,I.RIB+.RBPRV(I) ;STORE PRIV BITS
	MOVEM	P4,I.RIB+.RBPPN(I) ;STORE PPN
	MOVE	P1,I.RIB+.RBSPL(J) ;GET SPOOLED NAME
	MOVEM	P1,I.RIB+.RBSPL(I) ;STORE FOR NEW FILE
	MOVE	P1,I.RIB+.RBVER(J) ;GET VERSION NUMBER
	MOVEM	P1,I.RIB+.RBVER(I) ;STORE FOR NEW ENTER
	MOVE	P1,I.RIB+.RBSTS(J) ;GET THE STATUS WORD
	ANDI	P1,RP.NFS!RP.ABC ;MASK OUT BAD BITS
	MOVEM	P1,I.RIB+.RBSTS(I) ;STORE FOR ENTER
	MOVE	P1,I.RIB+.RBALC(J) ;GET SIZE OF INPUT
	MOVEM	P1,I.RIB+.RBEST(I) ;STORE AS ESTIMATED SIZE OF OUTPUT
	MOVE	P1,[ENTER I.RIB(I)]
	MOVEI	T1,P1+2
	IOR	P1,I.CHAN(I)	;PUT IN CHAN #
	XCT	P1		;ENTER THE FILE
	  JRST	LERCOD		;GIVE AN ERROR MESSAGE
	POPJ	P,		;RETURN
UENTR2:	MOVEM	P1,I.RIB(I)	;SAVE FILE NAME
	MOVEM	P2,I.RIB+1(I)	;SAVE EXTENSION
	TXNN	S,CPYFLG	;IS THIS A VERIFY PASS?
	SKIPA	T4,[LKUP. P1]	;YES--DO A LOOKUP NO AN ENTER.
	MOVE	T4,[ENTER. P1]	;SET UP ENTER
	XCT	T4		;DO THE UUO
	  JSP	T1,LERCOD	;WE HAVE JUST LOST
	POPJ	P,		;WE NOT ONLY COULD ENTER WE DID.

LKUP:	SKIPN	I.RIB(I)	;SKIP IF ALL SETUP
	JRST	UENTR1		;NOT SETUP MUST BE VERIFY
	LKUP.	P1		;LOOKUP THE FILE
	  JSP	T1,LERCOD	;WE LOST
	POPJ	P,
;SUBROUTINE TO SET A PATH IN P4
;CALL WITH:
;	MOVEI	I,I-BLOCK
;	PUSHJ	P,SETSFD
;	RETURN HERE
;
	IFN	FTSFD,<		;ONLY NEEDED IF SFD LOGIC
SETSFD:	MOVE	P4,I.DIR(I)	;SET UP A PPN
	SKIPN	I.DIR+2(I)	;DO WE NEED SFD LOGIC?
	POPJ	P,		;NO--ALL DONE
	TXNE	S,HVSFD		;SKIP IF FIRST SFD OF THE DAY
	JRST	SETSF0		;NO--WE KNOW WE HAVE SFD'S
	SETOM	I.PATH(I)	;ASK FOR DEFAULT PATH
	MOVSI	T1,4		; ..
	HRRI	T1,I.PATH(I)	; ..
	PATH.	T1,		; ..
	  JRST	E.NSFD		;NO SFD LOGIC
	TXO	S,HVSFD		;SAY WE HAVE SFD'S
SETSF0:	MOVEI	P4,I.PATH(I)		;POINT TO PATH
	MOVEI	T1,I.DIR(I)	;REAL DIRECTORY
	MOVSI	T2,-LN.DRB	;-VE LENGTH
	HRRI	T2,I.PATH;2(I)	;POINT TO PLACE FOR PATH
STSFD1:	MOVE	T3,(T1)		;GET WORD
	MOVEM	T3,(T2)		;STORE FOR LATER
	ADDI	T1,2		;POINT TO NEXT SFD
	AOBJN	T2,STSFD1	;LOOP FOR WHOLE PATH
	POPJ	P,		;RETURN

E.NSFD:	M.FAIL	<MONITOR DOES NOT SUPPORT SFD'S>

>
;SUBROUTINE TO CLOSE A CHANNEL
;CALL WITH:
;	MOVEI	I,I-BLOCK
;	PUSHJ	P,UCLOSE
;	RETURN HERE
UCLOSE:	CLOSE.
	AOS	I.FILE(I)	;COUNT THE FILE
	POPJ	P,
;SUBROUTINE TO CLEAN UP AN I-BLOCK AFTER A  FILE TRANSFER OR VERIFY
; TO PREPARE FOR THE NEXT VERIFY PASS
;CALL WITH:
;	PUSHJ	P,CLEARI
;	RETURN HERE
;
CLEANI:	LDB	T1,P.TYPE	;GET DEVTYP
	CAIE	T1,.TYMTA	;MAG TAPE?
	JRST	CLRI2		;NO--NO NEED TO REPOSITION
	MOVE	T1,I.FILE(I)	;GET THE FILE COUNT
	SKIPL	T1		;SKIP IF STARTED AT START
	SKIPA	T2,[17]		;NO--MUST DO N BACKFILES
	MOVEI	T2,1		;YES--DO A REWIND
	MTAPE.	(T2)		;REPOSITION THE TAPE
	SOJG	T1,.-1		;LOOP FOR ALL FILES
CLRI2:	SETZM	I.ZER1(I)	;FIRST WORD TO CLEAR
	HRRZI	T1,I.ZER1+1(I)	;ADDRESS OF NEXT WORD
	HRLI	T1,-1(T1)	;MAKE A BLT POINTER
	BLT	T1,I.EZER(I)	;CLEAR I-BLOCK
	POPJ	P,		;RETURN FROM WHENCE WE CAME ...
;SUBROUTINE TO RUN SOME OTHER SUBROUTINE ONCE FOR EACH OUTPUT
; FILE
;CALL WITH:
;	MOVEI	J,ROUTINE-TO-RUN
;	PUSHJ	P,RUNSUB
;
RUNSUB:	PUSH	P,I		;SAVE I
	MOVE	I,OUTLST	;POINT TO LIST OF OUTPUT SPECS
	PUSH	P,J		;SAVE J
	PUSHJ	P,@(P)		;CALL ROUTINE
	  JFCL
	SKIPE	I,I.LINK(I)	;GET NEXT I BLOCK
	JRST	.-3		;RUN SUB AGAIN
	POP	P,J		;RESTORE J
	JRST	IPOPJ		;RESTORE I AND RETURN
SUBTTL	ROUTINES TO SET UP CONVERSION TABLES


	IFL	EXPAND	<XLIST>

	DEFINE	M.CNVT,<

;TO___	ASCII	BCD	BINARY	EBCDIC	INTEGER	SIXBIT
X	.POPJ,	ASCBCD,	E.CONV,	ASCEBC,	E.CONV,	ASCSIX	;ASCII
X	BCDASC,	.POPJ,	E.CONV,	BCDEBC,	E.CONV,	BCDSIX	;BCD
X	BINASC,	BINBCD,	.POPJ,	BINBCD,	.POPJ,	BINSIX	;BINARY
X	EBCASC,	EBCBCD,	E.CONV,	.POPJ,	E.CONV,	EBCSIX	;EBCDIC
X	BINASC,	BINBCD,	.POPJ,	BINBCD,	.POPJ,	BINSIX	;INTEGER
X	SIXASC,	SIXBCD,	E.CONV,	SIXEBC,	E.CONV,	.POPJ	;SIXBIT
							;^ FROM ^
>

	DEFINE	X(A,B,C,D,E,F),<
	XWD		A,B
	XWD	C,D
	XWD	E,F
	>

	IFE	EXPAND	<XLIST>
	XALL
CNVTBL:	M.CNVT
	SALL
	LIST
;SUBROUTINE TO BUILT A TRANSLATION TABLE
;
SETTBL:	SKIPE	I.TABL(I)	;WAS A TABLE GIVEN?
	POPJ	P,		;YES--THAT WILL WIN THEN
	PUSHJ	P,SAVEIJ	;SAVE I AND J
	MOVE	J,ISAVE		;J IS POINTER TO INPUT SPEC
	LDB	T1,[<POINT WID(F1.COD),I.SWT1(J),POS(F1.COD)>]
	MOVEI	T3,-1(T1)	;ADJUST ORIGIN
	IMULI	T3,6		;SELECT ROW
	LDB	T2,PI.COD	;GET OUTPUT CODE
	ADDI	T3,-1(T2)	;SELECT ENTRY
	ROT	T3,-1		;DIVIDE BY 2
	MOVE	T4,CNVTBL(T3)	;GET THE CORRECT DISPATACH ADDRESS
	JUMPL	T3,(T3)		;JUMP IF IN R.H.
	MOVS	T4,T4		;FLIP AROUND
	JRST	(T4)		;GO TO IT
;HERE TO CONVER ASCII TO BCD OR EBCDIC

ASCBCD:	SKIPA	T4,BCDPTR	
ASCEBC:	MOVE	T4,EBCPTR
	MOVEI	N,^D128			;SIZE OF ASCII CODE
	PUSHJ	P,ALCTBL	;ALLOCATE THE TABLE
	MOVSI	T1,-^D128	;SIZE OF UNITAB
	HRRZ	T2,I.TABL(I)	;LOCAATION OF OUTPUT TABLE
ASCEB1:	LDB	N,T4		;GET A BYTE
	MOVEM	N,(T2)		;STORE IN TABLE
	AOBJP	T1,.POPJ	;RETURN IF DONE
	AOJA	T2,ASCEB1	;NOT DONE KEEP GOING
;HERE TO CONVERT EBCDIC OR BCD TO ASCII


BCDASC:	MOVE	T4,BCDPTR	 ;BYTE POINTER TO UNITAB
	MOVEI	N,^D64		;SIZE OF INPUT SET
	JRST	MKASTB		;CONVERT

EBCASC:	MOVE	T4,EBCPTR	;BYTE POINTER TO UNITAB
	MOVEI	N,^D256	;SIZE OF INPUT
MKASTB:	PUSHJ	P,ALCTBL	;BUILD A TABLE
	MOVSI	T1,-^D128	;SIZE OF UNITAB
	MOVE	T2,I.TABL(I)	;ADDRESS OF TABLE
	HRLI	T2,T3		;PUT IN AN AC FIELD FOR @
MKATB1:	LDB	T3,T4		;GET A CHAR
	CAIE	T3,$$$		;IS IT LEGAL?
	HRRZM	T1,@T2		;YES--THE TABLE ENTRY FOR THE C(T3)'RD
				; CHARACTER IN THE INPUT CODE IS C(T1)
	AOBJN	T1,MKATB1	;LOOP FOR THE WHOLE TABLE
	POPJ	P,		;RETURN
;HERE IF OUTPUT IS SIXBIT

BINSIX:	PUSHJ	P,BINASC	;FIRST CONVERT TO ASCII
	JRST	ASCSIX		;THEN CONVERT TO SIXBIT
BCDSIX:	PUSHJ	P,BCDASC	;FIRST CONVERT TO ASCII
	JRST	ASCSIX		;THEN MAKE SIXBIT
EBCSIX:	PUSHJ	P,EBCASC	;FIRST CONVERT TO ASCII
ASCSIX:	MOVNI	T1," "		;ADJUST THE /OFFSET FOR
	ADDM	T1,I.OFFS(I)	; SIXBIT CONVERSION
	POPJ	P,		;RETURN
;HERE TO CONVERT BCD TO EBCDIC OR EBCDIC TO BCD

BCDEBC:	PUSHJ	P,SAVE4		;SAVE THE WORLD
	MOVEI	N,^D64		;SIZE OF INPUT CODE
	MOVE	P1,BCDPTR	 ;POINTER TO INPUT CODE
	MOVE	P2,EBCPTR	;POINTER TO OUTPUT CODE
	JRST	MKTABL		;GO BUILD TABLE

EBCBCD:	PUSHJ	P,SAVE4		;SAVE THE P'S
	MOVEI	N,^D256		;SIZE OF EBCDIC
	MOVE	P1,EBCPTR	;POINTER TO INPUT CODE
	MOVE	P2,BCDPTR	

MKTABL:	MOVNI	P4,(N)		;SAVE SIZE OF TABLE
	HRLZI	P4,(P4)		;CONVERT TO AOBJN POINTER
	PUSHJ	P,ALCTBL	;ALLOCATE THE TABLE
	MOVSI	P3,(POINT 36,0(T1))	;BUILD A POINTER TO OUTPUT
	HRR	P3,I.TABL(I)	; ..
MKTBL1:	MOVSI	T1,-^D128	;SIZE OF UNITAB
	LDB	T3,P1		;GET BYTE FROM INPUT TABLE
	CAIN	T3,(P4)		;MATCH?
	JRST	[LDB	T3,P2	;GET OUTPUT BYTE
		 DPB	T3,P3	;STORE
		 JRST	MKTBL2]	;FIND NEXT CHAR
	AOBJN	T1,.-3		;LOOP
MKTBL2:	AOBJN	P4,MKTBL1	;LOOP
	POPJ	P,
;SUBROUTINE TO ALLOCATE SPACE FOR A TRANSLATION TABLE
;CALL WITH:
;	MOVE	N,SIZE
;	PUSHJ	P,ALCTBL
;	HERE WHEN DONE (WILL BOMB OUT IF NO MORE CORE)
;
ALCTBL:	PUSH	P,I		;SAVE I
	SETO	I,		;% HIGHEST ENTRY IN TABLE
	PUSHJ	P,SETMAX	;% GO BUILD THE TABLE
	HRL	N,TBASE		;% LH=ADDRESS OF TABLE
	POP	P,I		;PUT BACK I
	MOVSM	N,I.TABL(I)	;STORE TABLE POINTER
	POPJ	P,		;RETURN
;HERE TO CONVERT SIXBIT TO SOMETHING

SIXEBC:	PUSHJ	P,ASCEBC	;WILL CONVERT FROM ASCII
	JRST	SIXASC		;GO MAKE ASCII

SIXBCD:	PUSHJ	P,ASCBCD	;WILL CONVERT FROM ASCII

SIXASC:	MOVEI	T1,[ADDI	C," "
		    POPJ	P,]
	MOVEM	T1,I.CONV(I)	;STORE FOR RUN TIME
	POPJ	P,		;RETURN
;HERE TO CONVERT BINARY FILES TO GRAPHIC CODES

BINBCD:	PUSHJ	P,ASCBCD	;CONVERT TO BCD (SAME AS EBCDIC FOR NUMBERS)

BINASC:	MOVEI	T1,BN2ASC	;ADDRESS OF CONVERTER
	MOVEM	T1,I.CONV(I)	;STORE FOR LATER
	POPJ	P,		;RETURN

;SUBROUTINE TO CONVERT A BINARY WORD TO ASCII
;CALL WITH:
;	MOVE	C,WORD-TO-OUTPUT
;	PUSHJ	P,BN2ASC
;	RETURN HERE ONCE FOR EACH ASCII CHAR. THEN UP 1 LEVEL
;
BN2ASC:	EXCH	P1,(P)		;P1 _ RETURN ADDRESS AND P1 IS SAVED
	PUSH	P,T2		;SAVE T2
	PUSH	P,C		;SAVE C
	MOVEI	C," "		;BLANK BETWEEN WORDS
	PUSHJ	P,(P1)		;CALL OUTPUT ROUTINE
	MOVEI	T1,BN2AS3	;PLACE TO RETURN
	EXCH	T1,(P)		;PUT ON STACK -- GET NUMBER BACK
BN2AS2:	IDIVI	T1,10		;CONVERT TO OCTAL
	HRLM	T2,(P)		;STORE IN STACK
	SKIPE	T1		;SKIP IF DONE
	PUSHJ	P,BN2AS2	;RECURSE
	HLRZ	C,(P)		;POP OFF A DIGIT
	ADDI	C," "		;CONVER TO ASCII
	PJRST	(P1)		;CALL FOR OUTPUT

BN2AS3:	POP	P,T2		;RESTORE T2
	POP	P,P1		;RESTORE P1
	POPJ	P,		;RETURN

SUBTTL 	INPUT OUTPUT SUBROUTINES

GET:	PUSHJ	P,GETC		;GET A CHAR
	  POPJ	P,		;END OF FILE RETURN
	PUSH	P,T1		;SAVE T1
	SKIPE	T1,I.CONV(I)	;ANY CONVERSION ROUTINES?
	PUSHJ	P,(T1)		;YES--DO THEM
	SKIPE	T1,I.TABL(I)	;ANY TABLE?
	PUSHJ	P,TBLOOK	;YES DO THEM
	ADD	C,I.OFFS(I)	;ADD IN OFFSET
	JRST	TPOPJ1		;RETURN--ANSWER IN C

GETC:	SOSLE	I.BCNT(I)	;ANYTHING IN BUFFER?
	JRST	GETC1		;YES--GET THE BYTE
	PUSHJ	P,READ		;NO--FILL A BUFFER
	  POPJ	P,		;END OF FILE
GETC1:	ILDB	C,I.BPNT(I)	;GET A BYTE
	AOS	I.CHCT(I)	;BUMP THE BYTE COUNT
	JRST	.POPJ1		;RETURN
READ:	AOS	I.RCNT(I)	;BUMP THE RECORD COUNT
	IN.			;READ THE RECORD
	  JRST	.POPJ1		;SUCCESS RETURN
IOERR:	PUSHJ	P,SAVE2		;SAVE P1 P2
	PUSH	P,T1		;SAVE T1
	GTSTS.	N		;GET THE FILE STATUS
	MOVE	P2,T2		;SAVE T2 INCASE IT IS CLOBBERED
	TXNE	N,IO.ERR	;LOSSAGE?
	PUSHJ	P,E.IOER	;IO ERROR CONTROL
	MOVE	T2,P2		;GET T2 BACK
	HRR	P1,N		;COPY ERROR BITS
	TXZ	P1,IO.ERR!IO.EOF;TURN OFF ERROR FLAGS
	STSTS.	(P1)		;CLEAR THE ERROR BITS
	TXNE	N,IO.EOF	;END OF FILE?
TPOPJ:	POP	P,T1		;YES--RESTORE T1 AND
	POPJ	P,		;NON-SKIP RETURN
TPOPJ1:	POP	P,T1		;PUT BACK T1
	JRST	.POPJ1		;SKIP RETURN
PUT:	PUSH	P,T1		;SAVE T1
	SKIPE	T1,I.CONV(I)	;ANY CONVERSION ROUTINE
	PUSHJ	P,(T1)		;YES--GO CALL IT
	SKIPE	T1,I.TABL(I)	;ANY TABLE?
	PUSHJ	P,TBLOOK	;YES--CONVERT
	POP	P,T1		;GET T1 BACK
	ADD	C,I.OFFS(I)	;ADD IN OFFSET
PUTC:	JUMPL	S,PUT1		;JUMP IF COPY
	SOSLE	I.BCNT(I)	;ANYTHING IN BUFFER
	JRST	COMPCH		;COMPARE THE BYTES
	PUSHJ	P,READ		;GET A NEW BUFFER
	  JRST	VEREOF		;END OF FILE ERROR
COMPCH:	ILDB	C2,I.BPNT(I)	;GET THE CHAR
	AOS	I.CHCT(I)	;COUNT THE CHAR
	CAMN	C,C2		;ARE THEY THE SAME?
	POPJ	P,		;YES--RETURN
	AOS	I.ECNT(I)	;COUNT UP ERROR COUNT
	SOSL	I.ELIM(I)	;COUNT DOWN ERROR LIMIT
	POPJ	P,		;RETURN IF NO TOO MANY ERRORS
	M.FAIL	<TOO MANY VERIFY ERRORS>
VEREOF:	M.FAIL	<FILE1 NOT SAME SIZE AS FILE 2>
PUT1:	SOSLE	I.BCNT(I)	;ROOM IN BUFFER
	JRST	PUTC1		;YES--GO SHOVE IT IN.
	PUSHJ	P,WRITE		;NO--MAKE ROOM
	  HALT	.		;DON'T YOU SEE THE JRST TPOPJ1
PUTC1:	IDPB	C,I.BPNT(I)	;YES--STORE IN BUFFER
	AOS	I.CHCT(I)	;COUNT THE BYTE
	POPJ	P,		;RETURN
WRITE:	AOS	I.RCNT(I)	;COUNT UP RECORD COUNT
	OUT.			;WRITE THE RECORD
	  JRST	.POPJ1		;SKIP RETURN
	PJRST	IOERR		;TRANSMITTION ERROR
;SUBROUTINE TO USE A CONVERSION TABLE
;CALL WITH:
;	MOVE	T1,[+LENGTH,,TABLE]
;	MOVE	C,CHAR
;	PUSHJ	P,TBLOOK
;	HERE WITH CHAR IN C
;
TBLOOK:	PUSH	P,T2		;SAVE T2
	HLRZ	T2,T1		;COPY LIMIT
	ADD	T1,C		;POINT TO ENTRY
	CAMLE	C,T2		;IS IT TOO BIG
	SKIPA	C,I.ILLC(I)	;YES--FLAG
	MOVE	C,(T1)		;NO-CONVERT
	POP	P,T2		;RESTORETT2
SUBTTL READ SWITCHES

;SUBROUTINE TO READ A FULL WORD DECMAL SWITCH AND SET A MASK
;CALLED FROM SCAN

FWSWTD:	SETZ	N,		;% CLEAR RESULT
	SKIPL	C		;% SKIP IF EOL
	PUSHJ	P,.SWDEC	;% READ IN A DECMAL NUMBER
	SKIPN	T1,@1(J)	;% PICK UP POINTER TO RESULT
	HALT	.		;% CONFUSION
	MOVEM	N,(T1)		;% STORE RESULT
	SETOM	1(T1)		;% SET A MASK
	POPJ	P,		;% RETURN


;SUBROUTINE TO READ IN A NUMERIC SWITCH
;CALLED FROM SCAN

NBRSW:	PUSHJ	P,.SWDEC	;% READ THE NUMBER
	JUMPG	N,.SWMAX	;% STORE IF POSITIVE
	LDB	T1,[POINT 6,@1(J),11] ;% GET BYTE SIZE
	CAIL	T1,44		;% IF MORE THAN 1 WORD OK
	JRST	.SWMAX		;%  ..
	SETO	T2,		;% ELSE MAKE A MASK
	SUBI	T1,44		;% FIX FOR LSH
	LSH	T2,(T1)		;% ADJUST MASK
	AND	N,T2		;% MASK OUT EXTRA ONES
	PJRST	.SWMAX		;% STORE
;SUBROUTINE TO READ ARGUMENT OF COUNTBYTE SWITCH
;CALLED FROM SCAN

COUNTB:	JUMPL	C,E.ARGR	;% IF NO ARGUMENT THEN ERROR
	PUSH	P,I		;% SAVE I - IT IS P1 IN SCAN
	MOVEI	I,F.ZER		;% POINT TO F-BLOCK
	PUSHJ	P,.TIAUC	;% EAT A CHAR
	MOVEI	T1,"<"		;% EXPECTED CHAR
	PUSHJ	P,CHKCHR	;% CHEACK FOR MATCH ELSE BOMB
	PUSHJ	P,.SWDEC	;% READ THE POSITION
	JUMPL	N,E.WNBP	;% MUST BE POSITIVE
	CAIL	C,45		;% AND FIT IN A WORD
	JRST	E.WNBP		;% TOO BIG -- ERROR
	MOVEI	T1,","		;% LOAD A ,
	PUSHJ	P,CHKCHR	;% MAKE SURE WE HAVE CORRECT SEPERATOR
	DPB	N,PI.CNP	;% STORE
	PUSHJ	P,.SWDEC	;% GO READ A NUMBER
	JUMPLE	N,E.WNBP	;% MUST PE POSITIVE SIZE
	CAIL	N,45		;% LESS THAN OR EQ TO 1 WORD
	JRST	E.WNBP		;% TOO BIG -- ERROR
	MOVEI	T1,">"		;% WE NEED A ,
	PUSHJ	P,CHKCHR	;% MAKE SURE WE HAVE IT
	PUSHJ	P,.TIAUC	;% READ THE EOL
	SETO	T1,		;% SET THE EOL FLAG
	PUSHJ	P,CHKCHR	;% MAKE SURE WE HAVE EOL
	DPB	N,PI.CNS	;% SAVE SIZE
	MOVEI	N,F3.CNS!F3.CNP	;% MASK
	IORM	N,F.SWM3	;% STOR IN MASK WORD
IPOPJ:	POP	P,I		;% RESTORE I
	POPJ	P,		;% RETURN
SUBTTL	UTILITY ROUTINES


SAVE1:	EXCH	P1,(P)
	MOVEM	P1,1(P)
	MOVE	P1,(P)
	PUSHJ	P,@1(P)
	  JRST	RET1
	AOS	-1(P)
	JRST	RET1

SAVE2:	EXCH	P1,(P)
	PUSH	P,P2
	MOVEM	P1,1(P)
	MOVE	P1,-2(P)
	PUSHJ	P,@1(P)
	  JRST	RET2
	AOS	-2(P)
	JRST	RET2
SAVE4:
SAVE3:	EXCH	P1,(P)
	PUSH	P,P2
	PUSH	P,P3
	MOVEM	P1,1(P)
	MOVE	P1,-4(P)
	PUSHJ	P,@1(P)
	  JRST	RET3
	AOS	-3(P)
	JRST	RET3

	EXCH	P1,(P)
	PUSH	P,P2
	PUSH	P,P3
	PUSH	P,P4
	MOVEM	P1,1(P)
	MOVE	P1,-4(P)
	PUSHJ	P,@1(P)
	  JRST	.+2
	AOS	-4(P)
	POP	P,P4
RET3:	POP	P,P3
RET2:	POP	P,P2
RET1:	POP	P,P1
	POPJ	P,0


;ROUTINE TO SAVE I
;CALL WITH:
;	PUSHJ	P,SAVEI
;	RETURN HERE (RESTORE ROUTINE ON STACK)
SAVEI=.SAVE1##	;I=P1 IS SCAN SO USE SCAN'S SAVEN ROUTINE

;ROUTINE TO SAVE I AND J
;SAME AS SAVE I
SAVEIJ=.SAVE2##	;IN SCAN

;ROUTINE TO SAVE GLOBAL AC'S
SAVEG=.SAVE4##	;IN SCAN
;SOME THINGS USED BY SCAN AND WILD

;SUBROUTINE TO TYPE A CHAR AND AND INHIBIT BLANK LINES
;CALL WITH:
;	PUSHJ	P,TYPCHR	;ONLY CALLED FROM SCAN MAGIC
;				; CALLS .TCHAR
;	RETURN HERE
;USES NO AC EXCEPT T1 AND UPDATES NEWLIN BIT
SCNTCH:	CAIG	T1,15		;IS IT BIGGER THAN 15?
	CAIGE	T1,12		; OR SMALLER THAN 12?
	JRST	TYPCH1		;YES--NOT A NEW LINE
	TXON	S,NEWLIN	;TEST AND SET NEWLINE BIT
	OUTCHR	T1		;OUTPUT THE CHAR IF OFF
	POPJ	P,		;RETURN IN ANY CASE

TYPCH1:	TXZ	S,NEWLIN	;NOT NEW LINE
	OUTCHR	T1		;OUTPUT T1
	POPJ	P,

.HELPR::OUTSTR	[ASCIZ /HELPER NOT LOADED/]
.TNEWL::PJRST	.TCRLF		;TYPE A NEW LINE
SUBTTL	CORE CONTROL ROUTINES

;SUBROUTINE TO GET A BLOCK OF CORE
;CALL IS:
;	MOVE	T1,AMOUNT-TO-GET
;	PUSHJ	P,GETCOR
;	RETURN HERE T1 POINTS TO AQUIRED CORE
;
GETCOR:	PUSHJ	P,SAVE4		;SAVE P1-P4
GTCOR0:	SKIPE	P1,FREPTR	;ANY FREE LIST?
	JRST	GTCOR1		;YES--MUST SCAN
	PUSHJ	P,FRETOP	;FREE FROM .JBFF TO .JBREL
	MOVE	P1,FREPTR	;GET THE FREE POINTER
GTCOR1:	PUSHJ	P,GCOL		;COLLECT THE PIECES TOGETHER
	HRLOI	P2,377777	;SET P2 TO +INFINITY FOR MIN ROUTINE
	SETZM	PRED		;THIS BLOCK HAS NO PREDECESSOR
GTCOR2:	HLRZ	P3,(P1)		;GET SIZE OF THIS CHUNK
	CAILE	T1,(P3)		;IS THE AMOUNT WE WANT LE TO THIS
	JRST	GTCOR3		;NO--KEEP LOOKING
	SUB	P3,T1		;GET AMOUNT OF WASTED SPACE
	CAML	P3,P2		;LESS THAN OLD MINIMUM
	JRST	GTCOR3		;NO--KEEP LOOKING
	MOVE	P2,P3		;YES--MEMORIZE PARAMETERS
	MOVS	P4,PRED		;LH(P4) IS PRED OF THIS BLOCK
	HRR	P4,P1		;RH(P4) IS BEST FIT
GTCOR3:	MOVEM	P1,PRED		;REMEMEBER THIS ADDRESS
	MOVE	P1,(P1)		;LINK TO NEXT BLOCK
	TRNE	P1,-1		;ANY NEXT BLOCK?
	JRST	GTCOR2		;YES--LOOP FOR MORE
	TLNN	P2,1		;DID WE FIND A HOLE
	JRST	GTCOR4		;YES--GIVE IT AWAY
	MOVE	P1,T1		;GET AMOUNT WE NEED
	ADD	P1,.JBREL	; PLUS AMOUNT WE HAVE
	CORE	P1,		;ASK THE MONITOR FOR THE CORE
	  JRST	E.NMC		;NO MORE CORE
	PUSHJ	P,FRETOP	;PUT THE NEW STUFF ON THE FREE LIST
	JRST	GTCOR0		;TRY AGAIN
GTCOR4:	HLRZ	P1,P4		;P1 POINTS TO LAST BLOCK
	MOVE	P2,(P4)		;GET SUCESSOR TO THIS BLOCK
	SKIPN	P1		;ANY PREVIOUS BLOCK?
	MOVEI	P1,FREPTR	;NO--RESET FREE POINTER
	HRRM	P2,(P1)		;TAKE THIS GUY OFF CHAIN
	HLRZ	P1,(P4)		;GET SIZE OF THIS BLOCK
	SUB	P1,T1		;LESS THE AMOUNT WE NEED
	HRLZ	P1,P1		;FLIP TO LEFT HALF
	HRR	P1,P4		;FREE ADDRESS
	ADD	P1,T1		;POINT TO WASTED SPACE
	MOVE	T1,P1		;COPY POINTER TO CORRECT AC
	PUSHJ	P,GIVCOR	;RETURN THE WASTE
	HRRZ	T1,P4		;POINT TO CORE
	POPJ	P,		;RETURN TO CALLER
;SUBROUTINE TO RETURN A BLOCK TO THE FREE LIST
;CALL WITH:
;	MOVE	T1,[AMOUNT-TO-GIVE-BACK,,ADDRESS-OF-CHUNK]
;	PUSHJ	P,GIVCOR
;
GIVCOR:	PUSHJ	P,SAVE2		;SAVE P1 AND P2
	HLRE	P1,T1		;GET AMOUNT TO GIVE BACK
	JUMPLE	P1,.POPJ	;-VE OR ZERO JUST RETURN
	HLLZM	T1,(T1)		;STORE SIZE OF FREE CHUNK IN CHUNK
	SKIPE	P1,FREPTR	;ANY FREE LIST?
	JRST	GVCOR1		;YES--GO ADD TO CHAIN
	HRRZM	T1,FREPTR	;STORE THIS CHUNK AS FREE LIST
	POPJ	P,		;RETURN
GVCOR1:	CAIG	P1,(T1)		;IS THIS THE BEGINING OF THE LIST
	JRST	GVCOR2		;NO--SEE IF IT IS THE END
	HRRM	P1,(T1)		;YES--LINK LIST ONTO THIS BLOCK
	HRRZM	T1,FREPTR	;AND RESET FREE POINTER
	POPJ	P,		;RETURN
GVCOR2:	PUSHJ	P,GCOL		;CLEAN UP
	MOVE	P2,MAXFRE	;GET ADDRESS OF HIGHEST BLOCK
	CAIL	P2,(T1)		;IS THIS HIGHER?
	JRST	GVCOR3		;NO--PUT IN MIDDLE
	HRRM	T1,(P2)		;YES--PUT ON END
	POPJ	P,		;RETURN
GVCOR3:	CAIG	P1,(T1)		;IS THIS BLOCK GT NEW BLOCK
	JRST	GVCOR4		;NO--KEEP LOOKING
	HRRM	T1,(P2)		;YES--HAVE PRED POINT TO NEW
	HRRM	P1,(T1)		; AND NEW POINT TO THE REST
	POPJ	P,		;RETURN
GVCOR4:	MOVE	P2,P1		;SAVE THIS AS PRED
	HRRZ	P1,(P1)		;GET THE NEXT BLOCK
	JUMPN	P1,GVCOR3	;LOOP FOR MORE
	HALT	.		;RAN OFF END OF LIST
;SUBROUTINE TO MERGE CONTIGUOUS FREE BLOCKS INTO BIGGER FREE BLOCKS
;CALL WITH:
;	PUSHJ	P,GCOL
;
GCOL:	PUSHJ	P,SAVE3		;SAVE P1 - P3
	SKIPN	P1,FREPTR	;ANY FREE LIST?
	POPJ	P,		;NO--ALL TOGETHER
GCOL1:	HLRZ	P2,(P1)		;P2 IS SIZE OF FREE BLOCK
	SKIPN	P2		;CHUNKS CAN NOT HAVE ZERO LENGTH
	HALT	.		;THIS ONE DOES
	ADDI	P2,1(P1)	;P2 IS LOCATION OF FIRST FREE WORD
				; ABOVE THIS FREE BLOCK.
	HLL	P2,(P2)		;COPY SIZE OF NEXT BLOCK
	CAME	P2,(P1)		;IS THE NEXT EXACTLY ABOVE THIS?
	JRST	GCOL2		;NO--KEEP SCANING
	HLLZ	P3,(P1)		;SIZE OF FIRST FREE AREA
	ADD	P3,(P2)		;PLUS SIZE AND LINK TO SECOND FREE AREA
	MOVEM	P3,(P1)		;STORE IN BLOCK
	JRST	GCOL1		;SEE IF ANOTHER ABOVE THAT
GCOL2:	HRRZM	P1,MAXFRE	;STORE THIS AS HIGHEST ADDRESS IN FREE LIST
	HRRZ	P1,(P1)		;GET NEXT BLOCK
	JUMPN	P1,GCOL1	;LOOP FOR MORE
	POPJ	P,		;RETURN
;SUBROUTINE TO PLACE BLOCK OF CORE FROM .JBFF TO .JBREL ON FREE LIST
;CALL WITH
;	PUSHJ	P,FRETOP
;

FRETOP:	PUSHJ	P,SAVE1		;SAVE P1
	MOVE	P1,.JBREL	;GET HIGEST ADDRESS
	SUB	P1,.JBFF	;GET FIRST FREE ADDRESS
	SOS	P1		;DO NOT HUNT WITCHES
	MOVSS	P1		;FLIP TO LEFT HALF
	HRR	P1,.JBFF	;PUT IN ADDRESS
	EXCH	P1,T1		;SAVE T1 ANS PUT ARG IN T1
	PUSHJ	P,GIVCOR	;GIVE THE CORE BACK
	MOVE	T1,.JBREL	;GET THE FIRST WORD NOT IN LIST
	MOVEM	T1,.JBFF	;SATORE AS NEW FIRST FREE
	MOVE	T1,P1		;RESTORE T1
	POPJ	P,		;RETURN
SUBTTL ERROR MESSAGES

;SUBROUTINE TO DECODE A LOOKUP ENTER OR RENAME FAILURE
;CALL WITH:
;	UUO	CHAN,E
;	  JSP	T1,LERCOD
;	DOES NOT RETURN -- RESTARTS
;
LERCOD:	MOVEI	T1,-2(T1)	;POINT BACK TO UUO
	MOVEI	T2,@(T1)	;GET UUO BLOCK
	MOVE	T3,(T2)		;GET FIRST WORD
	TLNE	T3,-1		;EXTENDED UUO?
	SKIPA	T3,T2		;NO--GET ADDRESS OF FILE NAME
	MOVEI	T3,2(T2)	;YES--FILE NAME HAS BEEN MOVED GET IT
	LDB	J,[POINT 9,(T1),8] ;GET OP CODE
	MOVEI	T1,2(T2)	;POINT AT EFFECTIVE ADDRESS OF UUO
	CAIN	J,256		;IS IT AN XCT?
	JRST	LERCOD		;YES--FOLLOW THE CHAIN
	TRO	J,40		;LIGHT A BIT
	PUSH	P,T3		;SAVE ADDRESS OF FILE NAME
	MOVEI	T1,[ASCIZ /ILL. UUO/]
	CAIN	J,76		;LOOKUP?
	MOVEI	T1,[ASCIZ /LOOKUP/]
	CAIN	J,77		;ENTER?
	MOVEI	T1,[ASCIZ /ENTER/]
	CAIN	J,55		;RENAME?
	MOVEI	T1,[ASCIZ /RENAME/]
	PUSH	P,T1
	MOVEI	T1,[ASCIZ /
? /]
	PUSHJ	P,.TSTRG	;TYPE <CR><LF>?<SPACE>
	POP	P,T1		;TYPE UUO NAME
	PUSHJ	P,.TSTRG	; ..
	MOVEI	T1,[ASCIZ / failure /]
	PUSHJ	P,.TSTRG	;SAY FAILURE
	MOVE	T1,(P)		;GET ADDRESS OF FILENAME
	HRRZ	T1,1(T1)	;GET ERROR CODE
	MOVEI	N,(T1)		;SAVE
	PUSHJ	P,.TOCTW	;PRINT OCTAL NUMBER
	MOVEI	T1,[ASCIZ / (/]	;PRINT THE PAREN
	PUSHJ	P,.TSTRG	; ..
	CAILE	N,MAXERR	;DO WE KNOW ABOUT THIS ERROR?
	MOVEI	N,MAXERR+1	;NO--FAKE IT
	MOVEI	T1,[ASCIZ /no file name given/]
	SKIPE	@(P)		;SKIP IF FILE NAME WAS MISSING
	MOVE	T1,LERTBL(N)	;GET ADDRESS OF ERROR MESSAGE
	PUSHJ	P,.TSTRG	;TYPE THE MESSAGE
	MOVEI	T1,[ASCIZ /) for file /]
	PUSHJ	P,.TSTRG	;TYPE THE FOR FILE MESSAGE
	PUSHJ	P,TYFILE	;TYPE FILE NAME ETC.
	PJRST	.FMSGE		;BOMB OUT
;SUBROUTINE TO DECODE AN OPEN FAILURE
;CALL WITH:
;	JRST	E.FOF	;T2=DEVICE NAME
;
;	-OR-;
;	JRST	E.DFO	;OPNBLK+1=DEVICE NAME
;
E.FOF:	SKIPA	N,T2		;N := SIXBIT /DEVICE/
E.DFO:	MOVE	N,I.OPN+1(I)	; DITTO
	MOVE	T1,N		;COPY DEVICE NAME
	DEVCHR	T1,		;SEE IF DEVICE EXISTS
	JUMPE	T1,E.NSD	;JUMP IF NO SUCH DEVICE
	MOVE	T1,N		;GET DEVICE NAME AGAIN
	DEVTYP	T1,		;GET PJOBN BYTE
	  JRST	E.DNA		;DEVTYPE LOST
	DEVNAM	N,		;GET NAME OF DEVICE
	  JFCL			;AC UNCHANGED IF NO UUO
	LDB	I,[<POINTR(T1,TY.JOB)>] ;% SAVE JOB NUMBER
	MOVEI	T1,[ASCIZ /
? Device /]
	PUSHJ	P,.TSTRG	;% TYPE THE WORD DEVICE
	MOVE	T1,N		;% MOVE THE DEVICE NAME
	PUSHJ	P,.TSIXN	;% TYPE THE DEVICE NAME
	MOVEI	T1,[ASCIZ / is in use by job /]
	PUSHJ	P,.TSTRG	;% TYPE NOISE WORDS
	MOVE	T1,I		;% MOVE JOB NUMBER
	PUSHJ	P,.TDECW	;% TYPE A DECIMAL WORD
	PUSHJ	P,.TCRLF	;% TYPE A CRLF
	PJRST	.FMSGE		;% ERROR CLEANUP

E.DNA:	M.FAIN	<Device not available ->
LERTBL:	[ASCIZ	/file not found/]
	[ASCIZ	/no ufd/]
	[ASCIZ	/protection failure/]
	[ASCIZ	/file being modified/]
	[ASCIZ	/file exists/]
	[ASCIZ	/ill. sequence of UUOs/]
	[ASCIZ	/RIB or UFD ERROR/]
	[ASCIZ	/not a save file/]
	[ASCIZ	/not enough core/]
	[ASCIZ	/device not available/]
	[ASCIZ	/no such device/]
	[ASCIZ	/ill. GETSEG/]
	[ASCIZ	/no room/]
	[ASCIZ	/write lock error/]
	[ASCIZ	/not enough monitor table space/]
	[ASCIZ	/partial allocation only/]
	[ASCIZ	/block not free/]
	[ASCIZ	/can not superced a uFD or SFD/]
	[ASCIZ	/directory not empty/]
	[ASCIZ	/SFD not found/]
	[ASCIZ	/search list empty/]
	[ASCIZ	/SFD nesting too deep/]
	[ASCIZ	/all strs have no create or write lock/]
MAXERR==.-LERTBL
	[ASCIZ	/unknown error/]

E.ITF:	M.FAIL	<Invalid format in table file>
E.WNBP:	M.FAID	<WRONG NUMBER IN BYTE POINTER>
E.NFI:	M.FAIL	<No files for input>
E.NFO:	M.FAIL	<No files for output>
;ROUTINE TO PRINT IO ERROR BITS

	DEFINE	MATRIX,<

;TYPE	IMP	DER	DTE	BKT
X	BUG,	SRH,	BDB,	FUL,	;DSK
X	WLE,	DMI,	PTY,	TIF,	;DTA
X	WLE,	BTP,	PTY,	REB,	;MTA
X	$IM,	$DE,	$DT,	$BK,	;TTY
X	BDI,	$DE,	CHK,	$BK,	;PTR
X	$IM,	$DE,	$DT,	$BK,	;PTP
X	$IM,	$DE,	$DT,	$BK,	;DIS
X	$IM,	$DE,	$DT,	$BK,	;LPT
X	M79,	PCE,	CHK,	$BK,	;CDR
X	$IM,	PUE,	$DT,	PDL,	;CDP
X	$IM,	$DE,	$DT,	$BK,	;PTY
X	$IM,	$DE,	$DT,	$BK,	;PLT
					;^ DEVTYP ^
>

	DEFINE	X(A,B,C,D),<
	BYTE	(9) A'$ER,B'$ER,C'$ER,D'$ER
>

ERRPTR:	MATRIX
;THE MESSAGES THAT GO ALONG WITH THOSE CODES

	DEFINE	IOERMS,<
;FIRST THOSE THAT SHOULD NEVER HAPPEN
X	$IM,<improper mode>
X	$DE,<device error>
X	$DT,<data error>
X	$BK,<block too large>
;NOW THOSE THAT CAN HAPPEN
X	PUE,<punch error>
X	PDL,<attempt to punch column 81>
X	M79,<missing 7-9 punch on binary card>
X	PCE,<photo cell error, card motion or data missed>
X	CHK,<computed checksum does not match checksum read>
X	WLE,<write lock error>
X	BTP,<data missed or bad tape>
X	PTY,<parity error>
X	REB,<block bigger than /BLKSIZE>
X	BDI,<binary data incomplete>
x	dmi,<data missed>
X	TIF,<tape is full>
X	BUG,<software detected error>
X	SRH,<search error>
X	BDB,<bad block on disk>
X	FUL,<quota, disk or RIB is full>

>
	DEFINE	X(A,B),<
	A'$ER==.-ERRTBL
	ASCIZ	\B\
	>

	IFLE	EXPAND,<XLIST>
	IFG	EXPAND,<XALL>
ERRTBL:	IOERMS
	SALL
	LIST
;SUBROUTINE TO DO SOMETHING ABOUT ERRORS
;CALL WITH:
;	GETSTS	DEV,N
;	PUSHJ	P,E.IOER
;	RETURN HERE TO CONTINUE
;
E.IOER:	LDB	T1,PI.ERR	;GET ERROR SWITCH
	CAIN	T1,KE.IGN	;IGNORE ERRORS?
	POPJ	P,		;YES--JUST RETURN
	PUSHJ	P,SAVEG		;SAVE I,J,C,N
	MOVEI	T1,[ASCIZ "
% I/O Error "]
	PUSHJ	P,.TSTRG	;TYPE THAT MUCH
	MOVE	T1,N		;GET CODE
	PUSHJ	P,.TOCTW	;TYPE IT
	MOVEI	T1,[ASCIZ / for /]
	PUSHJ	P,.TSTRG	;TYPE THAT TOO
	PUSHJ	P,TYFILE	;TYPE THE FILESPEC
	MOVX	T2,TY.SPL	;LOAD THE SPOOL BIT
	TDNE	T2,I.TYPE(I)	;IS IT SET FOR OUTPUT DEVICE?
	TDZA	J,J		;YES--I DO NOT WANT TO BE FOOLED HERE
	LDB	J,P.TYPE	;GET THE DEVICE TYPE
	LDB	T2,[POINT 9,ERRPTR(J),8] ;GET THE DISPATCH BYTE
	TXNE	N,IO.IMP	;IMPROPER MODE?
	PUSHJ	P,WARNX		;YES--TYPE WARNING
	LDB	T2,[POINT 9,ERRPTR(J),17]
	TXNE	N,IO.DER	;DEVICE ERROR
	PUSHJ	P,WARNX		;YES--TYPE THE WARNING
	LDB	T2,[POINT 9,ERRPTR(J),26]
	TXNE	N,IO.DTE	;DATA ERROR
	PUSHJ	P,WARNX		;TYPE THE WARNING
	LDB	T2,[POINT 9,ERRPTR(J),35]
	TXNE	N,IO.BKT	;BLOCK TOO LARGE
	PUSHJ	P,WARNX		;YES--TELL ABOUT THAT TOO
	MOVEI	T1,[ASCIZ /
% FILE =/]
	PUSHJ	P,.TSTRG	;TYPE THAT
	MOVE	T1,I.FILE(I)	;GET FILE NUMBER
	TLZ	T1,(1B0)	;CLEAR BOT FLAG
	PUSHJ	P,.TDECW	;TYPE THE FILE NUMBER
	MOVEI	T1,[ASCIZ / RECORD =/]
	PUSHJ	P,.TSTRG	;TYPE THE STRING
	MOVE	T1,I.RCNT(I)	;TYPE THE RECORD COUNT
	PUSHJ	P,.TDECW	; ..
	PUSHJ	P,.TCRLF	;TYPE AN EOL
	LDB	J,PI.ERR	;GET THE TYPE OF ERROR RECOVERY
	CAIN	J,KE.WRN	;JUST WARN?
	POPJ	P,		;YES--THEN WE ARE DONE
	CAIE	J,KE.ASK	;ASK WHAT TO DO?
	JRST	CNTERR		;NO--JUST KEEP COUNTING
;HERE IF USER WANTS TO BE ASKED WHAT TO DO

	MOVEI	T1,[ASCIZ /CONTINUE: /]
IOASK:	SKPINC			;DEFEAT ^O
	  JRST	.+2		;SKIP IF NONE
	CLRBFI			;CLEAR TYPE AHEAD
	PUSHJ	P,.TSTRG	;TYPE A STRING
	PUSHJ	P,.TIAUC	;GET A CHAR
	CAIN	C,"N"		;IS IT NO?
	PJRST	.FMSGE		;YES--WIPE OUT
	CAIE	C,"Y"		;IS IT YES?
	JRST	IOASK		;NO--LOOP BACK AND TRY AGAIN
	PUSHJ	P,.TIAUC	;GET THE NEXT CHAR
	JUMPG	C,.-1		;LOOP FOR "ES" IF TYPED
	POPJ	P,		;END OF LINE
CNTERR:	SOSLE	I.ECNT(I)	;COUNT ANOTHER ERROR
	POPJ	P,		;NOT TOO MANY
	M.FAIL	<Too many errors>
;SUBROUTINE TO TYPE BACK THE FILE SPEC THE USER TYPED

TYFILE:	PUSHJ	P,SAVEIJ	;SAVE I AND J
	MOVE	T2,I.OPN+1(I)	;GET DEVICE NAME WE OPENED
	LDB	T1,P.CHAN	;GET CHAN NUMBER
	DEVNAM	T1,		;GET DEVICE NAME
	  MOVE	T1,I.OPN+1(I)	;NO--GET THE DEVICE WE OPENED
	PUSHJ	P,.TSIXN	;TYPE IT
	MOVEI	T1,":"		;TYPE A COLON
	PUSHJ	P,.TCHAR	; ..
	MOVE	J,I.RIB(I)	;GET FIRST WORD OF RIB
	TLNN	J,-1		;EXTENDED UUO?
	SKIPA	T1,I.RIB+.RBNAM(I) ;YES--GET NAME FROM OTHER PLACE
	MOVE	T1,J		;NO--NAME IS FIRST WORD
	JUMPE	T1,.POPJ	;EXIT IF NO FILE NAME
	PUSHJ	P,.TSIXN	;ELSE TYPE THE FILE NAME
	TLNN	J,-1		;EXTENDED UUO?
	SKIPA	T2,I.RIB+.RBEXT(I) ;YES GET EXTENSION
	MOVE	T2,I.RIB+1(I)	;NO--GET EXTENSION
	HLLZS	T2		;ZERO RH
	JUMPE	T2,TYPATH	;JUMP IF NO EXTENSION
	MOVEI	T1,"."		;ELSE TYPE A .
	PUSHJ	P,.TCHAR	; ..
	MOVE	T1,T2		;COPY EXTENSION
	PUSHJ	P,.TSIXN	;TYPE THAT

;FALL INT TYPATH
;SUBROUTINE TO TYPE A PATH

TYPATH:	TLNE	J,-1		;EXTENDED UUO?
	POPJ	P,		;NO--THEN NO PATH
	SKIPN	J,I.RIB+.RBPPN(I) ;ANY PATH THEN?
	POPJ	P,		;DEFAULT
	MOVEI	T1,"["		;TYPE THE BRACKET
	PUSHJ	P,.TCHAR	; ..
IFN FTSFD,<			;IF WE HAVE SFD LOGIC
	TLNN	J,-1		;SFD SPECIFIED?
	SKIPA	T1,2(J)		;YES--GET PPN INDIRECT
> ;END CONDITIONAL ON FTSFD
	MOVE	T1,J		;COPY PPN
	PUSHJ	P,.TXWDW		;TYPE THE PPN
IFN FTSFD,<			;IF WE HAVE SFD LOGIC
	TLNE	J,-1		;WAS A PATH SPECIFIED?
	JRST	TLSQB		;NO--TYPE THE BRACKET AND LEAVE
	ADDI	J,2		;BUMP J
TSFDLP:	AOS	J		;BUMP J
	SKIPN	T2,(J)		;SKIP IF MORE
	JRST	TLSQB		;ELSE TYPE THE BRACKET
	MOVEI	T1,","		;TYPE A COMMA
	PUSHJ	P,.TCHAR	; ..
	MOVE	T1,T2		;FLIP TO A GOOD PLACE
	PUSHJ	P,.TSIXN	;TYPE AN SFD
	JRST	TSFDLP		;LOOP FOR THE REST
TLSQB:
> ;END CONDITIONAL ON FTSFD
	MOVEI	T1,"]"		;TYPE THE LAST BRACKET
	PJRST	.TCHAR		; AND EXIT
;SUBROUTINE TO REPORT A BAD CONVERSION REQUEST
;CALL WITH:
;	MOVE	T1,FROM-INDEX
;	MOVE	T2,TO-INDEX
;	PJRST	E.CONV
;	RETURNS VIA .FMSGE
;
E.CONV:	PUSH	P,CODE.T(T2)	;SAVE TO CODE
	PUSH	P,CODE.T(T1)	;SAVE FROM CODE
	MOVEI	T1,[ASCIZ /
?Can not convert /]
	PUSHJ	P,.TSTRG	;TYPE THAT PART
	POP	P,T1		;RESTORE A WORD
	PUSHJ	P,.TSIXN	;TYPE IT
	MOVEI	T1,[ASCIZ / to /]
	PUSHJ	P,.TSTRG	;TYPE THE NEXT PART
	POP	P,T1		;PRINT OUT THE NEW CODE
	PUSHJ	P,.TSIXN	; ..
	PJRST	.FMSGE		;RETURN TO SCAN
;SUBROUTINE TO PRINT A WARNING MESSAGE
;CALL WITH:
;	MOVE	T1,ADDRESS-OF-MESSAGE
;	PUSHJ	P,$WARN
;	RETURN HERE
;
WARNX:	MOVEI	T1,ERRTBL(T2)	;POINT T1 TO ASCIZ STRING

$WARN:	PUSH	P,T1		;SAVE T1
	MOVEI	T1,[ASCIZ /
% /]
	PUSHJ	P,.TSTRG	;TYPE A WARNING MARK
	POP	P,T1		;RESTORE T1
	PUSHJ	P,.TSTRG	;TYPE THE MESSAGE
	PJRST	.TCRLF		;TYPE A CRLF
;HERE WHEN EOL EXPECTED AND NOT FOUND
E.ILSN:	SETO	T1,		;SAY WE WANT EOL
	PJRST	E.UXCH		;%  AND GIVE UNEXPECTED CHAR MESSAGE

;SUBROUTINE TO CHECK FOR CORRECT CHAR IN INPUT STRING
;CALL WITH:
;	MOVE	T1,WHAT-WE-WANT
;	MOVE	C,WHAT-WE-HAVE
;	PUSHJ	P,CHKCHR
;	RETURN HERE IF MATCH ELSE GIVE MESSAGE AND BOMB
;
CHKCHR:	CAMN	C,T1		;% MATCH?
	POPJ	P,		;% YES--RETURN
				;% NO--FALL INTO UNEXPECTED CHAR ROUTINE

;SUBROUTINE TO PRINT UNEXPECTED CHAR MESSAGE
;CALL WITH:
;	MOVE	T1,EXPECTED-CHAR
;	MOVE	C,ACTUAL-CHAR
;	PUSHJ	P,E.UXCH	
;	RETURNS TO SCAN

E.UXCH:	MOVE	I,T1		;% SAVE EXPECTED
	MOVE	J,C		;% SAVE ACTUAL
	MOVEI	T1,[ASCIZ /? Unexpected /]
	PUSHJ	P,.TSTRG	;% TYPE THE WORD
	MOVE	C,J		;% GET ACTUAL CHAR
	PUSHJ	P,TYPCHR	;% TYPE IT
	MOVEI	T1,[ASCIZ / while scaning for /]
	PUSHJ	P,.TSTRG	;% TYPE WILE...FOR
	MOVE	C,I		;% COPY WHAT WE WANTED
	PUSHJ	P,TYPCHR	;% TYPE THE LAST CHAR
	PJRST	.FMSGE		;% FINISH ERROR
;SUBROUTINE TO TYPE 1 CHAR CONVERTING CONTROLS AND -1 TO
; ASCII GRAPHICS
;CALL WITH:
;	MOVE	C,CHAR
;	PUSHJ	P,TYPCHR
;
TYPCHR:	MOVE	T1,C		;COPY ARGUMENT
	CAIN	T1,33		;ESCAPE?
	MOVEI	T1,"$"		;YES--FIX UP
	JUMPL	T1,TYPEOL	;JUMP IF EOL
	CAIL	T1,40		;CONTROL?
	JRST	.TCHAR		;NO--JUST TYPE
	MOVEI	T1,"^"		;YES--GET AN UP-ARROW
	PUSHJ	P,.TCHAR	;TYPE
	MOVEI	T1,100(C)	;GET ASCII EQUIV.
	PJRST	.TCHAR		;TYPE
TYPEOL:	MOVE	T1,[SIXBIT /<EOL>/]
	PJRST	.TSIXN		;TYPE THE <EOL>
SUBTTL 	CONSTANTS

DEFINE	GENPTR	(WORD,PFX,LIST)<
	IRP	LIST,<
	GENPT1	(WORD,PFX,LIST,PI)
	GENPT1	(WORD+1,PFX,LIST,PM)
	>>

DEFINE	GENPT1	(WORD,PFX,SFX,P)<
	.XCREF
	$WID==WID(PFX'.'SFX)
	$POS==POS(PFX'.'SFX)
	.CREF
P'.'SFX:POINT	$WID,WORD'(I),$POS
	>

;GENERATE POINTERS OF THE FORM PI.XXX AND PM.XXX TO
; POINT TO XXX AND ITS MASK.

	GENPTR	I.SWT1,F1,<BYT,COD,BLK>
	GENPTR	I.SWT2,F2,<REC,CNT,PAR,LAB>
	GENPTR	I.SWT3,F3,<BUF,MOD,DEN,CRL,CNP,CNS,ERR>

P.CHAN:	POINT	4,I.CHAN(I),12	;POINTER TO CHANNEL NUMBER
P.TYPE:	POINT	WID(TY.DEV),I.TYPE(I),POS(TY.DEV) ;POINTER TO DEVTYP
EBCPTR:	POINT	9,UNITAB(T1),8
BCDPTR:	POINT	9,UNITAB(T1),26
SUBTTL CODE NOT YET WRITTEN

MTEST:
TYPCOM:
	M.FAIL	<NO CODE FOR THAT FUNCTION>

SUBTTL	STORAGE

	XLIST
	LIT
	LIST
	RELOC
	
STZER:!
F.ZER:!
F.DEV:	BLOCK	1		;DEVICE NAME
F.NAM:	BLOCK	1		;FILE NAME
F.NAMM:	BLOCK	1		;FILE NAME MASK
F.EXT:	BLOCK	1		;EXTENSION
F.MOD:	BLOCK	1		;DEVICE SWITCHES
F.MODM:	BLOCK	1		;MASK FOR DEVICE SWITCHES

;FIELDS IN F.MOD
FM.NUL==1B1			;EXTENSION IS NULL
FM.DIR==1B2			;DIRECTORY WAS TYPED
FM.PHY==1B3			;/PHYSICAL
FM.NOM==1B4			;/OKNONE
FM.ADD==1B6			;FILSPEC ENDS WITH +
FM.STR==1B9			;/STRS

F.DIR:	BLOCK	1		;PPN
F.DIRM:	BLOCK	1		;PPN MASK
F.SFD:	BLOCK	2*<LN.DRB-1>	;SFD/MASK,SFD/MASK.....
F.SWT1:	BLOCK	1		;WORD OF SWITCHES
F.SWM1:	BLOCK	1		;MASK FOR F.SWT1

;FIELDS IN F.SWT1

F1.BYT==77B5			;/BYTESIZE
F1.COD==77B11			;/CODE
F1.TAB==7B14			;/TABS
F1.RFM==7B17			;/RECFMT
F1.BLK==777777B35		;/BLKSIZE

F.SWT2:	BLOCK	1		;SECOND SWITCH
F.SWM2:	BLOCK	1		; MASK PAIR

;FIELDS IN F.SWT2

F2.REC==777777B17		;/RECSIZE
F2.ALI==1B19			;/ALIGN
F2.LIN==1B18			;/LINEBLOCK
F2.TRI==1B20			;/TRIM 
F2.CNT==7B23			;/COUNT
F2.SPA==1B24			;/SPAN  
F2.PAR==3B26			;/PARITY
F2.LAB==777B35			;/LABEL
F.SWT3:	BLOCK	1
F.SWM3:	BLOCK	1

;FIELDS IN F.SWT3

F3.ERR==7B2			;/ERROR
F3.XXX==7B5			;SPARE
F3.BUF==77B11			;/BUFFERS
F3.MOD==1B12			;/MODE
F3.DEN==3B14			;/DENSITY
F3.CRL==7B17			;/CRLF
F3.CNP==77B23			;P FROM /COUNTBYTE
F3.CNS==77B29			;S FROM /COUNTBYTE
F3.XXX==77B35			;SPARE

F.SWT4:	BLOCK	1		
F.SWM4:	BLOCK	1

F4.LEO==77B5			;/LEOT

F.OFFS:	BLOCK	1		;/OFFSET
F.OFFM:	BLOCK	1		;MASK FOR /OFFSET
F.PAD:	BLOCK	1		;/PAD
F.PADM:	BLOCK	1		;MASK FOR /PAD
F.ELIM:	BLOCK	1		;ERROR LIMIT
F.ELMM:	BLOCK	1		;MASK TO SAME
F.CNTO:	BLOCK	2		;/COUNTOFFSET
F.ILLC:	BLOCK	2		;/ILLEGAL
F.TABL:	BLOCK	1		;XWD TABLESIZE,,ADDRESS
F.CHAN:	BLOCK	1		;CHAN NUMBER IN AC FIELD REST 0
F.IBLK:	BLOCK	1		;LH-SPARE, RH-LINK TO I.???? BLOCK
F.END==.-1			;LAST WORD IN BLOCK

F.LEN==.-F.ZER



;EACH FILE IS COPIED INTO A BLOCK AFTER SWITCH PROCESSING

I.ZER:	PHASE	0
I.DEV:!	BLOCK	1		;DEVICE
I.NAM:!	BLOCK	1		;FILE NAME
I.NAMM:!BLOCK	1		;FILE NAME MASK
I.EXT:!	BLOCK	1		;EXTENSION
I.MOD:!	BLOCK	2		;SWITCHES
I.DIR:!	BLOCK	LN.DRB*2	;PATH
ISPLEN==.-I.DEV		;LENGTH OF SPEC PART OF I BLOCK
I.SWT1:!BLOCK	2		;SWITCH WORD 1
I.SWT2:!BLOCK	2		;SWITCH WORD 2
I.SWT3:!BLOCK	2		;SWITCH WORD 3
I.SWT4:!BLOCK	2		;SWITCH WORD 4
I.OFFS:!BLOCK	2		;OFFSET VALUE
I.PAD:!	BLOCK	2		;PAD CHAR
I.ELIM:!BLOCK	2		;ERROR LIMIT
I.CNTO:!BLOCK	2		;COUNT OFFSET
I.ILLC:!BLOCK	2		;/ILLEGAL
SWTLEN==.-I.SWT1
I.TABL:!BLOCK	1		;TABLE LINK
I.CHAN:!BLOCK	1		;CHANNEL NUMBER IN AC FIELD

;FROM I.DEV TO HERE MUST MATCH F.DEV THRU F.IBLK-1

IF2	<
IFN	<<F.ZER-F.CHAN>-<I.DEV-I.CHAN>>,<
	PRINTX	?F-BLOCK AND I-BLOCK DO NOT MATCH
>>

I.CONV:!BLOCK	1		;CONVERSION ROUTINE
I.LINK:!BLOCK	1		;LINK TO NEXT SPEC
I.OPN:!BLOCK	3		;OPEN BLOCK
I.RIB:!	BLOCK	33		;FOR EXTENDED UUOS
RIBLEN==.-I.RIB
IFN	FTSFD,<
I.PATH:!BLOCK	LN.DRB+3	;FOR SFD LISTS
>
;MORE I-BLOCK LOCATIONS

I.LABL:!BLOCK	^D80/5		;PLACE TO HOLD AN ASCII LABEL
I.VLSN:!BLOCK	1		;VOLUME SERIAL NUMBER
I.VOID:!BLOCK	3		;VOLUME OWNER ID (14 a CHARS.)
I.FNAM:!BLOCK	4		;FILE NAME (17 a CHARS.)
I.FSET:!BLOCK	2		;FILE SET ID (6 a CHARS.)
I.FSCT:!BLOCK	1		;FILE SECTION NUMBER
I.FSEQ:!BLOCK	1		;FILE SEQUENCE NUMBER
I.FGEN:!BLOCK	1		;FILE GENERATION NUMBER
I.FGVN:!BLOCK	1		;FILE GENERATION VERSION
I.FCDT:!BLOCK	1		;CREATION DATE
I.FXPD:!BLOCK	1		;EXPIRATION DATE
I.EBCT:!BLOCK	1		;BLOCK COUNT
;FROM HERE TO END OF I.BLOCK CLEARED BY CLEANI
I.ZER1:!
I.BUFH:!BLOCK	1		;BUFFER HEADER
I.BPNT:!BLOCK	1		;BYTE POINTER
I.BCNT:!BLOCK	1		;BYTE COUNT
I.BUFA:!BLOCK	1		;ADDRESS OF FIRST BUFFER FOR THIS DEVICE
I.TYPE:!BLOCK	1		;DEVTYP WORD
I.CHCT:!BLOCK	1		;CHARACTOR COUNT
I.RCNT:!BLOCK	1		;RECORD COUNT
I.LMEM:!BLOCK	1		;POINTER FOR WILD AND SCNDTA
I.ECNT:!BLOCK	1		;CRROR COUNT
I.FILE:!BLOCK	1		;BIT0=1 IF MAG TAPE A BOT WHEN MAGIC
				; STARTED TO USE IT.
				; BITS 1-35 # FILES COPIED
I.EZER:!
	DEPHASE
I.LEN==.-I.ZER
	RELOC	I.ZER		;OVERLAY PROTOTYPE

;MISC SCRATCH CORE

SAOFST:	BLOCK	1		;STARTING ADDRESS OFFSET
INLST:	BLOCK	1		;CHAIN OF INPUT SPECS
OUTLST:	BLOCK	1		;CHAIN OF OUTPUT SPECS
TBLTMP:	BLOCK	1		;MEMORY WORK FOR SETWLD WHILE SCANING
				; FOR A TABLE FILE
ISAVE:	BLOCK	1		;THE ADDRESS OF THE INPUT I-BLOCK IS
				; SAVED HERE.
VERCNT:	BLOCK	1		;COUNT OF THE NUMBER OF VERIFY PASSES
				; BEFORE WE ARE DONE.
FREPTR:	BLOCK	1		;POINTER TO CHAIN OF FREE CORE AREAS
MAXFRE:	BLOCK	1		;HIGHEST BLOCK IN FREE LIST. THIS IS THE
				; LAST BLOCK IN FREE LIST ALSO
PRED:	BLOCK	1		;BLOCK JUST LOOKED AT. USED WHEN SCANING
				; LINKED LISTS.
TBASE:	BLOCK	1		;LOCATION WHERE THE LAST TABLE WAS
				; BUILT.
TBLBHD:	BLOCK	3		;BUFFER HEADER FOR READING IN TABLES
OPNBLK:	BLOCK	3		;BLOCK FOR OPENING TABLE FILE
LUBLK:	BLOCK	5		;BLOCK TO LOOKUP TABLE FILE
TBLSPC:	BLOCK	10+2*LN.DRB	;FILE SPEC FOR TABLE FILE
TBSPSZ==.-TBLSPC
ARGBLK:	BLOCK	10		;SCRATCH FOR UUO AND THE LIKE
TBLBUF:	BLOCK	203		;BLOCK FOR READING TABLE FILE, ALSO
				; USED FOR DEC TAPE DIRECTORIES.
PDL:	BLOCK	PDSIZE		;IF YOU CAN'T FIGURE OUT WHAT THIS IS
				; YOU HAVE A REAL PROBLEM.

ENDZER:!			;THE LAST LOCATION TO BE ZEROED AT
				; RESET TIME.
	END	MAGIC
  9/u