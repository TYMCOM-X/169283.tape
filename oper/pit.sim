!PIT PRODUCT INVENTORY  19 JAN 73  (BARB)

GLOBAL %PIN, G:
G:  IOCS(1); PIN; EXIT
\\->G

DEF UNTIL(X) AS WHILE NOT X THEN NULL
DEF TABCHAR AS ($I-OCT 100)
DEF FORM.FEED AS ($L-OCT 100)

LOCAL %DOUT, %CK.LIST, %DOL.IN, %RJ.DOL, %ERMS, %BMP.DOWN
LOCAL %GET.FILE.NAME, %WDB, %RDB

%GET.FILE.NAME
LOCAL P
  P _ GET.LINE(TEL); LOOP WHILE NCHV P#CARRET
  CHV P _ EOLIT; RETURN
END GET.FILE.NAME

%DOL.IN(N, NUTS:, DP)
  LOCAL SGN, DPNT, I, R, C, DCNT, V

  I _ SGN _ DCNT _ R _ C _ 0
  EIF V _ NCHV N = $- THEN SGN _ 1
  ORIF V = $+ THEN NULL
  ELSE PCHV N
  DPNT _ 0
  WHILE V _ NCHV N # CARRET THEN DO
    INC I
    EIF V = $. THEN [DPNT _ I; INC DCNT]
    ORIF NOT $0 <= V <= $9 THEN GO NUTS
    ELSE [C _ V-$0; R _ C + R*10]
  END
  IF DCNT>1 OR I_(IF DPNT = 0 THEN 0 ELSE I-DPNT)>DP THEN GO NUTS
  REPEAT DP-I  R _ R*10
  IF SGN # 0 THEN R _ -R
  RETURN R
END DOL.IN

%CK.LIST(PTR, TBL(), CNT)
LOCAL I,P1,C1,C2,FD,F,P2
  I _ -1; FD _ 0
  WHILE INC I # CNT THEN DO
    P1 _ CHPT(TBL(I),-1); P2 _ PTR
    WHILE C2 _ NCHV P2 # CARRET THEN DO
      IF C1 _ NCHV P1 = CARRET THEN GO NOFD
      IF C2#C1 THEN GO NOFD
    END
    INC FD; F _ I
NOFD: NULL
  END
  IF FD=1 THEN RETURN INC F ELSE RETURN 0
END CK.LIST

%RDB(FN, NWDS, BUF())
LOCAL I
  FOR I _ 1 TO NWDS BUF(I-1) _ R(FN)
! RB(FN, NWDS, BUF)
  RETURN
END RDB

%WDB(FN, NWDS, BUF())
LOCAL I
  FOR I _ 1 TO NWDS W(FN, BUF(I-1))
! WB(FN, NWDS, BUF)
  RETURN
END WDB

%DOUT(N)
  LOCAL H, L, S, D, C
C _  H _ L _ 0;  S _ [N<0];  N_ ABS N
  WHILE N>0 THEN DO
    [ N; D] _ N DIVMOD 10; INC C
    [ H; L] _ [ H; L] DSHL 4;  L BOR _ D
  END
  PUT($ );  IF S#0 THEN PUT($-)
  WHILE DEC C >= 0 THEN DO
    PUT( L BAND HEX F + $0);  [ H; L] _ [ H; L] DSHR 4
  END
  RETURN
END DOUT

LOCAL %FORM.LINES, %SET.LINE, %LJLIT, %RJINT, %WRITE.LINE, %PUTCH
%FORM.LINES

  DEF CPL AS 132
  LOCAL B( 0: CPL),  P, C, HPTR
  LOCAL %TRIM

  %SET.LINE
    MOVE CPL+2 FROM ALL $  TO B;  HPTR _ 0;  RETURN
  END SET.LINE

  %PUTCH( L, T)
    IF 0<=T<=CPL THEN [B(T) _ L; HPTR _ HPTR MAX T]
    RETURN
  END PUTCH

  %LJLIT( L(), T)
    P _ CHPT( L, -1);  DEC T;  T _ T MAX 0
    WHILE C_NCHV P # EOLIT AND INC T<=CPL THEN B(T) _ C
    HPTR _ HPTR MAX T;  RETURN
  END LJLIT

  %TRIM
    B(0) _ 1;  HPTR _ HPTR MIN CPL;  WHILE NOT TABCHAR#B(HPTR)#$  THEN DEC HPTR
    RETURN
  END TRIM

  %WRITE.LINE(FILE)
    TRIM;  FOR P_1 TO HPTR W( FILE, B(P));  RETURN
  END WRITE.LINE

  %RJINT( N, T)
    LOCAL S

    S _ [N<0];  N _ABS N;  HPTR _ HPTR MAX T
    LOOP DO
      WHILE 1<=T<=CPL
      [ N; B(T)] _ N DIVMOD 10;  B(T) +_ $0;  DEC T
      WHILE N>0
    END
    IF S#0 AND 1<=T<=CPL THEN B(T) _ $-
    RETURN
  END RJINT
END FORM.LINES


%RJ.DOL(N, L,DP)
LOCAL H,S,D,C
  C _ H _ 0; S _ [N<0]; H _ ABS N
  IF S # 0 THEN PUTCH($-,L)
  REPEAT DP DO
        [H; D] _ H DIVMOD 10; PUTCH(D+$0, DEC L)
  END
  PUTCH($., DEC L)
  WHILE H>0 THEN DO
        [H;D] _ H DIVMOD 10
        PUTCH(D+$0, DEC L)
  END
  RETURN
END RJ.DOL

DEF TYP.CR AS MSG("$")


LOCAL %BINSRCH, %SRCH, %YNQ


%YNQ(LIT)
TABLE YNQT(0:2)['YES','NO','QUIT']
LOCAL P,T
A:  MSG(LIT); T _ CK.LIST(P _ GETLINE(TEL), YNQT, 3)
  IF T=0 THEN [MSG('TYPE YES OR NO.'); GO A] 
  RETURN T
END YNQ
FIND %LOG

%SRCH(TARGET, A(), N)
LOCAL I
  I _ -1
  WHILE INC I < N THEN DO
  IF A(I)=TARGET THEN RETURN INC I
  END
  RETURN 0
END  SRCH

%BINSRCH(TARGET, B(), N, SZ)
 LOCAL C,M,STEP
  DEF A(I) AS B(SZ*I)
  IF TARGET>A(N) THEN RETURN [N+1; 0]
  C _ IF N<4 THEN 1 ELSE LOG(N)-1
  [STEP; M] _ [0; HEX 80.00.00.00.1] DSHL C; DEC M
  REPEAT C DO
    IF M<N AND TARGET > A(M) THEN  M _ M+STEP ELSE M_ M-STEP
    STEP _ STEP SHR 1
  END
  IF A(M) < TARGET OR M=0 THEN INC M
  RETURN [M; [A(M)=TARGET]]
END BINSRCH

LOCAL %SIC

%SIC(P, BADC:)
  LOCAL N,C
  N _ 0
  WHILE C _ NCHV P # CARRET THEN DO
    IF C=EOLIT THEN RETURN N
    IF -1<C_C-$0<=9 THEN N _ N*10+C ELSE GO BADC
  END
  RETURN N
END SIC

%BMP.DOWN(F(), T())
LOCAL J,K,X
  K _ T-F; J_0; X_F(0)
  WHILE DEC K>=0 THEN X<=> F(INC J)
RETURN
END BMP.DOWN



!PIT  -  PRODUCTS ITEMS TRANSACTIONS

%PIN

LOCAL %CK.PR, %RJ.STR, %MSP, %RD.NAM, %MK.LIT
LOCAL %WR.OUT, %GCUS, %CK.PL, %CK.STAT
LOCAL PROD, PTYP, KILL:, KIL:
LOCAL %R.IBLK, %W.IBLK, %UPDT, %GPR, %GSN, %PRMP, %G.MSG, %CRD, %CRDIN
LOCAL %GPL, %SRCH.TR, %SCRD, %STRTYM, %SRC.ST, %NSRC.ST
LOCAL %CK.QB, %SKP, %MOV.CHARS, %CNV.DATE
LOCAL %VALID, %GET.IBLK, %CK.SM, %HASH, %RD.MANS
LOCAL %CK.OWN, %PRDATE

DEF I.SZ AS 9   !NO OF WORDS FOR EACH ITEM
DEF SZ2 AS 2
DEF SZ AS 3571
DEF SN.MAX AS 11 !MAX NO CHARS IN SERIAL NO. + CR
DEF SCH.MAX AS 5 !MAX NO CHARS IN SCHEDULE NO. +CR
DEF PR.MAX AS 5  !MAX CHARS IN PRODUCT + CR
DEF OWN.MAX AS 4  !MAX CHARS IN OWNER, VENDOR NAME + CR
DEF STAT.MAX AS 5  !MAX STATUS + CR
DEF PO.MAX AS 21  !MAX P.O. +CR
DEF CBLKS AS 60  !GRAB CBLKS IN CORE

LOCAL IFSZ, IEOF:, I.BEG, IC, B(), FR.ORG, H(), INW, LEOF, YN
LOCAL NOSPC:, TEM, IFT, I, BUF.BEG, IT(1:3), SCH, PNL(), P, P1, P2, NPN:
LOCAL ITMBLK(0:255), CP, ENDR:, IF.END, TNPN:
LOCAL IFN, I.BLKS, ITEM(), SN(0:2), BLK.NO, BUF.END, PL.BEG, PL.CNT
LOCAL MODEL, ST.BEG, ST.CNT, PROD.BEG, PROD.CNT, OWN.BEG, OWN.CNT
LOCAL EOF.ITM, BLKR(SZ)

DEF IMOD AS ITEM(0)
DEF ISN AS @ITEM(1)
DEF ITS1 AS ITEM(1)
DEF ITS2 AS ITEM(2)
DEF ISCH AS ITEM(3)
DEF IOWN AS ITEM(4)
DEF IDDT AS ITEM(5)
DEF ITDT AS ITEM(6)
DEF ICST AS ITEM(7)
DEF ITRA AS ITEM(8)

LOCAL TITEMS(0:I.SZ), PTRAN !PTR TO TRANS RECS
DEF TMOD AS TITEMS(0)
DEF TSN AS @TITEMS(1)
DEF TTS1 AS TITEMS(1)
DEF TTS2 AS TITEMS(2)
DEF TSCH AS TITEMS(3)
DEF TOWN AS TITEMS(4)
DEF TDDT AS TITEMS(5)
DEF TTDT AS TITEMS(6)
DEF TCST AS TITEMS (7)
DEF TITRA AS TITEMS(8)

LOCAL %WR.THDR, %RD.THDR, %RD.TR, %WR.TR, %GTRB
LOCAL TR.CP, TR.BL1(0:128), TR.BLK(0:255)

DEF TR.SZ AS 20   !SIZE OF TRANSACTION RECORDS
LOCAL TEM.TR(0:TR.SZ), SAV.TR(0:TR.SZ), PREV.TR, SPEC.PR
DEF SAV.FDT AS SAV.TR(3)
DEF SAV.STAT AS SAV.TR(15)
DEF SAV.FPTRA AS HW(@SAV.TR(17),1)
DEF TRID AS TEM.TR(0)           !CUST ID INCLUDING P&L IN HIGH ORDER
DEF TR.LBILL AS TEM.TR(1)       !LAST BILLING DATE
DEF TR.DATE AS TEM.TR(2)
DEF TR.FDT AS TEM.TR(3)
DEF TR.MOD AS TEM.TR(3)   !MODEL  # FOR MAIN, FR, ETC
DEF TR.TAX AS TEM.TR(4)        !TAX IS 0 FOR MAIN, FREIGHT, INSTAL
DEF TR.PRICE AS TEM.TR(5)
DEF TR.PO AS @TEM.TR(6)
DEF TR.SM AS TEM.TR(10)
!DEF TR.USE AS @TEM.TR(11)
DEF TR.QTY AS TEM.TR(11)
DEF TR.ST AS TEM.TR(14)
DEF TR.STAT AS TEM.TR(15)
DEF TR.SERIAL AS @TEM.TR(15)  !  SERIAL # FOR INST, MAN, ETC.
DEF TR.BPTR AS TEM.TR(17)
DEF TR.UPDT AS TEM.TR(18)
DEF TR.SCRP AS TEM.TR(19)



DEF HD.SZ AS 4

LOCAL TRANS(), TFN, HD.BL(0:HD.SZ)

DEF TR.EOF AS HD.BL(1)          !LOGICAL EOF
DEF FR.BEG AS HD.BL(0)          !PTR TO FIRST FRRE BLK-0IF NONE
DEF FR.NXT AS TRANS(0) !1ST WD OF FREE BLK CONTAINS PTR TO NXT FREE BLK

DEF T.ID AS TRANS(0)
DEF T.LBILL AS TRANS(1)
DEF T.DATE AS TRANS(2)
DEF T.FDT AS TRANS(3)
DEF T.MMOD AS TRANS(3)
DEF T.TAX AS TRANS(4)
DEF T.PRICE AS TRANS(5)
DEF T.PO AS @TRANS(6)
DEF T.SM AS TRANS(10)
!DEF T.USE AS @TRANS(11)
DEF T.QTY AS TRANS(11)
DEF T.ST AS TRANS(14)
DEF T.STAT AS TRANS(15)
DEF T.SERIAL AS @TRANS(15)
DEF T.BPTR AS TRANS(17)
DEF T.SCRP AS TRANS(19)

  DEF MAN.MAX AS 2000   !ALLLOW 2000 NUMBERS FOR MANUALS
LOCAL MAN(MAN.MAX)
LOCAL MPL, TRPL, PL, NAFN, EOF.ADR, INSN, LASTR

TABLE TRTBL(0:11)['CUSTOMER #','STATUS','SALESMAN #',&
'PRICE','TAX','P.O. DATE','P.O. NUMBER','GSA?',&
'TRANSACTION DATE','TERMINATION DATE','BILLABLE?','QUANTITY']

TABLE MANS(0:2)['SERIAL #','MANUAL #','SUPPLY #']
TABLE ITMS(1:8)['PRODUCT','SERIAL #','SCHEDULE #', &
                'OWNER','DEL DATE','TERM DATE','TYM COST']


LOCAL NAD(), NAD.MAX, NBK, NBUF(), FBEG, JNADR, NA.EOF, PT.SN, UPD, SERN(0:2)

  MSG('$$$PRODUCT INVENTORY UPDATE.  VERS 1.0$$$')
  TEM _ 1  !PHONY TAG FOR TEM
  BUF.BEG _ (H_ BLOCK(CBLKS, 0, NOSPC))+SZ; BUF.END _ H+CBLKS*131
  MOVE SZ FROM ALL 0 TO H
  IF TEM = 1 THEN IFN _ OPEN ('ITEM.DAT',DIRECT+WORD+UPDATE,NPN) ELSE &
    IFN_OPEN('ITEM.DAT',DIRECT+WORD+INPUT,NPN)
BZ:  SET.RWE(IFN,IEOF); SET.CP(IFN,0)
  IF IFSZ _ SIZE(IFN) =0 THEN WDB(IFN, 256, H)

  TFN _ OPEN('TRANS.DAT',DIRECT+WORD+UPDATE,TNPN)
  IF SIZE(TFN)=0 THEN [MOVE 256 FROM ALL 0 TO TR.BLK; TRBLK(1)_1; &
        SET.CP(TFN,0); WDB(TFN,256,TRBLK)]
  RD.THDR(0)

  BLKNO _ IFT_1; INW _ 256*I.SZ  !CAUTION FIX TEST HERE
 RIF:   RDB(IFN, INW, B _  I.BEG_BUF.END-INW)
 DN:  I _ 0; WHILE I<INW THEN DO
        IF B(I) = 0 THEN GO ENDR
        CH(SERN,10) _ CARRET
        MOVE 2 FROM @B(I+1) TO SERN
       IF B(I+1) BOR B(I+2) #0 THEN &
        [P _ CHPT(SERN,-1); HASH(P)] &
       ELSE [P _ CHPT(@B(I+3),-1); HASH(P)]
       I_I+I.SZ; INC BLK.NO
      END
       IC _ IC+I; IF IFT>0 THEN GO RIF

ENDR: EOF.ITM _ BLK.NO; ERMS('$NO OF PRODUCTS = '); DOUT(BLK.NO)
        MSG('$LAST PRODUCT: '); PRINT(@B(I-ISZ))
        MSG('$LAST SN: '); PRINT(@B(I-ISZ+1))
        VALID
       NAD _ F.BEG; NBUF _(NAD.MAX _ (BUF.END-F.BEG)/2) + F.BEG
       [NBK; ] _(BUF.END - NBUF) DIVMOD 128; NAD.MAX _ NAD.MAX/SZ2
EOF.ADR_ RD.NAM(NAD, NBUF, NBK); MSG('$$NAME.ADR BUF= '); DOUT(NAD)
        MSG('$NAME.ADR EOF= '); DOUT (EOFADR)
        MSG('$BUF.END= '); DOUT(BUF.END)
        MSG('$JNADR= '); DOUT(JNADR); MSG('$$')

    RDMANS; CRDIN; UPDT; EXIT

TNPN: ERMS('CANT OPEN TRANS.DAT DATA BASE$$'); EXIT
NPN:  ERMS('CANT OPEN PRODUCT DATA BASE'); EXIT
IEOF:  IF ERRNUM # 10 THEN [PRINT('IFN'); DOUT (ERRNUM); EXIT]
       INW _ IFSZ-IC; DOUT(INW); IFT_0; GO DN
NOSPC:  PRINT('CANT GRAB CORE'); EXIT


  LOCAL LNZ, LNO, OLDB, STN:, PRM:, STP:, ITE(0:I.SZ), STG:, PRV:
  LOCAL CHNG, ILN:, NTRA:, CHNG1, PI1, YNA, TP, NEW.TR, SAV.TITRA
  LOCAL SAV.BLK

  DEF PT.MAX AS 7  !NO OF DIFF TYPES OF PRODUCTS, MAN, SUPP, INST, ETC

DEF BIL.BIT AS HEX 4000.0000.0
DEF CBIL.BIT AS HEX BFFF.FFFF.F
DEF GSA.BIT AS HEX 8000.0000.0
DEF CGSA.BIT AS HEX 7FFF.FFFF.F

TABLE SN.SPEC(0:PT.MAX)['TYM','99999','99998','99997','99996', &
'99995','99994']
TABLE STATBL(0:4)['SPCR','SNCR','NPCR','NNCR']

%UPDT
TABLE YN.TB(0:1)['Y$','N$']
TABLE LINE(0:9)[0, OCT 1000001, OCT 3000000, OCT 4000002, OCT 7000003,&
OCT 7000000, OCT 10000004, 5, 6, 7]
DEF LNL(X) AS HW(@LINE(X),0)
DEF LNR(X) AS HW(@LINE(X),1)

LOCAL FV:, FV1:, BFI(0:1), NS:, EJ:, PT, SVID, BLK.SPC, PS
BUP:  ALT.LOC _ KILL; OLDB _ PT.SN _ CHNG _ 0; UPD _ EJ
      MOVE TR.SZ FROM ALL 0 TO TEM.TR; SN(0) _ SN(1) _ 0
STP: GPR(STP); TMOD _ IMAGE(0); IF CHNG=1 THEN GO ONE
     MOVE I.SZ-1 FROM ALL 0 TO TITEMS+1

  DO PTYP OF 0: PT.MAX
0: 1:2: STN:  GSN(STP)
STG:  IF SN(0)=0 THEN[ERMS('YOU MUST ENTER A SERIAL #.$'); GO STN]
        NEW.TR _ [NOT (OLDB _ GET.IBLK(P))]; MOVE 2 FROM SN TO TSN
        IF OLDB=0 THEN PT.SN _ CHPT(TSN,-1)

        EIF CHNG=1 AND OLDB=0 THEN DO
          TITRA _ SAV.TITRA; IF OLDB_SAV.BLK#0 THEN [ &
        R.IBLK(SAV.BLK); MOVE ISZ-3 FROM ITEM+3 TO TITEMS+3]
          GO ONE
        END
        ORIF CHNG=1 THEN [ERMS('$THERE IS ALREADY A PROD FOR THIS&
 SERIAL NO.'); GO KILL]
        ELSE LNO _ 4
PRV: DEC LNO
PRM:  DO LNO OF 3:6
    3:  G.MSG(LNO, ITMS(4),3, @TOWN, STG, 0, -OWN.MAX)
        IF CK.OWN=0 THEN [TOWN _ 0; GO PRM]
    4:  G.MSG(LNO, 'TRANS DATE', 4, @TDDT, PRV, 0, 9)
    5:  G.MSG(LNO, 'TERM DATE', 4, @TTDT, PRV, 0, 9)
    6:  GMSG(LNO, ITMS(7), 2, @TCST, PRV, 'ILLEGAL FORMAT FOR COST', 0)
   END
    IF CHNG=1 THEN GO ONE
    IF INC LNO<7 THEN GO PRM

TRN:   DO YNQ('$ANY CHANGES? ') OF 0:3
 0: 3:  MSG('TYPE YES OR NO$'); GO TRN
ONE:1:  CHNG _ 1; MSG('$TYPE LINE #: '); SAV.TITRA_TITRA
        EIF 2 < LNO_ SIC(P_GETLINE(TEL), ILN) < 7 THEN GO PRM
        ELSE DO
          SAV.BLK _ OLDB; IF LNO=1 THEN GO STP ELSE GO STN
        END
    2:  GO NTRA
    END


3:4:5:  ERMS('ILLEGAL PRODUCT$'); GO BUP

    6: STRTYM; NEW.TR _ 1
       MOV.CHARS(EOLIT, OWN.MAX, RETURN)
FV:  PS_P2_CHPT(TSN,-1); P1_CHPT(SN.SPEC(PTYP),-1)
     MOV.CHARS(EOLIT, SN.MAX, FV1)

FV1:  IF PTYP > 2 THEN DO
     G.MSG(2, 'MODEL #',3, @TR.MOD, STP, 0, -PR.MAX)
    IF CKPR#0 THEN [ERMS('ILLEGAL MODEL #.$'); TR.MOD _ 0; GO FV1]
    G.MSG(3, ITMS(2), 3,  SN, FV1, 0, SNMAX)
    MOVE 2 FROM SN TO TR.SERIAL
    IF ^TR.SERIAL =0 THEN [ERMS('YOU MUST ENTER THE SERIAL #.$'); GO FV1]
    END

    SPEC.PR _ NEW.TR _ 1; MOVE 2 FROM TSN TO SN
    IF OLDB _ GET.IBLK(PS) #0 THEN MOVE I.SZ FROM ITEM TO TITEMS &
        ELSE PT.SN _ CHPT(TSN,-1)

FVA:  EIF YN _ YNQ('ANY CHANGES? ')=1 THEN GO BUP
  FIF YN#2 THEN [ERMS('TYPE Y OR N$'); GO FVA]

FV2:  EIF YN _ YNQ('NEW TRANSACTION? ')=2 THEN DO
      IF BLK.SPC _ SRCH.TR=0 THEN &
 [ERMS('THERE IS NO PREVIOUS TRANSACTION FOR THIS MODEL & SERIAL #$'); GO FV2]
      NEW.TR _ 0; MOVE TR.SZ FROM TRANS TO TEM.TR
      END
    FIF YN#1 THEN [ERMS('TYPE Y OR N$'); GO FV2]
     GO LSL
    END
ILN:  IF NCHV P = $Q AND GLCNT=2 THEN GO NTRA
        ERMS('$ILLEGAL LINE NUMBER'); GO ONE

KIL:   ERMS('READ/WRITE ERROR. TRANSACTION DATA BASE.$')
KILL:  ERMS('UPDATE ABORTED$'); ONALT; RD.THDR(0); GO BUP

NTRA:   LASTR _ SPEC.PR _ CHNG _ 0; PI1 _ 1
        MOVE TR.SZ FROM ALL 0 TO TEM.TR

       IF TITRA # 0 THEN DO
Z1:     EIF TP _ YNQ('$NEW TRANSACTION? ') =1 THEN NEW.TR _ 1
        ORIF TP =2 THEN DO
          NEW.TR _ 0; IF LASTR _ SRC.ST=3 THEN GO NTRA
        END

        ELSE [MSG('TYPE YES OR NO.'); GO Z1]
       END ELSE NEW.TR _ 1

LSL:  LNZ _ 1; LNO _ 2
LSTLN:  DEC LNO
TRQ:  DO LNO OF 1:11
  1:  SVID _ TRID; [PT; SVID] _ TRID DIVMOD 10000
      SVID _ SVID*100 + PT
      G.MSG(LNZ, TRTBL(0), 1, @SVID, LSTLN, 'ID ERROR', 0)
      [SVID; PT]_ SVID DIVMOD 100; TRID_ SVID + PT*10000
        IF GCUS(TRID)=0 THEN [TRID _ 0; GO TRQ]
  2:  IF SPEC.PR=0 THEN DO
      G.MSG(LNZ, TRTBL(1), 3, @TRSTAT, LSTLN,0, -STAT.MAX)
        IF CKSTAT(TR.STAT)=0 THEN [TR.STAT _ 0; GO TRQ]
       END
  3:  G.MSG(LNZ, TRTBL(3), 2, @TR.PRICE, LSTLN, 'ILLEGAL FORMAT FOR PRICE', 0)
  4:  G.MSG(LNZ, TRTBL(8), 4, @TR.DATE, LSTLN)
  5:  IF SPEC.PR=0 THEN G.MSG(LNZ, TRTBL(9), 4, @TR.FDT, LSTLN)
  6:  G.MSG(LNZ, TRTBL(4), 5, @TR.TAX, LSTLN, 'INCORRECT TAX FORMAT')
  7:  G.MSG(LNZ, TRTBL(6), 3, TRPO, LSTLN, PO.MAX-1,PO.MAX)
  8:  EIF NEW.TR BOR CHNG=1 THEN DO
     EIF G.MSG(LNZ, TRTBL(7), 6, BFI, LSTLN, 0, 5)= 1 THEN &
     TR.UPDT _ TR.UPDT BOR GSA.BIT
     ELSE TR.UPDT _ TR.UPDT BAND CGSA.BIT
     GO ND
     END

     ORIF TR.UPDT < 0 THEN BFI(0) _ ^YN.TB(0)
     ELSE BFI(0) _ ^YN.TB(1)
     G.MSG(LNZ, TRTBL(7), 3, BFI, LSTLN, 0, 5)
  9:  EIF NEW.TR BOR CHNG=1 THEN DO
      IF G.MSG(LNZ,TRTBL(10), 6, BFI, LSTLN, 0, 5)=1 THEN &
      TR.UPDT _ TR.UPDT BOR BIL.BIT ELSE TR.UPDT _ TR.UPDT BAND CBIL.BIT
      GO ND
      END
      ORIF TR.UPDT BAND BIL.BIT #0 THEN BFI(0)_ ^YN.TB(0)
      ELSE BFI(0) _ ^YN.TB(1)
      G.MSG(LNZ, TRTBL(10), 3, BFI, LSTLN, 0, 5)
 10:  IF 0<PTYP<3 THEN G.MSG(LNZ, TR.TBL(11), 1, @TR.QTY,LSTLN,0,0)&
      ELSE TR.QTY _ 1
 11:  NULL !ADD STATE CODE
 END

ND: IF CHNG=1 THEN GO UNO
ND1:  LNZ _ INC LNO; IF SPEC.PR=1 THEN LNZ_ LNR(LNO)
  IF LNO < 12 THEN GO TRQ
    
  IF LASTR=2 THEN DO
RGN:    EIF YN _ YNQ('IS THIS THE CORRECT TRANSACTION? ') = 2 THEN&
        IF NSRC.ST=3 THEN GO NTRA ELSE GO LSL
        FIF YN#1 THEN GO RGN

  END

ENTRA:  LASTR_0; DO YNA _ YNQ('$ANY CHANGES? ') OF 0:3
        0:3: MSG('TYPE YES OR NO$'); GO ENTRA
UNO:    1:  CHNG _ 1; MSG('TYPE LINE #  ')
           P_GETLINE(TEL); IF CH(IMAGE,0)=$Q AND GLCNT=2 THEN GO FINUP
           LNZ _ LNO _ SIC(P,NS)
        IF SPEC.PR=1 THEN DO
           IF 0<LNO<9 THEN [LNO_LNL(LNO); LNZ_LNR(LNO); GO TRQ]
         END ELSE IF 0<LNO<12 THEN GO TRQ
NS:        ERMS('$ILLEGAL LINE #'); GO UNO
FINUP:  2:  EIF PTYP=6 THEN TR.SCRP_CRD
             ORIF PTYP = 2 THEN TR.SCRP_SCRD
             FIF CKLIST(CHPT(@TR.STAT,-1),STATBL,4)#0 THEN TR.SCRP_CRD
        WROUT(PT.SN); GO BUP
        END

EJ:  CLOSE.ALL; ERMS('$$UPDATE TERMINATED.'); EXIT

END UPDT

%STRTYM
LOCAL A:
  P2 _ CHPT(@TOWN,-1); P1_ CHPT(SN.SPEC(0),-1)
  MOV.CHARS(EOLIT, OWN.MAX, A)
A: RETURN
END STRTYM

%WROUT(PTSN)
LOCAL BLK
  IF OLDB = 0 THEN [ R.IBLK(BLKNO _EOF.ITM); INC EOF.ITM]
  MOVE I.SZ FROM TITEMS TO ITEM
  EIF NEW.TR = 1 AND TITRA # 0 THEN DO   !NEW AND OLD TR
    RDTR(TITRA); MOVE TR.SZ FROM TRANS TO SAV.TR
    IF SPEC.PR=0 THEN DO
        IF SAV.FDT#0 AND SAV.STAT=^('LEAS ') BAND HEX F.FFFF.FF00 &
        BOR OCT 32 AND SAV.STAT=TR.STAT &
    THEN [SAV.FDT _ TR.DATE; MSG('OLD TRANS TERMINATED$')]
        END

! NEW DATE IS TERM DATE FOR OLDTR
    BLK _ TR.BPTR _ GTRB   !NEW BLK TO BACK PTR OF NEW TRANS
    MOVE TR.SZ FROM SAV.TR TO TRANS
    WR.TR(BLK); W.IBLK(CP); RD.TR(TITRA)
    MOVE TR.SZ FROM TEM.TR TO TRANS; WR.TR(TITRA)
   END

!OLD TRANS REC WAS MODIFIED - COULD BE WAY BACK
  ORIF NEW.TR=0 THEN DO
    MOVE TR.SZ FROM TEM.TR TO TRANS; WR.TR(PTRAN)
    W.IBLK(CP)
   END

  ELSE DO
    ITRA _ BLK _ GTRB !NEW ONLY, NO OLD
    MOVE TR.SZ FROM TEM.TR TO TRANS
    W.IBLK(CP); WR.TR(BLK); WRTHDR
   END
  IF PT.SN#0 THEN HASH(PT.SN); RETURN
  RETURN
END WR.OUT

%GCUS(CUS)
 LOCAL SLOT, FND, YN, CPNA, EOF:, PLCC, ID, J1, J2, MONE, FST
  IF CUS=0 THEN RETURN 1; FST _ MONE _ -1
  [PLCC; ID] _ CUS DIVMOD 10000
  IF CK.PL(PLCC)=0 THEN RETURN 0
  IF ID=0 THEN RETURN 1

  [SLOT; FND] _ DOUBLE BINSRCH(CUS, NAD, JNADR, SZ2)
  IF FND=1 THEN RETURN 1
  SET.RWE(NAFN, EOF)
  SET.CP(NAFN, CPNA _ EOF.ADR)
  ERMS('ID NOT IN NAME.ADR FILE.$')

A:  EIF YN _ YNQ('$IS THIS A NEW CUSTOMER?  ')=2 THEN RETURN 0
    FIF YN#1 THEN [ERMS('TYPE Y OR N'); GO A]
B:  MSG('TYPE NAME AND ADDRESS. TYPE Q FOLLOWED BY A CARRIAGE RETURN WHEN THRU.$')
C:  GET.LINE(TEL); IF GLCNT > 57 THEN &
[MSG('LINE CANT HAVE MORE`THAN 56 CHARS. RETYPE THIS LINE ONLY.$'); GO C]

  IF CH(IMAGE,0)=$Q AND GLCNT=2 THEN DO
D:  EIF YN_YNQ('IS NAME/ADR CORRECT?  ') = 2 THEN &
    [MSG('RETYPE WHOLE NAME & ADR.$'); SETCP(NAFN, EOF.ADR _  CPNA); &
        FST_ -1; GO C]
    FIF YN#1 THEN [ERMS('TYPE Y OR N'); GO D]
    J1 _ SLOT*SZ2-1; J2_JNADR*SZ2+2; INC JNADR
    REPEAT SZ2 BMP.DOWN(@NAD(INC J1), @NAD(IN)
    NAD(J1 _ SLOT*SZ2) _ CUS; NAD(INC J1) _ CPNA
    FOR J1_1 TO 128 W(NAFN, MONE); EOF.ADR_EOF.ADR+2
    RETURN 1
  END
  IF INC FST = 0 THEN W(NAFN,CUS); WB(NAFN, 12, IMAGE)
  EOF.ADR_EOF.ADR+12; GO C
EOF:  ERMS('NAME.ADR FILE: ERRNUM = '); DOUT(ERRNUM); EXIT
END GCUS

%CK.PL(PL)
  IF SRCH(PL, PL.BEG, PL.CNT)#0 THEN RETURN 1
  ERMS('NOT A VALID P&L CODE IN ID #.$'); RETURN 0
END CK.PL

%CK.STAT(STAT)
  IF STAT=0 THEN RETURN 1
  IF SRCH(STAT, ST.BEG, ST.CNT)#0 THEN RETURN 1
  ERMS('NOT A VALID STATUS CODE$'); RETURN 0
END CKSTAT

!SEARCH THRU TRANS RECORDS TO FIND MATCH OF PR&SN
%SRC.ST   !SEARCH THROUTGH OLD TRANS RECS FOR PARTICULAR STATUS
LOCAL STAP, TYP
  RD.TR(PTRAN_TITRA); IF T.BPTR=0 THEN [MOVE TR.SZ FROM TRANS &
        TO TEM.TR; RETURN 1]

A:  MSG('TYPE STATUS OF TRANSACTION DESIRED: '); GETLINE(TEL)
    IF GLCNT> 5 THEN GO C
    IF TYP _ SRCH(IMAGE(0),ST.BEG, ST.CNT)=0 THEN GO C
B:  STAP _ SRCH(T.STAT, ST.BEG, ST.CNT)
    IF STAP = TYP THEN [MOVE TR.SZ FROM TRANS TO TEM.TR; RETURN 2]

%%NSRC.ST
    IF T.BPTR = 0 THEN [ERMS('STATUS TYPED IS NOT IN OLD TRANSACTION.$');&
     RETURN 3]

    RD.TR(PTRAN_T.BPTR); GO B
C:  ERMS('ILLEGAL STATUS$'); GO A
END SRC.ST

%SRCH.TR
LOCAL XP
  IF XP _ TITRA = 0 THEN RETURN 0
NX:  RD.TR(XP)
    IF PTYP>2 AND TR.MOD#T.MMOD THEN GO XT
    IF ^TR.SERIAL=^T.SERIAL AND ^(TR.SERIAL+1)=^(T.SERIAL+1) THEN RETURN XP
XT:  IF XP _ T.BPTR # 0 THEN GO NX
  RETURN 0
END SRCH.TR

%GPR(LBL)
A:  PRMP(1,ITMS(1)); IF CK.QB(LBL)=0 THEN GO B; IF GLCNT>PR.MAX THEN GO B
    IF 0<=PTYP_CK.PR <PT.MAX THEN RETURN
B:  ERMS('NOT A VALID PRODUCT$'); GO A
END GPR


%CK.PR
  LOCAL M
  TABLE MSTBL(0:5)[' MAN','SUPP','MAIN','FRGT','INST','CRED']
  RJ.STR(IMAGE,PR.MAX)
  M _ SRCH (IMAGE(0), PROD.BEG, PROD.CNT)
  IF M=0 THEN RETURN -1
  RETURN  CKLIST(P, MSTBL, PT.MAX)
END CK.PR

%GPL
LOCAL B:, A:
 A:  PRMP(9, @TRTBL(1))
     EIF CHNG1 > 0 THEN NULL
     FIF TRPL>0 THEN [DOUT(TRPL); RETURN 1]
     IF CK.QB(A)=0 THEN [ERMS('YOU MUST TYPE A P&L OR Q$'); GO A]
     IF NOT 9< MPL _ SIC(P, B) < 100 THEN GO A
!    IF PL(MPL)#0 THEN RETURN 1
 B:  ERMS('NOT A VALID P&L$'); GO A
END GPL

%PRMP(NO, L())
  SETLINE; RJ.INT(NO,2); LJLIT(L,4); WRITE.LINE(TEL); MSG(':  ')
 RETURN
END PRMP

%G.MSG( L, LIT(), TYP, @VAR, LBL:, EM(), MAX.CH)
!L=LINE #
!LIT=PRMT MSG
!TYP  1=INT, 2=$, 3=ASCII, 4=DATE
!VAR  TESTS THIS FOR 0, IF SO INPUT FROM TTY
!LBL FOR ^
!EM=ERMSG TO BE PRINTED
!MAX NO CHARS ALLOWED,  IF - THEN RJ STRING, TAKE OFF LEADING 0
LOCAL B:, TRU, MX, ER:, Y, BUF(0:4), I
TABLE YESNO(0:1)['YES','NO']
  TRU _ [MAX.CH<0]; MX_ ABS MAX.CH
A:  PRMP(L,LIT)
    IF TYP = 6 THEN DO
    IF CK.QB(LBL)=0 THEN GO A1
    IF Y _ CKLIST(P, YESNO, 2)#0 THEN RETURN Y
A1: [ERMS('TYPE Y OR N$')]; GO A
    END

    EIF CHNG>0 THEN GO C
    ORIF VAR # 0 OR NEW.TR = 0 THEN DO TYP OF 1:5
        1:  DOUT(VAR); MSG('$')
        2:  SETLINE; RJ.DOL(VAR,10,2); PUTCH(CARRET, 12); WRITE.LINE(TEL)
        3:  IF EM#0 THEN [MKLIT(@VAR,BUF,EM); MSG(BUF)] ELSE MSG(@VAR)
        4:  PR.DATE(VAR)
        5:  SET.LINE; RJ.DOL(VAR,10,3); PUTCH(CARRET,12); WRITELINE(TEL)
      END
    ELSE DO
C:      IF CK.QB(LBL)=0 THEN RETURN 0
        DO TYP OF 1:5
        1:  VAR _ SIC(P,ER)
        2:  VAR _ DOLIN(P,ER,2)
        3:  IF GLCNT>MX THEN GO B
            P1 _ P; P2 _ CHPT(@VAR,-1)
            IF TRU = 1 THEN DO
            SKP($ ); SKP($0); MOV.CHARS(CARRET,MX,B)
            RJ.STR(@VAR,MX)
            END ELSE DO
                EIF EM=0 THEN MOV.CHARS(CARRET, MX,B)
                ELSE FOR I_1 TO EM NCHV(P2)_NCHV(P1)
             END
        4:  IF VAR _ CNV.DATE = 0 THEN GO A
        5:  VAR _ DOLIN(P,ER,3)
    END
   END
    RETURN
ER: ERMS(EM); GO A

B:  ERMS(LIT); MSG(' CANT HAVE MORE THAN '); DOUT(MX-1)
    MSG(' CHARACTERS.$'); GO A
END G.MSG

%ERMS(LIT)
  MSG("\G"); CLIBUF; MSG(LIT); RETURN
END ERMS

%MK.LIT(L1,L2,CNT)
LOCAL P1,P2,C,CAR
  C_-1; P1 _CHPT(L1,-1); P2_CHPT(L2,-1)
  WHILE INC C<CNT THEN DO
        CAR _ NCHV(P2) _ NCHV(P1)
        IF CAR=CARRET THEN RETURN
  END
     NCHV(P2) _ CARRET; RETURN
END MKLIT

%RJ.STR(LIT,NCHAR)
 LOCAL P3,P2,P1
 [P1; P2] _ DOUBLE MSP(LIT); P3 _ CHPT(LIT,NCHAR-1); CHV P3 _ CARRET
  NCHV P1
 WHILE P1#P2 THEN PCHV P3 _ PCHV P2
 WHILE P1 # P3 THEN PCHV P3 _ $ 
RETURN
END RJ.STR

%MSP(BF())
 LOCAL P3,P4
  P4_P3_CHPT(BF,-1)
  UNTIL(NCHV P4 = CARRET)
  RETURN [P3; P4]
END MSP

%GSN(LBL)
LOCAL BN:
A:  DO PTYP OF 0:PT.MAX
       0:  PRMP(2, ITMS(2))
       1:  PRMP(2, MANS(1))
       2:  PRMP(2, MANS(2))
 3:4:5:6: HALT
    END
    CK.QB(LBL)

  IF NOT 0 < GLCNT <= SN.MAX THEN &
       [PRINT(MANS(PTYP)); ERMS(' CAN NOT CONTAIN MORE THAN 10 CHARS.$'); GO A]
      MOVE 2 FROM IMAGE TO SN
  IF SN(0)=0 THEN [ERMS('YOU MST ENTER A '); PRINT(MANS(PTYP-1));GO A]
    IF PTYP=1 THEN DO
    IF 0 < INSN_ SIC(P,BN) < MAN.MAX THEN [T.CST_MAN(INSN); STRTYM] &
    ELSE GO BN
  END
  RETURN
BN:  ERMS('ILLEGAL MANUAL #'); GO A
END GSN
%CK.OWN
LOCAL M
  IF TOWN=0 THEN RETURN 1
  IF SRCH(TOWN, OWN.BEG, OWN.CNT)#0 THEN RETURN 1
  ERMS('NOT A VALID OWNER$'); RETURN 0
END CK.OWN



%PRDATE(DATE)
LOCAL D,M,Y
  IF DATE=0 THEN [MSG('$'); RETURN]
  [Y; M] _ DATE DIVMOD 10000
  [M; D] _ M DIVMOD 100
  DOUT(M); PUT($/); DOUT(D); PUT($/); DOUT(Y); MSG('$'); RETURN
END PRDATE





%RD.MANS
LOCAL MFN, MNOPN:, MER:, MNO(0:2), N, P3, EOF:
  MFN _ OPEN('MANSUP', SEQUEN+INPUT+CHARACTER, MNOPN, 1)
  SET.RWE(MFN, EOF)
A:  P _ P1 _ GETLINE(MFN); P3 _ P2_ CHPT(MNO,-1)
    SKP($ ); MOV.CHARS($ , 10, MER)
    N _ SIC(P3, MER); IF NOT 0<N<MAN.MAX THEN GO MER
    P1 _ CHPT(FREE, 45); SKP($ ); P3 _ P2_ CHPT(MNO,-1)
    MOV.CHARS($ ,15,MER); MAN(N) _ DOLIN(P3, MER, 2); GO A
EOF:  IF ERRNUM=10 THEN RETURN
MNOPN:  ERMS("CAN'T OPEN FILE WITH MANUAL #'S AND COSTS.$"); EXIT
MER:  ERMS("BAD DATA IN FILE WITH MANUAL #'S AND COSTS$"); EXIT
END RD.MANS

%VALID !READS FILE VALCDS.DAT WHICH CONTAINS VALID STATUS, OWNER, PROD
!AND P&L CODES.  FILE IS SYMBOLIC AND SORTED BY EACH SUBJ.
TABLE VAL(0:3)['**STATUS','**OWN','**PROD','**PL']
  LOCAL NOPN:, PEOF:,PFN, NOPL:
  FBEG _ BUF.BEG
  PFN _ OPEN ('VALCDS.DAT', INPUT+SEQUEN+ CHARACTER, NOPN,1)
  SET.RWE(PFN,PEOF); I _ -1; PL.BEG_0
 NX:  P1 _ P _ GETLINE(PFN)
      IF NCHV P =$* THEN DO CK.LIST(P1, VAL, 4) OF 0:4
        0: ERMS('ERROR IN VALCDS.DAT FILE'); EXIT
        1:  ST.BEG _ FBEG  !START O STATUS-1ST ENTRY
        2:  ST.CNT _ FBEG-ST.BEG; OWN.BEG _ FBEG
        3:  PROD.BEG _ FBEG; OWN.CNT _ FBEG-OWN.BEG
        4:  PL.BEG _ FBEG; PROD.CNT _ FBEG-PROD.BEG
        END ELSE DO
         IF PL.BEG=0 THEN ^FBEG _ FREE(0) ELSE ^FBEG _ SIC(CHPT(FREE,-1),NOPL)
         INC FBEG
      END
   GO NX

NOPN: PRINT('CANT OPEN VALCDS.DAT FILE'); EXIT
 PEOF: IF ERRNUM # EOFERR THEN [PRINT('VALCDS.DATL FILE'); &
        DOUT (ERRNUM); EXIT]
       PL.CNT _ F.BEG - PL.BEG; CLOSE (PFN); RETURN
NOPL:  PRINT('ILLEGAL CHARS IN VALCDS.DAT FILE'); EXIT
END VALID

%GET.IBLK( P)
!SEARCHES FOR AN ITEM WHICH MATCHES SN AND MODEL.
LOCAL M,H1,H2,BELOW:
  M _ 0
   WHILE NCHV P # CARRET THEN M _ M ROTL 7 BXOR CHV P
  H1 _ M BAND HEX 3F.FF.FF.FF.F MOD SZ  !GET RID OF SIGN BIT
  IF H(H1)=0 THEN RETURN 0 ELSE H2_ (M BAND OCT 77)+1
  AGAIN:  IF H(H1) = M THEN GO BELOW
AGP:    H1 _ H1 - H2; IF H1 < 0 THEN H1 _ H1+SZ
    IF H(H1)=0 THEN RETURN 0 ELSE GO AGAIN
  BELOW:  R.IBLK(BLK.NO_BLKR(H1))
     IF CK.SM=1 THEN [MOVE I.SZ FROM ITEM TO TITEMS; RETURN BLKNO] &
      ELSE GO AGP
END GET.IBLK

%CK.SM
  IF ITS1#SN(0) OR ITS2#SN(1) THEN RETURN 0
  IF IMOD = TMOD THEN RETURN 1 ELSE RETURN 0
END CK.SM

%HASH( P)
LOCAL M,J,H1,HS,H2
  M _ 0
  WHILE NCHV P # CARRET THEN M _ M ROTL 7 BXOR CHV P
  H1 _ M BAND HEX 3F.FF.FF.FF.F MOD SZ
  IF H(H1)#0 THEN H2 _ (M BAND OCT 77) + 1 ELSE GO BELOW
 MORE:  H1 _ H1 - H2
    IF H1 < 0 THEN H1 _ H1 +SZ
  IF H(H1)#0 THEN GO MORE
 BELOW:  H(H1) _ M; BLKR(H1) _ BLK.NO; RETURN
END HASH
  

%CK.QB(LBL:)
  LOCAL P4
  P4 _ P_ GETLINE(TEL); NCHV P4
  IF GLCNT = 2 AND CHV P4 = $Q THEN GO ^UPD
  IF GLCNT =2 AND CHV P4 = $^ THEN GO LBL
  IF GLCNT =1 AND CHV P4=CARRET THEN [MOVE 10 FROM ALL 0 TO IMAGE; RETURN 0]
  RETURN 1
END CK.QB

%SKP(CHAR)
  UNTIL (NCHV P1 # CHAR); PCHV P1
  RETURN
END SKP

%MOV.CHARS(CHAR,CNT,CAR.XIT:)
LOCAL I,C
  I _ 0
  WHILE C _ NCHV P1 # CHAR THEN DO
    IF INC I <= CNT THEN NCHV P2 _ C
    IF C=CARRET THEN GO CAR.XIT
  END
  NCHV P2 _ CARRET; RETURN
END MOV.CHARS

%CNV.DATE
LOCAL NM(0:4), M, SS:, P4
  IF GLCNT # 9 THEN GO SS; P1 _ P
  P2 _ P4 _ CHPT(NM,-1)
  MOV.CHARS( $/, 10, SS); M _SIC(P4,SS); P2 _ P4
  MOV.CHARS( $/, 10, SS); M _ M*100+SIC(P4,SS)
  RETURN M+(SIC(P1, SS))*10000

SS: ERMS('INCORRECT DATE FORMAT. USE MM/DD/YY$'); RETURN 0
END CNV.DATE


%R.IBLK(N)
LOCAL R, IEOF:
  SET.RWE(IFN, IEOF)
  MOVE 256 FROM ALL 0 TO ITMBLK
  [CP; R] _ (N-1)*I.SZ DIVMOD 128  !GET DISC BLOCK CONTAINING ITEM
  SET.CP(IFN, CP _  CP*128); RDB(IFN, 256, ITMBLK)
A:  ITEM _ @ITMBLK(R); RETURN
IEOF:  IF ERRNUM = 10 THEN GO A
       ERMS('$CANT READ ITEM.DAT '); EXIT
END R.IBLK

%W.IBLK(CP)
  SET.CP(IFN, CP); WDB(IFN, 256, ITMBLK); RETURN
END W.IBLK

%RD.THDR(T)
!T=1  PUT HEADER (HD.BL) INTO TRBL1 FOR WRITE
!T=0  MOVE HEADER FROM FILE TO (HD.BL)
  SET.RWE(TFN,KIL)
  SET.CP(TFN, 0); RDB(TFN, 128, TR.BL1)
  EIF T > 0 THEN MOVE HD.SZ FROM HD.BL TO TR.BL1
  ELSE MOVE HD.SZ FROM TR.BL1 TO HD.BL
  RETURN
END RD.THDR

%RD.TR(N)
  LOCAL R, TEOFR:
  SET.RWE(TFN, TEOFR); MOVE 256 FROM ALL 0 TO TR.BLK
  [TRCP; R] _ (N-1)*TR.SZ DIVMOD 128; SET.CP(TFN, TRCP*128)
  RDB(TFN, 256, TR.BLK)
A: TRANS _ @TR.BLK(R+HD.SZ); RETURN
TEOFR:  IF ERRNUM = 10 THEN GO A ELSE GO KIL
END RD.TR

%WR.TR(N)
LOCAL CP, R
  [CP; R] _ (N-1)*TR.SZ DIVMOD 128; SET.CP(TFN, CP*128)
  SET.RWE(TFN, KIL); WDB(TFN, 256, TR.BLK)
  IF NEW.TR > 0 THEN WR.THDR; RETURN
END WR.TR

%WR.THDR
  RD.THDR(1); SET.CP(TFN,0); MOVE HD.SZ FROM HD.BL TO TR.BL1
  WDB(TFN, 128, TR.BL1); RETURN
END WR.THDR

%GTRB  !GET A NEW TRANS BLOCK
LOCAL BLN
  EIF FR.BEG=0 THEN [RD.TR(BLN _ TR.EOF); INC TR.EOF]
  ELSE [RD.TR(BLN _ FR.BEG); FR.BEG _ FR.NXT]
  WR.THDR
 RETURN BLN
END GTRB


!READS NAME & ADDRESS FILE AND STORES ID,CP IN ARRAY NAD
!USES BUFFER STARTING AT N

LOCAL %CK.I
LOCAL J2,J1

%RD.NAM(NAD(), N(), Z)
  LOCAL NOPN:, NEOF:,IFN, B.MAX, I, BTOT, SLOT, FND,J, SFN, P3,EFT
  LOCAL C:
  NAFN _ OPEN ('NAME.ADR', UPDATE+DIRECT+WORD, NOPN); SET.RWE(NAFN,NEOF)
  B.MAX _ 128*Z; MOVE NAD.MAX*SZ2 FROM ALL 0 TO NAD

  J _ BTOT _ EFT _ 0; I _ -1; RDB(NAFN, B.MAX, N)
A:  UNTIL(N(CK.I)=-1)
    IF N(CK.I)=-1 THEN [JNADR _ J; RETURN BTOT+I]
    [SLOT; FND] _ DOUBLE BINSRCH( N(I), NAD, J, SZ2)
    IF FND>0 THEN GO A ! [MSG('$DUPLICATE ID IN NAME FILE.'); DOUT(N(I));  
!       GO A]
    J1_SLOT*SZ2-1; J2_J*SZ2+2
    IF SLOT<=J THEN REPEAT SZ2 BMP.DOWN(@NAD(INC J1), @NAD(INC J2))
    NAD(SLOT*SZ2) _ N(I); NAD(SLOT*SZ2+1) _ BTOT+I; INC J
    IF J>=NAD.MAX THEN RETURN 0; GO A

%CK.I
    IF INC I # B.MAX THEN RETURN I
  IF EFT=1 THEN GO C; BTOT _ BTOT+B.MAX; RDB(NAFN, B.MAX, N); RETURN I_ 0
NEOF:  IF ERRNUM =10 THEN [B.MAX _ SIZE(NAFN)-BTOT; INC EFT; RETURN I_0]
       MSG('CANT READ FILE NAME.ADR$'); EXIT
NOPN:  MSG('CANT OPEN NAME/ADR FILE.$'); EXIT
END CK.I
C: JNADR _ J; RETURN BTOT+I
END RD.NAM



%CRD
LOCAL C, BF(0:128), ER:, CRFN, NCRP:, L, I, TG
  TG _ 0

A:  SETRWE(CRFN, ER)
    IF TG=0 THEN MSG('TYPE CREDIT DESCRIPTION. TYPE Q WHEN THRU$') &
     ELSE MSG('TYPE SUPPLY DESCRIPTION. TYPE Q WHEN THRU$')
     C _ 0
    MOVE 128 FROM ALL 0 TO BF
D:  P _ GETLINE(TEL); IF GLCNT=2 AND NCHV P=$Q THEN GO B
    IF GLCNT>34 THEN [ERMS('CANT HAVE MORE THAN 32 CHARS PERLINE.$'); GO D]
    IF C=5 THEN [ERMS('MAX OF 5 LINES ALLOWED.'); GO A]
    MOVE 7 FROM IMAGE TO @BF(C*7); INC C; GO D

B:  IF YN _ YNQ('DESCRIPTION OK? ') = 2 THEN &
    [MSG('RETYPE ENTIRE DESCRIPTION.$'); GO A]
    IF YN#1 THEN [MSG('TYPE Y OR N$'); GO B]
    BF(C*7) _ ^('**** ') BAND HEX F.FFFF.FF00 BOR OCT 32
    OFF.ALT; SETCP(CRFN, LEOF*7); WDB(CRFN, 128, BF)
    SETCP(CRFN, 0); RDB(CRFN, 128, BF); L_LEOF
    BF(0)_LEOF_LEOF+INC C; SETCP(CRFN,0); WDB(CRFN,128,BF)
    ON.ALT; RETURN L

%%SCRD
  TG _ 1; GO A

%%CRDIN
  CRFN _ OPEN('SCRIPT', WORD+DIRECT+UPDATE,NCRP)
  IF .SIZE(CRFN)=0 THEN LEOF_1 ELSE LEOF_R(CRFN)
  RETURN

ER: ERMS('CANT RD/WRITE SCRIPT.'); GO KILL
NCRP:  ERMS('CANT OPEN SCRIPT.'); GO KILL

END CRD
END PIN
~PC{ì