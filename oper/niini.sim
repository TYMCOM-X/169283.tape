FIND P.Q.AREA

DEF C.B.I.NUM AS 0      !INIT NUMBER OF R.C.B-S  ***
DEF I.N.L.C.B.EL AS 0   !INIT NUM L.C.B ELEMENTS
DEF LN.MAX AS  22   !INIT SIZE OF L.C.B AREA.  CK %S.LN.NAMES
FIND ACCTG.CMNDS.FN
FIND AUD.FN
FIND P.LINES
FIND CMND.BLK.AREA
FIND P.L.C.B.AREA
FIND C.B.AREA
FIND MAX.LINE
FIND LINES
FIND CMD.STR()
FIND H.T.ENTRIES          !NUM ENTRIES IN H. T.; INIT 0

FIND STORE(0)
FIND N.AREA(0)
FIND MASK(0)
FIND MASK.COMP(0)
FIND CHAR.PROP(0)

FIND LOCAL.NAME
FIND SCRIPT.Q
FIND TCB.LIST
FIND OUT.Q
FIND OUT.H.Q
FIND SEQ.NO.Q
FIND ACK.LIST
FIND MODEM.Q
FIND SLAVE.Q
FIND BUFFERLETS
FIND INIT.P
FIND RADIX
FIND CR.STRING
FIND H.T.AREA             !PTR TO AREA
FIND H.T.SZ               !ACTUAL SIZE
FIND H.T.SZ.X             !INDEX INTO PRIME TABLE
FIND S.TBL.PTR            !SYMBOL TBL AREA PTR

FIND %G.ELMT
FIND %Q.POST
FIND %SET.FAST
FIND %AUDIT
FIND %STR.COMP
FIND %LN.S.NUM
FIND %FUSBUDGET
FIND %PUNT
FIND %N.OFF.PACK
FIND %AR.N
FIND %AR.OFF
FIND %R.P.L.DATA
FIND %L.P.L.DATA
FIND %SET.AR
FIND %R.P.CDR
FIND %L.P.CDR
FIND %C.ELMTS
FIND %C.AREA
!16 MAR 73  NIINI.SIM  INITIALIZATION CODE    *CW

GLOBAL.PROC(INIT.NET,H.INIT.NET)
GLOBAL.PROC(G.ANCHOR,H.G.ANCHOR)
GLOBAL.PROC(R.ANCHOR,H.R.ANCHOR)

FIND %INIT.SLA         !****************
!LOCAL %INIT.SLA
LOCAL %INIT.MASTER
LOCAL %INIT.BUF
LOCAL %INIT.LST
LOCAL %INIT.MOD
LOCAL %INIT.S.M
LOCAL %INIT.S.T
LOCAL %INIT.MSK
LOCAL %INIT.CHAR.PROP
LOCAL %INIT.LN
LOCAL %INIT.ANCHOR
!
PROC(INIT.NET,H.INIT.NET,'INIT.NET',)  !INITIALIZATION
!INPUT: NONE
!VALUE: TRUE IF SUCCESSFUL, ELSE FALSE

TABLE NAMES(1:MAX.CMND) [ &
 'BCKT'&
,'CHAN'&
,'ECHO'&
,'ECHOR'&
,'NULL'&
,'PAUSE'&
,'QUIT'&
,'RTEXT'&
,'STEXT'&
,'SENDV'&
,'SETV'&
,'VAR'&
,'WSLAVE'&
,'ZCKT'&
,'DATA'&
,'ERR'&
,'OPEN'&
,'CLOSE'&
,'SBLKS'&
,'ERASE'&
,'CLOSEA'&
,'WRITE'&
,'RENAME'&
,'RBLKS'&
,'STEST'&
,'SENDFS'&
,'SETBS'&
,'SETFS'&
,'SETCP'&
,'SENDBS'&
,'BSDATA'&
,'SENDFCB'&
,'FCBDATA'&
,'SENDCP'&
,'CREATE'&
,'CHOKE'&
,'ACKP'&
,'ACKN'&
,'BCKSUM'&
,'BDATA'&
,'MACK'&
]
LOCAL P,A

RADIX _ 10
INIT.MSK                      !MASK AND MASK COMPLEMENT

!INIT CR.STRING
CH(@CR.STRING,0)  _  CARRET
CH(@CR.STRING,1)  _  E.O.LIT
CH(@CR.STRING,2)  _  E.O.LIT

!INIT CMD.STR ARRAY WITH CMD NAME LITERALS
CMD.STR _ NAMES
IF NOT INIT.S.M THEN RETURN(FALSE)   !SPACE MANAGEMENT

!ZERO OUT LIST AREA ANCHORS SO FUSBUDGET DOESN'T GET CONFUSED
S.TBL.PTR _ 0
C.B.AREA _ 0
N.AREA(2) _ 0
N.AREA(3) _ 0
N.AREA(4) _ 0
BUFFERLETS _ 0
IF NOT INIT.LST THEN RETURN(FALSE)   !LISTS

IF NOT INIT.BUF THEN RETURN(FALSE)      !BUFFERLETS

IF NOT INIT.ANCHOR THEN RETURN(FALSE)     !ANCHORS

IF NOT INIT.MOD THEN RETURN(FALSE)   !MODEM

IF NOT INIT.SLA THEN RETURN(FALSE)   !SLAVE

                                !MASTER
                                !TEMPORARY   ****
FIND MAST.Q
FIND PREV.PTR
FIND STACK.Q
STACK.Q _ G.ANCHOR
SCRIPT.Q _ G.ANCHOR
TCB.LIST _ G.ANCHOR
MAST.Q _ G.ANCHOR
PREV.PTR _ G.ANCHOR

IF NOT INIT.S.T THEN RETURN(FALSE)     !SYMBOL TABLE
!INIT.MASTER MUST FOLLOW INIT.S.T

IF NOT INIT.MASTER THEN RETURN(FALSE)

IF NOT INIT.LN THEN RETURN(FALSE)    !LINES

IF NOT INIT.CHAR.PROP THEN RETURN(FALSE)

CMND.BLK.AREA _ C.ELMTS(ENCODED.CMND.SIZE,3)  !COMMAND BLOCK AREA

RETURN(TRUE)
END.PROC(INIT.NET,H.INIT.NET)
!
%INIT.BUF               !INIT BUFFERLET CODE
!INPUT: NONE
!VALUE: TRUE IF SUCCESSFUL; ELSE FALSE

BUFFERLETS _ C.ELMTS(BUF.SIZE,BUF.I.NO.EL)

RETURN(TRUE)
END INIT.BUF
!
%INIT.LST                      !INITIALIZE LST CODE
!INPUT: NONE
!VALUE: TRUE IF SUCCESSFUL; ELSE FALSE

LOCAL I
I _ 1
WHILE INC I <= 5 &
 THEN &
  DO
  N.AREA(I) _ C.ELMTS(I,0)
  END

RETURN(TRUE)
END INIT.LST
!
%INIT.MOD                      !INITIALIZE THE MODEM
!INPUT: NONE
!VALUE: TRUE IF SUCCESSFUL; ELSE FALSE

LOCAL P

OUT.Q _ G.ANCHOR
SEQ.NO.Q _ G.ANCHOR
ACK.LIST _ G.ANCHOR
OUT.H.Q _ G.ANCHOR
MODEM.Q _ G.ANCHOR

C.B.AREA _ C.ELMTS(C.B.H+1,C.B.I.NUM)

LOCAL.NAME _ OCT 61 !DEFINE A LOCAL NAME FOR DEBUGGING *** = "1"

[P;P.Q.AREA] _ DOUBLE C.AREA(1)
IF NOT P THEN RETURN(FALSE)

RETURN(TRUE)
END INIT.MOD
%INIT.S.M               !INITIALIZE SPACE MQNAGEMENT
!INPUT: NONE
!OUTPUT: TRUE/FALSE

!THE FOLLOWING BLOCK IS THE SPACE MANAGEMENT CODE.
!THE SPACE MANAGED IS OF SIZE MX.S.M.AR, AND LOCAL
!NAME "STORE".  THE SPACE IS BROKEN INTO ANY NUMBER OF ORDERED
!AREAS, THE **FIRST** AREA BEING A CONTROL AREA WHICH
!**MUST** START AT STORE(0), AND WHICH IS (3*N)+1 WORDS
!LONG, WHERE N IS THE NUMBER OF AREAS CURRENTLY BEING MANAGED.
!THE FIRST LOCATION (0:0) OF THE CONTROL AREA CONTAINS N; THE
!NEXT N LOCATIONS (1:N) CONTAIN THE STARTING LOCATIONS FOR THE
!N AREAS [STARTING LOCATION < 0 IMPLIES THAT THE AREA DOES
!NOT EXIST] INDEXED BY AREA NAME [1 <= AREA NAME <= N]; THE
!NEXT N LOCATIONSq(N+1:2*N) CONTAIN THE SIZES OF THE
!AREAS (SIZE >= 0); THE NEXT N LOCATIONS (2*N+1:3*N) ARE
!USED INTERNALLY IN ALLOCATING SPACE BETWEEN AREAS.
!THE FIRST (OR CONTROL) AREA IS MANAGED BY THE GENERAL AREA
!MANAGEMENT ROUTINES.

!SPACE MANAGEMENT LOCALS
DEF N AS NUM.AREAS
DEF S.M.I.C.A AS 4
                        !!!!!!!!!!!!!!!
                        !!! WARNING !!!
                        !!!!!!!!!!!!!!!
                !THE ASSUMPTION IS MADE THAT INIT.P
                !IS INITIALLY ZERO (FALSE).

!INITIALIZATION CODE FOR SPACE MANAGEMENT

!ENTER HERE FOR INITIALIZATION

!CHECK FOR ADEQUATE SPACE TO INITIALIZE
IF MX.S.M.AR < S.M.I.C.A !SIZE OF S.M. INITIAL CONTROL !&
!AREA! THEN RETURN(INIT.P _ FALSE)  !INDICATE FAILURE AND RETURN

!SET UP CONTROL AREA
N _ 1             !COUNT THIS AREA
AR.LOC(1) _ AR.SLOP(1) _ 0 !STARTING LOCATION (INDEX) OF CONTROL AREA,
                         !AND SLOP
AR.SIZE(1) _ S.M.I.C.A  !SIZE OF CONTROL AREA =
                           !S.M. INIT. CONTROL AREA SIZE

RETURN(INIT.P _ TRUE)    !GOOD RETURN


                         !THIS BLOCK TERMINATES AFTER 
                        !LAST S.M. PROCEDURE
END INIT.S.M
%INIT.S.T                       !INITIALIZE SYMBOL TABLE
!INPUT: NONE
!VALUE: TRUE IF SUCCESSFUL; ELSE FALSE

LOCAL %SUB.C.INT
LOCAL %SUB.INT
LOCAL P

DEF S.ENTRY.SIZE AS 4           !SIZE OF SYMBOL TABLE ENTRY
DEF S.I.N.E.L AS 0        !INIT NUM SYMBOL ELEMENTS
FIND %N.OFF.PACK
FIND %FM.STRING
FIND %C.AREA
FIND %G.ELMT
FIND %C.ELMTS
FIND %SET.SYMBOL.VALUE
FIND %SET.FAST
FIND %SET.HIDDEN



!CAUTION: *** THIS TABLE IS DUPLICATED IN NISY1.SIM ***
TABLE PRIME(0:14)[3,7,13,31,61,127,251,509,1021,2039,4093,8191, &
                  16381,32749,65521]

!CREATE HASH TABLE; INITIALIZE AREA; SIZE; SIZE INDEX; NUM ENTRIES
H.T.ENTRIES _ 0
[P;H.T.AREA] _ &
DOUBLE C.AREA(H.T.SZ _ PRIME(H.T.SZ.X _ 0))
H.T.AREA _ N.OFF.PACK(H.T.AREA,0) !MOVE AREA NAME TO AREA FIELD
HTCREATED:NULL
IF NOT P THEN RETURN(FALSE)

!CREATE AND REMEMBER SYMBOL TABLE
S.TBL.PTR _ C.ELMTS(S.ENTRY.SIZE,S.I.N.EL)
STCREATED:NULL

!DEFINE TABLES FOR SYMBOL TABLE INITIALIZATION
!NAME STRING,SYMBOL TYPE,SYMBOL VALUE TYPE,SYMBOL VALUE,FAST.L,LOCK.P

TABLE CT.1(0:18) &
 [       1,S.T.CMND,S.V.T.INT,  BCKT.CMND,0,TRUE &
 ,       1,S.T.CMND,S.V.T.INT,  CHAN.CMND,0,TRUE &
 ,       1,S.T.CMND,S.V.T.INT,  ECHO.CMND,0,TRUE &
 ,0]
TABLE CT.2(0:18) &
 [       1,S.T.CMND,S.V.T.INT, ECHOR.CMND,0,TRUE &
 ,       1,S.T.CMND,S.V.T.INT,  NULL.CMND,0,TRUE &
 ,       1,S.T.CMND,S.V.T.INT, PAUSE.CMND,0,TRUE &
 ,0]
TABLE CT.3(0:18) &
 [       1,S.T.CMND,S.V.T.INT,  QUIT.CMND,0,TRUE &
 ,       1,S.T.CMND,S.V.T.INT, RTEXT.CMND,0,TRUE &
 ,       1,S.T.CMND,S.V.T.INT, STEXT.CMND,0,TRUE &
 ,0]
TABLE CT.4(0:18) &
 [       1,S.T.CMND,S.V.T.INT, SENDV.CMND,0,TRUE &
 ,       1,S.T.CMND,S.V.T.INT,  SETV.CMND,0,TRUE &
 ,       1,S.T.CMND,S.V.T.INT,   VAR.CMND,0,TRUE &
 ,0]
TABLE CT.5(0:18) &
 [       1,S.T.CMND,S.V.T.INT,WSLAVE.CMND,0,TRUE &
 ,       1,S.T.CMND,S.V.T.INT,  ZCKT.CMND,0,TRUE &
 ,       1,S.T.CMND,S.V.T.INT,  DATA.CMND,0,TRUE &
 ,0]
TABLE CT.6.(0:18) &
 [    1,S.T.CMND,S.V.T.INT,   ERR.CMND,0,TRUE &
 ,  1,S.T.CMND,S.V.T.INT,  OPEN.CMND,0,TRUE &
 , 1,S.T.CMND,S.V.T.INT, CLOSE.CMND,0,TRUE &
 ,0]
TABLE CT.7(0:18) &
 [       1,S.T.CMND,S.V.T.INT, SBLKS.CMND,0,TRUE &
 ,       1,S.T.CMND,S.V.T.INT, ERASE.CMND,0,TRUE &
 ,       1,S.T.CMND,S.V.T.INT,CLOSEA.CMND,0,TRUE &
 ,0]
TABLE CT.8(0:18) &
 [       1,S.T.CMND,S.V.T.INT, WRITE.CMND,0,TRUE &
 ,       1,S.T.CMND,S.V.T.INT,RENAME.CMND,0,TRUE &
 ,       1,S.T.CMND,S.V.T.INT, RBLKS.CMND,0,TRUE &
 ,0]
TABLE CT.9(0:18) &
 [       1,S.T.CMND,S.V.T.INT, STEST.CMND,0,TRUE &
 ,       1,S.T.CMND,S.V.T.INT,SETCP.CMND,0,TRUE &
 ,       1,S.T.CMND,S.V.T.INT,SENDFS.CMND,0,TRUE &
 ,0]
TABLE CT.10(0:18) &
 [       1,S.T.CMND,S.V.T.INT, SETBS.CMND,0,TRUE &
 ,       1,S.T.CMND,S.V.T.INT, SETFS.CMND,0,TRUE &
 ,       1,S.T.CMND,S.V.T.INT, CHOKE.CMND,0,TRUE &
 ,0]
TABLE CT.11(0:18) &
 [       1,S.T.CMND,S.V.T.INT,  ACKP.CMND,0,TRUE &
 ,       1,S.T.CMND,S.V.T.INT,BCKSUM.CMND,0,TRUE &
 ,       1,S.T.CMND,S.V.T.INT, BDATA.CMND,0,TRUE &
 ,0]
TABLE CT.12(0:6) &
 [       1,S.T.CMND,S.V.T.INT,  MACK.CMND,0,TRUE &
 ,0]
TABLE T.11(0:18) &
 ['TRUE',S.T.VAR,S.V.T.INT,TRUE,0,TRUE &
 ,'FALSE',S.T.VAR,S.V.T.INT,FALSE,0,TRUE &
 ,'VERSION',S.T.VAR,S.V.T.INT,VERSION,0,TRUE &
 ,0]
TABLE T.12(0:18) &
 ['PATTERN',S.T.VAR,S.V.T.INT,HEX 102,PATTERN,FALSE &
 ,'DISCARDP',S.T.VAR,S.V.T.INT,FALSE,DISCARD.P,FALSE &
 ,'CHOKE',S.T.VAR,S.V.T.INT,INIT.CHOKE,CHOKE,FALSE &
 ,0]
TABLE T.13(0:18) &
 ['AUDLEV',S.T.VAR,S.V.T.INT,INIT.AUDIT.LEVEL,AUDIT.LEVEL,FALSE &
 ,'ECHOP',S.T.VAR,S.V.T.INT,FALSE,ECHO.P,FALSE &
 ,'CURFILE',S.T.VAR,S.V.T.NIL,T.V.T.NIL,CURFILE,FALSE &
 ,0]
TABLE T.14(0:18) &
 ['AUDFILE',S.T.VAR,S.V.T.LIT,I.AUD.F.N,AUD.FILE,FALSE &
 ,'MASTERP',S.T.VAR,S.V.T.INT,I.MASTER.P,MASTER.P,FALSE &
 ,'STDBLKSZ',S.T.VAR,S.V.T.INT,I.STD.BLK.SZ,0,FALSE &
 ,0]

!DEFINE A MACRO TO EASE THE NEXT FEW THINGS
DEF SET(TBL) AS IF NOT SUB.INT(TBL)THEN RETURN(FALSE)
DEF SETC(TBL) AS IF NOT SUB.C.INT(TBL) THEN RETURN (FALSE)

!NOW SET ALL THE INITIAL VALUES TO THE SYMBOL TABLE
SETT1: &
SETC(CT.1)
SETT2:  &
SETC(CT.2)
SETC(CT.3)
SETC(CT.4)
SETC(CT.5)
SETC(CT.6)
SETC(CT.7)
SETC(CT.8)
SETC(CT.9)
SETC(CT.10)
SETC(CT.11)
SETC(CT.12)
SET(T.11)
SET(T.12)
SET(T.13)
SETT14:  &
SET(T.14)
ALLSET: NULL

!ALL THROUGH INITIALIZING THE SYMBOL TABLE
RETURN(TRUE)
!
%SUB.INT(T())                        !SUB INIT SYMB TBL
!INPUT: TABLE ADDRESS
!VALUE: TRUE IF SUCCESSFUL, ELSE FALSE

LOCAL S.V

WHILE T(0) # 0 &
 THEN &
  DO           !WE HAVE AN ENTRY TO MAKE
  S.V _ T(3)                   !SYMBOL VALUE
  IF T(2) !SYMBOL VALUE TYPE! = S.V.T.LIT &
   THEN S.V _ FM.STRING(E.O.L,CHPT(T(3))) !MAP LIT TO BUFFERLETS
SETSV:  &
  IF NOT SET.SYMBOL.VALUE(FM.STRING(E.O.L,CHPT(T(0))),T(1),T(2),S.V) &
   THEN RETURN(FALSE)                  !CANNOT MAKE DEFINITION
HIDDEN:  &
  IF NOT SET.HIDDEN(FM.STRING(E.O.L,CHPT(T(0))),T(1),T(4),T(5)) &
   THEN RETURN(FALSE)                  !CANNOT SET HIDDEN PARAMS
  !STEP TO NEXT ENTRY
STEP: &
  T _ T+6
  END

RETURN(TRUE)
END SUB.INT
%SUB.C.INT(T())                        !SUB INIT SYMB TBL COMMANDS
!INPUT: TABLE ADDRESS
!VALUE: TRUE IF SUCCESSFUL, ELSE FALSE

LOCAL S.V

WHILE T(0) # 0 &
 THEN &
  DO           !WE HAVE AN ENTRY TO MAKE
  S.V _ T(3)                   !SYMBOL VALUE
  IF T(2) !SYMBOL VALUE TYPE! = S.V.T.LIT &
   THEN S.V _ FM.STRING(E.O.L,CHPT(T(3))) !MAP LIT TO BUFFERLETS
SETSV:  &
  IF NOT SET.SYMBOL.VALUE(FM.STRING(E.O.L,CHPT(CMD.STR(T(3)))),T(1),T(2),S.V) &
   THEN RETURN(FALSE)                  !CANNOT MAKE DEFINITION
HIDDEN:  &
  IF NOT SET.HIDDEN(FM.STRING(E.O.L,CHPT(CMD.STR(T(3)))),T(1),T(4),T(5)) &
   THEN RETURN(FALSE)                  !CANNOT SET HIDDEN PARAMS
  !STEP TO NEXT ENTRY
STEP: &
  T _ T+6
  END

RETURN(TRUE)
END SUB.C.INT
END INIT.S.T
!
%INIT.MSK                     !INITIALIZE MASK AND MASK.COMP ARRAYS
!INPUT: NONE
!VALUE: NONE

LOCAL  N, TWO.TO.THE.N

N _ 0
TWO.TO.THE.N _ 1
WHILE N < BITS.PER.WORD-1   &
 THEN &
  DO
  MASK.COMP(N) _ (MASK(N) _ TWO.TO.THE.N - 1) BXOR -1
  TWO.TO.THE.N _ TWO.TO.THE.N * 2
  INC N
  END

MASK.COMP(BITS.PER.WORD-1) _     &
         (MASK(BITS.PER.WORD-1) _ TWO.TO.THE.N  SHL 1) BXOR -1

MASK(BITS.PER.WORD) _ -1
MASK.COMP(BITS.PER.WORD) _ 0
RETURN
END INIT.MSK
!
%INIT.CHAR.PROP         !INITIALIZE CHAR.PROP TABLE
!INPUT: NONE
!VALUE: TRUE

LOCAL I

DEF SET(F,T,FN) BY
 I _ OCT F - 1
 WHILE INC I <= OCT T THEN FN(I) _ TRUE
ENDM SET

!ZERO OUT CHAR.PROP ARRAY (: NO CHARS BELONG TO ANY CLASS)
I _ -1
REPEAT 256 CHAR.PROP(INC I) _ 0    !ALL FIELDS FALSE

!SET "OTHERS"
SET(0,200,C.P.OTHER)
SET(204,211,C.P.OTHER)
SET(213,214,C.P.OTHER)
SET(216,237,C.P.OTHER)
SET(241,253,C.P.OTHER)
SET(255,257,C.P.OTHER)
SET(272,272,C.P.OTHER)
SET(274,300,C.P.OTHER)
SET(333,340,C.P.OTHER)
SET(373,376,C.P.OTHER)

!SET ALPHAS
SET(301,332,C.P.ALPHA)
SET(301,332,C.P.ALPHA.NUMERIC)
SET(341,372,C.P.ALPHA)
SET(341,372,C.P.ALPHA.NUMERIC)

!SET NUMERICS
SET(260,271,C.P.NUMERIC)
SET(260,271,C.P.ALPHA.NUMERIC)

!SET EOC
SET(212,212,C.P.EOC)            !LINE FEED
SET(215,215,C.P.EOC)            !CARRIAGE RETURN
SET(273,273,C.P.EOC)            !SEMI-COLON

!SET SOH, ETC.
SET(201,203,C.P.SOH)

!SET TEXT TERMINATORS
SET(201,203,C.P.TEXT.TERM)      !SOH LIST
SET(212,212,C.P.TEXT.TERM)      !LINE FEED
SET(215,215,C.P.TEXT.TERM)      !CARRIAGE RETURN
SET(273,273,C.P.TEXT.TERM)      !SEMI-COLON

!SET MISC. ODDS AND ENDS
SET(240,240,C.P.SPACE)          !SPACE
SET(254,254,C.P.COMMA)          !COMMA
SET(377,377,C.P.DEL)            !DEL
RETURN(TRUE)
END INIT.CHAR.PROP
!
%INIT.ANCHOR            !INITIALIZE THE ANCHOR AREA

LOCAL P, P.ANCHORS, A.ANCHORS, NUM.ANCHORS
LOCAL %SET

[P;A.ANCHORS] _ DOUBLE C.AREA(0)
IF NOT P  THEN  RETURN (FALSE)

P.ANCHORS _ N.OFF.PACK(A.ANCHORS,0)
SET(0)

RETURN (TRUE)


PROC(%G.ANCHOR,%H.G.ANCHOR,'G.ANCHOR',)  !GET AN ANCHOR

LOCAL I

FUSBUDGET               !*****
NUM.ANCHORS _ R.P.CDR(P.ANCHORS)

I _ 0
WHILE (INC I) <= NUM.ANCHORS  AND  R.P.L.DATA(P.ANCHORS,I) # -1 &
 THEN NULL

IF I > NUM.ANCHORS &
 THEN &
 DO
  SET(NUM.ANCHORS+1)
 END

L.P.L.DATA(P.ANCHORS, I, 0)

FUSBUDGET               !****
RETURN (N.OFF.PACK(A.ANCHORS,I))


PROC(%R.ANCHOR,%H.R.ANCHOR,'R.ANCHOR',(PTR))  !RETURN AN ANCHOR

LOCAL AR

!VALIDATE INPUT ARGUMENT
AR _ AR.N(PTR); I _ AR.OFF(PTR)
IF NOT(AR # A.ANCHORS AND 0<I<=NUM.ANCHORS) &
 THEN &
 DO
  PUNT(SOFT,'BAD PTR TO R.ANCHOR',0)
  RETURN
 END

L.P.L.DATA(P.ANCHORS, I, -1)    !MARK RETURNED ANCHOR SLOT

I _ NUM.ANCHORS                 !LOOK FOR UNUSED SLOTS AT END OF AREA
WHILE R.P.L.DATA(P.ANCHORS,I) = -1  AND  I >= 1 &
 THEN DEC I

IF I < NUM.ANCHORS THEN SET(I)         !GARBAGE COLLECT ANY SLOTS AT END
RETURN


%SET(SIZE)                      !SET SIZE OF ANCHOR AREA
SET.AR(A.ANCHORS,SIZE+1)
I _ NUM.ANCHORS _ L.P.CDR(P.ANCHORS,SIZE)
RETURN
END SET

END INIT.ANCHOR

%INIT.LN
!#######
!INPUT: NONE
!VALUE: TRUE IF SUCCESSFUL, ELSE FALSE

LOCAL P,NAME

[P;LINES] _ DOUBLE C.AREA(1)
IF NOT P THEN RETURN(FALSE)
P.LINES _ N.OFF.PACK(LINES,0)
MAX.LINE _ 0

P.L.C.B.AREA _ C.ELMTS(LN.MAX+1, I.N.L.C.B.EL)

NAME _ -1
REPEAT 256 LN.S.NUM(INC NAME,0)

RETURN(TRUE)
END INIT.LN
!
%INIT.MASTER
 
!INITIALIZATION FOR THE AC.NET.MASTER RUNNING ON THE PDP-10


LOCAL PTR
LOCAL STRING
LOCAL AUDIT.OPEN.ERR:
LOCAL CMND.OPEN.ERR:
LOCAL S.C.B.AREA.PTR




SET.FAST(AUDIT.LEVEL,S.V.T.INT, AUD.ALL)    !AUDIT EVERYTHING FOR NOW


                                      !OPEN AUDIT FILE AND MASTER CMNDS
AUD.FN  _        &
            OPEN('ACAUD',DIRECT+UPDATE+CHARACTER,AUDIT.OPEN.ERR)
AUDIT(A.AUDIT.MSG,CHPT('TODAY"S DATE AND TIME'))

ACCTG.CMNDS.FN  _       &
            OPEN('ACCMND',DIRECT+UPDATE+CHARACTER,CMND.OPEN.ERR)
STRING  _   GETLINE( ACCTG.CMNDS.FN )  !GET FIRST MASTER COMMAND


IF  NOT( STR.COMP(CHPT('*START',-1),STRING))      &
     THEN      &
              AUDIT(A.AUDIT.MSG,CHPT('CMND FILE FCKD'))     

!CREATE AND INITIALIZE THE FIRST SCRIPT CONTROL BLOCK ( S.C.B. )
S.C.B.AREA.PTR  _   C.ELMTS(S.C.B.ELMT.SIZE,S.C.B.INIT.NUM.ELMTS)
L.P.CDR(SCRIPT.Q,E.O.L)

PTR  _  G.ELMT(S.C.B.AREA.PTR)
Q.POST(SCRIPT.Q,PTR)

LOCAL TEMP
TEMP _ CP(ACCTG.CMNDS.FN)-1
L.S.C.B.CURR.CMND.CP(PTR,TEMP)
L.S.C.B.CRASH.MILESTONE.CP(PTR,TEMP)
L.S.C.B.PREV.CMND.CP(PTR,0)
L.S.C.B.CURR.ADDRESSEE(PTR,0)
L.S.C.B.ECHO.DATA(PTR,0)
L.S.C.B.ECHO.SEQ(PTR,0)


RETURN TRUE

AUDIT.OPEN.ERR:    PUNT(HARD,'AUDIT OPEN ERROR',0)
                   RETURN

CMND.OPEN.ERR:     PUNT(HARD,'COMMAND FILE OPEN ERROR',0)
                   RETURN

END INIT.MASTER
 