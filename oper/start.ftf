C       START.FTF
        SUBROUTINE STARTUP
C
C       THIS ROUTINE SETS UP THE VARIOUS THINGS NECESSARY
C
        COMMON /FILES/ FILES(7, 11)
C
        INTEGER TIM, DAT(2)
C
    1   FORMAT( '   * * * W I R R A P * * *'/ 12X,A5/10X,2A5/
     1  / 6X, ' START SESSION:'//)
C
C       GET TIME AND DATE
        CALL TIME(TIM)
        CALL DATE(DAT)
C
C       SET FILE NAMES
        CALL FUSED(FILES(5, 1), 'A')
        CALL FUSED(FILES(5, 2), 'B')
        CALL FUSED(FILES(5, 3), 'C')
        CALL FUSED(FILES(5, 4), 'D')
        CALL FUSED(FILES(5, 5), 'E')
        CALL FUSED(FILES(5, 6), 'F')
        CALL FUSED(FILES(5, 7), 'G')
        CALL FUSED(FILES(5, 8), 'H')
        CALL FUSED(FILES(5, 9), 'I')
        CALL FUSED(FILES(5,10), 'J')
        CALL FUSED(FILES(5,11), 'K')
C
C       VERIFY THE TEMP FILES
        CALL PRFTEST
C
C       OPEN THE SIGNAL FILE, CLEAR THE HASH TABLE
        CALL SIGOPEN
C
C       OUTPUT TEXT, AND &C.
        TYPE 1, TIM, DAT
C
C       NOW PROMPT, GET FIRST LINE OF INPUT
        CALL PROMPT
        CALL FETCHL(I)
C
C       DONE..EXIT
        RETURN
        END
        SUBROUTINE FUSED(IT, IS)
C
C       it IS AN ARRAY OF LENGTH 3.  is IS A CHARACTER.
C       THE ROUTINE PUTS is INTO THE FIRST CHARACTER OF THE ARRAY,
C       ADDITIONAL UNIQUE CHARACTERS INTO THE REST, AND FINISHES OFF
C       WITH A ZERO WORD.
C
        DIMENSION IT(3)
C
C       SET UP IT
        IT(1) = MUSENO(IS)
        IT(2) = 5HR.TMP
        IT(3) = 0
C
C       NOW THE ARRAY IS COMPLETE..EXIT
        RETURN
        END
        SUBROUTINE PRFTEST
C
C       THIS ROUTINE VERIFIES THE STATE OF THE PROGRAM TEMP FILES.
C       THIS ROUTINE CALLS IOTEST, AND EVALUATES THE STATE OF EACH FILE.
C       DEPENDING ON THE STATE OF EACH FILE, IT MAY RETURN OR ABORT
C       THE PROGRAM.
C
        COMMON /FILES/ FILES(7, 11)
        INTEGER FILES
C
        COMMON /CPGLOB/ KURSOR, LINSIZ, NATCH, INLINE(270), ISTTY,
     1  HUSH, UNCOLA, IPROMP, IDFILE(5)
C
    1   FORMAT(' ***ERROR***WIRRAP TEMP FILE UNAVAILABLE...ABORTING')
    2   FORMAT(' ***ERROR***TOO MANY FILES IN USE...ABORTING')
    3   FORMAT(' ***ERROR***PROGRAM TEMP FILE BAD ON DISK...ABORTING')
    4   FORMAT(' ***ERROR***SYSTEM ERROR...ABORTING')
C
C
C       DO FOR ALL FILES
        DO 150 N = 1, 11
C
C       COPY THE FILE NAME FOR TESTING
        IDFILE(1) = FILES(5, N)
        IDFILE(2) = FILES(6, N)
        IDFILE(3) = FILES(7, N)
C       FIND THE FILE STATUS
        I = IOTEST(I)
C
C       FAN OUT OVER CONDITION OF FILE
        GO TO (150, 100, 100, 100, 100, 150, 110, 100, 100, 120, 130), I
C
C       FILE UNAVAILABLE
  100   TYPE 1
        CALL EXIT
C
C       MAX NUMBER OF FILES NOW OPEN
  110   TYPE 2
        CALL EXIT
C
C       FILE BAD ON DISK
  120   TYPE 3
        CALL EXIT
C
C       SYSTEM ERROR
  130   TYPE 4
        CALL EXIT
C
C       END OF LOOP
  150   CONTINUE
        RETURN
        END
        SUBROUTINE SIGOPEN
C
C       THIS ROUTINE OPENS THE SIGNAL FILE AND INITIALIZES IT
C
        COMMON /FILES/ FILES(4, 7), FSIGNAL(7)
        INTEGER FSIGNAL
C
        COMMON /HASHCON/ NHASH, NBLOCK, THISSIG, SIGID(2), NEXT,
     1  NEXTPIN, SIGWRIT, DSHEAD(2), CDSN
        INTEGER THISSIG, SIGID, DSHEAD, CDSN
        LOGICAL SIGWRIT
C
C       FIRST OF ALL, SET SOME NUMBERS INTO /HASHCON/
        NHASH = 199
        NBLOCK = NHASH
        FSIGNAL(3) = NHASH
        SIGID(1) = 0
        SIGID(2) = 0
        NEXT = 0
        NEXTPIN = 0
C
C       NOW OPEN THE FILE, ZERO OUT THE BASIC TABLE
        CALL WOPEN(FSIGNAL)
        DO 100 THISSIG = 1, NHASH
         SIGWRIT = .TRUE.
  100   CALL PUTSIG
        END
        LOGICAL FUNCTION DBREAD(NULL)
C
C       THIS ROUTINE IS USED TO INPUT A DATABASE.  IT IS ASSUMED
C       THAT THE FILE IS CLOSED.  THE FILE IS OPENED, AND THE DATA-BASE
C       PREAMBLE IS READ AND VERIFIED.  IF FAILURE, AN ERROR IS OUTPUT,
C       THE FILE IS CLOSED, AND .FALSE. IS RETURNED.  IF IT IS OK, IT
C       IS COPIED TO THE APPROPRIATE FILE TABLES, WHICH ARE THEN CLOSED,
C       AS IS THE DATA-BASE, BEFORE RETURNING .TRUE., WITH ALL
C       PARAMETERS SET UP.
C
        EXTERNAL DBBUFIN, DBSIGIN
C
        COMMON /DBPRE/ DBTITLE(16), DBMOD(2), DBMFLG, DBSNO, DBSFORM(2),
     1  DBBLOK(4, 8), DBEND, DBXYM(4)
        INTEGER DBTITLE, DBMOD, DBSNO, DBSFORM, DBBLOK, DBEND
        LOGICAL DBMFLG
C
        COMMON /FILES/ FXCHAN(7), FYCHAN(7), FSOCKET(7), FPIN(7),
     1  FSIGNAL(7), FPLUGL(7), FPLUGID(7), FPLUGDE(7)
        INTEGER FILES(7, 8), FXCHAN, FYCHAN, FSOCKET, FPIN, FSIGNAL,
     1  FPLUGL, FPLUGID, FPLUGDE
        EQUIVALENCE (FILES(1, 1), FXCHAN(1) )
C
        COMMON /DTABASE/ DTABASE(9)
        INTEGER DTABASE
C
        COMMON /TITLE/ TITLE(16), MODIFY(2), NEWMOD, MODFLG, WRITEIT,
     1  XMIN, XMAX, YMIN, YMAX, PICFRAM
        INTEGER TITLE
        LOGICAL MODFLG, NEWMOD, WRITEIT, PICFRAM
C
    1   FORMAT(' ', 16A5)
    2   FORMAT(12X, 'MOD ', 2A5)
    3   FORMAT(' VERIFY THAT THIS IS THE CORRECT DATA-BASE...TYPE Y/N: '
     1  , $ )
    4   FORMAT(' INTERNAL VERIFICATION FAILURE ON DATA-BASE'//)
C
C       FIRST OPEN THE FILE
        CALL WOPEN(DTABASE(1) )
        READ (DTABASE(1) # 1) DBTITLE, DBMOD, DBMFLG, DBSNO, DBSFORM,
     1  K, DBBLOK, DBEND, DBXYM
C
C       VERIFY THE DATABASE
        DO 100 I = 1, 8
         IF (DBBLOK(1, I+1) .NE. (DBBLOK(1, I) + DBBLOK(2, I) ) )
     1   GO TO 120
  100    CONTINUE
        IF (K .NE. DTABASE(2) ) GO TO 120
C
C       TYPE OUT TITLE, MOD, ASK FOR VERIFICATION
        TYPE 1, DBTITLE
        IF (DBMFLG) TYPE 2, DBMOD
  110   TYPE 3
        IF (.NOT. FETCHL(I) ) GO TO 140
        I = LPARSE(47)
        IF (I .EQ. 1) GO TO 140
        IF (I .NE. 2) GO TO 110
C
C       USER REJECTED DATABASE..COMMENT AND EXIT
        CALL ERROR('DATA-BASE REFUSED', 'REFUSED')
        GO TO 130
C
C       INTERNAL VERIFICATION OF DATABASE FAILED..BITCH AND EXIT
  120   TYPE 4
        CALL PROMPT
        CALL FETCHL(I)
C
C       NOW FINISH EXITING
  130   CALL WCLOSE(DTABASE)
        DBREAD = .FALSE.
C
C       CLEAR THE BAD DATA-BASE NAME
        DTABASE(5) = 0
        DTABASE(6) = 0
        DTABASE(7) = 0
        DTABASE(8) = 0
        DTABASE(9) = 0
        RETURN
C
C       SUCCESS..DETERMINE HOW MUCH SPACE EXISTS FOR BUFFERING
  140   CALL DYNARY(ISPACE)
        ISPACE = MIN0(ISPACE, 4*K)
C
C       NOW INPUT THE BLOCKS OF DATA FROM THE DATA-BASE
        DO 150 I = 1, 8
C
C        DO FOR ALL BUT THE SIGNAL FILE
         IF (I .EQ. 5) GO TO 150
        ISIZE = MIN0(ISPACE, (DBBLOK(2, I) + 1)*K)
         CALL DYNARY(IERR, DBBUFIN, ISIZE, 0, ISIZE, K,
     1  FILES(1, I), DBBLOK(1, I) )
  150    CONTINUE
C
C       NOW INPUT THE SIGNALS FROM THE DATABASE
        ISIZE = MIN0(ISPACE, (DBBLOK(2, 5) + 1)*K)
        CALL DYNARY(IERR, DBSIGIN, ISIZE, 0, ISIZE, K,
     1  DBBLOK(1, 5), DBSFORM, DBSNO)
C
C       NOW COPY THE TITLE INFORMATION
        DO 160 I = 1, 16
  160    TITLE(I) = DBTITLE(I)
        MODIFY(1) = DBMOD(1)
        MODIFY(2) = DBMOD(2)
        NEWMOD = .FALSE.
        MODFLG = DBMFLG
        DBWRITE = .FALSE.
        XMIN = DBXYM(1)
        XMAX = DBXYM(2)
        YMIN = DBXYM(3)
        YMAX = DBXYM(4)
        IF ( (DBBLOK(4, 1) + DBBLOK(4, 2) ) .GT. 0) PICFRAM = .TRUE.
C
C       DONE..NOW CLEAN UP
        CALL WCLOSE(DTABASE)
        DBREAD = .TRUE.
        RETURN
        END
        SUBROUTINE DBBUFIN(LIST, LSIZE, MSIZE, FILE, BLOCK)
C
C       THIS ROUTINE BUFFERS A SET OF DATA FROM THE DATA-BASE FILE TO
C       THE FILE SPECIFIED BY FILE, ACCORDING TO THE INFORMATION IN
C       BLOCK, AND USING THE TEMPORARY STORAGE LIST.
C
        INTEGER LIST(1), FILE(7), BLOCK(4)
C
        COMMON /DTABASE/ DTABASE(9)
        INTEGER DTABASE
C
C       FIRST CLOSE FILE IF NECESSARY
        IF (FILE(4) ) CALL WCLOSE(FILE)
C
C       NOW INITIALIZE THE FILE BLOCK FOR TRANSFER IF NECESSARY
        IF (BLOCK(2) .LE. 0) GO TO 110
        FILE(2) = MSIZE
        CALL WOPEN(FILE)
        NWORDS = BLOCK(2)*MSIZE
        MWORDS = LSIZE/MSIZE*MSIZE
        POSITION (DTABASE(1), BLOCK(1) )
C
C       NOW DETERMINE HOW MANY WORDS TO TRANSFER, DO 1 SET
  100   NXFER = MIN0(NWORDS, MWORDS)
        READ (DTABASE(1) ) (LIST(I), I = 1, NXFER)
        WRITE (FILE(1) ) (LIST(I), I = 1, NXFER)
        NWORDS = NWORDS - NXFER
        IF (NWORDS .GT. 0) GO TO 100
C
C       THE TRANSFER IS DONE.. CLOSE THE FILE
        CALL WCLOSE(FILE)
C
C       NOW COPY ADDITIONAL INFORMATION INTO THE FILE BLOCK
  110   FILE(2) = BLOCK(3)
        FILE(3) = BLOCK(4)
C
C       DONE...EXIT
        RETURN
        END
        SUBROUTINE DBSIGIN(LIST, LSIZE, MSIZE, BLOCK, FORM, NO)
C
C       THIS ROUTINE BUFFERS THE TABLE OF SIGNALS FROM THE DATA-BASE TO
C       THE SIGNAL TABLE.  IT USES DATA IN BLOCK, AND THE TEMP ARRAY
C       LIST, OF SIZE LSIZE.
C
        INTEGER LIST(1), BLOCK(4), FORM(2), ITEM(4)
C
        COMMON /FILES/ FILES(4, 7), FSIGNAL(7)
        INTEGER FSIGNAL
C
        COMMON /DTABASE/ DTABASE(7)
        INTEGER DTABASE
C
        COMMON /HASHCON/ NHASH, NBLOCK, THISSIG, SIGID(2), NEXT,
     1  NEXTPIN, SIGWRIT, DSHEAD(2), CDSN
        INTEGER THISSIG, SIGID, DSHEAD, CDSN
        LOGICAL SIGWRIT
C
C       FIRST OF ALL, SET SOME NUMBERS INTO /HASHCON/
        DSHEAD(1) = FORM(1)
        DSHEAD(2) = FORM(2)
        CDSN = NO
C
C       COMPUTE HOW MUCH SPACE IS REQUIRED
        NWORDS = BLOCK(3)*BLOCK(4)
        MWORDS = LSIZE/MSIZE*MSIZE
C
C       READ A SET OF DATA, PUT IT INTO THE HASH TABLE
        NITEM = 1
  110   MWORDS = MIN0(MWORDS, NWORDS)
        IF (MWORDS .LE. 0) GO TO 130
        LWORDS = MWORDS
        READ (DTABASE(1) ) (LIST(I), I = 1, MWORDS)
        JCOUNT = 1
C
C       GET AN ITEM
  120   IF (LWORDS .LE. 0) GO TO 110
        ITEM(NITEM) = LIST(JCOUNT)
        JCOUNT = JCOUNT + 1
        LWORDS = LWORDS - 1
        NWORDS = NWORDS - 1
        NITEM = NITEM + 1
        IF (NITEM .LE. 4) GO TO 120
        NITEM = 1
C
C       WE'VE NOW ACCUMULATED A SIGNAL
        CALL SIGFIND(ITEM(1) )
        NEXTPIN = ITEM(4)
        SIGWRIT = .TRUE.
        GO TO 120
C
C       HERE WHEN WE'VE GOTTEN ALL SIGNALS..EXIT
  130   RETURN
        END
   