BASE 0


GLOBAL %GETDLM,%INITTTY,%QUERY,%GETNUM,%GETOCT,%GETTOKEN
GLOBAL %CHR.OUT,%OCTWD.OUT,%OCTOUT,%OUT,%NUMOUT,%SIXOUT
GLOBAL %MAKE.SIXBIT,%LISTABLE,%SHORT.OUT,%DATOUT,%CHOOSE,%MATCH
GLOBAL %SPOUT,%BYPT

GLOBAL TOKEN(72/CHARS.PER.WORD),FILNO

TABLE TEN(7)[1,10,100,1000,10000,100000,1000000]

FIND CH.OUT,P,NUMBER

LOCAL MINUSF
LOCAL GBLDLM,COUNT,TEMP,CHAR,TOKENP,RETADR,PTR,DISP,I
LOCAL %FILL.IN.TOKEN,%TTYIO

!THE FOLLOWING MACRO COMPUTES A GENERAL BYT POINTER SO THAT NCHV ON
!THE PDP-10 WILL DO ILDB'S FOR ANY BYTE SIZE
%BYPT(Y,P1,S)
RETURN [6,6,6,18]*[IF P1>=0 THEN 36-S*(P1 MOD(36/S)-1)&
	ELSE 36-S*(36/S-(-P1)MOD(36/S)+1),S,0,&
	IF P1>=0 THEN Y+P1/(36/S) ELSE Y+(P1+1)/(36/S)-1]
END BYPT

DEF NBYV AS NCHV
DEF BYV AS CHV

DEF ALPHA AS 0
DEF NUMERIC AS 1
DEF USERNAME AS 2
DEF OCTAL AS 3
DEF ONEDLM AS 4
DEF ANY AS 5


DEF IFCHAR(A) AS ($A <= A <= $Z) OR IFNUMBER(A) OR A=$.
DEF IF.OCT.NUMBER(A) AS $0 <= A <= $7
DEF IFNUMBER(A) AS $0 <= A <= $9
DEF COLON AS CHR.OUT($:)
DEF CR AS CHR.OUT(CARRET)
DEF MINUS AS $-
DEF SLASH AS CHR.OUT($/)
DEF SPACE AS $ 
DEF SP AS CHR.OUT(SPACE)
DEF IFNAME.CHAR(A) AS IFCHAR(A) OR IFNUMBER(A) OR A=SPACE OR &
	A=$* OR A=$. OR A=$- OR A=$/ OR A=$:
DEF WHAT AS [MSG('?$'); GO ^RETADR]
DEF PASS AS [WHILE NCHV P = SPACE THEN NULL; PCHV P]
DEF STILL.MORE AS INC ANS <= N.TAB
DEF SET.PTR AS PTR _ CHPT(NAME.TAB(ANS),-1)
DEF SETCOUNT AS [TOKENP _ CHPT(TOKEN,-1); COUNT _ -1;&
 WHILE NCHV TOKENP # EOLIT THEN INC COUNT; TOKENP _ CHPT(TOKEN,-1)]
DEF VERSION AS 4



%TTYIO



%INITTTY(INIT:)
FILNO _ TEL
P _ CHPT(IMAGE,-1)
RETADR _ INIT
RETURN
END INITTTY


%GETTOKEN(KIND)
MOVE 72/CHARS.PER.WORD FROM ALL 0 TO TOKEN
TOKENP _ CHPT(TOKEN,-1)
IF CHAR _ NCHV P = CARRET OR CHAR = EOLIT THEN P _ GETLINE(FILNO) ELSE PCHV P
FILL.IN.TOKEN(KIND); PASS; RETURN
END GETTOKEN


%FILL.IN.TOKEN(KIND)
LOCAL ENDT:,NOFLG !=0 TIL A NON-SPACE TYPED...
MINUSF _ NOFLG _ 0
IF KIND = ANY THEN INC NOFLG
NOSAVE: WHILE CHAR _ NCHV P # CARRET AND CHAR # EOLIT THEN DO
IF KIND # USERNAME AND KIND # ANY THEN [IF CHAR = SPACE THEN GO ENDT]
IF CHAR = $? THEN GO ^RETADR
	DO KIND OF ALPHA:ANY
	ALPHA: IF IFCHAR(CHAR) THEN INC NOFLG ELSE  WHAT
	NUMERIC: IF CHAR = MINUS THEN DO
		IF NOFLG #0 OR MINUSF # 0 THEN WHAT
		INC MINUSF; GO NOSAVE
	    END
	    IF IFNUMBER(CHAR) THEN INC NOFLG ELSE [PCHV P; GO ENDT]
	USERNAME: IF IFNAME.CHAR(CHAR) THEN INC NOFLG ELSE WHAT
	OCTAL: IF IF.OCT.NUMBER(CHAR) THEN INC NOFLG ELSE WHAT
	ONEDLM: IF CHAR = GBLDLM THEN [INC NOFLG; NCHV TOKENP _ CHAR; GO ENDT]
		IF CHAR # SPACE THEN WHAT ELSE GO NOSAVE
	ANY: NULL
	END
NCHV TOKENP _ CHAR
END
PCHV P
IF KIND = ONEDLM THEN RETURN
ENDT: IF NOFLG = 0 THEN WHAT ELSE NCHV TOKENP _ EOLIT
	RETURN
END FILL.IN.TOKEN


%QUERY(QUES)
CR; MSG(QUES); MSG('? ')
LOOP DO 
P _ GETLINE(FILNO); TEMP _ NCHV P; WHILE NCHV P # EOLIT THEN NULL
EIF TEMP = $Y OR TEMP = CARRET THEN RETURN 1
ORIF TEMP = $? THEN GO ^RETADR
ELSE IF TEMP = $N THEN RETURN 0
MSG('TYPE "Y" OR "N": ')
END
END QUERY



%GETDLM(DLM)
GBLDLM _ DLM; GETTOKEN(ONEDLM)
IF CH(TOKEN)=DLM THEN RETURN 1 ELSE RETURN 0
END GETDLM



%GETNUM
	!RETURN DECIMAL NUMBER IN NUMBER
GETTOKEN(NUMERIC);SETCOUNT; NUMBER _ 0
FOR I_COUNT TO 0 BY -1 NUMBER+_(NCHV TOKENP-$0)*TEN(I)
IF MINUSF # 0 THEN NUMBER-_
RETURN NUMBER
END GETNUM


%GETOCT
	!INPUT AN OCTAL NUMBER INTO NUMBER
NUMBER _ 0
GETTOKEN(OCTAL); SETCOUNT
DISP _ BITS.PER.WORD
 REPEAT BITS.PER.WORD/3-COUNT-1 DISP-_3
WHILE CHAR_NCHV TOKENP#EOLIT THEN [DISP-_3; BYT(NUMBER,3,DISP)_(CHAR-$0) BAND 7]
RETURN NUMBER
END GETOCT




%CHR.OUT(A)
W(CH.OUT,A)
RETURN
END CHR.OUT



%OCTWD.OUT(A)
OCTOUT(HW(@A,0)); CHROUT($,); OCTOUT(HW(@A,1))
RETURN
END OCTWD.OUT



%OUT(A)
	!OUTPUT A MESSAGE
TEMP _ CHPT(A,-1)
WHILE CHAR_NCHV TEMP#EOLIT THEN [IF CHAR=$$ THEN CHAR_CARRET;&
			CHR.OUT(CHAR)]
RETURN
END OUT



%NUMOUT(N)
	!OUTPUT DECIMAL NUMBER
IF N<0 THEN [CHR.OUT($-); N-_]
IF N>=TEN(6) THEN [OUT('>1000000.'); RETURN]
I_0; WHILE N>=TEN(I+1) THEN INC I
WHILE I>=0 THEN [CHR.OUT($0+N/TEN(I)); N_N MOD TEN(I); DEC I]
RETURN
END NUMOUT


%OCTOUT(N)
	!OUTPUT AN OCTAL HALF WORD
DISP _ BITS.PER.WORD/2
WHILE DISP > 0 THEN [DISP-_3; CHR.OUT($0+BYT(N,3,DISP))]
RETURN
END OCTOUT



%SIXOUT(ADR,N)
	!OUTPUT N CHARACTERS IN SIXBIT
PTR _ BYPT(ADR,1,6)
REPEAT N CHR.OUT(SPACE+NBYV PTR)
RETURN 
END SIXOUT



%MAKE.SIXBIT(FROMADR,TOADR,N)
	!CHANGE N CHARACTERS FROM ASCII IN FROMADR TO SIXBIT IN TOADR
LOCAL FROMP,CHAR
FROMP _ CHPT(FROMADR,-1)
PTR _ BYPT(TOADR,1,6)
REPEAT N DO
IF CHAR _ NCHV FROMP # EOLIT THEN NBYV PTR _ (CHAR-SPACE) BAND OCT 77 &
		ELSE NBYV PTR _ EOLIT
END
RETURN
END MAKE.SIXBIT



%LISTABLE(N.TAB,TAB())
	!LIST ENTIRE TABLE, WITH ENTRIES SEPARATED BY COMMAS...
	!TABLE MUST HAVE >1 ENTRY...DOES NOT TYPE ENTRIES OF -1
LOCAL WD.CNT
I _ 1; WD.CNT _ 0
WHILE TAB(I)=-1 THEN INC I
MSG(TAB(I)); INC I
WHILE I <= N.TAB THEN DO
   IF TAB(I) # -1 THEN DO
	INC WD.CNT
	IF I#N.TAB THEN DO
	   MSG(', ')
	   IF WD.CNT = 4 THEN [CR; WD.CNT _ 0]
	END ELSE MSG(' OR ')
	MSG(TAB(I))
   END
	INC I
END
RETURN
END LISTABLE



%SPOUT(A,B)
IF A = 0 THEN [REPEAT B SP; RETURN]
TEMP _ B
WHILE A < TEN(TEMP) THEN [SP; DEC TEMP]
RETURN
END SPOUT


%SHORT.OUT(PTR,N)
	!OUTPUT TEXT ONLY IN N SPACES...
REPEAT N DO
IF CHAR _ NCHV PTR = EOLIT THEN [SP; PCHV PTR] ELSE CHR.OUT(CHAR)
END
RETURN
END SHORT.OUT




%DATOUT
	!OUTPUT DATE AND TIME
LOCAL MON,HOURS,DAY,MINUTE
CR; TEMP _ EXU(OCT 47,OCT 1,OCT 14)
[TEMP; DAY] _ TEMP DIVMOD 31
[TEMP; MON] _ TEMP DIVMOD 12
NUMOUT(MON+1);SLASH; NUMOUT(DAY+1);SLASH; NUMOUT(64+TEMP); SP; SP
TEMP _ EXU(OCT 47, OCT 1,OCT 22)
[TEMP; ] _ TEMP DIVMOD 3600
[HOURS;MINUTE] _ TEMP DIVMOD 60
NUMOUT(HOURS); COLON
IF MINUTE < 10 THEN CHR.OUT($0)
IF MINUTE = 0 THEN CHR.OUT($0) ELSE NUMOUT(MINUTE)
CR; CR; RETURN
END DATOUT



%CHOOSE(N.TAB,NAME.TAB())
	!FIND A UNIQUE MATCH IN NAM.TAB WITH TOKEN
LOCAL ANS,FIRST,T
ANS _ 0
WHILE STILL.MORE THEN DO
   IF T _ MATCH = 2 THEN RETURN ANS
   IF T = 1 THEN DO
	FIRST_ANS
	WHILE STILL.MORE THEN &
	   [IF MATCH=1 THEN [MSG('$NOT UNIQUE$');RETURN 0]]
	RETURN FIRST
   END
END
RETURN 0


%MATCH
	!RETURN 0 IF NO MATCH, 1 IF MATCH, 2 IF EXACT MATCH (STOP LOOKING)
LOCAL P,COUNT
SET.PTR
P _ CHPT(TOKEN,-1)
COUNT _ 0
WHILE NCHV PTR # EOLIT THEN INC COUNT
SET.PTR
IF NCHV P # NCHV PTR THEN RETURN 0
DEC COUNT
WHILE NCHV P # EOLIT THEN [IF CHV P # NCHV PTR THEN RETURN 0; DEC COUNT]
IF COUNT = 0 THEN RETURN 2 ELSE RETURN 1
END MATCH
END CHOOSE


END TTYIO
