!21 MAR 73   FIPR3.SIM   OCCASIONAL MISC.PROCS.     *CW

DEF BINARY AS 1
GLOBAL.PROC(B.RBLKS,H.B.RBLKS)
GLOBAL.PROC(FND.EXT,H.FND.EXT)
GLOBAL.PROC(FND.CH,H.FND.CH)
GLOBAL.PROC(APP.EXT,H.APP.EXT)
GLOBAL.PROC(BLD.FCB,H.BLD.FCB)
GLOBAL.PROC(OPEN.IT,H.OPEN.IT)
GLOBAL.PROC(CLOSE.IT,H.CLOSE.IT)


FIND FCB.AREA

FIND %OUT.X.BUF
FIND %STR.BLD
FIND %OUT.B.S
FIND %DUP.BUF
FIND %FM.STRING
FIND %PUNT
FIND %R.P.L.DATA
FIND %L.P.L.DATA
FIND %SET.SYMBOL.VALUE
FIND %GET.SYMBOL.VALUE
FIND %FUSBUDGET
FIND %G.ELMT
FIND %GET.BUF.CHAR
FIND %SET.BUF.CHAR
FIND %BLD.ARG
FIND %BLD.CMD
FIND %BUF.LENGTH
!
PROC(B.RBLKS,H.B.RBLKS,'B.RBLKS',(BUF,FNAME,DONOR,TRANS.NUM,BS,BLKS,  &
        CP,FOLD,FT))
!INPUT  BUF PTR (OR E.O.L) TO APPEND NEW COMMAND TO
!       FNAME IS FILE NAME BUF PTR
!       DONOR JOB NAME
!       TRANSACTION NUMBER TO BE USED BY RECIPIENT
!       BLOCK SIZE IN 8-BIT BYTES
!       NUMBER OF BLOCKS TO BE SHIPPED
!       STARTING CURSOR POSITION
!       CHECKSUM FOLD SIZE
!       FILE TYPE
!VALUE:  BUF PTR TO RBLKS COMMAND STRING

LOCAL CB

CB _ BLD.ARG(E.O.L, PRS.T.LIT, FNAME)
BLD.ARG(CB, PRS.T.INT, DONOR)
BLD.ARG(CB, PRS.T.INT, TRANS.NUM)
BLD.ARG(CB, PRS.T.INT, BS)
BLD.ARG(CB, PRS.T.INT, BLKS)
BLD.ARG(CB, PRS.T.INT, CP)
BLD.ARG(CB, PRS.T.INT, FOLD)
BLD.ARG(CB, PRS.T.INT, FT)

BUF _ BLD.CMD(BUF, CB, RBLKS.CMND)

RETURN (BUF)

END.PROC(B.RBLKS,H.B.RBLKS)
!
PROC(FND.EXT,H.FND.EXT,'FND.EXT',(BUF,STR)) !FIND EXTENSION ON FILE NAME
!INPUT:  BUF PTR TO NAME STRING
!        SIMPL STRING TO FIND, E.G, '.BAD'
!VALUE:  0 IF ENTIRE STRING NOT MATCHED; OTHERWISE,
!        COUNT TO FIRST BUFFER CHARACTER OF MATCHING STR, E.G., '.'

LOCAL %COMPARE

LOCAL LEN, BUF.CNT, STR.CNT, CHAR, EXT

EXT _ TRUE
GO COMMON


PROC(%FND.CH,%H.FND.CH,'FND.CH',(BUF, STR))  !FIND A CHAR IN BUF STRING
!INPUT:  SAME AS %FND.EXT EXCEPT ONLY THE FIRST CHAR OF STRING IS USED
!VALUE:  SAME AS %FND.EXT

EXT _ FALSE

COMMON: NULL
LEN _ BUF.LENGTH(BUF)
STR.CNT _ BUF.CNT _ 0

WHILE (INC BUF.CNT) <= LEN &
 THEN &
 DO
  CHAR _ GET.BUF.CHAR(BUF, BUF.CNT)
  IF CHAR = CHAR.XFORM.TO.ASCII( CH(STR, STR.CNT)) &
   THEN &
   DO
    IF NOT EXT  THEN RETURN (BUF.CNT)   !FIRST CHAR MATCHES
    IF COMPARE( LEN, BUF, BUF.CNT, STR, STR.CNT) &
     THEN &
      RETURN (BUF.CNT)              !ENTIRE STRING MATCHES ! &
     ELSE &
      RETURN (0)
   END
 END

RETURN (0)

%COMPARE(LEN, BUF, BUF.CNT, STR, STR.CNT)

LOCAL S.CH, B.CH

DEC BUF.CNT
DEC STR.CNT

WHILE (INC BUF.CNT) <= LEN &
 THEN &
 DO
  IF (S.CH _ CH(STR, INC STR.CNT)) = E.O.LIT &
   THEN &
    RETURN (FALSE)              !STRING SHORTER THAN BUFFER
  B.CH _ GET.BUF.CHAR(BUF, BUF.CNT)
  IF B.CH # CHAR.XFORM.TO.ASCII(S.CH) THEN RETURN (FALSE)
 END

!FINISHED COMPARING EQUAL..HOWEVER, STRING MAY BE LONGER THAN BUFFER
IF CH(STR, INC STR.CNT) # E.O.LIT THEN RETURN (FALSE)

RETURN (TRUE)

END COMPARE

END.PROC(FND.EXT,H.FND.EXT)
!
PROC(APP.EXT,H.APP.EXT,'APP.EXT',(BUF, EXT.STR)) !APPEND EXTENSION
                                !STRING TO FILE NAME
!INPUT:  BUF CONTAINING FILE NAME
!        SIMPL STRING TO APPEND TO FILE NAME IN BUF
!VALUE:  BUF PTR TO EXTENDED FILE NAME

LOCAL CNT, S.CH, I

!APPEND EXTENSION IN EXT.STR ONTO FILENAME IN BUF

CNT _ BUF.LENGTH(BUF)
I _ -1

WHILE (S.CH _ CH(EXT.STR, INC I)) # E.O.LIT &
 THEN &
  SET.BUF.CHAR( BUF, INC CNT, CHAR.XFORM.TO.ASCII(S.CH))

RETURN (BUF)

END.PROC(APP.EXT,H.APP.EXT)
!
PROC(BLD.FCB,H.BLD.FCB,'BLD.FCB',(FCB, FN, CP, MODE, BS, FT, NAME))
                !BUILD FILE CONTROL BLOCK
!INPUT: FCB PTR
!       FILE NUMBER (FROM IOCS)
!       CURSOR POSITION
!       MODE: INPUT, OUTPUT, UPDATE
!       BLOCK SIZE IN 8-BIT BYTES, DEFAULT FROM 'STDBLKSZ'
!       FILE TYPE:  BINARY, SYMBOLIC
!       FILE NAME BUF PTR
!VALUE:  NONE

LOCAL TYPE

!SET UP FILE CONTROL BLOCK
L.FCB.FN(FCB,FN)                        !FILE NUMBER
L.FCB.CP(FCB,0)                         !CURSOR POSITION
L.FCB.OP.P(FCB,TRUE)                    !YES, THIS FILE IS OPEN
L.FCB.MODE(FCB,MODE)                    !READ=1,WRITE=2,UPDATE=3
IF BS = 0 &
 THEN &
 DO
  [TYPE;BS] _ DOUBLE GET.SYMBOL.VALUE(FM.STRING(E.O.L,CHPT( &
                                        'STDBLKSZ')), S.T.VAR)
  IF TYPE # S.V.T.INT &
   THEN &
    PUNT(HARD,'GET.SYM.VAL OF STD.BLK.SZ FAILED ',0) !DEBUG****
 END
L.FCB.BS(FCB,BS)                        !STANDARD BLOCK SIZE IN BYTES
IF FT = 0  THEN  FT _ BINARY            !DEFAULT FILE TYPE IS BINARY
L.FCB.FT(FCB, FT)                       !FILE TYPE: BINARY, SYMBOLIC
L.FCB.NAME(FCB,NAME)                    !BUF PTR TO FILE NAME

RETURN (TRUE)

END.PROC(BLD.FCB,H.BLD.FCB)
!
PROC(OPEN.IT,H.OPEN.IT,'OPEN.IT',(FNAME, MODE, FT)) !OPEN FILE AND
                        !SET UP FCB
!INPUT: FILE NAME BUF PTR
!       MODE: INPUT, OUTPUT, UPDATE
!       FILE TYPE:  BINARY, SYMBOLIC
!VALUE: FCB PTR

LOCAL FN, ORG, FCB, TYPE, OP.ERR:, P, STR

IF PDP10.P THEN  ORG _ PACK  ELSE  ORG _ CHARACTER

!FILE MAY BE IN SYMBOL TABLE ALREADY; IF NOT, THEN ENTER IT
[TYPE; FCB] _ DOUBLE GET.SYMBOL.VALUE(DUP.BUF(E.O.L,FNAME,0), S.T.FILE)
IF TYPE = S.V.T.PTR &
 THEN &
 DO
  !WE HAVE SYMBOL IN DICTIONARY ALREADY
  IF R.FCB.OP.P(FCB) = TRUE &
   THEN &
   DO
    PUNT(MED, 'FILE ALREADY OPEN--', 1, 2, STR.BLD(FNAME,0))
    RETURN (FALSE)      !********SHOULD SEND ERR COMMAND HERE******
   END
 END &
ELSE &
DO
 !SYMBOL MUST BE ENTERED IN DICTIONARY, GET FCB ELMT
FUSBUDGET
 FCB _ G.ELMT(FCB.AREA)
 P _ SET.SYMBOL.VALUE(DUP.BUF(E.O.L,FNAME,0),S.T.FILE,S.V.T.PTR,FCB )
FUSBUDGET
 IF NOT P &
  THEN &
  DO
   PUNT(MED, 'FILENAME NOT ENTERED IN SYM TAB:', 1, 2,STR.BLD(FNAME,0))
   RETURN (FALSE)
  END
END

!OPEN FILE
BUG: NULL
STR _ STR.BLD(FNAME, 0)
MSG('CALLING IOCS OPEN. FILE IS ')
OUT.B.S(TEL, FNAME, %OUT.X.BUF)
FN _ OPEN(STR, MODE+ORG+DIRECT, OP.ERR)
BLD.FCB(FCB, FN, 0, MODE, 0, BINARY, FNAME)

RETURN (FCB)

OP.ERR: PUNT(MED, 'FILE OPEN FAILED:', 1, 2, STR.BLD(FNAME,0))
        RETURN (FALSE)

END.PROC(OPEN.IT,H.OPEN.IT)
!
PROC(CLOSE.IT,H.CLOSE.IT,'CLOSE.IT',(FCB)) !CLOSE A FILE;MARK FCB CLOSED
!INPUT: FILE CONTROL BLOCK OF FILE TO BE CLOSED
!VALUE: NONE

MSG('CLOSE.IT$')

CLOSE(R.FCB.FN(FCB))            !CLOSE FILE
L.FCB.OP.P(FCB, FALSE)          !OPEN PREDICATE SET CLOSED

RETURN

END.PROC(CLOSE.IT,H.CLOSE.IT)
