GLOBAL BIND EXPRV=21	;!20-JUNE-73
BIND PRECEDENCE =	!THE PRECEDENCE OF THE EXPRESSION OPERATORS
	PLIT(	%PRECEDENCE,,OPERATOR FLAG COMBINED IF NEGATIVE%
	0,	!NULL FOR INDEXING
	0,	!LINEND
	0,	!EQUAL
	0,	!(
	0,	!)
	0,	![
	0,	!]
	0,	!:
	0,	!,
	0,	!$
	-1,	!**
	-2,	!*
	-2,	!/
	-3,	!+
	-3,	!-
	-4,	!RELATIONAL
	-5,	!.NOT.
	-6,	!.AND.
	-7,	!.OR.
	-8,	!.EQV. OR .XOR.
	0,	!IDENTIFIER
	0,	!CONSTANT
	0	!LITERAL
	);

MACRO	OPER(X)= (.PRECEDENCE[X] LSS 0)$;

MACRO ERR0(X)=( ENTRY[1]_ .LEXNAME[.LEXL<LEFT>];
			ENTRY[2]_X; RETURN ERROUT(0))$;
MACRO MAKENEGAT = (LOCAL BASE NEGNOD;
			NAME _ EXPTAB;
			NEGNOD _ NEWENTRY();
			NEGNOD[OPRCLS]_ NEGNOT; NEGNOD[OPERSP]_NEGOP;
			.NEGNOD
		)$;

MACRO MAKLABEL(X)= (
			MAP BASE T1;
			T1 _ .X; ENTRY[0]_.T1[CONST2]; NAME _ LABTAB;
			NEWENTRY()
		   )$;
EXTERNAL NEWENTRY,LEXEMEGEN,LEXL,LSAVE,STK,SP,ERROUT,LEXNAME;
GLOBAL ROUTINE EXPRESSION=
BEGIN
%
ROUTINE IS AN "ACTION" ROUTINE CALLED BY THE SYNTAX ANALYSER
TO PARSE A GENERAL FORTRAN EXPRESSION.
RETURNS A PTR TO AN EXPRESSION NODE IN STK[SP_.SP+1]
%
EXTERNAL SP,STK,LOGEXPRESSION;
LOCAL LSP;  !LOCAL STK PTR;
	LSP _ .SP;
	IF .LSAVE EQL 0
	THEN  (LSAVE_-1;LEXL _ LEXEMEGEN());
	IF .LEXL<LEFT> EQL LINEND THEN ERR0(PLIT'IDENTIFIER'); !NO EXPRESSION FOUND
	RETURN  STK[SP_.LSP+1]_LOGEXPRESSION();
END;
GLOBAL ROUTINE LOGEXPRESSION=
BEGIN
%
ROUTINE IS CALLED BY THE ACTION ROUTINE EXPRESSION
TO PARSE AN ARBITRARY FORTRAN EXPRESSION
THE ROUTINE IS AN OPERATOR PRECEDENCE  METHOD, THE PRECEDENCE OF THE
OPERATORS IS GIVEN IN THE TABLE PRECEDENCE IN THIS FILE

ROUTINE IS RECURSIVE
THE OPERATORS ** AND UNARY MINUS ARE HANDLED AS SPECIAL CASES IN THIS ROUTINE AND THE ROUTINES IT CALLS

%
MACRO BLDTREE(OPRATOR)=
BEGIN
LABEL BLDTR;
BLDTR: BEGIN
	LOCAL OPR;
	REGISTER BASE R2; MAP BASE T1:T2;
	OPR_.OPRATOR;
	NAME _ EXPTAB; !GENERATE AN EXPRESSION NODE
	T1 _ NEWENTRY();
	T1[ARG2PTR]_R2 _ .STAK[.STP]; STP _ .STP-1;
	IF .OPR<LEFT> EQL LOGICLNOT
	THEN
	   BEGIN
		T1[OPRCLS] _ NEGNOT; T1[OPERSP]_ NOTOP;
		IF .R2[OPRCLS] EQL DATAOPR THEN T1[A2VALFLG] _1
			ELSE (R2[PARENT] _ .T1;
				IF .R2[FNCALLSFLG] THEN T1[FNCALLSFLG] _ 1;
			     );
		T1[VALTYPE] _ .R2[VALTYPE];
		LEAVE BLDTR WITH .T1;
	    END;
	T1[ARG1PTR] _  .STAK[STP_.STP-1];
	CASE .OPR<LEFT>-10 OF SET
%POWER%		(T1[OPRCLS]_ARITHMETIC;T1[OPERSP]_EXPONOP);
%TIMES%		(T1[OPRCLS]_ARITHMETIC;T1[OPERSP]_MULOP);
%DIVIDE%	(T1[OPRCLS]_ARITHMETIC;T1[OPERSP]_DIVOP);
%PLUS%		(T1[OPRCLS]_ARITHMETIC;T1[OPERSP]_ADDOP);
%MINUS%		(T1[OPRCLS]_ARITHMETIC;T1[OPERSP]_SUBOP);
%RELATION%	(T1[OPRCLS]_RELATIONAL;T1[OPERSP]_.OPR<RIGHT>);
%NOT%		(T1[OPRCLS]_NEGNOT;T1[OPERSP]_NOTOP);
%AND%		(T1[OPRCLS]_BOOLEAN;T1[OPERSP]_ANDOP);
%OR%		(T1[OPRCLS]_BOOLEAN;T1[OPERSP]_OROP);
%MATCH%		(T1[OPRCLS]_BOOLEAN;T1[OPERSP]_ IF .OPR<RIGHT> EQL 1 THEN EQVOP ELSE XOROP)
		TES;
		R2 _ .T1;  EXPRTYPER(.T1); !SAVING EXPRESSION PTR
			!EXPRTYPER BUILDS A TYPE CONVERSION NODE IF NECESSARY
		T1_.R2;	!RESTORING PTR
		R2_.T1[ARG2PTR]; T2_.T1[ARG1PTR]; !RESTORING PTRS
		IF .R2[OPRCLS] EQL DATAOPR THEN T1[A2VALFLG]_1
			 ELSE (R2[PARENT]_.T1;IF .R2[FNCALLSFLG] THEN T1[FNCALLSFLG] _1;);

		  IF .T2[OPRCLS] EQL DATAOPR THEN T1[A1VALFLG]_1
			 ELSE (T2[PARENT]_.T1; IF .T2[FNCALLSFLG] THEN T1[FNCALLSFLG] _ 1;);

	.T1
   END
END$;	!OF MACRO BLDTREE
LOCAL STAK[14], STP; !STACK AND STACK PTR
REGISTER BASE R1;
EXTERNAL EXPRTYPER,PRIMITIVE,STK;
LABEL EXPR1,EXPR2;

!
!CHECK FOR STACK OVERFLOW
!
IF .SREG<RIGHT> GEQ (STK-20)<0,0> THEN RETURN ERROUT(90);
!
STP _ -1;	!INITIALIZE THE STACK PTR
WHILE 1 DO
BEGIN
EXPR1:
	IF .LEXL<LEFT> NEQ LOGICLNOT
	THEN
	   BEGIN
		IF (STAK[STP_.STP+1] _ PRIMITIVE()) LSS 0 THEN RETURN -1; !GET AN OPERAND OR OPERATOR
				!RETURN ON ERROR (-1)
	EXPR2:  WHILE 1 DO
		BEGIN
		   IF NOT OPER(.LEXL<LEFT>)
			THEN (IF .STP LEQ 0 THEN RETURN .STAK[.STP];)
			ELSE (
				IF .STP LEQ 0 THEN LEAVE EXPR2;
				IF .PRECEDENCE[.LEXL<LEFT>] GTR .PRECEDENCE[.STAK[.STP-1]<LEFT>]
				THEN LEAVE EXPR2; !LEAVE TO STACK THE OPERATOR
			     );
		!HERE IF NOT OPERATOR AND STACK PTR GTR 0
		!OR
		!IF OPERATOR PRECEDENCE LEQ PREVIOUS OPERATOR'S

		   STAK[.STP] _ BLDTREE(STAK[.STP-1]);	!BUILD A TREE NODE
		END; !OF WHILE 1 DO
	    END; !OF IF LEXL NEQ NOTOP
	!
	!HERE IF STACKING HIGER PRECEDENCE OPERATOR OR
	!NOT OP SEEN OR FIRST OPERATOR SEEN
	!
	STAK[STP_.STP+1] _ .LEXL;
	LEXL _ LEXEMEGEN();
END;	!OF WHILE 1 DO
	!EXIT FROM THIS LOOP IS BY RETURN FROM INSIDE THE LOOP
END;	!OF LOGEXPRESSION
GLOBAL ROUTINE REFERENCE=
BEGIN
%
ROUTINE PARSES A VARIABLE OR FUNCTION REFERENCE
INCOMING LEXEME IS ALREADY AVAILABLE IN LEXL AND MUST BE AN IDENTIFIER
ROUTINE THEN PROCEEDS TO CHECK FOR ARRAY OR FUNCTION REFEERENCE
AND IF A LEFT PAREN IS SEEN THEN THE LST OF SUBSCRIPTS OR ARGUMENTS IS SCANNED
ROUTINE RETURNS A PTR TO A VARIABLE OR FUNCTION REFERENCE NODE
%
LOCAL BASE IDPTR;
EXTERNAL MAKLIBFUN;	!MAKES A LIBRARY FUNCTION CALL NODE
EXTERNAL ARRXPN,LIBSRCH,ASTATFUN,CORMAN,COPYLIST,SAVSPACE,PROGNAME,TBLSEARCH;
MAP BASE T1:T2;
MACRO ERR65(X)= (ENTRY[1]_X; RETURN ERROUT(65))$;
MACRO ERR47(X)=( ENTRY[1]_ X; RETURN  ERROUT(47))$;

IF .LEXL<LEFT> NEQ IDENT
THEN ERR0(PLIT'IDENTIFIER?0');
IDPTR _ .LEXL<RIGHT>; !PTR TO IDENTIFIER
LEXL _ LEXEMEGEN(); !NEXT LEXEME TO LOOK FOR "("
IF .LEXL<LEFT> EQL LPAREN
THEN
    BEGIN	!ARRAY REFERENCE OR FUNCTION REFERENCE
	LOCAL LSP; LSP _.SP;	!SAV THE STK PTR FO SYNTAX
	DO BEGIN	!WHILE REFERENCE FOLLOWED BY ","
		LEXL _ LEXEMEGEN();
		IF .IDPTR[OPRSP1] NEQ ARRAYNM1  !IF NOT ARRAY THEN FUNCTION CALL
		THEN FLGREG<FELFLG> _ 1 !SET FLG FOR CHECKING ARGS IN ARGLIST OF FUNCTION
		ELSE IF .ASTATFUN NEQ 0
			THEN IF .IDPTR[IDATTRIBUT(SFDUMMY)]
				THEN(ENTRY[1] _ PLIT'DUMMY?0';
					ENTRY[2] _ IDPTR[IDSYMBOL];
					RETURN ERROUT(4) !ILLEGAL USE OF DUMMY
				    );
		IF (.LEXL<LEFT> NEQ DOLLAR) AND (.LEXL<LEFT> NEQ ASTERISK)
		THEN (IF ( STK[SP _ .SP+1] _ LOGEXPRESSION()) LSS 0 THEN RETURN -1)
		ELSE
		   BEGIN
			!IF .IDPTR[OPRSP1] EQL ARRAYNM1 THEN ERR0(PLIT'EXPRESSION');
			!LEXL _ LEXEMEGEN();
			!IF .LEXL<LEFT> NEQ CONST THEN ERR0(PLIT'LABEL');
			!STK[SP_.SP+1]_MAKLABEL(LEXL<RIGHT>); !CONVERT TO LABEL NODE
			!LEXL _ LEXEMEGEN(); !GET NEXT LEXEME
			!
			!LABEL ARGS ARE ILLEGAL IN FUNCTION OR ARRAY REF'S
			RETURN ERROUT(83);
		   END;
	   END WHILE .LEXL<LEFT> EQL COMMA;
	IF .LEXL<LEFT> NEQ RPAREN THEN ERR0(PLIT('RPAREN'));
	FLGREG<FELFLG> _ 0; !TURN OFF FELFLG FOR NEXT FUNCTION CALL
	IF NOT .IDPTR[PARENLSTFLG]
		THEN IF ISDEFIND(IDPTR)
			THEN (ENTRY[1] _ IDPTR[IDSYMBOL]; ENTRY[2] _ PLIT'AN ARRAY';
					RETURN ERROUT(15))
			ELSE IDPTR[OPERSP] _ IF .IDPTR[IDATTRIBUT(DUMMY)] 
						THEN FORMLFN ELSE FNNAME;
	COPYLIST(.LSP); !COPY LIST FROM STK TO FREE CORE
	INCR ARG FROM .STK[.SP] TO .STK[.SP]+.STK[.SP]<LEFT> DO
	BEGIN MAP BASE ARG;
		MACRO ARGPTR=0,0,FULL$, ARGFLG=0,0,LEFT$;
		LOCAL BASE R2;
		R2 _ .ARG[ARGPTR];
		IF .R2[OPRCLS] EQL DATAOPR
		THEN ARG[P1AVALFLG] _ 1
		ELSE ARG[P1AVALFLG] _ 0;
	END; !OF INCR ARG
!
!NOW SEE IF FUNCTION CALL OR ARRAY REF TO MAKE PROPER NODE TYPE
!
	LEXL _ LEXEMEGEN(); !FOR POSSIBLE RETURN TO CALLING ROUTINE
	IF .IDPTR[OPRSP1] EQL FNNAME1
	THEN !IDENTIFIER IS FUNCTION NAME
	   BEGIN
		LOCAL BASE ARGPT: FNEXPR;
		REGISTER R2;	!FOR PTR TO FUNTION ARG LIST
		FLGREG<BTTMSTFL> _ 0;  !TURN OFF BOTTOMOST ROUTINE FLAG
			!CHECK FOR RECURSIVE FUNCTION OR SUBPROGRAM
		   IF (.IDPTR EQL .ASTATFUN) OR (.IDPTR[IDSYMBOL] EQL .PROGNAME)  THEN ERR47(IDPTR[IDSYMBOL]);
		NAME<LEFT> _ .STK[.SP]<LEFT>+3;
		R2 _ CORMAN(); !CORE FOR FUNCTION ARGLIST
		!
		!NOW MOVE THE ARGLIST TO A BLOCK POINTED TO BY R2
		!BEGINNING AT WORD .R2+2 OF THE BLOCK
		!
		NAME _ EXPTAB; ENTRY[0] _ .IDPTR; ENTRY[1] _ .R2;
		FNEXPR_NEWENTRY();	!MAKE AN EXPREESION NODE FOR FNCALL
		FNEXPR[VALTYPE] _ .IDPTR[VALTYPE];  FNEXPR[OPRCLS] _ FNCALL;
		(.R2+1)<RIGHT> _ .STK[.SP]<LEFT>+1; !NUMBER OF ARGS
		!PREPARE TO MOVE ARGLIST TO NEW AREA
		T1 _ .STK[.SP];  T2 _ .R2+2;  !FROM T1 TO T2
		DECR I FROM .STK[.SP]<LEFT> TO 0 DO
		BEGIN
		  (.T2)[.I] _ ARGPT _  @(.T1)[.I];
		  IF .ARGPT<LEFT> EQL 0  !IS ARG FUNCTION OR EXPRESION
			THEN ARGPT[PARENT] _ .FNEXPR;
		  IF .ARGPT[OPRCLS] EQL DATAOPR
		  THEN IF .ARGPT[OPERSP] NEQ CONSTANT
			THEN ARGPT[IDATTRIBUT(STORD)] _ 1;
		END;
!
!	NOW IF FUNCTION CALL IS TO LIBRARY CALL SPECIAL PROCESSING ROUTINE
!	IN MODULE GNRCFN
!
		IF  NOT .IDPTR[IDATTRIBUT(INEXTERN)]
		THEN (
			LOCAL LIBPTR;
			IF (LIBPTR_ LIBSRCH(.IDPTR[IDSYMBOL])) NEQ -1
			THEN (
				MAKLIBFUN(.LIBPTR,.FNEXPR);	!MAKE THE LIB FUNCTION CALL NODE
				)
			ELSE FNEXPR[OPERSP] _ NONLIBARY
		     );
!
		SAVSPACE(.STK[.SP]<LEFT>,.STK[.SP]); !SAVE THE ARGLIST SPACE
		IDPTR _  .FNEXPR;
	   END
	ELSE
		IDPTR _  ARRXPN(.IDPTR,.STK[.SP]);
		SP _ .LSP;	!RESTORING STK PTR TO ORIGINAL TO AVOID RECURSION PROBLEMS
   END
ELSE
	!CHECK USE O NAME WITHOUT SUBSCRIPTS OR ARGS
   IF .IDPTR[PARENLSTFLG]
    THEN IF (.ASTATFUN EQL 0) AND NOT .IDPTR[IDATTRIBUT(SFDUMMY)] 
	THEN !ARRAYNAME OR FUNCTION NAME W/O ARGS OR SUBSCRIPTS
	  BEGIN
	     IF .IDPTR[IDSYMBOL] NEQ .PROGNAME
	     THEN
		IF NOT .FLGREG<FELFLG>
		THEN !ERRONEOUS USE OF IDENTIFIER
		   BEGIN
			ENTRY[2] _ IDPTR[IDSYMBOL];
			IF .IDPTR[OPRSP1] EQL FNNAME1
			  THEN ENTRY[1]_FNPLIT
			  ELSE ENTRY[1]_ARPLIT;
			RETURN ERROUT(4);
		   END;
	  END;
RETURN .IDPTR	!RETURN HERE ONLY
END;	!OF REFERENCE
GLOBAL ROUTINE PRIMITIVE=
BEGIN
%
PARSES A PRIMITIVE OF AN EXPRESSION
	THESE ARE:
	[$ OR * OR &]LABEL
	[+,-]CONSTANT OR LITERAL
	[+,-]REFERENCE (ARRAY OR FUNCTION)
	A**B
	(REAL,REAL) COMPLEX CONSTANT
	(EXPRESSION)
AND LEAVES NEXT LEXEME AVAILABLE WHEN FINISHED
%
LOCAL BASE NEGATNODE;
LOCAL BASE REALPART:IMAGPART;
MACRO MAKEREAL(X)=
BEGIN
	EXTERNAL KTYPCB,CNVNODE;
	C1H_0;
	C1L_X;
	COPRIX _ KKTPCNVIX(REAL2,FROMINT);
	CNSTCM();
END$;
MACRO DNEG(X)=
BEGIN
	C1H _ X[CONST1];	!HIGH ORDER
	C1L _ X[CONST2];	!LOW ORDER
	COPRIX _ KDNEGB + .CKA10FLG;
	CNSTCM();	!CONVERT TO NEG
	MAKECNST(REAL,.C2H,.C2L)
END$;
EXTERNAL CNSTCM,C1H,C1L,C2H,C2L,COPRIX,KDPRL,KDNEGB;
EXTERNAL EXPRTYPER,TBLSEARCH;
LABEL PRIM1;
NEGATNODE _ 0;
WHILE 1 DO
BEGIN	!SCAN UNTIL NO LEADING + OR MINUS
	IF .LEXL<LEFT> EQL MINUS
	THEN( IF .NEGATNODE EQL 0 THEN NEGATNODE _ MAKENEGAT ELSE NEGATNODE _ 0;
		  LEXL _ LEXEMEGEN();
		)
	ELSE  IF .LEXL<LEFT> EQL PLUS
		THEN LEXL _ LEXEMEGEN()
		ELSE EXITLOOP;
END; !OF WHILE 1 DO

PRIM1:
	IF .LEXL<LEFT> EQL LPAREN
	THEN !PRENTHESIZED EXPRESSION OR COMPLEX CONSTANT
	   BEGIN
		LEXL _ LEXEMEGEN();
		IF (REALPART _ LOGEXPRESSION()) LSS 0 THEN RETURN -1; !RECURSE RETURN IF ERROR
		IF .LEXL<LEFT> EQL COMMA
		THEN  !EXPECTING A COMPLEX CONSTANT
		   BEGIN
			LOCAL NEGSIGN;
			NEGSIGN _ 0;
			IF .REALPART[OPRCLS] NEQ DATAOPR
			THEN !MUST BE A NEGATIVE CONSTANT
			  (
			   REALPART _ .REALPART[ARG2PTR];
			   IF .REALPART[OPERSP] NEQ CONSTANT THEN ERR0(PLIT('RPAREN'));
			   NEGSIGN _ -1;
			  )
			ELSE IF .REALPART[OPERSP] NEQ CONSTANT
				 THEN ERR0(PLIT('RPAREN'));
			IF .REALPART[VALTYPE] EQL INTEGER THEN REALPART _ ( MAKEREAL(.REALPART[CONST2]);MAKECNST(REAL,.C2H,.C2L));
			IF .NEGSIGN NEQ 0 THEN REALPART _DNEG(.REALPART);
			!NOW CONVERT TO SINGLE PRECISION
			IF .REALPART[VALTYPE] NEQ OCTAL
			THEN
			BEGIN
			  C1H _ .REALPART[CONST1]; C1L _ .REALPART[CONST2];
			  COPRIX _ KDPRL;
			  CNSTCM();	!CONVERSION ROUTINE
			  REALPART _ .C2H;
			END
			  ELSE REALPART _ .REALPART[CONST2]; !GET THE OCTAL BITS
			NEGSIGN _ 0;
		 	LEXL _ LEXEMEGEN();
			IF .LEXL<LEFT> EQL PLUS
			THEN LEXL _ LEXEMEGEN()
			ELSE IF .LEXL<LEFT> EQL MINUS
				THEN( NEGSIGN _ -1; LEXL _ LEXEMEGEN());
			IF .LEXL<LEFT> NEQ CONST THEN ERR0(PLIT'CONSTANT');
			IMAGPART _ .LEXL<RIGHT>;
			IF .IMAGPART[VALTYPE] EQL INTEGER THEN IMAGPART _ (MAKEREAL(.IMAGPART[CONST2]); MAKECNST(REAL,.C2H,.C2L));
			IF .NEGSIGN NEQ 0 THEN IMAGPART_ DNEG(.IMAGPART);
			!NOW CONVERT TO SINGLE PRECISION
			IF .IMAGPART[VALTYPE] NEQ OCTAL
			THEN
			BEGIN
			  C1H _ .IMAGPART[CONST1]; C1L _ .IMAGPART[CONST2];
			  COPRIX _ KDPRL;
			  CNSTCM();	!CONVERSION ROUTINE
			  IMAGPART _ .C2H;
			END
			  ELSE IMAGPART _ .IMAGPART[CONST2];  !GET THE OCTAL BITS
			REALPART _ MAKECNST(COMPLEX,.REALPART,.IMAGPART);
			LEXL _ LEXEMEGEN();

		   END !OF IF COMMA
		ELSE IF .REALPART[OPRCLS] NEQ DATAOPR THEN REALPART[PARENFLG] _ 1;
		IF .LEXL<LEFT> NEQ RPAREN THEN ERR0(PLIT('RPAREN'));
		LEXL_ LEXEMEGEN(); !THIS IS TO LOOK AHEAD FOR EXPONENT OPERATOR
		LEAVE PRIM1;
	   END	!OF IF ... LPAREN
	ELSE	!NOT A PARENTHESIZED EXPRESSION
	   BEGIN
		IF (.LEXL<LEFT> EQL CONST) OR (.LEXL<LEFT> EQL LITSTRING)
		  THEN (REALPART _ .LEXL<RIGHT>; LEXL _ LEXEMEGEN())
		  ELSE
			IF ( REALPART _ REFERENCE()) LSS 0 THEN RETURN -1; !VARIABLE OR FUNCTION REFERENCE
		 !REFERENCE WILL RETURN WITH NEXT LEXEME IN LEXL
	   END;  !OF PRIM1:

!
!HERE NOW TO CHECK FOR ** OPERATOR AND SPECIAL PRIMITIVE
!REALPART CONTAINS EITHER
!	1. PTR TO CONSTANT NODE OR
!	2. PTR TO EXPRESSION NODE OR
!	3. PTR TO VARIABLE OR FUNCTION REFERENCE
!
	IF .LEXL<LEFT> EQL POWER
	THEN
	   BEGIN !MAKE AN EXPONENT NODE
		LOCAL BASE EXPON;MAP BASE T1;

		NAME _ EXPTAB; EXPON_NEWENTRY();
		EXPON[OPRCLS]_ARITHMETIC; EXPON[OPERSP]_EXPONOP;
		EXPON[ARG1PTR] _ .REALPART; !BASE
		!NOW CHECK FOR SONS BEING DATAOPR OR NOT AND SET PARENT POINTERS APPROPRIATELY
		LEXL _ LEXEMEGEN();
		IF (REALPART  _ PRIMITIVE()) LSS 0 THEN RETURN -1; !RECURSE TO GET A**B**C = A**(B**C)
		EXPON[ARG2PTR]_.REALPART;
		EXPRTYPER(.EXPON);	!CHECK FOR TYPE CONVERSIONS
		REALPART _ .EXPON[ARG1PTR];	!CHECK SONS NOW
		IF .REALPART[OPRCLS] EQL DATAOPR
			THEN EXPON[A1VALFLG]_1
			ELSE ( REALPART[PARENT]_.EXPON;
				IF .REALPART[FNCALLSFLG] THEN EXPON[FNCALLSFLG]_1;
			     );
		REALPART _ .EXPON[ARG2PTR];	!CHECK SON AGAIN
		IF .REALPART[OPRCLS] EQL DATAOPR
			THEN EXPON[A2VALFLG]_1
			ELSE ( REALPART[PARENT]_.EXPON;
				IF .REALPART[FNCALLSFLG] THEN EXPON[FNCALLSFLG]_1;
			     );
		REALPART _ .EXPON;
	   END;
	IF .NEGATNODE NEQ 0
	  THEN(
		IF .REALPART[VALTYPE] EQL DOUBLOCT
		THEN
		%(***FOR NEGATIVE OF A DOUBLE-OCTAL CONSTANT (UGH!!!) USE ONLY
			ONE WD OF PRECISION. CONVERT THE CONST TO SINGLE-OCTAL***)%
		REALPART_CNVNODE(.REALPART,OCTAL,.NEGATNODE);

		 NEGATNODE[ARG2PTR]_.REALPART;
		IF .REALPART[OPRCLS] EQL DATAOPR
			THEN NEGATNODE[A2VALFLG]_1
			ELSE ( REALPART[PARENT]_.NEGATNODE;
				IF .REALPART[FNCALLSFLG] THEN NEGATNODE[FNCALLSFLG]_1;
			     );
		NEGATNODE[VALTYPE]_ (IF .REALPART[VALTYPE] EQL CONTROL THEN LOGICAL ELSE .REALPART[VALTYPE]);
		RETURN .NEGATNODE
		)
	   ELSE   RETURN .REALPART;
END; !0F ROUTINE PRIMITIVE
  