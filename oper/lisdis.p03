BASE 0

!PROCEDURES
GLOBAL %LISDIS
FIND %INITTTY, %HASH, %GETNUM, %SETOPR
FIND %SPOUT, %CHR.OUT, %SIXOUT, %NUMOUT, %OCTWD.OUT
FIND %DATOUT,%NEWGET
LOCAL %CHK.IO.ERR,%CHK.ACT.ERR
LOCAL %OPEN.LUD
LOCAL %LUD.LOOK,%INITDISTRICT,%LUD.OVERFLOW

DEF SIZE.BLK AS 128

!ID'S
FIND TOKEN(0)
GLOBAL OPRLIC
FIND USER(0),CUST(0),PPN,IER,ICODE,MODE
GLOBAL NUMBER,NAME.HASH,LOC.HASH,P,GETCMD:,CH.OUT
LOCAL THIS.DIST, THIS.PPN
LOCAL %DUL.LOOK, %OPEN.DUL, %DUL.OVERFLOW, D.BLK(SIZE.BLK), D.INDEX, CH.DUL

LOCAL CH.LUD
LOCAL L.INDEX,L.BLK(SIZE.BLK),TEMP,NAME(2)



!MACRO'S
DEF CALL.GETACT(A,B) AS [ICODE_A; MODE_B; NEWGET]
DEF CR AS CHR.OUT(CARRET)
DEF DIST.BITS AS BYT(LUD(1),8,0)
DEF FIXCP(A) AS (A-1)*SIZE.BLK	!COMPUTE CURSOR POS. FROM BLK. NO.
DEF DUL.READ AS [RB(CH.DUL,SIZE.BLK,D.BLK); D.INDEX_0]
DEF LUD.READ AS [RB(CH.LUD,SIZE.BLK,L.BLK); L.INDEX_0]
DEF DUL(A) AS D.BLK(D.INDEX+A)
DEF LUD(A) AS L.BLK(L.INDEX+A)
DEF OV.BLK AS HW(@LUD(0),1)
DEF SIZE.LUD.ENT AS BYT(LUD(2),7,0)
DEF SP AS CHR.OUT(SPACE)
DEF SPACE AS $ 
DEF VERSION AS 3


!LABELS
LOCAL LUD.ERR:,CHK.ERR:
%LISDIS
	!MAINLINE
START: IOCS(2); INITDISTRICT
\\->START
GETCMD: CR;  OPEN.LUD

TEMP _ 0
CALL.GETACT(1,1); CHK.ACT.ERR
LOOP DO
   CALL.GETACT(4,1)
   IF IER = 2 THEN DO
	IF TEMP = 0 THEN MSG('$NO CUSTOMERS FOUND.$')
	EXIT
   END
   CHK.ACT.ERR
   IF THIS.DIST = CUST(1) THEN DO
	INC TEMP
	SPOUT(CUST(0),5); NUMOUT(CUST(0)); SP
	SIXOUT(CUST+9,30); CR
   END
END





%LUD.LOOK(ADR)
	!LOOK UP NAME IN ADR,ADR+1 IN LUD
HASH(^ADR,^(ADR+1))
SETCP(CH.LUD,FIXCP(LOC.HASH)); LUD.READ 
WHILE NAME.HASH # LUD(4) THEN DO	
	L.INDEX+_SIZE.LUD.ENT
	IF LUD(0)=0 THEN RETURN 0
	IF LUD(0)<0 THEN LUD.OVERFLOW
	END
RETURN 1
END LUD.LOOK


%CHK.ACT.ERR
	!CHECK ACCTG. ERROR
IF IER = 0 THEN RETURN
MSG('ERROR ON '); IF MODE < 0 THEN MSG('USERNA.MES') ELSE MSG('CUSTOM.ERS')
CR

DO IER OF 1:4
1: MSG('ENTRY NOT FOUND.')
2: MSG('END OF FILE FOUND.')
3: MSG('ERROR ON FILE.')
4: MSG('MISC. ERROR.')
END
EXIT
END CHK.ACT.ERR



%CHK.IO.ERR
	!TAKE CARE OF ALL I/O ERRORS FROM IOCS...
CHK.ERR: MSG('ERROR ON ');WFID(FIDP);MSG('...');CR
  DO ERRNUM OF TMFERR:CORERR
FNDERR: MSG('BAD FILE MODE OR TYPE')
IFDERR: MSG('ILLEGAL FILE IDENTIFIER')
FNFERR: MSG('FILE NOT FOUND')
IUSERR: MSG('INVALID USER NAME')
PRTERR: MSG('PROTECTION FAILURE')
EOFERR: MSG('END OF FILE')
 END
MSG('.$ERROR ');NUMOUT(ERRNUM);EXIT
END CHK.IO.ERR


%LUD.OVERFLOW
	!READ LUD OVERFLOW BLOCK
SETCP(CH.LUD,OV.BLK*SIZE.BLK)
LUD.READ
RETURN
END LUD.OVERFLOW




%INITDISTRICT
	!INIT PROGRAM
INITTTY(GETCMD)
PPN _ OCT 1042313
CH.OUT _ OPEN('TEL',SEQUEN+OUTPUT+CHARACTER,CHK.ERR,2)
MOVE 72/CHARS.PER.WORD FROM ALL 0 TO TOKEN
THISPPN _ EXU(OCT 47,OCT 1,OCT 24)
OPEN.DUL
IF DUL.LOOK(THISPPN) = 0 THEN DO
	OCTWD.OUT(THISPPN)
	MSG(' IS NOT IN THE DUL')
	EXIT
END
OPEN.LUD
IF LUD.LOOK(@DUL(1)) = 0 THEN DO
	SIXOUT(D.BLK+D.INDEX+1,12)
	MSG(' IS NOT IN THE LUD')
	EXIT
END
IF BYT(LUD(3),1,14) # 1 THEN EXIT
MSG('$LIST DISTRICT - VERSION '); NUMOUT(VERSION); MSG('$$$')
IF THISDIST _ DIST.BITS = 0 THEN DO
	MSG('$DISTRICT: ')
	GETNUM
	THISDIST _ NUMBER
END
SETOPR
 RETURN
END INITDISTRICT



%OPEN.LUD
	!LOOK FOR LUD.SYS ON DSK
	CH.LUD_OPEN('(SYS)LUD.SYS',DIRECT+INPUT+WORD,LUD.ERR)
	RETURN
LUD.ERR:CHK.IO.ERR
END OPEN.LUD






%OPEN.DUL
LOCAL DUL.ERR:
CH.DUL _ OPEN('(SYS)DUL.SYS',DIRECT+INPUT+WORD,DUL.ERR)
RETURN
DUL.ERR: CHK.IO.ERR
END OPEN.DUL


%DUL.LOOK(PP)
SETCP(CH.DUL,FIXCP((PP MOD 101)+1)); DUL.READ
WHILE DUL(0) # PP THEN DO
	D.INDEX + _ 3
	IF DUL(0) = 0 THEN RETURN 0
	IF DUL(0) < 0 THEN DUL.OVERFLOW
	END
RETURN 1
END DUL.LOOK


%DUL.OVERFLOW
SETCP(CH.DUL,HW(DUL(0),1) * SIZE.BLK)
DUL.READ
RETURN
END DUL.OVERFLOW
END LISDIS
