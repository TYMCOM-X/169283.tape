MODULE DOZE(DOLLAR,ENTRIES=($DTNS,$DCONV),
        FSAVE,TIMING,TIMER=EXTERNAL(SIX12))=
BEGIN

REQUIRE DDEFS.BLI[7,107355];
REQUIRE DVDEFS.BLI[7,107355];
REQUIRE GDEFS.BLI[7,107355];
REQUIRE UDEFS.BLI[7,107355];
REQUIRE FPDEFS.BLI[7,107355];
REQUIRE RDEFS.BLI[7,107355];
REQUIRE SDEFS.BLI[7,107355];

MAP U$DYNARY DBASE$;
MAP G$ DGAM$;
MAP DL$ DLIST$;
MAP DR$ DREGS$;
MAP DF$I DFLAG$;
MAP U$DYNARY DPOOL$;
MAP U$DYNARY DEFER$;
MAP U$DYNARY DRACK$;
UNDECLARE $DTNS;
GLOBAL ROUTINE $DTNS(TYPE,STP,FORMAT,RTN)=
   BEGIN
   %CONVERT NUMERIC TO STRING
   CALLED BY $DPRNT, AMONG OTHERS

   /JS....................8/2/74
   %
   %RTN DETERMINES WHICH OF THE CONVERT ROUTINES TO CALL%

   LOCAL P2;
   MAP DDW$I P2;

   LOCAL P;
   MAP S$ P;
   LOCAL T,LEN;
   LOCAL R;
   MAP G$OPND R;
   MAP FP$I T;
   LOCAL LEN2;

   $DFRCA();
   $DFRCL();    %FORCE BOTH AC'S%

   IF (.RTN EQL RTRV$TCTNT) THEN
        BEGIN
        %ONE EACH NUMERIC - IS - STRING%
        $DGFIE(.STP,3);
        $DGSAD(.DREGS$[DR$BASE,3],.DREGS$[DR$OFFSET,3],3);
        $DGSYL($FPCNT(.FORMAT),4);
        $DRNCL(RTRV$TCTNT,2);
        DXLOGAC$_.DGAM$[G$ID];
        DXLOGCT$_.DGAM$[G$UCNT];
        RETURN;
        END
   ELSE
   IF (.TYPE EQL GV$RIP) THEN
        BEGIN
        %ALL REPORT ITEMS EXCEPT @TOP ARE HANDLED HERE%
        R_.DGAM$+1;
        $DGRIT(.STP,.R[1,G$RITYP],1); %GET REPORT ITEM TO REG 1%
        P2[DD$QP]_(IF .R[1,G$RITYP] EQL GV$PAGENO THEN #5000 ELSE #3000);
        P2[DD$PRSIZE]_.P2[DD$QPINT];
        P2[DD$TYPE]_DDV$1WD;
        P2[DD$CLASS]_DDV$CLASS5;
        $DRTMP(3,DDV$1WD,.DGAM$[G$ID]+1,.P2[DD$QP],1); %GET TEMP%
        $DCOPY(3,0);
        $DPCP(DTPV$SAVE4); %REPT ITEM NOW SAFE IN TEMP%
        $DMSTP(.DGAM$[G$ID],.FORMAT[FP$C],(.FORMAT[FP$C]+4)/5,6);
        %R6 HAS POINTER TO STRING TEMP%
        DLIST$[DL$UCNT,.DXLSTCT$]_.DGAM$[G$UCNT]; %PROPER COUNT%
        $DGSYL(.P2,4); %IMPROVED QP TO R4..3/19/75%
        $DGSYL(IF .R[1,G$RITYP] EQL GV$PAGENO THEN .DXFP4ZN$ ELSE
           .DXFP2ZN$,5); %GET A CAREFULLY PREPARED FP%
        $DGSAD(.DREGS$[DR$BASE,3],.DREGS$[DR$OFFSET,3],3);
        $DGSAD(.DREGS$[DR$BASE,6],.DREGS$[DR$OFFSET,6],6);
        $DGSYL($FPCNT(.FORMAT),7); %LENGTH TO R7..3/8/75%

        $DRNCL(.RTN,5); %AND THE CALL TO 'CONVERT'%
        $DGTMP(.DGAM$[G$ID]+1,-1); %CLEAR NUMERIC TEMP%
        RETURN; %QUICK AND DIRTY%
        END
   ELSE
   IF (.TYPE EQL GV$STP) OR (.TYPE EQL GV$LIT) THEN
        BEGIN
        IF .TYPE EQL GV$STP THEN $DGFIE(.STP,3) ELSE $DGLIE(.STP,-3);
        P_$SGSTE(.STP);
        DREGS$[DR$BASE,4]_.P[S$DDB]; %SET R4 TO QP%
        DREGS$[DR$OFFSET,4]_.P[S$DDFO];
        DREGS$[DR$DDTYPE,4]_DDV$1WD;
        DREGS$[DR$STP1,4]_DREGS$[DR$QP,4]_0;
        $SFRNCH(.P);
        $DCOPY(4,5);
        DREGS$[DR$OFFSET,5]_.DREGS$[DR$OFFSET,5]+1;  %GET FP%
        END
    ELSE
    IF (.TYPE EQL GV$NP) THEN
        BEGIN
        %NODE POINTER CODE FOR NOW%
        $DGOPD(1,3);
        P2[DD$QP]_.DREGS$[DR$QP,3];
        P2[DD$PRSIZE]_.P2[DD$QPINT]+.P2[DD$QPDEC]+1;
        P2[DD$TYPE]_.DREGS$[DR$DDTYPE,3];
        P2[DD$CLASS]_DDV$CLASS5;
        T_0;
     IF .P2[DD$QPINT] GTR 0 THEN
        BEGIN
        T[FP$XI]_1;
        T[FP$FI]_.P2[DD$QPINT]-1;
        T[FP$FS]_FPV$Z;
        END;

        T[FP$DI]_.P2[DD$QPDEC];
        T[FP$TYPE]_FPV$NUM;
        IF .T[FP$DI] GTR 0 THEN T[FP$SP2]_1; %D.P. ONLY IF FP$DI #0%
        $DGSYL(.P2,4);
        $DGSYL(.T,5);

        END
    ELSE
        0;


        $DGSAD(.DREGS$[DR$BASE,3],.DREGS$[DR$OFFSET,3],3);
        $DGSAD(DBV$STEMPBASE,.DXSBASE$,6);
        $DGSYL($FPCNT(.FORMAT),7);  %GET FP SIZE%
        $DRNCL(.RTN,5);

        %GENERATE STRING TEMPORARY%
        DXLSTCT$_.DXLSTCT$+1;
        %FATAL ERROR MESSAGE GOES HERE%
   T_.FORMAT;
   LEN2_$FPCNT(.FORMAT);
   LEN _ (.LEN2+4)/5;


        DLIST$[DL$LOC   ,.DXLSTCT$]_.DXSBASE$;
        IF .T[FP$TYPE] EQL FPV$STR THEN
           DLIST$[DL$QP,.DXLSTCT$]_.T[FP$C]
        ELSE %NUMERIC%
        DLIST$[DL$QP    ,.DXLSTCT$]_.LEN2;
        DLIST$[DL$CGFP  ,.DXLSTCT$]_.DGAM$[G$ID];
        DLIST$[DL$UCNT  ,.DXLSTCT$]_.DGAM$[G$UCNT];
        DLIST$[DL$DDTYPE,.DXLSTCT$]_DDV$STEMP;
        DLIST$[DL$MASK  ,.DXLSTCT$]_0;

        DXSUSE$_.DXSUSE$+1;  %ONE MORE IN USE%

        %NOW STORE THE QP%

    DREGS$[DR$BASE  ,0]_DBV$STEMPBASE;
    DREGS$[DR$OFFSET,0]_.DXSBASE$-1;
    DREGS$[DR$DDTYPE,0]_DDV$1WD;
    DREGS$[DR$QP,0]_DREGS$[DR$STP1,0]_0;

    $DPCP(DTPV$LSTO);   %QP IS NOW SAVED%


        %NOW COMPUTE TEMP SIZE%

    DXSBASE$_.DXSBASE$+.LEN+1; %ONE WORD OF QP%
    IF .DXSBASE$ GTR .DXSTMPSIZE$ THEN DXSTMPSIZE$ _ .DXSBASE$;



    END;
UNDECLARE $DCONV;

GLOBAL ROUTINE $DCONV(TYPE,STP,RTN)=
   BEGIN
   %PROCESS ONE EACH GV$CONVERT TOKEN

   PARAMETERS ARE:
        TYPE = TYPE OF OPERAND (GV$NP,GV$LIT,GV$RIP ETC)
        STP = STP TO LITERAL OR FIELD INCARNATION
                (OR TOKEN NUMBER,WHICHEVER IS DESIRED)
        FORMAT = FORMAT PICTURE FOR DESIRED CONVERSION

   /JS....................10/27/74
   NOW $DCONV HANDLES BOTH CONVERT STRING TO NUMERIC
   AND STRING TO DATE
   PARAMETERS ARE:
        TYPE...TYPE OF FIRST OPERAND(STP,LIT,ETC)
        STP....OPVAL OF FIRST OPERAND
        RTN....EITHER RTRV$TCVSD OR RTRV$TCVSN OR RTRV$TCTST
        (SEE..ITS PARAMETRIZED)
   /JS.....................2/15/75
   NOW $DCONV GENERATES 'IS' TEST FOR STRING TO NUMERIC
   THIS IS DONE BY SETTING UP THE FIRST THREE
   PARAMETERS(AS THOUGH WE WERE GOING TO CALL $TCVSN,ETC)
   THEN CALLING $TCTST, SETTING THE LOGICAL AC, AND RETURNING EARLY
   TODAY IS 3/22/75
   %

   LOCAL FORMAT;
   MAP FP$I FORMAT;
   LOCAL U,W,T,X;
   LOCAL P;
   MAP G$OPND P;

   P_.DGAM$+1; %P IS USED FOR OPERAND SUBFIELDS%
   IF (.TYPE NEQ GV$RIP) THEN
        BEGIN
        %CONVERT STRING TO NUMERIC%
        $DFRCA();
        $DFRCL(); %CLEAN HOUSE%

        $DGOPD(1,3); %FORST OPERAND TO R3%
        $DGSYL(.DREGS$[DR$QP,3],4);
        $DGSAD(.DREGS$[DR$BASE,3],.DREGS$[DR$OFFSET,3],3);

        %OPERAND IS NOW LOADED%
        IF .RTN EQL RTRV$TCTST THEN
           BEGIN
           %GENERATE AN 'IS' FOR STRING--> NUMERIC%
           $DGSYL(.DGAM$[G$OPND2],5);
           $DRNCL(RTRV$TCTST,3);
           DXLOGAC$_.DGAM$[G$ID];
           DXLOGCT$_.DGAM$[G$UCNT];
           RETURN;  %EARLY EXIT%
           END
        ELSE
        IF .RTN EQL RTRV$TCVSN THEN
           BEGIN
           %CONVERT STRING TO NUMERIC%
           FORMAT_.DGAM$[G$OPND2]; %FORMAT IS SECOND OPERAND%

        $DGSYL(.FORMAT,5); %AND THE FORMAT%

        U_.FORMAT[FP$FI]+.FORMAT[FP$XI];
        W_.FORMAT[FP$DI]+.FORMAT[FP$EI];
           END
%APOLOGIZE FOR POOR INDENTATION..%
        ELSE IF .RTN EQL RTRV$TCVSD THEN
           BEGIN
           %SIMPLE STRING ---> DATE CONVERSION%
           X_$DMKL2(0,0,.DGAM$[G$OPND2],.DGAM$[G$OPND3]); %GET DATE TEMP%
           $DGLIE(.X,5); %R5 => DATE TEMPLATE%
           $DGSAD(.DREGS$[DR$BASE,5],.DREGS$[DR$OFFSET,5],5);
           U_8; %DATE DEFAULT%
           W_0;
           END;

        T_.U+.W;

        IF .T LEQ 10 THEN X_DDV$1WD ELSE
        IF .T LEQ 20 THEN X_DDV$2WD ELSE
        IF .T LEQ 30 THEN X_DDV$3WD;

        %NOW GET A TEMP OF APPROPRIATE SIZE%
        $DRTMP(6,.X,.DGAM$[G$ID],(.U^9)+.W,.DGAM$[G$UCNT]);
        $DGSAD(.DREGS$[DR$BASE,6],.DREGS$[DR$OFFSET,6],6);
        $DRNCL(.RTN,4);  %SEE..PARAMETRIZED%

        END
   ELSE IF (.TYPE EQL GV$RIP) AND (.P[1,G$RITYP] EQL GV$TOP) THEN
        BEGIN
        %PROCESS A @TOP STRING%
        $DFRCA(); %SAFETY%
        $DFRCL();
        $DGRIT(.STP,GV$TOP,1);
        $DSETAC(3,4); %VERY IMPLEMENTATION SPECIFIC%
        $DGSYL(1,4); %THAT'S RIGHT..1 CHARACTER%
        IF .RTN EQL RTRV$TCTST THEN
           BEGIN
           %GENERATE A CAL TO $TCTST FOR TESTING%
           $DGSYL(.DGAM$[G$OPND2],5); %FORMAT%
           $DRNCL(RTRV$TCTST,3);
           DXLOGAC$_.DGAM$[G$ID];
           DXLOGCT$_.DGAM$[G$UCNT];
           RETURN; %EARLY OUT%
           END
        ELSE
        IF .RTN EQL RTRV$TCVSN THEN
           BEGIN
           FORMAT_.DGAM$[G$OPND2]; %GET ONE WORD FP%
        $DGSYL(.FORMAT,5); %AND THE FORMAT%
        U_.FORMAT[FP$FI]+.FORMAT[FP$XI];
        W_.FORMAT[FP$DI]+.FORMAT[FP$EI];
           END
        ELSE
        IF .RTN EQL RTRV$TCVSD THEN
        BEGIN
        %WHY WOULD ANYONE WANT TO MAKE THE RIDICULOUS CONSTRUCT
        PAGE.TOP AS 'MMDDYYYY'???
        ANYWAY..HERE IT IS%
           X_$DMKL2(0,0,.DGAM$[G$OPND2],.DGAM$[G$OPND3]);
           $DGLIE(.X,5); %DATE TEMPLATE%
           $DGSAD(.DREGS$[DR$BASE,5],.DREGS$[DR$OFFSET,5],5);
           U_8;
           W_0;  %DEFAULT%
           END;

        T_.U+.W;

        %SELECT DDV$ VALUE%
        IF .T LEQ 10 THEN X_DDV$1WD ELSE
        IF .T LEQ 20 THEN X_DDV$2WD ELSE
        IF .T LEQ 30 THEN X_DDV$3WD;

        %GET A RIGHT-SIZE TEMPORARY%
        $DRTMP(6,.X,.DGAM$[G$ID],(.U^9)+.W,.DGAM$[G$UCNT]);
        $DGSAD(.DREGS$[DR$BASE,6],.DREGS$[DR$OFFSET,6],6);
        $DRNCL(.RTN,4);

        END
   ELSE
        0;


   END;


%*******************%
END ELUDOM
 