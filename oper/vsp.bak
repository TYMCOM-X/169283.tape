FIND %BLOCK,%RELEASE,NO.CORE: ! DYNAMIC STORAGE ALLOCATOR

GLOBAL %SYM.POS,%NEW.SYM.TBL,%GET.SYM,%INIT.SYM.PAK,%R.LEAS.SYM.TBL
LOCAL %SYM.PAK,%SETUP.H,%STEP.H,%GET.NEW.H.TBL
GLOBAL %DMP,%D.NXT.SYM

DEF BLOCK.SIZE AS 262  !      UNIT OF STORAGE ALLOCATION
DEF ADR.SIZ AS 18              !SIZE OF ADDRSSS FIELD
DEF FLAG.SIZ AS 1              !SIZE OF FLAG FIELD
DEF FLAG.BITS AS BNOT 00 !BITS FOR FLAG FIELD
DEF SUM.SIZ AS BITS.PER.WORD-ADR.SIZ-FLAG.SIZ-6
 DEF   IS     AS =
 DEF   ISNT   AS #

!--------------------

!      HASH QUANTITIES:

 DEF H.LINKS AS 4 !            CONTROL WORDS REQUIRED FOR LINKED HASH TABLES
 DEF H.PRIME AS 251 ! PRIME NUMBER USED FOR HASHING:
       !      H.PRIME <= BLOCK.SIZE - H.LINKS
 DEF H.PRIME.2 AS 233 ! PRIME USED FOR      STEP CALCULATION
 DEF H.BIAS AS 9               ! STEP ADJUSTMENT:    H.BIAS_(H.PRIME-H.PRIME.2)/2

LOCAL H.SUM,H.START,H.STEP,H.TRY ! THESE USABLE BY ALL
LOCAL H.TBL(),H.MAX,H.FULL    ! HASH PACKAGES.

 DEF H.COUNT AS H.TBL(-2)      !      NUMBER OF ENTRIES IN THIS PORTION OF H.TBL
 DEF H.SUC     AS H.TBL(-1)   !      LINK TO SUC.CESSOR H.TBL

!      LINK IS USED WHEN HOLE IS FOUND AND H.COUNT>=H.FULL


 DEF   H.SCRAM AS OCT 111111111111    ! RANDOMIZING MULTIPLIER
 DEF   H.SHIFT                AS 6   ! SHIFT TO ELIMINATE BIASED LOW BITS

!-------------------------------------------
!
!      SYMBOL TABLE !
!
       GLOBAL SYM.BUF(0:64) !         NAME PACKING BUFFER
       LOCAL SYM.MASK         !      A CODE-WORD UNPACKING MASK
       LOCAL N.LEFT           ! WORDS LEFT IN TEXT BLOCK
       LOCAL TEXT.P           !      POINTER BEFOR NEXT FREE TEXT WORD
       DEF SYM.N AS SYM.TBL(-3) ! NUMBER OF UNITS PER HASH BLOCK
       DEF SYM.V AS SYM.TBL(-4) ! VIRGIN VALUE FOR HASH TABLES

!****************************************************

!      SYMBOL TABLES ARE IN GENERAL LINKED LISTS OF MULTI-BLOCKS.
!      ONLY THE FIRST SECTION OF SUCH BLOCKS IS UNIFORMLY DEFINED.

!      THE PRIMARY SYMBOL HASH TABLE IS LINKED LIST OF DOUBLE-BLOCKS.
!      THE FIRST BLOCK.SIZE WORDS OF EACH IS THE "NAME DESCRIPTOR"
!      SECTION AND IS USED FOR ALL ACTUAL HASHING OPERATIONS.
!      FOR EACH NAME-DESCRIPTOR, AN ID-DESCRIPTOR IS FOUND BLOCK.SIZE
!      WORDS LATER IN THE SECOND SECTION.

!      A SYMBOL TO BE ENTERED IN THE SYMBOL TABLE IS PLACED IN SYM.BUF
!      SYM.BUF(1) CONTAINS THE FIRST CPW CHARS
!      SYM.BUF(N) CONTAINS THE LAST FEW CHARS AND IS FILLED OUT 
!      WITH NILS IF EXTRA ROOM IS LEFT.
!      SYM.BUF(0) IS SET TO N.

!      SYMBOLS MUST CONTAIN FROM 1 TO 256 CHARACTERS.

!      IF N=1 THEN THE NAME-DESCRIPTOR IS SIMPLY SYM.BUF(1).

!      IF N>1 THEN NAME-DESCRIPTOR HAS THE STRUCTURE:

!      [FLAG.SIZ,SUM.SIZ,6,ADR.SIZ]*[FLAG.BITS,HASH,N,P]

!      WHERE HASH IS PART OF THE HASH CALC FOR THE SYMBOL AND
!      WHERE P IS THE WORD-ADDRESS OF THE NAME-BLOCK.     THE NAME
!      BLOCK HAS THE STRUCTURE:

!      SYM.BUF(1)
!      SYM.BUF(2)
!      SYM.BUF(3) ...
!      SYM.BUF(N)
!
!      THE NAME-BLOCK'S ARE STORED IN A SET OF NON-LINKED DATA BLOCKS
!      SEPARATELY OBTAINED FROM THE HASH DOUBLE-BLOCKS.

!      THE INITIAL HASH DOUBLE BLOCK IS SYM.TBL().

!      A SINGLE TEXT OVERFLOW AREA IS USED FOR ALL SYMBOL TABLES.

!      THE PROCEDURE %SYM.POS LOOKS SYM.BUF() UP IN SYM.TBL() AND
!      ENTERS IT IF ABSENT.   SYM.POS RETURNS THE ADDRESS OF THE 
!      NAME DESCRIPTOR.

!      THE PROCEDURE GET.SYM (POS)    TAKES THE ADDRESS OF A 
!      A NAME-DESCRIPTOR AND UNPACKS IT INTO SYM.BUF.


!*********************************************************************

%SYM.PAK       !              SYMBOL TABLE PACKAGE


!
!------------------------

%SETUP.H

       H.SUM_ABS(H.SUM)
       H.START_H.SUM MOD H.PRIME
       H.STEP_H.BIAS+H.SUM MOD H.PRIME.2
       H.MAX_H.TBL+H.PRIME

       RETURN
END SETUP.H

%STEP.H

       H.TRY_H.TRY+H.STEP
       IF H.TRY>=H.MAX THEN H.TRY_H.TRY-H.PRIME
       RETURN
END STEP.H

%GET.NEW.H.TBL(N,V)

       IF H.SUC=V THEN H.SUC_H.LINKS+BLOCK(2*N,V,NO.CORE)
       H.TBL_H.SUC
       H.MAX_H.TBL+H.PRIME

       RETURN
END GET.NEW.H.TBL


!----------------------------------

!      SYMBOL TABLE LOOKUP ROUTINE:

%SYM.POS ( SYM.TBL() )

       LOCAL WORD,I,P

       H.TBL_SYM.TBL
       IF SYM.BUF(0)=1 THEN GO SHORT.NAME

       H.SUM_SYM.BUF(I_1)

SCRAM:         H.SUM_(H.SUM ROTL 5) BXOR SYM.BUF(INC I)
       IF I ISNT SYM.BUF(0) THEN GO SCRAM
       H.SUM_(H.SUM*H.SCRAM) ROTR H.SHIFT
       WORD_[SUM.SIZ,6,ADR.SIZ,FLAG.SIZ]*&
       [H.SUM,SYM.BUF(0),0,FLAG.BITS]

       SETUP.H
NXT.TBL:       H.TRY_H.START+H.TBL
TRY1:  IF ^H.TRY IS SYM.V THEN GO ENTER
       IF ^H.TRY BAND SYM.MASK IS WORD THEN GO COMPARE
TRY2:  STEP.H;                GO TRY1

COMPARE:       I_0; P_((^H.TRY BAND (BNOT SYM.MASK)) SHR FLAG.SIZ)-1
COMP1:         IF SYM.BUF(INC I) ISNT ^INC P THEN GO TRY2
       IF I ISNT SYM.BUF(0) THEN GO COMP1 ELSE RETURN H.TRY+BLOCK.SIZE

ENTER:         IF H.COUNT >= H.FULL THEN GO NEW.TBL
       INC H.COUNT
 IF N.LEFT<SYM.BUF(0) THEN [TEXT.P_BLOCK(2,0,NO.CORE)-1;N.LEFT_BLOCK.SIZE]
!      PLACE ADDRESS INTO WORD FOR SYMBOL ENTRY
       N.LEFT_N.LEFT-SYM.BUF(0);      ^H.TRY _ WORD +(TEXT.P+1) SHL 1
       I_0
ENT1:  ^INC TEXT.P_SYM.BUF(INC I) ; IF I ISNT SYM.BUF(0) THEN GO ENT1
       RETURN H.TRY+BLOCK.SIZE


NEW.TBL:       GET.NEW.H.TBL(SYM.N,SYM.V); GO NXT.TBL

!---

SHORT.NAME:    H.SUM_SYM.BUF(1) SHR 1; SETUP.H
SH.NXT.TBL:    H.TRY_H.START+H.TBL
SH.TRY:        IF ^H.TRY= SYM.BUF(1) THEN RETURN H.TRY+BLOCK.SIZE
       IF ^H.TRY # SYM.V THEN [STEP.H;    GO SH.TRY]
IF H.COUNT<H.FULL THEN &
       [INC H.COUNT; ^H.TRY_SYM.BUF(1) BAND HEX FFFFFFFFE; RETURN H.TRY+BLOCK.SIZE]
       GET.NEW.H.TBL(SYM.N,SYM.V); GO SH.NXT.TBL


!------

%NEW.SYM.TBL ( N ,V )

       LOCAL SYM.TBL()
       SYM.TBL_H.LINKS+BLOCK(2*N,V,NO.CORE)
       SYM.N_N; SYM.V_V

       RETURN SYM.TBL
END NEW.SYM.TBL
END SYM.POS

!--------------------------------------

%R.LEAS.SYM.TBL(SYM.TBL())

  LOCAL N,V
  N _ SYM.N; V _ SYM.V
  H.TBL _ SYM.TBL
  LOOP DO
    H.TBL _ H.SUC
    RELEASE(2*N,SYMTBL-H.LINKS,NOCORE)
    WHILE H.TBL # V
    SYM.TBL _ H.TBL
    END
  RETURN

END R.LEAS.SYM.TBL

!---------------------------------------

!      UNPACK A SYMBOL INTO SYM.BUF()

%GET.SYM (SYM.POSIT)

       LOCAL C,N,P

       SYM.POSIT_SYM.POSIT-BLOCK.SIZE

       [SUM.SIZ,6,ADR.SIZ,FLAG.SIZ]*[,N,P,C]_^SYM.POSIT

       IF C   = 0 THEN [SYM.BUF(0)_1;&
       SYM.BUF(1)_^SYM.POSIT;RETURN]

       SYM.BUF(0)_N; SYM.BUF(N_1)_^P

NEXT:  SYM.BUF(INC N)_^INC P; IF N ISNT SYM.BUF(0) THEN GO NEXT

       RETURN
END GET.SYM

!-------------------------

!
%INIT.SYM.PAK  !              INITIALIZE ENTIRE SYMBOL TABLE PACKAGE:


       H.FULL _ 213 ! SUGGESTED HASH LOAD (85% PACKED)
       N.LEFT_0; TEXT.P_0
       SYM.MASK_[SUM.SIZ,6,ADR.SIZ,FLAG.SIZ]* &
       [BNOT 0,BNOT 0,0,BNOT 0]
       

       RETURN
END INIT.SYM.PAK

!-----------

!      DUMP ALL SYMBOLS OF A SYMBOL TABLE:



%DMP (SYM.TBL(),DONE)

       LOCAL P
       P_SYMTBL-1
       LOCAL PMAX
       PMAX_P+H.PRIME
       RETURN

%D.NXT.SYM     ! DUMP THE NEXT SYMBOL

D1:    IF INC P > PMAX THEN GO NXT.LINK
       IF ^P IS SYM.V THEN GO D1
       RETURN P+BLOCK.SIZE

NXT.LINK:      P_^(PMAX-H.PRIME); IF P=SYM.V THEN GO ^DONE
       DEC P; PMAX_P+H.PRIME; GO D1

       RETURN
END DNXTSYM
END DMP

END SYM.PAK
