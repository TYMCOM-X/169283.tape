FIND %XPUTC, %XMSG, %XPUT, %GRAB, %UNGRAB, STATUS, %SETSIZE, %UNWIND
FIND DBLOCK(), IRQOFF, %ERROR, %TERROR, %RDLINE, HLPOFF, %SHOVER
FIND LINPTR, PRMOFF, %SPLIT, %RECFND, %FMATCH, %MKLD1, %DCTERR
FIND STATAB(1), %FNDID, %CHREAD, %CLRIN, %IXMSG, %YESNO, %ADDSUB
FIND %OPEND, ERRET:, %SET.CORE.FILE, RDCT, CDNOFF, DNOFF, STALEN
FIND %ADDON, %EXOPEND, %RBASE, %RNUM, %NEW.DBLK, %SETREC
LOCAL %SPUT, %SMSG, %STEST, FRST.FLG, DRAY(0:51), %RDNAM

GLOBAL %PNAME1, %WRSTG, %WRSTA, %WRUSTA, %PFLD, %RNAME1, %RDSTG
GLOBAL %RDSTA, %RFLD, %STORE, %RFIL, %RDUSTA

%SPUT (CHAR)
GLOBAL EDPTR, EBUFF(0:52)

XPUT (CHAR)
NCHV EDPTR _ CHAR
RETURN
END SPUT

%SMSG (MSG)
LOCAL TPTR, TCHR, LFLAG, CFLAG

TPTR _ CHPT ( MSG, -1 )
LFLAG _ CFLAG _ 0

LOOP DO
  WHILE TCHR _ NCHV TPTR # EOLIT

  EIF TCHR = CARRET THEN DO
    IF LFLAG # 0 THEN &
      LFLAG _ 0 &
      ELSE [ SPUT(CARRET); CFLAG _ -1]
    END
  ORIF TCHR = LNFEED THEN DO
    IF CFLAG # 0 THEN &
      CFLAG _ 0 &
      ELSE [ SPUT(LNFEED); LFLAG _ -1]
    END
  ELSE [ SPUT(TCHR); LFLAG _ CFLAG _ 0]
END

RETURN
END SMSG

%STEST (CHAR)
IF FRST.FLG <== -1 # 0 THEN [SPUT(CHAR); SPUT($ )]
RETURN
END STEST

%PNAME1 (DUM1, DUM2, FLDFRM() )
XPUT(CARRET)
XMSG(@FLDFRM(@IRQOFF))
SMSG (FADD(RNAM))
XPUT(CARRET)
RETURN
END PNAME1

%WRSTG (DUM1, DUM2, FLDFRM(), BIT, OFF)
XMSG(@FLDFRM(@IRQOFF))
SMSG(FADD(RECORD)+OFF)
XPUT(CARRET)
RETURN
END WRSTG

!
! PARTS OF THIS ROUTINE ARE IN NO SMALL WAY DIRECTLY ATTRIBITUBLE
! TO A PROLONGED CONVERSATION WITH WALT MAIN.
!
%WRUSTA (DUM1, DUM2, FLDFRM(), BIT, OFF)
LOCAL %WRASTA, STNDX
STNDX _ 1
WRASTA
RETURN
%%WRSTA (DUM1, DUM2, FLDFRM(), BIT, OFF)
STNDX _ 2
WRASTA
RETURN
%WRASTA 
FIND STALEN, %MKLD1, %BIT.CNT

LOCAL MAX.CNT, TMP.CNT, TMP1, TMP2, TMP3, TMP4
LOCAL SAVNDX, DBITS, I

XMSG(@FLDFRM(@IRQOFF))

TMP1 _ ^(FADD(RECORD)+OFF)

FRST.FLG _ DBITS _ 0

LOOP DO

  WHILE TMP1 # DBITS

  I _ MAX.CNT _ 0

  REPEAT STALEN DO
    IF (DBITS BAND TMP2 _ MKLD1(STATAB(I),STNDX) # TMP2) &
    AND (TMP1 BAND TMP2 = TMP2) THEN &
    IF TMP.CNT _ BIT.CNT(TMP2) > MAX.CNT THEN &
    [SAVNDX _ I; TMP4 _ TMP2; MAX.CNT _ TMP.CNT]
    INC I
  END

  WHILE MAX.CNT # 0

  DBITS BOR _ TMP4

  STEST($,)
  SMSG(STATAB(SAVNDX) BAND OCT 777777)

END

IF TMP1 # DBITS THEN [STEST($,); XMSG("??")]
XPUT(CARRET)

RETURN
END WRASTA
END WRUSTA

%PFLD (DUM1, DUM2, FLDFRM(), BIT, OFF)
FIND %FNDSTG, %OPEND, FDCT
LOCAL TRAY(), FLDID, PERR:, FNUM, I

XMSG(@FLDFRM(@IRQOFF)); XPUT(CARRET)

TRAY _ (FADD(RECORD)+OFF)

GRAB(1)
FNUM _ OPEND(@FDCT, 0, 0)

FOR I _ 1 TO TRAY(0) DO

  [12,12,12]*[FLDID, BIT, OFF] _ TRAY(I)
  XMSG("   ")
  XMSG(FNDSTG(FNUM, PERR, PERR, FLDID, -1, -1, -1, -1))
  XPUT(CARRET)
END

CLOSE (FNUM)
UNGRAB(0)

RETURN

PERR: ERROR("ERROR READING FIELD DEFINITION$")
END PFLD

%RNAME1 (DUM1, DUM2, FLDFRM(), BIT, OFF)

LOOP DO

  WHILE RDNAM( FLDFRM, BIT, OFF) > 0

  TERROR("ERROR - NAME ALREADY DEFINED$", 0)

END

RETURN

END RNAME1


%RDNAM (FLDFRM(), BIT, OFF)
LOCAL CNT, OPTR, LST, LND, FNUM, TMP

SPLIT( FLDFRM(@PRMOFF),3, 24,0,  3,@LST, 3,@LND)

LOOP DO
  RDLINE( @FLDFRM(@IRQOFF), @FLDFRM(@HLPOFF), LST, LND)
  OPTR _ CHPT(DRAY,-1)
  LOOP WHILE NCHV LINPTR =$ 
  PCHV LINPTR
  CNT _ 1
  WHILE NCHV OPTR _ NCHV LINPTR # EOLIT THEN INC CNT
  PCHV LINPTR
  WHILE CNT = 1
  TERROR ("NAME MUST NOT BE NULL$",0)
  XMSG( @FLDFRM(@HLPOFF) )
END

SHOVER (RNAM, DRAY, -1, (CNT+4)/5, 0, 0)
GRAB(0)
FNUM _ OPEND(FADD(DFORM) + @DNOFF, 0, 0)
TMP _ FNDID(FNUM,0,0,DRAY,-1,-1)
CLOSE(FNUM)
UNGRAB(0)
RETURN TMP
END RDNAM

%RFIL

RDSTG

IF YESNO("  CREATE FILE? ", &
"TYPE 'YES' IF YOU WANT ME TO CREATE THE FILE. TYPE 'NO' IS IT$&
ALREADY EXISTS.$") = 0 THEN DO

RDLINE("  INITIAL NUMBER OF EXPECTED ENTRIES: ",&
"ENTER INITIAL NUMBER OF ENTRIES TO BE ALLOWED FOR IN THE HASH TABLE.$&
ENTER ZERO IF YOU STILL DON'T UNDERSTAND.$", 2, 1)

GRAB(0)
CLOSE( OPEND( FADDS(RECORD,@DNOFF), 1, 1, RNUM(10) ) )
UNGRAB(0)

END

RETURN
END RFIL

%RDSTG (DUM1, DUM2, FLDFRM(), BIT, OFF)
LOCAL FLEN, LST, LND, OPTR, TCNT, CNT, NPTR, FLG

SPLIT (FLDFRM(@PRMOFF),5, 6,0, 3,@FLG, 6,@FLEN, 9,0, 3,@LST, 3,@LND)
TCNT _ (IF FLG = 3 THEN 260 ELSE FLEN*5)
NPTR _ CHPT( DRAY, -1 )

LOOP DO
  RDLINE( @FLDFRM(@IRQOFF), @FLDFRM(@HLPOFF), LST, LND)
  OPTR _ NPTR
  CNT _ 0

  LOOP WHILE INC CNT <= TCNT AND NCHV OPTR _ NCHV LINPTR # EOLIT
  PCHV LINPTR

  WHILE CNT > TCNT

  TERROR("STRING TOO LONG.$", 0)
  CHV OPTR _ EOLIT
  XMSG( DRAY )
  XMSG("<<$")
END

SETREC (OFF + (CNT+4)/5 -1 )
OPTR _ CHPT (FADD(RECORD) + OFF, -1)
LOOP WHILE NCHV OPTR _ NCHV NPTR # EOLIT

RETURN
END RDSTG

%RDUSTA
LOCAL %READ.STA
READ.STA ( -1 )
RETURN

%%RDSTA
READ.STA ( 0 )
RETURN

%READ.STA (SFLG, DUM2, FLDFRM(), BIT, OFF)
LOCAL %STAT.SCAN, TMP, LST, LND

SPLIT( FLDFRM(@PRMOFF),3, 24,0, 3,@LST, 3,@LND)

LOOP DO
  RDLINE( @FLDFRM(@IRQOFF), @FLDFRM(@HLPOFF), LST, LND)
  WHILE TMP _ STAT.SCAN < 0
  XMSG("RE-ENTER LINE.$")
END

RECFND(OFF)

STORE(OFF, TMP)

RETURN

%STAT.SCAN
LOCAL ANS, TMP, LPTR, SPTR, LRAY(0:51)

ANS _ 0

LOOP DO
  LOOP WHILE NCHV LINPTR =$ 
  WHILE CHV LINPTR # EOLIT
  PCHV LINPTR
  LPTR _ SPTR _ CHPT( LRAY, -1)
  LOOP WHILE EOLIT # NCHV LPTR _ NCHV LINPTR # $,
  CHV LPTR _ EOLIT
  IF CHV LINPTR = EOLIT THEN PCHV LINPTR

  IF TMP _ FMATCH(STATAB, STALEN, SPTR, -1,SFLG,-1) < 0 THEN RETURN TMP
  ANS BOR _ MKLD1(STATAB(TMP), 2)
END

PCHV LINPTR
RETURN ANS
END STAT.SCAN

END READ.STA

END RDU.STA

%STORE (OFF, TMP)
RECFND(OFF)
DBLOCK( (DBLOCK( LOCTAB(RECORD) ) BAND OCT 777777) + OFF ) _ TMP
RETURN
END STORE

%RFLD (DUM1, DUM2, TFLDFRM(), BIT, TOFF)
LOCAL FRAY(), TMP, TYP, FLEN, DWORD(0:1), TRAY(), ERR:, TMP2, FRAY.ID
LOCAL %OPEN.FILE, FDNUM, NPTR, %LOOP1, %LOOP2, FLDFRM()

DEF OLD.ID AS FRAY(0)
DEF OFRAY AS FRAY(1)
DEF LST AS FRAY(2)
DEF LND AS FRAY(3)
DEF OFF AS FRAY(4)
DEF CPTR AS FRAY(5)
DEF BPTR AS FRAY(6)
DEF WPTR AS FRAY(7)
DEF IRQ AS FRAY(8)
DEF FLDID AS FRAY(9)
DEF EFLAG AS FRAY(10)
DEF OFLDFRM AS FRAY(11)
DEF FIL2 AS FRAY(12)
DEF ODB AS FRAY(13)
DEF LRAY(X) AS FRAY(14+X)

TMP _ FRAY
[FRAY; TMP2] _ DOUBLE GRAB(66)
OFRAY _ TMP
OFF _ TOFF
OFLDFRM _ FLDFRM <== TFLDFRM
OLD.ID _ FRAY.ID <== TMP2

SPLIT( FLDFRM(@PRMOFF),3, 24,0, 3,@LST, 3,@LND)

LOOP DO
  CPTR _ OFF
  BPTR _ 0
  WPTR _ 2
  IRQ _ @FLDFRM(@IRQOFF)
  EFLAG _ 0

  OPEN.FILE

  TMP _ LOOP1
  CLOSE (FDNUM)
  UNGRAB(0)
  WHILE TMP # 0

END

STORE (OFF, CPTR-OFF)
SETREC (CPTR)

PCHV LINPTR

FRAY _ OFRAY
FRAY.ID _ OLD.ID
FLDFRM _ OFLDFRM
UNGRAB(0)

RETURN

ERR: DCTERR; GO ERRET


%LOOP1

LOOP DO
  RDLINE( IRQ <== " ? ", @FLDFRM(@HLPOFF) )
  NPTR _ CHPT( @LRAY(0), -1)
  LOOP WHILE NCHV LINPTR = $ 
  IF CHV LINPTR = EOLIT THEN RETURN 0
  PCHV LINPTR
  IF EFLAG # 0 THEN DO
    TERROR("PREVIOUS FIELD HAD UNLIMITED LENGTH AND MUST BE LAST FIELD.&
$RE-ENTER ALL FIELD NAMES.$")
    RETURN -1
  END
  LOOP WHILE NCHV NPTR _ NCHV LINPTR # EOLIT
  PCHV LINPTR
  LOOP2
END

END LOOP1


%LOOP2

  LOOP DO
    FLDID _ FNDID( FDNUM, 0, 0, @LRAY(0), 0, DWORD)
    EIF FLDID > 0 THEN DO
      TRAY _ GRAB ( DWORD(1) )
      CHREAD( FDNUM, ERR, ERR, 1, TRAY, DWORD(0), DWORD(1) )

      SPLIT( TRAY(@PRMOFF),3, 6,0, 3,@TYP, 6,@FLEN )
      UNGRAB(0)

      EIF TYP = 0 THEN FLEN _ 0
      ORIF TYP = 1 THEN FLEN * _ 36
      FIF TYP = 3 THEN [ FLEN _ 36; EFLAG _ -1]

      IF (FLEN <= 32 < BPTR + FLEN) OR (FLEN > 32 AND BPTR # 0 ) &
       THEN [BPTR _ 0; INC WPTR]

      STORE( INC CPTR, [12,12,12]*[FLDID,BPTR,WPTR] )
      FRAY _ RBASE( FRAY.ID )

      [ TMP; BPTR ] _ ( BPTR + FLEN ) DIVMOD 36
      WPTR + _ TMP
      RETURN
    END
    ORIF FLDID # -108 THEN DO
      DCTERR
      CLRIN
      RETURN
    END
    ELSE DO
      IXMSG(@LRAY(0)); IXMSG(" - NOT DEFINED.$")
      CLRIN
      EIF YESNO("WOULD YOU LIKE TO DEFINE IT? ", &
       "TYPE 'YES' IF YOU WANT TO DEFINE THE FIELD. TYPE 'NO'&
   IF$YOU MADE A MISTAKE.$") # 0 THEN DO
        XMSG("RE-ENTER FIELD NAMES BEGINNING WITH ")
        XMSG(@LRAY(0))
        XPUT(CARRET)
        RETURN
      END
      ELSE DO
        CLOSE(FDNUM)
        UNGRAB(0)
        XMSG("$$$ADD ")
        SET.CORE.FILE( @FLDFRM(@CDNOFF) )
        ODB _ DBLOCK
        NEW.DBLK
        ADDSUB
        UNGRAB ( DBLOCK(1) )
        DBLOCK _ ODB
        XMSG("$$$")
        OPEN.FILE
      END
    END

  END

END LOOP2


%OPEN.FILE
LOCAL RAY(), RDNUM
FIND PBLEN
[;FIL2] _ DOUBLE GRAB(@PBLEN)
GRAB(1)
RDNUM _ OPEND( @RDCT, 0, 0)
FNDID( RDNUM, ERR, ERR, @FLDFRM(@CDNOFF), 0, DWORD)
RAY _ ADDON( 0, DWORD(1) )
CHREAD (RDNUM, ERR, ERR, 1, RAY, DWORD(0), DWORD(1) )
CLOSE(RDNUM)
FDNUM _ EXOPEND( @RAY(@DNOFF), 0, 0, FIL2, -1)
UNGRAB(0)
RETURN
END OPEN.FILE

END RFLD
    